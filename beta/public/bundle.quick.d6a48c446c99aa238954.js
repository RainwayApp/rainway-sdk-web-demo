/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[2].use[1]!./node_modules/postcss-loader/src/index.js??ruleSet[1].rules[2].use[2]!./src/style.css":
/*!****************************************************************************************************************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[2].use[1]!./node_modules/postcss-loader/src/index.js??ruleSet[1].rules[2].use[2]!./src/style.css ***!
  \****************************************************************************************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

// Imports
var ___CSS_LOADER_API_IMPORT___ = __webpack_require__(/*! ../node_modules/css-loader/dist/runtime/api.js */ "./node_modules/css-loader/dist/runtime/api.js");
exports = ___CSS_LOADER_API_IMPORT___(false);
exports.push([module.id, "@import url(https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=Questrial&family=Poppins:wght@400;500;600&family=Barlow:wght@400;500;600;700&display=swap);"]);
// Module
exports.push([module.id, ":root {\n  --logo-font-family: \"Poppins\", sans-serif;\n  --body-font-family: \"Inter\", sans-serif;\n  --heading-font-family: \"Poppins\", sans-serif;\n  --header-font-family: \"Questrial\", sans-serif;\n\n  /* Slate Blue */\n  --clr-primary-100: #e0e2f4;\n  --clr-primary-200: #bfc3ec;\n  --clr-primary-300: #9fa7e2;\n  --clr-primary-400: #7e89d8;\n  --clr-primary-500: #616acb;\n  --clr-primary-600: #4854bb;\n  --clr-primary-700: #3943a2;\n  --clr-primary-800: #2f3885;\n  --clr-primary-900: #242b67;\n  --clr-primary-950: #191e4d;\n  --clr-primary-975: #0f122e;\n  --clr-primary-999: #05060f;\n\n  /* Mantis */\n  --clr-green-100: #f4fbf0;\n  --clr-green-200: #dff1d2;\n  --clr-green-300: #bfe2a6;\n  --clr-green-400: #a0d57b;\n  --clr-green-500: #8ccc61;\n  --clr-green-600: #6fad45;\n  --clr-green-700: #5b8d38;\n  --clr-green-800: #33571c;\n  --clr-green-900: #1e2f12;\n\n  /* Dandelion */\n  --clr-yellow-100: #fffdf1;\n  --clr-yellow-200: #fdf7db;\n  --clr-yellow-300: #faedb7;\n  --clr-yellow-400: #f7e695;\n  --clr-yellow-500: #f9dc5c;\n  --clr-yellow-600: #e5c343;\n  --clr-yellow-700: #9f8004;\n  --clr-yellow-800: #504102;\n  --clr-yellow-900: #282001;\n\n  /* Tomato */\n  --clr-red-100: #fff5f3;\n  --clr-red-200: #fbded8;\n  --clr-red-300: #f0b5a9;\n  --clr-red-400: #fa927b;\n  --clr-red-500: #fc6948;\n  --clr-red-600: #e9502f;\n  --clr-red-700: #cb3413;\n  --clr-red-800: #a30303;\n  --clr-red-900: #5c1111;\n\n  /* Neutrals */\n  --clr-neutral-0: #ffffff;\n  --clr-neutral-50: #f4f4f6;\n  --clr-neutral-100: #e9e9ec;\n  --clr-neutral-200: #d3d3d9;\n  --clr-neutral-300: #b3b3bc;\n  --clr-neutral-400: #9d9da9;\n  --clr-neutral-450: #868695;\n  --clr-neutral-500: #686877;\n  --clr-neutral-600: #5f5f6c;\n  --clr-neutral-700: #4c4c56;\n  --clr-neutral-800: #393941;\n  --clr-neutral-850: #2c2c33;\n  --clr-neutral-900: #26262c;\n  --clr-neutral-925: #1e1e23;\n  --clr-neutral-950: #131316;\n  --clr-neutral-975: #09090b;\n  --clr-neutral-990: #040405;\n  --clr-neutral-1000: #000000;\n}\n\n.spacer {\n  flex-grow: 1;\n}\n\n/** Margin and Padding helpers */\n.m-t-0 {\n  margin-top: 0px !important;\n}\n.p-t-0 {\n  padding-top: 0px !important;\n}\n.m-b-0 {\n  margin-bottom: 0px !important;\n}\n.p-b-0 {\n  padding-bottom: 0px !important;\n}\n.m-l-0 {\n  margin-left: 0px !important;\n}\n.p-l-0 {\n  padding-left: 0px !important;\n}\n.m-r-0 {\n  margin-right: 0px !important;\n}\n.p-r-0 {\n  padding-right: 0px !important;\n}\n.m-t-4 {\n  margin-top: 4px !important;\n}\n.p-t-4 {\n  padding-top: 4px !important;\n}\n.m-b-4 {\n  margin-bottom: 4px !important;\n}\n.p-b-4 {\n  padding-bottom: 4px !important;\n}\n.m-l-4 {\n  margin-left: 4px !important;\n}\n.p-l-4 {\n  padding-left: 4px !important;\n}\n.m-r-4 {\n  margin-right: 4px !important;\n}\n.p-r-4 {\n  padding-right: 4px !important;\n}\n.m-t-8 {\n  margin-top: 8px !important;\n}\n.p-t-8 {\n  padding-top: 8px !important;\n}\n.m-b-8 {\n  margin-bottom: 8px !important;\n}\n.p-b-8 {\n  padding-bottom: 8px !important;\n}\n.m-l-8 {\n  margin-left: 8px !important;\n}\n.p-l-8 {\n  padding-left: 8px !important;\n}\n.m-r-8 {\n  margin-right: 8px !important;\n}\n.p-r-8 {\n  padding-right: 8px !important;\n}\n.m-t-16 {\n  margin-top: 16px !important;\n}\n.p-t-16 {\n  padding-top: 16px !important;\n}\n.m-b-16 {\n  margin-bottom: 16px !important;\n}\n.p-b-16 {\n  padding-bottom: 16px !important;\n}\n.m-l-16 {\n  margin-left: 16px !important;\n}\n.p-l-16 {\n  padding-left: 16px !important;\n}\n.m-r-16 {\n  margin-right: 16px !important;\n}\n.p-r-16 {\n  padding-right: 16px !important;\n}\n.m-t-24 {\n  margin-top: 24px !important;\n}\n.p-t-24 {\n  padding-top: 24px !important;\n}\n.m-b-24 {\n  margin-bottom: 24px !important;\n}\n.p-b-24 {\n  padding-bottom: 24px !important;\n}\n.m-l-24 {\n  margin-left: 24px !important;\n}\n.p-l-24 {\n  padding-left: 24px !important;\n}\n.m-r-24 {\n  margin-right: 24px !important;\n}\n.p-r-24 {\n  padding-right: 24px !important;\n}\n.m-t-32 {\n  margin-top: 32px !important;\n}\n.p-t-32 {\n  padding-top: 32px !important;\n}\n.m-b-32 {\n  margin-bottom: 32px !important;\n}\n.p-b-32 {\n  padding-bottom: 32px !important;\n}\n.m-l-32 {\n  margin-left: 32px !important;\n}\n.p-l-32 {\n  padding-left: 32px !important;\n}\n.m-r-32 {\n  margin-right: 32px !important;\n}\n.p-r-32 {\n  padding-right: 32px !important;\n}\n.m-t-40 {\n  margin-top: 40px !important;\n}\n.p-t-40 {\n  padding-top: 40px !important;\n}\n.m-b-40 {\n  margin-bottom: 40px !important;\n}\n.p-b-40 {\n  padding-bottom: 40px !important;\n}\n.m-l-40 {\n  margin-left: 40px !important;\n}\n.p-l-40 {\n  padding-left: 40px !important;\n}\n.m-r-40 {\n  margin-right: 40px !important;\n}\n.p-r-40 {\n  padding-right: 40px !important;\n}\n.m-t-48 {\n  margin-top: 48px !important;\n}\n.p-t-48 {\n  padding-top: 48px !important;\n}\n.m-b-48 {\n  margin-bottom: 48px !important;\n}\n.p-b-48 {\n  padding-bottom: 48px !important;\n}\n.m-l-48 {\n  margin-left: 48px !important;\n}\n.p-l-48 {\n  padding-left: 48px !important;\n}\n.m-r-48 {\n  margin-right: 48px !important;\n}\n.p-r-48 {\n  padding-right: 48px !important;\n}\n.m-t-56 {\n  margin-top: 56px !important;\n}\n.p-t-56 {\n  padding-top: 56px !important;\n}\n.m-b-56 {\n  margin-bottom: 56px !important;\n}\n.p-b-56 {\n  padding-bottom: 56px !important;\n}\n.m-l-56 {\n  margin-left: 56px !important;\n}\n.p-l-56 {\n  padding-left: 56px !important;\n}\n.m-r-56 {\n  margin-right: 56px !important;\n}\n.p-r-56 {\n  padding-right: 56px !important;\n}\n.m-t-64 {\n  margin-top: 64px !important;\n}\n.p-t-64 {\n  padding-top: 64px !important;\n}\n.m-b-64 {\n  margin-bottom: 64px !important;\n}\n.p-b-64 {\n  padding-bottom: 64px !important;\n}\n.m-l-64 {\n  margin-left: 64px !important;\n}\n.p-l-64 {\n  padding-left: 64px !important;\n}\n.m-r-64 {\n  margin-right: 64px !important;\n}\n.p-r-64 {\n  padding-right: 64px !important;\n}\n.m-t-72 {\n  margin-top: 72px !important;\n}\n.p-t-72 {\n  padding-top: 72px !important;\n}\n.m-b-72 {\n  margin-bottom: 72px !important;\n}\n.p-b-72 {\n  padding-bottom: 72px !important;\n}\n.m-l-72 {\n  margin-left: 72px !important;\n}\n.p-l-72 {\n  padding-left: 72px !important;\n}\n.m-r-72 {\n  margin-right: 72px !important;\n}\n.p-r-72 {\n  padding-right: 72px !important;\n}\n.m-t-80 {\n  margin-top: 80px !important;\n}\n.p-t-80 {\n  padding-top: 80px !important;\n}\n.m-b-80 {\n  margin-bottom: 80px !important;\n}\n.p-b-80 {\n  padding-bottom: 80px !important;\n}\n.m-l-80 {\n  margin-left: 80px !important;\n}\n.p-l-80 {\n  padding-left: 80px !important;\n}\n.m-r-80 {\n  margin-right: 80px !important;\n}\n.p-r-80 {\n  padding-right: 80px !important;\n}\n.m-t-120 {\n  margin-top: 120px !important;\n}\n.p-t-120 {\n  padding-top: 120px !important;\n}\n.m-b-120 {\n  margin-bottom: 120px !important;\n}\n.p-b-120 {\n  padding-bottom: 120px !important;\n}\n.m-l-120 {\n  margin-left: 120px !important;\n}\n.p-l-120 {\n  padding-left: 120px !important;\n}\n.m-r-120 {\n  margin-right: 120px !important;\n}\n.p-r-120 {\n  padding-right: 120px !important;\n}\n.m-t-160 {\n  margin-top: 160px !important;\n}\n.p-t-160 {\n  padding-top: 160px !important;\n}\n.m-b-160 {\n  margin-bottom: 160px !important;\n}\n.p-b-160 {\n  padding-bottom: 160px !important;\n}\n.m-l-160 {\n  margin-left: 160px !important;\n}\n.p-l-160 {\n  padding-left: 160px !important;\n}\n.m-r-160 {\n  margin-right: 160px !important;\n}\n.p-r-160 {\n  padding-right: 160px !important;\n}\n\n* {\n  margin: 0;\n  padding: 0;\n  box-sizing: border-box;\n}\n\nhtml {\n  background: #131316;\n  scroll-behavior: smooth;\n  color-scheme: dark;\n}\n\nbody {\n  font-family: var(--body-font-family);\n  font-size: 14px;\n  color: var(--clr-neutral-300);\n}\n\nheader {\n  padding: 24px 32px;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  background: #000000;\n  box-shadow: 0px 1px 0px rgba(255, 255, 255, 0.15);\n}\n\n.header-inner {\n  flex: 1;\n  display: flex;\n  align-items: center;\n  max-width: 1100px;\n}\n\n.build-notes {\n  flex: 1;\n  display: flex;\n  justify-content: flex-end;\n  align-items: center;\n}\n\n.build-note {\n  line-height: 1;\n  display: flex;\n  align-items: center;\n  color: var(--clr-neutral-450);\n}\n\n.build-note + .build-note {\n  margin-left: 16px;\n}\n\n.build-note > svg {\n  margin-right: 8px;\n}\n\nh1 {\n  font-family: var(--heading-font-family);\n  font-size: 20px;\n  font-weight: bold;\n  color: var(--clr-neutral-0);\n}\n\nh2 {\n  font-family: var(--heading-font-family);\n  font-size: 16px;\n  font-weight: 600;\n  color: var(--clr-neutral-50);\n}\n\nh3 {\n  font-family: var(--heading-font-family);\n  font-size: 16px;\n  font-weight: 500;\n  color: var(--clr-neutral-100);\n}\n\nbutton {\n  border: none;\n  color: var(--clr-neutral-50);\n  background: linear-gradient(90deg, #616acb 0%, #4854bb 100%);\n  border-radius: 4px;\n  font-family: var(--body-font-family);\n  font-size: 14px;\n  padding: 12px 18px;\n  cursor: pointer;\n}\n\nbutton.secondary {\n  border: 1px solid var(--clr-primary-500);\n  background: transparent;\n}\n\nbutton:disabled {\n  color: var(--clr-neutral-400);\n  background: var(--clr-neutral-850);\n  cursor: inherit;\n}\n\ninput {\n  font-size: 14px;\n}\n\ninput[type=\"text\"] {\n  font-family: var(--body-font-family);\n  background: var(--clr-neutral-950);\n  border: 1px solid var(--clr-neutral-850);\n  border-radius: 5px;\n  padding: 12px 16px;\n}\n\n.badge {\n  display: flex;\n  flex-direction: row;\n  justify-content: center;\n  align-items: center;\n  padding: 4px 8px;\n  font-size: 12px;\n  font-weight: 500;\n  border-radius: 24px;\n  background: var(--clr-neutral-900);\n  color: var(--clr-neutral-300);\n}\n\n.badge.ok {\n  background: var(--clr-primary-900);\n  color: var(--clr-primary-300);\n}\n\n.backdrop {\n  width: 100%;\n  height: 180px;\n  position: absolute;\n  z-index: -5;\n  pointer-events: none;\n  background: #000000;\n}\n\n.demo {\n  padding: 32px;\n  max-width: 1100px;\n  margin: auto;\n}\n\n.flex {\n  display: flex;\n  align-items: center;\n}\n\nsvg {\n  flex-shrink: 0;\n}\n\n.card {\n  background: var(--clr-neutral-925);\n  box-shadow: 0px 8px 50px rgba(0, 0, 0, 0.25);\n  border-radius: 8px;\n  padding: 24px;\n  margin: 24px 0;\n}\n\n.card-top {\n  display: flex;\n  align-items: center;\n  margin-bottom: 8px;\n}\n\n.card-top > * + * {\n  margin-left: 8px;\n}\n\n.widget-body {\n  display: flex;\n}\n\n.stream-column {\n  flex: 2;\n}\n\n.chat-column {\n  flex: 1;\n  display: flex;\n  flex-direction: column;\n}\n\n.chat-history {\n  flex: 1;\n}\n\n.chat-bottom {\n  display: flex;\n  position: relative;\n  align-items: center;\n}\n\n.chat-input {\n  flex: 1;\n}\n\nbutton.chat-send-button {\n  cursor: pointer;\n  background: none;\n  padding: 0;\n  margin: 0;\n  position: absolute;\n  right: 16px;\n  margin-top: auto;\n}\n\nbutton.chat-send-button:disabled {\n  cursor: inherit;\n  filter: grayscale();\n}\n.stream-selector {\n  display: flex;\n}\n\n.stream-selector > select {\n  margin-right: 8px;\n}\n\n.stream-wrapper {\n  border: 1px solid rgba(0, 0, 0, 0.4);\n  background-image: /* url(\"https://rainway.com/images/logo.svg\"), */\n    linear-gradient(-45deg, #141625, #241635);\n  background-repeat: no-repeat;\n  background-position: center;\n  width: 100%;\n  height: 393px;\n}\n\na {\n  color: var(--clr-primary-400);\n  font-weight: 600;\n  text-decoration: none;\n  transition: color 0.2s ease;\n}\n\na:hover {\n  color: var(--clr-neutral-50);\n}\n", ""]);
// Exports
module.exports = exports;


/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/api.js":
/*!*****************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/api.js ***!
  \*****************************************************/
/***/ ((module) => {

"use strict";


/*
  MIT License http://www.opensource.org/licenses/mit-license.php
  Author Tobias Koppers @sokra
*/
// css base code, injected by the css-loader
// eslint-disable-next-line func-names
module.exports = function (useSourceMap) {
  var list = []; // return the list of modules as css string

  list.toString = function toString() {
    return this.map(function (item) {
      var content = cssWithMappingToString(item, useSourceMap);

      if (item[2]) {
        return "@media ".concat(item[2], " {").concat(content, "}");
      }

      return content;
    }).join('');
  }; // import a list of modules into the list
  // eslint-disable-next-line func-names


  list.i = function (modules, mediaQuery, dedupe) {
    if (typeof modules === 'string') {
      // eslint-disable-next-line no-param-reassign
      modules = [[null, modules, '']];
    }

    var alreadyImportedModules = {};

    if (dedupe) {
      for (var i = 0; i < this.length; i++) {
        // eslint-disable-next-line prefer-destructuring
        var id = this[i][0];

        if (id != null) {
          alreadyImportedModules[id] = true;
        }
      }
    }

    for (var _i = 0; _i < modules.length; _i++) {
      var item = [].concat(modules[_i]);

      if (dedupe && alreadyImportedModules[item[0]]) {
        // eslint-disable-next-line no-continue
        continue;
      }

      if (mediaQuery) {
        if (!item[2]) {
          item[2] = mediaQuery;
        } else {
          item[2] = "".concat(mediaQuery, " and ").concat(item[2]);
        }
      }

      list.push(item);
    }
  };

  return list;
};

function cssWithMappingToString(item, useSourceMap) {
  var content = item[1] || ''; // eslint-disable-next-line prefer-destructuring

  var cssMapping = item[3];

  if (!cssMapping) {
    return content;
  }

  if (useSourceMap && typeof btoa === 'function') {
    var sourceMapping = toComment(cssMapping);
    var sourceURLs = cssMapping.sources.map(function (source) {
      return "/*# sourceURL=".concat(cssMapping.sourceRoot || '').concat(source, " */");
    });
    return [content].concat(sourceURLs).concat([sourceMapping]).join('\n');
  }

  return [content].join('\n');
} // Adapted from convert-source-map (MIT)


function toComment(sourceMap) {
  // eslint-disable-next-line no-undef
  var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));
  var data = "sourceMappingURL=data:application/json;charset=utf-8;base64,".concat(base64);
  return "/*# ".concat(data, " */");
}

/***/ }),

/***/ "./node_modules/object-assign/index.js":
/*!*********************************************!*\
  !*** ./node_modules/object-assign/index.js ***!
  \*********************************************/
/***/ ((module) => {

"use strict";
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/


/* eslint-disable no-unused-vars */
var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var hasOwnProperty = Object.prototype.hasOwnProperty;
var propIsEnumerable = Object.prototype.propertyIsEnumerable;

function toObject(val) {
	if (val === null || val === undefined) {
		throw new TypeError('Object.assign cannot be called with null or undefined');
	}

	return Object(val);
}

function shouldUseNative() {
	try {
		if (!Object.assign) {
			return false;
		}

		// Detect buggy property enumeration order in older V8 versions.

		// https://bugs.chromium.org/p/v8/issues/detail?id=4118
		var test1 = new String('abc');  // eslint-disable-line no-new-wrappers
		test1[5] = 'de';
		if (Object.getOwnPropertyNames(test1)[0] === '5') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test2 = {};
		for (var i = 0; i < 10; i++) {
			test2['_' + String.fromCharCode(i)] = i;
		}
		var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
			return test2[n];
		});
		if (order2.join('') !== '0123456789') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test3 = {};
		'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
			test3[letter] = letter;
		});
		if (Object.keys(Object.assign({}, test3)).join('') !==
				'abcdefghijklmnopqrst') {
			return false;
		}

		return true;
	} catch (err) {
		// We don't expect any of the above to throw, but better to be safe.
		return false;
	}
}

module.exports = shouldUseNative() ? Object.assign : function (target, source) {
	var from;
	var to = toObject(target);
	var symbols;

	for (var s = 1; s < arguments.length; s++) {
		from = Object(arguments[s]);

		for (var key in from) {
			if (hasOwnProperty.call(from, key)) {
				to[key] = from[key];
			}
		}

		if (getOwnPropertySymbols) {
			symbols = getOwnPropertySymbols(from);
			for (var i = 0; i < symbols.length; i++) {
				if (propIsEnumerable.call(from, symbols[i])) {
					to[symbols[i]] = from[symbols[i]];
				}
			}
		}
	}

	return to;
};


/***/ }),

/***/ "./node_modules/rainway-sdk/dist/index.js":
/*!************************************************!*\
  !*** ./node_modules/rainway-sdk/dist/index.js ***!
  \************************************************/
/***/ ((module) => {

!function(A,e){ true?module.exports=e():0}(self,(function(){return(()=>{var A={7120:(A,e,I)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.BebopView=e.BebopRuntimeError=void 0;const g="0123456789abcdef",t=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,2,3,4,5,6,7,8,9,0,0,0,0,0,0,0,10,11,12,13,14,15,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,10,11,12,13,14,15,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],i=new Uint8Array(0),B=[];for(const A of g)for(const e of g)B.push(A+e);"undefined"==typeof TextDecoder&&(I.g.TextDecoder=I(1323).TextDecoder);class C extends Error{constructor(A){super(A),this.name="BebopRuntimeError"}}e.BebopRuntimeError=C;class Q{static textDecoder=new TextDecoder;static writeBuffer=new Uint8Array(256);static writeBufferView=new DataView(Q.writeBuffer.buffer);static instance;static getInstance(){return Q.instance||(Q.instance=new Q),Q.instance}minimumTextDecoderLength=300;buffer;view;index;length;constructor(){this.buffer=Q.writeBuffer,this.view=Q.writeBufferView,this.index=0,this.length=0}startReading(A){this.buffer=A,this.view=new DataView(this.buffer.buffer,this.buffer.byteOffset,this.buffer.byteLength),this.index=0,this.length=A.length}startWriting(){this.buffer=Q.writeBuffer,this.view=Q.writeBufferView,this.index=0,this.length=0}guaranteeBufferLength(A){if(A>this.buffer.length){const e=new Uint8Array(A<<1);e.set(this.buffer),this.buffer=e,this.view=new DataView(e.buffer)}}growBy(A){this.length+=A,this.guaranteeBufferLength(this.length)}skip(A){this.index+=A}toArray(){return this.buffer.subarray(0,this.length)}readByte(){return this.buffer[this.index++]}readUint16(){const A=this.view.getUint16(this.index,!0);return this.index+=2,A}readInt16(){const A=this.view.getInt16(this.index,!0);return this.index+=2,A}readUint32(){const A=this.view.getUint32(this.index,!0);return this.index+=4,A}readInt32(){const A=this.view.getInt32(this.index,!0);return this.index+=4,A}readUint64(){const A=this.view.getBigUint64(this.index,!0);return this.index+=8,A}readInt64(){const A=this.view.getBigInt64(this.index,!0);return this.index+=8,A}readFloat32(){const A=this.view.getFloat32(this.index,!0);return this.index+=4,A}readFloat64(){const A=this.view.getFloat64(this.index,!0);return this.index+=8,A}writeByte(A){const e=this.length;this.growBy(1),this.buffer[e]=A}writeUint16(A){const e=this.length;this.growBy(2),this.view.setUint16(e,A,!0)}writeInt16(A){const e=this.length;this.growBy(2),this.view.setInt16(e,A,!0)}writeUint32(A){const e=this.length;this.growBy(4),this.view.setUint32(e,A,!0)}writeInt32(A){const e=this.length;this.growBy(4),this.view.setInt32(e,A,!0)}writeUint64(A){const e=this.length;this.growBy(8),this.view.setBigUint64(e,A,!0)}writeInt64(A){const e=this.length;this.growBy(8),this.view.setBigInt64(e,A,!0)}writeFloat32(A){const e=this.length;this.growBy(4),this.view.setFloat32(e,A,!0)}writeFloat64(A){const e=this.length;this.growBy(8),this.view.setFloat64(e,A,!0)}readBytes(){const A=this.readUint32();if(0===A)return i;const e=this.index,I=e+A;return this.index=I,this.buffer.subarray(e,I)}writeBytes(A){const e=A.length;if(this.writeUint32(e),0===e)return;const I=this.length;this.growBy(e),this.buffer.set(A,I)}readString(){const A=this.readUint32();if(0===A)return"";if(A>=this.minimumTextDecoderLength)return Q.textDecoder.decode(this.buffer.subarray(this.index,this.index+=A));const e=this.index+A;let I,g="";for(;this.index<e;){const A=this.buffer[this.index++];if(A<192)I=A;else{const e=this.buffer[this.index++];if(A<224)I=(31&A)<<6|63&e;else{const g=this.buffer[this.index++];I=A<240?(15&A)<<12|(63&e)<<6|63&g:(7&A)<<18|(63&e)<<12|(63&g)<<6|63&this.buffer[this.index++]}}I<65536?g+=String.fromCharCode(I):(I-=65536,g+=String.fromCharCode(55296+(I>>10),56320+(1023&I)))}return this.index=e,g}writeString(A){const e=A.length;if(0===e)return void this.writeUint32(0);const I=4+3*e;this.guaranteeBufferLength(this.length+I);let g=this.length+4;const t=g;let i;for(let I=0;I<e;I++){const t=A.charCodeAt(I);i=I+1===e||t<55296||t>=56320?t:(t<<10)+A.charCodeAt(++I)+-56613888,i<128?this.buffer[g++]=i:(i<2048?this.buffer[g++]=i>>6&31|192:(i<65536?this.buffer[g++]=i>>12&15|224:(this.buffer[g++]=i>>18&7|240,this.buffer[g++]=i>>12&63|128),this.buffer[g++]=i>>6&63|128),this.buffer[g++]=63&i|128)}const B=g-t;this.view.setUint32(this.length,B,!0),this.length+=4+B}readGuid(){const A=B,e=this.buffer,I=this.index,g="-";var t=A[e[I+3]];return t+=A[e[I+2]],t+=A[e[I+1]],t+=A[e[I]],t+=g,t+=A[e[I+5]],t+=A[e[I+4]],t+=g,t+=A[e[I+7]],t+=A[e[I+6]],t+=g,t+=A[e[I+8]],t+=A[e[I+9]],t+=g,t+=A[e[I+10]],t+=A[e[I+11]],t+=A[e[I+12]],t+=A[e[I+13]],t+=A[e[I+14]],t+=A[e[I+15]],this.index+=16,t}writeGuid(A){const e=this.view,I=this.length;this.growBy(16);var g=0,i=0;i=(i=(i=(i=(i=(i=(i=(i=i<<4|t[A.charCodeAt(g++)])<<4|t[A.charCodeAt(g++)])<<4|t[A.charCodeAt(g++)])<<4|t[A.charCodeAt(g++)])<<4|t[A.charCodeAt(g++)])<<4|t[A.charCodeAt(g++)])<<4|t[A.charCodeAt(g++)])<<4|t[A.charCodeAt(g++)],g+=45===A.charCodeAt(g),e.setUint32(I,i,!0),i=(i=(i=(i=i<<4|t[A.charCodeAt(g++)])<<4|t[A.charCodeAt(g++)])<<4|t[A.charCodeAt(g++)])<<4|t[A.charCodeAt(g++)],g+=45===A.charCodeAt(g),e.setUint16(I+4,i,!0),i=(i=(i=(i=i<<4|t[A.charCodeAt(g++)])<<4|t[A.charCodeAt(g++)])<<4|t[A.charCodeAt(g++)])<<4|t[A.charCodeAt(g++)],g+=45===A.charCodeAt(g),e.setUint16(I+6,i,!0),i=(i=(i=(i=i<<4|t[A.charCodeAt(g++)])<<4|t[A.charCodeAt(g++)])<<4|t[A.charCodeAt(g++)])<<4|t[A.charCodeAt(g++)],g+=45===A.charCodeAt(g),i=(i=(i=(i=i<<4|t[A.charCodeAt(g++)])<<4|t[A.charCodeAt(g++)])<<4|t[A.charCodeAt(g++)])<<4|t[A.charCodeAt(g++)],e.setUint32(I+8,i,!1),i=(i=(i=(i=(i=(i=(i=(i=i<<4|t[A.charCodeAt(g++)])<<4|t[A.charCodeAt(g++)])<<4|t[A.charCodeAt(g++)])<<4|t[A.charCodeAt(g++)])<<4|t[A.charCodeAt(g++)])<<4|t[A.charCodeAt(g++)])<<4|t[A.charCodeAt(g++)])<<4|t[A.charCodeAt(g++)],e.setUint32(I+12,i,!1)}readDate(){const A=this.readUint32(),e=1073741823&this.readUint32();return new Date(429496.7296*e+1e-4*A-621355968e5)}writeDate(A){const e=A.getTime()+621355968e5,I=e%429496.7296*1e4|0,g=e/429496.7296|1073741824;this.writeUint32(I),this.writeUint32(g)}reserveMessageLength(){const A=this.length;return this.growBy(4),A}fillMessageLength(A,e){this.view.setUint32(A,e,!0)}readMessageLength(){const A=this.view.getUint32(this.index,!0);return this.index+=4,A}}e.BebopView=Q},2737:(A,e,I)=>{"use strict";var g=I(8750),t=I(4573),i=t(g("String.prototype.indexOf"));A.exports=function(A,e){var I=g(A,!!e);return"function"==typeof I&&i(A,".prototype.")>-1?t(I):I}},4573:(A,e,I)=>{"use strict";var g=I(132),t=I(8750),i=t("%Function.prototype.apply%"),B=t("%Function.prototype.call%"),C=t("%Reflect.apply%",!0)||g.call(B,i),Q=t("%Object.getOwnPropertyDescriptor%",!0),o=t("%Object.defineProperty%",!0),n=t("%Math.max%");if(o)try{o({},"a",{value:1})}catch(A){o=null}A.exports=function(A){var e=C(g,B,arguments);if(Q&&o){var I=Q(e,"length");I.configurable&&o(e,"length",{value:1+n(0,A.length-(arguments.length-1))})}return e};var a=function(){return C(g,i,arguments)};o?o(A.exports,"apply",{value:a}):A.exports.apply=a},5278:(A,e,I)=>{"use strict";var g=I(8245),t=Object.prototype.toString,i=Object.prototype.hasOwnProperty,B=function(A,e,I){for(var g=0,t=A.length;g<t;g++)i.call(A,g)&&(null==I?e(A[g],g,A):e.call(I,A[g],g,A))},C=function(A,e,I){for(var g=0,t=A.length;g<t;g++)null==I?e(A.charAt(g),g,A):e.call(I,A.charAt(g),g,A)},Q=function(A,e,I){for(var g in A)i.call(A,g)&&(null==I?e(A[g],g,A):e.call(I,A[g],g,A))};A.exports=function(A,e,I){if(!g(e))throw new TypeError("iterator must be a function");var i;arguments.length>=3&&(i=I),"[object Array]"===t.call(A)?B(A,e,i):"string"==typeof A?C(A,e,i):Q(A,e,i)}},8245:A=>{"use strict";var e,I,g=Function.prototype.toString,t="object"==typeof Reflect&&null!==Reflect&&Reflect.apply;if("function"==typeof t&&"function"==typeof Object.defineProperty)try{e=Object.defineProperty({},"length",{get:function(){throw I}}),I={},t((function(){throw 42}),null,e)}catch(A){A!==I&&(t=null)}else t=null;var i=/^\s*class\b/,B=function(A){try{var e=g.call(A);return i.test(e)}catch(A){return!1}},C=Object.prototype.toString,Q="function"==typeof Symbol&&!!Symbol.toStringTag,o="object"==typeof document&&void 0===document.all&&void 0!==document.all?document.all:{};A.exports=t?function(A){if(A===o)return!0;if(!A)return!1;if("function"!=typeof A&&"object"!=typeof A)return!1;if("function"==typeof A&&!A.prototype)return!0;try{t(A,null,e)}catch(A){if(A!==I)return!1}return!B(A)}:function(A){if(A===o)return!0;if(!A)return!1;if("function"!=typeof A&&"object"!=typeof A)return!1;if("function"==typeof A&&!A.prototype)return!0;if(Q)return function(A){try{return!B(A)&&(g.call(A),!0)}catch(A){return!1}}(A);if(B(A))return!1;var e=C.call(A);return"[object Function]"===e||"[object GeneratorFunction]"===e}},8458:A=>{"use strict";var e="Function.prototype.bind called on incompatible ",I=Array.prototype.slice,g=Object.prototype.toString,t="[object Function]";A.exports=function(A){var i=this;if("function"!=typeof i||g.call(i)!==t)throw new TypeError(e+i);for(var B,C=I.call(arguments,1),Q=function(){if(this instanceof B){var e=i.apply(this,C.concat(I.call(arguments)));return Object(e)===e?e:this}return i.apply(A,C.concat(I.call(arguments)))},o=Math.max(0,i.length-C.length),n=[],a=0;a<o;a++)n.push("$"+a);if(B=Function("binder","return function ("+n.join(",")+"){ return binder.apply(this,arguments); }")(Q),i.prototype){var r=function(){};r.prototype=i.prototype,B.prototype=new r,r.prototype=null}return B}},132:(A,e,I)=>{"use strict";var g=I(8458);A.exports=Function.prototype.bind||g},8750:(A,e,I)=>{"use strict";var g,t=SyntaxError,i=Function,B=TypeError,C=function(A){try{return i('"use strict"; return ('+A+").constructor;")()}catch(A){}},Q=Object.getOwnPropertyDescriptor;if(Q)try{Q({},"")}catch(A){Q=null}var o=function(){throw new B},n=Q?function(){try{return o}catch(A){try{return Q(arguments,"callee").get}catch(A){return o}}}():o,a=I(679)(),r=Object.getPrototypeOf||function(A){return A.__proto__},E={},s="undefined"==typeof Uint8Array?g:r(Uint8Array),d={"%AggregateError%":"undefined"==typeof AggregateError?g:AggregateError,"%Array%":Array,"%ArrayBuffer%":"undefined"==typeof ArrayBuffer?g:ArrayBuffer,"%ArrayIteratorPrototype%":a?r([][Symbol.iterator]()):g,"%AsyncFromSyncIteratorPrototype%":g,"%AsyncFunction%":E,"%AsyncGenerator%":E,"%AsyncGeneratorFunction%":E,"%AsyncIteratorPrototype%":E,"%Atomics%":"undefined"==typeof Atomics?g:Atomics,"%BigInt%":"undefined"==typeof BigInt?g:BigInt,"%Boolean%":Boolean,"%DataView%":"undefined"==typeof DataView?g:DataView,"%Date%":Date,"%decodeURI%":decodeURI,"%decodeURIComponent%":decodeURIComponent,"%encodeURI%":encodeURI,"%encodeURIComponent%":encodeURIComponent,"%Error%":Error,"%eval%":eval,"%EvalError%":EvalError,"%Float32Array%":"undefined"==typeof Float32Array?g:Float32Array,"%Float64Array%":"undefined"==typeof Float64Array?g:Float64Array,"%FinalizationRegistry%":"undefined"==typeof FinalizationRegistry?g:FinalizationRegistry,"%Function%":i,"%GeneratorFunction%":E,"%Int8Array%":"undefined"==typeof Int8Array?g:Int8Array,"%Int16Array%":"undefined"==typeof Int16Array?g:Int16Array,"%Int32Array%":"undefined"==typeof Int32Array?g:Int32Array,"%isFinite%":isFinite,"%isNaN%":isNaN,"%IteratorPrototype%":a?r(r([][Symbol.iterator]())):g,"%JSON%":"object"==typeof JSON?JSON:g,"%Map%":"undefined"==typeof Map?g:Map,"%MapIteratorPrototype%":"undefined"!=typeof Map&&a?r((new Map)[Symbol.iterator]()):g,"%Math%":Math,"%Number%":Number,"%Object%":Object,"%parseFloat%":parseFloat,"%parseInt%":parseInt,"%Promise%":"undefined"==typeof Promise?g:Promise,"%Proxy%":"undefined"==typeof Proxy?g:Proxy,"%RangeError%":RangeError,"%ReferenceError%":ReferenceError,"%Reflect%":"undefined"==typeof Reflect?g:Reflect,"%RegExp%":RegExp,"%Set%":"undefined"==typeof Set?g:Set,"%SetIteratorPrototype%":"undefined"!=typeof Set&&a?r((new Set)[Symbol.iterator]()):g,"%SharedArrayBuffer%":"undefined"==typeof SharedArrayBuffer?g:SharedArrayBuffer,"%String%":String,"%StringIteratorPrototype%":a?r(""[Symbol.iterator]()):g,"%Symbol%":a?Symbol:g,"%SyntaxError%":t,"%ThrowTypeError%":n,"%TypedArray%":s,"%TypeError%":B,"%Uint8Array%":"undefined"==typeof Uint8Array?g:Uint8Array,"%Uint8ClampedArray%":"undefined"==typeof Uint8ClampedArray?g:Uint8ClampedArray,"%Uint16Array%":"undefined"==typeof Uint16Array?g:Uint16Array,"%Uint32Array%":"undefined"==typeof Uint32Array?g:Uint32Array,"%URIError%":URIError,"%WeakMap%":"undefined"==typeof WeakMap?g:WeakMap,"%WeakRef%":"undefined"==typeof WeakRef?g:WeakRef,"%WeakSet%":"undefined"==typeof WeakSet?g:WeakSet},c=function A(e){var I;if("%AsyncFunction%"===e)I=C("async function () {}");else if("%GeneratorFunction%"===e)I=C("function* () {}");else if("%AsyncGeneratorFunction%"===e)I=C("async function* () {}");else if("%AsyncGenerator%"===e){var g=A("%AsyncGeneratorFunction%");g&&(I=g.prototype)}else if("%AsyncIteratorPrototype%"===e){var t=A("%AsyncGenerator%");t&&(I=r(t.prototype))}return d[e]=I,I},h={"%ArrayBufferPrototype%":["ArrayBuffer","prototype"],"%ArrayPrototype%":["Array","prototype"],"%ArrayProto_entries%":["Array","prototype","entries"],"%ArrayProto_forEach%":["Array","prototype","forEach"],"%ArrayProto_keys%":["Array","prototype","keys"],"%ArrayProto_values%":["Array","prototype","values"],"%AsyncFunctionPrototype%":["AsyncFunction","prototype"],"%AsyncGenerator%":["AsyncGeneratorFunction","prototype"],"%AsyncGeneratorPrototype%":["AsyncGeneratorFunction","prototype","prototype"],"%BooleanPrototype%":["Boolean","prototype"],"%DataViewPrototype%":["DataView","prototype"],"%DatePrototype%":["Date","prototype"],"%ErrorPrototype%":["Error","prototype"],"%EvalErrorPrototype%":["EvalError","prototype"],"%Float32ArrayPrototype%":["Float32Array","prototype"],"%Float64ArrayPrototype%":["Float64Array","prototype"],"%FunctionPrototype%":["Function","prototype"],"%Generator%":["GeneratorFunction","prototype"],"%GeneratorPrototype%":["GeneratorFunction","prototype","prototype"],"%Int8ArrayPrototype%":["Int8Array","prototype"],"%Int16ArrayPrototype%":["Int16Array","prototype"],"%Int32ArrayPrototype%":["Int32Array","prototype"],"%JSONParse%":["JSON","parse"],"%JSONStringify%":["JSON","stringify"],"%MapPrototype%":["Map","prototype"],"%NumberPrototype%":["Number","prototype"],"%ObjectPrototype%":["Object","prototype"],"%ObjProto_toString%":["Object","prototype","toString"],"%ObjProto_valueOf%":["Object","prototype","valueOf"],"%PromisePrototype%":["Promise","prototype"],"%PromiseProto_then%":["Promise","prototype","then"],"%Promise_all%":["Promise","all"],"%Promise_reject%":["Promise","reject"],"%Promise_resolve%":["Promise","resolve"],"%RangeErrorPrototype%":["RangeError","prototype"],"%ReferenceErrorPrototype%":["ReferenceError","prototype"],"%RegExpPrototype%":["RegExp","prototype"],"%SetPrototype%":["Set","prototype"],"%SharedArrayBufferPrototype%":["SharedArrayBuffer","prototype"],"%StringPrototype%":["String","prototype"],"%SymbolPrototype%":["Symbol","prototype"],"%SyntaxErrorPrototype%":["SyntaxError","prototype"],"%TypedArrayPrototype%":["TypedArray","prototype"],"%TypeErrorPrototype%":["TypeError","prototype"],"%Uint8ArrayPrototype%":["Uint8Array","prototype"],"%Uint8ClampedArrayPrototype%":["Uint8ClampedArray","prototype"],"%Uint16ArrayPrototype%":["Uint16Array","prototype"],"%Uint32ArrayPrototype%":["Uint32Array","prototype"],"%URIErrorPrototype%":["URIError","prototype"],"%WeakMapPrototype%":["WeakMap","prototype"],"%WeakSetPrototype%":["WeakSet","prototype"]},D=I(132),u=I(7492),w=D.call(Function.call,Array.prototype.concat),l=D.call(Function.apply,Array.prototype.splice),y=D.call(Function.call,String.prototype.replace),S=D.call(Function.call,String.prototype.slice),F=/[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g,R=/\\(\\)?/g,p=function(A){var e=S(A,0,1),I=S(A,-1);if("%"===e&&"%"!==I)throw new t("invalid intrinsic syntax, expected closing `%`");if("%"===I&&"%"!==e)throw new t("invalid intrinsic syntax, expected opening `%`");var g=[];return y(A,F,(function(A,e,I,t){g[g.length]=I?y(t,R,"$1"):e||A})),g},G=function(A,e){var I,g=A;if(u(h,g)&&(g="%"+(I=h[g])[0]+"%"),u(d,g)){var i=d[g];if(i===E&&(i=c(g)),void 0===i&&!e)throw new B("intrinsic "+A+" exists, but is not available. Please file an issue!");return{alias:I,name:g,value:i}}throw new t("intrinsic "+A+" does not exist!")};A.exports=function(A,e){if("string"!=typeof A||0===A.length)throw new B("intrinsic name must be a non-empty string");if(arguments.length>1&&"boolean"!=typeof e)throw new B('"allowMissing" argument must be a boolean');var I=p(A),g=I.length>0?I[0]:"",i=G("%"+g+"%",e),C=i.name,o=i.value,n=!1,a=i.alias;a&&(g=a[0],l(I,w([0,1],a)));for(var r=1,E=!0;r<I.length;r+=1){var s=I[r],c=S(s,0,1),h=S(s,-1);if(('"'===c||"'"===c||"`"===c||'"'===h||"'"===h||"`"===h)&&c!==h)throw new t("property names with quotes must have matching quotes");if("constructor"!==s&&E||(n=!0),u(d,C="%"+(g+="."+s)+"%"))o=d[C];else if(null!=o){if(!(s in o)){if(!e)throw new B("base intrinsic for "+A+" exists, but the property is not available.");return}if(Q&&r+1>=I.length){var D=Q(o,s);o=(E=!!D)&&"get"in D&&!("originalValue"in D.get)?D.get:o[s]}else E=u(o,s),o=o[s];E&&!n&&(d[C]=o)}}return o}},679:(A,e,I)=>{"use strict";var g="undefined"!=typeof Symbol&&Symbol,t=I(8186);A.exports=function(){return"function"==typeof g&&"function"==typeof Symbol&&"symbol"==typeof g("foo")&&"symbol"==typeof Symbol("bar")&&t()}},8186:A=>{"use strict";A.exports=function(){if("function"!=typeof Symbol||"function"!=typeof Object.getOwnPropertySymbols)return!1;if("symbol"==typeof Symbol.iterator)return!0;var A={},e=Symbol("test"),I=Object(e);if("string"==typeof e)return!1;if("[object Symbol]"!==Object.prototype.toString.call(e))return!1;if("[object Symbol]"!==Object.prototype.toString.call(I))return!1;for(e in A[e]=42,A)return!1;if("function"==typeof Object.keys&&0!==Object.keys(A).length)return!1;if("function"==typeof Object.getOwnPropertyNames&&0!==Object.getOwnPropertyNames(A).length)return!1;var g=Object.getOwnPropertySymbols(A);if(1!==g.length||g[0]!==e)return!1;if(!Object.prototype.propertyIsEnumerable.call(A,e))return!1;if("function"==typeof Object.getOwnPropertyDescriptor){var t=Object.getOwnPropertyDescriptor(A,e);if(42!==t.value||!0!==t.enumerable)return!1}return!0}},698:(A,e,I)=>{"use strict";var g=I(8186);A.exports=function(){return g()&&!!Symbol.toStringTag}},7492:(A,e,I)=>{"use strict";var g=I(132);A.exports=g.call(Function.call,Object.prototype.hasOwnProperty)},87:A=>{"function"==typeof Object.create?A.exports=function(A,e){e&&(A.super_=e,A.prototype=Object.create(e.prototype,{constructor:{value:A,enumerable:!1,writable:!0,configurable:!0}}))}:A.exports=function(A,e){if(e){A.super_=e;var I=function(){};I.prototype=e.prototype,A.prototype=new I,A.prototype.constructor=A}}},7740:(A,e,I)=>{"use strict";var g="function"==typeof Symbol&&"symbol"==typeof Symbol.toStringTag,t=I(2737)("Object.prototype.toString"),i=function(A){return!(g&&A&&"object"==typeof A&&Symbol.toStringTag in A)&&"[object Arguments]"===t(A)},B=function(A){return!!i(A)||null!==A&&"object"==typeof A&&"number"==typeof A.length&&A.length>=0&&"[object Array]"!==t(A)&&"[object Function]"===t(A.callee)},C=function(){return i(arguments)}();i.isLegacyArguments=B,A.exports=C?i:B},8265:(A,e,I)=>{"use strict";var g,t=Object.prototype.toString,i=Function.prototype.toString,B=/^\s*(?:function)?\*/,C=I(698)(),Q=Object.getPrototypeOf;A.exports=function(A){if("function"!=typeof A)return!1;if(B.test(i.call(A)))return!0;if(!C)return"[object GeneratorFunction]"===t.call(A);if(!Q)return!1;if(void 0===g){var e=function(){if(!C)return!1;try{return Function("return function*() {}")()}catch(A){}}();g=!!e&&Q(e)}return Q(A)===g}},387:(A,e,I)=>{"use strict";var g=I(5278),t=I(973),i=I(2737),B=i("Object.prototype.toString"),C=I(698)(),Q="undefined"==typeof globalThis?I.g:globalThis,o=t(),n=i("Array.prototype.indexOf",!0)||function(A,e){for(var I=0;I<A.length;I+=1)if(A[I]===e)return I;return-1},a=i("String.prototype.slice"),r={},E=I(8828),s=Object.getPrototypeOf;C&&E&&s&&g(o,(function(A){var e=new Q[A];if(Symbol.toStringTag in e){var I=s(e),g=E(I,Symbol.toStringTag);if(!g){var t=s(I);g=E(t,Symbol.toStringTag)}r[A]=g.get}})),A.exports=function(A){if(!A||"object"!=typeof A)return!1;if(!C||!(Symbol.toStringTag in A)){var e=a(B(A),8,-1);return n(o,e)>-1}return!!E&&function(A){var e=!1;return g(r,(function(I,g){if(!e)try{e=I.call(A)===g}catch(A){}})),e}(A)}},290:function(A,e,I){"use strict";var g=this&&this.__awaiter||function(A,e,I,g){return new(I||(I=Promise))((function(t,i){function B(A){try{Q(g.next(A))}catch(A){i(A)}}function C(A){try{Q(g.throw(A))}catch(A){i(A)}}function Q(A){var e;A.done?t(A.value):(e=A.value,e instanceof I?e:new I((function(A){A(e)}))).then(B,C)}Q((g=g.apply(A,e||[])).next())}))};Object.defineProperty(e,"__esModule",{value:!0}),e.fetchNewPeerId=e.getOrganizationInfo=void 0;const t=I(2994);function i(A,e){return g(this,void 0,void 0,(function*(){let I;try{I=yield fetch("https://api.rainway.network/v1"+A,e)}catch(A){throw new t.RainwayError("Could not connect to the Rainway API.")}if(!I.ok){let e;try{e=yield I.json()}catch(A){e=void 0}if(422===I.status&&!1===(null==e?void 0:e.is_valid))throw new t.RainwayError("The Rainway API key is invalid.");throw new t.RainwayError(`Rainway API error: ${A} returned ${I.status}`)}return I}))}e.getOrganizationInfo=function(A){return g(this,void 0,void 0,(function*(){const e=yield i("/keys/validate",{headers:{Authorization:`Bearer ${A}`,Accept:"application/json"}}),I=yield e.json();return{universeFlag:I.universe,organizationId:I.org_id}}))},e.fetchNewPeerId=function(){return g(this,void 0,void 0,(function*(){const A=yield i("/druid/next",{headers:{Accept:"application/json"}});return BigInt(yield A.text())}))}},2434:(A,e)=>{"use strict";var I,g;Object.defineProperty(e,"__esModule",{value:!0}),e.AudioReadyState=e.VideoReadyState=void 0,(g=e.VideoReadyState||(e.VideoReadyState={}))[g.Detached=0]="Detached",g[g.Initializing=1]="Initializing",g[g.WaitingForKeyframe=2]="WaitingForKeyframe",g[g.Playing=3]="Playing",g[g.Paused=4]="Paused",g[g.Disposed=5]="Disposed",(I=e.AudioReadyState||(e.AudioReadyState={}))[I.Detached=0]="Detached",I[I.Uninitialized=1]="Uninitialized",I[I.Initializing=2]="Initializing",I[I.Playing=3]="Playing",I[I.Paused=4]="Paused"},5528:(A,e)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.isDesktopSafari=void 0,e.isDesktopSafari=/Macintosh;.*Safari/.test(navigator.userAgent)&&!/Chrome|Android/i.test(navigator.userAgent)},9987:(A,e)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.reassemble=e.eachChunk=void 0;let I=0;e.eachChunk=function(A,e,g=16e3){const t=Math.ceil(A.length/g),i=++I;for(let I=0;I<t;I++){const B=I*g,C=Math.min((I+1)*g,A.length);e({chunksInGroup:t,groupId:i,index:I,data:A.slice(B,C)})}},e.reassemble=function(A){let e=0;const I=A.chunks.length;for(let g=0;g<I;g++)e+=A.chunks[g].byteLength;const g=new Uint8Array(e);let t=0;for(let e=0;e<I;e++){const I=A.chunks[e];g.set(I,t),t+=I.byteLength}return g}},9024:(A,e)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.Action=void 0,e.Action=class{constructor(){this.handlers=[]}addHandler(A){this.handlers.push(A)}removeHandler(A){this.handlers=this.handlers.filter((e=>e!==A))}invoke(A){for(let e=0;e<this.handlers.length;e++)this.handlers[e](A)}}},3930:(A,e)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.boundingRectangle=void 0,e.boundingRectangle=function(A){const e=A.length;if(0===e)throw new Error("boundingRectangle() of 0 rectangles");const I=A[0];let{left:g,top:t}=I,i=g+I.width,B=t+I.height;for(let I=1;I<e;I++){const e=A[I];g=Math.min(g,e.left),t=Math.min(t,e.top),i=Math.max(i,e.left+e.width),B=Math.max(B,e.top+e.height)}return{left:g,top:t,width:i-g,height:B-t}}},198:(A,e)=>{"use strict";function I(A){if(0===A.length)return NaN;let e=0;for(const I of A)e+=I;return e/A.length}Object.defineProperty(e,"__esModule",{value:!0}),e.meanOrZero=e.mean=e.standardDeviation=e.interquartileRange=e.median=e.WindowTrack=void 0,e.WindowTrack=class{constructor(A,e){this.sizeMs=A,this.averageOperation=e,this.cachedAverage=void 0,this.buffer=[]}get values(){return this.trim(),this.buffer.map((A=>A.value))}get measurements(){return this.trim(),this.buffer}trim(){const A=performance.now(),e=this.buffer.findIndex((e=>e.time>A-this.sizeMs));e>0?(this.buffer.splice(0,e),this.cachedAverage=void 0):-1===e&&(this.buffer.splice(0,this.buffer.length),this.cachedAverage=void 0)}feed(A){const e=performance.now();this.buffer.push({time:e,value:A}),this.buffer.length>=500&&this.trim(),this.cachedAverage=void 0}average(){if(this.trim(),this.cachedAverage)return this.cachedAverage;const A=this.buffer.map((A=>A.value));return this.cachedAverage=this.averageOperation(A)}},e.median=function(A){return 0===A.length?NaN:(A.sort(((A,e)=>A-e)),A[Math.floor(A.length/2)])},e.interquartileRange=function(A){if(0===A.length)return NaN;A.sort(((A,e)=>A-e));const e=Math.floor(.25*A.length);return A[Math.floor(.75*A.length)]-A[e]},e.standardDeviation=function(A){if(0===A.length)return NaN;const e=A.length,I=A.reduce(((A,e)=>A+e),0)/e;return Math.sqrt(A.map((A=>Math.pow(A-I,2))).reduce(((A,e)=>A+e),0)/e)},e.mean=I,e.meanOrZero=function(A){return 0===A.length?0:I(A)}},6904:function(A,e,I){"use strict";var g=this&&this.__createBinding||(Object.create?function(A,e,I,g){void 0===g&&(g=I),Object.defineProperty(A,g,{enumerable:!0,get:function(){return e[I]}})}:function(A,e,I,g){void 0===g&&(g=I),A[g]=e[I]}),t=this&&this.__exportStar||function(A,e){for(var I in A)"default"===I||Object.prototype.hasOwnProperty.call(e,I)||g(e,A,I)};Object.defineProperty(e,"__esModule",{value:!0}),t(I(7162),e)},7162:(A,e,I)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.AcceptStreamRequest_Invoke=e.ClearJoinRequests_Invoke=e.GetJoinRequests_Invoke=e.RejectJoinRequest_Invoke=e.AcceptJoinRequest_Invoke=e.ClearLogs_Invoke=e.GetLogs_Invoke=e.SetLogLevel_Invoke=e.GetPeerId_Invoke=e.GetVersion_Invoke=e.Shutdown_Invoke=e.Initialize_Invoke=e.Response=e.Request=e.TelemetryValueType=e.RainwayTelemetryDimension=e.RainwayTelemetryRecord=e.RainwayTelemetryRequest=e.TelemetryBatchesKeyTemplate=e.TelemetrySetKey=e.GatewayForwardableBody=e.PeerSignalingInformation=e.RejectedConnectionRequest=e.AcceptedConnectionRequest=e.ConnectionRequest=e.GatewayResponseBody=e.GatewayHello=e.GatewayRequestBody=e.InitConnectionRequest=e.GatewayBody=e.GatewayForwardable=e.GatewayAlert=e.GatewayResponse=e.GatewayRequest=e.GatewayDatagram=e.GatewayHeader=e.PendingConnectionRequest=e.Peer=e.GatewayIdentity=e.GatewayTrunk=e.PeerInformationType=e.PeerTransportType=e.GatewayAlertDescription=e.GatewayAlertLevel=e.GatewayResponseContext=e.PeerSetKeyTemplate=e.AcceptedConnectionRequestKeyTemplate=e.PendingConnectionRequestKeyTemplate=e.PeerKeyTemplate=e.DatagramChannel=void 0,e.WindowsPointerFlags=e.VirtualKey=e.KeyboardAction=e.ScrollAxis=e.MouseButton=e.ButtonAction=e.XInputButtons=e.ArbitraryDatagram=e.MediaDatagram=e.LogicDatagram=e.InputDatagram=e.Chunk=e.RainwayHeader=e.Guid=e.PeerMessage=e.PeerStateChange=e.StreamRequestOperation=e.JoinRequestOperation=e.LogEntry=e.PeerState=e.LogLevel=e.Return=e.ClearPeerMessages_Return=e.GetPeerMessages_Return=e.ClearPeerStateChanges_Return=e.GetPeerStateChanges_Return=e.ClearStreamRequests_Return=e.GetStreamRequests_Return=e.RejectStreamRequest_Return=e.AcceptStreamRequest_Return=e.ClearJoinRequests_Return=e.GetJoinRequests_Return=e.RejectJoinRequest_Return=e.AcceptJoinRequest_Return=e.ClearLogs_Return=e.GetLogs_Return=e.SetLogLevel_Return=e.GetPeerId_Return=e.GetVersion_Return=e.Shutdown_Return=e.Initialize_Return=e.Error_Return=e.Invocation=e.ClearPeerMessages_Invoke=e.GetPeerMessages_Invoke=e.ClearPeerStateChanges_Invoke=e.GetPeerStateChanges_Invoke=e.ClearStreamRequests_Invoke=e.GetStreamRequests_Invoke=e.RejectStreamRequest_Invoke=void 0,e.InputLevelRequest=e.InputLevelUpdate=e.RejectStreamRequest=e.PauseStream=e.JoinStream=e.VideoBitrateRequest=e.KeyframeRequest=e.StreamStopping=e.LeaveStream=e.StreamRequest=e.ErrorResponse=e.ClientCapabilities=e.CodecPackResponse=e.CodecPackRequest=e.DeviceInfo=e.RemoteStreamInfo=e.InputLevel=e.VideoConfig=e.StreamType=e.AudioConfig=e.LogicError=e.VideoContainer=e.AudioContainer=e.AudioCodec=e.AudioChannels=e.NetworkProtocol=e.OperatingSystem=e.FormFactor=e.VideoCodec=e.Vendor=e.VideoCodecType=e.InputBody=e.InputBodyInner=e.SetClipboardText=e.ViewportResize=e.PenAbsolute=e.TouchesAbsolute=e.LogicalInput=e.KeyboardInput=e.MouseScroll=e.MouseClick=e.MouseRelative=e.MouseAbsolute=e.GamepadRumble=e.GamepadReport=e.TouchAbsolute=e.PenFlags=e.PenMask=e.TouchMask=e.TouchPenPointerInfo=void 0,e.MediaBody=e.MediaChunk=e.AudioData=e.PointerData=e.VideoData=e.DesktopRect=e.AudioDataType=e.VideoDataType=e.LogicBody=e.ListStreams=e.StreamAnnouncement=void 0;const g=I(7120);var t,i,B,C,Q,o,n,a,r,E,s,d,c,h,D,u,w,l,y,S,F,R,p,G,f,m,k,U,N,M,L;e.DatagramChannel="network:datagrams",e.PeerKeyTemplate="network:peers:{0}",e.PendingConnectionRequestKeyTemplate="network:connection.requests:pending:{0}",e.AcceptedConnectionRequestKeyTemplate="network:connection.requests:accepted:{0}",e.PeerSetKeyTemplate="network:active.peers:{0}",e.GatewayResponseContext={encode(A){const e=g.BebopView.getInstance();return e.startWriting(),this.encodeInto(A,e),e.toArray()},encodeInto(A,I){const g=I.length;return I.writeInt64(A.sourcePeerId),I.writeInt64(A.targetPeerId),e.GatewayDatagram.encodeInto(A.datagram,I),I.length-g},decode(A){const e=g.BebopView.getInstance();return e.startReading(A),this.readFrom(e)},readFrom(A){let I,g,t;return I=A.readInt64(),g=A.readInt64(),t=e.GatewayDatagram.readFrom(A),{sourcePeerId:I,targetPeerId:g,datagram:t}}},(L=e.GatewayAlertLevel||(e.GatewayAlertLevel={}))[L.Unknown=0]="Unknown",L[L.Warning=1]="Warning",L[L.Fatal=2]="Fatal",(M=e.GatewayAlertDescription||(e.GatewayAlertDescription={}))[M.CloseNotify=0]="CloseNotify",M[M.UnexpectedMessage=10]="UnexpectedMessage",M[M.RecordOverflow=20]="RecordOverflow",M[M.TicketValidationError=30]="TicketValidationError",M[M.AccessDenied=49]="AccessDenied",M[M.DecodeError=50]="DecodeError",M[M.DecryptError=51]="DecryptError",M[M.ProtocolVersion=70]="ProtocolVersion",M[M.InternalError=80]="InternalError",M[M.PeerGoneAway=90]="PeerGoneAway",M[M.CommitFailure=100]="CommitFailure",M[M.ResourceExpired=200]="ResourceExpired",(N=e.PeerTransportType||(e.PeerTransportType={}))[N.Invalid=0]="Invalid",N[N.SCTP=1]="SCTP",N[N.GUDP=2]="GUDP",N[N.Reserved=3]="Reserved",(U=e.PeerInformationType||(e.PeerInformationType={}))[U.Invalid=0]="Invalid",U[U.Offer=1]="Offer",U[U.Answer=2]="Answer",U[U.Candidate=3]="Candidate",e.GatewayTrunk={encode(A){const e=g.BebopView.getInstance();return e.startWriting(),this.encodeInto(A,e),e.toArray()},encodeInto(A,e){const I=e.length;return e.writeString(A.machineId),e.writeDate(A.startDate),e.length-I},decode(A){const e=g.BebopView.getInstance();return e.startReading(A),this.readFrom(e)},readFrom(A){let e,I;return e=A.readString(),I=A.readDate(),{machineId:e,startDate:I}}},e.GatewayIdentity={encode(A){const e=g.BebopView.getInstance();return e.startWriting(),this.encodeInto(A,e),e.toArray()},encodeInto(A,e){const I=e.length;return e.writeString(A.apiKey),e.writeInt64(A.id),e.writeString(A.externalId),e.length-I},decode(A){const e=g.BebopView.getInstance();return e.startReading(A),this.readFrom(e)},readFrom(A){let e,I,g;return e=A.readString(),I=A.readInt64(),g=A.readString(),{apiKey:e,id:I,externalId:g}}},e.Peer={encode(A){const e=g.BebopView.getInstance();return e.startWriting(),this.encodeInto(A,e),e.toArray()},encodeInto(A,e){const I=e.length;return e.writeInt64(A.id),e.writeString(A.externalId),e.writeDate(A.connectionDate),e.writeInt64(A.organizationId),e.length-I},decode(A){const e=g.BebopView.getInstance();return e.startReading(A),this.readFrom(e)},readFrom(A){let e,I,g,t;return e=A.readInt64(),I=A.readString(),g=A.readDate(),t=A.readInt64(),{id:e,externalId:I,connectionDate:g,organizationId:t}}},e.PendingConnectionRequest={encode(A){const e=g.BebopView.getInstance();return e.startWriting(),this.encodeInto(A,e),e.toArray()},encodeInto(A,e){const I=e.length;return e.writeInt64(A.sourcePeerId),e.writeInt64(A.targetPeerId),e.length-I},decode(A){const e=g.BebopView.getInstance();return e.startReading(A),this.readFrom(e)},readFrom(A){let e,I;return e=A.readInt64(),I=A.readInt64(),{sourcePeerId:e,targetPeerId:I}}},e.GatewayHeader={encode(A){const e=g.BebopView.getInstance();return e.startWriting(),this.encodeInto(A,e),e.toArray()},encodeInto(A,e){const I=e.length;return e.writeUint32(A.syncKey),e.length-I},decode(A){const e=g.BebopView.getInstance();return e.startReading(A),this.readFrom(e)},readFrom(A){let e;return e=A.readUint32(),{syncKey:e}}},e.GatewayDatagram={encode(A){const e=g.BebopView.getInstance();return e.startWriting(),this.encodeInto(A,e),e.toArray()},encodeInto(A,I){const g=I.length;return e.GatewayHeader.encodeInto(A.header,I),e.GatewayBody.encodeInto(A.body,I),I.length-g},decode(A){const e=g.BebopView.getInstance();return e.startReading(A),this.readFrom(e)},readFrom(A){let I,g;return I=e.GatewayHeader.readFrom(A),g=e.GatewayBody.readFrom(A),{header:I,body:g}}},e.GatewayRequest={discriminator:1,encode(A){const e=g.BebopView.getInstance();return e.startWriting(),this.encodeInto(A,e),e.toArray()},encodeInto(A,I){const g=I.length;return e.GatewayRequestBody.encodeInto(A.body,I),I.length-g},decode(A){const e=g.BebopView.getInstance();return e.startReading(A),this.readFrom(e)},readFrom(A){let I;return I=e.GatewayRequestBody.readFrom(A),{body:I}}},e.GatewayResponse={discriminator:2,encode(A){const e=g.BebopView.getInstance();return e.startWriting(),this.encodeInto(A,e),e.toArray()},encodeInto(A,I){const g=I.length;return e.GatewayResponseBody.encodeInto(A.body,I),I.length-g},decode(A){const e=g.BebopView.getInstance();return e.startReading(A),this.readFrom(e)},readFrom(A){let I;return I=e.GatewayResponseBody.readFrom(A),{body:I}}},e.GatewayAlert={discriminator:3,encode(A){const e=g.BebopView.getInstance();return e.startWriting(),this.encodeInto(A,e),e.toArray()},encodeInto(A,e){const I=e.length;return e.writeUint32(A.level),e.writeUint32(A.description),e.length-I},decode(A){const e=g.BebopView.getInstance();return e.startReading(A),this.readFrom(e)},readFrom(A){let e,I;return e=A.readUint32(),I=A.readUint32(),{level:e,description:I}}},e.GatewayForwardable={discriminator:4,encode(A){const e=g.BebopView.getInstance();return e.startWriting(),this.encodeInto(A,e),e.toArray()},encodeInto(A,I){const g=I.length;return I.writeInt64(A.targetPeerId),e.GatewayForwardableBody.encodeInto(A.body,I),I.length-g},decode(A){const e=g.BebopView.getInstance();return e.startReading(A),this.readFrom(e)},readFrom(A){let I,g;return I=A.readInt64(),g=e.GatewayForwardableBody.readFrom(A),{targetPeerId:I,body:g}}},e.GatewayBody={encode(A){const e=g.BebopView.getInstance();return e.startWriting(),this.encodeInto(A,e),e.toArray()},encodeInto(A,I){const g=I.length,t=I.reserveMessageLength(),i=I.length+1;switch(I.writeByte(A.discriminator),A.discriminator){case 1:e.GatewayRequest.encodeInto(A.value,I);break;case 2:e.GatewayResponse.encodeInto(A.value,I);break;case 3:e.GatewayAlert.encodeInto(A.value,I);break;case 4:e.GatewayForwardable.encodeInto(A.value,I)}const B=I.length;return I.fillMessageLength(t,B-i),I.length-g},decode(A){const e=g.BebopView.getInstance();return e.startReading(A),this.readFrom(e)},readFrom(A){const I=A.readMessageLength(),t=A.index+1+I;switch(A.readByte()){case 1:return{discriminator:1,value:e.GatewayRequest.readFrom(A)};case 2:return{discriminator:2,value:e.GatewayResponse.readFrom(A)};case 3:return{discriminator:3,value:e.GatewayAlert.readFrom(A)};case 4:return{discriminator:4,value:e.GatewayForwardable.readFrom(A)};default:throw A.index=t,new g.BebopRuntimeError("Unrecognized discriminator while decoding GatewayBody")}}},e.InitConnectionRequest={discriminator:1,encode(A){const e=g.BebopView.getInstance();return e.startWriting(),this.encodeInto(A,e),e.toArray()},encodeInto(A,e){const I=e.length;return e.writeInt64(A.targetPeerId),e.writeUint32(A.desiredTransport),e.length-I},decode(A){const e=g.BebopView.getInstance();return e.startReading(A),this.readFrom(e)},readFrom(A){let e,I;return e=A.readInt64(),I=A.readUint32(),{targetPeerId:e,desiredTransport:I}}},e.GatewayRequestBody={encode(A){const e=g.BebopView.getInstance();return e.startWriting(),this.encodeInto(A,e),e.toArray()},encodeInto(A,I){const g=I.length,t=I.reserveMessageLength(),i=I.length+1;I.writeByte(A.discriminator),1===A.discriminator&&e.InitConnectionRequest.encodeInto(A.value,I);const B=I.length;return I.fillMessageLength(t,B-i),I.length-g},decode(A){const e=g.BebopView.getInstance();return e.startReading(A),this.readFrom(e)},readFrom(A){const I=A.readMessageLength(),t=A.index+1+I;if(1===A.readByte())return{discriminator:1,value:e.InitConnectionRequest.readFrom(A)};throw A.index=t,new g.BebopRuntimeError("Unrecognized discriminator while decoding GatewayRequestBody")}},e.GatewayHello={discriminator:1,encode(A){const e=g.BebopView.getInstance();return e.startWriting(),this.encodeInto(A,e),e.toArray()},encodeInto(A,e){const I=e.length;return e.length-I},decode(A){const e=g.BebopView.getInstance();return e.startReading(A),this.readFrom(e)},readFrom:A=>({})},e.GatewayResponseBody={encode(A){const e=g.BebopView.getInstance();return e.startWriting(),this.encodeInto(A,e),e.toArray()},encodeInto(A,I){const g=I.length,t=I.reserveMessageLength(),i=I.length+1;I.writeByte(A.discriminator),1===A.discriminator&&e.GatewayHello.encodeInto(A.value,I);const B=I.length;return I.fillMessageLength(t,B-i),I.length-g},decode(A){const e=g.BebopView.getInstance();return e.startReading(A),this.readFrom(e)},readFrom(A){const I=A.readMessageLength(),t=A.index+1+I;if(1===A.readByte())return{discriminator:1,value:e.GatewayHello.readFrom(A)};throw A.index=t,new g.BebopRuntimeError("Unrecognized discriminator while decoding GatewayResponseBody")}},e.ConnectionRequest={discriminator:1,encode(A){const e=g.BebopView.getInstance();return e.startWriting(),this.encodeInto(A,e),e.toArray()},encodeInto(A,e){const I=e.length;return e.writeInt64(A.sourcePeerId),e.writeString(A.sourceExternalId),e.writeUint32(A.desiredTransport),e.writeGuid(A.id),e.writeDate(A.expirationDate),e.length-I},decode(A){const e=g.BebopView.getInstance();return e.startReading(A),this.readFrom(e)},readFrom(A){let e,I,g,t,i;return e=A.readInt64(),I=A.readString(),g=A.readUint32(),t=A.readGuid(),i=A.readDate(),{sourcePeerId:e,sourceExternalId:I,desiredTransport:g,id:t,expirationDate:i}}},e.AcceptedConnectionRequest={discriminator:2,encode(A){const e=g.BebopView.getInstance();return e.startWriting(),this.encodeInto(A,e),e.toArray()},encodeInto(A,e){const I=e.length;return e.writeInt64(A.sourcePeerId),e.writeString(A.sourceExternalId),e.writeGuid(A.id),e.length-I},decode(A){const e=g.BebopView.getInstance();return e.startReading(A),this.readFrom(e)},readFrom(A){let e,I,g;return e=A.readInt64(),I=A.readString(),g=A.readGuid(),{sourcePeerId:e,sourceExternalId:I,id:g}}},e.RejectedConnectionRequest={discriminator:3,encode(A){const e=g.BebopView.getInstance();return e.startWriting(),this.encodeInto(A,e),e.toArray()},encodeInto(A,e){const I=e.length;return e.writeInt64(A.sourcePeerId),e.writeString(A.sourceExternalId),e.writeGuid(A.id),e.writeString(A.reason),e.length-I},decode(A){const e=g.BebopView.getInstance();return e.startReading(A),this.readFrom(e)},readFrom(A){let e,I,g,t;return e=A.readInt64(),I=A.readString(),g=A.readGuid(),t=A.readString(),{sourcePeerId:e,sourceExternalId:I,id:g,reason:t}}},e.PeerSignalingInformation={discriminator:4,encode(A){const e=g.BebopView.getInstance();return e.startWriting(),this.encodeInto(A,e),e.toArray()},encodeInto(A,e){const I=e.length;return e.writeGuid(A.id),e.writeUint32(A.type),e.writeString(A.data),e.length-I},decode(A){const e=g.BebopView.getInstance();return e.startReading(A),this.readFrom(e)},readFrom(A){let e,I,g;return e=A.readGuid(),I=A.readUint32(),g=A.readString(),{id:e,type:I,data:g}}},e.GatewayForwardableBody={encode(A){const e=g.BebopView.getInstance();return e.startWriting(),this.encodeInto(A,e),e.toArray()},encodeInto(A,I){const g=I.length,t=I.reserveMessageLength(),i=I.length+1;switch(I.writeByte(A.discriminator),A.discriminator){case 1:e.ConnectionRequest.encodeInto(A.value,I);break;case 2:e.AcceptedConnectionRequest.encodeInto(A.value,I);break;case 3:e.RejectedConnectionRequest.encodeInto(A.value,I);break;case 4:e.PeerSignalingInformation.encodeInto(A.value,I)}const B=I.length;return I.fillMessageLength(t,B-i),I.length-g},decode(A){const e=g.BebopView.getInstance();return e.startReading(A),this.readFrom(e)},readFrom(A){const I=A.readMessageLength(),t=A.index+1+I;switch(A.readByte()){case 1:return{discriminator:1,value:e.ConnectionRequest.readFrom(A)};case 2:return{discriminator:2,value:e.AcceptedConnectionRequest.readFrom(A)};case 3:return{discriminator:3,value:e.RejectedConnectionRequest.readFrom(A)};case 4:return{discriminator:4,value:e.PeerSignalingInformation.readFrom(A)};default:throw A.index=t,new g.BebopRuntimeError("Unrecognized discriminator while decoding GatewayForwardableBody")}}},e.TelemetrySetKey="network:telemetry:batches",e.TelemetryBatchesKeyTemplate="network:telemetry:batches:{0}",e.RainwayTelemetryRequest={encode(A){const e=g.BebopView.getInstance();return e.startWriting(),this.encodeInto(A,e),e.toArray()},encodeInto(A,I){const g=I.length,t=I.reserveMessageLength(),i=I.length;if(null!=A.records){I.writeByte(1);{const g=A.records.length;I.writeUint32(g);for(let t=0;t<g;t++)e.RainwayTelemetryRecord.encodeInto(A.records[t],I)}}null!=A.commonAttributes&&(I.writeByte(2),e.RainwayTelemetryRecord.encodeInto(A.commonAttributes,I)),I.writeByte(0);const B=I.length;return I.fillMessageLength(t,B-i),I.length-g},decode(A){const e=g.BebopView.getInstance();return e.startReading(A),this.readFrom(e)},readFrom(A){let I={};const g=A.readMessageLength(),t=A.index+g;for(;;)switch(A.readByte()){case 0:return I;case 1:{let g=A.readUint32();I.records=new Array(g);for(let t=0;t<g;t++){let g;g=e.RainwayTelemetryRecord.readFrom(A),I.records[t]=g}}break;case 2:I.commonAttributes=e.RainwayTelemetryRecord.readFrom(A);break;default:return A.index=t,I}}},e.RainwayTelemetryRecord={encode(A){const e=g.BebopView.getInstance();return e.startWriting(),this.encodeInto(A,e),e.toArray()},encodeInto(A,I){const g=I.length,t=I.reserveMessageLength(),i=I.length;if(null!=A.name&&(I.writeByte(1),I.writeString(A.name)),null!=A.value&&(I.writeByte(2),I.writeString(A.value)),null!=A.time&&(I.writeByte(3),I.writeDate(A.time)),null!=A.type&&(I.writeByte(4),I.writeUint32(A.type)),null!=A.dimensions){I.writeByte(5);{const g=A.dimensions.length;I.writeUint32(g);for(let t=0;t<g;t++)e.RainwayTelemetryDimension.encodeInto(A.dimensions[t],I)}}I.writeByte(0);const B=I.length;return I.fillMessageLength(t,B-i),I.length-g},decode(A){const e=g.BebopView.getInstance();return e.startReading(A),this.readFrom(e)},readFrom(A){let I={};const g=A.readMessageLength(),t=A.index+g;for(;;)switch(A.readByte()){case 0:return I;case 1:I.name=A.readString();break;case 2:I.value=A.readString();break;case 3:I.time=A.readDate();break;case 4:I.type=A.readUint32();break;case 5:{let g=A.readUint32();I.dimensions=new Array(g);for(let t=0;t<g;t++){let g;g=e.RainwayTelemetryDimension.readFrom(A),I.dimensions[t]=g}}break;default:return A.index=t,I}}},e.RainwayTelemetryDimension={encode(A){const e=g.BebopView.getInstance();return e.startWriting(),this.encodeInto(A,e),e.toArray()},encodeInto(A,e){const I=e.length;return e.writeString(A.name),e.writeString(A.value),e.length-I},decode(A){const e=g.BebopView.getInstance();return e.startReading(A),this.readFrom(e)},readFrom(A){let e,I;return e=A.readString(),I=A.readString(),{name:e,value:I}}},(k=e.TelemetryValueType||(e.TelemetryValueType={}))[k.Double=0]="Double",k[k.BigInt=1]="BigInt",k[k.VarChar=2]="VarChar",k[k.Bool=3]="Bool",e.Request={encode(A){const e=g.BebopView.getInstance();return e.startWriting(),this.encodeInto(A,e),e.toArray()},encodeInto(A,I){const g=I.length;return I.writeGuid(A.requestId),e.Invocation.encodeInto(A.invocation,I),I.length-g},decode(A){const e=g.BebopView.getInstance();return e.startReading(A),this.readFrom(e)},readFrom(A){let I,g;return I=A.readGuid(),g=e.Invocation.readFrom(A),{requestId:I,invocation:g}}},e.Response={encode(A){const e=g.BebopView.getInstance();return e.startWriting(),this.encodeInto(A,e),e.toArray()},encodeInto(A,I){const g=I.length;return I.writeGuid(A.requestId),e.Return.encodeInto(A.ret,I),I.length-g},decode(A){const e=g.BebopView.getInstance();return e.startReading(A),this.readFrom(e)},readFrom(A){let I,g;return I=A.readGuid(),g=e.Return.readFrom(A),{requestId:I,ret:g}}},e.Initialize_Invoke={discriminator:1,encode(A){const e=g.BebopView.getInstance();return e.startWriting(),this.encodeInto(A,e),e.toArray()},encodeInto(A,e){const I=e.length,g=e.reserveMessageLength(),t=e.length;null!=A.externalId&&(e.writeByte(1),e.writeString(A.externalId)),e.writeByte(0);const i=e.length;return e.fillMessageLength(g,i-t),e.length-I},decode(A){const e=g.BebopView.getInstance();return e.startReading(A),this.readFrom(e)},readFrom(A){let e={};const I=A.readMessageLength(),g=A.index+I;for(;;)switch(A.readByte()){case 0:return e;case 1:e.externalId=A.readString();break;default:return A.index=g,e}}},e.Shutdown_Invoke={discriminator:2,encode(A){const e=g.BebopView.getInstance();return e.startWriting(),this.encodeInto(A,e),e.toArray()},encodeInto(A,e){const I=e.length,g=e.reserveMessageLength(),t=e.length;e.writeByte(0);const i=e.length;return e.fillMessageLength(g,i-t),e.length-I},decode(A){const e=g.BebopView.getInstance();return e.startReading(A),this.readFrom(e)},readFrom(A){let e={};const I=A.readMessageLength(),g=A.index+I;for(;;)return 0===A.readByte()||(A.index=g),e}},e.GetVersion_Invoke={discriminator:3,encode(A){const e=g.BebopView.getInstance();return e.startWriting(),this.encodeInto(A,e),e.toArray()},encodeInto(A,e){const I=e.length,g=e.reserveMessageLength(),t=e.length;e.writeByte(0);const i=e.length;return e.fillMessageLength(g,i-t),e.length-I},decode(A){const e=g.BebopView.getInstance();return e.startReading(A),this.readFrom(e)},readFrom(A){let e={};const I=A.readMessageLength(),g=A.index+I;for(;;)return 0===A.readByte()||(A.index=g),e}},e.GetPeerId_Invoke={discriminator:4,encode(A){const e=g.BebopView.getInstance();return e.startWriting(),this.encodeInto(A,e),e.toArray()},encodeInto(A,e){const I=e.length,g=e.reserveMessageLength(),t=e.length;e.writeByte(0);const i=e.length;return e.fillMessageLength(g,i-t),e.length-I},decode(A){const e=g.BebopView.getInstance();return e.startReading(A),this.readFrom(e)},readFrom(A){let e={};const I=A.readMessageLength(),g=A.index+I;for(;;)return 0===A.readByte()||(A.index=g),e}},e.SetLogLevel_Invoke={discriminator:5,encode(A){const e=g.BebopView.getInstance();return e.startWriting(),this.encodeInto(A,e),e.toArray()},encodeInto(A,e){const I=e.length,g=e.reserveMessageLength(),t=e.length;null!=A.level&&(e.writeByte(1),e.writeUint32(A.level)),e.writeByte(0);const i=e.length;return e.fillMessageLength(g,i-t),e.length-I},decode(A){const e=g.BebopView.getInstance();return e.startReading(A),this.readFrom(e)},readFrom(A){let e={};const I=A.readMessageLength(),g=A.index+I;for(;;)switch(A.readByte()){case 0:return e;case 1:e.level=A.readUint32();break;default:return A.index=g,e}}},e.GetLogs_Invoke={discriminator:6,encode(A){const e=g.BebopView.getInstance();return e.startWriting(),this.encodeInto(A,e),e.toArray()},encodeInto(A,e){const I=e.length,g=e.reserveMessageLength(),t=e.length;e.writeByte(0);const i=e.length;return e.fillMessageLength(g,i-t),e.length-I},decode(A){const e=g.BebopView.getInstance();return e.startReading(A),this.readFrom(e)},readFrom(A){let e={};const I=A.readMessageLength(),g=A.index+I;for(;;)return 0===A.readByte()||(A.index=g),e}},e.ClearLogs_Invoke={discriminator:7,encode(A){const e=g.BebopView.getInstance();return e.startWriting(),this.encodeInto(A,e),e.toArray()},encodeInto(A,e){const I=e.length,g=e.reserveMessageLength(),t=e.length;e.writeByte(0);const i=e.length;return e.fillMessageLength(g,i-t),e.length-I},decode(A){const e=g.BebopView.getInstance();return e.startReading(A),this.readFrom(e)},readFrom(A){let e={};const I=A.readMessageLength(),g=A.index+I;for(;;)return 0===A.readByte()||(A.index=g),e}},e.AcceptJoinRequest_Invoke={discriminator:8,encode(A){const e=g.BebopView.getInstance();return e.startWriting(),this.encodeInto(A,e),e.toArray()},encodeInto(A,e){const I=e.length,g=e.reserveMessageLength(),t=e.length;e.writeByte(0);const i=e.length;return e.fillMessageLength(g,i-t),e.length-I},decode(A){const e=g.BebopView.getInstance();return e.startReading(A),this.readFrom(e)},readFrom(A){let e={};const I=A.readMessageLength(),g=A.index+I;for(;;)return 0===A.readByte()||(A.index=g),e}},e.RejectJoinRequest_Invoke={discriminator:9,encode(A){const e=g.BebopView.getInstance();return e.startWriting(),this.encodeInto(A,e),e.toArray()},encodeInto(A,e){const I=e.length,g=e.reserveMessageLength(),t=e.length;null!=A.reason&&(e.writeByte(1),e.writeString(A.reason)),e.writeByte(0);const i=e.length;return e.fillMessageLength(g,i-t),e.length-I},decode(A){const e=g.BebopView.getInstance();return e.startReading(A),this.readFrom(e)},readFrom(A){let e={};const I=A.readMessageLength(),g=A.index+I;for(;;)switch(A.readByte()){case 0:return e;case 1:e.reason=A.readString();break;default:return A.index=g,e}}},e.GetJoinRequests_Invoke={discriminator:10,encode(A){const e=g.BebopView.getInstance();return e.startWriting(),this.encodeInto(A,e),e.toArray()},encodeInto(A,e){const I=e.length,g=e.reserveMessageLength(),t=e.length;e.writeByte(0);const i=e.length;return e.fillMessageLength(g,i-t),e.length-I},decode(A){const e=g.BebopView.getInstance();return e.startReading(A),this.readFrom(e)},readFrom(A){let e={};const I=A.readMessageLength(),g=A.index+I;for(;;)return 0===A.readByte()||(A.index=g),e}},e.ClearJoinRequests_Invoke={discriminator:11,encode(A){const e=g.BebopView.getInstance();return e.startWriting(),this.encodeInto(A,e),e.toArray()},encodeInto(A,e){const I=e.length,g=e.reserveMessageLength(),t=e.length;e.writeByte(0);const i=e.length;return e.fillMessageLength(g,i-t),e.length-I},decode(A){const e=g.BebopView.getInstance();return e.startReading(A),this.readFrom(e)},readFrom(A){let e={};const I=A.readMessageLength(),g=A.index+I;for(;;)return 0===A.readByte()||(A.index=g),e}},e.AcceptStreamRequest_Invoke={discriminator:12,encode(A){const e=g.BebopView.getInstance();return e.startWriting(),this.encodeInto(A,e),e.toArray()},encodeInto(A,e){const I=e.length,g=e.reserveMessageLength(),t=e.length;if(null!=A.level&&(e.writeByte(1),e.writeUint32(A.level)),null!=A.pids){e.writeByte(2);{const I=A.pids.length;e.writeUint32(I);for(let g=0;g<I;g++)e.writeUint32(A.pids[g])}}e.writeByte(0);const i=e.length;return e.fillMessageLength(g,i-t),e.length-I},decode(A){const e=g.BebopView.getInstance();return e.startReading(A),this.readFrom(e)},readFrom(A){let e={};const I=A.readMessageLength(),g=A.index+I;for(;;)switch(A.readByte()){case 0:return e;case 1:e.level=A.readUint32();break;case 2:{let I=A.readUint32();e.pids=new Array(I);for(let g=0;g<I;g++){let I;I=A.readUint32(),e.pids[g]=I}}break;default:return A.index=g,e}}},e.RejectStreamRequest_Invoke={discriminator:13,encode(A){const e=g.BebopView.getInstance();return e.startWriting(),this.encodeInto(A,e),e.toArray()},encodeInto(A,e){const I=e.length,g=e.reserveMessageLength(),t=e.length;null!=A.reason&&(e.writeByte(1),e.writeString(A.reason)),e.writeByte(0);const i=e.length;return e.fillMessageLength(g,i-t),e.length-I},decode(A){const e=g.BebopView.getInstance();return e.startReading(A),this.readFrom(e)},readFrom(A){let e={};const I=A.readMessageLength(),g=A.index+I;for(;;)switch(A.readByte()){case 0:return e;case 1:e.reason=A.readString();break;default:return A.index=g,e}}},e.GetStreamRequests_Invoke={discriminator:14,encode(A){const e=g.BebopView.getInstance();return e.startWriting(),this.encodeInto(A,e),e.toArray()},encodeInto(A,e){const I=e.length,g=e.reserveMessageLength(),t=e.length;e.writeByte(0);const i=e.length;return e.fillMessageLength(g,i-t),e.length-I},decode(A){const e=g.BebopView.getInstance();return e.startReading(A),this.readFrom(e)},readFrom(A){let e={};const I=A.readMessageLength(),g=A.index+I;for(;;)return 0===A.readByte()||(A.index=g),e}},e.ClearStreamRequests_Invoke={discriminator:15,encode(A){const e=g.BebopView.getInstance();return e.startWriting(),this.encodeInto(A,e),e.toArray()},encodeInto(A,e){const I=e.length,g=e.reserveMessageLength(),t=e.length;e.writeByte(0);const i=e.length;return e.fillMessageLength(g,i-t),e.length-I},decode(A){const e=g.BebopView.getInstance();return e.startReading(A),this.readFrom(e)},readFrom(A){let e={};const I=A.readMessageLength(),g=A.index+I;for(;;)return 0===A.readByte()||(A.index=g),e}},e.GetPeerStateChanges_Invoke={discriminator:16,encode(A){const e=g.BebopView.getInstance();return e.startWriting(),this.encodeInto(A,e),e.toArray()},encodeInto(A,e){const I=e.length,g=e.reserveMessageLength(),t=e.length;e.writeByte(0);const i=e.length;return e.fillMessageLength(g,i-t),e.length-I},decode(A){const e=g.BebopView.getInstance();return e.startReading(A),this.readFrom(e)},readFrom(A){let e={};const I=A.readMessageLength(),g=A.index+I;for(;;)return 0===A.readByte()||(A.index=g),e}},e.ClearPeerStateChanges_Invoke={discriminator:17,encode(A){const e=g.BebopView.getInstance();return e.startWriting(),this.encodeInto(A,e),e.toArray()},encodeInto(A,e){const I=e.length,g=e.reserveMessageLength(),t=e.length;e.writeByte(0);const i=e.length;return e.fillMessageLength(g,i-t),e.length-I},decode(A){const e=g.BebopView.getInstance();return e.startReading(A),this.readFrom(e)},readFrom(A){let e={};const I=A.readMessageLength(),g=A.index+I;for(;;)return 0===A.readByte()||(A.index=g),e}},e.GetPeerMessages_Invoke={discriminator:18,encode(A){const e=g.BebopView.getInstance();return e.startWriting(),this.encodeInto(A,e),e.toArray()},encodeInto(A,e){const I=e.length,g=e.reserveMessageLength(),t=e.length;e.writeByte(0);const i=e.length;return e.fillMessageLength(g,i-t),e.length-I},decode(A){const e=g.BebopView.getInstance();return e.startReading(A),this.readFrom(e)},readFrom(A){let e={};const I=A.readMessageLength(),g=A.index+I;for(;;)return 0===A.readByte()||(A.index=g),e}},e.ClearPeerMessages_Invoke={discriminator:19,encode(A){const e=g.BebopView.getInstance();return e.startWriting(),this.encodeInto(A,e),e.toArray()},encodeInto(A,e){const I=e.length,g=e.reserveMessageLength(),t=e.length;e.writeByte(0);const i=e.length;return e.fillMessageLength(g,i-t),e.length-I},decode(A){const e=g.BebopView.getInstance();return e.startReading(A),this.readFrom(e)},readFrom(A){let e={};const I=A.readMessageLength(),g=A.index+I;for(;;)return 0===A.readByte()||(A.index=g),e}},e.Invocation={encode(A){const e=g.BebopView.getInstance();return e.startWriting(),this.encodeInto(A,e),e.toArray()},encodeInto(A,I){const g=I.length,t=I.reserveMessageLength(),i=I.length+1;switch(I.writeByte(A.discriminator),A.discriminator){case 1:e.Initialize_Invoke.encodeInto(A.value,I);break;case 2:e.Shutdown_Invoke.encodeInto(A.value,I);break;case 3:e.GetVersion_Invoke.encodeInto(A.value,I);break;case 4:e.GetPeerId_Invoke.encodeInto(A.value,I);break;case 5:e.SetLogLevel_Invoke.encodeInto(A.value,I);break;case 6:e.GetLogs_Invoke.encodeInto(A.value,I);break;case 7:e.ClearLogs_Invoke.encodeInto(A.value,I);break;case 8:e.AcceptJoinRequest_Invoke.encodeInto(A.value,I);break;case 9:e.RejectJoinRequest_Invoke.encodeInto(A.value,I);break;case 10:e.GetJoinRequests_Invoke.encodeInto(A.value,I);break;case 11:e.ClearJoinRequests_Invoke.encodeInto(A.value,I);break;case 12:e.AcceptStreamRequest_Invoke.encodeInto(A.value,I);break;case 13:e.RejectStreamRequest_Invoke.encodeInto(A.value,I);break;case 14:e.GetStreamRequests_Invoke.encodeInto(A.value,I);break;case 15:e.ClearStreamRequests_Invoke.encodeInto(A.value,I);break;case 16:e.GetPeerStateChanges_Invoke.encodeInto(A.value,I);break;case 17:e.ClearPeerStateChanges_Invoke.encodeInto(A.value,I);break;case 18:e.GetPeerMessages_Invoke.encodeInto(A.value,I);break;case 19:e.ClearPeerMessages_Invoke.encodeInto(A.value,I)}const B=I.length;return I.fillMessageLength(t,B-i),I.length-g},decode(A){const e=g.BebopView.getInstance();return e.startReading(A),this.readFrom(e)},readFrom(A){const I=A.readMessageLength(),t=A.index+1+I;switch(A.readByte()){case 1:return{discriminator:1,value:e.Initialize_Invoke.readFrom(A)};case 2:return{discriminator:2,value:e.Shutdown_Invoke.readFrom(A)};case 3:return{discriminator:3,value:e.GetVersion_Invoke.readFrom(A)};case 4:return{discriminator:4,value:e.GetPeerId_Invoke.readFrom(A)};case 5:return{discriminator:5,value:e.SetLogLevel_Invoke.readFrom(A)};case 6:return{discriminator:6,value:e.GetLogs_Invoke.readFrom(A)};case 7:return{discriminator:7,value:e.ClearLogs_Invoke.readFrom(A)};case 8:return{discriminator:8,value:e.AcceptJoinRequest_Invoke.readFrom(A)};case 9:return{discriminator:9,value:e.RejectJoinRequest_Invoke.readFrom(A)};case 10:return{discriminator:10,value:e.GetJoinRequests_Invoke.readFrom(A)};case 11:return{discriminator:11,value:e.ClearJoinRequests_Invoke.readFrom(A)};case 12:return{discriminator:12,value:e.AcceptStreamRequest_Invoke.readFrom(A)};case 13:return{discriminator:13,value:e.RejectStreamRequest_Invoke.readFrom(A)};case 14:return{discriminator:14,value:e.GetStreamRequests_Invoke.readFrom(A)};case 15:return{discriminator:15,value:e.ClearStreamRequests_Invoke.readFrom(A)};case 16:return{discriminator:16,value:e.GetPeerStateChanges_Invoke.readFrom(A)};case 17:return{discriminator:17,value:e.ClearPeerStateChanges_Invoke.readFrom(A)};case 18:return{discriminator:18,value:e.GetPeerMessages_Invoke.readFrom(A)};case 19:return{discriminator:19,value:e.ClearPeerMessages_Invoke.readFrom(A)};default:throw A.index=t,new g.BebopRuntimeError("Unrecognized discriminator while decoding Invocation")}}},e.Error_Return={discriminator:1,encode(A){const e=g.BebopView.getInstance();return e.startWriting(),this.encodeInto(A,e),e.toArray()},encodeInto(A,e){const I=e.length,g=e.reserveMessageLength(),t=e.length;null!=A.data&&(e.writeByte(1),e.writeString(A.data)),null!=A.stack&&(e.writeByte(2),e.writeString(A.stack)),e.writeByte(0);const i=e.length;return e.fillMessageLength(g,i-t),e.length-I},decode(A){const e=g.BebopView.getInstance();return e.startReading(A),this.readFrom(e)},readFrom(A){let e={};const I=A.readMessageLength(),g=A.index+I;for(;;)switch(A.readByte()){case 0:return e;case 1:e.data=A.readString();break;case 2:e.stack=A.readString();break;default:return A.index=g,e}}},e.Initialize_Return={discriminator:2,encode(A){const e=g.BebopView.getInstance();return e.startWriting(),this.encodeInto(A,e),e.toArray()},encodeInto(A,e){const I=e.length,g=e.reserveMessageLength(),t=e.length;null!=A.alreadyInitialized&&(e.writeByte(1),e.writeByte(Number(A.alreadyInitialized))),e.writeByte(0);const i=e.length;return e.fillMessageLength(g,i-t),e.length-I},decode(A){const e=g.BebopView.getInstance();return e.startReading(A),this.readFrom(e)},readFrom(A){let e={};const I=A.readMessageLength(),g=A.index+I;for(;;)switch(A.readByte()){case 0:return e;case 1:e.alreadyInitialized=!!A.readByte();break;default:return A.index=g,e}}},e.Shutdown_Return={discriminator:3,encode(A){const e=g.BebopView.getInstance();return e.startWriting(),this.encodeInto(A,e),e.toArray()},encodeInto(A,e){const I=e.length,g=e.reserveMessageLength(),t=e.length;e.writeByte(0);const i=e.length;return e.fillMessageLength(g,i-t),e.length-I},decode(A){const e=g.BebopView.getInstance();return e.startReading(A),this.readFrom(e)},readFrom(A){let e={};const I=A.readMessageLength(),g=A.index+I;for(;;)return 0===A.readByte()||(A.index=g),e}},e.GetVersion_Return={discriminator:4,encode(A){const e=g.BebopView.getInstance();return e.startWriting(),this.encodeInto(A,e),e.toArray()},encodeInto(A,e){const I=e.length,g=e.reserveMessageLength(),t=e.length;null!=A.version&&(e.writeByte(1),e.writeString(A.version)),e.writeByte(0);const i=e.length;return e.fillMessageLength(g,i-t),e.length-I},decode(A){const e=g.BebopView.getInstance();return e.startReading(A),this.readFrom(e)},readFrom(A){let e={};const I=A.readMessageLength(),g=A.index+I;for(;;)switch(A.readByte()){case 0:return e;case 1:e.version=A.readString();break;default:return A.index=g,e}}},e.GetPeerId_Return={discriminator:5,encode(A){const e=g.BebopView.getInstance();return e.startWriting(),this.encodeInto(A,e),e.toArray()},encodeInto(A,e){const I=e.length,g=e.reserveMessageLength(),t=e.length;null!=A.peerId&&(e.writeByte(1),e.writeString(A.peerId)),e.writeByte(0);const i=e.length;return e.fillMessageLength(g,i-t),e.length-I},decode(A){const e=g.BebopView.getInstance();return e.startReading(A),this.readFrom(e)},readFrom(A){let e={};const I=A.readMessageLength(),g=A.index+I;for(;;)switch(A.readByte()){case 0:return e;case 1:e.peerId=A.readString();break;default:return A.index=g,e}}},e.SetLogLevel_Return={discriminator:6,encode(A){const e=g.BebopView.getInstance();return e.startWriting(),this.encodeInto(A,e),e.toArray()},encodeInto(A,e){const I=e.length,g=e.reserveMessageLength(),t=e.length;e.writeByte(0);const i=e.length;return e.fillMessageLength(g,i-t),e.length-I},decode(A){const e=g.BebopView.getInstance();return e.startReading(A),this.readFrom(e)},readFrom(A){let e={};const I=A.readMessageLength(),g=A.index+I;for(;;)return 0===A.readByte()||(A.index=g),e}},e.GetLogs_Return={discriminator:7,encode(A){const e=g.BebopView.getInstance();return e.startWriting(),this.encodeInto(A,e),e.toArray()},encodeInto(A,I){const g=I.length,t=I.reserveMessageLength(),i=I.length;if(null!=A.data){I.writeByte(1);{const g=A.data.length;I.writeUint32(g);for(let t=0;t<g;t++)e.LogEntry.encodeInto(A.data[t],I)}}I.writeByte(0);const B=I.length;return I.fillMessageLength(t,B-i),I.length-g},decode(A){const e=g.BebopView.getInstance();return e.startReading(A),this.readFrom(e)},readFrom(A){let I={};const g=A.readMessageLength(),t=A.index+g;for(;;)switch(A.readByte()){case 0:return I;case 1:{let g=A.readUint32();I.data=new Array(g);for(let t=0;t<g;t++){let g;g=e.LogEntry.readFrom(A),I.data[t]=g}}break;default:return A.index=t,I}}},e.ClearLogs_Return={discriminator:8,encode(A){const e=g.BebopView.getInstance();return e.startWriting(),this.encodeInto(A,e),e.toArray()},encodeInto(A,e){const I=e.length,g=e.reserveMessageLength(),t=e.length;e.writeByte(0);const i=e.length;return e.fillMessageLength(g,i-t),e.length-I},decode(A){const e=g.BebopView.getInstance();return e.startReading(A),this.readFrom(e)},readFrom(A){let e={};const I=A.readMessageLength(),g=A.index+I;for(;;)return 0===A.readByte()||(A.index=g),e}},e.AcceptJoinRequest_Return={discriminator:9,encode(A){const e=g.BebopView.getInstance();return e.startWriting(),this.encodeInto(A,e),e.toArray()},encodeInto(A,e){const I=e.length,g=e.reserveMessageLength(),t=e.length;e.writeByte(0);const i=e.length;return e.fillMessageLength(g,i-t),e.length-I},decode(A){const e=g.BebopView.getInstance();return e.startReading(A),this.readFrom(e)},readFrom(A){let e={};const I=A.readMessageLength(),g=A.index+I;for(;;)return 0===A.readByte()||(A.index=g),e}},e.RejectJoinRequest_Return={discriminator:10,encode(A){const e=g.BebopView.getInstance();return e.startWriting(),this.encodeInto(A,e),e.toArray()},encodeInto(A,e){const I=e.length,g=e.reserveMessageLength(),t=e.length;e.writeByte(0);const i=e.length;return e.fillMessageLength(g,i-t),e.length-I},decode(A){const e=g.BebopView.getInstance();return e.startReading(A),this.readFrom(e)},readFrom(A){let e={};const I=A.readMessageLength(),g=A.index+I;for(;;)return 0===A.readByte()||(A.index=g),e}},e.GetJoinRequests_Return={discriminator:11,encode(A){const e=g.BebopView.getInstance();return e.startWriting(),this.encodeInto(A,e),e.toArray()},encodeInto(A,I){const g=I.length,t=I.reserveMessageLength(),i=I.length;if(null!=A.requests){I.writeByte(1);{const g=A.requests.length;I.writeUint32(g);for(let t=0;t<g;t++)e.JoinRequestOperation.encodeInto(A.requests[t],I)}}I.writeByte(0);const B=I.length;return I.fillMessageLength(t,B-i),I.length-g},decode(A){const e=g.BebopView.getInstance();return e.startReading(A),this.readFrom(e)},readFrom(A){let I={};const g=A.readMessageLength(),t=A.index+g;for(;;)switch(A.readByte()){case 0:return I;case 1:{let g=A.readUint32();I.requests=new Array(g);for(let t=0;t<g;t++){let g;g=e.JoinRequestOperation.readFrom(A),I.requests[t]=g}}break;default:return A.index=t,I}}},e.ClearJoinRequests_Return={discriminator:12,encode(A){const e=g.BebopView.getInstance();return e.startWriting(),this.encodeInto(A,e),e.toArray()},encodeInto(A,e){const I=e.length,g=e.reserveMessageLength(),t=e.length;e.writeByte(0);const i=e.length;return e.fillMessageLength(g,i-t),e.length-I},decode(A){const e=g.BebopView.getInstance();return e.startReading(A),this.readFrom(e)},readFrom(A){let e={};const I=A.readMessageLength(),g=A.index+I;for(;;)return 0===A.readByte()||(A.index=g),e}},e.AcceptStreamRequest_Return={discriminator:13,encode(A){const e=g.BebopView.getInstance();return e.startWriting(),this.encodeInto(A,e),e.toArray()},encodeInto(A,e){const I=e.length,g=e.reserveMessageLength(),t=e.length;e.writeByte(0);const i=e.length;return e.fillMessageLength(g,i-t),e.length-I},decode(A){const e=g.BebopView.getInstance();return e.startReading(A),this.readFrom(e)},readFrom(A){let e={};const I=A.readMessageLength(),g=A.index+I;for(;;)return 0===A.readByte()||(A.index=g),e}},e.RejectStreamRequest_Return={discriminator:14,encode(A){const e=g.BebopView.getInstance();return e.startWriting(),this.encodeInto(A,e),e.toArray()},encodeInto(A,e){const I=e.length,g=e.reserveMessageLength(),t=e.length;e.writeByte(0);const i=e.length;return e.fillMessageLength(g,i-t),e.length-I},decode(A){const e=g.BebopView.getInstance();return e.startReading(A),this.readFrom(e)},readFrom(A){let e={};const I=A.readMessageLength(),g=A.index+I;for(;;)return 0===A.readByte()||(A.index=g),e}},e.GetStreamRequests_Return={discriminator:15,encode(A){const e=g.BebopView.getInstance();return e.startWriting(),this.encodeInto(A,e),e.toArray()},encodeInto(A,I){const g=I.length,t=I.reserveMessageLength(),i=I.length;if(null!=A.requests){I.writeByte(1);{const g=A.requests.length;I.writeUint32(g);for(let t=0;t<g;t++)e.StreamRequestOperation.encodeInto(A.requests[t],I)}}I.writeByte(0);const B=I.length;return I.fillMessageLength(t,B-i),I.length-g},decode(A){const e=g.BebopView.getInstance();return e.startReading(A),this.readFrom(e)},readFrom(A){let I={};const g=A.readMessageLength(),t=A.index+g;for(;;)switch(A.readByte()){case 0:return I;case 1:{let g=A.readUint32();I.requests=new Array(g);for(let t=0;t<g;t++){let g;g=e.StreamRequestOperation.readFrom(A),I.requests[t]=g}}break;default:return A.index=t,I}}},e.ClearStreamRequests_Return={discriminator:16,encode(A){const e=g.BebopView.getInstance();return e.startWriting(),this.encodeInto(A,e),e.toArray()},encodeInto(A,e){const I=e.length,g=e.reserveMessageLength(),t=e.length;e.writeByte(0);const i=e.length;return e.fillMessageLength(g,i-t),e.length-I},decode(A){const e=g.BebopView.getInstance();return e.startReading(A),this.readFrom(e)},readFrom(A){let e={};const I=A.readMessageLength(),g=A.index+I;for(;;)return 0===A.readByte()||(A.index=g),e}},e.GetPeerStateChanges_Return={discriminator:17,encode(A){const e=g.BebopView.getInstance();return e.startWriting(),this.encodeInto(A,e),e.toArray()},encodeInto(A,I){const g=I.length,t=I.reserveMessageLength(),i=I.length;if(null!=A.changes){I.writeByte(1);{const g=A.changes.length;I.writeUint32(g);for(let t=0;t<g;t++)e.PeerStateChange.encodeInto(A.changes[t],I)}}I.writeByte(0);const B=I.length;return I.fillMessageLength(t,B-i),I.length-g},decode(A){const e=g.BebopView.getInstance();return e.startReading(A),this.readFrom(e)},readFrom(A){let I={};const g=A.readMessageLength(),t=A.index+g;for(;;)switch(A.readByte()){case 0:return I;case 1:{let g=A.readUint32();I.changes=new Array(g);for(let t=0;t<g;t++){let g;g=e.PeerStateChange.readFrom(A),I.changes[t]=g}}break;default:return A.index=t,I}}},e.ClearPeerStateChanges_Return={discriminator:18,encode(A){const e=g.BebopView.getInstance();return e.startWriting(),this.encodeInto(A,e),e.toArray()},encodeInto(A,e){const I=e.length,g=e.reserveMessageLength(),t=e.length;e.writeByte(0);const i=e.length;return e.fillMessageLength(g,i-t),e.length-I},decode(A){const e=g.BebopView.getInstance();return e.startReading(A),this.readFrom(e)},readFrom(A){let e={};const I=A.readMessageLength(),g=A.index+I;for(;;)return 0===A.readByte()||(A.index=g),e}},e.GetPeerMessages_Return={discriminator:19,encode(A){const e=g.BebopView.getInstance();return e.startWriting(),this.encodeInto(A,e),e.toArray()},encodeInto(A,I){const g=I.length,t=I.reserveMessageLength(),i=I.length;if(null!=A.messages){I.writeByte(1);{const g=A.messages.length;I.writeUint32(g);for(let t=0;t<g;t++)e.PeerMessage.encodeInto(A.messages[t],I)}}I.writeByte(0);const B=I.length;return I.fillMessageLength(t,B-i),I.length-g},decode(A){const e=g.BebopView.getInstance();return e.startReading(A),this.readFrom(e)},readFrom(A){let I={};const g=A.readMessageLength(),t=A.index+g;for(;;)switch(A.readByte()){case 0:return I;case 1:{let g=A.readUint32();I.messages=new Array(g);for(let t=0;t<g;t++){let g;g=e.PeerMessage.readFrom(A),I.messages[t]=g}}break;default:return A.index=t,I}}},e.ClearPeerMessages_Return={discriminator:20,encode(A){const e=g.BebopView.getInstance();return e.startWriting(),this.encodeInto(A,e),e.toArray()},encodeInto(A,e){const I=e.length,g=e.reserveMessageLength(),t=e.length;e.writeByte(0);const i=e.length;return e.fillMessageLength(g,i-t),e.length-I},decode(A){const e=g.BebopView.getInstance();return e.startReading(A),this.readFrom(e)},readFrom(A){let e={};const I=A.readMessageLength(),g=A.index+I;for(;;)return 0===A.readByte()||(A.index=g),e}},e.Return={encode(A){const e=g.BebopView.getInstance();return e.startWriting(),this.encodeInto(A,e),e.toArray()},encodeInto(A,I){const g=I.length,t=I.reserveMessageLength(),i=I.length+1;switch(I.writeByte(A.discriminator),A.discriminator){case 1:e.Error_Return.encodeInto(A.value,I);break;case 2:e.Initialize_Return.encodeInto(A.value,I);break;case 3:e.Shutdown_Return.encodeInto(A.value,I);break;case 4:e.GetVersion_Return.encodeInto(A.value,I);break;case 5:e.GetPeerId_Return.encodeInto(A.value,I);break;case 6:e.SetLogLevel_Return.encodeInto(A.value,I);break;case 7:e.GetLogs_Return.encodeInto(A.value,I);break;case 8:e.ClearLogs_Return.encodeInto(A.value,I);break;case 9:e.AcceptJoinRequest_Return.encodeInto(A.value,I);break;case 10:e.RejectJoinRequest_Return.encodeInto(A.value,I);break;case 11:e.GetJoinRequests_Return.encodeInto(A.value,I);break;case 12:e.ClearJoinRequests_Return.encodeInto(A.value,I);break;case 13:e.AcceptStreamRequest_Return.encodeInto(A.value,I);break;case 14:e.RejectStreamRequest_Return.encodeInto(A.value,I);break;case 15:e.GetStreamRequests_Return.encodeInto(A.value,I);break;case 16:e.ClearStreamRequests_Return.encodeInto(A.value,I);break;case 17:e.GetPeerStateChanges_Return.encodeInto(A.value,I);break;case 18:e.ClearPeerStateChanges_Return.encodeInto(A.value,I);break;case 19:e.GetPeerMessages_Return.encodeInto(A.value,I);break;case 20:e.ClearPeerMessages_Return.encodeInto(A.value,I)}const B=I.length;return I.fillMessageLength(t,B-i),I.length-g},decode(A){const e=g.BebopView.getInstance();return e.startReading(A),this.readFrom(e)},readFrom(A){const I=A.readMessageLength(),t=A.index+1+I;switch(A.readByte()){case 1:return{discriminator:1,value:e.Error_Return.readFrom(A)};case 2:return{discriminator:2,value:e.Initialize_Return.readFrom(A)};case 3:return{discriminator:3,value:e.Shutdown_Return.readFrom(A)};case 4:return{discriminator:4,value:e.GetVersion_Return.readFrom(A)};case 5:return{discriminator:5,value:e.GetPeerId_Return.readFrom(A)};case 6:return{discriminator:6,value:e.SetLogLevel_Return.readFrom(A)};case 7:return{discriminator:7,value:e.GetLogs_Return.readFrom(A)};case 8:return{discriminator:8,value:e.ClearLogs_Return.readFrom(A)};case 9:return{discriminator:9,value:e.AcceptJoinRequest_Return.readFrom(A)};case 10:return{discriminator:10,value:e.RejectJoinRequest_Return.readFrom(A)};case 11:return{discriminator:11,value:e.GetJoinRequests_Return.readFrom(A)};case 12:return{discriminator:12,value:e.ClearJoinRequests_Return.readFrom(A)};case 13:return{discriminator:13,value:e.AcceptStreamRequest_Return.readFrom(A)};case 14:return{discriminator:14,value:e.RejectStreamRequest_Return.readFrom(A)};case 15:return{discriminator:15,value:e.GetStreamRequests_Return.readFrom(A)};case 16:return{discriminator:16,value:e.ClearStreamRequests_Return.readFrom(A)};case 17:return{discriminator:17,value:e.GetPeerStateChanges_Return.readFrom(A)};case 18:return{discriminator:18,value:e.ClearPeerStateChanges_Return.readFrom(A)};case 19:return{discriminator:19,value:e.GetPeerMessages_Return.readFrom(A)};case 20:return{discriminator:20,value:e.ClearPeerMessages_Return.readFrom(A)};default:throw A.index=t,new g.BebopRuntimeError("Unrecognized discriminator while decoding Return")}}},(m=e.LogLevel||(e.LogLevel={}))[m.Silent=0]="Silent",m[m.Error=1]="Error",m[m.Warning=2]="Warning",m[m.Info=3]="Info",m[m.Debug=4]="Debug",m[m.Trace=5]="Trace",(f=e.PeerState||(e.PeerState={}))[f.New=0]="New",f[f.Connecting=1]="Connecting",f[f.Connected=2]="Connected",f[f.Disconnected=3]="Disconnected",f[f.Failed=4]="Failed",e.LogEntry={encode(A){const e=g.BebopView.getInstance();return e.startWriting(),this.encodeInto(A,e),e.toArray()},encodeInto(A,e){const I=e.length;return e.writeUint32(A.level),e.writeString(A.target),e.writeString(A.data),e.length-I},decode(A){const e=g.BebopView.getInstance();return e.startReading(A),this.readFrom(e)},readFrom(A){let e,I,g;return e=A.readUint32(),I=A.readString(),g=A.readString(),{level:e,target:I,data:g}}},e.JoinRequestOperation={encode(A){const e=g.BebopView.getInstance();return e.startWriting(),this.encodeInto(A,e),e.toArray()},encodeInto(A,e){const I=e.length;return e.writeString(A.peerId),e.writeByte(Number(A.accepted)),e.length-I},decode(A){const e=g.BebopView.getInstance();return e.startReading(A),this.readFrom(e)},readFrom(A){let e,I;return e=A.readString(),I=!!A.readByte(),{peerId:e,accepted:I}}},e.StreamRequestOperation={encode(A){const e=g.BebopView.getInstance();return e.startWriting(),this.encodeInto(A,e),e.toArray()},encodeInto(A,e){const I=e.length;return e.writeString(A.peerId),e.writeByte(Number(A.accepted)),e.length-I},decode(A){const e=g.BebopView.getInstance();return e.startReading(A),this.readFrom(e)},readFrom(A){let e,I;return e=A.readString(),I=!!A.readByte(),{peerId:e,accepted:I}}},e.PeerStateChange={encode(A){const e=g.BebopView.getInstance();return e.startWriting(),this.encodeInto(A,e),e.toArray()},encodeInto(A,e){const I=e.length;return e.writeString(A.peerId),e.writeUint32(A.oldState),e.writeUint32(A.newState),e.length-I},decode(A){const e=g.BebopView.getInstance();return e.startReading(A),this.readFrom(e)},readFrom(A){let e,I,g;return e=A.readString(),I=A.readUint32(),g=A.readUint32(),{peerId:e,oldState:I,newState:g}}},e.PeerMessage={encode(A){const e=g.BebopView.getInstance();return e.startWriting(),this.encodeInto(A,e),e.toArray()},encodeInto(A,e){const I=e.length;return e.writeString(A.peerId),e.writeString(A.channelName),e.writeBytes(A.data),e.length-I},decode(A){const e=g.BebopView.getInstance();return e.startReading(A),this.readFrom(e)},readFrom(A){let e,I,g;return e=A.readString(),I=A.readString(),g=A.readBytes(),{peerId:e,channelName:I,data:g}}},e.Guid={encode(A){const e=g.BebopView.getInstance();return e.startWriting(),this.encodeInto(A,e),e.toArray()},encodeInto(A,e){const I=e.length;return e.writeGuid(A.value),e.length-I},decode(A){const e=g.BebopView.getInstance();return e.startReading(A),this.readFrom(e)},readFrom(A){let e;return e=A.readGuid(),{value:e}}},e.RainwayHeader={encode(A){const e=g.BebopView.getInstance();return e.startWriting(),this.encodeInto(A,e),e.toArray()},encodeInto(A,e){const I=e.length;return e.writeUint32(A.magicNumber),e.writeUint32(A.syncKey),e.writeInt64(A.sourcePeerId),e.writeInt64(A.targetPeerId),e.length-I},decode(A){const e=g.BebopView.getInstance();return e.startReading(A),this.readFrom(e)},readFrom(A){let e,I,g,t;return e=A.readUint32(),I=A.readUint32(),g=A.readInt64(),t=A.readInt64(),{magicNumber:e,syncKey:I,sourcePeerId:g,targetPeerId:t}}},e.Chunk={encode(A){const e=g.BebopView.getInstance();return e.startWriting(),this.encodeInto(A,e),e.toArray()},encodeInto(A,e){const I=e.length;return e.writeUint16(A.groupId),e.writeByte(A.index),e.writeByte(A.chunksInGroup),e.writeBytes(A.data),e.length-I},decode(A){const e=g.BebopView.getInstance();return e.startReading(A),this.readFrom(e)},readFrom(A){let e,I,g,t;return e=A.readUint16(),I=A.readByte(),g=A.readByte(),t=A.readBytes(),{groupId:e,index:I,chunksInGroup:g,data:t}}},e.InputDatagram={encode(A){const e=g.BebopView.getInstance();return e.startWriting(),this.encodeInto(A,e),e.toArray()},encodeInto(A,I){const g=I.length;return e.RainwayHeader.encodeInto(A.header,I),e.InputBody.encodeInto(A.body,I),I.length-g},decode(A){const e=g.BebopView.getInstance();return e.startReading(A),this.readFrom(e)},readFrom(A){let I,g;return I=e.RainwayHeader.readFrom(A),g=e.InputBody.readFrom(A),{header:I,body:g}}},e.LogicDatagram={encode(A){const e=g.BebopView.getInstance();return e.startWriting(),this.encodeInto(A,e),e.toArray()},encodeInto(A,I){const g=I.length;return e.RainwayHeader.encodeInto(A.header,I),e.LogicBody.encodeInto(A.body,I),I.length-g},decode(A){const e=g.BebopView.getInstance();return e.startReading(A),this.readFrom(e)},readFrom(A){let I,g;return I=e.RainwayHeader.readFrom(A),g=e.LogicBody.readFrom(A),{header:I,body:g}}},e.MediaDatagram={encode(A){const e=g.BebopView.getInstance();return e.startWriting(),this.encodeInto(A,e),e.toArray()},encodeInto(A,I){const g=I.length;return e.RainwayHeader.encodeInto(A.header,I),e.MediaBody.encodeInto(A.body,I),I.length-g},decode(A){const e=g.BebopView.getInstance();return e.startReading(A),this.readFrom(e)},readFrom(A){let I,g;return I=e.RainwayHeader.readFrom(A),g=e.MediaBody.readFrom(A),{header:I,body:g}}},e.ArbitraryDatagram={encode(A){const e=g.BebopView.getInstance();return e.startWriting(),this.encodeInto(A,e),e.toArray()},encodeInto(A,I){const g=I.length;return e.RainwayHeader.encodeInto(A.header,I),e.Chunk.encodeInto(A.body,I),I.length-g},decode(A){const e=g.BebopView.getInstance();return e.startReading(A),this.readFrom(e)},readFrom(A){let I,g;return I=e.RainwayHeader.readFrom(A),g=e.Chunk.readFrom(A),{header:I,body:g}}},(G=e.XInputButtons||(e.XInputButtons={}))[G.None=0]="None",G[G.DpadUp=1]="DpadUp",G[G.DpadDown=2]="DpadDown",G[G.DpadLeft=4]="DpadLeft",G[G.DpadRight=8]="DpadRight",G[G.Start=16]="Start",G[G.Back=32]="Back",G[G.LeftStick=64]="LeftStick",G[G.RightStick=128]="RightStick",G[G.LeftBumper=256]="LeftBumper",G[G.RightBumper=512]="RightBumper",G[G.Guide=1024]="Guide",G[G.A=4096]="A",G[G.B=8192]="B",G[G.X=16384]="X",G[G.Y=32768]="Y",(p=e.ButtonAction||(e.ButtonAction={}))[p.ButtonDown=0]="ButtonDown",p[p.ButtonUp=1]="ButtonUp",(R=e.MouseButton||(e.MouseButton={}))[R.Left=0]="Left",R[R.Right=1]="Right",R[R.Middle=2]="Middle",R[R.X1=3]="X1",R[R.X2=4]="X2",(F=e.ScrollAxis||(e.ScrollAxis={}))[F.Horizontal=0]="Horizontal",F[F.Vertical=1]="Vertical",(S=e.KeyboardAction||(e.KeyboardAction={}))[S.KeyDown=0]="KeyDown",S[S.KeyUp=1]="KeyUp",(y=e.VirtualKey||(e.VirtualKey={}))[y.None=0]="None",y[y.Cancel=1]="Cancel",y[y.Back=2]="Back",y[y.Tab=3]="Tab",y[y.LineFeed=4]="LineFeed",y[y.Clear=5]="Clear",y[y.Enter=6]="Enter",y[y.Pause=7]="Pause",y[y.CapsLock=8]="CapsLock",y[y.HangulMode=9]="HangulMode",y[y.JunjaMode=10]="JunjaMode",y[y.FinalMode=11]="FinalMode",y[y.HanjaMode=12]="HanjaMode",y[y.Escape=13]="Escape",y[y.ImeConvert=14]="ImeConvert",y[y.ImeNonConvert=15]="ImeNonConvert",y[y.ImeAccept=16]="ImeAccept",y[y.ImeModeChange=17]="ImeModeChange",y[y.Space=18]="Space",y[y.PageUp=19]="PageUp",y[y.PageDown=20]="PageDown",y[y.End=21]="End",y[y.Home=22]="Home",y[y.Left=23]="Left",y[y.Up=24]="Up",y[y.Right=25]="Right",y[y.Down=26]="Down",y[y.Select=27]="Select",y[y.Print=28]="Print",y[y.Execute=29]="Execute",y[y.PrintScreen=30]="PrintScreen",y[y.Insert=31]="Insert",y[y.Delete=32]="Delete",y[y.Help=33]="Help",y[y.D0=34]="D0",y[y.D1=35]="D1",y[y.D2=36]="D2",y[y.D3=37]="D3",y[y.D4=38]="D4",y[y.D5=39]="D5",y[y.D6=40]="D6",y[y.D7=41]="D7",y[y.D8=42]="D8",y[y.D9=43]="D9",y[y.A=44]="A",y[y.B=45]="B",y[y.C=46]="C",y[y.D=47]="D",y[y.E=48]="E",y[y.F=49]="F",y[y.G=50]="G",y[y.H=51]="H",y[y.I=52]="I",y[y.J=53]="J",y[y.K=54]="K",y[y.L=55]="L",y[y.M=56]="M",y[y.N=57]="N",y[y.O=58]="O",y[y.P=59]="P",y[y.Q=60]="Q",y[y.R=61]="R",y[y.S=62]="S",y[y.T=63]="T",y[y.U=64]="U",y[y.V=65]="V",y[y.W=66]="W",y[y.X=67]="X",y[y.Y=68]="Y",y[y.Z=69]="Z",y[y.LWin=70]="LWin",y[y.RWin=71]="RWin",y[y.Apps=72]="Apps",y[y.Sleep=73]="Sleep",y[y.NumPad0=74]="NumPad0",y[y.NumPad1=75]="NumPad1",y[y.NumPad2=76]="NumPad2",y[y.NumPad3=77]="NumPad3",y[y.NumPad4=78]="NumPad4",y[y.NumPad5=79]="NumPad5",y[y.NumPad6=80]="NumPad6",y[y.NumPad7=81]="NumPad7",y[y.NumPad8=82]="NumPad8",y[y.NumPad9=83]="NumPad9",y[y.Multiply=84]="Multiply",y[y.Add=85]="Add",y[y.Separator=86]="Separator",y[y.Subtract=87]="Subtract",y[y.Decimal=88]="Decimal",y[y.Divide=89]="Divide",y[y.F1=90]="F1",y[y.F2=91]="F2",y[y.F3=92]="F3",y[y.F4=93]="F4",y[y.F5=94]="F5",y[y.F6=95]="F6",y[y.F7=96]="F7",y[y.F8=97]="F8",y[y.F9=98]="F9",y[y.F10=99]="F10",y[y.F11=100]="F11",y[y.F12=101]="F12",y[y.F13=102]="F13",y[y.F14=103]="F14",y[y.F15=104]="F15",y[y.F16=105]="F16",y[y.F17=106]="F17",y[y.F18=107]="F18",y[y.F19=108]="F19",y[y.F20=109]="F20",y[y.F21=110]="F21",y[y.F22=111]="F22",y[y.F23=112]="F23",y[y.F24=113]="F24",y[y.NumLock=114]="NumLock",y[y.Scroll=115]="Scroll",y[y.LeftShift=116]="LeftShift",y[y.RightShift=117]="RightShift",y[y.LeftCtrl=118]="LeftCtrl",y[y.RightCtrl=119]="RightCtrl",y[y.LeftAlt=120]="LeftAlt",y[y.RightAlt=121]="RightAlt",y[y.BrowserBack=122]="BrowserBack",y[y.BrowserForward=123]="BrowserForward",y[y.BrowserRefresh=124]="BrowserRefresh",y[y.BrowserStop=125]="BrowserStop",y[y.BrowserSearch=126]="BrowserSearch",y[y.BrowserFavorites=127]="BrowserFavorites",y[y.BrowserHome=128]="BrowserHome",y[y.VolumeMute=129]="VolumeMute",y[y.VolumeDown=130]="VolumeDown",y[y.VolumeUp=131]="VolumeUp",y[y.MediaNextTrack=132]="MediaNextTrack",y[y.MediaPreviousTrack=133]="MediaPreviousTrack",y[y.MediaStop=134]="MediaStop",y[y.MediaPlayPause=135]="MediaPlayPause",y[y.LaunchMail=136]="LaunchMail",y[y.SelectMedia=137]="SelectMedia",y[y.LaunchApplication1=138]="LaunchApplication1",y[y.LaunchApplication2=139]="LaunchApplication2",y[y.Oem1=140]="Oem1",y[y.OemPlus=141]="OemPlus",y[y.OemComma=142]="OemComma",y[y.OemMinus=143]="OemMinus",y[y.OemPeriod=144]="OemPeriod",y[y.Oem2=145]="Oem2",y[y.Oem3=146]="Oem3",y[y.AbntC1=147]="AbntC1",y[y.AbntC2=148]="AbntC2",y[y.Oem4=149]="Oem4",y[y.Oem5=150]="Oem5",y[y.Oem6=151]="Oem6",y[y.Oem7=152]="Oem7",y[y.Oem8=153]="Oem8",y[y.Oem102=154]="Oem102",y[y.ImeProcessed=155]="ImeProcessed",y[y.System=156]="System",y[y.OemAttn=157]="OemAttn",y[y.OemFinish=158]="OemFinish",y[y.OemCopy=159]="OemCopy",y[y.OemAuto=160]="OemAuto",y[y.OemEnlw=161]="OemEnlw",y[y.OemBackTab=162]="OemBackTab",y[y.Attn=163]="Attn",y[y.CrSel=164]="CrSel",y[y.ExSel=165]="ExSel",y[y.EraseEof=166]="EraseEof",y[y.Play=167]="Play",y[y.Zoom=168]="Zoom",y[y.NoName=169]="NoName",y[y.Pa1=170]="Pa1",y[y.OemClear=171]="OemClear",y[y.DeadCharProcessed=172]="DeadCharProcessed",(l=e.WindowsPointerFlags||(e.WindowsPointerFlags={}))[l.New=1]="New",l[l.InRange=2]="InRange",l[l.InContact=4]="InContact",l[l.FirstButton=16]="FirstButton",l[l.SecondButton=32]="SecondButton",l[l.ThirdButton=64]="ThirdButton",l[l.FourthButton=128]="FourthButton",l[l.FifthButton=256]="FifthButton",l[l.Primary=8192]="Primary",l[l.Confidence=16384]="Confidence",l[l.Canceled=32768]="Canceled",l[l.Down=65536]="Down",l[l.Update=131072]="Update",l[l.Up=262144]="Up",l[l.Wheel=524288]="Wheel",l[l.HWheel=1048576]="HWheel",l[l.CaptureChanged=2097152]="CaptureChanged",l[l.HasTransform=4194304]="HasTransform",e.TouchPenPointerInfo={encode(A){const e=g.BebopView.getInstance();return e.startWriting(),this.encodeInto(A,e),e.toArray()},encodeInto(A,e){const I=e.length;return e.writeUint32(A.pointerId),e.writeUint32(A.frameId),e.writeUint32(A.pointerFlags),e.writeInt32(A.x),e.writeInt32(A.y),e.length-I},decode(A){const e=g.BebopView.getInstance();return e.startReading(A),this.readFrom(e)},readFrom(A){let e,I,g,t,i;return e=A.readUint32(),I=A.readUint32(),g=A.readUint32(),t=A.readInt32(),i=A.readInt32(),{pointerId:e,frameId:I,pointerFlags:g,x:t,y:i}}},(w=e.TouchMask||(e.TouchMask={}))[w.ContactArea=1]="ContactArea",w[w.Orientation=2]="Orientation",w[w.Pressure=4]="Pressure",(u=e.PenMask||(e.PenMask={}))[u.Pressure=1]="Pressure",u[u.Rotation=2]="Rotation",u[u.TiltX=4]="TiltX",u[u.TiltY=8]="TiltY",(D=e.PenFlags||(e.PenFlags={}))[D.Barrel=1]="Barrel",D[D.Inverted=2]="Inverted",D[D.Eraser=4]="Eraser",e.TouchAbsolute={encode(A){const e=g.BebopView.getInstance();return e.startWriting(),this.encodeInto(A,e),e.toArray()},encodeInto(A,I){const g=I.length;return e.TouchPenPointerInfo.encodeInto(A.pointerInfo,I),I.writeUint32(A.touchMask),I.writeInt32(A.contactLeft),I.writeInt32(A.contactTop),I.writeInt32(A.contactRight),I.writeInt32(A.contactBottom),I.writeUint32(A.orientation),I.writeUint32(A.pressure),I.length-g},decode(A){const e=g.BebopView.getInstance();return e.startReading(A),this.readFrom(e)},readFrom(A){let I,g,t,i,B,C,Q,o;return I=e.TouchPenPointerInfo.readFrom(A),g=A.readUint32(),t=A.readInt32(),i=A.readInt32(),B=A.readInt32(),C=A.readInt32(),Q=A.readUint32(),o=A.readUint32(),{pointerInfo:I,touchMask:g,contactLeft:t,contactTop:i,contactRight:B,contactBottom:C,orientation:Q,pressure:o}}},e.GamepadReport={discriminator:1,encode(A){const e=g.BebopView.getInstance();return e.startWriting(),this.encodeInto(A,e),e.toArray()},encodeInto(A,e){const I=e.length;return e.writeUint32(A.buttons),e.writeByte(A.leftTrigger),e.writeByte(A.rightTrigger),e.writeInt16(A.leftThumbX),e.writeInt16(A.leftThumbY),e.writeInt16(A.rightThumbX),e.writeInt16(A.rightThumbY),e.writeByte(A.slot),e.length-I},decode(A){const e=g.BebopView.getInstance();return e.startReading(A),this.readFrom(e)},readFrom(A){let e,I,g,t,i,B,C,Q;return e=A.readUint32(),I=A.readByte(),g=A.readByte(),t=A.readInt16(),i=A.readInt16(),B=A.readInt16(),C=A.readInt16(),Q=A.readByte(),{buttons:e,leftTrigger:I,rightTrigger:g,leftThumbX:t,leftThumbY:i,rightThumbX:B,rightThumbY:C,slot:Q}}},e.GamepadRumble={discriminator:2,encode(A){const e=g.BebopView.getInstance();return e.startWriting(),this.encodeInto(A,e),e.toArray()},encodeInto(A,e){const I=e.length;return e.writeByte(A.port),e.writeUint16(A.leftMotorSpeed),e.writeUint16(A.rightMotorSpeed),e.length-I},decode(A){const e=g.BebopView.getInstance();return e.startReading(A),this.readFrom(e)},readFrom(A){let e,I,g;return e=A.readByte(),I=A.readUint16(),g=A.readUint16(),{port:e,leftMotorSpeed:I,rightMotorSpeed:g}}},e.MouseAbsolute={discriminator:3,encode(A){const e=g.BebopView.getInstance();return e.startWriting(),this.encodeInto(A,e),e.toArray()},encodeInto(A,e){const I=e.length;return e.writeInt32(A.x),e.writeInt32(A.y),e.length-I},decode(A){const e=g.BebopView.getInstance();return e.startReading(A),this.readFrom(e)},readFrom(A){let e,I;return e=A.readInt32(),I=A.readInt32(),{x:e,y:I}}},e.MouseRelative={discriminator:4,encode(A){const e=g.BebopView.getInstance();return e.startWriting(),this.encodeInto(A,e),e.toArray()},encodeInto(A,e){const I=e.length;return e.writeInt32(A.dx),e.writeInt32(A.dy),e.length-I},decode(A){const e=g.BebopView.getInstance();return e.startReading(A),this.readFrom(e)},readFrom(A){let e,I;return e=A.readInt32(),I=A.readInt32(),{dx:e,dy:I}}},e.MouseClick={discriminator:5,encode(A){const e=g.BebopView.getInstance();return e.startWriting(),this.encodeInto(A,e),e.toArray()},encodeInto(A,e){const I=e.length;return e.writeUint32(A.action),e.writeUint32(A.button),e.length-I},decode(A){const e=g.BebopView.getInstance();return e.startReading(A),this.readFrom(e)},readFrom(A){let e,I;return e=A.readUint32(),I=A.readUint32(),{action:e,button:I}}},e.MouseScroll={discriminator:6,encode(A){const e=g.BebopView.getInstance();return e.startWriting(),this.encodeInto(A,e),e.toArray()},encodeInto(A,e){const I=e.length;return e.writeUint32(A.axis),e.writeInt32(A.delta),e.length-I},decode(A){const e=g.BebopView.getInstance();return e.startReading(A),this.readFrom(e)},readFrom(A){let e,I;return e=A.readUint32(),I=A.readInt32(),{axis:e,delta:I}}},e.KeyboardInput={discriminator:7,encode(A){const e=g.BebopView.getInstance();return e.startWriting(),this.encodeInto(A,e),e.toArray()},encodeInto(A,e){const I=e.length;return e.writeUint32(A.action),e.writeUint32(A.keycode),e.length-I},decode(A){const e=g.BebopView.getInstance();return e.startReading(A),this.readFrom(e)},readFrom(A){let e,I;return e=A.readUint32(),I=A.readUint32(),{action:e,keycode:I}}},e.LogicalInput={discriminator:8,encode(A){const e=g.BebopView.getInstance();return e.startWriting(),this.encodeInto(A,e),e.toArray()},encodeInto(A,e){const I=e.length;return e.writeString(A.inputString),e.length-I},decode(A){const e=g.BebopView.getInstance();return e.startReading(A),this.readFrom(e)},readFrom(A){let e;return e=A.readString(),{inputString:e}}},e.TouchesAbsolute={discriminator:9,encode(A){const e=g.BebopView.getInstance();return e.startWriting(),this.encodeInto(A,e),e.toArray()},encodeInto(A,I){const g=I.length;{const g=A.touches.length;I.writeUint32(g);for(let t=0;t<g;t++)e.TouchAbsolute.encodeInto(A.touches[t],I)}return I.length-g},decode(A){const e=g.BebopView.getInstance();return e.startReading(A),this.readFrom(e)},readFrom(A){let I;{let g=A.readUint32();I=new Array(g);for(let t=0;t<g;t++){let g;g=e.TouchAbsolute.readFrom(A),I[t]=g}}return{touches:I}}},e.PenAbsolute={discriminator:10,encode(A){const e=g.BebopView.getInstance();return e.startWriting(),this.encodeInto(A,e),e.toArray()},encodeInto(A,I){const g=I.length;return e.TouchPenPointerInfo.encodeInto(A.pointerInfo,I),I.writeUint32(A.penFlags),I.writeUint32(A.penMask),I.writeUint32(A.pressure),I.writeUint32(A.rotation),I.writeInt32(A.tiltX),I.writeInt32(A.tiltY),I.length-g},decode(A){const e=g.BebopView.getInstance();return e.startReading(A),this.readFrom(e)},readFrom(A){let I,g,t,i,B,C,Q;return I=e.TouchPenPointerInfo.readFrom(A),g=A.readUint32(),t=A.readUint32(),i=A.readUint32(),B=A.readUint32(),C=A.readInt32(),Q=A.readInt32(),{pointerInfo:I,penFlags:g,penMask:t,pressure:i,rotation:B,tiltX:C,tiltY:Q}}},e.ViewportResize={discriminator:11,encode(A){const e=g.BebopView.getInstance();return e.startWriting(),this.encodeInto(A,e),e.toArray()},encodeInto(A,e){const I=e.length;return e.writeUint32(A.width),e.writeUint32(A.height),e.length-I},decode(A){const e=g.BebopView.getInstance();return e.startReading(A),this.readFrom(e)},readFrom(A){let e,I;return e=A.readUint32(),I=A.readUint32(),{width:e,height:I}}},e.SetClipboardText={discriminator:12,encode(A){const e=g.BebopView.getInstance();return e.startWriting(),this.encodeInto(A,e),e.toArray()},encodeInto(A,e){const I=e.length;return e.writeString(A.text),e.length-I},decode(A){const e=g.BebopView.getInstance();return e.startReading(A),this.readFrom(e)},readFrom(A){let e;return e=A.readString(),{text:e}}},e.InputBodyInner={encode(A){const e=g.BebopView.getInstance();return e.startWriting(),this.encodeInto(A,e),e.toArray()},encodeInto(A,I){const g=I.length,t=I.reserveMessageLength(),i=I.length+1;switch(I.writeByte(A.discriminator),A.discriminator){case 1:e.GamepadReport.encodeInto(A.value,I);break;case 2:e.GamepadRumble.encodeInto(A.value,I);break;case 3:e.MouseAbsolute.encodeInto(A.value,I);break;case 4:e.MouseRelative.encodeInto(A.value,I);break;case 5:e.MouseClick.encodeInto(A.value,I);break;case 6:e.MouseScroll.encodeInto(A.value,I);break;case 7:e.KeyboardInput.encodeInto(A.value,I);break;case 8:e.LogicalInput.encodeInto(A.value,I);break;case 9:e.TouchesAbsolute.encodeInto(A.value,I);break;case 10:e.PenAbsolute.encodeInto(A.value,I);break;case 11:e.ViewportResize.encodeInto(A.value,I);break;case 12:e.SetClipboardText.encodeInto(A.value,I)}const B=I.length;return I.fillMessageLength(t,B-i),I.length-g},decode(A){const e=g.BebopView.getInstance();return e.startReading(A),this.readFrom(e)},readFrom(A){const I=A.readMessageLength(),t=A.index+1+I;switch(A.readByte()){case 1:return{discriminator:1,value:e.GamepadReport.readFrom(A)};case 2:return{discriminator:2,value:e.GamepadRumble.readFrom(A)};case 3:return{discriminator:3,value:e.MouseAbsolute.readFrom(A)};case 4:return{discriminator:4,value:e.MouseRelative.readFrom(A)};case 5:return{discriminator:5,value:e.MouseClick.readFrom(A)};case 6:return{discriminator:6,value:e.MouseScroll.readFrom(A)};case 7:return{discriminator:7,value:e.KeyboardInput.readFrom(A)};case 8:return{discriminator:8,value:e.LogicalInput.readFrom(A)};case 9:return{discriminator:9,value:e.TouchesAbsolute.readFrom(A)};case 10:return{discriminator:10,value:e.PenAbsolute.readFrom(A)};case 11:return{discriminator:11,value:e.ViewportResize.readFrom(A)};case 12:return{discriminator:12,value:e.SetClipboardText.readFrom(A)};default:throw A.index=t,new g.BebopRuntimeError("Unrecognized discriminator while decoding InputBodyInner")}}},e.InputBody={encode(A){const e=g.BebopView.getInstance();return e.startWriting(),this.encodeInto(A,e),e.toArray()},encodeInto(A,I){const g=I.length;return I.writeByte(A.streamId),e.InputBodyInner.encodeInto(A.inner,I),I.length-g},decode(A){const e=g.BebopView.getInstance();return e.startReading(A),this.readFrom(e)},readFrom(A){let I,g;return I=A.readByte(),g=e.InputBodyInner.readFrom(A),{streamId:I,inner:g}}},(h=e.VideoCodecType||(e.VideoCodecType={}))[h.Baseline=1]="Baseline",h[h.Main=2]="Main",h[h.High=4]="High",h[h.H264=7]="H264",h[h.H265=8]="H265",(c=e.Vendor||(e.Vendor={}))[c.Unknown=0]="Unknown",c[c.Amd=4098]="Amd",c[c.Nvidia=4318]="Nvidia",c[c.Intel=32902]="Intel",e.VideoCodec={encode(A){const e=g.BebopView.getInstance();return e.startWriting(),this.encodeInto(A,e),e.toArray()},encodeInto(A,e){const I=e.length;return e.writeString(A.friendlyName),e.writeUint32(A.width),e.writeUint32(A.height),e.writeUint32(A.refreshRate),e.writeBytes(A.data),e.writeUint32(A.type),e.length-I},decode(A){const e=g.BebopView.getInstance();return e.startReading(A),this.readFrom(e)},readFrom(A){let e,I,g,t,i,B;return e=A.readString(),I=A.readUint32(),g=A.readUint32(),t=A.readUint32(),i=A.readBytes(),B=A.readUint32(),{friendlyName:e,width:I,height:g,refreshRate:t,data:i,type:B}}},(d=e.FormFactor||(e.FormFactor={}))[d.Unknown=0]="Unknown",d[d.Phone=1]="Phone",d[d.Tablet=2]="Tablet",d[d.Computer=3]="Computer",d[d.Console=4]="Console",d[d.Tv=5]="Tv",(s=e.OperatingSystem||(e.OperatingSystem={}))[s.Other=0]="Other",s[s.IOS=1]="IOS",s[s.TvOS=2]="TvOS",s[s.Android=3]="Android",s[s.Windows=4]="Windows",s[s.MacOS=5]="MacOS",s[s.Linux=6]="Linux",s[s.Roku=7]="Roku",(E=e.NetworkProtocol||(e.NetworkProtocol={}))[E.WebRTC=0]="WebRTC",E[E.Geyser=1]="Geyser",(r=e.AudioChannels||(e.AudioChannels={}))[r.Mono=0]="Mono",r[r.Stereo=1]="Stereo",r[r.Surround51=2]="Surround51",r[r.Surround71=3]="Surround71",(a=e.AudioCodec||(e.AudioCodec={}))[a.Opus=0]="Opus",a[a.Aac=1]="Aac",(n=e.AudioContainer||(e.AudioContainer={}))[n.Raw=0]="Raw",n[n.WebM=1]="WebM",n[n.IsoBMFF=2]="IsoBMFF",(o=e.VideoContainer||(e.VideoContainer={}))[o.Raw=0]="Raw",o[o.IsoBMFF=1]="IsoBMFF",(Q=e.LogicError||(e.LogicError={}))[Q.UnknownError=0]="UnknownError",Q[Q.DisplaysMissing=1]="DisplaysMissing",Q[Q.NoAvailableEncoder=2]="NoAvailableEncoder",Q[Q.InvalidEncodingConfig=3]="InvalidEncodingConfig",Q[Q.NoCodecsExchanged=4]="NoCodecsExchanged",Q[Q.NoCapabilities=5]="NoCapabilities",Q[Q.NoSuchStream=6]="NoSuchStream",Q[Q.ForceSegmentFailed=7]="ForceSegmentFailed",e.AudioConfig={encode(A){const e=g.BebopView.getInstance();return e.startWriting(),this.encodeInto(A,e),e.toArray()},encodeInto(A,e){const I=e.length;return e.writeUint32(A.codec),e.writeUint32(A.container),e.length-I},decode(A){const e=g.BebopView.getInstance();return e.startReading(A),this.readFrom(e)},readFrom(A){let e,I;return e=A.readUint32(),I=A.readUint32(),{codec:e,container:I}}},(C=e.StreamType||(e.StreamType={}))[C.Unknown=0]="Unknown",C[C.FullDesktop=1]="FullDesktop",C[C.AppIsolation=2]="AppIsolation",C[C.Byofb=3]="Byofb",e.VideoConfig={encode(A){const e=g.BebopView.getInstance();return e.startWriting(),this.encodeInto(A,e),e.toArray()},encodeInto(A,I){const g=I.length;return e.VideoCodec.encodeInto(A.codec,I),I.writeUint32(A.container),I.length-g},decode(A){const e=g.BebopView.getInstance();return e.startReading(A),this.readFrom(e)},readFrom(A){let I,g;return I=e.VideoCodec.readFrom(A),g=A.readUint32(),{codec:I,container:g}}},(B=e.InputLevel||(e.InputLevel={}))[B.None=0]="None",B[B.GamepadPort1=1]="GamepadPort1",B[B.GamepadPort2=2]="GamepadPort2",B[B.GamepadPort3=4]="GamepadPort3",B[B.GamepadPort4=8]="GamepadPort4",B[B.Gamepad=15]="Gamepad",B[B.Mouse=16]="Mouse",B[B.Keyboard=32]="Keyboard",B[B.Clipboard=64]="Clipboard",B[B.All=63]="All",e.RemoteStreamInfo={encode(A){const e=g.BebopView.getInstance();return e.startWriting(),this.encodeInto(A,e),e.toArray()},encodeInto(A,I){const g=I.length;return I.writeByte(A.streamId),I.writeUint32(A.streamType),I.writeUint32(A.defaultInputLevel),I.writeFloat32(A.temporalScaleFactor),e.AudioConfig.encodeInto(A.chosenAudioConfig,I),e.VideoConfig.encodeInto(A.chosenVideoConfig,I),I.length-g},decode(A){const e=g.BebopView.getInstance();return e.startReading(A),this.readFrom(e)},readFrom(A){let I,g,t,i,B,C;return I=A.readByte(),g=A.readUint32(),t=A.readUint32(),i=A.readFloat32(),B=e.AudioConfig.readFrom(A),C=e.VideoConfig.readFrom(A),{streamId:I,streamType:g,defaultInputLevel:t,temporalScaleFactor:i,chosenAudioConfig:B,chosenVideoConfig:C}}},e.DeviceInfo={discriminator:1,encode(A){const e=g.BebopView.getInstance();return e.startWriting(),this.encodeInto(A,e),e.toArray()},encodeInto(A,e){const I=e.length;return e.writeUint32(A.formFactor),e.writeString(A.deviceName),e.writeUint32(A.deviceOs),e.writeString(A.deviceOsVersion),e.writeString(A.deviceModel),e.writeString(A.userAgent),e.writeString(A.deviceId),e.writeByte(Number(A.isWeb)),e.length-I},decode(A){const e=g.BebopView.getInstance();return e.startReading(A),this.readFrom(e)},readFrom(A){let e,I,g,t,i,B,C,Q;return e=A.readUint32(),I=A.readString(),g=A.readUint32(),t=A.readString(),i=A.readString(),B=A.readString(),C=A.readString(),Q=!!A.readByte(),{formFactor:e,deviceName:I,deviceOs:g,deviceOsVersion:t,deviceModel:i,userAgent:B,deviceId:C,isWeb:Q}}},e.CodecPackRequest={discriminator:2,encode(A){const e=g.BebopView.getInstance();return e.startWriting(),this.encodeInto(A,e),e.toArray()},encodeInto(A,e){const I=e.length;return e.length-I},decode(A){const e=g.BebopView.getInstance();return e.startReading(A),this.readFrom(e)},readFrom:A=>({})},e.CodecPackResponse={discriminator:3,encode(A){const e=g.BebopView.getInstance();return e.startWriting(),this.encodeInto(A,e),e.toArray()},encodeInto(A,I){const g=I.length;{const g=A.videoCodecs.length;I.writeUint32(g);for(let t=0;t<g;t++)e.VideoCodec.encodeInto(A.videoCodecs[t],I)}return I.length-g},decode(A){const e=g.BebopView.getInstance();return e.startReading(A),this.readFrom(e)},readFrom(A){let I;{let g=A.readUint32();I=new Array(g);for(let t=0;t<g;t++){let g;g=e.VideoCodec.readFrom(A),I[t]=g}}return{videoCodecs:I}}},e.ClientCapabilities={discriminator:4,encode(A){const e=g.BebopView.getInstance();return e.startWriting(),this.encodeInto(A,e),e.toArray()},encodeInto(A,I){const g=I.length;I.writeUint32(A.preferredWidth),I.writeUint32(A.preferredHeight),I.writeUint32(A.preferredFps),I.writeUint32(A.preferredAudioBitrate),I.writeUint32(A.preferredVideoBitrate),I.writeUint32(A.preferredAudioChannels),e.AudioConfig.encodeInto(A.preferredAudioConfig,I),e.VideoConfig.encodeInto(A.preferredVideoConfig,I);{const e=A.supportedAudioChannels.length;I.writeUint32(e);for(let g=0;g<e;g++)I.writeUint32(A.supportedAudioChannels[g])}{const g=A.supportedAudioConfigs.length;I.writeUint32(g);for(let t=0;t<g;t++)e.AudioConfig.encodeInto(A.supportedAudioConfigs[t],I)}{const g=A.supportedVideoConfigs.length;I.writeUint32(g);for(let t=0;t<g;t++)e.VideoConfig.encodeInto(A.supportedVideoConfigs[t],I)}return I.writeByte(Number(A.supportsOver1080P)),I.writeByte(Number(A.supportsTemporalScaling)),I.writeByte(Number(A.supportsAppIsolation)),I.length-g},decode(A){const e=g.BebopView.getInstance();return e.startReading(A),this.readFrom(e)},readFrom(A){let I,g,t,i,B,C,Q,o,n,a,r,E,s,d;I=A.readUint32(),g=A.readUint32(),t=A.readUint32(),i=A.readUint32(),B=A.readUint32(),C=A.readUint32(),Q=e.AudioConfig.readFrom(A),o=e.VideoConfig.readFrom(A);{let e=A.readUint32();n=new Array(e);for(let I=0;I<e;I++){let e;e=A.readUint32(),n[I]=e}}{let I=A.readUint32();a=new Array(I);for(let g=0;g<I;g++){let I;I=e.AudioConfig.readFrom(A),a[g]=I}}{let I=A.readUint32();r=new Array(I);for(let g=0;g<I;g++){let I;I=e.VideoConfig.readFrom(A),r[g]=I}}return E=!!A.readByte(),s=!!A.readByte(),d=!!A.readByte(),{preferredWidth:I,preferredHeight:g,preferredFps:t,preferredAudioBitrate:i,preferredVideoBitrate:B,preferredAudioChannels:C,preferredAudioConfig:Q,preferredVideoConfig:o,supportedAudioChannels:n,supportedAudioConfigs:a,supportedVideoConfigs:r,supportsOver1080P:E,supportsTemporalScaling:s,supportsAppIsolation:d}}},e.ErrorResponse={discriminator:5,encode(A){const e=g.BebopView.getInstance();return e.startWriting(),this.encodeInto(A,e),e.toArray()},encodeInto(A,e){const I=e.length;return e.writeUint32(A.error),e.length-I},decode(A){const e=g.BebopView.getInstance();return e.startReading(A),this.readFrom(e)},readFrom(A){let e;return e=A.readUint32(),{error:e}}},e.StreamRequest={discriminator:6,encode(A){const e=g.BebopView.getInstance();return e.startWriting(),this.encodeInto(A,e),e.toArray()},encodeInto(A,e){const I=e.length;return e.writeUint32(A.inputLevel),e.length-I},decode(A){const e=g.BebopView.getInstance();return e.startReading(A),this.readFrom(e)},readFrom(A){let e;return e=A.readUint32(),{inputLevel:e}}},e.LeaveStream={discriminator:8,encode(A){const e=g.BebopView.getInstance();return e.startWriting(),this.encodeInto(A,e),e.toArray()},encodeInto(A,e){const I=e.length;return e.writeByte(A.streamId),e.length-I},decode(A){const e=g.BebopView.getInstance();return e.startReading(A),this.readFrom(e)},readFrom(A){let e;return e=A.readByte(),{streamId:e}}},e.StreamStopping={discriminator:9,encode(A){const e=g.BebopView.getInstance();return e.startWriting(),this.encodeInto(A,e),e.toArray()},encodeInto(A,e){const I=e.length;return e.writeByte(A.streamId),e.length-I},decode(A){const e=g.BebopView.getInstance();return e.startReading(A),this.readFrom(e)},readFrom(A){let e;return e=A.readByte(),{streamId:e}}},e.KeyframeRequest={discriminator:10,encode(A){const e=g.BebopView.getInstance();return e.startWriting(),this.encodeInto(A,e),e.toArray()},encodeInto(A,e){const I=e.length;return e.writeByte(A.streamId),e.length-I},decode(A){const e=g.BebopView.getInstance();return e.startReading(A),this.readFrom(e)},readFrom(A){let e;return e=A.readByte(),{streamId:e}}},e.VideoBitrateRequest={discriminator:11,encode(A){const e=g.BebopView.getInstance();return e.startWriting(),this.encodeInto(A,e),e.toArray()},encodeInto(A,e){const I=e.length;return e.writeByte(A.streamId),e.writeUint32(A.bitsPerSecond),e.length-I},decode(A){const e=g.BebopView.getInstance();return e.startReading(A),this.readFrom(e)},readFrom(A){let e,I;return e=A.readByte(),I=A.readUint32(),{streamId:e,bitsPerSecond:I}}},e.JoinStream={discriminator:12,encode(A){const e=g.BebopView.getInstance();return e.startWriting(),this.encodeInto(A,e),e.toArray()},encodeInto(A,e){const I=e.length;return e.writeByte(A.streamId),e.length-I},decode(A){const e=g.BebopView.getInstance();return e.startReading(A),this.readFrom(e)},readFrom(A){let e;return e=A.readByte(),{streamId:e}}},e.PauseStream={discriminator:13,encode(A){const e=g.BebopView.getInstance();return e.startWriting(),this.encodeInto(A,e),e.toArray()},encodeInto(A,e){const I=e.length;return e.writeByte(A.streamId),e.length-I},decode(A){const e=g.BebopView.getInstance();return e.startReading(A),this.readFrom(e)},readFrom(A){let e;return e=A.readByte(),{streamId:e}}},e.RejectStreamRequest={discriminator:14,encode(A){const e=g.BebopView.getInstance();return e.startWriting(),this.encodeInto(A,e),e.toArray()},encodeInto(A,e){const I=e.length;return e.writeString(A.reason),e.length-I},decode(A){const e=g.BebopView.getInstance();return e.startReading(A),this.readFrom(e)},readFrom(A){let e;return e=A.readString(),{reason:e}}},e.InputLevelUpdate={discriminator:15,encode(A){const e=g.BebopView.getInstance();return e.startWriting(),this.encodeInto(A,e),e.toArray()},encodeInto(A,e){const I=e.length;return e.writeByte(A.streamId),e.writeUint32(A.inputLevel),e.length-I},decode(A){const e=g.BebopView.getInstance();return e.startReading(A),this.readFrom(e)},readFrom(A){let e,I;return e=A.readByte(),I=A.readUint32(),{streamId:e,inputLevel:I}}},e.InputLevelRequest={discriminator:16,encode(A){const e=g.BebopView.getInstance();return e.startWriting(),this.encodeInto(A,e),e.toArray()},encodeInto(A,e){const I=e.length;return e.writeByte(A.streamId),e.writeUint32(A.inputLevel),e.length-I},decode(A){const e=g.BebopView.getInstance();return e.startReading(A),this.readFrom(e)},readFrom(A){let e,I;return e=A.readByte(),I=A.readUint32(),{streamId:e,inputLevel:I}}},e.StreamAnnouncement={discriminator:17,encode(A){const e=g.BebopView.getInstance();return e.startWriting(),this.encodeInto(A,e),e.toArray()},encodeInto(A,I){const g=I.length;return e.RemoteStreamInfo.encodeInto(A.streamInfo,I),I.length-g},decode(A){const e=g.BebopView.getInstance();return e.startReading(A),this.readFrom(e)},readFrom(A){let I;return I=e.RemoteStreamInfo.readFrom(A),{streamInfo:I}}},e.ListStreams={discriminator:18,encode(A){const e=g.BebopView.getInstance();return e.startWriting(),this.encodeInto(A,e),e.toArray()},encodeInto(A,e){const I=e.length;return e.length-I},decode(A){const e=g.BebopView.getInstance();return e.startReading(A),this.readFrom(e)},readFrom:A=>({})},e.LogicBody={encode(A){const e=g.BebopView.getInstance();return e.startWriting(),this.encodeInto(A,e),e.toArray()},encodeInto(A,I){const g=I.length,t=I.reserveMessageLength(),i=I.length+1;switch(I.writeByte(A.discriminator),A.discriminator){case 1:e.DeviceInfo.encodeInto(A.value,I);break;case 2:e.CodecPackRequest.encodeInto(A.value,I);break;case 3:e.CodecPackResponse.encodeInto(A.value,I);break;case 4:e.ClientCapabilities.encodeInto(A.value,I);break;case 5:e.ErrorResponse.encodeInto(A.value,I);break;case 6:e.StreamRequest.encodeInto(A.value,I);break;case 8:e.LeaveStream.encodeInto(A.value,I);break;case 9:e.StreamStopping.encodeInto(A.value,I);break;case 10:e.KeyframeRequest.encodeInto(A.value,I);break;case 11:e.VideoBitrateRequest.encodeInto(A.value,I);break;case 12:e.JoinStream.encodeInto(A.value,I);break;case 13:e.PauseStream.encodeInto(A.value,I);break;case 14:e.RejectStreamRequest.encodeInto(A.value,I);break;case 15:e.InputLevelUpdate.encodeInto(A.value,I);break;case 16:e.InputLevelRequest.encodeInto(A.value,I);break;case 17:e.StreamAnnouncement.encodeInto(A.value,I);break;case 18:e.ListStreams.encodeInto(A.value,I)}const B=I.length;return I.fillMessageLength(t,B-i),I.length-g},decode(A){const e=g.BebopView.getInstance();return e.startReading(A),this.readFrom(e)},readFrom(A){const I=A.readMessageLength(),t=A.index+1+I;switch(A.readByte()){case 1:return{discriminator:1,value:e.DeviceInfo.readFrom(A)};case 2:return{discriminator:2,value:e.CodecPackRequest.readFrom(A)};case 3:return{discriminator:3,value:e.CodecPackResponse.readFrom(A)};case 4:return{discriminator:4,value:e.ClientCapabilities.readFrom(A)};case 5:return{discriminator:5,value:e.ErrorResponse.readFrom(A)};case 6:return{discriminator:6,value:e.StreamRequest.readFrom(A)};case 8:return{discriminator:8,value:e.LeaveStream.readFrom(A)};case 9:return{discriminator:9,value:e.StreamStopping.readFrom(A)};case 10:return{discriminator:10,value:e.KeyframeRequest.readFrom(A)};case 11:return{discriminator:11,value:e.VideoBitrateRequest.readFrom(A)};case 12:return{discriminator:12,value:e.JoinStream.readFrom(A)};case 13:return{discriminator:13,value:e.PauseStream.readFrom(A)};case 14:return{discriminator:14,value:e.RejectStreamRequest.readFrom(A)};case 15:return{discriminator:15,value:e.InputLevelUpdate.readFrom(A)};case 16:return{discriminator:16,value:e.InputLevelRequest.readFrom(A)};case 17:return{discriminator:17,value:e.StreamAnnouncement.readFrom(A)};case 18:return{discriminator:18,value:e.ListStreams.readFrom(A)};default:throw A.index=t,new g.BebopRuntimeError("Unrecognized discriminator while decoding LogicBody")}}},(i=e.VideoDataType||(e.VideoDataType={}))[i.Metadata=0]="Metadata",i[i.CleanPointFrame=1]="CleanPointFrame",i[i.FrameDiff=2]="FrameDiff",(t=e.AudioDataType||(e.AudioDataType={}))[t.Metadata=0]="Metadata",t[t.Frame=1]="Frame",e.DesktopRect={encode(A){const e=g.BebopView.getInstance();return e.startWriting(),this.encodeInto(A,e),e.toArray()},encodeInto(A,e){const I=e.length;return e.writeInt32(A.left),e.writeInt32(A.top),e.writeUint32(A.width),e.writeUint32(A.height),e.length-I},decode(A){const e=g.BebopView.getInstance();return e.startReading(A),this.readFrom(e)},readFrom(A){let e,I,g,t;return e=A.readInt32(),I=A.readInt32(),g=A.readUint32(),t=A.readUint32(),{left:e,top:I,width:g,height:t}}},e.VideoData={discriminator:1,encode(A){const e=g.BebopView.getInstance();return e.startWriting(),this.encodeInto(A,e),e.toArray()},encodeInto(A,I){const g=I.length;I.writeBytes(A.data),I.writeUint64(A.segmentTime),I.writeUint32(A.type),I.writeByte(A.streamId),e.DesktopRect.encodeInto(A.desktopRect,I);{const g=A.mask.length;I.writeUint32(g);for(let t=0;t<g;t++)e.DesktopRect.encodeInto(A.mask[t],I)}return I.length-g},decode(A){const e=g.BebopView.getInstance();return e.startReading(A),this.readFrom(e)},readFrom(A){let I,g,t,i,B,C;I=A.readBytes(),g=A.readUint64(),t=A.readUint32(),i=A.readByte(),B=e.DesktopRect.readFrom(A);{let I=A.readUint32();C=new Array(I);for(let g=0;g<I;g++){let I;I=e.DesktopRect.readFrom(A),C[g]=I}}return{data:I,segmentTime:g,type:t,streamId:i,desktopRect:B,mask:C}}},e.PointerData={discriminator:2,encode(A){const e=g.BebopView.getInstance();return e.startWriting(),this.encodeInto(A,e),e.toArray()},encodeInto(A,e){const I=e.length;return e.writeBytes(A.data),e.writeUint32(A.monitorWidth),e.writeUint32(A.monitorHeight),e.writeUint32(A.shapeWidth),e.writeUint32(A.shapeHeight),e.writeInt32(A.spotX),e.writeInt32(A.spotY),e.writeByte(Number(A.visible)),e.writeInt32(A.positionX),e.writeInt32(A.positionY),e.writeByte(A.streamId),e.length-I},decode(A){const e=g.BebopView.getInstance();return e.startReading(A),this.readFrom(e)},readFrom(A){let e,I,g,t,i,B,C,Q,o,n,a;return e=A.readBytes(),I=A.readUint32(),g=A.readUint32(),t=A.readUint32(),i=A.readUint32(),B=A.readInt32(),C=A.readInt32(),Q=!!A.readByte(),o=A.readInt32(),n=A.readInt32(),a=A.readByte(),{data:e,monitorWidth:I,monitorHeight:g,shapeWidth:t,shapeHeight:i,spotX:B,spotY:C,visible:Q,positionX:o,positionY:n,streamId:a}}},e.AudioData={discriminator:3,encode(A){const e=g.BebopView.getInstance();return e.startWriting(),this.encodeInto(A,e),e.toArray()},encodeInto(A,e){const I=e.length;return e.writeBytes(A.data),e.writeUint32(A.type),e.writeByte(A.streamId),e.length-I},decode(A){const e=g.BebopView.getInstance();return e.startReading(A),this.readFrom(e)},readFrom(A){let e,I,g;return e=A.readBytes(),I=A.readUint32(),g=A.readByte(),{data:e,type:I,streamId:g}}},e.MediaChunk={discriminator:4,encode(A){const e=g.BebopView.getInstance();return e.startWriting(),this.encodeInto(A,e),e.toArray()},encodeInto(A,I){const g=I.length;return e.Chunk.encodeInto(A.chunk,I),I.length-g},decode(A){const e=g.BebopView.getInstance();return e.startReading(A),this.readFrom(e)},readFrom(A){let I;return I=e.Chunk.readFrom(A),{chunk:I}}},e.MediaBody={encode(A){const e=g.BebopView.getInstance();return e.startWriting(),this.encodeInto(A,e),e.toArray()},encodeInto(A,I){const g=I.length,t=I.reserveMessageLength(),i=I.length+1;switch(I.writeByte(A.discriminator),A.discriminator){case 1:e.VideoData.encodeInto(A.value,I);break;case 2:e.PointerData.encodeInto(A.value,I);break;case 3:e.AudioData.encodeInto(A.value,I);break;case 4:e.MediaChunk.encodeInto(A.value,I)}const B=I.length;return I.fillMessageLength(t,B-i),I.length-g},decode(A){const e=g.BebopView.getInstance();return e.startReading(A),this.readFrom(e)},readFrom(A){const I=A.readMessageLength(),t=A.index+1+I;switch(A.readByte()){case 1:return{discriminator:1,value:e.VideoData.readFrom(A)};case 2:return{discriminator:2,value:e.PointerData.readFrom(A)};case 3:return{discriminator:3,value:e.AudioData.readFrom(A)};case 4:return{discriminator:4,value:e.MediaChunk.readFrom(A)};default:throw A.index=t,new g.BebopRuntimeError("Unrecognized discriminator while decoding MediaBody")}}}},5014:function(A,e,I){"use strict";var g=this&&this.__createBinding||(Object.create?function(A,e,I,g){void 0===g&&(g=I),Object.defineProperty(A,g,{enumerable:!0,get:function(){return e[I]}})}:function(A,e,I,g){void 0===g&&(g=I),A[g]=e[I]}),t=this&&this.__exportStar||function(A,e){for(var I in A)"default"===I||Object.prototype.hasOwnProperty.call(e,I)||g(e,A,I)};Object.defineProperty(e,"__esModule",{value:!0}),e.RainwayError=e.HeldKeys=e.InputType=e.RainwayStreamFit=e.RainwayStream=e.RainwayRuntime=e.RainwayTransportStatus=e.RainwayTransport=e.RTCTransport=e.friendlyGamepadName=e.RainwayLogLevel=e.RainwayLogging=e.RainwayChannelMode=e.RainwayPeer=e.RainwayPeerState=void 0;var i=I(7783);Object.defineProperty(e,"RainwayPeerState",{enumerable:!0,get:function(){return i.RainwayPeerState}});var B=I(5420);Object.defineProperty(e,"RainwayPeer",{enumerable:!0,get:function(){return B.RainwayPeer}}),Object.defineProperty(e,"RainwayChannelMode",{enumerable:!0,get:function(){return B.RainwayChannelMode}});var C=I(3464);Object.defineProperty(e,"RainwayLogging",{enumerable:!0,get:function(){return C.RainwayLogging}}),Object.defineProperty(e,"RainwayLogLevel",{enumerable:!0,get:function(){return C.RainwayLogLevel}});var Q=I(9099);Object.defineProperty(e,"friendlyGamepadName",{enumerable:!0,get:function(){return Q.friendlyGamepadName}});var o=I(3145);Object.defineProperty(e,"RTCTransport",{enumerable:!0,get:function(){return o.RTCTransport}});var n=I(9009);Object.defineProperty(e,"RainwayTransport",{enumerable:!0,get:function(){return n.RainwayTransport}}),Object.defineProperty(e,"RainwayTransportStatus",{enumerable:!0,get:function(){return n.RainwayTransportStatus}});var a=I(7783);Object.defineProperty(e,"RainwayRuntime",{enumerable:!0,get:function(){return a.RainwayRuntime}});var r=I(3876);Object.defineProperty(e,"RainwayStream",{enumerable:!0,get:function(){return r.RainwayStream}});var E=I(4425);Object.defineProperty(e,"RainwayStreamFit",{enumerable:!0,get:function(){return E.RainwayStreamFit}});var s=I(884);Object.defineProperty(e,"InputType",{enumerable:!0,get:function(){return s.InputType}}),Object.defineProperty(e,"HeldKeys",{enumerable:!0,get:function(){return s.HeldKeys}});var d=I(2994);Object.defineProperty(e,"RainwayError",{enumerable:!0,get:function(){return d.RainwayError}}),t(I(6904),e)},65:(A,e)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.RainwayCursorPainter=void 0,e.RainwayCursorPainter=class{constructor(A,e,I,g=100){this.correctRemoteCursor=A,this.transformPointerOffsetToRemote=e,this.getCurrentFrameSize=I,this.cursorSyncInterval=g,this.container=void 0,this.video=void 0,this.canvas=void 0,this.cursorDiv=void 0,this.cursorImg=void 0,this.cursorState={visible:!1,x:0,y:0,spotX:0,spotY:0,extentWidth:0,extentHeight:0},this.wantsRemotePosition=!0,this.videoRect=new DOMRect(0,0,0,0),this.windowWidth=void 0,this.windowHeight=void 0,this.drawDebugDot=!1,this.debugDot=void 0,this.setVideoDimensions=()=>{for(const A of[this.video,this.canvas]){if(!A)continue;const e=A.getBoundingClientRect();if(e.width>0&&e.height>0)return this.videoRect=e,void this.applyCursorDivTransform()}},this.cursorSyncCounter=this.cursorSyncInterval,this.videoResizeObserver=new ResizeObserver((()=>{this.setVideoDimensions()})),["webkitfullscreenchange","mozfullscreenchange","fullscreenchange","MSFullscreenChange"].forEach((A=>{document.addEventListener(A,this.setVideoDimensions,!1)})),window.addEventListener("resize",this.setWindowDimensions)}detach(){["webkitfullscreenchange","mozfullscreenchange","fullscreenchange","MSFullscreenChange"].forEach((A=>{document.removeEventListener(A,this.setVideoDimensions,!1)})),window.removeEventListener("resize",this.setWindowDimensions),this.videoResizeObserver.disconnect()}setWindowDimensions(){this.windowWidth=window.innerWidth,this.windowHeight=window.innerHeight}setContainer(A){this.container=A,A.style.overflow="hidden",this.video&&this.videoResizeObserver.unobserve(this.video),this.canvas&&this.videoResizeObserver.unobserve(this.canvas),this.cursorDiv=void 0;const e=A.childNodes;for(let A=0;A<e.length;A++){const I=e[A];I instanceof HTMLVideoElement?(this.video=I,this.setVideoDimensions(),this.videoResizeObserver.observe(this.video)):I instanceof HTMLCanvasElement&&(I.classList.contains("rainway-canvas")||I.classList.contains("rainway-isolation-canvas"))?(this.canvas=I,this.setVideoDimensions(),this.videoResizeObserver.observe(this.canvas)):I instanceof HTMLDivElement&&(I.className.includes("rainway-cursor")?this.cursorDiv=I:I.className.includes("rainway-debug-dot")&&(this.debugDot=I))}this.cursorDiv||(this.cursorDiv=document.createElement("div"),this.cursorDiv.className="rainway-cursor",this.cursorDiv.style.position="absolute",this.cursorDiv.style.top="0px",this.cursorDiv.style.left="0px",this.cursorDiv.style.zIndex="1",this.cursorDiv.style.pointerEvents="none",this.cursorDiv.style.willChange="transform",this.cursorDiv.style.transformOrigin="top left",this.applyCursorDivTransform(),this.cursorImg=document.createElement("img"),this.cursorDiv.appendChild(this.cursorImg),A.appendChild(this.cursorDiv)),this.drawDebugDot&&!this.debugDot&&(this.debugDot=document.createElement("div"),this.debugDot.className="rainway-debug-dot",this.debugDot.style.position="absolute",this.debugDot.style.top="0px",this.debugDot.style.left="0px",this.debugDot.style.zIndex="1",this.debugDot.style.pointerEvents="none",this.debugDot.style.willChange="transform",this.debugDot.style.transformOrigin="top left",this.debugDot.style.width="3px",this.debugDot.style.height="3px",this.debugDot.style.backgroundColor="#ff0000",A.appendChild(this.debugDot))}unsetContainer(){var A,e;this.detach(),null===(A=this.cursorDiv)||void 0===A||A.remove(),null===(e=this.debugDot)||void 0===e||e.remove(),this.container=void 0}computeTransform(A){var e,I;const{x:g,y:t,spotX:i,spotY:B}=A,C={left:0,top:0,width:A.extentWidth,height:A.extentHeight},{width:Q,height:o}=this.videoRect,n=this.getCurrentFrameSize(),a=n.codecWidth,r=n.codecHeight,E=null!==(e=n.streamBounds)&&void 0!==e?e:C,s=null!==(I=n.fullDesktopBounds)&&void 0!==I?I:C,{left:d,top:c,width:h,height:D}=s,{left:u,top:w,width:l,height:y}=E,S=l*a/h,F=y*r/D,R=Math.min(Q/S,o/F),p=Math.round(g-i-(u-d)),G=Math.round(t-B-(w-c)),f=R*a/h,m=R*r/D;return`translate(${Math.round((Q-R*S)/2)}px,${Math.round((o-R*F)/2)}px) scale(${f},${m}) translate(${p}px,${G}px)`}applyCursorDivTransform(){this.cursorDiv&&(this.cursorState.visible?(this.cursorDiv.style.visibility="visible",this.cursorDiv.style.transform=this.computeTransform(this.cursorState)):this.cursorDiv.style.visibility="hidden")}moveDebugDotTo(A){this.debugDot&&(this.debugDot.style.transform=this.computeTransform(A))}processCursor(A){if(this.cursorDiv)if(A.visible&&!this.cursorState.visible&&(this.wantsRemotePosition=!0),this.cursorState.visible=A.visible,this.cursorState.spotX=A.spotX,this.cursorState.spotY=A.spotY,this.cursorState.extentWidth=A.extentWidth,this.cursorState.extentHeight=A.extentHeight,this.drawDebugDot&&this.moveDebugDotTo(A),this.cursorState.visible){if(this.wantsRemotePosition?(this.cursorState.x=A.x,this.cursorState.y=A.y,this.wantsRemotePosition=!1,this.cursorSyncCounter=this.cursorSyncInterval):0==--this.cursorSyncCounter&&(this.correctRemoteCursor(this.cursorState.x,this.cursorState.y),this.cursorSyncCounter=this.cursorSyncInterval),this.cursorDiv.style.width=`${A.shapeWidth}px`,this.cursorDiv.style.height=`${A.shapeHeight}px`,A.hasPointerImage&&this.cursorImg){const e=function(A){let e="";const I=new Uint8Array(A),g=I.byteLength;for(let A=0;A<g;A++)e+=String.fromCharCode(I[A]);return window.btoa(e)}(A.pointerImage);this.cursorImg.src=`data:image/png;base64,${e}`}this.applyCursorDivTransform()}else this.cursorDiv.style.visibility="hidden"}update(A,e,I){var g;if(this.cursorDiv&&("pointermove"===A.type||"mousemove"===A.type)){if("mouse"!==(null!==(g=A.pointerType)&&void 0!==g?g:"mouse")){const A=this.transformPointerOffsetToRemote(e,I);A&&(this.cursorState.x=A.x,this.cursorState.y=A.y)}else{const e=this.cursorState,I=A.movementX,g=A.movementY,t=this.getCurrentFrameSize();if(t.streamBounds){const{top:A,left:i,height:B,width:C}=t.streamBounds;this.cursorState.x=Math.max(i,Math.min(e.x+I,i+C)),this.cursorState.y=Math.max(A,Math.min(e.y+g,A+B))}else console.warn("Don't have streamBounds in CursorPainter.update?"),this.cursorState.x=Math.max(0,Math.min(e.x+I,e.extentWidth)),this.cursorState.y=Math.max(0,Math.min(e.y+g,e.extentHeight))}this.applyCursorDivTransform()}}}},9099:(A,e)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.friendlyGamepadName=void 0;const I={"054c":{"0268":"DualShock 3","05c4":"DualShock 4","09cc":"DualShock 4 (2nd Gen)"},"2dc8":{6101:"N30 Pro"},"0955":{b400:"NVIDIA Shield"},2563:{"0523":"ShanWan PS3 Controller"},"045e":{"02d1":"Xbox One Controller","02dd":"Xbox One Controller (Firmware 2015)","02e3":"Xbox One Elite Controller","02ea":"Xbox One S Controller","02fd":"Xbox One S Controller (Bluetooth)","028f":"Xbox360 Wireless Controller","028e":"Xbox360 Controller","0289":"Xbox Controller S","0285":"Xbox Controller S","0202":"Xbox Controller"},"046d":{c299:"G25 Racing Wheel",c29B:"G27 Racing Wheel",caa3:"DriveFX Racing Wheel",c295:"Momo Force Steering Wheel",c298:"Driving Force Pro"}};e.friendlyGamepadName=function(A,e){var g,t,i,B;const C=A.id.split("(")[0].trim()||"Unknown gamepad",Q=A.id.match(/\b([0-9a-f]{4})\b.*\b([0-9a-f]{4})\b/);if(!Q)return C;const o=Q[1],n=Q[2];return null!==(B=null!==(t=null===(g=null==e?void 0:e[o])||void 0===g?void 0:g[n])&&void 0!==t?t:null===(i=I[o])||void 0===i?void 0:i[n])&&void 0!==B?B:C}},8322:(A,e)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.RainwayGestureRecognizer=void 0;const I={clickDurationMs:60,dragDelayMs:300,rightClickDelayMs:500,touchSlopRadius:8,doubleTapWindowMs:400,doubleTapRadius:12,scrollGestureThresholdPixels:20,scrollEpsilonPixels:5,scrollSensitivity:4};var g,t,i;function B(A){return A==t.left?1:A==t.middle?4:A==t.right?2:0}!function(A){A[A.idle=0]="idle",A[A.oneFingerDeciding=1]="oneFingerDeciding",A[A.twoFingersDeciding=2]="twoFingersDeciding",A[A.moving=3]="moving",A[A.dragging=4]="dragging",A[A.holdingRightMouseButton=5]="holdingRightMouseButton",A[A.zooming=6]="zooming",A[A.scrolling=7]="scrolling"}(g||(g={})),function(A){A[A.left=0]="left",A[A.middle=1]="middle",A[A.right=2]="right"}(t||(t={})),function(A){A[A.pixels=0]="pixels",A[A.lines=1]="lines",A[A.pages=2]="pages"}(i||(i={})),e.RainwayGestureRecognizer=class{constructor(A,e,i=I){this.reportPointerEvent=A,this.reportWheelEvent=e,this.parameters=i,this.state=g.idle,this.primary=void 0,this.secondary=void 0,this.centroidY=0,this.lastTapTime=new Date,this.rightClickTimer=void 0,this.rightClick=()=>{this.reportMouseDown(t.right),this.toState(g.holdingRightMouseButton),this.rightClickTimer=void 0},this.tapReleaseTimer=void 0,this.tapRelease=()=>{this.reportMouseUp(t.left),this.toState(g.idle),this.rightClickTimer=void 0},this.onPointerDown=A=>{const e={pointerId:A.pointerId,homeOffsetX:A.offsetX,homeOffsetY:A.offsetY,currentOffsetX:A.offsetX,currentOffsetY:A.offsetY,downTime:new Date,awake:!1};void 0===this.primary?(this.toState(g.oneFingerDeciding),this.primary=e,window.clearTimeout(this.rightClickTimer),this.rightClickTimer=window.setTimeout(this.rightClick,this.parameters.rightClickDelayMs)):void 0===this.secondary&&(this.toState(g.twoFingersDeciding),this.secondary=e,window.clearTimeout(this.rightClickTimer))},this.onPointerUp=A=>{var e;window.clearTimeout(this.rightClickTimer);const I=A.pointerId===(null===(e=this.primary)||void 0===e?void 0:e.pointerId);if(this.state===g.oneFingerDeciding&&I){this.log("pointer up from deciding, tapping"),window.clearTimeout(this.rightClickTimer);const e=Object.assign(Object.assign({},A),{offsetX:A.offsetX,offsetY:A.offsetY,pointerType:"touch",type:"pointermove"});this.reportPointerEvent(e),this.reportMouseDown(t.left),this.primary=void 0,this.lastTapTime=new Date,this.tapReleaseTimer=window.setTimeout(this.tapRelease,this.parameters.clickDurationMs)}else this.primary&&this.secondary?(this.log("stopping two finger gesture"),this.primary=void 0,this.secondary=void 0,this.toState(g.idle)):this.state===g.moving&&I?(this.log("stop moving"),this.primary=void 0,this.toState(g.idle)):this.state===g.dragging&&I?(this.log("stop dragging"),this.reportMouseUp(t.left),this.primary=void 0,this.toState(g.idle)):this.state===g.holdingRightMouseButton&&I&&(this.log("stop right click"),this.reportMouseUp(t.right),this.primary=void 0,this.toState(g.idle))},this.onPointerMove=A=>{var e,I;const i=A.pointerId===(null===(e=this.primary)||void 0===e?void 0:e.pointerId),B=A.pointerId===(null===(I=this.secondary)||void 0===I?void 0:I.pointerId);if(this.primary&&i?(this.primary.currentOffsetX=A.offsetX,this.primary.currentOffsetY=A.offsetY):this.secondary&&B&&(this.secondary.currentOffsetX=A.offsetX,this.secondary.currentOffsetY=A.offsetY),this.primary&&i&&!this.secondary)this.state===g.oneFingerDeciding&&function(A,e){const I=A.currentOffsetX-A.homeOffsetX,g=A.currentOffsetY-A.homeOffsetY;return I*I+g*g>e*e}(this.primary,this.parameters.touchSlopRadius)?(this.log("left touch slop radius"),window.clearTimeout(this.rightClickTimer),this.primary.awake=!0,(new Date).valueOf()-this.lastTapTime.valueOf()<this.parameters.dragDelayMs?(this.reportMouseDown(t.left),this.toState(g.dragging)):this.toState(g.moving)):this.state!==g.dragging&&this.state!==g.moving&&this.state!==g.holdingRightMouseButton||this.reportPointerEvent(A);else if(this.primary&&this.secondary)if(this.state===g.twoFingersDeciding){const A=this.primary.currentOffsetY-this.primary.homeOffsetY,e=this.secondary.currentOffsetY-this.secondary.homeOffsetY,I=this.parameters.scrollGestureThresholdPixels;(A>I&&e>I||A<I&&e<I)&&(this.toState(g.scrolling),this.centroidY=(A+e)/2)}else if(this.state===g.scrolling){const A=this.parameters.scrollEpsilonPixels,e=(this.primary.currentOffsetY-this.primary.homeOffsetY+(this.secondary.currentOffsetY-this.secondary.homeOffsetY))/2;e>this.centroidY+A?(this.reportScroll(this.parameters.scrollSensitivity*A),this.centroidY=e):e<this.centroidY-A&&(this.reportScroll(this.parameters.scrollSensitivity*-A),this.centroidY=e)}}}log(...A){}reportMouseUp(A){this.log("--\x3e report pointerup",A);const e=new PointerEvent("pointerup",{pointerType:"mouse",buttons:0,button:A});this.reportPointerEvent(e)}reportMouseDown(A){this.log("--\x3e report pointerdown",A);const e=new PointerEvent("pointerdown",{pointerType:"mouse",buttons:B(A),button:A});this.reportPointerEvent(e)}reportScroll(A){const e=new WheelEvent("syntheticWheel",{deltaY:A,deltaMode:i.pixels});this.reportWheelEvent(e)}toState(A){this.log(["idle","oneFingerDeciding","twoFingersDeciding","moving","dragging","holdingRightMouseButton","zooming","scrolling"][A]),this.state=A}processPointerEvent(A){if("touch"===A.pointerType)switch(A.type){case"pointerdown":this.onPointerDown(A);break;case"pointerup":this.onPointerUp(A);break;case"pointerrawupdate":case"pointermove":this.onPointerMove(A)}else this.reportPointerEvent(A)}}},2824:(A,e,I)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.RainwayInputManager=e.mouseClickFrom=void 0;const g=I(2994),t=I(6904),i=I(9040),B=I(8322),C=I(65),Q=I(5528),o=I(6904),n=I(884);function a(A){let e,I;switch(A.button){default:case 0:e=0!=(1&A.buttons),I=o.MouseButton.Left;break;case 1:e=0!=(4&A.buttons),I=o.MouseButton.Middle;break;case 2:e=0!=(2&A.buttons),I=o.MouseButton.Right;break;case 3:e=0!=(8&A.buttons),I=o.MouseButton.X1;break;case 4:e=0!=(16&A.buttons),I=o.MouseButton.X2}return{button:I,action:e?o.ButtonAction.ButtonDown:o.ButtonAction.ButtonUp}}function r(A){return A.axes.length>=4&&A.buttons.length>=16}function E(A,e){if(A===e)return!0;if(A.length!==e.length)return!1;for(let I=0;I<A.length;++I)if(A[I]!==e[I])return!1;return!0}e.mouseClickFrom=a,e.RainwayInputManager=class{constructor(A,e={touchGestures:!1,unlockedMousePointer:!1,embraceMouseAcceleration:!1}){this.rainwayStream=A,this.options=e,this.level=t.InputLevel.None,this.container=void 0,this.heldKeys=new Set,this.alwaysReportGamepadPoll=!0,this.lockPointer=()=>{if(this.options.unlockedMousePointer)return;if(!this.container)return;if(!this.container.requestPointerLock)return;const A=!this.options.embraceMouseAcceleration,e=A?this.container.requestPointerLock({unadjustedMovement:!0}):this.container.requestPointerLock();e instanceof Promise?e.catch((e=>{var I;"NotSupportedError"===e.name&&A&&(null===(I=this.container)||void 0===I||I.requestPointerLock())})):this.container.onpointerlockerror=()=>{var e;A&&(null===(e=this.container)||void 0===e||e.requestPointerLock())},this.container.focus()},this.focusContainer=()=>{var A;return null===(A=this.container)||void 0===A?void 0:A.focus()},this.onPointerEventWithGestureProcessing=A=>{(A.pointerType&&"mouse"!==A.pointerType||document.pointerLockElement===this.container)&&(this.options.touchGestures&&"touch"===A.pointerType?(A.preventDefault(),this.gestureRecognizer.processPointerEvent(A)):this.onPointerEvent(A))},this.onPointerEventFromGestureRecognizer=A=>{this.onPointerEvent(A)},this.onPointerEvent=A=>{this.cursorPainter.update(A,this.rememberedOffsetX,this.rememberedOffsetY),this.reportPointerEvent(A)},this.scrolledAmount=0,this.onWheelEvent=A=>{this.scrolledAmount+=.05*A.deltaY,this.scrolledAmount>=1?(this.sendVerticalScroll(Math.floor(this.scrolledAmount)),this.scrolledAmount%=1):this.scrolledAmount<=-1&&(this.sendVerticalScroll(Math.ceil(this.scrolledAmount)),this.scrolledAmount%=-1)},this.onKeyboardEvent=A=>{A.preventDefault();const e=i.RainwayVirtualKeyFromWebKeyCode[A.code],I="keydown"===A.type;e&&(I?this.heldKeys.add(e):this.heldKeys.delete(e),this.sendInputDatagram({discriminator:o.KeyboardInput.discriminator,value:{action:I?o.KeyboardAction.KeyDown:o.KeyboardAction.KeyUp,keycode:e}}))},this.onGamepadConnectedEvent=A=>{},this.onGamepadDisconnectedEvent=A=>{},this.onDeviceMotion=A=>{},this.onDeviceOrientation=A=>{},this.gamepadCache=new Map,this.pollGamepads=A=>{if(navigator.getGamepads){if(this.container===document.activeElement){const A=[];for(const e of navigator.getGamepads()){if(!e||!r(e))continue;const I=e.buttons.map((A=>A.value)),g=this.gamepadCache.get(e.index);g&&E(g.axes,e.axes)&&E(g.buttonValues,I)||(A.push(this.makeGamepadInputEvent(e)),this.gamepadCache.set(e.index,{axes:[...e.axes],buttonValues:I}))}(this.alwaysReportGamepadPoll||A.length>0)&&this.reportGamepadEvents(A)}this.level&t.InputLevel.Gamepad&&(this.gamepadFrameHandle=window.requestAnimationFrame(this.pollGamepads))}},this.reportGamepadEvents=A=>{for(const e of A){let A=0;e.buttons.dpadUp&&(A|=1),e.buttons.dpadDown&&(A|=2),e.buttons.dpadLeft&&(A|=4),e.buttons.dpadRight&&(A|=8),e.buttons.start&&(A|=16),e.buttons.select&&(A|=32),e.buttons.leftStickPressed&&(A|=64),e.buttons.rightStickPressed&&(A|=128),e.buttons.leftShoulder&&(A|=256),e.buttons.rightShoulder&&(A|=512),e.buttons.a&&(A|=4096),e.buttons.b&&(A|=8192),e.buttons.x&&(A|=16384),e.buttons.y&&(A|=32768);const I={buttons:A,leftTrigger:Math.round(255*e.buttons.leftTrigger),rightTrigger:Math.round(255*e.buttons.rightTrigger),leftThumbX:Math.round(32767*e.sticks.left.x),leftThumbY:Math.round(32767*-e.sticks.left.y),rightThumbX:Math.round(32767*e.sticks.right.x),rightThumbY:Math.round(32767*-e.sticks.right.y),slot:1};this.sendInputDatagram({discriminator:o.GamepadReport.discriminator,value:I})}},this.moveMouseRelativeXY=(A,e)=>{this.sendMouseMove("relative",A,e)},this.moveMouseAbsoluteXY=(A,e)=>{this.sendMouseMove("absolute",A,e)},this.pointerFrameId=0,this.rememberedOffsetX=0,this.rememberedOffsetY=0,this.touches=new Map,this.reportPointerEvent=A=>{if("touch"===A.pointerType||"pen"===A.pointerType){if(document.pointerLockElement===this.container){const e=this.container.clientWidth,I=this.container.clientHeight,g=A.movementX,t=A.movementY;this.rememberedOffsetX=Math.max(0,Math.min(e,this.rememberedOffsetX+g)),this.rememberedOffsetY=Math.max(0,Math.min(I,this.rememberedOffsetY+t))}else this.rememberedOffsetX=A.offsetX,this.rememberedOffsetY=A.offsetY;const e=this.rainwayStream.transformPointerOffsetToRemote(this.rememberedOffsetX,this.rememberedOffsetY);if(!e)return;const{x:I,y:g}=e,i=Math.ceil(A.width/2),B=Math.ceil(A.height/2),{pointerId:C,buttons:Q}=A,o="pointercancel"===A.type||"pointerout"===A.type||"pointerleave"===A.type,n=Q>0,a=("pointerover"===A.type?t.WindowsPointerFlags.New:0)|(n?t.WindowsPointerFlags.InContact:0)|(1==(3&Q)?t.WindowsPointerFlags.FirstButton:0)|(3==(3&Q)?t.WindowsPointerFlags.SecondButton:0)|(A.isPrimary?t.WindowsPointerFlags.Primary:0)|("pointercancel"===A.type?t.WindowsPointerFlags.Canceled:0)|("pointerdown"===A.type?t.WindowsPointerFlags.Down:"pointerup"===A.type?t.WindowsPointerFlags.Up:t.WindowsPointerFlags.Update)|(o?n?t.WindowsPointerFlags.Up:t.WindowsPointerFlags.Update:t.WindowsPointerFlags.InRange),r={pointerId:C,frameId:++this.pointerFrameId,pointerFlags:a,x:I,y:g},E=Math.round(A.twist)%360,s=Math.round(1024*A.pressure);if("touch"===A.pointerType){const A={pointerInfo:r,touchMask:t.TouchMask.ContactArea|t.TouchMask.Orientation|t.TouchMask.Pressure,contactLeft:I-i,contactTop:g-B,contactRight:I+i,contactBottom:g+B,orientation:E,pressure:s};this.touches.set(C,A),this.sendInputDatagram({discriminator:t.TouchesAbsolute.discriminator,value:{touches:[...this.touches.values()]}}),o&&this.touches.delete(C)}else{const e=(2&Q?t.PenFlags.Barrel:0)|(32&Q?t.PenFlags.Eraser:0);this.sendInputDatagram({discriminator:t.PenAbsolute.discriminator,value:{pointerInfo:r,penMask:t.PenMask.Pressure|t.PenMask.Rotation|t.PenMask.TiltX|t.PenMask.TiltY,penFlags:e,rotation:E,pressure:s,tiltX:Math.round(A.tiltX),tiltY:Math.round(A.tiltY)}})}}else if((A.movementX||A.movementY)&&this.sendMouseMove("relative",A.movementX,A.movementY),A.button>-1){const e=a(A);this.sendMouseClick(e)}},this.cursorPainter=new C.RainwayCursorPainter(this.moveMouseAbsoluteXY,((A,e)=>this.rainwayStream.transformPointerOffsetToRemote(A,e)),(()=>this.rainwayStream.currentFrameSize)),this.gestureRecognizer=new B.RainwayGestureRecognizer(this.onPointerEventFromGestureRecognizer,this.onWheelEvent),this.outgoingInputFilter=()=>!0}setContainer(A){if(this.cursorPainter.setContainer(A),this.container){const e=this.level;this.setInputLevel(t.InputLevel.None,!1),this.container=A,this.setInputLevel(e,!1)}else this.container=A}unsetContainer(){this.setInputLevel(t.InputLevel.None,!1),this.cursorPainter.unsetContainer(),this.container=void 0}setInputLevel(A,e=!0,I=!0){this.alwaysReportGamepadPoll=I;const g=A&~this.level,i=this.level&~A;this.level=A,g&t.InputLevel.Gamepad&&this.startGamepad(e),i&t.InputLevel.Gamepad&&this.stopGamepad(),g&t.InputLevel.Mouse&&this.startMouse(),i&t.InputLevel.Mouse&&this.stopMouse(),g&t.InputLevel.Keyboard&&this.startKeyboard(),i&t.InputLevel.Keyboard&&this.stopKeyboard()}getInputLevel(){return this.level}startGamepad(A){window.addEventListener("gamepadconnected",this.onGamepadConnectedEvent),window.addEventListener("gamepaddisconnected",this.onGamepadDisconnectedEvent),this.gamepadFrameHandle=window.requestAnimationFrame(this.pollGamepads),A&&this.reportConnectedGamepads()}reportConnectedGamepads(){for(const A of navigator.getGamepads())A&&this.onGamepadConnectedEvent(new GamepadEvent("gamepadconnected",{gamepad:A}))}stopGamepad(){window.removeEventListener("gamepadconnected",this.onGamepadConnectedEvent),window.removeEventListener("gamepaddisconnected",this.onGamepadDisconnectedEvent),this.gamepadFrameHandle&&window.cancelAnimationFrame(this.gamepadFrameHandle),this.gamepadFrameHandle=void 0}pointerEventListeners(A){if(!window.PointerEvent)throw new Error("browser does not support PointerEvent");A(Q.isDesktopSafari&&navigator.maxTouchPoints<1?"mousemove":window.onpointerrawupdate?"pointerrawupdate":"pointermove",this.onPointerEventWithGestureProcessing),A("pointerdown",this.onPointerEventWithGestureProcessing),A("pointerup",this.onPointerEventWithGestureProcessing),A("pointerover",this.onPointerEventWithGestureProcessing),A("pointerenter",this.onPointerEventWithGestureProcessing),A("pointercancel",this.onPointerEventWithGestureProcessing),A("pointerout",this.onPointerEventWithGestureProcessing),A("pointerleave",this.onPointerEventWithGestureProcessing),A("wheel",this.onWheelEvent),A("mouseup",this.lockPointer)}startMouse(){if(!this.container)throw new g.RainwayError("Rainway tried to add an event listener to its container to handle mouse input, but no container element is set. Try calling setContainer() first.");this.pointerEventListeners(this.container.addEventListener.bind(this.container))}stopMouse(){this.container&&this.pointerEventListeners(this.container.removeEventListener.bind(this.container))}startKeyboard(){if(!this.container)throw new g.RainwayError("Rainway tried to add an event listener to its container to handle keyboard input, but no container element is set. Try calling setContainer() first.");this.container.addEventListener("keydown",this.onKeyboardEvent),this.container.addEventListener("keyup",this.onKeyboardEvent),this.container.addEventListener("click",this.focusContainer),this.container.focus()}stopKeyboard(){this.container&&(this.releaseKeys(),this.container.removeEventListener("keydown",this.onKeyboardEvent),this.container.removeEventListener("keyup",this.onKeyboardEvent),this.container.removeEventListener("click",this.focusContainer))}startDeviceMotionEvents(){window.addEventListener("devicemotion",this.onDeviceMotion)}stopDeviceMotionEvents(){window.removeEventListener("devicemotion",this.onDeviceMotion)}startDeviceOrientationEvents(){window.addEventListener("deviceorientation",this.onDeviceOrientation)}stopDeviceOrientationEvents(){window.removeEventListener("deviceorientation",this.onDeviceOrientation)}sendVerticalScroll(A){this.sendInputDatagram({discriminator:o.MouseScroll.discriminator,value:{axis:o.ScrollAxis.Vertical,delta:A}})}makeGamepadInputEvent(A){var e,I,g,t,i,B,C,Q,o,n,a,r,E,s,d,c,h,D,u,w,l,y,S,F,R,p,G,f,m,k,U,N,M,L,v,H,K,q;return{id:A.id,index:A.index,buttons:{a:null!==(I=null===(e=A.buttons[0])||void 0===e?void 0:e.value)&&void 0!==I?I:0,b:null!==(t=null===(g=A.buttons[1])||void 0===g?void 0:g.value)&&void 0!==t?t:0,x:null!==(B=null===(i=A.buttons[2])||void 0===i?void 0:i.value)&&void 0!==B?B:0,y:null!==(Q=null===(C=A.buttons[3])||void 0===C?void 0:C.value)&&void 0!==Q?Q:0,leftShoulder:null!==(n=null===(o=A.buttons[4])||void 0===o?void 0:o.value)&&void 0!==n?n:0,rightShoulder:null!==(r=null===(a=A.buttons[5])||void 0===a?void 0:a.value)&&void 0!==r?r:0,leftTrigger:null!==(s=null===(E=A.buttons[6])||void 0===E?void 0:E.value)&&void 0!==s?s:0,rightTrigger:null!==(c=null===(d=A.buttons[7])||void 0===d?void 0:d.value)&&void 0!==c?c:0,select:null!==(D=null===(h=A.buttons[8])||void 0===h?void 0:h.value)&&void 0!==D?D:0,start:null!==(w=null===(u=A.buttons[9])||void 0===u?void 0:u.value)&&void 0!==w?w:0,leftStickPressed:null!==(y=null===(l=A.buttons[10])||void 0===l?void 0:l.value)&&void 0!==y?y:0,rightStickPressed:null!==(F=null===(S=A.buttons[11])||void 0===S?void 0:S.value)&&void 0!==F?F:0,dpadUp:null!==(p=null===(R=A.buttons[12])||void 0===R?void 0:R.value)&&void 0!==p?p:0,dpadDown:null!==(f=null===(G=A.buttons[13])||void 0===G?void 0:G.value)&&void 0!==f?f:0,dpadLeft:null!==(k=null===(m=A.buttons[14])||void 0===m?void 0:m.value)&&void 0!==k?k:0,dpadRight:null!==(N=null===(U=A.buttons[15])||void 0===U?void 0:U.value)&&void 0!==N?N:0,home:null!==(L=null===(M=A.buttons[16])||void 0===M?void 0:M.value)&&void 0!==L?L:0},sticks:{left:{x:null!==(v=A.axes[0])&&void 0!==v?v:0,y:null!==(H=A.axes[1])&&void 0!==H?H:0},right:{x:null!==(K=A.axes[2])&&void 0!==K?K:0,y:null!==(q=A.axes[3])&&void 0!==q?q:0}}}}feedGamepadInputEvent(A){this.reportGamepadEvents(A)}static vibrateGamepad(A,e){var I,g;const t=navigator.getGamepads()[A];if(null==t?void 0:t.vibrationActuator)null===(g=(I=t.vibrationActuator).playEffect)||void 0===g||g.call(I,"dual-rumble",e);else if(null==t?void 0:t.hapticActuators){const A=null==t?void 0:t.hapticActuators;setTimeout((()=>{var I,g,t;for(const i of A)if("pulse"in i){const A=Math.max(null!==(I=e.strongMagnitude)&&void 0!==I?I:0,null!==(g=e.weakMagnitude)&&void 0!==g?g:0);i.pulse(A,null!==(t=e.duration)&&void 0!==t?t:0)}}),e.startDelay)}}feedKeyboardEvent(A){this.onKeyboardEvent(A)}releaseKeys(){for(const A of this.heldKeys)this.sendInputDatagram({discriminator:o.KeyboardInput.discriminator,value:{action:o.KeyboardAction.KeyUp,keycode:A}});this.heldKeys.clear()}feedPointerEvent(A){this.onPointerEvent(A)}feedWheelEvent(A){this.onWheelEvent(A)}processCursor(A){this.cursorPainter.processCursor(A)}enableGestures(){this.options.touchGestures=!0}disableGestures(){this.options.touchGestures=!1}sendMouseMove(A,e,I){"absolute"===A?this.sendInputDatagram({discriminator:o.MouseAbsolute.discriminator,value:{x:e,y:I}}):this.sendInputDatagram({discriminator:o.MouseRelative.discriminator,value:{dx:e,dy:I}})}sendMouseClick(A){this.sendInputDatagram({discriminator:o.MouseClick.discriminator,value:A})}sendInputDatagram(A){const e=n.toOutgoingInput(A);e&&this.outgoingInputFilter(e,new n.HeldKeys(this.heldKeys))&&this.rainwayStream.sendInput(A)}dispose(){this.unsetContainer()}}},884:(A,e,I)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.HeldKeys=e.toOutgoingInput=e.InputType=void 0;const g=I(6904);var t;!function(A){A[A.Gamepad=0]="Gamepad",A[A.MouseAbsolute=1]="MouseAbsolute",A[A.MouseRelative=2]="MouseRelative",A[A.MouseClick=3]="MouseClick",A[A.MouseScroll=4]="MouseScroll",A[A.Keyboard=5]="Keyboard",A[A.PasteText=6]="PasteText",A[A.TouchesAbsolute=7]="TouchesAbsolute",A[A.PenAbsolute=8]="PenAbsolute",A[A.ViewportResize=9]="ViewportResize",A[A.SetClipboardText=10]="SetClipboardText"}(t=e.InputType||(e.InputType={})),e.toOutgoingInput=function(A){switch(A.discriminator){case g.GamepadReport.discriminator:return Object.assign({type:t.Gamepad},A.value);case g.GamepadRumble.discriminator:return;case g.MouseAbsolute.discriminator:return Object.assign({type:t.MouseAbsolute},A.value);case g.MouseRelative.discriminator:return Object.assign({type:t.MouseRelative},A.value);case g.MouseClick.discriminator:return Object.assign({type:t.MouseClick},A.value);case g.MouseScroll.discriminator:return Object.assign({type:t.MouseScroll},A.value);case g.KeyboardInput.discriminator:{const e=A.value.keycode;return{type:t.Keyboard,action:A.value.action,key:e}}case g.LogicalInput.discriminator:return Object.assign({type:t.PasteText},A.value);case g.TouchesAbsolute.discriminator:return Object.assign({type:t.TouchesAbsolute},A.value);case g.PenAbsolute.discriminator:return Object.assign({type:t.PenAbsolute},A.value);case g.ViewportResize.discriminator:return Object.assign({type:t.ViewportResize},A.value);case g.SetClipboardText.discriminator:return Object.assign({type:t.SetClipboardText},A.value)}},e.HeldKeys=class{constructor(A){this.heldKeys=A}get keys(){return this.heldKeys}has(A){return this.heldKeys.has(A)}get ctrl(){return this.heldKeys.has(g.VirtualKey.LeftCtrl)||this.heldKeys.has(g.VirtualKey.RightCtrl)}get alt(){return this.heldKeys.has(g.VirtualKey.LeftAlt)||this.heldKeys.has(g.VirtualKey.RightAlt)}get win(){return this.heldKeys.has(g.VirtualKey.LWin)||this.heldKeys.has(g.VirtualKey.RWin)}get shift(){return this.heldKeys.has(g.VirtualKey.LeftShift)||this.heldKeys.has(g.VirtualKey.RightShift)}}},9040:(A,e,I)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.RainwayVirtualKeyFromWebKeyCode=void 0;const g=I(6904);e.RainwayVirtualKeyFromWebKeyCode={Unidentified:g.VirtualKey.None,Cancel:g.VirtualKey.Cancel,Backspace:g.VirtualKey.Back,Tab:g.VirtualKey.Tab,Enter:g.VirtualKey.Enter,Pause:g.VirtualKey.Pause,CapsLock:g.VirtualKey.CapsLock,HangulMode:g.VirtualKey.HangulMode,KanaMode:g.VirtualKey.HangulMode,Lang1:g.VirtualKey.HangulMode,Hanja:g.VirtualKey.HanjaMode,Lang2:g.VirtualKey.HanjaMode,Escape:g.VirtualKey.Escape,Convert:g.VirtualKey.ImeConvert,NonConvert:g.VirtualKey.ImeNonConvert,Space:g.VirtualKey.Space," ":g.VirtualKey.Space,Spacebar:g.VirtualKey.Space,PageUp:g.VirtualKey.PageUp,PageDown:g.VirtualKey.PageDown,End:g.VirtualKey.End,Home:g.VirtualKey.Home,ArrowLeft:g.VirtualKey.Left,ArrowUp:g.VirtualKey.Up,ArrowRight:g.VirtualKey.Right,ArrowDown:g.VirtualKey.Down,Select:g.VirtualKey.Select,PrintScreen:g.VirtualKey.PrintScreen,Insert:g.VirtualKey.Insert,Delete:g.VirtualKey.Delete,Help:g.VirtualKey.Help,Digit0:g.VirtualKey.D0,Digit1:g.VirtualKey.D1,Digit2:g.VirtualKey.D2,Digit3:g.VirtualKey.D3,Digit4:g.VirtualKey.D4,Digit5:g.VirtualKey.D5,Digit6:g.VirtualKey.D6,Digit7:g.VirtualKey.D7,Digit8:g.VirtualKey.D8,Digit9:g.VirtualKey.D9,KeyA:g.VirtualKey.A,KeyB:g.VirtualKey.B,KeyC:g.VirtualKey.C,KeyD:g.VirtualKey.D,KeyE:g.VirtualKey.E,KeyF:g.VirtualKey.F,KeyG:g.VirtualKey.G,KeyH:g.VirtualKey.H,KeyI:g.VirtualKey.I,KeyJ:g.VirtualKey.J,KeyK:g.VirtualKey.K,KeyL:g.VirtualKey.L,KeyM:g.VirtualKey.M,KeyN:g.VirtualKey.N,KeyO:g.VirtualKey.O,KeyP:g.VirtualKey.P,KeyQ:g.VirtualKey.Q,KeyR:g.VirtualKey.R,KeyS:g.VirtualKey.S,KeyT:g.VirtualKey.T,KeyU:g.VirtualKey.U,KeyV:g.VirtualKey.V,KeyW:g.VirtualKey.W,KeyX:g.VirtualKey.X,KeyY:g.VirtualKey.Y,KeyZ:g.VirtualKey.Z,MetaLeft:g.VirtualKey.LWin,OSLeft:g.VirtualKey.LWin,MetaRight:g.VirtualKey.RWin,OSRight:g.VirtualKey.RWin,ContextMenu:g.VirtualKey.Apps,Sleep:g.VirtualKey.Sleep,Numpad0:g.VirtualKey.NumPad0,Numpad1:g.VirtualKey.NumPad1,Numpad2:g.VirtualKey.NumPad2,Numpad3:g.VirtualKey.NumPad3,Numpad4:g.VirtualKey.NumPad4,Numpad5:g.VirtualKey.NumPad5,Numpad6:g.VirtualKey.NumPad6,Numpad7:g.VirtualKey.NumPad7,Numpad8:g.VirtualKey.NumPad8,Numpad9:g.VirtualKey.NumPad9,NumpadMultiply:g.VirtualKey.Multiply,NumpadAdd:g.VirtualKey.Add,NumpadComma:g.VirtualKey.Separator,NumpadSubtract:g.VirtualKey.Subtract,NumpadDecimal:g.VirtualKey.Decimal,NumpadDivide:g.VirtualKey.Divide,F1:g.VirtualKey.F1,F2:g.VirtualKey.F2,F3:g.VirtualKey.F3,F4:g.VirtualKey.F4,F5:g.VirtualKey.F5,F6:g.VirtualKey.F6,F7:g.VirtualKey.F7,F8:g.VirtualKey.F8,F9:g.VirtualKey.F9,F10:g.VirtualKey.F10,F11:g.VirtualKey.F11,F12:g.VirtualKey.F12,F13:g.VirtualKey.F13,F14:g.VirtualKey.F14,F15:g.VirtualKey.F15,F16:g.VirtualKey.F16,F17:g.VirtualKey.F17,F18:g.VirtualKey.F18,F19:g.VirtualKey.F19,F20:g.VirtualKey.F20,F21:g.VirtualKey.F21,F22:g.VirtualKey.F22,F23:g.VirtualKey.F23,F24:g.VirtualKey.F24,NumLock:g.VirtualKey.NumLock,ScrollLock:g.VirtualKey.Scroll,ShiftLeft:g.VirtualKey.LeftShift,ShiftRight:g.VirtualKey.RightShift,ControlLeft:g.VirtualKey.LeftCtrl,ControlRight:g.VirtualKey.RightCtrl,AltLeft:g.VirtualKey.LeftAlt,AltRight:g.VirtualKey.RightAlt,BrowserBack:g.VirtualKey.BrowserBack,BrowserForward:g.VirtualKey.BrowserForward,BrowserRefresh:g.VirtualKey.BrowserRefresh,BrowserStop:g.VirtualKey.BrowserStop,BrowserSearch:g.VirtualKey.BrowserSearch,BrowserFavorites:g.VirtualKey.BrowserFavorites,BrowserHome:g.VirtualKey.BrowserHome,AudioVolumeMute:g.VirtualKey.VolumeMute,AudioVolumeDown:g.VirtualKey.VolumeDown,AudioVolumeUp:g.VirtualKey.VolumeUp,MediaTrackNext:g.VirtualKey.MediaNextTrack,MediaTrackPrevious:g.VirtualKey.MediaPreviousTrack,MediaStop:g.VirtualKey.MediaStop,MediaPlayPause:g.VirtualKey.MediaPlayPause,LaunchMail:g.VirtualKey.LaunchMail,LaunchMediaPlayer:g.VirtualKey.SelectMedia,MediaSelect:g.VirtualKey.SelectMedia,LaunchApp1:g.VirtualKey.LaunchApplication1,LaunchApp2:g.VirtualKey.LaunchApplication2,Semicolon:g.VirtualKey.Oem1,Equal:g.VirtualKey.OemPlus,Comma:g.VirtualKey.OemComma,Minus:g.VirtualKey.OemMinus,Period:g.VirtualKey.OemPeriod,Slash:g.VirtualKey.Oem2,Backquote:g.VirtualKey.Oem3,BracketLeft:g.VirtualKey.Oem4,Backslash:g.VirtualKey.Oem5,BracketRight:g.VirtualKey.Oem6,Quote:g.VirtualKey.Oem7,IntlBackslash:g.VirtualKey.Oem102}},3464:(A,e)=>{"use strict";var I;Object.defineProperty(e,"__esModule",{value:!0}),e.RainwayLogging=e.RainwayLogLevel=void 0,function(A){A[A.Trace=0]="Trace",A[A.Debug=1]="Debug",A[A.Information=2]="Information",A[A.Warning=3]="Warning",A[A.Error=4]="Error",A[A.Critical=5]="Critical",A[A.Silent=6]="Silent"}(I=e.RainwayLogLevel||(e.RainwayLogLevel={}));class g{static setLogSink(A){g._logSink=A}static log(A,e){var I;null===(I=g._logSink)||void 0===I||I.call(g,A,e)}}e.RainwayLogging=g,g.trace=A=>g.log(I.Trace,A),g.debug=A=>g.log(I.Debug,A),g.information=A=>g.log(I.Information,A),g.warning=A=>g.log(I.Warning,A),g.error=A=>g.log(I.Error,A),g.critical=A=>g.log(I.Critical,A)},6585:function(A,e,I){"use strict";var g=this&&this.__awaiter||function(A,e,I,g){return new(I||(I=Promise))((function(t,i){function B(A){try{Q(g.next(A))}catch(A){i(A)}}function C(A){try{Q(g.throw(A))}catch(A){i(A)}}function Q(A){var e;A.done?t(A.value):(e=A.value,e instanceof I?e:new I((function(A){A(e)}))).then(B,C)}Q((g=g.apply(A,e||[])).next())}))},t=this&&this.__importDefault||function(A){return A&&A.__esModule?A:{default:A}};Object.defineProperty(e,"__esModule",{value:!0}),e.AudioStream=void 0;const i=t(I(6053)),B=I(2994),C=I(3464);e.AudioStream=class{constructor(){this.sampleRateHz=48e3,this.sampleRateKhz=48,this.channelCount=2,this.decodedCount=0,this.totalSamplesDecoded=0,this.waitingToDecodeQueue=[],this.decodeQueueSize=0,this.logPerformance=!1,this.maxDecodingTimeMs=0,this.totalDecodingTimeMs=0,this.totalQueuedSize=0,this.maxQueuedSize=0,this.startStreamTimeMs=0,this.outputBuffers=[],this.currentOutputBuffer=void 0,this.currentBufferReadIndex=0,this.nextStartTime=void 0,this.playing=!1,this.dataDurationMs=10,this.minLatencyMs=60,this.maxLatencyMs=100,this.prevDroppedFrameTimeMs=void 0,this.decodedSamplesPerFrame=0,this.audioBufferSize=0,this.audioBufferPool=[],this.maxAudioBufferPoolCount=5,this.resampledAudioBufferSize=0,this.onDecode=({startTimestamp:A,outputData:e,samplesDecoded:I})=>{--this.decodeQueueSize;const g=new Float32Array(e);this.outputBuffers.push(g);try{if(I>0&&(++this.decodedCount,this.totalSamplesDecoded+=I,this.logPerformance&&this.logPerfTiming(A),this.totalSamplesDecoded>=this.audioBufferSize&&(this.nextStartTime&&this.nextStartTime<this.audioContext.currentTime&&(this.nextStartTime=void 0),this.nextStartTime||this.totalSamplesDecoded>=2*this.audioBufferSize))){const A=Math.floor(this.totalSamplesDecoded/this.audioBufferSize);for(let e=0;e<A;++e){const A=this.nextStartTime?1e3*(this.nextStartTime-this.audioContext.currentTime):0;if(A>this.maxLatencyMs){let e=0;const I=Date.now(),g=this.prevDroppedFrameTimeMs?I-this.prevDroppedFrameTimeMs:void 0,t=1e4;if(g&&g<t)e=this.dropDecodedSamples(this.totalSamplesDecoded);else{const I=A-this.maxLatencyMs+this.dataDurationMs,g=Math.floor(this.sampleRateKhz*I);e=this.dropDecodedSamples(g)}this.prevDroppedFrameTimeMs=I,this.totalSamplesDecoded-=e}if(!(this.totalSamplesDecoded>=this.audioBufferSize))break;{const A=this.copyDecodedSamplesToAudioBuffer();this.scheduleBufferForPlaybackFunc(A),this.totalSamplesDecoded-=A.length}}}}catch(A){C.RainwayLogging.warning("Caught exception in AudioStream onDecode: "+A+" "+A.stack),this.stop(),this.play()}this.sendDecoderWaitingToDecodeFrames()}}initialize(){return g(this,void 0,void 0,(function*(){this.opusDecoderWorker=new i.default,yield this.opusDecoderWorker.initialize(),this.opusDecoderWorker.onDecode=this.onDecode.bind(this)}))}dispose(){var A;null===(A=this.opusDecoderWorker)||void 0===A||A.dispose(),this.opusDecoderWorker=void 0}configure({audioContext:A,sampleRateHz:e,channelCount:I,dataDurationMs:g,minLatencyMs:t,maxLatencyMs:i}){if(this.sampleRateHz=null!=e?e:this.sampleRateHz,8e3!=this.sampleRateHz&&12e3!=this.sampleRateHz&&16e3!=this.sampleRateHz&&24e3!=this.sampleRateHz&&48e3!=this.sampleRateHz)throw new B.RainwayError(`invalid audio sample rate: ${this.sampleRateHz} (must be 8000, 12000, 16000, 24000, or 48000)`);if(this.sampleRateKhz=this.sampleRateHz/1e3,this.channelCount=null!=I?I:this.channelCount,1!=this.channelCount&&2!=this.channelCount&&6!=this.channelCount)throw new B.RainwayError(`invalid channel count: ${this.channelCount} (must be 1, 2, or 6)`);if(this.dataDurationMs=null!=g?g:this.dataDurationMs,this.minLatencyMs=null!=t?t:this.minLatencyMs,this.maxLatencyMs=null!=i?i:this.maxLatencyMs,this.dataDurationMs<=0)throw new B.RainwayError(`dataDurationMs must be positive, but is ${this.dataDurationMs}`);if(this.dataDurationMs>this.minLatencyMs)throw new B.RainwayError("dataDurationMs may not exceed minLatencyMs");if(this.maxLatencyMs<=this.minLatencyMs)throw new B.RainwayError("maxLatencyMs must be greater than minLatencyMs");this.decodedSamplesPerFrame=this.dataDurationMs*this.sampleRateKhz,this.currentOutputBuffer=void 0,this.currentBufferReadIndex=0;const Q=this.sampleRateKhz*this.minLatencyMs;this.audioBufferSize=Math.floor(Q/2),null==A?(this.audioContext=new(window.AudioContext||window.webkitAudioContext)({latencyHint:"interactive",sampleRate:this.sampleRateHz}),this.audioContext.createBufferSource()):this.audioContext=A,this.volumeNode=this.audioContext.createGain(),this.volumeNode.connect(this.audioContext.destination),this.audioContext.resume(),"suspended"==this.audioContext.state&&C.RainwayLogging.information("AudioContext is suspended. Note, on Safari, must be created directly from user interaction (i.e. no 'await'))."),this.audioContext.sampleRate!=this.sampleRateHz?(C.RainwayLogging.warning("Configured sample rate: "+this.sampleRateHz+" does not match AudioContext: "+this.audioContext.sampleRate+". Resampling is required!"),this.resampledAudioBufferSize=Math.floor(this.audioContext.sampleRate/1e3*this.minLatencyMs/2),this.scheduleBufferForPlaybackFunc=this.resampleBufferThenScheduleForPlayback.bind(this)):this.scheduleBufferForPlaybackFunc=this.scheduleBufferForPlayback.bind(this),this.audioBufferPool=[];let o=!1;this.playing&&(o=!0,this.stop()),o&&this.play()}play(){if(!this.opusDecoderWorker)throw new B.RainwayError("play() has no opusDecoderWorker");if(!this.sampleRateHz)throw new B.RainwayError("play() has no sampleRateHz");if(!this.channelCount)throw new B.RainwayError("play() has no channelCount");if(!this.audioContext)throw new B.RainwayError("play() has no audioContext");this.playing||(this.maxDecodingTimeMs=0,this.totalDecodingTimeMs=0,this.totalQueuedSize=0,this.maxQueuedSize=0,this.startStreamTimeMs=Date.now(),this.opusDecoderWorker.startStream(this.sampleRateHz,this.channelCount,this.decodedSamplesPerFrame),this.playing=!0)}stop(){if(!this.opusDecoderWorker)throw new B.RainwayError("stop() has no opusDecoderWorker");this.waitingToDecodeQueue=[],this.outputBuffers=[],this.nextStartTime=void 0,this.totalSamplesDecoded=0,this.currentOutputBuffer=void 0,this.currentBufferReadIndex=0,this.prevDroppedFrameTimeMs=void 0,this.opusDecoderWorker.stopStream(),this.playing=!1}pushData(A){this.playing&&this.audioContext&&this.opusDecoderWorker&&(0==this.decodeQueueSize?(0!=this.waitingToDecodeQueue.length&&(C.RainwayLogging.error("[AudioStream] empty decoder queue, but waiting to decode queue not empty!"),this.waitingToDecodeQueue=[]),this.sendToDecoder({startTimestamp:Date.now(),inputData:A})):(this.waitingToDecodeQueue.push({startTimestamp:Date.now(),inputData:A}),this.decodeQueueSize<3&&this.sendDecoderWaitingToDecodeFrames()))}sendDecoderWaitingToDecodeFrames(){const A=(this.decodeQueueSize+this.waitingToDecodeQueue.length)*this.dataDurationMs;if(A>this.maxLatencyMs){const e=A-this.maxLatencyMs,I=Math.floor(e/this.dataDurationMs),g=Math.max(Math.max(this.waitingToDecodeQueue.length-I,3-this.decodeQueueSize),1),t=this.waitingToDecodeQueue.length-g;this.waitingToDecodeQueue=this.waitingToDecodeQueue.slice(t)}for(;this.decodeQueueSize<3&&this.waitingToDecodeQueue.length>0;){const A=this.waitingToDecodeQueue.shift();this.sendToDecoder(A)}}sendToDecoder(A){++this.decodeQueueSize,this.opusDecoderWorker.decode(A.startTimestamp,A.inputData)}dropDecodedSamples(A){let e=0;for(this.currentOutputBuffer&&(e+=this.dropCurrentOutputBufferSamples(A),A-=e);A>0&&this.outputBuffers.length>0;)if(A<this.decodedSamplesPerFrame){this.currentOutputBuffer=this.outputBuffers.shift(),this.currentBufferReadIndex=0;const I=this.dropCurrentOutputBufferSamples(A);e+=I,A-=I}else this.outputBuffers.shift(),e+=this.decodedSamplesPerFrame,A-=this.decodedSamplesPerFrame;return e}dropCurrentOutputBufferSamples(A){const e=Math.floor((this.currentOutputBuffer.length-this.currentBufferReadIndex)/this.channelCount),I=Math.min(e,A);return this.currentBufferReadIndex+=I*this.channelCount,this.currentBufferReadIndex>=this.currentOutputBuffer.length&&(this.currentOutputBuffer=void 0),I}copyDecodedSamplesToAudioBuffer(){const A=this.getOrCreateAudioBuffer();for(let e=0;e<this.audioBufferSize;){this.currentOutputBuffer||(this.currentOutputBuffer=this.outputBuffers.shift(),this.currentBufferReadIndex=0);const I=this.currentOutputBuffer;if(1==this.channelCount){const g=A.getChannelData(0);for(;this.currentBufferReadIndex<I.length&&(g[e]=I[this.currentBufferReadIndex],this.currentBufferReadIndex+=this.channelCount,++e,!(e>=this.audioBufferSize)););}else if(2==this.channelCount){const g=A.getChannelData(0),t=A.getChannelData(1);for(;this.currentBufferReadIndex<I.length&&(g[e]=I[this.currentBufferReadIndex],t[e]=I[this.currentBufferReadIndex+1],this.currentBufferReadIndex+=this.channelCount,++e,!(e>=this.audioBufferSize)););}else{const g=A.getChannelData(0),t=A.getChannelData(1),i=A.getChannelData(2),B=A.getChannelData(3),C=A.getChannelData(4),Q=A.getChannelData(5);for(;this.currentBufferReadIndex<I.length&&(g[e]=I[this.currentBufferReadIndex],t[e]=I[this.currentBufferReadIndex+1],C[e]=I[this.currentBufferReadIndex+2],Q[e]=I[this.currentBufferReadIndex+3],i[e]=I[this.currentBufferReadIndex+4],B[e]=I[this.currentBufferReadIndex+5],this.currentBufferReadIndex+=this.channelCount,++e,!(e>=this.audioBufferSize)););}this.currentBufferReadIndex>=this.currentOutputBuffer.length&&(this.currentOutputBuffer=void 0)}return A}getOrCreateAudioBuffer(){return 0==this.audioBufferPool.length?this.audioContext.createBuffer(this.channelCount,this.audioBufferSize,this.sampleRateHz):this.audioBufferPool.pop()}returnAudioBufferToPool(A,e){this.audioBufferPool.length<this.maxAudioBufferPoolCount&&this.audioBufferPool.push(A)}logPerfTiming(A){const e=Date.now(),I=e-A;this.totalDecodingTimeMs+=I,I>this.maxDecodingTimeMs&&(this.maxDecodingTimeMs=I);const g=this.waitingToDecodeQueue.length+this.decodeQueueSize;this.totalQueuedSize+=g,g>this.maxQueuedSize&&(this.maxQueuedSize=g),1500==this.decodedCount&&(C.RainwayLogging.information("[AudioStream] Avg queue: "+this.totalQueuedSize/this.decodedCount+", Max: "+this.maxQueuedSize+" Avg FPS: "+this.decodedCount/((e-this.startStreamTimeMs)/1e3)+" Avg decode: "+this.totalDecodingTimeMs/this.decodedCount+"ms, Max: "+this.maxDecodingTimeMs+"ms"),this.totalDecodingTimeMs=0,this.maxDecodingTimeMs=0,this.totalQueuedSize=0,this.maxQueuedSize=0,this.decodedCount=0,this.startStreamTimeMs=e)}resampleBufferThenScheduleForPlayback(A){const e=new(window.OfflineAudioContext||window.webkitOfflineAudioContext)(this.channelCount,this.resampledAudioBufferSize,this.audioContext.sampleRate),I=e.createBufferSource();I.buffer=A,I.connect(e.destination),I.start(),e.startRendering(),e.oncomplete=this.scheduleResampledBufferPlayback.bind(this,A)}scheduleResampledBufferPlayback(A,e){this.schedulePlaybackWithOnEnded(e.renderedBuffer),this.returnAudioBufferToPool(A,e)}scheduleBufferForPlayback(A){this.schedulePlaybackWithOnEnded(A,this.returnAudioBufferToPool.bind(this,A))}schedulePlaybackWithOnEnded(A,e=null){const I=this.audioContext.createBufferSource();I.buffer=A,this.nextStartTime||(this.nextStartTime=this.audioContext.currentTime),I.playbackRate.value=1,I.connect(this.volumeNode),I.start(this.nextStartTime),I.onended=e,this.nextStartTime+=A.duration}setVolume(A){this.volumeNode.gain.value=A}}},8514:(A,e,I)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.makeClientCapabilities=void 0;const g=I(6904),t=I(3643),i=I(4009);e.makeClientCapabilities=function(A){const{filtered:e,preferred:I}=i.filterCodecPack(A),B={codec:g.AudioCodec.Opus,container:g.AudioContainer.Raw},C="MediaSource"in window?g.VideoContainer.IsoBMFF:g.VideoContainer.Raw,Q=!!window.chrome;return{preferredWidth:screen.availWidth,preferredHeight:screen.availHeight,preferredFps:60,preferredAudioBitrate:96e3,preferredVideoBitrate:1e3*t.defaultRateControlParameters.initialBitrateKbps,preferredAudioChannels:g.AudioChannels.Stereo,preferredAudioConfig:B,preferredVideoConfig:{codec:I,container:C},supportedAudioChannels:[g.AudioChannels.Mono,g.AudioChannels.Stereo],supportedAudioConfigs:[B],supportedVideoConfigs:e.map((A=>({codec:A,container:C}))),supportsOver1080P:!1,supportsTemporalScaling:!0,supportsAppIsolation:Q}}},4009:(A,e,I)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.filterCodecPack=e.videoCodecMimeType=void 0;const g=I(6904);function t(A){const e=A.data;return`video/mp4; codecs="avc1.${(e[5]<<16|e[6]<<8|e[7]).toString(16).padStart(6,"0")}"`}function i(A){if(!("MediaSource"in window))return!1;const e=A.data;if(e.length<8||7!=(31&e[4]))return!1;const I=t(A);return MediaSource.isTypeSupported(I)}function B(A){const e=A.data;if(e.length<8||7!=(31&e[4]))return g.VideoCodecType.Baseline;const I=e[5];return e[6],116==I||122==I||110==I||100==I?g.VideoCodecType.High:88==I||77==I?g.VideoCodecType.Main:g.VideoCodecType.Baseline}e.videoCodecMimeType=t,e.filterCodecPack=function(A){if(0===A.length)throw new Error("Host supplied an empty CodecPack");let e=A.filter(i);if(0===e.length&&(console.warn("Found no browser-confirmed working codec, falling back to baseline"),e=A.filter((A=>B(A)<=g.VideoCodecType.Baseline))),0===e.length)throw new Error("Host supplied an unsupported CodecPack");const I=e.reduce(((A,e)=>B(A)>B(e)?A:e));return{filtered:e,preferred:I}}},4919:(A,e,I)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0});const g=I(3464);class t{constructor(A,e,I){this.glCtx=void 0,this.program=void 0,this.glCtx=A,this.program=this.glCtx.createProgram(),this.glCtx.attachShader(this.program,e),this.glCtx.attachShader(this.program,I),this.glCtx.linkProgram(this.program),this.glCtx.getProgramParameter(this.program,this.glCtx.LINK_STATUS)||g.RainwayLogging.error("Shader link failed.")}static compile(A,e,I){let t;return t="vertex"===e?A.createShader(A.VERTEX_SHADER):A.createShader(A.FRAGMENT_SHADER),A.shaderSource(t,I),A.compileShader(t),0==A.getShaderParameter(t,A.COMPILE_STATUS)&&g.RainwayLogging.error("Shader compile failed, log: "+A.getShaderInfoLog(t)),t}static create(A,e,I){const g=t.compile(A,"vertex",e),i=t.compile(A,"fragment",I);return new t(A,g,i)}use(){this.glCtx.useProgram(this.program)}getAttributeLocation(A){return this.glCtx.getAttribLocation(this.program,A)}getUniformLocation(A){const e=this.glCtx.getUniformLocation(this.program,A);if(e)return e}setMatrixUniform(A,e){this.glCtx.uniformMatrix4fv(A,!1,e)}}e.default=t},756:function(A,e,I){"use strict";var g=this&&this.__importDefault||function(A){return A&&A.__esModule?A:{default:A}};Object.defineProperty(e,"__esModule",{value:!0}),e.yuvFragShaderSrc=void 0;const t=g(I(4919));e.yuvFragShaderSrc="\n    precision lowp float;\n    \n    varying vec2 vTexCoord;\n    \n    uniform sampler2D yTexture;\n    uniform sampler2D uTexture;\n    uniform sampler2D vTexture;\n    const mat3 conversion = mat3(\n        1.164, 0.000,  1.596,\n        1.164, -0.391, -0.813,\n        1.164, 2.018,  0.000\n    );\n\n    const vec3 offset = vec3(0.0625, 0.5, 0.5);\n        \n    void main(void) {\n        float y = texture2D(yTexture, vTexCoord).x;\n        float u = texture2D(uTexture, vTexCoord).x;\n        float v = texture2D(vTexture, vTexCoord).x;\n        vec3 yuv = vec3(y, u, v) - offset;\n\n        vec3 rgb = (yuv * conversion);\n\n        gl_FragColor = vec4(rgb, 1.0);\n    }\n";class i{constructor(A,e,I,g,t,i,B,C,Q){this.glCtx=A,this.program=e,this.projectionMtxLoc=I,this.positionAttr=g,this.texCoordAttr=t,this.vertexBuffer=i,this.yTextureLoc=B,this.uTextureLoc=C,this.vTextureLoc=Q}static create(A){const I=t.default.create(A,"\n    precision mediump float;\n\n    uniform mat4 uProjection;\n    attribute vec2 aPosition;\n    attribute vec2 aTexCoord;\n\n    varying vec2 vTexCoord;\n    void main(){\n        vTexCoord = aTexCoord;\n        gl_Position = uProjection * vec4(aPosition, 0.0, 1.0);\n    }\n",e.yuvFragShaderSrc);I.use();const g=I.getUniformLocation("uProjection"),B=I.getAttributeLocation("aPosition");A.enableVertexAttribArray(B);const C=I.getAttributeLocation("aTexCoord");A.enableVertexAttribArray(C);const Q=A.createBuffer(),o=I.getUniformLocation("yTexture"),n=I.getUniformLocation("uTexture"),a=I.getUniformLocation("vTexture");return new i(A,I,g,B,C,Q,o,n,a)}bindInputTextures(A,e,I){const g=this.glCtx;g.uniform1i(this.yTextureLoc,0),g.activeTexture(g.TEXTURE0),g.bindTexture(g.TEXTURE_2D,A.textureId),g.uniform1i(this.uTextureLoc,1),g.activeTexture(g.TEXTURE1),g.bindTexture(g.TEXTURE_2D,e.textureId),g.uniform1i(this.vTextureLoc,2),g.activeTexture(g.TEXTURE2),g.bindTexture(g.TEXTURE_2D,I.textureId)}use(){this.program.use()}drop(){this.glCtx.useProgram(0)}update(A,e,I,g){this.glCtx.viewport(0,0,A,e),this.program.setMatrixUniform(this.projectionMtxLoc,[2/A,0,0,0,0,2/-e,0,0,0,0,1,0,-1,1,0,1]),this.glCtx.bindBuffer(this.glCtx.ARRAY_BUFFER,this.vertexBuffer),this.glCtx.bufferData(this.glCtx.ARRAY_BUFFER,new Float32Array([0,0,0,0,A,0,I,0,A,e,I,g,A,e,I,g,0,e,0,g,0,0,0,0]),this.glCtx.DYNAMIC_DRAW),this.glCtx.vertexAttribPointer(this.positionAttr,2,this.glCtx.FLOAT,!1,16,0),this.glCtx.vertexAttribPointer(this.texCoordAttr,2,this.glCtx.FLOAT,!1,16,8)}draw(){const A=this.glCtx;A.clear(A.COLOR_BUFFER_BIT|A.DEPTH_BUFFER_BIT|A.STENCIL_BUFFER_BIT),A.drawArrays(A.TRIANGLE_STRIP,0,6),A.bindTexture(A.TEXTURE_2D,null)}}e.default=i},3346:(A,e)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0});class I{constructor(A,e){this.glCtx=void 0,this.textureId=void 0,this.glCtx=A,this.textureId=e}static create(A){const e=A.createTexture();return A.bindTexture(A.TEXTURE_2D,e),A.texParameteri(A.TEXTURE_2D,A.TEXTURE_MAG_FILTER,A.NEAREST),A.texParameteri(A.TEXTURE_2D,A.TEXTURE_MIN_FILTER,A.NEAREST),A.texParameteri(A.TEXTURE_2D,A.TEXTURE_WRAP_S,A.CLAMP_TO_EDGE),A.texParameteri(A.TEXTURE_2D,A.TEXTURE_WRAP_T,A.CLAMP_TO_EDGE),A.bindTexture(A.TEXTURE_2D,null),new I(A,e)}uploadBuffer(A,e,I){const g=this.glCtx;g.bindTexture(g.TEXTURE_2D,this.textureId),g.texImage2D(g.TEXTURE_2D,0,g.LUMINANCE,e,I,0,g.LUMINANCE,g.UNSIGNED_BYTE,A),g.bindTexture(g.TEXTURE_2D,null)}delete(){null!=this.glCtx&&0!=this.textureId&&(this.glCtx.deleteTexture(this.textureId),this.textureId=0)}}e.default=I},4425:function(A,e,I){"use strict";var g,t=this&&this.__awaiter||function(A,e,I,g){return new(I||(I=Promise))((function(t,i){function B(A){try{Q(g.next(A))}catch(A){i(A)}}function C(A){try{Q(g.throw(A))}catch(A){i(A)}}function Q(A){var e;A.done?t(A.value):(e=A.value,e instanceof I?e:new I((function(A){A(e)}))).then(B,C)}Q((g=g.apply(A,e||[])).next())}))},i=this&&this.__classPrivateFieldSet||function(A,e,I){if(!e.has(A))throw new TypeError("attempted to set private field on non-instance");return e.set(A,I),I},B=this&&this.__classPrivateFieldGet||function(A,e){if(!e.has(A))throw new TypeError("attempted to get private field on non-instance");return e.get(A)};Object.defineProperty(e,"__esModule",{value:!0}),e.MediaManager=e.RainwayStreamFit=e.RainwayVideoFormat=e.RainwayVideoDecoder=void 0;const C=I(6900),Q=I(6585),o=I(1078),n=I(5914),a=I(2146),r=I(3930),E=I(6904);var s,d,c;!function(A){A[A.MSE=0]="MSE",A[A.Software=1]="Software"}(s=e.RainwayVideoDecoder||(e.RainwayVideoDecoder={})),function(A){A[A.AnnexB=0]="AnnexB",A[A.LengthPrefixed=1]="LengthPrefixed"}(d=e.RainwayVideoFormat||(e.RainwayVideoFormat={})),function(A){A[A.IsolatedApps=0]="IsolatedApps",A[A.FullDesktop=1]="FullDesktop"}(c=e.RainwayStreamFit||(e.RainwayStreamFit={})),e.MediaManager=class{constructor(A,e,I,t){var r;this.captureMode=A,this.chosenVideoConfig=e,g.set(this,void 0),this.overlayEnabled=!1,this.streamFit=c.IsolatedApps,i(this,g,{video:Object.assign(Object.assign({codecString:'video/mp4; codecs="avc1.42c020"'},this.autodetectVideoConfiguration()),I.video),videoPerformance:null!==(r=I.videoPerformance)&&void 0!==r?r:{},audio:Object.assign({},I.audio)}),B(this,g).video.decoder===s.Software?this.videoStream=new a.VideoStreamSoftwareDecoder(B(this,g).video.codecString,d.LengthPrefixed):this.videoStream=new C.VideoStreamMSE(B(this,g).video.codecString),this.audioStream=new Q.AudioStream,this.audioStream.configure(B(this,g).audio),this.videoPerformanceMonitor=new o.VideoPerformanceMonitor(this.videoStream,B(this,g).videoPerformance),this.videoStatsOverlay=new n.VideoStatsOverlay(this.videoStream,B(this,g).video.decoder===s.Software,t)}get videoReadyStateChangeEvent(){return this.videoStream.readyStateChangeEvent}get videoNeedsRestartEvent(){return this.videoStream.needsRestartEvent}get audioContext(){return this.audioStream.audioContext}get currentStreamBounds(){return this.streamBounds}get currentFullDesktopBounds(){return this.fullDesktopBounds}initialize(){return t(this,void 0,void 0,(function*(){yield this.audioStream.initialize(),this.audioStream.play()}))}get config(){return B(this,g)}autodetectVideoConfiguration(){return{decoder:window.MediaSource?s.MSE:s.Software}}setContainer(A){if(this.unsetContainer(),this.container=A,this.captureMode===E.StreamType.AppIsolation){const A=this.createIsolationCanvasElement();this.showStreamElement(A),B(this,g).video.decoder===s.MSE?this.setIsolationSource(this.createVideoElement()):this.setIsolationSource(this.createCanvasElement())}else B(this,g).video.decoder===s.MSE?this.showStreamElement(this.createVideoElement()):this.showStreamElement(this.createCanvasElement());this.overlayEnabled&&this.createAndShowStatsOverlay()}setIsolationSource(A){this.isolationSource=A}createAndShowStatsOverlay(){const A=this.createOverlayCanvasElement();this.showOverlayElement(A),B(this,g).video.decoder===s.MSE?this.videoStatsOverlay.setElements({video:this.videoElement,canvas:A,usingOutputCanvas:!1}):this.videoStatsOverlay.setElements({canvas:A,usingOutputCanvas:!1})}unsetContainer(){var A,e,I,g,t,i,B,C;this.disposeVideoElement(),this.disposeCanvasElement(),this.disposeOverlayCanvasElement(),this.disposeIsolationCanvasElement(),null===(e=null===(A=this.container)||void 0===A?void 0:A.querySelector(".rainway-video"))||void 0===e||e.remove(),null===(g=null===(I=this.container)||void 0===I?void 0:I.querySelector(".rainway-canvas"))||void 0===g||g.remove(),null===(i=null===(t=this.container)||void 0===t?void 0:t.querySelector(".rainway-overlay-canvas"))||void 0===i||i.remove(),null===(C=null===(B=this.container)||void 0===B?void 0:B.querySelector(".rainway-isolation-canvas"))||void 0===C||C.remove(),this.container=void 0}showOverlayElement(A){Object.assign(A.style,{position:"absolute",top:"0",bottom:"0",left:"0",right:"0",width:"100%",height:"100%",pointerEvents:"none"})}createVideoElement(){var A,e;null===(e=null===(A=this.container)||void 0===A?void 0:A.querySelector(".rainway-video"))||void 0===e||e.remove(),this.videoElement=document.createElement("video");const I=this.videoElement;return I.oncontextmenu=()=>!1,I.className="rainway-video",I.autoplay=!0,I.muted=!0,I.style.display="none",this.container.appendChild(I),this.videoStream.attachToElement(I),this.videoElement}disposeVideoElement(){this.videoElement&&(this.videoStream.detachFromElement(),this.videoElement.remove(),this.videoElement=void 0)}createOverlayCanvasElement(){var A,e,I;null===(e=null===(A=this.container)||void 0===A?void 0:A.querySelector(".rainway-overlay-canvas"))||void 0===e||e.remove(),this.canvasElement=document.createElement("canvas");const g=this.canvasElement;return g.oncontextmenu=()=>!1,g.className="rainway-overlay-canvas",this.container.appendChild(g),null===(I=g.getContext("2d"))||void 0===I||I.clearRect(0,0,g.width,g.height),g}disposeOverlayCanvasElement(){var A,e;null===(e=null===(A=this.container)||void 0===A?void 0:A.querySelector(".rainway-overlay-canvas"))||void 0===e||e.remove(),this.overlayCanvasElement&&(this.overlayCanvasElement.remove(),this.overlayCanvasElement=void 0)}createCanvasElement(){var A,e,I;null===(e=null===(A=this.container)||void 0===A?void 0:A.querySelector(".rainway-canvas"))||void 0===e||e.remove(),this.canvasElement=document.createElement("canvas");const g=this.canvasElement;return g.oncontextmenu=()=>!1,g.className="rainway-canvas",g.style.display="none",this.container.appendChild(g),this.videoStream instanceof a.VideoStreamSoftwareDecoder&&this.videoStream.attachToCanvas(g),null===(I=g.getContext("2d"))||void 0===I||I.clearRect(0,0,g.width,g.height),g}disposeCanvasElement(){this.canvasElement&&(this.videoStream instanceof a.VideoStreamSoftwareDecoder&&this.videoStream.detachFromCanvas(),this.canvasElement.remove(),this.canvasElement=void 0)}createIsolationCanvasElement(){var A,e,I;null===(e=null===(A=this.container)||void 0===A?void 0:A.querySelector(".rainway-isolation-canvas"))||void 0===e||e.remove(),this.isolationCanvasElement=document.createElement("canvas");const g=this.isolationCanvasElement;return g.oncontextmenu=()=>!1,g.className="rainway-isolation-canvas",this.container.appendChild(g),null===(I=g.getContext("2d"))||void 0===I||I.clearRect(0,0,g.width,g.height),g}disposeIsolationCanvasElement(){this.isolationCanvasElement&&(this.isolationCanvasElement.remove(),this.isolationCanvasElement=void 0)}hideStreamElement(A){A.style.width="0",A.style.height="0"}showStreamElement(A){this.container&&(this.streamElement=A,A.style.width="100%",A.style.height="100%",A.style.display="block",A.style.objectFit="contain")}pause(){this.videoStream.pause(),this.audioStream.stop()}play(){this.videoStream.play(),this.audioStream.play()}renderVideoFrame(A,e){this.videoStream.pushData(A,e),this.fullDesktopBounds={left:A.x,top:A.y,width:A.width,height:A.height},this.captureMode===E.StreamType.AppIsolation?(A.mask.length>0&&(this.mask=A.mask),A.width>0&&(this.frameWidth=A.width),A.height>0&&(this.frameHeight=A.height),this.renderIsolatedApp()):this.streamBounds=this.fullDesktopBounds}renderIsolatedApp(){if(!this.mask)return;if(!this.frameWidth)return;if(!this.frameHeight)return;const A=this.isolationSource;if(!A)return;const e=this.isolationCanvasElement;if(!e)return;const I=e.getContext("2d");if(!I)return;const g=this.streamFit==c.IsolatedApps?r.boundingRectangle(this.mask):this.fullDesktopBounds;this.streamBounds=g;const t=this.chosenVideoConfig.codec.width/this.frameWidth,i=this.chosenVideoConfig.codec.height/this.frameHeight;e.width=g.width*t,e.height=g.height*i;for(const{left:e,top:B,width:C,height:Q}of this.mask){const o=e*t,n=B*i,a=C*t,r=Q*i,E=(e-g.left)*t,s=(B-g.top)*i;I.drawImage(A,o,n,a,r,E,s,a,r)}}processAudio(A){this.audioStream.pushData(A)}getVideoStats(){return this.videoStream.getStats()}configureAudio(A){return t(this,void 0,void 0,(function*(){B(this,g).audio=Object.assign(Object.assign({},B(this,g).audio),A),this.audioStream.configure(A)}))}enableStatsOverlay(){this.overlayEnabled=!0,this.videoStatsOverlay.enable(),this.disposeOverlayCanvasElement(),this.createAndShowStatsOverlay()}disableStatsOverlay(){this.disposeOverlayCanvasElement(),this.overlayEnabled=!1,this.videoStatsOverlay.disable()}dispose(){this.pause(),this.unsetContainer(),this.audioStream.dispose(),this.videoStream.dispose()}setVolume(A){this.audioStream.setVolume(A)}},g=new WeakMap},1633:function(A,e){"use strict";var I,g=this&&this.__awaiter||function(A,e,I,g){return new(I||(I=Promise))((function(t,i){function B(A){try{Q(g.next(A))}catch(A){i(A)}}function C(A){try{Q(g.throw(A))}catch(A){i(A)}}function Q(A){var e;A.done?t(A.value):(e=A.value,e instanceof I?e:new I((function(A){A(e)}))).then(B,C)}Q((g=g.apply(A,e||[])).next())}))},t=this&&this.__classPrivateFieldGet||function(A,e){if(!e.has(A))throw new TypeError("attempted to get private field on non-instance");return e.get(A)},i=this&&this.__classPrivateFieldSet||function(A,e,I){if(!e.has(A))throw new TypeError("attempted to set private field on non-instance");return e.set(A,I),I};Object.defineProperty(e,"__esModule",{value:!0}),e.CircularBuffer=e.average=e.createSourceBuffer=e.awaitMediaSourceOpen=e.createMediaSource=e.MediaUnsupportedError=void 0;class B extends Error{}function C(A,e){return g(this,void 0,void 0,(function*(){return new Promise(((I,g)=>{let t=!1;const i=()=>{A.removeEventListener("sourceopen",B),null==e||e.removeHandler(o),window.clearInterval(Q),t=!0},B=()=>{i(),I(!0)},C=()=>{t||"open"===A.readyState&&(i(),I(!0))},Q=window.setInterval(C,500);C(),window.setTimeout((()=>{t||(i(),g(new Error("MediaSource open timed out.")))}),1e4),A.addEventListener("sourceopen",B);const o=()=>{i(),I(!1)};null==e||e.addHandler(o)}))}))}e.MediaUnsupportedError=B,e.createMediaSource=function(A,e){return g(this,void 0,void 0,(function*(){if(!window.MediaSource)throw new B("Browser does not support MSE.");const I=new MediaSource,g=window.URL.createObjectURL(I);if(A.src=void 0,A.src=g,A.load(),yield C(I,e))return I.duration=Number.POSITIVE_INFINITY,I}))},e.awaitMediaSourceOpen=C,e.createSourceBuffer=function(A,e){const I=A.addSourceBuffer(e);return I.mode="sequence",I},e.average=function(A){return 0===A.length?0:A.reduce(((A,e)=>A+e),0)/A.length},e.CircularBuffer=class{constructor(A){this.maxLength=A,this.nextIndex=0,this.list=Array(this.maxLength),I.set(this,0)}get length(){return t(this,I)}push(A){this.list[this.nextIndex++]=A,i(this,I,Math.max(t(this,I),this.nextIndex)),this.nextIndex%=this.maxLength}values(){return this.list.slice(0,t(this,I))}},I=new WeakMap},1078:(A,e,I)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.VideoPerformanceMonitor=void 0;const g=I(198),t=I(2434),i=I(9024),B={targetFramerate:60,bufferLimitMs:500,cpuStarvationThreshold:1,decoderStrugglingThreshold:1,checkInterval:1500,windowMs:500};e.VideoPerformanceMonitor=class{constructor(A,e={}){this.videoStream=A,this.decoderStrugglingEvent=new i.Action,this.cpuStarvationEvent=new i.Action,this.cpuStarvationCounter=0,this.decoderStrugglingCounter=0,this.readyStateChangeHandler=A=>{A===t.VideoReadyState.Detached?this.stopChecking():this.lastVideoReadyState===t.VideoReadyState.Detached&&this.startChecking(),this.lastVideoReadyState=A},this.videoFrameMetadataHandler=A=>{this.processingDurationTrack.feed(A)},this.checkPerformance=()=>{if(this.videoStream.readyState===t.VideoReadyState.Playing){const A=1/this.config.targetFramerate,e=1e3*A,I=Math.floor(this.config.bufferLimitMs/e),g=this.videoStream.getStats();(g.endOfBuffered>g.currentTime+this.config.bufferLimitMs/1e3||this.videoStream.dataQueueLength>I)&&this.videoStream.restart("checkPerformance"),this.videoStream.dataQueueLength>I?this.cpuStarvationCounter+=1:this.cpuStarvationCounter=Math.max(0,this.cpuStarvationCounter-1),this.processingDurationTrack.average()>A?(this.decoderStrugglingCounter+=1,this.cpuStarvationCounter=Math.max(0,this.cpuStarvationCounter-1)):this.decoderStrugglingCounter=Math.max(0,this.decoderStrugglingCounter-1),this.cpuStarvationCounter,this.config.cpuStarvationThreshold,this.decoderStrugglingCounter,this.config.decoderStrugglingThreshold}},this.config=Object.assign(Object.assign({},B),e),this.processingDurationTrack=new g.WindowTrack(this.config.windowMs,g.meanOrZero),this.videoStream.readyStateChangeEvent.addHandler(this.readyStateChangeHandler),this.videoStream.videoFrameProcessingDurationEvent.addHandler(this.videoFrameMetadataHandler),this.lastVideoReadyState=this.videoStream.readyState,this.videoStream.readyState!==t.VideoReadyState.Detached&&this.startChecking()}dispose(){this.stopChecking(),this.videoStream.readyStateChangeEvent.removeHandler(this.readyStateChangeHandler),this.videoStream.videoFrameProcessingDurationEvent.removeHandler(this.videoFrameMetadataHandler)}startChecking(){this.processingDurationTrack=new g.WindowTrack(this.config.windowMs,g.meanOrZero),this.checkPerformanceInterval=window.setInterval(this.checkPerformance,this.config.checkInterval)}stopChecking(){this.checkPerformanceInterval&&(window.clearInterval(this.checkPerformanceInterval),this.checkPerformanceInterval=void 0)}}},5914:function(A,e,I){"use strict";var g=this&&this.__awaiter||function(A,e,I,g){return new(I||(I=Promise))((function(t,i){function B(A){try{Q(g.next(A))}catch(A){i(A)}}function C(A){try{Q(g.throw(A))}catch(A){i(A)}}function Q(A){var e;A.done?t(A.value):(e=A.value,e instanceof I?e:new I((function(A){A(e)}))).then(B,C)}Q((g=g.apply(A,e||[])).next())}))};Object.defineProperty(e,"__esModule",{value:!0}),e.VideoStatsOverlay=void 0;const t=I(2146),i=I(2434),B=I(198),C=5e3,Q={droppedFrames:"Dropped frames",totalFrames:"Total frames",currentTime:"Current video time",endOfBuffered:"End of video buffer",endOfSeekable:"End of video seekable",dataInterval:"Video data interval",dataSize:"Video frame size",processingDuration:"Frame processing duration"};e.VideoStatsOverlay=class{constructor(A,e,I){this.videoStream=A,this.usingOutputCanvas=e,this.getStats=I,this.compositingTimeTrack=new B.WindowTrack(C,B.mean),this.processingDurationTrack=new B.WindowTrack(C,B.mean),this.frameTrack=new B.WindowTrack(C,B.mean),this.drawIntervalTrack=new B.WindowTrack(C,B.mean),this.displayTimeIntervalTrack=new B.WindowTrack(C,B.mean),this.frameCounter=0,this.throughput=[],this.fetchStats=()=>g(this,void 0,void 0,(function*(){this.videoStream.readyState===i.VideoReadyState.Playing&&(this.stats=this.videoStream.getStats(),this.lastTransportStats=this.transportStats,this.transportStats=yield this.getStats(),this.throughput=this.getThroughput())})),this.animationFrameHandler=()=>{this.frameTrack.feed(this.frameCounter),this.frameCounter=0,this.animationFrameHandle=window.requestAnimationFrame(this.animationFrameHandler)},this.drawStatsOnlyOnAnimationFrame=()=>{if(this.drawStatsOnlyHandle=window.requestAnimationFrame(this.drawStatsOnlyOnAnimationFrame),!this.canvasContext||this.videoStream.readyState!==i.VideoReadyState.Playing)return;const A=this.canvasContext;this.usingOutputCanvas||(A.canvas.width!==A.canvas.clientWidth&&(A.canvas.width=A.canvas.clientWidth),A.canvas.height!==A.canvas.clientHeight&&(A.canvas.height=A.canvas.clientHeight),A.clearRect(0,0,A.canvas.width,A.canvas.height)),this.drawStats()},this.drawStatsAndGraphsOnVideoFrame=([A,e])=>{if(this.frameCounter++,!this.canvasContext||this.videoStream.readyState!==i.VideoReadyState.Playing||!e)return;const I=this.canvasContext;this.usingOutputCanvas||(I.canvas.width!==I.canvas.clientWidth&&(I.canvas.width=I.canvas.clientWidth),I.canvas.height!==I.canvas.clientHeight&&(I.canvas.height=I.canvas.clientHeight),I.clearRect(0,0,I.canvas.width,I.canvas.height));const g=performance.now();this.lastCanvasDrawTime&&this.drawIntervalTrack.feed(g-this.lastCanvasDrawTime),this.lastCanvasDrawTime=g;const t=e.expectedDisplayTime;this.lastDisplayTime&&this.displayTimeIntervalTrack.feed(t-this.lastDisplayTime),this.lastDisplayTime=t,this.compositingTimeTrack.feed(e.expectedDisplayTime-A),this.processingDurationTrack.feed(e.processingDuration);const B=I.canvas;B.width,B.clientWidth,B.height,B.clientHeight,this.drawStats(e)}}setElements({video:A,canvas:e,usingOutputCanvas:I=!1}){this.usingOutputCanvas=I,this.canvas=e,this.video=A,this.canvas&&(this.canvasContext=this.canvas.getContext("2d",{alpha:!this.usingOutputCanvas}))}enable(){this.animationFrameHandle&&window.cancelAnimationFrame(this.animationFrameHandle),this.drawStatsOnlyHandle&&window.cancelAnimationFrame(this.drawStatsOnlyHandle),this.videoStream instanceof t.VideoStreamSoftwareDecoder||"requestVideoFrameCallback"in HTMLVideoElement.prototype?(this.animationFrameHandle=window.requestAnimationFrame(this.animationFrameHandler),this.videoStream.videoFrameEvent.addHandler(this.drawStatsAndGraphsOnVideoFrame)):this.drawStatsOnlyHandle=window.requestAnimationFrame(this.drawStatsOnlyOnAnimationFrame),this.statsInterval=window.setInterval(this.fetchStats,1e3)}disable(){this.animationFrameHandle&&window.cancelAnimationFrame(this.animationFrameHandle),this.drawStatsOnlyHandle&&window.cancelAnimationFrame(this.drawStatsOnlyHandle),this.videoStream.videoFrameEvent.removeHandler(this.drawStatsAndGraphsOnVideoFrame),window.clearInterval(this.statsInterval)}getThroughput(){var A;return this.transportStats&&this.lastTransportStats?Object.entries(null===(A=this.transportStats)||void 0===A?void 0:A.channels).map((([A,e])=>this.lastTransportStats?[A,e.bytesSent-this.lastTransportStats.channels[A].bytesSent,e.bytesReceived-this.lastTransportStats.channels[A].bytesReceived]:[A,0,0])):[]}drawStats(A){var e,I;if(!this.canvasContext||this.videoStream.readyState!==i.VideoReadyState.Playing)return;const g=this.canvasContext,t=g.canvas,B=t.width/t.clientWidth,C=t.height/t.clientHeight,o=this.throughput;if(this.stats){const i=Object.entries(this.stats),n=i.length+o.length,a=g.measureText("M").width;g.fillStyle="rgba(0, 0, 0, 0.5)";const r=(n+2)*a+2*(a+2*C)+15*C;g.fillRect(10*B,t.height-(r+10*C),300*B,r),g.fillStyle="white",g.font=`${(12*B).toFixed(0)}px sans-serif`,g.textBaseline="top";let E=0;const s=t.height-(r+15*C)+15*B;A?g.fillText(`Resolution: ${A.width}x${A.height}`,15*B,s):g.fillText(`Resolution: ${null===(e=this.video)||void 0===e?void 0:e.videoWidth}x${null===(I=this.video)||void 0===I?void 0:I.videoHeight}`,15*B,s),g.fillText(`Element size: ${t.clientWidth}x${t.clientHeight}`,15*B,s+a);for(const[A,e]of i){let I,t="";"processingDuration"===A?(t="ms",I=1e3*e):I=e,"endOfBuffered"===A||"endOfSeekable"===A||"currentTime"===A?t="s":"dataInterval"===A?t="ms":"dataSize"===A&&(t="bytes"),g.fillText(`${Q[A]}: ${I.toFixed(2)} ${t}`,15*B,E*(a+2*C)+2*(a+2*C)+s),E++}for(const[A,e,I]of o)g.fillText(`${A} throughput - up: ${(e/1e3).toFixed(0)} kb/s, down: ${(I/1e3).toFixed(0)} kb/s`,15*B,E*(a+2*C)+2*(a+2*C)+s),E++}}}},4441:(A,e,I)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.VideoStats=void 0;const g=I(2994),t=I(1633);e.VideoStats=class{constructor(){this.processingDurations=new Map,this.dataIntervals=new t.CircularBuffer(60),this.dataSizes=new t.CircularBuffer(60),this.totalFrames=0,this.presentedFrames=0}pushFrameMetadata(A){this.presentedFrames+=1;const{processingDuration:e}=A,I=(new Date).getTime();this.processingDurations.set(I,e);for(const[A]of this.processingDurations.entries())A<I-1e3&&this.processingDurations.delete(A)}reportFrameSubmitted(){this.totalFrames+=1}resetFrameCounts(){this.totalFrames=0,this.presentedFrames=0}pushData(A){this.dataSizes.push(A.byteLength);const e=(new Date).getTime();this.lastDataTimestamp&&this.dataIntervals.push(e-this.lastDataTimestamp),this.lastDataTimestamp=e}setElement(A){this.element=A}getReport(){if(!this.element)throw new g.RainwayError("getReport() has no video element");const A=t.average(Array.from(this.processingDurations.values())),e=this.element.buffered,I=e.length>0?e.end(e.length-1):0,i=this.element.seekable,B=i.length>0?i.end(i.length-1):0;return{processingDuration:A,droppedFrames:this.totalFrames-this.presentedFrames,totalFrames:this.totalFrames,dataInterval:t.average(this.dataIntervals.values()),dataSize:t.average(this.dataSizes.values()),currentTime:this.element.currentTime,endOfBuffered:I,endOfSeekable:B}}createReport(A,e){return{processingDuration:t.average(Array.from(this.processingDurations.values())),droppedFrames:null!=A?A:0,totalFrames:null!=e?e:0,dataInterval:t.average(this.dataIntervals.values()),dataSize:t.average(this.dataSizes.values()),currentTime:0,endOfBuffered:0,endOfSeekable:0}}}},6900:function(A,e,I){"use strict";var g=this&&this.__awaiter||function(A,e,I,g){return new(I||(I=Promise))((function(t,i){function B(A){try{Q(g.next(A))}catch(A){i(A)}}function C(A){try{Q(g.throw(A))}catch(A){i(A)}}function Q(A){var e;A.done?t(A.value):(e=A.value,e instanceof I?e:new I((function(A){A(e)}))).then(B,C)}Q((g=g.apply(A,e||[])).next())}))};Object.defineProperty(e,"__esModule",{value:!0}),e.VideoStreamMSE=void 0;const t=I(9024),i=I(1633),B=I(2434),C=I(3464),Q=I(4441);function o(A){return 102===A[4]&&116===A[5]&&121===A[6]&&112===A[7]}e.VideoStreamMSE=class{constructor(A){this.codecString=A,this.readyState=B.VideoReadyState.Detached,this.needsRestartEvent=new t.Action,this.sourceOpenEvent=new t.Action,this.readyStateChangeEvent=new t.Action,this.videoFrameEvent=new t.Action,this.videoFrameProcessingDurationEvent=new t.Action,this.cancelInitializeEvent=new t.Action,this.dataQueue=[],this.stats=new Q.VideoStats,this.justClearedBuffer=!1,this.lastBufferEnd=0,this.framesFrozenFor=0,this.ensureBuffer=()=>{if(this.readyState!==B.VideoReadyState.Paused&&this.readyState!==B.VideoReadyState.Detached&&this.element&&0===this.element.buffered.length){if(this.sourceBuffer&&!this.sourceBuffer.updating&&this.sourceBuffer.timestampOffset<=0){const A=this.sourceBuffer.timestampOffset.toFixed(2);this.sourceBuffer.timestampOffset=1;const e=this.sourceBuffer.timestampOffset.toFixed(2);this.warn(`Poked timestampOffset from ${A} to ${e}`)}this.restart("ensureBuffer")}},this.videoFrameHandler=(A,e)=>{(null==e?void 0:e.processingDuration)&&this.videoFrameProcessingDurationEvent.invoke(e.processingDuration),e&&this.stats.pushFrameMetadata(e),this.videoFrameEvent.invoke([A,e]),this.requestNextFrameCallback()},this.fallbackVideoFrameHandler=A=>{this.videoFrameHandler(A,void 0)},this.sourceBufferUpdateHandler=()=>{this.submitData()}}info(A){C.RainwayLogging.information(`[VideoStream] ${String(A)}`)}debug(A){C.RainwayLogging.debug(`[VideoStream] ${String(A)}`)}warn(A){C.RainwayLogging.warning(`[VideoStream] ${String(A)}`)}get dataQueueLength(){return this.dataQueue.length}attachToElement(A){this.info("Attaching to element: "+A),this.cancelInitializeEvent.invoke(),this.element=A,this.stats.setElement(this.element),this.stats.resetFrameCounts(),this.restart("attachToElement"),this.info("Attached to element.")}detachFromElement(){this.destroyMedia(),this.element=void 0,this.setReadyState(B.VideoReadyState.Detached),this.info("Detached from element.")}pause(){this.setReadyState(B.VideoReadyState.Paused)}play(){this.readyState===B.VideoReadyState.Paused&&this.restart("play")}pushData(A,e){if(this.dataQueue.length>8)return void this.restart("pushData.dataQueue too long");const I=new Uint8Array(e);return this.stats.pushData(I),this.readyState!==B.VideoReadyState.Paused?o(I)&&this.readyState===B.VideoReadyState.WaitingForKeyframe&&this.element?(this.debug(`Got requested keyframe (${I.length} bytes)`),this.getStats(),this.dataQueue.push(I),this.submitData(),void this.initializeMedia()):void(this.readyState!==B.VideoReadyState.WaitingForKeyframe&&this.element?(this.dataQueue.push(I),this.submitData()):this.startEnsuringBuffer()):void 0}getStats(){return this.stats.getReport()}setReadyState(A){this.info(`ReadyState changed: ${B.VideoReadyState[this.readyState]} => ${B.VideoReadyState[A]}`),this.readyState=A,this.readyStateChangeEvent.invoke(A)}submitData(){if(0!==this.dataQueue.length)if(void 0!==this.mediaSource)if(this.sourceBuffer){if(!this.sourceBuffer.updating)if(this.element){if(this.sourceBuffer.buffered.length>=1){const A=this.sourceBuffer.buffered.end(this.sourceBuffer.buffered.length-1);this.justClearedBuffer&&(this.element.currentTime=A,this.justClearedBuffer=!1),A===this.lastBufferEnd?(this.framesFrozenFor++,this.debug(`Frozen for ${this.framesFrozenFor} frames...`)):this.framesFrozenFor=0,this.lastBufferEnd=A}if(this.framesFrozenFor>=4)return this.restart("sourceBuffer FrozenFrames"),void(this.framesFrozenFor=0);try{const A=this.dataQueue[0];if(o(A)&&!this.justClearedBuffer)return this.debug("Got keyframe. Clearing sourcebuffer."),this.getStats(),this.sourceBuffer.remove(0,1/0),void(this.justClearedBuffer=!0);this.dataQueue.shift(),this.sourceBuffer.appendBuffer(A),this.stats.reportFrameSubmitted()}catch(A){C.RainwayLogging.error(String(A)),this.restart("submitData, sourceBuffer.appendBuffer error.")}}else this.debug("Idling because !element")}else this.debug("Idling because !sourceBuffer");else this.debug("Idling because mediaSource === undefined")}initializeMedia(){var A,e;return g(this,void 0,void 0,(function*(){if(this.setReadyState(B.VideoReadyState.Initializing),this.cancelInitializeEvent.invoke(),void 0!==this.mediaSource)return this.setReadyState(B.VideoReadyState.Playing),void(null===(A=this.element)||void 0===A||A.play());if(!this.element)throw new Error("Stream not attached to element.");try{const A=yield i.createMediaSource(this.element,this.cancelInitializeEvent);if(!A)return void this.setReadyState(B.VideoReadyState.WaitingForKeyframe);this.mediaSource=A,this.sourceBuffer=i.createSourceBuffer(this.mediaSource,this.codecString),this.sourceBuffer.addEventListener("updateend",this.sourceBufferUpdateHandler),this.sourceBuffer.addEventListener("error",(A=>console.error("sourceBuffer error:",A))),this.startEnsuringBuffer(),this.setReadyState(B.VideoReadyState.Playing),this.requestNextFrameCallback(),this.submitData(),null===(e=this.element)||void 0===e||e.play()}catch(A){this.setReadyState(B.VideoReadyState.WaitingForKeyframe)}}))}startEnsuringBuffer(){void 0===this.ensureBufferInterval&&(this.debug("Starting ensureBuffer loop"),this.ensureBufferInterval=window.setInterval(this.ensureBuffer,1e3))}destroyMedia(){var A,e;if(this.debug("destroyMedia() called"),void 0!==this.mediaSource){if(this.cancelFrameCallback(),null===(A=this.element)||void 0===A||A.pause(),null===(e=this.sourceBuffer)||void 0===e||e.removeEventListener("updateend",this.sourceBufferUpdateHandler),this.mediaSource){if(this.sourceBuffer){try{this.mediaSource.removeSourceBuffer(this.sourceBuffer)}catch(A){}this.sourceBuffer=void 0}if("open"===this.mediaSource.readyState)try{this.mediaSource.endOfStream()}catch(A){}this.mediaSource=void 0,this.element&&window.URL.revokeObjectURL(this.element.src)}window.clearInterval(this.ensureBufferInterval),this.ensureBufferInterval=void 0,this.setReadyState(B.VideoReadyState.WaitingForKeyframe)}}restart(A=""){const e=A?`Restarting Video Stream... Reason: '${A}'.`:"Restarting Video Stream.";this.warn(e),this.dataQueue=[],this.setReadyState(B.VideoReadyState.WaitingForKeyframe),this.needsRestartEvent.invoke()}requestNextFrameCallback(){var A,e,I,g;"requestVideoFrameCallback"in HTMLVideoElement.prototype?(this.frameHandle&&(null===(e=null===(A=this.element)||void 0===A?void 0:A.cancelVideoFrameCallback)||void 0===e||e.call(A,this.frameHandle),this.frameHandle=void 0),this.frameHandle=null===(g=null===(I=this.element)||void 0===I?void 0:I.requestVideoFrameCallback)||void 0===g?void 0:g.call(I,this.videoFrameHandler)):(this.frameHandle&&(window.cancelAnimationFrame(this.frameHandle),this.frameHandle=void 0),this.frameHandle=window.requestAnimationFrame(this.fallbackVideoFrameHandler))}cancelFrameCallback(){var A,e;"requestVideoFrameCallback"in HTMLVideoElement.prototype?this.frameHandle&&(null===(e=null===(A=this.element)||void 0===A?void 0:A.cancelVideoFrameCallback)||void 0===e||e.call(A,this.frameHandle),this.frameHandle=void 0):this.frameHandle&&(window.cancelAnimationFrame(this.frameHandle),this.frameHandle=void 0)}dispose(){this.cancelFrameCallback(),this.destroyMedia(),window.clearInterval(this.ensureBufferInterval),this.setReadyState(B.VideoReadyState.Disposed)}}},2146:function(A,e,I){"use strict";var g=this&&this.__importDefault||function(A){return A&&A.__esModule?A:{default:A}};Object.defineProperty(e,"__esModule",{value:!0}),e.VideoStreamSoftwareDecoder=void 0;const t=I(2434),i=I(9024),B=I(4425),C=g(I(8859)),Q=g(I(756)),o=g(I(3346)),n=I(3464),a=I(4441);e.VideoStreamSoftwareDecoder=class{constructor(A,e){this.codecString=A,this.format=e,this.readyState=t.VideoReadyState.Detached,this.needsRestartEvent=new i.Action,this.readyStateChangeEvent=new i.Action,this.videoFrameProcessingDurationEvent=new i.Action,this.videoFrameEvent=new i.Action,this.currentFrameInfo={containsSPS:!1,containsPPS:!1,containsFrameData:!0},this.paused=!1,this.stats=new a.VideoStats,this.totalFrames=0,this.waitingToDecodeQueue=[],this.decodeQueue=[],this.maxDecodeQueueSize=3,this.maxLatencyFrameCount=7,this.maxConsecutiveFramesDrops=3,this.framesDroppedSinceLastRender=0,this.totalFramesDropped=0,this.canvas=void 0,this.shader=void 0,this.yTexture=void 0,this.uTexture=void 0,this.vTexture=void 0,this.onDecode=({width:A,height:e,data:I})=>{if(0==this.decodeQueue.length)return n.RainwayLogging.error("[VideoStreamSoftwareDecoder] onDecode called with empty decoder queue!"),void this.sendDecoderWaitingToDecodeFrames();++this.totalFrames;const g=this.decodeQueue.shift();if(!this.paused){const t=Date.now();if(g.processingDuration=(t-g.mediaTime)/1e3,this.videoFrameProcessingDurationEvent.invoke(g.processingDuration),this.dataQueueLength>this.maxLatencyFrameCount&&this.framesDroppedSinceLastRender<this.maxConsecutiveFramesDrops)++this.framesDroppedSinceLastRender,++this.totalFramesDropped;else{this.framesDroppedSinceLastRender=0;const t=g.width,i=g.height;g.width=A,g.height=e,this.stats.pushFrameMetadata(g),this.renderFrame(t,i,I,A,e),this.videoFrameEvent.invoke([performance.now(),g])}}this.sendDecoderWaitingToDecodeFrames()},this.ensureBuffer=()=>{this.readyState===t.VideoReadyState.WaitingForKeyframe&&0===this.dataQueueLength&&(n.RainwayLogging.debug("Sending another request for a keyframe."),this.restart())},this.videoFormat=e,this.decoderWorker=new C.default,this.decoderWorker.initialize(),this.decoderWorker.onDecode=this.onDecode.bind(this),this.ensureBufferInterval=window.setInterval(this.ensureBuffer,1e3)}get dataQueueLength(){return this.waitingToDecodeQueue.length+this.decodeQueue.length}configure(A,e,I){this.maxDecodeQueueSize=A,this.maxLatencyFrameCount=e,this.maxConsecutiveFramesDrops=I}attachToElement(A){this.stats.resetFrameCounts(),this.readyState!=t.VideoReadyState.WaitingForKeyframe&&this.restart()}attachToCanvas(A){this.readyState!=t.VideoReadyState.WaitingForKeyframe&&this.restart(),this.canvas&&this.detachFromCanvas(),this.canvas=A;const e=A.getContext("webgl");this.shader=Q.default.create(e),this.yTexture=o.default.create(e),this.uTexture=o.default.create(e),this.vTexture=o.default.create(e)}detachFromElement(){this.setReadyState(t.VideoReadyState.Detached)}detachFromCanvas(){this.decoderWorker.release(),this.yTexture&&this.yTexture.delete(),this.uTexture&&this.uTexture.delete(),this.vTexture&&this.vTexture.delete(),this.canvas=void 0}pause(){this.paused=!0,this.setReadyState(t.VideoReadyState.Paused)}play(){this.paused&&(this.paused=!1,this.restart())}restart(){this.totalFrames=0,this.totalFramesDropped=0,this.framesDroppedSinceLastRender=0,this.waitingToDecodeQueue=[],this.setReadyState(t.VideoReadyState.WaitingForKeyframe),this.needsRestartEvent.invoke()}pushData(A,e){var I,g,i;if(this.stats.pushData(e),this.paused)return;const C=new Uint8Array(e);let Q=!1;if(this.videoFormat==B.RainwayVideoFormat.LengthPrefixed?Q=this.convertToAnnexbFormat(C):this.readyState==t.VideoReadyState.WaitingForKeyframe&&(Q=this.parseAnnexbFrameInfo(C)),this.readyState==t.VideoReadyState.WaitingForKeyframe)if(Q)this.setReadyState(t.VideoReadyState.Playing);else if(!(null===(I=this.currentFrameInfo)||void 0===I?void 0:I.containsFrameData))return((null===(g=this.currentFrameInfo)||void 0===g?void 0:g.containsSPS)||(null===(i=this.currentFrameInfo)||void 0===i?void 0:i.containsPPS))&&this.decoderWorker.decode(C),this.currentFrameInfo.containsSPS=!1,this.currentFrameInfo.containsPPS=!1,void(this.currentFrameInfo.containsFrameData=!0);if(this.readyState!=t.VideoReadyState.WaitingForKeyframe&&this.currentFrameInfo.containsFrameData){const e={width:A.width,height:A.height,mediaTime:Date.now(),processingDuration:0,expectedDisplayTime:0,presentationTime:0,presentedFrames:0};this.decode(e,C)}}convertToAnnexbFormat(A){let e=!1;this.currentFrameInfo.containsFrameData=!1;for(let I=0;I<A.length;){const g=this.ntohl(A,I);A[I]=0,A[++I]=0,A[++I]=0,A[++I]=1,++I;const t=31&A[I];t<=5&&t>=1?(e=5==t,this.currentFrameInfo.containsFrameData=!0):7==t?this.currentFrameInfo.containsSPS=!0:8==t&&(this.currentFrameInfo.containsPPS=!0),I+=g}return e}ntohl(A,e){return(255&A[e])<<24|(255&A[e+1])<<16|(255&A[e+2])<<8|255&A[e+3]}parseAnnexbFrameInfo(A){let e=!1;this.currentFrameInfo.containsFrameData=!1;for(let I=0;I<A.length;)if(0==A[I]&&0==A[I+1]){let g=0;if(1==A[I+2]?(I+=3,g=31&A[I]):0==A[I+2]&&1==A[I+3]?(I+=4,g=31&A[I]):++I,g<=5&&g>=1){if(this.currentFrameInfo.containsFrameData=!0,5==g){e=!0;break}}else 7==g?this.currentFrameInfo.containsSPS=!0:8==g&&(this.currentFrameInfo.containsPPS=!0)}else++I;return e}decode(A,e){0==this.decodeQueue.length?(0!=this.waitingToDecodeQueue.length&&(n.RainwayLogging.error("[VideoStreamSoftwareDecoder] empty decoder queue, but waiting to decode queue not empty!"),this.waitingToDecodeQueue=[]),this.sendToDecoder(A,e)):(this.waitingToDecodeQueue.push({metadata:A,data:e}),this.decodeQueue.length<this.maxDecodeQueueSize&&this.sendDecoderWaitingToDecodeFrames())}sendDecoderWaitingToDecodeFrames(){for(;this.decodeQueue.length<this.maxDecodeQueueSize&&this.waitingToDecodeQueue.length>0;){const A=this.waitingToDecodeQueue.shift();this.sendToDecoder(A.metadata,A.data)}}sendToDecoder(A,e){this.stats.reportFrameSubmitted(),this.decodeQueue.push(A),this.decoderWorker.decode(e)}renderFrame(A,e,I,g,t){this.canvas.width=A,this.canvas.height=e;const i=new Uint8Array(I),B=g*t,C=i.subarray(0,B),Q=B>>2,o=i.subarray(B,B+Q),n=i.subarray(B+Q,B+2*Q);this.yTexture.uploadBuffer(C,g,t);const a=g>>1,r=t>>1;this.uTexture.uploadBuffer(o,a,r),this.vTexture.uploadBuffer(n,a,r),this.shader.bindInputTextures(this.yTexture,this.uTexture,this.vTexture);const E=A/g,s=e/t;this.shader.update(g,t,E,s),this.shader.draw()}getStats(){return this.stats.createReport(this.totalFramesDropped,this.totalFrames)}setReadyState(A){this.readyState=A,this.readyStateChangeEvent.invoke(A)}dispose(){n.RainwayLogging.debug("Disposing VideoStreamSoftwareDecoder"),this.readyState=t.VideoReadyState.Disposed,this.decoderWorker.release(),this.decoderWorker.dispose(),window.clearInterval(this.ensureBufferInterval)}}},9104:function(A,e,I){"use strict";var g,t=this&&this.__awaiter||function(A,e,I,g){return new(I||(I=Promise))((function(t,i){function B(A){try{Q(g.next(A))}catch(A){i(A)}}function C(A){try{Q(g.throw(A))}catch(A){i(A)}}function Q(A){var e;A.done?t(A.value):(e=A.value,e instanceof I?e:new I((function(A){A(e)}))).then(B,C)}Q((g=g.apply(A,e||[])).next())}))},i=this&&this.__classPrivateFieldGet||function(A,e){if(!e.has(A))throw new TypeError("attempted to get private field on non-instance");return e.get(A)},B=this&&this.__classPrivateFieldSet||function(A,e,I){if(!e.has(A))throw new TypeError("attempted to set private field on non-instance");return e.set(A,I),I};Object.defineProperty(e,"__esModule",{value:!0}),e.Gateway=e.getHandshakeDataBase64=e.getPeerId=e.GatewayStatus=void 0;const C=I(290),Q=I(2994),o=I(3464),n=I(6904),a=I(9024);var r;function E(A,e,I){const g=n.GatewayIdentity.encode({id:A,apiKey:e,externalId:I});return btoa(String.fromCharCode(...g)).replace(/=*$/,"").replace(/\+/g,"-").replace(/\//g,"_")}!function(A){A[A.Open=0]="Open",A[A.Closed=1]="Closed"}(r=e.GatewayStatus||(e.GatewayStatus={})),e.getPeerId=function(A){var e;return t(this,void 0,void 0,(function*(){const I=yield C.getOrganizationInfo(A),g=`rainway-hostname-${I.organizationId.toString(16).padStart(8,"0")}-${I.universeFlag}`,t=BigInt(null!==(e=localStorage.getItem(g))&&void 0!==e?e:yield C.fetchNewPeerId());return localStorage.setItem(g,t.toString()),t}))},e.getHandshakeDataBase64=E,e.Gateway=class{constructor(A,e,I,i,B,C,Q="wss://gateway.rainway.network"){this.ownPeerId=A,this.apiKey=e,this.externalId=I,this.handlePeerInfo=i,this.connectionRequestHandler=B,this.addAcceptedPeer=C,this.connections=new Map,this.connectionLostEvent=new a.Action,g.set(this,r.Closed),this.syncKey=0,this.peerIdToExternalId=new Map,this.onMessage=A=>t(this,void 0,void 0,(function*(){var e;if(void 0!==this.socket&&"[object ArrayBuffer]"===A.data.toString()){const I=n.GatewayDatagram.decode(new Uint8Array(A.data)),{header:{syncKey:g},body:t}=I;switch(t.discriminator){case n.GatewayRequest.discriminator:o.RainwayLogging.warning("got GatewayRequest?! i am not a gateway. ignoring");break;case n.GatewayResponse.discriminator:{const A=t.value.body.value;o.RainwayLogging.trace("got GatewayHello"),null===(e=this.resolveConnectToGatewayPromise)||void 0===e||e.call(this,A);break}case n.GatewayAlert.discriminator:{const{level:A,description:e}=t.value;A===n.GatewayAlertLevel.Fatal?(o.RainwayLogging.error("Fatal GatewayAlert: "+n.GatewayAlertDescription[e]),this.die(e,"The connection to the Rainway server encountered a fatal error.")):this.onNonFatalAlert(g,e);break}case n.GatewayForwardable.discriminator:this.onForwardable(g,t.value)}}})),this.onClose=A=>{this.die(A,"The connection to the Rainway server was closed.")},this.onError=A=>{this.die(A,"The connection to the Rainway server was lost.")},this.url=Q}get status(){return i(this,g)}connect(){var A;return t(this,void 0,void 0,(function*(){return null!==(A=this.connectToGatewayPromise)&&void 0!==A?A:this.connectToGatewayPromise=new Promise(((A,e)=>{this.resolveConnectToGatewayPromise=A,this.rejectConnectToGatewayPromise=e,this.open()}))}))}open(){return t(this,void 0,void 0,(function*(){this.socket=yield this.makeWebSocket(this.url),o.RainwayLogging.debug("Gateway: connected WebSocket"),this.socket.addEventListener("message",this.onMessage),this.socket.addEventListener("close",this.onClose),B(this,g,r.Open)}))}makeWebSocket(A){return new Promise(((e,I)=>{const g=new WebSocket(A,["handshake",E(this.ownPeerId,this.apiKey,this.externalId)]);g.binaryType="arraybuffer",g.onopen=()=>{e(g)},g.onerror=A=>{this.onError(A),I(A),this.connectToGatewayPromise=void 0}}))}disconnect(){var A;if(o.RainwayLogging.debug("Gateway: close()"),void 0!==this.socket){this.socket.close(3e3,"Signaling websocket closed.");const A=this.socket;window.setTimeout((()=>{A.removeEventListener("close",this.onClose),A.removeEventListener("message",this.onMessage)}),0)}null===(A=this.rejectConnectToGatewayPromise)||void 0===A||A.call(this,void 0),B(this,g,r.Closed),this.connectToGatewayPromise=void 0,this.resolveConnectToGatewayPromise=void 0,this.rejectConnectToGatewayPromise=void 0,this.socket=void 0,this.connections.clear()}makeDatagram(A){return{header:{syncKey:++this.syncKey},body:A}}makeForwardable(A,e){return this.makeDatagram({discriminator:n.GatewayForwardable.discriminator,value:{targetPeerId:A,body:e}})}connectToHost(A,e){const I=this.connections.get(A);if(void 0!==I){if(I.owned)throw new Q.RainwayError("already connected in other direction");return I.promise}if(void 0===this.socket)throw new Q.RainwayError("socket undefined in sendInitConnectionRequest");if(this.status!==r.Open)throw new Q.RainwayError("signaling channel not open in sendInitConnectionRequest");const g=this.socket,t={pending:!0};return t.promise=new Promise(((I,i)=>{t.resolve=I,t.reject=i,o.RainwayLogging.trace(`Gateway: Adding ${A} to pendingConnections`);const B=this.makeDatagram({discriminator:n.GatewayRequest.discriminator,value:{body:{discriminator:n.InitConnectionRequest.discriminator,value:{desiredTransport:e,targetPeerId:A}}}});t.syncKey=B.header.syncKey,this.connections.set(A,t),g.send(n.GatewayDatagram.encode(B))})),t.promise}cancelConnectionAttempt(A){const e=this.connections.get(A);void 0!==e&&e.pending&&(e.resolve({canceled:!0}),this.connections.delete(A))}deleteConnection(A){this.connections.delete(A)}sendPeerInfo(A,e,I){if(void 0===this.socket)throw new Q.RainwayError("socket unset in Gateway.sendPeerInfo");const g=this.connections.get(A);if(void 0===g)throw new Q.RainwayError(`can't send peer info to unknown peerId ${A}`);if(g.pending)throw new Q.RainwayError(`can't send peer info to pending peerId ${A}`);const t=this.makeForwardable(A,{discriminator:n.PeerSignalingInformation.discriminator,value:{id:g.connectionRequestId,type:e,data:I}}),i=n.GatewayDatagram.encode(t);this.socket.send(i)}sendOffer(A,e){o.RainwayLogging.debug("sending offer: "+e),this.sendPeerInfo(A,n.PeerInformationType.Offer,e)}sendAnswer(A,e){o.RainwayLogging.debug("sending offer: "+e),this.sendPeerInfo(A,n.PeerInformationType.Answer,e)}sendCandidate(A,e){o.RainwayLogging.debug("sending candidate"+e.candidate),this.sendPeerInfo(A,n.PeerInformationType.Candidate,e.candidate)}onNonFatalAlert(A,e){if(e===n.GatewayAlertDescription.PeerGoneAway)for(const[e,I]of this.connections.entries())I.pending&&I.syncKey===A&&(I.reject("The target peer is not connected to Rainway."),this.connections.delete(e))}onForwardable(A,e){const{targetPeerId:I,body:g}=e;switch(g.discriminator){case n.ConnectionRequest.discriminator:{const{sourcePeerId:e,sourceExternalId:I,desiredTransport:t,id:i,expirationDate:B}=g.value,C=i;this.peerIdToExternalId.set(e,I),this.connectionRequestHandler({peerId:e,externalId:g.value.sourceExternalId,accept:()=>{if(void 0===this.socket)throw new Q.RainwayError("Couldn't send accept message because the connection to Rainway was lost.");const g=n.GatewayDatagram.encode({header:{syncKey:A},body:{discriminator:n.GatewayForwardable.discriminator,value:{targetPeerId:e,body:{discriminator:n.AcceptedConnectionRequest.discriminator,value:{sourcePeerId:this.ownPeerId,sourceExternalId:this.externalId,id:i}}}}});this.socket.send(g),this.connections.set(e,{pending:!1,owned:!0,connectionRequestId:C}),this.addAcceptedPeer(e,I,C)},reject:I=>{if(void 0===this.socket)throw new Q.RainwayError("Couldn't send reject message because the connection to Rainway was lost.");const g=n.GatewayDatagram.encode({header:{syncKey:A},body:{discriminator:n.GatewayForwardable.discriminator,value:{targetPeerId:e,body:{discriminator:n.RejectedConnectionRequest.discriminator,value:{sourcePeerId:this.ownPeerId,sourceExternalId:this.externalId,id:i,reason:I}}}}});this.socket.send(g)}});break}case n.AcceptedConnectionRequest.discriminator:{const{id:A,sourcePeerId:e,sourceExternalId:I}=g.value,t=A,i=this.connections.get(e);if(void 0===i)return void o.RainwayLogging.warning("Ignoring AcceptedConnectionRequest from unexpected hostname: "+e);if(!i.pending)return void o.RainwayLogging.warning("Ignoring AcceptedConnectionRequest from already-connected hostname: "+e);i.resolve({canceled:!1,accepted:!0,connectionRequestId:t,hostExternalId:I,transportProtocol:n.PeerTransportType.SCTP}),this.connections.set(e,{pending:!1,owned:!1,promise:i.promise,connectionRequestId:t});break}case n.RejectedConnectionRequest.discriminator:{const{id:A,sourcePeerId:e,sourceExternalId:I}=g.value,t=A,i=this.connections.get(e);if(void 0===i)return void o.RainwayLogging.warning("Ignoring RejectedConnectionRequest from unexpected hostname: "+e);if(!i.pending)return void o.RainwayLogging.warning("Ignoring RejectedConnectionRequest from already-connected hostname: "+e);i.resolve({canceled:!1,accepted:!1,connectionRequestId:t,hostExternalId:I,transportProtocol:n.PeerTransportType.SCTP,reason:g.value.reason}),this.connections.delete(e);break}case n.PeerSignalingInformation.discriminator:o.RainwayLogging.trace("Got peer info:\n"+JSON.stringify(g.value)),this.handlePeerInfo(g.value)}}die(A,e){var I,g;null===(I=this.rejectConnectToGatewayPromise)||void 0===I||I.call(this,A),this.connectToGatewayPromise=void 0,this.resolveConnectToGatewayPromise=void 0,this.rejectConnectToGatewayPromise=void 0;for(const A of this.connections.values())A.pending&&A.reject(e);this.connections.clear(),null===(g=this.connectionLostEvent)||void 0===g||g.invoke(new Q.RainwayError(e))}unsetConnectToGatewayPromise(){this.connectToGatewayPromise=void 0,this.resolveConnectToGatewayPromise=void 0,this.rejectConnectToGatewayPromise=void 0}},g=new WeakMap},3643:function(A,e,I){"use strict";var g,t=this&&this.__awaiter||function(A,e,I,g){return new(I||(I=Promise))((function(t,i){function B(A){try{Q(g.next(A))}catch(A){i(A)}}function C(A){try{Q(g.throw(A))}catch(A){i(A)}}function Q(A){var e;A.done?t(A.value):(e=A.value,e instanceof I?e:new I((function(A){A(e)}))).then(B,C)}Q((g=g.apply(A,e||[])).next())}))};Object.defineProperty(e,"__esModule",{value:!0}),e.RainwayRateController=e.defaultRateControlParameters=e.QualityAdjustment=void 0;const i=I(198),B=I(2434),C=I(3464),Q=I(4009);var o;!function(A){A[A.Up=0]="Up",A[A.Down=1]="Down"}(o=e.QualityAdjustment||(e.QualityAdjustment={})),e.defaultRateControlParameters={beatMs:2500,windowMs:4500,badBeats:2,goodBeats:4,backoffFactor:2,latenessThresholdMs:200,latenessSmoothingFactor:.9375,badLateFrameRatio:.75,initialBitrateKbps:Number(null!==(g=new URLSearchParams(window.location.search).get("initial-bitrate"))&&void 0!==g?g:5e3),qualityStepFactor:1.1875},e.RainwayRateController=class{constructor(A=e.defaultRateControlParameters,I,g,C){this.chosenVideoConfig=I,this.performanceMonitor=C,this.badBeatCount=0,this.goodBeatCount=0,this.lastAdjustment=void 0,this.history=[],this.lowestDelta=void 0,this.smoothLateness=0,this.framesThisBeat=0,this.lateFramesThisBeat=0,this.debugLatenessSmoothing=!1,this.badCpuPerfThisBeat=!1,this.badDecoderPerfThisBeat=!1,this.badCpuPerfHandler=()=>{this.badCpuPerfThisBeat=!0},this.badDecoderPerfHandler=()=>{this.badDecoderPerfThisBeat=!0},this.handleVideoReadyState=A=>{A===B.VideoReadyState.Detached||A===B.VideoReadyState.Paused||A===B.VideoReadyState.WaitingForKeyframe?this.stop():this.start()},this.check=()=>t(this,void 0,void 0,(function*(){0!==this.framesThisBeat&&((yield this.beatIsBad())?this.badBeat():this.goodBeat(),this.framesThisBeat=0,this.lateFramesThisBeat=0,this.badCpuPerfThisBeat=!1,this.badDecoderPerfThisBeat=!1)})),this.ownMaximumKbps=1/0,this.chosenVideoConfigMimeType=Q.videoCodecMimeType(I.codec),this.parameters=Object.assign(Object.assign({},e.defaultRateControlParameters),A),this.suggestBitrateKbps=g,this.currentBitrateKbps=this.parameters.initialBitrateKbps,this.frameVarianceMs=new i.WindowTrack(this.parameters.windowMs,i.standardDeviation)}format(A){return`[RateControl: ${this.currentBitrateKbps.toFixed(0)+"kbps"}, +${this.smoothLateness.toFixed(0)}ms] ${A}`}debug(A){C.RainwayLogging.debug(this.format(A))}info(A){C.RainwayLogging.information(this.format(A))}start(){var A,e;this.checkInterval||(this.info("Starting rate control!"),this.checkInterval=window.setInterval(this.check,this.parameters.beatMs),null===(A=this.performanceMonitor)||void 0===A||A.cpuStarvationEvent.addHandler(this.badCpuPerfHandler),null===(e=this.performanceMonitor)||void 0===e||e.decoderStrugglingEvent.addHandler(this.badDecoderPerfHandler))}stop(){var A,e;this.checkInterval&&(this.info("Stopping rate control!"),window.clearInterval(this.checkInterval),this.checkInterval=void 0,null===(A=this.performanceMonitor)||void 0===A||A.cpuStarvationEvent.removeHandler(this.badCpuPerfHandler),null===(e=this.performanceMonitor)||void 0===e||e.decoderStrugglingEvent.removeHandler(this.badDecoderPerfHandler))}feedFrameTimestamp(A){const e=performance.now()-A;(void 0===this.lowestDelta||e<this.lowestDelta||Math.abs(this.lowestDelta-e)>5e4)&&(this.lowestDelta=e);const I=e-this.lowestDelta,g=this.parameters.latenessSmoothingFactor;if(this.smoothLateness=g*this.smoothLateness+(1-g)*I,this.framesThisBeat++,this.smoothLateness>=this.parameters.latenessThresholdMs&&this.lateFramesThisBeat++,this.debugLatenessSmoothing){const A=new Array(100);A.fill("-");const e=I,g=this.smoothLateness;A[50]=".",A[Math.max(0,Math.min(Math.round(e/10+50),99))]="L",A[Math.max(0,Math.min(Math.round(g/10+50),99))]="S",this.beatIsBad().then((I=>C.RainwayLogging.debug(`${A.join("")} L=${e} S=${g} bad=${I} ld=${this.lowestDelta}`)))}}decodingInfoAtBitrate(A){return navigator.mediaCapabilities.decodingInfo({type:"media-source",video:{width:this.chosenVideoConfig.codec.width,height:this.chosenVideoConfig.codec.height,framerate:this.chosenVideoConfig.codec.refreshRate,bitrate:1e3*A,contentType:Q.videoCodecMimeType(this.chosenVideoConfig.codec)}})}capabilitiesBad(){return t(this,void 0,void 0,(function*(){if(!("MediaSource"in window))return!1;if(!("mediaCapabilities"in navigator))return!1;const A=yield this.decodingInfoAtBitrate(this.currentBitrateKbps),e=yield this.decodingInfoAtBitrate(this.bitrateOneStepDownKbps());return e.smooth&&!A.smooth||e.powerEfficient&&!A.powerEfficient}))}lateFrameRatioBad(){return this.lateFramesThisBeat/this.framesThisBeat>=this.parameters.badLateFrameRatio}beatIsBad(){return t(this,void 0,void 0,(function*(){return this.badDecoderPerfThisBeat||this.badCpuPerfThisBeat||this.lateFrameRatioBad()||(yield this.capabilitiesBad())}))}badBeat(){if(this.currentBitrateKbps<=this.lowestSupportedBitrateKbps())return void this.debug(`crashed at ${this.currentBitrateKbps.toFixed(0)}kbps, ignoring bad beat`);this.badBeatCount++,this.goodBeatCount=0,this.currentBitrateKbps;const A=this.parameters.badBeats;if(this.debug(`bad beat: ${this.badBeatCount}/${A}`),this.badBeatCount>=this.parameters.badBeats){this.goodBeatCount=this.badBeatCount=0;const A=this.lastAdjustment===o.Up;this.qualityDown(),this.debug("went down in quality"),A&&this.currentBitrateKbps<this.ownMaximumKbps&&(this.ownMaximumKbps=this.currentBitrateKbps,this.info(`setting a new maximum at ${this.ownMaximumKbps.toFixed(0)}kbps`))}}goodBeat(){if(this.currentBitrateKbps>=this.ownMaximumKbps||this.currentBitrateKbps>=this.highestSupportedBitrateKbps())return this.debug(`maxed at ${this.currentBitrateKbps.toFixed(0)}kbps, ignoring good beat`),void(this.badBeatCount=0);this.goodBeatCount++,this.badBeatCount=0,this.currentBitrateKbps;const A=this.parameters.goodBeats;this.debug(`good beat: ${this.goodBeatCount}/${A}`),this.goodBeatCount>=A&&(this.goodBeatCount=this.badBeatCount=0,this.qualityUp(),this.debug("went up in quality"))}bitrateOneStepUpKbps(){return Math.min(this.highestSupportedBitrateKbps(),this.currentBitrateKbps*this.parameters.qualityStepFactor)}bitrateOneStepDownKbps(){return Math.max(this.lowestSupportedBitrateKbps(),this.currentBitrateKbps/this.parameters.qualityStepFactor)}qualityUp(){this.currentBitrateKbps=this.bitrateOneStepUpKbps(),this.suggestBitrateKbps(this.currentBitrateKbps),this.lastAdjustment=o.Up,this.history.push({time:performance.now(),bitrate:this.currentBitrateKbps})}qualityDown(){this.currentBitrateKbps=this.bitrateOneStepDownKbps(),this.suggestBitrateKbps(this.currentBitrateKbps),this.lastAdjustment=o.Down,this.history.push({time:performance.now(),bitrate:this.currentBitrateKbps}),this.lowestDelta=void 0}lowestSupportedBitrateKbps(){var A;return Number(null!==(A=new URLSearchParams(window.location.search).get("lowest-bitrate"))&&void 0!==A?A:5e3)}highestSupportedBitrateKbps(){var A;return Number(null!==(A=new URLSearchParams(window.location.search).get("max-bitrate"))&&void 0!==A?A:1e4)}}},3145:function(A,e,I){"use strict";var g,t=this&&this.__awaiter||function(A,e,I,g){return new(I||(I=Promise))((function(t,i){function B(A){try{Q(g.next(A))}catch(A){i(A)}}function C(A){try{Q(g.throw(A))}catch(A){i(A)}}function Q(A){var e;A.done?t(A.value):(e=A.value,e instanceof I?e:new I((function(A){A(e)}))).then(B,C)}Q((g=g.apply(A,e||[])).next())}))},i=this&&this.__classPrivateFieldSet||function(A,e,I){if(!e.has(A))throw new TypeError("attempted to set private field on non-instance");return e.set(A,I),I},B=this&&this.__classPrivateFieldGet||function(A,e){if(!e.has(A))throw new TypeError("attempted to get private field on non-instance");return e.get(A)};Object.defineProperty(e,"__esModule",{value:!0}),e.RTCTransport=void 0;const C=I(2994),Q=I(9009),o=I(3464),n=I(6904),a=I(9987),r=I(5420),E=I(7783),s={iceServers:[{urls:"stun:stun.rainway.com:3478"}]};class d extends Q.RainwayTransport{constructor(A,e,I,t,B,a){super(),this.ownPeerId=A,this.targetPeerId=e,this.sendLocalOfferSdp=I,this.sendLocalAnswerSdp=t,this.sendLocalIceCandidate=B,this.reportStateChange=a,g.set(this,Q.RainwayTransportStatus.Disconnected),this.rtcConfiguration=s,this.dataChannelsConfig={},this.syncKey=0,this.onRainwayMessage=()=>{},this.onApplicationMessage=()=>{},this.onClose=()=>{},this.handlePeerInfo=A=>{var e,I,g;if(A.type===n.PeerInformationType.Answer)o.RainwayLogging.debug("Got Answer in CRID "+A.id+"\n"+A.data),null===(e=this.peerConnection)||void 0===e||e.setRemoteDescription({type:"answer",sdp:A.data});else if(A.type===n.PeerInformationType.Offer)o.RainwayLogging.debug("Got Offer in CRID "+A.id+"\n"+A.data),null===(I=this.peerConnection)||void 0===I||I.setRemoteDescription({type:"offer",sdp:A.data}),this.sendAnswer();else{if(A.type!==n.PeerInformationType.Candidate){const e=n.PeerInformationType[A.type];throw new C.RainwayError(`unexpected PeerInformationType ${e} in handlePeerInfo`)}o.RainwayLogging.debug("Got Candidate in CRID "+A.id+"\n"+A.data),null===(g=this.peerConnection)||void 0===g||g.addIceCandidate(new RTCIceCandidate({candidate:A.data,sdpMid:"",sdpMLineIndex:0}))}},this.handleLocalIceCandidate=A=>{A.candidate&&"1"===A.candidate.candidate.split(" ")[1]&&this.sendLocalIceCandidate(A.candidate)},this.handleIceConnectionStateChange=()=>{if(!this.peerConnection)return;const A=this.peerConnection.iceConnectionState;o.RainwayLogging.information(`ICE connection state changed to ${A}`)},this.handleConnectionStateChange=()=>{var A;if(!this.peerConnection)return;const e=this.peerConnection.connectionState;o.RainwayLogging.information(`Connection state changed to ${e}`),"closed"===e||"failed"===e?(this.reportStateChange(E.RainwayPeerState.Failed),null===(A=this.openReject)||void 0===A||A.call(this),this.onClose(),i(this,g,Q.RainwayTransportStatus.Disconnected),this.dispose()):"disconnected"===e?this.reportStateChange(E.RainwayPeerState.Disconnected):"connecting"===e?this.reportStateChange(E.RainwayPeerState.Connecting):"connected"===e?this.reportStateChange(E.RainwayPeerState.Connected):"new"===e&&this.reportStateChange(E.RainwayPeerState.New)},this.handleDataChannelMessage=A=>{const e=A.target.label;this.handleLabelAndData(e,new Uint8Array(A.data))},this.handleDataChannelClose=A=>{const e=A.target.label;o.RainwayLogging.warning("RTC channel closed: "+e)},this.handleDataChannelError=A=>{const e=A.target.label;o.RainwayLogging.warning("RTC channel errored: "+e)},this.chunkedMessages=new Map,this.highestChunkGroup=0;const r={protocol:"sctp",negotiated:!1},d={ordered:!1,maxRetransmits:0};this.dataChannelsConfig={RW_Logic:Object.assign(Object.assign({id:0},r),{ordered:!0}),RW_Video:Object.assign(Object.assign({id:1},r),d),RW_Audio:Object.assign(Object.assign({id:2},r),d),RW_Input:Object.assign(Object.assign({id:3},r),d)}}createDataChannel(A,e){var I,g;return t(this,void 0,void 0,(function*(){const t={protocol:"sctp",negotiated:!1},i=null===(I=this.peerConnection)||void 0===I?void 0:I.createDataChannel(A,e===r.RainwayChannelMode.Reliable?Object.assign(Object.assign({},t),{ordered:!0}):Object.assign(Object.assign({},t),{ordered:!1,maxRetransmits:0}));if(!i)throw new C.RainwayError("Couldn't create Data Channel: "+A);return i.addEventListener("close",this.handleDataChannelClose),i.addEventListener("error",this.handleDataChannelError),i.addEventListener("message",this.handleDataChannelMessage),null!==(g=this.dataChannels)&&void 0!==g||(this.dataChannels={}),this.dataChannels[A]=i,new Promise((A=>{const e=()=>{A(),i.removeEventListener("open",e)};i.addEventListener("open",e)}))}))}sendMessage(A,e){var I;if(!A)throw new C.RainwayError("sendMessage: no label");if(!this.dataChannels)throw new C.RainwayError("sendMessage: dataChannels not initialized");const g=null===(I=this.dataChannels)||void 0===I?void 0:I[A];if(!g)throw new C.RainwayError(`sendMessage: channel "${A}" does not exist`);if("open"!==g.readyState)throw new C.RainwayError(`sendMessage: channel "${A}" is not open`);g.send(e)}get status(){return B(this,g)}get maxMessageSize(){var A,e,I;return null!==(I=null===(e=null===(A=this.peerConnection)||void 0===A?void 0:A.sctp)||void 0===e?void 0:e.maxMessageSize)&&void 0!==I?I:262144}getStats(){return t(this,void 0,void 0,(function*(){if(!this.peerConnection)throw new C.RainwayError("getStats() but no peerConnection");const A=yield this.peerConnection.getStats(void 0),e={channels:{},raw:A};return A.forEach((A=>{"data-channel"===A.type&&(e.channels[A.label]=A)})),e}))}checkHeader(A){if(2036430674!==A.magicNumber)throw new C.RainwayError("Invalid magicNumber in checkHeader.");if(A.targetPeerId!==this.ownPeerId)throw new C.RainwayError("Invalid destination host name (not ours) in checkHeader.")}handleLabelAndData(A,e){if("RW_Logic"===A){const A=n.LogicDatagram.decode(e);this.checkHeader(A.header),this.onRainwayMessage({kind:"Logic",body:A.body})}else if("RW_Input"===A){const A=n.InputDatagram.decode(e);this.checkHeader(A.header),this.onRainwayMessage({kind:"Input",body:A.body})}else if("RW_Audio"===A||"RW_Video"==A){const I=n.MediaDatagram.decode(e);this.checkHeader(I.header),I.body.discriminator===n.MediaChunk.discriminator?this.handleChunk(A,I.body.value.chunk):this.onRainwayMessage({kind:"Media",body:I.body})}else if(/^RW_/.test(A))o.RainwayLogging.warning(`Unknown Rainway-reserved RTC label? ${A}`);else{const I=n.ArbitraryDatagram.decode(e);this.checkHeader(I.header),this.handleChunk(A,I.body)}}getDatagramHeader(A){return{magicNumber:2036430674,syncKey:A?++this.syncKey:0,sourcePeerId:this.ownPeerId,targetPeerId:this.targetPeerId}}sendArbitraryDatagram(A,e){a.eachChunk(e,(e=>{this.sendMessage(A,n.ArbitraryDatagram.encode({header:this.getDatagramHeader(!0),body:e}))}))}sendLogicDatagram(A){this.sendMessage("RW_Logic",n.LogicDatagram.encode({header:this.getDatagramHeader(!0),body:A}))}sendInputDatagram(A){this.sendMessage("RW_Input",n.InputDatagram.encode({header:this.getDatagramHeader(!1),body:A}))}open(A){return t(this,void 0,void 0,(function*(){yield new Promise(((e,I)=>t(this,void 0,void 0,(function*(){var t;this.openResolve=e,this.openReject=I,i(this,g,Q.RainwayTransportStatus.Connecting),this.peerConnection=new RTCPeerConnection(this.rtcConfiguration),this.peerConnection.addEventListener("iceconnectionstatechange",this.handleIceConnectionStateChange),this.peerConnection.addEventListener("connectionstatechange",this.handleConnectionStateChange),this.handleConnectionStateChange(),null!==(t=this.dataChannels)&&void 0!==t||(this.dataChannels={});const B=Object.keys(this.dataChannelsConfig).length;let C=0;const o=(A,I)=>{const t=()=>{var A;++C,C===B&&(null===(A=this.peerConnection)||void 0===A||A.removeEventListener("icecandidate",this.handleLocalIceCandidate),i(this,g,Q.RainwayTransportStatus.Connected),e()),I.removeEventListener("open",t)};I.addEventListener("open",t),I.addEventListener("close",this.handleDataChannelClose),I.addEventListener("error",this.handleDataChannelError),I.addEventListener("message",this.handleDataChannelMessage)};if("offer"===A)for(const[A,e]of Object.entries(this.dataChannelsConfig)){const I=this.peerConnection.createDataChannel(A,e);this.dataChannels[A]=I,I.binaryType="arraybuffer",o(0,I)}else this.peerConnection.addEventListener("datachannel",(A=>{var e;const I=A.channel.label;null!==(e=this.dataChannels)&&void 0!==e||(this.dataChannels={}),this.dataChannels[I]=A.channel,o(A.channel.label,A.channel)}));this.peerConnection.addEventListener("icecandidate",this.handleLocalIceCandidate),"offer"===A&&(yield this.sendOffer())}))))}))}sendOffer(){return t(this,void 0,void 0,(function*(){if(void 0===this.peerConnection)throw new C.RainwayError("sendOffer(): no peer connection");const A=yield this.peerConnection.createOffer();if(yield this.peerConnection.setLocalDescription(A),!A.sdp)throw new C.RainwayError("Created offer contained no sdp?");this.sendLocalOfferSdp(A.sdp)}))}sendAnswer(){return t(this,void 0,void 0,(function*(){if(void 0===this.peerConnection)throw new C.RainwayError("sendOffer(): no peer connection");const A=yield this.peerConnection.createAnswer();if(yield this.peerConnection.setLocalDescription(A),!A.sdp)throw new C.RainwayError("Created answer contained no sdp?");this.sendLocalAnswerSdp(A.sdp)}))}close(){var A;this.status!==Q.RainwayTransportStatus.Disconnected&&(o.RainwayLogging.debug("rtc-transport close()."),null===(A=this.peerConnection)||void 0===A||A.close(),this.onClose(),this.dispose())}dispose(){var A,e,I;if(null===(A=this.peerConnection)||void 0===A||A.removeEventListener("iceconnectionstatechange",this.handleIceConnectionStateChange),null===(e=this.peerConnection)||void 0===e||e.removeEventListener("connectionstatechange",this.handleConnectionStateChange),null===(I=this.peerConnection)||void 0===I||I.removeEventListener("icecandidate",this.handleLocalIceCandidate),this.dataChannels)for(const A of Object.values(this.dataChannels))A.removeEventListener("message",this.handleDataChannelMessage);this.dataChannels=void 0,this.peerConnection=void 0,this.openResolve=void 0,this.openReject=void 0}handleChunk(A,e){e.groupId<this.highestChunkGroup&&(this.chunkedMessages=new Map,this.highestChunkGroup=0);let I=this.chunkedMessages.get(e.groupId);if(I||(I={receivedChunkCount:0,chunks:[]},this.chunkedMessages.set(e.groupId,I)),I.chunks[e.index]=e.data,I.receivedChunkCount++,I.receivedChunkCount===e.chunksInGroup){this.highestChunkGroup=e.groupId,this.chunkedMessages.delete(e.groupId);const g=a.reassemble(I);/^RW_(Logic|Input|Audio|Video)$/.test(A)?this.handleLabelAndData(A,g):this.onApplicationMessage(A,g)}}}e.RTCTransport=d,g=new WeakMap},9009:(A,e)=>{"use strict";var I;Object.defineProperty(e,"__esModule",{value:!0}),e.RainwayTransport=e.RainwayTransportStatus=void 0,(I=e.RainwayTransportStatus||(e.RainwayTransportStatus={}))[I.Disconnected=0]="Disconnected",I[I.Connecting=1]="Connecting",I[I.Connected=2]="Connected",e.RainwayTransport=class{}},5420:function(A,e,I){"use strict";var g,t,i,B,C=this&&this.__awaiter||function(A,e,I,g){return new(I||(I=Promise))((function(t,i){function B(A){try{Q(g.next(A))}catch(A){i(A)}}function C(A){try{Q(g.throw(A))}catch(A){i(A)}}function Q(A){var e;A.done?t(A.value):(e=A.value,e instanceof I?e:new I((function(A){A(e)}))).then(B,C)}Q((g=g.apply(A,e||[])).next())}))},Q=this&&this.__classPrivateFieldSet||function(A,e,I){if(!e.has(A))throw new TypeError("attempted to set private field on non-instance");return e.set(A,I),I},o=this&&this.__classPrivateFieldGet||function(A,e){if(!e.has(A))throw new TypeError("attempted to get private field on non-instance");return e.get(A)};Object.defineProperty(e,"__esModule",{value:!0}),e.RainwayPeer=e.RainwayChannelMode=void 0;const n=I(6904),a=I(2824),r=I(3464),E=I(8514),s=I(7783),d=I(3876),c=I(2994);var h;(h=e.RainwayChannelMode||(e.RainwayChannelMode={}))[h.Unreliable=0]="Unreliable",h[h.Reliable=1]="Reliable";class D{constructor(A,e,I,C,o,n,a){this.transport=I,this.outerOnClose=C,this.onError=o,this.onStreamAnnouncement=n,this.onStreamStop=a,g.set(this,s.RainwayPeerState.New),t.set(this,new Map),i.set(this,void 0),B.set(this,void 0),this.lastTimestamp=void 0,Q(this,i,A),Q(this,B,e),I.onRainwayMessage=this.onMessage.bind(this),I.onClose=this.onClose.bind(this),this.readyToStream=new Promise(((A,e)=>{this.resolveReadyToStream=A}))}get state(){return o(this,g)}get disconnected(){return this.state===s.RainwayPeerState.Disconnected||this.state===s.RainwayPeerState.Failed}get stream(){const A=[...o(this,t).entries()];if(0!==A.length)return A.sort(((A,e)=>A[0]-e[0])),A[0][1]}get streams(){return o(this,t)}get peerId(){return o(this,i)}get externalId(){return o(this,B)}onClose(){this.onPeerStateChange(s.RainwayPeerState.Failed)}onPeerStateChange(A){Q(this,g,A),A===s.RainwayPeerState.Failed&&(this.dispose(),this.outerOnClose())}sendDeviceInfoAndExchangeCodecs(){if(this.disconnected)throw new c.RainwayError("Couldn't send device info and exchange codecs: peer is disconnected");this.sendDeviceInfo(),this.exchangeCodecs().then((A=>{var e,I;0===A.length?null===(e=this.resolveReadyToStream)||void 0===e||e.call(this,!1):(this.transport.sendLogicDatagram({discriminator:n.ClientCapabilities.discriminator,value:E.makeClientCapabilities(A)}),null===(I=this.resolveReadyToStream)||void 0===I||I.call(this,!0))}))}onMessage(A){"Logic"===A.kind?this.handleLogicMessage(A.body):"Input"===A.kind?this.handleInputMessage(A.body):"Media"===A.kind&&this.handleMediaMessage(A.body)}sendDeviceInfo(){if(this.disconnected)throw new c.RainwayError("Couldn't send device info: peer is disconnected");this.transport.sendLogicDatagram({discriminator:n.DeviceInfo.discriminator,value:{isWeb:!0,formFactor:n.FormFactor.Computer,deviceName:"deviceName",deviceId:"deviceId",deviceModel:"",deviceOs:n.OperatingSystem.Other,deviceOsVersion:"",userAgent:navigator.userAgent}})}send(A,e){if(A.startsWith("RW_"))throw new c.RainwayError("Data channel names starting with RW_ are reserved for Rainway");if(this.disconnected)throw new c.RainwayError("Couldn't send message: peer is disconnected");const I="string"==typeof e?D.textEncoder.encode(e):e;this.transport.sendArbitraryDatagram(A,I)}disconnect(){this.dispose(),this.transport.close()}dispose(){for(const A of o(this,t).values())A.leave();o(this,t).clear()}requestStream(A){return C(this,void 0,void 0,(function*(){if(this.disconnected)throw new c.RainwayError("Couldn't request stream: peer is disconnected");return yield this.readyToStream,yield this.exchangeCodecs().then((A=>{if(0===A.length)throw new Error("Unable to re-negotiate codecs");this.transport.sendLogicDatagram({discriminator:n.ClientCapabilities.discriminator,value:E.makeClientCapabilities(A)})})),this.transport.sendLogicDatagram({discriminator:n.StreamRequest.discriminator,value:{inputLevel:A}}),new Promise(((A,e)=>{this.resolveStream=A,this.rejectStream=e}))}))}handleLogicMessage(A){var e;return C(this,void 0,void 0,(function*(){if(A.discriminator===n.DeviceInfo.discriminator)r.RainwayLogging.debug("Got remote DeviceInfo:\n"+JSON.stringify(A.value));else if(A.discriminator===n.CodecPackRequest.discriminator)this.transport.sendLogicDatagram({discriminator:n.CodecPackResponse.discriminator,value:{videoCodecs:[]}});else if(A.discriminator===n.CodecPackResponse.discriminator)null===(e=this.codecsResolve)||void 0===e||e.call(this,A.value.videoCodecs);else if(A.discriminator===n.ClientCapabilities.discriminator)r.RainwayLogging.debug("Got remote ClientCapabilities:\n"+JSON.stringify(A.value));else if(A.discriminator===n.StreamRequest.discriminator)r.RainwayLogging.warning("Got remote StreamRequest?\n"+JSON.stringify(A.value));else if(A.discriminator===n.StreamAnnouncement.discriminator)if(void 0!==this.resolveStream){const e=yield this.createStream(A.value.streamInfo);o(this,t).set(e.streamId,e),this.transport.sendLogicDatagram({discriminator:n.JoinStream.discriminator,value:{streamId:A.value.streamInfo.streamId}}),this.resolveStream(e),this.resolveStream=void 0,this.rejectStream=void 0}else this.onStreamAnnouncement({info:A.value.streamInfo,join:()=>C(this,void 0,void 0,(function*(){console.log("Joining stream");const e=yield this.createStream(A.value.streamInfo);return o(this,t).set(e.streamId,e),this.transport.sendLogicDatagram({discriminator:n.JoinStream.discriminator,value:{streamId:A.value.streamInfo.streamId}}),this.resolveStream=void 0,this.rejectStream=void 0,e}))});else A.discriminator===n.RejectStreamRequest.discriminator?void 0!==this.rejectStream?(this.rejectStream(A.value.reason),this.resolveStream=void 0,this.rejectStream=void 0):r.RainwayLogging.warning("Got RejectStreamRequest, but didn't ask for a stream."):A.discriminator===n.LeaveStream.discriminator?r.RainwayLogging.warning("Got remote LeaveStream?\n"+JSON.stringify(A.value)):A.discriminator===n.StreamStopping.discriminator&&(r.RainwayLogging.debug("Got remote StreamStopping:\n"+JSON.stringify(A.value)),this.discardStream(A.value.streamId))}))}createStream(A){return d.RainwayStream.createAndInitialize(this,A.streamId,A.defaultInputLevel,A.chosenAudioConfig,A.chosenVideoConfig,A.streamType,(e=>this.transport.sendInputDatagram({streamId:A.streamId,inner:e})),(A=>this.transport.sendLogicDatagram(A)),(()=>this.transport.getStats()),(()=>this.discardStream(A.streamId)))}discardStream(A){const e=o(this,t).get(A);void 0!==e&&this.onStreamStop(e),o(this,t).delete(A)}handleInputMessage(A){var e;const I=A.inner;if(I.discriminator===n.GamepadRumble.discriminator){const A=I.value.leftMotorSpeed,e=I.value.rightMotorSpeed;a.RainwayInputManager.vibrateGamepad(I.value.port,{duration:100,startDelay:0,strongMagnitude:Math.max(A,e)/65535,weakMagnitude:0})}else if(I.discriminator===n.SetClipboardText.discriminator){const A=I.value.text;"function"==typeof(null===(e=null===navigator||void 0===navigator?void 0:navigator.clipboard)||void 0===e?void 0:e.writeText)&&navigator.clipboard.writeText(A).then((()=>{}))}else r.RainwayLogging.warning(`Ignoring unrecognized Input discriminator ${I.discriminator}`)}handleMediaMessage(A){if(A.discriminator===n.VideoData.discriminator){const{data:e,segmentTime:I,type:g,desktopRect:i,mask:B,streamId:C}=A.value,Q=o(this,t).get(C);if(!Q)return;const a=e.buffer.slice(e.byteOffset,e.byteOffset+e.length),E=1e-4*Number(I);g===n.VideoDataType.FrameDiff&&void 0!==this.lastTimestamp&&E-this.lastTimestamp<3&&r.RainwayLogging.warning(`Difference between successive timestamps was ${(E-this.lastTimestamp).toFixed(1)}`),g!==n.VideoDataType.Metadata&&(this.lastTimestamp=E),Q.renderVideoFrame({timestamp:E,x:i.left,y:i.top,width:i.width,height:i.height,mask:B},a)}else if(A.discriminator===n.PointerData.discriminator){const e=o(this,t).get(A.value.streamId);if(!e)return;e.processCursor({x:A.value.positionX,y:A.value.positionY,spotX:A.value.spotX,spotY:A.value.spotY,shapeWidth:A.value.shapeWidth,shapeHeight:A.value.shapeHeight,extentWidth:A.value.monitorWidth,extentHeight:A.value.monitorHeight,visible:A.value.visible,hasPointerImage:A.value.data.length>0,pointerImage:A.value.data})}else if(A.discriminator===n.AudioData.discriminator){const e=o(this,t).get(A.value.streamId);if(!e)return;const{data:I,type:g}=A.value,i=I.buffer.slice(I.byteOffset,I.byteOffset+I.length);e.processAudio(i)}}exchangeCodecs(){return C(this,void 0,void 0,(function*(){if(this.disconnected)throw new c.RainwayError("Couldn't exchange codecs: peer is disconnected");const A=yield new Promise((A=>{this.transport.sendLogicDatagram({discriminator:n.CodecPackRequest.discriminator,value:{}}),this.codecsResolve=A}));return this.codecsResolve=void 0,A}))}createDataChannel(A,e){return C(this,void 0,void 0,(function*(){if(A.startsWith("RW_"))throw new c.RainwayError("Data channel names starting with RW_ are reserved for Rainway");return this.transport.createDataChannel(A,e)}))}listStreams(){return C(this,void 0,void 0,(function*(){if(this.disconnected)throw new c.RainwayError("Couldn't list streams. Peer disconnected.");this.transport.sendLogicDatagram({discriminator:n.ListStreams.discriminator,value:{}})}))}}e.RainwayPeer=D,g=new WeakMap,t=new WeakMap,i=new WeakMap,B=new WeakMap,D.textEncoder=new TextEncoder},7783:function(A,e,I){"use strict";var g,t,i,B,C,Q,o=this&&this.__awaiter||function(A,e,I,g){return new(I||(I=Promise))((function(t,i){function B(A){try{Q(g.next(A))}catch(A){i(A)}}function C(A){try{Q(g.throw(A))}catch(A){i(A)}}function Q(A){var e;A.done?t(A.value):(e=A.value,e instanceof I?e:new I((function(A){A(e)}))).then(B,C)}Q((g=g.apply(A,e||[])).next())}))},n=this&&this.__classPrivateFieldSet||function(A,e,I){if(!e.has(A))throw new TypeError("attempted to set private field on non-instance");return e.set(A,I),I},a=this&&this.__classPrivateFieldGet||function(A,e){if(!e.has(A))throw new TypeError("attempted to get private field on non-instance");return e.get(A)};Object.defineProperty(e,"__esModule",{value:!0}),e.RainwayRuntime=e.RainwayPeerState=void 0;const r=I(9104),E=I(2994),s=I(3464),d=I(3145),c=I(6904),h=I(5420);var D;null!==(g=(i=DataView.prototype).setBigUint64)&&void 0!==g||(i.setBigUint64=function(A,e,I){const g=BigInt(4294967295),t=Number(e>>BigInt(32)&g),i=Number(e&g),[B,C]=I?[4,0]:[0,4];this.setUint32(A+B,t,I),this.setUint32(A+C,i,I)}),null!==(t=(B=DataView.prototype).getBigUint64)&&void 0!==t||(B.getBigUint64=function(A,e){const[I,g]=e?[4,0]:[0,4],t=BigInt(this.getUint32(A+I,e)),i=BigInt(this.getUint32(A+g,e));return t<<BigInt(32)|i}),function(A){A[A.New=0]="New",A[A.Connecting=1]="Connecting",A[A.Connected=2]="Connected",A[A.Disconnected=3]="Disconnected",A[A.Failed=4]="Failed"}(D=e.RainwayPeerState||(e.RainwayPeerState={}));class u{constructor(A,e){var I;C.set(this,void 0),Q.set(this,new Map),this.connectionTransports=new Map,this.documentVisibilityChangeHandler=()=>{if(document.hidden)for(const A of this.peers.values())for(const e of A.streams.values())e.releaseKeys(),e.pause();else for(const A of this.peers.values())for(const e of A.streams.values())e.play()},this.windowBlurHandler=()=>{for(const A of this.peers.values())for(const e of A.streams.values())e.releaseKeys()},this.beforeUnloadHandler=A=>{const e=location.hash;return[...this.peers.values()].some((A=>A.streams.size>0))&&(setTimeout((()=>{location.hash="?hj="+~~(9999*Math.random()),location.hash=e}),0),A.preventDefault(),A.returnValue=""),!1},n(this,C,A),this.config=e,this.config.logSink&&this.setLogSink(this.config.logSink),this.gateway=new r.Gateway(a(this,C),this.config.apiKey,null!==(I=this.config.externalId)&&void 0!==I?I:"",(A=>this.handlePeerInfo(A)),(A=>{var e,I;return null===(I=(e=this.config).onConnectionRequest)||void 0===I?void 0:I.call(e,this,A)}),((A,e,I)=>this.addPeer(A,e,I,"answer"))),this.gateway.connectionLostEvent.addHandler((A=>{var e,I;null===(I=(e=this.config).onRuntimeConnectionLost)||void 0===I||I.call(e,this,A),this.disconnectAllPeers()}))}get peers(){return[...a(this,Q).values()]}static initialize(A){return o(this,void 0,void 0,(function*(){if(u.initialized)throw new E.RainwayError("RainwayRuntime may only be initialized once. Don't worry: you can manage multiple Rainway connections from a single RainwayRuntime object.");const e=yield r.getPeerId(A.apiKey),I=new u(e,A);return yield I.gateway.connect(),I.addListeners(),u.initialized=!0,I}))}getPeerId(){return a(this,C)}connect(A){return o(this,void 0,void 0,(function*(){if(yield this.gateway.connect(),a(this,Q).has(A))throw new E.RainwayError(`Already connected to ${A}`);const e=yield this.gateway.connectToHost(A,c.PeerTransportType.SCTP);if(e.canceled)throw new E.RainwayError("The connection attempt was canceled.");if(!e.accepted)throw new E.RainwayError(`The peer at ${A} rejected the connection, with reason: ${e.reason}`);return this.addPeer(A,e.hostExternalId,e.connectionRequestId,"offer")}))}addPeer(A,e,I,g){var t,i;return o(this,void 0,void 0,(function*(){const B=new d.RTCTransport(a(this,C),A,(e=>this.gateway.sendOffer(A,e)),(e=>this.gateway.sendAnswer(A,e)),(e=>this.gateway.sendCandidate(A,e)),(A=>{var e,I;o.onPeerStateChange(A),null===(I=(e=this.config).onPeerStateChange)||void 0===I||I.call(e,this,o,A)})),o=new h.RainwayPeer(A,e,B,(()=>{this.gateway.deleteConnection(A),a(this,Q).delete(A)}),(A=>{var e,I;null===(I=(e=this.config).onPeerError)||void 0===I||I.call(e,this,o,A)}),(A=>{var e,I;null===(I=(e=this.config).onStreamAnnouncement)||void 0===I||I.call(e,this,o,A)}),(A=>{var e,I;null===(I=(e=this.config).onStreamStop)||void 0===I||I.call(e,this,A)}));this.connectionTransports.set(I,B),B.onApplicationMessage=(A,e)=>{var I,g;return null===(g=(I=this.config).onPeerMessage)||void 0===g?void 0:g.call(I,this,o,A,e)};try{yield B.open(g)}finally{this.connectionTransports.delete(I)}return o.sendDeviceInfoAndExchangeCodecs(),a(this,Q).set(A,o),null===(i=(t=this.config).onPeerStateChange)||void 0===i||i.call(t,this,o,D.Connected),o}))}cancelConnectionAttempt(A){this.gateway.cancelConnectionAttempt(A)}handlePeerInfo(A){const e=this.connectionTransports.get(A.id);void 0!==e?e.handlePeerInfo(A):A.type!==c.PeerInformationType.Candidate&&s.RainwayLogging.warning("Got peer info for unexpected CRID? "+A.id)}getMediaCapabilities(A){return navigator.mediaCapabilities.decodingInfo(A)}setLogSink(A){s.RainwayLogging.setLogSink(A)}disconnectAllPeers(){for(const A of a(this,Q).values())A.disconnect();a(this,Q).clear()}addListeners(){window.addEventListener("beforeunload",this.beforeUnloadHandler.bind(this)),window.addEventListener("blur",this.windowBlurHandler),document.addEventListener("visibilitychange",this.documentVisibilityChangeHandler)}removeListeners(){window.removeEventListener("beforeunload",this.beforeUnloadHandler.bind(this)),window.removeEventListener("blur",this.windowBlurHandler),document.removeEventListener("visibilitychange",this.documentVisibilityChangeHandler)}dispose(){this.disconnectAllPeers(),this.connectionTransports.clear(),this.gateway.disconnect(),this.removeListeners(),u.initialized=!1}}e.RainwayRuntime=u,C=new WeakMap,Q=new WeakMap,u.initialized=!1},3876:function(A,e,I){"use strict";var g,t=this&&this.__awaiter||function(A,e,I,g){return new(I||(I=Promise))((function(t,i){function B(A){try{Q(g.next(A))}catch(A){i(A)}}function C(A){try{Q(g.throw(A))}catch(A){i(A)}}function Q(A){var e;A.done?t(A.value):(e=A.value,e instanceof I?e:new I((function(A){A(e)}))).then(B,C)}Q((g=g.apply(A,e||[])).next())}))},i=this&&this.__classPrivateFieldGet||function(A,e){if(!e.has(A))throw new TypeError("attempted to get private field on non-instance");return e.get(A)},B=this&&this.__classPrivateFieldSet||function(A,e,I){if(!e.has(A))throw new TypeError("attempted to set private field on non-instance");return e.set(A,I),I};Object.defineProperty(e,"__esModule",{value:!0}),e.RainwayStream=void 0;const C=I(2994),Q=I(6904),o=I(2824),n=I(4425),a=I(3643),r=I(3464),E=I(4009),s=I(5528);class d{constructor(A,e,I,t,i,B,C,r,d,c){this.host=A,this.streamId=e,this.chosenAudioConfig=t,this.chosenVideoConfig=i,this.captureMode=B,this.sendInput=C,this.sendLogic=r,this.peerDiscardStream=c,this.resizeDebounceHandle=void 0,g.set(this,!1),this.sendKeyframeRequest=()=>{this.sendLogic({discriminator:Q.KeyframeRequest.discriminator,value:{streamId:this.streamId}})},this.feedVideoStateIntoRateController=A=>{this.rateController.handleVideoReadyState(A)},this.setRemoteClipboard=()=>{var A;"function"!=typeof(null===(A=null===navigator||void 0===navigator?void 0:navigator.clipboard)||void 0===A?void 0:A.readText)||s.isDesktopSafari||navigator.clipboard.readText().then((A=>{this.sendInput({discriminator:Q.SetClipboardText.discriminator,value:{text:A}})}))};const h=document.createElement("div");h.tabIndex=0,h.style.touchAction="none",h.style.userSelect="none",h.style.webkitUserSelect="none",h.style.position="relative",h.style.width="100%",h.style.height="100%",h.className="rainway-inner-container",h.addEventListener("focus",this.setRemoteClipboard),this.innerContainer=h,this.inputManager=new o.RainwayInputManager(this),this.mediaManager=new n.MediaManager(B,i,{video:{codecString:E.videoCodecMimeType(i.codec)}},d),this.rateController=new a.RainwayRateController(void 0,i,(A=>this.sendLogic({discriminator:Q.VideoBitrateRequest.discriminator,value:{streamId:e,bitsPerSecond:1e3*A}})),this.mediaManager.videoPerformanceMonitor),h.addEventListener("click",(()=>{this.resumeAudio()})),this.mediaManager.setContainer(h),this.mediaManager.videoNeedsRestartEvent.addHandler(this.sendKeyframeRequest),this.mediaManager.videoReadyStateChangeEvent.addHandler(this.feedVideoStateIntoRateController),this.inputManager.setContainer(h),this.inputManager.setInputLevel(I),this.containerResizeObserver=new ResizeObserver((()=>{this.resizeDebounceHandle&&window.clearTimeout(this.resizeDebounceHandle),this.resizeDebounceHandle=window.setTimeout((()=>{this.sendInput({discriminator:Q.ViewportResize.discriminator,value:{width:this.innerContainer.clientWidth,height:this.innerContainer.clientHeight}}),this.resizeDebounceHandle=void 0}),100)})),this.containerResizeObserver.observe(h)}get dead(){return i(this,g)}get container(){return this.innerContainer}get inputLevel(){return this.inputManager.getInputLevel()}get currentFrameSize(){const{codec:A}=this.chosenVideoConfig;return{codecWidth:A.width,codecHeight:A.height,streamBounds:this.mediaManager.currentStreamBounds,fullDesktopBounds:this.mediaManager.currentFullDesktopBounds}}static createAndInitialize(A,e,I,g,i,B,C,Q,o,n){return t(this,void 0,void 0,(function*(){const t=new d(A,e,I,g,i,B,C,Q,o,n);return yield t.mediaManager.initialize(),t}))}processAudio(A){this.mediaManager.processAudio(A)}processCursor(A){this.inputManager.processCursor(A)}renderVideoFrame(A,e){this.rateController.feedFrameTimestamp(A.timestamp),this.mediaManager.renderVideoFrame(A,e)}transformPointerOffsetToRemote(A,e){const I=this.mediaManager.currentStreamBounds;if(!I)return;const g=this.mediaManager.currentFullDesktopBounds;if(!g)return;const{left:t,top:i,width:B,height:C}=g,{left:Q,top:o,width:n,height:a}=I,r=this.chosenVideoConfig.codec.width,E=this.chosenVideoConfig.codec.height,s=this.innerContainer.clientWidth,d=this.innerContainer.clientHeight,c=n*r/B,h=a*E/C,D=Math.min(s/c,d/h);return{x:(A-(s-D*c)/2)/(D*r/B)+Q-t,y:(e-(d-D*h)/2)/(D*E/C)+o-i}}releaseKeys(){this.inputManager.releaseKeys()}enableVideoStatsOverlay(){var A;null===(A=this.mediaManager)||void 0===A||A.enableStatsOverlay()}disableVideoStatsOverlay(){var A;null===(A=this.mediaManager)||void 0===A||A.disableStatsOverlay()}requestFullscreen(A){var e,I,g;const t=null===(e=null==A?void 0:A.lockKeyboard)||void 0===e||e,i=null===(I=null==A?void 0:A.lockPointer)||void 0===I||I;if(this.innerContainer.requestFullscreen?this.innerContainer.requestFullscreen({navigationUI:"hide"}):this.innerContainer.webkitRequestFullscreen({navigationUI:"hide"}),t&&"keyboard"in navigator)try{navigator.keyboard.lock()}catch(A){}i&&(null===(g=this.inputManager)||void 0===g||g.lockPointer())}play(){if(i(this,g))throw new C.RainwayError("Attempted to play a dead stream");this.mediaManager.play(),this.rateController.start()}pause(){if(i(this,g))throw new C.RainwayError("Attempted to pause a dead stream");this.mediaManager.pause(),this.rateController.stop()}leave(){i(this,g)?r.RainwayLogging.warning("Attempted to leave a dead stream"):(this.sendLogic({discriminator:Q.LeaveStream.discriminator,value:{streamId:this.streamId}}),this.peerDiscardStream(),this.resizeDebounceHandle&&clearTimeout(this.resizeDebounceHandle),this.innerContainer.removeEventListener("focus",this.setRemoteClipboard),this.containerResizeObserver.disconnect(),this.mediaManager.videoNeedsRestartEvent.removeHandler(this.sendKeyframeRequest),this.mediaManager.videoReadyStateChangeEvent.removeHandler(this.feedVideoStateIntoRateController),this.inputManager.dispose(),this.mediaManager.dispose(),this.rateController.stop(),B(this,g,!0))}resumeAudio(){var A,e;null===(e=null===(A=this.mediaManager)||void 0===A?void 0:A.audioContext)||void 0===e||e.resume()}enableGestures(){var A;null===(A=this.inputManager)||void 0===A||A.enableGestures()}disableGestures(){var A;null===(A=this.inputManager)||void 0===A||A.disableGestures()}setStreamFit(A){this.mediaManager.streamFit=A}setOutgoingInputFilter(A){this.inputManager.outgoingInputFilter=A}}e.RainwayStream=d,g=new WeakMap},2994:(A,e)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.RainwayError=void 0;class I extends Error{constructor(A){super(`Rainway SDK Error: ${A}`),this.name=this.constructor.name,"function"==typeof Error.captureStackTrace?Error.captureStackTrace(this,this.constructor):this.stack=new Error(`Rainway SDK Error: ${A}`).stack,Object.setPrototypeOf(this,I.prototype)}}e.RainwayError=I},6579:A=>{A.exports=function(A){return A&&"object"==typeof A&&"function"==typeof A.copy&&"function"==typeof A.fill&&"function"==typeof A.readUInt8}},7673:(A,e,I)=>{"use strict";var g=I(7740),t=I(8265),i=I(2505),B=I(387);function C(A){return A.call.bind(A)}var Q="undefined"!=typeof BigInt,o="undefined"!=typeof Symbol,n=C(Object.prototype.toString),a=C(Number.prototype.valueOf),r=C(String.prototype.valueOf),E=C(Boolean.prototype.valueOf);if(Q)var s=C(BigInt.prototype.valueOf);if(o)var d=C(Symbol.prototype.valueOf);function c(A,e){if("object"!=typeof A)return!1;try{return e(A),!0}catch(A){return!1}}function h(A){return"[object Map]"===n(A)}function D(A){return"[object Set]"===n(A)}function u(A){return"[object WeakMap]"===n(A)}function w(A){return"[object WeakSet]"===n(A)}function l(A){return"[object ArrayBuffer]"===n(A)}function y(A){return"undefined"!=typeof ArrayBuffer&&(l.working?l(A):A instanceof ArrayBuffer)}function S(A){return"[object DataView]"===n(A)}function F(A){return"undefined"!=typeof DataView&&(S.working?S(A):A instanceof DataView)}e.isArgumentsObject=g,e.isGeneratorFunction=t,e.isTypedArray=B,e.isPromise=function(A){return"undefined"!=typeof Promise&&A instanceof Promise||null!==A&&"object"==typeof A&&"function"==typeof A.then&&"function"==typeof A.catch},e.isArrayBufferView=function(A){return"undefined"!=typeof ArrayBuffer&&ArrayBuffer.isView?ArrayBuffer.isView(A):B(A)||F(A)},e.isUint8Array=function(A){return"Uint8Array"===i(A)},e.isUint8ClampedArray=function(A){return"Uint8ClampedArray"===i(A)},e.isUint16Array=function(A){return"Uint16Array"===i(A)},e.isUint32Array=function(A){return"Uint32Array"===i(A)},e.isInt8Array=function(A){return"Int8Array"===i(A)},e.isInt16Array=function(A){return"Int16Array"===i(A)},e.isInt32Array=function(A){return"Int32Array"===i(A)},e.isFloat32Array=function(A){return"Float32Array"===i(A)},e.isFloat64Array=function(A){return"Float64Array"===i(A)},e.isBigInt64Array=function(A){return"BigInt64Array"===i(A)},e.isBigUint64Array=function(A){return"BigUint64Array"===i(A)},h.working="undefined"!=typeof Map&&h(new Map),e.isMap=function(A){return"undefined"!=typeof Map&&(h.working?h(A):A instanceof Map)},D.working="undefined"!=typeof Set&&D(new Set),e.isSet=function(A){return"undefined"!=typeof Set&&(D.working?D(A):A instanceof Set)},u.working="undefined"!=typeof WeakMap&&u(new WeakMap),e.isWeakMap=function(A){return"undefined"!=typeof WeakMap&&(u.working?u(A):A instanceof WeakMap)},w.working="undefined"!=typeof WeakSet&&w(new WeakSet),e.isWeakSet=function(A){return w(A)},l.working="undefined"!=typeof ArrayBuffer&&l(new ArrayBuffer),e.isArrayBuffer=y,S.working="undefined"!=typeof ArrayBuffer&&"undefined"!=typeof DataView&&S(new DataView(new ArrayBuffer(1),0,1)),e.isDataView=F;var R="undefined"!=typeof SharedArrayBuffer?SharedArrayBuffer:void 0;function p(A){return"[object SharedArrayBuffer]"===n(A)}function G(A){return void 0!==R&&(void 0===p.working&&(p.working=p(new R)),p.working?p(A):A instanceof R)}function f(A){return c(A,a)}function m(A){return c(A,r)}function k(A){return c(A,E)}function U(A){return Q&&c(A,s)}function N(A){return o&&c(A,d)}e.isSharedArrayBuffer=G,e.isAsyncFunction=function(A){return"[object AsyncFunction]"===n(A)},e.isMapIterator=function(A){return"[object Map Iterator]"===n(A)},e.isSetIterator=function(A){return"[object Set Iterator]"===n(A)},e.isGeneratorObject=function(A){return"[object Generator]"===n(A)},e.isWebAssemblyCompiledModule=function(A){return"[object WebAssembly.Module]"===n(A)},e.isNumberObject=f,e.isStringObject=m,e.isBooleanObject=k,e.isBigIntObject=U,e.isSymbolObject=N,e.isBoxedPrimitive=function(A){return f(A)||m(A)||k(A)||U(A)||N(A)},e.isAnyArrayBuffer=function(A){return"undefined"!=typeof Uint8Array&&(y(A)||G(A))},["isProxy","isExternal","isModuleNamespaceObject"].forEach((function(A){Object.defineProperty(e,A,{enumerable:!1,value:function(){throw new Error(A+" is not supported in userland")}})}))},1323:(A,e,I)=>{var g=Object.getOwnPropertyDescriptors||function(A){for(var e=Object.keys(A),I={},g=0;g<e.length;g++)I[e[g]]=Object.getOwnPropertyDescriptor(A,e[g]);return I},t=/%[sdj%]/g;e.format=function(A){if(!D(A)){for(var e=[],I=0;I<arguments.length;I++)e.push(Q(arguments[I]));return e.join(" ")}I=1;for(var g=arguments,i=g.length,B=String(A).replace(t,(function(A){if("%%"===A)return"%";if(I>=i)return A;switch(A){case"%s":return String(g[I++]);case"%d":return Number(g[I++]);case"%j":try{return JSON.stringify(g[I++])}catch(A){return"[Circular]"}default:return A}})),C=g[I];I<i;C=g[++I])c(C)||!l(C)?B+=" "+C:B+=" "+Q(C);return B},e.deprecate=function(A,I){if("undefined"!=typeof process&&!0===process.noDeprecation)return A;if("undefined"==typeof process)return function(){return e.deprecate(A,I).apply(this,arguments)};var g=!1;return function(){if(!g){if(process.throwDeprecation)throw new Error(I);process.traceDeprecation?console.trace(I):console.error(I),g=!0}return A.apply(this,arguments)}};var i={},B=/^$/;if(process.env.NODE_DEBUG){var C=process.env.NODE_DEBUG;C=C.replace(/[|\\{}()[\]^$+?.]/g,"\\$&").replace(/\*/g,".*").replace(/,/g,"$|^").toUpperCase(),B=new RegExp("^"+C+"$","i")}function Q(A,I){var g={seen:[],stylize:n};return arguments.length>=3&&(g.depth=arguments[2]),arguments.length>=4&&(g.colors=arguments[3]),d(I)?g.showHidden=I:I&&e._extend(g,I),u(g.showHidden)&&(g.showHidden=!1),u(g.depth)&&(g.depth=2),u(g.colors)&&(g.colors=!1),u(g.customInspect)&&(g.customInspect=!0),g.colors&&(g.stylize=o),a(g,A,g.depth)}function o(A,e){var I=Q.styles[e];return I?"["+Q.colors[I][0]+"m"+A+"["+Q.colors[I][1]+"m":A}function n(A,e){return A}function a(A,I,g){if(A.customInspect&&I&&F(I.inspect)&&I.inspect!==e.inspect&&(!I.constructor||I.constructor.prototype!==I)){var t=I.inspect(g,A);return D(t)||(t=a(A,t,g)),t}var i=function(A,e){if(u(e))return A.stylize("undefined","undefined");if(D(e)){var I="'"+JSON.stringify(e).replace(/^"|"$/g,"").replace(/'/g,"\\'").replace(/\\"/g,'"')+"'";return A.stylize(I,"string")}return h(e)?A.stylize(""+e,"number"):d(e)?A.stylize(""+e,"boolean"):c(e)?A.stylize("null","null"):void 0}(A,I);if(i)return i;var B=Object.keys(I),C=function(A){var e={};return A.forEach((function(A,I){e[A]=!0})),e}(B);if(A.showHidden&&(B=Object.getOwnPropertyNames(I)),S(I)&&(B.indexOf("message")>=0||B.indexOf("description")>=0))return r(I);if(0===B.length){if(F(I)){var Q=I.name?": "+I.name:"";return A.stylize("[Function"+Q+"]","special")}if(w(I))return A.stylize(RegExp.prototype.toString.call(I),"regexp");if(y(I))return A.stylize(Date.prototype.toString.call(I),"date");if(S(I))return r(I)}var o,n="",l=!1,R=["{","}"];return s(I)&&(l=!0,R=["[","]"]),F(I)&&(n=" [Function"+(I.name?": "+I.name:"")+"]"),w(I)&&(n=" "+RegExp.prototype.toString.call(I)),y(I)&&(n=" "+Date.prototype.toUTCString.call(I)),S(I)&&(n=" "+r(I)),0!==B.length||l&&0!=I.length?g<0?w(I)?A.stylize(RegExp.prototype.toString.call(I),"regexp"):A.stylize("[Object]","special"):(A.seen.push(I),o=l?function(A,e,I,g,t){for(var i=[],B=0,C=e.length;B<C;++B)m(e,String(B))?i.push(E(A,e,I,g,String(B),!0)):i.push("");return t.forEach((function(t){t.match(/^\d+$/)||i.push(E(A,e,I,g,t,!0))})),i}(A,I,g,C,B):B.map((function(e){return E(A,I,g,C,e,l)})),A.seen.pop(),function(A,e,I){return A.reduce((function(A,e){return e.indexOf("\n"),A+e.replace(/\u001b\[\d\d?m/g,"").length+1}),0)>60?I[0]+(""===e?"":e+"\n ")+" "+A.join(",\n  ")+" "+I[1]:I[0]+e+" "+A.join(", ")+" "+I[1]}(o,n,R)):R[0]+n+R[1]}function r(A){return"["+Error.prototype.toString.call(A)+"]"}function E(A,e,I,g,t,i){var B,C,Q;if((Q=Object.getOwnPropertyDescriptor(e,t)||{value:e[t]}).get?C=Q.set?A.stylize("[Getter/Setter]","special"):A.stylize("[Getter]","special"):Q.set&&(C=A.stylize("[Setter]","special")),m(g,t)||(B="["+t+"]"),C||(A.seen.indexOf(Q.value)<0?(C=c(I)?a(A,Q.value,null):a(A,Q.value,I-1)).indexOf("\n")>-1&&(C=i?C.split("\n").map((function(A){return"  "+A})).join("\n").substr(2):"\n"+C.split("\n").map((function(A){return"   "+A})).join("\n")):C=A.stylize("[Circular]","special")),u(B)){if(i&&t.match(/^\d+$/))return C;(B=JSON.stringify(""+t)).match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)?(B=B.substr(1,B.length-2),B=A.stylize(B,"name")):(B=B.replace(/'/g,"\\'").replace(/\\"/g,'"').replace(/(^"|"$)/g,"'"),B=A.stylize(B,"string"))}return B+": "+C}function s(A){return Array.isArray(A)}function d(A){return"boolean"==typeof A}function c(A){return null===A}function h(A){return"number"==typeof A}function D(A){return"string"==typeof A}function u(A){return void 0===A}function w(A){return l(A)&&"[object RegExp]"===R(A)}function l(A){return"object"==typeof A&&null!==A}function y(A){return l(A)&&"[object Date]"===R(A)}function S(A){return l(A)&&("[object Error]"===R(A)||A instanceof Error)}function F(A){return"function"==typeof A}function R(A){return Object.prototype.toString.call(A)}function p(A){return A<10?"0"+A.toString(10):A.toString(10)}e.debuglog=function(A){if(A=A.toUpperCase(),!i[A])if(B.test(A)){var I=process.pid;i[A]=function(){var g=e.format.apply(e,arguments);console.error("%s %d: %s",A,I,g)}}else i[A]=function(){};return i[A]},e.inspect=Q,Q.colors={bold:[1,22],italic:[3,23],underline:[4,24],inverse:[7,27],white:[37,39],grey:[90,39],black:[30,39],blue:[34,39],cyan:[36,39],green:[32,39],magenta:[35,39],red:[31,39],yellow:[33,39]},Q.styles={special:"cyan",number:"yellow",boolean:"yellow",undefined:"grey",null:"bold",string:"green",date:"magenta",regexp:"red"},e.types=I(7673),e.isArray=s,e.isBoolean=d,e.isNull=c,e.isNullOrUndefined=function(A){return null==A},e.isNumber=h,e.isString=D,e.isSymbol=function(A){return"symbol"==typeof A},e.isUndefined=u,e.isRegExp=w,e.types.isRegExp=w,e.isObject=l,e.isDate=y,e.types.isDate=y,e.isError=S,e.types.isNativeError=S,e.isFunction=F,e.isPrimitive=function(A){return null===A||"boolean"==typeof A||"number"==typeof A||"string"==typeof A||"symbol"==typeof A||void 0===A},e.isBuffer=I(6579);var G=["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"];function f(){var A=new Date,e=[p(A.getHours()),p(A.getMinutes()),p(A.getSeconds())].join(":");return[A.getDate(),G[A.getMonth()],e].join(" ")}function m(A,e){return Object.prototype.hasOwnProperty.call(A,e)}e.log=function(){console.log("%s - %s",f(),e.format.apply(e,arguments))},e.inherits=I(87),e._extend=function(A,e){if(!e||!l(e))return A;for(var I=Object.keys(e),g=I.length;g--;)A[I[g]]=e[I[g]];return A};var k="undefined"!=typeof Symbol?Symbol("util.promisify.custom"):void 0;function U(A,e){if(!A){var I=new Error("Promise was rejected with a falsy value");I.reason=A,A=I}return e(A)}e.promisify=function(A){if("function"!=typeof A)throw new TypeError('The "original" argument must be of type Function');if(k&&A[k]){var e;if("function"!=typeof(e=A[k]))throw new TypeError('The "util.promisify.custom" argument must be of type Function');return Object.defineProperty(e,k,{value:e,enumerable:!1,writable:!1,configurable:!0}),e}function e(){for(var e,I,g=new Promise((function(A,g){e=A,I=g})),t=[],i=0;i<arguments.length;i++)t.push(arguments[i]);t.push((function(A,g){A?I(A):e(g)}));try{A.apply(this,t)}catch(A){I(A)}return g}return Object.setPrototypeOf(e,Object.getPrototypeOf(A)),k&&Object.defineProperty(e,k,{value:e,enumerable:!1,writable:!1,configurable:!0}),Object.defineProperties(e,g(A))},e.promisify.custom=k,e.callbackify=function(A){if("function"!=typeof A)throw new TypeError('The "original" argument must be of type Function');function e(){for(var e=[],I=0;I<arguments.length;I++)e.push(arguments[I]);var g=e.pop();if("function"!=typeof g)throw new TypeError("The last argument must be of type Function");var t=this,i=function(){return g.apply(t,arguments)};A.apply(this,e).then((function(A){process.nextTick(i.bind(null,null,A))}),(function(A){process.nextTick(U.bind(null,A,i))}))}return Object.setPrototypeOf(e,Object.getPrototypeOf(A)),Object.defineProperties(e,g(A)),e}},2505:(A,e,I)=>{"use strict";var g=I(5278),t=I(973),i=I(2737),B=i("Object.prototype.toString"),C=I(698)(),Q="undefined"==typeof globalThis?I.g:globalThis,o=t(),n=i("String.prototype.slice"),a={},r=I(8828),E=Object.getPrototypeOf;C&&r&&E&&g(o,(function(A){if("function"==typeof Q[A]){var e=new Q[A];if(Symbol.toStringTag in e){var I=E(e),g=r(I,Symbol.toStringTag);if(!g){var t=E(I);g=r(t,Symbol.toStringTag)}a[A]=g.get}}}));var s=I(387);A.exports=function(A){return!!s(A)&&(C&&Symbol.toStringTag in A?function(A){var e=!1;return g(a,(function(I,g){if(!e)try{var t=I.call(A);t===g&&(e=t)}catch(A){}})),e}(A):n(B(A),8,-1))}},8859:A=>{self,A.exports=(()=>{"use strict";var A={114:function(A,e,I){var g=this&&this.__importDefault||function(A){return A&&A.__esModule?A:{default:A}};Object.defineProperty(e,"__esModule",{value:!0});const t=g(I(170));class i{initialize(){return this.id=i.uniqueIdCounter++,new Promise(((A,e)=>{this.worker=new t.default,this.worker.addEventListener("message",(e=>{var I;const g=e.data;"decoderReady"===g.type?A(0):"pictureReady"===g.type&&(null===(I=this.onDecode)||void 0===I||I.call(this,g))}))}))}decode(A){this.worker&&this.worker.postMessage({type:"decode",data:A.buffer,offset:A.byteOffset,length:A.byteLength,renderStateId:this.id},[A.buffer])}release(){this.worker&&this.worker.postMessage({type:"release",renderStateId:this.id})}dispose(){this.worker&&(this.worker.terminate(),this.worker=void 0)}}e.default=i,i.uniqueIdCounter=1},170:(A,e,I)=>{I.r(e),I.d(e,{default:()=>i});var g=I(614),t=I.n(g);function i(){return t()('/*! For license information please see index.worker.js.LICENSE.txt */\n(()=>{var A={719:A=>{var I,g=(I="undefined"!=typeof document&&document.currentScript?document.currentScript.src:void 0,function(A){(A=A||{})||(A=void 0!==A?A:{});var g,B={};for(g in A)A.hasOwnProperty(g)&&(B[g]=A[g]);var Q,C=[],E="";E=self.location.href,I&&(E=I),E=0!==E.indexOf("blob:")?E.substr(0,E.lastIndexOf("/")+1):"",Q=function(A){var I=new XMLHttpRequest;return I.open("GET",A,!1),I.responseType="arraybuffer",I.send(null),new Uint8Array(I.response)};var i,D,o=A.print||console.log.bind(console),a=A.printErr||console.warn.bind(console);for(g in B)B.hasOwnProperty(g)&&(A[g]=B[g]);B=null,A.arguments&&(C=A.arguments),A.thisProgram&&A.thisProgram,A.quit&&A.quit,A.wasmBinary&&(i=A.wasmBinary),A.noExitRuntime&&A.noExitRuntime,"object"!=typeof WebAssembly&&a("no native wasm support detected");var G,S,F,N,w,y,R,h=new WebAssembly.Table({initial:1,maximum:1,element:"anyfunc"}),s=!1;function k(I){G=I,A.HEAP8=S=new Int8Array(I),A.HEAP16=N=new Int16Array(I),A.HEAP32=w=new Int32Array(I),A.HEAPU8=F=new Uint8Array(I),A.HEAPU16=new Uint16Array(I),A.HEAPU32=new Uint32Array(I),A.HEAPF32=y=new Float32Array(I),A.HEAPF64=R=new Float64Array(I)}var L=A.INITIAL_MEMORY||16777216;function M(I){for(;I.length>0;){var g=I.shift();if("function"!=typeof g){var B=g.func;"number"==typeof B?void 0===g.arg?A.dynCall_v(B):A.dynCall_vi(B,g.arg):B(void 0===g.arg?null:g.arg)}else g(A)}}(D=A.wasmMemory?A.wasmMemory:new WebAssembly.Memory({initial:L/65536,maximum:32768}))&&(G=D.buffer),L=G.byteLength,k(G),w[2188]=5251792;var U=[],Y=[],J=[],q=[],K=0,H=null,t=null;function c(I){throw A.onAbort&&A.onAbort(I),o(I+=""),a(I),s=!0,I="abort("+I+"). Build with -s ASSERTIONS=1 for more info.",new WebAssembly.RuntimeError(I)}function d(A){return I=A,g="data:application/octet-stream;base64,",String.prototype.startsWith?I.startsWith(g):0===I.indexOf(g);var I,g}A.preloadedImages={},A.preloadedAudios={};var n,p="TinyH264.wasm";function f(){try{if(i)return new Uint8Array(i);if(Q)return Q(p);throw"both async and sync fetching of the wasm failed"}catch(A){c(A)}}function r(A){try{return D.grow(A-G.byteLength+65535>>>16),k(D.buffer),1}catch(A){}}d(p)||(n=p,p=A.locateFile?A.locateFile(n,E):E+n),Y.push({func:function(){x()}});var e={a:function(A,I,g){F.copyWithin(A,I,I+g)},b:function(A){A>>>=0;var I=F.length,g=2147483648;if(A>g)return!1;for(var B,Q=1;Q<=4;Q*=2){var C=I*(1+.2/Q);if(C=Math.min(C,A+100663296),r(Math.min(g,((B=Math.max(16777216,A,C))%65536>0&&(B+=65536-B%65536),B))))return!0}return!1},memory:D,table:h},m=function(){var I={a:e};function g(I,g){var B=I.exports;A.asm=B,function(I){if(K--,A.monitorRunDependencies&&A.monitorRunDependencies(K),0==K&&(null!==H&&(clearInterval(H),H=null),t)){var g=t;t=null,g()}}()}function B(A){g(A.instance)}function Q(A){return(i||"function"!=typeof fetch?new Promise((function(A,I){A(f())})):fetch(p,{credentials:"same-origin"}).then((function(A){if(!A.ok)throw"failed to load wasm binary file at \'"+p+"\'";return A.arrayBuffer()})).catch((function(){return f()}))).then((function(A){return WebAssembly.instantiate(A,I)})).then(A,(function(A){a("failed to asynchronously prepare wasm: "+A),c(A)}))}if(K++,A.monitorRunDependencies&&A.monitorRunDependencies(K),A.instantiateWasm)try{return A.instantiateWasm(I,g)}catch(A){return a("Module.instantiateWasm callback failed with error: "+A),!1}return function(){if(i||"function"!=typeof WebAssembly.instantiateStreaming||d(p)||"function"!=typeof fetch)return Q(B);fetch(p,{credentials:"same-origin"}).then((function(A){return WebAssembly.instantiateStreaming(A,I).then(B,(function(A){a("wasm streaming compile failed: "+A),a("falling back to ArrayBuffer instantiation"),Q(B)}))}))}(),{}}();A.asm=m;var W,x=A.___wasm_call_ctors=function(){return(x=A.___wasm_call_ctors=A.asm.c).apply(null,arguments)};function X(I){function g(){W||(W=!0,A.calledRun=!0,s||(M(Y),M(J),A.onRuntimeInitialized&&A.onRuntimeInitialized(),function(){if(A.postRun)for("function"==typeof A.postRun&&(A.postRun=[A.postRun]);A.postRun.length;)I=A.postRun.shift(),q.unshift(I);var I;M(q)}()))}I=I||C,K>0||(function(){if(A.preRun)for("function"==typeof A.preRun&&(A.preRun=[A.preRun]);A.preRun.length;)I=A.preRun.shift(),U.unshift(I);var I;M(U)}(),K>0||(A.setStatus?(A.setStatus("Running..."),setTimeout((function(){setTimeout((function(){A.setStatus("")}),1),g()}),1)):g()))}if(A._h264bsdInit=function(){return(A._h264bsdInit=A.asm.d).apply(null,arguments)},A._malloc=function(){return(A._malloc=A.asm.e).apply(null,arguments)},A._free=function(){return(A._free=A.asm.f).apply(null,arguments)},A._h264bsdDecode=function(){return(A._h264bsdDecode=A.asm.g).apply(null,arguments)},A._h264bsdShutdown=function(){return(A._h264bsdShutdown=A.asm.h).apply(null,arguments)},A._h264bsdAlloc=function(){return(A._h264bsdAlloc=A.asm.i).apply(null,arguments)},A._h264bsdFree=function(){return(A._h264bsdFree=A.asm.j).apply(null,arguments)},A.asm=m,A.getValue=function(A,I,g){switch("*"===(I=I||"i8").charAt(I.length-1)&&(I="i32"),I){case"i1":case"i8":return S[A>>0];case"i16":return N[A>>1];case"i32":case"i64":return w[A>>2];case"float":return y[A>>2];case"double":return R[A>>3];default:c("invalid type for getValue: "+I)}return null},A.then=function(I){if(W)I(A);else{var g=A.onRuntimeInitialized;A.onRuntimeInitialized=function(){g&&g(),I(A)}}return A},t=function A(){W||X(),W||(t=A)},A.run=X,A.preInit)for("function"==typeof A.preInit&&(A.preInit=[A.preInit]);A.preInit.length>0;)A.preInit.pop()();return X(),A});A.exports=g},340:(A,I,g)=>{"use strict";g.r(I),g.d(I,{init:()=>o});var B=function(){function A(A,I){this.tinyH264Module=A,this.onPictureReady=I,this.pStorage=this.tinyH264Module._h264bsdAlloc(),this.pWidth=this.tinyH264Module._malloc(4),this.pHeight=this.tinyH264Module._malloc(4),this.pPicture=this.tinyH264Module._malloc(4),this._decBuffer=this.tinyH264Module._malloc(1048576),this.tinyH264Module._h264bsdInit(this.pStorage,0)}var I=A.prototype;return I.release=function(){var A=this.pStorage;0!==A&&(this.tinyH264Module._h264bsdShutdown(A),this.tinyH264Module._h264bsdFree(A)),this.tinyH264Module._free(this.pWidth),this.tinyH264Module._free(this.pHeight),this.tinyH264Module._free(this.pPicture),this.pStorage=0,this.pWidth=0,this.pHeight=0},I.decode=function(I){if(I instanceof ArrayBuffer&&(I=new Uint8Array(I)),this.tinyH264Module.HEAPU8.set(I,this._decBuffer),this.tinyH264Module._h264bsdDecode(this.pStorage,this._decBuffer,I.byteLength,this.pPicture,this.pWidth,this.pHeight)===A.PIC_RDY){var g=this.tinyH264Module.getValue(this.pWidth,"i32"),B=this.tinyH264Module.getValue(this.pHeight,"i32"),Q=this.tinyH264Module.getValue(this.pPicture,"i8*"),C=new Uint8Array(this.tinyH264Module.HEAPU8.subarray(Q,Q+g*B*3/2));this.onPictureReady(C,g,B)}},A}();B.RDY=0,B.PIC_RDY=1,B.HDRS_RDY=2,B.ERROR=3,B.PARAM_SET_ERROR=4,B.MEMALLOC_ERROR=5;const Q=B;var C=g(719),E=g.n(C),i={"TinyH264.wasm":"data:;base64,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ZGogATYCACAEIANBBHFBGHIiBGsiAkEgSQ0AIAGtIgVCIIYgBYQhBSADIARqIQEDQCABIAU3AxggASAFNwMQIAEgBTcDCCABIAU3AwAgAUEgaiEBIAJBYGoiAkEfSw0ACwsgAAvyAwEDfyABKAIAIgNB////B0cEQCABKAIEIQQgACACIAJBA3EgAkEQSSICG0ECdCIFQfApaigCAEEQQQggAhsiAmxqIAVBsClqKAIAaiIAIAMgAC0AAGpBsC5qLQAAOgAAIAEoAgghAyAAIAQgAC0AAWpBsC5qLQAAOgABIAEoAgwhBCAAIAMgAC0AAmpBsC5qLQAAOgACIAAgBCAALQADakGwLmotAAA6AAMgASgCFCEDIAAgAmoiACABKAIQIAAtAABqQbAuai0AADoAACABKAIYIQQgACADIAAtAAFqQbAuai0AADoAASABKAIcIQMgACAEIAAtAAJqQbAuai0AADoAAiAAIAMgAC0AA2pBsC5qLQAAOgADIAEoAiQhAyAAIAJqIgAgASgCICAALQAAakGwLmotAAA6AAAgASgCKCEEIAAgAyAALQABakGwLmotAAA6AAEgASgCLCEDIAAgBCAALQACakGwLmotAAA6AAIgACADIAAtAANqQbAuai0AADoAAyABKAI0IQMgACACaiIAIAEoAjAgAC0AAGpBsC5qLQAAOgAAIAEoAjghAiAAIAMgAC0AAWpBsC5qLQAAOgABIAEoAjwhASAAIAIgAC0AAmpBsC5qLQAAOgACIAAgASAALQADakGwLmotAAA6AAMLC9MQAQx/IwBBgAFrIgokACAAEA8hBEEBIQUCQAJAAn8gAkEBTQRAIARBAEgNAiAEQRl2Qf4AcUGACGogBEGAgIDgAE8NARogBEEVdkH+D3FBwAhqIARBgICACE8NARogBEERdkH+/wFxQZAJaiAEQYCAgAFPDQEaIARBEHZBAXRBkApqDAELIAJBA00EQCAEQX9MBEBBAkGiECAEQYCAgIAEcRshBQwDCyAEQRl2Qf4AcUHQCmogBEGAgICAAU8NARogBEEWdkH+B3FBkAtqIARBgICAEE8NARogBEERdkH+/wFxQdALagwBCyACQQdNBEAgBEEadiICQXhqQThJBEAgAkEBdEHQDWoMAgsgBEEVdkH+D3FB0A5qDAELIARBGXZB/gBxQdAQaiACQRBNDQAaIARBHXYiAgRAIAJBAXRB0BFqDAELIARBF3ZB/gNxQeARagsvAQAiBQ0AQQEhCwwBC0EBIQsgBUELdiIJIANLDQBBICAFQR9xIgZrIQICQCAJRQRADAELIAQgBnQhBAJAIAVBBXZBP3EiDEUEQAwBCyACIAxJBEAgACAGEAtBf0YNAyAAEA8hBEEgIQILIAQgDHQhBkEBIAxBf2p0IQcgBEEgIAxrdiEEA0AgCkFAayAIQQJ0akF/QQEgBCAHcRs2AgAgCEEBaiEIIAdBAXYiBw0ACyACIAxrIQIgBiEECyAIIAlJBEAgDEEDSSIPIAVB/68BS3EhBQNAIAJBD00EQCAAQSAgAmsQC0F/RgRADAULIAAQDyEEQSAhAgtBACEGAkACQAJ/AkAgBEEASA0AQQEhBiAEQf////8DSw0AQQIhBiAEQf////8BSw0AQQMhBiAEQf////8ASw0AQQQhBiAEQf///z9LDQBBBSEGIARB////H0sNAEEGIQYgBEH///8PSw0AQQchBiAEQf///wdLDQBBCCEGIARB////A0sNAEEJIQYgBEH///8BSw0AQQohBiAEQf///wBLDQBBCyEGIARB//8/Sw0AQQwhBiAEQf//H0sNAEENIQYgBEH//w9LDQACfwJAIARB//8HTQRAIARBgIB8cUGAgARGDQEMCgsgBUEEIAUbIQYgBEEPdCEEQQ4hByACQXFqDAELIAVBASAFGyEFIARBEHQhBEEMIQZBDyEHIAJBcGoLIQIgByAFdCEHIAVFDAELIAYgBXQhB0EBIQ4gAiAGQQFqIgZrIQIgBCAGdCEEIAVFDQEgBSEGQQALIQ4gAiAGTwR/IAQFIABBICACaxALQX9GBEAMBwtBICECIAAQDwshDSACIAZrIQIgDSAGdCEEIA1BICAGa3YgB2ohBwwBC0EAIQULIApBQGsgCEECdGpBACAHQQJqIAcgCCAMRhsgByAPGyINQQJqQQF2IgZrIAYgDUEBcRs2AgBBASAFIA4bIgUgBUEGSSAGQQMgBUF/anRKcWohBSAIQQFqIgggCUcNAAsLQQAhBwJAIAkgA08EQEEAIQgMAQsCQCACQQhLBEAgAiEFDAELQSAhBSAAQSAgAmsQC0F/Rg0DIAAQDyEECwJAAkACfwJAIANBBEcEQCAJQX9qIgJBDUsNAwJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIAJBAWsODQABAgMEBQYHCAkKCwwOCyAEQRp2QeASagwOCyAEQRp2QaATagwNCyAEQRt2QeATagwMCyAEQRt2QYAUagwLCyAEQRp2QaAUagwKCyAEQRp2QeAUagwJCyAEQRp2QaAVagwICyAEQRp2QeAVagwHCyAEQRt2QaAWagwGCyAEQRx2QcAWagwFCyAEQRx2QdAWagwECyAEQR12QeAWagwDCyAEQR52QegWagwCCyAEQQBIBEBBASECDAQLQREhAiAJQQNGDQNBEiECIARB/////wNLDQNBIiECIAlBAkYNA0EjQTMgBEH/////AUsbIQIMAwsgBEEbdkGgEmogBEEXdkHAEmogBEH/////AEsbCy0AACICDQEMBAtBEUEBIARBAEgbIQILIAJBBHYhCCAFIAJBD3EiA2shAiAEIAN0IQQLIAlBf2oiAwRAA0ACfyAIBEAgAkEKTQRAIABBICACaxALQX9GBEAMBwsgABAPIQRBICECCwJAAn8CQCAIQX9qIgVBBU0EQAJAAkACQAJAAkAgBUEBaw4FAAECAwQGCyAEQR52Qe4WagwGCyAEQR52QfIWagwFCyAEQR12QfYWagwECyAEQR12Qf4WagwDCyAEQR12QYYXagwCCwJ/QfMAIARBGXZB8ABxayAEQYCAgIACTw0AGkH0ACAEQf////8ASw0AGkGFASAEQf///z9LDQAaQZYBIARB////H0sNABpBpwEgBEH///8PSw0AGkG4ASAEQf///wdLDQAaQckBIARB////A0sNABpB2gEgBEH///8BSw0AGkEAQesBIARBgICAAUkbCyIFQQR2IAhNDQIMCAsgBEEfdkHsFmoLLQAAIQULIAVFBEAMBgsgCiAHQQJ0aiAFQQR2IgZBAWo2AgAgAiAFQQ9xIgVrIQIgBCAFdCEEIAggBmsMAQsgCiAHQQJ0akEBNgIAQQALIQggB0EBaiIHIANHDQALIAEgCEECdGogCkFAayADQQJ0aigCADYCACAJQX5qIQVBASAIdCEHA0AgASAKIAUiA0ECdCIFaigCACAIaiIIQQJ0aiAKQUBrIAVqKAIANgIAIANBf2ohBUEBIAh0IAdyIQcgAw0ACwwBCyABIAhBAnRqIApBQGsgA0ECdGooAgA2AgBBASAIdCEHCyAA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ASAAKALMASADQQF0ai4BHGpBAWpBAXUPCyAFQQRGBEAgAiADQQF0ai4BACEBAn8gACgCyAEiAgRAIAAoAgQgAigCBEYMAQtBAAtFDQEgASAAKALIASAEQQF0ai4BHGpBAWpBAXUPCwJ/An8gACgCyAEiAQRAIAAoAgQgASgCBEYMAQtBAAtFBEBBACECQQAMAQtBASECIAAoAsgBIARBAXRqLgEcCyEBAn8gACgCzAEiBARAIAAoAgQgBCgCBEYMAQtBAAtFDQAgACgCzAEgA0EBdGouARwhACACRQRAIAAPCyAAIAFqQQFqQQF1IQELIAELiQcBB38gAyAFaiINIAEuAQAiDEECdWohAyAEIAZqIg4gAS4BAiIPQQJ1aiEEIAIoAghBBHQhCSACKAIEQQR0IQogACAGQQR0aiAFaiELAkAgDEEDcUEEdCAPQQNxQQJ0ckHQO2ooAgAiDEEOTQRAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIAxBAWsODgECAwQFBgcICQoLDA0OAAsgAigCACALIAMgBCAKIAkgByAIQRAQDAwPCyACKAIAIAsgAyAEQX5qIAogCSAHIAhBABAkDA4LIAIoAgAgCyADIARBfmogCiAJIAcgCBBHDA0LIAIoAgAgCyADIARBfmogCiAJIAcgCEEBECQMDAsgAigCACALIANBfmogBCAKIAkgByAIQQAQIwwLCyACKAIAIAsgA0F+aiAEQX5qIAogCSAHIAhBABAaDAoLIAIoAgAgCyADQX5qIARBfmogCiAJIAcgCEEAECEMCQsgAigCACALIANBfmogBEF+aiAKIAkgByAIQQIQGgwICyACKAIAIAsgA0F+aiAEIAogCSAHIAgQRgwHCyACKAIAIAsgA0F+aiAEQX5qIAogCSAHIAhBABAiDAYLIAIoAgAgCyADQX5qIARBfmogCiAJIAcgCBBFDAULIAIoAgAgCyADQX5qIARBfmogCiAJIAcgCEEBECIMBAsgAigCACALIANBfmogBCAKIAkgByAIQQEQIwwDCyACKAIAIAsgA0F+aiAEQX5qIAogCSAHIAhBARAaDAILIAIoAgAgCyADQX5qIARBfmogCiAJIAcgCEEBECEMAQsgAigCACALIANBfmogBEF+aiAKIAkgByAIQQMQGgsgDUEBdiABLgEAIglBA3VqIQMgDkEBdiABLgECIgFBA3VqIQQgAigCACACKAIEIgogAigCCCILbEEIdGohAiAAIAZBAnRBeHFqIAVBAXZqQYACaiEFIAhBAXYhBiAHQQF2IQcgAUEHcSEIIAtBA3QhACAKQQN0IQECQCAJQQdxIglFDQAgCEUNACACIAUgAyAEIAEgACAJIAggByAGEEgPCyAJBEAgAiAFIAMgBCABIAAgCSAHIAYQSw8LIAgEQCACIAUgAyAEIAEgACAIIAcgBhBKDwsgAiAFIAMgBCABIAAgByAGQQgQDCACIAAgAWxqIAVBQGsgAyAEIAEgACAHIAZBCBAMC8cBAQR/IAAoAgQhAgJAIAAoAgxBA3QgACgCEGsiA0EgTgRAIAIoAAAiAUEYdCABQQh0QYCA/AdxciABQQh2QYD+A3EgAUEYdnJyIQEgACgCCCIARQ0BIAEgAHQgAi0ABEEIIABrdnIPCyADQQFIBEBBAA8LIAItAAAgACgCCCIAQRhqIgR0IQEgACADakF4aiIAQQFIDQADQCACLQABIARBeGoiBHQgAXIhASAAQQhKIQMgAkEBaiECIABBeGohACADDQALCyABC4wEAQd/AkAgAEF/aiIILQAAIgUgAC0AACIGayIEIARBH3UiBGogBHMgAigCBE8NACAAQX5qLQAAIgQgBWsiByAHQR91IgdqIAdzIAIoAggiCU8NACAALQABIgcgBmsiCiAKQR91IgpqIApzIAlPDQAgAUEDTQRAIAggBSABIAIoAgBqQX9qLQAAIghBf3MiCSAIQQFqIgggBiAFa0ECdCAHayAEakEEakEDdSIFIAUgCEobIAUgCUgbIgVqQbAuai0AADoAACAAIAYgBWtBsC5qLQAAOgAADAELIAggBSAHaiAEQQF0akECakECdjoAACAAIAYgB0EBdGogBGpBAmpBAnY6AAALAkAgACADaiIAQX9qIgctAAAiAyAALQAAIgVrIgYgBkEfdSIGaiAGcyACKAIETw0AIABBfmotAAAiBiADayIEIARBH3UiBGogBHMgAigCCCIITw0AIAAtAAEiBCAFayIJIAlBH3UiCWogCXMgCE8NACABQQNNBEAgByABIAIoAgBqQX9qLQAAIgFBf3MiAiABQQFqIgcgBSADa0ECdCAEayAGakEEakEDdSIBIAEgB0obIAEgAkgbIgEg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QRBqIQELIAdBAnYiBEUNAEHAACAGayEQIAlBAXQhCiAJQQJ0IAZrIQtBACAJayIMQQF0IRIgASAHQQR0ayECIAkgE2ogCEEBcWpBAmoiACAJQQVsaiEBA0AgBiIDBEADQCACIAAgCmotAAAiBSABIApqLQAAIAEgCWotAAAiDiABIBJqLQAAIgdqIghrIAhBAnRraiABLQAAIg0gASAMai0AACIIakEUbGpBEGpBBXVBsC5qLQAAIAItADBqQQFqQQF2OgAwIAIgACAJai0AACIPIA4gByAIakEUbGogBSANaiIOayAOQQJ0a2pBEGpBBXVBsC5qLQAAIAItACBqQQFqQQF2OgAgIAIgAC0AACIOIA0gBSAHakEUbGogCCAPaiINayANQQJ0a2pBEGpBBXVBsC5qLQAAIAItABBqQQFqQQF2OgAQIAIgACAMai0AACAIIAUgD2pBFGxqIAcgDmoiBWsgBUECdGtqQRBqQQV1QbAuai0AACACLQAAakEBakEBdjoAACAAQQFqIQAgAkEBaiECIAFBAWohASADQX9qIgMNAAsLIAIgEGohAiABIAtqIQEgACALaiEAIARBf2oiBA0ACwsgEUHAA2okAAu1BQEEfyAAKAIUIQMgACgCECEEIAAoAgQhBSAAKAIMIgIgASkCADcCACACIAEpAgg3AgggAiAFQQR0IgBqIgIgASkCEDcCACACIAEpAhg3AgggACACaiICIAEpAiA3AgAgAiABKQIoNwIIIAAgAmoiAiABKQIwNwIAIAIgASkCODcCCCAAIAJqIgIgASkCQDcCACACIAEpAkg3AgggACACaiICIAEpAlA3AgAgAiABKQJYNwIIIAAgAmoiAiABKQJgNwIAIAIgASkCaDcCCCAAIAJqIgIgASkCcDcCACACIAEpAng3AgggACACaiICIAEpAoABNwIAIAIgASkCiAE3AgggACACaiICIAEpApABNwIAIAIgASkCmAE3AgggACACaiICIAEpAqABNwIAIAIgASkCqAE3AgggACACaiICIAEpArABNwIAIAIgASkCuAE3AgggACACaiICIAEpAsABNwIAIAIgASkCyAE3AgggACACaiICIAEpAtABNwIAIAIgASkC2AE3AgggACACaiICIAEpAuABNwIAIAIgASkC6AE3AgggACACaiIAIAEpAvABNwIAIAAgASkC+AE3AgggBCABKQKAAjcCACAEIAVBA3QiAGoiBCABKQKIAjcCACAAIARqIgQgASkCkAI3AgAgACAEaiIEIAEpApgCNwIAIAAgBGoiBCABKQKgAjcCACAAIARqIgQgASkCqAI3AgAgACAEaiIEIAEpArACNwIAIAAgBGogASkCuAI3AgAgAyABKQLAAjcCACAAIANqIgMgASkCyAI3AgAgACADaiIDIAEpAtACNwIAIAAgA2oiAyABKQLYAjcCACAAIANqIgMgASkC4AI3AgAgACADaiIDIAEpAugCNwIAIAAgA2oiAyABKQLwAjcCACAAIANqIAEpAvgCNwIAC+gCAQV/AkAgACABEAIiAw0AQQEhAyABIAEoAgBBAWoiAjYCACACQSBLDQAgAEEEEAMiAkF/Rg0AIAEgAjYCBCAAQQQQAyICQX9GDQAgASACNgIIIAEoAgAEQANAIAAgASAFQQJ0aiICIgRBDGoQAiIDDQJBASEDIAQoAgwiBkF/Rg0CIAQgBkEBaiIDNgIMIAQgAyABKAIEQQZqdDYCDCAAIAJBjAFqEAIiAw0CQQEhAyACKAKMASIEQX9GDQIgAiAEQQFqIgQ2AowBIAIgBCABKAIIQQRqdDYCjAEgAEEBEAMiBEF/Rg0CIAIgBEEBRjYCjAIgBUEBaiIFIAEoAgBJDQALCyAAQQUQAyICQX9GDQAgASACQQFqNgKMAyAAQQUQAyICQX9GDQAgASACQQFqNgKQAyAAQQUQAyICQX9GDQAgASACQQFqNgKUAyAAQQUQAyIAQX9GDQAgASAANgKYA0EAIQMLIAMLWwEDfyAAIAAoAgAiBCABIAAoAgQiAnAiA0EEdGogASADayIBQQh0ajYCDCAAIAQgAiAAKAIIbCICQQh0aiABQQZ0aiADQQN0aiIBNgIQIAAgASACQQZ0ajYCFAtVAQJ/IAEgAkEBaiIDIAMgAUkbIQMgACACQQJ0aigCACEEA0ACQCACQQFqIgIgAU8EQCADIQIMAQsgACACQQJ0aigCACAERw0BCwtBACACIAEgAkYbCycAIABBCCAAKAIIIgBrEANBf0YEQA8LQQAgAGtBAnRBzD9qKAIAGgt6AQJ/IwBBIGsiAiQAIAIgACgCEDYCECACIAApAgg3AwggAiAAKQIANwMAAkAgAiACQRxqEAIiAA0AIAIgAkEcahACIgANACACIAJBHGoQAiIADQBBASEAIAIoAhwiA0H/AUsNACABIAM2AgBBACEACyACQSBqJAAgAAvnBwESfyMAQYAOayIMJAAgBkEFaiEJAkACQCACQQBIDQAgA0EASA0AIAIgCWogBEsNACADIAdqQQVqIAVLDQAgAyEKDAELIAAgDEHACmogAiADIAQgBSAJIAdBBWogCRAMIAxBwApqIQAgCSEEQQAhAgsCQCAHQQJ2IhRFDQAgCUUNACAEQQF0IRVBACAEayIWQQF0IRogBEECdCAGa0F7aiEXIAAgBCAKbCACamogBGoiACAEQQVsaiECIAwgCUECdCIQaiEDIAlBA3QhDUEAIAlrQQJ0IQ4gCUEDbEECdCEPA0AgCSEFA0AgAyANaiAAIBVqLQAAIhEgAiAVai0AACACIARqLQAAIgsgAiAaai0AACISaiIKayAKQQJ0a2ogAi0AACIYIAIgFmotAAAiE2pBFGxqNgIAIAMgEGogACAEai0AACIZIAsgEiATakEUbGogESAYaiIKayAKQQJ0a2o2AgAgAyAALQAAIgsgGCARIBJqQRRsaiATIBlqIgprIApBAnRrajYCACADIA5qIAAgFmotAAAgEyARIBlqQRRsaiALIBJqIgprIApBAnRrajYCACAAQQFqIQAgA0EEaiEDIAJBAWohAiAFQX9qIgUNAAsgAiAXaiECIAAgF2ohACADIA9qIQMgFEF/aiIUDQALCyAHBEBBECAGayEQIAZBAnYhCiAMIAhBAnRqQQhqIQAgDEEUaiECA0AgCgRAIAJBbGooAgAhBCACQXBqKAIAIQ8gAkF0aigCACENIAJBeGooAgAhBSACQXxqKAIAIQMgCiEJA0AgASACKAIAIg4gBCADIA9qIgRrIAUgDWpBFGxqIARBAnRrakGABGpBCnVBsC5qLQAAIAAoAgBBEGpBBXVBsC5qLQAAakEBakEBdjoAACABIAIoAgQiCyAPIAMgBWpBFGxqIA0gDmoiBGsgBEECdGtqQYAEakEKdUGwLmotAAAgACgCBEEQakEFdUGwLmotAABqQQFqQQF2OgABIAEgAigCCCIIIA0gAyAOakEUbGogBSALaiIEayAEQQJ0a2pBgARqQQp1QbAuai0AACAAKAIIQRBqQQV1QbAuai0AAGpBAWpBAXY6AAIgASACKAIM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KAIABEAgAyAAQewMaiABIABB5ApqKAIAIAIgACgC0ApBBUYgACgCuAkgACgCtAkQKQwBCyADQQAgASAAQeQKaigCACACIAAoAtAKQQVGIAAoArgJIAAoArQJECkLIABCADcCoAlBASEFCyAEQZABaiQAIAULqAwBC38CQCABQQRPBEBBACADayINQQF0IQoCQCAAIANrIgUtAAAiBiAALQAAIghrIgEgAUEfdSIBaiABcyACKAIEIgFPDQAgACAKai0AACIHIAZrIgQgBEEfdSIEaiAEcyACKAIIIgxPDQAgACADai0AACIEIAhrIgsgC0EfdSILaiALcyAMTw0AIAUgBCAGaiAHQQF0akECakECdjoAACAAIAggBEEBdGogB2pBAmpBAnY6AAAgAigCBCEBCwJAIABBAWoiBiANaiIMLQAAIgggAC0AASIHayIEIARBH3UiBGogBHMgAU8NACAGIApqLQAAIgQgCGsiBSAFQR91IgVqIAVzIAIoAggiC08NACADIAZqLQAAIgUgB2siCSAJQR91IglqIAlzIAtPDQAgDCAFIAhqIARBAXRqQQJqQQJ2OgAAIAYgByAFQQF0aiAEakECakECdjoAACACKAIEIQELAkAgAEECaiIGIA1qIgwtAAAiCCAALQACIgdrIgQgBEEfdSIEaiAEcyABTw0AIAYgCmotAAAiBCAIayIFIAVBH3UiBWogBXMgAigCCCILTw0AIAMgBmotAAAiBSAHayIJIAlBH3UiCWogCXMgC08NACAMIAUgCGogBEEBdGpBAmpBAnY6AAAgBiAHIAVBAXRqIARqQQJqQQJ2OgAAIAIoAgQhAQsCQCAAQQNqIgYgDWoiDC0AACIIIAAtAAMiB2siBCAEQR91IgRqIARzIAFPDQAgBiAKai0AACIEIAhrIgUgBUEfdSIFaiAFcyACKAIIIgtPDQAgAyAGai0AACIFIAdrIgkgCUEfdSIJaiAJcyALTw0AIAwgBSAIaiAEQQF0akECakECdjoAACAGIAcgBUEBdGogBGpBAmpBAnY6AAAgAigCBCEBCwJAIABBBGoiBiANaiIMLQAAIgggAC0ABCIHayIEIARBH3UiBGogBHMgAU8NACAGIApqLQAAIgQgCGsiBSAFQR91IgVqIAVzIAIoAggiC08NACADIAZqLQAAIgUgB2siCSAJQR91IglqIAlzIAtPDQAgDCAFIAhqIARBAXRqQQJqQQJ2OgAAIAYgByAFQQF0aiAEakECakECdjoAACACKAIEIQELAkAgAEEFaiIGIA1qIgwtAAAiCCAALQAFIgdrIgQgBEEfdSIEaiAEcyABTw0AIAYgCmotAAAiBCAIayIFIAVBH3UiBWogBXMgAigCCCILTw0AIAMgBmotAAAiBSAHayIJIAlBH3UiCWogCXMgC08NACAMIAUgCGogBEEBdGpBAmpBAnY6AAAgBiAHIAVBAXRqIARqQQJqQQJ2OgAAIAIoAgQhAQsCQCAAQQZqIgYgDWoiDC0AACIIIAAtAAYiB2siBCAEQR91IgRqIARzIAFPDQAgBiAKai0AACIEIAhrIgUgBUEfdSIFaiAFcyACKAIIIgtPDQAgAyAGai0AACIFIAdrIgkgCUEfdSIJaiAJcyALTw0AIAwgBSAIaiAEQQF0akECakECdjoAACAGIAcgBUEBdGogBGpBAmpBAnY6AAAgAigCBCEBCyANIABBB2oiDWoiCC0AACIGIAAtAAciAGsiByAHQR91IgdqIAdzIAFPDQEgCiANai0AACIBIAZrIgogCkEfdSIKaiAKcyACKAIIIgpPDQEgAyANai0AACICIABrIgMgA0EfdSIDaiADcyAKTw0BIAggAiAGaiABQQF0akECakECdjoAACANIAAgAkEBdGogAWpBAmpBAnY6AAAPC0EAIANrIgdBAXQhBCABIAIoAgBqQX9qLQAAIgFBAWohBiABQX9zIQhBCCEBA0ACQCAAIAdqIgUtAAAiCiAALQAAIg1rIgwgDEEfdSIMaiAMcyACKAIETw0AIAAgBGotAAAiDCAKayILIAtBH3UiC2ogC3MgAigCCCILTw0AIAAgA2otAAAiCSANayIOIA5BH3UiDmogDnMgC08NACAFIAogCCAGIA0gCmtBAnQgCWsgDGpBBGpBA3UiCiAKIAZKGyAKIAhIGyIKakGwLmotAAA6AAAgACANIAprQbAuai0AADoAAAsgAEEBaiEAIAFBf2oiAQ0ACwsL6ggBAn8gAUEAQbgHEAchAkEBIQECQAJAIABBARADIgNBf0YNACACIANBAUY2AgACQCADQQFHDQAgAEEIEAMiA0F/Rg0BIAIgAzYCBCADQf8BRw0AIABBEBADIgNBf0YNASACIAM2AgggAEEQEAMiA0F/Rg0BIAIgAzYCDAsgAEEBEAMiA0F/Rg0AIAIgA0EBRjYCECADQQFGBEAgAEEBEAMiA0F/Rg0BIAIgA0EBRjYCFAsgAEEBEAMiA0F/Rg0AIAIgA0EBRjYCGAJAAkAgA0EBRgRAIABBAxADIgNBf0YNAyACIAM2AhwgAEEBEAMiA0F/Rg0DIAIgA0EBRjYCICAAQQEQAyIDQX9GDQMgAiADQQFGNgIkIANBAUcNASAAQQgQAyIDQX9GDQMgAiADNgIoIABBCBADIgNBf0YNAyACIAM2AiwgAEEIEAMiA0F/Rw0CDAMLIAJBBTYCHAsgAkKCgICAIDcCKEECIQMLIAIgAzYCMCAAQQEQAyIDQX9GDQAgAiADQQFGNgI0AkAgA0EBRw0AIAAgAkE4ahACIgENASACKAI4QQVLDQIgACACQTxqEAIiAQ0BIAIoAjxBBU0NAAwCC0EBIQEgAEEBEAMiA0F/Rg0AIAIgA0EBRjYCQCADQQFGBEAgABAPIQEgAEEgEAshAyABRQ0CIANBf0YNAiACIAE2AkQgABAPIQEgAEEgEAshAyABRQ0CIANBf0YNAiACIAE2AkhBASEBIABBARADIgNBf0YNASACIANBAUY2AkwLIABBARADIgNBf0YNACACIANBAUY2AlACQCADQQFGBEAgACACQdQAahAcIgFFDQEMAgsgAkEBNgJUIAJCmICAgIADNwLoAyACQpiAgICAAzcC4AMgAkGBkKqJATYC4AEgAkGBkKqJATYCYAtBASEBIABBARADIgNBf0YNACACIANBAUY2AvADAkAgA0EBRgRAIAAgAkH0A2oQHCIBRQ0BDAILIAJBATYC9AMgAkKYgICAgAM3AogHIAJCmICAgIADNwKAByACQYG4uPIANgKABSACQYG4uPIANgKABAsCQCACKAJQRQRAIAIoAvADRQ0BC0EBIQEgAEEBEAMiA0F/Rg0BIAIgA0EBRjYCkAcLQQEhASAAQQEQAyIDQX9GDQAgAiADQQFGNgKUByAAQQEQAyIDQX9GDQAgAiADQQFGNgKYBwJAIANBAUYEQCAAQQEQAyIDQX9GDQIgAiADQQFGNgKcByAAIAJBoAdqEAIiAQ0CIAIoAqAHQRBLDQMgACACQaQHahACIgENAiACKAKkB0EQSw0DIAAgAkGoB2oQAiIBDQIgAigCqAdBEEsNAyAAIAJBrAdqEAIiAQ0CQQEhASACKAKsB0EQSw0CIAAgAkGwB2oQAiIBDQIgACACQbQHahACIgFFDQEMAgsgAkEQNgK0ByACQpCAgICAAjcCrAcgAkKBgICAgAI3AqQHIAJCgYCAgCA3ApwHC0EAIQELIAEPC0EBC00BAn8jAEEQayIDJABBASEEAkAgACADQQxqEAINACADKAIMIgBBL0sNACABQdA/QYDAACACGyAAai0AADYCAEEAIQQLIANBEGokACAECz4BAn8CQCAAKAIMQQN0IAAoAhBrIgFFBEAMAQtBASECIAFBCEsNAEEBIAFBf2p0IAAQD0EgIAFrdkcPCyACCzIBAn8CQEGAgIDAACIBIABxDQADQCACQQFqIQIgAUEBdiIBRQ0BIAAgAXFFDQALCyACC4oCAQd/IAFBoD1qLQAAQQxsQdA8aigCACECQQEhAyABQQZPBEBBACEDIAIgAUGQPGotAABBf2p0IQILIAAgACgCACIBIAAoAggiBGsiBSAAKAIEIgYgACgCDCIHayIIayACbCADdTYCDCAAIAUgCGogAmwgA3U2AgggACABIARqIgEgBiAHaiIEayACbCADdTYCBCAAIAEgBGogAmwgA3U2AgAgACAAKAIcIgEgACgCFCIEaiIFIAAoAhgiBiAAKAIQIgdqIghqIAJsIAN1NgIQIAAgBCABayIBIAcgBmsiBGogAmwgA3U2AhggACAIIAVrIAJsIAN1NgIUIAAgBCABayACbCADdTYCHAvPCAEUfyAAIAAoAiwiAiAAKAIMIgZqIgUgACgCNCIEIAAoAiAiEGoiCmsiETYCLCAAKAIoIQMgACAGIAJrIgcgECAEayIEayIGNgIoIAAoAiQhAiAAIAQgB2oiBDYCJCAAIAUgCmoiBTYCICAAIAAoAhwiCiAAKAIIIgdqIgggACgCMCIMIAAoAhAiCWoiC2siEDYCHCAAKAIYIQ8gACAHIAprIgcgCSAMayIMayIKNgIYIAAoAhQhCSAAIAcgDGoiBzYCFCAAIAggC2oiCDYCECAAIAkgACgCACILaiISIA8gACgCBCINaiIOayIMNgIMIAAgCyAJayIJIA0gD2siC2siDzYCCCAAIAkgC2oiCTYCBCAAIA4gEmoiCzYCACAAIAIgACgCOCINaiITIAMgACgCPCIOaiIUayISNgI8IAAgAiANayICIAMgDmsiA2siDTYCOCAAIAIgA2oiDjYCNCAAIBMgFGoiEzYCMCABQZA8ai0AACECIAFBoD1qLQAAQQxsQdA8aigCACEDIAFBDE8EQCAAIAMgAkF+anQiASAFIAtqIgMgCCATaiICa2w2AjAgACALIAVrIgUgCCATayIIayABbDYCICAAIAUgCGogAWw2AhAgACACIANqIAFsNgIAIAAgBCAJaiIDIAcgDmoiAmsgAWw2AjQgACAJIARrIgQgByAOayIFayABbDYCJCAAIAQgBWogAWw2AhQgACACIANqIAFsNgIEIAAgBiAPaiIDIAogDWoiAmsgAWw2AjggACAPIAZrIgYgCiANayIEayABbDYCKCAAIAQgBmogAWw2AhggACACIANqIAFsNgIIIAAgDCARayIDIBAgEmsiAmsgAWw2AiwgACACIANqIAFsNgIcIAAgECASaiIDIAwgEWoiAmogAWw2AgwgACACIANrIAFsNgI8DwsgAEEBQQIgAUF6akEGSRsiASAFIAtqIhQgCCATaiIVayADbGpBAiACayICdTYCMCAAIAsgBWsiBSAIIBNrIghrIANsIAFqIAJ1NgIgIAAgBSAIaiADbCABaiACdTYCECAAIBQgFWogA2wgAWogAnU2AgAgACAEIAlqIgUgByAOaiIIayADbCABaiACdTYCNCAAIAkgBGsiBCAHIA5rIgdrIANsIAFqIAJ1NgIkIAAgBCAHaiADbCABaiACdTYCFCAAIAUgCGogA2wgAWogAnU2AgQgACAGIA9qIgQgCiANaiIFayADbCABaiACdTYCOCAAIA8gBmsiBiAKIA1rIgprIANsIAFqIAJ1NgIoIAAgBiAKaiADbCABaiACdTYCGCAAIAQgBWogA2wgAWogAnU2AgggACAMIBFrIgYgECASayIEayADbCABaiACdTYCLCAAIAQgBmogA2wgAWogAnU2AhwgACAQIBJqIgYgDCARaiIRaiADbCABaiACdTYCDCAAIBEgBmsgA2wgAWogAnU2AjwLvQUBBn8jAEEgayIFJAAgA0EANgIAAkAgASgCACIGQRJLDQBBASAGdCIGQcDfH3FFBEAgBkEicUUNASACQbQKaigCAARAIANBATYCACACQQA2ArQKCyAAIAVBHGoQICIEDQFB8P8DIQQgAiAF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IAFBf2oQA0F/RgRAQQEhAAwBCyAEIAMQBSEACyAEQSBqJAAgAAvmAQEDfyMAQSBrIgQkACAEIAAoAhA2AhAgBCAAKQIINwMIIAQgACkCADcDAAJAIAQgBEEcahACIgANACAEIARBHGoQAiIADQAgBCAEQRxqEAIiAA0AIAEoAgwhBkEAIQADQCAAIgVBAWohACAGIAV2DQALIAQgBUF/ahADQX9GBEBBASEADAELIAJBBUYEQCAEIARBHGoQAiIADQELIAEoAhQhAkEAIQADQCAAIgFBAWohACACIAF2DQALIAQgAUF/ahADIgBBf0YEQEEBIQAMAQsgAyAANgIAQQAhAAsgBEEgaiQAIAALkgEBAn8jAEEgayIDJAAgAyAAKAIQNgIQIAMgACkCADcDACADIAApAgg3AwgCQCADIANBHGoQAiIADQAgAyADQRxqEAIiAA0AIAMgA0EcahACIgANAEEAIQADQCAAIgRBAWohACABIAR2DQALIAMgBEF/ahADQX9GBEBBASEADAELIAMgAhACIQALIANBIGokACAAC5cBAQJ/IwBBIGsiAyQAIAMgACgCEDYCECADIAApAgg3AwggAyAAKQIANwMAAkAgAyADQRxqEAIiAA0AIAMgA0EcahACIgANACADIANBHGoQAiIADQBBACEAA0AgACIEQQFqIQAgASAEdg0ACyADIARBf2oQAyIAQX9GBEBBASEADAELIAIgADYCAEEAIQALIANBIGokACAAC68OAQp/IwBBEGsiBSQAIAFBAEHcBxAHIQcgAigCNCEGIAIoAjghCAJAIAAgBUEEahACIgENACAHIAUoAgQiATYCACABIAYgCGwiC08EQEEBIQEMAQsgACAFQQRqEAIiAQ0AIAcgBSgCBCIGNgIEIAZBB0sEQEEBIQEMAQtBASEBAkACQCAGQQFrDgcCAQICAAIBAAsgBCgCAEEFRgRADAILIAIoAiwNAAwBCyAAIAVBBGoQAiIBDQAgByAFKAIEIgY2AghBASEBIAYgAygCAEcNACACKAIMIQhBACEBA0AgASIGQQFqIQEgCCAGdg0AC0EBIQEgACAGQX9qEAMiBkF/Rg0AIAZBACAEKAIAIghBBUYbDQAgByAGNgIMIAhBBUYEQCAAIAVBBGoQAiIBDQEgByAFKAIEIgY2AhBBASEBIAZB//8DSw0B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IgMgAiANai0AACACIARqLQAAIgkgAiASai0AACIFaiIIayAIQQJ0a2ogAi0AACIKIAIgD2otAAAiCGpBFGxqQRBqQQV1QbAuai0AADoAMCABIAQgB2otAAAiECAJIAUgCGpBFGxqIAMgCmoiCWsgCUECdGtqQRBqQQV1QbAuai0AADoAICABIActAAAiCSAKIAMgBWpBFGxqIAggEGoiCmsgCkECdGtqQRBqQQV1QbAuai0AADoAECABIAcgD2otAAAgCCADIBBqQRRsaiAFIAlqIgNrIANBAnRrakEQakEFdUGwLmotAAA6AAAgB0EBaiEHIAFBAWohASACQQFqIQIgAEF/aiIADQALIAEgEWohASACIA5qIQIgByAOaiEHIAxBf2oiDA0ACwsgC0HAA2okAAuqBgENfyMAQbABayIRJAAgCEEBaiEKAkACQCACQQBIDQAgA0EASA0AIAIgCmogBEsNACADIAlqQQFqIAVLDQAgBSEMIAQhCiADIQ8MAQsgACARIAIgAyAEIAUgCiAJQQFqIgwgChAMIAAgBCAFbGogESAKIAxsaiACIAMgBCAFIAogDCAKEAwgESEAQQAhAgsCQCAJQQF2IgVFDQAgCEEBdiIERQ0AQRAgCGshE0EIIAdrIQtBCCAGayENIApBAXQiDiAIayEUIAAgAmoiFiAKIA9saiECIAEhACAFIRUDQCACIA5qLQAAIAdsIAsgAiAKai0AACIDbGohCCADIAdsIAsgAi0AAGxqIQkgBCEDA0AgAkEBaiIQIA5qLQAAIRIgACAJIA1sIAogEGotAAAiCSAHbCALIAItAAFsaiIQIAZsakEgakEGdjoAACAAIAggDWwgByASbCAJIAtsaiIIIAZsakEgakEGdjoACCACLQACIQkgAkECaiICIA5qLQAAIRIgACANIBBsIAIgCmotAAAiECAHbCAJIAtsaiIJIAZsakEgakEGdjoAASAAIAggDWwgByASbCALIBBsaiIIIAZsakEgakEGdjoACSAAQQJqIQAgA0F/aiIDDQALIAIgFGohAiAAIBNqIQAgFUF/aiIVDQALIAFBQGshACAWIAwgD2ogCmxqIQIDQCACIA5qLQAAIAdsIAsgAiAKai0AACIBbGohCCABIAdsIAsgAi0AAGxqIQkgBCEDA0AgAkEBaiIBIA5qLQAAIQwgACAJ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AmogAnNBA0shCgsgAyAKNgJoIAEuAaYBIR5BAiEbQQIhEwJAIC8gAS8BLCI0cg0AQQEhEyABLgGkASABLgGMAWsiAiACQR91IgJqIAJzQQNLDQAgHiAEayICIAJBH3UiAmogAnNBA0sNACABKAJ8IAEoAnRHIRMLIAMgEzYCcCABLgGqASEOAkAgECABLwEuIhhyDQBBASEbIAEuAagBIAEuAZABayICIAJBH3UiAmogAnNBA0sNACAOIAZrIgIgAkEfdSICaiACc0EDSw0AIAEoAnwgASgCdEchGwsgAyAbNgJ4IAEuAbYBIRlBAiESQQIhFQJAIBcgAS8BNCIgcg0AQQEhFSABLgG0ASABLgGcAWsiAiACQR91IgJqIAJzQQNLDQAgGSAHayICIAJBH3UiAmogAnNBA0sNACABKAKAASABKAJ4RyEVCyADIBU2AoABIAEuAboBISECQCAzIAEvATYiNXINAEEBIRIgAS4BuAEgAS4BoAFrIgIgAkEfdSICaiACc0EDSw0AICEgC2siAiACQR91IgJqIAJzQQNLDQAgASgCgAEgASgCeEchEgsgAyASNgKIASABLgGuASE2QQIhDSADAn9BAiA0IAEvATAiQXINABpBASABLgGsASABLgGkAWsiAiACQR91IgJqIAJzQQNLDQAaIDYgHmsiAiACQR91IgJqIAJzQQNLCyIdNgKQASABLgGyASEkAkAgGCABLwEyIjdyDQBBASENIAEuAbABIAEuAagBayICIAJBH3UiAmogAnNBA0sNACAkIA5rIgIgAkEfdSICaiACc0EDSyENCyADIA02ApgBIAEuAb4BISlBAiEcIAMCf0ECICAgAS8BOCI4cg0AGkEBIAEuAbwBIAEuAbQBayICIAJBH3UiAmogAnNBA0sNABogKSAZayICIAJBH3UiAmogAnNBA0sLIiY2AqABIAEuAcIBITkCQCA1IAEvAToiQnINAEEBIRwgAS4BwAEgAS4BuAFrIgIgAkEfdSICaiACc0EDSw0AIDkgIWsiAiACQR91IgJqIAJzQQNLIRwLIAMgHDYCqAFBAiECIAMCf0ECIBEgMHINABpBASABLgGIASABLgGEAWsiESARQR91IhFqIBFzQQNLDQAaIAggFGsiFCAUQR91IhRqIBRzQQNLCyIRNgI8AkAgMCAxcg0AQQEhAiAB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BSADLQAGampqQQJqQQJ2DAELIAcEQCADLQAEIAMtAAMgAy0AASADLQACampqQQJqQQJ2IQYgAy0ACCADLQAHIAMtAAUgAy0ABmpqakECakECdgwBCyAKRQRAQYABIQZBgAEMAQsgBC0AAyAELQACIAQtAAAgBC0AAWpqakECakECdiIGC0H/AXFBgYKECGwiADYAHCABIAZB/wFxQYGChAhsIgY2ABggASAANgAUIAEgBjYAECABIAA2AAwgASAGNgAIIAEgADYABCABIAY2AAACfyAKBEAgBC0AByAELQAGIAQtAAUgBC0ABGpqaiIGQQJqQQJ2IgAgB0UNARogAy0ACCADLQAHIAMtAAYgBiADLQAFampqakEEakEDdgwBCyAHRQRAQYABIQBBgAEMAQsgAy0ABCADLQADIAMtAAEgAy0AAmpqakECakECdiEAIAMtAAggAy0AByADLQAFIAMtAAZqampBAmpBAnYLIQYgASAAQf8BcUGBgoQIbCIANgAgIAEgBkH/AXFBgYKECGwiBjYAPCABIAA2ADggASAGNgA0IAEgADYAMCABIAY2ACwgASAANgAoIAEgBjYAJAwDCyAKRQRAQQEPCyABIAQtAAA6AAAgASAELQAAOgABIAEgBC0AADoAAiABIAQtAAA6AAMgASAELQAAOgAEIAEgBC0AADoABSABIAQtAAA6AAYgASAELQAAOgAHIAEgBC0AAToACCABIAQtAAE6AAkgASAELQABOgAKIAEgBC0AAToACyABIAQtAAE6AAwgASAELQABOgANIAEgBC0AAToADiABIAQtAAE6AA8gASAELQACOgAQIAEgBC0AAjoAESABIAQtAAI6ABIgASAELQACOgATIAEgBC0AAjoAFCABIAQtAAI6ABUgASAELQACOgAWIAEgBC0AAjoAFyABIAQtAAM6ABggASAELQADOgAZIAEgBC0AAzoAGiABIAQtAAM6ABsgASAELQADOgAcIAEgBC0AAzoAHSABIAQtAAM6AB4gASAELQADOgAfIAEgBC0ABDoAICABIAQtAAQ6ACEgASAELQAEOgAiIAEgBC0ABDoAIyABIAQtAAQ6ACQgASAELQAEOgAlIAEgBC0ABDoAJiABIAQtAAQ6ACcgASAELQAFOgAoIAEgBC0ABToAKSABIAQtAAU6ACogASAELQAFOgArIAEgBC0ABToALCABIAQtAAU6AC0gASAELQAFOgAuIAEgBC0ABToALyABIAQtAAY6ADAgASAELQAGOgAxIAEgBC0ABjoAMiABIAQtAAY6ADMgASAELQAGOgA0IAEgBC0ABjoANSABIAQtAAY6ADYgASAELQAGOgA3IAEgBC0ABzoAOCABIAQtAAc6ADkgASAELQAHOgA6IAEgBC0ABzoAOyABIAQtAAc6ADwgASAELQAHOgA9IAEgBC0ABzoAPiABIAQtAAc6AD8MAgsgB0UEQEEBDwsgASADLQABOgAAIAEgAy0AAToACCABIAMtAAE6ABAgASADLQABOgAYIAEgAy0AAToAICABIAMtAAE6ACggASADLQABOgAwIAEgAy0AAToAOCABIAMtAAI6AAEgASADLQACOgAJIAEgAy0AAjoAESABIAMtAAI6ABkgASADLQACOgAhIAEgAy0AAjoAKSABIAMtAAI6ADEgASADLQACOgA5IAEgAy0AAzoAAiABIAMtAAM6AAogASADLQADOgASIAEgAy0AAzoAGiABIAMtAAM6ACIgASADLQADOgAqIAEgAy0AAzoAMiABIAMtAAM6ADogASADLQAEOgADIAEgAy0ABDoACyABIAMtAAQ6ABMgASADLQAEOgAbIAEgAy0ABDoAIyABIAMtAAQ6ACsgASADLQAEOgAzIAEgAy0ABDoAOyABIAMtAAU6AAQgASADLQAFOgAMIAEgAy0ABToAFCABIAMtAAU6ABwgASADLQAFOgAkIAEgAy0ABToALCABIAMtAAU6ADQgASADLQAFOgA8IAEgAy0ABjoABSABIAMtAAY6AA0gASADLQAGOgAVIAEgAy0ABjoAHSABIAMtAAY6ACUgASADLQAGOgAtIAEgAy0ABjoANSABIAMtAAY6AD0gASADLQAHOgAGIAEgAy0ABzoADiABIAMtAAc6ABYgASADLQAHOgAeIAEgAy0ABzoAJiABIAMtAAc6AC4gASADLQAHOgA2IAEgAy0ABzoAPiABIAMtAAg6AAcgASADLQAIOgAPIAEgAy0ACDoAFyABIAMtAAg6AB8gASADLQAIOgAnIAEgAy0ACDoALyABIAMtAAg6ADcgASADLQAIOgA/DAELIA5FBEBBAQ8LIAMtAAUgAy0AA2sgAy0ABiADLQACa0EBdGogAy0AByADLQAB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ABA6AA8gAEEQaiEAIAVBAWoiBUEQRw0ACwwDCyAHRQRAQQEPC0EAIQUgASEAA0AgACAEIAVqIgMtAAA6AAAgACADLQAAOgABIAAgAy0AADoAAiAAIAMtAAA6AAMgACADLQAAOgAEIAAgAy0AADoABSAAIAMtAAA6AAYgACADLQAAOgAHIAAgAy0AADoACCAAIAMtAAA6AAkgACADLQAAOgAKIAAgAy0AADoACyAAIAMtAAA6AAwgACADLQAAOgANIAAgAy0AADoADiAAIAMtAAA6AA8gAEEQaiEAIAVBAWoiBUEQRw0ACwwCCyABAn8CQCAHRQ0AIAhFDQAgBC0ADyADLQAQIAQtAA4gAy0ADyAELQANIAMtAA4gBC0ADCADLQANIAQtAAsgAy0ADCAELQAKIAMtAAsgBC0ACSADLQAKIAQtAAggAy0ACSAELQAHIAMtAAggBC0ABiADLQAHIAQtAAUgAy0ABiAELQAEIAMtAAUgBC0AAyADLQAEIAQtAAIgAy0AAyAELQABIAMtAAIgAy0AASAELQAAampqampqampqampqampqampqampqampqampqampqakEQakEFdgwBCyAHBEAgBC0ADyAELQAOIAQtAA0gBC0ADCAELQALIAQtAAogBC0ACSAELQAIIAQtAAcgBC0ABiAELQAFIAQtAAQgBC0AAyAELQACIAQtAAAgBC0AAWpqampqampqampqampqakEIakEEdgwBC0GAASAIRQ0AGiADLQAQIAMtAA8gAy0ADiADLQANIAMtAAwgAy0ACyADLQAKIAMtAAkgAy0ACCADLQAHIAMtAAYgAy0ABSADLQAEIAMtAAMgAy0AASADLQACampqampqampqampqampqQQhqQQR2C0GAAhAHGgwBC0EBIQAgB0UNASAIRQ0BIAlFDQEgBC0ACCAELQAGayAELQAPIgAgAy0AACIFa0EDdGogBC0ACSAELQAFa0EBdGogBC0ACiAELQAEa0EDbGogBC0ACyAELQADa0ECdGogBC0ADCAELQACa0EFbGogBC0ADSAELQABa0EGbGogBC0ADiAELQAAa0EHbGpBBWxBIGpBBnUhByADLQAJIAMtAAdrIAMtAAogAy0ABmtBAXRqIAMtAAsgAy0ABWtBA2xqIAMtAAwgAy0ABGtBAnRqIAMtAA0gAy0AA2tBBWxqIAMtAA4gAy0AAmtBBmxqIAMtAA8gAy0AAWtBB2xqIAMtABAiAyAFa0EDdGpBBWxBIGpBBnUiBEEDdCEIIARBB2whCSAEQQZsIQogBEEFbCELIARBA2whDCAEQX1sIQ0gBEF7bCEOIARBemwhDyAEQXlsIRBBACAEQQF0IhFrIRJBACAEQQJ0IhNrIRQgACADakEEdEEQaiEVQQAhBQNAIAEgBUEEdCIAaiAVIAVBeWogB2xqIgMgEGpBBXUiBkH/ASAGQf8BSBsiBkEAIAZBAEobOgAAIAEgAEEBcmogAyAPakEFdSIGQf8BIAZB/wFIGyIGQQAgBkEAShs6AAAgASAAQQJyaiADIA5qQQV1IgZB/wEgBkH/AUgbIgZBACAGQQBKGzoAACABIABBA3JqIAMgFGpBBXUiBkH/ASAGQf8BSBsiBkEAIAZBAEobOgAAIAEgAEEEcmogAyANakEFdSIGQf8BIAZB/wFIGyIGQQAgBkEAShs6AAAgASAAQQVyaiADIBJqQQV1IgZB/wEgBkH/AUgbIgZBACAGQQBKGzoAACABIABBBnJqIAMgBGtBBXUiBkH/ASAGQf8BSBsiBkEAIAZBAEobOgAAIAEgAEEHcmogA0EFdSIGQf8BIAZB/wFIGyIGQQAgBkEAShs6AAAgASAAQQhyaiADIARqQQV1IgZB/wEgBkH/AUgbIgZBACAGQQBKGzoAACABIABBCXJqIAMgEWpBBXUiBkH/ASAGQf8BSBsiBkEAIAZBAEobOgAAIAEgAEEKcmogAyAMakEFdSIGQf8BIAZB/wFIGyIGQQAgBkEAShs6AAAgASAAQQtyaiADIBNqQQV1IgZB/wEgBkH/AUgbIgZBACAGQQBKGzoAACABIABBDHJqIAMgC2pBBXUiBkH/ASAGQf8BSBsiBkEAIAZBAEobOgAAIAEgAEENcmogAyAKakEFdSIGQf8BIAZB/wFIGyIGQQAgBkEAShs6AAAgASAAQQ5yaiADIAlqQQV1IgZB/wEgBkH/AUgbIgZBACAGQQBKGzoAACABIABBD3JqIAMgCGpBBXUiAEH/ASAAQf8BSBsiAEEAIABBAEobOgAAIAVBAWoiBUEQRw0ACwtBACEAIAEgAkEAEAggASACQUBrQQEQCCABIAJBgAFqQQIQCCABIAJBwAFqQQMQCCABIAJBgAJqQQQQCCABIAJBwAJqQQUQCCABIAJBgANqQQYQCCABIAJBwANqQQcQCCABIAJBgARqQQgQCCABIAJBwARqQQkQCCABIAJBgAVqQQoQCCABIAJBwAVqQQsQCCABIAJBgAZqQQwQCCABIAJBwAZqQQ0QCCABIAJBgAdqQQ4QCCABIAJBwAdqQQ8QCAsgAAvBCAEHfwJAIANFDQAgACgCACADIAAoAgQiBW4iCCAFbCIEQQh0aiADIARrIgdBBHRqIQYgBUEEdCEEIAAoAgghCSAFIANLIgpFBEAgASAGIARBf3NqIgMtAAA6AAAgASAGIARrLQAAOgABIAEgAy0AAjoAAiABIAMtAAM6AAMgASADLQAEOgAEIAEgAy0ABToABSABIAMtAAY6AAYgASADLQAHOgAHIAEgAy0ACDoACCABIAMtAAk6AAkgASADLQAKOgAKIAEgAy0ACzoACyABIAMtAAw6AAwgASADLQANOgANIAEgAy0ADjoADiABIAMtAA86AA8gASADLQAQOgAQIAEgAy0AEToAESABIAMtABI6ABIgASADLQATOgATIAEgAy0AFDoAFCABQRVqIQELIAcEQCACIAZBf2oiAy0AADoAACACIAMgBGoiAy0AADoAASACIAMgBGoiAy0AADoAAiACIAMgBGoiAy0AADoAAyACIAMgBGoiAy0AADoABCACIAMgBGoiAy0AADoABSACIAMgBGoiAy0AADoABiACIAMgBGoiAy0AADoAByACIAMgBGoiAy0AADoACCACIAMgBGoiAy0AADoACSACIAMgBGoiAy0AADoACiACIAMgBGoiAy0AADoACyACIAMgBGoiAy0AADoADCACIAMgBGoiAy0AADoADSACIAMgBGoiAy0AADoADiACIAMgBGotAAA6AA8gAkEQaiECCyAAKAIAIAUgCWwiBkEIdGogCCAFQQN0IgBsQQN0aiAHQQN0aiEEIABB+P///wdxIQAgCkUEQCABIAQgAEF/c2oiAy0AADoAACABIAQgAGstAAA6AAEgASADLQACOgACIAEgAy0AAzoAAyABIAMtAAQ6AAQgASADLQAFOgAFIAEgAy0ABjoABiABIAMtAAc6AAcgASADQQhqIgMtAAA6AAggASAGQQZ0IANqIgNBeGotAAA6AAkgASADQXlqLQAAOgAKIAEgA0F6ai0AADoACyABIANBe2otAAA6AAwgASADQXxqLQAAOgANIAEgA0F9ai0AADoADiABIANBfmotAAA6AA8gASADQX9qLQAAOgAQIAEgAy0AADoAEQsgB0UNACACIARBf2oiAS0AADoAACACIAAgAWoiAS0AADoAASACIAAgAWoiAS0AADoAAiACIAAgAWoiAS0AADoAAyACIAAgAWoiAS0AADoABCACIAAgAWoiAS0AADoABSACIAAgAWoiAS0AADoABiACIAAgAWoiAS0AADoAByACIAAgAWogBiAFa0EGdGoiAS0AADoACCACIAAgAWoiAS0AADoACSACIAAgAWoiAS0AADoACiACIAAgAWoiAS0AADoACyACIAAgAWoiAS0AADoADCACIAAgAWoiAS0AADoADSACIAAgAWoiAS0AADoADiACIAAgAWotAAA6AA8LC68BAQF/IwBB0ABrIgYkACACIAZBIGogBiADEFUCQAJAQQIgACgCACIDQQZHIANBBkkbQQFGBEAgACAFIAFByAJqIAZBIGogBiAEEFQiA0UNAQwCCyAAIAUgASAGQSBqIAYgBBBTIgMNAQsgACAFQYACaiABQcgKaiAGQTVqIAZBEGogASgCjAEgBBBSIgMNAEEAIQMgACgCxAFBAUsNACACIAUQGwsgBkHQAGokACADC6MqASR/IwBBIGsiECQAIBAgBCgCBCIINgIMIBAgBCgCCDYCECADIAhuIgZBBHQhFCADIAYgCGxrQQR0IRUCQAJAAkACQAJAAkACQAJAIAAoAgAiBkEDTQRAAkACQAJAIAZBAmsOAgECAAsgASgCkAEhEyAAKAIEIQ5BfyEPAn8gACgCyAEiCUUEQEEAIQhBfwwBC0EAIQhBfyAJKAIEIA5HDQAaQQEhEkF/IAkoAgBBBUsNABogCSgCmAEiCEEQdiEHIAkoAmgLIQ0gACgCzAEiCUUNCCAJKAIEIA5HDQhBASEWIAkoAgBBBUsNCCAJKAKsASIRQRB2IQogCSgCbCEPDAgLIAEoApABIRMgAS8BogEhDSABLwGgASEMIAAoAgQhC0F/IQcCQCAAKALMASIGRQ0AIAsgBigCBEcEQAwBC0EBIRIgBigCAEEFSw0AIAYoAqwBIglBEHYhCiAGKAJsIQcLIAcgE0YEQCAKIQcgCSEGDAcLQX8hDwJAAkACQCAAKALIASIIRQRAQQAh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AAAJAAAABAAAAAwAAAD/AAAAAAAAAP8AAAAAAAAABAAAAAkAAAAEAAAADAAAAAQAAAALAAAABAAAAA4AAAABAAAACgAAAP8AAAAAAAAA/wAAAAAAAAD/AAAAAAAAAAEAAAAKAAAABAAAAAAAAAD/AAAAAAAAAP8AAAAAAAAAAQAAAAoAAAABAAAACwAAAP8AAAAAAAAA/wAAAAAAAAABAAAACgAAAAEAAAALAAAABAAAAAAAAAAEAAAAAQAAAAEAAAAOAAAA/wAAAAAAAAD/AAAAAAAAAP8AAAAAAAAAAQAAAA4AAAAEAAAABAAAAP8AAAAAAAAA/wAAAAAAAAABAAAADgAAAAEAAAAPAAAA/wAAAAAAAAD/AAAAAAAAAAEAAAAOAAAAAQAAAA8AAAAEAAAABAAAAAQAAAAFAAAABAAAAAIAAAD/AAAAAAAAAP8AAAAAAAAA/wAAAAAAAAAEAAAAAgAAAAQAAAAIAAAA/wAAAAAAAAD/AAAAAAAAAAQAAAACAAAABAAAAAMAAAD/AAAAAAAAAP8AAAAAAAAABAAAAAIAAAAEAAAAAwAAAAQAAAAIAAAABAAAAAkAAAAEAAAABgAAAP8AAAAAAAAA/wAAAAAAAAD/AAAAAAAAAAQAAAAGAAAABAAAAAwAAAD/AAAAAAAAAP8AAAAAAAAABAAAAAYAAAAEAAAABwAAAP8AAAAAAAAA/wAAAAAAAAAEAAAABgAAAAQAAAAHAAAABAAAAAwAAAAEAAAADQAAAAEAAAAOAAAA/wAAAAAAAAD/AAAAAAAAAP8AAAAAAAAAAQAAAA4AAAD/AAAABAAAAP8AAAAAAAAA/wAAAAAAAAABAAAACwAAAAEAAAAOAAAA/wAAAAAAAAD/AAAAAAAAAAEAAAALAAAAAQAAAA4AAAAEAAAAAQAAAP8AAAAEAAAAAgAAAAoAAAD/AAAAAAAAAP8AAAAAAAAA/wAAAAAAAAACAAAACgAAAP8AAAAAAAAA/wAAAAAAAAD/AAAAAAAAAAEAAAAPAAAAAgAAAAoAAAD/AAAAAAAAAP8AAAAAAAAAAQAAAA8AAAACAAAACgAAAAQAAAAFAAAA/wAAAAAAAAAEAAAABgAAAP8AAAAAAAAA/wAAAAAAAAD/AAAAAAAAAAQAAAAGAAAA/wAAAAwAAAD/AAAAAAAAAP8AAAAAAAAABAAAAAMAAAAEAAAABgAAAP8AAAAAAAAA/wAAAAAAAAAEAAAAAwAAAAQAAAAGAAAABAAAAAkAAAD/AAAADAAAAP8AAAACAAAA/wAAAAAAAAD/AAAAAAAAAP8AAAAAAAAA/wAAAAIAAAD/AAAACAAAAP8AAAAAAAAA/wAAAAAAAAAEAAAABwAAAP8AAAACAAAA/wAAAAAAAAD/AAAAAAAAAAQAAAAHAAAA/wAAAAIAAAAEAAAADQAAAP8AAAAIAAAAAwAAAA8AAAD/AAAAAAAAAP8AAAAAAAAA/wAAAAAAAAADAAAADwAAAAAAAAAFAAAA/wAAAAAAAAD/AAAAAAAAAAMAAAAPAAAAAQAAAAoAAAD/AAAAAAAAAP8AAAAAAAAAAwAAAA8AAAABAAAACgAAAAAAAAAFAAAABAAAAAAAAAABAAAACwAAAP8AAAAAAAAA/wAAAAAAAAD/AAAAAAAAAAEAAAALAAAABAAAAAEAAAD/AAAAAAAAAP8AAAAAAAAAAQAAAAsAAAABAAAADgAAAP8AAAAAAAAA/wAAAAAAAAABAAAACwAAAAEAAAAOAAAABAAAAAEAAAAEAAAABAAAAAAAAAAHAAAA/wAAAAAAAAD/AAAAAAAAAP8AQdQnCxUHAAAAAAAAAA0AAAD/AAAAAAAAAP8AQfQnCxUHAAAABAAAAAIAAAD/AAAAAAAAAP8AQZQoC9kBBwAAAAQAAAACAAAAAAAAAA0AAAAEAAAACAAAAAQAAAADAAAA/wAAAAAAAAD/AAAAAAAAAP8AAAAAAAAABAAAAAMAAAAEAAAACQAAAP8AAAAAAAAA/wAAAAAAAAAEAAAAAwAAAAQAAAAGAAAA/wAAAAAAAAD/AAAAAAAAAAQAAAADAAAABAAAAAYAAAAEAAAACQAAAAQAAAAMAAAAAAAAAAQAAAAAAAAABAAAAAgAAAAMAAAACAAAAAwAAAAAAAAABAAAAAAAAAAEAAAACAAAAAwAAAAIAAAADABB+CkLBQQAAAAEAEGIKgslBAAAAAQAAAAIAAAACAAAAAwAAAAMAAAACAAAAAgAAAAMAAAADABBsS4LyAYBAgMEBQYHCAkKCwwNDg8QERITFBUWFxgZGhscHR4fICEiIyQlJicoKSorLC0uLzAxMjM0NTY3ODk6Ozw9Pj9AQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVpbXF1eX2BhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ent8fX5/gIGCg4SFhoeIiYqLjI2Oj5CRkpOUlZaXmJmam5ydnp+goaKjpKWmp6ipqqusra6vsLGys7S1tre4ubq7vL2+v8DBwsPExcbHyMnKy8zNzs/Q0dLT1NXW19jZ2tvc3d7f4OHi4+Tl5ufo6err7O3u7/Dx8vP09fb3+Pn6+/z9/v///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////wAAAAABAAAABAAAAAUAAAACAAAAAwAAAAYAAAAHAAAACAAAAAkAAAAMAAAADQAAAAoAAAALAAAADgAAAA8AAAAAAAAAAQAAAAEAQYQ1CyEBAAAAAQAAAAEAAAABAAAAAgAAAAIAAAABAAAAAgAAAAIAQbQ1CwUFAAAABABBxDULyQYHAAAABAAAAAIAAAAEAAAAAQAAAAQAAAAEAAAABAAAAAMAAAAEAAAABgAAAAAAAAANAAAABAAAAAgAAAAAAAAADwAAAAQAAAAKAAAABAAAAAkAAAAEAAAADAAAAAQAAAALAAAABAAAAA4AAAAAAAAAEQAAAAQAAAAQAAAAAAAAABMAAAAEAAAAEgAAAAAAAAAVAAAABAAAABQAAAAAAAAAFwAAAAQAAAAWAAAAAQAAAAoAAAABAAAACwAAAAQAAAAAAAAABAAAAAEAAAABAAAADgAAAAEAAAAPAAAABAAAAAQAAAAEAAAABQAAAAQAAAACAAAABAAAAAMAAAAEAAAACAAAAAQAAAAJAAAABAAAAAYAAAAEAAAABwAAAAQAAAAMAAAABAAAAA0AAAABAAAAEgAAAAEAAAATAAAABAAAABAAAAAEAAAAEQAAAAEAAAAWAAAAAQAAABcAAAAEAAAAFAAAAAQAAAAVAAAAAQAAAAsAAAABAAAADgAAAAQAAAABAAAA/wAAAAQAAAABAAAADwAAAAIAAAAKAAAABAAAAAUAAAD/AAAAAAAAAAQAAAADAAAABAAAAAYAAAAEAAAACQAAAP8AAAAMAAAABAAAAAcAAAD/AAAAAgAAAAQAAAANAAAA/wAAAAgAAAABAAAAEwAAAAIAAAASAAAABAAAABEAAAD/AAAAEAAAAAEAAAAXAAAAAgAAABYAAAAEAAAAFQAAAP8AAAAUAAAAAwAAAA8AAAABAAAACgAAAAAAAAAFAAAABAAAAAAAAAABAAAACwAAAAEAAAAOAAAABAAAAAEAAAAEAAAABAAAAAAAAAAHAAAABAAAAAIAAAAAAAAADQAAAAQAAAAIAAAABAAAAAMAAAAEAAAABgAAAAQAAAAJAAAABAAAAAwAAAADAAAAEwAAAAEAAAASAAAAAAAAABEAAAAEAAAAEAAAAAMAAAAXAAAAAQAAABYAAAAAAAAAFQAAAAQAAAAUAAAAAQAAAAEAAAACAAAAAgAAAAMAAAADAAAAAwAAAAMAAAAAAAAAAQAAAAIAAAADAAAABAAAAAUAAAAGAAAABwAAAAgAAAAJAAAACgAAAAsAAAAMAAAADQAAAA4AAAAPAEGWPAsuAQEBAQEBAgICAgICAwMDAwMDBAQEBAQEBQUFBQUFBgYGBgYGBwcHBwcHCAgICABB0DwLRQoAAAANAAAAEAAAAAsAAAAOAAAAEgAAAA0AAAAQAAAAFAAAAA4AAAASAAAAFwAAABAAAAAUAAAAGQAAABIAAAAXAAAAHQBBoT0LMwECAwQFAAECAwQFAAECAwQFAAECAwQFAAECAwQFAAECAwQFAAECAwQFAAECAwQFAAECAwBB5D0LzAIBAAAAAgAAAAMAAAAEAAAABQAAAAYAAAAHAAAACAAAAAkAAAAKAAAACwAAAAwAAAANAAAADgAAAA8AAAAQAAAAEQAAABIAAAATAAAAFAAAABUAAAAWAAAAFwAAABgAAAAZAAAAGgAAABsAAAAcAAAAHQAAAB0AAAAeAAAAHwAAACAAAAAgAAAAIQAAACIAAAAiAAAAIwAAACMAAAAkAAAAJAAAACUAAAAlAAAAJQAAACYAAAAmAAAAJgAAACcAAAAnAAAAJwAAACcAAAABAAAAAgAAAAQAAAAIAAAAEAAAACAAAABAAAAAgAAAAC8fDwAXGx0eBwsNDicrLS4QAwUKDBMVGhwjJSosAQIECBESFBgGCRYZICEiJCgmKQAQAQIECCADBQoMDy8HCw0OBgkfIyUqLCEiJCgnKy0uERIUGBMVGhwXGx0eFhkmKQ=="},D={};function o(){var A,I=E()({locateFile:function(A){return i[A]}});return(A=I,new Promise((function(I){A.calledRun?I():A.onRuntimeInitialized=function(){return I()}}))).then((function(){self.addEventListener("message",(function(A){var g=A.data,B=g.renderStateId;switch(g.type){case"decode":var C=D[B];C||(C=new Q(I,(function(A,I,g){postMessage({type:"pictureReady",width:I,height:g,renderStateId:B,data:A.buffer},[A.buffer])})),D[B]=C),C.decode(new Uint8Array(g.data,g.offset,g.length));break;case"release":var E=D[B];E&&(E.release(),delete D[B])}})),self.postMessage({type:"decoderReady"})}))}}},I={};function g(B){var Q=I[B];if(void 0!==Q)return Q.exports;var C=I[B]={exports:{}};return A[B](C,C.exports,g),C.exports}g.n=A=>{var I=A&&A.__esModule?()=>A.default:()=>A;return g.d(I,{a:I}),I},g.d=(A,I)=>{for(var B in I)g.o(I,B)&&!g.o(A,B)&&Object.defineProperty(A,B,{enumerable:!0,get:I[B]})},g.o=(A,I)=>Object.prototype.hasOwnProperty.call(A,I),g.r=A=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(A,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(A,"__esModule",{value:!0})},(()=>{"use strict";g(340).init()})()})();',"Worker",void 0,void 0)}},614:A=>{A.exports=function(A,e,I,g){var t=self||window;try{try{var i;try{i=new t.Blob([A])}catch(e){(i=new(t.BlobBuilder||t.WebKitBlobBuilder||t.MozBlobBuilder||t.MSBlobBuilder)).append(A),i=i.getBlob()}var B=t.URL||t.webkitURL,C=B.createObjectURL(i),Q=new t[e](C,I);return B.revokeObjectURL(C),Q}catch(g){return new t[e]("data:application/javascript,".concat(encodeURIComponent(A)),I)}}catch(A){if(!g)throw Error("Inline worker is not supported");return new t[e](g,I)}}}},e={};function I(g){var t=e[g];if(void 0!==t)return t.exports;var i=e[g]={exports:{}};return A[g].call(i.exports,i,i.exports,I),i.exports}return I.n=A=>{var e=A&&A.__esModule?()=>A.default:()=>A;return I.d(e,{a:e}),e},I.d=(A,e)=>{for(var g in e)I.o(e,g)&&!I.o(A,g)&&Object.defineProperty(A,g,{enumerable:!0,get:e[g]})},I.o=(A,e)=>Object.prototype.hasOwnProperty.call(A,e),I.r=A=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(A,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(A,"__esModule",{value:!0})},I(114)})()},6053:A=>{self,A.exports=(()=>{"use strict";var A={114:function(A,e,I){var g=this&&this.__importDefault||function(A){return A&&A.__esModule?A:{default:A}};Object.defineProperty(e,"__esModule",{value:!0});const t=g(I(289));e.default=class{initialize(){return new Promise(((A,e)=>{this.worker=new t.default,this.worker.addEventListener("message",(e=>{var I;const g=e.data;"decoderReady"===g.type?A(0):"decodeDone"===g.type&&(null===(I=this.onDecode)||void 0===I||I.call(this,g))}))}))}startStream(A,e,I){this.worker&&this.worker.postMessage({type:"startStream",sampleRateHz:A,channelCount:e,decodedSamplesPerFrame:I})}stopStream(){this.worker&&this.worker.postMessage({type:"stopStream"})}decode(A,e){this.worker&&this.worker.postMessage({type:"decode",startTimestamp:A,inputData:e},[e])}release(){this.worker&&this.worker.postMessage({type:"release"})}dispose(){this.worker&&(this.worker.terminate(),this.worker=void 0)}}},289:(A,e,I)=>{I.r(e),I.d(e,{default:()=>i});var g=I(614),t=I.n(g);function i(){return t()('(()=>{var A={305:A=>{var I,g=(I="undefined"!=typeof document&&document.currentScript?document.currentScript.src:void 0,function(A){var g,B;(A=void 0!==(A=A||{})?A:{}).ready=new Promise((function(A,I){g=A,B=I}));var Q,C={};for(Q in A)A.hasOwnProperty(Q)&&(C[Q]=A[Q]);var E=[],i="./this.program",D=function(A,I){throw I},o="";"undefined"!=typeof document&&document.currentScript&&(o=document.currentScript.src),I&&(o=I),o=0!==o.indexOf("blob:")?o.substr(0,o.lastIndexOf("/")+1):"";var w,F,G=A.print||console.log.bind(console),R=A.printErr||console.warn.bind(console);for(Q in C)C.hasOwnProperty(Q)&&(A[Q]=C[Q]);C=null,A.arguments&&(E=A.arguments),A.thisProgram&&(i=A.thisProgram),A.quit&&(D=A.quit),A.wasmBinary&&(w=A.wasmBinary),A.noExitRuntime&&(F=A.noExitRuntime),"object"!=typeof WebAssembly&&n("no native wasm support detected");var S=!1;function U(I){var g,B=A["_"+I];return g="Cannot call unknown function "+I+", make sure it is exported",B||n("Assertion failed: "+g),B}function a(A,I,g,B,Q){var C={string:function(A){var I=0;if(null!=A&&0!==A){var g=1+(A.length<<2);!function(A,I,g){J(A,k,I,g)}(A,I=V(g),g)}return I},array:function(A){var I,g,B=V(A.length);return I=A,g=B,s.set(I,g),B}},E=U(A),i=[],D=0;if(B)for(var o=0;o<B.length;o++){var w=C[g[o]];w?(0===D&&(D=X()),i[o]=w(B[o])):i[o]=B[o]}var F=E.apply(null,i);return F=function(A){return"string"===I?H(A):"boolean"===I?Boolean(A):A}(F),0!==D&&Z(D),F}var s,k,h,N="undefined"!=typeof TextDecoder?new TextDecoder("utf8"):void 0;function y(A,I,g){for(var B=I+g,Q=I;A[Q]&&!(Q>=B);)++Q;if(Q-I>16&&A.subarray&&N)return N.decode(A.subarray(I,Q));for(var C="";I<Q;){var E=A[I++];if(128&E){var i=63&A[I++];if(192!=(224&E)){var D=63&A[I++];if((E=224==(240&E)?(15&E)<<12|i<<6|D:(7&E)<<18|i<<12|D<<6|63&A[I++])<65536)C+=String.fromCharCode(E);else{var o=E-65536;C+=String.fromCharCode(55296|o>>10,56320|1023&o)}}else C+=String.fromCharCode((31&E)<<6|i)}else C+=String.fromCharCode(E)}return C}function H(A,I){return A?y(k,A,I):""}function J(A,I,g,B){if(!(B>0))return 0;for(var Q=g,C=g+B-1,E=0;E<A.length;++E){var i=A.charCodeAt(E);if(i>=55296&&i<=57343&&(i=65536+((1023&i)<<10)|1023&A.charCodeAt(++E)),i<=127){if(g>=C)break;I[g++]=i}else if(i<=2047){if(g+1>=C)break;I[g++]=192|i>>6,I[g++]=128|63&i}else if(i<=65535){if(g+2>=C)break;I[g++]=224|i>>12,I[g++]=128|i>>6&63,I[g++]=128|63&i}else{if(g+3>=C)break;I[g++]=240|i>>18,I[g++]=128|i>>12&63,I[g++]=128|i>>6&63,I[g++]=128|63&i}}return I[g]=0,g-Q}function L(A){var I=function(A){for(var I=0,g=0;g<A.length;++g){var B=A.charCodeAt(g);B>=55296&&B<=57343&&(B=65536+((1023&B)<<10)|1023&A.charCodeAt(++g)),B<=127?++I:I+=B<=2047?2:B<=65535?3:4}return I}(A)+1,g=V(I);return J(A,s,g,I),g}A.INITIAL_MEMORY;var q,M=[],K=[],c=[],Y=[];K.push({func:function(){l()}});var d=0,P=null,t=null;function n(I){A.onAbort&&A.onAbort(I),R(I+=""),S=!0,I="abort("+I+"). Build with -s ASSERTIONS=1 for more info.";var g=new WebAssembly.RuntimeError(I);throw B(g),g}A.preloadedImages={},A.preloadedAudios={};var r="data:application/octet-stream;base64,";function f(A){return I=A,g=r,String.prototype.startsWith?I.startsWith(g):0===I.indexOf(g);var I,g}var W,b="data:application/octet-stream;base64,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AXgB2AEEAGQAxAAkAYQBJACEAOQARAGkAUQApAAEAWQBxAEMAGwAzAAsAYwBLACMAOwATAGsAUwArAAMAWwBzAEUAHQA1AA0AZQBNACUAPQAVAG0AVQAtAAUAXQB1AEcAHwA3AA8AZwBPACcAPwAXAG8AVwAvAAcAXwB3AEBAGEAwQAhAYEBIQCBAOEAQQGhAUEAoQABAWEBwQEJAGkAyQApAYkBKQCJAOkASQGpAUkAqQAJAWkByQERAHEA0QAxAZEBMQCRAPEAUQGxAVEAsQARAXEB0QEZAHkA2QA5AZkBOQCZAPkAWQG5AVkAuQAZAXkB2QEFAGUAxQAlAYUBJQCFAOUARQGlAUUApQAFAWUBxQENAG0AzQAtAY0BLQCNAO0ATQGtAU0ArQANAW0BzQEVAHUA1QA1AZUBNQCVAPUAVQG1AVUAtQAVAXUB1QEdAH0A3QA9AZ0BPQCdAP0AXQG9AV0AvQAdAX0B3QECAGIAwgAiAYIBIgCCAOIAQgGiAUIAogACAWIBwgEKAGoAygAqAYoBKgCKAOoASgGqAUoAqgAKAWoBygESAHIA0gAyAZIBMgCSAPIAUgGyAVIAsgASAXIB0gEaAHoA2gA6AZoBOgCaAPoAWgG6AVoAugAaAXoB2gEGAGYAxgAmAYYBJgCGAOYARgGmAUYApgAGAWYBxgEOAG4AzgAuAY4BLgCOAO4ATgGuAU4ArgAOAW4BzgEWAHYA1gA2AZYBNgCWAPYAVgG2AVYAtgAWAXYB1gEeAH4A3gA+AZ4BPgCeAP4AXgG+AV4AvgAeAX4B3gEDAGMAwwAjAYMBIwCDAOMAQwGjAUMAowADAWMBwwELAGsAywArAYsBKwCLAOsASwGrAUsAqwALAWsBywETAHMA0wAzAZMBMwCTAPMAUwGzAVMAswATAXMB0wEbAHsA2wA7AZsBOwCbAPsAWwG7AVsAuwAbAXsB2wEHAGcAxwAnAYcBJwCHAOcARwGnAUcApwAHAWcBxwEPAG8AzwAvAY8BLwCPAO8ATwGvAU8ArwAPAW8BzwEXAHcA1wA3AZcBNwCXAPcAVwG3AVcAtwAXAXcB1wEfAH8A3wA/AZ8BPwCfAP8AXwG/AV8AvwAfAX8B3wEAAIA/AAAAgGP6fz+/dVa8i+l/Pwpx1rx5zX8/584gvS+mfz86Xla9r3N/PxPyhb35NX8/Kq+g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PjB8dD9M1Jc+NnV1P3VqkT53Y3Y/PvqKPupGdz/ug4Q+hB94P5wPfD487Xg/TQxvPgmweT+C/mE+4md6P83mVD6+FHs/wsVHPpi2ez/zmzo+Z018P/VpLT4l2Xw/XDAgPstZfT+77xI+Vc99P6ioBT68OX4/c7fwPf2Yfj8EE9Y9Eu1+PzNluz35NX8/Kq+gPa9zfz8T8oU9L6Z/PzpeVj15zX8/584gPYvpfz8KcdY8Y/p/P791VjwAADAAYACQAMAAEABAAHAAoADQACAAUACAALAA4AAEADQAZACUAMQAFABEAHQApADUACQAVACEALQA5AAIADgAaACYAMgAGABIAHgAqADYACgAWACIALgA6AAMADwAbACcAMwAHABMAHwArADcACwAXACMALwA7AABADEAYQCRAMEAEQBBAHEAoQDRACEAUQCBALEA4QAFADUAZQCVAMUAFQBFAHUApQDVACUAVQCFALUA5QAJADkAaQCZAMkAGQBJAHkAqQDZACkAWQCJALkA6QANAD0AbQCdAM0AHQBNAH0ArQDdAC0AXQCNAL0A7QACADIAYgCSAMIAEgBCAHIAogDSACIAUgCCALIA4gAGADYAZgCWAMYAFgBGAHYApgDWACYAVgCGALYA5gAKADoAagCaAMoAGgBKAHoAqgDaACoAWgCKALoA6gAOAD4AbgCeAM4AHgBOAH4ArgDeAC4AXgCOAL4A7gADADMAYwCTAMMAEwBDAHMAowDTACMAUwCDALMA4wAHADcAZwCXAMcAFwBHAHcApwDXACcAVwCHALcA5wALADsAawCbAMsAGwBLAHsAqwDbACsAWwCLALsA6wAPAD8AbwCfAM8AHwBPAH8ArwDfAC8AXwCPAL8A7wDwAAAAiYiIOwEAAAAFADAAAwAQAAQABAAEAAEAQYytAQsGgFQAAIBFAEGirQELiQIYADAASABgAAgAIAA4AFAAaAAQACgAQABYAHAABAAcADQATABkAAwAJAA8AFQAbAAUACwARABcAHQAAQAZADEASQBhAAkAIQA5AFEAaQARACkAQQBZAHEABQAdADUATQBlAA0AJQA9AFUAbQAVAC0ARQBdAHUAAgAaADIASgBiAAoAIgA6AFIAagASACoAQgBaAHIABgAeADYATgBmAA4AJgA+AFYAbgAWAC4ARgBeAHYAAwAbADMASwBjAAsAIwA7AFMAawATACsAQwBbAHMABwAfADcATwBnAA8AJwA/AFcAbwAXAC8ARwBfAHcAeAAAAIiICDwCAAAABQAYAAMACAACAAQABAABAEG8rwELBqBWAACARQBB0q8BC40BDAAYACQAMAAEABAAHAAoADQACAAUACAALAA4AAEADQAZACUAMQAFABEAHQApADUACQAVACEALQA5AAIADgAaACYAMgAGABIAHgAqADYACgAWACIALgA6AAMADwAbACcAMwAHABMAHwArADcACwAXACMALwA7ADwAAACJiIg8AwAAAAUADAADAAQABAABAEH0sAELTdBXAACARQAAAAAAAMBYAACAWwAAPF4AAPRgAACoYwAAWGYAAARpAABsagAAKGsAAJxrAADoawAAIGwAAEBsAABYbAAAZGwAAAAAAAABAEGEtwELoCMBAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAA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";function e(A){try{if(A==b&&w)return new Uint8Array(w);var I=function(A){if(f(A))return function(A){try{for(var I=p(A),g=new Uint8Array(I.length),B=0;B<I.length;++B)g[B]=I.charCodeAt(B);return g}catch(A){throw new Error("Converting base64 string to bytes failed.")}}(A.slice(r.length))}(A);if(I)return I;throw"both async and sync fetching of the wasm failed"}catch(A){n(A)}}function x(I){for(;I.length>0;){var g=I.shift();if("function"!=typeof g){var B=g.func;"number"==typeof B?void 0===g.arg?q.get(B)():q.get(B)(g.arg):B(void 0===g.arg?null:g.arg)}else g(A)}}f(b)||(W=b,b=A.locateFile?A.locateFile(W,o):o+W);var v={mappings:{},buffers:[null,[],[]],printChar:function(A,I){var g=v.buffers[A];0===I||10===I?((1===A?G:R)(y(g,0)),g.length=0):g.push(I)},varargs:void 0,get:function(){return v.varargs+=4,h[v.varargs-4>>2]},getStr:function(A){return H(A)},get64:function(A,I){return A}},p="function"==typeof atob?atob:function(A){var I,g,B,Q,C,E,i="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",D="",o=0;A=A.replace(/[^A-Za-z0-9\\+\\/\\=]/g,"");do{I=i.indexOf(A.charAt(o++))<<2|(Q=i.indexOf(A.charAt(o++)))>>4,g=(15&Q)<<4|(C=i.indexOf(A.charAt(o++)))>>2,B=(3&C)<<6|(E=i.indexOf(A.charAt(o++))),D+=String.fromCharCode(I),64!==C&&(D+=String.fromCharCode(g)),64!==E&&(D+=String.fromCharCode(B))}while(o<A.length);return D};var T,O={b:function(A,I,g){k.copyWithin(A,I,I+g)},c:function(A){n("OOM")},a:function(A,I,g,B){for(var Q=0,C=0;C<g;C++){for(var E=h[I+8*C>>2],i=h[I+(8*C+4)>>2],D=0;D<i;D++)v.printChar(A,k[E+D]);Q+=i}return h[B>>2]=Q,0}},l=(function(){var I={a:O};function g(I,g){var B,Q=I.exports;A.asm=Q,B=A.asm.d.buffer,A.HEAP8=s=new Int8Array(B),A.HEAP16=new Int16Array(B),A.HEAP32=h=new Int32Array(B),A.HEAPU8=k=new Uint8Array(B),A.HEAPU16=new Uint16Array(B),A.HEAPU32=new Uint32Array(B),A.HEAPF32=new Float32Array(B),A.HEAPF64=new Float64Array(B),q=A.asm.e,function(I){if(d--,A.monitorRunDependencies&&A.monitorRunDependencies(d),0==d&&(null!==P&&(clearInterval(P),P=null),t)){var g=t;t=null,g()}}()}function Q(A){g(A.instance)}function C(A){return(w||"function"!=typeof fetch?Promise.resolve().then((function(){return e(b)})):fetch(b,{credentials:"same-origin"}).then((function(A){if(!A.ok)throw"failed to load wasm binary file at \'"+b+"\'";return A.arrayBuffer()})).catch((function(){return e(b)}))).then((function(A){return WebAssembly.instantiate(A,I)})).then(A,(function(A){R("failed to asynchronously prepare wasm: "+A),n(A)}))}if(d++,A.monitorRunDependencies&&A.monitorRunDependencies(d),A.instantiateWasm)try{return A.instantiateWasm(I,g)}catch(A){return R("Module.instantiateWasm callback failed with error: "+A),!1}(w||"function"!=typeof WebAssembly.instantiateStreaming||f(b)||"function"!=typeof fetch?C(Q):fetch(b,{credentials:"same-origin"}).then((function(A){return WebAssembly.instantiateStreaming(A,I).then(Q,(function(A){return R("wasm streaming compile failed: "+A),R("falling back to ArrayBuffer instantiation"),C(Q)}))}))).catch(B)}(),A.___wasm_call_ctors=function(){return(l=A.___wasm_call_ctors=A.asm.f).apply(null,arguments)}),X=(A._stopStream=function(){return(A._stopStream=A.asm.g).apply(null,arguments)},A._startStream=function(){return(A._startStream=A.asm.h).apply(null,arguments)},A._decode=function(){return(A._decode=A.asm.i).apply(null,arguments)},A._createBuffer=function(){return(A._createBuffer=A.asm.j).apply(null,arguments)},A._freeBuffer=function(){return(A._freeBuffer=A.asm.k).apply(null,arguments)},A._main=function(){return(A._main=A.asm.l).apply(null,arguments)},A.stackSave=function(){return(X=A.stackSave=A.asm.m).apply(null,arguments)}),Z=A.stackRestore=function(){return(Z=A.stackRestore=A.asm.n).apply(null,arguments)},V=A.stackAlloc=function(){return(V=A.stackAlloc=A.asm.o).apply(null,arguments)};function z(A){this.name="ExitStatus",this.message="Program terminated with exit("+A+")",this.status=A}function j(I){function B(){T||(T=!0,A.calledRun=!0,S||(x(K),x(c),g(A),A.onRuntimeInitialized&&A.onRuntimeInitialized(),u&&function(I){var g,B=A._main,Q=(I=I||[]).length+1,C=V(4*(Q+1));h[C>>2]=L(i);for(var E=1;E<Q;E++)h[(C>>2)+E]=L(I[E-1]);h[(C>>2)+Q]=0;try{g=B(Q,C),F&&0===g||(F||(A.onExit&&A.onExit(g),S=!0),D(g,new z(g)))}catch(A){if(A instanceof z)return;if("unwind"==A)return void(F=!0);var o=A;A&&"object"==typeof A&&A.stack&&(o=[A,A.stack]),R("exception thrown: "+o),D(1,A)}}(I),function(){if(A.postRun)for("function"==typeof A.postRun&&(A.postRun=[A.postRun]);A.postRun.length;)I=A.postRun.shift(),Y.unshift(I);var I;x(Y)}()))}I=I||E,d>0||(function(){if(A.preRun)for("function"==typeof A.preRun&&(A.preRun=[A.preRun]);A.preRun.length;)I=A.preRun.shift(),M.unshift(I);var I;x(M)}(),d>0||(A.setStatus?(A.setStatus("Running..."),setTimeout((function(){setTimeout((function(){A.setStatus("")}),1),B()}),1)):B()))}if(A.cwrap=function(A,I,g,B){var Q=(g=g||[]).every((function(A){return"number"===A}));return"string"!==I&&Q&&!B?U(A):function(){return a(A,I,g,arguments)}},t=function A(){T||j(),T||(t=A)},A.run=j,A.preInit)for("function"==typeof A.preInit&&(A.preInit=[A.preInit]);A.preInit.length>0;)A.preInit.pop()();var u=!0;return A.noInitialRun&&(u=!1),F=!0,j(),A.ready});A.exports=g}},I={};function g(B){var Q=I[B];if(void 0!==Q)return Q.exports;var C=I[B]={exports:{}};return A[B](C,C.exports,g),C.exports}g.n=A=>{var I=A&&A.__esModule?()=>A.default:()=>A;return g.d(I,{a:I}),I},g.d=(A,I)=>{for(var B in I)g.o(I,B)&&!g.o(A,B)&&Object.defineProperty(A,B,{enumerable:!0,get:I[B]})},g.o=(A,I)=>Object.prototype.hasOwnProperty.call(A,I),(()=>{"use strict";var A,I=g(305),B=g.n(I),Q=0,C=0,E=0,i=0,D=0,o=0;!async function(){A=await B()(),self.addEventListener("message",(async function(I){var g=I.data;switch(g.type){case"startStream":o=g.decodedSamplesPerFrame,D=o*g.channelCount,A._startStream(g.sampleRateHz,g.channelCount);break;case"stopStream":A._stopStream();break;case"decode":{const I=g.startTimestamp,B=function(I){const g=I.byteLength;return 0!=Q&&C<g&&(A._freeBuffer(Q),Q=0,C=0),0==Q&&(Q=A._createBuffer(I.BYTES_PER_ELEMENT*g),C=g),A.HEAPU8.set(I,Q),Q}(new Uint8Array(g.inputData)),w=(0!=E&&i<D&&(A._freeBuffer(E),E=0,i=0),0==E&&(E=A._createBuffer(Float32Array.BYTES_PER_ELEMENT*D),i=D),E),F=new Float32Array(A.HEAPF32.buffer,w,D),G=A._decode(B,g.inputData.byteLength,w,o),R=F.buffer.slice(w,w+D*F.BYTES_PER_ELEMENT);postMessage({type:"decodeDone",startTimestamp:I,outputData:R,samplesDecoded:G},[R]);break}case"release":0!=Q&&(A._freeBuffer(Q),Q=0,C=0),0!=E&&(A._freeBuffer(E),E=0,i=0),A._stopStream()}})),postMessage({type:"decoderReady"})}()})()})();',"Worker",void 0,void 0)}},614:A=>{A.exports=function(A,e,I,g){var t=self||window;try{try{var i;try{i=new t.Blob([A])}catch(e){(i=new(t.BlobBuilder||t.WebKitBlobBuilder||t.MozBlobBuilder||t.MSBlobBuilder)).append(A),i=i.getBlob()}var B=t.URL||t.webkitURL,C=B.createObjectURL(i),Q=new t[e](C,I);return B.revokeObjectURL(C),Q}catch(g){return new t[e]("data:application/javascript,".concat(encodeURIComponent(A)),I)}}catch(A){if(!g)throw Error("Inline worker is not supported");return new t[e](g,I)}}}},e={};function I(g){var t=e[g];if(void 0!==t)return t.exports;var i=e[g]={exports:{}};return A[g].call(i.exports,i,i.exports,I),i.exports}return I.n=A=>{var e=A&&A.__esModule?()=>A.default:()=>A;return I.d(e,{a:e}),e},I.d=(A,e)=>{for(var g in e)I.o(e,g)&&!I.o(A,g)&&Object.defineProperty(A,g,{enumerable:!0,get:e[g]})},I.o=(A,e)=>Object.prototype.hasOwnProperty.call(A,e),I.r=A=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(A,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(A,"__esModule",{value:!0})},I(114)})()},973:(A,e,I)=>{"use strict";var g=["BigInt64Array","BigUint64Array","Float32Array","Float64Array","Int16Array","Int32Array","Int8Array","Uint16Array","Uint32Array","Uint8Array","Uint8ClampedArray"],t="undefined"==typeof globalThis?I.g:globalThis;A.exports=function(){for(var A=[],e=0;e<g.length;e++)"function"==typeof t[g[e]]&&(A[A.length]=g[e]);return A}},8828:(A,e,I)=>{"use strict";var g=I(8750)("%Object.getOwnPropertyDescriptor%",!0);if(g)try{g([],"length")}catch(A){g=null}A.exports=g}},e={};function I(g){var t=e[g];if(void 0!==t)return t.exports;var i=e[g]={exports:{}};return A[g].call(i.exports,i,i.exports,I),i.exports}return I.g=function(){if("object"==typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch(A){if("object"==typeof window)return window}}(),I(5014)})()}));

/***/ }),

/***/ "./node_modules/react-dom/cjs/react-dom.development.js":
/*!*************************************************************!*\
  !*** ./node_modules/react-dom/cjs/react-dom.development.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/** @license React v17.0.2
 * react-dom.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



if (true) {
  (function() {
'use strict';

var React = __webpack_require__(/*! react */ "./node_modules/react/index.js");
var _assign = __webpack_require__(/*! object-assign */ "./node_modules/object-assign/index.js");
var Scheduler = __webpack_require__(/*! scheduler */ "./node_modules/scheduler/index.js");
var tracing = __webpack_require__(/*! scheduler/tracing */ "./node_modules/scheduler/tracing.js");

var ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;

// by calls to these methods by a Babel plugin.
//
// In PROD (or in packages without access to React internals),
// they are left as they are instead.

function warn(format) {
  {
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }

    printWarning('warn', format, args);
  }
}
function error(format) {
  {
    for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
      args[_key2 - 1] = arguments[_key2];
    }

    printWarning('error', format, args);
  }
}

function printWarning(level, format, args) {
  // When changing this logic, you might want to also
  // update consoleWithStackDev.www.js as well.
  {
    var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
    var stack = ReactDebugCurrentFrame.getStackAddendum();

    if (stack !== '') {
      format += '%s';
      args = args.concat([stack]);
    }

    var argsWithFormat = args.map(function (item) {
      return '' + item;
    }); // Careful: RN currently depends on this prefix

    argsWithFormat.unshift('Warning: ' + format); // We intentionally don't use spread (or .apply) directly because it
    // breaks IE9: https://github.com/facebook/react/issues/13610
    // eslint-disable-next-line react-internal/no-production-logging

    Function.prototype.apply.call(console[level], console, argsWithFormat);
  }
}

if (!React) {
  {
    throw Error( "ReactDOM was loaded before React. Make sure you load the React package before loading ReactDOM." );
  }
}

var FunctionComponent = 0;
var ClassComponent = 1;
var IndeterminateComponent = 2; // Before we know whether it is function or class

var HostRoot = 3; // Root of a host tree. Could be nested inside another node.

var HostPortal = 4; // A subtree. Could be an entry point to a different renderer.

var HostComponent = 5;
var HostText = 6;
var Fragment = 7;
var Mode = 8;
var ContextConsumer = 9;
var ContextProvider = 10;
var ForwardRef = 11;
var Profiler = 12;
var SuspenseComponent = 13;
var MemoComponent = 14;
var SimpleMemoComponent = 15;
var LazyComponent = 16;
var IncompleteClassComponent = 17;
var DehydratedFragment = 18;
var SuspenseListComponent = 19;
var FundamentalComponent = 20;
var ScopeComponent = 21;
var Block = 22;
var OffscreenComponent = 23;
var LegacyHiddenComponent = 24;

// Filter certain DOM attributes (e.g. src, href) if their values are empty strings.

var enableProfilerTimer = true; // Record durations for commit and passive effects phases.

var enableFundamentalAPI = false; // Experimental Scope support.
var enableNewReconciler = false; // Errors that are thrown while unmounting (or after in the case of passive effects)
var warnAboutStringRefs = false;

var allNativeEvents = new Set();
/**
 * Mapping from registration name to event name
 */


var registrationNameDependencies = {};
/**
 * Mapping from lowercase registration names to the properly cased version,
 * used to warn in the case of missing event handlers. Available
 * only in true.
 * @type {Object}
 */

var possibleRegistrationNames =  {} ; // Trust the developer to only use possibleRegistrationNames in true

function registerTwoPhaseEvent(registrationName, dependencies) {
  registerDirectEvent(registrationName, dependencies);
  registerDirectEvent(registrationName + 'Capture', dependencies);
}
function registerDirectEvent(registrationName, dependencies) {
  {
    if (registrationNameDependencies[registrationName]) {
      error('EventRegistry: More than one plugin attempted to publish the same ' + 'registration name, `%s`.', registrationName);
    }
  }

  registrationNameDependencies[registrationName] = dependencies;

  {
    var lowerCasedName = registrationName.toLowerCase();
    possibleRegistrationNames[lowerCasedName] = registrationName;

    if (registrationName === 'onDoubleClick') {
      possibleRegistrationNames.ondblclick = registrationName;
    }
  }

  for (var i = 0; i < dependencies.length; i++) {
    allNativeEvents.add(dependencies[i]);
  }
}

var canUseDOM = !!(typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined');

// A reserved attribute.
// It is handled by React separately and shouldn't be written to the DOM.
var RESERVED = 0; // A simple string attribute.
// Attributes that aren't in the filter are presumed to have this type.

var STRING = 1; // A string attribute that accepts booleans in React. In HTML, these are called
// "enumerated" attributes with "true" and "false" as possible values.
// When true, it should be set to a "true" string.
// When false, it should be set to a "false" string.

var BOOLEANISH_STRING = 2; // A real boolean attribute.
// When true, it should be present (set either to an empty string or its name).
// When false, it should be omitted.

var BOOLEAN = 3; // An attribute that can be used as a flag as well as with a value.
// When true, it should be present (set either to an empty string or its name).
// When false, it should be omitted.
// For any other value, should be present with that value.

var OVERLOADED_BOOLEAN = 4; // An attribute that must be numeric or parse as a numeric.
// When falsy, it should be removed.

var NUMERIC = 5; // An attribute that must be positive numeric or parse as a positive numeric.
// When falsy, it should be removed.

var POSITIVE_NUMERIC = 6;

/* eslint-disable max-len */
var ATTRIBUTE_NAME_START_CHAR = ":A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD";
/* eslint-enable max-len */

var ATTRIBUTE_NAME_CHAR = ATTRIBUTE_NAME_START_CHAR + "\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040";
var ROOT_ATTRIBUTE_NAME = 'data-reactroot';
var VALID_ATTRIBUTE_NAME_REGEX = new RegExp('^[' + ATTRIBUTE_NAME_START_CHAR + '][' + ATTRIBUTE_NAME_CHAR + ']*$');
var hasOwnProperty = Object.prototype.hasOwnProperty;
var illegalAttributeNameCache = {};
var validatedAttributeNameCache = {};
function isAttributeNameSafe(attributeName) {
  if (hasOwnProperty.call(validatedAttributeNameCache, attributeName)) {
    return true;
  }

  if (hasOwnProperty.call(illegalAttributeNameCache, attributeName)) {
    return false;
  }

  if (VALID_ATTRIBUTE_NAME_REGEX.test(attributeName)) {
    validatedAttributeNameCache[attributeName] = true;
    return true;
  }

  illegalAttributeNameCache[attributeName] = true;

  {
    error('Invalid attribute name: `%s`', attributeName);
  }

  return false;
}
function shouldIgnoreAttribute(name, propertyInfo, isCustomComponentTag) {
  if (propertyInfo !== null) {
    return propertyInfo.type === RESERVED;
  }

  if (isCustomComponentTag) {
    return false;
  }

  if (name.length > 2 && (name[0] === 'o' || name[0] === 'O') && (name[1] === 'n' || name[1] === 'N')) {
    return true;
  }

  return false;
}
function shouldRemoveAttributeWithWarning(name, value, propertyInfo, isCustomComponentTag) {
  if (propertyInfo !== null && propertyInfo.type === RESERVED) {
    return false;
  }

  switch (typeof value) {
    case 'function': // $FlowIssue symbol is perfectly valid here

    case 'symbol':
      // eslint-disable-line
      return true;

    case 'boolean':
      {
        if (isCustomComponentTag) {
          return false;
        }

        if (propertyInfo !== null) {
          return !propertyInfo.acceptsBooleans;
        } else {
          var prefix = name.toLowerCase().slice(0, 5);
          return prefix !== 'data-' && prefix !== 'aria-';
        }
      }

    default:
      return false;
  }
}
function shouldRemoveAttribute(name, value, propertyInfo, isCustomComponentTag) {
  if (value === null || typeof value === 'undefined') {
    return true;
  }

  if (shouldRemoveAttributeWithWarning(name, value, propertyInfo, isCustomComponentTag)) {
    return true;
  }

  if (isCustomComponentTag) {
    return false;
  }

  if (propertyInfo !== null) {

    switch (propertyInfo.type) {
      case BOOLEAN:
        return !value;

      case OVERLOADED_BOOLEAN:
        return value === false;

      case NUMERIC:
        return isNaN(value);

      case POSITIVE_NUMERIC:
        return isNaN(value) || value < 1;
    }
  }

  return false;
}
function getPropertyInfo(name) {
  return properties.hasOwnProperty(name) ? properties[name] : null;
}

function PropertyInfoRecord(name, type, mustUseProperty, attributeName, attributeNamespace, sanitizeURL, removeEmptyString) {
  this.acceptsBooleans = type === BOOLEANISH_STRING || type === BOOLEAN || type === OVERLOADED_BOOLEAN;
  this.attributeName = attributeName;
  this.attributeNamespace = attributeNamespace;
  this.mustUseProperty = mustUseProperty;
  this.propertyName = name;
  this.type = type;
  this.sanitizeURL = sanitizeURL;
  this.removeEmptyString = removeEmptyString;
} // When adding attributes to this list, be sure to also add them to
// the `possibleStandardNames` module to ensure casing and incorrect
// name warnings.


var properties = {}; // These props are reserved by React. They shouldn't be written to the DOM.

var reservedProps = ['children', 'dangerouslySetInnerHTML', // TODO: This prevents the assignment of defaultValue to regular
// elements (not just inputs). Now that ReactDOMInput assigns to the
// defaultValue property -- do we need this?
'defaultValue', 'defaultChecked', 'innerHTML', 'suppressContentEditableWarning', 'suppressHydrationWarning', 'style'];
reservedProps.forEach(function (name) {
  properties[name] = new PropertyInfoRecord(name, RESERVED, false, // mustUseProperty
  name, // attributeName
  null, // attributeNamespace
  false, // sanitizeURL
  false);
}); // A few React string attributes have a different name.
// This is a mapping from React prop names to the attribute names.

[['acceptCharset', 'accept-charset'], ['className', 'class'], ['htmlFor', 'for'], ['httpEquiv', 'http-equiv']].forEach(function (_ref) {
  var name = _ref[0],
      attributeName = _ref[1];
  properties[name] = new PropertyInfoRecord(name, STRING, false, // mustUseProperty
  attributeName, // attributeName
  null, // attributeNamespace
  false, // sanitizeURL
  false);
}); // These are "enumerated" HTML attributes that accept "true" and "false".
// In React, we let users pass `true` and `false` even though technically
// these aren't boolean attributes (they are coerced to strings).

['contentEditable', 'draggable', 'spellCheck', 'value'].forEach(function (name) {
  properties[name] = new PropertyInfoRecord(name, BOOLEANISH_STRING, false, // mustUseProperty
  name.toLowerCase(), // attributeName
  null, // attributeNamespace
  false, // sanitizeURL
  false);
}); // These are "enumerated" SVG attributes that accept "true" and "false".
// In React, we let users pass `true` and `false` even though technically
// these aren't boolean attributes (they are coerced to strings).
// Since these are SVG attributes, their attribute names are case-sensitive.

['autoReverse', 'externalResourcesRequired', 'focusable', 'preserveAlpha'].forEach(function (name) {
  properties[name] = new PropertyInfoRecord(name, BOOLEANISH_STRING, false, // mustUseProperty
  name, // attributeName
  null, // attributeNamespace
  false, // sanitizeURL
  false);
}); // These are HTML boolean attributes.

['allowFullScreen', 'async', // Note: there is a special case that prevents it from being written to the DOM
// on the client side because the browsers are inconsistent. Instead we call focus().
'autoFocus', 'autoPlay', 'controls', 'default', 'defer', 'disabled', 'disablePictureInPicture', 'disableRemotePlayback', 'formNoValidate', 'hidden', 'loop', 'noModule', 'noValidate', 'open', 'playsInline', 'readOnly', 'required', 'reversed', 'scoped', 'seamless', // Microdata
'itemScope'].forEach(function (name) {
  properties[name] = new PropertyInfoRecord(name, BOOLEAN, false, // mustUseProperty
  name.toLowerCase(), // attributeName
  null, // attributeNamespace
  false, // sanitizeURL
  false);
}); // These are the few React props that we set as DOM properties
// rather than attributes. These are all booleans.

['checked', // Note: `option.selected` is not updated if `select.multiple` is
// disabled with `removeAttribute`. We have special logic for handling this.
'multiple', 'muted', 'selected' // NOTE: if you add a camelCased prop to this list,
// you'll need to set attributeName to name.toLowerCase()
// instead in the assignment below.
].forEach(function (name) {
  properties[name] = new PropertyInfoRecord(name, BOOLEAN, true, // mustUseProperty
  name, // attributeName
  null, // attributeNamespace
  false, // sanitizeURL
  false);
}); // These are HTML attributes that are "overloaded booleans": they behave like
// booleans, but can also accept a string value.

['capture', 'download' // NOTE: if you add a camelCased prop to this list,
// you'll need to set attributeName to name.toLowerCase()
// instead in the assignment below.
].forEach(function (name) {
  properties[name] = new PropertyInfoRecord(name, OVERLOADED_BOOLEAN, false, // mustUseProperty
  name, // attributeName
  null, // attributeNamespace
  false, // sanitizeURL
  false);
}); // These are HTML attributes that must be positive numbers.

['cols', 'rows', 'size', 'span' // NOTE: if you add a camelCased prop to this list,
// you'll need to set attributeName to name.toLowerCase()
// instead in the assignment below.
].forEach(function (name) {
  properties[name] = new PropertyInfoRecord(name, POSITIVE_NUMERIC, false, // mustUseProperty
  name, // attributeName
  null, // attributeNamespace
  false, // sanitizeURL
  false);
}); // These are HTML attributes that must be numbers.

['rowSpan', 'start'].forEach(function (name) {
  properties[name] = new PropertyInfoRecord(name, NUMERIC, false, // mustUseProperty
  name.toLowerCase(), // attributeName
  null, // attributeNamespace
  false, // sanitizeURL
  false);
});
var CAMELIZE = /[\-\:]([a-z])/g;

var capitalize = function (token) {
  return token[1].toUpperCase();
}; // This is a list of all SVG attributes that need special casing, namespacing,
// or boolean value assignment. Regular attributes that just accept strings
// and have the same names are omitted, just like in the HTML attribute filter.
// Some of these attributes can be hard to find. This list was created by
// scraping the MDN documentation.


['accent-height', 'alignment-baseline', 'arabic-form', 'baseline-shift', 'cap-height', 'clip-path', 'clip-rule', 'color-interpolation', 'color-interpolation-filters', 'color-profile', 'color-rendering', 'dominant-baseline', 'enable-background', 'fill-opacity', 'fill-rule', 'flood-color', 'flood-opacity', 'font-family', 'font-size', 'font-size-adjust', 'font-stretch', 'font-style', 'font-variant', 'font-weight', 'glyph-name', 'glyph-orientation-horizontal', 'glyph-orientation-vertical', 'horiz-adv-x', 'horiz-origin-x', 'image-rendering', 'letter-spacing', 'lighting-color', 'marker-end', 'marker-mid', 'marker-start', 'overline-position', 'overline-thickness', 'paint-order', 'panose-1', 'pointer-events', 'rendering-intent', 'shape-rendering', 'stop-color', 'stop-opacity', 'strikethrough-position', 'strikethrough-thickness', 'stroke-dasharray', 'stroke-dashoffset', 'stroke-linecap', 'stroke-linejoin', 'stroke-miterlimit', 'stroke-opacity', 'stroke-width', 'text-anchor', 'text-decoration', 'text-rendering', 'underline-position', 'underline-thickness', 'unicode-bidi', 'unicode-range', 'units-per-em', 'v-alphabetic', 'v-hanging', 'v-ideographic', 'v-mathematical', 'vector-effect', 'vert-adv-y', 'vert-origin-x', 'vert-origin-y', 'word-spacing', 'writing-mode', 'xmlns:xlink', 'x-height' // NOTE: if you add a camelCased prop to this list,
// you'll need to set attributeName to name.toLowerCase()
// instead in the assignment below.
].forEach(function (attributeName) {
  var name = attributeName.replace(CAMELIZE, capitalize);
  properties[name] = new PropertyInfoRecord(name, STRING, false, // mustUseProperty
  attributeName, null, // attributeNamespace
  false, // sanitizeURL
  false);
}); // String SVG attributes with the xlink namespace.

['xlink:actuate', 'xlink:arcrole', 'xlink:role', 'xlink:show', 'xlink:title', 'xlink:type' // NOTE: if you add a camelCased prop to this list,
// you'll need to set attributeName to name.toLowerCase()
// instead in the assignment below.
].forEach(function (attributeName) {
  var name = attributeName.replace(CAMELIZE, capitalize);
  properties[name] = new PropertyInfoRecord(name, STRING, false, // mustUseProperty
  attributeName, 'http://www.w3.org/1999/xlink', false, // sanitizeURL
  false);
}); // String SVG attributes with the xml namespace.

['xml:base', 'xml:lang', 'xml:space' // NOTE: if you add a camelCased prop to this list,
// you'll need to set attributeName to name.toLowerCase()
// instead in the assignment below.
].forEach(function (attributeName) {
  var name = attributeName.replace(CAMELIZE, capitalize);
  properties[name] = new PropertyInfoRecord(name, STRING, false, // mustUseProperty
  attributeName, 'http://www.w3.org/XML/1998/namespace', false, // sanitizeURL
  false);
}); // These attribute exists both in HTML and SVG.
// The attribute name is case-sensitive in SVG so we can't just use
// the React name like we do for attributes that exist only in HTML.

['tabIndex', 'crossOrigin'].forEach(function (attributeName) {
  properties[attributeName] = new PropertyInfoRecord(attributeName, STRING, false, // mustUseProperty
  attributeName.toLowerCase(), // attributeName
  null, // attributeNamespace
  false, // sanitizeURL
  false);
}); // These attributes accept URLs. These must not allow javascript: URLS.
// These will also need to accept Trusted Types object in the future.

var xlinkHref = 'xlinkHref';
properties[xlinkHref] = new PropertyInfoRecord('xlinkHref', STRING, false, // mustUseProperty
'xlink:href', 'http://www.w3.org/1999/xlink', true, // sanitizeURL
false);
['src', 'href', 'action', 'formAction'].forEach(function (attributeName) {
  properties[attributeName] = new PropertyInfoRecord(attributeName, STRING, false, // mustUseProperty
  attributeName.toLowerCase(), // attributeName
  null, // attributeNamespace
  true, // sanitizeURL
  true);
});

// and any newline or tab are filtered out as if they're not part of the URL.
// https://url.spec.whatwg.org/#url-parsing
// Tab or newline are defined as \r\n\t:
// https://infra.spec.whatwg.org/#ascii-tab-or-newline
// A C0 control is a code point in the range \u0000 NULL to \u001F
// INFORMATION SEPARATOR ONE, inclusive:
// https://infra.spec.whatwg.org/#c0-control-or-space

/* eslint-disable max-len */

var isJavaScriptProtocol = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*\:/i;
var didWarn = false;

function sanitizeURL(url) {
  {
    if (!didWarn && isJavaScriptProtocol.test(url)) {
      didWarn = true;

      error('A future version of React will block javascript: URLs as a security precaution. ' + 'Use event handlers instead if you can. If you need to generate unsafe HTML try ' + 'using dangerouslySetInnerHTML instead. React was passed %s.', JSON.stringify(url));
    }
  }
}

/**
 * Get the value for a property on a node. Only used in DEV for SSR validation.
 * The "expected" argument is used as a hint of what the expected value is.
 * Some properties have multiple equivalent values.
 */
function getValueForProperty(node, name, expected, propertyInfo) {
  {
    if (propertyInfo.mustUseProperty) {
      var propertyName = propertyInfo.propertyName;
      return node[propertyName];
    } else {
      if ( propertyInfo.sanitizeURL) {
        // If we haven't fully disabled javascript: URLs, and if
        // the hydration is successful of a javascript: URL, we
        // still want to warn on the client.
        sanitizeURL('' + expected);
      }

      var attributeName = propertyInfo.attributeName;
      var stringValue = null;

      if (propertyInfo.type === OVERLOADED_BOOLEAN) {
        if (node.hasAttribute(attributeName)) {
          var value = node.getAttribute(attributeName);

          if (value === '') {
            return true;
          }

          if (shouldRemoveAttribute(name, expected, propertyInfo, false)) {
            return value;
          }

          if (value === '' + expected) {
            return expected;
          }

          return value;
        }
      } else if (node.hasAttribute(attributeName)) {
        if (shouldRemoveAttribute(name, expected, propertyInfo, false)) {
          // We had an attribute but shouldn't have had one, so read it
          // for the error message.
          return node.getAttribute(attributeName);
        }

        if (propertyInfo.type === BOOLEAN) {
          // If this was a boolean, it doesn't matter what the value is
          // the fact that we have it is the same as the expected.
          return expected;
        } // Even if this property uses a namespace we use getAttribute
        // because we assume its namespaced name is the same as our config.
        // To use getAttributeNS we need the local name which we don't have
        // in our config atm.


        stringValue = node.getAttribute(attributeName);
      }

      if (shouldRemoveAttribute(name, expected, propertyInfo, false)) {
        return stringValue === null ? expected : stringValue;
      } else if (stringValue === '' + expected) {
        return expected;
      } else {
        return stringValue;
      }
    }
  }
}
/**
 * Get the value for a attribute on a node. Only used in DEV for SSR validation.
 * The third argument is used as a hint of what the expected value is. Some
 * attributes have multiple equivalent values.
 */

function getValueForAttribute(node, name, expected) {
  {
    if (!isAttributeNameSafe(name)) {
      return;
    } // If the object is an opaque reference ID, it's expected that
    // the next prop is different than the server value, so just return
    // expected


    if (isOpaqueHydratingObject(expected)) {
      return expected;
    }

    if (!node.hasAttribute(name)) {
      return expected === undefined ? undefined : null;
    }

    var value = node.getAttribute(name);

    if (value === '' + expected) {
      return expected;
    }

    return value;
  }
}
/**
 * Sets the value for a property on a node.
 *
 * @param {DOMElement} node
 * @param {string} name
 * @param {*} value
 */

function setValueForProperty(node, name, value, isCustomComponentTag) {
  var propertyInfo = getPropertyInfo(name);

  if (shouldIgnoreAttribute(name, propertyInfo, isCustomComponentTag)) {
    return;
  }

  if (shouldRemoveAttribute(name, value, propertyInfo, isCustomComponentTag)) {
    value = null;
  } // If the prop isn't in the special list, treat it as a simple attribute.


  if (isCustomComponentTag || propertyInfo === null) {
    if (isAttributeNameSafe(name)) {
      var _attributeName = name;

      if (value === null) {
        node.removeAttribute(_attributeName);
      } else {
        node.setAttribute(_attributeName,  '' + value);
      }
    }

    return;
  }

  var mustUseProperty = propertyInfo.mustUseProperty;

  if (mustUseProperty) {
    var propertyName = propertyInfo.propertyName;

    if (value === null) {
      var type = propertyInfo.type;
      node[propertyName] = type === BOOLEAN ? false : '';
    } else {
      // Contrary to `setAttribute`, object properties are properly
      // `toString`ed by IE8/9.
      node[propertyName] = value;
    }

    return;
  } // The rest are treated as attributes with special cases.


  var attributeName = propertyInfo.attributeName,
      attributeNamespace = propertyInfo.attributeNamespace;

  if (value === null) {
    node.removeAttribute(attributeName);
  } else {
    var _type = propertyInfo.type;
    var attributeValue;

    if (_type === BOOLEAN || _type === OVERLOADED_BOOLEAN && value === true) {
      // If attribute type is boolean, we know for sure it won't be an execution sink
      // and we won't require Trusted Type here.
      attributeValue = '';
    } else {
      // `setAttribute` with objects becomes only `[object]` in IE8/9,
      // ('' + value) makes it output the correct toString()-value.
      {
        attributeValue = '' + value;
      }

      if (propertyInfo.sanitizeURL) {
        sanitizeURL(attributeValue.toString());
      }
    }

    if (attributeNamespace) {
      node.setAttributeNS(attributeNamespace, attributeName, attributeValue);
    } else {
      node.setAttribute(attributeName, attributeValue);
    }
  }
}

// ATTENTION
// When adding new symbols to this file,
// Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'
// The Symbol used to tag the ReactElement-like types. If there is no native Symbol
// nor polyfill, then a plain number is used for performance.
var REACT_ELEMENT_TYPE = 0xeac7;
var REACT_PORTAL_TYPE = 0xeaca;
var REACT_FRAGMENT_TYPE = 0xeacb;
var REACT_STRICT_MODE_TYPE = 0xeacc;
var REACT_PROFILER_TYPE = 0xead2;
var REACT_PROVIDER_TYPE = 0xeacd;
var REACT_CONTEXT_TYPE = 0xeace;
var REACT_FORWARD_REF_TYPE = 0xead0;
var REACT_SUSPENSE_TYPE = 0xead1;
var REACT_SUSPENSE_LIST_TYPE = 0xead8;
var REACT_MEMO_TYPE = 0xead3;
var REACT_LAZY_TYPE = 0xead4;
var REACT_BLOCK_TYPE = 0xead9;
var REACT_SERVER_BLOCK_TYPE = 0xeada;
var REACT_FUNDAMENTAL_TYPE = 0xead5;
var REACT_SCOPE_TYPE = 0xead7;
var REACT_OPAQUE_ID_TYPE = 0xeae0;
var REACT_DEBUG_TRACING_MODE_TYPE = 0xeae1;
var REACT_OFFSCREEN_TYPE = 0xeae2;
var REACT_LEGACY_HIDDEN_TYPE = 0xeae3;

if (typeof Symbol === 'function' && Symbol.for) {
  var symbolFor = Symbol.for;
  REACT_ELEMENT_TYPE = symbolFor('react.element');
  REACT_PORTAL_TYPE = symbolFor('react.portal');
  REACT_FRAGMENT_TYPE = symbolFor('react.fragment');
  REACT_STRICT_MODE_TYPE = symbolFor('react.strict_mode');
  REACT_PROFILER_TYPE = symbolFor('react.profiler');
  REACT_PROVIDER_TYPE = symbolFor('react.provider');
  REACT_CONTEXT_TYPE = symbolFor('react.context');
  REACT_FORWARD_REF_TYPE = symbolFor('react.forward_ref');
  REACT_SUSPENSE_TYPE = symbolFor('react.suspense');
  REACT_SUSPENSE_LIST_TYPE = symbolFor('react.suspense_list');
  REACT_MEMO_TYPE = symbolFor('react.memo');
  REACT_LAZY_TYPE = symbolFor('react.lazy');
  REACT_BLOCK_TYPE = symbolFor('react.block');
  REACT_SERVER_BLOCK_TYPE = symbolFor('react.server.block');
  REACT_FUNDAMENTAL_TYPE = symbolFor('react.fundamental');
  REACT_SCOPE_TYPE = symbolFor('react.scope');
  REACT_OPAQUE_ID_TYPE = symbolFor('react.opaque.id');
  REACT_DEBUG_TRACING_MODE_TYPE = symbolFor('react.debug_trace_mode');
  REACT_OFFSCREEN_TYPE = symbolFor('react.offscreen');
  REACT_LEGACY_HIDDEN_TYPE = symbolFor('react.legacy_hidden');
}

var MAYBE_ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
var FAUX_ITERATOR_SYMBOL = '@@iterator';
function getIteratorFn(maybeIterable) {
  if (maybeIterable === null || typeof maybeIterable !== 'object') {
    return null;
  }

  var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];

  if (typeof maybeIterator === 'function') {
    return maybeIterator;
  }

  return null;
}

// Helpers to patch console.logs to avoid logging during side-effect free
// replaying on render function. This currently only patches the object
// lazily which won't cover if the log function was extracted eagerly.
// We could also eagerly patch the method.
var disabledDepth = 0;
var prevLog;
var prevInfo;
var prevWarn;
var prevError;
var prevGroup;
var prevGroupCollapsed;
var prevGroupEnd;

function disabledLog() {}

disabledLog.__reactDisabledLog = true;
function disableLogs() {
  {
    if (disabledDepth === 0) {
      /* eslint-disable react-internal/no-production-logging */
      prevLog = console.log;
      prevInfo = console.info;
      prevWarn = console.warn;
      prevError = console.error;
      prevGroup = console.group;
      prevGroupCollapsed = console.groupCollapsed;
      prevGroupEnd = console.groupEnd; // https://github.com/facebook/react/issues/19099

      var props = {
        configurable: true,
        enumerable: true,
        value: disabledLog,
        writable: true
      }; // $FlowFixMe Flow thinks console is immutable.

      Object.defineProperties(console, {
        info: props,
        log: props,
        warn: props,
        error: props,
        group: props,
        groupCollapsed: props,
        groupEnd: props
      });
      /* eslint-enable react-internal/no-production-logging */
    }

    disabledDepth++;
  }
}
function reenableLogs() {
  {
    disabledDepth--;

    if (disabledDepth === 0) {
      /* eslint-disable react-internal/no-production-logging */
      var props = {
        configurable: true,
        enumerable: true,
        writable: true
      }; // $FlowFixMe Flow thinks console is immutable.

      Object.defineProperties(console, {
        log: _assign({}, props, {
          value: prevLog
        }),
        info: _assign({}, props, {
          value: prevInfo
        }),
        warn: _assign({}, props, {
          value: prevWarn
        }),
        error: _assign({}, props, {
          value: prevError
        }),
        group: _assign({}, props, {
          value: prevGroup
        }),
        groupCollapsed: _assign({}, props, {
          value: prevGroupCollapsed
        }),
        groupEnd: _assign({}, props, {
          value: prevGroupEnd
        })
      });
      /* eslint-enable react-internal/no-production-logging */
    }

    if (disabledDepth < 0) {
      error('disabledDepth fell below zero. ' + 'This is a bug in React. Please file an issue.');
    }
  }
}

var ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;
var prefix;
function describeBuiltInComponentFrame(name, source, ownerFn) {
  {
    if (prefix === undefined) {
      // Extract the VM specific prefix used by each line.
      try {
        throw Error();
      } catch (x) {
        var match = x.stack.trim().match(/\n( *(at )?)/);
        prefix = match && match[1] || '';
      }
    } // We use the prefix to ensure our stacks line up with native stack frames.


    return '\n' + prefix + name;
  }
}
var reentry = false;
var componentFrameCache;

{
  var PossiblyWeakMap = typeof WeakMap === 'function' ? WeakMap : Map;
  componentFrameCache = new PossiblyWeakMap();
}

function describeNativeComponentFrame(fn, construct) {
  // If something asked for a stack inside a fake render, it should get ignored.
  if (!fn || reentry) {
    return '';
  }

  {
    var frame = componentFrameCache.get(fn);

    if (frame !== undefined) {
      return frame;
    }
  }

  var control;
  reentry = true;
  var previousPrepareStackTrace = Error.prepareStackTrace; // $FlowFixMe It does accept undefined.

  Error.prepareStackTrace = undefined;
  var previousDispatcher;

  {
    previousDispatcher = ReactCurrentDispatcher.current; // Set the dispatcher in DEV because this might be call in the render function
    // for warnings.

    ReactCurrentDispatcher.current = null;
    disableLogs();
  }

  try {
    // This should throw.
    if (construct) {
      // Something should be setting the props in the constructor.
      var Fake = function () {
        throw Error();
      }; // $FlowFixMe


      Object.defineProperty(Fake.prototype, 'props', {
        set: function () {
          // We use a throwing setter instead of frozen or non-writable props
          // because that won't throw in a non-strict mode function.
          throw Error();
        }
      });

      if (typeof Reflect === 'object' && Reflect.construct) {
        // We construct a different control for this case to include any extra
        // frames added by the construct call.
        try {
          Reflect.construct(Fake, []);
        } catch (x) {
          control = x;
        }

        Reflect.construct(fn, [], Fake);
      } else {
        try {
          Fake.call();
        } catch (x) {
          control = x;
        }

        fn.call(Fake.prototype);
      }
    } else {
      try {
        throw Error();
      } catch (x) {
        control = x;
      }

      fn();
    }
  } catch (sample) {
    // This is inlined manually because closure doesn't do it for us.
    if (sample && control && typeof sample.stack === 'string') {
      // This extracts the first frame from the sample that isn't also in the control.
      // Skipping one frame that we assume is the frame that calls the two.
      var sampleLines = sample.stack.split('\n');
      var controlLines = control.stack.split('\n');
      var s = sampleLines.length - 1;
      var c = controlLines.length - 1;

      while (s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]) {
        // We expect at least one stack frame to be shared.
        // Typically this will be the root most one. However, stack frames may be
        // cut off due to maximum stack limits. In this case, one maybe cut off
        // earlier than the other. We assume that the sample is longer or the same
        // and there for cut off earlier. So we should find the root most frame in
        // the sample somewhere in the control.
        c--;
      }

      for (; s >= 1 && c >= 0; s--, c--) {
        // Next we find the first one that isn't the same which should be the
        // frame that called our sample function and the control.
        if (sampleLines[s] !== controlLines[c]) {
          // In V8, the first line is describing the message but other VMs don't.
          // If we're about to return the first line, and the control is also on the same
          // line, that's a pretty good indicator that our sample threw at same line as
          // the control. I.e. before we entered the sample frame. So we ignore this result.
          // This can happen if you passed a class to function component, or non-function.
          if (s !== 1 || c !== 1) {
            do {
              s--;
              c--; // We may still have similar intermediate frames from the construct call.
              // The next one that isn't the same should be our match though.

              if (c < 0 || sampleLines[s] !== controlLines[c]) {
                // V8 adds a "new" prefix for native classes. Let's remove it to make it prettier.
                var _frame = '\n' + sampleLines[s].replace(' at new ', ' at ');

                {
                  if (typeof fn === 'function') {
                    componentFrameCache.set(fn, _frame);
                  }
                } // Return the line we found.


                return _frame;
              }
            } while (s >= 1 && c >= 0);
          }

          break;
        }
      }
    }
  } finally {
    reentry = false;

    {
      ReactCurrentDispatcher.current = previousDispatcher;
      reenableLogs();
    }

    Error.prepareStackTrace = previousPrepareStackTrace;
  } // Fallback to just using the name if we couldn't make it throw.


  var name = fn ? fn.displayName || fn.name : '';
  var syntheticFrame = name ? describeBuiltInComponentFrame(name) : '';

  {
    if (typeof fn === 'function') {
      componentFrameCache.set(fn, syntheticFrame);
    }
  }

  return syntheticFrame;
}

function describeClassComponentFrame(ctor, source, ownerFn) {
  {
    return describeNativeComponentFrame(ctor, true);
  }
}
function describeFunctionComponentFrame(fn, source, ownerFn) {
  {
    return describeNativeComponentFrame(fn, false);
  }
}

function shouldConstruct(Component) {
  var prototype = Component.prototype;
  return !!(prototype && prototype.isReactComponent);
}

function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {

  if (type == null) {
    return '';
  }

  if (typeof type === 'function') {
    {
      return describeNativeComponentFrame(type, shouldConstruct(type));
    }
  }

  if (typeof type === 'string') {
    return describeBuiltInComponentFrame(type);
  }

  switch (type) {
    case REACT_SUSPENSE_TYPE:
      return describeBuiltInComponentFrame('Suspense');

    case REACT_SUSPENSE_LIST_TYPE:
      return describeBuiltInComponentFrame('SuspenseList');
  }

  if (typeof type === 'object') {
    switch (type.$$typeof) {
      case REACT_FORWARD_REF_TYPE:
        return describeFunctionComponentFrame(type.render);

      case REACT_MEMO_TYPE:
        // Memo may contain any component type so we recursively resolve it.
        return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);

      case REACT_BLOCK_TYPE:
        return describeFunctionComponentFrame(type._render);

      case REACT_LAZY_TYPE:
        {
          var lazyComponent = type;
          var payload = lazyComponent._payload;
          var init = lazyComponent._init;

          try {
            // Lazy may contain any component type so we recursively resolve it.
            return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);
          } catch (x) {}
        }
    }
  }

  return '';
}

function describeFiber(fiber) {
  var owner =  fiber._debugOwner ? fiber._debugOwner.type : null ;
  var source =  fiber._debugSource ;

  switch (fiber.tag) {
    case HostComponent:
      return describeBuiltInComponentFrame(fiber.type);

    case LazyComponent:
      return describeBuiltInComponentFrame('Lazy');

    case SuspenseComponent:
      return describeBuiltInComponentFrame('Suspense');

    case SuspenseListComponent:
      return describeBuiltInComponentFrame('SuspenseList');

    case FunctionComponent:
    case IndeterminateComponent:
    case SimpleMemoComponent:
      return describeFunctionComponentFrame(fiber.type);

    case ForwardRef:
      return describeFunctionComponentFrame(fiber.type.render);

    case Block:
      return describeFunctionComponentFrame(fiber.type._render);

    case ClassComponent:
      return describeClassComponentFrame(fiber.type);

    default:
      return '';
  }
}

function getStackByFiberInDevAndProd(workInProgress) {
  try {
    var info = '';
    var node = workInProgress;

    do {
      info += describeFiber(node);
      node = node.return;
    } while (node);

    return info;
  } catch (x) {
    return '\nError generating stack: ' + x.message + '\n' + x.stack;
  }
}

function getWrappedName(outerType, innerType, wrapperName) {
  var functionName = innerType.displayName || innerType.name || '';
  return outerType.displayName || (functionName !== '' ? wrapperName + "(" + functionName + ")" : wrapperName);
}

function getContextName(type) {
  return type.displayName || 'Context';
}

function getComponentName(type) {
  if (type == null) {
    // Host root, text node or just invalid type.
    return null;
  }

  {
    if (typeof type.tag === 'number') {
      error('Received an unexpected object in getComponentName(). ' + 'This is likely a bug in React. Please file an issue.');
    }
  }

  if (typeof type === 'function') {
    return type.displayName || type.name || null;
  }

  if (typeof type === 'string') {
    return type;
  }

  switch (type) {
    case REACT_FRAGMENT_TYPE:
      return 'Fragment';

    case REACT_PORTAL_TYPE:
      return 'Portal';

    case REACT_PROFILER_TYPE:
      return 'Profiler';

    case REACT_STRICT_MODE_TYPE:
      return 'StrictMode';

    case REACT_SUSPENSE_TYPE:
      return 'Suspense';

    case REACT_SUSPENSE_LIST_TYPE:
      return 'SuspenseList';
  }

  if (typeof type === 'object') {
    switch (type.$$typeof) {
      case REACT_CONTEXT_TYPE:
        var context = type;
        return getContextName(context) + '.Consumer';

      case REACT_PROVIDER_TYPE:
        var provider = type;
        return getContextName(provider._context) + '.Provider';

      case REACT_FORWARD_REF_TYPE:
        return getWrappedName(type, type.render, 'ForwardRef');

      case REACT_MEMO_TYPE:
        return getComponentName(type.type);

      case REACT_BLOCK_TYPE:
        return getComponentName(type._render);

      case REACT_LAZY_TYPE:
        {
          var lazyComponent = type;
          var payload = lazyComponent._payload;
          var init = lazyComponent._init;

          try {
            return getComponentName(init(payload));
          } catch (x) {
            return null;
          }
        }
    }
  }

  return null;
}

var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
var current = null;
var isRendering = false;
function getCurrentFiberOwnerNameInDevOrNull() {
  {
    if (current === null) {
      return null;
    }

    var owner = current._debugOwner;

    if (owner !== null && typeof owner !== 'undefined') {
      return getComponentName(owner.type);
    }
  }

  return null;
}

function getCurrentFiberStackInDev() {
  {
    if (current === null) {
      return '';
    } // Safe because if current fiber exists, we are reconciling,
    // and it is guaranteed to be the work-in-progress version.


    return getStackByFiberInDevAndProd(current);
  }
}

function resetCurrentFiber() {
  {
    ReactDebugCurrentFrame.getCurrentStack = null;
    current = null;
    isRendering = false;
  }
}
function setCurrentFiber(fiber) {
  {
    ReactDebugCurrentFrame.getCurrentStack = getCurrentFiberStackInDev;
    current = fiber;
    isRendering = false;
  }
}
function setIsRendering(rendering) {
  {
    isRendering = rendering;
  }
}
function getIsRendering() {
  {
    return isRendering;
  }
}

// Flow does not allow string concatenation of most non-string types. To work
// around this limitation, we use an opaque type that can only be obtained by
// passing the value through getToStringValue first.
function toString(value) {
  return '' + value;
}
function getToStringValue(value) {
  switch (typeof value) {
    case 'boolean':
    case 'number':
    case 'object':
    case 'string':
    case 'undefined':
      return value;

    default:
      // function, symbol are assigned as empty strings
      return '';
  }
}

var hasReadOnlyValue = {
  button: true,
  checkbox: true,
  image: true,
  hidden: true,
  radio: true,
  reset: true,
  submit: true
};
function checkControlledValueProps(tagName, props) {
  {
    if (!(hasReadOnlyValue[props.type] || props.onChange || props.onInput || props.readOnly || props.disabled || props.value == null)) {
      error('You provided a `value` prop to a form field without an ' + '`onChange` handler. This will render a read-only field. If ' + 'the field should be mutable use `defaultValue`. Otherwise, ' + 'set either `onChange` or `readOnly`.');
    }

    if (!(props.onChange || props.readOnly || props.disabled || props.checked == null)) {
      error('You provided a `checked` prop to a form field without an ' + '`onChange` handler. This will render a read-only field. If ' + 'the field should be mutable use `defaultChecked`. Otherwise, ' + 'set either `onChange` or `readOnly`.');
    }
  }
}

function isCheckable(elem) {
  var type = elem.type;
  var nodeName = elem.nodeName;
  return nodeName && nodeName.toLowerCase() === 'input' && (type === 'checkbox' || type === 'radio');
}

function getTracker(node) {
  return node._valueTracker;
}

function detachTracker(node) {
  node._valueTracker = null;
}

function getValueFromNode(node) {
  var value = '';

  if (!node) {
    return value;
  }

  if (isCheckable(node)) {
    value = node.checked ? 'true' : 'false';
  } else {
    value = node.value;
  }

  return value;
}

function trackValueOnNode(node) {
  var valueField = isCheckable(node) ? 'checked' : 'value';
  var descriptor = Object.getOwnPropertyDescriptor(node.constructor.prototype, valueField);
  var currentValue = '' + node[valueField]; // if someone has already defined a value or Safari, then bail
  // and don't track value will cause over reporting of changes,
  // but it's better then a hard failure
  // (needed for certain tests that spyOn input values and Safari)

  if (node.hasOwnProperty(valueField) || typeof descriptor === 'undefined' || typeof descriptor.get !== 'function' || typeof descriptor.set !== 'function') {
    return;
  }

  var get = descriptor.get,
      set = descriptor.set;
  Object.defineProperty(node, valueField, {
    configurable: true,
    get: function () {
      return get.call(this);
    },
    set: function (value) {
      currentValue = '' + value;
      set.call(this, value);
    }
  }); // We could've passed this the first time
  // but it triggers a bug in IE11 and Edge 14/15.
  // Calling defineProperty() again should be equivalent.
  // https://github.com/facebook/react/issues/11768

  Object.defineProperty(node, valueField, {
    enumerable: descriptor.enumerable
  });
  var tracker = {
    getValue: function () {
      return currentValue;
    },
    setValue: function (value) {
      currentValue = '' + value;
    },
    stopTracking: function () {
      detachTracker(node);
      delete node[valueField];
    }
  };
  return tracker;
}

function track(node) {
  if (getTracker(node)) {
    return;
  } // TODO: Once it's just Fiber we can move this to node._wrapperState


  node._valueTracker = trackValueOnNode(node);
}
function updateValueIfChanged(node) {
  if (!node) {
    return false;
  }

  var tracker = getTracker(node); // if there is no tracker at this point it's unlikely
  // that trying again will succeed

  if (!tracker) {
    return true;
  }

  var lastValue = tracker.getValue();
  var nextValue = getValueFromNode(node);

  if (nextValue !== lastValue) {
    tracker.setValue(nextValue);
    return true;
  }

  return false;
}

function getActiveElement(doc) {
  doc = doc || (typeof document !== 'undefined' ? document : undefined);

  if (typeof doc === 'undefined') {
    return null;
  }

  try {
    return doc.activeElement || doc.body;
  } catch (e) {
    return doc.body;
  }
}

var didWarnValueDefaultValue = false;
var didWarnCheckedDefaultChecked = false;
var didWarnControlledToUncontrolled = false;
var didWarnUncontrolledToControlled = false;

function isControlled(props) {
  var usesChecked = props.type === 'checkbox' || props.type === 'radio';
  return usesChecked ? props.checked != null : props.value != null;
}
/**
 * Implements an <input> host component that allows setting these optional
 * props: `checked`, `value`, `defaultChecked`, and `defaultValue`.
 *
 * If `checked` or `value` are not supplied (or null/undefined), user actions
 * that affect the checked state or value will trigger updates to the element.
 *
 * If they are supplied (and not null/undefined), the rendered element will not
 * trigger updates to the element. Instead, the props must change in order for
 * the rendered element to be updated.
 *
 * The rendered element will be initialized as unchecked (or `defaultChecked`)
 * with an empty value (or `defaultValue`).
 *
 * See http://www.w3.org/TR/2012/WD-html5-20121025/the-input-element.html
 */


function getHostProps(element, props) {
  var node = element;
  var checked = props.checked;

  var hostProps = _assign({}, props, {
    defaultChecked: undefined,
    defaultValue: undefined,
    value: undefined,
    checked: checked != null ? checked : node._wrapperState.initialChecked
  });

  return hostProps;
}
function initWrapperState(element, props) {
  {
    checkControlledValueProps('input', props);

    if (props.checked !== undefined && props.defaultChecked !== undefined && !didWarnCheckedDefaultChecked) {
      error('%s contains an input of type %s with both checked and defaultChecked props. ' + 'Input elements must be either controlled or uncontrolled ' + '(specify either the checked prop, or the defaultChecked prop, but not ' + 'both). Decide between using a controlled or uncontrolled input ' + 'element and remove one of these props. More info: ' + 'https://reactjs.org/link/controlled-components', getCurrentFiberOwnerNameInDevOrNull() || 'A component', props.type);

      didWarnCheckedDefaultChecked = true;
    }

    if (props.value !== undefined && props.defaultValue !== undefined && !didWarnValueDefaultValue) {
      error('%s contains an input of type %s with both value and defaultValue props. ' + 'Input elements must be either controlled or uncontrolled ' + '(specify either the value prop, or the defaultValue prop, but not ' + 'both). Decide between using a controlled or uncontrolled input ' + 'element and remove one of these props. More info: ' + 'https://reactjs.org/link/controlled-components', getCurrentFiberOwnerNameInDevOrNull() || 'A component', props.type);

      didWarnValueDefaultValue = true;
    }
  }

  var node = element;
  var defaultValue = props.defaultValue == null ? '' : props.defaultValue;
  node._wrapperState = {
    initialChecked: props.checked != null ? props.checked : props.defaultChecked,
    initialValue: getToStringValue(props.value != null ? props.value : defaultValue),
    controlled: isControlled(props)
  };
}
function updateChecked(element, props) {
  var node = element;
  var checked = props.checked;

  if (checked != null) {
    setValueForProperty(node, 'checked', checked, false);
  }
}
function updateWrapper(element, props) {
  var node = element;

  {
    var controlled = isControlled(props);

    if (!node._wrapperState.controlled && controlled && !didWarnUncontrolledToControlled) {
      error('A component is changing an uncontrolled input to be controlled. ' + 'This is likely caused by the value changing from undefined to ' + 'a defined value, which should not happen. ' + 'Decide between using a controlled or uncontrolled input ' + 'element for the lifetime of the component. More info: https://reactjs.org/link/controlled-components');

      didWarnUncontrolledToControlled = true;
    }

    if (node._wrapperState.controlled && !controlled && !didWarnControlledToUncontrolled) {
      error('A component is changing a controlled input to be uncontrolled. ' + 'This is likely caused by the value changing from a defined to ' + 'undefined, which should not happen. ' + 'Decide between using a controlled or uncontrolled input ' + 'element for the lifetime of the component. More info: https://reactjs.org/link/controlled-components');

      didWarnControlledToUncontrolled = true;
    }
  }

  updateChecked(element, props);
  var value = getToStringValue(props.value);
  var type = props.type;

  if (value != null) {
    if (type === 'number') {
      if (value === 0 && node.value === '' || // We explicitly want to coerce to number here if possible.
      // eslint-disable-next-line
      node.value != value) {
        node.value = toString(value);
      }
    } else if (node.value !== toString(value)) {
      node.value = toString(value);
    }
  } else if (type === 'submit' || type === 'reset') {
    // Submit/reset inputs need the attribute removed completely to avoid
    // blank-text buttons.
    node.removeAttribute('value');
    return;
  }

  {
    // When syncing the value attribute, the value comes from a cascade of
    // properties:
    //  1. The value React property
    //  2. The defaultValue React property
    //  3. Otherwise there should be no change
    if (props.hasOwnProperty('value')) {
      setDefaultValue(node, props.type, value);
    } else if (props.hasOwnProperty('defaultValue')) {
      setDefaultValue(node, props.type, getToStringValue(props.defaultValue));
    }
  }

  {
    // When syncing the checked attribute, it only changes when it needs
    // to be removed, such as transitioning from a checkbox into a text input
    if (props.checked == null && props.defaultChecked != null) {
      node.defaultChecked = !!props.defaultChecked;
    }
  }
}
function postMountWrapper(element, props, isHydrating) {
  var node = element; // Do not assign value if it is already set. This prevents user text input
  // from being lost during SSR hydration.

  if (props.hasOwnProperty('value') || props.hasOwnProperty('defaultValue')) {
    var type = props.type;
    var isButton = type === 'submit' || type === 'reset'; // Avoid setting value attribute on submit/reset inputs as it overrides the
    // default value provided by the browser. See: #12872

    if (isButton && (props.value === undefined || props.value === null)) {
      return;
    }

    var initialValue = toString(node._wrapperState.initialValue); // Do not assign value if it is already set. This prevents user text input
    // from being lost during SSR hydration.

    if (!isHydrating) {
      {
        // When syncing the value attribute, the value property should use
        // the wrapperState._initialValue property. This uses:
        //
        //   1. The value React property when present
        //   2. The defaultValue React property when present
        //   3. An empty string
        if (initialValue !== node.value) {
          node.value = initialValue;
        }
      }
    }

    {
      // Otherwise, the value attribute is synchronized to the property,
      // so we assign defaultValue to the same thing as the value property
      // assignment step above.
      node.defaultValue = initialValue;
    }
  } // Normally, we'd just do `node.checked = node.checked` upon initial mount, less this bug
  // this is needed to work around a chrome bug where setting defaultChecked
  // will sometimes influence the value of checked (even after detachment).
  // Reference: https://bugs.chromium.org/p/chromium/issues/detail?id=608416
  // We need to temporarily unset name to avoid disrupting radio button groups.


  var name = node.name;

  if (name !== '') {
    node.name = '';
  }

  {
    // When syncing the checked attribute, both the checked property and
    // attribute are assigned at the same time using defaultChecked. This uses:
    //
    //   1. The checked React property when present
    //   2. The defaultChecked React property when present
    //   3. Otherwise, false
    node.defaultChecked = !node.defaultChecked;
    node.defaultChecked = !!node._wrapperState.initialChecked;
  }

  if (name !== '') {
    node.name = name;
  }
}
function restoreControlledState(element, props) {
  var node = element;
  updateWrapper(node, props);
  updateNamedCousins(node, props);
}

function updateNamedCousins(rootNode, props) {
  var name = props.name;

  if (props.type === 'radio' && name != null) {
    var queryRoot = rootNode;

    while (queryRoot.parentNode) {
      queryRoot = queryRoot.parentNode;
    } // If `rootNode.form` was non-null, then we could try `form.elements`,
    // but that sometimes behaves strangely in IE8. We could also try using
    // `form.getElementsByName`, but that will only return direct children
    // and won't include inputs that use the HTML5 `form=` attribute. Since
    // the input might not even be in a form. It might not even be in the
    // document. Let's just use the local `querySelectorAll` to ensure we don't
    // miss anything.


    var group = queryRoot.querySelectorAll('input[name=' + JSON.stringify('' + name) + '][type="radio"]');

    for (var i = 0; i < group.length; i++) {
      var otherNode = group[i];

      if (otherNode === rootNode || otherNode.form !== rootNode.form) {
        continue;
      } // This will throw if radio buttons rendered by different copies of React
      // and the same name are rendered into the same form (same as #1939).
      // That's probably okay; we don't support it just as we don't support
      // mixing React radio buttons with non-React ones.


      var otherProps = getFiberCurrentPropsFromNode(otherNode);

      if (!otherProps) {
        {
          throw Error( "ReactDOMInput: Mixing React and non-React radio inputs with the same `name` is not supported." );
        }
      } // We need update the tracked value on the named cousin since the value
      // was changed but the input saw no event or value set


      updateValueIfChanged(otherNode); // If this is a controlled radio button group, forcing the input that
      // was previously checked to update will cause it to be come re-checked
      // as appropriate.

      updateWrapper(otherNode, otherProps);
    }
  }
} // In Chrome, assigning defaultValue to certain input types triggers input validation.
// For number inputs, the display value loses trailing decimal points. For email inputs,
// Chrome raises "The specified value <x> is not a valid email address".
//
// Here we check to see if the defaultValue has actually changed, avoiding these problems
// when the user is inputting text
//
// https://github.com/facebook/react/issues/7253


function setDefaultValue(node, type, value) {
  if ( // Focused number inputs synchronize on blur. See ChangeEventPlugin.js
  type !== 'number' || getActiveElement(node.ownerDocument) !== node) {
    if (value == null) {
      node.defaultValue = toString(node._wrapperState.initialValue);
    } else if (node.defaultValue !== toString(value)) {
      node.defaultValue = toString(value);
    }
  }
}

var didWarnSelectedSetOnOption = false;
var didWarnInvalidChild = false;

function flattenChildren(children) {
  var content = ''; // Flatten children. We'll warn if they are invalid
  // during validateProps() which runs for hydration too.
  // Note that this would throw on non-element objects.
  // Elements are stringified (which is normally irrelevant
  // but matters for <fbt>).

  React.Children.forEach(children, function (child) {
    if (child == null) {
      return;
    }

    content += child; // Note: we don't warn about invalid children here.
    // Instead, this is done separately below so that
    // it happens during the hydration code path too.
  });
  return content;
}
/**
 * Implements an <option> host component that warns when `selected` is set.
 */


function validateProps(element, props) {
  {
    // This mirrors the code path above, but runs for hydration too.
    // Warn about invalid children here so that client and hydration are consistent.
    // TODO: this seems like it could cause a DEV-only throw for hydration
    // if children contains a non-element object. We should try to avoid that.
    if (typeof props.children === 'object' && props.children !== null) {
      React.Children.forEach(props.children, function (child) {
        if (child == null) {
          return;
        }

        if (typeof child === 'string' || typeof child === 'number') {
          return;
        }

        if (typeof child.type !== 'string') {
          return;
        }

        if (!didWarnInvalidChild) {
          didWarnInvalidChild = true;

          error('Only strings and numbers are supported as <option> children.');
        }
      });
    } // TODO: Remove support for `selected` in <option>.


    if (props.selected != null && !didWarnSelectedSetOnOption) {
      error('Use the `defaultValue` or `value` props on <select> instead of ' + 'setting `selected` on <option>.');

      didWarnSelectedSetOnOption = true;
    }
  }
}
function postMountWrapper$1(element, props) {
  // value="" should make a value attribute (#6219)
  if (props.value != null) {
    element.setAttribute('value', toString(getToStringValue(props.value)));
  }
}
function getHostProps$1(element, props) {
  var hostProps = _assign({
    children: undefined
  }, props);

  var content = flattenChildren(props.children);

  if (content) {
    hostProps.children = content;
  }

  return hostProps;
}

var didWarnValueDefaultValue$1;

{
  didWarnValueDefaultValue$1 = false;
}

function getDeclarationErrorAddendum() {
  var ownerName = getCurrentFiberOwnerNameInDevOrNull();

  if (ownerName) {
    return '\n\nCheck the render method of `' + ownerName + '`.';
  }

  return '';
}

var valuePropNames = ['value', 'defaultValue'];
/**
 * Validation function for `value` and `defaultValue`.
 */

function checkSelectPropTypes(props) {
  {
    checkControlledValueProps('select', props);

    for (var i = 0; i < valuePropNames.length; i++) {
      var propName = valuePropNames[i];

      if (props[propName] == null) {
        continue;
      }

      var isArray = Array.isArray(props[propName]);

      if (props.multiple && !isArray) {
        error('The `%s` prop supplied to <select> must be an array if ' + '`multiple` is true.%s', propName, getDeclarationErrorAddendum());
      } else if (!props.multiple && isArray) {
        error('The `%s` prop supplied to <select> must be a scalar ' + 'value if `multiple` is false.%s', propName, getDeclarationErrorAddendum());
      }
    }
  }
}

function updateOptions(node, multiple, propValue, setDefaultSelected) {
  var options = node.options;

  if (multiple) {
    var selectedValues = propValue;
    var selectedValue = {};

    for (var i = 0; i < selectedValues.length; i++) {
      // Prefix to avoid chaos with special keys.
      selectedValue['$' + selectedValues[i]] = true;
    }

    for (var _i = 0; _i < options.length; _i++) {
      var selected = selectedValue.hasOwnProperty('$' + options[_i].value);

      if (options[_i].selected !== selected) {
        options[_i].selected = selected;
      }

      if (selected && setDefaultSelected) {
        options[_i].defaultSelected = true;
      }
    }
  } else {
    // Do not set `select.value` as exact behavior isn't consistent across all
    // browsers for all cases.
    var _selectedValue = toString(getToStringValue(propValue));

    var defaultSelected = null;

    for (var _i2 = 0; _i2 < options.length; _i2++) {
      if (options[_i2].value === _selectedValue) {
        options[_i2].selected = true;

        if (setDefaultSelected) {
          options[_i2].defaultSelected = true;
        }

        return;
      }

      if (defaultSelected === null && !options[_i2].disabled) {
        defaultSelected = options[_i2];
      }
    }

    if (defaultSelected !== null) {
      defaultSelected.selected = true;
    }
  }
}
/**
 * Implements a <select> host component that allows optionally setting the
 * props `value` and `defaultValue`. If `multiple` is false, the prop must be a
 * stringable. If `multiple` is true, the prop must be an array of stringables.
 *
 * If `value` is not supplied (or null/undefined), user actions that change the
 * selected option will trigger updates to the rendered options.
 *
 * If it is supplied (and not null/undefined), the rendered options will not
 * update in response to user actions. Instead, the `value` prop must change in
 * order for the rendered options to update.
 *
 * If `defaultValue` is provided, any options with the supplied values will be
 * selected.
 */


function getHostProps$2(element, props) {
  return _assign({}, props, {
    value: undefined
  });
}
function initWrapperState$1(element, props) {
  var node = element;

  {
    checkSelectPropTypes(props);
  }

  node._wrapperState = {
    wasMultiple: !!props.multiple
  };

  {
    if (props.value !== undefined && props.defaultValue !== undefined && !didWarnValueDefaultValue$1) {
      error('Select elements must be either controlled or uncontrolled ' + '(specify either the value prop, or the defaultValue prop, but not ' + 'both). Decide between using a controlled or uncontrolled select ' + 'element and remove one of these props. More info: ' + 'https://reactjs.org/link/controlled-components');

      didWarnValueDefaultValue$1 = true;
    }
  }
}
function postMountWrapper$2(element, props) {
  var node = element;
  node.multiple = !!props.multiple;
  var value = props.value;

  if (value != null) {
    updateOptions(node, !!props.multiple, value, false);
  } else if (props.defaultValue != null) {
    updateOptions(node, !!props.multiple, props.defaultValue, true);
  }
}
function postUpdateWrapper(element, props) {
  var node = element;
  var wasMultiple = node._wrapperState.wasMultiple;
  node._wrapperState.wasMultiple = !!props.multiple;
  var value = props.value;

  if (value != null) {
    updateOptions(node, !!props.multiple, value, false);
  } else if (wasMultiple !== !!props.multiple) {
    // For simplicity, reapply `defaultValue` if `multiple` is toggled.
    if (props.defaultValue != null) {
      updateOptions(node, !!props.multiple, props.defaultValue, true);
    } else {
      // Revert the select back to its default unselected state.
      updateOptions(node, !!props.multiple, props.multiple ? [] : '', false);
    }
  }
}
function restoreControlledState$1(element, props) {
  var node = element;
  var value = props.value;

  if (value != null) {
    updateOptions(node, !!props.multiple, value, false);
  }
}

var didWarnValDefaultVal = false;

/**
 * Implements a <textarea> host component that allows setting `value`, and
 * `defaultValue`. This differs from the traditional DOM API because value is
 * usually set as PCDATA children.
 *
 * If `value` is not supplied (or null/undefined), user actions that affect the
 * value will trigger updates to the element.
 *
 * If `value` is supplied (and not null/undefined), the rendered element will
 * not trigger updates to the element. Instead, the `value` prop must change in
 * order for the rendered element to be updated.
 *
 * The rendered element will be initialized with an empty value, the prop
 * `defaultValue` if specified, or the children content (deprecated).
 */
function getHostProps$3(element, props) {
  var node = element;

  if (!(props.dangerouslySetInnerHTML == null)) {
    {
      throw Error( "`dangerouslySetInnerHTML` does not make sense on <textarea>." );
    }
  } // Always set children to the same thing. In IE9, the selection range will
  // get reset if `textContent` is mutated.  We could add a check in setTextContent
  // to only set the value if/when the value differs from the node value (which would
  // completely solve this IE9 bug), but Sebastian+Sophie seemed to like this
  // solution. The value can be a boolean or object so that's why it's forced
  // to be a string.


  var hostProps = _assign({}, props, {
    value: undefined,
    defaultValue: undefined,
    children: toString(node._wrapperState.initialValue)
  });

  return hostProps;
}
function initWrapperState$2(element, props) {
  var node = element;

  {
    checkControlledValueProps('textarea', props);

    if (props.value !== undefined && props.defaultValue !== undefined && !didWarnValDefaultVal) {
      error('%s contains a textarea with both value and defaultValue props. ' + 'Textarea elements must be either controlled or uncontrolled ' + '(specify either the value prop, or the defaultValue prop, but not ' + 'both). Decide between using a controlled or uncontrolled textarea ' + 'and remove one of these props. More info: ' + 'https://reactjs.org/link/controlled-components', getCurrentFiberOwnerNameInDevOrNull() || 'A component');

      didWarnValDefaultVal = true;
    }
  }

  var initialValue = props.value; // Only bother fetching default value if we're going to use it

  if (initialValue == null) {
    var children = props.children,
        defaultValue = props.defaultValue;

    if (children != null) {
      {
        error('Use the `defaultValue` or `value` props instead of setting ' + 'children on <textarea>.');
      }

      {
        if (!(defaultValue == null)) {
          {
            throw Error( "If you supply `defaultValue` on a <textarea>, do not pass children." );
          }
        }

        if (Array.isArray(children)) {
          if (!(children.length <= 1)) {
            {
              throw Error( "<textarea> can only have at most one child." );
            }
          }

          children = children[0];
        }

        defaultValue = children;
      }
    }

    if (defaultValue == null) {
      defaultValue = '';
    }

    initialValue = defaultValue;
  }

  node._wrapperState = {
    initialValue: getToStringValue(initialValue)
  };
}
function updateWrapper$1(element, props) {
  var node = element;
  var value = getToStringValue(props.value);
  var defaultValue = getToStringValue(props.defaultValue);

  if (value != null) {
    // Cast `value` to a string to ensure the value is set correctly. While
    // browsers typically do this as necessary, jsdom doesn't.
    var newValue = toString(value); // To avoid side effects (such as losing text selection), only set value if changed

    if (newValue !== node.value) {
      node.value = newValue;
    }

    if (props.defaultValue == null && node.defaultValue !== newValue) {
      node.defaultValue = newValue;
    }
  }

  if (defaultValue != null) {
    node.defaultValue = toString(defaultValue);
  }
}
function postMountWrapper$3(element, props) {
  var node = element; // This is in postMount because we need access to the DOM node, which is not
  // available until after the component has mounted.

  var textContent = node.textContent; // Only set node.value if textContent is equal to the expected
  // initial value. In IE10/IE11 there is a bug where the placeholder attribute
  // will populate textContent as well.
  // https://developer.microsoft.com/microsoft-edge/platform/issues/101525/

  if (textContent === node._wrapperState.initialValue) {
    if (textContent !== '' && textContent !== null) {
      node.value = textContent;
    }
  }
}
function restoreControlledState$2(element, props) {
  // DOM component is still mounted; update
  updateWrapper$1(element, props);
}

var HTML_NAMESPACE = 'http://www.w3.org/1999/xhtml';
var MATH_NAMESPACE = 'http://www.w3.org/1998/Math/MathML';
var SVG_NAMESPACE = 'http://www.w3.org/2000/svg';
var Namespaces = {
  html: HTML_NAMESPACE,
  mathml: MATH_NAMESPACE,
  svg: SVG_NAMESPACE
}; // Assumes there is no parent namespace.

function getIntrinsicNamespace(type) {
  switch (type) {
    case 'svg':
      return SVG_NAMESPACE;

    case 'math':
      return MATH_NAMESPACE;

    default:
      return HTML_NAMESPACE;
  }
}
function getChildNamespace(parentNamespace, type) {
  if (parentNamespace == null || parentNamespace === HTML_NAMESPACE) {
    // No (or default) parent namespace: potential entry point.
    return getIntrinsicNamespace(type);
  }

  if (parentNamespace === SVG_NAMESPACE && type === 'foreignObject') {
    // We're leaving SVG.
    return HTML_NAMESPACE;
  } // By default, pass namespace below.


  return parentNamespace;
}

/* globals MSApp */

/**
 * Create a function which has 'unsafe' privileges (required by windows8 apps)
 */
var createMicrosoftUnsafeLocalFunction = function (func) {
  if (typeof MSApp !== 'undefined' && MSApp.execUnsafeLocalFunction) {
    return function (arg0, arg1, arg2, arg3) {
      MSApp.execUnsafeLocalFunction(function () {
        return func(arg0, arg1, arg2, arg3);
      });
    };
  } else {
    return func;
  }
};

var reusableSVGContainer;
/**
 * Set the innerHTML property of a node
 *
 * @param {DOMElement} node
 * @param {string} html
 * @internal
 */

var setInnerHTML = createMicrosoftUnsafeLocalFunction(function (node, html) {
  if (node.namespaceURI === Namespaces.svg) {

    if (!('innerHTML' in node)) {
      // IE does not have innerHTML for SVG nodes, so instead we inject the
      // new markup in a temp node and then move the child nodes across into
      // the target node
      reusableSVGContainer = reusableSVGContainer || document.createElement('div');
      reusableSVGContainer.innerHTML = '<svg>' + html.valueOf().toString() + '</svg>';
      var svgNode = reusableSVGContainer.firstChild;

      while (node.firstChild) {
        node.removeChild(node.firstChild);
      }

      while (svgNode.firstChild) {
        node.appendChild(svgNode.firstChild);
      }

      return;
    }
  }

  node.innerHTML = html;
});

/**
 * HTML nodeType values that represent the type of the node
 */
var ELEMENT_NODE = 1;
var TEXT_NODE = 3;
var COMMENT_NODE = 8;
var DOCUMENT_NODE = 9;
var DOCUMENT_FRAGMENT_NODE = 11;

/**
 * Set the textContent property of a node. For text updates, it's faster
 * to set the `nodeValue` of the Text node directly instead of using
 * `.textContent` which will remove the existing node and create a new one.
 *
 * @param {DOMElement} node
 * @param {string} text
 * @internal
 */

var setTextContent = function (node, text) {
  if (text) {
    var firstChild = node.firstChild;

    if (firstChild && firstChild === node.lastChild && firstChild.nodeType === TEXT_NODE) {
      firstChild.nodeValue = text;
      return;
    }
  }

  node.textContent = text;
};

// List derived from Gecko source code:
// https://github.com/mozilla/gecko-dev/blob/4e638efc71/layout/style/test/property_database.js
var shorthandToLonghand = {
  animation: ['animationDelay', 'animationDirection', 'animationDuration', 'animationFillMode', 'animationIterationCount', 'animationName', 'animationPlayState', 'animationTimingFunction'],
  background: ['backgroundAttachment', 'backgroundClip', 'backgroundColor', 'backgroundImage', 'backgroundOrigin', 'backgroundPositionX', 'backgroundPositionY', 'backgroundRepeat', 'backgroundSize'],
  backgroundPosition: ['backgroundPositionX', 'backgroundPositionY'],
  border: ['borderBottomColor', 'borderBottomStyle', 'borderBottomWidth', 'borderImageOutset', 'borderImageRepeat', 'borderImageSlice', 'borderImageSource', 'borderImageWidth', 'borderLeftColor', 'borderLeftStyle', 'borderLeftWidth', 'borderRightColor', 'borderRightStyle', 'borderRightWidth', 'borderTopColor', 'borderTopStyle', 'borderTopWidth'],
  borderBlockEnd: ['borderBlockEndColor', 'borderBlockEndStyle', 'borderBlockEndWidth'],
  borderBlockStart: ['borderBlockStartColor', 'borderBlockStartStyle', 'borderBlockStartWidth'],
  borderBottom: ['borderBottomColor', 'borderBottomStyle', 'borderBottomWidth'],
  borderColor: ['borderBottomColor', 'borderLeftColor', 'borderRightColor', 'borderTopColor'],
  borderImage: ['borderImageOutset', 'borderImageRepeat', 'borderImageSlice', 'borderImageSource', 'borderImageWidth'],
  borderInlineEnd: ['borderInlineEndColor', 'borderInlineEndStyle', 'borderInlineEndWidth'],
  borderInlineStart: ['borderInlineStartColor', 'borderInlineStartStyle', 'borderInlineStartWidth'],
  borderLeft: ['borderLeftColor', 'borderLeftStyle', 'borderLeftWidth'],
  borderRadius: ['borderBottomLeftRadius', 'borderBottomRightRadius', 'borderTopLeftRadius', 'borderTopRightRadius'],
  borderRight: ['borderRightColor', 'borderRightStyle', 'borderRightWidth'],
  borderStyle: ['borderBottomStyle', 'borderLeftStyle', 'borderRightStyle', 'borderTopStyle'],
  borderTop: ['borderTopColor', 'borderTopStyle', 'borderTopWidth'],
  borderWidth: ['borderBottomWidth', 'borderLeftWidth', 'borderRightWidth', 'borderTopWidth'],
  columnRule: ['columnRuleColor', 'columnRuleStyle', 'columnRuleWidth'],
  columns: ['columnCount', 'columnWidth'],
  flex: ['flexBasis', 'flexGrow', 'flexShrink'],
  flexFlow: ['flexDirection', 'flexWrap'],
  font: ['fontFamily', 'fontFeatureSettings', 'fontKerning', 'fontLanguageOverride', 'fontSize', 'fontSizeAdjust', 'fontStretch', 'fontStyle', 'fontVariant', 'fontVariantAlternates', 'fontVariantCaps', 'fontVariantEastAsian', 'fontVariantLigatures', 'fontVariantNumeric', 'fontVariantPosition', 'fontWeight', 'lineHeight'],
  fontVariant: ['fontVariantAlternates', 'fontVariantCaps', 'fontVariantEastAsian', 'fontVariantLigatures', 'fontVariantNumeric', 'fontVariantPosition'],
  gap: ['columnGap', 'rowGap'],
  grid: ['gridAutoColumns', 'gridAutoFlow', 'gridAutoRows', 'gridTemplateAreas', 'gridTemplateColumns', 'gridTemplateRows'],
  gridArea: ['gridColumnEnd', 'gridColumnStart', 'gridRowEnd', 'gridRowStart'],
  gridColumn: ['gridColumnEnd', 'gridColumnStart'],
  gridColumnGap: ['columnGap'],
  gridGap: ['columnGap', 'rowGap'],
  gridRow: ['gridRowEnd', 'gridRowStart'],
  gridRowGap: ['rowGap'],
  gridTemplate: ['gridTemplateAreas', 'gridTemplateColumns', 'gridTemplateRows'],
  listStyle: ['listStyleImage', 'listStylePosition', 'listStyleType'],
  margin: ['marginBottom', 'marginLeft', 'marginRight', 'marginTop'],
  marker: ['markerEnd', 'markerMid', 'markerStart'],
  mask: ['maskClip', 'maskComposite', 'maskImage', 'maskMode', 'maskOrigin', 'maskPositionX', 'maskPositionY', 'maskRepeat', 'maskSize'],
  maskPosition: ['maskPositionX', 'maskPositionY'],
  outline: ['outlineColor', 'outlineStyle', 'outlineWidth'],
  overflow: ['overflowX', 'overflowY'],
  padding: ['paddingBottom', 'paddingLeft', 'paddingRight', 'paddingTop'],
  placeContent: ['alignContent', 'justifyContent'],
  placeItems: ['alignItems', 'justifyItems'],
  placeSelf: ['alignSelf', 'justifySelf'],
  textDecoration: ['textDecorationColor', 'textDecorationLine', 'textDecorationStyle'],
  textEmphasis: ['textEmphasisColor', 'textEmphasisStyle'],
  transition: ['transitionDelay', 'transitionDuration', 'transitionProperty', 'transitionTimingFunction'],
  wordWrap: ['overflowWrap']
};

/**
 * CSS properties which accept numbers but are not in units of "px".
 */
var isUnitlessNumber = {
  animationIterationCount: true,
  borderImageOutset: true,
  borderImageSlice: true,
  borderImageWidth: true,
  boxFlex: true,
  boxFlexGroup: true,
  boxOrdinalGroup: true,
  columnCount: true,
  columns: true,
  flex: true,
  flexGrow: true,
  flexPositive: true,
  flexShrink: true,
  flexNegative: true,
  flexOrder: true,
  gridArea: true,
  gridRow: true,
  gridRowEnd: true,
  gridRowSpan: true,
  gridRowStart: true,
  gridColumn: true,
  gridColumnEnd: true,
  gridColumnSpan: true,
  gridColumnStart: true,
  fontWeight: true,
  lineClamp: true,
  lineHeight: true,
  opacity: true,
  order: true,
  orphans: true,
  tabSize: true,
  widows: true,
  zIndex: true,
  zoom: true,
  // SVG-related properties
  fillOpacity: true,
  floodOpacity: true,
  stopOpacity: true,
  strokeDasharray: true,
  strokeDashoffset: true,
  strokeMiterlimit: true,
  strokeOpacity: true,
  strokeWidth: true
};
/**
 * @param {string} prefix vendor-specific prefix, eg: Webkit
 * @param {string} key style name, eg: transitionDuration
 * @return {string} style name prefixed with `prefix`, properly camelCased, eg:
 * WebkitTransitionDuration
 */

function prefixKey(prefix, key) {
  return prefix + key.charAt(0).toUpperCase() + key.substring(1);
}
/**
 * Support style names that may come passed in prefixed by adding permutations
 * of vendor prefixes.
 */


var prefixes = ['Webkit', 'ms', 'Moz', 'O']; // Using Object.keys here, or else the vanilla for-in loop makes IE8 go into an
// infinite loop, because it iterates over the newly added props too.

Object.keys(isUnitlessNumber).forEach(function (prop) {
  prefixes.forEach(function (prefix) {
    isUnitlessNumber[prefixKey(prefix, prop)] = isUnitlessNumber[prop];
  });
});

/**
 * Convert a value into the proper css writable value. The style name `name`
 * should be logical (no hyphens), as specified
 * in `CSSProperty.isUnitlessNumber`.
 *
 * @param {string} name CSS property name such as `topMargin`.
 * @param {*} value CSS property value such as `10px`.
 * @return {string} Normalized style value with dimensions applied.
 */

function dangerousStyleValue(name, value, isCustomProperty) {
  // Note that we've removed escapeTextForBrowser() calls here since the
  // whole string will be escaped when the attribute is injected into
  // the markup. If you provide unsafe user data here they can inject
  // arbitrary CSS which may be problematic (I couldn't repro this):
  // https://www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet
  // http://www.thespanner.co.uk/2007/11/26/ultimate-xss-css-injection/
  // This is not an XSS hole but instead a potential CSS injection issue
  // which has lead to a greater discussion about how we're going to
  // trust URLs moving forward. See #2115901
  var isEmpty = value == null || typeof value === 'boolean' || value === '';

  if (isEmpty) {
    return '';
  }

  if (!isCustomProperty && typeof value === 'number' && value !== 0 && !(isUnitlessNumber.hasOwnProperty(name) && isUnitlessNumber[name])) {
    return value + 'px'; // Presumes implicit 'px' suffix for unitless numbers
  }

  return ('' + value).trim();
}

var uppercasePattern = /([A-Z])/g;
var msPattern = /^ms-/;
/**
 * Hyphenates a camelcased CSS property name, for example:
 *
 *   > hyphenateStyleName('backgroundColor')
 *   < "background-color"
 *   > hyphenateStyleName('MozTransition')
 *   < "-moz-transition"
 *   > hyphenateStyleName('msTransition')
 *   < "-ms-transition"
 *
 * As Modernizr suggests (http://modernizr.com/docs/#prefixed), an `ms` prefix
 * is converted to `-ms-`.
 */

function hyphenateStyleName(name) {
  return name.replace(uppercasePattern, '-$1').toLowerCase().replace(msPattern, '-ms-');
}

var warnValidStyle = function () {};

{
  // 'msTransform' is correct, but the other prefixes should be capitalized
  var badVendoredStyleNamePattern = /^(?:webkit|moz|o)[A-Z]/;
  var msPattern$1 = /^-ms-/;
  var hyphenPattern = /-(.)/g; // style values shouldn't contain a semicolon

  var badStyleValueWithSemicolonPattern = /;\s*$/;
  var warnedStyleNames = {};
  var warnedStyleValues = {};
  var warnedForNaNValue = false;
  var warnedForInfinityValue = false;

  var camelize = function (string) {
    return string.replace(hyphenPattern, function (_, character) {
      return character.toUpperCase();
    });
  };

  var warnHyphenatedStyleName = function (name) {
    if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {
      return;
    }

    warnedStyleNames[name] = true;

    error('Unsupported style property %s. Did you mean %s?', name, // As Andi Smith suggests
    // (http://www.andismith.com/blog/2012/02/modernizr-prefixed/), an `-ms` prefix
    // is converted to lowercase `ms`.
    camelize(name.replace(msPattern$1, 'ms-')));
  };

  var warnBadVendoredStyleName = function (name) {
    if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {
      return;
    }

    warnedStyleNames[name] = true;

    error('Unsupported vendor-prefixed style property %s. Did you mean %s?', name, name.charAt(0).toUpperCase() + name.slice(1));
  };

  var warnStyleValueWithSemicolon = function (name, value) {
    if (warnedStyleValues.hasOwnProperty(value) && warnedStyleValues[value]) {
      return;
    }

    warnedStyleValues[value] = true;

    error("Style property values shouldn't contain a semicolon. " + 'Try "%s: %s" instead.', name, value.replace(badStyleValueWithSemicolonPattern, ''));
  };

  var warnStyleValueIsNaN = function (name, value) {
    if (warnedForNaNValue) {
      return;
    }

    warnedForNaNValue = true;

    error('`NaN` is an invalid value for the `%s` css style property.', name);
  };

  var warnStyleValueIsInfinity = function (name, value) {
    if (warnedForInfinityValue) {
      return;
    }

    warnedForInfinityValue = true;

    error('`Infinity` is an invalid value for the `%s` css style property.', name);
  };

  warnValidStyle = function (name, value) {
    if (name.indexOf('-') > -1) {
      warnHyphenatedStyleName(name);
    } else if (badVendoredStyleNamePattern.test(name)) {
      warnBadVendoredStyleName(name);
    } else if (badStyleValueWithSemicolonPattern.test(value)) {
      warnStyleValueWithSemicolon(name, value);
    }

    if (typeof value === 'number') {
      if (isNaN(value)) {
        warnStyleValueIsNaN(name, value);
      } else if (!isFinite(value)) {
        warnStyleValueIsInfinity(name, value);
      }
    }
  };
}

var warnValidStyle$1 = warnValidStyle;

/**
 * Operations for dealing with CSS properties.
 */

/**
 * This creates a string that is expected to be equivalent to the style
 * attribute generated by server-side rendering. It by-passes warnings and
 * security checks so it's not safe to use this value for anything other than
 * comparison. It is only used in DEV for SSR validation.
 */

function createDangerousStringForStyles(styles) {
  {
    var serialized = '';
    var delimiter = '';

    for (var styleName in styles) {
      if (!styles.hasOwnProperty(styleName)) {
        continue;
      }

      var styleValue = styles[styleName];

      if (styleValue != null) {
        var isCustomProperty = styleName.indexOf('--') === 0;
        serialized += delimiter + (isCustomProperty ? styleName : hyphenateStyleName(styleName)) + ':';
        serialized += dangerousStyleValue(styleName, styleValue, isCustomProperty);
        delimiter = ';';
      }
    }

    return serialized || null;
  }
}
/**
 * Sets the value for multiple styles on a node.  If a value is specified as
 * '' (empty string), the corresponding style property will be unset.
 *
 * @param {DOMElement} node
 * @param {object} styles
 */

function setValueForStyles(node, styles) {
  var style = node.style;

  for (var styleName in styles) {
    if (!styles.hasOwnProperty(styleName)) {
      continue;
    }

    var isCustomProperty = styleName.indexOf('--') === 0;

    {
      if (!isCustomProperty) {
        warnValidStyle$1(styleName, styles[styleName]);
      }
    }

    var styleValue = dangerousStyleValue(styleName, styles[styleName], isCustomProperty);

    if (styleName === 'float') {
      styleName = 'cssFloat';
    }

    if (isCustomProperty) {
      style.setProperty(styleName, styleValue);
    } else {
      style[styleName] = styleValue;
    }
  }
}

function isValueEmpty(value) {
  return value == null || typeof value === 'boolean' || value === '';
}
/**
 * Given {color: 'red', overflow: 'hidden'} returns {
 *   color: 'color',
 *   overflowX: 'overflow',
 *   overflowY: 'overflow',
 * }. This can be read as "the overflowY property was set by the overflow
 * shorthand". That is, the values are the property that each was derived from.
 */


function expandShorthandMap(styles) {
  var expanded = {};

  for (var key in styles) {
    var longhands = shorthandToLonghand[key] || [key];

    for (var i = 0; i < longhands.length; i++) {
      expanded[longhands[i]] = key;
    }
  }

  return expanded;
}
/**
 * When mixing shorthand and longhand property names, we warn during updates if
 * we expect an incorrect result to occur. In particular, we warn for:
 *
 * Updating a shorthand property (longhand gets overwritten):
 *   {font: 'foo', fontVariant: 'bar'} -> {font: 'baz', fontVariant: 'bar'}
 *   becomes .style.font = 'baz'
 * Removing a shorthand property (longhand gets lost too):
 *   {font: 'foo', fontVariant: 'bar'} -> {fontVariant: 'bar'}
 *   becomes .style.font = ''
 * Removing a longhand property (should revert to shorthand; doesn't):
 *   {font: 'foo', fontVariant: 'bar'} -> {font: 'foo'}
 *   becomes .style.fontVariant = ''
 */


function validateShorthandPropertyCollisionInDev(styleUpdates, nextStyles) {
  {
    if (!nextStyles) {
      return;
    }

    var expandedUpdates = expandShorthandMap(styleUpdates);
    var expandedStyles = expandShorthandMap(nextStyles);
    var warnedAbout = {};

    for (var key in expandedUpdates) {
      var originalKey = expandedUpdates[key];
      var correctOriginalKey = expandedStyles[key];

      if (correctOriginalKey && originalKey !== correctOriginalKey) {
        var warningKey = originalKey + ',' + correctOriginalKey;

        if (warnedAbout[warningKey]) {
          continue;
        }

        warnedAbout[warningKey] = true;

        error('%s a style property during rerender (%s) when a ' + 'conflicting property is set (%s) can lead to styling bugs. To ' + "avoid this, don't mix shorthand and non-shorthand properties " + 'for the same value; instead, replace the shorthand with ' + 'separate values.', isValueEmpty(styleUpdates[originalKey]) ? 'Removing' : 'Updating', originalKey, correctOriginalKey);
      }
    }
  }
}

// For HTML, certain tags should omit their close tag. We keep a list for
// those special-case tags.
var omittedCloseTags = {
  area: true,
  base: true,
  br: true,
  col: true,
  embed: true,
  hr: true,
  img: true,
  input: true,
  keygen: true,
  link: true,
  meta: true,
  param: true,
  source: true,
  track: true,
  wbr: true // NOTE: menuitem's close tag should be omitted, but that causes problems.

};

// `omittedCloseTags` except that `menuitem` should still have its closing tag.

var voidElementTags = _assign({
  menuitem: true
}, omittedCloseTags);

var HTML = '__html';

function assertValidProps(tag, props) {
  if (!props) {
    return;
  } // Note the use of `==` which checks for null or undefined.


  if (voidElementTags[tag]) {
    if (!(props.children == null && props.dangerouslySetInnerHTML == null)) {
      {
        throw Error( tag + " is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`." );
      }
    }
  }

  if (props.dangerouslySetInnerHTML != null) {
    if (!(props.children == null)) {
      {
        throw Error( "Can only set one of `children` or `props.dangerouslySetInnerHTML`." );
      }
    }

    if (!(typeof props.dangerouslySetInnerHTML === 'object' && HTML in props.dangerouslySetInnerHTML)) {
      {
        throw Error( "`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://reactjs.org/link/dangerously-set-inner-html for more information." );
      }
    }
  }

  {
    if (!props.suppressContentEditableWarning && props.contentEditable && props.children != null) {
      error('A component is `contentEditable` and contains `children` managed by ' + 'React. It is now your responsibility to guarantee that none of ' + 'those nodes are unexpectedly modified or duplicated. This is ' + 'probably not intentional.');
    }
  }

  if (!(props.style == null || typeof props.style === 'object')) {
    {
      throw Error( "The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + 'em'}} when using JSX." );
    }
  }
}

function isCustomComponent(tagName, props) {
  if (tagName.indexOf('-') === -1) {
    return typeof props.is === 'string';
  }

  switch (tagName) {
    // These are reserved SVG and MathML elements.
    // We don't mind this list too much because we expect it to never grow.
    // The alternative is to track the namespace in a few places which is convoluted.
    // https://w3c.github.io/webcomponents/spec/custom/#custom-elements-core-concepts
    case 'annotation-xml':
    case 'color-profile':
    case 'font-face':
    case 'font-face-src':
    case 'font-face-uri':
    case 'font-face-format':
    case 'font-face-name':
    case 'missing-glyph':
      return false;

    default:
      return true;
  }
}

// When adding attributes to the HTML or SVG allowed attribute list, be sure to
// also add them to this module to ensure casing and incorrect name
// warnings.
var possibleStandardNames = {
  // HTML
  accept: 'accept',
  acceptcharset: 'acceptCharset',
  'accept-charset': 'acceptCharset',
  accesskey: 'accessKey',
  action: 'action',
  allowfullscreen: 'allowFullScreen',
  alt: 'alt',
  as: 'as',
  async: 'async',
  autocapitalize: 'autoCapitalize',
  autocomplete: 'autoComplete',
  autocorrect: 'autoCorrect',
  autofocus: 'autoFocus',
  autoplay: 'autoPlay',
  autosave: 'autoSave',
  capture: 'capture',
  cellpadding: 'cellPadding',
  cellspacing: 'cellSpacing',
  challenge: 'challenge',
  charset: 'charSet',
  checked: 'checked',
  children: 'children',
  cite: 'cite',
  class: 'className',
  classid: 'classID',
  classname: 'className',
  cols: 'cols',
  colspan: 'colSpan',
  content: 'content',
  contenteditable: 'contentEditable',
  contextmenu: 'contextMenu',
  controls: 'controls',
  controlslist: 'controlsList',
  coords: 'coords',
  crossorigin: 'crossOrigin',
  dangerouslysetinnerhtml: 'dangerouslySetInnerHTML',
  data: 'data',
  datetime: 'dateTime',
  default: 'default',
  defaultchecked: 'defaultChecked',
  defaultvalue: 'defaultValue',
  defer: 'defer',
  dir: 'dir',
  disabled: 'disabled',
  disablepictureinpicture: 'disablePictureInPicture',
  disableremoteplayback: 'disableRemotePlayback',
  download: 'download',
  draggable: 'draggable',
  enctype: 'encType',
  enterkeyhint: 'enterKeyHint',
  for: 'htmlFor',
  form: 'form',
  formmethod: 'formMethod',
  formaction: 'formAction',
  formenctype: 'formEncType',
  formnovalidate: 'formNoValidate',
  formtarget: 'formTarget',
  frameborder: 'frameBorder',
  headers: 'headers',
  height: 'height',
  hidden: 'hidden',
  high: 'high',
  href: 'href',
  hreflang: 'hrefLang',
  htmlfor: 'htmlFor',
  httpequiv: 'httpEquiv',
  'http-equiv': 'httpEquiv',
  icon: 'icon',
  id: 'id',
  innerhtml: 'innerHTML',
  inputmode: 'inputMode',
  integrity: 'integrity',
  is: 'is',
  itemid: 'itemID',
  itemprop: 'itemProp',
  itemref: 'itemRef',
  itemscope: 'itemScope',
  itemtype: 'itemType',
  keyparams: 'keyParams',
  keytype: 'keyType',
  kind: 'kind',
  label: 'label',
  lang: 'lang',
  list: 'list',
  loop: 'loop',
  low: 'low',
  manifest: 'manifest',
  marginwidth: 'marginWidth',
  marginheight: 'marginHeight',
  max: 'max',
  maxlength: 'maxLength',
  media: 'media',
  mediagroup: 'mediaGroup',
  method: 'method',
  min: 'min',
  minlength: 'minLength',
  multiple: 'multiple',
  muted: 'muted',
  name: 'name',
  nomodule: 'noModule',
  nonce: 'nonce',
  novalidate: 'noValidate',
  open: 'open',
  optimum: 'optimum',
  pattern: 'pattern',
  placeholder: 'placeholder',
  playsinline: 'playsInline',
  poster: 'poster',
  preload: 'preload',
  profile: 'profile',
  radiogroup: 'radioGroup',
  readonly: 'readOnly',
  referrerpolicy: 'referrerPolicy',
  rel: 'rel',
  required: 'required',
  reversed: 'reversed',
  role: 'role',
  rows: 'rows',
  rowspan: 'rowSpan',
  sandbox: 'sandbox',
  scope: 'scope',
  scoped: 'scoped',
  scrolling: 'scrolling',
  seamless: 'seamless',
  selected: 'selected',
  shape: 'shape',
  size: 'size',
  sizes: 'sizes',
  span: 'span',
  spellcheck: 'spellCheck',
  src: 'src',
  srcdoc: 'srcDoc',
  srclang: 'srcLang',
  srcset: 'srcSet',
  start: 'start',
  step: 'step',
  style: 'style',
  summary: 'summary',
  tabindex: 'tabIndex',
  target: 'target',
  title: 'title',
  type: 'type',
  usemap: 'useMap',
  value: 'value',
  width: 'width',
  wmode: 'wmode',
  wrap: 'wrap',
  // SVG
  about: 'about',
  accentheight: 'accentHeight',
  'accent-height': 'accentHeight',
  accumulate: 'accumulate',
  additive: 'additive',
  alignmentbaseline: 'alignmentBaseline',
  'alignment-baseline': 'alignmentBaseline',
  allowreorder: 'allowReorder',
  alphabetic: 'alphabetic',
  amplitude: 'amplitude',
  arabicform: 'arabicForm',
  'arabic-form': 'arabicForm',
  ascent: 'ascent',
  attributename: 'attributeName',
  attributetype: 'attributeType',
  autoreverse: 'autoReverse',
  azimuth: 'azimuth',
  basefrequency: 'baseFrequency',
  baselineshift: 'baselineShift',
  'baseline-shift': 'baselineShift',
  baseprofile: 'baseProfile',
  bbox: 'bbox',
  begin: 'begin',
  bias: 'bias',
  by: 'by',
  calcmode: 'calcMode',
  capheight: 'capHeight',
  'cap-height': 'capHeight',
  clip: 'clip',
  clippath: 'clipPath',
  'clip-path': 'clipPath',
  clippathunits: 'clipPathUnits',
  cliprule: 'clipRule',
  'clip-rule': 'clipRule',
  color: 'color',
  colorinterpolation: 'colorInterpolation',
  'color-interpolation': 'colorInterpolation',
  colorinterpolationfilters: 'colorInterpolationFilters',
  'color-interpolation-filters': 'colorInterpolationFilters',
  colorprofile: 'colorProfile',
  'color-profile': 'colorProfile',
  colorrendering: 'colorRendering',
  'color-rendering': 'colorRendering',
  contentscripttype: 'contentScriptType',
  contentstyletype: 'contentStyleType',
  cursor: 'cursor',
  cx: 'cx',
  cy: 'cy',
  d: 'd',
  datatype: 'datatype',
  decelerate: 'decelerate',
  descent: 'descent',
  diffuseconstant: 'diffuseConstant',
  direction: 'direction',
  display: 'display',
  divisor: 'divisor',
  dominantbaseline: 'dominantBaseline',
  'dominant-baseline': 'dominantBaseline',
  dur: 'dur',
  dx: 'dx',
  dy: 'dy',
  edgemode: 'edgeMode',
  elevation: 'elevation',
  enablebackground: 'enableBackground',
  'enable-background': 'enableBackground',
  end: 'end',
  exponent: 'exponent',
  externalresourcesrequired: 'externalResourcesRequired',
  fill: 'fill',
  fillopacity: 'fillOpacity',
  'fill-opacity': 'fillOpacity',
  fillrule: 'fillRule',
  'fill-rule': 'fillRule',
  filter: 'filter',
  filterres: 'filterRes',
  filterunits: 'filterUnits',
  floodopacity: 'floodOpacity',
  'flood-opacity': 'floodOpacity',
  floodcolor: 'floodColor',
  'flood-color': 'floodColor',
  focusable: 'focusable',
  fontfamily: 'fontFamily',
  'font-family': 'fontFamily',
  fontsize: 'fontSize',
  'font-size': 'fontSize',
  fontsizeadjust: 'fontSizeAdjust',
  'font-size-adjust': 'fontSizeAdjust',
  fontstretch: 'fontStretch',
  'font-stretch': 'fontStretch',
  fontstyle: 'fontStyle',
  'font-style': 'fontStyle',
  fontvariant: 'fontVariant',
  'font-variant': 'fontVariant',
  fontweight: 'fontWeight',
  'font-weight': 'fontWeight',
  format: 'format',
  from: 'from',
  fx: 'fx',
  fy: 'fy',
  g1: 'g1',
  g2: 'g2',
  glyphname: 'glyphName',
  'glyph-name': 'glyphName',
  glyphorientationhorizontal: 'glyphOrientationHorizontal',
  'glyph-orientation-horizontal': 'glyphOrientationHorizontal',
  glyphorientationvertical: 'glyphOrientationVertical',
  'glyph-orientation-vertical': 'glyphOrientationVertical',
  glyphref: 'glyphRef',
  gradienttransform: 'gradientTransform',
  gradientunits: 'gradientUnits',
  hanging: 'hanging',
  horizadvx: 'horizAdvX',
  'horiz-adv-x': 'horizAdvX',
  horizoriginx: 'horizOriginX',
  'horiz-origin-x': 'horizOriginX',
  ideographic: 'ideographic',
  imagerendering: 'imageRendering',
  'image-rendering': 'imageRendering',
  in2: 'in2',
  in: 'in',
  inlist: 'inlist',
  intercept: 'intercept',
  k1: 'k1',
  k2: 'k2',
  k3: 'k3',
  k4: 'k4',
  k: 'k',
  kernelmatrix: 'kernelMatrix',
  kernelunitlength: 'kernelUnitLength',
  kerning: 'kerning',
  keypoints: 'keyPoints',
  keysplines: 'keySplines',
  keytimes: 'keyTimes',
  lengthadjust: 'lengthAdjust',
  letterspacing: 'letterSpacing',
  'letter-spacing': 'letterSpacing',
  lightingcolor: 'lightingColor',
  'lighting-color': 'lightingColor',
  limitingconeangle: 'limitingConeAngle',
  local: 'local',
  markerend: 'markerEnd',
  'marker-end': 'markerEnd',
  markerheight: 'markerHeight',
  markermid: 'markerMid',
  'marker-mid': 'markerMid',
  markerstart: 'markerStart',
  'marker-start': 'markerStart',
  markerunits: 'markerUnits',
  markerwidth: 'markerWidth',
  mask: 'mask',
  maskcontentunits: 'maskContentUnits',
  maskunits: 'maskUnits',
  mathematical: 'mathematical',
  mode: 'mode',
  numoctaves: 'numOctaves',
  offset: 'offset',
  opacity: 'opacity',
  operator: 'operator',
  order: 'order',
  orient: 'orient',
  orientation: 'orientation',
  origin: 'origin',
  overflow: 'overflow',
  overlineposition: 'overlinePosition',
  'overline-position': 'overlinePosition',
  overlinethickness: 'overlineThickness',
  'overline-thickness': 'overlineThickness',
  paintorder: 'paintOrder',
  'paint-order': 'paintOrder',
  panose1: 'panose1',
  'panose-1': 'panose1',
  pathlength: 'pathLength',
  patterncontentunits: 'patternContentUnits',
  patterntransform: 'patternTransform',
  patternunits: 'patternUnits',
  pointerevents: 'pointerEvents',
  'pointer-events': 'pointerEvents',
  points: 'points',
  pointsatx: 'pointsAtX',
  pointsaty: 'pointsAtY',
  pointsatz: 'pointsAtZ',
  prefix: 'prefix',
  preservealpha: 'preserveAlpha',
  preserveaspectratio: 'preserveAspectRatio',
  primitiveunits: 'primitiveUnits',
  property: 'property',
  r: 'r',
  radius: 'radius',
  refx: 'refX',
  refy: 'refY',
  renderingintent: 'renderingIntent',
  'rendering-intent': 'renderingIntent',
  repeatcount: 'repeatCount',
  repeatdur: 'repeatDur',
  requiredextensions: 'requiredExtensions',
  requiredfeatures: 'requiredFeatures',
  resource: 'resource',
  restart: 'restart',
  result: 'result',
  results: 'results',
  rotate: 'rotate',
  rx: 'rx',
  ry: 'ry',
  scale: 'scale',
  security: 'security',
  seed: 'seed',
  shaperendering: 'shapeRendering',
  'shape-rendering': 'shapeRendering',
  slope: 'slope',
  spacing: 'spacing',
  specularconstant: 'specularConstant',
  specularexponent: 'specularExponent',
  speed: 'speed',
  spreadmethod: 'spreadMethod',
  startoffset: 'startOffset',
  stddeviation: 'stdDeviation',
  stemh: 'stemh',
  stemv: 'stemv',
  stitchtiles: 'stitchTiles',
  stopcolor: 'stopColor',
  'stop-color': 'stopColor',
  stopopacity: 'stopOpacity',
  'stop-opacity': 'stopOpacity',
  strikethroughposition: 'strikethroughPosition',
  'strikethrough-position': 'strikethroughPosition',
  strikethroughthickness: 'strikethroughThickness',
  'strikethrough-thickness': 'strikethroughThickness',
  string: 'string',
  stroke: 'stroke',
  strokedasharray: 'strokeDasharray',
  'stroke-dasharray': 'strokeDasharray',
  strokedashoffset: 'strokeDashoffset',
  'stroke-dashoffset': 'strokeDashoffset',
  strokelinecap: 'strokeLinecap',
  'stroke-linecap': 'strokeLinecap',
  strokelinejoin: 'strokeLinejoin',
  'stroke-linejoin': 'strokeLinejoin',
  strokemiterlimit: 'strokeMiterlimit',
  'stroke-miterlimit': 'strokeMiterlimit',
  strokewidth: 'strokeWidth',
  'stroke-width': 'strokeWidth',
  strokeopacity: 'strokeOpacity',
  'stroke-opacity': 'strokeOpacity',
  suppresscontenteditablewarning: 'suppressContentEditableWarning',
  suppresshydrationwarning: 'suppressHydrationWarning',
  surfacescale: 'surfaceScale',
  systemlanguage: 'systemLanguage',
  tablevalues: 'tableValues',
  targetx: 'targetX',
  targety: 'targetY',
  textanchor: 'textAnchor',
  'text-anchor': 'textAnchor',
  textdecoration: 'textDecoration',
  'text-decoration': 'textDecoration',
  textlength: 'textLength',
  textrendering: 'textRendering',
  'text-rendering': 'textRendering',
  to: 'to',
  transform: 'transform',
  typeof: 'typeof',
  u1: 'u1',
  u2: 'u2',
  underlineposition: 'underlinePosition',
  'underline-position': 'underlinePosition',
  underlinethickness: 'underlineThickness',
  'underline-thickness': 'underlineThickness',
  unicode: 'unicode',
  unicodebidi: 'unicodeBidi',
  'unicode-bidi': 'unicodeBidi',
  unicoderange: 'unicodeRange',
  'unicode-range': 'unicodeRange',
  unitsperem: 'unitsPerEm',
  'units-per-em': 'unitsPerEm',
  unselectable: 'unselectable',
  valphabetic: 'vAlphabetic',
  'v-alphabetic': 'vAlphabetic',
  values: 'values',
  vectoreffect: 'vectorEffect',
  'vector-effect': 'vectorEffect',
  version: 'version',
  vertadvy: 'vertAdvY',
  'vert-adv-y': 'vertAdvY',
  vertoriginx: 'vertOriginX',
  'vert-origin-x': 'vertOriginX',
  vertoriginy: 'vertOriginY',
  'vert-origin-y': 'vertOriginY',
  vhanging: 'vHanging',
  'v-hanging': 'vHanging',
  videographic: 'vIdeographic',
  'v-ideographic': 'vIdeographic',
  viewbox: 'viewBox',
  viewtarget: 'viewTarget',
  visibility: 'visibility',
  vmathematical: 'vMathematical',
  'v-mathematical': 'vMathematical',
  vocab: 'vocab',
  widths: 'widths',
  wordspacing: 'wordSpacing',
  'word-spacing': 'wordSpacing',
  writingmode: 'writingMode',
  'writing-mode': 'writingMode',
  x1: 'x1',
  x2: 'x2',
  x: 'x',
  xchannelselector: 'xChannelSelector',
  xheight: 'xHeight',
  'x-height': 'xHeight',
  xlinkactuate: 'xlinkActuate',
  'xlink:actuate': 'xlinkActuate',
  xlinkarcrole: 'xlinkArcrole',
  'xlink:arcrole': 'xlinkArcrole',
  xlinkhref: 'xlinkHref',
  'xlink:href': 'xlinkHref',
  xlinkrole: 'xlinkRole',
  'xlink:role': 'xlinkRole',
  xlinkshow: 'xlinkShow',
  'xlink:show': 'xlinkShow',
  xlinktitle: 'xlinkTitle',
  'xlink:title': 'xlinkTitle',
  xlinktype: 'xlinkType',
  'xlink:type': 'xlinkType',
  xmlbase: 'xmlBase',
  'xml:base': 'xmlBase',
  xmllang: 'xmlLang',
  'xml:lang': 'xmlLang',
  xmlns: 'xmlns',
  'xml:space': 'xmlSpace',
  xmlnsxlink: 'xmlnsXlink',
  'xmlns:xlink': 'xmlnsXlink',
  xmlspace: 'xmlSpace',
  y1: 'y1',
  y2: 'y2',
  y: 'y',
  ychannelselector: 'yChannelSelector',
  z: 'z',
  zoomandpan: 'zoomAndPan'
};

var ariaProperties = {
  'aria-current': 0,
  // state
  'aria-details': 0,
  'aria-disabled': 0,
  // state
  'aria-hidden': 0,
  // state
  'aria-invalid': 0,
  // state
  'aria-keyshortcuts': 0,
  'aria-label': 0,
  'aria-roledescription': 0,
  // Widget Attributes
  'aria-autocomplete': 0,
  'aria-checked': 0,
  'aria-expanded': 0,
  'aria-haspopup': 0,
  'aria-level': 0,
  'aria-modal': 0,
  'aria-multiline': 0,
  'aria-multiselectable': 0,
  'aria-orientation': 0,
  'aria-placeholder': 0,
  'aria-pressed': 0,
  'aria-readonly': 0,
  'aria-required': 0,
  'aria-selected': 0,
  'aria-sort': 0,
  'aria-valuemax': 0,
  'aria-valuemin': 0,
  'aria-valuenow': 0,
  'aria-valuetext': 0,
  // Live Region Attributes
  'aria-atomic': 0,
  'aria-busy': 0,
  'aria-live': 0,
  'aria-relevant': 0,
  // Drag-and-Drop Attributes
  'aria-dropeffect': 0,
  'aria-grabbed': 0,
  // Relationship Attributes
  'aria-activedescendant': 0,
  'aria-colcount': 0,
  'aria-colindex': 0,
  'aria-colspan': 0,
  'aria-controls': 0,
  'aria-describedby': 0,
  'aria-errormessage': 0,
  'aria-flowto': 0,
  'aria-labelledby': 0,
  'aria-owns': 0,
  'aria-posinset': 0,
  'aria-rowcount': 0,
  'aria-rowindex': 0,
  'aria-rowspan': 0,
  'aria-setsize': 0
};

var warnedProperties = {};
var rARIA = new RegExp('^(aria)-[' + ATTRIBUTE_NAME_CHAR + ']*$');
var rARIACamel = new RegExp('^(aria)[A-Z][' + ATTRIBUTE_NAME_CHAR + ']*$');
var hasOwnProperty$1 = Object.prototype.hasOwnProperty;

function validateProperty(tagName, name) {
  {
    if (hasOwnProperty$1.call(warnedProperties, name) && warnedProperties[name]) {
      return true;
    }

    if (rARIACamel.test(name)) {
      var ariaName = 'aria-' + name.slice(4).toLowerCase();
      var correctName = ariaProperties.hasOwnProperty(ariaName) ? ariaName : null; // If this is an aria-* attribute, but is not listed in the known DOM
      // DOM properties, then it is an invalid aria-* attribute.

      if (correctName == null) {
        error('Invalid ARIA attribute `%s`. ARIA attributes follow the pattern aria-* and must be lowercase.', name);

        warnedProperties[name] = true;
        return true;
      } // aria-* attributes should be lowercase; suggest the lowercase version.


      if (name !== correctName) {
        error('Invalid ARIA attribute `%s`. Did you mean `%s`?', name, correctName);

        warnedProperties[name] = true;
        return true;
      }
    }

    if (rARIA.test(name)) {
      var lowerCasedName = name.toLowerCase();
      var standardName = ariaProperties.hasOwnProperty(lowerCasedName) ? lowerCasedName : null; // If this is an aria-* attribute, but is not listed in the known DOM
      // DOM properties, then it is an invalid aria-* attribute.

      if (standardName == null) {
        warnedProperties[name] = true;
        return false;
      } // aria-* attributes should be lowercase; suggest the lowercase version.


      if (name !== standardName) {
        error('Unknown ARIA attribute `%s`. Did you mean `%s`?', name, standardName);

        warnedProperties[name] = true;
        return true;
      }
    }
  }

  return true;
}

function warnInvalidARIAProps(type, props) {
  {
    var invalidProps = [];

    for (var key in props) {
      var isValid = validateProperty(type, key);

      if (!isValid) {
        invalidProps.push(key);
      }
    }

    var unknownPropString = invalidProps.map(function (prop) {
      return '`' + prop + '`';
    }).join(', ');

    if (invalidProps.length === 1) {
      error('Invalid aria prop %s on <%s> tag. ' + 'For details, see https://reactjs.org/link/invalid-aria-props', unknownPropString, type);
    } else if (invalidProps.length > 1) {
      error('Invalid aria props %s on <%s> tag. ' + 'For details, see https://reactjs.org/link/invalid-aria-props', unknownPropString, type);
    }
  }
}

function validateProperties(type, props) {
  if (isCustomComponent(type, props)) {
    return;
  }

  warnInvalidARIAProps(type, props);
}

var didWarnValueNull = false;
function validateProperties$1(type, props) {
  {
    if (type !== 'input' && type !== 'textarea' && type !== 'select') {
      return;
    }

    if (props != null && props.value === null && !didWarnValueNull) {
      didWarnValueNull = true;

      if (type === 'select' && props.multiple) {
        error('`value` prop on `%s` should not be null. ' + 'Consider using an empty array when `multiple` is set to `true` ' + 'to clear the component or `undefined` for uncontrolled components.', type);
      } else {
        error('`value` prop on `%s` should not be null. ' + 'Consider using an empty string to clear the component or `undefined` ' + 'for uncontrolled components.', type);
      }
    }
  }
}

var validateProperty$1 = function () {};

{
  var warnedProperties$1 = {};
  var _hasOwnProperty = Object.prototype.hasOwnProperty;
  var EVENT_NAME_REGEX = /^on./;
  var INVALID_EVENT_NAME_REGEX = /^on[^A-Z]/;
  var rARIA$1 = new RegExp('^(aria)-[' + ATTRIBUTE_NAME_CHAR + ']*$');
  var rARIACamel$1 = new RegExp('^(aria)[A-Z][' + ATTRIBUTE_NAME_CHAR + ']*$');

  validateProperty$1 = function (tagName, name, value, eventRegistry) {
    if (_hasOwnProperty.call(warnedProperties$1, name) && warnedProperties$1[name]) {
      return true;
    }

    var lowerCasedName = name.toLowerCase();

    if (lowerCasedName === 'onfocusin' || lowerCasedName === 'onfocusout') {
      error('React uses onFocus and onBlur instead of onFocusIn and onFocusOut. ' + 'All React events are normalized to bubble, so onFocusIn and onFocusOut ' + 'are not needed/supported by React.');

      warnedProperties$1[name] = true;
      return true;
    } // We can't rely on the event system being injected on the server.


    if (eventRegistry != null) {
      var registrationNameDependencies = eventRegistry.registrationNameDependencies,
          possibleRegistrationNames = eventRegistry.possibleRegistrationNames;

      if (registrationNameDependencies.hasOwnProperty(name)) {
        return true;
      }

      var registrationName = possibleRegistrationNames.hasOwnProperty(lowerCasedName) ? possibleRegistrationNames[lowerCasedName] : null;

      if (registrationName != null) {
        error('Invalid event handler property `%s`. Did you mean `%s`?', name, registrationName);

        warnedProperties$1[name] = true;
        return true;
      }

      if (EVENT_NAME_REGEX.test(name)) {
        error('Unknown event handler property `%s`. It will be ignored.', name);

        warnedProperties$1[name] = true;
        return true;
      }
    } else if (EVENT_NAME_REGEX.test(name)) {
      // If no event plugins have been injected, we are in a server environment.
      // So we can't tell if the event name is correct for sure, but we can filter
      // out known bad ones like `onclick`. We can't suggest a specific replacement though.
      if (INVALID_EVENT_NAME_REGEX.test(name)) {
        error('Invalid event handler property `%s`. ' + 'React events use the camelCase naming convention, for example `onClick`.', name);
      }

      warnedProperties$1[name] = true;
      return true;
    } // Let the ARIA attribute hook validate ARIA attributes


    if (rARIA$1.test(name) || rARIACamel$1.test(name)) {
      return true;
    }

    if (lowerCasedName === 'innerhtml') {
      error('Directly setting property `innerHTML` is not permitted. ' + 'For more information, lookup documentation on `dangerouslySetInnerHTML`.');

      warnedProperties$1[name] = true;
      return true;
    }

    if (lowerCasedName === 'aria') {
      error('The `aria` attribute is reserved for future use in React. ' + 'Pass individual `aria-` attributes instead.');

      warnedProperties$1[name] = true;
      return true;
    }

    if (lowerCasedName === 'is' && value !== null && value !== undefined && typeof value !== 'string') {
      error('Received a `%s` for a string attribute `is`. If this is expected, cast ' + 'the value to a string.', typeof value);

      warnedProperties$1[name] = true;
      return true;
    }

    if (typeof value === 'number' && isNaN(value)) {
      error('Received NaN for the `%s` attribute. If this is expected, cast ' + 'the value to a string.', name);

      warnedProperties$1[name] = true;
      return true;
    }

    var propertyInfo = getPropertyInfo(name);
    var isReserved = propertyInfo !== null && propertyInfo.type === RESERVED; // Known attributes should match the casing specified in the property config.

    if (possibleStandardNames.hasOwnProperty(lowerCasedName)) {
      var standardName = possibleStandardNames[lowerCasedName];

      if (standardName !== name) {
        error('Invalid DOM property `%s`. Did you mean `%s`?', name, standardName);

        warnedProperties$1[name] = true;
        return true;
      }
    } else if (!isReserved && name !== lowerCasedName) {
      // Unknown attributes should have lowercase casing since that's how they
      // will be cased anyway with server rendering.
      error('React does not recognize the `%s` prop on a DOM element. If you ' + 'intentionally want it to appear in the DOM as a custom ' + 'attribute, spell it as lowercase `%s` instead. ' + 'If you accidentally passed it from a parent component, remove ' + 'it from the DOM element.', name, lowerCasedName);

      warnedProperties$1[name] = true;
      return true;
    }

    if (typeof value === 'boolean' && shouldRemoveAttributeWithWarning(name, value, propertyInfo, false)) {
      if (value) {
        error('Received `%s` for a non-boolean attribute `%s`.\n\n' + 'If you want to write it to the DOM, pass a string instead: ' + '%s="%s" or %s={value.toString()}.', value, name, name, value, name);
      } else {
        error('Received `%s` for a non-boolean attribute `%s`.\n\n' + 'If you want to write it to the DOM, pass a string instead: ' + '%s="%s" or %s={value.toString()}.\n\n' + 'If you used to conditionally omit it with %s={condition && value}, ' + 'pass %s={condition ? value : undefined} instead.', value, name, name, value, name, name, name);
      }

      warnedProperties$1[name] = true;
      return true;
    } // Now that we've validated casing, do not validate
    // data types for reserved props


    if (isReserved) {
      return true;
    } // Warn when a known attribute is a bad type


    if (shouldRemoveAttributeWithWarning(name, value, propertyInfo, false)) {
      warnedProperties$1[name] = true;
      return false;
    } // Warn when passing the strings 'false' or 'true' into a boolean prop


    if ((value === 'false' || value === 'true') && propertyInfo !== null && propertyInfo.type === BOOLEAN) {
      error('Received the string `%s` for the boolean attribute `%s`. ' + '%s ' + 'Did you mean %s={%s}?', value, name, value === 'false' ? 'The browser will interpret it as a truthy value.' : 'Although this works, it will not work as expected if you pass the string "false".', name, value);

      warnedProperties$1[name] = true;
      return true;
    }

    return true;
  };
}

var warnUnknownProperties = function (type, props, eventRegistry) {
  {
    var unknownProps = [];

    for (var key in props) {
      var isValid = validateProperty$1(type, key, props[key], eventRegistry);

      if (!isValid) {
        unknownProps.push(key);
      }
    }

    var unknownPropString = unknownProps.map(function (prop) {
      return '`' + prop + '`';
    }).join(', ');

    if (unknownProps.length === 1) {
      error('Invalid value for prop %s on <%s> tag. Either remove it from the element, ' + 'or pass a string or number value to keep it in the DOM. ' + 'For details, see https://reactjs.org/link/attribute-behavior ', unknownPropString, type);
    } else if (unknownProps.length > 1) {
      error('Invalid values for props %s on <%s> tag. Either remove them from the element, ' + 'or pass a string or number value to keep them in the DOM. ' + 'For details, see https://reactjs.org/link/attribute-behavior ', unknownPropString, type);
    }
  }
};

function validateProperties$2(type, props, eventRegistry) {
  if (isCustomComponent(type, props)) {
    return;
  }

  warnUnknownProperties(type, props, eventRegistry);
}

var IS_EVENT_HANDLE_NON_MANAGED_NODE = 1;
var IS_NON_DELEGATED = 1 << 1;
var IS_CAPTURE_PHASE = 1 << 2;
var IS_REPLAYED = 1 << 4;
// set to LEGACY_FB_SUPPORT. LEGACY_FB_SUPPORT only gets set when
// we call willDeferLaterForLegacyFBSupport, thus not bailing out
// will result in endless cycles like an infinite loop.
// We also don't want to defer during event replaying.

var SHOULD_NOT_PROCESS_POLYFILL_EVENT_PLUGINS = IS_EVENT_HANDLE_NON_MANAGED_NODE | IS_NON_DELEGATED | IS_CAPTURE_PHASE;

/**
 * Gets the target node from a native browser event by accounting for
 * inconsistencies in browser DOM APIs.
 *
 * @param {object} nativeEvent Native browser event.
 * @return {DOMEventTarget} Target node.
 */

function getEventTarget(nativeEvent) {
  // Fallback to nativeEvent.srcElement for IE9
  // https://github.com/facebook/react/issues/12506
  var target = nativeEvent.target || nativeEvent.srcElement || window; // Normalize SVG <use> element events #4963

  if (target.correspondingUseElement) {
    target = target.correspondingUseElement;
  } // Safari may fire events on text nodes (Node.TEXT_NODE is 3).
  // @see http://www.quirksmode.org/js/events_properties.html


  return target.nodeType === TEXT_NODE ? target.parentNode : target;
}

var restoreImpl = null;
var restoreTarget = null;
var restoreQueue = null;

function restoreStateOfTarget(target) {
  // We perform this translation at the end of the event loop so that we
  // always receive the correct fiber here
  var internalInstance = getInstanceFromNode(target);

  if (!internalInstance) {
    // Unmounted
    return;
  }

  if (!(typeof restoreImpl === 'function')) {
    {
      throw Error( "setRestoreImplementation() needs to be called to handle a target for controlled events. This error is likely caused by a bug in React. Please file an issue." );
    }
  }

  var stateNode = internalInstance.stateNode; // Guard against Fiber being unmounted.

  if (stateNode) {
    var _props = getFiberCurrentPropsFromNode(stateNode);

    restoreImpl(internalInstance.stateNode, internalInstance.type, _props);
  }
}

function setRestoreImplementation(impl) {
  restoreImpl = impl;
}
function enqueueStateRestore(target) {
  if (restoreTarget) {
    if (restoreQueue) {
      restoreQueue.push(target);
    } else {
      restoreQueue = [target];
    }
  } else {
    restoreTarget = target;
  }
}
function needsStateRestore() {
  return restoreTarget !== null || restoreQueue !== null;
}
function restoreStateIfNeeded() {
  if (!restoreTarget) {
    return;
  }

  var target = restoreTarget;
  var queuedTargets = restoreQueue;
  restoreTarget = null;
  restoreQueue = null;
  restoreStateOfTarget(target);

  if (queuedTargets) {
    for (var i = 0; i < queuedTargets.length; i++) {
      restoreStateOfTarget(queuedTargets[i]);
    }
  }
}

// the renderer. Such as when we're dispatching events or if third party
// libraries need to call batchedUpdates. Eventually, this API will go away when
// everything is batched by default. We'll then have a similar API to opt-out of
// scheduled work and instead do synchronous work.
// Defaults

var batchedUpdatesImpl = function (fn, bookkeeping) {
  return fn(bookkeeping);
};

var discreteUpdatesImpl = function (fn, a, b, c, d) {
  return fn(a, b, c, d);
};

var flushDiscreteUpdatesImpl = function () {};

var batchedEventUpdatesImpl = batchedUpdatesImpl;
var isInsideEventHandler = false;
var isBatchingEventUpdates = false;

function finishEventHandler() {
  // Here we wait until all updates have propagated, which is important
  // when using controlled components within layers:
  // https://github.com/facebook/react/issues/1698
  // Then we restore state of any controlled component.
  var controlledComponentsHavePendingUpdates = needsStateRestore();

  if (controlledComponentsHavePendingUpdates) {
    // If a controlled event was fired, we may need to restore the state of
    // the DOM node back to the controlled value. This is necessary when React
    // bails out of the update without touching the DOM.
    flushDiscreteUpdatesImpl();
    restoreStateIfNeeded();
  }
}

function batchedUpdates(fn, bookkeeping) {
  if (isInsideEventHandler) {
    // If we are currently inside another batch, we need to wait until it
    // fully completes before restoring state.
    return fn(bookkeeping);
  }

  isInsideEventHandler = true;

  try {
    return batchedUpdatesImpl(fn, bookkeeping);
  } finally {
    isInsideEventHandler = false;
    finishEventHandler();
  }
}
function batchedEventUpdates(fn, a, b) {
  if (isBatchingEventUpdates) {
    // If we are currently inside another batch, we need to wait until it
    // fully completes before restoring state.
    return fn(a, b);
  }

  isBatchingEventUpdates = true;

  try {
    return batchedEventUpdatesImpl(fn, a, b);
  } finally {
    isBatchingEventUpdates = false;
    finishEventHandler();
  }
}
function discreteUpdates(fn, a, b, c, d) {
  var prevIsInsideEventHandler = isInsideEventHandler;
  isInsideEventHandler = true;

  try {
    return discreteUpdatesImpl(fn, a, b, c, d);
  } finally {
    isInsideEventHandler = prevIsInsideEventHandler;

    if (!isInsideEventHandler) {
      finishEventHandler();
    }
  }
}
function flushDiscreteUpdatesIfNeeded(timeStamp) {
  {
    if (!isInsideEventHandler) {
      flushDiscreteUpdatesImpl();
    }
  }
}
function setBatchingImplementation(_batchedUpdatesImpl, _discreteUpdatesImpl, _flushDiscreteUpdatesImpl, _batchedEventUpdatesImpl) {
  batchedUpdatesImpl = _batchedUpdatesImpl;
  discreteUpdatesImpl = _discreteUpdatesImpl;
  flushDiscreteUpdatesImpl = _flushDiscreteUpdatesImpl;
  batchedEventUpdatesImpl = _batchedEventUpdatesImpl;
}

function isInteractive(tag) {
  return tag === 'button' || tag === 'input' || tag === 'select' || tag === 'textarea';
}

function shouldPreventMouseEvent(name, type, props) {
  switch (name) {
    case 'onClick':
    case 'onClickCapture':
    case 'onDoubleClick':
    case 'onDoubleClickCapture':
    case 'onMouseDown':
    case 'onMouseDownCapture':
    case 'onMouseMove':
    case 'onMouseMoveCapture':
    case 'onMouseUp':
    case 'onMouseUpCapture':
    case 'onMouseEnter':
      return !!(props.disabled && isInteractive(type));

    default:
      return false;
  }
}
/**
 * @param {object} inst The instance, which is the source of events.
 * @param {string} registrationName Name of listener (e.g. `onClick`).
 * @return {?function} The stored callback.
 */


function getListener(inst, registrationName) {
  var stateNode = inst.stateNode;

  if (stateNode === null) {
    // Work in progress (ex: onload events in incremental mode).
    return null;
  }

  var props = getFiberCurrentPropsFromNode(stateNode);

  if (props === null) {
    // Work in progress.
    return null;
  }

  var listener = props[registrationName];

  if (shouldPreventMouseEvent(registrationName, inst.type, props)) {
    return null;
  }

  if (!(!listener || typeof listener === 'function')) {
    {
      throw Error( "Expected `" + registrationName + "` listener to be a function, instead got a value of `" + typeof listener + "` type." );
    }
  }

  return listener;
}

var passiveBrowserEventsSupported = false; // Check if browser support events with passive listeners
// https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener#Safely_detecting_option_support

if (canUseDOM) {
  try {
    var options = {}; // $FlowFixMe: Ignore Flow complaining about needing a value

    Object.defineProperty(options, 'passive', {
      get: function () {
        passiveBrowserEventsSupported = true;
      }
    });
    window.addEventListener('test', options, options);
    window.removeEventListener('test', options, options);
  } catch (e) {
    passiveBrowserEventsSupported = false;
  }
}

function invokeGuardedCallbackProd(name, func, context, a, b, c, d, e, f) {
  var funcArgs = Array.prototype.slice.call(arguments, 3);

  try {
    func.apply(context, funcArgs);
  } catch (error) {
    this.onError(error);
  }
}

var invokeGuardedCallbackImpl = invokeGuardedCallbackProd;

{
  // In DEV mode, we swap out invokeGuardedCallback for a special version
  // that plays more nicely with the browser's DevTools. The idea is to preserve
  // "Pause on exceptions" behavior. Because React wraps all user-provided
  // functions in invokeGuardedCallback, and the production version of
  // invokeGuardedCallback uses a try-catch, all user exceptions are treated
  // like caught exceptions, and the DevTools won't pause unless the developer
  // takes the extra step of enabling pause on caught exceptions. This is
  // unintuitive, though, because even though React has caught the error, from
  // the developer's perspective, the error is uncaught.
  //
  // To preserve the expected "Pause on exceptions" behavior, we don't use a
  // try-catch in DEV. Instead, we synchronously dispatch a fake event to a fake
  // DOM node, and call the user-provided callback from inside an event handler
  // for that fake event. If the callback throws, the error is "captured" using
  // a global event handler. But because the error happens in a different
  // event loop context, it does not interrupt the normal program flow.
  // Effectively, this gives us try-catch behavior without actually using
  // try-catch. Neat!
  // Check that the browser supports the APIs we need to implement our special
  // DEV version of invokeGuardedCallback
  if (typeof window !== 'undefined' && typeof window.dispatchEvent === 'function' && typeof document !== 'undefined' && typeof document.createEvent === 'function') {
    var fakeNode = document.createElement('react');

    invokeGuardedCallbackImpl = function invokeGuardedCallbackDev(name, func, context, a, b, c, d, e, f) {
      // If document doesn't exist we know for sure we will crash in this method
      // when we call document.createEvent(). However this can cause confusing
      // errors: https://github.com/facebookincubator/create-react-app/issues/3482
      // So we preemptively throw with a better message instead.
      if (!(typeof document !== 'undefined')) {
        {
          throw Error( "The `document` global was defined when React was initialized, but is not defined anymore. This can happen in a test environment if a component schedules an update from an asynchronous callback, but the test has already finished running. To solve this, you can either unmount the component at the end of your test (and ensure that any asynchronous operations get canceled in `componentWillUnmount`), or you can change the test itself to be asynchronous." );
        }
      }

      var evt = document.createEvent('Event');
      var didCall = false; // Keeps track of whether the user-provided callback threw an error. We
      // set this to true at the beginning, then set it to false right after
      // calling the function. If the function errors, `didError` will never be
      // set to false. This strategy works even if the browser is flaky and
      // fails to call our global error handler, because it doesn't rely on
      // the error event at all.

      var didError = true; // Keeps track of the value of window.event so that we can reset it
      // during the callback to let user code access window.event in the
      // browsers that support it.

      var windowEvent = window.event; // Keeps track of the descriptor of window.event to restore it after event
      // dispatching: https://github.com/facebook/react/issues/13688

      var windowEventDescriptor = Object.getOwnPropertyDescriptor(window, 'event');

      function restoreAfterDispatch() {
        // We immediately remove the callback from event listeners so that
        // nested `invokeGuardedCallback` calls do not clash. Otherwise, a
        // nested call would trigger the fake event handlers of any call higher
        // in the stack.
        fakeNode.removeEventListener(evtType, callCallback, false); // We check for window.hasOwnProperty('event') to prevent the
        // window.event assignment in both IE <= 10 as they throw an error
        // "Member not found" in strict mode, and in Firefox which does not
        // support window.event.

        if (typeof window.event !== 'undefined' && window.hasOwnProperty('event')) {
          window.event = windowEvent;
        }
      } // Create an event handler for our fake event. We will synchronously
      // dispatch our fake event using `dispatchEvent`. Inside the handler, we
      // call the user-provided callback.


      var funcArgs = Array.prototype.slice.call(arguments, 3);

      function callCallback() {
        didCall = true;
        restoreAfterDispatch();
        func.apply(context, funcArgs);
        didError = false;
      } // Create a global error event handler. We use this to capture the value
      // that was thrown. It's possible that this error handler will fire more
      // than once; for example, if non-React code also calls `dispatchEvent`
      // and a handler for that event throws. We should be resilient to most of
      // those cases. Even if our error event handler fires more than once, the
      // last error event is always used. If the callback actually does error,
      // we know that the last error event is the correct one, because it's not
      // possible for anything else to have happened in between our callback
      // erroring and the code that follows the `dispatchEvent` call below. If
      // the callback doesn't error, but the error event was fired, we know to
      // ignore it because `didError` will be false, as described above.


      var error; // Use this to track whether the error event is ever called.

      var didSetError = false;
      var isCrossOriginError = false;

      function handleWindowError(event) {
        error = event.error;
        didSetError = true;

        if (error === null && event.colno === 0 && event.lineno === 0) {
          isCrossOriginError = true;
        }

        if (event.defaultPrevented) {
          // Some other error handler has prevented default.
          // Browsers silence the error report if this happens.
          // We'll remember this to later decide whether to log it or not.
          if (error != null && typeof error === 'object') {
            try {
              error._suppressLogging = true;
            } catch (inner) {// Ignore.
            }
          }
        }
      } // Create a fake event type.


      var evtType = "react-" + (name ? name : 'invokeguardedcallback'); // Attach our event handlers

      window.addEventListener('error', handleWindowError);
      fakeNode.addEventListener(evtType, callCallback, false); // Synchronously dispatch our fake event. If the user-provided function
      // errors, it will trigger our global error handler.

      evt.initEvent(evtType, false, false);
      fakeNode.dispatchEvent(evt);

      if (windowEventDescriptor) {
        Object.defineProperty(window, 'event', windowEventDescriptor);
      }

      if (didCall && didError) {
        if (!didSetError) {
          // The callback errored, but the error event never fired.
          error = new Error('An error was thrown inside one of your components, but React ' + "doesn't know what it was. This is likely due to browser " + 'flakiness. React does its best to preserve the "Pause on ' + 'exceptions" behavior of the DevTools, which requires some ' + "DEV-mode only tricks. It's possible that these don't work in " + 'your browser. Try triggering the error in production mode, ' + 'or switching to a modern browser. If you suspect that this is ' + 'actually an issue with React, please file an issue.');
        } else if (isCrossOriginError) {
          error = new Error("A cross-origin error was thrown. React doesn't have access to " + 'the actual error object in development. ' + 'See https://reactjs.org/link/crossorigin-error for more information.');
        }

        this.onError(error);
      } // Remove our event listeners


      window.removeEventListener('error', handleWindowError);

      if (!didCall) {
        // Something went really wrong, and our event was not dispatched.
        // https://github.com/facebook/react/issues/16734
        // https://github.com/facebook/react/issues/16585
        // Fall back to the production implementation.
        restoreAfterDispatch();
        return invokeGuardedCallbackProd.apply(this, arguments);
      }
    };
  }
}

var invokeGuardedCallbackImpl$1 = invokeGuardedCallbackImpl;

var hasError = false;
var caughtError = null; // Used by event system to capture/rethrow the first error.

var hasRethrowError = false;
var rethrowError = null;
var reporter = {
  onError: function (error) {
    hasError = true;
    caughtError = error;
  }
};
/**
 * Call a function while guarding against errors that happens within it.
 * Returns an error if it throws, otherwise null.
 *
 * In production, this is implemented using a try-catch. The reason we don't
 * use a try-catch directly is so that we can swap out a different
 * implementation in DEV mode.
 *
 * @param {String} name of the guard to use for logging or debugging
 * @param {Function} func The function to invoke
 * @param {*} context The context to use when calling the function
 * @param {...*} args Arguments for function
 */

function invokeGuardedCallback(name, func, context, a, b, c, d, e, f) {
  hasError = false;
  caughtError = null;
  invokeGuardedCallbackImpl$1.apply(reporter, arguments);
}
/**
 * Same as invokeGuardedCallback, but instead of returning an error, it stores
 * it in a global so it can be rethrown by `rethrowCaughtError` later.
 * TODO: See if caughtError and rethrowError can be unified.
 *
 * @param {String} name of the guard to use for logging or debugging
 * @param {Function} func The function to invoke
 * @param {*} context The context to use when calling the function
 * @param {...*} args Arguments for function
 */

function invokeGuardedCallbackAndCatchFirstError(name, func, context, a, b, c, d, e, f) {
  invokeGuardedCallback.apply(this, arguments);

  if (hasError) {
    var error = clearCaughtError();

    if (!hasRethrowError) {
      hasRethrowError = true;
      rethrowError = error;
    }
  }
}
/**
 * During execution of guarded functions we will capture the first error which
 * we will rethrow to be handled by the top level error handler.
 */

function rethrowCaughtError() {
  if (hasRethrowError) {
    var error = rethrowError;
    hasRethrowError = false;
    rethrowError = null;
    throw error;
  }
}
function hasCaughtError() {
  return hasError;
}
function clearCaughtError() {
  if (hasError) {
    var error = caughtError;
    hasError = false;
    caughtError = null;
    return error;
  } else {
    {
      {
        throw Error( "clearCaughtError was called but no error was captured. This error is likely caused by a bug in React. Please file an issue." );
      }
    }
  }
}

/**
 * `ReactInstanceMap` maintains a mapping from a public facing stateful
 * instance (key) and the internal representation (value). This allows public
 * methods to accept the user facing instance as an argument and map them back
 * to internal methods.
 *
 * Note that this module is currently shared and assumed to be stateless.
 * If this becomes an actual Map, that will break.
 */
function get(key) {
  return key._reactInternals;
}
function has(key) {
  return key._reactInternals !== undefined;
}
function set(key, value) {
  key._reactInternals = value;
}

// Don't change these two values. They're used by React Dev Tools.
var NoFlags =
/*                      */
0;
var PerformedWork =
/*                */
1; // You can change the rest (and add more).

var Placement =
/*                    */
2;
var Update =
/*                       */
4;
var PlacementAndUpdate =
/*           */
6;
var Deletion =
/*                     */
8;
var ContentReset =
/*                 */
16;
var Callback =
/*                     */
32;
var DidCapture =
/*                   */
64;
var Ref =
/*                          */
128;
var Snapshot =
/*                     */
256;
var Passive =
/*                      */
512; // TODO (effects) Remove this bit once the new reconciler is synced to the old.

var PassiveUnmountPendingDev =
/*     */
8192;
var Hydrating =
/*                    */
1024;
var HydratingAndUpdate =
/*           */
1028; // Passive & Update & Callback & Ref & Snapshot

var LifecycleEffectMask =
/*          */
932; // Union of all host effects

var HostEffectMask =
/*               */
2047; // These are not really side effects, but we still reuse this field.

var Incomplete =
/*                   */
2048;
var ShouldCapture =
/*                */
4096;
var ForceUpdateForLegacySuspense =
/* */
16384; // Static tags describe aspects of a fiber that are not specific to a render,

var ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;
function getNearestMountedFiber(fiber) {
  var node = fiber;
  var nearestMounted = fiber;

  if (!fiber.alternate) {
    // If there is no alternate, this might be a new tree that isn't inserted
    // yet. If it is, then it will have a pending insertion effect on it.
    var nextNode = node;

    do {
      node = nextNode;

      if ((node.flags & (Placement | Hydrating)) !== NoFlags) {
        // This is an insertion or in-progress hydration. The nearest possible
        // mounted fiber is the parent but we need to continue to figure out
        // if that one is still mounted.
        nearestMounted = node.return;
      }

      nextNode = node.return;
    } while (nextNode);
  } else {
    while (node.return) {
      node = node.return;
    }
  }

  if (node.tag === HostRoot) {
    // TODO: Check if this was a nested HostRoot when used with
    // renderContainerIntoSubtree.
    return nearestMounted;
  } // If we didn't hit the root, that means that we're in an disconnected tree
  // that has been unmounted.


  return null;
}
function getSuspenseInstanceFromFiber(fiber) {
  if (fiber.tag === SuspenseComponent) {
    var suspenseState = fiber.memoizedState;

    if (suspenseState === null) {
      var current = fiber.alternate;

      if (current !== null) {
        suspenseState = current.memoizedState;
      }
    }

    if (suspenseState !== null) {
      return suspenseState.dehydrated;
    }
  }

  return null;
}
function getContainerFromFiber(fiber) {
  return fiber.tag === HostRoot ? fiber.stateNode.containerInfo : null;
}
function isFiberMounted(fiber) {
  return getNearestMountedFiber(fiber) === fiber;
}
function isMounted(component) {
  {
    var owner = ReactCurrentOwner.current;

    if (owner !== null && owner.tag === ClassComponent) {
      var ownerFiber = owner;
      var instance = ownerFiber.stateNode;

      if (!instance._warnedAboutRefsInRender) {
        error('%s is accessing isMounted inside its render() function. ' + 'render() should be a pure function of props and state. It should ' + 'never access something that requires stale data from the previous ' + 'render, such as refs. Move this logic to componentDidMount and ' + 'componentDidUpdate instead.', getComponentName(ownerFiber.type) || 'A component');
      }

      instance._warnedAboutRefsInRender = true;
    }
  }

  var fiber = get(component);

  if (!fiber) {
    return false;
  }

  return getNearestMountedFiber(fiber) === fiber;
}

function assertIsMounted(fiber) {
  if (!(getNearestMountedFiber(fiber) === fiber)) {
    {
      throw Error( "Unable to find node on an unmounted component." );
    }
  }
}

function findCurrentFiberUsingSlowPath(fiber) {
  var alternate = fiber.alternate;

  if (!alternate) {
    // If there is no alternate, then we only need to check if it is mounted.
    var nearestMounted = getNearestMountedFiber(fiber);

    if (!(nearestMounted !== null)) {
      {
        throw Error( "Unable to find node on an unmounted component." );
      }
    }

    if (nearestMounted !== fiber) {
      return null;
    }

    return fiber;
  } // If we have two possible branches, we'll walk backwards up to the root
  // to see what path the root points to. On the way we may hit one of the
  // special cases and we'll deal with them.


  var a = fiber;
  var b = alternate;

  while (true) {
    var parentA = a.return;

    if (parentA === null) {
      // We're at the root.
      break;
    }

    var parentB = parentA.alternate;

    if (parentB === null) {
      // There is no alternate. This is an unusual case. Currently, it only
      // happens when a Suspense component is hidden. An extra fragment fiber
      // is inserted in between the Suspense fiber and its children. Skip
      // over this extra fragment fiber and proceed to the next parent.
      var nextParent = parentA.return;

      if (nextParent !== null) {
        a = b = nextParent;
        continue;
      } // If there's no parent, we're at the root.


      break;
    } // If both copies of the parent fiber point to the same child, we can
    // assume that the child is current. This happens when we bailout on low
    // priority: the bailed out fiber's child reuses the current child.


    if (parentA.child === parentB.child) {
      var child = parentA.child;

      while (child) {
        if (child === a) {
          // We've determined that A is the current branch.
          assertIsMounted(parentA);
          return fiber;
        }

        if (child === b) {
          // We've determined that B is the current branch.
          assertIsMounted(parentA);
          return alternate;
        }

        child = child.sibling;
      } // We should never have an alternate for any mounting node. So the only
      // way this could possibly happen is if this was unmounted, if at all.


      {
        {
          throw Error( "Unable to find node on an unmounted component." );
        }
      }
    }

    if (a.return !== b.return) {
      // The return pointer of A and the return pointer of B point to different
      // fibers. We assume that return pointers never criss-cross, so A must
      // belong to the child set of A.return, and B must belong to the child
      // set of B.return.
      a = parentA;
      b = parentB;
    } else {
      // The return pointers point to the same fiber. We'll have to use the
      // default, slow path: scan the child sets of each parent alternate to see
      // which child belongs to which set.
      //
      // Search parent A's child set
      var didFindChild = false;
      var _child = parentA.child;

      while (_child) {
        if (_child === a) {
          didFindChild = true;
          a = parentA;
          b = parentB;
          break;
        }

        if (_child === b) {
          didFindChild = true;
          b = parentA;
          a = parentB;
          break;
        }

        _child = _child.sibling;
      }

      if (!didFindChild) {
        // Search parent B's child set
        _child = parentB.child;

        while (_child) {
          if (_child === a) {
            didFindChild = true;
            a = parentB;
            b = parentA;
            break;
          }

          if (_child === b) {
            didFindChild = true;
            b = parentB;
            a = parentA;
            break;
          }

          _child = _child.sibling;
        }

        if (!didFindChild) {
          {
            throw Error( "Child was not found in either parent set. This indicates a bug in React related to the return pointer. Please file an issue." );
          }
        }
      }
    }

    if (!(a.alternate === b)) {
      {
        throw Error( "Return fibers should always be each others' alternates. This error is likely caused by a bug in React. Please file an issue." );
      }
    }
  } // If the root is not a host container, we're in a disconnected tree. I.e.
  // unmounted.


  if (!(a.tag === HostRoot)) {
    {
      throw Error( "Unable to find node on an unmounted component." );
    }
  }

  if (a.stateNode.current === a) {
    // We've determined that A is the current branch.
    return fiber;
  } // Otherwise B has to be current branch.


  return alternate;
}
function findCurrentHostFiber(parent) {
  var currentParent = findCurrentFiberUsingSlowPath(parent);

  if (!currentParent) {
    return null;
  } // Next we'll drill down this component to find the first HostComponent/Text.


  var node = currentParent;

  while (true) {
    if (node.tag === HostComponent || node.tag === HostText) {
      return node;
    } else if (node.child) {
      node.child.return = node;
      node = node.child;
      continue;
    }

    if (node === currentParent) {
      return null;
    }

    while (!node.sibling) {
      if (!node.return || node.return === currentParent) {
        return null;
      }

      node = node.return;
    }

    node.sibling.return = node.return;
    node = node.sibling;
  } // Flow needs the return null here, but ESLint complains about it.
  // eslint-disable-next-line no-unreachable


  return null;
}
function findCurrentHostFiberWithNoPortals(parent) {
  var currentParent = findCurrentFiberUsingSlowPath(parent);

  if (!currentParent) {
    return null;
  } // Next we'll drill down this component to find the first HostComponent/Text.


  var node = currentParent;

  while (true) {
    if (node.tag === HostComponent || node.tag === HostText || enableFundamentalAPI ) {
      return node;
    } else if (node.child && node.tag !== HostPortal) {
      node.child.return = node;
      node = node.child;
      continue;
    }

    if (node === currentParent) {
      return null;
    }

    while (!node.sibling) {
      if (!node.return || node.return === currentParent) {
        return null;
      }

      node = node.return;
    }

    node.sibling.return = node.return;
    node = node.sibling;
  } // Flow needs the return null here, but ESLint complains about it.
  // eslint-disable-next-line no-unreachable


  return null;
}
function doesFiberContain(parentFiber, childFiber) {
  var node = childFiber;
  var parentFiberAlternate = parentFiber.alternate;

  while (node !== null) {
    if (node === parentFiber || node === parentFiberAlternate) {
      return true;
    }

    node = node.return;
  }

  return false;
}

var attemptUserBlockingHydration;
function setAttemptUserBlockingHydration(fn) {
  attemptUserBlockingHydration = fn;
}
var attemptContinuousHydration;
function setAttemptContinuousHydration(fn) {
  attemptContinuousHydration = fn;
}
var attemptHydrationAtCurrentPriority;
function setAttemptHydrationAtCurrentPriority(fn) {
  attemptHydrationAtCurrentPriority = fn;
}
var attemptHydrationAtPriority;
function setAttemptHydrationAtPriority(fn) {
  attemptHydrationAtPriority = fn;
} // TODO: Upgrade this definition once we're on a newer version of Flow that
var hasScheduledReplayAttempt = false; // The queue of discrete events to be replayed.

var queuedDiscreteEvents = []; // Indicates if any continuous event targets are non-null for early bailout.
// if the last target was dehydrated.

var queuedFocus = null;
var queuedDrag = null;
var queuedMouse = null; // For pointer events there can be one latest event per pointerId.

var queuedPointers = new Map();
var queuedPointerCaptures = new Map(); // We could consider replaying selectionchange and touchmoves too.

var queuedExplicitHydrationTargets = [];
function hasQueuedDiscreteEvents() {
  return queuedDiscreteEvents.length > 0;
}
var discreteReplayableEvents = ['mousedown', 'mouseup', 'touchcancel', 'touchend', 'touchstart', 'auxclick', 'dblclick', 'pointercancel', 'pointerdown', 'pointerup', 'dragend', 'dragstart', 'drop', 'compositionend', 'compositionstart', 'keydown', 'keypress', 'keyup', 'input', 'textInput', // Intentionally camelCase
'copy', 'cut', 'paste', 'click', 'change', 'contextmenu', 'reset', 'submit'];
function isReplayableDiscreteEvent(eventType) {
  return discreteReplayableEvents.indexOf(eventType) > -1;
}

function createQueuedReplayableEvent(blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent) {
  return {
    blockedOn: blockedOn,
    domEventName: domEventName,
    eventSystemFlags: eventSystemFlags | IS_REPLAYED,
    nativeEvent: nativeEvent,
    targetContainers: [targetContainer]
  };
}

function queueDiscreteEvent(blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent) {
  var queuedEvent = createQueuedReplayableEvent(blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent);
  queuedDiscreteEvents.push(queuedEvent);
} // Resets the replaying for this type of continuous event to no event.

function clearIfContinuousEvent(domEventName, nativeEvent) {
  switch (domEventName) {
    case 'focusin':
    case 'focusout':
      queuedFocus = null;
      break;

    case 'dragenter':
    case 'dragleave':
      queuedDrag = null;
      break;

    case 'mouseover':
    case 'mouseout':
      queuedMouse = null;
      break;

    case 'pointerover':
    case 'pointerout':
      {
        var pointerId = nativeEvent.pointerId;
        queuedPointers.delete(pointerId);
        break;
      }

    case 'gotpointercapture':
    case 'lostpointercapture':
      {
        var _pointerId = nativeEvent.pointerId;
        queuedPointerCaptures.delete(_pointerId);
        break;
      }
  }
}

function accumulateOrCreateContinuousQueuedReplayableEvent(existingQueuedEvent, blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent) {
  if (existingQueuedEvent === null || existingQueuedEvent.nativeEvent !== nativeEvent) {
    var queuedEvent = createQueuedReplayableEvent(blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent);

    if (blockedOn !== null) {
      var _fiber2 = getInstanceFromNode(blockedOn);

      if (_fiber2 !== null) {
        // Attempt to increase the priority of this target.
        attemptContinuousHydration(_fiber2);
      }
    }

    return queuedEvent;
  } // If we have already queued this exact event, then it's because
  // the different event systems have different DOM event listeners.
  // We can accumulate the flags, and the targetContainers, and
  // store a single event to be replayed.


  existingQueuedEvent.eventSystemFlags |= eventSystemFlags;
  var targetContainers = existingQueuedEvent.targetContainers;

  if (targetContainer !== null && targetContainers.indexOf(targetContainer) === -1) {
    targetContainers.push(targetContainer);
  }

  return existingQueuedEvent;
}

function queueIfContinuousEvent(blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent) {
  // These set relatedTarget to null because the replayed event will be treated as if we
  // moved from outside the window (no target) onto the target once it hydrates.
  // Instead of mutating we could clone the event.
  switch (domEventName) {
    case 'focusin':
      {
        var focusEvent = nativeEvent;
        queuedFocus = accumulateOrCreateContinuousQueuedReplayableEvent(queuedFocus, blockedOn, domEventName, eventSystemFlags, targetContainer, focusEvent);
        return true;
      }

    case 'dragenter':
      {
        var dragEvent = nativeEvent;
        queuedDrag = accumulateOrCreateContinuousQueuedReplayableEvent(queuedDrag, blockedOn, domEventName, eventSystemFlags, targetContainer, dragEvent);
        return true;
      }

    case 'mouseover':
      {
        var mouseEvent = nativeEvent;
        queuedMouse = accumulateOrCreateContinuousQueuedReplayableEvent(queuedMouse, blockedOn, domEventName, eventSystemFlags, targetContainer, mouseEvent);
        return true;
      }

    case 'pointerover':
      {
        var pointerEvent = nativeEvent;
        var pointerId = pointerEvent.pointerId;
        queuedPointers.set(pointerId, accumulateOrCreateContinuousQueuedReplayableEvent(queuedPointers.get(pointerId) || null, blockedOn, domEventName, eventSystemFlags, targetContainer, pointerEvent));
        return true;
      }

    case 'gotpointercapture':
      {
        var _pointerEvent = nativeEvent;
        var _pointerId2 = _pointerEvent.pointerId;
        queuedPointerCaptures.set(_pointerId2, accumulateOrCreateContinuousQueuedReplayableEvent(queuedPointerCaptures.get(_pointerId2) || null, blockedOn, domEventName, eventSystemFlags, targetContainer, _pointerEvent));
        return true;
      }
  }

  return false;
} // Check if this target is unblocked. Returns true if it's unblocked.

function attemptExplicitHydrationTarget(queuedTarget) {
  // TODO: This function shares a lot of logic with attemptToDispatchEvent.
  // Try to unify them. It's a bit tricky since it would require two return
  // values.
  var targetInst = getClosestInstanceFromNode(queuedTarget.target);

  if (targetInst !== null) {
    var nearestMounted = getNearestMountedFiber(targetInst);

    if (nearestMounted !== null) {
      var tag = nearestMounted.tag;

      if (tag === SuspenseComponent) {
        var instance = getSuspenseInstanceFromFiber(nearestMounted);

        if (instance !== null) {
          // We're blocked on hydrating this boundary.
          // Increase its priority.
          queuedTarget.blockedOn = instance;
          attemptHydrationAtPriority(queuedTarget.lanePriority, function () {
            Scheduler.unstable_runWithPriority(queuedTarget.priority, function () {
              attemptHydrationAtCurrentPriority(nearestMounted);
            });
          });
          return;
        }
      } else if (tag === HostRoot) {
        var root = nearestMounted.stateNode;

        if (root.hydrate) {
          queuedTarget.blockedOn = getContainerFromFiber(nearestMounted); // We don't currently have a way to increase the priority of
          // a root other than sync.

          return;
        }
      }
    }
  }

  queuedTarget.blockedOn = null;
}

function attemptReplayContinuousQueuedEvent(queuedEvent) {
  if (queuedEvent.blockedOn !== null) {
    return false;
  }

  var targetContainers = queuedEvent.targetContainers;

  while (targetContainers.length > 0) {
    var targetContainer = targetContainers[0];
    var nextBlockedOn = attemptToDispatchEvent(queuedEvent.domEventName, queuedEvent.eventSystemFlags, targetContainer, queuedEvent.nativeEvent);

    if (nextBlockedOn !== null) {
      // We're still blocked. Try again later.
      var _fiber3 = getInstanceFromNode(nextBlockedOn);

      if (_fiber3 !== null) {
        attemptContinuousHydration(_fiber3);
      }

      queuedEvent.blockedOn = nextBlockedOn;
      return false;
    } // This target container was successfully dispatched. Try the next.


    targetContainers.shift();
  }

  return true;
}

function attemptReplayContinuousQueuedEventInMap(queuedEvent, key, map) {
  if (attemptReplayContinuousQueuedEvent(queuedEvent)) {
    map.delete(key);
  }
}

function replayUnblockedEvents() {
  hasScheduledReplayAttempt = false; // First replay discrete events.

  while (queuedDiscreteEvents.length > 0) {
    var nextDiscreteEvent = queuedDiscreteEvents[0];

    if (nextDiscreteEvent.blockedOn !== null) {
      // We're still blocked.
      // Increase the priority of this boundary to unblock
      // the next discrete event.
      var _fiber4 = getInstanceFromNode(nextDiscreteEvent.blockedOn);

      if (_fiber4 !== null) {
        attemptUserBlockingHydration(_fiber4);
      }

      break;
    }

    var targetContainers = nextDiscreteEvent.targetContainers;

    while (targetContainers.length > 0) {
      var targetContainer = targetContainers[0];
      var nextBlockedOn = attemptToDispatchEvent(nextDiscreteEvent.domEventName, nextDiscreteEvent.eventSystemFlags, targetContainer, nextDiscreteEvent.nativeEvent);

      if (nextBlockedOn !== null) {
        // We're still blocked. Try again later.
        nextDiscreteEvent.blockedOn = nextBlockedOn;
        break;
      } // This target container was successfully dispatched. Try the next.


      targetContainers.shift();
    }

    if (nextDiscreteEvent.blockedOn === null) {
      // We've successfully replayed the first event. Let's try the next one.
      queuedDiscreteEvents.shift();
    }
  } // Next replay any continuous events.


  if (queuedFocus !== null && attemptReplayContinuousQueuedEvent(queuedFocus)) {
    queuedFocus = null;
  }

  if (queuedDrag !== null && attemptReplayContinuousQueuedEvent(queuedDrag)) {
    queuedDrag = null;
  }

  if (queuedMouse !== null && attemptReplayContinuousQueuedEvent(queuedMouse)) {
    queuedMouse = null;
  }

  queuedPointers.forEach(attemptReplayContinuousQueuedEventInMap);
  queuedPointerCaptures.forEach(attemptReplayContinuousQueuedEventInMap);
}

function scheduleCallbackIfUnblocked(queuedEvent, unblocked) {
  if (queuedEvent.blockedOn === unblocked) {
    queuedEvent.blockedOn = null;

    if (!hasScheduledReplayAttempt) {
      hasScheduledReplayAttempt = true; // Schedule a callback to attempt replaying as many events as are
      // now unblocked. This first might not actually be unblocked yet.
      // We could check it early to avoid scheduling an unnecessary callback.

      Scheduler.unstable_scheduleCallback(Scheduler.unstable_NormalPriority, replayUnblockedEvents);
    }
  }
}

function retryIfBlockedOn(unblocked) {
  // Mark anything that was blocked on this as no longer blocked
  // and eligible for a replay.
  if (queuedDiscreteEvents.length > 0) {
    scheduleCallbackIfUnblocked(queuedDiscreteEvents[0], unblocked); // This is a exponential search for each boundary that commits. I think it's
    // worth it because we expect very few discrete events to queue up and once
    // we are actually fully unblocked it will be fast to replay them.

    for (var i = 1; i < queuedDiscreteEvents.length; i++) {
      var queuedEvent = queuedDiscreteEvents[i];

      if (queuedEvent.blockedOn === unblocked) {
        queuedEvent.blockedOn = null;
      }
    }
  }

  if (queuedFocus !== null) {
    scheduleCallbackIfUnblocked(queuedFocus, unblocked);
  }

  if (queuedDrag !== null) {
    scheduleCallbackIfUnblocked(queuedDrag, unblocked);
  }

  if (queuedMouse !== null) {
    scheduleCallbackIfUnblocked(queuedMouse, unblocked);
  }

  var unblock = function (queuedEvent) {
    return scheduleCallbackIfUnblocked(queuedEvent, unblocked);
  };

  queuedPointers.forEach(unblock);
  queuedPointerCaptures.forEach(unblock);

  for (var _i = 0; _i < queuedExplicitHydrationTargets.length; _i++) {
    var queuedTarget = queuedExplicitHydrationTargets[_i];

    if (queuedTarget.blockedOn === unblocked) {
      queuedTarget.blockedOn = null;
    }
  }

  while (queuedExplicitHydrationTargets.length > 0) {
    var nextExplicitTarget = queuedExplicitHydrationTargets[0];

    if (nextExplicitTarget.blockedOn !== null) {
      // We're still blocked.
      break;
    } else {
      attemptExplicitHydrationTarget(nextExplicitTarget);

      if (nextExplicitTarget.blockedOn === null) {
        // We're unblocked.
        queuedExplicitHydrationTargets.shift();
      }
    }
  }
}

var DiscreteEvent = 0;
var UserBlockingEvent = 1;
var ContinuousEvent = 2;

/**
 * Generate a mapping of standard vendor prefixes using the defined style property and event name.
 *
 * @param {string} styleProp
 * @param {string} eventName
 * @returns {object}
 */

function makePrefixMap(styleProp, eventName) {
  var prefixes = {};
  prefixes[styleProp.toLowerCase()] = eventName.toLowerCase();
  prefixes['Webkit' + styleProp] = 'webkit' + eventName;
  prefixes['Moz' + styleProp] = 'moz' + eventName;
  return prefixes;
}
/**
 * A list of event names to a configurable list of vendor prefixes.
 */


var vendorPrefixes = {
  animationend: makePrefixMap('Animation', 'AnimationEnd'),
  animationiteration: makePrefixMap('Animation', 'AnimationIteration'),
  animationstart: makePrefixMap('Animation', 'AnimationStart'),
  transitionend: makePrefixMap('Transition', 'TransitionEnd')
};
/**
 * Event names that have already been detected and prefixed (if applicable).
 */

var prefixedEventNames = {};
/**
 * Element to check for prefixes on.
 */

var style = {};
/**
 * Bootstrap if a DOM exists.
 */

if (canUseDOM) {
  style = document.createElement('div').style; // On some platforms, in particular some releases of Android 4.x,
  // the un-prefixed "animation" and "transition" properties are defined on the
  // style object but the events that fire will still be prefixed, so we need
  // to check if the un-prefixed events are usable, and if not remove them from the map.

  if (!('AnimationEvent' in window)) {
    delete vendorPrefixes.animationend.animation;
    delete vendorPrefixes.animationiteration.animation;
    delete vendorPrefixes.animationstart.animation;
  } // Same as above


  if (!('TransitionEvent' in window)) {
    delete vendorPrefixes.transitionend.transition;
  }
}
/**
 * Attempts to determine the correct vendor prefixed event name.
 *
 * @param {string} eventName
 * @returns {string}
 */


function getVendorPrefixedEventName(eventName) {
  if (prefixedEventNames[eventName]) {
    return prefixedEventNames[eventName];
  } else if (!vendorPrefixes[eventName]) {
    return eventName;
  }

  var prefixMap = vendorPrefixes[eventName];

  for (var styleProp in prefixMap) {
    if (prefixMap.hasOwnProperty(styleProp) && styleProp in style) {
      return prefixedEventNames[eventName] = prefixMap[styleProp];
    }
  }

  return eventName;
}

var ANIMATION_END = getVendorPrefixedEventName('animationend');
var ANIMATION_ITERATION = getVendorPrefixedEventName('animationiteration');
var ANIMATION_START = getVendorPrefixedEventName('animationstart');
var TRANSITION_END = getVendorPrefixedEventName('transitionend');

var topLevelEventsToReactNames = new Map();
var eventPriorities = new Map(); // We store most of the events in this module in pairs of two strings so we can re-use
// the code required to apply the same logic for event prioritization and that of the
// SimpleEventPlugin. This complicates things slightly, but the aim is to reduce code
// duplication (for which there would be quite a bit). For the events that are not needed
// for the SimpleEventPlugin (otherDiscreteEvents) we process them separately as an
// array of top level events.
// Lastly, we ignore prettier so we can keep the formatting sane.
// prettier-ignore

var discreteEventPairsForSimpleEventPlugin = ['cancel', 'cancel', 'click', 'click', 'close', 'close', 'contextmenu', 'contextMenu', 'copy', 'copy', 'cut', 'cut', 'auxclick', 'auxClick', 'dblclick', 'doubleClick', // Careful!
'dragend', 'dragEnd', 'dragstart', 'dragStart', 'drop', 'drop', 'focusin', 'focus', // Careful!
'focusout', 'blur', // Careful!
'input', 'input', 'invalid', 'invalid', 'keydown', 'keyDown', 'keypress', 'keyPress', 'keyup', 'keyUp', 'mousedown', 'mouseDown', 'mouseup', 'mouseUp', 'paste', 'paste', 'pause', 'pause', 'play', 'play', 'pointercancel', 'pointerCancel', 'pointerdown', 'pointerDown', 'pointerup', 'pointerUp', 'ratechange', 'rateChange', 'reset', 'reset', 'seeked', 'seeked', 'submit', 'submit', 'touchcancel', 'touchCancel', 'touchend', 'touchEnd', 'touchstart', 'touchStart', 'volumechange', 'volumeChange'];
var otherDiscreteEvents = ['change', 'selectionchange', 'textInput', 'compositionstart', 'compositionend', 'compositionupdate'];


var userBlockingPairsForSimpleEventPlugin = ['drag', 'drag', 'dragenter', 'dragEnter', 'dragexit', 'dragExit', 'dragleave', 'dragLeave', 'dragover', 'dragOver', 'mousemove', 'mouseMove', 'mouseout', 'mouseOut', 'mouseover', 'mouseOver', 'pointermove', 'pointerMove', 'pointerout', 'pointerOut', 'pointerover', 'pointerOver', 'scroll', 'scroll', 'toggle', 'toggle', 'touchmove', 'touchMove', 'wheel', 'wheel']; // prettier-ignore

var continuousPairsForSimpleEventPlugin = ['abort', 'abort', ANIMATION_END, 'animationEnd', ANIMATION_ITERATION, 'animationIteration', ANIMATION_START, 'animationStart', 'canplay', 'canPlay', 'canplaythrough', 'canPlayThrough', 'durationchange', 'durationChange', 'emptied', 'emptied', 'encrypted', 'encrypted', 'ended', 'ended', 'error', 'error', 'gotpointercapture', 'gotPointerCapture', 'load', 'load', 'loadeddata', 'loadedData', 'loadedmetadata', 'loadedMetadata', 'loadstart', 'loadStart', 'lostpointercapture', 'lostPointerCapture', 'playing', 'playing', 'progress', 'progress', 'seeking', 'seeking', 'stalled', 'stalled', 'suspend', 'suspend', 'timeupdate', 'timeUpdate', TRANSITION_END, 'transitionEnd', 'waiting', 'waiting'];
/**
 * Turns
 * ['abort', ...]
 *
 * into
 *
 * topLevelEventsToReactNames = new Map([
 *   ['abort', 'onAbort'],
 * ]);
 *
 * and registers them.
 */

function registerSimplePluginEventsAndSetTheirPriorities(eventTypes, priority) {
  // As the event types are in pairs of two, we need to iterate
  // through in twos. The events are in pairs of two to save code
  // and improve init perf of processing this array, as it will
  // result in far fewer object allocations and property accesses
  // if we only use three arrays to process all the categories of
  // instead of tuples.
  for (var i = 0; i < eventTypes.length; i += 2) {
    var topEvent = eventTypes[i];
    var event = eventTypes[i + 1];
    var capitalizedEvent = event[0].toUpperCase() + event.slice(1);
    var reactName = 'on' + capitalizedEvent;
    eventPriorities.set(topEvent, priority);
    topLevelEventsToReactNames.set(topEvent, reactName);
    registerTwoPhaseEvent(reactName, [topEvent]);
  }
}

function setEventPriorities(eventTypes, priority) {
  for (var i = 0; i < eventTypes.length; i++) {
    eventPriorities.set(eventTypes[i], priority);
  }
}

function getEventPriorityForPluginSystem(domEventName) {
  var priority = eventPriorities.get(domEventName); // Default to a ContinuousEvent. Note: we might
  // want to warn if we can't detect the priority
  // for the event.

  return priority === undefined ? ContinuousEvent : priority;
}
function registerSimpleEvents() {
  registerSimplePluginEventsAndSetTheirPriorities(discreteEventPairsForSimpleEventPlugin, DiscreteEvent);
  registerSimplePluginEventsAndSetTheirPriorities(userBlockingPairsForSimpleEventPlugin, UserBlockingEvent);
  registerSimplePluginEventsAndSetTheirPriorities(continuousPairsForSimpleEventPlugin, ContinuousEvent);
  setEventPriorities(otherDiscreteEvents, DiscreteEvent);
}

var Scheduler_now = Scheduler.unstable_now;

{
  // Provide explicit error message when production+profiling bundle of e.g.
  // react-dom is used with production (non-profiling) bundle of
  // scheduler/tracing
  if (!(tracing.__interactionsRef != null && tracing.__interactionsRef.current != null)) {
    {
      throw Error( "It is not supported to run the profiling version of a renderer (for example, `react-dom/profiling`) without also replacing the `scheduler/tracing` module with `scheduler/tracing-profiling`. Your bundler might have a setting for aliasing both modules. Learn more at https://reactjs.org/link/profiling" );
    }
  }
}
// ascending numbers so we can compare them like numbers. They start at 90 to
// avoid clashing with Scheduler's priorities.

var ImmediatePriority = 99;
var UserBlockingPriority = 98;
var NormalPriority = 97;
var LowPriority = 96;
var IdlePriority = 95; // NoPriority is the absence of priority. Also React-only.

var NoPriority = 90;
var initialTimeMs = Scheduler_now(); // If the initial timestamp is reasonably small, use Scheduler's `now` directly.

var SyncLanePriority = 15;
var SyncBatchedLanePriority = 14;
var InputDiscreteHydrationLanePriority = 13;
var InputDiscreteLanePriority = 12;
var InputContinuousHydrationLanePriority = 11;
var InputContinuousLanePriority = 10;
var DefaultHydrationLanePriority = 9;
var DefaultLanePriority = 8;
var TransitionHydrationPriority = 7;
var TransitionPriority = 6;
var RetryLanePriority = 5;
var SelectiveHydrationLanePriority = 4;
var IdleHydrationLanePriority = 3;
var IdleLanePriority = 2;
var OffscreenLanePriority = 1;
var NoLanePriority = 0;
var TotalLanes = 31;
var NoLanes =
/*                        */
0;
var NoLane =
/*                          */
0;
var SyncLane =
/*                        */
1;
var SyncBatchedLane =
/*                 */
2;
var InputDiscreteHydrationLane =
/*      */
4;
var InputDiscreteLanes =
/*                    */
24;
var InputContinuousHydrationLane =
/*           */
32;
var InputContinuousLanes =
/*                  */
192;
var DefaultHydrationLane =
/*            */
256;
var DefaultLanes =
/*                   */
3584;
var TransitionHydrationLane =
/*                */
4096;
var TransitionLanes =
/*                       */
4186112;
var RetryLanes =
/*                            */
62914560;
var SomeRetryLane =
/*                  */
33554432;
var SelectiveHydrationLane =
/*          */
67108864;
var NonIdleLanes =
/*                                 */
134217727;
var IdleHydrationLane =
/*               */
134217728;
var IdleLanes =
/*                             */
805306368;
var OffscreenLane =
/*                   */
1073741824;
var NoTimestamp = -1;
function setCurrentUpdateLanePriority(newLanePriority) {
} // "Registers" used to "return" multiple values
// Used by getHighestPriorityLanes and getNextLanes:

var return_highestLanePriority = DefaultLanePriority;

function getHighestPriorityLanes(lanes) {
  if ((SyncLane & lanes) !== NoLanes) {
    return_highestLanePriority = SyncLanePriority;
    return SyncLane;
  }

  if ((SyncBatchedLane & lanes) !== NoLanes) {
    return_highestLanePriority = SyncBatchedLanePriority;
    return SyncBatchedLane;
  }

  if ((InputDiscreteHydrationLane & lanes) !== NoLanes) {
    return_highestLanePriority = InputDiscreteHydrationLanePriority;
    return InputDiscreteHydrationLane;
  }

  var inputDiscreteLanes = InputDiscreteLanes & lanes;

  if (inputDiscreteLanes !== NoLanes) {
    return_highestLanePriority = InputDiscreteLanePriority;
    return inputDiscreteLanes;
  }

  if ((lanes & InputContinuousHydrationLane) !== NoLanes) {
    return_highestLanePriority = InputContinuousHydrationLanePriority;
    return InputContinuousHydrationLane;
  }

  var inputContinuousLanes = InputContinuousLanes & lanes;

  if (inputContinuousLanes !== NoLanes) {
    return_highestLanePriority = InputContinuousLanePriority;
    return inputContinuousLanes;
  }

  if ((lanes & DefaultHydrationLane) !== NoLanes) {
    return_highestLanePriority = DefaultHydrationLanePriority;
    return DefaultHydrationLane;
  }

  var defaultLanes = DefaultLanes & lanes;

  if (defaultLanes !== NoLanes) {
    return_highestLanePriority = DefaultLanePriority;
    return defaultLanes;
  }

  if ((lanes & TransitionHydrationLane) !== NoLanes) {
    return_highestLanePriority = TransitionHydrationPriority;
    return TransitionHydrationLane;
  }

  var transitionLanes = TransitionLanes & lanes;

  if (transitionLanes !== NoLanes) {
    return_highestLanePriority = TransitionPriority;
    return transitionLanes;
  }

  var retryLanes = RetryLanes & lanes;

  if (retryLanes !== NoLanes) {
    return_highestLanePriority = RetryLanePriority;
    return retryLanes;
  }

  if (lanes & SelectiveHydrationLane) {
    return_highestLanePriority = SelectiveHydrationLanePriority;
    return SelectiveHydrationLane;
  }

  if ((lanes & IdleHydrationLane) !== NoLanes) {
    return_highestLanePriority = IdleHydrationLanePriority;
    return IdleHydrationLane;
  }

  var idleLanes = IdleLanes & lanes;

  if (idleLanes !== NoLanes) {
    return_highestLanePriority = IdleLanePriority;
    return idleLanes;
  }

  if ((OffscreenLane & lanes) !== NoLanes) {
    return_highestLanePriority = OffscreenLanePriority;
    return OffscreenLane;
  }

  {
    error('Should have found matching lanes. This is a bug in React.');
  } // This shouldn't be reachable, but as a fallback, return the entire bitmask.


  return_highestLanePriority = DefaultLanePriority;
  return lanes;
}

function schedulerPriorityToLanePriority(schedulerPriorityLevel) {
  switch (schedulerPriorityLevel) {
    case ImmediatePriority:
      return SyncLanePriority;

    case UserBlockingPriority:
      return InputContinuousLanePriority;

    case NormalPriority:
    case LowPriority:
      // TODO: Handle LowSchedulerPriority, somehow. Maybe the same lane as hydration.
      return DefaultLanePriority;

    case IdlePriority:
      return IdleLanePriority;

    default:
      return NoLanePriority;
  }
}
function lanePriorityToSchedulerPriority(lanePriority) {
  switch (lanePriority) {
    case SyncLanePriority:
    case SyncBatchedLanePriority:
      return ImmediatePriority;

    case InputDiscreteHydrationLanePriority:
    case InputDiscreteLanePriority:
    case InputContinuousHydrationLanePriority:
    case InputContinuousLanePriority:
      return UserBlockingPriority;

    case DefaultHydrationLanePriority:
    case DefaultLanePriority:
    case TransitionHydrationPriority:
    case TransitionPriority:
    case SelectiveHydrationLanePriority:
    case RetryLanePriority:
      return NormalPriority;

    case IdleHydrationLanePriority:
    case IdleLanePriority:
    case OffscreenLanePriority:
      return IdlePriority;

    case NoLanePriority:
      return NoPriority;

    default:
      {
        {
          throw Error( "Invalid update priority: " + lanePriority + ". This is a bug in React." );
        }
      }

  }
}
function getNextLanes(root, wipLanes) {
  // Early bailout if there's no pending work left.
  var pendingLanes = root.pendingLanes;

  if (pendingLanes === NoLanes) {
    return_highestLanePriority = NoLanePriority;
    return NoLanes;
  }

  var nextLanes = NoLanes;
  var nextLanePriority = NoLanePriority;
  var expiredLanes = root.expiredLanes;
  var suspendedLanes = root.suspendedLanes;
  var pingedLanes = root.pingedLanes; // Check if any work has expired.

  if (expiredLanes !== NoLanes) {
    nextLanes = expiredLanes;
    nextLanePriority = return_highestLanePriority = SyncLanePriority;
  } else {
    // Do not work on any idle work until all the non-idle work has finished,
    // even if the work is suspended.
    var nonIdlePendingLanes = pendingLanes & NonIdleLanes;

    if (nonIdlePendingLanes !== NoLanes) {
      var nonIdleUnblockedLanes = nonIdlePendingLanes & ~suspendedLanes;

      if (nonIdleUnblockedLanes !== NoLanes) {
        nextLanes = getHighestPriorityLanes(nonIdleUnblockedLanes);
        nextLanePriority = return_highestLanePriority;
      } else {
        var nonIdlePingedLanes = nonIdlePendingLanes & pingedLanes;

        if (nonIdlePingedLanes !== NoLanes) {
          nextLanes = getHighestPriorityLanes(nonIdlePingedLanes);
          nextLanePriority = return_highestLanePriority;
        }
      }
    } else {
      // The only remaining work is Idle.
      var unblockedLanes = pendingLanes & ~suspendedLanes;

      if (unblockedLanes !== NoLanes) {
        nextLanes = getHighestPriorityLanes(unblockedLanes);
        nextLanePriority = return_highestLanePriority;
      } else {
        if (pingedLanes !== NoLanes) {
          nextLanes = getHighestPriorityLanes(pingedLanes);
          nextLanePriority = return_highestLanePriority;
        }
      }
    }
  }

  if (nextLanes === NoLanes) {
    // This should only be reachable if we're suspended
    // TODO: Consider warning in this path if a fallback timer is not scheduled.
    return NoLanes;
  } // If there are higher priority lanes, we'll include them even if they
  // are suspended.


  nextLanes = pendingLanes & getEqualOrHigherPriorityLanes(nextLanes); // If we're already in the middle of a render, switching lanes will interrupt
  // it and we'll lose our progress. We should only do this if the new lanes are
  // higher priority.

  if (wipLanes !== NoLanes && wipLanes !== nextLanes && // If we already suspended with a delay, then interrupting is fine. Don't
  // bother waiting until the root is complete.
  (wipLanes & suspendedLanes) === NoLanes) {
    getHighestPriorityLanes(wipLanes);
    var wipLanePriority = return_highestLanePriority;

    if (nextLanePriority <= wipLanePriority) {
      return wipLanes;
    } else {
      return_highestLanePriority = nextLanePriority;
    }
  } // Check for entangled lanes and add them to the batch.
  //
  // A lane is said to be entangled with another when it's not allowed to render
  // in a batch that does not also include the other lane. Typically we do this
  // when multiple updates have the same source, and we only want to respond to
  // the most recent event from that source.
  //
  // Note that we apply entanglements *after* checking for partial work above.
  // This means that if a lane is entangled during an interleaved event while
  // it's already rendering, we won't interrupt it. This is intentional, since
  // entanglement is usually "best effort": we'll try our best to render the
  // lanes in the same batch, but it's not worth throwing out partially
  // completed work in order to do it.
  //
  // For those exceptions where entanglement is semantically important, like
  // useMutableSource, we should ensure that there is no partial work at the
  // time we apply the entanglement.


  var entangledLanes = root.entangledLanes;

  if (entangledLanes !== NoLanes) {
    var entanglements = root.entanglements;
    var lanes = nextLanes & entangledLanes;

    while (lanes > 0) {
      var index = pickArbitraryLaneIndex(lanes);
      var lane = 1 << index;
      nextLanes |= entanglements[index];
      lanes &= ~lane;
    }
  }

  return nextLanes;
}
function getMostRecentEventTime(root, lanes) {
  var eventTimes = root.eventTimes;
  var mostRecentEventTime = NoTimestamp;

  while (lanes > 0) {
    var index = pickArbitraryLaneIndex(lanes);
    var lane = 1 << index;
    var eventTime = eventTimes[index];

    if (eventTime > mostRecentEventTime) {
      mostRecentEventTime = eventTime;
    }

    lanes &= ~lane;
  }

  return mostRecentEventTime;
}

function computeExpirationTime(lane, currentTime) {
  // TODO: Expiration heuristic is constant per lane, so could use a map.
  getHighestPriorityLanes(lane);
  var priority = return_highestLanePriority;

  if (priority >= InputContinuousLanePriority) {
    // User interactions should expire slightly more quickly.
    //
    // NOTE: This is set to the corresponding constant as in Scheduler.js. When
    // we made it larger, a product metric in www regressed, suggesting there's
    // a user interaction that's being starved by a series of synchronous
    // updates. If that theory is correct, the proper solution is to fix the
    // starvation. However, this scenario supports the idea that expiration
    // times are an important safeguard when starvation does happen.
    //
    // Also note that, in the case of user input specifically, this will soon no
    // longer be an issue because we plan to make user input synchronous by
    // default (until you enter `startTransition`, of course.)
    //
    // If weren't planning to make these updates synchronous soon anyway, I
    // would probably make this number a configurable parameter.
    return currentTime + 250;
  } else if (priority >= TransitionPriority) {
    return currentTime + 5000;
  } else {
    // Anything idle priority or lower should never expire.
    return NoTimestamp;
  }
}

function markStarvedLanesAsExpired(root, currentTime) {
  // TODO: This gets called every time we yield. We can optimize by storing
  // the earliest expiration time on the root. Then use that to quickly bail out
  // of this function.
  var pendingLanes = root.pendingLanes;
  var suspendedLanes = root.suspendedLanes;
  var pingedLanes = root.pingedLanes;
  var expirationTimes = root.expirationTimes; // Iterate through the pending lanes and check if we've reached their
  // expiration time. If so, we'll assume the update is being starved and mark
  // it as expired to force it to finish.

  var lanes = pendingLanes;

  while (lanes > 0) {
    var index = pickArbitraryLaneIndex(lanes);
    var lane = 1 << index;
    var expirationTime = expirationTimes[index];

    if (expirationTime === NoTimestamp) {
      // Found a pending lane with no expiration time. If it's not suspended, or
      // if it's pinged, assume it's CPU-bound. Compute a new expiration time
      // using the current time.
      if ((lane & suspendedLanes) === NoLanes || (lane & pingedLanes) !== NoLanes) {
        // Assumes timestamps are monotonically increasing.
        expirationTimes[index] = computeExpirationTime(lane, currentTime);
      }
    } else if (expirationTime <= currentTime) {
      // This lane expired
      root.expiredLanes |= lane;
    }

    lanes &= ~lane;
  }
} // This returns the highest priority pending lanes regardless of whether they
function getLanesToRetrySynchronouslyOnError(root) {
  var everythingButOffscreen = root.pendingLanes & ~OffscreenLane;

  if (everythingButOffscreen !== NoLanes) {
    return everythingButOffscreen;
  }

  if (everythingButOffscreen & OffscreenLane) {
    return OffscreenLane;
  }

  return NoLanes;
}
function returnNextLanesPriority() {
  return return_highestLanePriority;
}
function includesNonIdleWork(lanes) {
  return (lanes & NonIdleLanes) !== NoLanes;
}
function includesOnlyRetries(lanes) {
  return (lanes & RetryLanes) === lanes;
}
function includesOnlyTransitions(lanes) {
  return (lanes & TransitionLanes) === lanes;
} // To ensure consistency across multiple updates in the same event, this should
// be a pure function, so that it always returns the same lane for given inputs.

function findUpdateLane(lanePriority, wipLanes) {
  switch (lanePriority) {
    case NoLanePriority:
      break;

    case SyncLanePriority:
      return SyncLane;

    case SyncBatchedLanePriority:
      return SyncBatchedLane;

    case InputDiscreteLanePriority:
      {
        var _lane = pickArbitraryLane(InputDiscreteLanes & ~wipLanes);

        if (_lane === NoLane) {
          // Shift to the next priority level
          return findUpdateLane(InputContinuousLanePriority, wipLanes);
        }

        return _lane;
      }

    case InputContinuousLanePriority:
      {
        var _lane2 = pickArbitraryLane(InputContinuousLanes & ~wipLanes);

        if (_lane2 === NoLane) {
          // Shift to the next priority level
          return findUpdateLane(DefaultLanePriority, wipLanes);
        }

        return _lane2;
      }

    case DefaultLanePriority:
      {
        var _lane3 = pickArbitraryLane(DefaultLanes & ~wipLanes);

        if (_lane3 === NoLane) {
          // If all the default lanes are already being worked on, look for a
          // lane in the transition range.
          _lane3 = pickArbitraryLane(TransitionLanes & ~wipLanes);

          if (_lane3 === NoLane) {
            // All the transition lanes are taken, too. This should be very
            // rare, but as a last resort, pick a default lane. This will have
            // the effect of interrupting the current work-in-progress render.
            _lane3 = pickArbitraryLane(DefaultLanes);
          }
        }

        return _lane3;
      }

    case TransitionPriority: // Should be handled by findTransitionLane instead

    case RetryLanePriority:
      // Should be handled by findRetryLane instead
      break;

    case IdleLanePriority:
      var lane = pickArbitraryLane(IdleLanes & ~wipLanes);

      if (lane === NoLane) {
        lane = pickArbitraryLane(IdleLanes);
      }

      return lane;
  }

  {
    {
      throw Error( "Invalid update priority: " + lanePriority + ". This is a bug in React." );
    }
  }
} // To ensure consistency across multiple updates in the same event, this should
// be pure function, so that it always returns the same lane for given inputs.

function findTransitionLane(wipLanes, pendingLanes) {
  // First look for lanes that are completely unclaimed, i.e. have no
  // pending work.
  var lane = pickArbitraryLane(TransitionLanes & ~pendingLanes);

  if (lane === NoLane) {
    // If all lanes have pending work, look for a lane that isn't currently
    // being worked on.
    lane = pickArbitraryLane(TransitionLanes & ~wipLanes);

    if (lane === NoLane) {
      // If everything is being worked on, pick any lane. This has the
      // effect of interrupting the current work-in-progress.
      lane = pickArbitraryLane(TransitionLanes);
    }
  }

  return lane;
} // To ensure consistency across multiple updates in the same event, this should
// be pure function, so that it always returns the same lane for given inputs.

function findRetryLane(wipLanes) {
  // This is a fork of `findUpdateLane` designed specifically for Suspense
  // "retries"  a special update that attempts to flip a Suspense boundary
  // from its placeholder state to its primary/resolved state.
  var lane = pickArbitraryLane(RetryLanes & ~wipLanes);

  if (lane === NoLane) {
    lane = pickArbitraryLane(RetryLanes);
  }

  return lane;
}

function getHighestPriorityLane(lanes) {
  return lanes & -lanes;
}

function getLowestPriorityLane(lanes) {
  // This finds the most significant non-zero bit.
  var index = 31 - clz32(lanes);
  return index < 0 ? NoLanes : 1 << index;
}

function getEqualOrHigherPriorityLanes(lanes) {
  return (getLowestPriorityLane(lanes) << 1) - 1;
}

function pickArbitraryLane(lanes) {
  // This wrapper function gets inlined. Only exists so to communicate that it
  // doesn't matter which bit is selected; you can pick any bit without
  // affecting the algorithms where its used. Here I'm using
  // getHighestPriorityLane because it requires the fewest operations.
  return getHighestPriorityLane(lanes);
}

function pickArbitraryLaneIndex(lanes) {
  return 31 - clz32(lanes);
}

function laneToIndex(lane) {
  return pickArbitraryLaneIndex(lane);
}

function includesSomeLane(a, b) {
  return (a & b) !== NoLanes;
}
function isSubsetOfLanes(set, subset) {
  return (set & subset) === subset;
}
function mergeLanes(a, b) {
  return a | b;
}
function removeLanes(set, subset) {
  return set & ~subset;
} // Seems redundant, but it changes the type from a single lane (used for
// updates) to a group of lanes (used for flushing work).

function laneToLanes(lane) {
  return lane;
}
function higherPriorityLane(a, b) {
  // This works because the bit ranges decrease in priority as you go left.
  return a !== NoLane && a < b ? a : b;
}
function createLaneMap(initial) {
  // Intentionally pushing one by one.
  // https://v8.dev/blog/elements-kinds#avoid-creating-holes
  var laneMap = [];

  for (var i = 0; i < TotalLanes; i++) {
    laneMap.push(initial);
  }

  return laneMap;
}
function markRootUpdated(root, updateLane, eventTime) {
  root.pendingLanes |= updateLane; // TODO: Theoretically, any update to any lane can unblock any other lane. But
  // it's not practical to try every single possible combination. We need a
  // heuristic to decide which lanes to attempt to render, and in which batches.
  // For now, we use the same heuristic as in the old ExpirationTimes model:
  // retry any lane at equal or lower priority, but don't try updates at higher
  // priority without also including the lower priority updates. This works well
  // when considering updates across different priority levels, but isn't
  // sufficient for updates within the same priority, since we want to treat
  // those updates as parallel.
  // Unsuspend any update at equal or lower priority.

  var higherPriorityLanes = updateLane - 1; // Turns 0b1000 into 0b0111

  root.suspendedLanes &= higherPriorityLanes;
  root.pingedLanes &= higherPriorityLanes;
  var eventTimes = root.eventTimes;
  var index = laneToIndex(updateLane); // We can always overwrite an existing timestamp because we prefer the most
  // recent event, and we assume time is monotonically increasing.

  eventTimes[index] = eventTime;
}
function markRootSuspended(root, suspendedLanes) {
  root.suspendedLanes |= suspendedLanes;
  root.pingedLanes &= ~suspendedLanes; // The suspended lanes are no longer CPU-bound. Clear their expiration times.

  var expirationTimes = root.expirationTimes;
  var lanes = suspendedLanes;

  while (lanes > 0) {
    var index = pickArbitraryLaneIndex(lanes);
    var lane = 1 << index;
    expirationTimes[index] = NoTimestamp;
    lanes &= ~lane;
  }
}
function markRootPinged(root, pingedLanes, eventTime) {
  root.pingedLanes |= root.suspendedLanes & pingedLanes;
}
function markDiscreteUpdatesExpired(root) {
  root.expiredLanes |= InputDiscreteLanes & root.pendingLanes;
}
function hasDiscreteLanes(lanes) {
  return (lanes & InputDiscreteLanes) !== NoLanes;
}
function markRootMutableRead(root, updateLane) {
  root.mutableReadLanes |= updateLane & root.pendingLanes;
}
function markRootFinished(root, remainingLanes) {
  var noLongerPendingLanes = root.pendingLanes & ~remainingLanes;
  root.pendingLanes = remainingLanes; // Let's try everything again

  root.suspendedLanes = 0;
  root.pingedLanes = 0;
  root.expiredLanes &= remainingLanes;
  root.mutableReadLanes &= remainingLanes;
  root.entangledLanes &= remainingLanes;
  var entanglements = root.entanglements;
  var eventTimes = root.eventTimes;
  var expirationTimes = root.expirationTimes; // Clear the lanes that no longer have pending work

  var lanes = noLongerPendingLanes;

  while (lanes > 0) {
    var index = pickArbitraryLaneIndex(lanes);
    var lane = 1 << index;
    entanglements[index] = NoLanes;
    eventTimes[index] = NoTimestamp;
    expirationTimes[index] = NoTimestamp;
    lanes &= ~lane;
  }
}
function markRootEntangled(root, entangledLanes) {
  root.entangledLanes |= entangledLanes;
  var entanglements = root.entanglements;
  var lanes = entangledLanes;

  while (lanes > 0) {
    var index = pickArbitraryLaneIndex(lanes);
    var lane = 1 << index;
    entanglements[index] |= entangledLanes;
    lanes &= ~lane;
  }
}
var clz32 = Math.clz32 ? Math.clz32 : clz32Fallback; // Count leading zeros. Only used on lanes, so assume input is an integer.
// Based on:
// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/clz32

var log = Math.log;
var LN2 = Math.LN2;

function clz32Fallback(lanes) {
  if (lanes === 0) {
    return 32;
  }

  return 31 - (log(lanes) / LN2 | 0) | 0;
}

// Intentionally not named imports because Rollup would use dynamic dispatch for
var UserBlockingPriority$1 = Scheduler.unstable_UserBlockingPriority,
    runWithPriority = Scheduler.unstable_runWithPriority; // TODO: can we stop exporting these?

var _enabled = true; // This is exported in FB builds for use by legacy FB layer infra.
// We'd like to remove this but it's not clear if this is safe.

function setEnabled(enabled) {
  _enabled = !!enabled;
}
function isEnabled() {
  return _enabled;
}
function createEventListenerWrapperWithPriority(targetContainer, domEventName, eventSystemFlags) {
  var eventPriority = getEventPriorityForPluginSystem(domEventName);
  var listenerWrapper;

  switch (eventPriority) {
    case DiscreteEvent:
      listenerWrapper = dispatchDiscreteEvent;
      break;

    case UserBlockingEvent:
      listenerWrapper = dispatchUserBlockingUpdate;
      break;

    case ContinuousEvent:
    default:
      listenerWrapper = dispatchEvent;
      break;
  }

  return listenerWrapper.bind(null, domEventName, eventSystemFlags, targetContainer);
}

function dispatchDiscreteEvent(domEventName, eventSystemFlags, container, nativeEvent) {
  {
    flushDiscreteUpdatesIfNeeded(nativeEvent.timeStamp);
  }

  discreteUpdates(dispatchEvent, domEventName, eventSystemFlags, container, nativeEvent);
}

function dispatchUserBlockingUpdate(domEventName, eventSystemFlags, container, nativeEvent) {
  {
    runWithPriority(UserBlockingPriority$1, dispatchEvent.bind(null, domEventName, eventSystemFlags, container, nativeEvent));
  }
}

function dispatchEvent(domEventName, eventSystemFlags, targetContainer, nativeEvent) {
  if (!_enabled) {
    return;
  }

  var allowReplay = true;

  {
    // TODO: replaying capture phase events is currently broken
    // because we used to do it during top-level native bubble handlers
    // but now we use different bubble and capture handlers.
    // In eager mode, we attach capture listeners early, so we need
    // to filter them out until we fix the logic to handle them correctly.
    // This could've been outside the flag but I put it inside to reduce risk.
    allowReplay = (eventSystemFlags & IS_CAPTURE_PHASE) === 0;
  }

  if (allowReplay && hasQueuedDiscreteEvents() && isReplayableDiscreteEvent(domEventName)) {
    // If we already have a queue of discrete events, and this is another discrete
    // event, then we can't dispatch it regardless of its target, since they
    // need to dispatch in order.
    queueDiscreteEvent(null, // Flags that we're not actually blocked on anything as far as we know.
    domEventName, eventSystemFlags, targetContainer, nativeEvent);
    return;
  }

  var blockedOn = attemptToDispatchEvent(domEventName, eventSystemFlags, targetContainer, nativeEvent);

  if (blockedOn === null) {
    // We successfully dispatched this event.
    if (allowReplay) {
      clearIfContinuousEvent(domEventName, nativeEvent);
    }

    return;
  }

  if (allowReplay) {
    if (isReplayableDiscreteEvent(domEventName)) {
      // This this to be replayed later once the target is available.
      queueDiscreteEvent(blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent);
      return;
    }

    if (queueIfContinuousEvent(blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent)) {
      return;
    } // We need to clear only if we didn't queue because
    // queueing is accummulative.


    clearIfContinuousEvent(domEventName, nativeEvent);
  } // This is not replayable so we'll invoke it but without a target,
  // in case the event system needs to trace it.


  dispatchEventForPluginEventSystem(domEventName, eventSystemFlags, nativeEvent, null, targetContainer);
} // Attempt dispatching an event. Returns a SuspenseInstance or Container if it's blocked.

function attemptToDispatchEvent(domEventName, eventSystemFlags, targetContainer, nativeEvent) {
  // TODO: Warn if _enabled is false.
  var nativeEventTarget = getEventTarget(nativeEvent);
  var targetInst = getClosestInstanceFromNode(nativeEventTarget);

  if (targetInst !== null) {
    var nearestMounted = getNearestMountedFiber(targetInst);

    if (nearestMounted === null) {
      // This tree has been unmounted already. Dispatch without a target.
      targetInst = null;
    } else {
      var tag = nearestMounted.tag;

      if (tag === SuspenseComponent) {
        var instance = getSuspenseInstanceFromFiber(nearestMounted);

        if (instance !== null) {
          // Queue the event to be replayed later. Abort dispatching since we
          // don't want this event dispatched twice through the event system.
          // TODO: If this is the first discrete event in the queue. Schedule an increased
          // priority for this boundary.
          return instance;
        } // This shouldn't happen, something went wrong but to avoid blocking
        // the whole system, dispatch the event without a target.
        // TODO: Warn.


        targetInst = null;
      } else if (tag === HostRoot) {
        var root = nearestMounted.stateNode;

        if (root.hydrate) {
          // If this happens during a replay something went wrong and it might block
          // the whole system.
          return getContainerFromFiber(nearestMounted);
        }

        targetInst = null;
      } else if (nearestMounted !== targetInst) {
        // If we get an event (ex: img onload) before committing that
        // component's mount, ignore it for now (that is, treat it as if it was an
        // event on a non-React tree). We might also consider queueing events and
        // dispatching them after the mount.
        targetInst = null;
      }
    }
  }

  dispatchEventForPluginEventSystem(domEventName, eventSystemFlags, nativeEvent, targetInst, targetContainer); // We're not blocked on anything.

  return null;
}

function addEventBubbleListener(target, eventType, listener) {
  target.addEventListener(eventType, listener, false);
  return listener;
}
function addEventCaptureListener(target, eventType, listener) {
  target.addEventListener(eventType, listener, true);
  return listener;
}
function addEventCaptureListenerWithPassiveFlag(target, eventType, listener, passive) {
  target.addEventListener(eventType, listener, {
    capture: true,
    passive: passive
  });
  return listener;
}
function addEventBubbleListenerWithPassiveFlag(target, eventType, listener, passive) {
  target.addEventListener(eventType, listener, {
    passive: passive
  });
  return listener;
}

/**
 * These variables store information about text content of a target node,
 * allowing comparison of content before and after a given event.
 *
 * Identify the node where selection currently begins, then observe
 * both its text content and its current position in the DOM. Since the
 * browser may natively replace the target node during composition, we can
 * use its position to find its replacement.
 *
 *
 */
var root = null;
var startText = null;
var fallbackText = null;
function initialize(nativeEventTarget) {
  root = nativeEventTarget;
  startText = getText();
  return true;
}
function reset() {
  root = null;
  startText = null;
  fallbackText = null;
}
function getData() {
  if (fallbackText) {
    return fallbackText;
  }

  var start;
  var startValue = startText;
  var startLength = startValue.length;
  var end;
  var endValue = getText();
  var endLength = endValue.length;

  for (start = 0; start < startLength; start++) {
    if (startValue[start] !== endValue[start]) {
      break;
    }
  }

  var minEnd = startLength - start;

  for (end = 1; end <= minEnd; end++) {
    if (startValue[startLength - end] !== endValue[endLength - end]) {
      break;
    }
  }

  var sliceTail = end > 1 ? 1 - end : undefined;
  fallbackText = endValue.slice(start, sliceTail);
  return fallbackText;
}
function getText() {
  if ('value' in root) {
    return root.value;
  }

  return root.textContent;
}

/**
 * `charCode` represents the actual "character code" and is safe to use with
 * `String.fromCharCode`. As such, only keys that correspond to printable
 * characters produce a valid `charCode`, the only exception to this is Enter.
 * The Tab-key is considered non-printable and does not have a `charCode`,
 * presumably because it does not produce a tab-character in browsers.
 *
 * @param {object} nativeEvent Native browser event.
 * @return {number} Normalized `charCode` property.
 */
function getEventCharCode(nativeEvent) {
  var charCode;
  var keyCode = nativeEvent.keyCode;

  if ('charCode' in nativeEvent) {
    charCode = nativeEvent.charCode; // FF does not set `charCode` for the Enter-key, check against `keyCode`.

    if (charCode === 0 && keyCode === 13) {
      charCode = 13;
    }
  } else {
    // IE8 does not implement `charCode`, but `keyCode` has the correct value.
    charCode = keyCode;
  } // IE and Edge (on Windows) and Chrome / Safari (on Windows and Linux)
  // report Enter as charCode 10 when ctrl is pressed.


  if (charCode === 10) {
    charCode = 13;
  } // Some non-printable keys are reported in `charCode`/`keyCode`, discard them.
  // Must not discard the (non-)printable Enter-key.


  if (charCode >= 32 || charCode === 13) {
    return charCode;
  }

  return 0;
}

function functionThatReturnsTrue() {
  return true;
}

function functionThatReturnsFalse() {
  return false;
} // This is intentionally a factory so that we have different returned constructors.
// If we had a single constructor, it would be megamorphic and engines would deopt.


function createSyntheticEvent(Interface) {
  /**
   * Synthetic events are dispatched by event plugins, typically in response to a
   * top-level event delegation handler.
   *
   * These systems should generally use pooling to reduce the frequency of garbage
   * collection. The system should check `isPersistent` to determine whether the
   * event should be released into the pool after being dispatched. Users that
   * need a persisted event should invoke `persist`.
   *
   * Synthetic events (and subclasses) implement the DOM Level 3 Events API by
   * normalizing browser quirks. Subclasses do not necessarily have to implement a
   * DOM interface; custom application-specific events can also subclass this.
   */
  function SyntheticBaseEvent(reactName, reactEventType, targetInst, nativeEvent, nativeEventTarget) {
    this._reactName = reactName;
    this._targetInst = targetInst;
    this.type = reactEventType;
    this.nativeEvent = nativeEvent;
    this.target = nativeEventTarget;
    this.currentTarget = null;

    for (var _propName in Interface) {
      if (!Interface.hasOwnProperty(_propName)) {
        continue;
      }

      var normalize = Interface[_propName];

      if (normalize) {
        this[_propName] = normalize(nativeEvent);
      } else {
        this[_propName] = nativeEvent[_propName];
      }
    }

    var defaultPrevented = nativeEvent.defaultPrevented != null ? nativeEvent.defaultPrevented : nativeEvent.returnValue === false;

    if (defaultPrevented) {
      this.isDefaultPrevented = functionThatReturnsTrue;
    } else {
      this.isDefaultPrevented = functionThatReturnsFalse;
    }

    this.isPropagationStopped = functionThatReturnsFalse;
    return this;
  }

  _assign(SyntheticBaseEvent.prototype, {
    preventDefault: function () {
      this.defaultPrevented = true;
      var event = this.nativeEvent;

      if (!event) {
        return;
      }

      if (event.preventDefault) {
        event.preventDefault(); // $FlowFixMe - flow is not aware of `unknown` in IE
      } else if (typeof event.returnValue !== 'unknown') {
        event.returnValue = false;
      }

      this.isDefaultPrevented = functionThatReturnsTrue;
    },
    stopPropagation: function () {
      var event = this.nativeEvent;

      if (!event) {
        return;
      }

      if (event.stopPropagation) {
        event.stopPropagation(); // $FlowFixMe - flow is not aware of `unknown` in IE
      } else if (typeof event.cancelBubble !== 'unknown') {
        // The ChangeEventPlugin registers a "propertychange" event for
        // IE. This event does not support bubbling or cancelling, and
        // any references to cancelBubble throw "Member not found".  A
        // typeof check of "unknown" circumvents this issue (and is also
        // IE specific).
        event.cancelBubble = true;
      }

      this.isPropagationStopped = functionThatReturnsTrue;
    },

    /**
     * We release all dispatched `SyntheticEvent`s after each event loop, adding
     * them back into the pool. This allows a way to hold onto a reference that
     * won't be added back into the pool.
     */
    persist: function () {// Modern event system doesn't use pooling.
    },

    /**
     * Checks if this event should be released back into the pool.
     *
     * @return {boolean} True if this should not be released, false otherwise.
     */
    isPersistent: functionThatReturnsTrue
  });

  return SyntheticBaseEvent;
}
/**
 * @interface Event
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */


var EventInterface = {
  eventPhase: 0,
  bubbles: 0,
  cancelable: 0,
  timeStamp: function (event) {
    return event.timeStamp || Date.now();
  },
  defaultPrevented: 0,
  isTrusted: 0
};
var SyntheticEvent = createSyntheticEvent(EventInterface);

var UIEventInterface = _assign({}, EventInterface, {
  view: 0,
  detail: 0
});

var SyntheticUIEvent = createSyntheticEvent(UIEventInterface);
var lastMovementX;
var lastMovementY;
var lastMouseEvent;

function updateMouseMovementPolyfillState(event) {
  if (event !== lastMouseEvent) {
    if (lastMouseEvent && event.type === 'mousemove') {
      lastMovementX = event.screenX - lastMouseEvent.screenX;
      lastMovementY = event.screenY - lastMouseEvent.screenY;
    } else {
      lastMovementX = 0;
      lastMovementY = 0;
    }

    lastMouseEvent = event;
  }
}
/**
 * @interface MouseEvent
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */


var MouseEventInterface = _assign({}, UIEventInterface, {
  screenX: 0,
  screenY: 0,
  clientX: 0,
  clientY: 0,
  pageX: 0,
  pageY: 0,
  ctrlKey: 0,
  shiftKey: 0,
  altKey: 0,
  metaKey: 0,
  getModifierState: getEventModifierState,
  button: 0,
  buttons: 0,
  relatedTarget: function (event) {
    if (event.relatedTarget === undefined) return event.fromElement === event.srcElement ? event.toElement : event.fromElement;
    return event.relatedTarget;
  },
  movementX: function (event) {
    if ('movementX' in event) {
      return event.movementX;
    }

    updateMouseMovementPolyfillState(event);
    return lastMovementX;
  },
  movementY: function (event) {
    if ('movementY' in event) {
      return event.movementY;
    } // Don't need to call updateMouseMovementPolyfillState() here
    // because it's guaranteed to have already run when movementX
    // was copied.


    return lastMovementY;
  }
});

var SyntheticMouseEvent = createSyntheticEvent(MouseEventInterface);
/**
 * @interface DragEvent
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */

var DragEventInterface = _assign({}, MouseEventInterface, {
  dataTransfer: 0
});

var SyntheticDragEvent = createSyntheticEvent(DragEventInterface);
/**
 * @interface FocusEvent
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */

var FocusEventInterface = _assign({}, UIEventInterface, {
  relatedTarget: 0
});

var SyntheticFocusEvent = createSyntheticEvent(FocusEventInterface);
/**
 * @interface Event
 * @see http://www.w3.org/TR/css3-animations/#AnimationEvent-interface
 * @see https://developer.mozilla.org/en-US/docs/Web/API/AnimationEvent
 */

var AnimationEventInterface = _assign({}, EventInterface, {
  animationName: 0,
  elapsedTime: 0,
  pseudoElement: 0
});

var SyntheticAnimationEvent = createSyntheticEvent(AnimationEventInterface);
/**
 * @interface Event
 * @see http://www.w3.org/TR/clipboard-apis/
 */

var ClipboardEventInterface = _assign({}, EventInterface, {
  clipboardData: function (event) {
    return 'clipboardData' in event ? event.clipboardData : window.clipboardData;
  }
});

var SyntheticClipboardEvent = createSyntheticEvent(ClipboardEventInterface);
/**
 * @interface Event
 * @see http://www.w3.org/TR/DOM-Level-3-Events/#events-compositionevents
 */

var CompositionEventInterface = _assign({}, EventInterface, {
  data: 0
});

var SyntheticCompositionEvent = createSyntheticEvent(CompositionEventInterface);
/**
 * @interface Event
 * @see http://www.w3.org/TR/2013/WD-DOM-Level-3-Events-20131105
 *      /#events-inputevents
 */
// Happens to share the same list for now.

var SyntheticInputEvent = SyntheticCompositionEvent;
/**
 * Normalization of deprecated HTML5 `key` values
 * @see https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent#Key_names
 */

var normalizeKey = {
  Esc: 'Escape',
  Spacebar: ' ',
  Left: 'ArrowLeft',
  Up: 'ArrowUp',
  Right: 'ArrowRight',
  Down: 'ArrowDown',
  Del: 'Delete',
  Win: 'OS',
  Menu: 'ContextMenu',
  Apps: 'ContextMenu',
  Scroll: 'ScrollLock',
  MozPrintableKey: 'Unidentified'
};
/**
 * Translation from legacy `keyCode` to HTML5 `key`
 * Only special keys supported, all others depend on keyboard layout or browser
 * @see https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent#Key_names
 */

var translateToKey = {
  '8': 'Backspace',
  '9': 'Tab',
  '12': 'Clear',
  '13': 'Enter',
  '16': 'Shift',
  '17': 'Control',
  '18': 'Alt',
  '19': 'Pause',
  '20': 'CapsLock',
  '27': 'Escape',
  '32': ' ',
  '33': 'PageUp',
  '34': 'PageDown',
  '35': 'End',
  '36': 'Home',
  '37': 'ArrowLeft',
  '38': 'ArrowUp',
  '39': 'ArrowRight',
  '40': 'ArrowDown',
  '45': 'Insert',
  '46': 'Delete',
  '112': 'F1',
  '113': 'F2',
  '114': 'F3',
  '115': 'F4',
  '116': 'F5',
  '117': 'F6',
  '118': 'F7',
  '119': 'F8',
  '120': 'F9',
  '121': 'F10',
  '122': 'F11',
  '123': 'F12',
  '144': 'NumLock',
  '145': 'ScrollLock',
  '224': 'Meta'
};
/**
 * @param {object} nativeEvent Native browser event.
 * @return {string} Normalized `key` property.
 */

function getEventKey(nativeEvent) {
  if (nativeEvent.key) {
    // Normalize inconsistent values reported by browsers due to
    // implementations of a working draft specification.
    // FireFox implements `key` but returns `MozPrintableKey` for all
    // printable characters (normalized to `Unidentified`), ignore it.
    var key = normalizeKey[nativeEvent.key] || nativeEvent.key;

    if (key !== 'Unidentified') {
      return key;
    }
  } // Browser does not implement `key`, polyfill as much of it as we can.


  if (nativeEvent.type === 'keypress') {
    var charCode = getEventCharCode(nativeEvent); // The enter-key is technically both printable and non-printable and can
    // thus be captured by `keypress`, no other non-printable key should.

    return charCode === 13 ? 'Enter' : String.fromCharCode(charCode);
  }

  if (nativeEvent.type === 'keydown' || nativeEvent.type === 'keyup') {
    // While user keyboard layout determines the actual meaning of each
    // `keyCode` value, almost all function keys have a universal value.
    return translateToKey[nativeEvent.keyCode] || 'Unidentified';
  }

  return '';
}
/**
 * Translation from modifier key to the associated property in the event.
 * @see http://www.w3.org/TR/DOM-Level-3-Events/#keys-Modifiers
 */


var modifierKeyToProp = {
  Alt: 'altKey',
  Control: 'ctrlKey',
  Meta: 'metaKey',
  Shift: 'shiftKey'
}; // Older browsers (Safari <= 10, iOS Safari <= 10.2) do not support
// getModifierState. If getModifierState is not supported, we map it to a set of
// modifier keys exposed by the event. In this case, Lock-keys are not supported.

function modifierStateGetter(keyArg) {
  var syntheticEvent = this;
  var nativeEvent = syntheticEvent.nativeEvent;

  if (nativeEvent.getModifierState) {
    return nativeEvent.getModifierState(keyArg);
  }

  var keyProp = modifierKeyToProp[keyArg];
  return keyProp ? !!nativeEvent[keyProp] : false;
}

function getEventModifierState(nativeEvent) {
  return modifierStateGetter;
}
/**
 * @interface KeyboardEvent
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */


var KeyboardEventInterface = _assign({}, UIEventInterface, {
  key: getEventKey,
  code: 0,
  location: 0,
  ctrlKey: 0,
  shiftKey: 0,
  altKey: 0,
  metaKey: 0,
  repeat: 0,
  locale: 0,
  getModifierState: getEventModifierState,
  // Legacy Interface
  charCode: function (event) {
    // `charCode` is the result of a KeyPress event and represents the value of
    // the actual printable character.
    // KeyPress is deprecated, but its replacement is not yet final and not
    // implemented in any major browser. Only KeyPress has charCode.
    if (event.type === 'keypress') {
      return getEventCharCode(event);
    }

    return 0;
  },
  keyCode: function (event) {
    // `keyCode` is the result of a KeyDown/Up event and represents the value of
    // physical keyboard key.
    // The actual meaning of the value depends on the users' keyboard layout
    // which cannot be detected. Assuming that it is a US keyboard layout
    // provides a surprisingly accurate mapping for US and European users.
    // Due to this, it is left to the user to implement at this time.
    if (event.type === 'keydown' || event.type === 'keyup') {
      return event.keyCode;
    }

    return 0;
  },
  which: function (event) {
    // `which` is an alias for either `keyCode` or `charCode` depending on the
    // type of the event.
    if (event.type === 'keypress') {
      return getEventCharCode(event);
    }

    if (event.type === 'keydown' || event.type === 'keyup') {
      return event.keyCode;
    }

    return 0;
  }
});

var SyntheticKeyboardEvent = createSyntheticEvent(KeyboardEventInterface);
/**
 * @interface PointerEvent
 * @see http://www.w3.org/TR/pointerevents/
 */

var PointerEventInterface = _assign({}, MouseEventInterface, {
  pointerId: 0,
  width: 0,
  height: 0,
  pressure: 0,
  tangentialPressure: 0,
  tiltX: 0,
  tiltY: 0,
  twist: 0,
  pointerType: 0,
  isPrimary: 0
});

var SyntheticPointerEvent = createSyntheticEvent(PointerEventInterface);
/**
 * @interface TouchEvent
 * @see http://www.w3.org/TR/touch-events/
 */

var TouchEventInterface = _assign({}, UIEventInterface, {
  touches: 0,
  targetTouches: 0,
  changedTouches: 0,
  altKey: 0,
  metaKey: 0,
  ctrlKey: 0,
  shiftKey: 0,
  getModifierState: getEventModifierState
});

var SyntheticTouchEvent = createSyntheticEvent(TouchEventInterface);
/**
 * @interface Event
 * @see http://www.w3.org/TR/2009/WD-css3-transitions-20090320/#transition-events-
 * @see https://developer.mozilla.org/en-US/docs/Web/API/TransitionEvent
 */

var TransitionEventInterface = _assign({}, EventInterface, {
  propertyName: 0,
  elapsedTime: 0,
  pseudoElement: 0
});

var SyntheticTransitionEvent = createSyntheticEvent(TransitionEventInterface);
/**
 * @interface WheelEvent
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */

var WheelEventInterface = _assign({}, MouseEventInterface, {
  deltaX: function (event) {
    return 'deltaX' in event ? event.deltaX : // Fallback to `wheelDeltaX` for Webkit and normalize (right is positive).
    'wheelDeltaX' in event ? -event.wheelDeltaX : 0;
  },
  deltaY: function (event) {
    return 'deltaY' in event ? event.deltaY : // Fallback to `wheelDeltaY` for Webkit and normalize (down is positive).
    'wheelDeltaY' in event ? -event.wheelDeltaY : // Fallback to `wheelDelta` for IE<9 and normalize (down is positive).
    'wheelDelta' in event ? -event.wheelDelta : 0;
  },
  deltaZ: 0,
  // Browsers without "deltaMode" is reporting in raw wheel delta where one
  // notch on the scroll is always +/- 120, roughly equivalent to pixels.
  // A good approximation of DOM_DELTA_LINE (1) is 5% of viewport size or
  // ~40 pixels, for DOM_DELTA_SCREEN (2) it is 87.5% of viewport size.
  deltaMode: 0
});

var SyntheticWheelEvent = createSyntheticEvent(WheelEventInterface);

var END_KEYCODES = [9, 13, 27, 32]; // Tab, Return, Esc, Space

var START_KEYCODE = 229;
var canUseCompositionEvent = canUseDOM && 'CompositionEvent' in window;
var documentMode = null;

if (canUseDOM && 'documentMode' in document) {
  documentMode = document.documentMode;
} // Webkit offers a very useful `textInput` event that can be used to
// directly represent `beforeInput`. The IE `textinput` event is not as
// useful, so we don't use it.


var canUseTextInputEvent = canUseDOM && 'TextEvent' in window && !documentMode; // In IE9+, we have access to composition events, but the data supplied
// by the native compositionend event may be incorrect. Japanese ideographic
// spaces, for instance (\u3000) are not recorded correctly.

var useFallbackCompositionData = canUseDOM && (!canUseCompositionEvent || documentMode && documentMode > 8 && documentMode <= 11);
var SPACEBAR_CODE = 32;
var SPACEBAR_CHAR = String.fromCharCode(SPACEBAR_CODE);

function registerEvents() {
  registerTwoPhaseEvent('onBeforeInput', ['compositionend', 'keypress', 'textInput', 'paste']);
  registerTwoPhaseEvent('onCompositionEnd', ['compositionend', 'focusout', 'keydown', 'keypress', 'keyup', 'mousedown']);
  registerTwoPhaseEvent('onCompositionStart', ['compositionstart', 'focusout', 'keydown', 'keypress', 'keyup', 'mousedown']);
  registerTwoPhaseEvent('onCompositionUpdate', ['compositionupdate', 'focusout', 'keydown', 'keypress', 'keyup', 'mousedown']);
} // Track whether we've ever handled a keypress on the space key.


var hasSpaceKeypress = false;
/**
 * Return whether a native keypress event is assumed to be a command.
 * This is required because Firefox fires `keypress` events for key commands
 * (cut, copy, select-all, etc.) even though no character is inserted.
 */

function isKeypressCommand(nativeEvent) {
  return (nativeEvent.ctrlKey || nativeEvent.altKey || nativeEvent.metaKey) && // ctrlKey && altKey is equivalent to AltGr, and is not a command.
  !(nativeEvent.ctrlKey && nativeEvent.altKey);
}
/**
 * Translate native top level events into event types.
 */


function getCompositionEventType(domEventName) {
  switch (domEventName) {
    case 'compositionstart':
      return 'onCompositionStart';

    case 'compositionend':
      return 'onCompositionEnd';

    case 'compositionupdate':
      return 'onCompositionUpdate';
  }
}
/**
 * Does our fallback best-guess model think this event signifies that
 * composition has begun?
 */


function isFallbackCompositionStart(domEventName, nativeEvent) {
  return domEventName === 'keydown' && nativeEvent.keyCode === START_KEYCODE;
}
/**
 * Does our fallback mode think that this event is the end of composition?
 */


function isFallbackCompositionEnd(domEventName, nativeEvent) {
  switch (domEventName) {
    case 'keyup':
      // Command keys insert or clear IME input.
      return END_KEYCODES.indexOf(nativeEvent.keyCode) !== -1;

    case 'keydown':
      // Expect IME keyCode on each keydown. If we get any other
      // code we must have exited earlier.
      return nativeEvent.keyCode !== START_KEYCODE;

    case 'keypress':
    case 'mousedown':
    case 'focusout':
      // Events are not possible without cancelling IME.
      return true;

    default:
      return false;
  }
}
/**
 * Google Input Tools provides composition data via a CustomEvent,
 * with the `data` property populated in the `detail` object. If this
 * is available on the event object, use it. If not, this is a plain
 * composition event and we have nothing special to extract.
 *
 * @param {object} nativeEvent
 * @return {?string}
 */


function getDataFromCustomEvent(nativeEvent) {
  var detail = nativeEvent.detail;

  if (typeof detail === 'object' && 'data' in detail) {
    return detail.data;
  }

  return null;
}
/**
 * Check if a composition event was triggered by Korean IME.
 * Our fallback mode does not work well with IE's Korean IME,
 * so just use native composition events when Korean IME is used.
 * Although CompositionEvent.locale property is deprecated,
 * it is available in IE, where our fallback mode is enabled.
 *
 * @param {object} nativeEvent
 * @return {boolean}
 */


function isUsingKoreanIME(nativeEvent) {
  return nativeEvent.locale === 'ko';
} // Track the current IME composition status, if any.


var isComposing = false;
/**
 * @return {?object} A SyntheticCompositionEvent.
 */

function extractCompositionEvent(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget) {
  var eventType;
  var fallbackData;

  if (canUseCompositionEvent) {
    eventType = getCompositionEventType(domEventName);
  } else if (!isComposing) {
    if (isFallbackCompositionStart(domEventName, nativeEvent)) {
      eventType = 'onCompositionStart';
    }
  } else if (isFallbackCompositionEnd(domEventName, nativeEvent)) {
    eventType = 'onCompositionEnd';
  }

  if (!eventType) {
    return null;
  }

  if (useFallbackCompositionData && !isUsingKoreanIME(nativeEvent)) {
    // The current composition is stored statically and must not be
    // overwritten while composition continues.
    if (!isComposing && eventType === 'onCompositionStart') {
      isComposing = initialize(nativeEventTarget);
    } else if (eventType === 'onCompositionEnd') {
      if (isComposing) {
        fallbackData = getData();
      }
    }
  }

  var listeners = accumulateTwoPhaseListeners(targetInst, eventType);

  if (listeners.length > 0) {
    var event = new SyntheticCompositionEvent(eventType, domEventName, null, nativeEvent, nativeEventTarget);
    dispatchQueue.push({
      event: event,
      listeners: listeners
    });

    if (fallbackData) {
      // Inject data generated from fallback path into the synthetic event.
      // This matches the property of native CompositionEventInterface.
      event.data = fallbackData;
    } else {
      var customData = getDataFromCustomEvent(nativeEvent);

      if (customData !== null) {
        event.data = customData;
      }
    }
  }
}

function getNativeBeforeInputChars(domEventName, nativeEvent) {
  switch (domEventName) {
    case 'compositionend':
      return getDataFromCustomEvent(nativeEvent);

    case 'keypress':
      /**
       * If native `textInput` events are available, our goal is to make
       * use of them. However, there is a special case: the spacebar key.
       * In Webkit, preventing default on a spacebar `textInput` event
       * cancels character insertion, but it *also* causes the browser
       * to fall back to its default spacebar behavior of scrolling the
       * page.
       *
       * Tracking at:
       * https://code.google.com/p/chromium/issues/detail?id=355103
       *
       * To avoid this issue, use the keypress event as if no `textInput`
       * event is available.
       */
      var which = nativeEvent.which;

      if (which !== SPACEBAR_CODE) {
        return null;
      }

      hasSpaceKeypress = true;
      return SPACEBAR_CHAR;

    case 'textInput':
      // Record the characters to be added to the DOM.
      var chars = nativeEvent.data; // If it's a spacebar character, assume that we have already handled
      // it at the keypress level and bail immediately. Android Chrome
      // doesn't give us keycodes, so we need to ignore it.

      if (chars === SPACEBAR_CHAR && hasSpaceKeypress) {
        return null;
      }

      return chars;

    default:
      // For other native event types, do nothing.
      return null;
  }
}
/**
 * For browsers that do not provide the `textInput` event, extract the
 * appropriate string to use for SyntheticInputEvent.
 */


function getFallbackBeforeInputChars(domEventName, nativeEvent) {
  // If we are currently composing (IME) and using a fallback to do so,
  // try to extract the composed characters from the fallback object.
  // If composition event is available, we extract a string only at
  // compositionevent, otherwise extract it at fallback events.
  if (isComposing) {
    if (domEventName === 'compositionend' || !canUseCompositionEvent && isFallbackCompositionEnd(domEventName, nativeEvent)) {
      var chars = getData();
      reset();
      isComposing = false;
      return chars;
    }

    return null;
  }

  switch (domEventName) {
    case 'paste':
      // If a paste event occurs after a keypress, throw out the input
      // chars. Paste events should not lead to BeforeInput events.
      return null;

    case 'keypress':
      /**
       * As of v27, Firefox may fire keypress events even when no character
       * will be inserted. A few possibilities:
       *
       * - `which` is `0`. Arrow keys, Esc key, etc.
       *
       * - `which` is the pressed key code, but no char is available.
       *   Ex: 'AltGr + d` in Polish. There is no modified character for
       *   this key combination and no character is inserted into the
       *   document, but FF fires the keypress for char code `100` anyway.
       *   No `input` event will occur.
       *
       * - `which` is the pressed key code, but a command combination is
       *   being used. Ex: `Cmd+C`. No character is inserted, and no
       *   `input` event will occur.
       */
      if (!isKeypressCommand(nativeEvent)) {
        // IE fires the `keypress` event when a user types an emoji via
        // Touch keyboard of Windows.  In such a case, the `char` property
        // holds an emoji character like `\uD83D\uDE0A`.  Because its length
        // is 2, the property `which` does not represent an emoji correctly.
        // In such a case, we directly return the `char` property instead of
        // using `which`.
        if (nativeEvent.char && nativeEvent.char.length > 1) {
          return nativeEvent.char;
        } else if (nativeEvent.which) {
          return String.fromCharCode(nativeEvent.which);
        }
      }

      return null;

    case 'compositionend':
      return useFallbackCompositionData && !isUsingKoreanIME(nativeEvent) ? null : nativeEvent.data;

    default:
      return null;
  }
}
/**
 * Extract a SyntheticInputEvent for `beforeInput`, based on either native
 * `textInput` or fallback behavior.
 *
 * @return {?object} A SyntheticInputEvent.
 */


function extractBeforeInputEvent(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget) {
  var chars;

  if (canUseTextInputEvent) {
    chars = getNativeBeforeInputChars(domEventName, nativeEvent);
  } else {
    chars = getFallbackBeforeInputChars(domEventName, nativeEvent);
  } // If no characters are being inserted, no BeforeInput event should
  // be fired.


  if (!chars) {
    return null;
  }

  var listeners = accumulateTwoPhaseListeners(targetInst, 'onBeforeInput');

  if (listeners.length > 0) {
    var event = new SyntheticInputEvent('onBeforeInput', 'beforeinput', null, nativeEvent, nativeEventTarget);
    dispatchQueue.push({
      event: event,
      listeners: listeners
    });
    event.data = chars;
  }
}
/**
 * Create an `onBeforeInput` event to match
 * http://www.w3.org/TR/2013/WD-DOM-Level-3-Events-20131105/#events-inputevents.
 *
 * This event plugin is based on the native `textInput` event
 * available in Chrome, Safari, Opera, and IE. This event fires after
 * `onKeyPress` and `onCompositionEnd`, but before `onInput`.
 *
 * `beforeInput` is spec'd but not implemented in any browsers, and
 * the `input` event does not provide any useful information about what has
 * actually been added, contrary to the spec. Thus, `textInput` is the best
 * available event to identify the characters that have actually been inserted
 * into the target node.
 *
 * This plugin is also responsible for emitting `composition` events, thus
 * allowing us to share composition fallback code for both `beforeInput` and
 * `composition` event types.
 */


function extractEvents(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags, targetContainer) {
  extractCompositionEvent(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget);
  extractBeforeInputEvent(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget);
}

/**
 * @see http://www.whatwg.org/specs/web-apps/current-work/multipage/the-input-element.html#input-type-attr-summary
 */
var supportedInputTypes = {
  color: true,
  date: true,
  datetime: true,
  'datetime-local': true,
  email: true,
  month: true,
  number: true,
  password: true,
  range: true,
  search: true,
  tel: true,
  text: true,
  time: true,
  url: true,
  week: true
};

function isTextInputElement(elem) {
  var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();

  if (nodeName === 'input') {
    return !!supportedInputTypes[elem.type];
  }

  if (nodeName === 'textarea') {
    return true;
  }

  return false;
}

/**
 * Checks if an event is supported in the current execution environment.
 *
 * NOTE: This will not work correctly for non-generic events such as `change`,
 * `reset`, `load`, `error`, and `select`.
 *
 * Borrows from Modernizr.
 *
 * @param {string} eventNameSuffix Event name, e.g. "click".
 * @return {boolean} True if the event is supported.
 * @internal
 * @license Modernizr 3.0.0pre (Custom Build) | MIT
 */

function isEventSupported(eventNameSuffix) {
  if (!canUseDOM) {
    return false;
  }

  var eventName = 'on' + eventNameSuffix;
  var isSupported = (eventName in document);

  if (!isSupported) {
    var element = document.createElement('div');
    element.setAttribute(eventName, 'return;');
    isSupported = typeof element[eventName] === 'function';
  }

  return isSupported;
}

function registerEvents$1() {
  registerTwoPhaseEvent('onChange', ['change', 'click', 'focusin', 'focusout', 'input', 'keydown', 'keyup', 'selectionchange']);
}

function createAndAccumulateChangeEvent(dispatchQueue, inst, nativeEvent, target) {
  // Flag this event loop as needing state restore.
  enqueueStateRestore(target);
  var listeners = accumulateTwoPhaseListeners(inst, 'onChange');

  if (listeners.length > 0) {
    var event = new SyntheticEvent('onChange', 'change', null, nativeEvent, target);
    dispatchQueue.push({
      event: event,
      listeners: listeners
    });
  }
}
/**
 * For IE shims
 */


var activeElement = null;
var activeElementInst = null;
/**
 * SECTION: handle `change` event
 */

function shouldUseChangeEvent(elem) {
  var nodeName = elem.nodeName && elem.nodeName.toLowerCase();
  return nodeName === 'select' || nodeName === 'input' && elem.type === 'file';
}

function manualDispatchChangeEvent(nativeEvent) {
  var dispatchQueue = [];
  createAndAccumulateChangeEvent(dispatchQueue, activeElementInst, nativeEvent, getEventTarget(nativeEvent)); // If change and propertychange bubbled, we'd just bind to it like all the
  // other events and have it go through ReactBrowserEventEmitter. Since it
  // doesn't, we manually listen for the events and so we have to enqueue and
  // process the abstract event manually.
  //
  // Batching is necessary here in order to ensure that all event handlers run
  // before the next rerender (including event handlers attached to ancestor
  // elements instead of directly on the input). Without this, controlled
  // components don't work properly in conjunction with event bubbling because
  // the component is rerendered and the value reverted before all the event
  // handlers can run. See https://github.com/facebook/react/issues/708.

  batchedUpdates(runEventInBatch, dispatchQueue);
}

function runEventInBatch(dispatchQueue) {
  processDispatchQueue(dispatchQueue, 0);
}

function getInstIfValueChanged(targetInst) {
  var targetNode = getNodeFromInstance(targetInst);

  if (updateValueIfChanged(targetNode)) {
    return targetInst;
  }
}

function getTargetInstForChangeEvent(domEventName, targetInst) {
  if (domEventName === 'change') {
    return targetInst;
  }
}
/**
 * SECTION: handle `input` event
 */


var isInputEventSupported = false;

if (canUseDOM) {
  // IE9 claims to support the input event but fails to trigger it when
  // deleting text, so we ignore its input events.
  isInputEventSupported = isEventSupported('input') && (!document.documentMode || document.documentMode > 9);
}
/**
 * (For IE <=9) Starts tracking propertychange events on the passed-in element
 * and override the value property so that we can distinguish user events from
 * value changes in JS.
 */


function startWatchingForValueChange(target, targetInst) {
  activeElement = target;
  activeElementInst = targetInst;
  activeElement.attachEvent('onpropertychange', handlePropertyChange);
}
/**
 * (For IE <=9) Removes the event listeners from the currently-tracked element,
 * if any exists.
 */


function stopWatchingForValueChange() {
  if (!activeElement) {
    return;
  }

  activeElement.detachEvent('onpropertychange', handlePropertyChange);
  activeElement = null;
  activeElementInst = null;
}
/**
 * (For IE <=9) Handles a propertychange event, sending a `change` event if
 * the value of the active element has changed.
 */


function handlePropertyChange(nativeEvent) {
  if (nativeEvent.propertyName !== 'value') {
    return;
  }

  if (getInstIfValueChanged(activeElementInst)) {
    manualDispatchChangeEvent(nativeEvent);
  }
}

function handleEventsForInputEventPolyfill(domEventName, target, targetInst) {
  if (domEventName === 'focusin') {
    // In IE9, propertychange fires for most input events but is buggy and
    // doesn't fire when text is deleted, but conveniently, selectionchange
    // appears to fire in all of the remaining cases so we catch those and
    // forward the event if the value has changed
    // In either case, we don't want to call the event handler if the value
    // is changed from JS so we redefine a setter for `.value` that updates
    // our activeElementValue variable, allowing us to ignore those changes
    //
    // stopWatching() should be a noop here but we call it just in case we
    // missed a blur event somehow.
    stopWatchingForValueChange();
    startWatchingForValueChange(target, targetInst);
  } else if (domEventName === 'focusout') {
    stopWatchingForValueChange();
  }
} // For IE8 and IE9.


function getTargetInstForInputEventPolyfill(domEventName, targetInst) {
  if (domEventName === 'selectionchange' || domEventName === 'keyup' || domEventName === 'keydown') {
    // On the selectionchange event, the target is just document which isn't
    // helpful for us so just check activeElement instead.
    //
    // 99% of the time, keydown and keyup aren't necessary. IE8 fails to fire
    // propertychange on the first input event after setting `value` from a
    // script and fires only keydown, keypress, keyup. Catching keyup usually
    // gets it and catching keydown lets us fire an event for the first
    // keystroke if user does a key repeat (it'll be a little delayed: right
    // before the second keystroke). Other input methods (e.g., paste) seem to
    // fire selectionchange normally.
    return getInstIfValueChanged(activeElementInst);
  }
}
/**
 * SECTION: handle `click` event
 */


function shouldUseClickEvent(elem) {
  // Use the `click` event to detect changes to checkbox and radio inputs.
  // This approach works across all browsers, whereas `change` does not fire
  // until `blur` in IE8.
  var nodeName = elem.nodeName;
  return nodeName && nodeName.toLowerCase() === 'input' && (elem.type === 'checkbox' || elem.type === 'radio');
}

function getTargetInstForClickEvent(domEventName, targetInst) {
  if (domEventName === 'click') {
    return getInstIfValueChanged(targetInst);
  }
}

function getTargetInstForInputOrChangeEvent(domEventName, targetInst) {
  if (domEventName === 'input' || domEventName === 'change') {
    return getInstIfValueChanged(targetInst);
  }
}

function handleControlledInputBlur(node) {
  var state = node._wrapperState;

  if (!state || !state.controlled || node.type !== 'number') {
    return;
  }

  {
    // If controlled, assign the value attribute to the current value on blur
    setDefaultValue(node, 'number', node.value);
  }
}
/**
 * This plugin creates an `onChange` event that normalizes change events
 * across form elements. This event fires at a time when it's possible to
 * change the element's value without seeing a flicker.
 *
 * Supported elements are:
 * - input (see `isTextInputElement`)
 * - textarea
 * - select
 */


function extractEvents$1(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags, targetContainer) {
  var targetNode = targetInst ? getNodeFromInstance(targetInst) : window;
  var getTargetInstFunc, handleEventFunc;

  if (shouldUseChangeEvent(targetNode)) {
    getTargetInstFunc = getTargetInstForChangeEvent;
  } else if (isTextInputElement(targetNode)) {
    if (isInputEventSupported) {
      getTargetInstFunc = getTargetInstForInputOrChangeEvent;
    } else {
      getTargetInstFunc = getTargetInstForInputEventPolyfill;
      handleEventFunc = handleEventsForInputEventPolyfill;
    }
  } else if (shouldUseClickEvent(targetNode)) {
    getTargetInstFunc = getTargetInstForClickEvent;
  }

  if (getTargetInstFunc) {
    var inst = getTargetInstFunc(domEventName, targetInst);

    if (inst) {
      createAndAccumulateChangeEvent(dispatchQueue, inst, nativeEvent, nativeEventTarget);
      return;
    }
  }

  if (handleEventFunc) {
    handleEventFunc(domEventName, targetNode, targetInst);
  } // When blurring, set the value attribute for number inputs


  if (domEventName === 'focusout') {
    handleControlledInputBlur(targetNode);
  }
}

function registerEvents$2() {
  registerDirectEvent('onMouseEnter', ['mouseout', 'mouseover']);
  registerDirectEvent('onMouseLeave', ['mouseout', 'mouseover']);
  registerDirectEvent('onPointerEnter', ['pointerout', 'pointerover']);
  registerDirectEvent('onPointerLeave', ['pointerout', 'pointerover']);
}
/**
 * For almost every interaction we care about, there will be both a top-level
 * `mouseover` and `mouseout` event that occurs. Only use `mouseout` so that
 * we do not extract duplicate events. However, moving the mouse into the
 * browser from outside will not fire a `mouseout` event. In this case, we use
 * the `mouseover` top-level event.
 */


function extractEvents$2(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags, targetContainer) {
  var isOverEvent = domEventName === 'mouseover' || domEventName === 'pointerover';
  var isOutEvent = domEventName === 'mouseout' || domEventName === 'pointerout';

  if (isOverEvent && (eventSystemFlags & IS_REPLAYED) === 0) {
    // If this is an over event with a target, we might have already dispatched
    // the event in the out event of the other target. If this is replayed,
    // then it's because we couldn't dispatch against this target previously
    // so we have to do it now instead.
    var related = nativeEvent.relatedTarget || nativeEvent.fromElement;

    if (related) {
      // If the related node is managed by React, we can assume that we have
      // already dispatched the corresponding events during its mouseout.
      if (getClosestInstanceFromNode(related) || isContainerMarkedAsRoot(related)) {
        return;
      }
    }
  }

  if (!isOutEvent && !isOverEvent) {
    // Must not be a mouse or pointer in or out - ignoring.
    return;
  }

  var win; // TODO: why is this nullable in the types but we read from it?

  if (nativeEventTarget.window === nativeEventTarget) {
    // `nativeEventTarget` is probably a window object.
    win = nativeEventTarget;
  } else {
    // TODO: Figure out why `ownerDocument` is sometimes undefined in IE8.
    var doc = nativeEventTarget.ownerDocument;

    if (doc) {
      win = doc.defaultView || doc.parentWindow;
    } else {
      win = window;
    }
  }

  var from;
  var to;

  if (isOutEvent) {
    var _related = nativeEvent.relatedTarget || nativeEvent.toElement;

    from = targetInst;
    to = _related ? getClosestInstanceFromNode(_related) : null;

    if (to !== null) {
      var nearestMounted = getNearestMountedFiber(to);

      if (to !== nearestMounted || to.tag !== HostComponent && to.tag !== HostText) {
        to = null;
      }
    }
  } else {
    // Moving to a node from outside the window.
    from = null;
    to = targetInst;
  }

  if (from === to) {
    // Nothing pertains to our managed components.
    return;
  }

  var SyntheticEventCtor = SyntheticMouseEvent;
  var leaveEventType = 'onMouseLeave';
  var enterEventType = 'onMouseEnter';
  var eventTypePrefix = 'mouse';

  if (domEventName === 'pointerout' || domEventName === 'pointerover') {
    SyntheticEventCtor = SyntheticPointerEvent;
    leaveEventType = 'onPointerLeave';
    enterEventType = 'onPointerEnter';
    eventTypePrefix = 'pointer';
  }

  var fromNode = from == null ? win : getNodeFromInstance(from);
  var toNode = to == null ? win : getNodeFromInstance(to);
  var leave = new SyntheticEventCtor(leaveEventType, eventTypePrefix + 'leave', from, nativeEvent, nativeEventTarget);
  leave.target = fromNode;
  leave.relatedTarget = toNode;
  var enter = null; // We should only process this nativeEvent if we are processing
  // the first ancestor. Next time, we will ignore the event.

  var nativeTargetInst = getClosestInstanceFromNode(nativeEventTarget);

  if (nativeTargetInst === targetInst) {
    var enterEvent = new SyntheticEventCtor(enterEventType, eventTypePrefix + 'enter', to, nativeEvent, nativeEventTarget);
    enterEvent.target = toNode;
    enterEvent.relatedTarget = fromNode;
    enter = enterEvent;
  }

  accumulateEnterLeaveTwoPhaseListeners(dispatchQueue, leave, enter, from, to);
}

/**
 * inlined Object.is polyfill to avoid requiring consumers ship their own
 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
 */
function is(x, y) {
  return x === y && (x !== 0 || 1 / x === 1 / y) || x !== x && y !== y // eslint-disable-line no-self-compare
  ;
}

var objectIs = typeof Object.is === 'function' ? Object.is : is;

var hasOwnProperty$2 = Object.prototype.hasOwnProperty;
/**
 * Performs equality by iterating through keys on an object and returning false
 * when any key has values which are not strictly equal between the arguments.
 * Returns true when the values of all keys are strictly equal.
 */

function shallowEqual(objA, objB) {
  if (objectIs(objA, objB)) {
    return true;
  }

  if (typeof objA !== 'object' || objA === null || typeof objB !== 'object' || objB === null) {
    return false;
  }

  var keysA = Object.keys(objA);
  var keysB = Object.keys(objB);

  if (keysA.length !== keysB.length) {
    return false;
  } // Test for A's keys different from B.


  for (var i = 0; i < keysA.length; i++) {
    if (!hasOwnProperty$2.call(objB, keysA[i]) || !objectIs(objA[keysA[i]], objB[keysA[i]])) {
      return false;
    }
  }

  return true;
}

/**
 * Given any node return the first leaf node without children.
 *
 * @param {DOMElement|DOMTextNode} node
 * @return {DOMElement|DOMTextNode}
 */

function getLeafNode(node) {
  while (node && node.firstChild) {
    node = node.firstChild;
  }

  return node;
}
/**
 * Get the next sibling within a container. This will walk up the
 * DOM if a node's siblings have been exhausted.
 *
 * @param {DOMElement|DOMTextNode} node
 * @return {?DOMElement|DOMTextNode}
 */


function getSiblingNode(node) {
  while (node) {
    if (node.nextSibling) {
      return node.nextSibling;
    }

    node = node.parentNode;
  }
}
/**
 * Get object describing the nodes which contain characters at offset.
 *
 * @param {DOMElement|DOMTextNode} root
 * @param {number} offset
 * @return {?object}
 */


function getNodeForCharacterOffset(root, offset) {
  var node = getLeafNode(root);
  var nodeStart = 0;
  var nodeEnd = 0;

  while (node) {
    if (node.nodeType === TEXT_NODE) {
      nodeEnd = nodeStart + node.textContent.length;

      if (nodeStart <= offset && nodeEnd >= offset) {
        return {
          node: node,
          offset: offset - nodeStart
        };
      }

      nodeStart = nodeEnd;
    }

    node = getLeafNode(getSiblingNode(node));
  }
}

/**
 * @param {DOMElement} outerNode
 * @return {?object}
 */

function getOffsets(outerNode) {
  var ownerDocument = outerNode.ownerDocument;
  var win = ownerDocument && ownerDocument.defaultView || window;
  var selection = win.getSelection && win.getSelection();

  if (!selection || selection.rangeCount === 0) {
    return null;
  }

  var anchorNode = selection.anchorNode,
      anchorOffset = selection.anchorOffset,
      focusNode = selection.focusNode,
      focusOffset = selection.focusOffset; // In Firefox, anchorNode and focusNode can be "anonymous divs", e.g. the
  // up/down buttons on an <input type="number">. Anonymous divs do not seem to
  // expose properties, triggering a "Permission denied error" if any of its
  // properties are accessed. The only seemingly possible way to avoid erroring
  // is to access a property that typically works for non-anonymous divs and
  // catch any error that may otherwise arise. See
  // https://bugzilla.mozilla.org/show_bug.cgi?id=208427

  try {
    /* eslint-disable no-unused-expressions */
    anchorNode.nodeType;
    focusNode.nodeType;
    /* eslint-enable no-unused-expressions */
  } catch (e) {
    return null;
  }

  return getModernOffsetsFromPoints(outerNode, anchorNode, anchorOffset, focusNode, focusOffset);
}
/**
 * Returns {start, end} where `start` is the character/codepoint index of
 * (anchorNode, anchorOffset) within the textContent of `outerNode`, and
 * `end` is the index of (focusNode, focusOffset).
 *
 * Returns null if you pass in garbage input but we should probably just crash.
 *
 * Exported only for testing.
 */

function getModernOffsetsFromPoints(outerNode, anchorNode, anchorOffset, focusNode, focusOffset) {
  var length = 0;
  var start = -1;
  var end = -1;
  var indexWithinAnchor = 0;
  var indexWithinFocus = 0;
  var node = outerNode;
  var parentNode = null;

  outer: while (true) {
    var next = null;

    while (true) {
      if (node === anchorNode && (anchorOffset === 0 || node.nodeType === TEXT_NODE)) {
        start = length + anchorOffset;
      }

      if (node === focusNode && (focusOffset === 0 || node.nodeType === TEXT_NODE)) {
        end = length + focusOffset;
      }

      if (node.nodeType === TEXT_NODE) {
        length += node.nodeValue.length;
      }

      if ((next = node.firstChild) === null) {
        break;
      } // Moving from `node` to its first child `next`.


      parentNode = node;
      node = next;
    }

    while (true) {
      if (node === outerNode) {
        // If `outerNode` has children, this is always the second time visiting
        // it. If it has no children, this is still the first loop, and the only
        // valid selection is anchorNode and focusNode both equal to this node
        // and both offsets 0, in which case we will have handled above.
        break outer;
      }

      if (parentNode === anchorNode && ++indexWithinAnchor === anchorOffset) {
        start = length;
      }

      if (parentNode === focusNode && ++indexWithinFocus === focusOffset) {
        end = length;
      }

      if ((next = node.nextSibling) !== null) {
        break;
      }

      node = parentNode;
      parentNode = node.parentNode;
    } // Moving from `node` to its next sibling `next`.


    node = next;
  }

  if (start === -1 || end === -1) {
    // This should never happen. (Would happen if the anchor/focus nodes aren't
    // actually inside the passed-in node.)
    return null;
  }

  return {
    start: start,
    end: end
  };
}
/**
 * In modern non-IE browsers, we can support both forward and backward
 * selections.
 *
 * Note: IE10+ supports the Selection object, but it does not support
 * the `extend` method, which means that even in modern IE, it's not possible
 * to programmatically create a backward selection. Thus, for all IE
 * versions, we use the old IE API to create our selections.
 *
 * @param {DOMElement|DOMTextNode} node
 * @param {object} offsets
 */

function setOffsets(node, offsets) {
  var doc = node.ownerDocument || document;
  var win = doc && doc.defaultView || window; // Edge fails with "Object expected" in some scenarios.
  // (For instance: TinyMCE editor used in a list component that supports pasting to add more,
  // fails when pasting 100+ items)

  if (!win.getSelection) {
    return;
  }

  var selection = win.getSelection();
  var length = node.textContent.length;
  var start = Math.min(offsets.start, length);
  var end = offsets.end === undefined ? start : Math.min(offsets.end, length); // IE 11 uses modern selection, but doesn't support the extend method.
  // Flip backward selections, so we can set with a single range.

  if (!selection.extend && start > end) {
    var temp = end;
    end = start;
    start = temp;
  }

  var startMarker = getNodeForCharacterOffset(node, start);
  var endMarker = getNodeForCharacterOffset(node, end);

  if (startMarker && endMarker) {
    if (selection.rangeCount === 1 && selection.anchorNode === startMarker.node && selection.anchorOffset === startMarker.offset && selection.focusNode === endMarker.node && selection.focusOffset === endMarker.offset) {
      return;
    }

    var range = doc.createRange();
    range.setStart(startMarker.node, startMarker.offset);
    selection.removeAllRanges();

    if (start > end) {
      selection.addRange(range);
      selection.extend(endMarker.node, endMarker.offset);
    } else {
      range.setEnd(endMarker.node, endMarker.offset);
      selection.addRange(range);
    }
  }
}

function isTextNode(node) {
  return node && node.nodeType === TEXT_NODE;
}

function containsNode(outerNode, innerNode) {
  if (!outerNode || !innerNode) {
    return false;
  } else if (outerNode === innerNode) {
    return true;
  } else if (isTextNode(outerNode)) {
    return false;
  } else if (isTextNode(innerNode)) {
    return containsNode(outerNode, innerNode.parentNode);
  } else if ('contains' in outerNode) {
    return outerNode.contains(innerNode);
  } else if (outerNode.compareDocumentPosition) {
    return !!(outerNode.compareDocumentPosition(innerNode) & 16);
  } else {
    return false;
  }
}

function isInDocument(node) {
  return node && node.ownerDocument && containsNode(node.ownerDocument.documentElement, node);
}

function isSameOriginFrame(iframe) {
  try {
    // Accessing the contentDocument of a HTMLIframeElement can cause the browser
    // to throw, e.g. if it has a cross-origin src attribute.
    // Safari will show an error in the console when the access results in "Blocked a frame with origin". e.g:
    // iframe.contentDocument.defaultView;
    // A safety way is to access one of the cross origin properties: Window or Location
    // Which might result in "SecurityError" DOM Exception and it is compatible to Safari.
    // https://html.spec.whatwg.org/multipage/browsers.html#integration-with-idl
    return typeof iframe.contentWindow.location.href === 'string';
  } catch (err) {
    return false;
  }
}

function getActiveElementDeep() {
  var win = window;
  var element = getActiveElement();

  while (element instanceof win.HTMLIFrameElement) {
    if (isSameOriginFrame(element)) {
      win = element.contentWindow;
    } else {
      return element;
    }

    element = getActiveElement(win.document);
  }

  return element;
}
/**
 * @ReactInputSelection: React input selection module. Based on Selection.js,
 * but modified to be suitable for react and has a couple of bug fixes (doesn't
 * assume buttons have range selections allowed).
 * Input selection module for React.
 */

/**
 * @hasSelectionCapabilities: we get the element types that support selection
 * from https://html.spec.whatwg.org/#do-not-apply, looking at `selectionStart`
 * and `selectionEnd` rows.
 */


function hasSelectionCapabilities(elem) {
  var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
  return nodeName && (nodeName === 'input' && (elem.type === 'text' || elem.type === 'search' || elem.type === 'tel' || elem.type === 'url' || elem.type === 'password') || nodeName === 'textarea' || elem.contentEditable === 'true');
}
function getSelectionInformation() {
  var focusedElem = getActiveElementDeep();
  return {
    focusedElem: focusedElem,
    selectionRange: hasSelectionCapabilities(focusedElem) ? getSelection(focusedElem) : null
  };
}
/**
 * @restoreSelection: If any selection information was potentially lost,
 * restore it. This is useful when performing operations that could remove dom
 * nodes and place them back in, resulting in focus being lost.
 */

function restoreSelection(priorSelectionInformation) {
  var curFocusedElem = getActiveElementDeep();
  var priorFocusedElem = priorSelectionInformation.focusedElem;
  var priorSelectionRange = priorSelectionInformation.selectionRange;

  if (curFocusedElem !== priorFocusedElem && isInDocument(priorFocusedElem)) {
    if (priorSelectionRange !== null && hasSelectionCapabilities(priorFocusedElem)) {
      setSelection(priorFocusedElem, priorSelectionRange);
    } // Focusing a node can change the scroll position, which is undesirable


    var ancestors = [];
    var ancestor = priorFocusedElem;

    while (ancestor = ancestor.parentNode) {
      if (ancestor.nodeType === ELEMENT_NODE) {
        ancestors.push({
          element: ancestor,
          left: ancestor.scrollLeft,
          top: ancestor.scrollTop
        });
      }
    }

    if (typeof priorFocusedElem.focus === 'function') {
      priorFocusedElem.focus();
    }

    for (var i = 0; i < ancestors.length; i++) {
      var info = ancestors[i];
      info.element.scrollLeft = info.left;
      info.element.scrollTop = info.top;
    }
  }
}
/**
 * @getSelection: Gets the selection bounds of a focused textarea, input or
 * contentEditable node.
 * -@input: Look up selection bounds of this input
 * -@return {start: selectionStart, end: selectionEnd}
 */

function getSelection(input) {
  var selection;

  if ('selectionStart' in input) {
    // Modern browser with input or textarea.
    selection = {
      start: input.selectionStart,
      end: input.selectionEnd
    };
  } else {
    // Content editable or old IE textarea.
    selection = getOffsets(input);
  }

  return selection || {
    start: 0,
    end: 0
  };
}
/**
 * @setSelection: Sets the selection bounds of a textarea or input and focuses
 * the input.
 * -@input     Set selection bounds of this input or textarea
 * -@offsets   Object of same form that is returned from get*
 */

function setSelection(input, offsets) {
  var start = offsets.start;
  var end = offsets.end;

  if (end === undefined) {
    end = start;
  }

  if ('selectionStart' in input) {
    input.selectionStart = start;
    input.selectionEnd = Math.min(end, input.value.length);
  } else {
    setOffsets(input, offsets);
  }
}

var skipSelectionChangeEvent = canUseDOM && 'documentMode' in document && document.documentMode <= 11;

function registerEvents$3() {
  registerTwoPhaseEvent('onSelect', ['focusout', 'contextmenu', 'dragend', 'focusin', 'keydown', 'keyup', 'mousedown', 'mouseup', 'selectionchange']);
}

var activeElement$1 = null;
var activeElementInst$1 = null;
var lastSelection = null;
var mouseDown = false;
/**
 * Get an object which is a unique representation of the current selection.
 *
 * The return value will not be consistent across nodes or browsers, but
 * two identical selections on the same node will return identical objects.
 */

function getSelection$1(node) {
  if ('selectionStart' in node && hasSelectionCapabilities(node)) {
    return {
      start: node.selectionStart,
      end: node.selectionEnd
    };
  } else {
    var win = node.ownerDocument && node.ownerDocument.defaultView || window;
    var selection = win.getSelection();
    return {
      anchorNode: selection.anchorNode,
      anchorOffset: selection.anchorOffset,
      focusNode: selection.focusNode,
      focusOffset: selection.focusOffset
    };
  }
}
/**
 * Get document associated with the event target.
 */


function getEventTargetDocument(eventTarget) {
  return eventTarget.window === eventTarget ? eventTarget.document : eventTarget.nodeType === DOCUMENT_NODE ? eventTarget : eventTarget.ownerDocument;
}
/**
 * Poll selection to see whether it's changed.
 *
 * @param {object} nativeEvent
 * @param {object} nativeEventTarget
 * @return {?SyntheticEvent}
 */


function constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget) {
  // Ensure we have the right element, and that the user is not dragging a
  // selection (this matches native `select` event behavior). In HTML5, select
  // fires only on input and textarea thus if there's no focused element we
  // won't dispatch.
  var doc = getEventTargetDocument(nativeEventTarget);

  if (mouseDown || activeElement$1 == null || activeElement$1 !== getActiveElement(doc)) {
    return;
  } // Only fire when selection has actually changed.


  var currentSelection = getSelection$1(activeElement$1);

  if (!lastSelection || !shallowEqual(lastSelection, currentSelection)) {
    lastSelection = currentSelection;
    var listeners = accumulateTwoPhaseListeners(activeElementInst$1, 'onSelect');

    if (listeners.length > 0) {
      var event = new SyntheticEvent('onSelect', 'select', null, nativeEvent, nativeEventTarget);
      dispatchQueue.push({
        event: event,
        listeners: listeners
      });
      event.target = activeElement$1;
    }
  }
}
/**
 * This plugin creates an `onSelect` event that normalizes select events
 * across form elements.
 *
 * Supported elements are:
 * - input (see `isTextInputElement`)
 * - textarea
 * - contentEditable
 *
 * This differs from native browser implementations in the following ways:
 * - Fires on contentEditable fields as well as inputs.
 * - Fires for collapsed selection.
 * - Fires after user input.
 */


function extractEvents$3(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags, targetContainer) {

  var targetNode = targetInst ? getNodeFromInstance(targetInst) : window;

  switch (domEventName) {
    // Track the input node that has focus.
    case 'focusin':
      if (isTextInputElement(targetNode) || targetNode.contentEditable === 'true') {
        activeElement$1 = targetNode;
        activeElementInst$1 = targetInst;
        lastSelection = null;
      }

      break;

    case 'focusout':
      activeElement$1 = null;
      activeElementInst$1 = null;
      lastSelection = null;
      break;
    // Don't fire the event while the user is dragging. This matches the
    // semantics of the native select event.

    case 'mousedown':
      mouseDown = true;
      break;

    case 'contextmenu':
    case 'mouseup':
    case 'dragend':
      mouseDown = false;
      constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget);
      break;
    // Chrome and IE fire non-standard event when selection is changed (and
    // sometimes when it hasn't). IE's event fires out of order with respect
    // to key and input events on deletion, so we discard it.
    //
    // Firefox doesn't support selectionchange, so check selection status
    // after each key entry. The selection changes after keydown and before
    // keyup, but we check on keydown as well in the case of holding down a
    // key, when multiple keydown events are fired but only one keyup is.
    // This is also our approach for IE handling, for the reason above.

    case 'selectionchange':
      if (skipSelectionChangeEvent) {
        break;
      }

    // falls through

    case 'keydown':
    case 'keyup':
      constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget);
  }
}

function extractEvents$4(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags, targetContainer) {
  var reactName = topLevelEventsToReactNames.get(domEventName);

  if (reactName === undefined) {
    return;
  }

  var SyntheticEventCtor = SyntheticEvent;
  var reactEventType = domEventName;

  switch (domEventName) {
    case 'keypress':
      // Firefox creates a keypress event for function keys too. This removes
      // the unwanted keypress events. Enter is however both printable and
      // non-printable. One would expect Tab to be as well (but it isn't).
      if (getEventCharCode(nativeEvent) === 0) {
        return;
      }

    /* falls through */

    case 'keydown':
    case 'keyup':
      SyntheticEventCtor = SyntheticKeyboardEvent;
      break;

    case 'focusin':
      reactEventType = 'focus';
      SyntheticEventCtor = SyntheticFocusEvent;
      break;

    case 'focusout':
      reactEventType = 'blur';
      SyntheticEventCtor = SyntheticFocusEvent;
      break;

    case 'beforeblur':
    case 'afterblur':
      SyntheticEventCtor = SyntheticFocusEvent;
      break;

    case 'click':
      // Firefox creates a click event on right mouse clicks. This removes the
      // unwanted click events.
      if (nativeEvent.button === 2) {
        return;
      }

    /* falls through */

    case 'auxclick':
    case 'dblclick':
    case 'mousedown':
    case 'mousemove':
    case 'mouseup': // TODO: Disabled elements should not respond to mouse events

    /* falls through */

    case 'mouseout':
    case 'mouseover':
    case 'contextmenu':
      SyntheticEventCtor = SyntheticMouseEvent;
      break;

    case 'drag':
    case 'dragend':
    case 'dragenter':
    case 'dragexit':
    case 'dragleave':
    case 'dragover':
    case 'dragstart':
    case 'drop':
      SyntheticEventCtor = SyntheticDragEvent;
      break;

    case 'touchcancel':
    case 'touchend':
    case 'touchmove':
    case 'touchstart':
      SyntheticEventCtor = SyntheticTouchEvent;
      break;

    case ANIMATION_END:
    case ANIMATION_ITERATION:
    case ANIMATION_START:
      SyntheticEventCtor = SyntheticAnimationEvent;
      break;

    case TRANSITION_END:
      SyntheticEventCtor = SyntheticTransitionEvent;
      break;

    case 'scroll':
      SyntheticEventCtor = SyntheticUIEvent;
      break;

    case 'wheel':
      SyntheticEventCtor = SyntheticWheelEvent;
      break;

    case 'copy':
    case 'cut':
    case 'paste':
      SyntheticEventCtor = SyntheticClipboardEvent;
      break;

    case 'gotpointercapture':
    case 'lostpointercapture':
    case 'pointercancel':
    case 'pointerdown':
    case 'pointermove':
    case 'pointerout':
    case 'pointerover':
    case 'pointerup':
      SyntheticEventCtor = SyntheticPointerEvent;
      break;
  }

  var inCapturePhase = (eventSystemFlags & IS_CAPTURE_PHASE) !== 0;

  {
    // Some events don't bubble in the browser.
    // In the past, React has always bubbled them, but this can be surprising.
    // We're going to try aligning closer to the browser behavior by not bubbling
    // them in React either. We'll start by not bubbling onScroll, and then expand.
    var accumulateTargetOnly = !inCapturePhase && // TODO: ideally, we'd eventually add all events from
    // nonDelegatedEvents list in DOMPluginEventSystem.
    // Then we can remove this special list.
    // This is a breaking change that can wait until React 18.
    domEventName === 'scroll';

    var _listeners = accumulateSinglePhaseListeners(targetInst, reactName, nativeEvent.type, inCapturePhase, accumulateTargetOnly);

    if (_listeners.length > 0) {
      // Intentionally create event lazily.
      var _event = new SyntheticEventCtor(reactName, reactEventType, null, nativeEvent, nativeEventTarget);

      dispatchQueue.push({
        event: _event,
        listeners: _listeners
      });
    }
  }
}

// TODO: remove top-level side effect.
registerSimpleEvents();
registerEvents$2();
registerEvents$1();
registerEvents$3();
registerEvents();

function extractEvents$5(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags, targetContainer) {
  // TODO: we should remove the concept of a "SimpleEventPlugin".
  // This is the basic functionality of the event system. All
  // the other plugins are essentially polyfills. So the plugin
  // should probably be inlined somewhere and have its logic
  // be core the to event system. This would potentially allow
  // us to ship builds of React without the polyfilled plugins below.
  extractEvents$4(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags);
  var shouldProcessPolyfillPlugins = (eventSystemFlags & SHOULD_NOT_PROCESS_POLYFILL_EVENT_PLUGINS) === 0; // We don't process these events unless we are in the
  // event's native "bubble" phase, which means that we're
  // not in the capture phase. That's because we emulate
  // the capture phase here still. This is a trade-off,
  // because in an ideal world we would not emulate and use
  // the phases properly, like we do with the SimpleEvent
  // plugin. However, the plugins below either expect
  // emulation (EnterLeave) or use state localized to that
  // plugin (BeforeInput, Change, Select). The state in
  // these modules complicates things, as you'll essentially
  // get the case where the capture phase event might change
  // state, only for the following bubble event to come in
  // later and not trigger anything as the state now
  // invalidates the heuristics of the event plugin. We
  // could alter all these plugins to work in such ways, but
  // that might cause other unknown side-effects that we
  // can't forsee right now.

  if (shouldProcessPolyfillPlugins) {
    extractEvents$2(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags);
    extractEvents$1(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget);
    extractEvents$3(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget);
    extractEvents(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget);
  }
} // List of events that need to be individually attached to media elements.


var mediaEventTypes = ['abort', 'canplay', 'canplaythrough', 'durationchange', 'emptied', 'encrypted', 'ended', 'error', 'loadeddata', 'loadedmetadata', 'loadstart', 'pause', 'play', 'playing', 'progress', 'ratechange', 'seeked', 'seeking', 'stalled', 'suspend', 'timeupdate', 'volumechange', 'waiting']; // We should not delegate these events to the container, but rather
// set them on the actual target element itself. This is primarily
// because these events do not consistently bubble in the DOM.

var nonDelegatedEvents = new Set(['cancel', 'close', 'invalid', 'load', 'scroll', 'toggle'].concat(mediaEventTypes));

function executeDispatch(event, listener, currentTarget) {
  var type = event.type || 'unknown-event';
  event.currentTarget = currentTarget;
  invokeGuardedCallbackAndCatchFirstError(type, listener, undefined, event);
  event.currentTarget = null;
}

function processDispatchQueueItemsInOrder(event, dispatchListeners, inCapturePhase) {
  var previousInstance;

  if (inCapturePhase) {
    for (var i = dispatchListeners.length - 1; i >= 0; i--) {
      var _dispatchListeners$i = dispatchListeners[i],
          instance = _dispatchListeners$i.instance,
          currentTarget = _dispatchListeners$i.currentTarget,
          listener = _dispatchListeners$i.listener;

      if (instance !== previousInstance && event.isPropagationStopped()) {
        return;
      }

      executeDispatch(event, listener, currentTarget);
      previousInstance = instance;
    }
  } else {
    for (var _i = 0; _i < dispatchListeners.length; _i++) {
      var _dispatchListeners$_i = dispatchListeners[_i],
          _instance = _dispatchListeners$_i.instance,
          _currentTarget = _dispatchListeners$_i.currentTarget,
          _listener = _dispatchListeners$_i.listener;

      if (_instance !== previousInstance && event.isPropagationStopped()) {
        return;
      }

      executeDispatch(event, _listener, _currentTarget);
      previousInstance = _instance;
    }
  }
}

function processDispatchQueue(dispatchQueue, eventSystemFlags) {
  var inCapturePhase = (eventSystemFlags & IS_CAPTURE_PHASE) !== 0;

  for (var i = 0; i < dispatchQueue.length; i++) {
    var _dispatchQueue$i = dispatchQueue[i],
        event = _dispatchQueue$i.event,
        listeners = _dispatchQueue$i.listeners;
    processDispatchQueueItemsInOrder(event, listeners, inCapturePhase); //  event system doesn't use pooling.
  } // This would be a good time to rethrow if any of the event handlers threw.


  rethrowCaughtError();
}

function dispatchEventsForPlugins(domEventName, eventSystemFlags, nativeEvent, targetInst, targetContainer) {
  var nativeEventTarget = getEventTarget(nativeEvent);
  var dispatchQueue = [];
  extractEvents$5(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags);
  processDispatchQueue(dispatchQueue, eventSystemFlags);
}

function listenToNonDelegatedEvent(domEventName, targetElement) {
  var isCapturePhaseListener = false;
  var listenerSet = getEventListenerSet(targetElement);
  var listenerSetKey = getListenerSetKey(domEventName, isCapturePhaseListener);

  if (!listenerSet.has(listenerSetKey)) {
    addTrappedEventListener(targetElement, domEventName, IS_NON_DELEGATED, isCapturePhaseListener);
    listenerSet.add(listenerSetKey);
  }
}
var listeningMarker = '_reactListening' + Math.random().toString(36).slice(2);
function listenToAllSupportedEvents(rootContainerElement) {
  {
    if (rootContainerElement[listeningMarker]) {
      // Performance optimization: don't iterate through events
      // for the same portal container or root node more than once.
      // TODO: once we remove the flag, we may be able to also
      // remove some of the bookkeeping maps used for laziness.
      return;
    }

    rootContainerElement[listeningMarker] = true;
    allNativeEvents.forEach(function (domEventName) {
      if (!nonDelegatedEvents.has(domEventName)) {
        listenToNativeEvent(domEventName, false, rootContainerElement, null);
      }

      listenToNativeEvent(domEventName, true, rootContainerElement, null);
    });
  }
}
function listenToNativeEvent(domEventName, isCapturePhaseListener, rootContainerElement, targetElement) {
  var eventSystemFlags = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;
  var target = rootContainerElement; // selectionchange needs to be attached to the document
  // otherwise it won't capture incoming events that are only
  // triggered on the document directly.

  if (domEventName === 'selectionchange' && rootContainerElement.nodeType !== DOCUMENT_NODE) {
    target = rootContainerElement.ownerDocument;
  } // If the event can be delegated (or is capture phase), we can
  // register it to the root container. Otherwise, we should
  // register the event to the target element and mark it as
  // a non-delegated event.


  if (targetElement !== null && !isCapturePhaseListener && nonDelegatedEvents.has(domEventName)) {
    // For all non-delegated events, apart from scroll, we attach
    // their event listeners to the respective elements that their
    // events fire on. That means we can skip this step, as event
    // listener has already been added previously. However, we
    // special case the scroll event because the reality is that any
    // element can scroll.
    // TODO: ideally, we'd eventually apply the same logic to all
    // events from the nonDelegatedEvents list. Then we can remove
    // this special case and use the same logic for all events.
    if (domEventName !== 'scroll') {
      return;
    }

    eventSystemFlags |= IS_NON_DELEGATED;
    target = targetElement;
  }

  var listenerSet = getEventListenerSet(target);
  var listenerSetKey = getListenerSetKey(domEventName, isCapturePhaseListener); // If the listener entry is empty or we should upgrade, then
  // we need to trap an event listener onto the target.

  if (!listenerSet.has(listenerSetKey)) {
    if (isCapturePhaseListener) {
      eventSystemFlags |= IS_CAPTURE_PHASE;
    }

    addTrappedEventListener(target, domEventName, eventSystemFlags, isCapturePhaseListener);
    listenerSet.add(listenerSetKey);
  }
}

function addTrappedEventListener(targetContainer, domEventName, eventSystemFlags, isCapturePhaseListener, isDeferredListenerForLegacyFBSupport) {
  var listener = createEventListenerWrapperWithPriority(targetContainer, domEventName, eventSystemFlags); // If passive option is not supported, then the event will be
  // active and not passive.

  var isPassiveListener = undefined;

  if (passiveBrowserEventsSupported) {
    // Browsers introduced an intervention, making these events
    // passive by default on document. React doesn't bind them
    // to document anymore, but changing this now would undo
    // the performance wins from the change. So we emulate
    // the existing behavior manually on the roots now.
    // https://github.com/facebook/react/issues/19651
    if (domEventName === 'touchstart' || domEventName === 'touchmove' || domEventName === 'wheel') {
      isPassiveListener = true;
    }
  }

  targetContainer =  targetContainer;
  var unsubscribeListener; // When legacyFBSupport is enabled, it's for when we


  if (isCapturePhaseListener) {
    if (isPassiveListener !== undefined) {
      unsubscribeListener = addEventCaptureListenerWithPassiveFlag(targetContainer, domEventName, listener, isPassiveListener);
    } else {
      unsubscribeListener = addEventCaptureListener(targetContainer, domEventName, listener);
    }
  } else {
    if (isPassiveListener !== undefined) {
      unsubscribeListener = addEventBubbleListenerWithPassiveFlag(targetContainer, domEventName, listener, isPassiveListener);
    } else {
      unsubscribeListener = addEventBubbleListener(targetContainer, domEventName, listener);
    }
  }
}

function isMatchingRootContainer(grandContainer, targetContainer) {
  return grandContainer === targetContainer || grandContainer.nodeType === COMMENT_NODE && grandContainer.parentNode === targetContainer;
}

function dispatchEventForPluginEventSystem(domEventName, eventSystemFlags, nativeEvent, targetInst, targetContainer) {
  var ancestorInst = targetInst;

  if ((eventSystemFlags & IS_EVENT_HANDLE_NON_MANAGED_NODE) === 0 && (eventSystemFlags & IS_NON_DELEGATED) === 0) {
    var targetContainerNode = targetContainer; // If we are using the legacy FB support flag, we

    if (targetInst !== null) {
      // The below logic attempts to work out if we need to change
      // the target fiber to a different ancestor. We had similar logic
      // in the legacy event system, except the big difference between
      // systems is that the modern event system now has an event listener
      // attached to each React Root and React Portal Root. Together,
      // the DOM nodes representing these roots are the "rootContainer".
      // To figure out which ancestor instance we should use, we traverse
      // up the fiber tree from the target instance and attempt to find
      // root boundaries that match that of our current "rootContainer".
      // If we find that "rootContainer", we find the parent fiber
      // sub-tree for that root and make that our ancestor instance.
      var node = targetInst;

      mainLoop: while (true) {
        if (node === null) {
          return;
        }

        var nodeTag = node.tag;

        if (nodeTag === HostRoot || nodeTag === HostPortal) {
          var container = node.stateNode.containerInfo;

          if (isMatchingRootContainer(container, targetContainerNode)) {
            break;
          }

          if (nodeTag === HostPortal) {
            // The target is a portal, but it's not the rootContainer we're looking for.
            // Normally portals handle their own events all the way down to the root.
            // So we should be able to stop now. However, we don't know if this portal
            // was part of *our* root.
            var grandNode = node.return;

            while (grandNode !== null) {
              var grandTag = grandNode.tag;

              if (grandTag === HostRoot || grandTag === HostPortal) {
                var grandContainer = grandNode.stateNode.containerInfo;

                if (isMatchingRootContainer(grandContainer, targetContainerNode)) {
                  // This is the rootContainer we're looking for and we found it as
                  // a parent of the Portal. That means we can ignore it because the
                  // Portal will bubble through to us.
                  return;
                }
              }

              grandNode = grandNode.return;
            }
          } // Now we need to find it's corresponding host fiber in the other
          // tree. To do this we can use getClosestInstanceFromNode, but we
          // need to validate that the fiber is a host instance, otherwise
          // we need to traverse up through the DOM till we find the correct
          // node that is from the other tree.


          while (container !== null) {
            var parentNode = getClosestInstanceFromNode(container);

            if (parentNode === null) {
              return;
            }

            var parentTag = parentNode.tag;

            if (parentTag === HostComponent || parentTag === HostText) {
              node = ancestorInst = parentNode;
              continue mainLoop;
            }

            container = container.parentNode;
          }
        }

        node = node.return;
      }
    }
  }

  batchedEventUpdates(function () {
    return dispatchEventsForPlugins(domEventName, eventSystemFlags, nativeEvent, ancestorInst);
  });
}

function createDispatchListener(instance, listener, currentTarget) {
  return {
    instance: instance,
    listener: listener,
    currentTarget: currentTarget
  };
}

function accumulateSinglePhaseListeners(targetFiber, reactName, nativeEventType, inCapturePhase, accumulateTargetOnly) {
  var captureName = reactName !== null ? reactName + 'Capture' : null;
  var reactEventName = inCapturePhase ? captureName : reactName;
  var listeners = [];
  var instance = targetFiber;
  var lastHostComponent = null; // Accumulate all instances and listeners via the target -> root path.

  while (instance !== null) {
    var _instance2 = instance,
        stateNode = _instance2.stateNode,
        tag = _instance2.tag; // Handle listeners that are on HostComponents (i.e. <div>)

    if (tag === HostComponent && stateNode !== null) {
      lastHostComponent = stateNode; // createEventHandle listeners


      if (reactEventName !== null) {
        var listener = getListener(instance, reactEventName);

        if (listener != null) {
          listeners.push(createDispatchListener(instance, listener, lastHostComponent));
        }
      }
    } // If we are only accumulating events for the target, then we don't
    // continue to propagate through the React fiber tree to find other
    // listeners.


    if (accumulateTargetOnly) {
      break;
    }

    instance = instance.return;
  }

  return listeners;
} // We should only use this function for:
// - BeforeInputEventPlugin
// - ChangeEventPlugin
// - SelectEventPlugin
// This is because we only process these plugins
// in the bubble phase, so we need to accumulate two
// phase event listeners (via emulation).

function accumulateTwoPhaseListeners(targetFiber, reactName) {
  var captureName = reactName + 'Capture';
  var listeners = [];
  var instance = targetFiber; // Accumulate all instances and listeners via the target -> root path.

  while (instance !== null) {
    var _instance3 = instance,
        stateNode = _instance3.stateNode,
        tag = _instance3.tag; // Handle listeners that are on HostComponents (i.e. <div>)

    if (tag === HostComponent && stateNode !== null) {
      var currentTarget = stateNode;
      var captureListener = getListener(instance, captureName);

      if (captureListener != null) {
        listeners.unshift(createDispatchListener(instance, captureListener, currentTarget));
      }

      var bubbleListener = getListener(instance, reactName);

      if (bubbleListener != null) {
        listeners.push(createDispatchListener(instance, bubbleListener, currentTarget));
      }
    }

    instance = instance.return;
  }

  return listeners;
}

function getParent(inst) {
  if (inst === null) {
    return null;
  }

  do {
    inst = inst.return; // TODO: If this is a HostRoot we might want to bail out.
    // That is depending on if we want nested subtrees (layers) to bubble
    // events to their parent. We could also go through parentNode on the
    // host node but that wouldn't work for React Native and doesn't let us
    // do the portal feature.
  } while (inst && inst.tag !== HostComponent);

  if (inst) {
    return inst;
  }

  return null;
}
/**
 * Return the lowest common ancestor of A and B, or null if they are in
 * different trees.
 */


function getLowestCommonAncestor(instA, instB) {
  var nodeA = instA;
  var nodeB = instB;
  var depthA = 0;

  for (var tempA = nodeA; tempA; tempA = getParent(tempA)) {
    depthA++;
  }

  var depthB = 0;

  for (var tempB = nodeB; tempB; tempB = getParent(tempB)) {
    depthB++;
  } // If A is deeper, crawl up.


  while (depthA - depthB > 0) {
    nodeA = getParent(nodeA);
    depthA--;
  } // If B is deeper, crawl up.


  while (depthB - depthA > 0) {
    nodeB = getParent(nodeB);
    depthB--;
  } // Walk in lockstep until we find a match.


  var depth = depthA;

  while (depth--) {
    if (nodeA === nodeB || nodeB !== null && nodeA === nodeB.alternate) {
      return nodeA;
    }

    nodeA = getParent(nodeA);
    nodeB = getParent(nodeB);
  }

  return null;
}

function accumulateEnterLeaveListenersForEvent(dispatchQueue, event, target, common, inCapturePhase) {
  var registrationName = event._reactName;
  var listeners = [];
  var instance = target;

  while (instance !== null) {
    if (instance === common) {
      break;
    }

    var _instance4 = instance,
        alternate = _instance4.alternate,
        stateNode = _instance4.stateNode,
        tag = _instance4.tag;

    if (alternate !== null && alternate === common) {
      break;
    }

    if (tag === HostComponent && stateNode !== null) {
      var currentTarget = stateNode;

      if (inCapturePhase) {
        var captureListener = getListener(instance, registrationName);

        if (captureListener != null) {
          listeners.unshift(createDispatchListener(instance, captureListener, currentTarget));
        }
      } else if (!inCapturePhase) {
        var bubbleListener = getListener(instance, registrationName);

        if (bubbleListener != null) {
          listeners.push(createDispatchListener(instance, bubbleListener, currentTarget));
        }
      }
    }

    instance = instance.return;
  }

  if (listeners.length !== 0) {
    dispatchQueue.push({
      event: event,
      listeners: listeners
    });
  }
} // We should only use this function for:
// - EnterLeaveEventPlugin
// This is because we only process this plugin
// in the bubble phase, so we need to accumulate two
// phase event listeners.


function accumulateEnterLeaveTwoPhaseListeners(dispatchQueue, leaveEvent, enterEvent, from, to) {
  var common = from && to ? getLowestCommonAncestor(from, to) : null;

  if (from !== null) {
    accumulateEnterLeaveListenersForEvent(dispatchQueue, leaveEvent, from, common, false);
  }

  if (to !== null && enterEvent !== null) {
    accumulateEnterLeaveListenersForEvent(dispatchQueue, enterEvent, to, common, true);
  }
}
function getListenerSetKey(domEventName, capture) {
  return domEventName + "__" + (capture ? 'capture' : 'bubble');
}

var didWarnInvalidHydration = false;
var DANGEROUSLY_SET_INNER_HTML = 'dangerouslySetInnerHTML';
var SUPPRESS_CONTENT_EDITABLE_WARNING = 'suppressContentEditableWarning';
var SUPPRESS_HYDRATION_WARNING = 'suppressHydrationWarning';
var AUTOFOCUS = 'autoFocus';
var CHILDREN = 'children';
var STYLE = 'style';
var HTML$1 = '__html';
var HTML_NAMESPACE$1 = Namespaces.html;
var warnedUnknownTags;
var suppressHydrationWarning;
var validatePropertiesInDevelopment;
var warnForTextDifference;
var warnForPropDifference;
var warnForExtraAttributes;
var warnForInvalidEventListener;
var canDiffStyleForHydrationWarning;
var normalizeMarkupForTextOrAttribute;
var normalizeHTML;

{
  warnedUnknownTags = {
    // There are working polyfills for <dialog>. Let people use it.
    dialog: true,
    // Electron ships a custom <webview> tag to display external web content in
    // an isolated frame and process.
    // This tag is not present in non Electron environments such as JSDom which
    // is often used for testing purposes.
    // @see https://electronjs.org/docs/api/webview-tag
    webview: true
  };

  validatePropertiesInDevelopment = function (type, props) {
    validateProperties(type, props);
    validateProperties$1(type, props);
    validateProperties$2(type, props, {
      registrationNameDependencies: registrationNameDependencies,
      possibleRegistrationNames: possibleRegistrationNames
    });
  }; // IE 11 parses & normalizes the style attribute as opposed to other
  // browsers. It adds spaces and sorts the properties in some
  // non-alphabetical order. Handling that would require sorting CSS
  // properties in the client & server versions or applying
  // `expectedStyle` to a temporary DOM node to read its `style` attribute
  // normalized. Since it only affects IE, we're skipping style warnings
  // in that browser completely in favor of doing all that work.
  // See https://github.com/facebook/react/issues/11807


  canDiffStyleForHydrationWarning = canUseDOM && !document.documentMode; // HTML parsing normalizes CR and CRLF to LF.
  // It also can turn \u0000 into \uFFFD inside attributes.
  // https://www.w3.org/TR/html5/single-page.html#preprocessing-the-input-stream
  // If we have a mismatch, it might be caused by that.
  // We will still patch up in this case but not fire the warning.

  var NORMALIZE_NEWLINES_REGEX = /\r\n?/g;
  var NORMALIZE_NULL_AND_REPLACEMENT_REGEX = /\u0000|\uFFFD/g;

  normalizeMarkupForTextOrAttribute = function (markup) {
    var markupString = typeof markup === 'string' ? markup : '' + markup;
    return markupString.replace(NORMALIZE_NEWLINES_REGEX, '\n').replace(NORMALIZE_NULL_AND_REPLACEMENT_REGEX, '');
  };

  warnForTextDifference = function (serverText, clientText) {
    if (didWarnInvalidHydration) {
      return;
    }

    var normalizedClientText = normalizeMarkupForTextOrAttribute(clientText);
    var normalizedServerText = normalizeMarkupForTextOrAttribute(serverText);

    if (normalizedServerText === normalizedClientText) {
      return;
    }

    didWarnInvalidHydration = true;

    error('Text content did not match. Server: "%s" Client: "%s"', normalizedServerText, normalizedClientText);
  };

  warnForPropDifference = function (propName, serverValue, clientValue) {
    if (didWarnInvalidHydration) {
      return;
    }

    var normalizedClientValue = normalizeMarkupForTextOrAttribute(clientValue);
    var normalizedServerValue = normalizeMarkupForTextOrAttribute(serverValue);

    if (normalizedServerValue === normalizedClientValue) {
      return;
    }

    didWarnInvalidHydration = true;

    error('Prop `%s` did not match. Server: %s Client: %s', propName, JSON.stringify(normalizedServerValue), JSON.stringify(normalizedClientValue));
  };

  warnForExtraAttributes = function (attributeNames) {
    if (didWarnInvalidHydration) {
      return;
    }

    didWarnInvalidHydration = true;
    var names = [];
    attributeNames.forEach(function (name) {
      names.push(name);
    });

    error('Extra attributes from the server: %s', names);
  };

  warnForInvalidEventListener = function (registrationName, listener) {
    if (listener === false) {
      error('Expected `%s` listener to be a function, instead got `false`.\n\n' + 'If you used to conditionally omit it with %s={condition && value}, ' + 'pass %s={condition ? value : undefined} instead.', registrationName, registrationName, registrationName);
    } else {
      error('Expected `%s` listener to be a function, instead got a value of `%s` type.', registrationName, typeof listener);
    }
  }; // Parse the HTML and read it back to normalize the HTML string so that it
  // can be used for comparison.


  normalizeHTML = function (parent, html) {
    // We could have created a separate document here to avoid
    // re-initializing custom elements if they exist. But this breaks
    // how <noscript> is being handled. So we use the same document.
    // See the discussion in https://github.com/facebook/react/pull/11157.
    var testElement = parent.namespaceURI === HTML_NAMESPACE$1 ? parent.ownerDocument.createElement(parent.tagName) : parent.ownerDocument.createElementNS(parent.namespaceURI, parent.tagName);
    testElement.innerHTML = html;
    return testElement.innerHTML;
  };
}

function getOwnerDocumentFromRootContainer(rootContainerElement) {
  return rootContainerElement.nodeType === DOCUMENT_NODE ? rootContainerElement : rootContainerElement.ownerDocument;
}

function noop() {}

function trapClickOnNonInteractiveElement(node) {
  // Mobile Safari does not fire properly bubble click events on
  // non-interactive elements, which means delegated click listeners do not
  // fire. The workaround for this bug involves attaching an empty click
  // listener on the target node.
  // https://www.quirksmode.org/blog/archives/2010/09/click_event_del.html
  // Just set it using the onclick property so that we don't have to manage any
  // bookkeeping for it. Not sure if we need to clear it when the listener is
  // removed.
  // TODO: Only do this for the relevant Safaris maybe?
  node.onclick = noop;
}

function setInitialDOMProperties(tag, domElement, rootContainerElement, nextProps, isCustomComponentTag) {
  for (var propKey in nextProps) {
    if (!nextProps.hasOwnProperty(propKey)) {
      continue;
    }

    var nextProp = nextProps[propKey];

    if (propKey === STYLE) {
      {
        if (nextProp) {
          // Freeze the next style object so that we can assume it won't be
          // mutated. We have already warned for this in the past.
          Object.freeze(nextProp);
        }
      } // Relies on `updateStylesByID` not mutating `styleUpdates`.


      setValueForStyles(domElement, nextProp);
    } else if (propKey === DANGEROUSLY_SET_INNER_HTML) {
      var nextHtml = nextProp ? nextProp[HTML$1] : undefined;

      if (nextHtml != null) {
        setInnerHTML(domElement, nextHtml);
      }
    } else if (propKey === CHILDREN) {
      if (typeof nextProp === 'string') {
        // Avoid setting initial textContent when the text is empty. In IE11 setting
        // textContent on a <textarea> will cause the placeholder to not
        // show within the <textarea> until it has been focused and blurred again.
        // https://github.com/facebook/react/issues/6731#issuecomment-254874553
        var canSetTextContent = tag !== 'textarea' || nextProp !== '';

        if (canSetTextContent) {
          setTextContent(domElement, nextProp);
        }
      } else if (typeof nextProp === 'number') {
        setTextContent(domElement, '' + nextProp);
      }
    } else if (propKey === SUPPRESS_CONTENT_EDITABLE_WARNING || propKey === SUPPRESS_HYDRATION_WARNING) ; else if (propKey === AUTOFOCUS) ; else if (registrationNameDependencies.hasOwnProperty(propKey)) {
      if (nextProp != null) {
        if ( typeof nextProp !== 'function') {
          warnForInvalidEventListener(propKey, nextProp);
        }

        if (propKey === 'onScroll') {
          listenToNonDelegatedEvent('scroll', domElement);
        }
      }
    } else if (nextProp != null) {
      setValueForProperty(domElement, propKey, nextProp, isCustomComponentTag);
    }
  }
}

function updateDOMProperties(domElement, updatePayload, wasCustomComponentTag, isCustomComponentTag) {
  // TODO: Handle wasCustomComponentTag
  for (var i = 0; i < updatePayload.length; i += 2) {
    var propKey = updatePayload[i];
    var propValue = updatePayload[i + 1];

    if (propKey === STYLE) {
      setValueForStyles(domElement, propValue);
    } else if (propKey === DANGEROUSLY_SET_INNER_HTML) {
      setInnerHTML(domElement, propValue);
    } else if (propKey === CHILDREN) {
      setTextContent(domElement, propValue);
    } else {
      setValueForProperty(domElement, propKey, propValue, isCustomComponentTag);
    }
  }
}

function createElement(type, props, rootContainerElement, parentNamespace) {
  var isCustomComponentTag; // We create tags in the namespace of their parent container, except HTML
  // tags get no namespace.

  var ownerDocument = getOwnerDocumentFromRootContainer(rootContainerElement);
  var domElement;
  var namespaceURI = parentNamespace;

  if (namespaceURI === HTML_NAMESPACE$1) {
    namespaceURI = getIntrinsicNamespace(type);
  }

  if (namespaceURI === HTML_NAMESPACE$1) {
    {
      isCustomComponentTag = isCustomComponent(type, props); // Should this check be gated by parent namespace? Not sure we want to
      // allow <SVG> or <mATH>.

      if (!isCustomComponentTag && type !== type.toLowerCase()) {
        error('<%s /> is using incorrect casing. ' + 'Use PascalCase for React components, ' + 'or lowercase for HTML elements.', type);
      }
    }

    if (type === 'script') {
      // Create the script via .innerHTML so its "parser-inserted" flag is
      // set to true and it does not execute
      var div = ownerDocument.createElement('div');

      div.innerHTML = '<script><' + '/script>'; // eslint-disable-line
      // This is guaranteed to yield a script element.

      var firstChild = div.firstChild;
      domElement = div.removeChild(firstChild);
    } else if (typeof props.is === 'string') {
      // $FlowIssue `createElement` should be updated for Web Components
      domElement = ownerDocument.createElement(type, {
        is: props.is
      });
    } else {
      // Separate else branch instead of using `props.is || undefined` above because of a Firefox bug.
      // See discussion in https://github.com/facebook/react/pull/6896
      // and discussion in https://bugzilla.mozilla.org/show_bug.cgi?id=1276240
      domElement = ownerDocument.createElement(type); // Normally attributes are assigned in `setInitialDOMProperties`, however the `multiple` and `size`
      // attributes on `select`s needs to be added before `option`s are inserted.
      // This prevents:
      // - a bug where the `select` does not scroll to the correct option because singular
      //  `select` elements automatically pick the first item #13222
      // - a bug where the `select` set the first item as selected despite the `size` attribute #14239
      // See https://github.com/facebook/react/issues/13222
      // and https://github.com/facebook/react/issues/14239

      if (type === 'select') {
        var node = domElement;

        if (props.multiple) {
          node.multiple = true;
        } else if (props.size) {
          // Setting a size greater than 1 causes a select to behave like `multiple=true`, where
          // it is possible that no option is selected.
          //
          // This is only necessary when a select in "single selection mode".
          node.size = props.size;
        }
      }
    }
  } else {
    domElement = ownerDocument.createElementNS(namespaceURI, type);
  }

  {
    if (namespaceURI === HTML_NAMESPACE$1) {
      if (!isCustomComponentTag && Object.prototype.toString.call(domElement) === '[object HTMLUnknownElement]' && !Object.prototype.hasOwnProperty.call(warnedUnknownTags, type)) {
        warnedUnknownTags[type] = true;

        error('The tag <%s> is unrecognized in this browser. ' + 'If you meant to render a React component, start its name with ' + 'an uppercase letter.', type);
      }
    }
  }

  return domElement;
}
function createTextNode(text, rootContainerElement) {
  return getOwnerDocumentFromRootContainer(rootContainerElement).createTextNode(text);
}
function setInitialProperties(domElement, tag, rawProps, rootContainerElement) {
  var isCustomComponentTag = isCustomComponent(tag, rawProps);

  {
    validatePropertiesInDevelopment(tag, rawProps);
  } // TODO: Make sure that we check isMounted before firing any of these events.


  var props;

  switch (tag) {
    case 'dialog':
      listenToNonDelegatedEvent('cancel', domElement);
      listenToNonDelegatedEvent('close', domElement);
      props = rawProps;
      break;

    case 'iframe':
    case 'object':
    case 'embed':
      // We listen to this event in case to ensure emulated bubble
      // listeners still fire for the load event.
      listenToNonDelegatedEvent('load', domElement);
      props = rawProps;
      break;

    case 'video':
    case 'audio':
      // We listen to these events in case to ensure emulated bubble
      // listeners still fire for all the media events.
      for (var i = 0; i < mediaEventTypes.length; i++) {
        listenToNonDelegatedEvent(mediaEventTypes[i], domElement);
      }

      props = rawProps;
      break;

    case 'source':
      // We listen to this event in case to ensure emulated bubble
      // listeners still fire for the error event.
      listenToNonDelegatedEvent('error', domElement);
      props = rawProps;
      break;

    case 'img':
    case 'image':
    case 'link':
      // We listen to these events in case to ensure emulated bubble
      // listeners still fire for error and load events.
      listenToNonDelegatedEvent('error', domElement);
      listenToNonDelegatedEvent('load', domElement);
      props = rawProps;
      break;

    case 'details':
      // We listen to this event in case to ensure emulated bubble
      // listeners still fire for the toggle event.
      listenToNonDelegatedEvent('toggle', domElement);
      props = rawProps;
      break;

    case 'input':
      initWrapperState(domElement, rawProps);
      props = getHostProps(domElement, rawProps); // We listen to this event in case to ensure emulated bubble
      // listeners still fire for the invalid event.

      listenToNonDelegatedEvent('invalid', domElement);

      break;

    case 'option':
      validateProps(domElement, rawProps);
      props = getHostProps$1(domElement, rawProps);
      break;

    case 'select':
      initWrapperState$1(domElement, rawProps);
      props = getHostProps$2(domElement, rawProps); // We listen to this event in case to ensure emulated bubble
      // listeners still fire for the invalid event.

      listenToNonDelegatedEvent('invalid', domElement);

      break;

    case 'textarea':
      initWrapperState$2(domElement, rawProps);
      props = getHostProps$3(domElement, rawProps); // We listen to this event in case to ensure emulated bubble
      // listeners still fire for the invalid event.

      listenToNonDelegatedEvent('invalid', domElement);

      break;

    default:
      props = rawProps;
  }

  assertValidProps(tag, props);
  setInitialDOMProperties(tag, domElement, rootContainerElement, props, isCustomComponentTag);

  switch (tag) {
    case 'input':
      // TODO: Make sure we check if this is still unmounted or do any clean
      // up necessary since we never stop tracking anymore.
      track(domElement);
      postMountWrapper(domElement, rawProps, false);
      break;

    case 'textarea':
      // TODO: Make sure we check if this is still unmounted or do any clean
      // up necessary since we never stop tracking anymore.
      track(domElement);
      postMountWrapper$3(domElement);
      break;

    case 'option':
      postMountWrapper$1(domElement, rawProps);
      break;

    case 'select':
      postMountWrapper$2(domElement, rawProps);
      break;

    default:
      if (typeof props.onClick === 'function') {
        // TODO: This cast may not be sound for SVG, MathML or custom elements.
        trapClickOnNonInteractiveElement(domElement);
      }

      break;
  }
} // Calculate the diff between the two objects.

function diffProperties(domElement, tag, lastRawProps, nextRawProps, rootContainerElement) {
  {
    validatePropertiesInDevelopment(tag, nextRawProps);
  }

  var updatePayload = null;
  var lastProps;
  var nextProps;

  switch (tag) {
    case 'input':
      lastProps = getHostProps(domElement, lastRawProps);
      nextProps = getHostProps(domElement, nextRawProps);
      updatePayload = [];
      break;

    case 'option':
      lastProps = getHostProps$1(domElement, lastRawProps);
      nextProps = getHostProps$1(domElement, nextRawProps);
      updatePayload = [];
      break;

    case 'select':
      lastProps = getHostProps$2(domElement, lastRawProps);
      nextProps = getHostProps$2(domElement, nextRawProps);
      updatePayload = [];
      break;

    case 'textarea':
      lastProps = getHostProps$3(domElement, lastRawProps);
      nextProps = getHostProps$3(domElement, nextRawProps);
      updatePayload = [];
      break;

    default:
      lastProps = lastRawProps;
      nextProps = nextRawProps;

      if (typeof lastProps.onClick !== 'function' && typeof nextProps.onClick === 'function') {
        // TODO: This cast may not be sound for SVG, MathML or custom elements.
        trapClickOnNonInteractiveElement(domElement);
      }

      break;
  }

  assertValidProps(tag, nextProps);
  var propKey;
  var styleName;
  var styleUpdates = null;

  for (propKey in lastProps) {
    if (nextProps.hasOwnProperty(propKey) || !lastProps.hasOwnProperty(propKey) || lastProps[propKey] == null) {
      continue;
    }

    if (propKey === STYLE) {
      var lastStyle = lastProps[propKey];

      for (styleName in lastStyle) {
        if (lastStyle.hasOwnProperty(styleName)) {
          if (!styleUpdates) {
            styleUpdates = {};
          }

          styleUpdates[styleName] = '';
        }
      }
    } else if (propKey === DANGEROUSLY_SET_INNER_HTML || propKey === CHILDREN) ; else if (propKey === SUPPRESS_CONTENT_EDITABLE_WARNING || propKey === SUPPRESS_HYDRATION_WARNING) ; else if (propKey === AUTOFOCUS) ; else if (registrationNameDependencies.hasOwnProperty(propKey)) {
      // This is a special case. If any listener updates we need to ensure
      // that the "current" fiber pointer gets updated so we need a commit
      // to update this element.
      if (!updatePayload) {
        updatePayload = [];
      }
    } else {
      // For all other deleted properties we add it to the queue. We use
      // the allowed property list in the commit phase instead.
      (updatePayload = updatePayload || []).push(propKey, null);
    }
  }

  for (propKey in nextProps) {
    var nextProp = nextProps[propKey];
    var lastProp = lastProps != null ? lastProps[propKey] : undefined;

    if (!nextProps.hasOwnProperty(propKey) || nextProp === lastProp || nextProp == null && lastProp == null) {
      continue;
    }

    if (propKey === STYLE) {
      {
        if (nextProp) {
          // Freeze the next style object so that we can assume it won't be
          // mutated. We have already warned for this in the past.
          Object.freeze(nextProp);
        }
      }

      if (lastProp) {
        // Unset styles on `lastProp` but not on `nextProp`.
        for (styleName in lastProp) {
          if (lastProp.hasOwnProperty(styleName) && (!nextProp || !nextProp.hasOwnProperty(styleName))) {
            if (!styleUpdates) {
              styleUpdates = {};
            }

            styleUpdates[styleName] = '';
          }
        } // Update styles that changed since `lastProp`.


        for (styleName in nextProp) {
          if (nextProp.hasOwnProperty(styleName) && lastProp[styleName] !== nextProp[styleName]) {
            if (!styleUpdates) {
              styleUpdates = {};
            }

            styleUpdates[styleName] = nextProp[styleName];
          }
        }
      } else {
        // Relies on `updateStylesByID` not mutating `styleUpdates`.
        if (!styleUpdates) {
          if (!updatePayload) {
            updatePayload = [];
          }

          updatePayload.push(propKey, styleUpdates);
        }

        styleUpdates = nextProp;
      }
    } else if (propKey === DANGEROUSLY_SET_INNER_HTML) {
      var nextHtml = nextProp ? nextProp[HTML$1] : undefined;
      var lastHtml = lastProp ? lastProp[HTML$1] : undefined;

      if (nextHtml != null) {
        if (lastHtml !== nextHtml) {
          (updatePayload = updatePayload || []).push(propKey, nextHtml);
        }
      }
    } else if (propKey === CHILDREN) {
      if (typeof nextProp === 'string' || typeof nextProp === 'number') {
        (updatePayload = updatePayload || []).push(propKey, '' + nextProp);
      }
    } else if (propKey === SUPPRESS_CONTENT_EDITABLE_WARNING || propKey === SUPPRESS_HYDRATION_WARNING) ; else if (registrationNameDependencies.hasOwnProperty(propKey)) {
      if (nextProp != null) {
        // We eagerly listen to this even though we haven't committed yet.
        if ( typeof nextProp !== 'function') {
          warnForInvalidEventListener(propKey, nextProp);
        }

        if (propKey === 'onScroll') {
          listenToNonDelegatedEvent('scroll', domElement);
        }
      }

      if (!updatePayload && lastProp !== nextProp) {
        // This is a special case. If any listener updates we need to ensure
        // that the "current" props pointer gets updated so we need a commit
        // to update this element.
        updatePayload = [];
      }
    } else if (typeof nextProp === 'object' && nextProp !== null && nextProp.$$typeof === REACT_OPAQUE_ID_TYPE) {
      // If we encounter useOpaqueReference's opaque object, this means we are hydrating.
      // In this case, call the opaque object's toString function which generates a new client
      // ID so client and server IDs match and throws to rerender.
      nextProp.toString();
    } else {
      // For any other property we always add it to the queue and then we
      // filter it out using the allowed property list during the commit.
      (updatePayload = updatePayload || []).push(propKey, nextProp);
    }
  }

  if (styleUpdates) {
    {
      validateShorthandPropertyCollisionInDev(styleUpdates, nextProps[STYLE]);
    }

    (updatePayload = updatePayload || []).push(STYLE, styleUpdates);
  }

  return updatePayload;
} // Apply the diff.

function updateProperties(domElement, updatePayload, tag, lastRawProps, nextRawProps) {
  // Update checked *before* name.
  // In the middle of an update, it is possible to have multiple checked.
  // When a checked radio tries to change name, browser makes another radio's checked false.
  if (tag === 'input' && nextRawProps.type === 'radio' && nextRawProps.name != null) {
    updateChecked(domElement, nextRawProps);
  }

  var wasCustomComponentTag = isCustomComponent(tag, lastRawProps);
  var isCustomComponentTag = isCustomComponent(tag, nextRawProps); // Apply the diff.

  updateDOMProperties(domElement, updatePayload, wasCustomComponentTag, isCustomComponentTag); // TODO: Ensure that an update gets scheduled if any of the special props
  // changed.

  switch (tag) {
    case 'input':
      // Update the wrapper around inputs *after* updating props. This has to
      // happen after `updateDOMProperties`. Otherwise HTML5 input validations
      // raise warnings and prevent the new value from being assigned.
      updateWrapper(domElement, nextRawProps);
      break;

    case 'textarea':
      updateWrapper$1(domElement, nextRawProps);
      break;

    case 'select':
      // <select> value update needs to occur after <option> children
      // reconciliation
      postUpdateWrapper(domElement, nextRawProps);
      break;
  }
}

function getPossibleStandardName(propName) {
  {
    var lowerCasedName = propName.toLowerCase();

    if (!possibleStandardNames.hasOwnProperty(lowerCasedName)) {
      return null;
    }

    return possibleStandardNames[lowerCasedName] || null;
  }
}

function diffHydratedProperties(domElement, tag, rawProps, parentNamespace, rootContainerElement) {
  var isCustomComponentTag;
  var extraAttributeNames;

  {
    suppressHydrationWarning = rawProps[SUPPRESS_HYDRATION_WARNING] === true;
    isCustomComponentTag = isCustomComponent(tag, rawProps);
    validatePropertiesInDevelopment(tag, rawProps);
  } // TODO: Make sure that we check isMounted before firing any of these events.


  switch (tag) {
    case 'dialog':
      listenToNonDelegatedEvent('cancel', domElement);
      listenToNonDelegatedEvent('close', domElement);
      break;

    case 'iframe':
    case 'object':
    case 'embed':
      // We listen to this event in case to ensure emulated bubble
      // listeners still fire for the load event.
      listenToNonDelegatedEvent('load', domElement);
      break;

    case 'video':
    case 'audio':
      // We listen to these events in case to ensure emulated bubble
      // listeners still fire for all the media events.
      for (var i = 0; i < mediaEventTypes.length; i++) {
        listenToNonDelegatedEvent(mediaEventTypes[i], domElement);
      }

      break;

    case 'source':
      // We listen to this event in case to ensure emulated bubble
      // listeners still fire for the error event.
      listenToNonDelegatedEvent('error', domElement);
      break;

    case 'img':
    case 'image':
    case 'link':
      // We listen to these events in case to ensure emulated bubble
      // listeners still fire for error and load events.
      listenToNonDelegatedEvent('error', domElement);
      listenToNonDelegatedEvent('load', domElement);
      break;

    case 'details':
      // We listen to this event in case to ensure emulated bubble
      // listeners still fire for the toggle event.
      listenToNonDelegatedEvent('toggle', domElement);
      break;

    case 'input':
      initWrapperState(domElement, rawProps); // We listen to this event in case to ensure emulated bubble
      // listeners still fire for the invalid event.

      listenToNonDelegatedEvent('invalid', domElement);

      break;

    case 'option':
      validateProps(domElement, rawProps);
      break;

    case 'select':
      initWrapperState$1(domElement, rawProps); // We listen to this event in case to ensure emulated bubble
      // listeners still fire for the invalid event.

      listenToNonDelegatedEvent('invalid', domElement);

      break;

    case 'textarea':
      initWrapperState$2(domElement, rawProps); // We listen to this event in case to ensure emulated bubble
      // listeners still fire for the invalid event.

      listenToNonDelegatedEvent('invalid', domElement);

      break;
  }

  assertValidProps(tag, rawProps);

  {
    extraAttributeNames = new Set();
    var attributes = domElement.attributes;

    for (var _i = 0; _i < attributes.length; _i++) {
      var name = attributes[_i].name.toLowerCase();

      switch (name) {
        // Built-in SSR attribute is allowed
        case 'data-reactroot':
          break;
        // Controlled attributes are not validated
        // TODO: Only ignore them on controlled tags.

        case 'value':
          break;

        case 'checked':
          break;

        case 'selected':
          break;

        default:
          // Intentionally use the original name.
          // See discussion in https://github.com/facebook/react/pull/10676.
          extraAttributeNames.add(attributes[_i].name);
      }
    }
  }

  var updatePayload = null;

  for (var propKey in rawProps) {
    if (!rawProps.hasOwnProperty(propKey)) {
      continue;
    }

    var nextProp = rawProps[propKey];

    if (propKey === CHILDREN) {
      // For text content children we compare against textContent. This
      // might match additional HTML that is hidden when we read it using
      // textContent. E.g. "foo" will match "f<span>oo</span>" but that still
      // satisfies our requirement. Our requirement is not to produce perfect
      // HTML and attributes. Ideally we should preserve structure but it's
      // ok not to if the visible content is still enough to indicate what
      // even listeners these nodes might be wired up to.
      // TODO: Warn if there is more than a single textNode as a child.
      // TODO: Should we use domElement.firstChild.nodeValue to compare?
      if (typeof nextProp === 'string') {
        if (domElement.textContent !== nextProp) {
          if ( !suppressHydrationWarning) {
            warnForTextDifference(domElement.textContent, nextProp);
          }

          updatePayload = [CHILDREN, nextProp];
        }
      } else if (typeof nextProp === 'number') {
        if (domElement.textContent !== '' + nextProp) {
          if ( !suppressHydrationWarning) {
            warnForTextDifference(domElement.textContent, nextProp);
          }

          updatePayload = [CHILDREN, '' + nextProp];
        }
      }
    } else if (registrationNameDependencies.hasOwnProperty(propKey)) {
      if (nextProp != null) {
        if ( typeof nextProp !== 'function') {
          warnForInvalidEventListener(propKey, nextProp);
        }

        if (propKey === 'onScroll') {
          listenToNonDelegatedEvent('scroll', domElement);
        }
      }
    } else if ( // Convince Flow we've calculated it (it's DEV-only in this method.)
    typeof isCustomComponentTag === 'boolean') {
      // Validate that the properties correspond to their expected values.
      var serverValue = void 0;
      var propertyInfo = getPropertyInfo(propKey);

      if (suppressHydrationWarning) ; else if (propKey === SUPPRESS_CONTENT_EDITABLE_WARNING || propKey === SUPPRESS_HYDRATION_WARNING || // Controlled attributes are not validated
      // TODO: Only ignore them on controlled tags.
      propKey === 'value' || propKey === 'checked' || propKey === 'selected') ; else if (propKey === DANGEROUSLY_SET_INNER_HTML) {
        var serverHTML = domElement.innerHTML;
        var nextHtml = nextProp ? nextProp[HTML$1] : undefined;

        if (nextHtml != null) {
          var expectedHTML = normalizeHTML(domElement, nextHtml);

          if (expectedHTML !== serverHTML) {
            warnForPropDifference(propKey, serverHTML, expectedHTML);
          }
        }
      } else if (propKey === STYLE) {
        // $FlowFixMe - Should be inferred as not undefined.
        extraAttributeNames.delete(propKey);

        if (canDiffStyleForHydrationWarning) {
          var expectedStyle = createDangerousStringForStyles(nextProp);
          serverValue = domElement.getAttribute('style');

          if (expectedStyle !== serverValue) {
            warnForPropDifference(propKey, serverValue, expectedStyle);
          }
        }
      } else if (isCustomComponentTag) {
        // $FlowFixMe - Should be inferred as not undefined.
        extraAttributeNames.delete(propKey.toLowerCase());
        serverValue = getValueForAttribute(domElement, propKey, nextProp);

        if (nextProp !== serverValue) {
          warnForPropDifference(propKey, serverValue, nextProp);
        }
      } else if (!shouldIgnoreAttribute(propKey, propertyInfo, isCustomComponentTag) && !shouldRemoveAttribute(propKey, nextProp, propertyInfo, isCustomComponentTag)) {
        var isMismatchDueToBadCasing = false;

        if (propertyInfo !== null) {
          // $FlowFixMe - Should be inferred as not undefined.
          extraAttributeNames.delete(propertyInfo.attributeName);
          serverValue = getValueForProperty(domElement, propKey, nextProp, propertyInfo);
        } else {
          var ownNamespace = parentNamespace;

          if (ownNamespace === HTML_NAMESPACE$1) {
            ownNamespace = getIntrinsicNamespace(tag);
          }

          if (ownNamespace === HTML_NAMESPACE$1) {
            // $FlowFixMe - Should be inferred as not undefined.
            extraAttributeNames.delete(propKey.toLowerCase());
          } else {
            var standardName = getPossibleStandardName(propKey);

            if (standardName !== null && standardName !== propKey) {
              // If an SVG prop is supplied with bad casing, it will
              // be successfully parsed from HTML, but will produce a mismatch
              // (and would be incorrectly rendered on the client).
              // However, we already warn about bad casing elsewhere.
              // So we'll skip the misleading extra mismatch warning in this case.
              isMismatchDueToBadCasing = true; // $FlowFixMe - Should be inferred as not undefined.

              extraAttributeNames.delete(standardName);
            } // $FlowFixMe - Should be inferred as not undefined.


            extraAttributeNames.delete(propKey);
          }

          serverValue = getValueForAttribute(domElement, propKey, nextProp);
        }

        if (nextProp !== serverValue && !isMismatchDueToBadCasing) {
          warnForPropDifference(propKey, serverValue, nextProp);
        }
      }
    }
  }

  {
    // $FlowFixMe - Should be inferred as not undefined.
    if (extraAttributeNames.size > 0 && !suppressHydrationWarning) {
      // $FlowFixMe - Should be inferred as not undefined.
      warnForExtraAttributes(extraAttributeNames);
    }
  }

  switch (tag) {
    case 'input':
      // TODO: Make sure we check if this is still unmounted or do any clean
      // up necessary since we never stop tracking anymore.
      track(domElement);
      postMountWrapper(domElement, rawProps, true);
      break;

    case 'textarea':
      // TODO: Make sure we check if this is still unmounted or do any clean
      // up necessary since we never stop tracking anymore.
      track(domElement);
      postMountWrapper$3(domElement);
      break;

    case 'select':
    case 'option':
      // For input and textarea we current always set the value property at
      // post mount to force it to diverge from attributes. However, for
      // option and select we don't quite do the same thing and select
      // is not resilient to the DOM state changing so we don't do that here.
      // TODO: Consider not doing this for input and textarea.
      break;

    default:
      if (typeof rawProps.onClick === 'function') {
        // TODO: This cast may not be sound for SVG, MathML or custom elements.
        trapClickOnNonInteractiveElement(domElement);
      }

      break;
  }

  return updatePayload;
}
function diffHydratedText(textNode, text) {
  var isDifferent = textNode.nodeValue !== text;
  return isDifferent;
}
function warnForUnmatchedText(textNode, text) {
  {
    warnForTextDifference(textNode.nodeValue, text);
  }
}
function warnForDeletedHydratableElement(parentNode, child) {
  {
    if (didWarnInvalidHydration) {
      return;
    }

    didWarnInvalidHydration = true;

    error('Did not expect server HTML to contain a <%s> in <%s>.', child.nodeName.toLowerCase(), parentNode.nodeName.toLowerCase());
  }
}
function warnForDeletedHydratableText(parentNode, child) {
  {
    if (didWarnInvalidHydration) {
      return;
    }

    didWarnInvalidHydration = true;

    error('Did not expect server HTML to contain the text node "%s" in <%s>.', child.nodeValue, parentNode.nodeName.toLowerCase());
  }
}
function warnForInsertedHydratedElement(parentNode, tag, props) {
  {
    if (didWarnInvalidHydration) {
      return;
    }

    didWarnInvalidHydration = true;

    error('Expected server HTML to contain a matching <%s> in <%s>.', tag, parentNode.nodeName.toLowerCase());
  }
}
function warnForInsertedHydratedText(parentNode, text) {
  {
    if (text === '') {
      // We expect to insert empty text nodes since they're not represented in
      // the HTML.
      // TODO: Remove this special case if we can just avoid inserting empty
      // text nodes.
      return;
    }

    if (didWarnInvalidHydration) {
      return;
    }

    didWarnInvalidHydration = true;

    error('Expected server HTML to contain a matching text node for "%s" in <%s>.', text, parentNode.nodeName.toLowerCase());
  }
}
function restoreControlledState$3(domElement, tag, props) {
  switch (tag) {
    case 'input':
      restoreControlledState(domElement, props);
      return;

    case 'textarea':
      restoreControlledState$2(domElement, props);
      return;

    case 'select':
      restoreControlledState$1(domElement, props);
      return;
  }
}

var validateDOMNesting = function () {};

var updatedAncestorInfo = function () {};

{
  // This validation code was written based on the HTML5 parsing spec:
  // https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-scope
  //
  // Note: this does not catch all invalid nesting, nor does it try to (as it's
  // not clear what practical benefit doing so provides); instead, we warn only
  // for cases where the parser will give a parse tree differing from what React
  // intended. For example, <b><div></div></b> is invalid but we don't warn
  // because it still parses correctly; we do warn for other cases like nested
  // <p> tags where the beginning of the second element implicitly closes the
  // first, causing a confusing mess.
  // https://html.spec.whatwg.org/multipage/syntax.html#special
  var specialTags = ['address', 'applet', 'area', 'article', 'aside', 'base', 'basefont', 'bgsound', 'blockquote', 'body', 'br', 'button', 'caption', 'center', 'col', 'colgroup', 'dd', 'details', 'dir', 'div', 'dl', 'dt', 'embed', 'fieldset', 'figcaption', 'figure', 'footer', 'form', 'frame', 'frameset', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'head', 'header', 'hgroup', 'hr', 'html', 'iframe', 'img', 'input', 'isindex', 'li', 'link', 'listing', 'main', 'marquee', 'menu', 'menuitem', 'meta', 'nav', 'noembed', 'noframes', 'noscript', 'object', 'ol', 'p', 'param', 'plaintext', 'pre', 'script', 'section', 'select', 'source', 'style', 'summary', 'table', 'tbody', 'td', 'template', 'textarea', 'tfoot', 'th', 'thead', 'title', 'tr', 'track', 'ul', 'wbr', 'xmp']; // https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-scope

  var inScopeTags = ['applet', 'caption', 'html', 'table', 'td', 'th', 'marquee', 'object', 'template', // https://html.spec.whatwg.org/multipage/syntax.html#html-integration-point
  // TODO: Distinguish by namespace here -- for <title>, including it here
  // errs on the side of fewer warnings
  'foreignObject', 'desc', 'title']; // https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-button-scope

  var buttonScopeTags = inScopeTags.concat(['button']); // https://html.spec.whatwg.org/multipage/syntax.html#generate-implied-end-tags

  var impliedEndTags = ['dd', 'dt', 'li', 'option', 'optgroup', 'p', 'rp', 'rt'];
  var emptyAncestorInfo = {
    current: null,
    formTag: null,
    aTagInScope: null,
    buttonTagInScope: null,
    nobrTagInScope: null,
    pTagInButtonScope: null,
    listItemTagAutoclosing: null,
    dlItemTagAutoclosing: null
  };

  updatedAncestorInfo = function (oldInfo, tag) {
    var ancestorInfo = _assign({}, oldInfo || emptyAncestorInfo);

    var info = {
      tag: tag
    };

    if (inScopeTags.indexOf(tag) !== -1) {
      ancestorInfo.aTagInScope = null;
      ancestorInfo.buttonTagInScope = null;
      ancestorInfo.nobrTagInScope = null;
    }

    if (buttonScopeTags.indexOf(tag) !== -1) {
      ancestorInfo.pTagInButtonScope = null;
    } // See rules for 'li', 'dd', 'dt' start tags in
    // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inbody


    if (specialTags.indexOf(tag) !== -1 && tag !== 'address' && tag !== 'div' && tag !== 'p') {
      ancestorInfo.listItemTagAutoclosing = null;
      ancestorInfo.dlItemTagAutoclosing = null;
    }

    ancestorInfo.current = info;

    if (tag === 'form') {
      ancestorInfo.formTag = info;
    }

    if (tag === 'a') {
      ancestorInfo.aTagInScope = info;
    }

    if (tag === 'button') {
      ancestorInfo.buttonTagInScope = info;
    }

    if (tag === 'nobr') {
      ancestorInfo.nobrTagInScope = info;
    }

    if (tag === 'p') {
      ancestorInfo.pTagInButtonScope = info;
    }

    if (tag === 'li') {
      ancestorInfo.listItemTagAutoclosing = info;
    }

    if (tag === 'dd' || tag === 'dt') {
      ancestorInfo.dlItemTagAutoclosing = info;
    }

    return ancestorInfo;
  };
  /**
   * Returns whether
   */


  var isTagValidWithParent = function (tag, parentTag) {
    // First, let's check if we're in an unusual parsing mode...
    switch (parentTag) {
      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inselect
      case 'select':
        return tag === 'option' || tag === 'optgroup' || tag === '#text';

      case 'optgroup':
        return tag === 'option' || tag === '#text';
      // Strictly speaking, seeing an <option> doesn't mean we're in a <select>
      // but

      case 'option':
        return tag === '#text';
      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intd
      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-incaption
      // No special behavior since these rules fall back to "in body" mode for
      // all except special table nodes which cause bad parsing behavior anyway.
      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intr

      case 'tr':
        return tag === 'th' || tag === 'td' || tag === 'style' || tag === 'script' || tag === 'template';
      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intbody

      case 'tbody':
      case 'thead':
      case 'tfoot':
        return tag === 'tr' || tag === 'style' || tag === 'script' || tag === 'template';
      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-incolgroup

      case 'colgroup':
        return tag === 'col' || tag === 'template';
      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intable

      case 'table':
        return tag === 'caption' || tag === 'colgroup' || tag === 'tbody' || tag === 'tfoot' || tag === 'thead' || tag === 'style' || tag === 'script' || tag === 'template';
      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inhead

      case 'head':
        return tag === 'base' || tag === 'basefont' || tag === 'bgsound' || tag === 'link' || tag === 'meta' || tag === 'title' || tag === 'noscript' || tag === 'noframes' || tag === 'style' || tag === 'script' || tag === 'template';
      // https://html.spec.whatwg.org/multipage/semantics.html#the-html-element

      case 'html':
        return tag === 'head' || tag === 'body' || tag === 'frameset';

      case 'frameset':
        return tag === 'frame';

      case '#document':
        return tag === 'html';
    } // Probably in the "in body" parsing mode, so we outlaw only tag combos
    // where the parsing rules cause implicit opens or closes to be added.
    // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inbody


    switch (tag) {
      case 'h1':
      case 'h2':
      case 'h3':
      case 'h4':
      case 'h5':
      case 'h6':
        return parentTag !== 'h1' && parentTag !== 'h2' && parentTag !== 'h3' && parentTag !== 'h4' && parentTag !== 'h5' && parentTag !== 'h6';

      case 'rp':
      case 'rt':
        return impliedEndTags.indexOf(parentTag) === -1;

      case 'body':
      case 'caption':
      case 'col':
      case 'colgroup':
      case 'frameset':
      case 'frame':
      case 'head':
      case 'html':
      case 'tbody':
      case 'td':
      case 'tfoot':
      case 'th':
      case 'thead':
      case 'tr':
        // These tags are only valid with a few parents that have special child
        // parsing rules -- if we're down here, then none of those matched and
        // so we allow it only if we don't know what the parent is, as all other
        // cases are invalid.
        return parentTag == null;
    }

    return true;
  };
  /**
   * Returns whether
   */


  var findInvalidAncestorForTag = function (tag, ancestorInfo) {
    switch (tag) {
      case 'address':
      case 'article':
      case 'aside':
      case 'blockquote':
      case 'center':
      case 'details':
      case 'dialog':
      case 'dir':
      case 'div':
      case 'dl':
      case 'fieldset':
      case 'figcaption':
      case 'figure':
      case 'footer':
      case 'header':
      case 'hgroup':
      case 'main':
      case 'menu':
      case 'nav':
      case 'ol':
      case 'p':
      case 'section':
      case 'summary':
      case 'ul':
      case 'pre':
      case 'listing':
      case 'table':
      case 'hr':
      case 'xmp':
      case 'h1':
      case 'h2':
      case 'h3':
      case 'h4':
      case 'h5':
      case 'h6':
        return ancestorInfo.pTagInButtonScope;

      case 'form':
        return ancestorInfo.formTag || ancestorInfo.pTagInButtonScope;

      case 'li':
        return ancestorInfo.listItemTagAutoclosing;

      case 'dd':
      case 'dt':
        return ancestorInfo.dlItemTagAutoclosing;

      case 'button':
        return ancestorInfo.buttonTagInScope;

      case 'a':
        // Spec says something about storing a list of markers, but it sounds
        // equivalent to this check.
        return ancestorInfo.aTagInScope;

      case 'nobr':
        return ancestorInfo.nobrTagInScope;
    }

    return null;
  };

  var didWarn$1 = {};

  validateDOMNesting = function (childTag, childText, ancestorInfo) {
    ancestorInfo = ancestorInfo || emptyAncestorInfo;
    var parentInfo = ancestorInfo.current;
    var parentTag = parentInfo && parentInfo.tag;

    if (childText != null) {
      if (childTag != null) {
        error('validateDOMNesting: when childText is passed, childTag should be null');
      }

      childTag = '#text';
    }

    var invalidParent = isTagValidWithParent(childTag, parentTag) ? null : parentInfo;
    var invalidAncestor = invalidParent ? null : findInvalidAncestorForTag(childTag, ancestorInfo);
    var invalidParentOrAncestor = invalidParent || invalidAncestor;

    if (!invalidParentOrAncestor) {
      return;
    }

    var ancestorTag = invalidParentOrAncestor.tag;
    var warnKey = !!invalidParent + '|' + childTag + '|' + ancestorTag;

    if (didWarn$1[warnKey]) {
      return;
    }

    didWarn$1[warnKey] = true;
    var tagDisplayName = childTag;
    var whitespaceInfo = '';

    if (childTag === '#text') {
      if (/\S/.test(childText)) {
        tagDisplayName = 'Text nodes';
      } else {
        tagDisplayName = 'Whitespace text nodes';
        whitespaceInfo = " Make sure you don't have any extra whitespace between tags on " + 'each line of your source code.';
      }
    } else {
      tagDisplayName = '<' + childTag + '>';
    }

    if (invalidParent) {
      var info = '';

      if (ancestorTag === 'table' && childTag === 'tr') {
        info += ' Add a <tbody>, <thead> or <tfoot> to your code to match the DOM tree generated by ' + 'the browser.';
      }

      error('validateDOMNesting(...): %s cannot appear as a child of <%s>.%s%s', tagDisplayName, ancestorTag, whitespaceInfo, info);
    } else {
      error('validateDOMNesting(...): %s cannot appear as a descendant of ' + '<%s>.', tagDisplayName, ancestorTag);
    }
  };
}

var SUPPRESS_HYDRATION_WARNING$1;

{
  SUPPRESS_HYDRATION_WARNING$1 = 'suppressHydrationWarning';
}

var SUSPENSE_START_DATA = '$';
var SUSPENSE_END_DATA = '/$';
var SUSPENSE_PENDING_START_DATA = '$?';
var SUSPENSE_FALLBACK_START_DATA = '$!';
var STYLE$1 = 'style';
var eventsEnabled = null;
var selectionInformation = null;

function shouldAutoFocusHostComponent(type, props) {
  switch (type) {
    case 'button':
    case 'input':
    case 'select':
    case 'textarea':
      return !!props.autoFocus;
  }

  return false;
}
function getRootHostContext(rootContainerInstance) {
  var type;
  var namespace;
  var nodeType = rootContainerInstance.nodeType;

  switch (nodeType) {
    case DOCUMENT_NODE:
    case DOCUMENT_FRAGMENT_NODE:
      {
        type = nodeType === DOCUMENT_NODE ? '#document' : '#fragment';
        var root = rootContainerInstance.documentElement;
        namespace = root ? root.namespaceURI : getChildNamespace(null, '');
        break;
      }

    default:
      {
        var container = nodeType === COMMENT_NODE ? rootContainerInstance.parentNode : rootContainerInstance;
        var ownNamespace = container.namespaceURI || null;
        type = container.tagName;
        namespace = getChildNamespace(ownNamespace, type);
        break;
      }
  }

  {
    var validatedTag = type.toLowerCase();
    var ancestorInfo = updatedAncestorInfo(null, validatedTag);
    return {
      namespace: namespace,
      ancestorInfo: ancestorInfo
    };
  }
}
function getChildHostContext(parentHostContext, type, rootContainerInstance) {
  {
    var parentHostContextDev = parentHostContext;
    var namespace = getChildNamespace(parentHostContextDev.namespace, type);
    var ancestorInfo = updatedAncestorInfo(parentHostContextDev.ancestorInfo, type);
    return {
      namespace: namespace,
      ancestorInfo: ancestorInfo
    };
  }
}
function getPublicInstance(instance) {
  return instance;
}
function prepareForCommit(containerInfo) {
  eventsEnabled = isEnabled();
  selectionInformation = getSelectionInformation();
  var activeInstance = null;

  setEnabled(false);
  return activeInstance;
}
function resetAfterCommit(containerInfo) {
  restoreSelection(selectionInformation);
  setEnabled(eventsEnabled);
  eventsEnabled = null;
  selectionInformation = null;
}
function createInstance(type, props, rootContainerInstance, hostContext, internalInstanceHandle) {
  var parentNamespace;

  {
    // TODO: take namespace into account when validating.
    var hostContextDev = hostContext;
    validateDOMNesting(type, null, hostContextDev.ancestorInfo);

    if (typeof props.children === 'string' || typeof props.children === 'number') {
      var string = '' + props.children;
      var ownAncestorInfo = updatedAncestorInfo(hostContextDev.ancestorInfo, type);
      validateDOMNesting(null, string, ownAncestorInfo);
    }

    parentNamespace = hostContextDev.namespace;
  }

  var domElement = createElement(type, props, rootContainerInstance, parentNamespace);
  precacheFiberNode(internalInstanceHandle, domElement);
  updateFiberProps(domElement, props);
  return domElement;
}
function appendInitialChild(parentInstance, child) {
  parentInstance.appendChild(child);
}
function finalizeInitialChildren(domElement, type, props, rootContainerInstance, hostContext) {
  setInitialProperties(domElement, type, props, rootContainerInstance);
  return shouldAutoFocusHostComponent(type, props);
}
function prepareUpdate(domElement, type, oldProps, newProps, rootContainerInstance, hostContext) {
  {
    var hostContextDev = hostContext;

    if (typeof newProps.children !== typeof oldProps.children && (typeof newProps.children === 'string' || typeof newProps.children === 'number')) {
      var string = '' + newProps.children;
      var ownAncestorInfo = updatedAncestorInfo(hostContextDev.ancestorInfo, type);
      validateDOMNesting(null, string, ownAncestorInfo);
    }
  }

  return diffProperties(domElement, type, oldProps, newProps);
}
function shouldSetTextContent(type, props) {
  return type === 'textarea' || type === 'option' || type === 'noscript' || typeof props.children === 'string' || typeof props.children === 'number' || typeof props.dangerouslySetInnerHTML === 'object' && props.dangerouslySetInnerHTML !== null && props.dangerouslySetInnerHTML.__html != null;
}
function createTextInstance(text, rootContainerInstance, hostContext, internalInstanceHandle) {
  {
    var hostContextDev = hostContext;
    validateDOMNesting(null, text, hostContextDev.ancestorInfo);
  }

  var textNode = createTextNode(text, rootContainerInstance);
  precacheFiberNode(internalInstanceHandle, textNode);
  return textNode;
}
// if a component just imports ReactDOM (e.g. for findDOMNode).
// Some environments might not have setTimeout or clearTimeout.

var scheduleTimeout = typeof setTimeout === 'function' ? setTimeout : undefined;
var cancelTimeout = typeof clearTimeout === 'function' ? clearTimeout : undefined;
var noTimeout = -1; // -------------------
function commitMount(domElement, type, newProps, internalInstanceHandle) {
  // Despite the naming that might imply otherwise, this method only
  // fires if there is an `Update` effect scheduled during mounting.
  // This happens if `finalizeInitialChildren` returns `true` (which it
  // does to implement the `autoFocus` attribute on the client). But
  // there are also other cases when this might happen (such as patching
  // up text content during hydration mismatch). So we'll check this again.
  if (shouldAutoFocusHostComponent(type, newProps)) {
    domElement.focus();
  }
}
function commitUpdate(domElement, updatePayload, type, oldProps, newProps, internalInstanceHandle) {
  // Update the props handle so that we know which props are the ones with
  // with current event handlers.
  updateFiberProps(domElement, newProps); // Apply the diff to the DOM node.

  updateProperties(domElement, updatePayload, type, oldProps, newProps);
}
function resetTextContent(domElement) {
  setTextContent(domElement, '');
}
function commitTextUpdate(textInstance, oldText, newText) {
  textInstance.nodeValue = newText;
}
function appendChild(parentInstance, child) {
  parentInstance.appendChild(child);
}
function appendChildToContainer(container, child) {
  var parentNode;

  if (container.nodeType === COMMENT_NODE) {
    parentNode = container.parentNode;
    parentNode.insertBefore(child, container);
  } else {
    parentNode = container;
    parentNode.appendChild(child);
  } // This container might be used for a portal.
  // If something inside a portal is clicked, that click should bubble
  // through the React tree. However, on Mobile Safari the click would
  // never bubble through the *DOM* tree unless an ancestor with onclick
  // event exists. So we wouldn't see it and dispatch it.
  // This is why we ensure that non React root containers have inline onclick
  // defined.
  // https://github.com/facebook/react/issues/11918


  var reactRootContainer = container._reactRootContainer;

  if ((reactRootContainer === null || reactRootContainer === undefined) && parentNode.onclick === null) {
    // TODO: This cast may not be sound for SVG, MathML or custom elements.
    trapClickOnNonInteractiveElement(parentNode);
  }
}
function insertBefore(parentInstance, child, beforeChild) {
  parentInstance.insertBefore(child, beforeChild);
}
function insertInContainerBefore(container, child, beforeChild) {
  if (container.nodeType === COMMENT_NODE) {
    container.parentNode.insertBefore(child, beforeChild);
  } else {
    container.insertBefore(child, beforeChild);
  }
}

function removeChild(parentInstance, child) {
  parentInstance.removeChild(child);
}
function removeChildFromContainer(container, child) {
  if (container.nodeType === COMMENT_NODE) {
    container.parentNode.removeChild(child);
  } else {
    container.removeChild(child);
  }
}
function hideInstance(instance) {
  // TODO: Does this work for all element types? What about MathML? Should we
  // pass host context to this method?
  instance = instance;
  var style = instance.style;

  if (typeof style.setProperty === 'function') {
    style.setProperty('display', 'none', 'important');
  } else {
    style.display = 'none';
  }
}
function hideTextInstance(textInstance) {
  textInstance.nodeValue = '';
}
function unhideInstance(instance, props) {
  instance = instance;
  var styleProp = props[STYLE$1];
  var display = styleProp !== undefined && styleProp !== null && styleProp.hasOwnProperty('display') ? styleProp.display : null;
  instance.style.display = dangerousStyleValue('display', display);
}
function unhideTextInstance(textInstance, text) {
  textInstance.nodeValue = text;
}
function clearContainer(container) {
  if (container.nodeType === ELEMENT_NODE) {
    container.textContent = '';
  } else if (container.nodeType === DOCUMENT_NODE) {
    var body = container.body;

    if (body != null) {
      body.textContent = '';
    }
  }
} // -------------------
function canHydrateInstance(instance, type, props) {
  if (instance.nodeType !== ELEMENT_NODE || type.toLowerCase() !== instance.nodeName.toLowerCase()) {
    return null;
  } // This has now been refined to an element node.


  return instance;
}
function canHydrateTextInstance(instance, text) {
  if (text === '' || instance.nodeType !== TEXT_NODE) {
    // Empty strings are not parsed by HTML so there won't be a correct match here.
    return null;
  } // This has now been refined to a text node.


  return instance;
}
function isSuspenseInstancePending(instance) {
  return instance.data === SUSPENSE_PENDING_START_DATA;
}
function isSuspenseInstanceFallback(instance) {
  return instance.data === SUSPENSE_FALLBACK_START_DATA;
}

function getNextHydratable(node) {
  // Skip non-hydratable nodes.
  for (; node != null; node = node.nextSibling) {
    var nodeType = node.nodeType;

    if (nodeType === ELEMENT_NODE || nodeType === TEXT_NODE) {
      break;
    }
  }

  return node;
}

function getNextHydratableSibling(instance) {
  return getNextHydratable(instance.nextSibling);
}
function getFirstHydratableChild(parentInstance) {
  return getNextHydratable(parentInstance.firstChild);
}
function hydrateInstance(instance, type, props, rootContainerInstance, hostContext, internalInstanceHandle) {
  precacheFiberNode(internalInstanceHandle, instance); // TODO: Possibly defer this until the commit phase where all the events
  // get attached.

  updateFiberProps(instance, props);
  var parentNamespace;

  {
    var hostContextDev = hostContext;
    parentNamespace = hostContextDev.namespace;
  }

  return diffHydratedProperties(instance, type, props, parentNamespace);
}
function hydrateTextInstance(textInstance, text, internalInstanceHandle) {
  precacheFiberNode(internalInstanceHandle, textInstance);
  return diffHydratedText(textInstance, text);
}
function getNextHydratableInstanceAfterSuspenseInstance(suspenseInstance) {
  var node = suspenseInstance.nextSibling; // Skip past all nodes within this suspense boundary.
  // There might be nested nodes so we need to keep track of how
  // deep we are and only break out when we're back on top.

  var depth = 0;

  while (node) {
    if (node.nodeType === COMMENT_NODE) {
      var data = node.data;

      if (data === SUSPENSE_END_DATA) {
        if (depth === 0) {
          return getNextHydratableSibling(node);
        } else {
          depth--;
        }
      } else if (data === SUSPENSE_START_DATA || data === SUSPENSE_FALLBACK_START_DATA || data === SUSPENSE_PENDING_START_DATA) {
        depth++;
      }
    }

    node = node.nextSibling;
  } // TODO: Warn, we didn't find the end comment boundary.


  return null;
} // Returns the SuspenseInstance if this node is a direct child of a
// SuspenseInstance. I.e. if its previous sibling is a Comment with
// SUSPENSE_x_START_DATA. Otherwise, null.

function getParentSuspenseInstance(targetInstance) {
  var node = targetInstance.previousSibling; // Skip past all nodes within this suspense boundary.
  // There might be nested nodes so we need to keep track of how
  // deep we are and only break out when we're back on top.

  var depth = 0;

  while (node) {
    if (node.nodeType === COMMENT_NODE) {
      var data = node.data;

      if (data === SUSPENSE_START_DATA || data === SUSPENSE_FALLBACK_START_DATA || data === SUSPENSE_PENDING_START_DATA) {
        if (depth === 0) {
          return node;
        } else {
          depth--;
        }
      } else if (data === SUSPENSE_END_DATA) {
        depth++;
      }
    }

    node = node.previousSibling;
  }

  return null;
}
function commitHydratedContainer(container) {
  // Retry if any event replaying was blocked on this.
  retryIfBlockedOn(container);
}
function commitHydratedSuspenseInstance(suspenseInstance) {
  // Retry if any event replaying was blocked on this.
  retryIfBlockedOn(suspenseInstance);
}
function didNotMatchHydratedContainerTextInstance(parentContainer, textInstance, text) {
  {
    warnForUnmatchedText(textInstance, text);
  }
}
function didNotMatchHydratedTextInstance(parentType, parentProps, parentInstance, textInstance, text) {
  if ( parentProps[SUPPRESS_HYDRATION_WARNING$1] !== true) {
    warnForUnmatchedText(textInstance, text);
  }
}
function didNotHydrateContainerInstance(parentContainer, instance) {
  {
    if (instance.nodeType === ELEMENT_NODE) {
      warnForDeletedHydratableElement(parentContainer, instance);
    } else if (instance.nodeType === COMMENT_NODE) ; else {
      warnForDeletedHydratableText(parentContainer, instance);
    }
  }
}
function didNotHydrateInstance(parentType, parentProps, parentInstance, instance) {
  if ( parentProps[SUPPRESS_HYDRATION_WARNING$1] !== true) {
    if (instance.nodeType === ELEMENT_NODE) {
      warnForDeletedHydratableElement(parentInstance, instance);
    } else if (instance.nodeType === COMMENT_NODE) ; else {
      warnForDeletedHydratableText(parentInstance, instance);
    }
  }
}
function didNotFindHydratableContainerInstance(parentContainer, type, props) {
  {
    warnForInsertedHydratedElement(parentContainer, type);
  }
}
function didNotFindHydratableContainerTextInstance(parentContainer, text) {
  {
    warnForInsertedHydratedText(parentContainer, text);
  }
}
function didNotFindHydratableInstance(parentType, parentProps, parentInstance, type, props) {
  if ( parentProps[SUPPRESS_HYDRATION_WARNING$1] !== true) {
    warnForInsertedHydratedElement(parentInstance, type);
  }
}
function didNotFindHydratableTextInstance(parentType, parentProps, parentInstance, text) {
  if ( parentProps[SUPPRESS_HYDRATION_WARNING$1] !== true) {
    warnForInsertedHydratedText(parentInstance, text);
  }
}
function didNotFindHydratableSuspenseInstance(parentType, parentProps, parentInstance) {
  if ( parentProps[SUPPRESS_HYDRATION_WARNING$1] !== true) ;
}
var clientId = 0;
function makeClientIdInDEV(warnOnAccessInDEV) {
  var id = 'r:' + (clientId++).toString(36);
  return {
    toString: function () {
      warnOnAccessInDEV();
      return id;
    },
    valueOf: function () {
      warnOnAccessInDEV();
      return id;
    }
  };
}
function isOpaqueHydratingObject(value) {
  return value !== null && typeof value === 'object' && value.$$typeof === REACT_OPAQUE_ID_TYPE;
}
function makeOpaqueHydratingObject(attemptToReadValue) {
  return {
    $$typeof: REACT_OPAQUE_ID_TYPE,
    toString: attemptToReadValue,
    valueOf: attemptToReadValue
  };
}
function preparePortalMount(portalInstance) {
  {
    listenToAllSupportedEvents(portalInstance);
  }
}

var randomKey = Math.random().toString(36).slice(2);
var internalInstanceKey = '__reactFiber$' + randomKey;
var internalPropsKey = '__reactProps$' + randomKey;
var internalContainerInstanceKey = '__reactContainer$' + randomKey;
var internalEventHandlersKey = '__reactEvents$' + randomKey;
function precacheFiberNode(hostInst, node) {
  node[internalInstanceKey] = hostInst;
}
function markContainerAsRoot(hostRoot, node) {
  node[internalContainerInstanceKey] = hostRoot;
}
function unmarkContainerAsRoot(node) {
  node[internalContainerInstanceKey] = null;
}
function isContainerMarkedAsRoot(node) {
  return !!node[internalContainerInstanceKey];
} // Given a DOM node, return the closest HostComponent or HostText fiber ancestor.
// If the target node is part of a hydrated or not yet rendered subtree, then
// this may also return a SuspenseComponent or HostRoot to indicate that.
// Conceptually the HostRoot fiber is a child of the Container node. So if you
// pass the Container node as the targetNode, you will not actually get the
// HostRoot back. To get to the HostRoot, you need to pass a child of it.
// The same thing applies to Suspense boundaries.

function getClosestInstanceFromNode(targetNode) {
  var targetInst = targetNode[internalInstanceKey];

  if (targetInst) {
    // Don't return HostRoot or SuspenseComponent here.
    return targetInst;
  } // If the direct event target isn't a React owned DOM node, we need to look
  // to see if one of its parents is a React owned DOM node.


  var parentNode = targetNode.parentNode;

  while (parentNode) {
    // We'll check if this is a container root that could include
    // React nodes in the future. We need to check this first because
    // if we're a child of a dehydrated container, we need to first
    // find that inner container before moving on to finding the parent
    // instance. Note that we don't check this field on  the targetNode
    // itself because the fibers are conceptually between the container
    // node and the first child. It isn't surrounding the container node.
    // If it's not a container, we check if it's an instance.
    targetInst = parentNode[internalContainerInstanceKey] || parentNode[internalInstanceKey];

    if (targetInst) {
      // Since this wasn't the direct target of the event, we might have
      // stepped past dehydrated DOM nodes to get here. However they could
      // also have been non-React nodes. We need to answer which one.
      // If we the instance doesn't have any children, then there can't be
      // a nested suspense boundary within it. So we can use this as a fast
      // bailout. Most of the time, when people add non-React children to
      // the tree, it is using a ref to a child-less DOM node.
      // Normally we'd only need to check one of the fibers because if it
      // has ever gone from having children to deleting them or vice versa
      // it would have deleted the dehydrated boundary nested inside already.
      // However, since the HostRoot starts out with an alternate it might
      // have one on the alternate so we need to check in case this was a
      // root.
      var alternate = targetInst.alternate;

      if (targetInst.child !== null || alternate !== null && alternate.child !== null) {
        // Next we need to figure out if the node that skipped past is
        // nested within a dehydrated boundary and if so, which one.
        var suspenseInstance = getParentSuspenseInstance(targetNode);

        while (suspenseInstance !== null) {
          // We found a suspense instance. That means that we haven't
          // hydrated it yet. Even though we leave the comments in the
          // DOM after hydrating, and there are boundaries in the DOM
          // that could already be hydrated, we wouldn't have found them
          // through this pass since if the target is hydrated it would
          // have had an internalInstanceKey on it.
          // Let's get the fiber associated with the SuspenseComponent
          // as the deepest instance.
          var targetSuspenseInst = suspenseInstance[internalInstanceKey];

          if (targetSuspenseInst) {
            return targetSuspenseInst;
          } // If we don't find a Fiber on the comment, it might be because
          // we haven't gotten to hydrate it yet. There might still be a
          // parent boundary that hasn't above this one so we need to find
          // the outer most that is known.


          suspenseInstance = getParentSuspenseInstance(suspenseInstance); // If we don't find one, then that should mean that the parent
          // host component also hasn't hydrated yet. We can return it
          // below since it will bail out on the isMounted check later.
        }
      }

      return targetInst;
    }

    targetNode = parentNode;
    parentNode = targetNode.parentNode;
  }

  return null;
}
/**
 * Given a DOM node, return the ReactDOMComponent or ReactDOMTextComponent
 * instance, or null if the node was not rendered by this React.
 */

function getInstanceFromNode(node) {
  var inst = node[internalInstanceKey] || node[internalContainerInstanceKey];

  if (inst) {
    if (inst.tag === HostComponent || inst.tag === HostText || inst.tag === SuspenseComponent || inst.tag === HostRoot) {
      return inst;
    } else {
      return null;
    }
  }

  return null;
}
/**
 * Given a ReactDOMComponent or ReactDOMTextComponent, return the corresponding
 * DOM node.
 */

function getNodeFromInstance(inst) {
  if (inst.tag === HostComponent || inst.tag === HostText) {
    // In Fiber this, is just the state node right now. We assume it will be
    // a host component or host text.
    return inst.stateNode;
  } // Without this first invariant, passing a non-DOM-component triggers the next
  // invariant for a missing parent, which is super confusing.


  {
    {
      throw Error( "getNodeFromInstance: Invalid argument." );
    }
  }
}
function getFiberCurrentPropsFromNode(node) {
  return node[internalPropsKey] || null;
}
function updateFiberProps(node, props) {
  node[internalPropsKey] = props;
}
function getEventListenerSet(node) {
  var elementListenerSet = node[internalEventHandlersKey];

  if (elementListenerSet === undefined) {
    elementListenerSet = node[internalEventHandlersKey] = new Set();
  }

  return elementListenerSet;
}

var loggedTypeFailures = {};
var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;

function setCurrentlyValidatingElement(element) {
  {
    if (element) {
      var owner = element._owner;
      var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
      ReactDebugCurrentFrame$1.setExtraStackFrame(stack);
    } else {
      ReactDebugCurrentFrame$1.setExtraStackFrame(null);
    }
  }
}

function checkPropTypes(typeSpecs, values, location, componentName, element) {
  {
    // $FlowFixMe This is okay but Flow doesn't know it.
    var has = Function.call.bind(Object.prototype.hasOwnProperty);

    for (var typeSpecName in typeSpecs) {
      if (has(typeSpecs, typeSpecName)) {
        var error$1 = void 0; // Prop type validation may throw. In case they do, we don't want to
        // fail the render phase where it didn't fail before. So we log it.
        // After these have been cleaned up, we'll let them throw.

        try {
          // This is intentionally an invariant that gets caught. It's the same
          // behavior as without this statement except with a better message.
          if (typeof typeSpecs[typeSpecName] !== 'function') {
            var err = Error((componentName || 'React class') + ': ' + location + ' type `' + typeSpecName + '` is invalid; ' + 'it must be a function, usually from the `prop-types` package, but received `' + typeof typeSpecs[typeSpecName] + '`.' + 'This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.');
            err.name = 'Invariant Violation';
            throw err;
          }

          error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED');
        } catch (ex) {
          error$1 = ex;
        }

        if (error$1 && !(error$1 instanceof Error)) {
          setCurrentlyValidatingElement(element);

          error('%s: type specification of %s' + ' `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', location, typeSpecName, typeof error$1);

          setCurrentlyValidatingElement(null);
        }

        if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {
          // Only monitor this failure once because there tends to be a lot of the
          // same error.
          loggedTypeFailures[error$1.message] = true;
          setCurrentlyValidatingElement(element);

          error('Failed %s type: %s', location, error$1.message);

          setCurrentlyValidatingElement(null);
        }
      }
    }
  }
}

var valueStack = [];
var fiberStack;

{
  fiberStack = [];
}

var index = -1;

function createCursor(defaultValue) {
  return {
    current: defaultValue
  };
}

function pop(cursor, fiber) {
  if (index < 0) {
    {
      error('Unexpected pop.');
    }

    return;
  }

  {
    if (fiber !== fiberStack[index]) {
      error('Unexpected Fiber popped.');
    }
  }

  cursor.current = valueStack[index];
  valueStack[index] = null;

  {
    fiberStack[index] = null;
  }

  index--;
}

function push(cursor, value, fiber) {
  index++;
  valueStack[index] = cursor.current;

  {
    fiberStack[index] = fiber;
  }

  cursor.current = value;
}

var warnedAboutMissingGetChildContext;

{
  warnedAboutMissingGetChildContext = {};
}

var emptyContextObject = {};

{
  Object.freeze(emptyContextObject);
} // A cursor to the current merged context object on the stack.


var contextStackCursor = createCursor(emptyContextObject); // A cursor to a boolean indicating whether the context has changed.

var didPerformWorkStackCursor = createCursor(false); // Keep track of the previous context object that was on the stack.
// We use this to get access to the parent context after we have already
// pushed the next context provider, and now need to merge their contexts.

var previousContext = emptyContextObject;

function getUnmaskedContext(workInProgress, Component, didPushOwnContextIfProvider) {
  {
    if (didPushOwnContextIfProvider && isContextProvider(Component)) {
      // If the fiber is a context provider itself, when we read its context
      // we may have already pushed its own child context on the stack. A context
      // provider should not "see" its own child context. Therefore we read the
      // previous (parent) context instead for a context provider.
      return previousContext;
    }

    return contextStackCursor.current;
  }
}

function cacheContext(workInProgress, unmaskedContext, maskedContext) {
  {
    var instance = workInProgress.stateNode;
    instance.__reactInternalMemoizedUnmaskedChildContext = unmaskedContext;
    instance.__reactInternalMemoizedMaskedChildContext = maskedContext;
  }
}

function getMaskedContext(workInProgress, unmaskedContext) {
  {
    var type = workInProgress.type;
    var contextTypes = type.contextTypes;

    if (!contextTypes) {
      return emptyContextObject;
    } // Avoid recreating masked context unless unmasked context has changed.
    // Failing to do this will result in unnecessary calls to componentWillReceiveProps.
    // This may trigger infinite loops if componentWillReceiveProps calls setState.


    var instance = workInProgress.stateNode;

    if (instance && instance.__reactInternalMemoizedUnmaskedChildContext === unmaskedContext) {
      return instance.__reactInternalMemoizedMaskedChildContext;
    }

    var context = {};

    for (var key in contextTypes) {
      context[key] = unmaskedContext[key];
    }

    {
      var name = getComponentName(type) || 'Unknown';
      checkPropTypes(contextTypes, context, 'context', name);
    } // Cache unmasked context so we can avoid recreating masked context unless necessary.
    // Context is created before the class component is instantiated so check for instance.


    if (instance) {
      cacheContext(workInProgress, unmaskedContext, context);
    }

    return context;
  }
}

function hasContextChanged() {
  {
    return didPerformWorkStackCursor.current;
  }
}

function isContextProvider(type) {
  {
    var childContextTypes = type.childContextTypes;
    return childContextTypes !== null && childContextTypes !== undefined;
  }
}

function popContext(fiber) {
  {
    pop(didPerformWorkStackCursor, fiber);
    pop(contextStackCursor, fiber);
  }
}

function popTopLevelContextObject(fiber) {
  {
    pop(didPerformWorkStackCursor, fiber);
    pop(contextStackCursor, fiber);
  }
}

function pushTopLevelContextObject(fiber, context, didChange) {
  {
    if (!(contextStackCursor.current === emptyContextObject)) {
      {
        throw Error( "Unexpected context found on stack. This error is likely caused by a bug in React. Please file an issue." );
      }
    }

    push(contextStackCursor, context, fiber);
    push(didPerformWorkStackCursor, didChange, fiber);
  }
}

function processChildContext(fiber, type, parentContext) {
  {
    var instance = fiber.stateNode;
    var childContextTypes = type.childContextTypes; // TODO (bvaughn) Replace this behavior with an invariant() in the future.
    // It has only been added in Fiber to match the (unintentional) behavior in Stack.

    if (typeof instance.getChildContext !== 'function') {
      {
        var componentName = getComponentName(type) || 'Unknown';

        if (!warnedAboutMissingGetChildContext[componentName]) {
          warnedAboutMissingGetChildContext[componentName] = true;

          error('%s.childContextTypes is specified but there is no getChildContext() method ' + 'on the instance. You can either define getChildContext() on %s or remove ' + 'childContextTypes from it.', componentName, componentName);
        }
      }

      return parentContext;
    }

    var childContext = instance.getChildContext();

    for (var contextKey in childContext) {
      if (!(contextKey in childContextTypes)) {
        {
          throw Error( (getComponentName(type) || 'Unknown') + ".getChildContext(): key \"" + contextKey + "\" is not defined in childContextTypes." );
        }
      }
    }

    {
      var name = getComponentName(type) || 'Unknown';
      checkPropTypes(childContextTypes, childContext, 'child context', name);
    }

    return _assign({}, parentContext, childContext);
  }
}

function pushContextProvider(workInProgress) {
  {
    var instance = workInProgress.stateNode; // We push the context as early as possible to ensure stack integrity.
    // If the instance does not exist yet, we will push null at first,
    // and replace it on the stack later when invalidating the context.

    var memoizedMergedChildContext = instance && instance.__reactInternalMemoizedMergedChildContext || emptyContextObject; // Remember the parent context so we can merge with it later.
    // Inherit the parent's did-perform-work value to avoid inadvertently blocking updates.

    previousContext = contextStackCursor.current;
    push(contextStackCursor, memoizedMergedChildContext, workInProgress);
    push(didPerformWorkStackCursor, didPerformWorkStackCursor.current, workInProgress);
    return true;
  }
}

function invalidateContextProvider(workInProgress, type, didChange) {
  {
    var instance = workInProgress.stateNode;

    if (!instance) {
      {
        throw Error( "Expected to have an instance by this point. This error is likely caused by a bug in React. Please file an issue." );
      }
    }

    if (didChange) {
      // Merge parent and own context.
      // Skip this if we're not updating due to sCU.
      // This avoids unnecessarily recomputing memoized values.
      var mergedContext = processChildContext(workInProgress, type, previousContext);
      instance.__reactInternalMemoizedMergedChildContext = mergedContext; // Replace the old (or empty) context with the new one.
      // It is important to unwind the context in the reverse order.

      pop(didPerformWorkStackCursor, workInProgress);
      pop(contextStackCursor, workInProgress); // Now push the new context and mark that it has changed.

      push(contextStackCursor, mergedContext, workInProgress);
      push(didPerformWorkStackCursor, didChange, workInProgress);
    } else {
      pop(didPerformWorkStackCursor, workInProgress);
      push(didPerformWorkStackCursor, didChange, workInProgress);
    }
  }
}

function findCurrentUnmaskedContext(fiber) {
  {
    // Currently this is only used with renderSubtreeIntoContainer; not sure if it
    // makes sense elsewhere
    if (!(isFiberMounted(fiber) && fiber.tag === ClassComponent)) {
      {
        throw Error( "Expected subtree parent to be a mounted class component. This error is likely caused by a bug in React. Please file an issue." );
      }
    }

    var node = fiber;

    do {
      switch (node.tag) {
        case HostRoot:
          return node.stateNode.context;

        case ClassComponent:
          {
            var Component = node.type;

            if (isContextProvider(Component)) {
              return node.stateNode.__reactInternalMemoizedMergedChildContext;
            }

            break;
          }
      }

      node = node.return;
    } while (node !== null);

    {
      {
        throw Error( "Found unexpected detached subtree parent. This error is likely caused by a bug in React. Please file an issue." );
      }
    }
  }
}

var LegacyRoot = 0;
var BlockingRoot = 1;
var ConcurrentRoot = 2;

var rendererID = null;
var injectedHook = null;
var hasLoggedError = false;
var isDevToolsPresent = typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined';
function injectInternals(internals) {
  if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === 'undefined') {
    // No DevTools
    return false;
  }

  var hook = __REACT_DEVTOOLS_GLOBAL_HOOK__;

  if (hook.isDisabled) {
    // This isn't a real property on the hook, but it can be set to opt out
    // of DevTools integration and associated warnings and logs.
    // https://github.com/facebook/react/issues/3877
    return true;
  }

  if (!hook.supportsFiber) {
    {
      error('The installed version of React DevTools is too old and will not work ' + 'with the current version of React. Please update React DevTools. ' + 'https://reactjs.org/link/react-devtools');
    } // DevTools exists, even though it doesn't support Fiber.


    return true;
  }

  try {
    rendererID = hook.inject(internals); // We have successfully injected, so now it is safe to set up hooks.

    injectedHook = hook;
  } catch (err) {
    // Catch all errors because it is unsafe to throw during initialization.
    {
      error('React instrumentation encountered an error: %s.', err);
    }
  } // DevTools exists


  return true;
}
function onScheduleRoot(root, children) {
  {
    if (injectedHook && typeof injectedHook.onScheduleFiberRoot === 'function') {
      try {
        injectedHook.onScheduleFiberRoot(rendererID, root, children);
      } catch (err) {
        if ( !hasLoggedError) {
          hasLoggedError = true;

          error('React instrumentation encountered an error: %s', err);
        }
      }
    }
  }
}
function onCommitRoot(root, priorityLevel) {
  if (injectedHook && typeof injectedHook.onCommitFiberRoot === 'function') {
    try {
      var didError = (root.current.flags & DidCapture) === DidCapture;

      if (enableProfilerTimer) {
        injectedHook.onCommitFiberRoot(rendererID, root, priorityLevel, didError);
      } else {
        injectedHook.onCommitFiberRoot(rendererID, root, undefined, didError);
      }
    } catch (err) {
      {
        if (!hasLoggedError) {
          hasLoggedError = true;

          error('React instrumentation encountered an error: %s', err);
        }
      }
    }
  }
}
function onCommitUnmount(fiber) {
  if (injectedHook && typeof injectedHook.onCommitFiberUnmount === 'function') {
    try {
      injectedHook.onCommitFiberUnmount(rendererID, fiber);
    } catch (err) {
      {
        if (!hasLoggedError) {
          hasLoggedError = true;

          error('React instrumentation encountered an error: %s', err);
        }
      }
    }
  }
}

var Scheduler_runWithPriority = Scheduler.unstable_runWithPriority,
    Scheduler_scheduleCallback = Scheduler.unstable_scheduleCallback,
    Scheduler_cancelCallback = Scheduler.unstable_cancelCallback,
    Scheduler_shouldYield = Scheduler.unstable_shouldYield,
    Scheduler_requestPaint = Scheduler.unstable_requestPaint,
    Scheduler_now$1 = Scheduler.unstable_now,
    Scheduler_getCurrentPriorityLevel = Scheduler.unstable_getCurrentPriorityLevel,
    Scheduler_ImmediatePriority = Scheduler.unstable_ImmediatePriority,
    Scheduler_UserBlockingPriority = Scheduler.unstable_UserBlockingPriority,
    Scheduler_NormalPriority = Scheduler.unstable_NormalPriority,
    Scheduler_LowPriority = Scheduler.unstable_LowPriority,
    Scheduler_IdlePriority = Scheduler.unstable_IdlePriority;

{
  // Provide explicit error message when production+profiling bundle of e.g.
  // react-dom is used with production (non-profiling) bundle of
  // scheduler/tracing
  if (!(tracing.__interactionsRef != null && tracing.__interactionsRef.current != null)) {
    {
      throw Error( "It is not supported to run the profiling version of a renderer (for example, `react-dom/profiling`) without also replacing the `scheduler/tracing` module with `scheduler/tracing-profiling`. Your bundler might have a setting for aliasing both modules. Learn more at https://reactjs.org/link/profiling" );
    }
  }
}

var fakeCallbackNode = {}; // Except for NoPriority, these correspond to Scheduler priorities. We use
// ascending numbers so we can compare them like numbers. They start at 90 to
// avoid clashing with Scheduler's priorities.

var ImmediatePriority$1 = 99;
var UserBlockingPriority$2 = 98;
var NormalPriority$1 = 97;
var LowPriority$1 = 96;
var IdlePriority$1 = 95; // NoPriority is the absence of priority. Also React-only.

var NoPriority$1 = 90;
var shouldYield = Scheduler_shouldYield;
var requestPaint = // Fall back gracefully if we're running an older version of Scheduler.
Scheduler_requestPaint !== undefined ? Scheduler_requestPaint : function () {};
var syncQueue = null;
var immediateQueueCallbackNode = null;
var isFlushingSyncQueue = false;
var initialTimeMs$1 = Scheduler_now$1(); // If the initial timestamp is reasonably small, use Scheduler's `now` directly.
// This will be the case for modern browsers that support `performance.now`. In
// older browsers, Scheduler falls back to `Date.now`, which returns a Unix
// timestamp. In that case, subtract the module initialization time to simulate
// the behavior of performance.now and keep our times small enough to fit
// within 32 bits.
// TODO: Consider lifting this into Scheduler.

var now = initialTimeMs$1 < 10000 ? Scheduler_now$1 : function () {
  return Scheduler_now$1() - initialTimeMs$1;
};
function getCurrentPriorityLevel() {
  switch (Scheduler_getCurrentPriorityLevel()) {
    case Scheduler_ImmediatePriority:
      return ImmediatePriority$1;

    case Scheduler_UserBlockingPriority:
      return UserBlockingPriority$2;

    case Scheduler_NormalPriority:
      return NormalPriority$1;

    case Scheduler_LowPriority:
      return LowPriority$1;

    case Scheduler_IdlePriority:
      return IdlePriority$1;

    default:
      {
        {
          throw Error( "Unknown priority level." );
        }
      }

  }
}

function reactPriorityToSchedulerPriority(reactPriorityLevel) {
  switch (reactPriorityLevel) {
    case ImmediatePriority$1:
      return Scheduler_ImmediatePriority;

    case UserBlockingPriority$2:
      return Scheduler_UserBlockingPriority;

    case NormalPriority$1:
      return Scheduler_NormalPriority;

    case LowPriority$1:
      return Scheduler_LowPriority;

    case IdlePriority$1:
      return Scheduler_IdlePriority;

    default:
      {
        {
          throw Error( "Unknown priority level." );
        }
      }

  }
}

function runWithPriority$1(reactPriorityLevel, fn) {
  var priorityLevel = reactPriorityToSchedulerPriority(reactPriorityLevel);
  return Scheduler_runWithPriority(priorityLevel, fn);
}
function scheduleCallback(reactPriorityLevel, callback, options) {
  var priorityLevel = reactPriorityToSchedulerPriority(reactPriorityLevel);
  return Scheduler_scheduleCallback(priorityLevel, callback, options);
}
function scheduleSyncCallback(callback) {
  // Push this callback into an internal queue. We'll flush these either in
  // the next tick, or earlier if something calls `flushSyncCallbackQueue`.
  if (syncQueue === null) {
    syncQueue = [callback]; // Flush the queue in the next tick, at the earliest.

    immediateQueueCallbackNode = Scheduler_scheduleCallback(Scheduler_ImmediatePriority, flushSyncCallbackQueueImpl);
  } else {
    // Push onto existing queue. Don't need to schedule a callback because
    // we already scheduled one when we created the queue.
    syncQueue.push(callback);
  }

  return fakeCallbackNode;
}
function cancelCallback(callbackNode) {
  if (callbackNode !== fakeCallbackNode) {
    Scheduler_cancelCallback(callbackNode);
  }
}
function flushSyncCallbackQueue() {
  if (immediateQueueCallbackNode !== null) {
    var node = immediateQueueCallbackNode;
    immediateQueueCallbackNode = null;
    Scheduler_cancelCallback(node);
  }

  flushSyncCallbackQueueImpl();
}

function flushSyncCallbackQueueImpl() {
  if (!isFlushingSyncQueue && syncQueue !== null) {
    // Prevent re-entrancy.
    isFlushingSyncQueue = true;
    var i = 0;

    {
      try {
        var _isSync2 = true;
        var _queue = syncQueue;
        runWithPriority$1(ImmediatePriority$1, function () {
          for (; i < _queue.length; i++) {
            var callback = _queue[i];

            do {
              callback = callback(_isSync2);
            } while (callback !== null);
          }
        });
        syncQueue = null;
      } catch (error) {
        // If something throws, leave the remaining callbacks on the queue.
        if (syncQueue !== null) {
          syncQueue = syncQueue.slice(i + 1);
        } // Resume flushing in the next tick


        Scheduler_scheduleCallback(Scheduler_ImmediatePriority, flushSyncCallbackQueue);
        throw error;
      } finally {
        isFlushingSyncQueue = false;
      }
    }
  }
}

// TODO: this is special because it gets imported during build.
var ReactVersion = '17.0.2';

var NoMode = 0;
var StrictMode = 1; // TODO: Remove BlockingMode and ConcurrentMode by reading from the root
// tag instead

var BlockingMode = 2;
var ConcurrentMode = 4;
var ProfileMode = 8;
var DebugTracingMode = 16;

var ReactCurrentBatchConfig = ReactSharedInternals.ReactCurrentBatchConfig;
var NoTransition = 0;
function requestCurrentTransition() {
  return ReactCurrentBatchConfig.transition;
}

var ReactStrictModeWarnings = {
  recordUnsafeLifecycleWarnings: function (fiber, instance) {},
  flushPendingUnsafeLifecycleWarnings: function () {},
  recordLegacyContextWarning: function (fiber, instance) {},
  flushLegacyContextWarning: function () {},
  discardPendingWarnings: function () {}
};

{
  var findStrictRoot = function (fiber) {
    var maybeStrictRoot = null;
    var node = fiber;

    while (node !== null) {
      if (node.mode & StrictMode) {
        maybeStrictRoot = node;
      }

      node = node.return;
    }

    return maybeStrictRoot;
  };

  var setToSortedString = function (set) {
    var array = [];
    set.forEach(function (value) {
      array.push(value);
    });
    return array.sort().join(', ');
  };

  var pendingComponentWillMountWarnings = [];
  var pendingUNSAFE_ComponentWillMountWarnings = [];
  var pendingComponentWillReceivePropsWarnings = [];
  var pendingUNSAFE_ComponentWillReceivePropsWarnings = [];
  var pendingComponentWillUpdateWarnings = [];
  var pendingUNSAFE_ComponentWillUpdateWarnings = []; // Tracks components we have already warned about.

  var didWarnAboutUnsafeLifecycles = new Set();

  ReactStrictModeWarnings.recordUnsafeLifecycleWarnings = function (fiber, instance) {
    // Dedup strategy: Warn once per component.
    if (didWarnAboutUnsafeLifecycles.has(fiber.type)) {
      return;
    }

    if (typeof instance.componentWillMount === 'function' && // Don't warn about react-lifecycles-compat polyfilled components.
    instance.componentWillMount.__suppressDeprecationWarning !== true) {
      pendingComponentWillMountWarnings.push(fiber);
    }

    if (fiber.mode & StrictMode && typeof instance.UNSAFE_componentWillMount === 'function') {
      pendingUNSAFE_ComponentWillMountWarnings.push(fiber);
    }

    if (typeof instance.componentWillReceiveProps === 'function' && instance.componentWillReceiveProps.__suppressDeprecationWarning !== true) {
      pendingComponentWillReceivePropsWarnings.push(fiber);
    }

    if (fiber.mode & StrictMode && typeof instance.UNSAFE_componentWillReceiveProps === 'function') {
      pendingUNSAFE_ComponentWillReceivePropsWarnings.push(fiber);
    }

    if (typeof instance.componentWillUpdate === 'function' && instance.componentWillUpdate.__suppressDeprecationWarning !== true) {
      pendingComponentWillUpdateWarnings.push(fiber);
    }

    if (fiber.mode & StrictMode && typeof instance.UNSAFE_componentWillUpdate === 'function') {
      pendingUNSAFE_ComponentWillUpdateWarnings.push(fiber);
    }
  };

  ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings = function () {
    // We do an initial pass to gather component names
    var componentWillMountUniqueNames = new Set();

    if (pendingComponentWillMountWarnings.length > 0) {
      pendingComponentWillMountWarnings.forEach(function (fiber) {
        componentWillMountUniqueNames.add(getComponentName(fiber.type) || 'Component');
        didWarnAboutUnsafeLifecycles.add(fiber.type);
      });
      pendingComponentWillMountWarnings = [];
    }

    var UNSAFE_componentWillMountUniqueNames = new Set();

    if (pendingUNSAFE_ComponentWillMountWarnings.length > 0) {
      pendingUNSAFE_ComponentWillMountWarnings.forEach(function (fiber) {
        UNSAFE_componentWillMountUniqueNames.add(getComponentName(fiber.type) || 'Component');
        didWarnAboutUnsafeLifecycles.add(fiber.type);
      });
      pendingUNSAFE_ComponentWillMountWarnings = [];
    }

    var componentWillReceivePropsUniqueNames = new Set();

    if (pendingComponentWillReceivePropsWarnings.length > 0) {
      pendingComponentWillReceivePropsWarnings.forEach(function (fiber) {
        componentWillReceivePropsUniqueNames.add(getComponentName(fiber.type) || 'Component');
        didWarnAboutUnsafeLifecycles.add(fiber.type);
      });
      pendingComponentWillReceivePropsWarnings = [];
    }

    var UNSAFE_componentWillReceivePropsUniqueNames = new Set();

    if (pendingUNSAFE_ComponentWillReceivePropsWarnings.length > 0) {
      pendingUNSAFE_ComponentWillReceivePropsWarnings.forEach(function (fiber) {
        UNSAFE_componentWillReceivePropsUniqueNames.add(getComponentName(fiber.type) || 'Component');
        didWarnAboutUnsafeLifecycles.add(fiber.type);
      });
      pendingUNSAFE_ComponentWillReceivePropsWarnings = [];
    }

    var componentWillUpdateUniqueNames = new Set();

    if (pendingComponentWillUpdateWarnings.length > 0) {
      pendingComponentWillUpdateWarnings.forEach(function (fiber) {
        componentWillUpdateUniqueNames.add(getComponentName(fiber.type) || 'Component');
        didWarnAboutUnsafeLifecycles.add(fiber.type);
      });
      pendingComponentWillUpdateWarnings = [];
    }

    var UNSAFE_componentWillUpdateUniqueNames = new Set();

    if (pendingUNSAFE_ComponentWillUpdateWarnings.length > 0) {
      pendingUNSAFE_ComponentWillUpdateWarnings.forEach(function (fiber) {
        UNSAFE_componentWillUpdateUniqueNames.add(getComponentName(fiber.type) || 'Component');
        didWarnAboutUnsafeLifecycles.add(fiber.type);
      });
      pendingUNSAFE_ComponentWillUpdateWarnings = [];
    } // Finally, we flush all the warnings
    // UNSAFE_ ones before the deprecated ones, since they'll be 'louder'


    if (UNSAFE_componentWillMountUniqueNames.size > 0) {
      var sortedNames = setToSortedString(UNSAFE_componentWillMountUniqueNames);

      error('Using UNSAFE_componentWillMount in strict mode is not recommended and may indicate bugs in your code. ' + 'See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n' + '* Move code with side effects to componentDidMount, and set initial state in the constructor.\n' + '\nPlease update the following components: %s', sortedNames);
    }

    if (UNSAFE_componentWillReceivePropsUniqueNames.size > 0) {
      var _sortedNames = setToSortedString(UNSAFE_componentWillReceivePropsUniqueNames);

      error('Using UNSAFE_componentWillReceiveProps in strict mode is not recommended ' + 'and may indicate bugs in your code. ' + 'See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n' + '* Move data fetching code or side effects to componentDidUpdate.\n' + "* If you're updating state whenever props change, " + 'refactor your code to use memoization techniques or move it to ' + 'static getDerivedStateFromProps. Learn more at: https://reactjs.org/link/derived-state\n' + '\nPlease update the following components: %s', _sortedNames);
    }

    if (UNSAFE_componentWillUpdateUniqueNames.size > 0) {
      var _sortedNames2 = setToSortedString(UNSAFE_componentWillUpdateUniqueNames);

      error('Using UNSAFE_componentWillUpdate in strict mode is not recommended ' + 'and may indicate bugs in your code. ' + 'See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n' + '* Move data fetching code or side effects to componentDidUpdate.\n' + '\nPlease update the following components: %s', _sortedNames2);
    }

    if (componentWillMountUniqueNames.size > 0) {
      var _sortedNames3 = setToSortedString(componentWillMountUniqueNames);

      warn('componentWillMount has been renamed, and is not recommended for use. ' + 'See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n' + '* Move code with side effects to componentDidMount, and set initial state in the constructor.\n' + '* Rename componentWillMount to UNSAFE_componentWillMount to suppress ' + 'this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. ' + 'To rename all deprecated lifecycles to their new names, you can run ' + '`npx react-codemod rename-unsafe-lifecycles` in your project source folder.\n' + '\nPlease update the following components: %s', _sortedNames3);
    }

    if (componentWillReceivePropsUniqueNames.size > 0) {
      var _sortedNames4 = setToSortedString(componentWillReceivePropsUniqueNames);

      warn('componentWillReceiveProps has been renamed, and is not recommended for use. ' + 'See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n' + '* Move data fetching code or side effects to componentDidUpdate.\n' + "* If you're updating state whenever props change, refactor your " + 'code to use memoization techniques or move it to ' + 'static getDerivedStateFromProps. Learn more at: https://reactjs.org/link/derived-state\n' + '* Rename componentWillReceiveProps to UNSAFE_componentWillReceiveProps to suppress ' + 'this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. ' + 'To rename all deprecated lifecycles to their new names, you can run ' + '`npx react-codemod rename-unsafe-lifecycles` in your project source folder.\n' + '\nPlease update the following components: %s', _sortedNames4);
    }

    if (componentWillUpdateUniqueNames.size > 0) {
      var _sortedNames5 = setToSortedString(componentWillUpdateUniqueNames);

      warn('componentWillUpdate has been renamed, and is not recommended for use. ' + 'See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n' + '* Move data fetching code or side effects to componentDidUpdate.\n' + '* Rename componentWillUpdate to UNSAFE_componentWillUpdate to suppress ' + 'this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. ' + 'To rename all deprecated lifecycles to their new names, you can run ' + '`npx react-codemod rename-unsafe-lifecycles` in your project source folder.\n' + '\nPlease update the following components: %s', _sortedNames5);
    }
  };

  var pendingLegacyContextWarning = new Map(); // Tracks components we have already warned about.

  var didWarnAboutLegacyContext = new Set();

  ReactStrictModeWarnings.recordLegacyContextWarning = function (fiber, instance) {
    var strictRoot = findStrictRoot(fiber);

    if (strictRoot === null) {
      error('Expected to find a StrictMode component in a strict mode tree. ' + 'This error is likely caused by a bug in React. Please file an issue.');

      return;
    } // Dedup strategy: Warn once per component.


    if (didWarnAboutLegacyContext.has(fiber.type)) {
      return;
    }

    var warningsForRoot = pendingLegacyContextWarning.get(strictRoot);

    if (fiber.type.contextTypes != null || fiber.type.childContextTypes != null || instance !== null && typeof instance.getChildContext === 'function') {
      if (warningsForRoot === undefined) {
        warningsForRoot = [];
        pendingLegacyContextWarning.set(strictRoot, warningsForRoot);
      }

      warningsForRoot.push(fiber);
    }
  };

  ReactStrictModeWarnings.flushLegacyContextWarning = function () {
    pendingLegacyContextWarning.forEach(function (fiberArray, strictRoot) {
      if (fiberArray.length === 0) {
        return;
      }

      var firstFiber = fiberArray[0];
      var uniqueNames = new Set();
      fiberArray.forEach(function (fiber) {
        uniqueNames.add(getComponentName(fiber.type) || 'Component');
        didWarnAboutLegacyContext.add(fiber.type);
      });
      var sortedNames = setToSortedString(uniqueNames);

      try {
        setCurrentFiber(firstFiber);

        error('Legacy context API has been detected within a strict-mode tree.' + '\n\nThe old API will be supported in all 16.x releases, but applications ' + 'using it should migrate to the new version.' + '\n\nPlease update the following components: %s' + '\n\nLearn more about this warning here: https://reactjs.org/link/legacy-context', sortedNames);
      } finally {
        resetCurrentFiber();
      }
    });
  };

  ReactStrictModeWarnings.discardPendingWarnings = function () {
    pendingComponentWillMountWarnings = [];
    pendingUNSAFE_ComponentWillMountWarnings = [];
    pendingComponentWillReceivePropsWarnings = [];
    pendingUNSAFE_ComponentWillReceivePropsWarnings = [];
    pendingComponentWillUpdateWarnings = [];
    pendingUNSAFE_ComponentWillUpdateWarnings = [];
    pendingLegacyContextWarning = new Map();
  };
}

function resolveDefaultProps(Component, baseProps) {
  if (Component && Component.defaultProps) {
    // Resolve default props. Taken from ReactElement
    var props = _assign({}, baseProps);

    var defaultProps = Component.defaultProps;

    for (var propName in defaultProps) {
      if (props[propName] === undefined) {
        props[propName] = defaultProps[propName];
      }
    }

    return props;
  }

  return baseProps;
}

// Max 31 bit integer. The max integer size in V8 for 32-bit systems.
// Math.pow(2, 30) - 1
// 0b111111111111111111111111111111
var MAX_SIGNED_31_BIT_INT = 1073741823;

var valueCursor = createCursor(null);
var rendererSigil;

{
  // Use this to detect multiple renderers using the same context
  rendererSigil = {};
}

var currentlyRenderingFiber = null;
var lastContextDependency = null;
var lastContextWithAllBitsObserved = null;
var isDisallowedContextReadInDEV = false;
function resetContextDependencies() {
  // This is called right before React yields execution, to ensure `readContext`
  // cannot be called outside the render phase.
  currentlyRenderingFiber = null;
  lastContextDependency = null;
  lastContextWithAllBitsObserved = null;

  {
    isDisallowedContextReadInDEV = false;
  }
}
function enterDisallowedContextReadInDEV() {
  {
    isDisallowedContextReadInDEV = true;
  }
}
function exitDisallowedContextReadInDEV() {
  {
    isDisallowedContextReadInDEV = false;
  }
}
function pushProvider(providerFiber, nextValue) {
  var context = providerFiber.type._context;

  {
    push(valueCursor, context._currentValue, providerFiber);
    context._currentValue = nextValue;

    {
      if (context._currentRenderer !== undefined && context._currentRenderer !== null && context._currentRenderer !== rendererSigil) {
        error('Detected multiple renderers concurrently rendering the ' + 'same context provider. This is currently unsupported.');
      }

      context._currentRenderer = rendererSigil;
    }
  }
}
function popProvider(providerFiber) {
  var currentValue = valueCursor.current;
  pop(valueCursor, providerFiber);
  var context = providerFiber.type._context;

  {
    context._currentValue = currentValue;
  }
}
function calculateChangedBits(context, newValue, oldValue) {
  if (objectIs(oldValue, newValue)) {
    // No change
    return 0;
  } else {
    var changedBits = typeof context._calculateChangedBits === 'function' ? context._calculateChangedBits(oldValue, newValue) : MAX_SIGNED_31_BIT_INT;

    {
      if ((changedBits & MAX_SIGNED_31_BIT_INT) !== changedBits) {
        error('calculateChangedBits: Expected the return value to be a ' + '31-bit integer. Instead received: %s', changedBits);
      }
    }

    return changedBits | 0;
  }
}
function scheduleWorkOnParentPath(parent, renderLanes) {
  // Update the child lanes of all the ancestors, including the alternates.
  var node = parent;

  while (node !== null) {
    var alternate = node.alternate;

    if (!isSubsetOfLanes(node.childLanes, renderLanes)) {
      node.childLanes = mergeLanes(node.childLanes, renderLanes);

      if (alternate !== null) {
        alternate.childLanes = mergeLanes(alternate.childLanes, renderLanes);
      }
    } else if (alternate !== null && !isSubsetOfLanes(alternate.childLanes, renderLanes)) {
      alternate.childLanes = mergeLanes(alternate.childLanes, renderLanes);
    } else {
      // Neither alternate was updated, which means the rest of the
      // ancestor path already has sufficient priority.
      break;
    }

    node = node.return;
  }
}
function propagateContextChange(workInProgress, context, changedBits, renderLanes) {
  var fiber = workInProgress.child;

  if (fiber !== null) {
    // Set the return pointer of the child to the work-in-progress fiber.
    fiber.return = workInProgress;
  }

  while (fiber !== null) {
    var nextFiber = void 0; // Visit this fiber.

    var list = fiber.dependencies;

    if (list !== null) {
      nextFiber = fiber.child;
      var dependency = list.firstContext;

      while (dependency !== null) {
        // Check if the context matches.
        if (dependency.context === context && (dependency.observedBits & changedBits) !== 0) {
          // Match! Schedule an update on this fiber.
          if (fiber.tag === ClassComponent) {
            // Schedule a force update on the work-in-progress.
            var update = createUpdate(NoTimestamp, pickArbitraryLane(renderLanes));
            update.tag = ForceUpdate; // TODO: Because we don't have a work-in-progress, this will add the
            // update to the current fiber, too, which means it will persist even if
            // this render is thrown away. Since it's a race condition, not sure it's
            // worth fixing.

            enqueueUpdate(fiber, update);
          }

          fiber.lanes = mergeLanes(fiber.lanes, renderLanes);
          var alternate = fiber.alternate;

          if (alternate !== null) {
            alternate.lanes = mergeLanes(alternate.lanes, renderLanes);
          }

          scheduleWorkOnParentPath(fiber.return, renderLanes); // Mark the updated lanes on the list, too.

          list.lanes = mergeLanes(list.lanes, renderLanes); // Since we already found a match, we can stop traversing the
          // dependency list.

          break;
        }

        dependency = dependency.next;
      }
    } else if (fiber.tag === ContextProvider) {
      // Don't scan deeper if this is a matching provider
      nextFiber = fiber.type === workInProgress.type ? null : fiber.child;
    } else {
      // Traverse down.
      nextFiber = fiber.child;
    }

    if (nextFiber !== null) {
      // Set the return pointer of the child to the work-in-progress fiber.
      nextFiber.return = fiber;
    } else {
      // No child. Traverse to next sibling.
      nextFiber = fiber;

      while (nextFiber !== null) {
        if (nextFiber === workInProgress) {
          // We're back to the root of this subtree. Exit.
          nextFiber = null;
          break;
        }

        var sibling = nextFiber.sibling;

        if (sibling !== null) {
          // Set the return pointer of the sibling to the work-in-progress fiber.
          sibling.return = nextFiber.return;
          nextFiber = sibling;
          break;
        } // No more siblings. Traverse up.


        nextFiber = nextFiber.return;
      }
    }

    fiber = nextFiber;
  }
}
function prepareToReadContext(workInProgress, renderLanes) {
  currentlyRenderingFiber = workInProgress;
  lastContextDependency = null;
  lastContextWithAllBitsObserved = null;
  var dependencies = workInProgress.dependencies;

  if (dependencies !== null) {
    var firstContext = dependencies.firstContext;

    if (firstContext !== null) {
      if (includesSomeLane(dependencies.lanes, renderLanes)) {
        // Context list has a pending update. Mark that this fiber performed work.
        markWorkInProgressReceivedUpdate();
      } // Reset the work-in-progress list


      dependencies.firstContext = null;
    }
  }
}
function readContext(context, observedBits) {
  {
    // This warning would fire if you read context inside a Hook like useMemo.
    // Unlike the class check below, it's not enforced in production for perf.
    if (isDisallowedContextReadInDEV) {
      error('Context can only be read while React is rendering. ' + 'In classes, you can read it in the render method or getDerivedStateFromProps. ' + 'In function components, you can read it directly in the function body, but not ' + 'inside Hooks like useReducer() or useMemo().');
    }
  }

  if (lastContextWithAllBitsObserved === context) ; else if (observedBits === false || observedBits === 0) ; else {
    var resolvedObservedBits; // Avoid deopting on observable arguments or heterogeneous types.

    if (typeof observedBits !== 'number' || observedBits === MAX_SIGNED_31_BIT_INT) {
      // Observe all updates.
      lastContextWithAllBitsObserved = context;
      resolvedObservedBits = MAX_SIGNED_31_BIT_INT;
    } else {
      resolvedObservedBits = observedBits;
    }

    var contextItem = {
      context: context,
      observedBits: resolvedObservedBits,
      next: null
    };

    if (lastContextDependency === null) {
      if (!(currentlyRenderingFiber !== null)) {
        {
          throw Error( "Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo()." );
        }
      } // This is the first dependency for this component. Create a new list.


      lastContextDependency = contextItem;
      currentlyRenderingFiber.dependencies = {
        lanes: NoLanes,
        firstContext: contextItem,
        responders: null
      };
    } else {
      // Append a new context item.
      lastContextDependency = lastContextDependency.next = contextItem;
    }
  }

  return  context._currentValue ;
}

var UpdateState = 0;
var ReplaceState = 1;
var ForceUpdate = 2;
var CaptureUpdate = 3; // Global state that is reset at the beginning of calling `processUpdateQueue`.
// It should only be read right after calling `processUpdateQueue`, via
// `checkHasForceUpdateAfterProcessing`.

var hasForceUpdate = false;
var didWarnUpdateInsideUpdate;
var currentlyProcessingQueue;

{
  didWarnUpdateInsideUpdate = false;
  currentlyProcessingQueue = null;
}

function initializeUpdateQueue(fiber) {
  var queue = {
    baseState: fiber.memoizedState,
    firstBaseUpdate: null,
    lastBaseUpdate: null,
    shared: {
      pending: null
    },
    effects: null
  };
  fiber.updateQueue = queue;
}
function cloneUpdateQueue(current, workInProgress) {
  // Clone the update queue from current. Unless it's already a clone.
  var queue = workInProgress.updateQueue;
  var currentQueue = current.updateQueue;

  if (queue === currentQueue) {
    var clone = {
      baseState: currentQueue.baseState,
      firstBaseUpdate: currentQueue.firstBaseUpdate,
      lastBaseUpdate: currentQueue.lastBaseUpdate,
      shared: currentQueue.shared,
      effects: currentQueue.effects
    };
    workInProgress.updateQueue = clone;
  }
}
function createUpdate(eventTime, lane) {
  var update = {
    eventTime: eventTime,
    lane: lane,
    tag: UpdateState,
    payload: null,
    callback: null,
    next: null
  };
  return update;
}
function enqueueUpdate(fiber, update) {
  var updateQueue = fiber.updateQueue;

  if (updateQueue === null) {
    // Only occurs if the fiber has been unmounted.
    return;
  }

  var sharedQueue = updateQueue.shared;
  var pending = sharedQueue.pending;

  if (pending === null) {
    // This is the first update. Create a circular list.
    update.next = update;
  } else {
    update.next = pending.next;
    pending.next = update;
  }

  sharedQueue.pending = update;

  {
    if (currentlyProcessingQueue === sharedQueue && !didWarnUpdateInsideUpdate) {
      error('An update (setState, replaceState, or forceUpdate) was scheduled ' + 'from inside an update function. Update functions should be pure, ' + 'with zero side-effects. Consider using componentDidUpdate or a ' + 'callback.');

      didWarnUpdateInsideUpdate = true;
    }
  }
}
function enqueueCapturedUpdate(workInProgress, capturedUpdate) {
  // Captured updates are updates that are thrown by a child during the render
  // phase. They should be discarded if the render is aborted. Therefore,
  // we should only put them on the work-in-progress queue, not the current one.
  var queue = workInProgress.updateQueue; // Check if the work-in-progress queue is a clone.

  var current = workInProgress.alternate;

  if (current !== null) {
    var currentQueue = current.updateQueue;

    if (queue === currentQueue) {
      // The work-in-progress queue is the same as current. This happens when
      // we bail out on a parent fiber that then captures an error thrown by
      // a child. Since we want to append the update only to the work-in
      // -progress queue, we need to clone the updates. We usually clone during
      // processUpdateQueue, but that didn't happen in this case because we
      // skipped over the parent when we bailed out.
      var newFirst = null;
      var newLast = null;
      var firstBaseUpdate = queue.firstBaseUpdate;

      if (firstBaseUpdate !== null) {
        // Loop through the updates and clone them.
        var update = firstBaseUpdate;

        do {
          var clone = {
            eventTime: update.eventTime,
            lane: update.lane,
            tag: update.tag,
            payload: update.payload,
            callback: update.callback,
            next: null
          };

          if (newLast === null) {
            newFirst = newLast = clone;
          } else {
            newLast.next = clone;
            newLast = clone;
          }

          update = update.next;
        } while (update !== null); // Append the captured update the end of the cloned list.


        if (newLast === null) {
          newFirst = newLast = capturedUpdate;
        } else {
          newLast.next = capturedUpdate;
          newLast = capturedUpdate;
        }
      } else {
        // There are no base updates.
        newFirst = newLast = capturedUpdate;
      }

      queue = {
        baseState: currentQueue.baseState,
        firstBaseUpdate: newFirst,
        lastBaseUpdate: newLast,
        shared: currentQueue.shared,
        effects: currentQueue.effects
      };
      workInProgress.updateQueue = queue;
      return;
    }
  } // Append the update to the end of the list.


  var lastBaseUpdate = queue.lastBaseUpdate;

  if (lastBaseUpdate === null) {
    queue.firstBaseUpdate = capturedUpdate;
  } else {
    lastBaseUpdate.next = capturedUpdate;
  }

  queue.lastBaseUpdate = capturedUpdate;
}

function getStateFromUpdate(workInProgress, queue, update, prevState, nextProps, instance) {
  switch (update.tag) {
    case ReplaceState:
      {
        var payload = update.payload;

        if (typeof payload === 'function') {
          // Updater function
          {
            enterDisallowedContextReadInDEV();
          }

          var nextState = payload.call(instance, prevState, nextProps);

          {
            if ( workInProgress.mode & StrictMode) {
              disableLogs();

              try {
                payload.call(instance, prevState, nextProps);
              } finally {
                reenableLogs();
              }
            }

            exitDisallowedContextReadInDEV();
          }

          return nextState;
        } // State object


        return payload;
      }

    case CaptureUpdate:
      {
        workInProgress.flags = workInProgress.flags & ~ShouldCapture | DidCapture;
      }
    // Intentional fallthrough

    case UpdateState:
      {
        var _payload = update.payload;
        var partialState;

        if (typeof _payload === 'function') {
          // Updater function
          {
            enterDisallowedContextReadInDEV();
          }

          partialState = _payload.call(instance, prevState, nextProps);

          {
            if ( workInProgress.mode & StrictMode) {
              disableLogs();

              try {
                _payload.call(instance, prevState, nextProps);
              } finally {
                reenableLogs();
              }
            }

            exitDisallowedContextReadInDEV();
          }
        } else {
          // Partial state object
          partialState = _payload;
        }

        if (partialState === null || partialState === undefined) {
          // Null and undefined are treated as no-ops.
          return prevState;
        } // Merge the partial state and the previous state.


        return _assign({}, prevState, partialState);
      }

    case ForceUpdate:
      {
        hasForceUpdate = true;
        return prevState;
      }
  }

  return prevState;
}

function processUpdateQueue(workInProgress, props, instance, renderLanes) {
  // This is always non-null on a ClassComponent or HostRoot
  var queue = workInProgress.updateQueue;
  hasForceUpdate = false;

  {
    currentlyProcessingQueue = queue.shared;
  }

  var firstBaseUpdate = queue.firstBaseUpdate;
  var lastBaseUpdate = queue.lastBaseUpdate; // Check if there are pending updates. If so, transfer them to the base queue.

  var pendingQueue = queue.shared.pending;

  if (pendingQueue !== null) {
    queue.shared.pending = null; // The pending queue is circular. Disconnect the pointer between first
    // and last so that it's non-circular.

    var lastPendingUpdate = pendingQueue;
    var firstPendingUpdate = lastPendingUpdate.next;
    lastPendingUpdate.next = null; // Append pending updates to base queue

    if (lastBaseUpdate === null) {
      firstBaseUpdate = firstPendingUpdate;
    } else {
      lastBaseUpdate.next = firstPendingUpdate;
    }

    lastBaseUpdate = lastPendingUpdate; // If there's a current queue, and it's different from the base queue, then
    // we need to transfer the updates to that queue, too. Because the base
    // queue is a singly-linked list with no cycles, we can append to both
    // lists and take advantage of structural sharing.
    // TODO: Pass `current` as argument

    var current = workInProgress.alternate;

    if (current !== null) {
      // This is always non-null on a ClassComponent or HostRoot
      var currentQueue = current.updateQueue;
      var currentLastBaseUpdate = currentQueue.lastBaseUpdate;

      if (currentLastBaseUpdate !== lastBaseUpdate) {
        if (currentLastBaseUpdate === null) {
          currentQueue.firstBaseUpdate = firstPendingUpdate;
        } else {
          currentLastBaseUpdate.next = firstPendingUpdate;
        }

        currentQueue.lastBaseUpdate = lastPendingUpdate;
      }
    }
  } // These values may change as we process the queue.


  if (firstBaseUpdate !== null) {
    // Iterate through the list of updates to compute the result.
    var newState = queue.baseState; // TODO: Don't need to accumulate this. Instead, we can remove renderLanes
    // from the original lanes.

    var newLanes = NoLanes;
    var newBaseState = null;
    var newFirstBaseUpdate = null;
    var newLastBaseUpdate = null;
    var update = firstBaseUpdate;

    do {
      var updateLane = update.lane;
      var updateEventTime = update.eventTime;

      if (!isSubsetOfLanes(renderLanes, updateLane)) {
        // Priority is insufficient. Skip this update. If this is the first
        // skipped update, the previous update/state is the new base
        // update/state.
        var clone = {
          eventTime: updateEventTime,
          lane: updateLane,
          tag: update.tag,
          payload: update.payload,
          callback: update.callback,
          next: null
        };

        if (newLastBaseUpdate === null) {
          newFirstBaseUpdate = newLastBaseUpdate = clone;
          newBaseState = newState;
        } else {
          newLastBaseUpdate = newLastBaseUpdate.next = clone;
        } // Update the remaining priority in the queue.


        newLanes = mergeLanes(newLanes, updateLane);
      } else {
        // This update does have sufficient priority.
        if (newLastBaseUpdate !== null) {
          var _clone = {
            eventTime: updateEventTime,
            // This update is going to be committed so we never want uncommit
            // it. Using NoLane works because 0 is a subset of all bitmasks, so
            // this will never be skipped by the check above.
            lane: NoLane,
            tag: update.tag,
            payload: update.payload,
            callback: update.callback,
            next: null
          };
          newLastBaseUpdate = newLastBaseUpdate.next = _clone;
        } // Process this update.


        newState = getStateFromUpdate(workInProgress, queue, update, newState, props, instance);
        var callback = update.callback;

        if (callback !== null) {
          workInProgress.flags |= Callback;
          var effects = queue.effects;

          if (effects === null) {
            queue.effects = [update];
          } else {
            effects.push(update);
          }
        }
      }

      update = update.next;

      if (update === null) {
        pendingQueue = queue.shared.pending;

        if (pendingQueue === null) {
          break;
        } else {
          // An update was scheduled from inside a reducer. Add the new
          // pending updates to the end of the list and keep processing.
          var _lastPendingUpdate = pendingQueue; // Intentionally unsound. Pending updates form a circular list, but we
          // unravel them when transferring them to the base queue.

          var _firstPendingUpdate = _lastPendingUpdate.next;
          _lastPendingUpdate.next = null;
          update = _firstPendingUpdate;
          queue.lastBaseUpdate = _lastPendingUpdate;
          queue.shared.pending = null;
        }
      }
    } while (true);

    if (newLastBaseUpdate === null) {
      newBaseState = newState;
    }

    queue.baseState = newBaseState;
    queue.firstBaseUpdate = newFirstBaseUpdate;
    queue.lastBaseUpdate = newLastBaseUpdate; // Set the remaining expiration time to be whatever is remaining in the queue.
    // This should be fine because the only two other things that contribute to
    // expiration time are props and context. We're already in the middle of the
    // begin phase by the time we start processing the queue, so we've already
    // dealt with the props. Context in components that specify
    // shouldComponentUpdate is tricky; but we'll have to account for
    // that regardless.

    markSkippedUpdateLanes(newLanes);
    workInProgress.lanes = newLanes;
    workInProgress.memoizedState = newState;
  }

  {
    currentlyProcessingQueue = null;
  }
}

function callCallback(callback, context) {
  if (!(typeof callback === 'function')) {
    {
      throw Error( "Invalid argument passed as callback. Expected a function. Instead received: " + callback );
    }
  }

  callback.call(context);
}

function resetHasForceUpdateBeforeProcessing() {
  hasForceUpdate = false;
}
function checkHasForceUpdateAfterProcessing() {
  return hasForceUpdate;
}
function commitUpdateQueue(finishedWork, finishedQueue, instance) {
  // Commit the effects
  var effects = finishedQueue.effects;
  finishedQueue.effects = null;

  if (effects !== null) {
    for (var i = 0; i < effects.length; i++) {
      var effect = effects[i];
      var callback = effect.callback;

      if (callback !== null) {
        effect.callback = null;
        callCallback(callback, instance);
      }
    }
  }
}

var fakeInternalInstance = {};
var isArray = Array.isArray; // React.Component uses a shared frozen object by default.
// We'll use it to determine whether we need to initialize legacy refs.

var emptyRefsObject = new React.Component().refs;
var didWarnAboutStateAssignmentForComponent;
var didWarnAboutUninitializedState;
var didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate;
var didWarnAboutLegacyLifecyclesAndDerivedState;
var didWarnAboutUndefinedDerivedState;
var warnOnUndefinedDerivedState;
var warnOnInvalidCallback;
var didWarnAboutDirectlyAssigningPropsToState;
var didWarnAboutContextTypeAndContextTypes;
var didWarnAboutInvalidateContextType;

{
  didWarnAboutStateAssignmentForComponent = new Set();
  didWarnAboutUninitializedState = new Set();
  didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate = new Set();
  didWarnAboutLegacyLifecyclesAndDerivedState = new Set();
  didWarnAboutDirectlyAssigningPropsToState = new Set();
  didWarnAboutUndefinedDerivedState = new Set();
  didWarnAboutContextTypeAndContextTypes = new Set();
  didWarnAboutInvalidateContextType = new Set();
  var didWarnOnInvalidCallback = new Set();

  warnOnInvalidCallback = function (callback, callerName) {
    if (callback === null || typeof callback === 'function') {
      return;
    }

    var key = callerName + '_' + callback;

    if (!didWarnOnInvalidCallback.has(key)) {
      didWarnOnInvalidCallback.add(key);

      error('%s(...): Expected the last optional `callback` argument to be a ' + 'function. Instead received: %s.', callerName, callback);
    }
  };

  warnOnUndefinedDerivedState = function (type, partialState) {
    if (partialState === undefined) {
      var componentName = getComponentName(type) || 'Component';

      if (!didWarnAboutUndefinedDerivedState.has(componentName)) {
        didWarnAboutUndefinedDerivedState.add(componentName);

        error('%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. ' + 'You have returned undefined.', componentName);
      }
    }
  }; // This is so gross but it's at least non-critical and can be removed if
  // it causes problems. This is meant to give a nicer error message for
  // ReactDOM15.unstable_renderSubtreeIntoContainer(reactDOM16Component,
  // ...)) which otherwise throws a "_processChildContext is not a function"
  // exception.


  Object.defineProperty(fakeInternalInstance, '_processChildContext', {
    enumerable: false,
    value: function () {
      {
        {
          throw Error( "_processChildContext is not available in React 16+. This likely means you have multiple copies of React and are attempting to nest a React 15 tree inside a React 16 tree using unstable_renderSubtreeIntoContainer, which isn't supported. Try to make sure you have only one copy of React (and ideally, switch to ReactDOM.createPortal)." );
        }
      }
    }
  });
  Object.freeze(fakeInternalInstance);
}

function applyDerivedStateFromProps(workInProgress, ctor, getDerivedStateFromProps, nextProps) {
  var prevState = workInProgress.memoizedState;

  {
    if ( workInProgress.mode & StrictMode) {
      disableLogs();

      try {
        // Invoke the function an extra time to help detect side-effects.
        getDerivedStateFromProps(nextProps, prevState);
      } finally {
        reenableLogs();
      }
    }
  }

  var partialState = getDerivedStateFromProps(nextProps, prevState);

  {
    warnOnUndefinedDerivedState(ctor, partialState);
  } // Merge the partial state and the previous state.


  var memoizedState = partialState === null || partialState === undefined ? prevState : _assign({}, prevState, partialState);
  workInProgress.memoizedState = memoizedState; // Once the update queue is empty, persist the derived state onto the
  // base state.

  if (workInProgress.lanes === NoLanes) {
    // Queue is always non-null for classes
    var updateQueue = workInProgress.updateQueue;
    updateQueue.baseState = memoizedState;
  }
}
var classComponentUpdater = {
  isMounted: isMounted,
  enqueueSetState: function (inst, payload, callback) {
    var fiber = get(inst);
    var eventTime = requestEventTime();
    var lane = requestUpdateLane(fiber);
    var update = createUpdate(eventTime, lane);
    update.payload = payload;

    if (callback !== undefined && callback !== null) {
      {
        warnOnInvalidCallback(callback, 'setState');
      }

      update.callback = callback;
    }

    enqueueUpdate(fiber, update);
    scheduleUpdateOnFiber(fiber, lane, eventTime);
  },
  enqueueReplaceState: function (inst, payload, callback) {
    var fiber = get(inst);
    var eventTime = requestEventTime();
    var lane = requestUpdateLane(fiber);
    var update = createUpdate(eventTime, lane);
    update.tag = ReplaceState;
    update.payload = payload;

    if (callback !== undefined && callback !== null) {
      {
        warnOnInvalidCallback(callback, 'replaceState');
      }

      update.callback = callback;
    }

    enqueueUpdate(fiber, update);
    scheduleUpdateOnFiber(fiber, lane, eventTime);
  },
  enqueueForceUpdate: function (inst, callback) {
    var fiber = get(inst);
    var eventTime = requestEventTime();
    var lane = requestUpdateLane(fiber);
    var update = createUpdate(eventTime, lane);
    update.tag = ForceUpdate;

    if (callback !== undefined && callback !== null) {
      {
        warnOnInvalidCallback(callback, 'forceUpdate');
      }

      update.callback = callback;
    }

    enqueueUpdate(fiber, update);
    scheduleUpdateOnFiber(fiber, lane, eventTime);
  }
};

function checkShouldComponentUpdate(workInProgress, ctor, oldProps, newProps, oldState, newState, nextContext) {
  var instance = workInProgress.stateNode;

  if (typeof instance.shouldComponentUpdate === 'function') {
    {
      if ( workInProgress.mode & StrictMode) {
        disableLogs();

        try {
          // Invoke the function an extra time to help detect side-effects.
          instance.shouldComponentUpdate(newProps, newState, nextContext);
        } finally {
          reenableLogs();
        }
      }
    }

    var shouldUpdate = instance.shouldComponentUpdate(newProps, newState, nextContext);

    {
      if (shouldUpdate === undefined) {
        error('%s.shouldComponentUpdate(): Returned undefined instead of a ' + 'boolean value. Make sure to return true or false.', getComponentName(ctor) || 'Component');
      }
    }

    return shouldUpdate;
  }

  if (ctor.prototype && ctor.prototype.isPureReactComponent) {
    return !shallowEqual(oldProps, newProps) || !shallowEqual(oldState, newState);
  }

  return true;
}

function checkClassInstance(workInProgress, ctor, newProps) {
  var instance = workInProgress.stateNode;

  {
    var name = getComponentName(ctor) || 'Component';
    var renderPresent = instance.render;

    if (!renderPresent) {
      if (ctor.prototype && typeof ctor.prototype.render === 'function') {
        error('%s(...): No `render` method found on the returned component ' + 'instance: did you accidentally return an object from the constructor?', name);
      } else {
        error('%s(...): No `render` method found on the returned component ' + 'instance: you may have forgotten to define `render`.', name);
      }
    }

    if (instance.getInitialState && !instance.getInitialState.isReactClassApproved && !instance.state) {
      error('getInitialState was defined on %s, a plain JavaScript class. ' + 'This is only supported for classes created using React.createClass. ' + 'Did you mean to define a state property instead?', name);
    }

    if (instance.getDefaultProps && !instance.getDefaultProps.isReactClassApproved) {
      error('getDefaultProps was defined on %s, a plain JavaScript class. ' + 'This is only supported for classes created using React.createClass. ' + 'Use a static property to define defaultProps instead.', name);
    }

    if (instance.propTypes) {
      error('propTypes was defined as an instance property on %s. Use a static ' + 'property to define propTypes instead.', name);
    }

    if (instance.contextType) {
      error('contextType was defined as an instance property on %s. Use a static ' + 'property to define contextType instead.', name);
    }

    {
      if (instance.contextTypes) {
        error('contextTypes was defined as an instance property on %s. Use a static ' + 'property to define contextTypes instead.', name);
      }

      if (ctor.contextType && ctor.contextTypes && !didWarnAboutContextTypeAndContextTypes.has(ctor)) {
        didWarnAboutContextTypeAndContextTypes.add(ctor);

        error('%s declares both contextTypes and contextType static properties. ' + 'The legacy contextTypes property will be ignored.', name);
      }
    }

    if (typeof instance.componentShouldUpdate === 'function') {
      error('%s has a method called ' + 'componentShouldUpdate(). Did you mean shouldComponentUpdate()? ' + 'The name is phrased as a question because the function is ' + 'expected to return a value.', name);
    }

    if (ctor.prototype && ctor.prototype.isPureReactComponent && typeof instance.shouldComponentUpdate !== 'undefined') {
      error('%s has a method called shouldComponentUpdate(). ' + 'shouldComponentUpdate should not be used when extending React.PureComponent. ' + 'Please extend React.Component if shouldComponentUpdate is used.', getComponentName(ctor) || 'A pure component');
    }

    if (typeof instance.componentDidUnmount === 'function') {
      error('%s has a method called ' + 'componentDidUnmount(). But there is no such lifecycle method. ' + 'Did you mean componentWillUnmount()?', name);
    }

    if (typeof instance.componentDidReceiveProps === 'function') {
      error('%s has a method called ' + 'componentDidReceiveProps(). But there is no such lifecycle method. ' + 'If you meant to update the state in response to changing props, ' + 'use componentWillReceiveProps(). If you meant to fetch data or ' + 'run side-effects or mutations after React has updated the UI, use componentDidUpdate().', name);
    }

    if (typeof instance.componentWillRecieveProps === 'function') {
      error('%s has a method called ' + 'componentWillRecieveProps(). Did you mean componentWillReceiveProps()?', name);
    }

    if (typeof instance.UNSAFE_componentWillRecieveProps === 'function') {
      error('%s has a method called ' + 'UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?', name);
    }

    var hasMutatedProps = instance.props !== newProps;

    if (instance.props !== undefined && hasMutatedProps) {
      error('%s(...): When calling super() in `%s`, make sure to pass ' + "up the same props that your component's constructor was passed.", name, name);
    }

    if (instance.defaultProps) {
      error('Setting defaultProps as an instance property on %s is not supported and will be ignored.' + ' Instead, define defaultProps as a static property on %s.', name, name);
    }

    if (typeof instance.getSnapshotBeforeUpdate === 'function' && typeof instance.componentDidUpdate !== 'function' && !didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.has(ctor)) {
      didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.add(ctor);

      error('%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). ' + 'This component defines getSnapshotBeforeUpdate() only.', getComponentName(ctor));
    }

    if (typeof instance.getDerivedStateFromProps === 'function') {
      error('%s: getDerivedStateFromProps() is defined as an instance method ' + 'and will be ignored. Instead, declare it as a static method.', name);
    }

    if (typeof instance.getDerivedStateFromError === 'function') {
      error('%s: getDerivedStateFromError() is defined as an instance method ' + 'and will be ignored. Instead, declare it as a static method.', name);
    }

    if (typeof ctor.getSnapshotBeforeUpdate === 'function') {
      error('%s: getSnapshotBeforeUpdate() is defined as a static method ' + 'and will be ignored. Instead, declare it as an instance method.', name);
    }

    var _state = instance.state;

    if (_state && (typeof _state !== 'object' || isArray(_state))) {
      error('%s.state: must be set to an object or null', name);
    }

    if (typeof instance.getChildContext === 'function' && typeof ctor.childContextTypes !== 'object') {
      error('%s.getChildContext(): childContextTypes must be defined in order to ' + 'use getChildContext().', name);
    }
  }
}

function adoptClassInstance(workInProgress, instance) {
  instance.updater = classComponentUpdater;
  workInProgress.stateNode = instance; // The instance needs access to the fiber so that it can schedule updates

  set(instance, workInProgress);

  {
    instance._reactInternalInstance = fakeInternalInstance;
  }
}

function constructClassInstance(workInProgress, ctor, props) {
  var isLegacyContextConsumer = false;
  var unmaskedContext = emptyContextObject;
  var context = emptyContextObject;
  var contextType = ctor.contextType;

  {
    if ('contextType' in ctor) {
      var isValid = // Allow null for conditional declaration
      contextType === null || contextType !== undefined && contextType.$$typeof === REACT_CONTEXT_TYPE && contextType._context === undefined; // Not a <Context.Consumer>

      if (!isValid && !didWarnAboutInvalidateContextType.has(ctor)) {
        didWarnAboutInvalidateContextType.add(ctor);
        var addendum = '';

        if (contextType === undefined) {
          addendum = ' However, it is set to undefined. ' + 'This can be caused by a typo or by mixing up named and default imports. ' + 'This can also happen due to a circular dependency, so ' + 'try moving the createContext() call to a separate file.';
        } else if (typeof contextType !== 'object') {
          addendum = ' However, it is set to a ' + typeof contextType + '.';
        } else if (contextType.$$typeof === REACT_PROVIDER_TYPE) {
          addendum = ' Did you accidentally pass the Context.Provider instead?';
        } else if (contextType._context !== undefined) {
          // <Context.Consumer>
          addendum = ' Did you accidentally pass the Context.Consumer instead?';
        } else {
          addendum = ' However, it is set to an object with keys {' + Object.keys(contextType).join(', ') + '}.';
        }

        error('%s defines an invalid contextType. ' + 'contextType should point to the Context object returned by React.createContext().%s', getComponentName(ctor) || 'Component', addendum);
      }
    }
  }

  if (typeof contextType === 'object' && contextType !== null) {
    context = readContext(contextType);
  } else {
    unmaskedContext = getUnmaskedContext(workInProgress, ctor, true);
    var contextTypes = ctor.contextTypes;
    isLegacyContextConsumer = contextTypes !== null && contextTypes !== undefined;
    context = isLegacyContextConsumer ? getMaskedContext(workInProgress, unmaskedContext) : emptyContextObject;
  } // Instantiate twice to help detect side-effects.


  {
    if ( workInProgress.mode & StrictMode) {
      disableLogs();

      try {
        new ctor(props, context); // eslint-disable-line no-new
      } finally {
        reenableLogs();
      }
    }
  }

  var instance = new ctor(props, context);
  var state = workInProgress.memoizedState = instance.state !== null && instance.state !== undefined ? instance.state : null;
  adoptClassInstance(workInProgress, instance);

  {
    if (typeof ctor.getDerivedStateFromProps === 'function' && state === null) {
      var componentName = getComponentName(ctor) || 'Component';

      if (!didWarnAboutUninitializedState.has(componentName)) {
        didWarnAboutUninitializedState.add(componentName);

        error('`%s` uses `getDerivedStateFromProps` but its initial state is ' + '%s. This is not recommended. Instead, define the initial state by ' + 'assigning an object to `this.state` in the constructor of `%s`. ' + 'This ensures that `getDerivedStateFromProps` arguments have a consistent shape.', componentName, instance.state === null ? 'null' : 'undefined', componentName);
      }
    } // If new component APIs are defined, "unsafe" lifecycles won't be called.
    // Warn about these lifecycles if they are present.
    // Don't warn about react-lifecycles-compat polyfilled methods though.


    if (typeof ctor.getDerivedStateFromProps === 'function' || typeof instance.getSnapshotBeforeUpdate === 'function') {
      var foundWillMountName = null;
      var foundWillReceivePropsName = null;
      var foundWillUpdateName = null;

      if (typeof instance.componentWillMount === 'function' && instance.componentWillMount.__suppressDeprecationWarning !== true) {
        foundWillMountName = 'componentWillMount';
      } else if (typeof instance.UNSAFE_componentWillMount === 'function') {
        foundWillMountName = 'UNSAFE_componentWillMount';
      }

      if (typeof instance.componentWillReceiveProps === 'function' && instance.componentWillReceiveProps.__suppressDeprecationWarning !== true) {
        foundWillReceivePropsName = 'componentWillReceiveProps';
      } else if (typeof instance.UNSAFE_componentWillReceiveProps === 'function') {
        foundWillReceivePropsName = 'UNSAFE_componentWillReceiveProps';
      }

      if (typeof instance.componentWillUpdate === 'function' && instance.componentWillUpdate.__suppressDeprecationWarning !== true) {
        foundWillUpdateName = 'componentWillUpdate';
      } else if (typeof instance.UNSAFE_componentWillUpdate === 'function') {
        foundWillUpdateName = 'UNSAFE_componentWillUpdate';
      }

      if (foundWillMountName !== null || foundWillReceivePropsName !== null || foundWillUpdateName !== null) {
        var _componentName = getComponentName(ctor) || 'Component';

        var newApiName = typeof ctor.getDerivedStateFromProps === 'function' ? 'getDerivedStateFromProps()' : 'getSnapshotBeforeUpdate()';

        if (!didWarnAboutLegacyLifecyclesAndDerivedState.has(_componentName)) {
          didWarnAboutLegacyLifecyclesAndDerivedState.add(_componentName);

          error('Unsafe legacy lifecycles will not be called for components using new component APIs.\n\n' + '%s uses %s but also contains the following legacy lifecycles:%s%s%s\n\n' + 'The above lifecycles should be removed. Learn more about this warning here:\n' + 'https://reactjs.org/link/unsafe-component-lifecycles', _componentName, newApiName, foundWillMountName !== null ? "\n  " + foundWillMountName : '', foundWillReceivePropsName !== null ? "\n  " + foundWillReceivePropsName : '', foundWillUpdateName !== null ? "\n  " + foundWillUpdateName : '');
        }
      }
    }
  } // Cache unmasked context so we can avoid recreating masked context unless necessary.
  // ReactFiberContext usually updates this cache but can't for newly-created instances.


  if (isLegacyContextConsumer) {
    cacheContext(workInProgress, unmaskedContext, context);
  }

  return instance;
}

function callComponentWillMount(workInProgress, instance) {
  var oldState = instance.state;

  if (typeof instance.componentWillMount === 'function') {
    instance.componentWillMount();
  }

  if (typeof instance.UNSAFE_componentWillMount === 'function') {
    instance.UNSAFE_componentWillMount();
  }

  if (oldState !== instance.state) {
    {
      error('%s.componentWillMount(): Assigning directly to this.state is ' + "deprecated (except inside a component's " + 'constructor). Use setState instead.', getComponentName(workInProgress.type) || 'Component');
    }

    classComponentUpdater.enqueueReplaceState(instance, instance.state, null);
  }
}

function callComponentWillReceiveProps(workInProgress, instance, newProps, nextContext) {
  var oldState = instance.state;

  if (typeof instance.componentWillReceiveProps === 'function') {
    instance.componentWillReceiveProps(newProps, nextContext);
  }

  if (typeof instance.UNSAFE_componentWillReceiveProps === 'function') {
    instance.UNSAFE_componentWillReceiveProps(newProps, nextContext);
  }

  if (instance.state !== oldState) {
    {
      var componentName = getComponentName(workInProgress.type) || 'Component';

      if (!didWarnAboutStateAssignmentForComponent.has(componentName)) {
        didWarnAboutStateAssignmentForComponent.add(componentName);

        error('%s.componentWillReceiveProps(): Assigning directly to ' + "this.state is deprecated (except inside a component's " + 'constructor). Use setState instead.', componentName);
      }
    }

    classComponentUpdater.enqueueReplaceState(instance, instance.state, null);
  }
} // Invokes the mount life-cycles on a previously never rendered instance.


function mountClassInstance(workInProgress, ctor, newProps, renderLanes) {
  {
    checkClassInstance(workInProgress, ctor, newProps);
  }

  var instance = workInProgress.stateNode;
  instance.props = newProps;
  instance.state = workInProgress.memoizedState;
  instance.refs = emptyRefsObject;
  initializeUpdateQueue(workInProgress);
  var contextType = ctor.contextType;

  if (typeof contextType === 'object' && contextType !== null) {
    instance.context = readContext(contextType);
  } else {
    var unmaskedContext = getUnmaskedContext(workInProgress, ctor, true);
    instance.context = getMaskedContext(workInProgress, unmaskedContext);
  }

  {
    if (instance.state === newProps) {
      var componentName = getComponentName(ctor) || 'Component';

      if (!didWarnAboutDirectlyAssigningPropsToState.has(componentName)) {
        didWarnAboutDirectlyAssigningPropsToState.add(componentName);

        error('%s: It is not recommended to assign props directly to state ' + "because updates to props won't be reflected in state. " + 'In most cases, it is better to use props directly.', componentName);
      }
    }

    if (workInProgress.mode & StrictMode) {
      ReactStrictModeWarnings.recordLegacyContextWarning(workInProgress, instance);
    }

    {
      ReactStrictModeWarnings.recordUnsafeLifecycleWarnings(workInProgress, instance);
    }
  }

  processUpdateQueue(workInProgress, newProps, instance, renderLanes);
  instance.state = workInProgress.memoizedState;
  var getDerivedStateFromProps = ctor.getDerivedStateFromProps;

  if (typeof getDerivedStateFromProps === 'function') {
    applyDerivedStateFromProps(workInProgress, ctor, getDerivedStateFromProps, newProps);
    instance.state = workInProgress.memoizedState;
  } // In order to support react-lifecycles-compat polyfilled components,
  // Unsafe lifecycles should not be invoked for components using the new APIs.


  if (typeof ctor.getDerivedStateFromProps !== 'function' && typeof instance.getSnapshotBeforeUpdate !== 'function' && (typeof instance.UNSAFE_componentWillMount === 'function' || typeof instance.componentWillMount === 'function')) {
    callComponentWillMount(workInProgress, instance); // If we had additional state updates during this life-cycle, let's
    // process them now.

    processUpdateQueue(workInProgress, newProps, instance, renderLanes);
    instance.state = workInProgress.memoizedState;
  }

  if (typeof instance.componentDidMount === 'function') {
    workInProgress.flags |= Update;
  }
}

function resumeMountClassInstance(workInProgress, ctor, newProps, renderLanes) {
  var instance = workInProgress.stateNode;
  var oldProps = workInProgress.memoizedProps;
  instance.props = oldProps;
  var oldContext = instance.context;
  var contextType = ctor.contextType;
  var nextContext = emptyContextObject;

  if (typeof contextType === 'object' && contextType !== null) {
    nextContext = readContext(contextType);
  } else {
    var nextLegacyUnmaskedContext = getUnmaskedContext(workInProgress, ctor, true);
    nextContext = getMaskedContext(workInProgress, nextLegacyUnmaskedContext);
  }

  var getDerivedStateFromProps = ctor.getDerivedStateFromProps;
  var hasNewLifecycles = typeof getDerivedStateFromProps === 'function' || typeof instance.getSnapshotBeforeUpdate === 'function'; // Note: During these life-cycles, instance.props/instance.state are what
  // ever the previously attempted to render - not the "current". However,
  // during componentDidUpdate we pass the "current" props.
  // In order to support react-lifecycles-compat polyfilled components,
  // Unsafe lifecycles should not be invoked for components using the new APIs.

  if (!hasNewLifecycles && (typeof instance.UNSAFE_componentWillReceiveProps === 'function' || typeof instance.componentWillReceiveProps === 'function')) {
    if (oldProps !== newProps || oldContext !== nextContext) {
      callComponentWillReceiveProps(workInProgress, instance, newProps, nextContext);
    }
  }

  resetHasForceUpdateBeforeProcessing();
  var oldState = workInProgress.memoizedState;
  var newState = instance.state = oldState;
  processUpdateQueue(workInProgress, newProps, instance, renderLanes);
  newState = workInProgress.memoizedState;

  if (oldProps === newProps && oldState === newState && !hasContextChanged() && !checkHasForceUpdateAfterProcessing()) {
    // If an update was already in progress, we should schedule an Update
    // effect even though we're bailing out, so that cWU/cDU are called.
    if (typeof instance.componentDidMount === 'function') {
      workInProgress.flags |= Update;
    }

    return false;
  }

  if (typeof getDerivedStateFromProps === 'function') {
    applyDerivedStateFromProps(workInProgress, ctor, getDerivedStateFromProps, newProps);
    newState = workInProgress.memoizedState;
  }

  var shouldUpdate = checkHasForceUpdateAfterProcessing() || checkShouldComponentUpdate(workInProgress, ctor, oldProps, newProps, oldState, newState, nextContext);

  if (shouldUpdate) {
    // In order to support react-lifecycles-compat polyfilled components,
    // Unsafe lifecycles should not be invoked for components using the new APIs.
    if (!hasNewLifecycles && (typeof instance.UNSAFE_componentWillMount === 'function' || typeof instance.componentWillMount === 'function')) {
      if (typeof instance.componentWillMount === 'function') {
        instance.componentWillMount();
      }

      if (typeof instance.UNSAFE_componentWillMount === 'function') {
        instance.UNSAFE_componentWillMount();
      }
    }

    if (typeof instance.componentDidMount === 'function') {
      workInProgress.flags |= Update;
    }
  } else {
    // If an update was already in progress, we should schedule an Update
    // effect even though we're bailing out, so that cWU/cDU are called.
    if (typeof instance.componentDidMount === 'function') {
      workInProgress.flags |= Update;
    } // If shouldComponentUpdate returned false, we should still update the
    // memoized state to indicate that this work can be reused.


    workInProgress.memoizedProps = newProps;
    workInProgress.memoizedState = newState;
  } // Update the existing instance's state, props, and context pointers even
  // if shouldComponentUpdate returns false.


  instance.props = newProps;
  instance.state = newState;
  instance.context = nextContext;
  return shouldUpdate;
} // Invokes the update life-cycles and returns false if it shouldn't rerender.


function updateClassInstance(current, workInProgress, ctor, newProps, renderLanes) {
  var instance = workInProgress.stateNode;
  cloneUpdateQueue(current, workInProgress);
  var unresolvedOldProps = workInProgress.memoizedProps;
  var oldProps = workInProgress.type === workInProgress.elementType ? unresolvedOldProps : resolveDefaultProps(workInProgress.type, unresolvedOldProps);
  instance.props = oldProps;
  var unresolvedNewProps = workInProgress.pendingProps;
  var oldContext = instance.context;
  var contextType = ctor.contextType;
  var nextContext = emptyContextObject;

  if (typeof contextType === 'object' && contextType !== null) {
    nextContext = readContext(contextType);
  } else {
    var nextUnmaskedContext = getUnmaskedContext(workInProgress, ctor, true);
    nextContext = getMaskedContext(workInProgress, nextUnmaskedContext);
  }

  var getDerivedStateFromProps = ctor.getDerivedStateFromProps;
  var hasNewLifecycles = typeof getDerivedStateFromProps === 'function' || typeof instance.getSnapshotBeforeUpdate === 'function'; // Note: During these life-cycles, instance.props/instance.state are what
  // ever the previously attempted to render - not the "current". However,
  // during componentDidUpdate we pass the "current" props.
  // In order to support react-lifecycles-compat polyfilled components,
  // Unsafe lifecycles should not be invoked for components using the new APIs.

  if (!hasNewLifecycles && (typeof instance.UNSAFE_componentWillReceiveProps === 'function' || typeof instance.componentWillReceiveProps === 'function')) {
    if (unresolvedOldProps !== unresolvedNewProps || oldContext !== nextContext) {
      callComponentWillReceiveProps(workInProgress, instance, newProps, nextContext);
    }
  }

  resetHasForceUpdateBeforeProcessing();
  var oldState = workInProgress.memoizedState;
  var newState = instance.state = oldState;
  processUpdateQueue(workInProgress, newProps, instance, renderLanes);
  newState = workInProgress.memoizedState;

  if (unresolvedOldProps === unresolvedNewProps && oldState === newState && !hasContextChanged() && !checkHasForceUpdateAfterProcessing()) {
    // If an update was already in progress, we should schedule an Update
    // effect even though we're bailing out, so that cWU/cDU are called.
    if (typeof instance.componentDidUpdate === 'function') {
      if (unresolvedOldProps !== current.memoizedProps || oldState !== current.memoizedState) {
        workInProgress.flags |= Update;
      }
    }

    if (typeof instance.getSnapshotBeforeUpdate === 'function') {
      if (unresolvedOldProps !== current.memoizedProps || oldState !== current.memoizedState) {
        workInProgress.flags |= Snapshot;
      }
    }

    return false;
  }

  if (typeof getDerivedStateFromProps === 'function') {
    applyDerivedStateFromProps(workInProgress, ctor, getDerivedStateFromProps, newProps);
    newState = workInProgress.memoizedState;
  }

  var shouldUpdate = checkHasForceUpdateAfterProcessing() || checkShouldComponentUpdate(workInProgress, ctor, oldProps, newProps, oldState, newState, nextContext);

  if (shouldUpdate) {
    // In order to support react-lifecycles-compat polyfilled components,
    // Unsafe lifecycles should not be invoked for components using the new APIs.
    if (!hasNewLifecycles && (typeof instance.UNSAFE_componentWillUpdate === 'function' || typeof instance.componentWillUpdate === 'function')) {
      if (typeof instance.componentWillUpdate === 'function') {
        instance.componentWillUpdate(newProps, newState, nextContext);
      }

      if (typeof instance.UNSAFE_componentWillUpdate === 'function') {
        instance.UNSAFE_componentWillUpdate(newProps, newState, nextContext);
      }
    }

    if (typeof instance.componentDidUpdate === 'function') {
      workInProgress.flags |= Update;
    }

    if (typeof instance.getSnapshotBeforeUpdate === 'function') {
      workInProgress.flags |= Snapshot;
    }
  } else {
    // If an update was already in progress, we should schedule an Update
    // effect even though we're bailing out, so that cWU/cDU are called.
    if (typeof instance.componentDidUpdate === 'function') {
      if (unresolvedOldProps !== current.memoizedProps || oldState !== current.memoizedState) {
        workInProgress.flags |= Update;
      }
    }

    if (typeof instance.getSnapshotBeforeUpdate === 'function') {
      if (unresolvedOldProps !== current.memoizedProps || oldState !== current.memoizedState) {
        workInProgress.flags |= Snapshot;
      }
    } // If shouldComponentUpdate returned false, we should still update the
    // memoized props/state to indicate that this work can be reused.


    workInProgress.memoizedProps = newProps;
    workInProgress.memoizedState = newState;
  } // Update the existing instance's state, props, and context pointers even
  // if shouldComponentUpdate returns false.


  instance.props = newProps;
  instance.state = newState;
  instance.context = nextContext;
  return shouldUpdate;
}

var didWarnAboutMaps;
var didWarnAboutGenerators;
var didWarnAboutStringRefs;
var ownerHasKeyUseWarning;
var ownerHasFunctionTypeWarning;

var warnForMissingKey = function (child, returnFiber) {};

{
  didWarnAboutMaps = false;
  didWarnAboutGenerators = false;
  didWarnAboutStringRefs = {};
  /**
   * Warn if there's no key explicitly set on dynamic arrays of children or
   * object keys are not valid. This allows us to keep track of children between
   * updates.
   */

  ownerHasKeyUseWarning = {};
  ownerHasFunctionTypeWarning = {};

  warnForMissingKey = function (child, returnFiber) {
    if (child === null || typeof child !== 'object') {
      return;
    }

    if (!child._store || child._store.validated || child.key != null) {
      return;
    }

    if (!(typeof child._store === 'object')) {
      {
        throw Error( "React Component in warnForMissingKey should have a _store. This error is likely caused by a bug in React. Please file an issue." );
      }
    }

    child._store.validated = true;
    var componentName = getComponentName(returnFiber.type) || 'Component';

    if (ownerHasKeyUseWarning[componentName]) {
      return;
    }

    ownerHasKeyUseWarning[componentName] = true;

    error('Each child in a list should have a unique ' + '"key" prop. See https://reactjs.org/link/warning-keys for ' + 'more information.');
  };
}

var isArray$1 = Array.isArray;

function coerceRef(returnFiber, current, element) {
  var mixedRef = element.ref;

  if (mixedRef !== null && typeof mixedRef !== 'function' && typeof mixedRef !== 'object') {
    {
      // TODO: Clean this up once we turn on the string ref warning for
      // everyone, because the strict mode case will no longer be relevant
      if ((returnFiber.mode & StrictMode || warnAboutStringRefs) && // We warn in ReactElement.js if owner and self are equal for string refs
      // because these cannot be automatically converted to an arrow function
      // using a codemod. Therefore, we don't have to warn about string refs again.
      !(element._owner && element._self && element._owner.stateNode !== element._self)) {
        var componentName = getComponentName(returnFiber.type) || 'Component';

        if (!didWarnAboutStringRefs[componentName]) {
          {
            error('A string ref, "%s", has been found within a strict mode tree. ' + 'String refs are a source of potential bugs and should be avoided. ' + 'We recommend using useRef() or createRef() instead. ' + 'Learn more about using refs safely here: ' + 'https://reactjs.org/link/strict-mode-string-ref', mixedRef);
          }

          didWarnAboutStringRefs[componentName] = true;
        }
      }
    }

    if (element._owner) {
      var owner = element._owner;
      var inst;

      if (owner) {
        var ownerFiber = owner;

        if (!(ownerFiber.tag === ClassComponent)) {
          {
            throw Error( "Function components cannot have string refs. We recommend using useRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref" );
          }
        }

        inst = ownerFiber.stateNode;
      }

      if (!inst) {
        {
          throw Error( "Missing owner for string ref " + mixedRef + ". This error is likely caused by a bug in React. Please file an issue." );
        }
      }

      var stringRef = '' + mixedRef; // Check if previous string ref matches new string ref

      if (current !== null && current.ref !== null && typeof current.ref === 'function' && current.ref._stringRef === stringRef) {
        return current.ref;
      }

      var ref = function (value) {
        var refs = inst.refs;

        if (refs === emptyRefsObject) {
          // This is a lazy pooled frozen object, so we need to initialize.
          refs = inst.refs = {};
        }

        if (value === null) {
          delete refs[stringRef];
        } else {
          refs[stringRef] = value;
        }
      };

      ref._stringRef = stringRef;
      return ref;
    } else {
      if (!(typeof mixedRef === 'string')) {
        {
          throw Error( "Expected ref to be a function, a string, an object returned by React.createRef(), or null." );
        }
      }

      if (!element._owner) {
        {
          throw Error( "Element ref was specified as a string (" + mixedRef + ") but no owner was set. This could happen for one of the following reasons:\n1. You may be adding a ref to a function component\n2. You may be adding a ref to a component that was not created inside a component's render method\n3. You have multiple copies of React loaded\nSee https://reactjs.org/link/refs-must-have-owner for more information." );
        }
      }
    }
  }

  return mixedRef;
}

function throwOnInvalidObjectType(returnFiber, newChild) {
  if (returnFiber.type !== 'textarea') {
    {
      {
        throw Error( "Objects are not valid as a React child (found: " + (Object.prototype.toString.call(newChild) === '[object Object]' ? 'object with keys {' + Object.keys(newChild).join(', ') + '}' : newChild) + "). If you meant to render a collection of children, use an array instead." );
      }
    }
  }
}

function warnOnFunctionType(returnFiber) {
  {
    var componentName = getComponentName(returnFiber.type) || 'Component';

    if (ownerHasFunctionTypeWarning[componentName]) {
      return;
    }

    ownerHasFunctionTypeWarning[componentName] = true;

    error('Functions are not valid as a React child. This may happen if ' + 'you return a Component instead of <Component /> from render. ' + 'Or maybe you meant to call this function rather than return it.');
  }
} // We avoid inlining this to avoid potential deopts from using try/catch.
// to be able to optimize each path individually by branching early. This needs
// a compiler or we can do it manually. Helpers that don't need this branching
// live outside of this function.


function ChildReconciler(shouldTrackSideEffects) {
  function deleteChild(returnFiber, childToDelete) {
    if (!shouldTrackSideEffects) {
      // Noop.
      return;
    } // Deletions are added in reversed order so we add it to the front.
    // At this point, the return fiber's effect list is empty except for
    // deletions, so we can just append the deletion to the list. The remaining
    // effects aren't added until the complete phase. Once we implement
    // resuming, this may not be true.


    var last = returnFiber.lastEffect;

    if (last !== null) {
      last.nextEffect = childToDelete;
      returnFiber.lastEffect = childToDelete;
    } else {
      returnFiber.firstEffect = returnFiber.lastEffect = childToDelete;
    }

    childToDelete.nextEffect = null;
    childToDelete.flags = Deletion;
  }

  function deleteRemainingChildren(returnFiber, currentFirstChild) {
    if (!shouldTrackSideEffects) {
      // Noop.
      return null;
    } // TODO: For the shouldClone case, this could be micro-optimized a bit by
    // assuming that after the first child we've already added everything.


    var childToDelete = currentFirstChild;

    while (childToDelete !== null) {
      deleteChild(returnFiber, childToDelete);
      childToDelete = childToDelete.sibling;
    }

    return null;
  }

  function mapRemainingChildren(returnFiber, currentFirstChild) {
    // Add the remaining children to a temporary map so that we can find them by
    // keys quickly. Implicit (null) keys get added to this set with their index
    // instead.
    var existingChildren = new Map();
    var existingChild = currentFirstChild;

    while (existingChild !== null) {
      if (existingChild.key !== null) {
        existingChildren.set(existingChild.key, existingChild);
      } else {
        existingChildren.set(existingChild.index, existingChild);
      }

      existingChild = existingChild.sibling;
    }

    return existingChildren;
  }

  function useFiber(fiber, pendingProps) {
    // We currently set sibling to null and index to 0 here because it is easy
    // to forget to do before returning it. E.g. for the single child case.
    var clone = createWorkInProgress(fiber, pendingProps);
    clone.index = 0;
    clone.sibling = null;
    return clone;
  }

  function placeChild(newFiber, lastPlacedIndex, newIndex) {
    newFiber.index = newIndex;

    if (!shouldTrackSideEffects) {
      // Noop.
      return lastPlacedIndex;
    }

    var current = newFiber.alternate;

    if (current !== null) {
      var oldIndex = current.index;

      if (oldIndex < lastPlacedIndex) {
        // This is a move.
        newFiber.flags = Placement;
        return lastPlacedIndex;
      } else {
        // This item can stay in place.
        return oldIndex;
      }
    } else {
      // This is an insertion.
      newFiber.flags = Placement;
      return lastPlacedIndex;
    }
  }

  function placeSingleChild(newFiber) {
    // This is simpler for the single child case. We only need to do a
    // placement for inserting new children.
    if (shouldTrackSideEffects && newFiber.alternate === null) {
      newFiber.flags = Placement;
    }

    return newFiber;
  }

  function updateTextNode(returnFiber, current, textContent, lanes) {
    if (current === null || current.tag !== HostText) {
      // Insert
      var created = createFiberFromText(textContent, returnFiber.mode, lanes);
      created.return = returnFiber;
      return created;
    } else {
      // Update
      var existing = useFiber(current, textContent);
      existing.return = returnFiber;
      return existing;
    }
  }

  function updateElement(returnFiber, current, element, lanes) {
    if (current !== null) {
      if (current.elementType === element.type || ( // Keep this check inline so it only runs on the false path:
       isCompatibleFamilyForHotReloading(current, element) )) {
        // Move based on index
        var existing = useFiber(current, element.props);
        existing.ref = coerceRef(returnFiber, current, element);
        existing.return = returnFiber;

        {
          existing._debugSource = element._source;
          existing._debugOwner = element._owner;
        }

        return existing;
      }
    } // Insert


    var created = createFiberFromElement(element, returnFiber.mode, lanes);
    created.ref = coerceRef(returnFiber, current, element);
    created.return = returnFiber;
    return created;
  }

  function updatePortal(returnFiber, current, portal, lanes) {
    if (current === null || current.tag !== HostPortal || current.stateNode.containerInfo !== portal.containerInfo || current.stateNode.implementation !== portal.implementation) {
      // Insert
      var created = createFiberFromPortal(portal, returnFiber.mode, lanes);
      created.return = returnFiber;
      return created;
    } else {
      // Update
      var existing = useFiber(current, portal.children || []);
      existing.return = returnFiber;
      return existing;
    }
  }

  function updateFragment(returnFiber, current, fragment, lanes, key) {
    if (current === null || current.tag !== Fragment) {
      // Insert
      var created = createFiberFromFragment(fragment, returnFiber.mode, lanes, key);
      created.return = returnFiber;
      return created;
    } else {
      // Update
      var existing = useFiber(current, fragment);
      existing.return = returnFiber;
      return existing;
    }
  }

  function createChild(returnFiber, newChild, lanes) {
    if (typeof newChild === 'string' || typeof newChild === 'number') {
      // Text nodes don't have keys. If the previous node is implicitly keyed
      // we can continue to replace it without aborting even if it is not a text
      // node.
      var created = createFiberFromText('' + newChild, returnFiber.mode, lanes);
      created.return = returnFiber;
      return created;
    }

    if (typeof newChild === 'object' && newChild !== null) {
      switch (newChild.$$typeof) {
        case REACT_ELEMENT_TYPE:
          {
            var _created = createFiberFromElement(newChild, returnFiber.mode, lanes);

            _created.ref = coerceRef(returnFiber, null, newChild);
            _created.return = returnFiber;
            return _created;
          }

        case REACT_PORTAL_TYPE:
          {
            var _created2 = createFiberFromPortal(newChild, returnFiber.mode, lanes);

            _created2.return = returnFiber;
            return _created2;
          }
      }

      if (isArray$1(newChild) || getIteratorFn(newChild)) {
        var _created3 = createFiberFromFragment(newChild, returnFiber.mode, lanes, null);

        _created3.return = returnFiber;
        return _created3;
      }

      throwOnInvalidObjectType(returnFiber, newChild);
    }

    {
      if (typeof newChild === 'function') {
        warnOnFunctionType(returnFiber);
      }
    }

    return null;
  }

  function updateSlot(returnFiber, oldFiber, newChild, lanes) {
    // Update the fiber if the keys match, otherwise return null.
    var key = oldFiber !== null ? oldFiber.key : null;

    if (typeof newChild === 'string' || typeof newChild === 'number') {
      // Text nodes don't have keys. If the previous node is implicitly keyed
      // we can continue to replace it without aborting even if it is not a text
      // node.
      if (key !== null) {
        return null;
      }

      return updateTextNode(returnFiber, oldFiber, '' + newChild, lanes);
    }

    if (typeof newChild === 'object' && newChild !== null) {
      switch (newChild.$$typeof) {
        case REACT_ELEMENT_TYPE:
          {
            if (newChild.key === key) {
              if (newChild.type === REACT_FRAGMENT_TYPE) {
                return updateFragment(returnFiber, oldFiber, newChild.props.children, lanes, key);
              }

              return updateElement(returnFiber, oldFiber, newChild, lanes);
            } else {
              return null;
            }
          }

        case REACT_PORTAL_TYPE:
          {
            if (newChild.key === key) {
              return updatePortal(returnFiber, oldFiber, newChild, lanes);
            } else {
              return null;
            }
          }
      }

      if (isArray$1(newChild) || getIteratorFn(newChild)) {
        if (key !== null) {
          return null;
        }

        return updateFragment(returnFiber, oldFiber, newChild, lanes, null);
      }

      throwOnInvalidObjectType(returnFiber, newChild);
    }

    {
      if (typeof newChild === 'function') {
        warnOnFunctionType(returnFiber);
      }
    }

    return null;
  }

  function updateFromMap(existingChildren, returnFiber, newIdx, newChild, lanes) {
    if (typeof newChild === 'string' || typeof newChild === 'number') {
      // Text nodes don't have keys, so we neither have to check the old nor
      // new node for the key. If both are text nodes, they match.
      var matchedFiber = existingChildren.get(newIdx) || null;
      return updateTextNode(returnFiber, matchedFiber, '' + newChild, lanes);
    }

    if (typeof newChild === 'object' && newChild !== null) {
      switch (newChild.$$typeof) {
        case REACT_ELEMENT_TYPE:
          {
            var _matchedFiber = existingChildren.get(newChild.key === null ? newIdx : newChild.key) || null;

            if (newChild.type === REACT_FRAGMENT_TYPE) {
              return updateFragment(returnFiber, _matchedFiber, newChild.props.children, lanes, newChild.key);
            }

            return updateElement(returnFiber, _matchedFiber, newChild, lanes);
          }

        case REACT_PORTAL_TYPE:
          {
            var _matchedFiber2 = existingChildren.get(newChild.key === null ? newIdx : newChild.key) || null;

            return updatePortal(returnFiber, _matchedFiber2, newChild, lanes);
          }

      }

      if (isArray$1(newChild) || getIteratorFn(newChild)) {
        var _matchedFiber3 = existingChildren.get(newIdx) || null;

        return updateFragment(returnFiber, _matchedFiber3, newChild, lanes, null);
      }

      throwOnInvalidObjectType(returnFiber, newChild);
    }

    {
      if (typeof newChild === 'function') {
        warnOnFunctionType(returnFiber);
      }
    }

    return null;
  }
  /**
   * Warns if there is a duplicate or missing key
   */


  function warnOnInvalidKey(child, knownKeys, returnFiber) {
    {
      if (typeof child !== 'object' || child === null) {
        return knownKeys;
      }

      switch (child.$$typeof) {
        case REACT_ELEMENT_TYPE:
        case REACT_PORTAL_TYPE:
          warnForMissingKey(child, returnFiber);
          var key = child.key;

          if (typeof key !== 'string') {
            break;
          }

          if (knownKeys === null) {
            knownKeys = new Set();
            knownKeys.add(key);
            break;
          }

          if (!knownKeys.has(key)) {
            knownKeys.add(key);
            break;
          }

          error('Encountered two children with the same key, `%s`. ' + 'Keys should be unique so that components maintain their identity ' + 'across updates. Non-unique keys may cause children to be ' + 'duplicated and/or omitted  the behavior is unsupported and ' + 'could change in a future version.', key);

          break;
      }
    }

    return knownKeys;
  }

  function reconcileChildrenArray(returnFiber, currentFirstChild, newChildren, lanes) {
    // This algorithm can't optimize by searching from both ends since we
    // don't have backpointers on fibers. I'm trying to see how far we can get
    // with that model. If it ends up not being worth the tradeoffs, we can
    // add it later.
    // Even with a two ended optimization, we'd want to optimize for the case
    // where there are few changes and brute force the comparison instead of
    // going for the Map. It'd like to explore hitting that path first in
    // forward-only mode and only go for the Map once we notice that we need
    // lots of look ahead. This doesn't handle reversal as well as two ended
    // search but that's unusual. Besides, for the two ended optimization to
    // work on Iterables, we'd need to copy the whole set.
    // In this first iteration, we'll just live with hitting the bad case
    // (adding everything to a Map) in for every insert/move.
    // If you change this code, also update reconcileChildrenIterator() which
    // uses the same algorithm.
    {
      // First, validate keys.
      var knownKeys = null;

      for (var i = 0; i < newChildren.length; i++) {
        var child = newChildren[i];
        knownKeys = warnOnInvalidKey(child, knownKeys, returnFiber);
      }
    }

    var resultingFirstChild = null;
    var previousNewFiber = null;
    var oldFiber = currentFirstChild;
    var lastPlacedIndex = 0;
    var newIdx = 0;
    var nextOldFiber = null;

    for (; oldFiber !== null && newIdx < newChildren.length; newIdx++) {
      if (oldFiber.index > newIdx) {
        nextOldFiber = oldFiber;
        oldFiber = null;
      } else {
        nextOldFiber = oldFiber.sibling;
      }

      var newFiber = updateSlot(returnFiber, oldFiber, newChildren[newIdx], lanes);

      if (newFiber === null) {
        // TODO: This breaks on empty slots like null children. That's
        // unfortunate because it triggers the slow path all the time. We need
        // a better way to communicate whether this was a miss or null,
        // boolean, undefined, etc.
        if (oldFiber === null) {
          oldFiber = nextOldFiber;
        }

        break;
      }

      if (shouldTrackSideEffects) {
        if (oldFiber && newFiber.alternate === null) {
          // We matched the slot, but we didn't reuse the existing fiber, so we
          // need to delete the existing child.
          deleteChild(returnFiber, oldFiber);
        }
      }

      lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);

      if (previousNewFiber === null) {
        // TODO: Move out of the loop. This only happens for the first run.
        resultingFirstChild = newFiber;
      } else {
        // TODO: Defer siblings if we're not at the right index for this slot.
        // I.e. if we had null values before, then we want to defer this
        // for each null value. However, we also don't want to call updateSlot
        // with the previous one.
        previousNewFiber.sibling = newFiber;
      }

      previousNewFiber = newFiber;
      oldFiber = nextOldFiber;
    }

    if (newIdx === newChildren.length) {
      // We've reached the end of the new children. We can delete the rest.
      deleteRemainingChildren(returnFiber, oldFiber);
      return resultingFirstChild;
    }

    if (oldFiber === null) {
      // If we don't have any more existing children we can choose a fast path
      // since the rest will all be insertions.
      for (; newIdx < newChildren.length; newIdx++) {
        var _newFiber = createChild(returnFiber, newChildren[newIdx], lanes);

        if (_newFiber === null) {
          continue;
        }

        lastPlacedIndex = placeChild(_newFiber, lastPlacedIndex, newIdx);

        if (previousNewFiber === null) {
          // TODO: Move out of the loop. This only happens for the first run.
          resultingFirstChild = _newFiber;
        } else {
          previousNewFiber.sibling = _newFiber;
        }

        previousNewFiber = _newFiber;
      }

      return resultingFirstChild;
    } // Add all children to a key map for quick lookups.


    var existingChildren = mapRemainingChildren(returnFiber, oldFiber); // Keep scanning and use the map to restore deleted items as moves.

    for (; newIdx < newChildren.length; newIdx++) {
      var _newFiber2 = updateFromMap(existingChildren, returnFiber, newIdx, newChildren[newIdx], lanes);

      if (_newFiber2 !== null) {
        if (shouldTrackSideEffects) {
          if (_newFiber2.alternate !== null) {
            // The new fiber is a work in progress, but if there exists a
            // current, that means that we reused the fiber. We need to delete
            // it from the child list so that we don't add it to the deletion
            // list.
            existingChildren.delete(_newFiber2.key === null ? newIdx : _newFiber2.key);
          }
        }

        lastPlacedIndex = placeChild(_newFiber2, lastPlacedIndex, newIdx);

        if (previousNewFiber === null) {
          resultingFirstChild = _newFiber2;
        } else {
          previousNewFiber.sibling = _newFiber2;
        }

        previousNewFiber = _newFiber2;
      }
    }

    if (shouldTrackSideEffects) {
      // Any existing children that weren't consumed above were deleted. We need
      // to add them to the deletion list.
      existingChildren.forEach(function (child) {
        return deleteChild(returnFiber, child);
      });
    }

    return resultingFirstChild;
  }

  function reconcileChildrenIterator(returnFiber, currentFirstChild, newChildrenIterable, lanes) {
    // This is the same implementation as reconcileChildrenArray(),
    // but using the iterator instead.
    var iteratorFn = getIteratorFn(newChildrenIterable);

    if (!(typeof iteratorFn === 'function')) {
      {
        throw Error( "An object is not an iterable. This error is likely caused by a bug in React. Please file an issue." );
      }
    }

    {
      // We don't support rendering Generators because it's a mutation.
      // See https://github.com/facebook/react/issues/12995
      if (typeof Symbol === 'function' && // $FlowFixMe Flow doesn't know about toStringTag
      newChildrenIterable[Symbol.toStringTag] === 'Generator') {
        if (!didWarnAboutGenerators) {
          error('Using Generators as children is unsupported and will likely yield ' + 'unexpected results because enumerating a generator mutates it. ' + 'You may convert it to an array with `Array.from()` or the ' + '`[...spread]` operator before rendering. Keep in mind ' + 'you might need to polyfill these features for older browsers.');
        }

        didWarnAboutGenerators = true;
      } // Warn about using Maps as children


      if (newChildrenIterable.entries === iteratorFn) {
        if (!didWarnAboutMaps) {
          error('Using Maps as children is not supported. ' + 'Use an array of keyed ReactElements instead.');
        }

        didWarnAboutMaps = true;
      } // First, validate keys.
      // We'll get a different iterator later for the main pass.


      var _newChildren = iteratorFn.call(newChildrenIterable);

      if (_newChildren) {
        var knownKeys = null;

        var _step = _newChildren.next();

        for (; !_step.done; _step = _newChildren.next()) {
          var child = _step.value;
          knownKeys = warnOnInvalidKey(child, knownKeys, returnFiber);
        }
      }
    }

    var newChildren = iteratorFn.call(newChildrenIterable);

    if (!(newChildren != null)) {
      {
        throw Error( "An iterable object provided no iterator." );
      }
    }

    var resultingFirstChild = null;
    var previousNewFiber = null;
    var oldFiber = currentFirstChild;
    var lastPlacedIndex = 0;
    var newIdx = 0;
    var nextOldFiber = null;
    var step = newChildren.next();

    for (; oldFiber !== null && !step.done; newIdx++, step = newChildren.next()) {
      if (oldFiber.index > newIdx) {
        nextOldFiber = oldFiber;
        oldFiber = null;
      } else {
        nextOldFiber = oldFiber.sibling;
      }

      var newFiber = updateSlot(returnFiber, oldFiber, step.value, lanes);

      if (newFiber === null) {
        // TODO: This breaks on empty slots like null children. That's
        // unfortunate because it triggers the slow path all the time. We need
        // a better way to communicate whether this was a miss or null,
        // boolean, undefined, etc.
        if (oldFiber === null) {
          oldFiber = nextOldFiber;
        }

        break;
      }

      if (shouldTrackSideEffects) {
        if (oldFiber && newFiber.alternate === null) {
          // We matched the slot, but we didn't reuse the existing fiber, so we
          // need to delete the existing child.
          deleteChild(returnFiber, oldFiber);
        }
      }

      lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);

      if (previousNewFiber === null) {
        // TODO: Move out of the loop. This only happens for the first run.
        resultingFirstChild = newFiber;
      } else {
        // TODO: Defer siblings if we're not at the right index for this slot.
        // I.e. if we had null values before, then we want to defer this
        // for each null value. However, we also don't want to call updateSlot
        // with the previous one.
        previousNewFiber.sibling = newFiber;
      }

      previousNewFiber = newFiber;
      oldFiber = nextOldFiber;
    }

    if (step.done) {
      // We've reached the end of the new children. We can delete the rest.
      deleteRemainingChildren(returnFiber, oldFiber);
      return resultingFirstChild;
    }

    if (oldFiber === null) {
      // If we don't have any more existing children we can choose a fast path
      // since the rest will all be insertions.
      for (; !step.done; newIdx++, step = newChildren.next()) {
        var _newFiber3 = createChild(returnFiber, step.value, lanes);

        if (_newFiber3 === null) {
          continue;
        }

        lastPlacedIndex = placeChild(_newFiber3, lastPlacedIndex, newIdx);

        if (previousNewFiber === null) {
          // TODO: Move out of the loop. This only happens for the first run.
          resultingFirstChild = _newFiber3;
        } else {
          previousNewFiber.sibling = _newFiber3;
        }

        previousNewFiber = _newFiber3;
      }

      return resultingFirstChild;
    } // Add all children to a key map for quick lookups.


    var existingChildren = mapRemainingChildren(returnFiber, oldFiber); // Keep scanning and use the map to restore deleted items as moves.

    for (; !step.done; newIdx++, step = newChildren.next()) {
      var _newFiber4 = updateFromMap(existingChildren, returnFiber, newIdx, step.value, lanes);

      if (_newFiber4 !== null) {
        if (shouldTrackSideEffects) {
          if (_newFiber4.alternate !== null) {
            // The new fiber is a work in progress, but if there exists a
            // current, that means that we reused the fiber. We need to delete
            // it from the child list so that we don't add it to the deletion
            // list.
            existingChildren.delete(_newFiber4.key === null ? newIdx : _newFiber4.key);
          }
        }

        lastPlacedIndex = placeChild(_newFiber4, lastPlacedIndex, newIdx);

        if (previousNewFiber === null) {
          resultingFirstChild = _newFiber4;
        } else {
          previousNewFiber.sibling = _newFiber4;
        }

        previousNewFiber = _newFiber4;
      }
    }

    if (shouldTrackSideEffects) {
      // Any existing children that weren't consumed above were deleted. We need
      // to add them to the deletion list.
      existingChildren.forEach(function (child) {
        return deleteChild(returnFiber, child);
      });
    }

    return resultingFirstChild;
  }

  function reconcileSingleTextNode(returnFiber, currentFirstChild, textContent, lanes) {
    // There's no need to check for keys on text nodes since we don't have a
    // way to define them.
    if (currentFirstChild !== null && currentFirstChild.tag === HostText) {
      // We already have an existing node so let's just update it and delete
      // the rest.
      deleteRemainingChildren(returnFiber, currentFirstChild.sibling);
      var existing = useFiber(currentFirstChild, textContent);
      existing.return = returnFiber;
      return existing;
    } // The existing first child is not a text node so we need to create one
    // and delete the existing ones.


    deleteRemainingChildren(returnFiber, currentFirstChild);
    var created = createFiberFromText(textContent, returnFiber.mode, lanes);
    created.return = returnFiber;
    return created;
  }

  function reconcileSingleElement(returnFiber, currentFirstChild, element, lanes) {
    var key = element.key;
    var child = currentFirstChild;

    while (child !== null) {
      // TODO: If key === null and child.key === null, then this only applies to
      // the first item in the list.
      if (child.key === key) {
        switch (child.tag) {
          case Fragment:
            {
              if (element.type === REACT_FRAGMENT_TYPE) {
                deleteRemainingChildren(returnFiber, child.sibling);
                var existing = useFiber(child, element.props.children);
                existing.return = returnFiber;

                {
                  existing._debugSource = element._source;
                  existing._debugOwner = element._owner;
                }

                return existing;
              }

              break;
            }

          case Block:

          // We intentionally fallthrough here if enableBlocksAPI is not on.
          // eslint-disable-next-lined no-fallthrough

          default:
            {
              if (child.elementType === element.type || ( // Keep this check inline so it only runs on the false path:
               isCompatibleFamilyForHotReloading(child, element) )) {
                deleteRemainingChildren(returnFiber, child.sibling);

                var _existing3 = useFiber(child, element.props);

                _existing3.ref = coerceRef(returnFiber, child, element);
                _existing3.return = returnFiber;

                {
                  _existing3._debugSource = element._source;
                  _existing3._debugOwner = element._owner;
                }

                return _existing3;
              }

              break;
            }
        } // Didn't match.


        deleteRemainingChildren(returnFiber, child);
        break;
      } else {
        deleteChild(returnFiber, child);
      }

      child = child.sibling;
    }

    if (element.type === REACT_FRAGMENT_TYPE) {
      var created = createFiberFromFragment(element.props.children, returnFiber.mode, lanes, element.key);
      created.return = returnFiber;
      return created;
    } else {
      var _created4 = createFiberFromElement(element, returnFiber.mode, lanes);

      _created4.ref = coerceRef(returnFiber, currentFirstChild, element);
      _created4.return = returnFiber;
      return _created4;
    }
  }

  function reconcileSinglePortal(returnFiber, currentFirstChild, portal, lanes) {
    var key = portal.key;
    var child = currentFirstChild;

    while (child !== null) {
      // TODO: If key === null and child.key === null, then this only applies to
      // the first item in the list.
      if (child.key === key) {
        if (child.tag === HostPortal && child.stateNode.containerInfo === portal.containerInfo && child.stateNode.implementation === portal.implementation) {
          deleteRemainingChildren(returnFiber, child.sibling);
          var existing = useFiber(child, portal.children || []);
          existing.return = returnFiber;
          return existing;
        } else {
          deleteRemainingChildren(returnFiber, child);
          break;
        }
      } else {
        deleteChild(returnFiber, child);
      }

      child = child.sibling;
    }

    var created = createFiberFromPortal(portal, returnFiber.mode, lanes);
    created.return = returnFiber;
    return created;
  } // This API will tag the children with the side-effect of the reconciliation
  // itself. They will be added to the side-effect list as we pass through the
  // children and the parent.


  function reconcileChildFibers(returnFiber, currentFirstChild, newChild, lanes) {
    // This function is not recursive.
    // If the top level item is an array, we treat it as a set of children,
    // not as a fragment. Nested arrays on the other hand will be treated as
    // fragment nodes. Recursion happens at the normal flow.
    // Handle top level unkeyed fragments as if they were arrays.
    // This leads to an ambiguity between <>{[...]}</> and <>...</>.
    // We treat the ambiguous cases above the same.
    var isUnkeyedTopLevelFragment = typeof newChild === 'object' && newChild !== null && newChild.type === REACT_FRAGMENT_TYPE && newChild.key === null;

    if (isUnkeyedTopLevelFragment) {
      newChild = newChild.props.children;
    } // Handle object types


    var isObject = typeof newChild === 'object' && newChild !== null;

    if (isObject) {
      switch (newChild.$$typeof) {
        case REACT_ELEMENT_TYPE:
          return placeSingleChild(reconcileSingleElement(returnFiber, currentFirstChild, newChild, lanes));

        case REACT_PORTAL_TYPE:
          return placeSingleChild(reconcileSinglePortal(returnFiber, currentFirstChild, newChild, lanes));

      }
    }

    if (typeof newChild === 'string' || typeof newChild === 'number') {
      return placeSingleChild(reconcileSingleTextNode(returnFiber, currentFirstChild, '' + newChild, lanes));
    }

    if (isArray$1(newChild)) {
      return reconcileChildrenArray(returnFiber, currentFirstChild, newChild, lanes);
    }

    if (getIteratorFn(newChild)) {
      return reconcileChildrenIterator(returnFiber, currentFirstChild, newChild, lanes);
    }

    if (isObject) {
      throwOnInvalidObjectType(returnFiber, newChild);
    }

    {
      if (typeof newChild === 'function') {
        warnOnFunctionType(returnFiber);
      }
    }

    if (typeof newChild === 'undefined' && !isUnkeyedTopLevelFragment) {
      // If the new child is undefined, and the return fiber is a composite
      // component, throw an error. If Fiber return types are disabled,
      // we already threw above.
      switch (returnFiber.tag) {
        case ClassComponent:
          {
            {
              var instance = returnFiber.stateNode;

              if (instance.render._isMockFunction) {
                // We allow auto-mocks to proceed as if they're returning null.
                break;
              }
            }
          }
        // Intentionally fall through to the next case, which handles both
        // functions and classes
        // eslint-disable-next-lined no-fallthrough

        case Block:
        case FunctionComponent:
        case ForwardRef:
        case SimpleMemoComponent:
          {
            {
              {
                throw Error( (getComponentName(returnFiber.type) || 'Component') + "(...): Nothing was returned from render. This usually means a return statement is missing. Or, to render nothing, return null." );
              }
            }
          }
      }
    } // Remaining cases are all treated as empty.


    return deleteRemainingChildren(returnFiber, currentFirstChild);
  }

  return reconcileChildFibers;
}

var reconcileChildFibers = ChildReconciler(true);
var mountChildFibers = ChildReconciler(false);
function cloneChildFibers(current, workInProgress) {
  if (!(current === null || workInProgress.child === current.child)) {
    {
      throw Error( "Resuming work not yet implemented." );
    }
  }

  if (workInProgress.child === null) {
    return;
  }

  var currentChild = workInProgress.child;
  var newChild = createWorkInProgress(currentChild, currentChild.pendingProps);
  workInProgress.child = newChild;
  newChild.return = workInProgress;

  while (currentChild.sibling !== null) {
    currentChild = currentChild.sibling;
    newChild = newChild.sibling = createWorkInProgress(currentChild, currentChild.pendingProps);
    newChild.return = workInProgress;
  }

  newChild.sibling = null;
} // Reset a workInProgress child set to prepare it for a second pass.

function resetChildFibers(workInProgress, lanes) {
  var child = workInProgress.child;

  while (child !== null) {
    resetWorkInProgress(child, lanes);
    child = child.sibling;
  }
}

var NO_CONTEXT = {};
var contextStackCursor$1 = createCursor(NO_CONTEXT);
var contextFiberStackCursor = createCursor(NO_CONTEXT);
var rootInstanceStackCursor = createCursor(NO_CONTEXT);

function requiredContext(c) {
  if (!(c !== NO_CONTEXT)) {
    {
      throw Error( "Expected host context to exist. This error is likely caused by a bug in React. Please file an issue." );
    }
  }

  return c;
}

function getRootHostContainer() {
  var rootInstance = requiredContext(rootInstanceStackCursor.current);
  return rootInstance;
}

function pushHostContainer(fiber, nextRootInstance) {
  // Push current root instance onto the stack;
  // This allows us to reset root when portals are popped.
  push(rootInstanceStackCursor, nextRootInstance, fiber); // Track the context and the Fiber that provided it.
  // This enables us to pop only Fibers that provide unique contexts.

  push(contextFiberStackCursor, fiber, fiber); // Finally, we need to push the host context to the stack.
  // However, we can't just call getRootHostContext() and push it because
  // we'd have a different number of entries on the stack depending on
  // whether getRootHostContext() throws somewhere in renderer code or not.
  // So we push an empty value first. This lets us safely unwind on errors.

  push(contextStackCursor$1, NO_CONTEXT, fiber);
  var nextRootContext = getRootHostContext(nextRootInstance); // Now that we know this function doesn't throw, replace it.

  pop(contextStackCursor$1, fiber);
  push(contextStackCursor$1, nextRootContext, fiber);
}

function popHostContainer(fiber) {
  pop(contextStackCursor$1, fiber);
  pop(contextFiberStackCursor, fiber);
  pop(rootInstanceStackCursor, fiber);
}

function getHostContext() {
  var context = requiredContext(contextStackCursor$1.current);
  return context;
}

function pushHostContext(fiber) {
  var rootInstance = requiredContext(rootInstanceStackCursor.current);
  var context = requiredContext(contextStackCursor$1.current);
  var nextContext = getChildHostContext(context, fiber.type); // Don't push this Fiber's context unless it's unique.

  if (context === nextContext) {
    return;
  } // Track the context and the Fiber that provided it.
  // This enables us to pop only Fibers that provide unique contexts.


  push(contextFiberStackCursor, fiber, fiber);
  push(contextStackCursor$1, nextContext, fiber);
}

function popHostContext(fiber) {
  // Do not pop unless this Fiber provided the current context.
  // pushHostContext() only pushes Fibers that provide unique contexts.
  if (contextFiberStackCursor.current !== fiber) {
    return;
  }

  pop(contextStackCursor$1, fiber);
  pop(contextFiberStackCursor, fiber);
}

var DefaultSuspenseContext = 0; // The Suspense Context is split into two parts. The lower bits is
// inherited deeply down the subtree. The upper bits only affect
// this immediate suspense boundary and gets reset each new
// boundary or suspense list.

var SubtreeSuspenseContextMask = 1; // Subtree Flags:
// InvisibleParentSuspenseContext indicates that one of our parent Suspense
// boundaries is not currently showing visible main content.
// Either because it is already showing a fallback or is not mounted at all.
// We can use this to determine if it is desirable to trigger a fallback at
// the parent. If not, then we might need to trigger undesirable boundaries
// and/or suspend the commit to avoid hiding the parent content.

var InvisibleParentSuspenseContext = 1; // Shallow Flags:
// ForceSuspenseFallback can be used by SuspenseList to force newly added
// items into their fallback state during one of the render passes.

var ForceSuspenseFallback = 2;
var suspenseStackCursor = createCursor(DefaultSuspenseContext);
function hasSuspenseContext(parentContext, flag) {
  return (parentContext & flag) !== 0;
}
function setDefaultShallowSuspenseContext(parentContext) {
  return parentContext & SubtreeSuspenseContextMask;
}
function setShallowSuspenseContext(parentContext, shallowContext) {
  return parentContext & SubtreeSuspenseContextMask | shallowContext;
}
function addSubtreeSuspenseContext(parentContext, subtreeContext) {
  return parentContext | subtreeContext;
}
function pushSuspenseContext(fiber, newContext) {
  push(suspenseStackCursor, newContext, fiber);
}
function popSuspenseContext(fiber) {
  pop(suspenseStackCursor, fiber);
}

function shouldCaptureSuspense(workInProgress, hasInvisibleParent) {
  // If it was the primary children that just suspended, capture and render the
  // fallback. Otherwise, don't capture and bubble to the next boundary.
  var nextState = workInProgress.memoizedState;

  if (nextState !== null) {
    if (nextState.dehydrated !== null) {
      // A dehydrated boundary always captures.
      return true;
    }

    return false;
  }

  var props = workInProgress.memoizedProps; // In order to capture, the Suspense component must have a fallback prop.

  if (props.fallback === undefined) {
    return false;
  } // Regular boundaries always capture.


  if (props.unstable_avoidThisFallback !== true) {
    return true;
  } // If it's a boundary we should avoid, then we prefer to bubble up to the
  // parent boundary if it is currently invisible.


  if (hasInvisibleParent) {
    return false;
  } // If the parent is not able to handle it, we must handle it.


  return true;
}
function findFirstSuspended(row) {
  var node = row;

  while (node !== null) {
    if (node.tag === SuspenseComponent) {
      var state = node.memoizedState;

      if (state !== null) {
        var dehydrated = state.dehydrated;

        if (dehydrated === null || isSuspenseInstancePending(dehydrated) || isSuspenseInstanceFallback(dehydrated)) {
          return node;
        }
      }
    } else if (node.tag === SuspenseListComponent && // revealOrder undefined can't be trusted because it don't
    // keep track of whether it suspended or not.
    node.memoizedProps.revealOrder !== undefined) {
      var didSuspend = (node.flags & DidCapture) !== NoFlags;

      if (didSuspend) {
        return node;
      }
    } else if (node.child !== null) {
      node.child.return = node;
      node = node.child;
      continue;
    }

    if (node === row) {
      return null;
    }

    while (node.sibling === null) {
      if (node.return === null || node.return === row) {
        return null;
      }

      node = node.return;
    }

    node.sibling.return = node.return;
    node = node.sibling;
  }

  return null;
}

var NoFlags$1 =
/*  */
0; // Represents whether effect should fire.

var HasEffect =
/* */
1; // Represents the phase in which the effect (not the clean-up) fires.

var Layout =
/*    */
2;
var Passive$1 =
/*   */
4;

// This may have been an insertion or a hydration.

var hydrationParentFiber = null;
var nextHydratableInstance = null;
var isHydrating = false;

function enterHydrationState(fiber) {

  var parentInstance = fiber.stateNode.containerInfo;
  nextHydratableInstance = getFirstHydratableChild(parentInstance);
  hydrationParentFiber = fiber;
  isHydrating = true;
  return true;
}

function deleteHydratableInstance(returnFiber, instance) {
  {
    switch (returnFiber.tag) {
      case HostRoot:
        didNotHydrateContainerInstance(returnFiber.stateNode.containerInfo, instance);
        break;

      case HostComponent:
        didNotHydrateInstance(returnFiber.type, returnFiber.memoizedProps, returnFiber.stateNode, instance);
        break;
    }
  }

  var childToDelete = createFiberFromHostInstanceForDeletion();
  childToDelete.stateNode = instance;
  childToDelete.return = returnFiber;
  childToDelete.flags = Deletion; // This might seem like it belongs on progressedFirstDeletion. However,
  // these children are not part of the reconciliation list of children.
  // Even if we abort and rereconcile the children, that will try to hydrate
  // again and the nodes are still in the host tree so these will be
  // recreated.

  if (returnFiber.lastEffect !== null) {
    returnFiber.lastEffect.nextEffect = childToDelete;
    returnFiber.lastEffect = childToDelete;
  } else {
    returnFiber.firstEffect = returnFiber.lastEffect = childToDelete;
  }
}

function insertNonHydratedInstance(returnFiber, fiber) {
  fiber.flags = fiber.flags & ~Hydrating | Placement;

  {
    switch (returnFiber.tag) {
      case HostRoot:
        {
          var parentContainer = returnFiber.stateNode.containerInfo;

          switch (fiber.tag) {
            case HostComponent:
              var type = fiber.type;
              var props = fiber.pendingProps;
              didNotFindHydratableContainerInstance(parentContainer, type);
              break;

            case HostText:
              var text = fiber.pendingProps;
              didNotFindHydratableContainerTextInstance(parentContainer, text);
              break;
          }

          break;
        }

      case HostComponent:
        {
          var parentType = returnFiber.type;
          var parentProps = returnFiber.memoizedProps;
          var parentInstance = returnFiber.stateNode;

          switch (fiber.tag) {
            case HostComponent:
              var _type = fiber.type;
              var _props = fiber.pendingProps;
              didNotFindHydratableInstance(parentType, parentProps, parentInstance, _type);
              break;

            case HostText:
              var _text = fiber.pendingProps;
              didNotFindHydratableTextInstance(parentType, parentProps, parentInstance, _text);
              break;

            case SuspenseComponent:
              didNotFindHydratableSuspenseInstance(parentType, parentProps);
              break;
          }

          break;
        }

      default:
        return;
    }
  }
}

function tryHydrate(fiber, nextInstance) {
  switch (fiber.tag) {
    case HostComponent:
      {
        var type = fiber.type;
        var props = fiber.pendingProps;
        var instance = canHydrateInstance(nextInstance, type);

        if (instance !== null) {
          fiber.stateNode = instance;
          return true;
        }

        return false;
      }

    case HostText:
      {
        var text = fiber.pendingProps;
        var textInstance = canHydrateTextInstance(nextInstance, text);

        if (textInstance !== null) {
          fiber.stateNode = textInstance;
          return true;
        }

        return false;
      }

    case SuspenseComponent:
      {

        return false;
      }

    default:
      return false;
  }
}

function tryToClaimNextHydratableInstance(fiber) {
  if (!isHydrating) {
    return;
  }

  var nextInstance = nextHydratableInstance;

  if (!nextInstance) {
    // Nothing to hydrate. Make it an insertion.
    insertNonHydratedInstance(hydrationParentFiber, fiber);
    isHydrating = false;
    hydrationParentFiber = fiber;
    return;
  }

  var firstAttemptedInstance = nextInstance;

  if (!tryHydrate(fiber, nextInstance)) {
    // If we can't hydrate this instance let's try the next one.
    // We use this as a heuristic. It's based on intuition and not data so it
    // might be flawed or unnecessary.
    nextInstance = getNextHydratableSibling(firstAttemptedInstance);

    if (!nextInstance || !tryHydrate(fiber, nextInstance)) {
      // Nothing to hydrate. Make it an insertion.
      insertNonHydratedInstance(hydrationParentFiber, fiber);
      isHydrating = false;
      hydrationParentFiber = fiber;
      return;
    } // We matched the next one, we'll now assume that the first one was
    // superfluous and we'll delete it. Since we can't eagerly delete it
    // we'll have to schedule a deletion. To do that, this node needs a dummy
    // fiber associated with it.


    deleteHydratableInstance(hydrationParentFiber, firstAttemptedInstance);
  }

  hydrationParentFiber = fiber;
  nextHydratableInstance = getFirstHydratableChild(nextInstance);
}

function prepareToHydrateHostInstance(fiber, rootContainerInstance, hostContext) {

  var instance = fiber.stateNode;
  var updatePayload = hydrateInstance(instance, fiber.type, fiber.memoizedProps, rootContainerInstance, hostContext, fiber); // TODO: Type this specific to this type of component.

  fiber.updateQueue = updatePayload; // If the update payload indicates that there is a change or if there
  // is a new ref we mark this as an update.

  if (updatePayload !== null) {
    return true;
  }

  return false;
}

function prepareToHydrateHostTextInstance(fiber) {

  var textInstance = fiber.stateNode;
  var textContent = fiber.memoizedProps;
  var shouldUpdate = hydrateTextInstance(textInstance, textContent, fiber);

  {
    if (shouldUpdate) {
      // We assume that prepareToHydrateHostTextInstance is called in a context where the
      // hydration parent is the parent host component of this host text.
      var returnFiber = hydrationParentFiber;

      if (returnFiber !== null) {
        switch (returnFiber.tag) {
          case HostRoot:
            {
              var parentContainer = returnFiber.stateNode.containerInfo;
              didNotMatchHydratedContainerTextInstance(parentContainer, textInstance, textContent);
              break;
            }

          case HostComponent:
            {
              var parentType = returnFiber.type;
              var parentProps = returnFiber.memoizedProps;
              var parentInstance = returnFiber.stateNode;
              didNotMatchHydratedTextInstance(parentType, parentProps, parentInstance, textInstance, textContent);
              break;
            }
        }
      }
    }
  }

  return shouldUpdate;
}

function skipPastDehydratedSuspenseInstance(fiber) {

  var suspenseState = fiber.memoizedState;
  var suspenseInstance = suspenseState !== null ? suspenseState.dehydrated : null;

  if (!suspenseInstance) {
    {
      throw Error( "Expected to have a hydrated suspense instance. This error is likely caused by a bug in React. Please file an issue." );
    }
  }

  return getNextHydratableInstanceAfterSuspenseInstance(suspenseInstance);
}

function popToNextHostParent(fiber) {
  var parent = fiber.return;

  while (parent !== null && parent.tag !== HostComponent && parent.tag !== HostRoot && parent.tag !== SuspenseComponent) {
    parent = parent.return;
  }

  hydrationParentFiber = parent;
}

function popHydrationState(fiber) {

  if (fiber !== hydrationParentFiber) {
    // We're deeper than the current hydration context, inside an inserted
    // tree.
    return false;
  }

  if (!isHydrating) {
    // If we're not currently hydrating but we're in a hydration context, then
    // we were an insertion and now need to pop up reenter hydration of our
    // siblings.
    popToNextHostParent(fiber);
    isHydrating = true;
    return false;
  }

  var type = fiber.type; // If we have any remaining hydratable nodes, we need to delete them now.
  // We only do this deeper than head and body since they tend to have random
  // other nodes in them. We also ignore components with pure text content in
  // side of them.
  // TODO: Better heuristic.

  if (fiber.tag !== HostComponent || type !== 'head' && type !== 'body' && !shouldSetTextContent(type, fiber.memoizedProps)) {
    var nextInstance = nextHydratableInstance;

    while (nextInstance) {
      deleteHydratableInstance(fiber, nextInstance);
      nextInstance = getNextHydratableSibling(nextInstance);
    }
  }

  popToNextHostParent(fiber);

  if (fiber.tag === SuspenseComponent) {
    nextHydratableInstance = skipPastDehydratedSuspenseInstance(fiber);
  } else {
    nextHydratableInstance = hydrationParentFiber ? getNextHydratableSibling(fiber.stateNode) : null;
  }

  return true;
}

function resetHydrationState() {

  hydrationParentFiber = null;
  nextHydratableInstance = null;
  isHydrating = false;
}

function getIsHydrating() {
  return isHydrating;
}

// and should be reset before starting a new render.
// This tracks which mutable sources need to be reset after a render.

var workInProgressSources = [];
var rendererSigil$1;

{
  // Used to detect multiple renderers using the same mutable source.
  rendererSigil$1 = {};
}

function markSourceAsDirty(mutableSource) {
  workInProgressSources.push(mutableSource);
}
function resetWorkInProgressVersions() {
  for (var i = 0; i < workInProgressSources.length; i++) {
    var mutableSource = workInProgressSources[i];

    {
      mutableSource._workInProgressVersionPrimary = null;
    }
  }

  workInProgressSources.length = 0;
}
function getWorkInProgressVersion(mutableSource) {
  {
    return mutableSource._workInProgressVersionPrimary;
  }
}
function setWorkInProgressVersion(mutableSource, version) {
  {
    mutableSource._workInProgressVersionPrimary = version;
  }

  workInProgressSources.push(mutableSource);
}
function warnAboutMultipleRenderersDEV(mutableSource) {
  {
    {
      if (mutableSource._currentPrimaryRenderer == null) {
        mutableSource._currentPrimaryRenderer = rendererSigil$1;
      } else if (mutableSource._currentPrimaryRenderer !== rendererSigil$1) {
        error('Detected multiple renderers concurrently rendering the ' + 'same mutable source. This is currently unsupported.');
      }
    }
  }
} // Eager reads the version of a mutable source and stores it on the root.

var ReactCurrentDispatcher$1 = ReactSharedInternals.ReactCurrentDispatcher,
    ReactCurrentBatchConfig$1 = ReactSharedInternals.ReactCurrentBatchConfig;
var didWarnAboutMismatchedHooksForComponent;
var didWarnAboutUseOpaqueIdentifier;

{
  didWarnAboutUseOpaqueIdentifier = {};
  didWarnAboutMismatchedHooksForComponent = new Set();
}

// These are set right before calling the component.
var renderLanes = NoLanes; // The work-in-progress fiber. I've named it differently to distinguish it from
// the work-in-progress hook.

var currentlyRenderingFiber$1 = null; // Hooks are stored as a linked list on the fiber's memoizedState field. The
// current hook list is the list that belongs to the current fiber. The
// work-in-progress hook list is a new list that will be added to the
// work-in-progress fiber.

var currentHook = null;
var workInProgressHook = null; // Whether an update was scheduled at any point during the render phase. This
// does not get reset if we do another render pass; only when we're completely
// finished evaluating this component. This is an optimization so we know
// whether we need to clear render phase updates after a throw.

var didScheduleRenderPhaseUpdate = false; // Where an update was scheduled only during the current render pass. This
// gets reset after each attempt.
// TODO: Maybe there's some way to consolidate this with
// `didScheduleRenderPhaseUpdate`. Or with `numberOfReRenders`.

var didScheduleRenderPhaseUpdateDuringThisPass = false;
var RE_RENDER_LIMIT = 25; // In DEV, this is the name of the currently executing primitive hook

var currentHookNameInDev = null; // In DEV, this list ensures that hooks are called in the same order between renders.
// The list stores the order of hooks used during the initial render (mount).
// Subsequent renders (updates) reference this list.

var hookTypesDev = null;
var hookTypesUpdateIndexDev = -1; // In DEV, this tracks whether currently rendering component needs to ignore
// the dependencies for Hooks that need them (e.g. useEffect or useMemo).
// When true, such Hooks will always be "remounted". Only used during hot reload.

var ignorePreviousDependencies = false;

function mountHookTypesDev() {
  {
    var hookName = currentHookNameInDev;

    if (hookTypesDev === null) {
      hookTypesDev = [hookName];
    } else {
      hookTypesDev.push(hookName);
    }
  }
}

function updateHookTypesDev() {
  {
    var hookName = currentHookNameInDev;

    if (hookTypesDev !== null) {
      hookTypesUpdateIndexDev++;

      if (hookTypesDev[hookTypesUpdateIndexDev] !== hookName) {
        warnOnHookMismatchInDev(hookName);
      }
    }
  }
}

function checkDepsAreArrayDev(deps) {
  {
    if (deps !== undefined && deps !== null && !Array.isArray(deps)) {
      // Verify deps, but only on mount to avoid extra checks.
      // It's unlikely their type would change as usually you define them inline.
      error('%s received a final argument that is not an array (instead, received `%s`). When ' + 'specified, the final argument must be an array.', currentHookNameInDev, typeof deps);
    }
  }
}

function warnOnHookMismatchInDev(currentHookName) {
  {
    var componentName = getComponentName(currentlyRenderingFiber$1.type);

    if (!didWarnAboutMismatchedHooksForComponent.has(componentName)) {
      didWarnAboutMismatchedHooksForComponent.add(componentName);

      if (hookTypesDev !== null) {
        var table = '';
        var secondColumnStart = 30;

        for (var i = 0; i <= hookTypesUpdateIndexDev; i++) {
          var oldHookName = hookTypesDev[i];
          var newHookName = i === hookTypesUpdateIndexDev ? currentHookName : oldHookName;
          var row = i + 1 + ". " + oldHookName; // Extra space so second column lines up
          // lol @ IE not supporting String#repeat

          while (row.length < secondColumnStart) {
            row += ' ';
          }

          row += newHookName + '\n';
          table += row;
        }

        error('React has detected a change in the order of Hooks called by %s. ' + 'This will lead to bugs and errors if not fixed. ' + 'For more information, read the Rules of Hooks: https://reactjs.org/link/rules-of-hooks\n\n' + '   Previous render            Next render\n' + '   ------------------------------------------------------\n' + '%s' + '   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n', componentName, table);
      }
    }
  }
}

function throwInvalidHookError() {
  {
    {
      throw Error( "Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem." );
    }
  }
}

function areHookInputsEqual(nextDeps, prevDeps) {
  {
    if (ignorePreviousDependencies) {
      // Only true when this component is being hot reloaded.
      return false;
    }
  }

  if (prevDeps === null) {
    {
      error('%s received a final argument during this render, but not during ' + 'the previous render. Even though the final argument is optional, ' + 'its type cannot change between renders.', currentHookNameInDev);
    }

    return false;
  }

  {
    // Don't bother comparing lengths in prod because these arrays should be
    // passed inline.
    if (nextDeps.length !== prevDeps.length) {
      error('The final argument passed to %s changed size between renders. The ' + 'order and size of this array must remain constant.\n\n' + 'Previous: %s\n' + 'Incoming: %s', currentHookNameInDev, "[" + prevDeps.join(', ') + "]", "[" + nextDeps.join(', ') + "]");
    }
  }

  for (var i = 0; i < prevDeps.length && i < nextDeps.length; i++) {
    if (objectIs(nextDeps[i], prevDeps[i])) {
      continue;
    }

    return false;
  }

  return true;
}

function renderWithHooks(current, workInProgress, Component, props, secondArg, nextRenderLanes) {
  renderLanes = nextRenderLanes;
  currentlyRenderingFiber$1 = workInProgress;

  {
    hookTypesDev = current !== null ? current._debugHookTypes : null;
    hookTypesUpdateIndexDev = -1; // Used for hot reloading:

    ignorePreviousDependencies = current !== null && current.type !== workInProgress.type;
  }

  workInProgress.memoizedState = null;
  workInProgress.updateQueue = null;
  workInProgress.lanes = NoLanes; // The following should have already been reset
  // currentHook = null;
  // workInProgressHook = null;
  // didScheduleRenderPhaseUpdate = false;
  // TODO Warn if no hooks are used at all during mount, then some are used during update.
  // Currently we will identify the update render as a mount because memoizedState === null.
  // This is tricky because it's valid for certain types of components (e.g. React.lazy)
  // Using memoizedState to differentiate between mount/update only works if at least one stateful hook is used.
  // Non-stateful hooks (e.g. context) don't get added to memoizedState,
  // so memoizedState would be null during updates and mounts.

  {
    if (current !== null && current.memoizedState !== null) {
      ReactCurrentDispatcher$1.current = HooksDispatcherOnUpdateInDEV;
    } else if (hookTypesDev !== null) {
      // This dispatcher handles an edge case where a component is updating,
      // but no stateful hooks have been used.
      // We want to match the production code behavior (which will use HooksDispatcherOnMount),
      // but with the extra DEV validation to ensure hooks ordering hasn't changed.
      // This dispatcher does that.
      ReactCurrentDispatcher$1.current = HooksDispatcherOnMountWithHookTypesInDEV;
    } else {
      ReactCurrentDispatcher$1.current = HooksDispatcherOnMountInDEV;
    }
  }

  var children = Component(props, secondArg); // Check if there was a render phase update

  if (didScheduleRenderPhaseUpdateDuringThisPass) {
    // Keep rendering in a loop for as long as render phase updates continue to
    // be scheduled. Use a counter to prevent infinite loops.
    var numberOfReRenders = 0;

    do {
      didScheduleRenderPhaseUpdateDuringThisPass = false;

      if (!(numberOfReRenders < RE_RENDER_LIMIT)) {
        {
          throw Error( "Too many re-renders. React limits the number of renders to prevent an infinite loop." );
        }
      }

      numberOfReRenders += 1;

      {
        // Even when hot reloading, allow dependencies to stabilize
        // after first render to prevent infinite render phase updates.
        ignorePreviousDependencies = false;
      } // Start over from the beginning of the list


      currentHook = null;
      workInProgressHook = null;
      workInProgress.updateQueue = null;

      {
        // Also validate hook order for cascading updates.
        hookTypesUpdateIndexDev = -1;
      }

      ReactCurrentDispatcher$1.current =  HooksDispatcherOnRerenderInDEV ;
      children = Component(props, secondArg);
    } while (didScheduleRenderPhaseUpdateDuringThisPass);
  } // We can assume the previous dispatcher is always this one, since we set it
  // at the beginning of the render phase and there's no re-entrancy.


  ReactCurrentDispatcher$1.current = ContextOnlyDispatcher;

  {
    workInProgress._debugHookTypes = hookTypesDev;
  } // This check uses currentHook so that it works the same in DEV and prod bundles.
  // hookTypesDev could catch more cases (e.g. context) but only in DEV bundles.


  var didRenderTooFewHooks = currentHook !== null && currentHook.next !== null;
  renderLanes = NoLanes;
  currentlyRenderingFiber$1 = null;
  currentHook = null;
  workInProgressHook = null;

  {
    currentHookNameInDev = null;
    hookTypesDev = null;
    hookTypesUpdateIndexDev = -1;
  }

  didScheduleRenderPhaseUpdate = false;

  if (!!didRenderTooFewHooks) {
    {
      throw Error( "Rendered fewer hooks than expected. This may be caused by an accidental early return statement." );
    }
  }

  return children;
}
function bailoutHooks(current, workInProgress, lanes) {
  workInProgress.updateQueue = current.updateQueue;
  workInProgress.flags &= ~(Passive | Update);
  current.lanes = removeLanes(current.lanes, lanes);
}
function resetHooksAfterThrow() {
  // We can assume the previous dispatcher is always this one, since we set it
  // at the beginning of the render phase and there's no re-entrancy.
  ReactCurrentDispatcher$1.current = ContextOnlyDispatcher;

  if (didScheduleRenderPhaseUpdate) {
    // There were render phase updates. These are only valid for this render
    // phase, which we are now aborting. Remove the updates from the queues so
    // they do not persist to the next render. Do not remove updates from hooks
    // that weren't processed.
    //
    // Only reset the updates from the queue if it has a clone. If it does
    // not have a clone, that means it wasn't processed, and the updates were
    // scheduled before we entered the render phase.
    var hook = currentlyRenderingFiber$1.memoizedState;

    while (hook !== null) {
      var queue = hook.queue;

      if (queue !== null) {
        queue.pending = null;
      }

      hook = hook.next;
    }

    didScheduleRenderPhaseUpdate = false;
  }

  renderLanes = NoLanes;
  currentlyRenderingFiber$1 = null;
  currentHook = null;
  workInProgressHook = null;

  {
    hookTypesDev = null;
    hookTypesUpdateIndexDev = -1;
    currentHookNameInDev = null;
    isUpdatingOpaqueValueInRenderPhase = false;
  }

  didScheduleRenderPhaseUpdateDuringThisPass = false;
}

function mountWorkInProgressHook() {
  var hook = {
    memoizedState: null,
    baseState: null,
    baseQueue: null,
    queue: null,
    next: null
  };

  if (workInProgressHook === null) {
    // This is the first hook in the list
    currentlyRenderingFiber$1.memoizedState = workInProgressHook = hook;
  } else {
    // Append to the end of the list
    workInProgressHook = workInProgressHook.next = hook;
  }

  return workInProgressHook;
}

function updateWorkInProgressHook() {
  // This function is used both for updates and for re-renders triggered by a
  // render phase update. It assumes there is either a current hook we can
  // clone, or a work-in-progress hook from a previous render pass that we can
  // use as a base. When we reach the end of the base list, we must switch to
  // the dispatcher used for mounts.
  var nextCurrentHook;

  if (currentHook === null) {
    var current = currentlyRenderingFiber$1.alternate;

    if (current !== null) {
      nextCurrentHook = current.memoizedState;
    } else {
      nextCurrentHook = null;
    }
  } else {
    nextCurrentHook = currentHook.next;
  }

  var nextWorkInProgressHook;

  if (workInProgressHook === null) {
    nextWorkInProgressHook = currentlyRenderingFiber$1.memoizedState;
  } else {
    nextWorkInProgressHook = workInProgressHook.next;
  }

  if (nextWorkInProgressHook !== null) {
    // There's already a work-in-progress. Reuse it.
    workInProgressHook = nextWorkInProgressHook;
    nextWorkInProgressHook = workInProgressHook.next;
    currentHook = nextCurrentHook;
  } else {
    // Clone from the current hook.
    if (!(nextCurrentHook !== null)) {
      {
        throw Error( "Rendered more hooks than during the previous render." );
      }
    }

    currentHook = nextCurrentHook;
    var newHook = {
      memoizedState: currentHook.memoizedState,
      baseState: currentHook.baseState,
      baseQueue: currentHook.baseQueue,
      queue: currentHook.queue,
      next: null
    };

    if (workInProgressHook === null) {
      // This is the first hook in the list.
      currentlyRenderingFiber$1.memoizedState = workInProgressHook = newHook;
    } else {
      // Append to the end of the list.
      workInProgressHook = workInProgressHook.next = newHook;
    }
  }

  return workInProgressHook;
}

function createFunctionComponentUpdateQueue() {
  return {
    lastEffect: null
  };
}

function basicStateReducer(state, action) {
  // $FlowFixMe: Flow doesn't like mixed types
  return typeof action === 'function' ? action(state) : action;
}

function mountReducer(reducer, initialArg, init) {
  var hook = mountWorkInProgressHook();
  var initialState;

  if (init !== undefined) {
    initialState = init(initialArg);
  } else {
    initialState = initialArg;
  }

  hook.memoizedState = hook.baseState = initialState;
  var queue = hook.queue = {
    pending: null,
    dispatch: null,
    lastRenderedReducer: reducer,
    lastRenderedState: initialState
  };
  var dispatch = queue.dispatch = dispatchAction.bind(null, currentlyRenderingFiber$1, queue);
  return [hook.memoizedState, dispatch];
}

function updateReducer(reducer, initialArg, init) {
  var hook = updateWorkInProgressHook();
  var queue = hook.queue;

  if (!(queue !== null)) {
    {
      throw Error( "Should have a queue. This is likely a bug in React. Please file an issue." );
    }
  }

  queue.lastRenderedReducer = reducer;
  var current = currentHook; // The last rebase update that is NOT part of the base state.

  var baseQueue = current.baseQueue; // The last pending update that hasn't been processed yet.

  var pendingQueue = queue.pending;

  if (pendingQueue !== null) {
    // We have new updates that haven't been processed yet.
    // We'll add them to the base queue.
    if (baseQueue !== null) {
      // Merge the pending queue and the base queue.
      var baseFirst = baseQueue.next;
      var pendingFirst = pendingQueue.next;
      baseQueue.next = pendingFirst;
      pendingQueue.next = baseFirst;
    }

    {
      if (current.baseQueue !== baseQueue) {
        // Internal invariant that should never happen, but feasibly could in
        // the future if we implement resuming, or some form of that.
        error('Internal error: Expected work-in-progress queue to be a clone. ' + 'This is a bug in React.');
      }
    }

    current.baseQueue = baseQueue = pendingQueue;
    queue.pending = null;
  }

  if (baseQueue !== null) {
    // We have a queue to process.
    var first = baseQueue.next;
    var newState = current.baseState;
    var newBaseState = null;
    var newBaseQueueFirst = null;
    var newBaseQueueLast = null;
    var update = first;

    do {
      var updateLane = update.lane;

      if (!isSubsetOfLanes(renderLanes, updateLane)) {
        // Priority is insufficient. Skip this update. If this is the first
        // skipped update, the previous update/state is the new base
        // update/state.
        var clone = {
          lane: updateLane,
          action: update.action,
          eagerReducer: update.eagerReducer,
          eagerState: update.eagerState,
          next: null
        };

        if (newBaseQueueLast === null) {
          newBaseQueueFirst = newBaseQueueLast = clone;
          newBaseState = newState;
        } else {
          newBaseQueueLast = newBaseQueueLast.next = clone;
        } // Update the remaining priority in the queue.
        // TODO: Don't need to accumulate this. Instead, we can remove
        // renderLanes from the original lanes.


        currentlyRenderingFiber$1.lanes = mergeLanes(currentlyRenderingFiber$1.lanes, updateLane);
        markSkippedUpdateLanes(updateLane);
      } else {
        // This update does have sufficient priority.
        if (newBaseQueueLast !== null) {
          var _clone = {
            // This update is going to be committed so we never want uncommit
            // it. Using NoLane works because 0 is a subset of all bitmasks, so
            // this will never be skipped by the check above.
            lane: NoLane,
            action: update.action,
            eagerReducer: update.eagerReducer,
            eagerState: update.eagerState,
            next: null
          };
          newBaseQueueLast = newBaseQueueLast.next = _clone;
        } // Process this update.


        if (update.eagerReducer === reducer) {
          // If this update was processed eagerly, and its reducer matches the
          // current reducer, we can use the eagerly computed state.
          newState = update.eagerState;
        } else {
          var action = update.action;
          newState = reducer(newState, action);
        }
      }

      update = update.next;
    } while (update !== null && update !== first);

    if (newBaseQueueLast === null) {
      newBaseState = newState;
    } else {
      newBaseQueueLast.next = newBaseQueueFirst;
    } // Mark that the fiber performed work, but only if the new state is
    // different from the current state.


    if (!objectIs(newState, hook.memoizedState)) {
      markWorkInProgressReceivedUpdate();
    }

    hook.memoizedState = newState;
    hook.baseState = newBaseState;
    hook.baseQueue = newBaseQueueLast;
    queue.lastRenderedState = newState;
  }

  var dispatch = queue.dispatch;
  return [hook.memoizedState, dispatch];
}

function rerenderReducer(reducer, initialArg, init) {
  var hook = updateWorkInProgressHook();
  var queue = hook.queue;

  if (!(queue !== null)) {
    {
      throw Error( "Should have a queue. This is likely a bug in React. Please file an issue." );
    }
  }

  queue.lastRenderedReducer = reducer; // This is a re-render. Apply the new render phase updates to the previous
  // work-in-progress hook.

  var dispatch = queue.dispatch;
  var lastRenderPhaseUpdate = queue.pending;
  var newState = hook.memoizedState;

  if (lastRenderPhaseUpdate !== null) {
    // The queue doesn't persist past this render pass.
    queue.pending = null;
    var firstRenderPhaseUpdate = lastRenderPhaseUpdate.next;
    var update = firstRenderPhaseUpdate;

    do {
      // Process this render phase update. We don't have to check the
      // priority because it will always be the same as the current
      // render's.
      var action = update.action;
      newState = reducer(newState, action);
      update = update.next;
    } while (update !== firstRenderPhaseUpdate); // Mark that the fiber performed work, but only if the new state is
    // different from the current state.


    if (!objectIs(newState, hook.memoizedState)) {
      markWorkInProgressReceivedUpdate();
    }

    hook.memoizedState = newState; // Don't persist the state accumulated from the render phase updates to
    // the base state unless the queue is empty.
    // TODO: Not sure if this is the desired semantics, but it's what we
    // do for gDSFP. I can't remember why.

    if (hook.baseQueue === null) {
      hook.baseState = newState;
    }

    queue.lastRenderedState = newState;
  }

  return [newState, dispatch];
}

function readFromUnsubcribedMutableSource(root, source, getSnapshot) {
  {
    warnAboutMultipleRenderersDEV(source);
  }

  var getVersion = source._getVersion;
  var version = getVersion(source._source); // Is it safe for this component to read from this source during the current render?

  var isSafeToReadFromSource = false; // Check the version first.
  // If this render has already been started with a specific version,
  // we can use it alone to determine if we can safely read from the source.

  var currentRenderVersion = getWorkInProgressVersion(source);

  if (currentRenderVersion !== null) {
    // It's safe to read if the store hasn't been mutated since the last time
    // we read something.
    isSafeToReadFromSource = currentRenderVersion === version;
  } else {
    // If there's no version, then this is the first time we've read from the
    // source during the current render pass, so we need to do a bit more work.
    // What we need to determine is if there are any hooks that already
    // subscribed to the source, and if so, whether there are any pending
    // mutations that haven't been synchronized yet.
    //
    // If there are no pending mutations, then `root.mutableReadLanes` will be
    // empty, and we know we can safely read.
    //
    // If there *are* pending mutations, we may still be able to safely read
    // if the currently rendering lanes are inclusive of the pending mutation
    // lanes, since that guarantees that the value we're about to read from
    // the source is consistent with the values that we read during the most
    // recent mutation.
    isSafeToReadFromSource = isSubsetOfLanes(renderLanes, root.mutableReadLanes);

    if (isSafeToReadFromSource) {
      // If it's safe to read from this source during the current render,
      // store the version in case other components read from it.
      // A changed version number will let those components know to throw and restart the render.
      setWorkInProgressVersion(source, version);
    }
  }

  if (isSafeToReadFromSource) {
    var snapshot = getSnapshot(source._source);

    {
      if (typeof snapshot === 'function') {
        error('Mutable source should not return a function as the snapshot value. ' + 'Functions may close over mutable values and cause tearing.');
      }
    }

    return snapshot;
  } else {
    // This handles the special case of a mutable source being shared between renderers.
    // In that case, if the source is mutated between the first and second renderer,
    // The second renderer don't know that it needs to reset the WIP version during unwind,
    // (because the hook only marks sources as dirty if it's written to their WIP version).
    // That would cause this tear check to throw again and eventually be visible to the user.
    // We can avoid this infinite loop by explicitly marking the source as dirty.
    //
    // This can lead to tearing in the first renderer when it resumes,
    // but there's nothing we can do about that (short of throwing here and refusing to continue the render).
    markSourceAsDirty(source);

    {
      {
        throw Error( "Cannot read from mutable source during the current render without tearing. This is a bug in React. Please file an issue." );
      }
    }
  }
}

function useMutableSource(hook, source, getSnapshot, subscribe) {
  var root = getWorkInProgressRoot();

  if (!(root !== null)) {
    {
      throw Error( "Expected a work-in-progress root. This is a bug in React. Please file an issue." );
    }
  }

  var getVersion = source._getVersion;
  var version = getVersion(source._source);
  var dispatcher = ReactCurrentDispatcher$1.current; // eslint-disable-next-line prefer-const

  var _dispatcher$useState = dispatcher.useState(function () {
    return readFromUnsubcribedMutableSource(root, source, getSnapshot);
  }),
      currentSnapshot = _dispatcher$useState[0],
      setSnapshot = _dispatcher$useState[1];

  var snapshot = currentSnapshot; // Grab a handle to the state hook as well.
  // We use it to clear the pending update queue if we have a new source.

  var stateHook = workInProgressHook;
  var memoizedState = hook.memoizedState;
  var refs = memoizedState.refs;
  var prevGetSnapshot = refs.getSnapshot;
  var prevSource = memoizedState.source;
  var prevSubscribe = memoizedState.subscribe;
  var fiber = currentlyRenderingFiber$1;
  hook.memoizedState = {
    refs: refs,
    source: source,
    subscribe: subscribe
  }; // Sync the values needed by our subscription handler after each commit.

  dispatcher.useEffect(function () {
    refs.getSnapshot = getSnapshot; // Normally the dispatch function for a state hook never changes,
    // but this hook recreates the queue in certain cases  to avoid updates from stale sources.
    // handleChange() below needs to reference the dispatch function without re-subscribing,
    // so we use a ref to ensure that it always has the latest version.

    refs.setSnapshot = setSnapshot; // Check for a possible change between when we last rendered now.

    var maybeNewVersion = getVersion(source._source);

    if (!objectIs(version, maybeNewVersion)) {
      var maybeNewSnapshot = getSnapshot(source._source);

      {
        if (typeof maybeNewSnapshot === 'function') {
          error('Mutable source should not return a function as the snapshot value. ' + 'Functions may close over mutable values and cause tearing.');
        }
      }

      if (!objectIs(snapshot, maybeNewSnapshot)) {
        setSnapshot(maybeNewSnapshot);
        var lane = requestUpdateLane(fiber);
        markRootMutableRead(root, lane);
      } // If the source mutated between render and now,
      // there may be state updates already scheduled from the old source.
      // Entangle the updates so that they render in the same batch.


      markRootEntangled(root, root.mutableReadLanes);
    }
  }, [getSnapshot, source, subscribe]); // If we got a new source or subscribe function, re-subscribe in a passive effect.

  dispatcher.useEffect(function () {
    var handleChange = function () {
      var latestGetSnapshot = refs.getSnapshot;
      var latestSetSnapshot = refs.setSnapshot;

      try {
        latestSetSnapshot(latestGetSnapshot(source._source)); // Record a pending mutable source update with the same expiration time.

        var lane = requestUpdateLane(fiber);
        markRootMutableRead(root, lane);
      } catch (error) {
        // A selector might throw after a source mutation.
        // e.g. it might try to read from a part of the store that no longer exists.
        // In this case we should still schedule an update with React.
        // Worst case the selector will throw again and then an error boundary will handle it.
        latestSetSnapshot(function () {
          throw error;
        });
      }
    };

    var unsubscribe = subscribe(source._source, handleChange);

    {
      if (typeof unsubscribe !== 'function') {
        error('Mutable source subscribe function must return an unsubscribe function.');
      }
    }

    return unsubscribe;
  }, [source, subscribe]); // If any of the inputs to useMutableSource change, reading is potentially unsafe.
  //
  // If either the source or the subscription have changed we can't can't trust the update queue.
  // Maybe the source changed in a way that the old subscription ignored but the new one depends on.
  //
  // If the getSnapshot function changed, we also shouldn't rely on the update queue.
  // It's possible that the underlying source was mutated between the when the last "change" event fired,
  // and when the current render (with the new getSnapshot function) is processed.
  //
  // In both cases, we need to throw away pending updates (since they are no longer relevant)
  // and treat reading from the source as we do in the mount case.

  if (!objectIs(prevGetSnapshot, getSnapshot) || !objectIs(prevSource, source) || !objectIs(prevSubscribe, subscribe)) {
    // Create a new queue and setState method,
    // So if there are interleaved updates, they get pushed to the older queue.
    // When this becomes current, the previous queue and dispatch method will be discarded,
    // including any interleaving updates that occur.
    var newQueue = {
      pending: null,
      dispatch: null,
      lastRenderedReducer: basicStateReducer,
      lastRenderedState: snapshot
    };
    newQueue.dispatch = setSnapshot = dispatchAction.bind(null, currentlyRenderingFiber$1, newQueue);
    stateHook.queue = newQueue;
    stateHook.baseQueue = null;
    snapshot = readFromUnsubcribedMutableSource(root, source, getSnapshot);
    stateHook.memoizedState = stateHook.baseState = snapshot;
  }

  return snapshot;
}

function mountMutableSource(source, getSnapshot, subscribe) {
  var hook = mountWorkInProgressHook();
  hook.memoizedState = {
    refs: {
      getSnapshot: getSnapshot,
      setSnapshot: null
    },
    source: source,
    subscribe: subscribe
  };
  return useMutableSource(hook, source, getSnapshot, subscribe);
}

function updateMutableSource(source, getSnapshot, subscribe) {
  var hook = updateWorkInProgressHook();
  return useMutableSource(hook, source, getSnapshot, subscribe);
}

function mountState(initialState) {
  var hook = mountWorkInProgressHook();

  if (typeof initialState === 'function') {
    // $FlowFixMe: Flow doesn't like mixed types
    initialState = initialState();
  }

  hook.memoizedState = hook.baseState = initialState;
  var queue = hook.queue = {
    pending: null,
    dispatch: null,
    lastRenderedReducer: basicStateReducer,
    lastRenderedState: initialState
  };
  var dispatch = queue.dispatch = dispatchAction.bind(null, currentlyRenderingFiber$1, queue);
  return [hook.memoizedState, dispatch];
}

function updateState(initialState) {
  return updateReducer(basicStateReducer);
}

function rerenderState(initialState) {
  return rerenderReducer(basicStateReducer);
}

function pushEffect(tag, create, destroy, deps) {
  var effect = {
    tag: tag,
    create: create,
    destroy: destroy,
    deps: deps,
    // Circular
    next: null
  };
  var componentUpdateQueue = currentlyRenderingFiber$1.updateQueue;

  if (componentUpdateQueue === null) {
    componentUpdateQueue = createFunctionComponentUpdateQueue();
    currentlyRenderingFiber$1.updateQueue = componentUpdateQueue;
    componentUpdateQueue.lastEffect = effect.next = effect;
  } else {
    var lastEffect = componentUpdateQueue.lastEffect;

    if (lastEffect === null) {
      componentUpdateQueue.lastEffect = effect.next = effect;
    } else {
      var firstEffect = lastEffect.next;
      lastEffect.next = effect;
      effect.next = firstEffect;
      componentUpdateQueue.lastEffect = effect;
    }
  }

  return effect;
}

function mountRef(initialValue) {
  var hook = mountWorkInProgressHook();
  var ref = {
    current: initialValue
  };

  {
    Object.seal(ref);
  }

  hook.memoizedState = ref;
  return ref;
}

function updateRef(initialValue) {
  var hook = updateWorkInProgressHook();
  return hook.memoizedState;
}

function mountEffectImpl(fiberFlags, hookFlags, create, deps) {
  var hook = mountWorkInProgressHook();
  var nextDeps = deps === undefined ? null : deps;
  currentlyRenderingFiber$1.flags |= fiberFlags;
  hook.memoizedState = pushEffect(HasEffect | hookFlags, create, undefined, nextDeps);
}

function updateEffectImpl(fiberFlags, hookFlags, create, deps) {
  var hook = updateWorkInProgressHook();
  var nextDeps = deps === undefined ? null : deps;
  var destroy = undefined;

  if (currentHook !== null) {
    var prevEffect = currentHook.memoizedState;
    destroy = prevEffect.destroy;

    if (nextDeps !== null) {
      var prevDeps = prevEffect.deps;

      if (areHookInputsEqual(nextDeps, prevDeps)) {
        pushEffect(hookFlags, create, destroy, nextDeps);
        return;
      }
    }
  }

  currentlyRenderingFiber$1.flags |= fiberFlags;
  hook.memoizedState = pushEffect(HasEffect | hookFlags, create, destroy, nextDeps);
}

function mountEffect(create, deps) {
  {
    // $FlowExpectedError - jest isn't a global, and isn't recognized outside of tests
    if ('undefined' !== typeof jest) {
      warnIfNotCurrentlyActingEffectsInDEV(currentlyRenderingFiber$1);
    }
  }

  return mountEffectImpl(Update | Passive, Passive$1, create, deps);
}

function updateEffect(create, deps) {
  {
    // $FlowExpectedError - jest isn't a global, and isn't recognized outside of tests
    if ('undefined' !== typeof jest) {
      warnIfNotCurrentlyActingEffectsInDEV(currentlyRenderingFiber$1);
    }
  }

  return updateEffectImpl(Update | Passive, Passive$1, create, deps);
}

function mountLayoutEffect(create, deps) {
  return mountEffectImpl(Update, Layout, create, deps);
}

function updateLayoutEffect(create, deps) {
  return updateEffectImpl(Update, Layout, create, deps);
}

function imperativeHandleEffect(create, ref) {
  if (typeof ref === 'function') {
    var refCallback = ref;

    var _inst = create();

    refCallback(_inst);
    return function () {
      refCallback(null);
    };
  } else if (ref !== null && ref !== undefined) {
    var refObject = ref;

    {
      if (!refObject.hasOwnProperty('current')) {
        error('Expected useImperativeHandle() first argument to either be a ' + 'ref callback or React.createRef() object. Instead received: %s.', 'an object with keys {' + Object.keys(refObject).join(', ') + '}');
      }
    }

    var _inst2 = create();

    refObject.current = _inst2;
    return function () {
      refObject.current = null;
    };
  }
}

function mountImperativeHandle(ref, create, deps) {
  {
    if (typeof create !== 'function') {
      error('Expected useImperativeHandle() second argument to be a function ' + 'that creates a handle. Instead received: %s.', create !== null ? typeof create : 'null');
    }
  } // TODO: If deps are provided, should we skip comparing the ref itself?


  var effectDeps = deps !== null && deps !== undefined ? deps.concat([ref]) : null;
  return mountEffectImpl(Update, Layout, imperativeHandleEffect.bind(null, create, ref), effectDeps);
}

function updateImperativeHandle(ref, create, deps) {
  {
    if (typeof create !== 'function') {
      error('Expected useImperativeHandle() second argument to be a function ' + 'that creates a handle. Instead received: %s.', create !== null ? typeof create : 'null');
    }
  } // TODO: If deps are provided, should we skip comparing the ref itself?


  var effectDeps = deps !== null && deps !== undefined ? deps.concat([ref]) : null;
  return updateEffectImpl(Update, Layout, imperativeHandleEffect.bind(null, create, ref), effectDeps);
}

function mountDebugValue(value, formatterFn) {// This hook is normally a no-op.
  // The react-debug-hooks package injects its own implementation
  // so that e.g. DevTools can display custom hook values.
}

var updateDebugValue = mountDebugValue;

function mountCallback(callback, deps) {
  var hook = mountWorkInProgressHook();
  var nextDeps = deps === undefined ? null : deps;
  hook.memoizedState = [callback, nextDeps];
  return callback;
}

function updateCallback(callback, deps) {
  var hook = updateWorkInProgressHook();
  var nextDeps = deps === undefined ? null : deps;
  var prevState = hook.memoizedState;

  if (prevState !== null) {
    if (nextDeps !== null) {
      var prevDeps = prevState[1];

      if (areHookInputsEqual(nextDeps, prevDeps)) {
        return prevState[0];
      }
    }
  }

  hook.memoizedState = [callback, nextDeps];
  return callback;
}

function mountMemo(nextCreate, deps) {
  var hook = mountWorkInProgressHook();
  var nextDeps = deps === undefined ? null : deps;
  var nextValue = nextCreate();
  hook.memoizedState = [nextValue, nextDeps];
  return nextValue;
}

function updateMemo(nextCreate, deps) {
  var hook = updateWorkInProgressHook();
  var nextDeps = deps === undefined ? null : deps;
  var prevState = hook.memoizedState;

  if (prevState !== null) {
    // Assume these are defined. If they're not, areHookInputsEqual will warn.
    if (nextDeps !== null) {
      var prevDeps = prevState[1];

      if (areHookInputsEqual(nextDeps, prevDeps)) {
        return prevState[0];
      }
    }
  }

  var nextValue = nextCreate();
  hook.memoizedState = [nextValue, nextDeps];
  return nextValue;
}

function mountDeferredValue(value) {
  var _mountState = mountState(value),
      prevValue = _mountState[0],
      setValue = _mountState[1];

  mountEffect(function () {
    var prevTransition = ReactCurrentBatchConfig$1.transition;
    ReactCurrentBatchConfig$1.transition = 1;

    try {
      setValue(value);
    } finally {
      ReactCurrentBatchConfig$1.transition = prevTransition;
    }
  }, [value]);
  return prevValue;
}

function updateDeferredValue(value) {
  var _updateState = updateState(),
      prevValue = _updateState[0],
      setValue = _updateState[1];

  updateEffect(function () {
    var prevTransition = ReactCurrentBatchConfig$1.transition;
    ReactCurrentBatchConfig$1.transition = 1;

    try {
      setValue(value);
    } finally {
      ReactCurrentBatchConfig$1.transition = prevTransition;
    }
  }, [value]);
  return prevValue;
}

function rerenderDeferredValue(value) {
  var _rerenderState = rerenderState(),
      prevValue = _rerenderState[0],
      setValue = _rerenderState[1];

  updateEffect(function () {
    var prevTransition = ReactCurrentBatchConfig$1.transition;
    ReactCurrentBatchConfig$1.transition = 1;

    try {
      setValue(value);
    } finally {
      ReactCurrentBatchConfig$1.transition = prevTransition;
    }
  }, [value]);
  return prevValue;
}

function startTransition(setPending, callback) {
  var priorityLevel = getCurrentPriorityLevel();

  {
    runWithPriority$1(priorityLevel < UserBlockingPriority$2 ? UserBlockingPriority$2 : priorityLevel, function () {
      setPending(true);
    });
    runWithPriority$1(priorityLevel > NormalPriority$1 ? NormalPriority$1 : priorityLevel, function () {
      var prevTransition = ReactCurrentBatchConfig$1.transition;
      ReactCurrentBatchConfig$1.transition = 1;

      try {
        setPending(false);
        callback();
      } finally {
        ReactCurrentBatchConfig$1.transition = prevTransition;
      }
    });
  }
}

function mountTransition() {
  var _mountState2 = mountState(false),
      isPending = _mountState2[0],
      setPending = _mountState2[1]; // The `start` method can be stored on a ref, since `setPending`
  // never changes.


  var start = startTransition.bind(null, setPending);
  mountRef(start);
  return [start, isPending];
}

function updateTransition() {
  var _updateState2 = updateState(),
      isPending = _updateState2[0];

  var startRef = updateRef();
  var start = startRef.current;
  return [start, isPending];
}

function rerenderTransition() {
  var _rerenderState2 = rerenderState(),
      isPending = _rerenderState2[0];

  var startRef = updateRef();
  var start = startRef.current;
  return [start, isPending];
}

var isUpdatingOpaqueValueInRenderPhase = false;
function getIsUpdatingOpaqueValueInRenderPhaseInDEV() {
  {
    return isUpdatingOpaqueValueInRenderPhase;
  }
}

function warnOnOpaqueIdentifierAccessInDEV(fiber) {
  {
    // TODO: Should warn in effects and callbacks, too
    var name = getComponentName(fiber.type) || 'Unknown';

    if (getIsRendering() && !didWarnAboutUseOpaqueIdentifier[name]) {
      error('The object passed back from useOpaqueIdentifier is meant to be ' + 'passed through to attributes only. Do not read the ' + 'value directly.');

      didWarnAboutUseOpaqueIdentifier[name] = true;
    }
  }
}

function mountOpaqueIdentifier() {
  var makeId =  makeClientIdInDEV.bind(null, warnOnOpaqueIdentifierAccessInDEV.bind(null, currentlyRenderingFiber$1)) ;

  if (getIsHydrating()) {
    var didUpgrade = false;
    var fiber = currentlyRenderingFiber$1;

    var readValue = function () {
      if (!didUpgrade) {
        // Only upgrade once. This works even inside the render phase because
        // the update is added to a shared queue, which outlasts the
        // in-progress render.
        didUpgrade = true;

        {
          isUpdatingOpaqueValueInRenderPhase = true;
          setId(makeId());
          isUpdatingOpaqueValueInRenderPhase = false;
          warnOnOpaqueIdentifierAccessInDEV(fiber);
        }
      }

      {
        {
          throw Error( "The object passed back from useOpaqueIdentifier is meant to be passed through to attributes only. Do not read the value directly." );
        }
      }
    };

    var id = makeOpaqueHydratingObject(readValue);
    var setId = mountState(id)[1];

    if ((currentlyRenderingFiber$1.mode & BlockingMode) === NoMode) {
      currentlyRenderingFiber$1.flags |= Update | Passive;
      pushEffect(HasEffect | Passive$1, function () {
        setId(makeId());
      }, undefined, null);
    }

    return id;
  } else {
    var _id = makeId();

    mountState(_id);
    return _id;
  }
}

function updateOpaqueIdentifier() {
  var id = updateState()[0];
  return id;
}

function rerenderOpaqueIdentifier() {
  var id = rerenderState()[0];
  return id;
}

function dispatchAction(fiber, queue, action) {
  {
    if (typeof arguments[3] === 'function') {
      error("State updates from the useState() and useReducer() Hooks don't support the " + 'second callback argument. To execute a side effect after ' + 'rendering, declare it in the component body with useEffect().');
    }
  }

  var eventTime = requestEventTime();
  var lane = requestUpdateLane(fiber);
  var update = {
    lane: lane,
    action: action,
    eagerReducer: null,
    eagerState: null,
    next: null
  }; // Append the update to the end of the list.

  var pending = queue.pending;

  if (pending === null) {
    // This is the first update. Create a circular list.
    update.next = update;
  } else {
    update.next = pending.next;
    pending.next = update;
  }

  queue.pending = update;
  var alternate = fiber.alternate;

  if (fiber === currentlyRenderingFiber$1 || alternate !== null && alternate === currentlyRenderingFiber$1) {
    // This is a render phase update. Stash it in a lazily-created map of
    // queue -> linked list of updates. After this render pass, we'll restart
    // and apply the stashed updates on top of the work-in-progress hook.
    didScheduleRenderPhaseUpdateDuringThisPass = didScheduleRenderPhaseUpdate = true;
  } else {
    if (fiber.lanes === NoLanes && (alternate === null || alternate.lanes === NoLanes)) {
      // The queue is currently empty, which means we can eagerly compute the
      // next state before entering the render phase. If the new state is the
      // same as the current state, we may be able to bail out entirely.
      var lastRenderedReducer = queue.lastRenderedReducer;

      if (lastRenderedReducer !== null) {
        var prevDispatcher;

        {
          prevDispatcher = ReactCurrentDispatcher$1.current;
          ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
        }

        try {
          var currentState = queue.lastRenderedState;
          var eagerState = lastRenderedReducer(currentState, action); // Stash the eagerly computed state, and the reducer used to compute
          // it, on the update object. If the reducer hasn't changed by the
          // time we enter the render phase, then the eager state can be used
          // without calling the reducer again.

          update.eagerReducer = lastRenderedReducer;
          update.eagerState = eagerState;

          if (objectIs(eagerState, currentState)) {
            // Fast path. We can bail out without scheduling React to re-render.
            // It's still possible that we'll need to rebase this update later,
            // if the component re-renders for a different reason and by that
            // time the reducer has changed.
            return;
          }
        } catch (error) {// Suppress the error. It will throw again in the render phase.
        } finally {
          {
            ReactCurrentDispatcher$1.current = prevDispatcher;
          }
        }
      }
    }

    {
      // $FlowExpectedError - jest isn't a global, and isn't recognized outside of tests
      if ('undefined' !== typeof jest) {
        warnIfNotScopedWithMatchingAct(fiber);
        warnIfNotCurrentlyActingUpdatesInDev(fiber);
      }
    }

    scheduleUpdateOnFiber(fiber, lane, eventTime);
  }
}

var ContextOnlyDispatcher = {
  readContext: readContext,
  useCallback: throwInvalidHookError,
  useContext: throwInvalidHookError,
  useEffect: throwInvalidHookError,
  useImperativeHandle: throwInvalidHookError,
  useLayoutEffect: throwInvalidHookError,
  useMemo: throwInvalidHookError,
  useReducer: throwInvalidHookError,
  useRef: throwInvalidHookError,
  useState: throwInvalidHookError,
  useDebugValue: throwInvalidHookError,
  useDeferredValue: throwInvalidHookError,
  useTransition: throwInvalidHookError,
  useMutableSource: throwInvalidHookError,
  useOpaqueIdentifier: throwInvalidHookError,
  unstable_isNewReconciler: enableNewReconciler
};
var HooksDispatcherOnMountInDEV = null;
var HooksDispatcherOnMountWithHookTypesInDEV = null;
var HooksDispatcherOnUpdateInDEV = null;
var HooksDispatcherOnRerenderInDEV = null;
var InvalidNestedHooksDispatcherOnMountInDEV = null;
var InvalidNestedHooksDispatcherOnUpdateInDEV = null;
var InvalidNestedHooksDispatcherOnRerenderInDEV = null;

{
  var warnInvalidContextAccess = function () {
    error('Context can only be read while React is rendering. ' + 'In classes, you can read it in the render method or getDerivedStateFromProps. ' + 'In function components, you can read it directly in the function body, but not ' + 'inside Hooks like useReducer() or useMemo().');
  };

  var warnInvalidHookAccess = function () {
    error('Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. ' + 'You can only call Hooks at the top level of your React function. ' + 'For more information, see ' + 'https://reactjs.org/link/rules-of-hooks');
  };

  HooksDispatcherOnMountInDEV = {
    readContext: function (context, observedBits) {
      return readContext(context, observedBits);
    },
    useCallback: function (callback, deps) {
      currentHookNameInDev = 'useCallback';
      mountHookTypesDev();
      checkDepsAreArrayDev(deps);
      return mountCallback(callback, deps);
    },
    useContext: function (context, observedBits) {
      currentHookNameInDev = 'useContext';
      mountHookTypesDev();
      return readContext(context, observedBits);
    },
    useEffect: function (create, deps) {
      currentHookNameInDev = 'useEffect';
      mountHookTypesDev();
      checkDepsAreArrayDev(deps);
      return mountEffect(create, deps);
    },
    useImperativeHandle: function (ref, create, deps) {
      currentHookNameInDev = 'useImperativeHandle';
      mountHookTypesDev();
      checkDepsAreArrayDev(deps);
      return mountImperativeHandle(ref, create, deps);
    },
    useLayoutEffect: function (create, deps) {
      currentHookNameInDev = 'useLayoutEffect';
      mountHookTypesDev();
      checkDepsAreArrayDev(deps);
      return mountLayoutEffect(create, deps);
    },
    useMemo: function (create, deps) {
      currentHookNameInDev = 'useMemo';
      mountHookTypesDev();
      checkDepsAreArrayDev(deps);
      var prevDispatcher = ReactCurrentDispatcher$1.current;
      ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;

      try {
        return mountMemo(create, deps);
      } finally {
        ReactCurrentDispatcher$1.current = prevDispatcher;
      }
    },
    useReducer: function (reducer, initialArg, init) {
      currentHookNameInDev = 'useReducer';
      mountHookTypesDev();
      var prevDispatcher = ReactCurrentDispatcher$1.current;
      ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;

      try {
        return mountReducer(reducer, initialArg, init);
      } finally {
        ReactCurrentDispatcher$1.current = prevDispatcher;
      }
    },
    useRef: function (initialValue) {
      currentHookNameInDev = 'useRef';
      mountHookTypesDev();
      return mountRef(initialValue);
    },
    useState: function (initialState) {
      currentHookNameInDev = 'useState';
      mountHookTypesDev();
      var prevDispatcher = ReactCurrentDispatcher$1.current;
      ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;

      try {
        return mountState(initialState);
      } finally {
        ReactCurrentDispatcher$1.current = prevDispatcher;
      }
    },
    useDebugValue: function (value, formatterFn) {
      currentHookNameInDev = 'useDebugValue';
      mountHookTypesDev();
      return mountDebugValue();
    },
    useDeferredValue: function (value) {
      currentHookNameInDev = 'useDeferredValue';
      mountHookTypesDev();
      return mountDeferredValue(value);
    },
    useTransition: function () {
      currentHookNameInDev = 'useTransition';
      mountHookTypesDev();
      return mountTransition();
    },
    useMutableSource: function (source, getSnapshot, subscribe) {
      currentHookNameInDev = 'useMutableSource';
      mountHookTypesDev();
      return mountMutableSource(source, getSnapshot, subscribe);
    },
    useOpaqueIdentifier: function () {
      currentHookNameInDev = 'useOpaqueIdentifier';
      mountHookTypesDev();
      return mountOpaqueIdentifier();
    },
    unstable_isNewReconciler: enableNewReconciler
  };
  HooksDispatcherOnMountWithHookTypesInDEV = {
    readContext: function (context, observedBits) {
      return readContext(context, observedBits);
    },
    useCallback: function (callback, deps) {
      currentHookNameInDev = 'useCallback';
      updateHookTypesDev();
      return mountCallback(callback, deps);
    },
    useContext: function (context, observedBits) {
      currentHookNameInDev = 'useContext';
      updateHookTypesDev();
      return readContext(context, observedBits);
    },
    useEffect: function (create, deps) {
      currentHookNameInDev = 'useEffect';
      updateHookTypesDev();
      return mountEffect(create, deps);
    },
    useImperativeHandle: function (ref, create, deps) {
      currentHookNameInDev = 'useImperativeHandle';
      updateHookTypesDev();
      return mountImperativeHandle(ref, create, deps);
    },
    useLayoutEffect: function (create, deps) {
      currentHookNameInDev = 'useLayoutEffect';
      updateHookTypesDev();
      return mountLayoutEffect(create, deps);
    },
    useMemo: function (create, deps) {
      currentHookNameInDev = 'useMemo';
      updateHookTypesDev();
      var prevDispatcher = ReactCurrentDispatcher$1.current;
      ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;

      try {
        return mountMemo(create, deps);
      } finally {
        ReactCurrentDispatcher$1.current = prevDispatcher;
      }
    },
    useReducer: function (reducer, initialArg, init) {
      currentHookNameInDev = 'useReducer';
      updateHookTypesDev();
      var prevDispatcher = ReactCurrentDispatcher$1.current;
      ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;

      try {
        return mountReducer(reducer, initialArg, init);
      } finally {
        ReactCurrentDispatcher$1.current = prevDispatcher;
      }
    },
    useRef: function (initialValue) {
      currentHookNameInDev = 'useRef';
      updateHookTypesDev();
      return mountRef(initialValue);
    },
    useState: function (initialState) {
      currentHookNameInDev = 'useState';
      updateHookTypesDev();
      var prevDispatcher = ReactCurrentDispatcher$1.current;
      ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;

      try {
        return mountState(initialState);
      } finally {
        ReactCurrentDispatcher$1.current = prevDispatcher;
      }
    },
    useDebugValue: function (value, formatterFn) {
      currentHookNameInDev = 'useDebugValue';
      updateHookTypesDev();
      return mountDebugValue();
    },
    useDeferredValue: function (value) {
      currentHookNameInDev = 'useDeferredValue';
      updateHookTypesDev();
      return mountDeferredValue(value);
    },
    useTransition: function () {
      currentHookNameInDev = 'useTransition';
      updateHookTypesDev();
      return mountTransition();
    },
    useMutableSource: function (source, getSnapshot, subscribe) {
      currentHookNameInDev = 'useMutableSource';
      updateHookTypesDev();
      return mountMutableSource(source, getSnapshot, subscribe);
    },
    useOpaqueIdentifier: function () {
      currentHookNameInDev = 'useOpaqueIdentifier';
      updateHookTypesDev();
      return mountOpaqueIdentifier();
    },
    unstable_isNewReconciler: enableNewReconciler
  };
  HooksDispatcherOnUpdateInDEV = {
    readContext: function (context, observedBits) {
      return readContext(context, observedBits);
    },
    useCallback: function (callback, deps) {
      currentHookNameInDev = 'useCallback';
      updateHookTypesDev();
      return updateCallback(callback, deps);
    },
    useContext: function (context, observedBits) {
      currentHookNameInDev = 'useContext';
      updateHookTypesDev();
      return readContext(context, observedBits);
    },
    useEffect: function (create, deps) {
      currentHookNameInDev = 'useEffect';
      updateHookTypesDev();
      return updateEffect(create, deps);
    },
    useImperativeHandle: function (ref, create, deps) {
      currentHookNameInDev = 'useImperativeHandle';
      updateHookTypesDev();
      return updateImperativeHandle(ref, create, deps);
    },
    useLayoutEffect: function (create, deps) {
      currentHookNameInDev = 'useLayoutEffect';
      updateHookTypesDev();
      return updateLayoutEffect(create, deps);
    },
    useMemo: function (create, deps) {
      currentHookNameInDev = 'useMemo';
      updateHookTypesDev();
      var prevDispatcher = ReactCurrentDispatcher$1.current;
      ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;

      try {
        return updateMemo(create, deps);
      } finally {
        ReactCurrentDispatcher$1.current = prevDispatcher;
      }
    },
    useReducer: function (reducer, initialArg, init) {
      currentHookNameInDev = 'useReducer';
      updateHookTypesDev();
      var prevDispatcher = ReactCurrentDispatcher$1.current;
      ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;

      try {
        return updateReducer(reducer, initialArg, init);
      } finally {
        ReactCurrentDispatcher$1.current = prevDispatcher;
      }
    },
    useRef: function (initialValue) {
      currentHookNameInDev = 'useRef';
      updateHookTypesDev();
      return updateRef();
    },
    useState: function (initialState) {
      currentHookNameInDev = 'useState';
      updateHookTypesDev();
      var prevDispatcher = ReactCurrentDispatcher$1.current;
      ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;

      try {
        return updateState(initialState);
      } finally {
        ReactCurrentDispatcher$1.current = prevDispatcher;
      }
    },
    useDebugValue: function (value, formatterFn) {
      currentHookNameInDev = 'useDebugValue';
      updateHookTypesDev();
      return updateDebugValue();
    },
    useDeferredValue: function (value) {
      currentHookNameInDev = 'useDeferredValue';
      updateHookTypesDev();
      return updateDeferredValue(value);
    },
    useTransition: function () {
      currentHookNameInDev = 'useTransition';
      updateHookTypesDev();
      return updateTransition();
    },
    useMutableSource: function (source, getSnapshot, subscribe) {
      currentHookNameInDev = 'useMutableSource';
      updateHookTypesDev();
      return updateMutableSource(source, getSnapshot, subscribe);
    },
    useOpaqueIdentifier: function () {
      currentHookNameInDev = 'useOpaqueIdentifier';
      updateHookTypesDev();
      return updateOpaqueIdentifier();
    },
    unstable_isNewReconciler: enableNewReconciler
  };
  HooksDispatcherOnRerenderInDEV = {
    readContext: function (context, observedBits) {
      return readContext(context, observedBits);
    },
    useCallback: function (callback, deps) {
      currentHookNameInDev = 'useCallback';
      updateHookTypesDev();
      return updateCallback(callback, deps);
    },
    useContext: function (context, observedBits) {
      currentHookNameInDev = 'useContext';
      updateHookTypesDev();
      return readContext(context, observedBits);
    },
    useEffect: function (create, deps) {
      currentHookNameInDev = 'useEffect';
      updateHookTypesDev();
      return updateEffect(create, deps);
    },
    useImperativeHandle: function (ref, create, deps) {
      currentHookNameInDev = 'useImperativeHandle';
      updateHookTypesDev();
      return updateImperativeHandle(ref, create, deps);
    },
    useLayoutEffect: function (create, deps) {
      currentHookNameInDev = 'useLayoutEffect';
      updateHookTypesDev();
      return updateLayoutEffect(create, deps);
    },
    useMemo: function (create, deps) {
      currentHookNameInDev = 'useMemo';
      updateHookTypesDev();
      var prevDispatcher = ReactCurrentDispatcher$1.current;
      ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnRerenderInDEV;

      try {
        return updateMemo(create, deps);
      } finally {
        ReactCurrentDispatcher$1.current = prevDispatcher;
      }
    },
    useReducer: function (reducer, initialArg, init) {
      currentHookNameInDev = 'useReducer';
      updateHookTypesDev();
      var prevDispatcher = ReactCurrentDispatcher$1.current;
      ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnRerenderInDEV;

      try {
        return rerenderReducer(reducer, initialArg, init);
      } finally {
        ReactCurrentDispatcher$1.current = prevDispatcher;
      }
    },
    useRef: function (initialValue) {
      currentHookNameInDev = 'useRef';
      updateHookTypesDev();
      return updateRef();
    },
    useState: function (initialState) {
      currentHookNameInDev = 'useState';
      updateHookTypesDev();
      var prevDispatcher = ReactCurrentDispatcher$1.current;
      ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnRerenderInDEV;

      try {
        return rerenderState(initialState);
      } finally {
        ReactCurrentDispatcher$1.current = prevDispatcher;
      }
    },
    useDebugValue: function (value, formatterFn) {
      currentHookNameInDev = 'useDebugValue';
      updateHookTypesDev();
      return updateDebugValue();
    },
    useDeferredValue: function (value) {
      currentHookNameInDev = 'useDeferredValue';
      updateHookTypesDev();
      return rerenderDeferredValue(value);
    },
    useTransition: function () {
      currentHookNameInDev = 'useTransition';
      updateHookTypesDev();
      return rerenderTransition();
    },
    useMutableSource: function (source, getSnapshot, subscribe) {
      currentHookNameInDev = 'useMutableSource';
      updateHookTypesDev();
      return updateMutableSource(source, getSnapshot, subscribe);
    },
    useOpaqueIdentifier: function () {
      currentHookNameInDev = 'useOpaqueIdentifier';
      updateHookTypesDev();
      return rerenderOpaqueIdentifier();
    },
    unstable_isNewReconciler: enableNewReconciler
  };
  InvalidNestedHooksDispatcherOnMountInDEV = {
    readContext: function (context, observedBits) {
      warnInvalidContextAccess();
      return readContext(context, observedBits);
    },
    useCallback: function (callback, deps) {
      currentHookNameInDev = 'useCallback';
      warnInvalidHookAccess();
      mountHookTypesDev();
      return mountCallback(callback, deps);
    },
    useContext: function (context, observedBits) {
      currentHookNameInDev = 'useContext';
      warnInvalidHookAccess();
      mountHookTypesDev();
      return readContext(context, observedBits);
    },
    useEffect: function (create, deps) {
      currentHookNameInDev = 'useEffect';
      warnInvalidHookAccess();
      mountHookTypesDev();
      return mountEffect(create, deps);
    },
    useImperativeHandle: function (ref, create, deps) {
      currentHookNameInDev = 'useImperativeHandle';
      warnInvalidHookAccess();
      mountHookTypesDev();
      return mountImperativeHandle(ref, create, deps);
    },
    useLayoutEffect: function (create, deps) {
      currentHookNameInDev = 'useLayoutEffect';
      warnInvalidHookAccess();
      mountHookTypesDev();
      return mountLayoutEffect(create, deps);
    },
    useMemo: function (create, deps) {
      currentHookNameInDev = 'useMemo';
      warnInvalidHookAccess();
      mountHookTypesDev();
      var prevDispatcher = ReactCurrentDispatcher$1.current;
      ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;

      try {
        return mountMemo(create, deps);
      } finally {
        ReactCurrentDispatcher$1.current = prevDispatcher;
      }
    },
    useReducer: function (reducer, initialArg, init) {
      currentHookNameInDev = 'useReducer';
      warnInvalidHookAccess();
      mountHookTypesDev();
      var prevDispatcher = ReactCurrentDispatcher$1.current;
      ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;

      try {
        return mountReducer(reducer, initialArg, init);
      } finally {
        ReactCurrentDispatcher$1.current = prevDispatcher;
      }
    },
    useRef: function (initialValue) {
      currentHookNameInDev = 'useRef';
      warnInvalidHookAccess();
      mountHookTypesDev();
      return mountRef(initialValue);
    },
    useState: function (initialState) {
      currentHookNameInDev = 'useState';
      warnInvalidHookAccess();
      mountHookTypesDev();
      var prevDispatcher = ReactCurrentDispatcher$1.current;
      ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;

      try {
        return mountState(initialState);
      } finally {
        ReactCurrentDispatcher$1.current = prevDispatcher;
      }
    },
    useDebugValue: function (value, formatterFn) {
      currentHookNameInDev = 'useDebugValue';
      warnInvalidHookAccess();
      mountHookTypesDev();
      return mountDebugValue();
    },
    useDeferredValue: function (value) {
      currentHookNameInDev = 'useDeferredValue';
      warnInvalidHookAccess();
      mountHookTypesDev();
      return mountDeferredValue(value);
    },
    useTransition: function () {
      currentHookNameInDev = 'useTransition';
      warnInvalidHookAccess();
      mountHookTypesDev();
      return mountTransition();
    },
    useMutableSource: function (source, getSnapshot, subscribe) {
      currentHookNameInDev = 'useMutableSource';
      warnInvalidHookAccess();
      mountHookTypesDev();
      return mountMutableSource(source, getSnapshot, subscribe);
    },
    useOpaqueIdentifier: function () {
      currentHookNameInDev = 'useOpaqueIdentifier';
      warnInvalidHookAccess();
      mountHookTypesDev();
      return mountOpaqueIdentifier();
    },
    unstable_isNewReconciler: enableNewReconciler
  };
  InvalidNestedHooksDispatcherOnUpdateInDEV = {
    readContext: function (context, observedBits) {
      warnInvalidContextAccess();
      return readContext(context, observedBits);
    },
    useCallback: function (callback, deps) {
      currentHookNameInDev = 'useCallback';
      warnInvalidHookAccess();
      updateHookTypesDev();
      return updateCallback(callback, deps);
    },
    useContext: function (context, observedBits) {
      currentHookNameInDev = 'useContext';
      warnInvalidHookAccess();
      updateHookTypesDev();
      return readContext(context, observedBits);
    },
    useEffect: function (create, deps) {
      currentHookNameInDev = 'useEffect';
      warnInvalidHookAccess();
      updateHookTypesDev();
      return updateEffect(create, deps);
    },
    useImperativeHandle: function (ref, create, deps) {
      currentHookNameInDev = 'useImperativeHandle';
      warnInvalidHookAccess();
      updateHookTypesDev();
      return updateImperativeHandle(ref, create, deps);
    },
    useLayoutEffect: function (create, deps) {
      currentHookNameInDev = 'useLayoutEffect';
      warnInvalidHookAccess();
      updateHookTypesDev();
      return updateLayoutEffect(create, deps);
    },
    useMemo: function (create, deps) {
      currentHookNameInDev = 'useMemo';
      warnInvalidHookAccess();
      updateHookTypesDev();
      var prevDispatcher = ReactCurrentDispatcher$1.current;
      ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;

      try {
        return updateMemo(create, deps);
      } finally {
        ReactCurrentDispatcher$1.current = prevDispatcher;
      }
    },
    useReducer: function (reducer, initialArg, init) {
      currentHookNameInDev = 'useReducer';
      warnInvalidHookAccess();
      updateHookTypesDev();
      var prevDispatcher = ReactCurrentDispatcher$1.current;
      ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;

      try {
        return updateReducer(reducer, initialArg, init);
      } finally {
        ReactCurrentDispatcher$1.current = prevDispatcher;
      }
    },
    useRef: function (initialValue) {
      currentHookNameInDev = 'useRef';
      warnInvalidHookAccess();
      updateHookTypesDev();
      return updateRef();
    },
    useState: function (initialState) {
      currentHookNameInDev = 'useState';
      warnInvalidHookAccess();
      updateHookTypesDev();
      var prevDispatcher = ReactCurrentDispatcher$1.current;
      ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;

      try {
        return updateState(initialState);
      } finally {
        ReactCurrentDispatcher$1.current = prevDispatcher;
      }
    },
    useDebugValue: function (value, formatterFn) {
      currentHookNameInDev = 'useDebugValue';
      warnInvalidHookAccess();
      updateHookTypesDev();
      return updateDebugValue();
    },
    useDeferredValue: function (value) {
      currentHookNameInDev = 'useDeferredValue';
      warnInvalidHookAccess();
      updateHookTypesDev();
      return updateDeferredValue(value);
    },
    useTransition: function () {
      currentHookNameInDev = 'useTransition';
      warnInvalidHookAccess();
      updateHookTypesDev();
      return updateTransition();
    },
    useMutableSource: function (source, getSnapshot, subscribe) {
      currentHookNameInDev = 'useMutableSource';
      warnInvalidHookAccess();
      updateHookTypesDev();
      return updateMutableSource(source, getSnapshot, subscribe);
    },
    useOpaqueIdentifier: function () {
      currentHookNameInDev = 'useOpaqueIdentifier';
      warnInvalidHookAccess();
      updateHookTypesDev();
      return updateOpaqueIdentifier();
    },
    unstable_isNewReconciler: enableNewReconciler
  };
  InvalidNestedHooksDispatcherOnRerenderInDEV = {
    readContext: function (context, observedBits) {
      warnInvalidContextAccess();
      return readContext(context, observedBits);
    },
    useCallback: function (callback, deps) {
      currentHookNameInDev = 'useCallback';
      warnInvalidHookAccess();
      updateHookTypesDev();
      return updateCallback(callback, deps);
    },
    useContext: function (context, observedBits) {
      currentHookNameInDev = 'useContext';
      warnInvalidHookAccess();
      updateHookTypesDev();
      return readContext(context, observedBits);
    },
    useEffect: function (create, deps) {
      currentHookNameInDev = 'useEffect';
      warnInvalidHookAccess();
      updateHookTypesDev();
      return updateEffect(create, deps);
    },
    useImperativeHandle: function (ref, create, deps) {
      currentHookNameInDev = 'useImperativeHandle';
      warnInvalidHookAccess();
      updateHookTypesDev();
      return updateImperativeHandle(ref, create, deps);
    },
    useLayoutEffect: function (create, deps) {
      currentHookNameInDev = 'useLayoutEffect';
      warnInvalidHookAccess();
      updateHookTypesDev();
      return updateLayoutEffect(create, deps);
    },
    useMemo: function (create, deps) {
      currentHookNameInDev = 'useMemo';
      warnInvalidHookAccess();
      updateHookTypesDev();
      var prevDispatcher = ReactCurrentDispatcher$1.current;
      ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;

      try {
        return updateMemo(create, deps);
      } finally {
        ReactCurrentDispatcher$1.current = prevDispatcher;
      }
    },
    useReducer: function (reducer, initialArg, init) {
      currentHookNameInDev = 'useReducer';
      warnInvalidHookAccess();
      updateHookTypesDev();
      var prevDispatcher = ReactCurrentDispatcher$1.current;
      ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;

      try {
        return rerenderReducer(reducer, initialArg, init);
      } finally {
        ReactCurrentDispatcher$1.current = prevDispatcher;
      }
    },
    useRef: function (initialValue) {
      currentHookNameInDev = 'useRef';
      warnInvalidHookAccess();
      updateHookTypesDev();
      return updateRef();
    },
    useState: function (initialState) {
      currentHookNameInDev = 'useState';
      warnInvalidHookAccess();
      updateHookTypesDev();
      var prevDispatcher = ReactCurrentDispatcher$1.current;
      ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;

      try {
        return rerenderState(initialState);
      } finally {
        ReactCurrentDispatcher$1.current = prevDispatcher;
      }
    },
    useDebugValue: function (value, formatterFn) {
      currentHookNameInDev = 'useDebugValue';
      warnInvalidHookAccess();
      updateHookTypesDev();
      return updateDebugValue();
    },
    useDeferredValue: function (value) {
      currentHookNameInDev = 'useDeferredValue';
      warnInvalidHookAccess();
      updateHookTypesDev();
      return rerenderDeferredValue(value);
    },
    useTransition: function () {
      currentHookNameInDev = 'useTransition';
      warnInvalidHookAccess();
      updateHookTypesDev();
      return rerenderTransition();
    },
    useMutableSource: function (source, getSnapshot, subscribe) {
      currentHookNameInDev = 'useMutableSource';
      warnInvalidHookAccess();
      updateHookTypesDev();
      return updateMutableSource(source, getSnapshot, subscribe);
    },
    useOpaqueIdentifier: function () {
      currentHookNameInDev = 'useOpaqueIdentifier';
      warnInvalidHookAccess();
      updateHookTypesDev();
      return rerenderOpaqueIdentifier();
    },
    unstable_isNewReconciler: enableNewReconciler
  };
}

var now$1 = Scheduler.unstable_now;
var commitTime = 0;
var profilerStartTime = -1;

function getCommitTime() {
  return commitTime;
}

function recordCommitTime() {

  commitTime = now$1();
}

function startProfilerTimer(fiber) {

  profilerStartTime = now$1();

  if (fiber.actualStartTime < 0) {
    fiber.actualStartTime = now$1();
  }
}

function stopProfilerTimerIfRunning(fiber) {

  profilerStartTime = -1;
}

function stopProfilerTimerIfRunningAndRecordDelta(fiber, overrideBaseTime) {

  if (profilerStartTime >= 0) {
    var elapsedTime = now$1() - profilerStartTime;
    fiber.actualDuration += elapsedTime;

    if (overrideBaseTime) {
      fiber.selfBaseDuration = elapsedTime;
    }

    profilerStartTime = -1;
  }
}

function transferActualDuration(fiber) {
  // Transfer time spent rendering these children so we don't lose it
  // after we rerender. This is used as a helper in special cases
  // where we should count the work of multiple passes.
  var child = fiber.child;

  while (child) {
    fiber.actualDuration += child.actualDuration;
    child = child.sibling;
  }
}

var ReactCurrentOwner$1 = ReactSharedInternals.ReactCurrentOwner;
var didReceiveUpdate = false;
var didWarnAboutBadClass;
var didWarnAboutModulePatternComponent;
var didWarnAboutContextTypeOnFunctionComponent;
var didWarnAboutGetDerivedStateOnFunctionComponent;
var didWarnAboutFunctionRefs;
var didWarnAboutReassigningProps;
var didWarnAboutRevealOrder;
var didWarnAboutTailOptions;

{
  didWarnAboutBadClass = {};
  didWarnAboutModulePatternComponent = {};
  didWarnAboutContextTypeOnFunctionComponent = {};
  didWarnAboutGetDerivedStateOnFunctionComponent = {};
  didWarnAboutFunctionRefs = {};
  didWarnAboutReassigningProps = false;
  didWarnAboutRevealOrder = {};
  didWarnAboutTailOptions = {};
}

function reconcileChildren(current, workInProgress, nextChildren, renderLanes) {
  if (current === null) {
    // If this is a fresh new component that hasn't been rendered yet, we
    // won't update its child set by applying minimal side-effects. Instead,
    // we will add them all to the child before it gets rendered. That means
    // we can optimize this reconciliation pass by not tracking side-effects.
    workInProgress.child = mountChildFibers(workInProgress, null, nextChildren, renderLanes);
  } else {
    // If the current child is the same as the work in progress, it means that
    // we haven't yet started any work on these children. Therefore, we use
    // the clone algorithm to create a copy of all the current children.
    // If we had any progressed work already, that is invalid at this point so
    // let's throw it out.
    workInProgress.child = reconcileChildFibers(workInProgress, current.child, nextChildren, renderLanes);
  }
}

function forceUnmountCurrentAndReconcile(current, workInProgress, nextChildren, renderLanes) {
  // This function is fork of reconcileChildren. It's used in cases where we
  // want to reconcile without matching against the existing set. This has the
  // effect of all current children being unmounted; even if the type and key
  // are the same, the old child is unmounted and a new child is created.
  //
  // To do this, we're going to go through the reconcile algorithm twice. In
  // the first pass, we schedule a deletion for all the current children by
  // passing null.
  workInProgress.child = reconcileChildFibers(workInProgress, current.child, null, renderLanes); // In the second pass, we mount the new children. The trick here is that we
  // pass null in place of where we usually pass the current child set. This has
  // the effect of remounting all children regardless of whether their
  // identities match.

  workInProgress.child = reconcileChildFibers(workInProgress, null, nextChildren, renderLanes);
}

function updateForwardRef(current, workInProgress, Component, nextProps, renderLanes) {
  // TODO: current can be non-null here even if the component
  // hasn't yet mounted. This happens after the first render suspends.
  // We'll need to figure out if this is fine or can cause issues.
  {
    if (workInProgress.type !== workInProgress.elementType) {
      // Lazy component props can't be validated in createElement
      // because they're only guaranteed to be resolved here.
      var innerPropTypes = Component.propTypes;

      if (innerPropTypes) {
        checkPropTypes(innerPropTypes, nextProps, // Resolved props
        'prop', getComponentName(Component));
      }
    }
  }

  var render = Component.render;
  var ref = workInProgress.ref; // The rest is a fork of updateFunctionComponent

  var nextChildren;
  prepareToReadContext(workInProgress, renderLanes);

  {
    ReactCurrentOwner$1.current = workInProgress;
    setIsRendering(true);
    nextChildren = renderWithHooks(current, workInProgress, render, nextProps, ref, renderLanes);

    if ( workInProgress.mode & StrictMode) {
      disableLogs();

      try {
        nextChildren = renderWithHooks(current, workInProgress, render, nextProps, ref, renderLanes);
      } finally {
        reenableLogs();
      }
    }

    setIsRendering(false);
  }

  if (current !== null && !didReceiveUpdate) {
    bailoutHooks(current, workInProgress, renderLanes);
    return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);
  } // React DevTools reads this flag.


  workInProgress.flags |= PerformedWork;
  reconcileChildren(current, workInProgress, nextChildren, renderLanes);
  return workInProgress.child;
}

function updateMemoComponent(current, workInProgress, Component, nextProps, updateLanes, renderLanes) {
  if (current === null) {
    var type = Component.type;

    if (isSimpleFunctionComponent(type) && Component.compare === null && // SimpleMemoComponent codepath doesn't resolve outer props either.
    Component.defaultProps === undefined) {
      var resolvedType = type;

      {
        resolvedType = resolveFunctionForHotReloading(type);
      } // If this is a plain function component without default props,
      // and with only the default shallow comparison, we upgrade it
      // to a SimpleMemoComponent to allow fast path updates.


      workInProgress.tag = SimpleMemoComponent;
      workInProgress.type = resolvedType;

      {
        validateFunctionComponentInDev(workInProgress, type);
      }

      return updateSimpleMemoComponent(current, workInProgress, resolvedType, nextProps, updateLanes, renderLanes);
    }

    {
      var innerPropTypes = type.propTypes;

      if (innerPropTypes) {
        // Inner memo component props aren't currently validated in createElement.
        // We could move it there, but we'd still need this for lazy code path.
        checkPropTypes(innerPropTypes, nextProps, // Resolved props
        'prop', getComponentName(type));
      }
    }

    var child = createFiberFromTypeAndProps(Component.type, null, nextProps, workInProgress, workInProgress.mode, renderLanes);
    child.ref = workInProgress.ref;
    child.return = workInProgress;
    workInProgress.child = child;
    return child;
  }

  {
    var _type = Component.type;
    var _innerPropTypes = _type.propTypes;

    if (_innerPropTypes) {
      // Inner memo component props aren't currently validated in createElement.
      // We could move it there, but we'd still need this for lazy code path.
      checkPropTypes(_innerPropTypes, nextProps, // Resolved props
      'prop', getComponentName(_type));
    }
  }

  var currentChild = current.child; // This is always exactly one child

  if (!includesSomeLane(updateLanes, renderLanes)) {
    // This will be the props with resolved defaultProps,
    // unlike current.memoizedProps which will be the unresolved ones.
    var prevProps = currentChild.memoizedProps; // Default to shallow comparison

    var compare = Component.compare;
    compare = compare !== null ? compare : shallowEqual;

    if (compare(prevProps, nextProps) && current.ref === workInProgress.ref) {
      return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);
    }
  } // React DevTools reads this flag.


  workInProgress.flags |= PerformedWork;
  var newChild = createWorkInProgress(currentChild, nextProps);
  newChild.ref = workInProgress.ref;
  newChild.return = workInProgress;
  workInProgress.child = newChild;
  return newChild;
}

function updateSimpleMemoComponent(current, workInProgress, Component, nextProps, updateLanes, renderLanes) {
  // TODO: current can be non-null here even if the component
  // hasn't yet mounted. This happens when the inner render suspends.
  // We'll need to figure out if this is fine or can cause issues.
  {
    if (workInProgress.type !== workInProgress.elementType) {
      // Lazy component props can't be validated in createElement
      // because they're only guaranteed to be resolved here.
      var outerMemoType = workInProgress.elementType;

      if (outerMemoType.$$typeof === REACT_LAZY_TYPE) {
        // We warn when you define propTypes on lazy()
        // so let's just skip over it to find memo() outer wrapper.
        // Inner props for memo are validated later.
        var lazyComponent = outerMemoType;
        var payload = lazyComponent._payload;
        var init = lazyComponent._init;

        try {
          outerMemoType = init(payload);
        } catch (x) {
          outerMemoType = null;
        } // Inner propTypes will be validated in the function component path.


        var outerPropTypes = outerMemoType && outerMemoType.propTypes;

        if (outerPropTypes) {
          checkPropTypes(outerPropTypes, nextProps, // Resolved (SimpleMemoComponent has no defaultProps)
          'prop', getComponentName(outerMemoType));
        }
      }
    }
  }

  if (current !== null) {
    var prevProps = current.memoizedProps;

    if (shallowEqual(prevProps, nextProps) && current.ref === workInProgress.ref && ( // Prevent bailout if the implementation changed due to hot reload.
     workInProgress.type === current.type )) {
      didReceiveUpdate = false;

      if (!includesSomeLane(renderLanes, updateLanes)) {
        // The pending lanes were cleared at the beginning of beginWork. We're
        // about to bail out, but there might be other lanes that weren't
        // included in the current render. Usually, the priority level of the
        // remaining updates is accumlated during the evaluation of the
        // component (i.e. when processing the update queue). But since since
        // we're bailing out early *without* evaluating the component, we need
        // to account for it here, too. Reset to the value of the current fiber.
        // NOTE: This only applies to SimpleMemoComponent, not MemoComponent,
        // because a MemoComponent fiber does not have hooks or an update queue;
        // rather, it wraps around an inner component, which may or may not
        // contains hooks.
        // TODO: Move the reset at in beginWork out of the common path so that
        // this is no longer necessary.
        workInProgress.lanes = current.lanes;
        return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);
      } else if ((current.flags & ForceUpdateForLegacySuspense) !== NoFlags) {
        // This is a special case that only exists for legacy mode.
        // See https://github.com/facebook/react/pull/19216.
        didReceiveUpdate = true;
      }
    }
  }

  return updateFunctionComponent(current, workInProgress, Component, nextProps, renderLanes);
}

function updateOffscreenComponent(current, workInProgress, renderLanes) {
  var nextProps = workInProgress.pendingProps;
  var nextChildren = nextProps.children;
  var prevState = current !== null ? current.memoizedState : null;

  if (nextProps.mode === 'hidden' || nextProps.mode === 'unstable-defer-without-hiding') {
    if ((workInProgress.mode & ConcurrentMode) === NoMode) {
      // In legacy sync mode, don't defer the subtree. Render it now.
      // TODO: Figure out what we should do in Blocking mode.
      var nextState = {
        baseLanes: NoLanes
      };
      workInProgress.memoizedState = nextState;
      pushRenderLanes(workInProgress, renderLanes);
    } else if (!includesSomeLane(renderLanes, OffscreenLane)) {
      var nextBaseLanes;

      if (prevState !== null) {
        var prevBaseLanes = prevState.baseLanes;
        nextBaseLanes = mergeLanes(prevBaseLanes, renderLanes);
      } else {
        nextBaseLanes = renderLanes;
      } // Schedule this fiber to re-render at offscreen priority. Then bailout.


      {
        markSpawnedWork(OffscreenLane);
      }

      workInProgress.lanes = workInProgress.childLanes = laneToLanes(OffscreenLane);
      var _nextState = {
        baseLanes: nextBaseLanes
      };
      workInProgress.memoizedState = _nextState; // We're about to bail out, but we need to push this to the stack anyway
      // to avoid a push/pop misalignment.

      pushRenderLanes(workInProgress, nextBaseLanes);
      return null;
    } else {
      // Rendering at offscreen, so we can clear the base lanes.
      var _nextState2 = {
        baseLanes: NoLanes
      };
      workInProgress.memoizedState = _nextState2; // Push the lanes that were skipped when we bailed out.

      var subtreeRenderLanes = prevState !== null ? prevState.baseLanes : renderLanes;
      pushRenderLanes(workInProgress, subtreeRenderLanes);
    }
  } else {
    var _subtreeRenderLanes;

    if (prevState !== null) {
      _subtreeRenderLanes = mergeLanes(prevState.baseLanes, renderLanes); // Since we're not hidden anymore, reset the state

      workInProgress.memoizedState = null;
    } else {
      // We weren't previously hidden, and we still aren't, so there's nothing
      // special to do. Need to push to the stack regardless, though, to avoid
      // a push/pop misalignment.
      _subtreeRenderLanes = renderLanes;
    }

    pushRenderLanes(workInProgress, _subtreeRenderLanes);
  }

  reconcileChildren(current, workInProgress, nextChildren, renderLanes);
  return workInProgress.child;
} // Note: These happen to have identical begin phases, for now. We shouldn't hold
// ourselves to this constraint, though. If the behavior diverges, we should
// fork the function.


var updateLegacyHiddenComponent = updateOffscreenComponent;

function updateFragment(current, workInProgress, renderLanes) {
  var nextChildren = workInProgress.pendingProps;
  reconcileChildren(current, workInProgress, nextChildren, renderLanes);
  return workInProgress.child;
}

function updateMode(current, workInProgress, renderLanes) {
  var nextChildren = workInProgress.pendingProps.children;
  reconcileChildren(current, workInProgress, nextChildren, renderLanes);
  return workInProgress.child;
}

function updateProfiler(current, workInProgress, renderLanes) {
  {
    workInProgress.flags |= Update; // Reset effect durations for the next eventual effect phase.
    // These are reset during render to allow the DevTools commit hook a chance to read them,

    var stateNode = workInProgress.stateNode;
    stateNode.effectDuration = 0;
    stateNode.passiveEffectDuration = 0;
  }

  var nextProps = workInProgress.pendingProps;
  var nextChildren = nextProps.children;
  reconcileChildren(current, workInProgress, nextChildren, renderLanes);
  return workInProgress.child;
}

function markRef(current, workInProgress) {
  var ref = workInProgress.ref;

  if (current === null && ref !== null || current !== null && current.ref !== ref) {
    // Schedule a Ref effect
    workInProgress.flags |= Ref;
  }
}

function updateFunctionComponent(current, workInProgress, Component, nextProps, renderLanes) {
  {
    if (workInProgress.type !== workInProgress.elementType) {
      // Lazy component props can't be validated in createElement
      // because they're only guaranteed to be resolved here.
      var innerPropTypes = Component.propTypes;

      if (innerPropTypes) {
        checkPropTypes(innerPropTypes, nextProps, // Resolved props
        'prop', getComponentName(Component));
      }
    }
  }

  var context;

  {
    var unmaskedContext = getUnmaskedContext(workInProgress, Component, true);
    context = getMaskedContext(workInProgress, unmaskedContext);
  }

  var nextChildren;
  prepareToReadContext(workInProgress, renderLanes);

  {
    ReactCurrentOwner$1.current = workInProgress;
    setIsRendering(true);
    nextChildren = renderWithHooks(current, workInProgress, Component, nextProps, context, renderLanes);

    if ( workInProgress.mode & StrictMode) {
      disableLogs();

      try {
        nextChildren = renderWithHooks(current, workInProgress, Component, nextProps, context, renderLanes);
      } finally {
        reenableLogs();
      }
    }

    setIsRendering(false);
  }

  if (current !== null && !didReceiveUpdate) {
    bailoutHooks(current, workInProgress, renderLanes);
    return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);
  } // React DevTools reads this flag.


  workInProgress.flags |= PerformedWork;
  reconcileChildren(current, workInProgress, nextChildren, renderLanes);
  return workInProgress.child;
}

function updateClassComponent(current, workInProgress, Component, nextProps, renderLanes) {
  {
    if (workInProgress.type !== workInProgress.elementType) {
      // Lazy component props can't be validated in createElement
      // because they're only guaranteed to be resolved here.
      var innerPropTypes = Component.propTypes;

      if (innerPropTypes) {
        checkPropTypes(innerPropTypes, nextProps, // Resolved props
        'prop', getComponentName(Component));
      }
    }
  } // Push context providers early to prevent context stack mismatches.
  // During mounting we don't know the child context yet as the instance doesn't exist.
  // We will invalidate the child context in finishClassComponent() right after rendering.


  var hasContext;

  if (isContextProvider(Component)) {
    hasContext = true;
    pushContextProvider(workInProgress);
  } else {
    hasContext = false;
  }

  prepareToReadContext(workInProgress, renderLanes);
  var instance = workInProgress.stateNode;
  var shouldUpdate;

  if (instance === null) {
    if (current !== null) {
      // A class component without an instance only mounts if it suspended
      // inside a non-concurrent tree, in an inconsistent state. We want to
      // treat it like a new mount, even though an empty version of it already
      // committed. Disconnect the alternate pointers.
      current.alternate = null;
      workInProgress.alternate = null; // Since this is conceptually a new fiber, schedule a Placement effect

      workInProgress.flags |= Placement;
    } // In the initial pass we might need to construct the instance.


    constructClassInstance(workInProgress, Component, nextProps);
    mountClassInstance(workInProgress, Component, nextProps, renderLanes);
    shouldUpdate = true;
  } else if (current === null) {
    // In a resume, we'll already have an instance we can reuse.
    shouldUpdate = resumeMountClassInstance(workInProgress, Component, nextProps, renderLanes);
  } else {
    shouldUpdate = updateClassInstance(current, workInProgress, Component, nextProps, renderLanes);
  }

  var nextUnitOfWork = finishClassComponent(current, workInProgress, Component, shouldUpdate, hasContext, renderLanes);

  {
    var inst = workInProgress.stateNode;

    if (shouldUpdate && inst.props !== nextProps) {
      if (!didWarnAboutReassigningProps) {
        error('It looks like %s is reassigning its own `this.props` while rendering. ' + 'This is not supported and can lead to confusing bugs.', getComponentName(workInProgress.type) || 'a component');
      }

      didWarnAboutReassigningProps = true;
    }
  }

  return nextUnitOfWork;
}

function finishClassComponent(current, workInProgress, Component, shouldUpdate, hasContext, renderLanes) {
  // Refs should update even if shouldComponentUpdate returns false
  markRef(current, workInProgress);
  var didCaptureError = (workInProgress.flags & DidCapture) !== NoFlags;

  if (!shouldUpdate && !didCaptureError) {
    // Context providers should defer to sCU for rendering
    if (hasContext) {
      invalidateContextProvider(workInProgress, Component, false);
    }

    return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);
  }

  var instance = workInProgress.stateNode; // Rerender

  ReactCurrentOwner$1.current = workInProgress;
  var nextChildren;

  if (didCaptureError && typeof Component.getDerivedStateFromError !== 'function') {
    // If we captured an error, but getDerivedStateFromError is not defined,
    // unmount all the children. componentDidCatch will schedule an update to
    // re-render a fallback. This is temporary until we migrate everyone to
    // the new API.
    // TODO: Warn in a future release.
    nextChildren = null;

    {
      stopProfilerTimerIfRunning();
    }
  } else {
    {
      setIsRendering(true);
      nextChildren = instance.render();

      if ( workInProgress.mode & StrictMode) {
        disableLogs();

        try {
          instance.render();
        } finally {
          reenableLogs();
        }
      }

      setIsRendering(false);
    }
  } // React DevTools reads this flag.


  workInProgress.flags |= PerformedWork;

  if (current !== null && didCaptureError) {
    // If we're recovering from an error, reconcile without reusing any of
    // the existing children. Conceptually, the normal children and the children
    // that are shown on error are two different sets, so we shouldn't reuse
    // normal children even if their identities match.
    forceUnmountCurrentAndReconcile(current, workInProgress, nextChildren, renderLanes);
  } else {
    reconcileChildren(current, workInProgress, nextChildren, renderLanes);
  } // Memoize state using the values we just used to render.
  // TODO: Restructure so we never read values from the instance.


  workInProgress.memoizedState = instance.state; // The context might have changed so we need to recalculate it.

  if (hasContext) {
    invalidateContextProvider(workInProgress, Component, true);
  }

  return workInProgress.child;
}

function pushHostRootContext(workInProgress) {
  var root = workInProgress.stateNode;

  if (root.pendingContext) {
    pushTopLevelContextObject(workInProgress, root.pendingContext, root.pendingContext !== root.context);
  } else if (root.context) {
    // Should always be set
    pushTopLevelContextObject(workInProgress, root.context, false);
  }

  pushHostContainer(workInProgress, root.containerInfo);
}

function updateHostRoot(current, workInProgress, renderLanes) {
  pushHostRootContext(workInProgress);
  var updateQueue = workInProgress.updateQueue;

  if (!(current !== null && updateQueue !== null)) {
    {
      throw Error( "If the root does not have an updateQueue, we should have already bailed out. This error is likely caused by a bug in React. Please file an issue." );
    }
  }

  var nextProps = workInProgress.pendingProps;
  var prevState = workInProgress.memoizedState;
  var prevChildren = prevState !== null ? prevState.element : null;
  cloneUpdateQueue(current, workInProgress);
  processUpdateQueue(workInProgress, nextProps, null, renderLanes);
  var nextState = workInProgress.memoizedState; // Caution: React DevTools currently depends on this property
  // being called "element".

  var nextChildren = nextState.element;

  if (nextChildren === prevChildren) {
    resetHydrationState();
    return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);
  }

  var root = workInProgress.stateNode;

  if (root.hydrate && enterHydrationState(workInProgress)) {
    // If we don't have any current children this might be the first pass.
    // We always try to hydrate. If this isn't a hydration pass there won't
    // be any children to hydrate which is effectively the same thing as
    // not hydrating.
    {
      var mutableSourceEagerHydrationData = root.mutableSourceEagerHydrationData;

      if (mutableSourceEagerHydrationData != null) {
        for (var i = 0; i < mutableSourceEagerHydrationData.length; i += 2) {
          var mutableSource = mutableSourceEagerHydrationData[i];
          var version = mutableSourceEagerHydrationData[i + 1];
          setWorkInProgressVersion(mutableSource, version);
        }
      }
    }

    var child = mountChildFibers(workInProgress, null, nextChildren, renderLanes);
    workInProgress.child = child;
    var node = child;

    while (node) {
      // Mark each child as hydrating. This is a fast path to know whether this
      // tree is part of a hydrating tree. This is used to determine if a child
      // node has fully mounted yet, and for scheduling event replaying.
      // Conceptually this is similar to Placement in that a new subtree is
      // inserted into the React tree here. It just happens to not need DOM
      // mutations because it already exists.
      node.flags = node.flags & ~Placement | Hydrating;
      node = node.sibling;
    }
  } else {
    // Otherwise reset hydration state in case we aborted and resumed another
    // root.
    reconcileChildren(current, workInProgress, nextChildren, renderLanes);
    resetHydrationState();
  }

  return workInProgress.child;
}

function updateHostComponent(current, workInProgress, renderLanes) {
  pushHostContext(workInProgress);

  if (current === null) {
    tryToClaimNextHydratableInstance(workInProgress);
  }

  var type = workInProgress.type;
  var nextProps = workInProgress.pendingProps;
  var prevProps = current !== null ? current.memoizedProps : null;
  var nextChildren = nextProps.children;
  var isDirectTextChild = shouldSetTextContent(type, nextProps);

  if (isDirectTextChild) {
    // We special case a direct text child of a host node. This is a common
    // case. We won't handle it as a reified child. We will instead handle
    // this in the host environment that also has access to this prop. That
    // avoids allocating another HostText fiber and traversing it.
    nextChildren = null;
  } else if (prevProps !== null && shouldSetTextContent(type, prevProps)) {
    // If we're switching from a direct text child to a normal child, or to
    // empty, we need to schedule the text content to be reset.
    workInProgress.flags |= ContentReset;
  }

  markRef(current, workInProgress);
  reconcileChildren(current, workInProgress, nextChildren, renderLanes);
  return workInProgress.child;
}

function updateHostText(current, workInProgress) {
  if (current === null) {
    tryToClaimNextHydratableInstance(workInProgress);
  } // Nothing to do here. This is terminal. We'll do the completion step
  // immediately after.


  return null;
}

function mountLazyComponent(_current, workInProgress, elementType, updateLanes, renderLanes) {
  if (_current !== null) {
    // A lazy component only mounts if it suspended inside a non-
    // concurrent tree, in an inconsistent state. We want to treat it like
    // a new mount, even though an empty version of it already committed.
    // Disconnect the alternate pointers.
    _current.alternate = null;
    workInProgress.alternate = null; // Since this is conceptually a new fiber, schedule a Placement effect

    workInProgress.flags |= Placement;
  }

  var props = workInProgress.pendingProps;
  var lazyComponent = elementType;
  var payload = lazyComponent._payload;
  var init = lazyComponent._init;
  var Component = init(payload); // Store the unwrapped component in the type.

  workInProgress.type = Component;
  var resolvedTag = workInProgress.tag = resolveLazyComponentTag(Component);
  var resolvedProps = resolveDefaultProps(Component, props);
  var child;

  switch (resolvedTag) {
    case FunctionComponent:
      {
        {
          validateFunctionComponentInDev(workInProgress, Component);
          workInProgress.type = Component = resolveFunctionForHotReloading(Component);
        }

        child = updateFunctionComponent(null, workInProgress, Component, resolvedProps, renderLanes);
        return child;
      }

    case ClassComponent:
      {
        {
          workInProgress.type = Component = resolveClassForHotReloading(Component);
        }

        child = updateClassComponent(null, workInProgress, Component, resolvedProps, renderLanes);
        return child;
      }

    case ForwardRef:
      {
        {
          workInProgress.type = Component = resolveForwardRefForHotReloading(Component);
        }

        child = updateForwardRef(null, workInProgress, Component, resolvedProps, renderLanes);
        return child;
      }

    case MemoComponent:
      {
        {
          if (workInProgress.type !== workInProgress.elementType) {
            var outerPropTypes = Component.propTypes;

            if (outerPropTypes) {
              checkPropTypes(outerPropTypes, resolvedProps, // Resolved for outer only
              'prop', getComponentName(Component));
            }
          }
        }

        child = updateMemoComponent(null, workInProgress, Component, resolveDefaultProps(Component.type, resolvedProps), // The inner type can have defaults too
        updateLanes, renderLanes);
        return child;
      }
  }

  var hint = '';

  {
    if (Component !== null && typeof Component === 'object' && Component.$$typeof === REACT_LAZY_TYPE) {
      hint = ' Did you wrap a component in React.lazy() more than once?';
    }
  } // This message intentionally doesn't mention ForwardRef or MemoComponent
  // because the fact that it's a separate type of work is an
  // implementation detail.


  {
    {
      throw Error( "Element type is invalid. Received a promise that resolves to: " + Component + ". Lazy element type must resolve to a class or function." + hint );
    }
  }
}

function mountIncompleteClassComponent(_current, workInProgress, Component, nextProps, renderLanes) {
  if (_current !== null) {
    // An incomplete component only mounts if it suspended inside a non-
    // concurrent tree, in an inconsistent state. We want to treat it like
    // a new mount, even though an empty version of it already committed.
    // Disconnect the alternate pointers.
    _current.alternate = null;
    workInProgress.alternate = null; // Since this is conceptually a new fiber, schedule a Placement effect

    workInProgress.flags |= Placement;
  } // Promote the fiber to a class and try rendering again.


  workInProgress.tag = ClassComponent; // The rest of this function is a fork of `updateClassComponent`
  // Push context providers early to prevent context stack mismatches.
  // During mounting we don't know the child context yet as the instance doesn't exist.
  // We will invalidate the child context in finishClassComponent() right after rendering.

  var hasContext;

  if (isContextProvider(Component)) {
    hasContext = true;
    pushContextProvider(workInProgress);
  } else {
    hasContext = false;
  }

  prepareToReadContext(workInProgress, renderLanes);
  constructClassInstance(workInProgress, Component, nextProps);
  mountClassInstance(workInProgress, Component, nextProps, renderLanes);
  return finishClassComponent(null, workInProgress, Component, true, hasContext, renderLanes);
}

function mountIndeterminateComponent(_current, workInProgress, Component, renderLanes) {
  if (_current !== null) {
    // An indeterminate component only mounts if it suspended inside a non-
    // concurrent tree, in an inconsistent state. We want to treat it like
    // a new mount, even though an empty version of it already committed.
    // Disconnect the alternate pointers.
    _current.alternate = null;
    workInProgress.alternate = null; // Since this is conceptually a new fiber, schedule a Placement effect

    workInProgress.flags |= Placement;
  }

  var props = workInProgress.pendingProps;
  var context;

  {
    var unmaskedContext = getUnmaskedContext(workInProgress, Component, false);
    context = getMaskedContext(workInProgress, unmaskedContext);
  }

  prepareToReadContext(workInProgress, renderLanes);
  var value;

  {
    if (Component.prototype && typeof Component.prototype.render === 'function') {
      var componentName = getComponentName(Component) || 'Unknown';

      if (!didWarnAboutBadClass[componentName]) {
        error("The <%s /> component appears to have a render method, but doesn't extend React.Component. " + 'This is likely to cause errors. Change %s to extend React.Component instead.', componentName, componentName);

        didWarnAboutBadClass[componentName] = true;
      }
    }

    if (workInProgress.mode & StrictMode) {
      ReactStrictModeWarnings.recordLegacyContextWarning(workInProgress, null);
    }

    setIsRendering(true);
    ReactCurrentOwner$1.current = workInProgress;
    value = renderWithHooks(null, workInProgress, Component, props, context, renderLanes);
    setIsRendering(false);
  } // React DevTools reads this flag.


  workInProgress.flags |= PerformedWork;

  {
    // Support for module components is deprecated and is removed behind a flag.
    // Whether or not it would crash later, we want to show a good message in DEV first.
    if (typeof value === 'object' && value !== null && typeof value.render === 'function' && value.$$typeof === undefined) {
      var _componentName = getComponentName(Component) || 'Unknown';

      if (!didWarnAboutModulePatternComponent[_componentName]) {
        error('The <%s /> component appears to be a function component that returns a class instance. ' + 'Change %s to a class that extends React.Component instead. ' + "If you can't use a class try assigning the prototype on the function as a workaround. " + "`%s.prototype = React.Component.prototype`. Don't use an arrow function since it " + 'cannot be called with `new` by React.', _componentName, _componentName, _componentName);

        didWarnAboutModulePatternComponent[_componentName] = true;
      }
    }
  }

  if ( // Run these checks in production only if the flag is off.
  // Eventually we'll delete this branch altogether.
   typeof value === 'object' && value !== null && typeof value.render === 'function' && value.$$typeof === undefined) {
    {
      var _componentName2 = getComponentName(Component) || 'Unknown';

      if (!didWarnAboutModulePatternComponent[_componentName2]) {
        error('The <%s /> component appears to be a function component that returns a class instance. ' + 'Change %s to a class that extends React.Component instead. ' + "If you can't use a class try assigning the prototype on the function as a workaround. " + "`%s.prototype = React.Component.prototype`. Don't use an arrow function since it " + 'cannot be called with `new` by React.', _componentName2, _componentName2, _componentName2);

        didWarnAboutModulePatternComponent[_componentName2] = true;
      }
    } // Proceed under the assumption that this is a class instance


    workInProgress.tag = ClassComponent; // Throw out any hooks that were used.

    workInProgress.memoizedState = null;
    workInProgress.updateQueue = null; // Push context providers early to prevent context stack mismatches.
    // During mounting we don't know the child context yet as the instance doesn't exist.
    // We will invalidate the child context in finishClassComponent() right after rendering.

    var hasContext = false;

    if (isContextProvider(Component)) {
      hasContext = true;
      pushContextProvider(workInProgress);
    } else {
      hasContext = false;
    }

    workInProgress.memoizedState = value.state !== null && value.state !== undefined ? value.state : null;
    initializeUpdateQueue(workInProgress);
    var getDerivedStateFromProps = Component.getDerivedStateFromProps;

    if (typeof getDerivedStateFromProps === 'function') {
      applyDerivedStateFromProps(workInProgress, Component, getDerivedStateFromProps, props);
    }

    adoptClassInstance(workInProgress, value);
    mountClassInstance(workInProgress, Component, props, renderLanes);
    return finishClassComponent(null, workInProgress, Component, true, hasContext, renderLanes);
  } else {
    // Proceed under the assumption that this is a function component
    workInProgress.tag = FunctionComponent;

    {

      if ( workInProgress.mode & StrictMode) {
        disableLogs();

        try {
          value = renderWithHooks(null, workInProgress, Component, props, context, renderLanes);
        } finally {
          reenableLogs();
        }
      }
    }

    reconcileChildren(null, workInProgress, value, renderLanes);

    {
      validateFunctionComponentInDev(workInProgress, Component);
    }

    return workInProgress.child;
  }
}

function validateFunctionComponentInDev(workInProgress, Component) {
  {
    if (Component) {
      if (Component.childContextTypes) {
        error('%s(...): childContextTypes cannot be defined on a function component.', Component.displayName || Component.name || 'Component');
      }
    }

    if (workInProgress.ref !== null) {
      var info = '';
      var ownerName = getCurrentFiberOwnerNameInDevOrNull();

      if (ownerName) {
        info += '\n\nCheck the render method of `' + ownerName + '`.';
      }

      var warningKey = ownerName || workInProgress._debugID || '';
      var debugSource = workInProgress._debugSource;

      if (debugSource) {
        warningKey = debugSource.fileName + ':' + debugSource.lineNumber;
      }

      if (!didWarnAboutFunctionRefs[warningKey]) {
        didWarnAboutFunctionRefs[warningKey] = true;

        error('Function components cannot be given refs. ' + 'Attempts to access this ref will fail. ' + 'Did you mean to use React.forwardRef()?%s', info);
      }
    }

    if (typeof Component.getDerivedStateFromProps === 'function') {
      var _componentName3 = getComponentName(Component) || 'Unknown';

      if (!didWarnAboutGetDerivedStateOnFunctionComponent[_componentName3]) {
        error('%s: Function components do not support getDerivedStateFromProps.', _componentName3);

        didWarnAboutGetDerivedStateOnFunctionComponent[_componentName3] = true;
      }
    }

    if (typeof Component.contextType === 'object' && Component.contextType !== null) {
      var _componentName4 = getComponentName(Component) || 'Unknown';

      if (!didWarnAboutContextTypeOnFunctionComponent[_componentName4]) {
        error('%s: Function components do not support contextType.', _componentName4);

        didWarnAboutContextTypeOnFunctionComponent[_componentName4] = true;
      }
    }
  }
}

var SUSPENDED_MARKER = {
  dehydrated: null,
  retryLane: NoLane
};

function mountSuspenseOffscreenState(renderLanes) {
  return {
    baseLanes: renderLanes
  };
}

function updateSuspenseOffscreenState(prevOffscreenState, renderLanes) {
  return {
    baseLanes: mergeLanes(prevOffscreenState.baseLanes, renderLanes)
  };
} // TODO: Probably should inline this back


function shouldRemainOnFallback(suspenseContext, current, workInProgress, renderLanes) {
  // If we're already showing a fallback, there are cases where we need to
  // remain on that fallback regardless of whether the content has resolved.
  // For example, SuspenseList coordinates when nested content appears.
  if (current !== null) {
    var suspenseState = current.memoizedState;

    if (suspenseState === null) {
      // Currently showing content. Don't hide it, even if ForceSuspenseFallack
      // is true. More precise name might be "ForceRemainSuspenseFallback".
      // Note: This is a factoring smell. Can't remain on a fallback if there's
      // no fallback to remain on.
      return false;
    }
  } // Not currently showing content. Consult the Suspense context.


  return hasSuspenseContext(suspenseContext, ForceSuspenseFallback);
}

function getRemainingWorkInPrimaryTree(current, renderLanes) {
  // TODO: Should not remove render lanes that were pinged during this render
  return removeLanes(current.childLanes, renderLanes);
}

function updateSuspenseComponent(current, workInProgress, renderLanes) {
  var nextProps = workInProgress.pendingProps; // This is used by DevTools to force a boundary to suspend.

  {
    if (shouldSuspend(workInProgress)) {
      workInProgress.flags |= DidCapture;
    }
  }

  var suspenseContext = suspenseStackCursor.current;
  var showFallback = false;
  var didSuspend = (workInProgress.flags & DidCapture) !== NoFlags;

  if (didSuspend || shouldRemainOnFallback(suspenseContext, current)) {
    // Something in this boundary's subtree already suspended. Switch to
    // rendering the fallback children.
    showFallback = true;
    workInProgress.flags &= ~DidCapture;
  } else {
    // Attempting the main content
    if (current === null || current.memoizedState !== null) {
      // This is a new mount or this boundary is already showing a fallback state.
      // Mark this subtree context as having at least one invisible parent that could
      // handle the fallback state.
      // Boundaries without fallbacks or should be avoided are not considered since
      // they cannot handle preferred fallback states.
      if (nextProps.fallback !== undefined && nextProps.unstable_avoidThisFallback !== true) {
        suspenseContext = addSubtreeSuspenseContext(suspenseContext, InvisibleParentSuspenseContext);
      }
    }
  }

  suspenseContext = setDefaultShallowSuspenseContext(suspenseContext);
  pushSuspenseContext(workInProgress, suspenseContext); // OK, the next part is confusing. We're about to reconcile the Suspense
  // boundary's children. This involves some custom reconcilation logic. Two
  // main reasons this is so complicated.
  //
  // First, Legacy Mode has different semantics for backwards compatibility. The
  // primary tree will commit in an inconsistent state, so when we do the
  // second pass to render the fallback, we do some exceedingly, uh, clever
  // hacks to make that not totally break. Like transferring effects and
  // deletions from hidden tree. In Concurrent Mode, it's much simpler,
  // because we bailout on the primary tree completely and leave it in its old
  // state, no effects. Same as what we do for Offscreen (except that
  // Offscreen doesn't have the first render pass).
  //
  // Second is hydration. During hydration, the Suspense fiber has a slightly
  // different layout, where the child points to a dehydrated fragment, which
  // contains the DOM rendered by the server.
  //
  // Third, even if you set all that aside, Suspense is like error boundaries in
  // that we first we try to render one tree, and if that fails, we render again
  // and switch to a different tree. Like a try/catch block. So we have to track
  // which branch we're currently rendering. Ideally we would model this using
  // a stack.

  if (current === null) {
    // Initial mount
    // If we're currently hydrating, try to hydrate this boundary.
    // But only if this has a fallback.
    if (nextProps.fallback !== undefined) {
      tryToClaimNextHydratableInstance(workInProgress); // This could've been a dehydrated suspense component.
    }

    var nextPrimaryChildren = nextProps.children;
    var nextFallbackChildren = nextProps.fallback;

    if (showFallback) {
      var fallbackFragment = mountSuspenseFallbackChildren(workInProgress, nextPrimaryChildren, nextFallbackChildren, renderLanes);
      var primaryChildFragment = workInProgress.child;
      primaryChildFragment.memoizedState = mountSuspenseOffscreenState(renderLanes);
      workInProgress.memoizedState = SUSPENDED_MARKER;
      return fallbackFragment;
    } else if (typeof nextProps.unstable_expectedLoadTime === 'number') {
      // This is a CPU-bound tree. Skip this tree and show a placeholder to
      // unblock the surrounding content. Then immediately retry after the
      // initial commit.
      var _fallbackFragment = mountSuspenseFallbackChildren(workInProgress, nextPrimaryChildren, nextFallbackChildren, renderLanes);

      var _primaryChildFragment = workInProgress.child;
      _primaryChildFragment.memoizedState = mountSuspenseOffscreenState(renderLanes);
      workInProgress.memoizedState = SUSPENDED_MARKER; // Since nothing actually suspended, there will nothing to ping this to
      // get it started back up to attempt the next item. While in terms of
      // priority this work has the same priority as this current render, it's
      // not part of the same transition once the transition has committed. If
      // it's sync, we still want to yield so that it can be painted.
      // Conceptually, this is really the same as pinging. We can use any
      // RetryLane even if it's the one currently rendering since we're leaving
      // it behind on this node.

      workInProgress.lanes = SomeRetryLane;

      {
        markSpawnedWork(SomeRetryLane);
      }

      return _fallbackFragment;
    } else {
      return mountSuspensePrimaryChildren(workInProgress, nextPrimaryChildren, renderLanes);
    }
  } else {
    // This is an update.
    // If the current fiber has a SuspenseState, that means it's already showing
    // a fallback.
    var prevState = current.memoizedState;

    if (prevState !== null) {

      if (showFallback) {
        var _nextFallbackChildren2 = nextProps.fallback;
        var _nextPrimaryChildren2 = nextProps.children;

        var _fallbackChildFragment = updateSuspenseFallbackChildren(current, workInProgress, _nextPrimaryChildren2, _nextFallbackChildren2, renderLanes);

        var _primaryChildFragment3 = workInProgress.child;
        var prevOffscreenState = current.child.memoizedState;
        _primaryChildFragment3.memoizedState = prevOffscreenState === null ? mountSuspenseOffscreenState(renderLanes) : updateSuspenseOffscreenState(prevOffscreenState, renderLanes);
        _primaryChildFragment3.childLanes = getRemainingWorkInPrimaryTree(current, renderLanes);
        workInProgress.memoizedState = SUSPENDED_MARKER;
        return _fallbackChildFragment;
      } else {
        var _nextPrimaryChildren3 = nextProps.children;

        var _primaryChildFragment4 = updateSuspensePrimaryChildren(current, workInProgress, _nextPrimaryChildren3, renderLanes);

        workInProgress.memoizedState = null;
        return _primaryChildFragment4;
      }
    } else {
      // The current tree is not already showing a fallback.
      if (showFallback) {
        // Timed out.
        var _nextFallbackChildren3 = nextProps.fallback;
        var _nextPrimaryChildren4 = nextProps.children;

        var _fallbackChildFragment2 = updateSuspenseFallbackChildren(current, workInProgress, _nextPrimaryChildren4, _nextFallbackChildren3, renderLanes);

        var _primaryChildFragment5 = workInProgress.child;
        var _prevOffscreenState = current.child.memoizedState;
        _primaryChildFragment5.memoizedState = _prevOffscreenState === null ? mountSuspenseOffscreenState(renderLanes) : updateSuspenseOffscreenState(_prevOffscreenState, renderLanes);
        _primaryChildFragment5.childLanes = getRemainingWorkInPrimaryTree(current, renderLanes); // Skip the primary children, and continue working on the
        // fallback children.

        workInProgress.memoizedState = SUSPENDED_MARKER;
        return _fallbackChildFragment2;
      } else {
        // Still haven't timed out. Continue rendering the children, like we
        // normally do.
        var _nextPrimaryChildren5 = nextProps.children;

        var _primaryChildFragment6 = updateSuspensePrimaryChildren(current, workInProgress, _nextPrimaryChildren5, renderLanes);

        workInProgress.memoizedState = null;
        return _primaryChildFragment6;
      }
    }
  }
}

function mountSuspensePrimaryChildren(workInProgress, primaryChildren, renderLanes) {
  var mode = workInProgress.mode;
  var primaryChildProps = {
    mode: 'visible',
    children: primaryChildren
  };
  var primaryChildFragment = createFiberFromOffscreen(primaryChildProps, mode, renderLanes, null);
  primaryChildFragment.return = workInProgress;
  workInProgress.child = primaryChildFragment;
  return primaryChildFragment;
}

function mountSuspenseFallbackChildren(workInProgress, primaryChildren, fallbackChildren, renderLanes) {
  var mode = workInProgress.mode;
  var progressedPrimaryFragment = workInProgress.child;
  var primaryChildProps = {
    mode: 'hidden',
    children: primaryChildren
  };
  var primaryChildFragment;
  var fallbackChildFragment;

  if ((mode & BlockingMode) === NoMode && progressedPrimaryFragment !== null) {
    // In legacy mode, we commit the primary tree as if it successfully
    // completed, even though it's in an inconsistent state.
    primaryChildFragment = progressedPrimaryFragment;
    primaryChildFragment.childLanes = NoLanes;
    primaryChildFragment.pendingProps = primaryChildProps;

    if ( workInProgress.mode & ProfileMode) {
      // Reset the durations from the first pass so they aren't included in the
      // final amounts. This seems counterintuitive, since we're intentionally
      // not measuring part of the render phase, but this makes it match what we
      // do in Concurrent Mode.
      primaryChildFragment.actualDuration = 0;
      primaryChildFragment.actualStartTime = -1;
      primaryChildFragment.selfBaseDuration = 0;
      primaryChildFragment.treeBaseDuration = 0;
    }

    fallbackChildFragment = createFiberFromFragment(fallbackChildren, mode, renderLanes, null);
  } else {
    primaryChildFragment = createFiberFromOffscreen(primaryChildProps, mode, NoLanes, null);
    fallbackChildFragment = createFiberFromFragment(fallbackChildren, mode, renderLanes, null);
  }

  primaryChildFragment.return = workInProgress;
  fallbackChildFragment.return = workInProgress;
  primaryChildFragment.sibling = fallbackChildFragment;
  workInProgress.child = primaryChildFragment;
  return fallbackChildFragment;
}

function createWorkInProgressOffscreenFiber(current, offscreenProps) {
  // The props argument to `createWorkInProgress` is `any` typed, so we use this
  // wrapper function to constrain it.
  return createWorkInProgress(current, offscreenProps);
}

function updateSuspensePrimaryChildren(current, workInProgress, primaryChildren, renderLanes) {
  var currentPrimaryChildFragment = current.child;
  var currentFallbackChildFragment = currentPrimaryChildFragment.sibling;
  var primaryChildFragment = createWorkInProgressOffscreenFiber(currentPrimaryChildFragment, {
    mode: 'visible',
    children: primaryChildren
  });

  if ((workInProgress.mode & BlockingMode) === NoMode) {
    primaryChildFragment.lanes = renderLanes;
  }

  primaryChildFragment.return = workInProgress;
  primaryChildFragment.sibling = null;

  if (currentFallbackChildFragment !== null) {
    // Delete the fallback child fragment
    currentFallbackChildFragment.nextEffect = null;
    currentFallbackChildFragment.flags = Deletion;
    workInProgress.firstEffect = workInProgress.lastEffect = currentFallbackChildFragment;
  }

  workInProgress.child = primaryChildFragment;
  return primaryChildFragment;
}

function updateSuspenseFallbackChildren(current, workInProgress, primaryChildren, fallbackChildren, renderLanes) {
  var mode = workInProgress.mode;
  var currentPrimaryChildFragment = current.child;
  var currentFallbackChildFragment = currentPrimaryChildFragment.sibling;
  var primaryChildProps = {
    mode: 'hidden',
    children: primaryChildren
  };
  var primaryChildFragment;

  if ( // In legacy mode, we commit the primary tree as if it successfully
  // completed, even though it's in an inconsistent state.
  (mode & BlockingMode) === NoMode && // Make sure we're on the second pass, i.e. the primary child fragment was
  // already cloned. In legacy mode, the only case where this isn't true is
  // when DevTools forces us to display a fallback; we skip the first render
  // pass entirely and go straight to rendering the fallback. (In Concurrent
  // Mode, SuspenseList can also trigger this scenario, but this is a legacy-
  // only codepath.)
  workInProgress.child !== currentPrimaryChildFragment) {
    var progressedPrimaryFragment = workInProgress.child;
    primaryChildFragment = progressedPrimaryFragment;
    primaryChildFragment.childLanes = NoLanes;
    primaryChildFragment.pendingProps = primaryChildProps;

    if ( workInProgress.mode & ProfileMode) {
      // Reset the durations from the first pass so they aren't included in the
      // final amounts. This seems counterintuitive, since we're intentionally
      // not measuring part of the render phase, but this makes it match what we
      // do in Concurrent Mode.
      primaryChildFragment.actualDuration = 0;
      primaryChildFragment.actualStartTime = -1;
      primaryChildFragment.selfBaseDuration = currentPrimaryChildFragment.selfBaseDuration;
      primaryChildFragment.treeBaseDuration = currentPrimaryChildFragment.treeBaseDuration;
    } // The fallback fiber was added as a deletion effect during the first pass.
    // However, since we're going to remain on the fallback, we no longer want
    // to delete it. So we need to remove it from the list. Deletions are stored
    // on the same list as effects. We want to keep the effects from the primary
    // tree. So we copy the primary child fragment's effect list, which does not
    // include the fallback deletion effect.


    var progressedLastEffect = primaryChildFragment.lastEffect;

    if (progressedLastEffect !== null) {
      workInProgress.firstEffect = primaryChildFragment.firstEffect;
      workInProgress.lastEffect = progressedLastEffect;
      progressedLastEffect.nextEffect = null;
    } else {
      // TODO: Reset this somewhere else? Lol legacy mode is so weird.
      workInProgress.firstEffect = workInProgress.lastEffect = null;
    }
  } else {
    primaryChildFragment = createWorkInProgressOffscreenFiber(currentPrimaryChildFragment, primaryChildProps);
  }

  var fallbackChildFragment;

  if (currentFallbackChildFragment !== null) {
    fallbackChildFragment = createWorkInProgress(currentFallbackChildFragment, fallbackChildren);
  } else {
    fallbackChildFragment = createFiberFromFragment(fallbackChildren, mode, renderLanes, null); // Needs a placement effect because the parent (the Suspense boundary) already
    // mounted but this is a new fiber.

    fallbackChildFragment.flags |= Placement;
  }

  fallbackChildFragment.return = workInProgress;
  primaryChildFragment.return = workInProgress;
  primaryChildFragment.sibling = fallbackChildFragment;
  workInProgress.child = primaryChildFragment;
  return fallbackChildFragment;
}

function scheduleWorkOnFiber(fiber, renderLanes) {
  fiber.lanes = mergeLanes(fiber.lanes, renderLanes);
  var alternate = fiber.alternate;

  if (alternate !== null) {
    alternate.lanes = mergeLanes(alternate.lanes, renderLanes);
  }

  scheduleWorkOnParentPath(fiber.return, renderLanes);
}

function propagateSuspenseContextChange(workInProgress, firstChild, renderLanes) {
  // Mark any Suspense boundaries with fallbacks as having work to do.
  // If they were previously forced into fallbacks, they may now be able
  // to unblock.
  var node = firstChild;

  while (node !== null) {
    if (node.tag === SuspenseComponent) {
      var state = node.memoizedState;

      if (state !== null) {
        scheduleWorkOnFiber(node, renderLanes);
      }
    } else if (node.tag === SuspenseListComponent) {
      // If the tail is hidden there might not be an Suspense boundaries
      // to schedule work on. In this case we have to schedule it on the
      // list itself.
      // We don't have to traverse to the children of the list since
      // the list will propagate the change when it rerenders.
      scheduleWorkOnFiber(node, renderLanes);
    } else if (node.child !== null) {
      node.child.return = node;
      node = node.child;
      continue;
    }

    if (node === workInProgress) {
      return;
    }

    while (node.sibling === null) {
      if (node.return === null || node.return === workInProgress) {
        return;
      }

      node = node.return;
    }

    node.sibling.return = node.return;
    node = node.sibling;
  }
}

function findLastContentRow(firstChild) {
  // This is going to find the last row among these children that is already
  // showing content on the screen, as opposed to being in fallback state or
  // new. If a row has multiple Suspense boundaries, any of them being in the
  // fallback state, counts as the whole row being in a fallback state.
  // Note that the "rows" will be workInProgress, but any nested children
  // will still be current since we haven't rendered them yet. The mounted
  // order may not be the same as the new order. We use the new order.
  var row = firstChild;
  var lastContentRow = null;

  while (row !== null) {
    var currentRow = row.alternate; // New rows can't be content rows.

    if (currentRow !== null && findFirstSuspended(currentRow) === null) {
      lastContentRow = row;
    }

    row = row.sibling;
  }

  return lastContentRow;
}

function validateRevealOrder(revealOrder) {
  {
    if (revealOrder !== undefined && revealOrder !== 'forwards' && revealOrder !== 'backwards' && revealOrder !== 'together' && !didWarnAboutRevealOrder[revealOrder]) {
      didWarnAboutRevealOrder[revealOrder] = true;

      if (typeof revealOrder === 'string') {
        switch (revealOrder.toLowerCase()) {
          case 'together':
          case 'forwards':
          case 'backwards':
            {
              error('"%s" is not a valid value for revealOrder on <SuspenseList />. ' + 'Use lowercase "%s" instead.', revealOrder, revealOrder.toLowerCase());

              break;
            }

          case 'forward':
          case 'backward':
            {
              error('"%s" is not a valid value for revealOrder on <SuspenseList />. ' + 'React uses the -s suffix in the spelling. Use "%ss" instead.', revealOrder, revealOrder.toLowerCase());

              break;
            }

          default:
            error('"%s" is not a supported revealOrder on <SuspenseList />. ' + 'Did you mean "together", "forwards" or "backwards"?', revealOrder);

            break;
        }
      } else {
        error('%s is not a supported value for revealOrder on <SuspenseList />. ' + 'Did you mean "together", "forwards" or "backwards"?', revealOrder);
      }
    }
  }
}

function validateTailOptions(tailMode, revealOrder) {
  {
    if (tailMode !== undefined && !didWarnAboutTailOptions[tailMode]) {
      if (tailMode !== 'collapsed' && tailMode !== 'hidden') {
        didWarnAboutTailOptions[tailMode] = true;

        error('"%s" is not a supported value for tail on <SuspenseList />. ' + 'Did you mean "collapsed" or "hidden"?', tailMode);
      } else if (revealOrder !== 'forwards' && revealOrder !== 'backwards') {
        didWarnAboutTailOptions[tailMode] = true;

        error('<SuspenseList tail="%s" /> is only valid if revealOrder is ' + '"forwards" or "backwards". ' + 'Did you mean to specify revealOrder="forwards"?', tailMode);
      }
    }
  }
}

function validateSuspenseListNestedChild(childSlot, index) {
  {
    var isArray = Array.isArray(childSlot);
    var isIterable = !isArray && typeof getIteratorFn(childSlot) === 'function';

    if (isArray || isIterable) {
      var type = isArray ? 'array' : 'iterable';

      error('A nested %s was passed to row #%s in <SuspenseList />. Wrap it in ' + 'an additional SuspenseList to configure its revealOrder: ' + '<SuspenseList revealOrder=...> ... ' + '<SuspenseList revealOrder=...>{%s}</SuspenseList> ... ' + '</SuspenseList>', type, index, type);

      return false;
    }
  }

  return true;
}

function validateSuspenseListChildren(children, revealOrder) {
  {
    if ((revealOrder === 'forwards' || revealOrder === 'backwards') && children !== undefined && children !== null && children !== false) {
      if (Array.isArray(children)) {
        for (var i = 0; i < children.length; i++) {
          if (!validateSuspenseListNestedChild(children[i], i)) {
            return;
          }
        }
      } else {
        var iteratorFn = getIteratorFn(children);

        if (typeof iteratorFn === 'function') {
          var childrenIterator = iteratorFn.call(children);

          if (childrenIterator) {
            var step = childrenIterator.next();
            var _i = 0;

            for (; !step.done; step = childrenIterator.next()) {
              if (!validateSuspenseListNestedChild(step.value, _i)) {
                return;
              }

              _i++;
            }
          }
        } else {
          error('A single row was passed to a <SuspenseList revealOrder="%s" />. ' + 'This is not useful since it needs multiple rows. ' + 'Did you mean to pass multiple children or an array?', revealOrder);
        }
      }
    }
  }
}

function initSuspenseListRenderState(workInProgress, isBackwards, tail, lastContentRow, tailMode, lastEffectBeforeRendering) {
  var renderState = workInProgress.memoizedState;

  if (renderState === null) {
    workInProgress.memoizedState = {
      isBackwards: isBackwards,
      rendering: null,
      renderingStartTime: 0,
      last: lastContentRow,
      tail: tail,
      tailMode: tailMode,
      lastEffect: lastEffectBeforeRendering
    };
  } else {
    // We can reuse the existing object from previous renders.
    renderState.isBackwards = isBackwards;
    renderState.rendering = null;
    renderState.renderingStartTime = 0;
    renderState.last = lastContentRow;
    renderState.tail = tail;
    renderState.tailMode = tailMode;
    renderState.lastEffect = lastEffectBeforeRendering;
  }
} // This can end up rendering this component multiple passes.
// The first pass splits the children fibers into two sets. A head and tail.
// We first render the head. If anything is in fallback state, we do another
// pass through beginWork to rerender all children (including the tail) with
// the force suspend context. If the first render didn't have anything in
// in fallback state. Then we render each row in the tail one-by-one.
// That happens in the completeWork phase without going back to beginWork.


function updateSuspenseListComponent(current, workInProgress, renderLanes) {
  var nextProps = workInProgress.pendingProps;
  var revealOrder = nextProps.revealOrder;
  var tailMode = nextProps.tail;
  var newChildren = nextProps.children;
  validateRevealOrder(revealOrder);
  validateTailOptions(tailMode, revealOrder);
  validateSuspenseListChildren(newChildren, revealOrder);
  reconcileChildren(current, workInProgress, newChildren, renderLanes);
  var suspenseContext = suspenseStackCursor.current;
  var shouldForceFallback = hasSuspenseContext(suspenseContext, ForceSuspenseFallback);

  if (shouldForceFallback) {
    suspenseContext = setShallowSuspenseContext(suspenseContext, ForceSuspenseFallback);
    workInProgress.flags |= DidCapture;
  } else {
    var didSuspendBefore = current !== null && (current.flags & DidCapture) !== NoFlags;

    if (didSuspendBefore) {
      // If we previously forced a fallback, we need to schedule work
      // on any nested boundaries to let them know to try to render
      // again. This is the same as context updating.
      propagateSuspenseContextChange(workInProgress, workInProgress.child, renderLanes);
    }

    suspenseContext = setDefaultShallowSuspenseContext(suspenseContext);
  }

  pushSuspenseContext(workInProgress, suspenseContext);

  if ((workInProgress.mode & BlockingMode) === NoMode) {
    // In legacy mode, SuspenseList doesn't work so we just
    // use make it a noop by treating it as the default revealOrder.
    workInProgress.memoizedState = null;
  } else {
    switch (revealOrder) {
      case 'forwards':
        {
          var lastContentRow = findLastContentRow(workInProgress.child);
          var tail;

          if (lastContentRow === null) {
            // The whole list is part of the tail.
            // TODO: We could fast path by just rendering the tail now.
            tail = workInProgress.child;
            workInProgress.child = null;
          } else {
            // Disconnect the tail rows after the content row.
            // We're going to render them separately later.
            tail = lastContentRow.sibling;
            lastContentRow.sibling = null;
          }

          initSuspenseListRenderState(workInProgress, false, // isBackwards
          tail, lastContentRow, tailMode, workInProgress.lastEffect);
          break;
        }

      case 'backwards':
        {
          // We're going to find the first row that has existing content.
          // At the same time we're going to reverse the list of everything
          // we pass in the meantime. That's going to be our tail in reverse
          // order.
          var _tail = null;
          var row = workInProgress.child;
          workInProgress.child = null;

          while (row !== null) {
            var currentRow = row.alternate; // New rows can't be content rows.

            if (currentRow !== null && findFirstSuspended(currentRow) === null) {
              // This is the beginning of the main content.
              workInProgress.child = row;
              break;
            }

            var nextRow = row.sibling;
            row.sibling = _tail;
            _tail = row;
            row = nextRow;
          } // TODO: If workInProgress.child is null, we can continue on the tail immediately.


          initSuspenseListRenderState(workInProgress, true, // isBackwards
          _tail, null, // last
          tailMode, workInProgress.lastEffect);
          break;
        }

      case 'together':
        {
          initSuspenseListRenderState(workInProgress, false, // isBackwards
          null, // tail
          null, // last
          undefined, workInProgress.lastEffect);
          break;
        }

      default:
        {
          // The default reveal order is the same as not having
          // a boundary.
          workInProgress.memoizedState = null;
        }
    }
  }

  return workInProgress.child;
}

function updatePortalComponent(current, workInProgress, renderLanes) {
  pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo);
  var nextChildren = workInProgress.pendingProps;

  if (current === null) {
    // Portals are special because we don't append the children during mount
    // but at commit. Therefore we need to track insertions which the normal
    // flow doesn't do during mount. This doesn't happen at the root because
    // the root always starts with a "current" with a null child.
    // TODO: Consider unifying this with how the root works.
    workInProgress.child = reconcileChildFibers(workInProgress, null, nextChildren, renderLanes);
  } else {
    reconcileChildren(current, workInProgress, nextChildren, renderLanes);
  }

  return workInProgress.child;
}

var hasWarnedAboutUsingNoValuePropOnContextProvider = false;

function updateContextProvider(current, workInProgress, renderLanes) {
  var providerType = workInProgress.type;
  var context = providerType._context;
  var newProps = workInProgress.pendingProps;
  var oldProps = workInProgress.memoizedProps;
  var newValue = newProps.value;

  {
    if (!('value' in newProps)) {
      if (!hasWarnedAboutUsingNoValuePropOnContextProvider) {
        hasWarnedAboutUsingNoValuePropOnContextProvider = true;

        error('The `value` prop is required for the `<Context.Provider>`. Did you misspell it or forget to pass it?');
      }
    }

    var providerPropTypes = workInProgress.type.propTypes;

    if (providerPropTypes) {
      checkPropTypes(providerPropTypes, newProps, 'prop', 'Context.Provider');
    }
  }

  pushProvider(workInProgress, newValue);

  if (oldProps !== null) {
    var oldValue = oldProps.value;
    var changedBits = calculateChangedBits(context, newValue, oldValue);

    if (changedBits === 0) {
      // No change. Bailout early if children are the same.
      if (oldProps.children === newProps.children && !hasContextChanged()) {
        return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);
      }
    } else {
      // The context value changed. Search for matching consumers and schedule
      // them to update.
      propagateContextChange(workInProgress, context, changedBits, renderLanes);
    }
  }

  var newChildren = newProps.children;
  reconcileChildren(current, workInProgress, newChildren, renderLanes);
  return workInProgress.child;
}

var hasWarnedAboutUsingContextAsConsumer = false;

function updateContextConsumer(current, workInProgress, renderLanes) {
  var context = workInProgress.type; // The logic below for Context differs depending on PROD or DEV mode. In
  // DEV mode, we create a separate object for Context.Consumer that acts
  // like a proxy to Context. This proxy object adds unnecessary code in PROD
  // so we use the old behaviour (Context.Consumer references Context) to
  // reduce size and overhead. The separate object references context via
  // a property called "_context", which also gives us the ability to check
  // in DEV mode if this property exists or not and warn if it does not.

  {
    if (context._context === undefined) {
      // This may be because it's a Context (rather than a Consumer).
      // Or it may be because it's older React where they're the same thing.
      // We only want to warn if we're sure it's a new React.
      if (context !== context.Consumer) {
        if (!hasWarnedAboutUsingContextAsConsumer) {
          hasWarnedAboutUsingContextAsConsumer = true;

          error('Rendering <Context> directly is not supported and will be removed in ' + 'a future major release. Did you mean to render <Context.Consumer> instead?');
        }
      }
    } else {
      context = context._context;
    }
  }

  var newProps = workInProgress.pendingProps;
  var render = newProps.children;

  {
    if (typeof render !== 'function') {
      error('A context consumer was rendered with multiple children, or a child ' + "that isn't a function. A context consumer expects a single child " + 'that is a function. If you did pass a function, make sure there ' + 'is no trailing or leading whitespace around it.');
    }
  }

  prepareToReadContext(workInProgress, renderLanes);
  var newValue = readContext(context, newProps.unstable_observedBits);
  var newChildren;

  {
    ReactCurrentOwner$1.current = workInProgress;
    setIsRendering(true);
    newChildren = render(newValue);
    setIsRendering(false);
  } // React DevTools reads this flag.


  workInProgress.flags |= PerformedWork;
  reconcileChildren(current, workInProgress, newChildren, renderLanes);
  return workInProgress.child;
}

function markWorkInProgressReceivedUpdate() {
  didReceiveUpdate = true;
}

function bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes) {
  if (current !== null) {
    // Reuse previous dependencies
    workInProgress.dependencies = current.dependencies;
  }

  {
    // Don't update "base" render times for bailouts.
    stopProfilerTimerIfRunning();
  }

  markSkippedUpdateLanes(workInProgress.lanes); // Check if the children have any pending work.

  if (!includesSomeLane(renderLanes, workInProgress.childLanes)) {
    // The children don't have any work either. We can skip them.
    // TODO: Once we add back resuming, we should check if the children are
    // a work-in-progress set. If so, we need to transfer their effects.
    return null;
  } else {
    // This fiber doesn't have work, but its subtree does. Clone the child
    // fibers and continue.
    cloneChildFibers(current, workInProgress);
    return workInProgress.child;
  }
}

function remountFiber(current, oldWorkInProgress, newWorkInProgress) {
  {
    var returnFiber = oldWorkInProgress.return;

    if (returnFiber === null) {
      throw new Error('Cannot swap the root fiber.');
    } // Disconnect from the old current.
    // It will get deleted.


    current.alternate = null;
    oldWorkInProgress.alternate = null; // Connect to the new tree.

    newWorkInProgress.index = oldWorkInProgress.index;
    newWorkInProgress.sibling = oldWorkInProgress.sibling;
    newWorkInProgress.return = oldWorkInProgress.return;
    newWorkInProgress.ref = oldWorkInProgress.ref; // Replace the child/sibling pointers above it.

    if (oldWorkInProgress === returnFiber.child) {
      returnFiber.child = newWorkInProgress;
    } else {
      var prevSibling = returnFiber.child;

      if (prevSibling === null) {
        throw new Error('Expected parent to have a child.');
      }

      while (prevSibling.sibling !== oldWorkInProgress) {
        prevSibling = prevSibling.sibling;

        if (prevSibling === null) {
          throw new Error('Expected to find the previous sibling.');
        }
      }

      prevSibling.sibling = newWorkInProgress;
    } // Delete the old fiber and place the new one.
    // Since the old fiber is disconnected, we have to schedule it manually.


    var last = returnFiber.lastEffect;

    if (last !== null) {
      last.nextEffect = current;
      returnFiber.lastEffect = current;
    } else {
      returnFiber.firstEffect = returnFiber.lastEffect = current;
    }

    current.nextEffect = null;
    current.flags = Deletion;
    newWorkInProgress.flags |= Placement; // Restart work from the new fiber.

    return newWorkInProgress;
  }
}

function beginWork(current, workInProgress, renderLanes) {
  var updateLanes = workInProgress.lanes;

  {
    if (workInProgress._debugNeedsRemount && current !== null) {
      // This will restart the begin phase with a new fiber.
      return remountFiber(current, workInProgress, createFiberFromTypeAndProps(workInProgress.type, workInProgress.key, workInProgress.pendingProps, workInProgress._debugOwner || null, workInProgress.mode, workInProgress.lanes));
    }
  }

  if (current !== null) {
    var oldProps = current.memoizedProps;
    var newProps = workInProgress.pendingProps;

    if (oldProps !== newProps || hasContextChanged() || ( // Force a re-render if the implementation changed due to hot reload:
     workInProgress.type !== current.type )) {
      // If props or context changed, mark the fiber as having performed work.
      // This may be unset if the props are determined to be equal later (memo).
      didReceiveUpdate = true;
    } else if (!includesSomeLane(renderLanes, updateLanes)) {
      didReceiveUpdate = false; // This fiber does not have any pending work. Bailout without entering
      // the begin phase. There's still some bookkeeping we that needs to be done
      // in this optimized path, mostly pushing stuff onto the stack.

      switch (workInProgress.tag) {
        case HostRoot:
          pushHostRootContext(workInProgress);
          resetHydrationState();
          break;

        case HostComponent:
          pushHostContext(workInProgress);
          break;

        case ClassComponent:
          {
            var Component = workInProgress.type;

            if (isContextProvider(Component)) {
              pushContextProvider(workInProgress);
            }

            break;
          }

        case HostPortal:
          pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo);
          break;

        case ContextProvider:
          {
            var newValue = workInProgress.memoizedProps.value;
            pushProvider(workInProgress, newValue);
            break;
          }

        case Profiler:
          {
            // Profiler should only call onRender when one of its descendants actually rendered.
            var hasChildWork = includesSomeLane(renderLanes, workInProgress.childLanes);

            if (hasChildWork) {
              workInProgress.flags |= Update;
            } // Reset effect durations for the next eventual effect phase.
            // These are reset during render to allow the DevTools commit hook a chance to read them,


            var stateNode = workInProgress.stateNode;
            stateNode.effectDuration = 0;
            stateNode.passiveEffectDuration = 0;
          }

          break;

        case SuspenseComponent:
          {
            var state = workInProgress.memoizedState;

            if (state !== null) {
              // whether to retry the primary children, or to skip over it and
              // go straight to the fallback. Check the priority of the primary
              // child fragment.


              var primaryChildFragment = workInProgress.child;
              var primaryChildLanes = primaryChildFragment.childLanes;

              if (includesSomeLane(renderLanes, primaryChildLanes)) {
                // The primary children have pending work. Use the normal path
                // to attempt to render the primary children again.
                return updateSuspenseComponent(current, workInProgress, renderLanes);
              } else {
                // The primary child fragment does not have pending work marked
                // on it
                pushSuspenseContext(workInProgress, setDefaultShallowSuspenseContext(suspenseStackCursor.current)); // The primary children do not have pending work with sufficient
                // priority. Bailout.

                var child = bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);

                if (child !== null) {
                  // The fallback children have pending work. Skip over the
                  // primary children and work on the fallback.
                  return child.sibling;
                } else {
                  return null;
                }
              }
            } else {
              pushSuspenseContext(workInProgress, setDefaultShallowSuspenseContext(suspenseStackCursor.current));
            }

            break;
          }

        case SuspenseListComponent:
          {
            var didSuspendBefore = (current.flags & DidCapture) !== NoFlags;

            var _hasChildWork = includesSomeLane(renderLanes, workInProgress.childLanes);

            if (didSuspendBefore) {
              if (_hasChildWork) {
                // If something was in fallback state last time, and we have all the
                // same children then we're still in progressive loading state.
                // Something might get unblocked by state updates or retries in the
                // tree which will affect the tail. So we need to use the normal
                // path to compute the correct tail.
                return updateSuspenseListComponent(current, workInProgress, renderLanes);
              } // If none of the children had any work, that means that none of
              // them got retried so they'll still be blocked in the same way
              // as before. We can fast bail out.


              workInProgress.flags |= DidCapture;
            } // If nothing suspended before and we're rendering the same children,
            // then the tail doesn't matter. Anything new that suspends will work
            // in the "together" mode, so we can continue from the state we had.


            var renderState = workInProgress.memoizedState;

            if (renderState !== null) {
              // Reset to the "together" mode in case we've started a different
              // update in the past but didn't complete it.
              renderState.rendering = null;
              renderState.tail = null;
              renderState.lastEffect = null;
            }

            pushSuspenseContext(workInProgress, suspenseStackCursor.current);

            if (_hasChildWork) {
              break;
            } else {
              // If none of the children had any work, that means that none of
              // them got retried so they'll still be blocked in the same way
              // as before. We can fast bail out.
              return null;
            }
          }

        case OffscreenComponent:
        case LegacyHiddenComponent:
          {
            // Need to check if the tree still needs to be deferred. This is
            // almost identical to the logic used in the normal update path,
            // so we'll just enter that. The only difference is we'll bail out
            // at the next level instead of this one, because the child props
            // have not changed. Which is fine.
            // TODO: Probably should refactor `beginWork` to split the bailout
            // path from the normal path. I'm tempted to do a labeled break here
            // but I won't :)
            workInProgress.lanes = NoLanes;
            return updateOffscreenComponent(current, workInProgress, renderLanes);
          }
      }

      return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);
    } else {
      if ((current.flags & ForceUpdateForLegacySuspense) !== NoFlags) {
        // This is a special case that only exists for legacy mode.
        // See https://github.com/facebook/react/pull/19216.
        didReceiveUpdate = true;
      } else {
        // An update was scheduled on this fiber, but there are no new props
        // nor legacy context. Set this to false. If an update queue or context
        // consumer produces a changed value, it will set this to true. Otherwise,
        // the component will assume the children have not changed and bail out.
        didReceiveUpdate = false;
      }
    }
  } else {
    didReceiveUpdate = false;
  } // Before entering the begin phase, clear pending update priority.
  // TODO: This assumes that we're about to evaluate the component and process
  // the update queue. However, there's an exception: SimpleMemoComponent
  // sometimes bails out later in the begin phase. This indicates that we should
  // move this assignment out of the common path and into each branch.


  workInProgress.lanes = NoLanes;

  switch (workInProgress.tag) {
    case IndeterminateComponent:
      {
        return mountIndeterminateComponent(current, workInProgress, workInProgress.type, renderLanes);
      }

    case LazyComponent:
      {
        var elementType = workInProgress.elementType;
        return mountLazyComponent(current, workInProgress, elementType, updateLanes, renderLanes);
      }

    case FunctionComponent:
      {
        var _Component = workInProgress.type;
        var unresolvedProps = workInProgress.pendingProps;
        var resolvedProps = workInProgress.elementType === _Component ? unresolvedProps : resolveDefaultProps(_Component, unresolvedProps);
        return updateFunctionComponent(current, workInProgress, _Component, resolvedProps, renderLanes);
      }

    case ClassComponent:
      {
        var _Component2 = workInProgress.type;
        var _unresolvedProps = workInProgress.pendingProps;

        var _resolvedProps = workInProgress.elementType === _Component2 ? _unresolvedProps : resolveDefaultProps(_Component2, _unresolvedProps);

        return updateClassComponent(current, workInProgress, _Component2, _resolvedProps, renderLanes);
      }

    case HostRoot:
      return updateHostRoot(current, workInProgress, renderLanes);

    case HostComponent:
      return updateHostComponent(current, workInProgress, renderLanes);

    case HostText:
      return updateHostText(current, workInProgress);

    case SuspenseComponent:
      return updateSuspenseComponent(current, workInProgress, renderLanes);

    case HostPortal:
      return updatePortalComponent(current, workInProgress, renderLanes);

    case ForwardRef:
      {
        var type = workInProgress.type;
        var _unresolvedProps2 = workInProgress.pendingProps;

        var _resolvedProps2 = workInProgress.elementType === type ? _unresolvedProps2 : resolveDefaultProps(type, _unresolvedProps2);

        return updateForwardRef(current, workInProgress, type, _resolvedProps2, renderLanes);
      }

    case Fragment:
      return updateFragment(current, workInProgress, renderLanes);

    case Mode:
      return updateMode(current, workInProgress, renderLanes);

    case Profiler:
      return updateProfiler(current, workInProgress, renderLanes);

    case ContextProvider:
      return updateContextProvider(current, workInProgress, renderLanes);

    case ContextConsumer:
      return updateContextConsumer(current, workInProgress, renderLanes);

    case MemoComponent:
      {
        var _type2 = workInProgress.type;
        var _unresolvedProps3 = workInProgress.pendingProps; // Resolve outer props first, then resolve inner props.

        var _resolvedProps3 = resolveDefaultProps(_type2, _unresolvedProps3);

        {
          if (workInProgress.type !== workInProgress.elementType) {
            var outerPropTypes = _type2.propTypes;

            if (outerPropTypes) {
              checkPropTypes(outerPropTypes, _resolvedProps3, // Resolved for outer only
              'prop', getComponentName(_type2));
            }
          }
        }

        _resolvedProps3 = resolveDefaultProps(_type2.type, _resolvedProps3);
        return updateMemoComponent(current, workInProgress, _type2, _resolvedProps3, updateLanes, renderLanes);
      }

    case SimpleMemoComponent:
      {
        return updateSimpleMemoComponent(current, workInProgress, workInProgress.type, workInProgress.pendingProps, updateLanes, renderLanes);
      }

    case IncompleteClassComponent:
      {
        var _Component3 = workInProgress.type;
        var _unresolvedProps4 = workInProgress.pendingProps;

        var _resolvedProps4 = workInProgress.elementType === _Component3 ? _unresolvedProps4 : resolveDefaultProps(_Component3, _unresolvedProps4);

        return mountIncompleteClassComponent(current, workInProgress, _Component3, _resolvedProps4, renderLanes);
      }

    case SuspenseListComponent:
      {
        return updateSuspenseListComponent(current, workInProgress, renderLanes);
      }

    case FundamentalComponent:
      {

        break;
      }

    case ScopeComponent:
      {

        break;
      }

    case Block:
      {

        break;
      }

    case OffscreenComponent:
      {
        return updateOffscreenComponent(current, workInProgress, renderLanes);
      }

    case LegacyHiddenComponent:
      {
        return updateLegacyHiddenComponent(current, workInProgress, renderLanes);
      }
  }

  {
    {
      throw Error( "Unknown unit of work tag (" + workInProgress.tag + "). This error is likely caused by a bug in React. Please file an issue." );
    }
  }
}

function markUpdate(workInProgress) {
  // Tag the fiber with an update effect. This turns a Placement into
  // a PlacementAndUpdate.
  workInProgress.flags |= Update;
}

function markRef$1(workInProgress) {
  workInProgress.flags |= Ref;
}

var appendAllChildren;
var updateHostContainer;
var updateHostComponent$1;
var updateHostText$1;

{
  // Mutation mode
  appendAllChildren = function (parent, workInProgress, needsVisibilityToggle, isHidden) {
    // We only have the top Fiber that was created but we need recurse down its
    // children to find all the terminal nodes.
    var node = workInProgress.child;

    while (node !== null) {
      if (node.tag === HostComponent || node.tag === HostText) {
        appendInitialChild(parent, node.stateNode);
      } else if (node.tag === HostPortal) ; else if (node.child !== null) {
        node.child.return = node;
        node = node.child;
        continue;
      }

      if (node === workInProgress) {
        return;
      }

      while (node.sibling === null) {
        if (node.return === null || node.return === workInProgress) {
          return;
        }

        node = node.return;
      }

      node.sibling.return = node.return;
      node = node.sibling;
    }
  };

  updateHostContainer = function (workInProgress) {// Noop
  };

  updateHostComponent$1 = function (current, workInProgress, type, newProps, rootContainerInstance) {
    // If we have an alternate, that means this is an update and we need to
    // schedule a side-effect to do the updates.
    var oldProps = current.memoizedProps;

    if (oldProps === newProps) {
      // In mutation mode, this is sufficient for a bailout because
      // we won't touch this node even if children changed.
      return;
    } // If we get updated because one of our children updated, we don't
    // have newProps so we'll have to reuse them.
    // TODO: Split the update API as separate for the props vs. children.
    // Even better would be if children weren't special cased at all tho.


    var instance = workInProgress.stateNode;
    var currentHostContext = getHostContext(); // TODO: Experiencing an error where oldProps is null. Suggests a host
    // component is hitting the resume path. Figure out why. Possibly
    // related to `hidden`.

    var updatePayload = prepareUpdate(instance, type, oldProps, newProps, rootContainerInstance, currentHostContext); // TODO: Type this specific to this type of component.

    workInProgress.updateQueue = updatePayload; // If the update payload indicates that there is a change or if there
    // is a new ref we mark this as an update. All the work is done in commitWork.

    if (updatePayload) {
      markUpdate(workInProgress);
    }
  };

  updateHostText$1 = function (current, workInProgress, oldText, newText) {
    // If the text differs, mark it as an update. All the work in done in commitWork.
    if (oldText !== newText) {
      markUpdate(workInProgress);
    }
  };
}

function cutOffTailIfNeeded(renderState, hasRenderedATailFallback) {
  if (getIsHydrating()) {
    // If we're hydrating, we should consume as many items as we can
    // so we don't leave any behind.
    return;
  }

  switch (renderState.tailMode) {
    case 'hidden':
      {
        // Any insertions at the end of the tail list after this point
        // should be invisible. If there are already mounted boundaries
        // anything before them are not considered for collapsing.
        // Therefore we need to go through the whole tail to find if
        // there are any.
        var tailNode = renderState.tail;
        var lastTailNode = null;

        while (tailNode !== null) {
          if (tailNode.alternate !== null) {
            lastTailNode = tailNode;
          }

          tailNode = tailNode.sibling;
        } // Next we're simply going to delete all insertions after the
        // last rendered item.


        if (lastTailNode === null) {
          // All remaining items in the tail are insertions.
          renderState.tail = null;
        } else {
          // Detach the insertion after the last node that was already
          // inserted.
          lastTailNode.sibling = null;
        }

        break;
      }

    case 'collapsed':
      {
        // Any insertions at the end of the tail list after this point
        // should be invisible. If there are already mounted boundaries
        // anything before them are not considered for collapsing.
        // Therefore we need to go through the whole tail to find if
        // there are any.
        var _tailNode = renderState.tail;
        var _lastTailNode = null;

        while (_tailNode !== null) {
          if (_tailNode.alternate !== null) {
            _lastTailNode = _tailNode;
          }

          _tailNode = _tailNode.sibling;
        } // Next we're simply going to delete all insertions after the
        // last rendered item.


        if (_lastTailNode === null) {
          // All remaining items in the tail are insertions.
          if (!hasRenderedATailFallback && renderState.tail !== null) {
            // We suspended during the head. We want to show at least one
            // row at the tail. So we'll keep on and cut off the rest.
            renderState.tail.sibling = null;
          } else {
            renderState.tail = null;
          }
        } else {
          // Detach the insertion after the last node that was already
          // inserted.
          _lastTailNode.sibling = null;
        }

        break;
      }
  }
}

function completeWork(current, workInProgress, renderLanes) {
  var newProps = workInProgress.pendingProps;

  switch (workInProgress.tag) {
    case IndeterminateComponent:
    case LazyComponent:
    case SimpleMemoComponent:
    case FunctionComponent:
    case ForwardRef:
    case Fragment:
    case Mode:
    case Profiler:
    case ContextConsumer:
    case MemoComponent:
      return null;

    case ClassComponent:
      {
        var Component = workInProgress.type;

        if (isContextProvider(Component)) {
          popContext(workInProgress);
        }

        return null;
      }

    case HostRoot:
      {
        popHostContainer(workInProgress);
        popTopLevelContextObject(workInProgress);
        resetWorkInProgressVersions();
        var fiberRoot = workInProgress.stateNode;

        if (fiberRoot.pendingContext) {
          fiberRoot.context = fiberRoot.pendingContext;
          fiberRoot.pendingContext = null;
        }

        if (current === null || current.child === null) {
          // If we hydrated, pop so that we can delete any remaining children
          // that weren't hydrated.
          var wasHydrated = popHydrationState(workInProgress);

          if (wasHydrated) {
            // If we hydrated, then we'll need to schedule an update for
            // the commit side-effects on the root.
            markUpdate(workInProgress);
          } else if (!fiberRoot.hydrate) {
            // Schedule an effect to clear this container at the start of the next commit.
            // This handles the case of React rendering into a container with previous children.
            // It's also safe to do for updates too, because current.child would only be null
            // if the previous render was null (so the the container would already be empty).
            workInProgress.flags |= Snapshot;
          }
        }

        updateHostContainer(workInProgress);
        return null;
      }

    case HostComponent:
      {
        popHostContext(workInProgress);
        var rootContainerInstance = getRootHostContainer();
        var type = workInProgress.type;

        if (current !== null && workInProgress.stateNode != null) {
          updateHostComponent$1(current, workInProgress, type, newProps, rootContainerInstance);

          if (current.ref !== workInProgress.ref) {
            markRef$1(workInProgress);
          }
        } else {
          if (!newProps) {
            if (!(workInProgress.stateNode !== null)) {
              {
                throw Error( "We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue." );
              }
            } // This can happen when we abort work.


            return null;
          }

          var currentHostContext = getHostContext(); // TODO: Move createInstance to beginWork and keep it on a context
          // "stack" as the parent. Then append children as we go in beginWork
          // or completeWork depending on whether we want to add them top->down or
          // bottom->up. Top->down is faster in IE11.

          var _wasHydrated = popHydrationState(workInProgress);

          if (_wasHydrated) {
            // TODO: Move this and createInstance step into the beginPhase
            // to consolidate.
            if (prepareToHydrateHostInstance(workInProgress, rootContainerInstance, currentHostContext)) {
              // If changes to the hydrated node need to be applied at the
              // commit-phase we mark this as such.
              markUpdate(workInProgress);
            }
          } else {
            var instance = createInstance(type, newProps, rootContainerInstance, currentHostContext, workInProgress);
            appendAllChildren(instance, workInProgress, false, false);
            workInProgress.stateNode = instance; // Certain renderers require commit-time effects for initial mount.
            // (eg DOM renderer supports auto-focus for certain elements).
            // Make sure such renderers get scheduled for later work.

            if (finalizeInitialChildren(instance, type, newProps, rootContainerInstance)) {
              markUpdate(workInProgress);
            }
          }

          if (workInProgress.ref !== null) {
            // If there is a ref on a host node we need to schedule a callback
            markRef$1(workInProgress);
          }
        }

        return null;
      }

    case HostText:
      {
        var newText = newProps;

        if (current && workInProgress.stateNode != null) {
          var oldText = current.memoizedProps; // If we have an alternate, that means this is an update and we need
          // to schedule a side-effect to do the updates.

          updateHostText$1(current, workInProgress, oldText, newText);
        } else {
          if (typeof newText !== 'string') {
            if (!(workInProgress.stateNode !== null)) {
              {
                throw Error( "We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue." );
              }
            } // This can happen when we abort work.

          }

          var _rootContainerInstance = getRootHostContainer();

          var _currentHostContext = getHostContext();

          var _wasHydrated2 = popHydrationState(workInProgress);

          if (_wasHydrated2) {
            if (prepareToHydrateHostTextInstance(workInProgress)) {
              markUpdate(workInProgress);
            }
          } else {
            workInProgress.stateNode = createTextInstance(newText, _rootContainerInstance, _currentHostContext, workInProgress);
          }
        }

        return null;
      }

    case SuspenseComponent:
      {
        popSuspenseContext(workInProgress);
        var nextState = workInProgress.memoizedState;

        if ((workInProgress.flags & DidCapture) !== NoFlags) {
          // Something suspended. Re-render with the fallback children.
          workInProgress.lanes = renderLanes; // Do not reset the effect list.

          if ( (workInProgress.mode & ProfileMode) !== NoMode) {
            transferActualDuration(workInProgress);
          }

          return workInProgress;
        }

        var nextDidTimeout = nextState !== null;
        var prevDidTimeout = false;

        if (current === null) {
          if (workInProgress.memoizedProps.fallback !== undefined) {
            popHydrationState(workInProgress);
          }
        } else {
          var prevState = current.memoizedState;
          prevDidTimeout = prevState !== null;
        }

        if (nextDidTimeout && !prevDidTimeout) {
          // If this subtreee is running in blocking mode we can suspend,
          // otherwise we won't suspend.
          // TODO: This will still suspend a synchronous tree if anything
          // in the concurrent tree already suspended during this render.
          // This is a known bug.
          if ((workInProgress.mode & BlockingMode) !== NoMode) {
            // TODO: Move this back to throwException because this is too late
            // if this is a large tree which is common for initial loads. We
            // don't know if we should restart a render or not until we get
            // this marker, and this is too late.
            // If this render already had a ping or lower pri updates,
            // and this is the first time we know we're going to suspend we
            // should be able to immediately restart from within throwException.
            var hasInvisibleChildContext = current === null && workInProgress.memoizedProps.unstable_avoidThisFallback !== true;

            if (hasInvisibleChildContext || hasSuspenseContext(suspenseStackCursor.current, InvisibleParentSuspenseContext)) {
              // If this was in an invisible tree or a new render, then showing
              // this boundary is ok.
              renderDidSuspend();
            } else {
              // Otherwise, we're going to have to hide content so we should
              // suspend for longer if possible.
              renderDidSuspendDelayIfPossible();
            }
          }
        }

        {
          // TODO: Only schedule updates if these values are non equal, i.e. it changed.
          if (nextDidTimeout || prevDidTimeout) {
            // If this boundary just timed out, schedule an effect to attach a
            // retry listener to the promise. This flag is also used to hide the
            // primary children. In mutation mode, we also need the flag to
            // *unhide* children that were previously hidden, so check if this
            // is currently timed out, too.
            workInProgress.flags |= Update;
          }
        }

        return null;
      }

    case HostPortal:
      popHostContainer(workInProgress);
      updateHostContainer(workInProgress);

      if (current === null) {
        preparePortalMount(workInProgress.stateNode.containerInfo);
      }

      return null;

    case ContextProvider:
      // Pop provider fiber
      popProvider(workInProgress);
      return null;

    case IncompleteClassComponent:
      {
        // Same as class component case. I put it down here so that the tags are
        // sequential to ensure this switch is compiled to a jump table.
        var _Component = workInProgress.type;

        if (isContextProvider(_Component)) {
          popContext(workInProgress);
        }

        return null;
      }

    case SuspenseListComponent:
      {
        popSuspenseContext(workInProgress);
        var renderState = workInProgress.memoizedState;

        if (renderState === null) {
          // We're running in the default, "independent" mode.
          // We don't do anything in this mode.
          return null;
        }

        var didSuspendAlready = (workInProgress.flags & DidCapture) !== NoFlags;
        var renderedTail = renderState.rendering;

        if (renderedTail === null) {
          // We just rendered the head.
          if (!didSuspendAlready) {
            // This is the first pass. We need to figure out if anything is still
            // suspended in the rendered set.
            // If new content unsuspended, but there's still some content that
            // didn't. Then we need to do a second pass that forces everything
            // to keep showing their fallbacks.
            // We might be suspended if something in this render pass suspended, or
            // something in the previous committed pass suspended. Otherwise,
            // there's no chance so we can skip the expensive call to
            // findFirstSuspended.
            var cannotBeSuspended = renderHasNotSuspendedYet() && (current === null || (current.flags & DidCapture) === NoFlags);

            if (!cannotBeSuspended) {
              var row = workInProgress.child;

              while (row !== null) {
                var suspended = findFirstSuspended(row);

                if (suspended !== null) {
                  didSuspendAlready = true;
                  workInProgress.flags |= DidCapture;
                  cutOffTailIfNeeded(renderState, false); // If this is a newly suspended tree, it might not get committed as
                  // part of the second pass. In that case nothing will subscribe to
                  // its thennables. Instead, we'll transfer its thennables to the
                  // SuspenseList so that it can retry if they resolve.
                  // There might be multiple of these in the list but since we're
                  // going to wait for all of them anyway, it doesn't really matter
                  // which ones gets to ping. In theory we could get clever and keep
                  // track of how many dependencies remain but it gets tricky because
                  // in the meantime, we can add/remove/change items and dependencies.
                  // We might bail out of the loop before finding any but that
                  // doesn't matter since that means that the other boundaries that
                  // we did find already has their listeners attached.

                  var newThennables = suspended.updateQueue;

                  if (newThennables !== null) {
                    workInProgress.updateQueue = newThennables;
                    workInProgress.flags |= Update;
                  } // Rerender the whole list, but this time, we'll force fallbacks
                  // to stay in place.
                  // Reset the effect list before doing the second pass since that's now invalid.


                  if (renderState.lastEffect === null) {
                    workInProgress.firstEffect = null;
                  }

                  workInProgress.lastEffect = renderState.lastEffect; // Reset the child fibers to their original state.

                  resetChildFibers(workInProgress, renderLanes); // Set up the Suspense Context to force suspense and immediately
                  // rerender the children.

                  pushSuspenseContext(workInProgress, setShallowSuspenseContext(suspenseStackCursor.current, ForceSuspenseFallback));
                  return workInProgress.child;
                }

                row = row.sibling;
              }
            }

            if (renderState.tail !== null && now() > getRenderTargetTime()) {
              // We have already passed our CPU deadline but we still have rows
              // left in the tail. We'll just give up further attempts to render
              // the main content and only render fallbacks.
              workInProgress.flags |= DidCapture;
              didSuspendAlready = true;
              cutOffTailIfNeeded(renderState, false); // Since nothing actually suspended, there will nothing to ping this
              // to get it started back up to attempt the next item. While in terms
              // of priority this work has the same priority as this current render,
              // it's not part of the same transition once the transition has
              // committed. If it's sync, we still want to yield so that it can be
              // painted. Conceptually, this is really the same as pinging.
              // We can use any RetryLane even if it's the one currently rendering
              // since we're leaving it behind on this node.

              workInProgress.lanes = SomeRetryLane;

              {
                markSpawnedWork(SomeRetryLane);
              }
            }
          } else {
            cutOffTailIfNeeded(renderState, false);
          } // Next we're going to render the tail.

        } else {
          // Append the rendered row to the child list.
          if (!didSuspendAlready) {
            var _suspended = findFirstSuspended(renderedTail);

            if (_suspended !== null) {
              workInProgress.flags |= DidCapture;
              didSuspendAlready = true; // Ensure we transfer the update queue to the parent so that it doesn't
              // get lost if this row ends up dropped during a second pass.

              var _newThennables = _suspended.updateQueue;

              if (_newThennables !== null) {
                workInProgress.updateQueue = _newThennables;
                workInProgress.flags |= Update;
              }

              cutOffTailIfNeeded(renderState, true); // This might have been modified.

              if (renderState.tail === null && renderState.tailMode === 'hidden' && !renderedTail.alternate && !getIsHydrating() // We don't cut it if we're hydrating.
              ) {
                  // We need to delete the row we just rendered.
                  // Reset the effect list to what it was before we rendered this
                  // child. The nested children have already appended themselves.
                  var lastEffect = workInProgress.lastEffect = renderState.lastEffect; // Remove any effects that were appended after this point.

                  if (lastEffect !== null) {
                    lastEffect.nextEffect = null;
                  } // We're done.


                  return null;
                }
            } else if ( // The time it took to render last row is greater than the remaining
            // time we have to render. So rendering one more row would likely
            // exceed it.
            now() * 2 - renderState.renderingStartTime > getRenderTargetTime() && renderLanes !== OffscreenLane) {
              // We have now passed our CPU deadline and we'll just give up further
              // attempts to render the main content and only render fallbacks.
              // The assumption is that this is usually faster.
              workInProgress.flags |= DidCapture;
              didSuspendAlready = true;
              cutOffTailIfNeeded(renderState, false); // Since nothing actually suspended, there will nothing to ping this
              // to get it started back up to attempt the next item. While in terms
              // of priority this work has the same priority as this current render,
              // it's not part of the same transition once the transition has
              // committed. If it's sync, we still want to yield so that it can be
              // painted. Conceptually, this is really the same as pinging.
              // We can use any RetryLane even if it's the one currently rendering
              // since we're leaving it behind on this node.

              workInProgress.lanes = SomeRetryLane;

              {
                markSpawnedWork(SomeRetryLane);
              }
            }
          }

          if (renderState.isBackwards) {
            // The effect list of the backwards tail will have been added
            // to the end. This breaks the guarantee that life-cycles fire in
            // sibling order but that isn't a strong guarantee promised by React.
            // Especially since these might also just pop in during future commits.
            // Append to the beginning of the list.
            renderedTail.sibling = workInProgress.child;
            workInProgress.child = renderedTail;
          } else {
            var previousSibling = renderState.last;

            if (previousSibling !== null) {
              previousSibling.sibling = renderedTail;
            } else {
              workInProgress.child = renderedTail;
            }

            renderState.last = renderedTail;
          }
        }

        if (renderState.tail !== null) {
          // We still have tail rows to render.
          // Pop a row.
          var next = renderState.tail;
          renderState.rendering = next;
          renderState.tail = next.sibling;
          renderState.lastEffect = workInProgress.lastEffect;
          renderState.renderingStartTime = now();
          next.sibling = null; // Restore the context.
          // TODO: We can probably just avoid popping it instead and only
          // setting it the first time we go from not suspended to suspended.

          var suspenseContext = suspenseStackCursor.current;

          if (didSuspendAlready) {
            suspenseContext = setShallowSuspenseContext(suspenseContext, ForceSuspenseFallback);
          } else {
            suspenseContext = setDefaultShallowSuspenseContext(suspenseContext);
          }

          pushSuspenseContext(workInProgress, suspenseContext); // Do a pass over the next row.

          return next;
        }

        return null;
      }

    case FundamentalComponent:
      {

        break;
      }

    case ScopeComponent:
      {

        break;
      }

    case Block:

      break;

    case OffscreenComponent:
    case LegacyHiddenComponent:
      {
        popRenderLanes(workInProgress);

        if (current !== null) {
          var _nextState = workInProgress.memoizedState;
          var _prevState = current.memoizedState;
          var prevIsHidden = _prevState !== null;
          var nextIsHidden = _nextState !== null;

          if (prevIsHidden !== nextIsHidden && newProps.mode !== 'unstable-defer-without-hiding') {
            workInProgress.flags |= Update;
          }
        }

        return null;
      }
  }

  {
    {
      throw Error( "Unknown unit of work tag (" + workInProgress.tag + "). This error is likely caused by a bug in React. Please file an issue." );
    }
  }
}

function unwindWork(workInProgress, renderLanes) {
  switch (workInProgress.tag) {
    case ClassComponent:
      {
        var Component = workInProgress.type;

        if (isContextProvider(Component)) {
          popContext(workInProgress);
        }

        var flags = workInProgress.flags;

        if (flags & ShouldCapture) {
          workInProgress.flags = flags & ~ShouldCapture | DidCapture;

          if ( (workInProgress.mode & ProfileMode) !== NoMode) {
            transferActualDuration(workInProgress);
          }

          return workInProgress;
        }

        return null;
      }

    case HostRoot:
      {
        popHostContainer(workInProgress);
        popTopLevelContextObject(workInProgress);
        resetWorkInProgressVersions();
        var _flags = workInProgress.flags;

        if (!((_flags & DidCapture) === NoFlags)) {
          {
            throw Error( "The root failed to unmount after an error. This is likely a bug in React. Please file an issue." );
          }
        }

        workInProgress.flags = _flags & ~ShouldCapture | DidCapture;
        return workInProgress;
      }

    case HostComponent:
      {
        // TODO: popHydrationState
        popHostContext(workInProgress);
        return null;
      }

    case SuspenseComponent:
      {
        popSuspenseContext(workInProgress);

        var _flags2 = workInProgress.flags;

        if (_flags2 & ShouldCapture) {
          workInProgress.flags = _flags2 & ~ShouldCapture | DidCapture; // Captured a suspense effect. Re-render the boundary.

          if ( (workInProgress.mode & ProfileMode) !== NoMode) {
            transferActualDuration(workInProgress);
          }

          return workInProgress;
        }

        return null;
      }

    case SuspenseListComponent:
      {
        popSuspenseContext(workInProgress); // SuspenseList doesn't actually catch anything. It should've been
        // caught by a nested boundary. If not, it should bubble through.

        return null;
      }

    case HostPortal:
      popHostContainer(workInProgress);
      return null;

    case ContextProvider:
      popProvider(workInProgress);
      return null;

    case OffscreenComponent:
    case LegacyHiddenComponent:
      popRenderLanes(workInProgress);
      return null;

    default:
      return null;
  }
}

function unwindInterruptedWork(interruptedWork) {
  switch (interruptedWork.tag) {
    case ClassComponent:
      {
        var childContextTypes = interruptedWork.type.childContextTypes;

        if (childContextTypes !== null && childContextTypes !== undefined) {
          popContext(interruptedWork);
        }

        break;
      }

    case HostRoot:
      {
        popHostContainer(interruptedWork);
        popTopLevelContextObject(interruptedWork);
        resetWorkInProgressVersions();
        break;
      }

    case HostComponent:
      {
        popHostContext(interruptedWork);
        break;
      }

    case HostPortal:
      popHostContainer(interruptedWork);
      break;

    case SuspenseComponent:
      popSuspenseContext(interruptedWork);
      break;

    case SuspenseListComponent:
      popSuspenseContext(interruptedWork);
      break;

    case ContextProvider:
      popProvider(interruptedWork);
      break;

    case OffscreenComponent:
    case LegacyHiddenComponent:
      popRenderLanes(interruptedWork);
      break;
  }
}

function createCapturedValue(value, source) {
  // If the value is an error, call this function immediately after it is thrown
  // so the stack is accurate.
  return {
    value: value,
    source: source,
    stack: getStackByFiberInDevAndProd(source)
  };
}

// This module is forked in different environments.
// By default, return `true` to log errors to the console.
// Forks can return `false` if this isn't desirable.
function showErrorDialog(boundary, errorInfo) {
  return true;
}

function logCapturedError(boundary, errorInfo) {
  try {
    var logError = showErrorDialog(boundary, errorInfo); // Allow injected showErrorDialog() to prevent default console.error logging.
    // This enables renderers like ReactNative to better manage redbox behavior.

    if (logError === false) {
      return;
    }

    var error = errorInfo.value;

    if (true) {
      var source = errorInfo.source;
      var stack = errorInfo.stack;
      var componentStack = stack !== null ? stack : ''; // Browsers support silencing uncaught errors by calling
      // `preventDefault()` in window `error` handler.
      // We record this information as an expando on the error.

      if (error != null && error._suppressLogging) {
        if (boundary.tag === ClassComponent) {
          // The error is recoverable and was silenced.
          // Ignore it and don't print the stack addendum.
          // This is handy for testing error boundaries without noise.
          return;
        } // The error is fatal. Since the silencing might have
        // been accidental, we'll surface it anyway.
        // However, the browser would have silenced the original error
        // so we'll print it first, and then print the stack addendum.


        console['error'](error); // Don't transform to our wrapper
        // For a more detailed description of this block, see:
        // https://github.com/facebook/react/pull/13384
      }

      var componentName = source ? getComponentName(source.type) : null;
      var componentNameMessage = componentName ? "The above error occurred in the <" + componentName + "> component:" : 'The above error occurred in one of your React components:';
      var errorBoundaryMessage;
      var errorBoundaryName = getComponentName(boundary.type);

      if (errorBoundaryName) {
        errorBoundaryMessage = "React will try to recreate this component tree from scratch " + ("using the error boundary you provided, " + errorBoundaryName + ".");
      } else {
        errorBoundaryMessage = 'Consider adding an error boundary to your tree to customize error handling behavior.\n' + 'Visit https://reactjs.org/link/error-boundaries to learn more about error boundaries.';
      }

      var combinedMessage = componentNameMessage + "\n" + componentStack + "\n\n" + ("" + errorBoundaryMessage); // In development, we provide our own message with just the component stack.
      // We don't include the original error message and JS stack because the browser
      // has already printed it. Even if the application swallows the error, it is still
      // displayed by the browser thanks to the DEV-only fake event trick in ReactErrorUtils.

      console['error'](combinedMessage); // Don't transform to our wrapper
    } else {}
  } catch (e) {
    // This method must not throw, or React internal state will get messed up.
    // If console.error is overridden, or logCapturedError() shows a dialog that throws,
    // we want to report this error outside of the normal stack as a last resort.
    // https://github.com/facebook/react/issues/13188
    setTimeout(function () {
      throw e;
    });
  }
}

var PossiblyWeakMap$1 = typeof WeakMap === 'function' ? WeakMap : Map;

function createRootErrorUpdate(fiber, errorInfo, lane) {
  var update = createUpdate(NoTimestamp, lane); // Unmount the root by rendering null.

  update.tag = CaptureUpdate; // Caution: React DevTools currently depends on this property
  // being called "element".

  update.payload = {
    element: null
  };
  var error = errorInfo.value;

  update.callback = function () {
    onUncaughtError(error);
    logCapturedError(fiber, errorInfo);
  };

  return update;
}

function createClassErrorUpdate(fiber, errorInfo, lane) {
  var update = createUpdate(NoTimestamp, lane);
  update.tag = CaptureUpdate;
  var getDerivedStateFromError = fiber.type.getDerivedStateFromError;

  if (typeof getDerivedStateFromError === 'function') {
    var error$1 = errorInfo.value;

    update.payload = function () {
      logCapturedError(fiber, errorInfo);
      return getDerivedStateFromError(error$1);
    };
  }

  var inst = fiber.stateNode;

  if (inst !== null && typeof inst.componentDidCatch === 'function') {
    update.callback = function callback() {
      {
        markFailedErrorBoundaryForHotReloading(fiber);
      }

      if (typeof getDerivedStateFromError !== 'function') {
        // To preserve the preexisting retry behavior of error boundaries,
        // we keep track of which ones already failed during this batch.
        // This gets reset before we yield back to the browser.
        // TODO: Warn in strict mode if getDerivedStateFromError is
        // not defined.
        markLegacyErrorBoundaryAsFailed(this); // Only log here if componentDidCatch is the only error boundary method defined

        logCapturedError(fiber, errorInfo);
      }

      var error$1 = errorInfo.value;
      var stack = errorInfo.stack;
      this.componentDidCatch(error$1, {
        componentStack: stack !== null ? stack : ''
      });

      {
        if (typeof getDerivedStateFromError !== 'function') {
          // If componentDidCatch is the only error boundary method defined,
          // then it needs to call setState to recover from errors.
          // If no state update is scheduled then the boundary will swallow the error.
          if (!includesSomeLane(fiber.lanes, SyncLane)) {
            error('%s: Error boundaries should implement getDerivedStateFromError(). ' + 'In that method, return a state update to display an error message or fallback UI.', getComponentName(fiber.type) || 'Unknown');
          }
        }
      }
    };
  } else {
    update.callback = function () {
      markFailedErrorBoundaryForHotReloading(fiber);
    };
  }

  return update;
}

function attachPingListener(root, wakeable, lanes) {
  // Attach a listener to the promise to "ping" the root and retry. But only if
  // one does not already exist for the lanes we're currently rendering (which
  // acts like a "thread ID" here).
  var pingCache = root.pingCache;
  var threadIDs;

  if (pingCache === null) {
    pingCache = root.pingCache = new PossiblyWeakMap$1();
    threadIDs = new Set();
    pingCache.set(wakeable, threadIDs);
  } else {
    threadIDs = pingCache.get(wakeable);

    if (threadIDs === undefined) {
      threadIDs = new Set();
      pingCache.set(wakeable, threadIDs);
    }
  }

  if (!threadIDs.has(lanes)) {
    // Memoize using the thread ID to prevent redundant listeners.
    threadIDs.add(lanes);
    var ping = pingSuspendedRoot.bind(null, root, wakeable, lanes);
    wakeable.then(ping, ping);
  }
}

function throwException(root, returnFiber, sourceFiber, value, rootRenderLanes) {
  // The source fiber did not complete.
  sourceFiber.flags |= Incomplete; // Its effect list is no longer valid.

  sourceFiber.firstEffect = sourceFiber.lastEffect = null;

  if (value !== null && typeof value === 'object' && typeof value.then === 'function') {
    // This is a wakeable.
    var wakeable = value;

    if ((sourceFiber.mode & BlockingMode) === NoMode) {
      // Reset the memoizedState to what it was before we attempted
      // to render it.
      var currentSource = sourceFiber.alternate;

      if (currentSource) {
        sourceFiber.updateQueue = currentSource.updateQueue;
        sourceFiber.memoizedState = currentSource.memoizedState;
        sourceFiber.lanes = currentSource.lanes;
      } else {
        sourceFiber.updateQueue = null;
        sourceFiber.memoizedState = null;
      }
    }

    var hasInvisibleParentBoundary = hasSuspenseContext(suspenseStackCursor.current, InvisibleParentSuspenseContext); // Schedule the nearest Suspense to re-render the timed out view.

    var _workInProgress = returnFiber;

    do {
      if (_workInProgress.tag === SuspenseComponent && shouldCaptureSuspense(_workInProgress, hasInvisibleParentBoundary)) {
        // Found the nearest boundary.
        // Stash the promise on the boundary fiber. If the boundary times out, we'll
        // attach another listener to flip the boundary back to its normal state.
        var wakeables = _workInProgress.updateQueue;

        if (wakeables === null) {
          var updateQueue = new Set();
          updateQueue.add(wakeable);
          _workInProgress.updateQueue = updateQueue;
        } else {
          wakeables.add(wakeable);
        } // If the boundary is outside of blocking mode, we should *not*
        // suspend the commit. Pretend as if the suspended component rendered
        // null and keep rendering. In the commit phase, we'll schedule a
        // subsequent synchronous update to re-render the Suspense.
        //
        // Note: It doesn't matter whether the component that suspended was
        // inside a blocking mode tree. If the Suspense is outside of it, we
        // should *not* suspend the commit.


        if ((_workInProgress.mode & BlockingMode) === NoMode) {
          _workInProgress.flags |= DidCapture;
          sourceFiber.flags |= ForceUpdateForLegacySuspense; // We're going to commit this fiber even though it didn't complete.
          // But we shouldn't call any lifecycle methods or callbacks. Remove
          // all lifecycle effect tags.

          sourceFiber.flags &= ~(LifecycleEffectMask | Incomplete);

          if (sourceFiber.tag === ClassComponent) {
            var currentSourceFiber = sourceFiber.alternate;

            if (currentSourceFiber === null) {
              // This is a new mount. Change the tag so it's not mistaken for a
              // completed class component. For example, we should not call
              // componentWillUnmount if it is deleted.
              sourceFiber.tag = IncompleteClassComponent;
            } else {
              // When we try rendering again, we should not reuse the current fiber,
              // since it's known to be in an inconsistent state. Use a force update to
              // prevent a bail out.
              var update = createUpdate(NoTimestamp, SyncLane);
              update.tag = ForceUpdate;
              enqueueUpdate(sourceFiber, update);
            }
          } // The source fiber did not complete. Mark it with Sync priority to
          // indicate that it still has pending work.


          sourceFiber.lanes = mergeLanes(sourceFiber.lanes, SyncLane); // Exit without suspending.

          return;
        } // Confirmed that the boundary is in a concurrent mode tree. Continue
        // with the normal suspend path.
        //
        // After this we'll use a set of heuristics to determine whether this
        // render pass will run to completion or restart or "suspend" the commit.
        // The actual logic for this is spread out in different places.
        //
        // This first principle is that if we're going to suspend when we complete
        // a root, then we should also restart if we get an update or ping that
        // might unsuspend it, and vice versa. The only reason to suspend is
        // because you think you might want to restart before committing. However,
        // it doesn't make sense to restart only while in the period we're suspended.
        //
        // Restarting too aggressively is also not good because it starves out any
        // intermediate loading state. So we use heuristics to determine when.
        // Suspense Heuristics
        //
        // If nothing threw a Promise or all the same fallbacks are already showing,
        // then don't suspend/restart.
        //
        // If this is an initial render of a new tree of Suspense boundaries and
        // those trigger a fallback, then don't suspend/restart. We want to ensure
        // that we can show the initial loading state as quickly as possible.
        //
        // If we hit a "Delayed" case, such as when we'd switch from content back into
        // a fallback, then we should always suspend/restart. Transitions apply
        // to this case. If none is defined, JND is used instead.
        //
        // If we're already showing a fallback and it gets "retried", allowing us to show
        // another level, but there's still an inner boundary that would show a fallback,
        // then we suspend/restart for 500ms since the last time we showed a fallback
        // anywhere in the tree. This effectively throttles progressive loading into a
        // consistent train of commits. This also gives us an opportunity to restart to
        // get to the completed state slightly earlier.
        //
        // If there's ambiguity due to batching it's resolved in preference of:
        // 1) "delayed", 2) "initial render", 3) "retry".
        //
        // We want to ensure that a "busy" state doesn't get force committed. We want to
        // ensure that new initial loading states can commit as soon as possible.


        attachPingListener(root, wakeable, rootRenderLanes);
        _workInProgress.flags |= ShouldCapture;
        _workInProgress.lanes = rootRenderLanes;
        return;
      } // This boundary already captured during this render. Continue to the next
      // boundary.


      _workInProgress = _workInProgress.return;
    } while (_workInProgress !== null); // No boundary was found. Fallthrough to error mode.
    // TODO: Use invariant so the message is stripped in prod?


    value = new Error((getComponentName(sourceFiber.type) || 'A React component') + ' suspended while rendering, but no fallback UI was specified.\n' + '\n' + 'Add a <Suspense fallback=...> component higher in the tree to ' + 'provide a loading indicator or placeholder to display.');
  } // We didn't find a boundary that could handle this type of exception. Start
  // over and traverse parent path again, this time treating the exception
  // as an error.


  renderDidError();
  value = createCapturedValue(value, sourceFiber);
  var workInProgress = returnFiber;

  do {
    switch (workInProgress.tag) {
      case HostRoot:
        {
          var _errorInfo = value;
          workInProgress.flags |= ShouldCapture;
          var lane = pickArbitraryLane(rootRenderLanes);
          workInProgress.lanes = mergeLanes(workInProgress.lanes, lane);

          var _update = createRootErrorUpdate(workInProgress, _errorInfo, lane);

          enqueueCapturedUpdate(workInProgress, _update);
          return;
        }

      case ClassComponent:
        // Capture and retry
        var errorInfo = value;
        var ctor = workInProgress.type;
        var instance = workInProgress.stateNode;

        if ((workInProgress.flags & DidCapture) === NoFlags && (typeof ctor.getDerivedStateFromError === 'function' || instance !== null && typeof instance.componentDidCatch === 'function' && !isAlreadyFailedLegacyErrorBoundary(instance))) {
          workInProgress.flags |= ShouldCapture;

          var _lane = pickArbitraryLane(rootRenderLanes);

          workInProgress.lanes = mergeLanes(workInProgress.lanes, _lane); // Schedule the error boundary to re-render using updated state

          var _update2 = createClassErrorUpdate(workInProgress, errorInfo, _lane);

          enqueueCapturedUpdate(workInProgress, _update2);
          return;
        }

        break;
    }

    workInProgress = workInProgress.return;
  } while (workInProgress !== null);
}

var didWarnAboutUndefinedSnapshotBeforeUpdate = null;

{
  didWarnAboutUndefinedSnapshotBeforeUpdate = new Set();
}

var PossiblyWeakSet = typeof WeakSet === 'function' ? WeakSet : Set;

var callComponentWillUnmountWithTimer = function (current, instance) {
  instance.props = current.memoizedProps;
  instance.state = current.memoizedState;

  {
    instance.componentWillUnmount();
  }
}; // Capture errors so they don't interrupt unmounting.


function safelyCallComponentWillUnmount(current, instance) {
  {
    invokeGuardedCallback(null, callComponentWillUnmountWithTimer, null, current, instance);

    if (hasCaughtError()) {
      var unmountError = clearCaughtError();
      captureCommitPhaseError(current, unmountError);
    }
  }
}

function safelyDetachRef(current) {
  var ref = current.ref;

  if (ref !== null) {
    if (typeof ref === 'function') {
      {
        invokeGuardedCallback(null, ref, null, null);

        if (hasCaughtError()) {
          var refError = clearCaughtError();
          captureCommitPhaseError(current, refError);
        }
      }
    } else {
      ref.current = null;
    }
  }
}

function safelyCallDestroy(current, destroy) {
  {
    invokeGuardedCallback(null, destroy, null);

    if (hasCaughtError()) {
      var error = clearCaughtError();
      captureCommitPhaseError(current, error);
    }
  }
}

function commitBeforeMutationLifeCycles(current, finishedWork) {
  switch (finishedWork.tag) {
    case FunctionComponent:
    case ForwardRef:
    case SimpleMemoComponent:
    case Block:
      {
        return;
      }

    case ClassComponent:
      {
        if (finishedWork.flags & Snapshot) {
          if (current !== null) {
            var prevProps = current.memoizedProps;
            var prevState = current.memoizedState;
            var instance = finishedWork.stateNode; // We could update instance props and state here,
            // but instead we rely on them being set during last render.
            // TODO: revisit this when we implement resuming.

            {
              if (finishedWork.type === finishedWork.elementType && !didWarnAboutReassigningProps) {
                if (instance.props !== finishedWork.memoizedProps) {
                  error('Expected %s props to match memoized props before ' + 'getSnapshotBeforeUpdate. ' + 'This might either be because of a bug in React, or because ' + 'a component reassigns its own `this.props`. ' + 'Please file an issue.', getComponentName(finishedWork.type) || 'instance');
                }

                if (instance.state !== finishedWork.memoizedState) {
                  error('Expected %s state to match memoized state before ' + 'getSnapshotBeforeUpdate. ' + 'This might either be because of a bug in React, or because ' + 'a component reassigns its own `this.state`. ' + 'Please file an issue.', getComponentName(finishedWork.type) || 'instance');
                }
              }
            }

            var snapshot = instance.getSnapshotBeforeUpdate(finishedWork.elementType === finishedWork.type ? prevProps : resolveDefaultProps(finishedWork.type, prevProps), prevState);

            {
              var didWarnSet = didWarnAboutUndefinedSnapshotBeforeUpdate;

              if (snapshot === undefined && !didWarnSet.has(finishedWork.type)) {
                didWarnSet.add(finishedWork.type);

                error('%s.getSnapshotBeforeUpdate(): A snapshot value (or null) ' + 'must be returned. You have returned undefined.', getComponentName(finishedWork.type));
              }
            }

            instance.__reactInternalSnapshotBeforeUpdate = snapshot;
          }
        }

        return;
      }

    case HostRoot:
      {
        {
          if (finishedWork.flags & Snapshot) {
            var root = finishedWork.stateNode;
            clearContainer(root.containerInfo);
          }
        }

        return;
      }

    case HostComponent:
    case HostText:
    case HostPortal:
    case IncompleteClassComponent:
      // Nothing to do for these component types
      return;
  }

  {
    {
      throw Error( "This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue." );
    }
  }
}

function commitHookEffectListUnmount(tag, finishedWork) {
  var updateQueue = finishedWork.updateQueue;
  var lastEffect = updateQueue !== null ? updateQueue.lastEffect : null;

  if (lastEffect !== null) {
    var firstEffect = lastEffect.next;
    var effect = firstEffect;

    do {
      if ((effect.tag & tag) === tag) {
        // Unmount
        var destroy = effect.destroy;
        effect.destroy = undefined;

        if (destroy !== undefined) {
          destroy();
        }
      }

      effect = effect.next;
    } while (effect !== firstEffect);
  }
}

function commitHookEffectListMount(tag, finishedWork) {
  var updateQueue = finishedWork.updateQueue;
  var lastEffect = updateQueue !== null ? updateQueue.lastEffect : null;

  if (lastEffect !== null) {
    var firstEffect = lastEffect.next;
    var effect = firstEffect;

    do {
      if ((effect.tag & tag) === tag) {
        // Mount
        var create = effect.create;
        effect.destroy = create();

        {
          var destroy = effect.destroy;

          if (destroy !== undefined && typeof destroy !== 'function') {
            var addendum = void 0;

            if (destroy === null) {
              addendum = ' You returned null. If your effect does not require clean ' + 'up, return undefined (or nothing).';
            } else if (typeof destroy.then === 'function') {
              addendum = '\n\nIt looks like you wrote useEffect(async () => ...) or returned a Promise. ' + 'Instead, write the async function inside your effect ' + 'and call it immediately:\n\n' + 'useEffect(() => {\n' + '  async function fetchData() {\n' + '    // You can await here\n' + '    const response = await MyAPI.getData(someId);\n' + '    // ...\n' + '  }\n' + '  fetchData();\n' + "}, [someId]); // Or [] if effect doesn't need props or state\n\n" + 'Learn more about data fetching with Hooks: https://reactjs.org/link/hooks-data-fetching';
            } else {
              addendum = ' You returned: ' + destroy;
            }

            error('An effect function must not return anything besides a function, ' + 'which is used for clean-up.%s', addendum);
          }
        }
      }

      effect = effect.next;
    } while (effect !== firstEffect);
  }
}

function schedulePassiveEffects(finishedWork) {
  var updateQueue = finishedWork.updateQueue;
  var lastEffect = updateQueue !== null ? updateQueue.lastEffect : null;

  if (lastEffect !== null) {
    var firstEffect = lastEffect.next;
    var effect = firstEffect;

    do {
      var _effect = effect,
          next = _effect.next,
          tag = _effect.tag;

      if ((tag & Passive$1) !== NoFlags$1 && (tag & HasEffect) !== NoFlags$1) {
        enqueuePendingPassiveHookEffectUnmount(finishedWork, effect);
        enqueuePendingPassiveHookEffectMount(finishedWork, effect);
      }

      effect = next;
    } while (effect !== firstEffect);
  }
}

function commitLifeCycles(finishedRoot, current, finishedWork, committedLanes) {
  switch (finishedWork.tag) {
    case FunctionComponent:
    case ForwardRef:
    case SimpleMemoComponent:
    case Block:
      {
        // At this point layout effects have already been destroyed (during mutation phase).
        // This is done to prevent sibling component effects from interfering with each other,
        // e.g. a destroy function in one component should never override a ref set
        // by a create function in another component during the same commit.
        {
          commitHookEffectListMount(Layout | HasEffect, finishedWork);
        }

        schedulePassiveEffects(finishedWork);
        return;
      }

    case ClassComponent:
      {
        var instance = finishedWork.stateNode;

        if (finishedWork.flags & Update) {
          if (current === null) {
            // We could update instance props and state here,
            // but instead we rely on them being set during last render.
            // TODO: revisit this when we implement resuming.
            {
              if (finishedWork.type === finishedWork.elementType && !didWarnAboutReassigningProps) {
                if (instance.props !== finishedWork.memoizedProps) {
                  error('Expected %s props to match memoized props before ' + 'componentDidMount. ' + 'This might either be because of a bug in React, or because ' + 'a component reassigns its own `this.props`. ' + 'Please file an issue.', getComponentName(finishedWork.type) || 'instance');
                }

                if (instance.state !== finishedWork.memoizedState) {
                  error('Expected %s state to match memoized state before ' + 'componentDidMount. ' + 'This might either be because of a bug in React, or because ' + 'a component reassigns its own `this.state`. ' + 'Please file an issue.', getComponentName(finishedWork.type) || 'instance');
                }
              }
            }

            {
              instance.componentDidMount();
            }
          } else {
            var prevProps = finishedWork.elementType === finishedWork.type ? current.memoizedProps : resolveDefaultProps(finishedWork.type, current.memoizedProps);
            var prevState = current.memoizedState; // We could update instance props and state here,
            // but instead we rely on them being set during last render.
            // TODO: revisit this when we implement resuming.

            {
              if (finishedWork.type === finishedWork.elementType && !didWarnAboutReassigningProps) {
                if (instance.props !== finishedWork.memoizedProps) {
                  error('Expected %s props to match memoized props before ' + 'componentDidUpdate. ' + 'This might either be because of a bug in React, or because ' + 'a component reassigns its own `this.props`. ' + 'Please file an issue.', getComponentName(finishedWork.type) || 'instance');
                }

                if (instance.state !== finishedWork.memoizedState) {
                  error('Expected %s state to match memoized state before ' + 'componentDidUpdate. ' + 'This might either be because of a bug in React, or because ' + 'a component reassigns its own `this.state`. ' + 'Please file an issue.', getComponentName(finishedWork.type) || 'instance');
                }
              }
            }

            {
              instance.componentDidUpdate(prevProps, prevState, instance.__reactInternalSnapshotBeforeUpdate);
            }
          }
        } // TODO: I think this is now always non-null by the time it reaches the
        // commit phase. Consider removing the type check.


        var updateQueue = finishedWork.updateQueue;

        if (updateQueue !== null) {
          {
            if (finishedWork.type === finishedWork.elementType && !didWarnAboutReassigningProps) {
              if (instance.props !== finishedWork.memoizedProps) {
                error('Expected %s props to match memoized props before ' + 'processing the update queue. ' + 'This might either be because of a bug in React, or because ' + 'a component reassigns its own `this.props`. ' + 'Please file an issue.', getComponentName(finishedWork.type) || 'instance');
              }

              if (instance.state !== finishedWork.memoizedState) {
                error('Expected %s state to match memoized state before ' + 'processing the update queue. ' + 'This might either be because of a bug in React, or because ' + 'a component reassigns its own `this.state`. ' + 'Please file an issue.', getComponentName(finishedWork.type) || 'instance');
              }
            }
          } // We could update instance props and state here,
          // but instead we rely on them being set during last render.
          // TODO: revisit this when we implement resuming.


          commitUpdateQueue(finishedWork, updateQueue, instance);
        }

        return;
      }

    case HostRoot:
      {
        // TODO: I think this is now always non-null by the time it reaches the
        // commit phase. Consider removing the type check.
        var _updateQueue = finishedWork.updateQueue;

        if (_updateQueue !== null) {
          var _instance = null;

          if (finishedWork.child !== null) {
            switch (finishedWork.child.tag) {
              case HostComponent:
                _instance = getPublicInstance(finishedWork.child.stateNode);
                break;

              case ClassComponent:
                _instance = finishedWork.child.stateNode;
                break;
            }
          }

          commitUpdateQueue(finishedWork, _updateQueue, _instance);
        }

        return;
      }

    case HostComponent:
      {
        var _instance2 = finishedWork.stateNode; // Renderers may schedule work to be done after host components are mounted
        // (eg DOM renderer may schedule auto-focus for inputs and form controls).
        // These effects should only be committed when components are first mounted,
        // aka when there is no current/alternate.

        if (current === null && finishedWork.flags & Update) {
          var type = finishedWork.type;
          var props = finishedWork.memoizedProps;
          commitMount(_instance2, type, props);
        }

        return;
      }

    case HostText:
      {
        // We have no life-cycles associated with text.
        return;
      }

    case HostPortal:
      {
        // We have no life-cycles associated with portals.
        return;
      }

    case Profiler:
      {
        {
          var _finishedWork$memoize2 = finishedWork.memoizedProps,
              onCommit = _finishedWork$memoize2.onCommit,
              onRender = _finishedWork$memoize2.onRender;
          var effectDuration = finishedWork.stateNode.effectDuration;
          var commitTime = getCommitTime();

          if (typeof onRender === 'function') {
            {
              onRender(finishedWork.memoizedProps.id, current === null ? 'mount' : 'update', finishedWork.actualDuration, finishedWork.treeBaseDuration, finishedWork.actualStartTime, commitTime, finishedRoot.memoizedInteractions);
            }
          }
        }

        return;
      }

    case SuspenseComponent:
      {
        commitSuspenseHydrationCallbacks(finishedRoot, finishedWork);
        return;
      }

    case SuspenseListComponent:
    case IncompleteClassComponent:
    case FundamentalComponent:
    case ScopeComponent:
    case OffscreenComponent:
    case LegacyHiddenComponent:
      return;
  }

  {
    {
      throw Error( "This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue." );
    }
  }
}

function hideOrUnhideAllChildren(finishedWork, isHidden) {
  {
    // We only have the top Fiber that was inserted but we need to recurse down its
    // children to find all the terminal nodes.
    var node = finishedWork;

    while (true) {
      if (node.tag === HostComponent) {
        var instance = node.stateNode;

        if (isHidden) {
          hideInstance(instance);
        } else {
          unhideInstance(node.stateNode, node.memoizedProps);
        }
      } else if (node.tag === HostText) {
        var _instance3 = node.stateNode;

        if (isHidden) {
          hideTextInstance(_instance3);
        } else {
          unhideTextInstance(_instance3, node.memoizedProps);
        }
      } else if ((node.tag === OffscreenComponent || node.tag === LegacyHiddenComponent) && node.memoizedState !== null && node !== finishedWork) ; else if (node.child !== null) {
        node.child.return = node;
        node = node.child;
        continue;
      }

      if (node === finishedWork) {
        return;
      }

      while (node.sibling === null) {
        if (node.return === null || node.return === finishedWork) {
          return;
        }

        node = node.return;
      }

      node.sibling.return = node.return;
      node = node.sibling;
    }
  }
}

function commitAttachRef(finishedWork) {
  var ref = finishedWork.ref;

  if (ref !== null) {
    var instance = finishedWork.stateNode;
    var instanceToUse;

    switch (finishedWork.tag) {
      case HostComponent:
        instanceToUse = getPublicInstance(instance);
        break;

      default:
        instanceToUse = instance;
    } // Moved outside to ensure DCE works with this flag

    if (typeof ref === 'function') {
      ref(instanceToUse);
    } else {
      {
        if (!ref.hasOwnProperty('current')) {
          error('Unexpected ref object provided for %s. ' + 'Use either a ref-setter function or React.createRef().', getComponentName(finishedWork.type));
        }
      }

      ref.current = instanceToUse;
    }
  }
}

function commitDetachRef(current) {
  var currentRef = current.ref;

  if (currentRef !== null) {
    if (typeof currentRef === 'function') {
      currentRef(null);
    } else {
      currentRef.current = null;
    }
  }
} // User-originating errors (lifecycles and refs) should not interrupt
// deletion, so don't let them throw. Host-originating errors should
// interrupt deletion, so it's okay


function commitUnmount(finishedRoot, current, renderPriorityLevel) {
  onCommitUnmount(current);

  switch (current.tag) {
    case FunctionComponent:
    case ForwardRef:
    case MemoComponent:
    case SimpleMemoComponent:
    case Block:
      {
        var updateQueue = current.updateQueue;

        if (updateQueue !== null) {
          var lastEffect = updateQueue.lastEffect;

          if (lastEffect !== null) {
            var firstEffect = lastEffect.next;
            var effect = firstEffect;

            do {
              var _effect2 = effect,
                  destroy = _effect2.destroy,
                  tag = _effect2.tag;

              if (destroy !== undefined) {
                if ((tag & Passive$1) !== NoFlags$1) {
                  enqueuePendingPassiveHookEffectUnmount(current, effect);
                } else {
                  {
                    safelyCallDestroy(current, destroy);
                  }
                }
              }

              effect = effect.next;
            } while (effect !== firstEffect);
          }
        }

        return;
      }

    case ClassComponent:
      {
        safelyDetachRef(current);
        var instance = current.stateNode;

        if (typeof instance.componentWillUnmount === 'function') {
          safelyCallComponentWillUnmount(current, instance);
        }

        return;
      }

    case HostComponent:
      {
        safelyDetachRef(current);
        return;
      }

    case HostPortal:
      {
        // TODO: this is recursive.
        // We are also not using this parent because
        // the portal will get pushed immediately.
        {
          unmountHostComponents(finishedRoot, current);
        }

        return;
      }

    case FundamentalComponent:
      {

        return;
      }

    case DehydratedFragment:
      {

        return;
      }

    case ScopeComponent:
      {

        return;
      }
  }
}

function commitNestedUnmounts(finishedRoot, root, renderPriorityLevel) {
  // While we're inside a removed host node we don't want to call
  // removeChild on the inner nodes because they're removed by the top
  // call anyway. We also want to call componentWillUnmount on all
  // composites before this host node is removed from the tree. Therefore
  // we do an inner loop while we're still inside the host node.
  var node = root;

  while (true) {
    commitUnmount(finishedRoot, node); // Visit children because they may contain more composite or host nodes.
    // Skip portals because commitUnmount() currently visits them recursively.

    if (node.child !== null && ( // If we use mutation we drill down into portals using commitUnmount above.
    // If we don't use mutation we drill down into portals here instead.
     node.tag !== HostPortal)) {
      node.child.return = node;
      node = node.child;
      continue;
    }

    if (node === root) {
      return;
    }

    while (node.sibling === null) {
      if (node.return === null || node.return === root) {
        return;
      }

      node = node.return;
    }

    node.sibling.return = node.return;
    node = node.sibling;
  }
}

function detachFiberMutation(fiber) {
  // Cut off the return pointers to disconnect it from the tree. Ideally, we
  // should clear the child pointer of the parent alternate to let this
  // get GC:ed but we don't know which for sure which parent is the current
  // one so we'll settle for GC:ing the subtree of this child. This child
  // itself will be GC:ed when the parent updates the next time.
  // Note: we cannot null out sibling here, otherwise it can cause issues
  // with findDOMNode and how it requires the sibling field to carry out
  // traversal in a later effect. See PR #16820. We now clear the sibling
  // field after effects, see: detachFiberAfterEffects.
  //
  // Don't disconnect stateNode now; it will be detached in detachFiberAfterEffects.
  // It may be required if the current component is an error boundary,
  // and one of its descendants throws while unmounting a passive effect.
  fiber.alternate = null;
  fiber.child = null;
  fiber.dependencies = null;
  fiber.firstEffect = null;
  fiber.lastEffect = null;
  fiber.memoizedProps = null;
  fiber.memoizedState = null;
  fiber.pendingProps = null;
  fiber.return = null;
  fiber.updateQueue = null;

  {
    fiber._debugOwner = null;
  }
}

function getHostParentFiber(fiber) {
  var parent = fiber.return;

  while (parent !== null) {
    if (isHostParent(parent)) {
      return parent;
    }

    parent = parent.return;
  }

  {
    {
      throw Error( "Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue." );
    }
  }
}

function isHostParent(fiber) {
  return fiber.tag === HostComponent || fiber.tag === HostRoot || fiber.tag === HostPortal;
}

function getHostSibling(fiber) {
  // We're going to search forward into the tree until we find a sibling host
  // node. Unfortunately, if multiple insertions are done in a row we have to
  // search past them. This leads to exponential search for the next sibling.
  // TODO: Find a more efficient way to do this.
  var node = fiber;

  siblings: while (true) {
    // If we didn't find anything, let's try the next sibling.
    while (node.sibling === null) {
      if (node.return === null || isHostParent(node.return)) {
        // If we pop out of the root or hit the parent the fiber we are the
        // last sibling.
        return null;
      }

      node = node.return;
    }

    node.sibling.return = node.return;
    node = node.sibling;

    while (node.tag !== HostComponent && node.tag !== HostText && node.tag !== DehydratedFragment) {
      // If it is not host node and, we might have a host node inside it.
      // Try to search down until we find one.
      if (node.flags & Placement) {
        // If we don't have a child, try the siblings instead.
        continue siblings;
      } // If we don't have a child, try the siblings instead.
      // We also skip portals because they are not part of this host tree.


      if (node.child === null || node.tag === HostPortal) {
        continue siblings;
      } else {
        node.child.return = node;
        node = node.child;
      }
    } // Check if this host node is stable or about to be placed.


    if (!(node.flags & Placement)) {
      // Found it!
      return node.stateNode;
    }
  }
}

function commitPlacement(finishedWork) {


  var parentFiber = getHostParentFiber(finishedWork); // Note: these two variables *must* always be updated together.

  var parent;
  var isContainer;
  var parentStateNode = parentFiber.stateNode;

  switch (parentFiber.tag) {
    case HostComponent:
      parent = parentStateNode;
      isContainer = false;
      break;

    case HostRoot:
      parent = parentStateNode.containerInfo;
      isContainer = true;
      break;

    case HostPortal:
      parent = parentStateNode.containerInfo;
      isContainer = true;
      break;

    case FundamentalComponent:

    // eslint-disable-next-line-no-fallthrough

    default:
      {
        {
          throw Error( "Invalid host parent fiber. This error is likely caused by a bug in React. Please file an issue." );
        }
      }

  }

  if (parentFiber.flags & ContentReset) {
    // Reset the text content of the parent before doing any insertions
    resetTextContent(parent); // Clear ContentReset from the effect tag

    parentFiber.flags &= ~ContentReset;
  }

  var before = getHostSibling(finishedWork); // We only have the top Fiber that was inserted but we need to recurse down its
  // children to find all the terminal nodes.

  if (isContainer) {
    insertOrAppendPlacementNodeIntoContainer(finishedWork, before, parent);
  } else {
    insertOrAppendPlacementNode(finishedWork, before, parent);
  }
}

function insertOrAppendPlacementNodeIntoContainer(node, before, parent) {
  var tag = node.tag;
  var isHost = tag === HostComponent || tag === HostText;

  if (isHost || enableFundamentalAPI ) {
    var stateNode = isHost ? node.stateNode : node.stateNode.instance;

    if (before) {
      insertInContainerBefore(parent, stateNode, before);
    } else {
      appendChildToContainer(parent, stateNode);
    }
  } else if (tag === HostPortal) ; else {
    var child = node.child;

    if (child !== null) {
      insertOrAppendPlacementNodeIntoContainer(child, before, parent);
      var sibling = child.sibling;

      while (sibling !== null) {
        insertOrAppendPlacementNodeIntoContainer(sibling, before, parent);
        sibling = sibling.sibling;
      }
    }
  }
}

function insertOrAppendPlacementNode(node, before, parent) {
  var tag = node.tag;
  var isHost = tag === HostComponent || tag === HostText;

  if (isHost || enableFundamentalAPI ) {
    var stateNode = isHost ? node.stateNode : node.stateNode.instance;

    if (before) {
      insertBefore(parent, stateNode, before);
    } else {
      appendChild(parent, stateNode);
    }
  } else if (tag === HostPortal) ; else {
    var child = node.child;

    if (child !== null) {
      insertOrAppendPlacementNode(child, before, parent);
      var sibling = child.sibling;

      while (sibling !== null) {
        insertOrAppendPlacementNode(sibling, before, parent);
        sibling = sibling.sibling;
      }
    }
  }
}

function unmountHostComponents(finishedRoot, current, renderPriorityLevel) {
  // We only have the top Fiber that was deleted but we need to recurse down its
  // children to find all the terminal nodes.
  var node = current; // Each iteration, currentParent is populated with node's host parent if not
  // currentParentIsValid.

  var currentParentIsValid = false; // Note: these two variables *must* always be updated together.

  var currentParent;
  var currentParentIsContainer;

  while (true) {
    if (!currentParentIsValid) {
      var parent = node.return;

      findParent: while (true) {
        if (!(parent !== null)) {
          {
            throw Error( "Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue." );
          }
        }

        var parentStateNode = parent.stateNode;

        switch (parent.tag) {
          case HostComponent:
            currentParent = parentStateNode;
            currentParentIsContainer = false;
            break findParent;

          case HostRoot:
            currentParent = parentStateNode.containerInfo;
            currentParentIsContainer = true;
            break findParent;

          case HostPortal:
            currentParent = parentStateNode.containerInfo;
            currentParentIsContainer = true;
            break findParent;

        }

        parent = parent.return;
      }

      currentParentIsValid = true;
    }

    if (node.tag === HostComponent || node.tag === HostText) {
      commitNestedUnmounts(finishedRoot, node); // After all the children have unmounted, it is now safe to remove the
      // node from the tree.

      if (currentParentIsContainer) {
        removeChildFromContainer(currentParent, node.stateNode);
      } else {
        removeChild(currentParent, node.stateNode);
      } // Don't visit children because we already visited them.

    } else if (node.tag === HostPortal) {
      if (node.child !== null) {
        // When we go into a portal, it becomes the parent to remove from.
        // We will reassign it back when we pop the portal on the way up.
        currentParent = node.stateNode.containerInfo;
        currentParentIsContainer = true; // Visit children because portals might contain host components.

        node.child.return = node;
        node = node.child;
        continue;
      }
    } else {
      commitUnmount(finishedRoot, node); // Visit children because we may find more host components below.

      if (node.child !== null) {
        node.child.return = node;
        node = node.child;
        continue;
      }
    }

    if (node === current) {
      return;
    }

    while (node.sibling === null) {
      if (node.return === null || node.return === current) {
        return;
      }

      node = node.return;

      if (node.tag === HostPortal) {
        // When we go out of the portal, we need to restore the parent.
        // Since we don't keep a stack of them, we will search for it.
        currentParentIsValid = false;
      }
    }

    node.sibling.return = node.return;
    node = node.sibling;
  }
}

function commitDeletion(finishedRoot, current, renderPriorityLevel) {
  {
    // Recursively delete all host nodes from the parent.
    // Detach refs and call componentWillUnmount() on the whole subtree.
    unmountHostComponents(finishedRoot, current);
  }

  var alternate = current.alternate;
  detachFiberMutation(current);

  if (alternate !== null) {
    detachFiberMutation(alternate);
  }
}

function commitWork(current, finishedWork) {

  switch (finishedWork.tag) {
    case FunctionComponent:
    case ForwardRef:
    case MemoComponent:
    case SimpleMemoComponent:
    case Block:
      {
        // Layout effects are destroyed during the mutation phase so that all
        // destroy functions for all fibers are called before any create functions.
        // This prevents sibling component effects from interfering with each other,
        // e.g. a destroy function in one component should never override a ref set
        // by a create function in another component during the same commit.
        {
          commitHookEffectListUnmount(Layout | HasEffect, finishedWork);
        }

        return;
      }

    case ClassComponent:
      {
        return;
      }

    case HostComponent:
      {
        var instance = finishedWork.stateNode;

        if (instance != null) {
          // Commit the work prepared earlier.
          var newProps = finishedWork.memoizedProps; // For hydration we reuse the update path but we treat the oldProps
          // as the newProps. The updatePayload will contain the real change in
          // this case.

          var oldProps = current !== null ? current.memoizedProps : newProps;
          var type = finishedWork.type; // TODO: Type the updateQueue to be specific to host components.

          var updatePayload = finishedWork.updateQueue;
          finishedWork.updateQueue = null;

          if (updatePayload !== null) {
            commitUpdate(instance, updatePayload, type, oldProps, newProps);
          }
        }

        return;
      }

    case HostText:
      {
        if (!(finishedWork.stateNode !== null)) {
          {
            throw Error( "This should have a text node initialized. This error is likely caused by a bug in React. Please file an issue." );
          }
        }

        var textInstance = finishedWork.stateNode;
        var newText = finishedWork.memoizedProps; // For hydration we reuse the update path but we treat the oldProps
        // as the newProps. The updatePayload will contain the real change in
        // this case.

        var oldText = current !== null ? current.memoizedProps : newText;
        commitTextUpdate(textInstance, oldText, newText);
        return;
      }

    case HostRoot:
      {
        {
          var _root = finishedWork.stateNode;

          if (_root.hydrate) {
            // We've just hydrated. No need to hydrate again.
            _root.hydrate = false;
            commitHydratedContainer(_root.containerInfo);
          }
        }

        return;
      }

    case Profiler:
      {
        return;
      }

    case SuspenseComponent:
      {
        commitSuspenseComponent(finishedWork);
        attachSuspenseRetryListeners(finishedWork);
        return;
      }

    case SuspenseListComponent:
      {
        attachSuspenseRetryListeners(finishedWork);
        return;
      }

    case IncompleteClassComponent:
      {
        return;
      }

    case FundamentalComponent:
      {

        break;
      }

    case ScopeComponent:
      {

        break;
      }

    case OffscreenComponent:
    case LegacyHiddenComponent:
      {
        var newState = finishedWork.memoizedState;
        var isHidden = newState !== null;
        hideOrUnhideAllChildren(finishedWork, isHidden);
        return;
      }
  }

  {
    {
      throw Error( "This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue." );
    }
  }
}

function commitSuspenseComponent(finishedWork) {
  var newState = finishedWork.memoizedState;

  if (newState !== null) {
    markCommitTimeOfFallback();

    {
      // Hide the Offscreen component that contains the primary children. TODO:
      // Ideally, this effect would have been scheduled on the Offscreen fiber
      // itself. That's how unhiding works: the Offscreen component schedules an
      // effect on itself. However, in this case, the component didn't complete,
      // so the fiber was never added to the effect list in the normal path. We
      // could have appended it to the effect list in the Suspense component's
      // second pass, but doing it this way is less complicated. This would be
      // simpler if we got rid of the effect list and traversed the tree, like
      // we're planning to do.
      var primaryChildParent = finishedWork.child;
      hideOrUnhideAllChildren(primaryChildParent, true);
    }
  }
}

function commitSuspenseHydrationCallbacks(finishedRoot, finishedWork) {

  var newState = finishedWork.memoizedState;

  if (newState === null) {
    var current = finishedWork.alternate;

    if (current !== null) {
      var prevState = current.memoizedState;

      if (prevState !== null) {
        var suspenseInstance = prevState.dehydrated;

        if (suspenseInstance !== null) {
          commitHydratedSuspenseInstance(suspenseInstance);
        }
      }
    }
  }
}

function attachSuspenseRetryListeners(finishedWork) {
  // If this boundary just timed out, then it will have a set of wakeables.
  // For each wakeable, attach a listener so that when it resolves, React
  // attempts to re-render the boundary in the primary (pre-timeout) state.
  var wakeables = finishedWork.updateQueue;

  if (wakeables !== null) {
    finishedWork.updateQueue = null;
    var retryCache = finishedWork.stateNode;

    if (retryCache === null) {
      retryCache = finishedWork.stateNode = new PossiblyWeakSet();
    }

    wakeables.forEach(function (wakeable) {
      // Memoize using the boundary fiber to prevent redundant listeners.
      var retry = resolveRetryWakeable.bind(null, finishedWork, wakeable);

      if (!retryCache.has(wakeable)) {
        {
          if (wakeable.__reactDoNotTraceInteractions !== true) {
            retry = tracing.unstable_wrap(retry);
          }
        }

        retryCache.add(wakeable);
        wakeable.then(retry, retry);
      }
    });
  }
} // This function detects when a Suspense boundary goes from visible to hidden.
// It returns false if the boundary is already hidden.
// TODO: Use an effect tag.


function isSuspenseBoundaryBeingHidden(current, finishedWork) {
  if (current !== null) {
    var oldState = current.memoizedState;

    if (oldState === null || oldState.dehydrated !== null) {
      var newState = finishedWork.memoizedState;
      return newState !== null && newState.dehydrated === null;
    }
  }

  return false;
}

function commitResetTextContent(current) {

  resetTextContent(current.stateNode);
}

var COMPONENT_TYPE = 0;
var HAS_PSEUDO_CLASS_TYPE = 1;
var ROLE_TYPE = 2;
var TEST_NAME_TYPE = 3;
var TEXT_TYPE = 4;

if (typeof Symbol === 'function' && Symbol.for) {
  var symbolFor$1 = Symbol.for;
  COMPONENT_TYPE = symbolFor$1('selector.component');
  HAS_PSEUDO_CLASS_TYPE = symbolFor$1('selector.has_pseudo_class');
  ROLE_TYPE = symbolFor$1('selector.role');
  TEST_NAME_TYPE = symbolFor$1('selector.test_id');
  TEXT_TYPE = symbolFor$1('selector.text');
}
var commitHooks = [];
function onCommitRoot$1() {
  {
    commitHooks.forEach(function (commitHook) {
      return commitHook();
    });
  }
}

var ceil = Math.ceil;
var ReactCurrentDispatcher$2 = ReactSharedInternals.ReactCurrentDispatcher,
    ReactCurrentOwner$2 = ReactSharedInternals.ReactCurrentOwner,
    IsSomeRendererActing = ReactSharedInternals.IsSomeRendererActing;
var NoContext =
/*             */
0;
var BatchedContext =
/*               */
1;
var EventContext =
/*                 */
2;
var DiscreteEventContext =
/*         */
4;
var LegacyUnbatchedContext =
/*       */
8;
var RenderContext =
/*                */
16;
var CommitContext =
/*                */
32;
var RetryAfterError =
/*       */
64;
var RootIncomplete = 0;
var RootFatalErrored = 1;
var RootErrored = 2;
var RootSuspended = 3;
var RootSuspendedWithDelay = 4;
var RootCompleted = 5; // Describes where we are in the React execution stack

var executionContext = NoContext; // The root we're working on

var workInProgressRoot = null; // The fiber we're working on

var workInProgress = null; // The lanes we're rendering

var workInProgressRootRenderLanes = NoLanes; // Stack that allows components to change the render lanes for its subtree
// This is a superset of the lanes we started working on at the root. The only
// case where it's different from `workInProgressRootRenderLanes` is when we
// enter a subtree that is hidden and needs to be unhidden: Suspense and
// Offscreen component.
//
// Most things in the work loop should deal with workInProgressRootRenderLanes.
// Most things in begin/complete phases should deal with subtreeRenderLanes.

var subtreeRenderLanes = NoLanes;
var subtreeRenderLanesCursor = createCursor(NoLanes); // Whether to root completed, errored, suspended, etc.

var workInProgressRootExitStatus = RootIncomplete; // A fatal error, if one is thrown

var workInProgressRootFatalError = null; // "Included" lanes refer to lanes that were worked on during this render. It's
// slightly different than `renderLanes` because `renderLanes` can change as you
// enter and exit an Offscreen tree. This value is the combination of all render
// lanes for the entire render phase.

var workInProgressRootIncludedLanes = NoLanes; // The work left over by components that were visited during this render. Only
// includes unprocessed updates, not work in bailed out children.

var workInProgressRootSkippedLanes = NoLanes; // Lanes that were updated (in an interleaved event) during this render.

var workInProgressRootUpdatedLanes = NoLanes; // Lanes that were pinged (in an interleaved event) during this render.

var workInProgressRootPingedLanes = NoLanes;
var mostRecentlyUpdatedRoot = null; // The most recent time we committed a fallback. This lets us ensure a train
// model where we don't commit new loading states in too quick succession.

var globalMostRecentFallbackTime = 0;
var FALLBACK_THROTTLE_MS = 500; // The absolute time for when we should start giving up on rendering
// more and prefer CPU suspense heuristics instead.

var workInProgressRootRenderTargetTime = Infinity; // How long a render is supposed to take before we start following CPU
// suspense heuristics and opt out of rendering more content.

var RENDER_TIMEOUT_MS = 500;

function resetRenderTimer() {
  workInProgressRootRenderTargetTime = now() + RENDER_TIMEOUT_MS;
}

function getRenderTargetTime() {
  return workInProgressRootRenderTargetTime;
}
var nextEffect = null;
var hasUncaughtError = false;
var firstUncaughtError = null;
var legacyErrorBoundariesThatAlreadyFailed = null;
var rootDoesHavePassiveEffects = false;
var rootWithPendingPassiveEffects = null;
var pendingPassiveEffectsRenderPriority = NoPriority$1;
var pendingPassiveEffectsLanes = NoLanes;
var pendingPassiveHookEffectsMount = [];
var pendingPassiveHookEffectsUnmount = [];
var rootsWithPendingDiscreteUpdates = null; // Use these to prevent an infinite loop of nested updates

var NESTED_UPDATE_LIMIT = 50;
var nestedUpdateCount = 0;
var rootWithNestedUpdates = null;
var NESTED_PASSIVE_UPDATE_LIMIT = 50;
var nestedPassiveUpdateCount = 0; // Marks the need to reschedule pending interactions at these lanes
// during the commit phase. This enables them to be traced across components
// that spawn new work during render. E.g. hidden boundaries, suspended SSR
// hydration or SuspenseList.
// TODO: Can use a bitmask instead of an array

var spawnedWorkDuringRender = null; // If two updates are scheduled within the same event, we should treat their
// event times as simultaneous, even if the actual clock time has advanced
// between the first and second call.

var currentEventTime = NoTimestamp;
var currentEventWipLanes = NoLanes;
var currentEventPendingLanes = NoLanes; // Dev only flag that tracks if passive effects are currently being flushed.
// We warn about state updates for unmounted components differently in this case.

var isFlushingPassiveEffects = false;
var focusedInstanceHandle = null;
var shouldFireAfterActiveInstanceBlur = false;
function getWorkInProgressRoot() {
  return workInProgressRoot;
}
function requestEventTime() {
  if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {
    // We're inside React, so it's fine to read the actual time.
    return now();
  } // We're not inside React, so we may be in the middle of a browser event.


  if (currentEventTime !== NoTimestamp) {
    // Use the same start time for all updates until we enter React again.
    return currentEventTime;
  } // This is the first update since React yielded. Compute a new start time.


  currentEventTime = now();
  return currentEventTime;
}
function requestUpdateLane(fiber) {
  // Special cases
  var mode = fiber.mode;

  if ((mode & BlockingMode) === NoMode) {
    return SyncLane;
  } else if ((mode & ConcurrentMode) === NoMode) {
    return getCurrentPriorityLevel() === ImmediatePriority$1 ? SyncLane : SyncBatchedLane;
  } // The algorithm for assigning an update to a lane should be stable for all
  // updates at the same priority within the same event. To do this, the inputs
  // to the algorithm must be the same. For example, we use the `renderLanes`
  // to avoid choosing a lane that is already in the middle of rendering.
  //
  // However, the "included" lanes could be mutated in between updates in the
  // same event, like if you perform an update inside `flushSync`. Or any other
  // code path that might call `prepareFreshStack`.
  //
  // The trick we use is to cache the first of each of these inputs within an
  // event. Then reset the cached values once we can be sure the event is over.
  // Our heuristic for that is whenever we enter a concurrent work loop.
  //
  // We'll do the same for `currentEventPendingLanes` below.


  if (currentEventWipLanes === NoLanes) {
    currentEventWipLanes = workInProgressRootIncludedLanes;
  }

  var isTransition = requestCurrentTransition() !== NoTransition;

  if (isTransition) {
    if (currentEventPendingLanes !== NoLanes) {
      currentEventPendingLanes = mostRecentlyUpdatedRoot !== null ? mostRecentlyUpdatedRoot.pendingLanes : NoLanes;
    }

    return findTransitionLane(currentEventWipLanes, currentEventPendingLanes);
  } // TODO: Remove this dependency on the Scheduler priority.
  // To do that, we're replacing it with an update lane priority.


  var schedulerPriority = getCurrentPriorityLevel(); // The old behavior was using the priority level of the Scheduler.
  // This couples React to the Scheduler internals, so we're replacing it
  // with the currentUpdateLanePriority above. As an example of how this
  // could be problematic, if we're not inside `Scheduler.runWithPriority`,
  // then we'll get the priority of the current running Scheduler task,
  // which is probably not what we want.

  var lane;

  if ( // TODO: Temporary. We're removing the concept of discrete updates.
  (executionContext & DiscreteEventContext) !== NoContext && schedulerPriority === UserBlockingPriority$2) {
    lane = findUpdateLane(InputDiscreteLanePriority, currentEventWipLanes);
  } else {
    var schedulerLanePriority = schedulerPriorityToLanePriority(schedulerPriority);

    lane = findUpdateLane(schedulerLanePriority, currentEventWipLanes);
  }

  return lane;
}

function requestRetryLane(fiber) {
  // This is a fork of `requestUpdateLane` designed specifically for Suspense
  // "retries"  a special update that attempts to flip a Suspense boundary
  // from its placeholder state to its primary/resolved state.
  // Special cases
  var mode = fiber.mode;

  if ((mode & BlockingMode) === NoMode) {
    return SyncLane;
  } else if ((mode & ConcurrentMode) === NoMode) {
    return getCurrentPriorityLevel() === ImmediatePriority$1 ? SyncLane : SyncBatchedLane;
  } // See `requestUpdateLane` for explanation of `currentEventWipLanes`


  if (currentEventWipLanes === NoLanes) {
    currentEventWipLanes = workInProgressRootIncludedLanes;
  }

  return findRetryLane(currentEventWipLanes);
}

function scheduleUpdateOnFiber(fiber, lane, eventTime) {
  checkForNestedUpdates();
  warnAboutRenderPhaseUpdatesInDEV(fiber);
  var root = markUpdateLaneFromFiberToRoot(fiber, lane);

  if (root === null) {
    warnAboutUpdateOnUnmountedFiberInDEV(fiber);
    return null;
  } // Mark that the root has a pending update.


  markRootUpdated(root, lane, eventTime);

  if (root === workInProgressRoot) {
    // Received an update to a tree that's in the middle of rendering. Mark
    // that there was an interleaved update work on this root. Unless the
    // `deferRenderPhaseUpdateToNextBatch` flag is off and this is a render
    // phase update. In that case, we don't treat render phase updates as if
    // they were interleaved, for backwards compat reasons.
    {
      workInProgressRootUpdatedLanes = mergeLanes(workInProgressRootUpdatedLanes, lane);
    }

    if (workInProgressRootExitStatus === RootSuspendedWithDelay) {
      // The root already suspended with a delay, which means this render
      // definitely won't finish. Since we have a new update, let's mark it as
      // suspended now, right before marking the incoming update. This has the
      // effect of interrupting the current render and switching to the update.
      // TODO: Make sure this doesn't override pings that happen while we've
      // already started rendering.
      markRootSuspended$1(root, workInProgressRootRenderLanes);
    }
  } // TODO: requestUpdateLanePriority also reads the priority. Pass the
  // priority as an argument to that function and this one.


  var priorityLevel = getCurrentPriorityLevel();

  if (lane === SyncLane) {
    if ( // Check if we're inside unbatchedUpdates
    (executionContext & LegacyUnbatchedContext) !== NoContext && // Check if we're not already rendering
    (executionContext & (RenderContext | CommitContext)) === NoContext) {
      // Register pending interactions on the root to avoid losing traced interaction data.
      schedulePendingInteractions(root, lane); // This is a legacy edge case. The initial mount of a ReactDOM.render-ed
      // root inside of batchedUpdates should be synchronous, but layout updates
      // should be deferred until the end of the batch.

      performSyncWorkOnRoot(root);
    } else {
      ensureRootIsScheduled(root, eventTime);
      schedulePendingInteractions(root, lane);

      if (executionContext === NoContext) {
        // Flush the synchronous work now, unless we're already working or inside
        // a batch. This is intentionally inside scheduleUpdateOnFiber instead of
        // scheduleCallbackForFiber to preserve the ability to schedule a callback
        // without immediately flushing it. We only do this for user-initiated
        // updates, to preserve historical behavior of legacy mode.
        resetRenderTimer();
        flushSyncCallbackQueue();
      }
    }
  } else {
    // Schedule a discrete update but only if it's not Sync.
    if ((executionContext & DiscreteEventContext) !== NoContext && ( // Only updates at user-blocking priority or greater are considered
    // discrete, even inside a discrete event.
    priorityLevel === UserBlockingPriority$2 || priorityLevel === ImmediatePriority$1)) {
      // This is the result of a discrete event. Track the lowest priority
      // discrete update per root so we can flush them early, if needed.
      if (rootsWithPendingDiscreteUpdates === null) {
        rootsWithPendingDiscreteUpdates = new Set([root]);
      } else {
        rootsWithPendingDiscreteUpdates.add(root);
      }
    } // Schedule other updates after in case the callback is sync.


    ensureRootIsScheduled(root, eventTime);
    schedulePendingInteractions(root, lane);
  } // We use this when assigning a lane for a transition inside
  // `requestUpdateLane`. We assume it's the same as the root being updated,
  // since in the common case of a single root app it probably is. If it's not
  // the same root, then it's not a huge deal, we just might batch more stuff
  // together more than necessary.


  mostRecentlyUpdatedRoot = root;
} // This is split into a separate function so we can mark a fiber with pending
// work without treating it as a typical update that originates from an event;
// e.g. retrying a Suspense boundary isn't an update, but it does schedule work
// on a fiber.

function markUpdateLaneFromFiberToRoot(sourceFiber, lane) {
  // Update the source fiber's lanes
  sourceFiber.lanes = mergeLanes(sourceFiber.lanes, lane);
  var alternate = sourceFiber.alternate;

  if (alternate !== null) {
    alternate.lanes = mergeLanes(alternate.lanes, lane);
  }

  {
    if (alternate === null && (sourceFiber.flags & (Placement | Hydrating)) !== NoFlags) {
      warnAboutUpdateOnNotYetMountedFiberInDEV(sourceFiber);
    }
  } // Walk the parent path to the root and update the child expiration time.


  var node = sourceFiber;
  var parent = sourceFiber.return;

  while (parent !== null) {
    parent.childLanes = mergeLanes(parent.childLanes, lane);
    alternate = parent.alternate;

    if (alternate !== null) {
      alternate.childLanes = mergeLanes(alternate.childLanes, lane);
    } else {
      {
        if ((parent.flags & (Placement | Hydrating)) !== NoFlags) {
          warnAboutUpdateOnNotYetMountedFiberInDEV(sourceFiber);
        }
      }
    }

    node = parent;
    parent = parent.return;
  }

  if (node.tag === HostRoot) {
    var root = node.stateNode;
    return root;
  } else {
    return null;
  }
} // Use this function to schedule a task for a root. There's only one task per
// root; if a task was already scheduled, we'll check to make sure the priority
// of the existing task is the same as the priority of the next level that the
// root has work on. This function is called on every update, and right before
// exiting a task.


function ensureRootIsScheduled(root, currentTime) {
  var existingCallbackNode = root.callbackNode; // Check if any lanes are being starved by other work. If so, mark them as
  // expired so we know to work on those next.

  markStarvedLanesAsExpired(root, currentTime); // Determine the next lanes to work on, and their priority.

  var nextLanes = getNextLanes(root, root === workInProgressRoot ? workInProgressRootRenderLanes : NoLanes); // This returns the priority level computed during the `getNextLanes` call.

  var newCallbackPriority = returnNextLanesPriority();

  if (nextLanes === NoLanes) {
    // Special case: There's nothing to work on.
    if (existingCallbackNode !== null) {
      cancelCallback(existingCallbackNode);
      root.callbackNode = null;
      root.callbackPriority = NoLanePriority;
    }

    return;
  } // Check if there's an existing task. We may be able to reuse it.


  if (existingCallbackNode !== null) {
    var existingCallbackPriority = root.callbackPriority;

    if (existingCallbackPriority === newCallbackPriority) {
      // The priority hasn't changed. We can reuse the existing task. Exit.
      return;
    } // The priority changed. Cancel the existing callback. We'll schedule a new
    // one below.


    cancelCallback(existingCallbackNode);
  } // Schedule a new callback.


  var newCallbackNode;

  if (newCallbackPriority === SyncLanePriority) {
    // Special case: Sync React callbacks are scheduled on a special
    // internal queue
    newCallbackNode = scheduleSyncCallback(performSyncWorkOnRoot.bind(null, root));
  } else if (newCallbackPriority === SyncBatchedLanePriority) {
    newCallbackNode = scheduleCallback(ImmediatePriority$1, performSyncWorkOnRoot.bind(null, root));
  } else {
    var schedulerPriorityLevel = lanePriorityToSchedulerPriority(newCallbackPriority);
    newCallbackNode = scheduleCallback(schedulerPriorityLevel, performConcurrentWorkOnRoot.bind(null, root));
  }

  root.callbackPriority = newCallbackPriority;
  root.callbackNode = newCallbackNode;
} // This is the entry point for every concurrent task, i.e. anything that
// goes through Scheduler.


function performConcurrentWorkOnRoot(root) {
  // Since we know we're in a React event, we can clear the current
  // event time. The next update will compute a new event time.
  currentEventTime = NoTimestamp;
  currentEventWipLanes = NoLanes;
  currentEventPendingLanes = NoLanes;

  if (!((executionContext & (RenderContext | CommitContext)) === NoContext)) {
    {
      throw Error( "Should not already be working." );
    }
  } // Flush any pending passive effects before deciding which lanes to work on,
  // in case they schedule additional work.


  var originalCallbackNode = root.callbackNode;
  var didFlushPassiveEffects = flushPassiveEffects();

  if (didFlushPassiveEffects) {
    // Something in the passive effect phase may have canceled the current task.
    // Check if the task node for this root was changed.
    if (root.callbackNode !== originalCallbackNode) {
      // The current task was canceled. Exit. We don't need to call
      // `ensureRootIsScheduled` because the check above implies either that
      // there's a new task, or that there's no remaining work on this root.
      return null;
    }
  } // Determine the next expiration time to work on, using the fields stored
  // on the root.


  var lanes = getNextLanes(root, root === workInProgressRoot ? workInProgressRootRenderLanes : NoLanes);

  if (lanes === NoLanes) {
    // Defensive coding. This is never expected to happen.
    return null;
  }

  var exitStatus = renderRootConcurrent(root, lanes);

  if (includesSomeLane(workInProgressRootIncludedLanes, workInProgressRootUpdatedLanes)) {
    // The render included lanes that were updated during the render phase.
    // For example, when unhiding a hidden tree, we include all the lanes
    // that were previously skipped when the tree was hidden. That set of
    // lanes is a superset of the lanes we started rendering with.
    //
    // So we'll throw out the current work and restart.
    prepareFreshStack(root, NoLanes);
  } else if (exitStatus !== RootIncomplete) {
    if (exitStatus === RootErrored) {
      executionContext |= RetryAfterError; // If an error occurred during hydration,
      // discard server response and fall back to client side render.

      if (root.hydrate) {
        root.hydrate = false;
        clearContainer(root.containerInfo);
      } // If something threw an error, try rendering one more time. We'll render
      // synchronously to block concurrent data mutations, and we'll includes
      // all pending updates are included. If it still fails after the second
      // attempt, we'll give up and commit the resulting tree.


      lanes = getLanesToRetrySynchronouslyOnError(root);

      if (lanes !== NoLanes) {
        exitStatus = renderRootSync(root, lanes);
      }
    }

    if (exitStatus === RootFatalErrored) {
      var fatalError = workInProgressRootFatalError;
      prepareFreshStack(root, NoLanes);
      markRootSuspended$1(root, lanes);
      ensureRootIsScheduled(root, now());
      throw fatalError;
    } // We now have a consistent tree. The next step is either to commit it,
    // or, if something suspended, wait to commit it after a timeout.


    var finishedWork = root.current.alternate;
    root.finishedWork = finishedWork;
    root.finishedLanes = lanes;
    finishConcurrentRender(root, exitStatus, lanes);
  }

  ensureRootIsScheduled(root, now());

  if (root.callbackNode === originalCallbackNode) {
    // The task node scheduled for this root is the same one that's
    // currently executed. Need to return a continuation.
    return performConcurrentWorkOnRoot.bind(null, root);
  }

  return null;
}

function finishConcurrentRender(root, exitStatus, lanes) {
  switch (exitStatus) {
    case RootIncomplete:
    case RootFatalErrored:
      {
        {
          {
            throw Error( "Root did not complete. This is a bug in React." );
          }
        }
      }
    // Flow knows about invariant, so it complains if I add a break
    // statement, but eslint doesn't know about invariant, so it complains
    // if I do. eslint-disable-next-line no-fallthrough

    case RootErrored:
      {
        // We should have already attempted to retry this tree. If we reached
        // this point, it errored again. Commit it.
        commitRoot(root);
        break;
      }

    case RootSuspended:
      {
        markRootSuspended$1(root, lanes); // We have an acceptable loading state. We need to figure out if we
        // should immediately commit it or wait a bit.

        if (includesOnlyRetries(lanes) && // do not delay if we're inside an act() scope
        !shouldForceFlushFallbacksInDEV()) {
          // This render only included retries, no updates. Throttle committing
          // retries so that we don't show too many loading states too quickly.
          var msUntilTimeout = globalMostRecentFallbackTime + FALLBACK_THROTTLE_MS - now(); // Don't bother with a very short suspense time.

          if (msUntilTimeout > 10) {
            var nextLanes = getNextLanes(root, NoLanes);

            if (nextLanes !== NoLanes) {
              // There's additional work on this root.
              break;
            }

            var suspendedLanes = root.suspendedLanes;

            if (!isSubsetOfLanes(suspendedLanes, lanes)) {
              // We should prefer to render the fallback of at the last
              // suspended level. Ping the last suspended level to try
              // rendering it again.
              // FIXME: What if the suspended lanes are Idle? Should not restart.
              var eventTime = requestEventTime();
              markRootPinged(root, suspendedLanes);
              break;
            } // The render is suspended, it hasn't timed out, and there's no
            // lower priority work to do. Instead of committing the fallback
            // immediately, wait for more data to arrive.


            root.timeoutHandle = scheduleTimeout(commitRoot.bind(null, root), msUntilTimeout);
            break;
          }
        } // The work expired. Commit immediately.


        commitRoot(root);
        break;
      }

    case RootSuspendedWithDelay:
      {
        markRootSuspended$1(root, lanes);

        if (includesOnlyTransitions(lanes)) {
          // This is a transition, so we should exit without committing a
          // placeholder and without scheduling a timeout. Delay indefinitely
          // until we receive more data.
          break;
        }

        if (!shouldForceFlushFallbacksInDEV()) {
          // This is not a transition, but we did trigger an avoided state.
          // Schedule a placeholder to display after a short delay, using the Just
          // Noticeable Difference.
          // TODO: Is the JND optimization worth the added complexity? If this is
          // the only reason we track the event time, then probably not.
          // Consider removing.
          var mostRecentEventTime = getMostRecentEventTime(root, lanes);
          var eventTimeMs = mostRecentEventTime;
          var timeElapsedMs = now() - eventTimeMs;

          var _msUntilTimeout = jnd(timeElapsedMs) - timeElapsedMs; // Don't bother with a very short suspense time.


          if (_msUntilTimeout > 10) {
            // Instead of committing the fallback immediately, wait for more data
            // to arrive.
            root.timeoutHandle = scheduleTimeout(commitRoot.bind(null, root), _msUntilTimeout);
            break;
          }
        } // Commit the placeholder.


        commitRoot(root);
        break;
      }

    case RootCompleted:
      {
        // The work completed. Ready to commit.
        commitRoot(root);
        break;
      }

    default:
      {
        {
          {
            throw Error( "Unknown root exit status." );
          }
        }
      }
  }
}

function markRootSuspended$1(root, suspendedLanes) {
  // When suspending, we should always exclude lanes that were pinged or (more
  // rarely, since we try to avoid it) updated during the render phase.
  // TODO: Lol maybe there's a better way to factor this besides this
  // obnoxiously named function :)
  suspendedLanes = removeLanes(suspendedLanes, workInProgressRootPingedLanes);
  suspendedLanes = removeLanes(suspendedLanes, workInProgressRootUpdatedLanes);
  markRootSuspended(root, suspendedLanes);
} // This is the entry point for synchronous tasks that don't go
// through Scheduler


function performSyncWorkOnRoot(root) {
  if (!((executionContext & (RenderContext | CommitContext)) === NoContext)) {
    {
      throw Error( "Should not already be working." );
    }
  }

  flushPassiveEffects();
  var lanes;
  var exitStatus;

  if (root === workInProgressRoot && includesSomeLane(root.expiredLanes, workInProgressRootRenderLanes)) {
    // There's a partial tree, and at least one of its lanes has expired. Finish
    // rendering it before rendering the rest of the expired work.
    lanes = workInProgressRootRenderLanes;
    exitStatus = renderRootSync(root, lanes);

    if (includesSomeLane(workInProgressRootIncludedLanes, workInProgressRootUpdatedLanes)) {
      // The render included lanes that were updated during the render phase.
      // For example, when unhiding a hidden tree, we include all the lanes
      // that were previously skipped when the tree was hidden. That set of
      // lanes is a superset of the lanes we started rendering with.
      //
      // Note that this only happens when part of the tree is rendered
      // concurrently. If the whole tree is rendered synchronously, then there
      // are no interleaved events.
      lanes = getNextLanes(root, lanes);
      exitStatus = renderRootSync(root, lanes);
    }
  } else {
    lanes = getNextLanes(root, NoLanes);
    exitStatus = renderRootSync(root, lanes);
  }

  if (root.tag !== LegacyRoot && exitStatus === RootErrored) {
    executionContext |= RetryAfterError; // If an error occurred during hydration,
    // discard server response and fall back to client side render.

    if (root.hydrate) {
      root.hydrate = false;
      clearContainer(root.containerInfo);
    } // If something threw an error, try rendering one more time. We'll render
    // synchronously to block concurrent data mutations, and we'll includes
    // all pending updates are included. If it still fails after the second
    // attempt, we'll give up and commit the resulting tree.


    lanes = getLanesToRetrySynchronouslyOnError(root);

    if (lanes !== NoLanes) {
      exitStatus = renderRootSync(root, lanes);
    }
  }

  if (exitStatus === RootFatalErrored) {
    var fatalError = workInProgressRootFatalError;
    prepareFreshStack(root, NoLanes);
    markRootSuspended$1(root, lanes);
    ensureRootIsScheduled(root, now());
    throw fatalError;
  } // We now have a consistent tree. Because this is a sync render, we
  // will commit it even if something suspended.


  var finishedWork = root.current.alternate;
  root.finishedWork = finishedWork;
  root.finishedLanes = lanes;
  commitRoot(root); // Before exiting, make sure there's a callback scheduled for the next
  // pending level.

  ensureRootIsScheduled(root, now());
  return null;
}
function flushDiscreteUpdates() {
  // TODO: Should be able to flush inside batchedUpdates, but not inside `act`.
  // However, `act` uses `batchedUpdates`, so there's no way to distinguish
  // those two cases. Need to fix this before exposing flushDiscreteUpdates
  // as a public API.
  if ((executionContext & (BatchedContext | RenderContext | CommitContext)) !== NoContext) {
    {
      if ((executionContext & RenderContext) !== NoContext) {
        error('unstable_flushDiscreteUpdates: Cannot flush updates when React is ' + 'already rendering.');
      }
    } // We're already rendering, so we can't synchronously flush pending work.
    // This is probably a nested event dispatch triggered by a lifecycle/effect,
    // like `el.focus()`. Exit.


    return;
  }

  flushPendingDiscreteUpdates(); // If the discrete updates scheduled passive effects, flush them now so that
  // they fire before the next serial event.

  flushPassiveEffects();
}

function flushPendingDiscreteUpdates() {
  if (rootsWithPendingDiscreteUpdates !== null) {
    // For each root with pending discrete updates, schedule a callback to
    // immediately flush them.
    var roots = rootsWithPendingDiscreteUpdates;
    rootsWithPendingDiscreteUpdates = null;
    roots.forEach(function (root) {
      markDiscreteUpdatesExpired(root);
      ensureRootIsScheduled(root, now());
    });
  } // Now flush the immediate queue.


  flushSyncCallbackQueue();
}

function batchedUpdates$1(fn, a) {
  var prevExecutionContext = executionContext;
  executionContext |= BatchedContext;

  try {
    return fn(a);
  } finally {
    executionContext = prevExecutionContext;

    if (executionContext === NoContext) {
      // Flush the immediate callbacks that were scheduled during this batch
      resetRenderTimer();
      flushSyncCallbackQueue();
    }
  }
}
function batchedEventUpdates$1(fn, a) {
  var prevExecutionContext = executionContext;
  executionContext |= EventContext;

  try {
    return fn(a);
  } finally {
    executionContext = prevExecutionContext;

    if (executionContext === NoContext) {
      // Flush the immediate callbacks that were scheduled during this batch
      resetRenderTimer();
      flushSyncCallbackQueue();
    }
  }
}
function discreteUpdates$1(fn, a, b, c, d) {
  var prevExecutionContext = executionContext;
  executionContext |= DiscreteEventContext;

  {
    try {
      return runWithPriority$1(UserBlockingPriority$2, fn.bind(null, a, b, c, d));
    } finally {
      executionContext = prevExecutionContext;

      if (executionContext === NoContext) {
        // Flush the immediate callbacks that were scheduled during this batch
        resetRenderTimer();
        flushSyncCallbackQueue();
      }
    }
  }
}
function unbatchedUpdates(fn, a) {
  var prevExecutionContext = executionContext;
  executionContext &= ~BatchedContext;
  executionContext |= LegacyUnbatchedContext;

  try {
    return fn(a);
  } finally {
    executionContext = prevExecutionContext;

    if (executionContext === NoContext) {
      // Flush the immediate callbacks that were scheduled during this batch
      resetRenderTimer();
      flushSyncCallbackQueue();
    }
  }
}
function flushSync(fn, a) {
  var prevExecutionContext = executionContext;

  if ((prevExecutionContext & (RenderContext | CommitContext)) !== NoContext) {
    {
      error('flushSync was called from inside a lifecycle method. React cannot ' + 'flush when React is already rendering. Consider moving this call to ' + 'a scheduler task or micro task.');
    }

    return fn(a);
  }

  executionContext |= BatchedContext;

  {
    try {
      if (fn) {
        return runWithPriority$1(ImmediatePriority$1, fn.bind(null, a));
      } else {
        return undefined;
      }
    } finally {
      executionContext = prevExecutionContext; // Flush the immediate callbacks that were scheduled during this batch.
      // Note that this will happen even if batchedUpdates is higher up
      // the stack.

      flushSyncCallbackQueue();
    }
  }
}
function pushRenderLanes(fiber, lanes) {
  push(subtreeRenderLanesCursor, subtreeRenderLanes, fiber);
  subtreeRenderLanes = mergeLanes(subtreeRenderLanes, lanes);
  workInProgressRootIncludedLanes = mergeLanes(workInProgressRootIncludedLanes, lanes);
}
function popRenderLanes(fiber) {
  subtreeRenderLanes = subtreeRenderLanesCursor.current;
  pop(subtreeRenderLanesCursor, fiber);
}

function prepareFreshStack(root, lanes) {
  root.finishedWork = null;
  root.finishedLanes = NoLanes;
  var timeoutHandle = root.timeoutHandle;

  if (timeoutHandle !== noTimeout) {
    // The root previous suspended and scheduled a timeout to commit a fallback
    // state. Now that we have additional work, cancel the timeout.
    root.timeoutHandle = noTimeout; // $FlowFixMe Complains noTimeout is not a TimeoutID, despite the check above

    cancelTimeout(timeoutHandle);
  }

  if (workInProgress !== null) {
    var interruptedWork = workInProgress.return;

    while (interruptedWork !== null) {
      unwindInterruptedWork(interruptedWork);
      interruptedWork = interruptedWork.return;
    }
  }

  workInProgressRoot = root;
  workInProgress = createWorkInProgress(root.current, null);
  workInProgressRootRenderLanes = subtreeRenderLanes = workInProgressRootIncludedLanes = lanes;
  workInProgressRootExitStatus = RootIncomplete;
  workInProgressRootFatalError = null;
  workInProgressRootSkippedLanes = NoLanes;
  workInProgressRootUpdatedLanes = NoLanes;
  workInProgressRootPingedLanes = NoLanes;

  {
    spawnedWorkDuringRender = null;
  }

  {
    ReactStrictModeWarnings.discardPendingWarnings();
  }
}

function handleError(root, thrownValue) {
  do {
    var erroredWork = workInProgress;

    try {
      // Reset module-level state that was set during the render phase.
      resetContextDependencies();
      resetHooksAfterThrow();
      resetCurrentFiber(); // TODO: I found and added this missing line while investigating a
      // separate issue. Write a regression test using string refs.

      ReactCurrentOwner$2.current = null;

      if (erroredWork === null || erroredWork.return === null) {
        // Expected to be working on a non-root fiber. This is a fatal error
        // because there's no ancestor that can handle it; the root is
        // supposed to capture all errors that weren't caught by an error
        // boundary.
        workInProgressRootExitStatus = RootFatalErrored;
        workInProgressRootFatalError = thrownValue; // Set `workInProgress` to null. This represents advancing to the next
        // sibling, or the parent if there are no siblings. But since the root
        // has no siblings nor a parent, we set it to null. Usually this is
        // handled by `completeUnitOfWork` or `unwindWork`, but since we're
        // intentionally not calling those, we need set it here.
        // TODO: Consider calling `unwindWork` to pop the contexts.

        workInProgress = null;
        return;
      }

      if (enableProfilerTimer && erroredWork.mode & ProfileMode) {
        // Record the time spent rendering before an error was thrown. This
        // avoids inaccurate Profiler durations in the case of a
        // suspended render.
        stopProfilerTimerIfRunningAndRecordDelta(erroredWork, true);
      }

      throwException(root, erroredWork.return, erroredWork, thrownValue, workInProgressRootRenderLanes);
      completeUnitOfWork(erroredWork);
    } catch (yetAnotherThrownValue) {
      // Something in the return path also threw.
      thrownValue = yetAnotherThrownValue;

      if (workInProgress === erroredWork && erroredWork !== null) {
        // If this boundary has already errored, then we had trouble processing
        // the error. Bubble it to the next boundary.
        erroredWork = erroredWork.return;
        workInProgress = erroredWork;
      } else {
        erroredWork = workInProgress;
      }

      continue;
    } // Return to the normal work loop.


    return;
  } while (true);
}

function pushDispatcher() {
  var prevDispatcher = ReactCurrentDispatcher$2.current;
  ReactCurrentDispatcher$2.current = ContextOnlyDispatcher;

  if (prevDispatcher === null) {
    // The React isomorphic package does not include a default dispatcher.
    // Instead the first renderer will lazily attach one, in order to give
    // nicer error messages.
    return ContextOnlyDispatcher;
  } else {
    return prevDispatcher;
  }
}

function popDispatcher(prevDispatcher) {
  ReactCurrentDispatcher$2.current = prevDispatcher;
}

function pushInteractions(root) {
  {
    var prevInteractions = tracing.__interactionsRef.current;
    tracing.__interactionsRef.current = root.memoizedInteractions;
    return prevInteractions;
  }
}

function popInteractions(prevInteractions) {
  {
    tracing.__interactionsRef.current = prevInteractions;
  }
}

function markCommitTimeOfFallback() {
  globalMostRecentFallbackTime = now();
}
function markSkippedUpdateLanes(lane) {
  workInProgressRootSkippedLanes = mergeLanes(lane, workInProgressRootSkippedLanes);
}
function renderDidSuspend() {
  if (workInProgressRootExitStatus === RootIncomplete) {
    workInProgressRootExitStatus = RootSuspended;
  }
}
function renderDidSuspendDelayIfPossible() {
  if (workInProgressRootExitStatus === RootIncomplete || workInProgressRootExitStatus === RootSuspended) {
    workInProgressRootExitStatus = RootSuspendedWithDelay;
  } // Check if there are updates that we skipped tree that might have unblocked
  // this render.


  if (workInProgressRoot !== null && (includesNonIdleWork(workInProgressRootSkippedLanes) || includesNonIdleWork(workInProgressRootUpdatedLanes))) {
    // Mark the current render as suspended so that we switch to working on
    // the updates that were skipped. Usually we only suspend at the end of
    // the render phase.
    // TODO: We should probably always mark the root as suspended immediately
    // (inside this function), since by suspending at the end of the render
    // phase introduces a potential mistake where we suspend lanes that were
    // pinged or updated while we were rendering.
    markRootSuspended$1(workInProgressRoot, workInProgressRootRenderLanes);
  }
}
function renderDidError() {
  if (workInProgressRootExitStatus !== RootCompleted) {
    workInProgressRootExitStatus = RootErrored;
  }
} // Called during render to determine if anything has suspended.
// Returns false if we're not sure.

function renderHasNotSuspendedYet() {
  // If something errored or completed, we can't really be sure,
  // so those are false.
  return workInProgressRootExitStatus === RootIncomplete;
}

function renderRootSync(root, lanes) {
  var prevExecutionContext = executionContext;
  executionContext |= RenderContext;
  var prevDispatcher = pushDispatcher(); // If the root or lanes have changed, throw out the existing stack
  // and prepare a fresh one. Otherwise we'll continue where we left off.

  if (workInProgressRoot !== root || workInProgressRootRenderLanes !== lanes) {
    prepareFreshStack(root, lanes);
    startWorkOnPendingInteractions(root, lanes);
  }

  var prevInteractions = pushInteractions(root);

  do {
    try {
      workLoopSync();
      break;
    } catch (thrownValue) {
      handleError(root, thrownValue);
    }
  } while (true);

  resetContextDependencies();

  {
    popInteractions(prevInteractions);
  }

  executionContext = prevExecutionContext;
  popDispatcher(prevDispatcher);

  if (workInProgress !== null) {
    // This is a sync render, so we should have finished the whole tree.
    {
      {
        throw Error( "Cannot commit an incomplete root. This error is likely caused by a bug in React. Please file an issue." );
      }
    }
  }


  workInProgressRoot = null;
  workInProgressRootRenderLanes = NoLanes;
  return workInProgressRootExitStatus;
} // The work loop is an extremely hot path. Tell Closure not to inline it.

/** @noinline */


function workLoopSync() {
  // Already timed out, so perform work without checking if we need to yield.
  while (workInProgress !== null) {
    performUnitOfWork(workInProgress);
  }
}

function renderRootConcurrent(root, lanes) {
  var prevExecutionContext = executionContext;
  executionContext |= RenderContext;
  var prevDispatcher = pushDispatcher(); // If the root or lanes have changed, throw out the existing stack
  // and prepare a fresh one. Otherwise we'll continue where we left off.

  if (workInProgressRoot !== root || workInProgressRootRenderLanes !== lanes) {
    resetRenderTimer();
    prepareFreshStack(root, lanes);
    startWorkOnPendingInteractions(root, lanes);
  }

  var prevInteractions = pushInteractions(root);

  do {
    try {
      workLoopConcurrent();
      break;
    } catch (thrownValue) {
      handleError(root, thrownValue);
    }
  } while (true);

  resetContextDependencies();

  {
    popInteractions(prevInteractions);
  }

  popDispatcher(prevDispatcher);
  executionContext = prevExecutionContext;


  if (workInProgress !== null) {

    return RootIncomplete;
  } else {


    workInProgressRoot = null;
    workInProgressRootRenderLanes = NoLanes; // Return the final exit status.

    return workInProgressRootExitStatus;
  }
}
/** @noinline */


function workLoopConcurrent() {
  // Perform work until Scheduler asks us to yield
  while (workInProgress !== null && !shouldYield()) {
    performUnitOfWork(workInProgress);
  }
}

function performUnitOfWork(unitOfWork) {
  // The current, flushed, state of this fiber is the alternate. Ideally
  // nothing should rely on this, but relying on it here means that we don't
  // need an additional field on the work in progress.
  var current = unitOfWork.alternate;
  setCurrentFiber(unitOfWork);
  var next;

  if ( (unitOfWork.mode & ProfileMode) !== NoMode) {
    startProfilerTimer(unitOfWork);
    next = beginWork$1(current, unitOfWork, subtreeRenderLanes);
    stopProfilerTimerIfRunningAndRecordDelta(unitOfWork, true);
  } else {
    next = beginWork$1(current, unitOfWork, subtreeRenderLanes);
  }

  resetCurrentFiber();
  unitOfWork.memoizedProps = unitOfWork.pendingProps;

  if (next === null) {
    // If this doesn't spawn new work, complete the current work.
    completeUnitOfWork(unitOfWork);
  } else {
    workInProgress = next;
  }

  ReactCurrentOwner$2.current = null;
}

function completeUnitOfWork(unitOfWork) {
  // Attempt to complete the current unit of work, then move to the next
  // sibling. If there are no more siblings, return to the parent fiber.
  var completedWork = unitOfWork;

  do {
    // The current, flushed, state of this fiber is the alternate. Ideally
    // nothing should rely on this, but relying on it here means that we don't
    // need an additional field on the work in progress.
    var current = completedWork.alternate;
    var returnFiber = completedWork.return; // Check if the work completed or if something threw.

    if ((completedWork.flags & Incomplete) === NoFlags) {
      setCurrentFiber(completedWork);
      var next = void 0;

      if ( (completedWork.mode & ProfileMode) === NoMode) {
        next = completeWork(current, completedWork, subtreeRenderLanes);
      } else {
        startProfilerTimer(completedWork);
        next = completeWork(current, completedWork, subtreeRenderLanes); // Update render duration assuming we didn't error.

        stopProfilerTimerIfRunningAndRecordDelta(completedWork, false);
      }

      resetCurrentFiber();

      if (next !== null) {
        // Completing this fiber spawned new work. Work on that next.
        workInProgress = next;
        return;
      }

      resetChildLanes(completedWork);

      if (returnFiber !== null && // Do not append effects to parents if a sibling failed to complete
      (returnFiber.flags & Incomplete) === NoFlags) {
        // Append all the effects of the subtree and this fiber onto the effect
        // list of the parent. The completion order of the children affects the
        // side-effect order.
        if (returnFiber.firstEffect === null) {
          returnFiber.firstEffect = completedWork.firstEffect;
        }

        if (completedWork.lastEffect !== null) {
          if (returnFiber.lastEffect !== null) {
            returnFiber.lastEffect.nextEffect = completedWork.firstEffect;
          }

          returnFiber.lastEffect = completedWork.lastEffect;
        } // If this fiber had side-effects, we append it AFTER the children's
        // side-effects. We can perform certain side-effects earlier if needed,
        // by doing multiple passes over the effect list. We don't want to
        // schedule our own side-effect on our own list because if end up
        // reusing children we'll schedule this effect onto itself since we're
        // at the end.


        var flags = completedWork.flags; // Skip both NoWork and PerformedWork tags when creating the effect
        // list. PerformedWork effect is read by React DevTools but shouldn't be
        // committed.

        if (flags > PerformedWork) {
          if (returnFiber.lastEffect !== null) {
            returnFiber.lastEffect.nextEffect = completedWork;
          } else {
            returnFiber.firstEffect = completedWork;
          }

          returnFiber.lastEffect = completedWork;
        }
      }
    } else {
      // This fiber did not complete because something threw. Pop values off
      // the stack without entering the complete phase. If this is a boundary,
      // capture values if possible.
      var _next = unwindWork(completedWork); // Because this fiber did not complete, don't reset its expiration time.


      if (_next !== null) {
        // If completing this work spawned new work, do that next. We'll come
        // back here again.
        // Since we're restarting, remove anything that is not a host effect
        // from the effect tag.
        _next.flags &= HostEffectMask;
        workInProgress = _next;
        return;
      }

      if ( (completedWork.mode & ProfileMode) !== NoMode) {
        // Record the render duration for the fiber that errored.
        stopProfilerTimerIfRunningAndRecordDelta(completedWork, false); // Include the time spent working on failed children before continuing.

        var actualDuration = completedWork.actualDuration;
        var child = completedWork.child;

        while (child !== null) {
          actualDuration += child.actualDuration;
          child = child.sibling;
        }

        completedWork.actualDuration = actualDuration;
      }

      if (returnFiber !== null) {
        // Mark the parent fiber as incomplete and clear its effect list.
        returnFiber.firstEffect = returnFiber.lastEffect = null;
        returnFiber.flags |= Incomplete;
      }
    }

    var siblingFiber = completedWork.sibling;

    if (siblingFiber !== null) {
      // If there is more work to do in this returnFiber, do that next.
      workInProgress = siblingFiber;
      return;
    } // Otherwise, return to the parent


    completedWork = returnFiber; // Update the next thing we're working on in case something throws.

    workInProgress = completedWork;
  } while (completedWork !== null); // We've reached the root.


  if (workInProgressRootExitStatus === RootIncomplete) {
    workInProgressRootExitStatus = RootCompleted;
  }
}

function resetChildLanes(completedWork) {
  if ( // TODO: Move this check out of the hot path by moving `resetChildLanes`
  // to switch statement in `completeWork`.
  (completedWork.tag === LegacyHiddenComponent || completedWork.tag === OffscreenComponent) && completedWork.memoizedState !== null && !includesSomeLane(subtreeRenderLanes, OffscreenLane) && (completedWork.mode & ConcurrentMode) !== NoLanes) {
    // The children of this component are hidden. Don't bubble their
    // expiration times.
    return;
  }

  var newChildLanes = NoLanes; // Bubble up the earliest expiration time.

  if ( (completedWork.mode & ProfileMode) !== NoMode) {
    // In profiling mode, resetChildExpirationTime is also used to reset
    // profiler durations.
    var actualDuration = completedWork.actualDuration;
    var treeBaseDuration = completedWork.selfBaseDuration; // When a fiber is cloned, its actualDuration is reset to 0. This value will
    // only be updated if work is done on the fiber (i.e. it doesn't bailout).
    // When work is done, it should bubble to the parent's actualDuration. If
    // the fiber has not been cloned though, (meaning no work was done), then
    // this value will reflect the amount of time spent working on a previous
    // render. In that case it should not bubble. We determine whether it was
    // cloned by comparing the child pointer.

    var shouldBubbleActualDurations = completedWork.alternate === null || completedWork.child !== completedWork.alternate.child;
    var child = completedWork.child;

    while (child !== null) {
      newChildLanes = mergeLanes(newChildLanes, mergeLanes(child.lanes, child.childLanes));

      if (shouldBubbleActualDurations) {
        actualDuration += child.actualDuration;
      }

      treeBaseDuration += child.treeBaseDuration;
      child = child.sibling;
    }

    var isTimedOutSuspense = completedWork.tag === SuspenseComponent && completedWork.memoizedState !== null;

    if (isTimedOutSuspense) {
      // Don't count time spent in a timed out Suspense subtree as part of the base duration.
      var primaryChildFragment = completedWork.child;

      if (primaryChildFragment !== null) {
        treeBaseDuration -= primaryChildFragment.treeBaseDuration;
      }
    }

    completedWork.actualDuration = actualDuration;
    completedWork.treeBaseDuration = treeBaseDuration;
  } else {
    var _child = completedWork.child;

    while (_child !== null) {
      newChildLanes = mergeLanes(newChildLanes, mergeLanes(_child.lanes, _child.childLanes));
      _child = _child.sibling;
    }
  }

  completedWork.childLanes = newChildLanes;
}

function commitRoot(root) {
  var renderPriorityLevel = getCurrentPriorityLevel();
  runWithPriority$1(ImmediatePriority$1, commitRootImpl.bind(null, root, renderPriorityLevel));
  return null;
}

function commitRootImpl(root, renderPriorityLevel) {
  do {
    // `flushPassiveEffects` will call `flushSyncUpdateQueue` at the end, which
    // means `flushPassiveEffects` will sometimes result in additional
    // passive effects. So we need to keep flushing in a loop until there are
    // no more pending effects.
    // TODO: Might be better if `flushPassiveEffects` did not automatically
    // flush synchronous work at the end, to avoid factoring hazards like this.
    flushPassiveEffects();
  } while (rootWithPendingPassiveEffects !== null);

  flushRenderPhaseStrictModeWarningsInDEV();

  if (!((executionContext & (RenderContext | CommitContext)) === NoContext)) {
    {
      throw Error( "Should not already be working." );
    }
  }

  var finishedWork = root.finishedWork;
  var lanes = root.finishedLanes;

  if (finishedWork === null) {

    return null;
  }

  root.finishedWork = null;
  root.finishedLanes = NoLanes;

  if (!(finishedWork !== root.current)) {
    {
      throw Error( "Cannot commit the same tree as before. This error is likely caused by a bug in React. Please file an issue." );
    }
  } // commitRoot never returns a continuation; it always finishes synchronously.
  // So we can clear these now to allow a new callback to be scheduled.


  root.callbackNode = null; // Update the first and last pending times on this root. The new first
  // pending time is whatever is left on the root fiber.

  var remainingLanes = mergeLanes(finishedWork.lanes, finishedWork.childLanes);
  markRootFinished(root, remainingLanes); // Clear already finished discrete updates in case that a later call of
  // `flushDiscreteUpdates` starts a useless render pass which may cancels
  // a scheduled timeout.

  if (rootsWithPendingDiscreteUpdates !== null) {
    if (!hasDiscreteLanes(remainingLanes) && rootsWithPendingDiscreteUpdates.has(root)) {
      rootsWithPendingDiscreteUpdates.delete(root);
    }
  }

  if (root === workInProgressRoot) {
    // We can reset these now that they are finished.
    workInProgressRoot = null;
    workInProgress = null;
    workInProgressRootRenderLanes = NoLanes;
  } // Get the list of effects.


  var firstEffect;

  if (finishedWork.flags > PerformedWork) {
    // A fiber's effect list consists only of its children, not itself. So if
    // the root has an effect, we need to add it to the end of the list. The
    // resulting list is the set that would belong to the root's parent, if it
    // had one; that is, all the effects in the tree including the root.
    if (finishedWork.lastEffect !== null) {
      finishedWork.lastEffect.nextEffect = finishedWork;
      firstEffect = finishedWork.firstEffect;
    } else {
      firstEffect = finishedWork;
    }
  } else {
    // There is no effect on the root.
    firstEffect = finishedWork.firstEffect;
  }

  if (firstEffect !== null) {

    var prevExecutionContext = executionContext;
    executionContext |= CommitContext;
    var prevInteractions = pushInteractions(root); // Reset this to null before calling lifecycles

    ReactCurrentOwner$2.current = null; // The commit phase is broken into several sub-phases. We do a separate pass
    // of the effect list for each phase: all mutation effects come before all
    // layout effects, and so on.
    // The first phase a "before mutation" phase. We use this phase to read the
    // state of the host tree right before we mutate it. This is where
    // getSnapshotBeforeUpdate is called.

    focusedInstanceHandle = prepareForCommit(root.containerInfo);
    shouldFireAfterActiveInstanceBlur = false;
    nextEffect = firstEffect;

    do {
      {
        invokeGuardedCallback(null, commitBeforeMutationEffects, null);

        if (hasCaughtError()) {
          if (!(nextEffect !== null)) {
            {
              throw Error( "Should be working on an effect." );
            }
          }

          var error = clearCaughtError();
          captureCommitPhaseError(nextEffect, error);
          nextEffect = nextEffect.nextEffect;
        }
      }
    } while (nextEffect !== null); // We no longer need to track the active instance fiber


    focusedInstanceHandle = null;

    {
      // Mark the current commit time to be shared by all Profilers in this
      // batch. This enables them to be grouped later.
      recordCommitTime();
    } // The next phase is the mutation phase, where we mutate the host tree.


    nextEffect = firstEffect;

    do {
      {
        invokeGuardedCallback(null, commitMutationEffects, null, root, renderPriorityLevel);

        if (hasCaughtError()) {
          if (!(nextEffect !== null)) {
            {
              throw Error( "Should be working on an effect." );
            }
          }

          var _error = clearCaughtError();

          captureCommitPhaseError(nextEffect, _error);
          nextEffect = nextEffect.nextEffect;
        }
      }
    } while (nextEffect !== null);

    resetAfterCommit(root.containerInfo); // The work-in-progress tree is now the current tree. This must come after
    // the mutation phase, so that the previous tree is still current during
    // componentWillUnmount, but before the layout phase, so that the finished
    // work is current during componentDidMount/Update.

    root.current = finishedWork; // The next phase is the layout phase, where we call effects that read
    // the host tree after it's been mutated. The idiomatic use case for this is
    // layout, but class component lifecycles also fire here for legacy reasons.

    nextEffect = firstEffect;

    do {
      {
        invokeGuardedCallback(null, commitLayoutEffects, null, root, lanes);

        if (hasCaughtError()) {
          if (!(nextEffect !== null)) {
            {
              throw Error( "Should be working on an effect." );
            }
          }

          var _error2 = clearCaughtError();

          captureCommitPhaseError(nextEffect, _error2);
          nextEffect = nextEffect.nextEffect;
        }
      }
    } while (nextEffect !== null);

    nextEffect = null; // Tell Scheduler to yield at the end of the frame, so the browser has an
    // opportunity to paint.

    requestPaint();

    {
      popInteractions(prevInteractions);
    }

    executionContext = prevExecutionContext;
  } else {
    // No effects.
    root.current = finishedWork; // Measure these anyway so the flamegraph explicitly shows that there were
    // no effects.
    // TODO: Maybe there's a better way to report this.

    {
      recordCommitTime();
    }
  }

  var rootDidHavePassiveEffects = rootDoesHavePassiveEffects;

  if (rootDoesHavePassiveEffects) {
    // This commit has passive effects. Stash a reference to them. But don't
    // schedule a callback until after flushing layout work.
    rootDoesHavePassiveEffects = false;
    rootWithPendingPassiveEffects = root;
    pendingPassiveEffectsLanes = lanes;
    pendingPassiveEffectsRenderPriority = renderPriorityLevel;
  } else {
    // We are done with the effect chain at this point so let's clear the
    // nextEffect pointers to assist with GC. If we have passive effects, we'll
    // clear this in flushPassiveEffects.
    nextEffect = firstEffect;

    while (nextEffect !== null) {
      var nextNextEffect = nextEffect.nextEffect;
      nextEffect.nextEffect = null;

      if (nextEffect.flags & Deletion) {
        detachFiberAfterEffects(nextEffect);
      }

      nextEffect = nextNextEffect;
    }
  } // Read this again, since an effect might have updated it


  remainingLanes = root.pendingLanes; // Check if there's remaining work on this root

  if (remainingLanes !== NoLanes) {
    {
      if (spawnedWorkDuringRender !== null) {
        var expirationTimes = spawnedWorkDuringRender;
        spawnedWorkDuringRender = null;

        for (var i = 0; i < expirationTimes.length; i++) {
          scheduleInteractions(root, expirationTimes[i], root.memoizedInteractions);
        }
      }

      schedulePendingInteractions(root, remainingLanes);
    }
  } else {
    // If there's no remaining work, we can clear the set of already failed
    // error boundaries.
    legacyErrorBoundariesThatAlreadyFailed = null;
  }

  {
    if (!rootDidHavePassiveEffects) {
      // If there are no passive effects, then we can complete the pending interactions.
      // Otherwise, we'll wait until after the passive effects are flushed.
      // Wait to do this until after remaining work has been scheduled,
      // so that we don't prematurely signal complete for interactions when there's e.g. hidden work.
      finishPendingInteractions(root, lanes);
    }
  }

  if (remainingLanes === SyncLane) {
    // Count the number of times the root synchronously re-renders without
    // finishing. If there are too many, it indicates an infinite update loop.
    if (root === rootWithNestedUpdates) {
      nestedUpdateCount++;
    } else {
      nestedUpdateCount = 0;
      rootWithNestedUpdates = root;
    }
  } else {
    nestedUpdateCount = 0;
  }

  onCommitRoot(finishedWork.stateNode, renderPriorityLevel);

  {
    onCommitRoot$1();
  } // Always call this before exiting `commitRoot`, to ensure that any
  // additional work on this root is scheduled.


  ensureRootIsScheduled(root, now());

  if (hasUncaughtError) {
    hasUncaughtError = false;
    var _error3 = firstUncaughtError;
    firstUncaughtError = null;
    throw _error3;
  }

  if ((executionContext & LegacyUnbatchedContext) !== NoContext) {
    // a ReactDOM.render-ed root inside of batchedUpdates. The commit fired
    // synchronously, but layout updates should be deferred until the end
    // of the batch.


    return null;
  } // If layout work was scheduled, flush it now.


  flushSyncCallbackQueue();

  return null;
}

function commitBeforeMutationEffects() {
  while (nextEffect !== null) {
    var current = nextEffect.alternate;

    if (!shouldFireAfterActiveInstanceBlur && focusedInstanceHandle !== null) {
      if ((nextEffect.flags & Deletion) !== NoFlags) {
        if (doesFiberContain(nextEffect, focusedInstanceHandle)) {
          shouldFireAfterActiveInstanceBlur = true;
        }
      } else {
        // TODO: Move this out of the hot path using a dedicated effect tag.
        if (nextEffect.tag === SuspenseComponent && isSuspenseBoundaryBeingHidden(current, nextEffect) && doesFiberContain(nextEffect, focusedInstanceHandle)) {
          shouldFireAfterActiveInstanceBlur = true;
        }
      }
    }

    var flags = nextEffect.flags;

    if ((flags & Snapshot) !== NoFlags) {
      setCurrentFiber(nextEffect);
      commitBeforeMutationLifeCycles(current, nextEffect);
      resetCurrentFiber();
    }

    if ((flags & Passive) !== NoFlags) {
      // If there are passive effects, schedule a callback to flush at
      // the earliest opportunity.
      if (!rootDoesHavePassiveEffects) {
        rootDoesHavePassiveEffects = true;
        scheduleCallback(NormalPriority$1, function () {
          flushPassiveEffects();
          return null;
        });
      }
    }

    nextEffect = nextEffect.nextEffect;
  }
}

function commitMutationEffects(root, renderPriorityLevel) {
  // TODO: Should probably move the bulk of this function to commitWork.
  while (nextEffect !== null) {
    setCurrentFiber(nextEffect);
    var flags = nextEffect.flags;

    if (flags & ContentReset) {
      commitResetTextContent(nextEffect);
    }

    if (flags & Ref) {
      var current = nextEffect.alternate;

      if (current !== null) {
        commitDetachRef(current);
      }
    } // The following switch statement is only concerned about placement,
    // updates, and deletions. To avoid needing to add a case for every possible
    // bitmap value, we remove the secondary effects from the effect tag and
    // switch on that value.


    var primaryFlags = flags & (Placement | Update | Deletion | Hydrating);

    switch (primaryFlags) {
      case Placement:
        {
          commitPlacement(nextEffect); // Clear the "placement" from effect tag so that we know that this is
          // inserted, before any life-cycles like componentDidMount gets called.
          // TODO: findDOMNode doesn't rely on this any more but isMounted does
          // and isMounted is deprecated anyway so we should be able to kill this.

          nextEffect.flags &= ~Placement;
          break;
        }

      case PlacementAndUpdate:
        {
          // Placement
          commitPlacement(nextEffect); // Clear the "placement" from effect tag so that we know that this is
          // inserted, before any life-cycles like componentDidMount gets called.

          nextEffect.flags &= ~Placement; // Update

          var _current = nextEffect.alternate;
          commitWork(_current, nextEffect);
          break;
        }

      case Hydrating:
        {
          nextEffect.flags &= ~Hydrating;
          break;
        }

      case HydratingAndUpdate:
        {
          nextEffect.flags &= ~Hydrating; // Update

          var _current2 = nextEffect.alternate;
          commitWork(_current2, nextEffect);
          break;
        }

      case Update:
        {
          var _current3 = nextEffect.alternate;
          commitWork(_current3, nextEffect);
          break;
        }

      case Deletion:
        {
          commitDeletion(root, nextEffect);
          break;
        }
    }

    resetCurrentFiber();
    nextEffect = nextEffect.nextEffect;
  }
}

function commitLayoutEffects(root, committedLanes) {


  while (nextEffect !== null) {
    setCurrentFiber(nextEffect);
    var flags = nextEffect.flags;

    if (flags & (Update | Callback)) {
      var current = nextEffect.alternate;
      commitLifeCycles(root, current, nextEffect);
    }

    {
      if (flags & Ref) {
        commitAttachRef(nextEffect);
      }
    }

    resetCurrentFiber();
    nextEffect = nextEffect.nextEffect;
  }
}

function flushPassiveEffects() {
  // Returns whether passive effects were flushed.
  if (pendingPassiveEffectsRenderPriority !== NoPriority$1) {
    var priorityLevel = pendingPassiveEffectsRenderPriority > NormalPriority$1 ? NormalPriority$1 : pendingPassiveEffectsRenderPriority;
    pendingPassiveEffectsRenderPriority = NoPriority$1;

    {
      return runWithPriority$1(priorityLevel, flushPassiveEffectsImpl);
    }
  }

  return false;
}
function enqueuePendingPassiveHookEffectMount(fiber, effect) {
  pendingPassiveHookEffectsMount.push(effect, fiber);

  if (!rootDoesHavePassiveEffects) {
    rootDoesHavePassiveEffects = true;
    scheduleCallback(NormalPriority$1, function () {
      flushPassiveEffects();
      return null;
    });
  }
}
function enqueuePendingPassiveHookEffectUnmount(fiber, effect) {
  pendingPassiveHookEffectsUnmount.push(effect, fiber);

  {
    fiber.flags |= PassiveUnmountPendingDev;
    var alternate = fiber.alternate;

    if (alternate !== null) {
      alternate.flags |= PassiveUnmountPendingDev;
    }
  }

  if (!rootDoesHavePassiveEffects) {
    rootDoesHavePassiveEffects = true;
    scheduleCallback(NormalPriority$1, function () {
      flushPassiveEffects();
      return null;
    });
  }
}

function invokePassiveEffectCreate(effect) {
  var create = effect.create;
  effect.destroy = create();
}

function flushPassiveEffectsImpl() {
  if (rootWithPendingPassiveEffects === null) {
    return false;
  }

  var root = rootWithPendingPassiveEffects;
  var lanes = pendingPassiveEffectsLanes;
  rootWithPendingPassiveEffects = null;
  pendingPassiveEffectsLanes = NoLanes;

  if (!((executionContext & (RenderContext | CommitContext)) === NoContext)) {
    {
      throw Error( "Cannot flush passive effects while already rendering." );
    }
  }

  {
    isFlushingPassiveEffects = true;
  }

  var prevExecutionContext = executionContext;
  executionContext |= CommitContext;
  var prevInteractions = pushInteractions(root); // It's important that ALL pending passive effect destroy functions are called
  // before ANY passive effect create functions are called.
  // Otherwise effects in sibling components might interfere with each other.
  // e.g. a destroy function in one component may unintentionally override a ref
  // value set by a create function in another component.
  // Layout effects have the same constraint.
  // First pass: Destroy stale passive effects.

  var unmountEffects = pendingPassiveHookEffectsUnmount;
  pendingPassiveHookEffectsUnmount = [];

  for (var i = 0; i < unmountEffects.length; i += 2) {
    var _effect = unmountEffects[i];
    var fiber = unmountEffects[i + 1];
    var destroy = _effect.destroy;
    _effect.destroy = undefined;

    {
      fiber.flags &= ~PassiveUnmountPendingDev;
      var alternate = fiber.alternate;

      if (alternate !== null) {
        alternate.flags &= ~PassiveUnmountPendingDev;
      }
    }

    if (typeof destroy === 'function') {
      {
        setCurrentFiber(fiber);

        {
          invokeGuardedCallback(null, destroy, null);
        }

        if (hasCaughtError()) {
          if (!(fiber !== null)) {
            {
              throw Error( "Should be working on an effect." );
            }
          }

          var error = clearCaughtError();
          captureCommitPhaseError(fiber, error);
        }

        resetCurrentFiber();
      }
    }
  } // Second pass: Create new passive effects.


  var mountEffects = pendingPassiveHookEffectsMount;
  pendingPassiveHookEffectsMount = [];

  for (var _i = 0; _i < mountEffects.length; _i += 2) {
    var _effect2 = mountEffects[_i];
    var _fiber = mountEffects[_i + 1];

    {
      setCurrentFiber(_fiber);

      {
        invokeGuardedCallback(null, invokePassiveEffectCreate, null, _effect2);
      }

      if (hasCaughtError()) {
        if (!(_fiber !== null)) {
          {
            throw Error( "Should be working on an effect." );
          }
        }

        var _error4 = clearCaughtError();

        captureCommitPhaseError(_fiber, _error4);
      }

      resetCurrentFiber();
    }
  } // Note: This currently assumes there are no passive effects on the root fiber
  // because the root is not part of its own effect list.
  // This could change in the future.


  var effect = root.current.firstEffect;

  while (effect !== null) {
    var nextNextEffect = effect.nextEffect; // Remove nextEffect pointer to assist GC

    effect.nextEffect = null;

    if (effect.flags & Deletion) {
      detachFiberAfterEffects(effect);
    }

    effect = nextNextEffect;
  }

  {
    popInteractions(prevInteractions);
    finishPendingInteractions(root, lanes);
  }

  {
    isFlushingPassiveEffects = false;
  }

  executionContext = prevExecutionContext;
  flushSyncCallbackQueue(); // If additional passive effects were scheduled, increment a counter. If this
  // exceeds the limit, we'll fire a warning.

  nestedPassiveUpdateCount = rootWithPendingPassiveEffects === null ? 0 : nestedPassiveUpdateCount + 1;
  return true;
}

function isAlreadyFailedLegacyErrorBoundary(instance) {
  return legacyErrorBoundariesThatAlreadyFailed !== null && legacyErrorBoundariesThatAlreadyFailed.has(instance);
}
function markLegacyErrorBoundaryAsFailed(instance) {
  if (legacyErrorBoundariesThatAlreadyFailed === null) {
    legacyErrorBoundariesThatAlreadyFailed = new Set([instance]);
  } else {
    legacyErrorBoundariesThatAlreadyFailed.add(instance);
  }
}

function prepareToThrowUncaughtError(error) {
  if (!hasUncaughtError) {
    hasUncaughtError = true;
    firstUncaughtError = error;
  }
}

var onUncaughtError = prepareToThrowUncaughtError;

function captureCommitPhaseErrorOnRoot(rootFiber, sourceFiber, error) {
  var errorInfo = createCapturedValue(error, sourceFiber);
  var update = createRootErrorUpdate(rootFiber, errorInfo, SyncLane);
  enqueueUpdate(rootFiber, update);
  var eventTime = requestEventTime();
  var root = markUpdateLaneFromFiberToRoot(rootFiber, SyncLane);

  if (root !== null) {
    markRootUpdated(root, SyncLane, eventTime);
    ensureRootIsScheduled(root, eventTime);
    schedulePendingInteractions(root, SyncLane);
  }
}

function captureCommitPhaseError(sourceFiber, error) {
  if (sourceFiber.tag === HostRoot) {
    // Error was thrown at the root. There is no parent, so the root
    // itself should capture it.
    captureCommitPhaseErrorOnRoot(sourceFiber, sourceFiber, error);
    return;
  }

  var fiber = sourceFiber.return;

  while (fiber !== null) {
    if (fiber.tag === HostRoot) {
      captureCommitPhaseErrorOnRoot(fiber, sourceFiber, error);
      return;
    } else if (fiber.tag === ClassComponent) {
      var ctor = fiber.type;
      var instance = fiber.stateNode;

      if (typeof ctor.getDerivedStateFromError === 'function' || typeof instance.componentDidCatch === 'function' && !isAlreadyFailedLegacyErrorBoundary(instance)) {
        var errorInfo = createCapturedValue(error, sourceFiber);
        var update = createClassErrorUpdate(fiber, errorInfo, SyncLane);
        enqueueUpdate(fiber, update);
        var eventTime = requestEventTime();
        var root = markUpdateLaneFromFiberToRoot(fiber, SyncLane);

        if (root !== null) {
          markRootUpdated(root, SyncLane, eventTime);
          ensureRootIsScheduled(root, eventTime);
          schedulePendingInteractions(root, SyncLane);
        } else {
          // This component has already been unmounted.
          // We can't schedule any follow up work for the root because the fiber is already unmounted,
          // but we can still call the log-only boundary so the error isn't swallowed.
          //
          // TODO This is only a temporary bandaid for the old reconciler fork.
          // We can delete this special case once the new fork is merged.
          if (typeof instance.componentDidCatch === 'function' && !isAlreadyFailedLegacyErrorBoundary(instance)) {
            try {
              instance.componentDidCatch(error, errorInfo);
            } catch (errorToIgnore) {// TODO Ignore this error? Rethrow it?
              // This is kind of an edge case.
            }
          }
        }

        return;
      }
    }

    fiber = fiber.return;
  }
}
function pingSuspendedRoot(root, wakeable, pingedLanes) {
  var pingCache = root.pingCache;

  if (pingCache !== null) {
    // The wakeable resolved, so we no longer need to memoize, because it will
    // never be thrown again.
    pingCache.delete(wakeable);
  }

  var eventTime = requestEventTime();
  markRootPinged(root, pingedLanes);

  if (workInProgressRoot === root && isSubsetOfLanes(workInProgressRootRenderLanes, pingedLanes)) {
    // Received a ping at the same priority level at which we're currently
    // rendering. We might want to restart this render. This should mirror
    // the logic of whether or not a root suspends once it completes.
    // TODO: If we're rendering sync either due to Sync, Batched or expired,
    // we should probably never restart.
    // If we're suspended with delay, or if it's a retry, we'll always suspend
    // so we can always restart.
    if (workInProgressRootExitStatus === RootSuspendedWithDelay || workInProgressRootExitStatus === RootSuspended && includesOnlyRetries(workInProgressRootRenderLanes) && now() - globalMostRecentFallbackTime < FALLBACK_THROTTLE_MS) {
      // Restart from the root.
      prepareFreshStack(root, NoLanes);
    } else {
      // Even though we can't restart right now, we might get an
      // opportunity later. So we mark this render as having a ping.
      workInProgressRootPingedLanes = mergeLanes(workInProgressRootPingedLanes, pingedLanes);
    }
  }

  ensureRootIsScheduled(root, eventTime);
  schedulePendingInteractions(root, pingedLanes);
}

function retryTimedOutBoundary(boundaryFiber, retryLane) {
  // The boundary fiber (a Suspense component or SuspenseList component)
  // previously was rendered in its fallback state. One of the promises that
  // suspended it has resolved, which means at least part of the tree was
  // likely unblocked. Try rendering again, at a new expiration time.
  if (retryLane === NoLane) {
    retryLane = requestRetryLane(boundaryFiber);
  } // TODO: Special case idle priority?


  var eventTime = requestEventTime();
  var root = markUpdateLaneFromFiberToRoot(boundaryFiber, retryLane);

  if (root !== null) {
    markRootUpdated(root, retryLane, eventTime);
    ensureRootIsScheduled(root, eventTime);
    schedulePendingInteractions(root, retryLane);
  }
}
function resolveRetryWakeable(boundaryFiber, wakeable) {
  var retryLane = NoLane; // Default

  var retryCache;

  {
    retryCache = boundaryFiber.stateNode;
  }

  if (retryCache !== null) {
    // The wakeable resolved, so we no longer need to memoize, because it will
    // never be thrown again.
    retryCache.delete(wakeable);
  }

  retryTimedOutBoundary(boundaryFiber, retryLane);
} // Computes the next Just Noticeable Difference (JND) boundary.
// The theory is that a person can't tell the difference between small differences in time.
// Therefore, if we wait a bit longer than necessary that won't translate to a noticeable
// difference in the experience. However, waiting for longer might mean that we can avoid
// showing an intermediate loading state. The longer we have already waited, the harder it
// is to tell small differences in time. Therefore, the longer we've already waited,
// the longer we can wait additionally. At some point we have to give up though.
// We pick a train model where the next boundary commits at a consistent schedule.
// These particular numbers are vague estimates. We expect to adjust them based on research.

function jnd(timeElapsed) {
  return timeElapsed < 120 ? 120 : timeElapsed < 480 ? 480 : timeElapsed < 1080 ? 1080 : timeElapsed < 1920 ? 1920 : timeElapsed < 3000 ? 3000 : timeElapsed < 4320 ? 4320 : ceil(timeElapsed / 1960) * 1960;
}

function checkForNestedUpdates() {
  if (nestedUpdateCount > NESTED_UPDATE_LIMIT) {
    nestedUpdateCount = 0;
    rootWithNestedUpdates = null;

    {
      {
        throw Error( "Maximum update depth exceeded. This can happen when a component repeatedly calls setState inside componentWillUpdate or componentDidUpdate. React limits the number of nested updates to prevent infinite loops." );
      }
    }
  }

  {
    if (nestedPassiveUpdateCount > NESTED_PASSIVE_UPDATE_LIMIT) {
      nestedPassiveUpdateCount = 0;

      error('Maximum update depth exceeded. This can happen when a component ' + "calls setState inside useEffect, but useEffect either doesn't " + 'have a dependency array, or one of the dependencies changes on ' + 'every render.');
    }
  }
}

function flushRenderPhaseStrictModeWarningsInDEV() {
  {
    ReactStrictModeWarnings.flushLegacyContextWarning();

    {
      ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings();
    }
  }
}

var didWarnStateUpdateForNotYetMountedComponent = null;

function warnAboutUpdateOnNotYetMountedFiberInDEV(fiber) {
  {
    if ((executionContext & RenderContext) !== NoContext) {
      // We let the other warning about render phase updates deal with this one.
      return;
    }

    if (!(fiber.mode & (BlockingMode | ConcurrentMode))) {
      return;
    }

    var tag = fiber.tag;

    if (tag !== IndeterminateComponent && tag !== HostRoot && tag !== ClassComponent && tag !== FunctionComponent && tag !== ForwardRef && tag !== MemoComponent && tag !== SimpleMemoComponent && tag !== Block) {
      // Only warn for user-defined components, not internal ones like Suspense.
      return;
    } // We show the whole stack but dedupe on the top component's name because
    // the problematic code almost always lies inside that component.


    var componentName = getComponentName(fiber.type) || 'ReactComponent';

    if (didWarnStateUpdateForNotYetMountedComponent !== null) {
      if (didWarnStateUpdateForNotYetMountedComponent.has(componentName)) {
        return;
      }

      didWarnStateUpdateForNotYetMountedComponent.add(componentName);
    } else {
      didWarnStateUpdateForNotYetMountedComponent = new Set([componentName]);
    }

    var previousFiber = current;

    try {
      setCurrentFiber(fiber);

      error("Can't perform a React state update on a component that hasn't mounted yet. " + 'This indicates that you have a side-effect in your render function that ' + 'asynchronously later calls tries to update the component. Move this work to ' + 'useEffect instead.');
    } finally {
      if (previousFiber) {
        setCurrentFiber(fiber);
      } else {
        resetCurrentFiber();
      }
    }
  }
}

var didWarnStateUpdateForUnmountedComponent = null;

function warnAboutUpdateOnUnmountedFiberInDEV(fiber) {
  {
    var tag = fiber.tag;

    if (tag !== HostRoot && tag !== ClassComponent && tag !== FunctionComponent && tag !== ForwardRef && tag !== MemoComponent && tag !== SimpleMemoComponent && tag !== Block) {
      // Only warn for user-defined components, not internal ones like Suspense.
      return;
    } // If there are pending passive effects unmounts for this Fiber,
    // we can assume that they would have prevented this update.


    if ((fiber.flags & PassiveUnmountPendingDev) !== NoFlags) {
      return;
    } // We show the whole stack but dedupe on the top component's name because
    // the problematic code almost always lies inside that component.


    var componentName = getComponentName(fiber.type) || 'ReactComponent';

    if (didWarnStateUpdateForUnmountedComponent !== null) {
      if (didWarnStateUpdateForUnmountedComponent.has(componentName)) {
        return;
      }

      didWarnStateUpdateForUnmountedComponent.add(componentName);
    } else {
      didWarnStateUpdateForUnmountedComponent = new Set([componentName]);
    }

    if (isFlushingPassiveEffects) ; else {
      var previousFiber = current;

      try {
        setCurrentFiber(fiber);

        error("Can't perform a React state update on an unmounted component. This " + 'is a no-op, but it indicates a memory leak in your application. To ' + 'fix, cancel all subscriptions and asynchronous tasks in %s.', tag === ClassComponent ? 'the componentWillUnmount method' : 'a useEffect cleanup function');
      } finally {
        if (previousFiber) {
          setCurrentFiber(fiber);
        } else {
          resetCurrentFiber();
        }
      }
    }
  }
}

var beginWork$1;

{
  var dummyFiber = null;

  beginWork$1 = function (current, unitOfWork, lanes) {
    // If a component throws an error, we replay it again in a synchronously
    // dispatched event, so that the debugger will treat it as an uncaught
    // error See ReactErrorUtils for more information.
    // Before entering the begin phase, copy the work-in-progress onto a dummy
    // fiber. If beginWork throws, we'll use this to reset the state.
    var originalWorkInProgressCopy = assignFiberPropertiesInDEV(dummyFiber, unitOfWork);

    try {
      return beginWork(current, unitOfWork, lanes);
    } catch (originalError) {
      if (originalError !== null && typeof originalError === 'object' && typeof originalError.then === 'function') {
        // Don't replay promises. Treat everything else like an error.
        throw originalError;
      } // Keep this code in sync with handleError; any changes here must have
      // corresponding changes there.


      resetContextDependencies();
      resetHooksAfterThrow(); // Don't reset current debug fiber, since we're about to work on the
      // same fiber again.
      // Unwind the failed stack frame

      unwindInterruptedWork(unitOfWork); // Restore the original properties of the fiber.

      assignFiberPropertiesInDEV(unitOfWork, originalWorkInProgressCopy);

      if ( unitOfWork.mode & ProfileMode) {
        // Reset the profiler timer.
        startProfilerTimer(unitOfWork);
      } // Run beginWork again.


      invokeGuardedCallback(null, beginWork, null, current, unitOfWork, lanes);

      if (hasCaughtError()) {
        var replayError = clearCaughtError(); // `invokeGuardedCallback` sometimes sets an expando `_suppressLogging`.
        // Rethrow this error instead of the original one.

        throw replayError;
      } else {
        // This branch is reachable if the render phase is impure.
        throw originalError;
      }
    }
  };
}

var didWarnAboutUpdateInRender = false;
var didWarnAboutUpdateInRenderForAnotherComponent;

{
  didWarnAboutUpdateInRenderForAnotherComponent = new Set();
}

function warnAboutRenderPhaseUpdatesInDEV(fiber) {
  {
    if (isRendering && (executionContext & RenderContext) !== NoContext && !getIsUpdatingOpaqueValueInRenderPhaseInDEV()) {
      switch (fiber.tag) {
        case FunctionComponent:
        case ForwardRef:
        case SimpleMemoComponent:
          {
            var renderingComponentName = workInProgress && getComponentName(workInProgress.type) || 'Unknown'; // Dedupe by the rendering component because it's the one that needs to be fixed.

            var dedupeKey = renderingComponentName;

            if (!didWarnAboutUpdateInRenderForAnotherComponent.has(dedupeKey)) {
              didWarnAboutUpdateInRenderForAnotherComponent.add(dedupeKey);
              var setStateComponentName = getComponentName(fiber.type) || 'Unknown';

              error('Cannot update a component (`%s`) while rendering a ' + 'different component (`%s`). To locate the bad setState() call inside `%s`, ' + 'follow the stack trace as described in https://reactjs.org/link/setstate-in-render', setStateComponentName, renderingComponentName, renderingComponentName);
            }

            break;
          }

        case ClassComponent:
          {
            if (!didWarnAboutUpdateInRender) {
              error('Cannot update during an existing state transition (such as ' + 'within `render`). Render methods should be a pure ' + 'function of props and state.');

              didWarnAboutUpdateInRender = true;
            }

            break;
          }
      }
    }
  }
} // a 'shared' variable that changes when act() opens/closes in tests.


var IsThisRendererActing = {
  current: false
};
function warnIfNotScopedWithMatchingAct(fiber) {
  {
    if ( IsSomeRendererActing.current === true && IsThisRendererActing.current !== true) {
      var previousFiber = current;

      try {
        setCurrentFiber(fiber);

        error("It looks like you're using the wrong act() around your test interactions.\n" + 'Be sure to use the matching version of act() corresponding to your renderer:\n\n' + '// for react-dom:\n' + // Break up imports to avoid accidentally parsing them as dependencies.
        'import {act} fr' + "om 'react-dom/test-utils';\n" + '// ...\n' + 'act(() => ...);\n\n' + '// for react-test-renderer:\n' + // Break up imports to avoid accidentally parsing them as dependencies.
        'import TestRenderer fr' + "om react-test-renderer';\n" + 'const {act} = TestRenderer;\n' + '// ...\n' + 'act(() => ...);');
      } finally {
        if (previousFiber) {
          setCurrentFiber(fiber);
        } else {
          resetCurrentFiber();
        }
      }
    }
  }
}
function warnIfNotCurrentlyActingEffectsInDEV(fiber) {
  {
    if ( (fiber.mode & StrictMode) !== NoMode && IsSomeRendererActing.current === false && IsThisRendererActing.current === false) {
      error('An update to %s ran an effect, but was not wrapped in act(...).\n\n' + 'When testing, code that causes React state updates should be ' + 'wrapped into act(...):\n\n' + 'act(() => {\n' + '  /* fire events that update state */\n' + '});\n' + '/* assert on the output */\n\n' + "This ensures that you're testing the behavior the user would see " + 'in the browser.' + ' Learn more at https://reactjs.org/link/wrap-tests-with-act', getComponentName(fiber.type));
    }
  }
}

function warnIfNotCurrentlyActingUpdatesInDEV(fiber) {
  {
    if ( executionContext === NoContext && IsSomeRendererActing.current === false && IsThisRendererActing.current === false) {
      var previousFiber = current;

      try {
        setCurrentFiber(fiber);

        error('An update to %s inside a test was not wrapped in act(...).\n\n' + 'When testing, code that causes React state updates should be ' + 'wrapped into act(...):\n\n' + 'act(() => {\n' + '  /* fire events that update state */\n' + '});\n' + '/* assert on the output */\n\n' + "This ensures that you're testing the behavior the user would see " + 'in the browser.' + ' Learn more at https://reactjs.org/link/wrap-tests-with-act', getComponentName(fiber.type));
      } finally {
        if (previousFiber) {
          setCurrentFiber(fiber);
        } else {
          resetCurrentFiber();
        }
      }
    }
  }
}

var warnIfNotCurrentlyActingUpdatesInDev = warnIfNotCurrentlyActingUpdatesInDEV; // In tests, we want to enforce a mocked scheduler.

var didWarnAboutUnmockedScheduler = false; // TODO Before we release concurrent mode, revisit this and decide whether a mocked
// scheduler is the actual recommendation. The alternative could be a testing build,
// a new lib, or whatever; we dunno just yet. This message is for early adopters
// to get their tests right.

function warnIfUnmockedScheduler(fiber) {
  {
    if (didWarnAboutUnmockedScheduler === false && Scheduler.unstable_flushAllWithoutAsserting === undefined) {
      if (fiber.mode & BlockingMode || fiber.mode & ConcurrentMode) {
        didWarnAboutUnmockedScheduler = true;

        error('In Concurrent or Sync modes, the "scheduler" module needs to be mocked ' + 'to guarantee consistent behaviour across tests and browsers. ' + 'For example, with jest: \n' + // Break up requires to avoid accidentally parsing them as dependencies.
        "jest.mock('scheduler', () => require" + "('scheduler/unstable_mock'));\n\n" + 'For more info, visit https://reactjs.org/link/mock-scheduler');
      }
    }
  }
}

function computeThreadID(root, lane) {
  // Interaction threads are unique per root and expiration time.
  // NOTE: Intentionally unsound cast. All that matters is that it's a number
  // and it represents a batch of work. Could make a helper function instead,
  // but meh this is fine for now.
  return lane * 1000 + root.interactionThreadID;
}

function markSpawnedWork(lane) {

  if (spawnedWorkDuringRender === null) {
    spawnedWorkDuringRender = [lane];
  } else {
    spawnedWorkDuringRender.push(lane);
  }
}

function scheduleInteractions(root, lane, interactions) {

  if (interactions.size > 0) {
    var pendingInteractionMap = root.pendingInteractionMap;
    var pendingInteractions = pendingInteractionMap.get(lane);

    if (pendingInteractions != null) {
      interactions.forEach(function (interaction) {
        if (!pendingInteractions.has(interaction)) {
          // Update the pending async work count for previously unscheduled interaction.
          interaction.__count++;
        }

        pendingInteractions.add(interaction);
      });
    } else {
      pendingInteractionMap.set(lane, new Set(interactions)); // Update the pending async work count for the current interactions.

      interactions.forEach(function (interaction) {
        interaction.__count++;
      });
    }

    var subscriber = tracing.__subscriberRef.current;

    if (subscriber !== null) {
      var threadID = computeThreadID(root, lane);
      subscriber.onWorkScheduled(interactions, threadID);
    }
  }
}

function schedulePendingInteractions(root, lane) {

  scheduleInteractions(root, lane, tracing.__interactionsRef.current);
}

function startWorkOnPendingInteractions(root, lanes) {
  // we can accurately attribute time spent working on it, And so that cascading
  // work triggered during the render phase will be associated with it.


  var interactions = new Set();
  root.pendingInteractionMap.forEach(function (scheduledInteractions, scheduledLane) {
    if (includesSomeLane(lanes, scheduledLane)) {
      scheduledInteractions.forEach(function (interaction) {
        return interactions.add(interaction);
      });
    }
  }); // Store the current set of interactions on the FiberRoot for a few reasons:
  // We can re-use it in hot functions like performConcurrentWorkOnRoot()
  // without having to recalculate it. We will also use it in commitWork() to
  // pass to any Profiler onRender() hooks. This also provides DevTools with a
  // way to access it when the onCommitRoot() hook is called.

  root.memoizedInteractions = interactions;

  if (interactions.size > 0) {
    var subscriber = tracing.__subscriberRef.current;

    if (subscriber !== null) {
      var threadID = computeThreadID(root, lanes);

      try {
        subscriber.onWorkStarted(interactions, threadID);
      } catch (error) {
        // If the subscriber throws, rethrow it in a separate task
        scheduleCallback(ImmediatePriority$1, function () {
          throw error;
        });
      }
    }
  }
}

function finishPendingInteractions(root, committedLanes) {

  var remainingLanesAfterCommit = root.pendingLanes;
  var subscriber;

  try {
    subscriber = tracing.__subscriberRef.current;

    if (subscriber !== null && root.memoizedInteractions.size > 0) {
      // FIXME: More than one lane can finish in a single commit.
      var threadID = computeThreadID(root, committedLanes);
      subscriber.onWorkStopped(root.memoizedInteractions, threadID);
    }
  } catch (error) {
    // If the subscriber throws, rethrow it in a separate task
    scheduleCallback(ImmediatePriority$1, function () {
      throw error;
    });
  } finally {
    // Clear completed interactions from the pending Map.
    // Unless the render was suspended or cascading work was scheduled,
    // In which case leave pending interactions until the subsequent render.
    var pendingInteractionMap = root.pendingInteractionMap;
    pendingInteractionMap.forEach(function (scheduledInteractions, lane) {
      // Only decrement the pending interaction count if we're done.
      // If there's still work at the current priority,
      // That indicates that we are waiting for suspense data.
      if (!includesSomeLane(remainingLanesAfterCommit, lane)) {
        pendingInteractionMap.delete(lane);
        scheduledInteractions.forEach(function (interaction) {
          interaction.__count--;

          if (subscriber !== null && interaction.__count === 0) {
            try {
              subscriber.onInteractionScheduledWorkCompleted(interaction);
            } catch (error) {
              // If the subscriber throws, rethrow it in a separate task
              scheduleCallback(ImmediatePriority$1, function () {
                throw error;
              });
            }
          }
        });
      }
    });
  }
} // `act` testing API

function shouldForceFlushFallbacksInDEV() {
  // Never force flush in production. This function should get stripped out.
  return  actingUpdatesScopeDepth > 0;
}
// so we can tell if any async act() calls try to run in parallel.


var actingUpdatesScopeDepth = 0;

function detachFiberAfterEffects(fiber) {
  fiber.sibling = null;
  fiber.stateNode = null;
}

var resolveFamily = null; // $FlowFixMe Flow gets confused by a WeakSet feature check below.

var failedBoundaries = null;
var setRefreshHandler = function (handler) {
  {
    resolveFamily = handler;
  }
};
function resolveFunctionForHotReloading(type) {
  {
    if (resolveFamily === null) {
      // Hot reloading is disabled.
      return type;
    }

    var family = resolveFamily(type);

    if (family === undefined) {
      return type;
    } // Use the latest known implementation.


    return family.current;
  }
}
function resolveClassForHotReloading(type) {
  // No implementation differences.
  return resolveFunctionForHotReloading(type);
}
function resolveForwardRefForHotReloading(type) {
  {
    if (resolveFamily === null) {
      // Hot reloading is disabled.
      return type;
    }

    var family = resolveFamily(type);

    if (family === undefined) {
      // Check if we're dealing with a real forwardRef. Don't want to crash early.
      if (type !== null && type !== undefined && typeof type.render === 'function') {
        // ForwardRef is special because its resolved .type is an object,
        // but it's possible that we only have its inner render function in the map.
        // If that inner render function is different, we'll build a new forwardRef type.
        var currentRender = resolveFunctionForHotReloading(type.render);

        if (type.render !== currentRender) {
          var syntheticType = {
            $$typeof: REACT_FORWARD_REF_TYPE,
            render: currentRender
          };

          if (type.displayName !== undefined) {
            syntheticType.displayName = type.displayName;
          }

          return syntheticType;
        }
      }

      return type;
    } // Use the latest known implementation.


    return family.current;
  }
}
function isCompatibleFamilyForHotReloading(fiber, element) {
  {
    if (resolveFamily === null) {
      // Hot reloading is disabled.
      return false;
    }

    var prevType = fiber.elementType;
    var nextType = element.type; // If we got here, we know types aren't === equal.

    var needsCompareFamilies = false;
    var $$typeofNextType = typeof nextType === 'object' && nextType !== null ? nextType.$$typeof : null;

    switch (fiber.tag) {
      case ClassComponent:
        {
          if (typeof nextType === 'function') {
            needsCompareFamilies = true;
          }

          break;
        }

      case FunctionComponent:
        {
          if (typeof nextType === 'function') {
            needsCompareFamilies = true;
          } else if ($$typeofNextType === REACT_LAZY_TYPE) {
            // We don't know the inner type yet.
            // We're going to assume that the lazy inner type is stable,
            // and so it is sufficient to avoid reconciling it away.
            // We're not going to unwrap or actually use the new lazy type.
            needsCompareFamilies = true;
          }

          break;
        }

      case ForwardRef:
        {
          if ($$typeofNextType === REACT_FORWARD_REF_TYPE) {
            needsCompareFamilies = true;
          } else if ($$typeofNextType === REACT_LAZY_TYPE) {
            needsCompareFamilies = true;
          }

          break;
        }

      case MemoComponent:
      case SimpleMemoComponent:
        {
          if ($$typeofNextType === REACT_MEMO_TYPE) {
            // TODO: if it was but can no longer be simple,
            // we shouldn't set this.
            needsCompareFamilies = true;
          } else if ($$typeofNextType === REACT_LAZY_TYPE) {
            needsCompareFamilies = true;
          }

          break;
        }

      default:
        return false;
    } // Check if both types have a family and it's the same one.


    if (needsCompareFamilies) {
      // Note: memo() and forwardRef() we'll compare outer rather than inner type.
      // This means both of them need to be registered to preserve state.
      // If we unwrapped and compared the inner types for wrappers instead,
      // then we would risk falsely saying two separate memo(Foo)
      // calls are equivalent because they wrap the same Foo function.
      var prevFamily = resolveFamily(prevType);

      if (prevFamily !== undefined && prevFamily === resolveFamily(nextType)) {
        return true;
      }
    }

    return false;
  }
}
function markFailedErrorBoundaryForHotReloading(fiber) {
  {
    if (resolveFamily === null) {
      // Hot reloading is disabled.
      return;
    }

    if (typeof WeakSet !== 'function') {
      return;
    }

    if (failedBoundaries === null) {
      failedBoundaries = new WeakSet();
    }

    failedBoundaries.add(fiber);
  }
}
var scheduleRefresh = function (root, update) {
  {
    if (resolveFamily === null) {
      // Hot reloading is disabled.
      return;
    }

    var staleFamilies = update.staleFamilies,
        updatedFamilies = update.updatedFamilies;
    flushPassiveEffects();
    flushSync(function () {
      scheduleFibersWithFamiliesRecursively(root.current, updatedFamilies, staleFamilies);
    });
  }
};
var scheduleRoot = function (root, element) {
  {
    if (root.context !== emptyContextObject) {
      // Super edge case: root has a legacy _renderSubtree context
      // but we don't know the parentComponent so we can't pass it.
      // Just ignore. We'll delete this with _renderSubtree code path later.
      return;
    }

    flushPassiveEffects();
    flushSync(function () {
      updateContainer(element, root, null, null);
    });
  }
};

function scheduleFibersWithFamiliesRecursively(fiber, updatedFamilies, staleFamilies) {
  {
    var alternate = fiber.alternate,
        child = fiber.child,
        sibling = fiber.sibling,
        tag = fiber.tag,
        type = fiber.type;
    var candidateType = null;

    switch (tag) {
      case FunctionComponent:
      case SimpleMemoComponent:
      case ClassComponent:
        candidateType = type;
        break;

      case ForwardRef:
        candidateType = type.render;
        break;
    }

    if (resolveFamily === null) {
      throw new Error('Expected resolveFamily to be set during hot reload.');
    }

    var needsRender = false;
    var needsRemount = false;

    if (candidateType !== null) {
      var family = resolveFamily(candidateType);

      if (family !== undefined) {
        if (staleFamilies.has(family)) {
          needsRemount = true;
        } else if (updatedFamilies.has(family)) {
          if (tag === ClassComponent) {
            needsRemount = true;
          } else {
            needsRender = true;
          }
        }
      }
    }

    if (failedBoundaries !== null) {
      if (failedBoundaries.has(fiber) || alternate !== null && failedBoundaries.has(alternate)) {
        needsRemount = true;
      }
    }

    if (needsRemount) {
      fiber._debugNeedsRemount = true;
    }

    if (needsRemount || needsRender) {
      scheduleUpdateOnFiber(fiber, SyncLane, NoTimestamp);
    }

    if (child !== null && !needsRemount) {
      scheduleFibersWithFamiliesRecursively(child, updatedFamilies, staleFamilies);
    }

    if (sibling !== null) {
      scheduleFibersWithFamiliesRecursively(sibling, updatedFamilies, staleFamilies);
    }
  }
}

var findHostInstancesForRefresh = function (root, families) {
  {
    var hostInstances = new Set();
    var types = new Set(families.map(function (family) {
      return family.current;
    }));
    findHostInstancesForMatchingFibersRecursively(root.current, types, hostInstances);
    return hostInstances;
  }
};

function findHostInstancesForMatchingFibersRecursively(fiber, types, hostInstances) {
  {
    var child = fiber.child,
        sibling = fiber.sibling,
        tag = fiber.tag,
        type = fiber.type;
    var candidateType = null;

    switch (tag) {
      case FunctionComponent:
      case SimpleMemoComponent:
      case ClassComponent:
        candidateType = type;
        break;

      case ForwardRef:
        candidateType = type.render;
        break;
    }

    var didMatch = false;

    if (candidateType !== null) {
      if (types.has(candidateType)) {
        didMatch = true;
      }
    }

    if (didMatch) {
      // We have a match. This only drills down to the closest host components.
      // There's no need to search deeper because for the purpose of giving
      // visual feedback, "flashing" outermost parent rectangles is sufficient.
      findHostInstancesForFiberShallowly(fiber, hostInstances);
    } else {
      // If there's no match, maybe there will be one further down in the child tree.
      if (child !== null) {
        findHostInstancesForMatchingFibersRecursively(child, types, hostInstances);
      }
    }

    if (sibling !== null) {
      findHostInstancesForMatchingFibersRecursively(sibling, types, hostInstances);
    }
  }
}

function findHostInstancesForFiberShallowly(fiber, hostInstances) {
  {
    var foundHostInstances = findChildHostInstancesForFiberShallowly(fiber, hostInstances);

    if (foundHostInstances) {
      return;
    } // If we didn't find any host children, fallback to closest host parent.


    var node = fiber;

    while (true) {
      switch (node.tag) {
        case HostComponent:
          hostInstances.add(node.stateNode);
          return;

        case HostPortal:
          hostInstances.add(node.stateNode.containerInfo);
          return;

        case HostRoot:
          hostInstances.add(node.stateNode.containerInfo);
          return;
      }

      if (node.return === null) {
        throw new Error('Expected to reach root first.');
      }

      node = node.return;
    }
  }
}

function findChildHostInstancesForFiberShallowly(fiber, hostInstances) {
  {
    var node = fiber;
    var foundHostInstances = false;

    while (true) {
      if (node.tag === HostComponent) {
        // We got a match.
        foundHostInstances = true;
        hostInstances.add(node.stateNode); // There may still be more, so keep searching.
      } else if (node.child !== null) {
        node.child.return = node;
        node = node.child;
        continue;
      }

      if (node === fiber) {
        return foundHostInstances;
      }

      while (node.sibling === null) {
        if (node.return === null || node.return === fiber) {
          return foundHostInstances;
        }

        node = node.return;
      }

      node.sibling.return = node.return;
      node = node.sibling;
    }
  }

  return false;
}

var hasBadMapPolyfill;

{
  hasBadMapPolyfill = false;

  try {
    var nonExtensibleObject = Object.preventExtensions({});
    /* eslint-disable no-new */

    new Map([[nonExtensibleObject, null]]);
    new Set([nonExtensibleObject]);
    /* eslint-enable no-new */
  } catch (e) {
    // TODO: Consider warning about bad polyfills
    hasBadMapPolyfill = true;
  }
}

var debugCounter = 1;

function FiberNode(tag, pendingProps, key, mode) {
  // Instance
  this.tag = tag;
  this.key = key;
  this.elementType = null;
  this.type = null;
  this.stateNode = null; // Fiber

  this.return = null;
  this.child = null;
  this.sibling = null;
  this.index = 0;
  this.ref = null;
  this.pendingProps = pendingProps;
  this.memoizedProps = null;
  this.updateQueue = null;
  this.memoizedState = null;
  this.dependencies = null;
  this.mode = mode; // Effects

  this.flags = NoFlags;
  this.nextEffect = null;
  this.firstEffect = null;
  this.lastEffect = null;
  this.lanes = NoLanes;
  this.childLanes = NoLanes;
  this.alternate = null;

  {
    // Note: The following is done to avoid a v8 performance cliff.
    //
    // Initializing the fields below to smis and later updating them with
    // double values will cause Fibers to end up having separate shapes.
    // This behavior/bug has something to do with Object.preventExtension().
    // Fortunately this only impacts DEV builds.
    // Unfortunately it makes React unusably slow for some applications.
    // To work around this, initialize the fields below with doubles.
    //
    // Learn more about this here:
    // https://github.com/facebook/react/issues/14365
    // https://bugs.chromium.org/p/v8/issues/detail?id=8538
    this.actualDuration = Number.NaN;
    this.actualStartTime = Number.NaN;
    this.selfBaseDuration = Number.NaN;
    this.treeBaseDuration = Number.NaN; // It's okay to replace the initial doubles with smis after initialization.
    // This won't trigger the performance cliff mentioned above,
    // and it simplifies other profiler code (including DevTools).

    this.actualDuration = 0;
    this.actualStartTime = -1;
    this.selfBaseDuration = 0;
    this.treeBaseDuration = 0;
  }

  {
    // This isn't directly used but is handy for debugging internals:
    this._debugID = debugCounter++;
    this._debugSource = null;
    this._debugOwner = null;
    this._debugNeedsRemount = false;
    this._debugHookTypes = null;

    if (!hasBadMapPolyfill && typeof Object.preventExtensions === 'function') {
      Object.preventExtensions(this);
    }
  }
} // This is a constructor function, rather than a POJO constructor, still
// please ensure we do the following:
// 1) Nobody should add any instance methods on this. Instance methods can be
//    more difficult to predict when they get optimized and they are almost
//    never inlined properly in static compilers.
// 2) Nobody should rely on `instanceof Fiber` for type testing. We should
//    always know when it is a fiber.
// 3) We might want to experiment with using numeric keys since they are easier
//    to optimize in a non-JIT environment.
// 4) We can easily go from a constructor to a createFiber object literal if that
//    is faster.
// 5) It should be easy to port this to a C struct and keep a C implementation
//    compatible.


var createFiber = function (tag, pendingProps, key, mode) {
  // $FlowFixMe: the shapes are exact here but Flow doesn't like constructors
  return new FiberNode(tag, pendingProps, key, mode);
};

function shouldConstruct$1(Component) {
  var prototype = Component.prototype;
  return !!(prototype && prototype.isReactComponent);
}

function isSimpleFunctionComponent(type) {
  return typeof type === 'function' && !shouldConstruct$1(type) && type.defaultProps === undefined;
}
function resolveLazyComponentTag(Component) {
  if (typeof Component === 'function') {
    return shouldConstruct$1(Component) ? ClassComponent : FunctionComponent;
  } else if (Component !== undefined && Component !== null) {
    var $$typeof = Component.$$typeof;

    if ($$typeof === REACT_FORWARD_REF_TYPE) {
      return ForwardRef;
    }

    if ($$typeof === REACT_MEMO_TYPE) {
      return MemoComponent;
    }
  }

  return IndeterminateComponent;
} // This is used to create an alternate fiber to do work on.

function createWorkInProgress(current, pendingProps) {
  var workInProgress = current.alternate;

  if (workInProgress === null) {
    // We use a double buffering pooling technique because we know that we'll
    // only ever need at most two versions of a tree. We pool the "other" unused
    // node that we're free to reuse. This is lazily created to avoid allocating
    // extra objects for things that are never updated. It also allow us to
    // reclaim the extra memory if needed.
    workInProgress = createFiber(current.tag, pendingProps, current.key, current.mode);
    workInProgress.elementType = current.elementType;
    workInProgress.type = current.type;
    workInProgress.stateNode = current.stateNode;

    {
      // DEV-only fields
      workInProgress._debugID = current._debugID;
      workInProgress._debugSource = current._debugSource;
      workInProgress._debugOwner = current._debugOwner;
      workInProgress._debugHookTypes = current._debugHookTypes;
    }

    workInProgress.alternate = current;
    current.alternate = workInProgress;
  } else {
    workInProgress.pendingProps = pendingProps; // Needed because Blocks store data on type.

    workInProgress.type = current.type; // We already have an alternate.
    // Reset the effect tag.

    workInProgress.flags = NoFlags; // The effect list is no longer valid.

    workInProgress.nextEffect = null;
    workInProgress.firstEffect = null;
    workInProgress.lastEffect = null;

    {
      // We intentionally reset, rather than copy, actualDuration & actualStartTime.
      // This prevents time from endlessly accumulating in new commits.
      // This has the downside of resetting values for different priority renders,
      // But works for yielding (the common case) and should support resuming.
      workInProgress.actualDuration = 0;
      workInProgress.actualStartTime = -1;
    }
  }

  workInProgress.childLanes = current.childLanes;
  workInProgress.lanes = current.lanes;
  workInProgress.child = current.child;
  workInProgress.memoizedProps = current.memoizedProps;
  workInProgress.memoizedState = current.memoizedState;
  workInProgress.updateQueue = current.updateQueue; // Clone the dependencies object. This is mutated during the render phase, so
  // it cannot be shared with the current fiber.

  var currentDependencies = current.dependencies;
  workInProgress.dependencies = currentDependencies === null ? null : {
    lanes: currentDependencies.lanes,
    firstContext: currentDependencies.firstContext
  }; // These will be overridden during the parent's reconciliation

  workInProgress.sibling = current.sibling;
  workInProgress.index = current.index;
  workInProgress.ref = current.ref;

  {
    workInProgress.selfBaseDuration = current.selfBaseDuration;
    workInProgress.treeBaseDuration = current.treeBaseDuration;
  }

  {
    workInProgress._debugNeedsRemount = current._debugNeedsRemount;

    switch (workInProgress.tag) {
      case IndeterminateComponent:
      case FunctionComponent:
      case SimpleMemoComponent:
        workInProgress.type = resolveFunctionForHotReloading(current.type);
        break;

      case ClassComponent:
        workInProgress.type = resolveClassForHotReloading(current.type);
        break;

      case ForwardRef:
        workInProgress.type = resolveForwardRefForHotReloading(current.type);
        break;
    }
  }

  return workInProgress;
} // Used to reuse a Fiber for a second pass.

function resetWorkInProgress(workInProgress, renderLanes) {
  // This resets the Fiber to what createFiber or createWorkInProgress would
  // have set the values to before during the first pass. Ideally this wouldn't
  // be necessary but unfortunately many code paths reads from the workInProgress
  // when they should be reading from current and writing to workInProgress.
  // We assume pendingProps, index, key, ref, return are still untouched to
  // avoid doing another reconciliation.
  // Reset the effect tag but keep any Placement tags, since that's something
  // that child fiber is setting, not the reconciliation.
  workInProgress.flags &= Placement; // The effect list is no longer valid.

  workInProgress.nextEffect = null;
  workInProgress.firstEffect = null;
  workInProgress.lastEffect = null;
  var current = workInProgress.alternate;

  if (current === null) {
    // Reset to createFiber's initial values.
    workInProgress.childLanes = NoLanes;
    workInProgress.lanes = renderLanes;
    workInProgress.child = null;
    workInProgress.memoizedProps = null;
    workInProgress.memoizedState = null;
    workInProgress.updateQueue = null;
    workInProgress.dependencies = null;
    workInProgress.stateNode = null;

    {
      // Note: We don't reset the actualTime counts. It's useful to accumulate
      // actual time across multiple render passes.
      workInProgress.selfBaseDuration = 0;
      workInProgress.treeBaseDuration = 0;
    }
  } else {
    // Reset to the cloned values that createWorkInProgress would've.
    workInProgress.childLanes = current.childLanes;
    workInProgress.lanes = current.lanes;
    workInProgress.child = current.child;
    workInProgress.memoizedProps = current.memoizedProps;
    workInProgress.memoizedState = current.memoizedState;
    workInProgress.updateQueue = current.updateQueue; // Needed because Blocks store data on type.

    workInProgress.type = current.type; // Clone the dependencies object. This is mutated during the render phase, so
    // it cannot be shared with the current fiber.

    var currentDependencies = current.dependencies;
    workInProgress.dependencies = currentDependencies === null ? null : {
      lanes: currentDependencies.lanes,
      firstContext: currentDependencies.firstContext
    };

    {
      // Note: We don't reset the actualTime counts. It's useful to accumulate
      // actual time across multiple render passes.
      workInProgress.selfBaseDuration = current.selfBaseDuration;
      workInProgress.treeBaseDuration = current.treeBaseDuration;
    }
  }

  return workInProgress;
}
function createHostRootFiber(tag) {
  var mode;

  if (tag === ConcurrentRoot) {
    mode = ConcurrentMode | BlockingMode | StrictMode;
  } else if (tag === BlockingRoot) {
    mode = BlockingMode | StrictMode;
  } else {
    mode = NoMode;
  }

  if ( isDevToolsPresent) {
    // Always collect profile timings when DevTools are present.
    // This enables DevTools to start capturing timing at any point
    // Without some nodes in the tree having empty base times.
    mode |= ProfileMode;
  }

  return createFiber(HostRoot, null, null, mode);
}
function createFiberFromTypeAndProps(type, // React$ElementType
key, pendingProps, owner, mode, lanes) {
  var fiberTag = IndeterminateComponent; // The resolved type is set if we know what the final type will be. I.e. it's not lazy.

  var resolvedType = type;

  if (typeof type === 'function') {
    if (shouldConstruct$1(type)) {
      fiberTag = ClassComponent;

      {
        resolvedType = resolveClassForHotReloading(resolvedType);
      }
    } else {
      {
        resolvedType = resolveFunctionForHotReloading(resolvedType);
      }
    }
  } else if (typeof type === 'string') {
    fiberTag = HostComponent;
  } else {
    getTag: switch (type) {
      case REACT_FRAGMENT_TYPE:
        return createFiberFromFragment(pendingProps.children, mode, lanes, key);

      case REACT_DEBUG_TRACING_MODE_TYPE:
        fiberTag = Mode;
        mode |= DebugTracingMode;
        break;

      case REACT_STRICT_MODE_TYPE:
        fiberTag = Mode;
        mode |= StrictMode;
        break;

      case REACT_PROFILER_TYPE:
        return createFiberFromProfiler(pendingProps, mode, lanes, key);

      case REACT_SUSPENSE_TYPE:
        return createFiberFromSuspense(pendingProps, mode, lanes, key);

      case REACT_SUSPENSE_LIST_TYPE:
        return createFiberFromSuspenseList(pendingProps, mode, lanes, key);

      case REACT_OFFSCREEN_TYPE:
        return createFiberFromOffscreen(pendingProps, mode, lanes, key);

      case REACT_LEGACY_HIDDEN_TYPE:
        return createFiberFromLegacyHidden(pendingProps, mode, lanes, key);

      case REACT_SCOPE_TYPE:

      // eslint-disable-next-line no-fallthrough

      default:
        {
          if (typeof type === 'object' && type !== null) {
            switch (type.$$typeof) {
              case REACT_PROVIDER_TYPE:
                fiberTag = ContextProvider;
                break getTag;

              case REACT_CONTEXT_TYPE:
                // This is a consumer
                fiberTag = ContextConsumer;
                break getTag;

              case REACT_FORWARD_REF_TYPE:
                fiberTag = ForwardRef;

                {
                  resolvedType = resolveForwardRefForHotReloading(resolvedType);
                }

                break getTag;

              case REACT_MEMO_TYPE:
                fiberTag = MemoComponent;
                break getTag;

              case REACT_LAZY_TYPE:
                fiberTag = LazyComponent;
                resolvedType = null;
                break getTag;

              case REACT_BLOCK_TYPE:
                fiberTag = Block;
                break getTag;
            }
          }

          var info = '';

          {
            if (type === undefined || typeof type === 'object' && type !== null && Object.keys(type).length === 0) {
              info += ' You likely forgot to export your component from the file ' + "it's defined in, or you might have mixed up default and " + 'named imports.';
            }

            var ownerName = owner ? getComponentName(owner.type) : null;

            if (ownerName) {
              info += '\n\nCheck the render method of `' + ownerName + '`.';
            }
          }

          {
            {
              throw Error( "Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) but got: " + (type == null ? type : typeof type) + "." + info );
            }
          }
        }
    }
  }

  var fiber = createFiber(fiberTag, pendingProps, key, mode);
  fiber.elementType = type;
  fiber.type = resolvedType;
  fiber.lanes = lanes;

  {
    fiber._debugOwner = owner;
  }

  return fiber;
}
function createFiberFromElement(element, mode, lanes) {
  var owner = null;

  {
    owner = element._owner;
  }

  var type = element.type;
  var key = element.key;
  var pendingProps = element.props;
  var fiber = createFiberFromTypeAndProps(type, key, pendingProps, owner, mode, lanes);

  {
    fiber._debugSource = element._source;
    fiber._debugOwner = element._owner;
  }

  return fiber;
}
function createFiberFromFragment(elements, mode, lanes, key) {
  var fiber = createFiber(Fragment, elements, key, mode);
  fiber.lanes = lanes;
  return fiber;
}

function createFiberFromProfiler(pendingProps, mode, lanes, key) {
  {
    if (typeof pendingProps.id !== 'string') {
      error('Profiler must specify an "id" as a prop');
    }
  }

  var fiber = createFiber(Profiler, pendingProps, key, mode | ProfileMode); // TODO: The Profiler fiber shouldn't have a type. It has a tag.

  fiber.elementType = REACT_PROFILER_TYPE;
  fiber.type = REACT_PROFILER_TYPE;
  fiber.lanes = lanes;

  {
    fiber.stateNode = {
      effectDuration: 0,
      passiveEffectDuration: 0
    };
  }

  return fiber;
}

function createFiberFromSuspense(pendingProps, mode, lanes, key) {
  var fiber = createFiber(SuspenseComponent, pendingProps, key, mode); // TODO: The SuspenseComponent fiber shouldn't have a type. It has a tag.
  // This needs to be fixed in getComponentName so that it relies on the tag
  // instead.

  fiber.type = REACT_SUSPENSE_TYPE;
  fiber.elementType = REACT_SUSPENSE_TYPE;
  fiber.lanes = lanes;
  return fiber;
}
function createFiberFromSuspenseList(pendingProps, mode, lanes, key) {
  var fiber = createFiber(SuspenseListComponent, pendingProps, key, mode);

  {
    // TODO: The SuspenseListComponent fiber shouldn't have a type. It has a tag.
    // This needs to be fixed in getComponentName so that it relies on the tag
    // instead.
    fiber.type = REACT_SUSPENSE_LIST_TYPE;
  }

  fiber.elementType = REACT_SUSPENSE_LIST_TYPE;
  fiber.lanes = lanes;
  return fiber;
}
function createFiberFromOffscreen(pendingProps, mode, lanes, key) {
  var fiber = createFiber(OffscreenComponent, pendingProps, key, mode); // TODO: The OffscreenComponent fiber shouldn't have a type. It has a tag.
  // This needs to be fixed in getComponentName so that it relies on the tag
  // instead.

  {
    fiber.type = REACT_OFFSCREEN_TYPE;
  }

  fiber.elementType = REACT_OFFSCREEN_TYPE;
  fiber.lanes = lanes;
  return fiber;
}
function createFiberFromLegacyHidden(pendingProps, mode, lanes, key) {
  var fiber = createFiber(LegacyHiddenComponent, pendingProps, key, mode); // TODO: The LegacyHidden fiber shouldn't have a type. It has a tag.
  // This needs to be fixed in getComponentName so that it relies on the tag
  // instead.

  {
    fiber.type = REACT_LEGACY_HIDDEN_TYPE;
  }

  fiber.elementType = REACT_LEGACY_HIDDEN_TYPE;
  fiber.lanes = lanes;
  return fiber;
}
function createFiberFromText(content, mode, lanes) {
  var fiber = createFiber(HostText, content, null, mode);
  fiber.lanes = lanes;
  return fiber;
}
function createFiberFromHostInstanceForDeletion() {
  var fiber = createFiber(HostComponent, null, null, NoMode); // TODO: These should not need a type.

  fiber.elementType = 'DELETED';
  fiber.type = 'DELETED';
  return fiber;
}
function createFiberFromPortal(portal, mode, lanes) {
  var pendingProps = portal.children !== null ? portal.children : [];
  var fiber = createFiber(HostPortal, pendingProps, portal.key, mode);
  fiber.lanes = lanes;
  fiber.stateNode = {
    containerInfo: portal.containerInfo,
    pendingChildren: null,
    // Used by persistent updates
    implementation: portal.implementation
  };
  return fiber;
} // Used for stashing WIP properties to replay failed work in DEV.

function assignFiberPropertiesInDEV(target, source) {
  if (target === null) {
    // This Fiber's initial properties will always be overwritten.
    // We only use a Fiber to ensure the same hidden class so DEV isn't slow.
    target = createFiber(IndeterminateComponent, null, null, NoMode);
  } // This is intentionally written as a list of all properties.
  // We tried to use Object.assign() instead but this is called in
  // the hottest path, and Object.assign() was too slow:
  // https://github.com/facebook/react/issues/12502
  // This code is DEV-only so size is not a concern.


  target.tag = source.tag;
  target.key = source.key;
  target.elementType = source.elementType;
  target.type = source.type;
  target.stateNode = source.stateNode;
  target.return = source.return;
  target.child = source.child;
  target.sibling = source.sibling;
  target.index = source.index;
  target.ref = source.ref;
  target.pendingProps = source.pendingProps;
  target.memoizedProps = source.memoizedProps;
  target.updateQueue = source.updateQueue;
  target.memoizedState = source.memoizedState;
  target.dependencies = source.dependencies;
  target.mode = source.mode;
  target.flags = source.flags;
  target.nextEffect = source.nextEffect;
  target.firstEffect = source.firstEffect;
  target.lastEffect = source.lastEffect;
  target.lanes = source.lanes;
  target.childLanes = source.childLanes;
  target.alternate = source.alternate;

  {
    target.actualDuration = source.actualDuration;
    target.actualStartTime = source.actualStartTime;
    target.selfBaseDuration = source.selfBaseDuration;
    target.treeBaseDuration = source.treeBaseDuration;
  }

  target._debugID = source._debugID;
  target._debugSource = source._debugSource;
  target._debugOwner = source._debugOwner;
  target._debugNeedsRemount = source._debugNeedsRemount;
  target._debugHookTypes = source._debugHookTypes;
  return target;
}

function FiberRootNode(containerInfo, tag, hydrate) {
  this.tag = tag;
  this.containerInfo = containerInfo;
  this.pendingChildren = null;
  this.current = null;
  this.pingCache = null;
  this.finishedWork = null;
  this.timeoutHandle = noTimeout;
  this.context = null;
  this.pendingContext = null;
  this.hydrate = hydrate;
  this.callbackNode = null;
  this.callbackPriority = NoLanePriority;
  this.eventTimes = createLaneMap(NoLanes);
  this.expirationTimes = createLaneMap(NoTimestamp);
  this.pendingLanes = NoLanes;
  this.suspendedLanes = NoLanes;
  this.pingedLanes = NoLanes;
  this.expiredLanes = NoLanes;
  this.mutableReadLanes = NoLanes;
  this.finishedLanes = NoLanes;
  this.entangledLanes = NoLanes;
  this.entanglements = createLaneMap(NoLanes);

  {
    this.mutableSourceEagerHydrationData = null;
  }

  {
    this.interactionThreadID = tracing.unstable_getThreadID();
    this.memoizedInteractions = new Set();
    this.pendingInteractionMap = new Map();
  }

  {
    switch (tag) {
      case BlockingRoot:
        this._debugRootType = 'createBlockingRoot()';
        break;

      case ConcurrentRoot:
        this._debugRootType = 'createRoot()';
        break;

      case LegacyRoot:
        this._debugRootType = 'createLegacyRoot()';
        break;
    }
  }
}

function createFiberRoot(containerInfo, tag, hydrate, hydrationCallbacks) {
  var root = new FiberRootNode(containerInfo, tag, hydrate);
  // stateNode is any.


  var uninitializedFiber = createHostRootFiber(tag);
  root.current = uninitializedFiber;
  uninitializedFiber.stateNode = root;
  initializeUpdateQueue(uninitializedFiber);
  return root;
}

// This ensures that the version used for server rendering matches the one
// that is eventually read during hydration.
// If they don't match there's a potential tear and a full deopt render is required.

function registerMutableSourceForHydration(root, mutableSource) {
  var getVersion = mutableSource._getVersion;
  var version = getVersion(mutableSource._source); // TODO Clear this data once all pending hydration work is finished.
  // Retaining it forever may interfere with GC.

  if (root.mutableSourceEagerHydrationData == null) {
    root.mutableSourceEagerHydrationData = [mutableSource, version];
  } else {
    root.mutableSourceEagerHydrationData.push(mutableSource, version);
  }
}

function createPortal(children, containerInfo, // TODO: figure out the API for cross-renderer implementation.
implementation) {
  var key = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
  return {
    // This tag allow us to uniquely identify this as a React Portal
    $$typeof: REACT_PORTAL_TYPE,
    key: key == null ? null : '' + key,
    children: children,
    containerInfo: containerInfo,
    implementation: implementation
  };
}

var didWarnAboutNestedUpdates;
var didWarnAboutFindNodeInStrictMode;

{
  didWarnAboutNestedUpdates = false;
  didWarnAboutFindNodeInStrictMode = {};
}

function getContextForSubtree(parentComponent) {
  if (!parentComponent) {
    return emptyContextObject;
  }

  var fiber = get(parentComponent);
  var parentContext = findCurrentUnmaskedContext(fiber);

  if (fiber.tag === ClassComponent) {
    var Component = fiber.type;

    if (isContextProvider(Component)) {
      return processChildContext(fiber, Component, parentContext);
    }
  }

  return parentContext;
}

function findHostInstanceWithWarning(component, methodName) {
  {
    var fiber = get(component);

    if (fiber === undefined) {
      if (typeof component.render === 'function') {
        {
          {
            throw Error( "Unable to find node on an unmounted component." );
          }
        }
      } else {
        {
          {
            throw Error( "Argument appears to not be a ReactComponent. Keys: " + Object.keys(component) );
          }
        }
      }
    }

    var hostFiber = findCurrentHostFiber(fiber);

    if (hostFiber === null) {
      return null;
    }

    if (hostFiber.mode & StrictMode) {
      var componentName = getComponentName(fiber.type) || 'Component';

      if (!didWarnAboutFindNodeInStrictMode[componentName]) {
        didWarnAboutFindNodeInStrictMode[componentName] = true;
        var previousFiber = current;

        try {
          setCurrentFiber(hostFiber);

          if (fiber.mode & StrictMode) {
            error('%s is deprecated in StrictMode. ' + '%s was passed an instance of %s which is inside StrictMode. ' + 'Instead, add a ref directly to the element you want to reference. ' + 'Learn more about using refs safely here: ' + 'https://reactjs.org/link/strict-mode-find-node', methodName, methodName, componentName);
          } else {
            error('%s is deprecated in StrictMode. ' + '%s was passed an instance of %s which renders StrictMode children. ' + 'Instead, add a ref directly to the element you want to reference. ' + 'Learn more about using refs safely here: ' + 'https://reactjs.org/link/strict-mode-find-node', methodName, methodName, componentName);
          }
        } finally {
          // Ideally this should reset to previous but this shouldn't be called in
          // render and there's another warning for that anyway.
          if (previousFiber) {
            setCurrentFiber(previousFiber);
          } else {
            resetCurrentFiber();
          }
        }
      }
    }

    return hostFiber.stateNode;
  }
}

function createContainer(containerInfo, tag, hydrate, hydrationCallbacks) {
  return createFiberRoot(containerInfo, tag, hydrate);
}
function updateContainer(element, container, parentComponent, callback) {
  {
    onScheduleRoot(container, element);
  }

  var current$1 = container.current;
  var eventTime = requestEventTime();

  {
    // $FlowExpectedError - jest isn't a global, and isn't recognized outside of tests
    if ('undefined' !== typeof jest) {
      warnIfUnmockedScheduler(current$1);
      warnIfNotScopedWithMatchingAct(current$1);
    }
  }

  var lane = requestUpdateLane(current$1);

  var context = getContextForSubtree(parentComponent);

  if (container.context === null) {
    container.context = context;
  } else {
    container.pendingContext = context;
  }

  {
    if (isRendering && current !== null && !didWarnAboutNestedUpdates) {
      didWarnAboutNestedUpdates = true;

      error('Render methods should be a pure function of props and state; ' + 'triggering nested component updates from render is not allowed. ' + 'If necessary, trigger nested updates in componentDidUpdate.\n\n' + 'Check the render method of %s.', getComponentName(current.type) || 'Unknown');
    }
  }

  var update = createUpdate(eventTime, lane); // Caution: React DevTools currently depends on this property
  // being called "element".

  update.payload = {
    element: element
  };
  callback = callback === undefined ? null : callback;

  if (callback !== null) {
    {
      if (typeof callback !== 'function') {
        error('render(...): Expected the last optional `callback` argument to be a ' + 'function. Instead received: %s.', callback);
      }
    }

    update.callback = callback;
  }

  enqueueUpdate(current$1, update);
  scheduleUpdateOnFiber(current$1, lane, eventTime);
  return lane;
}
function getPublicRootInstance(container) {
  var containerFiber = container.current;

  if (!containerFiber.child) {
    return null;
  }

  switch (containerFiber.child.tag) {
    case HostComponent:
      return getPublicInstance(containerFiber.child.stateNode);

    default:
      return containerFiber.child.stateNode;
  }
}

function markRetryLaneImpl(fiber, retryLane) {
  var suspenseState = fiber.memoizedState;

  if (suspenseState !== null && suspenseState.dehydrated !== null) {
    suspenseState.retryLane = higherPriorityLane(suspenseState.retryLane, retryLane);
  }
} // Increases the priority of thennables when they resolve within this boundary.


function markRetryLaneIfNotHydrated(fiber, retryLane) {
  markRetryLaneImpl(fiber, retryLane);
  var alternate = fiber.alternate;

  if (alternate) {
    markRetryLaneImpl(alternate, retryLane);
  }
}

function attemptUserBlockingHydration$1(fiber) {
  if (fiber.tag !== SuspenseComponent) {
    // We ignore HostRoots here because we can't increase
    // their priority and they should not suspend on I/O,
    // since you have to wrap anything that might suspend in
    // Suspense.
    return;
  }

  var eventTime = requestEventTime();
  var lane = InputDiscreteHydrationLane;
  scheduleUpdateOnFiber(fiber, lane, eventTime);
  markRetryLaneIfNotHydrated(fiber, lane);
}
function attemptContinuousHydration$1(fiber) {
  if (fiber.tag !== SuspenseComponent) {
    // We ignore HostRoots here because we can't increase
    // their priority and they should not suspend on I/O,
    // since you have to wrap anything that might suspend in
    // Suspense.
    return;
  }

  var eventTime = requestEventTime();
  var lane = SelectiveHydrationLane;
  scheduleUpdateOnFiber(fiber, lane, eventTime);
  markRetryLaneIfNotHydrated(fiber, lane);
}
function attemptHydrationAtCurrentPriority$1(fiber) {
  if (fiber.tag !== SuspenseComponent) {
    // We ignore HostRoots here because we can't increase
    // their priority other than synchronously flush it.
    return;
  }

  var eventTime = requestEventTime();
  var lane = requestUpdateLane(fiber);
  scheduleUpdateOnFiber(fiber, lane, eventTime);
  markRetryLaneIfNotHydrated(fiber, lane);
}
function runWithPriority$2(priority, fn) {

  try {
    setCurrentUpdateLanePriority(priority);
    return fn();
  } finally {
  }
}
function findHostInstanceWithNoPortals(fiber) {
  var hostFiber = findCurrentHostFiberWithNoPortals(fiber);

  if (hostFiber === null) {
    return null;
  }

  if (hostFiber.tag === FundamentalComponent) {
    return hostFiber.stateNode.instance;
  }

  return hostFiber.stateNode;
}

var shouldSuspendImpl = function (fiber) {
  return false;
};

function shouldSuspend(fiber) {
  return shouldSuspendImpl(fiber);
}
var overrideHookState = null;
var overrideHookStateDeletePath = null;
var overrideHookStateRenamePath = null;
var overrideProps = null;
var overridePropsDeletePath = null;
var overridePropsRenamePath = null;
var scheduleUpdate = null;
var setSuspenseHandler = null;

{
  var copyWithDeleteImpl = function (obj, path, index) {
    var key = path[index];
    var updated = Array.isArray(obj) ? obj.slice() : _assign({}, obj);

    if (index + 1 === path.length) {
      if (Array.isArray(updated)) {
        updated.splice(key, 1);
      } else {
        delete updated[key];
      }

      return updated;
    } // $FlowFixMe number or string is fine here


    updated[key] = copyWithDeleteImpl(obj[key], path, index + 1);
    return updated;
  };

  var copyWithDelete = function (obj, path) {
    return copyWithDeleteImpl(obj, path, 0);
  };

  var copyWithRenameImpl = function (obj, oldPath, newPath, index) {
    var oldKey = oldPath[index];
    var updated = Array.isArray(obj) ? obj.slice() : _assign({}, obj);

    if (index + 1 === oldPath.length) {
      var newKey = newPath[index]; // $FlowFixMe number or string is fine here

      updated[newKey] = updated[oldKey];

      if (Array.isArray(updated)) {
        updated.splice(oldKey, 1);
      } else {
        delete updated[oldKey];
      }
    } else {
      // $FlowFixMe number or string is fine here
      updated[oldKey] = copyWithRenameImpl( // $FlowFixMe number or string is fine here
      obj[oldKey], oldPath, newPath, index + 1);
    }

    return updated;
  };

  var copyWithRename = function (obj, oldPath, newPath) {
    if (oldPath.length !== newPath.length) {
      warn('copyWithRename() expects paths of the same length');

      return;
    } else {
      for (var i = 0; i < newPath.length - 1; i++) {
        if (oldPath[i] !== newPath[i]) {
          warn('copyWithRename() expects paths to be the same except for the deepest key');

          return;
        }
      }
    }

    return copyWithRenameImpl(obj, oldPath, newPath, 0);
  };

  var copyWithSetImpl = function (obj, path, index, value) {
    if (index >= path.length) {
      return value;
    }

    var key = path[index];
    var updated = Array.isArray(obj) ? obj.slice() : _assign({}, obj); // $FlowFixMe number or string is fine here

    updated[key] = copyWithSetImpl(obj[key], path, index + 1, value);
    return updated;
  };

  var copyWithSet = function (obj, path, value) {
    return copyWithSetImpl(obj, path, 0, value);
  };

  var findHook = function (fiber, id) {
    // For now, the "id" of stateful hooks is just the stateful hook index.
    // This may change in the future with e.g. nested hooks.
    var currentHook = fiber.memoizedState;

    while (currentHook !== null && id > 0) {
      currentHook = currentHook.next;
      id--;
    }

    return currentHook;
  }; // Support DevTools editable values for useState and useReducer.


  overrideHookState = function (fiber, id, path, value) {
    var hook = findHook(fiber, id);

    if (hook !== null) {
      var newState = copyWithSet(hook.memoizedState, path, value);
      hook.memoizedState = newState;
      hook.baseState = newState; // We aren't actually adding an update to the queue,
      // because there is no update we can add for useReducer hooks that won't trigger an error.
      // (There's no appropriate action type for DevTools overrides.)
      // As a result though, React will see the scheduled update as a noop and bailout.
      // Shallow cloning props works as a workaround for now to bypass the bailout check.

      fiber.memoizedProps = _assign({}, fiber.memoizedProps);
      scheduleUpdateOnFiber(fiber, SyncLane, NoTimestamp);
    }
  };

  overrideHookStateDeletePath = function (fiber, id, path) {
    var hook = findHook(fiber, id);

    if (hook !== null) {
      var newState = copyWithDelete(hook.memoizedState, path);
      hook.memoizedState = newState;
      hook.baseState = newState; // We aren't actually adding an update to the queue,
      // because there is no update we can add for useReducer hooks that won't trigger an error.
      // (There's no appropriate action type for DevTools overrides.)
      // As a result though, React will see the scheduled update as a noop and bailout.
      // Shallow cloning props works as a workaround for now to bypass the bailout check.

      fiber.memoizedProps = _assign({}, fiber.memoizedProps);
      scheduleUpdateOnFiber(fiber, SyncLane, NoTimestamp);
    }
  };

  overrideHookStateRenamePath = function (fiber, id, oldPath, newPath) {
    var hook = findHook(fiber, id);

    if (hook !== null) {
      var newState = copyWithRename(hook.memoizedState, oldPath, newPath);
      hook.memoizedState = newState;
      hook.baseState = newState; // We aren't actually adding an update to the queue,
      // because there is no update we can add for useReducer hooks that won't trigger an error.
      // (There's no appropriate action type for DevTools overrides.)
      // As a result though, React will see the scheduled update as a noop and bailout.
      // Shallow cloning props works as a workaround for now to bypass the bailout check.

      fiber.memoizedProps = _assign({}, fiber.memoizedProps);
      scheduleUpdateOnFiber(fiber, SyncLane, NoTimestamp);
    }
  }; // Support DevTools props for function components, forwardRef, memo, host components, etc.


  overrideProps = function (fiber, path, value) {
    fiber.pendingProps = copyWithSet(fiber.memoizedProps, path, value);

    if (fiber.alternate) {
      fiber.alternate.pendingProps = fiber.pendingProps;
    }

    scheduleUpdateOnFiber(fiber, SyncLane, NoTimestamp);
  };

  overridePropsDeletePath = function (fiber, path) {
    fiber.pendingProps = copyWithDelete(fiber.memoizedProps, path);

    if (fiber.alternate) {
      fiber.alternate.pendingProps = fiber.pendingProps;
    }

    scheduleUpdateOnFiber(fiber, SyncLane, NoTimestamp);
  };

  overridePropsRenamePath = function (fiber, oldPath, newPath) {
    fiber.pendingProps = copyWithRename(fiber.memoizedProps, oldPath, newPath);

    if (fiber.alternate) {
      fiber.alternate.pendingProps = fiber.pendingProps;
    }

    scheduleUpdateOnFiber(fiber, SyncLane, NoTimestamp);
  };

  scheduleUpdate = function (fiber) {
    scheduleUpdateOnFiber(fiber, SyncLane, NoTimestamp);
  };

  setSuspenseHandler = function (newShouldSuspendImpl) {
    shouldSuspendImpl = newShouldSuspendImpl;
  };
}

function findHostInstanceByFiber(fiber) {
  var hostFiber = findCurrentHostFiber(fiber);

  if (hostFiber === null) {
    return null;
  }

  return hostFiber.stateNode;
}

function emptyFindFiberByHostInstance(instance) {
  return null;
}

function getCurrentFiberForDevTools() {
  return current;
}

function injectIntoDevTools(devToolsConfig) {
  var findFiberByHostInstance = devToolsConfig.findFiberByHostInstance;
  var ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;
  return injectInternals({
    bundleType: devToolsConfig.bundleType,
    version: devToolsConfig.version,
    rendererPackageName: devToolsConfig.rendererPackageName,
    rendererConfig: devToolsConfig.rendererConfig,
    overrideHookState: overrideHookState,
    overrideHookStateDeletePath: overrideHookStateDeletePath,
    overrideHookStateRenamePath: overrideHookStateRenamePath,
    overrideProps: overrideProps,
    overridePropsDeletePath: overridePropsDeletePath,
    overridePropsRenamePath: overridePropsRenamePath,
    setSuspenseHandler: setSuspenseHandler,
    scheduleUpdate: scheduleUpdate,
    currentDispatcherRef: ReactCurrentDispatcher,
    findHostInstanceByFiber: findHostInstanceByFiber,
    findFiberByHostInstance: findFiberByHostInstance || emptyFindFiberByHostInstance,
    // React Refresh
    findHostInstancesForRefresh:  findHostInstancesForRefresh ,
    scheduleRefresh:  scheduleRefresh ,
    scheduleRoot:  scheduleRoot ,
    setRefreshHandler:  setRefreshHandler ,
    // Enables DevTools to append owner stacks to error messages in DEV mode.
    getCurrentFiber:  getCurrentFiberForDevTools 
  });
}

function ReactDOMRoot(container, options) {
  this._internalRoot = createRootImpl(container, ConcurrentRoot, options);
}

function ReactDOMBlockingRoot(container, tag, options) {
  this._internalRoot = createRootImpl(container, tag, options);
}

ReactDOMRoot.prototype.render = ReactDOMBlockingRoot.prototype.render = function (children) {
  var root = this._internalRoot;

  {
    if (typeof arguments[1] === 'function') {
      error('render(...): does not support the second callback argument. ' + 'To execute a side effect after rendering, declare it in a component body with useEffect().');
    }

    var container = root.containerInfo;

    if (container.nodeType !== COMMENT_NODE) {
      var hostInstance = findHostInstanceWithNoPortals(root.current);

      if (hostInstance) {
        if (hostInstance.parentNode !== container) {
          error('render(...): It looks like the React-rendered content of the ' + 'root container was removed without using React. This is not ' + 'supported and will cause errors. Instead, call ' + "root.unmount() to empty a root's container.");
        }
      }
    }
  }

  updateContainer(children, root, null, null);
};

ReactDOMRoot.prototype.unmount = ReactDOMBlockingRoot.prototype.unmount = function () {
  {
    if (typeof arguments[0] === 'function') {
      error('unmount(...): does not support a callback argument. ' + 'To execute a side effect after rendering, declare it in a component body with useEffect().');
    }
  }

  var root = this._internalRoot;
  var container = root.containerInfo;
  updateContainer(null, root, null, function () {
    unmarkContainerAsRoot(container);
  });
};

function createRootImpl(container, tag, options) {
  // Tag is either LegacyRoot or Concurrent Root
  var hydrate = options != null && options.hydrate === true;
  var hydrationCallbacks = options != null && options.hydrationOptions || null;
  var mutableSources = options != null && options.hydrationOptions != null && options.hydrationOptions.mutableSources || null;
  var root = createContainer(container, tag, hydrate);
  markContainerAsRoot(root.current, container);
  var containerNodeType = container.nodeType;

  {
    var rootContainerElement = container.nodeType === COMMENT_NODE ? container.parentNode : container;
    listenToAllSupportedEvents(rootContainerElement);
  }

  if (mutableSources) {
    for (var i = 0; i < mutableSources.length; i++) {
      var mutableSource = mutableSources[i];
      registerMutableSourceForHydration(root, mutableSource);
    }
  }

  return root;
}
function createLegacyRoot(container, options) {
  return new ReactDOMBlockingRoot(container, LegacyRoot, options);
}
function isValidContainer(node) {
  return !!(node && (node.nodeType === ELEMENT_NODE || node.nodeType === DOCUMENT_NODE || node.nodeType === DOCUMENT_FRAGMENT_NODE || node.nodeType === COMMENT_NODE && node.nodeValue === ' react-mount-point-unstable '));
}

var ReactCurrentOwner$3 = ReactSharedInternals.ReactCurrentOwner;
var topLevelUpdateWarnings;
var warnedAboutHydrateAPI = false;

{
  topLevelUpdateWarnings = function (container) {
    if (container._reactRootContainer && container.nodeType !== COMMENT_NODE) {
      var hostInstance = findHostInstanceWithNoPortals(container._reactRootContainer._internalRoot.current);

      if (hostInstance) {
        if (hostInstance.parentNode !== container) {
          error('render(...): It looks like the React-rendered content of this ' + 'container was removed without using React. This is not ' + 'supported and will cause errors. Instead, call ' + 'ReactDOM.unmountComponentAtNode to empty a container.');
        }
      }
    }

    var isRootRenderedBySomeReact = !!container._reactRootContainer;
    var rootEl = getReactRootElementInContainer(container);
    var hasNonRootReactChild = !!(rootEl && getInstanceFromNode(rootEl));

    if (hasNonRootReactChild && !isRootRenderedBySomeReact) {
      error('render(...): Replacing React-rendered children with a new root ' + 'component. If you intended to update the children of this node, ' + 'you should instead have the existing children update their state ' + 'and render the new components instead of calling ReactDOM.render.');
    }

    if (container.nodeType === ELEMENT_NODE && container.tagName && container.tagName.toUpperCase() === 'BODY') {
      error('render(): Rendering components directly into document.body is ' + 'discouraged, since its children are often manipulated by third-party ' + 'scripts and browser extensions. This may lead to subtle ' + 'reconciliation issues. Try rendering into a container element created ' + 'for your app.');
    }
  };
}

function getReactRootElementInContainer(container) {
  if (!container) {
    return null;
  }

  if (container.nodeType === DOCUMENT_NODE) {
    return container.documentElement;
  } else {
    return container.firstChild;
  }
}

function shouldHydrateDueToLegacyHeuristic(container) {
  var rootElement = getReactRootElementInContainer(container);
  return !!(rootElement && rootElement.nodeType === ELEMENT_NODE && rootElement.hasAttribute(ROOT_ATTRIBUTE_NAME));
}

function legacyCreateRootFromDOMContainer(container, forceHydrate) {
  var shouldHydrate = forceHydrate || shouldHydrateDueToLegacyHeuristic(container); // First clear any existing content.

  if (!shouldHydrate) {
    var warned = false;
    var rootSibling;

    while (rootSibling = container.lastChild) {
      {
        if (!warned && rootSibling.nodeType === ELEMENT_NODE && rootSibling.hasAttribute(ROOT_ATTRIBUTE_NAME)) {
          warned = true;

          error('render(): Target node has markup rendered by React, but there ' + 'are unrelated nodes as well. This is most commonly caused by ' + 'white-space inserted around server-rendered markup.');
        }
      }

      container.removeChild(rootSibling);
    }
  }

  {
    if (shouldHydrate && !forceHydrate && !warnedAboutHydrateAPI) {
      warnedAboutHydrateAPI = true;

      warn('render(): Calling ReactDOM.render() to hydrate server-rendered markup ' + 'will stop working in React v18. Replace the ReactDOM.render() call ' + 'with ReactDOM.hydrate() if you want React to attach to the server HTML.');
    }
  }

  return createLegacyRoot(container, shouldHydrate ? {
    hydrate: true
  } : undefined);
}

function warnOnInvalidCallback$1(callback, callerName) {
  {
    if (callback !== null && typeof callback !== 'function') {
      error('%s(...): Expected the last optional `callback` argument to be a ' + 'function. Instead received: %s.', callerName, callback);
    }
  }
}

function legacyRenderSubtreeIntoContainer(parentComponent, children, container, forceHydrate, callback) {
  {
    topLevelUpdateWarnings(container);
    warnOnInvalidCallback$1(callback === undefined ? null : callback, 'render');
  } // TODO: Without `any` type, Flow says "Property cannot be accessed on any
  // member of intersection type." Whyyyyyy.


  var root = container._reactRootContainer;
  var fiberRoot;

  if (!root) {
    // Initial mount
    root = container._reactRootContainer = legacyCreateRootFromDOMContainer(container, forceHydrate);
    fiberRoot = root._internalRoot;

    if (typeof callback === 'function') {
      var originalCallback = callback;

      callback = function () {
        var instance = getPublicRootInstance(fiberRoot);
        originalCallback.call(instance);
      };
    } // Initial mount should not be batched.


    unbatchedUpdates(function () {
      updateContainer(children, fiberRoot, parentComponent, callback);
    });
  } else {
    fiberRoot = root._internalRoot;

    if (typeof callback === 'function') {
      var _originalCallback = callback;

      callback = function () {
        var instance = getPublicRootInstance(fiberRoot);

        _originalCallback.call(instance);
      };
    } // Update


    updateContainer(children, fiberRoot, parentComponent, callback);
  }

  return getPublicRootInstance(fiberRoot);
}

function findDOMNode(componentOrElement) {
  {
    var owner = ReactCurrentOwner$3.current;

    if (owner !== null && owner.stateNode !== null) {
      var warnedAboutRefsInRender = owner.stateNode._warnedAboutRefsInRender;

      if (!warnedAboutRefsInRender) {
        error('%s is accessing findDOMNode inside its render(). ' + 'render() should be a pure function of props and state. It should ' + 'never access something that requires stale data from the previous ' + 'render, such as refs. Move this logic to componentDidMount and ' + 'componentDidUpdate instead.', getComponentName(owner.type) || 'A component');
      }

      owner.stateNode._warnedAboutRefsInRender = true;
    }
  }

  if (componentOrElement == null) {
    return null;
  }

  if (componentOrElement.nodeType === ELEMENT_NODE) {
    return componentOrElement;
  }

  {
    return findHostInstanceWithWarning(componentOrElement, 'findDOMNode');
  }
}
function hydrate(element, container, callback) {
  if (!isValidContainer(container)) {
    {
      throw Error( "Target container is not a DOM element." );
    }
  }

  {
    var isModernRoot = isContainerMarkedAsRoot(container) && container._reactRootContainer === undefined;

    if (isModernRoot) {
      error('You are calling ReactDOM.hydrate() on a container that was previously ' + 'passed to ReactDOM.createRoot(). This is not supported. ' + 'Did you mean to call createRoot(container, {hydrate: true}).render(element)?');
    }
  } // TODO: throw or warn if we couldn't hydrate?


  return legacyRenderSubtreeIntoContainer(null, element, container, true, callback);
}
function render(element, container, callback) {
  if (!isValidContainer(container)) {
    {
      throw Error( "Target container is not a DOM element." );
    }
  }

  {
    var isModernRoot = isContainerMarkedAsRoot(container) && container._reactRootContainer === undefined;

    if (isModernRoot) {
      error('You are calling ReactDOM.render() on a container that was previously ' + 'passed to ReactDOM.createRoot(). This is not supported. ' + 'Did you mean to call root.render(element)?');
    }
  }

  return legacyRenderSubtreeIntoContainer(null, element, container, false, callback);
}
function unstable_renderSubtreeIntoContainer(parentComponent, element, containerNode, callback) {
  if (!isValidContainer(containerNode)) {
    {
      throw Error( "Target container is not a DOM element." );
    }
  }

  if (!(parentComponent != null && has(parentComponent))) {
    {
      throw Error( "parentComponent must be a valid React Component" );
    }
  }

  return legacyRenderSubtreeIntoContainer(parentComponent, element, containerNode, false, callback);
}
function unmountComponentAtNode(container) {
  if (!isValidContainer(container)) {
    {
      throw Error( "unmountComponentAtNode(...): Target container is not a DOM element." );
    }
  }

  {
    var isModernRoot = isContainerMarkedAsRoot(container) && container._reactRootContainer === undefined;

    if (isModernRoot) {
      error('You are calling ReactDOM.unmountComponentAtNode() on a container that was previously ' + 'passed to ReactDOM.createRoot(). This is not supported. Did you mean to call root.unmount()?');
    }
  }

  if (container._reactRootContainer) {
    {
      var rootEl = getReactRootElementInContainer(container);
      var renderedByDifferentReact = rootEl && !getInstanceFromNode(rootEl);

      if (renderedByDifferentReact) {
        error("unmountComponentAtNode(): The node you're attempting to unmount " + 'was rendered by another copy of React.');
      }
    } // Unmount should not be batched.


    unbatchedUpdates(function () {
      legacyRenderSubtreeIntoContainer(null, null, container, false, function () {
        // $FlowFixMe This should probably use `delete container._reactRootContainer`
        container._reactRootContainer = null;
        unmarkContainerAsRoot(container);
      });
    }); // If you call unmountComponentAtNode twice in quick succession, you'll
    // get `true` twice. That's probably fine?

    return true;
  } else {
    {
      var _rootEl = getReactRootElementInContainer(container);

      var hasNonRootReactChild = !!(_rootEl && getInstanceFromNode(_rootEl)); // Check if the container itself is a React root node.

      var isContainerReactRoot = container.nodeType === ELEMENT_NODE && isValidContainer(container.parentNode) && !!container.parentNode._reactRootContainer;

      if (hasNonRootReactChild) {
        error("unmountComponentAtNode(): The node you're attempting to unmount " + 'was rendered by React and is not a top-level container. %s', isContainerReactRoot ? 'You may have accidentally passed in a React root node instead ' + 'of its container.' : 'Instead, have the parent component update its state and ' + 'rerender in order to remove this component.');
      }
    }

    return false;
  }
}

setAttemptUserBlockingHydration(attemptUserBlockingHydration$1);
setAttemptContinuousHydration(attemptContinuousHydration$1);
setAttemptHydrationAtCurrentPriority(attemptHydrationAtCurrentPriority$1);
setAttemptHydrationAtPriority(runWithPriority$2);
var didWarnAboutUnstableCreatePortal = false;

{
  if (typeof Map !== 'function' || // $FlowIssue Flow incorrectly thinks Map has no prototype
  Map.prototype == null || typeof Map.prototype.forEach !== 'function' || typeof Set !== 'function' || // $FlowIssue Flow incorrectly thinks Set has no prototype
  Set.prototype == null || typeof Set.prototype.clear !== 'function' || typeof Set.prototype.forEach !== 'function') {
    error('React depends on Map and Set built-in types. Make sure that you load a ' + 'polyfill in older browsers. https://reactjs.org/link/react-polyfills');
  }
}

setRestoreImplementation(restoreControlledState$3);
setBatchingImplementation(batchedUpdates$1, discreteUpdates$1, flushDiscreteUpdates, batchedEventUpdates$1);

function createPortal$1(children, container) {
  var key = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

  if (!isValidContainer(container)) {
    {
      throw Error( "Target container is not a DOM element." );
    }
  } // TODO: pass ReactDOM portal implementation as third argument
  // $FlowFixMe The Flow type is opaque but there's no way to actually create it.


  return createPortal(children, container, null, key);
}

function renderSubtreeIntoContainer(parentComponent, element, containerNode, callback) {

  return unstable_renderSubtreeIntoContainer(parentComponent, element, containerNode, callback);
}

function unstable_createPortal(children, container) {
  var key = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

  {
    if (!didWarnAboutUnstableCreatePortal) {
      didWarnAboutUnstableCreatePortal = true;

      warn('The ReactDOM.unstable_createPortal() alias has been deprecated, ' + 'and will be removed in React 18+. Update your code to use ' + 'ReactDOM.createPortal() instead. It has the exact same API, ' + 'but without the "unstable_" prefix.');
    }
  }

  return createPortal$1(children, container, key);
}

var Internals = {
  // Keep in sync with ReactTestUtils.js, and ReactTestUtilsAct.js.
  // This is an array for better minification.
  Events: [getInstanceFromNode, getNodeFromInstance, getFiberCurrentPropsFromNode, enqueueStateRestore, restoreStateIfNeeded, flushPassiveEffects, // TODO: This is related to `act`, not events. Move to separate key?
  IsThisRendererActing]
};
var foundDevTools = injectIntoDevTools({
  findFiberByHostInstance: getClosestInstanceFromNode,
  bundleType:  1 ,
  version: ReactVersion,
  rendererPackageName: 'react-dom'
});

{
  if (!foundDevTools && canUseDOM && window.top === window.self) {
    // If we're in Chrome or Firefox, provide a download link if not installed.
    if (navigator.userAgent.indexOf('Chrome') > -1 && navigator.userAgent.indexOf('Edge') === -1 || navigator.userAgent.indexOf('Firefox') > -1) {
      var protocol = window.location.protocol; // Don't warn in exotic cases like chrome-extension://.

      if (/^(https?|file):$/.test(protocol)) {
        // eslint-disable-next-line react-internal/no-production-logging
        console.info('%cDownload the React DevTools ' + 'for a better development experience: ' + 'https://reactjs.org/link/react-devtools' + (protocol === 'file:' ? '\nYou might need to use a local HTTP server (instead of file://): ' + 'https://reactjs.org/link/react-devtools-faq' : ''), 'font-weight:bold');
      }
    }
  }
}

exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = Internals;
exports.createPortal = createPortal$1;
exports.findDOMNode = findDOMNode;
exports.flushSync = flushSync;
exports.hydrate = hydrate;
exports.render = render;
exports.unmountComponentAtNode = unmountComponentAtNode;
exports.unstable_batchedUpdates = batchedUpdates$1;
exports.unstable_createPortal = unstable_createPortal;
exports.unstable_renderSubtreeIntoContainer = renderSubtreeIntoContainer;
exports.version = ReactVersion;
  })();
}


/***/ }),

/***/ "./node_modules/react-dom/index.js":
/*!*****************************************!*\
  !*** ./node_modules/react-dom/index.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


function checkDCE() {
  /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */
  if (
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === 'undefined' ||
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== 'function'
  ) {
    return;
  }
  if (true) {
    // This branch is unreachable because this function is only called
    // in production, but the condition is true only in development.
    // Therefore if the branch is still here, dead code elimination wasn't
    // properly applied.
    // Don't change the message. React DevTools relies on it. Also make sure
    // this message doesn't occur elsewhere in this function, or it will cause
    // a false positive.
    throw new Error('^_^');
  }
  try {
    // Verify that the code above has been dead code eliminated (DCE'd).
    __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
  } catch (err) {
    // DevTools shouldn't crash React, no matter what.
    // We should still report in case we break this code.
    console.error(err);
  }
}

if (false) {} else {
  module.exports = __webpack_require__(/*! ./cjs/react-dom.development.js */ "./node_modules/react-dom/cjs/react-dom.development.js");
}


/***/ }),

/***/ "./node_modules/react/cjs/react.development.js":
/*!*****************************************************!*\
  !*** ./node_modules/react/cjs/react.development.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/** @license React v17.0.2
 * react.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



if (true) {
  (function() {
'use strict';

var _assign = __webpack_require__(/*! object-assign */ "./node_modules/object-assign/index.js");

// TODO: this is special because it gets imported during build.
var ReactVersion = '17.0.2';

// ATTENTION
// When adding new symbols to this file,
// Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'
// The Symbol used to tag the ReactElement-like types. If there is no native Symbol
// nor polyfill, then a plain number is used for performance.
var REACT_ELEMENT_TYPE = 0xeac7;
var REACT_PORTAL_TYPE = 0xeaca;
exports.Fragment = 0xeacb;
exports.StrictMode = 0xeacc;
exports.Profiler = 0xead2;
var REACT_PROVIDER_TYPE = 0xeacd;
var REACT_CONTEXT_TYPE = 0xeace;
var REACT_FORWARD_REF_TYPE = 0xead0;
exports.Suspense = 0xead1;
var REACT_SUSPENSE_LIST_TYPE = 0xead8;
var REACT_MEMO_TYPE = 0xead3;
var REACT_LAZY_TYPE = 0xead4;
var REACT_BLOCK_TYPE = 0xead9;
var REACT_SERVER_BLOCK_TYPE = 0xeada;
var REACT_FUNDAMENTAL_TYPE = 0xead5;
var REACT_SCOPE_TYPE = 0xead7;
var REACT_OPAQUE_ID_TYPE = 0xeae0;
var REACT_DEBUG_TRACING_MODE_TYPE = 0xeae1;
var REACT_OFFSCREEN_TYPE = 0xeae2;
var REACT_LEGACY_HIDDEN_TYPE = 0xeae3;

if (typeof Symbol === 'function' && Symbol.for) {
  var symbolFor = Symbol.for;
  REACT_ELEMENT_TYPE = symbolFor('react.element');
  REACT_PORTAL_TYPE = symbolFor('react.portal');
  exports.Fragment = symbolFor('react.fragment');
  exports.StrictMode = symbolFor('react.strict_mode');
  exports.Profiler = symbolFor('react.profiler');
  REACT_PROVIDER_TYPE = symbolFor('react.provider');
  REACT_CONTEXT_TYPE = symbolFor('react.context');
  REACT_FORWARD_REF_TYPE = symbolFor('react.forward_ref');
  exports.Suspense = symbolFor('react.suspense');
  REACT_SUSPENSE_LIST_TYPE = symbolFor('react.suspense_list');
  REACT_MEMO_TYPE = symbolFor('react.memo');
  REACT_LAZY_TYPE = symbolFor('react.lazy');
  REACT_BLOCK_TYPE = symbolFor('react.block');
  REACT_SERVER_BLOCK_TYPE = symbolFor('react.server.block');
  REACT_FUNDAMENTAL_TYPE = symbolFor('react.fundamental');
  REACT_SCOPE_TYPE = symbolFor('react.scope');
  REACT_OPAQUE_ID_TYPE = symbolFor('react.opaque.id');
  REACT_DEBUG_TRACING_MODE_TYPE = symbolFor('react.debug_trace_mode');
  REACT_OFFSCREEN_TYPE = symbolFor('react.offscreen');
  REACT_LEGACY_HIDDEN_TYPE = symbolFor('react.legacy_hidden');
}

var MAYBE_ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
var FAUX_ITERATOR_SYMBOL = '@@iterator';
function getIteratorFn(maybeIterable) {
  if (maybeIterable === null || typeof maybeIterable !== 'object') {
    return null;
  }

  var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];

  if (typeof maybeIterator === 'function') {
    return maybeIterator;
  }

  return null;
}

/**
 * Keeps track of the current dispatcher.
 */
var ReactCurrentDispatcher = {
  /**
   * @internal
   * @type {ReactComponent}
   */
  current: null
};

/**
 * Keeps track of the current batch's configuration such as how long an update
 * should suspend for if it needs to.
 */
var ReactCurrentBatchConfig = {
  transition: 0
};

/**
 * Keeps track of the current owner.
 *
 * The current owner is the component who should own any components that are
 * currently being constructed.
 */
var ReactCurrentOwner = {
  /**
   * @internal
   * @type {ReactComponent}
   */
  current: null
};

var ReactDebugCurrentFrame = {};
var currentExtraStackFrame = null;
function setExtraStackFrame(stack) {
  {
    currentExtraStackFrame = stack;
  }
}

{
  ReactDebugCurrentFrame.setExtraStackFrame = function (stack) {
    {
      currentExtraStackFrame = stack;
    }
  }; // Stack implementation injected by the current renderer.


  ReactDebugCurrentFrame.getCurrentStack = null;

  ReactDebugCurrentFrame.getStackAddendum = function () {
    var stack = ''; // Add an extra top frame while an element is being validated

    if (currentExtraStackFrame) {
      stack += currentExtraStackFrame;
    } // Delegate to the injected renderer-specific implementation


    var impl = ReactDebugCurrentFrame.getCurrentStack;

    if (impl) {
      stack += impl() || '';
    }

    return stack;
  };
}

/**
 * Used by act() to track whether you're inside an act() scope.
 */
var IsSomeRendererActing = {
  current: false
};

var ReactSharedInternals = {
  ReactCurrentDispatcher: ReactCurrentDispatcher,
  ReactCurrentBatchConfig: ReactCurrentBatchConfig,
  ReactCurrentOwner: ReactCurrentOwner,
  IsSomeRendererActing: IsSomeRendererActing,
  // Used by renderers to avoid bundling object-assign twice in UMD bundles:
  assign: _assign
};

{
  ReactSharedInternals.ReactDebugCurrentFrame = ReactDebugCurrentFrame;
}

// by calls to these methods by a Babel plugin.
//
// In PROD (or in packages without access to React internals),
// they are left as they are instead.

function warn(format) {
  {
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }

    printWarning('warn', format, args);
  }
}
function error(format) {
  {
    for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
      args[_key2 - 1] = arguments[_key2];
    }

    printWarning('error', format, args);
  }
}

function printWarning(level, format, args) {
  // When changing this logic, you might want to also
  // update consoleWithStackDev.www.js as well.
  {
    var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
    var stack = ReactDebugCurrentFrame.getStackAddendum();

    if (stack !== '') {
      format += '%s';
      args = args.concat([stack]);
    }

    var argsWithFormat = args.map(function (item) {
      return '' + item;
    }); // Careful: RN currently depends on this prefix

    argsWithFormat.unshift('Warning: ' + format); // We intentionally don't use spread (or .apply) directly because it
    // breaks IE9: https://github.com/facebook/react/issues/13610
    // eslint-disable-next-line react-internal/no-production-logging

    Function.prototype.apply.call(console[level], console, argsWithFormat);
  }
}

var didWarnStateUpdateForUnmountedComponent = {};

function warnNoop(publicInstance, callerName) {
  {
    var _constructor = publicInstance.constructor;
    var componentName = _constructor && (_constructor.displayName || _constructor.name) || 'ReactClass';
    var warningKey = componentName + "." + callerName;

    if (didWarnStateUpdateForUnmountedComponent[warningKey]) {
      return;
    }

    error("Can't call %s on a component that is not yet mounted. " + 'This is a no-op, but it might indicate a bug in your application. ' + 'Instead, assign to `this.state` directly or define a `state = {};` ' + 'class property with the desired state in the %s component.', callerName, componentName);

    didWarnStateUpdateForUnmountedComponent[warningKey] = true;
  }
}
/**
 * This is the abstract API for an update queue.
 */


var ReactNoopUpdateQueue = {
  /**
   * Checks whether or not this composite component is mounted.
   * @param {ReactClass} publicInstance The instance we want to test.
   * @return {boolean} True if mounted, false otherwise.
   * @protected
   * @final
   */
  isMounted: function (publicInstance) {
    return false;
  },

  /**
   * Forces an update. This should only be invoked when it is known with
   * certainty that we are **not** in a DOM transaction.
   *
   * You may want to call this when you know that some deeper aspect of the
   * component's state has changed but `setState` was not called.
   *
   * This will not invoke `shouldComponentUpdate`, but it will invoke
   * `componentWillUpdate` and `componentDidUpdate`.
   *
   * @param {ReactClass} publicInstance The instance that should rerender.
   * @param {?function} callback Called after component is updated.
   * @param {?string} callerName name of the calling function in the public API.
   * @internal
   */
  enqueueForceUpdate: function (publicInstance, callback, callerName) {
    warnNoop(publicInstance, 'forceUpdate');
  },

  /**
   * Replaces all of the state. Always use this or `setState` to mutate state.
   * You should treat `this.state` as immutable.
   *
   * There is no guarantee that `this.state` will be immediately updated, so
   * accessing `this.state` after calling this method may return the old value.
   *
   * @param {ReactClass} publicInstance The instance that should rerender.
   * @param {object} completeState Next state.
   * @param {?function} callback Called after component is updated.
   * @param {?string} callerName name of the calling function in the public API.
   * @internal
   */
  enqueueReplaceState: function (publicInstance, completeState, callback, callerName) {
    warnNoop(publicInstance, 'replaceState');
  },

  /**
   * Sets a subset of the state. This only exists because _pendingState is
   * internal. This provides a merging strategy that is not available to deep
   * properties which is confusing. TODO: Expose pendingState or don't use it
   * during the merge.
   *
   * @param {ReactClass} publicInstance The instance that should rerender.
   * @param {object} partialState Next partial state to be merged with state.
   * @param {?function} callback Called after component is updated.
   * @param {?string} Name of the calling function in the public API.
   * @internal
   */
  enqueueSetState: function (publicInstance, partialState, callback, callerName) {
    warnNoop(publicInstance, 'setState');
  }
};

var emptyObject = {};

{
  Object.freeze(emptyObject);
}
/**
 * Base class helpers for the updating state of a component.
 */


function Component(props, context, updater) {
  this.props = props;
  this.context = context; // If a component has string refs, we will assign a different object later.

  this.refs = emptyObject; // We initialize the default updater but the real one gets injected by the
  // renderer.

  this.updater = updater || ReactNoopUpdateQueue;
}

Component.prototype.isReactComponent = {};
/**
 * Sets a subset of the state. Always use this to mutate
 * state. You should treat `this.state` as immutable.
 *
 * There is no guarantee that `this.state` will be immediately updated, so
 * accessing `this.state` after calling this method may return the old value.
 *
 * There is no guarantee that calls to `setState` will run synchronously,
 * as they may eventually be batched together.  You can provide an optional
 * callback that will be executed when the call to setState is actually
 * completed.
 *
 * When a function is provided to setState, it will be called at some point in
 * the future (not synchronously). It will be called with the up to date
 * component arguments (state, props, context). These values can be different
 * from this.* because your function may be called after receiveProps but before
 * shouldComponentUpdate, and this new state, props, and context will not yet be
 * assigned to this.
 *
 * @param {object|function} partialState Next partial state or function to
 *        produce next partial state to be merged with current state.
 * @param {?function} callback Called after state is updated.
 * @final
 * @protected
 */

Component.prototype.setState = function (partialState, callback) {
  if (!(typeof partialState === 'object' || typeof partialState === 'function' || partialState == null)) {
    {
      throw Error( "setState(...): takes an object of state variables to update or a function which returns an object of state variables." );
    }
  }

  this.updater.enqueueSetState(this, partialState, callback, 'setState');
};
/**
 * Forces an update. This should only be invoked when it is known with
 * certainty that we are **not** in a DOM transaction.
 *
 * You may want to call this when you know that some deeper aspect of the
 * component's state has changed but `setState` was not called.
 *
 * This will not invoke `shouldComponentUpdate`, but it will invoke
 * `componentWillUpdate` and `componentDidUpdate`.
 *
 * @param {?function} callback Called after update is complete.
 * @final
 * @protected
 */


Component.prototype.forceUpdate = function (callback) {
  this.updater.enqueueForceUpdate(this, callback, 'forceUpdate');
};
/**
 * Deprecated APIs. These APIs used to exist on classic React classes but since
 * we would like to deprecate them, we're not going to move them over to this
 * modern base class. Instead, we define a getter that warns if it's accessed.
 */


{
  var deprecatedAPIs = {
    isMounted: ['isMounted', 'Instead, make sure to clean up subscriptions and pending requests in ' + 'componentWillUnmount to prevent memory leaks.'],
    replaceState: ['replaceState', 'Refactor your code to use setState instead (see ' + 'https://github.com/facebook/react/issues/3236).']
  };

  var defineDeprecationWarning = function (methodName, info) {
    Object.defineProperty(Component.prototype, methodName, {
      get: function () {
        warn('%s(...) is deprecated in plain JavaScript React classes. %s', info[0], info[1]);

        return undefined;
      }
    });
  };

  for (var fnName in deprecatedAPIs) {
    if (deprecatedAPIs.hasOwnProperty(fnName)) {
      defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);
    }
  }
}

function ComponentDummy() {}

ComponentDummy.prototype = Component.prototype;
/**
 * Convenience component with default shallow equality check for sCU.
 */

function PureComponent(props, context, updater) {
  this.props = props;
  this.context = context; // If a component has string refs, we will assign a different object later.

  this.refs = emptyObject;
  this.updater = updater || ReactNoopUpdateQueue;
}

var pureComponentPrototype = PureComponent.prototype = new ComponentDummy();
pureComponentPrototype.constructor = PureComponent; // Avoid an extra prototype jump for these methods.

_assign(pureComponentPrototype, Component.prototype);

pureComponentPrototype.isPureReactComponent = true;

// an immutable object with a single mutable value
function createRef() {
  var refObject = {
    current: null
  };

  {
    Object.seal(refObject);
  }

  return refObject;
}

function getWrappedName(outerType, innerType, wrapperName) {
  var functionName = innerType.displayName || innerType.name || '';
  return outerType.displayName || (functionName !== '' ? wrapperName + "(" + functionName + ")" : wrapperName);
}

function getContextName(type) {
  return type.displayName || 'Context';
}

function getComponentName(type) {
  if (type == null) {
    // Host root, text node or just invalid type.
    return null;
  }

  {
    if (typeof type.tag === 'number') {
      error('Received an unexpected object in getComponentName(). ' + 'This is likely a bug in React. Please file an issue.');
    }
  }

  if (typeof type === 'function') {
    return type.displayName || type.name || null;
  }

  if (typeof type === 'string') {
    return type;
  }

  switch (type) {
    case exports.Fragment:
      return 'Fragment';

    case REACT_PORTAL_TYPE:
      return 'Portal';

    case exports.Profiler:
      return 'Profiler';

    case exports.StrictMode:
      return 'StrictMode';

    case exports.Suspense:
      return 'Suspense';

    case REACT_SUSPENSE_LIST_TYPE:
      return 'SuspenseList';
  }

  if (typeof type === 'object') {
    switch (type.$$typeof) {
      case REACT_CONTEXT_TYPE:
        var context = type;
        return getContextName(context) + '.Consumer';

      case REACT_PROVIDER_TYPE:
        var provider = type;
        return getContextName(provider._context) + '.Provider';

      case REACT_FORWARD_REF_TYPE:
        return getWrappedName(type, type.render, 'ForwardRef');

      case REACT_MEMO_TYPE:
        return getComponentName(type.type);

      case REACT_BLOCK_TYPE:
        return getComponentName(type._render);

      case REACT_LAZY_TYPE:
        {
          var lazyComponent = type;
          var payload = lazyComponent._payload;
          var init = lazyComponent._init;

          try {
            return getComponentName(init(payload));
          } catch (x) {
            return null;
          }
        }
    }
  }

  return null;
}

var hasOwnProperty = Object.prototype.hasOwnProperty;
var RESERVED_PROPS = {
  key: true,
  ref: true,
  __self: true,
  __source: true
};
var specialPropKeyWarningShown, specialPropRefWarningShown, didWarnAboutStringRefs;

{
  didWarnAboutStringRefs = {};
}

function hasValidRef(config) {
  {
    if (hasOwnProperty.call(config, 'ref')) {
      var getter = Object.getOwnPropertyDescriptor(config, 'ref').get;

      if (getter && getter.isReactWarning) {
        return false;
      }
    }
  }

  return config.ref !== undefined;
}

function hasValidKey(config) {
  {
    if (hasOwnProperty.call(config, 'key')) {
      var getter = Object.getOwnPropertyDescriptor(config, 'key').get;

      if (getter && getter.isReactWarning) {
        return false;
      }
    }
  }

  return config.key !== undefined;
}

function defineKeyPropWarningGetter(props, displayName) {
  var warnAboutAccessingKey = function () {
    {
      if (!specialPropKeyWarningShown) {
        specialPropKeyWarningShown = true;

        error('%s: `key` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);
      }
    }
  };

  warnAboutAccessingKey.isReactWarning = true;
  Object.defineProperty(props, 'key', {
    get: warnAboutAccessingKey,
    configurable: true
  });
}

function defineRefPropWarningGetter(props, displayName) {
  var warnAboutAccessingRef = function () {
    {
      if (!specialPropRefWarningShown) {
        specialPropRefWarningShown = true;

        error('%s: `ref` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);
      }
    }
  };

  warnAboutAccessingRef.isReactWarning = true;
  Object.defineProperty(props, 'ref', {
    get: warnAboutAccessingRef,
    configurable: true
  });
}

function warnIfStringRefCannotBeAutoConverted(config) {
  {
    if (typeof config.ref === 'string' && ReactCurrentOwner.current && config.__self && ReactCurrentOwner.current.stateNode !== config.__self) {
      var componentName = getComponentName(ReactCurrentOwner.current.type);

      if (!didWarnAboutStringRefs[componentName]) {
        error('Component "%s" contains the string ref "%s". ' + 'Support for string refs will be removed in a future major release. ' + 'This case cannot be automatically converted to an arrow function. ' + 'We ask you to manually fix this case by using useRef() or createRef() instead. ' + 'Learn more about using refs safely here: ' + 'https://reactjs.org/link/strict-mode-string-ref', componentName, config.ref);

        didWarnAboutStringRefs[componentName] = true;
      }
    }
  }
}
/**
 * Factory method to create a new React element. This no longer adheres to
 * the class pattern, so do not use new to call it. Also, instanceof check
 * will not work. Instead test $$typeof field against Symbol.for('react.element') to check
 * if something is a React Element.
 *
 * @param {*} type
 * @param {*} props
 * @param {*} key
 * @param {string|object} ref
 * @param {*} owner
 * @param {*} self A *temporary* helper to detect places where `this` is
 * different from the `owner` when React.createElement is called, so that we
 * can warn. We want to get rid of owner and replace string `ref`s with arrow
 * functions, and as long as `this` and owner are the same, there will be no
 * change in behavior.
 * @param {*} source An annotation object (added by a transpiler or otherwise)
 * indicating filename, line number, and/or other information.
 * @internal
 */


var ReactElement = function (type, key, ref, self, source, owner, props) {
  var element = {
    // This tag allows us to uniquely identify this as a React Element
    $$typeof: REACT_ELEMENT_TYPE,
    // Built-in properties that belong on the element
    type: type,
    key: key,
    ref: ref,
    props: props,
    // Record the component responsible for creating this element.
    _owner: owner
  };

  {
    // The validation flag is currently mutative. We put it on
    // an external backing store so that we can freeze the whole object.
    // This can be replaced with a WeakMap once they are implemented in
    // commonly used development environments.
    element._store = {}; // To make comparing ReactElements easier for testing purposes, we make
    // the validation flag non-enumerable (where possible, which should
    // include every environment we run tests in), so the test framework
    // ignores it.

    Object.defineProperty(element._store, 'validated', {
      configurable: false,
      enumerable: false,
      writable: true,
      value: false
    }); // self and source are DEV only properties.

    Object.defineProperty(element, '_self', {
      configurable: false,
      enumerable: false,
      writable: false,
      value: self
    }); // Two elements created in two different places should be considered
    // equal for testing purposes and therefore we hide it from enumeration.

    Object.defineProperty(element, '_source', {
      configurable: false,
      enumerable: false,
      writable: false,
      value: source
    });

    if (Object.freeze) {
      Object.freeze(element.props);
      Object.freeze(element);
    }
  }

  return element;
};
/**
 * Create and return a new ReactElement of the given type.
 * See https://reactjs.org/docs/react-api.html#createelement
 */

function createElement(type, config, children) {
  var propName; // Reserved names are extracted

  var props = {};
  var key = null;
  var ref = null;
  var self = null;
  var source = null;

  if (config != null) {
    if (hasValidRef(config)) {
      ref = config.ref;

      {
        warnIfStringRefCannotBeAutoConverted(config);
      }
    }

    if (hasValidKey(config)) {
      key = '' + config.key;
    }

    self = config.__self === undefined ? null : config.__self;
    source = config.__source === undefined ? null : config.__source; // Remaining properties are added to a new props object

    for (propName in config) {
      if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
        props[propName] = config[propName];
      }
    }
  } // Children can be more than one argument, and those are transferred onto
  // the newly allocated props object.


  var childrenLength = arguments.length - 2;

  if (childrenLength === 1) {
    props.children = children;
  } else if (childrenLength > 1) {
    var childArray = Array(childrenLength);

    for (var i = 0; i < childrenLength; i++) {
      childArray[i] = arguments[i + 2];
    }

    {
      if (Object.freeze) {
        Object.freeze(childArray);
      }
    }

    props.children = childArray;
  } // Resolve default props


  if (type && type.defaultProps) {
    var defaultProps = type.defaultProps;

    for (propName in defaultProps) {
      if (props[propName] === undefined) {
        props[propName] = defaultProps[propName];
      }
    }
  }

  {
    if (key || ref) {
      var displayName = typeof type === 'function' ? type.displayName || type.name || 'Unknown' : type;

      if (key) {
        defineKeyPropWarningGetter(props, displayName);
      }

      if (ref) {
        defineRefPropWarningGetter(props, displayName);
      }
    }
  }

  return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);
}
function cloneAndReplaceKey(oldElement, newKey) {
  var newElement = ReactElement(oldElement.type, newKey, oldElement.ref, oldElement._self, oldElement._source, oldElement._owner, oldElement.props);
  return newElement;
}
/**
 * Clone and return a new ReactElement using element as the starting point.
 * See https://reactjs.org/docs/react-api.html#cloneelement
 */

function cloneElement(element, config, children) {
  if (!!(element === null || element === undefined)) {
    {
      throw Error( "React.cloneElement(...): The argument must be a React element, but you passed " + element + "." );
    }
  }

  var propName; // Original props are copied

  var props = _assign({}, element.props); // Reserved names are extracted


  var key = element.key;
  var ref = element.ref; // Self is preserved since the owner is preserved.

  var self = element._self; // Source is preserved since cloneElement is unlikely to be targeted by a
  // transpiler, and the original source is probably a better indicator of the
  // true owner.

  var source = element._source; // Owner will be preserved, unless ref is overridden

  var owner = element._owner;

  if (config != null) {
    if (hasValidRef(config)) {
      // Silently steal the ref from the parent.
      ref = config.ref;
      owner = ReactCurrentOwner.current;
    }

    if (hasValidKey(config)) {
      key = '' + config.key;
    } // Remaining properties override existing props


    var defaultProps;

    if (element.type && element.type.defaultProps) {
      defaultProps = element.type.defaultProps;
    }

    for (propName in config) {
      if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
        if (config[propName] === undefined && defaultProps !== undefined) {
          // Resolve default props
          props[propName] = defaultProps[propName];
        } else {
          props[propName] = config[propName];
        }
      }
    }
  } // Children can be more than one argument, and those are transferred onto
  // the newly allocated props object.


  var childrenLength = arguments.length - 2;

  if (childrenLength === 1) {
    props.children = children;
  } else if (childrenLength > 1) {
    var childArray = Array(childrenLength);

    for (var i = 0; i < childrenLength; i++) {
      childArray[i] = arguments[i + 2];
    }

    props.children = childArray;
  }

  return ReactElement(element.type, key, ref, self, source, owner, props);
}
/**
 * Verifies the object is a ReactElement.
 * See https://reactjs.org/docs/react-api.html#isvalidelement
 * @param {?object} object
 * @return {boolean} True if `object` is a ReactElement.
 * @final
 */

function isValidElement(object) {
  return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
}

var SEPARATOR = '.';
var SUBSEPARATOR = ':';
/**
 * Escape and wrap key so it is safe to use as a reactid
 *
 * @param {string} key to be escaped.
 * @return {string} the escaped key.
 */

function escape(key) {
  var escapeRegex = /[=:]/g;
  var escaperLookup = {
    '=': '=0',
    ':': '=2'
  };
  var escapedString = key.replace(escapeRegex, function (match) {
    return escaperLookup[match];
  });
  return '$' + escapedString;
}
/**
 * TODO: Test that a single child and an array with one item have the same key
 * pattern.
 */


var didWarnAboutMaps = false;
var userProvidedKeyEscapeRegex = /\/+/g;

function escapeUserProvidedKey(text) {
  return text.replace(userProvidedKeyEscapeRegex, '$&/');
}
/**
 * Generate a key string that identifies a element within a set.
 *
 * @param {*} element A element that could contain a manual key.
 * @param {number} index Index that is used if a manual key is not provided.
 * @return {string}
 */


function getElementKey(element, index) {
  // Do some typechecking here since we call this blindly. We want to ensure
  // that we don't block potential future ES APIs.
  if (typeof element === 'object' && element !== null && element.key != null) {
    // Explicit key
    return escape('' + element.key);
  } // Implicit key determined by the index in the set


  return index.toString(36);
}

function mapIntoArray(children, array, escapedPrefix, nameSoFar, callback) {
  var type = typeof children;

  if (type === 'undefined' || type === 'boolean') {
    // All of the above are perceived as null.
    children = null;
  }

  var invokeCallback = false;

  if (children === null) {
    invokeCallback = true;
  } else {
    switch (type) {
      case 'string':
      case 'number':
        invokeCallback = true;
        break;

      case 'object':
        switch (children.$$typeof) {
          case REACT_ELEMENT_TYPE:
          case REACT_PORTAL_TYPE:
            invokeCallback = true;
        }

    }
  }

  if (invokeCallback) {
    var _child = children;
    var mappedChild = callback(_child); // If it's the only child, treat the name as if it was wrapped in an array
    // so that it's consistent if the number of children grows:

    var childKey = nameSoFar === '' ? SEPARATOR + getElementKey(_child, 0) : nameSoFar;

    if (Array.isArray(mappedChild)) {
      var escapedChildKey = '';

      if (childKey != null) {
        escapedChildKey = escapeUserProvidedKey(childKey) + '/';
      }

      mapIntoArray(mappedChild, array, escapedChildKey, '', function (c) {
        return c;
      });
    } else if (mappedChild != null) {
      if (isValidElement(mappedChild)) {
        mappedChild = cloneAndReplaceKey(mappedChild, // Keep both the (mapped) and old keys if they differ, just as
        // traverseAllChildren used to do for objects as children
        escapedPrefix + ( // $FlowFixMe Flow incorrectly thinks React.Portal doesn't have a key
        mappedChild.key && (!_child || _child.key !== mappedChild.key) ? // $FlowFixMe Flow incorrectly thinks existing element's key can be a number
        escapeUserProvidedKey('' + mappedChild.key) + '/' : '') + childKey);
      }

      array.push(mappedChild);
    }

    return 1;
  }

  var child;
  var nextName;
  var subtreeCount = 0; // Count of children found in the current subtree.

  var nextNamePrefix = nameSoFar === '' ? SEPARATOR : nameSoFar + SUBSEPARATOR;

  if (Array.isArray(children)) {
    for (var i = 0; i < children.length; i++) {
      child = children[i];
      nextName = nextNamePrefix + getElementKey(child, i);
      subtreeCount += mapIntoArray(child, array, escapedPrefix, nextName, callback);
    }
  } else {
    var iteratorFn = getIteratorFn(children);

    if (typeof iteratorFn === 'function') {
      var iterableChildren = children;

      {
        // Warn about using Maps as children
        if (iteratorFn === iterableChildren.entries) {
          if (!didWarnAboutMaps) {
            warn('Using Maps as children is not supported. ' + 'Use an array of keyed ReactElements instead.');
          }

          didWarnAboutMaps = true;
        }
      }

      var iterator = iteratorFn.call(iterableChildren);
      var step;
      var ii = 0;

      while (!(step = iterator.next()).done) {
        child = step.value;
        nextName = nextNamePrefix + getElementKey(child, ii++);
        subtreeCount += mapIntoArray(child, array, escapedPrefix, nextName, callback);
      }
    } else if (type === 'object') {
      var childrenString = '' + children;

      {
        {
          throw Error( "Objects are not valid as a React child (found: " + (childrenString === '[object Object]' ? 'object with keys {' + Object.keys(children).join(', ') + '}' : childrenString) + "). If you meant to render a collection of children, use an array instead." );
        }
      }
    }
  }

  return subtreeCount;
}

/**
 * Maps children that are typically specified as `props.children`.
 *
 * See https://reactjs.org/docs/react-api.html#reactchildrenmap
 *
 * The provided mapFunction(child, index) will be called for each
 * leaf child.
 *
 * @param {?*} children Children tree container.
 * @param {function(*, int)} func The map function.
 * @param {*} context Context for mapFunction.
 * @return {object} Object containing the ordered map of results.
 */
function mapChildren(children, func, context) {
  if (children == null) {
    return children;
  }

  var result = [];
  var count = 0;
  mapIntoArray(children, result, '', '', function (child) {
    return func.call(context, child, count++);
  });
  return result;
}
/**
 * Count the number of children that are typically specified as
 * `props.children`.
 *
 * See https://reactjs.org/docs/react-api.html#reactchildrencount
 *
 * @param {?*} children Children tree container.
 * @return {number} The number of children.
 */


function countChildren(children) {
  var n = 0;
  mapChildren(children, function () {
    n++; // Don't return anything
  });
  return n;
}

/**
 * Iterates through children that are typically specified as `props.children`.
 *
 * See https://reactjs.org/docs/react-api.html#reactchildrenforeach
 *
 * The provided forEachFunc(child, index) will be called for each
 * leaf child.
 *
 * @param {?*} children Children tree container.
 * @param {function(*, int)} forEachFunc
 * @param {*} forEachContext Context for forEachContext.
 */
function forEachChildren(children, forEachFunc, forEachContext) {
  mapChildren(children, function () {
    forEachFunc.apply(this, arguments); // Don't return anything.
  }, forEachContext);
}
/**
 * Flatten a children object (typically specified as `props.children`) and
 * return an array with appropriately re-keyed children.
 *
 * See https://reactjs.org/docs/react-api.html#reactchildrentoarray
 */


function toArray(children) {
  return mapChildren(children, function (child) {
    return child;
  }) || [];
}
/**
 * Returns the first child in a collection of children and verifies that there
 * is only one child in the collection.
 *
 * See https://reactjs.org/docs/react-api.html#reactchildrenonly
 *
 * The current implementation of this function assumes that a single child gets
 * passed without a wrapper, but the purpose of this helper function is to
 * abstract away the particular structure of children.
 *
 * @param {?object} children Child collection structure.
 * @return {ReactElement} The first and only `ReactElement` contained in the
 * structure.
 */


function onlyChild(children) {
  if (!isValidElement(children)) {
    {
      throw Error( "React.Children.only expected to receive a single React element child." );
    }
  }

  return children;
}

function createContext(defaultValue, calculateChangedBits) {
  if (calculateChangedBits === undefined) {
    calculateChangedBits = null;
  } else {
    {
      if (calculateChangedBits !== null && typeof calculateChangedBits !== 'function') {
        error('createContext: Expected the optional second argument to be a ' + 'function. Instead received: %s', calculateChangedBits);
      }
    }
  }

  var context = {
    $$typeof: REACT_CONTEXT_TYPE,
    _calculateChangedBits: calculateChangedBits,
    // As a workaround to support multiple concurrent renderers, we categorize
    // some renderers as primary and others as secondary. We only expect
    // there to be two concurrent renderers at most: React Native (primary) and
    // Fabric (secondary); React DOM (primary) and React ART (secondary).
    // Secondary renderers store their context values on separate fields.
    _currentValue: defaultValue,
    _currentValue2: defaultValue,
    // Used to track how many concurrent renderers this context currently
    // supports within in a single renderer. Such as parallel server rendering.
    _threadCount: 0,
    // These are circular
    Provider: null,
    Consumer: null
  };
  context.Provider = {
    $$typeof: REACT_PROVIDER_TYPE,
    _context: context
  };
  var hasWarnedAboutUsingNestedContextConsumers = false;
  var hasWarnedAboutUsingConsumerProvider = false;
  var hasWarnedAboutDisplayNameOnConsumer = false;

  {
    // A separate object, but proxies back to the original context object for
    // backwards compatibility. It has a different $$typeof, so we can properly
    // warn for the incorrect usage of Context as a Consumer.
    var Consumer = {
      $$typeof: REACT_CONTEXT_TYPE,
      _context: context,
      _calculateChangedBits: context._calculateChangedBits
    }; // $FlowFixMe: Flow complains about not setting a value, which is intentional here

    Object.defineProperties(Consumer, {
      Provider: {
        get: function () {
          if (!hasWarnedAboutUsingConsumerProvider) {
            hasWarnedAboutUsingConsumerProvider = true;

            error('Rendering <Context.Consumer.Provider> is not supported and will be removed in ' + 'a future major release. Did you mean to render <Context.Provider> instead?');
          }

          return context.Provider;
        },
        set: function (_Provider) {
          context.Provider = _Provider;
        }
      },
      _currentValue: {
        get: function () {
          return context._currentValue;
        },
        set: function (_currentValue) {
          context._currentValue = _currentValue;
        }
      },
      _currentValue2: {
        get: function () {
          return context._currentValue2;
        },
        set: function (_currentValue2) {
          context._currentValue2 = _currentValue2;
        }
      },
      _threadCount: {
        get: function () {
          return context._threadCount;
        },
        set: function (_threadCount) {
          context._threadCount = _threadCount;
        }
      },
      Consumer: {
        get: function () {
          if (!hasWarnedAboutUsingNestedContextConsumers) {
            hasWarnedAboutUsingNestedContextConsumers = true;

            error('Rendering <Context.Consumer.Consumer> is not supported and will be removed in ' + 'a future major release. Did you mean to render <Context.Consumer> instead?');
          }

          return context.Consumer;
        }
      },
      displayName: {
        get: function () {
          return context.displayName;
        },
        set: function (displayName) {
          if (!hasWarnedAboutDisplayNameOnConsumer) {
            warn('Setting `displayName` on Context.Consumer has no effect. ' + "You should set it directly on the context with Context.displayName = '%s'.", displayName);

            hasWarnedAboutDisplayNameOnConsumer = true;
          }
        }
      }
    }); // $FlowFixMe: Flow complains about missing properties because it doesn't understand defineProperty

    context.Consumer = Consumer;
  }

  {
    context._currentRenderer = null;
    context._currentRenderer2 = null;
  }

  return context;
}

var Uninitialized = -1;
var Pending = 0;
var Resolved = 1;
var Rejected = 2;

function lazyInitializer(payload) {
  if (payload._status === Uninitialized) {
    var ctor = payload._result;
    var thenable = ctor(); // Transition to the next state.

    var pending = payload;
    pending._status = Pending;
    pending._result = thenable;
    thenable.then(function (moduleObject) {
      if (payload._status === Pending) {
        var defaultExport = moduleObject.default;

        {
          if (defaultExport === undefined) {
            error('lazy: Expected the result of a dynamic import() call. ' + 'Instead received: %s\n\nYour code should look like: \n  ' + // Break up imports to avoid accidentally parsing them as dependencies.
            'const MyComponent = lazy(() => imp' + "ort('./MyComponent'))", moduleObject);
          }
        } // Transition to the next state.


        var resolved = payload;
        resolved._status = Resolved;
        resolved._result = defaultExport;
      }
    }, function (error) {
      if (payload._status === Pending) {
        // Transition to the next state.
        var rejected = payload;
        rejected._status = Rejected;
        rejected._result = error;
      }
    });
  }

  if (payload._status === Resolved) {
    return payload._result;
  } else {
    throw payload._result;
  }
}

function lazy(ctor) {
  var payload = {
    // We use these fields to store the result.
    _status: -1,
    _result: ctor
  };
  var lazyType = {
    $$typeof: REACT_LAZY_TYPE,
    _payload: payload,
    _init: lazyInitializer
  };

  {
    // In production, this would just set it on the object.
    var defaultProps;
    var propTypes; // $FlowFixMe

    Object.defineProperties(lazyType, {
      defaultProps: {
        configurable: true,
        get: function () {
          return defaultProps;
        },
        set: function (newDefaultProps) {
          error('React.lazy(...): It is not supported to assign `defaultProps` to ' + 'a lazy component import. Either specify them where the component ' + 'is defined, or create a wrapping component around it.');

          defaultProps = newDefaultProps; // Match production behavior more closely:
          // $FlowFixMe

          Object.defineProperty(lazyType, 'defaultProps', {
            enumerable: true
          });
        }
      },
      propTypes: {
        configurable: true,
        get: function () {
          return propTypes;
        },
        set: function (newPropTypes) {
          error('React.lazy(...): It is not supported to assign `propTypes` to ' + 'a lazy component import. Either specify them where the component ' + 'is defined, or create a wrapping component around it.');

          propTypes = newPropTypes; // Match production behavior more closely:
          // $FlowFixMe

          Object.defineProperty(lazyType, 'propTypes', {
            enumerable: true
          });
        }
      }
    });
  }

  return lazyType;
}

function forwardRef(render) {
  {
    if (render != null && render.$$typeof === REACT_MEMO_TYPE) {
      error('forwardRef requires a render function but received a `memo` ' + 'component. Instead of forwardRef(memo(...)), use ' + 'memo(forwardRef(...)).');
    } else if (typeof render !== 'function') {
      error('forwardRef requires a render function but was given %s.', render === null ? 'null' : typeof render);
    } else {
      if (render.length !== 0 && render.length !== 2) {
        error('forwardRef render functions accept exactly two parameters: props and ref. %s', render.length === 1 ? 'Did you forget to use the ref parameter?' : 'Any additional parameter will be undefined.');
      }
    }

    if (render != null) {
      if (render.defaultProps != null || render.propTypes != null) {
        error('forwardRef render functions do not support propTypes or defaultProps. ' + 'Did you accidentally pass a React component?');
      }
    }
  }

  var elementType = {
    $$typeof: REACT_FORWARD_REF_TYPE,
    render: render
  };

  {
    var ownName;
    Object.defineProperty(elementType, 'displayName', {
      enumerable: false,
      configurable: true,
      get: function () {
        return ownName;
      },
      set: function (name) {
        ownName = name;

        if (render.displayName == null) {
          render.displayName = name;
        }
      }
    });
  }

  return elementType;
}

// Filter certain DOM attributes (e.g. src, href) if their values are empty strings.

var enableScopeAPI = false; // Experimental Create Event Handle API.

function isValidElementType(type) {
  if (typeof type === 'string' || typeof type === 'function') {
    return true;
  } // Note: typeof might be other than 'symbol' or 'number' (e.g. if it's a polyfill).


  if (type === exports.Fragment || type === exports.Profiler || type === REACT_DEBUG_TRACING_MODE_TYPE || type === exports.StrictMode || type === exports.Suspense || type === REACT_SUSPENSE_LIST_TYPE || type === REACT_LEGACY_HIDDEN_TYPE || enableScopeAPI ) {
    return true;
  }

  if (typeof type === 'object' && type !== null) {
    if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_BLOCK_TYPE || type[0] === REACT_SERVER_BLOCK_TYPE) {
      return true;
    }
  }

  return false;
}

function memo(type, compare) {
  {
    if (!isValidElementType(type)) {
      error('memo: The first argument must be a component. Instead ' + 'received: %s', type === null ? 'null' : typeof type);
    }
  }

  var elementType = {
    $$typeof: REACT_MEMO_TYPE,
    type: type,
    compare: compare === undefined ? null : compare
  };

  {
    var ownName;
    Object.defineProperty(elementType, 'displayName', {
      enumerable: false,
      configurable: true,
      get: function () {
        return ownName;
      },
      set: function (name) {
        ownName = name;

        if (type.displayName == null) {
          type.displayName = name;
        }
      }
    });
  }

  return elementType;
}

function resolveDispatcher() {
  var dispatcher = ReactCurrentDispatcher.current;

  if (!(dispatcher !== null)) {
    {
      throw Error( "Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem." );
    }
  }

  return dispatcher;
}

function useContext(Context, unstable_observedBits) {
  var dispatcher = resolveDispatcher();

  {
    if (unstable_observedBits !== undefined) {
      error('useContext() second argument is reserved for future ' + 'use in React. Passing it is not supported. ' + 'You passed: %s.%s', unstable_observedBits, typeof unstable_observedBits === 'number' && Array.isArray(arguments[2]) ? '\n\nDid you call array.map(useContext)? ' + 'Calling Hooks inside a loop is not supported. ' + 'Learn more at https://reactjs.org/link/rules-of-hooks' : '');
    } // TODO: add a more generic warning for invalid values.


    if (Context._context !== undefined) {
      var realContext = Context._context; // Don't deduplicate because this legitimately causes bugs
      // and nobody should be using this in existing code.

      if (realContext.Consumer === Context) {
        error('Calling useContext(Context.Consumer) is not supported, may cause bugs, and will be ' + 'removed in a future major release. Did you mean to call useContext(Context) instead?');
      } else if (realContext.Provider === Context) {
        error('Calling useContext(Context.Provider) is not supported. ' + 'Did you mean to call useContext(Context) instead?');
      }
    }
  }

  return dispatcher.useContext(Context, unstable_observedBits);
}
function useState(initialState) {
  var dispatcher = resolveDispatcher();
  return dispatcher.useState(initialState);
}
function useReducer(reducer, initialArg, init) {
  var dispatcher = resolveDispatcher();
  return dispatcher.useReducer(reducer, initialArg, init);
}
function useRef(initialValue) {
  var dispatcher = resolveDispatcher();
  return dispatcher.useRef(initialValue);
}
function useEffect(create, deps) {
  var dispatcher = resolveDispatcher();
  return dispatcher.useEffect(create, deps);
}
function useLayoutEffect(create, deps) {
  var dispatcher = resolveDispatcher();
  return dispatcher.useLayoutEffect(create, deps);
}
function useCallback(callback, deps) {
  var dispatcher = resolveDispatcher();
  return dispatcher.useCallback(callback, deps);
}
function useMemo(create, deps) {
  var dispatcher = resolveDispatcher();
  return dispatcher.useMemo(create, deps);
}
function useImperativeHandle(ref, create, deps) {
  var dispatcher = resolveDispatcher();
  return dispatcher.useImperativeHandle(ref, create, deps);
}
function useDebugValue(value, formatterFn) {
  {
    var dispatcher = resolveDispatcher();
    return dispatcher.useDebugValue(value, formatterFn);
  }
}

// Helpers to patch console.logs to avoid logging during side-effect free
// replaying on render function. This currently only patches the object
// lazily which won't cover if the log function was extracted eagerly.
// We could also eagerly patch the method.
var disabledDepth = 0;
var prevLog;
var prevInfo;
var prevWarn;
var prevError;
var prevGroup;
var prevGroupCollapsed;
var prevGroupEnd;

function disabledLog() {}

disabledLog.__reactDisabledLog = true;
function disableLogs() {
  {
    if (disabledDepth === 0) {
      /* eslint-disable react-internal/no-production-logging */
      prevLog = console.log;
      prevInfo = console.info;
      prevWarn = console.warn;
      prevError = console.error;
      prevGroup = console.group;
      prevGroupCollapsed = console.groupCollapsed;
      prevGroupEnd = console.groupEnd; // https://github.com/facebook/react/issues/19099

      var props = {
        configurable: true,
        enumerable: true,
        value: disabledLog,
        writable: true
      }; // $FlowFixMe Flow thinks console is immutable.

      Object.defineProperties(console, {
        info: props,
        log: props,
        warn: props,
        error: props,
        group: props,
        groupCollapsed: props,
        groupEnd: props
      });
      /* eslint-enable react-internal/no-production-logging */
    }

    disabledDepth++;
  }
}
function reenableLogs() {
  {
    disabledDepth--;

    if (disabledDepth === 0) {
      /* eslint-disable react-internal/no-production-logging */
      var props = {
        configurable: true,
        enumerable: true,
        writable: true
      }; // $FlowFixMe Flow thinks console is immutable.

      Object.defineProperties(console, {
        log: _assign({}, props, {
          value: prevLog
        }),
        info: _assign({}, props, {
          value: prevInfo
        }),
        warn: _assign({}, props, {
          value: prevWarn
        }),
        error: _assign({}, props, {
          value: prevError
        }),
        group: _assign({}, props, {
          value: prevGroup
        }),
        groupCollapsed: _assign({}, props, {
          value: prevGroupCollapsed
        }),
        groupEnd: _assign({}, props, {
          value: prevGroupEnd
        })
      });
      /* eslint-enable react-internal/no-production-logging */
    }

    if (disabledDepth < 0) {
      error('disabledDepth fell below zero. ' + 'This is a bug in React. Please file an issue.');
    }
  }
}

var ReactCurrentDispatcher$1 = ReactSharedInternals.ReactCurrentDispatcher;
var prefix;
function describeBuiltInComponentFrame(name, source, ownerFn) {
  {
    if (prefix === undefined) {
      // Extract the VM specific prefix used by each line.
      try {
        throw Error();
      } catch (x) {
        var match = x.stack.trim().match(/\n( *(at )?)/);
        prefix = match && match[1] || '';
      }
    } // We use the prefix to ensure our stacks line up with native stack frames.


    return '\n' + prefix + name;
  }
}
var reentry = false;
var componentFrameCache;

{
  var PossiblyWeakMap = typeof WeakMap === 'function' ? WeakMap : Map;
  componentFrameCache = new PossiblyWeakMap();
}

function describeNativeComponentFrame(fn, construct) {
  // If something asked for a stack inside a fake render, it should get ignored.
  if (!fn || reentry) {
    return '';
  }

  {
    var frame = componentFrameCache.get(fn);

    if (frame !== undefined) {
      return frame;
    }
  }

  var control;
  reentry = true;
  var previousPrepareStackTrace = Error.prepareStackTrace; // $FlowFixMe It does accept undefined.

  Error.prepareStackTrace = undefined;
  var previousDispatcher;

  {
    previousDispatcher = ReactCurrentDispatcher$1.current; // Set the dispatcher in DEV because this might be call in the render function
    // for warnings.

    ReactCurrentDispatcher$1.current = null;
    disableLogs();
  }

  try {
    // This should throw.
    if (construct) {
      // Something should be setting the props in the constructor.
      var Fake = function () {
        throw Error();
      }; // $FlowFixMe


      Object.defineProperty(Fake.prototype, 'props', {
        set: function () {
          // We use a throwing setter instead of frozen or non-writable props
          // because that won't throw in a non-strict mode function.
          throw Error();
        }
      });

      if (typeof Reflect === 'object' && Reflect.construct) {
        // We construct a different control for this case to include any extra
        // frames added by the construct call.
        try {
          Reflect.construct(Fake, []);
        } catch (x) {
          control = x;
        }

        Reflect.construct(fn, [], Fake);
      } else {
        try {
          Fake.call();
        } catch (x) {
          control = x;
        }

        fn.call(Fake.prototype);
      }
    } else {
      try {
        throw Error();
      } catch (x) {
        control = x;
      }

      fn();
    }
  } catch (sample) {
    // This is inlined manually because closure doesn't do it for us.
    if (sample && control && typeof sample.stack === 'string') {
      // This extracts the first frame from the sample that isn't also in the control.
      // Skipping one frame that we assume is the frame that calls the two.
      var sampleLines = sample.stack.split('\n');
      var controlLines = control.stack.split('\n');
      var s = sampleLines.length - 1;
      var c = controlLines.length - 1;

      while (s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]) {
        // We expect at least one stack frame to be shared.
        // Typically this will be the root most one. However, stack frames may be
        // cut off due to maximum stack limits. In this case, one maybe cut off
        // earlier than the other. We assume that the sample is longer or the same
        // and there for cut off earlier. So we should find the root most frame in
        // the sample somewhere in the control.
        c--;
      }

      for (; s >= 1 && c >= 0; s--, c--) {
        // Next we find the first one that isn't the same which should be the
        // frame that called our sample function and the control.
        if (sampleLines[s] !== controlLines[c]) {
          // In V8, the first line is describing the message but other VMs don't.
          // If we're about to return the first line, and the control is also on the same
          // line, that's a pretty good indicator that our sample threw at same line as
          // the control. I.e. before we entered the sample frame. So we ignore this result.
          // This can happen if you passed a class to function component, or non-function.
          if (s !== 1 || c !== 1) {
            do {
              s--;
              c--; // We may still have similar intermediate frames from the construct call.
              // The next one that isn't the same should be our match though.

              if (c < 0 || sampleLines[s] !== controlLines[c]) {
                // V8 adds a "new" prefix for native classes. Let's remove it to make it prettier.
                var _frame = '\n' + sampleLines[s].replace(' at new ', ' at ');

                {
                  if (typeof fn === 'function') {
                    componentFrameCache.set(fn, _frame);
                  }
                } // Return the line we found.


                return _frame;
              }
            } while (s >= 1 && c >= 0);
          }

          break;
        }
      }
    }
  } finally {
    reentry = false;

    {
      ReactCurrentDispatcher$1.current = previousDispatcher;
      reenableLogs();
    }

    Error.prepareStackTrace = previousPrepareStackTrace;
  } // Fallback to just using the name if we couldn't make it throw.


  var name = fn ? fn.displayName || fn.name : '';
  var syntheticFrame = name ? describeBuiltInComponentFrame(name) : '';

  {
    if (typeof fn === 'function') {
      componentFrameCache.set(fn, syntheticFrame);
    }
  }

  return syntheticFrame;
}
function describeFunctionComponentFrame(fn, source, ownerFn) {
  {
    return describeNativeComponentFrame(fn, false);
  }
}

function shouldConstruct(Component) {
  var prototype = Component.prototype;
  return !!(prototype && prototype.isReactComponent);
}

function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {

  if (type == null) {
    return '';
  }

  if (typeof type === 'function') {
    {
      return describeNativeComponentFrame(type, shouldConstruct(type));
    }
  }

  if (typeof type === 'string') {
    return describeBuiltInComponentFrame(type);
  }

  switch (type) {
    case exports.Suspense:
      return describeBuiltInComponentFrame('Suspense');

    case REACT_SUSPENSE_LIST_TYPE:
      return describeBuiltInComponentFrame('SuspenseList');
  }

  if (typeof type === 'object') {
    switch (type.$$typeof) {
      case REACT_FORWARD_REF_TYPE:
        return describeFunctionComponentFrame(type.render);

      case REACT_MEMO_TYPE:
        // Memo may contain any component type so we recursively resolve it.
        return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);

      case REACT_BLOCK_TYPE:
        return describeFunctionComponentFrame(type._render);

      case REACT_LAZY_TYPE:
        {
          var lazyComponent = type;
          var payload = lazyComponent._payload;
          var init = lazyComponent._init;

          try {
            // Lazy may contain any component type so we recursively resolve it.
            return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);
          } catch (x) {}
        }
    }
  }

  return '';
}

var loggedTypeFailures = {};
var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;

function setCurrentlyValidatingElement(element) {
  {
    if (element) {
      var owner = element._owner;
      var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
      ReactDebugCurrentFrame$1.setExtraStackFrame(stack);
    } else {
      ReactDebugCurrentFrame$1.setExtraStackFrame(null);
    }
  }
}

function checkPropTypes(typeSpecs, values, location, componentName, element) {
  {
    // $FlowFixMe This is okay but Flow doesn't know it.
    var has = Function.call.bind(Object.prototype.hasOwnProperty);

    for (var typeSpecName in typeSpecs) {
      if (has(typeSpecs, typeSpecName)) {
        var error$1 = void 0; // Prop type validation may throw. In case they do, we don't want to
        // fail the render phase where it didn't fail before. So we log it.
        // After these have been cleaned up, we'll let them throw.

        try {
          // This is intentionally an invariant that gets caught. It's the same
          // behavior as without this statement except with a better message.
          if (typeof typeSpecs[typeSpecName] !== 'function') {
            var err = Error((componentName || 'React class') + ': ' + location + ' type `' + typeSpecName + '` is invalid; ' + 'it must be a function, usually from the `prop-types` package, but received `' + typeof typeSpecs[typeSpecName] + '`.' + 'This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.');
            err.name = 'Invariant Violation';
            throw err;
          }

          error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED');
        } catch (ex) {
          error$1 = ex;
        }

        if (error$1 && !(error$1 instanceof Error)) {
          setCurrentlyValidatingElement(element);

          error('%s: type specification of %s' + ' `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', location, typeSpecName, typeof error$1);

          setCurrentlyValidatingElement(null);
        }

        if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {
          // Only monitor this failure once because there tends to be a lot of the
          // same error.
          loggedTypeFailures[error$1.message] = true;
          setCurrentlyValidatingElement(element);

          error('Failed %s type: %s', location, error$1.message);

          setCurrentlyValidatingElement(null);
        }
      }
    }
  }
}

function setCurrentlyValidatingElement$1(element) {
  {
    if (element) {
      var owner = element._owner;
      var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
      setExtraStackFrame(stack);
    } else {
      setExtraStackFrame(null);
    }
  }
}

var propTypesMisspellWarningShown;

{
  propTypesMisspellWarningShown = false;
}

function getDeclarationErrorAddendum() {
  if (ReactCurrentOwner.current) {
    var name = getComponentName(ReactCurrentOwner.current.type);

    if (name) {
      return '\n\nCheck the render method of `' + name + '`.';
    }
  }

  return '';
}

function getSourceInfoErrorAddendum(source) {
  if (source !== undefined) {
    var fileName = source.fileName.replace(/^.*[\\\/]/, '');
    var lineNumber = source.lineNumber;
    return '\n\nCheck your code at ' + fileName + ':' + lineNumber + '.';
  }

  return '';
}

function getSourceInfoErrorAddendumForProps(elementProps) {
  if (elementProps !== null && elementProps !== undefined) {
    return getSourceInfoErrorAddendum(elementProps.__source);
  }

  return '';
}
/**
 * Warn if there's no key explicitly set on dynamic arrays of children or
 * object keys are not valid. This allows us to keep track of children between
 * updates.
 */


var ownerHasKeyUseWarning = {};

function getCurrentComponentErrorInfo(parentType) {
  var info = getDeclarationErrorAddendum();

  if (!info) {
    var parentName = typeof parentType === 'string' ? parentType : parentType.displayName || parentType.name;

    if (parentName) {
      info = "\n\nCheck the top-level render call using <" + parentName + ">.";
    }
  }

  return info;
}
/**
 * Warn if the element doesn't have an explicit key assigned to it.
 * This element is in an array. The array could grow and shrink or be
 * reordered. All children that haven't already been validated are required to
 * have a "key" property assigned to it. Error statuses are cached so a warning
 * will only be shown once.
 *
 * @internal
 * @param {ReactElement} element Element that requires a key.
 * @param {*} parentType element's parent's type.
 */


function validateExplicitKey(element, parentType) {
  if (!element._store || element._store.validated || element.key != null) {
    return;
  }

  element._store.validated = true;
  var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);

  if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {
    return;
  }

  ownerHasKeyUseWarning[currentComponentErrorInfo] = true; // Usually the current owner is the offender, but if it accepts children as a
  // property, it may be the creator of the child that's responsible for
  // assigning it a key.

  var childOwner = '';

  if (element && element._owner && element._owner !== ReactCurrentOwner.current) {
    // Give the component that originally created this child.
    childOwner = " It was passed a child from " + getComponentName(element._owner.type) + ".";
  }

  {
    setCurrentlyValidatingElement$1(element);

    error('Each child in a list should have a unique "key" prop.' + '%s%s See https://reactjs.org/link/warning-keys for more information.', currentComponentErrorInfo, childOwner);

    setCurrentlyValidatingElement$1(null);
  }
}
/**
 * Ensure that every element either is passed in a static location, in an
 * array with an explicit keys property defined, or in an object literal
 * with valid key property.
 *
 * @internal
 * @param {ReactNode} node Statically passed child of any type.
 * @param {*} parentType node's parent's type.
 */


function validateChildKeys(node, parentType) {
  if (typeof node !== 'object') {
    return;
  }

  if (Array.isArray(node)) {
    for (var i = 0; i < node.length; i++) {
      var child = node[i];

      if (isValidElement(child)) {
        validateExplicitKey(child, parentType);
      }
    }
  } else if (isValidElement(node)) {
    // This element was passed in a valid location.
    if (node._store) {
      node._store.validated = true;
    }
  } else if (node) {
    var iteratorFn = getIteratorFn(node);

    if (typeof iteratorFn === 'function') {
      // Entry iterators used to provide implicit keys,
      // but now we print a separate warning for them later.
      if (iteratorFn !== node.entries) {
        var iterator = iteratorFn.call(node);
        var step;

        while (!(step = iterator.next()).done) {
          if (isValidElement(step.value)) {
            validateExplicitKey(step.value, parentType);
          }
        }
      }
    }
  }
}
/**
 * Given an element, validate that its props follow the propTypes definition,
 * provided by the type.
 *
 * @param {ReactElement} element
 */


function validatePropTypes(element) {
  {
    var type = element.type;

    if (type === null || type === undefined || typeof type === 'string') {
      return;
    }

    var propTypes;

    if (typeof type === 'function') {
      propTypes = type.propTypes;
    } else if (typeof type === 'object' && (type.$$typeof === REACT_FORWARD_REF_TYPE || // Note: Memo only checks outer props here.
    // Inner props are checked in the reconciler.
    type.$$typeof === REACT_MEMO_TYPE)) {
      propTypes = type.propTypes;
    } else {
      return;
    }

    if (propTypes) {
      // Intentionally inside to avoid triggering lazy initializers:
      var name = getComponentName(type);
      checkPropTypes(propTypes, element.props, 'prop', name, element);
    } else if (type.PropTypes !== undefined && !propTypesMisspellWarningShown) {
      propTypesMisspellWarningShown = true; // Intentionally inside to avoid triggering lazy initializers:

      var _name = getComponentName(type);

      error('Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?', _name || 'Unknown');
    }

    if (typeof type.getDefaultProps === 'function' && !type.getDefaultProps.isReactClassApproved) {
      error('getDefaultProps is only used on classic React.createClass ' + 'definitions. Use a static property named `defaultProps` instead.');
    }
  }
}
/**
 * Given a fragment, validate that it can only be provided with fragment props
 * @param {ReactElement} fragment
 */


function validateFragmentProps(fragment) {
  {
    var keys = Object.keys(fragment.props);

    for (var i = 0; i < keys.length; i++) {
      var key = keys[i];

      if (key !== 'children' && key !== 'key') {
        setCurrentlyValidatingElement$1(fragment);

        error('Invalid prop `%s` supplied to `React.Fragment`. ' + 'React.Fragment can only have `key` and `children` props.', key);

        setCurrentlyValidatingElement$1(null);
        break;
      }
    }

    if (fragment.ref !== null) {
      setCurrentlyValidatingElement$1(fragment);

      error('Invalid attribute `ref` supplied to `React.Fragment`.');

      setCurrentlyValidatingElement$1(null);
    }
  }
}
function createElementWithValidation(type, props, children) {
  var validType = isValidElementType(type); // We warn in this case but don't throw. We expect the element creation to
  // succeed and there will likely be errors in render.

  if (!validType) {
    var info = '';

    if (type === undefined || typeof type === 'object' && type !== null && Object.keys(type).length === 0) {
      info += ' You likely forgot to export your component from the file ' + "it's defined in, or you might have mixed up default and named imports.";
    }

    var sourceInfo = getSourceInfoErrorAddendumForProps(props);

    if (sourceInfo) {
      info += sourceInfo;
    } else {
      info += getDeclarationErrorAddendum();
    }

    var typeString;

    if (type === null) {
      typeString = 'null';
    } else if (Array.isArray(type)) {
      typeString = 'array';
    } else if (type !== undefined && type.$$typeof === REACT_ELEMENT_TYPE) {
      typeString = "<" + (getComponentName(type.type) || 'Unknown') + " />";
      info = ' Did you accidentally export a JSX literal instead of a component?';
    } else {
      typeString = typeof type;
    }

    {
      error('React.createElement: type is invalid -- expected a string (for ' + 'built-in components) or a class/function (for composite ' + 'components) but got: %s.%s', typeString, info);
    }
  }

  var element = createElement.apply(this, arguments); // The result can be nullish if a mock or a custom function is used.
  // TODO: Drop this when these are no longer allowed as the type argument.

  if (element == null) {
    return element;
  } // Skip key warning if the type isn't valid since our key validation logic
  // doesn't expect a non-string/function type and can throw confusing errors.
  // We don't want exception behavior to differ between dev and prod.
  // (Rendering will throw with a helpful message and as soon as the type is
  // fixed, the key warnings will appear.)


  if (validType) {
    for (var i = 2; i < arguments.length; i++) {
      validateChildKeys(arguments[i], type);
    }
  }

  if (type === exports.Fragment) {
    validateFragmentProps(element);
  } else {
    validatePropTypes(element);
  }

  return element;
}
var didWarnAboutDeprecatedCreateFactory = false;
function createFactoryWithValidation(type) {
  var validatedFactory = createElementWithValidation.bind(null, type);
  validatedFactory.type = type;

  {
    if (!didWarnAboutDeprecatedCreateFactory) {
      didWarnAboutDeprecatedCreateFactory = true;

      warn('React.createFactory() is deprecated and will be removed in ' + 'a future major release. Consider using JSX ' + 'or use React.createElement() directly instead.');
    } // Legacy hook: remove it


    Object.defineProperty(validatedFactory, 'type', {
      enumerable: false,
      get: function () {
        warn('Factory.type is deprecated. Access the class directly ' + 'before passing it to createFactory.');

        Object.defineProperty(this, 'type', {
          value: type
        });
        return type;
      }
    });
  }

  return validatedFactory;
}
function cloneElementWithValidation(element, props, children) {
  var newElement = cloneElement.apply(this, arguments);

  for (var i = 2; i < arguments.length; i++) {
    validateChildKeys(arguments[i], newElement.type);
  }

  validatePropTypes(newElement);
  return newElement;
}

{

  try {
    var frozenObject = Object.freeze({});
    /* eslint-disable no-new */

    new Map([[frozenObject, null]]);
    new Set([frozenObject]);
    /* eslint-enable no-new */
  } catch (e) {
  }
}

var createElement$1 =  createElementWithValidation ;
var cloneElement$1 =  cloneElementWithValidation ;
var createFactory =  createFactoryWithValidation ;
var Children = {
  map: mapChildren,
  forEach: forEachChildren,
  count: countChildren,
  toArray: toArray,
  only: onlyChild
};

exports.Children = Children;
exports.Component = Component;
exports.PureComponent = PureComponent;
exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = ReactSharedInternals;
exports.cloneElement = cloneElement$1;
exports.createContext = createContext;
exports.createElement = createElement$1;
exports.createFactory = createFactory;
exports.createRef = createRef;
exports.forwardRef = forwardRef;
exports.isValidElement = isValidElement;
exports.lazy = lazy;
exports.memo = memo;
exports.useCallback = useCallback;
exports.useContext = useContext;
exports.useDebugValue = useDebugValue;
exports.useEffect = useEffect;
exports.useImperativeHandle = useImperativeHandle;
exports.useLayoutEffect = useLayoutEffect;
exports.useMemo = useMemo;
exports.useReducer = useReducer;
exports.useRef = useRef;
exports.useState = useState;
exports.version = ReactVersion;
  })();
}


/***/ }),

/***/ "./node_modules/react/index.js":
/*!*************************************!*\
  !*** ./node_modules/react/index.js ***!
  \*************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


if (false) {} else {
  module.exports = __webpack_require__(/*! ./cjs/react.development.js */ "./node_modules/react/cjs/react.development.js");
}


/***/ }),

/***/ "./node_modules/scheduler/cjs/scheduler-tracing.development.js":
/*!*********************************************************************!*\
  !*** ./node_modules/scheduler/cjs/scheduler-tracing.development.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
/** @license React v0.20.2
 * scheduler-tracing.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



if (true) {
  (function() {
'use strict';

var DEFAULT_THREAD_ID = 0; // Counters used to generate unique IDs.

var interactionIDCounter = 0;
var threadIDCounter = 0; // Set of currently traced interactions.
// Interactions "stack"
// Meaning that newly traced interactions are appended to the previously active set.
// When an interaction goes out of scope, the previous set (if any) is restored.

exports.__interactionsRef = null; // Listener(s) to notify when interactions begin and end.

exports.__subscriberRef = null;

{
  exports.__interactionsRef = {
    current: new Set()
  };
  exports.__subscriberRef = {
    current: null
  };
}
function unstable_clear(callback) {

  var prevInteractions = exports.__interactionsRef.current;
  exports.__interactionsRef.current = new Set();

  try {
    return callback();
  } finally {
    exports.__interactionsRef.current = prevInteractions;
  }
}
function unstable_getCurrent() {
  {
    return exports.__interactionsRef.current;
  }
}
function unstable_getThreadID() {
  return ++threadIDCounter;
}
function unstable_trace(name, timestamp, callback) {
  var threadID = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : DEFAULT_THREAD_ID;

  var interaction = {
    __count: 1,
    id: interactionIDCounter++,
    name: name,
    timestamp: timestamp
  };
  var prevInteractions = exports.__interactionsRef.current; // Traced interactions should stack/accumulate.
  // To do that, clone the current interactions.
  // The previous set will be restored upon completion.

  var interactions = new Set(prevInteractions);
  interactions.add(interaction);
  exports.__interactionsRef.current = interactions;
  var subscriber = exports.__subscriberRef.current;
  var returnValue;

  try {
    if (subscriber !== null) {
      subscriber.onInteractionTraced(interaction);
    }
  } finally {
    try {
      if (subscriber !== null) {
        subscriber.onWorkStarted(interactions, threadID);
      }
    } finally {
      try {
        returnValue = callback();
      } finally {
        exports.__interactionsRef.current = prevInteractions;

        try {
          if (subscriber !== null) {
            subscriber.onWorkStopped(interactions, threadID);
          }
        } finally {
          interaction.__count--; // If no async work was scheduled for this interaction,
          // Notify subscribers that it's completed.

          if (subscriber !== null && interaction.__count === 0) {
            subscriber.onInteractionScheduledWorkCompleted(interaction);
          }
        }
      }
    }
  }

  return returnValue;
}
function unstable_wrap(callback) {
  var threadID = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DEFAULT_THREAD_ID;

  var wrappedInteractions = exports.__interactionsRef.current;
  var subscriber = exports.__subscriberRef.current;

  if (subscriber !== null) {
    subscriber.onWorkScheduled(wrappedInteractions, threadID);
  } // Update the pending async work count for the current interactions.
  // Update after calling subscribers in case of error.


  wrappedInteractions.forEach(function (interaction) {
    interaction.__count++;
  });
  var hasRun = false;

  function wrapped() {
    var prevInteractions = exports.__interactionsRef.current;
    exports.__interactionsRef.current = wrappedInteractions;
    subscriber = exports.__subscriberRef.current;

    try {
      var returnValue;

      try {
        if (subscriber !== null) {
          subscriber.onWorkStarted(wrappedInteractions, threadID);
        }
      } finally {
        try {
          returnValue = callback.apply(undefined, arguments);
        } finally {
          exports.__interactionsRef.current = prevInteractions;

          if (subscriber !== null) {
            subscriber.onWorkStopped(wrappedInteractions, threadID);
          }
        }
      }

      return returnValue;
    } finally {
      if (!hasRun) {
        // We only expect a wrapped function to be executed once,
        // But in the event that it's executed more than once
        // Only decrement the outstanding interaction counts once.
        hasRun = true; // Update pending async counts for all wrapped interactions.
        // If this was the last scheduled async work for any of them,
        // Mark them as completed.

        wrappedInteractions.forEach(function (interaction) {
          interaction.__count--;

          if (subscriber !== null && interaction.__count === 0) {
            subscriber.onInteractionScheduledWorkCompleted(interaction);
          }
        });
      }
    }
  }

  wrapped.cancel = function cancel() {
    subscriber = exports.__subscriberRef.current;

    try {
      if (subscriber !== null) {
        subscriber.onWorkCanceled(wrappedInteractions, threadID);
      }
    } finally {
      // Update pending async counts for all wrapped interactions.
      // If this was the last scheduled async work for any of them,
      // Mark them as completed.
      wrappedInteractions.forEach(function (interaction) {
        interaction.__count--;

        if (subscriber && interaction.__count === 0) {
          subscriber.onInteractionScheduledWorkCompleted(interaction);
        }
      });
    }
  };

  return wrapped;
}

var subscribers = null;

{
  subscribers = new Set();
}

function unstable_subscribe(subscriber) {
  {
    subscribers.add(subscriber);

    if (subscribers.size === 1) {
      exports.__subscriberRef.current = {
        onInteractionScheduledWorkCompleted: onInteractionScheduledWorkCompleted,
        onInteractionTraced: onInteractionTraced,
        onWorkCanceled: onWorkCanceled,
        onWorkScheduled: onWorkScheduled,
        onWorkStarted: onWorkStarted,
        onWorkStopped: onWorkStopped
      };
    }
  }
}
function unstable_unsubscribe(subscriber) {
  {
    subscribers.delete(subscriber);

    if (subscribers.size === 0) {
      exports.__subscriberRef.current = null;
    }
  }
}

function onInteractionTraced(interaction) {
  var didCatchError = false;
  var caughtError = null;
  subscribers.forEach(function (subscriber) {
    try {
      subscriber.onInteractionTraced(interaction);
    } catch (error) {
      if (!didCatchError) {
        didCatchError = true;
        caughtError = error;
      }
    }
  });

  if (didCatchError) {
    throw caughtError;
  }
}

function onInteractionScheduledWorkCompleted(interaction) {
  var didCatchError = false;
  var caughtError = null;
  subscribers.forEach(function (subscriber) {
    try {
      subscriber.onInteractionScheduledWorkCompleted(interaction);
    } catch (error) {
      if (!didCatchError) {
        didCatchError = true;
        caughtError = error;
      }
    }
  });

  if (didCatchError) {
    throw caughtError;
  }
}

function onWorkScheduled(interactions, threadID) {
  var didCatchError = false;
  var caughtError = null;
  subscribers.forEach(function (subscriber) {
    try {
      subscriber.onWorkScheduled(interactions, threadID);
    } catch (error) {
      if (!didCatchError) {
        didCatchError = true;
        caughtError = error;
      }
    }
  });

  if (didCatchError) {
    throw caughtError;
  }
}

function onWorkStarted(interactions, threadID) {
  var didCatchError = false;
  var caughtError = null;
  subscribers.forEach(function (subscriber) {
    try {
      subscriber.onWorkStarted(interactions, threadID);
    } catch (error) {
      if (!didCatchError) {
        didCatchError = true;
        caughtError = error;
      }
    }
  });

  if (didCatchError) {
    throw caughtError;
  }
}

function onWorkStopped(interactions, threadID) {
  var didCatchError = false;
  var caughtError = null;
  subscribers.forEach(function (subscriber) {
    try {
      subscriber.onWorkStopped(interactions, threadID);
    } catch (error) {
      if (!didCatchError) {
        didCatchError = true;
        caughtError = error;
      }
    }
  });

  if (didCatchError) {
    throw caughtError;
  }
}

function onWorkCanceled(interactions, threadID) {
  var didCatchError = false;
  var caughtError = null;
  subscribers.forEach(function (subscriber) {
    try {
      subscriber.onWorkCanceled(interactions, threadID);
    } catch (error) {
      if (!didCatchError) {
        didCatchError = true;
        caughtError = error;
      }
    }
  });

  if (didCatchError) {
    throw caughtError;
  }
}

exports.unstable_clear = unstable_clear;
exports.unstable_getCurrent = unstable_getCurrent;
exports.unstable_getThreadID = unstable_getThreadID;
exports.unstable_subscribe = unstable_subscribe;
exports.unstable_trace = unstable_trace;
exports.unstable_unsubscribe = unstable_unsubscribe;
exports.unstable_wrap = unstable_wrap;
  })();
}


/***/ }),

/***/ "./node_modules/scheduler/cjs/scheduler.development.js":
/*!*************************************************************!*\
  !*** ./node_modules/scheduler/cjs/scheduler.development.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
/** @license React v0.20.2
 * scheduler.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



if (true) {
  (function() {
'use strict';

var enableSchedulerDebugging = false;
var enableProfiling = false;

var requestHostCallback;
var requestHostTimeout;
var cancelHostTimeout;
var requestPaint;
var hasPerformanceNow = typeof performance === 'object' && typeof performance.now === 'function';

if (hasPerformanceNow) {
  var localPerformance = performance;

  exports.unstable_now = function () {
    return localPerformance.now();
  };
} else {
  var localDate = Date;
  var initialTime = localDate.now();

  exports.unstable_now = function () {
    return localDate.now() - initialTime;
  };
}

if ( // If Scheduler runs in a non-DOM environment, it falls back to a naive
// implementation using setTimeout.
typeof window === 'undefined' || // Check if MessageChannel is supported, too.
typeof MessageChannel !== 'function') {
  // If this accidentally gets imported in a non-browser environment, e.g. JavaScriptCore,
  // fallback to a naive implementation.
  var _callback = null;
  var _timeoutID = null;

  var _flushCallback = function () {
    if (_callback !== null) {
      try {
        var currentTime = exports.unstable_now();
        var hasRemainingTime = true;

        _callback(hasRemainingTime, currentTime);

        _callback = null;
      } catch (e) {
        setTimeout(_flushCallback, 0);
        throw e;
      }
    }
  };

  requestHostCallback = function (cb) {
    if (_callback !== null) {
      // Protect against re-entrancy.
      setTimeout(requestHostCallback, 0, cb);
    } else {
      _callback = cb;
      setTimeout(_flushCallback, 0);
    }
  };

  requestHostTimeout = function (cb, ms) {
    _timeoutID = setTimeout(cb, ms);
  };

  cancelHostTimeout = function () {
    clearTimeout(_timeoutID);
  };

  exports.unstable_shouldYield = function () {
    return false;
  };

  requestPaint = exports.unstable_forceFrameRate = function () {};
} else {
  // Capture local references to native APIs, in case a polyfill overrides them.
  var _setTimeout = window.setTimeout;
  var _clearTimeout = window.clearTimeout;

  if (typeof console !== 'undefined') {
    // TODO: Scheduler no longer requires these methods to be polyfilled. But
    // maybe we want to continue warning if they don't exist, to preserve the
    // option to rely on it in the future?
    var requestAnimationFrame = window.requestAnimationFrame;
    var cancelAnimationFrame = window.cancelAnimationFrame;

    if (typeof requestAnimationFrame !== 'function') {
      // Using console['error'] to evade Babel and ESLint
      console['error']("This browser doesn't support requestAnimationFrame. " + 'Make sure that you load a ' + 'polyfill in older browsers. https://reactjs.org/link/react-polyfills');
    }

    if (typeof cancelAnimationFrame !== 'function') {
      // Using console['error'] to evade Babel and ESLint
      console['error']("This browser doesn't support cancelAnimationFrame. " + 'Make sure that you load a ' + 'polyfill in older browsers. https://reactjs.org/link/react-polyfills');
    }
  }

  var isMessageLoopRunning = false;
  var scheduledHostCallback = null;
  var taskTimeoutID = -1; // Scheduler periodically yields in case there is other work on the main
  // thread, like user events. By default, it yields multiple times per frame.
  // It does not attempt to align with frame boundaries, since most tasks don't
  // need to be frame aligned; for those that do, use requestAnimationFrame.

  var yieldInterval = 5;
  var deadline = 0; // TODO: Make this configurable

  {
    // `isInputPending` is not available. Since we have no way of knowing if
    // there's pending input, always yield at the end of the frame.
    exports.unstable_shouldYield = function () {
      return exports.unstable_now() >= deadline;
    }; // Since we yield every frame regardless, `requestPaint` has no effect.


    requestPaint = function () {};
  }

  exports.unstable_forceFrameRate = function (fps) {
    if (fps < 0 || fps > 125) {
      // Using console['error'] to evade Babel and ESLint
      console['error']('forceFrameRate takes a positive int between 0 and 125, ' + 'forcing frame rates higher than 125 fps is not supported');
      return;
    }

    if (fps > 0) {
      yieldInterval = Math.floor(1000 / fps);
    } else {
      // reset the framerate
      yieldInterval = 5;
    }
  };

  var performWorkUntilDeadline = function () {
    if (scheduledHostCallback !== null) {
      var currentTime = exports.unstable_now(); // Yield after `yieldInterval` ms, regardless of where we are in the vsync
      // cycle. This means there's always time remaining at the beginning of
      // the message event.

      deadline = currentTime + yieldInterval;
      var hasTimeRemaining = true;

      try {
        var hasMoreWork = scheduledHostCallback(hasTimeRemaining, currentTime);

        if (!hasMoreWork) {
          isMessageLoopRunning = false;
          scheduledHostCallback = null;
        } else {
          // If there's more work, schedule the next message event at the end
          // of the preceding one.
          port.postMessage(null);
        }
      } catch (error) {
        // If a scheduler task throws, exit the current browser task so the
        // error can be observed.
        port.postMessage(null);
        throw error;
      }
    } else {
      isMessageLoopRunning = false;
    } // Yielding to the browser will give it a chance to paint, so we can
  };

  var channel = new MessageChannel();
  var port = channel.port2;
  channel.port1.onmessage = performWorkUntilDeadline;

  requestHostCallback = function (callback) {
    scheduledHostCallback = callback;

    if (!isMessageLoopRunning) {
      isMessageLoopRunning = true;
      port.postMessage(null);
    }
  };

  requestHostTimeout = function (callback, ms) {
    taskTimeoutID = _setTimeout(function () {
      callback(exports.unstable_now());
    }, ms);
  };

  cancelHostTimeout = function () {
    _clearTimeout(taskTimeoutID);

    taskTimeoutID = -1;
  };
}

function push(heap, node) {
  var index = heap.length;
  heap.push(node);
  siftUp(heap, node, index);
}
function peek(heap) {
  var first = heap[0];
  return first === undefined ? null : first;
}
function pop(heap) {
  var first = heap[0];

  if (first !== undefined) {
    var last = heap.pop();

    if (last !== first) {
      heap[0] = last;
      siftDown(heap, last, 0);
    }

    return first;
  } else {
    return null;
  }
}

function siftUp(heap, node, i) {
  var index = i;

  while (true) {
    var parentIndex = index - 1 >>> 1;
    var parent = heap[parentIndex];

    if (parent !== undefined && compare(parent, node) > 0) {
      // The parent is larger. Swap positions.
      heap[parentIndex] = node;
      heap[index] = parent;
      index = parentIndex;
    } else {
      // The parent is smaller. Exit.
      return;
    }
  }
}

function siftDown(heap, node, i) {
  var index = i;
  var length = heap.length;

  while (index < length) {
    var leftIndex = (index + 1) * 2 - 1;
    var left = heap[leftIndex];
    var rightIndex = leftIndex + 1;
    var right = heap[rightIndex]; // If the left or right node is smaller, swap with the smaller of those.

    if (left !== undefined && compare(left, node) < 0) {
      if (right !== undefined && compare(right, left) < 0) {
        heap[index] = right;
        heap[rightIndex] = node;
        index = rightIndex;
      } else {
        heap[index] = left;
        heap[leftIndex] = node;
        index = leftIndex;
      }
    } else if (right !== undefined && compare(right, node) < 0) {
      heap[index] = right;
      heap[rightIndex] = node;
      index = rightIndex;
    } else {
      // Neither child is smaller. Exit.
      return;
    }
  }
}

function compare(a, b) {
  // Compare sort index first, then task id.
  var diff = a.sortIndex - b.sortIndex;
  return diff !== 0 ? diff : a.id - b.id;
}

// TODO: Use symbols?
var ImmediatePriority = 1;
var UserBlockingPriority = 2;
var NormalPriority = 3;
var LowPriority = 4;
var IdlePriority = 5;

function markTaskErrored(task, ms) {
}

/* eslint-disable no-var */
// Math.pow(2, 30) - 1
// 0b111111111111111111111111111111

var maxSigned31BitInt = 1073741823; // Times out immediately

var IMMEDIATE_PRIORITY_TIMEOUT = -1; // Eventually times out

var USER_BLOCKING_PRIORITY_TIMEOUT = 250;
var NORMAL_PRIORITY_TIMEOUT = 5000;
var LOW_PRIORITY_TIMEOUT = 10000; // Never times out

var IDLE_PRIORITY_TIMEOUT = maxSigned31BitInt; // Tasks are stored on a min heap

var taskQueue = [];
var timerQueue = []; // Incrementing id counter. Used to maintain insertion order.

var taskIdCounter = 1; // Pausing the scheduler is useful for debugging.
var currentTask = null;
var currentPriorityLevel = NormalPriority; // This is set while performing work, to prevent re-entrancy.

var isPerformingWork = false;
var isHostCallbackScheduled = false;
var isHostTimeoutScheduled = false;

function advanceTimers(currentTime) {
  // Check for tasks that are no longer delayed and add them to the queue.
  var timer = peek(timerQueue);

  while (timer !== null) {
    if (timer.callback === null) {
      // Timer was cancelled.
      pop(timerQueue);
    } else if (timer.startTime <= currentTime) {
      // Timer fired. Transfer to the task queue.
      pop(timerQueue);
      timer.sortIndex = timer.expirationTime;
      push(taskQueue, timer);
    } else {
      // Remaining timers are pending.
      return;
    }

    timer = peek(timerQueue);
  }
}

function handleTimeout(currentTime) {
  isHostTimeoutScheduled = false;
  advanceTimers(currentTime);

  if (!isHostCallbackScheduled) {
    if (peek(taskQueue) !== null) {
      isHostCallbackScheduled = true;
      requestHostCallback(flushWork);
    } else {
      var firstTimer = peek(timerQueue);

      if (firstTimer !== null) {
        requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);
      }
    }
  }
}

function flushWork(hasTimeRemaining, initialTime) {


  isHostCallbackScheduled = false;

  if (isHostTimeoutScheduled) {
    // We scheduled a timeout but it's no longer needed. Cancel it.
    isHostTimeoutScheduled = false;
    cancelHostTimeout();
  }

  isPerformingWork = true;
  var previousPriorityLevel = currentPriorityLevel;

  try {
    if (enableProfiling) {
      try {
        return workLoop(hasTimeRemaining, initialTime);
      } catch (error) {
        if (currentTask !== null) {
          var currentTime = exports.unstable_now();
          markTaskErrored(currentTask, currentTime);
          currentTask.isQueued = false;
        }

        throw error;
      }
    } else {
      // No catch in prod code path.
      return workLoop(hasTimeRemaining, initialTime);
    }
  } finally {
    currentTask = null;
    currentPriorityLevel = previousPriorityLevel;
    isPerformingWork = false;
  }
}

function workLoop(hasTimeRemaining, initialTime) {
  var currentTime = initialTime;
  advanceTimers(currentTime);
  currentTask = peek(taskQueue);

  while (currentTask !== null && !(enableSchedulerDebugging )) {
    if (currentTask.expirationTime > currentTime && (!hasTimeRemaining || exports.unstable_shouldYield())) {
      // This currentTask hasn't expired, and we've reached the deadline.
      break;
    }

    var callback = currentTask.callback;

    if (typeof callback === 'function') {
      currentTask.callback = null;
      currentPriorityLevel = currentTask.priorityLevel;
      var didUserCallbackTimeout = currentTask.expirationTime <= currentTime;

      var continuationCallback = callback(didUserCallbackTimeout);
      currentTime = exports.unstable_now();

      if (typeof continuationCallback === 'function') {
        currentTask.callback = continuationCallback;
      } else {

        if (currentTask === peek(taskQueue)) {
          pop(taskQueue);
        }
      }

      advanceTimers(currentTime);
    } else {
      pop(taskQueue);
    }

    currentTask = peek(taskQueue);
  } // Return whether there's additional work


  if (currentTask !== null) {
    return true;
  } else {
    var firstTimer = peek(timerQueue);

    if (firstTimer !== null) {
      requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);
    }

    return false;
  }
}

function unstable_runWithPriority(priorityLevel, eventHandler) {
  switch (priorityLevel) {
    case ImmediatePriority:
    case UserBlockingPriority:
    case NormalPriority:
    case LowPriority:
    case IdlePriority:
      break;

    default:
      priorityLevel = NormalPriority;
  }

  var previousPriorityLevel = currentPriorityLevel;
  currentPriorityLevel = priorityLevel;

  try {
    return eventHandler();
  } finally {
    currentPriorityLevel = previousPriorityLevel;
  }
}

function unstable_next(eventHandler) {
  var priorityLevel;

  switch (currentPriorityLevel) {
    case ImmediatePriority:
    case UserBlockingPriority:
    case NormalPriority:
      // Shift down to normal priority
      priorityLevel = NormalPriority;
      break;

    default:
      // Anything lower than normal priority should remain at the current level.
      priorityLevel = currentPriorityLevel;
      break;
  }

  var previousPriorityLevel = currentPriorityLevel;
  currentPriorityLevel = priorityLevel;

  try {
    return eventHandler();
  } finally {
    currentPriorityLevel = previousPriorityLevel;
  }
}

function unstable_wrapCallback(callback) {
  var parentPriorityLevel = currentPriorityLevel;
  return function () {
    // This is a fork of runWithPriority, inlined for performance.
    var previousPriorityLevel = currentPriorityLevel;
    currentPriorityLevel = parentPriorityLevel;

    try {
      return callback.apply(this, arguments);
    } finally {
      currentPriorityLevel = previousPriorityLevel;
    }
  };
}

function unstable_scheduleCallback(priorityLevel, callback, options) {
  var currentTime = exports.unstable_now();
  var startTime;

  if (typeof options === 'object' && options !== null) {
    var delay = options.delay;

    if (typeof delay === 'number' && delay > 0) {
      startTime = currentTime + delay;
    } else {
      startTime = currentTime;
    }
  } else {
    startTime = currentTime;
  }

  var timeout;

  switch (priorityLevel) {
    case ImmediatePriority:
      timeout = IMMEDIATE_PRIORITY_TIMEOUT;
      break;

    case UserBlockingPriority:
      timeout = USER_BLOCKING_PRIORITY_TIMEOUT;
      break;

    case IdlePriority:
      timeout = IDLE_PRIORITY_TIMEOUT;
      break;

    case LowPriority:
      timeout = LOW_PRIORITY_TIMEOUT;
      break;

    case NormalPriority:
    default:
      timeout = NORMAL_PRIORITY_TIMEOUT;
      break;
  }

  var expirationTime = startTime + timeout;
  var newTask = {
    id: taskIdCounter++,
    callback: callback,
    priorityLevel: priorityLevel,
    startTime: startTime,
    expirationTime: expirationTime,
    sortIndex: -1
  };

  if (startTime > currentTime) {
    // This is a delayed task.
    newTask.sortIndex = startTime;
    push(timerQueue, newTask);

    if (peek(taskQueue) === null && newTask === peek(timerQueue)) {
      // All tasks are delayed, and this is the task with the earliest delay.
      if (isHostTimeoutScheduled) {
        // Cancel an existing timeout.
        cancelHostTimeout();
      } else {
        isHostTimeoutScheduled = true;
      } // Schedule a timeout.


      requestHostTimeout(handleTimeout, startTime - currentTime);
    }
  } else {
    newTask.sortIndex = expirationTime;
    push(taskQueue, newTask);
    // wait until the next time we yield.


    if (!isHostCallbackScheduled && !isPerformingWork) {
      isHostCallbackScheduled = true;
      requestHostCallback(flushWork);
    }
  }

  return newTask;
}

function unstable_pauseExecution() {
}

function unstable_continueExecution() {

  if (!isHostCallbackScheduled && !isPerformingWork) {
    isHostCallbackScheduled = true;
    requestHostCallback(flushWork);
  }
}

function unstable_getFirstCallbackNode() {
  return peek(taskQueue);
}

function unstable_cancelCallback(task) {
  // remove from the queue because you can't remove arbitrary nodes from an
  // array based heap, only the first one.)


  task.callback = null;
}

function unstable_getCurrentPriorityLevel() {
  return currentPriorityLevel;
}

var unstable_requestPaint = requestPaint;
var unstable_Profiling =  null;

exports.unstable_IdlePriority = IdlePriority;
exports.unstable_ImmediatePriority = ImmediatePriority;
exports.unstable_LowPriority = LowPriority;
exports.unstable_NormalPriority = NormalPriority;
exports.unstable_Profiling = unstable_Profiling;
exports.unstable_UserBlockingPriority = UserBlockingPriority;
exports.unstable_cancelCallback = unstable_cancelCallback;
exports.unstable_continueExecution = unstable_continueExecution;
exports.unstable_getCurrentPriorityLevel = unstable_getCurrentPriorityLevel;
exports.unstable_getFirstCallbackNode = unstable_getFirstCallbackNode;
exports.unstable_next = unstable_next;
exports.unstable_pauseExecution = unstable_pauseExecution;
exports.unstable_requestPaint = unstable_requestPaint;
exports.unstable_runWithPriority = unstable_runWithPriority;
exports.unstable_scheduleCallback = unstable_scheduleCallback;
exports.unstable_wrapCallback = unstable_wrapCallback;
  })();
}


/***/ }),

/***/ "./node_modules/scheduler/index.js":
/*!*****************************************!*\
  !*** ./node_modules/scheduler/index.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


if (false) {} else {
  module.exports = __webpack_require__(/*! ./cjs/scheduler.development.js */ "./node_modules/scheduler/cjs/scheduler.development.js");
}


/***/ }),

/***/ "./node_modules/scheduler/tracing.js":
/*!*******************************************!*\
  !*** ./node_modules/scheduler/tracing.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


if (false) {} else {
  module.exports = __webpack_require__(/*! ./cjs/scheduler-tracing.development.js */ "./node_modules/scheduler/cjs/scheduler-tracing.development.js");
}


/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js":
/*!****************************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js ***!
  \****************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var isOldIE = function isOldIE() {
  var memo;
  return function memorize() {
    if (typeof memo === 'undefined') {
      // Test for IE <= 9 as proposed by Browserhacks
      // @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805
      // Tests for existence of standard globals is to allow style-loader
      // to operate correctly into non-standard environments
      // @see https://github.com/webpack-contrib/style-loader/issues/177
      memo = Boolean(window && document && document.all && !window.atob);
    }

    return memo;
  };
}();

var getTarget = function getTarget() {
  var memo = {};
  return function memorize(target) {
    if (typeof memo[target] === 'undefined') {
      var styleTarget = document.querySelector(target); // Special case to return head of iframe instead of iframe itself

      if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {
        try {
          // This will throw an exception if access to iframe is blocked
          // due to cross-origin restrictions
          styleTarget = styleTarget.contentDocument.head;
        } catch (e) {
          // istanbul ignore next
          styleTarget = null;
        }
      }

      memo[target] = styleTarget;
    }

    return memo[target];
  };
}();

var stylesInDom = [];

function getIndexByIdentifier(identifier) {
  var result = -1;

  for (var i = 0; i < stylesInDom.length; i++) {
    if (stylesInDom[i].identifier === identifier) {
      result = i;
      break;
    }
  }

  return result;
}

function modulesToDom(list, options) {
  var idCountMap = {};
  var identifiers = [];

  for (var i = 0; i < list.length; i++) {
    var item = list[i];
    var id = options.base ? item[0] + options.base : item[0];
    var count = idCountMap[id] || 0;
    var identifier = "".concat(id, " ").concat(count);
    idCountMap[id] = count + 1;
    var index = getIndexByIdentifier(identifier);
    var obj = {
      css: item[1],
      media: item[2],
      sourceMap: item[3]
    };

    if (index !== -1) {
      stylesInDom[index].references++;
      stylesInDom[index].updater(obj);
    } else {
      stylesInDom.push({
        identifier: identifier,
        updater: addStyle(obj, options),
        references: 1
      });
    }

    identifiers.push(identifier);
  }

  return identifiers;
}

function insertStyleElement(options) {
  var style = document.createElement('style');
  var attributes = options.attributes || {};

  if (typeof attributes.nonce === 'undefined') {
    var nonce =  true ? __webpack_require__.nc : 0;

    if (nonce) {
      attributes.nonce = nonce;
    }
  }

  Object.keys(attributes).forEach(function (key) {
    style.setAttribute(key, attributes[key]);
  });

  if (typeof options.insert === 'function') {
    options.insert(style);
  } else {
    var target = getTarget(options.insert || 'head');

    if (!target) {
      throw new Error("Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.");
    }

    target.appendChild(style);
  }

  return style;
}

function removeStyleElement(style) {
  // istanbul ignore if
  if (style.parentNode === null) {
    return false;
  }

  style.parentNode.removeChild(style);
}
/* istanbul ignore next  */


var replaceText = function replaceText() {
  var textStore = [];
  return function replace(index, replacement) {
    textStore[index] = replacement;
    return textStore.filter(Boolean).join('\n');
  };
}();

function applyToSingletonTag(style, index, remove, obj) {
  var css = remove ? '' : obj.media ? "@media ".concat(obj.media, " {").concat(obj.css, "}") : obj.css; // For old IE

  /* istanbul ignore if  */

  if (style.styleSheet) {
    style.styleSheet.cssText = replaceText(index, css);
  } else {
    var cssNode = document.createTextNode(css);
    var childNodes = style.childNodes;

    if (childNodes[index]) {
      style.removeChild(childNodes[index]);
    }

    if (childNodes.length) {
      style.insertBefore(cssNode, childNodes[index]);
    } else {
      style.appendChild(cssNode);
    }
  }
}

function applyToTag(style, options, obj) {
  var css = obj.css;
  var media = obj.media;
  var sourceMap = obj.sourceMap;

  if (media) {
    style.setAttribute('media', media);
  } else {
    style.removeAttribute('media');
  }

  if (sourceMap && typeof btoa !== 'undefined') {
    css += "\n/*# sourceMappingURL=data:application/json;base64,".concat(btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))), " */");
  } // For old IE

  /* istanbul ignore if  */


  if (style.styleSheet) {
    style.styleSheet.cssText = css;
  } else {
    while (style.firstChild) {
      style.removeChild(style.firstChild);
    }

    style.appendChild(document.createTextNode(css));
  }
}

var singleton = null;
var singletonCounter = 0;

function addStyle(obj, options) {
  var style;
  var update;
  var remove;

  if (options.singleton) {
    var styleIndex = singletonCounter++;
    style = singleton || (singleton = insertStyleElement(options));
    update = applyToSingletonTag.bind(null, style, styleIndex, false);
    remove = applyToSingletonTag.bind(null, style, styleIndex, true);
  } else {
    style = insertStyleElement(options);
    update = applyToTag.bind(null, style, options);

    remove = function remove() {
      removeStyleElement(style);
    };
  }

  update(obj);
  return function updateStyle(newObj) {
    if (newObj) {
      if (newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap) {
        return;
      }

      update(obj = newObj);
    } else {
      remove();
    }
  };
}

module.exports = function (list, options) {
  options = options || {}; // Force single-tag solution on IE6-9, which has a hard limit on the # of <style>
  // tags it will allow on a page

  if (!options.singleton && typeof options.singleton !== 'boolean') {
    options.singleton = isOldIE();
  }

  list = list || [];
  var lastIdentifiers = modulesToDom(list, options);
  return function update(newList) {
    newList = newList || [];

    if (Object.prototype.toString.call(newList) !== '[object Array]') {
      return;
    }

    for (var i = 0; i < lastIdentifiers.length; i++) {
      var identifier = lastIdentifiers[i];
      var index = getIndexByIdentifier(identifier);
      stylesInDom[index].references--;
    }

    var newLastIdentifiers = modulesToDom(newList, options);

    for (var _i = 0; _i < lastIdentifiers.length; _i++) {
      var _identifier = lastIdentifiers[_i];

      var _index = getIndexByIdentifier(_identifier);

      if (stylesInDom[_index].references === 0) {
        stylesInDom[_index].updater();

        stylesInDom.splice(_index, 1);
      }
    }

    lastIdentifiers = newLastIdentifiers;
  };
};

/***/ }),

/***/ "./node_modules/use-async-effect/index.js":
/*!************************************************!*\
  !*** ./node_modules/use-async-effect/index.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var React = __webpack_require__(/*! react */ "./node_modules/react/index.js");

function useAsyncEffect(effect, destroy, inputs) {
  var hasDestroy = typeof destroy === 'function';

  React.useEffect(function () {
    var result;
    var mounted = true;
    var maybePromise = effect(function () {
      return mounted;
    });

    Promise.resolve(maybePromise).then(function (value) {
      result = value;
    });

    return function () {
      mounted = false;

      if (hasDestroy) {
        destroy(result);
      }
    };
  }, hasDestroy ? inputs : destroy);
}

module.exports = useAsyncEffect;
module.exports.useAsyncEffect = useAsyncEffect;


/***/ }),

/***/ "./src/style.css":
/*!***********************!*\
  !*** ./src/style.css ***!
  \***********************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var api = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js");
            var content = __webpack_require__(/*! !!../node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[2].use[1]!../node_modules/postcss-loader/src/index.js??ruleSet[1].rules[2].use[2]!./style.css */ "./node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[2].use[1]!./node_modules/postcss-loader/src/index.js??ruleSet[1].rules[2].use[2]!./src/style.css");

            content = content.__esModule ? content.default : content;

            if (typeof content === 'string') {
              content = [[module.id, content, '']];
            }

var options = {};

options.insert = "head";
options.singleton = false;

var update = api(content, options);



module.exports = content.locals || {};

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be in strict mode.
(() => {
"use strict";
/*!**********************************!*\
  !*** ./src/quick-demo/index.tsx ***!
  \**********************************/
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var rainway_sdk__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! rainway-sdk */ "./node_modules/rainway-sdk/dist/index.js");
/* harmony import */ var rainway_sdk__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(rainway_sdk__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react-dom */ "./node_modules/react-dom/index.js");
/* harmony import */ var _style_css__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../style.css */ "./src/style.css");
/* harmony import */ var _style_css__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_style_css__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var use_async_effect__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! use-async-effect */ "./node_modules/use-async-effect/index.js");
/* harmony import */ var use_async_effect__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(use_async_effect__WEBPACK_IMPORTED_MODULE_4__);
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};





const QuickDemo = () => {
    const [runtime, setRuntime] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)();
    const [error, setError] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)("");
    use_async_effect__WEBPACK_IMPORTED_MODULE_4___default()((isAlive) => __awaiter(void 0, void 0, void 0, function* () {
        var _a;
        try {
            const rt = yield rainway_sdk__WEBPACK_IMPORTED_MODULE_0__.RainwayRuntime.initialize({
                apiKey: (_a = new URLSearchParams(window.location.search).get("api_key")) !== null && _a !== void 0 ? _a : "",
                externalId: "web-demo-quick",
                onRuntimeConnectionLost: (rt, error) => {
                    setRuntime(undefined);
                },
                onConnectionRequest: (rt, request) => {
                    request.accept();
                },
                onPeerMessage: () => { },
                onPeerDataChannel: () => { },
                onPeerError: (rt, peer, error) => {
                    console.warn("onPeerError", peer, error);
                },
                onPeerStateChange: (rt, peer, state) => {
                    console.log(`Peer ${peer.peerId} changed states to ${state}`);
                },
                onStreamAnnouncement: () => { },
                onStreamStop: () => { },
                logSink: () => { },
            });
            if (!isAlive())
                return;
            setRuntime(rt);
        }
        catch (e) {
            setError(e.message);
            console.log(e);
        }
    }));
    return (react__WEBPACK_IMPORTED_MODULE_1__.createElement("main", { className: "m-t-8 m-l-8 m-r-8 m-b-8" }, error ? error : runtime ? "Connected." : "Connecting"));
};
react_dom__WEBPACK_IMPORTED_MODULE_2__.render(react__WEBPACK_IMPORTED_MODULE_1__.createElement(react__WEBPACK_IMPORTED_MODULE_1__.StrictMode, null,
    react__WEBPACK_IMPORTED_MODULE_1__.createElement(QuickDemo, null)), document.getElementById("react-root"));

})();

/******/ })()
;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yYWlud2F5LXNkay13ZWItZGVtby8uL3NyYy9zdHlsZS5jc3MiLCJ3ZWJwYWNrOi8vcmFpbndheS1zZGstd2ViLWRlbW8vLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvYXBpLmpzIiwid2VicGFjazovL3JhaW53YXktc2RrLXdlYi1kZW1vLy4vbm9kZV9tb2R1bGVzL29iamVjdC1hc3NpZ24vaW5kZXguanMiLCJ3ZWJwYWNrOi8vcmFpbndheS1zZGstd2ViLWRlbW8vLi9ub2RlX21vZHVsZXMvcmFpbndheS1zZGsvZGlzdC9pbmRleC5qcyIsIndlYnBhY2s6Ly9yYWlud2F5LXNkay13ZWItZGVtby8uL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vY2pzL3JlYWN0LWRvbS5kZXZlbG9wbWVudC5qcyIsIndlYnBhY2s6Ly9yYWlud2F5LXNkay13ZWItZGVtby8uL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vaW5kZXguanMiLCJ3ZWJwYWNrOi8vcmFpbndheS1zZGstd2ViLWRlbW8vLi9ub2RlX21vZHVsZXMvcmVhY3QvY2pzL3JlYWN0LmRldmVsb3BtZW50LmpzIiwid2VicGFjazovL3JhaW53YXktc2RrLXdlYi1kZW1vLy4vbm9kZV9tb2R1bGVzL3JlYWN0L2luZGV4LmpzIiwid2VicGFjazovL3JhaW53YXktc2RrLXdlYi1kZW1vLy4vbm9kZV9tb2R1bGVzL3NjaGVkdWxlci9janMvc2NoZWR1bGVyLXRyYWNpbmcuZGV2ZWxvcG1lbnQuanMiLCJ3ZWJwYWNrOi8vcmFpbndheS1zZGstd2ViLWRlbW8vLi9ub2RlX21vZHVsZXMvc2NoZWR1bGVyL2Nqcy9zY2hlZHVsZXIuZGV2ZWxvcG1lbnQuanMiLCJ3ZWJwYWNrOi8vcmFpbndheS1zZGstd2ViLWRlbW8vLi9ub2RlX21vZHVsZXMvc2NoZWR1bGVyL2luZGV4LmpzIiwid2VicGFjazovL3JhaW53YXktc2RrLXdlYi1kZW1vLy4vbm9kZV9tb2R1bGVzL3NjaGVkdWxlci90cmFjaW5nLmpzIiwid2VicGFjazovL3JhaW53YXktc2RrLXdlYi1kZW1vLy4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvaW5qZWN0U3R5bGVzSW50b1N0eWxlVGFnLmpzIiwid2VicGFjazovL3JhaW53YXktc2RrLXdlYi1kZW1vLy4vbm9kZV9tb2R1bGVzL3VzZS1hc3luYy1lZmZlY3QvaW5kZXguanMiLCJ3ZWJwYWNrOi8vcmFpbndheS1zZGstd2ViLWRlbW8vLi9zcmMvc3R5bGUuY3NzPzllZmQiLCJ3ZWJwYWNrOi8vcmFpbndheS1zZGstd2ViLWRlbW8vd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vcmFpbndheS1zZGstd2ViLWRlbW8vd2VicGFjay9ydW50aW1lL2NvbXBhdCBnZXQgZGVmYXVsdCBleHBvcnQiLCJ3ZWJwYWNrOi8vcmFpbndheS1zZGstd2ViLWRlbW8vd2VicGFjay9ydW50aW1lL2RlZmluZSBwcm9wZXJ0eSBnZXR0ZXJzIiwid2VicGFjazovL3JhaW53YXktc2RrLXdlYi1kZW1vL3dlYnBhY2svcnVudGltZS9oYXNPd25Qcm9wZXJ0eSBzaG9ydGhhbmQiLCJ3ZWJwYWNrOi8vcmFpbndheS1zZGstd2ViLWRlbW8vd2VicGFjay9ydW50aW1lL21ha2UgbmFtZXNwYWNlIG9iamVjdCIsIndlYnBhY2s6Ly9yYWlud2F5LXNkay13ZWItZGVtby8uL3NyYy9xdWljay1kZW1vL2luZGV4LnRzeCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBQTtBQUNBLGtDQUFrQyxtQkFBTyxDQUFDLHFHQUFnRDtBQUMxRjtBQUNBLDhGQUE4RixJQUFJLElBQUksNkNBQTZDLElBQUksMkJBQTJCLElBQUksSUFBSSxrQkFBa0I7QUFDNU07QUFDQSxpQ0FBaUMsZ0RBQWdELDhDQUE4QyxtREFBbUQsb0RBQW9ELHFEQUFxRCwrQkFBK0IsK0JBQStCLCtCQUErQiwrQkFBK0IsK0JBQStCLCtCQUErQiwrQkFBK0IsK0JBQStCLCtCQUErQiwrQkFBK0IsK0JBQStCLCtDQUErQyw2QkFBNkIsNkJBQTZCLDZCQUE2Qiw2QkFBNkIsNkJBQTZCLDZCQUE2Qiw2QkFBNkIsNkJBQTZCLG1EQUFtRCw4QkFBOEIsOEJBQThCLDhCQUE4Qiw4QkFBOEIsOEJBQThCLDhCQUE4Qiw4QkFBOEIsOEJBQThCLDZDQUE2QywyQkFBMkIsMkJBQTJCLDJCQUEyQiwyQkFBMkIsMkJBQTJCLDJCQUEyQiwyQkFBMkIsMkJBQTJCLGlEQUFpRCw4QkFBOEIsK0JBQStCLCtCQUErQiwrQkFBK0IsK0JBQStCLCtCQUErQiwrQkFBK0IsK0JBQStCLCtCQUErQiwrQkFBK0IsK0JBQStCLCtCQUErQiwrQkFBK0IsK0JBQStCLCtCQUErQiwrQkFBK0IsZ0NBQWdDLEdBQUcsYUFBYSxpQkFBaUIsR0FBRywrQ0FBK0MsK0JBQStCLEdBQUcsVUFBVSxnQ0FBZ0MsR0FBRyxVQUFVLGtDQUFrQyxHQUFHLFVBQVUsbUNBQW1DLEdBQUcsVUFBVSxnQ0FBZ0MsR0FBRyxVQUFVLGlDQUFpQyxHQUFHLFVBQVUsaUNBQWlDLEdBQUcsVUFBVSxrQ0FBa0MsR0FBRyxVQUFVLCtCQUErQixHQUFHLFVBQVUsZ0NBQWdDLEdBQUcsVUFBVSxrQ0FBa0MsR0FBRyxVQUFVLG1DQUFtQyxHQUFHLFVBQVUsZ0NBQWdDLEdBQUcsVUFBVSxpQ0FBaUMsR0FBRyxVQUFVLGlDQUFpQyxHQUFHLFVBQVUsa0NBQWtDLEdBQUcsVUFBVSwrQkFBK0IsR0FBRyxVQUFVLGdDQUFnQyxHQUFHLFVBQVUsa0NBQWtDLEdBQUcsVUFBVSxtQ0FBbUMsR0FBRyxVQUFVLGdDQUFnQyxHQUFHLFVBQVUsaUNBQWlDLEdBQUcsVUFBVSxpQ0FBaUMsR0FBRyxVQUFVLGtDQUFrQyxHQUFHLFdBQVcsZ0NBQWdDLEdBQUcsV0FBVyxpQ0FBaUMsR0FBRyxXQUFXLG1DQUFtQyxHQUFHLFdBQVcsb0NBQW9DLEdBQUcsV0FBVyxpQ0FBaUMsR0FBRyxXQUFXLGtDQUFrQyxHQUFHLFdBQVcsa0NBQWtDLEdBQUcsV0FBVyxtQ0FBbUMsR0FBRyxXQUFXLGdDQUFnQyxHQUFHLFdBQVcsaUNBQWlDLEdBQUcsV0FBVyxtQ0FBbUMsR0FBRyxXQUFXLG9DQUFvQyxHQUFHLFdBQVcsaUNBQWlDLEdBQUcsV0FBVyxrQ0FBa0MsR0FBRyxXQUFXLGtDQUFrQyxHQUFHLFdBQVcsbUNBQW1DLEdBQUcsV0FBVyxnQ0FBZ0MsR0FBRyxXQUFXLGlDQUFpQyxHQUFHLFdBQVcsbUNBQW1DLEdBQUcsV0FBVyxvQ0FBb0MsR0FBRyxXQUFXLGlDQUFpQyxHQUFHLFdBQVcsa0NBQWtDLEdBQUcsV0FBVyxrQ0FBa0MsR0FBRyxXQUFXLG1DQUFtQyxHQUFHLFdBQVcsZ0NBQWdDLEdBQUcsV0FBVyxpQ0FBaUMsR0FBRyxXQUFXLG1DQUFtQyxHQUFHLFdBQVcsb0NBQW9DLEdBQUcsV0FBVyxpQ0FBaUMsR0FBRyxXQUFXLGtDQUFrQyxHQUFHLFdBQVcsa0NBQWtDLEdBQUcsV0FBVyxtQ0FBbUMsR0FBRyxXQUFXLGdDQUFnQyxHQUFHLFdBQVcsaUNBQWlDLEdBQUcsV0FBVyxtQ0FBbUMsR0FBRyxXQUFXLG9DQUFvQyxHQUFHLFdBQVcsaUNBQWlDLEdBQUcsV0FBVyxrQ0FBa0MsR0FBRyxXQUFXLGtDQUFrQyxHQUFHLFdBQVcsbUNBQW1DLEdBQUcsV0FBVyxnQ0FBZ0MsR0FBRyxXQUFXLGlDQUFpQyxHQUFHLFdBQVcsbUNBQW1DLEdBQUcsV0FBVyxvQ0FBb0MsR0FBRyxXQUFXLGlDQUFpQyxHQUFHLFdBQVcsa0NBQWtDLEdBQUcsV0FBVyxrQ0FBa0MsR0FBRyxXQUFXLG1DQUFtQyxHQUFHLFdBQVcsZ0NBQWdDLEdBQUcsV0FBVyxpQ0FBaUMsR0FBRyxXQUFXLG1DQUFtQyxHQUFHLFdBQVcsb0NBQW9DLEdBQUcsV0FBVyxpQ0FBaUMsR0FBRyxXQUFXLGtDQUFrQyxHQUFHLFdBQVcsa0NBQWtDLEdBQUcsV0FBVyxtQ0FBbUMsR0FBRyxXQUFXLGdDQUFnQyxHQUFHLFdBQVcsaUNBQWlDLEdBQUcsV0FBVyxtQ0FBbUMsR0FBRyxXQUFXLG9DQUFvQyxHQUFHLFdBQVcsaUNBQWlDLEdBQUcsV0FBVyxrQ0FB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QUFFQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCOztBQUVBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7O0FBRUEsMEJBQTBCO0FBQzFCO0FBQ0E7O0FBRUEsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTs7QUFFQSwyQkFBMkI7QUFDM0I7O0FBRUEsZ0JBQWdCO0FBQ2hCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTs7O0FBR0Esb0JBQW9COztBQUVwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsRUFBRTtBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLEVBQUU7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsRUFBRTtBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLEVBQUU7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFFO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsRUFBRTtBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsRUFBRTs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLEVBQUU7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOztBQUVBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsRUFBRTs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFFOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLEVBQUU7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsRUFBRTtBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxXQUFXO0FBQ3RCLFdBQVcsT0FBTztBQUNsQixXQUFXLEVBQUU7QUFDYjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7O0FBR0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOzs7QUFHSDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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RUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsRUFBRTtBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7OztBQUdIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQ0FBaUM7QUFDakM7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUEsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjs7QUFFQTtBQUNBO0FBQ0EseURBQXlEO0FBQ3pEOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxpRUFBaUU7QUFDakU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFF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QUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7O0FBRW5DO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCOztBQUVBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7O0FBR0g7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsV0FBVztBQUN0QixXQUFXLE9BQU87QUFDbEI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFdBQVc7QUFDdEIsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFlBQVksT0FBTztBQUNuQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQSw0Q0FBNEM7QUFDNUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLEVBQUU7QUFDYixZQUFZLE9BQU87QUFDbkI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx3QkFBd0I7QUFDeEI7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCOztBQUU5Qiw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFdBQVc7QUFDdEIsV0FBVyxPQUFPO0FBQ2xCOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsaUNBQWlDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsbUJBQW1CLHNCQUFzQjtBQUN6QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLGdDQUFnQyxLQUFLO0FBQzNDO0FBQ0E7QUFDQSxNQUFNLGdDQUFnQyxLQUFLO0FBQzNDO0FBQ0EsNERBQTREO0FBQzVELE1BQU0sZ0NBQWdDLEtBQUs7QUFDM0M7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLDROQUE0TjtBQUM1TjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7O0FBR0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw0RUFBNEUsWUFBWTtBQUN4RjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMkhBQTJILDZCQUE2QjtBQUN4SjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrRkFBa0Y7QUFDbEY7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTywwQ0FBMEM7OztBQUdqRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwrRkFBK0Y7QUFDL0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTywwQ0FBMEM7OztBQUdqRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7OztBQUdMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOzs7QUFHTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw2RUFBNkU7O0FBRTdFO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esc0pBQXNKLGlCQUFpQjtBQUN2SyxPQUFPO0FBQ1Asc0pBQXNKLGlCQUFpQix3REFBd0QsbUJBQW1CLGdCQUFnQiw4QkFBOEI7QUFDaFM7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDs7O0FBR0E7QUFDQTtBQUNBLEtBQUs7OztBQUdMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7OztBQUdMO0FBQ0Esb0dBQW9HLEdBQUc7O0FBRXZHO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsWUFBWSxlQUFlO0FBQzNCOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHNFQUFzRTs7QUFFdEU7QUFDQTtBQUNBLEdBQUc7QUFDSDs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw2Q0FBNkM7O0FBRTdDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1CQUFtQiwwQkFBMEI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFlBQVksVUFBVTtBQUN0Qjs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLDBDQUEwQztBQUMxQzs7QUFFQTtBQUNBO0FBQ0EscUJBQXFCOztBQUVyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwwQkFBMEI7QUFDMUI7QUFDQTs7QUFFQSxxQ0FBcUM7QUFDckM7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1FQUFtRTtBQUNuRTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0EsZ0JBQWdCOztBQUVoQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGdCQUFnQjtBQUM3QjtBQUNBO0FBQ0E7QUFDQSxPQUFPOzs7QUFHUCx1RUFBdUU7O0FBRXZFO0FBQ0EsOERBQThEO0FBQzlEOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQSxPQUFPOzs7QUFHUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsdUJBQXVCOztBQUV2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLFNBQVM7QUFDcEIsV0FBVyxFQUFFO0FBQ2IsV0FBVyxLQUFLO0FBQ2hCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsU0FBUztBQUNwQixXQUFXLEVBQUU7QUFDYixXQUFXLEtBQUs7QUFDaEI7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87OztBQUdQO0FBQ0EsS0FBSztBQUNMO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPO0FBQ1A7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOzs7QUFHSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7O0FBR0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOzs7QUFHSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELHNDQUFzQzs7QUFFdEMsOEJBQThCO0FBQzlCOztBQUVBO0FBQ0E7QUFDQSx1QkFBdUI7O0FBRXZCO0FBQ0Esc0NBQXNDOztBQUV0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixXQUFXO0FBQ1g7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBLHlFQUF5RTtBQUN6RTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7OztBQUdMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0NBQW9DOztBQUVwQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7O0FBR1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7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O0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOzs7QUFHSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7O0FBRXJDO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7O0FBR0Esc0VBQXNFO0FBQ3RFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7QUFDRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlCQUFpQixnQkFBZ0I7QUFDakM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDJDQUEyQzs7QUFFM0M7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDOztBQUV0QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQzs7QUFFckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7O0FBRTdDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9EO0FBQ3BEO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx5REFBeUQ7O0FBRXpELG9CQUFvQjtBQUNwQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMOzs7QUFHQTtBQUNBLEdBQUc7QUFDSDs7O0FBR0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7OztBQUdBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtB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QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQ0FBb0M7QUFDcEM7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHdDQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMENBQTBDO0FBQzFDO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixZQUFZLE9BQU87QUFDbkI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7O0FBR0g7QUFDQSxpREFBaUQ7QUFDakQ7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBLG1DQUFtQzs7QUFFbkM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTs7O0FBR0EsK0VBQStFO0FBQy9FO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7QUFHRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsWUFBWTtBQUNaOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsWUFBWTtBQUNaOzs7QUFHQTtBQUNBO0FBQ0EsQ0FBQzs7O0FBR0Q7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEI7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDs7O0FBR0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDZHQUE2RztBQUM3RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLENBQUM7OztBQUdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7OztBQUdIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsVUFBVTs7QUFFVjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25COztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOzs7QUFHSCxpQkFBaUIsa0JBQWtCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyx1QkFBdUI7QUFDbEMsWUFBWTtBQUNaOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsdUJBQXVCO0FBQ2xDLFlBQVk7QUFDWjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHVCQUF1QjtBQUNsQyxXQUFXLE9BQU87QUFDbEIsWUFBWTtBQUNaOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxXQUFXO0FBQ3RCLFlBQVk7QUFDWjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWSxXQUFXO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPOzs7QUFHUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7O0FBR0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHVCQUF1QjtBQUNsQyxXQUFXLE9BQU87QUFDbEI7O0FBRUE7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw4RUFBOEU7QUFDOUU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7O0FBR0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CLHNCQUFzQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixZQUFZO0FBQ1o7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7O0FBR0g7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwR0FBMEc7QUFDMUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7O0FBR0QsZ1RBQWdUO0FBQ2hUO0FBQ0E7O0FBRUE7O0FBRUE7QUFD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QUFDQTtBQUNBO0FBQ0E7O0FBRUEseUJBQXlCLE9BQU87QUFDaEM7QUFDQTs7QUFFQTs7QUFFQSx5QkFBeUIsT0FBTztBQUNoQztBQUNBLEdBQUc7OztBQUdIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7OztBQUdIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7OztBQUdIOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQSx3RUFBd0U7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlJQUFpSSxtQkFBbUIsZ0JBQWdCLDhCQUE4QjtBQUNsTSxLQUFLO0FBQ0w7QUFDQTtBQUNBLElBQUk7QUFDSjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7O0FBR1A7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUssb0dBQW9HLGtDQUFrQztBQUMzSTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCLDBCQUEwQjtBQUMzQztBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwyQkFBMkI7QUFDM0I7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNERBQTREO0FBQzVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLCtDQUErQztBQUMvQzs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EscURBQXFEO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7OztBQUdIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLDRCQUE0QjtBQUNqRDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlEQUFpRDtBQUNqRDs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbURBQW1EO0FBQ25EOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxtREFBbUQ7QUFDbkQ7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVB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O0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFDQUFxQztBQUNyQztBQUNBLCtFQUErRTtBQUMvRTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4Qzs7QUFFOUM7QUFDQSxhQUFhOzs7QUFHYjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQ7QUFDekQ7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQSwwdkJBQTB2Qjs7QUFFMXZCO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQzs7QUFFcEMsdURBQXVEOztBQUV2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUNBQWlDOztBQUVqQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5Qzs7QUFFekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLEdBQUc7OztBQUdIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7OztBQUdIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVEsY0FBYztBQUN0Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNEO0FBQ3REOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7O0FBR0g7QUFDQSxDQUFDO0FBQ0Q7QUFDQTs7QUFFQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLCtDQUErQztBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSywrQ0FBK0M7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBOzs7QUFHQSx5RUFBeUU7QUFDekU7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwSEFBMEg7QUFDMUg7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxtRUFBbUU7O0FBRW5FO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLENBQUM7OztBQUdELDBEQUEwRDs7QUFFMUQsb0RBQW9EO0FBQ3BEO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbURBQW1EO0FBQ25EOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFCQUFxQjtBQUNyQjtBQUNBOztBQUVBO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQTs7QUFFQSwwSEFBMEg7QUFDMUg7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5RUFBeUU7QUFDekU7O0FBRUE7QUFDQSw4Q0FBOEM7O0FBRTlDO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUVBQW1FO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7O0FBR0w7QUFDQTs7QUFFQTtBQUNBLHdDQUF3Qzs7QUFFeEM7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOzs7QUFHSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMEJBQTBCO0FBQzFCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7O0FBRXhCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCOztBQUUzQjtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixtQkFBbUI7QUFDbkM7O0FBRUE7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxTQUFTOzs7QUFHVDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLG1CQUFtQjtBQUNuQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsOERBQThEO0FBQzlELHFEQUFxRDtBQUNyRCwyREFBMkQ7QUFDM0QsMkNBQTJDO0FBQzNDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRDs7QUFFckQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTDs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSw4Q0FBOEM7O0FBRTlDOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEtBQUs7OztBQUdMO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjs7QUFFMUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDJCQUEyQjs7QUFFM0I7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDhEQUE4RDs7QUFFOUQsMkRBQTJEO0FBQzNEOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7OztBQUdUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOzs7QUFHUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbURBQW1ELHlEQUF5RDtBQUM1Ryw2QkFBNkI7O0FBRTdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7O0FBR1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5Qzs7QUFFekM7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUyx5QkFBeUI7OztBQUdsQztBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOzs7QUFHSDs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxzQ0FBc0M7O0FBRXRDOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNklBQTZJOztBQUU3STtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNULGtFQUFrRSw0Q0FBNEM7QUFDOUc7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7OztBQUdIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlDQUFpQztBQUNqQyxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7OztBQUdEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7OztBQUdBO0FBQ0EscURBQXFEO0FBQ3JEOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtJQUFrSTtBQUNsSTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOzs7QUFHQTtBQUNBO0FBQ0EsR0FBRztBQUNIOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7OztBQUdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0lBQWtJO0FBQ2xJO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOzs7QUFHQTtBQUNBO0FBQ0EsR0FBRztBQUNIOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9DQUFvQzs7QUFFcEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4SkFBOEoseUNBQXlDO0FBQ3ZNO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7O0FBR0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxxQkFBcUIsd0JBQXdCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxVQUFVLGtEQUFrRDtBQUM1RDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLDZCQUE2QjtBQUN6Qzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEtBQUs7OztBQUdMLHVFQUF1RTs7QUFFdkUsVUFBVSw2QkFBNkI7QUFDdkM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTzs7O0FBR1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPO0FBQ1A7OztBQUdBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsY0FBYyxhQUFhO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxVQUFVLGlDQUFpQztBQUMzQztBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFlBQVk7QUFDeEI7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOzs7QUFHTCx1RUFBdUU7O0FBRXZFLFVBQVUsWUFBWTtBQUN0Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUzs7O0FBR1Q7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxNQUFNO0FBQ25EO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7OztBQUdMOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7OztBQUdMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EseURBQXlEO0FBQ3pEOztBQUVBLDhDQUE4QztBQUM5QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDZEQUE2RDs7QUFFN0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNkRBQTZEOztBQUU3RDtBQUNBO0FBQ0EsR0FBRztBQUNIOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBOztBQUVBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsdUNBQXVDO0FBQ3ZDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsMkNBQTJDOztBQUUzQztBQUNBO0FBQ0EsR0FBRzs7O0FBR0g7QUFDQTtBQUNBLEdBQUc7QUFDSDs7O0FBR0E7QUFDQTtBQUNBLEdBQUc7OztBQUdIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLDRIQUE0SDs7QUFFNUgsb0NBQW9DO0FBQ3BDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7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QTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw0QkFBNEI7O0FBRTVCLG9DQUFvQzs7QUFFcEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBOzs7QUFHQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7O0FBR1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxzQ0FBc0M7QUFDdEM7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLDJDQUEyQztBQUNoRDs7O0FBR0E7QUFDQTtBQUNBOztBQUVBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDJDQUEyQzs7QUFFM0MscUNBQXFDO0FBQ3JDO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9EQUFvRDs7QUFFcEQ7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBLGlDQUFpQztBQUNqQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7O0FBRUEsbUNBQW1DOztBQUVuQzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLEdBQUcsb0NBQW9DOztBQUV2QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDZEQUE2RDs7QUFFN0Q7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRyx1QkFBdUI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBLHlLQUF5SywwQ0FBMEM7QUFDbk47QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7OztBQUdIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7O0FBR0g7QUFDQTtBQUNBOztBQUVBLDhDQUE4QztBQUM5QztBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQzs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EscUVBQXFFO0FBQ3JFO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxnQkFBZ0I7QUFDekIsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRDtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0dBQWdHO0FBQ2hHO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwrQkFBK0I7O0FBRS9CO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7OztBQUdIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQ0FBbUM7O0FBRW5DO0FBQ0E7QUFDQTtBQUNBLCtDQUErQzs7QUFFL0M7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOzs7QUFHSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7OztBQUdUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPOzs7QUFHUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0Q7QUFDaEQ7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRDs7QUFFakQ7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0EseUVBQXlFOztBQUV6RTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1DQUFtQztBQUNuQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7OztBQUdIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQzs7QUFFdEM7QUFDQSxLQUFLOzs7QUFHTDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLDBDQUEwQzs7QUFFMUM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7OztBQUdIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDs7O0FBR0EsZ0RBQWdEOztBQUVoRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQzs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVCQUF1Qiw0Q0FBNEM7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DOztBQUVwQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDOztBQUVoQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7O0FBRXBDO0FBQ0EsR0FBRzs7O0FBR0gsc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DOztBQUVwQztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7O0FBR0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7O0FBR0wsd0NBQXdDOztBQUV4QztBQUNBLHNDQUFzQztBQUN0QztBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7QUFHRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOzs7QUFHSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsOENBQThDOztBQUU5QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVEQUF1RDtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RDtBQUN2RDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esc0RBQXNEO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0dBQWdHO0FBQ2hHOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQ7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSCwrRkFBK0Y7QUFDL0Y7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtQ0FBbUM7O0FBRW5DO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHlOQUF5TixHQUFHOztBQUU1TjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixxQkFBcUI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLFlBQVk7QUFDOUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwyQ0FBMkM7O0FBRTNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXOzs7QUFHWDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7O0FBR0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsK0NBQStDOztBQUUvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDs7O0FBR0E7QUFDQSx1Q0FBdUM7O0FBRXZDO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRDs7QUFFbEQ7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHlDQUF5Qzs7QUFFekM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLCtCQUErQjtBQUMvQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0EsbUhBQW1IO0FBQ25IOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTs7O0FBR0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNERBQTREOztBQUU1RDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPLG9DQUFvQztBQUMzQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtREFBbUQ7QUFDbkQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOzs7QUFHQTtBQUNBLDhDQUE4QztBQUM5QztBQUNBOztBQUVBLHFIQUFxSDs7QUFFckgsK0NBQStDO0FBQy9DOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVM7QUFDVDs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUztBQUNUOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOzs7QUFHYjtBQUNBOztBQUVBLG9EQUFvRDtBQUNwRDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsZ0RBQWdEO0FBQ2hEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhDQUE4QztBQUM5Qzs7QUFFQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNkNBQTZDOztBQUU3QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQ7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBLHFFQUFxRTs7QUFFckUsZ0VBQWdFO0FBQ2hFOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFEO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsV0FBVzs7QUFFWCxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FB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QUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEM7O0FBRTlDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0NBQWtDOztBQUVsQzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUEscUhBQXFIOztBQUVySDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSw0REFBNEQ7QUFDNUQ7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7OztBQUdBLHNFQUFzRTs7QUFFdEU7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7O0FBR0E7QUFDQSxLQUFLLGtDQUFrQztBQUN2Qzs7O0FBR0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSx5RUFBeUU7O0FBRXpFOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtEO0FBQ2xEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IseU5BQXlOLHFDQUFxQyx3RkFBd0YsMkJBQTJCLHFCQUFxQixRQUFRLFlBQVk7QUFDMVosYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0Esa0RBQWtEO0FBQ2xEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnREFBZ0Q7QUFDaEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxPQUFPLDRJQUE0STtBQUNuSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxzQ0FBc0M7QUFDdEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7O0FBR0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLOzs7QUFHTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBLHFEQUFxRDs7QUFFckQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSw2QkFBNkI7O0FBRTdCO0FBQ0E7O0FBRUEsNENBQTRDO0FBQzVDOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUcsK0JBQStCO0FBQ2xDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHLCtCQUErQjtBQUNsQzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCOztBQUVBLG1DQUFtQzs7QUFFbkM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsK0NBQStDO0FBQy9DOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPOztBQUVQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3Qzs7QUFFeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsd0NBQXdDOztBQUV4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9EQUFvRDtBQUNwRDtBQUNBOztBQUVBO0FBQ0EsdUNBQXVDOztBQUV2QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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O0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLOzs7QUFHTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7O0FBR0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsQ0FBQztBQUNELFFBQVE7QUFDUjtBQUNBO0FBQ0E7OztBQUdBO0FBQ0EsK0NBQStDO0FBQy9DOztBQUVBLCtDQUErQzs7QUFFL0MsNEdBQTRHOztBQUU1Rzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7OztBQUdIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOzs7QUFHQTtBQUNBLEdBQUc7OztBQUdIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsMENBQTBDO0FBQzFDOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkZBQTJGOztBQUUzRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7O0FBR1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUVBQW1FOzs7QUFHbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7O0FBR1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHdDQUF3QztBQUN4Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOzs7QUFHQTtBQUNBOztBQUVBLGdDQUFnQztBQUNoQzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHOzs7QUFHSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsOENBQThDO0FBQzlDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DOztBQUVuQztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLDBEQUEwRDtBQUMxRDtBQUNBO0FBQ0E7QUFDQSxtREFBbUQ7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOzs7QUFHTDtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQSxHQUFHOzs7QUFHSDtBQUNBLDRDQUE0Qzs7QUFFNUM7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDOztBQUUzQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLHdFQUF3RTs7QUFFeEU7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QXFDOztBQUVyQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHVCQUF1Qiw0QkFBNEI7QUFDbkQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBLEdBQUc7OztBQUdIOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0Qzs7QUFFQSx5Q0FBeUM7O0FBRXpDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHlDQUF5Qzs7QUFFekM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdEQUFnRDtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxpQkFBaUIsMkJBQTJCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7O0FBR0g7QUFDQTs7QUFFQSxrQkFBa0IsMEJBQTBCO0FBQzVDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBLDJDQUEyQzs7QUFFM0M7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMkJBQTJCO0FBQzNCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsd0JBQXdCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7O0FBR0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qjs7QUFFekI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOzs7QUFHQTtBQUNBO0FBQ0EsS0FBSztBQUNMOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBLG1DQUFtQztBQUNuQzs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxPQUFPLDRDQUE0QztBQUNuRDs7O0FBR0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTs7QUFFQSx3Q0FBd0M7O0FBRXhDOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87OztBQUdQOztBQUVBO0FBQ0EsNkNBQTZDO0FBQzdDOztBQUVBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEdBQThHOztBQUU5Rzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7OztBQUdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsSUFBSSxrQ0FBa0MsbUNBQW1DO0FBQzFGLDREQUE0RCxjQUFjLElBQUksZ0JBQWdCLG1DQUFtQztBQUNqSSxPQUFPO0FBQ1A7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpTUFBaU0sb0RBQW9ELEVBQUU7QUFDdlA7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsOExBQThMLG9EQUFvRCxFQUFFO0FBQ3BQLE9BQU87QUFDUDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxnRkFBZ0Y7O0FBRWhGLDBDQUEwQztBQUMxQztBQUNBLDBCQUEwQjtBQUMxQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsK0VBQStFO0FBQy9FO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMLDZEQUE2RDs7QUFFN0Q7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHLEVBQUU7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx5QkFBeUI7O0FBRXpCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7O0FBR0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7O0FBR0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0NBQWdDOztBQUVoQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7OztBQUdMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7OztBQUdMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQyxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EseURBQXlEO0FBQ3pEOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7O0FBRXhCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1COztBQUVuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsK0NBQStDOztBQUUvQyx1Q0FBdUM7QUFDdkM7O0FBRUEsbUNBQW1DOztBQUVuQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQ7QUFDbkQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DOztBQUVwQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFEOztBQUVyRCx1Q0FBdUM7QUFDdkM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDOztBQUV4Qzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwyRUFBMkU7O0FBRTNFO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHNFQUFzRTtBQUN0RTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUVBQXVFO0FBQ3ZFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwRUFBMEU7QUFDMUU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQ7O0FBRTdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrREFBa0Q7QUFDbEQ7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEseUVBQXlFO0FBQ3pFO0FBQ0E7O0FBRUEsNkNBQTZDO0FBQzdDOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7O0FBR0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1GQUFtRjs7QUFFbkY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOzs7QUFHTDtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7OztBQUdMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGlNQUFpTSxjQUFjO0FBQy9NO0FBQ0EsR0FBRzs7O0FBR0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFF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QUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEVBQUU7QUFDYixXQUFXLEVBQUU7QUFDYixXQUFXLEVBQUU7QUFDYixXQUFXLGNBQWM7QUFDekIsV0FBVyxFQUFFO0FBQ2IsV0FBVyxFQUFFO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEVBQUU7QUFDYjtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxFQUFFOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLEVBQUU7QUFDUDs7QUFF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O0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBOztBQUVBOztBQUVBLDJCQUEyQjs7QUFFM0I7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7O0FBR0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOzs7QUFHTDtBQUNBLHlDQUF5QztBQUN6Qzs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBLEdBQUc7OztBQUdIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPOzs7QUFHUDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLDZCQUE2QjtBQUM3QixrQ0FBa0M7QUFDbEMsNEJBQTRCO0FBQzVCLCtCQUErQjtBQUMvQiwwQkFBMEI7QUFDMUIscUNBQXFDO0FBQ3JDLCtCQUErQjtBQUMvQixrQ0FBa0M7QUFDbEMsd0NBQXdDO0FBQ3hDLHFDQUFxQztBQUNyQyxxQkFBcUI7QUFDckIsK0JBQStCO0FBQy9CLDZCQUE2QjtBQUM3QixnQ0FBZ0M7QUFDaEMsaUNBQWlDO0FBQ2pDLDZCQUE2QjtBQUM3QixHQUFHO0FBQ0g7Ozs7Ozs7Ozs7OztBQ3JvQmE7O0FBRWIsSUFBSSxLQUFxQyxFQUFFLEVBRTFDO0FBQ0QsRUFBRSxtSUFBMEQ7QUFDNUQ7Ozs7Ozs7Ozs7OztBQ05hOztBQUViLElBQUksS0FBcUMsRUFBRSxFQUUxQztBQUNELEVBQUUsbUpBQWtFO0FBQ3BFOzs7Ozs7Ozs7Ozs7QUNOYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVEOztBQUV2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTs7QUFFQSxpQkFBaUIsd0JBQXdCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsaUJBQWlCLGlCQUFpQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0JBQWdCLEtBQXdDLEdBQUcsc0JBQWlCLEdBQUcsQ0FBSTs7QUFFbkY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0EscUVBQXFFLHFCQUFxQixhQUFhOztBQUV2Rzs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0EseURBQXlEO0FBQ3pELEdBQUc7O0FBRUg7OztBQUdBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwwQkFBMEI7QUFDMUI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUIsNEJBQTRCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLG9CQUFvQiw2QkFBNkI7QUFDakQ7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEU7Ozs7Ozs7Ozs7O0FDNVFhOztBQUViLFlBQVksbUJBQU8sQ0FBQyw0Q0FBTzs7QUFFM0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0EsNkJBQTZCOzs7Ozs7Ozs7OztBQzdCN0IsVUFBVSxtQkFBTyxDQUFDLG9KQUF3RTtBQUMxRiwwQkFBMEIsbUJBQU8sQ0FBQywwVEFBMEo7O0FBRTVMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOzs7O0FBSUEsc0M7Ozs7OztVQ2xCQTtVQUNBOztVQUVBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBOztVQUVBO1VBQ0E7O1VBRUE7VUFDQTtVQUNBOzs7OztXQ3RCQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0EsZ0NBQWdDLFlBQVk7V0FDNUM7V0FDQSxFOzs7OztXQ1BBO1dBQ0E7V0FDQTtXQUNBO1dBQ0Esd0NBQXdDLHlDQUF5QztXQUNqRjtXQUNBO1dBQ0EsRTs7Ozs7V0NQQSx3Rjs7Ozs7V0NBQTtXQUNBO1dBQ0E7V0FDQSxzREFBc0Qsa0JBQWtCO1dBQ3hFO1dBQ0EsK0NBQStDLGNBQWM7V0FDN0QsRTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNONkM7QUFDYztBQUMxQjtBQUNYO0FBQ3dCO0FBRTlDLE1BQU0sU0FBUyxHQUFHLEdBQUcsRUFBRTtJQUNyQixNQUFNLENBQUMsT0FBTyxFQUFFLFVBQVUsQ0FBQyxHQUFHLCtDQUFRLEVBQThCLENBQUM7SUFDckUsTUFBTSxDQUFDLEtBQUssRUFBRSxRQUFRLENBQUMsR0FBRywrQ0FBUSxDQUFTLEVBQUUsQ0FBQyxDQUFDO0lBQy9DLHVEQUFjLENBQUMsQ0FBTyxPQUFPLEVBQUUsRUFBRTs7UUFDL0IsSUFBSTtZQUNGLE1BQU0sRUFBRSxHQUFHLE1BQU0sa0VBQXlCLENBQUM7Z0JBQ3pDLE1BQU0sRUFDSixVQUFJLGVBQWUsQ0FBQyxNQUFNLENBQUMsUUFBUSxDQUFDLE1BQU0sQ0FBQyxDQUFDLEdBQUcsQ0FBQyxTQUFTLENBQUMsbUNBQUksRUFBRTtnQkFDbEUsVUFBVSxFQUFFLGdCQUFnQjtnQkFDNUIsdUJBQXVCLEVBQUUsQ0FBQyxFQUFFLEVBQUUsS0FBSyxFQUFFLEVBQUU7b0JBQ3JDLFVBQVUsQ0FBQyxTQUFTLENBQUMsQ0FBQztnQkFDeEIsQ0FBQztnQkFDRCxtQkFBbUIsRUFBRSxDQUFDLEVBQUUsRUFBRSxPQUFPLEVBQUUsRUFBRTtvQkFDbkMsT0FBTyxDQUFDLE1BQU0sRUFBRSxDQUFDO2dCQUNuQixDQUFDO2dCQUNELGFBQWEsRUFBRSxHQUFHLEVBQUUsR0FBRSxDQUFDO2dCQUN2QixpQkFBaUIsRUFBRSxHQUFHLEVBQUUsR0FBRSxDQUFDO2dCQUMzQixXQUFXLEVBQUUsQ0FBQyxFQUFFLEVBQUUsSUFBSSxFQUFFLEtBQUssRUFBRSxFQUFFO29CQUMvQixPQUFPLENBQUMsSUFBSSxDQUFDLGFBQWEsRUFBRSxJQUFJLEVBQUUsS0FBSyxDQUFDLENBQUM7Z0JBQzNDLENBQUM7Z0JBQ0QsaUJBQWlCLEVBQUUsQ0FBQyxFQUFFLEVBQUUsSUFBSSxFQUFFLEtBQUssRUFBRSxFQUFFO29CQUNyQyxPQUFPLENBQUMsR0FBRyxDQUFDLFFBQVEsSUFBSSxDQUFDLE1BQU0sc0JBQXNCLEtBQUssRUFBRSxDQUFDLENBQUM7Z0JBQ2hFLENBQUM7Z0JBQ0Qsb0JBQW9CLEVBQUUsR0FBRyxFQUFFLEdBQUUsQ0FBQztnQkFDOUIsWUFBWSxFQUFFLEdBQUcsRUFBRSxHQUFFLENBQUM7Z0JBQ3RCLE9BQU8sRUFBRSxHQUFHLEVBQUUsR0FBRSxDQUFDO2FBQ2xCLENBQUMsQ0FBQztZQUNILElBQUksQ0FBQyxPQUFPLEVBQUU7Z0JBQUUsT0FBTztZQUN2QixVQUFVLENBQUMsRUFBRSxDQUFDLENBQUM7U0FDaEI7UUFBQyxPQUFPLENBQUMsRUFBRTtZQUNWLFFBQVEsQ0FBRSxDQUFXLENBQUMsT0FBTyxDQUFDLENBQUM7WUFDL0IsT0FBTyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQztTQUNoQjtJQUNILENBQUMsRUFBQyxDQUFDO0lBQ0gsT0FBTyxDQUNMLDJEQUFNLFNBQVMsRUFBQyx5QkFBeUIsSUFDdEMsS0FBSyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsWUFBWSxDQUFDLENBQUMsQ0FBQyxhQUFhLENBQ2xELENBQ1IsQ0FBQztBQUNKLENBQUMsQ0FBQztBQUVGLDZDQUFlLENBQ2IsaURBQUMsNkNBQWdCO0lBQ2YsaURBQUMsU0FBUyxPQUFHLENBQ0ksRUFDbkIsUUFBUSxDQUFDLGNBQWMsQ0FBQyxZQUFZLENBQUMsQ0FDdEMsQ0FBQyIsImZpbGUiOiJidW5kbGUucXVpY2suZDZhNDhjNDQ2Yzk5YWEyMzg5NTQuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBJbXBvcnRzXG52YXIgX19fQ1NTX0xPQURFUl9BUElfSU1QT1JUX19fID0gcmVxdWlyZShcIi4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvcnVudGltZS9hcGkuanNcIik7XG5leHBvcnRzID0gX19fQ1NTX0xPQURFUl9BUElfSU1QT1JUX19fKGZhbHNlKTtcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcIkBpbXBvcnQgdXJsKGh0dHBzOi8vZm9udHMuZ29vZ2xlYXBpcy5jb20vY3NzMj9mYW1pbHk9SW50ZXI6d2dodEA0MDA7NTAwOzYwMDs3MDAmZmFtaWx5PVF1ZXN0cmlhbCZmYW1pbHk9UG9wcGluczp3Z2h0QDQwMDs1MDA7NjAwJmZhbWlseT1CYXJsb3c6d2dodEA0MDA7NTAwOzYwMDs3MDAmZGlzcGxheT1zd2FwKTtcIl0pO1xuLy8gTW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCI6cm9vdCB7XFxuICAtLWxvZ28tZm9udC1mYW1pbHk6IFxcXCJQb3BwaW5zXFxcIiwgc2Fucy1zZXJpZjtcXG4gIC0tYm9keS1mb250LWZhbWlseTogXFxcIkludGVyXFxcIiwgc2Fucy1zZXJpZjtcXG4gIC0taGVhZGluZy1mb250LWZhbWlseTogXFxcIlBvcHBpbnNcXFwiLCBzYW5zLXNlcmlmO1xcbiAgLS1oZWFkZXItZm9udC1mYW1pbHk6IFxcXCJRdWVzdHJpYWxcXFwiLCBzYW5zLXNlcmlmO1xcblxcbiAgLyogU2xhdGUgQmx1ZSAqL1xcbiAgLS1jbHItcHJpbWFyeS0xMDA6ICNlMGUyZjQ7XFxuICAtLWNsci1wcmltYXJ5LTIwMDogI2JmYzNlYztcXG4gIC0tY2xyLXByaW1hcnktMzAwOiAjOWZhN2UyO1xcbiAgLS1jbHItcHJpbWFyeS00MDA6ICM3ZTg5ZDg7XFxuICAtLWNsci1wcmltYXJ5LTUwMDogIzYxNmFjYjtcXG4gIC0tY2xyLXByaW1hcnktNjAwOiAjNDg1NGJiO1xcbiAgLS1jbHItcHJpbWFyeS03MDA6ICMzOTQzYTI7XFxuICAtLWNsci1wcmltYXJ5LTgwMDogIzJmMzg4NTtcXG4gIC0tY2xyLXByaW1hcnktOTAwOiAjMjQyYjY3O1xcbiAgLS1jbHItcHJpbWFyeS05NTA6ICMxOTFlNGQ7XFxuICAtLWNsci1wcmltYXJ5LTk3NTogIzBmMTIyZTtcXG4gIC0tY2xyLXByaW1hcnktOTk5OiAjMDUwNjBmO1xcblxcbiAgLyogTWFudGlzICovXFxuICAtLWNsci1ncmVlbi0xMDA6ICNmNGZiZjA7XFxuICAtLWNsci1ncmVlbi0yMDA6ICNkZmYxZDI7XFxuICAtLWNsci1ncmVlbi0zMDA6ICNiZmUyYTY7XFxuICAtLWNsci1ncmVlbi00MDA6ICNhMGQ1N2I7XFxuICAtLWNsci1ncmVlbi01MDA6ICM4Y2NjNjE7XFxuICAtLWNsci1ncmVlbi02MDA6ICM2ZmFkNDU7XFxuICAtLWNsci1ncmVlbi03MDA6ICM1YjhkMzg7XFxuICAtLWNsci1ncmVlbi04MDA6ICMzMzU3MWM7XFxuICAtLWNsci1ncmVlbi05MDA6ICMxZTJmMTI7XFxuXFxuICAvKiBEYW5kZWxpb24gKi9cXG4gIC0tY2xyLXllbGxvdy0xMDA6ICNmZmZkZjE7XFxuICAtLWNsci15ZWxsb3ctMjAwOiAjZmRmN2RiO1xcbiAgLS1jbHIteWVsbG93LTMwMDogI2ZhZWRiNztcXG4gIC0tY2xyLXllbGxvdy00MDA6ICNmN2U2OTU7XFxuICAtLWNsci15ZWxsb3ctNTAwOiAjZjlkYzVjO1xcbiAgLS1jbHIteWVsbG93LTYwMDogI2U1YzM0MztcXG4gIC0tY2xyLXllbGxvdy03MDA6ICM5ZjgwMDQ7XFxuICAtLWNsci15ZWxsb3ctODAwOiAjNTA0MTAyO1xcbiAgLS1jbHIteWVsbG93LTkwMDogIzI4MjAwMTtcXG5cXG4gIC8qIFRvbWF0byAqL1xcbiAgLS1jbHItcmVkLTEwMDogI2ZmZjVmMztcXG4gIC0tY2xyLXJlZC0yMDA6ICNmYmRlZDg7XFxuICAtLWNsci1yZWQtMzAwOiAjZjBiNWE5O1xcbiAgLS1jbHItcmVkLTQwMDogI2ZhOTI3YjtcXG4gIC0tY2xyLXJlZC01MDA6ICNmYzY5NDg7XFxuICAtLWNsci1yZWQtNjAwOiAjZTk1MDJmO1xcbiAgLS1jbHItcmVkLTcwMDogI2NiMzQxMztcXG4gIC0tY2xyLXJlZC04MDA6ICNhMzAzMDM7XFxuICAtLWNsci1yZWQtOTAwOiAjNWMxMTExO1xcblxcbiAgLyogTmV1dHJhbHMgKi9cXG4gIC0tY2xyLW5ldXRyYWwtMDogI2ZmZmZmZjtcXG4gIC0tY2xyLW5ldXRyYWwtNTA6ICNmNGY0ZjY7XFxuICAtLWNsci1uZXV0cmFsLTEwMDogI2U5ZTllYztcXG4gIC0tY2xyLW5ldXRyYWwtMjAwOiAjZDNkM2Q5O1xcbiAgLS1jbHItbmV1dHJhbC0zMDA6ICNiM2IzYmM7XFxuICAtLWNsci1uZXV0cmFsLTQwMDogIzlkOWRhOTtcXG4gIC0tY2xyLW5ldXRyYWwtNDUwOiAjODY4Njk1O1xcbiAgLS1jbHItbmV1dHJhbC01MDA6ICM2ODY4Nzc7XFxuICAtLWNsci1uZXV0cmFsLTYwMDogIzVmNWY2YztcXG4gIC0tY2xyLW5ldXRyYWwtNzAwOiAjNGM0YzU2O1xcbiAgLS1jbHItbmV1dHJhbC04MDA6ICMzOTM5NDE7XFxuICAtLWNsci1uZXV0cmFsLTg1MDogIzJjMmMzMztcXG4gIC0tY2xyLW5ldXRyYWwtOTAwOiAjMjYyNjJjO1xcbiAgLS1jbHItbmV1dHJhbC05MjU6ICMxZTFlMjM7XFxuICAtLWNsci1uZXV0cmFsLTk1MDogIzEzMTMxNjtcXG4gIC0tY2xyLW5ldXRyYWwtOTc1OiAjMDkwOTBiO1xcbiAgLS1jbHItbmV1dHJhbC05OTA6ICMwNDA0MDU7XFxuICAtLWNsci1uZXV0cmFsLTEwMDA6ICMwMDAwMDA7XFxufVxcblxcbi5zcGFjZXIge1xcbiAgZmxleC1ncm93OiAxO1xcbn1cXG5cXG4vKiogTWFyZ2luIGFuZCBQYWRkaW5nIGhlbHBlcnMgKi9cXG4ubS10LTAge1xcbiAgbWFyZ2luLXRvcDogMHB4ICFpbXBvcnRhbnQ7XFxufVxcbi5wLXQtMCB7XFxuICBwYWRkaW5nLXRvcDogMHB4ICFpbXBvcnRhbnQ7XFxufVxcbi5tLWItMCB7XFxuICBtYXJnaW4tYm90dG9tOiAwcHggIWltcG9ydGFudDtcXG59XFxuLnAtYi0wIHtcXG4gIHBhZGRpbmctYm90dG9tOiAwcHggIWltcG9ydGFudDtcXG59XFxuLm0tbC0wIHtcXG4gIG1hcmdpbi1sZWZ0OiAwcHggIWltcG9ydGFudDtcXG59XFxuLnAtbC0wIHtcXG4gIHBhZGRpbmctbGVmdDogMHB4ICFpbXBvcnRhbnQ7XFxufVxcbi5tLXItMCB7XFxuICBtYXJnaW4tcmlnaHQ6IDBweCAhaW1wb3J0YW50O1xcbn1cXG4ucC1yLTAge1xcbiAgcGFkZGluZy1yaWdodDogMHB4ICFpbXBvcnRhbnQ7XFxufVxcbi5tLXQtNCB7XFxuICBtYXJnaW4tdG9wOiA0cHggIWltcG9ydGFudDtcXG59XFxuLnAtdC00IHtcXG4gIHBhZGRpbmctdG9wOiA0cHggIWltcG9ydGFudDtcXG59XFxuLm0tYi00IHtcXG4gIG1hcmdpbi1ib3R0b206IDRweCAhaW1wb3J0YW50O1xcbn1cXG4ucC1iLTQge1xcbiAgcGFkZGluZy1ib3R0b206IDRweCAhaW1wb3J0YW50O1xcbn1cXG4ubS1sLTQge1xcbiAgbWFyZ2luLWxlZnQ6IDRweCAhaW1wb3J0YW50O1xcbn1cXG4ucC1sLTQge1xcbiAgcGFkZGluZy1sZWZ0OiA0cHggIWltcG9ydGFudDtcXG59XFxuLm0tci00IHtcXG4gIG1hcmdpbi1yaWdodDogNHB4ICFpbXBvcnRhbnQ7XFxufVxcbi5wLXItNCB7XFxuICBwYWRkaW5nLXJpZ2h0OiA0cHggIWltcG9ydGFudDtcXG59XFxuLm0tdC04IHtcXG4gIG1hcmdpbi10b3A6IDhweCAhaW1wb3J0YW50O1xcbn1cXG4ucC10LTgge1xcbiAgcGFkZGluZy10b3A6IDhweCAhaW1wb3J0YW50O1xcbn1cXG4ubS1iLTgge1xcbiAgbWFyZ2luLWJvdHRvbTogOHB4ICFpbXBvcnRhbnQ7XFxufVxcbi5wLWItOCB7XFxuICBwYWRkaW5nLWJvdHRvbTogOHB4ICFpbXBvcnRhbnQ7XFxufVxcbi5tLWwtOCB7XFxuICBtYXJnaW4tbGVmdDogOHB4ICFpbXBvcnRhbnQ7XFxufVxcbi5wLWwtOCB7XFxuICBwYWRkaW5nLWxlZnQ6IDhweCAhaW1wb3J0YW50O1xcbn1cXG4ubS1yLTgge1xcbiAgbWFyZ2luLXJpZ2h0OiA4cHggIWltcG9ydGFudDtcXG59XFxuLnAtci04IHtcXG4gIHBhZGRpbmctcmlnaHQ6IDhweCAhaW1wb3J0YW50O1xcbn1cXG4ubS10LTE2IHtcXG4gIG1hcmdpbi10b3A6IDE2cHggIWltcG9ydGFudDtcXG59XFxuLnAtdC0xNiB7XFxuICBwYWRkaW5nLXRvcDogMTZweCAhaW1wb3J0YW50O1xcbn1cXG4ubS1iLTE2IHtcXG4gIG1hcmdpbi1ib3R0b206IDE2cHggIWltcG9ydGFudDtcXG59XFxuLnAtYi0xNiB7XFxuICBwYWRkaW5nLWJvdHRvbTogMTZweCAhaW1wb3J0YW50O1xcbn1cXG4ubS1sLTE2IHtcXG4gIG1hcmdpbi1sZWZ0OiAxNnB4ICFpbXBvcnRhbnQ7XFxufVxcbi5wLWwtMTYge1xcbiAgcGFkZGluZy1sZWZ0OiAxNnB4ICFpbXBvcnRhbnQ7XFxufVxcbi5tLXItMTYge1xcbiAgbWFyZ2luLXJpZ2h0OiAxNnB4ICFpbXBvcnRhbnQ7XFxufVxcbi5wLXItMTYge1xcbiAgcGFkZGluZy1yaWdodDogMTZweCAhaW1wb3J0YW50O1xcbn1cXG4ubS10LTI0IHtcXG4gIG1hcmdpbi10b3A6IDI0cHggIWltcG9ydGFudDtcXG59XFxuLnAtdC0yNCB7XFxuICBwYWRkaW5nLXRvcDogMjRweCAhaW1wb3J0YW50O1xcbn1cXG4ubS1iLTI0IHtcXG4gIG1hcmdpbi1ib3R0b206IDI0cHggIWltcG9ydGFudDtcXG59XFxuLnAtYi0yNCB7XFxuICBwYWRkaW5nLWJvdHRvbTogMjRweCAhaW1wb3J0YW50O1xcbn1cXG4ubS1sLTI0IHtcXG4gIG1hcmdpbi1sZWZ0OiAyNHB4ICFpbXBvcnRhbnQ7XFxufVxcbi5wLWwtMjQge1xcbiAgcGFkZGluZy1sZWZ0OiAyNHB4ICFpbXBvcnRhbnQ7XFxufVxcbi5tLXItMjQge1xcbiAgbWFyZ2luLXJpZ2h0OiAyNHB4ICFpbXBvcnRhbnQ7XFxufVxcbi5wLXItMjQge1xcbiAgcGFkZGluZy1yaWdodDogMjRweCAhaW1wb3J0YW50O1xcbn1cXG4ubS10LTMyIHtcXG4gIG1hcmdpbi10b3A6IDMycHggIWltcG9ydGFudDtcXG59XFxuLnAtdC0zMiB7XFxuICBwYWRkaW5nLXRvcDogMzJweCAhaW1wb3J0YW50O1xcbn1cXG4ubS1iLTMyIHtcXG4gIG1hcmdpbi1ib3R0b206IDMycHggIWltcG9ydGFudDtcXG59XFxuLnAtYi0zMiB7XFxuICBwYWRkaW5nLWJvdHRvbTogMzJweCAhaW1wb3J0YW50O1xcbn1cXG4ubS1sLTMyIHtcXG4gIG1hcmdpbi1sZWZ0OiAzMnB4ICFpbXBvcnRhbnQ7XFxufVxcbi5wLWwtMzIge1xcbiAgcGFkZGluZy1sZWZ0OiAzMnB4ICFpbXBvcnRhbnQ7XFxufVxcbi5tLXItMzIge1xcbiAgbWFyZ2luLXJpZ2h0OiAzMnB4ICFpbXBvcnRhbnQ7XFxufVxcbi5wLXItMzIge1xcbiAgcGFkZGluZy1yaWdodDogMzJweCAhaW1wb3J0YW50O1xcbn1cXG4ubS10LTQwIHtcXG4gIG1hcmdpbi10b3A6IDQwcHggIWltcG9ydGFudDtcXG59XFxuLnAtdC00MCB7XFxuICBwYWRkaW5nLXRvcDogNDBweCAhaW1wb3J0YW50O1xcbn1cXG4ubS1iLTQwIHtcXG4gIG1hcmdpbi1ib3R0b206IDQwcHggIWltcG9ydGFudDtcXG59XFxuLnAtYi00MCB7XFxuICBwYWRkaW5nLWJvdHRvbTogNDBweCAhaW1wb3J0YW50O1xcbn1cXG4ubS1sLTQwIHtcXG4gIG1hcmdpbi1sZWZ0OiA0MHB4ICFpbXBvcnRhbnQ7XFxufVxcbi5wLWwtNDAge1xcbiAgcGFkZGluZy1sZWZ0OiA0MHB4ICFpbXBvcnRhbnQ7XFxufVxcbi5tLXItNDAge1xcbiAgbWFyZ2luLXJpZ2h0OiA0MHB4ICFpbXBvcnRhbnQ7XFxufVxcbi5wLXItNDAge1xcbiAgcGFkZGluZy1yaWdodDogNDBweCAhaW1wb3J0YW50O1xcbn1cXG4ubS10LTQ4IHtcXG4gIG1hcmdpbi10b3A6IDQ4cHggIWltcG9ydGFudDtcXG59XFxuLnAtdC00OCB7XFxuICBwYWRkaW5nLXRvcDogNDhweCAhaW1wb3J0YW50O1xcbn1cXG4ubS1iLTQ4IHtcXG4gIG1hcmdpbi1ib3R0b206IDQ4cHggIWltcG9ydGFudDtcXG59XFxuLnAtYi00OCB7XFxuICBwYWRkaW5nLWJvdHRvbTogNDhweCAhaW1wb3J0YW50O1xcbn1cXG4ubS1sLTQ4IHtcXG4gIG1hcmdpbi1sZWZ0OiA0OHB4ICFpbXBvcnRhbnQ7XFxufVxcbi5wLWwtNDgge1xcbiAgcGFkZGluZy1sZWZ0OiA0OHB4ICFpbXBvcnRhbnQ7XFxufVxcbi5tLXItNDgge1xcbiAgbWFyZ2luLXJpZ2h0OiA0OHB4ICFpbXBvcnRhbnQ7XFxufVxcbi5wLXItNDgge1xcbiAgcGFkZGluZy1yaWdodDogNDhweCAhaW1wb3J0YW50O1xcbn1cXG4ubS10LTU2IHtcXG4gIG1hcmdpbi10b3A6IDU2cHggIWltcG9ydGFudDtcXG59XFxuLnAtdC01NiB7XFxuICBwYWRkaW5nLXRvcDogNTZweCAhaW1wb3J0YW50O1xcbn1cXG4ubS1iLTU2IHtcXG4gIG1hcmdpbi1ib3R0b206IDU2cHggIWltcG9ydGFudDtcXG59XFxuLnAtYi01NiB7XFxuICBwYWRkaW5nLWJvdHRvbTogNTZweCAhaW1wb3J0YW50O1xcbn1cXG4ubS1sLTU2IHtcXG4gIG1hcmdpbi1sZWZ0OiA1NnB4ICFpbXBvcnRhbnQ7XFxufVxcbi5wLWwtNTYge1xcbiAgcGFkZGluZy1sZWZ0OiA1NnB4ICFpbXBvcnRhbnQ7XFxufVxcbi5tLXItNTYge1xcbiAgbWFyZ2luLXJpZ2h0OiA1NnB4ICFpbXBvcnRhbnQ7XFxufVxcbi5wLXItNTYge1xcbiAgcGFkZGluZy1yaWdodDogNTZweCAhaW1wb3J0YW50O1xcbn1cXG4ubS10LTY0IHtcXG4gIG1hcmdpbi10b3A6IDY0cHggIWltcG9ydGFudDtcXG59XFxuLnAtdC02NCB7XFxuICBwYWRkaW5nLXRvcDogNjRweCAhaW1wb3J0YW50O1xcbn1cXG4ubS1iLTY0IHtcXG4gIG1hcmdpbi1ib3R0b206IDY0cHggIWltcG9ydGFudDtcXG59XFxuLnAtYi02NCB7XFxuICBwYWRkaW5nLWJvdHRvbTogNjRweCAhaW1wb3J0YW50O1xcbn1cXG4ubS1sLTY0IHtcXG4gIG1hcmdpbi1sZWZ0OiA2NHB4ICFpbXBvcnRhbnQ7XFxufVxcbi5wLWwtNjQge1xcbiAgcGFkZGluZy1sZWZ0OiA2NHB4ICFpbXBvcnRhbnQ7XFxufVxcbi5tLXItNjQge1xcbiAgbWFyZ2luLXJpZ2h0OiA2NHB4ICFpbXBvcnRhbnQ7XFxufVxcbi5wLXItNjQge1xcbiAgcGFkZGluZy1yaWdodDogNjRweCAhaW1wb3J0YW50O1xcbn1cXG4ubS10LTcyIHtcXG4gIG1hcmdpbi10b3A6IDcycHggIWltcG9ydGFudDtcXG59XFxuLnAtdC03MiB7XFxuICBwYWRkaW5nLXRvcDogNzJweCAhaW1wb3J0YW50O1xcbn1cXG4ubS1iLTcyIHtcXG4gIG1hcmdpbi1ib3R0b206IDcycHggIWltcG9ydGFudDtcXG59XFxuLnAtYi03MiB7XFxuICBwYWRkaW5nLWJvdHRvbTogNzJweCAhaW1wb3J0YW50O1xcbn1cXG4ubS1sLTcyIHtcXG4gIG1hcmdpbi1sZWZ0OiA3MnB4ICFpbXBvcnRhbnQ7XFxufVxcbi5wLWwtNzIge1xcbiAgcGFkZGluZy1sZWZ0OiA3MnB4ICFpbXBvcnRhbnQ7XFxufVxcbi5tLXItNzIge1xcbiAgbWFyZ2luLXJpZ2h0OiA3MnB4ICFpbXBvcnRhbnQ7XFxufVxcbi5wLXItNzIge1xcbiAgcGFkZGluZy1yaWdodDogNzJweCAhaW1wb3J0YW50O1xcbn1cXG4ubS10LTgwIHtcXG4gIG1hcmdpbi10b3A6IDgwcHggIWltcG9ydGFudDtcXG59XFxuLnAtdC04MCB7XFxuICBwYWRkaW5nLXRvcDogODBweCAhaW1wb3J0YW50O1xcbn1cXG4ubS1iLTgwIHtcXG4gIG1hcmdpbi1ib3R0b206IDgwcHggIWltcG9ydGFudDtcXG59XFxuLnAtYi04MCB7XFxuICBwYWRkaW5nLWJvdHRvbTogODBweCAhaW1wb3J0YW50O1xcbn1cXG4ubS1sLTgwIHtcXG4gIG1hcmdpbi1sZWZ0OiA4MHB4ICFpbXBvcnRhbnQ7XFxufVxcbi5wLWwtODAge1xcbiAgcGFkZGluZy1sZWZ0OiA4MHB4ICFpbXBvcnRhbnQ7XFxufVxcbi5tLXItODAge1xcbiAgbWFyZ2luLXJpZ2h0OiA4MHB4ICFpbXBvcnRhbnQ7XFxufVxcbi5wLXItODAge1xcbiAgcGFkZGluZy1yaWdodDogODBweCAhaW1wb3J0YW50O1xcbn1cXG4ubS10LTEyMCB7XFxuICBtYXJnaW4tdG9wOiAxMjBweCAhaW1wb3J0YW50O1xcbn1cXG4ucC10LTEyMCB7XFxuICBwYWRkaW5nLXRvcDogMTIwcHggIWltcG9ydGFudDtcXG59XFxuLm0tYi0xMjAge1xcbiAgbWFyZ2luLWJvdHRvbTogMTIwcHggIWltcG9ydGFudDtcXG59XFxuLnAtYi0xMjAge1xcbiAgcGFkZGluZy1ib3R0b206IDEyMHB4ICFpbXBvcnRhbnQ7XFxufVxcbi5tLWwtMTIwIHtcXG4gIG1hcmdpbi1sZWZ0OiAxMjBweCAhaW1wb3J0YW50O1xcbn1cXG4ucC1sLTEyMCB7XFxuICBwYWRkaW5nLWxlZnQ6IDEyMHB4ICFpbXBvcnRhbnQ7XFxufVxcbi5tLXItMTIwIHtcXG4gIG1hcmdpbi1yaWdodDogMTIwcHggIWltcG9ydGFudDtcXG59XFxuLnAtci0xMjAge1xcbiAgcGFkZGluZy1yaWdodDogMTIwcHggIWltcG9ydGFudDtcXG59XFxuLm0tdC0xNjAge1xcbiAgbWFyZ2luLXRvcDogMTYwcHggIWltcG9ydGFudDtcXG59XFxuLnAtdC0xNjAge1xcbiAgcGFkZGluZy10b3A6IDE2MHB4ICFpbXBvcnRhbnQ7XFxufVxcbi5tLWItMTYwIHtcXG4gIG1hcmdpbi1ib3R0b206IDE2MHB4ICFpbXBvcnRhbnQ7XFxufVxcbi5wLWItMTYwIHtcXG4gIHBhZGRpbmctYm90dG9tOiAxNjBweCAhaW1wb3J0YW50O1xcbn1cXG4ubS1sLTE2MCB7XFxuICBtYXJnaW4tbGVmdDogMTYwcHggIWltcG9ydGFudDtcXG59XFxuLnAtbC0xNjAge1xcbiAgcGFkZGluZy1sZWZ0OiAxNjBweCAhaW1wb3J0YW50O1xcbn1cXG4ubS1yLTE2MCB7XFxuICBtYXJnaW4tcmlnaHQ6IDE2MHB4ICFpbXBvcnRhbnQ7XFxufVxcbi5wLXItMTYwIHtcXG4gIHBhZGRpbmctcmlnaHQ6IDE2MHB4ICFpbXBvcnRhbnQ7XFxufVxcblxcbioge1xcbiAgbWFyZ2luOiAwO1xcbiAgcGFkZGluZzogMDtcXG4gIGJveC1zaXppbmc6IGJvcmRlci1ib3g7XFxufVxcblxcbmh0bWwge1xcbiAgYmFja2dyb3VuZDogIzEzMTMxNjtcXG4gIHNjcm9sbC1iZWhhdmlvcjogc21vb3RoO1xcbiAgY29sb3Itc2NoZW1lOiBkYXJrO1xcbn1cXG5cXG5ib2R5IHtcXG4gIGZvbnQtZmFtaWx5OiB2YXIoLS1ib2R5LWZvbnQtZmFtaWx5KTtcXG4gIGZvbnQtc2l6ZTogMTRweDtcXG4gIGNvbG9yOiB2YXIoLS1jbHItbmV1dHJhbC0zMDApO1xcbn1cXG5cXG5oZWFkZXIge1xcbiAgcGFkZGluZzogMjRweCAzMnB4O1xcbiAgZGlzcGxheTogZmxleDtcXG4gIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxuICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcXG4gIGJhY2tncm91bmQ6ICMwMDAwMDA7XFxuICBib3gtc2hhZG93OiAwcHggMXB4IDBweCByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuMTUpO1xcbn1cXG5cXG4uaGVhZGVyLWlubmVyIHtcXG4gIGZsZXg6IDE7XFxuICBkaXNwbGF5OiBmbGV4O1xcbiAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXG4gIG1heC13aWR0aDogMTEwMHB4O1xcbn1cXG5cXG4uYnVpbGQtbm90ZXMge1xcbiAgZmxleDogMTtcXG4gIGRpc3BsYXk6IGZsZXg7XFxuICBqdXN0aWZ5LWNvbnRlbnQ6IGZsZXgtZW5kO1xcbiAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXG59XFxuXFxuLmJ1aWxkLW5vdGUge1xcbiAgbGluZS1oZWlnaHQ6IDE7XFxuICBkaXNwbGF5OiBmbGV4O1xcbiAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXG4gIGNvbG9yOiB2YXIoLS1jbHItbmV1dHJhbC00NTApO1xcbn1cXG5cXG4uYnVpbGQtbm90ZSArIC5idWlsZC1ub3RlIHtcXG4gIG1hcmdpbi1sZWZ0OiAxNnB4O1xcbn1cXG5cXG4uYnVpbGQtbm90ZSA+IHN2ZyB7XFxuICBtYXJnaW4tcmlnaHQ6IDhweDtcXG59XFxuXFxuaDEge1xcbiAgZm9udC1mYW1pbHk6IHZhcigtLWhlYWRpbmctZm9udC1mYW1pbHkpO1xcbiAgZm9udC1zaXplOiAyMHB4O1xcbiAgZm9udC13ZWlnaHQ6IGJvbGQ7XFxuICBjb2xvcjogdmFyKC0tY2xyLW5ldXRyYWwtMCk7XFxufVxcblxcbmgyIHtcXG4gIGZvbnQtZmFtaWx5OiB2YXIoLS1oZWFkaW5nLWZvbnQtZmFtaWx5KTtcXG4gIGZvbnQtc2l6ZTogMTZweDtcXG4gIGZvbnQtd2VpZ2h0OiA2MDA7XFxuICBjb2xvcjogdmFyKC0tY2xyLW5ldXRyYWwtNTApO1xcbn1cXG5cXG5oMyB7XFxuICBmb250LWZhbWlseTogdmFyKC0taGVhZGluZy1mb250LWZhbWlseSk7XFxuICBmb250LXNpemU6IDE2cHg7XFxuICBmb250LXdlaWdodDogNTAwO1xcbiAgY29sb3I6IHZhcigtLWNsci1uZXV0cmFsLTEwMCk7XFxufVxcblxcbmJ1dHRvbiB7XFxuICBib3JkZXI6IG5vbmU7XFxuICBjb2xvcjogdmFyKC0tY2xyLW5ldXRyYWwtNTApO1xcbiAgYmFja2dyb3VuZDogbGluZWFyLWdyYWRpZW50KDkwZGVnLCAjNjE2YWNiIDAlLCAjNDg1NGJiIDEwMCUpO1xcbiAgYm9yZGVyLXJhZGl1czogNHB4O1xcbiAgZm9udC1mYW1pbHk6IHZhcigtLWJvZHktZm9udC1mYW1pbHkpO1xcbiAgZm9udC1zaXplOiAxNHB4O1xcbiAgcGFkZGluZzogMTJweCAxOHB4O1xcbiAgY3Vyc29yOiBwb2ludGVyO1xcbn1cXG5cXG5idXR0b24uc2Vjb25kYXJ5IHtcXG4gIGJvcmRlcjogMXB4IHNvbGlkIHZhcigtLWNsci1wcmltYXJ5LTUwMCk7XFxuICBiYWNrZ3JvdW5kOiB0cmFuc3BhcmVudDtcXG59XFxuXFxuYnV0dG9uOmRpc2FibGVkIHtcXG4gIGNvbG9yOiB2YXIoLS1jbHItbmV1dHJhbC00MDApO1xcbiAgYmFja2dyb3VuZDogdmFyKC0tY2xyLW5ldXRyYWwtODUwKTtcXG4gIGN1cnNvcjogaW5oZXJpdDtcXG59XFxuXFxuaW5wdXQge1xcbiAgZm9udC1zaXplOiAxNHB4O1xcbn1cXG5cXG5pbnB1dFt0eXBlPVxcXCJ0ZXh0XFxcIl0ge1xcbiAgZm9udC1mYW1pbHk6IHZhcigtLWJvZHktZm9udC1mYW1pbHkpO1xcbiAgYmFja2dyb3VuZDogdmFyKC0tY2xyLW5ldXRyYWwtOTUwKTtcXG4gIGJvcmRlcjogMXB4IHNvbGlkIHZhcigtLWNsci1uZXV0cmFsLTg1MCk7XFxuICBib3JkZXItcmFkaXVzOiA1cHg7XFxuICBwYWRkaW5nOiAxMnB4IDE2cHg7XFxufVxcblxcbi5iYWRnZSB7XFxuICBkaXNwbGF5OiBmbGV4O1xcbiAgZmxleC1kaXJlY3Rpb246IHJvdztcXG4gIGp1c3RpZnktY29udGVudDogY2VudGVyO1xcbiAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXG4gIHBhZGRpbmc6IDRweCA4cHg7XFxuICBmb250LXNpemU6IDEycHg7XFxuICBmb250LXdlaWdodDogNTAwO1xcbiAgYm9yZGVyLXJhZGl1czogMjRweDtcXG4gIGJhY2tncm91bmQ6IHZhcigtLWNsci1uZXV0cmFsLTkwMCk7XFxuICBjb2xvcjogdmFyKC0tY2xyLW5ldXRyYWwtMzAwKTtcXG59XFxuXFxuLmJhZGdlLm9rIHtcXG4gIGJhY2tncm91bmQ6IHZhcigtLWNsci1wcmltYXJ5LTkwMCk7XFxuICBjb2xvcjogdmFyKC0tY2xyLXByaW1hcnktMzAwKTtcXG59XFxuXFxuLmJhY2tkcm9wIHtcXG4gIHdpZHRoOiAxMDAlO1xcbiAgaGVpZ2h0OiAxODBweDtcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gIHotaW5kZXg6IC01O1xcbiAgcG9pbnRlci1ldmVudHM6IG5vbmU7XFxuICBiYWNrZ3JvdW5kOiAjMDAwMDAwO1xcbn1cXG5cXG4uZGVtbyB7XFxuICBwYWRkaW5nOiAzMnB4O1xcbiAgbWF4LXdpZHRoOiAxMTAwcHg7XFxuICBtYXJnaW46IGF1dG87XFxufVxcblxcbi5mbGV4IHtcXG4gIGRpc3BsYXk6IGZsZXg7XFxuICBhbGlnbi1pdGVtczogY2VudGVyO1xcbn1cXG5cXG5zdmcge1xcbiAgZmxleC1zaHJpbms6IDA7XFxufVxcblxcbi5jYXJkIHtcXG4gIGJhY2tncm91bmQ6IHZhcigtLWNsci1uZXV0cmFsLTkyNSk7XFxuICBib3gtc2hhZG93OiAwcHggOHB4IDUwcHggcmdiYSgwLCAwLCAwLCAwLjI1KTtcXG4gIGJvcmRlci1yYWRpdXM6IDhweDtcXG4gIHBhZGRpbmc6IDI0cHg7XFxuICBtYXJnaW46IDI0cHggMDtcXG59XFxuXFxuLmNhcmQtdG9wIHtcXG4gIGRpc3BsYXk6IGZsZXg7XFxuICBhbGlnbi1pdGVtczogY2VudGVyO1xcbiAgbWFyZ2luLWJvdHRvbTogOHB4O1xcbn1cXG5cXG4uY2FyZC10b3AgPiAqICsgKiB7XFxuICBtYXJnaW4tbGVmdDogOHB4O1xcbn1cXG5cXG4ud2lkZ2V0LWJvZHkge1xcbiAgZGlzcGxheTogZmxleDtcXG59XFxuXFxuLnN0cmVhbS1jb2x1bW4ge1xcbiAgZmxleDogMjtcXG59XFxuXFxuLmNoYXQtY29sdW1uIHtcXG4gIGZsZXg6IDE7XFxuICBkaXNwbGF5OiBmbGV4O1xcbiAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcXG59XFxuXFxuLmNoYXQtaGlzdG9yeSB7XFxuICBmbGV4OiAxO1xcbn1cXG5cXG4uY2hhdC1ib3R0b20ge1xcbiAgZGlzcGxheTogZmxleDtcXG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG4gIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxufVxcblxcbi5jaGF0LWlucHV0IHtcXG4gIGZsZXg6IDE7XFxufVxcblxcbmJ1dHRvbi5jaGF0LXNlbmQtYnV0dG9uIHtcXG4gIGN1cnNvcjogcG9pbnRlcjtcXG4gIGJhY2tncm91bmQ6IG5vbmU7XFxuICBwYWRkaW5nOiAwO1xcbiAgbWFyZ2luOiAwO1xcbiAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgcmlnaHQ6IDE2cHg7XFxuICBtYXJnaW4tdG9wOiBhdXRvO1xcbn1cXG5cXG5idXR0b24uY2hhdC1zZW5kLWJ1dHRvbjpkaXNhYmxlZCB7XFxuICBjdXJzb3I6IGluaGVyaXQ7XFxuICBmaWx0ZXI6IGdyYXlzY2FsZSgpO1xcbn1cXG4uc3RyZWFtLXNlbGVjdG9yIHtcXG4gIGRpc3BsYXk6IGZsZXg7XFxufVxcblxcbi5zdHJlYW0tc2VsZWN0b3IgPiBzZWxlY3Qge1xcbiAgbWFyZ2luLXJpZ2h0OiA4cHg7XFxufVxcblxcbi5zdHJlYW0td3JhcHBlciB7XFxuICBib3JkZXI6IDFweCBzb2xpZCByZ2JhKDAsIDAsIDAsIDAuNCk7XFxuICBiYWNrZ3JvdW5kLWltYWdlOiAvKiB1cmwoXFxcImh0dHBzOi8vcmFpbndheS5jb20vaW1hZ2VzL2xvZ28uc3ZnXFxcIiksICovXFxuICAgIGxpbmVhci1ncmFkaWVudCgtNDVkZWcsICMxNDE2MjUsICMyNDE2MzUpO1xcbiAgYmFja2dyb3VuZC1yZXBlYXQ6IG5vLXJlcGVhdDtcXG4gIGJhY2tncm91bmQtcG9zaXRpb246IGNlbnRlcjtcXG4gIHdpZHRoOiAxMDAlO1xcbiAgaGVpZ2h0OiAzOTNweDtcXG59XFxuXFxuYSB7XFxuICBjb2xvcjogdmFyKC0tY2xyLXByaW1hcnktNDAwKTtcXG4gIGZvbnQtd2VpZ2h0OiA2MDA7XFxuICB0ZXh0LWRlY29yYXRpb246IG5vbmU7XFxuICB0cmFuc2l0aW9uOiBjb2xvciAwLjJzIGVhc2U7XFxufVxcblxcbmE6aG92ZXIge1xcbiAgY29sb3I6IHZhcigtLWNsci1uZXV0cmFsLTUwKTtcXG59XFxuXCIsIFwiXCJdKTtcbi8vIEV4cG9ydHNcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cztcbiIsIlwidXNlIHN0cmljdFwiO1xuXG4vKlxuICBNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxuICBBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXG4qL1xuLy8gY3NzIGJhc2UgY29kZSwgaW5qZWN0ZWQgYnkgdGhlIGNzcy1sb2FkZXJcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBmdW5jLW5hbWVzXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh1c2VTb3VyY2VNYXApIHtcbiAgdmFyIGxpc3QgPSBbXTsgLy8gcmV0dXJuIHRoZSBsaXN0IG9mIG1vZHVsZXMgYXMgY3NzIHN0cmluZ1xuXG4gIGxpc3QudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gdGhpcy5tYXAoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgIHZhciBjb250ZW50ID0gY3NzV2l0aE1hcHBpbmdUb1N0cmluZyhpdGVtLCB1c2VTb3VyY2VNYXApO1xuXG4gICAgICBpZiAoaXRlbVsyXSkge1xuICAgICAgICByZXR1cm4gXCJAbWVkaWEgXCIuY29uY2F0KGl0ZW1bMl0sIFwiIHtcIikuY29uY2F0KGNvbnRlbnQsIFwifVwiKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGNvbnRlbnQ7XG4gICAgfSkuam9pbignJyk7XG4gIH07IC8vIGltcG9ydCBhIGxpc3Qgb2YgbW9kdWxlcyBpbnRvIHRoZSBsaXN0XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBmdW5jLW5hbWVzXG5cblxuICBsaXN0LmkgPSBmdW5jdGlvbiAobW9kdWxlcywgbWVkaWFRdWVyeSwgZGVkdXBlKSB7XG4gICAgaWYgKHR5cGVvZiBtb2R1bGVzID09PSAnc3RyaW5nJykge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgICBtb2R1bGVzID0gW1tudWxsLCBtb2R1bGVzLCAnJ11dO1xuICAgIH1cblxuICAgIHZhciBhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzID0ge307XG5cbiAgICBpZiAoZGVkdXBlKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHByZWZlci1kZXN0cnVjdHVyaW5nXG4gICAgICAgIHZhciBpZCA9IHRoaXNbaV1bMF07XG5cbiAgICAgICAgaWYgKGlkICE9IG51bGwpIHtcbiAgICAgICAgICBhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzW2lkXSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgbW9kdWxlcy5sZW5ndGg7IF9pKyspIHtcbiAgICAgIHZhciBpdGVtID0gW10uY29uY2F0KG1vZHVsZXNbX2ldKTtcblxuICAgICAgaWYgKGRlZHVwZSAmJiBhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzW2l0ZW1bMF1dKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb250aW51ZVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKG1lZGlhUXVlcnkpIHtcbiAgICAgICAgaWYgKCFpdGVtWzJdKSB7XG4gICAgICAgICAgaXRlbVsyXSA9IG1lZGlhUXVlcnk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaXRlbVsyXSA9IFwiXCIuY29uY2F0KG1lZGlhUXVlcnksIFwiIGFuZCBcIikuY29uY2F0KGl0ZW1bMl0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGxpc3QucHVzaChpdGVtKTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIGxpc3Q7XG59O1xuXG5mdW5jdGlvbiBjc3NXaXRoTWFwcGluZ1RvU3RyaW5nKGl0ZW0sIHVzZVNvdXJjZU1hcCkge1xuICB2YXIgY29udGVudCA9IGl0ZW1bMV0gfHwgJyc7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBwcmVmZXItZGVzdHJ1Y3R1cmluZ1xuXG4gIHZhciBjc3NNYXBwaW5nID0gaXRlbVszXTtcblxuICBpZiAoIWNzc01hcHBpbmcpIHtcbiAgICByZXR1cm4gY29udGVudDtcbiAgfVxuXG4gIGlmICh1c2VTb3VyY2VNYXAgJiYgdHlwZW9mIGJ0b2EgPT09ICdmdW5jdGlvbicpIHtcbiAgICB2YXIgc291cmNlTWFwcGluZyA9IHRvQ29tbWVudChjc3NNYXBwaW5nKTtcbiAgICB2YXIgc291cmNlVVJMcyA9IGNzc01hcHBpbmcuc291cmNlcy5tYXAoZnVuY3Rpb24gKHNvdXJjZSkge1xuICAgICAgcmV0dXJuIFwiLyojIHNvdXJjZVVSTD1cIi5jb25jYXQoY3NzTWFwcGluZy5zb3VyY2VSb290IHx8ICcnKS5jb25jYXQoc291cmNlLCBcIiAqL1wiKTtcbiAgICB9KTtcbiAgICByZXR1cm4gW2NvbnRlbnRdLmNvbmNhdChzb3VyY2VVUkxzKS5jb25jYXQoW3NvdXJjZU1hcHBpbmddKS5qb2luKCdcXG4nKTtcbiAgfVxuXG4gIHJldHVybiBbY29udGVudF0uam9pbignXFxuJyk7XG59IC8vIEFkYXB0ZWQgZnJvbSBjb252ZXJ0LXNvdXJjZS1tYXAgKE1JVClcblxuXG5mdW5jdGlvbiB0b0NvbW1lbnQoc291cmNlTWFwKSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlZlxuICB2YXIgYmFzZTY0ID0gYnRvYSh1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoSlNPTi5zdHJpbmdpZnkoc291cmNlTWFwKSkpKTtcbiAgdmFyIGRhdGEgPSBcInNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2NoYXJzZXQ9dXRmLTg7YmFzZTY0LFwiLmNvbmNhdChiYXNlNjQpO1xuICByZXR1cm4gXCIvKiMgXCIuY29uY2F0KGRhdGEsIFwiICovXCIpO1xufSIsIi8qXG5vYmplY3QtYXNzaWduXG4oYykgU2luZHJlIFNvcmh1c1xuQGxpY2Vuc2UgTUlUXG4qL1xuXG4ndXNlIHN0cmljdCc7XG4vKiBlc2xpbnQtZGlzYWJsZSBuby11bnVzZWQtdmFycyAqL1xudmFyIGdldE93blByb3BlcnR5U3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIHByb3BJc0VudW1lcmFibGUgPSBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xuXG5mdW5jdGlvbiB0b09iamVjdCh2YWwpIHtcblx0aWYgKHZhbCA9PT0gbnVsbCB8fCB2YWwgPT09IHVuZGVmaW5lZCkge1xuXHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ09iamVjdC5hc3NpZ24gY2Fubm90IGJlIGNhbGxlZCB3aXRoIG51bGwgb3IgdW5kZWZpbmVkJyk7XG5cdH1cblxuXHRyZXR1cm4gT2JqZWN0KHZhbCk7XG59XG5cbmZ1bmN0aW9uIHNob3VsZFVzZU5hdGl2ZSgpIHtcblx0dHJ5IHtcblx0XHRpZiAoIU9iamVjdC5hc3NpZ24pIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHQvLyBEZXRlY3QgYnVnZ3kgcHJvcGVydHkgZW51bWVyYXRpb24gb3JkZXIgaW4gb2xkZXIgVjggdmVyc2lvbnMuXG5cblx0XHQvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD00MTE4XG5cdFx0dmFyIHRlc3QxID0gbmV3IFN0cmluZygnYWJjJyk7ICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5ldy13cmFwcGVyc1xuXHRcdHRlc3QxWzVdID0gJ2RlJztcblx0XHRpZiAoT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGVzdDEpWzBdID09PSAnNScpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHQvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD0zMDU2XG5cdFx0dmFyIHRlc3QyID0ge307XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCAxMDsgaSsrKSB7XG5cdFx0XHR0ZXN0MlsnXycgKyBTdHJpbmcuZnJvbUNoYXJDb2RlKGkpXSA9IGk7XG5cdFx0fVxuXHRcdHZhciBvcmRlcjIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0ZXN0MikubWFwKGZ1bmN0aW9uIChuKSB7XG5cdFx0XHRyZXR1cm4gdGVzdDJbbl07XG5cdFx0fSk7XG5cdFx0aWYgKG9yZGVyMi5qb2luKCcnKSAhPT0gJzAxMjM0NTY3ODknKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0Ly8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9MzA1NlxuXHRcdHZhciB0ZXN0MyA9IHt9O1xuXHRcdCdhYmNkZWZnaGlqa2xtbm9wcXJzdCcuc3BsaXQoJycpLmZvckVhY2goZnVuY3Rpb24gKGxldHRlcikge1xuXHRcdFx0dGVzdDNbbGV0dGVyXSA9IGxldHRlcjtcblx0XHR9KTtcblx0XHRpZiAoT2JqZWN0LmtleXMoT2JqZWN0LmFzc2lnbih7fSwgdGVzdDMpKS5qb2luKCcnKSAhPT1cblx0XHRcdFx0J2FiY2RlZmdoaWprbG1ub3BxcnN0Jykge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdHJldHVybiB0cnVlO1xuXHR9IGNhdGNoIChlcnIpIHtcblx0XHQvLyBXZSBkb24ndCBleHBlY3QgYW55IG9mIHRoZSBhYm92ZSB0byB0aHJvdywgYnV0IGJldHRlciB0byBiZSBzYWZlLlxuXHRcdHJldHVybiBmYWxzZTtcblx0fVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNob3VsZFVzZU5hdGl2ZSgpID8gT2JqZWN0LmFzc2lnbiA6IGZ1bmN0aW9uICh0YXJnZXQsIHNvdXJjZSkge1xuXHR2YXIgZnJvbTtcblx0dmFyIHRvID0gdG9PYmplY3QodGFyZ2V0KTtcblx0dmFyIHN5bWJvbHM7XG5cblx0Zm9yICh2YXIgcyA9IDE7IHMgPCBhcmd1bWVudHMubGVuZ3RoOyBzKyspIHtcblx0XHRmcm9tID0gT2JqZWN0KGFyZ3VtZW50c1tzXSk7XG5cblx0XHRmb3IgKHZhciBrZXkgaW4gZnJvbSkge1xuXHRcdFx0aWYgKGhhc093blByb3BlcnR5LmNhbGwoZnJvbSwga2V5KSkge1xuXHRcdFx0XHR0b1trZXldID0gZnJvbVtrZXldO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmIChnZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcblx0XHRcdHN5bWJvbHMgPSBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZnJvbSk7XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHN5bWJvbHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0aWYgKHByb3BJc0VudW1lcmFibGUuY2FsbChmcm9tLCBzeW1ib2xzW2ldKSkge1xuXHRcdFx0XHRcdHRvW3N5bWJvbHNbaV1dID0gZnJvbVtzeW1ib2xzW2ldXTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiB0bztcbn07XG4iLCIhZnVuY3Rpb24oQSxlKXtcIm9iamVjdFwiPT10eXBlb2YgZXhwb3J0cyYmXCJvYmplY3RcIj09dHlwZW9mIG1vZHVsZT9tb2R1bGUuZXhwb3J0cz1lKCk6XCJmdW5jdGlvblwiPT10eXBlb2YgZGVmaW5lJiZkZWZpbmUuYW1kP2RlZmluZShbXSxlKTpcIm9iamVjdFwiPT10eXBlb2YgZXhwb3J0cz9leHBvcnRzW1wicmFpbndheS1zZGtcIl09ZSgpOkFbXCJyYWlud2F5LXNka1wiXT1lKCl9KHNlbGYsKGZ1bmN0aW9uKCl7cmV0dXJuKCgpPT57dmFyIEE9ezcxMjA6KEEsZSxJKT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLGUuQmVib3BWaWV3PWUuQmVib3BSdW50aW1lRXJyb3I9dm9pZCAwO2NvbnN0IGc9XCIwMTIzNDU2Nzg5YWJjZGVmXCIsdD1bMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwxLDIsMyw0LDUsNiw3LDgsOSwwLDAsMCwwLDAsMCwwLDEwLDExLDEyLDEzLDE0LDE1LDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwxMCwxMSwxMiwxMywxNCwxNSwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwXSxpPW5ldyBVaW50OEFycmF5KDApLEI9W107Zm9yKGNvbnN0IEEgb2YgZylmb3IoY29uc3QgZSBvZiBnKUIucHVzaChBK2UpO1widW5kZWZpbmVkXCI9PXR5cGVvZiBUZXh0RGVjb2RlciYmKEkuZy5UZXh0RGVjb2Rlcj1JKDEzMjMpLlRleHREZWNvZGVyKTtjbGFzcyBDIGV4dGVuZHMgRXJyb3J7Y29uc3RydWN0b3IoQSl7c3VwZXIoQSksdGhpcy5uYW1lPVwiQmVib3BSdW50aW1lRXJyb3JcIn19ZS5CZWJvcFJ1bnRpbWVFcnJvcj1DO2NsYXNzIFF7c3RhdGljIHRleHREZWNvZGVyPW5ldyBUZXh0RGVjb2RlcjtzdGF0aWMgd3JpdGVCdWZmZXI9bmV3IFVpbnQ4QXJyYXkoMjU2KTtzdGF0aWMgd3JpdGVCdWZmZXJWaWV3PW5ldyBEYXRhVmlldyhRLndyaXRlQnVmZmVyLmJ1ZmZlcik7c3RhdGljIGluc3RhbmNlO3N0YXRpYyBnZXRJbnN0YW5jZSgpe3JldHVybiBRLmluc3RhbmNlfHwoUS5pbnN0YW5jZT1uZXcgUSksUS5pbnN0YW5jZX1taW5pbXVtVGV4dERlY29kZXJMZW5ndGg9MzAwO2J1ZmZlcjt2aWV3O2luZGV4O2xlbmd0aDtjb25zdHJ1Y3Rvcigpe3RoaXMuYnVmZmVyPVEud3JpdGVCdWZmZXIsdGhpcy52aWV3PVEud3JpdGVCdWZmZXJWaWV3LHRoaXMuaW5kZXg9MCx0aGlzLmxlbmd0aD0wfXN0YXJ0UmVhZGluZyhBKXt0aGlzLmJ1ZmZlcj1BLHRoaXMudmlldz1uZXcgRGF0YVZpZXcodGhpcy5idWZmZXIuYnVmZmVyLHRoaXMuYnVmZmVyLmJ5dGVPZmZzZXQsdGhpcy5idWZmZXIuYnl0ZUxlbmd0aCksdGhpcy5pbmRleD0wLHRoaXMubGVuZ3RoPUEubGVuZ3RofXN0YXJ0V3JpdGluZygpe3RoaXMuYnVmZmVyPVEud3JpdGVCdWZmZXIsdGhpcy52aWV3PVEud3JpdGVCdWZmZXJWaWV3LHRoaXMuaW5kZXg9MCx0aGlzLmxlbmd0aD0wfWd1YXJhbnRlZUJ1ZmZlckxlbmd0aChBKXtpZihBPnRoaXMuYnVmZmVyLmxlbmd0aCl7Y29uc3QgZT1uZXcgVWludDhBcnJheShBPDwxKTtlLnNldCh0aGlzLmJ1ZmZlciksdGhpcy5idWZmZXI9ZSx0aGlzLnZpZXc9bmV3IERhdGFWaWV3KGUuYnVmZmVyKX19Z3Jvd0J5KEEpe3RoaXMubGVuZ3RoKz1BLHRoaXMuZ3VhcmFudGVlQnVmZmVyTGVuZ3RoKHRoaXMubGVuZ3RoKX1za2lwKEEpe3RoaXMuaW5kZXgrPUF9dG9BcnJheSgpe3JldHVybiB0aGlzLmJ1ZmZlci5zdWJhcnJheSgwLHRoaXMubGVuZ3RoKX1yZWFkQnl0ZSgpe3JldHVybiB0aGlzLmJ1ZmZlclt0aGlzLmluZGV4KytdfXJlYWRVaW50MTYoKXtjb25zdCBBPXRoaXMudmlldy5nZXRVaW50MTYodGhpcy5pbmRleCwhMCk7cmV0dXJuIHRoaXMuaW5kZXgrPTIsQX1yZWFkSW50MTYoKXtjb25zdCBBPXRoaXMudmlldy5nZXRJbnQxNih0aGlzLmluZGV4LCEwKTtyZXR1cm4gdGhpcy5pbmRleCs9MixBfXJlYWRVaW50MzIoKXtjb25zdCBBPXRoaXMudmlldy5nZXRVaW50MzIodGhpcy5pbmRleCwhMCk7cmV0dXJuIHRoaXMuaW5kZXgrPTQsQX1yZWFkSW50MzIoKXtjb25zdCBBPXRoaXMudmlldy5nZXRJbnQzMih0aGlzLmluZGV4LCEwKTtyZXR1cm4gdGhpcy5pbmRleCs9NCxBfXJlYWRVaW50NjQoKXtjb25zdCBBPXRoaXMudmlldy5nZXRCaWdVaW50NjQodGhpcy5pbmRleCwhMCk7cmV0dXJuIHRoaXMuaW5kZXgrPTgsQX1yZWFkSW50NjQoKXtjb25zdCBBPXRoaXMudmlldy5nZXRCaWdJbnQ2NCh0aGlzLmluZGV4LCEwKTtyZXR1cm4gdGhpcy5pbmRleCs9OCxBfXJlYWRGbG9hdDMyKCl7Y29uc3QgQT10aGlzLnZpZXcuZ2V0RmxvYXQzMih0aGlzLmluZGV4LCEwKTtyZXR1cm4gdGhpcy5pbmRleCs9NCxBfXJlYWRGbG9hdDY0KCl7Y29uc3QgQT10aGlzLnZpZXcuZ2V0RmxvYXQ2NCh0aGlzLmluZGV4LCEwKTtyZXR1cm4gdGhpcy5pbmRleCs9OCxBfXdyaXRlQnl0ZShBKXtjb25zdCBlPXRoaXMubGVuZ3RoO3RoaXMuZ3Jvd0J5KDEpLHRoaXMuYnVmZmVyW2VdPUF9d3JpdGVVaW50MTYoQSl7Y29uc3QgZT10aGlzLmxlbmd0aDt0aGlzLmdyb3dCeSgyKSx0aGlzLnZpZXcuc2V0VWludDE2KGUsQSwhMCl9d3JpdGVJbnQxNihBKXtjb25zdCBlPXRoaXMubGVuZ3RoO3RoaXMuZ3Jvd0J5KDIpLHRoaXMudmlldy5zZXRJbnQxNihlLEEsITApfXdyaXRlVWludDMyKEEpe2NvbnN0IGU9dGhpcy5sZW5ndGg7dGhpcy5ncm93QnkoNCksdGhpcy52aWV3LnNldFVpbnQzMihlLEEsITApfXdyaXRlSW50MzIoQSl7Y29uc3QgZT10aGlzLmxlbmd0aDt0aGlzLmdyb3dCeSg0KSx0aGlzLnZpZXcuc2V0SW50MzIoZSxBLCEwKX13cml0ZVVpbnQ2NChBKXtjb25zdCBlPXRoaXMubGVuZ3RoO3RoaXMuZ3Jvd0J5KDgpLHRoaXMudmlldy5zZXRCaWdVaW50NjQoZSxBLCEwKX13cml0ZUludDY0KEEpe2NvbnN0IGU9dGhpcy5sZW5ndGg7dGhpcy5ncm93QnkoOCksdGhpcy52aWV3LnNldEJpZ0ludDY0KGUsQSwhMCl9d3JpdGVGbG9hdDMyKEEpe2NvbnN0IGU9dGhpcy5sZW5ndGg7dGhpcy5ncm93QnkoNCksdGhpcy52aWV3LnNldEZsb2F0MzIoZSxBLCEwKX13cml0ZUZsb2F0NjQoQSl7Y29uc3QgZT10aGlzLmxlbmd0aDt0aGlzLmdyb3dCeSg4KSx0aGlzLnZpZXcuc2V0RmxvYXQ2NChlLEEsITApfXJlYWRCeXRlcygpe2NvbnN0IEE9dGhpcy5yZWFkVWludDMyKCk7aWYoMD09PUEpcmV0dXJuIGk7Y29uc3QgZT10aGlzLmluZGV4LEk9ZStBO3JldHVybiB0aGlzLmluZGV4PUksdGhpcy5idWZmZXIuc3ViYXJyYXkoZSxJKX13cml0ZUJ5dGVzKEEpe2NvbnN0IGU9QS5sZW5ndGg7aWYodGhpcy53cml0ZVVpbnQzMihlKSwwPT09ZSlyZXR1cm47Y29uc3QgST10aGlzLmxlbmd0aDt0aGlzLmdyb3dCeShlKSx0aGlzLmJ1ZmZlci5zZXQoQSxJKX1yZWFkU3RyaW5nKCl7Y29uc3QgQT10aGlzLnJlYWRVaW50MzIoKTtpZigwPT09QSlyZXR1cm5cIlwiO2lmKEE+PXRoaXMubWluaW11bVRleHREZWNvZGVyTGVuZ3RoKXJldHVybiBRLnRleHREZWNvZGVyLmRlY29kZSh0aGlzLmJ1ZmZlci5zdWJhcnJheSh0aGlzLmluZGV4LHRoaXMuaW5kZXgrPUEpKTtjb25zdCBlPXRoaXMuaW5kZXgrQTtsZXQgSSxnPVwiXCI7Zm9yKDt0aGlzLmluZGV4PGU7KXtjb25zdCBBPXRoaXMuYnVmZmVyW3RoaXMuaW5kZXgrK107aWYoQTwxOTIpST1BO2Vsc2V7Y29uc3QgZT10aGlzLmJ1ZmZlclt0aGlzLmluZGV4KytdO2lmKEE8MjI0KUk9KDMxJkEpPDw2fDYzJmU7ZWxzZXtjb25zdCBnPXRoaXMuYnVmZmVyW3RoaXMuaW5kZXgrK107ST1BPDI0MD8oMTUmQSk8PDEyfCg2MyZlKTw8Nnw2MyZnOig3JkEpPDwxOHwoNjMmZSk8PDEyfCg2MyZnKTw8Nnw2MyZ0aGlzLmJ1ZmZlclt0aGlzLmluZGV4KytdfX1JPDY1NTM2P2crPVN0cmluZy5mcm9tQ2hhckNvZGUoSSk6KEktPTY1NTM2LGcrPVN0cmluZy5mcm9tQ2hhckNvZGUoNTUyOTYrKEk+PjEwKSw1NjMyMCsoMTAyMyZJKSkpfXJldHVybiB0aGlzLmluZGV4PWUsZ313cml0ZVN0cmluZyhBKXtjb25zdCBlPUEubGVuZ3RoO2lmKDA9PT1lKXJldHVybiB2b2lkIHRoaXMud3JpdGVVaW50MzIoMCk7Y29uc3QgST00KzMqZTt0aGlzLmd1YXJhbnRlZUJ1ZmZlckxlbmd0aCh0aGlzLmxlbmd0aCtJKTtsZXQgZz10aGlzLmxlbmd0aCs0O2NvbnN0IHQ9ZztsZXQgaTtmb3IobGV0IEk9MDtJPGU7SSsrKXtjb25zdCB0PUEuY2hhckNvZGVBdChJKTtpPUkrMT09PWV8fHQ8NTUyOTZ8fHQ+PTU2MzIwP3Q6KHQ8PDEwKStBLmNoYXJDb2RlQXQoKytJKSstNTY2MTM4ODgsaTwxMjg/dGhpcy5idWZmZXJbZysrXT1pOihpPDIwNDg/dGhpcy5idWZmZXJbZysrXT1pPj42JjMxfDE5MjooaTw2NTUzNj90aGlzLmJ1ZmZlcltnKytdPWk+PjEyJjE1fDIyNDoodGhpcy5idWZmZXJbZysrXT1pPj4xOCY3fDI0MCx0aGlzLmJ1ZmZlcltnKytdPWk+PjEyJjYzfDEyOCksdGhpcy5idWZmZXJbZysrXT1pPj42JjYzfDEyOCksdGhpcy5idWZmZXJbZysrXT02MyZpfDEyOCl9Y29uc3QgQj1nLXQ7dGhpcy52aWV3LnNldFVpbnQzMih0aGlzLmxlbmd0aCxCLCEwKSx0aGlzLmxlbmd0aCs9NCtCfXJlYWRHdWlkKCl7Y29uc3QgQT1CLGU9dGhpcy5idWZmZXIsST10aGlzLmluZGV4LGc9XCItXCI7dmFyIHQ9QVtlW0krM11dO3JldHVybiB0Kz1BW2VbSSsyXV0sdCs9QVtlW0krMV1dLHQrPUFbZVtJXV0sdCs9Zyx0Kz1BW2VbSSs1XV0sdCs9QVtlW0krNF1dLHQrPWcsdCs9QVtlW0krN11dLHQrPUFbZVtJKzZdXSx0Kz1nLHQrPUFbZVtJKzhdXSx0Kz1BW2VbSSs5XV0sdCs9Zyx0Kz1BW2VbSSsxMF1dLHQrPUFbZVtJKzExXV0sdCs9QVtlW0krMTJdXSx0Kz1BW2VbSSsxM11dLHQrPUFbZVtJKzE0XV0sdCs9QVtlW0krMTVdXSx0aGlzLmluZGV4Kz0xNix0fXdyaXRlR3VpZChBKXtjb25zdCBlPXRoaXMudmlldyxJPXRoaXMubGVuZ3RoO3RoaXMuZ3Jvd0J5KDE2KTt2YXIgZz0wLGk9MDtpPShpPShpPShpPShpPShpPShpPShpPWk8PDR8dFtBLmNoYXJDb2RlQXQoZysrKV0pPDw0fHRbQS5jaGFyQ29kZUF0KGcrKyldKTw8NHx0W0EuY2hhckNvZGVBdChnKyspXSk8PDR8dFtBLmNoYXJDb2RlQXQoZysrKV0pPDw0fHRbQS5jaGFyQ29kZUF0KGcrKyldKTw8NHx0W0EuY2hhckNvZGVBdChnKyspXSk8PDR8dFtBLmNoYXJDb2RlQXQoZysrKV0pPDw0fHRbQS5jaGFyQ29kZUF0KGcrKyldLGcrPTQ1PT09QS5jaGFyQ29kZUF0KGcpLGUuc2V0VWludDMyKEksaSwhMCksaT0oaT0oaT0oaT1pPDw0fHRbQS5jaGFyQ29kZUF0KGcrKyldKTw8NHx0W0EuY2hhckNvZGVBdChnKyspXSk8PDR8dFtBLmNoYXJDb2RlQXQoZysrKV0pPDw0fHRbQS5jaGFyQ29kZUF0KGcrKyldLGcrPTQ1PT09QS5jaGFyQ29kZUF0KGcpLGUuc2V0VWludDE2KEkrNCxpLCEwKSxpPShpPShpPShpPWk8PDR8dFtBLmNoYXJDb2RlQXQoZysrKV0pPDw0fHRbQS5jaGFyQ29kZUF0KGcrKyldKTw8NHx0W0EuY2hhckNvZGVBdChnKyspXSk8PDR8dFtBLmNoYXJDb2RlQXQoZysrKV0sZys9NDU9PT1BLmNoYXJDb2RlQXQoZyksZS5zZXRVaW50MTYoSSs2LGksITApLGk9KGk9KGk9KGk9aTw8NHx0W0EuY2hhckNvZGVBdChnKyspXSk8PDR8dFtBLmNoYXJDb2RlQXQoZysrKV0pPDw0fHRbQS5jaGFyQ29kZUF0KGcrKyldKTw8NHx0W0EuY2hhckNvZGVBdChnKyspXSxnKz00NT09PUEuY2hhckNvZGVBdChnKSxpPShpPShpPShpPWk8PDR8dFtBLmNoYXJDb2RlQXQoZysrKV0pPDw0fHRbQS5jaGFyQ29kZUF0KGcrKyldKTw8NHx0W0EuY2hhckNvZGVBdChnKyspXSk8PDR8dFtBLmNoYXJDb2RlQXQoZysrKV0sZS5zZXRVaW50MzIoSSs4LGksITEpLGk9KGk9KGk9KGk9KGk9KGk9KGk9KGk9aTw8NHx0W0EuY2hhckNvZGVBdChnKyspXSk8PDR8dFtBLmNoYXJDb2RlQXQoZysrKV0pPDw0fHRbQS5jaGFyQ29kZUF0KGcrKyldKTw8NHx0W0EuY2hhckNvZGVBdChnKyspXSk8PDR8dFtBLmNoYXJDb2RlQXQoZysrKV0pPDw0fHRbQS5jaGFyQ29kZUF0KGcrKyldKTw8NHx0W0EuY2hhckNvZGVBdChnKyspXSk8PDR8dFtBLmNoYXJDb2RlQXQoZysrKV0sZS5zZXRVaW50MzIoSSsxMixpLCExKX1yZWFkRGF0ZSgpe2NvbnN0IEE9dGhpcy5yZWFkVWludDMyKCksZT0xMDczNzQxODIzJnRoaXMucmVhZFVpbnQzMigpO3JldHVybiBuZXcgRGF0ZSg0Mjk0OTYuNzI5NiplKzFlLTQqQS02MjEzNTU5NjhlNSl9d3JpdGVEYXRlKEEpe2NvbnN0IGU9QS5nZXRUaW1lKCkrNjIxMzU1OTY4ZTUsST1lJTQyOTQ5Ni43Mjk2KjFlNHwwLGc9ZS80Mjk0OTYuNzI5NnwxMDczNzQxODI0O3RoaXMud3JpdGVVaW50MzIoSSksdGhpcy53cml0ZVVpbnQzMihnKX1yZXNlcnZlTWVzc2FnZUxlbmd0aCgpe2NvbnN0IEE9dGhpcy5sZW5ndGg7cmV0dXJuIHRoaXMuZ3Jvd0J5KDQpLEF9ZmlsbE1lc3NhZ2VMZW5ndGgoQSxlKXt0aGlzLnZpZXcuc2V0VWludDMyKEEsZSwhMCl9cmVhZE1lc3NhZ2VMZW5ndGgoKXtjb25zdCBBPXRoaXMudmlldy5nZXRVaW50MzIodGhpcy5pbmRleCwhMCk7cmV0dXJuIHRoaXMuaW5kZXgrPTQsQX19ZS5CZWJvcFZpZXc9UX0sMjczNzooQSxlLEkpPT57XCJ1c2Ugc3RyaWN0XCI7dmFyIGc9SSg4NzUwKSx0PUkoNDU3MyksaT10KGcoXCJTdHJpbmcucHJvdG90eXBlLmluZGV4T2ZcIikpO0EuZXhwb3J0cz1mdW5jdGlvbihBLGUpe3ZhciBJPWcoQSwhIWUpO3JldHVyblwiZnVuY3Rpb25cIj09dHlwZW9mIEkmJmkoQSxcIi5wcm90b3R5cGUuXCIpPi0xP3QoSSk6SX19LDQ1NzM6KEEsZSxJKT0+e1widXNlIHN0cmljdFwiO3ZhciBnPUkoMTMyKSx0PUkoODc1MCksaT10KFwiJUZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseSVcIiksQj10KFwiJUZ1bmN0aW9uLnByb3RvdHlwZS5jYWxsJVwiKSxDPXQoXCIlUmVmbGVjdC5hcHBseSVcIiwhMCl8fGcuY2FsbChCLGkpLFE9dChcIiVPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yJVwiLCEwKSxvPXQoXCIlT2JqZWN0LmRlZmluZVByb3BlcnR5JVwiLCEwKSxuPXQoXCIlTWF0aC5tYXglXCIpO2lmKG8pdHJ5e28oe30sXCJhXCIse3ZhbHVlOjF9KX1jYXRjaChBKXtvPW51bGx9QS5leHBvcnRzPWZ1bmN0aW9uKEEpe3ZhciBlPUMoZyxCLGFyZ3VtZW50cyk7aWYoUSYmbyl7dmFyIEk9UShlLFwibGVuZ3RoXCIpO0kuY29uZmlndXJhYmxlJiZvKGUsXCJsZW5ndGhcIix7dmFsdWU6MStuKDAsQS5sZW5ndGgtKGFyZ3VtZW50cy5sZW5ndGgtMSkpfSl9cmV0dXJuIGV9O3ZhciBhPWZ1bmN0aW9uKCl7cmV0dXJuIEMoZyxpLGFyZ3VtZW50cyl9O28/byhBLmV4cG9ydHMsXCJhcHBseVwiLHt2YWx1ZTphfSk6QS5leHBvcnRzLmFwcGx5PWF9LDUyNzg6KEEsZSxJKT0+e1widXNlIHN0cmljdFwiO3ZhciBnPUkoODI0NSksdD1PYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLGk9T2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSxCPWZ1bmN0aW9uKEEsZSxJKXtmb3IodmFyIGc9MCx0PUEubGVuZ3RoO2c8dDtnKyspaS5jYWxsKEEsZykmJihudWxsPT1JP2UoQVtnXSxnLEEpOmUuY2FsbChJLEFbZ10sZyxBKSl9LEM9ZnVuY3Rpb24oQSxlLEkpe2Zvcih2YXIgZz0wLHQ9QS5sZW5ndGg7Zzx0O2crKyludWxsPT1JP2UoQS5jaGFyQXQoZyksZyxBKTplLmNhbGwoSSxBLmNoYXJBdChnKSxnLEEpfSxRPWZ1bmN0aW9uKEEsZSxJKXtmb3IodmFyIGcgaW4gQSlpLmNhbGwoQSxnKSYmKG51bGw9PUk/ZShBW2ddLGcsQSk6ZS5jYWxsKEksQVtnXSxnLEEpKX07QS5leHBvcnRzPWZ1bmN0aW9uKEEsZSxJKXtpZighZyhlKSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiaXRlcmF0b3IgbXVzdCBiZSBhIGZ1bmN0aW9uXCIpO3ZhciBpO2FyZ3VtZW50cy5sZW5ndGg+PTMmJihpPUkpLFwiW29iamVjdCBBcnJheV1cIj09PXQuY2FsbChBKT9CKEEsZSxpKTpcInN0cmluZ1wiPT10eXBlb2YgQT9DKEEsZSxpKTpRKEEsZSxpKX19LDgyNDU6QT0+e1widXNlIHN0cmljdFwiO3ZhciBlLEksZz1GdW5jdGlvbi5wcm90b3R5cGUudG9TdHJpbmcsdD1cIm9iamVjdFwiPT10eXBlb2YgUmVmbGVjdCYmbnVsbCE9PVJlZmxlY3QmJlJlZmxlY3QuYXBwbHk7aWYoXCJmdW5jdGlvblwiPT10eXBlb2YgdCYmXCJmdW5jdGlvblwiPT10eXBlb2YgT2JqZWN0LmRlZmluZVByb3BlcnR5KXRyeXtlPU9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7fSxcImxlbmd0aFwiLHtnZXQ6ZnVuY3Rpb24oKXt0aHJvdyBJfX0pLEk9e30sdCgoZnVuY3Rpb24oKXt0aHJvdyA0Mn0pLG51bGwsZSl9Y2F0Y2goQSl7QSE9PUkmJih0PW51bGwpfWVsc2UgdD1udWxsO3ZhciBpPS9eXFxzKmNsYXNzXFxiLyxCPWZ1bmN0aW9uKEEpe3RyeXt2YXIgZT1nLmNhbGwoQSk7cmV0dXJuIGkudGVzdChlKX1jYXRjaChBKXtyZXR1cm4hMX19LEM9T2JqZWN0LnByb3RvdHlwZS50b1N0cmluZyxRPVwiZnVuY3Rpb25cIj09dHlwZW9mIFN5bWJvbCYmISFTeW1ib2wudG9TdHJpbmdUYWcsbz1cIm9iamVjdFwiPT10eXBlb2YgZG9jdW1lbnQmJnZvaWQgMD09PWRvY3VtZW50LmFsbCYmdm9pZCAwIT09ZG9jdW1lbnQuYWxsP2RvY3VtZW50LmFsbDp7fTtBLmV4cG9ydHM9dD9mdW5jdGlvbihBKXtpZihBPT09bylyZXR1cm4hMDtpZighQSlyZXR1cm4hMTtpZihcImZ1bmN0aW9uXCIhPXR5cGVvZiBBJiZcIm9iamVjdFwiIT10eXBlb2YgQSlyZXR1cm4hMTtpZihcImZ1bmN0aW9uXCI9PXR5cGVvZiBBJiYhQS5wcm90b3R5cGUpcmV0dXJuITA7dHJ5e3QoQSxudWxsLGUpfWNhdGNoKEEpe2lmKEEhPT1JKXJldHVybiExfXJldHVybiFCKEEpfTpmdW5jdGlvbihBKXtpZihBPT09bylyZXR1cm4hMDtpZighQSlyZXR1cm4hMTtpZihcImZ1bmN0aW9uXCIhPXR5cGVvZiBBJiZcIm9iamVjdFwiIT10eXBlb2YgQSlyZXR1cm4hMTtpZihcImZ1bmN0aW9uXCI9PXR5cGVvZiBBJiYhQS5wcm90b3R5cGUpcmV0dXJuITA7aWYoUSlyZXR1cm4gZnVuY3Rpb24oQSl7dHJ5e3JldHVybiFCKEEpJiYoZy5jYWxsKEEpLCEwKX1jYXRjaChBKXtyZXR1cm4hMX19KEEpO2lmKEIoQSkpcmV0dXJuITE7dmFyIGU9Qy5jYWxsKEEpO3JldHVyblwiW29iamVjdCBGdW5jdGlvbl1cIj09PWV8fFwiW29iamVjdCBHZW5lcmF0b3JGdW5jdGlvbl1cIj09PWV9fSw4NDU4OkE9PntcInVzZSBzdHJpY3RcIjt2YXIgZT1cIkZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kIGNhbGxlZCBvbiBpbmNvbXBhdGlibGUgXCIsST1BcnJheS5wcm90b3R5cGUuc2xpY2UsZz1PYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLHQ9XCJbb2JqZWN0IEZ1bmN0aW9uXVwiO0EuZXhwb3J0cz1mdW5jdGlvbihBKXt2YXIgaT10aGlzO2lmKFwiZnVuY3Rpb25cIiE9dHlwZW9mIGl8fGcuY2FsbChpKSE9PXQpdGhyb3cgbmV3IFR5cGVFcnJvcihlK2kpO2Zvcih2YXIgQixDPUkuY2FsbChhcmd1bWVudHMsMSksUT1mdW5jdGlvbigpe2lmKHRoaXMgaW5zdGFuY2VvZiBCKXt2YXIgZT1pLmFwcGx5KHRoaXMsQy5jb25jYXQoSS5jYWxsKGFyZ3VtZW50cykpKTtyZXR1cm4gT2JqZWN0KGUpPT09ZT9lOnRoaXN9cmV0dXJuIGkuYXBwbHkoQSxDLmNvbmNhdChJLmNhbGwoYXJndW1lbnRzKSkpfSxvPU1hdGgubWF4KDAsaS5sZW5ndGgtQy5sZW5ndGgpLG49W10sYT0wO2E8bzthKyspbi5wdXNoKFwiJFwiK2EpO2lmKEI9RnVuY3Rpb24oXCJiaW5kZXJcIixcInJldHVybiBmdW5jdGlvbiAoXCIrbi5qb2luKFwiLFwiKStcIil7IHJldHVybiBiaW5kZXIuYXBwbHkodGhpcyxhcmd1bWVudHMpOyB9XCIpKFEpLGkucHJvdG90eXBlKXt2YXIgcj1mdW5jdGlvbigpe307ci5wcm90b3R5cGU9aS5wcm90b3R5cGUsQi5wcm90b3R5cGU9bmV3IHIsci5wcm90b3R5cGU9bnVsbH1yZXR1cm4gQn19LDEzMjooQSxlLEkpPT57XCJ1c2Ugc3RyaWN0XCI7dmFyIGc9SSg4NDU4KTtBLmV4cG9ydHM9RnVuY3Rpb24ucHJvdG90eXBlLmJpbmR8fGd9LDg3NTA6KEEsZSxJKT0+e1widXNlIHN0cmljdFwiO3ZhciBnLHQ9U3ludGF4RXJyb3IsaT1GdW5jdGlvbixCPVR5cGVFcnJvcixDPWZ1bmN0aW9uKEEpe3RyeXtyZXR1cm4gaSgnXCJ1c2Ugc3RyaWN0XCI7IHJldHVybiAoJytBK1wiKS5jb25zdHJ1Y3RvcjtcIikoKX1jYXRjaChBKXt9fSxRPU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7aWYoUSl0cnl7USh7fSxcIlwiKX1jYXRjaChBKXtRPW51bGx9dmFyIG89ZnVuY3Rpb24oKXt0aHJvdyBuZXcgQn0sbj1RP2Z1bmN0aW9uKCl7dHJ5e3JldHVybiBvfWNhdGNoKEEpe3RyeXtyZXR1cm4gUShhcmd1bWVudHMsXCJjYWxsZWVcIikuZ2V0fWNhdGNoKEEpe3JldHVybiBvfX19KCk6byxhPUkoNjc5KSgpLHI9T2JqZWN0LmdldFByb3RvdHlwZU9mfHxmdW5jdGlvbihBKXtyZXR1cm4gQS5fX3Byb3RvX199LEU9e30scz1cInVuZGVmaW5lZFwiPT10eXBlb2YgVWludDhBcnJheT9nOnIoVWludDhBcnJheSksZD17XCIlQWdncmVnYXRlRXJyb3IlXCI6XCJ1bmRlZmluZWRcIj09dHlwZW9mIEFnZ3JlZ2F0ZUVycm9yP2c6QWdncmVnYXRlRXJyb3IsXCIlQXJyYXklXCI6QXJyYXksXCIlQXJyYXlCdWZmZXIlXCI6XCJ1bmRlZmluZWRcIj09dHlwZW9mIEFycmF5QnVmZmVyP2c6QXJyYXlCdWZmZXIsXCIlQXJyYXlJdGVyYXRvclByb3RvdHlwZSVcIjphP3IoW11bU3ltYm9sLml0ZXJhdG9yXSgpKTpnLFwiJUFzeW5jRnJvbVN5bmNJdGVyYXRvclByb3RvdHlwZSVcIjpnLFwiJUFzeW5jRnVuY3Rpb24lXCI6RSxcIiVBc3luY0dlbmVyYXRvciVcIjpFLFwiJUFzeW5jR2VuZXJhdG9yRnVuY3Rpb24lXCI6RSxcIiVBc3luY0l0ZXJhdG9yUHJvdG90eXBlJVwiOkUsXCIlQXRvbWljcyVcIjpcInVuZGVmaW5lZFwiPT10eXBlb2YgQXRvbWljcz9nOkF0b21pY3MsXCIlQmlnSW50JVwiOlwidW5kZWZpbmVkXCI9PXR5cGVvZiBCaWdJbnQ/ZzpCaWdJbnQsXCIlQm9vbGVhbiVcIjpCb29sZWFuLFwiJURhdGFWaWV3JVwiOlwidW5kZWZpbmVkXCI9PXR5cGVvZiBEYXRhVmlldz9nOkRhdGFWaWV3LFwiJURhdGUlXCI6RGF0ZSxcIiVkZWNvZGVVUkklXCI6ZGVjb2RlVVJJLFwiJWRlY29kZVVSSUNvbXBvbmVudCVcIjpkZWNvZGVVUklDb21wb25lbnQsXCIlZW5jb2RlVVJJJVwiOmVuY29kZVVSSSxcIiVlbmNvZGVVUklDb21wb25lbnQlXCI6ZW5jb2RlVVJJQ29tcG9uZW50LFwiJUVycm9yJVwiOkVycm9yLFwiJWV2YWwlXCI6ZXZhbCxcIiVFdmFsRXJyb3IlXCI6RXZhbEVycm9yLFwiJUZsb2F0MzJBcnJheSVcIjpcInVuZGVmaW5lZFwiPT10eXBlb2YgRmxvYXQzMkFycmF5P2c6RmxvYXQzMkFycmF5LFwiJUZsb2F0NjRBcnJheSVcIjpcInVuZGVmaW5lZFwiPT10eXBlb2YgRmxvYXQ2NEFycmF5P2c6RmxvYXQ2NEFycmF5LFwiJUZpbmFsaXphdGlvblJlZ2lzdHJ5JVwiOlwidW5kZWZpbmVkXCI9PXR5cGVvZiBGaW5hbGl6YXRpb25SZWdpc3RyeT9nOkZpbmFsaXphdGlvblJlZ2lzdHJ5LFwiJUZ1bmN0aW9uJVwiOmksXCIlR2VuZXJhdG9yRnVuY3Rpb24lXCI6RSxcIiVJbnQ4QXJyYXklXCI6XCJ1bmRlZmluZWRcIj09dHlwZW9mIEludDhBcnJheT9nOkludDhBcnJheSxcIiVJbnQxNkFycmF5JVwiOlwidW5kZWZpbmVkXCI9PXR5cGVvZiBJbnQxNkFycmF5P2c6SW50MTZBcnJheSxcIiVJbnQzMkFycmF5JVwiOlwidW5kZWZpbmVkXCI9PXR5cGVvZiBJbnQzMkFycmF5P2c6SW50MzJBcnJheSxcIiVpc0Zpbml0ZSVcIjppc0Zpbml0ZSxcIiVpc05hTiVcIjppc05hTixcIiVJdGVyYXRvclByb3RvdHlwZSVcIjphP3IocihbXVtTeW1ib2wuaXRlcmF0b3JdKCkpKTpnLFwiJUpTT04lXCI6XCJvYmplY3RcIj09dHlwZW9mIEpTT04/SlNPTjpnLFwiJU1hcCVcIjpcInVuZGVmaW5lZFwiPT10eXBlb2YgTWFwP2c6TWFwLFwiJU1hcEl0ZXJhdG9yUHJvdG90eXBlJVwiOlwidW5kZWZpbmVkXCIhPXR5cGVvZiBNYXAmJmE/cigobmV3IE1hcClbU3ltYm9sLml0ZXJhdG9yXSgpKTpnLFwiJU1hdGglXCI6TWF0aCxcIiVOdW1iZXIlXCI6TnVtYmVyLFwiJU9iamVjdCVcIjpPYmplY3QsXCIlcGFyc2VGbG9hdCVcIjpwYXJzZUZsb2F0LFwiJXBhcnNlSW50JVwiOnBhcnNlSW50LFwiJVByb21pc2UlXCI6XCJ1bmRlZmluZWRcIj09dHlwZW9mIFByb21pc2U/ZzpQcm9taXNlLFwiJVByb3h5JVwiOlwidW5kZWZpbmVkXCI9PXR5cGVvZiBQcm94eT9nOlByb3h5LFwiJVJhbmdlRXJyb3IlXCI6UmFuZ2VFcnJvcixcIiVSZWZlcmVuY2VFcnJvciVcIjpSZWZlcmVuY2VFcnJvcixcIiVSZWZsZWN0JVwiOlwidW5kZWZpbmVkXCI9PXR5cGVvZiBSZWZsZWN0P2c6UmVmbGVjdCxcIiVSZWdFeHAlXCI6UmVnRXhwLFwiJVNldCVcIjpcInVuZGVmaW5lZFwiPT10eXBlb2YgU2V0P2c6U2V0LFwiJVNldEl0ZXJhdG9yUHJvdG90eXBlJVwiOlwidW5kZWZpbmVkXCIhPXR5cGVvZiBTZXQmJmE/cigobmV3IFNldClbU3ltYm9sLml0ZXJhdG9yXSgpKTpnLFwiJVNoYXJlZEFycmF5QnVmZmVyJVwiOlwidW5kZWZpbmVkXCI9PXR5cGVvZiBTaGFyZWRBcnJheUJ1ZmZlcj9nOlNoYXJlZEFycmF5QnVmZmVyLFwiJVN0cmluZyVcIjpTdHJpbmcsXCIlU3RyaW5nSXRlcmF0b3JQcm90b3R5cGUlXCI6YT9yKFwiXCJbU3ltYm9sLml0ZXJhdG9yXSgpKTpnLFwiJVN5bWJvbCVcIjphP1N5bWJvbDpnLFwiJVN5bnRheEVycm9yJVwiOnQsXCIlVGhyb3dUeXBlRXJyb3IlXCI6bixcIiVUeXBlZEFycmF5JVwiOnMsXCIlVHlwZUVycm9yJVwiOkIsXCIlVWludDhBcnJheSVcIjpcInVuZGVmaW5lZFwiPT10eXBlb2YgVWludDhBcnJheT9nOlVpbnQ4QXJyYXksXCIlVWludDhDbGFtcGVkQXJyYXklXCI6XCJ1bmRlZmluZWRcIj09dHlwZW9mIFVpbnQ4Q2xhbXBlZEFycmF5P2c6VWludDhDbGFtcGVkQXJyYXksXCIlVWludDE2QXJyYXklXCI6XCJ1bmRlZmluZWRcIj09dHlwZW9mIFVpbnQxNkFycmF5P2c6VWludDE2QXJyYXksXCIlVWludDMyQXJyYXklXCI6XCJ1bmRlZmluZWRcIj09dHlwZW9mIFVpbnQzMkFycmF5P2c6VWludDMyQXJyYXksXCIlVVJJRXJyb3IlXCI6VVJJRXJyb3IsXCIlV2Vha01hcCVcIjpcInVuZGVmaW5lZFwiPT10eXBlb2YgV2Vha01hcD9nOldlYWtNYXAsXCIlV2Vha1JlZiVcIjpcInVuZGVmaW5lZFwiPT10eXBlb2YgV2Vha1JlZj9nOldlYWtSZWYsXCIlV2Vha1NldCVcIjpcInVuZGVmaW5lZFwiPT10eXBlb2YgV2Vha1NldD9nOldlYWtTZXR9LGM9ZnVuY3Rpb24gQShlKXt2YXIgSTtpZihcIiVBc3luY0Z1bmN0aW9uJVwiPT09ZSlJPUMoXCJhc3luYyBmdW5jdGlvbiAoKSB7fVwiKTtlbHNlIGlmKFwiJUdlbmVyYXRvckZ1bmN0aW9uJVwiPT09ZSlJPUMoXCJmdW5jdGlvbiogKCkge31cIik7ZWxzZSBpZihcIiVBc3luY0dlbmVyYXRvckZ1bmN0aW9uJVwiPT09ZSlJPUMoXCJhc3luYyBmdW5jdGlvbiogKCkge31cIik7ZWxzZSBpZihcIiVBc3luY0dlbmVyYXRvciVcIj09PWUpe3ZhciBnPUEoXCIlQXN5bmNHZW5lcmF0b3JGdW5jdGlvbiVcIik7ZyYmKEk9Zy5wcm90b3R5cGUpfWVsc2UgaWYoXCIlQXN5bmNJdGVyYXRvclByb3RvdHlwZSVcIj09PWUpe3ZhciB0PUEoXCIlQXN5bmNHZW5lcmF0b3IlXCIpO3QmJihJPXIodC5wcm90b3R5cGUpKX1yZXR1cm4gZFtlXT1JLEl9LGg9e1wiJUFycmF5QnVmZmVyUHJvdG90eXBlJVwiOltcIkFycmF5QnVmZmVyXCIsXCJwcm90b3R5cGVcIl0sXCIlQXJyYXlQcm90b3R5cGUlXCI6W1wiQXJyYXlcIixcInByb3RvdHlwZVwiXSxcIiVBcnJheVByb3RvX2VudHJpZXMlXCI6W1wiQXJyYXlcIixcInByb3RvdHlwZVwiLFwiZW50cmllc1wiXSxcIiVBcnJheVByb3RvX2ZvckVhY2glXCI6W1wiQXJyYXlcIixcInByb3RvdHlwZVwiLFwiZm9yRWFjaFwiXSxcIiVBcnJheVByb3RvX2tleXMlXCI6W1wiQXJyYXlcIixcInByb3RvdHlwZVwiLFwia2V5c1wiXSxcIiVBcnJheVByb3RvX3ZhbHVlcyVcIjpbXCJBcnJheVwiLFwicHJvdG90eXBlXCIsXCJ2YWx1ZXNcIl0sXCIlQXN5bmNGdW5jdGlvblByb3RvdHlwZSVcIjpbXCJBc3luY0Z1bmN0aW9uXCIsXCJwcm90b3R5cGVcIl0sXCIlQXN5bmNHZW5lcmF0b3IlXCI6W1wiQXN5bmNHZW5lcmF0b3JGdW5jdGlvblwiLFwicHJvdG90eXBlXCJdLFwiJUFzeW5jR2VuZXJhdG9yUHJvdG90eXBlJVwiOltcIkFzeW5jR2VuZXJhdG9yRnVuY3Rpb25cIixcInByb3RvdHlwZVwiLFwicHJvdG90eXBlXCJdLFwiJUJvb2xlYW5Qcm90b3R5cGUlXCI6W1wiQm9vbGVhblwiLFwicHJvdG90eXBlXCJdLFwiJURhdGFWaWV3UHJvdG90eXBlJVwiOltcIkRhdGFWaWV3XCIsXCJwcm90b3R5cGVcIl0sXCIlRGF0ZVByb3RvdHlwZSVcIjpbXCJEYXRlXCIsXCJwcm90b3R5cGVcIl0sXCIlRXJyb3JQcm90b3R5cGUlXCI6W1wiRXJyb3JcIixcInByb3RvdHlwZVwiXSxcIiVFdmFsRXJyb3JQcm90b3R5cGUlXCI6W1wiRXZhbEVycm9yXCIsXCJwcm90b3R5cGVcIl0sXCIlRmxvYXQzMkFycmF5UHJvdG90eXBlJVwiOltcIkZsb2F0MzJBcnJheVwiLFwicHJvdG90eXBlXCJdLFwiJUZsb2F0NjRBcnJheVByb3RvdHlwZSVcIjpbXCJGbG9hdDY0QXJyYXlcIixcInByb3RvdHlwZVwiXSxcIiVGdW5jdGlvblByb3RvdHlwZSVcIjpbXCJGdW5jdGlvblwiLFwicHJvdG90eXBlXCJdLFwiJUdlbmVyYXRvciVcIjpbXCJHZW5lcmF0b3JGdW5jdGlvblwiLFwicHJvdG90eXBlXCJdLFwiJUdlbmVyYXRvclByb3RvdHlwZSVcIjpbXCJHZW5lcmF0b3JGdW5jdGlvblwiLFwicHJvdG90eXBlXCIsXCJwcm90b3R5cGVcIl0sXCIlSW50OEFycmF5UHJvdG90eXBlJVwiOltcIkludDhBcnJheVwiLFwicHJvdG90eXBlXCJdLFwiJUludDE2QXJyYXlQcm90b3R5cGUlXCI6W1wiSW50MTZBcnJheVwiLFwicHJvdG90eXBlXCJdLFwiJUludDMyQXJyYXlQcm90b3R5cGUlXCI6W1wiSW50MzJBcnJheVwiLFwicHJvdG90eXBlXCJdLFwiJUpTT05QYXJzZSVcIjpbXCJKU09OXCIsXCJwYXJzZVwiXSxcIiVKU09OU3RyaW5naWZ5JVwiOltcIkpTT05cIixcInN0cmluZ2lmeVwiXSxcIiVNYXBQcm90b3R5cGUlXCI6W1wiTWFwXCIsXCJwcm90b3R5cGVcIl0sXCIlTnVtYmVyUHJvdG90eXBlJVwiOltcIk51bWJlclwiLFwicHJvdG90eXBlXCJdLFwiJU9iamVjdFByb3RvdHlwZSVcIjpbXCJPYmplY3RcIixcInByb3RvdHlwZVwiXSxcIiVPYmpQcm90b190b1N0cmluZyVcIjpbXCJPYmplY3RcIixcInByb3RvdHlwZVwiLFwidG9TdHJpbmdcIl0sXCIlT2JqUHJvdG9fdmFsdWVPZiVcIjpbXCJPYmplY3RcIixcInByb3RvdHlwZVwiLFwidmFsdWVPZlwiXSxcIiVQcm9taXNlUHJvdG90eXBlJVwiOltcIlByb21pc2VcIixcInByb3RvdHlwZVwiXSxcIiVQcm9taXNlUHJvdG9fdGhlbiVcIjpbXCJQcm9taXNlXCIsXCJwcm90b3R5cGVcIixcInRoZW5cIl0sXCIlUHJvbWlzZV9hbGwlXCI6W1wiUHJvbWlzZVwiLFwiYWxsXCJdLFwiJVByb21pc2VfcmVqZWN0JVwiOltcIlByb21pc2VcIixcInJlamVjdFwiXSxcIiVQcm9taXNlX3Jlc29sdmUlXCI6W1wiUHJvbWlzZVwiLFwicmVzb2x2ZVwiXSxcIiVSYW5nZUVycm9yUHJvdG90eXBlJVwiOltcIlJhbmdlRXJyb3JcIixcInByb3RvdHlwZVwiXSxcIiVSZWZlcmVuY2VFcnJvclByb3RvdHlwZSVcIjpbXCJSZWZlcmVuY2VFcnJvclwiLFwicHJvdG90eXBlXCJdLFwiJVJlZ0V4cFByb3RvdHlwZSVcIjpbXCJSZWdFeHBcIixcInByb3RvdHlwZVwiXSxcIiVTZXRQcm90b3R5cGUlXCI6W1wiU2V0XCIsXCJwcm90b3R5cGVcIl0sXCIlU2hhcmVkQXJyYXlCdWZmZXJQcm90b3R5cGUlXCI6W1wiU2hhcmVkQXJyYXlCdWZmZXJcIixcInByb3RvdHlwZVwiXSxcIiVTdHJpbmdQcm90b3R5cGUlXCI6W1wiU3RyaW5nXCIsXCJwcm90b3R5cGVcIl0sXCIlU3ltYm9sUHJvdG90eXBlJVwiOltcIlN5bWJvbFwiLFwicHJvdG90eXBlXCJdLFwiJVN5bnRheEVycm9yUHJvdG90eXBlJVwiOltcIlN5bnRheEVycm9yXCIsXCJwcm90b3R5cGVcIl0sXCIlVHlwZWRBcnJheVByb3RvdHlwZSVcIjpbXCJUeXBlZEFycmF5XCIsXCJwcm90b3R5cGVcIl0sXCIlVHlwZUVycm9yUHJvdG90eXBlJVwiOltcIlR5cGVFcnJvclwiLFwicHJvdG90eXBlXCJdLFwiJVVpbnQ4QXJyYXlQcm90b3R5cGUlXCI6W1wiVWludDhBcnJheVwiLFwicHJvdG90eXBlXCJdLFwiJVVpbnQ4Q2xhbXBlZEFycmF5UHJvdG90eXBlJVwiOltcIlVpbnQ4Q2xhbXBlZEFycmF5XCIsXCJwcm90b3R5cGVcIl0sXCIlVWludDE2QXJyYXlQcm90b3R5cGUlXCI6W1wiVWludDE2QXJyYXlcIixcInByb3RvdHlwZVwiXSxcIiVVaW50MzJBcnJheVByb3RvdHlwZSVcIjpbXCJVaW50MzJBcnJheVwiLFwicHJvdG90eXBlXCJdLFwiJVVSSUVycm9yUHJvdG90eXBlJVwiOltcIlVSSUVycm9yXCIsXCJwcm90b3R5cGVcIl0sXCIlV2Vha01hcFByb3RvdHlwZSVcIjpbXCJXZWFrTWFwXCIsXCJwcm90b3R5cGVcIl0sXCIlV2Vha1NldFByb3RvdHlwZSVcIjpbXCJXZWFrU2V0XCIsXCJwcm90b3R5cGVcIl19LEQ9SSgxMzIpLHU9SSg3NDkyKSx3PUQuY2FsbChGdW5jdGlvbi5jYWxsLEFycmF5LnByb3RvdHlwZS5jb25jYXQpLGw9RC5jYWxsKEZ1bmN0aW9uLmFwcGx5LEFycmF5LnByb3RvdHlwZS5zcGxpY2UpLHk9RC5jYWxsKEZ1bmN0aW9uLmNhbGwsU3RyaW5nLnByb3RvdHlwZS5yZXBsYWNlKSxTPUQuY2FsbChGdW5jdGlvbi5jYWxsLFN0cmluZy5wcm90b3R5cGUuc2xpY2UpLEY9L1teJS5bXFxdXSt8XFxbKD86KC0/XFxkKyg/OlxcLlxcZCspPyl8KFtcIiddKSgoPzooPyFcXDIpW15cXFxcXXxcXFxcLikqPylcXDIpXFxdfCg/PSg/OlxcLnxcXFtcXF0pKD86XFwufFxcW1xcXXwlJCkpL2csUj0vXFxcXChcXFxcKT8vZyxwPWZ1bmN0aW9uKEEpe3ZhciBlPVMoQSwwLDEpLEk9UyhBLC0xKTtpZihcIiVcIj09PWUmJlwiJVwiIT09SSl0aHJvdyBuZXcgdChcImludmFsaWQgaW50cmluc2ljIHN5bnRheCwgZXhwZWN0ZWQgY2xvc2luZyBgJWBcIik7aWYoXCIlXCI9PT1JJiZcIiVcIiE9PWUpdGhyb3cgbmV3IHQoXCJpbnZhbGlkIGludHJpbnNpYyBzeW50YXgsIGV4cGVjdGVkIG9wZW5pbmcgYCVgXCIpO3ZhciBnPVtdO3JldHVybiB5KEEsRiwoZnVuY3Rpb24oQSxlLEksdCl7Z1tnLmxlbmd0aF09ST95KHQsUixcIiQxXCIpOmV8fEF9KSksZ30sRz1mdW5jdGlvbihBLGUpe3ZhciBJLGc9QTtpZih1KGgsZykmJihnPVwiJVwiKyhJPWhbZ10pWzBdK1wiJVwiKSx1KGQsZykpe3ZhciBpPWRbZ107aWYoaT09PUUmJihpPWMoZykpLHZvaWQgMD09PWkmJiFlKXRocm93IG5ldyBCKFwiaW50cmluc2ljIFwiK0ErXCIgZXhpc3RzLCBidXQgaXMgbm90IGF2YWlsYWJsZS4gUGxlYXNlIGZpbGUgYW4gaXNzdWUhXCIpO3JldHVybnthbGlhczpJLG5hbWU6Zyx2YWx1ZTppfX10aHJvdyBuZXcgdChcImludHJpbnNpYyBcIitBK1wiIGRvZXMgbm90IGV4aXN0IVwiKX07QS5leHBvcnRzPWZ1bmN0aW9uKEEsZSl7aWYoXCJzdHJpbmdcIiE9dHlwZW9mIEF8fDA9PT1BLmxlbmd0aCl0aHJvdyBuZXcgQihcImludHJpbnNpYyBuYW1lIG11c3QgYmUgYSBub24tZW1wdHkgc3RyaW5nXCIpO2lmKGFyZ3VtZW50cy5sZW5ndGg+MSYmXCJib29sZWFuXCIhPXR5cGVvZiBlKXRocm93IG5ldyBCKCdcImFsbG93TWlzc2luZ1wiIGFyZ3VtZW50IG11c3QgYmUgYSBib29sZWFuJyk7dmFyIEk9cChBKSxnPUkubGVuZ3RoPjA/SVswXTpcIlwiLGk9RyhcIiVcIitnK1wiJVwiLGUpLEM9aS5uYW1lLG89aS52YWx1ZSxuPSExLGE9aS5hbGlhczthJiYoZz1hWzBdLGwoSSx3KFswLDFdLGEpKSk7Zm9yKHZhciByPTEsRT0hMDtyPEkubGVuZ3RoO3IrPTEpe3ZhciBzPUlbcl0sYz1TKHMsMCwxKSxoPVMocywtMSk7aWYoKCdcIic9PT1jfHxcIidcIj09PWN8fFwiYFwiPT09Y3x8J1wiJz09PWh8fFwiJ1wiPT09aHx8XCJgXCI9PT1oKSYmYyE9PWgpdGhyb3cgbmV3IHQoXCJwcm9wZXJ0eSBuYW1lcyB3aXRoIHF1b3RlcyBtdXN0IGhhdmUgbWF0Y2hpbmcgcXVvdGVzXCIpO2lmKFwiY29uc3RydWN0b3JcIiE9PXMmJkV8fChuPSEwKSx1KGQsQz1cIiVcIisoZys9XCIuXCIrcykrXCIlXCIpKW89ZFtDXTtlbHNlIGlmKG51bGwhPW8pe2lmKCEocyBpbiBvKSl7aWYoIWUpdGhyb3cgbmV3IEIoXCJiYXNlIGludHJpbnNpYyBmb3IgXCIrQStcIiBleGlzdHMsIGJ1dCB0aGUgcHJvcGVydHkgaXMgbm90IGF2YWlsYWJsZS5cIik7cmV0dXJufWlmKFEmJnIrMT49SS5sZW5ndGgpe3ZhciBEPVEobyxzKTtvPShFPSEhRCkmJlwiZ2V0XCJpbiBEJiYhKFwib3JpZ2luYWxWYWx1ZVwiaW4gRC5nZXQpP0QuZ2V0Om9bc119ZWxzZSBFPXUobyxzKSxvPW9bc107RSYmIW4mJihkW0NdPW8pfX1yZXR1cm4gb319LDY3OTooQSxlLEkpPT57XCJ1c2Ugc3RyaWN0XCI7dmFyIGc9XCJ1bmRlZmluZWRcIiE9dHlwZW9mIFN5bWJvbCYmU3ltYm9sLHQ9SSg4MTg2KTtBLmV4cG9ydHM9ZnVuY3Rpb24oKXtyZXR1cm5cImZ1bmN0aW9uXCI9PXR5cGVvZiBnJiZcImZ1bmN0aW9uXCI9PXR5cGVvZiBTeW1ib2wmJlwic3ltYm9sXCI9PXR5cGVvZiBnKFwiZm9vXCIpJiZcInN5bWJvbFwiPT10eXBlb2YgU3ltYm9sKFwiYmFyXCIpJiZ0KCl9fSw4MTg2OkE9PntcInVzZSBzdHJpY3RcIjtBLmV4cG9ydHM9ZnVuY3Rpb24oKXtpZihcImZ1bmN0aW9uXCIhPXR5cGVvZiBTeW1ib2x8fFwiZnVuY3Rpb25cIiE9dHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpcmV0dXJuITE7aWYoXCJzeW1ib2xcIj09dHlwZW9mIFN5bWJvbC5pdGVyYXRvcilyZXR1cm4hMDt2YXIgQT17fSxlPVN5bWJvbChcInRlc3RcIiksST1PYmplY3QoZSk7aWYoXCJzdHJpbmdcIj09dHlwZW9mIGUpcmV0dXJuITE7aWYoXCJbb2JqZWN0IFN5bWJvbF1cIiE9PU9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChlKSlyZXR1cm4hMTtpZihcIltvYmplY3QgU3ltYm9sXVwiIT09T2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKEkpKXJldHVybiExO2ZvcihlIGluIEFbZV09NDIsQSlyZXR1cm4hMTtpZihcImZ1bmN0aW9uXCI9PXR5cGVvZiBPYmplY3Qua2V5cyYmMCE9PU9iamVjdC5rZXlzKEEpLmxlbmd0aClyZXR1cm4hMTtpZihcImZ1bmN0aW9uXCI9PXR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyYmMCE9PU9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKEEpLmxlbmd0aClyZXR1cm4hMTt2YXIgZz1PYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKEEpO2lmKDEhPT1nLmxlbmd0aHx8Z1swXSE9PWUpcmV0dXJuITE7aWYoIU9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChBLGUpKXJldHVybiExO2lmKFwiZnVuY3Rpb25cIj09dHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ipe3ZhciB0PU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoQSxlKTtpZig0MiE9PXQudmFsdWV8fCEwIT09dC5lbnVtZXJhYmxlKXJldHVybiExfXJldHVybiEwfX0sNjk4OihBLGUsSSk9PntcInVzZSBzdHJpY3RcIjt2YXIgZz1JKDgxODYpO0EuZXhwb3J0cz1mdW5jdGlvbigpe3JldHVybiBnKCkmJiEhU3ltYm9sLnRvU3RyaW5nVGFnfX0sNzQ5MjooQSxlLEkpPT57XCJ1c2Ugc3RyaWN0XCI7dmFyIGc9SSgxMzIpO0EuZXhwb3J0cz1nLmNhbGwoRnVuY3Rpb24uY2FsbCxPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5KX0sODc6QT0+e1wiZnVuY3Rpb25cIj09dHlwZW9mIE9iamVjdC5jcmVhdGU/QS5leHBvcnRzPWZ1bmN0aW9uKEEsZSl7ZSYmKEEuc3VwZXJfPWUsQS5wcm90b3R5cGU9T2JqZWN0LmNyZWF0ZShlLnByb3RvdHlwZSx7Y29uc3RydWN0b3I6e3ZhbHVlOkEsZW51bWVyYWJsZTohMSx3cml0YWJsZTohMCxjb25maWd1cmFibGU6ITB9fSkpfTpBLmV4cG9ydHM9ZnVuY3Rpb24oQSxlKXtpZihlKXtBLnN1cGVyXz1lO3ZhciBJPWZ1bmN0aW9uKCl7fTtJLnByb3RvdHlwZT1lLnByb3RvdHlwZSxBLnByb3RvdHlwZT1uZXcgSSxBLnByb3RvdHlwZS5jb25zdHJ1Y3Rvcj1BfX19LDc3NDA6KEEsZSxJKT0+e1widXNlIHN0cmljdFwiO3ZhciBnPVwiZnVuY3Rpb25cIj09dHlwZW9mIFN5bWJvbCYmXCJzeW1ib2xcIj09dHlwZW9mIFN5bWJvbC50b1N0cmluZ1RhZyx0PUkoMjczNykoXCJPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nXCIpLGk9ZnVuY3Rpb24oQSl7cmV0dXJuIShnJiZBJiZcIm9iamVjdFwiPT10eXBlb2YgQSYmU3ltYm9sLnRvU3RyaW5nVGFnIGluIEEpJiZcIltvYmplY3QgQXJndW1lbnRzXVwiPT09dChBKX0sQj1mdW5jdGlvbihBKXtyZXR1cm4hIWkoQSl8fG51bGwhPT1BJiZcIm9iamVjdFwiPT10eXBlb2YgQSYmXCJudW1iZXJcIj09dHlwZW9mIEEubGVuZ3RoJiZBLmxlbmd0aD49MCYmXCJbb2JqZWN0IEFycmF5XVwiIT09dChBKSYmXCJbb2JqZWN0IEZ1bmN0aW9uXVwiPT09dChBLmNhbGxlZSl9LEM9ZnVuY3Rpb24oKXtyZXR1cm4gaShhcmd1bWVudHMpfSgpO2kuaXNMZWdhY3lBcmd1bWVudHM9QixBLmV4cG9ydHM9Qz9pOkJ9LDgyNjU6KEEsZSxJKT0+e1widXNlIHN0cmljdFwiO3ZhciBnLHQ9T2JqZWN0LnByb3RvdHlwZS50b1N0cmluZyxpPUZ1bmN0aW9uLnByb3RvdHlwZS50b1N0cmluZyxCPS9eXFxzKig/OmZ1bmN0aW9uKT9cXCovLEM9SSg2OTgpKCksUT1PYmplY3QuZ2V0UHJvdG90eXBlT2Y7QS5leHBvcnRzPWZ1bmN0aW9uKEEpe2lmKFwiZnVuY3Rpb25cIiE9dHlwZW9mIEEpcmV0dXJuITE7aWYoQi50ZXN0KGkuY2FsbChBKSkpcmV0dXJuITA7aWYoIUMpcmV0dXJuXCJbb2JqZWN0IEdlbmVyYXRvckZ1bmN0aW9uXVwiPT09dC5jYWxsKEEpO2lmKCFRKXJldHVybiExO2lmKHZvaWQgMD09PWcpe3ZhciBlPWZ1bmN0aW9uKCl7aWYoIUMpcmV0dXJuITE7dHJ5e3JldHVybiBGdW5jdGlvbihcInJldHVybiBmdW5jdGlvbiooKSB7fVwiKSgpfWNhdGNoKEEpe319KCk7Zz0hIWUmJlEoZSl9cmV0dXJuIFEoQSk9PT1nfX0sMzg3OihBLGUsSSk9PntcInVzZSBzdHJpY3RcIjt2YXIgZz1JKDUyNzgpLHQ9SSg5NzMpLGk9SSgyNzM3KSxCPWkoXCJPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nXCIpLEM9SSg2OTgpKCksUT1cInVuZGVmaW5lZFwiPT10eXBlb2YgZ2xvYmFsVGhpcz9JLmc6Z2xvYmFsVGhpcyxvPXQoKSxuPWkoXCJBcnJheS5wcm90b3R5cGUuaW5kZXhPZlwiLCEwKXx8ZnVuY3Rpb24oQSxlKXtmb3IodmFyIEk9MDtJPEEubGVuZ3RoO0krPTEpaWYoQVtJXT09PWUpcmV0dXJuIEk7cmV0dXJuLTF9LGE9aShcIlN0cmluZy5wcm90b3R5cGUuc2xpY2VcIikscj17fSxFPUkoODgyOCkscz1PYmplY3QuZ2V0UHJvdG90eXBlT2Y7QyYmRSYmcyYmZyhvLChmdW5jdGlvbihBKXt2YXIgZT1uZXcgUVtBXTtpZihTeW1ib2wudG9TdHJpbmdUYWcgaW4gZSl7dmFyIEk9cyhlKSxnPUUoSSxTeW1ib2wudG9TdHJpbmdUYWcpO2lmKCFnKXt2YXIgdD1zKEkpO2c9RSh0LFN5bWJvbC50b1N0cmluZ1RhZyl9cltBXT1nLmdldH19KSksQS5leHBvcnRzPWZ1bmN0aW9uKEEpe2lmKCFBfHxcIm9iamVjdFwiIT10eXBlb2YgQSlyZXR1cm4hMTtpZighQ3x8IShTeW1ib2wudG9TdHJpbmdUYWcgaW4gQSkpe3ZhciBlPWEoQihBKSw4LC0xKTtyZXR1cm4gbihvLGUpPi0xfXJldHVybiEhRSYmZnVuY3Rpb24oQSl7dmFyIGU9ITE7cmV0dXJuIGcociwoZnVuY3Rpb24oSSxnKXtpZighZSl0cnl7ZT1JLmNhbGwoQSk9PT1nfWNhdGNoKEEpe319KSksZX0oQSl9fSwyOTA6ZnVuY3Rpb24oQSxlLEkpe1widXNlIHN0cmljdFwiO3ZhciBnPXRoaXMmJnRoaXMuX19hd2FpdGVyfHxmdW5jdGlvbihBLGUsSSxnKXtyZXR1cm4gbmV3KEl8fChJPVByb21pc2UpKSgoZnVuY3Rpb24odCxpKXtmdW5jdGlvbiBCKEEpe3RyeXtRKGcubmV4dChBKSl9Y2F0Y2goQSl7aShBKX19ZnVuY3Rpb24gQyhBKXt0cnl7UShnLnRocm93KEEpKX1jYXRjaChBKXtpKEEpfX1mdW5jdGlvbiBRKEEpe3ZhciBlO0EuZG9uZT90KEEudmFsdWUpOihlPUEudmFsdWUsZSBpbnN0YW5jZW9mIEk/ZTpuZXcgSSgoZnVuY3Rpb24oQSl7QShlKX0pKSkudGhlbihCLEMpfVEoKGc9Zy5hcHBseShBLGV8fFtdKSkubmV4dCgpKX0pKX07T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksZS5mZXRjaE5ld1BlZXJJZD1lLmdldE9yZ2FuaXphdGlvbkluZm89dm9pZCAwO2NvbnN0IHQ9SSgyOTk0KTtmdW5jdGlvbiBpKEEsZSl7cmV0dXJuIGcodGhpcyx2b2lkIDAsdm9pZCAwLChmdW5jdGlvbiooKXtsZXQgSTt0cnl7ST15aWVsZCBmZXRjaChcImh0dHBzOi8vYXBpLnJhaW53YXkubmV0d29yay92MVwiK0EsZSl9Y2F0Y2goQSl7dGhyb3cgbmV3IHQuUmFpbndheUVycm9yKFwiQ291bGQgbm90IGNvbm5lY3QgdG8gdGhlIFJhaW53YXkgQVBJLlwiKX1pZighSS5vayl7bGV0IGU7dHJ5e2U9eWllbGQgSS5qc29uKCl9Y2F0Y2goQSl7ZT12b2lkIDB9aWYoNDIyPT09SS5zdGF0dXMmJiExPT09KG51bGw9PWU/dm9pZCAwOmUuaXNfdmFsaWQpKXRocm93IG5ldyB0LlJhaW53YXlFcnJvcihcIlRoZSBSYWlud2F5IEFQSSBrZXkgaXMgaW52YWxpZC5cIik7dGhyb3cgbmV3IHQuUmFpbndheUVycm9yKGBSYWlud2F5IEFQSSBlcnJvcjogJHtBfSByZXR1cm5lZCAke0kuc3RhdHVzfWApfXJldHVybiBJfSkpfWUuZ2V0T3JnYW5pemF0aW9uSW5mbz1mdW5jdGlvbihBKXtyZXR1cm4gZyh0aGlzLHZvaWQgMCx2b2lkIDAsKGZ1bmN0aW9uKigpe2NvbnN0IGU9eWllbGQgaShcIi9rZXlzL3ZhbGlkYXRlXCIse2hlYWRlcnM6e0F1dGhvcml6YXRpb246YEJlYXJlciAke0F9YCxBY2NlcHQ6XCJhcHBsaWNhdGlvbi9qc29uXCJ9fSksST15aWVsZCBlLmpzb24oKTtyZXR1cm57dW5pdmVyc2VGbGFnOkkudW5pdmVyc2Usb3JnYW5pemF0aW9uSWQ6SS5vcmdfaWR9fSkpfSxlLmZldGNoTmV3UGVlcklkPWZ1bmN0aW9uKCl7cmV0dXJuIGcodGhpcyx2b2lkIDAsdm9pZCAwLChmdW5jdGlvbiooKXtjb25zdCBBPXlpZWxkIGkoXCIvZHJ1aWQvbmV4dFwiLHtoZWFkZXJzOntBY2NlcHQ6XCJhcHBsaWNhdGlvbi9qc29uXCJ9fSk7cmV0dXJuIEJpZ0ludCh5aWVsZCBBLnRleHQoKSl9KSl9fSwyNDM0OihBLGUpPT57XCJ1c2Ugc3RyaWN0XCI7dmFyIEksZztPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxlLkF1ZGlvUmVhZHlTdGF0ZT1lLlZpZGVvUmVhZHlTdGF0ZT12b2lkIDAsKGc9ZS5WaWRlb1JlYWR5U3RhdGV8fChlLlZpZGVvUmVhZHlTdGF0ZT17fSkpW2cuRGV0YWNoZWQ9MF09XCJEZXRhY2hlZFwiLGdbZy5Jbml0aWFsaXppbmc9MV09XCJJbml0aWFsaXppbmdcIixnW2cuV2FpdGluZ0ZvcktleWZyYW1lPTJdPVwiV2FpdGluZ0ZvcktleWZyYW1lXCIsZ1tnLlBsYXlpbmc9M109XCJQbGF5aW5nXCIsZ1tnLlBhdXNlZD00XT1cIlBhdXNlZFwiLGdbZy5EaXNwb3NlZD01XT1cIkRpc3Bvc2VkXCIsKEk9ZS5BdWRpb1JlYWR5U3RhdGV8fChlLkF1ZGlvUmVhZHlTdGF0ZT17fSkpW0kuRGV0YWNoZWQ9MF09XCJEZXRhY2hlZFwiLElbSS5VbmluaXRpYWxpemVkPTFdPVwiVW5pbml0aWFsaXplZFwiLElbSS5Jbml0aWFsaXppbmc9Ml09XCJJbml0aWFsaXppbmdcIixJW0kuUGxheWluZz0zXT1cIlBsYXlpbmdcIixJW0kuUGF1c2VkPTRdPVwiUGF1c2VkXCJ9LDU1Mjg6KEEsZSk9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxlLmlzRGVza3RvcFNhZmFyaT12b2lkIDAsZS5pc0Rlc2t0b3BTYWZhcmk9L01hY2ludG9zaDsuKlNhZmFyaS8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSYmIS9DaHJvbWV8QW5kcm9pZC9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCl9LDk5ODc6KEEsZSk9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxlLnJlYXNzZW1ibGU9ZS5lYWNoQ2h1bms9dm9pZCAwO2xldCBJPTA7ZS5lYWNoQ2h1bms9ZnVuY3Rpb24oQSxlLGc9MTZlMyl7Y29uc3QgdD1NYXRoLmNlaWwoQS5sZW5ndGgvZyksaT0rK0k7Zm9yKGxldCBJPTA7STx0O0krKyl7Y29uc3QgQj1JKmcsQz1NYXRoLm1pbigoSSsxKSpnLEEubGVuZ3RoKTtlKHtjaHVua3NJbkdyb3VwOnQsZ3JvdXBJZDppLGluZGV4OkksZGF0YTpBLnNsaWNlKEIsQyl9KX19LGUucmVhc3NlbWJsZT1mdW5jdGlvbihBKXtsZXQgZT0wO2NvbnN0IEk9QS5jaHVua3MubGVuZ3RoO2ZvcihsZXQgZz0wO2c8STtnKyspZSs9QS5jaHVua3NbZ10uYnl0ZUxlbmd0aDtjb25zdCBnPW5ldyBVaW50OEFycmF5KGUpO2xldCB0PTA7Zm9yKGxldCBlPTA7ZTxJO2UrKyl7Y29uc3QgST1BLmNodW5rc1tlXTtnLnNldChJLHQpLHQrPUkuYnl0ZUxlbmd0aH1yZXR1cm4gZ319LDkwMjQ6KEEsZSk9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxlLkFjdGlvbj12b2lkIDAsZS5BY3Rpb249Y2xhc3N7Y29uc3RydWN0b3IoKXt0aGlzLmhhbmRsZXJzPVtdfWFkZEhhbmRsZXIoQSl7dGhpcy5oYW5kbGVycy5wdXNoKEEpfXJlbW92ZUhhbmRsZXIoQSl7dGhpcy5oYW5kbGVycz10aGlzLmhhbmRsZXJzLmZpbHRlcigoZT0+ZSE9PUEpKX1pbnZva2UoQSl7Zm9yKGxldCBlPTA7ZTx0aGlzLmhhbmRsZXJzLmxlbmd0aDtlKyspdGhpcy5oYW5kbGVyc1tlXShBKX19fSwzOTMwOihBLGUpPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksZS5ib3VuZGluZ1JlY3RhbmdsZT12b2lkIDAsZS5ib3VuZGluZ1JlY3RhbmdsZT1mdW5jdGlvbihBKXtjb25zdCBlPUEubGVuZ3RoO2lmKDA9PT1lKXRocm93IG5ldyBFcnJvcihcImJvdW5kaW5nUmVjdGFuZ2xlKCkgb2YgMCByZWN0YW5nbGVzXCIpO2NvbnN0IEk9QVswXTtsZXR7bGVmdDpnLHRvcDp0fT1JLGk9ZytJLndpZHRoLEI9dCtJLmhlaWdodDtmb3IobGV0IEk9MTtJPGU7SSsrKXtjb25zdCBlPUFbSV07Zz1NYXRoLm1pbihnLGUubGVmdCksdD1NYXRoLm1pbih0LGUudG9wKSxpPU1hdGgubWF4KGksZS5sZWZ0K2Uud2lkdGgpLEI9TWF0aC5tYXgoQixlLnRvcCtlLmhlaWdodCl9cmV0dXJue2xlZnQ6Zyx0b3A6dCx3aWR0aDppLWcsaGVpZ2h0OkItdH19fSwxOTg6KEEsZSk9PntcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiBJKEEpe2lmKDA9PT1BLmxlbmd0aClyZXR1cm4gTmFOO2xldCBlPTA7Zm9yKGNvbnN0IEkgb2YgQSllKz1JO3JldHVybiBlL0EubGVuZ3RofU9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLGUubWVhbk9yWmVybz1lLm1lYW49ZS5zdGFuZGFyZERldmlhdGlvbj1lLmludGVycXVhcnRpbGVSYW5nZT1lLm1lZGlhbj1lLldpbmRvd1RyYWNrPXZvaWQgMCxlLldpbmRvd1RyYWNrPWNsYXNze2NvbnN0cnVjdG9yKEEsZSl7dGhpcy5zaXplTXM9QSx0aGlzLmF2ZXJhZ2VPcGVyYXRpb249ZSx0aGlzLmNhY2hlZEF2ZXJhZ2U9dm9pZCAwLHRoaXMuYnVmZmVyPVtdfWdldCB2YWx1ZXMoKXtyZXR1cm4gdGhpcy50cmltKCksdGhpcy5idWZmZXIubWFwKChBPT5BLnZhbHVlKSl9Z2V0IG1lYXN1cmVtZW50cygpe3JldHVybiB0aGlzLnRyaW0oKSx0aGlzLmJ1ZmZlcn10cmltKCl7Y29uc3QgQT1wZXJmb3JtYW5jZS5ub3coKSxlPXRoaXMuYnVmZmVyLmZpbmRJbmRleCgoZT0+ZS50aW1lPkEtdGhpcy5zaXplTXMpKTtlPjA/KHRoaXMuYnVmZmVyLnNwbGljZSgwLGUpLHRoaXMuY2FjaGVkQXZlcmFnZT12b2lkIDApOi0xPT09ZSYmKHRoaXMuYnVmZmVyLnNwbGljZSgwLHRoaXMuYnVmZmVyLmxlbmd0aCksdGhpcy5jYWNoZWRBdmVyYWdlPXZvaWQgMCl9ZmVlZChBKXtjb25zdCBlPXBlcmZvcm1hbmNlLm5vdygpO3RoaXMuYnVmZmVyLnB1c2goe3RpbWU6ZSx2YWx1ZTpBfSksdGhpcy5idWZmZXIubGVuZ3RoPj01MDAmJnRoaXMudHJpbSgpLHRoaXMuY2FjaGVkQXZlcmFnZT12b2lkIDB9YXZlcmFnZSgpe2lmKHRoaXMudHJpbSgpLHRoaXMuY2FjaGVkQXZlcmFnZSlyZXR1cm4gdGhpcy5jYWNoZWRBdmVyYWdlO2NvbnN0IEE9dGhpcy5idWZmZXIubWFwKChBPT5BLnZhbHVlKSk7cmV0dXJuIHRoaXMuY2FjaGVkQXZlcmFnZT10aGlzLmF2ZXJhZ2VPcGVyYXRpb24oQSl9fSxlLm1lZGlhbj1mdW5jdGlvbihBKXtyZXR1cm4gMD09PUEubGVuZ3RoP05hTjooQS5zb3J0KCgoQSxlKT0+QS1lKSksQVtNYXRoLmZsb29yKEEubGVuZ3RoLzIpXSl9LGUuaW50ZXJxdWFydGlsZVJhbmdlPWZ1bmN0aW9uKEEpe2lmKDA9PT1BLmxlbmd0aClyZXR1cm4gTmFOO0Euc29ydCgoKEEsZSk9PkEtZSkpO2NvbnN0IGU9TWF0aC5mbG9vciguMjUqQS5sZW5ndGgpO3JldHVybiBBW01hdGguZmxvb3IoLjc1KkEubGVuZ3RoKV0tQVtlXX0sZS5zdGFuZGFyZERldmlhdGlvbj1mdW5jdGlvbihBKXtpZigwPT09QS5sZW5ndGgpcmV0dXJuIE5hTjtjb25zdCBlPUEubGVuZ3RoLEk9QS5yZWR1Y2UoKChBLGUpPT5BK2UpLDApL2U7cmV0dXJuIE1hdGguc3FydChBLm1hcCgoQT0+TWF0aC5wb3coQS1JLDIpKSkucmVkdWNlKCgoQSxlKT0+QStlKSwwKS9lKX0sZS5tZWFuPUksZS5tZWFuT3JaZXJvPWZ1bmN0aW9uKEEpe3JldHVybiAwPT09QS5sZW5ndGg/MDpJKEEpfX0sNjkwNDpmdW5jdGlvbihBLGUsSSl7XCJ1c2Ugc3RyaWN0XCI7dmFyIGc9dGhpcyYmdGhpcy5fX2NyZWF0ZUJpbmRpbmd8fChPYmplY3QuY3JlYXRlP2Z1bmN0aW9uKEEsZSxJLGcpe3ZvaWQgMD09PWcmJihnPUkpLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBLGcse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIGVbSV19fSl9OmZ1bmN0aW9uKEEsZSxJLGcpe3ZvaWQgMD09PWcmJihnPUkpLEFbZ109ZVtJXX0pLHQ9dGhpcyYmdGhpcy5fX2V4cG9ydFN0YXJ8fGZ1bmN0aW9uKEEsZSl7Zm9yKHZhciBJIGluIEEpXCJkZWZhdWx0XCI9PT1JfHxPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZSxJKXx8ZyhlLEEsSSl9O09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQoSSg3MTYyKSxlKX0sNzE2MjooQSxlLEkpPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksZS5BY2NlcHRTdHJlYW1SZXF1ZXN0X0ludm9rZT1lLkNsZWFySm9pblJlcXVlc3RzX0ludm9rZT1lLkdldEpvaW5SZXF1ZXN0c19JbnZva2U9ZS5SZWplY3RKb2luUmVxdWVzdF9JbnZva2U9ZS5BY2NlcHRKb2luUmVxdWVzdF9JbnZva2U9ZS5DbGVhckxvZ3NfSW52b2tlPWUuR2V0TG9nc19JbnZva2U9ZS5TZXRMb2dMZXZlbF9JbnZva2U9ZS5HZXRQZWVySWRfSW52b2tlPWUuR2V0VmVyc2lvbl9JbnZva2U9ZS5TaHV0ZG93bl9JbnZva2U9ZS5Jbml0aWFsaXplX0ludm9rZT1lLlJlc3BvbnNlPWUuUmVxdWVzdD1lLlRlbGVtZXRyeVZhbHVlVHlwZT1lLlJhaW53YXlUZWxlbWV0cnlEaW1lbnNpb249ZS5SYWlud2F5VGVsZW1ldHJ5UmVjb3JkPWUuUmFpbndheVRlbGVtZXRyeVJlcXVlc3Q9ZS5UZWxlbWV0cnlCYXRjaGVzS2V5VGVtcGxhdGU9ZS5UZWxlbWV0cnlTZXRLZXk9ZS5HYXRld2F5Rm9yd2FyZGFibGVCb2R5PWUuUGVlclNpZ25hbGluZ0luZm9ybWF0aW9uPWUuUmVqZWN0ZWRDb25uZWN0aW9uUmVxdWVzdD1lLkFjY2VwdGVkQ29ubmVjdGlvblJlcXVlc3Q9ZS5Db25uZWN0aW9uUmVxdWVzdD1lLkdhdGV3YXlSZXNwb25zZUJvZHk9ZS5HYXRld2F5SGVsbG89ZS5HYXRld2F5UmVxdWVzdEJvZHk9ZS5Jbml0Q29ubmVjdGlvblJlcXVlc3Q9ZS5HYXRld2F5Qm9keT1lLkdhdGV3YXlGb3J3YXJkYWJsZT1lLkdhdGV3YXlBbGVydD1lLkdhdGV3YXlSZXNwb25zZT1lLkdhdGV3YXlSZXF1ZXN0PWUuR2F0ZXdheURhdGFncmFtPWUuR2F0ZXdheUhlYWRlcj1lLlBlbmRpbmdDb25uZWN0aW9uUmVxdWVzdD1lLlBlZXI9ZS5HYXRld2F5SWRlbnRpdHk9ZS5HYXRld2F5VHJ1bms9ZS5QZWVySW5mb3JtYXRpb25UeXBlPWUuUGVlclRyYW5zcG9ydFR5cGU9ZS5HYXRld2F5QWxlcnREZXNjcmlwdGlvbj1lLkdhdGV3YXlBbGVydExldmVsPWUuR2F0ZXdheVJlc3BvbnNlQ29udGV4dD1lLlBlZXJTZXRLZXlUZW1wbGF0ZT1lLkFjY2VwdGVkQ29ubmVjdGlvblJlcXVlc3RLZXlUZW1wbGF0ZT1lLlBlbmRpbmdDb25uZWN0aW9uUmVxdWVzdEtleVRlbXBsYXRlPWUuUGVlcktleVRlbXBsYXRlPWUuRGF0YWdyYW1DaGFubmVsPXZvaWQgMCxlLldpbmRvd3NQb2ludGVyRmxhZ3M9ZS5WaXJ0dWFsS2V5PWUuS2V5Ym9hcmRBY3Rpb249ZS5TY3JvbGxBeGlzPWUuTW91c2VCdXR0b249ZS5CdXR0b25BY3Rpb249ZS5YSW5wdXRCdXR0b25zPWUuQXJiaXRyYXJ5RGF0YWdyYW09ZS5NZWRpYURhdGFncmFtPWUuTG9naWNEYXRhZ3JhbT1lLklucHV0RGF0YWdyYW09ZS5DaHVuaz1lLlJhaW53YXlIZWFkZXI9ZS5HdWlkPWUuUGVlck1lc3NhZ2U9ZS5QZWVyU3RhdGVDaGFuZ2U9ZS5TdHJlYW1SZXF1ZXN0T3BlcmF0aW9uPWUuSm9pblJlcXVlc3RPcGVyYXRpb249ZS5Mb2dFbnRyeT1lLlBlZXJTdGF0ZT1lLkxvZ0xldmVsPWUuUmV0dXJuPWUuQ2xlYXJQZWVyTWVzc2FnZXNfUmV0dXJuPWUuR2V0UGVlck1lc3NhZ2VzX1JldHVybj1lLkNsZWFyUGVlclN0YXRlQ2hhbmdlc19SZXR1cm49ZS5HZXRQZWVyU3RhdGVDaGFuZ2VzX1JldHVybj1lLkNsZWFyU3RyZWFtUmVxdWVzdHNfUmV0dXJuPWUuR2V0U3RyZWFtUmVxdWVzdHNfUmV0dXJuPWUuUmVqZWN0U3RyZWFtUmVxdWVzdF9SZXR1cm49ZS5BY2NlcHRTdHJlYW1SZXF1ZXN0X1JldHVybj1lLkNsZWFySm9pblJlcXVlc3RzX1JldHVybj1lLkdldEpvaW5SZXF1ZXN0c19SZXR1cm49ZS5SZWplY3RKb2luUmVxdWVzdF9SZXR1cm49ZS5BY2NlcHRKb2luUmVxdWVzdF9SZXR1cm49ZS5DbGVhckxvZ3NfUmV0dXJuPWUuR2V0TG9nc19SZXR1cm49ZS5TZXRMb2dMZXZlbF9SZXR1cm49ZS5HZXRQZWVySWRfUmV0dXJuPWUuR2V0VmVyc2lvbl9SZXR1cm49ZS5TaHV0ZG93bl9SZXR1cm49ZS5Jbml0aWFsaXplX1JldHVybj1lLkVycm9yX1JldHVybj1lLkludm9jYXRpb249ZS5DbGVhclBlZXJNZXNzYWdlc19JbnZva2U9ZS5HZXRQZWVyTWVzc2FnZXNfSW52b2tlPWUuQ2xlYXJQZWVyU3RhdGVDaGFuZ2VzX0ludm9rZT1lLkdldFBlZXJTdGF0ZUNoYW5nZXNfSW52b2tlPWUuQ2xlYXJTdHJlYW1SZXF1ZXN0c19JbnZva2U9ZS5HZXRTdHJlYW1SZXF1ZXN0c19JbnZva2U9ZS5SZWplY3RTdHJlYW1SZXF1ZXN0X0ludm9rZT12b2lkIDAsZS5JbnB1dExldmVsUmVxdWVzdD1lLklucHV0TGV2ZWxVcGRhdGU9ZS5SZWplY3RTdHJlYW1SZXF1ZXN0PWUuUGF1c2VTdHJlYW09ZS5Kb2luU3RyZWFtPWUuVmlkZW9CaXRyYXRlUmVxdWVzdD1lLktleWZyYW1lUmVxdWVzdD1lLlN0cmVhbVN0b3BwaW5nPWUuTGVhdmVTdHJlYW09ZS5TdHJlYW1SZXF1ZXN0PWUuRXJyb3JSZXNwb25zZT1lLkNsaWVudENhcGFiaWxpdGllcz1lLkNvZGVjUGFja1Jlc3BvbnNlPWUuQ29kZWNQYWNrUmVxdWVzdD1lLkRldmljZUluZm89ZS5SZW1vdGVTdHJlYW1JbmZvPWUuSW5wdXRMZXZlbD1lLlZpZGVvQ29uZmlnPWUuU3RyZWFtVHlwZT1lLkF1ZGlvQ29uZmlnPWUuTG9naWNFcnJvcj1lLlZpZGVvQ29udGFpbmVyPWUuQXVkaW9Db250YWluZXI9ZS5BdWRpb0NvZGVjPWUuQXVkaW9DaGFubmVscz1lLk5ldHdvcmtQcm90b2NvbD1lLk9wZXJhdGluZ1N5c3RlbT1lLkZvcm1GYWN0b3I9ZS5WaWRlb0NvZGVjPWUuVmVuZG9yPWUuVmlkZW9Db2RlY1R5cGU9ZS5JbnB1dEJvZHk9ZS5JbnB1dEJvZHlJbm5lcj1lLlNldENsaXBib2FyZFRleHQ9ZS5WaWV3cG9ydFJlc2l6ZT1lLlBlbkFic29sdXRlPWUuVG91Y2hlc0Fic29sdXRlPWUuTG9naWNhbElucHV0PWUuS2V5Ym9hcmRJbnB1dD1lLk1vdXNlU2Nyb2xsPWUuTW91c2VDbGljaz1lLk1vdXNlUmVsYXRpdmU9ZS5Nb3VzZUFic29sdXRlPWUuR2FtZXBhZFJ1bWJsZT1lLkdhbWVwYWRSZXBvcnQ9ZS5Ub3VjaEFic29sdXRlPWUuUGVuRmxhZ3M9ZS5QZW5NYXNrPWUuVG91Y2hNYXNrPWUuVG91Y2hQZW5Qb2ludGVySW5mbz12b2lkIDAsZS5NZWRpYUJvZHk9ZS5NZWRpYUNodW5rPWUuQXVkaW9EYXRhPWUuUG9pbnRlckRhdGE9ZS5WaWRlb0RhdGE9ZS5EZXNrdG9wUmVjdD1lLkF1ZGlvRGF0YVR5cGU9ZS5WaWRlb0RhdGFUeXBlPWUuTG9naWNCb2R5PWUuTGlzdFN0cmVhbXM9ZS5TdHJlYW1Bbm5vdW5jZW1lbnQ9dm9pZCAwO2NvbnN0IGc9SSg3MTIwKTt2YXIgdCxpLEIsQyxRLG8sbixhLHIsRSxzLGQsYyxoLEQsdSx3LGwseSxTLEYsUixwLEcsZixtLGssVSxOLE0sTDtlLkRhdGFncmFtQ2hhbm5lbD1cIm5ldHdvcms6ZGF0YWdyYW1zXCIsZS5QZWVyS2V5VGVtcGxhdGU9XCJuZXR3b3JrOnBlZXJzOnswfVwiLGUuUGVuZGluZ0Nvbm5lY3Rpb25SZXF1ZXN0S2V5VGVtcGxhdGU9XCJuZXR3b3JrOmNvbm5lY3Rpb24ucmVxdWVzdHM6cGVuZGluZzp7MH1cIixlLkFjY2VwdGVkQ29ubmVjdGlvblJlcXVlc3RLZXlUZW1wbGF0ZT1cIm5ldHdvcms6Y29ubmVjdGlvbi5yZXF1ZXN0czphY2NlcHRlZDp7MH1cIixlLlBlZXJTZXRLZXlUZW1wbGF0ZT1cIm5ldHdvcms6YWN0aXZlLnBlZXJzOnswfVwiLGUuR2F0ZXdheVJlc3BvbnNlQ29udGV4dD17ZW5jb2RlKEEpe2NvbnN0IGU9Zy5CZWJvcFZpZXcuZ2V0SW5zdGFuY2UoKTtyZXR1cm4gZS5zdGFydFdyaXRpbmcoKSx0aGlzLmVuY29kZUludG8oQSxlKSxlLnRvQXJyYXkoKX0sZW5jb2RlSW50byhBLEkpe2NvbnN0IGc9SS5sZW5ndGg7cmV0dXJuIEkud3JpdGVJbnQ2NChBLnNvdXJjZVBlZXJJZCksSS53cml0ZUludDY0KEEudGFyZ2V0UGVlcklkKSxlLkdhdGV3YXlEYXRhZ3JhbS5lbmNvZGVJbnRvKEEuZGF0YWdyYW0sSSksSS5sZW5ndGgtZ30sZGVjb2RlKEEpe2NvbnN0IGU9Zy5CZWJvcFZpZXcuZ2V0SW5zdGFuY2UoKTtyZXR1cm4gZS5zdGFydFJlYWRpbmcoQSksdGhpcy5yZWFkRnJvbShlKX0scmVhZEZyb20oQSl7bGV0IEksZyx0O3JldHVybiBJPUEucmVhZEludDY0KCksZz1BLnJlYWRJbnQ2NCgpLHQ9ZS5HYXRld2F5RGF0YWdyYW0ucmVhZEZyb20oQSkse3NvdXJjZVBlZXJJZDpJLHRhcmdldFBlZXJJZDpnLGRhdGFncmFtOnR9fX0sKEw9ZS5HYXRld2F5QWxlcnRMZXZlbHx8KGUuR2F0ZXdheUFsZXJ0TGV2ZWw9e30pKVtMLlVua25vd249MF09XCJVbmtub3duXCIsTFtMLldhcm5pbmc9MV09XCJXYXJuaW5nXCIsTFtMLkZhdGFsPTJdPVwiRmF0YWxcIiwoTT1lLkdhdGV3YXlBbGVydERlc2NyaXB0aW9ufHwoZS5HYXRld2F5QWxlcnREZXNjcmlwdGlvbj17fSkpW00uQ2xvc2VOb3RpZnk9MF09XCJDbG9zZU5vdGlmeVwiLE1bTS5VbmV4cGVjdGVkTWVzc2FnZT0xMF09XCJVbmV4cGVjdGVkTWVzc2FnZVwiLE1bTS5SZWNvcmRPdmVyZmxvdz0yMF09XCJSZWNvcmRPdmVyZmxvd1wiLE1bTS5UaWNrZXRWYWxpZGF0aW9uRXJyb3I9MzBdPVwiVGlja2V0VmFsaWRhdGlvbkVycm9yXCIsTVtNLkFjY2Vzc0RlbmllZD00OV09XCJBY2Nlc3NEZW5pZWRcIixNW00uRGVjb2RlRXJyb3I9NTBdPVwiRGVjb2RlRXJyb3JcIixNW00uRGVjcnlwdEVycm9yPTUxXT1cIkRlY3J5cHRFcnJvclwiLE1bTS5Qcm90b2NvbFZlcnNpb249NzBdPVwiUHJvdG9jb2xWZXJzaW9uXCIsTVtNLkludGVybmFsRXJyb3I9ODBdPVwiSW50ZXJuYWxFcnJvclwiLE1bTS5QZWVyR29uZUF3YXk9OTBdPVwiUGVlckdvbmVBd2F5XCIsTVtNLkNvbW1pdEZhaWx1cmU9MTAwXT1cIkNvbW1pdEZhaWx1cmVcIixNW00uUmVzb3VyY2VFeHBpcmVkPTIwMF09XCJSZXNvdXJjZUV4cGlyZWRcIiwoTj1lLlBlZXJUcmFuc3BvcnRUeXBlfHwoZS5QZWVyVHJhbnNwb3J0VHlwZT17fSkpW04uSW52YWxpZD0wXT1cIkludmFsaWRcIixOW04uU0NUUD0xXT1cIlNDVFBcIixOW04uR1VEUD0yXT1cIkdVRFBcIixOW04uUmVzZXJ2ZWQ9M109XCJSZXNlcnZlZFwiLChVPWUuUGVlckluZm9ybWF0aW9uVHlwZXx8KGUuUGVlckluZm9ybWF0aW9uVHlwZT17fSkpW1UuSW52YWxpZD0wXT1cIkludmFsaWRcIixVW1UuT2ZmZXI9MV09XCJPZmZlclwiLFVbVS5BbnN3ZXI9Ml09XCJBbnN3ZXJcIixVW1UuQ2FuZGlkYXRlPTNdPVwiQ2FuZGlkYXRlXCIsZS5HYXRld2F5VHJ1bms9e2VuY29kZShBKXtjb25zdCBlPWcuQmVib3BWaWV3LmdldEluc3RhbmNlKCk7cmV0dXJuIGUuc3RhcnRXcml0aW5nKCksdGhpcy5lbmNvZGVJbnRvKEEsZSksZS50b0FycmF5KCl9LGVuY29kZUludG8oQSxlKXtjb25zdCBJPWUubGVuZ3RoO3JldHVybiBlLndyaXRlU3RyaW5nKEEubWFjaGluZUlkKSxlLndyaXRlRGF0ZShBLnN0YXJ0RGF0ZSksZS5sZW5ndGgtSX0sZGVjb2RlKEEpe2NvbnN0IGU9Zy5CZWJvcFZpZXcuZ2V0SW5zdGFuY2UoKTtyZXR1cm4gZS5zdGFydFJlYWRpbmcoQSksdGhpcy5yZWFkRnJvbShlKX0scmVhZEZyb20oQSl7bGV0IGUsSTtyZXR1cm4gZT1BLnJlYWRTdHJpbmcoKSxJPUEucmVhZERhdGUoKSx7bWFjaGluZUlkOmUsc3RhcnREYXRlOkl9fX0sZS5HYXRld2F5SWRlbnRpdHk9e2VuY29kZShBKXtjb25zdCBlPWcuQmVib3BWaWV3LmdldEluc3RhbmNlKCk7cmV0dXJuIGUuc3RhcnRXcml0aW5nKCksdGhpcy5lbmNvZGVJbnRvKEEsZSksZS50b0FycmF5KCl9LGVuY29kZUludG8oQSxlKXtjb25zdCBJPWUubGVuZ3RoO3JldHVybiBlLndyaXRlU3RyaW5nKEEuYXBpS2V5KSxlLndyaXRlSW50NjQoQS5pZCksZS53cml0ZVN0cmluZyhBLmV4dGVybmFsSWQpLGUubGVuZ3RoLUl9LGRlY29kZShBKXtjb25zdCBlPWcuQmVib3BWaWV3LmdldEluc3RhbmNlKCk7cmV0dXJuIGUuc3RhcnRSZWFkaW5nKEEpLHRoaXMucmVhZEZyb20oZSl9LHJlYWRGcm9tKEEpe2xldCBlLEksZztyZXR1cm4gZT1BLnJlYWRTdHJpbmcoKSxJPUEucmVhZEludDY0KCksZz1BLnJlYWRTdHJpbmcoKSx7YXBpS2V5OmUsaWQ6SSxleHRlcm5hbElkOmd9fX0sZS5QZWVyPXtlbmNvZGUoQSl7Y29uc3QgZT1nLkJlYm9wVmlldy5nZXRJbnN0YW5jZSgpO3JldHVybiBlLnN0YXJ0V3JpdGluZygpLHRoaXMuZW5jb2RlSW50byhBLGUpLGUudG9BcnJheSgpfSxlbmNvZGVJbnRvKEEsZSl7Y29uc3QgST1lLmxlbmd0aDtyZXR1cm4gZS53cml0ZUludDY0KEEuaWQpLGUud3JpdGVTdHJpbmcoQS5leHRlcm5hbElkKSxlLndyaXRlRGF0ZShBLmNvbm5lY3Rpb25EYXRlKSxlLndyaXRlSW50NjQoQS5vcmdhbml6YXRpb25JZCksZS5sZW5ndGgtSX0sZGVjb2RlKEEpe2NvbnN0IGU9Zy5CZWJvcFZpZXcuZ2V0SW5zdGFuY2UoKTtyZXR1cm4gZS5zdGFydFJlYWRpbmcoQSksdGhpcy5yZWFkRnJvbShlKX0scmVhZEZyb20oQSl7bGV0IGUsSSxnLHQ7cmV0dXJuIGU9QS5yZWFkSW50NjQoKSxJPUEucmVhZFN0cmluZygpLGc9QS5yZWFkRGF0ZSgpLHQ9QS5yZWFkSW50NjQoKSx7aWQ6ZSxleHRlcm5hbElkOkksY29ubmVjdGlvbkRhdGU6Zyxvcmdhbml6YXRpb25JZDp0fX19LGUuUGVuZGluZ0Nvbm5lY3Rpb25SZXF1ZXN0PXtlbmNvZGUoQSl7Y29uc3QgZT1nLkJlYm9wVmlldy5nZXRJbnN0YW5jZSgpO3JldHVybiBlLnN0YXJ0V3JpdGluZygpLHRoaXMuZW5jb2RlSW50byhBLGUpLGUudG9BcnJheSgpfSxlbmNvZGVJbnRvKEEsZSl7Y29uc3QgST1lLmxlbmd0aDtyZXR1cm4gZS53cml0ZUludDY0KEEuc291cmNlUGVlcklkKSxlLndyaXRlSW50NjQoQS50YXJnZXRQZWVySWQpLGUubGVuZ3RoLUl9LGRlY29kZShBKXtjb25zdCBlPWcuQmVib3BWaWV3LmdldEluc3RhbmNlKCk7cmV0dXJuIGUuc3RhcnRSZWFkaW5nKEEpLHRoaXMucmVhZEZyb20oZSl9LHJlYWRGcm9tKEEpe2xldCBlLEk7cmV0dXJuIGU9QS5yZWFkSW50NjQoKSxJPUEucmVhZEludDY0KCkse3NvdXJjZVBlZXJJZDplLHRhcmdldFBlZXJJZDpJfX19LGUuR2F0ZXdheUhlYWRlcj17ZW5jb2RlKEEpe2NvbnN0IGU9Zy5CZWJvcFZpZXcuZ2V0SW5zdGFuY2UoKTtyZXR1cm4gZS5zdGFydFdyaXRpbmcoKSx0aGlzLmVuY29kZUludG8oQSxlKSxlLnRvQXJyYXkoKX0sZW5jb2RlSW50byhBLGUpe2NvbnN0IEk9ZS5sZW5ndGg7cmV0dXJuIGUud3JpdGVVaW50MzIoQS5zeW5jS2V5KSxlLmxlbmd0aC1JfSxkZWNvZGUoQSl7Y29uc3QgZT1nLkJlYm9wVmlldy5nZXRJbnN0YW5jZSgpO3JldHVybiBlLnN0YXJ0UmVhZGluZyhBKSx0aGlzLnJlYWRGcm9tKGUpfSxyZWFkRnJvbShBKXtsZXQgZTtyZXR1cm4gZT1BLnJlYWRVaW50MzIoKSx7c3luY0tleTplfX19LGUuR2F0ZXdheURhdGFncmFtPXtlbmNvZGUoQSl7Y29uc3QgZT1nLkJlYm9wVmlldy5nZXRJbnN0YW5jZSgpO3JldHVybiBlLnN0YXJ0V3JpdGluZygpLHRoaXMuZW5jb2RlSW50byhBLGUpLGUudG9BcnJheSgpfSxlbmNvZGVJbnRvKEEsSSl7Y29uc3QgZz1JLmxlbmd0aDtyZXR1cm4gZS5HYXRld2F5SGVhZGVyLmVuY29kZUludG8oQS5oZWFkZXIsSSksZS5HYXRld2F5Qm9keS5lbmNvZGVJbnRvKEEuYm9keSxJKSxJLmxlbmd0aC1nfSxkZWNvZGUoQSl7Y29uc3QgZT1nLkJlYm9wVmlldy5nZXRJbnN0YW5jZSgpO3JldHVybiBlLnN0YXJ0UmVhZGluZyhBKSx0aGlzLnJlYWRGcm9tKGUpfSxyZWFkRnJvbShBKXtsZXQgSSxnO3JldHVybiBJPWUuR2F0ZXdheUhlYWRlci5yZWFkRnJvbShBKSxnPWUuR2F0ZXdheUJvZHkucmVhZEZyb20oQSkse2hlYWRlcjpJLGJvZHk6Z319fSxlLkdhdGV3YXlSZXF1ZXN0PXtkaXNjcmltaW5hdG9yOjEsZW5jb2RlKEEpe2NvbnN0IGU9Zy5CZWJvcFZpZXcuZ2V0SW5zdGFuY2UoKTtyZXR1cm4gZS5zdGFydFdyaXRpbmcoKSx0aGlzLmVuY29kZUludG8oQSxlKSxlLnRvQXJyYXkoKX0sZW5jb2RlSW50byhBLEkpe2NvbnN0IGc9SS5sZW5ndGg7cmV0dXJuIGUuR2F0ZXdheVJlcXVlc3RCb2R5LmVuY29kZUludG8oQS5ib2R5LEkpLEkubGVuZ3RoLWd9LGRlY29kZShBKXtjb25zdCBlPWcuQmVib3BWaWV3LmdldEluc3RhbmNlKCk7cmV0dXJuIGUuc3RhcnRSZWFkaW5nKEEpLHRoaXMucmVhZEZyb20oZSl9LHJlYWRGcm9tKEEpe2xldCBJO3JldHVybiBJPWUuR2F0ZXdheVJlcXVlc3RCb2R5LnJlYWRGcm9tKEEpLHtib2R5Okl9fX0sZS5HYXRld2F5UmVzcG9uc2U9e2Rpc2NyaW1pbmF0b3I6MixlbmNvZGUoQSl7Y29uc3QgZT1nLkJlYm9wVmlldy5nZXRJbnN0YW5jZSgpO3JldHVybiBlLnN0YXJ0V3JpdGluZygpLHRoaXMuZW5jb2RlSW50byhBLGUpLGUudG9BcnJheSgpfSxlbmNvZGVJbnRvKEEsSSl7Y29uc3QgZz1JLmxlbmd0aDtyZXR1cm4gZS5HYXRld2F5UmVzcG9uc2VCb2R5LmVuY29kZUludG8oQS5ib2R5LEkpLEkubGVuZ3RoLWd9LGRlY29kZShBKXtjb25zdCBlPWcuQmVib3BWaWV3LmdldEluc3RhbmNlKCk7cmV0dXJuIGUuc3RhcnRSZWFkaW5nKEEpLHRoaXMucmVhZEZyb20oZSl9LHJlYWRGcm9tKEEpe2xldCBJO3JldHVybiBJPWUuR2F0ZXdheVJlc3BvbnNlQm9keS5yZWFkRnJvbShBKSx7Ym9keTpJfX19LGUuR2F0ZXdheUFsZXJ0PXtkaXNjcmltaW5hdG9yOjMsZW5jb2RlKEEpe2NvbnN0IGU9Zy5CZWJvcFZpZXcuZ2V0SW5zdGFuY2UoKTtyZXR1cm4gZS5zdGFydFdyaXRpbmcoKSx0aGlzLmVuY29kZUludG8oQSxlKSxlLnRvQXJyYXkoKX0sZW5jb2RlSW50byhBLGUpe2NvbnN0IEk9ZS5sZW5ndGg7cmV0dXJuIGUud3JpdGVVaW50MzIoQS5sZXZlbCksZS53cml0ZVVpbnQzMihBLmRlc2NyaXB0aW9uKSxlLmxlbmd0aC1JfSxkZWNvZGUoQSl7Y29uc3QgZT1nLkJlYm9wVmlldy5nZXRJbnN0YW5jZSgpO3JldHVybiBlLnN0YXJ0UmVhZGluZyhBKSx0aGlzLnJlYWRGcm9tKGUpfSxyZWFkRnJvbShBKXtsZXQgZSxJO3JldHVybiBlPUEucmVhZFVpbnQzMigpLEk9QS5yZWFkVWludDMyKCkse2xldmVsOmUsZGVzY3JpcHRpb246SX19fSxlLkdhdGV3YXlGb3J3YXJkYWJsZT17ZGlzY3JpbWluYXRvcjo0LGVuY29kZShBKXtjb25zdCBlPWcuQmVib3BWaWV3LmdldEluc3RhbmNlKCk7cmV0dXJuIGUuc3RhcnRXcml0aW5nKCksdGhpcy5lbmNvZGVJbnRvKEEsZSksZS50b0FycmF5KCl9LGVuY29kZUludG8oQSxJKXtjb25zdCBnPUkubGVuZ3RoO3JldHVybiBJLndyaXRlSW50NjQoQS50YXJnZXRQZWVySWQpLGUuR2F0ZXdheUZvcndhcmRhYmxlQm9keS5lbmNvZGVJbnRvKEEuYm9keSxJKSxJLmxlbmd0aC1nfSxkZWNvZGUoQSl7Y29uc3QgZT1nLkJlYm9wVmlldy5nZXRJbnN0YW5jZSgpO3JldHVybiBlLnN0YXJ0UmVhZGluZyhBKSx0aGlzLnJlYWRGcm9tKGUpfSxyZWFkRnJvbShBKXtsZXQgSSxnO3JldHVybiBJPUEucmVhZEludDY0KCksZz1lLkdhdGV3YXlGb3J3YXJkYWJsZUJvZHkucmVhZEZyb20oQSkse3RhcmdldFBlZXJJZDpJLGJvZHk6Z319fSxlLkdhdGV3YXlCb2R5PXtlbmNvZGUoQSl7Y29uc3QgZT1nLkJlYm9wVmlldy5nZXRJbnN0YW5jZSgpO3JldHVybiBlLnN0YXJ0V3JpdGluZygpLHRoaXMuZW5jb2RlSW50byhBLGUpLGUudG9BcnJheSgpfSxlbmNvZGVJbnRvKEEsSSl7Y29uc3QgZz1JLmxlbmd0aCx0PUkucmVzZXJ2ZU1lc3NhZ2VMZW5ndGgoKSxpPUkubGVuZ3RoKzE7c3dpdGNoKEkud3JpdGVCeXRlKEEuZGlzY3JpbWluYXRvciksQS5kaXNjcmltaW5hdG9yKXtjYXNlIDE6ZS5HYXRld2F5UmVxdWVzdC5lbmNvZGVJbnRvKEEudmFsdWUsSSk7YnJlYWs7Y2FzZSAyOmUuR2F0ZXdheVJlc3BvbnNlLmVuY29kZUludG8oQS52YWx1ZSxJKTticmVhaztjYXNlIDM6ZS5HYXRld2F5QWxlcnQuZW5jb2RlSW50byhBLnZhbHVlLEkpO2JyZWFrO2Nhc2UgNDplLkdhdGV3YXlGb3J3YXJkYWJsZS5lbmNvZGVJbnRvKEEudmFsdWUsSSl9Y29uc3QgQj1JLmxlbmd0aDtyZXR1cm4gSS5maWxsTWVzc2FnZUxlbmd0aCh0LEItaSksSS5sZW5ndGgtZ30sZGVjb2RlKEEpe2NvbnN0IGU9Zy5CZWJvcFZpZXcuZ2V0SW5zdGFuY2UoKTtyZXR1cm4gZS5zdGFydFJlYWRpbmcoQSksdGhpcy5yZWFkRnJvbShlKX0scmVhZEZyb20oQSl7Y29uc3QgST1BLnJlYWRNZXNzYWdlTGVuZ3RoKCksdD1BLmluZGV4KzErSTtzd2l0Y2goQS5yZWFkQnl0ZSgpKXtjYXNlIDE6cmV0dXJue2Rpc2NyaW1pbmF0b3I6MSx2YWx1ZTplLkdhdGV3YXlSZXF1ZXN0LnJlYWRGcm9tKEEpfTtjYXNlIDI6cmV0dXJue2Rpc2NyaW1pbmF0b3I6Mix2YWx1ZTplLkdhdGV3YXlSZXNwb25zZS5yZWFkRnJvbShBKX07Y2FzZSAzOnJldHVybntkaXNjcmltaW5hdG9yOjMsdmFsdWU6ZS5HYXRld2F5QWxlcnQucmVhZEZyb20oQSl9O2Nhc2UgNDpyZXR1cm57ZGlzY3JpbWluYXRvcjo0LHZhbHVlOmUuR2F0ZXdheUZvcndhcmRhYmxlLnJlYWRGcm9tKEEpfTtkZWZhdWx0OnRocm93IEEuaW5kZXg9dCxuZXcgZy5CZWJvcFJ1bnRpbWVFcnJvcihcIlVucmVjb2duaXplZCBkaXNjcmltaW5hdG9yIHdoaWxlIGRlY29kaW5nIEdhdGV3YXlCb2R5XCIpfX19LGUuSW5pdENvbm5lY3Rpb25SZXF1ZXN0PXtkaXNjcmltaW5hdG9yOjEsZW5jb2RlKEEpe2NvbnN0IGU9Zy5CZWJvcFZpZXcuZ2V0SW5zdGFuY2UoKTtyZXR1cm4gZS5zdGFydFdyaXRpbmcoKSx0aGlzLmVuY29kZUludG8oQSxlKSxlLnRvQXJyYXkoKX0sZW5jb2RlSW50byhBLGUpe2NvbnN0IEk9ZS5sZW5ndGg7cmV0dXJuIGUud3JpdGVJbnQ2NChBLnRhcmdldFBlZXJJZCksZS53cml0ZVVpbnQzMihBLmRlc2lyZWRUcmFuc3BvcnQpLGUubGVuZ3RoLUl9LGRlY29kZShBKXtjb25zdCBlPWcuQmVib3BWaWV3LmdldEluc3RhbmNlKCk7cmV0dXJuIGUuc3RhcnRSZWFkaW5nKEEpLHRoaXMucmVhZEZyb20oZSl9LHJlYWRGcm9tKEEpe2xldCBlLEk7cmV0dXJuIGU9QS5yZWFkSW50NjQoKSxJPUEucmVhZFVpbnQzMigpLHt0YXJnZXRQZWVySWQ6ZSxkZXNpcmVkVHJhbnNwb3J0Okl9fX0sZS5HYXRld2F5UmVxdWVzdEJvZHk9e2VuY29kZShBKXtjb25zdCBlPWcuQmVib3BWaWV3LmdldEluc3RhbmNlKCk7cmV0dXJuIGUuc3RhcnRXcml0aW5nKCksdGhpcy5lbmNvZGVJbnRvKEEsZSksZS50b0FycmF5KCl9LGVuY29kZUludG8oQSxJKXtjb25zdCBnPUkubGVuZ3RoLHQ9SS5yZXNlcnZlTWVzc2FnZUxlbmd0aCgpLGk9SS5sZW5ndGgrMTtJLndyaXRlQnl0ZShBLmRpc2NyaW1pbmF0b3IpLDE9PT1BLmRpc2NyaW1pbmF0b3ImJmUuSW5pdENvbm5lY3Rpb25SZXF1ZXN0LmVuY29kZUludG8oQS52YWx1ZSxJKTtjb25zdCBCPUkubGVuZ3RoO3JldHVybiBJLmZpbGxNZXNzYWdlTGVuZ3RoKHQsQi1pKSxJLmxlbmd0aC1nfSxkZWNvZGUoQSl7Y29uc3QgZT1nLkJlYm9wVmlldy5nZXRJbnN0YW5jZSgpO3JldHVybiBlLnN0YXJ0UmVhZGluZyhBKSx0aGlzLnJlYWRGcm9tKGUpfSxyZWFkRnJvbShBKXtjb25zdCBJPUEucmVhZE1lc3NhZ2VMZW5ndGgoKSx0PUEuaW5kZXgrMStJO2lmKDE9PT1BLnJlYWRCeXRlKCkpcmV0dXJue2Rpc2NyaW1pbmF0b3I6MSx2YWx1ZTplLkluaXRDb25uZWN0aW9uUmVxdWVzdC5yZWFkRnJvbShBKX07dGhyb3cgQS5pbmRleD10LG5ldyBnLkJlYm9wUnVudGltZUVycm9yKFwiVW5yZWNvZ25pemVkIGRpc2NyaW1pbmF0b3Igd2hpbGUgZGVjb2RpbmcgR2F0ZXdheVJlcXVlc3RCb2R5XCIpfX0sZS5HYXRld2F5SGVsbG89e2Rpc2NyaW1pbmF0b3I6MSxlbmNvZGUoQSl7Y29uc3QgZT1nLkJlYm9wVmlldy5nZXRJbnN0YW5jZSgpO3JldHVybiBlLnN0YXJ0V3JpdGluZygpLHRoaXMuZW5jb2RlSW50byhBLGUpLGUudG9BcnJheSgpfSxlbmNvZGVJbnRvKEEsZSl7Y29uc3QgST1lLmxlbmd0aDtyZXR1cm4gZS5sZW5ndGgtSX0sZGVjb2RlKEEpe2NvbnN0IGU9Zy5CZWJvcFZpZXcuZ2V0SW5zdGFuY2UoKTtyZXR1cm4gZS5zdGFydFJlYWRpbmcoQSksdGhpcy5yZWFkRnJvbShlKX0scmVhZEZyb206QT0+KHt9KX0sZS5HYXRld2F5UmVzcG9uc2VCb2R5PXtlbmNvZGUoQSl7Y29uc3QgZT1nLkJlYm9wVmlldy5nZXRJbnN0YW5jZSgpO3JldHVybiBlLnN0YXJ0V3JpdGluZygpLHRoaXMuZW5jb2RlSW50byhBLGUpLGUudG9BcnJheSgpfSxlbmNvZGVJbnRvKEEsSSl7Y29uc3QgZz1JLmxlbmd0aCx0PUkucmVzZXJ2ZU1lc3NhZ2VMZW5ndGgoKSxpPUkubGVuZ3RoKzE7SS53cml0ZUJ5dGUoQS5kaXNjcmltaW5hdG9yKSwxPT09QS5kaXNjcmltaW5hdG9yJiZlLkdhdGV3YXlIZWxsby5lbmNvZGVJbnRvKEEudmFsdWUsSSk7Y29uc3QgQj1JLmxlbmd0aDtyZXR1cm4gSS5maWxsTWVzc2FnZUxlbmd0aCh0LEItaSksSS5sZW5ndGgtZ30sZGVjb2RlKEEpe2NvbnN0IGU9Zy5CZWJvcFZpZXcuZ2V0SW5zdGFuY2UoKTtyZXR1cm4gZS5zdGFydFJlYWRpbmcoQSksdGhpcy5yZWFkRnJvbShlKX0scmVhZEZyb20oQSl7Y29uc3QgST1BLnJlYWRNZXNzYWdlTGVuZ3RoKCksdD1BLmluZGV4KzErSTtpZigxPT09QS5yZWFkQnl0ZSgpKXJldHVybntkaXNjcmltaW5hdG9yOjEsdmFsdWU6ZS5HYXRld2F5SGVsbG8ucmVhZEZyb20oQSl9O3Rocm93IEEuaW5kZXg9dCxuZXcgZy5CZWJvcFJ1bnRpbWVFcnJvcihcIlVucmVjb2duaXplZCBkaXNjcmltaW5hdG9yIHdoaWxlIGRlY29kaW5nIEdhdGV3YXlSZXNwb25zZUJvZHlcIil9fSxlLkNvbm5lY3Rpb25SZXF1ZXN0PXtkaXNjcmltaW5hdG9yOjEsZW5jb2RlKEEpe2NvbnN0IGU9Zy5CZWJvcFZpZXcuZ2V0SW5zdGFuY2UoKTtyZXR1cm4gZS5zdGFydFdyaXRpbmcoKSx0aGlzLmVuY29kZUludG8oQSxlKSxlLnRvQXJyYXkoKX0sZW5jb2RlSW50byhBLGUpe2NvbnN0IEk9ZS5sZW5ndGg7cmV0dXJuIGUud3JpdGVJbnQ2NChBLnNvdXJjZVBlZXJJZCksZS53cml0ZVN0cmluZyhBLnNvdXJjZUV4dGVybmFsSWQpLGUud3JpdGVVaW50MzIoQS5kZXNpcmVkVHJhbnNwb3J0KSxlLndyaXRlR3VpZChBLmlkKSxlLndyaXRlRGF0ZShBLmV4cGlyYXRpb25EYXRlKSxlLmxlbmd0aC1JfSxkZWNvZGUoQSl7Y29uc3QgZT1nLkJlYm9wVmlldy5nZXRJbnN0YW5jZSgpO3JldHVybiBlLnN0YXJ0UmVhZGluZyhBKSx0aGlzLnJlYWRGcm9tKGUpfSxyZWFkRnJvbShBKXtsZXQgZSxJLGcsdCxpO3JldHVybiBlPUEucmVhZEludDY0KCksST1BLnJlYWRTdHJpbmcoKSxnPUEucmVhZFVpbnQzMigpLHQ9QS5yZWFkR3VpZCgpLGk9QS5yZWFkRGF0ZSgpLHtzb3VyY2VQZWVySWQ6ZSxzb3VyY2VFeHRlcm5hbElkOkksZGVzaXJlZFRyYW5zcG9ydDpnLGlkOnQsZXhwaXJhdGlvbkRhdGU6aX19fSxlLkFjY2VwdGVkQ29ubmVjdGlvblJlcXVlc3Q9e2Rpc2NyaW1pbmF0b3I6MixlbmNvZGUoQSl7Y29uc3QgZT1nLkJlYm9wVmlldy5nZXRJbnN0YW5jZSgpO3JldHVybiBlLnN0YXJ0V3JpdGluZygpLHRoaXMuZW5jb2RlSW50byhBLGUpLGUudG9BcnJheSgpfSxlbmNvZGVJbnRvKEEsZSl7Y29uc3QgST1lLmxlbmd0aDtyZXR1cm4gZS53cml0ZUludDY0KEEuc291cmNlUGVlcklkKSxlLndyaXRlU3RyaW5nKEEuc291cmNlRXh0ZXJuYWxJZCksZS53cml0ZUd1aWQoQS5pZCksZS5sZW5ndGgtSX0sZGVjb2RlKEEpe2NvbnN0IGU9Zy5CZWJvcFZpZXcuZ2V0SW5zdGFuY2UoKTtyZXR1cm4gZS5zdGFydFJlYWRpbmcoQSksdGhpcy5yZWFkRnJvbShlKX0scmVhZEZyb20oQSl7bGV0IGUsSSxnO3JldHVybiBlPUEucmVhZEludDY0KCksST1BLnJlYWRTdHJpbmcoKSxnPUEucmVhZEd1aWQoKSx7c291cmNlUGVlcklkOmUsc291cmNlRXh0ZXJuYWxJZDpJLGlkOmd9fX0sZS5SZWplY3RlZENvbm5lY3Rpb25SZXF1ZXN0PXtkaXNjcmltaW5hdG9yOjMsZW5jb2RlKEEpe2NvbnN0IGU9Zy5CZWJvcFZpZXcuZ2V0SW5zdGFuY2UoKTtyZXR1cm4gZS5zdGFydFdyaXRpbmcoKSx0aGlzLmVuY29kZUludG8oQSxlKSxlLnRvQXJyYXkoKX0sZW5jb2RlSW50byhBLGUpe2NvbnN0IEk9ZS5sZW5ndGg7cmV0dXJuIGUud3JpdGVJbnQ2NChBLnNvdXJjZVBlZXJJZCksZS53cml0ZVN0cmluZyhBLnNvdXJjZUV4dGVybmFsSWQpLGUud3JpdGVHdWlkKEEuaWQpLGUud3JpdGVTdHJpbmcoQS5yZWFzb24pLGUubGVuZ3RoLUl9LGRlY29kZShBKXtjb25zdCBlPWcuQmVib3BWaWV3LmdldEluc3RhbmNlKCk7cmV0dXJuIGUuc3RhcnRSZWFkaW5nKEEpLHRoaXMucmVhZEZyb20oZSl9LHJlYWRGcm9tKEEpe2xldCBlLEksZyx0O3JldHVybiBlPUEucmVhZEludDY0KCksST1BLnJlYWRTdHJpbmcoKSxnPUEucmVhZEd1aWQoKSx0PUEucmVhZFN0cmluZygpLHtzb3VyY2VQZWVySWQ6ZSxzb3VyY2VFeHRlcm5hbElkOkksaWQ6ZyxyZWFzb246dH19fSxlLlBlZXJTaWduYWxpbmdJbmZvcm1hdGlvbj17ZGlzY3JpbWluYXRvcjo0LGVuY29kZShBKXtjb25zdCBlPWcuQmVib3BWaWV3LmdldEluc3RhbmNlKCk7cmV0dXJuIGUuc3RhcnRXcml0aW5nKCksdGhpcy5lbmNvZGVJbnRvKEEsZSksZS50b0FycmF5KCl9LGVuY29kZUludG8oQSxlKXtjb25zdCBJPWUubGVuZ3RoO3JldHVybiBlLndyaXRlR3VpZChBLmlkKSxlLndyaXRlVWludDMyKEEudHlwZSksZS53cml0ZVN0cmluZyhBLmRhdGEpLGUubGVuZ3RoLUl9LGRlY29kZShBKXtjb25zdCBlPWcuQmVib3BWaWV3LmdldEluc3RhbmNlKCk7cmV0dXJuIGUuc3RhcnRSZWFkaW5nKEEpLHRoaXMucmVhZEZyb20oZSl9LHJlYWRGcm9tKEEpe2xldCBlLEksZztyZXR1cm4gZT1BLnJlYWRHdWlkKCksST1BLnJlYWRVaW50MzIoKSxnPUEucmVhZFN0cmluZygpLHtpZDplLHR5cGU6SSxkYXRhOmd9fX0sZS5HYXRld2F5Rm9yd2FyZGFibGVCb2R5PXtlbmNvZGUoQSl7Y29uc3QgZT1nLkJlYm9wVmlldy5nZXRJbnN0YW5jZSgpO3JldHVybiBlLnN0YXJ0V3JpdGluZygpLHRoaXMuZW5jb2RlSW50byhBLGUpLGUudG9BcnJheSgpfSxlbmNvZGVJbnRvKEEsSSl7Y29uc3QgZz1JLmxlbmd0aCx0PUkucmVzZXJ2ZU1lc3NhZ2VMZW5ndGgoKSxpPUkubGVuZ3RoKzE7c3dpdGNoKEkud3JpdGVCeXRlKEEuZGlzY3JpbWluYXRvciksQS5kaXNjcmltaW5hdG9yKXtjYXNlIDE6ZS5Db25uZWN0aW9uUmVxdWVzdC5lbmNvZGVJbnRvKEEudmFsdWUsSSk7YnJlYWs7Y2FzZSAyOmUuQWNjZXB0ZWRDb25uZWN0aW9uUmVxdWVzdC5lbmNvZGVJbnRvKEEudmFsdWUsSSk7YnJlYWs7Y2FzZSAzOmUuUmVqZWN0ZWRDb25uZWN0aW9uUmVxdWVzdC5lbmNvZGVJbnRvKEEudmFsdWUsSSk7YnJlYWs7Y2FzZSA0OmUuUGVlclNpZ25hbGluZ0luZm9ybWF0aW9uLmVuY29kZUludG8oQS52YWx1ZSxJKX1jb25zdCBCPUkubGVuZ3RoO3JldHVybiBJLmZpbGxNZXNzYWdlTGVuZ3RoKHQsQi1pKSxJLmxlbmd0aC1nfSxkZWNvZGUoQSl7Y29uc3QgZT1nLkJlYm9wVmlldy5nZXRJbnN0YW5jZSgpO3JldHVybiBlLnN0YXJ0UmVhZGluZyhBKSx0aGlzLnJlYWRGcm9tKGUpfSxyZWFkRnJvbShBKXtjb25zdCBJPUEucmVhZE1lc3NhZ2VMZW5ndGgoKSx0PUEuaW5kZXgrMStJO3N3aXRjaChBLnJlYWRCeXRlKCkpe2Nhc2UgMTpyZXR1cm57ZGlzY3JpbWluYXRvcjoxLHZhbHVlOmUuQ29ubmVjdGlvblJlcXVlc3QucmVhZEZyb20oQSl9O2Nhc2UgMjpyZXR1cm57ZGlzY3JpbWluYXRvcjoyLHZhbHVlOmUuQWNjZXB0ZWRDb25uZWN0aW9uUmVxdWVzdC5yZWFkRnJvbShBKX07Y2FzZSAzOnJldHVybntkaXNjcmltaW5hdG9yOjMsdmFsdWU6ZS5SZWplY3RlZENvbm5lY3Rpb25SZXF1ZXN0LnJlYWRGcm9tKEEpfTtjYXNlIDQ6cmV0dXJue2Rpc2NyaW1pbmF0b3I6NCx2YWx1ZTplLlBlZXJTaWduYWxpbmdJbmZvcm1hdGlvbi5yZWFkRnJvbShBKX07ZGVmYXVsdDp0aHJvdyBBLmluZGV4PXQsbmV3IGcuQmVib3BSdW50aW1lRXJyb3IoXCJVbnJlY29nbml6ZWQgZGlzY3JpbWluYXRvciB3aGlsZSBkZWNvZGluZyBHYXRld2F5Rm9yd2FyZGFibGVCb2R5XCIpfX19LGUuVGVsZW1ldHJ5U2V0S2V5PVwibmV0d29yazp0ZWxlbWV0cnk6YmF0Y2hlc1wiLGUuVGVsZW1ldHJ5QmF0Y2hlc0tleVRlbXBsYXRlPVwibmV0d29yazp0ZWxlbWV0cnk6YmF0Y2hlczp7MH1cIixlLlJhaW53YXlUZWxlbWV0cnlSZXF1ZXN0PXtlbmNvZGUoQSl7Y29uc3QgZT1nLkJlYm9wVmlldy5nZXRJbnN0YW5jZSgpO3JldHVybiBlLnN0YXJ0V3JpdGluZygpLHRoaXMuZW5jb2RlSW50byhBLGUpLGUudG9BcnJheSgpfSxlbmNvZGVJbnRvKEEsSSl7Y29uc3QgZz1JLmxlbmd0aCx0PUkucmVzZXJ2ZU1lc3NhZ2VMZW5ndGgoKSxpPUkubGVuZ3RoO2lmKG51bGwhPUEucmVjb3Jkcyl7SS53cml0ZUJ5dGUoMSk7e2NvbnN0IGc9QS5yZWNvcmRzLmxlbmd0aDtJLndyaXRlVWludDMyKGcpO2ZvcihsZXQgdD0wO3Q8Zzt0KyspZS5SYWlud2F5VGVsZW1ldHJ5UmVjb3JkLmVuY29kZUludG8oQS5yZWNvcmRzW3RdLEkpfX1udWxsIT1BLmNvbW1vbkF0dHJpYnV0ZXMmJihJLndyaXRlQnl0ZSgyKSxlLlJhaW53YXlUZWxlbWV0cnlSZWNvcmQuZW5jb2RlSW50byhBLmNvbW1vbkF0dHJpYnV0ZXMsSSkpLEkud3JpdGVCeXRlKDApO2NvbnN0IEI9SS5sZW5ndGg7cmV0dXJuIEkuZmlsbE1lc3NhZ2VMZW5ndGgodCxCLWkpLEkubGVuZ3RoLWd9LGRlY29kZShBKXtjb25zdCBlPWcuQmVib3BWaWV3LmdldEluc3RhbmNlKCk7cmV0dXJuIGUuc3RhcnRSZWFkaW5nKEEpLHRoaXMucmVhZEZyb20oZSl9LHJlYWRGcm9tKEEpe2xldCBJPXt9O2NvbnN0IGc9QS5yZWFkTWVzc2FnZUxlbmd0aCgpLHQ9QS5pbmRleCtnO2Zvcig7Oylzd2l0Y2goQS5yZWFkQnl0ZSgpKXtjYXNlIDA6cmV0dXJuIEk7Y2FzZSAxOntsZXQgZz1BLnJlYWRVaW50MzIoKTtJLnJlY29yZHM9bmV3IEFycmF5KGcpO2ZvcihsZXQgdD0wO3Q8Zzt0Kyspe2xldCBnO2c9ZS5SYWlud2F5VGVsZW1ldHJ5UmVjb3JkLnJlYWRGcm9tKEEpLEkucmVjb3Jkc1t0XT1nfX1icmVhaztjYXNlIDI6SS5jb21tb25BdHRyaWJ1dGVzPWUuUmFpbndheVRlbGVtZXRyeVJlY29yZC5yZWFkRnJvbShBKTticmVhaztkZWZhdWx0OnJldHVybiBBLmluZGV4PXQsSX19fSxlLlJhaW53YXlUZWxlbWV0cnlSZWNvcmQ9e2VuY29kZShBKXtjb25zdCBlPWcuQmVib3BWaWV3LmdldEluc3RhbmNlKCk7cmV0dXJuIGUuc3RhcnRXcml0aW5nKCksdGhpcy5lbmNvZGVJbnRvKEEsZSksZS50b0FycmF5KCl9LGVuY29kZUludG8oQSxJKXtjb25zdCBnPUkubGVuZ3RoLHQ9SS5yZXNlcnZlTWVzc2FnZUxlbmd0aCgpLGk9SS5sZW5ndGg7aWYobnVsbCE9QS5uYW1lJiYoSS53cml0ZUJ5dGUoMSksSS53cml0ZVN0cmluZyhBLm5hbWUpKSxudWxsIT1BLnZhbHVlJiYoSS53cml0ZUJ5dGUoMiksSS53cml0ZVN0cmluZyhBLnZhbHVlKSksbnVsbCE9QS50aW1lJiYoSS53cml0ZUJ5dGUoMyksSS53cml0ZURhdGUoQS50aW1lKSksbnVsbCE9QS50eXBlJiYoSS53cml0ZUJ5dGUoNCksSS53cml0ZVVpbnQzMihBLnR5cGUpKSxudWxsIT1BLmRpbWVuc2lvbnMpe0kud3JpdGVCeXRlKDUpO3tjb25zdCBnPUEuZGltZW5zaW9ucy5sZW5ndGg7SS53cml0ZVVpbnQzMihnKTtmb3IobGV0IHQ9MDt0PGc7dCsrKWUuUmFpbndheVRlbGVtZXRyeURpbWVuc2lvbi5lbmNvZGVJbnRvKEEuZGltZW5zaW9uc1t0XSxJKX19SS53cml0ZUJ5dGUoMCk7Y29uc3QgQj1JLmxlbmd0aDtyZXR1cm4gSS5maWxsTWVzc2FnZUxlbmd0aCh0LEItaSksSS5sZW5ndGgtZ30sZGVjb2RlKEEpe2NvbnN0IGU9Zy5CZWJvcFZpZXcuZ2V0SW5zdGFuY2UoKTtyZXR1cm4gZS5zdGFydFJlYWRpbmcoQSksdGhpcy5yZWFkRnJvbShlKX0scmVhZEZyb20oQSl7bGV0IEk9e307Y29uc3QgZz1BLnJlYWRNZXNzYWdlTGVuZ3RoKCksdD1BLmluZGV4K2c7Zm9yKDs7KXN3aXRjaChBLnJlYWRCeXRlKCkpe2Nhc2UgMDpyZXR1cm4gSTtjYXNlIDE6SS5uYW1lPUEucmVhZFN0cmluZygpO2JyZWFrO2Nhc2UgMjpJLnZhbHVlPUEucmVhZFN0cmluZygpO2JyZWFrO2Nhc2UgMzpJLnRpbWU9QS5yZWFkRGF0ZSgpO2JyZWFrO2Nhc2UgNDpJLnR5cGU9QS5yZWFkVWludDMyKCk7YnJlYWs7Y2FzZSA1OntsZXQgZz1BLnJlYWRVaW50MzIoKTtJLmRpbWVuc2lvbnM9bmV3IEFycmF5KGcpO2ZvcihsZXQgdD0wO3Q8Zzt0Kyspe2xldCBnO2c9ZS5SYWlud2F5VGVsZW1ldHJ5RGltZW5zaW9uLnJlYWRGcm9tKEEpLEkuZGltZW5zaW9uc1t0XT1nfX1icmVhaztkZWZhdWx0OnJldHVybiBBLmluZGV4PXQsSX19fSxlLlJhaW53YXlUZWxlbWV0cnlEaW1lbnNpb249e2VuY29kZShBKXtjb25zdCBlPWcuQmVib3BWaWV3LmdldEluc3RhbmNlKCk7cmV0dXJuIGUuc3RhcnRXcml0aW5nKCksdGhpcy5lbmNvZGVJbnRvKEEsZSksZS50b0FycmF5KCl9LGVuY29kZUludG8oQSxlKXtjb25zdCBJPWUubGVuZ3RoO3JldHVybiBlLndyaXRlU3RyaW5nKEEubmFtZSksZS53cml0ZVN0cmluZyhBLnZhbHVlKSxlLmxlbmd0aC1JfSxkZWNvZGUoQSl7Y29uc3QgZT1nLkJlYm9wVmlldy5nZXRJbnN0YW5jZSgpO3JldHVybiBlLnN0YXJ0UmVhZGluZyhBKSx0aGlzLnJlYWRGcm9tKGUpfSxyZWFkRnJvbShBKXtsZXQgZSxJO3JldHVybiBlPUEucmVhZFN0cmluZygpLEk9QS5yZWFkU3RyaW5nKCkse25hbWU6ZSx2YWx1ZTpJfX19LChrPWUuVGVsZW1ldHJ5VmFsdWVUeXBlfHwoZS5UZWxlbWV0cnlWYWx1ZVR5cGU9e30pKVtrLkRvdWJsZT0wXT1cIkRvdWJsZVwiLGtbay5CaWdJbnQ9MV09XCJCaWdJbnRcIixrW2suVmFyQ2hhcj0yXT1cIlZhckNoYXJcIixrW2suQm9vbD0zXT1cIkJvb2xcIixlLlJlcXVlc3Q9e2VuY29kZShBKXtjb25zdCBlPWcuQmVib3BWaWV3LmdldEluc3RhbmNlKCk7cmV0dXJuIGUuc3RhcnRXcml0aW5nKCksdGhpcy5lbmNvZGVJbnRvKEEsZSksZS50b0FycmF5KCl9LGVuY29kZUludG8oQSxJKXtjb25zdCBnPUkubGVuZ3RoO3JldHVybiBJLndyaXRlR3VpZChBLnJlcXVlc3RJZCksZS5JbnZvY2F0aW9uLmVuY29kZUludG8oQS5pbnZvY2F0aW9uLEkpLEkubGVuZ3RoLWd9LGRlY29kZShBKXtjb25zdCBlPWcuQmVib3BWaWV3LmdldEluc3RhbmNlKCk7cmV0dXJuIGUuc3RhcnRSZWFkaW5nKEEpLHRoaXMucmVhZEZyb20oZSl9LHJlYWRGcm9tKEEpe2xldCBJLGc7cmV0dXJuIEk9QS5yZWFkR3VpZCgpLGc9ZS5JbnZvY2F0aW9uLnJlYWRGcm9tKEEpLHtyZXF1ZXN0SWQ6SSxpbnZvY2F0aW9uOmd9fX0sZS5SZXNwb25zZT17ZW5jb2RlKEEpe2NvbnN0IGU9Zy5CZWJvcFZpZXcuZ2V0SW5zdGFuY2UoKTtyZXR1cm4gZS5zdGFydFdyaXRpbmcoKSx0aGlzLmVuY29kZUludG8oQSxlKSxlLnRvQXJyYXkoKX0sZW5jb2RlSW50byhBLEkpe2NvbnN0IGc9SS5sZW5ndGg7cmV0dXJuIEkud3JpdGVHdWlkKEEucmVxdWVzdElkKSxlLlJldHVybi5lbmNvZGVJbnRvKEEucmV0LEkpLEkubGVuZ3RoLWd9LGRlY29kZShBKXtjb25zdCBlPWcuQmVib3BWaWV3LmdldEluc3RhbmNlKCk7cmV0dXJuIGUuc3RhcnRSZWFkaW5nKEEpLHRoaXMucmVhZEZyb20oZSl9LHJlYWRGcm9tKEEpe2xldCBJLGc7cmV0dXJuIEk9QS5yZWFkR3VpZCgpLGc9ZS5SZXR1cm4ucmVhZEZyb20oQSkse3JlcXVlc3RJZDpJLHJldDpnfX19LGUuSW5pdGlhbGl6ZV9JbnZva2U9e2Rpc2NyaW1pbmF0b3I6MSxlbmNvZGUoQSl7Y29uc3QgZT1nLkJlYm9wVmlldy5nZXRJbnN0YW5jZSgpO3JldHVybiBlLnN0YXJ0V3JpdGluZygpLHRoaXMuZW5jb2RlSW50byhBLGUpLGUudG9BcnJheSgpfSxlbmNvZGVJbnRvKEEsZSl7Y29uc3QgST1lLmxlbmd0aCxnPWUucmVzZXJ2ZU1lc3NhZ2VMZW5ndGgoKSx0PWUubGVuZ3RoO251bGwhPUEuZXh0ZXJuYWxJZCYmKGUud3JpdGVCeXRlKDEpLGUud3JpdGVTdHJpbmcoQS5leHRlcm5hbElkKSksZS53cml0ZUJ5dGUoMCk7Y29uc3QgaT1lLmxlbmd0aDtyZXR1cm4gZS5maWxsTWVzc2FnZUxlbmd0aChnLGktdCksZS5sZW5ndGgtSX0sZGVjb2RlKEEpe2NvbnN0IGU9Zy5CZWJvcFZpZXcuZ2V0SW5zdGFuY2UoKTtyZXR1cm4gZS5zdGFydFJlYWRpbmcoQSksdGhpcy5yZWFkRnJvbShlKX0scmVhZEZyb20oQSl7bGV0IGU9e307Y29uc3QgST1BLnJlYWRNZXNzYWdlTGVuZ3RoKCksZz1BLmluZGV4K0k7Zm9yKDs7KXN3aXRjaChBLnJlYWRCeXRlKCkpe2Nhc2UgMDpyZXR1cm4gZTtjYXNlIDE6ZS5leHRlcm5hbElkPUEucmVhZFN0cmluZygpO2JyZWFrO2RlZmF1bHQ6cmV0dXJuIEEuaW5kZXg9ZyxlfX19LGUuU2h1dGRvd25fSW52b2tlPXtkaXNjcmltaW5hdG9yOjIsZW5jb2RlKEEpe2NvbnN0IGU9Zy5CZWJvcFZpZXcuZ2V0SW5zdGFuY2UoKTtyZXR1cm4gZS5zdGFydFdyaXRpbmcoKSx0aGlzLmVuY29kZUludG8oQSxlKSxlLnRvQXJyYXkoKX0sZW5jb2RlSW50byhBLGUpe2NvbnN0IEk9ZS5sZW5ndGgsZz1lLnJlc2VydmVNZXNzYWdlTGVuZ3RoKCksdD1lLmxlbmd0aDtlLndyaXRlQnl0ZSgwKTtjb25zdCBpPWUubGVuZ3RoO3JldHVybiBlLmZpbGxNZXNzYWdlTGVuZ3RoKGcsaS10KSxlLmxlbmd0aC1JfSxkZWNvZGUoQSl7Y29uc3QgZT1nLkJlYm9wVmlldy5nZXRJbnN0YW5jZSgpO3JldHVybiBlLnN0YXJ0UmVhZGluZyhBKSx0aGlzLnJlYWRGcm9tKGUpfSxyZWFkRnJvbShBKXtsZXQgZT17fTtjb25zdCBJPUEucmVhZE1lc3NhZ2VMZW5ndGgoKSxnPUEuaW5kZXgrSTtmb3IoOzspcmV0dXJuIDA9PT1BLnJlYWRCeXRlKCl8fChBLmluZGV4PWcpLGV9fSxlLkdldFZlcnNpb25fSW52b2tlPXtkaXNjcmltaW5hdG9yOjMsZW5jb2RlKEEpe2NvbnN0IGU9Zy5CZWJvcFZpZXcuZ2V0SW5zdGFuY2UoKTtyZXR1cm4gZS5zdGFydFdyaXRpbmcoKSx0aGlzLmVuY29kZUludG8oQSxlKSxlLnRvQXJyYXkoKX0sZW5jb2RlSW50byhBLGUpe2NvbnN0IEk9ZS5sZW5ndGgsZz1lLnJlc2VydmVNZXNzYWdlTGVuZ3RoKCksdD1lLmxlbmd0aDtlLndyaXRlQnl0ZSgwKTtjb25zdCBpPWUubGVuZ3RoO3JldHVybiBlLmZpbGxNZXNzYWdlTGVuZ3RoKGcsaS10KSxlLmxlbmd0aC1JfSxkZWNvZGUoQSl7Y29uc3QgZT1nLkJlYm9wVmlldy5nZXRJbnN0YW5jZSgpO3JldHVybiBlLnN0YXJ0UmVhZGluZyhBKSx0aGlzLnJlYWRGcm9tKGUpfSxyZWFkRnJvbShBKXtsZXQgZT17fTtjb25zdCBJPUEucmVhZE1lc3NhZ2VMZW5ndGgoKSxnPUEuaW5kZXgrSTtmb3IoOzspcmV0dXJuIDA9PT1BLnJlYWRCeXRlKCl8fChBLmluZGV4PWcpLGV9fSxlLkdldFBlZXJJZF9JbnZva2U9e2Rpc2NyaW1pbmF0b3I6NCxlbmNvZGUoQSl7Y29uc3QgZT1nLkJlYm9wVmlldy5nZXRJbnN0YW5jZSgpO3JldHVybiBlLnN0YXJ0V3JpdGluZygpLHRoaXMuZW5jb2RlSW50byhBLGUpLGUudG9BcnJheSgpfSxlbmNvZGVJbnRvKEEsZSl7Y29uc3QgST1lLmxlbmd0aCxnPWUucmVzZXJ2ZU1lc3NhZ2VMZW5ndGgoKSx0PWUubGVuZ3RoO2Uud3JpdGVCeXRlKDApO2NvbnN0IGk9ZS5sZW5ndGg7cmV0dXJuIGUuZmlsbE1lc3NhZ2VMZW5ndGgoZyxpLXQpLGUubGVuZ3RoLUl9LGRlY29kZShBKXtjb25zdCBlPWcuQmVib3BWaWV3LmdldEluc3RhbmNlKCk7cmV0dXJuIGUuc3RhcnRSZWFkaW5nKEEpLHRoaXMucmVhZEZyb20oZSl9LHJlYWRGcm9tKEEpe2xldCBlPXt9O2NvbnN0IEk9QS5yZWFkTWVzc2FnZUxlbmd0aCgpLGc9QS5pbmRleCtJO2Zvcig7OylyZXR1cm4gMD09PUEucmVhZEJ5dGUoKXx8KEEuaW5kZXg9ZyksZX19LGUuU2V0TG9nTGV2ZWxfSW52b2tlPXtkaXNjcmltaW5hdG9yOjUsZW5jb2RlKEEpe2NvbnN0IGU9Zy5CZWJvcFZpZXcuZ2V0SW5zdGFuY2UoKTtyZXR1cm4gZS5zdGFydFdyaXRpbmcoKSx0aGlzLmVuY29kZUludG8oQSxlKSxlLnRvQXJyYXkoKX0sZW5jb2RlSW50byhBLGUpe2NvbnN0IEk9ZS5sZW5ndGgsZz1lLnJlc2VydmVNZXNzYWdlTGVuZ3RoKCksdD1lLmxlbmd0aDtudWxsIT1BLmxldmVsJiYoZS53cml0ZUJ5dGUoMSksZS53cml0ZVVpbnQzMihBLmxldmVsKSksZS53cml0ZUJ5dGUoMCk7Y29uc3QgaT1lLmxlbmd0aDtyZXR1cm4gZS5maWxsTWVzc2FnZUxlbmd0aChnLGktdCksZS5sZW5ndGgtSX0sZGVjb2RlKEEpe2NvbnN0IGU9Zy5CZWJvcFZpZXcuZ2V0SW5zdGFuY2UoKTtyZXR1cm4gZS5zdGFydFJlYWRpbmcoQSksdGhpcy5yZWFkRnJvbShlKX0scmVhZEZyb20oQSl7bGV0IGU9e307Y29uc3QgST1BLnJlYWRNZXNzYWdlTGVuZ3RoKCksZz1BLmluZGV4K0k7Zm9yKDs7KXN3aXRjaChBLnJlYWRCeXRlKCkpe2Nhc2UgMDpyZXR1cm4gZTtjYXNlIDE6ZS5sZXZlbD1BLnJlYWRVaW50MzIoKTticmVhaztkZWZhdWx0OnJldHVybiBBLmluZGV4PWcsZX19fSxlLkdldExvZ3NfSW52b2tlPXtkaXNjcmltaW5hdG9yOjYsZW5jb2RlKEEpe2NvbnN0IGU9Zy5CZWJvcFZpZXcuZ2V0SW5zdGFuY2UoKTtyZXR1cm4gZS5zdGFydFdyaXRpbmcoKSx0aGlzLmVuY29kZUludG8oQSxlKSxlLnRvQXJyYXkoKX0sZW5jb2RlSW50byhBLGUpe2NvbnN0IEk9ZS5sZW5ndGgsZz1lLnJlc2VydmVNZXNzYWdlTGVuZ3RoKCksdD1lLmxlbmd0aDtlLndyaXRlQnl0ZSgwKTtjb25zdCBpPWUubGVuZ3RoO3JldHVybiBlLmZpbGxNZXNzYWdlTGVuZ3RoKGcsaS10KSxlLmxlbmd0aC1JfSxkZWNvZGUoQSl7Y29uc3QgZT1nLkJlYm9wVmlldy5nZXRJbnN0YW5jZSgpO3JldHVybiBlLnN0YXJ0UmVhZGluZyhBKSx0aGlzLnJlYWRGcm9tKGUpfSxyZWFkRnJvbShBKXtsZXQgZT17fTtjb25zdCBJPUEucmVhZE1lc3NhZ2VMZW5ndGgoKSxnPUEuaW5kZXgrSTtmb3IoOzspcmV0dXJuIDA9PT1BLnJlYWRCeXRlKCl8fChBLmluZGV4PWcpLGV9fSxlLkNsZWFyTG9nc19JbnZva2U9e2Rpc2NyaW1pbmF0b3I6NyxlbmNvZGUoQSl7Y29uc3QgZT1nLkJlYm9wVmlldy5nZXRJbnN0YW5jZSgpO3JldHVybiBlLnN0YXJ0V3JpdGluZygpLHRoaXMuZW5jb2RlSW50byhBLGUpLGUudG9BcnJheSgpfSxlbmNvZGVJbnRvKEEsZSl7Y29uc3QgST1lLmxlbmd0aCxnPWUucmVzZXJ2ZU1lc3NhZ2VMZW5ndGgoKSx0PWUubGVuZ3RoO2Uud3JpdGVCeXRlKDApO2NvbnN0IGk9ZS5sZW5ndGg7cmV0dXJuIGUuZmlsbE1lc3NhZ2VMZW5ndGgoZyxpLXQpLGUubGVuZ3RoLUl9LGRlY29kZShBKXtjb25zdCBlPWcuQmVib3BWaWV3LmdldEluc3RhbmNlKCk7cmV0dXJuIGUuc3RhcnRSZWFkaW5nKEEpLHRoaXMucmVhZEZyb20oZSl9LHJlYWRGcm9tKEEpe2xldCBlPXt9O2NvbnN0IEk9QS5yZWFkTWVzc2FnZUxlbmd0aCgpLGc9QS5pbmRleCtJO2Zvcig7OylyZXR1cm4gMD09PUEucmVhZEJ5dGUoKXx8KEEuaW5kZXg9ZyksZX19LGUuQWNjZXB0Sm9pblJlcXVlc3RfSW52b2tlPXtkaXNjcmltaW5hdG9yOjgsZW5jb2RlKEEpe2NvbnN0IGU9Zy5CZWJvcFZpZXcuZ2V0SW5zdGFuY2UoKTtyZXR1cm4gZS5zdGFydFdyaXRpbmcoKSx0aGlzLmVuY29kZUludG8oQSxlKSxlLnRvQXJyYXkoKX0sZW5jb2RlSW50byhBLGUpe2NvbnN0IEk9ZS5sZW5ndGgsZz1lLnJlc2VydmVNZXNzYWdlTGVuZ3RoKCksdD1lLmxlbmd0aDtlLndyaXRlQnl0ZSgwKTtjb25zdCBpPWUubGVuZ3RoO3JldHVybiBlLmZpbGxNZXNzYWdlTGVuZ3RoKGcsaS10KSxlLmxlbmd0aC1JfSxkZWNvZGUoQSl7Y29uc3QgZT1nLkJlYm9wVmlldy5nZXRJbnN0YW5jZSgpO3JldHVybiBlLnN0YXJ0UmVhZGluZyhBKSx0aGlzLnJlYWRGcm9tKGUpfSxyZWFkRnJvbShBKXtsZXQgZT17fTtjb25zdCBJPUEucmVhZE1lc3NhZ2VMZW5ndGgoKSxnPUEuaW5kZXgrSTtmb3IoOzspcmV0dXJuIDA9PT1BLnJlYWRCeXRlKCl8fChBLmluZGV4PWcpLGV9fSxlLlJlamVjdEpvaW5SZXF1ZXN0X0ludm9rZT17ZGlzY3JpbWluYXRvcjo5LGVuY29kZShBKXtjb25zdCBlPWcuQmVib3BWaWV3LmdldEluc3RhbmNlKCk7cmV0dXJuIGUuc3RhcnRXcml0aW5nKCksdGhpcy5lbmNvZGVJbnRvKEEsZSksZS50b0FycmF5KCl9LGVuY29kZUludG8oQSxlKXtjb25zdCBJPWUubGVuZ3RoLGc9ZS5yZXNlcnZlTWVzc2FnZUxlbmd0aCgpLHQ9ZS5sZW5ndGg7bnVsbCE9QS5yZWFzb24mJihlLndyaXRlQnl0ZSgxKSxlLndyaXRlU3RyaW5nKEEucmVhc29uKSksZS53cml0ZUJ5dGUoMCk7Y29uc3QgaT1lLmxlbmd0aDtyZXR1cm4gZS5maWxsTWVzc2FnZUxlbmd0aChnLGktdCksZS5sZW5ndGgtSX0sZGVjb2RlKEEpe2NvbnN0IGU9Zy5CZWJvcFZpZXcuZ2V0SW5zdGFuY2UoKTtyZXR1cm4gZS5zdGFydFJlYWRpbmcoQSksdGhpcy5yZWFkRnJvbShlKX0scmVhZEZyb20oQSl7bGV0IGU9e307Y29uc3QgST1BLnJlYWRNZXNzYWdlTGVuZ3RoKCksZz1BLmluZGV4K0k7Zm9yKDs7KXN3aXRjaChBLnJlYWRCeXRlKCkpe2Nhc2UgMDpyZXR1cm4gZTtjYXNlIDE6ZS5yZWFzb249QS5yZWFkU3RyaW5nKCk7YnJlYWs7ZGVmYXVsdDpyZXR1cm4gQS5pbmRleD1nLGV9fX0sZS5HZXRKb2luUmVxdWVzdHNfSW52b2tlPXtkaXNjcmltaW5hdG9yOjEwLGVuY29kZShBKXtjb25zdCBlPWcuQmVib3BWaWV3LmdldEluc3RhbmNlKCk7cmV0dXJuIGUuc3RhcnRXcml0aW5nKCksdGhpcy5lbmNvZGVJbnRvKEEsZSksZS50b0FycmF5KCl9LGVuY29kZUludG8oQSxlKXtjb25zdCBJPWUubGVuZ3RoLGc9ZS5yZXNlcnZlTWVzc2FnZUxlbmd0aCgpLHQ9ZS5sZW5ndGg7ZS53cml0ZUJ5dGUoMCk7Y29uc3QgaT1lLmxlbmd0aDtyZXR1cm4gZS5maWxsTWVzc2FnZUxlbmd0aChnLGktdCksZS5sZW5ndGgtSX0sZGVjb2RlKEEpe2NvbnN0IGU9Zy5CZWJvcFZpZXcuZ2V0SW5zdGFuY2UoKTtyZXR1cm4gZS5zdGFydFJlYWRpbmcoQSksdGhpcy5yZWFkRnJvbShlKX0scmVhZEZyb20oQSl7bGV0IGU9e307Y29uc3QgST1BLnJlYWRNZXNzYWdlTGVuZ3RoKCksZz1BLmluZGV4K0k7Zm9yKDs7KXJldHVybiAwPT09QS5yZWFkQnl0ZSgpfHwoQS5pbmRleD1nKSxlfX0sZS5DbGVhckpvaW5SZXF1ZXN0c19JbnZva2U9e2Rpc2NyaW1pbmF0b3I6MTEsZW5jb2RlKEEpe2NvbnN0IGU9Zy5CZWJvcFZpZXcuZ2V0SW5zdGFuY2UoKTtyZXR1cm4gZS5zdGFydFdyaXRpbmcoKSx0aGlzLmVuY29kZUludG8oQSxlKSxlLnRvQXJyYXkoKX0sZW5jb2RlSW50byhBLGUpe2NvbnN0IEk9ZS5sZW5ndGgsZz1lLnJlc2VydmVNZXNzYWdlTGVuZ3RoKCksdD1lLmxlbmd0aDtlLndyaXRlQnl0ZSgwKTtjb25zdCBpPWUubGVuZ3RoO3JldHVybiBlLmZpbGxNZXNzYWdlTGVuZ3RoKGcsaS10KSxlLmxlbmd0aC1JfSxkZWNvZGUoQSl7Y29uc3QgZT1nLkJlYm9wVmlldy5nZXRJbnN0YW5jZSgpO3JldHVybiBlLnN0YXJ0UmVhZGluZyhBKSx0aGlzLnJlYWRGcm9tKGUpfSxyZWFkRnJvbShBKXtsZXQgZT17fTtjb25zdCBJPUEucmVhZE1lc3NhZ2VMZW5ndGgoKSxnPUEuaW5kZXgrSTtmb3IoOzspcmV0dXJuIDA9PT1BLnJlYWRCeXRlKCl8fChBLmluZGV4PWcpLGV9fSxlLkFjY2VwdFN0cmVhbVJlcXVlc3RfSW52b2tlPXtkaXNjcmltaW5hdG9yOjEyLGVuY29kZShBKXtjb25zdCBlPWcuQmVib3BWaWV3LmdldEluc3RhbmNlKCk7cmV0dXJuIGUuc3RhcnRXcml0aW5nKCksdGhpcy5lbmNvZGVJbnRvKEEsZSksZS50b0FycmF5KCl9LGVuY29kZUludG8oQSxlKXtjb25zdCBJPWUubGVuZ3RoLGc9ZS5yZXNlcnZlTWVzc2FnZUxlbmd0aCgpLHQ9ZS5sZW5ndGg7aWYobnVsbCE9QS5sZXZlbCYmKGUud3JpdGVCeXRlKDEpLGUud3JpdGVVaW50MzIoQS5sZXZlbCkpLG51bGwhPUEucGlkcyl7ZS53cml0ZUJ5dGUoMik7e2NvbnN0IEk9QS5waWRzLmxlbmd0aDtlLndyaXRlVWludDMyKEkpO2ZvcihsZXQgZz0wO2c8STtnKyspZS53cml0ZVVpbnQzMihBLnBpZHNbZ10pfX1lLndyaXRlQnl0ZSgwKTtjb25zdCBpPWUubGVuZ3RoO3JldHVybiBlLmZpbGxNZXNzYWdlTGVuZ3RoKGcsaS10KSxlLmxlbmd0aC1JfSxkZWNvZGUoQSl7Y29uc3QgZT1nLkJlYm9wVmlldy5nZXRJbnN0YW5jZSgpO3JldHVybiBlLnN0YXJ0UmVhZGluZyhBKSx0aGlzLnJlYWRGcm9tKGUpfSxyZWFkRnJvbShBKXtsZXQgZT17fTtjb25zdCBJPUEucmVhZE1lc3NhZ2VMZW5ndGgoKSxnPUEuaW5kZXgrSTtmb3IoOzspc3dpdGNoKEEucmVhZEJ5dGUoKSl7Y2FzZSAwOnJldHVybiBlO2Nhc2UgMTplLmxldmVsPUEucmVhZFVpbnQzMigpO2JyZWFrO2Nhc2UgMjp7bGV0IEk9QS5yZWFkVWludDMyKCk7ZS5waWRzPW5ldyBBcnJheShJKTtmb3IobGV0IGc9MDtnPEk7ZysrKXtsZXQgSTtJPUEucmVhZFVpbnQzMigpLGUucGlkc1tnXT1JfX1icmVhaztkZWZhdWx0OnJldHVybiBBLmluZGV4PWcsZX19fSxlLlJlamVjdFN0cmVhbVJlcXVlc3RfSW52b2tlPXtkaXNjcmltaW5hdG9yOjEzLGVuY29kZShBKXtjb25zdCBlPWcuQmVib3BWaWV3LmdldEluc3RhbmNlKCk7cmV0dXJuIGUuc3RhcnRXcml0aW5nKCksdGhpcy5lbmNvZGVJbnRvKEEsZSksZS50b0FycmF5KCl9LGVuY29kZUludG8oQSxlKXtjb25zdCBJPWUubGVuZ3RoLGc9ZS5yZXNlcnZlTWVzc2FnZUxlbmd0aCgpLHQ9ZS5sZW5ndGg7bnVsbCE9QS5yZWFzb24mJihlLndyaXRlQnl0ZSgxKSxlLndyaXRlU3RyaW5nKEEucmVhc29uKSksZS53cml0ZUJ5dGUoMCk7Y29uc3QgaT1lLmxlbmd0aDtyZXR1cm4gZS5maWxsTWVzc2FnZUxlbmd0aChnLGktdCksZS5sZW5ndGgtSX0sZGVjb2RlKEEpe2NvbnN0IGU9Zy5CZWJvcFZpZXcuZ2V0SW5zdGFuY2UoKTtyZXR1cm4gZS5zdGFydFJlYWRpbmcoQSksdGhpcy5yZWFkRnJvbShlKX0scmVhZEZyb20oQSl7bGV0IGU9e307Y29uc3QgST1BLnJlYWRNZXNzYWdlTGVuZ3RoKCksZz1BLmluZGV4K0k7Zm9yKDs7KXN3aXRjaChBLnJlYWRCeXRlKCkpe2Nhc2UgMDpyZXR1cm4gZTtjYXNlIDE6ZS5yZWFzb249QS5yZWFkU3RyaW5nKCk7YnJlYWs7ZGVmYXVsdDpyZXR1cm4gQS5pbmRleD1nLGV9fX0sZS5HZXRTdHJlYW1SZXF1ZXN0c19JbnZva2U9e2Rpc2NyaW1pbmF0b3I6MTQsZW5jb2RlKEEpe2NvbnN0IGU9Zy5CZWJvcFZpZXcuZ2V0SW5zdGFuY2UoKTtyZXR1cm4gZS5zdGFydFdyaXRpbmcoKSx0aGlzLmVuY29kZUludG8oQSxlKSxlLnRvQXJyYXkoKX0sZW5jb2RlSW50byhBLGUpe2NvbnN0IEk9ZS5sZW5ndGgsZz1lLnJlc2VydmVNZXNzYWdlTGVuZ3RoKCksdD1lLmxlbmd0aDtlLndyaXRlQnl0ZSgwKTtjb25zdCBpPWUubGVuZ3RoO3JldHVybiBlLmZpbGxNZXNzYWdlTGVuZ3RoKGcsaS10KSxlLmxlbmd0aC1JfSxkZWNvZGUoQSl7Y29uc3QgZT1nLkJlYm9wVmlldy5nZXRJbnN0YW5jZSgpO3JldHVybiBlLnN0YXJ0UmVhZGluZyhBKSx0aGlzLnJlYWRGcm9tKGUpfSxyZWFkRnJvbShBKXtsZXQgZT17fTtjb25zdCBJPUEucmVhZE1lc3NhZ2VMZW5ndGgoKSxnPUEuaW5kZXgrSTtmb3IoOzspcmV0dXJuIDA9PT1BLnJlYWRCeXRlKCl8fChBLmluZGV4PWcpLGV9fSxlLkNsZWFyU3RyZWFtUmVxdWVzdHNfSW52b2tlPXtkaXNjcmltaW5hdG9yOjE1LGVuY29kZShBKXtjb25zdCBlPWcuQmVib3BWaWV3LmdldEluc3RhbmNlKCk7cmV0dXJuIGUuc3RhcnRXcml0aW5nKCksdGhpcy5lbmNvZGVJbnRvKEEsZSksZS50b0FycmF5KCl9LGVuY29kZUludG8oQSxlKXtjb25zdCBJPWUubGVuZ3RoLGc9ZS5yZXNlcnZlTWVzc2FnZUxlbmd0aCgpLHQ9ZS5sZW5ndGg7ZS53cml0ZUJ5dGUoMCk7Y29uc3QgaT1lLmxlbmd0aDtyZXR1cm4gZS5maWxsTWVzc2FnZUxlbmd0aChnLGktdCksZS5sZW5ndGgtSX0sZGVjb2RlKEEpe2NvbnN0IGU9Zy5CZWJvcFZpZXcuZ2V0SW5zdGFuY2UoKTtyZXR1cm4gZS5zdGFydFJlYWRpbmcoQSksdGhpcy5yZWFkRnJvbShlKX0scmVhZEZyb20oQSl7bGV0IGU9e307Y29uc3QgST1BLnJlYWRNZXNzYWdlTGVuZ3RoKCksZz1BLmluZGV4K0k7Zm9yKDs7KXJldHVybiAwPT09QS5yZWFkQnl0ZSgpfHwoQS5pbmRleD1nKSxlfX0sZS5HZXRQZWVyU3RhdGVDaGFuZ2VzX0ludm9rZT17ZGlzY3JpbWluYXRvcjoxNixlbmNvZGUoQSl7Y29uc3QgZT1nLkJlYm9wVmlldy5nZXRJbnN0YW5jZSgpO3JldHVybiBlLnN0YXJ0V3JpdGluZygpLHRoaXMuZW5jb2RlSW50byhBLGUpLGUudG9BcnJheSgpfSxlbmNvZGVJbnRvKEEsZSl7Y29uc3QgST1lLmxlbmd0aCxnPWUucmVzZXJ2ZU1lc3NhZ2VMZW5ndGgoKSx0PWUubGVuZ3RoO2Uud3JpdGVCeXRlKDApO2NvbnN0IGk9ZS5sZW5ndGg7cmV0dXJuIGUuZmlsbE1lc3NhZ2VMZW5ndGgoZyxpLXQpLGUubGVuZ3RoLUl9LGRlY29kZShBKXtjb25zdCBlPWcuQmVib3BWaWV3LmdldEluc3RhbmNlKCk7cmV0dXJuIGUuc3RhcnRSZWFkaW5nKEEpLHRoaXMucmVhZEZyb20oZSl9LHJlYWRGcm9tKEEpe2xldCBlPXt9O2NvbnN0IEk9QS5yZWFkTWVzc2FnZUxlbmd0aCgpLGc9QS5pbmRleCtJO2Zvcig7OylyZXR1cm4gMD09PUEucmVhZEJ5dGUoKXx8KEEuaW5kZXg9ZyksZX19LGUuQ2xlYXJQZWVyU3RhdGVDaGFuZ2VzX0ludm9rZT17ZGlzY3JpbWluYXRvcjoxNyxlbmNvZGUoQSl7Y29uc3QgZT1nLkJlYm9wVmlldy5nZXRJbnN0YW5jZSgpO3JldHVybiBlLnN0YXJ0V3JpdGluZygpLHRoaXMuZW5jb2RlSW50byhBLGUpLGUudG9BcnJheSgpfSxlbmNvZGVJbnRvKEEsZSl7Y29uc3QgST1lLmxlbmd0aCxnPWUucmVzZXJ2ZU1lc3NhZ2VMZW5ndGgoKSx0PWUubGVuZ3RoO2Uud3JpdGVCeXRlKDApO2NvbnN0IGk9ZS5sZW5ndGg7cmV0dXJuIGUuZmlsbE1lc3NhZ2VMZW5ndGgoZyxpLXQpLGUubGVuZ3RoLUl9LGRlY29kZShBKXtjb25zdCBlPWcuQmVib3BWaWV3LmdldEluc3RhbmNlKCk7cmV0dXJuIGUuc3RhcnRSZWFkaW5nKEEpLHRoaXMucmVhZEZyb20oZSl9LHJlYWRGcm9tKEEpe2xldCBlPXt9O2NvbnN0IEk9QS5yZWFkTWVzc2FnZUxlbmd0aCgpLGc9QS5pbmRleCtJO2Zvcig7OylyZXR1cm4gMD09PUEucmVhZEJ5dGUoKXx8KEEuaW5kZXg9ZyksZX19LGUuR2V0UGVlck1lc3NhZ2VzX0ludm9rZT17ZGlzY3JpbWluYXRvcjoxOCxlbmNvZGUoQSl7Y29uc3QgZT1nLkJlYm9wVmlldy5nZXRJbnN0YW5jZSgpO3JldHVybiBlLnN0YXJ0V3JpdGluZygpLHRoaXMuZW5jb2RlSW50byhBLGUpLGUudG9BcnJheSgpfSxlbmNvZGVJbnRvKEEsZSl7Y29uc3QgST1lLmxlbmd0aCxnPWUucmVzZXJ2ZU1lc3NhZ2VMZW5ndGgoKSx0PWUubGVuZ3RoO2Uud3JpdGVCeXRlKDApO2NvbnN0IGk9ZS5sZW5ndGg7cmV0dXJuIGUuZmlsbE1lc3NhZ2VMZW5ndGgoZyxpLXQpLGUubGVuZ3RoLUl9LGRlY29kZShBKXtjb25zdCBlPWcuQmVib3BWaWV3LmdldEluc3RhbmNlKCk7cmV0dXJuIGUuc3RhcnRSZWFkaW5nKEEpLHRoaXMucmVhZEZyb20oZSl9LHJlYWRGcm9tKEEpe2xldCBlPXt9O2NvbnN0IEk9QS5yZWFkTWVzc2FnZUxlbmd0aCgpLGc9QS5pbmRleCtJO2Zvcig7OylyZXR1cm4gMD09PUEucmVhZEJ5dGUoKXx8KEEuaW5kZXg9ZyksZX19LGUuQ2xlYXJQZWVyTWVzc2FnZXNfSW52b2tlPXtkaXNjcmltaW5hdG9yOjE5LGVuY29kZShBKXtjb25zdCBlPWcuQmVib3BWaWV3LmdldEluc3RhbmNlKCk7cmV0dXJuIGUuc3RhcnRXcml0aW5nKCksdGhpcy5lbmNvZGVJbnRvKEEsZSksZS50b0FycmF5KCl9LGVuY29kZUludG8oQSxlKXtjb25zdCBJPWUubGVuZ3RoLGc9ZS5yZXNlcnZlTWVzc2FnZUxlbmd0aCgpLHQ9ZS5sZW5ndGg7ZS53cml0ZUJ5dGUoMCk7Y29uc3QgaT1lLmxlbmd0aDtyZXR1cm4gZS5maWxsTWVzc2FnZUxlbmd0aChnLGktdCksZS5sZW5ndGgtSX0sZGVjb2RlKEEpe2NvbnN0IGU9Zy5CZWJvcFZpZXcuZ2V0SW5zdGFuY2UoKTtyZXR1cm4gZS5zdGFydFJlYWRpbmcoQSksdGhpcy5yZWFkRnJvbShlKX0scmVhZEZyb20oQSl7bGV0IGU9e307Y29uc3QgST1BLnJlYWRNZXNzYWdlTGVuZ3RoKCksZz1BLmluZGV4K0k7Zm9yKDs7KXJldHVybiAwPT09QS5yZWFkQnl0ZSgpfHwoQS5pbmRleD1nKSxlfX0sZS5JbnZvY2F0aW9uPXtlbmNvZGUoQSl7Y29uc3QgZT1nLkJlYm9wVmlldy5nZXRJbnN0YW5jZSgpO3JldHVybiBlLnN0YXJ0V3JpdGluZygpLHRoaXMuZW5jb2RlSW50byhBLGUpLGUudG9BcnJheSgpfSxlbmNvZGVJbnRvKEEsSSl7Y29uc3QgZz1JLmxlbmd0aCx0PUkucmVzZXJ2ZU1lc3NhZ2VMZW5ndGgoKSxpPUkubGVuZ3RoKzE7c3dpdGNoKEkud3JpdGVCeXRlKEEuZGlzY3JpbWluYXRvciksQS5kaXNjcmltaW5hdG9yKXtjYXNlIDE6ZS5Jbml0aWFsaXplX0ludm9rZS5lbmNvZGVJbnRvKEEudmFsdWUsSSk7YnJlYWs7Y2FzZSAyOmUuU2h1dGRvd25fSW52b2tlLmVuY29kZUludG8oQS52YWx1ZSxJKTticmVhaztjYXNlIDM6ZS5HZXRWZXJzaW9uX0ludm9rZS5lbmNvZGVJbnRvKEEudmFsdWUsSSk7YnJlYWs7Y2FzZSA0OmUuR2V0UGVlcklkX0ludm9rZS5lbmNvZGVJbnRvKEEudmFsdWUsSSk7YnJlYWs7Y2FzZSA1OmUuU2V0TG9nTGV2ZWxfSW52b2tlLmVuY29kZUludG8oQS52YWx1ZSxJKTticmVhaztjYXNlIDY6ZS5HZXRMb2dzX0ludm9rZS5lbmNvZGVJbnRvKEEudmFsdWUsSSk7YnJlYWs7Y2FzZSA3OmUuQ2xlYXJMb2dzX0ludm9rZS5lbmNvZGVJbnRvKEEudmFsdWUsSSk7YnJlYWs7Y2FzZSA4OmUuQWNjZXB0Sm9pblJlcXVlc3RfSW52b2tlLmVuY29kZUludG8oQS52YWx1ZSxJKTticmVhaztjYXNlIDk6ZS5SZWplY3RKb2luUmVxdWVzdF9JbnZva2UuZW5jb2RlSW50byhBLnZhbHVlLEkpO2JyZWFrO2Nhc2UgMTA6ZS5HZXRKb2luUmVxdWVzdHNfSW52b2tlLmVuY29kZUludG8oQS52YWx1ZSxJKTticmVhaztjYXNlIDExOmUuQ2xlYXJKb2luUmVxdWVzdHNfSW52b2tlLmVuY29kZUludG8oQS52YWx1ZSxJKTticmVhaztjYXNlIDEyOmUuQWNjZXB0U3RyZWFtUmVxdWVzdF9JbnZva2UuZW5jb2RlSW50byhBLnZhbHVlLEkpO2JyZWFrO2Nhc2UgMTM6ZS5SZWplY3RTdHJlYW1SZXF1ZXN0X0ludm9rZS5lbmNvZGVJbnRvKEEudmFsdWUsSSk7YnJlYWs7Y2FzZSAxNDplLkdldFN0cmVhbVJlcXVlc3RzX0ludm9rZS5lbmNvZGVJbnRvKEEudmFsdWUsSSk7YnJlYWs7Y2FzZSAxNTplLkNsZWFyU3RyZWFtUmVxdWVzdHNfSW52b2tlLmVuY29kZUludG8oQS52YWx1ZSxJKTticmVhaztjYXNlIDE2OmUuR2V0UGVlclN0YXRlQ2hhbmdlc19JbnZva2UuZW5jb2RlSW50byhBLnZhbHVlLEkpO2JyZWFrO2Nhc2UgMTc6ZS5DbGVhclBlZXJTdGF0ZUNoYW5nZXNfSW52b2tlLmVuY29kZUludG8oQS52YWx1ZSxJKTticmVhaztjYXNlIDE4OmUuR2V0UGVlck1lc3NhZ2VzX0ludm9rZS5lbmNvZGVJbnRvKEEudmFsdWUsSSk7YnJlYWs7Y2FzZSAxOTplLkNsZWFyUGVlck1lc3NhZ2VzX0ludm9rZS5lbmNvZGVJbnRvKEEudmFsdWUsSSl9Y29uc3QgQj1JLmxlbmd0aDtyZXR1cm4gSS5maWxsTWVzc2FnZUxlbmd0aCh0LEItaSksSS5sZW5ndGgtZ30sZGVjb2RlKEEpe2NvbnN0IGU9Zy5CZWJvcFZpZXcuZ2V0SW5zdGFuY2UoKTtyZXR1cm4gZS5zdGFydFJlYWRpbmcoQSksdGhpcy5yZWFkRnJvbShlKX0scmVhZEZyb20oQSl7Y29uc3QgST1BLnJlYWRNZXNzYWdlTGVuZ3RoKCksdD1BLmluZGV4KzErSTtzd2l0Y2goQS5yZWFkQnl0ZSgpKXtjYXNlIDE6cmV0dXJue2Rpc2NyaW1pbmF0b3I6MSx2YWx1ZTplLkluaXRpYWxpemVfSW52b2tlLnJlYWRGcm9tKEEpfTtjYXNlIDI6cmV0dXJue2Rpc2NyaW1pbmF0b3I6Mix2YWx1ZTplLlNodXRkb3duX0ludm9rZS5yZWFkRnJvbShBKX07Y2FzZSAzOnJldHVybntkaXNjcmltaW5hdG9yOjMsdmFsdWU6ZS5HZXRWZXJzaW9uX0ludm9rZS5yZWFkRnJvbShBKX07Y2FzZSA0OnJldHVybntkaXNjcmltaW5hdG9yOjQsdmFsdWU6ZS5HZXRQZWVySWRfSW52b2tlLnJlYWRGcm9tKEEpfTtjYXNlIDU6cmV0dXJue2Rpc2NyaW1pbmF0b3I6NSx2YWx1ZTplLlNldExvZ0xldmVsX0ludm9rZS5yZWFkRnJvbShBKX07Y2FzZSA2OnJldHVybntkaXNjcmltaW5hdG9yOjYsdmFsdWU6ZS5HZXRMb2dzX0ludm9rZS5yZWFkRnJvbShBKX07Y2FzZSA3OnJldHVybntkaXNjcmltaW5hdG9yOjcsdmFsdWU6ZS5DbGVhckxvZ3NfSW52b2tlLnJlYWRGcm9tKEEpfTtjYXNlIDg6cmV0dXJue2Rpc2NyaW1pbmF0b3I6OCx2YWx1ZTplLkFjY2VwdEpvaW5SZXF1ZXN0X0ludm9rZS5yZWFkRnJvbShBKX07Y2FzZSA5OnJldHVybntkaXNjcmltaW5hdG9yOjksdmFsdWU6ZS5SZWplY3RKb2luUmVxdWVzdF9JbnZva2UucmVhZEZyb20oQSl9O2Nhc2UgMTA6cmV0dXJue2Rpc2NyaW1pbmF0b3I6MTAsdmFsdWU6ZS5HZXRKb2luUmVxdWVzdHNfSW52b2tlLnJlYWRGcm9tKEEpfTtjYXNlIDExOnJldHVybntkaXNjcmltaW5hdG9yOjExLHZhbHVlOmUuQ2xlYXJKb2luUmVxdWVzdHNfSW52b2tlLnJlYWRGcm9tKEEpfTtjYXNlIDEyOnJldHVybntkaXNjcmltaW5hdG9yOjEyLHZhbHVlOmUuQWNjZXB0U3RyZWFtUmVxdWVzdF9JbnZva2UucmVhZEZyb20oQSl9O2Nhc2UgMTM6cmV0dXJue2Rpc2NyaW1pbmF0b3I6MTMsdmFsdWU6ZS5SZWplY3RTdHJlYW1SZXF1ZXN0X0ludm9rZS5yZWFkRnJvbShBKX07Y2FzZSAxNDpyZXR1cm57ZGlzY3JpbWluYXRvcjoxNCx2YWx1ZTplLkdldFN0cmVhbVJlcXVlc3RzX0ludm9rZS5yZWFkRnJvbShBKX07Y2FzZSAxNTpyZXR1cm57ZGlzY3JpbWluYXRvcjoxNSx2YWx1ZTplLkNsZWFyU3RyZWFtUmVxdWVzdHNfSW52b2tlLnJlYWRGcm9tKEEpfTtjYXNlIDE2OnJldHVybntkaXNjcmltaW5hdG9yOjE2LHZhbHVlOmUuR2V0UGVlclN0YXRlQ2hhbmdlc19JbnZva2UucmVhZEZyb20oQSl9O2Nhc2UgMTc6cmV0dXJue2Rpc2NyaW1pbmF0b3I6MTcsdmFsdWU6ZS5DbGVhclBlZXJTdGF0ZUNoYW5nZXNfSW52b2tlLnJlYWRGcm9tKEEpfTtjYXNlIDE4OnJldHVybntkaXNjcmltaW5hdG9yOjE4LHZhbHVlOmUuR2V0UGVlck1lc3NhZ2VzX0ludm9rZS5yZWFkRnJvbShBKX07Y2FzZSAxOTpyZXR1cm57ZGlzY3JpbWluYXRvcjoxOSx2YWx1ZTplLkNsZWFyUGVlck1lc3NhZ2VzX0ludm9rZS5yZWFkRnJvbShBKX07ZGVmYXVsdDp0aHJvdyBBLmluZGV4PXQsbmV3IGcuQmVib3BSdW50aW1lRXJyb3IoXCJVbnJlY29nbml6ZWQgZGlzY3JpbWluYXRvciB3aGlsZSBkZWNvZGluZyBJbnZvY2F0aW9uXCIpfX19LGUuRXJyb3JfUmV0dXJuPXtkaXNjcmltaW5hdG9yOjEsZW5jb2RlKEEpe2NvbnN0IGU9Zy5CZWJvcFZpZXcuZ2V0SW5zdGFuY2UoKTtyZXR1cm4gZS5zdGFydFdyaXRpbmcoKSx0aGlzLmVuY29kZUludG8oQSxlKSxlLnRvQXJyYXkoKX0sZW5jb2RlSW50byhBLGUpe2NvbnN0IEk9ZS5sZW5ndGgsZz1lLnJlc2VydmVNZXNzYWdlTGVuZ3RoKCksdD1lLmxlbmd0aDtudWxsIT1BLmRhdGEmJihlLndyaXRlQnl0ZSgxKSxlLndyaXRlU3RyaW5nKEEuZGF0YSkpLG51bGwhPUEuc3RhY2smJihlLndyaXRlQnl0ZSgyKSxlLndyaXRlU3RyaW5nKEEuc3RhY2spKSxlLndyaXRlQnl0ZSgwKTtjb25zdCBpPWUubGVuZ3RoO3JldHVybiBlLmZpbGxNZXNzYWdlTGVuZ3RoKGcsaS10KSxlLmxlbmd0aC1JfSxkZWNvZGUoQSl7Y29uc3QgZT1nLkJlYm9wVmlldy5nZXRJbnN0YW5jZSgpO3JldHVybiBlLnN0YXJ0UmVhZGluZyhBKSx0aGlzLnJlYWRGcm9tKGUpfSxyZWFkRnJvbShBKXtsZXQgZT17fTtjb25zdCBJPUEucmVhZE1lc3NhZ2VMZW5ndGgoKSxnPUEuaW5kZXgrSTtmb3IoOzspc3dpdGNoKEEucmVhZEJ5dGUoKSl7Y2FzZSAwOnJldHVybiBlO2Nhc2UgMTplLmRhdGE9QS5yZWFkU3RyaW5nKCk7YnJlYWs7Y2FzZSAyOmUuc3RhY2s9QS5yZWFkU3RyaW5nKCk7YnJlYWs7ZGVmYXVsdDpyZXR1cm4gQS5pbmRleD1nLGV9fX0sZS5Jbml0aWFsaXplX1JldHVybj17ZGlzY3JpbWluYXRvcjoyLGVuY29kZShBKXtjb25zdCBlPWcuQmVib3BWaWV3LmdldEluc3RhbmNlKCk7cmV0dXJuIGUuc3RhcnRXcml0aW5nKCksdGhpcy5lbmNvZGVJbnRvKEEsZSksZS50b0FycmF5KCl9LGVuY29kZUludG8oQSxlKXtjb25zdCBJPWUubGVuZ3RoLGc9ZS5yZXNlcnZlTWVzc2FnZUxlbmd0aCgpLHQ9ZS5sZW5ndGg7bnVsbCE9QS5hbHJlYWR5SW5pdGlhbGl6ZWQmJihlLndyaXRlQnl0ZSgxKSxlLndyaXRlQnl0ZShOdW1iZXIoQS5hbHJlYWR5SW5pdGlhbGl6ZWQpKSksZS53cml0ZUJ5dGUoMCk7Y29uc3QgaT1lLmxlbmd0aDtyZXR1cm4gZS5maWxsTWVzc2FnZUxlbmd0aChnLGktdCksZS5sZW5ndGgtSX0sZGVjb2RlKEEpe2NvbnN0IGU9Zy5CZWJvcFZpZXcuZ2V0SW5zdGFuY2UoKTtyZXR1cm4gZS5zdGFydFJlYWRpbmcoQSksdGhpcy5yZWFkRnJvbShlKX0scmVhZEZyb20oQSl7bGV0IGU9e307Y29uc3QgST1BLnJlYWRNZXNzYWdlTGVuZ3RoKCksZz1BLmluZGV4K0k7Zm9yKDs7KXN3aXRjaChBLnJlYWRCeXRlKCkpe2Nhc2UgMDpyZXR1cm4gZTtjYXNlIDE6ZS5hbHJlYWR5SW5pdGlhbGl6ZWQ9ISFBLnJlYWRCeXRlKCk7YnJlYWs7ZGVmYXVsdDpyZXR1cm4gQS5pbmRleD1nLGV9fX0sZS5TaHV0ZG93bl9SZXR1cm49e2Rpc2NyaW1pbmF0b3I6MyxlbmNvZGUoQSl7Y29uc3QgZT1nLkJlYm9wVmlldy5nZXRJbnN0YW5jZSgpO3JldHVybiBlLnN0YXJ0V3JpdGluZygpLHRoaXMuZW5jb2RlSW50byhBLGUpLGUudG9BcnJheSgpfSxlbmNvZGVJbnRvKEEsZSl7Y29uc3QgST1lLmxlbmd0aCxnPWUucmVzZXJ2ZU1lc3NhZ2VMZW5ndGgoKSx0PWUubGVuZ3RoO2Uud3JpdGVCeXRlKDApO2NvbnN0IGk9ZS5sZW5ndGg7cmV0dXJuIGUuZmlsbE1lc3NhZ2VMZW5ndGgoZyxpLXQpLGUubGVuZ3RoLUl9LGRlY29kZShBKXtjb25zdCBlPWcuQmVib3BWaWV3LmdldEluc3RhbmNlKCk7cmV0dXJuIGUuc3RhcnRSZWFkaW5nKEEpLHRoaXMucmVhZEZyb20oZSl9LHJlYWRGcm9tKEEpe2xldCBlPXt9O2NvbnN0IEk9QS5yZWFkTWVzc2FnZUxlbmd0aCgpLGc9QS5pbmRleCtJO2Zvcig7OylyZXR1cm4gMD09PUEucmVhZEJ5dGUoKXx8KEEuaW5kZXg9ZyksZX19LGUuR2V0VmVyc2lvbl9SZXR1cm49e2Rpc2NyaW1pbmF0b3I6NCxlbmNvZGUoQSl7Y29uc3QgZT1nLkJlYm9wVmlldy5nZXRJbnN0YW5jZSgpO3JldHVybiBlLnN0YXJ0V3JpdGluZygpLHRoaXMuZW5jb2RlSW50byhBLGUpLGUudG9BcnJheSgpfSxlbmNvZGVJbnRvKEEsZSl7Y29uc3QgST1lLmxlbmd0aCxnPWUucmVzZXJ2ZU1lc3NhZ2VMZW5ndGgoKSx0PWUubGVuZ3RoO251bGwhPUEudmVyc2lvbiYmKGUud3JpdGVCeXRlKDEpLGUud3JpdGVTdHJpbmcoQS52ZXJzaW9uKSksZS53cml0ZUJ5dGUoMCk7Y29uc3QgaT1lLmxlbmd0aDtyZXR1cm4gZS5maWxsTWVzc2FnZUxlbmd0aChnLGktdCksZS5sZW5ndGgtSX0sZGVjb2RlKEEpe2NvbnN0IGU9Zy5CZWJvcFZpZXcuZ2V0SW5zdGFuY2UoKTtyZXR1cm4gZS5zdGFydFJlYWRpbmcoQSksdGhpcy5yZWFkRnJvbShlKX0scmVhZEZyb20oQSl7bGV0IGU9e307Y29uc3QgST1BLnJlYWRNZXNzYWdlTGVuZ3RoKCksZz1BLmluZGV4K0k7Zm9yKDs7KXN3aXRjaChBLnJlYWRCeXRlKCkpe2Nhc2UgMDpyZXR1cm4gZTtjYXNlIDE6ZS52ZXJzaW9uPUEucmVhZFN0cmluZygpO2JyZWFrO2RlZmF1bHQ6cmV0dXJuIEEuaW5kZXg9ZyxlfX19LGUuR2V0UGVlcklkX1JldHVybj17ZGlzY3JpbWluYXRvcjo1LGVuY29kZShBKXtjb25zdCBlPWcuQmVib3BWaWV3LmdldEluc3RhbmNlKCk7cmV0dXJuIGUuc3RhcnRXcml0aW5nKCksdGhpcy5lbmNvZGVJbnRvKEEsZSksZS50b0FycmF5KCl9LGVuY29kZUludG8oQSxlKXtjb25zdCBJPWUubGVuZ3RoLGc9ZS5yZXNlcnZlTWVzc2FnZUxlbmd0aCgpLHQ9ZS5sZW5ndGg7bnVsbCE9QS5wZWVySWQmJihlLndyaXRlQnl0ZSgxKSxlLndyaXRlU3RyaW5nKEEucGVlcklkKSksZS53cml0ZUJ5dGUoMCk7Y29uc3QgaT1lLmxlbmd0aDtyZXR1cm4gZS5maWxsTWVzc2FnZUxlbmd0aChnLGktdCksZS5sZW5ndGgtSX0sZGVjb2RlKEEpe2NvbnN0IGU9Zy5CZWJvcFZpZXcuZ2V0SW5zdGFuY2UoKTtyZXR1cm4gZS5zdGFydFJlYWRpbmcoQSksdGhpcy5yZWFkRnJvbShlKX0scmVhZEZyb20oQSl7bGV0IGU9e307Y29uc3QgST1BLnJlYWRNZXNzYWdlTGVuZ3RoKCksZz1BLmluZGV4K0k7Zm9yKDs7KXN3aXRjaChBLnJlYWRCeXRlKCkpe2Nhc2UgMDpyZXR1cm4gZTtjYXNlIDE6ZS5wZWVySWQ9QS5yZWFkU3RyaW5nKCk7YnJlYWs7ZGVmYXVsdDpyZXR1cm4gQS5pbmRleD1nLGV9fX0sZS5TZXRMb2dMZXZlbF9SZXR1cm49e2Rpc2NyaW1pbmF0b3I6NixlbmNvZGUoQSl7Y29uc3QgZT1nLkJlYm9wVmlldy5nZXRJbnN0YW5jZSgpO3JldHVybiBlLnN0YXJ0V3JpdGluZygpLHRoaXMuZW5jb2RlSW50byhBLGUpLGUudG9BcnJheSgpfSxlbmNvZGVJbnRvKEEsZSl7Y29uc3QgST1lLmxlbmd0aCxnPWUucmVzZXJ2ZU1lc3NhZ2VMZW5ndGgoKSx0PWUubGVuZ3RoO2Uud3JpdGVCeXRlKDApO2NvbnN0IGk9ZS5sZW5ndGg7cmV0dXJuIGUuZmlsbE1lc3NhZ2VMZW5ndGgoZyxpLXQpLGUubGVuZ3RoLUl9LGRlY29kZShBKXtjb25zdCBlPWcuQmVib3BWaWV3LmdldEluc3RhbmNlKCk7cmV0dXJuIGUuc3RhcnRSZWFkaW5nKEEpLHRoaXMucmVhZEZyb20oZSl9LHJlYWRGcm9tKEEpe2xldCBlPXt9O2NvbnN0IEk9QS5yZWFkTWVzc2FnZUxlbmd0aCgpLGc9QS5pbmRleCtJO2Zvcig7OylyZXR1cm4gMD09PUEucmVhZEJ5dGUoKXx8KEEuaW5kZXg9ZyksZX19LGUuR2V0TG9nc19SZXR1cm49e2Rpc2NyaW1pbmF0b3I6NyxlbmNvZGUoQSl7Y29uc3QgZT1nLkJlYm9wVmlldy5nZXRJbnN0YW5jZSgpO3JldHVybiBlLnN0YXJ0V3JpdGluZygpLHRoaXMuZW5jb2RlSW50byhBLGUpLGUudG9BcnJheSgpfSxlbmNvZGVJbnRvKEEsSSl7Y29uc3QgZz1JLmxlbmd0aCx0PUkucmVzZXJ2ZU1lc3NhZ2VMZW5ndGgoKSxpPUkubGVuZ3RoO2lmKG51bGwhPUEuZGF0YSl7SS53cml0ZUJ5dGUoMSk7e2NvbnN0IGc9QS5kYXRhLmxlbmd0aDtJLndyaXRlVWludDMyKGcpO2ZvcihsZXQgdD0wO3Q8Zzt0KyspZS5Mb2dFbnRyeS5lbmNvZGVJbnRvKEEuZGF0YVt0XSxJKX19SS53cml0ZUJ5dGUoMCk7Y29uc3QgQj1JLmxlbmd0aDtyZXR1cm4gSS5maWxsTWVzc2FnZUxlbmd0aCh0LEItaSksSS5sZW5ndGgtZ30sZGVjb2RlKEEpe2NvbnN0IGU9Zy5CZWJvcFZpZXcuZ2V0SW5zdGFuY2UoKTtyZXR1cm4gZS5zdGFydFJlYWRpbmcoQSksdGhpcy5yZWFkRnJvbShlKX0scmVhZEZyb20oQSl7bGV0IEk9e307Y29uc3QgZz1BLnJlYWRNZXNzYWdlTGVuZ3RoKCksdD1BLmluZGV4K2c7Zm9yKDs7KXN3aXRjaChBLnJlYWRCeXRlKCkpe2Nhc2UgMDpyZXR1cm4gSTtjYXNlIDE6e2xldCBnPUEucmVhZFVpbnQzMigpO0kuZGF0YT1uZXcgQXJyYXkoZyk7Zm9yKGxldCB0PTA7dDxnO3QrKyl7bGV0IGc7Zz1lLkxvZ0VudHJ5LnJlYWRGcm9tKEEpLEkuZGF0YVt0XT1nfX1icmVhaztkZWZhdWx0OnJldHVybiBBLmluZGV4PXQsSX19fSxlLkNsZWFyTG9nc19SZXR1cm49e2Rpc2NyaW1pbmF0b3I6OCxlbmNvZGUoQSl7Y29uc3QgZT1nLkJlYm9wVmlldy5nZXRJbnN0YW5jZSgpO3JldHVybiBlLnN0YXJ0V3JpdGluZygpLHRoaXMuZW5jb2RlSW50byhBLGUpLGUudG9BcnJheSgpfSxlbmNvZGVJbnRvKEEsZSl7Y29uc3QgST1lLmxlbmd0aCxnPWUucmVzZXJ2ZU1lc3NhZ2VMZW5ndGgoKSx0PWUubGVuZ3RoO2Uud3JpdGVCeXRlKDApO2NvbnN0IGk9ZS5sZW5ndGg7cmV0dXJuIGUuZmlsbE1lc3NhZ2VMZW5ndGgoZyxpLXQpLGUubGVuZ3RoLUl9LGRlY29kZShBKXtjb25zdCBlPWcuQmVib3BWaWV3LmdldEluc3RhbmNlKCk7cmV0dXJuIGUuc3RhcnRSZWFkaW5nKEEpLHRoaXMucmVhZEZyb20oZSl9LHJlYWRGcm9tKEEpe2xldCBlPXt9O2NvbnN0IEk9QS5yZWFkTWVzc2FnZUxlbmd0aCgpLGc9QS5pbmRleCtJO2Zvcig7OylyZXR1cm4gMD09PUEucmVhZEJ5dGUoKXx8KEEuaW5kZXg9ZyksZX19LGUuQWNjZXB0Sm9pblJlcXVlc3RfUmV0dXJuPXtkaXNjcmltaW5hdG9yOjksZW5jb2RlKEEpe2NvbnN0IGU9Zy5CZWJvcFZpZXcuZ2V0SW5zdGFuY2UoKTtyZXR1cm4gZS5zdGFydFdyaXRpbmcoKSx0aGlzLmVuY29kZUludG8oQSxlKSxlLnRvQXJyYXkoKX0sZW5jb2RlSW50byhBLGUpe2NvbnN0IEk9ZS5sZW5ndGgsZz1lLnJlc2VydmVNZXNzYWdlTGVuZ3RoKCksdD1lLmxlbmd0aDtlLndyaXRlQnl0ZSgwKTtjb25zdCBpPWUubGVuZ3RoO3JldHVybiBlLmZpbGxNZXNzYWdlTGVuZ3RoKGcsaS10KSxlLmxlbmd0aC1JfSxkZWNvZGUoQSl7Y29uc3QgZT1nLkJlYm9wVmlldy5nZXRJbnN0YW5jZSgpO3JldHVybiBlLnN0YXJ0UmVhZGluZyhBKSx0aGlzLnJlYWRGcm9tKGUpfSxyZWFkRnJvbShBKXtsZXQgZT17fTtjb25zdCBJPUEucmVhZE1lc3NhZ2VMZW5ndGgoKSxnPUEuaW5kZXgrSTtmb3IoOzspcmV0dXJuIDA9PT1BLnJlYWRCeXRlKCl8fChBLmluZGV4PWcpLGV9fSxlLlJlamVjdEpvaW5SZXF1ZXN0X1JldHVybj17ZGlzY3JpbWluYXRvcjoxMCxlbmNvZGUoQSl7Y29uc3QgZT1nLkJlYm9wVmlldy5nZXRJbnN0YW5jZSgpO3JldHVybiBlLnN0YXJ0V3JpdGluZygpLHRoaXMuZW5jb2RlSW50byhBLGUpLGUudG9BcnJheSgpfSxlbmNvZGVJbnRvKEEsZSl7Y29uc3QgST1lLmxlbmd0aCxnPWUucmVzZXJ2ZU1lc3NhZ2VMZW5ndGgoKSx0PWUubGVuZ3RoO2Uud3JpdGVCeXRlKDApO2NvbnN0IGk9ZS5sZW5ndGg7cmV0dXJuIGUuZmlsbE1lc3NhZ2VMZW5ndGgoZyxpLXQpLGUubGVuZ3RoLUl9LGRlY29kZShBKXtjb25zdCBlPWcuQmVib3BWaWV3LmdldEluc3RhbmNlKCk7cmV0dXJuIGUuc3RhcnRSZWFkaW5nKEEpLHRoaXMucmVhZEZyb20oZSl9LHJlYWRGcm9tKEEpe2xldCBlPXt9O2NvbnN0IEk9QS5yZWFkTWVzc2FnZUxlbmd0aCgpLGc9QS5pbmRleCtJO2Zvcig7OylyZXR1cm4gMD09PUEucmVhZEJ5dGUoKXx8KEEuaW5kZXg9ZyksZX19LGUuR2V0Sm9pblJlcXVlc3RzX1JldHVybj17ZGlzY3JpbWluYXRvcjoxMSxlbmNvZGUoQSl7Y29uc3QgZT1nLkJlYm9wVmlldy5nZXRJbnN0YW5jZSgpO3JldHVybiBlLnN0YXJ0V3JpdGluZygpLHRoaXMuZW5jb2RlSW50byhBLGUpLGUudG9BcnJheSgpfSxlbmNvZGVJbnRvKEEsSSl7Y29uc3QgZz1JLmxlbmd0aCx0PUkucmVzZXJ2ZU1lc3NhZ2VMZW5ndGgoKSxpPUkubGVuZ3RoO2lmKG51bGwhPUEucmVxdWVzdHMpe0kud3JpdGVCeXRlKDEpO3tjb25zdCBnPUEucmVxdWVzdHMubGVuZ3RoO0kud3JpdGVVaW50MzIoZyk7Zm9yKGxldCB0PTA7dDxnO3QrKyllLkpvaW5SZXF1ZXN0T3BlcmF0aW9uLmVuY29kZUludG8oQS5yZXF1ZXN0c1t0XSxJKX19SS53cml0ZUJ5dGUoMCk7Y29uc3QgQj1JLmxlbmd0aDtyZXR1cm4gSS5maWxsTWVzc2FnZUxlbmd0aCh0LEItaSksSS5sZW5ndGgtZ30sZGVjb2RlKEEpe2NvbnN0IGU9Zy5CZWJvcFZpZXcuZ2V0SW5zdGFuY2UoKTtyZXR1cm4gZS5zdGFydFJlYWRpbmcoQSksdGhpcy5yZWFkRnJvbShlKX0scmVhZEZyb20oQSl7bGV0IEk9e307Y29uc3QgZz1BLnJlYWRNZXNzYWdlTGVuZ3RoKCksdD1BLmluZGV4K2c7Zm9yKDs7KXN3aXRjaChBLnJlYWRCeXRlKCkpe2Nhc2UgMDpyZXR1cm4gSTtjYXNlIDE6e2xldCBnPUEucmVhZFVpbnQzMigpO0kucmVxdWVzdHM9bmV3IEFycmF5KGcpO2ZvcihsZXQgdD0wO3Q8Zzt0Kyspe2xldCBnO2c9ZS5Kb2luUmVxdWVzdE9wZXJhdGlvbi5yZWFkRnJvbShBKSxJLnJlcXVlc3RzW3RdPWd9fWJyZWFrO2RlZmF1bHQ6cmV0dXJuIEEuaW5kZXg9dCxJfX19LGUuQ2xlYXJKb2luUmVxdWVzdHNfUmV0dXJuPXtkaXNjcmltaW5hdG9yOjEyLGVuY29kZShBKXtjb25zdCBlPWcuQmVib3BWaWV3LmdldEluc3RhbmNlKCk7cmV0dXJuIGUuc3RhcnRXcml0aW5nKCksdGhpcy5lbmNvZGVJbnRvKEEsZSksZS50b0FycmF5KCl9LGVuY29kZUludG8oQSxlKXtjb25zdCBJPWUubGVuZ3RoLGc9ZS5yZXNlcnZlTWVzc2FnZUxlbmd0aCgpLHQ9ZS5sZW5ndGg7ZS53cml0ZUJ5dGUoMCk7Y29uc3QgaT1lLmxlbmd0aDtyZXR1cm4gZS5maWxsTWVzc2FnZUxlbmd0aChnLGktdCksZS5sZW5ndGgtSX0sZGVjb2RlKEEpe2NvbnN0IGU9Zy5CZWJvcFZpZXcuZ2V0SW5zdGFuY2UoKTtyZXR1cm4gZS5zdGFydFJlYWRpbmcoQSksdGhpcy5yZWFkRnJvbShlKX0scmVhZEZyb20oQSl7bGV0IGU9e307Y29uc3QgST1BLnJlYWRNZXNzYWdlTGVuZ3RoKCksZz1BLmluZGV4K0k7Zm9yKDs7KXJldHVybiAwPT09QS5yZWFkQnl0ZSgpfHwoQS5pbmRleD1nKSxlfX0sZS5BY2NlcHRTdHJlYW1SZXF1ZXN0X1JldHVybj17ZGlzY3JpbWluYXRvcjoxMyxlbmNvZGUoQSl7Y29uc3QgZT1nLkJlYm9wVmlldy5nZXRJbnN0YW5jZSgpO3JldHVybiBlLnN0YXJ0V3JpdGluZygpLHRoaXMuZW5jb2RlSW50byhBLGUpLGUudG9BcnJheSgpfSxlbmNvZGVJbnRvKEEsZSl7Y29uc3QgST1lLmxlbmd0aCxnPWUucmVzZXJ2ZU1lc3NhZ2VMZW5ndGgoKSx0PWUubGVuZ3RoO2Uud3JpdGVCeXRlKDApO2NvbnN0IGk9ZS5sZW5ndGg7cmV0dXJuIGUuZmlsbE1lc3NhZ2VMZW5ndGgoZyxpLXQpLGUubGVuZ3RoLUl9LGRlY29kZShBKXtjb25zdCBlPWcuQmVib3BWaWV3LmdldEluc3RhbmNlKCk7cmV0dXJuIGUuc3RhcnRSZWFkaW5nKEEpLHRoaXMucmVhZEZyb20oZSl9LHJlYWRGcm9tKEEpe2xldCBlPXt9O2NvbnN0IEk9QS5yZWFkTWVzc2FnZUxlbmd0aCgpLGc9QS5pbmRleCtJO2Zvcig7OylyZXR1cm4gMD09PUEucmVhZEJ5dGUoKXx8KEEuaW5kZXg9ZyksZX19LGUuUmVqZWN0U3RyZWFtUmVxdWVzdF9SZXR1cm49e2Rpc2NyaW1pbmF0b3I6MTQsZW5jb2RlKEEpe2NvbnN0IGU9Zy5CZWJvcFZpZXcuZ2V0SW5zdGFuY2UoKTtyZXR1cm4gZS5zdGFydFdyaXRpbmcoKSx0aGlzLmVuY29kZUludG8oQSxlKSxlLnRvQXJyYXkoKX0sZW5jb2RlSW50byhBLGUpe2NvbnN0IEk9ZS5sZW5ndGgsZz1lLnJlc2VydmVNZXNzYWdlTGVuZ3RoKCksdD1lLmxlbmd0aDtlLndyaXRlQnl0ZSgwKTtjb25zdCBpPWUubGVuZ3RoO3JldHVybiBlLmZpbGxNZXNzYWdlTGVuZ3RoKGcsaS10KSxlLmxlbmd0aC1JfSxkZWNvZGUoQSl7Y29uc3QgZT1nLkJlYm9wVmlldy5nZXRJbnN0YW5jZSgpO3JldHVybiBlLnN0YXJ0UmVhZGluZyhBKSx0aGlzLnJlYWRGcm9tKGUpfSxyZWFkRnJvbShBKXtsZXQgZT17fTtjb25zdCBJPUEucmVhZE1lc3NhZ2VMZW5ndGgoKSxnPUEuaW5kZXgrSTtmb3IoOzspcmV0dXJuIDA9PT1BLnJlYWRCeXRlKCl8fChBLmluZGV4PWcpLGV9fSxlLkdldFN0cmVhbVJlcXVlc3RzX1JldHVybj17ZGlzY3JpbWluYXRvcjoxNSxlbmNvZGUoQSl7Y29uc3QgZT1nLkJlYm9wVmlldy5nZXRJbnN0YW5jZSgpO3JldHVybiBlLnN0YXJ0V3JpdGluZygpLHRoaXMuZW5jb2RlSW50byhBLGUpLGUudG9BcnJheSgpfSxlbmNvZGVJbnRvKEEsSSl7Y29uc3QgZz1JLmxlbmd0aCx0PUkucmVzZXJ2ZU1lc3NhZ2VMZW5ndGgoKSxpPUkubGVuZ3RoO2lmKG51bGwhPUEucmVxdWVzdHMpe0kud3JpdGVCeXRlKDEpO3tjb25zdCBnPUEucmVxdWVzdHMubGVuZ3RoO0kud3JpdGVVaW50MzIoZyk7Zm9yKGxldCB0PTA7dDxnO3QrKyllLlN0cmVhbVJlcXVlc3RPcGVyYXRpb24uZW5jb2RlSW50byhBLnJlcXVlc3RzW3RdLEkpfX1JLndyaXRlQnl0ZSgwKTtjb25zdCBCPUkubGVuZ3RoO3JldHVybiBJLmZpbGxNZXNzYWdlTGVuZ3RoKHQsQi1pKSxJLmxlbmd0aC1nfSxkZWNvZGUoQSl7Y29uc3QgZT1nLkJlYm9wVmlldy5nZXRJbnN0YW5jZSgpO3JldHVybiBlLnN0YXJ0UmVhZGluZyhBKSx0aGlzLnJlYWRGcm9tKGUpfSxyZWFkRnJvbShBKXtsZXQgST17fTtjb25zdCBnPUEucmVhZE1lc3NhZ2VMZW5ndGgoKSx0PUEuaW5kZXgrZztmb3IoOzspc3dpdGNoKEEucmVhZEJ5dGUoKSl7Y2FzZSAwOnJldHVybiBJO2Nhc2UgMTp7bGV0IGc9QS5yZWFkVWludDMyKCk7SS5yZXF1ZXN0cz1uZXcgQXJyYXkoZyk7Zm9yKGxldCB0PTA7dDxnO3QrKyl7bGV0IGc7Zz1lLlN0cmVhbVJlcXVlc3RPcGVyYXRpb24ucmVhZEZyb20oQSksSS5yZXF1ZXN0c1t0XT1nfX1icmVhaztkZWZhdWx0OnJldHVybiBBLmluZGV4PXQsSX19fSxlLkNsZWFyU3RyZWFtUmVxdWVzdHNfUmV0dXJuPXtkaXNjcmltaW5hdG9yOjE2LGVuY29kZShBKXtjb25zdCBlPWcuQmVib3BWaWV3LmdldEluc3RhbmNlKCk7cmV0dXJuIGUuc3RhcnRXcml0aW5nKCksdGhpcy5lbmNvZGVJbnRvKEEsZSksZS50b0FycmF5KCl9LGVuY29kZUludG8oQSxlKXtjb25zdCBJPWUubGVuZ3RoLGc9ZS5yZXNlcnZlTWVzc2FnZUxlbmd0aCgpLHQ9ZS5sZW5ndGg7ZS53cml0ZUJ5dGUoMCk7Y29uc3QgaT1lLmxlbmd0aDtyZXR1cm4gZS5maWxsTWVzc2FnZUxlbmd0aChnLGktdCksZS5sZW5ndGgtSX0sZGVjb2RlKEEpe2NvbnN0IGU9Zy5CZWJvcFZpZXcuZ2V0SW5zdGFuY2UoKTtyZXR1cm4gZS5zdGFydFJlYWRpbmcoQSksdGhpcy5yZWFkRnJvbShlKX0scmVhZEZyb20oQSl7bGV0IGU9e307Y29uc3QgST1BLnJlYWRNZXNzYWdlTGVuZ3RoKCksZz1BLmluZGV4K0k7Zm9yKDs7KXJldHVybiAwPT09QS5yZWFkQnl0ZSgpfHwoQS5pbmRleD1nKSxlfX0sZS5HZXRQZWVyU3RhdGVDaGFuZ2VzX1JldHVybj17ZGlzY3JpbWluYXRvcjoxNyxlbmNvZGUoQSl7Y29uc3QgZT1nLkJlYm9wVmlldy5nZXRJbnN0YW5jZSgpO3JldHVybiBlLnN0YXJ0V3JpdGluZygpLHRoaXMuZW5jb2RlSW50byhBLGUpLGUudG9BcnJheSgpfSxlbmNvZGVJbnRvKEEsSSl7Y29uc3QgZz1JLmxlbmd0aCx0PUkucmVzZXJ2ZU1lc3NhZ2VMZW5ndGgoKSxpPUkubGVuZ3RoO2lmKG51bGwhPUEuY2hhbmdlcyl7SS53cml0ZUJ5dGUoMSk7e2NvbnN0IGc9QS5jaGFuZ2VzLmxlbmd0aDtJLndyaXRlVWludDMyKGcpO2ZvcihsZXQgdD0wO3Q8Zzt0KyspZS5QZWVyU3RhdGVDaGFuZ2UuZW5jb2RlSW50byhBLmNoYW5nZXNbdF0sSSl9fUkud3JpdGVCeXRlKDApO2NvbnN0IEI9SS5sZW5ndGg7cmV0dXJuIEkuZmlsbE1lc3NhZ2VMZW5ndGgodCxCLWkpLEkubGVuZ3RoLWd9LGRlY29kZShBKXtjb25zdCBlPWcuQmVib3BWaWV3LmdldEluc3RhbmNlKCk7cmV0dXJuIGUuc3RhcnRSZWFkaW5nKEEpLHRoaXMucmVhZEZyb20oZSl9LHJlYWRGcm9tKEEpe2xldCBJPXt9O2NvbnN0IGc9QS5yZWFkTWVzc2FnZUxlbmd0aCgpLHQ9QS5pbmRleCtnO2Zvcig7Oylzd2l0Y2goQS5yZWFkQnl0ZSgpKXtjYXNlIDA6cmV0dXJuIEk7Y2FzZSAxOntsZXQgZz1BLnJlYWRVaW50MzIoKTtJLmNoYW5nZXM9bmV3IEFycmF5KGcpO2ZvcihsZXQgdD0wO3Q8Zzt0Kyspe2xldCBnO2c9ZS5QZWVyU3RhdGVDaGFuZ2UucmVhZEZyb20oQSksSS5jaGFuZ2VzW3RdPWd9fWJyZWFrO2RlZmF1bHQ6cmV0dXJuIEEuaW5kZXg9dCxJfX19LGUuQ2xlYXJQZWVyU3RhdGVDaGFuZ2VzX1JldHVybj17ZGlzY3JpbWluYXRvcjoxOCxlbmNvZGUoQSl7Y29uc3QgZT1nLkJlYm9wVmlldy5nZXRJbnN0YW5jZSgpO3JldHVybiBlLnN0YXJ0V3JpdGluZygpLHRoaXMuZW5jb2RlSW50byhBLGUpLGUudG9BcnJheSgpfSxlbmNvZGVJbnRvKEEsZSl7Y29uc3QgST1lLmxlbmd0aCxnPWUucmVzZXJ2ZU1lc3NhZ2VMZW5ndGgoKSx0PWUubGVuZ3RoO2Uud3JpdGVCeXRlKDApO2NvbnN0IGk9ZS5sZW5ndGg7cmV0dXJuIGUuZmlsbE1lc3NhZ2VMZW5ndGgoZyxpLXQpLGUubGVuZ3RoLUl9LGRlY29kZShBKXtjb25zdCBlPWcuQmVib3BWaWV3LmdldEluc3RhbmNlKCk7cmV0dXJuIGUuc3RhcnRSZWFkaW5nKEEpLHRoaXMucmVhZEZyb20oZSl9LHJlYWRGcm9tKEEpe2xldCBlPXt9O2NvbnN0IEk9QS5yZWFkTWVzc2FnZUxlbmd0aCgpLGc9QS5pbmRleCtJO2Zvcig7OylyZXR1cm4gMD09PUEucmVhZEJ5dGUoKXx8KEEuaW5kZXg9ZyksZX19LGUuR2V0UGVlck1lc3NhZ2VzX1JldHVybj17ZGlzY3JpbWluYXRvcjoxOSxlbmNvZGUoQSl7Y29uc3QgZT1nLkJlYm9wVmlldy5nZXRJbnN0YW5jZSgpO3JldHVybiBlLnN0YXJ0V3JpdGluZygpLHRoaXMuZW5jb2RlSW50byhBLGUpLGUudG9BcnJheSgpfSxlbmNvZGVJbnRvKEEsSSl7Y29uc3QgZz1JLmxlbmd0aCx0PUkucmVzZXJ2ZU1lc3NhZ2VMZW5ndGgoKSxpPUkubGVuZ3RoO2lmKG51bGwhPUEubWVzc2FnZXMpe0kud3JpdGVCeXRlKDEpO3tjb25zdCBnPUEubWVzc2FnZXMubGVuZ3RoO0kud3JpdGVVaW50MzIoZyk7Zm9yKGxldCB0PTA7dDxnO3QrKyllLlBlZXJNZXNzYWdlLmVuY29kZUludG8oQS5tZXNzYWdlc1t0XSxJKX19SS53cml0ZUJ5dGUoMCk7Y29uc3QgQj1JLmxlbmd0aDtyZXR1cm4gSS5maWxsTWVzc2FnZUxlbmd0aCh0LEItaSksSS5sZW5ndGgtZ30sZGVjb2RlKEEpe2NvbnN0IGU9Zy5CZWJvcFZpZXcuZ2V0SW5zdGFuY2UoKTtyZXR1cm4gZS5zdGFydFJlYWRpbmcoQSksdGhpcy5yZWFkRnJvbShlKX0scmVhZEZyb20oQSl7bGV0IEk9e307Y29uc3QgZz1BLnJlYWRNZXNzYWdlTGVuZ3RoKCksdD1BLmluZGV4K2c7Zm9yKDs7KXN3aXRjaChBLnJlYWRCeXRlKCkpe2Nhc2UgMDpyZXR1cm4gSTtjYXNlIDE6e2xldCBnPUEucmVhZFVpbnQzMigpO0kubWVzc2FnZXM9bmV3IEFycmF5KGcpO2ZvcihsZXQgdD0wO3Q8Zzt0Kyspe2xldCBnO2c9ZS5QZWVyTWVzc2FnZS5yZWFkRnJvbShBKSxJLm1lc3NhZ2VzW3RdPWd9fWJyZWFrO2RlZmF1bHQ6cmV0dXJuIEEuaW5kZXg9dCxJfX19LGUuQ2xlYXJQZWVyTWVzc2FnZXNfUmV0dXJuPXtkaXNjcmltaW5hdG9yOjIwLGVuY29kZShBKXtjb25zdCBlPWcuQmVib3BWaWV3LmdldEluc3RhbmNlKCk7cmV0dXJuIGUuc3RhcnRXcml0aW5nKCksdGhpcy5lbmNvZGVJbnRvKEEsZSksZS50b0FycmF5KCl9LGVuY29kZUludG8oQSxlKXtjb25zdCBJPWUubGVuZ3RoLGc9ZS5yZXNlcnZlTWVzc2FnZUxlbmd0aCgpLHQ9ZS5sZW5ndGg7ZS53cml0ZUJ5dGUoMCk7Y29uc3QgaT1lLmxlbmd0aDtyZXR1cm4gZS5maWxsTWVzc2FnZUxlbmd0aChnLGktdCksZS5sZW5ndGgtSX0sZGVjb2RlKEEpe2NvbnN0IGU9Zy5CZWJvcFZpZXcuZ2V0SW5zdGFuY2UoKTtyZXR1cm4gZS5zdGFydFJlYWRpbmcoQSksdGhpcy5yZWFkRnJvbShlKX0scmVhZEZyb20oQSl7bGV0IGU9e307Y29uc3QgST1BLnJlYWRNZXNzYWdlTGVuZ3RoKCksZz1BLmluZGV4K0k7Zm9yKDs7KXJldHVybiAwPT09QS5yZWFkQnl0ZSgpfHwoQS5pbmRleD1nKSxlfX0sZS5SZXR1cm49e2VuY29kZShBKXtjb25zdCBlPWcuQmVib3BWaWV3LmdldEluc3RhbmNlKCk7cmV0dXJuIGUuc3RhcnRXcml0aW5nKCksdGhpcy5lbmNvZGVJbnRvKEEsZSksZS50b0FycmF5KCl9LGVuY29kZUludG8oQSxJKXtjb25zdCBnPUkubGVuZ3RoLHQ9SS5yZXNlcnZlTWVzc2FnZUxlbmd0aCgpLGk9SS5sZW5ndGgrMTtzd2l0Y2goSS53cml0ZUJ5dGUoQS5kaXNjcmltaW5hdG9yKSxBLmRpc2NyaW1pbmF0b3Ipe2Nhc2UgMTplLkVycm9yX1JldHVybi5lbmNvZGVJbnRvKEEudmFsdWUsSSk7YnJlYWs7Y2FzZSAyOmUuSW5pdGlhbGl6ZV9SZXR1cm4uZW5jb2RlSW50byhBLnZhbHVlLEkpO2JyZWFrO2Nhc2UgMzplLlNodXRkb3duX1JldHVybi5lbmNvZGVJbnRvKEEudmFsdWUsSSk7YnJlYWs7Y2FzZSA0OmUuR2V0VmVyc2lvbl9SZXR1cm4uZW5jb2RlSW50byhBLnZhbHVlLEkpO2JyZWFrO2Nhc2UgNTplLkdldFBlZXJJZF9SZXR1cm4uZW5jb2RlSW50byhBLnZhbHVlLEkpO2JyZWFrO2Nhc2UgNjplLlNldExvZ0xldmVsX1JldHVybi5lbmNvZGVJbnRvKEEudmFsdWUsSSk7YnJlYWs7Y2FzZSA3OmUuR2V0TG9nc19SZXR1cm4uZW5jb2RlSW50byhBLnZhbHVlLEkpO2JyZWFrO2Nhc2UgODplLkNsZWFyTG9nc19SZXR1cm4uZW5jb2RlSW50byhBLnZhbHVlLEkpO2JyZWFrO2Nhc2UgOTplLkFjY2VwdEpvaW5SZXF1ZXN0X1JldHVybi5lbmNvZGVJbnRvKEEudmFsdWUsSSk7YnJlYWs7Y2FzZSAxMDplLlJlamVjdEpvaW5SZXF1ZXN0X1JldHVybi5lbmNvZGVJbnRvKEEudmFsdWUsSSk7YnJlYWs7Y2FzZSAxMTplLkdldEpvaW5SZXF1ZXN0c19SZXR1cm4uZW5jb2RlSW50byhBLnZhbHVlLEkpO2JyZWFrO2Nhc2UgMTI6ZS5DbGVhckpvaW5SZXF1ZXN0c19SZXR1cm4uZW5jb2RlSW50byhBLnZhbHVlLEkpO2JyZWFrO2Nhc2UgMTM6ZS5BY2NlcHRTdHJlYW1SZXF1ZXN0X1JldHVybi5lbmNvZGVJbnRvKEEudmFsdWUsSSk7YnJlYWs7Y2FzZSAxNDplLlJlamVjdFN0cmVhbVJlcXVlc3RfUmV0dXJuLmVuY29kZUludG8oQS52YWx1ZSxJKTticmVhaztjYXNlIDE1OmUuR2V0U3RyZWFtUmVxdWVzdHNfUmV0dXJuLmVuY29kZUludG8oQS52YWx1ZSxJKTticmVhaztjYXNlIDE2OmUuQ2xlYXJTdHJlYW1SZXF1ZXN0c19SZXR1cm4uZW5jb2RlSW50byhBLnZhbHVlLEkpO2JyZWFrO2Nhc2UgMTc6ZS5HZXRQZWVyU3RhdGVDaGFuZ2VzX1JldHVybi5lbmNvZGVJbnRvKEEudmFsdWUsSSk7YnJlYWs7Y2FzZSAxODplLkNsZWFyUGVlclN0YXRlQ2hhbmdlc19SZXR1cm4uZW5jb2RlSW50byhBLnZhbHVlLEkpO2JyZWFrO2Nhc2UgMTk6ZS5HZXRQZWVyTWVzc2FnZXNfUmV0dXJuLmVuY29kZUludG8oQS52YWx1ZSxJKTticmVhaztjYXNlIDIwOmUuQ2xlYXJQZWVyTWVzc2FnZXNfUmV0dXJuLmVuY29kZUludG8oQS52YWx1ZSxJKX1jb25zdCBCPUkubGVuZ3RoO3JldHVybiBJLmZpbGxNZXNzYWdlTGVuZ3RoKHQsQi1pKSxJLmxlbmd0aC1nfSxkZWNvZGUoQSl7Y29uc3QgZT1nLkJlYm9wVmlldy5nZXRJbnN0YW5jZSgpO3JldHVybiBlLnN0YXJ0UmVhZGluZyhBKSx0aGlzLnJlYWRGcm9tKGUpfSxyZWFkRnJvbShBKXtjb25zdCBJPUEucmVhZE1lc3NhZ2VMZW5ndGgoKSx0PUEuaW5kZXgrMStJO3N3aXRjaChBLnJlYWRCeXRlKCkpe2Nhc2UgMTpyZXR1cm57ZGlzY3JpbWluYXRvcjoxLHZhbHVlOmUuRXJyb3JfUmV0dXJuLnJlYWRGcm9tKEEpfTtjYXNlIDI6cmV0dXJue2Rpc2NyaW1pbmF0b3I6Mix2YWx1ZTplLkluaXRpYWxpemVfUmV0dXJuLnJlYWRGcm9tKEEpfTtjYXNlIDM6cmV0dXJue2Rpc2NyaW1pbmF0b3I6Myx2YWx1ZTplLlNodXRkb3duX1JldHVybi5yZWFkRnJvbShBKX07Y2FzZSA0OnJldHVybntkaXNjcmltaW5hdG9yOjQsdmFsdWU6ZS5HZXRWZXJzaW9uX1JldHVybi5yZWFkRnJvbShBKX07Y2FzZSA1OnJldHVybntkaXNjcmltaW5hdG9yOjUsdmFsdWU6ZS5HZXRQZWVySWRfUmV0dXJuLnJlYWRGcm9tKEEpfTtjYXNlIDY6cmV0dXJue2Rpc2NyaW1pbmF0b3I6Nix2YWx1ZTplLlNldExvZ0xldmVsX1JldHVybi5yZWFkRnJvbShBKX07Y2FzZSA3OnJldHVybntkaXNjcmltaW5hdG9yOjcsdmFsdWU6ZS5HZXRMb2dzX1JldHVybi5yZWFkRnJvbShBKX07Y2FzZSA4OnJldHVybntkaXNjcmltaW5hdG9yOjgsdmFsdWU6ZS5DbGVhckxvZ3NfUmV0dXJuLnJlYWRGcm9tKEEpfTtjYXNlIDk6cmV0dXJue2Rpc2NyaW1pbmF0b3I6OSx2YWx1ZTplLkFjY2VwdEpvaW5SZXF1ZXN0X1JldHVybi5yZWFkRnJvbShBKX07Y2FzZSAxMDpyZXR1cm57ZGlzY3JpbWluYXRvcjoxMCx2YWx1ZTplLlJlamVjdEpvaW5SZXF1ZXN0X1JldHVybi5yZWFkRnJvbShBKX07Y2FzZSAxMTpyZXR1cm57ZGlzY3JpbWluYXRvcjoxMSx2YWx1ZTplLkdldEpvaW5SZXF1ZXN0c19SZXR1cm4ucmVhZEZyb20oQSl9O2Nhc2UgMTI6cmV0dXJue2Rpc2NyaW1pbmF0b3I6MTIsdmFsdWU6ZS5DbGVhckpvaW5SZXF1ZXN0c19SZXR1cm4ucmVhZEZyb20oQSl9O2Nhc2UgMTM6cmV0dXJue2Rpc2NyaW1pbmF0b3I6MTMsdmFsdWU6ZS5BY2NlcHRTdHJlYW1SZXF1ZXN0X1JldHVybi5yZWFkRnJvbShBKX07Y2FzZSAxNDpyZXR1cm57ZGlzY3JpbWluYXRvcjoxNCx2YWx1ZTplLlJlamVjdFN0cmVhbVJlcXVlc3RfUmV0dXJuLnJlYWRGcm9tKEEpfTtjYXNlIDE1OnJldHVybntkaXNjcmltaW5hdG9yOjE1LHZhbHVlOmUuR2V0U3RyZWFtUmVxdWVzdHNfUmV0dXJuLnJlYWRGcm9tKEEpfTtjYXNlIDE2OnJldHVybntkaXNjcmltaW5hdG9yOjE2LHZhbHVlOmUuQ2xlYXJTdHJlYW1SZXF1ZXN0c19SZXR1cm4ucmVhZEZyb20oQSl9O2Nhc2UgMTc6cmV0dXJue2Rpc2NyaW1pbmF0b3I6MTcsdmFsdWU6ZS5HZXRQZWVyU3RhdGVDaGFuZ2VzX1JldHVybi5yZWFkRnJvbShBKX07Y2FzZSAxODpyZXR1cm57ZGlzY3JpbWluYXRvcjoxOCx2YWx1ZTplLkNsZWFyUGVlclN0YXRlQ2hhbmdlc19SZXR1cm4ucmVhZEZyb20oQSl9O2Nhc2UgMTk6cmV0dXJue2Rpc2NyaW1pbmF0b3I6MTksdmFsdWU6ZS5HZXRQZWVyTWVzc2FnZXNfUmV0dXJuLnJlYWRGcm9tKEEpfTtjYXNlIDIwOnJldHVybntkaXNjcmltaW5hdG9yOjIwLHZhbHVlOmUuQ2xlYXJQZWVyTWVzc2FnZXNfUmV0dXJuLnJlYWRGcm9tKEEpfTtkZWZhdWx0OnRocm93IEEuaW5kZXg9dCxuZXcgZy5CZWJvcFJ1bnRpbWVFcnJvcihcIlVucmVjb2duaXplZCBkaXNjcmltaW5hdG9yIHdoaWxlIGRlY29kaW5nIFJldHVyblwiKX19fSwobT1lLkxvZ0xldmVsfHwoZS5Mb2dMZXZlbD17fSkpW20uU2lsZW50PTBdPVwiU2lsZW50XCIsbVttLkVycm9yPTFdPVwiRXJyb3JcIixtW20uV2FybmluZz0yXT1cIldhcm5pbmdcIixtW20uSW5mbz0zXT1cIkluZm9cIixtW20uRGVidWc9NF09XCJEZWJ1Z1wiLG1bbS5UcmFjZT01XT1cIlRyYWNlXCIsKGY9ZS5QZWVyU3RhdGV8fChlLlBlZXJTdGF0ZT17fSkpW2YuTmV3PTBdPVwiTmV3XCIsZltmLkNvbm5lY3Rpbmc9MV09XCJDb25uZWN0aW5nXCIsZltmLkNvbm5lY3RlZD0yXT1cIkNvbm5lY3RlZFwiLGZbZi5EaXNjb25uZWN0ZWQ9M109XCJEaXNjb25uZWN0ZWRcIixmW2YuRmFpbGVkPTRdPVwiRmFpbGVkXCIsZS5Mb2dFbnRyeT17ZW5jb2RlKEEpe2NvbnN0IGU9Zy5CZWJvcFZpZXcuZ2V0SW5zdGFuY2UoKTtyZXR1cm4gZS5zdGFydFdyaXRpbmcoKSx0aGlzLmVuY29kZUludG8oQSxlKSxlLnRvQXJyYXkoKX0sZW5jb2RlSW50byhBLGUpe2NvbnN0IEk9ZS5sZW5ndGg7cmV0dXJuIGUud3JpdGVVaW50MzIoQS5sZXZlbCksZS53cml0ZVN0cmluZyhBLnRhcmdldCksZS53cml0ZVN0cmluZyhBLmRhdGEpLGUubGVuZ3RoLUl9LGRlY29kZShBKXtjb25zdCBlPWcuQmVib3BWaWV3LmdldEluc3RhbmNlKCk7cmV0dXJuIGUuc3RhcnRSZWFkaW5nKEEpLHRoaXMucmVhZEZyb20oZSl9LHJlYWRGcm9tKEEpe2xldCBlLEksZztyZXR1cm4gZT1BLnJlYWRVaW50MzIoKSxJPUEucmVhZFN0cmluZygpLGc9QS5yZWFkU3RyaW5nKCkse2xldmVsOmUsdGFyZ2V0OkksZGF0YTpnfX19LGUuSm9pblJlcXVlc3RPcGVyYXRpb249e2VuY29kZShBKXtjb25zdCBlPWcuQmVib3BWaWV3LmdldEluc3RhbmNlKCk7cmV0dXJuIGUuc3RhcnRXcml0aW5nKCksdGhpcy5lbmNvZGVJbnRvKEEsZSksZS50b0FycmF5KCl9LGVuY29kZUludG8oQSxlKXtjb25zdCBJPWUubGVuZ3RoO3JldHVybiBlLndyaXRlU3RyaW5nKEEucGVlcklkKSxlLndyaXRlQnl0ZShOdW1iZXIoQS5hY2NlcHRlZCkpLGUubGVuZ3RoLUl9LGRlY29kZShBKXtjb25zdCBlPWcuQmVib3BWaWV3LmdldEluc3RhbmNlKCk7cmV0dXJuIGUuc3RhcnRSZWFkaW5nKEEpLHRoaXMucmVhZEZyb20oZSl9LHJlYWRGcm9tKEEpe2xldCBlLEk7cmV0dXJuIGU9QS5yZWFkU3RyaW5nKCksST0hIUEucmVhZEJ5dGUoKSx7cGVlcklkOmUsYWNjZXB0ZWQ6SX19fSxlLlN0cmVhbVJlcXVlc3RPcGVyYXRpb249e2VuY29kZShBKXtjb25zdCBlPWcuQmVib3BWaWV3LmdldEluc3RhbmNlKCk7cmV0dXJuIGUuc3RhcnRXcml0aW5nKCksdGhpcy5lbmNvZGVJbnRvKEEsZSksZS50b0FycmF5KCl9LGVuY29kZUludG8oQSxlKXtjb25zdCBJPWUubGVuZ3RoO3JldHVybiBlLndyaXRlU3RyaW5nKEEucGVlcklkKSxlLndyaXRlQnl0ZShOdW1iZXIoQS5hY2NlcHRlZCkpLGUubGVuZ3RoLUl9LGRlY29kZShBKXtjb25zdCBlPWcuQmVib3BWaWV3LmdldEluc3RhbmNlKCk7cmV0dXJuIGUuc3RhcnRSZWFkaW5nKEEpLHRoaXMucmVhZEZyb20oZSl9LHJlYWRGcm9tKEEpe2xldCBlLEk7cmV0dXJuIGU9QS5yZWFkU3RyaW5nKCksST0hIUEucmVhZEJ5dGUoKSx7cGVlcklkOmUsYWNjZXB0ZWQ6SX19fSxlLlBlZXJTdGF0ZUNoYW5nZT17ZW5jb2RlKEEpe2NvbnN0IGU9Zy5CZWJvcFZpZXcuZ2V0SW5zdGFuY2UoKTtyZXR1cm4gZS5zdGFydFdyaXRpbmcoKSx0aGlzLmVuY29kZUludG8oQSxlKSxlLnRvQXJyYXkoKX0sZW5jb2RlSW50byhBLGUpe2NvbnN0IEk9ZS5sZW5ndGg7cmV0dXJuIGUud3JpdGVTdHJpbmcoQS5wZWVySWQpLGUud3JpdGVVaW50MzIoQS5vbGRTdGF0ZSksZS53cml0ZVVpbnQzMihBLm5ld1N0YXRlKSxlLmxlbmd0aC1JfSxkZWNvZGUoQSl7Y29uc3QgZT1nLkJlYm9wVmlldy5nZXRJbnN0YW5jZSgpO3JldHVybiBlLnN0YXJ0UmVhZGluZyhBKSx0aGlzLnJlYWRGcm9tKGUpfSxyZWFkRnJvbShBKXtsZXQgZSxJLGc7cmV0dXJuIGU9QS5yZWFkU3RyaW5nKCksST1BLnJlYWRVaW50MzIoKSxnPUEucmVhZFVpbnQzMigpLHtwZWVySWQ6ZSxvbGRTdGF0ZTpJLG5ld1N0YXRlOmd9fX0sZS5QZWVyTWVzc2FnZT17ZW5jb2RlKEEpe2NvbnN0IGU9Zy5CZWJvcFZpZXcuZ2V0SW5zdGFuY2UoKTtyZXR1cm4gZS5zdGFydFdyaXRpbmcoKSx0aGlzLmVuY29kZUludG8oQSxlKSxlLnRvQXJyYXkoKX0sZW5jb2RlSW50byhBLGUpe2NvbnN0IEk9ZS5sZW5ndGg7cmV0dXJuIGUud3JpdGVTdHJpbmcoQS5wZWVySWQpLGUud3JpdGVTdHJpbmcoQS5jaGFubmVsTmFtZSksZS53cml0ZUJ5dGVzKEEuZGF0YSksZS5sZW5ndGgtSX0sZGVjb2RlKEEpe2NvbnN0IGU9Zy5CZWJvcFZpZXcuZ2V0SW5zdGFuY2UoKTtyZXR1cm4gZS5zdGFydFJlYWRpbmcoQSksdGhpcy5yZWFkRnJvbShlKX0scmVhZEZyb20oQSl7bGV0IGUsSSxnO3JldHVybiBlPUEucmVhZFN0cmluZygpLEk9QS5yZWFkU3RyaW5nKCksZz1BLnJlYWRCeXRlcygpLHtwZWVySWQ6ZSxjaGFubmVsTmFtZTpJLGRhdGE6Z319fSxlLkd1aWQ9e2VuY29kZShBKXtjb25zdCBlPWcuQmVib3BWaWV3LmdldEluc3RhbmNlKCk7cmV0dXJuIGUuc3RhcnRXcml0aW5nKCksdGhpcy5lbmNvZGVJbnRvKEEsZSksZS50b0FycmF5KCl9LGVuY29kZUludG8oQSxlKXtjb25zdCBJPWUubGVuZ3RoO3JldHVybiBlLndyaXRlR3VpZChBLnZhbHVlKSxlLmxlbmd0aC1JfSxkZWNvZGUoQSl7Y29uc3QgZT1nLkJlYm9wVmlldy5nZXRJbnN0YW5jZSgpO3JldHVybiBlLnN0YXJ0UmVhZGluZyhBKSx0aGlzLnJlYWRGcm9tKGUpfSxyZWFkRnJvbShBKXtsZXQgZTtyZXR1cm4gZT1BLnJlYWRHdWlkKCkse3ZhbHVlOmV9fX0sZS5SYWlud2F5SGVhZGVyPXtlbmNvZGUoQSl7Y29uc3QgZT1nLkJlYm9wVmlldy5nZXRJbnN0YW5jZSgpO3JldHVybiBlLnN0YXJ0V3JpdGluZygpLHRoaXMuZW5jb2RlSW50byhBLGUpLGUudG9BcnJheSgpfSxlbmNvZGVJbnRvKEEsZSl7Y29uc3QgST1lLmxlbmd0aDtyZXR1cm4gZS53cml0ZVVpbnQzMihBLm1hZ2ljTnVtYmVyKSxlLndyaXRlVWludDMyKEEuc3luY0tleSksZS53cml0ZUludDY0KEEuc291cmNlUGVlcklkKSxlLndyaXRlSW50NjQoQS50YXJnZXRQZWVySWQpLGUubGVuZ3RoLUl9LGRlY29kZShBKXtjb25zdCBlPWcuQmVib3BWaWV3LmdldEluc3RhbmNlKCk7cmV0dXJuIGUuc3RhcnRSZWFkaW5nKEEpLHRoaXMucmVhZEZyb20oZSl9LHJlYWRGcm9tKEEpe2xldCBlLEksZyx0O3JldHVybiBlPUEucmVhZFVpbnQzMigpLEk9QS5yZWFkVWludDMyKCksZz1BLnJlYWRJbnQ2NCgpLHQ9QS5yZWFkSW50NjQoKSx7bWFnaWNOdW1iZXI6ZSxzeW5jS2V5Okksc291cmNlUGVlcklkOmcsdGFyZ2V0UGVlcklkOnR9fX0sZS5DaHVuaz17ZW5jb2RlKEEpe2NvbnN0IGU9Zy5CZWJvcFZpZXcuZ2V0SW5zdGFuY2UoKTtyZXR1cm4gZS5zdGFydFdyaXRpbmcoKSx0aGlzLmVuY29kZUludG8oQSxlKSxlLnRvQXJyYXkoKX0sZW5jb2RlSW50byhBLGUpe2NvbnN0IEk9ZS5sZW5ndGg7cmV0dXJuIGUud3JpdGVVaW50MTYoQS5ncm91cElkKSxlLndyaXRlQnl0ZShBLmluZGV4KSxlLndyaXRlQnl0ZShBLmNodW5rc0luR3JvdXApLGUud3JpdGVCeXRlcyhBLmRhdGEpLGUubGVuZ3RoLUl9LGRlY29kZShBKXtjb25zdCBlPWcuQmVib3BWaWV3LmdldEluc3RhbmNlKCk7cmV0dXJuIGUuc3RhcnRSZWFkaW5nKEEpLHRoaXMucmVhZEZyb20oZSl9LHJlYWRGcm9tKEEpe2xldCBlLEksZyx0O3JldHVybiBlPUEucmVhZFVpbnQxNigpLEk9QS5yZWFkQnl0ZSgpLGc9QS5yZWFkQnl0ZSgpLHQ9QS5yZWFkQnl0ZXMoKSx7Z3JvdXBJZDplLGluZGV4OkksY2h1bmtzSW5Hcm91cDpnLGRhdGE6dH19fSxlLklucHV0RGF0YWdyYW09e2VuY29kZShBKXtjb25zdCBlPWcuQmVib3BWaWV3LmdldEluc3RhbmNlKCk7cmV0dXJuIGUuc3RhcnRXcml0aW5nKCksdGhpcy5lbmNvZGVJbnRvKEEsZSksZS50b0FycmF5KCl9LGVuY29kZUludG8oQSxJKXtjb25zdCBnPUkubGVuZ3RoO3JldHVybiBlLlJhaW53YXlIZWFkZXIuZW5jb2RlSW50byhBLmhlYWRlcixJKSxlLklucHV0Qm9keS5lbmNvZGVJbnRvKEEuYm9keSxJKSxJLmxlbmd0aC1nfSxkZWNvZGUoQSl7Y29uc3QgZT1nLkJlYm9wVmlldy5nZXRJbnN0YW5jZSgpO3JldHVybiBlLnN0YXJ0UmVhZGluZyhBKSx0aGlzLnJlYWRGcm9tKGUpfSxyZWFkRnJvbShBKXtsZXQgSSxnO3JldHVybiBJPWUuUmFpbndheUhlYWRlci5yZWFkRnJvbShBKSxnPWUuSW5wdXRCb2R5LnJlYWRGcm9tKEEpLHtoZWFkZXI6SSxib2R5Omd9fX0sZS5Mb2dpY0RhdGFncmFtPXtlbmNvZGUoQSl7Y29uc3QgZT1nLkJlYm9wVmlldy5nZXRJbnN0YW5jZSgpO3JldHVybiBlLnN0YXJ0V3JpdGluZygpLHRoaXMuZW5jb2RlSW50byhBLGUpLGUudG9BcnJheSgpfSxlbmNvZGVJbnRvKEEsSSl7Y29uc3QgZz1JLmxlbmd0aDtyZXR1cm4gZS5SYWlud2F5SGVhZGVyLmVuY29kZUludG8oQS5oZWFkZXIsSSksZS5Mb2dpY0JvZHkuZW5jb2RlSW50byhBLmJvZHksSSksSS5sZW5ndGgtZ30sZGVjb2RlKEEpe2NvbnN0IGU9Zy5CZWJvcFZpZXcuZ2V0SW5zdGFuY2UoKTtyZXR1cm4gZS5zdGFydFJlYWRpbmcoQSksdGhpcy5yZWFkRnJvbShlKX0scmVhZEZyb20oQSl7bGV0IEksZztyZXR1cm4gST1lLlJhaW53YXlIZWFkZXIucmVhZEZyb20oQSksZz1lLkxvZ2ljQm9keS5yZWFkRnJvbShBKSx7aGVhZGVyOkksYm9keTpnfX19LGUuTWVkaWFEYXRhZ3JhbT17ZW5jb2RlKEEpe2NvbnN0IGU9Zy5CZWJvcFZpZXcuZ2V0SW5zdGFuY2UoKTtyZXR1cm4gZS5zdGFydFdyaXRpbmcoKSx0aGlzLmVuY29kZUludG8oQSxlKSxlLnRvQXJyYXkoKX0sZW5jb2RlSW50byhBLEkpe2NvbnN0IGc9SS5sZW5ndGg7cmV0dXJuIGUuUmFpbndheUhlYWRlci5lbmNvZGVJbnRvKEEuaGVhZGVyLEkpLGUuTWVkaWFCb2R5LmVuY29kZUludG8oQS5ib2R5LEkpLEkubGVuZ3RoLWd9LGRlY29kZShBKXtjb25zdCBlPWcuQmVib3BWaWV3LmdldEluc3RhbmNlKCk7cmV0dXJuIGUuc3RhcnRSZWFkaW5nKEEpLHRoaXMucmVhZEZyb20oZSl9LHJlYWRGcm9tKEEpe2xldCBJLGc7cmV0dXJuIEk9ZS5SYWlud2F5SGVhZGVyLnJlYWRGcm9tKEEpLGc9ZS5NZWRpYUJvZHkucmVhZEZyb20oQSkse2hlYWRlcjpJLGJvZHk6Z319fSxlLkFyYml0cmFyeURhdGFncmFtPXtlbmNvZGUoQSl7Y29uc3QgZT1nLkJlYm9wVmlldy5nZXRJbnN0YW5jZSgpO3JldHVybiBlLnN0YXJ0V3JpdGluZygpLHRoaXMuZW5jb2RlSW50byhBLGUpLGUudG9BcnJheSgpfSxlbmNvZGVJbnRvKEEsSSl7Y29uc3QgZz1JLmxlbmd0aDtyZXR1cm4gZS5SYWlud2F5SGVhZGVyLmVuY29kZUludG8oQS5oZWFkZXIsSSksZS5DaHVuay5lbmNvZGVJbnRvKEEuYm9keSxJKSxJLmxlbmd0aC1nfSxkZWNvZGUoQSl7Y29uc3QgZT1nLkJlYm9wVmlldy5nZXRJbnN0YW5jZSgpO3JldHVybiBlLnN0YXJ0UmVhZGluZyhBKSx0aGlzLnJlYWRGcm9tKGUpfSxyZWFkRnJvbShBKXtsZXQgSSxnO3JldHVybiBJPWUuUmFpbndheUhlYWRlci5yZWFkRnJvbShBKSxnPWUuQ2h1bmsucmVhZEZyb20oQSkse2hlYWRlcjpJLGJvZHk6Z319fSwoRz1lLlhJbnB1dEJ1dHRvbnN8fChlLlhJbnB1dEJ1dHRvbnM9e30pKVtHLk5vbmU9MF09XCJOb25lXCIsR1tHLkRwYWRVcD0xXT1cIkRwYWRVcFwiLEdbRy5EcGFkRG93bj0yXT1cIkRwYWREb3duXCIsR1tHLkRwYWRMZWZ0PTRdPVwiRHBhZExlZnRcIixHW0cuRHBhZFJpZ2h0PThdPVwiRHBhZFJpZ2h0XCIsR1tHLlN0YXJ0PTE2XT1cIlN0YXJ0XCIsR1tHLkJhY2s9MzJdPVwiQmFja1wiLEdbRy5MZWZ0U3RpY2s9NjRdPVwiTGVmdFN0aWNrXCIsR1tHLlJpZ2h0U3RpY2s9MTI4XT1cIlJpZ2h0U3RpY2tcIixHW0cuTGVmdEJ1bXBlcj0yNTZdPVwiTGVmdEJ1bXBlclwiLEdbRy5SaWdodEJ1bXBlcj01MTJdPVwiUmlnaHRCdW1wZXJcIixHW0cuR3VpZGU9MTAyNF09XCJHdWlkZVwiLEdbRy5BPTQwOTZdPVwiQVwiLEdbRy5CPTgxOTJdPVwiQlwiLEdbRy5YPTE2Mzg0XT1cIlhcIixHW0cuWT0zMjc2OF09XCJZXCIsKHA9ZS5CdXR0b25BY3Rpb258fChlLkJ1dHRvbkFjdGlvbj17fSkpW3AuQnV0dG9uRG93bj0wXT1cIkJ1dHRvbkRvd25cIixwW3AuQnV0dG9uVXA9MV09XCJCdXR0b25VcFwiLChSPWUuTW91c2VCdXR0b258fChlLk1vdXNlQnV0dG9uPXt9KSlbUi5MZWZ0PTBdPVwiTGVmdFwiLFJbUi5SaWdodD0xXT1cIlJpZ2h0XCIsUltSLk1pZGRsZT0yXT1cIk1pZGRsZVwiLFJbUi5YMT0zXT1cIlgxXCIsUltSLlgyPTRdPVwiWDJcIiwoRj1lLlNjcm9sbEF4aXN8fChlLlNjcm9sbEF4aXM9e30pKVtGLkhvcml6b250YWw9MF09XCJIb3Jpem9udGFsXCIsRltGLlZlcnRpY2FsPTFdPVwiVmVydGljYWxcIiwoUz1lLktleWJvYXJkQWN0aW9ufHwoZS5LZXlib2FyZEFjdGlvbj17fSkpW1MuS2V5RG93bj0wXT1cIktleURvd25cIixTW1MuS2V5VXA9MV09XCJLZXlVcFwiLCh5PWUuVmlydHVhbEtleXx8KGUuVmlydHVhbEtleT17fSkpW3kuTm9uZT0wXT1cIk5vbmVcIix5W3kuQ2FuY2VsPTFdPVwiQ2FuY2VsXCIseVt5LkJhY2s9Ml09XCJCYWNrXCIseVt5LlRhYj0zXT1cIlRhYlwiLHlbeS5MaW5lRmVlZD00XT1cIkxpbmVGZWVkXCIseVt5LkNsZWFyPTVdPVwiQ2xlYXJcIix5W3kuRW50ZXI9Nl09XCJFbnRlclwiLHlbeS5QYXVzZT03XT1cIlBhdXNlXCIseVt5LkNhcHNMb2NrPThdPVwiQ2Fwc0xvY2tcIix5W3kuSGFuZ3VsTW9kZT05XT1cIkhhbmd1bE1vZGVcIix5W3kuSnVuamFNb2RlPTEwXT1cIkp1bmphTW9kZVwiLHlbeS5GaW5hbE1vZGU9MTFdPVwiRmluYWxNb2RlXCIseVt5LkhhbmphTW9kZT0xMl09XCJIYW5qYU1vZGVcIix5W3kuRXNjYXBlPTEzXT1cIkVzY2FwZVwiLHlbeS5JbWVDb252ZXJ0PTE0XT1cIkltZUNvbnZlcnRcIix5W3kuSW1lTm9uQ29udmVydD0xNV09XCJJbWVOb25Db252ZXJ0XCIseVt5LkltZUFjY2VwdD0xNl09XCJJbWVBY2NlcHRcIix5W3kuSW1lTW9kZUNoYW5nZT0xN109XCJJbWVNb2RlQ2hhbmdlXCIseVt5LlNwYWNlPTE4XT1cIlNwYWNlXCIseVt5LlBhZ2VVcD0xOV09XCJQYWdlVXBcIix5W3kuUGFnZURvd249MjBdPVwiUGFnZURvd25cIix5W3kuRW5kPTIxXT1cIkVuZFwiLHlbeS5Ib21lPTIyXT1cIkhvbWVcIix5W3kuTGVmdD0yM109XCJMZWZ0XCIseVt5LlVwPTI0XT1cIlVwXCIseVt5LlJpZ2h0PTI1XT1cIlJpZ2h0XCIseVt5LkRvd249MjZdPVwiRG93blwiLHlbeS5TZWxlY3Q9MjddPVwiU2VsZWN0XCIseVt5LlByaW50PTI4XT1cIlByaW50XCIseVt5LkV4ZWN1dGU9MjldPVwiRXhlY3V0ZVwiLHlbeS5QcmludFNjcmVlbj0zMF09XCJQcmludFNjcmVlblwiLHlbeS5JbnNlcnQ9MzFdPVwiSW5zZXJ0XCIseVt5LkRlbGV0ZT0zMl09XCJEZWxldGVcIix5W3kuSGVscD0zM109XCJIZWxwXCIseVt5LkQwPTM0XT1cIkQwXCIseVt5LkQxPTM1XT1cIkQxXCIseVt5LkQyPTM2XT1cIkQyXCIseVt5LkQzPTM3XT1cIkQzXCIseVt5LkQ0PTM4XT1cIkQ0XCIseVt5LkQ1PTM5XT1cIkQ1XCIseVt5LkQ2PTQwXT1cIkQ2XCIseVt5LkQ3PTQxXT1cIkQ3XCIseVt5LkQ4PTQyXT1cIkQ4XCIseVt5LkQ5PTQzXT1cIkQ5XCIseVt5LkE9NDRdPVwiQVwiLHlbeS5CPTQ1XT1cIkJcIix5W3kuQz00Nl09XCJDXCIseVt5LkQ9NDddPVwiRFwiLHlbeS5FPTQ4XT1cIkVcIix5W3kuRj00OV09XCJGXCIseVt5Lkc9NTBdPVwiR1wiLHlbeS5IPTUxXT1cIkhcIix5W3kuST01Ml09XCJJXCIseVt5Lko9NTNdPVwiSlwiLHlbeS5LPTU0XT1cIktcIix5W3kuTD01NV09XCJMXCIseVt5Lk09NTZdPVwiTVwiLHlbeS5OPTU3XT1cIk5cIix5W3kuTz01OF09XCJPXCIseVt5LlA9NTldPVwiUFwiLHlbeS5RPTYwXT1cIlFcIix5W3kuUj02MV09XCJSXCIseVt5LlM9NjJdPVwiU1wiLHlbeS5UPTYzXT1cIlRcIix5W3kuVT02NF09XCJVXCIseVt5LlY9NjVdPVwiVlwiLHlbeS5XPTY2XT1cIldcIix5W3kuWD02N109XCJYXCIseVt5Llk9NjhdPVwiWVwiLHlbeS5aPTY5XT1cIlpcIix5W3kuTFdpbj03MF09XCJMV2luXCIseVt5LlJXaW49NzFdPVwiUldpblwiLHlbeS5BcHBzPTcyXT1cIkFwcHNcIix5W3kuU2xlZXA9NzNdPVwiU2xlZXBcIix5W3kuTnVtUGFkMD03NF09XCJOdW1QYWQwXCIseVt5Lk51bVBhZDE9NzVdPVwiTnVtUGFkMVwiLHlbeS5OdW1QYWQyPTc2XT1cIk51bVBhZDJcIix5W3kuTnVtUGFkMz03N109XCJOdW1QYWQzXCIseVt5Lk51bVBhZDQ9NzhdPVwiTnVtUGFkNFwiLHlbeS5OdW1QYWQ1PTc5XT1cIk51bVBhZDVcIix5W3kuTnVtUGFkNj04MF09XCJOdW1QYWQ2XCIseVt5Lk51bVBhZDc9ODFdPVwiTnVtUGFkN1wiLHlbeS5OdW1QYWQ4PTgyXT1cIk51bVBhZDhcIix5W3kuTnVtUGFkOT04M109XCJOdW1QYWQ5XCIseVt5Lk11bHRpcGx5PTg0XT1cIk11bHRpcGx5XCIseVt5LkFkZD04NV09XCJBZGRcIix5W3kuU2VwYXJhdG9yPTg2XT1cIlNlcGFyYXRvclwiLHlbeS5TdWJ0cmFjdD04N109XCJTdWJ0cmFjdFwiLHlbeS5EZWNpbWFsPTg4XT1cIkRlY2ltYWxcIix5W3kuRGl2aWRlPTg5XT1cIkRpdmlkZVwiLHlbeS5GMT05MF09XCJGMVwiLHlbeS5GMj05MV09XCJGMlwiLHlbeS5GMz05Ml09XCJGM1wiLHlbeS5GND05M109XCJGNFwiLHlbeS5GNT05NF09XCJGNVwiLHlbeS5GNj05NV09XCJGNlwiLHlbeS5GNz05Nl09XCJGN1wiLHlbeS5GOD05N109XCJGOFwiLHlbeS5GOT05OF09XCJGOVwiLHlbeS5GMTA9OTldPVwiRjEwXCIseVt5LkYxMT0xMDBdPVwiRjExXCIseVt5LkYxMj0xMDFdPVwiRjEyXCIseVt5LkYxMz0xMDJdPVwiRjEzXCIseVt5LkYxND0xMDNdPVwiRjE0XCIseVt5LkYxNT0xMDRdPVwiRjE1XCIseVt5LkYxNj0xMDVdPVwiRjE2XCIseVt5LkYxNz0xMDZdPVwiRjE3XCIseVt5LkYxOD0xMDddPVwiRjE4XCIseVt5LkYxOT0xMDhdPVwiRjE5XCIseVt5LkYyMD0xMDldPVwiRjIwXCIseVt5LkYyMT0xMTBdPVwiRjIxXCIseVt5LkYyMj0xMTFdPVwiRjIyXCIseVt5LkYyMz0xMTJdPVwiRjIzXCIseVt5LkYyND0xMTNdPVwiRjI0XCIseVt5Lk51bUxvY2s9MTE0XT1cIk51bUxvY2tcIix5W3kuU2Nyb2xsPTExNV09XCJTY3JvbGxcIix5W3kuTGVmdFNoaWZ0PTExNl09XCJMZWZ0U2hpZnRcIix5W3kuUmlnaHRTaGlmdD0xMTddPVwiUmlnaHRTaGlmdFwiLHlbeS5MZWZ0Q3RybD0xMThdPVwiTGVmdEN0cmxcIix5W3kuUmlnaHRDdHJsPTExOV09XCJSaWdodEN0cmxcIix5W3kuTGVmdEFsdD0xMjBdPVwiTGVmdEFsdFwiLHlbeS5SaWdodEFsdD0xMjFdPVwiUmlnaHRBbHRcIix5W3kuQnJvd3NlckJhY2s9MTIyXT1cIkJyb3dzZXJCYWNrXCIseVt5LkJyb3dzZXJGb3J3YXJkPTEyM109XCJCcm93c2VyRm9yd2FyZFwiLHlbeS5Ccm93c2VyUmVmcmVzaD0xMjRdPVwiQnJvd3NlclJlZnJlc2hcIix5W3kuQnJvd3NlclN0b3A9MTI1XT1cIkJyb3dzZXJTdG9wXCIseVt5LkJyb3dzZXJTZWFyY2g9MTI2XT1cIkJyb3dzZXJTZWFyY2hcIix5W3kuQnJvd3NlckZhdm9yaXRlcz0xMjddPVwiQnJvd3NlckZhdm9yaXRlc1wiLHlbeS5Ccm93c2VySG9tZT0xMjhdPVwiQnJvd3NlckhvbWVcIix5W3kuVm9sdW1lTXV0ZT0xMjldPVwiVm9sdW1lTXV0ZVwiLHlbeS5Wb2x1bWVEb3duPTEzMF09XCJWb2x1bWVEb3duXCIseVt5LlZvbHVtZVVwPTEzMV09XCJWb2x1bWVVcFwiLHlbeS5NZWRpYU5leHRUcmFjaz0xMzJdPVwiTWVkaWFOZXh0VHJhY2tcIix5W3kuTWVkaWFQcmV2aW91c1RyYWNrPTEzM109XCJNZWRpYVByZXZpb3VzVHJhY2tcIix5W3kuTWVkaWFTdG9wPTEzNF09XCJNZWRpYVN0b3BcIix5W3kuTWVkaWFQbGF5UGF1c2U9MTM1XT1cIk1lZGlhUGxheVBhdXNlXCIseVt5LkxhdW5jaE1haWw9MTM2XT1cIkxhdW5jaE1haWxcIix5W3kuU2VsZWN0TWVkaWE9MTM3XT1cIlNlbGVjdE1lZGlhXCIseVt5LkxhdW5jaEFwcGxpY2F0aW9uMT0xMzhdPVwiTGF1bmNoQXBwbGljYXRpb24xXCIseVt5LkxhdW5jaEFwcGxpY2F0aW9uMj0xMzldPVwiTGF1bmNoQXBwbGljYXRpb24yXCIseVt5Lk9lbTE9MTQwXT1cIk9lbTFcIix5W3kuT2VtUGx1cz0xNDFdPVwiT2VtUGx1c1wiLHlbeS5PZW1Db21tYT0xNDJdPVwiT2VtQ29tbWFcIix5W3kuT2VtTWludXM9MTQzXT1cIk9lbU1pbnVzXCIseVt5Lk9lbVBlcmlvZD0xNDRdPVwiT2VtUGVyaW9kXCIseVt5Lk9lbTI9MTQ1XT1cIk9lbTJcIix5W3kuT2VtMz0xNDZdPVwiT2VtM1wiLHlbeS5BYm50QzE9MTQ3XT1cIkFibnRDMVwiLHlbeS5BYm50QzI9MTQ4XT1cIkFibnRDMlwiLHlbeS5PZW00PTE0OV09XCJPZW00XCIseVt5Lk9lbTU9MTUwXT1cIk9lbTVcIix5W3kuT2VtNj0xNTFdPVwiT2VtNlwiLHlbeS5PZW03PTE1Ml09XCJPZW03XCIseVt5Lk9lbTg9MTUzXT1cIk9lbThcIix5W3kuT2VtMTAyPTE1NF09XCJPZW0xMDJcIix5W3kuSW1lUHJvY2Vzc2VkPTE1NV09XCJJbWVQcm9jZXNzZWRcIix5W3kuU3lzdGVtPTE1Nl09XCJTeXN0ZW1cIix5W3kuT2VtQXR0bj0xNTddPVwiT2VtQXR0blwiLHlbeS5PZW1GaW5pc2g9MTU4XT1cIk9lbUZpbmlzaFwiLHlbeS5PZW1Db3B5PTE1OV09XCJPZW1Db3B5XCIseVt5Lk9lbUF1dG89MTYwXT1cIk9lbUF1dG9cIix5W3kuT2VtRW5sdz0xNjFdPVwiT2VtRW5sd1wiLHlbeS5PZW1CYWNrVGFiPTE2Ml09XCJPZW1CYWNrVGFiXCIseVt5LkF0dG49MTYzXT1cIkF0dG5cIix5W3kuQ3JTZWw9MTY0XT1cIkNyU2VsXCIseVt5LkV4U2VsPTE2NV09XCJFeFNlbFwiLHlbeS5FcmFzZUVvZj0xNjZdPVwiRXJhc2VFb2ZcIix5W3kuUGxheT0xNjddPVwiUGxheVwiLHlbeS5ab29tPTE2OF09XCJab29tXCIseVt5Lk5vTmFtZT0xNjldPVwiTm9OYW1lXCIseVt5LlBhMT0xNzBdPVwiUGExXCIseVt5Lk9lbUNsZWFyPTE3MV09XCJPZW1DbGVhclwiLHlbeS5EZWFkQ2hhclByb2Nlc3NlZD0xNzJdPVwiRGVhZENoYXJQcm9jZXNzZWRcIiwobD1lLldpbmRvd3NQb2ludGVyRmxhZ3N8fChlLldpbmRvd3NQb2ludGVyRmxhZ3M9e30pKVtsLk5ldz0xXT1cIk5ld1wiLGxbbC5JblJhbmdlPTJdPVwiSW5SYW5nZVwiLGxbbC5JbkNvbnRhY3Q9NF09XCJJbkNvbnRhY3RcIixsW2wuRmlyc3RCdXR0b249MTZdPVwiRmlyc3RCdXR0b25cIixsW2wuU2Vjb25kQnV0dG9uPTMyXT1cIlNlY29uZEJ1dHRvblwiLGxbbC5UaGlyZEJ1dHRvbj02NF09XCJUaGlyZEJ1dHRvblwiLGxbbC5Gb3VydGhCdXR0b249MTI4XT1cIkZvdXJ0aEJ1dHRvblwiLGxbbC5GaWZ0aEJ1dHRvbj0yNTZdPVwiRmlmdGhCdXR0b25cIixsW2wuUHJpbWFyeT04MTkyXT1cIlByaW1hcnlcIixsW2wuQ29uZmlkZW5jZT0xNjM4NF09XCJDb25maWRlbmNlXCIsbFtsLkNhbmNlbGVkPTMyNzY4XT1cIkNhbmNlbGVkXCIsbFtsLkRvd249NjU1MzZdPVwiRG93blwiLGxbbC5VcGRhdGU9MTMxMDcyXT1cIlVwZGF0ZVwiLGxbbC5VcD0yNjIxNDRdPVwiVXBcIixsW2wuV2hlZWw9NTI0Mjg4XT1cIldoZWVsXCIsbFtsLkhXaGVlbD0xMDQ4NTc2XT1cIkhXaGVlbFwiLGxbbC5DYXB0dXJlQ2hhbmdlZD0yMDk3MTUyXT1cIkNhcHR1cmVDaGFuZ2VkXCIsbFtsLkhhc1RyYW5zZm9ybT00MTk0MzA0XT1cIkhhc1RyYW5zZm9ybVwiLGUuVG91Y2hQZW5Qb2ludGVySW5mbz17ZW5jb2RlKEEpe2NvbnN0IGU9Zy5CZWJvcFZpZXcuZ2V0SW5zdGFuY2UoKTtyZXR1cm4gZS5zdGFydFdyaXRpbmcoKSx0aGlzLmVuY29kZUludG8oQSxlKSxlLnRvQXJyYXkoKX0sZW5jb2RlSW50byhBLGUpe2NvbnN0IEk9ZS5sZW5ndGg7cmV0dXJuIGUud3JpdGVVaW50MzIoQS5wb2ludGVySWQpLGUud3JpdGVVaW50MzIoQS5mcmFtZUlkKSxlLndyaXRlVWludDMyKEEucG9pbnRlckZsYWdzKSxlLndyaXRlSW50MzIoQS54KSxlLndyaXRlSW50MzIoQS55KSxlLmxlbmd0aC1JfSxkZWNvZGUoQSl7Y29uc3QgZT1nLkJlYm9wVmlldy5nZXRJbnN0YW5jZSgpO3JldHVybiBlLnN0YXJ0UmVhZGluZyhBKSx0aGlzLnJlYWRGcm9tKGUpfSxyZWFkRnJvbShBKXtsZXQgZSxJLGcsdCxpO3JldHVybiBlPUEucmVhZFVpbnQzMigpLEk9QS5yZWFkVWludDMyKCksZz1BLnJlYWRVaW50MzIoKSx0PUEucmVhZEludDMyKCksaT1BLnJlYWRJbnQzMigpLHtwb2ludGVySWQ6ZSxmcmFtZUlkOkkscG9pbnRlckZsYWdzOmcseDp0LHk6aX19fSwodz1lLlRvdWNoTWFza3x8KGUuVG91Y2hNYXNrPXt9KSlbdy5Db250YWN0QXJlYT0xXT1cIkNvbnRhY3RBcmVhXCIsd1t3Lk9yaWVudGF0aW9uPTJdPVwiT3JpZW50YXRpb25cIix3W3cuUHJlc3N1cmU9NF09XCJQcmVzc3VyZVwiLCh1PWUuUGVuTWFza3x8KGUuUGVuTWFzaz17fSkpW3UuUHJlc3N1cmU9MV09XCJQcmVzc3VyZVwiLHVbdS5Sb3RhdGlvbj0yXT1cIlJvdGF0aW9uXCIsdVt1LlRpbHRYPTRdPVwiVGlsdFhcIix1W3UuVGlsdFk9OF09XCJUaWx0WVwiLChEPWUuUGVuRmxhZ3N8fChlLlBlbkZsYWdzPXt9KSlbRC5CYXJyZWw9MV09XCJCYXJyZWxcIixEW0QuSW52ZXJ0ZWQ9Ml09XCJJbnZlcnRlZFwiLERbRC5FcmFzZXI9NF09XCJFcmFzZXJcIixlLlRvdWNoQWJzb2x1dGU9e2VuY29kZShBKXtjb25zdCBlPWcuQmVib3BWaWV3LmdldEluc3RhbmNlKCk7cmV0dXJuIGUuc3RhcnRXcml0aW5nKCksdGhpcy5lbmNvZGVJbnRvKEEsZSksZS50b0FycmF5KCl9LGVuY29kZUludG8oQSxJKXtjb25zdCBnPUkubGVuZ3RoO3JldHVybiBlLlRvdWNoUGVuUG9pbnRlckluZm8uZW5jb2RlSW50byhBLnBvaW50ZXJJbmZvLEkpLEkud3JpdGVVaW50MzIoQS50b3VjaE1hc2spLEkud3JpdGVJbnQzMihBLmNvbnRhY3RMZWZ0KSxJLndyaXRlSW50MzIoQS5jb250YWN0VG9wKSxJLndyaXRlSW50MzIoQS5jb250YWN0UmlnaHQpLEkud3JpdGVJbnQzMihBLmNvbnRhY3RCb3R0b20pLEkud3JpdGVVaW50MzIoQS5vcmllbnRhdGlvbiksSS53cml0ZVVpbnQzMihBLnByZXNzdXJlKSxJLmxlbmd0aC1nfSxkZWNvZGUoQSl7Y29uc3QgZT1nLkJlYm9wVmlldy5nZXRJbnN0YW5jZSgpO3JldHVybiBlLnN0YXJ0UmVhZGluZyhBKSx0aGlzLnJlYWRGcm9tKGUpfSxyZWFkRnJvbShBKXtsZXQgSSxnLHQsaSxCLEMsUSxvO3JldHVybiBJPWUuVG91Y2hQZW5Qb2ludGVySW5mby5yZWFkRnJvbShBKSxnPUEucmVhZFVpbnQzMigpLHQ9QS5yZWFkSW50MzIoKSxpPUEucmVhZEludDMyKCksQj1BLnJlYWRJbnQzMigpLEM9QS5yZWFkSW50MzIoKSxRPUEucmVhZFVpbnQzMigpLG89QS5yZWFkVWludDMyKCkse3BvaW50ZXJJbmZvOkksdG91Y2hNYXNrOmcsY29udGFjdExlZnQ6dCxjb250YWN0VG9wOmksY29udGFjdFJpZ2h0OkIsY29udGFjdEJvdHRvbTpDLG9yaWVudGF0aW9uOlEscHJlc3N1cmU6b319fSxlLkdhbWVwYWRSZXBvcnQ9e2Rpc2NyaW1pbmF0b3I6MSxlbmNvZGUoQSl7Y29uc3QgZT1nLkJlYm9wVmlldy5nZXRJbnN0YW5jZSgpO3JldHVybiBlLnN0YXJ0V3JpdGluZygpLHRoaXMuZW5jb2RlSW50byhBLGUpLGUudG9BcnJheSgpfSxlbmNvZGVJbnRvKEEsZSl7Y29uc3QgST1lLmxlbmd0aDtyZXR1cm4gZS53cml0ZVVpbnQzMihBLmJ1dHRvbnMpLGUud3JpdGVCeXRlKEEubGVmdFRyaWdnZXIpLGUud3JpdGVCeXRlKEEucmlnaHRUcmlnZ2VyKSxlLndyaXRlSW50MTYoQS5sZWZ0VGh1bWJYKSxlLndyaXRlSW50MTYoQS5sZWZ0VGh1bWJZKSxlLndyaXRlSW50MTYoQS5yaWdodFRodW1iWCksZS53cml0ZUludDE2KEEucmlnaHRUaHVtYlkpLGUud3JpdGVCeXRlKEEuc2xvdCksZS5sZW5ndGgtSX0sZGVjb2RlKEEpe2NvbnN0IGU9Zy5CZWJvcFZpZXcuZ2V0SW5zdGFuY2UoKTtyZXR1cm4gZS5zdGFydFJlYWRpbmcoQSksdGhpcy5yZWFkRnJvbShlKX0scmVhZEZyb20oQSl7bGV0IGUsSSxnLHQsaSxCLEMsUTtyZXR1cm4gZT1BLnJlYWRVaW50MzIoKSxJPUEucmVhZEJ5dGUoKSxnPUEucmVhZEJ5dGUoKSx0PUEucmVhZEludDE2KCksaT1BLnJlYWRJbnQxNigpLEI9QS5yZWFkSW50MTYoKSxDPUEucmVhZEludDE2KCksUT1BLnJlYWRCeXRlKCkse2J1dHRvbnM6ZSxsZWZ0VHJpZ2dlcjpJLHJpZ2h0VHJpZ2dlcjpnLGxlZnRUaHVtYlg6dCxsZWZ0VGh1bWJZOmkscmlnaHRUaHVtYlg6QixyaWdodFRodW1iWTpDLHNsb3Q6UX19fSxlLkdhbWVwYWRSdW1ibGU9e2Rpc2NyaW1pbmF0b3I6MixlbmNvZGUoQSl7Y29uc3QgZT1nLkJlYm9wVmlldy5nZXRJbnN0YW5jZSgpO3JldHVybiBlLnN0YXJ0V3JpdGluZygpLHRoaXMuZW5jb2RlSW50byhBLGUpLGUudG9BcnJheSgpfSxlbmNvZGVJbnRvKEEsZSl7Y29uc3QgST1lLmxlbmd0aDtyZXR1cm4gZS53cml0ZUJ5dGUoQS5wb3J0KSxlLndyaXRlVWludDE2KEEubGVmdE1vdG9yU3BlZWQpLGUud3JpdGVVaW50MTYoQS5yaWdodE1vdG9yU3BlZWQpLGUubGVuZ3RoLUl9LGRlY29kZShBKXtjb25zdCBlPWcuQmVib3BWaWV3LmdldEluc3RhbmNlKCk7cmV0dXJuIGUuc3RhcnRSZWFkaW5nKEEpLHRoaXMucmVhZEZyb20oZSl9LHJlYWRGcm9tKEEpe2xldCBlLEksZztyZXR1cm4gZT1BLnJlYWRCeXRlKCksST1BLnJlYWRVaW50MTYoKSxnPUEucmVhZFVpbnQxNigpLHtwb3J0OmUsbGVmdE1vdG9yU3BlZWQ6SSxyaWdodE1vdG9yU3BlZWQ6Z319fSxlLk1vdXNlQWJzb2x1dGU9e2Rpc2NyaW1pbmF0b3I6MyxlbmNvZGUoQSl7Y29uc3QgZT1nLkJlYm9wVmlldy5nZXRJbnN0YW5jZSgpO3JldHVybiBlLnN0YXJ0V3JpdGluZygpLHRoaXMuZW5jb2RlSW50byhBLGUpLGUudG9BcnJheSgpfSxlbmNvZGVJbnRvKEEsZSl7Y29uc3QgST1lLmxlbmd0aDtyZXR1cm4gZS53cml0ZUludDMyKEEueCksZS53cml0ZUludDMyKEEueSksZS5sZW5ndGgtSX0sZGVjb2RlKEEpe2NvbnN0IGU9Zy5CZWJvcFZpZXcuZ2V0SW5zdGFuY2UoKTtyZXR1cm4gZS5zdGFydFJlYWRpbmcoQSksdGhpcy5yZWFkRnJvbShlKX0scmVhZEZyb20oQSl7bGV0IGUsSTtyZXR1cm4gZT1BLnJlYWRJbnQzMigpLEk9QS5yZWFkSW50MzIoKSx7eDplLHk6SX19fSxlLk1vdXNlUmVsYXRpdmU9e2Rpc2NyaW1pbmF0b3I6NCxlbmNvZGUoQSl7Y29uc3QgZT1nLkJlYm9wVmlldy5nZXRJbnN0YW5jZSgpO3JldHVybiBlLnN0YXJ0V3JpdGluZygpLHRoaXMuZW5jb2RlSW50byhBLGUpLGUudG9BcnJheSgpfSxlbmNvZGVJbnRvKEEsZSl7Y29uc3QgST1lLmxlbmd0aDtyZXR1cm4gZS53cml0ZUludDMyKEEuZHgpLGUud3JpdGVJbnQzMihBLmR5KSxlLmxlbmd0aC1JfSxkZWNvZGUoQSl7Y29uc3QgZT1nLkJlYm9wVmlldy5nZXRJbnN0YW5jZSgpO3JldHVybiBlLnN0YXJ0UmVhZGluZyhBKSx0aGlzLnJlYWRGcm9tKGUpfSxyZWFkRnJvbShBKXtsZXQgZSxJO3JldHVybiBlPUEucmVhZEludDMyKCksST1BLnJlYWRJbnQzMigpLHtkeDplLGR5Okl9fX0sZS5Nb3VzZUNsaWNrPXtkaXNjcmltaW5hdG9yOjUsZW5jb2RlKEEpe2NvbnN0IGU9Zy5CZWJvcFZpZXcuZ2V0SW5zdGFuY2UoKTtyZXR1cm4gZS5zdGFydFdyaXRpbmcoKSx0aGlzLmVuY29kZUludG8oQSxlKSxlLnRvQXJyYXkoKX0sZW5jb2RlSW50byhBLGUpe2NvbnN0IEk9ZS5sZW5ndGg7cmV0dXJuIGUud3JpdGVVaW50MzIoQS5hY3Rpb24pLGUud3JpdGVVaW50MzIoQS5idXR0b24pLGUubGVuZ3RoLUl9LGRlY29kZShBKXtjb25zdCBlPWcuQmVib3BWaWV3LmdldEluc3RhbmNlKCk7cmV0dXJuIGUuc3RhcnRSZWFkaW5nKEEpLHRoaXMucmVhZEZyb20oZSl9LHJlYWRGcm9tKEEpe2xldCBlLEk7cmV0dXJuIGU9QS5yZWFkVWludDMyKCksST1BLnJlYWRVaW50MzIoKSx7YWN0aW9uOmUsYnV0dG9uOkl9fX0sZS5Nb3VzZVNjcm9sbD17ZGlzY3JpbWluYXRvcjo2LGVuY29kZShBKXtjb25zdCBlPWcuQmVib3BWaWV3LmdldEluc3RhbmNlKCk7cmV0dXJuIGUuc3RhcnRXcml0aW5nKCksdGhpcy5lbmNvZGVJbnRvKEEsZSksZS50b0FycmF5KCl9LGVuY29kZUludG8oQSxlKXtjb25zdCBJPWUubGVuZ3RoO3JldHVybiBlLndyaXRlVWludDMyKEEuYXhpcyksZS53cml0ZUludDMyKEEuZGVsdGEpLGUubGVuZ3RoLUl9LGRlY29kZShBKXtjb25zdCBlPWcuQmVib3BWaWV3LmdldEluc3RhbmNlKCk7cmV0dXJuIGUuc3RhcnRSZWFkaW5nKEEpLHRoaXMucmVhZEZyb20oZSl9LHJlYWRGcm9tKEEpe2xldCBlLEk7cmV0dXJuIGU9QS5yZWFkVWludDMyKCksST1BLnJlYWRJbnQzMigpLHtheGlzOmUsZGVsdGE6SX19fSxlLktleWJvYXJkSW5wdXQ9e2Rpc2NyaW1pbmF0b3I6NyxlbmNvZGUoQSl7Y29uc3QgZT1nLkJlYm9wVmlldy5nZXRJbnN0YW5jZSgpO3JldHVybiBlLnN0YXJ0V3JpdGluZygpLHRoaXMuZW5jb2RlSW50byhBLGUpLGUudG9BcnJheSgpfSxlbmNvZGVJbnRvKEEsZSl7Y29uc3QgST1lLmxlbmd0aDtyZXR1cm4gZS53cml0ZVVpbnQzMihBLmFjdGlvbiksZS53cml0ZVVpbnQzMihBLmtleWNvZGUpLGUubGVuZ3RoLUl9LGRlY29kZShBKXtjb25zdCBlPWcuQmVib3BWaWV3LmdldEluc3RhbmNlKCk7cmV0dXJuIGUuc3RhcnRSZWFkaW5nKEEpLHRoaXMucmVhZEZyb20oZSl9LHJlYWRGcm9tKEEpe2xldCBlLEk7cmV0dXJuIGU9QS5yZWFkVWludDMyKCksST1BLnJlYWRVaW50MzIoKSx7YWN0aW9uOmUsa2V5Y29kZTpJfX19LGUuTG9naWNhbElucHV0PXtkaXNjcmltaW5hdG9yOjgsZW5jb2RlKEEpe2NvbnN0IGU9Zy5CZWJvcFZpZXcuZ2V0SW5zdGFuY2UoKTtyZXR1cm4gZS5zdGFydFdyaXRpbmcoKSx0aGlzLmVuY29kZUludG8oQSxlKSxlLnRvQXJyYXkoKX0sZW5jb2RlSW50byhBLGUpe2NvbnN0IEk9ZS5sZW5ndGg7cmV0dXJuIGUud3JpdGVTdHJpbmcoQS5pbnB1dFN0cmluZyksZS5sZW5ndGgtSX0sZGVjb2RlKEEpe2NvbnN0IGU9Zy5CZWJvcFZpZXcuZ2V0SW5zdGFuY2UoKTtyZXR1cm4gZS5zdGFydFJlYWRpbmcoQSksdGhpcy5yZWFkRnJvbShlKX0scmVhZEZyb20oQSl7bGV0IGU7cmV0dXJuIGU9QS5yZWFkU3RyaW5nKCkse2lucHV0U3RyaW5nOmV9fX0sZS5Ub3VjaGVzQWJzb2x1dGU9e2Rpc2NyaW1pbmF0b3I6OSxlbmNvZGUoQSl7Y29uc3QgZT1nLkJlYm9wVmlldy5nZXRJbnN0YW5jZSgpO3JldHVybiBlLnN0YXJ0V3JpdGluZygpLHRoaXMuZW5jb2RlSW50byhBLGUpLGUudG9BcnJheSgpfSxlbmNvZGVJbnRvKEEsSSl7Y29uc3QgZz1JLmxlbmd0aDt7Y29uc3QgZz1BLnRvdWNoZXMubGVuZ3RoO0kud3JpdGVVaW50MzIoZyk7Zm9yKGxldCB0PTA7dDxnO3QrKyllLlRvdWNoQWJzb2x1dGUuZW5jb2RlSW50byhBLnRvdWNoZXNbdF0sSSl9cmV0dXJuIEkubGVuZ3RoLWd9LGRlY29kZShBKXtjb25zdCBlPWcuQmVib3BWaWV3LmdldEluc3RhbmNlKCk7cmV0dXJuIGUuc3RhcnRSZWFkaW5nKEEpLHRoaXMucmVhZEZyb20oZSl9LHJlYWRGcm9tKEEpe2xldCBJO3tsZXQgZz1BLnJlYWRVaW50MzIoKTtJPW5ldyBBcnJheShnKTtmb3IobGV0IHQ9MDt0PGc7dCsrKXtsZXQgZztnPWUuVG91Y2hBYnNvbHV0ZS5yZWFkRnJvbShBKSxJW3RdPWd9fXJldHVybnt0b3VjaGVzOkl9fX0sZS5QZW5BYnNvbHV0ZT17ZGlzY3JpbWluYXRvcjoxMCxlbmNvZGUoQSl7Y29uc3QgZT1nLkJlYm9wVmlldy5nZXRJbnN0YW5jZSgpO3JldHVybiBlLnN0YXJ0V3JpdGluZygpLHRoaXMuZW5jb2RlSW50byhBLGUpLGUudG9BcnJheSgpfSxlbmNvZGVJbnRvKEEsSSl7Y29uc3QgZz1JLmxlbmd0aDtyZXR1cm4gZS5Ub3VjaFBlblBvaW50ZXJJbmZvLmVuY29kZUludG8oQS5wb2ludGVySW5mbyxJKSxJLndyaXRlVWludDMyKEEucGVuRmxhZ3MpLEkud3JpdGVVaW50MzIoQS5wZW5NYXNrKSxJLndyaXRlVWludDMyKEEucHJlc3N1cmUpLEkud3JpdGVVaW50MzIoQS5yb3RhdGlvbiksSS53cml0ZUludDMyKEEudGlsdFgpLEkud3JpdGVJbnQzMihBLnRpbHRZKSxJLmxlbmd0aC1nfSxkZWNvZGUoQSl7Y29uc3QgZT1nLkJlYm9wVmlldy5nZXRJbnN0YW5jZSgpO3JldHVybiBlLnN0YXJ0UmVhZGluZyhBKSx0aGlzLnJlYWRGcm9tKGUpfSxyZWFkRnJvbShBKXtsZXQgSSxnLHQsaSxCLEMsUTtyZXR1cm4gST1lLlRvdWNoUGVuUG9pbnRlckluZm8ucmVhZEZyb20oQSksZz1BLnJlYWRVaW50MzIoKSx0PUEucmVhZFVpbnQzMigpLGk9QS5yZWFkVWludDMyKCksQj1BLnJlYWRVaW50MzIoKSxDPUEucmVhZEludDMyKCksUT1BLnJlYWRJbnQzMigpLHtwb2ludGVySW5mbzpJLHBlbkZsYWdzOmcscGVuTWFzazp0LHByZXNzdXJlOmkscm90YXRpb246Qix0aWx0WDpDLHRpbHRZOlF9fX0sZS5WaWV3cG9ydFJlc2l6ZT17ZGlzY3JpbWluYXRvcjoxMSxlbmNvZGUoQSl7Y29uc3QgZT1nLkJlYm9wVmlldy5nZXRJbnN0YW5jZSgpO3JldHVybiBlLnN0YXJ0V3JpdGluZygpLHRoaXMuZW5jb2RlSW50byhBLGUpLGUudG9BcnJheSgpfSxlbmNvZGVJbnRvKEEsZSl7Y29uc3QgST1lLmxlbmd0aDtyZXR1cm4gZS53cml0ZVVpbnQzMihBLndpZHRoKSxlLndyaXRlVWludDMyKEEuaGVpZ2h0KSxlLmxlbmd0aC1JfSxkZWNvZGUoQSl7Y29uc3QgZT1nLkJlYm9wVmlldy5nZXRJbnN0YW5jZSgpO3JldHVybiBlLnN0YXJ0UmVhZGluZyhBKSx0aGlzLnJlYWRGcm9tKGUpfSxyZWFkRnJvbShBKXtsZXQgZSxJO3JldHVybiBlPUEucmVhZFVpbnQzMigpLEk9QS5yZWFkVWludDMyKCkse3dpZHRoOmUsaGVpZ2h0Okl9fX0sZS5TZXRDbGlwYm9hcmRUZXh0PXtkaXNjcmltaW5hdG9yOjEyLGVuY29kZShBKXtjb25zdCBlPWcuQmVib3BWaWV3LmdldEluc3RhbmNlKCk7cmV0dXJuIGUuc3RhcnRXcml0aW5nKCksdGhpcy5lbmNvZGVJbnRvKEEsZSksZS50b0FycmF5KCl9LGVuY29kZUludG8oQSxlKXtjb25zdCBJPWUubGVuZ3RoO3JldHVybiBlLndyaXRlU3RyaW5nKEEudGV4dCksZS5sZW5ndGgtSX0sZGVjb2RlKEEpe2NvbnN0IGU9Zy5CZWJvcFZpZXcuZ2V0SW5zdGFuY2UoKTtyZXR1cm4gZS5zdGFydFJlYWRpbmcoQSksdGhpcy5yZWFkRnJvbShlKX0scmVhZEZyb20oQSl7bGV0IGU7cmV0dXJuIGU9QS5yZWFkU3RyaW5nKCkse3RleHQ6ZX19fSxlLklucHV0Qm9keUlubmVyPXtlbmNvZGUoQSl7Y29uc3QgZT1nLkJlYm9wVmlldy5nZXRJbnN0YW5jZSgpO3JldHVybiBlLnN0YXJ0V3JpdGluZygpLHRoaXMuZW5jb2RlSW50byhBLGUpLGUudG9BcnJheSgpfSxlbmNvZGVJbnRvKEEsSSl7Y29uc3QgZz1JLmxlbmd0aCx0PUkucmVzZXJ2ZU1lc3NhZ2VMZW5ndGgoKSxpPUkubGVuZ3RoKzE7c3dpdGNoKEkud3JpdGVCeXRlKEEuZGlzY3JpbWluYXRvciksQS5kaXNjcmltaW5hdG9yKXtjYXNlIDE6ZS5HYW1lcGFkUmVwb3J0LmVuY29kZUludG8oQS52YWx1ZSxJKTticmVhaztjYXNlIDI6ZS5HYW1lcGFkUnVtYmxlLmVuY29kZUludG8oQS52YWx1ZSxJKTticmVhaztjYXNlIDM6ZS5Nb3VzZUFic29sdXRlLmVuY29kZUludG8oQS52YWx1ZSxJKTticmVhaztjYXNlIDQ6ZS5Nb3VzZVJlbGF0aXZlLmVuY29kZUludG8oQS52YWx1ZSxJKTticmVhaztjYXNlIDU6ZS5Nb3VzZUNsaWNrLmVuY29kZUludG8oQS52YWx1ZSxJKTticmVhaztjYXNlIDY6ZS5Nb3VzZVNjcm9sbC5lbmNvZGVJbnRvKEEudmFsdWUsSSk7YnJlYWs7Y2FzZSA3OmUuS2V5Ym9hcmRJbnB1dC5lbmNvZGVJbnRvKEEudmFsdWUsSSk7YnJlYWs7Y2FzZSA4OmUuTG9naWNhbElucHV0LmVuY29kZUludG8oQS52YWx1ZSxJKTticmVhaztjYXNlIDk6ZS5Ub3VjaGVzQWJzb2x1dGUuZW5jb2RlSW50byhBLnZhbHVlLEkpO2JyZWFrO2Nhc2UgMTA6ZS5QZW5BYnNvbHV0ZS5lbmNvZGVJbnRvKEEudmFsdWUsSSk7YnJlYWs7Y2FzZSAxMTplLlZpZXdwb3J0UmVzaXplLmVuY29kZUludG8oQS52YWx1ZSxJKTticmVhaztjYXNlIDEyOmUuU2V0Q2xpcGJvYXJkVGV4dC5lbmNvZGVJbnRvKEEudmFsdWUsSSl9Y29uc3QgQj1JLmxlbmd0aDtyZXR1cm4gSS5maWxsTWVzc2FnZUxlbmd0aCh0LEItaSksSS5sZW5ndGgtZ30sZGVjb2RlKEEpe2NvbnN0IGU9Zy5CZWJvcFZpZXcuZ2V0SW5zdGFuY2UoKTtyZXR1cm4gZS5zdGFydFJlYWRpbmcoQSksdGhpcy5yZWFkRnJvbShlKX0scmVhZEZyb20oQSl7Y29uc3QgST1BLnJlYWRNZXNzYWdlTGVuZ3RoKCksdD1BLmluZGV4KzErSTtzd2l0Y2goQS5yZWFkQnl0ZSgpKXtjYXNlIDE6cmV0dXJue2Rpc2NyaW1pbmF0b3I6MSx2YWx1ZTplLkdhbWVwYWRSZXBvcnQucmVhZEZyb20oQSl9O2Nhc2UgMjpyZXR1cm57ZGlzY3JpbWluYXRvcjoyLHZhbHVlOmUuR2FtZXBhZFJ1bWJsZS5yZWFkRnJvbShBKX07Y2FzZSAzOnJldHVybntkaXNjcmltaW5hdG9yOjMsdmFsdWU6ZS5Nb3VzZUFic29sdXRlLnJlYWRGcm9tKEEpfTtjYXNlIDQ6cmV0dXJue2Rpc2NyaW1pbmF0b3I6NCx2YWx1ZTplLk1vdXNlUmVsYXRpdmUucmVhZEZyb20oQSl9O2Nhc2UgNTpyZXR1cm57ZGlzY3JpbWluYXRvcjo1LHZhbHVlOmUuTW91c2VDbGljay5yZWFkRnJvbShBKX07Y2FzZSA2OnJldHVybntkaXNjcmltaW5hdG9yOjYsdmFsdWU6ZS5Nb3VzZVNjcm9sbC5yZWFkRnJvbShBKX07Y2FzZSA3OnJldHVybntkaXNjcmltaW5hdG9yOjcsdmFsdWU6ZS5LZXlib2FyZElucHV0LnJlYWRGcm9tKEEpfTtjYXNlIDg6cmV0dXJue2Rpc2NyaW1pbmF0b3I6OCx2YWx1ZTplLkxvZ2ljYWxJbnB1dC5yZWFkRnJvbShBKX07Y2FzZSA5OnJldHVybntkaXNjcmltaW5hdG9yOjksdmFsdWU6ZS5Ub3VjaGVzQWJzb2x1dGUucmVhZEZyb20oQSl9O2Nhc2UgMTA6cmV0dXJue2Rpc2NyaW1pbmF0b3I6MTAsdmFsdWU6ZS5QZW5BYnNvbHV0ZS5yZWFkRnJvbShBKX07Y2FzZSAxMTpyZXR1cm57ZGlzY3JpbWluYXRvcjoxMSx2YWx1ZTplLlZpZXdwb3J0UmVzaXplLnJlYWRGcm9tKEEpfTtjYXNlIDEyOnJldHVybntkaXNjcmltaW5hdG9yOjEyLHZhbHVlOmUuU2V0Q2xpcGJvYXJkVGV4dC5yZWFkRnJvbShBKX07ZGVmYXVsdDp0aHJvdyBBLmluZGV4PXQsbmV3IGcuQmVib3BSdW50aW1lRXJyb3IoXCJVbnJlY29nbml6ZWQgZGlzY3JpbWluYXRvciB3aGlsZSBkZWNvZGluZyBJbnB1dEJvZHlJbm5lclwiKX19fSxlLklucHV0Qm9keT17ZW5jb2RlKEEpe2NvbnN0IGU9Zy5CZWJvcFZpZXcuZ2V0SW5zdGFuY2UoKTtyZXR1cm4gZS5zdGFydFdyaXRpbmcoKSx0aGlzLmVuY29kZUludG8oQSxlKSxlLnRvQXJyYXkoKX0sZW5jb2RlSW50byhBLEkpe2NvbnN0IGc9SS5sZW5ndGg7cmV0dXJuIEkud3JpdGVCeXRlKEEuc3RyZWFtSWQpLGUuSW5wdXRCb2R5SW5uZXIuZW5jb2RlSW50byhBLmlubmVyLEkpLEkubGVuZ3RoLWd9LGRlY29kZShBKXtjb25zdCBlPWcuQmVib3BWaWV3LmdldEluc3RhbmNlKCk7cmV0dXJuIGUuc3RhcnRSZWFkaW5nKEEpLHRoaXMucmVhZEZyb20oZSl9LHJlYWRGcm9tKEEpe2xldCBJLGc7cmV0dXJuIEk9QS5yZWFkQnl0ZSgpLGc9ZS5JbnB1dEJvZHlJbm5lci5yZWFkRnJvbShBKSx7c3RyZWFtSWQ6SSxpbm5lcjpnfX19LChoPWUuVmlkZW9Db2RlY1R5cGV8fChlLlZpZGVvQ29kZWNUeXBlPXt9KSlbaC5CYXNlbGluZT0xXT1cIkJhc2VsaW5lXCIsaFtoLk1haW49Ml09XCJNYWluXCIsaFtoLkhpZ2g9NF09XCJIaWdoXCIsaFtoLkgyNjQ9N109XCJIMjY0XCIsaFtoLkgyNjU9OF09XCJIMjY1XCIsKGM9ZS5WZW5kb3J8fChlLlZlbmRvcj17fSkpW2MuVW5rbm93bj0wXT1cIlVua25vd25cIixjW2MuQW1kPTQwOThdPVwiQW1kXCIsY1tjLk52aWRpYT00MzE4XT1cIk52aWRpYVwiLGNbYy5JbnRlbD0zMjkwMl09XCJJbnRlbFwiLGUuVmlkZW9Db2RlYz17ZW5jb2RlKEEpe2NvbnN0IGU9Zy5CZWJvcFZpZXcuZ2V0SW5zdGFuY2UoKTtyZXR1cm4gZS5zdGFydFdyaXRpbmcoKSx0aGlzLmVuY29kZUludG8oQSxlKSxlLnRvQXJyYXkoKX0sZW5jb2RlSW50byhBLGUpe2NvbnN0IEk9ZS5sZW5ndGg7cmV0dXJuIGUud3JpdGVTdHJpbmcoQS5mcmllbmRseU5hbWUpLGUud3JpdGVVaW50MzIoQS53aWR0aCksZS53cml0ZVVpbnQzMihBLmhlaWdodCksZS53cml0ZVVpbnQzMihBLnJlZnJlc2hSYXRlKSxlLndyaXRlQnl0ZXMoQS5kYXRhKSxlLndyaXRlVWludDMyKEEudHlwZSksZS5sZW5ndGgtSX0sZGVjb2RlKEEpe2NvbnN0IGU9Zy5CZWJvcFZpZXcuZ2V0SW5zdGFuY2UoKTtyZXR1cm4gZS5zdGFydFJlYWRpbmcoQSksdGhpcy5yZWFkRnJvbShlKX0scmVhZEZyb20oQSl7bGV0IGUsSSxnLHQsaSxCO3JldHVybiBlPUEucmVhZFN0cmluZygpLEk9QS5yZWFkVWludDMyKCksZz1BLnJlYWRVaW50MzIoKSx0PUEucmVhZFVpbnQzMigpLGk9QS5yZWFkQnl0ZXMoKSxCPUEucmVhZFVpbnQzMigpLHtmcmllbmRseU5hbWU6ZSx3aWR0aDpJLGhlaWdodDpnLHJlZnJlc2hSYXRlOnQsZGF0YTppLHR5cGU6Qn19fSwoZD1lLkZvcm1GYWN0b3J8fChlLkZvcm1GYWN0b3I9e30pKVtkLlVua25vd249MF09XCJVbmtub3duXCIsZFtkLlBob25lPTFdPVwiUGhvbmVcIixkW2QuVGFibGV0PTJdPVwiVGFibGV0XCIsZFtkLkNvbXB1dGVyPTNdPVwiQ29tcHV0ZXJcIixkW2QuQ29uc29sZT00XT1cIkNvbnNvbGVcIixkW2QuVHY9NV09XCJUdlwiLChzPWUuT3BlcmF0aW5nU3lzdGVtfHwoZS5PcGVyYXRpbmdTeXN0ZW09e30pKVtzLk90aGVyPTBdPVwiT3RoZXJcIixzW3MuSU9TPTFdPVwiSU9TXCIsc1tzLlR2T1M9Ml09XCJUdk9TXCIsc1tzLkFuZHJvaWQ9M109XCJBbmRyb2lkXCIsc1tzLldpbmRvd3M9NF09XCJXaW5kb3dzXCIsc1tzLk1hY09TPTVdPVwiTWFjT1NcIixzW3MuTGludXg9Nl09XCJMaW51eFwiLHNbcy5Sb2t1PTddPVwiUm9rdVwiLChFPWUuTmV0d29ya1Byb3RvY29sfHwoZS5OZXR3b3JrUHJvdG9jb2w9e30pKVtFLldlYlJUQz0wXT1cIldlYlJUQ1wiLEVbRS5HZXlzZXI9MV09XCJHZXlzZXJcIiwocj1lLkF1ZGlvQ2hhbm5lbHN8fChlLkF1ZGlvQ2hhbm5lbHM9e30pKVtyLk1vbm89MF09XCJNb25vXCIscltyLlN0ZXJlbz0xXT1cIlN0ZXJlb1wiLHJbci5TdXJyb3VuZDUxPTJdPVwiU3Vycm91bmQ1MVwiLHJbci5TdXJyb3VuZDcxPTNdPVwiU3Vycm91bmQ3MVwiLChhPWUuQXVkaW9Db2RlY3x8KGUuQXVkaW9Db2RlYz17fSkpW2EuT3B1cz0wXT1cIk9wdXNcIixhW2EuQWFjPTFdPVwiQWFjXCIsKG49ZS5BdWRpb0NvbnRhaW5lcnx8KGUuQXVkaW9Db250YWluZXI9e30pKVtuLlJhdz0wXT1cIlJhd1wiLG5bbi5XZWJNPTFdPVwiV2ViTVwiLG5bbi5Jc29CTUZGPTJdPVwiSXNvQk1GRlwiLChvPWUuVmlkZW9Db250YWluZXJ8fChlLlZpZGVvQ29udGFpbmVyPXt9KSlbby5SYXc9MF09XCJSYXdcIixvW28uSXNvQk1GRj0xXT1cIklzb0JNRkZcIiwoUT1lLkxvZ2ljRXJyb3J8fChlLkxvZ2ljRXJyb3I9e30pKVtRLlVua25vd25FcnJvcj0wXT1cIlVua25vd25FcnJvclwiLFFbUS5EaXNwbGF5c01pc3Npbmc9MV09XCJEaXNwbGF5c01pc3NpbmdcIixRW1EuTm9BdmFpbGFibGVFbmNvZGVyPTJdPVwiTm9BdmFpbGFibGVFbmNvZGVyXCIsUVtRLkludmFsaWRFbmNvZGluZ0NvbmZpZz0zXT1cIkludmFsaWRFbmNvZGluZ0NvbmZpZ1wiLFFbUS5Ob0NvZGVjc0V4Y2hhbmdlZD00XT1cIk5vQ29kZWNzRXhjaGFuZ2VkXCIsUVtRLk5vQ2FwYWJpbGl0aWVzPTVdPVwiTm9DYXBhYmlsaXRpZXNcIixRW1EuTm9TdWNoU3RyZWFtPTZdPVwiTm9TdWNoU3RyZWFtXCIsUVtRLkZvcmNlU2VnbWVudEZhaWxlZD03XT1cIkZvcmNlU2VnbWVudEZhaWxlZFwiLGUuQXVkaW9Db25maWc9e2VuY29kZShBKXtjb25zdCBlPWcuQmVib3BWaWV3LmdldEluc3RhbmNlKCk7cmV0dXJuIGUuc3RhcnRXcml0aW5nKCksdGhpcy5lbmNvZGVJbnRvKEEsZSksZS50b0FycmF5KCl9LGVuY29kZUludG8oQSxlKXtjb25zdCBJPWUubGVuZ3RoO3JldHVybiBlLndyaXRlVWludDMyKEEuY29kZWMpLGUud3JpdGVVaW50MzIoQS5jb250YWluZXIpLGUubGVuZ3RoLUl9LGRlY29kZShBKXtjb25zdCBlPWcuQmVib3BWaWV3LmdldEluc3RhbmNlKCk7cmV0dXJuIGUuc3RhcnRSZWFkaW5nKEEpLHRoaXMucmVhZEZyb20oZSl9LHJlYWRGcm9tKEEpe2xldCBlLEk7cmV0dXJuIGU9QS5yZWFkVWludDMyKCksST1BLnJlYWRVaW50MzIoKSx7Y29kZWM6ZSxjb250YWluZXI6SX19fSwoQz1lLlN0cmVhbVR5cGV8fChlLlN0cmVhbVR5cGU9e30pKVtDLlVua25vd249MF09XCJVbmtub3duXCIsQ1tDLkZ1bGxEZXNrdG9wPTFdPVwiRnVsbERlc2t0b3BcIixDW0MuQXBwSXNvbGF0aW9uPTJdPVwiQXBwSXNvbGF0aW9uXCIsQ1tDLkJ5b2ZiPTNdPVwiQnlvZmJcIixlLlZpZGVvQ29uZmlnPXtlbmNvZGUoQSl7Y29uc3QgZT1nLkJlYm9wVmlldy5nZXRJbnN0YW5jZSgpO3JldHVybiBlLnN0YXJ0V3JpdGluZygpLHRoaXMuZW5jb2RlSW50byhBLGUpLGUudG9BcnJheSgpfSxlbmNvZGVJbnRvKEEsSSl7Y29uc3QgZz1JLmxlbmd0aDtyZXR1cm4gZS5WaWRlb0NvZGVjLmVuY29kZUludG8oQS5jb2RlYyxJKSxJLndyaXRlVWludDMyKEEuY29udGFpbmVyKSxJLmxlbmd0aC1nfSxkZWNvZGUoQSl7Y29uc3QgZT1nLkJlYm9wVmlldy5nZXRJbnN0YW5jZSgpO3JldHVybiBlLnN0YXJ0UmVhZGluZyhBKSx0aGlzLnJlYWRGcm9tKGUpfSxyZWFkRnJvbShBKXtsZXQgSSxnO3JldHVybiBJPWUuVmlkZW9Db2RlYy5yZWFkRnJvbShBKSxnPUEucmVhZFVpbnQzMigpLHtjb2RlYzpJLGNvbnRhaW5lcjpnfX19LChCPWUuSW5wdXRMZXZlbHx8KGUuSW5wdXRMZXZlbD17fSkpW0IuTm9uZT0wXT1cIk5vbmVcIixCW0IuR2FtZXBhZFBvcnQxPTFdPVwiR2FtZXBhZFBvcnQxXCIsQltCLkdhbWVwYWRQb3J0Mj0yXT1cIkdhbWVwYWRQb3J0MlwiLEJbQi5HYW1lcGFkUG9ydDM9NF09XCJHYW1lcGFkUG9ydDNcIixCW0IuR2FtZXBhZFBvcnQ0PThdPVwiR2FtZXBhZFBvcnQ0XCIsQltCLkdhbWVwYWQ9MTVdPVwiR2FtZXBhZFwiLEJbQi5Nb3VzZT0xNl09XCJNb3VzZVwiLEJbQi5LZXlib2FyZD0zMl09XCJLZXlib2FyZFwiLEJbQi5DbGlwYm9hcmQ9NjRdPVwiQ2xpcGJvYXJkXCIsQltCLkFsbD02M109XCJBbGxcIixlLlJlbW90ZVN0cmVhbUluZm89e2VuY29kZShBKXtjb25zdCBlPWcuQmVib3BWaWV3LmdldEluc3RhbmNlKCk7cmV0dXJuIGUuc3RhcnRXcml0aW5nKCksdGhpcy5lbmNvZGVJbnRvKEEsZSksZS50b0FycmF5KCl9LGVuY29kZUludG8oQSxJKXtjb25zdCBnPUkubGVuZ3RoO3JldHVybiBJLndyaXRlQnl0ZShBLnN0cmVhbUlkKSxJLndyaXRlVWludDMyKEEuc3RyZWFtVHlwZSksSS53cml0ZVVpbnQzMihBLmRlZmF1bHRJbnB1dExldmVsKSxJLndyaXRlRmxvYXQzMihBLnRlbXBvcmFsU2NhbGVGYWN0b3IpLGUuQXVkaW9Db25maWcuZW5jb2RlSW50byhBLmNob3NlbkF1ZGlvQ29uZmlnLEkpLGUuVmlkZW9Db25maWcuZW5jb2RlSW50byhBLmNob3NlblZpZGVvQ29uZmlnLEkpLEkubGVuZ3RoLWd9LGRlY29kZShBKXtjb25zdCBlPWcuQmVib3BWaWV3LmdldEluc3RhbmNlKCk7cmV0dXJuIGUuc3RhcnRSZWFkaW5nKEEpLHRoaXMucmVhZEZyb20oZSl9LHJlYWRGcm9tKEEpe2xldCBJLGcsdCxpLEIsQztyZXR1cm4gST1BLnJlYWRCeXRlKCksZz1BLnJlYWRVaW50MzIoKSx0PUEucmVhZFVpbnQzMigpLGk9QS5yZWFkRmxvYXQzMigpLEI9ZS5BdWRpb0NvbmZpZy5yZWFkRnJvbShBKSxDPWUuVmlkZW9Db25maWcucmVhZEZyb20oQSkse3N0cmVhbUlkOkksc3RyZWFtVHlwZTpnLGRlZmF1bHRJbnB1dExldmVsOnQsdGVtcG9yYWxTY2FsZUZhY3RvcjppLGNob3NlbkF1ZGlvQ29uZmlnOkIsY2hvc2VuVmlkZW9Db25maWc6Q319fSxlLkRldmljZUluZm89e2Rpc2NyaW1pbmF0b3I6MSxlbmNvZGUoQSl7Y29uc3QgZT1nLkJlYm9wVmlldy5nZXRJbnN0YW5jZSgpO3JldHVybiBlLnN0YXJ0V3JpdGluZygpLHRoaXMuZW5jb2RlSW50byhBLGUpLGUudG9BcnJheSgpfSxlbmNvZGVJbnRvKEEsZSl7Y29uc3QgST1lLmxlbmd0aDtyZXR1cm4gZS53cml0ZVVpbnQzMihBLmZvcm1GYWN0b3IpLGUud3JpdGVTdHJpbmcoQS5kZXZpY2VOYW1lKSxlLndyaXRlVWludDMyKEEuZGV2aWNlT3MpLGUud3JpdGVTdHJpbmcoQS5kZXZpY2VPc1ZlcnNpb24pLGUud3JpdGVTdHJpbmcoQS5kZXZpY2VNb2RlbCksZS53cml0ZVN0cmluZyhBLnVzZXJBZ2VudCksZS53cml0ZVN0cmluZyhBLmRldmljZUlkKSxlLndyaXRlQnl0ZShOdW1iZXIoQS5pc1dlYikpLGUubGVuZ3RoLUl9LGRlY29kZShBKXtjb25zdCBlPWcuQmVib3BWaWV3LmdldEluc3RhbmNlKCk7cmV0dXJuIGUuc3RhcnRSZWFkaW5nKEEpLHRoaXMucmVhZEZyb20oZSl9LHJlYWRGcm9tKEEpe2xldCBlLEksZyx0LGksQixDLFE7cmV0dXJuIGU9QS5yZWFkVWludDMyKCksST1BLnJlYWRTdHJpbmcoKSxnPUEucmVhZFVpbnQzMigpLHQ9QS5yZWFkU3RyaW5nKCksaT1BLnJlYWRTdHJpbmcoKSxCPUEucmVhZFN0cmluZygpLEM9QS5yZWFkU3RyaW5nKCksUT0hIUEucmVhZEJ5dGUoKSx7Zm9ybUZhY3RvcjplLGRldmljZU5hbWU6SSxkZXZpY2VPczpnLGRldmljZU9zVmVyc2lvbjp0LGRldmljZU1vZGVsOmksdXNlckFnZW50OkIsZGV2aWNlSWQ6Qyxpc1dlYjpRfX19LGUuQ29kZWNQYWNrUmVxdWVzdD17ZGlzY3JpbWluYXRvcjoyLGVuY29kZShBKXtjb25zdCBlPWcuQmVib3BWaWV3LmdldEluc3RhbmNlKCk7cmV0dXJuIGUuc3RhcnRXcml0aW5nKCksdGhpcy5lbmNvZGVJbnRvKEEsZSksZS50b0FycmF5KCl9LGVuY29kZUludG8oQSxlKXtjb25zdCBJPWUubGVuZ3RoO3JldHVybiBlLmxlbmd0aC1JfSxkZWNvZGUoQSl7Y29uc3QgZT1nLkJlYm9wVmlldy5nZXRJbnN0YW5jZSgpO3JldHVybiBlLnN0YXJ0UmVhZGluZyhBKSx0aGlzLnJlYWRGcm9tKGUpfSxyZWFkRnJvbTpBPT4oe30pfSxlLkNvZGVjUGFja1Jlc3BvbnNlPXtkaXNjcmltaW5hdG9yOjMsZW5jb2RlKEEpe2NvbnN0IGU9Zy5CZWJvcFZpZXcuZ2V0SW5zdGFuY2UoKTtyZXR1cm4gZS5zdGFydFdyaXRpbmcoKSx0aGlzLmVuY29kZUludG8oQSxlKSxlLnRvQXJyYXkoKX0sZW5jb2RlSW50byhBLEkpe2NvbnN0IGc9SS5sZW5ndGg7e2NvbnN0IGc9QS52aWRlb0NvZGVjcy5sZW5ndGg7SS53cml0ZVVpbnQzMihnKTtmb3IobGV0IHQ9MDt0PGc7dCsrKWUuVmlkZW9Db2RlYy5lbmNvZGVJbnRvKEEudmlkZW9Db2RlY3NbdF0sSSl9cmV0dXJuIEkubGVuZ3RoLWd9LGRlY29kZShBKXtjb25zdCBlPWcuQmVib3BWaWV3LmdldEluc3RhbmNlKCk7cmV0dXJuIGUuc3RhcnRSZWFkaW5nKEEpLHRoaXMucmVhZEZyb20oZSl9LHJlYWRGcm9tKEEpe2xldCBJO3tsZXQgZz1BLnJlYWRVaW50MzIoKTtJPW5ldyBBcnJheShnKTtmb3IobGV0IHQ9MDt0PGc7dCsrKXtsZXQgZztnPWUuVmlkZW9Db2RlYy5yZWFkRnJvbShBKSxJW3RdPWd9fXJldHVybnt2aWRlb0NvZGVjczpJfX19LGUuQ2xpZW50Q2FwYWJpbGl0aWVzPXtkaXNjcmltaW5hdG9yOjQsZW5jb2RlKEEpe2NvbnN0IGU9Zy5CZWJvcFZpZXcuZ2V0SW5zdGFuY2UoKTtyZXR1cm4gZS5zdGFydFdyaXRpbmcoKSx0aGlzLmVuY29kZUludG8oQSxlKSxlLnRvQXJyYXkoKX0sZW5jb2RlSW50byhBLEkpe2NvbnN0IGc9SS5sZW5ndGg7SS53cml0ZVVpbnQzMihBLnByZWZlcnJlZFdpZHRoKSxJLndyaXRlVWludDMyKEEucHJlZmVycmVkSGVpZ2h0KSxJLndyaXRlVWludDMyKEEucHJlZmVycmVkRnBzKSxJLndyaXRlVWludDMyKEEucHJlZmVycmVkQXVkaW9CaXRyYXRlKSxJLndyaXRlVWludDMyKEEucHJlZmVycmVkVmlkZW9CaXRyYXRlKSxJLndyaXRlVWludDMyKEEucHJlZmVycmVkQXVkaW9DaGFubmVscyksZS5BdWRpb0NvbmZpZy5lbmNvZGVJbnRvKEEucHJlZmVycmVkQXVkaW9Db25maWcsSSksZS5WaWRlb0NvbmZpZy5lbmNvZGVJbnRvKEEucHJlZmVycmVkVmlkZW9Db25maWcsSSk7e2NvbnN0IGU9QS5zdXBwb3J0ZWRBdWRpb0NoYW5uZWxzLmxlbmd0aDtJLndyaXRlVWludDMyKGUpO2ZvcihsZXQgZz0wO2c8ZTtnKyspSS53cml0ZVVpbnQzMihBLnN1cHBvcnRlZEF1ZGlvQ2hhbm5lbHNbZ10pfXtjb25zdCBnPUEuc3VwcG9ydGVkQXVkaW9Db25maWdzLmxlbmd0aDtJLndyaXRlVWludDMyKGcpO2ZvcihsZXQgdD0wO3Q8Zzt0KyspZS5BdWRpb0NvbmZpZy5lbmNvZGVJbnRvKEEuc3VwcG9ydGVkQXVkaW9Db25maWdzW3RdLEkpfXtjb25zdCBnPUEuc3VwcG9ydGVkVmlkZW9Db25maWdzLmxlbmd0aDtJLndyaXRlVWludDMyKGcpO2ZvcihsZXQgdD0wO3Q8Zzt0KyspZS5WaWRlb0NvbmZpZy5lbmNvZGVJbnRvKEEuc3VwcG9ydGVkVmlkZW9Db25maWdzW3RdLEkpfXJldHVybiBJLndyaXRlQnl0ZShOdW1iZXIoQS5zdXBwb3J0c092ZXIxMDgwUCkpLEkud3JpdGVCeXRlKE51bWJlcihBLnN1cHBvcnRzVGVtcG9yYWxTY2FsaW5nKSksSS53cml0ZUJ5dGUoTnVtYmVyKEEuc3VwcG9ydHNBcHBJc29sYXRpb24pKSxJLmxlbmd0aC1nfSxkZWNvZGUoQSl7Y29uc3QgZT1nLkJlYm9wVmlldy5nZXRJbnN0YW5jZSgpO3JldHVybiBlLnN0YXJ0UmVhZGluZyhBKSx0aGlzLnJlYWRGcm9tKGUpfSxyZWFkRnJvbShBKXtsZXQgSSxnLHQsaSxCLEMsUSxvLG4sYSxyLEUscyxkO0k9QS5yZWFkVWludDMyKCksZz1BLnJlYWRVaW50MzIoKSx0PUEucmVhZFVpbnQzMigpLGk9QS5yZWFkVWludDMyKCksQj1BLnJlYWRVaW50MzIoKSxDPUEucmVhZFVpbnQzMigpLFE9ZS5BdWRpb0NvbmZpZy5yZWFkRnJvbShBKSxvPWUuVmlkZW9Db25maWcucmVhZEZyb20oQSk7e2xldCBlPUEucmVhZFVpbnQzMigpO249bmV3IEFycmF5KGUpO2ZvcihsZXQgST0wO0k8ZTtJKyspe2xldCBlO2U9QS5yZWFkVWludDMyKCksbltJXT1lfX17bGV0IEk9QS5yZWFkVWludDMyKCk7YT1uZXcgQXJyYXkoSSk7Zm9yKGxldCBnPTA7ZzxJO2crKyl7bGV0IEk7ST1lLkF1ZGlvQ29uZmlnLnJlYWRGcm9tKEEpLGFbZ109SX19e2xldCBJPUEucmVhZFVpbnQzMigpO3I9bmV3IEFycmF5KEkpO2ZvcihsZXQgZz0wO2c8STtnKyspe2xldCBJO0k9ZS5WaWRlb0NvbmZpZy5yZWFkRnJvbShBKSxyW2ddPUl9fXJldHVybiBFPSEhQS5yZWFkQnl0ZSgpLHM9ISFBLnJlYWRCeXRlKCksZD0hIUEucmVhZEJ5dGUoKSx7cHJlZmVycmVkV2lkdGg6SSxwcmVmZXJyZWRIZWlnaHQ6ZyxwcmVmZXJyZWRGcHM6dCxwcmVmZXJyZWRBdWRpb0JpdHJhdGU6aSxwcmVmZXJyZWRWaWRlb0JpdHJhdGU6QixwcmVmZXJyZWRBdWRpb0NoYW5uZWxzOkMscHJlZmVycmVkQXVkaW9Db25maWc6USxwcmVmZXJyZWRWaWRlb0NvbmZpZzpvLHN1cHBvcnRlZEF1ZGlvQ2hhbm5lbHM6bixzdXBwb3J0ZWRBdWRpb0NvbmZpZ3M6YSxzdXBwb3J0ZWRWaWRlb0NvbmZpZ3M6cixzdXBwb3J0c092ZXIxMDgwUDpFLHN1cHBvcnRzVGVtcG9yYWxTY2FsaW5nOnMsc3VwcG9ydHNBcHBJc29sYXRpb246ZH19fSxlLkVycm9yUmVzcG9uc2U9e2Rpc2NyaW1pbmF0b3I6NSxlbmNvZGUoQSl7Y29uc3QgZT1nLkJlYm9wVmlldy5nZXRJbnN0YW5jZSgpO3JldHVybiBlLnN0YXJ0V3JpdGluZygpLHRoaXMuZW5jb2RlSW50byhBLGUpLGUudG9BcnJheSgpfSxlbmNvZGVJbnRvKEEsZSl7Y29uc3QgST1lLmxlbmd0aDtyZXR1cm4gZS53cml0ZVVpbnQzMihBLmVycm9yKSxlLmxlbmd0aC1JfSxkZWNvZGUoQSl7Y29uc3QgZT1nLkJlYm9wVmlldy5nZXRJbnN0YW5jZSgpO3JldHVybiBlLnN0YXJ0UmVhZGluZyhBKSx0aGlzLnJlYWRGcm9tKGUpfSxyZWFkRnJvbShBKXtsZXQgZTtyZXR1cm4gZT1BLnJlYWRVaW50MzIoKSx7ZXJyb3I6ZX19fSxlLlN0cmVhbVJlcXVlc3Q9e2Rpc2NyaW1pbmF0b3I6NixlbmNvZGUoQSl7Y29uc3QgZT1nLkJlYm9wVmlldy5nZXRJbnN0YW5jZSgpO3JldHVybiBlLnN0YXJ0V3JpdGluZygpLHRoaXMuZW5jb2RlSW50byhBLGUpLGUudG9BcnJheSgpfSxlbmNvZGVJbnRvKEEsZSl7Y29uc3QgST1lLmxlbmd0aDtyZXR1cm4gZS53cml0ZVVpbnQzMihBLmlucHV0TGV2ZWwpLGUubGVuZ3RoLUl9LGRlY29kZShBKXtjb25zdCBlPWcuQmVib3BWaWV3LmdldEluc3RhbmNlKCk7cmV0dXJuIGUuc3RhcnRSZWFkaW5nKEEpLHRoaXMucmVhZEZyb20oZSl9LHJlYWRGcm9tKEEpe2xldCBlO3JldHVybiBlPUEucmVhZFVpbnQzMigpLHtpbnB1dExldmVsOmV9fX0sZS5MZWF2ZVN0cmVhbT17ZGlzY3JpbWluYXRvcjo4LGVuY29kZShBKXtjb25zdCBlPWcuQmVib3BWaWV3LmdldEluc3RhbmNlKCk7cmV0dXJuIGUuc3RhcnRXcml0aW5nKCksdGhpcy5lbmNvZGVJbnRvKEEsZSksZS50b0FycmF5KCl9LGVuY29kZUludG8oQSxlKXtjb25zdCBJPWUubGVuZ3RoO3JldHVybiBlLndyaXRlQnl0ZShBLnN0cmVhbUlkKSxlLmxlbmd0aC1JfSxkZWNvZGUoQSl7Y29uc3QgZT1nLkJlYm9wVmlldy5nZXRJbnN0YW5jZSgpO3JldHVybiBlLnN0YXJ0UmVhZGluZyhBKSx0aGlzLnJlYWRGcm9tKGUpfSxyZWFkRnJvbShBKXtsZXQgZTtyZXR1cm4gZT1BLnJlYWRCeXRlKCkse3N0cmVhbUlkOmV9fX0sZS5TdHJlYW1TdG9wcGluZz17ZGlzY3JpbWluYXRvcjo5LGVuY29kZShBKXtjb25zdCBlPWcuQmVib3BWaWV3LmdldEluc3RhbmNlKCk7cmV0dXJuIGUuc3RhcnRXcml0aW5nKCksdGhpcy5lbmNvZGVJbnRvKEEsZSksZS50b0FycmF5KCl9LGVuY29kZUludG8oQSxlKXtjb25zdCBJPWUubGVuZ3RoO3JldHVybiBlLndyaXRlQnl0ZShBLnN0cmVhbUlkKSxlLmxlbmd0aC1JfSxkZWNvZGUoQSl7Y29uc3QgZT1nLkJlYm9wVmlldy5nZXRJbnN0YW5jZSgpO3JldHVybiBlLnN0YXJ0UmVhZGluZyhBKSx0aGlzLnJlYWRGcm9tKGUpfSxyZWFkRnJvbShBKXtsZXQgZTtyZXR1cm4gZT1BLnJlYWRCeXRlKCkse3N0cmVhbUlkOmV9fX0sZS5LZXlmcmFtZVJlcXVlc3Q9e2Rpc2NyaW1pbmF0b3I6MTAsZW5jb2RlKEEpe2NvbnN0IGU9Zy5CZWJvcFZpZXcuZ2V0SW5zdGFuY2UoKTtyZXR1cm4gZS5zdGFydFdyaXRpbmcoKSx0aGlzLmVuY29kZUludG8oQSxlKSxlLnRvQXJyYXkoKX0sZW5jb2RlSW50byhBLGUpe2NvbnN0IEk9ZS5sZW5ndGg7cmV0dXJuIGUud3JpdGVCeXRlKEEuc3RyZWFtSWQpLGUubGVuZ3RoLUl9LGRlY29kZShBKXtjb25zdCBlPWcuQmVib3BWaWV3LmdldEluc3RhbmNlKCk7cmV0dXJuIGUuc3RhcnRSZWFkaW5nKEEpLHRoaXMucmVhZEZyb20oZSl9LHJlYWRGcm9tKEEpe2xldCBlO3JldHVybiBlPUEucmVhZEJ5dGUoKSx7c3RyZWFtSWQ6ZX19fSxlLlZpZGVvQml0cmF0ZVJlcXVlc3Q9e2Rpc2NyaW1pbmF0b3I6MTEsZW5jb2RlKEEpe2NvbnN0IGU9Zy5CZWJvcFZpZXcuZ2V0SW5zdGFuY2UoKTtyZXR1cm4gZS5zdGFydFdyaXRpbmcoKSx0aGlzLmVuY29kZUludG8oQSxlKSxlLnRvQXJyYXkoKX0sZW5jb2RlSW50byhBLGUpe2NvbnN0IEk9ZS5sZW5ndGg7cmV0dXJuIGUud3JpdGVCeXRlKEEuc3RyZWFtSWQpLGUud3JpdGVVaW50MzIoQS5iaXRzUGVyU2Vjb25kKSxlLmxlbmd0aC1JfSxkZWNvZGUoQSl7Y29uc3QgZT1nLkJlYm9wVmlldy5nZXRJbnN0YW5jZSgpO3JldHVybiBlLnN0YXJ0UmVhZGluZyhBKSx0aGlzLnJlYWRGcm9tKGUpfSxyZWFkRnJvbShBKXtsZXQgZSxJO3JldHVybiBlPUEucmVhZEJ5dGUoKSxJPUEucmVhZFVpbnQzMigpLHtzdHJlYW1JZDplLGJpdHNQZXJTZWNvbmQ6SX19fSxlLkpvaW5TdHJlYW09e2Rpc2NyaW1pbmF0b3I6MTIsZW5jb2RlKEEpe2NvbnN0IGU9Zy5CZWJvcFZpZXcuZ2V0SW5zdGFuY2UoKTtyZXR1cm4gZS5zdGFydFdyaXRpbmcoKSx0aGlzLmVuY29kZUludG8oQSxlKSxlLnRvQXJyYXkoKX0sZW5jb2RlSW50byhBLGUpe2NvbnN0IEk9ZS5sZW5ndGg7cmV0dXJuIGUud3JpdGVCeXRlKEEuc3RyZWFtSWQpLGUubGVuZ3RoLUl9LGRlY29kZShBKXtjb25zdCBlPWcuQmVib3BWaWV3LmdldEluc3RhbmNlKCk7cmV0dXJuIGUuc3RhcnRSZWFkaW5nKEEpLHRoaXMucmVhZEZyb20oZSl9LHJlYWRGcm9tKEEpe2xldCBlO3JldHVybiBlPUEucmVhZEJ5dGUoKSx7c3RyZWFtSWQ6ZX19fSxlLlBhdXNlU3RyZWFtPXtkaXNjcmltaW5hdG9yOjEzLGVuY29kZShBKXtjb25zdCBlPWcuQmVib3BWaWV3LmdldEluc3RhbmNlKCk7cmV0dXJuIGUuc3RhcnRXcml0aW5nKCksdGhpcy5lbmNvZGVJbnRvKEEsZSksZS50b0FycmF5KCl9LGVuY29kZUludG8oQSxlKXtjb25zdCBJPWUubGVuZ3RoO3JldHVybiBlLndyaXRlQnl0ZShBLnN0cmVhbUlkKSxlLmxlbmd0aC1JfSxkZWNvZGUoQSl7Y29uc3QgZT1nLkJlYm9wVmlldy5nZXRJbnN0YW5jZSgpO3JldHVybiBlLnN0YXJ0UmVhZGluZyhBKSx0aGlzLnJlYWRGcm9tKGUpfSxyZWFkRnJvbShBKXtsZXQgZTtyZXR1cm4gZT1BLnJlYWRCeXRlKCkse3N0cmVhbUlkOmV9fX0sZS5SZWplY3RTdHJlYW1SZXF1ZXN0PXtkaXNjcmltaW5hdG9yOjE0LGVuY29kZShBKXtjb25zdCBlPWcuQmVib3BWaWV3LmdldEluc3RhbmNlKCk7cmV0dXJuIGUuc3RhcnRXcml0aW5nKCksdGhpcy5lbmNvZGVJbnRvKEEsZSksZS50b0FycmF5KCl9LGVuY29kZUludG8oQSxlKXtjb25zdCBJPWUubGVuZ3RoO3JldHVybiBlLndyaXRlU3RyaW5nKEEucmVhc29uKSxlLmxlbmd0aC1JfSxkZWNvZGUoQSl7Y29uc3QgZT1nLkJlYm9wVmlldy5nZXRJbnN0YW5jZSgpO3JldHVybiBlLnN0YXJ0UmVhZGluZyhBKSx0aGlzLnJlYWRGcm9tKGUpfSxyZWFkRnJvbShBKXtsZXQgZTtyZXR1cm4gZT1BLnJlYWRTdHJpbmcoKSx7cmVhc29uOmV9fX0sZS5JbnB1dExldmVsVXBkYXRlPXtkaXNjcmltaW5hdG9yOjE1LGVuY29kZShBKXtjb25zdCBlPWcuQmVib3BWaWV3LmdldEluc3RhbmNlKCk7cmV0dXJuIGUuc3RhcnRXcml0aW5nKCksdGhpcy5lbmNvZGVJbnRvKEEsZSksZS50b0FycmF5KCl9LGVuY29kZUludG8oQSxlKXtjb25zdCBJPWUubGVuZ3RoO3JldHVybiBlLndyaXRlQnl0ZShBLnN0cmVhbUlkKSxlLndyaXRlVWludDMyKEEuaW5wdXRMZXZlbCksZS5sZW5ndGgtSX0sZGVjb2RlKEEpe2NvbnN0IGU9Zy5CZWJvcFZpZXcuZ2V0SW5zdGFuY2UoKTtyZXR1cm4gZS5zdGFydFJlYWRpbmcoQSksdGhpcy5yZWFkRnJvbShlKX0scmVhZEZyb20oQSl7bGV0IGUsSTtyZXR1cm4gZT1BLnJlYWRCeXRlKCksST1BLnJlYWRVaW50MzIoKSx7c3RyZWFtSWQ6ZSxpbnB1dExldmVsOkl9fX0sZS5JbnB1dExldmVsUmVxdWVzdD17ZGlzY3JpbWluYXRvcjoxNixlbmNvZGUoQSl7Y29uc3QgZT1nLkJlYm9wVmlldy5nZXRJbnN0YW5jZSgpO3JldHVybiBlLnN0YXJ0V3JpdGluZygpLHRoaXMuZW5jb2RlSW50byhBLGUpLGUudG9BcnJheSgpfSxlbmNvZGVJbnRvKEEsZSl7Y29uc3QgST1lLmxlbmd0aDtyZXR1cm4gZS53cml0ZUJ5dGUoQS5zdHJlYW1JZCksZS53cml0ZVVpbnQzMihBLmlucHV0TGV2ZWwpLGUubGVuZ3RoLUl9LGRlY29kZShBKXtjb25zdCBlPWcuQmVib3BWaWV3LmdldEluc3RhbmNlKCk7cmV0dXJuIGUuc3RhcnRSZWFkaW5nKEEpLHRoaXMucmVhZEZyb20oZSl9LHJlYWRGcm9tKEEpe2xldCBlLEk7cmV0dXJuIGU9QS5yZWFkQnl0ZSgpLEk9QS5yZWFkVWludDMyKCkse3N0cmVhbUlkOmUsaW5wdXRMZXZlbDpJfX19LGUuU3RyZWFtQW5ub3VuY2VtZW50PXtkaXNjcmltaW5hdG9yOjE3LGVuY29kZShBKXtjb25zdCBlPWcuQmVib3BWaWV3LmdldEluc3RhbmNlKCk7cmV0dXJuIGUuc3RhcnRXcml0aW5nKCksdGhpcy5lbmNvZGVJbnRvKEEsZSksZS50b0FycmF5KCl9LGVuY29kZUludG8oQSxJKXtjb25zdCBnPUkubGVuZ3RoO3JldHVybiBlLlJlbW90ZVN0cmVhbUluZm8uZW5jb2RlSW50byhBLnN0cmVhbUluZm8sSSksSS5sZW5ndGgtZ30sZGVjb2RlKEEpe2NvbnN0IGU9Zy5CZWJvcFZpZXcuZ2V0SW5zdGFuY2UoKTtyZXR1cm4gZS5zdGFydFJlYWRpbmcoQSksdGhpcy5yZWFkRnJvbShlKX0scmVhZEZyb20oQSl7bGV0IEk7cmV0dXJuIEk9ZS5SZW1vdGVTdHJlYW1JbmZvLnJlYWRGcm9tKEEpLHtzdHJlYW1JbmZvOkl9fX0sZS5MaXN0U3RyZWFtcz17ZGlzY3JpbWluYXRvcjoxOCxlbmNvZGUoQSl7Y29uc3QgZT1nLkJlYm9wVmlldy5nZXRJbnN0YW5jZSgpO3JldHVybiBlLnN0YXJ0V3JpdGluZygpLHRoaXMuZW5jb2RlSW50byhBLGUpLGUudG9BcnJheSgpfSxlbmNvZGVJbnRvKEEsZSl7Y29uc3QgST1lLmxlbmd0aDtyZXR1cm4gZS5sZW5ndGgtSX0sZGVjb2RlKEEpe2NvbnN0IGU9Zy5CZWJvcFZpZXcuZ2V0SW5zdGFuY2UoKTtyZXR1cm4gZS5zdGFydFJlYWRpbmcoQSksdGhpcy5yZWFkRnJvbShlKX0scmVhZEZyb206QT0+KHt9KX0sZS5Mb2dpY0JvZHk9e2VuY29kZShBKXtjb25zdCBlPWcuQmVib3BWaWV3LmdldEluc3RhbmNlKCk7cmV0dXJuIGUuc3RhcnRXcml0aW5nKCksdGhpcy5lbmNvZGVJbnRvKEEsZSksZS50b0FycmF5KCl9LGVuY29kZUludG8oQSxJKXtjb25zdCBnPUkubGVuZ3RoLHQ9SS5yZXNlcnZlTWVzc2FnZUxlbmd0aCgpLGk9SS5sZW5ndGgrMTtzd2l0Y2goSS53cml0ZUJ5dGUoQS5kaXNjcmltaW5hdG9yKSxBLmRpc2NyaW1pbmF0b3Ipe2Nhc2UgMTplLkRldmljZUluZm8uZW5jb2RlSW50byhBLnZhbHVlLEkpO2JyZWFrO2Nhc2UgMjplLkNvZGVjUGFja1JlcXVlc3QuZW5jb2RlSW50byhBLnZhbHVlLEkpO2JyZWFrO2Nhc2UgMzplLkNvZGVjUGFja1Jlc3BvbnNlLmVuY29kZUludG8oQS52YWx1ZSxJKTticmVhaztjYXNlIDQ6ZS5DbGllbnRDYXBhYmlsaXRpZXMuZW5jb2RlSW50byhBLnZhbHVlLEkpO2JyZWFrO2Nhc2UgNTplLkVycm9yUmVzcG9uc2UuZW5jb2RlSW50byhBLnZhbHVlLEkpO2JyZWFrO2Nhc2UgNjplLlN0cmVhbVJlcXVlc3QuZW5jb2RlSW50byhBLnZhbHVlLEkpO2JyZWFrO2Nhc2UgODplLkxlYXZlU3RyZWFtLmVuY29kZUludG8oQS52YWx1ZSxJKTticmVhaztjYXNlIDk6ZS5TdHJlYW1TdG9wcGluZy5lbmNvZGVJbnRvKEEudmFsdWUsSSk7YnJlYWs7Y2FzZSAxMDplLktleWZyYW1lUmVxdWVzdC5lbmNvZGVJbnRvKEEudmFsdWUsSSk7YnJlYWs7Y2FzZSAxMTplLlZpZGVvQml0cmF0ZVJlcXVlc3QuZW5jb2RlSW50byhBLnZhbHVlLEkpO2JyZWFrO2Nhc2UgMTI6ZS5Kb2luU3RyZWFtLmVuY29kZUludG8oQS52YWx1ZSxJKTticmVhaztjYXNlIDEzOmUuUGF1c2VTdHJlYW0uZW5jb2RlSW50byhBLnZhbHVlLEkpO2JyZWFrO2Nhc2UgMTQ6ZS5SZWplY3RTdHJlYW1SZXF1ZXN0LmVuY29kZUludG8oQS52YWx1ZSxJKTticmVhaztjYXNlIDE1OmUuSW5wdXRMZXZlbFVwZGF0ZS5lbmNvZGVJbnRvKEEudmFsdWUsSSk7YnJlYWs7Y2FzZSAxNjplLklucHV0TGV2ZWxSZXF1ZXN0LmVuY29kZUludG8oQS52YWx1ZSxJKTticmVhaztjYXNlIDE3OmUuU3RyZWFtQW5ub3VuY2VtZW50LmVuY29kZUludG8oQS52YWx1ZSxJKTticmVhaztjYXNlIDE4OmUuTGlzdFN0cmVhbXMuZW5jb2RlSW50byhBLnZhbHVlLEkpfWNvbnN0IEI9SS5sZW5ndGg7cmV0dXJuIEkuZmlsbE1lc3NhZ2VMZW5ndGgodCxCLWkpLEkubGVuZ3RoLWd9LGRlY29kZShBKXtjb25zdCBlPWcuQmVib3BWaWV3LmdldEluc3RhbmNlKCk7cmV0dXJuIGUuc3RhcnRSZWFkaW5nKEEpLHRoaXMucmVhZEZyb20oZSl9LHJlYWRGcm9tKEEpe2NvbnN0IEk9QS5yZWFkTWVzc2FnZUxlbmd0aCgpLHQ9QS5pbmRleCsxK0k7c3dpdGNoKEEucmVhZEJ5dGUoKSl7Y2FzZSAxOnJldHVybntkaXNjcmltaW5hdG9yOjEsdmFsdWU6ZS5EZXZpY2VJbmZvLnJlYWRGcm9tKEEpfTtjYXNlIDI6cmV0dXJue2Rpc2NyaW1pbmF0b3I6Mix2YWx1ZTplLkNvZGVjUGFja1JlcXVlc3QucmVhZEZyb20oQSl9O2Nhc2UgMzpyZXR1cm57ZGlzY3JpbWluYXRvcjozLHZhbHVlOmUuQ29kZWNQYWNrUmVzcG9uc2UucmVhZEZyb20oQSl9O2Nhc2UgNDpyZXR1cm57ZGlzY3JpbWluYXRvcjo0LHZhbHVlOmUuQ2xpZW50Q2FwYWJpbGl0aWVzLnJlYWRGcm9tKEEpfTtjYXNlIDU6cmV0dXJue2Rpc2NyaW1pbmF0b3I6NSx2YWx1ZTplLkVycm9yUmVzcG9uc2UucmVhZEZyb20oQSl9O2Nhc2UgNjpyZXR1cm57ZGlzY3JpbWluYXRvcjo2LHZhbHVlOmUuU3RyZWFtUmVxdWVzdC5yZWFkRnJvbShBKX07Y2FzZSA4OnJldHVybntkaXNjcmltaW5hdG9yOjgsdmFsdWU6ZS5MZWF2ZVN0cmVhbS5yZWFkRnJvbShBKX07Y2FzZSA5OnJldHVybntkaXNjcmltaW5hdG9yOjksdmFsdWU6ZS5TdHJlYW1TdG9wcGluZy5yZWFkRnJvbShBKX07Y2FzZSAxMDpyZXR1cm57ZGlzY3JpbWluYXRvcjoxMCx2YWx1ZTplLktleWZyYW1lUmVxdWVzdC5yZWFkRnJvbShBKX07Y2FzZSAxMTpyZXR1cm57ZGlzY3JpbWluYXRvcjoxMSx2YWx1ZTplLlZpZGVvQml0cmF0ZVJlcXVlc3QucmVhZEZyb20oQSl9O2Nhc2UgMTI6cmV0dXJue2Rpc2NyaW1pbmF0b3I6MTIsdmFsdWU6ZS5Kb2luU3RyZWFtLnJlYWRGcm9tKEEpfTtjYXNlIDEzOnJldHVybntkaXNjcmltaW5hdG9yOjEzLHZhbHVlOmUuUGF1c2VTdHJlYW0ucmVhZEZyb20oQSl9O2Nhc2UgMTQ6cmV0dXJue2Rpc2NyaW1pbmF0b3I6MTQsdmFsdWU6ZS5SZWplY3RTdHJlYW1SZXF1ZXN0LnJlYWRGcm9tKEEpfTtjYXNlIDE1OnJldHVybntkaXNjcmltaW5hdG9yOjE1LHZhbHVlOmUuSW5wdXRMZXZlbFVwZGF0ZS5yZWFkRnJvbShBKX07Y2FzZSAxNjpyZXR1cm57ZGlzY3JpbWluYXRvcjoxNix2YWx1ZTplLklucHV0TGV2ZWxSZXF1ZXN0LnJlYWRGcm9tKEEpfTtjYXNlIDE3OnJldHVybntkaXNjcmltaW5hdG9yOjE3LHZhbHVlOmUuU3RyZWFtQW5ub3VuY2VtZW50LnJlYWRGcm9tKEEpfTtjYXNlIDE4OnJldHVybntkaXNjcmltaW5hdG9yOjE4LHZhbHVlOmUuTGlzdFN0cmVhbXMucmVhZEZyb20oQSl9O2RlZmF1bHQ6dGhyb3cgQS5pbmRleD10LG5ldyBnLkJlYm9wUnVudGltZUVycm9yKFwiVW5yZWNvZ25pemVkIGRpc2NyaW1pbmF0b3Igd2hpbGUgZGVjb2RpbmcgTG9naWNCb2R5XCIpfX19LChpPWUuVmlkZW9EYXRhVHlwZXx8KGUuVmlkZW9EYXRhVHlwZT17fSkpW2kuTWV0YWRhdGE9MF09XCJNZXRhZGF0YVwiLGlbaS5DbGVhblBvaW50RnJhbWU9MV09XCJDbGVhblBvaW50RnJhbWVcIixpW2kuRnJhbWVEaWZmPTJdPVwiRnJhbWVEaWZmXCIsKHQ9ZS5BdWRpb0RhdGFUeXBlfHwoZS5BdWRpb0RhdGFUeXBlPXt9KSlbdC5NZXRhZGF0YT0wXT1cIk1ldGFkYXRhXCIsdFt0LkZyYW1lPTFdPVwiRnJhbWVcIixlLkRlc2t0b3BSZWN0PXtlbmNvZGUoQSl7Y29uc3QgZT1nLkJlYm9wVmlldy5nZXRJbnN0YW5jZSgpO3JldHVybiBlLnN0YXJ0V3JpdGluZygpLHRoaXMuZW5jb2RlSW50byhBLGUpLGUudG9BcnJheSgpfSxlbmNvZGVJbnRvKEEsZSl7Y29uc3QgST1lLmxlbmd0aDtyZXR1cm4gZS53cml0ZUludDMyKEEubGVmdCksZS53cml0ZUludDMyKEEudG9wKSxlLndyaXRlVWludDMyKEEud2lkdGgpLGUud3JpdGVVaW50MzIoQS5oZWlnaHQpLGUubGVuZ3RoLUl9LGRlY29kZShBKXtjb25zdCBlPWcuQmVib3BWaWV3LmdldEluc3RhbmNlKCk7cmV0dXJuIGUuc3RhcnRSZWFkaW5nKEEpLHRoaXMucmVhZEZyb20oZSl9LHJlYWRGcm9tKEEpe2xldCBlLEksZyx0O3JldHVybiBlPUEucmVhZEludDMyKCksST1BLnJlYWRJbnQzMigpLGc9QS5yZWFkVWludDMyKCksdD1BLnJlYWRVaW50MzIoKSx7bGVmdDplLHRvcDpJLHdpZHRoOmcsaGVpZ2h0OnR9fX0sZS5WaWRlb0RhdGE9e2Rpc2NyaW1pbmF0b3I6MSxlbmNvZGUoQSl7Y29uc3QgZT1nLkJlYm9wVmlldy5nZXRJbnN0YW5jZSgpO3JldHVybiBlLnN0YXJ0V3JpdGluZygpLHRoaXMuZW5jb2RlSW50byhBLGUpLGUudG9BcnJheSgpfSxlbmNvZGVJbnRvKEEsSSl7Y29uc3QgZz1JLmxlbmd0aDtJLndyaXRlQnl0ZXMoQS5kYXRhKSxJLndyaXRlVWludDY0KEEuc2VnbWVudFRpbWUpLEkud3JpdGVVaW50MzIoQS50eXBlKSxJLndyaXRlQnl0ZShBLnN0cmVhbUlkKSxlLkRlc2t0b3BSZWN0LmVuY29kZUludG8oQS5kZXNrdG9wUmVjdCxJKTt7Y29uc3QgZz1BLm1hc2subGVuZ3RoO0kud3JpdGVVaW50MzIoZyk7Zm9yKGxldCB0PTA7dDxnO3QrKyllLkRlc2t0b3BSZWN0LmVuY29kZUludG8oQS5tYXNrW3RdLEkpfXJldHVybiBJLmxlbmd0aC1nfSxkZWNvZGUoQSl7Y29uc3QgZT1nLkJlYm9wVmlldy5nZXRJbnN0YW5jZSgpO3JldHVybiBlLnN0YXJ0UmVhZGluZyhBKSx0aGlzLnJlYWRGcm9tKGUpfSxyZWFkRnJvbShBKXtsZXQgSSxnLHQsaSxCLEM7ST1BLnJlYWRCeXRlcygpLGc9QS5yZWFkVWludDY0KCksdD1BLnJlYWRVaW50MzIoKSxpPUEucmVhZEJ5dGUoKSxCPWUuRGVza3RvcFJlY3QucmVhZEZyb20oQSk7e2xldCBJPUEucmVhZFVpbnQzMigpO0M9bmV3IEFycmF5KEkpO2ZvcihsZXQgZz0wO2c8STtnKyspe2xldCBJO0k9ZS5EZXNrdG9wUmVjdC5yZWFkRnJvbShBKSxDW2ddPUl9fXJldHVybntkYXRhOkksc2VnbWVudFRpbWU6Zyx0eXBlOnQsc3RyZWFtSWQ6aSxkZXNrdG9wUmVjdDpCLG1hc2s6Q319fSxlLlBvaW50ZXJEYXRhPXtkaXNjcmltaW5hdG9yOjIsZW5jb2RlKEEpe2NvbnN0IGU9Zy5CZWJvcFZpZXcuZ2V0SW5zdGFuY2UoKTtyZXR1cm4gZS5zdGFydFdyaXRpbmcoKSx0aGlzLmVuY29kZUludG8oQSxlKSxlLnRvQXJyYXkoKX0sZW5jb2RlSW50byhBLGUpe2NvbnN0IEk9ZS5sZW5ndGg7cmV0dXJuIGUud3JpdGVCeXRlcyhBLmRhdGEpLGUud3JpdGVVaW50MzIoQS5tb25pdG9yV2lkdGgpLGUud3JpdGVVaW50MzIoQS5tb25pdG9ySGVpZ2h0KSxlLndyaXRlVWludDMyKEEuc2hhcGVXaWR0aCksZS53cml0ZVVpbnQzMihBLnNoYXBlSGVpZ2h0KSxlLndyaXRlSW50MzIoQS5zcG90WCksZS53cml0ZUludDMyKEEuc3BvdFkpLGUud3JpdGVCeXRlKE51bWJlcihBLnZpc2libGUpKSxlLndyaXRlSW50MzIoQS5wb3NpdGlvblgpLGUud3JpdGVJbnQzMihBLnBvc2l0aW9uWSksZS53cml0ZUJ5dGUoQS5zdHJlYW1JZCksZS5sZW5ndGgtSX0sZGVjb2RlKEEpe2NvbnN0IGU9Zy5CZWJvcFZpZXcuZ2V0SW5zdGFuY2UoKTtyZXR1cm4gZS5zdGFydFJlYWRpbmcoQSksdGhpcy5yZWFkRnJvbShlKX0scmVhZEZyb20oQSl7bGV0IGUsSSxnLHQsaSxCLEMsUSxvLG4sYTtyZXR1cm4gZT1BLnJlYWRCeXRlcygpLEk9QS5yZWFkVWludDMyKCksZz1BLnJlYWRVaW50MzIoKSx0PUEucmVhZFVpbnQzMigpLGk9QS5yZWFkVWludDMyKCksQj1BLnJlYWRJbnQzMigpLEM9QS5yZWFkSW50MzIoKSxRPSEhQS5yZWFkQnl0ZSgpLG89QS5yZWFkSW50MzIoKSxuPUEucmVhZEludDMyKCksYT1BLnJlYWRCeXRlKCkse2RhdGE6ZSxtb25pdG9yV2lkdGg6SSxtb25pdG9ySGVpZ2h0Omcsc2hhcGVXaWR0aDp0LHNoYXBlSGVpZ2h0Omksc3BvdFg6QixzcG90WTpDLHZpc2libGU6USxwb3NpdGlvblg6byxwb3NpdGlvblk6bixzdHJlYW1JZDphfX19LGUuQXVkaW9EYXRhPXtkaXNjcmltaW5hdG9yOjMsZW5jb2RlKEEpe2NvbnN0IGU9Zy5CZWJvcFZpZXcuZ2V0SW5zdGFuY2UoKTtyZXR1cm4gZS5zdGFydFdyaXRpbmcoKSx0aGlzLmVuY29kZUludG8oQSxlKSxlLnRvQXJyYXkoKX0sZW5jb2RlSW50byhBLGUpe2NvbnN0IEk9ZS5sZW5ndGg7cmV0dXJuIGUud3JpdGVCeXRlcyhBLmRhdGEpLGUud3JpdGVVaW50MzIoQS50eXBlKSxlLndyaXRlQnl0ZShBLnN0cmVhbUlkKSxlLmxlbmd0aC1JfSxkZWNvZGUoQSl7Y29uc3QgZT1nLkJlYm9wVmlldy5nZXRJbnN0YW5jZSgpO3JldHVybiBlLnN0YXJ0UmVhZGluZyhBKSx0aGlzLnJlYWRGcm9tKGUpfSxyZWFkRnJvbShBKXtsZXQgZSxJLGc7cmV0dXJuIGU9QS5yZWFkQnl0ZXMoKSxJPUEucmVhZFVpbnQzMigpLGc9QS5yZWFkQnl0ZSgpLHtkYXRhOmUsdHlwZTpJLHN0cmVhbUlkOmd9fX0sZS5NZWRpYUNodW5rPXtkaXNjcmltaW5hdG9yOjQsZW5jb2RlKEEpe2NvbnN0IGU9Zy5CZWJvcFZpZXcuZ2V0SW5zdGFuY2UoKTtyZXR1cm4gZS5zdGFydFdyaXRpbmcoKSx0aGlzLmVuY29kZUludG8oQSxlKSxlLnRvQXJyYXkoKX0sZW5jb2RlSW50byhBLEkpe2NvbnN0IGc9SS5sZW5ndGg7cmV0dXJuIGUuQ2h1bmsuZW5jb2RlSW50byhBLmNodW5rLEkpLEkubGVuZ3RoLWd9LGRlY29kZShBKXtjb25zdCBlPWcuQmVib3BWaWV3LmdldEluc3RhbmNlKCk7cmV0dXJuIGUuc3RhcnRSZWFkaW5nKEEpLHRoaXMucmVhZEZyb20oZSl9LHJlYWRGcm9tKEEpe2xldCBJO3JldHVybiBJPWUuQ2h1bmsucmVhZEZyb20oQSkse2NodW5rOkl9fX0sZS5NZWRpYUJvZHk9e2VuY29kZShBKXtjb25zdCBlPWcuQmVib3BWaWV3LmdldEluc3RhbmNlKCk7cmV0dXJuIGUuc3RhcnRXcml0aW5nKCksdGhpcy5lbmNvZGVJbnRvKEEsZSksZS50b0FycmF5KCl9LGVuY29kZUludG8oQSxJKXtjb25zdCBnPUkubGVuZ3RoLHQ9SS5yZXNlcnZlTWVzc2FnZUxlbmd0aCgpLGk9SS5sZW5ndGgrMTtzd2l0Y2goSS53cml0ZUJ5dGUoQS5kaXNjcmltaW5hdG9yKSxBLmRpc2NyaW1pbmF0b3Ipe2Nhc2UgMTplLlZpZGVvRGF0YS5lbmNvZGVJbnRvKEEudmFsdWUsSSk7YnJlYWs7Y2FzZSAyOmUuUG9pbnRlckRhdGEuZW5jb2RlSW50byhBLnZhbHVlLEkpO2JyZWFrO2Nhc2UgMzplLkF1ZGlvRGF0YS5lbmNvZGVJbnRvKEEudmFsdWUsSSk7YnJlYWs7Y2FzZSA0OmUuTWVkaWFDaHVuay5lbmNvZGVJbnRvKEEudmFsdWUsSSl9Y29uc3QgQj1JLmxlbmd0aDtyZXR1cm4gSS5maWxsTWVzc2FnZUxlbmd0aCh0LEItaSksSS5sZW5ndGgtZ30sZGVjb2RlKEEpe2NvbnN0IGU9Zy5CZWJvcFZpZXcuZ2V0SW5zdGFuY2UoKTtyZXR1cm4gZS5zdGFydFJlYWRpbmcoQSksdGhpcy5yZWFkRnJvbShlKX0scmVhZEZyb20oQSl7Y29uc3QgST1BLnJlYWRNZXNzYWdlTGVuZ3RoKCksdD1BLmluZGV4KzErSTtzd2l0Y2goQS5yZWFkQnl0ZSgpKXtjYXNlIDE6cmV0dXJue2Rpc2NyaW1pbmF0b3I6MSx2YWx1ZTplLlZpZGVvRGF0YS5yZWFkRnJvbShBKX07Y2FzZSAyOnJldHVybntkaXNjcmltaW5hdG9yOjIsdmFsdWU6ZS5Qb2ludGVyRGF0YS5yZWFkRnJvbShBKX07Y2FzZSAzOnJldHVybntkaXNjcmltaW5hdG9yOjMsdmFsdWU6ZS5BdWRpb0RhdGEucmVhZEZyb20oQSl9O2Nhc2UgNDpyZXR1cm57ZGlzY3JpbWluYXRvcjo0LHZhbHVlOmUuTWVkaWFDaHVuay5yZWFkRnJvbShBKX07ZGVmYXVsdDp0aHJvdyBBLmluZGV4PXQsbmV3IGcuQmVib3BSdW50aW1lRXJyb3IoXCJVbnJlY29nbml6ZWQgZGlzY3JpbWluYXRvciB3aGlsZSBkZWNvZGluZyBNZWRpYUJvZHlcIil9fX19LDUwMTQ6ZnVuY3Rpb24oQSxlLEkpe1widXNlIHN0cmljdFwiO3ZhciBnPXRoaXMmJnRoaXMuX19jcmVhdGVCaW5kaW5nfHwoT2JqZWN0LmNyZWF0ZT9mdW5jdGlvbihBLGUsSSxnKXt2b2lkIDA9PT1nJiYoZz1JKSxPYmplY3QuZGVmaW5lUHJvcGVydHkoQSxnLHtlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiBlW0ldfX0pfTpmdW5jdGlvbihBLGUsSSxnKXt2b2lkIDA9PT1nJiYoZz1JKSxBW2ddPWVbSV19KSx0PXRoaXMmJnRoaXMuX19leHBvcnRTdGFyfHxmdW5jdGlvbihBLGUpe2Zvcih2YXIgSSBpbiBBKVwiZGVmYXVsdFwiPT09SXx8T2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGUsSSl8fGcoZSxBLEkpfTtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxlLlJhaW53YXlFcnJvcj1lLkhlbGRLZXlzPWUuSW5wdXRUeXBlPWUuUmFpbndheVN0cmVhbUZpdD1lLlJhaW53YXlTdHJlYW09ZS5SYWlud2F5UnVudGltZT1lLlJhaW53YXlUcmFuc3BvcnRTdGF0dXM9ZS5SYWlud2F5VHJhbnNwb3J0PWUuUlRDVHJhbnNwb3J0PWUuZnJpZW5kbHlHYW1lcGFkTmFtZT1lLlJhaW53YXlMb2dMZXZlbD1lLlJhaW53YXlMb2dnaW5nPWUuUmFpbndheUNoYW5uZWxNb2RlPWUuUmFpbndheVBlZXI9ZS5SYWlud2F5UGVlclN0YXRlPXZvaWQgMDt2YXIgaT1JKDc3ODMpO09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiUmFpbndheVBlZXJTdGF0ZVwiLHtlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiBpLlJhaW53YXlQZWVyU3RhdGV9fSk7dmFyIEI9SSg1NDIwKTtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIlJhaW53YXlQZWVyXCIse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIEIuUmFpbndheVBlZXJ9fSksT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJSYWlud2F5Q2hhbm5lbE1vZGVcIix7ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gQi5SYWlud2F5Q2hhbm5lbE1vZGV9fSk7dmFyIEM9SSgzNDY0KTtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIlJhaW53YXlMb2dnaW5nXCIse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIEMuUmFpbndheUxvZ2dpbmd9fSksT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJSYWlud2F5TG9nTGV2ZWxcIix7ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gQy5SYWlud2F5TG9nTGV2ZWx9fSk7dmFyIFE9SSg5MDk5KTtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcImZyaWVuZGx5R2FtZXBhZE5hbWVcIix7ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gUS5mcmllbmRseUdhbWVwYWROYW1lfX0pO3ZhciBvPUkoMzE0NSk7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJSVENUcmFuc3BvcnRcIix7ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gby5SVENUcmFuc3BvcnR9fSk7dmFyIG49SSg5MDA5KTtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIlJhaW53YXlUcmFuc3BvcnRcIix7ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gbi5SYWlud2F5VHJhbnNwb3J0fX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiUmFpbndheVRyYW5zcG9ydFN0YXR1c1wiLHtlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiBuLlJhaW53YXlUcmFuc3BvcnRTdGF0dXN9fSk7dmFyIGE9SSg3NzgzKTtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIlJhaW53YXlSdW50aW1lXCIse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIGEuUmFpbndheVJ1bnRpbWV9fSk7dmFyIHI9SSgzODc2KTtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIlJhaW53YXlTdHJlYW1cIix7ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gci5SYWlud2F5U3RyZWFtfX0pO3ZhciBFPUkoNDQyNSk7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJSYWlud2F5U3RyZWFtRml0XCIse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIEUuUmFpbndheVN0cmVhbUZpdH19KTt2YXIgcz1JKDg4NCk7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJJbnB1dFR5cGVcIix7ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gcy5JbnB1dFR5cGV9fSksT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJIZWxkS2V5c1wiLHtlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiBzLkhlbGRLZXlzfX0pO3ZhciBkPUkoMjk5NCk7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJSYWlud2F5RXJyb3JcIix7ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gZC5SYWlud2F5RXJyb3J9fSksdChJKDY5MDQpLGUpfSw2NTooQSxlKT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLGUuUmFpbndheUN1cnNvclBhaW50ZXI9dm9pZCAwLGUuUmFpbndheUN1cnNvclBhaW50ZXI9Y2xhc3N7Y29uc3RydWN0b3IoQSxlLEksZz0xMDApe3RoaXMuY29ycmVjdFJlbW90ZUN1cnNvcj1BLHRoaXMudHJhbnNmb3JtUG9pbnRlck9mZnNldFRvUmVtb3RlPWUsdGhpcy5nZXRDdXJyZW50RnJhbWVTaXplPUksdGhpcy5jdXJzb3JTeW5jSW50ZXJ2YWw9Zyx0aGlzLmNvbnRhaW5lcj12b2lkIDAsdGhpcy52aWRlbz12b2lkIDAsdGhpcy5jYW52YXM9dm9pZCAwLHRoaXMuY3Vyc29yRGl2PXZvaWQgMCx0aGlzLmN1cnNvckltZz12b2lkIDAsdGhpcy5jdXJzb3JTdGF0ZT17dmlzaWJsZTohMSx4OjAseTowLHNwb3RYOjAsc3BvdFk6MCxleHRlbnRXaWR0aDowLGV4dGVudEhlaWdodDowfSx0aGlzLndhbnRzUmVtb3RlUG9zaXRpb249ITAsdGhpcy52aWRlb1JlY3Q9bmV3IERPTVJlY3QoMCwwLDAsMCksdGhpcy53aW5kb3dXaWR0aD12b2lkIDAsdGhpcy53aW5kb3dIZWlnaHQ9dm9pZCAwLHRoaXMuZHJhd0RlYnVnRG90PSExLHRoaXMuZGVidWdEb3Q9dm9pZCAwLHRoaXMuc2V0VmlkZW9EaW1lbnNpb25zPSgpPT57Zm9yKGNvbnN0IEEgb2ZbdGhpcy52aWRlbyx0aGlzLmNhbnZhc10pe2lmKCFBKWNvbnRpbnVlO2NvbnN0IGU9QS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtpZihlLndpZHRoPjAmJmUuaGVpZ2h0PjApcmV0dXJuIHRoaXMudmlkZW9SZWN0PWUsdm9pZCB0aGlzLmFwcGx5Q3Vyc29yRGl2VHJhbnNmb3JtKCl9fSx0aGlzLmN1cnNvclN5bmNDb3VudGVyPXRoaXMuY3Vyc29yU3luY0ludGVydmFsLHRoaXMudmlkZW9SZXNpemVPYnNlcnZlcj1uZXcgUmVzaXplT2JzZXJ2ZXIoKCgpPT57dGhpcy5zZXRWaWRlb0RpbWVuc2lvbnMoKX0pKSxbXCJ3ZWJraXRmdWxsc2NyZWVuY2hhbmdlXCIsXCJtb3pmdWxsc2NyZWVuY2hhbmdlXCIsXCJmdWxsc2NyZWVuY2hhbmdlXCIsXCJNU0Z1bGxzY3JlZW5DaGFuZ2VcIl0uZm9yRWFjaCgoQT0+e2RvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoQSx0aGlzLnNldFZpZGVvRGltZW5zaW9ucywhMSl9KSksd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIix0aGlzLnNldFdpbmRvd0RpbWVuc2lvbnMpfWRldGFjaCgpe1tcIndlYmtpdGZ1bGxzY3JlZW5jaGFuZ2VcIixcIm1vemZ1bGxzY3JlZW5jaGFuZ2VcIixcImZ1bGxzY3JlZW5jaGFuZ2VcIixcIk1TRnVsbHNjcmVlbkNoYW5nZVwiXS5mb3JFYWNoKChBPT57ZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihBLHRoaXMuc2V0VmlkZW9EaW1lbnNpb25zLCExKX0pKSx3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInJlc2l6ZVwiLHRoaXMuc2V0V2luZG93RGltZW5zaW9ucyksdGhpcy52aWRlb1Jlc2l6ZU9ic2VydmVyLmRpc2Nvbm5lY3QoKX1zZXRXaW5kb3dEaW1lbnNpb25zKCl7dGhpcy53aW5kb3dXaWR0aD13aW5kb3cuaW5uZXJXaWR0aCx0aGlzLndpbmRvd0hlaWdodD13aW5kb3cuaW5uZXJIZWlnaHR9c2V0Q29udGFpbmVyKEEpe3RoaXMuY29udGFpbmVyPUEsQS5zdHlsZS5vdmVyZmxvdz1cImhpZGRlblwiLHRoaXMudmlkZW8mJnRoaXMudmlkZW9SZXNpemVPYnNlcnZlci51bm9ic2VydmUodGhpcy52aWRlbyksdGhpcy5jYW52YXMmJnRoaXMudmlkZW9SZXNpemVPYnNlcnZlci51bm9ic2VydmUodGhpcy5jYW52YXMpLHRoaXMuY3Vyc29yRGl2PXZvaWQgMDtjb25zdCBlPUEuY2hpbGROb2Rlcztmb3IobGV0IEE9MDtBPGUubGVuZ3RoO0ErKyl7Y29uc3QgST1lW0FdO0kgaW5zdGFuY2VvZiBIVE1MVmlkZW9FbGVtZW50Pyh0aGlzLnZpZGVvPUksdGhpcy5zZXRWaWRlb0RpbWVuc2lvbnMoKSx0aGlzLnZpZGVvUmVzaXplT2JzZXJ2ZXIub2JzZXJ2ZSh0aGlzLnZpZGVvKSk6SSBpbnN0YW5jZW9mIEhUTUxDYW52YXNFbGVtZW50JiYoSS5jbGFzc0xpc3QuY29udGFpbnMoXCJyYWlud2F5LWNhbnZhc1wiKXx8SS5jbGFzc0xpc3QuY29udGFpbnMoXCJyYWlud2F5LWlzb2xhdGlvbi1jYW52YXNcIikpPyh0aGlzLmNhbnZhcz1JLHRoaXMuc2V0VmlkZW9EaW1lbnNpb25zKCksdGhpcy52aWRlb1Jlc2l6ZU9ic2VydmVyLm9ic2VydmUodGhpcy5jYW52YXMpKTpJIGluc3RhbmNlb2YgSFRNTERpdkVsZW1lbnQmJihJLmNsYXNzTmFtZS5pbmNsdWRlcyhcInJhaW53YXktY3Vyc29yXCIpP3RoaXMuY3Vyc29yRGl2PUk6SS5jbGFzc05hbWUuaW5jbHVkZXMoXCJyYWlud2F5LWRlYnVnLWRvdFwiKSYmKHRoaXMuZGVidWdEb3Q9SSkpfXRoaXMuY3Vyc29yRGl2fHwodGhpcy5jdXJzb3JEaXY9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKSx0aGlzLmN1cnNvckRpdi5jbGFzc05hbWU9XCJyYWlud2F5LWN1cnNvclwiLHRoaXMuY3Vyc29yRGl2LnN0eWxlLnBvc2l0aW9uPVwiYWJzb2x1dGVcIix0aGlzLmN1cnNvckRpdi5zdHlsZS50b3A9XCIwcHhcIix0aGlzLmN1cnNvckRpdi5zdHlsZS5sZWZ0PVwiMHB4XCIsdGhpcy5jdXJzb3JEaXYuc3R5bGUuekluZGV4PVwiMVwiLHRoaXMuY3Vyc29yRGl2LnN0eWxlLnBvaW50ZXJFdmVudHM9XCJub25lXCIsdGhpcy5jdXJzb3JEaXYuc3R5bGUud2lsbENoYW5nZT1cInRyYW5zZm9ybVwiLHRoaXMuY3Vyc29yRGl2LnN0eWxlLnRyYW5zZm9ybU9yaWdpbj1cInRvcCBsZWZ0XCIsdGhpcy5hcHBseUN1cnNvckRpdlRyYW5zZm9ybSgpLHRoaXMuY3Vyc29ySW1nPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbWdcIiksdGhpcy5jdXJzb3JEaXYuYXBwZW5kQ2hpbGQodGhpcy5jdXJzb3JJbWcpLEEuYXBwZW5kQ2hpbGQodGhpcy5jdXJzb3JEaXYpKSx0aGlzLmRyYXdEZWJ1Z0RvdCYmIXRoaXMuZGVidWdEb3QmJih0aGlzLmRlYnVnRG90PWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiksdGhpcy5kZWJ1Z0RvdC5jbGFzc05hbWU9XCJyYWlud2F5LWRlYnVnLWRvdFwiLHRoaXMuZGVidWdEb3Quc3R5bGUucG9zaXRpb249XCJhYnNvbHV0ZVwiLHRoaXMuZGVidWdEb3Quc3R5bGUudG9wPVwiMHB4XCIsdGhpcy5kZWJ1Z0RvdC5zdHlsZS5sZWZ0PVwiMHB4XCIsdGhpcy5kZWJ1Z0RvdC5zdHlsZS56SW5kZXg9XCIxXCIsdGhpcy5kZWJ1Z0RvdC5zdHlsZS5wb2ludGVyRXZlbnRzPVwibm9uZVwiLHRoaXMuZGVidWdEb3Quc3R5bGUud2lsbENoYW5nZT1cInRyYW5zZm9ybVwiLHRoaXMuZGVidWdEb3Quc3R5bGUudHJhbnNmb3JtT3JpZ2luPVwidG9wIGxlZnRcIix0aGlzLmRlYnVnRG90LnN0eWxlLndpZHRoPVwiM3B4XCIsdGhpcy5kZWJ1Z0RvdC5zdHlsZS5oZWlnaHQ9XCIzcHhcIix0aGlzLmRlYnVnRG90LnN0eWxlLmJhY2tncm91bmRDb2xvcj1cIiNmZjAwMDBcIixBLmFwcGVuZENoaWxkKHRoaXMuZGVidWdEb3QpKX11bnNldENvbnRhaW5lcigpe3ZhciBBLGU7dGhpcy5kZXRhY2goKSxudWxsPT09KEE9dGhpcy5jdXJzb3JEaXYpfHx2b2lkIDA9PT1BfHxBLnJlbW92ZSgpLG51bGw9PT0oZT10aGlzLmRlYnVnRG90KXx8dm9pZCAwPT09ZXx8ZS5yZW1vdmUoKSx0aGlzLmNvbnRhaW5lcj12b2lkIDB9Y29tcHV0ZVRyYW5zZm9ybShBKXt2YXIgZSxJO2NvbnN0e3g6Zyx5OnQsc3BvdFg6aSxzcG90WTpCfT1BLEM9e2xlZnQ6MCx0b3A6MCx3aWR0aDpBLmV4dGVudFdpZHRoLGhlaWdodDpBLmV4dGVudEhlaWdodH0se3dpZHRoOlEsaGVpZ2h0Om99PXRoaXMudmlkZW9SZWN0LG49dGhpcy5nZXRDdXJyZW50RnJhbWVTaXplKCksYT1uLmNvZGVjV2lkdGgscj1uLmNvZGVjSGVpZ2h0LEU9bnVsbCE9PShlPW4uc3RyZWFtQm91bmRzKSYmdm9pZCAwIT09ZT9lOkMscz1udWxsIT09KEk9bi5mdWxsRGVza3RvcEJvdW5kcykmJnZvaWQgMCE9PUk/STpDLHtsZWZ0OmQsdG9wOmMsd2lkdGg6aCxoZWlnaHQ6RH09cyx7bGVmdDp1LHRvcDp3LHdpZHRoOmwsaGVpZ2h0Onl9PUUsUz1sKmEvaCxGPXkqci9ELFI9TWF0aC5taW4oUS9TLG8vRikscD1NYXRoLnJvdW5kKGctaS0odS1kKSksRz1NYXRoLnJvdW5kKHQtQi0ody1jKSksZj1SKmEvaCxtPVIqci9EO3JldHVybmB0cmFuc2xhdGUoJHtNYXRoLnJvdW5kKChRLVIqUykvMil9cHgsJHtNYXRoLnJvdW5kKChvLVIqRikvMil9cHgpIHNjYWxlKCR7Zn0sJHttfSkgdHJhbnNsYXRlKCR7cH1weCwke0d9cHgpYH1hcHBseUN1cnNvckRpdlRyYW5zZm9ybSgpe3RoaXMuY3Vyc29yRGl2JiYodGhpcy5jdXJzb3JTdGF0ZS52aXNpYmxlPyh0aGlzLmN1cnNvckRpdi5zdHlsZS52aXNpYmlsaXR5PVwidmlzaWJsZVwiLHRoaXMuY3Vyc29yRGl2LnN0eWxlLnRyYW5zZm9ybT10aGlzLmNvbXB1dGVUcmFuc2Zvcm0odGhpcy5jdXJzb3JTdGF0ZSkpOnRoaXMuY3Vyc29yRGl2LnN0eWxlLnZpc2liaWxpdHk9XCJoaWRkZW5cIil9bW92ZURlYnVnRG90VG8oQSl7dGhpcy5kZWJ1Z0RvdCYmKHRoaXMuZGVidWdEb3Quc3R5bGUudHJhbnNmb3JtPXRoaXMuY29tcHV0ZVRyYW5zZm9ybShBKSl9cHJvY2Vzc0N1cnNvcihBKXtpZih0aGlzLmN1cnNvckRpdilpZihBLnZpc2libGUmJiF0aGlzLmN1cnNvclN0YXRlLnZpc2libGUmJih0aGlzLndhbnRzUmVtb3RlUG9zaXRpb249ITApLHRoaXMuY3Vyc29yU3RhdGUudmlzaWJsZT1BLnZpc2libGUsdGhpcy5jdXJzb3JTdGF0ZS5zcG90WD1BLnNwb3RYLHRoaXMuY3Vyc29yU3RhdGUuc3BvdFk9QS5zcG90WSx0aGlzLmN1cnNvclN0YXRlLmV4dGVudFdpZHRoPUEuZXh0ZW50V2lkdGgsdGhpcy5jdXJzb3JTdGF0ZS5leHRlbnRIZWlnaHQ9QS5leHRlbnRIZWlnaHQsdGhpcy5kcmF3RGVidWdEb3QmJnRoaXMubW92ZURlYnVnRG90VG8oQSksdGhpcy5jdXJzb3JTdGF0ZS52aXNpYmxlKXtpZih0aGlzLndhbnRzUmVtb3RlUG9zaXRpb24/KHRoaXMuY3Vyc29yU3RhdGUueD1BLngsdGhpcy5jdXJzb3JTdGF0ZS55PUEueSx0aGlzLndhbnRzUmVtb3RlUG9zaXRpb249ITEsdGhpcy5jdXJzb3JTeW5jQ291bnRlcj10aGlzLmN1cnNvclN5bmNJbnRlcnZhbCk6MD09LS10aGlzLmN1cnNvclN5bmNDb3VudGVyJiYodGhpcy5jb3JyZWN0UmVtb3RlQ3Vyc29yKHRoaXMuY3Vyc29yU3RhdGUueCx0aGlzLmN1cnNvclN0YXRlLnkpLHRoaXMuY3Vyc29yU3luY0NvdW50ZXI9dGhpcy5jdXJzb3JTeW5jSW50ZXJ2YWwpLHRoaXMuY3Vyc29yRGl2LnN0eWxlLndpZHRoPWAke0Euc2hhcGVXaWR0aH1weGAsdGhpcy5jdXJzb3JEaXYuc3R5bGUuaGVpZ2h0PWAke0Euc2hhcGVIZWlnaHR9cHhgLEEuaGFzUG9pbnRlckltYWdlJiZ0aGlzLmN1cnNvckltZyl7Y29uc3QgZT1mdW5jdGlvbihBKXtsZXQgZT1cIlwiO2NvbnN0IEk9bmV3IFVpbnQ4QXJyYXkoQSksZz1JLmJ5dGVMZW5ndGg7Zm9yKGxldCBBPTA7QTxnO0ErKyllKz1TdHJpbmcuZnJvbUNoYXJDb2RlKElbQV0pO3JldHVybiB3aW5kb3cuYnRvYShlKX0oQS5wb2ludGVySW1hZ2UpO3RoaXMuY3Vyc29ySW1nLnNyYz1gZGF0YTppbWFnZS9wbmc7YmFzZTY0LCR7ZX1gfXRoaXMuYXBwbHlDdXJzb3JEaXZUcmFuc2Zvcm0oKX1lbHNlIHRoaXMuY3Vyc29yRGl2LnN0eWxlLnZpc2liaWxpdHk9XCJoaWRkZW5cIn11cGRhdGUoQSxlLEkpe3ZhciBnO2lmKHRoaXMuY3Vyc29yRGl2JiYoXCJwb2ludGVybW92ZVwiPT09QS50eXBlfHxcIm1vdXNlbW92ZVwiPT09QS50eXBlKSl7aWYoXCJtb3VzZVwiIT09KG51bGwhPT0oZz1BLnBvaW50ZXJUeXBlKSYmdm9pZCAwIT09Zz9nOlwibW91c2VcIikpe2NvbnN0IEE9dGhpcy50cmFuc2Zvcm1Qb2ludGVyT2Zmc2V0VG9SZW1vdGUoZSxJKTtBJiYodGhpcy5jdXJzb3JTdGF0ZS54PUEueCx0aGlzLmN1cnNvclN0YXRlLnk9QS55KX1lbHNle2NvbnN0IGU9dGhpcy5jdXJzb3JTdGF0ZSxJPUEubW92ZW1lbnRYLGc9QS5tb3ZlbWVudFksdD10aGlzLmdldEN1cnJlbnRGcmFtZVNpemUoKTtpZih0LnN0cmVhbUJvdW5kcyl7Y29uc3R7dG9wOkEsbGVmdDppLGhlaWdodDpCLHdpZHRoOkN9PXQuc3RyZWFtQm91bmRzO3RoaXMuY3Vyc29yU3RhdGUueD1NYXRoLm1heChpLE1hdGgubWluKGUueCtJLGkrQykpLHRoaXMuY3Vyc29yU3RhdGUueT1NYXRoLm1heChBLE1hdGgubWluKGUueStnLEErQikpfWVsc2UgY29uc29sZS53YXJuKFwiRG9uJ3QgaGF2ZSBzdHJlYW1Cb3VuZHMgaW4gQ3Vyc29yUGFpbnRlci51cGRhdGU/XCIpLHRoaXMuY3Vyc29yU3RhdGUueD1NYXRoLm1heCgwLE1hdGgubWluKGUueCtJLGUuZXh0ZW50V2lkdGgpKSx0aGlzLmN1cnNvclN0YXRlLnk9TWF0aC5tYXgoMCxNYXRoLm1pbihlLnkrZyxlLmV4dGVudEhlaWdodCkpfXRoaXMuYXBwbHlDdXJzb3JEaXZUcmFuc2Zvcm0oKX19fX0sOTA5OTooQSxlKT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLGUuZnJpZW5kbHlHYW1lcGFkTmFtZT12b2lkIDA7Y29uc3QgST17XCIwNTRjXCI6e1wiMDI2OFwiOlwiRHVhbFNob2NrIDNcIixcIjA1YzRcIjpcIkR1YWxTaG9jayA0XCIsXCIwOWNjXCI6XCJEdWFsU2hvY2sgNCAoMm5kIEdlbilcIn0sXCIyZGM4XCI6ezYxMDE6XCJOMzAgUHJvXCJ9LFwiMDk1NVwiOntiNDAwOlwiTlZJRElBIFNoaWVsZFwifSwyNTYzOntcIjA1MjNcIjpcIlNoYW5XYW4gUFMzIENvbnRyb2xsZXJcIn0sXCIwNDVlXCI6e1wiMDJkMVwiOlwiWGJveCBPbmUgQ29udHJvbGxlclwiLFwiMDJkZFwiOlwiWGJveCBPbmUgQ29udHJvbGxlciAoRmlybXdhcmUgMjAxNSlcIixcIjAyZTNcIjpcIlhib3ggT25lIEVsaXRlIENvbnRyb2xsZXJcIixcIjAyZWFcIjpcIlhib3ggT25lIFMgQ29udHJvbGxlclwiLFwiMDJmZFwiOlwiWGJveCBPbmUgUyBDb250cm9sbGVyIChCbHVldG9vdGgpXCIsXCIwMjhmXCI6XCJYYm94MzYwIFdpcmVsZXNzIENvbnRyb2xsZXJcIixcIjAyOGVcIjpcIlhib3gzNjAgQ29udHJvbGxlclwiLFwiMDI4OVwiOlwiWGJveCBDb250cm9sbGVyIFNcIixcIjAyODVcIjpcIlhib3ggQ29udHJvbGxlciBTXCIsXCIwMjAyXCI6XCJYYm94IENvbnRyb2xsZXJcIn0sXCIwNDZkXCI6e2MyOTk6XCJHMjUgUmFjaW5nIFdoZWVsXCIsYzI5QjpcIkcyNyBSYWNpbmcgV2hlZWxcIixjYWEzOlwiRHJpdmVGWCBSYWNpbmcgV2hlZWxcIixjMjk1OlwiTW9tbyBGb3JjZSBTdGVlcmluZyBXaGVlbFwiLGMyOTg6XCJEcml2aW5nIEZvcmNlIFByb1wifX07ZS5mcmllbmRseUdhbWVwYWROYW1lPWZ1bmN0aW9uKEEsZSl7dmFyIGcsdCxpLEI7Y29uc3QgQz1BLmlkLnNwbGl0KFwiKFwiKVswXS50cmltKCl8fFwiVW5rbm93biBnYW1lcGFkXCIsUT1BLmlkLm1hdGNoKC9cXGIoWzAtOWEtZl17NH0pXFxiLipcXGIoWzAtOWEtZl17NH0pXFxiLyk7aWYoIVEpcmV0dXJuIEM7Y29uc3Qgbz1RWzFdLG49UVsyXTtyZXR1cm4gbnVsbCE9PShCPW51bGwhPT0odD1udWxsPT09KGc9bnVsbD09ZT92b2lkIDA6ZVtvXSl8fHZvaWQgMD09PWc/dm9pZCAwOmdbbl0pJiZ2b2lkIDAhPT10P3Q6bnVsbD09PShpPUlbb10pfHx2b2lkIDA9PT1pP3ZvaWQgMDppW25dKSYmdm9pZCAwIT09Qj9COkN9fSw4MzIyOihBLGUpPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksZS5SYWlud2F5R2VzdHVyZVJlY29nbml6ZXI9dm9pZCAwO2NvbnN0IEk9e2NsaWNrRHVyYXRpb25Nczo2MCxkcmFnRGVsYXlNczozMDAscmlnaHRDbGlja0RlbGF5TXM6NTAwLHRvdWNoU2xvcFJhZGl1czo4LGRvdWJsZVRhcFdpbmRvd01zOjQwMCxkb3VibGVUYXBSYWRpdXM6MTIsc2Nyb2xsR2VzdHVyZVRocmVzaG9sZFBpeGVsczoyMCxzY3JvbGxFcHNpbG9uUGl4ZWxzOjUsc2Nyb2xsU2Vuc2l0aXZpdHk6NH07dmFyIGcsdCxpO2Z1bmN0aW9uIEIoQSl7cmV0dXJuIEE9PXQubGVmdD8xOkE9PXQubWlkZGxlPzQ6QT09dC5yaWdodD8yOjB9IWZ1bmN0aW9uKEEpe0FbQS5pZGxlPTBdPVwiaWRsZVwiLEFbQS5vbmVGaW5nZXJEZWNpZGluZz0xXT1cIm9uZUZpbmdlckRlY2lkaW5nXCIsQVtBLnR3b0ZpbmdlcnNEZWNpZGluZz0yXT1cInR3b0ZpbmdlcnNEZWNpZGluZ1wiLEFbQS5tb3Zpbmc9M109XCJtb3ZpbmdcIixBW0EuZHJhZ2dpbmc9NF09XCJkcmFnZ2luZ1wiLEFbQS5ob2xkaW5nUmlnaHRNb3VzZUJ1dHRvbj01XT1cImhvbGRpbmdSaWdodE1vdXNlQnV0dG9uXCIsQVtBLnpvb21pbmc9Nl09XCJ6b29taW5nXCIsQVtBLnNjcm9sbGluZz03XT1cInNjcm9sbGluZ1wifShnfHwoZz17fSkpLGZ1bmN0aW9uKEEpe0FbQS5sZWZ0PTBdPVwibGVmdFwiLEFbQS5taWRkbGU9MV09XCJtaWRkbGVcIixBW0EucmlnaHQ9Ml09XCJyaWdodFwifSh0fHwodD17fSkpLGZ1bmN0aW9uKEEpe0FbQS5waXhlbHM9MF09XCJwaXhlbHNcIixBW0EubGluZXM9MV09XCJsaW5lc1wiLEFbQS5wYWdlcz0yXT1cInBhZ2VzXCJ9KGl8fChpPXt9KSksZS5SYWlud2F5R2VzdHVyZVJlY29nbml6ZXI9Y2xhc3N7Y29uc3RydWN0b3IoQSxlLGk9SSl7dGhpcy5yZXBvcnRQb2ludGVyRXZlbnQ9QSx0aGlzLnJlcG9ydFdoZWVsRXZlbnQ9ZSx0aGlzLnBhcmFtZXRlcnM9aSx0aGlzLnN0YXRlPWcuaWRsZSx0aGlzLnByaW1hcnk9dm9pZCAwLHRoaXMuc2Vjb25kYXJ5PXZvaWQgMCx0aGlzLmNlbnRyb2lkWT0wLHRoaXMubGFzdFRhcFRpbWU9bmV3IERhdGUsdGhpcy5yaWdodENsaWNrVGltZXI9dm9pZCAwLHRoaXMucmlnaHRDbGljaz0oKT0+e3RoaXMucmVwb3J0TW91c2VEb3duKHQucmlnaHQpLHRoaXMudG9TdGF0ZShnLmhvbGRpbmdSaWdodE1vdXNlQnV0dG9uKSx0aGlzLnJpZ2h0Q2xpY2tUaW1lcj12b2lkIDB9LHRoaXMudGFwUmVsZWFzZVRpbWVyPXZvaWQgMCx0aGlzLnRhcFJlbGVhc2U9KCk9Pnt0aGlzLnJlcG9ydE1vdXNlVXAodC5sZWZ0KSx0aGlzLnRvU3RhdGUoZy5pZGxlKSx0aGlzLnJpZ2h0Q2xpY2tUaW1lcj12b2lkIDB9LHRoaXMub25Qb2ludGVyRG93bj1BPT57Y29uc3QgZT17cG9pbnRlcklkOkEucG9pbnRlcklkLGhvbWVPZmZzZXRYOkEub2Zmc2V0WCxob21lT2Zmc2V0WTpBLm9mZnNldFksY3VycmVudE9mZnNldFg6QS5vZmZzZXRYLGN1cnJlbnRPZmZzZXRZOkEub2Zmc2V0WSxkb3duVGltZTpuZXcgRGF0ZSxhd2FrZTohMX07dm9pZCAwPT09dGhpcy5wcmltYXJ5Pyh0aGlzLnRvU3RhdGUoZy5vbmVGaW5nZXJEZWNpZGluZyksdGhpcy5wcmltYXJ5PWUsd2luZG93LmNsZWFyVGltZW91dCh0aGlzLnJpZ2h0Q2xpY2tUaW1lciksdGhpcy5yaWdodENsaWNrVGltZXI9d2luZG93LnNldFRpbWVvdXQodGhpcy5yaWdodENsaWNrLHRoaXMucGFyYW1ldGVycy5yaWdodENsaWNrRGVsYXlNcykpOnZvaWQgMD09PXRoaXMuc2Vjb25kYXJ5JiYodGhpcy50b1N0YXRlKGcudHdvRmluZ2Vyc0RlY2lkaW5nKSx0aGlzLnNlY29uZGFyeT1lLHdpbmRvdy5jbGVhclRpbWVvdXQodGhpcy5yaWdodENsaWNrVGltZXIpKX0sdGhpcy5vblBvaW50ZXJVcD1BPT57dmFyIGU7d2luZG93LmNsZWFyVGltZW91dCh0aGlzLnJpZ2h0Q2xpY2tUaW1lcik7Y29uc3QgST1BLnBvaW50ZXJJZD09PShudWxsPT09KGU9dGhpcy5wcmltYXJ5KXx8dm9pZCAwPT09ZT92b2lkIDA6ZS5wb2ludGVySWQpO2lmKHRoaXMuc3RhdGU9PT1nLm9uZUZpbmdlckRlY2lkaW5nJiZJKXt0aGlzLmxvZyhcInBvaW50ZXIgdXAgZnJvbSBkZWNpZGluZywgdGFwcGluZ1wiKSx3aW5kb3cuY2xlYXJUaW1lb3V0KHRoaXMucmlnaHRDbGlja1RpbWVyKTtjb25zdCBlPU9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSxBKSx7b2Zmc2V0WDpBLm9mZnNldFgsb2Zmc2V0WTpBLm9mZnNldFkscG9pbnRlclR5cGU6XCJ0b3VjaFwiLHR5cGU6XCJwb2ludGVybW92ZVwifSk7dGhpcy5yZXBvcnRQb2ludGVyRXZlbnQoZSksdGhpcy5yZXBvcnRNb3VzZURvd24odC5sZWZ0KSx0aGlzLnByaW1hcnk9dm9pZCAwLHRoaXMubGFzdFRhcFRpbWU9bmV3IERhdGUsdGhpcy50YXBSZWxlYXNlVGltZXI9d2luZG93LnNldFRpbWVvdXQodGhpcy50YXBSZWxlYXNlLHRoaXMucGFyYW1ldGVycy5jbGlja0R1cmF0aW9uTXMpfWVsc2UgdGhpcy5wcmltYXJ5JiZ0aGlzLnNlY29uZGFyeT8odGhpcy5sb2coXCJzdG9wcGluZyB0d28gZmluZ2VyIGdlc3R1cmVcIiksdGhpcy5wcmltYXJ5PXZvaWQgMCx0aGlzLnNlY29uZGFyeT12b2lkIDAsdGhpcy50b1N0YXRlKGcuaWRsZSkpOnRoaXMuc3RhdGU9PT1nLm1vdmluZyYmST8odGhpcy5sb2coXCJzdG9wIG1vdmluZ1wiKSx0aGlzLnByaW1hcnk9dm9pZCAwLHRoaXMudG9TdGF0ZShnLmlkbGUpKTp0aGlzLnN0YXRlPT09Zy5kcmFnZ2luZyYmST8odGhpcy5sb2coXCJzdG9wIGRyYWdnaW5nXCIpLHRoaXMucmVwb3J0TW91c2VVcCh0LmxlZnQpLHRoaXMucHJpbWFyeT12b2lkIDAsdGhpcy50b1N0YXRlKGcuaWRsZSkpOnRoaXMuc3RhdGU9PT1nLmhvbGRpbmdSaWdodE1vdXNlQnV0dG9uJiZJJiYodGhpcy5sb2coXCJzdG9wIHJpZ2h0IGNsaWNrXCIpLHRoaXMucmVwb3J0TW91c2VVcCh0LnJpZ2h0KSx0aGlzLnByaW1hcnk9dm9pZCAwLHRoaXMudG9TdGF0ZShnLmlkbGUpKX0sdGhpcy5vblBvaW50ZXJNb3ZlPUE9Pnt2YXIgZSxJO2NvbnN0IGk9QS5wb2ludGVySWQ9PT0obnVsbD09PShlPXRoaXMucHJpbWFyeSl8fHZvaWQgMD09PWU/dm9pZCAwOmUucG9pbnRlcklkKSxCPUEucG9pbnRlcklkPT09KG51bGw9PT0oST10aGlzLnNlY29uZGFyeSl8fHZvaWQgMD09PUk/dm9pZCAwOkkucG9pbnRlcklkKTtpZih0aGlzLnByaW1hcnkmJmk/KHRoaXMucHJpbWFyeS5jdXJyZW50T2Zmc2V0WD1BLm9mZnNldFgsdGhpcy5wcmltYXJ5LmN1cnJlbnRPZmZzZXRZPUEub2Zmc2V0WSk6dGhpcy5zZWNvbmRhcnkmJkImJih0aGlzLnNlY29uZGFyeS5jdXJyZW50T2Zmc2V0WD1BLm9mZnNldFgsdGhpcy5zZWNvbmRhcnkuY3VycmVudE9mZnNldFk9QS5vZmZzZXRZKSx0aGlzLnByaW1hcnkmJmkmJiF0aGlzLnNlY29uZGFyeSl0aGlzLnN0YXRlPT09Zy5vbmVGaW5nZXJEZWNpZGluZyYmZnVuY3Rpb24oQSxlKXtjb25zdCBJPUEuY3VycmVudE9mZnNldFgtQS5ob21lT2Zmc2V0WCxnPUEuY3VycmVudE9mZnNldFktQS5ob21lT2Zmc2V0WTtyZXR1cm4gSSpJK2cqZz5lKmV9KHRoaXMucHJpbWFyeSx0aGlzLnBhcmFtZXRlcnMudG91Y2hTbG9wUmFkaXVzKT8odGhpcy5sb2coXCJsZWZ0IHRvdWNoIHNsb3AgcmFkaXVzXCIpLHdpbmRvdy5jbGVhclRpbWVvdXQodGhpcy5yaWdodENsaWNrVGltZXIpLHRoaXMucHJpbWFyeS5hd2FrZT0hMCwobmV3IERhdGUpLnZhbHVlT2YoKS10aGlzLmxhc3RUYXBUaW1lLnZhbHVlT2YoKTx0aGlzLnBhcmFtZXRlcnMuZHJhZ0RlbGF5TXM/KHRoaXMucmVwb3J0TW91c2VEb3duKHQubGVmdCksdGhpcy50b1N0YXRlKGcuZHJhZ2dpbmcpKTp0aGlzLnRvU3RhdGUoZy5tb3ZpbmcpKTp0aGlzLnN0YXRlIT09Zy5kcmFnZ2luZyYmdGhpcy5zdGF0ZSE9PWcubW92aW5nJiZ0aGlzLnN0YXRlIT09Zy5ob2xkaW5nUmlnaHRNb3VzZUJ1dHRvbnx8dGhpcy5yZXBvcnRQb2ludGVyRXZlbnQoQSk7ZWxzZSBpZih0aGlzLnByaW1hcnkmJnRoaXMuc2Vjb25kYXJ5KWlmKHRoaXMuc3RhdGU9PT1nLnR3b0ZpbmdlcnNEZWNpZGluZyl7Y29uc3QgQT10aGlzLnByaW1hcnkuY3VycmVudE9mZnNldFktdGhpcy5wcmltYXJ5LmhvbWVPZmZzZXRZLGU9dGhpcy5zZWNvbmRhcnkuY3VycmVudE9mZnNldFktdGhpcy5zZWNvbmRhcnkuaG9tZU9mZnNldFksST10aGlzLnBhcmFtZXRlcnMuc2Nyb2xsR2VzdHVyZVRocmVzaG9sZFBpeGVsczsoQT5JJiZlPkl8fEE8SSYmZTxJKSYmKHRoaXMudG9TdGF0ZShnLnNjcm9sbGluZyksdGhpcy5jZW50cm9pZFk9KEErZSkvMil9ZWxzZSBpZih0aGlzLnN0YXRlPT09Zy5zY3JvbGxpbmcpe2NvbnN0IEE9dGhpcy5wYXJhbWV0ZXJzLnNjcm9sbEVwc2lsb25QaXhlbHMsZT0odGhpcy5wcmltYXJ5LmN1cnJlbnRPZmZzZXRZLXRoaXMucHJpbWFyeS5ob21lT2Zmc2V0WSsodGhpcy5zZWNvbmRhcnkuY3VycmVudE9mZnNldFktdGhpcy5zZWNvbmRhcnkuaG9tZU9mZnNldFkpKS8yO2U+dGhpcy5jZW50cm9pZFkrQT8odGhpcy5yZXBvcnRTY3JvbGwodGhpcy5wYXJhbWV0ZXJzLnNjcm9sbFNlbnNpdGl2aXR5KkEpLHRoaXMuY2VudHJvaWRZPWUpOmU8dGhpcy5jZW50cm9pZFktQSYmKHRoaXMucmVwb3J0U2Nyb2xsKHRoaXMucGFyYW1ldGVycy5zY3JvbGxTZW5zaXRpdml0eSotQSksdGhpcy5jZW50cm9pZFk9ZSl9fX1sb2coLi4uQSl7fXJlcG9ydE1vdXNlVXAoQSl7dGhpcy5sb2coXCItLVxceDNlIHJlcG9ydCBwb2ludGVydXBcIixBKTtjb25zdCBlPW5ldyBQb2ludGVyRXZlbnQoXCJwb2ludGVydXBcIix7cG9pbnRlclR5cGU6XCJtb3VzZVwiLGJ1dHRvbnM6MCxidXR0b246QX0pO3RoaXMucmVwb3J0UG9pbnRlckV2ZW50KGUpfXJlcG9ydE1vdXNlRG93bihBKXt0aGlzLmxvZyhcIi0tXFx4M2UgcmVwb3J0IHBvaW50ZXJkb3duXCIsQSk7Y29uc3QgZT1uZXcgUG9pbnRlckV2ZW50KFwicG9pbnRlcmRvd25cIix7cG9pbnRlclR5cGU6XCJtb3VzZVwiLGJ1dHRvbnM6QihBKSxidXR0b246QX0pO3RoaXMucmVwb3J0UG9pbnRlckV2ZW50KGUpfXJlcG9ydFNjcm9sbChBKXtjb25zdCBlPW5ldyBXaGVlbEV2ZW50KFwic3ludGhldGljV2hlZWxcIix7ZGVsdGFZOkEsZGVsdGFNb2RlOmkucGl4ZWxzfSk7dGhpcy5yZXBvcnRXaGVlbEV2ZW50KGUpfXRvU3RhdGUoQSl7dGhpcy5sb2coW1wiaWRsZVwiLFwib25lRmluZ2VyRGVjaWRpbmdcIixcInR3b0ZpbmdlcnNEZWNpZGluZ1wiLFwibW92aW5nXCIsXCJkcmFnZ2luZ1wiLFwiaG9sZGluZ1JpZ2h0TW91c2VCdXR0b25cIixcInpvb21pbmdcIixcInNjcm9sbGluZ1wiXVtBXSksdGhpcy5zdGF0ZT1BfXByb2Nlc3NQb2ludGVyRXZlbnQoQSl7aWYoXCJ0b3VjaFwiPT09QS5wb2ludGVyVHlwZSlzd2l0Y2goQS50eXBlKXtjYXNlXCJwb2ludGVyZG93blwiOnRoaXMub25Qb2ludGVyRG93bihBKTticmVhaztjYXNlXCJwb2ludGVydXBcIjp0aGlzLm9uUG9pbnRlclVwKEEpO2JyZWFrO2Nhc2VcInBvaW50ZXJyYXd1cGRhdGVcIjpjYXNlXCJwb2ludGVybW92ZVwiOnRoaXMub25Qb2ludGVyTW92ZShBKX1lbHNlIHRoaXMucmVwb3J0UG9pbnRlckV2ZW50KEEpfX19LDI4MjQ6KEEsZSxJKT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLGUuUmFpbndheUlucHV0TWFuYWdlcj1lLm1vdXNlQ2xpY2tGcm9tPXZvaWQgMDtjb25zdCBnPUkoMjk5NCksdD1JKDY5MDQpLGk9SSg5MDQwKSxCPUkoODMyMiksQz1JKDY1KSxRPUkoNTUyOCksbz1JKDY5MDQpLG49SSg4ODQpO2Z1bmN0aW9uIGEoQSl7bGV0IGUsSTtzd2l0Y2goQS5idXR0b24pe2RlZmF1bHQ6Y2FzZSAwOmU9MCE9KDEmQS5idXR0b25zKSxJPW8uTW91c2VCdXR0b24uTGVmdDticmVhaztjYXNlIDE6ZT0wIT0oNCZBLmJ1dHRvbnMpLEk9by5Nb3VzZUJ1dHRvbi5NaWRkbGU7YnJlYWs7Y2FzZSAyOmU9MCE9KDImQS5idXR0b25zKSxJPW8uTW91c2VCdXR0b24uUmlnaHQ7YnJlYWs7Y2FzZSAzOmU9MCE9KDgmQS5idXR0b25zKSxJPW8uTW91c2VCdXR0b24uWDE7YnJlYWs7Y2FzZSA0OmU9MCE9KDE2JkEuYnV0dG9ucyksST1vLk1vdXNlQnV0dG9uLlgyfXJldHVybntidXR0b246SSxhY3Rpb246ZT9vLkJ1dHRvbkFjdGlvbi5CdXR0b25Eb3duOm8uQnV0dG9uQWN0aW9uLkJ1dHRvblVwfX1mdW5jdGlvbiByKEEpe3JldHVybiBBLmF4ZXMubGVuZ3RoPj00JiZBLmJ1dHRvbnMubGVuZ3RoPj0xNn1mdW5jdGlvbiBFKEEsZSl7aWYoQT09PWUpcmV0dXJuITA7aWYoQS5sZW5ndGghPT1lLmxlbmd0aClyZXR1cm4hMTtmb3IobGV0IEk9MDtJPEEubGVuZ3RoOysrSSlpZihBW0ldIT09ZVtJXSlyZXR1cm4hMTtyZXR1cm4hMH1lLm1vdXNlQ2xpY2tGcm9tPWEsZS5SYWlud2F5SW5wdXRNYW5hZ2VyPWNsYXNze2NvbnN0cnVjdG9yKEEsZT17dG91Y2hHZXN0dXJlczohMSx1bmxvY2tlZE1vdXNlUG9pbnRlcjohMSxlbWJyYWNlTW91c2VBY2NlbGVyYXRpb246ITF9KXt0aGlzLnJhaW53YXlTdHJlYW09QSx0aGlzLm9wdGlvbnM9ZSx0aGlzLmxldmVsPXQuSW5wdXRMZXZlbC5Ob25lLHRoaXMuY29udGFpbmVyPXZvaWQgMCx0aGlzLmhlbGRLZXlzPW5ldyBTZXQsdGhpcy5hbHdheXNSZXBvcnRHYW1lcGFkUG9sbD0hMCx0aGlzLmxvY2tQb2ludGVyPSgpPT57aWYodGhpcy5vcHRpb25zLnVubG9ja2VkTW91c2VQb2ludGVyKXJldHVybjtpZighdGhpcy5jb250YWluZXIpcmV0dXJuO2lmKCF0aGlzLmNvbnRhaW5lci5yZXF1ZXN0UG9pbnRlckxvY2spcmV0dXJuO2NvbnN0IEE9IXRoaXMub3B0aW9ucy5lbWJyYWNlTW91c2VBY2NlbGVyYXRpb24sZT1BP3RoaXMuY29udGFpbmVyLnJlcXVlc3RQb2ludGVyTG9jayh7dW5hZGp1c3RlZE1vdmVtZW50OiEwfSk6dGhpcy5jb250YWluZXIucmVxdWVzdFBvaW50ZXJMb2NrKCk7ZSBpbnN0YW5jZW9mIFByb21pc2U/ZS5jYXRjaCgoZT0+e3ZhciBJO1wiTm90U3VwcG9ydGVkRXJyb3JcIj09PWUubmFtZSYmQSYmKG51bGw9PT0oST10aGlzLmNvbnRhaW5lcil8fHZvaWQgMD09PUl8fEkucmVxdWVzdFBvaW50ZXJMb2NrKCkpfSkpOnRoaXMuY29udGFpbmVyLm9ucG9pbnRlcmxvY2tlcnJvcj0oKT0+e3ZhciBlO0EmJihudWxsPT09KGU9dGhpcy5jb250YWluZXIpfHx2b2lkIDA9PT1lfHxlLnJlcXVlc3RQb2ludGVyTG9jaygpKX0sdGhpcy5jb250YWluZXIuZm9jdXMoKX0sdGhpcy5mb2N1c0NvbnRhaW5lcj0oKT0+e3ZhciBBO3JldHVybiBudWxsPT09KEE9dGhpcy5jb250YWluZXIpfHx2b2lkIDA9PT1BP3ZvaWQgMDpBLmZvY3VzKCl9LHRoaXMub25Qb2ludGVyRXZlbnRXaXRoR2VzdHVyZVByb2Nlc3Npbmc9QT0+eyhBLnBvaW50ZXJUeXBlJiZcIm1vdXNlXCIhPT1BLnBvaW50ZXJUeXBlfHxkb2N1bWVudC5wb2ludGVyTG9ja0VsZW1lbnQ9PT10aGlzLmNvbnRhaW5lcikmJih0aGlzLm9wdGlvbnMudG91Y2hHZXN0dXJlcyYmXCJ0b3VjaFwiPT09QS5wb2ludGVyVHlwZT8oQS5wcmV2ZW50RGVmYXVsdCgpLHRoaXMuZ2VzdHVyZVJlY29nbml6ZXIucHJvY2Vzc1BvaW50ZXJFdmVudChBKSk6dGhpcy5vblBvaW50ZXJFdmVudChBKSl9LHRoaXMub25Qb2ludGVyRXZlbnRGcm9tR2VzdHVyZVJlY29nbml6ZXI9QT0+e3RoaXMub25Qb2ludGVyRXZlbnQoQSl9LHRoaXMub25Qb2ludGVyRXZlbnQ9QT0+e3RoaXMuY3Vyc29yUGFpbnRlci51cGRhdGUoQSx0aGlzLnJlbWVtYmVyZWRPZmZzZXRYLHRoaXMucmVtZW1iZXJlZE9mZnNldFkpLHRoaXMucmVwb3J0UG9pbnRlckV2ZW50KEEpfSx0aGlzLnNjcm9sbGVkQW1vdW50PTAsdGhpcy5vbldoZWVsRXZlbnQ9QT0+e3RoaXMuc2Nyb2xsZWRBbW91bnQrPS4wNSpBLmRlbHRhWSx0aGlzLnNjcm9sbGVkQW1vdW50Pj0xPyh0aGlzLnNlbmRWZXJ0aWNhbFNjcm9sbChNYXRoLmZsb29yKHRoaXMuc2Nyb2xsZWRBbW91bnQpKSx0aGlzLnNjcm9sbGVkQW1vdW50JT0xKTp0aGlzLnNjcm9sbGVkQW1vdW50PD0tMSYmKHRoaXMuc2VuZFZlcnRpY2FsU2Nyb2xsKE1hdGguY2VpbCh0aGlzLnNjcm9sbGVkQW1vdW50KSksdGhpcy5zY3JvbGxlZEFtb3VudCU9LTEpfSx0aGlzLm9uS2V5Ym9hcmRFdmVudD1BPT57QS5wcmV2ZW50RGVmYXVsdCgpO2NvbnN0IGU9aS5SYWlud2F5VmlydHVhbEtleUZyb21XZWJLZXlDb2RlW0EuY29kZV0sST1cImtleWRvd25cIj09PUEudHlwZTtlJiYoST90aGlzLmhlbGRLZXlzLmFkZChlKTp0aGlzLmhlbGRLZXlzLmRlbGV0ZShlKSx0aGlzLnNlbmRJbnB1dERhdGFncmFtKHtkaXNjcmltaW5hdG9yOm8uS2V5Ym9hcmRJbnB1dC5kaXNjcmltaW5hdG9yLHZhbHVlOnthY3Rpb246ST9vLktleWJvYXJkQWN0aW9uLktleURvd246by5LZXlib2FyZEFjdGlvbi5LZXlVcCxrZXljb2RlOmV9fSkpfSx0aGlzLm9uR2FtZXBhZENvbm5lY3RlZEV2ZW50PUE9Pnt9LHRoaXMub25HYW1lcGFkRGlzY29ubmVjdGVkRXZlbnQ9QT0+e30sdGhpcy5vbkRldmljZU1vdGlvbj1BPT57fSx0aGlzLm9uRGV2aWNlT3JpZW50YXRpb249QT0+e30sdGhpcy5nYW1lcGFkQ2FjaGU9bmV3IE1hcCx0aGlzLnBvbGxHYW1lcGFkcz1BPT57aWYobmF2aWdhdG9yLmdldEdhbWVwYWRzKXtpZih0aGlzLmNvbnRhaW5lcj09PWRvY3VtZW50LmFjdGl2ZUVsZW1lbnQpe2NvbnN0IEE9W107Zm9yKGNvbnN0IGUgb2YgbmF2aWdhdG9yLmdldEdhbWVwYWRzKCkpe2lmKCFlfHwhcihlKSljb250aW51ZTtjb25zdCBJPWUuYnV0dG9ucy5tYXAoKEE9PkEudmFsdWUpKSxnPXRoaXMuZ2FtZXBhZENhY2hlLmdldChlLmluZGV4KTtnJiZFKGcuYXhlcyxlLmF4ZXMpJiZFKGcuYnV0dG9uVmFsdWVzLEkpfHwoQS5wdXNoKHRoaXMubWFrZUdhbWVwYWRJbnB1dEV2ZW50KGUpKSx0aGlzLmdhbWVwYWRDYWNoZS5zZXQoZS5pbmRleCx7YXhlczpbLi4uZS5heGVzXSxidXR0b25WYWx1ZXM6SX0pKX0odGhpcy5hbHdheXNSZXBvcnRHYW1lcGFkUG9sbHx8QS5sZW5ndGg+MCkmJnRoaXMucmVwb3J0R2FtZXBhZEV2ZW50cyhBKX10aGlzLmxldmVsJnQuSW5wdXRMZXZlbC5HYW1lcGFkJiYodGhpcy5nYW1lcGFkRnJhbWVIYW5kbGU9d2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSh0aGlzLnBvbGxHYW1lcGFkcykpfX0sdGhpcy5yZXBvcnRHYW1lcGFkRXZlbnRzPUE9Pntmb3IoY29uc3QgZSBvZiBBKXtsZXQgQT0wO2UuYnV0dG9ucy5kcGFkVXAmJihBfD0xKSxlLmJ1dHRvbnMuZHBhZERvd24mJihBfD0yKSxlLmJ1dHRvbnMuZHBhZExlZnQmJihBfD00KSxlLmJ1dHRvbnMuZHBhZFJpZ2h0JiYoQXw9OCksZS5idXR0b25zLnN0YXJ0JiYoQXw9MTYpLGUuYnV0dG9ucy5zZWxlY3QmJihBfD0zMiksZS5idXR0b25zLmxlZnRTdGlja1ByZXNzZWQmJihBfD02NCksZS5idXR0b25zLnJpZ2h0U3RpY2tQcmVzc2VkJiYoQXw9MTI4KSxlLmJ1dHRvbnMubGVmdFNob3VsZGVyJiYoQXw9MjU2KSxlLmJ1dHRvbnMucmlnaHRTaG91bGRlciYmKEF8PTUxMiksZS5idXR0b25zLmEmJihBfD00MDk2KSxlLmJ1dHRvbnMuYiYmKEF8PTgxOTIpLGUuYnV0dG9ucy54JiYoQXw9MTYzODQpLGUuYnV0dG9ucy55JiYoQXw9MzI3NjgpO2NvbnN0IEk9e2J1dHRvbnM6QSxsZWZ0VHJpZ2dlcjpNYXRoLnJvdW5kKDI1NSplLmJ1dHRvbnMubGVmdFRyaWdnZXIpLHJpZ2h0VHJpZ2dlcjpNYXRoLnJvdW5kKDI1NSplLmJ1dHRvbnMucmlnaHRUcmlnZ2VyKSxsZWZ0VGh1bWJYOk1hdGgucm91bmQoMzI3NjcqZS5zdGlja3MubGVmdC54KSxsZWZ0VGh1bWJZOk1hdGgucm91bmQoMzI3NjcqLWUuc3RpY2tzLmxlZnQueSkscmlnaHRUaHVtYlg6TWF0aC5yb3VuZCgzMjc2NyplLnN0aWNrcy5yaWdodC54KSxyaWdodFRodW1iWTpNYXRoLnJvdW5kKDMyNzY3Ki1lLnN0aWNrcy5yaWdodC55KSxzbG90OjF9O3RoaXMuc2VuZElucHV0RGF0YWdyYW0oe2Rpc2NyaW1pbmF0b3I6by5HYW1lcGFkUmVwb3J0LmRpc2NyaW1pbmF0b3IsdmFsdWU6SX0pfX0sdGhpcy5tb3ZlTW91c2VSZWxhdGl2ZVhZPShBLGUpPT57dGhpcy5zZW5kTW91c2VNb3ZlKFwicmVsYXRpdmVcIixBLGUpfSx0aGlzLm1vdmVNb3VzZUFic29sdXRlWFk9KEEsZSk9Pnt0aGlzLnNlbmRNb3VzZU1vdmUoXCJhYnNvbHV0ZVwiLEEsZSl9LHRoaXMucG9pbnRlckZyYW1lSWQ9MCx0aGlzLnJlbWVtYmVyZWRPZmZzZXRYPTAsdGhpcy5yZW1lbWJlcmVkT2Zmc2V0WT0wLHRoaXMudG91Y2hlcz1uZXcgTWFwLHRoaXMucmVwb3J0UG9pbnRlckV2ZW50PUE9PntpZihcInRvdWNoXCI9PT1BLnBvaW50ZXJUeXBlfHxcInBlblwiPT09QS5wb2ludGVyVHlwZSl7aWYoZG9jdW1lbnQucG9pbnRlckxvY2tFbGVtZW50PT09dGhpcy5jb250YWluZXIpe2NvbnN0IGU9dGhpcy5jb250YWluZXIuY2xpZW50V2lkdGgsST10aGlzLmNvbnRhaW5lci5jbGllbnRIZWlnaHQsZz1BLm1vdmVtZW50WCx0PUEubW92ZW1lbnRZO3RoaXMucmVtZW1iZXJlZE9mZnNldFg9TWF0aC5tYXgoMCxNYXRoLm1pbihlLHRoaXMucmVtZW1iZXJlZE9mZnNldFgrZykpLHRoaXMucmVtZW1iZXJlZE9mZnNldFk9TWF0aC5tYXgoMCxNYXRoLm1pbihJLHRoaXMucmVtZW1iZXJlZE9mZnNldFkrdCkpfWVsc2UgdGhpcy5yZW1lbWJlcmVkT2Zmc2V0WD1BLm9mZnNldFgsdGhpcy5yZW1lbWJlcmVkT2Zmc2V0WT1BLm9mZnNldFk7Y29uc3QgZT10aGlzLnJhaW53YXlTdHJlYW0udHJhbnNmb3JtUG9pbnRlck9mZnNldFRvUmVtb3RlKHRoaXMucmVtZW1iZXJlZE9mZnNldFgsdGhpcy5yZW1lbWJlcmVkT2Zmc2V0WSk7aWYoIWUpcmV0dXJuO2NvbnN0e3g6SSx5Omd9PWUsaT1NYXRoLmNlaWwoQS53aWR0aC8yKSxCPU1hdGguY2VpbChBLmhlaWdodC8yKSx7cG9pbnRlcklkOkMsYnV0dG9uczpRfT1BLG89XCJwb2ludGVyY2FuY2VsXCI9PT1BLnR5cGV8fFwicG9pbnRlcm91dFwiPT09QS50eXBlfHxcInBvaW50ZXJsZWF2ZVwiPT09QS50eXBlLG49UT4wLGE9KFwicG9pbnRlcm92ZXJcIj09PUEudHlwZT90LldpbmRvd3NQb2ludGVyRmxhZ3MuTmV3OjApfChuP3QuV2luZG93c1BvaW50ZXJGbGFncy5JbkNvbnRhY3Q6MCl8KDE9PSgzJlEpP3QuV2luZG93c1BvaW50ZXJGbGFncy5GaXJzdEJ1dHRvbjowKXwoMz09KDMmUSk/dC5XaW5kb3dzUG9pbnRlckZsYWdzLlNlY29uZEJ1dHRvbjowKXwoQS5pc1ByaW1hcnk/dC5XaW5kb3dzUG9pbnRlckZsYWdzLlByaW1hcnk6MCl8KFwicG9pbnRlcmNhbmNlbFwiPT09QS50eXBlP3QuV2luZG93c1BvaW50ZXJGbGFncy5DYW5jZWxlZDowKXwoXCJwb2ludGVyZG93blwiPT09QS50eXBlP3QuV2luZG93c1BvaW50ZXJGbGFncy5Eb3duOlwicG9pbnRlcnVwXCI9PT1BLnR5cGU/dC5XaW5kb3dzUG9pbnRlckZsYWdzLlVwOnQuV2luZG93c1BvaW50ZXJGbGFncy5VcGRhdGUpfChvP24/dC5XaW5kb3dzUG9pbnRlckZsYWdzLlVwOnQuV2luZG93c1BvaW50ZXJGbGFncy5VcGRhdGU6dC5XaW5kb3dzUG9pbnRlckZsYWdzLkluUmFuZ2UpLHI9e3BvaW50ZXJJZDpDLGZyYW1lSWQ6Kyt0aGlzLnBvaW50ZXJGcmFtZUlkLHBvaW50ZXJGbGFnczphLHg6SSx5Omd9LEU9TWF0aC5yb3VuZChBLnR3aXN0KSUzNjAscz1NYXRoLnJvdW5kKDEwMjQqQS5wcmVzc3VyZSk7aWYoXCJ0b3VjaFwiPT09QS5wb2ludGVyVHlwZSl7Y29uc3QgQT17cG9pbnRlckluZm86cix0b3VjaE1hc2s6dC5Ub3VjaE1hc2suQ29udGFjdEFyZWF8dC5Ub3VjaE1hc2suT3JpZW50YXRpb258dC5Ub3VjaE1hc2suUHJlc3N1cmUsY29udGFjdExlZnQ6SS1pLGNvbnRhY3RUb3A6Zy1CLGNvbnRhY3RSaWdodDpJK2ksY29udGFjdEJvdHRvbTpnK0Isb3JpZW50YXRpb246RSxwcmVzc3VyZTpzfTt0aGlzLnRvdWNoZXMuc2V0KEMsQSksdGhpcy5zZW5kSW5wdXREYXRhZ3JhbSh7ZGlzY3JpbWluYXRvcjp0LlRvdWNoZXNBYnNvbHV0ZS5kaXNjcmltaW5hdG9yLHZhbHVlOnt0b3VjaGVzOlsuLi50aGlzLnRvdWNoZXMudmFsdWVzKCldfX0pLG8mJnRoaXMudG91Y2hlcy5kZWxldGUoQyl9ZWxzZXtjb25zdCBlPSgyJlE/dC5QZW5GbGFncy5CYXJyZWw6MCl8KDMyJlE/dC5QZW5GbGFncy5FcmFzZXI6MCk7dGhpcy5zZW5kSW5wdXREYXRhZ3JhbSh7ZGlzY3JpbWluYXRvcjp0LlBlbkFic29sdXRlLmRpc2NyaW1pbmF0b3IsdmFsdWU6e3BvaW50ZXJJbmZvOnIscGVuTWFzazp0LlBlbk1hc2suUHJlc3N1cmV8dC5QZW5NYXNrLlJvdGF0aW9ufHQuUGVuTWFzay5UaWx0WHx0LlBlbk1hc2suVGlsdFkscGVuRmxhZ3M6ZSxyb3RhdGlvbjpFLHByZXNzdXJlOnMsdGlsdFg6TWF0aC5yb3VuZChBLnRpbHRYKSx0aWx0WTpNYXRoLnJvdW5kKEEudGlsdFkpfX0pfX1lbHNlIGlmKChBLm1vdmVtZW50WHx8QS5tb3ZlbWVudFkpJiZ0aGlzLnNlbmRNb3VzZU1vdmUoXCJyZWxhdGl2ZVwiLEEubW92ZW1lbnRYLEEubW92ZW1lbnRZKSxBLmJ1dHRvbj4tMSl7Y29uc3QgZT1hKEEpO3RoaXMuc2VuZE1vdXNlQ2xpY2soZSl9fSx0aGlzLmN1cnNvclBhaW50ZXI9bmV3IEMuUmFpbndheUN1cnNvclBhaW50ZXIodGhpcy5tb3ZlTW91c2VBYnNvbHV0ZVhZLCgoQSxlKT0+dGhpcy5yYWlud2F5U3RyZWFtLnRyYW5zZm9ybVBvaW50ZXJPZmZzZXRUb1JlbW90ZShBLGUpKSwoKCk9PnRoaXMucmFpbndheVN0cmVhbS5jdXJyZW50RnJhbWVTaXplKSksdGhpcy5nZXN0dXJlUmVjb2duaXplcj1uZXcgQi5SYWlud2F5R2VzdHVyZVJlY29nbml6ZXIodGhpcy5vblBvaW50ZXJFdmVudEZyb21HZXN0dXJlUmVjb2duaXplcix0aGlzLm9uV2hlZWxFdmVudCksdGhpcy5vdXRnb2luZ0lucHV0RmlsdGVyPSgpPT4hMH1zZXRDb250YWluZXIoQSl7aWYodGhpcy5jdXJzb3JQYWludGVyLnNldENvbnRhaW5lcihBKSx0aGlzLmNvbnRhaW5lcil7Y29uc3QgZT10aGlzLmxldmVsO3RoaXMuc2V0SW5wdXRMZXZlbCh0LklucHV0TGV2ZWwuTm9uZSwhMSksdGhpcy5jb250YWluZXI9QSx0aGlzLnNldElucHV0TGV2ZWwoZSwhMSl9ZWxzZSB0aGlzLmNvbnRhaW5lcj1BfXVuc2V0Q29udGFpbmVyKCl7dGhpcy5zZXRJbnB1dExldmVsKHQuSW5wdXRMZXZlbC5Ob25lLCExKSx0aGlzLmN1cnNvclBhaW50ZXIudW5zZXRDb250YWluZXIoKSx0aGlzLmNvbnRhaW5lcj12b2lkIDB9c2V0SW5wdXRMZXZlbChBLGU9ITAsST0hMCl7dGhpcy5hbHdheXNSZXBvcnRHYW1lcGFkUG9sbD1JO2NvbnN0IGc9QSZ+dGhpcy5sZXZlbCxpPXRoaXMubGV2ZWwmfkE7dGhpcy5sZXZlbD1BLGcmdC5JbnB1dExldmVsLkdhbWVwYWQmJnRoaXMuc3RhcnRHYW1lcGFkKGUpLGkmdC5JbnB1dExldmVsLkdhbWVwYWQmJnRoaXMuc3RvcEdhbWVwYWQoKSxnJnQuSW5wdXRMZXZlbC5Nb3VzZSYmdGhpcy5zdGFydE1vdXNlKCksaSZ0LklucHV0TGV2ZWwuTW91c2UmJnRoaXMuc3RvcE1vdXNlKCksZyZ0LklucHV0TGV2ZWwuS2V5Ym9hcmQmJnRoaXMuc3RhcnRLZXlib2FyZCgpLGkmdC5JbnB1dExldmVsLktleWJvYXJkJiZ0aGlzLnN0b3BLZXlib2FyZCgpfWdldElucHV0TGV2ZWwoKXtyZXR1cm4gdGhpcy5sZXZlbH1zdGFydEdhbWVwYWQoQSl7d2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJnYW1lcGFkY29ubmVjdGVkXCIsdGhpcy5vbkdhbWVwYWRDb25uZWN0ZWRFdmVudCksd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJnYW1lcGFkZGlzY29ubmVjdGVkXCIsdGhpcy5vbkdhbWVwYWREaXNjb25uZWN0ZWRFdmVudCksdGhpcy5nYW1lcGFkRnJhbWVIYW5kbGU9d2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSh0aGlzLnBvbGxHYW1lcGFkcyksQSYmdGhpcy5yZXBvcnRDb25uZWN0ZWRHYW1lcGFkcygpfXJlcG9ydENvbm5lY3RlZEdhbWVwYWRzKCl7Zm9yKGNvbnN0IEEgb2YgbmF2aWdhdG9yLmdldEdhbWVwYWRzKCkpQSYmdGhpcy5vbkdhbWVwYWRDb25uZWN0ZWRFdmVudChuZXcgR2FtZXBhZEV2ZW50KFwiZ2FtZXBhZGNvbm5lY3RlZFwiLHtnYW1lcGFkOkF9KSl9c3RvcEdhbWVwYWQoKXt3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImdhbWVwYWRjb25uZWN0ZWRcIix0aGlzLm9uR2FtZXBhZENvbm5lY3RlZEV2ZW50KSx3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImdhbWVwYWRkaXNjb25uZWN0ZWRcIix0aGlzLm9uR2FtZXBhZERpc2Nvbm5lY3RlZEV2ZW50KSx0aGlzLmdhbWVwYWRGcmFtZUhhbmRsZSYmd2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMuZ2FtZXBhZEZyYW1lSGFuZGxlKSx0aGlzLmdhbWVwYWRGcmFtZUhhbmRsZT12b2lkIDB9cG9pbnRlckV2ZW50TGlzdGVuZXJzKEEpe2lmKCF3aW5kb3cuUG9pbnRlckV2ZW50KXRocm93IG5ldyBFcnJvcihcImJyb3dzZXIgZG9lcyBub3Qgc3VwcG9ydCBQb2ludGVyRXZlbnRcIik7QShRLmlzRGVza3RvcFNhZmFyaSYmbmF2aWdhdG9yLm1heFRvdWNoUG9pbnRzPDE/XCJtb3VzZW1vdmVcIjp3aW5kb3cub25wb2ludGVycmF3dXBkYXRlP1wicG9pbnRlcnJhd3VwZGF0ZVwiOlwicG9pbnRlcm1vdmVcIix0aGlzLm9uUG9pbnRlckV2ZW50V2l0aEdlc3R1cmVQcm9jZXNzaW5nKSxBKFwicG9pbnRlcmRvd25cIix0aGlzLm9uUG9pbnRlckV2ZW50V2l0aEdlc3R1cmVQcm9jZXNzaW5nKSxBKFwicG9pbnRlcnVwXCIsdGhpcy5vblBvaW50ZXJFdmVudFdpdGhHZXN0dXJlUHJvY2Vzc2luZyksQShcInBvaW50ZXJvdmVyXCIsdGhpcy5vblBvaW50ZXJFdmVudFdpdGhHZXN0dXJlUHJvY2Vzc2luZyksQShcInBvaW50ZXJlbnRlclwiLHRoaXMub25Qb2ludGVyRXZlbnRXaXRoR2VzdHVyZVByb2Nlc3NpbmcpLEEoXCJwb2ludGVyY2FuY2VsXCIsdGhpcy5vblBvaW50ZXJFdmVudFdpdGhHZXN0dXJlUHJvY2Vzc2luZyksQShcInBvaW50ZXJvdXRcIix0aGlzLm9uUG9pbnRlckV2ZW50V2l0aEdlc3R1cmVQcm9jZXNzaW5nKSxBKFwicG9pbnRlcmxlYXZlXCIsdGhpcy5vblBvaW50ZXJFdmVudFdpdGhHZXN0dXJlUHJvY2Vzc2luZyksQShcIndoZWVsXCIsdGhpcy5vbldoZWVsRXZlbnQpLEEoXCJtb3VzZXVwXCIsdGhpcy5sb2NrUG9pbnRlcil9c3RhcnRNb3VzZSgpe2lmKCF0aGlzLmNvbnRhaW5lcil0aHJvdyBuZXcgZy5SYWlud2F5RXJyb3IoXCJSYWlud2F5IHRyaWVkIHRvIGFkZCBhbiBldmVudCBsaXN0ZW5lciB0byBpdHMgY29udGFpbmVyIHRvIGhhbmRsZSBtb3VzZSBpbnB1dCwgYnV0IG5vIGNvbnRhaW5lciBlbGVtZW50IGlzIHNldC4gVHJ5IGNhbGxpbmcgc2V0Q29udGFpbmVyKCkgZmlyc3QuXCIpO3RoaXMucG9pbnRlckV2ZW50TGlzdGVuZXJzKHRoaXMuY29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIuYmluZCh0aGlzLmNvbnRhaW5lcikpfXN0b3BNb3VzZSgpe3RoaXMuY29udGFpbmVyJiZ0aGlzLnBvaW50ZXJFdmVudExpc3RlbmVycyh0aGlzLmNvbnRhaW5lci5yZW1vdmVFdmVudExpc3RlbmVyLmJpbmQodGhpcy5jb250YWluZXIpKX1zdGFydEtleWJvYXJkKCl7aWYoIXRoaXMuY29udGFpbmVyKXRocm93IG5ldyBnLlJhaW53YXlFcnJvcihcIlJhaW53YXkgdHJpZWQgdG8gYWRkIGFuIGV2ZW50IGxpc3RlbmVyIHRvIGl0cyBjb250YWluZXIgdG8gaGFuZGxlIGtleWJvYXJkIGlucHV0LCBidXQgbm8gY29udGFpbmVyIGVsZW1lbnQgaXMgc2V0LiBUcnkgY2FsbGluZyBzZXRDb250YWluZXIoKSBmaXJzdC5cIik7dGhpcy5jb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIix0aGlzLm9uS2V5Ym9hcmRFdmVudCksdGhpcy5jb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcihcImtleXVwXCIsdGhpcy5vbktleWJvYXJkRXZlbnQpLHRoaXMuY29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLHRoaXMuZm9jdXNDb250YWluZXIpLHRoaXMuY29udGFpbmVyLmZvY3VzKCl9c3RvcEtleWJvYXJkKCl7dGhpcy5jb250YWluZXImJih0aGlzLnJlbGVhc2VLZXlzKCksdGhpcy5jb250YWluZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIix0aGlzLm9uS2V5Ym9hcmRFdmVudCksdGhpcy5jb250YWluZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImtleXVwXCIsdGhpcy5vbktleWJvYXJkRXZlbnQpLHRoaXMuY29udGFpbmVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLHRoaXMuZm9jdXNDb250YWluZXIpKX1zdGFydERldmljZU1vdGlvbkV2ZW50cygpe3dpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwiZGV2aWNlbW90aW9uXCIsdGhpcy5vbkRldmljZU1vdGlvbil9c3RvcERldmljZU1vdGlvbkV2ZW50cygpe3dpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwiZGV2aWNlbW90aW9uXCIsdGhpcy5vbkRldmljZU1vdGlvbil9c3RhcnREZXZpY2VPcmllbnRhdGlvbkV2ZW50cygpe3dpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwiZGV2aWNlb3JpZW50YXRpb25cIix0aGlzLm9uRGV2aWNlT3JpZW50YXRpb24pfXN0b3BEZXZpY2VPcmllbnRhdGlvbkV2ZW50cygpe3dpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwiZGV2aWNlb3JpZW50YXRpb25cIix0aGlzLm9uRGV2aWNlT3JpZW50YXRpb24pfXNlbmRWZXJ0aWNhbFNjcm9sbChBKXt0aGlzLnNlbmRJbnB1dERhdGFncmFtKHtkaXNjcmltaW5hdG9yOm8uTW91c2VTY3JvbGwuZGlzY3JpbWluYXRvcix2YWx1ZTp7YXhpczpvLlNjcm9sbEF4aXMuVmVydGljYWwsZGVsdGE6QX19KX1tYWtlR2FtZXBhZElucHV0RXZlbnQoQSl7dmFyIGUsSSxnLHQsaSxCLEMsUSxvLG4sYSxyLEUscyxkLGMsaCxELHUsdyxsLHksUyxGLFIscCxHLGYsbSxrLFUsTixNLEwsdixILEsscTtyZXR1cm57aWQ6QS5pZCxpbmRleDpBLmluZGV4LGJ1dHRvbnM6e2E6bnVsbCE9PShJPW51bGw9PT0oZT1BLmJ1dHRvbnNbMF0pfHx2b2lkIDA9PT1lP3ZvaWQgMDplLnZhbHVlKSYmdm9pZCAwIT09ST9JOjAsYjpudWxsIT09KHQ9bnVsbD09PShnPUEuYnV0dG9uc1sxXSl8fHZvaWQgMD09PWc/dm9pZCAwOmcudmFsdWUpJiZ2b2lkIDAhPT10P3Q6MCx4Om51bGwhPT0oQj1udWxsPT09KGk9QS5idXR0b25zWzJdKXx8dm9pZCAwPT09aT92b2lkIDA6aS52YWx1ZSkmJnZvaWQgMCE9PUI/QjowLHk6bnVsbCE9PShRPW51bGw9PT0oQz1BLmJ1dHRvbnNbM10pfHx2b2lkIDA9PT1DP3ZvaWQgMDpDLnZhbHVlKSYmdm9pZCAwIT09UT9ROjAsbGVmdFNob3VsZGVyOm51bGwhPT0obj1udWxsPT09KG89QS5idXR0b25zWzRdKXx8dm9pZCAwPT09bz92b2lkIDA6by52YWx1ZSkmJnZvaWQgMCE9PW4/bjowLHJpZ2h0U2hvdWxkZXI6bnVsbCE9PShyPW51bGw9PT0oYT1BLmJ1dHRvbnNbNV0pfHx2b2lkIDA9PT1hP3ZvaWQgMDphLnZhbHVlKSYmdm9pZCAwIT09cj9yOjAsbGVmdFRyaWdnZXI6bnVsbCE9PShzPW51bGw9PT0oRT1BLmJ1dHRvbnNbNl0pfHx2b2lkIDA9PT1FP3ZvaWQgMDpFLnZhbHVlKSYmdm9pZCAwIT09cz9zOjAscmlnaHRUcmlnZ2VyOm51bGwhPT0oYz1udWxsPT09KGQ9QS5idXR0b25zWzddKXx8dm9pZCAwPT09ZD92b2lkIDA6ZC52YWx1ZSkmJnZvaWQgMCE9PWM/YzowLHNlbGVjdDpudWxsIT09KEQ9bnVsbD09PShoPUEuYnV0dG9uc1s4XSl8fHZvaWQgMD09PWg/dm9pZCAwOmgudmFsdWUpJiZ2b2lkIDAhPT1EP0Q6MCxzdGFydDpudWxsIT09KHc9bnVsbD09PSh1PUEuYnV0dG9uc1s5XSl8fHZvaWQgMD09PXU/dm9pZCAwOnUudmFsdWUpJiZ2b2lkIDAhPT13P3c6MCxsZWZ0U3RpY2tQcmVzc2VkOm51bGwhPT0oeT1udWxsPT09KGw9QS5idXR0b25zWzEwXSl8fHZvaWQgMD09PWw/dm9pZCAwOmwudmFsdWUpJiZ2b2lkIDAhPT15P3k6MCxyaWdodFN0aWNrUHJlc3NlZDpudWxsIT09KEY9bnVsbD09PShTPUEuYnV0dG9uc1sxMV0pfHx2b2lkIDA9PT1TP3ZvaWQgMDpTLnZhbHVlKSYmdm9pZCAwIT09Rj9GOjAsZHBhZFVwOm51bGwhPT0ocD1udWxsPT09KFI9QS5idXR0b25zWzEyXSl8fHZvaWQgMD09PVI/dm9pZCAwOlIudmFsdWUpJiZ2b2lkIDAhPT1wP3A6MCxkcGFkRG93bjpudWxsIT09KGY9bnVsbD09PShHPUEuYnV0dG9uc1sxM10pfHx2b2lkIDA9PT1HP3ZvaWQgMDpHLnZhbHVlKSYmdm9pZCAwIT09Zj9mOjAsZHBhZExlZnQ6bnVsbCE9PShrPW51bGw9PT0obT1BLmJ1dHRvbnNbMTRdKXx8dm9pZCAwPT09bT92b2lkIDA6bS52YWx1ZSkmJnZvaWQgMCE9PWs/azowLGRwYWRSaWdodDpudWxsIT09KE49bnVsbD09PShVPUEuYnV0dG9uc1sxNV0pfHx2b2lkIDA9PT1VP3ZvaWQgMDpVLnZhbHVlKSYmdm9pZCAwIT09Tj9OOjAsaG9tZTpudWxsIT09KEw9bnVsbD09PShNPUEuYnV0dG9uc1sxNl0pfHx2b2lkIDA9PT1NP3ZvaWQgMDpNLnZhbHVlKSYmdm9pZCAwIT09TD9MOjB9LHN0aWNrczp7bGVmdDp7eDpudWxsIT09KHY9QS5heGVzWzBdKSYmdm9pZCAwIT09dj92OjAseTpudWxsIT09KEg9QS5heGVzWzFdKSYmdm9pZCAwIT09SD9IOjB9LHJpZ2h0Ont4Om51bGwhPT0oSz1BLmF4ZXNbMl0pJiZ2b2lkIDAhPT1LP0s6MCx5Om51bGwhPT0ocT1BLmF4ZXNbM10pJiZ2b2lkIDAhPT1xP3E6MH19fX1mZWVkR2FtZXBhZElucHV0RXZlbnQoQSl7dGhpcy5yZXBvcnRHYW1lcGFkRXZlbnRzKEEpfXN0YXRpYyB2aWJyYXRlR2FtZXBhZChBLGUpe3ZhciBJLGc7Y29uc3QgdD1uYXZpZ2F0b3IuZ2V0R2FtZXBhZHMoKVtBXTtpZihudWxsPT10P3ZvaWQgMDp0LnZpYnJhdGlvbkFjdHVhdG9yKW51bGw9PT0oZz0oST10LnZpYnJhdGlvbkFjdHVhdG9yKS5wbGF5RWZmZWN0KXx8dm9pZCAwPT09Z3x8Zy5jYWxsKEksXCJkdWFsLXJ1bWJsZVwiLGUpO2Vsc2UgaWYobnVsbD09dD92b2lkIDA6dC5oYXB0aWNBY3R1YXRvcnMpe2NvbnN0IEE9bnVsbD09dD92b2lkIDA6dC5oYXB0aWNBY3R1YXRvcnM7c2V0VGltZW91dCgoKCk9Pnt2YXIgSSxnLHQ7Zm9yKGNvbnN0IGkgb2YgQSlpZihcInB1bHNlXCJpbiBpKXtjb25zdCBBPU1hdGgubWF4KG51bGwhPT0oST1lLnN0cm9uZ01hZ25pdHVkZSkmJnZvaWQgMCE9PUk/STowLG51bGwhPT0oZz1lLndlYWtNYWduaXR1ZGUpJiZ2b2lkIDAhPT1nP2c6MCk7aS5wdWxzZShBLG51bGwhPT0odD1lLmR1cmF0aW9uKSYmdm9pZCAwIT09dD90OjApfX0pLGUuc3RhcnREZWxheSl9fWZlZWRLZXlib2FyZEV2ZW50KEEpe3RoaXMub25LZXlib2FyZEV2ZW50KEEpfXJlbGVhc2VLZXlzKCl7Zm9yKGNvbnN0IEEgb2YgdGhpcy5oZWxkS2V5cyl0aGlzLnNlbmRJbnB1dERhdGFncmFtKHtkaXNjcmltaW5hdG9yOm8uS2V5Ym9hcmRJbnB1dC5kaXNjcmltaW5hdG9yLHZhbHVlOnthY3Rpb246by5LZXlib2FyZEFjdGlvbi5LZXlVcCxrZXljb2RlOkF9fSk7dGhpcy5oZWxkS2V5cy5jbGVhcigpfWZlZWRQb2ludGVyRXZlbnQoQSl7dGhpcy5vblBvaW50ZXJFdmVudChBKX1mZWVkV2hlZWxFdmVudChBKXt0aGlzLm9uV2hlZWxFdmVudChBKX1wcm9jZXNzQ3Vyc29yKEEpe3RoaXMuY3Vyc29yUGFpbnRlci5wcm9jZXNzQ3Vyc29yKEEpfWVuYWJsZUdlc3R1cmVzKCl7dGhpcy5vcHRpb25zLnRvdWNoR2VzdHVyZXM9ITB9ZGlzYWJsZUdlc3R1cmVzKCl7dGhpcy5vcHRpb25zLnRvdWNoR2VzdHVyZXM9ITF9c2VuZE1vdXNlTW92ZShBLGUsSSl7XCJhYnNvbHV0ZVwiPT09QT90aGlzLnNlbmRJbnB1dERhdGFncmFtKHtkaXNjcmltaW5hdG9yOm8uTW91c2VBYnNvbHV0ZS5kaXNjcmltaW5hdG9yLHZhbHVlOnt4OmUseTpJfX0pOnRoaXMuc2VuZElucHV0RGF0YWdyYW0oe2Rpc2NyaW1pbmF0b3I6by5Nb3VzZVJlbGF0aXZlLmRpc2NyaW1pbmF0b3IsdmFsdWU6e2R4OmUsZHk6SX19KX1zZW5kTW91c2VDbGljayhBKXt0aGlzLnNlbmRJbnB1dERhdGFncmFtKHtkaXNjcmltaW5hdG9yOm8uTW91c2VDbGljay5kaXNjcmltaW5hdG9yLHZhbHVlOkF9KX1zZW5kSW5wdXREYXRhZ3JhbShBKXtjb25zdCBlPW4udG9PdXRnb2luZ0lucHV0KEEpO2UmJnRoaXMub3V0Z29pbmdJbnB1dEZpbHRlcihlLG5ldyBuLkhlbGRLZXlzKHRoaXMuaGVsZEtleXMpKSYmdGhpcy5yYWlud2F5U3RyZWFtLnNlbmRJbnB1dChBKX1kaXNwb3NlKCl7dGhpcy51bnNldENvbnRhaW5lcigpfX19LDg4NDooQSxlLEkpPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksZS5IZWxkS2V5cz1lLnRvT3V0Z29pbmdJbnB1dD1lLklucHV0VHlwZT12b2lkIDA7Y29uc3QgZz1JKDY5MDQpO3ZhciB0OyFmdW5jdGlvbihBKXtBW0EuR2FtZXBhZD0wXT1cIkdhbWVwYWRcIixBW0EuTW91c2VBYnNvbHV0ZT0xXT1cIk1vdXNlQWJzb2x1dGVcIixBW0EuTW91c2VSZWxhdGl2ZT0yXT1cIk1vdXNlUmVsYXRpdmVcIixBW0EuTW91c2VDbGljaz0zXT1cIk1vdXNlQ2xpY2tcIixBW0EuTW91c2VTY3JvbGw9NF09XCJNb3VzZVNjcm9sbFwiLEFbQS5LZXlib2FyZD01XT1cIktleWJvYXJkXCIsQVtBLlBhc3RlVGV4dD02XT1cIlBhc3RlVGV4dFwiLEFbQS5Ub3VjaGVzQWJzb2x1dGU9N109XCJUb3VjaGVzQWJzb2x1dGVcIixBW0EuUGVuQWJzb2x1dGU9OF09XCJQZW5BYnNvbHV0ZVwiLEFbQS5WaWV3cG9ydFJlc2l6ZT05XT1cIlZpZXdwb3J0UmVzaXplXCIsQVtBLlNldENsaXBib2FyZFRleHQ9MTBdPVwiU2V0Q2xpcGJvYXJkVGV4dFwifSh0PWUuSW5wdXRUeXBlfHwoZS5JbnB1dFR5cGU9e30pKSxlLnRvT3V0Z29pbmdJbnB1dD1mdW5jdGlvbihBKXtzd2l0Y2goQS5kaXNjcmltaW5hdG9yKXtjYXNlIGcuR2FtZXBhZFJlcG9ydC5kaXNjcmltaW5hdG9yOnJldHVybiBPYmplY3QuYXNzaWduKHt0eXBlOnQuR2FtZXBhZH0sQS52YWx1ZSk7Y2FzZSBnLkdhbWVwYWRSdW1ibGUuZGlzY3JpbWluYXRvcjpyZXR1cm47Y2FzZSBnLk1vdXNlQWJzb2x1dGUuZGlzY3JpbWluYXRvcjpyZXR1cm4gT2JqZWN0LmFzc2lnbih7dHlwZTp0Lk1vdXNlQWJzb2x1dGV9LEEudmFsdWUpO2Nhc2UgZy5Nb3VzZVJlbGF0aXZlLmRpc2NyaW1pbmF0b3I6cmV0dXJuIE9iamVjdC5hc3NpZ24oe3R5cGU6dC5Nb3VzZVJlbGF0aXZlfSxBLnZhbHVlKTtjYXNlIGcuTW91c2VDbGljay5kaXNjcmltaW5hdG9yOnJldHVybiBPYmplY3QuYXNzaWduKHt0eXBlOnQuTW91c2VDbGlja30sQS52YWx1ZSk7Y2FzZSBnLk1vdXNlU2Nyb2xsLmRpc2NyaW1pbmF0b3I6cmV0dXJuIE9iamVjdC5hc3NpZ24oe3R5cGU6dC5Nb3VzZVNjcm9sbH0sQS52YWx1ZSk7Y2FzZSBnLktleWJvYXJkSW5wdXQuZGlzY3JpbWluYXRvcjp7Y29uc3QgZT1BLnZhbHVlLmtleWNvZGU7cmV0dXJue3R5cGU6dC5LZXlib2FyZCxhY3Rpb246QS52YWx1ZS5hY3Rpb24sa2V5OmV9fWNhc2UgZy5Mb2dpY2FsSW5wdXQuZGlzY3JpbWluYXRvcjpyZXR1cm4gT2JqZWN0LmFzc2lnbih7dHlwZTp0LlBhc3RlVGV4dH0sQS52YWx1ZSk7Y2FzZSBnLlRvdWNoZXNBYnNvbHV0ZS5kaXNjcmltaW5hdG9yOnJldHVybiBPYmplY3QuYXNzaWduKHt0eXBlOnQuVG91Y2hlc0Fic29sdXRlfSxBLnZhbHVlKTtjYXNlIGcuUGVuQWJzb2x1dGUuZGlzY3JpbWluYXRvcjpyZXR1cm4gT2JqZWN0LmFzc2lnbih7dHlwZTp0LlBlbkFic29sdXRlfSxBLnZhbHVlKTtjYXNlIGcuVmlld3BvcnRSZXNpemUuZGlzY3JpbWluYXRvcjpyZXR1cm4gT2JqZWN0LmFzc2lnbih7dHlwZTp0LlZpZXdwb3J0UmVzaXplfSxBLnZhbHVlKTtjYXNlIGcuU2V0Q2xpcGJvYXJkVGV4dC5kaXNjcmltaW5hdG9yOnJldHVybiBPYmplY3QuYXNzaWduKHt0eXBlOnQuU2V0Q2xpcGJvYXJkVGV4dH0sQS52YWx1ZSl9fSxlLkhlbGRLZXlzPWNsYXNze2NvbnN0cnVjdG9yKEEpe3RoaXMuaGVsZEtleXM9QX1nZXQga2V5cygpe3JldHVybiB0aGlzLmhlbGRLZXlzfWhhcyhBKXtyZXR1cm4gdGhpcy5oZWxkS2V5cy5oYXMoQSl9Z2V0IGN0cmwoKXtyZXR1cm4gdGhpcy5oZWxkS2V5cy5oYXMoZy5WaXJ0dWFsS2V5LkxlZnRDdHJsKXx8dGhpcy5oZWxkS2V5cy5oYXMoZy5WaXJ0dWFsS2V5LlJpZ2h0Q3RybCl9Z2V0IGFsdCgpe3JldHVybiB0aGlzLmhlbGRLZXlzLmhhcyhnLlZpcnR1YWxLZXkuTGVmdEFsdCl8fHRoaXMuaGVsZEtleXMuaGFzKGcuVmlydHVhbEtleS5SaWdodEFsdCl9Z2V0IHdpbigpe3JldHVybiB0aGlzLmhlbGRLZXlzLmhhcyhnLlZpcnR1YWxLZXkuTFdpbil8fHRoaXMuaGVsZEtleXMuaGFzKGcuVmlydHVhbEtleS5SV2luKX1nZXQgc2hpZnQoKXtyZXR1cm4gdGhpcy5oZWxkS2V5cy5oYXMoZy5WaXJ0dWFsS2V5LkxlZnRTaGlmdCl8fHRoaXMuaGVsZEtleXMuaGFzKGcuVmlydHVhbEtleS5SaWdodFNoaWZ0KX19fSw5MDQwOihBLGUsSSk9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxlLlJhaW53YXlWaXJ0dWFsS2V5RnJvbVdlYktleUNvZGU9dm9pZCAwO2NvbnN0IGc9SSg2OTA0KTtlLlJhaW53YXlWaXJ0dWFsS2V5RnJvbVdlYktleUNvZGU9e1VuaWRlbnRpZmllZDpnLlZpcnR1YWxLZXkuTm9uZSxDYW5jZWw6Zy5WaXJ0dWFsS2V5LkNhbmNlbCxCYWNrc3BhY2U6Zy5WaXJ0dWFsS2V5LkJhY2ssVGFiOmcuVmlydHVhbEtleS5UYWIsRW50ZXI6Zy5WaXJ0dWFsS2V5LkVudGVyLFBhdXNlOmcuVmlydHVhbEtleS5QYXVzZSxDYXBzTG9jazpnLlZpcnR1YWxLZXkuQ2Fwc0xvY2ssSGFuZ3VsTW9kZTpnLlZpcnR1YWxLZXkuSGFuZ3VsTW9kZSxLYW5hTW9kZTpnLlZpcnR1YWxLZXkuSGFuZ3VsTW9kZSxMYW5nMTpnLlZpcnR1YWxLZXkuSGFuZ3VsTW9kZSxIYW5qYTpnLlZpcnR1YWxLZXkuSGFuamFNb2RlLExhbmcyOmcuVmlydHVhbEtleS5IYW5qYU1vZGUsRXNjYXBlOmcuVmlydHVhbEtleS5Fc2NhcGUsQ29udmVydDpnLlZpcnR1YWxLZXkuSW1lQ29udmVydCxOb25Db252ZXJ0OmcuVmlydHVhbEtleS5JbWVOb25Db252ZXJ0LFNwYWNlOmcuVmlydHVhbEtleS5TcGFjZSxcIiBcIjpnLlZpcnR1YWxLZXkuU3BhY2UsU3BhY2ViYXI6Zy5WaXJ0dWFsS2V5LlNwYWNlLFBhZ2VVcDpnLlZpcnR1YWxLZXkuUGFnZVVwLFBhZ2VEb3duOmcuVmlydHVhbEtleS5QYWdlRG93bixFbmQ6Zy5WaXJ0dWFsS2V5LkVuZCxIb21lOmcuVmlydHVhbEtleS5Ib21lLEFycm93TGVmdDpnLlZpcnR1YWxLZXkuTGVmdCxBcnJvd1VwOmcuVmlydHVhbEtleS5VcCxBcnJvd1JpZ2h0OmcuVmlydHVhbEtleS5SaWdodCxBcnJvd0Rvd246Zy5WaXJ0dWFsS2V5LkRvd24sU2VsZWN0OmcuVmlydHVhbEtleS5TZWxlY3QsUHJpbnRTY3JlZW46Zy5WaXJ0dWFsS2V5LlByaW50U2NyZWVuLEluc2VydDpnLlZpcnR1YWxLZXkuSW5zZXJ0LERlbGV0ZTpnLlZpcnR1YWxLZXkuRGVsZXRlLEhlbHA6Zy5WaXJ0dWFsS2V5LkhlbHAsRGlnaXQwOmcuVmlydHVhbEtleS5EMCxEaWdpdDE6Zy5WaXJ0dWFsS2V5LkQxLERpZ2l0MjpnLlZpcnR1YWxLZXkuRDIsRGlnaXQzOmcuVmlydHVhbEtleS5EMyxEaWdpdDQ6Zy5WaXJ0dWFsS2V5LkQ0LERpZ2l0NTpnLlZpcnR1YWxLZXkuRDUsRGlnaXQ2OmcuVmlydHVhbEtleS5ENixEaWdpdDc6Zy5WaXJ0dWFsS2V5LkQ3LERpZ2l0ODpnLlZpcnR1YWxLZXkuRDgsRGlnaXQ5OmcuVmlydHVhbEtleS5EOSxLZXlBOmcuVmlydHVhbEtleS5BLEtleUI6Zy5WaXJ0dWFsS2V5LkIsS2V5QzpnLlZpcnR1YWxLZXkuQyxLZXlEOmcuVmlydHVhbEtleS5ELEtleUU6Zy5WaXJ0dWFsS2V5LkUsS2V5RjpnLlZpcnR1YWxLZXkuRixLZXlHOmcuVmlydHVhbEtleS5HLEtleUg6Zy5WaXJ0dWFsS2V5LkgsS2V5STpnLlZpcnR1YWxLZXkuSSxLZXlKOmcuVmlydHVhbEtleS5KLEtleUs6Zy5WaXJ0dWFsS2V5LkssS2V5TDpnLlZpcnR1YWxLZXkuTCxLZXlNOmcuVmlydHVhbEtleS5NLEtleU46Zy5WaXJ0dWFsS2V5Lk4sS2V5TzpnLlZpcnR1YWxLZXkuTyxLZXlQOmcuVmlydHVhbEtleS5QLEtleVE6Zy5WaXJ0dWFsS2V5LlEsS2V5UjpnLlZpcnR1YWxLZXkuUixLZXlTOmcuVmlydHVhbEtleS5TLEtleVQ6Zy5WaXJ0dWFsS2V5LlQsS2V5VTpnLlZpcnR1YWxLZXkuVSxLZXlWOmcuVmlydHVhbEtleS5WLEtleVc6Zy5WaXJ0dWFsS2V5LlcsS2V5WDpnLlZpcnR1YWxLZXkuWCxLZXlZOmcuVmlydHVhbEtleS5ZLEtleVo6Zy5WaXJ0dWFsS2V5LlosTWV0YUxlZnQ6Zy5WaXJ0dWFsS2V5LkxXaW4sT1NMZWZ0OmcuVmlydHVhbEtleS5MV2luLE1ldGFSaWdodDpnLlZpcnR1YWxLZXkuUldpbixPU1JpZ2h0OmcuVmlydHVhbEtleS5SV2luLENvbnRleHRNZW51OmcuVmlydHVhbEtleS5BcHBzLFNsZWVwOmcuVmlydHVhbEtleS5TbGVlcCxOdW1wYWQwOmcuVmlydHVhbEtleS5OdW1QYWQwLE51bXBhZDE6Zy5WaXJ0dWFsS2V5Lk51bVBhZDEsTnVtcGFkMjpnLlZpcnR1YWxLZXkuTnVtUGFkMixOdW1wYWQzOmcuVmlydHVhbEtleS5OdW1QYWQzLE51bXBhZDQ6Zy5WaXJ0dWFsS2V5Lk51bVBhZDQsTnVtcGFkNTpnLlZpcnR1YWxLZXkuTnVtUGFkNSxOdW1wYWQ2OmcuVmlydHVhbEtleS5OdW1QYWQ2LE51bXBhZDc6Zy5WaXJ0dWFsS2V5Lk51bVBhZDcsTnVtcGFkODpnLlZpcnR1YWxLZXkuTnVtUGFkOCxOdW1wYWQ5OmcuVmlydHVhbEtleS5OdW1QYWQ5LE51bXBhZE11bHRpcGx5OmcuVmlydHVhbEtleS5NdWx0aXBseSxOdW1wYWRBZGQ6Zy5WaXJ0dWFsS2V5LkFkZCxOdW1wYWRDb21tYTpnLlZpcnR1YWxLZXkuU2VwYXJhdG9yLE51bXBhZFN1YnRyYWN0OmcuVmlydHVhbEtleS5TdWJ0cmFjdCxOdW1wYWREZWNpbWFsOmcuVmlydHVhbEtleS5EZWNpbWFsLE51bXBhZERpdmlkZTpnLlZpcnR1YWxLZXkuRGl2aWRlLEYxOmcuVmlydHVhbEtleS5GMSxGMjpnLlZpcnR1YWxLZXkuRjIsRjM6Zy5WaXJ0dWFsS2V5LkYzLEY0OmcuVmlydHVhbEtleS5GNCxGNTpnLlZpcnR1YWxLZXkuRjUsRjY6Zy5WaXJ0dWFsS2V5LkY2LEY3OmcuVmlydHVhbEtleS5GNyxGODpnLlZpcnR1YWxLZXkuRjgsRjk6Zy5WaXJ0dWFsS2V5LkY5LEYxMDpnLlZpcnR1YWxLZXkuRjEwLEYxMTpnLlZpcnR1YWxLZXkuRjExLEYxMjpnLlZpcnR1YWxLZXkuRjEyLEYxMzpnLlZpcnR1YWxLZXkuRjEzLEYxNDpnLlZpcnR1YWxLZXkuRjE0LEYxNTpnLlZpcnR1YWxLZXkuRjE1LEYxNjpnLlZpcnR1YWxLZXkuRjE2LEYxNzpnLlZpcnR1YWxLZXkuRjE3LEYxODpnLlZpcnR1YWxLZXkuRjE4LEYxOTpnLlZpcnR1YWxLZXkuRjE5LEYyMDpnLlZpcnR1YWxLZXkuRjIwLEYyMTpnLlZpcnR1YWxLZXkuRjIxLEYyMjpnLlZpcnR1YWxLZXkuRjIyLEYyMzpnLlZpcnR1YWxLZXkuRjIzLEYyNDpnLlZpcnR1YWxLZXkuRjI0LE51bUxvY2s6Zy5WaXJ0dWFsS2V5Lk51bUxvY2ssU2Nyb2xsTG9jazpnLlZpcnR1YWxLZXkuU2Nyb2xsLFNoaWZ0TGVmdDpnLlZpcnR1YWxLZXkuTGVmdFNoaWZ0LFNoaWZ0UmlnaHQ6Zy5WaXJ0dWFsS2V5LlJpZ2h0U2hpZnQsQ29udHJvbExlZnQ6Zy5WaXJ0dWFsS2V5LkxlZnRDdHJsLENvbnRyb2xSaWdodDpnLlZpcnR1YWxLZXkuUmlnaHRDdHJsLEFsdExlZnQ6Zy5WaXJ0dWFsS2V5LkxlZnRBbHQsQWx0UmlnaHQ6Zy5WaXJ0dWFsS2V5LlJpZ2h0QWx0LEJyb3dzZXJCYWNrOmcuVmlydHVhbEtleS5Ccm93c2VyQmFjayxCcm93c2VyRm9yd2FyZDpnLlZpcnR1YWxLZXkuQnJvd3NlckZvcndhcmQsQnJvd3NlclJlZnJlc2g6Zy5WaXJ0dWFsS2V5LkJyb3dzZXJSZWZyZXNoLEJyb3dzZXJTdG9wOmcuVmlydHVhbEtleS5Ccm93c2VyU3RvcCxCcm93c2VyU2VhcmNoOmcuVmlydHVhbEtleS5Ccm93c2VyU2VhcmNoLEJyb3dzZXJGYXZvcml0ZXM6Zy5WaXJ0dWFsS2V5LkJyb3dzZXJGYXZvcml0ZXMsQnJvd3NlckhvbWU6Zy5WaXJ0dWFsS2V5LkJyb3dzZXJIb21lLEF1ZGlvVm9sdW1lTXV0ZTpnLlZpcnR1YWxLZXkuVm9sdW1lTXV0ZSxBdWRpb1ZvbHVtZURvd246Zy5WaXJ0dWFsS2V5LlZvbHVtZURvd24sQXVkaW9Wb2x1bWVVcDpnLlZpcnR1YWxLZXkuVm9sdW1lVXAsTWVkaWFUcmFja05leHQ6Zy5WaXJ0dWFsS2V5Lk1lZGlhTmV4dFRyYWNrLE1lZGlhVHJhY2tQcmV2aW91czpnLlZpcnR1YWxLZXkuTWVkaWFQcmV2aW91c1RyYWNrLE1lZGlhU3RvcDpnLlZpcnR1YWxLZXkuTWVkaWFTdG9wLE1lZGlhUGxheVBhdXNlOmcuVmlydHVhbEtleS5NZWRpYVBsYXlQYXVzZSxMYXVuY2hNYWlsOmcuVmlydHVhbEtleS5MYXVuY2hNYWlsLExhdW5jaE1lZGlhUGxheWVyOmcuVmlydHVhbEtleS5TZWxlY3RNZWRpYSxNZWRpYVNlbGVjdDpnLlZpcnR1YWxLZXkuU2VsZWN0TWVkaWEsTGF1bmNoQXBwMTpnLlZpcnR1YWxLZXkuTGF1bmNoQXBwbGljYXRpb24xLExhdW5jaEFwcDI6Zy5WaXJ0dWFsS2V5LkxhdW5jaEFwcGxpY2F0aW9uMixTZW1pY29sb246Zy5WaXJ0dWFsS2V5Lk9lbTEsRXF1YWw6Zy5WaXJ0dWFsS2V5Lk9lbVBsdXMsQ29tbWE6Zy5WaXJ0dWFsS2V5Lk9lbUNvbW1hLE1pbnVzOmcuVmlydHVhbEtleS5PZW1NaW51cyxQZXJpb2Q6Zy5WaXJ0dWFsS2V5Lk9lbVBlcmlvZCxTbGFzaDpnLlZpcnR1YWxLZXkuT2VtMixCYWNrcXVvdGU6Zy5WaXJ0dWFsS2V5Lk9lbTMsQnJhY2tldExlZnQ6Zy5WaXJ0dWFsS2V5Lk9lbTQsQmFja3NsYXNoOmcuVmlydHVhbEtleS5PZW01LEJyYWNrZXRSaWdodDpnLlZpcnR1YWxLZXkuT2VtNixRdW90ZTpnLlZpcnR1YWxLZXkuT2VtNyxJbnRsQmFja3NsYXNoOmcuVmlydHVhbEtleS5PZW0xMDJ9fSwzNDY0OihBLGUpPT57XCJ1c2Ugc3RyaWN0XCI7dmFyIEk7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksZS5SYWlud2F5TG9nZ2luZz1lLlJhaW53YXlMb2dMZXZlbD12b2lkIDAsZnVuY3Rpb24oQSl7QVtBLlRyYWNlPTBdPVwiVHJhY2VcIixBW0EuRGVidWc9MV09XCJEZWJ1Z1wiLEFbQS5JbmZvcm1hdGlvbj0yXT1cIkluZm9ybWF0aW9uXCIsQVtBLldhcm5pbmc9M109XCJXYXJuaW5nXCIsQVtBLkVycm9yPTRdPVwiRXJyb3JcIixBW0EuQ3JpdGljYWw9NV09XCJDcml0aWNhbFwiLEFbQS5TaWxlbnQ9Nl09XCJTaWxlbnRcIn0oST1lLlJhaW53YXlMb2dMZXZlbHx8KGUuUmFpbndheUxvZ0xldmVsPXt9KSk7Y2xhc3MgZ3tzdGF0aWMgc2V0TG9nU2luayhBKXtnLl9sb2dTaW5rPUF9c3RhdGljIGxvZyhBLGUpe3ZhciBJO251bGw9PT0oST1nLl9sb2dTaW5rKXx8dm9pZCAwPT09SXx8SS5jYWxsKGcsQSxlKX19ZS5SYWlud2F5TG9nZ2luZz1nLGcudHJhY2U9QT0+Zy5sb2coSS5UcmFjZSxBKSxnLmRlYnVnPUE9PmcubG9nKEkuRGVidWcsQSksZy5pbmZvcm1hdGlvbj1BPT5nLmxvZyhJLkluZm9ybWF0aW9uLEEpLGcud2FybmluZz1BPT5nLmxvZyhJLldhcm5pbmcsQSksZy5lcnJvcj1BPT5nLmxvZyhJLkVycm9yLEEpLGcuY3JpdGljYWw9QT0+Zy5sb2coSS5Dcml0aWNhbCxBKX0sNjU4NTpmdW5jdGlvbihBLGUsSSl7XCJ1c2Ugc3RyaWN0XCI7dmFyIGc9dGhpcyYmdGhpcy5fX2F3YWl0ZXJ8fGZ1bmN0aW9uKEEsZSxJLGcpe3JldHVybiBuZXcoSXx8KEk9UHJvbWlzZSkpKChmdW5jdGlvbih0LGkpe2Z1bmN0aW9uIEIoQSl7dHJ5e1EoZy5uZXh0KEEpKX1jYXRjaChBKXtpKEEpfX1mdW5jdGlvbiBDKEEpe3RyeXtRKGcudGhyb3coQSkpfWNhdGNoKEEpe2koQSl9fWZ1bmN0aW9uIFEoQSl7dmFyIGU7QS5kb25lP3QoQS52YWx1ZSk6KGU9QS52YWx1ZSxlIGluc3RhbmNlb2YgST9lOm5ldyBJKChmdW5jdGlvbihBKXtBKGUpfSkpKS50aGVuKEIsQyl9USgoZz1nLmFwcGx5KEEsZXx8W10pKS5uZXh0KCkpfSkpfSx0PXRoaXMmJnRoaXMuX19pbXBvcnREZWZhdWx0fHxmdW5jdGlvbihBKXtyZXR1cm4gQSYmQS5fX2VzTW9kdWxlP0E6e2RlZmF1bHQ6QX19O09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLGUuQXVkaW9TdHJlYW09dm9pZCAwO2NvbnN0IGk9dChJKDYwNTMpKSxCPUkoMjk5NCksQz1JKDM0NjQpO2UuQXVkaW9TdHJlYW09Y2xhc3N7Y29uc3RydWN0b3IoKXt0aGlzLnNhbXBsZVJhdGVIej00OGUzLHRoaXMuc2FtcGxlUmF0ZUtoej00OCx0aGlzLmNoYW5uZWxDb3VudD0yLHRoaXMuZGVjb2RlZENvdW50PTAsdGhpcy50b3RhbFNhbXBsZXNEZWNvZGVkPTAsdGhpcy53YWl0aW5nVG9EZWNvZGVRdWV1ZT1bXSx0aGlzLmRlY29kZVF1ZXVlU2l6ZT0wLHRoaXMubG9nUGVyZm9ybWFuY2U9ITEsdGhpcy5tYXhEZWNvZGluZ1RpbWVNcz0wLHRoaXMudG90YWxEZWNvZGluZ1RpbWVNcz0wLHRoaXMudG90YWxRdWV1ZWRTaXplPTAsdGhpcy5tYXhRdWV1ZWRTaXplPTAsdGhpcy5zdGFydFN0cmVhbVRpbWVNcz0wLHRoaXMub3V0cHV0QnVmZmVycz1bXSx0aGlzLmN1cnJlbnRPdXRwdXRCdWZmZXI9dm9pZCAwLHRoaXMuY3VycmVudEJ1ZmZlclJlYWRJbmRleD0wLHRoaXMubmV4dFN0YXJ0VGltZT12b2lkIDAsdGhpcy5wbGF5aW5nPSExLHRoaXMuZGF0YUR1cmF0aW9uTXM9MTAsdGhpcy5taW5MYXRlbmN5TXM9NjAsdGhpcy5tYXhMYXRlbmN5TXM9MTAwLHRoaXMucHJldkRyb3BwZWRGcmFtZVRpbWVNcz12b2lkIDAsdGhpcy5kZWNvZGVkU2FtcGxlc1BlckZyYW1lPTAsdGhpcy5hdWRpb0J1ZmZlclNpemU9MCx0aGlzLmF1ZGlvQnVmZmVyUG9vbD1bXSx0aGlzLm1heEF1ZGlvQnVmZmVyUG9vbENvdW50PTUsdGhpcy5yZXNhbXBsZWRBdWRpb0J1ZmZlclNpemU9MCx0aGlzLm9uRGVjb2RlPSh7c3RhcnRUaW1lc3RhbXA6QSxvdXRwdXREYXRhOmUsc2FtcGxlc0RlY29kZWQ6SX0pPT57LS10aGlzLmRlY29kZVF1ZXVlU2l6ZTtjb25zdCBnPW5ldyBGbG9hdDMyQXJyYXkoZSk7dGhpcy5vdXRwdXRCdWZmZXJzLnB1c2goZyk7dHJ5e2lmKEk+MCYmKCsrdGhpcy5kZWNvZGVkQ291bnQsdGhpcy50b3RhbFNhbXBsZXNEZWNvZGVkKz1JLHRoaXMubG9nUGVyZm9ybWFuY2UmJnRoaXMubG9nUGVyZlRpbWluZyhBKSx0aGlzLnRvdGFsU2FtcGxlc0RlY29kZWQ+PXRoaXMuYXVkaW9CdWZmZXJTaXplJiYodGhpcy5uZXh0U3RhcnRUaW1lJiZ0aGlzLm5leHRTdGFydFRpbWU8dGhpcy5hdWRpb0NvbnRleHQuY3VycmVudFRpbWUmJih0aGlzLm5leHRTdGFydFRpbWU9dm9pZCAwKSx0aGlzLm5leHRTdGFydFRpbWV8fHRoaXMudG90YWxTYW1wbGVzRGVjb2RlZD49Mip0aGlzLmF1ZGlvQnVmZmVyU2l6ZSkpKXtjb25zdCBBPU1hdGguZmxvb3IodGhpcy50b3RhbFNhbXBsZXNEZWNvZGVkL3RoaXMuYXVkaW9CdWZmZXJTaXplKTtmb3IobGV0IGU9MDtlPEE7KytlKXtjb25zdCBBPXRoaXMubmV4dFN0YXJ0VGltZT8xZTMqKHRoaXMubmV4dFN0YXJ0VGltZS10aGlzLmF1ZGlvQ29udGV4dC5jdXJyZW50VGltZSk6MDtpZihBPnRoaXMubWF4TGF0ZW5jeU1zKXtsZXQgZT0wO2NvbnN0IEk9RGF0ZS5ub3coKSxnPXRoaXMucHJldkRyb3BwZWRGcmFtZVRpbWVNcz9JLXRoaXMucHJldkRyb3BwZWRGcmFtZVRpbWVNczp2b2lkIDAsdD0xZTQ7aWYoZyYmZzx0KWU9dGhpcy5kcm9wRGVjb2RlZFNhbXBsZXModGhpcy50b3RhbFNhbXBsZXNEZWNvZGVkKTtlbHNle2NvbnN0IEk9QS10aGlzLm1heExhdGVuY3lNcyt0aGlzLmRhdGFEdXJhdGlvbk1zLGc9TWF0aC5mbG9vcih0aGlzLnNhbXBsZVJhdGVLaHoqSSk7ZT10aGlzLmRyb3BEZWNvZGVkU2FtcGxlcyhnKX10aGlzLnByZXZEcm9wcGVkRnJhbWVUaW1lTXM9SSx0aGlzLnRvdGFsU2FtcGxlc0RlY29kZWQtPWV9aWYoISh0aGlzLnRvdGFsU2FtcGxlc0RlY29kZWQ+PXRoaXMuYXVkaW9CdWZmZXJTaXplKSlicmVhazt7Y29uc3QgQT10aGlzLmNvcHlEZWNvZGVkU2FtcGxlc1RvQXVkaW9CdWZmZXIoKTt0aGlzLnNjaGVkdWxlQnVmZmVyRm9yUGxheWJhY2tGdW5jKEEpLHRoaXMudG90YWxTYW1wbGVzRGVjb2RlZC09QS5sZW5ndGh9fX19Y2F0Y2goQSl7Qy5SYWlud2F5TG9nZ2luZy53YXJuaW5nKFwiQ2F1Z2h0IGV4Y2VwdGlvbiBpbiBBdWRpb1N0cmVhbSBvbkRlY29kZTogXCIrQStcIiBcIitBLnN0YWNrKSx0aGlzLnN0b3AoKSx0aGlzLnBsYXkoKX10aGlzLnNlbmREZWNvZGVyV2FpdGluZ1RvRGVjb2RlRnJhbWVzKCl9fWluaXRpYWxpemUoKXtyZXR1cm4gZyh0aGlzLHZvaWQgMCx2b2lkIDAsKGZ1bmN0aW9uKigpe3RoaXMub3B1c0RlY29kZXJXb3JrZXI9bmV3IGkuZGVmYXVsdCx5aWVsZCB0aGlzLm9wdXNEZWNvZGVyV29ya2VyLmluaXRpYWxpemUoKSx0aGlzLm9wdXNEZWNvZGVyV29ya2VyLm9uRGVjb2RlPXRoaXMub25EZWNvZGUuYmluZCh0aGlzKX0pKX1kaXNwb3NlKCl7dmFyIEE7bnVsbD09PShBPXRoaXMub3B1c0RlY29kZXJXb3JrZXIpfHx2b2lkIDA9PT1BfHxBLmRpc3Bvc2UoKSx0aGlzLm9wdXNEZWNvZGVyV29ya2VyPXZvaWQgMH1jb25maWd1cmUoe2F1ZGlvQ29udGV4dDpBLHNhbXBsZVJhdGVIejplLGNoYW5uZWxDb3VudDpJLGRhdGFEdXJhdGlvbk1zOmcsbWluTGF0ZW5jeU1zOnQsbWF4TGF0ZW5jeU1zOml9KXtpZih0aGlzLnNhbXBsZVJhdGVIej1udWxsIT1lP2U6dGhpcy5zYW1wbGVSYXRlSHosOGUzIT10aGlzLnNhbXBsZVJhdGVIeiYmMTJlMyE9dGhpcy5zYW1wbGVSYXRlSHomJjE2ZTMhPXRoaXMuc2FtcGxlUmF0ZUh6JiYyNGUzIT10aGlzLnNhbXBsZVJhdGVIeiYmNDhlMyE9dGhpcy5zYW1wbGVSYXRlSHopdGhyb3cgbmV3IEIuUmFpbndheUVycm9yKGBpbnZhbGlkIGF1ZGlvIHNhbXBsZSByYXRlOiAke3RoaXMuc2FtcGxlUmF0ZUh6fSAobXVzdCBiZSA4MDAwLCAxMjAwMCwgMTYwMDAsIDI0MDAwLCBvciA0ODAwMClgKTtpZih0aGlzLnNhbXBsZVJhdGVLaHo9dGhpcy5zYW1wbGVSYXRlSHovMWUzLHRoaXMuY2hhbm5lbENvdW50PW51bGwhPUk/STp0aGlzLmNoYW5uZWxDb3VudCwxIT10aGlzLmNoYW5uZWxDb3VudCYmMiE9dGhpcy5jaGFubmVsQ291bnQmJjYhPXRoaXMuY2hhbm5lbENvdW50KXRocm93IG5ldyBCLlJhaW53YXlFcnJvcihgaW52YWxpZCBjaGFubmVsIGNvdW50OiAke3RoaXMuY2hhbm5lbENvdW50fSAobXVzdCBiZSAxLCAyLCBvciA2KWApO2lmKHRoaXMuZGF0YUR1cmF0aW9uTXM9bnVsbCE9Zz9nOnRoaXMuZGF0YUR1cmF0aW9uTXMsdGhpcy5taW5MYXRlbmN5TXM9bnVsbCE9dD90OnRoaXMubWluTGF0ZW5jeU1zLHRoaXMubWF4TGF0ZW5jeU1zPW51bGwhPWk/aTp0aGlzLm1heExhdGVuY3lNcyx0aGlzLmRhdGFEdXJhdGlvbk1zPD0wKXRocm93IG5ldyBCLlJhaW53YXlFcnJvcihgZGF0YUR1cmF0aW9uTXMgbXVzdCBiZSBwb3NpdGl2ZSwgYnV0IGlzICR7dGhpcy5kYXRhRHVyYXRpb25Nc31gKTtpZih0aGlzLmRhdGFEdXJhdGlvbk1zPnRoaXMubWluTGF0ZW5jeU1zKXRocm93IG5ldyBCLlJhaW53YXlFcnJvcihcImRhdGFEdXJhdGlvbk1zIG1heSBub3QgZXhjZWVkIG1pbkxhdGVuY3lNc1wiKTtpZih0aGlzLm1heExhdGVuY3lNczw9dGhpcy5taW5MYXRlbmN5TXMpdGhyb3cgbmV3IEIuUmFpbndheUVycm9yKFwibWF4TGF0ZW5jeU1zIG11c3QgYmUgZ3JlYXRlciB0aGFuIG1pbkxhdGVuY3lNc1wiKTt0aGlzLmRlY29kZWRTYW1wbGVzUGVyRnJhbWU9dGhpcy5kYXRhRHVyYXRpb25Ncyp0aGlzLnNhbXBsZVJhdGVLaHosdGhpcy5jdXJyZW50T3V0cHV0QnVmZmVyPXZvaWQgMCx0aGlzLmN1cnJlbnRCdWZmZXJSZWFkSW5kZXg9MDtjb25zdCBRPXRoaXMuc2FtcGxlUmF0ZUtoeip0aGlzLm1pbkxhdGVuY3lNczt0aGlzLmF1ZGlvQnVmZmVyU2l6ZT1NYXRoLmZsb29yKFEvMiksbnVsbD09QT8odGhpcy5hdWRpb0NvbnRleHQ9bmV3KHdpbmRvdy5BdWRpb0NvbnRleHR8fHdpbmRvdy53ZWJraXRBdWRpb0NvbnRleHQpKHtsYXRlbmN5SGludDpcImludGVyYWN0aXZlXCIsc2FtcGxlUmF0ZTp0aGlzLnNhbXBsZVJhdGVIen0pLHRoaXMuYXVkaW9Db250ZXh0LmNyZWF0ZUJ1ZmZlclNvdXJjZSgpKTp0aGlzLmF1ZGlvQ29udGV4dD1BLHRoaXMudm9sdW1lTm9kZT10aGlzLmF1ZGlvQ29udGV4dC5jcmVhdGVHYWluKCksdGhpcy52b2x1bWVOb2RlLmNvbm5lY3QodGhpcy5hdWRpb0NvbnRleHQuZGVzdGluYXRpb24pLHRoaXMuYXVkaW9Db250ZXh0LnJlc3VtZSgpLFwic3VzcGVuZGVkXCI9PXRoaXMuYXVkaW9Db250ZXh0LnN0YXRlJiZDLlJhaW53YXlMb2dnaW5nLmluZm9ybWF0aW9uKFwiQXVkaW9Db250ZXh0IGlzIHN1c3BlbmRlZC4gTm90ZSwgb24gU2FmYXJpLCBtdXN0IGJlIGNyZWF0ZWQgZGlyZWN0bHkgZnJvbSB1c2VyIGludGVyYWN0aW9uIChpLmUuIG5vICdhd2FpdCcpKS5cIiksdGhpcy5hdWRpb0NvbnRleHQuc2FtcGxlUmF0ZSE9dGhpcy5zYW1wbGVSYXRlSHo/KEMuUmFpbndheUxvZ2dpbmcud2FybmluZyhcIkNvbmZpZ3VyZWQgc2FtcGxlIHJhdGU6IFwiK3RoaXMuc2FtcGxlUmF0ZUh6K1wiIGRvZXMgbm90IG1hdGNoIEF1ZGlvQ29udGV4dDogXCIrdGhpcy5hdWRpb0NvbnRleHQuc2FtcGxlUmF0ZStcIi4gUmVzYW1wbGluZyBpcyByZXF1aXJlZCFcIiksdGhpcy5yZXNhbXBsZWRBdWRpb0J1ZmZlclNpemU9TWF0aC5mbG9vcih0aGlzLmF1ZGlvQ29udGV4dC5zYW1wbGVSYXRlLzFlMyp0aGlzLm1pbkxhdGVuY3lNcy8yKSx0aGlzLnNjaGVkdWxlQnVmZmVyRm9yUGxheWJhY2tGdW5jPXRoaXMucmVzYW1wbGVCdWZmZXJUaGVuU2NoZWR1bGVGb3JQbGF5YmFjay5iaW5kKHRoaXMpKTp0aGlzLnNjaGVkdWxlQnVmZmVyRm9yUGxheWJhY2tGdW5jPXRoaXMuc2NoZWR1bGVCdWZmZXJGb3JQbGF5YmFjay5iaW5kKHRoaXMpLHRoaXMuYXVkaW9CdWZmZXJQb29sPVtdO2xldCBvPSExO3RoaXMucGxheWluZyYmKG89ITAsdGhpcy5zdG9wKCkpLG8mJnRoaXMucGxheSgpfXBsYXkoKXtpZighdGhpcy5vcHVzRGVjb2Rlcldvcmtlcil0aHJvdyBuZXcgQi5SYWlud2F5RXJyb3IoXCJwbGF5KCkgaGFzIG5vIG9wdXNEZWNvZGVyV29ya2VyXCIpO2lmKCF0aGlzLnNhbXBsZVJhdGVIeil0aHJvdyBuZXcgQi5SYWlud2F5RXJyb3IoXCJwbGF5KCkgaGFzIG5vIHNhbXBsZVJhdGVIelwiKTtpZighdGhpcy5jaGFubmVsQ291bnQpdGhyb3cgbmV3IEIuUmFpbndheUVycm9yKFwicGxheSgpIGhhcyBubyBjaGFubmVsQ291bnRcIik7aWYoIXRoaXMuYXVkaW9Db250ZXh0KXRocm93IG5ldyBCLlJhaW53YXlFcnJvcihcInBsYXkoKSBoYXMgbm8gYXVkaW9Db250ZXh0XCIpO3RoaXMucGxheWluZ3x8KHRoaXMubWF4RGVjb2RpbmdUaW1lTXM9MCx0aGlzLnRvdGFsRGVjb2RpbmdUaW1lTXM9MCx0aGlzLnRvdGFsUXVldWVkU2l6ZT0wLHRoaXMubWF4UXVldWVkU2l6ZT0wLHRoaXMuc3RhcnRTdHJlYW1UaW1lTXM9RGF0ZS5ub3coKSx0aGlzLm9wdXNEZWNvZGVyV29ya2VyLnN0YXJ0U3RyZWFtKHRoaXMuc2FtcGxlUmF0ZUh6LHRoaXMuY2hhbm5lbENvdW50LHRoaXMuZGVjb2RlZFNhbXBsZXNQZXJGcmFtZSksdGhpcy5wbGF5aW5nPSEwKX1zdG9wKCl7aWYoIXRoaXMub3B1c0RlY29kZXJXb3JrZXIpdGhyb3cgbmV3IEIuUmFpbndheUVycm9yKFwic3RvcCgpIGhhcyBubyBvcHVzRGVjb2RlcldvcmtlclwiKTt0aGlzLndhaXRpbmdUb0RlY29kZVF1ZXVlPVtdLHRoaXMub3V0cHV0QnVmZmVycz1bXSx0aGlzLm5leHRTdGFydFRpbWU9dm9pZCAwLHRoaXMudG90YWxTYW1wbGVzRGVjb2RlZD0wLHRoaXMuY3VycmVudE91dHB1dEJ1ZmZlcj12b2lkIDAsdGhpcy5jdXJyZW50QnVmZmVyUmVhZEluZGV4PTAsdGhpcy5wcmV2RHJvcHBlZEZyYW1lVGltZU1zPXZvaWQgMCx0aGlzLm9wdXNEZWNvZGVyV29ya2VyLnN0b3BTdHJlYW0oKSx0aGlzLnBsYXlpbmc9ITF9cHVzaERhdGEoQSl7dGhpcy5wbGF5aW5nJiZ0aGlzLmF1ZGlvQ29udGV4dCYmdGhpcy5vcHVzRGVjb2RlcldvcmtlciYmKDA9PXRoaXMuZGVjb2RlUXVldWVTaXplPygwIT10aGlzLndhaXRpbmdUb0RlY29kZVF1ZXVlLmxlbmd0aCYmKEMuUmFpbndheUxvZ2dpbmcuZXJyb3IoXCJbQXVkaW9TdHJlYW1dIGVtcHR5IGRlY29kZXIgcXVldWUsIGJ1dCB3YWl0aW5nIHRvIGRlY29kZSBxdWV1ZSBub3QgZW1wdHkhXCIpLHRoaXMud2FpdGluZ1RvRGVjb2RlUXVldWU9W10pLHRoaXMuc2VuZFRvRGVjb2Rlcih7c3RhcnRUaW1lc3RhbXA6RGF0ZS5ub3coKSxpbnB1dERhdGE6QX0pKToodGhpcy53YWl0aW5nVG9EZWNvZGVRdWV1ZS5wdXNoKHtzdGFydFRpbWVzdGFtcDpEYXRlLm5vdygpLGlucHV0RGF0YTpBfSksdGhpcy5kZWNvZGVRdWV1ZVNpemU8MyYmdGhpcy5zZW5kRGVjb2RlcldhaXRpbmdUb0RlY29kZUZyYW1lcygpKSl9c2VuZERlY29kZXJXYWl0aW5nVG9EZWNvZGVGcmFtZXMoKXtjb25zdCBBPSh0aGlzLmRlY29kZVF1ZXVlU2l6ZSt0aGlzLndhaXRpbmdUb0RlY29kZVF1ZXVlLmxlbmd0aCkqdGhpcy5kYXRhRHVyYXRpb25NcztpZihBPnRoaXMubWF4TGF0ZW5jeU1zKXtjb25zdCBlPUEtdGhpcy5tYXhMYXRlbmN5TXMsST1NYXRoLmZsb29yKGUvdGhpcy5kYXRhRHVyYXRpb25NcyksZz1NYXRoLm1heChNYXRoLm1heCh0aGlzLndhaXRpbmdUb0RlY29kZVF1ZXVlLmxlbmd0aC1JLDMtdGhpcy5kZWNvZGVRdWV1ZVNpemUpLDEpLHQ9dGhpcy53YWl0aW5nVG9EZWNvZGVRdWV1ZS5sZW5ndGgtZzt0aGlzLndhaXRpbmdUb0RlY29kZVF1ZXVlPXRoaXMud2FpdGluZ1RvRGVjb2RlUXVldWUuc2xpY2UodCl9Zm9yKDt0aGlzLmRlY29kZVF1ZXVlU2l6ZTwzJiZ0aGlzLndhaXRpbmdUb0RlY29kZVF1ZXVlLmxlbmd0aD4wOyl7Y29uc3QgQT10aGlzLndhaXRpbmdUb0RlY29kZVF1ZXVlLnNoaWZ0KCk7dGhpcy5zZW5kVG9EZWNvZGVyKEEpfX1zZW5kVG9EZWNvZGVyKEEpeysrdGhpcy5kZWNvZGVRdWV1ZVNpemUsdGhpcy5vcHVzRGVjb2Rlcldvcmtlci5kZWNvZGUoQS5zdGFydFRpbWVzdGFtcCxBLmlucHV0RGF0YSl9ZHJvcERlY29kZWRTYW1wbGVzKEEpe2xldCBlPTA7Zm9yKHRoaXMuY3VycmVudE91dHB1dEJ1ZmZlciYmKGUrPXRoaXMuZHJvcEN1cnJlbnRPdXRwdXRCdWZmZXJTYW1wbGVzKEEpLEEtPWUpO0E+MCYmdGhpcy5vdXRwdXRCdWZmZXJzLmxlbmd0aD4wOylpZihBPHRoaXMuZGVjb2RlZFNhbXBsZXNQZXJGcmFtZSl7dGhpcy5jdXJyZW50T3V0cHV0QnVmZmVyPXRoaXMub3V0cHV0QnVmZmVycy5zaGlmdCgpLHRoaXMuY3VycmVudEJ1ZmZlclJlYWRJbmRleD0wO2NvbnN0IEk9dGhpcy5kcm9wQ3VycmVudE91dHB1dEJ1ZmZlclNhbXBsZXMoQSk7ZSs9SSxBLT1JfWVsc2UgdGhpcy5vdXRwdXRCdWZmZXJzLnNoaWZ0KCksZSs9dGhpcy5kZWNvZGVkU2FtcGxlc1BlckZyYW1lLEEtPXRoaXMuZGVjb2RlZFNhbXBsZXNQZXJGcmFtZTtyZXR1cm4gZX1kcm9wQ3VycmVudE91dHB1dEJ1ZmZlclNhbXBsZXMoQSl7Y29uc3QgZT1NYXRoLmZsb29yKCh0aGlzLmN1cnJlbnRPdXRwdXRCdWZmZXIubGVuZ3RoLXRoaXMuY3VycmVudEJ1ZmZlclJlYWRJbmRleCkvdGhpcy5jaGFubmVsQ291bnQpLEk9TWF0aC5taW4oZSxBKTtyZXR1cm4gdGhpcy5jdXJyZW50QnVmZmVyUmVhZEluZGV4Kz1JKnRoaXMuY2hhbm5lbENvdW50LHRoaXMuY3VycmVudEJ1ZmZlclJlYWRJbmRleD49dGhpcy5jdXJyZW50T3V0cHV0QnVmZmVyLmxlbmd0aCYmKHRoaXMuY3VycmVudE91dHB1dEJ1ZmZlcj12b2lkIDApLEl9Y29weURlY29kZWRTYW1wbGVzVG9BdWRpb0J1ZmZlcigpe2NvbnN0IEE9dGhpcy5nZXRPckNyZWF0ZUF1ZGlvQnVmZmVyKCk7Zm9yKGxldCBlPTA7ZTx0aGlzLmF1ZGlvQnVmZmVyU2l6ZTspe3RoaXMuY3VycmVudE91dHB1dEJ1ZmZlcnx8KHRoaXMuY3VycmVudE91dHB1dEJ1ZmZlcj10aGlzLm91dHB1dEJ1ZmZlcnMuc2hpZnQoKSx0aGlzLmN1cnJlbnRCdWZmZXJSZWFkSW5kZXg9MCk7Y29uc3QgST10aGlzLmN1cnJlbnRPdXRwdXRCdWZmZXI7aWYoMT09dGhpcy5jaGFubmVsQ291bnQpe2NvbnN0IGc9QS5nZXRDaGFubmVsRGF0YSgwKTtmb3IoO3RoaXMuY3VycmVudEJ1ZmZlclJlYWRJbmRleDxJLmxlbmd0aCYmKGdbZV09SVt0aGlzLmN1cnJlbnRCdWZmZXJSZWFkSW5kZXhdLHRoaXMuY3VycmVudEJ1ZmZlclJlYWRJbmRleCs9dGhpcy5jaGFubmVsQ291bnQsKytlLCEoZT49dGhpcy5hdWRpb0J1ZmZlclNpemUpKTspO31lbHNlIGlmKDI9PXRoaXMuY2hhbm5lbENvdW50KXtjb25zdCBnPUEuZ2V0Q2hhbm5lbERhdGEoMCksdD1BLmdldENoYW5uZWxEYXRhKDEpO2Zvcig7dGhpcy5jdXJyZW50QnVmZmVyUmVhZEluZGV4PEkubGVuZ3RoJiYoZ1tlXT1JW3RoaXMuY3VycmVudEJ1ZmZlclJlYWRJbmRleF0sdFtlXT1JW3RoaXMuY3VycmVudEJ1ZmZlclJlYWRJbmRleCsxXSx0aGlzLmN1cnJlbnRCdWZmZXJSZWFkSW5kZXgrPXRoaXMuY2hhbm5lbENvdW50LCsrZSwhKGU+PXRoaXMuYXVkaW9CdWZmZXJTaXplKSk7KTt9ZWxzZXtjb25zdCBnPUEuZ2V0Q2hhbm5lbERhdGEoMCksdD1BLmdldENoYW5uZWxEYXRhKDEpLGk9QS5nZXRDaGFubmVsRGF0YSgyKSxCPUEuZ2V0Q2hhbm5lbERhdGEoMyksQz1BLmdldENoYW5uZWxEYXRhKDQpLFE9QS5nZXRDaGFubmVsRGF0YSg1KTtmb3IoO3RoaXMuY3VycmVudEJ1ZmZlclJlYWRJbmRleDxJLmxlbmd0aCYmKGdbZV09SVt0aGlzLmN1cnJlbnRCdWZmZXJSZWFkSW5kZXhdLHRbZV09SVt0aGlzLmN1cnJlbnRCdWZmZXJSZWFkSW5kZXgrMV0sQ1tlXT1JW3RoaXMuY3VycmVudEJ1ZmZlclJlYWRJbmRleCsyXSxRW2VdPUlbdGhpcy5jdXJyZW50QnVmZmVyUmVhZEluZGV4KzNdLGlbZV09SVt0aGlzLmN1cnJlbnRCdWZmZXJSZWFkSW5kZXgrNF0sQltlXT1JW3RoaXMuY3VycmVudEJ1ZmZlclJlYWRJbmRleCs1XSx0aGlzLmN1cnJlbnRCdWZmZXJSZWFkSW5kZXgrPXRoaXMuY2hhbm5lbENvdW50LCsrZSwhKGU+PXRoaXMuYXVkaW9CdWZmZXJTaXplKSk7KTt9dGhpcy5jdXJyZW50QnVmZmVyUmVhZEluZGV4Pj10aGlzLmN1cnJlbnRPdXRwdXRCdWZmZXIubGVuZ3RoJiYodGhpcy5jdXJyZW50T3V0cHV0QnVmZmVyPXZvaWQgMCl9cmV0dXJuIEF9Z2V0T3JDcmVhdGVBdWRpb0J1ZmZlcigpe3JldHVybiAwPT10aGlzLmF1ZGlvQnVmZmVyUG9vbC5sZW5ndGg/dGhpcy5hdWRpb0NvbnRleHQuY3JlYXRlQnVmZmVyKHRoaXMuY2hhbm5lbENvdW50LHRoaXMuYXVkaW9CdWZmZXJTaXplLHRoaXMuc2FtcGxlUmF0ZUh6KTp0aGlzLmF1ZGlvQnVmZmVyUG9vbC5wb3AoKX1yZXR1cm5BdWRpb0J1ZmZlclRvUG9vbChBLGUpe3RoaXMuYXVkaW9CdWZmZXJQb29sLmxlbmd0aDx0aGlzLm1heEF1ZGlvQnVmZmVyUG9vbENvdW50JiZ0aGlzLmF1ZGlvQnVmZmVyUG9vbC5wdXNoKEEpfWxvZ1BlcmZUaW1pbmcoQSl7Y29uc3QgZT1EYXRlLm5vdygpLEk9ZS1BO3RoaXMudG90YWxEZWNvZGluZ1RpbWVNcys9SSxJPnRoaXMubWF4RGVjb2RpbmdUaW1lTXMmJih0aGlzLm1heERlY29kaW5nVGltZU1zPUkpO2NvbnN0IGc9dGhpcy53YWl0aW5nVG9EZWNvZGVRdWV1ZS5sZW5ndGgrdGhpcy5kZWNvZGVRdWV1ZVNpemU7dGhpcy50b3RhbFF1ZXVlZFNpemUrPWcsZz50aGlzLm1heFF1ZXVlZFNpemUmJih0aGlzLm1heFF1ZXVlZFNpemU9ZyksMTUwMD09dGhpcy5kZWNvZGVkQ291bnQmJihDLlJhaW53YXlMb2dnaW5nLmluZm9ybWF0aW9uKFwiW0F1ZGlvU3RyZWFtXSBBdmcgcXVldWU6IFwiK3RoaXMudG90YWxRdWV1ZWRTaXplL3RoaXMuZGVjb2RlZENvdW50K1wiLCBNYXg6IFwiK3RoaXMubWF4UXVldWVkU2l6ZStcIiBBdmcgRlBTOiBcIit0aGlzLmRlY29kZWRDb3VudC8oKGUtdGhpcy5zdGFydFN0cmVhbVRpbWVNcykvMWUzKStcIiBBdmcgZGVjb2RlOiBcIit0aGlzLnRvdGFsRGVjb2RpbmdUaW1lTXMvdGhpcy5kZWNvZGVkQ291bnQrXCJtcywgTWF4OiBcIit0aGlzLm1heERlY29kaW5nVGltZU1zK1wibXNcIiksdGhpcy50b3RhbERlY29kaW5nVGltZU1zPTAsdGhpcy5tYXhEZWNvZGluZ1RpbWVNcz0wLHRoaXMudG90YWxRdWV1ZWRTaXplPTAsdGhpcy5tYXhRdWV1ZWRTaXplPTAsdGhpcy5kZWNvZGVkQ291bnQ9MCx0aGlzLnN0YXJ0U3RyZWFtVGltZU1zPWUpfXJlc2FtcGxlQnVmZmVyVGhlblNjaGVkdWxlRm9yUGxheWJhY2soQSl7Y29uc3QgZT1uZXcod2luZG93Lk9mZmxpbmVBdWRpb0NvbnRleHR8fHdpbmRvdy53ZWJraXRPZmZsaW5lQXVkaW9Db250ZXh0KSh0aGlzLmNoYW5uZWxDb3VudCx0aGlzLnJlc2FtcGxlZEF1ZGlvQnVmZmVyU2l6ZSx0aGlzLmF1ZGlvQ29udGV4dC5zYW1wbGVSYXRlKSxJPWUuY3JlYXRlQnVmZmVyU291cmNlKCk7SS5idWZmZXI9QSxJLmNvbm5lY3QoZS5kZXN0aW5hdGlvbiksSS5zdGFydCgpLGUuc3RhcnRSZW5kZXJpbmcoKSxlLm9uY29tcGxldGU9dGhpcy5zY2hlZHVsZVJlc2FtcGxlZEJ1ZmZlclBsYXliYWNrLmJpbmQodGhpcyxBKX1zY2hlZHVsZVJlc2FtcGxlZEJ1ZmZlclBsYXliYWNrKEEsZSl7dGhpcy5zY2hlZHVsZVBsYXliYWNrV2l0aE9uRW5kZWQoZS5yZW5kZXJlZEJ1ZmZlciksdGhpcy5yZXR1cm5BdWRpb0J1ZmZlclRvUG9vbChBLGUpfXNjaGVkdWxlQnVmZmVyRm9yUGxheWJhY2soQSl7dGhpcy5zY2hlZHVsZVBsYXliYWNrV2l0aE9uRW5kZWQoQSx0aGlzLnJldHVybkF1ZGlvQnVmZmVyVG9Qb29sLmJpbmQodGhpcyxBKSl9c2NoZWR1bGVQbGF5YmFja1dpdGhPbkVuZGVkKEEsZT1udWxsKXtjb25zdCBJPXRoaXMuYXVkaW9Db250ZXh0LmNyZWF0ZUJ1ZmZlclNvdXJjZSgpO0kuYnVmZmVyPUEsdGhpcy5uZXh0U3RhcnRUaW1lfHwodGhpcy5uZXh0U3RhcnRUaW1lPXRoaXMuYXVkaW9Db250ZXh0LmN1cnJlbnRUaW1lKSxJLnBsYXliYWNrUmF0ZS52YWx1ZT0xLEkuY29ubmVjdCh0aGlzLnZvbHVtZU5vZGUpLEkuc3RhcnQodGhpcy5uZXh0U3RhcnRUaW1lKSxJLm9uZW5kZWQ9ZSx0aGlzLm5leHRTdGFydFRpbWUrPUEuZHVyYXRpb259c2V0Vm9sdW1lKEEpe3RoaXMudm9sdW1lTm9kZS5nYWluLnZhbHVlPUF9fX0sODUxNDooQSxlLEkpPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksZS5tYWtlQ2xpZW50Q2FwYWJpbGl0aWVzPXZvaWQgMDtjb25zdCBnPUkoNjkwNCksdD1JKDM2NDMpLGk9SSg0MDA5KTtlLm1ha2VDbGllbnRDYXBhYmlsaXRpZXM9ZnVuY3Rpb24oQSl7Y29uc3R7ZmlsdGVyZWQ6ZSxwcmVmZXJyZWQ6SX09aS5maWx0ZXJDb2RlY1BhY2soQSksQj17Y29kZWM6Zy5BdWRpb0NvZGVjLk9wdXMsY29udGFpbmVyOmcuQXVkaW9Db250YWluZXIuUmF3fSxDPVwiTWVkaWFTb3VyY2VcImluIHdpbmRvdz9nLlZpZGVvQ29udGFpbmVyLklzb0JNRkY6Zy5WaWRlb0NvbnRhaW5lci5SYXcsUT0hIXdpbmRvdy5jaHJvbWU7cmV0dXJue3ByZWZlcnJlZFdpZHRoOnNjcmVlbi5hdmFpbFdpZHRoLHByZWZlcnJlZEhlaWdodDpzY3JlZW4uYXZhaWxIZWlnaHQscHJlZmVycmVkRnBzOjYwLHByZWZlcnJlZEF1ZGlvQml0cmF0ZTo5NmUzLHByZWZlcnJlZFZpZGVvQml0cmF0ZToxZTMqdC5kZWZhdWx0UmF0ZUNvbnRyb2xQYXJhbWV0ZXJzLmluaXRpYWxCaXRyYXRlS2JwcyxwcmVmZXJyZWRBdWRpb0NoYW5uZWxzOmcuQXVkaW9DaGFubmVscy5TdGVyZW8scHJlZmVycmVkQXVkaW9Db25maWc6QixwcmVmZXJyZWRWaWRlb0NvbmZpZzp7Y29kZWM6SSxjb250YWluZXI6Q30sc3VwcG9ydGVkQXVkaW9DaGFubmVsczpbZy5BdWRpb0NoYW5uZWxzLk1vbm8sZy5BdWRpb0NoYW5uZWxzLlN0ZXJlb10sc3VwcG9ydGVkQXVkaW9Db25maWdzOltCXSxzdXBwb3J0ZWRWaWRlb0NvbmZpZ3M6ZS5tYXAoKEE9Pih7Y29kZWM6QSxjb250YWluZXI6Q30pKSksc3VwcG9ydHNPdmVyMTA4MFA6ITEsc3VwcG9ydHNUZW1wb3JhbFNjYWxpbmc6ITAsc3VwcG9ydHNBcHBJc29sYXRpb246UX19fSw0MDA5OihBLGUsSSk9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxlLmZpbHRlckNvZGVjUGFjaz1lLnZpZGVvQ29kZWNNaW1lVHlwZT12b2lkIDA7Y29uc3QgZz1JKDY5MDQpO2Z1bmN0aW9uIHQoQSl7Y29uc3QgZT1BLmRhdGE7cmV0dXJuYHZpZGVvL21wNDsgY29kZWNzPVwiYXZjMS4keyhlWzVdPDwxNnxlWzZdPDw4fGVbN10pLnRvU3RyaW5nKDE2KS5wYWRTdGFydCg2LFwiMFwiKX1cImB9ZnVuY3Rpb24gaShBKXtpZighKFwiTWVkaWFTb3VyY2VcImluIHdpbmRvdykpcmV0dXJuITE7Y29uc3QgZT1BLmRhdGE7aWYoZS5sZW5ndGg8OHx8NyE9KDMxJmVbNF0pKXJldHVybiExO2NvbnN0IEk9dChBKTtyZXR1cm4gTWVkaWFTb3VyY2UuaXNUeXBlU3VwcG9ydGVkKEkpfWZ1bmN0aW9uIEIoQSl7Y29uc3QgZT1BLmRhdGE7aWYoZS5sZW5ndGg8OHx8NyE9KDMxJmVbNF0pKXJldHVybiBnLlZpZGVvQ29kZWNUeXBlLkJhc2VsaW5lO2NvbnN0IEk9ZVs1XTtyZXR1cm4gZVs2XSwxMTY9PUl8fDEyMj09SXx8MTEwPT1JfHwxMDA9PUk/Zy5WaWRlb0NvZGVjVHlwZS5IaWdoOjg4PT1JfHw3Nz09ST9nLlZpZGVvQ29kZWNUeXBlLk1haW46Zy5WaWRlb0NvZGVjVHlwZS5CYXNlbGluZX1lLnZpZGVvQ29kZWNNaW1lVHlwZT10LGUuZmlsdGVyQ29kZWNQYWNrPWZ1bmN0aW9uKEEpe2lmKDA9PT1BLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJIb3N0IHN1cHBsaWVkIGFuIGVtcHR5IENvZGVjUGFja1wiKTtsZXQgZT1BLmZpbHRlcihpKTtpZigwPT09ZS5sZW5ndGgmJihjb25zb2xlLndhcm4oXCJGb3VuZCBubyBicm93c2VyLWNvbmZpcm1lZCB3b3JraW5nIGNvZGVjLCBmYWxsaW5nIGJhY2sgdG8gYmFzZWxpbmVcIiksZT1BLmZpbHRlcigoQT0+QihBKTw9Zy5WaWRlb0NvZGVjVHlwZS5CYXNlbGluZSkpKSwwPT09ZS5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiSG9zdCBzdXBwbGllZCBhbiB1bnN1cHBvcnRlZCBDb2RlY1BhY2tcIik7Y29uc3QgST1lLnJlZHVjZSgoKEEsZSk9PkIoQSk+QihlKT9BOmUpKTtyZXR1cm57ZmlsdGVyZWQ6ZSxwcmVmZXJyZWQ6SX19fSw0OTE5OihBLGUsSSk9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTtjb25zdCBnPUkoMzQ2NCk7Y2xhc3MgdHtjb25zdHJ1Y3RvcihBLGUsSSl7dGhpcy5nbEN0eD12b2lkIDAsdGhpcy5wcm9ncmFtPXZvaWQgMCx0aGlzLmdsQ3R4PUEsdGhpcy5wcm9ncmFtPXRoaXMuZ2xDdHguY3JlYXRlUHJvZ3JhbSgpLHRoaXMuZ2xDdHguYXR0YWNoU2hhZGVyKHRoaXMucHJvZ3JhbSxlKSx0aGlzLmdsQ3R4LmF0dGFjaFNoYWRlcih0aGlzLnByb2dyYW0sSSksdGhpcy5nbEN0eC5saW5rUHJvZ3JhbSh0aGlzLnByb2dyYW0pLHRoaXMuZ2xDdHguZ2V0UHJvZ3JhbVBhcmFtZXRlcih0aGlzLnByb2dyYW0sdGhpcy5nbEN0eC5MSU5LX1NUQVRVUyl8fGcuUmFpbndheUxvZ2dpbmcuZXJyb3IoXCJTaGFkZXIgbGluayBmYWlsZWQuXCIpfXN0YXRpYyBjb21waWxlKEEsZSxJKXtsZXQgdDtyZXR1cm4gdD1cInZlcnRleFwiPT09ZT9BLmNyZWF0ZVNoYWRlcihBLlZFUlRFWF9TSEFERVIpOkEuY3JlYXRlU2hhZGVyKEEuRlJBR01FTlRfU0hBREVSKSxBLnNoYWRlclNvdXJjZSh0LEkpLEEuY29tcGlsZVNoYWRlcih0KSwwPT1BLmdldFNoYWRlclBhcmFtZXRlcih0LEEuQ09NUElMRV9TVEFUVVMpJiZnLlJhaW53YXlMb2dnaW5nLmVycm9yKFwiU2hhZGVyIGNvbXBpbGUgZmFpbGVkLCBsb2c6IFwiK0EuZ2V0U2hhZGVySW5mb0xvZyh0KSksdH1zdGF0aWMgY3JlYXRlKEEsZSxJKXtjb25zdCBnPXQuY29tcGlsZShBLFwidmVydGV4XCIsZSksaT10LmNvbXBpbGUoQSxcImZyYWdtZW50XCIsSSk7cmV0dXJuIG5ldyB0KEEsZyxpKX11c2UoKXt0aGlzLmdsQ3R4LnVzZVByb2dyYW0odGhpcy5wcm9ncmFtKX1nZXRBdHRyaWJ1dGVMb2NhdGlvbihBKXtyZXR1cm4gdGhpcy5nbEN0eC5nZXRBdHRyaWJMb2NhdGlvbih0aGlzLnByb2dyYW0sQSl9Z2V0VW5pZm9ybUxvY2F0aW9uKEEpe2NvbnN0IGU9dGhpcy5nbEN0eC5nZXRVbmlmb3JtTG9jYXRpb24odGhpcy5wcm9ncmFtLEEpO2lmKGUpcmV0dXJuIGV9c2V0TWF0cml4VW5pZm9ybShBLGUpe3RoaXMuZ2xDdHgudW5pZm9ybU1hdHJpeDRmdihBLCExLGUpfX1lLmRlZmF1bHQ9dH0sNzU2OmZ1bmN0aW9uKEEsZSxJKXtcInVzZSBzdHJpY3RcIjt2YXIgZz10aGlzJiZ0aGlzLl9faW1wb3J0RGVmYXVsdHx8ZnVuY3Rpb24oQSl7cmV0dXJuIEEmJkEuX19lc01vZHVsZT9BOntkZWZhdWx0OkF9fTtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxlLnl1dkZyYWdTaGFkZXJTcmM9dm9pZCAwO2NvbnN0IHQ9ZyhJKDQ5MTkpKTtlLnl1dkZyYWdTaGFkZXJTcmM9XCJcXG4gICAgcHJlY2lzaW9uIGxvd3AgZmxvYXQ7XFxuICAgIFxcbiAgICB2YXJ5aW5nIHZlYzIgdlRleENvb3JkO1xcbiAgICBcXG4gICAgdW5pZm9ybSBzYW1wbGVyMkQgeVRleHR1cmU7XFxuICAgIHVuaWZvcm0gc2FtcGxlcjJEIHVUZXh0dXJlO1xcbiAgICB1bmlmb3JtIHNhbXBsZXIyRCB2VGV4dHVyZTtcXG4gICAgY29uc3QgbWF0MyBjb252ZXJzaW9uID0gbWF0MyhcXG4gICAgICAgIDEuMTY0LCAwLjAwMCwgIDEuNTk2LFxcbiAgICAgICAgMS4xNjQsIC0wLjM5MSwgLTAuODEzLFxcbiAgICAgICAgMS4xNjQsIDIuMDE4LCAgMC4wMDBcXG4gICAgKTtcXG5cXG4gICAgY29uc3QgdmVjMyBvZmZzZXQgPSB2ZWMzKDAuMDYyNSwgMC41LCAwLjUpO1xcbiAgICAgICAgXFxuICAgIHZvaWQgbWFpbih2b2lkKSB7XFxuICAgICAgICBmbG9hdCB5ID0gdGV4dHVyZTJEKHlUZXh0dXJlLCB2VGV4Q29vcmQpLng7XFxuICAgICAgICBmbG9hdCB1ID0gdGV4dHVyZTJEKHVUZXh0dXJlLCB2VGV4Q29vcmQpLng7XFxuICAgICAgICBmbG9hdCB2ID0gdGV4dHVyZTJEKHZUZXh0dXJlLCB2VGV4Q29vcmQpLng7XFxuICAgICAgICB2ZWMzIHl1diA9IHZlYzMoeSwgdSwgdikgLSBvZmZzZXQ7XFxuXFxuICAgICAgICB2ZWMzIHJnYiA9ICh5dXYgKiBjb252ZXJzaW9uKTtcXG5cXG4gICAgICAgIGdsX0ZyYWdDb2xvciA9IHZlYzQocmdiLCAxLjApO1xcbiAgICB9XFxuXCI7Y2xhc3MgaXtjb25zdHJ1Y3RvcihBLGUsSSxnLHQsaSxCLEMsUSl7dGhpcy5nbEN0eD1BLHRoaXMucHJvZ3JhbT1lLHRoaXMucHJvamVjdGlvbk10eExvYz1JLHRoaXMucG9zaXRpb25BdHRyPWcsdGhpcy50ZXhDb29yZEF0dHI9dCx0aGlzLnZlcnRleEJ1ZmZlcj1pLHRoaXMueVRleHR1cmVMb2M9Qix0aGlzLnVUZXh0dXJlTG9jPUMsdGhpcy52VGV4dHVyZUxvYz1RfXN0YXRpYyBjcmVhdGUoQSl7Y29uc3QgST10LmRlZmF1bHQuY3JlYXRlKEEsXCJcXG4gICAgcHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XFxuXFxuICAgIHVuaWZvcm0gbWF0NCB1UHJvamVjdGlvbjtcXG4gICAgYXR0cmlidXRlIHZlYzIgYVBvc2l0aW9uO1xcbiAgICBhdHRyaWJ1dGUgdmVjMiBhVGV4Q29vcmQ7XFxuXFxuICAgIHZhcnlpbmcgdmVjMiB2VGV4Q29vcmQ7XFxuICAgIHZvaWQgbWFpbigpe1xcbiAgICAgICAgdlRleENvb3JkID0gYVRleENvb3JkO1xcbiAgICAgICAgZ2xfUG9zaXRpb24gPSB1UHJvamVjdGlvbiAqIHZlYzQoYVBvc2l0aW9uLCAwLjAsIDEuMCk7XFxuICAgIH1cXG5cIixlLnl1dkZyYWdTaGFkZXJTcmMpO0kudXNlKCk7Y29uc3QgZz1JLmdldFVuaWZvcm1Mb2NhdGlvbihcInVQcm9qZWN0aW9uXCIpLEI9SS5nZXRBdHRyaWJ1dGVMb2NhdGlvbihcImFQb3NpdGlvblwiKTtBLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KEIpO2NvbnN0IEM9SS5nZXRBdHRyaWJ1dGVMb2NhdGlvbihcImFUZXhDb29yZFwiKTtBLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KEMpO2NvbnN0IFE9QS5jcmVhdGVCdWZmZXIoKSxvPUkuZ2V0VW5pZm9ybUxvY2F0aW9uKFwieVRleHR1cmVcIiksbj1JLmdldFVuaWZvcm1Mb2NhdGlvbihcInVUZXh0dXJlXCIpLGE9SS5nZXRVbmlmb3JtTG9jYXRpb24oXCJ2VGV4dHVyZVwiKTtyZXR1cm4gbmV3IGkoQSxJLGcsQixDLFEsbyxuLGEpfWJpbmRJbnB1dFRleHR1cmVzKEEsZSxJKXtjb25zdCBnPXRoaXMuZ2xDdHg7Zy51bmlmb3JtMWkodGhpcy55VGV4dHVyZUxvYywwKSxnLmFjdGl2ZVRleHR1cmUoZy5URVhUVVJFMCksZy5iaW5kVGV4dHVyZShnLlRFWFRVUkVfMkQsQS50ZXh0dXJlSWQpLGcudW5pZm9ybTFpKHRoaXMudVRleHR1cmVMb2MsMSksZy5hY3RpdmVUZXh0dXJlKGcuVEVYVFVSRTEpLGcuYmluZFRleHR1cmUoZy5URVhUVVJFXzJELGUudGV4dHVyZUlkKSxnLnVuaWZvcm0xaSh0aGlzLnZUZXh0dXJlTG9jLDIpLGcuYWN0aXZlVGV4dHVyZShnLlRFWFRVUkUyKSxnLmJpbmRUZXh0dXJlKGcuVEVYVFVSRV8yRCxJLnRleHR1cmVJZCl9dXNlKCl7dGhpcy5wcm9ncmFtLnVzZSgpfWRyb3AoKXt0aGlzLmdsQ3R4LnVzZVByb2dyYW0oMCl9dXBkYXRlKEEsZSxJLGcpe3RoaXMuZ2xDdHgudmlld3BvcnQoMCwwLEEsZSksdGhpcy5wcm9ncmFtLnNldE1hdHJpeFVuaWZvcm0odGhpcy5wcm9qZWN0aW9uTXR4TG9jLFsyL0EsMCwwLDAsMCwyLy1lLDAsMCwwLDAsMSwwLC0xLDEsMCwxXSksdGhpcy5nbEN0eC5iaW5kQnVmZmVyKHRoaXMuZ2xDdHguQVJSQVlfQlVGRkVSLHRoaXMudmVydGV4QnVmZmVyKSx0aGlzLmdsQ3R4LmJ1ZmZlckRhdGEodGhpcy5nbEN0eC5BUlJBWV9CVUZGRVIsbmV3IEZsb2F0MzJBcnJheShbMCwwLDAsMCxBLDAsSSwwLEEsZSxJLGcsQSxlLEksZywwLGUsMCxnLDAsMCwwLDBdKSx0aGlzLmdsQ3R4LkRZTkFNSUNfRFJBVyksdGhpcy5nbEN0eC52ZXJ0ZXhBdHRyaWJQb2ludGVyKHRoaXMucG9zaXRpb25BdHRyLDIsdGhpcy5nbEN0eC5GTE9BVCwhMSwxNiwwKSx0aGlzLmdsQ3R4LnZlcnRleEF0dHJpYlBvaW50ZXIodGhpcy50ZXhDb29yZEF0dHIsMix0aGlzLmdsQ3R4LkZMT0FULCExLDE2LDgpfWRyYXcoKXtjb25zdCBBPXRoaXMuZ2xDdHg7QS5jbGVhcihBLkNPTE9SX0JVRkZFUl9CSVR8QS5ERVBUSF9CVUZGRVJfQklUfEEuU1RFTkNJTF9CVUZGRVJfQklUKSxBLmRyYXdBcnJheXMoQS5UUklBTkdMRV9TVFJJUCwwLDYpLEEuYmluZFRleHR1cmUoQS5URVhUVVJFXzJELG51bGwpfX1lLmRlZmF1bHQ9aX0sMzM0NjooQSxlKT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO2NsYXNzIEl7Y29uc3RydWN0b3IoQSxlKXt0aGlzLmdsQ3R4PXZvaWQgMCx0aGlzLnRleHR1cmVJZD12b2lkIDAsdGhpcy5nbEN0eD1BLHRoaXMudGV4dHVyZUlkPWV9c3RhdGljIGNyZWF0ZShBKXtjb25zdCBlPUEuY3JlYXRlVGV4dHVyZSgpO3JldHVybiBBLmJpbmRUZXh0dXJlKEEuVEVYVFVSRV8yRCxlKSxBLnRleFBhcmFtZXRlcmkoQS5URVhUVVJFXzJELEEuVEVYVFVSRV9NQUdfRklMVEVSLEEuTkVBUkVTVCksQS50ZXhQYXJhbWV0ZXJpKEEuVEVYVFVSRV8yRCxBLlRFWFRVUkVfTUlOX0ZJTFRFUixBLk5FQVJFU1QpLEEudGV4UGFyYW1ldGVyaShBLlRFWFRVUkVfMkQsQS5URVhUVVJFX1dSQVBfUyxBLkNMQU1QX1RPX0VER0UpLEEudGV4UGFyYW1ldGVyaShBLlRFWFRVUkVfMkQsQS5URVhUVVJFX1dSQVBfVCxBLkNMQU1QX1RPX0VER0UpLEEuYmluZFRleHR1cmUoQS5URVhUVVJFXzJELG51bGwpLG5ldyBJKEEsZSl9dXBsb2FkQnVmZmVyKEEsZSxJKXtjb25zdCBnPXRoaXMuZ2xDdHg7Zy5iaW5kVGV4dHVyZShnLlRFWFRVUkVfMkQsdGhpcy50ZXh0dXJlSWQpLGcudGV4SW1hZ2UyRChnLlRFWFRVUkVfMkQsMCxnLkxVTUlOQU5DRSxlLEksMCxnLkxVTUlOQU5DRSxnLlVOU0lHTkVEX0JZVEUsQSksZy5iaW5kVGV4dHVyZShnLlRFWFRVUkVfMkQsbnVsbCl9ZGVsZXRlKCl7bnVsbCE9dGhpcy5nbEN0eCYmMCE9dGhpcy50ZXh0dXJlSWQmJih0aGlzLmdsQ3R4LmRlbGV0ZVRleHR1cmUodGhpcy50ZXh0dXJlSWQpLHRoaXMudGV4dHVyZUlkPTApfX1lLmRlZmF1bHQ9SX0sNDQyNTpmdW5jdGlvbihBLGUsSSl7XCJ1c2Ugc3RyaWN0XCI7dmFyIGcsdD10aGlzJiZ0aGlzLl9fYXdhaXRlcnx8ZnVuY3Rpb24oQSxlLEksZyl7cmV0dXJuIG5ldyhJfHwoST1Qcm9taXNlKSkoKGZ1bmN0aW9uKHQsaSl7ZnVuY3Rpb24gQihBKXt0cnl7UShnLm5leHQoQSkpfWNhdGNoKEEpe2koQSl9fWZ1bmN0aW9uIEMoQSl7dHJ5e1EoZy50aHJvdyhBKSl9Y2F0Y2goQSl7aShBKX19ZnVuY3Rpb24gUShBKXt2YXIgZTtBLmRvbmU/dChBLnZhbHVlKTooZT1BLnZhbHVlLGUgaW5zdGFuY2VvZiBJP2U6bmV3IEkoKGZ1bmN0aW9uKEEpe0EoZSl9KSkpLnRoZW4oQixDKX1RKChnPWcuYXBwbHkoQSxlfHxbXSkpLm5leHQoKSl9KSl9LGk9dGhpcyYmdGhpcy5fX2NsYXNzUHJpdmF0ZUZpZWxkU2V0fHxmdW5jdGlvbihBLGUsSSl7aWYoIWUuaGFzKEEpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJhdHRlbXB0ZWQgdG8gc2V0IHByaXZhdGUgZmllbGQgb24gbm9uLWluc3RhbmNlXCIpO3JldHVybiBlLnNldChBLEkpLEl9LEI9dGhpcyYmdGhpcy5fX2NsYXNzUHJpdmF0ZUZpZWxkR2V0fHxmdW5jdGlvbihBLGUpe2lmKCFlLmhhcyhBKSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiYXR0ZW1wdGVkIHRvIGdldCBwcml2YXRlIGZpZWxkIG9uIG5vbi1pbnN0YW5jZVwiKTtyZXR1cm4gZS5nZXQoQSl9O09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLGUuTWVkaWFNYW5hZ2VyPWUuUmFpbndheVN0cmVhbUZpdD1lLlJhaW53YXlWaWRlb0Zvcm1hdD1lLlJhaW53YXlWaWRlb0RlY29kZXI9dm9pZCAwO2NvbnN0IEM9SSg2OTAwKSxRPUkoNjU4NSksbz1JKDEwNzgpLG49SSg1OTE0KSxhPUkoMjE0Nikscj1JKDM5MzApLEU9SSg2OTA0KTt2YXIgcyxkLGM7IWZ1bmN0aW9uKEEpe0FbQS5NU0U9MF09XCJNU0VcIixBW0EuU29mdHdhcmU9MV09XCJTb2Z0d2FyZVwifShzPWUuUmFpbndheVZpZGVvRGVjb2Rlcnx8KGUuUmFpbndheVZpZGVvRGVjb2Rlcj17fSkpLGZ1bmN0aW9uKEEpe0FbQS5Bbm5leEI9MF09XCJBbm5leEJcIixBW0EuTGVuZ3RoUHJlZml4ZWQ9MV09XCJMZW5ndGhQcmVmaXhlZFwifShkPWUuUmFpbndheVZpZGVvRm9ybWF0fHwoZS5SYWlud2F5VmlkZW9Gb3JtYXQ9e30pKSxmdW5jdGlvbihBKXtBW0EuSXNvbGF0ZWRBcHBzPTBdPVwiSXNvbGF0ZWRBcHBzXCIsQVtBLkZ1bGxEZXNrdG9wPTFdPVwiRnVsbERlc2t0b3BcIn0oYz1lLlJhaW53YXlTdHJlYW1GaXR8fChlLlJhaW53YXlTdHJlYW1GaXQ9e30pKSxlLk1lZGlhTWFuYWdlcj1jbGFzc3tjb25zdHJ1Y3RvcihBLGUsSSx0KXt2YXIgcjt0aGlzLmNhcHR1cmVNb2RlPUEsdGhpcy5jaG9zZW5WaWRlb0NvbmZpZz1lLGcuc2V0KHRoaXMsdm9pZCAwKSx0aGlzLm92ZXJsYXlFbmFibGVkPSExLHRoaXMuc3RyZWFtRml0PWMuSXNvbGF0ZWRBcHBzLGkodGhpcyxnLHt2aWRlbzpPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe2NvZGVjU3RyaW5nOid2aWRlby9tcDQ7IGNvZGVjcz1cImF2YzEuNDJjMDIwXCInfSx0aGlzLmF1dG9kZXRlY3RWaWRlb0NvbmZpZ3VyYXRpb24oKSksSS52aWRlbyksdmlkZW9QZXJmb3JtYW5jZTpudWxsIT09KHI9SS52aWRlb1BlcmZvcm1hbmNlKSYmdm9pZCAwIT09cj9yOnt9LGF1ZGlvOk9iamVjdC5hc3NpZ24oe30sSS5hdWRpbyl9KSxCKHRoaXMsZykudmlkZW8uZGVjb2Rlcj09PXMuU29mdHdhcmU/dGhpcy52aWRlb1N0cmVhbT1uZXcgYS5WaWRlb1N0cmVhbVNvZnR3YXJlRGVjb2RlcihCKHRoaXMsZykudmlkZW8uY29kZWNTdHJpbmcsZC5MZW5ndGhQcmVmaXhlZCk6dGhpcy52aWRlb1N0cmVhbT1uZXcgQy5WaWRlb1N0cmVhbU1TRShCKHRoaXMsZykudmlkZW8uY29kZWNTdHJpbmcpLHRoaXMuYXVkaW9TdHJlYW09bmV3IFEuQXVkaW9TdHJlYW0sdGhpcy5hdWRpb1N0cmVhbS5jb25maWd1cmUoQih0aGlzLGcpLmF1ZGlvKSx0aGlzLnZpZGVvUGVyZm9ybWFuY2VNb25pdG9yPW5ldyBvLlZpZGVvUGVyZm9ybWFuY2VNb25pdG9yKHRoaXMudmlkZW9TdHJlYW0sQih0aGlzLGcpLnZpZGVvUGVyZm9ybWFuY2UpLHRoaXMudmlkZW9TdGF0c092ZXJsYXk9bmV3IG4uVmlkZW9TdGF0c092ZXJsYXkodGhpcy52aWRlb1N0cmVhbSxCKHRoaXMsZykudmlkZW8uZGVjb2Rlcj09PXMuU29mdHdhcmUsdCl9Z2V0IHZpZGVvUmVhZHlTdGF0ZUNoYW5nZUV2ZW50KCl7cmV0dXJuIHRoaXMudmlkZW9TdHJlYW0ucmVhZHlTdGF0ZUNoYW5nZUV2ZW50fWdldCB2aWRlb05lZWRzUmVzdGFydEV2ZW50KCl7cmV0dXJuIHRoaXMudmlkZW9TdHJlYW0ubmVlZHNSZXN0YXJ0RXZlbnR9Z2V0IGF1ZGlvQ29udGV4dCgpe3JldHVybiB0aGlzLmF1ZGlvU3RyZWFtLmF1ZGlvQ29udGV4dH1nZXQgY3VycmVudFN0cmVhbUJvdW5kcygpe3JldHVybiB0aGlzLnN0cmVhbUJvdW5kc31nZXQgY3VycmVudEZ1bGxEZXNrdG9wQm91bmRzKCl7cmV0dXJuIHRoaXMuZnVsbERlc2t0b3BCb3VuZHN9aW5pdGlhbGl6ZSgpe3JldHVybiB0KHRoaXMsdm9pZCAwLHZvaWQgMCwoZnVuY3Rpb24qKCl7eWllbGQgdGhpcy5hdWRpb1N0cmVhbS5pbml0aWFsaXplKCksdGhpcy5hdWRpb1N0cmVhbS5wbGF5KCl9KSl9Z2V0IGNvbmZpZygpe3JldHVybiBCKHRoaXMsZyl9YXV0b2RldGVjdFZpZGVvQ29uZmlndXJhdGlvbigpe3JldHVybntkZWNvZGVyOndpbmRvdy5NZWRpYVNvdXJjZT9zLk1TRTpzLlNvZnR3YXJlfX1zZXRDb250YWluZXIoQSl7aWYodGhpcy51bnNldENvbnRhaW5lcigpLHRoaXMuY29udGFpbmVyPUEsdGhpcy5jYXB0dXJlTW9kZT09PUUuU3RyZWFtVHlwZS5BcHBJc29sYXRpb24pe2NvbnN0IEE9dGhpcy5jcmVhdGVJc29sYXRpb25DYW52YXNFbGVtZW50KCk7dGhpcy5zaG93U3RyZWFtRWxlbWVudChBKSxCKHRoaXMsZykudmlkZW8uZGVjb2Rlcj09PXMuTVNFP3RoaXMuc2V0SXNvbGF0aW9uU291cmNlKHRoaXMuY3JlYXRlVmlkZW9FbGVtZW50KCkpOnRoaXMuc2V0SXNvbGF0aW9uU291cmNlKHRoaXMuY3JlYXRlQ2FudmFzRWxlbWVudCgpKX1lbHNlIEIodGhpcyxnKS52aWRlby5kZWNvZGVyPT09cy5NU0U/dGhpcy5zaG93U3RyZWFtRWxlbWVudCh0aGlzLmNyZWF0ZVZpZGVvRWxlbWVudCgpKTp0aGlzLnNob3dTdHJlYW1FbGVtZW50KHRoaXMuY3JlYXRlQ2FudmFzRWxlbWVudCgpKTt0aGlzLm92ZXJsYXlFbmFibGVkJiZ0aGlzLmNyZWF0ZUFuZFNob3dTdGF0c092ZXJsYXkoKX1zZXRJc29sYXRpb25Tb3VyY2UoQSl7dGhpcy5pc29sYXRpb25Tb3VyY2U9QX1jcmVhdGVBbmRTaG93U3RhdHNPdmVybGF5KCl7Y29uc3QgQT10aGlzLmNyZWF0ZU92ZXJsYXlDYW52YXNFbGVtZW50KCk7dGhpcy5zaG93T3ZlcmxheUVsZW1lbnQoQSksQih0aGlzLGcpLnZpZGVvLmRlY29kZXI9PT1zLk1TRT90aGlzLnZpZGVvU3RhdHNPdmVybGF5LnNldEVsZW1lbnRzKHt2aWRlbzp0aGlzLnZpZGVvRWxlbWVudCxjYW52YXM6QSx1c2luZ091dHB1dENhbnZhczohMX0pOnRoaXMudmlkZW9TdGF0c092ZXJsYXkuc2V0RWxlbWVudHMoe2NhbnZhczpBLHVzaW5nT3V0cHV0Q2FudmFzOiExfSl9dW5zZXRDb250YWluZXIoKXt2YXIgQSxlLEksZyx0LGksQixDO3RoaXMuZGlzcG9zZVZpZGVvRWxlbWVudCgpLHRoaXMuZGlzcG9zZUNhbnZhc0VsZW1lbnQoKSx0aGlzLmRpc3Bvc2VPdmVybGF5Q2FudmFzRWxlbWVudCgpLHRoaXMuZGlzcG9zZUlzb2xhdGlvbkNhbnZhc0VsZW1lbnQoKSxudWxsPT09KGU9bnVsbD09PShBPXRoaXMuY29udGFpbmVyKXx8dm9pZCAwPT09QT92b2lkIDA6QS5xdWVyeVNlbGVjdG9yKFwiLnJhaW53YXktdmlkZW9cIikpfHx2b2lkIDA9PT1lfHxlLnJlbW92ZSgpLG51bGw9PT0oZz1udWxsPT09KEk9dGhpcy5jb250YWluZXIpfHx2b2lkIDA9PT1JP3ZvaWQgMDpJLnF1ZXJ5U2VsZWN0b3IoXCIucmFpbndheS1jYW52YXNcIikpfHx2b2lkIDA9PT1nfHxnLnJlbW92ZSgpLG51bGw9PT0oaT1udWxsPT09KHQ9dGhpcy5jb250YWluZXIpfHx2b2lkIDA9PT10P3ZvaWQgMDp0LnF1ZXJ5U2VsZWN0b3IoXCIucmFpbndheS1vdmVybGF5LWNhbnZhc1wiKSl8fHZvaWQgMD09PWl8fGkucmVtb3ZlKCksbnVsbD09PShDPW51bGw9PT0oQj10aGlzLmNvbnRhaW5lcil8fHZvaWQgMD09PUI/dm9pZCAwOkIucXVlcnlTZWxlY3RvcihcIi5yYWlud2F5LWlzb2xhdGlvbi1jYW52YXNcIikpfHx2b2lkIDA9PT1DfHxDLnJlbW92ZSgpLHRoaXMuY29udGFpbmVyPXZvaWQgMH1zaG93T3ZlcmxheUVsZW1lbnQoQSl7T2JqZWN0LmFzc2lnbihBLnN0eWxlLHtwb3NpdGlvbjpcImFic29sdXRlXCIsdG9wOlwiMFwiLGJvdHRvbTpcIjBcIixsZWZ0OlwiMFwiLHJpZ2h0OlwiMFwiLHdpZHRoOlwiMTAwJVwiLGhlaWdodDpcIjEwMCVcIixwb2ludGVyRXZlbnRzOlwibm9uZVwifSl9Y3JlYXRlVmlkZW9FbGVtZW50KCl7dmFyIEEsZTtudWxsPT09KGU9bnVsbD09PShBPXRoaXMuY29udGFpbmVyKXx8dm9pZCAwPT09QT92b2lkIDA6QS5xdWVyeVNlbGVjdG9yKFwiLnJhaW53YXktdmlkZW9cIikpfHx2b2lkIDA9PT1lfHxlLnJlbW92ZSgpLHRoaXMudmlkZW9FbGVtZW50PWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJ2aWRlb1wiKTtjb25zdCBJPXRoaXMudmlkZW9FbGVtZW50O3JldHVybiBJLm9uY29udGV4dG1lbnU9KCk9PiExLEkuY2xhc3NOYW1lPVwicmFpbndheS12aWRlb1wiLEkuYXV0b3BsYXk9ITAsSS5tdXRlZD0hMCxJLnN0eWxlLmRpc3BsYXk9XCJub25lXCIsdGhpcy5jb250YWluZXIuYXBwZW5kQ2hpbGQoSSksdGhpcy52aWRlb1N0cmVhbS5hdHRhY2hUb0VsZW1lbnQoSSksdGhpcy52aWRlb0VsZW1lbnR9ZGlzcG9zZVZpZGVvRWxlbWVudCgpe3RoaXMudmlkZW9FbGVtZW50JiYodGhpcy52aWRlb1N0cmVhbS5kZXRhY2hGcm9tRWxlbWVudCgpLHRoaXMudmlkZW9FbGVtZW50LnJlbW92ZSgpLHRoaXMudmlkZW9FbGVtZW50PXZvaWQgMCl9Y3JlYXRlT3ZlcmxheUNhbnZhc0VsZW1lbnQoKXt2YXIgQSxlLEk7bnVsbD09PShlPW51bGw9PT0oQT10aGlzLmNvbnRhaW5lcil8fHZvaWQgMD09PUE/dm9pZCAwOkEucXVlcnlTZWxlY3RvcihcIi5yYWlud2F5LW92ZXJsYXktY2FudmFzXCIpKXx8dm9pZCAwPT09ZXx8ZS5yZW1vdmUoKSx0aGlzLmNhbnZhc0VsZW1lbnQ9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKTtjb25zdCBnPXRoaXMuY2FudmFzRWxlbWVudDtyZXR1cm4gZy5vbmNvbnRleHRtZW51PSgpPT4hMSxnLmNsYXNzTmFtZT1cInJhaW53YXktb3ZlcmxheS1jYW52YXNcIix0aGlzLmNvbnRhaW5lci5hcHBlbmRDaGlsZChnKSxudWxsPT09KEk9Zy5nZXRDb250ZXh0KFwiMmRcIikpfHx2b2lkIDA9PT1JfHxJLmNsZWFyUmVjdCgwLDAsZy53aWR0aCxnLmhlaWdodCksZ31kaXNwb3NlT3ZlcmxheUNhbnZhc0VsZW1lbnQoKXt2YXIgQSxlO251bGw9PT0oZT1udWxsPT09KEE9dGhpcy5jb250YWluZXIpfHx2b2lkIDA9PT1BP3ZvaWQgMDpBLnF1ZXJ5U2VsZWN0b3IoXCIucmFpbndheS1vdmVybGF5LWNhbnZhc1wiKSl8fHZvaWQgMD09PWV8fGUucmVtb3ZlKCksdGhpcy5vdmVybGF5Q2FudmFzRWxlbWVudCYmKHRoaXMub3ZlcmxheUNhbnZhc0VsZW1lbnQucmVtb3ZlKCksdGhpcy5vdmVybGF5Q2FudmFzRWxlbWVudD12b2lkIDApfWNyZWF0ZUNhbnZhc0VsZW1lbnQoKXt2YXIgQSxlLEk7bnVsbD09PShlPW51bGw9PT0oQT10aGlzLmNvbnRhaW5lcil8fHZvaWQgMD09PUE/dm9pZCAwOkEucXVlcnlTZWxlY3RvcihcIi5yYWlud2F5LWNhbnZhc1wiKSl8fHZvaWQgMD09PWV8fGUucmVtb3ZlKCksdGhpcy5jYW52YXNFbGVtZW50PWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7Y29uc3QgZz10aGlzLmNhbnZhc0VsZW1lbnQ7cmV0dXJuIGcub25jb250ZXh0bWVudT0oKT0+ITEsZy5jbGFzc05hbWU9XCJyYWlud2F5LWNhbnZhc1wiLGcuc3R5bGUuZGlzcGxheT1cIm5vbmVcIix0aGlzLmNvbnRhaW5lci5hcHBlbmRDaGlsZChnKSx0aGlzLnZpZGVvU3RyZWFtIGluc3RhbmNlb2YgYS5WaWRlb1N0cmVhbVNvZnR3YXJlRGVjb2RlciYmdGhpcy52aWRlb1N0cmVhbS5hdHRhY2hUb0NhbnZhcyhnKSxudWxsPT09KEk9Zy5nZXRDb250ZXh0KFwiMmRcIikpfHx2b2lkIDA9PT1JfHxJLmNsZWFyUmVjdCgwLDAsZy53aWR0aCxnLmhlaWdodCksZ31kaXNwb3NlQ2FudmFzRWxlbWVudCgpe3RoaXMuY2FudmFzRWxlbWVudCYmKHRoaXMudmlkZW9TdHJlYW0gaW5zdGFuY2VvZiBhLlZpZGVvU3RyZWFtU29mdHdhcmVEZWNvZGVyJiZ0aGlzLnZpZGVvU3RyZWFtLmRldGFjaEZyb21DYW52YXMoKSx0aGlzLmNhbnZhc0VsZW1lbnQucmVtb3ZlKCksdGhpcy5jYW52YXNFbGVtZW50PXZvaWQgMCl9Y3JlYXRlSXNvbGF0aW9uQ2FudmFzRWxlbWVudCgpe3ZhciBBLGUsSTtudWxsPT09KGU9bnVsbD09PShBPXRoaXMuY29udGFpbmVyKXx8dm9pZCAwPT09QT92b2lkIDA6QS5xdWVyeVNlbGVjdG9yKFwiLnJhaW53YXktaXNvbGF0aW9uLWNhbnZhc1wiKSl8fHZvaWQgMD09PWV8fGUucmVtb3ZlKCksdGhpcy5pc29sYXRpb25DYW52YXNFbGVtZW50PWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7Y29uc3QgZz10aGlzLmlzb2xhdGlvbkNhbnZhc0VsZW1lbnQ7cmV0dXJuIGcub25jb250ZXh0bWVudT0oKT0+ITEsZy5jbGFzc05hbWU9XCJyYWlud2F5LWlzb2xhdGlvbi1jYW52YXNcIix0aGlzLmNvbnRhaW5lci5hcHBlbmRDaGlsZChnKSxudWxsPT09KEk9Zy5nZXRDb250ZXh0KFwiMmRcIikpfHx2b2lkIDA9PT1JfHxJLmNsZWFyUmVjdCgwLDAsZy53aWR0aCxnLmhlaWdodCksZ31kaXNwb3NlSXNvbGF0aW9uQ2FudmFzRWxlbWVudCgpe3RoaXMuaXNvbGF0aW9uQ2FudmFzRWxlbWVudCYmKHRoaXMuaXNvbGF0aW9uQ2FudmFzRWxlbWVudC5yZW1vdmUoKSx0aGlzLmlzb2xhdGlvbkNhbnZhc0VsZW1lbnQ9dm9pZCAwKX1oaWRlU3RyZWFtRWxlbWVudChBKXtBLnN0eWxlLndpZHRoPVwiMFwiLEEuc3R5bGUuaGVpZ2h0PVwiMFwifXNob3dTdHJlYW1FbGVtZW50KEEpe3RoaXMuY29udGFpbmVyJiYodGhpcy5zdHJlYW1FbGVtZW50PUEsQS5zdHlsZS53aWR0aD1cIjEwMCVcIixBLnN0eWxlLmhlaWdodD1cIjEwMCVcIixBLnN0eWxlLmRpc3BsYXk9XCJibG9ja1wiLEEuc3R5bGUub2JqZWN0Rml0PVwiY29udGFpblwiKX1wYXVzZSgpe3RoaXMudmlkZW9TdHJlYW0ucGF1c2UoKSx0aGlzLmF1ZGlvU3RyZWFtLnN0b3AoKX1wbGF5KCl7dGhpcy52aWRlb1N0cmVhbS5wbGF5KCksdGhpcy5hdWRpb1N0cmVhbS5wbGF5KCl9cmVuZGVyVmlkZW9GcmFtZShBLGUpe3RoaXMudmlkZW9TdHJlYW0ucHVzaERhdGEoQSxlKSx0aGlzLmZ1bGxEZXNrdG9wQm91bmRzPXtsZWZ0OkEueCx0b3A6QS55LHdpZHRoOkEud2lkdGgsaGVpZ2h0OkEuaGVpZ2h0fSx0aGlzLmNhcHR1cmVNb2RlPT09RS5TdHJlYW1UeXBlLkFwcElzb2xhdGlvbj8oQS5tYXNrLmxlbmd0aD4wJiYodGhpcy5tYXNrPUEubWFzayksQS53aWR0aD4wJiYodGhpcy5mcmFtZVdpZHRoPUEud2lkdGgpLEEuaGVpZ2h0PjAmJih0aGlzLmZyYW1lSGVpZ2h0PUEuaGVpZ2h0KSx0aGlzLnJlbmRlcklzb2xhdGVkQXBwKCkpOnRoaXMuc3RyZWFtQm91bmRzPXRoaXMuZnVsbERlc2t0b3BCb3VuZHN9cmVuZGVySXNvbGF0ZWRBcHAoKXtpZighdGhpcy5tYXNrKXJldHVybjtpZighdGhpcy5mcmFtZVdpZHRoKXJldHVybjtpZighdGhpcy5mcmFtZUhlaWdodClyZXR1cm47Y29uc3QgQT10aGlzLmlzb2xhdGlvblNvdXJjZTtpZighQSlyZXR1cm47Y29uc3QgZT10aGlzLmlzb2xhdGlvbkNhbnZhc0VsZW1lbnQ7aWYoIWUpcmV0dXJuO2NvbnN0IEk9ZS5nZXRDb250ZXh0KFwiMmRcIik7aWYoIUkpcmV0dXJuO2NvbnN0IGc9dGhpcy5zdHJlYW1GaXQ9PWMuSXNvbGF0ZWRBcHBzP3IuYm91bmRpbmdSZWN0YW5nbGUodGhpcy5tYXNrKTp0aGlzLmZ1bGxEZXNrdG9wQm91bmRzO3RoaXMuc3RyZWFtQm91bmRzPWc7Y29uc3QgdD10aGlzLmNob3NlblZpZGVvQ29uZmlnLmNvZGVjLndpZHRoL3RoaXMuZnJhbWVXaWR0aCxpPXRoaXMuY2hvc2VuVmlkZW9Db25maWcuY29kZWMuaGVpZ2h0L3RoaXMuZnJhbWVIZWlnaHQ7ZS53aWR0aD1nLndpZHRoKnQsZS5oZWlnaHQ9Zy5oZWlnaHQqaTtmb3IoY29uc3R7bGVmdDplLHRvcDpCLHdpZHRoOkMsaGVpZ2h0OlF9b2YgdGhpcy5tYXNrKXtjb25zdCBvPWUqdCxuPUIqaSxhPUMqdCxyPVEqaSxFPShlLWcubGVmdCkqdCxzPShCLWcudG9wKSppO0kuZHJhd0ltYWdlKEEsbyxuLGEscixFLHMsYSxyKX19cHJvY2Vzc0F1ZGlvKEEpe3RoaXMuYXVkaW9TdHJlYW0ucHVzaERhdGEoQSl9Z2V0VmlkZW9TdGF0cygpe3JldHVybiB0aGlzLnZpZGVvU3RyZWFtLmdldFN0YXRzKCl9Y29uZmlndXJlQXVkaW8oQSl7cmV0dXJuIHQodGhpcyx2b2lkIDAsdm9pZCAwLChmdW5jdGlvbiooKXtCKHRoaXMsZykuYXVkaW89T2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LEIodGhpcyxnKS5hdWRpbyksQSksdGhpcy5hdWRpb1N0cmVhbS5jb25maWd1cmUoQSl9KSl9ZW5hYmxlU3RhdHNPdmVybGF5KCl7dGhpcy5vdmVybGF5RW5hYmxlZD0hMCx0aGlzLnZpZGVvU3RhdHNPdmVybGF5LmVuYWJsZSgpLHRoaXMuZGlzcG9zZU92ZXJsYXlDYW52YXNFbGVtZW50KCksdGhpcy5jcmVhdGVBbmRTaG93U3RhdHNPdmVybGF5KCl9ZGlzYWJsZVN0YXRzT3ZlcmxheSgpe3RoaXMuZGlzcG9zZU92ZXJsYXlDYW52YXNFbGVtZW50KCksdGhpcy5vdmVybGF5RW5hYmxlZD0hMSx0aGlzLnZpZGVvU3RhdHNPdmVybGF5LmRpc2FibGUoKX1kaXNwb3NlKCl7dGhpcy5wYXVzZSgpLHRoaXMudW5zZXRDb250YWluZXIoKSx0aGlzLmF1ZGlvU3RyZWFtLmRpc3Bvc2UoKSx0aGlzLnZpZGVvU3RyZWFtLmRpc3Bvc2UoKX1zZXRWb2x1bWUoQSl7dGhpcy5hdWRpb1N0cmVhbS5zZXRWb2x1bWUoQSl9fSxnPW5ldyBXZWFrTWFwfSwxNjMzOmZ1bmN0aW9uKEEsZSl7XCJ1c2Ugc3RyaWN0XCI7dmFyIEksZz10aGlzJiZ0aGlzLl9fYXdhaXRlcnx8ZnVuY3Rpb24oQSxlLEksZyl7cmV0dXJuIG5ldyhJfHwoST1Qcm9taXNlKSkoKGZ1bmN0aW9uKHQsaSl7ZnVuY3Rpb24gQihBKXt0cnl7UShnLm5leHQoQSkpfWNhdGNoKEEpe2koQSl9fWZ1bmN0aW9uIEMoQSl7dHJ5e1EoZy50aHJvdyhBKSl9Y2F0Y2goQSl7aShBKX19ZnVuY3Rpb24gUShBKXt2YXIgZTtBLmRvbmU/dChBLnZhbHVlKTooZT1BLnZhbHVlLGUgaW5zdGFuY2VvZiBJP2U6bmV3IEkoKGZ1bmN0aW9uKEEpe0EoZSl9KSkpLnRoZW4oQixDKX1RKChnPWcuYXBwbHkoQSxlfHxbXSkpLm5leHQoKSl9KSl9LHQ9dGhpcyYmdGhpcy5fX2NsYXNzUHJpdmF0ZUZpZWxkR2V0fHxmdW5jdGlvbihBLGUpe2lmKCFlLmhhcyhBKSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiYXR0ZW1wdGVkIHRvIGdldCBwcml2YXRlIGZpZWxkIG9uIG5vbi1pbnN0YW5jZVwiKTtyZXR1cm4gZS5nZXQoQSl9LGk9dGhpcyYmdGhpcy5fX2NsYXNzUHJpdmF0ZUZpZWxkU2V0fHxmdW5jdGlvbihBLGUsSSl7aWYoIWUuaGFzKEEpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJhdHRlbXB0ZWQgdG8gc2V0IHByaXZhdGUgZmllbGQgb24gbm9uLWluc3RhbmNlXCIpO3JldHVybiBlLnNldChBLEkpLEl9O09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLGUuQ2lyY3VsYXJCdWZmZXI9ZS5hdmVyYWdlPWUuY3JlYXRlU291cmNlQnVmZmVyPWUuYXdhaXRNZWRpYVNvdXJjZU9wZW49ZS5jcmVhdGVNZWRpYVNvdXJjZT1lLk1lZGlhVW5zdXBwb3J0ZWRFcnJvcj12b2lkIDA7Y2xhc3MgQiBleHRlbmRzIEVycm9ye31mdW5jdGlvbiBDKEEsZSl7cmV0dXJuIGcodGhpcyx2b2lkIDAsdm9pZCAwLChmdW5jdGlvbiooKXtyZXR1cm4gbmV3IFByb21pc2UoKChJLGcpPT57bGV0IHQ9ITE7Y29uc3QgaT0oKT0+e0EucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInNvdXJjZW9wZW5cIixCKSxudWxsPT1lfHxlLnJlbW92ZUhhbmRsZXIobyksd2luZG93LmNsZWFySW50ZXJ2YWwoUSksdD0hMH0sQj0oKT0+e2koKSxJKCEwKX0sQz0oKT0+e3R8fFwib3BlblwiPT09QS5yZWFkeVN0YXRlJiYoaSgpLEkoITApKX0sUT13aW5kb3cuc2V0SW50ZXJ2YWwoQyw1MDApO0MoKSx3aW5kb3cuc2V0VGltZW91dCgoKCk9Pnt0fHwoaSgpLGcobmV3IEVycm9yKFwiTWVkaWFTb3VyY2Ugb3BlbiB0aW1lZCBvdXQuXCIpKSl9KSwxZTQpLEEuYWRkRXZlbnRMaXN0ZW5lcihcInNvdXJjZW9wZW5cIixCKTtjb25zdCBvPSgpPT57aSgpLEkoITEpfTtudWxsPT1lfHxlLmFkZEhhbmRsZXIobyl9KSl9KSl9ZS5NZWRpYVVuc3VwcG9ydGVkRXJyb3I9QixlLmNyZWF0ZU1lZGlhU291cmNlPWZ1bmN0aW9uKEEsZSl7cmV0dXJuIGcodGhpcyx2b2lkIDAsdm9pZCAwLChmdW5jdGlvbiooKXtpZighd2luZG93Lk1lZGlhU291cmNlKXRocm93IG5ldyBCKFwiQnJvd3NlciBkb2VzIG5vdCBzdXBwb3J0IE1TRS5cIik7Y29uc3QgST1uZXcgTWVkaWFTb3VyY2UsZz13aW5kb3cuVVJMLmNyZWF0ZU9iamVjdFVSTChJKTtpZihBLnNyYz12b2lkIDAsQS5zcmM9ZyxBLmxvYWQoKSx5aWVsZCBDKEksZSkpcmV0dXJuIEkuZHVyYXRpb249TnVtYmVyLlBPU0lUSVZFX0lORklOSVRZLEl9KSl9LGUuYXdhaXRNZWRpYVNvdXJjZU9wZW49QyxlLmNyZWF0ZVNvdXJjZUJ1ZmZlcj1mdW5jdGlvbihBLGUpe2NvbnN0IEk9QS5hZGRTb3VyY2VCdWZmZXIoZSk7cmV0dXJuIEkubW9kZT1cInNlcXVlbmNlXCIsSX0sZS5hdmVyYWdlPWZ1bmN0aW9uKEEpe3JldHVybiAwPT09QS5sZW5ndGg/MDpBLnJlZHVjZSgoKEEsZSk9PkErZSksMCkvQS5sZW5ndGh9LGUuQ2lyY3VsYXJCdWZmZXI9Y2xhc3N7Y29uc3RydWN0b3IoQSl7dGhpcy5tYXhMZW5ndGg9QSx0aGlzLm5leHRJbmRleD0wLHRoaXMubGlzdD1BcnJheSh0aGlzLm1heExlbmd0aCksSS5zZXQodGhpcywwKX1nZXQgbGVuZ3RoKCl7cmV0dXJuIHQodGhpcyxJKX1wdXNoKEEpe3RoaXMubGlzdFt0aGlzLm5leHRJbmRleCsrXT1BLGkodGhpcyxJLE1hdGgubWF4KHQodGhpcyxJKSx0aGlzLm5leHRJbmRleCkpLHRoaXMubmV4dEluZGV4JT10aGlzLm1heExlbmd0aH12YWx1ZXMoKXtyZXR1cm4gdGhpcy5saXN0LnNsaWNlKDAsdCh0aGlzLEkpKX19LEk9bmV3IFdlYWtNYXB9LDEwNzg6KEEsZSxJKT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLGUuVmlkZW9QZXJmb3JtYW5jZU1vbml0b3I9dm9pZCAwO2NvbnN0IGc9SSgxOTgpLHQ9SSgyNDM0KSxpPUkoOTAyNCksQj17dGFyZ2V0RnJhbWVyYXRlOjYwLGJ1ZmZlckxpbWl0TXM6NTAwLGNwdVN0YXJ2YXRpb25UaHJlc2hvbGQ6MSxkZWNvZGVyU3RydWdnbGluZ1RocmVzaG9sZDoxLGNoZWNrSW50ZXJ2YWw6MTUwMCx3aW5kb3dNczo1MDB9O2UuVmlkZW9QZXJmb3JtYW5jZU1vbml0b3I9Y2xhc3N7Y29uc3RydWN0b3IoQSxlPXt9KXt0aGlzLnZpZGVvU3RyZWFtPUEsdGhpcy5kZWNvZGVyU3RydWdnbGluZ0V2ZW50PW5ldyBpLkFjdGlvbix0aGlzLmNwdVN0YXJ2YXRpb25FdmVudD1uZXcgaS5BY3Rpb24sdGhpcy5jcHVTdGFydmF0aW9uQ291bnRlcj0wLHRoaXMuZGVjb2RlclN0cnVnZ2xpbmdDb3VudGVyPTAsdGhpcy5yZWFkeVN0YXRlQ2hhbmdlSGFuZGxlcj1BPT57QT09PXQuVmlkZW9SZWFkeVN0YXRlLkRldGFjaGVkP3RoaXMuc3RvcENoZWNraW5nKCk6dGhpcy5sYXN0VmlkZW9SZWFkeVN0YXRlPT09dC5WaWRlb1JlYWR5U3RhdGUuRGV0YWNoZWQmJnRoaXMuc3RhcnRDaGVja2luZygpLHRoaXMubGFzdFZpZGVvUmVhZHlTdGF0ZT1BfSx0aGlzLnZpZGVvRnJhbWVNZXRhZGF0YUhhbmRsZXI9QT0+e3RoaXMucHJvY2Vzc2luZ0R1cmF0aW9uVHJhY2suZmVlZChBKX0sdGhpcy5jaGVja1BlcmZvcm1hbmNlPSgpPT57aWYodGhpcy52aWRlb1N0cmVhbS5yZWFkeVN0YXRlPT09dC5WaWRlb1JlYWR5U3RhdGUuUGxheWluZyl7Y29uc3QgQT0xL3RoaXMuY29uZmlnLnRhcmdldEZyYW1lcmF0ZSxlPTFlMypBLEk9TWF0aC5mbG9vcih0aGlzLmNvbmZpZy5idWZmZXJMaW1pdE1zL2UpLGc9dGhpcy52aWRlb1N0cmVhbS5nZXRTdGF0cygpOyhnLmVuZE9mQnVmZmVyZWQ+Zy5jdXJyZW50VGltZSt0aGlzLmNvbmZpZy5idWZmZXJMaW1pdE1zLzFlM3x8dGhpcy52aWRlb1N0cmVhbS5kYXRhUXVldWVMZW5ndGg+SSkmJnRoaXMudmlkZW9TdHJlYW0ucmVzdGFydChcImNoZWNrUGVyZm9ybWFuY2VcIiksdGhpcy52aWRlb1N0cmVhbS5kYXRhUXVldWVMZW5ndGg+ST90aGlzLmNwdVN0YXJ2YXRpb25Db3VudGVyKz0xOnRoaXMuY3B1U3RhcnZhdGlvbkNvdW50ZXI9TWF0aC5tYXgoMCx0aGlzLmNwdVN0YXJ2YXRpb25Db3VudGVyLTEpLHRoaXMucHJvY2Vzc2luZ0R1cmF0aW9uVHJhY2suYXZlcmFnZSgpPkE/KHRoaXMuZGVjb2RlclN0cnVnZ2xpbmdDb3VudGVyKz0xLHRoaXMuY3B1U3RhcnZhdGlvbkNvdW50ZXI9TWF0aC5tYXgoMCx0aGlzLmNwdVN0YXJ2YXRpb25Db3VudGVyLTEpKTp0aGlzLmRlY29kZXJTdHJ1Z2dsaW5nQ291bnRlcj1NYXRoLm1heCgwLHRoaXMuZGVjb2RlclN0cnVnZ2xpbmdDb3VudGVyLTEpLHRoaXMuY3B1U3RhcnZhdGlvbkNvdW50ZXIsdGhpcy5jb25maWcuY3B1U3RhcnZhdGlvblRocmVzaG9sZCx0aGlzLmRlY29kZXJTdHJ1Z2dsaW5nQ291bnRlcix0aGlzLmNvbmZpZy5kZWNvZGVyU3RydWdnbGluZ1RocmVzaG9sZH19LHRoaXMuY29uZmlnPU9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSxCKSxlKSx0aGlzLnByb2Nlc3NpbmdEdXJhdGlvblRyYWNrPW5ldyBnLldpbmRvd1RyYWNrKHRoaXMuY29uZmlnLndpbmRvd01zLGcubWVhbk9yWmVybyksdGhpcy52aWRlb1N0cmVhbS5yZWFkeVN0YXRlQ2hhbmdlRXZlbnQuYWRkSGFuZGxlcih0aGlzLnJlYWR5U3RhdGVDaGFuZ2VIYW5kbGVyKSx0aGlzLnZpZGVvU3RyZWFtLnZpZGVvRnJhbWVQcm9jZXNzaW5nRHVyYXRpb25FdmVudC5hZGRIYW5kbGVyKHRoaXMudmlkZW9GcmFtZU1ldGFkYXRhSGFuZGxlciksdGhpcy5sYXN0VmlkZW9SZWFkeVN0YXRlPXRoaXMudmlkZW9TdHJlYW0ucmVhZHlTdGF0ZSx0aGlzLnZpZGVvU3RyZWFtLnJlYWR5U3RhdGUhPT10LlZpZGVvUmVhZHlTdGF0ZS5EZXRhY2hlZCYmdGhpcy5zdGFydENoZWNraW5nKCl9ZGlzcG9zZSgpe3RoaXMuc3RvcENoZWNraW5nKCksdGhpcy52aWRlb1N0cmVhbS5yZWFkeVN0YXRlQ2hhbmdlRXZlbnQucmVtb3ZlSGFuZGxlcih0aGlzLnJlYWR5U3RhdGVDaGFuZ2VIYW5kbGVyKSx0aGlzLnZpZGVvU3RyZWFtLnZpZGVvRnJhbWVQcm9jZXNzaW5nRHVyYXRpb25FdmVudC5yZW1vdmVIYW5kbGVyKHRoaXMudmlkZW9GcmFtZU1ldGFkYXRhSGFuZGxlcil9c3RhcnRDaGVja2luZygpe3RoaXMucHJvY2Vzc2luZ0R1cmF0aW9uVHJhY2s9bmV3IGcuV2luZG93VHJhY2sodGhpcy5jb25maWcud2luZG93TXMsZy5tZWFuT3JaZXJvKSx0aGlzLmNoZWNrUGVyZm9ybWFuY2VJbnRlcnZhbD13aW5kb3cuc2V0SW50ZXJ2YWwodGhpcy5jaGVja1BlcmZvcm1hbmNlLHRoaXMuY29uZmlnLmNoZWNrSW50ZXJ2YWwpfXN0b3BDaGVja2luZygpe3RoaXMuY2hlY2tQZXJmb3JtYW5jZUludGVydmFsJiYod2luZG93LmNsZWFySW50ZXJ2YWwodGhpcy5jaGVja1BlcmZvcm1hbmNlSW50ZXJ2YWwpLHRoaXMuY2hlY2tQZXJmb3JtYW5jZUludGVydmFsPXZvaWQgMCl9fX0sNTkxNDpmdW5jdGlvbihBLGUsSSl7XCJ1c2Ugc3RyaWN0XCI7dmFyIGc9dGhpcyYmdGhpcy5fX2F3YWl0ZXJ8fGZ1bmN0aW9uKEEsZSxJLGcpe3JldHVybiBuZXcoSXx8KEk9UHJvbWlzZSkpKChmdW5jdGlvbih0LGkpe2Z1bmN0aW9uIEIoQSl7dHJ5e1EoZy5uZXh0KEEpKX1jYXRjaChBKXtpKEEpfX1mdW5jdGlvbiBDKEEpe3RyeXtRKGcudGhyb3coQSkpfWNhdGNoKEEpe2koQSl9fWZ1bmN0aW9uIFEoQSl7dmFyIGU7QS5kb25lP3QoQS52YWx1ZSk6KGU9QS52YWx1ZSxlIGluc3RhbmNlb2YgST9lOm5ldyBJKChmdW5jdGlvbihBKXtBKGUpfSkpKS50aGVuKEIsQyl9USgoZz1nLmFwcGx5KEEsZXx8W10pKS5uZXh0KCkpfSkpfTtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxlLlZpZGVvU3RhdHNPdmVybGF5PXZvaWQgMDtjb25zdCB0PUkoMjE0NiksaT1JKDI0MzQpLEI9SSgxOTgpLEM9NWUzLFE9e2Ryb3BwZWRGcmFtZXM6XCJEcm9wcGVkIGZyYW1lc1wiLHRvdGFsRnJhbWVzOlwiVG90YWwgZnJhbWVzXCIsY3VycmVudFRpbWU6XCJDdXJyZW50IHZpZGVvIHRpbWVcIixlbmRPZkJ1ZmZlcmVkOlwiRW5kIG9mIHZpZGVvIGJ1ZmZlclwiLGVuZE9mU2Vla2FibGU6XCJFbmQgb2YgdmlkZW8gc2Vla2FibGVcIixkYXRhSW50ZXJ2YWw6XCJWaWRlbyBkYXRhIGludGVydmFsXCIsZGF0YVNpemU6XCJWaWRlbyBmcmFtZSBzaXplXCIscHJvY2Vzc2luZ0R1cmF0aW9uOlwiRnJhbWUgcHJvY2Vzc2luZyBkdXJhdGlvblwifTtlLlZpZGVvU3RhdHNPdmVybGF5PWNsYXNze2NvbnN0cnVjdG9yKEEsZSxJKXt0aGlzLnZpZGVvU3RyZWFtPUEsdGhpcy51c2luZ091dHB1dENhbnZhcz1lLHRoaXMuZ2V0U3RhdHM9SSx0aGlzLmNvbXBvc2l0aW5nVGltZVRyYWNrPW5ldyBCLldpbmRvd1RyYWNrKEMsQi5tZWFuKSx0aGlzLnByb2Nlc3NpbmdEdXJhdGlvblRyYWNrPW5ldyBCLldpbmRvd1RyYWNrKEMsQi5tZWFuKSx0aGlzLmZyYW1lVHJhY2s9bmV3IEIuV2luZG93VHJhY2soQyxCLm1lYW4pLHRoaXMuZHJhd0ludGVydmFsVHJhY2s9bmV3IEIuV2luZG93VHJhY2soQyxCLm1lYW4pLHRoaXMuZGlzcGxheVRpbWVJbnRlcnZhbFRyYWNrPW5ldyBCLldpbmRvd1RyYWNrKEMsQi5tZWFuKSx0aGlzLmZyYW1lQ291bnRlcj0wLHRoaXMudGhyb3VnaHB1dD1bXSx0aGlzLmZldGNoU3RhdHM9KCk9PmcodGhpcyx2b2lkIDAsdm9pZCAwLChmdW5jdGlvbiooKXt0aGlzLnZpZGVvU3RyZWFtLnJlYWR5U3RhdGU9PT1pLlZpZGVvUmVhZHlTdGF0ZS5QbGF5aW5nJiYodGhpcy5zdGF0cz10aGlzLnZpZGVvU3RyZWFtLmdldFN0YXRzKCksdGhpcy5sYXN0VHJhbnNwb3J0U3RhdHM9dGhpcy50cmFuc3BvcnRTdGF0cyx0aGlzLnRyYW5zcG9ydFN0YXRzPXlpZWxkIHRoaXMuZ2V0U3RhdHMoKSx0aGlzLnRocm91Z2hwdXQ9dGhpcy5nZXRUaHJvdWdocHV0KCkpfSkpLHRoaXMuYW5pbWF0aW9uRnJhbWVIYW5kbGVyPSgpPT57dGhpcy5mcmFtZVRyYWNrLmZlZWQodGhpcy5mcmFtZUNvdW50ZXIpLHRoaXMuZnJhbWVDb3VudGVyPTAsdGhpcy5hbmltYXRpb25GcmFtZUhhbmRsZT13aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRoaXMuYW5pbWF0aW9uRnJhbWVIYW5kbGVyKX0sdGhpcy5kcmF3U3RhdHNPbmx5T25BbmltYXRpb25GcmFtZT0oKT0+e2lmKHRoaXMuZHJhd1N0YXRzT25seUhhbmRsZT13aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRoaXMuZHJhd1N0YXRzT25seU9uQW5pbWF0aW9uRnJhbWUpLCF0aGlzLmNhbnZhc0NvbnRleHR8fHRoaXMudmlkZW9TdHJlYW0ucmVhZHlTdGF0ZSE9PWkuVmlkZW9SZWFkeVN0YXRlLlBsYXlpbmcpcmV0dXJuO2NvbnN0IEE9dGhpcy5jYW52YXNDb250ZXh0O3RoaXMudXNpbmdPdXRwdXRDYW52YXN8fChBLmNhbnZhcy53aWR0aCE9PUEuY2FudmFzLmNsaWVudFdpZHRoJiYoQS5jYW52YXMud2lkdGg9QS5jYW52YXMuY2xpZW50V2lkdGgpLEEuY2FudmFzLmhlaWdodCE9PUEuY2FudmFzLmNsaWVudEhlaWdodCYmKEEuY2FudmFzLmhlaWdodD1BLmNhbnZhcy5jbGllbnRIZWlnaHQpLEEuY2xlYXJSZWN0KDAsMCxBLmNhbnZhcy53aWR0aCxBLmNhbnZhcy5oZWlnaHQpKSx0aGlzLmRyYXdTdGF0cygpfSx0aGlzLmRyYXdTdGF0c0FuZEdyYXBoc09uVmlkZW9GcmFtZT0oW0EsZV0pPT57aWYodGhpcy5mcmFtZUNvdW50ZXIrKywhdGhpcy5jYW52YXNDb250ZXh0fHx0aGlzLnZpZGVvU3RyZWFtLnJlYWR5U3RhdGUhPT1pLlZpZGVvUmVhZHlTdGF0ZS5QbGF5aW5nfHwhZSlyZXR1cm47Y29uc3QgST10aGlzLmNhbnZhc0NvbnRleHQ7dGhpcy51c2luZ091dHB1dENhbnZhc3x8KEkuY2FudmFzLndpZHRoIT09SS5jYW52YXMuY2xpZW50V2lkdGgmJihJLmNhbnZhcy53aWR0aD1JLmNhbnZhcy5jbGllbnRXaWR0aCksSS5jYW52YXMuaGVpZ2h0IT09SS5jYW52YXMuY2xpZW50SGVpZ2h0JiYoSS5jYW52YXMuaGVpZ2h0PUkuY2FudmFzLmNsaWVudEhlaWdodCksSS5jbGVhclJlY3QoMCwwLEkuY2FudmFzLndpZHRoLEkuY2FudmFzLmhlaWdodCkpO2NvbnN0IGc9cGVyZm9ybWFuY2Uubm93KCk7dGhpcy5sYXN0Q2FudmFzRHJhd1RpbWUmJnRoaXMuZHJhd0ludGVydmFsVHJhY2suZmVlZChnLXRoaXMubGFzdENhbnZhc0RyYXdUaW1lKSx0aGlzLmxhc3RDYW52YXNEcmF3VGltZT1nO2NvbnN0IHQ9ZS5leHBlY3RlZERpc3BsYXlUaW1lO3RoaXMubGFzdERpc3BsYXlUaW1lJiZ0aGlzLmRpc3BsYXlUaW1lSW50ZXJ2YWxUcmFjay5mZWVkKHQtdGhpcy5sYXN0RGlzcGxheVRpbWUpLHRoaXMubGFzdERpc3BsYXlUaW1lPXQsdGhpcy5jb21wb3NpdGluZ1RpbWVUcmFjay5mZWVkKGUuZXhwZWN0ZWREaXNwbGF5VGltZS1BKSx0aGlzLnByb2Nlc3NpbmdEdXJhdGlvblRyYWNrLmZlZWQoZS5wcm9jZXNzaW5nRHVyYXRpb24pO2NvbnN0IEI9SS5jYW52YXM7Qi53aWR0aCxCLmNsaWVudFdpZHRoLEIuaGVpZ2h0LEIuY2xpZW50SGVpZ2h0LHRoaXMuZHJhd1N0YXRzKGUpfX1zZXRFbGVtZW50cyh7dmlkZW86QSxjYW52YXM6ZSx1c2luZ091dHB1dENhbnZhczpJPSExfSl7dGhpcy51c2luZ091dHB1dENhbnZhcz1JLHRoaXMuY2FudmFzPWUsdGhpcy52aWRlbz1BLHRoaXMuY2FudmFzJiYodGhpcy5jYW52YXNDb250ZXh0PXRoaXMuY2FudmFzLmdldENvbnRleHQoXCIyZFwiLHthbHBoYTohdGhpcy51c2luZ091dHB1dENhbnZhc30pKX1lbmFibGUoKXt0aGlzLmFuaW1hdGlvbkZyYW1lSGFuZGxlJiZ3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWUodGhpcy5hbmltYXRpb25GcmFtZUhhbmRsZSksdGhpcy5kcmF3U3RhdHNPbmx5SGFuZGxlJiZ3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWUodGhpcy5kcmF3U3RhdHNPbmx5SGFuZGxlKSx0aGlzLnZpZGVvU3RyZWFtIGluc3RhbmNlb2YgdC5WaWRlb1N0cmVhbVNvZnR3YXJlRGVjb2Rlcnx8XCJyZXF1ZXN0VmlkZW9GcmFtZUNhbGxiYWNrXCJpbiBIVE1MVmlkZW9FbGVtZW50LnByb3RvdHlwZT8odGhpcy5hbmltYXRpb25GcmFtZUhhbmRsZT13aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRoaXMuYW5pbWF0aW9uRnJhbWVIYW5kbGVyKSx0aGlzLnZpZGVvU3RyZWFtLnZpZGVvRnJhbWVFdmVudC5hZGRIYW5kbGVyKHRoaXMuZHJhd1N0YXRzQW5kR3JhcGhzT25WaWRlb0ZyYW1lKSk6dGhpcy5kcmF3U3RhdHNPbmx5SGFuZGxlPXdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUodGhpcy5kcmF3U3RhdHNPbmx5T25BbmltYXRpb25GcmFtZSksdGhpcy5zdGF0c0ludGVydmFsPXdpbmRvdy5zZXRJbnRlcnZhbCh0aGlzLmZldGNoU3RhdHMsMWUzKX1kaXNhYmxlKCl7dGhpcy5hbmltYXRpb25GcmFtZUhhbmRsZSYmd2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMuYW5pbWF0aW9uRnJhbWVIYW5kbGUpLHRoaXMuZHJhd1N0YXRzT25seUhhbmRsZSYmd2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMuZHJhd1N0YXRzT25seUhhbmRsZSksdGhpcy52aWRlb1N0cmVhbS52aWRlb0ZyYW1lRXZlbnQucmVtb3ZlSGFuZGxlcih0aGlzLmRyYXdTdGF0c0FuZEdyYXBoc09uVmlkZW9GcmFtZSksd2luZG93LmNsZWFySW50ZXJ2YWwodGhpcy5zdGF0c0ludGVydmFsKX1nZXRUaHJvdWdocHV0KCl7dmFyIEE7cmV0dXJuIHRoaXMudHJhbnNwb3J0U3RhdHMmJnRoaXMubGFzdFRyYW5zcG9ydFN0YXRzP09iamVjdC5lbnRyaWVzKG51bGw9PT0oQT10aGlzLnRyYW5zcG9ydFN0YXRzKXx8dm9pZCAwPT09QT92b2lkIDA6QS5jaGFubmVscykubWFwKCgoW0EsZV0pPT50aGlzLmxhc3RUcmFuc3BvcnRTdGF0cz9bQSxlLmJ5dGVzU2VudC10aGlzLmxhc3RUcmFuc3BvcnRTdGF0cy5jaGFubmVsc1tBXS5ieXRlc1NlbnQsZS5ieXRlc1JlY2VpdmVkLXRoaXMubGFzdFRyYW5zcG9ydFN0YXRzLmNoYW5uZWxzW0FdLmJ5dGVzUmVjZWl2ZWRdOltBLDAsMF0pKTpbXX1kcmF3U3RhdHMoQSl7dmFyIGUsSTtpZighdGhpcy5jYW52YXNDb250ZXh0fHx0aGlzLnZpZGVvU3RyZWFtLnJlYWR5U3RhdGUhPT1pLlZpZGVvUmVhZHlTdGF0ZS5QbGF5aW5nKXJldHVybjtjb25zdCBnPXRoaXMuY2FudmFzQ29udGV4dCx0PWcuY2FudmFzLEI9dC53aWR0aC90LmNsaWVudFdpZHRoLEM9dC5oZWlnaHQvdC5jbGllbnRIZWlnaHQsbz10aGlzLnRocm91Z2hwdXQ7aWYodGhpcy5zdGF0cyl7Y29uc3QgaT1PYmplY3QuZW50cmllcyh0aGlzLnN0YXRzKSxuPWkubGVuZ3RoK28ubGVuZ3RoLGE9Zy5tZWFzdXJlVGV4dChcIk1cIikud2lkdGg7Zy5maWxsU3R5bGU9XCJyZ2JhKDAsIDAsIDAsIDAuNSlcIjtjb25zdCByPShuKzIpKmErMiooYSsyKkMpKzE1KkM7Zy5maWxsUmVjdCgxMCpCLHQuaGVpZ2h0LShyKzEwKkMpLDMwMCpCLHIpLGcuZmlsbFN0eWxlPVwid2hpdGVcIixnLmZvbnQ9YCR7KDEyKkIpLnRvRml4ZWQoMCl9cHggc2Fucy1zZXJpZmAsZy50ZXh0QmFzZWxpbmU9XCJ0b3BcIjtsZXQgRT0wO2NvbnN0IHM9dC5oZWlnaHQtKHIrMTUqQykrMTUqQjtBP2cuZmlsbFRleHQoYFJlc29sdXRpb246ICR7QS53aWR0aH14JHtBLmhlaWdodH1gLDE1KkIscyk6Zy5maWxsVGV4dChgUmVzb2x1dGlvbjogJHtudWxsPT09KGU9dGhpcy52aWRlbyl8fHZvaWQgMD09PWU/dm9pZCAwOmUudmlkZW9XaWR0aH14JHtudWxsPT09KEk9dGhpcy52aWRlbyl8fHZvaWQgMD09PUk/dm9pZCAwOkkudmlkZW9IZWlnaHR9YCwxNSpCLHMpLGcuZmlsbFRleHQoYEVsZW1lbnQgc2l6ZTogJHt0LmNsaWVudFdpZHRofXgke3QuY2xpZW50SGVpZ2h0fWAsMTUqQixzK2EpO2Zvcihjb25zdFtBLGVdb2YgaSl7bGV0IEksdD1cIlwiO1wicHJvY2Vzc2luZ0R1cmF0aW9uXCI9PT1BPyh0PVwibXNcIixJPTFlMyplKTpJPWUsXCJlbmRPZkJ1ZmZlcmVkXCI9PT1BfHxcImVuZE9mU2Vla2FibGVcIj09PUF8fFwiY3VycmVudFRpbWVcIj09PUE/dD1cInNcIjpcImRhdGFJbnRlcnZhbFwiPT09QT90PVwibXNcIjpcImRhdGFTaXplXCI9PT1BJiYodD1cImJ5dGVzXCIpLGcuZmlsbFRleHQoYCR7UVtBXX06ICR7SS50b0ZpeGVkKDIpfSAke3R9YCwxNSpCLEUqKGErMipDKSsyKihhKzIqQykrcyksRSsrfWZvcihjb25zdFtBLGUsSV1vZiBvKWcuZmlsbFRleHQoYCR7QX0gdGhyb3VnaHB1dCAtIHVwOiAkeyhlLzFlMykudG9GaXhlZCgwKX0ga2IvcywgZG93bjogJHsoSS8xZTMpLnRvRml4ZWQoMCl9IGtiL3NgLDE1KkIsRSooYSsyKkMpKzIqKGErMipDKStzKSxFKyt9fX19LDQ0NDE6KEEsZSxJKT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLGUuVmlkZW9TdGF0cz12b2lkIDA7Y29uc3QgZz1JKDI5OTQpLHQ9SSgxNjMzKTtlLlZpZGVvU3RhdHM9Y2xhc3N7Y29uc3RydWN0b3IoKXt0aGlzLnByb2Nlc3NpbmdEdXJhdGlvbnM9bmV3IE1hcCx0aGlzLmRhdGFJbnRlcnZhbHM9bmV3IHQuQ2lyY3VsYXJCdWZmZXIoNjApLHRoaXMuZGF0YVNpemVzPW5ldyB0LkNpcmN1bGFyQnVmZmVyKDYwKSx0aGlzLnRvdGFsRnJhbWVzPTAsdGhpcy5wcmVzZW50ZWRGcmFtZXM9MH1wdXNoRnJhbWVNZXRhZGF0YShBKXt0aGlzLnByZXNlbnRlZEZyYW1lcys9MTtjb25zdHtwcm9jZXNzaW5nRHVyYXRpb246ZX09QSxJPShuZXcgRGF0ZSkuZ2V0VGltZSgpO3RoaXMucHJvY2Vzc2luZ0R1cmF0aW9ucy5zZXQoSSxlKTtmb3IoY29uc3RbQV1vZiB0aGlzLnByb2Nlc3NpbmdEdXJhdGlvbnMuZW50cmllcygpKUE8SS0xZTMmJnRoaXMucHJvY2Vzc2luZ0R1cmF0aW9ucy5kZWxldGUoQSl9cmVwb3J0RnJhbWVTdWJtaXR0ZWQoKXt0aGlzLnRvdGFsRnJhbWVzKz0xfXJlc2V0RnJhbWVDb3VudHMoKXt0aGlzLnRvdGFsRnJhbWVzPTAsdGhpcy5wcmVzZW50ZWRGcmFtZXM9MH1wdXNoRGF0YShBKXt0aGlzLmRhdGFTaXplcy5wdXNoKEEuYnl0ZUxlbmd0aCk7Y29uc3QgZT0obmV3IERhdGUpLmdldFRpbWUoKTt0aGlzLmxhc3REYXRhVGltZXN0YW1wJiZ0aGlzLmRhdGFJbnRlcnZhbHMucHVzaChlLXRoaXMubGFzdERhdGFUaW1lc3RhbXApLHRoaXMubGFzdERhdGFUaW1lc3RhbXA9ZX1zZXRFbGVtZW50KEEpe3RoaXMuZWxlbWVudD1BfWdldFJlcG9ydCgpe2lmKCF0aGlzLmVsZW1lbnQpdGhyb3cgbmV3IGcuUmFpbndheUVycm9yKFwiZ2V0UmVwb3J0KCkgaGFzIG5vIHZpZGVvIGVsZW1lbnRcIik7Y29uc3QgQT10LmF2ZXJhZ2UoQXJyYXkuZnJvbSh0aGlzLnByb2Nlc3NpbmdEdXJhdGlvbnMudmFsdWVzKCkpKSxlPXRoaXMuZWxlbWVudC5idWZmZXJlZCxJPWUubGVuZ3RoPjA/ZS5lbmQoZS5sZW5ndGgtMSk6MCxpPXRoaXMuZWxlbWVudC5zZWVrYWJsZSxCPWkubGVuZ3RoPjA/aS5lbmQoaS5sZW5ndGgtMSk6MDtyZXR1cm57cHJvY2Vzc2luZ0R1cmF0aW9uOkEsZHJvcHBlZEZyYW1lczp0aGlzLnRvdGFsRnJhbWVzLXRoaXMucHJlc2VudGVkRnJhbWVzLHRvdGFsRnJhbWVzOnRoaXMudG90YWxGcmFtZXMsZGF0YUludGVydmFsOnQuYXZlcmFnZSh0aGlzLmRhdGFJbnRlcnZhbHMudmFsdWVzKCkpLGRhdGFTaXplOnQuYXZlcmFnZSh0aGlzLmRhdGFTaXplcy52YWx1ZXMoKSksY3VycmVudFRpbWU6dGhpcy5lbGVtZW50LmN1cnJlbnRUaW1lLGVuZE9mQnVmZmVyZWQ6SSxlbmRPZlNlZWthYmxlOkJ9fWNyZWF0ZVJlcG9ydChBLGUpe3JldHVybntwcm9jZXNzaW5nRHVyYXRpb246dC5hdmVyYWdlKEFycmF5LmZyb20odGhpcy5wcm9jZXNzaW5nRHVyYXRpb25zLnZhbHVlcygpKSksZHJvcHBlZEZyYW1lczpudWxsIT1BP0E6MCx0b3RhbEZyYW1lczpudWxsIT1lP2U6MCxkYXRhSW50ZXJ2YWw6dC5hdmVyYWdlKHRoaXMuZGF0YUludGVydmFscy52YWx1ZXMoKSksZGF0YVNpemU6dC5hdmVyYWdlKHRoaXMuZGF0YVNpemVzLnZhbHVlcygpKSxjdXJyZW50VGltZTowLGVuZE9mQnVmZmVyZWQ6MCxlbmRPZlNlZWthYmxlOjB9fX19LDY5MDA6ZnVuY3Rpb24oQSxlLEkpe1widXNlIHN0cmljdFwiO3ZhciBnPXRoaXMmJnRoaXMuX19hd2FpdGVyfHxmdW5jdGlvbihBLGUsSSxnKXtyZXR1cm4gbmV3KEl8fChJPVByb21pc2UpKSgoZnVuY3Rpb24odCxpKXtmdW5jdGlvbiBCKEEpe3RyeXtRKGcubmV4dChBKSl9Y2F0Y2goQSl7aShBKX19ZnVuY3Rpb24gQyhBKXt0cnl7UShnLnRocm93KEEpKX1jYXRjaChBKXtpKEEpfX1mdW5jdGlvbiBRKEEpe3ZhciBlO0EuZG9uZT90KEEudmFsdWUpOihlPUEudmFsdWUsZSBpbnN0YW5jZW9mIEk/ZTpuZXcgSSgoZnVuY3Rpb24oQSl7QShlKX0pKSkudGhlbihCLEMpfVEoKGc9Zy5hcHBseShBLGV8fFtdKSkubmV4dCgpKX0pKX07T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksZS5WaWRlb1N0cmVhbU1TRT12b2lkIDA7Y29uc3QgdD1JKDkwMjQpLGk9SSgxNjMzKSxCPUkoMjQzNCksQz1JKDM0NjQpLFE9SSg0NDQxKTtmdW5jdGlvbiBvKEEpe3JldHVybiAxMDI9PT1BWzRdJiYxMTY9PT1BWzVdJiYxMjE9PT1BWzZdJiYxMTI9PT1BWzddfWUuVmlkZW9TdHJlYW1NU0U9Y2xhc3N7Y29uc3RydWN0b3IoQSl7dGhpcy5jb2RlY1N0cmluZz1BLHRoaXMucmVhZHlTdGF0ZT1CLlZpZGVvUmVhZHlTdGF0ZS5EZXRhY2hlZCx0aGlzLm5lZWRzUmVzdGFydEV2ZW50PW5ldyB0LkFjdGlvbix0aGlzLnNvdXJjZU9wZW5FdmVudD1uZXcgdC5BY3Rpb24sdGhpcy5yZWFkeVN0YXRlQ2hhbmdlRXZlbnQ9bmV3IHQuQWN0aW9uLHRoaXMudmlkZW9GcmFtZUV2ZW50PW5ldyB0LkFjdGlvbix0aGlzLnZpZGVvRnJhbWVQcm9jZXNzaW5nRHVyYXRpb25FdmVudD1uZXcgdC5BY3Rpb24sdGhpcy5jYW5jZWxJbml0aWFsaXplRXZlbnQ9bmV3IHQuQWN0aW9uLHRoaXMuZGF0YVF1ZXVlPVtdLHRoaXMuc3RhdHM9bmV3IFEuVmlkZW9TdGF0cyx0aGlzLmp1c3RDbGVhcmVkQnVmZmVyPSExLHRoaXMubGFzdEJ1ZmZlckVuZD0wLHRoaXMuZnJhbWVzRnJvemVuRm9yPTAsdGhpcy5lbnN1cmVCdWZmZXI9KCk9PntpZih0aGlzLnJlYWR5U3RhdGUhPT1CLlZpZGVvUmVhZHlTdGF0ZS5QYXVzZWQmJnRoaXMucmVhZHlTdGF0ZSE9PUIuVmlkZW9SZWFkeVN0YXRlLkRldGFjaGVkJiZ0aGlzLmVsZW1lbnQmJjA9PT10aGlzLmVsZW1lbnQuYnVmZmVyZWQubGVuZ3RoKXtpZih0aGlzLnNvdXJjZUJ1ZmZlciYmIXRoaXMuc291cmNlQnVmZmVyLnVwZGF0aW5nJiZ0aGlzLnNvdXJjZUJ1ZmZlci50aW1lc3RhbXBPZmZzZXQ8PTApe2NvbnN0IEE9dGhpcy5zb3VyY2VCdWZmZXIudGltZXN0YW1wT2Zmc2V0LnRvRml4ZWQoMik7dGhpcy5zb3VyY2VCdWZmZXIudGltZXN0YW1wT2Zmc2V0PTE7Y29uc3QgZT10aGlzLnNvdXJjZUJ1ZmZlci50aW1lc3RhbXBPZmZzZXQudG9GaXhlZCgyKTt0aGlzLndhcm4oYFBva2VkIHRpbWVzdGFtcE9mZnNldCBmcm9tICR7QX0gdG8gJHtlfWApfXRoaXMucmVzdGFydChcImVuc3VyZUJ1ZmZlclwiKX19LHRoaXMudmlkZW9GcmFtZUhhbmRsZXI9KEEsZSk9PnsobnVsbD09ZT92b2lkIDA6ZS5wcm9jZXNzaW5nRHVyYXRpb24pJiZ0aGlzLnZpZGVvRnJhbWVQcm9jZXNzaW5nRHVyYXRpb25FdmVudC5pbnZva2UoZS5wcm9jZXNzaW5nRHVyYXRpb24pLGUmJnRoaXMuc3RhdHMucHVzaEZyYW1lTWV0YWRhdGEoZSksdGhpcy52aWRlb0ZyYW1lRXZlbnQuaW52b2tlKFtBLGVdKSx0aGlzLnJlcXVlc3ROZXh0RnJhbWVDYWxsYmFjaygpfSx0aGlzLmZhbGxiYWNrVmlkZW9GcmFtZUhhbmRsZXI9QT0+e3RoaXMudmlkZW9GcmFtZUhhbmRsZXIoQSx2b2lkIDApfSx0aGlzLnNvdXJjZUJ1ZmZlclVwZGF0ZUhhbmRsZXI9KCk9Pnt0aGlzLnN1Ym1pdERhdGEoKX19aW5mbyhBKXtDLlJhaW53YXlMb2dnaW5nLmluZm9ybWF0aW9uKGBbVmlkZW9TdHJlYW1dICR7U3RyaW5nKEEpfWApfWRlYnVnKEEpe0MuUmFpbndheUxvZ2dpbmcuZGVidWcoYFtWaWRlb1N0cmVhbV0gJHtTdHJpbmcoQSl9YCl9d2FybihBKXtDLlJhaW53YXlMb2dnaW5nLndhcm5pbmcoYFtWaWRlb1N0cmVhbV0gJHtTdHJpbmcoQSl9YCl9Z2V0IGRhdGFRdWV1ZUxlbmd0aCgpe3JldHVybiB0aGlzLmRhdGFRdWV1ZS5sZW5ndGh9YXR0YWNoVG9FbGVtZW50KEEpe3RoaXMuaW5mbyhcIkF0dGFjaGluZyB0byBlbGVtZW50OiBcIitBKSx0aGlzLmNhbmNlbEluaXRpYWxpemVFdmVudC5pbnZva2UoKSx0aGlzLmVsZW1lbnQ9QSx0aGlzLnN0YXRzLnNldEVsZW1lbnQodGhpcy5lbGVtZW50KSx0aGlzLnN0YXRzLnJlc2V0RnJhbWVDb3VudHMoKSx0aGlzLnJlc3RhcnQoXCJhdHRhY2hUb0VsZW1lbnRcIiksdGhpcy5pbmZvKFwiQXR0YWNoZWQgdG8gZWxlbWVudC5cIil9ZGV0YWNoRnJvbUVsZW1lbnQoKXt0aGlzLmRlc3Ryb3lNZWRpYSgpLHRoaXMuZWxlbWVudD12b2lkIDAsdGhpcy5zZXRSZWFkeVN0YXRlKEIuVmlkZW9SZWFkeVN0YXRlLkRldGFjaGVkKSx0aGlzLmluZm8oXCJEZXRhY2hlZCBmcm9tIGVsZW1lbnQuXCIpfXBhdXNlKCl7dGhpcy5zZXRSZWFkeVN0YXRlKEIuVmlkZW9SZWFkeVN0YXRlLlBhdXNlZCl9cGxheSgpe3RoaXMucmVhZHlTdGF0ZT09PUIuVmlkZW9SZWFkeVN0YXRlLlBhdXNlZCYmdGhpcy5yZXN0YXJ0KFwicGxheVwiKX1wdXNoRGF0YShBLGUpe2lmKHRoaXMuZGF0YVF1ZXVlLmxlbmd0aD44KXJldHVybiB2b2lkIHRoaXMucmVzdGFydChcInB1c2hEYXRhLmRhdGFRdWV1ZSB0b28gbG9uZ1wiKTtjb25zdCBJPW5ldyBVaW50OEFycmF5KGUpO3JldHVybiB0aGlzLnN0YXRzLnB1c2hEYXRhKEkpLHRoaXMucmVhZHlTdGF0ZSE9PUIuVmlkZW9SZWFkeVN0YXRlLlBhdXNlZD9vKEkpJiZ0aGlzLnJlYWR5U3RhdGU9PT1CLlZpZGVvUmVhZHlTdGF0ZS5XYWl0aW5nRm9yS2V5ZnJhbWUmJnRoaXMuZWxlbWVudD8odGhpcy5kZWJ1ZyhgR290IHJlcXVlc3RlZCBrZXlmcmFtZSAoJHtJLmxlbmd0aH0gYnl0ZXMpYCksdGhpcy5nZXRTdGF0cygpLHRoaXMuZGF0YVF1ZXVlLnB1c2goSSksdGhpcy5zdWJtaXREYXRhKCksdm9pZCB0aGlzLmluaXRpYWxpemVNZWRpYSgpKTp2b2lkKHRoaXMucmVhZHlTdGF0ZSE9PUIuVmlkZW9SZWFkeVN0YXRlLldhaXRpbmdGb3JLZXlmcmFtZSYmdGhpcy5lbGVtZW50Pyh0aGlzLmRhdGFRdWV1ZS5wdXNoKEkpLHRoaXMuc3VibWl0RGF0YSgpKTp0aGlzLnN0YXJ0RW5zdXJpbmdCdWZmZXIoKSk6dm9pZCAwfWdldFN0YXRzKCl7cmV0dXJuIHRoaXMuc3RhdHMuZ2V0UmVwb3J0KCl9c2V0UmVhZHlTdGF0ZShBKXt0aGlzLmluZm8oYFJlYWR5U3RhdGUgY2hhbmdlZDogJHtCLlZpZGVvUmVhZHlTdGF0ZVt0aGlzLnJlYWR5U3RhdGVdfSA9PiAke0IuVmlkZW9SZWFkeVN0YXRlW0FdfWApLHRoaXMucmVhZHlTdGF0ZT1BLHRoaXMucmVhZHlTdGF0ZUNoYW5nZUV2ZW50Lmludm9rZShBKX1zdWJtaXREYXRhKCl7aWYoMCE9PXRoaXMuZGF0YVF1ZXVlLmxlbmd0aClpZih2b2lkIDAhPT10aGlzLm1lZGlhU291cmNlKWlmKHRoaXMuc291cmNlQnVmZmVyKXtpZighdGhpcy5zb3VyY2VCdWZmZXIudXBkYXRpbmcpaWYodGhpcy5lbGVtZW50KXtpZih0aGlzLnNvdXJjZUJ1ZmZlci5idWZmZXJlZC5sZW5ndGg+PTEpe2NvbnN0IEE9dGhpcy5zb3VyY2VCdWZmZXIuYnVmZmVyZWQuZW5kKHRoaXMuc291cmNlQnVmZmVyLmJ1ZmZlcmVkLmxlbmd0aC0xKTt0aGlzLmp1c3RDbGVhcmVkQnVmZmVyJiYodGhpcy5lbGVtZW50LmN1cnJlbnRUaW1lPUEsdGhpcy5qdXN0Q2xlYXJlZEJ1ZmZlcj0hMSksQT09PXRoaXMubGFzdEJ1ZmZlckVuZD8odGhpcy5mcmFtZXNGcm96ZW5Gb3IrKyx0aGlzLmRlYnVnKGBGcm96ZW4gZm9yICR7dGhpcy5mcmFtZXNGcm96ZW5Gb3J9IGZyYW1lcy4uLmApKTp0aGlzLmZyYW1lc0Zyb3plbkZvcj0wLHRoaXMubGFzdEJ1ZmZlckVuZD1BfWlmKHRoaXMuZnJhbWVzRnJvemVuRm9yPj00KXJldHVybiB0aGlzLnJlc3RhcnQoXCJzb3VyY2VCdWZmZXIgRnJvemVuRnJhbWVzXCIpLHZvaWQodGhpcy5mcmFtZXNGcm96ZW5Gb3I9MCk7dHJ5e2NvbnN0IEE9dGhpcy5kYXRhUXVldWVbMF07aWYobyhBKSYmIXRoaXMuanVzdENsZWFyZWRCdWZmZXIpcmV0dXJuIHRoaXMuZGVidWcoXCJHb3Qga2V5ZnJhbWUuIENsZWFyaW5nIHNvdXJjZWJ1ZmZlci5cIiksdGhpcy5nZXRTdGF0cygpLHRoaXMuc291cmNlQnVmZmVyLnJlbW92ZSgwLDEvMCksdm9pZCh0aGlzLmp1c3RDbGVhcmVkQnVmZmVyPSEwKTt0aGlzLmRhdGFRdWV1ZS5zaGlmdCgpLHRoaXMuc291cmNlQnVmZmVyLmFwcGVuZEJ1ZmZlcihBKSx0aGlzLnN0YXRzLnJlcG9ydEZyYW1lU3VibWl0dGVkKCl9Y2F0Y2goQSl7Qy5SYWlud2F5TG9nZ2luZy5lcnJvcihTdHJpbmcoQSkpLHRoaXMucmVzdGFydChcInN1Ym1pdERhdGEsIHNvdXJjZUJ1ZmZlci5hcHBlbmRCdWZmZXIgZXJyb3IuXCIpfX1lbHNlIHRoaXMuZGVidWcoXCJJZGxpbmcgYmVjYXVzZSAhZWxlbWVudFwiKX1lbHNlIHRoaXMuZGVidWcoXCJJZGxpbmcgYmVjYXVzZSAhc291cmNlQnVmZmVyXCIpO2Vsc2UgdGhpcy5kZWJ1ZyhcIklkbGluZyBiZWNhdXNlIG1lZGlhU291cmNlID09PSB1bmRlZmluZWRcIil9aW5pdGlhbGl6ZU1lZGlhKCl7dmFyIEEsZTtyZXR1cm4gZyh0aGlzLHZvaWQgMCx2b2lkIDAsKGZ1bmN0aW9uKigpe2lmKHRoaXMuc2V0UmVhZHlTdGF0ZShCLlZpZGVvUmVhZHlTdGF0ZS5Jbml0aWFsaXppbmcpLHRoaXMuY2FuY2VsSW5pdGlhbGl6ZUV2ZW50Lmludm9rZSgpLHZvaWQgMCE9PXRoaXMubWVkaWFTb3VyY2UpcmV0dXJuIHRoaXMuc2V0UmVhZHlTdGF0ZShCLlZpZGVvUmVhZHlTdGF0ZS5QbGF5aW5nKSx2b2lkKG51bGw9PT0oQT10aGlzLmVsZW1lbnQpfHx2b2lkIDA9PT1BfHxBLnBsYXkoKSk7aWYoIXRoaXMuZWxlbWVudCl0aHJvdyBuZXcgRXJyb3IoXCJTdHJlYW0gbm90IGF0dGFjaGVkIHRvIGVsZW1lbnQuXCIpO3RyeXtjb25zdCBBPXlpZWxkIGkuY3JlYXRlTWVkaWFTb3VyY2UodGhpcy5lbGVtZW50LHRoaXMuY2FuY2VsSW5pdGlhbGl6ZUV2ZW50KTtpZighQSlyZXR1cm4gdm9pZCB0aGlzLnNldFJlYWR5U3RhdGUoQi5WaWRlb1JlYWR5U3RhdGUuV2FpdGluZ0ZvcktleWZyYW1lKTt0aGlzLm1lZGlhU291cmNlPUEsdGhpcy5zb3VyY2VCdWZmZXI9aS5jcmVhdGVTb3VyY2VCdWZmZXIodGhpcy5tZWRpYVNvdXJjZSx0aGlzLmNvZGVjU3RyaW5nKSx0aGlzLnNvdXJjZUJ1ZmZlci5hZGRFdmVudExpc3RlbmVyKFwidXBkYXRlZW5kXCIsdGhpcy5zb3VyY2VCdWZmZXJVcGRhdGVIYW5kbGVyKSx0aGlzLnNvdXJjZUJ1ZmZlci5hZGRFdmVudExpc3RlbmVyKFwiZXJyb3JcIiwoQT0+Y29uc29sZS5lcnJvcihcInNvdXJjZUJ1ZmZlciBlcnJvcjpcIixBKSkpLHRoaXMuc3RhcnRFbnN1cmluZ0J1ZmZlcigpLHRoaXMuc2V0UmVhZHlTdGF0ZShCLlZpZGVvUmVhZHlTdGF0ZS5QbGF5aW5nKSx0aGlzLnJlcXVlc3ROZXh0RnJhbWVDYWxsYmFjaygpLHRoaXMuc3VibWl0RGF0YSgpLG51bGw9PT0oZT10aGlzLmVsZW1lbnQpfHx2b2lkIDA9PT1lfHxlLnBsYXkoKX1jYXRjaChBKXt0aGlzLnNldFJlYWR5U3RhdGUoQi5WaWRlb1JlYWR5U3RhdGUuV2FpdGluZ0ZvcktleWZyYW1lKX19KSl9c3RhcnRFbnN1cmluZ0J1ZmZlcigpe3ZvaWQgMD09PXRoaXMuZW5zdXJlQnVmZmVySW50ZXJ2YWwmJih0aGlzLmRlYnVnKFwiU3RhcnRpbmcgZW5zdXJlQnVmZmVyIGxvb3BcIiksdGhpcy5lbnN1cmVCdWZmZXJJbnRlcnZhbD13aW5kb3cuc2V0SW50ZXJ2YWwodGhpcy5lbnN1cmVCdWZmZXIsMWUzKSl9ZGVzdHJveU1lZGlhKCl7dmFyIEEsZTtpZih0aGlzLmRlYnVnKFwiZGVzdHJveU1lZGlhKCkgY2FsbGVkXCIpLHZvaWQgMCE9PXRoaXMubWVkaWFTb3VyY2Upe2lmKHRoaXMuY2FuY2VsRnJhbWVDYWxsYmFjaygpLG51bGw9PT0oQT10aGlzLmVsZW1lbnQpfHx2b2lkIDA9PT1BfHxBLnBhdXNlKCksbnVsbD09PShlPXRoaXMuc291cmNlQnVmZmVyKXx8dm9pZCAwPT09ZXx8ZS5yZW1vdmVFdmVudExpc3RlbmVyKFwidXBkYXRlZW5kXCIsdGhpcy5zb3VyY2VCdWZmZXJVcGRhdGVIYW5kbGVyKSx0aGlzLm1lZGlhU291cmNlKXtpZih0aGlzLnNvdXJjZUJ1ZmZlcil7dHJ5e3RoaXMubWVkaWFTb3VyY2UucmVtb3ZlU291cmNlQnVmZmVyKHRoaXMuc291cmNlQnVmZmVyKX1jYXRjaChBKXt9dGhpcy5zb3VyY2VCdWZmZXI9dm9pZCAwfWlmKFwib3BlblwiPT09dGhpcy5tZWRpYVNvdXJjZS5yZWFkeVN0YXRlKXRyeXt0aGlzLm1lZGlhU291cmNlLmVuZE9mU3RyZWFtKCl9Y2F0Y2goQSl7fXRoaXMubWVkaWFTb3VyY2U9dm9pZCAwLHRoaXMuZWxlbWVudCYmd2luZG93LlVSTC5yZXZva2VPYmplY3RVUkwodGhpcy5lbGVtZW50LnNyYyl9d2luZG93LmNsZWFySW50ZXJ2YWwodGhpcy5lbnN1cmVCdWZmZXJJbnRlcnZhbCksdGhpcy5lbnN1cmVCdWZmZXJJbnRlcnZhbD12b2lkIDAsdGhpcy5zZXRSZWFkeVN0YXRlKEIuVmlkZW9SZWFkeVN0YXRlLldhaXRpbmdGb3JLZXlmcmFtZSl9fXJlc3RhcnQoQT1cIlwiKXtjb25zdCBlPUE/YFJlc3RhcnRpbmcgVmlkZW8gU3RyZWFtLi4uIFJlYXNvbjogJyR7QX0nLmA6XCJSZXN0YXJ0aW5nIFZpZGVvIFN0cmVhbS5cIjt0aGlzLndhcm4oZSksdGhpcy5kYXRhUXVldWU9W10sdGhpcy5zZXRSZWFkeVN0YXRlKEIuVmlkZW9SZWFkeVN0YXRlLldhaXRpbmdGb3JLZXlmcmFtZSksdGhpcy5uZWVkc1Jlc3RhcnRFdmVudC5pbnZva2UoKX1yZXF1ZXN0TmV4dEZyYW1lQ2FsbGJhY2soKXt2YXIgQSxlLEksZztcInJlcXVlc3RWaWRlb0ZyYW1lQ2FsbGJhY2tcImluIEhUTUxWaWRlb0VsZW1lbnQucHJvdG90eXBlPyh0aGlzLmZyYW1lSGFuZGxlJiYobnVsbD09PShlPW51bGw9PT0oQT10aGlzLmVsZW1lbnQpfHx2b2lkIDA9PT1BP3ZvaWQgMDpBLmNhbmNlbFZpZGVvRnJhbWVDYWxsYmFjayl8fHZvaWQgMD09PWV8fGUuY2FsbChBLHRoaXMuZnJhbWVIYW5kbGUpLHRoaXMuZnJhbWVIYW5kbGU9dm9pZCAwKSx0aGlzLmZyYW1lSGFuZGxlPW51bGw9PT0oZz1udWxsPT09KEk9dGhpcy5lbGVtZW50KXx8dm9pZCAwPT09ST92b2lkIDA6SS5yZXF1ZXN0VmlkZW9GcmFtZUNhbGxiYWNrKXx8dm9pZCAwPT09Zz92b2lkIDA6Zy5jYWxsKEksdGhpcy52aWRlb0ZyYW1lSGFuZGxlcikpOih0aGlzLmZyYW1lSGFuZGxlJiYod2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMuZnJhbWVIYW5kbGUpLHRoaXMuZnJhbWVIYW5kbGU9dm9pZCAwKSx0aGlzLmZyYW1lSGFuZGxlPXdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUodGhpcy5mYWxsYmFja1ZpZGVvRnJhbWVIYW5kbGVyKSl9Y2FuY2VsRnJhbWVDYWxsYmFjaygpe3ZhciBBLGU7XCJyZXF1ZXN0VmlkZW9GcmFtZUNhbGxiYWNrXCJpbiBIVE1MVmlkZW9FbGVtZW50LnByb3RvdHlwZT90aGlzLmZyYW1lSGFuZGxlJiYobnVsbD09PShlPW51bGw9PT0oQT10aGlzLmVsZW1lbnQpfHx2b2lkIDA9PT1BP3ZvaWQgMDpBLmNhbmNlbFZpZGVvRnJhbWVDYWxsYmFjayl8fHZvaWQgMD09PWV8fGUuY2FsbChBLHRoaXMuZnJhbWVIYW5kbGUpLHRoaXMuZnJhbWVIYW5kbGU9dm9pZCAwKTp0aGlzLmZyYW1lSGFuZGxlJiYod2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMuZnJhbWVIYW5kbGUpLHRoaXMuZnJhbWVIYW5kbGU9dm9pZCAwKX1kaXNwb3NlKCl7dGhpcy5jYW5jZWxGcmFtZUNhbGxiYWNrKCksdGhpcy5kZXN0cm95TWVkaWEoKSx3aW5kb3cuY2xlYXJJbnRlcnZhbCh0aGlzLmVuc3VyZUJ1ZmZlckludGVydmFsKSx0aGlzLnNldFJlYWR5U3RhdGUoQi5WaWRlb1JlYWR5U3RhdGUuRGlzcG9zZWQpfX19LDIxNDY6ZnVuY3Rpb24oQSxlLEkpe1widXNlIHN0cmljdFwiO3ZhciBnPXRoaXMmJnRoaXMuX19pbXBvcnREZWZhdWx0fHxmdW5jdGlvbihBKXtyZXR1cm4gQSYmQS5fX2VzTW9kdWxlP0E6e2RlZmF1bHQ6QX19O09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLGUuVmlkZW9TdHJlYW1Tb2Z0d2FyZURlY29kZXI9dm9pZCAwO2NvbnN0IHQ9SSgyNDM0KSxpPUkoOTAyNCksQj1JKDQ0MjUpLEM9ZyhJKDg4NTkpKSxRPWcoSSg3NTYpKSxvPWcoSSgzMzQ2KSksbj1JKDM0NjQpLGE9SSg0NDQxKTtlLlZpZGVvU3RyZWFtU29mdHdhcmVEZWNvZGVyPWNsYXNze2NvbnN0cnVjdG9yKEEsZSl7dGhpcy5jb2RlY1N0cmluZz1BLHRoaXMuZm9ybWF0PWUsdGhpcy5yZWFkeVN0YXRlPXQuVmlkZW9SZWFkeVN0YXRlLkRldGFjaGVkLHRoaXMubmVlZHNSZXN0YXJ0RXZlbnQ9bmV3IGkuQWN0aW9uLHRoaXMucmVhZHlTdGF0ZUNoYW5nZUV2ZW50PW5ldyBpLkFjdGlvbix0aGlzLnZpZGVvRnJhbWVQcm9jZXNzaW5nRHVyYXRpb25FdmVudD1uZXcgaS5BY3Rpb24sdGhpcy52aWRlb0ZyYW1lRXZlbnQ9bmV3IGkuQWN0aW9uLHRoaXMuY3VycmVudEZyYW1lSW5mbz17Y29udGFpbnNTUFM6ITEsY29udGFpbnNQUFM6ITEsY29udGFpbnNGcmFtZURhdGE6ITB9LHRoaXMucGF1c2VkPSExLHRoaXMuc3RhdHM9bmV3IGEuVmlkZW9TdGF0cyx0aGlzLnRvdGFsRnJhbWVzPTAsdGhpcy53YWl0aW5nVG9EZWNvZGVRdWV1ZT1bXSx0aGlzLmRlY29kZVF1ZXVlPVtdLHRoaXMubWF4RGVjb2RlUXVldWVTaXplPTMsdGhpcy5tYXhMYXRlbmN5RnJhbWVDb3VudD03LHRoaXMubWF4Q29uc2VjdXRpdmVGcmFtZXNEcm9wcz0zLHRoaXMuZnJhbWVzRHJvcHBlZFNpbmNlTGFzdFJlbmRlcj0wLHRoaXMudG90YWxGcmFtZXNEcm9wcGVkPTAsdGhpcy5jYW52YXM9dm9pZCAwLHRoaXMuc2hhZGVyPXZvaWQgMCx0aGlzLnlUZXh0dXJlPXZvaWQgMCx0aGlzLnVUZXh0dXJlPXZvaWQgMCx0aGlzLnZUZXh0dXJlPXZvaWQgMCx0aGlzLm9uRGVjb2RlPSh7d2lkdGg6QSxoZWlnaHQ6ZSxkYXRhOkl9KT0+e2lmKDA9PXRoaXMuZGVjb2RlUXVldWUubGVuZ3RoKXJldHVybiBuLlJhaW53YXlMb2dnaW5nLmVycm9yKFwiW1ZpZGVvU3RyZWFtU29mdHdhcmVEZWNvZGVyXSBvbkRlY29kZSBjYWxsZWQgd2l0aCBlbXB0eSBkZWNvZGVyIHF1ZXVlIVwiKSx2b2lkIHRoaXMuc2VuZERlY29kZXJXYWl0aW5nVG9EZWNvZGVGcmFtZXMoKTsrK3RoaXMudG90YWxGcmFtZXM7Y29uc3QgZz10aGlzLmRlY29kZVF1ZXVlLnNoaWZ0KCk7aWYoIXRoaXMucGF1c2VkKXtjb25zdCB0PURhdGUubm93KCk7aWYoZy5wcm9jZXNzaW5nRHVyYXRpb249KHQtZy5tZWRpYVRpbWUpLzFlMyx0aGlzLnZpZGVvRnJhbWVQcm9jZXNzaW5nRHVyYXRpb25FdmVudC5pbnZva2UoZy5wcm9jZXNzaW5nRHVyYXRpb24pLHRoaXMuZGF0YVF1ZXVlTGVuZ3RoPnRoaXMubWF4TGF0ZW5jeUZyYW1lQ291bnQmJnRoaXMuZnJhbWVzRHJvcHBlZFNpbmNlTGFzdFJlbmRlcjx0aGlzLm1heENvbnNlY3V0aXZlRnJhbWVzRHJvcHMpKyt0aGlzLmZyYW1lc0Ryb3BwZWRTaW5jZUxhc3RSZW5kZXIsKyt0aGlzLnRvdGFsRnJhbWVzRHJvcHBlZDtlbHNle3RoaXMuZnJhbWVzRHJvcHBlZFNpbmNlTGFzdFJlbmRlcj0wO2NvbnN0IHQ9Zy53aWR0aCxpPWcuaGVpZ2h0O2cud2lkdGg9QSxnLmhlaWdodD1lLHRoaXMuc3RhdHMucHVzaEZyYW1lTWV0YWRhdGEoZyksdGhpcy5yZW5kZXJGcmFtZSh0LGksSSxBLGUpLHRoaXMudmlkZW9GcmFtZUV2ZW50Lmludm9rZShbcGVyZm9ybWFuY2Uubm93KCksZ10pfX10aGlzLnNlbmREZWNvZGVyV2FpdGluZ1RvRGVjb2RlRnJhbWVzKCl9LHRoaXMuZW5zdXJlQnVmZmVyPSgpPT57dGhpcy5yZWFkeVN0YXRlPT09dC5WaWRlb1JlYWR5U3RhdGUuV2FpdGluZ0ZvcktleWZyYW1lJiYwPT09dGhpcy5kYXRhUXVldWVMZW5ndGgmJihuLlJhaW53YXlMb2dnaW5nLmRlYnVnKFwiU2VuZGluZyBhbm90aGVyIHJlcXVlc3QgZm9yIGEga2V5ZnJhbWUuXCIpLHRoaXMucmVzdGFydCgpKX0sdGhpcy52aWRlb0Zvcm1hdD1lLHRoaXMuZGVjb2Rlcldvcmtlcj1uZXcgQy5kZWZhdWx0LHRoaXMuZGVjb2Rlcldvcmtlci5pbml0aWFsaXplKCksdGhpcy5kZWNvZGVyV29ya2VyLm9uRGVjb2RlPXRoaXMub25EZWNvZGUuYmluZCh0aGlzKSx0aGlzLmVuc3VyZUJ1ZmZlckludGVydmFsPXdpbmRvdy5zZXRJbnRlcnZhbCh0aGlzLmVuc3VyZUJ1ZmZlciwxZTMpfWdldCBkYXRhUXVldWVMZW5ndGgoKXtyZXR1cm4gdGhpcy53YWl0aW5nVG9EZWNvZGVRdWV1ZS5sZW5ndGgrdGhpcy5kZWNvZGVRdWV1ZS5sZW5ndGh9Y29uZmlndXJlKEEsZSxJKXt0aGlzLm1heERlY29kZVF1ZXVlU2l6ZT1BLHRoaXMubWF4TGF0ZW5jeUZyYW1lQ291bnQ9ZSx0aGlzLm1heENvbnNlY3V0aXZlRnJhbWVzRHJvcHM9SX1hdHRhY2hUb0VsZW1lbnQoQSl7dGhpcy5zdGF0cy5yZXNldEZyYW1lQ291bnRzKCksdGhpcy5yZWFkeVN0YXRlIT10LlZpZGVvUmVhZHlTdGF0ZS5XYWl0aW5nRm9yS2V5ZnJhbWUmJnRoaXMucmVzdGFydCgpfWF0dGFjaFRvQ2FudmFzKEEpe3RoaXMucmVhZHlTdGF0ZSE9dC5WaWRlb1JlYWR5U3RhdGUuV2FpdGluZ0ZvcktleWZyYW1lJiZ0aGlzLnJlc3RhcnQoKSx0aGlzLmNhbnZhcyYmdGhpcy5kZXRhY2hGcm9tQ2FudmFzKCksdGhpcy5jYW52YXM9QTtjb25zdCBlPUEuZ2V0Q29udGV4dChcIndlYmdsXCIpO3RoaXMuc2hhZGVyPVEuZGVmYXVsdC5jcmVhdGUoZSksdGhpcy55VGV4dHVyZT1vLmRlZmF1bHQuY3JlYXRlKGUpLHRoaXMudVRleHR1cmU9by5kZWZhdWx0LmNyZWF0ZShlKSx0aGlzLnZUZXh0dXJlPW8uZGVmYXVsdC5jcmVhdGUoZSl9ZGV0YWNoRnJvbUVsZW1lbnQoKXt0aGlzLnNldFJlYWR5U3RhdGUodC5WaWRlb1JlYWR5U3RhdGUuRGV0YWNoZWQpfWRldGFjaEZyb21DYW52YXMoKXt0aGlzLmRlY29kZXJXb3JrZXIucmVsZWFzZSgpLHRoaXMueVRleHR1cmUmJnRoaXMueVRleHR1cmUuZGVsZXRlKCksdGhpcy51VGV4dHVyZSYmdGhpcy51VGV4dHVyZS5kZWxldGUoKSx0aGlzLnZUZXh0dXJlJiZ0aGlzLnZUZXh0dXJlLmRlbGV0ZSgpLHRoaXMuY2FudmFzPXZvaWQgMH1wYXVzZSgpe3RoaXMucGF1c2VkPSEwLHRoaXMuc2V0UmVhZHlTdGF0ZSh0LlZpZGVvUmVhZHlTdGF0ZS5QYXVzZWQpfXBsYXkoKXt0aGlzLnBhdXNlZCYmKHRoaXMucGF1c2VkPSExLHRoaXMucmVzdGFydCgpKX1yZXN0YXJ0KCl7dGhpcy50b3RhbEZyYW1lcz0wLHRoaXMudG90YWxGcmFtZXNEcm9wcGVkPTAsdGhpcy5mcmFtZXNEcm9wcGVkU2luY2VMYXN0UmVuZGVyPTAsdGhpcy53YWl0aW5nVG9EZWNvZGVRdWV1ZT1bXSx0aGlzLnNldFJlYWR5U3RhdGUodC5WaWRlb1JlYWR5U3RhdGUuV2FpdGluZ0ZvcktleWZyYW1lKSx0aGlzLm5lZWRzUmVzdGFydEV2ZW50Lmludm9rZSgpfXB1c2hEYXRhKEEsZSl7dmFyIEksZyxpO2lmKHRoaXMuc3RhdHMucHVzaERhdGEoZSksdGhpcy5wYXVzZWQpcmV0dXJuO2NvbnN0IEM9bmV3IFVpbnQ4QXJyYXkoZSk7bGV0IFE9ITE7aWYodGhpcy52aWRlb0Zvcm1hdD09Qi5SYWlud2F5VmlkZW9Gb3JtYXQuTGVuZ3RoUHJlZml4ZWQ/UT10aGlzLmNvbnZlcnRUb0FubmV4YkZvcm1hdChDKTp0aGlzLnJlYWR5U3RhdGU9PXQuVmlkZW9SZWFkeVN0YXRlLldhaXRpbmdGb3JLZXlmcmFtZSYmKFE9dGhpcy5wYXJzZUFubmV4YkZyYW1lSW5mbyhDKSksdGhpcy5yZWFkeVN0YXRlPT10LlZpZGVvUmVhZHlTdGF0ZS5XYWl0aW5nRm9yS2V5ZnJhbWUpaWYoUSl0aGlzLnNldFJlYWR5U3RhdGUodC5WaWRlb1JlYWR5U3RhdGUuUGxheWluZyk7ZWxzZSBpZighKG51bGw9PT0oST10aGlzLmN1cnJlbnRGcmFtZUluZm8pfHx2b2lkIDA9PT1JP3ZvaWQgMDpJLmNvbnRhaW5zRnJhbWVEYXRhKSlyZXR1cm4oKG51bGw9PT0oZz10aGlzLmN1cnJlbnRGcmFtZUluZm8pfHx2b2lkIDA9PT1nP3ZvaWQgMDpnLmNvbnRhaW5zU1BTKXx8KG51bGw9PT0oaT10aGlzLmN1cnJlbnRGcmFtZUluZm8pfHx2b2lkIDA9PT1pP3ZvaWQgMDppLmNvbnRhaW5zUFBTKSkmJnRoaXMuZGVjb2Rlcldvcmtlci5kZWNvZGUoQyksdGhpcy5jdXJyZW50RnJhbWVJbmZvLmNvbnRhaW5zU1BTPSExLHRoaXMuY3VycmVudEZyYW1lSW5mby5jb250YWluc1BQUz0hMSx2b2lkKHRoaXMuY3VycmVudEZyYW1lSW5mby5jb250YWluc0ZyYW1lRGF0YT0hMCk7aWYodGhpcy5yZWFkeVN0YXRlIT10LlZpZGVvUmVhZHlTdGF0ZS5XYWl0aW5nRm9yS2V5ZnJhbWUmJnRoaXMuY3VycmVudEZyYW1lSW5mby5jb250YWluc0ZyYW1lRGF0YSl7Y29uc3QgZT17d2lkdGg6QS53aWR0aCxoZWlnaHQ6QS5oZWlnaHQsbWVkaWFUaW1lOkRhdGUubm93KCkscHJvY2Vzc2luZ0R1cmF0aW9uOjAsZXhwZWN0ZWREaXNwbGF5VGltZTowLHByZXNlbnRhdGlvblRpbWU6MCxwcmVzZW50ZWRGcmFtZXM6MH07dGhpcy5kZWNvZGUoZSxDKX19Y29udmVydFRvQW5uZXhiRm9ybWF0KEEpe2xldCBlPSExO3RoaXMuY3VycmVudEZyYW1lSW5mby5jb250YWluc0ZyYW1lRGF0YT0hMTtmb3IobGV0IEk9MDtJPEEubGVuZ3RoOyl7Y29uc3QgZz10aGlzLm50b2hsKEEsSSk7QVtJXT0wLEFbKytJXT0wLEFbKytJXT0wLEFbKytJXT0xLCsrSTtjb25zdCB0PTMxJkFbSV07dDw9NSYmdD49MT8oZT01PT10LHRoaXMuY3VycmVudEZyYW1lSW5mby5jb250YWluc0ZyYW1lRGF0YT0hMCk6Nz09dD90aGlzLmN1cnJlbnRGcmFtZUluZm8uY29udGFpbnNTUFM9ITA6OD09dCYmKHRoaXMuY3VycmVudEZyYW1lSW5mby5jb250YWluc1BQUz0hMCksSSs9Z31yZXR1cm4gZX1udG9obChBLGUpe3JldHVybigyNTUmQVtlXSk8PDI0fCgyNTUmQVtlKzFdKTw8MTZ8KDI1NSZBW2UrMl0pPDw4fDI1NSZBW2UrM119cGFyc2VBbm5leGJGcmFtZUluZm8oQSl7bGV0IGU9ITE7dGhpcy5jdXJyZW50RnJhbWVJbmZvLmNvbnRhaW5zRnJhbWVEYXRhPSExO2ZvcihsZXQgST0wO0k8QS5sZW5ndGg7KWlmKDA9PUFbSV0mJjA9PUFbSSsxXSl7bGV0IGc9MDtpZigxPT1BW0krMl0/KEkrPTMsZz0zMSZBW0ldKTowPT1BW0krMl0mJjE9PUFbSSszXT8oSSs9NCxnPTMxJkFbSV0pOisrSSxnPD01JiZnPj0xKXtpZih0aGlzLmN1cnJlbnRGcmFtZUluZm8uY29udGFpbnNGcmFtZURhdGE9ITAsNT09Zyl7ZT0hMDticmVha319ZWxzZSA3PT1nP3RoaXMuY3VycmVudEZyYW1lSW5mby5jb250YWluc1NQUz0hMDo4PT1nJiYodGhpcy5jdXJyZW50RnJhbWVJbmZvLmNvbnRhaW5zUFBTPSEwKX1lbHNlKytJO3JldHVybiBlfWRlY29kZShBLGUpezA9PXRoaXMuZGVjb2RlUXVldWUubGVuZ3RoPygwIT10aGlzLndhaXRpbmdUb0RlY29kZVF1ZXVlLmxlbmd0aCYmKG4uUmFpbndheUxvZ2dpbmcuZXJyb3IoXCJbVmlkZW9TdHJlYW1Tb2Z0d2FyZURlY29kZXJdIGVtcHR5IGRlY29kZXIgcXVldWUsIGJ1dCB3YWl0aW5nIHRvIGRlY29kZSBxdWV1ZSBub3QgZW1wdHkhXCIpLHRoaXMud2FpdGluZ1RvRGVjb2RlUXVldWU9W10pLHRoaXMuc2VuZFRvRGVjb2RlcihBLGUpKToodGhpcy53YWl0aW5nVG9EZWNvZGVRdWV1ZS5wdXNoKHttZXRhZGF0YTpBLGRhdGE6ZX0pLHRoaXMuZGVjb2RlUXVldWUubGVuZ3RoPHRoaXMubWF4RGVjb2RlUXVldWVTaXplJiZ0aGlzLnNlbmREZWNvZGVyV2FpdGluZ1RvRGVjb2RlRnJhbWVzKCkpfXNlbmREZWNvZGVyV2FpdGluZ1RvRGVjb2RlRnJhbWVzKCl7Zm9yKDt0aGlzLmRlY29kZVF1ZXVlLmxlbmd0aDx0aGlzLm1heERlY29kZVF1ZXVlU2l6ZSYmdGhpcy53YWl0aW5nVG9EZWNvZGVRdWV1ZS5sZW5ndGg+MDspe2NvbnN0IEE9dGhpcy53YWl0aW5nVG9EZWNvZGVRdWV1ZS5zaGlmdCgpO3RoaXMuc2VuZFRvRGVjb2RlcihBLm1ldGFkYXRhLEEuZGF0YSl9fXNlbmRUb0RlY29kZXIoQSxlKXt0aGlzLnN0YXRzLnJlcG9ydEZyYW1lU3VibWl0dGVkKCksdGhpcy5kZWNvZGVRdWV1ZS5wdXNoKEEpLHRoaXMuZGVjb2Rlcldvcmtlci5kZWNvZGUoZSl9cmVuZGVyRnJhbWUoQSxlLEksZyx0KXt0aGlzLmNhbnZhcy53aWR0aD1BLHRoaXMuY2FudmFzLmhlaWdodD1lO2NvbnN0IGk9bmV3IFVpbnQ4QXJyYXkoSSksQj1nKnQsQz1pLnN1YmFycmF5KDAsQiksUT1CPj4yLG89aS5zdWJhcnJheShCLEIrUSksbj1pLnN1YmFycmF5KEIrUSxCKzIqUSk7dGhpcy55VGV4dHVyZS51cGxvYWRCdWZmZXIoQyxnLHQpO2NvbnN0IGE9Zz4+MSxyPXQ+PjE7dGhpcy51VGV4dHVyZS51cGxvYWRCdWZmZXIobyxhLHIpLHRoaXMudlRleHR1cmUudXBsb2FkQnVmZmVyKG4sYSxyKSx0aGlzLnNoYWRlci5iaW5kSW5wdXRUZXh0dXJlcyh0aGlzLnlUZXh0dXJlLHRoaXMudVRleHR1cmUsdGhpcy52VGV4dHVyZSk7Y29uc3QgRT1BL2cscz1lL3Q7dGhpcy5zaGFkZXIudXBkYXRlKGcsdCxFLHMpLHRoaXMuc2hhZGVyLmRyYXcoKX1nZXRTdGF0cygpe3JldHVybiB0aGlzLnN0YXRzLmNyZWF0ZVJlcG9ydCh0aGlzLnRvdGFsRnJhbWVzRHJvcHBlZCx0aGlzLnRvdGFsRnJhbWVzKX1zZXRSZWFkeVN0YXRlKEEpe3RoaXMucmVhZHlTdGF0ZT1BLHRoaXMucmVhZHlTdGF0ZUNoYW5nZUV2ZW50Lmludm9rZShBKX1kaXNwb3NlKCl7bi5SYWlud2F5TG9nZ2luZy5kZWJ1ZyhcIkRpc3Bvc2luZyBWaWRlb1N0cmVhbVNvZnR3YXJlRGVjb2RlclwiKSx0aGlzLnJlYWR5U3RhdGU9dC5WaWRlb1JlYWR5U3RhdGUuRGlzcG9zZWQsdGhpcy5kZWNvZGVyV29ya2VyLnJlbGVhc2UoKSx0aGlzLmRlY29kZXJXb3JrZXIuZGlzcG9zZSgpLHdpbmRvdy5jbGVhckludGVydmFsKHRoaXMuZW5zdXJlQnVmZmVySW50ZXJ2YWwpfX19LDkxMDQ6ZnVuY3Rpb24oQSxlLEkpe1widXNlIHN0cmljdFwiO3ZhciBnLHQ9dGhpcyYmdGhpcy5fX2F3YWl0ZXJ8fGZ1bmN0aW9uKEEsZSxJLGcpe3JldHVybiBuZXcoSXx8KEk9UHJvbWlzZSkpKChmdW5jdGlvbih0LGkpe2Z1bmN0aW9uIEIoQSl7dHJ5e1EoZy5uZXh0KEEpKX1jYXRjaChBKXtpKEEpfX1mdW5jdGlvbiBDKEEpe3RyeXtRKGcudGhyb3coQSkpfWNhdGNoKEEpe2koQSl9fWZ1bmN0aW9uIFEoQSl7dmFyIGU7QS5kb25lP3QoQS52YWx1ZSk6KGU9QS52YWx1ZSxlIGluc3RhbmNlb2YgST9lOm5ldyBJKChmdW5jdGlvbihBKXtBKGUpfSkpKS50aGVuKEIsQyl9USgoZz1nLmFwcGx5KEEsZXx8W10pKS5uZXh0KCkpfSkpfSxpPXRoaXMmJnRoaXMuX19jbGFzc1ByaXZhdGVGaWVsZEdldHx8ZnVuY3Rpb24oQSxlKXtpZighZS5oYXMoQSkpdGhyb3cgbmV3IFR5cGVFcnJvcihcImF0dGVtcHRlZCB0byBnZXQgcHJpdmF0ZSBmaWVsZCBvbiBub24taW5zdGFuY2VcIik7cmV0dXJuIGUuZ2V0KEEpfSxCPXRoaXMmJnRoaXMuX19jbGFzc1ByaXZhdGVGaWVsZFNldHx8ZnVuY3Rpb24oQSxlLEkpe2lmKCFlLmhhcyhBKSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiYXR0ZW1wdGVkIHRvIHNldCBwcml2YXRlIGZpZWxkIG9uIG5vbi1pbnN0YW5jZVwiKTtyZXR1cm4gZS5zZXQoQSxJKSxJfTtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxlLkdhdGV3YXk9ZS5nZXRIYW5kc2hha2VEYXRhQmFzZTY0PWUuZ2V0UGVlcklkPWUuR2F0ZXdheVN0YXR1cz12b2lkIDA7Y29uc3QgQz1JKDI5MCksUT1JKDI5OTQpLG89SSgzNDY0KSxuPUkoNjkwNCksYT1JKDkwMjQpO3ZhciByO2Z1bmN0aW9uIEUoQSxlLEkpe2NvbnN0IGc9bi5HYXRld2F5SWRlbnRpdHkuZW5jb2RlKHtpZDpBLGFwaUtleTplLGV4dGVybmFsSWQ6SX0pO3JldHVybiBidG9hKFN0cmluZy5mcm9tQ2hhckNvZGUoLi4uZykpLnJlcGxhY2UoLz0qJC8sXCJcIikucmVwbGFjZSgvXFwrL2csXCItXCIpLnJlcGxhY2UoL1xcLy9nLFwiX1wiKX0hZnVuY3Rpb24oQSl7QVtBLk9wZW49MF09XCJPcGVuXCIsQVtBLkNsb3NlZD0xXT1cIkNsb3NlZFwifShyPWUuR2F0ZXdheVN0YXR1c3x8KGUuR2F0ZXdheVN0YXR1cz17fSkpLGUuZ2V0UGVlcklkPWZ1bmN0aW9uKEEpe3ZhciBlO3JldHVybiB0KHRoaXMsdm9pZCAwLHZvaWQgMCwoZnVuY3Rpb24qKCl7Y29uc3QgST15aWVsZCBDLmdldE9yZ2FuaXphdGlvbkluZm8oQSksZz1gcmFpbndheS1ob3N0bmFtZS0ke0kub3JnYW5pemF0aW9uSWQudG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDgsXCIwXCIpfS0ke0kudW5pdmVyc2VGbGFnfWAsdD1CaWdJbnQobnVsbCE9PShlPWxvY2FsU3RvcmFnZS5nZXRJdGVtKGcpKSYmdm9pZCAwIT09ZT9lOnlpZWxkIEMuZmV0Y2hOZXdQZWVySWQoKSk7cmV0dXJuIGxvY2FsU3RvcmFnZS5zZXRJdGVtKGcsdC50b1N0cmluZygpKSx0fSkpfSxlLmdldEhhbmRzaGFrZURhdGFCYXNlNjQ9RSxlLkdhdGV3YXk9Y2xhc3N7Y29uc3RydWN0b3IoQSxlLEksaSxCLEMsUT1cIndzczovL2dhdGV3YXkucmFpbndheS5uZXR3b3JrXCIpe3RoaXMub3duUGVlcklkPUEsdGhpcy5hcGlLZXk9ZSx0aGlzLmV4dGVybmFsSWQ9SSx0aGlzLmhhbmRsZVBlZXJJbmZvPWksdGhpcy5jb25uZWN0aW9uUmVxdWVzdEhhbmRsZXI9Qix0aGlzLmFkZEFjY2VwdGVkUGVlcj1DLHRoaXMuY29ubmVjdGlvbnM9bmV3IE1hcCx0aGlzLmNvbm5lY3Rpb25Mb3N0RXZlbnQ9bmV3IGEuQWN0aW9uLGcuc2V0KHRoaXMsci5DbG9zZWQpLHRoaXMuc3luY0tleT0wLHRoaXMucGVlcklkVG9FeHRlcm5hbElkPW5ldyBNYXAsdGhpcy5vbk1lc3NhZ2U9QT0+dCh0aGlzLHZvaWQgMCx2b2lkIDAsKGZ1bmN0aW9uKigpe3ZhciBlO2lmKHZvaWQgMCE9PXRoaXMuc29ja2V0JiZcIltvYmplY3QgQXJyYXlCdWZmZXJdXCI9PT1BLmRhdGEudG9TdHJpbmcoKSl7Y29uc3QgST1uLkdhdGV3YXlEYXRhZ3JhbS5kZWNvZGUobmV3IFVpbnQ4QXJyYXkoQS5kYXRhKSkse2hlYWRlcjp7c3luY0tleTpnfSxib2R5OnR9PUk7c3dpdGNoKHQuZGlzY3JpbWluYXRvcil7Y2FzZSBuLkdhdGV3YXlSZXF1ZXN0LmRpc2NyaW1pbmF0b3I6by5SYWlud2F5TG9nZ2luZy53YXJuaW5nKFwiZ290IEdhdGV3YXlSZXF1ZXN0PyEgaSBhbSBub3QgYSBnYXRld2F5LiBpZ25vcmluZ1wiKTticmVhaztjYXNlIG4uR2F0ZXdheVJlc3BvbnNlLmRpc2NyaW1pbmF0b3I6e2NvbnN0IEE9dC52YWx1ZS5ib2R5LnZhbHVlO28uUmFpbndheUxvZ2dpbmcudHJhY2UoXCJnb3QgR2F0ZXdheUhlbGxvXCIpLG51bGw9PT0oZT10aGlzLnJlc29sdmVDb25uZWN0VG9HYXRld2F5UHJvbWlzZSl8fHZvaWQgMD09PWV8fGUuY2FsbCh0aGlzLEEpO2JyZWFrfWNhc2Ugbi5HYXRld2F5QWxlcnQuZGlzY3JpbWluYXRvcjp7Y29uc3R7bGV2ZWw6QSxkZXNjcmlwdGlvbjplfT10LnZhbHVlO0E9PT1uLkdhdGV3YXlBbGVydExldmVsLkZhdGFsPyhvLlJhaW53YXlMb2dnaW5nLmVycm9yKFwiRmF0YWwgR2F0ZXdheUFsZXJ0OiBcIituLkdhdGV3YXlBbGVydERlc2NyaXB0aW9uW2VdKSx0aGlzLmRpZShlLFwiVGhlIGNvbm5lY3Rpb24gdG8gdGhlIFJhaW53YXkgc2VydmVyIGVuY291bnRlcmVkIGEgZmF0YWwgZXJyb3IuXCIpKTp0aGlzLm9uTm9uRmF0YWxBbGVydChnLGUpO2JyZWFrfWNhc2Ugbi5HYXRld2F5Rm9yd2FyZGFibGUuZGlzY3JpbWluYXRvcjp0aGlzLm9uRm9yd2FyZGFibGUoZyx0LnZhbHVlKX19fSkpLHRoaXMub25DbG9zZT1BPT57dGhpcy5kaWUoQSxcIlRoZSBjb25uZWN0aW9uIHRvIHRoZSBSYWlud2F5IHNlcnZlciB3YXMgY2xvc2VkLlwiKX0sdGhpcy5vbkVycm9yPUE9Pnt0aGlzLmRpZShBLFwiVGhlIGNvbm5lY3Rpb24gdG8gdGhlIFJhaW53YXkgc2VydmVyIHdhcyBsb3N0LlwiKX0sdGhpcy51cmw9UX1nZXQgc3RhdHVzKCl7cmV0dXJuIGkodGhpcyxnKX1jb25uZWN0KCl7dmFyIEE7cmV0dXJuIHQodGhpcyx2b2lkIDAsdm9pZCAwLChmdW5jdGlvbiooKXtyZXR1cm4gbnVsbCE9PShBPXRoaXMuY29ubmVjdFRvR2F0ZXdheVByb21pc2UpJiZ2b2lkIDAhPT1BP0E6dGhpcy5jb25uZWN0VG9HYXRld2F5UHJvbWlzZT1uZXcgUHJvbWlzZSgoKEEsZSk9Pnt0aGlzLnJlc29sdmVDb25uZWN0VG9HYXRld2F5UHJvbWlzZT1BLHRoaXMucmVqZWN0Q29ubmVjdFRvR2F0ZXdheVByb21pc2U9ZSx0aGlzLm9wZW4oKX0pKX0pKX1vcGVuKCl7cmV0dXJuIHQodGhpcyx2b2lkIDAsdm9pZCAwLChmdW5jdGlvbiooKXt0aGlzLnNvY2tldD15aWVsZCB0aGlzLm1ha2VXZWJTb2NrZXQodGhpcy51cmwpLG8uUmFpbndheUxvZ2dpbmcuZGVidWcoXCJHYXRld2F5OiBjb25uZWN0ZWQgV2ViU29ja2V0XCIpLHRoaXMuc29ja2V0LmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsdGhpcy5vbk1lc3NhZ2UpLHRoaXMuc29ja2V0LmFkZEV2ZW50TGlzdGVuZXIoXCJjbG9zZVwiLHRoaXMub25DbG9zZSksQih0aGlzLGcsci5PcGVuKX0pKX1tYWtlV2ViU29ja2V0KEEpe3JldHVybiBuZXcgUHJvbWlzZSgoKGUsSSk9Pntjb25zdCBnPW5ldyBXZWJTb2NrZXQoQSxbXCJoYW5kc2hha2VcIixFKHRoaXMub3duUGVlcklkLHRoaXMuYXBpS2V5LHRoaXMuZXh0ZXJuYWxJZCldKTtnLmJpbmFyeVR5cGU9XCJhcnJheWJ1ZmZlclwiLGcub25vcGVuPSgpPT57ZShnKX0sZy5vbmVycm9yPUE9Pnt0aGlzLm9uRXJyb3IoQSksSShBKSx0aGlzLmNvbm5lY3RUb0dhdGV3YXlQcm9taXNlPXZvaWQgMH19KSl9ZGlzY29ubmVjdCgpe3ZhciBBO2lmKG8uUmFpbndheUxvZ2dpbmcuZGVidWcoXCJHYXRld2F5OiBjbG9zZSgpXCIpLHZvaWQgMCE9PXRoaXMuc29ja2V0KXt0aGlzLnNvY2tldC5jbG9zZSgzZTMsXCJTaWduYWxpbmcgd2Vic29ja2V0IGNsb3NlZC5cIik7Y29uc3QgQT10aGlzLnNvY2tldDt3aW5kb3cuc2V0VGltZW91dCgoKCk9PntBLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjbG9zZVwiLHRoaXMub25DbG9zZSksQS5yZW1vdmVFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLHRoaXMub25NZXNzYWdlKX0pLDApfW51bGw9PT0oQT10aGlzLnJlamVjdENvbm5lY3RUb0dhdGV3YXlQcm9taXNlKXx8dm9pZCAwPT09QXx8QS5jYWxsKHRoaXMsdm9pZCAwKSxCKHRoaXMsZyxyLkNsb3NlZCksdGhpcy5jb25uZWN0VG9HYXRld2F5UHJvbWlzZT12b2lkIDAsdGhpcy5yZXNvbHZlQ29ubmVjdFRvR2F0ZXdheVByb21pc2U9dm9pZCAwLHRoaXMucmVqZWN0Q29ubmVjdFRvR2F0ZXdheVByb21pc2U9dm9pZCAwLHRoaXMuc29ja2V0PXZvaWQgMCx0aGlzLmNvbm5lY3Rpb25zLmNsZWFyKCl9bWFrZURhdGFncmFtKEEpe3JldHVybntoZWFkZXI6e3N5bmNLZXk6Kyt0aGlzLnN5bmNLZXl9LGJvZHk6QX19bWFrZUZvcndhcmRhYmxlKEEsZSl7cmV0dXJuIHRoaXMubWFrZURhdGFncmFtKHtkaXNjcmltaW5hdG9yOm4uR2F0ZXdheUZvcndhcmRhYmxlLmRpc2NyaW1pbmF0b3IsdmFsdWU6e3RhcmdldFBlZXJJZDpBLGJvZHk6ZX19KX1jb25uZWN0VG9Ib3N0KEEsZSl7Y29uc3QgST10aGlzLmNvbm5lY3Rpb25zLmdldChBKTtpZih2b2lkIDAhPT1JKXtpZihJLm93bmVkKXRocm93IG5ldyBRLlJhaW53YXlFcnJvcihcImFscmVhZHkgY29ubmVjdGVkIGluIG90aGVyIGRpcmVjdGlvblwiKTtyZXR1cm4gSS5wcm9taXNlfWlmKHZvaWQgMD09PXRoaXMuc29ja2V0KXRocm93IG5ldyBRLlJhaW53YXlFcnJvcihcInNvY2tldCB1bmRlZmluZWQgaW4gc2VuZEluaXRDb25uZWN0aW9uUmVxdWVzdFwiKTtpZih0aGlzLnN0YXR1cyE9PXIuT3Blbil0aHJvdyBuZXcgUS5SYWlud2F5RXJyb3IoXCJzaWduYWxpbmcgY2hhbm5lbCBub3Qgb3BlbiBpbiBzZW5kSW5pdENvbm5lY3Rpb25SZXF1ZXN0XCIpO2NvbnN0IGc9dGhpcy5zb2NrZXQsdD17cGVuZGluZzohMH07cmV0dXJuIHQucHJvbWlzZT1uZXcgUHJvbWlzZSgoKEksaSk9Pnt0LnJlc29sdmU9SSx0LnJlamVjdD1pLG8uUmFpbndheUxvZ2dpbmcudHJhY2UoYEdhdGV3YXk6IEFkZGluZyAke0F9IHRvIHBlbmRpbmdDb25uZWN0aW9uc2ApO2NvbnN0IEI9dGhpcy5tYWtlRGF0YWdyYW0oe2Rpc2NyaW1pbmF0b3I6bi5HYXRld2F5UmVxdWVzdC5kaXNjcmltaW5hdG9yLHZhbHVlOntib2R5OntkaXNjcmltaW5hdG9yOm4uSW5pdENvbm5lY3Rpb25SZXF1ZXN0LmRpc2NyaW1pbmF0b3IsdmFsdWU6e2Rlc2lyZWRUcmFuc3BvcnQ6ZSx0YXJnZXRQZWVySWQ6QX19fX0pO3Quc3luY0tleT1CLmhlYWRlci5zeW5jS2V5LHRoaXMuY29ubmVjdGlvbnMuc2V0KEEsdCksZy5zZW5kKG4uR2F0ZXdheURhdGFncmFtLmVuY29kZShCKSl9KSksdC5wcm9taXNlfWNhbmNlbENvbm5lY3Rpb25BdHRlbXB0KEEpe2NvbnN0IGU9dGhpcy5jb25uZWN0aW9ucy5nZXQoQSk7dm9pZCAwIT09ZSYmZS5wZW5kaW5nJiYoZS5yZXNvbHZlKHtjYW5jZWxlZDohMH0pLHRoaXMuY29ubmVjdGlvbnMuZGVsZXRlKEEpKX1kZWxldGVDb25uZWN0aW9uKEEpe3RoaXMuY29ubmVjdGlvbnMuZGVsZXRlKEEpfXNlbmRQZWVySW5mbyhBLGUsSSl7aWYodm9pZCAwPT09dGhpcy5zb2NrZXQpdGhyb3cgbmV3IFEuUmFpbndheUVycm9yKFwic29ja2V0IHVuc2V0IGluIEdhdGV3YXkuc2VuZFBlZXJJbmZvXCIpO2NvbnN0IGc9dGhpcy5jb25uZWN0aW9ucy5nZXQoQSk7aWYodm9pZCAwPT09Zyl0aHJvdyBuZXcgUS5SYWlud2F5RXJyb3IoYGNhbid0IHNlbmQgcGVlciBpbmZvIHRvIHVua25vd24gcGVlcklkICR7QX1gKTtpZihnLnBlbmRpbmcpdGhyb3cgbmV3IFEuUmFpbndheUVycm9yKGBjYW4ndCBzZW5kIHBlZXIgaW5mbyB0byBwZW5kaW5nIHBlZXJJZCAke0F9YCk7Y29uc3QgdD10aGlzLm1ha2VGb3J3YXJkYWJsZShBLHtkaXNjcmltaW5hdG9yOm4uUGVlclNpZ25hbGluZ0luZm9ybWF0aW9uLmRpc2NyaW1pbmF0b3IsdmFsdWU6e2lkOmcuY29ubmVjdGlvblJlcXVlc3RJZCx0eXBlOmUsZGF0YTpJfX0pLGk9bi5HYXRld2F5RGF0YWdyYW0uZW5jb2RlKHQpO3RoaXMuc29ja2V0LnNlbmQoaSl9c2VuZE9mZmVyKEEsZSl7by5SYWlud2F5TG9nZ2luZy5kZWJ1ZyhcInNlbmRpbmcgb2ZmZXI6IFwiK2UpLHRoaXMuc2VuZFBlZXJJbmZvKEEsbi5QZWVySW5mb3JtYXRpb25UeXBlLk9mZmVyLGUpfXNlbmRBbnN3ZXIoQSxlKXtvLlJhaW53YXlMb2dnaW5nLmRlYnVnKFwic2VuZGluZyBvZmZlcjogXCIrZSksdGhpcy5zZW5kUGVlckluZm8oQSxuLlBlZXJJbmZvcm1hdGlvblR5cGUuQW5zd2VyLGUpfXNlbmRDYW5kaWRhdGUoQSxlKXtvLlJhaW53YXlMb2dnaW5nLmRlYnVnKFwic2VuZGluZyBjYW5kaWRhdGVcIitlLmNhbmRpZGF0ZSksdGhpcy5zZW5kUGVlckluZm8oQSxuLlBlZXJJbmZvcm1hdGlvblR5cGUuQ2FuZGlkYXRlLGUuY2FuZGlkYXRlKX1vbk5vbkZhdGFsQWxlcnQoQSxlKXtpZihlPT09bi5HYXRld2F5QWxlcnREZXNjcmlwdGlvbi5QZWVyR29uZUF3YXkpZm9yKGNvbnN0W2UsSV1vZiB0aGlzLmNvbm5lY3Rpb25zLmVudHJpZXMoKSlJLnBlbmRpbmcmJkkuc3luY0tleT09PUEmJihJLnJlamVjdChcIlRoZSB0YXJnZXQgcGVlciBpcyBub3QgY29ubmVjdGVkIHRvIFJhaW53YXkuXCIpLHRoaXMuY29ubmVjdGlvbnMuZGVsZXRlKGUpKX1vbkZvcndhcmRhYmxlKEEsZSl7Y29uc3R7dGFyZ2V0UGVlcklkOkksYm9keTpnfT1lO3N3aXRjaChnLmRpc2NyaW1pbmF0b3Ipe2Nhc2Ugbi5Db25uZWN0aW9uUmVxdWVzdC5kaXNjcmltaW5hdG9yOntjb25zdHtzb3VyY2VQZWVySWQ6ZSxzb3VyY2VFeHRlcm5hbElkOkksZGVzaXJlZFRyYW5zcG9ydDp0LGlkOmksZXhwaXJhdGlvbkRhdGU6Qn09Zy52YWx1ZSxDPWk7dGhpcy5wZWVySWRUb0V4dGVybmFsSWQuc2V0KGUsSSksdGhpcy5jb25uZWN0aW9uUmVxdWVzdEhhbmRsZXIoe3BlZXJJZDplLGV4dGVybmFsSWQ6Zy52YWx1ZS5zb3VyY2VFeHRlcm5hbElkLGFjY2VwdDooKT0+e2lmKHZvaWQgMD09PXRoaXMuc29ja2V0KXRocm93IG5ldyBRLlJhaW53YXlFcnJvcihcIkNvdWxkbid0IHNlbmQgYWNjZXB0IG1lc3NhZ2UgYmVjYXVzZSB0aGUgY29ubmVjdGlvbiB0byBSYWlud2F5IHdhcyBsb3N0LlwiKTtjb25zdCBnPW4uR2F0ZXdheURhdGFncmFtLmVuY29kZSh7aGVhZGVyOntzeW5jS2V5OkF9LGJvZHk6e2Rpc2NyaW1pbmF0b3I6bi5HYXRld2F5Rm9yd2FyZGFibGUuZGlzY3JpbWluYXRvcix2YWx1ZTp7dGFyZ2V0UGVlcklkOmUsYm9keTp7ZGlzY3JpbWluYXRvcjpuLkFjY2VwdGVkQ29ubmVjdGlvblJlcXVlc3QuZGlzY3JpbWluYXRvcix2YWx1ZTp7c291cmNlUGVlcklkOnRoaXMub3duUGVlcklkLHNvdXJjZUV4dGVybmFsSWQ6dGhpcy5leHRlcm5hbElkLGlkOml9fX19fSk7dGhpcy5zb2NrZXQuc2VuZChnKSx0aGlzLmNvbm5lY3Rpb25zLnNldChlLHtwZW5kaW5nOiExLG93bmVkOiEwLGNvbm5lY3Rpb25SZXF1ZXN0SWQ6Q30pLHRoaXMuYWRkQWNjZXB0ZWRQZWVyKGUsSSxDKX0scmVqZWN0Okk9PntpZih2b2lkIDA9PT10aGlzLnNvY2tldCl0aHJvdyBuZXcgUS5SYWlud2F5RXJyb3IoXCJDb3VsZG4ndCBzZW5kIHJlamVjdCBtZXNzYWdlIGJlY2F1c2UgdGhlIGNvbm5lY3Rpb24gdG8gUmFpbndheSB3YXMgbG9zdC5cIik7Y29uc3QgZz1uLkdhdGV3YXlEYXRhZ3JhbS5lbmNvZGUoe2hlYWRlcjp7c3luY0tleTpBfSxib2R5OntkaXNjcmltaW5hdG9yOm4uR2F0ZXdheUZvcndhcmRhYmxlLmRpc2NyaW1pbmF0b3IsdmFsdWU6e3RhcmdldFBlZXJJZDplLGJvZHk6e2Rpc2NyaW1pbmF0b3I6bi5SZWplY3RlZENvbm5lY3Rpb25SZXF1ZXN0LmRpc2NyaW1pbmF0b3IsdmFsdWU6e3NvdXJjZVBlZXJJZDp0aGlzLm93blBlZXJJZCxzb3VyY2VFeHRlcm5hbElkOnRoaXMuZXh0ZXJuYWxJZCxpZDppLHJlYXNvbjpJfX19fX0pO3RoaXMuc29ja2V0LnNlbmQoZyl9fSk7YnJlYWt9Y2FzZSBuLkFjY2VwdGVkQ29ubmVjdGlvblJlcXVlc3QuZGlzY3JpbWluYXRvcjp7Y29uc3R7aWQ6QSxzb3VyY2VQZWVySWQ6ZSxzb3VyY2VFeHRlcm5hbElkOkl9PWcudmFsdWUsdD1BLGk9dGhpcy5jb25uZWN0aW9ucy5nZXQoZSk7aWYodm9pZCAwPT09aSlyZXR1cm4gdm9pZCBvLlJhaW53YXlMb2dnaW5nLndhcm5pbmcoXCJJZ25vcmluZyBBY2NlcHRlZENvbm5lY3Rpb25SZXF1ZXN0IGZyb20gdW5leHBlY3RlZCBob3N0bmFtZTogXCIrZSk7aWYoIWkucGVuZGluZylyZXR1cm4gdm9pZCBvLlJhaW53YXlMb2dnaW5nLndhcm5pbmcoXCJJZ25vcmluZyBBY2NlcHRlZENvbm5lY3Rpb25SZXF1ZXN0IGZyb20gYWxyZWFkeS1jb25uZWN0ZWQgaG9zdG5hbWU6IFwiK2UpO2kucmVzb2x2ZSh7Y2FuY2VsZWQ6ITEsYWNjZXB0ZWQ6ITAsY29ubmVjdGlvblJlcXVlc3RJZDp0LGhvc3RFeHRlcm5hbElkOkksdHJhbnNwb3J0UHJvdG9jb2w6bi5QZWVyVHJhbnNwb3J0VHlwZS5TQ1RQfSksdGhpcy5jb25uZWN0aW9ucy5zZXQoZSx7cGVuZGluZzohMSxvd25lZDohMSxwcm9taXNlOmkucHJvbWlzZSxjb25uZWN0aW9uUmVxdWVzdElkOnR9KTticmVha31jYXNlIG4uUmVqZWN0ZWRDb25uZWN0aW9uUmVxdWVzdC5kaXNjcmltaW5hdG9yOntjb25zdHtpZDpBLHNvdXJjZVBlZXJJZDplLHNvdXJjZUV4dGVybmFsSWQ6SX09Zy52YWx1ZSx0PUEsaT10aGlzLmNvbm5lY3Rpb25zLmdldChlKTtpZih2b2lkIDA9PT1pKXJldHVybiB2b2lkIG8uUmFpbndheUxvZ2dpbmcud2FybmluZyhcIklnbm9yaW5nIFJlamVjdGVkQ29ubmVjdGlvblJlcXVlc3QgZnJvbSB1bmV4cGVjdGVkIGhvc3RuYW1lOiBcIitlKTtpZighaS5wZW5kaW5nKXJldHVybiB2b2lkIG8uUmFpbndheUxvZ2dpbmcud2FybmluZyhcIklnbm9yaW5nIFJlamVjdGVkQ29ubmVjdGlvblJlcXVlc3QgZnJvbSBhbHJlYWR5LWNvbm5lY3RlZCBob3N0bmFtZTogXCIrZSk7aS5yZXNvbHZlKHtjYW5jZWxlZDohMSxhY2NlcHRlZDohMSxjb25uZWN0aW9uUmVxdWVzdElkOnQsaG9zdEV4dGVybmFsSWQ6SSx0cmFuc3BvcnRQcm90b2NvbDpuLlBlZXJUcmFuc3BvcnRUeXBlLlNDVFAscmVhc29uOmcudmFsdWUucmVhc29ufSksdGhpcy5jb25uZWN0aW9ucy5kZWxldGUoZSk7YnJlYWt9Y2FzZSBuLlBlZXJTaWduYWxpbmdJbmZvcm1hdGlvbi5kaXNjcmltaW5hdG9yOm8uUmFpbndheUxvZ2dpbmcudHJhY2UoXCJHb3QgcGVlciBpbmZvOlxcblwiK0pTT04uc3RyaW5naWZ5KGcudmFsdWUpKSx0aGlzLmhhbmRsZVBlZXJJbmZvKGcudmFsdWUpfX1kaWUoQSxlKXt2YXIgSSxnO251bGw9PT0oST10aGlzLnJlamVjdENvbm5lY3RUb0dhdGV3YXlQcm9taXNlKXx8dm9pZCAwPT09SXx8SS5jYWxsKHRoaXMsQSksdGhpcy5jb25uZWN0VG9HYXRld2F5UHJvbWlzZT12b2lkIDAsdGhpcy5yZXNvbHZlQ29ubmVjdFRvR2F0ZXdheVByb21pc2U9dm9pZCAwLHRoaXMucmVqZWN0Q29ubmVjdFRvR2F0ZXdheVByb21pc2U9dm9pZCAwO2Zvcihjb25zdCBBIG9mIHRoaXMuY29ubmVjdGlvbnMudmFsdWVzKCkpQS5wZW5kaW5nJiZBLnJlamVjdChlKTt0aGlzLmNvbm5lY3Rpb25zLmNsZWFyKCksbnVsbD09PShnPXRoaXMuY29ubmVjdGlvbkxvc3RFdmVudCl8fHZvaWQgMD09PWd8fGcuaW52b2tlKG5ldyBRLlJhaW53YXlFcnJvcihlKSl9dW5zZXRDb25uZWN0VG9HYXRld2F5UHJvbWlzZSgpe3RoaXMuY29ubmVjdFRvR2F0ZXdheVByb21pc2U9dm9pZCAwLHRoaXMucmVzb2x2ZUNvbm5lY3RUb0dhdGV3YXlQcm9taXNlPXZvaWQgMCx0aGlzLnJlamVjdENvbm5lY3RUb0dhdGV3YXlQcm9taXNlPXZvaWQgMH19LGc9bmV3IFdlYWtNYXB9LDM2NDM6ZnVuY3Rpb24oQSxlLEkpe1widXNlIHN0cmljdFwiO3ZhciBnLHQ9dGhpcyYmdGhpcy5fX2F3YWl0ZXJ8fGZ1bmN0aW9uKEEsZSxJLGcpe3JldHVybiBuZXcoSXx8KEk9UHJvbWlzZSkpKChmdW5jdGlvbih0LGkpe2Z1bmN0aW9uIEIoQSl7dHJ5e1EoZy5uZXh0KEEpKX1jYXRjaChBKXtpKEEpfX1mdW5jdGlvbiBDKEEpe3RyeXtRKGcudGhyb3coQSkpfWNhdGNoKEEpe2koQSl9fWZ1bmN0aW9uIFEoQSl7dmFyIGU7QS5kb25lP3QoQS52YWx1ZSk6KGU9QS52YWx1ZSxlIGluc3RhbmNlb2YgST9lOm5ldyBJKChmdW5jdGlvbihBKXtBKGUpfSkpKS50aGVuKEIsQyl9USgoZz1nLmFwcGx5KEEsZXx8W10pKS5uZXh0KCkpfSkpfTtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxlLlJhaW53YXlSYXRlQ29udHJvbGxlcj1lLmRlZmF1bHRSYXRlQ29udHJvbFBhcmFtZXRlcnM9ZS5RdWFsaXR5QWRqdXN0bWVudD12b2lkIDA7Y29uc3QgaT1JKDE5OCksQj1JKDI0MzQpLEM9SSgzNDY0KSxRPUkoNDAwOSk7dmFyIG87IWZ1bmN0aW9uKEEpe0FbQS5VcD0wXT1cIlVwXCIsQVtBLkRvd249MV09XCJEb3duXCJ9KG89ZS5RdWFsaXR5QWRqdXN0bWVudHx8KGUuUXVhbGl0eUFkanVzdG1lbnQ9e30pKSxlLmRlZmF1bHRSYXRlQ29udHJvbFBhcmFtZXRlcnM9e2JlYXRNczoyNTAwLHdpbmRvd01zOjQ1MDAsYmFkQmVhdHM6Mixnb29kQmVhdHM6NCxiYWNrb2ZmRmFjdG9yOjIsbGF0ZW5lc3NUaHJlc2hvbGRNczoyMDAsbGF0ZW5lc3NTbW9vdGhpbmdGYWN0b3I6LjkzNzUsYmFkTGF0ZUZyYW1lUmF0aW86Ljc1LGluaXRpYWxCaXRyYXRlS2JwczpOdW1iZXIobnVsbCE9PShnPW5ldyBVUkxTZWFyY2hQYXJhbXMod2luZG93LmxvY2F0aW9uLnNlYXJjaCkuZ2V0KFwiaW5pdGlhbC1iaXRyYXRlXCIpKSYmdm9pZCAwIT09Zz9nOjVlMykscXVhbGl0eVN0ZXBGYWN0b3I6MS4xODc1fSxlLlJhaW53YXlSYXRlQ29udHJvbGxlcj1jbGFzc3tjb25zdHJ1Y3RvcihBPWUuZGVmYXVsdFJhdGVDb250cm9sUGFyYW1ldGVycyxJLGcsQyl7dGhpcy5jaG9zZW5WaWRlb0NvbmZpZz1JLHRoaXMucGVyZm9ybWFuY2VNb25pdG9yPUMsdGhpcy5iYWRCZWF0Q291bnQ9MCx0aGlzLmdvb2RCZWF0Q291bnQ9MCx0aGlzLmxhc3RBZGp1c3RtZW50PXZvaWQgMCx0aGlzLmhpc3Rvcnk9W10sdGhpcy5sb3dlc3REZWx0YT12b2lkIDAsdGhpcy5zbW9vdGhMYXRlbmVzcz0wLHRoaXMuZnJhbWVzVGhpc0JlYXQ9MCx0aGlzLmxhdGVGcmFtZXNUaGlzQmVhdD0wLHRoaXMuZGVidWdMYXRlbmVzc1Ntb290aGluZz0hMSx0aGlzLmJhZENwdVBlcmZUaGlzQmVhdD0hMSx0aGlzLmJhZERlY29kZXJQZXJmVGhpc0JlYXQ9ITEsdGhpcy5iYWRDcHVQZXJmSGFuZGxlcj0oKT0+e3RoaXMuYmFkQ3B1UGVyZlRoaXNCZWF0PSEwfSx0aGlzLmJhZERlY29kZXJQZXJmSGFuZGxlcj0oKT0+e3RoaXMuYmFkRGVjb2RlclBlcmZUaGlzQmVhdD0hMH0sdGhpcy5oYW5kbGVWaWRlb1JlYWR5U3RhdGU9QT0+e0E9PT1CLlZpZGVvUmVhZHlTdGF0ZS5EZXRhY2hlZHx8QT09PUIuVmlkZW9SZWFkeVN0YXRlLlBhdXNlZHx8QT09PUIuVmlkZW9SZWFkeVN0YXRlLldhaXRpbmdGb3JLZXlmcmFtZT90aGlzLnN0b3AoKTp0aGlzLnN0YXJ0KCl9LHRoaXMuY2hlY2s9KCk9PnQodGhpcyx2b2lkIDAsdm9pZCAwLChmdW5jdGlvbiooKXswIT09dGhpcy5mcmFtZXNUaGlzQmVhdCYmKCh5aWVsZCB0aGlzLmJlYXRJc0JhZCgpKT90aGlzLmJhZEJlYXQoKTp0aGlzLmdvb2RCZWF0KCksdGhpcy5mcmFtZXNUaGlzQmVhdD0wLHRoaXMubGF0ZUZyYW1lc1RoaXNCZWF0PTAsdGhpcy5iYWRDcHVQZXJmVGhpc0JlYXQ9ITEsdGhpcy5iYWREZWNvZGVyUGVyZlRoaXNCZWF0PSExKX0pKSx0aGlzLm93bk1heGltdW1LYnBzPTEvMCx0aGlzLmNob3NlblZpZGVvQ29uZmlnTWltZVR5cGU9US52aWRlb0NvZGVjTWltZVR5cGUoSS5jb2RlYyksdGhpcy5wYXJhbWV0ZXJzPU9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSxlLmRlZmF1bHRSYXRlQ29udHJvbFBhcmFtZXRlcnMpLEEpLHRoaXMuc3VnZ2VzdEJpdHJhdGVLYnBzPWcsdGhpcy5jdXJyZW50Qml0cmF0ZUticHM9dGhpcy5wYXJhbWV0ZXJzLmluaXRpYWxCaXRyYXRlS2Jwcyx0aGlzLmZyYW1lVmFyaWFuY2VNcz1uZXcgaS5XaW5kb3dUcmFjayh0aGlzLnBhcmFtZXRlcnMud2luZG93TXMsaS5zdGFuZGFyZERldmlhdGlvbil9Zm9ybWF0KEEpe3JldHVybmBbUmF0ZUNvbnRyb2w6ICR7dGhpcy5jdXJyZW50Qml0cmF0ZUticHMudG9GaXhlZCgwKStcImticHNcIn0sICske3RoaXMuc21vb3RoTGF0ZW5lc3MudG9GaXhlZCgwKX1tc10gJHtBfWB9ZGVidWcoQSl7Qy5SYWlud2F5TG9nZ2luZy5kZWJ1Zyh0aGlzLmZvcm1hdChBKSl9aW5mbyhBKXtDLlJhaW53YXlMb2dnaW5nLmluZm9ybWF0aW9uKHRoaXMuZm9ybWF0KEEpKX1zdGFydCgpe3ZhciBBLGU7dGhpcy5jaGVja0ludGVydmFsfHwodGhpcy5pbmZvKFwiU3RhcnRpbmcgcmF0ZSBjb250cm9sIVwiKSx0aGlzLmNoZWNrSW50ZXJ2YWw9d2luZG93LnNldEludGVydmFsKHRoaXMuY2hlY2ssdGhpcy5wYXJhbWV0ZXJzLmJlYXRNcyksbnVsbD09PShBPXRoaXMucGVyZm9ybWFuY2VNb25pdG9yKXx8dm9pZCAwPT09QXx8QS5jcHVTdGFydmF0aW9uRXZlbnQuYWRkSGFuZGxlcih0aGlzLmJhZENwdVBlcmZIYW5kbGVyKSxudWxsPT09KGU9dGhpcy5wZXJmb3JtYW5jZU1vbml0b3IpfHx2b2lkIDA9PT1lfHxlLmRlY29kZXJTdHJ1Z2dsaW5nRXZlbnQuYWRkSGFuZGxlcih0aGlzLmJhZERlY29kZXJQZXJmSGFuZGxlcikpfXN0b3AoKXt2YXIgQSxlO3RoaXMuY2hlY2tJbnRlcnZhbCYmKHRoaXMuaW5mbyhcIlN0b3BwaW5nIHJhdGUgY29udHJvbCFcIiksd2luZG93LmNsZWFySW50ZXJ2YWwodGhpcy5jaGVja0ludGVydmFsKSx0aGlzLmNoZWNrSW50ZXJ2YWw9dm9pZCAwLG51bGw9PT0oQT10aGlzLnBlcmZvcm1hbmNlTW9uaXRvcil8fHZvaWQgMD09PUF8fEEuY3B1U3RhcnZhdGlvbkV2ZW50LnJlbW92ZUhhbmRsZXIodGhpcy5iYWRDcHVQZXJmSGFuZGxlciksbnVsbD09PShlPXRoaXMucGVyZm9ybWFuY2VNb25pdG9yKXx8dm9pZCAwPT09ZXx8ZS5kZWNvZGVyU3RydWdnbGluZ0V2ZW50LnJlbW92ZUhhbmRsZXIodGhpcy5iYWREZWNvZGVyUGVyZkhhbmRsZXIpKX1mZWVkRnJhbWVUaW1lc3RhbXAoQSl7Y29uc3QgZT1wZXJmb3JtYW5jZS5ub3coKS1BOyh2b2lkIDA9PT10aGlzLmxvd2VzdERlbHRhfHxlPHRoaXMubG93ZXN0RGVsdGF8fE1hdGguYWJzKHRoaXMubG93ZXN0RGVsdGEtZSk+NWU0KSYmKHRoaXMubG93ZXN0RGVsdGE9ZSk7Y29uc3QgST1lLXRoaXMubG93ZXN0RGVsdGEsZz10aGlzLnBhcmFtZXRlcnMubGF0ZW5lc3NTbW9vdGhpbmdGYWN0b3I7aWYodGhpcy5zbW9vdGhMYXRlbmVzcz1nKnRoaXMuc21vb3RoTGF0ZW5lc3MrKDEtZykqSSx0aGlzLmZyYW1lc1RoaXNCZWF0KyssdGhpcy5zbW9vdGhMYXRlbmVzcz49dGhpcy5wYXJhbWV0ZXJzLmxhdGVuZXNzVGhyZXNob2xkTXMmJnRoaXMubGF0ZUZyYW1lc1RoaXNCZWF0KyssdGhpcy5kZWJ1Z0xhdGVuZXNzU21vb3RoaW5nKXtjb25zdCBBPW5ldyBBcnJheSgxMDApO0EuZmlsbChcIi1cIik7Y29uc3QgZT1JLGc9dGhpcy5zbW9vdGhMYXRlbmVzcztBWzUwXT1cIi5cIixBW01hdGgubWF4KDAsTWF0aC5taW4oTWF0aC5yb3VuZChlLzEwKzUwKSw5OSkpXT1cIkxcIixBW01hdGgubWF4KDAsTWF0aC5taW4oTWF0aC5yb3VuZChnLzEwKzUwKSw5OSkpXT1cIlNcIix0aGlzLmJlYXRJc0JhZCgpLnRoZW4oKEk9PkMuUmFpbndheUxvZ2dpbmcuZGVidWcoYCR7QS5qb2luKFwiXCIpfSBMPSR7ZX0gUz0ke2d9IGJhZD0ke0l9IGxkPSR7dGhpcy5sb3dlc3REZWx0YX1gKSkpfX1kZWNvZGluZ0luZm9BdEJpdHJhdGUoQSl7cmV0dXJuIG5hdmlnYXRvci5tZWRpYUNhcGFiaWxpdGllcy5kZWNvZGluZ0luZm8oe3R5cGU6XCJtZWRpYS1zb3VyY2VcIix2aWRlbzp7d2lkdGg6dGhpcy5jaG9zZW5WaWRlb0NvbmZpZy5jb2RlYy53aWR0aCxoZWlnaHQ6dGhpcy5jaG9zZW5WaWRlb0NvbmZpZy5jb2RlYy5oZWlnaHQsZnJhbWVyYXRlOnRoaXMuY2hvc2VuVmlkZW9Db25maWcuY29kZWMucmVmcmVzaFJhdGUsYml0cmF0ZToxZTMqQSxjb250ZW50VHlwZTpRLnZpZGVvQ29kZWNNaW1lVHlwZSh0aGlzLmNob3NlblZpZGVvQ29uZmlnLmNvZGVjKX19KX1jYXBhYmlsaXRpZXNCYWQoKXtyZXR1cm4gdCh0aGlzLHZvaWQgMCx2b2lkIDAsKGZ1bmN0aW9uKigpe2lmKCEoXCJNZWRpYVNvdXJjZVwiaW4gd2luZG93KSlyZXR1cm4hMTtpZighKFwibWVkaWFDYXBhYmlsaXRpZXNcImluIG5hdmlnYXRvcikpcmV0dXJuITE7Y29uc3QgQT15aWVsZCB0aGlzLmRlY29kaW5nSW5mb0F0Qml0cmF0ZSh0aGlzLmN1cnJlbnRCaXRyYXRlS2JwcyksZT15aWVsZCB0aGlzLmRlY29kaW5nSW5mb0F0Qml0cmF0ZSh0aGlzLmJpdHJhdGVPbmVTdGVwRG93bkticHMoKSk7cmV0dXJuIGUuc21vb3RoJiYhQS5zbW9vdGh8fGUucG93ZXJFZmZpY2llbnQmJiFBLnBvd2VyRWZmaWNpZW50fSkpfWxhdGVGcmFtZVJhdGlvQmFkKCl7cmV0dXJuIHRoaXMubGF0ZUZyYW1lc1RoaXNCZWF0L3RoaXMuZnJhbWVzVGhpc0JlYXQ+PXRoaXMucGFyYW1ldGVycy5iYWRMYXRlRnJhbWVSYXRpb31iZWF0SXNCYWQoKXtyZXR1cm4gdCh0aGlzLHZvaWQgMCx2b2lkIDAsKGZ1bmN0aW9uKigpe3JldHVybiB0aGlzLmJhZERlY29kZXJQZXJmVGhpc0JlYXR8fHRoaXMuYmFkQ3B1UGVyZlRoaXNCZWF0fHx0aGlzLmxhdGVGcmFtZVJhdGlvQmFkKCl8fCh5aWVsZCB0aGlzLmNhcGFiaWxpdGllc0JhZCgpKX0pKX1iYWRCZWF0KCl7aWYodGhpcy5jdXJyZW50Qml0cmF0ZUticHM8PXRoaXMubG93ZXN0U3VwcG9ydGVkQml0cmF0ZUticHMoKSlyZXR1cm4gdm9pZCB0aGlzLmRlYnVnKGBjcmFzaGVkIGF0ICR7dGhpcy5jdXJyZW50Qml0cmF0ZUticHMudG9GaXhlZCgwKX1rYnBzLCBpZ25vcmluZyBiYWQgYmVhdGApO3RoaXMuYmFkQmVhdENvdW50KyssdGhpcy5nb29kQmVhdENvdW50PTAsdGhpcy5jdXJyZW50Qml0cmF0ZUticHM7Y29uc3QgQT10aGlzLnBhcmFtZXRlcnMuYmFkQmVhdHM7aWYodGhpcy5kZWJ1ZyhgYmFkIGJlYXQ6ICR7dGhpcy5iYWRCZWF0Q291bnR9LyR7QX1gKSx0aGlzLmJhZEJlYXRDb3VudD49dGhpcy5wYXJhbWV0ZXJzLmJhZEJlYXRzKXt0aGlzLmdvb2RCZWF0Q291bnQ9dGhpcy5iYWRCZWF0Q291bnQ9MDtjb25zdCBBPXRoaXMubGFzdEFkanVzdG1lbnQ9PT1vLlVwO3RoaXMucXVhbGl0eURvd24oKSx0aGlzLmRlYnVnKFwid2VudCBkb3duIGluIHF1YWxpdHlcIiksQSYmdGhpcy5jdXJyZW50Qml0cmF0ZUticHM8dGhpcy5vd25NYXhpbXVtS2JwcyYmKHRoaXMub3duTWF4aW11bUticHM9dGhpcy5jdXJyZW50Qml0cmF0ZUticHMsdGhpcy5pbmZvKGBzZXR0aW5nIGEgbmV3IG1heGltdW0gYXQgJHt0aGlzLm93bk1heGltdW1LYnBzLnRvRml4ZWQoMCl9a2Jwc2ApKX19Z29vZEJlYXQoKXtpZih0aGlzLmN1cnJlbnRCaXRyYXRlS2Jwcz49dGhpcy5vd25NYXhpbXVtS2Jwc3x8dGhpcy5jdXJyZW50Qml0cmF0ZUticHM+PXRoaXMuaGlnaGVzdFN1cHBvcnRlZEJpdHJhdGVLYnBzKCkpcmV0dXJuIHRoaXMuZGVidWcoYG1heGVkIGF0ICR7dGhpcy5jdXJyZW50Qml0cmF0ZUticHMudG9GaXhlZCgwKX1rYnBzLCBpZ25vcmluZyBnb29kIGJlYXRgKSx2b2lkKHRoaXMuYmFkQmVhdENvdW50PTApO3RoaXMuZ29vZEJlYXRDb3VudCsrLHRoaXMuYmFkQmVhdENvdW50PTAsdGhpcy5jdXJyZW50Qml0cmF0ZUticHM7Y29uc3QgQT10aGlzLnBhcmFtZXRlcnMuZ29vZEJlYXRzO3RoaXMuZGVidWcoYGdvb2QgYmVhdDogJHt0aGlzLmdvb2RCZWF0Q291bnR9LyR7QX1gKSx0aGlzLmdvb2RCZWF0Q291bnQ+PUEmJih0aGlzLmdvb2RCZWF0Q291bnQ9dGhpcy5iYWRCZWF0Q291bnQ9MCx0aGlzLnF1YWxpdHlVcCgpLHRoaXMuZGVidWcoXCJ3ZW50IHVwIGluIHF1YWxpdHlcIikpfWJpdHJhdGVPbmVTdGVwVXBLYnBzKCl7cmV0dXJuIE1hdGgubWluKHRoaXMuaGlnaGVzdFN1cHBvcnRlZEJpdHJhdGVLYnBzKCksdGhpcy5jdXJyZW50Qml0cmF0ZUticHMqdGhpcy5wYXJhbWV0ZXJzLnF1YWxpdHlTdGVwRmFjdG9yKX1iaXRyYXRlT25lU3RlcERvd25LYnBzKCl7cmV0dXJuIE1hdGgubWF4KHRoaXMubG93ZXN0U3VwcG9ydGVkQml0cmF0ZUticHMoKSx0aGlzLmN1cnJlbnRCaXRyYXRlS2Jwcy90aGlzLnBhcmFtZXRlcnMucXVhbGl0eVN0ZXBGYWN0b3IpfXF1YWxpdHlVcCgpe3RoaXMuY3VycmVudEJpdHJhdGVLYnBzPXRoaXMuYml0cmF0ZU9uZVN0ZXBVcEticHMoKSx0aGlzLnN1Z2dlc3RCaXRyYXRlS2Jwcyh0aGlzLmN1cnJlbnRCaXRyYXRlS2JwcyksdGhpcy5sYXN0QWRqdXN0bWVudD1vLlVwLHRoaXMuaGlzdG9yeS5wdXNoKHt0aW1lOnBlcmZvcm1hbmNlLm5vdygpLGJpdHJhdGU6dGhpcy5jdXJyZW50Qml0cmF0ZUticHN9KX1xdWFsaXR5RG93bigpe3RoaXMuY3VycmVudEJpdHJhdGVLYnBzPXRoaXMuYml0cmF0ZU9uZVN0ZXBEb3duS2JwcygpLHRoaXMuc3VnZ2VzdEJpdHJhdGVLYnBzKHRoaXMuY3VycmVudEJpdHJhdGVLYnBzKSx0aGlzLmxhc3RBZGp1c3RtZW50PW8uRG93bix0aGlzLmhpc3RvcnkucHVzaCh7dGltZTpwZXJmb3JtYW5jZS5ub3coKSxiaXRyYXRlOnRoaXMuY3VycmVudEJpdHJhdGVLYnBzfSksdGhpcy5sb3dlc3REZWx0YT12b2lkIDB9bG93ZXN0U3VwcG9ydGVkQml0cmF0ZUticHMoKXt2YXIgQTtyZXR1cm4gTnVtYmVyKG51bGwhPT0oQT1uZXcgVVJMU2VhcmNoUGFyYW1zKHdpbmRvdy5sb2NhdGlvbi5zZWFyY2gpLmdldChcImxvd2VzdC1iaXRyYXRlXCIpKSYmdm9pZCAwIT09QT9BOjVlMyl9aGlnaGVzdFN1cHBvcnRlZEJpdHJhdGVLYnBzKCl7dmFyIEE7cmV0dXJuIE51bWJlcihudWxsIT09KEE9bmV3IFVSTFNlYXJjaFBhcmFtcyh3aW5kb3cubG9jYXRpb24uc2VhcmNoKS5nZXQoXCJtYXgtYml0cmF0ZVwiKSkmJnZvaWQgMCE9PUE/QToxZTQpfX19LDMxNDU6ZnVuY3Rpb24oQSxlLEkpe1widXNlIHN0cmljdFwiO3ZhciBnLHQ9dGhpcyYmdGhpcy5fX2F3YWl0ZXJ8fGZ1bmN0aW9uKEEsZSxJLGcpe3JldHVybiBuZXcoSXx8KEk9UHJvbWlzZSkpKChmdW5jdGlvbih0LGkpe2Z1bmN0aW9uIEIoQSl7dHJ5e1EoZy5uZXh0KEEpKX1jYXRjaChBKXtpKEEpfX1mdW5jdGlvbiBDKEEpe3RyeXtRKGcudGhyb3coQSkpfWNhdGNoKEEpe2koQSl9fWZ1bmN0aW9uIFEoQSl7dmFyIGU7QS5kb25lP3QoQS52YWx1ZSk6KGU9QS52YWx1ZSxlIGluc3RhbmNlb2YgST9lOm5ldyBJKChmdW5jdGlvbihBKXtBKGUpfSkpKS50aGVuKEIsQyl9USgoZz1nLmFwcGx5KEEsZXx8W10pKS5uZXh0KCkpfSkpfSxpPXRoaXMmJnRoaXMuX19jbGFzc1ByaXZhdGVGaWVsZFNldHx8ZnVuY3Rpb24oQSxlLEkpe2lmKCFlLmhhcyhBKSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiYXR0ZW1wdGVkIHRvIHNldCBwcml2YXRlIGZpZWxkIG9uIG5vbi1pbnN0YW5jZVwiKTtyZXR1cm4gZS5zZXQoQSxJKSxJfSxCPXRoaXMmJnRoaXMuX19jbGFzc1ByaXZhdGVGaWVsZEdldHx8ZnVuY3Rpb24oQSxlKXtpZighZS5oYXMoQSkpdGhyb3cgbmV3IFR5cGVFcnJvcihcImF0dGVtcHRlZCB0byBnZXQgcHJpdmF0ZSBmaWVsZCBvbiBub24taW5zdGFuY2VcIik7cmV0dXJuIGUuZ2V0KEEpfTtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxlLlJUQ1RyYW5zcG9ydD12b2lkIDA7Y29uc3QgQz1JKDI5OTQpLFE9SSg5MDA5KSxvPUkoMzQ2NCksbj1JKDY5MDQpLGE9SSg5OTg3KSxyPUkoNTQyMCksRT1JKDc3ODMpLHM9e2ljZVNlcnZlcnM6W3t1cmxzOlwic3R1bjpzdHVuLnJhaW53YXkuY29tOjM0NzhcIn1dfTtjbGFzcyBkIGV4dGVuZHMgUS5SYWlud2F5VHJhbnNwb3J0e2NvbnN0cnVjdG9yKEEsZSxJLHQsQixhKXtzdXBlcigpLHRoaXMub3duUGVlcklkPUEsdGhpcy50YXJnZXRQZWVySWQ9ZSx0aGlzLnNlbmRMb2NhbE9mZmVyU2RwPUksdGhpcy5zZW5kTG9jYWxBbnN3ZXJTZHA9dCx0aGlzLnNlbmRMb2NhbEljZUNhbmRpZGF0ZT1CLHRoaXMucmVwb3J0U3RhdGVDaGFuZ2U9YSxnLnNldCh0aGlzLFEuUmFpbndheVRyYW5zcG9ydFN0YXR1cy5EaXNjb25uZWN0ZWQpLHRoaXMucnRjQ29uZmlndXJhdGlvbj1zLHRoaXMuZGF0YUNoYW5uZWxzQ29uZmlnPXt9LHRoaXMuc3luY0tleT0wLHRoaXMub25SYWlud2F5TWVzc2FnZT0oKT0+e30sdGhpcy5vbkFwcGxpY2F0aW9uTWVzc2FnZT0oKT0+e30sdGhpcy5vbkNsb3NlPSgpPT57fSx0aGlzLmhhbmRsZVBlZXJJbmZvPUE9Pnt2YXIgZSxJLGc7aWYoQS50eXBlPT09bi5QZWVySW5mb3JtYXRpb25UeXBlLkFuc3dlcilvLlJhaW53YXlMb2dnaW5nLmRlYnVnKFwiR290IEFuc3dlciBpbiBDUklEIFwiK0EuaWQrXCJcXG5cIitBLmRhdGEpLG51bGw9PT0oZT10aGlzLnBlZXJDb25uZWN0aW9uKXx8dm9pZCAwPT09ZXx8ZS5zZXRSZW1vdGVEZXNjcmlwdGlvbih7dHlwZTpcImFuc3dlclwiLHNkcDpBLmRhdGF9KTtlbHNlIGlmKEEudHlwZT09PW4uUGVlckluZm9ybWF0aW9uVHlwZS5PZmZlcilvLlJhaW53YXlMb2dnaW5nLmRlYnVnKFwiR290IE9mZmVyIGluIENSSUQgXCIrQS5pZCtcIlxcblwiK0EuZGF0YSksbnVsbD09PShJPXRoaXMucGVlckNvbm5lY3Rpb24pfHx2b2lkIDA9PT1JfHxJLnNldFJlbW90ZURlc2NyaXB0aW9uKHt0eXBlOlwib2ZmZXJcIixzZHA6QS5kYXRhfSksdGhpcy5zZW5kQW5zd2VyKCk7ZWxzZXtpZihBLnR5cGUhPT1uLlBlZXJJbmZvcm1hdGlvblR5cGUuQ2FuZGlkYXRlKXtjb25zdCBlPW4uUGVlckluZm9ybWF0aW9uVHlwZVtBLnR5cGVdO3Rocm93IG5ldyBDLlJhaW53YXlFcnJvcihgdW5leHBlY3RlZCBQZWVySW5mb3JtYXRpb25UeXBlICR7ZX0gaW4gaGFuZGxlUGVlckluZm9gKX1vLlJhaW53YXlMb2dnaW5nLmRlYnVnKFwiR290IENhbmRpZGF0ZSBpbiBDUklEIFwiK0EuaWQrXCJcXG5cIitBLmRhdGEpLG51bGw9PT0oZz10aGlzLnBlZXJDb25uZWN0aW9uKXx8dm9pZCAwPT09Z3x8Zy5hZGRJY2VDYW5kaWRhdGUobmV3IFJUQ0ljZUNhbmRpZGF0ZSh7Y2FuZGlkYXRlOkEuZGF0YSxzZHBNaWQ6XCJcIixzZHBNTGluZUluZGV4OjB9KSl9fSx0aGlzLmhhbmRsZUxvY2FsSWNlQ2FuZGlkYXRlPUE9PntBLmNhbmRpZGF0ZSYmXCIxXCI9PT1BLmNhbmRpZGF0ZS5jYW5kaWRhdGUuc3BsaXQoXCIgXCIpWzFdJiZ0aGlzLnNlbmRMb2NhbEljZUNhbmRpZGF0ZShBLmNhbmRpZGF0ZSl9LHRoaXMuaGFuZGxlSWNlQ29ubmVjdGlvblN0YXRlQ2hhbmdlPSgpPT57aWYoIXRoaXMucGVlckNvbm5lY3Rpb24pcmV0dXJuO2NvbnN0IEE9dGhpcy5wZWVyQ29ubmVjdGlvbi5pY2VDb25uZWN0aW9uU3RhdGU7by5SYWlud2F5TG9nZ2luZy5pbmZvcm1hdGlvbihgSUNFIGNvbm5lY3Rpb24gc3RhdGUgY2hhbmdlZCB0byAke0F9YCl9LHRoaXMuaGFuZGxlQ29ubmVjdGlvblN0YXRlQ2hhbmdlPSgpPT57dmFyIEE7aWYoIXRoaXMucGVlckNvbm5lY3Rpb24pcmV0dXJuO2NvbnN0IGU9dGhpcy5wZWVyQ29ubmVjdGlvbi5jb25uZWN0aW9uU3RhdGU7by5SYWlud2F5TG9nZ2luZy5pbmZvcm1hdGlvbihgQ29ubmVjdGlvbiBzdGF0ZSBjaGFuZ2VkIHRvICR7ZX1gKSxcImNsb3NlZFwiPT09ZXx8XCJmYWlsZWRcIj09PWU/KHRoaXMucmVwb3J0U3RhdGVDaGFuZ2UoRS5SYWlud2F5UGVlclN0YXRlLkZhaWxlZCksbnVsbD09PShBPXRoaXMub3BlblJlamVjdCl8fHZvaWQgMD09PUF8fEEuY2FsbCh0aGlzKSx0aGlzLm9uQ2xvc2UoKSxpKHRoaXMsZyxRLlJhaW53YXlUcmFuc3BvcnRTdGF0dXMuRGlzY29ubmVjdGVkKSx0aGlzLmRpc3Bvc2UoKSk6XCJkaXNjb25uZWN0ZWRcIj09PWU/dGhpcy5yZXBvcnRTdGF0ZUNoYW5nZShFLlJhaW53YXlQZWVyU3RhdGUuRGlzY29ubmVjdGVkKTpcImNvbm5lY3RpbmdcIj09PWU/dGhpcy5yZXBvcnRTdGF0ZUNoYW5nZShFLlJhaW53YXlQZWVyU3RhdGUuQ29ubmVjdGluZyk6XCJjb25uZWN0ZWRcIj09PWU/dGhpcy5yZXBvcnRTdGF0ZUNoYW5nZShFLlJhaW53YXlQZWVyU3RhdGUuQ29ubmVjdGVkKTpcIm5ld1wiPT09ZSYmdGhpcy5yZXBvcnRTdGF0ZUNoYW5nZShFLlJhaW53YXlQZWVyU3RhdGUuTmV3KX0sdGhpcy5oYW5kbGVEYXRhQ2hhbm5lbE1lc3NhZ2U9QT0+e2NvbnN0IGU9QS50YXJnZXQubGFiZWw7dGhpcy5oYW5kbGVMYWJlbEFuZERhdGEoZSxuZXcgVWludDhBcnJheShBLmRhdGEpKX0sdGhpcy5oYW5kbGVEYXRhQ2hhbm5lbENsb3NlPUE9Pntjb25zdCBlPUEudGFyZ2V0LmxhYmVsO28uUmFpbndheUxvZ2dpbmcud2FybmluZyhcIlJUQyBjaGFubmVsIGNsb3NlZDogXCIrZSl9LHRoaXMuaGFuZGxlRGF0YUNoYW5uZWxFcnJvcj1BPT57Y29uc3QgZT1BLnRhcmdldC5sYWJlbDtvLlJhaW53YXlMb2dnaW5nLndhcm5pbmcoXCJSVEMgY2hhbm5lbCBlcnJvcmVkOiBcIitlKX0sdGhpcy5jaHVua2VkTWVzc2FnZXM9bmV3IE1hcCx0aGlzLmhpZ2hlc3RDaHVua0dyb3VwPTA7Y29uc3Qgcj17cHJvdG9jb2w6XCJzY3RwXCIsbmVnb3RpYXRlZDohMX0sZD17b3JkZXJlZDohMSxtYXhSZXRyYW5zbWl0czowfTt0aGlzLmRhdGFDaGFubmVsc0NvbmZpZz17UldfTG9naWM6T2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHtpZDowfSxyKSx7b3JkZXJlZDohMH0pLFJXX1ZpZGVvOk9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7aWQ6MX0sciksZCksUldfQXVkaW86T2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHtpZDoyfSxyKSxkKSxSV19JbnB1dDpPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe2lkOjN9LHIpLGQpfX1jcmVhdGVEYXRhQ2hhbm5lbChBLGUpe3ZhciBJLGc7cmV0dXJuIHQodGhpcyx2b2lkIDAsdm9pZCAwLChmdW5jdGlvbiooKXtjb25zdCB0PXtwcm90b2NvbDpcInNjdHBcIixuZWdvdGlhdGVkOiExfSxpPW51bGw9PT0oST10aGlzLnBlZXJDb25uZWN0aW9uKXx8dm9pZCAwPT09ST92b2lkIDA6SS5jcmVhdGVEYXRhQ2hhbm5lbChBLGU9PT1yLlJhaW53YXlDaGFubmVsTW9kZS5SZWxpYWJsZT9PYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sdCkse29yZGVyZWQ6ITB9KTpPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sdCkse29yZGVyZWQ6ITEsbWF4UmV0cmFuc21pdHM6MH0pKTtpZighaSl0aHJvdyBuZXcgQy5SYWlud2F5RXJyb3IoXCJDb3VsZG4ndCBjcmVhdGUgRGF0YSBDaGFubmVsOiBcIitBKTtyZXR1cm4gaS5hZGRFdmVudExpc3RlbmVyKFwiY2xvc2VcIix0aGlzLmhhbmRsZURhdGFDaGFubmVsQ2xvc2UpLGkuYWRkRXZlbnRMaXN0ZW5lcihcImVycm9yXCIsdGhpcy5oYW5kbGVEYXRhQ2hhbm5lbEVycm9yKSxpLmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsdGhpcy5oYW5kbGVEYXRhQ2hhbm5lbE1lc3NhZ2UpLG51bGwhPT0oZz10aGlzLmRhdGFDaGFubmVscykmJnZvaWQgMCE9PWd8fCh0aGlzLmRhdGFDaGFubmVscz17fSksdGhpcy5kYXRhQ2hhbm5lbHNbQV09aSxuZXcgUHJvbWlzZSgoQT0+e2NvbnN0IGU9KCk9PntBKCksaS5yZW1vdmVFdmVudExpc3RlbmVyKFwib3BlblwiLGUpfTtpLmFkZEV2ZW50TGlzdGVuZXIoXCJvcGVuXCIsZSl9KSl9KSl9c2VuZE1lc3NhZ2UoQSxlKXt2YXIgSTtpZighQSl0aHJvdyBuZXcgQy5SYWlud2F5RXJyb3IoXCJzZW5kTWVzc2FnZTogbm8gbGFiZWxcIik7aWYoIXRoaXMuZGF0YUNoYW5uZWxzKXRocm93IG5ldyBDLlJhaW53YXlFcnJvcihcInNlbmRNZXNzYWdlOiBkYXRhQ2hhbm5lbHMgbm90IGluaXRpYWxpemVkXCIpO2NvbnN0IGc9bnVsbD09PShJPXRoaXMuZGF0YUNoYW5uZWxzKXx8dm9pZCAwPT09ST92b2lkIDA6SVtBXTtpZighZyl0aHJvdyBuZXcgQy5SYWlud2F5RXJyb3IoYHNlbmRNZXNzYWdlOiBjaGFubmVsIFwiJHtBfVwiIGRvZXMgbm90IGV4aXN0YCk7aWYoXCJvcGVuXCIhPT1nLnJlYWR5U3RhdGUpdGhyb3cgbmV3IEMuUmFpbndheUVycm9yKGBzZW5kTWVzc2FnZTogY2hhbm5lbCBcIiR7QX1cIiBpcyBub3Qgb3BlbmApO2cuc2VuZChlKX1nZXQgc3RhdHVzKCl7cmV0dXJuIEIodGhpcyxnKX1nZXQgbWF4TWVzc2FnZVNpemUoKXt2YXIgQSxlLEk7cmV0dXJuIG51bGwhPT0oST1udWxsPT09KGU9bnVsbD09PShBPXRoaXMucGVlckNvbm5lY3Rpb24pfHx2b2lkIDA9PT1BP3ZvaWQgMDpBLnNjdHApfHx2b2lkIDA9PT1lP3ZvaWQgMDplLm1heE1lc3NhZ2VTaXplKSYmdm9pZCAwIT09ST9JOjI2MjE0NH1nZXRTdGF0cygpe3JldHVybiB0KHRoaXMsdm9pZCAwLHZvaWQgMCwoZnVuY3Rpb24qKCl7aWYoIXRoaXMucGVlckNvbm5lY3Rpb24pdGhyb3cgbmV3IEMuUmFpbndheUVycm9yKFwiZ2V0U3RhdHMoKSBidXQgbm8gcGVlckNvbm5lY3Rpb25cIik7Y29uc3QgQT15aWVsZCB0aGlzLnBlZXJDb25uZWN0aW9uLmdldFN0YXRzKHZvaWQgMCksZT17Y2hhbm5lbHM6e30scmF3OkF9O3JldHVybiBBLmZvckVhY2goKEE9PntcImRhdGEtY2hhbm5lbFwiPT09QS50eXBlJiYoZS5jaGFubmVsc1tBLmxhYmVsXT1BKX0pKSxlfSkpfWNoZWNrSGVhZGVyKEEpe2lmKDIwMzY0MzA2NzQhPT1BLm1hZ2ljTnVtYmVyKXRocm93IG5ldyBDLlJhaW53YXlFcnJvcihcIkludmFsaWQgbWFnaWNOdW1iZXIgaW4gY2hlY2tIZWFkZXIuXCIpO2lmKEEudGFyZ2V0UGVlcklkIT09dGhpcy5vd25QZWVySWQpdGhyb3cgbmV3IEMuUmFpbndheUVycm9yKFwiSW52YWxpZCBkZXN0aW5hdGlvbiBob3N0IG5hbWUgKG5vdCBvdXJzKSBpbiBjaGVja0hlYWRlci5cIil9aGFuZGxlTGFiZWxBbmREYXRhKEEsZSl7aWYoXCJSV19Mb2dpY1wiPT09QSl7Y29uc3QgQT1uLkxvZ2ljRGF0YWdyYW0uZGVjb2RlKGUpO3RoaXMuY2hlY2tIZWFkZXIoQS5oZWFkZXIpLHRoaXMub25SYWlud2F5TWVzc2FnZSh7a2luZDpcIkxvZ2ljXCIsYm9keTpBLmJvZHl9KX1lbHNlIGlmKFwiUldfSW5wdXRcIj09PUEpe2NvbnN0IEE9bi5JbnB1dERhdGFncmFtLmRlY29kZShlKTt0aGlzLmNoZWNrSGVhZGVyKEEuaGVhZGVyKSx0aGlzLm9uUmFpbndheU1lc3NhZ2Uoe2tpbmQ6XCJJbnB1dFwiLGJvZHk6QS5ib2R5fSl9ZWxzZSBpZihcIlJXX0F1ZGlvXCI9PT1BfHxcIlJXX1ZpZGVvXCI9PUEpe2NvbnN0IEk9bi5NZWRpYURhdGFncmFtLmRlY29kZShlKTt0aGlzLmNoZWNrSGVhZGVyKEkuaGVhZGVyKSxJLmJvZHkuZGlzY3JpbWluYXRvcj09PW4uTWVkaWFDaHVuay5kaXNjcmltaW5hdG9yP3RoaXMuaGFuZGxlQ2h1bmsoQSxJLmJvZHkudmFsdWUuY2h1bmspOnRoaXMub25SYWlud2F5TWVzc2FnZSh7a2luZDpcIk1lZGlhXCIsYm9keTpJLmJvZHl9KX1lbHNlIGlmKC9eUldfLy50ZXN0KEEpKW8uUmFpbndheUxvZ2dpbmcud2FybmluZyhgVW5rbm93biBSYWlud2F5LXJlc2VydmVkIFJUQyBsYWJlbD8gJHtBfWApO2Vsc2V7Y29uc3QgST1uLkFyYml0cmFyeURhdGFncmFtLmRlY29kZShlKTt0aGlzLmNoZWNrSGVhZGVyKEkuaGVhZGVyKSx0aGlzLmhhbmRsZUNodW5rKEEsSS5ib2R5KX19Z2V0RGF0YWdyYW1IZWFkZXIoQSl7cmV0dXJue21hZ2ljTnVtYmVyOjIwMzY0MzA2NzQsc3luY0tleTpBPysrdGhpcy5zeW5jS2V5OjAsc291cmNlUGVlcklkOnRoaXMub3duUGVlcklkLHRhcmdldFBlZXJJZDp0aGlzLnRhcmdldFBlZXJJZH19c2VuZEFyYml0cmFyeURhdGFncmFtKEEsZSl7YS5lYWNoQ2h1bmsoZSwoZT0+e3RoaXMuc2VuZE1lc3NhZ2UoQSxuLkFyYml0cmFyeURhdGFncmFtLmVuY29kZSh7aGVhZGVyOnRoaXMuZ2V0RGF0YWdyYW1IZWFkZXIoITApLGJvZHk6ZX0pKX0pKX1zZW5kTG9naWNEYXRhZ3JhbShBKXt0aGlzLnNlbmRNZXNzYWdlKFwiUldfTG9naWNcIixuLkxvZ2ljRGF0YWdyYW0uZW5jb2RlKHtoZWFkZXI6dGhpcy5nZXREYXRhZ3JhbUhlYWRlcighMCksYm9keTpBfSkpfXNlbmRJbnB1dERhdGFncmFtKEEpe3RoaXMuc2VuZE1lc3NhZ2UoXCJSV19JbnB1dFwiLG4uSW5wdXREYXRhZ3JhbS5lbmNvZGUoe2hlYWRlcjp0aGlzLmdldERhdGFncmFtSGVhZGVyKCExKSxib2R5OkF9KSl9b3BlbihBKXtyZXR1cm4gdCh0aGlzLHZvaWQgMCx2b2lkIDAsKGZ1bmN0aW9uKigpe3lpZWxkIG5ldyBQcm9taXNlKCgoZSxJKT0+dCh0aGlzLHZvaWQgMCx2b2lkIDAsKGZ1bmN0aW9uKigpe3ZhciB0O3RoaXMub3BlblJlc29sdmU9ZSx0aGlzLm9wZW5SZWplY3Q9SSxpKHRoaXMsZyxRLlJhaW53YXlUcmFuc3BvcnRTdGF0dXMuQ29ubmVjdGluZyksdGhpcy5wZWVyQ29ubmVjdGlvbj1uZXcgUlRDUGVlckNvbm5lY3Rpb24odGhpcy5ydGNDb25maWd1cmF0aW9uKSx0aGlzLnBlZXJDb25uZWN0aW9uLmFkZEV2ZW50TGlzdGVuZXIoXCJpY2Vjb25uZWN0aW9uc3RhdGVjaGFuZ2VcIix0aGlzLmhhbmRsZUljZUNvbm5lY3Rpb25TdGF0ZUNoYW5nZSksdGhpcy5wZWVyQ29ubmVjdGlvbi5hZGRFdmVudExpc3RlbmVyKFwiY29ubmVjdGlvbnN0YXRlY2hhbmdlXCIsdGhpcy5oYW5kbGVDb25uZWN0aW9uU3RhdGVDaGFuZ2UpLHRoaXMuaGFuZGxlQ29ubmVjdGlvblN0YXRlQ2hhbmdlKCksbnVsbCE9PSh0PXRoaXMuZGF0YUNoYW5uZWxzKSYmdm9pZCAwIT09dHx8KHRoaXMuZGF0YUNoYW5uZWxzPXt9KTtjb25zdCBCPU9iamVjdC5rZXlzKHRoaXMuZGF0YUNoYW5uZWxzQ29uZmlnKS5sZW5ndGg7bGV0IEM9MDtjb25zdCBvPShBLEkpPT57Y29uc3QgdD0oKT0+e3ZhciBBOysrQyxDPT09QiYmKG51bGw9PT0oQT10aGlzLnBlZXJDb25uZWN0aW9uKXx8dm9pZCAwPT09QXx8QS5yZW1vdmVFdmVudExpc3RlbmVyKFwiaWNlY2FuZGlkYXRlXCIsdGhpcy5oYW5kbGVMb2NhbEljZUNhbmRpZGF0ZSksaSh0aGlzLGcsUS5SYWlud2F5VHJhbnNwb3J0U3RhdHVzLkNvbm5lY3RlZCksZSgpKSxJLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJvcGVuXCIsdCl9O0kuYWRkRXZlbnRMaXN0ZW5lcihcIm9wZW5cIix0KSxJLmFkZEV2ZW50TGlzdGVuZXIoXCJjbG9zZVwiLHRoaXMuaGFuZGxlRGF0YUNoYW5uZWxDbG9zZSksSS5hZGRFdmVudExpc3RlbmVyKFwiZXJyb3JcIix0aGlzLmhhbmRsZURhdGFDaGFubmVsRXJyb3IpLEkuYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIix0aGlzLmhhbmRsZURhdGFDaGFubmVsTWVzc2FnZSl9O2lmKFwib2ZmZXJcIj09PUEpZm9yKGNvbnN0W0EsZV1vZiBPYmplY3QuZW50cmllcyh0aGlzLmRhdGFDaGFubmVsc0NvbmZpZykpe2NvbnN0IEk9dGhpcy5wZWVyQ29ubmVjdGlvbi5jcmVhdGVEYXRhQ2hhbm5lbChBLGUpO3RoaXMuZGF0YUNoYW5uZWxzW0FdPUksSS5iaW5hcnlUeXBlPVwiYXJyYXlidWZmZXJcIixvKDAsSSl9ZWxzZSB0aGlzLnBlZXJDb25uZWN0aW9uLmFkZEV2ZW50TGlzdGVuZXIoXCJkYXRhY2hhbm5lbFwiLChBPT57dmFyIGU7Y29uc3QgST1BLmNoYW5uZWwubGFiZWw7bnVsbCE9PShlPXRoaXMuZGF0YUNoYW5uZWxzKSYmdm9pZCAwIT09ZXx8KHRoaXMuZGF0YUNoYW5uZWxzPXt9KSx0aGlzLmRhdGFDaGFubmVsc1tJXT1BLmNoYW5uZWwsbyhBLmNoYW5uZWwubGFiZWwsQS5jaGFubmVsKX0pKTt0aGlzLnBlZXJDb25uZWN0aW9uLmFkZEV2ZW50TGlzdGVuZXIoXCJpY2VjYW5kaWRhdGVcIix0aGlzLmhhbmRsZUxvY2FsSWNlQ2FuZGlkYXRlKSxcIm9mZmVyXCI9PT1BJiYoeWllbGQgdGhpcy5zZW5kT2ZmZXIoKSl9KSkpKX0pKX1zZW5kT2ZmZXIoKXtyZXR1cm4gdCh0aGlzLHZvaWQgMCx2b2lkIDAsKGZ1bmN0aW9uKigpe2lmKHZvaWQgMD09PXRoaXMucGVlckNvbm5lY3Rpb24pdGhyb3cgbmV3IEMuUmFpbndheUVycm9yKFwic2VuZE9mZmVyKCk6IG5vIHBlZXIgY29ubmVjdGlvblwiKTtjb25zdCBBPXlpZWxkIHRoaXMucGVlckNvbm5lY3Rpb24uY3JlYXRlT2ZmZXIoKTtpZih5aWVsZCB0aGlzLnBlZXJDb25uZWN0aW9uLnNldExvY2FsRGVzY3JpcHRpb24oQSksIUEuc2RwKXRocm93IG5ldyBDLlJhaW53YXlFcnJvcihcIkNyZWF0ZWQgb2ZmZXIgY29udGFpbmVkIG5vIHNkcD9cIik7dGhpcy5zZW5kTG9jYWxPZmZlclNkcChBLnNkcCl9KSl9c2VuZEFuc3dlcigpe3JldHVybiB0KHRoaXMsdm9pZCAwLHZvaWQgMCwoZnVuY3Rpb24qKCl7aWYodm9pZCAwPT09dGhpcy5wZWVyQ29ubmVjdGlvbil0aHJvdyBuZXcgQy5SYWlud2F5RXJyb3IoXCJzZW5kT2ZmZXIoKTogbm8gcGVlciBjb25uZWN0aW9uXCIpO2NvbnN0IEE9eWllbGQgdGhpcy5wZWVyQ29ubmVjdGlvbi5jcmVhdGVBbnN3ZXIoKTtpZih5aWVsZCB0aGlzLnBlZXJDb25uZWN0aW9uLnNldExvY2FsRGVzY3JpcHRpb24oQSksIUEuc2RwKXRocm93IG5ldyBDLlJhaW53YXlFcnJvcihcIkNyZWF0ZWQgYW5zd2VyIGNvbnRhaW5lZCBubyBzZHA/XCIpO3RoaXMuc2VuZExvY2FsQW5zd2VyU2RwKEEuc2RwKX0pKX1jbG9zZSgpe3ZhciBBO3RoaXMuc3RhdHVzIT09US5SYWlud2F5VHJhbnNwb3J0U3RhdHVzLkRpc2Nvbm5lY3RlZCYmKG8uUmFpbndheUxvZ2dpbmcuZGVidWcoXCJydGMtdHJhbnNwb3J0IGNsb3NlKCkuXCIpLG51bGw9PT0oQT10aGlzLnBlZXJDb25uZWN0aW9uKXx8dm9pZCAwPT09QXx8QS5jbG9zZSgpLHRoaXMub25DbG9zZSgpLHRoaXMuZGlzcG9zZSgpKX1kaXNwb3NlKCl7dmFyIEEsZSxJO2lmKG51bGw9PT0oQT10aGlzLnBlZXJDb25uZWN0aW9uKXx8dm9pZCAwPT09QXx8QS5yZW1vdmVFdmVudExpc3RlbmVyKFwiaWNlY29ubmVjdGlvbnN0YXRlY2hhbmdlXCIsdGhpcy5oYW5kbGVJY2VDb25uZWN0aW9uU3RhdGVDaGFuZ2UpLG51bGw9PT0oZT10aGlzLnBlZXJDb25uZWN0aW9uKXx8dm9pZCAwPT09ZXx8ZS5yZW1vdmVFdmVudExpc3RlbmVyKFwiY29ubmVjdGlvbnN0YXRlY2hhbmdlXCIsdGhpcy5oYW5kbGVDb25uZWN0aW9uU3RhdGVDaGFuZ2UpLG51bGw9PT0oST10aGlzLnBlZXJDb25uZWN0aW9uKXx8dm9pZCAwPT09SXx8SS5yZW1vdmVFdmVudExpc3RlbmVyKFwiaWNlY2FuZGlkYXRlXCIsdGhpcy5oYW5kbGVMb2NhbEljZUNhbmRpZGF0ZSksdGhpcy5kYXRhQ2hhbm5lbHMpZm9yKGNvbnN0IEEgb2YgT2JqZWN0LnZhbHVlcyh0aGlzLmRhdGFDaGFubmVscykpQS5yZW1vdmVFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLHRoaXMuaGFuZGxlRGF0YUNoYW5uZWxNZXNzYWdlKTt0aGlzLmRhdGFDaGFubmVscz12b2lkIDAsdGhpcy5wZWVyQ29ubmVjdGlvbj12b2lkIDAsdGhpcy5vcGVuUmVzb2x2ZT12b2lkIDAsdGhpcy5vcGVuUmVqZWN0PXZvaWQgMH1oYW5kbGVDaHVuayhBLGUpe2UuZ3JvdXBJZDx0aGlzLmhpZ2hlc3RDaHVua0dyb3VwJiYodGhpcy5jaHVua2VkTWVzc2FnZXM9bmV3IE1hcCx0aGlzLmhpZ2hlc3RDaHVua0dyb3VwPTApO2xldCBJPXRoaXMuY2h1bmtlZE1lc3NhZ2VzLmdldChlLmdyb3VwSWQpO2lmKEl8fChJPXtyZWNlaXZlZENodW5rQ291bnQ6MCxjaHVua3M6W119LHRoaXMuY2h1bmtlZE1lc3NhZ2VzLnNldChlLmdyb3VwSWQsSSkpLEkuY2h1bmtzW2UuaW5kZXhdPWUuZGF0YSxJLnJlY2VpdmVkQ2h1bmtDb3VudCsrLEkucmVjZWl2ZWRDaHVua0NvdW50PT09ZS5jaHVua3NJbkdyb3VwKXt0aGlzLmhpZ2hlc3RDaHVua0dyb3VwPWUuZ3JvdXBJZCx0aGlzLmNodW5rZWRNZXNzYWdlcy5kZWxldGUoZS5ncm91cElkKTtjb25zdCBnPWEucmVhc3NlbWJsZShJKTsvXlJXXyhMb2dpY3xJbnB1dHxBdWRpb3xWaWRlbykkLy50ZXN0KEEpP3RoaXMuaGFuZGxlTGFiZWxBbmREYXRhKEEsZyk6dGhpcy5vbkFwcGxpY2F0aW9uTWVzc2FnZShBLGcpfX19ZS5SVENUcmFuc3BvcnQ9ZCxnPW5ldyBXZWFrTWFwfSw5MDA5OihBLGUpPT57XCJ1c2Ugc3RyaWN0XCI7dmFyIEk7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksZS5SYWlud2F5VHJhbnNwb3J0PWUuUmFpbndheVRyYW5zcG9ydFN0YXR1cz12b2lkIDAsKEk9ZS5SYWlud2F5VHJhbnNwb3J0U3RhdHVzfHwoZS5SYWlud2F5VHJhbnNwb3J0U3RhdHVzPXt9KSlbSS5EaXNjb25uZWN0ZWQ9MF09XCJEaXNjb25uZWN0ZWRcIixJW0kuQ29ubmVjdGluZz0xXT1cIkNvbm5lY3RpbmdcIixJW0kuQ29ubmVjdGVkPTJdPVwiQ29ubmVjdGVkXCIsZS5SYWlud2F5VHJhbnNwb3J0PWNsYXNze319LDU0MjA6ZnVuY3Rpb24oQSxlLEkpe1widXNlIHN0cmljdFwiO3ZhciBnLHQsaSxCLEM9dGhpcyYmdGhpcy5fX2F3YWl0ZXJ8fGZ1bmN0aW9uKEEsZSxJLGcpe3JldHVybiBuZXcoSXx8KEk9UHJvbWlzZSkpKChmdW5jdGlvbih0LGkpe2Z1bmN0aW9uIEIoQSl7dHJ5e1EoZy5uZXh0KEEpKX1jYXRjaChBKXtpKEEpfX1mdW5jdGlvbiBDKEEpe3RyeXtRKGcudGhyb3coQSkpfWNhdGNoKEEpe2koQSl9fWZ1bmN0aW9uIFEoQSl7dmFyIGU7QS5kb25lP3QoQS52YWx1ZSk6KGU9QS52YWx1ZSxlIGluc3RhbmNlb2YgST9lOm5ldyBJKChmdW5jdGlvbihBKXtBKGUpfSkpKS50aGVuKEIsQyl9USgoZz1nLmFwcGx5KEEsZXx8W10pKS5uZXh0KCkpfSkpfSxRPXRoaXMmJnRoaXMuX19jbGFzc1ByaXZhdGVGaWVsZFNldHx8ZnVuY3Rpb24oQSxlLEkpe2lmKCFlLmhhcyhBKSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiYXR0ZW1wdGVkIHRvIHNldCBwcml2YXRlIGZpZWxkIG9uIG5vbi1pbnN0YW5jZVwiKTtyZXR1cm4gZS5zZXQoQSxJKSxJfSxvPXRoaXMmJnRoaXMuX19jbGFzc1ByaXZhdGVGaWVsZEdldHx8ZnVuY3Rpb24oQSxlKXtpZighZS5oYXMoQSkpdGhyb3cgbmV3IFR5cGVFcnJvcihcImF0dGVtcHRlZCB0byBnZXQgcHJpdmF0ZSBmaWVsZCBvbiBub24taW5zdGFuY2VcIik7cmV0dXJuIGUuZ2V0KEEpfTtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxlLlJhaW53YXlQZWVyPWUuUmFpbndheUNoYW5uZWxNb2RlPXZvaWQgMDtjb25zdCBuPUkoNjkwNCksYT1JKDI4MjQpLHI9SSgzNDY0KSxFPUkoODUxNCkscz1JKDc3ODMpLGQ9SSgzODc2KSxjPUkoMjk5NCk7dmFyIGg7KGg9ZS5SYWlud2F5Q2hhbm5lbE1vZGV8fChlLlJhaW53YXlDaGFubmVsTW9kZT17fSkpW2guVW5yZWxpYWJsZT0wXT1cIlVucmVsaWFibGVcIixoW2guUmVsaWFibGU9MV09XCJSZWxpYWJsZVwiO2NsYXNzIER7Y29uc3RydWN0b3IoQSxlLEksQyxvLG4sYSl7dGhpcy50cmFuc3BvcnQ9SSx0aGlzLm91dGVyT25DbG9zZT1DLHRoaXMub25FcnJvcj1vLHRoaXMub25TdHJlYW1Bbm5vdW5jZW1lbnQ9bix0aGlzLm9uU3RyZWFtU3RvcD1hLGcuc2V0KHRoaXMscy5SYWlud2F5UGVlclN0YXRlLk5ldyksdC5zZXQodGhpcyxuZXcgTWFwKSxpLnNldCh0aGlzLHZvaWQgMCksQi5zZXQodGhpcyx2b2lkIDApLHRoaXMubGFzdFRpbWVzdGFtcD12b2lkIDAsUSh0aGlzLGksQSksUSh0aGlzLEIsZSksSS5vblJhaW53YXlNZXNzYWdlPXRoaXMub25NZXNzYWdlLmJpbmQodGhpcyksSS5vbkNsb3NlPXRoaXMub25DbG9zZS5iaW5kKHRoaXMpLHRoaXMucmVhZHlUb1N0cmVhbT1uZXcgUHJvbWlzZSgoKEEsZSk9Pnt0aGlzLnJlc29sdmVSZWFkeVRvU3RyZWFtPUF9KSl9Z2V0IHN0YXRlKCl7cmV0dXJuIG8odGhpcyxnKX1nZXQgZGlzY29ubmVjdGVkKCl7cmV0dXJuIHRoaXMuc3RhdGU9PT1zLlJhaW53YXlQZWVyU3RhdGUuRGlzY29ubmVjdGVkfHx0aGlzLnN0YXRlPT09cy5SYWlud2F5UGVlclN0YXRlLkZhaWxlZH1nZXQgc3RyZWFtKCl7Y29uc3QgQT1bLi4ubyh0aGlzLHQpLmVudHJpZXMoKV07aWYoMCE9PUEubGVuZ3RoKXJldHVybiBBLnNvcnQoKChBLGUpPT5BWzBdLWVbMF0pKSxBWzBdWzFdfWdldCBzdHJlYW1zKCl7cmV0dXJuIG8odGhpcyx0KX1nZXQgcGVlcklkKCl7cmV0dXJuIG8odGhpcyxpKX1nZXQgZXh0ZXJuYWxJZCgpe3JldHVybiBvKHRoaXMsQil9b25DbG9zZSgpe3RoaXMub25QZWVyU3RhdGVDaGFuZ2Uocy5SYWlud2F5UGVlclN0YXRlLkZhaWxlZCl9b25QZWVyU3RhdGVDaGFuZ2UoQSl7USh0aGlzLGcsQSksQT09PXMuUmFpbndheVBlZXJTdGF0ZS5GYWlsZWQmJih0aGlzLmRpc3Bvc2UoKSx0aGlzLm91dGVyT25DbG9zZSgpKX1zZW5kRGV2aWNlSW5mb0FuZEV4Y2hhbmdlQ29kZWNzKCl7aWYodGhpcy5kaXNjb25uZWN0ZWQpdGhyb3cgbmV3IGMuUmFpbndheUVycm9yKFwiQ291bGRuJ3Qgc2VuZCBkZXZpY2UgaW5mbyBhbmQgZXhjaGFuZ2UgY29kZWNzOiBwZWVyIGlzIGRpc2Nvbm5lY3RlZFwiKTt0aGlzLnNlbmREZXZpY2VJbmZvKCksdGhpcy5leGNoYW5nZUNvZGVjcygpLnRoZW4oKEE9Pnt2YXIgZSxJOzA9PT1BLmxlbmd0aD9udWxsPT09KGU9dGhpcy5yZXNvbHZlUmVhZHlUb1N0cmVhbSl8fHZvaWQgMD09PWV8fGUuY2FsbCh0aGlzLCExKToodGhpcy50cmFuc3BvcnQuc2VuZExvZ2ljRGF0YWdyYW0oe2Rpc2NyaW1pbmF0b3I6bi5DbGllbnRDYXBhYmlsaXRpZXMuZGlzY3JpbWluYXRvcix2YWx1ZTpFLm1ha2VDbGllbnRDYXBhYmlsaXRpZXMoQSl9KSxudWxsPT09KEk9dGhpcy5yZXNvbHZlUmVhZHlUb1N0cmVhbSl8fHZvaWQgMD09PUl8fEkuY2FsbCh0aGlzLCEwKSl9KSl9b25NZXNzYWdlKEEpe1wiTG9naWNcIj09PUEua2luZD90aGlzLmhhbmRsZUxvZ2ljTWVzc2FnZShBLmJvZHkpOlwiSW5wdXRcIj09PUEua2luZD90aGlzLmhhbmRsZUlucHV0TWVzc2FnZShBLmJvZHkpOlwiTWVkaWFcIj09PUEua2luZCYmdGhpcy5oYW5kbGVNZWRpYU1lc3NhZ2UoQS5ib2R5KX1zZW5kRGV2aWNlSW5mbygpe2lmKHRoaXMuZGlzY29ubmVjdGVkKXRocm93IG5ldyBjLlJhaW53YXlFcnJvcihcIkNvdWxkbid0IHNlbmQgZGV2aWNlIGluZm86IHBlZXIgaXMgZGlzY29ubmVjdGVkXCIpO3RoaXMudHJhbnNwb3J0LnNlbmRMb2dpY0RhdGFncmFtKHtkaXNjcmltaW5hdG9yOm4uRGV2aWNlSW5mby5kaXNjcmltaW5hdG9yLHZhbHVlOntpc1dlYjohMCxmb3JtRmFjdG9yOm4uRm9ybUZhY3Rvci5Db21wdXRlcixkZXZpY2VOYW1lOlwiZGV2aWNlTmFtZVwiLGRldmljZUlkOlwiZGV2aWNlSWRcIixkZXZpY2VNb2RlbDpcIlwiLGRldmljZU9zOm4uT3BlcmF0aW5nU3lzdGVtLk90aGVyLGRldmljZU9zVmVyc2lvbjpcIlwiLHVzZXJBZ2VudDpuYXZpZ2F0b3IudXNlckFnZW50fX0pfXNlbmQoQSxlKXtpZihBLnN0YXJ0c1dpdGgoXCJSV19cIikpdGhyb3cgbmV3IGMuUmFpbndheUVycm9yKFwiRGF0YSBjaGFubmVsIG5hbWVzIHN0YXJ0aW5nIHdpdGggUldfIGFyZSByZXNlcnZlZCBmb3IgUmFpbndheVwiKTtpZih0aGlzLmRpc2Nvbm5lY3RlZCl0aHJvdyBuZXcgYy5SYWlud2F5RXJyb3IoXCJDb3VsZG4ndCBzZW5kIG1lc3NhZ2U6IHBlZXIgaXMgZGlzY29ubmVjdGVkXCIpO2NvbnN0IEk9XCJzdHJpbmdcIj09dHlwZW9mIGU/RC50ZXh0RW5jb2Rlci5lbmNvZGUoZSk6ZTt0aGlzLnRyYW5zcG9ydC5zZW5kQXJiaXRyYXJ5RGF0YWdyYW0oQSxJKX1kaXNjb25uZWN0KCl7dGhpcy5kaXNwb3NlKCksdGhpcy50cmFuc3BvcnQuY2xvc2UoKX1kaXNwb3NlKCl7Zm9yKGNvbnN0IEEgb2Ygbyh0aGlzLHQpLnZhbHVlcygpKUEubGVhdmUoKTtvKHRoaXMsdCkuY2xlYXIoKX1yZXF1ZXN0U3RyZWFtKEEpe3JldHVybiBDKHRoaXMsdm9pZCAwLHZvaWQgMCwoZnVuY3Rpb24qKCl7aWYodGhpcy5kaXNjb25uZWN0ZWQpdGhyb3cgbmV3IGMuUmFpbndheUVycm9yKFwiQ291bGRuJ3QgcmVxdWVzdCBzdHJlYW06IHBlZXIgaXMgZGlzY29ubmVjdGVkXCIpO3JldHVybiB5aWVsZCB0aGlzLnJlYWR5VG9TdHJlYW0seWllbGQgdGhpcy5leGNoYW5nZUNvZGVjcygpLnRoZW4oKEE9PntpZigwPT09QS5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiVW5hYmxlIHRvIHJlLW5lZ290aWF0ZSBjb2RlY3NcIik7dGhpcy50cmFuc3BvcnQuc2VuZExvZ2ljRGF0YWdyYW0oe2Rpc2NyaW1pbmF0b3I6bi5DbGllbnRDYXBhYmlsaXRpZXMuZGlzY3JpbWluYXRvcix2YWx1ZTpFLm1ha2VDbGllbnRDYXBhYmlsaXRpZXMoQSl9KX0pKSx0aGlzLnRyYW5zcG9ydC5zZW5kTG9naWNEYXRhZ3JhbSh7ZGlzY3JpbWluYXRvcjpuLlN0cmVhbVJlcXVlc3QuZGlzY3JpbWluYXRvcix2YWx1ZTp7aW5wdXRMZXZlbDpBfX0pLG5ldyBQcm9taXNlKCgoQSxlKT0+e3RoaXMucmVzb2x2ZVN0cmVhbT1BLHRoaXMucmVqZWN0U3RyZWFtPWV9KSl9KSl9aGFuZGxlTG9naWNNZXNzYWdlKEEpe3ZhciBlO3JldHVybiBDKHRoaXMsdm9pZCAwLHZvaWQgMCwoZnVuY3Rpb24qKCl7aWYoQS5kaXNjcmltaW5hdG9yPT09bi5EZXZpY2VJbmZvLmRpc2NyaW1pbmF0b3Ipci5SYWlud2F5TG9nZ2luZy5kZWJ1ZyhcIkdvdCByZW1vdGUgRGV2aWNlSW5mbzpcXG5cIitKU09OLnN0cmluZ2lmeShBLnZhbHVlKSk7ZWxzZSBpZihBLmRpc2NyaW1pbmF0b3I9PT1uLkNvZGVjUGFja1JlcXVlc3QuZGlzY3JpbWluYXRvcil0aGlzLnRyYW5zcG9ydC5zZW5kTG9naWNEYXRhZ3JhbSh7ZGlzY3JpbWluYXRvcjpuLkNvZGVjUGFja1Jlc3BvbnNlLmRpc2NyaW1pbmF0b3IsdmFsdWU6e3ZpZGVvQ29kZWNzOltdfX0pO2Vsc2UgaWYoQS5kaXNjcmltaW5hdG9yPT09bi5Db2RlY1BhY2tSZXNwb25zZS5kaXNjcmltaW5hdG9yKW51bGw9PT0oZT10aGlzLmNvZGVjc1Jlc29sdmUpfHx2b2lkIDA9PT1lfHxlLmNhbGwodGhpcyxBLnZhbHVlLnZpZGVvQ29kZWNzKTtlbHNlIGlmKEEuZGlzY3JpbWluYXRvcj09PW4uQ2xpZW50Q2FwYWJpbGl0aWVzLmRpc2NyaW1pbmF0b3Ipci5SYWlud2F5TG9nZ2luZy5kZWJ1ZyhcIkdvdCByZW1vdGUgQ2xpZW50Q2FwYWJpbGl0aWVzOlxcblwiK0pTT04uc3RyaW5naWZ5KEEudmFsdWUpKTtlbHNlIGlmKEEuZGlzY3JpbWluYXRvcj09PW4uU3RyZWFtUmVxdWVzdC5kaXNjcmltaW5hdG9yKXIuUmFpbndheUxvZ2dpbmcud2FybmluZyhcIkdvdCByZW1vdGUgU3RyZWFtUmVxdWVzdD9cXG5cIitKU09OLnN0cmluZ2lmeShBLnZhbHVlKSk7ZWxzZSBpZihBLmRpc2NyaW1pbmF0b3I9PT1uLlN0cmVhbUFubm91bmNlbWVudC5kaXNjcmltaW5hdG9yKWlmKHZvaWQgMCE9PXRoaXMucmVzb2x2ZVN0cmVhbSl7Y29uc3QgZT15aWVsZCB0aGlzLmNyZWF0ZVN0cmVhbShBLnZhbHVlLnN0cmVhbUluZm8pO28odGhpcyx0KS5zZXQoZS5zdHJlYW1JZCxlKSx0aGlzLnRyYW5zcG9ydC5zZW5kTG9naWNEYXRhZ3JhbSh7ZGlzY3JpbWluYXRvcjpuLkpvaW5TdHJlYW0uZGlzY3JpbWluYXRvcix2YWx1ZTp7c3RyZWFtSWQ6QS52YWx1ZS5zdHJlYW1JbmZvLnN0cmVhbUlkfX0pLHRoaXMucmVzb2x2ZVN0cmVhbShlKSx0aGlzLnJlc29sdmVTdHJlYW09dm9pZCAwLHRoaXMucmVqZWN0U3RyZWFtPXZvaWQgMH1lbHNlIHRoaXMub25TdHJlYW1Bbm5vdW5jZW1lbnQoe2luZm86QS52YWx1ZS5zdHJlYW1JbmZvLGpvaW46KCk9PkModGhpcyx2b2lkIDAsdm9pZCAwLChmdW5jdGlvbiooKXtjb25zb2xlLmxvZyhcIkpvaW5pbmcgc3RyZWFtXCIpO2NvbnN0IGU9eWllbGQgdGhpcy5jcmVhdGVTdHJlYW0oQS52YWx1ZS5zdHJlYW1JbmZvKTtyZXR1cm4gbyh0aGlzLHQpLnNldChlLnN0cmVhbUlkLGUpLHRoaXMudHJhbnNwb3J0LnNlbmRMb2dpY0RhdGFncmFtKHtkaXNjcmltaW5hdG9yOm4uSm9pblN0cmVhbS5kaXNjcmltaW5hdG9yLHZhbHVlOntzdHJlYW1JZDpBLnZhbHVlLnN0cmVhbUluZm8uc3RyZWFtSWR9fSksdGhpcy5yZXNvbHZlU3RyZWFtPXZvaWQgMCx0aGlzLnJlamVjdFN0cmVhbT12b2lkIDAsZX0pKX0pO2Vsc2UgQS5kaXNjcmltaW5hdG9yPT09bi5SZWplY3RTdHJlYW1SZXF1ZXN0LmRpc2NyaW1pbmF0b3I/dm9pZCAwIT09dGhpcy5yZWplY3RTdHJlYW0/KHRoaXMucmVqZWN0U3RyZWFtKEEudmFsdWUucmVhc29uKSx0aGlzLnJlc29sdmVTdHJlYW09dm9pZCAwLHRoaXMucmVqZWN0U3RyZWFtPXZvaWQgMCk6ci5SYWlud2F5TG9nZ2luZy53YXJuaW5nKFwiR290IFJlamVjdFN0cmVhbVJlcXVlc3QsIGJ1dCBkaWRuJ3QgYXNrIGZvciBhIHN0cmVhbS5cIik6QS5kaXNjcmltaW5hdG9yPT09bi5MZWF2ZVN0cmVhbS5kaXNjcmltaW5hdG9yP3IuUmFpbndheUxvZ2dpbmcud2FybmluZyhcIkdvdCByZW1vdGUgTGVhdmVTdHJlYW0/XFxuXCIrSlNPTi5zdHJpbmdpZnkoQS52YWx1ZSkpOkEuZGlzY3JpbWluYXRvcj09PW4uU3RyZWFtU3RvcHBpbmcuZGlzY3JpbWluYXRvciYmKHIuUmFpbndheUxvZ2dpbmcuZGVidWcoXCJHb3QgcmVtb3RlIFN0cmVhbVN0b3BwaW5nOlxcblwiK0pTT04uc3RyaW5naWZ5KEEudmFsdWUpKSx0aGlzLmRpc2NhcmRTdHJlYW0oQS52YWx1ZS5zdHJlYW1JZCkpfSkpfWNyZWF0ZVN0cmVhbShBKXtyZXR1cm4gZC5SYWlud2F5U3RyZWFtLmNyZWF0ZUFuZEluaXRpYWxpemUodGhpcyxBLnN0cmVhbUlkLEEuZGVmYXVsdElucHV0TGV2ZWwsQS5jaG9zZW5BdWRpb0NvbmZpZyxBLmNob3NlblZpZGVvQ29uZmlnLEEuc3RyZWFtVHlwZSwoZT0+dGhpcy50cmFuc3BvcnQuc2VuZElucHV0RGF0YWdyYW0oe3N0cmVhbUlkOkEuc3RyZWFtSWQsaW5uZXI6ZX0pKSwoQT0+dGhpcy50cmFuc3BvcnQuc2VuZExvZ2ljRGF0YWdyYW0oQSkpLCgoKT0+dGhpcy50cmFuc3BvcnQuZ2V0U3RhdHMoKSksKCgpPT50aGlzLmRpc2NhcmRTdHJlYW0oQS5zdHJlYW1JZCkpKX1kaXNjYXJkU3RyZWFtKEEpe2NvbnN0IGU9byh0aGlzLHQpLmdldChBKTt2b2lkIDAhPT1lJiZ0aGlzLm9uU3RyZWFtU3RvcChlKSxvKHRoaXMsdCkuZGVsZXRlKEEpfWhhbmRsZUlucHV0TWVzc2FnZShBKXt2YXIgZTtjb25zdCBJPUEuaW5uZXI7aWYoSS5kaXNjcmltaW5hdG9yPT09bi5HYW1lcGFkUnVtYmxlLmRpc2NyaW1pbmF0b3Ipe2NvbnN0IEE9SS52YWx1ZS5sZWZ0TW90b3JTcGVlZCxlPUkudmFsdWUucmlnaHRNb3RvclNwZWVkO2EuUmFpbndheUlucHV0TWFuYWdlci52aWJyYXRlR2FtZXBhZChJLnZhbHVlLnBvcnQse2R1cmF0aW9uOjEwMCxzdGFydERlbGF5OjAsc3Ryb25nTWFnbml0dWRlOk1hdGgubWF4KEEsZSkvNjU1MzUsd2Vha01hZ25pdHVkZTowfSl9ZWxzZSBpZihJLmRpc2NyaW1pbmF0b3I9PT1uLlNldENsaXBib2FyZFRleHQuZGlzY3JpbWluYXRvcil7Y29uc3QgQT1JLnZhbHVlLnRleHQ7XCJmdW5jdGlvblwiPT10eXBlb2YobnVsbD09PShlPW51bGw9PT1uYXZpZ2F0b3J8fHZvaWQgMD09PW5hdmlnYXRvcj92b2lkIDA6bmF2aWdhdG9yLmNsaXBib2FyZCl8fHZvaWQgMD09PWU/dm9pZCAwOmUud3JpdGVUZXh0KSYmbmF2aWdhdG9yLmNsaXBib2FyZC53cml0ZVRleHQoQSkudGhlbigoKCk9Pnt9KSl9ZWxzZSByLlJhaW53YXlMb2dnaW5nLndhcm5pbmcoYElnbm9yaW5nIHVucmVjb2duaXplZCBJbnB1dCBkaXNjcmltaW5hdG9yICR7SS5kaXNjcmltaW5hdG9yfWApfWhhbmRsZU1lZGlhTWVzc2FnZShBKXtpZihBLmRpc2NyaW1pbmF0b3I9PT1uLlZpZGVvRGF0YS5kaXNjcmltaW5hdG9yKXtjb25zdHtkYXRhOmUsc2VnbWVudFRpbWU6SSx0eXBlOmcsZGVza3RvcFJlY3Q6aSxtYXNrOkIsc3RyZWFtSWQ6Q309QS52YWx1ZSxRPW8odGhpcyx0KS5nZXQoQyk7aWYoIVEpcmV0dXJuO2NvbnN0IGE9ZS5idWZmZXIuc2xpY2UoZS5ieXRlT2Zmc2V0LGUuYnl0ZU9mZnNldCtlLmxlbmd0aCksRT0xZS00Kk51bWJlcihJKTtnPT09bi5WaWRlb0RhdGFUeXBlLkZyYW1lRGlmZiYmdm9pZCAwIT09dGhpcy5sYXN0VGltZXN0YW1wJiZFLXRoaXMubGFzdFRpbWVzdGFtcDwzJiZyLlJhaW53YXlMb2dnaW5nLndhcm5pbmcoYERpZmZlcmVuY2UgYmV0d2VlbiBzdWNjZXNzaXZlIHRpbWVzdGFtcHMgd2FzICR7KEUtdGhpcy5sYXN0VGltZXN0YW1wKS50b0ZpeGVkKDEpfWApLGchPT1uLlZpZGVvRGF0YVR5cGUuTWV0YWRhdGEmJih0aGlzLmxhc3RUaW1lc3RhbXA9RSksUS5yZW5kZXJWaWRlb0ZyYW1lKHt0aW1lc3RhbXA6RSx4OmkubGVmdCx5OmkudG9wLHdpZHRoOmkud2lkdGgsaGVpZ2h0OmkuaGVpZ2h0LG1hc2s6Qn0sYSl9ZWxzZSBpZihBLmRpc2NyaW1pbmF0b3I9PT1uLlBvaW50ZXJEYXRhLmRpc2NyaW1pbmF0b3Ipe2NvbnN0IGU9byh0aGlzLHQpLmdldChBLnZhbHVlLnN0cmVhbUlkKTtpZighZSlyZXR1cm47ZS5wcm9jZXNzQ3Vyc29yKHt4OkEudmFsdWUucG9zaXRpb25YLHk6QS52YWx1ZS5wb3NpdGlvblksc3BvdFg6QS52YWx1ZS5zcG90WCxzcG90WTpBLnZhbHVlLnNwb3RZLHNoYXBlV2lkdGg6QS52YWx1ZS5zaGFwZVdpZHRoLHNoYXBlSGVpZ2h0OkEudmFsdWUuc2hhcGVIZWlnaHQsZXh0ZW50V2lkdGg6QS52YWx1ZS5tb25pdG9yV2lkdGgsZXh0ZW50SGVpZ2h0OkEudmFsdWUubW9uaXRvckhlaWdodCx2aXNpYmxlOkEudmFsdWUudmlzaWJsZSxoYXNQb2ludGVySW1hZ2U6QS52YWx1ZS5kYXRhLmxlbmd0aD4wLHBvaW50ZXJJbWFnZTpBLnZhbHVlLmRhdGF9KX1lbHNlIGlmKEEuZGlzY3JpbWluYXRvcj09PW4uQXVkaW9EYXRhLmRpc2NyaW1pbmF0b3Ipe2NvbnN0IGU9byh0aGlzLHQpLmdldChBLnZhbHVlLnN0cmVhbUlkKTtpZighZSlyZXR1cm47Y29uc3R7ZGF0YTpJLHR5cGU6Z309QS52YWx1ZSxpPUkuYnVmZmVyLnNsaWNlKEkuYnl0ZU9mZnNldCxJLmJ5dGVPZmZzZXQrSS5sZW5ndGgpO2UucHJvY2Vzc0F1ZGlvKGkpfX1leGNoYW5nZUNvZGVjcygpe3JldHVybiBDKHRoaXMsdm9pZCAwLHZvaWQgMCwoZnVuY3Rpb24qKCl7aWYodGhpcy5kaXNjb25uZWN0ZWQpdGhyb3cgbmV3IGMuUmFpbndheUVycm9yKFwiQ291bGRuJ3QgZXhjaGFuZ2UgY29kZWNzOiBwZWVyIGlzIGRpc2Nvbm5lY3RlZFwiKTtjb25zdCBBPXlpZWxkIG5ldyBQcm9taXNlKChBPT57dGhpcy50cmFuc3BvcnQuc2VuZExvZ2ljRGF0YWdyYW0oe2Rpc2NyaW1pbmF0b3I6bi5Db2RlY1BhY2tSZXF1ZXN0LmRpc2NyaW1pbmF0b3IsdmFsdWU6e319KSx0aGlzLmNvZGVjc1Jlc29sdmU9QX0pKTtyZXR1cm4gdGhpcy5jb2RlY3NSZXNvbHZlPXZvaWQgMCxBfSkpfWNyZWF0ZURhdGFDaGFubmVsKEEsZSl7cmV0dXJuIEModGhpcyx2b2lkIDAsdm9pZCAwLChmdW5jdGlvbiooKXtpZihBLnN0YXJ0c1dpdGgoXCJSV19cIikpdGhyb3cgbmV3IGMuUmFpbndheUVycm9yKFwiRGF0YSBjaGFubmVsIG5hbWVzIHN0YXJ0aW5nIHdpdGggUldfIGFyZSByZXNlcnZlZCBmb3IgUmFpbndheVwiKTtyZXR1cm4gdGhpcy50cmFuc3BvcnQuY3JlYXRlRGF0YUNoYW5uZWwoQSxlKX0pKX1saXN0U3RyZWFtcygpe3JldHVybiBDKHRoaXMsdm9pZCAwLHZvaWQgMCwoZnVuY3Rpb24qKCl7aWYodGhpcy5kaXNjb25uZWN0ZWQpdGhyb3cgbmV3IGMuUmFpbndheUVycm9yKFwiQ291bGRuJ3QgbGlzdCBzdHJlYW1zLiBQZWVyIGRpc2Nvbm5lY3RlZC5cIik7dGhpcy50cmFuc3BvcnQuc2VuZExvZ2ljRGF0YWdyYW0oe2Rpc2NyaW1pbmF0b3I6bi5MaXN0U3RyZWFtcy5kaXNjcmltaW5hdG9yLHZhbHVlOnt9fSl9KSl9fWUuUmFpbndheVBlZXI9RCxnPW5ldyBXZWFrTWFwLHQ9bmV3IFdlYWtNYXAsaT1uZXcgV2Vha01hcCxCPW5ldyBXZWFrTWFwLEQudGV4dEVuY29kZXI9bmV3IFRleHRFbmNvZGVyfSw3NzgzOmZ1bmN0aW9uKEEsZSxJKXtcInVzZSBzdHJpY3RcIjt2YXIgZyx0LGksQixDLFEsbz10aGlzJiZ0aGlzLl9fYXdhaXRlcnx8ZnVuY3Rpb24oQSxlLEksZyl7cmV0dXJuIG5ldyhJfHwoST1Qcm9taXNlKSkoKGZ1bmN0aW9uKHQsaSl7ZnVuY3Rpb24gQihBKXt0cnl7UShnLm5leHQoQSkpfWNhdGNoKEEpe2koQSl9fWZ1bmN0aW9uIEMoQSl7dHJ5e1EoZy50aHJvdyhBKSl9Y2F0Y2goQSl7aShBKX19ZnVuY3Rpb24gUShBKXt2YXIgZTtBLmRvbmU/dChBLnZhbHVlKTooZT1BLnZhbHVlLGUgaW5zdGFuY2VvZiBJP2U6bmV3IEkoKGZ1bmN0aW9uKEEpe0EoZSl9KSkpLnRoZW4oQixDKX1RKChnPWcuYXBwbHkoQSxlfHxbXSkpLm5leHQoKSl9KSl9LG49dGhpcyYmdGhpcy5fX2NsYXNzUHJpdmF0ZUZpZWxkU2V0fHxmdW5jdGlvbihBLGUsSSl7aWYoIWUuaGFzKEEpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJhdHRlbXB0ZWQgdG8gc2V0IHByaXZhdGUgZmllbGQgb24gbm9uLWluc3RhbmNlXCIpO3JldHVybiBlLnNldChBLEkpLEl9LGE9dGhpcyYmdGhpcy5fX2NsYXNzUHJpdmF0ZUZpZWxkR2V0fHxmdW5jdGlvbihBLGUpe2lmKCFlLmhhcyhBKSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiYXR0ZW1wdGVkIHRvIGdldCBwcml2YXRlIGZpZWxkIG9uIG5vbi1pbnN0YW5jZVwiKTtyZXR1cm4gZS5nZXQoQSl9O09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLGUuUmFpbndheVJ1bnRpbWU9ZS5SYWlud2F5UGVlclN0YXRlPXZvaWQgMDtjb25zdCByPUkoOTEwNCksRT1JKDI5OTQpLHM9SSgzNDY0KSxkPUkoMzE0NSksYz1JKDY5MDQpLGg9SSg1NDIwKTt2YXIgRDtudWxsIT09KGc9KGk9RGF0YVZpZXcucHJvdG90eXBlKS5zZXRCaWdVaW50NjQpJiZ2b2lkIDAhPT1nfHwoaS5zZXRCaWdVaW50NjQ9ZnVuY3Rpb24oQSxlLEkpe2NvbnN0IGc9QmlnSW50KDQyOTQ5NjcyOTUpLHQ9TnVtYmVyKGU+PkJpZ0ludCgzMikmZyksaT1OdW1iZXIoZSZnKSxbQixDXT1JP1s0LDBdOlswLDRdO3RoaXMuc2V0VWludDMyKEErQix0LEkpLHRoaXMuc2V0VWludDMyKEErQyxpLEkpfSksbnVsbCE9PSh0PShCPURhdGFWaWV3LnByb3RvdHlwZSkuZ2V0QmlnVWludDY0KSYmdm9pZCAwIT09dHx8KEIuZ2V0QmlnVWludDY0PWZ1bmN0aW9uKEEsZSl7Y29uc3RbSSxnXT1lP1s0LDBdOlswLDRdLHQ9QmlnSW50KHRoaXMuZ2V0VWludDMyKEErSSxlKSksaT1CaWdJbnQodGhpcy5nZXRVaW50MzIoQStnLGUpKTtyZXR1cm4gdDw8QmlnSW50KDMyKXxpfSksZnVuY3Rpb24oQSl7QVtBLk5ldz0wXT1cIk5ld1wiLEFbQS5Db25uZWN0aW5nPTFdPVwiQ29ubmVjdGluZ1wiLEFbQS5Db25uZWN0ZWQ9Ml09XCJDb25uZWN0ZWRcIixBW0EuRGlzY29ubmVjdGVkPTNdPVwiRGlzY29ubmVjdGVkXCIsQVtBLkZhaWxlZD00XT1cIkZhaWxlZFwifShEPWUuUmFpbndheVBlZXJTdGF0ZXx8KGUuUmFpbndheVBlZXJTdGF0ZT17fSkpO2NsYXNzIHV7Y29uc3RydWN0b3IoQSxlKXt2YXIgSTtDLnNldCh0aGlzLHZvaWQgMCksUS5zZXQodGhpcyxuZXcgTWFwKSx0aGlzLmNvbm5lY3Rpb25UcmFuc3BvcnRzPW5ldyBNYXAsdGhpcy5kb2N1bWVudFZpc2liaWxpdHlDaGFuZ2VIYW5kbGVyPSgpPT57aWYoZG9jdW1lbnQuaGlkZGVuKWZvcihjb25zdCBBIG9mIHRoaXMucGVlcnMudmFsdWVzKCkpZm9yKGNvbnN0IGUgb2YgQS5zdHJlYW1zLnZhbHVlcygpKWUucmVsZWFzZUtleXMoKSxlLnBhdXNlKCk7ZWxzZSBmb3IoY29uc3QgQSBvZiB0aGlzLnBlZXJzLnZhbHVlcygpKWZvcihjb25zdCBlIG9mIEEuc3RyZWFtcy52YWx1ZXMoKSllLnBsYXkoKX0sdGhpcy53aW5kb3dCbHVySGFuZGxlcj0oKT0+e2Zvcihjb25zdCBBIG9mIHRoaXMucGVlcnMudmFsdWVzKCkpZm9yKGNvbnN0IGUgb2YgQS5zdHJlYW1zLnZhbHVlcygpKWUucmVsZWFzZUtleXMoKX0sdGhpcy5iZWZvcmVVbmxvYWRIYW5kbGVyPUE9Pntjb25zdCBlPWxvY2F0aW9uLmhhc2g7cmV0dXJuWy4uLnRoaXMucGVlcnMudmFsdWVzKCldLnNvbWUoKEE9PkEuc3RyZWFtcy5zaXplPjApKSYmKHNldFRpbWVvdXQoKCgpPT57bG9jYXRpb24uaGFzaD1cIj9oaj1cIit+fig5OTk5Kk1hdGgucmFuZG9tKCkpLGxvY2F0aW9uLmhhc2g9ZX0pLDApLEEucHJldmVudERlZmF1bHQoKSxBLnJldHVyblZhbHVlPVwiXCIpLCExfSxuKHRoaXMsQyxBKSx0aGlzLmNvbmZpZz1lLHRoaXMuY29uZmlnLmxvZ1NpbmsmJnRoaXMuc2V0TG9nU2luayh0aGlzLmNvbmZpZy5sb2dTaW5rKSx0aGlzLmdhdGV3YXk9bmV3IHIuR2F0ZXdheShhKHRoaXMsQyksdGhpcy5jb25maWcuYXBpS2V5LG51bGwhPT0oST10aGlzLmNvbmZpZy5leHRlcm5hbElkKSYmdm9pZCAwIT09ST9JOlwiXCIsKEE9PnRoaXMuaGFuZGxlUGVlckluZm8oQSkpLChBPT57dmFyIGUsSTtyZXR1cm4gbnVsbD09PShJPShlPXRoaXMuY29uZmlnKS5vbkNvbm5lY3Rpb25SZXF1ZXN0KXx8dm9pZCAwPT09ST92b2lkIDA6SS5jYWxsKGUsdGhpcyxBKX0pLCgoQSxlLEkpPT50aGlzLmFkZFBlZXIoQSxlLEksXCJhbnN3ZXJcIikpKSx0aGlzLmdhdGV3YXkuY29ubmVjdGlvbkxvc3RFdmVudC5hZGRIYW5kbGVyKChBPT57dmFyIGUsSTtudWxsPT09KEk9KGU9dGhpcy5jb25maWcpLm9uUnVudGltZUNvbm5lY3Rpb25Mb3N0KXx8dm9pZCAwPT09SXx8SS5jYWxsKGUsdGhpcyxBKSx0aGlzLmRpc2Nvbm5lY3RBbGxQZWVycygpfSkpfWdldCBwZWVycygpe3JldHVyblsuLi5hKHRoaXMsUSkudmFsdWVzKCldfXN0YXRpYyBpbml0aWFsaXplKEEpe3JldHVybiBvKHRoaXMsdm9pZCAwLHZvaWQgMCwoZnVuY3Rpb24qKCl7aWYodS5pbml0aWFsaXplZCl0aHJvdyBuZXcgRS5SYWlud2F5RXJyb3IoXCJSYWlud2F5UnVudGltZSBtYXkgb25seSBiZSBpbml0aWFsaXplZCBvbmNlLiBEb24ndCB3b3JyeTogeW91IGNhbiBtYW5hZ2UgbXVsdGlwbGUgUmFpbndheSBjb25uZWN0aW9ucyBmcm9tIGEgc2luZ2xlIFJhaW53YXlSdW50aW1lIG9iamVjdC5cIik7Y29uc3QgZT15aWVsZCByLmdldFBlZXJJZChBLmFwaUtleSksST1uZXcgdShlLEEpO3JldHVybiB5aWVsZCBJLmdhdGV3YXkuY29ubmVjdCgpLEkuYWRkTGlzdGVuZXJzKCksdS5pbml0aWFsaXplZD0hMCxJfSkpfWdldFBlZXJJZCgpe3JldHVybiBhKHRoaXMsQyl9Y29ubmVjdChBKXtyZXR1cm4gbyh0aGlzLHZvaWQgMCx2b2lkIDAsKGZ1bmN0aW9uKigpe2lmKHlpZWxkIHRoaXMuZ2F0ZXdheS5jb25uZWN0KCksYSh0aGlzLFEpLmhhcyhBKSl0aHJvdyBuZXcgRS5SYWlud2F5RXJyb3IoYEFscmVhZHkgY29ubmVjdGVkIHRvICR7QX1gKTtjb25zdCBlPXlpZWxkIHRoaXMuZ2F0ZXdheS5jb25uZWN0VG9Ib3N0KEEsYy5QZWVyVHJhbnNwb3J0VHlwZS5TQ1RQKTtpZihlLmNhbmNlbGVkKXRocm93IG5ldyBFLlJhaW53YXlFcnJvcihcIlRoZSBjb25uZWN0aW9uIGF0dGVtcHQgd2FzIGNhbmNlbGVkLlwiKTtpZighZS5hY2NlcHRlZCl0aHJvdyBuZXcgRS5SYWlud2F5RXJyb3IoYFRoZSBwZWVyIGF0ICR7QX0gcmVqZWN0ZWQgdGhlIGNvbm5lY3Rpb24sIHdpdGggcmVhc29uOiAke2UucmVhc29ufWApO3JldHVybiB0aGlzLmFkZFBlZXIoQSxlLmhvc3RFeHRlcm5hbElkLGUuY29ubmVjdGlvblJlcXVlc3RJZCxcIm9mZmVyXCIpfSkpfWFkZFBlZXIoQSxlLEksZyl7dmFyIHQsaTtyZXR1cm4gbyh0aGlzLHZvaWQgMCx2b2lkIDAsKGZ1bmN0aW9uKigpe2NvbnN0IEI9bmV3IGQuUlRDVHJhbnNwb3J0KGEodGhpcyxDKSxBLChlPT50aGlzLmdhdGV3YXkuc2VuZE9mZmVyKEEsZSkpLChlPT50aGlzLmdhdGV3YXkuc2VuZEFuc3dlcihBLGUpKSwoZT0+dGhpcy5nYXRld2F5LnNlbmRDYW5kaWRhdGUoQSxlKSksKEE9Pnt2YXIgZSxJO28ub25QZWVyU3RhdGVDaGFuZ2UoQSksbnVsbD09PShJPShlPXRoaXMuY29uZmlnKS5vblBlZXJTdGF0ZUNoYW5nZSl8fHZvaWQgMD09PUl8fEkuY2FsbChlLHRoaXMsbyxBKX0pKSxvPW5ldyBoLlJhaW53YXlQZWVyKEEsZSxCLCgoKT0+e3RoaXMuZ2F0ZXdheS5kZWxldGVDb25uZWN0aW9uKEEpLGEodGhpcyxRKS5kZWxldGUoQSl9KSwoQT0+e3ZhciBlLEk7bnVsbD09PShJPShlPXRoaXMuY29uZmlnKS5vblBlZXJFcnJvcil8fHZvaWQgMD09PUl8fEkuY2FsbChlLHRoaXMsbyxBKX0pLChBPT57dmFyIGUsSTtudWxsPT09KEk9KGU9dGhpcy5jb25maWcpLm9uU3RyZWFtQW5ub3VuY2VtZW50KXx8dm9pZCAwPT09SXx8SS5jYWxsKGUsdGhpcyxvLEEpfSksKEE9Pnt2YXIgZSxJO251bGw9PT0oST0oZT10aGlzLmNvbmZpZykub25TdHJlYW1TdG9wKXx8dm9pZCAwPT09SXx8SS5jYWxsKGUsdGhpcyxBKX0pKTt0aGlzLmNvbm5lY3Rpb25UcmFuc3BvcnRzLnNldChJLEIpLEIub25BcHBsaWNhdGlvbk1lc3NhZ2U9KEEsZSk9Pnt2YXIgSSxnO3JldHVybiBudWxsPT09KGc9KEk9dGhpcy5jb25maWcpLm9uUGVlck1lc3NhZ2UpfHx2b2lkIDA9PT1nP3ZvaWQgMDpnLmNhbGwoSSx0aGlzLG8sQSxlKX07dHJ5e3lpZWxkIEIub3BlbihnKX1maW5hbGx5e3RoaXMuY29ubmVjdGlvblRyYW5zcG9ydHMuZGVsZXRlKEkpfXJldHVybiBvLnNlbmREZXZpY2VJbmZvQW5kRXhjaGFuZ2VDb2RlY3MoKSxhKHRoaXMsUSkuc2V0KEEsbyksbnVsbD09PShpPSh0PXRoaXMuY29uZmlnKS5vblBlZXJTdGF0ZUNoYW5nZSl8fHZvaWQgMD09PWl8fGkuY2FsbCh0LHRoaXMsbyxELkNvbm5lY3RlZCksb30pKX1jYW5jZWxDb25uZWN0aW9uQXR0ZW1wdChBKXt0aGlzLmdhdGV3YXkuY2FuY2VsQ29ubmVjdGlvbkF0dGVtcHQoQSl9aGFuZGxlUGVlckluZm8oQSl7Y29uc3QgZT10aGlzLmNvbm5lY3Rpb25UcmFuc3BvcnRzLmdldChBLmlkKTt2b2lkIDAhPT1lP2UuaGFuZGxlUGVlckluZm8oQSk6QS50eXBlIT09Yy5QZWVySW5mb3JtYXRpb25UeXBlLkNhbmRpZGF0ZSYmcy5SYWlud2F5TG9nZ2luZy53YXJuaW5nKFwiR290IHBlZXIgaW5mbyBmb3IgdW5leHBlY3RlZCBDUklEPyBcIitBLmlkKX1nZXRNZWRpYUNhcGFiaWxpdGllcyhBKXtyZXR1cm4gbmF2aWdhdG9yLm1lZGlhQ2FwYWJpbGl0aWVzLmRlY29kaW5nSW5mbyhBKX1zZXRMb2dTaW5rKEEpe3MuUmFpbndheUxvZ2dpbmcuc2V0TG9nU2luayhBKX1kaXNjb25uZWN0QWxsUGVlcnMoKXtmb3IoY29uc3QgQSBvZiBhKHRoaXMsUSkudmFsdWVzKCkpQS5kaXNjb25uZWN0KCk7YSh0aGlzLFEpLmNsZWFyKCl9YWRkTGlzdGVuZXJzKCl7d2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJiZWZvcmV1bmxvYWRcIix0aGlzLmJlZm9yZVVubG9hZEhhbmRsZXIuYmluZCh0aGlzKSksd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJibHVyXCIsdGhpcy53aW5kb3dCbHVySGFuZGxlciksZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInZpc2liaWxpdHljaGFuZ2VcIix0aGlzLmRvY3VtZW50VmlzaWJpbGl0eUNoYW5nZUhhbmRsZXIpfXJlbW92ZUxpc3RlbmVycygpe3dpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwiYmVmb3JldW5sb2FkXCIsdGhpcy5iZWZvcmVVbmxvYWRIYW5kbGVyLmJpbmQodGhpcykpLHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwiYmx1clwiLHRoaXMud2luZG93Qmx1ckhhbmRsZXIpLGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ2aXNpYmlsaXR5Y2hhbmdlXCIsdGhpcy5kb2N1bWVudFZpc2liaWxpdHlDaGFuZ2VIYW5kbGVyKX1kaXNwb3NlKCl7dGhpcy5kaXNjb25uZWN0QWxsUGVlcnMoKSx0aGlzLmNvbm5lY3Rpb25UcmFuc3BvcnRzLmNsZWFyKCksdGhpcy5nYXRld2F5LmRpc2Nvbm5lY3QoKSx0aGlzLnJlbW92ZUxpc3RlbmVycygpLHUuaW5pdGlhbGl6ZWQ9ITF9fWUuUmFpbndheVJ1bnRpbWU9dSxDPW5ldyBXZWFrTWFwLFE9bmV3IFdlYWtNYXAsdS5pbml0aWFsaXplZD0hMX0sMzg3NjpmdW5jdGlvbihBLGUsSSl7XCJ1c2Ugc3RyaWN0XCI7dmFyIGcsdD10aGlzJiZ0aGlzLl9fYXdhaXRlcnx8ZnVuY3Rpb24oQSxlLEksZyl7cmV0dXJuIG5ldyhJfHwoST1Qcm9taXNlKSkoKGZ1bmN0aW9uKHQsaSl7ZnVuY3Rpb24gQihBKXt0cnl7UShnLm5leHQoQSkpfWNhdGNoKEEpe2koQSl9fWZ1bmN0aW9uIEMoQSl7dHJ5e1EoZy50aHJvdyhBKSl9Y2F0Y2goQSl7aShBKX19ZnVuY3Rpb24gUShBKXt2YXIgZTtBLmRvbmU/dChBLnZhbHVlKTooZT1BLnZhbHVlLGUgaW5zdGFuY2VvZiBJP2U6bmV3IEkoKGZ1bmN0aW9uKEEpe0EoZSl9KSkpLnRoZW4oQixDKX1RKChnPWcuYXBwbHkoQSxlfHxbXSkpLm5leHQoKSl9KSl9LGk9dGhpcyYmdGhpcy5fX2NsYXNzUHJpdmF0ZUZpZWxkR2V0fHxmdW5jdGlvbihBLGUpe2lmKCFlLmhhcyhBKSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiYXR0ZW1wdGVkIHRvIGdldCBwcml2YXRlIGZpZWxkIG9uIG5vbi1pbnN0YW5jZVwiKTtyZXR1cm4gZS5nZXQoQSl9LEI9dGhpcyYmdGhpcy5fX2NsYXNzUHJpdmF0ZUZpZWxkU2V0fHxmdW5jdGlvbihBLGUsSSl7aWYoIWUuaGFzKEEpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJhdHRlbXB0ZWQgdG8gc2V0IHByaXZhdGUgZmllbGQgb24gbm9uLWluc3RhbmNlXCIpO3JldHVybiBlLnNldChBLEkpLEl9O09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLGUuUmFpbndheVN0cmVhbT12b2lkIDA7Y29uc3QgQz1JKDI5OTQpLFE9SSg2OTA0KSxvPUkoMjgyNCksbj1JKDQ0MjUpLGE9SSgzNjQzKSxyPUkoMzQ2NCksRT1JKDQwMDkpLHM9SSg1NTI4KTtjbGFzcyBke2NvbnN0cnVjdG9yKEEsZSxJLHQsaSxCLEMscixkLGMpe3RoaXMuaG9zdD1BLHRoaXMuc3RyZWFtSWQ9ZSx0aGlzLmNob3NlbkF1ZGlvQ29uZmlnPXQsdGhpcy5jaG9zZW5WaWRlb0NvbmZpZz1pLHRoaXMuY2FwdHVyZU1vZGU9Qix0aGlzLnNlbmRJbnB1dD1DLHRoaXMuc2VuZExvZ2ljPXIsdGhpcy5wZWVyRGlzY2FyZFN0cmVhbT1jLHRoaXMucmVzaXplRGVib3VuY2VIYW5kbGU9dm9pZCAwLGcuc2V0KHRoaXMsITEpLHRoaXMuc2VuZEtleWZyYW1lUmVxdWVzdD0oKT0+e3RoaXMuc2VuZExvZ2ljKHtkaXNjcmltaW5hdG9yOlEuS2V5ZnJhbWVSZXF1ZXN0LmRpc2NyaW1pbmF0b3IsdmFsdWU6e3N0cmVhbUlkOnRoaXMuc3RyZWFtSWR9fSl9LHRoaXMuZmVlZFZpZGVvU3RhdGVJbnRvUmF0ZUNvbnRyb2xsZXI9QT0+e3RoaXMucmF0ZUNvbnRyb2xsZXIuaGFuZGxlVmlkZW9SZWFkeVN0YXRlKEEpfSx0aGlzLnNldFJlbW90ZUNsaXBib2FyZD0oKT0+e3ZhciBBO1wiZnVuY3Rpb25cIiE9dHlwZW9mKG51bGw9PT0oQT1udWxsPT09bmF2aWdhdG9yfHx2b2lkIDA9PT1uYXZpZ2F0b3I/dm9pZCAwOm5hdmlnYXRvci5jbGlwYm9hcmQpfHx2b2lkIDA9PT1BP3ZvaWQgMDpBLnJlYWRUZXh0KXx8cy5pc0Rlc2t0b3BTYWZhcml8fG5hdmlnYXRvci5jbGlwYm9hcmQucmVhZFRleHQoKS50aGVuKChBPT57dGhpcy5zZW5kSW5wdXQoe2Rpc2NyaW1pbmF0b3I6US5TZXRDbGlwYm9hcmRUZXh0LmRpc2NyaW1pbmF0b3IsdmFsdWU6e3RleHQ6QX19KX0pKX07Y29uc3QgaD1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO2gudGFiSW5kZXg9MCxoLnN0eWxlLnRvdWNoQWN0aW9uPVwibm9uZVwiLGguc3R5bGUudXNlclNlbGVjdD1cIm5vbmVcIixoLnN0eWxlLndlYmtpdFVzZXJTZWxlY3Q9XCJub25lXCIsaC5zdHlsZS5wb3NpdGlvbj1cInJlbGF0aXZlXCIsaC5zdHlsZS53aWR0aD1cIjEwMCVcIixoLnN0eWxlLmhlaWdodD1cIjEwMCVcIixoLmNsYXNzTmFtZT1cInJhaW53YXktaW5uZXItY29udGFpbmVyXCIsaC5hZGRFdmVudExpc3RlbmVyKFwiZm9jdXNcIix0aGlzLnNldFJlbW90ZUNsaXBib2FyZCksdGhpcy5pbm5lckNvbnRhaW5lcj1oLHRoaXMuaW5wdXRNYW5hZ2VyPW5ldyBvLlJhaW53YXlJbnB1dE1hbmFnZXIodGhpcyksdGhpcy5tZWRpYU1hbmFnZXI9bmV3IG4uTWVkaWFNYW5hZ2VyKEIsaSx7dmlkZW86e2NvZGVjU3RyaW5nOkUudmlkZW9Db2RlY01pbWVUeXBlKGkuY29kZWMpfX0sZCksdGhpcy5yYXRlQ29udHJvbGxlcj1uZXcgYS5SYWlud2F5UmF0ZUNvbnRyb2xsZXIodm9pZCAwLGksKEE9PnRoaXMuc2VuZExvZ2ljKHtkaXNjcmltaW5hdG9yOlEuVmlkZW9CaXRyYXRlUmVxdWVzdC5kaXNjcmltaW5hdG9yLHZhbHVlOntzdHJlYW1JZDplLGJpdHNQZXJTZWNvbmQ6MWUzKkF9fSkpLHRoaXMubWVkaWFNYW5hZ2VyLnZpZGVvUGVyZm9ybWFuY2VNb25pdG9yKSxoLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCgoKT0+e3RoaXMucmVzdW1lQXVkaW8oKX0pKSx0aGlzLm1lZGlhTWFuYWdlci5zZXRDb250YWluZXIoaCksdGhpcy5tZWRpYU1hbmFnZXIudmlkZW9OZWVkc1Jlc3RhcnRFdmVudC5hZGRIYW5kbGVyKHRoaXMuc2VuZEtleWZyYW1lUmVxdWVzdCksdGhpcy5tZWRpYU1hbmFnZXIudmlkZW9SZWFkeVN0YXRlQ2hhbmdlRXZlbnQuYWRkSGFuZGxlcih0aGlzLmZlZWRWaWRlb1N0YXRlSW50b1JhdGVDb250cm9sbGVyKSx0aGlzLmlucHV0TWFuYWdlci5zZXRDb250YWluZXIoaCksdGhpcy5pbnB1dE1hbmFnZXIuc2V0SW5wdXRMZXZlbChJKSx0aGlzLmNvbnRhaW5lclJlc2l6ZU9ic2VydmVyPW5ldyBSZXNpemVPYnNlcnZlcigoKCk9Pnt0aGlzLnJlc2l6ZURlYm91bmNlSGFuZGxlJiZ3aW5kb3cuY2xlYXJUaW1lb3V0KHRoaXMucmVzaXplRGVib3VuY2VIYW5kbGUpLHRoaXMucmVzaXplRGVib3VuY2VIYW5kbGU9d2luZG93LnNldFRpbWVvdXQoKCgpPT57dGhpcy5zZW5kSW5wdXQoe2Rpc2NyaW1pbmF0b3I6US5WaWV3cG9ydFJlc2l6ZS5kaXNjcmltaW5hdG9yLHZhbHVlOnt3aWR0aDp0aGlzLmlubmVyQ29udGFpbmVyLmNsaWVudFdpZHRoLGhlaWdodDp0aGlzLmlubmVyQ29udGFpbmVyLmNsaWVudEhlaWdodH19KSx0aGlzLnJlc2l6ZURlYm91bmNlSGFuZGxlPXZvaWQgMH0pLDEwMCl9KSksdGhpcy5jb250YWluZXJSZXNpemVPYnNlcnZlci5vYnNlcnZlKGgpfWdldCBkZWFkKCl7cmV0dXJuIGkodGhpcyxnKX1nZXQgY29udGFpbmVyKCl7cmV0dXJuIHRoaXMuaW5uZXJDb250YWluZXJ9Z2V0IGlucHV0TGV2ZWwoKXtyZXR1cm4gdGhpcy5pbnB1dE1hbmFnZXIuZ2V0SW5wdXRMZXZlbCgpfWdldCBjdXJyZW50RnJhbWVTaXplKCl7Y29uc3R7Y29kZWM6QX09dGhpcy5jaG9zZW5WaWRlb0NvbmZpZztyZXR1cm57Y29kZWNXaWR0aDpBLndpZHRoLGNvZGVjSGVpZ2h0OkEuaGVpZ2h0LHN0cmVhbUJvdW5kczp0aGlzLm1lZGlhTWFuYWdlci5jdXJyZW50U3RyZWFtQm91bmRzLGZ1bGxEZXNrdG9wQm91bmRzOnRoaXMubWVkaWFNYW5hZ2VyLmN1cnJlbnRGdWxsRGVza3RvcEJvdW5kc319c3RhdGljIGNyZWF0ZUFuZEluaXRpYWxpemUoQSxlLEksZyxpLEIsQyxRLG8sbil7cmV0dXJuIHQodGhpcyx2b2lkIDAsdm9pZCAwLChmdW5jdGlvbiooKXtjb25zdCB0PW5ldyBkKEEsZSxJLGcsaSxCLEMsUSxvLG4pO3JldHVybiB5aWVsZCB0Lm1lZGlhTWFuYWdlci5pbml0aWFsaXplKCksdH0pKX1wcm9jZXNzQXVkaW8oQSl7dGhpcy5tZWRpYU1hbmFnZXIucHJvY2Vzc0F1ZGlvKEEpfXByb2Nlc3NDdXJzb3IoQSl7dGhpcy5pbnB1dE1hbmFnZXIucHJvY2Vzc0N1cnNvcihBKX1yZW5kZXJWaWRlb0ZyYW1lKEEsZSl7dGhpcy5yYXRlQ29udHJvbGxlci5mZWVkRnJhbWVUaW1lc3RhbXAoQS50aW1lc3RhbXApLHRoaXMubWVkaWFNYW5hZ2VyLnJlbmRlclZpZGVvRnJhbWUoQSxlKX10cmFuc2Zvcm1Qb2ludGVyT2Zmc2V0VG9SZW1vdGUoQSxlKXtjb25zdCBJPXRoaXMubWVkaWFNYW5hZ2VyLmN1cnJlbnRTdHJlYW1Cb3VuZHM7aWYoIUkpcmV0dXJuO2NvbnN0IGc9dGhpcy5tZWRpYU1hbmFnZXIuY3VycmVudEZ1bGxEZXNrdG9wQm91bmRzO2lmKCFnKXJldHVybjtjb25zdHtsZWZ0OnQsdG9wOmksd2lkdGg6QixoZWlnaHQ6Q309Zyx7bGVmdDpRLHRvcDpvLHdpZHRoOm4saGVpZ2h0OmF9PUkscj10aGlzLmNob3NlblZpZGVvQ29uZmlnLmNvZGVjLndpZHRoLEU9dGhpcy5jaG9zZW5WaWRlb0NvbmZpZy5jb2RlYy5oZWlnaHQscz10aGlzLmlubmVyQ29udGFpbmVyLmNsaWVudFdpZHRoLGQ9dGhpcy5pbm5lckNvbnRhaW5lci5jbGllbnRIZWlnaHQsYz1uKnIvQixoPWEqRS9DLEQ9TWF0aC5taW4ocy9jLGQvaCk7cmV0dXJue3g6KEEtKHMtRCpjKS8yKS8oRCpyL0IpK1EtdCx5OihlLShkLUQqaCkvMikvKEQqRS9DKStvLWl9fXJlbGVhc2VLZXlzKCl7dGhpcy5pbnB1dE1hbmFnZXIucmVsZWFzZUtleXMoKX1lbmFibGVWaWRlb1N0YXRzT3ZlcmxheSgpe3ZhciBBO251bGw9PT0oQT10aGlzLm1lZGlhTWFuYWdlcil8fHZvaWQgMD09PUF8fEEuZW5hYmxlU3RhdHNPdmVybGF5KCl9ZGlzYWJsZVZpZGVvU3RhdHNPdmVybGF5KCl7dmFyIEE7bnVsbD09PShBPXRoaXMubWVkaWFNYW5hZ2VyKXx8dm9pZCAwPT09QXx8QS5kaXNhYmxlU3RhdHNPdmVybGF5KCl9cmVxdWVzdEZ1bGxzY3JlZW4oQSl7dmFyIGUsSSxnO2NvbnN0IHQ9bnVsbD09PShlPW51bGw9PUE/dm9pZCAwOkEubG9ja0tleWJvYXJkKXx8dm9pZCAwPT09ZXx8ZSxpPW51bGw9PT0oST1udWxsPT1BP3ZvaWQgMDpBLmxvY2tQb2ludGVyKXx8dm9pZCAwPT09SXx8STtpZih0aGlzLmlubmVyQ29udGFpbmVyLnJlcXVlc3RGdWxsc2NyZWVuP3RoaXMuaW5uZXJDb250YWluZXIucmVxdWVzdEZ1bGxzY3JlZW4oe25hdmlnYXRpb25VSTpcImhpZGVcIn0pOnRoaXMuaW5uZXJDb250YWluZXIud2Via2l0UmVxdWVzdEZ1bGxzY3JlZW4oe25hdmlnYXRpb25VSTpcImhpZGVcIn0pLHQmJlwia2V5Ym9hcmRcImluIG5hdmlnYXRvcil0cnl7bmF2aWdhdG9yLmtleWJvYXJkLmxvY2soKX1jYXRjaChBKXt9aSYmKG51bGw9PT0oZz10aGlzLmlucHV0TWFuYWdlcil8fHZvaWQgMD09PWd8fGcubG9ja1BvaW50ZXIoKSl9cGxheSgpe2lmKGkodGhpcyxnKSl0aHJvdyBuZXcgQy5SYWlud2F5RXJyb3IoXCJBdHRlbXB0ZWQgdG8gcGxheSBhIGRlYWQgc3RyZWFtXCIpO3RoaXMubWVkaWFNYW5hZ2VyLnBsYXkoKSx0aGlzLnJhdGVDb250cm9sbGVyLnN0YXJ0KCl9cGF1c2UoKXtpZihpKHRoaXMsZykpdGhyb3cgbmV3IEMuUmFpbndheUVycm9yKFwiQXR0ZW1wdGVkIHRvIHBhdXNlIGEgZGVhZCBzdHJlYW1cIik7dGhpcy5tZWRpYU1hbmFnZXIucGF1c2UoKSx0aGlzLnJhdGVDb250cm9sbGVyLnN0b3AoKX1sZWF2ZSgpe2kodGhpcyxnKT9yLlJhaW53YXlMb2dnaW5nLndhcm5pbmcoXCJBdHRlbXB0ZWQgdG8gbGVhdmUgYSBkZWFkIHN0cmVhbVwiKToodGhpcy5zZW5kTG9naWMoe2Rpc2NyaW1pbmF0b3I6US5MZWF2ZVN0cmVhbS5kaXNjcmltaW5hdG9yLHZhbHVlOntzdHJlYW1JZDp0aGlzLnN0cmVhbUlkfX0pLHRoaXMucGVlckRpc2NhcmRTdHJlYW0oKSx0aGlzLnJlc2l6ZURlYm91bmNlSGFuZGxlJiZjbGVhclRpbWVvdXQodGhpcy5yZXNpemVEZWJvdW5jZUhhbmRsZSksdGhpcy5pbm5lckNvbnRhaW5lci5yZW1vdmVFdmVudExpc3RlbmVyKFwiZm9jdXNcIix0aGlzLnNldFJlbW90ZUNsaXBib2FyZCksdGhpcy5jb250YWluZXJSZXNpemVPYnNlcnZlci5kaXNjb25uZWN0KCksdGhpcy5tZWRpYU1hbmFnZXIudmlkZW9OZWVkc1Jlc3RhcnRFdmVudC5yZW1vdmVIYW5kbGVyKHRoaXMuc2VuZEtleWZyYW1lUmVxdWVzdCksdGhpcy5tZWRpYU1hbmFnZXIudmlkZW9SZWFkeVN0YXRlQ2hhbmdlRXZlbnQucmVtb3ZlSGFuZGxlcih0aGlzLmZlZWRWaWRlb1N0YXRlSW50b1JhdGVDb250cm9sbGVyKSx0aGlzLmlucHV0TWFuYWdlci5kaXNwb3NlKCksdGhpcy5tZWRpYU1hbmFnZXIuZGlzcG9zZSgpLHRoaXMucmF0ZUNvbnRyb2xsZXIuc3RvcCgpLEIodGhpcyxnLCEwKSl9cmVzdW1lQXVkaW8oKXt2YXIgQSxlO251bGw9PT0oZT1udWxsPT09KEE9dGhpcy5tZWRpYU1hbmFnZXIpfHx2b2lkIDA9PT1BP3ZvaWQgMDpBLmF1ZGlvQ29udGV4dCl8fHZvaWQgMD09PWV8fGUucmVzdW1lKCl9ZW5hYmxlR2VzdHVyZXMoKXt2YXIgQTtudWxsPT09KEE9dGhpcy5pbnB1dE1hbmFnZXIpfHx2b2lkIDA9PT1BfHxBLmVuYWJsZUdlc3R1cmVzKCl9ZGlzYWJsZUdlc3R1cmVzKCl7dmFyIEE7bnVsbD09PShBPXRoaXMuaW5wdXRNYW5hZ2VyKXx8dm9pZCAwPT09QXx8QS5kaXNhYmxlR2VzdHVyZXMoKX1zZXRTdHJlYW1GaXQoQSl7dGhpcy5tZWRpYU1hbmFnZXIuc3RyZWFtRml0PUF9c2V0T3V0Z29pbmdJbnB1dEZpbHRlcihBKXt0aGlzLmlucHV0TWFuYWdlci5vdXRnb2luZ0lucHV0RmlsdGVyPUF9fWUuUmFpbndheVN0cmVhbT1kLGc9bmV3IFdlYWtNYXB9LDI5OTQ6KEEsZSk9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxlLlJhaW53YXlFcnJvcj12b2lkIDA7Y2xhc3MgSSBleHRlbmRzIEVycm9ye2NvbnN0cnVjdG9yKEEpe3N1cGVyKGBSYWlud2F5IFNESyBFcnJvcjogJHtBfWApLHRoaXMubmFtZT10aGlzLmNvbnN0cnVjdG9yLm5hbWUsXCJmdW5jdGlvblwiPT10eXBlb2YgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2U/RXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcyx0aGlzLmNvbnN0cnVjdG9yKTp0aGlzLnN0YWNrPW5ldyBFcnJvcihgUmFpbndheSBTREsgRXJyb3I6ICR7QX1gKS5zdGFjayxPYmplY3Quc2V0UHJvdG90eXBlT2YodGhpcyxJLnByb3RvdHlwZSl9fWUuUmFpbndheUVycm9yPUl9LDY1Nzk6QT0+e0EuZXhwb3J0cz1mdW5jdGlvbihBKXtyZXR1cm4gQSYmXCJvYmplY3RcIj09dHlwZW9mIEEmJlwiZnVuY3Rpb25cIj09dHlwZW9mIEEuY29weSYmXCJmdW5jdGlvblwiPT10eXBlb2YgQS5maWxsJiZcImZ1bmN0aW9uXCI9PXR5cGVvZiBBLnJlYWRVSW50OH19LDc2NzM6KEEsZSxJKT0+e1widXNlIHN0cmljdFwiO3ZhciBnPUkoNzc0MCksdD1JKDgyNjUpLGk9SSgyNTA1KSxCPUkoMzg3KTtmdW5jdGlvbiBDKEEpe3JldHVybiBBLmNhbGwuYmluZChBKX12YXIgUT1cInVuZGVmaW5lZFwiIT10eXBlb2YgQmlnSW50LG89XCJ1bmRlZmluZWRcIiE9dHlwZW9mIFN5bWJvbCxuPUMoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZyksYT1DKE51bWJlci5wcm90b3R5cGUudmFsdWVPZikscj1DKFN0cmluZy5wcm90b3R5cGUudmFsdWVPZiksRT1DKEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YpO2lmKFEpdmFyIHM9QyhCaWdJbnQucHJvdG90eXBlLnZhbHVlT2YpO2lmKG8pdmFyIGQ9QyhTeW1ib2wucHJvdG90eXBlLnZhbHVlT2YpO2Z1bmN0aW9uIGMoQSxlKXtpZihcIm9iamVjdFwiIT10eXBlb2YgQSlyZXR1cm4hMTt0cnl7cmV0dXJuIGUoQSksITB9Y2F0Y2goQSl7cmV0dXJuITF9fWZ1bmN0aW9uIGgoQSl7cmV0dXJuXCJbb2JqZWN0IE1hcF1cIj09PW4oQSl9ZnVuY3Rpb24gRChBKXtyZXR1cm5cIltvYmplY3QgU2V0XVwiPT09bihBKX1mdW5jdGlvbiB1KEEpe3JldHVyblwiW29iamVjdCBXZWFrTWFwXVwiPT09bihBKX1mdW5jdGlvbiB3KEEpe3JldHVyblwiW29iamVjdCBXZWFrU2V0XVwiPT09bihBKX1mdW5jdGlvbiBsKEEpe3JldHVyblwiW29iamVjdCBBcnJheUJ1ZmZlcl1cIj09PW4oQSl9ZnVuY3Rpb24geShBKXtyZXR1cm5cInVuZGVmaW5lZFwiIT10eXBlb2YgQXJyYXlCdWZmZXImJihsLndvcmtpbmc/bChBKTpBIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpfWZ1bmN0aW9uIFMoQSl7cmV0dXJuXCJbb2JqZWN0IERhdGFWaWV3XVwiPT09bihBKX1mdW5jdGlvbiBGKEEpe3JldHVyblwidW5kZWZpbmVkXCIhPXR5cGVvZiBEYXRhVmlldyYmKFMud29ya2luZz9TKEEpOkEgaW5zdGFuY2VvZiBEYXRhVmlldyl9ZS5pc0FyZ3VtZW50c09iamVjdD1nLGUuaXNHZW5lcmF0b3JGdW5jdGlvbj10LGUuaXNUeXBlZEFycmF5PUIsZS5pc1Byb21pc2U9ZnVuY3Rpb24oQSl7cmV0dXJuXCJ1bmRlZmluZWRcIiE9dHlwZW9mIFByb21pc2UmJkEgaW5zdGFuY2VvZiBQcm9taXNlfHxudWxsIT09QSYmXCJvYmplY3RcIj09dHlwZW9mIEEmJlwiZnVuY3Rpb25cIj09dHlwZW9mIEEudGhlbiYmXCJmdW5jdGlvblwiPT10eXBlb2YgQS5jYXRjaH0sZS5pc0FycmF5QnVmZmVyVmlldz1mdW5jdGlvbihBKXtyZXR1cm5cInVuZGVmaW5lZFwiIT10eXBlb2YgQXJyYXlCdWZmZXImJkFycmF5QnVmZmVyLmlzVmlldz9BcnJheUJ1ZmZlci5pc1ZpZXcoQSk6QihBKXx8RihBKX0sZS5pc1VpbnQ4QXJyYXk9ZnVuY3Rpb24oQSl7cmV0dXJuXCJVaW50OEFycmF5XCI9PT1pKEEpfSxlLmlzVWludDhDbGFtcGVkQXJyYXk9ZnVuY3Rpb24oQSl7cmV0dXJuXCJVaW50OENsYW1wZWRBcnJheVwiPT09aShBKX0sZS5pc1VpbnQxNkFycmF5PWZ1bmN0aW9uKEEpe3JldHVyblwiVWludDE2QXJyYXlcIj09PWkoQSl9LGUuaXNVaW50MzJBcnJheT1mdW5jdGlvbihBKXtyZXR1cm5cIlVpbnQzMkFycmF5XCI9PT1pKEEpfSxlLmlzSW50OEFycmF5PWZ1bmN0aW9uKEEpe3JldHVyblwiSW50OEFycmF5XCI9PT1pKEEpfSxlLmlzSW50MTZBcnJheT1mdW5jdGlvbihBKXtyZXR1cm5cIkludDE2QXJyYXlcIj09PWkoQSl9LGUuaXNJbnQzMkFycmF5PWZ1bmN0aW9uKEEpe3JldHVyblwiSW50MzJBcnJheVwiPT09aShBKX0sZS5pc0Zsb2F0MzJBcnJheT1mdW5jdGlvbihBKXtyZXR1cm5cIkZsb2F0MzJBcnJheVwiPT09aShBKX0sZS5pc0Zsb2F0NjRBcnJheT1mdW5jdGlvbihBKXtyZXR1cm5cIkZsb2F0NjRBcnJheVwiPT09aShBKX0sZS5pc0JpZ0ludDY0QXJyYXk9ZnVuY3Rpb24oQSl7cmV0dXJuXCJCaWdJbnQ2NEFycmF5XCI9PT1pKEEpfSxlLmlzQmlnVWludDY0QXJyYXk9ZnVuY3Rpb24oQSl7cmV0dXJuXCJCaWdVaW50NjRBcnJheVwiPT09aShBKX0saC53b3JraW5nPVwidW5kZWZpbmVkXCIhPXR5cGVvZiBNYXAmJmgobmV3IE1hcCksZS5pc01hcD1mdW5jdGlvbihBKXtyZXR1cm5cInVuZGVmaW5lZFwiIT10eXBlb2YgTWFwJiYoaC53b3JraW5nP2goQSk6QSBpbnN0YW5jZW9mIE1hcCl9LEQud29ya2luZz1cInVuZGVmaW5lZFwiIT10eXBlb2YgU2V0JiZEKG5ldyBTZXQpLGUuaXNTZXQ9ZnVuY3Rpb24oQSl7cmV0dXJuXCJ1bmRlZmluZWRcIiE9dHlwZW9mIFNldCYmKEQud29ya2luZz9EKEEpOkEgaW5zdGFuY2VvZiBTZXQpfSx1Lndvcmtpbmc9XCJ1bmRlZmluZWRcIiE9dHlwZW9mIFdlYWtNYXAmJnUobmV3IFdlYWtNYXApLGUuaXNXZWFrTWFwPWZ1bmN0aW9uKEEpe3JldHVyblwidW5kZWZpbmVkXCIhPXR5cGVvZiBXZWFrTWFwJiYodS53b3JraW5nP3UoQSk6QSBpbnN0YW5jZW9mIFdlYWtNYXApfSx3Lndvcmtpbmc9XCJ1bmRlZmluZWRcIiE9dHlwZW9mIFdlYWtTZXQmJncobmV3IFdlYWtTZXQpLGUuaXNXZWFrU2V0PWZ1bmN0aW9uKEEpe3JldHVybiB3KEEpfSxsLndvcmtpbmc9XCJ1bmRlZmluZWRcIiE9dHlwZW9mIEFycmF5QnVmZmVyJiZsKG5ldyBBcnJheUJ1ZmZlciksZS5pc0FycmF5QnVmZmVyPXksUy53b3JraW5nPVwidW5kZWZpbmVkXCIhPXR5cGVvZiBBcnJheUJ1ZmZlciYmXCJ1bmRlZmluZWRcIiE9dHlwZW9mIERhdGFWaWV3JiZTKG5ldyBEYXRhVmlldyhuZXcgQXJyYXlCdWZmZXIoMSksMCwxKSksZS5pc0RhdGFWaWV3PUY7dmFyIFI9XCJ1bmRlZmluZWRcIiE9dHlwZW9mIFNoYXJlZEFycmF5QnVmZmVyP1NoYXJlZEFycmF5QnVmZmVyOnZvaWQgMDtmdW5jdGlvbiBwKEEpe3JldHVyblwiW29iamVjdCBTaGFyZWRBcnJheUJ1ZmZlcl1cIj09PW4oQSl9ZnVuY3Rpb24gRyhBKXtyZXR1cm4gdm9pZCAwIT09UiYmKHZvaWQgMD09PXAud29ya2luZyYmKHAud29ya2luZz1wKG5ldyBSKSkscC53b3JraW5nP3AoQSk6QSBpbnN0YW5jZW9mIFIpfWZ1bmN0aW9uIGYoQSl7cmV0dXJuIGMoQSxhKX1mdW5jdGlvbiBtKEEpe3JldHVybiBjKEEscil9ZnVuY3Rpb24gayhBKXtyZXR1cm4gYyhBLEUpfWZ1bmN0aW9uIFUoQSl7cmV0dXJuIFEmJmMoQSxzKX1mdW5jdGlvbiBOKEEpe3JldHVybiBvJiZjKEEsZCl9ZS5pc1NoYXJlZEFycmF5QnVmZmVyPUcsZS5pc0FzeW5jRnVuY3Rpb249ZnVuY3Rpb24oQSl7cmV0dXJuXCJbb2JqZWN0IEFzeW5jRnVuY3Rpb25dXCI9PT1uKEEpfSxlLmlzTWFwSXRlcmF0b3I9ZnVuY3Rpb24oQSl7cmV0dXJuXCJbb2JqZWN0IE1hcCBJdGVyYXRvcl1cIj09PW4oQSl9LGUuaXNTZXRJdGVyYXRvcj1mdW5jdGlvbihBKXtyZXR1cm5cIltvYmplY3QgU2V0IEl0ZXJhdG9yXVwiPT09bihBKX0sZS5pc0dlbmVyYXRvck9iamVjdD1mdW5jdGlvbihBKXtyZXR1cm5cIltvYmplY3QgR2VuZXJhdG9yXVwiPT09bihBKX0sZS5pc1dlYkFzc2VtYmx5Q29tcGlsZWRNb2R1bGU9ZnVuY3Rpb24oQSl7cmV0dXJuXCJbb2JqZWN0IFdlYkFzc2VtYmx5Lk1vZHVsZV1cIj09PW4oQSl9LGUuaXNOdW1iZXJPYmplY3Q9ZixlLmlzU3RyaW5nT2JqZWN0PW0sZS5pc0Jvb2xlYW5PYmplY3Q9ayxlLmlzQmlnSW50T2JqZWN0PVUsZS5pc1N5bWJvbE9iamVjdD1OLGUuaXNCb3hlZFByaW1pdGl2ZT1mdW5jdGlvbihBKXtyZXR1cm4gZihBKXx8bShBKXx8ayhBKXx8VShBKXx8TihBKX0sZS5pc0FueUFycmF5QnVmZmVyPWZ1bmN0aW9uKEEpe3JldHVyblwidW5kZWZpbmVkXCIhPXR5cGVvZiBVaW50OEFycmF5JiYoeShBKXx8RyhBKSl9LFtcImlzUHJveHlcIixcImlzRXh0ZXJuYWxcIixcImlzTW9kdWxlTmFtZXNwYWNlT2JqZWN0XCJdLmZvckVhY2goKGZ1bmN0aW9uKEEpe09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLEEse2VudW1lcmFibGU6ITEsdmFsdWU6ZnVuY3Rpb24oKXt0aHJvdyBuZXcgRXJyb3IoQStcIiBpcyBub3Qgc3VwcG9ydGVkIGluIHVzZXJsYW5kXCIpfX0pfSkpfSwxMzIzOihBLGUsSSk9Pnt2YXIgZz1PYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yc3x8ZnVuY3Rpb24oQSl7Zm9yKHZhciBlPU9iamVjdC5rZXlzKEEpLEk9e30sZz0wO2c8ZS5sZW5ndGg7ZysrKUlbZVtnXV09T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihBLGVbZ10pO3JldHVybiBJfSx0PS8lW3NkaiVdL2c7ZS5mb3JtYXQ9ZnVuY3Rpb24oQSl7aWYoIUQoQSkpe2Zvcih2YXIgZT1bXSxJPTA7STxhcmd1bWVudHMubGVuZ3RoO0krKyllLnB1c2goUShhcmd1bWVudHNbSV0pKTtyZXR1cm4gZS5qb2luKFwiIFwiKX1JPTE7Zm9yKHZhciBnPWFyZ3VtZW50cyxpPWcubGVuZ3RoLEI9U3RyaW5nKEEpLnJlcGxhY2UodCwoZnVuY3Rpb24oQSl7aWYoXCIlJVwiPT09QSlyZXR1cm5cIiVcIjtpZihJPj1pKXJldHVybiBBO3N3aXRjaChBKXtjYXNlXCIlc1wiOnJldHVybiBTdHJpbmcoZ1tJKytdKTtjYXNlXCIlZFwiOnJldHVybiBOdW1iZXIoZ1tJKytdKTtjYXNlXCIlalwiOnRyeXtyZXR1cm4gSlNPTi5zdHJpbmdpZnkoZ1tJKytdKX1jYXRjaChBKXtyZXR1cm5cIltDaXJjdWxhcl1cIn1kZWZhdWx0OnJldHVybiBBfX0pKSxDPWdbSV07STxpO0M9Z1srK0ldKWMoQyl8fCFsKEMpP0IrPVwiIFwiK0M6Qis9XCIgXCIrUShDKTtyZXR1cm4gQn0sZS5kZXByZWNhdGU9ZnVuY3Rpb24oQSxJKXtpZihcInVuZGVmaW5lZFwiIT10eXBlb2YgcHJvY2VzcyYmITA9PT1wcm9jZXNzLm5vRGVwcmVjYXRpb24pcmV0dXJuIEE7aWYoXCJ1bmRlZmluZWRcIj09dHlwZW9mIHByb2Nlc3MpcmV0dXJuIGZ1bmN0aW9uKCl7cmV0dXJuIGUuZGVwcmVjYXRlKEEsSSkuYXBwbHkodGhpcyxhcmd1bWVudHMpfTt2YXIgZz0hMTtyZXR1cm4gZnVuY3Rpb24oKXtpZighZyl7aWYocHJvY2Vzcy50aHJvd0RlcHJlY2F0aW9uKXRocm93IG5ldyBFcnJvcihJKTtwcm9jZXNzLnRyYWNlRGVwcmVjYXRpb24/Y29uc29sZS50cmFjZShJKTpjb25zb2xlLmVycm9yKEkpLGc9ITB9cmV0dXJuIEEuYXBwbHkodGhpcyxhcmd1bWVudHMpfX07dmFyIGk9e30sQj0vXiQvO2lmKHByb2Nlc3MuZW52Lk5PREVfREVCVUcpe3ZhciBDPXByb2Nlc3MuZW52Lk5PREVfREVCVUc7Qz1DLnJlcGxhY2UoL1t8XFxcXHt9KClbXFxdXiQrPy5dL2csXCJcXFxcJCZcIikucmVwbGFjZSgvXFwqL2csXCIuKlwiKS5yZXBsYWNlKC8sL2csXCIkfF5cIikudG9VcHBlckNhc2UoKSxCPW5ldyBSZWdFeHAoXCJeXCIrQytcIiRcIixcImlcIil9ZnVuY3Rpb24gUShBLEkpe3ZhciBnPXtzZWVuOltdLHN0eWxpemU6bn07cmV0dXJuIGFyZ3VtZW50cy5sZW5ndGg+PTMmJihnLmRlcHRoPWFyZ3VtZW50c1syXSksYXJndW1lbnRzLmxlbmd0aD49NCYmKGcuY29sb3JzPWFyZ3VtZW50c1szXSksZChJKT9nLnNob3dIaWRkZW49STpJJiZlLl9leHRlbmQoZyxJKSx1KGcuc2hvd0hpZGRlbikmJihnLnNob3dIaWRkZW49ITEpLHUoZy5kZXB0aCkmJihnLmRlcHRoPTIpLHUoZy5jb2xvcnMpJiYoZy5jb2xvcnM9ITEpLHUoZy5jdXN0b21JbnNwZWN0KSYmKGcuY3VzdG9tSW5zcGVjdD0hMCksZy5jb2xvcnMmJihnLnN0eWxpemU9byksYShnLEEsZy5kZXB0aCl9ZnVuY3Rpb24gbyhBLGUpe3ZhciBJPVEuc3R5bGVzW2VdO3JldHVybiBJP1wiXHUwMDFiW1wiK1EuY29sb3JzW0ldWzBdK1wibVwiK0ErXCJcdTAwMWJbXCIrUS5jb2xvcnNbSV1bMV0rXCJtXCI6QX1mdW5jdGlvbiBuKEEsZSl7cmV0dXJuIEF9ZnVuY3Rpb24gYShBLEksZyl7aWYoQS5jdXN0b21JbnNwZWN0JiZJJiZGKEkuaW5zcGVjdCkmJkkuaW5zcGVjdCE9PWUuaW5zcGVjdCYmKCFJLmNvbnN0cnVjdG9yfHxJLmNvbnN0cnVjdG9yLnByb3RvdHlwZSE9PUkpKXt2YXIgdD1JLmluc3BlY3QoZyxBKTtyZXR1cm4gRCh0KXx8KHQ9YShBLHQsZykpLHR9dmFyIGk9ZnVuY3Rpb24oQSxlKXtpZih1KGUpKXJldHVybiBBLnN0eWxpemUoXCJ1bmRlZmluZWRcIixcInVuZGVmaW5lZFwiKTtpZihEKGUpKXt2YXIgST1cIidcIitKU09OLnN0cmluZ2lmeShlKS5yZXBsYWNlKC9eXCJ8XCIkL2csXCJcIikucmVwbGFjZSgvJy9nLFwiXFxcXCdcIikucmVwbGFjZSgvXFxcXFwiL2csJ1wiJykrXCInXCI7cmV0dXJuIEEuc3R5bGl6ZShJLFwic3RyaW5nXCIpfXJldHVybiBoKGUpP0Euc3R5bGl6ZShcIlwiK2UsXCJudW1iZXJcIik6ZChlKT9BLnN0eWxpemUoXCJcIitlLFwiYm9vbGVhblwiKTpjKGUpP0Euc3R5bGl6ZShcIm51bGxcIixcIm51bGxcIik6dm9pZCAwfShBLEkpO2lmKGkpcmV0dXJuIGk7dmFyIEI9T2JqZWN0LmtleXMoSSksQz1mdW5jdGlvbihBKXt2YXIgZT17fTtyZXR1cm4gQS5mb3JFYWNoKChmdW5jdGlvbihBLEkpe2VbQV09ITB9KSksZX0oQik7aWYoQS5zaG93SGlkZGVuJiYoQj1PYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhJKSksUyhJKSYmKEIuaW5kZXhPZihcIm1lc3NhZ2VcIik+PTB8fEIuaW5kZXhPZihcImRlc2NyaXB0aW9uXCIpPj0wKSlyZXR1cm4gcihJKTtpZigwPT09Qi5sZW5ndGgpe2lmKEYoSSkpe3ZhciBRPUkubmFtZT9cIjogXCIrSS5uYW1lOlwiXCI7cmV0dXJuIEEuc3R5bGl6ZShcIltGdW5jdGlvblwiK1ErXCJdXCIsXCJzcGVjaWFsXCIpfWlmKHcoSSkpcmV0dXJuIEEuc3R5bGl6ZShSZWdFeHAucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoSSksXCJyZWdleHBcIik7aWYoeShJKSlyZXR1cm4gQS5zdHlsaXplKERhdGUucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoSSksXCJkYXRlXCIpO2lmKFMoSSkpcmV0dXJuIHIoSSl9dmFyIG8sbj1cIlwiLGw9ITEsUj1bXCJ7XCIsXCJ9XCJdO3JldHVybiBzKEkpJiYobD0hMCxSPVtcIltcIixcIl1cIl0pLEYoSSkmJihuPVwiIFtGdW5jdGlvblwiKyhJLm5hbWU/XCI6IFwiK0kubmFtZTpcIlwiKStcIl1cIiksdyhJKSYmKG49XCIgXCIrUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKEkpKSx5KEkpJiYobj1cIiBcIitEYXRlLnByb3RvdHlwZS50b1VUQ1N0cmluZy5jYWxsKEkpKSxTKEkpJiYobj1cIiBcIityKEkpKSwwIT09Qi5sZW5ndGh8fGwmJjAhPUkubGVuZ3RoP2c8MD93KEkpP0Euc3R5bGl6ZShSZWdFeHAucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoSSksXCJyZWdleHBcIik6QS5zdHlsaXplKFwiW09iamVjdF1cIixcInNwZWNpYWxcIik6KEEuc2Vlbi5wdXNoKEkpLG89bD9mdW5jdGlvbihBLGUsSSxnLHQpe2Zvcih2YXIgaT1bXSxCPTAsQz1lLmxlbmd0aDtCPEM7KytCKW0oZSxTdHJpbmcoQikpP2kucHVzaChFKEEsZSxJLGcsU3RyaW5nKEIpLCEwKSk6aS5wdXNoKFwiXCIpO3JldHVybiB0LmZvckVhY2goKGZ1bmN0aW9uKHQpe3QubWF0Y2goL15cXGQrJC8pfHxpLnB1c2goRShBLGUsSSxnLHQsITApKX0pKSxpfShBLEksZyxDLEIpOkIubWFwKChmdW5jdGlvbihlKXtyZXR1cm4gRShBLEksZyxDLGUsbCl9KSksQS5zZWVuLnBvcCgpLGZ1bmN0aW9uKEEsZSxJKXtyZXR1cm4gQS5yZWR1Y2UoKGZ1bmN0aW9uKEEsZSl7cmV0dXJuIGUuaW5kZXhPZihcIlxcblwiKSxBK2UucmVwbGFjZSgvXFx1MDAxYlxcW1xcZFxcZD9tL2csXCJcIikubGVuZ3RoKzF9KSwwKT42MD9JWzBdKyhcIlwiPT09ZT9cIlwiOmUrXCJcXG4gXCIpK1wiIFwiK0Euam9pbihcIixcXG4gIFwiKStcIiBcIitJWzFdOklbMF0rZStcIiBcIitBLmpvaW4oXCIsIFwiKStcIiBcIitJWzFdfShvLG4sUikpOlJbMF0rbitSWzFdfWZ1bmN0aW9uIHIoQSl7cmV0dXJuXCJbXCIrRXJyb3IucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoQSkrXCJdXCJ9ZnVuY3Rpb24gRShBLGUsSSxnLHQsaSl7dmFyIEIsQyxRO2lmKChRPU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSx0KXx8e3ZhbHVlOmVbdF19KS5nZXQ/Qz1RLnNldD9BLnN0eWxpemUoXCJbR2V0dGVyL1NldHRlcl1cIixcInNwZWNpYWxcIik6QS5zdHlsaXplKFwiW0dldHRlcl1cIixcInNwZWNpYWxcIik6US5zZXQmJihDPUEuc3R5bGl6ZShcIltTZXR0ZXJdXCIsXCJzcGVjaWFsXCIpKSxtKGcsdCl8fChCPVwiW1wiK3QrXCJdXCIpLEN8fChBLnNlZW4uaW5kZXhPZihRLnZhbHVlKTwwPyhDPWMoSSk/YShBLFEudmFsdWUsbnVsbCk6YShBLFEudmFsdWUsSS0xKSkuaW5kZXhPZihcIlxcblwiKT4tMSYmKEM9aT9DLnNwbGl0KFwiXFxuXCIpLm1hcCgoZnVuY3Rpb24oQSl7cmV0dXJuXCIgIFwiK0F9KSkuam9pbihcIlxcblwiKS5zdWJzdHIoMik6XCJcXG5cIitDLnNwbGl0KFwiXFxuXCIpLm1hcCgoZnVuY3Rpb24oQSl7cmV0dXJuXCIgICBcIitBfSkpLmpvaW4oXCJcXG5cIikpOkM9QS5zdHlsaXplKFwiW0NpcmN1bGFyXVwiLFwic3BlY2lhbFwiKSksdShCKSl7aWYoaSYmdC5tYXRjaCgvXlxcZCskLykpcmV0dXJuIEM7KEI9SlNPTi5zdHJpbmdpZnkoXCJcIit0KSkubWF0Y2goL15cIihbYS16QS1aX11bYS16QS1aXzAtOV0qKVwiJC8pPyhCPUIuc3Vic3RyKDEsQi5sZW5ndGgtMiksQj1BLnN0eWxpemUoQixcIm5hbWVcIikpOihCPUIucmVwbGFjZSgvJy9nLFwiXFxcXCdcIikucmVwbGFjZSgvXFxcXFwiL2csJ1wiJykucmVwbGFjZSgvKF5cInxcIiQpL2csXCInXCIpLEI9QS5zdHlsaXplKEIsXCJzdHJpbmdcIikpfXJldHVybiBCK1wiOiBcIitDfWZ1bmN0aW9uIHMoQSl7cmV0dXJuIEFycmF5LmlzQXJyYXkoQSl9ZnVuY3Rpb24gZChBKXtyZXR1cm5cImJvb2xlYW5cIj09dHlwZW9mIEF9ZnVuY3Rpb24gYyhBKXtyZXR1cm4gbnVsbD09PUF9ZnVuY3Rpb24gaChBKXtyZXR1cm5cIm51bWJlclwiPT10eXBlb2YgQX1mdW5jdGlvbiBEKEEpe3JldHVyblwic3RyaW5nXCI9PXR5cGVvZiBBfWZ1bmN0aW9uIHUoQSl7cmV0dXJuIHZvaWQgMD09PUF9ZnVuY3Rpb24gdyhBKXtyZXR1cm4gbChBKSYmXCJbb2JqZWN0IFJlZ0V4cF1cIj09PVIoQSl9ZnVuY3Rpb24gbChBKXtyZXR1cm5cIm9iamVjdFwiPT10eXBlb2YgQSYmbnVsbCE9PUF9ZnVuY3Rpb24geShBKXtyZXR1cm4gbChBKSYmXCJbb2JqZWN0IERhdGVdXCI9PT1SKEEpfWZ1bmN0aW9uIFMoQSl7cmV0dXJuIGwoQSkmJihcIltvYmplY3QgRXJyb3JdXCI9PT1SKEEpfHxBIGluc3RhbmNlb2YgRXJyb3IpfWZ1bmN0aW9uIEYoQSl7cmV0dXJuXCJmdW5jdGlvblwiPT10eXBlb2YgQX1mdW5jdGlvbiBSKEEpe3JldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoQSl9ZnVuY3Rpb24gcChBKXtyZXR1cm4gQTwxMD9cIjBcIitBLnRvU3RyaW5nKDEwKTpBLnRvU3RyaW5nKDEwKX1lLmRlYnVnbG9nPWZ1bmN0aW9uKEEpe2lmKEE9QS50b1VwcGVyQ2FzZSgpLCFpW0FdKWlmKEIudGVzdChBKSl7dmFyIEk9cHJvY2Vzcy5waWQ7aVtBXT1mdW5jdGlvbigpe3ZhciBnPWUuZm9ybWF0LmFwcGx5KGUsYXJndW1lbnRzKTtjb25zb2xlLmVycm9yKFwiJXMgJWQ6ICVzXCIsQSxJLGcpfX1lbHNlIGlbQV09ZnVuY3Rpb24oKXt9O3JldHVybiBpW0FdfSxlLmluc3BlY3Q9USxRLmNvbG9ycz17Ym9sZDpbMSwyMl0saXRhbGljOlszLDIzXSx1bmRlcmxpbmU6WzQsMjRdLGludmVyc2U6WzcsMjddLHdoaXRlOlszNywzOV0sZ3JleTpbOTAsMzldLGJsYWNrOlszMCwzOV0sYmx1ZTpbMzQsMzldLGN5YW46WzM2LDM5XSxncmVlbjpbMzIsMzldLG1hZ2VudGE6WzM1LDM5XSxyZWQ6WzMxLDM5XSx5ZWxsb3c6WzMzLDM5XX0sUS5zdHlsZXM9e3NwZWNpYWw6XCJjeWFuXCIsbnVtYmVyOlwieWVsbG93XCIsYm9vbGVhbjpcInllbGxvd1wiLHVuZGVmaW5lZDpcImdyZXlcIixudWxsOlwiYm9sZFwiLHN0cmluZzpcImdyZWVuXCIsZGF0ZTpcIm1hZ2VudGFcIixyZWdleHA6XCJyZWRcIn0sZS50eXBlcz1JKDc2NzMpLGUuaXNBcnJheT1zLGUuaXNCb29sZWFuPWQsZS5pc051bGw9YyxlLmlzTnVsbE9yVW5kZWZpbmVkPWZ1bmN0aW9uKEEpe3JldHVybiBudWxsPT1BfSxlLmlzTnVtYmVyPWgsZS5pc1N0cmluZz1ELGUuaXNTeW1ib2w9ZnVuY3Rpb24oQSl7cmV0dXJuXCJzeW1ib2xcIj09dHlwZW9mIEF9LGUuaXNVbmRlZmluZWQ9dSxlLmlzUmVnRXhwPXcsZS50eXBlcy5pc1JlZ0V4cD13LGUuaXNPYmplY3Q9bCxlLmlzRGF0ZT15LGUudHlwZXMuaXNEYXRlPXksZS5pc0Vycm9yPVMsZS50eXBlcy5pc05hdGl2ZUVycm9yPVMsZS5pc0Z1bmN0aW9uPUYsZS5pc1ByaW1pdGl2ZT1mdW5jdGlvbihBKXtyZXR1cm4gbnVsbD09PUF8fFwiYm9vbGVhblwiPT10eXBlb2YgQXx8XCJudW1iZXJcIj09dHlwZW9mIEF8fFwic3RyaW5nXCI9PXR5cGVvZiBBfHxcInN5bWJvbFwiPT10eXBlb2YgQXx8dm9pZCAwPT09QX0sZS5pc0J1ZmZlcj1JKDY1NzkpO3ZhciBHPVtcIkphblwiLFwiRmViXCIsXCJNYXJcIixcIkFwclwiLFwiTWF5XCIsXCJKdW5cIixcIkp1bFwiLFwiQXVnXCIsXCJTZXBcIixcIk9jdFwiLFwiTm92XCIsXCJEZWNcIl07ZnVuY3Rpb24gZigpe3ZhciBBPW5ldyBEYXRlLGU9W3AoQS5nZXRIb3VycygpKSxwKEEuZ2V0TWludXRlcygpKSxwKEEuZ2V0U2Vjb25kcygpKV0uam9pbihcIjpcIik7cmV0dXJuW0EuZ2V0RGF0ZSgpLEdbQS5nZXRNb250aCgpXSxlXS5qb2luKFwiIFwiKX1mdW5jdGlvbiBtKEEsZSl7cmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChBLGUpfWUubG9nPWZ1bmN0aW9uKCl7Y29uc29sZS5sb2coXCIlcyAtICVzXCIsZigpLGUuZm9ybWF0LmFwcGx5KGUsYXJndW1lbnRzKSl9LGUuaW5oZXJpdHM9SSg4NyksZS5fZXh0ZW5kPWZ1bmN0aW9uKEEsZSl7aWYoIWV8fCFsKGUpKXJldHVybiBBO2Zvcih2YXIgST1PYmplY3Qua2V5cyhlKSxnPUkubGVuZ3RoO2ctLTspQVtJW2ddXT1lW0lbZ11dO3JldHVybiBBfTt2YXIgaz1cInVuZGVmaW5lZFwiIT10eXBlb2YgU3ltYm9sP1N5bWJvbChcInV0aWwucHJvbWlzaWZ5LmN1c3RvbVwiKTp2b2lkIDA7ZnVuY3Rpb24gVShBLGUpe2lmKCFBKXt2YXIgST1uZXcgRXJyb3IoXCJQcm9taXNlIHdhcyByZWplY3RlZCB3aXRoIGEgZmFsc3kgdmFsdWVcIik7SS5yZWFzb249QSxBPUl9cmV0dXJuIGUoQSl9ZS5wcm9taXNpZnk9ZnVuY3Rpb24oQSl7aWYoXCJmdW5jdGlvblwiIT10eXBlb2YgQSl0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgXCJvcmlnaW5hbFwiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBGdW5jdGlvbicpO2lmKGsmJkFba10pe3ZhciBlO2lmKFwiZnVuY3Rpb25cIiE9dHlwZW9mKGU9QVtrXSkpdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIFwidXRpbC5wcm9taXNpZnkuY3VzdG9tXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIEZ1bmN0aW9uJyk7cmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLGsse3ZhbHVlOmUsZW51bWVyYWJsZTohMSx3cml0YWJsZTohMSxjb25maWd1cmFibGU6ITB9KSxlfWZ1bmN0aW9uIGUoKXtmb3IodmFyIGUsSSxnPW5ldyBQcm9taXNlKChmdW5jdGlvbihBLGcpe2U9QSxJPWd9KSksdD1bXSxpPTA7aTxhcmd1bWVudHMubGVuZ3RoO2krKyl0LnB1c2goYXJndW1lbnRzW2ldKTt0LnB1c2goKGZ1bmN0aW9uKEEsZyl7QT9JKEEpOmUoZyl9KSk7dHJ5e0EuYXBwbHkodGhpcyx0KX1jYXRjaChBKXtJKEEpfXJldHVybiBnfXJldHVybiBPYmplY3Quc2V0UHJvdG90eXBlT2YoZSxPYmplY3QuZ2V0UHJvdG90eXBlT2YoQSkpLGsmJk9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLGsse3ZhbHVlOmUsZW51bWVyYWJsZTohMSx3cml0YWJsZTohMSxjb25maWd1cmFibGU6ITB9KSxPYmplY3QuZGVmaW5lUHJvcGVydGllcyhlLGcoQSkpfSxlLnByb21pc2lmeS5jdXN0b209ayxlLmNhbGxiYWNraWZ5PWZ1bmN0aW9uKEEpe2lmKFwiZnVuY3Rpb25cIiE9dHlwZW9mIEEpdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIFwib3JpZ2luYWxcIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgRnVuY3Rpb24nKTtmdW5jdGlvbiBlKCl7Zm9yKHZhciBlPVtdLEk9MDtJPGFyZ3VtZW50cy5sZW5ndGg7SSsrKWUucHVzaChhcmd1bWVudHNbSV0pO3ZhciBnPWUucG9wKCk7aWYoXCJmdW5jdGlvblwiIT10eXBlb2YgZyl0aHJvdyBuZXcgVHlwZUVycm9yKFwiVGhlIGxhc3QgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIEZ1bmN0aW9uXCIpO3ZhciB0PXRoaXMsaT1mdW5jdGlvbigpe3JldHVybiBnLmFwcGx5KHQsYXJndW1lbnRzKX07QS5hcHBseSh0aGlzLGUpLnRoZW4oKGZ1bmN0aW9uKEEpe3Byb2Nlc3MubmV4dFRpY2soaS5iaW5kKG51bGwsbnVsbCxBKSl9KSwoZnVuY3Rpb24oQSl7cHJvY2Vzcy5uZXh0VGljayhVLmJpbmQobnVsbCxBLGkpKX0pKX1yZXR1cm4gT2JqZWN0LnNldFByb3RvdHlwZU9mKGUsT2JqZWN0LmdldFByb3RvdHlwZU9mKEEpKSxPYmplY3QuZGVmaW5lUHJvcGVydGllcyhlLGcoQSkpLGV9fSwyNTA1OihBLGUsSSk9PntcInVzZSBzdHJpY3RcIjt2YXIgZz1JKDUyNzgpLHQ9SSg5NzMpLGk9SSgyNzM3KSxCPWkoXCJPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nXCIpLEM9SSg2OTgpKCksUT1cInVuZGVmaW5lZFwiPT10eXBlb2YgZ2xvYmFsVGhpcz9JLmc6Z2xvYmFsVGhpcyxvPXQoKSxuPWkoXCJTdHJpbmcucHJvdG90eXBlLnNsaWNlXCIpLGE9e30scj1JKDg4MjgpLEU9T2JqZWN0LmdldFByb3RvdHlwZU9mO0MmJnImJkUmJmcobywoZnVuY3Rpb24oQSl7aWYoXCJmdW5jdGlvblwiPT10eXBlb2YgUVtBXSl7dmFyIGU9bmV3IFFbQV07aWYoU3ltYm9sLnRvU3RyaW5nVGFnIGluIGUpe3ZhciBJPUUoZSksZz1yKEksU3ltYm9sLnRvU3RyaW5nVGFnKTtpZighZyl7dmFyIHQ9RShJKTtnPXIodCxTeW1ib2wudG9TdHJpbmdUYWcpfWFbQV09Zy5nZXR9fX0pKTt2YXIgcz1JKDM4Nyk7QS5leHBvcnRzPWZ1bmN0aW9uKEEpe3JldHVybiEhcyhBKSYmKEMmJlN5bWJvbC50b1N0cmluZ1RhZyBpbiBBP2Z1bmN0aW9uKEEpe3ZhciBlPSExO3JldHVybiBnKGEsKGZ1bmN0aW9uKEksZyl7aWYoIWUpdHJ5e3ZhciB0PUkuY2FsbChBKTt0PT09ZyYmKGU9dCl9Y2F0Y2goQSl7fX0pKSxlfShBKTpuKEIoQSksOCwtMSkpfX0sODg1OTpBPT57c2VsZixBLmV4cG9ydHM9KCgpPT57XCJ1c2Ugc3RyaWN0XCI7dmFyIEE9ezExNDpmdW5jdGlvbihBLGUsSSl7dmFyIGc9dGhpcyYmdGhpcy5fX2ltcG9ydERlZmF1bHR8fGZ1bmN0aW9uKEEpe3JldHVybiBBJiZBLl9fZXNNb2R1bGU/QTp7ZGVmYXVsdDpBfX07T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7Y29uc3QgdD1nKEkoMTcwKSk7Y2xhc3MgaXtpbml0aWFsaXplKCl7cmV0dXJuIHRoaXMuaWQ9aS51bmlxdWVJZENvdW50ZXIrKyxuZXcgUHJvbWlzZSgoKEEsZSk9Pnt0aGlzLndvcmtlcj1uZXcgdC5kZWZhdWx0LHRoaXMud29ya2VyLmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsKGU9Pnt2YXIgSTtjb25zdCBnPWUuZGF0YTtcImRlY29kZXJSZWFkeVwiPT09Zy50eXBlP0EoMCk6XCJwaWN0dXJlUmVhZHlcIj09PWcudHlwZSYmKG51bGw9PT0oST10aGlzLm9uRGVjb2RlKXx8dm9pZCAwPT09SXx8SS5jYWxsKHRoaXMsZykpfSkpfSkpfWRlY29kZShBKXt0aGlzLndvcmtlciYmdGhpcy53b3JrZXIucG9zdE1lc3NhZ2Uoe3R5cGU6XCJkZWNvZGVcIixkYXRhOkEuYnVmZmVyLG9mZnNldDpBLmJ5dGVPZmZzZXQsbGVuZ3RoOkEuYnl0ZUxlbmd0aCxyZW5kZXJTdGF0ZUlkOnRoaXMuaWR9LFtBLmJ1ZmZlcl0pfXJlbGVhc2UoKXt0aGlzLndvcmtlciYmdGhpcy53b3JrZXIucG9zdE1lc3NhZ2Uoe3R5cGU6XCJyZWxlYXNlXCIscmVuZGVyU3RhdGVJZDp0aGlzLmlkfSl9ZGlzcG9zZSgpe3RoaXMud29ya2VyJiYodGhpcy53b3JrZXIudGVybWluYXRlKCksdGhpcy53b3JrZXI9dm9pZCAwKX19ZS5kZWZhdWx0PWksaS51bmlxdWVJZENvdW50ZXI9MX0sMTcwOihBLGUsSSk9PntJLnIoZSksSS5kKGUse2RlZmF1bHQ6KCk9Pml9KTt2YXIgZz1JKDYxNCksdD1JLm4oZyk7ZnVuY3Rpb24gaSgpe3JldHVybiB0KCkoJy8qISBGb3IgbGljZW5zZSBpbmZvcm1hdGlvbiBwbGVhc2Ugc2VlIGluZGV4Lndvcmtlci5qcy5MSUNFTlNFLnR4dCAqL1xcbigoKT0+e3ZhciBBPXs3MTk6QT0+e3ZhciBJLGc9KEk9XCJ1bmRlZmluZWRcIiE9dHlwZW9mIGRvY3VtZW50JiZkb2N1bWVudC5jdXJyZW50U2NyaXB0P2RvY3VtZW50LmN1cnJlbnRTY3JpcHQuc3JjOnZvaWQgMCxmdW5jdGlvbihBKXsoQT1BfHx7fSl8fChBPXZvaWQgMCE9PUE/QTp7fSk7dmFyIGcsQj17fTtmb3IoZyBpbiBBKUEuaGFzT3duUHJvcGVydHkoZykmJihCW2ddPUFbZ10pO3ZhciBRLEM9W10sRT1cIlwiO0U9c2VsZi5sb2NhdGlvbi5ocmVmLEkmJihFPUkpLEU9MCE9PUUuaW5kZXhPZihcImJsb2I6XCIpP0Uuc3Vic3RyKDAsRS5sYXN0SW5kZXhPZihcIi9cIikrMSk6XCJcIixRPWZ1bmN0aW9uKEEpe3ZhciBJPW5ldyBYTUxIdHRwUmVxdWVzdDtyZXR1cm4gSS5vcGVuKFwiR0VUXCIsQSwhMSksSS5yZXNwb25zZVR5cGU9XCJhcnJheWJ1ZmZlclwiLEkuc2VuZChudWxsKSxuZXcgVWludDhBcnJheShJLnJlc3BvbnNlKX07dmFyIGksRCxvPUEucHJpbnR8fGNvbnNvbGUubG9nLmJpbmQoY29uc29sZSksYT1BLnByaW50RXJyfHxjb25zb2xlLndhcm4uYmluZChjb25zb2xlKTtmb3IoZyBpbiBCKUIuaGFzT3duUHJvcGVydHkoZykmJihBW2ddPUJbZ10pO0I9bnVsbCxBLmFyZ3VtZW50cyYmKEM9QS5hcmd1bWVudHMpLEEudGhpc1Byb2dyYW0mJkEudGhpc1Byb2dyYW0sQS5xdWl0JiZBLnF1aXQsQS53YXNtQmluYXJ5JiYoaT1BLndhc21CaW5hcnkpLEEubm9FeGl0UnVudGltZSYmQS5ub0V4aXRSdW50aW1lLFwib2JqZWN0XCIhPXR5cGVvZiBXZWJBc3NlbWJseSYmYShcIm5vIG5hdGl2ZSB3YXNtIHN1cHBvcnQgZGV0ZWN0ZWRcIik7dmFyIEcsUyxGLE4sdyx5LFIsaD1uZXcgV2ViQXNzZW1ibHkuVGFibGUoe2luaXRpYWw6MSxtYXhpbXVtOjEsZWxlbWVudDpcImFueWZ1bmNcIn0pLHM9ITE7ZnVuY3Rpb24gayhJKXtHPUksQS5IRUFQOD1TPW5ldyBJbnQ4QXJyYXkoSSksQS5IRUFQMTY9Tj1uZXcgSW50MTZBcnJheShJKSxBLkhFQVAzMj13PW5ldyBJbnQzMkFycmF5KEkpLEEuSEVBUFU4PUY9bmV3IFVpbnQ4QXJyYXkoSSksQS5IRUFQVTE2PW5ldyBVaW50MTZBcnJheShJKSxBLkhFQVBVMzI9bmV3IFVpbnQzMkFycmF5KEkpLEEuSEVBUEYzMj15PW5ldyBGbG9hdDMyQXJyYXkoSSksQS5IRUFQRjY0PVI9bmV3IEZsb2F0NjRBcnJheShJKX12YXIgTD1BLklOSVRJQUxfTUVNT1JZfHwxNjc3NzIxNjtmdW5jdGlvbiBNKEkpe2Zvcig7SS5sZW5ndGg+MDspe3ZhciBnPUkuc2hpZnQoKTtpZihcImZ1bmN0aW9uXCIhPXR5cGVvZiBnKXt2YXIgQj1nLmZ1bmM7XCJudW1iZXJcIj09dHlwZW9mIEI/dm9pZCAwPT09Zy5hcmc/QS5keW5DYWxsX3YoQik6QS5keW5DYWxsX3ZpKEIsZy5hcmcpOkIodm9pZCAwPT09Zy5hcmc/bnVsbDpnLmFyZyl9ZWxzZSBnKEEpfX0oRD1BLndhc21NZW1vcnk/QS53YXNtTWVtb3J5Om5ldyBXZWJBc3NlbWJseS5NZW1vcnkoe2luaXRpYWw6TC82NTUzNixtYXhpbXVtOjMyNzY4fSkpJiYoRz1ELmJ1ZmZlciksTD1HLmJ5dGVMZW5ndGgsayhHKSx3WzIxODhdPTUyNTE3OTI7dmFyIFU9W10sWT1bXSxKPVtdLHE9W10sSz0wLEg9bnVsbCx0PW51bGw7ZnVuY3Rpb24gYyhJKXt0aHJvdyBBLm9uQWJvcnQmJkEub25BYm9ydChJKSxvKEkrPVwiXCIpLGEoSSkscz0hMCxJPVwiYWJvcnQoXCIrSStcIikuIEJ1aWxkIHdpdGggLXMgQVNTRVJUSU9OUz0xIGZvciBtb3JlIGluZm8uXCIsbmV3IFdlYkFzc2VtYmx5LlJ1bnRpbWVFcnJvcihJKX1mdW5jdGlvbiBkKEEpe3JldHVybiBJPUEsZz1cImRhdGE6YXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtO2Jhc2U2NCxcIixTdHJpbmcucHJvdG90eXBlLnN0YXJ0c1dpdGg/SS5zdGFydHNXaXRoKGcpOjA9PT1JLmluZGV4T2YoZyk7dmFyIEksZ31BLnByZWxvYWRlZEltYWdlcz17fSxBLnByZWxvYWRlZEF1ZGlvcz17fTt2YXIgbixwPVwiVGlueUgyNjQud2FzbVwiO2Z1bmN0aW9uIGYoKXt0cnl7aWYoaSlyZXR1cm4gbmV3IFVpbnQ4QXJyYXkoaSk7aWYoUSlyZXR1cm4gUShwKTt0aHJvd1wiYm90aCBhc3luYyBhbmQgc3luYyBmZXRjaGluZyBvZiB0aGUgd2FzbSBmYWlsZWRcIn1jYXRjaChBKXtjKEEpfX1mdW5jdGlvbiByKEEpe3RyeXtyZXR1cm4gRC5ncm93KEEtRy5ieXRlTGVuZ3RoKzY1NTM1Pj4+MTYpLGsoRC5idWZmZXIpLDF9Y2F0Y2goQSl7fX1kKHApfHwobj1wLHA9QS5sb2NhdGVGaWxlP0EubG9jYXRlRmlsZShuLEUpOkUrbiksWS5wdXNoKHtmdW5jOmZ1bmN0aW9uKCl7eCgpfX0pO3ZhciBlPXthOmZ1bmN0aW9uKEEsSSxnKXtGLmNvcHlXaXRoaW4oQSxJLEkrZyl9LGI6ZnVuY3Rpb24oQSl7QT4+Pj0wO3ZhciBJPUYubGVuZ3RoLGc9MjE0NzQ4MzY0ODtpZihBPmcpcmV0dXJuITE7Zm9yKHZhciBCLFE9MTtRPD00O1EqPTIpe3ZhciBDPUkqKDErLjIvUSk7aWYoQz1NYXRoLm1pbihDLEErMTAwNjYzMjk2KSxyKE1hdGgubWluKGcsKChCPU1hdGgubWF4KDE2Nzc3MjE2LEEsQykpJTY1NTM2PjAmJihCKz02NTUzNi1CJTY1NTM2KSxCKSkpKXJldHVybiEwfXJldHVybiExfSxtZW1vcnk6RCx0YWJsZTpofSxtPWZ1bmN0aW9uKCl7dmFyIEk9e2E6ZX07ZnVuY3Rpb24gZyhJLGcpe3ZhciBCPUkuZXhwb3J0cztBLmFzbT1CLGZ1bmN0aW9uKEkpe2lmKEstLSxBLm1vbml0b3JSdW5EZXBlbmRlbmNpZXMmJkEubW9uaXRvclJ1bkRlcGVuZGVuY2llcyhLKSwwPT1LJiYobnVsbCE9PUgmJihjbGVhckludGVydmFsKEgpLEg9bnVsbCksdCkpe3ZhciBnPXQ7dD1udWxsLGcoKX19KCl9ZnVuY3Rpb24gQihBKXtnKEEuaW5zdGFuY2UpfWZ1bmN0aW9uIFEoQSl7cmV0dXJuKGl8fFwiZnVuY3Rpb25cIiE9dHlwZW9mIGZldGNoP25ldyBQcm9taXNlKChmdW5jdGlvbihBLEkpe0EoZigpKX0pKTpmZXRjaChwLHtjcmVkZW50aWFsczpcInNhbWUtb3JpZ2luXCJ9KS50aGVuKChmdW5jdGlvbihBKXtpZighQS5vayl0aHJvd1wiZmFpbGVkIHRvIGxvYWQgd2FzbSBiaW5hcnkgZmlsZSBhdCBcXCdcIitwK1wiXFwnXCI7cmV0dXJuIEEuYXJyYXlCdWZmZXIoKX0pKS5jYXRjaCgoZnVuY3Rpb24oKXtyZXR1cm4gZigpfSkpKS50aGVuKChmdW5jdGlvbihBKXtyZXR1cm4gV2ViQXNzZW1ibHkuaW5zdGFudGlhdGUoQSxJKX0pKS50aGVuKEEsKGZ1bmN0aW9uKEEpe2EoXCJmYWlsZWQgdG8gYXN5bmNocm9ub3VzbHkgcHJlcGFyZSB3YXNtOiBcIitBKSxjKEEpfSkpfWlmKEsrKyxBLm1vbml0b3JSdW5EZXBlbmRlbmNpZXMmJkEubW9uaXRvclJ1bkRlcGVuZGVuY2llcyhLKSxBLmluc3RhbnRpYXRlV2FzbSl0cnl7cmV0dXJuIEEuaW5zdGFudGlhdGVXYXNtKEksZyl9Y2F0Y2goQSl7cmV0dXJuIGEoXCJNb2R1bGUuaW5zdGFudGlhdGVXYXNtIGNhbGxiYWNrIGZhaWxlZCB3aXRoIGVycm9yOiBcIitBKSwhMX1yZXR1cm4gZnVuY3Rpb24oKXtpZihpfHxcImZ1bmN0aW9uXCIhPXR5cGVvZiBXZWJBc3NlbWJseS5pbnN0YW50aWF0ZVN0cmVhbWluZ3x8ZChwKXx8XCJmdW5jdGlvblwiIT10eXBlb2YgZmV0Y2gpcmV0dXJuIFEoQik7ZmV0Y2gocCx7Y3JlZGVudGlhbHM6XCJzYW1lLW9yaWdpblwifSkudGhlbigoZnVuY3Rpb24oQSl7cmV0dXJuIFdlYkFzc2VtYmx5Lmluc3RhbnRpYXRlU3RyZWFtaW5nKEEsSSkudGhlbihCLChmdW5jdGlvbihBKXthKFwid2FzbSBzdHJlYW1pbmcgY29tcGlsZSBmYWlsZWQ6IFwiK0EpLGEoXCJmYWxsaW5nIGJhY2sgdG8gQXJyYXlCdWZmZXIgaW5zdGFudGlhdGlvblwiKSxRKEIpfSkpfSkpfSgpLHt9fSgpO0EuYXNtPW07dmFyIFcseD1BLl9fX3dhc21fY2FsbF9jdG9ycz1mdW5jdGlvbigpe3JldHVybih4PUEuX19fd2FzbV9jYWxsX2N0b3JzPUEuYXNtLmMpLmFwcGx5KG51bGwsYXJndW1lbnRzKX07ZnVuY3Rpb24gWChJKXtmdW5jdGlvbiBnKCl7V3x8KFc9ITAsQS5jYWxsZWRSdW49ITAsc3x8KE0oWSksTShKKSxBLm9uUnVudGltZUluaXRpYWxpemVkJiZBLm9uUnVudGltZUluaXRpYWxpemVkKCksZnVuY3Rpb24oKXtpZihBLnBvc3RSdW4pZm9yKFwiZnVuY3Rpb25cIj09dHlwZW9mIEEucG9zdFJ1biYmKEEucG9zdFJ1bj1bQS5wb3N0UnVuXSk7QS5wb3N0UnVuLmxlbmd0aDspST1BLnBvc3RSdW4uc2hpZnQoKSxxLnVuc2hpZnQoSSk7dmFyIEk7TShxKX0oKSkpfUk9SXx8QyxLPjB8fChmdW5jdGlvbigpe2lmKEEucHJlUnVuKWZvcihcImZ1bmN0aW9uXCI9PXR5cGVvZiBBLnByZVJ1biYmKEEucHJlUnVuPVtBLnByZVJ1bl0pO0EucHJlUnVuLmxlbmd0aDspST1BLnByZVJ1bi5zaGlmdCgpLFUudW5zaGlmdChJKTt2YXIgSTtNKFUpfSgpLEs+MHx8KEEuc2V0U3RhdHVzPyhBLnNldFN0YXR1cyhcIlJ1bm5pbmcuLi5cIiksc2V0VGltZW91dCgoZnVuY3Rpb24oKXtzZXRUaW1lb3V0KChmdW5jdGlvbigpe0Euc2V0U3RhdHVzKFwiXCIpfSksMSksZygpfSksMSkpOmcoKSkpfWlmKEEuX2gyNjRic2RJbml0PWZ1bmN0aW9uKCl7cmV0dXJuKEEuX2gyNjRic2RJbml0PUEuYXNtLmQpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sQS5fbWFsbG9jPWZ1bmN0aW9uKCl7cmV0dXJuKEEuX21hbGxvYz1BLmFzbS5lKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LEEuX2ZyZWU9ZnVuY3Rpb24oKXtyZXR1cm4oQS5fZnJlZT1BLmFzbS5mKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LEEuX2gyNjRic2REZWNvZGU9ZnVuY3Rpb24oKXtyZXR1cm4oQS5faDI2NGJzZERlY29kZT1BLmFzbS5nKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LEEuX2gyNjRic2RTaHV0ZG93bj1mdW5jdGlvbigpe3JldHVybihBLl9oMjY0YnNkU2h1dGRvd249QS5hc20uaCkuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxBLl9oMjY0YnNkQWxsb2M9ZnVuY3Rpb24oKXtyZXR1cm4oQS5faDI2NGJzZEFsbG9jPUEuYXNtLmkpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sQS5faDI2NGJzZEZyZWU9ZnVuY3Rpb24oKXtyZXR1cm4oQS5faDI2NGJzZEZyZWU9QS5hc20uaikuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxBLmFzbT1tLEEuZ2V0VmFsdWU9ZnVuY3Rpb24oQSxJLGcpe3N3aXRjaChcIipcIj09PShJPUl8fFwiaThcIikuY2hhckF0KEkubGVuZ3RoLTEpJiYoST1cImkzMlwiKSxJKXtjYXNlXCJpMVwiOmNhc2VcImk4XCI6cmV0dXJuIFNbQT4+MF07Y2FzZVwiaTE2XCI6cmV0dXJuIE5bQT4+MV07Y2FzZVwiaTMyXCI6Y2FzZVwiaTY0XCI6cmV0dXJuIHdbQT4+Ml07Y2FzZVwiZmxvYXRcIjpyZXR1cm4geVtBPj4yXTtjYXNlXCJkb3VibGVcIjpyZXR1cm4gUltBPj4zXTtkZWZhdWx0OmMoXCJpbnZhbGlkIHR5cGUgZm9yIGdldFZhbHVlOiBcIitJKX1yZXR1cm4gbnVsbH0sQS50aGVuPWZ1bmN0aW9uKEkpe2lmKFcpSShBKTtlbHNle3ZhciBnPUEub25SdW50aW1lSW5pdGlhbGl6ZWQ7QS5vblJ1bnRpbWVJbml0aWFsaXplZD1mdW5jdGlvbigpe2cmJmcoKSxJKEEpfX1yZXR1cm4gQX0sdD1mdW5jdGlvbiBBKCl7V3x8WCgpLFd8fCh0PUEpfSxBLnJ1bj1YLEEucHJlSW5pdClmb3IoXCJmdW5jdGlvblwiPT10eXBlb2YgQS5wcmVJbml0JiYoQS5wcmVJbml0PVtBLnByZUluaXRdKTtBLnByZUluaXQubGVuZ3RoPjA7KUEucHJlSW5pdC5wb3AoKSgpO3JldHVybiBYKCksQX0pO0EuZXhwb3J0cz1nfSwzNDA6KEEsSSxnKT0+e1widXNlIHN0cmljdFwiO2cucihJKSxnLmQoSSx7aW5pdDooKT0+b30pO3ZhciBCPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gQShBLEkpe3RoaXMudGlueUgyNjRNb2R1bGU9QSx0aGlzLm9uUGljdHVyZVJlYWR5PUksdGhpcy5wU3RvcmFnZT10aGlzLnRpbnlIMjY0TW9kdWxlLl9oMjY0YnNkQWxsb2MoKSx0aGlzLnBXaWR0aD10aGlzLnRpbnlIMjY0TW9kdWxlLl9tYWxsb2MoNCksdGhpcy5wSGVpZ2h0PXRoaXMudGlueUgyNjRNb2R1bGUuX21hbGxvYyg0KSx0aGlzLnBQaWN0dXJlPXRoaXMudGlueUgyNjRNb2R1bGUuX21hbGxvYyg0KSx0aGlzLl9kZWNCdWZmZXI9dGhpcy50aW55SDI2NE1vZHVsZS5fbWFsbG9jKDEwNDg1NzYpLHRoaXMudGlueUgyNjRNb2R1bGUuX2gyNjRic2RJbml0KHRoaXMucFN0b3JhZ2UsMCl9dmFyIEk9QS5wcm90b3R5cGU7cmV0dXJuIEkucmVsZWFzZT1mdW5jdGlvbigpe3ZhciBBPXRoaXMucFN0b3JhZ2U7MCE9PUEmJih0aGlzLnRpbnlIMjY0TW9kdWxlLl9oMjY0YnNkU2h1dGRvd24oQSksdGhpcy50aW55SDI2NE1vZHVsZS5faDI2NGJzZEZyZWUoQSkpLHRoaXMudGlueUgyNjRNb2R1bGUuX2ZyZWUodGhpcy5wV2lkdGgpLHRoaXMudGlueUgyNjRNb2R1bGUuX2ZyZWUodGhpcy5wSGVpZ2h0KSx0aGlzLnRpbnlIMjY0TW9kdWxlLl9mcmVlKHRoaXMucFBpY3R1cmUpLHRoaXMucFN0b3JhZ2U9MCx0aGlzLnBXaWR0aD0wLHRoaXMucEhlaWdodD0wfSxJLmRlY29kZT1mdW5jdGlvbihJKXtpZihJIGluc3RhbmNlb2YgQXJyYXlCdWZmZXImJihJPW5ldyBVaW50OEFycmF5KEkpKSx0aGlzLnRpbnlIMjY0TW9kdWxlLkhFQVBVOC5zZXQoSSx0aGlzLl9kZWNCdWZmZXIpLHRoaXMudGlueUgyNjRNb2R1bGUuX2gyNjRic2REZWNvZGUodGhpcy5wU3RvcmFnZSx0aGlzLl9kZWNCdWZmZXIsSS5ieXRlTGVuZ3RoLHRoaXMucFBpY3R1cmUsdGhpcy5wV2lkdGgsdGhpcy5wSGVpZ2h0KT09PUEuUElDX1JEWSl7dmFyIGc9dGhpcy50aW55SDI2NE1vZHVsZS5nZXRWYWx1ZSh0aGlzLnBXaWR0aCxcImkzMlwiKSxCPXRoaXMudGlueUgyNjRNb2R1bGUuZ2V0VmFsdWUodGhpcy5wSGVpZ2h0LFwiaTMyXCIpLFE9dGhpcy50aW55SDI2NE1vZHVsZS5nZXRWYWx1ZSh0aGlzLnBQaWN0dXJlLFwiaTgqXCIpLEM9bmV3IFVpbnQ4QXJyYXkodGhpcy50aW55SDI2NE1vZHVsZS5IRUFQVTguc3ViYXJyYXkoUSxRK2cqQiozLzIpKTt0aGlzLm9uUGljdHVyZVJlYWR5KEMsZyxCKX19LEF9KCk7Qi5SRFk9MCxCLlBJQ19SRFk9MSxCLkhEUlNfUkRZPTIsQi5FUlJPUj0zLEIuUEFSQU1fU0VUX0VSUk9SPTQsQi5NRU1BTExPQ19FUlJPUj01O2NvbnN0IFE9Qjt2YXIgQz1nKDcxOSksRT1nLm4oQyksaT17XCJUaW55SDI2NC53YXNtXCI6XCJkYXRhOjtiYXNlNjQsQUdGemJRRUFBQUFCbHdFVFlBSi9md0YvWUFSL2YzOS9BWDlnQW45L0FHQURmMzkvQVg5Z0FYOEFZQWwvZjM5L2YzOS9mMzhBWUFGL0FYOWdCSDkvZjM4QVlBWi9mMzkvZjM4QmYyQUlmMzkvZjM5L2YzOEFZQU4vZjM4QVlBVi9mMzkvZndGL1lBQUFZQVYvZjM5L2Z3QmdCbjkvZjM5L2Z3QmdDbjkvZjM5L2YzOS9mMzhBWUFBQmYyQUhmMzkvZjM5L2Z3Ri9ZQWgvZjM5L2YzOS9md0YvQWgwREFXRUJZUUFEQVdFQllnQUdBV0VHYldWdGIzSjVBZ0dBQW9DQUFnTm1aUUFBQkFBQkF3b0JCZ0FGQXdVR0J3QUhCZ0FERGdNSEJ3VUNBQUlEQkFBRkJRVUZDZ1FDQkFrQkJ3QURCZ1lDQWdFR0JBTUNBZ0VMQVFFREF3c05BZ0VBQUFJSkNRa1BBZ1VGQUFFS0FCSUxFUWdJQndnSUJ3UUJCQWdJQmdFRUVBUUlBQUVNQmdrQmZ3RkIwTVhBQWdzSElRZ0JZd0JtQVdRQVpBRmxBQW9CWmdBRUFXY0FZd0ZvQUdJQmFRQmhBV29BWUFyRXFBVmx3QUlCQW44Z0FCQVBJZ0pCZjB3RVFDQUFRUUVRQ3hvZ0FVRUFOZ0lBUVFBUEN3SkFBa0FnQWtHQWdJQ0FCRThFUUNBQVFRTVFDMEYvUmdSQVFRRVBDeUFCSUFKQkhYWkJBWEZCQVdvMkFnQU1BUXNnQWtHQWdJQ0FBazhFUUNBQVFRVVFDMEYvUmdSQVFRRVBDeUFCSUFKQkczWkJBM0ZCQTJvMkFnQU1BUXNnQWtHQWdJQ0FBVThFUUNBQVFRY1FDMEYvUmdSQVFRRVBDeUFCSUFKQkdYWkJCM0ZCQjJvMkFnQU1BUXNnQWhBdklnTkJCR29pQWtFZ1JnUkFJQUZCQURZQ0FDQUFRU0FRQ3hwQkFTRUNJQUJCQVJBRFFRRkhEUUlnQUJBUElRTWdBRUVnRUF0QmYwWU5BaUFEUVFGTERRSWdBMEVCYXdSQUlBRkJmellDQUF3Q0N5QUJRWDgyQWdCQkFROExJQUFnQTBFRmFoQUxHaUFBSUFJUUF5SUFRWDlHQkVCQkFROExJQUVnQUVGL0lBSjBRWDl6YWpZQ0FBdEJBQ0VDQ3lBQ0M0Z0NBUWQvSUFBb0FnUWhCQUpBSUFBb0FneEJBM1FpQnlBQUtBSVFJZ2hySWdKQklFNEVRQ0FFS0FBQUlnTkJHSFFnQTBFSWRFR0FnUHdIY1hJZ0EwRUlka0dBL2dOeElBTkJHSFp5Y2lFRElBQW9BZ2dpQWtVTkFTQURJQUowSUFRdEFBUkJDQ0FDYTNaeUlRTU1BUXNnQWtFQlNBUkFEQUVMSUFRdEFBQWdBQ2dDQ0NJRlFSaHFJZ1owSVFNZ0FpQUZha0Y0YWlJQ1FRRklEUUFEUUNBRUxRQUJJQVpCZUdvaUJuUWdBM0loQXlBQ1FRaEtJUVVnQkVFQmFpRUVJQUpCZUdvaEFpQUZEUUFMQ3lBQUlBRWdDR29pQkRZQ0VDQUFJQVJCQjNFMkFnaEJmeUVDSUFRZ0IwMEVmeUFBSUFBb0FnQWdCRUVEZG1vMkFnUWdBMEVnSUFGcmRnVkJmd3NMcWcwQkIzOENRQ0FBUlEwQUlBQkJlR29pQXlBQVFYeHFLQUlBSWdGQmVIRWlBR29oQlFKQUlBRkJBWEVOQUNBQlFRTnhSUTBCSUFNZ0F5Z0NBQ0lDYXlJRFFjVEFBQ2dDQUNJRVNRMEJJQUFnQW1vaEFDQURRY2pBQUNnQ0FFY0VRQ0FDUWY4QlRRUkFJQU1vQWdnaUJDQUNRUU4ySWdKQkEzUkIzTUFBYWtjYUlBUWdBeWdDRENJQlJnUkFRYlRBQUVHMHdBQW9BZ0JCZmlBQ2QzRTJBZ0FNQXdzZ0JDQUJOZ0lNSUFFZ0JEWUNDQXdDQ3lBREtBSVlJUVlDUUNBRElBTW9BZ3dpQVVjRVFDQUVJQU1vQWdnaUFrMEVRQ0FDS0FJTUdnc2dBaUFCTmdJTUlBRWdBallDQ0F3QkN3SkFJQU5CRkdvaUFpZ0NBQ0lFRFFBZ0EwRVFhaUlDS0FJQUlnUU5BRUVBSVFFTUFRc0RRQ0FDSVFjZ0JDSUJRUlJxSWdJb0FnQWlCQTBBSUFGQkVHb2hBaUFCS0FJUUlnUU5BQXNnQjBFQU5nSUFDeUFHUlEwQkFrQWdBeUFES0FJY0lnSkJBblJCNU1JQWFpSUVLQUlBUmdSQUlBUWdBVFlDQUNBQkRRRkJ1TUFBUWJqQUFDZ0NBRUYrSUFKM2NUWUNBQXdEQ3lBR1FSQkJGQ0FHS0FJUUlBTkdHMm9nQVRZQ0FDQUJSUTBDQ3lBQklBWTJBaGdnQXlnQ0VDSUNCRUFnQVNBQ05nSVFJQUlnQVRZQ0dBc2dBeWdDRkNJQ1JRMEJJQUVnQWpZQ0ZDQUNJQUUyQWhnTUFRc2dCU2dDQkNJQlFRTnhRUU5IRFFCQnZNQUFJQUEyQWdBZ0JTQUJRWDV4TmdJRUlBTWdBRUVCY2pZQ0JDQUFJQU5xSUFBMkFnQVBDeUFGSUFOTkRRQWdCU2dDQkNJQlFRRnhSUTBBQWtBZ0FVRUNjVVVFUUNBRlFjekFBQ2dDQUVZRVFFSE13QUFnQXpZQ0FFSEF3QUJCd01BQUtBSUFJQUJxSWdBMkFnQWdBeUFBUVFGeU5nSUVJQU5CeU1BQUtBSUFSdzBEUWJ6QUFFRUFOZ0lBUWNqQUFFRUFOZ0lBRHdzZ0JVSEl3QUFvQWdCR0JFQkJ5TUFBSUFNMkFnQkJ2TUFBUWJ6QUFDZ0NBQ0FBYWlJQU5nSUFJQU1nQUVFQmNqWUNCQ0FBSUFOcUlBQTJBZ0FQQ3lBQlFYaHhJQUJxSVFBQ1FDQUJRZjhCVFFSQUlBVW9BZ3doQWlBRktBSUlJZ1FnQVVFRGRpSUJRUU4wUWR6QUFHb2lCMGNFUUVIRXdBQW9BZ0FhQ3lBQ0lBUkdCRUJCdE1BQVFiVEFBQ2dDQUVGK0lBRjNjVFlDQUF3Q0N5QUNJQWRIQkVCQnhNQUFLQUlBR2dzZ0JDQUNOZ0lNSUFJZ0JEWUNDQXdCQ3lBRktBSVlJUVlDUUNBRklBVW9BZ3dpQVVjRVFFSEV3QUFvQWdBZ0JTZ0NDQ0lDVFFSQUlBSW9BZ3dhQ3lBQ0lBRTJBZ3dnQVNBQ05nSUlEQUVMQWtBZ0JVRVVhaUlDS0FJQUlnUU5BQ0FGUVJCcUlnSW9BZ0FpQkEwQVFRQWhBUXdCQ3dOQUlBSWhCeUFFSWdGQkZHb2lBaWdDQUNJRURRQWdBVUVRYWlFQ0lBRW9BaEFpQkEwQUN5QUhRUUEyQWdBTElBWkZEUUFDUUNBRklBVW9BaHdpQWtFQ2RFSGt3Z0JxSWdRb0FnQkdCRUFnQkNBQk5nSUFJQUVOQVVHNHdBQkJ1TUFBS0FJQVFYNGdBbmR4TmdJQURBSUxJQVpCRUVFVUlBWW9BaEFnQlVZYmFpQUJOZ0lBSUFGRkRRRUxJQUVnQmpZQ0dDQUZLQUlRSWdJRVFDQUJJQUkyQWhBZ0FpQUJOZ0lZQ3lBRktBSVVJZ0pGRFFBZ0FTQUNOZ0lVSUFJZ0FUWUNHQXNnQXlBQVFRRnlOZ0lFSUFBZ0Eyb2dBRFlDQUNBRFFjakFBQ2dDQUVjTkFVRzh3QUFnQURZQ0FBOExJQVVnQVVGK2NUWUNCQ0FESUFCQkFYSTJBZ1FnQUNBRGFpQUFOZ0lBQ3lBQVFmOEJUUVJBSUFCQkEzWWlBVUVEZEVIY3dBQnFJUUFDZjBHMHdBQW9BZ0FpQWtFQklBRjBJZ0Z4UlFSQVFiVEFBQ0FCSUFKeU5nSUFJQUFNQVFzZ0FDZ0NDQXNoQWlBQUlBTTJBZ2dnQWlBRE5nSU1JQU1nQURZQ0RDQURJQUkyQWdnUEN5QURRZ0EzQWhBZ0F3Si9RUUFnQUVFSWRpSUJSUTBBR2tFZklBQkIvLy8vQjBzTkFCb2dBU0FCUVlEK1AycEJFSFpCQ0hFaUFYUWlBaUFDUVlEZ0gycEJFSFpCQkhFaUFuUWlCQ0FFUVlDQUQycEJFSFpCQW5FaUJIUkJEM1lnQVNBQ2NpQUVjbXNpQVVFQmRDQUFJQUZCRldwMlFRRnhja0VjYWdzaUFqWUNIQ0FDUVFKMFFlVENBR29oQVFKQUFrQUNRRUc0d0FBb0FnQWlCRUVCSUFKMElnZHhSUVJBUWJqQUFDQUVJQWR5TmdJQUlBRWdBellDQUNBRElBRTJBaGdNQVFzZ0FFRUFRUmtnQWtFQmRtc2dBa0VmUmh0MElRSWdBU2dDQUNFQkEwQWdBU0lFS0FJRVFYaHhJQUJHRFFJZ0FrRWRkaUVCSUFKQkFYUWhBaUFFSUFGQkJIRnFJZ2RCRUdvb0FnQWlBUTBBQ3lBSElBTTJBaEFnQXlBRU5nSVlDeUFESUFNMkFnd2dBeUFETmdJSURBRUxJQVFvQWdnaUFDQUROZ0lNSUFRZ0F6WUNDQ0FEUVFBMkFoZ2dBeUFFTmdJTUlBTWdBRFlDQ0F0QjFNQUFRZFRBQUNnQ0FFRi9haUlBTmdJQUlBQU5BRUg4d3dBaEF3TkFJQU1vQWdBaUFFRUlhaUVESUFBTkFBdEIxTUFBUVg4MkFnQUxDM1FCQW44akFFRVFheUlDSkFBZ0FrRUFOZ0lNSUFBZ0FrRU1haEFDSVFBQ2Z5QUNLQUlNSWdOQmYwWUVRRUVCSUFCRkRRRWFJQUZCZ0lDQWdIZzJBZ0JCQUF3QkMwRUJJQUFOQUJvZ0FTQURRUUZxUVFGMklnRkJBQ0FCYXlBRFFRRnhHellDQUVFQUN5RUFJQUpCRUdva0FDQUFDN2tMQVJSL0lBRkJvRDFxTFFBQVFReHNJZ1pCMUR4cUtBSUFJUVFnQmtIUVBHb29BZ0FnQVVHUVBHb3RBQUFpQjNRaEJTQUNSUVJBSUFBZ0FDZ0NBQ0FGYkRZQ0FBc2dCQ0FIZENFQkFrQUNRQ0FEUVp6L0EzRUVRQ0FBSUFaQjJEeHFLQUlBSUFkMElnTWdBQ2dDUEd3MkFqd2dBQ0FBS0FJNElBRnNOZ0k0UVFFaEFpQUFJQUFvQWl3Z0JXd2lCeUFBS0FJTUlBVnNJZ1JxSWd3Z0FDZ0NJQ0FCYkNJTklBQW9BalFnQVd3aURrRUJkV29pRUdzaUJqWUNMQ0FBS0FJb0lSRWdBQ0FFSUFkcklnUWdEVUVCZFNBT2F5SU5heUlITmdJb0lBQW9BaVFoQ0NBQUlBUWdEV29pQkRZQ0pDQUFJQUFvQWh3Z0FXd2lEaUFBS0FJSUlBRnNJZ3BxSWhJZ0FDZ0NFQ0FEYkNJUElBQW9BakFnQTJ3aUMwRUJkV29pRTJzaURUWUNIQ0FBS0FJWUlRa2dBQ0FLSUE1cklnb2dEMEVCZFNBTGF5SVBheUlPTmdJWUlBQW9BaFFoQ3lBQUlBb2dEMm9pQ2pZQ0ZDQUFJQVVnQzJ3aUR5QUFLQUlBSWd0cUloUWdBQ2dDQkNBQmJDSVZJQUVnQ1d3aUNVRUJkV29pRm1zaUJUWUNEQ0FBSUFzZ0Qyc2lDeUFWUVFGMUlBbHJJZ2xySWc4MkFnZ2dBQ0FKSUF0cUlnczJBZ1FnQUNBQklBaHNJZ2dnQUNnQ09DSUpheUlWSUFNZ0VXd2lFVUVCZFNBQUtBSThJaGRySWdOcklnRTJBamdnQUNBRElCVnFJZ00yQWpRZ0FDQUlJQWxxSWdnZ0YwRUJkU0FSYWlJSmF5SVJOZ0k4SUFBZ0ZDQVdhaUlVSUF3Z0VHb2lER3RCSUdvaUVDQVNJQk5xSWhKQkFYVWdDQ0FKYWlJSWF5SVRhMEVHZFNJSk5nSWdJQUFnRUNBVGFrRUdkU0lRTmdJUUlBQWdEQ0FVYWtFZ2FpSU1JQWhCQVhVZ0Vtb2lDR3RCQm5VaUVqWUNNQ0FBSUFnZ0RHcEJCblVpRERZQ0FDQU1RWUFFYWlBUVFZQUVhbkpCL3dkTERRSWdFa0dBQkdvZ0NVR0FCR3B5UWY4SFN3MENJQUFnQkNBTGFrRWdhaUlNSUFOQkFYVWdDbW9pRUd0QkJuVWlDRFlDTkNBQUlBc2dCR3RCSUdvaUJDQUtRUUYxSUFOcklnTnJRUVoxSWdvMkFpUWdBQ0FESUFScVFRWjFJZ00yQWhRZ0FDQU1JQkJxUVFaMUlnUTJBZ1FnQkVHQUJHb2dBMEdBQkdweVFmOEhTdzBDSUFoQmdBUnFJQXBCZ0FScWNrSC9CMHNOQWlBQUlBY2dEMnBCSUdvaUF5QUJRUUYxSUE1cUlnUnJRUVoxSWdvMkFqZ2dBQ0FQSUFkclFTQnFJZ2NnRGtFQmRTQUJheUlCYTBFR2RTSU9OZ0lvSUFBZ0FTQUhha0VHZFNJQk5nSVlJQUFnQXlBRWFrRUdkU0lETmdJSUlBTkJnQVJxSUFGQmdBUnFja0gvQjBzTkFpQUtRWUFFYWlBT1FZQUVhbkpCL3dkTERRSWdBQ0FGSUFacVFTQnFJZ0VnRVVFQmRTQU5haUlEYTBFR2RTSUhOZ0k4SUFBZ0JTQUdhMEVnYWlJRklBMUJBWFVnRVdzaUJtdEJCblVpQkRZQ0xDQUFJQVVnQm1wQkJuVWlCVFlDSENBQUlBRWdBMnBCQm5VaUFEWUNEQ0FBUVlBRWFpQUZRWUFFYW5KQi93ZExEUUlnQjBHQUJHb2dCRUdBQkdweVFmOEhUUTBCREFJTElBTkI0Z0J4UlFSQVFRRWhBaUFBS0FJQVFTQnFRUVoxSWdGQmdBUnFRZjhIU3cwQ0lBQWdBVFlDT0NBQUlBRTJBandnQUNBQk5nSTBJQUFnQVRZQ01DQUFJQUUyQWl3Z0FDQUJOZ0lvSUFBZ0FUWUNKQ0FBSUFFMkFpQWdBQ0FCTmdJY0lBQWdBVFlDR0NBQUlBRTJBaFFnQUNBQk5nSVFJQUFnQVRZQ0RDQUFJQUUyQWdnZ0FDQUJOZ0lFSUFBZ0FUWUNBQXdCQzBFQklRSWdBQ0FBS0FJRUlBRnNJZ1FnQUNnQ0dDQUJiQ0lOUVFGMWFpSURJQUFvQWdBaUJpQUFLQUlVSUFWc0lnZHFJZ1ZxUVNCcVFRWjFJZ0UyQWpBZ0FDQUZJQU5yUVNCcVFRWjFJZ00yQWd3Z0FDQUVRUUYxSUExcklnUWdCaUFIYTJwQklHcEJCblVpQlRZQ0JDQUFJQUUyQWdBZ0FDQUJOZ0lnSUFBZ0JUWUNOQ0FBSUFFMkFoQWdBQ0FGTmdJa0lBQWdCVFlDRkNBQUlBTTJBandnQUNBR0lBUWdCMnByUVNCcVFRWjFJZ1kyQWdnZ0FDQUdOZ0k0SUFBZ0JqWUNLQ0FBSUFZMkFoZ2dBQ0FETmdJc0lBQWdBellDSENBRFFZQUVhaUFCUVlBRWFpQUdRWUFFYWlBRlFZQUVhbkp5Y2tIL0Iwc05BUXRCQUNFQ0N5QUNDL01DQWdKL0FYNENRQ0FDUlEwQUlBQWdBbW9pQTBGL2FpQUJPZ0FBSUFBZ0FUb0FBQ0FDUVFOSkRRQWdBMEYrYWlBQk9nQUFJQUFnQVRvQUFTQURRWDFxSUFFNkFBQWdBQ0FCT2dBQ0lBSkJCMGtOQUNBRFFYeHFJQUU2QUFBZ0FDQUJPZ0FESUFKQkNVa05BQ0FBUVFBZ0FHdEJBM0VpQkdvaUF5QUJRZjhCY1VHQmdvUUliQ0lCTmdJQUlBTWdBaUFFYTBGOGNTSUVhaUlDUVh4cUlBRTJBZ0FnQkVFSlNRMEFJQU1nQVRZQ0NDQURJQUUyQWdRZ0FrRjRhaUFCTmdJQUlBSkJkR29nQVRZQ0FDQUVRUmxKRFFBZ0F5QUJOZ0lZSUFNZ0FUWUNGQ0FESUFFMkFoQWdBeUFCTmdJTUlBSkJjR29nQVRZQ0FDQUNRV3hxSUFFMkFnQWdBa0ZvYWlBQk5nSUFJQUpCWkdvZ0FUWUNBQ0FFSUFOQkJIRkJHSElpQkdzaUFrRWdTUTBBSUFHdElnVkNJSVlnQllRaEJTQURJQVJxSVFFRFFDQUJJQVUzQXhnZ0FTQUZOd01RSUFFZ0JUY0RDQ0FCSUFVM0F3QWdBVUVnYWlFQklBSkJZR29pQWtFZlN3MEFDd3NnQUF2eUF3RURmeUFCS0FJQUlnTkIvLy8vQjBjRVFDQUJLQUlFSVFRZ0FDQUNJQUpCQTNFZ0FrRVFTU0lDRzBFQ2RDSUZRZkFwYWlnQ0FFRVFRUWdnQWhzaUFteHFJQVZCc0NscUtBSUFhaUlBSUFNZ0FDMEFBR3BCc0M1cUxRQUFPZ0FBSUFFb0FnZ2hBeUFBSUFRZ0FDMEFBV3BCc0M1cUxRQUFPZ0FCSUFFb0Fnd2hCQ0FBSUFNZ0FDMEFBbXBCc0M1cUxRQUFPZ0FDSUFBZ0JDQUFMUUFEYWtHd0xtb3RBQUE2QUFNZ0FTZ0NGQ0VESUFBZ0Ftb2lBQ0FCS0FJUUlBQXRBQUJxUWJBdWFpMEFBRG9BQUNBQktBSVlJUVFnQUNBRElBQXRBQUZxUWJBdWFpMEFBRG9BQVNBQktBSWNJUU1nQUNBRUlBQXRBQUpxUWJBdWFpMEFBRG9BQWlBQUlBTWdBQzBBQTJwQnNDNXFMUUFBT2dBRElBRW9BaVFoQXlBQUlBSnFJZ0FnQVNnQ0lDQUFMUUFBYWtHd0xtb3RBQUE2QUFBZ0FTZ0NLQ0VFSUFBZ0F5QUFMUUFCYWtHd0xtb3RBQUE2QUFFZ0FTZ0NMQ0VESUFBZ0JDQUFMUUFDYWtHd0xtb3RBQUE2QUFJZ0FDQURJQUF0QUFOcVFiQXVhaTBBQURvQUF5QUJLQUkwSVFNZ0FDQUNhaUlBSUFFb0FqQWdBQzBBQUdwQnNDNXFMUUFBT2dBQUlBRW9BamdoQWlBQUlBTWdBQzBBQVdwQnNDNXFMUUFBT2dBQklBRW9BandoQVNBQUlBSWdBQzBBQW1wQnNDNXFMUUFBT2dBQ0lBQWdBU0FBTFFBRGFrR3dMbW90QUFBNkFBTUxDOU1RQVF4L0l3QkJnQUZySWdva0FDQUFFQThoQkVFQklRVUNRQUpBQW44Z0FrRUJUUVJBSUFSQkFFZ05BaUFFUVJsMlFmNEFjVUdBQ0dvZ0JFR0FnSURnQUU4TkFSb2dCRUVWZGtIK0QzRkJ3QWhxSUFSQmdJQ0FDRThOQVJvZ0JFRVJka0grL3dGeFFaQUphaUFFUVlDQWdBRlBEUUVhSUFSQkVIWkJBWFJCa0FwcURBRUxJQUpCQTAwRVFDQUVRWDlNQkVCQkFrR2lFQ0FFUVlDQWdJQUVjUnNoQlF3REN5QUVRUmwyUWY0QWNVSFFDbW9nQkVHQWdJQ0FBVThOQVJvZ0JFRVdka0grQjNGQmtBdHFJQVJCZ0lDQUVFOE5BUm9nQkVFUmRrSCsvd0Z4UWRBTGFnd0JDeUFDUVFkTkJFQWdCRUVhZGlJQ1FYaHFRVGhKQkVBZ0FrRUJkRUhRRFdvTUFnc2dCRUVWZGtIK0QzRkIwQTVxREFFTElBUkJHWFpCL2dCeFFkQVFhaUFDUVJCTkRRQWFJQVJCSFhZaUFnUkFJQUpCQVhSQjBCRnFEQUVMSUFSQkYzWkIvZ054UWVBUmFnc3ZBUUFpQlEwQVFRRWhDd3dCQzBFQklRc2dCVUVMZGlJSklBTkxEUUJCSUNBRlFSOXhJZ1pySVFJQ1FDQUpSUVJBREFFTElBUWdCblFoQkFKQUlBVkJCWFpCUDNFaURFVUVRQXdCQ3lBQ0lBeEpCRUFnQUNBR0VBdEJmMFlOQXlBQUVBOGhCRUVnSVFJTElBUWdESFFoQmtFQklBeEJmMnAwSVFjZ0JFRWdJQXhyZGlFRUEwQWdDa0ZBYXlBSVFRSjBha0YvUVFFZ0JDQUhjUnMyQWdBZ0NFRUJhaUVJSUFkQkFYWWlCdzBBQ3lBQ0lBeHJJUUlnQmlFRUN5QUlJQWxKQkVBZ0RFRURTU0lQSUFWQi82OEJTM0VoQlFOQUlBSkJEMDBFUUNBQVFTQWdBbXNRQzBGL1JnUkFEQVVMSUFBUUR5RUVRU0FoQWd0QkFDRUdBa0FDUUFKL0FrQWdCRUVBU0EwQVFRRWhCaUFFUWYvLy8vOERTdzBBUVFJaEJpQUVRZi8vLy84QlN3MEFRUU1oQmlBRVFmLy8vLzhBU3cwQVFRUWhCaUFFUWYvLy96OUxEUUJCQlNFR0lBUkIvLy8vSDBzTkFFRUdJUVlnQkVILy8vOFBTdzBBUVFjaEJpQUVRZi8vL3dkTERRQkJDQ0VHSUFSQi8vLy9BMHNOQUVFSklRWWdCRUgvLy84QlN3MEFRUW9oQmlBRVFmLy8vd0JMRFFCQkN5RUdJQVJCLy84L1N3MEFRUXdoQmlBRVFmLy9IMHNOQUVFTklRWWdCRUgvL3c5TERRQUNmd0pBSUFSQi8vOEhUUVJBSUFSQmdJQjhjVUdBZ0FSR0RRRU1DZ3NnQlVFRUlBVWJJUVlnQkVFUGRDRUVRUTRoQnlBQ1FYRnFEQUVMSUFWQkFTQUZHeUVGSUFSQkVIUWhCRUVNSVFaQkR5RUhJQUpCY0dvTElRSWdCeUFGZENFSElBVkZEQUVMSUFZZ0JYUWhCMEVCSVE0Z0FpQUdRUUZxSWdacklRSWdCQ0FHZENFRUlBVkZEUUVnQlNFR1FRQUxJUTRnQWlBR1R3Ui9JQVFGSUFCQklDQUNheEFMUVg5R0JFQU1Cd3RCSUNFQ0lBQVFEd3NoRFNBQ0lBWnJJUUlnRFNBR2RDRUVJQTFCSUNBR2EzWWdCMm9oQnd3QkMwRUFJUVVMSUFwQlFHc2dDRUVDZEdwQkFDQUhRUUpxSUFjZ0NDQU1SaHNnQnlBUEd5SU5RUUpxUVFGMklnWnJJQVlnRFVFQmNSczJBZ0JCQVNBRklBNGJJZ1VnQlVFR1NTQUdRUU1nQlVGL2FuUktjV29oQlNBSVFRRnFJZ2dnQ1VjTkFBc0xRUUFoQndKQUlBa2dBMDhFUUVFQUlRZ01BUXNDUUNBQ1FRaExCRUFnQWlFRkRBRUxRU0FoQlNBQVFTQWdBbXNRQzBGL1JnMERJQUFRRHlFRUN3SkFBa0FDZndKQUlBTkJCRWNFUUNBSlFYOXFJZ0pCRFVzTkF3SkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUlBSkJBV3NPRFFBQkFnTUVCUVlIQ0FrS0N3d09DeUFFUVJwMlFlQVNhZ3dPQ3lBRVFScDJRYUFUYWd3TkN5QUVRUnQyUWVBVGFnd01DeUFFUVJ0MlFZQVVhZ3dMQ3lBRVFScDJRYUFVYWd3S0N5QUVRUnAyUWVBVWFnd0pDeUFFUVJwMlFhQVZhZ3dJQ3lBRVFScDJRZUFWYWd3SEN5QUVRUnQyUWFBV2Fnd0dDeUFFUVJ4MlFjQVdhZ3dGQ3lBRVFSeDJRZEFXYWd3RUN5QUVRUjEyUWVBV2Fnd0RDeUFFUVI1MlFlZ1dhZ3dDQ3lBRVFRQklCRUJCQVNFQ0RBUUxRUkVoQWlBSlFRTkdEUU5CRWlFQ0lBUkIvLy8vL3dOTERRTkJJaUVDSUFsQkFrWU5BMEVqUVRNZ0JFSC8vLy8vQVVzYklRSU1Bd3NnQkVFYmRrR2dFbW9nQkVFWGRrSEFFbW9nQkVILy8vLy9BRXNiQ3kwQUFDSUNEUUVNQkF0QkVVRUJJQVJCQUVnYklRSUxJQUpCQkhZaENDQUZJQUpCRDNFaUEyc2hBaUFFSUFOMElRUUxJQWxCZjJvaUF3UkFBMEFDZnlBSUJFQWdBa0VLVFFSQUlBQkJJQ0FDYXhBTFFYOUdCRUFNQndzZ0FCQVBJUVJCSUNFQ0N3SkFBbjhDUUNBSVFYOXFJZ1ZCQlUwRVFBSkFBa0FDUUFKQUFrQWdCVUVCYXc0RkFBRUNBd1FHQ3lBRVFSNTJRZTRXYWd3R0N5QUVRUjUyUWZJV2Fnd0ZDeUFFUVIxMlFmWVdhZ3dFQ3lBRVFSMTJRZjRXYWd3REN5QUVRUjEyUVlZWGFnd0NDd0ovUWZNQUlBUkJHWFpCOEFCeGF5QUVRWUNBZ0lBQ1R3MEFHa0gwQUNBRVFmLy8vLzhBU3cwQUdrR0ZBU0FFUWYvLy96OUxEUUFhUVpZQklBUkIvLy8vSDBzTkFCcEJwd0VnQkVILy8vOFBTdzBBR2tHNEFTQUVRZi8vL3dkTERRQWFRY2tCSUFSQi8vLy9BMHNOQUJwQjJnRWdCRUgvLy84QlN3MEFHa0VBUWVzQklBUkJnSUNBQVVrYkN5SUZRUVIySUFoTkRRSU1DQXNnQkVFZmRrSHNGbW9MTFFBQUlRVUxJQVZGQkVBTUJnc2dDaUFIUVFKMGFpQUZRUVIySWdaQkFXbzJBZ0FnQWlBRlFROXhJZ1ZySVFJZ0JDQUZkQ0VFSUFnZ0Jtc01BUXNnQ2lBSFFRSjBha0VCTmdJQVFRQUxJUWdnQjBFQmFpSUhJQU5IRFFBTElBRWdDRUVDZEdvZ0NrRkFheUFEUVFKMGFpZ0NBRFlDQUNBSlFYNXFJUVZCQVNBSWRDRUhBMEFnQVNBS0lBVWlBMEVDZENJRmFpZ0NBQ0FJYWlJSVFRSjBhaUFLUVVCcklBVnFLQUlBTmdJQUlBTkJmMm9oQlVFQklBaDBJQWR5SVFjZ0F3MEFDd3dCQ3lBQklBaEJBblJxSUFwQlFHc2dBMEVDZEdvb0FnQTJBZ0JCQVNBSWRDRUhDeUFBUVNBZ0Ftc1FDdzBBSUFkQkVIUWdDVUVFZEhJaEN3c2dDa0dBQVdva0FDQUxDODB1QVF0L0l3QkJFR3NpQ3lRQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQ0FBUWZRQlRRUkFRYlRBQUNnQ0FDSUdRUkFnQUVFTGFrRjRjU0FBUVF0Skd5SUZRUU4ySWdCMklnRkJBM0VFUUNBQlFYOXpRUUZ4SUFCcUlnSkJBM1FpQkVIa3dBQnFLQUlBSWdGQkNHb2hBQUpBSUFFb0FnZ2lBeUFFUWR6QUFHb2lCRVlFUUVHMHdBQWdCa0YrSUFKM2NUWUNBQXdCQzBIRXdBQW9BZ0FhSUFNZ0JEWUNEQ0FFSUFNMkFnZ0xJQUVnQWtFRGRDSUNRUU55TmdJRUlBRWdBbW9pQVNBQktBSUVRUUZ5TmdJRURBd0xJQVZCdk1BQUtBSUFJZ2hORFFFZ0FRUkFBa0JCQWlBQWRDSUNRUUFnQW10eUlBRWdBSFJ4SWdCQkFDQUFhM0ZCZjJvaUFDQUFRUXgyUVJCeElnQjJJZ0ZCQlhaQkNIRWlBaUFBY2lBQklBSjJJZ0JCQW5aQkJIRWlBWElnQUNBQmRpSUFRUUYyUVFKeElnRnlJQUFnQVhZaUFFRUJka0VCY1NJQmNpQUFJQUYyYWlJQ1FRTjBJZ05CNU1BQWFpZ0NBQ0lCS0FJSUlnQWdBMEhjd0FCcUlnTkdCRUJCdE1BQUlBWkJmaUFDZDNFaUJqWUNBQXdCQzBIRXdBQW9BZ0FhSUFBZ0F6WUNEQ0FESUFBMkFnZ0xJQUZCQ0dvaEFDQUJJQVZCQTNJMkFnUWdBU0FGYWlJSElBSkJBM1FpQWlBRmF5SURRUUZ5TmdJRUlBRWdBbW9nQXpZQ0FDQUlCRUFnQ0VFRGRpSUVRUU4wUWR6QUFHb2hBVUhJd0FBb0FnQWhBZ0ovSUFaQkFTQUVkQ0lFY1VVRVFFRzB3QUFnQkNBR2NqWUNBQ0FCREFFTElBRW9BZ2dMSVFRZ0FTQUNOZ0lJSUFRZ0FqWUNEQ0FDSUFFMkFnd2dBaUFFTmdJSUMwSEl3QUFnQnpZQ0FFRzh3QUFnQXpZQ0FBd01DMEc0d0FBb0FnQWlDa1VOQVNBS1FRQWdDbXR4UVg5cUlnQWdBRUVNZGtFUWNTSUFkaUlCUVFWMlFRaHhJZ0lnQUhJZ0FTQUNkaUlBUVFKMlFRUnhJZ0Z5SUFBZ0FYWWlBRUVCZGtFQ2NTSUJjaUFBSUFGMklnQkJBWFpCQVhFaUFYSWdBQ0FCZG1wQkFuUkI1TUlBYWlnQ0FDSUJLQUlFUVhoeElBVnJJUU1nQVNFQ0EwQUNRQ0FDS0FJUUlnQkZCRUFnQWlnQ0ZDSUFSUTBCQ3lBQUtBSUVRWGh4SUFWcklnSWdBeUFDSUFOSklnSWJJUU1nQUNBQklBSWJJUUVnQUNFQ0RBRUxDeUFCS0FJWUlRa2dBU0FCS0FJTUlnUkhCRUJCeE1BQUtBSUFJQUVvQWdnaUFFMEVRQ0FBS0FJTUdnc2dBQ0FFTmdJTUlBUWdBRFlDQ0F3TEN5QUJRUlJxSWdJb0FnQWlBRVVFUUNBQktBSVFJZ0JGRFFNZ0FVRVFhaUVDQ3dOQUlBSWhCeUFBSWdSQkZHb2lBaWdDQUNJQURRQWdCRUVRYWlFQ0lBUW9BaEFpQUEwQUN5QUhRUUEyQWdBTUNndEJmeUVGSUFCQnYzOUxEUUFnQUVFTGFpSUFRWGh4SVFWQnVNQUFLQUlBSWdkRkRRQkJBQ0FGYXlFQ0FrQUNRQUpBQW45QkFDQUFRUWgySWdCRkRRQWFRUjhnQlVILy8vOEhTdzBBR2lBQUlBQkJnUDQvYWtFUWRrRUljU0lBZENJQklBRkJnT0FmYWtFUWRrRUVjU0lCZENJRElBTkJnSUFQYWtFUWRrRUNjU0lEZEVFUGRpQUFJQUZ5SUFOeWF5SUFRUUYwSUFVZ0FFRVZhblpCQVhGeVFSeHFDeUlJUVFKMFFlVENBR29vQWdBaUEwVUVRRUVBSVFBTUFRc2dCVUVBUVJrZ0NFRUJkbXNnQ0VFZlJodDBJUUZCQUNFQUEwQUNRQ0FES0FJRVFYaHhJQVZySWdZZ0FrOE5BQ0FESVFRZ0JpSUNEUUJCQUNFQ0lBTWhBQXdEQ3lBQUlBTW9BaFFpQmlBR0lBTWdBVUVkZGtFRWNXb29BaEFpQTBZYklBQWdCaHNoQUNBQklBTkJBRWQwSVFFZ0F3MEFDd3NnQUNBRWNrVUVRRUVDSUFoMElnQkJBQ0FBYTNJZ0IzRWlBRVVOQXlBQVFRQWdBR3R4UVg5cUlnQWdBRUVNZGtFUWNTSUFkaUlCUVFWMlFRaHhJZ01nQUhJZ0FTQURkaUlBUVFKMlFRUnhJZ0Z5SUFBZ0FYWWlBRUVCZGtFQ2NTSUJjaUFBSUFGMklnQkJBWFpCQVhFaUFYSWdBQ0FCZG1wQkFuUkI1TUlBYWlnQ0FDRUFDeUFBUlEwQkN3TkFJQUFvQWdSQmVIRWdCV3NpQXlBQ1NTRUJJQU1nQWlBQkd5RUNJQUFnQkNBQkd5RUVJQUFvQWhBaUFRUi9JQUVGSUFBb0FoUUxJZ0FOQUFzTElBUkZEUUFnQWtHOHdBQW9BZ0FnQld0UERRQWdCQ2dDR0NFSUlBUWdCQ2dDRENJQlJ3UkFRY1RBQUNnQ0FDQUVLQUlJSWdCTkJFQWdBQ2dDREJvTElBQWdBVFlDRENBQklBQTJBZ2dNQ1FzZ0JFRVVhaUlES0FJQUlnQkZCRUFnQkNnQ0VDSUFSUTBESUFSQkVHb2hBd3NEUUNBRElRWWdBQ0lCUVJScUlnTW9BZ0FpQUEwQUlBRkJFR29oQXlBQktBSVFJZ0FOQUFzZ0JrRUFOZ0lBREFnTFFiekFBQ2dDQUNJQklBVlBCRUJCeU1BQUtBSUFJUUFDUUNBQklBVnJJZ0pCRUU4RVFFRzh3QUFnQWpZQ0FFSEl3QUFnQUNBRmFpSUROZ0lBSUFNZ0FrRUJjallDQkNBQUlBRnFJQUkyQWdBZ0FDQUZRUU55TmdJRURBRUxRY2pBQUVFQU5nSUFRYnpBQUVFQU5nSUFJQUFnQVVFRGNqWUNCQ0FBSUFGcUlnRWdBU2dDQkVFQmNqWUNCQXNnQUVFSWFpRUFEQW9MUWNEQUFDZ0NBQ0lCSUFWTEJFQkJ3TUFBSUFFZ0JXc2lBVFlDQUVITXdBQkJ6TUFBS0FJQUlnQWdCV29pQWpZQ0FDQUNJQUZCQVhJMkFnUWdBQ0FGUVFOeU5nSUVJQUJCQ0dvaEFBd0tDMEVBSVFBZ0JVRXZhaUlFQW45QmpNUUFLQUlBQkVCQmxNUUFLQUlBREFFTFFaakVBRUovTndJQVFaREVBRUtBb0lDQWdJQUVOd0lBUVl6RUFDQUxRUXhxUVhCeFFkaXExYW9GY3pZQ0FFR2d4QUJCQURZQ0FFSHd3d0JCQURZQ0FFR0FJQXNpQW1vaUJrRUFJQUpySWdkeElnSWdCVTBOQ1VIc3d3QW9BZ0FpQXdSQVFlVERBQ2dDQUNJSUlBSnFJZ2tnQ0UwTkNpQUpJQU5MRFFvTFFmRERBQzBBQUVFRWNRMEVBa0FDUUVITXdBQW9BZ0FpQXdSQVFmVERBQ0VBQTBBZ0FDZ0NBQ0lJSUFOTkJFQWdDQ0FBS0FJRWFpQURTdzBEQ3lBQUtBSUlJZ0FOQUFzTFFRQVFFeUlCUVg5R0RRVWdBaUVHUVpERUFDZ0NBQ0lBUVg5cUlnTWdBWEVFUUNBQ0lBRnJJQUVnQTJwQkFDQUFhM0ZxSVFZTElBWWdCVTBOQlNBR1FmNy8vLzhIU3cwRlFlekRBQ2dDQUNJQUJFQkI1TU1BS0FJQUlnTWdCbW9pQnlBRFRRMEdJQWNnQUVzTkJnc2dCaEFUSWdBZ0FVY05BUXdIQ3lBR0lBRnJJQWR4SWdaQi92Ly8vd2RMRFFRZ0JoQVRJZ0VnQUNnQ0FDQUFLQUlFYWtZTkF5QUJJUUFMQWtBZ0JVRXdhaUFHVFEwQUlBQkJmMFlOQUVHVXhBQW9BZ0FpQVNBRUlBWnJha0VBSUFGcmNTSUJRZjcvLy84SFN3UkFJQUFoQVF3SEN5QUJFQk5CZjBjRVFDQUJJQVpxSVFZZ0FDRUJEQWNMUVFBZ0Jtc1FFeG9NQkFzZ0FDSUJRWDlIRFFVTUF3dEJBQ0VFREFjTFFRQWhBUXdGQ3lBQlFYOUhEUUlMUWZEREFFSHd3d0FvQWdCQkJISTJBZ0FMSUFKQi92Ly8vd2RMRFFFZ0FoQVRJZ0ZCQUJBVElnQlBEUUVnQVVGL1JnMEJJQUJCZjBZTkFTQUFJQUZySWdZZ0JVRW9hazBOQVF0QjVNTUFRZVREQUNnQ0FDQUdhaUlBTmdJQUlBQkI2TU1BS0FJQVN3UkFRZWpEQUNBQU5nSUFDd0pBQWtBQ1FFSE13QUFvQWdBaUF3UkFRZlREQUNFQUEwQWdBU0FBS0FJQUlnSWdBQ2dDQkNJRWFrWU5BaUFBS0FJSUlnQU5BQXNNQWd0QnhNQUFLQUlBSWdCQkFDQUJJQUJQRzBVRVFFSEV3QUFnQVRZQ0FBdEJBQ0VBUWZqREFDQUdOZ0lBUWZUREFDQUJOZ0lBUWRUQUFFRi9OZ0lBUWRqQUFFR014QUFvQWdBMkFnQkJnTVFBUVFBMkFnQURRQ0FBUVFOMElnSkI1TUFBYWlBQ1FkekFBR29pQXpZQ0FDQUNRZWpBQUdvZ0F6WUNBQ0FBUVFGcUlnQkJJRWNOQUF0QndNQUFJQVpCV0dvaUFFRjRJQUZyUVFkeFFRQWdBVUVJYWtFSGNSc2lBbXNpQXpZQ0FFSE13QUFnQVNBQ2FpSUNOZ0lBSUFJZ0EwRUJjallDQkNBQUlBRnFRU2cyQWdSQjBNQUFRWnpFQUNnQ0FEWUNBQXdDQ3lBQUxRQU1RUWh4RFFBZ0FTQURUUTBBSUFJZ0Ewc05BQ0FBSUFRZ0JtbzJBZ1JCek1BQUlBTkJlQ0FEYTBFSGNVRUFJQU5CQ0dwQkIzRWJJZ0JxSWdFMkFnQkJ3TUFBUWNEQUFDZ0NBQ0FHYWlJQ0lBQnJJZ0EyQWdBZ0FTQUFRUUZ5TmdJRUlBSWdBMnBCS0RZQ0JFSFF3QUJCbk1RQUtBSUFOZ0lBREFFTElBRkJ4TUFBS0FJQUlnUkpCRUJCeE1BQUlBRTJBZ0FnQVNFRUN5QUJJQVpxSVFKQjlNTUFJUUFDUUFKQUFrQUNRQUpBQWtBRFFDQUNJQUFvQWdCSEJFQWdBQ2dDQ0NJQURRRU1BZ3NMSUFBdEFBeEJDSEZGRFFFTFFmVERBQ0VBQTBBZ0FDZ0NBQ0lDSUFOTkJFQWdBaUFBS0FJRWFpSUVJQU5MRFFNTElBQW9BZ2doQUF3QUFBc0FDeUFBSUFFMkFnQWdBQ0FBS0FJRUlBWnFOZ0lFSUFGQmVDQUJhMEVIY1VFQUlBRkJDR3BCQjNFYmFpSUpJQVZCQTNJMkFnUWdBa0Y0SUFKclFRZHhRUUFnQWtFSWFrRUhjUnRxSWdFZ0NXc2dCV3NoQUNBRklBbHFJUWNnQVNBRFJnUkFRY3pBQUNBSE5nSUFRY0RBQUVIQXdBQW9BZ0FnQUdvaUFEWUNBQ0FISUFCQkFYSTJBZ1FNQXdzZ0FVSEl3QUFvQWdCR0JFQkJ5TUFBSUFjMkFnQkJ2TUFBUWJ6QUFDZ0NBQ0FBYWlJQU5nSUFJQWNnQUVFQmNqWUNCQ0FBSUFkcUlBQTJBZ0FNQXdzZ0FTZ0NCQ0lDUVFOeFFRRkdCRUFnQWtGNGNTRUtBa0FnQWtIL0FVMEVRQ0FCS0FJSUlnTWdBa0VEZGlJRVFRTjBRZHpBQUdwSEdpQURJQUVvQWd3aUFrWUVRRUcwd0FCQnRNQUFLQUlBUVg0Z0JIZHhOZ0lBREFJTElBTWdBallDRENBQ0lBTTJBZ2dNQVFzZ0FTZ0NHQ0VJQWtBZ0FTQUJLQUlNSWdaSEJFQWdCQ0FCS0FJSUlnSk5CRUFnQWlnQ0RCb0xJQUlnQmpZQ0RDQUdJQUkyQWdnTUFRc0NRQ0FCUVJScUlnTW9BZ0FpQlEwQUlBRkJFR29pQXlnQ0FDSUZEUUJCQUNFR0RBRUxBMEFnQXlFQ0lBVWlCa0VVYWlJREtBSUFJZ1VOQUNBR1FSQnFJUU1nQmlnQ0VDSUZEUUFMSUFKQkFEWUNBQXNnQ0VVTkFBSkFJQUVnQVNnQ0hDSUNRUUowUWVUQ0FHb2lBeWdDQUVZRVFDQURJQVkyQWdBZ0JnMEJRYmpBQUVHNHdBQW9BZ0JCZmlBQ2QzRTJBZ0FNQWdzZ0NFRVFRUlFnQ0NnQ0VDQUJSaHRxSUFZMkFnQWdCa1VOQVFzZ0JpQUlOZ0lZSUFFb0FoQWlBZ1JBSUFZZ0FqWUNFQ0FDSUFZMkFoZ0xJQUVvQWhRaUFrVU5BQ0FHSUFJMkFoUWdBaUFHTmdJWUN5QUJJQXBxSVFFZ0FDQUthaUVBQ3lBQklBRW9BZ1JCZm5FMkFnUWdCeUFBUVFGeU5nSUVJQUFnQjJvZ0FEWUNBQ0FBUWY4QlRRUkFJQUJCQTNZaUFVRURkRUhjd0FCcUlRQUNmMEcwd0FBb0FnQWlBa0VCSUFGMElnRnhSUVJBUWJUQUFDQUJJQUp5TmdJQUlBQU1BUXNnQUNnQ0NBc2hBU0FBSUFjMkFnZ2dBU0FITmdJTUlBY2dBRFlDRENBSElBRTJBZ2dNQXdzZ0J3Si9RUUFnQUVFSWRpSUJSUTBBR2tFZklBQkIvLy8vQjBzTkFCb2dBU0FCUVlEK1AycEJFSFpCQ0hFaUFYUWlBaUFDUVlEZ0gycEJFSFpCQkhFaUFuUWlBeUFEUVlDQUQycEJFSFpCQW5FaUEzUkJEM1lnQVNBQ2NpQURjbXNpQVVFQmRDQUFJQUZCRldwMlFRRnhja0VjYWdzaUFUWUNIQ0FIUWdBM0FoQWdBVUVDZEVIa3dnQnFJUUlDUUVHNHdBQW9BZ0FpQTBFQklBRjBJZ1J4UlFSQVFiakFBQ0FESUFSeU5nSUFJQUlnQnpZQ0FBd0JDeUFBUVFCQkdTQUJRUUYyYXlBQlFSOUdHM1FoQXlBQ0tBSUFJUUVEUUNBQklnSW9BZ1JCZUhFZ0FFWU5BeUFEUVIxMklRRWdBMEVCZENFRElBSWdBVUVFY1dvaUJDZ0NFQ0lCRFFBTElBUWdCellDRUFzZ0J5QUNOZ0lZSUFjZ0J6WUNEQ0FISUFjMkFnZ01BZ3RCd01BQUlBWkJXR29pQUVGNElBRnJRUWR4UVFBZ0FVRUlha0VIY1JzaUFtc2lCellDQUVITXdBQWdBU0FDYWlJQ05nSUFJQUlnQjBFQmNqWUNCQ0FBSUFGcVFTZzJBZ1JCME1BQVFaekVBQ2dDQURZQ0FDQURJQVJCSnlBRWEwRUhjVUVBSUFSQldXcEJCM0ViYWtGUmFpSUFJQUFnQTBFUWFra2JJZ0pCR3pZQ0JDQUNRZnpEQUNrQ0FEY0NFQ0FDUWZUREFDa0NBRGNDQ0VIOHd3QWdBa0VJYWpZQ0FFSDR3d0FnQmpZQ0FFSDB3d0FnQVRZQ0FFR0F4QUJCQURZQ0FDQUNRUmhxSVFBRFFDQUFRUWMyQWdRZ0FFRUlhaUVCSUFCQkJHb2hBQ0FFSUFGTERRQUxJQUlnQTBZTkF5QUNJQUlvQWdSQmZuRTJBZ1FnQXlBQ0lBTnJJZ1JCQVhJMkFnUWdBaUFFTmdJQUlBUkIvd0ZOQkVBZ0JFRURkaUlCUVFOMFFkekFBR29oQUFKL1FiVEFBQ2dDQUNJQ1FRRWdBWFFpQVhGRkJFQkJ0TUFBSUFFZ0FuSTJBZ0FnQUF3QkN5QUFLQUlJQ3lFQklBQWdBellDQ0NBQklBTTJBZ3dnQXlBQU5nSU1JQU1nQVRZQ0NBd0VDeUFEUWdBM0FoQWdBd0ovUVFBZ0JFRUlkaUlBUlEwQUdrRWZJQVJCLy8vL0Iwc05BQm9nQUNBQVFZRCtQMnBCRUhaQkNIRWlBSFFpQVNBQlFZRGdIMnBCRUhaQkJIRWlBWFFpQWlBQ1FZQ0FEMnBCRUhaQkFuRWlBblJCRDNZZ0FDQUJjaUFDY21zaUFFRUJkQ0FFSUFCQkZXcDJRUUZ4Y2tFY2Fnc2lBRFlDSENBQVFRSjBRZVRDQUdvaEFRSkFRYmpBQUNnQ0FDSUNRUUVnQUhRaUJuRkZCRUJCdU1BQUlBSWdCbkkyQWdBZ0FTQUROZ0lBSUFNZ0FUWUNHQXdCQ3lBRVFRQkJHU0FBUVFGMmF5QUFRUjlHRzNRaEFDQUJLQUlBSVFFRFFDQUJJZ0lvQWdSQmVIRWdCRVlOQkNBQVFSMTJJUUVnQUVFQmRDRUFJQUlnQVVFRWNXb2lCaWdDRUNJQkRRQUxJQVlnQXpZQ0VDQURJQUkyQWhnTElBTWdBellDRENBRElBTTJBZ2dNQXdzZ0FpZ0NDQ0lBSUFjMkFnd2dBaUFITmdJSUlBZEJBRFlDR0NBSElBSTJBZ3dnQnlBQU5nSUlDeUFKUVFocUlRQU1CUXNnQWlnQ0NDSUFJQU0yQWd3Z0FpQUROZ0lJSUFOQkFEWUNHQ0FESUFJMkFnd2dBeUFBTmdJSUMwSEF3QUFvQWdBaUFDQUZUUTBBUWNEQUFDQUFJQVZySWdFMkFnQkJ6TUFBUWN6QUFDZ0NBQ0lBSUFWcUlnSTJBZ0FnQWlBQlFRRnlOZ0lFSUFBZ0JVRURjallDQkNBQVFRaHFJUUFNQXd0QnNNQUFRVEEyQWdCQkFDRUFEQUlMQWtBZ0NFVU5BQUpBSUFRb0Fod2lBRUVDZEVIa3dnQnFJZ01vQWdBZ0JFWUVRQ0FESUFFMkFnQWdBUTBCUWJqQUFDQUhRWDRnQUhkeElnYzJBZ0FNQWdzZ0NFRVFRUlFnQ0NnQ0VDQUVSaHRxSUFFMkFnQWdBVVVOQVFzZ0FTQUlOZ0lZSUFRb0FoQWlBQVJBSUFFZ0FEWUNFQ0FBSUFFMkFoZ0xJQVFvQWhRaUFFVU5BQ0FCSUFBMkFoUWdBQ0FCTmdJWUN3SkFJQUpCRDAwRVFDQUVJQUlnQldvaUFFRURjallDQkNBQUlBUnFJZ0FnQUNnQ0JFRUJjallDQkF3QkN5QUVJQVZCQTNJMkFnUWdCQ0FGYWlJRElBSkJBWEkyQWdRZ0FpQURhaUFDTmdJQUlBSkIvd0ZOQkVBZ0FrRURkaUlCUVFOMFFkekFBR29oQUFKL1FiVEFBQ2dDQUNJQ1FRRWdBWFFpQVhGRkJFQkJ0TUFBSUFFZ0FuSTJBZ0FnQUF3QkN5QUFLQUlJQ3lFQklBQWdBellDQ0NBQklBTTJBZ3dnQXlBQU5nSU1JQU1nQVRZQ0NBd0JDeUFEQW45QkFDQUNRUWgySWdCRkRRQWFRUjhnQWtILy8vOEhTdzBBR2lBQUlBQkJnUDQvYWtFUWRrRUljU0lBZENJQklBRkJnT0FmYWtFUWRrRUVjU0lCZENJRklBVkJnSUFQYWtFUWRrRUNjU0lGZEVFUGRpQUFJQUZ5SUFWeWF5SUFRUUYwSUFJZ0FFRVZhblpCQVhGeVFSeHFDeUlBTmdJY0lBTkNBRGNDRUNBQVFRSjBRZVRDQUdvaEFRSkFBa0FnQjBFQklBQjBJZ1Z4UlFSQVFiakFBQ0FGSUFkeU5nSUFJQUVnQXpZQ0FBd0JDeUFDUVFCQkdTQUFRUUYyYXlBQVFSOUdHM1FoQUNBQktBSUFJUVVEUUNBRklnRW9BZ1JCZUhFZ0FrWU5BaUFBUVIxMklRVWdBRUVCZENFQUlBRWdCVUVFY1dvaUJpZ0NFQ0lGRFFBTElBWWdBellDRUFzZ0F5QUJOZ0lZSUFNZ0F6WUNEQ0FESUFNMkFnZ01BUXNnQVNnQ0NDSUFJQU0yQWd3Z0FTQUROZ0lJSUFOQkFEWUNHQ0FESUFFMkFnd2dBeUFBTmdJSUN5QUVRUWhxSVFBTUFRc0NRQ0FKUlEwQUFrQWdBU2dDSENJQVFRSjBRZVRDQUdvaUFpZ0NBQ0FCUmdSQUlBSWdCRFlDQUNBRURRRkJ1TUFBSUFwQmZpQUFkM0UyQWdBTUFnc2dDVUVRUVJRZ0NTZ0NFQ0FCUmh0cUlBUTJBZ0FnQkVVTkFRc2dCQ0FKTmdJWUlBRW9BaEFpQUFSQUlBUWdBRFlDRUNBQUlBUTJBaGdMSUFFb0FoUWlBRVVOQUNBRUlBQTJBaFFnQUNBRU5nSVlDd0pBSUFOQkQwMEVRQ0FCSUFNZ0JXb2lBRUVEY2pZQ0JDQUFJQUZxSWdBZ0FDZ0NCRUVCY2pZQ0JBd0JDeUFCSUFWQkEzSTJBZ1FnQVNBRmFpSUVJQU5CQVhJMkFnUWdBeUFFYWlBRE5nSUFJQWdFUUNBSVFRTjJJZ1ZCQTNSQjNNQUFhaUVBUWNqQUFDZ0NBQ0VDQW45QkFTQUZkQ0lGSUFaeFJRUkFRYlRBQUNBRklBWnlOZ0lBSUFBTUFRc2dBQ2dDQ0FzaEJTQUFJQUkyQWdnZ0JTQUNOZ0lNSUFJZ0FEWUNEQ0FDSUFVMkFnZ0xRY2pBQUNBRU5nSUFRYnpBQUNBRE5nSUFDeUFCUVFocUlRQUxJQXRCRUdva0FDQUFDMFFCQVg4Z0FDQUFLQUlRSUFGcUlnRTJBaEFnQUNBQlFRZHhOZ0lJUVg4aEFpQUJJQUFvQWd4QkEzUk5CSDhnQUNBQUtBSUFJQUZCQTNacU5nSUVRUUFGUVg4TEMrVUhBUWgvSUFBZ0JFRUFJQVpySUFJZ0FpQUdha0VBU0JzaUFpQUNJQVJLR3lJQ2FpQUFJQUpCQUVvYklna2dCVUVBSUFkcklBTWdBeUFIYWtFQVNCc2lBQ0FBSUFWS0d5SUFJQVJzYWlBSklBQkJBRW9iSVFNZ0IwRUFJQUJySUFCQkgzVnhJZ2xySUFBZ0Iyb2lBQ0FGYXlJTVFRQWdBQ0FGU2hzaUQyc2hDeUFHUVFBZ0Ftc2lEaUFDUVI5MWNTSU5heUFDSUFacUlnQWdCR3RCQUNBQUlBUktJZ1ViSWdwcklRQUNRQ0FDUVFCSUlBVnlJaEJGQkVBZ0NRUkFBMEFnQVNBRElBQVFGU0FJYWlFQklBbEJmMm9pQ1EwQUN3c2dDMFVOQVFOQUlBRWdBeUFBRUJVZ0NHb2hBU0FESUFScUlRTWdDMEYvYWlJTERRQUxEQUVMQWtBZ0NVVU5BQ0FOUlFSQUEwQWdBQ0VISUFFaEFpQURJUVVnQUFSQUEwQWdBaUFGTFFBQU9nQUFJQUpCQVdvaEFpQUZRUUZxSVFVZ0IwRi9haUlIRFFBTEN5QUtCRUFnQWlBRlFYOXFMUUFBSUFvUUJ4b0xJQUVnQ0dvaEFTQUpRWDlxSWdrTkFBd0NBQXNBQ3lBQklBNXFJUVlEUUNBQklBTXRBQUFnRFJBSElRRWdBQ0VISUFZaEFpQURJUVVnQUFSQUEwQWdBaUFGTFFBQU9nQUFJQUpCQVdvaEFpQUZRUUZxSVFVZ0IwRi9haUlIRFFBTEN5QUtCRUFnQWlBRlFYOXFMUUFBSUFvUUJ4b0xJQVlnQ0dvaEJpQUJJQWhxSVFFZ0NVRi9haUlKRFFBTEN5QUxSUTBBSUExRkJFQURRQ0FBSVFjZ0FTRUNJQU1oQlNBQUJFQURRQ0FDSUFVdEFBQTZBQUFnQWtFQmFpRUNJQVZCQVdvaEJTQUhRWDlxSWdjTkFBc0xJQW9FUUNBQ0lBVkJmMm90QUFBZ0NoQUhHZ3NnQVNBSWFpRUJJQU1nQkdvaEF5QUxRWDlxSWdzTkFBd0NBQXNBQ3lBQklBNXFJUWtEUUNBQklBTXRBQUFnRFJBSElRRWdBQ0VISUFraEFpQURJUVVnQUFSQUEwQWdBaUFGTFFBQU9nQUFJQUpCQVdvaEFpQUZRUUZxSVFVZ0IwRi9haUlIRFFBTEN5QUtCRUFnQWlBRlFYOXFMUUFBSUFvUUJ4b0xJQWdnQ1dvaENTQUJJQWhxSVFFZ0F5QUVhaUVESUF0QmYyb2lDdzBBQ3dzQ1FDQVBSUTBBSUFNZ0JHc2hBeUFRUlFSQUEwQWdBU0FESUFBUUZTQUlhaUVCSUF4QmYyb2lEQTBBREFJQUN3QUxJQTFGQkVBRFFDQURJUUlnQVNFRklBQWhCeUFBQkVBRFFDQUZJQUl0QUFBNkFBQWdCVUVCYWlFRklBSkJBV29oQWlBSFFYOXFJZ2NOQUFzTElBb0VRQ0FGSUFKQmYyb3RBQUFnQ2hBSEdnc2dBU0FJYWlFQklBeEJmMm9pREEwQURBSUFDd0FMSUFFZ0Rtb2hDUU5BSUFFZ0F5MEFBQ0FORUFjaEFTQUFJUWNnQ1NFQ0lBTWhCU0FBQkVBRFFDQUNJQVV0QUFBNkFBQWdBa0VCYWlFQ0lBVkJBV29oQlNBSFFYOXFJZ2NOQUFzTElBb0VRQ0FDSUFWQmYyb3RBQUFnQ2hBSEdnc2dDQ0FKYWlFSklBRWdDR29oQVNBTVFYOXFJZ3dOQUFzTEMvUUNBUU4vSUFGQkEzUkI4RFpxSWdNb0FnQWhCU0FETFFBRUlRTWdBVUVEZEVHd05Xb2lBUzBBQkNFRUFrQWdBU2dDQUVFRVJnUkFJQUlnQkVFQmRHb3VBUUFoQVNBRlFRUkdCRUFnQVNBQ0lBTkJBWFJxTGdFQWFrRUJha0VCZFE4TEFuOGdBQ2dDekFFaUFnUkFJQUFvQWdRZ0FpZ0NCRVlNQVF0QkFBdEZEUUVnQVNBQUtBTE1BU0FEUVFGMGFpNEJIR3BCQVdwQkFYVVBDeUFGUVFSR0JFQWdBaUFEUVFGMGFpNEJBQ0VCQW44Z0FDZ0N5QUVpQWdSQUlBQW9BZ1FnQWlnQ0JFWU1BUXRCQUF0RkRRRWdBU0FBS0FMSUFTQUVRUUYwYWk0QkhHcEJBV3BCQVhVUEN3Si9BbjhnQUNnQ3lBRWlBUVJBSUFBb0FnUWdBU2dDQkVZTUFRdEJBQXRGQkVCQkFDRUNRUUFNQVF0QkFTRUNJQUFvQXNnQklBUkJBWFJxTGdFY0N5RUJBbjhnQUNnQ3pBRWlCQVJBSUFBb0FnUWdCQ2dDQkVZTUFRdEJBQXRGRFFBZ0FDZ0N6QUVnQTBFQmRHb3VBUndoQUNBQ1JRUkFJQUFQQ3lBQUlBRnFRUUZxUVFGMUlRRUxJQUVMaVFjQkIzOGdBeUFGYWlJTklBRXVBUUFpREVFQ2RXb2hBeUFFSUFacUlnNGdBUzRCQWlJUFFRSjFhaUVFSUFJb0FnaEJCSFFoQ1NBQ0tBSUVRUVIwSVFvZ0FDQUdRUVIwYWlBRmFpRUxBa0FnREVFRGNVRUVkQ0FQUVFOeFFRSjBja0hRTzJvb0FnQWlERUVPVFFSQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFJQXhCQVdzT0RnRUNBd1FGQmdjSUNRb0xEQTBPQUFzZ0FpZ0NBQ0FMSUFNZ0JDQUtJQWtnQnlBSVFSQVFEQXdQQ3lBQ0tBSUFJQXNnQXlBRVFYNXFJQW9nQ1NBSElBaEJBQkFrREE0TElBSW9BZ0FnQ3lBRElBUkJmbW9nQ2lBSklBY2dDQkJIREEwTElBSW9BZ0FnQ3lBRElBUkJmbW9nQ2lBSklBY2dDRUVCRUNRTURBc2dBaWdDQUNBTElBTkJmbW9nQkNBS0lBa2dCeUFJUVFBUUl3d0xDeUFDS0FJQUlBc2dBMEYrYWlBRVFYNXFJQW9nQ1NBSElBaEJBQkFhREFvTElBSW9BZ0FnQ3lBRFFYNXFJQVJCZm1vZ0NpQUpJQWNnQ0VFQUVDRU1DUXNnQWlnQ0FDQUxJQU5CZm1vZ0JFRithaUFLSUFrZ0J5QUlRUUlRR2d3SUN5QUNLQUlBSUFzZ0EwRithaUFFSUFvZ0NTQUhJQWdRUmd3SEN5QUNLQUlBSUFzZ0EwRithaUFFUVg1cUlBb2dDU0FISUFoQkFCQWlEQVlMSUFJb0FnQWdDeUFEUVg1cUlBUkJmbW9nQ2lBSklBY2dDQkJGREFVTElBSW9BZ0FnQ3lBRFFYNXFJQVJCZm1vZ0NpQUpJQWNnQ0VFQkVDSU1CQXNnQWlnQ0FDQUxJQU5CZm1vZ0JDQUtJQWtnQnlBSVFRRVFJd3dEQ3lBQ0tBSUFJQXNnQTBGK2FpQUVRWDVxSUFvZ0NTQUhJQWhCQVJBYURBSUxJQUlvQWdBZ0N5QURRWDVxSUFSQmZtb2dDaUFKSUFjZ0NFRUJFQ0VNQVFzZ0FpZ0NBQ0FMSUFOQmZtb2dCRUYrYWlBS0lBa2dCeUFJUVFNUUdnc2dEVUVCZGlBQkxnRUFJZ2xCQTNWcUlRTWdEa0VCZGlBQkxnRUNJZ0ZCQTNWcUlRUWdBaWdDQUNBQ0tBSUVJZ29nQWlnQ0NDSUxiRUVJZEdvaEFpQUFJQVpCQW5SQmVIRnFJQVZCQVhacVFZQUNhaUVGSUFoQkFYWWhCaUFIUVFGMklRY2dBVUVIY1NFSUlBdEJBM1FoQUNBS1FRTjBJUUVDUUNBSlFRZHhJZ2xGRFFBZ0NFVU5BQ0FDSUFVZ0F5QUVJQUVnQUNBSklBZ2dCeUFHRUVnUEN5QUpCRUFnQWlBRklBTWdCQ0FCSUFBZ0NTQUhJQVlRU3c4TElBZ0VRQ0FDSUFVZ0F5QUVJQUVnQUNBSUlBY2dCaEJLRHdzZ0FpQUZJQU1nQkNBQklBQWdCeUFHUVFnUURDQUNJQUFnQVd4cUlBVkJRR3NnQXlBRUlBRWdBQ0FISUFaQkNCQU1DOGNCQVFSL0lBQW9BZ1FoQWdKQUlBQW9BZ3hCQTNRZ0FDZ0NFR3NpQTBFZ1RnUkFJQUlvQUFBaUFVRVlkQ0FCUVFoMFFZQ0EvQWR4Y2lBQlFRaDJRWUQrQTNFZ0FVRVlkbkp5SVFFZ0FDZ0NDQ0lBUlEwQklBRWdBSFFnQWkwQUJFRUlJQUJyZG5JUEN5QURRUUZJQkVCQkFBOExJQUl0QUFBZ0FDZ0NDQ0lBUVJocUlnUjBJUUVnQUNBRGFrRjRhaUlBUVFGSURRQURRQ0FDTFFBQklBUkJlR29pQkhRZ0FYSWhBU0FBUVFoS0lRTWdBa0VCYWlFQ0lBQkJlR29oQUNBRERRQUxDeUFCQzR3RUFRZC9Ba0FnQUVGL2FpSUlMUUFBSWdVZ0FDMEFBQ0lHYXlJRUlBUkJIM1VpQkdvZ0JITWdBaWdDQkU4TkFDQUFRWDVxTFFBQUlnUWdCV3NpQnlBSFFSOTFJZ2RxSUFkeklBSW9BZ2dpQ1U4TkFDQUFMUUFCSWdjZ0Jtc2lDaUFLUVI5MUlncHFJQXB6SUFsUERRQWdBVUVEVFFSQUlBZ2dCU0FCSUFJb0FnQnFRWDlxTFFBQUlnaEJmM01pQ1NBSVFRRnFJZ2dnQmlBRmEwRUNkQ0FIYXlBRWFrRUVha0VEZFNJRklBVWdDRW9iSUFVZ0NVZ2JJZ1ZxUWJBdWFpMEFBRG9BQUNBQUlBWWdCV3RCc0M1cUxRQUFPZ0FBREFFTElBZ2dCU0FIYWlBRVFRRjBha0VDYWtFQ2Rqb0FBQ0FBSUFZZ0IwRUJkR29nQkdwQkFtcEJBblk2QUFBTEFrQWdBQ0FEYWlJQVFYOXFJZ2N0QUFBaUF5QUFMUUFBSWdWcklnWWdCa0VmZFNJR2FpQUdjeUFDS0FJRVR3MEFJQUJCZm1vdEFBQWlCaUFEYXlJRUlBUkJIM1VpQkdvZ0JITWdBaWdDQ0NJSVR3MEFJQUF0QUFFaUJDQUZheUlKSUFsQkgzVWlDV29nQ1hNZ0NFOE5BQ0FCUVFOTkJFQWdCeUFCSUFJb0FnQnFRWDlxTFFBQUlnRkJmM01pQWlBQlFRRnFJZ2NnQlNBRGEwRUNkQ0FFYXlBR2FrRUVha0VEZFNJQklBRWdCMG9iSUFFZ0FrZ2JJZ0VnQTJwQnNDNXFMUUFBT2dBQUlBQWdCU0FCYTBHd0xtb3RBQUE2QUFBUEN5QUhJQU1nQkdvZ0JrRUJkR3BCQW1wQkFuWTZBQUFnQUNBRklBUkJBWFJxSUFacVFRSnFRUUoyT2dBQUN3dEhBQUpBSUFGQkJFMEVRQUpBQWtBQ1FBSkFJQUZCQVdzT0JBRUNBd1VBQ3lBQUtBTElBUThMSUFBb0Fzd0JEd3NnQUNnQzBBRVBDeUFBS0FMVUFROExRUUFoQUFzZ0FBdWxBd0VMZjBFQUlBTnJJZ3RCQVhRaEJDQUJJQUlvQWdCcVFYOXFMUUFBSWdGQkFXb2hDU0FCUVg5eklRb0NRQ0FBSUFOcklnY3RBQUFpQlNBQUxRQUFJZ1pySWdFZ0FVRWZkU0lCYWlBQmN5QUNLQUlFSWdGUERRQWdBQ0FFYWkwQUFDSU5JQVZySWdnZ0NFRWZkU0lJYWlBSWN5QUNLQUlJSWdoUERRQWdBQ0FEYWkwQUFDSU9JQVpySWd3Z0RFRWZkU0lNYWlBTWN5QUlUdzBBSUFjZ0NpQUpJQVlnQld0QkFuUWdEbXNnRFdwQkJHcEJBM1VpQVNBQklBbEtHeUFCSUFwSUd5SUJJQVZxUWJBdWFpMEFBRG9BQUNBQUlBWWdBV3RCc0M1cUxRQUFPZ0FBSUFJb0FnUWhBUXNDUUNBQVFRRnFJZ1VnQzJvaUN5MEFBQ0lHSUFBdEFBRWlBR3NpQnlBSFFSOTFJZ2RxSUFkeklBRlBEUUFnQkNBRmFpMEFBQ0lCSUFacklnUWdCRUVmZFNJRWFpQUVjeUFDS0FJSUlnSlBEUUFnQXlBRmFpMEFBQ0lESUFCcklnUWdCRUVmZFNJRWFpQUVjeUFDVHcwQUlBc2dDaUFKSUFBZ0JtdEJBblFnQTJzZ0FXcEJCR3BCQTNVaUFTQUJJQWxLR3lBQklBcElHeUlCSUFacVFiQXVhaTBBQURvQUFDQUZJQUFnQVd0QnNDNXFMUUFBT2dBQUN3dFZBUUovUWJERUFDZ0NBQ0lCSUFCQkEycEJmSEVpQW1vaEFBSkFJQUpCQVU1QkFDQUFJQUZOR3cwQUlBQS9BRUVRZEVzRVFDQUFFQUZGRFFFTFFiREVBQ0FBTmdJQUlBRVBDMEd3d0FCQk1EWUNBRUYvQ3pRQkFYOENRQ0FCUVJCTERRQWdBQ2dDQkNBQlFRSjBhaWdDQUNJQVJRMEFJQUFvQWhSQkFra05BQ0FBS0FJQUlRSUxJQUlMZ2dRQkEzOGdBa0dBQkU4RVFDQUFJQUVnQWhBQUdpQUFEd3NnQUNBQ2FpRURBa0FnQUNBQmMwRURjVVVFUUFKQUlBSkJBVWdFUUNBQUlRSU1BUXNnQUVFRGNVVUVRQ0FBSVFJTUFRc2dBQ0VDQTBBZ0FpQUJMUUFBT2dBQUlBRkJBV29oQVNBQ1FRRnFJZ0lnQTA4TkFTQUNRUU54RFFBTEN3SkFJQU5CZkhFaUJFSEFBRWtOQUNBQ0lBUkJRR29pQlVzTkFBTkFJQUlnQVNnQ0FEWUNBQ0FDSUFFb0FnUTJBZ1FnQWlBQktBSUlOZ0lJSUFJZ0FTZ0NERFlDRENBQ0lBRW9BaEEyQWhBZ0FpQUJLQUlVTmdJVUlBSWdBU2dDR0RZQ0dDQUNJQUVvQWh3MkFod2dBaUFCS0FJZ05nSWdJQUlnQVNnQ0pEWUNKQ0FDSUFFb0FpZzJBaWdnQWlBQktBSXNOZ0lzSUFJZ0FTZ0NNRFlDTUNBQ0lBRW9BalEyQWpRZ0FpQUJLQUk0TmdJNElBSWdBU2dDUERZQ1BDQUJRVUJySVFFZ0FrRkFheUlDSUFWTkRRQUxDeUFDSUFSUERRRURRQ0FDSUFFb0FnQTJBZ0FnQVVFRWFpRUJJQUpCQkdvaUFpQUVTUTBBQ3d3QkN5QURRUVJKQkVBZ0FDRUNEQUVMSUFOQmZHb2lCQ0FBU1FSQUlBQWhBZ3dCQ3lBQUlRSURRQ0FDSUFFdEFBQTZBQUFnQWlBQkxRQUJPZ0FCSUFJZ0FTMEFBam9BQWlBQ0lBRXRBQU02QUFNZ0FVRUVhaUVCSUFKQkJHb2lBaUFFVFEwQUN3c2dBaUFEU1FSQUEwQWdBaUFCTFFBQU9nQUFJQUZCQVdvaEFTQUNRUUZxSWdJZ0EwY05BQXNMSUFBTHdSZ0JJSDhqQUVIUUEyc2lCaVFBSUFFb0FnZ2hGQ0FCSUFFb0FnUWlDaUFDYkNJYUlBTnFFQjBnQVNnQ0FDRUpJQUJCQURZQ0NDQUFRaWczQWhRZ0FFSUFOd0lNSUFCQkJqWUNBQ0FEUVFSMElRY0NRQUpBQWtBZ0JFRithaUlFUVFWTERRQUNRQ0FFUVFGckRnUUJBUUVCQUFzTUFRc2dCa0VBTmdJTUlBWWdGRFlDR0NBR0lBbzJBaFFnQmlBRk5nSVFJQVVFUUNBR1FkQUFhaUFHUVF4cUlBWkJFR29nQnlBQ1FRUjBRUUJCQUVFUVFSQVFEZ3dDQ3dzZ0JrSFFBR3BCQUVHQUF4QUhHaUFKSUJwQkNIUnFJQWRxSVF3Z0JrSUFOd05JSUFaQlFHdENBRGNEQUNBR1FnQTNBemdnQmtJQU53TXdJQVpDQURjREtDQUdRZ0EzQXlBZ0JrSUFOd01ZSUFaQ0FEY0RFRUVBSVFrQ2YwRUFJQUpGRFFBYVFRQWdBRUVBSUFwclFkZ0JiR29vQXNRQlJRMEFHaUFHSUF3Z0NrRUVkR3NpQkMwQUJTQUVMUUFFYWlBRUxRQUdhaUFFTFFBSGFpSVhJQVF0QUFNZ0JDMEFBaUFFTFFBQklBUXRBQUJxYW1vaUZtb2lCU0FFTFFBTElBUXRBQW9nQkMwQUNTQUVMUUFJYW1wcUloSnJJQVF0QUE4Z0JDMEFEaUFFTFFBTklBUXRBQXhxYW1vaUUyc2lDRFlDRkNBR0lBVWdFbW9nRTJvaUNUWUNFRUVCQ3lFRkFuOENRQ0FDSUJSQmYycEhCRUFnQUNBS1FkZ0JiR29vQXNRQkRRRUxJQVVNQVFzZ0JpQU1JQXBCQ0hScUlnSXRBQVVnQWkwQUJHb2dBaTBBQm1vZ0FpMEFCMm9pSGlBQ0xRQURJQUl0QUFJZ0FpMEFBU0FDTFFBQWFtcHFJaDlxSWdRZ0FpMEFDeUFDTFFBS0lBSXRBQWtnQWkwQUNHcHFhaUlZYXlBQ0xRQVBJQUl0QUE0Z0FpMEFEU0FDTFFBTWFtcHFJaGxySUFocUlnZzJBaFFnQmlBRUlCaHFJQWxxSUJscUlnazJBaEJCQVNFUUlBVkJBV29MSVFkQkFDRUVBbjhDUUNBRFJRMEFJQUJCYkdvb0FnQkZEUUFnQmlBTVFYOXFJZ0lnQ2tFR2RDSU9haUlFSUFwQkJIUWlDMm90QUFBZ0JDMEFBR29nQkNBS1FRVjBJZzlxTFFBQWFpQUVJQXBCTUd3aURXb3RBQUJxSWhzZ0FpQU5haTBBQUNBQ0lBOXFMUUFBSUFJZ0Myb3RBQUFnQWkwQUFHcHFhaUljYWlJUklBUWdEbW9pQWlBTGFpMEFBQ0FDTFFBQWFpQUNJQTlxTFFBQWFpQUNJQTFxTFFBQWFpSVZheUFDSUE1cUlnSWdDMm90QUFBZ0FpMEFBR29nQWlBUGFpMEFBR29nQWlBTmFpMEFBR29pRDJzaUJEWUNJQ0FHSUJFZ0ZXb2dDV29nRDJvaUNUWUNFQ0FIUVFGcUlRdEJBUXdCQ3lBSElRdEJBQXNoQWdKQUFrQUNRQUpBQWtBQ1FDQURJQXBCZjJwSEJFQWdBQ2dDbkFNTkFRdEJBQ0VPSUFKQkFFY2hFU0FIRFFFTUFnc2dCaUFFSUF4QkVHb2lCQ0FLUVFaMEloMXFJZ0FnQ2tFRWRDSU5haTBBQUNBQUxRQUFhaUFBSUFwQkJYUWlEbW90QUFCcUlBQWdDa0V3YkNJUmFpMEFBR29pSUNBRUlCRnFMUUFBSUFRZ0Rtb3RBQUFnQkNBTmFpMEFBQ0FNTFFBUWFtcHFJaUZxSWlJZ0FDQWRhaUlBSUExcUxRQUFJQUF0QUFCcUlBQWdEbW90QUFCcUlBQWdFV290QUFCcUlneHJJQUFnSFdvaUFDQU5haTBBQUNBQUxRQUFhaUFBSUE1cUxRQUFhaUFBSUJGcUxRQUFhaUlOYTJvaUJEWUNJQ0FHSUF3Z0ltb2dDV29nRFdvaUNUWUNFQ0FDUVFCSElSRkJBU0VPSUFKQkFXb2hBQ0FMUVFGcUlRc0NRQ0FIRFFBZ0FrVU5BQ0FHSUJzZ0hHb2dGV29nRDJvZ0lXc2dJR3NnREdzZ0RXdEJCWFVpQ0RZQ0ZBd0RDeUFIUlEwQ0lBQWhBZ3NnQmlBSUlBZEJBMnAxSWdnMkFoUUxBa0FnRUVVTkFDQUZSUTBBSUFJTkFDQUdJQllnRjJvZ0Vtb2dFMm9nR1dzZ0dHc2dIbXNnSDJ0QkJYVWlCRFlDSUVFQklSQkJBU0VOREFNTElCQkJBRWNoRUNBRlFRQkhJUTBnQWtVTkFnd0JDeUFRUVFCSElSQWdCVUVBUnlFTklBQWhBZ3NnQmlBRUlBSkJBMnAxSWdRMkFpQUxJQVlDZnlBTFFYOXFJZ0JCQWswRVFBSkFBa0FDUUNBQVFRRnJEZ0lCQWdBTElBbEJCSFlNQXdzZ0NVRUZkZ3dDQ3lBSlFSVnNRUXAxREFFTElBbEJCbllMSWdBMkFoQUNRQ0FFSUFoeVJRUkFJQVlnQURZQ1NDQUdJQUEyQWt3Z0JpQUFOZ0pFSUFZZ0FEWUNRQ0FHSUFBMkFqd2dCaUFBTmdJNElBWWdBRFlDTkNBR0lBQTJBakFnQmlBQU5nSXNJQVlnQURZQ0tDQUdJQUEyQWlRZ0JpQUFOZ0lnSUFZZ0FEWUNIQ0FHSUFBMkFoZ2dCaUFBTmdJVURBRUxJQVlnQUNBSWFpSUZJQVJyTmdKQUlBWWdCU0FFUVFGMUlnSnJOZ0l3SUFZZ0FpQUZhallDSUNBR0lBUWdCV28yQWhBZ0JpQUFJQWhySWdVZ0JHczJBa3dnQmlBRklBSnJOZ0k4SUFZZ0FpQUZhallDTENBR0lBUWdCV28yQWh3Z0JpQUFJQWhCQVhVaUIyb2lCU0FFYXpZQ1JDQUdJQVVnQW1zMkFqUWdCaUFDSUFWcU5nSWtJQVlnQkNBRmFqWUNGQ0FHSUFBZ0Iyc2lBQ0FFYXpZQ1NDQUdJQUFnQW1zMkFqZ2dCaUFBSUFKcU5nSW9JQVlnQUNBRWFqWUNHQXNnQmtIUUFHb2hDQ0FHUVJCcUlRQkJBQ0VFQTBBZ0NDQUFJQVJCREhGcUtBSUFJZ0pCL3dFZ0FrSC9BVWdiSWdKQkFDQUNRUUJLR3pvQUFDQUFJQUJCRUdvZ0JFRUJhaUlFUVQ5eEd5RUFJQWhCQVdvaENDQUVRWUFDUncwQUN5QUJLQUlBSUFvZ0ZHd2lBRUVJZEdvZ0drRUdkR29nQTBFRGRHb2hBeUFLUVFSMElRd2dDa0VHZENFYUlBQkJCblFoSFVFQUlBcEJBM1FpQzJzaElDQUdRZEFDYWlFaElBWkJRR3NoSWtFQUlRVURRQ0FHUWdBM0EwZ2dJa0lBTndNQUlBWkNBRGNET0NBR1FnQTNBekFnQmtJQU53TW9JQVpDQURjRElDQUdRZ0EzQXhnZ0JrSUFOd01RUVFBaENFRUFJUVJCQUNFSklBMEVRQ0FHSUFNZ0lHb2lBQzBBQXlBQUxRQUNhaUlYSUFBdEFBRWdBQzBBQUdvaUZtb2lBaUFBTFFBRklBQXRBQVJxSWhKcklBQXRBQWNnQUMwQUJtb2lFMnNpQ0RZQ0ZDQUdJQUlnRW1vZ0Uyb2lCRFlDRUVFQklRa0xJQkFFUUNBR0lBTWdHbW9pQUMwQUF5QUFMUUFDYWlJZUlBQXRBQUVnQUMwQUFHb2lIMm9pQWlBQUxRQUZJQUF0QUFScUloaHJJQUF0QUFjZ0FDMEFCbW9pR1dzZ0NHb2lDRFlDRkNBR0lBSWdHR29nQkdvZ0dXb2lCRFlDRUNBSlFRRnFJUWtMUVFBaEFBSi9JQkZGQkVBZ0NTRUhRUUFNQVFzZ0JpQURRWDlxSWdBZ0RHb2lBaUFMYWkwQUFDQUNMUUFBYWlJYklBQWdDMm90QUFBZ0FDMEFBR29pSEdvaUJ5QUNJQXhxSWdBZ0Myb3RBQUFnQUMwQUFHb2lGV3NnQUNBTWFpSUFJQXRxTFFBQUlBQXRBQUJxSWc5cklnQTJBaUFnQmlBSElCVnFJQVJxSUE5cUlnUTJBaEFnQ1VFQmFpRUhRUUVMSVFJQ1FDQUdBbjhDUUFKQUFrQWdEa1VFUUNBSkRRRU1BZ3NnQmlBQUlBTkJDR29pQ2lBTWFpSUFJQXRxTFFBQUlBQXRBQUJxSWlNZ0NpQUxhaTBBQUNBRExRQUlhaUlrYWlJbElBQWdER29pQUNBTGFpMEFBQ0FBTFFBQWFpSUtheUFBSUF4cUlnQWdDMm90QUFBZ0FDMEFBR29pRkd0cUlnQTJBaUFnQmlBS0lDVnFJQVJxSUJScUlnUTJBaEFnQWtFQmFpRUNJQWRCQVdvaEJ5QVJRUUZ6SUFsQkFFZHlSUVJBSUFZZ0d5QWNhaUFWYWlBUGFpQWtheUFqYXlBS2F5QVVhMEVFZFNJSU5nSVVEQU1MSUFsRkRRSUxJQVlnQ0NBSlFRSnFkU0lJTmdJVUN5QVdJQmRxSUJKcUlCTnFJQmxySUJocklCNXJJQjlyUVFSMUlCQWdEU0FDUlhGeFFRRkdEUUVhSUFKRkRRSUxJQUFnQWtFQ2FuVUxJZ0EyQWlBTElBWUNmeUFIUVg5cUlnSkJBazBFUUFKQUFrQUNRQ0FDUVFGckRnSUJBZ0FMSUFSQkEzWU1Bd3NnQkVFRWRnd0NDeUFFUVJWc1FRbDJEQUVMSUFSQkJYWUxJZ1EyQWhBQ1FDQUFJQWh5UlFSQUlBWWdCRFlDU0NBR0lBUTJBa3dnQmlBRU5nSkVJQVlnQkRZQ1FDQUdJQVEyQWp3Z0JpQUVOZ0k0SUFZZ0JEWUNOQ0FHSUFRMkFqQWdCaUFFTmdJc0lBWWdCRFlDS0NBR0lBUTJBaVFnQmlBRU5nSWdJQVlnQkRZQ0hDQUdJQVEyQWhnZ0JpQUVOZ0lVREFFTElBWWdCQ0FJYWlJSElBQnJOZ0pBSUFZZ0J5QUFRUUYxSWdKck5nSXdJQVlnQWlBSGFqWUNJQ0FHSUFBZ0IybzJBaEFnQmlBRUlBaHJJZ2NnQUdzMkFrd2dCaUFISUFKck5nSThJQVlnQWlBSGFqWUNMQ0FHSUFBZ0IybzJBaHdnQmlBRUlBaEJBWFVpQ1dvaUJ5QUFhellDUkNBR0lBY2dBbXMyQWpRZ0JpQUNJQWRxTmdJa0lBWWdBQ0FIYWpZQ0ZDQUdJQVFnQ1dzaUJDQUFhellDU0NBR0lBUWdBbXMyQWpnZ0JpQUNJQVJxTmdJb0lBWWdBQ0FFYWpZQ0dBc2dJU0FGUVFaMGFpRUlRUUFoQUNBR1FSQnFJUVFEUUNBSUlBUWdBRUVCZEVFTWNXb29BZ0FpQWtIL0FTQUNRZjhCU0JzaUFrRUFJQUpCQUVvYk9nQUFJQVFnQkVFUWFpQUFRUUZxSWdCQkQzRWJJUVFnQ0VFQmFpRUlJQUJCd0FCSERRQUxJQU1nSFdvaEF5QUZRUUZxSWdWQkFrY05BQXNMSUFFZ0JrSFFBR29RR3lBR1FkQURhaVFBQ3pZQUlBSUVRQ0FBSUFFUUFnOExRUUVoQWlBQklBQkJBUkFESWdBMkFnQWdBRUYvUndSL0lBRWdBRUVCY3pZQ0FFRUFCVUVCQ3d2TUF3RVNmeUFEUVFGMElROGdBMEY5YkNFUVFRQWdBMnNpRVVFQmRDRVNJQUVnQWlnQ0FHcEJmMm90QUFBaUIwRUJhaUVUUVFBZ0Iyc2hDa0VFSVFFRFFBSkFJQUFnRVdvaUZDMEFBQ0lGSUFBdEFBQWlDR3NpQkNBRVFSOTFJZ1JxSUFSeklBSW9BZ1JQRFFBZ0FDQVNhaUlMTFFBQUlnd2dCV3NpQkNBRVFSOTFJZ1JxSUFSeklBSW9BZ2dpQms4TkFDQUFJQU5xSWhVdEFBQWlEU0FJYXlJRUlBUkJIM1VpQkdvZ0JITWdCazhOQUNBSElRUWdBQ0FRYWkwQUFDSUpJQVZySWc0Z0RrRWZkU0lPYWlBT2N5QUdTUVJBSUFzZ0RDQUtJQWNnQlNBSWFrRUJha0VCZGlBTVFRRjBheUFKYWtFQmRTSUVJQVFnQjBvYklBUWdDa2diYWpvQUFDQUNLQUlJSVFZZ0V5RUVDeUFVSUFVQ2Z5QUFJQTlxTFFBQUlnc2dDR3NpQ1NBSlFSOTFJZ2xxSUFseklBWkpCRUFnRlNBTklBb2dCeUFGSUFocVFRRnFRUUYySUExQkFYUnJJQXRxUVFGMUlnWWdCaUFIU2hzZ0JpQUtTQnRxT2dBQUlBUkJBV29oQkF0QkFDQUVheUlHQ3lBRUlBZ2dCV3RCQW5RZ0RXc2dER3BCQkdwQkEzVWlCU0FGSUFSS0d5QUZJQVpJR3lJRWFrR3dMbW90QUFBNkFBQWdBQ0FJSUFSclFiQXVhaTBBQURvQUFBc2dBRUVCYWlFQUlBRkJmMm9pQVEwQUN3djdCZ0VPZnlBQ0tBSUlJUW9nQWlnQ0JDRVBBa0FnQVVFRVR3UkFJQTlCQW5aQkFtb2hFRUVFSVFJRFFBSkFJQUJCZjJvaUJTMEFBQ0lISUFBdEFBQWlDR3NpQVNBQlFSOTFJZ0ZxSUFGeklnMGdEMDhOQUNBQVFYNXFJZzR0QUFBaUFTQUhheUlFSUFSQkgzVWlCR29nQkhNZ0NrOE5BQ0FBTFFBQklna2dDR3NpQkNBRVFSOTFJZ1JxSUFSeklBcFBEUUFDUUNBTklCQkpCRUFnQUMwQUFpRUxBbjhnQUVGOWFpSU5MUUFBSWdRZ0Iyc2lCaUFHUVI5MUlnWnFJQVp6SUFwSkJFQkJBeUVHSUFVZ0NTQUhJQWhxSUFGcUlnVkJBWFJxSUFScVFRUnFRUU4yT2dBQUlBNGdCQ0FGYWtFQ2FrRUNkam9BQUNBRVFRTnNJUTRnQlVFRWFpRU1JQUJCZkdvdEFBQU1BUXNnQnlBSmFpRU1RUUloRGtFQ0lRWWdCU0VOSUFFTElRUWdEU0FNSUE1cUlBUkJBWFJxSUFaMk9nQUFJQXNnQ0dzaUJTQUZRUjkxSWdWcUlBVnpJQXBQRFFFZ0FDQUhJQWxxSUFocUlnVWdDMnBCQW1wQkFuWTZBQUVnQUNBRklBdEJBMnhxSUFBdEFBTkJBWFJxUVFScVFRTjJPZ0FDSUFBZ0FTQUZRUUYwYWlBTGFrRUVha0VEZGpvQUFBd0NDeUFGSUFjZ0NXb2dBVUVCZEdwQkFtcEJBblk2QUFBTElBQWdBU0FJYWlBSlFRRjBha0VDYWtFQ2Rqb0FBQXNnQUNBRGFpRUFJQUpCZjJvaUFnMEFDd3dCQ3lBQklBSW9BZ0JxUVg5cUxRQUFJZ1ZCQVdvaERVRUFJQVZySVFoQkJDRUNBMEFDUUNBQVFYOXFJZzR0QUFBaUJDQUFMUUFBSWdkcklnRWdBVUVmZFNJQmFpQUJjeUFQVHcwQUlBQkJmbW9pREMwQUFDSUpJQVJySWdFZ0FVRWZkU0lCYWlBQmN5QUtUdzBBSUFBdEFBRWlDeUFIYXlJQklBRkJIM1VpQVdvZ0FYTWdDazhOQUNBQUxRQUNJUVlnQlNFQklBQkJmV290QUFBaUVDQUVheUlSSUJGQkgzVWlFV29nRVhNZ0Nra0VRQ0FNSUFrZ0NDQUZJQVFnQjJwQkFXcEJBWFlnQ1VFQmRHc2dFR3BCQVhVaUFTQUJJQVZLR3lBQklBaElHMm82QUFBZ0RTRUJDeUFPSUFRQ2Z5QUdJQWRySWd3Z0RFRWZkU0lNYWlBTWN5QUtTUVJBSUFBZ0N5QUlJQVVnQkNBSGFrRUJha0VCZGlBTFFRRjBheUFHYWtFQmRTSUdJQVlnQlVvYklBWWdDRWdiYWpvQUFTQUJRUUZxSVFFTFFRQWdBV3NpQmdzZ0FTQUpJQXRySUFjZ0JHdEJBblJxUVFScVFRTjFJZ1FnQkNBQlNoc2dCQ0FHU0JzaUFXcEJzQzVxTFFBQU9nQUFJQUFnQnlBQmEwR3dMbW90QUFBNkFBQUxJQUFnQTJvaEFDQUNRWDlxSWdJTkFBc0xDOW9IQVExL0l3QkJ3QU5ySWhFa0FDQUdRUVZxSVFrQ1FBSkFJQUpCQUVnTkFDQURRUUJJRFFBZ0FpQUphaUFFU3cwQUlBTWdCMnBCQldvZ0JVc05BQ0FFSVFrZ0F5RUtEQUVMSUFBZ0VTQUNJQU1nQkNBRklBa2dCMEVGYWlBSkVBd2dFU0VBUVFBaEFnc0NRQ0FIUlEwQUlBQWdDU0FLYkNBQ2Ftb2hFMEVRSUFacklSUUNRQ0FHUVFKMkloSUVRQ0FKSUFacklSVWdFeUFKSUFoQkFYWkJBWEZCQW5Kc2FrRUZhaUVDSUFjaEJBTkFJQUpCZjJvdEFBQWhBQ0FDUVg1cUxRQUFJUU1nQWtGOWFpMEFBQ0VGSUFKQmZHb3RBQUFoQ3lBQ1FYdHFMUUFBSVEwZ0VpRVBBMEFnQVNBQ0xRQUFJZ29nRFNBQUlBdHFJZ3hySUFNZ0JXcEJGR3hxSUF4QkFuUnJha0VRYWtFRmRVR3dMbW90QUFBNkFBQWdBU0FDTFFBQklnd2dDeUFBSUFOcVFSUnNhaUFGSUFwcUlndHJJQXRCQW5ScmFrRVFha0VGZFVHd0xtb3RBQUE2QUFFZ0FTQUNMUUFDSWhBZ0JTQUFJQXBxUVJSc2FpQURJQXhxSWdWcklBVkJBblJyYWtFUWFrRUZkVUd3TG1vdEFBQTZBQUlnQVNBQ0xRQURJZzRnQXlBS0lBeHFRUlJzYWlBQUlCQnFJZ05ySUFOQkFuUnJha0VRYWtFRmRVR3dMbW90QUFBNkFBTWdBVUVFYWlFQklBSkJCR29oQWlBQUlRMGdDaUVMSUF3aEJTQVFJUU1nRGlFQUlBOUJmMm9pRHcwQUN5QUJJQlJxSVFFZ0FpQVZhaUVDSUFSQmYyb2lCQTBBQ3d3QkN5QUhRWDlxSUJSc0lBWnJJQUZxUVJCcUlRRUxJQWRCQW5ZaUJFVU5BRUhBQUNBR2F5RVFJQWxCQVhRaENpQUpRUUowSUFacklRdEJBQ0FKYXlJTVFRRjBJUklnQVNBSFFRUjBheUVDSUFrZ0Uyb2dDRUVCY1dwQkFtb2lBQ0FKUVFWc2FpRUJBMEFnQmlJREJFQURRQ0FDSUFBZ0Ntb3RBQUFpQlNBQklBcHFMUUFBSUFFZ0NXb3RBQUFpRGlBQklCSnFMUUFBSWdkcUlnaHJJQWhCQW5ScmFpQUJMUUFBSWcwZ0FTQU1haTBBQUNJSWFrRVViR3BCRUdwQkJYVkJzQzVxTFFBQUlBSXRBREJxUVFGcVFRRjJPZ0F3SUFJZ0FDQUphaTBBQUNJUElBNGdCeUFJYWtFVWJHb2dCU0FOYWlJT2F5QU9RUUowYTJwQkVHcEJCWFZCc0M1cUxRQUFJQUl0QUNCcVFRRnFRUUYyT2dBZ0lBSWdBQzBBQUNJT0lBMGdCU0FIYWtFVWJHb2dDQ0FQYWlJTmF5QU5RUUowYTJwQkVHcEJCWFZCc0M1cUxRQUFJQUl0QUJCcVFRRnFRUUYyT2dBUUlBSWdBQ0FNYWkwQUFDQUlJQVVnRDJwQkZHeHFJQWNnRG1vaUJXc2dCVUVDZEd0cVFSQnFRUVYxUWJBdWFpMEFBQ0FDTFFBQWFrRUJha0VCZGpvQUFDQUFRUUZxSVFBZ0FrRUJhaUVDSUFGQkFXb2hBU0FEUVg5cUlnTU5BQXNMSUFJZ0VHb2hBaUFCSUF0cUlRRWdBQ0FMYWlFQUlBUkJmMm9pQkEwQUN3c2dFVUhBQTJva0FBdTFCUUVFZnlBQUtBSVVJUU1nQUNnQ0VDRUVJQUFvQWdRaEJTQUFLQUlNSWdJZ0FTa0NBRGNDQUNBQ0lBRXBBZ2czQWdnZ0FpQUZRUVIwSWdCcUlnSWdBU2tDRURjQ0FDQUNJQUVwQWhnM0FnZ2dBQ0FDYWlJQ0lBRXBBaUEzQWdBZ0FpQUJLUUlvTndJSUlBQWdBbW9pQWlBQktRSXdOd0lBSUFJZ0FTa0NPRGNDQ0NBQUlBSnFJZ0lnQVNrQ1FEY0NBQ0FDSUFFcEFrZzNBZ2dnQUNBQ2FpSUNJQUVwQWxBM0FnQWdBaUFCS1FKWU53SUlJQUFnQW1vaUFpQUJLUUpnTndJQUlBSWdBU2tDYURjQ0NDQUFJQUpxSWdJZ0FTa0NjRGNDQUNBQ0lBRXBBbmczQWdnZ0FDQUNhaUlDSUFFcEFvQUJOd0lBSUFJZ0FTa0NpQUUzQWdnZ0FDQUNhaUlDSUFFcEFwQUJOd0lBSUFJZ0FTa0NtQUUzQWdnZ0FDQUNhaUlDSUFFcEFxQUJOd0lBSUFJZ0FTa0NxQUUzQWdnZ0FDQUNhaUlDSUFFcEFyQUJOd0lBSUFJZ0FTa0N1QUUzQWdnZ0FDQUNhaUlDSUFFcEFzQUJOd0lBSUFJZ0FTa0N5QUUzQWdnZ0FDQUNhaUlDSUFFcEF0QUJOd0lBSUFJZ0FTa0MyQUUzQWdnZ0FDQUNhaUlDSUFFcEF1QUJOd0lBSUFJZ0FTa0M2QUUzQWdnZ0FDQUNhaUlBSUFFcEF2QUJOd0lBSUFBZ0FTa0MrQUUzQWdnZ0JDQUJLUUtBQWpjQ0FDQUVJQVZCQTNRaUFHb2lCQ0FCS1FLSUFqY0NBQ0FBSUFScUlnUWdBU2tDa0FJM0FnQWdBQ0FFYWlJRUlBRXBBcGdDTndJQUlBQWdCR29pQkNBQktRS2dBamNDQUNBQUlBUnFJZ1FnQVNrQ3FBSTNBZ0FnQUNBRWFpSUVJQUVwQXJBQ053SUFJQUFnQkdvZ0FTa0N1QUkzQWdBZ0F5QUJLUUxBQWpjQ0FDQUFJQU5xSWdNZ0FTa0N5QUkzQWdBZ0FDQURhaUlESUFFcEF0QUNOd0lBSUFBZ0Eyb2lBeUFCS1FMWUFqY0NBQ0FBSUFOcUlnTWdBU2tDNEFJM0FnQWdBQ0FEYWlJRElBRXBBdWdDTndJQUlBQWdBMm9pQXlBQktRTHdBamNDQUNBQUlBTnFJQUVwQXZnQ053SUFDK2dDQVFWL0FrQWdBQ0FCRUFJaUF3MEFRUUVoQXlBQklBRW9BZ0JCQVdvaUFqWUNBQ0FDUVNCTERRQWdBRUVFRUFNaUFrRi9SZzBBSUFFZ0FqWUNCQ0FBUVFRUUF5SUNRWDlHRFFBZ0FTQUNOZ0lJSUFFb0FnQUVRQU5BSUFBZ0FTQUZRUUowYWlJQ0lnUkJER29RQWlJRERRSkJBU0VESUFRb0Fnd2lCa0YvUmcwQ0lBUWdCa0VCYWlJRE5nSU1JQVFnQXlBQktBSUVRUVpxZERZQ0RDQUFJQUpCakFGcUVBSWlBdzBDUVFFaEF5QUNLQUtNQVNJRVFYOUdEUUlnQWlBRVFRRnFJZ1EyQW93QklBSWdCQ0FCS0FJSVFRUnFkRFlDakFFZ0FFRUJFQU1pQkVGL1JnMENJQUlnQkVFQlJqWUNqQUlnQlVFQmFpSUZJQUVvQWdCSkRRQUxDeUFBUVFVUUF5SUNRWDlHRFFBZ0FTQUNRUUZxTmdLTUF5QUFRUVVRQXlJQ1FYOUdEUUFnQVNBQ1FRRnFOZ0tRQXlBQVFRVVFBeUlDUVg5R0RRQWdBU0FDUVFGcU5nS1VBeUFBUVFVUUF5SUFRWDlHRFFBZ0FTQUFOZ0tZQTBFQUlRTUxJQU1MV3dFRGZ5QUFJQUFvQWdBaUJDQUJJQUFvQWdRaUFuQWlBMEVFZEdvZ0FTQURheUlCUVFoMGFqWUNEQ0FBSUFRZ0FpQUFLQUlJYkNJQ1FRaDBhaUFCUVFaMGFpQURRUU4wYWlJQk5nSVFJQUFnQVNBQ1FRWjBhallDRkF0VkFRSi9JQUVnQWtFQmFpSURJQU1nQVVrYklRTWdBQ0FDUVFKMGFpZ0NBQ0VFQTBBQ1FDQUNRUUZxSWdJZ0FVOEVRQ0FESVFJTUFRc2dBQ0FDUVFKMGFpZ0NBQ0FFUncwQkN3dEJBQ0FDSUFFZ0FrWWJDeWNBSUFCQkNDQUFLQUlJSWdCckVBTkJmMFlFUUE4TFFRQWdBR3RCQW5SQnpEOXFLQUlBR2d0NkFRSi9Jd0JCSUdzaUFpUUFJQUlnQUNnQ0VEWUNFQ0FDSUFBcEFnZzNBd2dnQWlBQUtRSUFOd01BQWtBZ0FpQUNRUnhxRUFJaUFBMEFJQUlnQWtFY2FoQUNJZ0FOQUNBQ0lBSkJIR29RQWlJQURRQkJBU0VBSUFJb0Fod2lBMEgvQVVzTkFDQUJJQU0yQWdCQkFDRUFDeUFDUVNCcUpBQWdBQXZuQndFU2Z5TUFRWUFPYXlJTUpBQWdCa0VGYWlFSkFrQUNRQ0FDUVFCSURRQWdBMEVBU0EwQUlBSWdDV29nQkVzTkFDQURJQWRxUVFWcUlBVkxEUUFnQXlFS0RBRUxJQUFnREVIQUNtb2dBaUFESUFRZ0JTQUpJQWRCQldvZ0NSQU1JQXhCd0FwcUlRQWdDU0VFUVFBaEFnc0NRQ0FIUVFKMkloUkZEUUFnQ1VVTkFDQUVRUUYwSVJWQkFDQUVheUlXUVFGMElSb2dCRUVDZENBR2EwRjdhaUVYSUFBZ0JDQUtiQ0FDYW1vZ0JHb2lBQ0FFUVFWc2FpRUNJQXdnQ1VFQ2RDSVFhaUVESUFsQkEzUWhEVUVBSUFsclFRSjBJUTRnQ1VFRGJFRUNkQ0VQQTBBZ0NTRUZBMEFnQXlBTmFpQUFJQlZxTFFBQUloRWdBaUFWYWkwQUFDQUNJQVJxTFFBQUlnc2dBaUFhYWkwQUFDSVNhaUlLYXlBS1FRSjBhMm9nQWkwQUFDSVlJQUlnRm1vdEFBQWlFMnBCRkd4cU5nSUFJQU1nRUdvZ0FDQUVhaTBBQUNJWklBc2dFaUFUYWtFVWJHb2dFU0FZYWlJS2F5QUtRUUowYTJvMkFnQWdBeUFBTFFBQUlnc2dHQ0FSSUJKcVFSUnNhaUFUSUJscUlncHJJQXBCQW5ScmFqWUNBQ0FESUE1cUlBQWdGbW90QUFBZ0V5QVJJQmxxUVJSc2FpQUxJQkpxSWdwcklBcEJBblJyYWpZQ0FDQUFRUUZxSVFBZ0EwRUVhaUVESUFKQkFXb2hBaUFGUVg5cUlnVU5BQXNnQWlBWGFpRUNJQUFnRjJvaEFDQURJQTlxSVFNZ0ZFRi9haUlVRFFBTEN5QUhCRUJCRUNBR2F5RVFJQVpCQW5ZaENpQU1JQWhCQW5ScVFRaHFJUUFnREVFVWFpRUNBMEFnQ2dSQUlBSkJiR29vQWdBaEJDQUNRWEJxS0FJQUlROGdBa0YwYWlnQ0FDRU5JQUpCZUdvb0FnQWhCU0FDUVh4cUtBSUFJUU1nQ2lFSkEwQWdBU0FDS0FJQUlnNGdCQ0FESUE5cUlnUnJJQVVnRFdwQkZHeHFJQVJCQW5ScmFrR0FCR3BCQ25WQnNDNXFMUUFBSUFBb0FnQkJFR3BCQlhWQnNDNXFMUUFBYWtFQmFrRUJkam9BQUNBQklBSW9BZ1FpQ3lBUElBTWdCV3BCRkd4cUlBMGdEbW9pQkdzZ0JFRUNkR3RxUVlBRWFrRUtkVUd3TG1vdEFBQWdBQ2dDQkVFUWFrRUZkVUd3TG1vdEFBQnFRUUZxUVFGMk9nQUJJQUVnQWlnQ0NDSUlJQTBnQXlBT2FrRVViR29nQlNBTGFpSUVheUFFUVFKMGEycEJnQVJxUVFwMVFiQXVhaTBBQUNBQUtBSUlRUkJxUVFWMVFiQXVhaTBBQUdwQkFXcEJBWFk2QUFJZ0FTQUNLQUlNSWdZZ0JTQUxJQTVxUVJSc2FpQURJQWhxSWdScklBUkJBblJyYWtHQUJHcEJDblZCc0M1cUxRQUFJQUFvQWd4QkVHcEJCWFZCc0M1cUxRQUFha0VCYWtFQmRqb0FBeUFCUVFScUlRRWdBRUVRYWlFQUlBSkJFR29oQWlBRElRUWdEaUVQSUFzaERTQUlJUVVnQmlFRElBbEJmMm9pQ1EwQUN3c2dBU0FRYWlFQklBQkJGR29oQUNBQ1FSUnFJUUlnQjBGL2FpSUhEUUFMQ3lBTVFZQU9haVFBQzlFSEFReC9Jd0JCZ0E1cklnOGtBQ0FHUVFWcUlRa0NRQUpBSUFKQkFFZ05BQ0FEUVFCSURRQWdBaUFKYWlBRVN3MEFJQWRCQldvaURpQURhaUFGU3cwQUlBUWhDU0FESVFvTUFRc2dBQ0FQUWNBS2FpQUNJQU1nQkNBRklBa2dCMEVGYWlJT0lBa1FEQ0FQUWNBS2FpRUFRUUFoQWdzQ1FDQU9SUTBBSUFaQkFuWWlFa1VOQUNBSklBWnJJUk1nQUNBSklBcHNJQUpxYWtFRmFpRUNJQThoQUFOQUlBSkJmMm90QUFBaENTQUNRWDVxTFFBQUlRTWdBa0Y5YWkwQUFDRUZJQUpCZkdvdEFBQWhDaUFDUVh0cUxRQUFJUXdnRWlFTkEwQWdBQ0FDTFFBQUlnUWdEQ0FKSUFwcUlndHJJQU1nQldwQkZHeHFJQXRCQW5ScmFqWUNBQ0FBSUFJdEFBRWlDeUFESUFscVFSUnNJQXBxSUFRZ0JXb2lDbXNnQ2tFQ2RHdHFOZ0lFSUFBZ0FpMEFBaUlRSUFRZ0NXcEJGR3dnQldvZ0F5QUxhaUlGYXlBRlFRSjBhMm8yQWdnZ0FDQUNMUUFESWhRZ0JDQUxha0VVYkNBRGFpQUpJQkJxSWdOcklBTkJBblJyYWpZQ0RDQUFRUkJxSVFBZ0FrRUVhaUVDSUFraERDQUVJUW9nQ3lFRklCQWhBeUFVSVFrZ0RVRi9haUlORFFBTElBSWdFMm9oQWlBT1FYOXFJZzROQUFzTElBZEJBbllpQndSQVFjQUFJQVpySVJRZ0R5QUdRUUowSWdScUlna2dCa0VVYkdvaEFpQUpJQWhCQW1vZ0JteEJBblJxSVFBZ0JrRURiRUVDZENFRlFRQWdCbXNpRGtFRGRDRVRJQVpCQTNRaENBTkFJQVloQXlBR0JFQURRQ0FCSUFnZ0NXb29BZ0FpQ2lBQ0lBaHFLQUlBSUFJZ0JHb29BZ0FpRVNBQ0lCTnFLQUlBSWd0cUlneHJJQXhCQW5ScmFpQUNLQUlBSWcwZ0FpQU9RUUowSWhCcUtBSUFJZ3hxUVJSc2FrR0FCR3BCQ25WQnNDNXFMUUFBSUFBZ0NHb29BZ0JCRUdwQkJYVkJzQzVxTFFBQWFrRUJha0VCZGpvQU1DQUJJQVFnQ1dvb0FnQWlFaUFSSUFzZ0RHcEJGR3hxSUFvZ0RXb2lFV3NnRVVFQ2RHdHFRWUFFYWtFS2RVR3dMbW90QUFBZ0FDQUVhaWdDQUVFUWFrRUZkVUd3TG1vdEFBQnFRUUZxUVFGMk9nQWdJQUVnQ1NnQ0FDSVJJQTBnQ2lBTGFrRVViR29nRENBU2FpSU5heUFOUVFKMGEycEJnQVJxUVFwMVFiQXVhaTBBQUNBQUtBSUFRUkJxUVFWMVFiQXVhaTBBQUdwQkFXcEJBWFk2QUJBZ0FTQUpJQkJxS0FJQUlBd2dDaUFTYWtFVWJHb2dDeUFSYWlJS2F5QUtRUUowYTJwQmdBUnFRUXAxUWJBdWFpMEFBQ0FBSUJCcUtBSUFRUkJxUVFWMVFiQXVhaTBBQUdwQkFXcEJBWFk2QUFBZ0FFRUVhaUVBSUFsQkJHb2hDU0FCUVFGcUlRRWdBa0VFYWlFQ0lBTkJmMm9pQXcwQUN3c2dBU0FVYWlFQklBQWdCV29oQUNBQ0lBVnFJUUlnQlNBSmFpRUpJQWRCZjJvaUJ3MEFDd3NnRDBHQURtb2tBQXUwQmdFSmZ5TUFRY0FEYXlJTkpBQWdCa0VGYWlFSkFrQUNRQ0FDUVFCSURRQWdBeUFIYWlBRlN3MEFJQU5CQUVnTkFDQUNJQWxxSUFSTERRQWdCQ0VKSUFNaENnd0JDeUFBSUEwZ0FpQURJQVFnQlNBSklBY2dDUkFNSUEwaEFFRUFJUUlMSUFjRVFFRVFJQVpySVJBZ0NTQUdheUVSSUFaQkFuWWhEeUFBSUFrZ0Ntd2dBbXBxUVFWcUlRa0RRQUpBSUE5RkRRQWdDVUYvYWkwQUFDRUNJQWxCZm1vdEFBQWhCaUFKUVgxcUxRQUFJUU1nQ1VGOGFpMEFBQ0VGSUFsQmUyb3RBQUFoQ2lBUElnQWhDeUFJQkVBRFFDQUJJQVlnQ1MwQUFDSUVJQW9nQWlBRmFpSUtheUFESUFacVFSUnNhaUFLUVFKMGEycEJFR3BCQlhWQnNDNXFMUUFBYWtFQmFrRUJkam9BQUNBQklBSWdDUzBBQVNJTElBVWdBaUFHYWtFVWJHb2dBeUFFYWlJRmF5QUZRUUowYTJwQkVHcEJCWFZCc0M1cUxRQUFha0VCYWtFQmRqb0FBU0FCSUFRZ0NTMEFBaUlNSUFNZ0FpQUVha0VVYkdvZ0JpQUxhaUlEYXlBRFFRSjBhMnBCRUdwQkJYVkJzQzVxTFFBQWFrRUJha0VCZGpvQUFpQUJJQXNnQ1MwQUF5SU9JQVlnQkNBTGFrRVViR29nQWlBTWFpSURheUFEUVFKMGEycEJFR3BCQlhWQnNDNXFMUUFBYWtFQmFrRUJkam9BQXlBQlFRUnFJUUVnQ1VFRWFpRUpJQUloQ2lBRUlRVWdDeUVESUF3aEJpQU9JUUlnQUVGL2FpSUFEUUFNQWdBTEFBc0RRQ0FCSUFNZ0NTMEFBQ0lBSUFvZ0FpQUZhaUlFYXlBRElBWnFRUlJzYWlBRVFRSjBhMnBCRUdwQkJYVkJzQzVxTFFBQWFrRUJha0VCZGpvQUFDQUJJQVlnQ1MwQUFTSUVJQVVnQWlBR2FrRVViR29nQUNBRGFpSUZheUFGUVFKMGEycEJFR3BCQlhWQnNDNXFMUUFBYWtFQmFrRUJkam9BQVNBQklBSWdDUzBBQWlJTUlBTWdBQ0FDYWtFVWJHb2dCQ0FHYWlJRGF5QURRUUowYTJwQkVHcEJCWFZCc0M1cUxRQUFha0VCYWtFQmRqb0FBaUFCSUFBZ0NTMEFBeUlPSUFZZ0FDQUVha0VVYkdvZ0FpQU1haUlEYXlBRFFRSjBhMnBCRUdwQkJYVkJzQzVxTFFBQWFrRUJha0VCZGpvQUF5QUJRUVJxSVFFZ0NVRUVhaUVKSUFJaENpQUFJUVVnQkNFRElBd2hCaUFPSVFJZ0MwRi9haUlMRFFBTEN5QUJJQkJxSVFFZ0NTQVJhaUVKSUFkQmYyb2lCdzBBQ3dzZ0RVSEFBMm9rQUF2R0JBRUxmeU1BUWNBRGF5SU5KQUFDUUFKQUlBSkJBRWdOQUNBRFFRQklEUUFnQWlBR2FpQUVTdzBBSUFNZ0IycEJCV29nQlVzTkFDQURJUWtNQVFzZ0FDQU5JQUlnQXlBRUlBVWdCaUFIUVFWcUlBWVFEQ0FOSVFBZ0JpRUVRUUFoQWdzZ0IwRUNkaUlRQkVCQndBQWdCbXNoRWlBRVFRRjBJUVVnQkVFQ2RDQUdheUVPUVFBZ0JHc2lEMEVCZENFVElBQWdCQ0FKYkNBQ2Ftb2dCR29pQUNBRVFRVnNhaUVDSUFBZ0JDQUlRUUpxYkdvaEJ3TkFJQVloQXlBR0JFQURRQ0FCSUFBZ0JXb3RBQUFpQ0NBQ0lBVnFMUUFBSUFJZ0JHb3RBQUFpQ2lBQ0lCTnFMUUFBSWdscUlndHJJQXRCQW5ScmFpQUNMUUFBSWd3Z0FpQVBhaTBBQUNJTGFrRVViR3BCRUdwQkJYVkJzQzVxTFFBQUlBVWdCMm90QUFCcVFRRnFRUUYyT2dBd0lBRWdBQ0FFYWkwQUFDSVJJQW9nQ1NBTGFrRVViR29nQ0NBTWFpSUtheUFLUVFKMGEycEJFR3BCQlhWQnNDNXFMUUFBSUFRZ0Iyb3RBQUJxUVFGcVFRRjJPZ0FnSUFFZ0FDMEFBQ0lLSUF3Z0NDQUpha0VVYkdvZ0N5QVJhaUlNYXlBTVFRSjBhMnBCRUdwQkJYVkJzQzVxTFFBQUlBY3RBQUJxUVFGcVFRRjJPZ0FRSUFFZ0FDQVBhaTBBQUNBTElBZ2dFV3BCRkd4cUlBa2dDbW9pQ0dzZ0NFRUNkR3RxUVJCcVFRVjFRYkF1YWkwQUFDQUhJQTlxTFFBQWFrRUJha0VCZGpvQUFDQUhRUUZxSVFjZ0FFRUJhaUVBSUFGQkFXb2hBU0FDUVFGcUlRSWdBMEYvYWlJRERRQUxDeUFCSUJKcUlRRWdCeUFPYWlFSElBSWdEbW9oQWlBQUlBNXFJUUFnRUVGL2FpSVFEUUFMQ3lBTlFjQURhaVFBQzQ4SEFReC9JQUVvQWdnaEN5QUJLQUlFSVFZQ1FBSkFBa0FnQWtFRlN3MEFJQUpCQVdzT0JBQUFBQUFCQ3lBQUtBSzRHZzBBREFFTElBQkJ4QWxxSVFRRFFDQUVJQU1RRkNFSElBTkJEa3NOQVNBRFFRRnFJUU1nQjBVTkFBc0xBa0FDUUFKQUFrQWdBQ2dDbUFraUNBUkFJQUFvQXJ3SklRcEJBQ0VEUVFBaEJBTkFJQW9nQTBIWUFXeHFLQUxFQVVVRVFFRUFJQVJCQVdvaUJDQUVJQVpHSWdVYklRUWdCU0FKYWlFSklBTkJBV29pQXlBSVNRMEJDd3NnQXlBSVJ3MEJDd0pBQWtBZ0FrRithaUlDUVFWTERRQUNRQ0FDUVFGckRnUUJBUUVCQUFzZ0IwVU5BU0FBS0FLNEdrVU5BUXdEQ3lBSERRSUxJQUVvQWdCQmdBRWdCaUFMYkVHQUEyd1FCeG9NQWdzZ0FDZ0N2QWtnQmlBSmJFSFlBV3hxSVFnZ0JBUkFJQVFoQXdOQUlBZ2dBMEYvYWlJRFFkZ0JiR29pQ2lBQklBa2dBeUFDSUFjUUZpQUtRUUUyQXNRQklBQWdBQ2dDdEFsQkFXbzJBclFKSUFNTkFBc0xJQVJCQVdvaUF5QUdTUVJBQTBBZ0NDQURRZGdCYkdvaUJDZ0N4QUZGQkVBZ0JDQUJJQWtnQXlBQ0lBY1FGaUFFUVFFMkFzUUJJQUFnQUNnQ3RBbEJBV28yQXJRSkN5QURRUUZxSWdNZ0JrY05BQXNMQWtBZ0NVVU5BQ0FHUlEwQVFRQWhCU0FKUVg5cUlnd2dCbXdoRFNBTVJRUkFBMEFnQUNnQ3ZBa2dEVUhZQVd4cUlBVkIyQUZzYWlJRUlBRkJBQ0FGSUFJZ0J4QVdJQVJCQVRZQ3hBRWdBQ0FBS0FLMENVRUJhallDdEFrZ0JVRUJhaUlGSUFaSERRQU1BZ0FMQUFzZ0NVRithaUVJUVFBZ0JtdEIyQUZzSVE0RFFDQUFLQUs4Q1NBTlFkZ0JiR29nQlVIWUFXeHFJZ01nQVNBTUlBVWdBaUFIRUJZZ0EwRUJOZ0xFQVNBQUlBQW9BclFKUVFGcU5nSzBDU0FJSVFRRFFDQURJQTVxSWdNZ0FTQUVJZ29nQlNBQ0lBY1FGaUFEUVFFMkFzUUJJQUFnQUNnQ3RBbEJBV28yQXJRSklBUkJmMm9oQkNBS0RRQUxJQVZCQVdvaUJTQUdSdzBBQ3dzZ0NVRUJhaUlGSUF0UERRSWdCa1VOQWdOQUlBQW9BcndKSUFVZ0JteEIyQUZzYWlFSVFRQWhBd05BSUFnZ0EwSFlBV3hxSWdRb0FzUUJSUVJBSUFRZ0FTQUZJQU1nQWlBSEVCWWdCRUVCTmdMRUFTQUFJQUFvQXJRSlFRRnFOZ0swQ1FzZ0EwRUJhaUlESUFaSERRQUxJQVZCQVdvaUJTQUxSdzBBQ3d3Q0N5QUJLQUlBSUFjZ0JpQUxiRUdBQTJ3UUZSb0xJQUFnQUNnQ21Ba2lBVFlDdEFrZ0FVVU5BQ0FBS0FLOENTRUFRUUFoQXdOQUlBQWdBMEhZQVd4cVFRRTJBZ2dnQTBFQmFpSURJQUZIRFFBTEN3czJBUUovSUFBb0FpZ2lBZ1JBQTBBZ0FDZ0NCQ0FCUVFKMGFpQUFLQUlBSUFGQktHeHFOZ0lBSUFGQkFXb2lBU0FDUncwQUN3c0w5d1FDREg4QmZrRUhJUVVqQUVFZ2F5SUlJUXdEUUNBRklBRkpCRUFnQUVFQUlBVnJRU2hzYWlFS0lBVWhCZ05BSUFBZ0JrRW9iR29pQWlnQ0NDRUpJQUlwQWdBaERpQUlJQUlwQWd3M0F4Z2dBaWdDR0NFTklBSW9BaFFoQ3lBTUlBSW9BaVEyQWhBZ0NDQUNLUUljTndNSUFrQWdCaUlESUFWSkRRQUNRQ0FMUlFSQUEwQWdDaUFEUVNoc0lnSnFJZ1FvQWhRTkFpQU5SUTBDSUFRb0FoZ05BaUFBSUFKcUlnUWdBQ0FESUFWcklnTkJLR3hxSWdJcEFnQTNBZ0FnQkNBQ0tRSWdOd0lnSUFRZ0Fpa0NHRGNDR0NBRUlBSXBBaEEzQWhBZ0JDQUNLUUlJTndJSUlBTWdCVThOQUF3REFBc0FDeUFMUVg5cVFRRk5CRUFEUUFKL0FrQWdDaUFEUVNoc0lnSnFJZ1FvQWhRaUIwVU5BQ0FIUVg5cVFRRkxEUUFnQkNnQ0NDSUhJQWxLRFFRZ0FDQUNhaUlFSUFjZ0NVZ05BUm9nQkNFQ0RBVUxJQUFnQW1vTElnUWdBQ0FESUFWcklnTkJLR3hxSWdJcEFnQTNBZ0FnQkNBQ0tRSWdOd0lnSUFRZ0Fpa0NHRGNDR0NBRUlBSXBBaEEzQWhBZ0JDQUNLUUlJTndJSUlBTWdCVThOQUF3REFBc0FDd05BSUFvZ0EwRW9iQ0lDYWlJRUtBSVVJZ2NFUUNBSFFYOXFRUUpKRFFJZ0JDZ0NDQ0FKVEEwQ0N5QUFJQUpxSWdRZ0FDQURJQVZySWdOQktHeHFJZ0lwQWdBM0FnQWdCQ0FDS1FJZ053SWdJQVFnQWlrQ0dEY0NHQ0FFSUFJcEFoQTNBaEFnQkNBQ0tRSUlOd0lJSUFNZ0JVOE5BQXNNQVFzZ0FDQURRU2hzYWlFQ0N5QUNJQTQzQWdBZ0FDQURRU2hzYWlJRElBazJBZ2dnQ0NrREdDRU9JQU1nRFRZQ0dDQURJQXMyQWhRZ0F5QU9Od0lNSUFNZ0NDa0RDRGNDSENBRElBd29BaEEyQWlRZ0JrRUJhaUlHSUFGSERRQUxDeUFGUVFGMklnVU5BQXNMclFVQkFYOENRQ0FBS0FJQUlnRW9BaFJGRFFBZ0FVRUFOZ0lVSUFFb0FoZ05BQ0FBSUFBb0FpeEJmMm8yQWl3TEFrQWdBU2dDUEVVTkFDQUJRUUEyQWp3Z0FVRkFheWdDQUEwQUlBQWdBQ2dDTEVGL2FqWUNMQXNDUUNBQktBSmtSUTBBSUFGQkFEWUNaQ0FCS0FKb0RRQWdBQ0FBS0FJc1FYOXFOZ0lzQ3dKQUlBRW9Bb3dCUlEwQUlBRkJBRFlDakFFZ0FTZ0NrQUVOQUNBQUlBQW9BaXhCZjJvMkFpd0xBa0FnQVNnQ3RBRkZEUUFnQVVFQU5nSzBBU0FCS0FLNEFRMEFJQUFnQUNnQ0xFRi9hallDTEFzQ1FDQUJLQUxjQVVVTkFDQUJRUUEyQXR3QklBRW9BdUFCRFFBZ0FDQUFLQUlzUVg5cU5nSXNDd0pBSUFFb0FvUUNSUTBBSUFGQkFEWUNoQUlnQVNnQ2lBSU5BQ0FBSUFBb0FpeEJmMm8yQWl3TEFrQWdBU2dDckFKRkRRQWdBVUVBTmdLc0FpQUJLQUt3QWcwQUlBQWdBQ2dDTEVGL2FqWUNMQXNDUUNBQktBTFVBa1VOQUNBQlFRQTJBdFFDSUFFb0F0Z0NEUUFnQUNBQUtBSXNRWDlxTmdJc0N3SkFJQUVvQXZ3Q1JRMEFJQUZCQURZQy9BSWdBU2dDZ0FNTkFDQUFJQUFvQWl4QmYybzJBaXdMQWtBZ0FTZ0NwQU5GRFFBZ0FVRUFOZ0trQXlBQktBS29BdzBBSUFBZ0FDZ0NMRUYvYWpZQ0xBc0NRQ0FCS0FMTUEwVU5BQ0FCUVFBMkFzd0RJQUVvQXRBRERRQWdBQ0FBS0FJc1FYOXFOZ0lzQ3dKQUlBRW9BdlFEUlEwQUlBRkJBRFlDOUFNZ0FTZ0MrQU1OQUNBQUlBQW9BaXhCZjJvMkFpd0xBa0FnQVNnQ25BUkZEUUFnQVVFQU5nS2NCQ0FCS0FLZ0JBMEFJQUFnQUNnQ0xFRi9hallDTEFzQ1FDQUJLQUxFQkVVTkFDQUJRUUEyQXNRRUlBRW9Bc2dFRFFBZ0FDQUFLQUlzUVg5cU5nSXNDd0pBSUFFb0F1d0VSUTBBSUFGQkFEWUM3QVFnQVNnQzhBUU5BQ0FBSUFBb0FpeEJmMm8yQWl3TEEwQWdBQkJlUlEwQUN5QUFRUUEyQWpBZ0FFTC8vd00zQWlRTDNRNEJDWDhnQWlnQ0FDQUFLQUlJSWdJb0FnQkdCRUFnQUVFQU5nSTBJQUFvQWpnaUMwVWhEUUpBSUFGRkJFQWdBaUFETmdJTUlBSkJBRFlDRkNBQ0lBMDJBaGdnQWlBRU5nSVFJQUlnQXpZQ0NDQUxEUUVnQUNBQUtBSXNRUUZxTmdJc0RBRUxJQVVFUUNBQVFnQTNBaEFnQUJBb0FrQWdBU2dDQUVVRVFDQUFLQUk0UlEwQkN5QUFRZ0EzQWhBTElBQW9BZ2dpQWtFRFFRSWdBU2dDQkNJQkd6WUNGQ0FBUVFCQi8vOERJQUViTmdJa0lBSWdEVFlDR0NBQ1FRQTJBaEFnQWtJQU53SUlJQUJDZ1lDQWdCQTNBaWdNQVFzQ1FBSkFBa0FnQVNnQ0NBUkFRUUFoQ3dOQUlBRWdDMEVVYkdvaUNDZ0NEQ0lDUVFaTERRSUNRQUpBQWtBQ1FBSkFBa0FDUUNBQ1FRRnJEZ1lBQVFJREJBVUpDeUFBS0FJWUlnbEZEUWdnQXlBSUtBSVFheUVNSUFBb0FnQWhDa0VBSVFnRFFBSkFJQW9nQ0VFb2JHb2lBaWdDRkVGL2FrRUJUUVJBSUFJb0FnZ2dERVlOQVFzZ0NFRUJhaUlJSUFsSERRRU1DZ3NMSUFoQkFFZ05DQ0FDUVFBMkFoUWdBQ0FBS0FJb1FYOXFOZ0lvSUFJb0FoZ05CU0FBSUFBb0FpeEJmMm8yQWl3Z0MwRUJhaUVMREFZTElBQW9BaGdpQ1VVTkJ5QUlLQUlVSVF3Z0FDZ0NBQ0VLUVFBaENBTkFBa0FnQ2lBSVFTaHNhaUlDS0FJVVFRTkdCRUFnQWlnQ0NDQU1SZzBCQ3lBSVFRRnFJZ2dnQ1VjTkFRd0pDd3NnQ0VFQVNBMEhJQUpCQURZQ0ZDQUFJQUFvQWloQmYybzJBaWdnQWlnQ0dBMEVJQUFnQUNnQ0xFRi9hallDTENBTFFRRnFJUXNNQlFzZ0FDZ0NKQ0lDUWYvL0EwWU5CaUFDSUFnb0FoZ2lERWtOQmlBQUtBSVlJZ2xGRFFZZ0NDZ0NFQ0VPSUFBb0FnQWhDa0VBSVFJRFFBSkFBa0FnQ2lBQ1FTaHNhaUlJS0FJVVFRTkhEUUFnQ0NnQ0NDQU1SdzBBSUFoQkFEWUNGQ0FBSUFBb0FpaEJmMm8yQWlnZ0NDZ0NHQTBCSUFBZ0FDZ0NMRUYvYWpZQ0xBd0JDeUFDUVFGcUlnSWdDVWNOQVFzTElBbEJBU0FKUVFGTEd5RUpJQU1nRG1zaERrRUFJUWdEUUFKQUlBb2dDRUVvYkdvaUFpZ0NGQ0lQUVg5cVFRRk5CRUFnQWlnQ0NDQU9SZzBCQ3lBSVFRRnFJZ2dnQ1VjTkFRd0lDd3NnQ0VFQVNBMEdJQTlCQWtrTkJpQUNRUU0yQWhRZ0FpQU1OZ0lJSUF0QkFXb2hDd3dFQ3lBQUlBZ29BaHdpQ1RZQ0pDQUFLQUlZSWd4RkRRSWdBQ2dDQUNFS1FRQWhBaUFKUWYvL0EwWUVRQU5BQWtBZ0NpQUNRU2hzYWlJSUtBSVVRUU5IRFFBZ0NFRUFOZ0lVSUFBZ0FDZ0NLRUYvYWpZQ0tDQUlLQUlZRFFBZ0FDQUFLQUlzUVg5cU5nSXNDeUFDUVFGcUlnSWdERWNOQUF3RUFBc0FDd05BQWtBZ0NpQUNRU2hzYWlJSUtBSVVRUU5IRFFBZ0NDZ0NDQ0FKVFEwQUlBaEJBRFlDRkNBQUlBQW9BaWhCZjJvMkFpZ2dDQ2dDR0EwQUlBQWdBQ2dDTEVGL2FqWUNMQXNnQWtFQmFpSUNJQXhIRFFBTERBSUxJQUFRS0NBQVFRRTJBalJCQUNFRElBdEJBV29oQ3d3Q0N5QUFLQUlrSWdKQi8vOERSZzBESUFJZ0NDZ0NHQ0lNU1EwRElBQW9BaGdpQ2tVTkF5QUFLQUlBSVFoQkFDRUNBa0FEUUFKQUlBZ2dBa0VvYkdvaUNTZ0NGRUVEUncwQUlBa29BZ2dnREVjTkFDQUpRUUEyQWhRZ0FDQUFLQUlvUVg5cUlnZzJBaWdnQ1NnQ0dBMENJQUFnQUNnQ0xFRi9hallDTEF3Q0N5QUNRUUZxSWdJZ0NrY05BQXNnQUNnQ0tDRUlDeUFJSUFwUERRTWdBQ2dDQ0NJQ1FRTTJBaFFnQWlBRU5nSVFJQUlnRERZQ0NDQUNJQU0yQWd3Z0FpQUFLQUk0UlRZQ0dFRUJJUkFnQUNBSVFRRnFOZ0lvSUFBZ0FDZ0NMRUVCYWpZQ0xBc2dDMEVCYWlFTERBQUFDd0FMUVFBaEFpQUFLQUlvSWdrZ0FDZ0NHQ0lMU1EwQklBbEZCRUJCQUNFSkRBSUxJQUFvQWdBaERFRi9JUUVEUUNBTUlBSkJLR3hxSWdvb0FoUkJmMnBCQVUwRVFDQUtLQUlJSWdvZ0NDQUJRWDlHSUFvZ0NFaHlJZ29iSVFnZ0FpQUJJQW9iSVFFTElBSkJBV29pQWlBSlJ3MEFDeUFCUVFCSURRRWdEQ0FCUVNoc2FpSUJRUUEyQWhRZ0FDQUpRWDlxSWdrMkFpZ2dBU2dDR0EwQklBQWdBQ2dDTEVGL2FqWUNMQXdCQ3lBUURRRWdBQ2dDR0NFTElBQW9BaWdoQ1FzZ0NTQUxUdzBCSUFBb0FnZ2lBU0FOTmdJWUlBRkJBallDRkNBQklBUTJBaEFnQVNBRE5nSUlJQUVnQXpZQ0RDQUFJQWxCQVdvMkFpZ2dBQ0FBS0FJc1FRRnFOZ0lzQ3dzZ0FDZ0NDQ0lCSUFjMkFpQWdBU0FHTmdJY0lBRWdCVFlDSkFKQUlBQW9BamhGQkVBZ0FDZ0NMQ0lKSUFBb0Fod2lBMDBOQVNBQUtBSUFJUVFEUUVILy8vLy9CeUVGUVFBaEJrRUFJUUlEUUNBRUlBSkJLR3hxSWdFb0FoZ0VRQ0FCSUFZZ0FTZ0NFQ0lCSUFWSUlnY2JJUVlnQVNBRklBY2JJUVVMSUFKQkFXb2lBaUFEVFEwQUN3SkFJQVpGRFFBZ0FDZ0NEQ0FBS0FJUUlnSkJCSFJxSWdFZ0JpZ0NBRFlDQUNBQklBWW9BaVEyQWd3Z0FTQUdLQUljTmdJRUlBRWdCaWdDSURZQ0NDQUFJQUpCQVdvMkFoQWdCa0VBTmdJWUlBWW9BaFFOQUNBQUlBbEJmMm9pQ1RZQ0xBc2dDU0FEU3cwQUN3d0JDeUFCS0FJQUlRSWdBQ2dDRENBQUtBSVFJZ05CQkhScUlnRWdCVFlDRENBQklBSTJBZ0FnQVNBSE5nSUlJQUVnQmpZQ0JDQUFJQU5CQVdvMkFoQWdBQ2dDSENFREN5QUFLQUlBSUFOQkFXb1FKd3NMMUFzQ0FuOEJmaU1BUVpBQmF5SUVKQUFnQkVFQU5nSU1Ba0FDUUFKQUlBQW9BcEFhUlEwQUlBQW9BcFFhSUFGSERRQWdCQ0FBUWFRYWFpa0NBRGNER0NBQUtRS2NHaUVHSUFSQkFEWUNHQ0FFSUFZM0F4QWdCRUVBTmdJZ0lBUWdCajRDRkNBRElBQW9BcGdhTmdJQURBRUxRUU1oQlNBQklBSWdCRUVRYWlBREVHVU5BU0FBSUFRcEF4QTNBcHdhSUFCQnJCcHFJQVFvQWlBMkFnQWdBRUdrR21vZ0JDa0RHRGNDQUNBREtBSUFJUUlnQUNBQk5nS1VHaUFBSUFJMkFwZ2FDMEVBSVFVZ0FFRUFOZ0tRR2lBRVFSQnFJQVJCaUFGcUVFOEVRRUVESVFVTUFRc2dCQ2dDaUFGQmYycEJDMHNOQUNBRVFSQnFJQVJCaUFGcUlBQWdCRUVNYWhBeUlnRUVRRUVFSVFVZ0FVSHcvd05HRFFGQkF5RUZEQUVMQWtBZ0JDZ0NEQVJBQWtBZ0FDZ0NvQWxGRFFBZ0FDZ0NFRVVOQUVFRElRVWdBQ2dDdEJvTkF3SkFJQUFvQXFRSlJRUkFJQUJCeEFscUlnSWlBU0FCS0FJQUlBRW9BaHhCS0d4cUlnRTJBZ2dnQUNBQktBSUFOZ0s0Q2lBQ0VDWWdBQ0FBUWJnS2FrRUFFQ1VNQVFzZ0FDQUFRYmdLYWlBQVFkd0thaWdDQUJBbEN5QURRUUEyQWdBZ0FFRUFOZ0tjQ1NBQVFRRTJBcEFhREFJTElBQkJBRFlDbkFrZ0FFRUFOZ0trQ1FzZ0JDZ0NpQUZCZjJvaUFVRUhTdzBCQWtBQ1FBSkFJQUZCQVdzT0J3UUVCQUlFQUFFQ0N5QUVRUkJxSUFSQktHb1FRd1JBSUFRb0FsQVFCQ0FFUVFBMkFsQWdCQ2dDZkJBRUlBUkJBRFlDZkVFRElRVU1CQXNnQUNBRVFTaHFFRGNNQXdzZ0JFRVFhaUFFUVNocUVFd0VRQ0FFS0FJOEVBUWdCRUVBTmdJOElBUW9Ba0FRQkNBRVFRQTJBa0FnQkNnQ1JCQUVJQVJCQURZQ1JDQUVLQUpVRUFRZ0JFRUFOZ0pVUVFNaEJRd0RDeUFBSUFSQktHb1FOZ3dDQ3lBQUtBS2NDUTBCSUFCQkFUWUNvQWtDUUNBQUtBS2tDUTBBSUFCQ0FEY0N0QWtnQkVFUWFpQUVRU2hxRUNBYUlBQW9BZ2doQVNBQUlBUW9BaWdnQkNnQ2lBRkJCVVlRTlNJQ0JFQWdBRUtBZ29DQWdBUTNBZ1FnQUVFQU5nSzBHaUFBUWdBM0FneEJCVUVFSUFKQi8vOERSaHNoQlF3REN5QUJJQUFvQWdoR0RRQWdBQ2dDRUNFQklBUkJBVFlDQ0NBQUtBSUFJZ0pCSDAwRVFDQUFJQUpCQW5ScUtBSVVJUVVMSUFOQkFEWUNBQ0FBUVFFMkFwQWFBa0FDUUFKQUlBUW9Bb2dCUVFWSERRQWdCRUVJYWlBRVFSQnFJQUVnQUNnQ0RCQTRJQVFvQWdoeURRQWdCVVVOQUNBQVFmd0phaWdDQUEwQUlBVW9BalFnQVNnQ05FY05BQ0FGS0FJNElBRW9BamhIRFFBZ0JTZ0NXQ0FCS0FKWVJnMEJDeUFBUVlBS2FrRUFOZ0lBREFFTElBQkJ4QWxxRUZrTElBQWdBQ2dDQ0RZQ0FFRUNJUVVNQWdzZ0FDZ0N0Qm9FUUVFRElRVU1BZ3NnQkVFUWFpQUFRYlFTYWlJQ0lBQW9BaEFnQUNnQ0RDQUVRWWdCYWhBK0JFQkJBeUVGREFJTElBQW9BcVFKUlFSQUFrQWdCQ2dDaUFGQkJVWU5BQ0FBUWNRSmFpQUFRY0FTYWlnQ0FDQUVLQUtNQVVFQVJ5QUFLQUlRS0FJd0VGcEZEUUJCQXlFRkRBTUxJQUJCeEFscUlnRWdBU2dDQUNBQktBSWNRU2hzYWlJQk5nSUlJQUFnQVNnQ0FEWUN1QW9MSUFCQjJBcHFJQUpCM0FjUUZTRUJJQUJCQVRZQ3BBa2dBQ0FFS1FPSUFUY0MwQW9nQUNnQ2xBa2dBQ2dDRENBQVFaZ0xhaWdDQUNBQUtBSVFJZ0lvQWpRZ0FpZ0NPQkEvSUFCQnhBbHFJZ0lRSmlBQ0lBQkJuQXRxSUFCQjVBcHFLQUlBSUFCQmhBdHFLQUlBRUY4RVFFRURJUVVNQWdzZ0JFRVFhaUFBSUFCQnVBcHFJQUVRUVFSQUlBQWdBQ2dDMkFvUVFFRURJUVVNQWdzZ0FCQXpSUTBCSUFCQkFUWUNuQWtMSUFCQnVBcHFJZ0VnQUNnQ3ZBa1FTU0FBRURRZ0FFR0VDbW9nQUNnQ0VDQUFRZGdLYWlBQVFkQUthaEJOSVFJQ1FDQUFLQUtrQ1VVTkFDQUFRY1FKYWlFRElBQkIxQXBxS0FJQUJFQWdBeUFBUWV3TWFpQUJJQUJCNUFwcUtBSUFJQUlnQUNnQzBBcEJCVVlnQUNnQ3VBa2dBQ2dDdEFrUUtRd0JDeUFEUVFBZ0FTQUFRZVFLYWlnQ0FDQUNJQUFvQXRBS1FRVkdJQUFvQXJnSklBQW9BclFKRUNrTElBQkNBRGNDb0FsQkFTRUZDeUFFUVpBQmFpUUFJQVVMcUF3QkMzOENRQ0FCUVFSUEJFQkJBQ0FEYXlJTlFRRjBJUW9DUUNBQUlBTnJJZ1V0QUFBaUJpQUFMUUFBSWdocklnRWdBVUVmZFNJQmFpQUJjeUFDS0FJRUlnRlBEUUFnQUNBS2FpMEFBQ0lISUFacklnUWdCRUVmZFNJRWFpQUVjeUFDS0FJSUlneFBEUUFnQUNBRGFpMEFBQ0lFSUFocklnc2dDMEVmZFNJTGFpQUxjeUFNVHcwQUlBVWdCQ0FHYWlBSFFRRjBha0VDYWtFQ2Rqb0FBQ0FBSUFnZ0JFRUJkR29nQjJwQkFtcEJBblk2QUFBZ0FpZ0NCQ0VCQ3dKQUlBQkJBV29pQmlBTmFpSU1MUUFBSWdnZ0FDMEFBU0lIYXlJRUlBUkJIM1VpQkdvZ0JITWdBVThOQUNBR0lBcHFMUUFBSWdRZ0NHc2lCU0FGUVI5MUlnVnFJQVZ6SUFJb0FnZ2lDMDhOQUNBRElBWnFMUUFBSWdVZ0Iyc2lDU0FKUVI5MUlnbHFJQWx6SUF0UERRQWdEQ0FGSUFocUlBUkJBWFJxUVFKcVFRSjJPZ0FBSUFZZ0J5QUZRUUYwYWlBRWFrRUNha0VDZGpvQUFDQUNLQUlFSVFFTEFrQWdBRUVDYWlJR0lBMXFJZ3d0QUFBaUNDQUFMUUFDSWdkcklnUWdCRUVmZFNJRWFpQUVjeUFCVHcwQUlBWWdDbW90QUFBaUJDQUlheUlGSUFWQkgzVWlCV29nQlhNZ0FpZ0NDQ0lMVHcwQUlBTWdCbW90QUFBaUJTQUhheUlKSUFsQkgzVWlDV29nQ1hNZ0MwOE5BQ0FNSUFVZ0NHb2dCRUVCZEdwQkFtcEJBblk2QUFBZ0JpQUhJQVZCQVhScUlBUnFRUUpxUVFKMk9nQUFJQUlvQWdRaEFRc0NRQ0FBUVFOcUlnWWdEV29pREMwQUFDSUlJQUF0QUFNaUIyc2lCQ0FFUVI5MUlnUnFJQVJ6SUFGUERRQWdCaUFLYWkwQUFDSUVJQWhySWdVZ0JVRWZkU0lGYWlBRmN5QUNLQUlJSWd0UERRQWdBeUFHYWkwQUFDSUZJQWRySWdrZ0NVRWZkU0lKYWlBSmN5QUxUdzBBSUF3Z0JTQUlhaUFFUVFGMGFrRUNha0VDZGpvQUFDQUdJQWNnQlVFQmRHb2dCR3BCQW1wQkFuWTZBQUFnQWlnQ0JDRUJDd0pBSUFCQkJHb2lCaUFOYWlJTUxRQUFJZ2dnQUMwQUJDSUhheUlFSUFSQkgzVWlCR29nQkhNZ0FVOE5BQ0FHSUFwcUxRQUFJZ1FnQ0dzaUJTQUZRUjkxSWdWcUlBVnpJQUlvQWdnaUMwOE5BQ0FESUFacUxRQUFJZ1VnQjJzaUNTQUpRUjkxSWdscUlBbHpJQXRQRFFBZ0RDQUZJQWhxSUFSQkFYUnFRUUpxUVFKMk9nQUFJQVlnQnlBRlFRRjBhaUFFYWtFQ2FrRUNkam9BQUNBQ0tBSUVJUUVMQWtBZ0FFRUZhaUlHSUExcUlnd3RBQUFpQ0NBQUxRQUZJZ2RySWdRZ0JFRWZkU0lFYWlBRWN5QUJUdzBBSUFZZ0Ntb3RBQUFpQkNBSWF5SUZJQVZCSDNVaUJXb2dCWE1nQWlnQ0NDSUxUdzBBSUFNZ0Jtb3RBQUFpQlNBSGF5SUpJQWxCSDNVaUNXb2dDWE1nQzA4TkFDQU1JQVVnQ0dvZ0JFRUJkR3BCQW1wQkFuWTZBQUFnQmlBSElBVkJBWFJxSUFScVFRSnFRUUoyT2dBQUlBSW9BZ1FoQVFzQ1FDQUFRUVpxSWdZZ0RXb2lEQzBBQUNJSUlBQXRBQVlpQjJzaUJDQUVRUjkxSWdScUlBUnpJQUZQRFFBZ0JpQUthaTBBQUNJRUlBaHJJZ1VnQlVFZmRTSUZhaUFGY3lBQ0tBSUlJZ3RQRFFBZ0F5QUdhaTBBQUNJRklBZHJJZ2tnQ1VFZmRTSUphaUFKY3lBTFR3MEFJQXdnQlNBSWFpQUVRUUYwYWtFQ2FrRUNkam9BQUNBR0lBY2dCVUVCZEdvZ0JHcEJBbXBCQW5ZNkFBQWdBaWdDQkNFQkN5QU5JQUJCQjJvaURXb2lDQzBBQUNJR0lBQXRBQWNpQUdzaUJ5QUhRUjkxSWdkcUlBZHpJQUZQRFFFZ0NpQU5haTBBQUNJQklBWnJJZ29nQ2tFZmRTSUthaUFLY3lBQ0tBSUlJZ3BQRFFFZ0F5QU5haTBBQUNJQ0lBQnJJZ01nQTBFZmRTSURhaUFEY3lBS1R3MEJJQWdnQWlBR2FpQUJRUUYwYWtFQ2FrRUNkam9BQUNBTklBQWdBa0VCZEdvZ0FXcEJBbXBCQW5ZNkFBQVBDMEVBSUFOcklnZEJBWFFoQkNBQklBSW9BZ0JxUVg5cUxRQUFJZ0ZCQVdvaEJpQUJRWDl6SVFoQkNDRUJBMEFDUUNBQUlBZHFJZ1V0QUFBaUNpQUFMUUFBSWcxcklnd2dERUVmZFNJTWFpQU1jeUFDS0FJRVR3MEFJQUFnQkdvdEFBQWlEQ0FLYXlJTElBdEJIM1VpQzJvZ0MzTWdBaWdDQ0NJTFR3MEFJQUFnQTJvdEFBQWlDU0FOYXlJT0lBNUJIM1VpRG1vZ0RuTWdDMDhOQUNBRklBb2dDQ0FHSUEwZ0NtdEJBblFnQ1dzZ0RHcEJCR3BCQTNVaUNpQUtJQVpLR3lBS0lBaElHeUlLYWtHd0xtb3RBQUE2QUFBZ0FDQU5JQXByUWJBdWFpMEFBRG9BQUFzZ0FFRUJhaUVBSUFGQmYyb2lBUTBBQ3dzTDZnZ0JBbjhnQVVFQVFiZ0hFQWNoQWtFQklRRUNRQUpBSUFCQkFSQURJZ05CZjBZTkFDQUNJQU5CQVVZMkFnQUNRQ0FEUVFGSERRQWdBRUVJRUFNaUEwRi9SZzBCSUFJZ0F6WUNCQ0FEUWY4QlJ3MEFJQUJCRUJBRElnTkJmMFlOQVNBQ0lBTTJBZ2dnQUVFUUVBTWlBMEYvUmcwQklBSWdBellDREFzZ0FFRUJFQU1pQTBGL1JnMEFJQUlnQTBFQlJqWUNFQ0FEUVFGR0JFQWdBRUVCRUFNaUEwRi9SZzBCSUFJZ0EwRUJSallDRkFzZ0FFRUJFQU1pQTBGL1JnMEFJQUlnQTBFQlJqWUNHQUpBQWtBZ0EwRUJSZ1JBSUFCQkF4QURJZ05CZjBZTkF5QUNJQU0yQWh3Z0FFRUJFQU1pQTBGL1JnMERJQUlnQTBFQlJqWUNJQ0FBUVFFUUF5SURRWDlHRFFNZ0FpQURRUUZHTmdJa0lBTkJBVWNOQVNBQVFRZ1FBeUlEUVg5R0RRTWdBaUFETmdJb0lBQkJDQkFESWdOQmYwWU5BeUFDSUFNMkFpd2dBRUVJRUFNaUEwRi9SdzBDREFNTElBSkJCVFlDSEFzZ0FrS0NnSUNBSURjQ0tFRUNJUU1MSUFJZ0F6WUNNQ0FBUVFFUUF5SURRWDlHRFFBZ0FpQURRUUZHTmdJMEFrQWdBMEVCUncwQUlBQWdBa0U0YWhBQ0lnRU5BU0FDS0FJNFFRVkxEUUlnQUNBQ1FUeHFFQUlpQVEwQklBSW9BanhCQlUwTkFBd0NDMEVCSVFFZ0FFRUJFQU1pQTBGL1JnMEFJQUlnQTBFQlJqWUNRQ0FEUVFGR0JFQWdBQkFQSVFFZ0FFRWdFQXNoQXlBQlJRMENJQU5CZjBZTkFpQUNJQUUyQWtRZ0FCQVBJUUVnQUVFZ0VBc2hBeUFCUlEwQ0lBTkJmMFlOQWlBQ0lBRTJBa2hCQVNFQklBQkJBUkFESWdOQmYwWU5BU0FDSUFOQkFVWTJBa3dMSUFCQkFSQURJZ05CZjBZTkFDQUNJQU5CQVVZMkFsQUNRQ0FEUVFGR0JFQWdBQ0FDUWRRQWFoQWNJZ0ZGRFFFTUFnc2dBa0VCTmdKVUlBSkNtSUNBZ0lBRE53TG9BeUFDUXBpQWdJQ0FBemNDNEFNZ0FrR0JrS3FKQVRZQzRBRWdBa0dCa0txSkFUWUNZQXRCQVNFQklBQkJBUkFESWdOQmYwWU5BQ0FDSUFOQkFVWTJBdkFEQWtBZ0EwRUJSZ1JBSUFBZ0FrSDBBMm9RSENJQlJRMEJEQUlMSUFKQkFUWUM5QU1nQWtLWWdJQ0FnQU0zQW9nSElBSkNtSUNBZ0lBRE53S0FCeUFDUVlHNHVQSUFOZ0tBQlNBQ1FZRzR1UElBTmdLQUJBc0NRQ0FDS0FKUVJRUkFJQUlvQXZBRFJRMEJDMEVCSVFFZ0FFRUJFQU1pQTBGL1JnMEJJQUlnQTBFQlJqWUNrQWNMUVFFaEFTQUFRUUVRQXlJRFFYOUdEUUFnQWlBRFFRRkdOZ0tVQnlBQVFRRVFBeUlEUVg5R0RRQWdBaUFEUVFGR05nS1lCd0pBSUFOQkFVWUVRQ0FBUVFFUUF5SURRWDlHRFFJZ0FpQURRUUZHTmdLY0J5QUFJQUpCb0FkcUVBSWlBUTBDSUFJb0FxQUhRUkJMRFFNZ0FDQUNRYVFIYWhBQ0lnRU5BaUFDS0FLa0IwRVFTdzBESUFBZ0FrR29CMm9RQWlJQkRRSWdBaWdDcUFkQkVFc05BeUFBSUFKQnJBZHFFQUlpQVEwQ1FRRWhBU0FDS0FLc0IwRVFTdzBDSUFBZ0FrR3dCMm9RQWlJQkRRSWdBQ0FDUWJRSGFoQUNJZ0ZGRFFFTUFnc2dBa0VRTmdLMEJ5QUNRcENBZ0lDQUFqY0NyQWNnQWtLQmdJQ0FnQUkzQXFRSElBSkNnWUNBZ0NBM0Fwd0hDMEVBSVFFTElBRVBDMEVCQzAwQkFuOGpBRUVRYXlJREpBQkJBU0VFQWtBZ0FDQURRUXhxRUFJTkFDQURLQUlNSWdCQkwwc05BQ0FCUWRBL1FZREFBQ0FDR3lBQWFpMEFBRFlDQUVFQUlRUUxJQU5CRUdva0FDQUVDejRCQW44Q1FDQUFLQUlNUVFOMElBQW9BaEJySWdGRkJFQU1BUXRCQVNFQ0lBRkJDRXNOQUVFQklBRkJmMnAwSUFBUUQwRWdJQUZyZGtjUEN5QUNDeklCQW44Q1FFR0FnSURBQUNJQklBQnhEUUFEUUNBQ1FRRnFJUUlnQVVFQmRpSUJSUTBCSUFBZ0FYRkZEUUFMQ3lBQ0M0b0NBUWQvSUFGQm9EMXFMUUFBUVF4c1FkQThhaWdDQUNFQ1FRRWhBeUFCUVFaUEJFQkJBQ0VESUFJZ0FVR1FQR290QUFCQmYycDBJUUlMSUFBZ0FDZ0NBQ0lCSUFBb0FnZ2lCR3NpQlNBQUtBSUVJZ1lnQUNnQ0RDSUhheUlJYXlBQ2JDQURkVFlDRENBQUlBVWdDR29nQW13Z0EzVTJBZ2dnQUNBQklBUnFJZ0VnQmlBSGFpSUVheUFDYkNBRGRUWUNCQ0FBSUFFZ0JHb2dBbXdnQTNVMkFnQWdBQ0FBS0FJY0lnRWdBQ2dDRkNJRWFpSUZJQUFvQWhnaUJpQUFLQUlRSWdkcUlnaHFJQUpzSUFOMU5nSVFJQUFnQkNBQmF5SUJJQWNnQm1zaUJHb2dBbXdnQTNVMkFoZ2dBQ0FJSUFWcklBSnNJQU4xTmdJVUlBQWdCQ0FCYXlBQ2JDQURkVFlDSEF2UENBRVVmeUFBSUFBb0Fpd2lBaUFBS0FJTUlnWnFJZ1VnQUNnQ05DSUVJQUFvQWlBaUVHb2lDbXNpRVRZQ0xDQUFLQUlvSVFNZ0FDQUdJQUpySWdjZ0VDQUVheUlFYXlJR05nSW9JQUFvQWlRaEFpQUFJQVFnQjJvaUJEWUNKQ0FBSUFVZ0Ntb2lCVFlDSUNBQUlBQW9BaHdpQ2lBQUtBSUlJZ2RxSWdnZ0FDZ0NNQ0lNSUFBb0FoQWlDV29pQzJzaUVEWUNIQ0FBS0FJWUlROGdBQ0FISUFwcklnY2dDU0FNYXlJTWF5SUtOZ0lZSUFBb0FoUWhDU0FBSUFjZ0RHb2lCellDRkNBQUlBZ2dDMm9pQ0RZQ0VDQUFJQWtnQUNnQ0FDSUxhaUlTSUE4Z0FDZ0NCQ0lOYWlJT2F5SU1OZ0lNSUFBZ0N5QUpheUlKSUEwZ0Qyc2lDMnNpRHpZQ0NDQUFJQWtnQzJvaUNUWUNCQ0FBSUE0Z0Vtb2lDellDQUNBQUlBSWdBQ2dDT0NJTmFpSVRJQU1nQUNnQ1BDSU9haUlVYXlJU05nSThJQUFnQWlBTmF5SUNJQU1nRG1zaUEyc2lEVFlDT0NBQUlBSWdBMm9pRGpZQ05DQUFJQk1nRkdvaUV6WUNNQ0FCUVpBOGFpMEFBQ0VDSUFGQm9EMXFMUUFBUVF4c1FkQThhaWdDQUNFRElBRkJERThFUUNBQUlBTWdBa0YrYW5RaUFTQUZJQXRxSWdNZ0NDQVRhaUlDYTJ3MkFqQWdBQ0FMSUFWcklnVWdDQ0FUYXlJSWF5QUJiRFlDSUNBQUlBVWdDR29nQVd3MkFoQWdBQ0FDSUFOcUlBRnNOZ0lBSUFBZ0JDQUphaUlESUFjZ0Rtb2lBbXNnQVd3MkFqUWdBQ0FKSUFScklnUWdCeUFPYXlJRmF5QUJiRFlDSkNBQUlBUWdCV29nQVd3MkFoUWdBQ0FDSUFOcUlBRnNOZ0lFSUFBZ0JpQVBhaUlESUFvZ0RXb2lBbXNnQVd3MkFqZ2dBQ0FQSUFacklnWWdDaUFOYXlJRWF5QUJiRFlDS0NBQUlBUWdCbW9nQVd3MkFoZ2dBQ0FDSUFOcUlBRnNOZ0lJSUFBZ0RDQVJheUlESUJBZ0Vtc2lBbXNnQVd3MkFpd2dBQ0FDSUFOcUlBRnNOZ0ljSUFBZ0VDQVNhaUlESUF3Z0VXb2lBbW9nQVd3MkFnd2dBQ0FDSUFOcklBRnNOZ0k4RHdzZ0FFRUJRUUlnQVVGNmFrRUdTUnNpQVNBRklBdHFJaFFnQ0NBVGFpSVZheUFEYkdwQkFpQUNheUlDZFRZQ01DQUFJQXNnQldzaUJTQUlJQk5ySWdocklBTnNJQUZxSUFKMU5nSWdJQUFnQlNBSWFpQURiQ0FCYWlBQ2RUWUNFQ0FBSUJRZ0ZXb2dBMndnQVdvZ0FuVTJBZ0FnQUNBRUlBbHFJZ1VnQnlBT2FpSUlheUFEYkNBQmFpQUNkVFlDTkNBQUlBa2dCR3NpQkNBSElBNXJJZ2RySUFOc0lBRnFJQUoxTmdJa0lBQWdCQ0FIYWlBRGJDQUJhaUFDZFRZQ0ZDQUFJQVVnQ0dvZ0Eyd2dBV29nQW5VMkFnUWdBQ0FHSUE5cUlnUWdDaUFOYWlJRmF5QURiQ0FCYWlBQ2RUWUNPQ0FBSUE4Z0Jtc2lCaUFLSUExcklncHJJQU5zSUFGcUlBSjFOZ0lvSUFBZ0JpQUthaUFEYkNBQmFpQUNkVFlDR0NBQUlBUWdCV29nQTJ3Z0FXb2dBblUyQWdnZ0FDQU1JQkZySWdZZ0VDQVNheUlFYXlBRGJDQUJhaUFDZFRZQ0xDQUFJQVFnQm1vZ0Eyd2dBV29nQW5VMkFod2dBQ0FRSUJKcUlnWWdEQ0FSYWlJUmFpQURiQ0FCYWlBQ2RUWUNEQ0FBSUJFZ0Jtc2dBMndnQVdvZ0FuVTJBandMdlFVQkJuOGpBRUVnYXlJRkpBQWdBMEVBTmdJQUFrQWdBU2dDQUNJR1FSSkxEUUJCQVNBR2RDSUdRY0RmSDNGRkJFQWdCa0VpY1VVTkFTQUNRYlFLYWlnQ0FBUkFJQU5CQVRZQ0FDQUNRUUEyQXJRS0N5QUFJQVZCSEdvUUlDSUVEUUZCOFA4RElRUWdBaUFGS0FJY1FRSjBhaWdDbEFFaUNFVU5BU0FDSUFnb0FnUWlCa0VDZEdvb0FoUWlCMFVOQVFKQUlBSW9BZ2dpQ1VFZ1JnMEFJQVlnQ1VZTkFDQUJLQUlBUVFWSERRSUxBa0FnQWtHWUNtb29BZ0FpQkNBQktBSUVJZ1pHRFFBZ0JFRUFJQVliRFFBZ0EwRUJOZ0lBQ3lBQktBSUFJUVFDUUFKQUlBSW9BcFFLUVFWR0JFQWdCRUVGUncwQkRBSUxJQVJCQlVjTkFRc2dBMEVCTmdJQUMwRUJJUVFnQUNBSEtBSU1JQVZCR0dvUVBRMEJJQVVvQWhnaUJpQUNRWndLYWlnQ0FFY0VRQ0FDSUFZMkFwd0tJQU5CQVRZQ0FBc2dBU2dDQUVFRlJnUkFJQUFnQnlnQ0RDQUZRUlJxRUR3TkFnSkFJQUlvQXBRS1FRVkhCRUFnQlNnQ0ZDRUVEQUVMSUFKQm9BcHFLQUlBSWdRZ0JTZ0NGQ0lHUmcwQUlBTkJBVFlDQUNBR0lRUUxJQUpCb0FwcUlBUTJBZ0FMQWtBZ0J5Z0NFQ0lFUVFGTERRQWdCRUVCYXdSQVFRRWhCQ0FBSUFjZ0FTZ0NBQ0FGUVFocUVEc05BeUFGS0FJSUlnUWdBa0drQ21vb0FnQkhCRUFnQWlBRU5nS2tDaUFEUVFFMkFnQUxJQWdvQWdoRkRRRWdBQ0FISUFFb0FnQWdCVUVRYWhBNklnUU5BeUFGS0FJUUlnQWdBa0dvQ21vb0FnQkdEUUVnQWlBQU5nS29DaUFEUVFFMkFnQU1BUXNnQnlnQ0dBMEFJQUFnQnlBQktBSUFJQWdvQWdnZ0JVRUlhaEE1SWdRTkFpQUZLQUlJSWdBZ0FrR3NDbW9vQWdCSEJFQWdBaUFBTmdLc0NpQURRUUUyQWdBTElBZ29BZ2hGRFFBZ0JTZ0NEQ0lBSUFKQnNBcHFLQUlBUmcwQUlBSWdBRFlDc0FvZ0EwRUJOZ0lBQ3lBQ0lBRXBBZ0EzQXBRS1FRQWhCQXdCQ3lBRFFRRTJBZ0FMSUFWQklHb2tBQ0FFQzM4QkEzOENRQUpBQWtBZ0FFSDhDbW9vQWdBRVFDQUFLQUtZQ1NJRERRRkJBUThMUVFFaEFTQUFRYXdKYWlnQ0FDQUFLQUtZQ1VjTkFRd0NDeUFBS0FLOENTRUJRUUFoQUFOQUlBSWdBU0FBUWRnQmJHb29Bc1FCUVFCSGFpRUNJQUJCQVdvaUFDQURSdzBBQzBFQklRRWdBaUFEUmcwQkMwRUFJUUVMSUFFTFNnRURmeUFBUWdBM0FxZ0pJQUFvQXBnSklnRUVRQ0FBS0FLOENTRUNRUUFoQUFOQUlBSWdBRUhZQVd4cUlnTkJBRFlDeEFFZ0EwRUFOZ0lFSUFCQkFXb2lBQ0FCUncwQUN3c0xnd1lCREg5QkFTRUdBa0FnQUNBQlFRSjBhaWdDbEFFaUJFVU5BQ0FBSUFRb0FnUWlDVUVDZEdvaUNrRVVhaWdDQUNJRFJRMEFBa0FnQkNnQ0RDSUZRUUpKRFFBZ0F5Z0NOQ0lISUFNb0FqaHNJUWdDUUNBRUtBSVFJZ05CQWtzTkFBSkFBa0FDUUNBRFFRRnJEZ0lEQUFFTElBVkJmMm9oQ3lBRUtBSWNJUXdnQkNnQ0dDRU5RUUFoQXd3QkN5QUVLQUlVSVFkQkFDRURBMEFnQnlBRFFRSjBhaWdDQUNBSVRRUkFJQVVnQTBFQmFpSURSdzBCREFRTEMwRUJEd3NEUUNBTklBTkJBblFpQldvb0FnQWlEaUFGSUF4cUtBSUFJZ1ZMRFFNZ0JTQUlUdzBESUE0Z0IzQWdCU0FIY0UwRVFDQURRUUZxSWdNZ0MwWU5Bd3dCQ3d0QkFROExJQU5CZldwQkFrMEVRQ0FFS0FJa0lBaE5EUUVNQWdzZ0EwRUdSdzBBSUFRb0FpZ2dDRWtOQVFzQ1FDQUFLQUlFSWdOQmdBSkdCRUFnQUNBRU5nSU1JQUFnQVRZQ0JDQUFJQWsyQWdnZ0FDQUtLQUlVSWdFMkFoQWdBU2dDTkNFQ0lBRW9BamdoQVNBQVFRRTJBclFhSUFCQndBcHFJQUUyQWdBZ0FFRzhDbW9nQWpZQ0FDQUFJQUVnQW13MkFwZ0pEQUVMSUFBb0FyUWFCRUFnQUVFQU5nSzBHaUFBS0FLOENSQUVJQUJCQURZQ3ZBa2dBQ2dDbEFrUUJDQUFJQUFvQXBnSklnRkIyQUZzSWdRUUNpSUNOZ0s4Q1NBQUlBRkJBblFRQ2lJRE5nS1VDVUgvL3dNaEJpQUNSUTBDSUFORkRRSWdBa0VBSUFRUUJ5QUFLQUlRS0FJMElBRVFUaUFBS0FJUUlRRkJBU0VDQWtBZ0FDZ0N3QWtOQUNBQktBSVFRUUpHRFFBQ1FDQUJLQUpRUlEwQUlBRW9BbFFpQkNnQ21BZEZEUUFnQkNnQ3NBZEZEUUVMUVFBaEFnc2dBRUhFQ1dvZ0FTZ0NPQ0FCS0FJMGJDQUJLQUpZSUFFb0Fpd2dBU2dDRENBQ0VGd2lCa1VOQVF3Q0N5QUJJQU5HRFFBZ0FDZ0NDQ0FKUndSQUlBSkZEUUlnQUNBRU5nSU1JQUFnQVRZQ0JDQUFJQWsyQWdnZ0FDQUtLQUlVSWdFMkFoQWdBU2dDTkNFQ0lBRW9BamdoQVNBQVFRRTJBclFhSUFCQndBcHFJQUUyQWdBZ0FFRzhDbW9nQWpZQ0FDQUFJQUVnQW13MkFwZ0pEQUVMSUFBZ0JEWUNEQ0FBSUFFMkFnUUxRUUFoQmdzZ0JndTJBUUVEZndKQUlBQWdBU2dDQUNJRFFRSjBhaUlDS0FLVUFTSUVSUVJBSUFKQnlBQVFDaUlBTmdLVUFTQUFEUUVQQ3dKQUlBTWdBQ2dDQkVjTkFDQUJLQUlFSUFBb0FnaEdEUUFnQUVHQkFqWUNCQXNnQkNnQ0ZCQUVJQUlvQXBRQlFRQTJBaFFnQWlnQ2xBRW9BaGdRQkNBQ0tBS1VBVUVBTmdJWUlBSW9BcFFCS0FJY0VBUWdBaWdDbEFGQkFEWUNIQ0FDS0FLVUFTZ0NMQkFFSUFJb0FwUUJRUUEyQWl3TElBSW9BcFFCSUFGQnlBQVFGUm9MMWdFQkEzOENRQ0FBSUFFb0FnZ2lBMEVDZEdvaUFpZ0NGQ0lFUlFSQUlBSkIzQUFRQ2lJQU5nSVVJQUFOQVE4TElBQW9BZ2dnQTBZRVFDQUJJQUFvQWhBUVFnUkFJQUlvQWhRb0FpZ1FCQ0FDS0FJVVFRQTJBaWdnQWlnQ0ZDZ0NWQkFFSUFJb0FoUkJBRFlDVkNBQVFRQTJBaEFnQUVHQkFqWUNCQ0FBUWlFM0FnZ01BZ3NnQVNnQ0tCQUVJQUZCQURZQ0tDQUJLQUpVRUFRZ0FVRUFOZ0pVRHdzZ0JDZ0NLQkFFSUFJb0FoUkJBRFlDS0NBQ0tBSVVLQUpVRUFRZ0FpZ0NGRUVBTmdKVUN5QUNLQUlVSUFGQjNBQVFGUm9MMGdJQkEzOGpBRUVnYXlJRUpBQWdCQ0FCS0FJUU5nSVFJQVFnQVNrQ0NEY0RDQ0FFSUFFcEFnQTNBd0FDUUNBRUlBUkJIR29RQWlJQkRRQWdCQ0FFUVJ4cUVBSWlBUTBBSUFRZ0JFRWNhaEFDSWdFTkFDQUNLQUlNSVFaQkFDRUJBMEFnQVNJRlFRRnFJUUVnQmlBRmRnMEFDeUFFSUFWQmYyb1FBMEYvUmdSQVFRRWhBUXdCQ3lBRUlBUkJIR29RQWlJQkRRQUNRQ0FDS0FJUUlnRUVmeUFCQlNBQ0tBSVVJUVpCQUNFQkEwQWdBU0lGUVFGcUlRRWdCaUFGZGcwQUN5QUVJQVZCZjJvUUEwRi9SZ1JBUVFFaEFRd0RDeUFES0FJSUJFQWdCQ0FFUVJocUVBVWlBUTBEQ3lBQ0tBSVFDMEVCUncwQUlBSW9BaGdOQUNBRUlBUkJHR29RQlNJQkRRRWdBeWdDQ0VVTkFDQUVJQVJCR0dvUUJTSUJEUUVMSUFNb0FrUUVRQ0FFSUFSQkhHb1FBaUlCRFFFTElBQWdCRUVCRUFNaUFEWUNBQ0FBUVg5R0lRRUxJQVJCSUdva0FDQUJDOFlCQVFKL0l3QkJJR3NpQlNRQUlBVWdBQ2dDRURZQ0VDQUZJQUFwQWdnM0F3Z2dCU0FBS1FJQU53TUFBa0FnQlNBRlFSeHFFQUlpQUEwQUlBVWdCVUVjYWhBQ0lnQU5BQ0FGSUFWQkhHb1FBaUlBRFFBZ0FTZ0NEQ0VHUVFBaEFBTkFJQUFpQVVFQmFpRUFJQVlnQVhZTkFBc2dCU0FCUVg5cUVBTkJmMFlFUUVFQklRQU1BUXNnQWtFRlJnUkFJQVVnQlVFY2FoQUNJZ0FOQVFzZ0JTQUVFQVVpQUEwQUlBTUVRQ0FGSUFSQkJHb1FCU0lBRFFFTFFRQWhBQXNnQlVFZ2FpUUFJQUFMNFFFQkEzOGpBRUVnYXlJRUpBQWdCQ0FBS0FJUU5nSVFJQVFnQUNrQ0NEY0RDQ0FFSUFBcEFnQTNBd0FDUUNBRUlBUkJIR29RQWlJQURRQWdCQ0FFUVJ4cUVBSWlBQTBBSUFRZ0JFRWNhaEFDSWdBTkFDQUJLQUlNSVFaQkFDRUFBMEFnQUNJRlFRRnFJUUFnQmlBRmRnMEFDeUFFSUFWQmYyb1FBMEYvUmdSQVFRRWhBQXdCQ3lBQ1FRVkdCRUFnQkNBRVFSeHFFQUlpQUEwQkN5QUJLQUlVSVFKQkFDRUFBMEFnQUNJQlFRRnFJUUFnQWlBQmRnMEFDeUFFSUFGQmYyb1FBMEYvUmdSQVFRRWhBQXdCQ3lBRUlBTVFCU0VBQ3lBRVFTQnFKQUFnQUF2bUFRRURmeU1BUVNCcklnUWtBQ0FFSUFBb0FoQTJBaEFnQkNBQUtRSUlOd01JSUFRZ0FDa0NBRGNEQUFKQUlBUWdCRUVjYWhBQ0lnQU5BQ0FFSUFSQkhHb1FBaUlBRFFBZ0JDQUVRUnhxRUFJaUFBMEFJQUVvQWd3aEJrRUFJUUFEUUNBQUlnVkJBV29oQUNBR0lBVjJEUUFMSUFRZ0JVRi9haEFEUVg5R0JFQkJBU0VBREFFTElBSkJCVVlFUUNBRUlBUkJIR29RQWlJQURRRUxJQUVvQWhRaEFrRUFJUUFEUUNBQUlnRkJBV29oQUNBQ0lBRjJEUUFMSUFRZ0FVRi9haEFESWdCQmYwWUVRRUVCSVFBTUFRc2dBeUFBTmdJQVFRQWhBQXNnQkVFZ2FpUUFJQUFMa2dFQkFuOGpBRUVnYXlJREpBQWdBeUFBS0FJUU5nSVFJQU1nQUNrQ0FEY0RBQ0FESUFBcEFnZzNBd2dDUUNBRElBTkJIR29RQWlJQURRQWdBeUFEUVJ4cUVBSWlBQTBBSUFNZ0EwRWNhaEFDSWdBTkFFRUFJUUFEUUNBQUlnUkJBV29oQUNBQklBUjJEUUFMSUFNZ0JFRi9haEFEUVg5R0JFQkJBU0VBREFFTElBTWdBaEFDSVFBTElBTkJJR29rQUNBQUM1Y0JBUUovSXdCQklHc2lBeVFBSUFNZ0FDZ0NFRFlDRUNBRElBQXBBZ2czQXdnZ0F5QUFLUUlBTndNQUFrQWdBeUFEUVJ4cUVBSWlBQTBBSUFNZ0EwRWNhaEFDSWdBTkFDQURJQU5CSEdvUUFpSUFEUUJCQUNFQUEwQWdBQ0lFUVFGcUlRQWdBU0FFZGcwQUN5QURJQVJCZjJvUUF5SUFRWDlHQkVCQkFTRUFEQUVMSUFJZ0FEWUNBRUVBSVFBTElBTkJJR29rQUNBQUM2OE9BUXAvSXdCQkVHc2lCU1FBSUFGQkFFSGNCeEFISVFjZ0FpZ0NOQ0VHSUFJb0FqZ2hDQUpBSUFBZ0JVRUVhaEFDSWdFTkFDQUhJQVVvQWdRaUFUWUNBQ0FCSUFZZ0NHd2lDMDhFUUVFQklRRU1BUXNnQUNBRlFRUnFFQUlpQVEwQUlBY2dCU2dDQkNJR05nSUVJQVpCQjBzRVFFRUJJUUVNQVF0QkFTRUJBa0FDUUNBR1FRRnJEZ2NDQVFJQ0FBSUJBQXNnQkNnQ0FFRUZSZ1JBREFJTElBSW9BaXdOQUF3QkN5QUFJQVZCQkdvUUFpSUJEUUFnQnlBRktBSUVJZ1kyQWdoQkFTRUJJQVlnQXlnQ0FFY05BQ0FDS0FJTUlRaEJBQ0VCQTBBZ0FTSUdRUUZxSVFFZ0NDQUdkZzBBQzBFQklRRWdBQ0FHUVg5cUVBTWlCa0YvUmcwQUlBWkJBQ0FFS0FJQUlnaEJCVVliRFFBZ0J5QUdOZ0lNSUFoQkJVWUVRQ0FBSUFWQkJHb1FBaUlCRFFFZ0J5QUZLQUlFSWdZMkFoQkJBU0VCSUFaQi8vOERTdzBCQ3dKQUlBSW9BaEFpQVFSL0lBRUZJQUlvQWhRaENFRUFJUUVEUUNBQklnWkJBV29oQVNBSUlBWjJEUUFMSUFBZ0JrRi9haEFESWdGQmYwWUVRRUVCSVFFTUF3c2dCeUFCTmdJVUlBTW9BZ2dFUUNBQUlBVVFCU0lCRFFNZ0J5QUZLQUlBTmdJWUN5QUVLQUlBUVFWR0JFQkJBU0VCSUFjb0FoUWlCaUFDS0FJVVFRRjJTdzBESUFaQkFDQUhLQUlZSWdoQkgzVWdDSEZyUncwREN5QUNLQUlRQzBFQlJ3MEFJQUlvQWhnTkFDQUFJQVVRQlNJQkRRRWdCeUFGS0FJQU5nSWNJQU1vQWdnRVFDQUFJQVVRQlNJQkRRSWdCeUFGS0FJQU5nSWdDeUFFS0FJQVFRVkhEUUJCQVNFQklBY29BaHdpQmlBSEtBSWdJQVlnQWlnQ0lHcHFJZ2dnQmlBSVNCc05BUXNnQXlnQ1JBUkFJQUFnQlVFRWFoQUNJZ0VOQVNBSElBVW9BZ1FpQmpZQ0pFRUJJUUVnQmtIL0FFc05BUXNDUUNBSEtBSUVJZ0ZCQlVzTkFBSkFJQUZCQVdzT0JBRUJBUUVBQzBFQklRRWdBRUVCRUFNaUJrRi9SZzBCSUFjZ0JqWUNLQUpBSUFZRVFDQUFJQVZCQkdvUUFpSUJEUU5CQVNFQklBVW9BZ1FpQmtFUFN3MERJQVpCQVdvaEJnd0JDeUFES0FJd0lnWkJFRXNOQWdzZ0J5QUdOZ0lzSUFjb0FnUWhBUXNDUUNBQlFRVkxEUUFDUUNBQlFRRnJEZ1FCQVFFQkFBc2dBaWdDRENFSklBY29BaXdoQ2tFQklRRWdBRUVCRUFNaUJrRi9SZzBCSUFjZ0JqWUNSQ0FHUlEwQVFRQWhBUU5BSUFFaUJpQUtTd1JBUVFFaEFRd0RDeUFBSUFWQkNHb1FBaUlCRFFJZ0JTZ0NDQ0lCUVFOTEJFQkJBU0VCREFNTElBY2dCa0VNYkdvaUNDQUJOZ0pJQWtBZ0FVRUJUUVJBSUFBZ0JVRU1haEFDSWdFTkJDQUZLQUlNSWdFZ0NVOEVRRUVCSVFFTUJRc2dDQ0FCUVFGcU5nSk1EQUVMSUFGQkFrY05BQ0FBSUFWQkRHb1FBaUlCRFFNZ0NDQUZLQUlNTmdKUUN5QUdRUUZxSVFFZ0JTZ0NDRUVEUncwQUMwRUJJUUVnQmtVTkFRc0NRQ0FFS0FJRVJRMEFJQVFvQWdBaEJDQUNLQUlzSVFsQkFTRUJJQUJCQVJBRElRSWdCRUVGUmdSQUlBSkJmMFlOQWlBSElBSTJBcFFDSUFCQkFSQURJZ0pCZjBZTkFpQUhJQUkyQXBnQ0lBa05BU0FDUlEwQkRBSUxJQUpCZjBZTkFTQUhJQUkyQXB3Q0lBSkZEUUFnQ1VFQmRFRURhaUVPUVFBaEJrRUFJUXBCQUNFRUEwQWdCaUFPUmdSQVFRRWhBUXdEQ3lBQUlBVkJDR29RQWlJQkRRSWdCU2dDQ0NJQ1FRWkxCRUJCQVNFQkRBTUxJQWNnQmtFVWJHb2lDQ0FDTmdLZ0FnSi9JQUpCZlhGQkFVWUVRQ0FBSUFWQkRHb1FBaUlCRFFRZ0NDQUZLQUlNUVFGcU5nS2tBaUFGS0FJSUlRSUxJQUpCQWtZTEJFQWdBQ0FGUVF4cUVBSWlBUTBESUFnZ0JTZ0NERFlDcUFJZ0JTZ0NDQ0VDQ3dKQUlBSkJmV29pQVVFRFN3MEFBa0FnQVVFQmF3NENBUUVBQ3lBQUlBVkJER29RQWlJQkRRTWdDQ0FGS0FJTU5nS3NBaUFGS0FJSUlRSUxJQUpCQkVZRVFDQUFJQVZCREdvUUFpSUJEUU1nQlNnQ0RDSUJJQWxMQkVCQkFTRUJEQVFMSUFnZ0FVRi9ha0gvL3dNZ0FSczJBckFDSUFwQkFXb2hDaUFGS0FJSUlRSUxJQVpCQVdvaEJpQU1JQUpCQmtacUlRd2dCQ0FDUVFWR2FpRUVJQTBnQWtGL2FrRURTV29oRFNBQ0RRQUxRUUVoQVNBRUlBcHlJQXh5UVFGTERRRWdCRVVOQUNBTkRRRUxJQUFnQlJBRklnRU5BQ0FISUFVb0FnQWlBVFlDTUNBRklBRWdBeWdDTkdvaUFqWUNBRUVCSVFFZ0FrRXpTdzBBQWtBZ0F5Z0NQRVVOQUNBQUlBVkJCR29RQWlJQkRRRWdCeUFGS0FJRUlnSTJBalJCQVNFQklBSkJBa3NOQVNBQ1FRRkdEUUFnQUNBRkVBVWlBUTBCUVFFaEFTQUZLQUlBSWdKQkJtcEJERXNOQVNBSElBSkJBWFEyQWpnZ0FDQUZFQVVpQVEwQlFRRWhBU0FGS0FJQUlnSkJCbXBCREVzTkFTQUhJQUpCQVhRMkFqd0xBa0FnQXlnQ0RFRUNTUTBBSUFNb0FoQkJmV3BCQWtzTkFFRUNRUUVnQ3lBTElBTW9BaVFpQVc0aUFpQUJiR3NiSUFKcUlRUkJBQ0VDQTBBZ0JDQUNJZ0ZCQVdvaUFuWU5BQXNnQlNBQUlBSWdBU0FFUVg4Z0FYUkJmM054R3hBRElnQTJBZ1JCQVNFQklBQkJmMFlOQVNBSElBQTJBa0FnQUNBTElBTW9BaVFpQUdwQmYyb2dBRzVMRFFFTFFRQWhBUXNnQlVFUWFpUUFJQUVMd1FrQkRYOGdBeUFFYkNFRklBRW9BZ3dpQ1VFQlJnUkFJQUJCQUNBRlFRSjBFQWNhRHdzQ1FBSkFBa0FDUUNBQktBSVFJZ1pCZldwQkFrMEVRQ0FCS0FJa0lBSnNJZ0lnQlNBQ0lBVkpHeUVMSUFaQmZuRkJCRWNOQVNBRklBdHJJQXNnQVNnQ0lCc2hCd3NDUUFKQUFrQWdCa0VGVFFSQUlBWkJBV3NPQlFZRkJBTUNBUXNnQlVVTkJpQUJLQUlzSVFKQkFDRUJBMEFnQUNBQlFRSjBJZ05xSUFJZ0Eyb29BZ0EyQWdBZ0FVRUJhaUlCSUFWSERRQUxEQVlMQWtBZ0NRUkFJQUVvQWhRaEFrRUFJUVlNQVFzZ0JVVU5CZ05BREFBQUN3QUxBMEJCQUNFRUlBWWdCVThOQmdOQVFRQWhCd0pBSUFJZ0JFRUNkR29pQXlnQ0FDSUJSUTBBSUFFaEJ5QUZJQVpORFFCQkFDRUJRUUFnQlNBR2F5SUhJQWNnQlVzYklRZ0RRQ0FBSUFFZ0JtcEJBblJxSUFRMkFnQWdBVUVCYWlJQklBTW9BZ0FpQjA4TkFTQUJJQWhIRFFBTEN5QUVRUUZxSWdRZ0NVbEJBQ0FHSUFkcUlnWWdCVWtiRFFBTElBWWdCVWtOQUFzTUJRc2dBMFVOQkNBRVJRMEVRUUVnQVNnQ0lDSUpheUVJUVFBaEJVRUFJUUlEUUVFQUlRRWdCU0VHQTBBZ0FDQUJJQU5zSUFKcVFRSjBhaUFKSUFnZ0JpQUhTUnMyQWdBZ0JrRUJhaUVHSUFGQkFXb2lBU0FFUncwQUN5QUVJQVZxSVFVZ0FrRUJhaUlDSUFOSERRQUxEQVFMSUFWRkRRTkJBU0FCS0FJZ0lnSnJJUU5CQUNFQkEwQWdBQ0FCUVFKMGFpQUNJQU1nQVNBSFNSczJBZ0FnQVVFQmFpSUJJQVZIRFFBTERBTUxJQUVvQWlBaEFpQUZCRUJCQUNFQkEwQWdBQ0FCUVFKMGFrRUJOZ0lBSUFGQkFXb2lBU0FGUncwQUN3c2dDMFVOQWlBRFFYOXFJUThnQkVGL2FpRVFJQUpCZjJvaEJrRUJJQUpCQVhRaUFXc2hCU0FCUVg5cUlRa2dCQ0FDYTBFQmRpSUtJUXdnQXlBQ2EwRUJkaUlOSVFRZ0NpRUlJQTBoQVVFQUlRY0RRQ0FBSUFNZ0NHd2dBV3BCQW5ScUlnNG9BZ0FpRVVFQlJnUkFJQTVCQURZQ0FBc2dFVUVCUmlFT0FrQUNRQ0FHUVg5SERRQWdBU0FFUncwQVFRQWhCaUFKSVFJZ0JFRUJJQVJCQVVvYlFYOXFJZ0VoQkF3QkN3SkFJQVpCQVVjTkFDQUJJQTFIRFFCQkFDRUdJQVVoQWlBTlFRRnFJZ0VnRHlBQklBOUlHeUlCSVEwTUFRc0NRQ0FDUVg5SERRQWdDQ0FNUncwQVFRQWhBaUFGSVFZZ0RFRUJJQXhCQVVvYlFYOXFJZ2doREF3QkN3SkFJQUpCQVVjTkFDQUlJQXBIRFFCQkFDRUNJQWtoQmlBS1FRRnFJZ2dnRUNBSUlCQklHeUlJSVFvTUFRc2dBaUFJYWlFSUlBRWdCbW9oQVFzZ0J5QU9haUlISUF0SkRRQUxEQUlMSUFFb0Fod2hCeUFCS0FJWUlRZ2dCUVJBSUFsQmYyb2hBa0VBSVFFRFFDQUFJQUZCQW5ScUlBSTJBZ0FnQVVFQmFpSUJJQVZIRFFBTElBSkZEUUlMSUFsQmZtb2hBUU5BQWtBZ0NDQUJJZ1JCQW5RaUFXb29BZ0FpQmlBRGJpSUNJQUVnQjJvb0FnQWlBU0FEYmlJRlN3MEFJQVlnQWlBRGJHc2lCaUFCSUFNZ0JXeHJJZ2xMQkVBRFFDQUNRUUZxSWdJZ0JVME5BQXdDQUFzQUN3TkFJQUlnQTJ3aENpQUdJUUVEUUNBQUlBRWdDbXBCQW5ScUlBUTJBZ0FnQVVFQmFpSUJJQWxORFFBTElBSkJBV29pQWlBRlRRMEFDd3NnQkVGL2FpRUJJQVFOQUFzTUFRc2dCVVVOQUVFQUlRRURRQ0FBSUFGQkFuUnFJQUVnQTI0aUFpQUpiRUVCZGlBQklBSWdBMnhyYWlBSmNEWUNBQ0FCUVFGcUlnRWdCVWNOQUFzTEM4UUJBUVYvSUFBb0FxZ0pJUVFDUUNBQVFiQUphaWdDQUNJQ1JRMEFJQUpCZjJvaUFpQUJUUVJBSUFJaEFRd0JDeUFBS0FLOENTRUZBMEFDUUNBRklBSkIyQUZzYWlnQ0JDQUVSdzBBSUFOQkFXb2lBeUFBS0FJUUtBSTBJZ1pCQ2lBR1FRcExHMGtOQUNBQ0lRRU1BZ3NnQWtGL2FpSUNJQUZMRFFBTEN3TkFBa0FnQUNnQ3ZBa2dBVUhZQVd4cUlnSW9BZ1FnQkVjTkFDQUNLQUxFQVNJRFJRMEFJQUlnQTBGL2FqWUN4QUVnQUNnQ2xBa2dBQ2dDbUFrZ0FSQWVJZ0VOQVFzTEM3MEVBZ3QvQVg0akFFSEFBMnNpQlNRQUlBTW9BZ0FoQnlBQktBS3dHaUVJSUFWQkFEWUNEQ0FCUWJBSmFrRUFOZ0lBSUFFZ0FTZ0NxQWxCQVdvMkFxZ0pJQVVnQXlnQ01DQUJLQUlNS0FJMGFqWUNDQ0FCUWNRSmFpRU5JQWhCREdvaERnSkFBMEFnQVNnQ3ZBa2hCQUpBSUFNb0FpUU5BQ0FFSUFkQjJBRnNhaWdDeEFGRkRRQkJBU0VFREFJTElBTXBBalFoRHlBREtBSThJUXNnQVNnQ3FBa2hEQ0FFSUFkQjJBRnNJZ1pxSWdRZ0FTZ0NEQ2dDT0RZQ0dDQUVJQXMyQWhBZ0JDQVBOd0lJSUFRZ0REWUNCQUpBSUFNb0FnUWlCRUVDUmcwQUlBa05BQ0FFUVFkR0RRQWdBQ0FGUVF4cUVBSWlCQTBDSUFVb0Fnd2lCQ0FCS0FLWUNTQUhhMHNFUUVFQklRUU1Bd3NnQkVVRVFFRUFJUWtNQVFzZ0RrRUFRYVFCRUFjYUlBaEJBRFlDQUVFQklRa0xBa0FnQlNnQ0RDSUVCRUFnQlNBRVFYOXFOZ0lNREFFTFFRQWhDU0FBSUFnZ0FTZ0N2QWtnQm1vZ0F5Z0NCQ0FES0FJc0VGRWlCQTBDQ3lBQktBSzhDU0FHYWlBSUlBSWdEU0FGUVFocUlBY2dBU2dDRENnQ1FDQUZRUkJxRUZBaUJBMEJJQUVvQXJ3SklBWnFLQUxFQVNFTElBQVFMaUVFSUFVb0Fnd2hCZ0pBSUFNb0FnUkJmbW9pREVFRlN3MEFBa0FnREVFQmF3NEVBUUVCQVFBTElBRWdCellDc0FrTElBUWdCbkloQmtFQklRUWdBU2dDbEFrZ0FTZ0NtQWtnQnhBZUlnZEZRUUFnQmhzTkFTQUtJQXRCQVVacUlRb2dCZzBBQ3lBQlFhd0phaWdDQUNBS2FpSUFJQUVvQXBnSlN3MEFJQUVnQURZQ3JBbEJBQ0VFQ3lBRlFjQURhaVFBSUFRTDVnSUJCMzlCQVNFQ0FrQWdBQ2dDQUNBQktBSUFSdzBBSUFBb0FnUWdBU2dDQkVjTkFDQUFLQUlNSUFFb0FneEhEUUFnQUNnQ0VDSURJQUVvQWhCSERRQWdBQ2dDTENBQktBSXNSdzBBSUFBb0FqQWdBU2dDTUVjTkFDQUFLQUkwSUFFb0FqUkhEUUFnQUNnQ09DQUJLQUk0UncwQUlBQW9BandpQlNBQktBSThSdzBBSUFBb0FsQWdBU2dDVUVjTkFBSkFJQU5CQVVzTkFDQURRUUZyUlFSQUlBQW9BaGdnQVNnQ0dFY05BaUFBS0FJY0lBRW9BaHhIRFFJZ0FDZ0NJQ0FCS0FJZ1J3MENJQUFvQWlRaUJDQUJLQUlrUncwQ0lBUkZEUUVnQVNnQ0tDRUdJQUFvQWlnaEIwRUFJUU1EUUNBSElBTkJBblFpQ0dvb0FnQWdCaUFJYWlnQ0FFY05BeUFFSUFOQkFXb2lBMGNOQUFzTUFRc2dBQ2dDRkNBQktBSVVSdzBCQ3lBRkJFQWdBQ2dDUUNBQktBSkFSdzBCSUFBb0FrUWdBU2dDUkVjTkFTQUFLQUpJSUFFb0FraEhEUUVnQUNnQ1RDQUJLQUpNUncwQkMwRUFJUUlMSUFJTC93a0JCbjhqQUVFUWF5SUVKQUFnQVVFQVFkd0FFQWNoQXdKQUlBQkJDQkFESWdGQmYwWUVRRUVCSVFFTUFRc2dBeUFCTmdJQUlBQkJBUkFER2lBQVFRRVFBeG9nQUVFQkVBTkJmMFlFUUVFQklRRU1BUXNnQUVFRkVBTkJmMFlFUUVFQklRRU1BUXNnQUVFSUVBTWlBVUYvUmdSQVFRRWhBUXdCQ3lBRElBRTJBZ1FnQUNBRFFRaHFFQUlpQVEwQUlBTW9BZ2hCSDBzRVFFRUJJUUVNQVFzZ0FDQUVRUXhxRUFJaUFRMEFRUUVoQVNBRUtBSU1JZ0pCREVzTkFDQURRUUVnQWtFRWFuUTJBZ3dnQUNBRVFReHFFQUlpQVEwQVFRRWhBU0FFS0FJTUlnSkJBa3NOQUNBRElBSTJBaEFDUUNBQ1FRRkxEUUFnQWtFQmF3UkFJQUFnQkVFTWFoQUNJZ0VOQWtFQklRRWdCQ2dDRENJQ1FReExEUUlnQTBFQklBSkJCR3AwTmdJVURBRUxJQUJCQVJBRElnSkJmMFlOQVNBRElBSkJBVVkyQWhnZ0FDQURRUnhxRUFVaUFRMEJJQUFnQTBFZ2FoQUZJZ0VOQVNBQUlBTkJKR29RQWlJQkRRRkJBU0VCSUFNb0FpUWlBa0gvQVVzTkFTQUNCRUFnQXlBQ1FRSjBFQW9pQVRZQ0tDQUJSUVJBUWYvL0F5RUJEQU1MSUFBZ0FSQUZJZ0VOQWtFQklRSURRQ0FDSUFNb0FpUlBEUUlnQWtFQ2RDRUJJQUpCQVdvaEFpQUFJQUVnQXlnQ0tHb1FCU0lCUlEwQUN3d0NDeUFEUVFBMkFpZ0xJQUFnQTBFc2FoQUNJZ0VOQUVFQklRRWdBeWdDTEVFUVN3MEFJQUJCQVJBRElnSkJmMFlOQUNBRElBSkJBVVkyQWpBZ0FDQUVRUXhxRUFJaUFRMEFJQU1nQkNnQ0RFRUJhallDTkNBQUlBUkJER29RQWlJQkRRQkJBU0VCSUFNZ0JDZ0NERUVCYWpZQ09DQUFRUUVRQTBFQmFrRUNTUTBBSUFCQkFSQURRWDlHRFFBZ0FFRUJFQU1pQWtGL1JnMEFJQU1nQWtFQlJpSUJOZ0k4QWtBZ0FVVUVRQ0FES0FJNElRVWdBeWdDTkNFR0RBRUxJQUFnQTBGQWF4QUNJZ0VOQVNBQUlBTkJ4QUJxRUFJaUFRMEJJQUFnQTBISUFHb1FBaUlCRFFFZ0FDQURRY3dBYWhBQ0lnRU5BVUVCSVFFZ0F5Z0NRQ0FES0FKRVFYOXpJQU1vQWpRaUJrRURkR3BLRFFFZ0F5Z0NTQ0FES0FKTVFYOXpJQU1vQWpnaUJVRURkR3BLRFFFTEFrQUNRQUpBQWtBZ0F5Z0NCRUYyYWlJSFFTbExEUUJCNHdBaEFVR0FwQWtoQWdKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQWdCMEVCYXc0cEFBRUJDd3NMQ3dzTEFRSURDd3NMQ3dzTEN3TUVCUXNMQ3dzTEN3c0dCZ2NMQ3dzTEN3c0xDQWtLQzBHTUF5RUJRWUNNRlNFQ0RBa0xRWXdESVFGQmdOZzNJUUlNQ0F0Qm1BWWhBVUdBc084QUlRSU1Cd3RCMUF3aEFVR0E3TDBCSVFJTUJndEJrQndoQVVHQThLVURJUUlNQlF0QmdDZ2hBVUdBZ09BRElRSU1CQXRCZ01BQUlRRkJnSUNBQmlFQ0RBTUxRWURFQUNFQlFZQ0FzQVloQWd3Q0MwSEFyQUVoQVVHQXdKc1VJUUlNQVF0QmdLQUNJUUZCZ0lEZ0lTRUNDeUFCSUFVZ0Jtd2lBVThOQVFzZ0JFSC8vLy8vQnpZQ0RDQURLQUlzSVFJTUFRc2dCQ0FDSUFGQmdBTnNiaUlCUVJBZ0FVRVFTUnNpQVRZQ0RDQURLQUlzSWdJZ0FVME5BUXNnQkNBQ05nSU1JQUloQVFzZ0F5QUJOZ0pZUVFFaEFTQUFRUUVRQXlJQ1FYOUdEUUFnQXlBQ1FRRkdOZ0pRQWtBZ0FrRUJSdzBBSUFOQnVBY1FDaUlCTmdKVUlBRkZCRUJCLy84RElRRU1BZ3NnQUNBQkVDd2lBUTBCSUFNb0FsUWlBaWdDbUFkRkRRQkJBU0VCSUFJb0FyQUhJQUlvQXJRSElnSkxEUUVnQWlBREtBSXNTUTBCSUFJZ0F5Z0NXRXNOQVNBRElBSkJBU0FDR3pZQ1dBc2dBQkFmUVFBaEFRc2dCRUVRYWlRQUlBRUxqUVFCRG44Z0FRSi9Ba0FnQUM4QklDSUhEUUFnQUM4QkhBMEFRUUFNQVF0QkFnczJBaUFnQVFKL0FrQWdBQzhCSWlJQ0RRQWdBQzhCSGcwQVFRQU1BUXRCQWdzMkFpZ2dBUUovQWtBZ0FDOEJLQ0lERFFBZ0FDOEJKQTBBUVFBTUFRdEJBZ3MyQWpBZ0FRSi9Ba0FnQUM4QktpSUlEUUFnQUM4QkpnMEFRUUFNQVF0QkFnczJBamdnQVNBSElBQXZBU3dpQ1hKQkFFZEJBWFEyQWtBZ0FTQUNJQUF2QVM0aUJISkJBRWRCQVhRMkFrZ2dBU0FESUFBdkFUUWlCWEpCQUVkQkFYUTJBbEFnQVNBSUlBQXZBVFlpQ25KQkFFZEJBWFEyQWxnZ0FTQUFMd0V3SWcwZ0NYSkJBRWRCQVhRMkFtQWdBU0FBTHdFeUlnc2dCSEpCQUVkQkFYUTJBbWdnQVNBQUx3RTRJZ3dnQlhKQkFFZEJBWFEyQW5BZ0FTQUFMd0U2SWc0Z0NuSkJBRWRCQVhRMkFuaEJBaUVHSUFFZ0FDOEJIaUlQQkg5QkFnVWdBQzhCSEVFQVIwRUJkQXMyQWd3Z0FTQVBJQUF2QVNRaUJuSkJBRWRCQVhRMkFoUWdBQzhCSmlFQUlBRWdEQ0FPY2tFQVIwRUJkRFlDZkNBQklBc2dESEpCQUVkQkFYUTJBblFnQVNBTElBMXlRUUJIUVFGME5nSnNJQUVnQlNBS2NrRUFSMEVCZERZQ1hDQUJJQVFnQlhKQkFFZEJBWFEyQWxRZ0FTQUVJQWx5UVFCSFFRRjBOZ0pNSUFFZ0F5QUlja0VBUjBFQmREWUNQQ0FCSUFJZ0EzSkJBRWRCQVhRMkFqUWdBU0FDSUFkeVFRQkhRUUYwTmdJc0lBRWdBQ0FHY2tFQVIwRUJkRFlDSEF2TUJnRUxmeU1BUVlBT2F5SU9KQUFnQmtFRmFpRUlBa0FDUUNBQ1FRQklEUUFnQTBFQVNBMEFJQUlnQ0dvZ0JFc05BQ0FIUVFWcUlnb2dBMm9nQlVzTkFDQUVJUWdnQXlFSkRBRUxJQUFnRGtIQUNtb2dBaUFESUFRZ0JTQUlJQWRCQldvaUNpQUlFQXdnRGtIQUNtb2hBRUVBSVFJTEFrQWdDa1VOQUNBR1FRSjJJaEJGRFFBZ0NDQUdheUVSSUFBZ0NDQUpiQ0FDYW1wQkJXb2hBaUFPSVFBRFFDQUNRWDlxTFFBQUlRZ2dBa0YrYWkwQUFDRURJQUpCZldvdEFBQWhCU0FDUVh4cUxRQUFJUVFnQWtGN2FpMEFBQ0VNSUJBaERRTkFJQUFnQWkwQUFDSUpJQXdnQkNBSWFpSUxheUFESUFWcVFSUnNhaUFMUVFKMGEybzJBZ0FnQUNBQ0xRQUJJZ3NnQXlBSWFrRVViQ0FFYWlBRklBbHFJZ1JySUFSQkFuUnJhallDQkNBQUlBSXRBQUlpRHlBSUlBbHFRUlJzSUFWcUlBTWdDMm9pQkdzZ0JFRUNkR3RxTmdJSUlBQWdBaTBBQXlJU0lBa2dDMnBCRkd3Z0Eyb2dDQ0FQYWlJRGF5QURRUUowYTJvMkFnd2dBRUVRYWlFQUlBSkJCR29oQWlBSUlRd2dDU0VFSUFzaEJTQVBJUU1nRWlFSUlBMUJmMm9pRFEwQUN5QUNJQkZxSVFJZ0NrRi9haUlLRFFBTEN3SkFJQWRCQW5ZaUIwVU5BQ0FHUlEwQVFjQUFJQVpySVE4Z0RpQUdRUUowYWlJSUlBWkJGR3hxSVFKQkFDQUdheUlRUVFOMElSSWdCa0VEZENFSklBWkJBMnhCQW5RaEN3TkFJQVloQkFOQUlBRWdDQ0FKYWlnQ0FDSUFJQUlnQ1dvb0FnQWdBaUFHUVFKMElnMXFLQUlBSWdvZ0FpQVNhaWdDQUNJRGFpSUZheUFGUVFKMGEyb2dBaWdDQUNJTUlBSWdFRUVDZENJUmFpZ0NBQ0lGYWtFVWJHcEJnQVJxUVFwMVFiQXVhaTBBQURvQU1DQUJJQWdnRFdvb0FnQWlEU0FLSUFNZ0JXcEJGR3hxSUFBZ0RHb2lDbXNnQ2tFQ2RHdHFRWUFFYWtFS2RVR3dMbW90QUFBNkFDQWdBU0FJS0FJQUlnb2dEQ0FBSUFOcVFSUnNhaUFGSUExcUlneHJJQXhCQW5ScmFrR0FCR3BCQ25WQnNDNXFMUUFBT2dBUUlBRWdDQ0FSYWlnQ0FDQUZJQUFnRFdwQkZHeHFJQU1nQ21vaUFHc2dBRUVDZEd0cVFZQUVha0VLZFVHd0xtb3RBQUE2QUFBZ0NFRUVhaUVJSUFGQkFXb2hBU0FDUVFScUlRSWdCRUYvYWlJRURRQUxJQUVnRDJvaEFTQUNJQXRxSVFJZ0NDQUxhaUVJSUFkQmYyb2lCdzBBQ3dzZ0RrR0FEbW9rQUF2bEF3RUpmeU1BUWNBRGF5SUtKQUFnQmtFRmFpRUlBa0FDUUNBQ1FRQklEUUFnQXlBSGFpQUZTdzBBSUFOQkFFZ05BQ0FDSUFocUlBUkxEUUFnQkNFSUlBTWhDUXdCQ3lBQUlBb2dBaUFESUFRZ0JTQUlJQWNnQ0JBTUlBb2hBRUVBSVFJTEFrQWdCMFVOQUNBR1FRSjJJZzFGRFFCQkVDQUdheUVPSUFnZ0Jtc2hEeUFBSUFnZ0NXd2dBbXBxUVFWcUlRSURRQ0FDUVg5cUxRQUFJUWdnQWtGK2FpMEFBQ0VHSUFKQmZXb3RBQUFoQUNBQ1FYeHFMUUFBSVFVZ0FrRjdhaTBBQUNFSklBMGhDd05BSUFFZ0FpMEFBQ0lESUFrZ0JTQUlhaUlFYXlBQUlBWnFRUlJzYWlBRVFRSjBhMnBCRUdwQkJYVkJzQzVxTFFBQU9nQUFJQUVnQWkwQUFTSUVJQVVnQmlBSWFrRVViR29nQUNBRGFpSUZheUFGUVFKMGEycEJFR3BCQlhWQnNDNXFMUUFBT2dBQklBRWdBaTBBQWlJTUlBQWdBeUFJYWtFVWJHb2dCQ0FHYWlJQWF5QUFRUUowYTJwQkVHcEJCWFZCc0M1cUxRQUFPZ0FDSUFFZ0FpMEFBeUlRSUFZZ0F5QUVha0VVYkdvZ0NDQU1haUlBYXlBQVFRSjBhMnBCRUdwQkJYVkJzQzVxTFFBQU9nQURJQUZCQkdvaEFTQUNRUVJxSVFJZ0NDRUpJQU1oQlNBRUlRQWdEQ0VHSUJBaENDQUxRWDlxSWdzTkFBc2dBU0FPYWlFQklBSWdEMm9oQWlBSFFYOXFJZ2NOQUFzTElBcEJ3QU5xSkFBTDlRTUJDMzhqQUVIQUEyc2lDeVFBQWtBQ1FDQUNRUUJJRFFBZ0EwRUFTQTBBSUFJZ0Jtb2dCRXNOQUNBRElBZHFRUVZxSUFWTERRQWdBeUVJREFFTElBQWdDeUFDSUFNZ0JDQUZJQVlnQjBFRmFpQUdFQXdnQ3lFQUlBWWhCRUVBSVFJTEFrQWdCMEVDZGlJTVJRMEFJQVpGRFFCQndBQWdCbXNoRVNBRVFRRjBJUTBnQkVFQ2RDQUdheUVPUVFBZ0JHc2lEMEVCZENFU0lBQWdCQ0FJYkNBQ2Ftb2dCR29pQnlBRVFRVnNhaUVDQTBBZ0JpRUFBMEFnQVNBSElBMXFMUUFBSWdNZ0FpQU5haTBBQUNBQ0lBUnFMUUFBSWdrZ0FpQVNhaTBBQUNJRmFpSUlheUFJUVFKMGEyb2dBaTBBQUNJS0lBSWdEMm90QUFBaUNHcEJGR3hxUVJCcVFRVjFRYkF1YWkwQUFEb0FNQ0FCSUFRZ0Iyb3RBQUFpRUNBSklBVWdDR3BCRkd4cUlBTWdDbW9pQ1dzZ0NVRUNkR3RxUVJCcVFRVjFRYkF1YWkwQUFEb0FJQ0FCSUFjdEFBQWlDU0FLSUFNZ0JXcEJGR3hxSUFnZ0VHb2lDbXNnQ2tFQ2RHdHFRUkJxUVFWMVFiQXVhaTBBQURvQUVDQUJJQWNnRDJvdEFBQWdDQ0FESUJCcVFSUnNhaUFGSUFscUlnTnJJQU5CQW5ScmFrRVFha0VGZFVHd0xtb3RBQUE2QUFBZ0IwRUJhaUVISUFGQkFXb2hBU0FDUVFGcUlRSWdBRUYvYWlJQURRQUxJQUVnRVdvaEFTQUNJQTVxSVFJZ0J5QU9haUVISUF4QmYyb2lEQTBBQ3dzZ0MwSEFBMm9rQUF1cUJnRU5meU1BUWJBQmF5SVJKQUFnQ0VFQmFpRUtBa0FDUUNBQ1FRQklEUUFnQTBFQVNBMEFJQUlnQ21vZ0JFc05BQ0FESUFscVFRRnFJQVZMRFFBZ0JTRU1JQVFoQ2lBRElROE1BUXNnQUNBUklBSWdBeUFFSUFVZ0NpQUpRUUZxSWd3Z0NoQU1JQUFnQkNBRmJHb2dFU0FLSUF4c2FpQUNJQU1nQkNBRklBb2dEQ0FLRUF3Z0VTRUFRUUFoQWdzQ1FDQUpRUUYySWdWRkRRQWdDRUVCZGlJRVJRMEFRUkFnQ0dzaEUwRUlJQWRySVF0QkNDQUdheUVOSUFwQkFYUWlEaUFJYXlFVUlBQWdBbW9pRmlBS0lBOXNhaUVDSUFFaEFDQUZJUlVEUUNBQ0lBNXFMUUFBSUFkc0lBc2dBaUFLYWkwQUFDSURiR29oQ0NBRElBZHNJQXNnQWkwQUFHeHFJUWtnQkNFREEwQWdBa0VCYWlJUUlBNXFMUUFBSVJJZ0FDQUpJQTFzSUFvZ0VHb3RBQUFpQ1NBSGJDQUxJQUl0QUFGc2FpSVFJQVpzYWtFZ2FrRUdkam9BQUNBQUlBZ2dEV3dnQnlBU2JDQUpJQXRzYWlJSUlBWnNha0VnYWtFR2Rqb0FDQ0FDTFFBQ0lRa2dBa0VDYWlJQ0lBNXFMUUFBSVJJZ0FDQU5JQkJzSUFJZ0Ntb3RBQUFpRUNBSGJDQUpJQXRzYWlJSklBWnNha0VnYWtFR2Rqb0FBU0FBSUFnZ0RXd2dCeUFTYkNBTElCQnNhaUlJSUFac2FrRWdha0VHZGpvQUNTQUFRUUpxSVFBZ0EwRi9haUlERFFBTElBSWdGR29oQWlBQUlCTnFJUUFnRlVGL2FpSVZEUUFMSUFGQlFHc2hBQ0FXSUF3Z0Qyb2dDbXhxSVFJRFFDQUNJQTVxTFFBQUlBZHNJQXNnQWlBS2FpMEFBQ0lCYkdvaENDQUJJQWRzSUFzZ0FpMEFBR3hxSVFrZ0JDRURBMEFnQWtFQmFpSUJJQTVxTFFBQUlRd2dBQ0FKSUExc0lBRWdDbW90QUFBaUFTQUhiQ0FMSUFJdEFBRnNhaUlKSUFac2FrRWdha0VHZGpvQUFDQUFJQWdnRFd3Z0J5QU1iQ0FCSUF0c2FpSUJJQVpzYWtFZ2FrRUdkam9BQ0NBQ0xRQUNJUWdnQWtFQ2FpSUNJQTVxTFFBQUlRd2dBQ0FKSUExc0lBSWdDbW90QUFBaUR5QUhiQ0FJSUF0c2FpSUpJQVpzYWtFZ2FrRUdkam9BQVNBQUlBRWdEV3dnQnlBTWJDQUxJQTlzYWlJSUlBWnNha0VnYWtFR2Rqb0FDU0FBUVFKcUlRQWdBMEYvYWlJRERRQUxJQUlnRkdvaEFpQUFJQk5xSVFBZ0JVRi9haUlGRFFBTEN5QVJRYkFCYWlRQUMvOUVBVUYvSXdCQnNBRnJJZ01rQUNBQUtBSUlJZ1FFUUNBQUtBSUVJaDlCQTNRaEZpQUVJQjlzSWdSQkJuUWhPeUFFUVFoMElUd2dIMEVHZENFOUlCOUJNR3doUGlBZlFRVjBJU1VnSDBGUWJDRXJRUUFnSDBFRWRDSWFheUlvUVFKMElUOGdLRUVCZENFc0lBTkJHR29oSWlBRFFReHlJU01EUUFKQUlBRW9BZ2dpQ1VFQlJnMEFBa0FDUUFKQUFrQWdBU2dDeUFFaUFrVUVRRUVCSVFZTUFRdEJCU0VHSUFsQkFrY05BRUVGUVFFZ0FTZ0NCQ0lKSUFJb0FnUkdHeUVHSUFFb0Fzd0JJZ1FOQVVFQUlRUU1Bd3NnQVNnQ3pBRWlCRVVFUUVFQUlRUU1Bd3NnQ1VFQ1J3MEJJQUVvQWdRaENRc2dDU0FFS0FJRVJ3MEJDeUFHUVFKeUlRWUxBbjhnQmtFQ2NTSXRCRUFDUUNBQktBSUFRUVZOQkVBZ0JDZ0NBRUVHU1EwQkN5QURRUVEyQWtBZ0EwRUVOZ0pJSUFOQkJEWUNPQ0FEUVFRMkFqQkJBUXdDQzBFQ0lROUJBaUVKQWtBZ0FTOEJIQTBBSUFRdkFUQU5BRUVCSVFrZ0FTZ0NkQ0FFS0FKOFJ3MEFJQUV1QVlRQklBUXVBYXdCYXlJRklBVkJIM1VpQldvZ0JYTkJBMHNOQUNBQkxnR0dBU0FFTGdHdUFXc2lDU0FKUVI5MUlnbHFJQWx6UVFOTElRa0xJQU1nQ1RZQ01BSkFJQUV2QVI0TkFDQUVMd0V5RFFCQkFTRVBJQUVvQW5RZ0JDZ0NmRWNOQUNBQkxnR0lBU0FFTGdHd0FXc2lCU0FGUVI5MUlnVnFJQVZ6UVFOTERRQWdBUzRCaWdFZ0JDNEJzZ0ZySWdVZ0JVRWZkU0lGYWlBRmMwRURTeUVQQ3lBRElBODJBamhCQWlFRlFRSWhDZ0pBSUFFdkFTUU5BQ0FFTHdFNERRQkJBU0VLSUFFb0FuZ2dCQ2dDZ0FGSERRQWdBUzRCbEFFZ0JDNEJ2QUZySWdnZ0NFRWZkU0lJYWlBSWMwRURTdzBBSUFFdUFaWUJJQVF1QWI0QmF5SUlJQWhCSDNVaUNHb2dDSE5CQTBzaENnc2dBeUFLTmdKQUFrQWdBUzhCSmcwQUlBUXZBVG9OQUVFQklRVWdBU2dDZUNBRUtBS0FBVWNOQUNBQkxnR1lBU0FFTGdIQUFXc2lDQ0FJUVI5MUlnaHFJQWh6UVFOTERRQWdBUzRCbWdFZ0JDNEJ3Z0ZySWdRZ0JFRWZkU0lFYWlBRWMwRURTeUVGQ3lBRElBVTJBa2dnQ1NBUGNpQUtjaUFGY2tFQVJ3d0JDeUFEUVFBMkFrQWdBMEVBTmdKSUlBTkJBRFlDT0NBRFFRQTJBakJCQUFzaENRSkFBa0FDUUFKQUlBWkJCSEVpTGdSQUFrQWdBU2dDQUNJR1FRVk5CRUFnQWlnQ0FFRUdTUTBCQ3lBRFFRUTJBblFnQTBFRU5nS1VBU0FEUVFRMkFsUWdBMEVFTmdJMFFRRWhDUXdDQzBFQ0lROUJBaUVFQWtBZ0FTOEJIQTBBSUFJdkFTWU5BRUVCSVFRZ0FTZ0NkQ0FDS0FKNFJ3MEFJQUV1QVlRQklBSXVBWmdCYXlJRklBVkJIM1VpQldvZ0JYTkJBMHNOQUNBQkxnR0dBU0FDTGdHYUFXc2lCQ0FFUVI5MUlnUnFJQVJ6UVFOTElRUUxJQU1nQkRZQ05BSkFJQUV2QVNBTkFDQUNMd0VxRFFCQkFTRVBJQUVvQW5RZ0FpZ0NlRWNOQUNBQkxnR01BU0FDTGdHZ0FXc2lCU0FGUVI5MUlnVnFJQVZ6UVFOTERRQWdBUzRCamdFZ0FpNEJvZ0ZySWdVZ0JVRWZkU0lGYWlBRmMwRURTeUVQQ3lBRElBODJBbFJCQWlFRlFRSWhDZ0pBSUFFdkFTd05BQ0FDTHdFMkRRQkJBU0VLSUFFb0Fud2dBaWdDZ0FGSERRQWdBUzRCcEFFZ0FpNEJ1QUZySWdnZ0NFRWZkU0lJYWlBSWMwRURTdzBBSUFFdUFhWUJJQUl1QWJvQmF5SUlJQWhCSDNVaUNHb2dDSE5CQTBzaENnc2dBeUFLTmdKMEFrQWdBUzhCTUEwQUlBSXZBVG9OQUVFQklRVWdBU2dDZkNBQ0tBS0FBVWNOQUNBQkxnR3NBU0FDTGdIQUFXc2lDQ0FJUVI5MUlnaHFJQWh6UVFOTERRQWdBUzRCcmdFZ0FpNEJ3Z0ZySWdVZ0JVRWZkU0lGYWlBRmMwRURTeUVGQ3lBRElBVTJBcFFCSUFsRkRRSkJBU0VKREFNTElBTkJBRFlDZENBRFFRQTJBcFFCSUFOQkFEWUNWQ0FEUVFBMkFqUWdBU2dDQUNFR0N5QUdRUVpKRFFFZ0EwRUROZ0tnQVNBRFFvT0FnSUF3TndLa0FTQURRUU0yQXBBQklBTkJBellDY0NBRFFRTTJBcXdCSUFOQ2c0Q0FnREEzQTVnQklBTkNnNENBZ0RBM0E0Z0JJQU5DZzRDQWdEQTNBNEFCSUFOQ2c0Q0FnREEzQTNnZ0EwS0RnSUNBTURjRGFDQURRb09BZ0lBd053TmdJQU5DZzRDQWdEQTNBMWdnQTBLRGdJQ0FNRGNDVENBRFFRTTJBa1FnQTBFRE5nSThEQUlMSUFRZ0QzSWdDbklnQlhKQkFFY2hDUXNDUUFKL0lBWkJBMDBFUUNBR1FRSjBRWXcxYWlnQ0FBd0JDMEVFQzBFQlJnUkFJQUVnQTBFd2FoQkVJQU1vQXF3QklRY2dBeWdDcEFFaERpQURLQUtjQVNFUUlBTW9Bb3dCSVJrZ0F5Z0NoQUVoQmlBREtBSjhJUmNnQXlnQ2JDRUlJQU1vQW1RaEJDQURLQUpjSVJRZ0F5Z0NUQ0VNSUFNb0FrUWhBaUFES0FJOElSRWdBeWdDcUFFaEhDQURLQUtnQVNFbUlBTW9BcGdCSVEwZ0F5Z0NrQUVoSFNBREtBS0lBU0VTSUFNb0FvQUJJUlVnQXlnQ2VDRWJJQU1vQW5BaEV5QURLQUpvSVFvZ0F5Z0NZQ0VQSUFNb0FsZ2hCU0FES0FKUUlTY01BUXNnQXdKL0FrQWdBd0ovQWtBQ1FDQUJLQUlBUVg1cUlnUkJBVTBFUUNBRVFRRnJCRUFnQXdKL0FrQWdBUzhCSUNJRURRQWdBUzhCSEEwQVFRQU1BUXRCQWdzaUp6WUNVQ0FEQW44Q1FDQUJMd0VpSWdjTkFDQUJMd0VlRFFCQkFBd0JDMEVDQ3lJRk5nSllJQU1DZndKQUlBRXZBU2dpQmcwQUlBRXZBU1FOQUVFQURBRUxRUUlMSWc4MkFtQWdBd0ovQWtBZ0FTOEJLaUlPRFFBZ0FTOEJKZzBBUVFBTUFRdEJBZ3NpQ2pZQ2FDQURBbjhDUUNBQkx3RXdJaDROQUNBQkx3RXNEUUJCQUF3QkMwRUNDeUlkTmdLUUFTQURBbjhDUUNBQkx3RXlJaEFOQUNBQkx3RXVEUUJCQUF3QkMwRUNDeUlOTmdLWUFTQURBbjhDUUNBQkx3RTRJZ3NOQUNBQkx3RTBEUUJCQUF3QkMwRUNDeUltTmdLZ0FTQURBbjhDUUNBQkx3RTZJaGdOQUNBQkx3RTJEUUJCQUF3QkMwRUNDeUljTmdLb0FVRUNJUnRCQWlFVEFrQWdCQ0FCTHdFc0loZHlEUUJCQVNFVElBRXVBYVFCSUFFdUFZd0JheUlDSUFKQkgzVWlBbW9nQW5OQkEwc05BQ0FCTGdHbUFTQUJMZ0dPQVdzaUFpQUNRUjkxSWdKcUlBSnpRUU5MRFFBZ0FTZ0NmQ0FCS0FKMFJ5RVRDeUFESUJNMkFuQUNRQ0FISUFFdkFTNGlJSElOQUVFQklSc2dBUzRCcUFFZ0FTNEJrQUZySWdJZ0FrRWZkU0lDYWlBQ2MwRURTdzBBSUFFdUFhb0JJQUV1QVpJQmF5SUNJQUpCSDNVaUFtb2dBbk5CQTBzTkFDQUJLQUo4SUFFb0FuUkhJUnNMSUFNZ0d6WUNlRUVDSVJKQkFpRVZBa0FnQmlBQkx3RTBJaGx5RFFCQkFTRVZJQUV1QWJRQklBRXVBWndCYXlJQ0lBSkJIM1VpQW1vZ0FuTkJBMHNOQUNBQkxnRzJBU0FCTGdHZUFXc2lBaUFDUVI5MUlnSnFJQUp6UVFOTERRQWdBU2dDZ0FFZ0FTZ0NlRWNoRlFzZ0F5QVZOZ0tBQVFKQUlBNGdBUzhCTmlJaGNnMEFRUUVoRWlBQkxnRzRBU0FCTGdHZ0FXc2lBaUFDUVI5MUlnSnFJQUp6UVFOTERRQWdBUzRCdWdFZ0FTNEJvZ0ZySWdJZ0FrRWZkU0lDYWlBQ2MwRURTdzBBSUFFb0FvQUJJQUVvQW5oSElSSUxJQU1nRWpZQ2lBRWdBUzhCSGcwQ0lBRXZBUndFUUVFQ0lSRWdBMEVDTmdJOElBRXZBU1FpQ0EwR1FRQWhERUVBREFjTFFRQWhFU0FEUVFBMkFqeEJBQ0VNUVFBZ0FTOEJKQ0lJUlEwR0dnd0ZDeUFEQW44Q1FDQUJMd0VnSWdJTkFDQUJMd0VjRFFCQkFBd0JDMEVDQ3lJbk5nSlFJQU1DZndKQUlBRXZBU0lpQmcwQUlBRXZBUjROQUVFQURBRUxRUUlMSWdVMkFsZ2dBd0ovQWtBZ0FTOEJLQ0lPRFFBZ0FTOEJKQTBBUVFBTUFRdEJBZ3NpRHpZQ1lDQURBbjhDUUNBQkx3RXFJZ2dOQUNBQkx3RW1EUUJCQUF3QkMwRUNDeUlLTmdKb0lBTWdBaUFCTHdFc0loZHlRUUJIUVFGMEloTTJBbkFnQXlBR0lBRXZBUzRpQzNKQkFFZEJBWFFpR3pZQ2VDQURJQTRnQVM4Qk5DSWVja0VBUjBFQmRDSVZOZ0tBQVNBRElBZ2dBUzhCTmlJWmNrRUFSMEVCZENJU05nS0lBU0FESUFFdkFUQWlFQ0FYY2tFQVIwRUJkQ0lkTmdLUUFTQURJQUV2QVRJaUlDQUxja0VBUjBFQmRDSU5OZ0tZQVNBRElBRXZBVGdpSVNBZWNrRUFSMEVCZENJbU5nS2dBU0FESUFFdkFUb2lCeUFaY2tFQVIwRUJkQ0ljTmdLb0FTQURBbjhDUUNBQkx3RWVJaVFOQUNBQkx3RWNEUUJCQUF3QkMwRUNDeUlSTmdJOElBRXZBU1lFUUNBQkx3RWtJUmdNQXdzZ0FTOEJKQ0lZRFFKQkFDRVlRUUFNQXdzZ0FTNEJoZ0VoRkNBQkxnR09BU0VFUVFJaEJTQURBbjlCQWlBQkx3RWNJaEVnQVM4QklDSXZjZzBBR2tFQklBRXVBWXdCSUFFdUFZUUJheUlHSUFaQkgzVWlCbW9nQm5OQkEwc05BQm9nQkNBVWF5SUdJQVpCSDNVaUJtb2dCbk5CQTBzTElpYzJBbEFnQVM0QmlnRWhDQ0FCTGdHU0FTRUdBa0FnQVM4QkhpSXdJQUV2QVNJaUVISU5BRUVCSVFVZ0FTNEJrQUVnQVM0QmlBRnJJZ0lnQWtFZmRTSUNhaUFDYzBFRFN3MEFJQVlnQ0dzaUJTQUZRUjkxSWdWcUlBVnpRUU5MSVFVTElBTWdCVFlDV0NBQkxnR1dBU0VNSUFFdUFaNEJJUWRCQWlFS0lBTUNmMEVDSUFFdkFTUWlNU0FCTHdFb0loZHlEUUFhUVFFZ0FTNEJuQUVnQVM0QmxBRnJJZ0lnQWtFZmRTSUNhaUFDYzBFRFN3MEFHaUFISUF4cklnSWdBa0VmZFNJQ2FpQUNjMEVEU3dzaUR6WUNZQ0FCTGdHYUFTRXlJQUV1QWFJQklRc0NRQ0FCTHdFbUlrQWdBUzhCS2lJemNnMEFRUUVoQ2lBQkxnR2dBU0FCTGdHWUFXc2lBaUFDUVI5MUlnSnFJQUp6UVFOTERRQWdDeUF5YXlJQ0lBSkJIM1VpQW1vZ0FuTkJBMHNoQ2dzZ0F5QUtOZ0pvSUFFdUFhWUJJUjVCQWlFYlFRSWhFd0pBSUM4Z0FTOEJMQ0kwY2cwQVFRRWhFeUFCTGdHa0FTQUJMZ0dNQVdzaUFpQUNRUjkxSWdKcUlBSnpRUU5MRFFBZ0hpQUVheUlDSUFKQkgzVWlBbW9nQW5OQkEwc05BQ0FCS0FKOElBRW9BblJISVJNTElBTWdFellDY0NBQkxnR3FBU0VPQWtBZ0VDQUJMd0V1SWhoeURRQkJBU0ViSUFFdUFhZ0JJQUV1QVpBQmF5SUNJQUpCSDNVaUFtb2dBbk5CQTBzTkFDQU9JQVpySWdJZ0FrRWZkU0lDYWlBQ2MwRURTdzBBSUFFb0Fud2dBU2dDZEVjaEd3c2dBeUFiTmdKNElBRXVBYllCSVJsQkFpRVNRUUloRlFKQUlCY2dBUzhCTkNJZ2NnMEFRUUVoRlNBQkxnRzBBU0FCTGdHY0FXc2lBaUFDUVI5MUlnSnFJQUp6UVFOTERRQWdHU0FIYXlJQ0lBSkJIM1VpQW1vZ0FuTkJBMHNOQUNBQktBS0FBU0FCS0FKNFJ5RVZDeUFESUJVMkFvQUJJQUV1QWJvQklTRUNRQ0F6SUFFdkFUWWlOWElOQUVFQklSSWdBUzRCdUFFZ0FTNEJvQUZySWdJZ0FrRWZkU0lDYWlBQ2MwRURTdzBBSUNFZ0Myc2lBaUFDUVI5MUlnSnFJQUp6UVFOTERRQWdBU2dDZ0FFZ0FTZ0NlRWNoRWdzZ0F5QVNOZ0tJQVNBQkxnR3VBU0UyUVFJaERTQURBbjlCQWlBMElBRXZBVEFpUVhJTkFCcEJBU0FCTGdHc0FTQUJMZ0drQVdzaUFpQUNRUjkxSWdKcUlBSnpRUU5MRFFBYUlEWWdIbXNpQWlBQ1FSOTFJZ0pxSUFKelFRTkxDeUlkTmdLUUFTQUJMZ0d5QVNFa0FrQWdHQ0FCTHdFeUlqZHlEUUJCQVNFTklBRXVBYkFCSUFFdUFhZ0JheUlDSUFKQkgzVWlBbW9nQW5OQkEwc05BQ0FrSUE1cklnSWdBa0VmZFNJQ2FpQUNjMEVEU3lFTkN5QURJQTAyQXBnQklBRXVBYjRCSVNsQkFpRWNJQU1DZjBFQ0lDQWdBUzhCT0NJNGNnMEFHa0VCSUFFdUFid0JJQUV1QWJRQmF5SUNJQUpCSDNVaUFtb2dBbk5CQTBzTkFCb2dLU0FaYXlJQ0lBSkJIM1VpQW1vZ0FuTkJBMHNMSWlZMkFxQUJJQUV1QWNJQklUa0NRQ0ExSUFFdkFUb2lRbklOQUVFQklSd2dBUzRCd0FFZ0FTNEJ1QUZySWdJZ0FrRWZkU0lDYWlBQ2MwRURTdzBBSURrZ0lXc2lBaUFDUVI5MUlnSnFJQUp6UVFOTElSd0xJQU1nSERZQ3FBRkJBaUVDSUFNQ2YwRUNJQkVnTUhJTkFCcEJBU0FCTGdHSUFTQUJMZ0dFQVdzaUVTQVJRUjkxSWhGcUlCRnpRUU5MRFFBYUlBZ2dGR3NpRkNBVVFSOTFJaFJxSUJSelFRTkxDeUlSTmdJOEFrQWdNQ0F4Y2cwQVFRRWhBaUFCTGdHVUFTQUJMZ0dJQVdzaUZDQVVRUjkxSWhScUlCUnpRUU5MRFFBZ0RDQUlheUlJSUFoQkgzVWlDR29nQ0hOQkEwc05BQ0FCS0FKNElBRW9BblJISVFJTElBTWdBallDUkVFQ0lSUWdBd0ovUVFJZ01TQkFjZzBBR2tFQklBRXVBWmdCSUFFdUFaUUJheUlJSUFoQkgzVWlDR29nQ0hOQkEwc05BQm9nTWlBTWF5SUlJQWhCSDNVaUNHb2dDSE5CQTBzTElndzJBa3dDUUNBUUlDOXlEUUJCQVNFVUlBRXVBWkFCSUFFdUFZd0JheUlJSUFoQkgzVWlDR29nQ0hOQkEwc05BQ0FHSUFScklnUWdCRUVmZFNJRWFpQUVjMEVEU3lFVUN5QURJQlEyQWx4QkFpRUlRUUloQkFKQUlCQWdGM0lOQUVFQklRUWdBUzRCbkFFZ0FTNEJrQUZySWhBZ0VFRWZkU0lRYWlBUWMwRURTdzBBSUFjZ0Jtc2lCaUFHUVI5MUlnWnFJQVp6UVFOTERRQWdBU2dDZUNBQktBSjBSeUVFQ3lBRElBUTJBbVFDUUNBWElETnlEUUJCQVNFSUlBRXVBYUFCSUFFdUFad0JheUlHSUFaQkgzVWlCbW9nQm5OQkEwc05BQ0FMSUFkcklnWWdCa0VmZFNJR2FpQUdjMEVEU3lFSUN5QURJQWcyQW14QkFpRUdJQU1DZjBFQ0lCZ2dOSElOQUJwQkFTQUJMZ0dvQVNBQkxnR2tBV3NpQnlBSFFSOTFJZ2RxSUFkelFRTkxEUUFhSUE0Z0htc2lCeUFIUVI5MUlnZHFJQWR6UVFOTEN5SVhOZ0o4QWtBZ0dDQWdjZzBBUVFFaEJpQUJMZ0cwQVNBQkxnR29BV3NpQnlBSFFSOTFJZ2RxSUFkelFRTkxEUUFnR1NBT2F5SUhJQWRCSDNVaUIyb2dCM05CQTBzTkFDQUJLQUtBQVNBQktBSjhSeUVHQ3lBRElBWTJBb1FCUVFJaEVDQURBbjlCQWlBZ0lEVnlEUUFhUVFFZ0FTNEJ1QUVnQVM0QnRBRnJJZ2NnQjBFZmRTSUhhaUFIYzBFRFN3MEFHaUFoSUJscklnY2dCMEVmZFNJSGFpQUhjMEVEU3dzaUdUWUNqQUVDUUNBM0lFRnlEUUJCQVNFUUlBRXVBYkFCSUFFdUFhd0JheUlISUFkQkgzVWlCMm9nQjNOQkEwc05BQ0FrSURacklnY2dCMEVmZFNJSGFpQUhjMEVEU3lFUUN5QURJQkEyQXB3QlFRSWhCMEVDSVE0Q1FDQTNJRGh5RFFCQkFTRU9JQUV1QWJ3QklBRXVBYkFCYXlJTElBdEJIM1VpQzJvZ0MzTkJBMHNOQUNBcElDUnJJZ3NnQzBFZmRTSUxhaUFMYzBFRFN3MEFJQUVvQW9BQklBRW9BbnhISVE0TElBTWdEallDcEFFQ1FDQTRJRUp5RFFCQkFTRUhJQUV1QWNBQklBRXVBYndCYXlJTElBdEJIM1VpQzJvZ0MzTkJBMHNOQUNBNUlDbHJJZ2NnQjBFZmRTSUhhaUFIYzBFRFN5RUhDeUFESUFjMkFxd0JEQVVMUVFJaEVTQURRUUkyQWp3Z0FTOEJKQ0VJREFJTFFRSUxJZ3cyQWt4QkFpRUVJQU5CQWlBSVFRQkhRUUYwSUE0YklnZzJBbXdnQTBFQ0lBWkJBRWRCQVhRZ0Foc2lGRFlDWENBRElBY2dJWEpCQUVkQkFYUWlCellDckFFZ0F5QVFJQ0J5UVFCSFFRRjBJaEEyQXB3QklBTWdHU0FlY2tFQVIwRUJkQ0laTmdLTUFTQURJQXNnRjNKQkFFZEJBWFFpRnpZQ2ZFRUNJUUlDUUNBWUlDUnlEUUJCQVNFQ0lBRXVBWlFCSUFFdUFZZ0JheUlZSUJoQkgzVWlHR29nR0hOQkEwc05BQ0FCTGdHV0FTQUJMZ0dLQVdzaUdDQVlRUjkxSWhocUlCaHpRUU5MRFFBZ0FTZ0NlQ0FCS0FKMFJ5RUNDeUFESUFJMkFrUUNRQ0FHSUE1eURRQkJBU0VFSUFFdUFad0JJQUV1QVpBQmF5SUdJQVpCSDNVaUJtb2dCbk5CQTBzTkFDQUJMZ0dlQVNBQkxnR1NBV3NpQmlBR1FSOTFJZ1pxSUFaelFRTkxEUUFnQVNnQ2VDQUJLQUowUnlFRUN5QURJQVEyQW1SQkFpRU9RUUloQmdKQUlBc2dIbklOQUVFQklRWWdBUzRCdEFFZ0FTNEJxQUZySWdzZ0MwRWZkU0lMYWlBTGMwRURTdzBBSUFFdUFiWUJJQUV1QWFvQmF5SUxJQXRCSDNVaUMyb2dDM05CQTBzTkFDQUJLQUtBQVNBQktBSjhSeUVHQ3lBRElBWTJBb1FCQWtBZ0lDQWhjZzBBUVFFaERpQUJMZ0c4QVNBQkxnR3dBV3NpQ3lBTFFSOTFJZ3RxSUF0elFRTkxEUUFnQVM0QnZnRWdBUzRCc2dGcklnc2dDMEVmZFNJTGFpQUxjMEVEU3cwQUlBRW9Bb0FCSUFFb0FueEhJUTRMSUFNZ0RqWUNwQUVNQWdzZ0NDRU1RUUlMSWdJMkFrUWdBeUFCTHdFbUlBeEIvLzhEY1hKQkFFZEJBWFFpRERZQ1RDQURBbjhDUUNBSFJRUkFJQVFFUUVFQ0lSUWdBMEVDTmdKY0lBWU5Ba0VBREFNTFFRQWhGQ0FEUVFBMkFseEJBQ0FHUlEwQ0dnd0JDMEVDSVJRZ0EwRUNOZ0pjQzBFQ0N5SUVOZ0prSUFOQkFpQU9RUUJIUVFGMElBWWJJZ2cyQW13Z0F3Si9Ba0FnSUVVRVFDQVhCRUJCQWlFWElBTkJBallDZkNBWkRRSkJBQXdEQzBFQUlSY2dBMEVBTmdKOFFRQWdHVVVOQWhvTUFRdEJBaUVYSUFOQkFqWUNmQXRCQWdzaUJqWUNoQUVnQXlBTElCaHlRUUJIUVFGMElnYzJBcXdCSUFNZ0N5QVFja0VBUjBFQmRDSU9OZ0trQVNBRFFRSWdFRUVBUjBFQmRDQWVHeUlRTmdLY0FTQURJQmtnSVhKQkFFZEJBWFFpR1RZQ2pBRUxJQWtnSjNJZ0JYSWdEM0lnQ25JZ0UzSWdHM0lnRlhJZ0VuSWdIWElnRFhJZ0puSWdISElnRVhJZ0FuSWdESElnRkhJZ0JISWdDSElnRjNJZ0JuSWdHWElnRUhJZ0RuSWdCM0pGRFFFTElBRW9BZ3doQ1NBRElBRW9BaEFpQlNBQktBSVVJZ1JxSWdaQk15QUdRVE5JR3lJR1FRQWdCa0VBU2h0QjBCZHFMUUFBSWdZMkFpQWdBeUFFSUFscUlnSkJNeUFDUVROSUd5SUNRUUFnQWtFQVNoc2lDRUdRRjJvdEFBQWlBallDSENBRElBaEJBMnhCa0JocUlnZzJBaGdDUUNBdFJRMEFJQVFnQVNnQ3pBRW9BaFFpQjBjRVFDQURJQVFnQjJwQkFXcEJBWFlpQnlBRmFpSU5RVE1nRFVFelNCc2lEVUVBSUExQkFFb2JRZEFYYWkwQUFEWUNDQ0FESUFjZ0NXb2lCMEV6SUFkQk0wZ2JJZ2RCQUNBSFFRQktHeUlIUVpBWGFpMEFBRFlDQkNBRElBZEJBMnhCa0JocU5nSUFEQUVMSUFNZ0JqWUNDQ0FESUFJMkFnUWdBeUFJTmdJQUN3SkFJQzVGRFFBZ0JDQUJLQUxJQVNnQ0ZDSUhSd1JBSUFNZ0JDQUhha0VCYWtFQmRpSUVJQVZxSWdWQk15QUZRVE5JR3lJRlFRQWdCVUVBU2h0QjBCZHFMUUFBTmdJVUlBTWdCQ0FKYWlJRVFUTWdCRUV6U0JzaUJFRUFJQVJCQUVvYklnUkJrQmRxTFFBQU5nSVFJQU1nQkVFRGJFR1FHR28yQWd3TUFRc2dBeUFHTmdJVUlBTWdBallDRUNBRElBZzJBZ3dMSUFBb0FnQWdIeUE2YkNJVVFRaDBhaUFxUVFSMGFpRUpRUUFoQWtFRElRUWdBMEV3YWlFR0EwQWdCaWdDQkNJRkJFQWdDU0FGSUNNZ0doQVpDeUFHS0FJTUlnVUVRQ0FKUVFScUlBVWdJaUFhRUJrTElBWW9BaFFpQlFSQUlBbEJDR29nQlNBaUlCb1FHUXNnQmlnQ0hDSUZCRUFnQ1VFTWFpQUZJQ0lnR2hBWkN5QUVJUWdDUUFKQUFrQWdCaWdDQUNJRUlBWW9BZ2dpRDBjTkFDQUVJQVlvQWhCSERRQWdCQ0FHS0FJWVJ3MEFJQVJGRFFJZ0F5QUNRUXhzYWlJRktBSUlJUXdnQlNnQ0JDRWJJQVJCQkVrTkFTQWJRUUoyUVFKcUlSQkJFQ0VQSUFraEJBTkFBa0FnQkNBb2FpSUNMUUFBSWdvZ0JDMEFBQ0lPYXlJRklBVkJIM1VpQldvZ0JYTWlCeUFiVHcwQUlBUWdMR29pRVMwQUFDSUZJQXBySWcwZ0RVRWZkU0lOYWlBTmN5QU1UdzBBSUFRZ0dtb2lIQzBBQUNJU0lBNXJJZzBnRFVFZmRTSU5haUFOY3lBTVR3MEFBa0FnQnlBUVNRUkFJQVFnSldvaUZ5MEFBQ0VWQW44Z0JDQXJhaUlOTFFBQUloTWdDbXNpQnlBSFFSOTFJZ2RxSUFkeklBeEpCRUJCQXlFZElBSWdFaUFLSUE1cUlBVnFJZ0pCQVhScUlCTnFRUVJxUVFOMk9nQUFJQkVnQWlBVGFrRUNha0VDZGpvQUFDQUNRUVJxSVJFZ0JDQS9haTBBQUNFSElCTkJBMndNQVFzZ0NpQVNhaUVSSUFVaEIwRUNJUjBnQWlFTlFRSUxJUUlnRFNBQ0lCRnFJQWRCQVhScUlCMTJPZ0FBSUJVZ0Rtc2lBaUFDUVI5MUlnSnFJQUp6SUF4UERRRWdCQ0FGSUFvZ0Vtb2dEbW9pQWtFQmRHb2dGV3BCQkdwQkEzWTZBQUFnSENBQ0lCVnFRUUpxUVFKMk9nQUFJQmNnQWlBVlFRTnNhaUFFSUQ1cUxRQUFRUUYwYWtFRWFrRURkam9BQUF3Q0N5QUNJQW9nRW1vZ0JVRUJkR3BCQW1wQkFuWTZBQUFMSUFRZ0JTQU9haUFTUVFGMGFrRUNha0VDZGpvQUFBc2dCRUVCYWlFRUlBOUJmMm9pRHcwQUN3d0NDd0ovSUFRRVFDQUpJQVFnQXlBQ1FReHNhaUFhRUJnZ0JpZ0NDQ0VQQ3lBUEN3UkFJQWxCQkdvZ0R5QURJQUpCREd4cUlCb1FHQXNnQmlnQ0VDSUVCRUFnQ1VFSWFpQUVJQU1nQWtFTWJHb2dHaEFZQ3lBR0tBSVlJZ1JGRFFFZ0NVRU1haUFFSUFNZ0FrRU1iR29nR2hBWURBRUxJQVFnQlNnQ0FHcEJmMm90QUFBaUFrRUJhaUVIUVFBZ0Ftc2hEa0VRSVE4Z0NTRUVBMEFDUUNBRUlDaHFJaE10QUFBaURTQUVMUUFBSWdwcklnVWdCVUVmZFNJRmFpQUZjeUFiVHcwQUlBUWdMR29pRVMwQUFDSVNJQTFySWdVZ0JVRWZkU0lGYWlBRmN5QU1UdzBBSUFRZ0dtb2lFQzBBQUNJVklBcHJJZ1VnQlVFZmRTSUZhaUFGY3lBTVR3MEFJQUloQlNBRUlDdHFMUUFBSWh3Z0RXc2lIU0FkUVI5MUloMXFJQjF6SUF4SkJFQWdFU0FTSUE0Z0FpQUtJQTFxUVFGcVFRRjJJQkpCQVhScklCeHFRUUYxSWdVZ0JTQUNTaHNnQlNBT1NCdHFPZ0FBSUFjaEJRc2dFeUFOQW44Z0JDQWxhaTBBQUNJVElBcHJJaEVnRVVFZmRTSVJhaUFSY3lBTVNRUkFJQkFnRlNBT0lBSWdDaUFOYWtFQmFrRUJkaUFWUVFGMGF5QVRha0VCZFNJVElCTWdBa29iSUJNZ0RrZ2Jham9BQUNBRlFRRnFJUVVMUVFBZ0JXc2lFd3NnQlNBU0lCVnJJQW9nRFd0QkFuUnFRUVJxUVFOMUloSWdFaUFGU2hzZ0VpQVRTQnNpQldwQnNDNXFMUUFBT2dBQUlBUWdDaUFGYTBHd0xtb3RBQUE2QUFBTElBUkJBV29oQkNBUFFYOXFJZzhOQUFzTElBaEJmMm9oQkNBR1FTQnFJUVlnQ1NBOWFpRUpRUUloQWlBSURRQUxJQUVvQWd3aEJDQURJQUVvQWhBaUJTQUJLQUlVSWdZZ0FTZ0NHQ0lDYWlJSlFUTWdDVUV6U0JzaUNVRUFJQWxCQUVvYlFRSjBRZUE5YWlnQ0FDSUphaUlJUVRNZ0NFRXpTQnNpQ0VFQUlBaEJBRW9iUWRBWGFpMEFBQ0lJTmdJZ0lBTWdCQ0FKYWlJSFFUTWdCMEV6U0JzaUIwRUFJQWRCQUVvYklnMUJrQmRxTFFBQUlnYzJBaHdnQXlBTlFRTnNRWkFZYWlJTk5nSVlBa0FnTFVVTkFDQUdJQUVvQXN3QktBSVVJZ3hIQkVBZ0F5QUpJQUlnREdvaURFRXpJQXhCTTBnYklneEJBQ0FNUVFCS0cwRUNkRUhnUFdvb0FnQnFRUUZxUVFGMklnd2dCV29pRDBFeklBOUJNMGdiSWc5QkFDQVBRUUJLRzBIUUYyb3RBQUEyQWdnZ0F5QUVJQXhxSWd4Qk15QU1RVE5JR3lJTVFRQWdERUVBU2hzaURFR1FGMm90QUFBMkFnUWdBeUFNUVFOc1FaQVlhallDQUF3QkN5QURJQWcyQWdnZ0F5QUhOZ0lFSUFNZ0RUWUNBQXNDUUNBdVJRMEFJQVlnQVNnQ3lBRW9BaFFpREVjRVFDQURJQVVnQ1NBQ0lBeHFJZ1pCTXlBR1FUTklHeUlHUVFBZ0JrRUFTaHRCQW5SQjREMXFLQUlBYWtFQmFrRUJkaUlKYWlJRlFUTWdCVUV6U0JzaUJVRUFJQVZCQUVvYlFkQVhhaTBBQURZQ0ZDQURJQVFnQ1dvaUJFRXpJQVJCTTBnYklnUkJBQ0FFUVFCS0d5SUVRWkFYYWkwQUFEWUNFQ0FESUFSQkEyeEJrQmhxTmdJTURBRUxJQU1nQ0RZQ0ZDQURJQWMyQWhBZ0F5QU5OZ0lNQ3lBQUtBSUFJRHhxSUJSQkJuUnFJQ3BCQTNScUlna2dPMm9oQkVFQUlRb2dBMEV3YWlFR1FRQWhBZ05BSUFZb0FnUWlCUVJBSUFrZ0JTQWpJQllRRUNBRUlBWW9BZ1FnSXlBV0VCQUxJQVlvQWlRaUJRUkFJQWtnR21vZ0JTQWpJQllRRUNBRUlCcHFJQVlvQWlRZ0l5QVdFQkFMSUFZb0FoUWlCUVJBSUFsQkJHb2dCU0FpSUJZUUVDQUVRUVJxSUFZb0FoUWdJaUFXRUJBTElBWW9BalFpQlFSQUlBa2dHbXBCQkdvZ0JTQWlJQllRRUNBRUlCcHFRUVJxSUFZb0FqUWdJaUFXRUJBTElBSWhCUUpBQWtBZ0JpZ0NBQ0lDSUFZb0FnZ2lEMGNOQUNBQ0lBWW9BaEJIRFFBZ0FpQUdLQUlZUncwQUlBSkZEUUVnQ1NBQ0lBTWdDa0VNYkdvaUFpQVdFQ3NnQkNBR0tBSUFJQUlnRmhBckRBRUxBbjhnQWdSQUlBa2dBaUFESUFwQkRHeHFJZ0lnRmhBU0lBUWdCaWdDQUNBQ0lCWVFFaUFHS0FJSUlROExJQThMQkVBZ0NVRUNhaUFQSUFNZ0NrRU1iR29pQWlBV0VCSWdCRUVDYWlBR0tBSUlJQUlnRmhBU0N5QUdLQUlRSWdJRVFDQUpRUVJxSUFJZ0F5QUtRUXhzYWlJQ0lCWVFFaUFFUVFScUlBWW9BaEFnQWlBV0VCSUxJQVlvQWhnaUFrVU5BQ0FKUVFacUlBSWdBeUFLUVF4c2FpSUNJQllRRWlBRVFRWnFJQVlvQWhnZ0FpQVdFQklMSUFRZ0pXb2hCQ0FKSUNWcUlRa2dCa0ZBYXlFR1FRRWhBa0VDSVFvZ0JVVU5BQXNMUVFBZ0trRUJhaUlFSUFRZ0gwWWlCQnNoS2lBQlFkZ0JhaUVCSUFRZ09tb2lPaUFBS0FJSVNRMEFDd3NnQTBHd0FXb2tBQXVDQlFFS2Z5TUFRWkFCYXlJTEpBQUNRQUpBSUFKQkFFZ05BQ0FEUVFCSURRQWdBaUFIYWlBRVN3MEFJQU1nQ0dwQkFXb2dCVXNOQUNBRklRd2dBeUVPREFFTElBQWdDeUFDSUFNZ0JDQUZJQWNnQ0VFQmFpSU1JQWNRRENBQUlBUWdCV3hxSUFzZ0J5QU1iR29nQWlBRElBUWdCU0FISUF3Z0J4QU1JQXNoQUNBSElRUkJBQ0VDQ3dKQUlBaEJBWFlpQlVVTkFDQUhRUUYySWdORkRRQkJFQ0FIYXlFUVFRZ2dCbXNoQ1NBRVFRRjBJZzBnQjJzaEVTQUFJQUpxSWhJZ0JDQU9iR29oQnlBQklRSWdCU0VJQTBBZ0F5RUFBMEFnQnlBTmFpMEFBQ0VLSUFJZ0NTQUhMUUFBYkNBRUlBZHFMUUFBSWc4Z0JteHFRUU4wUVNCcVFRWjJPZ0FBSUFJZ0NTQVBiQ0FHSUFwc2FrRURkRUVnYWtFR2Rqb0FDQ0FIUVFGcUlnb2dEV290QUFBaER5QUNJQWtnQnkwQUFXd2dCQ0FLYWkwQUFDSUtJQVpzYWtFRGRFRWdha0VHZGpvQUFTQUNJQWtnQ213Z0JpQVBiR3BCQTNSQklHcEJCblk2QUFrZ0FrRUNhaUVDSUFkQkFtb2hCeUFBUVg5cUlnQU5BQXNnQnlBUmFpRUhJQUlnRUdvaEFpQUlRWDlxSWdnTkFBc2dBVUZBYXlFQ0lCSWdEQ0FPYWlBRWJHb2hCd05BSUFNaEFBTkFJQWNnRFdvdEFBQWhBU0FDSUFrZ0J5MEFBR3dnQkNBSGFpMEFBQ0lJSUFac2FrRURkRUVnYWtFR2Rqb0FBQ0FDSUFnZ0NXd2dBU0FHYkdwQkEzUkJJR3BCQm5ZNkFBZ2dCMEVCYWlJQklBMXFMUUFBSVFnZ0FpQUpJQWN0QUFGc0lBRWdCR290QUFBaUFTQUdiR3BCQTNSQklHcEJCblk2QUFFZ0FpQUJJQWxzSUFZZ0NHeHFRUU4wUVNCcVFRWjJPZ0FKSUFKQkFtb2hBaUFIUVFKcUlRY2dBRUYvYWlJQURRQUxJQWNnRVdvaEJ5QUNJQkJxSVFJZ0JVRi9haUlGRFFBTEN5QUxRWkFCYWlRQUMvMEVBUXQvSXdCQmtBRnJJZ3drQUNBSFFRRnFJUWtDUUFKQUlBSkJBRWdOQUNBRElBaHFJQVZMRFFBZ0EwRUFTQTBBSUFJZ0NXb2dCRXNOQUNBRUlRa2dBeUVMREFFTElBQWdEQ0FDSUFNZ0JDQUZJQWtnQ0NBSkVBd2dBQ0FFSUFWc2FpQU1JQWdnQ1d4cUlBSWdBeUFFSUFVZ0NTQUlJQWtRRENBTUlRQWdDQ0VGUVFBaEFnc0NRQ0FJUVFGMklnaEZEUUFnQjBFQmRpSUVSUTBBUVJBZ0Iyc2hEa0VJSUFacklRb2dDVUVCZENBSGF5RVBJQUFnQW1vaUVTQUpJQXRzYWlFQ0lBRWhBeUFJSVFBRFFDQUVJUWNEUUNBQ1FRRnFJQWxxTFFBQUlSQWdBaUFKYWkwQUFDRU5JQU1nQWkwQUFTSVNJQVpzSUFvZ0FpMEFBR3hxUVFOMFFTQnFRUVoyT2dBQUlBTWdCaUFRYkNBS0lBMXNha0VEZEVFZ2FrRUdkam9BQ0NBQ0xRQUNJUTBnQWtFQ2FpSUNJQWxxTFFBQUlSTWdBeUFHSUExc0lBb2dFbXhxUVFOMFFTQnFRUVoyT2dBQklBTWdCaUFUYkNBS0lCQnNha0VEZEVFZ2FrRUdkam9BQ1NBRFFRSnFJUU1nQjBGL2FpSUhEUUFMSUFJZ0Qyb2hBaUFESUE1cUlRTWdBRUYvYWlJQURRQUxJQUZCUUdzaEF5QVJJQVVnQzJvZ0NXeHFJUUlEUUNBRUlRY0RRQ0FDUVFGcUlBbHFMUUFBSVFBZ0FpQUphaTBBQUNFQklBTWdBaTBBQVNJRklBWnNJQW9nQWkwQUFHeHFRUU4wUVNCcVFRWjJPZ0FBSUFNZ0FDQUdiQ0FCSUFwc2FrRURkRUVnYWtFR2Rqb0FDQ0FDTFFBQ0lRRWdBa0VDYWlJQ0lBbHFMUUFBSVFzZ0F5QUJJQVpzSUFVZ0NteHFRUU4wUVNCcVFRWjJPZ0FCSUFNZ0JpQUxiQ0FBSUFwc2FrRURkRUVnYWtFR2Rqb0FDU0FEUVFKcUlRTWdCMEYvYWlJSERRQUxJQUlnRDJvaEFpQURJQTVxSVFNZ0NFRi9haUlJRFFBTEN5QU1RWkFCYWlRQUM3a0hBUVYvSXdCQkVHc2lCQ1FBQWtBZ0FDQUJRUUJCeUFBUUJ5SURFQUlpQVEwQVFRRWhBU0FES0FJQVFmOEJTdzBBSUFBZ0EwRUVhaEFDSWdFTkFFRUJJUUVnQXlnQ0JFRWZTdzBBSUFCQkFSQUREUUFnQUVFQkVBTWlBa0YvUmcwQUlBTWdBa0VCUmpZQ0NDQUFJQVJCREdvUUFpSUJEUUFnQXlBRUtBSU1RUUZxSWdFMkFnd2dBVUVJU3dSQVFRRWhBUXdCQ3dKQUlBRkJBa2tOQUNBQUlBTkJFR29RQWlJQkRRRWdBeWdDRUNJQlFRWkxJZ0lFUUVFQklRRU1BZ3NnQWcwQUFrQUNRQUpBQWtBZ0FVRUJhdzRHQkFFQ0FnSURBQXNnQXlBREtBSU1JZ0ZCQW5RUUNpSUNOZ0lVSUFKRkJFQkIvLzhESVFFTUJRc2dBVVVOQTBFQUlRSURRQ0FBSUFSQkRHb1FBaUlCRFFVZ0F5Z0NGQ0FDUVFKMGFpQUVLQUlNUVFGcU5nSUFJQUpCQVdvaUFpQURLQUlNU1EwQUN3d0RDeUFESUFNb0Fnd2lBa0VDZEVGOGFpSUJFQW9pQlRZQ0dDQURJQUVRQ2lJR05nSWNRZi8vQXlFQklBVkZEUU1nQmtVTkF5QUNRUUZHRFFKQkFDRUNBMEFnQUNBRVFReHFFQUlpQVEwRUlBSkJBblFpQlNBREtBSVlhaUFFS0FJTU5nSUFJQUFnQkVFTWFoQUNJZ0VOQkNBREtBSWNJQVZxSUFRb0FndzJBZ0FnQWtFQmFpSUNJQU1vQWd4QmYycEpEUUFMREFJTFFRRWhBU0FBUVFFUUF5SUNRWDlHRFFJZ0F5QUNRUUZHTmdJZ0lBQWdCRUVNYWhBQ0lnRU5BaUFESUFRb0FneEJBV28yQWlRTUFRc2dBQ0FFUVF4cUVBSWlBUTBCSUFNZ0JDZ0NERUVCYWlJQk5nSW9JQU1nQVVFQ2RCQUtJZ0kyQWl3Z0FrVUVRRUgvL3dNaEFRd0NDeUFCUlEwQUlBTW9BZ3hCQW5SQnJEdHFLQUlBSVFaQkFDRUNBMEFnQUNBR0VBTWhCU0FES0FJc0lBSkJBblJxSUFVMkFnQkJBU0VCSUFVZ0F5Z0NERThOQWlBQ1FRRnFJZ0lnQXlnQ0tFa05BQXNMSUFBZ0JFRU1haEFDSWdFTkFFRUJJUUVnQkNnQ0RDSUNRUjlMRFFBZ0F5QUNRUUZxTmdJd0lBQWdCRUVNYWhBQ0lnRU5BRUVCSVFFZ0JDZ0NERUVmU3cwQUlBQkJBUkFEQkVBTUFRc2dBRUVDRUFOQkFrc0VRQXdCQ3lBQUlBUkJDR29RQlNJQkRRQWdCQ2dDQ0VFYWFpSUJRVE5MQkVCQkFTRUJEQUVMSUFNZ0FUWUNOQ0FBSUFSQkNHb1FCU0lCRFFBZ0JDZ0NDRUVhYWtFelN3UkFRUUVoQVF3QkN5QUFJQVJCQ0dvUUJTSUJEUUJCQVNFQklBUW9BZ2dpQWtFTWFrRVlTdzBBSUFNZ0FqWUNPQ0FBUVFFUUF5SUNRWDlHRFFBZ0F5QUNRUUZHTmdJOElBQkJBUkFESWdKQmYwWU5BQ0FESUFKQkFVWTJBa0FnQUVFQkVBTWlBa0YvUmcwQUlBTWdBa0VCUmpZQ1JDQUFFQjlCQUNFQkN5QUVRUkJxSkFBZ0FRdnFCUUVKZndKQUlBSW9BcHdDUlFSQURBRUxRUUVoQmdOQUFrQUNRQ0FDSUFWQkZHeHFLQUtnQWlJRVFRVkxEUUFnQkVFQmF3NEZBQUFBQUFNQkN5QUZRUUZxSVFVTUFRc0xJQVFoQmdzQ2Z3SkFJQUVvQWhBaUJFRUJUUVJBSUFSQkFXc0VRQ0FES0FJQVFRVkdCRUFnQUVJQU53SUFJQUlvQWhRaEJVRUFJUVFNQXdzZ0FDZ0NBQ0lFSUFJb0FoUWlCVTBOQWlBRUlBVnJJQUVvQWhRaUIwRUJka2tOQWlBQUtBSUVJQWRxREFNTFFRQWhCUUovUVFBZ0F5Z0NBRUVGUmcwQUdpQUFLQUlNSWdjZ0FDZ0NDQ0FDS0FJTVRRMEFHaUFCS0FJTUlBZHFDeUVIUVFBaEJBSi9JQUVvQWlRaUNBUkFJQUlvQWd3Z0Iyb2hCUXNnQlNBREtBSUVJZ3BGSUFWQkFFZHhheUlKQ3dSQUlBbEJmMm9pQXlBRElBaHVJZ3NnQ0d4cklRTUxJQWdFUUNBQktBSW9JUXhCQUNFRkEwQWdEQ0FGUVFKMGFpZ0NBQ0FFYWlFRUlBVkJBV29pQlNBSVJ3MEFDd3NDUUNBSlJRUkFRUUFoQkF3QkN5QUVJQXRzSVFRZ0FTZ0NLQ0VJUVFBaEJRTkFJQWdnQlVFQ2RHb29BZ0FnQkdvaEJDQUZRUUZxSWdVZ0EwME5BQXNMSUFwRkJFQWdBU2dDSENBRWFpRUVDeUFHUlFSQUlBSW9BaUFoQXlBQktBSWdJUUVnQWlnQ0hDRUdJQUFnQnpZQ0RDQUFJQUlvQWd3MkFnZ2dCaUFCSUFOcUlnQkJIM1VnQUhFZ0JHcHFEd3NnQUVJQU53SUlRUUFQQzBFQUlRVkJBQ0VFSUFNb0FnQkJCVWNFUUNBQUtBSU1JUVVnQUNnQ0NDQUNLQUlNSWdSTEJFQWdBU2dDRENBRmFpRUZDeUFFSUFWcVFRRjBJQU1vQWdSRmF5RUVDeUFHUlFSQUlBQWdCVFlDRENBQUlBSW9BZ3cyQWdnZ0JBOExJQUJDQURjQ0NFRUFEd3NDUUNBRklBUk5EUUFnQlNBRWF5QUJLQUlVSWdGQkFYWk5EUUFnQUNnQ0JDQUJhd3dCQ3lBQUtBSUVDeUVFSUFNb0FnUkZCRUFnQkNBRmFpQUNLQUlZSWdCQkgzVWdBSEZxRHdzZ0FDQUVOZ0lFSUFJb0FoZ2hBU0FHQkVBZ0FFRUFOZ0lFSUFCQkFDQUJheUFCUVI5MWNUWUNBRUVBRHdzZ0FDQUZOZ0lBSUFRZ0JXb2dBVUVmZFNBQmNXb0x2QUVCQ0g4Z0FnUkFJQUZCZjJvaEIwRUFJQUZyUWRnQmJDRUlRUUVnQVd0QjJBRnNJUWtnQVVGL2MwSFlBV3doQ2dOQUlBQWdCa0hZQVd4cUlnTWdBMEdvZm1wQkFDQUVHellDeUFFZ0F3Si9JQVZGQkVBZ0EwRUFOZ0xNQVVFQURBRUxJQU1nQXlBSWFqWUN6QUVnQXlBSmFrRUFJQVFnQjBrYkN6WUMwQUVnQXlBRElBcHFRUUFnQkJ0QkFDQUZHellDMUFGQkFDQUVRUUZxSWdNZ0FTQURSaUlER3lFRUlBTWdCV29oQlNBR1FRRnFJZ1lnQWtjTkFBc0xDM2NCQW45QkFTRUNBa0FnQUVFQkVBTkJmMFlOQUNBQklBQkJBaEFETmdJRUlBRWdBRUVGRUFNaUFEWUNBQ0FBUVg1cVFRTkpEUUFDUUNBQVFReExEUUJCQVNBQWRDSURRY0E4Y1VVRVFDQURRYUFEY1VVTkFTQUFRUVpHRFFJZ0FTZ0NCQTBCREFJTElBRW9BZ1FOQVF0QkFDRUNDeUFDQzVJVEFRWi9JQUFnQVNnQ0FDSU5OZ0lBSUFBZ0FDZ0N4QUZCQVdvMkFzUUJJQUlnQlJBZEFrQUNRQUpBQWtBQ1FDQU5RUjlHQkVBZ0FFRUFOZ0lVSUFBb0FzUUJRUUZMRFFFZ0FFRWNhaUVKSUFGQnlBSnFJUVJCRnlFQklBY2hBQU5BSUFsQkVEc0JBQ0FBSUFRb0FnQTZBQUFnQUNBRUtBSUVPZ0FCSUFBZ0JDZ0NDRG9BQWlBQUlBUW9BZ3c2QUFNZ0FDQUVLQUlRT2dBRUlBQWdCQ2dDRkRvQUJTQUFJQVFvQWhnNkFBWWdBQ0FFS0FJY09nQUhJQUFnQkNnQ0lEb0FDQ0FBSUFRb0FpUTZBQWtnQUNBRUtBSW9PZ0FLSUFBZ0JDZ0NMRG9BQ3lBQUlBUW9BakE2QUF3Z0FDQUVLQUkwT2dBTklBQWdCQ2dDT0RvQURpQUFJQVFvQWp3NkFBOGdBU0lEUVg5cUlRRWdDVUVDYWlFSklBQkJFR29oQUNBRVFVQnJJUVFnQXcwQUN5QUNJQWNRR3d3RUN5QUFRUnhxSVFrZ0RRUkFJQWtnQVNrQ2tBSTNBZ0FnQ1NBQktRRytBamNCTGlBSklBRXBBcmdDTndJb0lBa2dBU2tDc0FJM0FpQWdDU0FCS1FLb0FqY0NHQ0FKSUFFcEFxQUNOd0lRSUFrZ0FTa0NtQUkzQWdnZ0JDZ0NBQ0VLQWtBZ0FTZ0NDQ0lMUlEwQUlBUWdDaUFMYWlJS05nSUFJQVFnQ2tGL1RBUi9JQXBCTkdvRklBcEJORWdOQVNBS1FVeHFDeUlLTmdJQUN5QUFJQW8yQWhRZ0FVSElEMm9oRENBQlFjZ0NhaUVFQWtBQ1FDQUFLQUlBUVFaTkJFQWdDUzhCQUVVTkFVRUJJUWdnQkNBS1FRQWdEQ2dDQUJBR1JRMENEQWdMSUFBdkFVd0VRQ0FCUWNnT2FpQUtFREVMUWJBMElRcEJEeUVJQTBBZ0NDRUxJQVFnQVNBS0tBSUFRUUowYWtISURtb29BZ0FpQ0RZQ0FBSkFBa0FnQ0VVRVFDQUpMd0VBUlEwQkMwRUJJUWdnQkNBQUtBSVVRUUVnRENnQ0FCQUdSUTBCREFvTElBUkIvLy8vQnpZQ0FBc2dDa0VFYWlFS0lBdEJmMm9oQ0NBTVFRUnFJUXdnQ1VFQ2FpRUpJQVJCUUdzaEJDQUxEUUFMREFRTElBUkIvLy8vQnpZQ0FBc2dBVUdJQTJvaEJBSkFJQUF2QVI0RVFFRUJJUWdnQkNBQUtBSVVRUUFnQVVITUQyb29BZ0FRQmtVTkFRd0hDeUFFUWYvLy93YzJBZ0FMSUFGQnlBTnFJUVFDUUNBQUx3RWdCRUJCQVNFSUlBUWdBQ2dDRkVFQUlBRkIwQTlxS0FJQUVBWkZEUUVNQndzZ0JFSC8vLzhITmdJQUN5QUJRWWdFYWlFRUFrQWdBQzhCSWdSQVFRRWhDQ0FFSUFBb0FoUkJBQ0FCUWRRUGFpZ0NBQkFHUlEwQkRBY0xJQVJCLy8vL0J6WUNBQXNnQVVISUJHb2hCQUpBSUFBdkFTUUVRRUVCSVFnZ0JDQUFLQUlVUVFBZ0FVSFlEMm9vQWdBUUJrVU5BUXdIQ3lBRVFmLy8vd2MyQWdBTElBRkJpQVZxSVFRQ1FDQUFMd0VtQkVCQkFTRUlJQVFnQUNnQ0ZFRUFJQUZCM0E5cUtBSUFFQVpGRFFFTUJ3c2dCRUgvLy84SE5nSUFDeUFCUWNnRmFpRUVBa0FnQUM4QktBUkFRUUVoQ0NBRUlBQW9BaFJCQUNBQlFlQVBhaWdDQUJBR1JRMEJEQWNMSUFSQi8vLy9CellDQUFzZ0FVR0lCbW9oQkFKQUlBQXZBU29FUUVFQklRZ2dCQ0FBS0FJVVFRQWdBVUhrRDJvb0FnQVFCa1VOQVF3SEN5QUVRZi8vL3djMkFnQUxJQUZCeUFacUlRUUNRQ0FBTHdFc0JFQkJBU0VJSUFRZ0FDZ0NGRUVBSUFGQjZBOXFLQUlBRUFaRkRRRU1Cd3NnQkVILy8vOEhOZ0lBQ3lBQlFZZ0hhaUVFQWtBZ0FDOEJMZ1JBUVFFaENDQUVJQUFvQWhSQkFDQUJRZXdQYWlnQ0FCQUdSUTBCREFjTElBUkIvLy8vQnpZQ0FBc2dBVUhJQjJvaEJBSkFJQUF2QVRBRVFFRUJJUWdnQkNBQUtBSVVRUUFnQVVId0Qyb29BZ0FRQmtVTkFRd0hDeUFFUWYvLy93YzJBZ0FMSUFGQmlBaHFJUVFDUUNBQUx3RXlCRUJCQVNFSUlBUWdBQ2dDRkVFQUlBRkI5QTlxS0FJQUVBWkZEUUVNQndzZ0JFSC8vLzhITmdJQUN5QUJRY2dJYWlFRUFrQWdBQzhCTkFSQVFRRWhDQ0FFSUFBb0FoUkJBQ0FCUWZnUGFpZ0NBQkFHUlEwQkRBY0xJQVJCLy8vL0J6WUNBQXNnQVVHSUNXb2hCQUpBSUFBdkFUWUVRRUVCSVFnZ0JDQUFLQUlVUVFBZ0FVSDhEMm9vQWdBUUJrVU5BUXdIQ3lBRVFmLy8vd2MyQWdBTElBRkJ5QWxxSVFRQ1FDQUFMd0U0QkVCQkFTRUlJQVFnQUNnQ0ZFRUFJQUZCZ0JCcUtBSUFFQVpGRFFFTUJ3c2dCRUgvLy84SE5nSUFDeUFCUVlnS2FpRUVBa0FnQUM4Qk9nUkFRUUVoQ0NBRUlBQW9BaFJCQUNBQlFZUVFhaWdDQUJBR1JRMEJEQWNMSUFSQi8vLy9CellDQUFzZ0FVR0lFR29oRENBQlFjZ0thaUVFREFJTElBbENBRGNDQUNBSlFnQTNBUzRnQ1VJQU53SW9JQWxDQURjQ0lDQUpRZ0EzQWhnZ0NVSUFOd0lRSUFsQ0FEY0NDQ0FBSUFRb0FnQTJBaFFNQWdzZ0FFS1FnTUNBZ0lLQUNEY0JIQ0FBUXBDQXdJQ0Fnb0FJTndGRUlBQkNrSURBZ0lDQ2dBZzNBVHdnQUVLUWdNQ0FnSUtBQ0RjQk5DQUFRcENBd0lDQWdvQUlOd0VzSUFCQ2tJREFnSUNDZ0FnM0FTUkJBQThMSUFBb0FoZ2dBQ2dDRkdvaUMwRXpJQXRCTTBnYklndEJBQ0FMUVFCS0cwRUNkRUhnUFdvb0FnQWhDUUpBSUFBdkFVNUZCRUFnQUM4QlVFVU5BUXNnQVVHSUQyb2dDUkF3Q3lBRUlBRkJpQTlxS0FJQUlnczJBZ0FDUUFKQUlBdEZCRUFnQUM4QlBFVU5BUXRCQVNFSUlBUWdDVUVCSUF3b0FnQVFCa1VOQVF3RUN5QUVRZi8vL3djMkFnQUxJQVFnQVNnQ2pBOGlDellDUUNBRVFVQnJJUW9DUUFKQUlBdEZCRUFnQUM4QlBrVU5BUXRCQVNFSUlBb2dDVUVCSUF3b0FnUVFCa1VOQVF3RUN5QUtRZi8vL3djMkFnQUxJQVFnQVNnQ2tBOGlDellDZ0FFZ0JFR0FBV29oQ2dKQUFrQWdDMFVFUUNBQVFVQnJMd0VBUlEwQkMwRUJJUWdnQ2lBSlFRRWdEQ2dDQ0JBR1JRMEJEQVFMSUFwQi8vLy9CellDQUFzZ0JDQUJLQUtVRHlJTE5nTEFBU0FFUWNBQmFpRUtBa0FDUUNBTFJRUkFJQUF2QVVKRkRRRUxRUUVoQ0NBS0lBbEJBU0FNS0FJTUVBWkZEUUVNQkFzZ0NrSC8vLzhITmdJQUN5QUVJQUVvQXBnUElnczJBb0FDSUFSQmdBSnFJUW9DUUFKQUlBdEZCRUFnQUM4QlJFVU5BUXRCQVNFSUlBb2dDVUVCSUF3b0FoQVFCa1VOQVF3RUN5QUtRZi8vL3djMkFnQUxJQVFnQVNnQ25BOGlDellDd0FJZ0JFSEFBbW9oQ2dKQUFrQWdDMFVFUUNBQUx3RkdSUTBCQzBFQklRZ2dDaUFKUVFFZ0RDZ0NGQkFHUlEwQkRBUUxJQXBCLy8vL0J6WUNBQXNnQkNBQktBS2dEeUlMTmdLQUF5QUVRWUFEYWlFS0FrQUNRQ0FMUlFSQUlBQXZBVWhGRFFFTFFRRWhDQ0FLSUFsQkFTQU1LQUlZRUFaRkRRRU1CQXNnQ2tILy8vOEhOZ0lBQ3lBRUlBRW9BcVFQSWdzMkFzQURJQVJCd0FOcUlRUUNRQUpBSUF0RkJFQWdBQzhCU2tVTkFRdEJBU0VJSUFRZ0NVRUJJQXdvQWh3UUJrVU5BUXdFQ3lBRVFmLy8vd2MyQWdBTElBMUJCa2tOQUNBQUlBRWdBaUFGSUFZZ0J4QldJZ2hGRFFFTUFnc2dBQ0FCSUFNZ0JTQUNJQWNRVnlJSURRRUxRUUFoQ0FzZ0NBdVdIUUVIZnlNQVFSQnJJZ2NrQUNBQlFRQkJxQkFRQnlFRklBQWdCMEVFYWhBQ0lRRWdCeWdDQkNFSUFrQUNRQUpBSUFOQmZtb2lBMEVGU3cwQUFrQWdBMEVCYXc0RUFRRUJBUUFMUVFFaEF5QUJEUUlnQ0VFR2FpSUdRUjlORFFFTUFndEJBU0VESUFFTkFTQUlRUUZxSWdaQkgwc05BUXNnQlNBR05nSUFBa0FnQmtFZlJnUkFBMEFnQUNnQ0NBUkFJQUJCQVJBRFJRMEJEQVFMQ3lBRlFjZ0NhaUVHQTBBZ0J5QUFRUWdRQXlJQk5nSUVJQUZCZjBZTkF5QUdJQUUyQWdBZ0JrRUVhaUVHSUFsQkFXb2lDVUdBQTBjTkFBc01BUXRCQWlBR1FRWkhJQVpCQmtrYklRb0NRQUpBSUFaQkJFa05BQ0FHUVFWTERRQWdBQ0FIUVF4cUVBSU5BU0FIS0FJTUlnRkJBMHNOQVNBRklBRTJBckFCSUFBZ0IwRU1haEFDRFFFZ0J5Z0NEQ0lCUVFOTERRRWdCU0FCTmdLMEFTQUFJQWRCREdvUUFnMEJJQWNvQWd3aUFVRURTdzBCSUFVZ0FUWUN1QUVnQUNBSFFReHFFQUlOQVNBSEtBSU1JZ0ZCQTBzTkFTQUZJQUUyQXJ3QkFrQWdCRUVDU1EwQUlBWkJCVVlOQUNBQUlBZEJER29nQkVFQ1N5SUJFQmNOQWlBSEtBSU1JZ2dnQkU4TkFpQUZJQWcyQXNBQklBQWdCMEVNYWlBQkVCY05BaUFIS0FJTUlnZ2dCRThOQWlBRklBZzJBc1FCSUFBZ0IwRU1haUFCRUJjTkFpQUhLQUlNSWdnZ0JFOE5BaUFGSUFnMkFzZ0JJQUFnQjBFTWFpQUJFQmNOQWlBSEtBSU1JZ0VnQkU4TkFpQUZJQUUyQXN3QkN5QUhJQVVvQXJBQklnRkJBazBFZnlBQlFRSjBRZkEwYWlnQ0FBVkJBd3MyQWd4QkFDRUdBMEFnQUNBSFFRaHFFQVVpQXcwQ0lBVWdCa0VDZEdvaUFTQUhLQUlJT3dIUUFTQUFJQWRCQ0dvUUJTSUREUUlnQVNBSEtBSUlPd0hTQVNBSElBY29BZ3dpQVVGL2FqWUNEQ0FHUVFGcUlRWWdBUTBBQ3lBSElBVW9BclFCSWdGQkFrMEVmeUFCUVFKMFFmQTBhaWdDQUFWQkF3czJBZ3hCQUNFR0EwQWdBQ0FIUVFocUVBVWlBdzBDSUFVZ0JrRUNkR29pQVNBSEtBSUlPd0hnQVNBQUlBZEJDR29RQlNJRERRSWdBU0FIS0FJSU93SGlBU0FISUFjb0Fnd2lBVUYvYWpZQ0RDQUdRUUZxSVFZZ0FRMEFDeUFISUFVb0FyZ0JJZ0ZCQWswRWZ5QUJRUUowUWZBMGFpZ0NBQVZCQXdzMkFneEJBQ0VHQTBBZ0FDQUhRUWhxRUFVaUF3MENJQVVnQmtFQ2RHb2lBU0FIS0FJSU93SHdBU0FBSUFkQkNHb1FCU0lERFFJZ0FTQUhLQUlJT3dIeUFTQUhJQWNvQWd3aUFVRi9hallDRENBR1FRRnFJUVlnQVEwQUN5QUhJQVVvQXJ3QklnRkJBazBFZnlBQlFRSjBRZkEwYWlnQ0FBVkJBd3MyQWd4QkFDRUdBMEFnQUNBSFFRaHFFQVVpQXcwQ0lBVWdCa0VDZEdvaUFTQUhLQUlJT3dHQUFpQUFJQWRCQ0dvUUJTSUREUUlnQVNBSEtBSUlPd0dDQWlBSElBY29BZ3dpQVVGL2FqWUNEQ0FHUVFGcUlRWkJBQ0VESUFFTkFBc01BUXRCQUNFRElBcEJBa3NOQUFKQUFuOENRQUpBQWtBZ0NrRUJhdzRDQkFFQUN5QUhRUUEyQWdnZ0JTQUFFQThpQVVFZmRqWUNEQ0FCUVFCT0RRRWdBVUVCZENFR1FRQU1BZ3NnQkVFQ1R3UkFRUU1oQVNBR1FRTk5CRUFnQmtFQ2RFSDhOR29vQWdBaEFRc2dCRUVDU3lFTFFRRWhBd05BSUFBZ0IwRU1haUFMRUJjTkJTQUhLQUlNSWdnZ0JFOE5CU0FGSUFsQkFuUnFJQWcyQXBBQklBRWlDRUYvYWlFQklBbEJBV29oQ1NBSURRQUxDMEVESVFNZ0JrRURUUVJBSUFaQkFuUkIvRFJxS0FJQUlRTUxRUUFoQmdOQUlBTWhBU0FBSUFkQkNHb1FCU0lERFFRZ0JTQUdRUUowYWlJRUlBY29BZ2c3QWFBQklBQWdCMEVJYWhBRklnTU5CQ0FFSUFjb0FnZzdBYUlCSUFGQmYyb2hBeUFHUVFGcUlRWWdBUTBBQzBFQUlRTU1Bd3NnQlNBQlFSeDJOZ0pNSUFGQkJIUWhCa0VCQ3lFRElBVWdCa0VmZGpZQ0VDQUZJQVpCQUVnRWZ5QUdRUUYwQlNBRklBWkJISFkyQWxBZ0EwRUJhaUVESUFaQkJIUUxJZ0ZCSDNZMkFoUWdCU0FCUVFCSUJIOGdBVUVCZEFVZ0JTQUJRUngyTmdKVUlBTkJBV29oQXlBQlFRUjBDeUlCUVI5Mk5nSVlJQVVnQVVFQVNBUi9JQUZCQVhRRklBVWdBVUVjZGpZQ1dDQURRUUZxSVFNZ0FVRUVkQXNpQVVFZmRqWUNIQ0FGSUFGQkFFZ0VmeUFCUVFGMEJTQUZJQUZCSEhZMkFsd2dBMEVCYWlFRElBRkJCSFFMSWdGQkgzWTJBaUFnQlNBQlFRQklCSDhnQVVFQmRBVWdCU0FCUVJ4Mk5nSmdJQU5CQVdvaEF5QUJRUVIwQ3lJQlFSOTJOZ0lrSUFVZ0FVRUFTQVIvSUFGQkFYUUZJQVVnQVVFY2RqWUNaQ0FEUVFGcUlRTWdBVUVFZEFzaUFVRWZkallDS0NBQlFRQklCSDhnQVVFQmRBVWdCU0FCUVJ4Mk5nSm9JQU5CQVdvaEF5QUJRUVIwQ3lFR0FrQWdBQ0FEUVFOc1FRaHFFQXRCZjBZTkFDQUhRUUUyQWdnZ0JTQUFFQThpQVVFZmRqWUNMQUovSUFGQkFFZ0VRQ0FCUVFGMElRWkJBQXdCQ3lBRklBRkJISFkyQW13Z0FVRUVkQ0VHUVFFTElRTWdCU0FHUVI5Mk5nSXdJQVVnQmtFQVNBUi9JQVpCQVhRRklBVWdCa0VjZGpZQ2NDQURRUUZxSVFNZ0JrRUVkQXNpQVVFZmRqWUNOQ0FGSUFGQkFFZ0VmeUFCUVFGMEJTQUZJQUZCSEhZMkFuUWdBMEVCYWlFRElBRkJCSFFMSWdGQkgzWTJBamdnQlNBQlFRQklCSDhnQVVFQmRBVWdCU0FCUVJ4Mk5nSjRJQU5CQVdvaEF5QUJRUVIwQ3lJQlFSOTJOZ0k4SUFWQlFHc2dBVUVBU0FSL0lBRkJBWFFGSUFVZ0FVRWNkallDZkNBRFFRRnFJUU1nQVVFRWRBc2lBVUVmZGpZQ0FDQUZJQUZCQUVnRWZ5QUJRUUYwQlNBRklBRkJISFkyQW9BQklBTkJBV29oQXlBQlFRUjBDeUlCUVI5Mk5nSkVJQVVnQVVFQVNBUi9JQUZCQVhRRklBVWdBVUVjZGpZQ2hBRWdBMEVCYWlFRElBRkJCSFFMSWdGQkgzWTJBa2dnQVVFQVNBUi9JQUZCQVhRRklBVWdBVUVjZGpZQ2lBRWdBMEVCYWlFRElBRkJCSFFMSVFZZ0FDQURRUU5zUVFocUVBdEJmMFlOQUNBSElBWTJBZ3dnQjBFQ05nSUlEQUVMSUFjZ0JqWUNERUVCSVFNTUFRdEJBU0VESUFBZ0IwRU1haEFDRFFBZ0J5Z0NEQ0lCUVFOTERRQWdCU0FCTmdLTUFVRUFJUU1MSUFNTkFRSkFJQXBCQVVjRVFDQUFJQWRCQkdvZ0NrVVFMU0lERFFNZ0JTQUhLQUlFSWdFMkFnUWdBVVVOQWd3QkN5QUZJQVVvQWdBaUFVRjVhaUlEUVFKMFFYQnhJZ1JCVUdvZ0JDQURRUXRMRzBFUFFRQWdBVUVTU3h0eU5nSUVDMEVCSVFNZ0FDQUhRUXhxRUFVTkFTQUhLQUlNSWdGQkdtcEJNMHNOQVNBRklBRTJBZ2dnQlVHUUFtb2hDQ0FGS0FJRUlRUUNRQUpBSUFVb0FnQkJCMGtFUUVFQUlRbEJBeUVEQTBBZ0F5RUJJQVJCQVhFRVFDQUlJQWxCQW5ScVFiZ05haUFBSUFnZ0NVRUdkR3BCT0dvZ0FpQUpJQWdRRFVFUUVBa2lBMEVRZGpZQ0FDQURRUTl4RFFRZ0NDQUpRUUYwYWlBRFFRUjJRZjhCY1RzQkFDQUlJQWxCQVhJaUJrRUNkR3BCdUExcUlBQWdDQ0FHUVFaMGFrRTRhaUFDSUFZZ0NCQU5RUkFRQ1NJRFFSQjJOZ0lBSUFOQkQzRU5CQ0FJSUFaQkFYUnFJQU5CQkhaQi93RnhPd0VBSUFnZ0NVRUNjaUlHUVFKMGFrRzREV29nQUNBSUlBWkJCblJxUVRocUlBSWdCaUFJRUExQkVCQUpJZ05CRUhZMkFnQWdBMEVQY1EwRUlBZ2dCa0VCZEdvZ0EwRUVka0gvQVhFN0FRQWdDQ0FKUVFOeUlnWkJBblJxUWJnTmFpQUFJQWdnQmtFR2RHcEJPR29nQWlBR0lBZ1FEVUVRRUFraUEwRVFkallDQUNBRFFROXhEUVFnQlNBR1FRRjBhaUFEUVFSMlFmOEJjVHNCa0FJTElBUkJBWFloQkNBQlFYOXFJUU1nQ1VFRWFpRUpJQUVOQUFzTUFRdEJBQ0VKSUFBZ0JVSElEbW9nQWtFQUlBZ1FEVUVRRUFraUEwRVBjUTBCSUFVZ0EwRUVka0gvQVhFN0FjQUNJQVZCa0FKcUlRWkJBeUVEQTBBZ0F5RUJJQVJCQVhFRVFDQUdJQWxCQW5ScVFiZ05haUFBSUFZZ0NVRUdkR3BCUEdvZ0FpQUpJQWdRRFVFUEVBa2lBMEVQZGpZQ0FDQURRUTl4RFFNZ0JpQUpRUUYwYWlBRFFRUjJRZjhCY1RzQkFDQUdJQWxCQVhJaUNrRUNkR3BCdUExcUlBQWdCaUFLUVFaMGFrRThhaUFDSUFvZ0NCQU5RUThRQ1NJRFFROTJOZ0lBSUFOQkQzRU5BeUFHSUFwQkFYUnFJQU5CQkhaQi93RnhPd0VBSUFZZ0NVRUNjaUlLUVFKMGFrRzREV29nQUNBR0lBcEJCblJxUVR4cUlBSWdDaUFJRUExQkR4QUpJZ05CRDNZMkFnQWdBMEVQY1EwRElBWWdDa0VCZEdvZ0EwRUVka0gvQVhFN0FRQWdCaUFKUVFOeUlncEJBblJxUWJnTmFpQUFJQVlnQ2tFR2RHcEJQR29nQWlBS0lBZ1FEVUVQRUFraUEwRVBkallDQUNBRFFROXhEUU1nQlNBS1FRRjBhaUFEUVFSMlFmOEJjVHNCa0FJTElBUkJBWFloQkNBQlFYOXFJUU1nQ1VFRWFpRUpJQUVOQUFzTElBUkJBM0VFUUNBQUlBVkJpQTlxUVg5QkJCQUpJZ05CRDNFTkFTQUZJQU5CQkhaQi93RnhPd0hDQWlBQUlBVkJtQTlxUVg5QkJCQUpJZ05CRDNFTkFTQUZJQU5CQkhaQi93RnhPd0hFQWd0QkFDRURJQVJCQW5GRkRRQWdBQ0FGUWN3S2FpQUNRUkFnQ0JBTlFROFFDU0lCUVE5eEJFQWdBU0VEREFFTElBVkJpQkJxSUFGQkQzWTJBZ0FnQlNBQlFRUjJRZjhCY1RzQnNBSWdBQ0FGUVl3TGFpQUNRUkVnQ0JBTlFROFFDU0lCUVE5eEJFQWdBU0VEREFFTElBVkJqQkJxSUFGQkQzWTJBZ0FnQlNBQlFRUjJRZjhCY1RzQnNnSWdBQ0FGUWN3TGFpQUNRUklnQ0JBTlFROFFDU0lCUVE5eEJFQWdBU0VEREFFTElBVkJrQkJxSUFGQkQzWTJBZ0FnQlNBQlFRUjJRZjhCY1RzQnRBSWdBQ0FGUVl3TWFpQUNRUk1nQ0JBTlFROFFDU0lCUVE5eEJFQWdBU0VEREFFTElBVkJsQkJxSUFGQkQzWTJBZ0FnQlNBQlFRUjJRZjhCY1RzQnRnSWdBQ0FGUWN3TWFpQUNRUlFnQ0JBTlFROFFDU0lCUVE5eEJFQWdBU0VEREFFTElBVkJtQkJxSUFGQkQzWTJBZ0FnQlNBQlFRUjJRZjhCY1RzQnVBSWdBQ0FGUVl3TmFpQUNRUlVnQ0JBTlFROFFDU0lCUVE5eEJFQWdBU0VEREFFTElBVkJuQkJxSUFGQkQzWTJBZ0FnQlNBQlFRUjJRZjhCY1RzQnVnSWdBQ0FGUWN3TmFpQUNRUllnQ0JBTlFROFFDU0lCUVE5eEJFQWdBU0VEREFFTElBVkJvQkJxSUFGQkQzWTJBZ0FnQlNBQlFRUjJRZjhCY1RzQnZBSWdBQ0FGUVl3T2FpQUNRUmNnQ0JBTlFROFFDU0lCUVE5eEJFQWdBU0VEREFFTElBVkJwQkJxSUFGQkQzWTJBZ0FnQlNBQlFRUjJRZjhCY1RzQnZnSUxJQUFnQUNnQ0NDQUFLQUlFSUFBb0FnQnJRUU4wYWpZQ0VDQUREUUVMUVFBaEF3c2dCMEVRYWlRQUlBTUxwUlFCREg4Q2Z5QUFLQUxJQVNJSEJFQWdBQ2dDQkNBSEtBSUVSZ3dCQzBFQUN5RUtBa0FnQmtVTkFDQUtSUTBBUVFBZ0NrRUNJQUFvQXNnQktBSUFJZ2RCQmtjZ0IwRUdTUnRCQWtZYklRb0xBbjhnQUNnQ3pBRWlCd1JBSUFBb0FnUWdCeWdDQkVZTUFRdEJBQXNoQndKQUlBWkZEUUFnQjBVTkFFRUFJQWRCQWlBQUtBTE1BU2dDQUNJSFFRWkhJQWRCQmtrYlFRSkdHeUVIQ3dKL0lBQW9BdFFCSWdrRVFDQUFLQUlFSUFrb0FnUkdEQUVMUVFBTElRa0NRQ0FHUlEwQUlBbEZEUUJCQWlBQUtBTFVBU2dDQUNJQVFRWkhJQUJCQmtrYlFRSkhJUWtMSUFwQkFFY2dCMEVBUjNFaURTQUpRUUJIY1NFT0lBVkJBa3NoRDBFUUlRc0RRQUpBSUE5RkJFQUNRQUpBQWtBZ0JVRUJhdzRDQVFJQUN5QUJBbjhnRFFSQUlBUXRBQU1nQkMwQUFpQUVMUUFCSUFRdEFBQWdBeTBBQkNBRExRQURJQU10QUFFZ0F5MEFBbXBxYW1wcWFtcEJCR3BCQTNZaEJpQURMUUFJSUFNdEFBY2dBeTBBQlNBRExRQUdhbXBxUVFKcVFRSjJEQUVMSUFjRVFDQURMUUFFSUFNdEFBTWdBeTBBQVNBRExRQUNhbXBxUVFKcVFRSjJJUVlnQXkwQUNDQURMUUFISUFNdEFBVWdBeTBBQm1wcWFrRUNha0VDZGd3QkN5QUtSUVJBUVlBQklRWkJnQUVNQVFzZ0JDMEFBeUFFTFFBQ0lBUXRBQUFnQkMwQUFXcHFha0VDYWtFQ2RpSUdDMEgvQVhGQmdZS0VDR3dpQURZQUhDQUJJQVpCL3dGeFFZR0NoQWhzSWdZMkFCZ2dBU0FBTmdBVUlBRWdCallBRUNBQklBQTJBQXdnQVNBR05nQUlJQUVnQURZQUJDQUJJQVkyQUFBQ2Z5QUtCRUFnQkMwQUJ5QUVMUUFHSUFRdEFBVWdCQzBBQkdwcWFpSUdRUUpxUVFKMklnQWdCMFVOQVJvZ0F5MEFDQ0FETFFBSElBTXRBQVlnQmlBRExRQUZhbXBxYWtFRWFrRURkZ3dCQ3lBSFJRUkFRWUFCSVFCQmdBRU1BUXNnQXkwQUJDQURMUUFESUFNdEFBRWdBeTBBQW1wcWFrRUNha0VDZGlFQUlBTXRBQWdnQXkwQUJ5QURMUUFGSUFNdEFBWnFhbXBCQW1wQkFuWUxJUVlnQVNBQVFmOEJjVUdCZ29RSWJDSUFOZ0FnSUFFZ0JrSC9BWEZCZ1lLRUNHd2lCallBUENBQklBQTJBRGdnQVNBR05nQTBJQUVnQURZQU1DQUJJQVkyQUN3Z0FTQUFOZ0FvSUFFZ0JqWUFKQXdEQ3lBS1JRUkFRUUVQQ3lBQklBUXRBQUE2QUFBZ0FTQUVMUUFBT2dBQklBRWdCQzBBQURvQUFpQUJJQVF0QUFBNkFBTWdBU0FFTFFBQU9nQUVJQUVnQkMwQUFEb0FCU0FCSUFRdEFBQTZBQVlnQVNBRUxRQUFPZ0FISUFFZ0JDMEFBVG9BQ0NBQklBUXRBQUU2QUFrZ0FTQUVMUUFCT2dBS0lBRWdCQzBBQVRvQUN5QUJJQVF0QUFFNkFBd2dBU0FFTFFBQk9nQU5JQUVnQkMwQUFUb0FEaUFCSUFRdEFBRTZBQThnQVNBRUxRQUNPZ0FRSUFFZ0JDMEFBam9BRVNBQklBUXRBQUk2QUJJZ0FTQUVMUUFDT2dBVElBRWdCQzBBQWpvQUZDQUJJQVF0QUFJNkFCVWdBU0FFTFFBQ09nQVdJQUVnQkMwQUFqb0FGeUFCSUFRdEFBTTZBQmdnQVNBRUxRQURPZ0FaSUFFZ0JDMEFBem9BR2lBQklBUXRBQU02QUJzZ0FTQUVMUUFET2dBY0lBRWdCQzBBQXpvQUhTQUJJQVF0QUFNNkFCNGdBU0FFTFFBRE9nQWZJQUVnQkMwQUJEb0FJQ0FCSUFRdEFBUTZBQ0VnQVNBRUxRQUVPZ0FpSUFFZ0JDMEFCRG9BSXlBQklBUXRBQVE2QUNRZ0FTQUVMUUFFT2dBbElBRWdCQzBBQkRvQUppQUJJQVF0QUFRNkFDY2dBU0FFTFFBRk9nQW9JQUVnQkMwQUJUb0FLU0FCSUFRdEFBVTZBQ29nQVNBRUxRQUZPZ0FySUFFZ0JDMEFCVG9BTENBQklBUXRBQVU2QUMwZ0FTQUVMUUFGT2dBdUlBRWdCQzBBQlRvQUx5QUJJQVF0QUFZNkFEQWdBU0FFTFFBR09nQXhJQUVnQkMwQUJqb0FNaUFCSUFRdEFBWTZBRE1nQVNBRUxRQUdPZ0EwSUFFZ0JDMEFCam9BTlNBQklBUXRBQVk2QURZZ0FTQUVMUUFHT2dBM0lBRWdCQzBBQnpvQU9DQUJJQVF0QUFjNkFEa2dBU0FFTFFBSE9nQTZJQUVnQkMwQUJ6b0FPeUFCSUFRdEFBYzZBRHdnQVNBRUxRQUhPZ0E5SUFFZ0JDMEFCem9BUGlBQklBUXRBQWM2QUQ4TUFnc2dCMFVFUUVFQkR3c2dBU0FETFFBQk9nQUFJQUVnQXkwQUFUb0FDQ0FCSUFNdEFBRTZBQkFnQVNBRExRQUJPZ0FZSUFFZ0F5MEFBVG9BSUNBQklBTXRBQUU2QUNnZ0FTQURMUUFCT2dBd0lBRWdBeTBBQVRvQU9DQUJJQU10QUFJNkFBRWdBU0FETFFBQ09nQUpJQUVnQXkwQUFqb0FFU0FCSUFNdEFBSTZBQmtnQVNBRExRQUNPZ0FoSUFFZ0F5MEFBam9BS1NBQklBTXRBQUk2QURFZ0FTQURMUUFDT2dBNUlBRWdBeTBBQXpvQUFpQUJJQU10QUFNNkFBb2dBU0FETFFBRE9nQVNJQUVnQXkwQUF6b0FHaUFCSUFNdEFBTTZBQ0lnQVNBRExRQURPZ0FxSUFFZ0F5MEFBem9BTWlBQklBTXRBQU02QURvZ0FTQURMUUFFT2dBRElBRWdBeTBBQkRvQUN5QUJJQU10QUFRNkFCTWdBU0FETFFBRU9nQWJJQUVnQXkwQUJEb0FJeUFCSUFNdEFBUTZBQ3NnQVNBRExRQUVPZ0F6SUFFZ0F5MEFCRG9BT3lBQklBTXRBQVU2QUFRZ0FTQURMUUFGT2dBTUlBRWdBeTBBQlRvQUZDQUJJQU10QUFVNkFCd2dBU0FETFFBRk9nQWtJQUVnQXkwQUJUb0FMQ0FCSUFNdEFBVTZBRFFnQVNBRExRQUZPZ0E4SUFFZ0F5MEFCam9BQlNBQklBTXRBQVk2QUEwZ0FTQURMUUFHT2dBVklBRWdBeTBBQmpvQUhTQUJJQU10QUFZNkFDVWdBU0FETFFBR09nQXRJQUVnQXkwQUJqb0FOU0FCSUFNdEFBWTZBRDBnQVNBRExRQUhPZ0FHSUFFZ0F5MEFCem9BRGlBQklBTXRBQWM2QUJZZ0FTQURMUUFIT2dBZUlBRWdBeTBBQnpvQUppQUJJQU10QUFjNkFDNGdBU0FETFFBSE9nQTJJQUVnQXkwQUJ6b0FQaUFCSUFNdEFBZzZBQWNnQVNBRExRQUlPZ0FQSUFFZ0F5MEFDRG9BRnlBQklBTXRBQWc2QUI4Z0FTQURMUUFJT2dBbklBRWdBeTBBQ0RvQUx5QUJJQU10QUFnNkFEY2dBU0FETFFBSU9nQS9EQUVMSUE1RkJFQkJBUThMSUFNdEFBVWdBeTBBQTJzZ0F5MEFCaUFETFFBQ2EwRUJkR29nQXkwQUJ5QURMUUFCYTBFRGJHb2dBeTBBQ0NJQUlBTXRBQUFpQ1d0QkFuUnFRUkZzUVJCcVFRVjFJZ1pCZld3aEVDQUFJQVF0QUFjaURHcEJCSFFnQkMwQUJDQUVMUUFDYXlBTUlBbHJRUUowYWlBRUxRQUZJQVF0QUFGclFRRjBhaUFFTFFBR0lBUXRBQUJyUVFOc2FrRVJiRUVRYWtFRmRTSVJRWDFzYWtFUWFpRUpRUWdoRENBQklRQURRQ0FBSUFrZ0VHb2lDRUVGZFVHd0xtb3RBQUE2QUFBZ0FDQUdJQWhxSWdoQkJYVkJzQzVxTFFBQU9nQUJJQUFnQmlBSWFpSUlRUVYxUWJBdWFpMEFBRG9BQWlBQUlBWWdDR29pQ0VFRmRVR3dMbW90QUFBNkFBTWdBQ0FHSUFocUlnaEJCWFZCc0M1cUxRQUFPZ0FFSUFBZ0JpQUlhaUlJUVFWMVFiQXVhaTBBQURvQUJTQUFJQVlnQ0dvaUNFRUZkVUd3TG1vdEFBQTZBQVlnQUNBR0lBaHFRUVYxUWJBdWFpMEFBRG9BQnlBSklCRnFJUWtnQUVFSWFpRUFJQXhCZjJvaURBMEFDd3NnQVNBQ0lBc1FDQ0FCSUFKQlFHc2dDMEVCY2hBSUlBRWdBa0dBQVdvZ0MwRUNjaEFJSUFFZ0FrSEFBV29nQzBFRGNoQUlJQUpCZ0FKcUlRSWdCRUVJYWlFRUlBTkJDV29oQXlBQlFVQnJJUUVnQzBFRWFpRUxJQkpCQVdvaUVrRUNSdzBBQzBFQUM2RVZBaGgvQW40Q2Z3TkFBbjhnQUNJSUlCWkJBM1JCc0RWcUtRSUFJaDZuRUJFaUNTSUdCRUFnQ0NnQ0JDQUdLQUlFUmd3QkMwRUFDeUVOQWtBZ0JVVU5BQ0FOUlEwQVFRQWdEVUVDSUFrb0FnQWlCa0VHUnlBR1FRWkpHMEVDUmhzaERRc0NmeUFJSUJaQkEzUkI4RFpxS1FJQUloK25FQkVpQnlJR0JFQWdDQ2dDQkNBR0tBSUVSZ3dCQzBFQUN5RVBBa0FnQlVVTkFDQVBSUTBBUVFBZ0QwRUNJQWNvQWdBaUJrRUdSeUFHUVFaSkcwRUNSaHNoRHd0QkFpRU1JQTFCQUVjZ0QwRUFSM0VpRWtFQlJnUkFRUUloQmdKL1FRSWdDU2dDQUNJTFFRWkhJQXRCQmtrYlJRUkFJQWtnSGtJZ2lLZEIvd0Z4YWkwQVVpRUdDeUFHQ3dKL1FRSWdCeWdDQUNJSlFRWkhJQWxCQmtrYlJRUkFJQWNnSDBJZ2lLZEIvd0Z4YWkwQVVpRU1DeUFNQ3lBR0lBeEpHeUVNQ3lBQ0lCWkJBblFpQ1dvaUJpZ0NERVVFUUNBR0tBSk1JZ1lnQmlBTVQyb2hEQXNnQ0NBV2FpQU1PZ0JTQW44Z0NDQVdRUU4wUWJBNGFpZ0NBQkFSSWdZaUJ3UkFJQWdvQWdRZ0J5Z0NCRVlNQVF0QkFBc2hEZ0pBSUFWRkRRQWdEa1VOQUVFQUlBNUJBaUFHS0FJQUlnWkJCa2NnQmtFR1NSdEJBa1liSVE0TEFuOGdBQ0FXUVFOMFFmQTVhaWdDQUJBUklnZ2lCZ1JBSUFBb0FnUWdCaWdDQkVZTUFRdEJBQXNoRVFKQUlBVkZEUUFnRVVVTkFFRUFJQkZCQWlBSUtBSUFJZ2hCQmtjZ0NFRUdTUnRCQWtZYklSRUxJQWxCOENscUtBSUFJUmNnQ1VHd0tXb29BZ0FoR0FKL1FZVUtJQloyUVFGeElod0VRQ0FYUVFOcUlRY2dCQ0FYYWlJSVFRSnFJUVlnQ0VFQmFpRUxJQVFNQVFzZ0YwRUVkQ0FZYWlJSVFTOXFJUWNnQVNBSWFpSUlRUjlxSVFZZ0NFRVBhaUVMSUFoQmYyb2hDQ0FCQ3lFSklBY2dDV290QUFBaENpQUdMUUFBSVJBZ0N5MEFBQ0VUSUFndEFBQWhGQUpBUVRNZ0ZuWkJBWEVFUUNBRElCaHFJZ2N0QUFnaEd5QUhMUUFISVJrZ0J5MEFCaUVWSUFjdEFBVWhHaUFITFFBRUlRWWdCeTBBQXlFTElBY3RBQUloQ1NBSExRQUJJUWdNQVFzZ0FTQVhRWDlxSWgxQkJIUWdHR3BxSWdjdEFBQWhDQ0FITFFBSElSc2dCeTBBQmlFWklBY3RBQVVoRlNBSExRQUVJUm9nQnkwQUF5RUdJQWN0QUFJaEN5QUhMUUFCSVFrZ0hBUkFJQVFnSFdvaEJ3d0JDeUFIUVg5cUlRY0xBa0FnREVFSFRRUkFJQWN0QUFBaEJ3SkFBa0FDUUFKQUFrQUNRQUpBQWtBZ0RFRUJhdzRIQVFJREJBVUdCd0FMSUE5RkJFQkJBUThMSUFoQi93RnhJQXRCL3dGeFFSQjBJQVpCR0hSeWNpQUpRZjhCY1VFSWRISWhGU0FJSWd3aERTQUpJZzRoRWlBTElnOGhDaUFHSWhFaEJ3d0lDeUFOUlFSQVFRRVBDeUFLUVlHQ2hBaHNJUlVnRUVHQmdvUUliQ0lOUVJoMklRY2dEVUVRZGlFS0lBMUJDSFloRWlBVFFZR0NoQWhzSWd4QkdIWWhFU0FNUVJCMklROGdERUVJZGlFT0lCUkJnWUtFQ0d3aUNFRVlkaUVHSUFoQkVIWWhDeUFJUVFoMklRa01Cd3NDZnlBVElCUnFJQXBxSUJCcUlBWkIvd0Z4YWlBTFFmOEJjV29nQ1VIL0FYRnFJQWhCL3dGeGFrRUVha0VEZGlBU0RRQWFJQk1nRkdvZ0Ntb2dFR3BCQW1wQkFuWWdEUTBBR2tHQUFTQVBSUTBBR2lBR1FmOEJjU0FMUWY4QmNXb2dDVUgvQVhGcUlBaEIvd0Z4YWtFQ2FrRUNkZ3NpQ0VHQmdvUUliQ0VWSUFnaUNTSUxJZ1lpRENJT0lnOGlFU0lOSWhJaUNpRUhEQVlMSUE5RkJFQkJBUThMSUFaQi93RnhJZzFCQW1vaUVTQVZJQVlnRGh0Qi93RnhJZ2RxSUJvZ0JpQU9HMEgvQVhFaUNrRUJkR3BCQW5ZaUR5QVpJQVlnRGh0Qi93RnhJZ3dnR3lBR0lBNGJRZjhCY1NJR1FRTnNha0VXZEVHQWdJQUVha0dBZ0lCNGNYSWdDaUFNYWlBSFFRRjBha0VDYWlJUVFRWjBRWUQrQTNGeUlBWWdCMm9nREVFQmRHcEJBbW9pQmtFT2RFR0FnUHdIY1hJaEZTQUdRUUoySVFjZ0MwSC9BWEVpQmtFQ2FpSUxJQWhCL3dGeGFpQUpRZjhCY1NJSlFRRjBha0VDZGlFSUlBa2dFV29nQmtFQmRHcEJBbllpQ1NFTUlBb2dDMm9nRFVFQmRHcEJBbllpQ3lFT0lBc2hEU0FQSWdZaEVpQVFRUUoySWhFaENnd0ZDMEVCSUJGRklCSkJBWE55RFFZYUlCUWdFMEVCZEdvZ0VHcEJBbW9pRGtFR2RFR0EvZ054SUFvZ0UwRUNhaUlQYWlBUVFRRjBha0VDZG5JZ0NFSC9BWEVpQ2tFQ2FpSU1JQlJxSUFkQkFYUnFRUUoySWdoQkdIUnlJQThnRkVFQmRHb2dCMm9pRUVFT2RFR0FnUHdIY1hJaEZTQUpRZjhCY1NJUlFRSnFJZ2tnQmtIL0FYRnFJQXRCL3dGeElndEJBWFJxUVFKMklRWWdEa0VDZGlFTklBa2dDa0VCZEdvZ0IycEJBbllpQ1NFUElCRkJBWFFnQzJvZ0RHcEJBbllpQ3lFUklCQkJBbllpRENFU0lBZ2lEaUVLSUFraEJ3d0VDMEVCSUJGRklCSkJBWE55RFFVYUlBaEIvd0Z4SWdwQkFtb2lEaUFMUWY4QmNTSUlJQWxCL3dGeElndEJBWFJxYWtFQ2RpSVBRUmgwSUJRZ0UwRUJkR29nRUdwQkFtcEJBblp5SUE0Z0ZHb2dCMEVCZEdvaUNVRUdkRUdBL2dOeGNpQUxRUUpxSWc0Z0NrRUJkR29nQjJvaURVRU9kRUdBZ1B3SGNYSWhGU0FJUVFGcUloQWdCa0gvQVhFaURHcEJBWFloQmlBTUlBNXFJQWhCQVhScVFRSjJJUkVnQ1VFQ2RpRU1JQTFCQW5ZaERpQVRJQlJCQVhScUlBZHFRUUpxUVFKMklRMGdCeUFLYWtFQmFrRUJkaUlJSVJJZ0NpQUxha0VCYWtFQmRpSUpJUW9nQ3lBUWFrRUJkaUlMSVFjTUF3dEJBU0FSUlNBU1FRRnpjZzBFR2lBVFFRSnFJZzRnQ21vZ0VFRUJkR3BCQm5SQmdQNERjU0FRSUJOcVFRRnFJZzlCRDNSQmdJRDhCM0VnRkVFQ2FpSU1JQk5CQVhScUlCQnFRUUoySWhKQkdIUnlJQW9nRUdwQkFXcEJBWFp5Y2lFVklBaEIvd0Z4SWdnZ0MwSC9BWEZxSUFsQi93RnhJZ2xCQVhScVFRSnFRUUoySVFZZ0NTQUlRUUYwYWlBSGFrRUNha0VDZGlFTElBOUJBWFloRFNBSUlBeHFJQWRCQVhScVFRSjJJaEVoQ1NBVVFRRnFJZ29nQjJwQkFYWWlDQ0VQSUFvZ0UycEJBWFlpRENFS0lBNGdGRUVCZEdvZ0IycEJBbllpRGlFSERBSUxJQTlGQkVCQkFROExJQm9nQmlBT0cwSC9BWEVpQ2lBWklBWWdEaHRCL3dGeGFpQVZJQVlnRGh0Qi93RnhJZ2RCQVhScVFSWjBJQXRCL3dGeElndEJBbW9pRENBS2FpQUdRZjhCY1NJR1FRRjBhaUlQUVFaMGNrR0FnSUFFYWtHQS9vTjRjU0FHUVFKcUlnMGdDVUgvQVhFaUNXb2dDMEVCZEdwQkFuWWlEbklnQnlBTmFpQUtRUUYwYWlJTlFRNTBRWUNBL0FkeGNpRVZJQWNnQ21wQkFXcEJBWFloQnlBTlFRSjJJUkVnQ1NBSVFmOEJjU0lOYWtFQmFrRUJkaUVJSUE5QkFuWWhEeUFNSUExcUlBbEJBWFJxUVFKMklRd2dDU0FMYWtFQmFrRUJkaUlKSVEwZ0JrRUJhaUlHSUF0cVFRRjJJZ3NoRWlBR0lBcHFRUUYySWdZaENnd0JDeUFOUlFSQVFRRVBDeUFLUVFoMElBcHlJQXBCRUhSeUlBcEJHSFJ5SVJVZ0VFRUNhaUlISUJScUlCTkJBWFJxUVFKMklRa2dFMEVCYWlJR0lCUnFRUUYySVFnZ0JpQVFha0VCZGlJTElRd2dDaUFUYWlBUVFRRjBha0VDYWtFQ2RpSUdJUTRnQ2lBUWFrRUJha0VCZGlJUElRMGdCeUFLUVFOc2FrRUNkaUlSSVJJZ0NpRUhDeUFCSUJkQkJIUWdHR3BxSWhBZ0ZUWUNNQ0FRSUExQi93RnhJQkpCL3dGeFFRaDBjaUFLUWY4QmNVRVFkSElnQjBFWWRISTJBaUFnRUNBTVFmOEJjU0FPUWY4QmNVRUlkSElnRDBIL0FYRkJFSFJ5SUJGQkdIUnlOZ0lRSUJBZ0NFSC9BWEVnQ1VIL0FYRkJDSFJ5SUF0Qi93RnhRUkIwY2lBR1FSaDBjallDQUNBQklBSWdGa0VHZEdwQnlBSnFJQllRQ0NBV1FRRnFJaFpCRUVjTkFBdEJBQXNMeFJJQkVIOENmeUFBS0FMSUFTSUhCRUFnQUNnQ0JDQUhLQUlFUmd3QkMwRUFDeUVIQWtBZ0JVVU5BQ0FIUlEwQVFRQWdCMEVDSUFBb0FzZ0JLQUlBSWdkQkJrY2dCMEVHU1J0QkFrWWJJUWNMQW44Z0FDZ0N6QUVpQ0FSQUlBQW9BZ1FnQ0NnQ0JFWU1BUXRCQUFzaENBSkFJQVZGRFFBZ0NFVU5BRUVBSUFoQkFpQUFLQUxNQVNnQ0FDSUlRUVpISUFoQkJra2JRUUpHR3lFSUN3Si9JQUFvQXRRQklna0VRQ0FBS0FJRUlBa29BZ1JHREFFTFFRQUxJUWtDUUNBRlJRMEFJQWxGRFFCQkFpQUFLQUxVQVNnQ0FDSUZRUVpISUFWQkJra2JRUUpISVFrTEFrQUNRQ0FBS0FJQVFRRnFRUU54SWdCQkFrMEVRQUpBQWtBQ1FDQUFRUUZyRGdJQkFnQUxJQWhGQkVCQkFROExRUUFoQlNBQklRQURRQ0FBSUFNdEFBRTZBQUFnQUNBRExRQUNPZ0FCSUFBZ0F5MEFBem9BQWlBQUlBTXRBQVE2QUFNZ0FDQURMUUFGT2dBRUlBQWdBeTBBQmpvQUJTQUFJQU10QUFjNkFBWWdBQ0FETFFBSU9nQUhJQUFnQXkwQUNUb0FDQ0FBSUFNdEFBbzZBQWtnQUNBRExRQUxPZ0FLSUFBZ0F5MEFERG9BQ3lBQUlBTXRBQTA2QUF3Z0FDQURMUUFPT2dBTklBQWdBeTBBRHpvQURpQUFJQU10QUJBNkFBOGdBRUVRYWlFQUlBVkJBV29pQlVFUVJ3MEFDd3dEQ3lBSFJRUkFRUUVQQzBFQUlRVWdBU0VBQTBBZ0FDQUVJQVZxSWdNdEFBQTZBQUFnQUNBRExRQUFPZ0FCSUFBZ0F5MEFBRG9BQWlBQUlBTXRBQUE2QUFNZ0FDQURMUUFBT2dBRUlBQWdBeTBBQURvQUJTQUFJQU10QUFBNkFBWWdBQ0FETFFBQU9nQUhJQUFnQXkwQUFEb0FDQ0FBSUFNdEFBQTZBQWtnQUNBRExRQUFPZ0FLSUFBZ0F5MEFBRG9BQ3lBQUlBTXRBQUE2QUF3Z0FDQURMUUFBT2dBTklBQWdBeTBBQURvQURpQUFJQU10QUFBNkFBOGdBRUVRYWlFQUlBVkJBV29pQlVFUVJ3MEFDd3dDQ3lBQkFuOENRQ0FIUlEwQUlBaEZEUUFnQkMwQUR5QURMUUFRSUFRdEFBNGdBeTBBRHlBRUxRQU5JQU10QUE0Z0JDMEFEQ0FETFFBTklBUXRBQXNnQXkwQURDQUVMUUFLSUFNdEFBc2dCQzBBQ1NBRExRQUtJQVF0QUFnZ0F5MEFDU0FFTFFBSElBTXRBQWdnQkMwQUJpQURMUUFISUFRdEFBVWdBeTBBQmlBRUxRQUVJQU10QUFVZ0JDMEFBeUFETFFBRUlBUXRBQUlnQXkwQUF5QUVMUUFCSUFNdEFBSWdBeTBBQVNBRUxRQUFhbXBxYW1wcWFtcHFhbXBxYW1wcWFtcHFhbXBxYW1wcWFtcHFhbXBxYWtFUWFrRUZkZ3dCQ3lBSEJFQWdCQzBBRHlBRUxRQU9JQVF0QUEwZ0JDMEFEQ0FFTFFBTElBUXRBQW9nQkMwQUNTQUVMUUFJSUFRdEFBY2dCQzBBQmlBRUxRQUZJQVF0QUFRZ0JDMEFBeUFFTFFBQ0lBUXRBQUFnQkMwQUFXcHFhbXBxYW1wcWFtcHFhbXBxYWtFSWFrRUVkZ3dCQzBHQUFTQUlSUTBBR2lBRExRQVFJQU10QUE4Z0F5MEFEaUFETFFBTklBTXRBQXdnQXkwQUN5QURMUUFLSUFNdEFBa2dBeTBBQ0NBRExRQUhJQU10QUFZZ0F5MEFCU0FETFFBRUlBTXRBQU1nQXkwQUFTQURMUUFDYW1wcWFtcHFhbXBxYW1wcWFtcHFRUWhxUVFSMkMwR0FBaEFIR2d3QkMwRUJJUUFnQjBVTkFTQUlSUTBCSUFsRkRRRWdCQzBBQ0NBRUxRQUdheUFFTFFBUElnQWdBeTBBQUNJRmEwRURkR29nQkMwQUNTQUVMUUFGYTBFQmRHb2dCQzBBQ2lBRUxRQUVhMEVEYkdvZ0JDMEFDeUFFTFFBRGEwRUNkR29nQkMwQURDQUVMUUFDYTBFRmJHb2dCQzBBRFNBRUxRQUJhMEVHYkdvZ0JDMEFEaUFFTFFBQWEwRUhiR3BCQld4QklHcEJCblVoQnlBRExRQUpJQU10QUFkcklBTXRBQW9nQXkwQUJtdEJBWFJxSUFNdEFBc2dBeTBBQld0QkEyeHFJQU10QUF3Z0F5MEFCR3RCQW5ScUlBTXRBQTBnQXkwQUEydEJCV3hxSUFNdEFBNGdBeTBBQW10QkJteHFJQU10QUE4Z0F5MEFBV3RCQjJ4cUlBTXRBQkFpQXlBRmEwRURkR3BCQld4QklHcEJCblVpQkVFRGRDRUlJQVJCQjJ3aENTQUVRUVpzSVFvZ0JFRUZiQ0VMSUFSQkEyd2hEQ0FFUVgxc0lRMGdCRUY3YkNFT0lBUkJlbXdoRHlBRVFYbHNJUkJCQUNBRVFRRjBJaEZySVJKQkFDQUVRUUowSWhOcklSUWdBQ0FEYWtFRWRFRVFhaUVWUVFBaEJRTkFJQUVnQlVFRWRDSUFhaUFWSUFWQmVXb2dCMnhxSWdNZ0VHcEJCWFVpQmtIL0FTQUdRZjhCU0JzaUJrRUFJQVpCQUVvYk9nQUFJQUVnQUVFQmNtb2dBeUFQYWtFRmRTSUdRZjhCSUFaQi93RklHeUlHUVFBZ0JrRUFTaHM2QUFBZ0FTQUFRUUp5YWlBRElBNXFRUVYxSWdaQi93RWdCa0gvQVVnYklnWkJBQ0FHUVFCS0d6b0FBQ0FCSUFCQkEzSnFJQU1nRkdwQkJYVWlCa0gvQVNBR1FmOEJTQnNpQmtFQUlBWkJBRW9iT2dBQUlBRWdBRUVFY21vZ0F5QU5ha0VGZFNJR1FmOEJJQVpCL3dGSUd5SUdRUUFnQmtFQVNoczZBQUFnQVNBQVFRVnlhaUFESUJKcVFRVjFJZ1pCL3dFZ0JrSC9BVWdiSWdaQkFDQUdRUUJLR3pvQUFDQUJJQUJCQm5KcUlBTWdCR3RCQlhVaUJrSC9BU0FHUWY4QlNCc2lCa0VBSUFaQkFFb2JPZ0FBSUFFZ0FFRUhjbW9nQTBFRmRTSUdRZjhCSUFaQi93RklHeUlHUVFBZ0JrRUFTaHM2QUFBZ0FTQUFRUWh5YWlBRElBUnFRUVYxSWdaQi93RWdCa0gvQVVnYklnWkJBQ0FHUVFCS0d6b0FBQ0FCSUFCQkNYSnFJQU1nRVdwQkJYVWlCa0gvQVNBR1FmOEJTQnNpQmtFQUlBWkJBRW9iT2dBQUlBRWdBRUVLY21vZ0F5QU1ha0VGZFNJR1FmOEJJQVpCL3dGSUd5SUdRUUFnQmtFQVNoczZBQUFnQVNBQVFRdHlhaUFESUJOcVFRVjFJZ1pCL3dFZ0JrSC9BVWdiSWdaQkFDQUdRUUJLR3pvQUFDQUJJQUJCREhKcUlBTWdDMnBCQlhVaUJrSC9BU0FHUWY4QlNCc2lCa0VBSUFaQkFFb2JPZ0FBSUFFZ0FFRU5jbW9nQXlBS2FrRUZkU0lHUWY4QklBWkIvd0ZJR3lJR1FRQWdCa0VBU2hzNkFBQWdBU0FBUVE1eWFpQURJQWxxUVFWMUlnWkIvd0VnQmtIL0FVZ2JJZ1pCQUNBR1FRQktHem9BQUNBQklBQkJEM0pxSUFNZ0NHcEJCWFVpQUVIL0FTQUFRZjhCU0JzaUFFRUFJQUJCQUVvYk9nQUFJQVZCQVdvaUJVRVFSdzBBQ3d0QkFDRUFJQUVnQWtFQUVBZ2dBU0FDUVVCclFRRVFDQ0FCSUFKQmdBRnFRUUlRQ0NBQklBSkJ3QUZxUVFNUUNDQUJJQUpCZ0FKcVFRUVFDQ0FCSUFKQndBSnFRUVVRQ0NBQklBSkJnQU5xUVFZUUNDQUJJQUpCd0FOcVFRY1FDQ0FCSUFKQmdBUnFRUWdRQ0NBQklBSkJ3QVJxUVFrUUNDQUJJQUpCZ0FWcVFRb1FDQ0FCSUFKQndBVnFRUXNRQ0NBQklBSkJnQVpxUVF3UUNDQUJJQUpCd0FacVFRMFFDQ0FCSUFKQmdBZHFRUTRRQ0NBQklBSkJ3QWRxUVE4UUNBc2dBQXZCQ0FFSGZ3SkFJQU5GRFFBZ0FDZ0NBQ0FESUFBb0FnUWlCVzRpQ0NBRmJDSUVRUWgwYWlBRElBUnJJZ2RCQkhScUlRWWdCVUVFZENFRUlBQW9BZ2doQ1NBRklBTkxJZ3BGQkVBZ0FTQUdJQVJCZjNOcUlnTXRBQUE2QUFBZ0FTQUdJQVJyTFFBQU9nQUJJQUVnQXkwQUFqb0FBaUFCSUFNdEFBTTZBQU1nQVNBRExRQUVPZ0FFSUFFZ0F5MEFCVG9BQlNBQklBTXRBQVk2QUFZZ0FTQURMUUFIT2dBSElBRWdBeTBBQ0RvQUNDQUJJQU10QUFrNkFBa2dBU0FETFFBS09nQUtJQUVnQXkwQUN6b0FDeUFCSUFNdEFBdzZBQXdnQVNBRExRQU5PZ0FOSUFFZ0F5MEFEam9BRGlBQklBTXRBQTg2QUE4Z0FTQURMUUFRT2dBUUlBRWdBeTBBRVRvQUVTQUJJQU10QUJJNkFCSWdBU0FETFFBVE9nQVRJQUVnQXkwQUZEb0FGQ0FCUVJWcUlRRUxJQWNFUUNBQ0lBWkJmMm9pQXkwQUFEb0FBQ0FDSUFNZ0JHb2lBeTBBQURvQUFTQUNJQU1nQkdvaUF5MEFBRG9BQWlBQ0lBTWdCR29pQXkwQUFEb0FBeUFDSUFNZ0JHb2lBeTBBQURvQUJDQUNJQU1nQkdvaUF5MEFBRG9BQlNBQ0lBTWdCR29pQXkwQUFEb0FCaUFDSUFNZ0JHb2lBeTBBQURvQUJ5QUNJQU1nQkdvaUF5MEFBRG9BQ0NBQ0lBTWdCR29pQXkwQUFEb0FDU0FDSUFNZ0JHb2lBeTBBQURvQUNpQUNJQU1nQkdvaUF5MEFBRG9BQ3lBQ0lBTWdCR29pQXkwQUFEb0FEQ0FDSUFNZ0JHb2lBeTBBQURvQURTQUNJQU1nQkdvaUF5MEFBRG9BRGlBQ0lBTWdCR290QUFBNkFBOGdBa0VRYWlFQ0N5QUFLQUlBSUFVZ0NXd2lCa0VJZEdvZ0NDQUZRUU4wSWdCc1FRTjBhaUFIUVFOMGFpRUVJQUJCK1AvLy93ZHhJUUFnQ2tVRVFDQUJJQVFnQUVGL2Myb2lBeTBBQURvQUFDQUJJQVFnQUdzdEFBQTZBQUVnQVNBRExRQUNPZ0FDSUFFZ0F5MEFBem9BQXlBQklBTXRBQVE2QUFRZ0FTQURMUUFGT2dBRklBRWdBeTBBQmpvQUJpQUJJQU10QUFjNkFBY2dBU0FEUVFocUlnTXRBQUE2QUFnZ0FTQUdRUVowSUFOcUlnTkJlR290QUFBNkFBa2dBU0FEUVhscUxRQUFPZ0FLSUFFZ0EwRjZhaTBBQURvQUN5QUJJQU5CZTJvdEFBQTZBQXdnQVNBRFFYeHFMUUFBT2dBTklBRWdBMEY5YWkwQUFEb0FEaUFCSUFOQmZtb3RBQUE2QUE4Z0FTQURRWDlxTFFBQU9nQVFJQUVnQXkwQUFEb0FFUXNnQjBVTkFDQUNJQVJCZjJvaUFTMEFBRG9BQUNBQ0lBQWdBV29pQVMwQUFEb0FBU0FDSUFBZ0FXb2lBUzBBQURvQUFpQUNJQUFnQVdvaUFTMEFBRG9BQXlBQ0lBQWdBV29pQVMwQUFEb0FCQ0FDSUFBZ0FXb2lBUzBBQURvQUJTQUNJQUFnQVdvaUFTMEFBRG9BQmlBQ0lBQWdBV29pQVMwQUFEb0FCeUFDSUFBZ0FXb2dCaUFGYTBFR2RHb2lBUzBBQURvQUNDQUNJQUFnQVdvaUFTMEFBRG9BQ1NBQ0lBQWdBV29pQVMwQUFEb0FDaUFDSUFBZ0FXb2lBUzBBQURvQUN5QUNJQUFnQVdvaUFTMEFBRG9BRENBQ0lBQWdBV29pQVMwQUFEb0FEU0FDSUFBZ0FXb2lBUzBBQURvQURpQUNJQUFnQVdvdEFBQTZBQThMQzY4QkFRRi9Jd0JCMEFCcklnWWtBQ0FDSUFaQklHb2dCaUFERUZVQ1FBSkFRUUlnQUNnQ0FDSURRUVpISUFOQkJra2JRUUZHQkVBZ0FDQUZJQUZCeUFKcUlBWkJJR29nQmlBRUVGUWlBMFVOQVF3Q0N5QUFJQVVnQVNBR1FTQnFJQVlnQkJCVElnTU5BUXNnQUNBRlFZQUNhaUFCUWNnS2FpQUdRVFZxSUFaQkVHb2dBU2dDakFFZ0JCQlNJZ01OQUVFQUlRTWdBQ2dDeEFGQkFVc05BQ0FDSUFVUUd3c2dCa0hRQUdva0FDQURDNk1xQVNSL0l3QkJJR3NpRUNRQUlCQWdCQ2dDQkNJSU5nSU1JQkFnQkNnQ0NEWUNFQ0FESUFodUlnWkJCSFFoRkNBRElBWWdDR3hyUVFSMElSVUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUlBQW9BZ0FpQmtFRFRRUkFBa0FDUUFKQUlBWkJBbXNPQWdFQ0FBc2dBU2dDa0FFaEV5QUFLQUlFSVE1QmZ5RVBBbjhnQUNnQ3lBRWlDVVVFUUVFQUlRaEJmd3dCQzBFQUlRaEJmeUFKS0FJRUlBNUhEUUFhUVFFaEVrRi9JQWtvQWdCQkJVc05BQm9nQ1NnQ21BRWlDRUVRZGlFSElBa29BbWdMSVEwZ0FDZ0N6QUVpQ1VVTkNDQUpLQUlFSUE1SERRaEJBU0VXSUFrb0FnQkJCVXNOQ0NBSktBS3NBU0lSUVJCMklRb2dDU2dDYkNFUERBZ0xJQUVvQXBBQklSTWdBUzhCb2dFaERTQUJMd0dnQVNFTUlBQW9BZ1FoQzBGL0lRY0NRQ0FBS0FMTUFTSUdSUTBBSUFzZ0JpZ0NCRWNFUUF3QkMwRUJJUklnQmlnQ0FFRUZTdzBBSUFZb0Fxd0JJZ2xCRUhZaENpQUdLQUpzSVFjTElBY2dFMFlFUUNBS0lRY2dDU0VHREFjTFFYOGhEd0pBQWtBQ1FDQUFLQUxJQVNJSVJRUkFRUUFoQnd3QkMwRUFJUWNnQ0NnQ0JDQUxSZzBCQzBFQUlRWU1BUXRCQVNFWElBZ29BZ0JCQlVzRVFFRUFJUVlNQVFzZ0NDZ0NtQUVpQmtFUWRpRUhJQWdvQW1naER3c0NRQUpBSUFBb0F0QUJJZ2hGRFFBZ0NDZ0NCQ0FMUncwQUlBZ29BZ0JCQlUwTkFRd0dDd0pBSUFBb0F0UUJJZ2hGRFFBZ0NDZ0NCQ0FMUncwQUlBZ29BZ0JCQlVzTkJpQUlLQUp3SVJZZ0NDZ0N3QUVoQ0F3SEMwRUFJUWhCZnlFV0lCSU5CaUFYUlEwR0RBY0xJQWdvQW13aEZpQUlLQUtzQVNFSURBVUxJQUVvQXBBQklROGdBUzhCb2dFaERTQUJMd0dnQVNFTUlBQW9BZ1FoQmtGL0lRY0NRQ0FBS0FMSUFTSUtSUVJBUVFBaENBd0JDMEVBSVFnZ0JpQUtLQUlFUndSQURBRUxRUUVoRVNBS0tBSUFRUVZMRFFBZ0NpZ0NtQUVpQ1VFUWRpRUlJQW9vQW1naEJ3c2dCeUFQUmcwQkFuOENmd0pBQWtBZ0FDZ0N6QUVpQjBVTkFDQUhLQUlFSUFaSERRQWdCeWdDQUVFRlN3MEJJQWNvQW5BaEVTQUhLQUs4QVNFS0lBY29BbXdoRWlBSEtBS3NBU0lHUVJCMkRBTUxBa0FnQUNnQzFBRWlCMFVOQUNBSEtBSUVJQVpIRFFCQkFDRUdRWDhoRWlBSEtBSUFRUVZMQkVCQmZ5RVJRUUFNQXdzZ0J5Z0NjQ0VSSUFjb0FzQUJEQUlMSUJFTkJBdEJmeUVSUVg4aEVrRUFJUVpCQUFzaENrRUFDeUVISUE4Z0VrWWlDeUFQSUJGR2FrRUJSd1JBSUFjZ0NDQUhRUkIwUVJCMUlnc2dDRUVRZEVFUWRTSU9TaUlJR3lJSElBNGdDeUFPSUFzZ0RrZ2JJQWdiSWdnZ0NrRVFkU0lMSUFnZ0Mwb2JJQWRCRUhSQkVIVWdDMGdiSVFjZ0JpQUpJQVpCRUhSQkVIVWlDeUFKUVJCMFFSQjFJZ2xLSWdZYklnaEIvLzhEY1NBSklBc2dDU0FMSUFsSUd5QUdHeUlHSUFwQkVIUkJFSFVpQ1NBR0lBbEtHeUFJUVJCMFFSQjFJQWxJR3lFR0RBTUxJQXNOQWlBS1FSQjJJUWNnQ2lFR0RBSUxRUUVoR3lBQVFZUUJhaUVjQTBBQ2Z5QUJJQjFCQW5RaUhtb2lJQ0lrS0FLd0FTSUdRUUpOQkVBZ0JrRUNkRUdjTldvb0FnQU1BUXRCQkFzaElpQUFJQjVxSWdZZ0lDZ0N3QUUyQW1RZ0JpQUNJQ0FvQXNBQkVCUWlCallDZENBR1JRMElJQ0lFUUNBY0lCMUJCSFFpSDJvaUpTRW1JQndnSDBFTWNtb2lKMEVDYWlFb0lCd2dIMEVJY21vaUtTRVJJQndnSDBFRWNtb2lGaUVUUVFBaEJnTkFJQUVnSDJvZ0JrRUNkR29pQ0M4QjBnRWhEeUFJTHdIUUFTRU9JQ0FvQXNBQklTRkJmeUVYQW44Z0FDQWRRUWQwSUNRb0FyQUJJaU5CQlhScUlBWkJBM1JxSWhwQnNCbHFLQUlBRUJFaUNVVUVRRUVBSVF4QkFDRUlRUUFoQ2tGL0RBRUxRUUFoREVFQUlRaEJBQ0VLUVg4Z0NTZ0NCQ0FBS0FJRVJ3MEFHa0VCSVFwQmZ5QUpLQUlBUVFWTERRQWFJQWtnR2tHMEdXb3RBQUFpQjBFQ2RHb29Bb1FCSWdoQkVIWWhEQ0FKSUFkQi9BRnhhaWdDWkFzaERRSkFBa0FDUUNBQUlCcEJzQjFxS0FJQUVCRWlHRVVFUUVFQUlRa01BUXRCQUNFSklCZ29BZ1FnQUNnQ0JFWU5BUXRCQUNFU1FRQWhDd3dCQzBFQklRc2dHQ2dDQUVFRlN3UkFRUUFoRWd3QkN5QVlJQnBCdEIxcUxRQUFJZ2RCQW5ScUtBS0VBU0lTUVJCMklRa2dHQ0FIUWZ3QmNXb29BbVFoRndzQ1FBSkFBa0FDUUFKQUlBQWdHa0d3SVdvb0FnQVFFU0laUlEwQUlCa29BZ1FnQUNnQ0JFY05BQ0FaS0FJQVFRVk5EUUVNQWdzQ1FDQUFJQnBCc0NWcUtBSUFFQkVpR1VVTkFDQVpLQUlFSUFBb0FnUkhEUUFnR1NnQ0FFRUZTdzBDSUJrZ0drRzBKV290QUFBaUIwSDhBWEZxS0FKa0lSZ2dHU0FIUVFKMGFpZ0NoQUVoQnd3REMwRUFJUWRCZnlFWUlBcEZEUUlnQ3cwQ0RBTUxJQmtnR2tHMElXb3RBQUFpQjBIOEFYRnFLQUprSVJnZ0dTQUhRUUowYWlnQ2hBRWhCd3dCQzBFQUlRZEJmeUVZQ3lBWElDRkdJZ29nRFNBaFJpSUxhaUFZSUNGR2FrRUJSd1JBSUFrZ0RDQUpRUkIwUVJCMUlnc2dERUVRZEVFUWRTSU1TaUlKR3lJS0lBd2dDeUFNSUFzZ0RFZ2JJQWtiSWdrZ0IwRVFkU0lMSUFrZ0Mwb2JJQXBCRUhSQkVIVWdDMGdiSVF3Z0VpQUlJQkpCRUhSQkVIVWlDaUFJUVJCMFFSQjFJZ3RLSWdnYklnbEIvLzhEY1NBTElBb2dDeUFLSUF0SUd5QUlHeUlJSUFkQkVIUkJFSFVpQnlBSUlBZEtHeUFKUVJCMFFSQjFJQWRJR3lFSURBRUxJQWdnRWlBTEd5RUlJQXdnQ1NBTEd5RU1JQXNOQUNBS0RRQWdCMEVRZGlFTUlBY2hDQXNnQ0NBT2FpSUtRUkIwUVJCMVFZQkFhMEgvL3dCTERRb2dEQ0FQYWlJSlFSQjBRUkIxUVlBUWFrSC9IMHNOQ2lBalFRTk5CRUFDZndKQUFrQUNRQUpBSUNOQkFXc09Bd0VDQXdBTElDVWdDanNCQUNBbUlBazdBUUlnRmlBS093RUFJQk1nQ1RzQkFpQXBJQW83QVFBZ0VTQUpPd0VDSUNjZ0Nqc0JBQ0FvREFNTElCd2dCa0VCZENBZWFrRUNkQ0lIYWlJSUlBazdBUUlnQ0NBS093RUFJQndnQjBFRWNtb2lDQ0FLT3dFQUlBaEJBbW9NQWdzZ0FDQUdJQjVxUVFKMGFpSUlJQW83QVl3QklBZ2dDVHNCaGdFZ0NDQUtPd0dFQVNBSVFZNEJhZ3dCQ3lBQUlBWWdIbXBCQW5ScUlnZ2dDanNCaEFFZ0NFR0dBV29MSUFrN0FRQUxJQVpCQVdvaUJpQWlSdzBBQ3dzZ0hVRUJhaUlkUVFSSERRQUxRUUFoREFOQUlCQWdBQ0FNUVFKMElnSnFLQUowTmdJSUlBeEJBVXRCQTNRaENTQU1RUU4wUVFoeElRY0NRQ0FCSUFKcUtBS3dBU0lDUVFKTkJFQUNRQUpBQWtBZ0FrRUJhdzRDQVFJQUN5QUZJQUFnREVFRWRHcEJoQUZxSUJCQkNHb2dGU0FVSUFjZ0NVRUlRUWdRRGd3REN5QUZJQUFnREVFRWRHb2lBa0dFQVdvZ0VFRUlhaUFWSUJRZ0J5QUpRUWhCQkJBT0lBVWdBa0dNQVdvZ0VFRUlhaUFWSUJRZ0J5QUpRUVJ5UVFoQkJCQU9EQUlMSUFVZ0FDQU1RUVIwYWlJQ1FZUUJhaUFRUVFocUlCVWdGQ0FISUFsQkJFRUlFQTRnQlNBQ1FZZ0JhaUFRUVFocUlCVWdGQ0FIUVFSeUlBbEJCRUVJRUE0TUFRc2dCU0FBSUF4QkJIUnFJZ2hCaEFGcUlCQkJDR29nRlNBVUlBY2dDVUVFUVFRUURpQUZJQWhCaUFGcUlCQkJDR29nRlNBVUlBZEJCSElpQmlBSlFRUkJCQkFPSUFVZ0NFR01BV29nRUVFSWFpQVZJQlFnQnlBSlFRUnlJZ0pCQkVFRUVBNGdCU0FJUVpBQmFpQVFRUWhxSUJVZ0ZDQUdJQUpCQkVFRUVBNExJQXhCQVdvaURFRUVSdzBBQ3d3R0N5QUlJUWNnQ1NFR0MwRUJJUnNnQmlBTWFpSUlRUkIwUVJCMVFZQkFhMEgvL3dCTERRVWdCeUFOYWlJR1FSQjBRUkIxUVlBUWFrSC9IMHNOQlNBQ0lBOFFGQ0lIUlEwRklBQWdCanNCc2dFZ0FDQUlPd0d3QVNBQUlBYzJBblFnQUNBUE5nSmtJQUFnQnpZQ2ZDQUFJQTgyQW13Z0FDQUFLQUt3QVNJR05nS3NBU0FBSUFZMkFxZ0JJQUFnQmpZQ3BBRWdBQ0FHTmdLUUFTQUFJQVkyQW93QklBQWdCallDaUFFZ0FDQUdOZ0tFQVNBQktBS1VBU0VPSUFFdkFhWUJJUXdnQVM4QnBBRWhDeUFBS0FJRUlRa0NRQUpBSUFBb0F0QUJJZ2RGRFFBZ0J5Z0NCQ0FKUncwQVFRRWhFU0FIS0FJQVFRVkxCRUJCZnlFSVFRQWhCd3dDQ3lBSEtBSnNJUWdnQnlnQ3JBRWhCd3dCQzBGL0lRaEJBQ0VISUFBb0Fzd0JJZ3BGQkVCQkFDRVJEQUVMSUFrZ0NpZ0NCRWNFUUVFQUlSRU1BUXRCQVNFUklBb29BZ0JCQlVzTkFDQUtLQUpzSVFnZ0NpZ0NzQUVoQndzQ1FDQUlJQTVHUlFSQUlBWkJFSFloQ0FKL0FrQUNRQ0FBS0FMTUFTSU5SUTBBSUEwb0FnUWdDVWNOQUNBTktBSUFRUVZMRFFFZ0RTZ0N2QUVpRVVFUWRpRUtJQTBvQW5BTUFnc2dFVVVOQXd0QkFDRVJRUUFoQ2tGL0N5RU5JQTRnRDBZaUNTQU5JQTVHYWtFQlJ3UkFJQW9nQ0NBS1FSQjBRUkIxSWcwZ0NFRVFkRUVRZFVvaUNCc2lDU0FHUVJCMUlnb2dEU0FLSUFvZ0RVb2JJQWdiSWdnZ0IwRVFkU0lLSUFnZ0Nrb2JJQWxCRUhSQkVIVWdDa2diSVFnZ0VTQUdJQkZCRUhSQkVIVWlDaUFHUVJCMFFSQjFJZzFLSWdZYklnbEIvLzhEY1NBTklBb2dEU0FOSUFwS0d5QUdHeUlHSUFkQkVIUkJFSFVpQnlBR0lBZEtHeUFKUVJCMFFSQjFJQWRJR3lFR0RBSUxJQWtOQVNBTklBNUdCRUFnRVVILy93TnhJQXBCRUhSeUlRWWdDaUVJREFJTEN5QUhRUkIySVFnZ0J5RUdDeUFHSUF0cUlnZEJFSFJCRUhWQmdFQnJRZi8vQUVzTkJTQUlJQXhxSWdaQkVIUkJFSFZCZ0JCcVFmOGZTdzBGSUFJZ0RoQVVJZ0pGRFFVZ0FDQUdPd0hDQVNBQUlBYzdBY0FCSUFBZ0FqWUNnQUVnQUNBQ05nSjRJQUFnRGpZQ2NDQUFJQTQyQW1nZ0FDQUFLQUxBQVNJR05nSzhBU0FBSUFZMkFyZ0JJQUFnQmpZQ3RBRWdBQ0FHTmdLZ0FTQUFJQVkyQXB3QklBQWdCallDbUFFZ0FFR1VBV29pQWlBR05nSUFJQkFnQUNnQ2REWUNDQ0FGSUFCQmhBRnFJQkJCQ0dvZ0ZTQVVRUUJCQUVFSVFSQVFEaUFRSUFBb0FuZzJBZ2dnQlNBQ0lCQkJDR29nRlNBVVFRaEJBRUVJUVJBUURnd0VDMEVBSVFoQmZ5RVdDeUFQSUJOR0lnc2dFeUFXUm1wQkFVY0VRQ0FLSUFjZ0NrRVFkRUVRZFNJTElBZEJFSFJCRUhVaURrb2lCeHNpQ2lBT0lBc2dEaUFMSUE1SUd5QUhHeUlISUFoQkVIVWlDeUFISUF0S0d5QUtRUkIwUVJCMUlBdElHeUVISUFrZ0JpQUpRUkIwUVJCMUlnb2dCa0VRZEVFUWRTSUxTaUlHR3lJSlFmLy9BM0VnQ3lBS0lBc2dDaUFMU0JzZ0Joc2lCaUFJUVJCMFFSQjFJZ2dnQmlBSVNoc2dDVUVRZEVFUWRTQUlTQnNoQmd3QkN5QUxEUUFnQ0VFUWRpRUhJQWdoQmd0QkFTRWJJQVlnREdvaUNFRVFkRUVRZFVHQVFHdEIvLzhBU3cwQ0lBY2dEV29pQmtFUWRFRVFkVUdBRUdwQi94OUxEUUlnQWlBVEVCUWlCMFVOQWlBQUlBWTdBYUlCSUFBZ0NEc0JvQUVnQUNBSE5nSjBJQUFnRXpZQ1pDQUFJQWMyQW5nZ0FDQVROZ0pvSUFBZ0FDZ0NvQUVpRHpZQ25BRWdBQ0FQTmdLWUFTQUFJQTgyQXBRQklBQWdEellDa0FFZ0FDQVBOZ0tNQVNBQUlBODJBb2dCSUFBZ0R6WUNoQUVnQVNnQ2xBRWhEaUFCTHdHbUFTRU5JQUV2QWFRQklRd0Nmd0pBQWtBQ1FDQUFLQUxJQVNJR0JFQWdCaWdDQkNBQUtBSUVSZ1JBSUFZb0FnQkJCVTBFUUNBR0tBSzRBU0lMUVJCMklRY2dCaWdDY0NBT1J3MEVJQXNoQ1F3REMwRi9JUkpCQUNFSlFRQWhCMEVBSVF0QkFDRUtJQTVCZjBZTkFnd0VDMEYvSVJKQkFDRUpRUUFoQjBFQUlRdEJBQ0VLSUE1QmYwWU5BUXdEQzBGL0lSSkJBQ0VKUVFBaEIwRUFJUXRCQUNFS0lBNUJmMGNOQWdzZ0NVSC8vd054SUFkQkVIUnlEQUlMSUFZb0FtZ2hFaUFHS0FLZ0FTRUtJQWNoQ1FzZ0QwRVFkaUVJSUE0Z0UwWWlCaUFPSUJKR2FrRUJSd1JBSUFnZ0NTQUpRUkIwUVJCMUlna2dDRUVRZEVFUWRVZ2lCeHNpQ0NBSklBOUJFSFVpQmlBSklBWWdDVWdiSUFjYklnWWdDa0VRZFNJSElBWWdCMG9iSUFoQkVIUkJFSFVnQjBnYklRY2dEeUFMSUF0QkVIUkJFSFVpQ3lBUFFSQjBRUkIxSWdsSUlnWWJJZ2hCLy84RGNTQUxJQWtnQ3lBSklBdElHeUFHR3lJR0lBcEJFSFJCRUhVaUNTQUdJQWxLR3lBSVFSQjBRUkIxSUFsSUd3d0JDeUFJSUFwQkVIWWdCaHNoQnlBUElBb2dCaHNMSUF4cUlnaEJFSFJCRUhWQmdFQnJRZi8vQUVzTkFpQUhJQTFxSWdaQkVIUkJFSFZCZ0JCcVFmOGZTdzBDSUFJZ0RoQVVJZ0pGRFFJZ0FDQUdPd0hDQVNBQUlBZzdBY0FCSUFBZ0FqWUNnQUVnQUNBQ05nSjhJQUFnRGpZQ2NDQUFJQTQyQW13Z0FDQUFLQUxBQVNJR05nSzhBU0FBSUFZMkFyZ0JJQUFnQmpZQ3RBRWdBQ0FHTmdLd0FTQUFJQVkyQXF3QklBQWdCallDcUFFZ0FFR2tBV29pQWlBR05nSUFJQkFnQUNnQ2REWUNDQ0FGSUFCQmhBRnFJQkJCQ0dvZ0ZTQVVRUUJCQUVFUVFRZ1FEaUFRSUFBb0FudzJBZ2dnQlNBQ0lCQkJDR29nRlNBVVFRQkJDRUVRUVFnUURnd0JDd0pBSUFaRkJFQWdFa1VFUUVFQUlRa01BZ3NnRmtVRVFFRUFJUWtNQWdzZ0NFSC8vd054SUFkQkVIUnlJQTF5UlFSQVFRQWhDUXdDQzBFQUlRa2dFVUgvL3dOeElBcEJFSFJ5SUE5eVJRMEJDeUFCTHdHaUFTRUxJQUV2QWFBQklRa0NRQUpBQWtBQ1FBSkFJQUFvQXRBQklnWkZEUUFnQmlnQ0JDQU9SdzBBSUFZb0FnQkJCVTBOQVF3Q0N3SkFJQUFvQXRRQklnWkZEUUFnQmlnQ0JDQU9SdzBBSUFZb0FnQkJCVXNOQWlBR0tBSndJUmNnQmlnQ3dBRWhEQXdEQzBGL0lSY2dFa1VOQWlBV0RRSU1Bd3NnQmlnQ2JDRVhJQVlvQXF3QklRd01BUXRCZnlFWEN5QVBJQk5HSWdZZ0RTQVRSaUlOYWlBVElCZEdha0VCUndSQUlBb2dCeUFLUVJCMFFSQjFJZ29nQjBFUWRFRVFkU0lOU2lJR0d5SUhJQTBnQ2lBTklBb2dEVWdiSUFZYklnWWdERUVRZFNJS0lBWWdDa29iSUFkQkVIUkJFSFVnQ2tnYklRY2dFU0FJSUJGQkVIUkJFSFVpQ2lBSVFSQjBRUkIxSWcxS0lnWWJJZ2hCLy84RGNTQU5JQW9nRFNBS0lBMUlHeUFHR3lJR0lBeEJFSFJCRUhVaUNpQUdJQXBLR3lBSVFSQjBRUkIxSUFwSUd5RUlEQUVMSUFnZ0VTQU5HeUVJSUFjZ0NpQU5HeUVISUEwTkFDQUdEUUFnREVFUWRpRUhJQXdoQ0F0QkFTRWJJQWdnQ1dvaURFRVFkRUVRZFVHQVFHdEIvLzhBU3cwQ0lBY2dDMm9pQ1VFUWRFRVFkVUdBRUdwQi94OUxEUUlMSUFJZ0V4QVVJZ0pGQkVCQkFTRWJEQUlMSUFBZ0NUc0J3Z0VnQUNBTU93SEFBU0FBSUFJMkFuUWdBQ0FUTmdKa0lBQWdBallDZ0FFZ0FDQUNOZ0o4SUFBZ0FqWUNlQ0FBSUJNMkFuQWdBQ0FUTmdKc0lBQWdFellDYUNBQUlBQW9Bc0FCSWdZMkFyd0JJQUFnQmpZQ3VBRWdBQ0FHTmdLMEFTQUFJQVkyQXJBQklBQWdCallDckFFZ0FDQUdOZ0tvQVNBQUlBWTJBcVFCSUFBZ0JqWUNvQUVnQUNBR05nS2NBU0FBSUFZMkFwZ0JJQUFnQmpZQ2xBRWdBQ0FHTmdLUUFTQUFJQVkyQW93QklBQWdCallDaUFFZ0FDQUdOZ0tFQVNBUUlBSTJBZ2dnQlNBQVFZUUJhaUFRUVFocUlCVWdGRUVBUVFCQkVFRVFFQTRMUVFBaEd5QUFLQUxFQVVFQlN3MEFJQUFvQWdBRVFDQUVJQU1nQlNBQlFjZ0NhaEJZREFFTElBUWdCUkFiQ3lBUVFTQnFKQUFnR3d1VEN3RVBmeUFBS0FJQUloRWdBU0FCSUFBb0FnUWlDbkFpQVdzaUJFRUlkR29nQVVFRWRHb2hCU0FLUVFSMElRc2dBQ2dDQ0NBS2JDSUFRUVowSVFZZ0FVRURkQ0VKSUFCQkNIUWhEQ0FFUVFaMElSSWdDa0VDZEVIOC8vLy9BM0ZCQW5RaEVBTkFJQVVnRGtFQ2RDSUFRZkFwYWlnQ0FDSUJJQXRzYWlBQVFiQXBhaWdDQUNJQWFpRUVJQUlnQVVFRWRHb2dBR29oQUFKQUlBTWdEa0VHZEdvaUFTZ0NBQ0lIUWYvLy93ZEhCRUFnQVNnQ0JDRUlJQUF0QUFFaERTQUVJQWNnQUMwQUFHcEJzQzVxTFFBQU9nQUFJQUVvQWdnaEJ5QUFMUUFDSVE4Z0JDQUlJQTFxUWJBdWFpMEFBRG9BQVNBQktBSU1JUWdnQUMwQUF5RU5JQVFnQnlBUGFrR3dMbW90QUFBNkFBSWdCQ0FJSUExcVFiQXVhaTBBQURvQUF5QUJLQUlVSVFjZ0FDMEFFU0VJSUFRZ0Myb2lCQ0FCS0FJUUlBQXRBQkJxUWJBdWFpMEFBRG9BQUNBQktBSVlJUTBnQUMwQUVpRVBJQVFnQnlBSWFrR3dMbW90QUFBNkFBRWdBU2dDSENFSElBQXRBQk1oQ0NBRUlBMGdEMnBCc0M1cUxRQUFPZ0FDSUFRZ0J5QUlha0d3TG1vdEFBQTZBQU1nQVNnQ0pDRUhJQUF0QUNFaENDQUVJQXRxSWdRZ0FTZ0NJQ0FBTFFBZ2FrR3dMbW90QUFBNkFBQWdBU2dDS0NFTklBQXRBQ0loRHlBRUlBY2dDR3BCc0M1cUxRQUFPZ0FCSUFFb0Fpd2hCeUFBTFFBaklRZ2dCQ0FOSUE5cVFiQXVhaTBBQURvQUFpQUVJQWNnQ0dwQnNDNXFMUUFBT2dBRElBRW9BalFoQnlBQUxRQXhJUWdnQkNBTGFpSUVJQUVvQWpBZ0FDMEFNR3BCc0M1cUxRQUFPZ0FBSUFFb0FqZ2hEU0FBTFFBeUlROGdCQ0FISUFocVFiQXVhaTBBQURvQUFTQUJLQUk4SVFFZ0FDMEFNeUVBSUFRZ0RTQVBha0d3TG1vdEFBQTZBQUlnQkNBQUlBRnFRYkF1YWkwQUFEb0FBd3dCQ3lBQUtBSVFJUUVnQkNBQUtBSUFOZ0lBSUFRZ0VHb2lCQ0FCTmdJQUlBQW9BakFoQVNBRUlCQnFJZ1FnQUNnQ0lEWUNBQ0FFSUJCcUlBRTJBZ0FMSUE1QkFXb2lEa0VRUncwQUN5QU1JQkZxSUJKcUlBbHFJaEFnQm1vaEVTQUtRUU4wUWZqLy8vOEhjU0lMUVFKMlFRSjBJUTVCRUNFS0EwQWdDa0VDZEVFTWNTSUFRZkFwYWlnQ0FDSUJJQXRzSUFCQnNDbHFLQUlBSWdCcUlCRWdFQ0FLUVJOTElnVWJhaUVFSUFKQndBSkJnQUlnQlJ0cUlBRkJBM1FnQUdwcUlRQUNRQ0FESUFwQkJuUnFJZ0VvQWdBaUJVSC8vLzhIUndSQUlBRW9BZ1FoQmlBQUxRQUJJUWtnQkNBRklBQXRBQUJxUWJBdWFpMEFBRG9BQUNBQktBSUlJUVVnQUMwQUFpRU1JQVFnQmlBSmFrR3dMbW90QUFBNkFBRWdBU2dDRENFR0lBQXRBQU1oQ1NBRUlBVWdER3BCc0M1cUxRQUFPZ0FDSUFRZ0JpQUpha0d3TG1vdEFBQTZBQU1nQVNnQ0ZDRUZJQUF0QUFraEJpQUVJQXRxSWdRZ0FTZ0NFQ0FBTFFBSWFrR3dMbW90QUFBNkFBQWdBU2dDR0NFSklBQXRBQW9oRENBRUlBVWdCbXBCc0M1cUxRQUFPZ0FCSUFFb0Fod2hCU0FBTFFBTElRWWdCQ0FKSUF4cVFiQXVhaTBBQURvQUFpQUVJQVVnQm1wQnNDNXFMUUFBT2dBRElBRW9BaVFoQlNBQUxRQVJJUVlnQkNBTGFpSUVJQUVvQWlBZ0FDMEFFR3BCc0M1cUxRQUFPZ0FBSUFFb0FpZ2hDU0FBTFFBU0lRd2dCQ0FGSUFacVFiQXVhaTBBQURvQUFTQUJLQUlzSVFVZ0FDMEFFeUVHSUFRZ0NTQU1ha0d3TG1vdEFBQTZBQUlnQkNBRklBWnFRYkF1YWkwQUFEb0FBeUFCS0FJMElRVWdBQzBBR1NFR0lBUWdDMm9pQkNBQktBSXdJQUF0QUJocVFiQXVhaTBBQURvQUFDQUJLQUk0SVFrZ0FDMEFHaUVNSUFRZ0JTQUdha0d3TG1vdEFBQTZBQUVnQVNnQ1BDRUJJQUF0QUJzaEFDQUVJQWtnREdwQnNDNXFMUUFBT2dBQ0lBUWdBQ0FCYWtHd0xtb3RBQUE2QUFNTUFRc2dBQ2dDQ0NFQklBUWdBQ2dDQURZQ0FDQUVJQTVxSWdRZ0FUWUNBQ0FBS0FJWUlRRWdCQ0FPYWlJRUlBQW9BaEEyQWdBZ0JDQU9haUFCTmdJQUN5QUtRUUZxSWdwQkdFY05BQXNMNWdFQkIzOENRQ0FBS0FJQUlnVkZEUUFnQUVFQk5nSThJQUFvQWpnTkFDQUFLQUljSVFaQi8vLy8vd2NoQWdOQUEwQWdCU0FEUVNoc2FpSUVLQUlZQkVBZ0JDQUJJQVFvQWhBaUJDQUNTQ0lIR3lFQklBUWdBaUFIR3lFQ0N5QURRUUZxSWdNZ0JrME5BQ0FCUlEwQ0lBQW9BZ3dnQUNnQ0VDSURRUVIwYWlJQ0lBRW9BZ0EyQWdBZ0FpQUJLQUlrTmdJTUlBSWdBU2dDSERZQ0JDQUNJQUVvQWlBMkFnZ2dBQ0FEUVFGcU5nSVFRUUFoQXlBQlFRQTJBaGdnQVNnQ0ZDRUVRUUFoQVVILy8vLy9CeUVDSUFRTkFBc2dBQ0FBS0FJc1FYOXFOZ0lzREFBQUN3QUxDOXdHQVFwL0lBQkNBRGNDRUFKQUFrQUNRQ0FEUlEwQUFrQUNRQ0FCSUFBb0FqQWlBMGNFUUNBRFFRRnFJQUFvQWlBaUJIQWlDU0FCUmcwQklBQW9BZ0FnQUNnQ0hFRW9iR29vQWdBaEN3TkFBa0FDUUNBQUtBSW9JZ2NFUUNBQUtBSUFJUWhCQUNFREEwQWdDQ0FEUVNoc2FpSUZLQUlVUVg5cVFRRk5CRUFnQlNBRktBSU1JZ1VnQkVFQUlBVWdDVXNiYXpZQ0NBc2dBMEVCYWlJRElBZEhEUUFMSUFjZ0FDZ0NHRWtOQWtGL0lRVkJBQ0VEUVFBaEJBTkFJQWdnQTBFb2JHb2lCaWdDRkVGL2FrRUJUUVJBSUFZb0FnZ2lCaUFFSUFWQmYwWWdCaUFFU0hJaUJoc2hCQ0FESUFVZ0Joc2hCUXNnQTBFQmFpSURJQWRIRFFBTElBVkJBRTROQVVFQkR3dEJBQ0VISUFBb0FoZ05BVUVCRHdzZ0NDQUZRU2hzYWlJRFFRQTJBaFFnQUNBSFFYOXFJZ2MyQWlnZ0F5Z0NHQTBBSUFBZ0FDZ0NMRUYvYWpZQ0xBc2dBQ2dDTENJRklBQW9BaHdpQ0U4RVFDQUFLQUk0RFFZZ0FDZ0NBQ0VNQTBCQkFDRUVRZi8vLy84SElRWkJBQ0VEQTBBZ0RDQURRU2hzYWlJS0tBSVlCRUFnQ2lBRUlBb29BaEFpQ2lBR1NDSU5HeUVFSUFvZ0JpQU5HeUVHQ3lBRFFRRnFJZ01nQ0UwTkFBc0NRQ0FFUlEwQUlBQW9BZ3dnQUNnQ0VDSUdRUVIwYWlJRElBUW9BZ0EyQWdBZ0F5QUVLQUlrTmdJTUlBTWdCQ2dDSERZQ0JDQURJQVFvQWlBMkFnZ2dBQ0FHUVFGcU5nSVFJQVJCQURZQ0dDQUVLQUlVRFFBZ0FDQUZRWDlxSWdVMkFpd0xJQVVnQ0U4TkFBc0xJQUFvQWdBaUJDQUlRU2hzYWlJRElBazJBZ3dnQTBLQWdJQ0FFRGNDRUNBRFFRQTJBaGdnQXlBSk5nSUlJQUFnQjBFQmFqWUNLQ0FBSUFWQkFXbzJBaXdnQkNBSVFRRnFFQ2NnQ1VFQmFpQUFLQUlnSWdSd0lna2dBVWNOQUFzQ1FDQUFLQUlRSWdsRkRRQWdBQ2dDQUNJRklBQW9BaHdpQkVFb2JHb2lDQ2dDQUNFSElBQW9BZ3doQmtFQUlRTURRQ0FISUFZZ0EwRUVkR29vQWdCSEJFQWdDU0FEUVFGcUlnTkhEUUVNQWdzTElBUkZEUUJCQUNFREEwQWdDeUFGSUFOQktHeHFJZ2tvQWdCSEJFQWdCQ0FEUVFGcUlnTkhEUUVNQWdzTElBa2dCellDQUNBSUlBczJBZ0FMSUFJTkJTQUFLQUl3SVFNTUFnc2dBa0VBUnc4TElBSU5Bd3NnQVNBRFJnMEFJQUFnQVNBQUtBSWdJZ0JxUVg5cUlBQndOZ0l3QzBFQUR3c0RRQXdBQUFzQUN5QUFJQUUyQWpCQkFBdDFBUU4vQWtBZ0FDZ0NBQ0lCUlEwQUlBQW9BaHhCZjBZTkFBTkFJQUVnQWtFb2JDSURhaWdDQkJBRUlBQW9BZ0FpQVNBRGFrRUFOZ0lFSUFKQkFXb2lBaUFBS0FJY1FRRnFTUTBBQ3dzZ0FSQUVJQUJCQURZQ0FDQUFLQUlFRUFRZ0FFRUFOZ0lFSUFBb0Fnd1FCQ0FBUVFBMkFnd0xnd0VCQTM4Q1FDQUFLQUlBSWdaRkRRQWdBQ2dDSEVGL1JnMEFBMEFnQmlBSFFTaHNJZ2hxS0FJRUVBUWdBQ2dDQUNJR0lBaHFRUUEyQWdRZ0IwRUJhaUlISUFBb0FoeEJBV3BKRFFBTEN5QUdFQVFnQUVFQU5nSUFJQUFvQWdRUUJDQUFRUUEyQWdRZ0FDZ0NEQkFFSUFCQkFEWUNEQ0FBSUFFZ0FpQURJQVFnQlJCZEM0QUNBUUovSUFBZ0JUWUNPQ0FBSUFRMkFpQWdBRUwvL3dNM0FpUWdBRUlBTndJc0lBQWdBMEVCSUFOQkFVc2JJZ00yQWhnZ0FDQURJQUlnQlJzaUFqWUNIQ0FBUWFnRkVBb2lBellDQUVILy93TWhCQUpBSUFORkRRQkJBQ0VGSUFOQkFFR29CUkFISVFZZ0FrRi9Sd1JBSUFGQmdBTnNRUzl5SVFWQkFDRURBMEFnQmlBRFFTaHNhaUlISUFVUUNpSUJOZ0lFSUFGRkRRSWdCeUFCUVFBZ0FXdEJEM0ZxTmdJQUlBTWdBa2toQVNBRFFRRnFJUU1nQVEwQUN5QUNRUVIwUVJCcUlRVUxJQUJCeEFBUUNpSUJOZ0lFSUFBZ0JSQUtJZ0kyQWd3Z0FrVU5BQ0FCUlEwQVFRQWhCQ0FCUVFCQnhBQVFCeG9nQUVJQU53SVFDeUFFQzlNQkFRZC9RUUVoQVFKQUlBQW9BamdOQUNBQUtBSWNJUVVnQUNnQ0FDRUdRZi8vLy84SElRTkJBQ0VCQTBBZ0JpQUJRU2hzYWlJRUtBSVlCRUFnQkNBQ0lBUW9BaEFpQkNBRFNDSUhHeUVDSUFRZ0F5QUhHeUVEQ3lBQlFRRnFJZ0VnQlUwTkFBc2dBa1VFUUVFQkR3c2dBQ2dDRENBQUtBSVFJZ05CQkhScUlnRWdBaWdDQURZQ0FDQUJJQUlvQWlRMkFnd2dBU0FDS0FJY05nSUVJQUVnQWlnQ0lEWUNDQ0FBSUFOQkFXbzJBaEJCQUNFQklBSkJBRFlDR0NBQ0tBSVVEUUFnQUNBQUtBSXNRWDlxTmdJc0N5QUJDL1VFQVFoL0lBQW9BaWdpQkFSQUlBQW9BZ0FoQndOQUlBY2dCVUVvYkdvaUJpZ0NGRUYvYWtFQlRRUkFJQVlnQmlnQ0RDSUlJQUpMQkg4Z0NDQUFLQUlnYXdVZ0NBczJBZ2dMSUFWQkFXb2lCU0FFUncwQUN3dEJBQ0VFQWtBZ0FTZ0NBRVVOQUNBQktBSUVJZ1ZCQWtzTkFFRUFJUWNnQWlFR0EwQUNRQUpBQWtBZ0JVRUNSd1JBSUFFZ0IwRU1iR29vQWdnaEJBSkFJQVZGQkVBZ0JpQUVheUlHUVg5S0RRRWdBQ2dDSUNBR2FpRUdEQUVMSUFRZ0Jtb2lCa0VBSUFBb0FpQWlCU0FHSUFWSUcyc2hCZ3NnQmlFSklBWWdBa3NFUUNBR0lBQW9BaUJySVFrTElBQW9BaGdpQ2tVRVFFRUJEd3NnQUNnQ0FDRUlRUUFoQlFOQUlBZ2dCVUVvYkdvaUJDZ0NGQ0lMUVg5cVFRRk5CRUFnQkNnQ0NDQUpSZzBEQzBFQklRUWdCVUVCYWlJRklBcEhEUUFMREFVTFFRRWhCQ0FBS0FJWUlnbEZEUVFnQVNBSFFReHNhaWdDRENFS0lBQW9BZ0FoQ0VFQUlRVURRQ0FJSUFWQktHeHFJZ1FvQWhSQkEwWUVRQ0FFS0FJSUlBcEdEUU1MUVFFaEJDQUZRUUZxSWdVZ0NVY05BQXNNQkFzZ0JVRUFTQVJBUVFFUEMwRUJJUVFnQzBFQlN3MEJEQU1MUVFFaEJDQUZRUUJJRFFJTElBY2dBeUlFU1FSQUEwQWdBQ2dDQkNJSklBUkJBblJxSUFrZ0JFRi9haUlFUVFKMGFpZ0NBRFlDQUNBRUlBZExEUUFMSUFBb0FnQWhDQXNnQUNnQ0JDQUhRUUowYWlBSUlBVkJLR3dpQ1dvMkFnQWdCMEVCYWlJSElRUWdCeUlGSUFOTkJFQURRQ0FBS0FJRUlnZ2dCVUVDZEdvb0FnQWlDaUFBS0FJQUlBbHFSd1JBSUFnZ0JFRUNkR29nQ2pZQ0FDQUVRUUZxSVFRTElBVkJBV29pQlNBRFRRMEFDd3RCQUNFRUlBRWdCMEVNYkdvb0FnUWlCVUVEU1EwQUN3c2dCQXNHQUNBQUVBUUxCd0JCeEJvUUNndTRBZ0VEZndOQUlBQWdBa0VDZEdvaUFVRVVhaWdDQUNJREJFQWdBeWdDS0JBRUlBRW9BaFJCQURZQ0tDQUJLQUlVS0FKVUVBUWdBU2dDRkVFQU5nSlVJQUVvQWhRUUJDQUJRUUEyQWhRTElBSkJBV29pQWtFZ1J3MEFDMEVBSVFJRFFDQUFJQUpCQW5ScUlnRkJsQUZxS0FJQUlnTUVRQ0FES0FJVUVBUWdBU2dDbEFGQkFEWUNGQ0FCS0FLVUFTZ0NHQkFFSUFFb0FwUUJRUUEyQWhnZ0FTZ0NsQUVvQWh3UUJDQUJLQUtVQVVFQU5nSWNJQUVvQXBRQktBSXNFQVFnQVNnQ2xBRkJBRFlDTENBQktBS1VBUkFFSUFGQkFEWUNsQUVMSUFKQkFXb2lBa0dBQWtjTkFBc2dBQ2dDc0JvUUJDQUFRUUEyQXJBYUlBQW9BcndKRUFRZ0FFRUFOZ0s4Q1NBQUtBS1VDUkFFSUFCQkFEWUNsQWtnQUNnQ3ZCb2lBUVJBSUFFUUJDQUFRUUEyQXJ3YUN5QUFRY1FKYWhCYkM3Y0JBUUovSXdCQkVHc2lCaVFBSUFaQkFEWUNEQ0FBSUFFZ0FpQUdRUXhxRUNvaUIwRjljVVVFUUFOQUlBQWdBU0FHS0FJTUlnZHFJZ0VnQWlBSGF5SUNJQVpCREdvUUtpSUhRWDF4UlEwQUN3c2dCMEVCUmdSQUlBUWdBQ2dDRUNJQktBSTBRUVIwTmdJQUlBVWdBU2dDT0VFRWREWUNBQ0FESUFCQnhBbHFJZ0FvQWhRaUFTQUFLQUlRU1FSL0lBQWdBVUVCYWpZQ0ZDQUFLQUlNSUFGQkJIUnFCVUVBQ3lnQ0FEWUNBQXNnQmtFUWFpUUFJQWNMU1FFQmZ5QUFRUUJCeEJvUUJ5SUNRYlFLYWtFQk5nSUFJQUpDZ0lLQWdJQUVOd0lFSUFCQndCQVFDaUlDTmdLd0dpQUNSUVJBUVFFUEN5QUJCRUFnQUVFQk5nTEFDUXRCQUF1NkJBRUpmd0pBQWtBZ0FVRUVTUTBBSUFBdEFBQU5BQ0FBTFFBQkRRQWdBQzBBQWlJSFFRRkxEUUJCQXlFRUlBQkJBMm9oQlVFQ0lRaEJmU0VNQWtBRFFDQUZJUVlDZnlBSVFRRnFJQWRCL3dGeElnVkZEUUFhUVFBaEJ5QUZRUUZHUVFBZ0NFRUJTeHNOQWtFQUN5RUlJQVJCZjNNaERDQUdRUUZxSVFVZ0JpMEFBQ0VISUFSQkFXb2lCQ0FCUncwQUN5QURJQUUyQWdCQkFROExJQVFoQ2tFQUlRaEJBQ0VGQTBCQkFTQUlJQWNnQmkwQUFDSUxSV29pQ1VFQ1Joc2dDQ0FMUVFOR0d5RUlJQXBCQVdvaENnSkFJQXRCQVVjTkFDQUpRUUpKRFFBZ0FpQUtJQXhxSUFsQmYzTnFJZ0UyQWd4QkFDQUpRWDFxSWdZZ0JpQUpTeHNoQnd3REMwRUFJQWtnQ3hzaEIwRUJJQVVnQ1VFQ1N4c2dCU0FMR3lFRklBWkJBV29oQmlBQklBcEhEUUFMSUFJZ0FTQU1haUFIYXlJQk5nSU1EQUVMSUFJZ0FUWUNERUVCSVFoQkFDRUhDeUFDUVFBMkFoQWdBa0VBTmdJSUlBSWdBQ0FFYWlJQU5nSUVJQUlnQURZQ0FDQURJQVFnQjJvZ0FXbzJBZ0JCQVNFREFrQWdCUTBBUVFBaEF5QUlSUTBBSUFJQ2Z5QUNLQUlNSWdGRkJFQWdBQ0VFUVFBTUFRc2dBQ0VFUVFBaEJnTkFJQUZCZjJvaEFTQUVMUUFBSVFVQ2Z3SkFJQVpCQWtjTkFDQUZRUU5HQkVBZ0FVVUVRRUVCRHdzZ0JDMEFBVUVEU3dSQVFRRVBDMEVBSVFZZ0JFRUJhZ3dDQ3lBRlFRTlBEUUJCQVE4TElBQWdCVG9BQUVFQUlBWkJBV29nQlJzaEJpQUFRUUZxSVFBZ0JFRUJhZ3NoQkNBQkRRQUxJQUlvQWd3TElBQWdCR3RxTmdJTUN5QURDd01BQVFzTDdUSVpBRUdHQ0F2S0JXWWdKaEFHQ0dVWVpSaERFRU1RUXhCREVFTVFReEJERUVNUUlnZ2lDQ0lJSWdnaUNDSUlJZ2dpQ0NJSUlnZ2lDQ0lJSWdnaUNDSUlJZ2dBQUFBQUFBQUFBR3BBU2pBcUtBb2dhVGhwT0Vrb1NTZ3BJQ2tnQ1JnSkdHZ3dhREJvTUdnd1NDQklJRWdnU0NBb0dDZ1lLQmdvR0FnUUNCQUlFQWdRWnlobktHY29aeWhuS0djb1p5aG5LRWNZUnhoSEdFY1lSeGhIR0VjWVJ4aHVZRTVZTGxBT1VHNVlUbEF1U0E1SURVQU5RRTFJVFVndFFDMUFEVGdOT0cxUWJWQk5RRTFBTFRndE9BMHdEVEJyU0d0SWEwaHJTR3RJYTBoclNHdElTemhMT0VzNFN6aExPRXM0U3poTE9Dc3dLekFyTUNzd0t6QXJNQ3N3S3pBTEtBc29DeWdMS0Fzb0N5Z0xLQXNvQUFBQUFDOW9MMmdRZ0ZDQU1JQVFlSENBVUhnd2VCQndjSGhRY0RCd0VHaHZjRzl3VDJoUGFDOWdMMkFQWUE5Z2IyaHZhRTlnVDJBdldDOVlEMWdQV0FBQUFBQUFBQUFBWmpoR0lDWWdCaEJtTUVZWUpoZ0dDR1VvWlNnbEVDVVFaQ0JrSUdRZ1pDQmtHR1FZWkJoa0dFTVFReEJERUVNUVF4QkRFRU1RUXhBQUFBQUFBQUFBQUdsSVNUZ3BPQWt3Q0NnSUtFZ3dTREFvTUNnd0NDQUlJR2RBWjBCblFHZEFSeWhIS0Vjb1J5Z25LQ2NvSnlnbktBY1lCeGdIR0FjWUFBQUFBRzE0YlhodWdFNkFMb0FPZ0M1NERuaE9lQzV3VFhCTmNBMXdEWEJ0Y0cxd1RXaE5hQzFvTFdnTmFBMW9iV2h0YUUxZ1RXQXRZQzFnRFdBTllBeFlERmdNV0F4WVRGaE1XRXhZVEZnc1dDeFlMRmdzV0F4UURGQU1VQXhRYkdCc1lHeGdiR0JNVUV4UVRGQk1VQ3hRTEZBc1VDeFFERWdNU0F4SURFaHJXR3RZYTFocldHdFlhMWhyV0d0WVMwaExTRXRJUzBoTFNFdElTMGhMU0N0SUswZ3JTQ3RJSzBnclNDdElLMGdMUUF0QUMwQUxRQXRBQzBBTFFBdEFhMUJyVUd0UWExQnJVR3RRYTFCclVFdEFTMEJMUUV0QVMwQkxRRXRBUzBBclFDdEFLMEFyUUN0QUswQXJRQ3RBQ3pnTE9BczRDemdMT0FzNEN6Z0xPQUJCNEEwTHJna0dHRVk0SmpnR0VHWklSakFtTUFZSUpTZ2xLRVVvUlNnbElDVWdSU0JGSUNVWUpSaGxRR1ZBUlJoRkdDVVFKUkJrT0dRNFpEaGtPR1F3WkRCa01HUXdaQ2hrS0dRb1pDaGtJR1FnWkNCa0lHUVlaQmhrR0dRWVJCQkVFRVFRUkJBa0NDUUlKQWdrQ0FRQUJBQUVBQVFBQUFBS2dHcUFTb0FxZ0FwNGFuaEtlQ3A0Q25CcWNFcHdLbkFLYUNsb0tXZ0pZQWxnU1doSmFDbGdLV0FKV0FsWWFXaHBhRWxnU1dBcFdDbFlDVkFKVUdoZ2FHQm9ZR2hnU0ZoSVdFaFlTRmdvVUNoUUtGQW9VQWhJQ0VnSVNBaElhRmhvV0doWWFGaElVRWhRU0ZCSVVDaElLRWdvU0NoSUNFQUlRQWhBQ0VBSE9BYzRCemdIT0FjNEJ6Z0hPQWM0QnpBSE1BY3dCekFITUFjd0J6QUhNRWRJUjBoSFNFZElSMGhIU0VkSVIwZ0hLQWNvQnlnSEtBY29CeWdIS0Fjb1oxQm5VR2RRWjFCblVHZFFaMUJuVUVkQVIwQkhRRWRBUjBCSFFFZEFSMEFuUUNkQUowQW5RQ2RBSjBBblFDZEFCeUFISUFjZ0J5QUhJQWNnQnlBSElBWUlKZ2dBQUFZQUJoQW1FRVlRQUFBR0dDWVlSaGhtR0FZZ0ppQkdJR1lnQmlnbUtFWW9aaWdHTUNZd1JqQm1NQVk0SmpoR09HWTRCa0FtUUVaQVprQUdTQ1pJUmtobVNBWlFKbEJHVUdaUUJsZ21XRVpZWmxnR1lDWmdSbUJtWUFab0ptaEdhR1pvQm5BbWNFWndabkFHZUNaNFJuaG1lQWFBSm9CR2dHYUFBQUJERUFJQUFnQWhDQ0VJSVFnaENHY2daeUJJSUNnZ1J4aEhHQ2NZSnhnR0lBWWdCaUFHSUFZWUJoZ0dHQVlZQmhBR0VBWVFCaEJtR0dZWVpoaG1HQ1lRSmhBbUVDWVFCZ2dHQ0FZSUJnZ0FBR1ZWUkVRME5DTWpJeU1URXhNVEFRRUJBUUVCQVFFQkFRRUJBUUVCQVFENTZkbkl5TGk0cDZlbnA1ZVhsNWVHaG9hR2hvYUdobloyZG5aMmRuWjI1dGJHdHFXbGxaV0VoSVNFZEhSMGRHUmtaR1JVVkZSVVEwTkRRME5EUTBNek16TXpNek16TXlNakl5TWpJeU1qRXhNVEV4TVRFeE1EQXdNREF3TURBOWEyeGNXbHBaV1ZoSVNFaEZSVVZGUkVSRVJFQkFRRUJITnpjM056YzNOelkyTmpZMk5qWTJNek16TXpNek16TXlNakl5TWpJeU1qRXhNVEV4TVRFeFBGdGFVRmxKUjBkRFEwSkNTRGc0T0RZMk5qWTFOVFUxTkRRME5ERXhNVEU3V1ZwS1NFaENRa0ZCUUVCSE56YzNOalkyTmpVMU5UVTBORFEwTXpNek16cGdZVkZZU0VoSVNUazVPVGs1T1RrM056YzNOemMzTnpZMk5qWTJOalkyTlRVMU5UVTFOVFUwTkRRME5EUTBORE16TXpNek16TXpNakl5TWpJeU1qSTVZR0ZSVjBkSFIwZzRPRGc0T0RnNE5qWTJOalkyTmpZME5EUTBORFEwTkRNek16TXpNek16TWpJeU1qSXlNakkxSlNVbEpTVWxKU1VsSlNVbEpTVWxLR0JpVWxGQlFVRkhOemMzTnpjM056WTJOalkyTmpZMk16TXpNek16TXpNMUpTVWxKU1VsSlNVbEpTVWxKU1VsSkNRa0pDUWtKQ1FrSkNRa0pDUWtKQ0ZnWjFkU1FrSkNSVFUxTlRVMU5UVTJKaVltSmlZbUppWW1KaVltSmlZbUpDUWtKQ1FrSkNRa0pDUWtKQ1FrSkNNakl5TWpJeU1qSXlNakl5TWpJeU1oVUZaR1FqSXlNalVsSlNVbEpTVWxKQ1FrSkNRa0pDUWpJeU1qSXlNakl5QkJRakl6TXpVMU5CUVVGQlFVRkJRUVFVUTBNaUlpSWlNVEV4TVRFeE1URURFekl5SVNFaElRSVNJU0VSQVNJU0FRRXlJaElDUXpNaUloSVNBZ0pUUXpNakVoSUNBaE1qUXpOalV3SUNBRUdnRndza0JBUUZCZ2NJQ1FvTURROFJGQllaSENBa0tDMHlPRDlIVUZwbGNYK1FvcmJMNHYvL0FFSGdGd3NrQWdJQ0F3TURBd1FFQkFZR0J3Y0lDQWtKQ2dvTEN3d01EUTBPRGc4UEVCQVJFUklTQUVIRkdBdUVBUUVBQUFFQUFBRUFBQUVBQVFFQUFRRUJBUUVCQVFFQkFRRUJBUUVCQVFJQkFRSUJBUUlCQVFJQkFnTUJBZ01DQWdNQ0FnUUNBd1FDQXdRREF3VURCQVlEQkFZRUJRY0VCUWdFQmdrRkJ3b0dDQXNHQ0EwSENnNElDeEFKREJJS0RSUUxEeGNORVJrQUFBQUFBQUFBQUFVQUFBRC9BQUFBQUFBQUFQOEFBQUFBQUFBQS93QkIxQmtMRlFVQUFBQUFBQUFBQndBQUFQOEFBQUFBQUFBQS93QkI5QmtMRlFVQUFBQUVBQUFBQUFBQUFQOEFBQUFBQUFBQS93QkJsQm9MQlFVQUFBQUVBRUdrR2d1bEFRY0FBQUFFQUFBQUFnQUFBQVFBQUFBQkFBQUEvd0FBQUFBQUFBRC9BQUFBQUFBQUFQOEFBQUFBQUFBQUJBQUFBQUVBQUFBRUFBQUFBd0FBQVA4QUFBQUFBQUFBL3dBQUFBQUFBQUFFQUFBQUFRQUFBQVFBQUFBRUFBQUEvd0FBQUFBQUFBRC9BQUFBQUFBQUFBUUFBQUFCQUFBQUJBQUFBQVFBQUFBRUFBQUFBd0FBQUFRQUFBQUdBQUFBQUFBQUFBMEFBQUQvQUFBQUFBQUFBUDhBQUFBQUFBQUEvd0JCMUJzTEZRMEFBQUFBQUFBQUR3QUFBUDhBQUFBQUFBQUEvd0JCOUJzTEZRMEFBQUFFQUFBQUNBQUFBUDhBQUFBQUFBQUEvd0JCbEJ3THRRc05BQUFBQkFBQUFBZ0FBQUFBQUFBQUR3QUFBQVFBQUFBS0FBQUFCQUFBQUFrQUFBRC9BQUFBQUFBQUFQOEFBQUFBQUFBQS93QUFBQUFBQUFBRUFBQUFDUUFBQUFRQUFBQUxBQUFBL3dBQUFBQUFBQUQvQUFBQUFBQUFBQVFBQUFBSkFBQUFCQUFBQUF3QUFBRC9BQUFBQUFBQUFQOEFBQUFBQUFBQUJBQUFBQWtBQUFBRUFBQUFEQUFBQUFRQUFBQUxBQUFBQkFBQUFBNEFBQUFCQUFBQUNnQUFBUDhBQUFBQUFBQUEvd0FBQUFBQUFBRC9BQUFBQUFBQUFBRUFBQUFLQUFBQUJBQUFBQUFBQUFEL0FBQUFBQUFBQVA4QUFBQUFBQUFBQVFBQUFBb0FBQUFCQUFBQUN3QUFBUDhBQUFBQUFBQUEvd0FBQUFBQUFBQUJBQUFBQ2dBQUFBRUFBQUFMQUFBQUJBQUFBQUFBQUFBRUFBQUFBUUFBQUFFQUFBQU9BQUFBL3dBQUFBQUFBQUQvQUFBQUFBQUFBUDhBQUFBQUFBQUFBUUFBQUE0QUFBQUVBQUFBQkFBQUFQOEFBQUFBQUFBQS93QUFBQUFBQUFBQkFBQUFEZ0FBQUFFQUFBQVBBQUFBL3dBQUFBQUFBQUQvQUFBQUFBQUFBQUVBQUFBT0FBQUFBUUFBQUE4QUFBQUVBQUFBQkFBQUFBUUFBQUFGQUFBQUJBQUFBQUlBQUFEL0FBQUFBQUFBQVA4QUFBQUFBQUFBL3dBQUFBQUFBQUFFQUFBQUFnQUFBQVFBQUFBSUFBQUEvd0FBQUFBQUFBRC9BQUFBQUFBQUFBUUFBQUFDQUFBQUJBQUFBQU1BQUFEL0FBQUFBQUFBQVA4QUFBQUFBQUFBQkFBQUFBSUFBQUFFQUFBQUF3QUFBQVFBQUFBSUFBQUFCQUFBQUFrQUFBQUVBQUFBQmdBQUFQOEFBQUFBQUFBQS93QUFBQUFBQUFEL0FBQUFBQUFBQUFRQUFBQUdBQUFBQkFBQUFBd0FBQUQvQUFBQUFBQUFBUDhBQUFBQUFBQUFCQUFBQUFZQUFBQUVBQUFBQndBQUFQOEFBQUFBQUFBQS93QUFBQUFBQUFBRUFBQUFCZ0FBQUFRQUFBQUhBQUFBQkFBQUFBd0FBQUFFQUFBQURRQUFBQUVBQUFBT0FBQUEvd0FBQUFBQUFBRC9BQUFBQUFBQUFQOEFBQUFBQUFBQUFRQUFBQTRBQUFEL0FBQUFCQUFBQVA4QUFBQUFBQUFBL3dBQUFBQUFBQUFCQUFBQUN3QUFBQUVBQUFBT0FBQUEvd0FBQUFBQUFBRC9BQUFBQUFBQUFBRUFBQUFMQUFBQUFRQUFBQTRBQUFBRUFBQUFBUUFBQVA4QUFBQUVBQUFBQWdBQUFBb0FBQUQvQUFBQUFBQUFBUDhBQUFBQUFBQUEvd0FBQUFBQUFBQUNBQUFBQ2dBQUFQOEFBQUFBQUFBQS93QUFBQUFBQUFEL0FBQUFBQUFBQUFFQUFBQVBBQUFBQWdBQUFBb0FBQUQvQUFBQUFBQUFBUDhBQUFBQUFBQUFBUUFBQUE4QUFBQUNBQUFBQ2dBQUFBUUFBQUFGQUFBQS93QUFBQUFBQUFBRUFBQUFCZ0FBQVA4QUFBQUFBQUFBL3dBQUFBQUFBQUQvQUFBQUFBQUFBQVFBQUFBR0FBQUEvd0FBQUF3QUFBRC9BQUFBQUFBQUFQOEFBQUFBQUFBQUJBQUFBQU1BQUFBRUFBQUFCZ0FBQVA4QUFBQUFBQUFBL3dBQUFBQUFBQUFFQUFBQUF3QUFBQVFBQUFBR0FBQUFCQUFBQUFrQUFBRC9BQUFBREFBQUFQOEFBQUFDQUFBQS93QUFBQUFBQUFEL0FBQUFBQUFBQVA4QUFBQUFBQUFBL3dBQUFBSUFBQUQvQUFBQUNBQUFBUDhBQUFBQUFBQUEvd0FBQUFBQUFBQUVBQUFBQndBQUFQOEFBQUFDQUFBQS93QUFBQUFBQUFEL0FBQUFBQUFBQUFRQUFBQUhBQUFBL3dBQUFBSUFBQUFFQUFBQURRQUFBUDhBQUFBSUFBQUFBd0FBQUE4QUFBRC9BQUFBQUFBQUFQOEFBQUFBQUFBQS93QUFBQUFBQUFBREFBQUFEd0FBQUFBQUFBQUZBQUFBL3dBQUFBQUFBQUQvQUFBQUFBQUFBQU1BQUFBUEFBQUFBUUFBQUFvQUFBRC9BQUFBQUFBQUFQOEFBQUFBQUFBQUF3QUFBQThBQUFBQkFBQUFDZ0FBQUFBQUFBQUZBQUFBQkFBQUFBQUFBQUFCQUFBQUN3QUFBUDhBQUFBQUFBQUEvd0FBQUFBQUFBRC9BQUFBQUFBQUFBRUFBQUFMQUFBQUJBQUFBQUVBQUFEL0FBQUFBQUFBQVA4QUFBQUFBQUFBQVFBQUFBc0FBQUFCQUFBQURnQUFBUDhBQUFBQUFBQUEvd0FBQUFBQUFBQUJBQUFBQ3dBQUFBRUFBQUFPQUFBQUJBQUFBQUVBQUFBRUFBQUFCQUFBQUFBQUFBQUhBQUFBL3dBQUFBQUFBQUQvQUFBQUFBQUFBUDhBUWRRbkN4VUhBQUFBQUFBQUFBMEFBQUQvQUFBQUFBQUFBUDhBUWZRbkN4VUhBQUFBQkFBQUFBSUFBQUQvQUFBQUFBQUFBUDhBUVpRb0M5a0JCd0FBQUFRQUFBQUNBQUFBQUFBQUFBMEFBQUFFQUFBQUNBQUFBQVFBQUFBREFBQUEvd0FBQUFBQUFBRC9BQUFBQUFBQUFQOEFBQUFBQUFBQUJBQUFBQU1BQUFBRUFBQUFDUUFBQVA4QUFBQUFBQUFBL3dBQUFBQUFBQUFFQUFBQUF3QUFBQVFBQUFBR0FBQUEvd0FBQUFBQUFBRC9BQUFBQUFBQUFBUUFBQUFEQUFBQUJBQUFBQVlBQUFBRUFBQUFDUUFBQUFRQUFBQU1BQUFBQUFBQUFBUUFBQUFBQUFBQUJBQUFBQWdBQUFBTUFBQUFDQUFBQUF3QUFBQUFBQUFBQkFBQUFBQUFBQUFFQUFBQUNBQUFBQXdBQUFBSUFBQUFEQUJCK0NrTEJRUUFBQUFFQUVHSUtnc2xCQUFBQUFRQUFBQUlBQUFBQ0FBQUFBd0FBQUFNQUFBQUNBQUFBQWdBQUFBTUFBQUFEQUJCc1M0THlBWUJBZ01FQlFZSENBa0tDd3dORGc4UUVSSVRGQlVXRnhnWkdoc2NIUjRmSUNFaUl5UWxKaWNvS1NvckxDMHVMekF4TWpNME5UWTNPRGs2T3p3OVBqOUFRVUpEUkVWR1IwaEpTa3RNVFU1UFVGRlNVMVJWVmxkWVdWcGJYRjFlWDJCaFltTmtaV1puYUdscWEyeHRibTl3Y1hKemRIVjJkM2g1ZW50OGZYNS9nSUdDZzRTRmhvZUlpWXFMakkyT2o1Q1JrcE9VbFphWG1KbWFtNXlkbnArZ29hS2pwS1dtcDZpcHFxdXNyYTZ2c0xHeXM3UzF0cmU0dWJxN3ZMMit2OERCd3NQRXhjYkh5TW5LeTh6TnpzL1EwZExUMU5YVzE5aloydHZjM2Q3ZjRPSGk0K1RsNXVmbzZlcnI3TzN1Ny9EeDh2UDA5ZmIzK1BuNisvejkvdi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vd0FBQUFBQkFBQUFCQUFBQUFVQUFBQUNBQUFBQXdBQUFBWUFBQUFIQUFBQUNBQUFBQWtBQUFBTUFBQUFEUUFBQUFvQUFBQUxBQUFBRGdBQUFBOEFBQUFBQUFBQUFRQUFBQUVBUVlRMUN5RUJBQUFBQVFBQUFBRUFBQUFCQUFBQUFnQUFBQUlBQUFBQkFBQUFBZ0FBQUFJQVFiUTFDd1VGQUFBQUJBQkJ4RFVMeVFZSEFBQUFCQUFBQUFJQUFBQUVBQUFBQVFBQUFBUUFBQUFFQUFBQUJBQUFBQU1BQUFBRUFBQUFCZ0FBQUFBQUFBQU5BQUFBQkFBQUFBZ0FBQUFBQUFBQUR3QUFBQVFBQUFBS0FBQUFCQUFBQUFrQUFBQUVBQUFBREFBQUFBUUFBQUFMQUFBQUJBQUFBQTRBQUFBQUFBQUFFUUFBQUFRQUFBQVFBQUFBQUFBQUFCTUFBQUFFQUFBQUVnQUFBQUFBQUFBVkFBQUFCQUFBQUJRQUFBQUFBQUFBRndBQUFBUUFBQUFXQUFBQUFRQUFBQW9BQUFBQkFBQUFDd0FBQUFRQUFBQUFBQUFBQkFBQUFBRUFBQUFCQUFBQURnQUFBQUVBQUFBUEFBQUFCQUFBQUFRQUFBQUVBQUFBQlFBQUFBUUFBQUFDQUFBQUJBQUFBQU1BQUFBRUFBQUFDQUFBQUFRQUFBQUpBQUFBQkFBQUFBWUFBQUFFQUFBQUJ3QUFBQVFBQUFBTUFBQUFCQUFBQUEwQUFBQUJBQUFBRWdBQUFBRUFBQUFUQUFBQUJBQUFBQkFBQUFBRUFBQUFFUUFBQUFFQUFBQVdBQUFBQVFBQUFCY0FBQUFFQUFBQUZBQUFBQVFBQUFBVkFBQUFBUUFBQUFzQUFBQUJBQUFBRGdBQUFBUUFBQUFCQUFBQS93QUFBQVFBQUFBQkFBQUFEd0FBQUFJQUFBQUtBQUFBQkFBQUFBVUFBQUQvQUFBQUFBQUFBQVFBQUFBREFBQUFCQUFBQUFZQUFBQUVBQUFBQ1FBQUFQOEFBQUFNQUFBQUJBQUFBQWNBQUFEL0FBQUFBZ0FBQUFRQUFBQU5BQUFBL3dBQUFBZ0FBQUFCQUFBQUV3QUFBQUlBQUFBU0FBQUFCQUFBQUJFQUFBRC9BQUFBRUFBQUFBRUFBQUFYQUFBQUFnQUFBQllBQUFBRUFBQUFGUUFBQVA4QUFBQVVBQUFBQXdBQUFBOEFBQUFCQUFBQUNnQUFBQUFBQUFBRkFBQUFCQUFBQUFBQUFBQUJBQUFBQ3dBQUFBRUFBQUFPQUFBQUJBQUFBQUVBQUFBRUFBQUFCQUFBQUFBQUFBQUhBQUFBQkFBQUFBSUFBQUFBQUFBQURRQUFBQVFBQUFBSUFBQUFCQUFBQUFNQUFBQUVBQUFBQmdBQUFBUUFBQUFKQUFBQUJBQUFBQXdBQUFBREFBQUFFd0FBQUFFQUFBQVNBQUFBQUFBQUFCRUFBQUFFQUFBQUVBQUFBQU1BQUFBWEFBQUFBUUFBQUJZQUFBQUFBQUFBRlFBQUFBUUFBQUFVQUFBQUFRQUFBQUVBQUFBQ0FBQUFBZ0FBQUFNQUFBQURBQUFBQXdBQUFBTUFBQUFBQUFBQUFRQUFBQUlBQUFBREFBQUFCQUFBQUFVQUFBQUdBQUFBQndBQUFBZ0FBQUFKQUFBQUNnQUFBQXNBQUFBTUFBQUFEUUFBQUE0QUFBQVBBRUdXUEFzdUFRRUJBUUVCQWdJQ0FnSUNBd01EQXdNREJBUUVCQVFFQlFVRkJRVUZCZ1lHQmdZR0J3Y0hCd2NIQ0FnSUNBQkIwRHdMUlFvQUFBQU5BQUFBRUFBQUFBc0FBQUFPQUFBQUVnQUFBQTBBQUFBUUFBQUFGQUFBQUE0QUFBQVNBQUFBRndBQUFCQUFBQUFVQUFBQUdRQUFBQklBQUFBWEFBQUFIUUJCb1QwTE13RUNBd1FGQUFFQ0F3UUZBQUVDQXdRRkFBRUNBd1FGQUFFQ0F3UUZBQUVDQXdRRkFBRUNBd1FGQUFFQ0F3UUZBQUVDQXdCQjVEMEx6QUlCQUFBQUFnQUFBQU1BQUFBRUFBQUFCUUFBQUFZQUFBQUhBQUFBQ0FBQUFBa0FBQUFLQUFBQUN3QUFBQXdBQUFBTkFBQUFEZ0FBQUE4QUFBQVFBQUFBRVFBQUFCSUFBQUFUQUFBQUZBQUFBQlVBQUFBV0FBQUFGd0FBQUJnQUFBQVpBQUFBR2dBQUFCc0FBQUFjQUFBQUhRQUFBQjBBQUFBZUFBQUFId0FBQUNBQUFBQWdBQUFBSVFBQUFDSUFBQUFpQUFBQUl3QUFBQ01BQUFBa0FBQUFKQUFBQUNVQUFBQWxBQUFBSlFBQUFDWUFBQUFtQUFBQUpnQUFBQ2NBQUFBbkFBQUFKd0FBQUNjQUFBQUJBQUFBQWdBQUFBUUFBQUFJQUFBQUVBQUFBQ0FBQUFCQUFBQUFnQUFBQUM4ZkR3QVhHeDBlQndzTkRpY3JMUzRRQXdVS0RCTVZHaHdqSlNvc0FRSUVDQkVTRkJnR0NSWVpJQ0VpSkNnbUtRQVFBUUlFQ0NBREJRb01EeThIQ3cwT0Jna2ZJeVVxTENFaUpDZ25LeTB1RVJJVUdCTVZHaHdYR3gwZUZoa21LUT09XCJ9LEQ9e307ZnVuY3Rpb24gbygpe3ZhciBBLEk9RSgpKHtsb2NhdGVGaWxlOmZ1bmN0aW9uKEEpe3JldHVybiBpW0FdfX0pO3JldHVybihBPUksbmV3IFByb21pc2UoKGZ1bmN0aW9uKEkpe0EuY2FsbGVkUnVuP0koKTpBLm9uUnVudGltZUluaXRpYWxpemVkPWZ1bmN0aW9uKCl7cmV0dXJuIEkoKX19KSkpLnRoZW4oKGZ1bmN0aW9uKCl7c2VsZi5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLChmdW5jdGlvbihBKXt2YXIgZz1BLmRhdGEsQj1nLnJlbmRlclN0YXRlSWQ7c3dpdGNoKGcudHlwZSl7Y2FzZVwiZGVjb2RlXCI6dmFyIEM9RFtCXTtDfHwoQz1uZXcgUShJLChmdW5jdGlvbihBLEksZyl7cG9zdE1lc3NhZ2Uoe3R5cGU6XCJwaWN0dXJlUmVhZHlcIix3aWR0aDpJLGhlaWdodDpnLHJlbmRlclN0YXRlSWQ6QixkYXRhOkEuYnVmZmVyfSxbQS5idWZmZXJdKX0pKSxEW0JdPUMpLEMuZGVjb2RlKG5ldyBVaW50OEFycmF5KGcuZGF0YSxnLm9mZnNldCxnLmxlbmd0aCkpO2JyZWFrO2Nhc2VcInJlbGVhc2VcIjp2YXIgRT1EW0JdO0UmJihFLnJlbGVhc2UoKSxkZWxldGUgRFtCXSl9fSkpLHNlbGYucG9zdE1lc3NhZ2Uoe3R5cGU6XCJkZWNvZGVyUmVhZHlcIn0pfSkpfX19LEk9e307ZnVuY3Rpb24gZyhCKXt2YXIgUT1JW0JdO2lmKHZvaWQgMCE9PVEpcmV0dXJuIFEuZXhwb3J0czt2YXIgQz1JW0JdPXtleHBvcnRzOnt9fTtyZXR1cm4gQVtCXShDLEMuZXhwb3J0cyxnKSxDLmV4cG9ydHN9Zy5uPUE9Pnt2YXIgST1BJiZBLl9fZXNNb2R1bGU/KCk9PkEuZGVmYXVsdDooKT0+QTtyZXR1cm4gZy5kKEkse2E6SX0pLEl9LGcuZD0oQSxJKT0+e2Zvcih2YXIgQiBpbiBJKWcubyhJLEIpJiYhZy5vKEEsQikmJk9iamVjdC5kZWZpbmVQcm9wZXJ0eShBLEIse2VudW1lcmFibGU6ITAsZ2V0OklbQl19KX0sZy5vPShBLEkpPT5PYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoQSxJKSxnLnI9QT0+e1widW5kZWZpbmVkXCIhPXR5cGVvZiBTeW1ib2wmJlN5bWJvbC50b1N0cmluZ1RhZyYmT2JqZWN0LmRlZmluZVByb3BlcnR5KEEsU3ltYm9sLnRvU3RyaW5nVGFnLHt2YWx1ZTpcIk1vZHVsZVwifSksT2JqZWN0LmRlZmluZVByb3BlcnR5KEEsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSl9LCgoKT0+e1widXNlIHN0cmljdFwiO2coMzQwKS5pbml0KCl9KSgpfSkoKTsnLFwiV29ya2VyXCIsdm9pZCAwLHZvaWQgMCl9fSw2MTQ6QT0+e0EuZXhwb3J0cz1mdW5jdGlvbihBLGUsSSxnKXt2YXIgdD1zZWxmfHx3aW5kb3c7dHJ5e3RyeXt2YXIgaTt0cnl7aT1uZXcgdC5CbG9iKFtBXSl9Y2F0Y2goZSl7KGk9bmV3KHQuQmxvYkJ1aWxkZXJ8fHQuV2ViS2l0QmxvYkJ1aWxkZXJ8fHQuTW96QmxvYkJ1aWxkZXJ8fHQuTVNCbG9iQnVpbGRlcikpLmFwcGVuZChBKSxpPWkuZ2V0QmxvYigpfXZhciBCPXQuVVJMfHx0LndlYmtpdFVSTCxDPUIuY3JlYXRlT2JqZWN0VVJMKGkpLFE9bmV3IHRbZV0oQyxJKTtyZXR1cm4gQi5yZXZva2VPYmplY3RVUkwoQyksUX1jYXRjaChnKXtyZXR1cm4gbmV3IHRbZV0oXCJkYXRhOmFwcGxpY2F0aW9uL2phdmFzY3JpcHQsXCIuY29uY2F0KGVuY29kZVVSSUNvbXBvbmVudChBKSksSSl9fWNhdGNoKEEpe2lmKCFnKXRocm93IEVycm9yKFwiSW5saW5lIHdvcmtlciBpcyBub3Qgc3VwcG9ydGVkXCIpO3JldHVybiBuZXcgdFtlXShnLEkpfX19fSxlPXt9O2Z1bmN0aW9uIEkoZyl7dmFyIHQ9ZVtnXTtpZih2b2lkIDAhPT10KXJldHVybiB0LmV4cG9ydHM7dmFyIGk9ZVtnXT17ZXhwb3J0czp7fX07cmV0dXJuIEFbZ10uY2FsbChpLmV4cG9ydHMsaSxpLmV4cG9ydHMsSSksaS5leHBvcnRzfXJldHVybiBJLm49QT0+e3ZhciBlPUEmJkEuX19lc01vZHVsZT8oKT0+QS5kZWZhdWx0OigpPT5BO3JldHVybiBJLmQoZSx7YTplfSksZX0sSS5kPShBLGUpPT57Zm9yKHZhciBnIGluIGUpSS5vKGUsZykmJiFJLm8oQSxnKSYmT2JqZWN0LmRlZmluZVByb3BlcnR5KEEsZyx7ZW51bWVyYWJsZTohMCxnZXQ6ZVtnXX0pfSxJLm89KEEsZSk9Pk9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChBLGUpLEkucj1BPT57XCJ1bmRlZmluZWRcIiE9dHlwZW9mIFN5bWJvbCYmU3ltYm9sLnRvU3RyaW5nVGFnJiZPYmplY3QuZGVmaW5lUHJvcGVydHkoQSxTeW1ib2wudG9TdHJpbmdUYWcse3ZhbHVlOlwiTW9kdWxlXCJ9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkoQSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KX0sSSgxMTQpfSkoKX0sNjA1MzpBPT57c2VsZixBLmV4cG9ydHM9KCgpPT57XCJ1c2Ugc3RyaWN0XCI7dmFyIEE9ezExNDpmdW5jdGlvbihBLGUsSSl7dmFyIGc9dGhpcyYmdGhpcy5fX2ltcG9ydERlZmF1bHR8fGZ1bmN0aW9uKEEpe3JldHVybiBBJiZBLl9fZXNNb2R1bGU/QTp7ZGVmYXVsdDpBfX07T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7Y29uc3QgdD1nKEkoMjg5KSk7ZS5kZWZhdWx0PWNsYXNze2luaXRpYWxpemUoKXtyZXR1cm4gbmV3IFByb21pc2UoKChBLGUpPT57dGhpcy53b3JrZXI9bmV3IHQuZGVmYXVsdCx0aGlzLndvcmtlci5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLChlPT57dmFyIEk7Y29uc3QgZz1lLmRhdGE7XCJkZWNvZGVyUmVhZHlcIj09PWcudHlwZT9BKDApOlwiZGVjb2RlRG9uZVwiPT09Zy50eXBlJiYobnVsbD09PShJPXRoaXMub25EZWNvZGUpfHx2b2lkIDA9PT1JfHxJLmNhbGwodGhpcyxnKSl9KSl9KSl9c3RhcnRTdHJlYW0oQSxlLEkpe3RoaXMud29ya2VyJiZ0aGlzLndvcmtlci5wb3N0TWVzc2FnZSh7dHlwZTpcInN0YXJ0U3RyZWFtXCIsc2FtcGxlUmF0ZUh6OkEsY2hhbm5lbENvdW50OmUsZGVjb2RlZFNhbXBsZXNQZXJGcmFtZTpJfSl9c3RvcFN0cmVhbSgpe3RoaXMud29ya2VyJiZ0aGlzLndvcmtlci5wb3N0TWVzc2FnZSh7dHlwZTpcInN0b3BTdHJlYW1cIn0pfWRlY29kZShBLGUpe3RoaXMud29ya2VyJiZ0aGlzLndvcmtlci5wb3N0TWVzc2FnZSh7dHlwZTpcImRlY29kZVwiLHN0YXJ0VGltZXN0YW1wOkEsaW5wdXREYXRhOmV9LFtlXSl9cmVsZWFzZSgpe3RoaXMud29ya2VyJiZ0aGlzLndvcmtlci5wb3N0TWVzc2FnZSh7dHlwZTpcInJlbGVhc2VcIn0pfWRpc3Bvc2UoKXt0aGlzLndvcmtlciYmKHRoaXMud29ya2VyLnRlcm1pbmF0ZSgpLHRoaXMud29ya2VyPXZvaWQgMCl9fX0sMjg5OihBLGUsSSk9PntJLnIoZSksSS5kKGUse2RlZmF1bHQ6KCk9Pml9KTt2YXIgZz1JKDYxNCksdD1JLm4oZyk7ZnVuY3Rpb24gaSgpe3JldHVybiB0KCkoJygoKT0+e3ZhciBBPXszMDU6QT0+e3ZhciBJLGc9KEk9XCJ1bmRlZmluZWRcIiE9dHlwZW9mIGRvY3VtZW50JiZkb2N1bWVudC5jdXJyZW50U2NyaXB0P2RvY3VtZW50LmN1cnJlbnRTY3JpcHQuc3JjOnZvaWQgMCxmdW5jdGlvbihBKXt2YXIgZyxCOyhBPXZvaWQgMCE9PShBPUF8fHt9KT9BOnt9KS5yZWFkeT1uZXcgUHJvbWlzZSgoZnVuY3Rpb24oQSxJKXtnPUEsQj1JfSkpO3ZhciBRLEM9e307Zm9yKFEgaW4gQSlBLmhhc093blByb3BlcnR5KFEpJiYoQ1tRXT1BW1FdKTt2YXIgRT1bXSxpPVwiLi90aGlzLnByb2dyYW1cIixEPWZ1bmN0aW9uKEEsSSl7dGhyb3cgSX0sbz1cIlwiO1widW5kZWZpbmVkXCIhPXR5cGVvZiBkb2N1bWVudCYmZG9jdW1lbnQuY3VycmVudFNjcmlwdCYmKG89ZG9jdW1lbnQuY3VycmVudFNjcmlwdC5zcmMpLEkmJihvPUkpLG89MCE9PW8uaW5kZXhPZihcImJsb2I6XCIpP28uc3Vic3RyKDAsby5sYXN0SW5kZXhPZihcIi9cIikrMSk6XCJcIjt2YXIgdyxGLEc9QS5wcmludHx8Y29uc29sZS5sb2cuYmluZChjb25zb2xlKSxSPUEucHJpbnRFcnJ8fGNvbnNvbGUud2Fybi5iaW5kKGNvbnNvbGUpO2ZvcihRIGluIEMpQy5oYXNPd25Qcm9wZXJ0eShRKSYmKEFbUV09Q1tRXSk7Qz1udWxsLEEuYXJndW1lbnRzJiYoRT1BLmFyZ3VtZW50cyksQS50aGlzUHJvZ3JhbSYmKGk9QS50aGlzUHJvZ3JhbSksQS5xdWl0JiYoRD1BLnF1aXQpLEEud2FzbUJpbmFyeSYmKHc9QS53YXNtQmluYXJ5KSxBLm5vRXhpdFJ1bnRpbWUmJihGPUEubm9FeGl0UnVudGltZSksXCJvYmplY3RcIiE9dHlwZW9mIFdlYkFzc2VtYmx5JiZuKFwibm8gbmF0aXZlIHdhc20gc3VwcG9ydCBkZXRlY3RlZFwiKTt2YXIgUz0hMTtmdW5jdGlvbiBVKEkpe3ZhciBnLEI9QVtcIl9cIitJXTtyZXR1cm4gZz1cIkNhbm5vdCBjYWxsIHVua25vd24gZnVuY3Rpb24gXCIrSStcIiwgbWFrZSBzdXJlIGl0IGlzIGV4cG9ydGVkXCIsQnx8bihcIkFzc2VydGlvbiBmYWlsZWQ6IFwiK2cpLEJ9ZnVuY3Rpb24gYShBLEksZyxCLFEpe3ZhciBDPXtzdHJpbmc6ZnVuY3Rpb24oQSl7dmFyIEk9MDtpZihudWxsIT1BJiYwIT09QSl7dmFyIGc9MSsoQS5sZW5ndGg8PDIpOyFmdW5jdGlvbihBLEksZyl7SihBLGssSSxnKX0oQSxJPVYoZyksZyl9cmV0dXJuIEl9LGFycmF5OmZ1bmN0aW9uKEEpe3ZhciBJLGcsQj1WKEEubGVuZ3RoKTtyZXR1cm4gST1BLGc9QixzLnNldChJLGcpLEJ9fSxFPVUoQSksaT1bXSxEPTA7aWYoQilmb3IodmFyIG89MDtvPEIubGVuZ3RoO28rKyl7dmFyIHc9Q1tnW29dXTt3PygwPT09RCYmKEQ9WCgpKSxpW29dPXcoQltvXSkpOmlbb109QltvXX12YXIgRj1FLmFwcGx5KG51bGwsaSk7cmV0dXJuIEY9ZnVuY3Rpb24oQSl7cmV0dXJuXCJzdHJpbmdcIj09PUk/SChBKTpcImJvb2xlYW5cIj09PUk/Qm9vbGVhbihBKTpBfShGKSwwIT09RCYmWihEKSxGfXZhciBzLGssaCxOPVwidW5kZWZpbmVkXCIhPXR5cGVvZiBUZXh0RGVjb2Rlcj9uZXcgVGV4dERlY29kZXIoXCJ1dGY4XCIpOnZvaWQgMDtmdW5jdGlvbiB5KEEsSSxnKXtmb3IodmFyIEI9SStnLFE9STtBW1FdJiYhKFE+PUIpOykrK1E7aWYoUS1JPjE2JiZBLnN1YmFycmF5JiZOKXJldHVybiBOLmRlY29kZShBLnN1YmFycmF5KEksUSkpO2Zvcih2YXIgQz1cIlwiO0k8UTspe3ZhciBFPUFbSSsrXTtpZigxMjgmRSl7dmFyIGk9NjMmQVtJKytdO2lmKDE5MiE9KDIyNCZFKSl7dmFyIEQ9NjMmQVtJKytdO2lmKChFPTIyND09KDI0MCZFKT8oMTUmRSk8PDEyfGk8PDZ8RDooNyZFKTw8MTh8aTw8MTJ8RDw8Nnw2MyZBW0krK10pPDY1NTM2KUMrPVN0cmluZy5mcm9tQ2hhckNvZGUoRSk7ZWxzZXt2YXIgbz1FLTY1NTM2O0MrPVN0cmluZy5mcm9tQ2hhckNvZGUoNTUyOTZ8bz4+MTAsNTYzMjB8MTAyMyZvKX19ZWxzZSBDKz1TdHJpbmcuZnJvbUNoYXJDb2RlKCgzMSZFKTw8NnxpKX1lbHNlIEMrPVN0cmluZy5mcm9tQ2hhckNvZGUoRSl9cmV0dXJuIEN9ZnVuY3Rpb24gSChBLEkpe3JldHVybiBBP3koayxBLEkpOlwiXCJ9ZnVuY3Rpb24gSihBLEksZyxCKXtpZighKEI+MCkpcmV0dXJuIDA7Zm9yKHZhciBRPWcsQz1nK0ItMSxFPTA7RTxBLmxlbmd0aDsrK0Upe3ZhciBpPUEuY2hhckNvZGVBdChFKTtpZihpPj01NTI5NiYmaTw9NTczNDMmJihpPTY1NTM2KygoMTAyMyZpKTw8MTApfDEwMjMmQS5jaGFyQ29kZUF0KCsrRSkpLGk8PTEyNyl7aWYoZz49QylicmVhaztJW2crK109aX1lbHNlIGlmKGk8PTIwNDcpe2lmKGcrMT49QylicmVhaztJW2crK109MTkyfGk+PjYsSVtnKytdPTEyOHw2MyZpfWVsc2UgaWYoaTw9NjU1MzUpe2lmKGcrMj49QylicmVhaztJW2crK109MjI0fGk+PjEyLElbZysrXT0xMjh8aT4+NiY2MyxJW2crK109MTI4fDYzJml9ZWxzZXtpZihnKzM+PUMpYnJlYWs7SVtnKytdPTI0MHxpPj4xOCxJW2crK109MTI4fGk+PjEyJjYzLElbZysrXT0xMjh8aT4+NiY2MyxJW2crK109MTI4fDYzJml9fXJldHVybiBJW2ddPTAsZy1RfWZ1bmN0aW9uIEwoQSl7dmFyIEk9ZnVuY3Rpb24oQSl7Zm9yKHZhciBJPTAsZz0wO2c8QS5sZW5ndGg7KytnKXt2YXIgQj1BLmNoYXJDb2RlQXQoZyk7Qj49NTUyOTYmJkI8PTU3MzQzJiYoQj02NTUzNisoKDEwMjMmQik8PDEwKXwxMDIzJkEuY2hhckNvZGVBdCgrK2cpKSxCPD0xMjc/KytJOkkrPUI8PTIwNDc/MjpCPD02NTUzNT8zOjR9cmV0dXJuIEl9KEEpKzEsZz1WKEkpO3JldHVybiBKKEEscyxnLEkpLGd9QS5JTklUSUFMX01FTU9SWTt2YXIgcSxNPVtdLEs9W10sYz1bXSxZPVtdO0sucHVzaCh7ZnVuYzpmdW5jdGlvbigpe2woKX19KTt2YXIgZD0wLFA9bnVsbCx0PW51bGw7ZnVuY3Rpb24gbihJKXtBLm9uQWJvcnQmJkEub25BYm9ydChJKSxSKEkrPVwiXCIpLFM9ITAsST1cImFib3J0KFwiK0krXCIpLiBCdWlsZCB3aXRoIC1zIEFTU0VSVElPTlM9MSBmb3IgbW9yZSBpbmZvLlwiO3ZhciBnPW5ldyBXZWJBc3NlbWJseS5SdW50aW1lRXJyb3IoSSk7dGhyb3cgQihnKSxnfUEucHJlbG9hZGVkSW1hZ2VzPXt9LEEucHJlbG9hZGVkQXVkaW9zPXt9O3ZhciByPVwiZGF0YTphcHBsaWNhdGlvbi9vY3RldC1zdHJlYW07YmFzZTY0LFwiO2Z1bmN0aW9uIGYoQSl7cmV0dXJuIEk9QSxnPXIsU3RyaW5nLnByb3RvdHlwZS5zdGFydHNXaXRoP0kuc3RhcnRzV2l0aChnKTowPT09SS5pbmRleE9mKGcpO3ZhciBJLGd9dmFyIFcsYj1cImRhdGE6YXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtO2Jhc2U2NCxBR0Z6YlFFQUFBQUJoQU1vWUFOL2YzOEJmMkFEZjM5L0FHQUVmMzkvZndCZ0FYOEJmMkFDZjM4QmYyQUZmMzkvZjM4QVlBSi9md0JnQjM5L2YzOS9mMzhBWUFaL2YzOS9mMzhBWUFGL0FHQUVmMzkvZndGL1lBVi9mMzkvZndGL1lBQUFZQWgvZjM5L2YzOS9md0JnQ1g5L2YzOS9mMzkvZndCZ0JuOS9mMzkvZndGL1lBZC9mMzkvZjM5L0FYOWdBbjUvQVg5Z0JIOS9mMzhCZldBQmZBRjhZQUo4ZkFGOFlBdC9mMzkvZjM5L2YzOS9md0JnRFg5L2YzOS9mMzkvZjM5L2YzOEFZQTUvZjM5L2YzOS9mMzkvZjM5L2Z3QmdGSDkvZjM5L2YzOS9mMzkvZjM5L2YzOS9mMzkvQUdBTWYzOS9mMzk5Zlg5L2YzOS9BR0FFZjM5OWZ3QmdBQUYvWUFoL2YzOS9mMzkvZndGL1lBdC9mMzkvZjM5L2YzOS9md0YvWUJCL2YzOS9mMzkvZjM5L2YzOS9mMzkvQVg5Z0MzOS9mMzkvZjM5L2ZYOS9BWDlnQ1g5L2YzOS9mMzk5ZndGL1lBZC9mMzkvZjM5OUFYOWdDWDkvZjM5L2YzMS9md0YvWUFaL2ZIOS9mMzhCZjJBRGZuOS9BWDlnQW54L0FYOWdBMzkrZndGK1lBSjhmd0Y4QWhNREFXRUJZUUFLQVdFQllnQUFBV0VCWXdBREE1OEJuUUVBQUFBRUFBa0VId01EQlFBREFTQU9DeWNEQkFjUEdRSUdEd1FHRXdZQ0ZoVWRCZ01GQlFFQkFnc1VHZ2dBQWd3RkNBRUJFQU1IQkFZQ0FnSUVBZ0lLSEFNQ0FnVUFBQUFCQXdRUUZCTUJCQUVPQVFJU0FnZ0ZBUUFBQWdNQ0dBUVhDQVlCQlFBREJRQUpCUUVDQ0FNQkRRRUJBUUVLQWdrSEJBUUxBQUFFQXdBRENSc1JFU1FFQVFFREJBUW1Bd0FLSlFzaEFDSVNCaDREQncwTUJBVUJjQUVGQlFVR0FRR0FBb0FDQmdrQmZ3RkI0SWZDQWdzSE5nd0JaQUlBQVdVQkFBRm1BRElCWndDZkFRRm9BSUVCQVdrQWVBRnFBSEVCYXdCc0FXd0FZZ0Z0QUlZQkFXNEFoUUVCYndDRUFRa05BUUJCQVFzRWU1RUJrZ0dRQVFxZDdnV2RBWUVDQVFoL0lBQW9BaHdpQXlBQ2RpRUhJQUFvQWlBaEJFRi9JUUlEUUNBRElRVWdCQ0FISUFFZ0FrRUJhaUlDYWkwQUFHd2lBMGtOQUFzZ0FDQUZJQU5ySWdFMkFod2dBQ0FFSUFOcklnZzJBaUFnQVVHQWdJQUVUUVJBSUFBb0FoZ2hCaUFBS0FJb0lRUWdBQ2dDRkNFSklBQW9BZ1FoQ2dOQUlBQWdBVUVJZENJSE5nSWNJQUFnQ1VFSWFpSUpOZ0lVUVFBaEF5QUdJQXBKQkVBZ0FDQUdRUUZxSWdVMkFoZ2dBQ2dDQUNBR2FpMEFBQ0VESUFVaEJnc2dBQ0FETmdJb0lBQWdDRUVJZEVHQS92Ly9CM0VnQXlBRVFRaDBja0VCZGtIL0FYRnlRZjhCY3lJSU5nSWdJQUZCZ1lBQ1NTRUZJQU1oQkNBSElRRWdCUTBBQ3dzZ0FndUNCQUVEZnlBQ1FZQUVUd1JBSUFBZ0FTQUNFQUVhSUFBUEN5QUFJQUpxSVFNQ1FDQUFJQUZ6UVFOeFJRUkFBa0FnQWtFQlNBUkFJQUFoQWd3QkN5QUFRUU54UlFSQUlBQWhBZ3dCQ3lBQUlRSURRQ0FDSUFFdEFBQTZBQUFnQVVFQmFpRUJJQUpCQVdvaUFpQURUdzBCSUFKQkEzRU5BQXNMQWtBZ0EwRjhjU0lFUWNBQVNRMEFJQUlnQkVGQWFpSUZTdzBBQTBBZ0FpQUJLQUlBTmdJQUlBSWdBU2dDQkRZQ0JDQUNJQUVvQWdnMkFnZ2dBaUFCS0FJTU5nSU1JQUlnQVNnQ0VEWUNFQ0FDSUFFb0FoUTJBaFFnQWlBQktBSVlOZ0lZSUFJZ0FTZ0NIRFlDSENBQ0lBRW9BaUEyQWlBZ0FpQUJLQUlrTmdJa0lBSWdBU2dDS0RZQ0tDQUNJQUVvQWl3MkFpd2dBaUFCS0FJd05nSXdJQUlnQVNnQ05EWUNOQ0FDSUFFb0FqZzJBamdnQWlBQktBSThOZ0k4SUFGQlFHc2hBU0FDUVVCcklnSWdCVTBOQUFzTElBSWdCRThOQVFOQUlBSWdBU2dDQURZQ0FDQUJRUVJxSVFFZ0FrRUVhaUlDSUFSSkRRQUxEQUVMSUFOQkJFa0VRQ0FBSVFJTUFRc2dBQ0FEUVFScklnUkxCRUFnQUNFQ0RBRUxJQUFoQWdOQUlBSWdBUzBBQURvQUFDQUNJQUV0QUFFNkFBRWdBaUFCTFFBQ09nQUNJQUlnQVMwQUF6b0FBeUFCUVFScUlRRWdBa0VFYWlJQ0lBUk5EUUFMQ3lBQ0lBTkpCRUFEUUNBQ0lBRXRBQUE2QUFBZ0FVRUJhaUVCSUFKQkFXb2lBaUFEUncwQUN3c2dBQXZ6QWdJQ2Z3RitBa0FnQWtVTkFDQUFJQUpxSWdOQkFXc2dBVG9BQUNBQUlBRTZBQUFnQWtFRFNRMEFJQU5CQW1zZ0FUb0FBQ0FBSUFFNkFBRWdBMEVEYXlBQk9nQUFJQUFnQVRvQUFpQUNRUWRKRFFBZ0EwRUVheUFCT2dBQUlBQWdBVG9BQXlBQ1FRbEpEUUFnQUVFQUlBQnJRUU54SWdScUlnTWdBVUgvQVhGQmdZS0VDR3dpQVRZQ0FDQURJQUlnQkd0QmZIRWlCR29pQWtFRWF5QUJOZ0lBSUFSQkNVa05BQ0FESUFFMkFnZ2dBeUFCTmdJRUlBSkJDR3NnQVRZQ0FDQUNRUXhySUFFMkFnQWdCRUVaU1EwQUlBTWdBVFlDR0NBRElBRTJBaFFnQXlBQk5nSVFJQU1nQVRZQ0RDQUNRUkJySUFFMkFnQWdBa0VVYXlBQk5nSUFJQUpCR0dzZ0FUWUNBQ0FDUVJ4cklBRTJBZ0FnQkNBRFFRUnhRUmh5SWdScklnSkJJRWtOQUNBQnJTSUZRaUNHSUFXRUlRVWdBeUFFYWlFQkEwQWdBU0FGTndNWUlBRWdCVGNERUNBQklBVTNBd2dnQVNBRk53TUFJQUZCSUdvaEFTQUNRU0JySWdKQkgwc05BQXNMSUFBTDZ3RUJDWDhnQUNnQ0lDSUVJQUFvQWh3aUFpQUJkaUlCU1NJR1JRUkFJQUFnQkNBQmF5SUVOZ0lnQ3lBQUlBRWdBaUFCYXlBR0d5SUZOZ0ljSUFWQmdJQ0FCRTBFUUNBQUtBSVlJUU1nQUNnQ0tDRUhJQUFvQWhRaENDQUFLQUlFSVFrRFFDQUFJQVZCQ0hRaUNqWUNIQ0FBSUFoQkNHb2lDRFlDRkVFQUlRRWdBeUFKU1FSQUlBQWdBMEVCYWlJQ05nSVlJQUFvQWdBZ0Eyb3RBQUFoQVNBQ0lRTUxJQUFnQVRZQ0tDQUFJQVJCQ0hSQmdQNy8vd2R4SUFFZ0IwRUlkSEpCQVhaQi93Rnhja0gvQVhNaUJEWUNJQ0FGUVlHQUFra2hBaUFCSVFjZ0NpRUZJQUlOQUFzTElBWUxyd1lCQlg4akFFRVFheUlESkFBZ0F5QUNOZ0lNUVhzaEFnSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FnQVVHN0gyc09GUUVDQ2dvR0NnTUtDZ29LQ2dvS0Nnb0tDZ29IQ0FBTEFrQUNRQUpBQWtBZ0FVR1h6Z0JyRGdvREFnMEFEUUVORFFjSURRc2dBeUFES0FJTUlnRkJCR28yQWd4QmZ5RUNJQUVvQWdBaUFVRUFTQTBNSUFFZ0FDZ0NBQ2dDQ0U0TkRDQUFJQUUyQWhRTUN3c2dBeUFES0FJTUlnRkJCR28yQWd4QmZ5RUNJQUVvQWdBaUFVRUJTQTBMSUFFZ0FDZ0NBQ2dDQ0VvTkN5QUFJQUUyQWhnTUNnc2dBeUFES0FJTUlnRkJCR28yQWd4QmZ5RUNJQUVvQWdBaUFVRUJhMEVCU3cwS0lBQWdBVFlDREF3SkN5QURJQU1vQWd3aUFVRUVhallDRENBQktBSUFJZ0ZGQkVCQmZ5RUNEQW9MSUFFZ0FDZ0NMRFlDQUVFQUlRSWdBRUVBTmdJc0RBa0xJQU1nQXlnQ0RDSUJRUVJxTmdJTUlBRW9BZ0FpQVVVRVFFRi9JUUlNQ1FzZ0FTQUFLQUlFSUFBb0FoQnROZ0lBREFjTElBQW9BZ1FoQmtFQUlRSWdBRUVvYWtFQUlBQW9BZ0FpQkNnQ0NDSUJRUVYwSUFBb0FnZ2lCU0FFS0FJRVFRSjBRZURBQUdwc2FrRTBhaEFGR2lBQlFRRk9CRUFnQVVFRGRDSUVJQUFnQmtHQUVHb2dCV3hCQW5ScUlBVkI0QUJzYW1wQjNBQnFJZ1VnQkdvaEJpQUJRUUYwSWdGQkFTQUJRUUZLR3lFRVFRQWhBUU5BSUFZZ0FVRUNkQ0lIYWtHQWdJQ1BmRFlDQUNBRklBZHFRWUNBZ0k5OE5nSUFJQUZCQVdvaUFTQUVSdzBBQ3dzZ0FFRUJOZ0k0REFjTElBTWdBeWdDRENJQlFRUnFOZ0lNSUFFb0FnQWlBVVVFUUVGL0lRSU1Cd3NnQVNBQUtBSThOZ0lBREFVTElBTWdBeWdDRENJQlFRUnFOZ0lNSUFFb0FnQWlBVVVFUUVGL0lRSU1CZ3NnQVNBQUtBSUFOZ0lBREFRTElBTWdBeWdDRENJQlFRUnFOZ0lNSUFBZ0FTZ0NBRFlDSEF3REN5QURJQU1vQWd3aUFVRUVhallDRENBQktBSUFJZ0ZGQkVCQmZ5RUNEQVFMSUFFZ0FDZ0NLRFlDQUF3Q0N5QURJQU1vQWd3aUFVRUVhallDREVGL0lRSWdBU2dDQUNJQlFRRkxEUUlnQUNBQk5nSWdEQUVMSUFNZ0F5Z0NEQ0lCUVFScU5nSU1JQUVvQWdBaUFVVUVRRUYvSVFJTUFnc2dBU0FBS0FJZ05nSUFDMEVBSVFJTElBTkJFR29rQUNBQ0M0SU5BUWQvQWtBZ0FFVU5BQ0FBUVFocklnTWdBRUVFYXlnQ0FDSUJRWGh4SWdCcUlRVUNRQ0FCUVFGeERRQWdBVUVEY1VVTkFTQURJQU1vQWdBaUFtc2lBMEd3K3dFb0FnQWlCRWtOQVNBQUlBSnFJUUFnQTBHMCt3RW9BZ0JIQkVBZ0FrSC9BVTBFUUNBREtBSUlJZ1FnQWtFRGRpSUNRUU4wUWNqN0FXcEhHaUFFSUFNb0Fnd2lBVVlFUUVHZyt3RkJvUHNCS0FJQVFYNGdBbmR4TmdJQURBTUxJQVFnQVRZQ0RDQUJJQVEyQWdnTUFnc2dBeWdDR0NFR0FrQWdBeUFES0FJTUlnRkhCRUFnQXlnQ0NDSUNJQVJQQkVBZ0FpZ0NEQm9MSUFJZ0FUWUNEQ0FCSUFJMkFnZ01BUXNDUUNBRFFSUnFJZ0lvQWdBaUJBMEFJQU5CRUdvaUFpZ0NBQ0lFRFFCQkFDRUJEQUVMQTBBZ0FpRUhJQVFpQVVFVWFpSUNLQUlBSWdRTkFDQUJRUkJxSVFJZ0FTZ0NFQ0lFRFFBTElBZEJBRFlDQUFzZ0JrVU5BUUpBSUFNZ0F5Z0NIQ0lDUVFKMFFkRDlBV29pQkNnQ0FFWUVRQ0FFSUFFMkFnQWdBUTBCUWFUN0FVR2srd0VvQWdCQmZpQUNkM0UyQWdBTUF3c2dCa0VRUVJRZ0JpZ0NFQ0FEUmh0cUlBRTJBZ0FnQVVVTkFnc2dBU0FHTmdJWUlBTW9BaEFpQWdSQUlBRWdBallDRUNBQ0lBRTJBaGdMSUFNb0FoUWlBa1VOQVNBQklBSTJBaFFnQWlBQk5nSVlEQUVMSUFVb0FnUWlBVUVEY1VFRFJ3MEFRYWo3QVNBQU5nSUFJQVVnQVVGK2NUWUNCQ0FESUFCQkFYSTJBZ1FnQUNBRGFpQUFOZ0lBRHdzZ0F5QUZUdzBBSUFVb0FnUWlBVUVCY1VVTkFBSkFJQUZCQW5GRkJFQWdCVUc0K3dFb0FnQkdCRUJCdVBzQklBTTJBZ0JCclBzQlFhejdBU2dDQUNBQWFpSUFOZ0lBSUFNZ0FFRUJjallDQkNBRFFiVDdBU2dDQUVjTkEwR28rd0ZCQURZQ0FFRzArd0ZCQURZQ0FBOExJQVZCdFBzQktBSUFSZ1JBUWJUN0FTQUROZ0lBUWFqN0FVR28rd0VvQWdBZ0FHb2lBRFlDQUNBRElBQkJBWEkyQWdRZ0FDQURhaUFBTmdJQUR3c2dBVUY0Y1NBQWFpRUFBa0FnQVVIL0FVMEVRQ0FGS0FJTUlRSWdCU2dDQ0NJRUlBRkJBM1lpQVVFRGRFSEkrd0ZxSWdkSEJFQkJzUHNCS0FJQUdnc2dBaUFFUmdSQVFhRDdBVUdnK3dFb0FnQkJmaUFCZDNFMkFnQU1BZ3NnQWlBSFJ3UkFRYkQ3QVNnQ0FCb0xJQVFnQWpZQ0RDQUNJQVEyQWdnTUFRc2dCU2dDR0NFR0FrQWdCU0FGS0FJTUlnRkhCRUFnQlNnQ0NDSUNRYkQ3QVNnQ0FFOEVRQ0FDS0FJTUdnc2dBaUFCTmdJTUlBRWdBallDQ0F3QkN3SkFJQVZCRkdvaUFpZ0NBQ0lFRFFBZ0JVRVFhaUlDS0FJQUlnUU5BRUVBSVFFTUFRc0RRQ0FDSVFjZ0JDSUJRUlJxSWdJb0FnQWlCQTBBSUFGQkVHb2hBaUFCS0FJUUlnUU5BQXNnQjBFQU5nSUFDeUFHUlEwQUFrQWdCU0FGS0FJY0lnSkJBblJCMFAwQmFpSUVLQUlBUmdSQUlBUWdBVFlDQUNBQkRRRkJwUHNCUWFUN0FTZ0NBRUYrSUFKM2NUWUNBQXdDQ3lBR1FSQkJGQ0FHS0FJUUlBVkdHMm9nQVRZQ0FDQUJSUTBCQ3lBQklBWTJBaGdnQlNnQ0VDSUNCRUFnQVNBQ05nSVFJQUlnQVRZQ0dBc2dCU2dDRkNJQ1JRMEFJQUVnQWpZQ0ZDQUNJQUUyQWhnTElBTWdBRUVCY2pZQ0JDQUFJQU5xSUFBMkFnQWdBMEcwK3dFb0FnQkhEUUZCcVBzQklBQTJBZ0FQQ3lBRklBRkJmbkUyQWdRZ0F5QUFRUUZ5TmdJRUlBQWdBMm9nQURZQ0FBc2dBRUgvQVUwRVFDQUFRUU4ySWdGQkEzUkJ5UHNCYWlFQUFuOUJvUHNCS0FJQUlnSkJBU0FCZENJQmNVVUVRRUdnK3dFZ0FTQUNjallDQUNBQURBRUxJQUFvQWdnTElRSWdBQ0FETmdJSUlBSWdBellDRENBRElBQTJBZ3dnQXlBQ05nSUlEd3RCSHlFQ0lBTkNBRGNDRUNBQVFmLy8vd2ROQkVBZ0FFRUlkaUlCSUFGQmdQNC9ha0VRZGtFSWNTSUJkQ0lDSUFKQmdPQWZha0VRZGtFRWNTSUNkQ0lFSUFSQmdJQVBha0VRZGtFQ2NTSUVkRUVQZGlBQklBSnlJQVJ5YXlJQlFRRjBJQUFnQVVFVmFuWkJBWEZ5UVJ4cUlRSUxJQU1nQWpZQ0hDQUNRUUowUWREOUFXb2hBUUpBQWtBQ1FFR2srd0VvQWdBaUJFRUJJQUowSWdkeFJRUkFRYVQ3QVNBRUlBZHlOZ0lBSUFFZ0F6WUNBQ0FESUFFMkFoZ01BUXNnQUVFQVFSa2dBa0VCZG1zZ0FrRWZSaHQwSVFJZ0FTZ0NBQ0VCQTBBZ0FTSUVLQUlFUVhoeElBQkdEUUlnQWtFZGRpRUJJQUpCQVhRaEFpQUVJQUZCQkhGcUlnZEJFR29vQWdBaUFRMEFDeUFISUFNMkFoQWdBeUFFTmdJWUN5QURJQU0yQWd3Z0F5QUROZ0lJREFFTElBUW9BZ2dpQUNBRE5nSU1JQVFnQXpZQ0NDQURRUUEyQWhnZ0F5QUVOZ0lNSUFNZ0FEWUNDQXRCd1BzQlFjRDdBU2dDQUVFQmF5SUFRWDhnQUJzMkFnQUxDNk1CQVFaL0lBQW9BZ3doQXdKQUlBRWdBQ2dDRUNJQ1RRUkFJQUloQkF3QkN5QUFLQUlJSVFVZ0FDZ0NCQ0VHQTBCQkFDRUVJQVVnQmtrRWZ5QUFJQVZCQVdvaUJUWUNDQ0FBS0FJQUlBWWdCV3RxTFFBQUJVRUFDeUFDZENBRGNpRURJQUpCRVVnaEJ5QUNRUWhxSWdRaEFpQUhEUUFMQ3lBQUlBUWdBV3MyQWhBZ0FDQURJQUYyTmdJTUlBQWdBQ2dDRkNBQmFqWUNGQ0FEUVg4Z0FYUkJmM054QzhFUUFnNS9BbjBnQWlBRWJpRVRJQUFvQWdBaEZ3SkFJQUpCQVVZRVFDQUFLQUlnSVFNZ0FDZ0NIQ0VDQWtBZ0Z3UkFJQU5CQjBvRVFDQUNJQUVxQWdCREFBQUFBRjBpRFJBZ0lBQWdBQ2dDSUVFSWF6WUNJQXNnQUNnQ0JFVU5BU0FCUXdBQWdMOURBQUNBUHlBTkd6Z0NBQXdCQ3lBRFFRaE9CRUFnQWtFQkVBa2hEU0FBSUFBb0FpQkJDR3MyQWlBTElBQW9BZ1JGRFFBZ0FVTUFBSUMvUXdBQWdEOGdEUnM0QWdBTFFRRWhDaUFIUlEwQklBY2dBU29DQURnQ0FFRUJEd3NnQUNnQ0dDSVNRUUJLSVFzQ1FDQUZSUVJBSUFVaENRd0JDeUFKUlFSQUlBVWhDUXdCQ3dKQUlCSkJBRW9OQUNBRVFRRktEUUFnRTBFQmNVVWdFa0VBUjNFTkFDQUZJUWtNQVFzZ0NTQUZJQUpCQW5RUUJCb0xJQkpCQUNBTEd5RVFBa0FnRWtFQlNBMEFJQmRGQkVBRFFBSkFJQWxGRFFBZ0RFRWZSZzBBSUFJZ0RIVWlCVUVDU0EwQVFRRWdESFFpRVVFQmRDRU9JQVZCQVhVaUJVRUJJQVZCQVVvYklROUJBQ0VOQTBCQkFDRUZBMEFnQ1NBRklBNXNJQTFxUVFKMGFpSUxJQXNxQWdCRDh3UTFQNVFpR2lBSklBVkJBWFJCQVhJZ0RIUWdEV3BCQW5ScUlnc3FBZ0JEOHdRMVA1UWlHWkk0QWdBZ0N5QWFJQm1UT0FJQUlBVkJBV29pQlNBUFJ3MEFDeUFOUVFGcUlnMGdFVWNOQUFzTElBcEJEM0ZCMERscUxRQUFJQXBCQkhWQjBEbHFMUUFBUVFKMGNpRUtJQXhCQVdvaURDQVFSdzBBREFJTEFBc0RRQUpBSUF4QkgwWWlEZzBBSUFJZ0RIVWlCVUVDU0NJUERRQkJBU0FNZENJVlFRRjBJUllnQlVFQmRTSUZRUUVnQlVFQlNoc2hFVUVBSVEwRFFFRUFJUVVEUUNBQklBVWdGbXdnRFdwQkFuUnFJZ3NnQ3lvQ0FFUHpCRFUvbENJYUlBRWdCVUVCZEVFQmNpQU1kQ0FOYWtFQ2RHb2lDeW9DQUVQekJEVS9sQ0laa2pnQ0FDQUxJQm9nR1pNNEFnQWdCVUVCYWlJRklCRkhEUUFMSUExQkFXb2lEU0FWUncwQUN5QUpSUTBBSUE0TkFDQVBEUUJCQUNFTkEwQkJBQ0VGQTBBZ0NTQUZJQlpzSUExcVFRSjBhaUlMSUFzcUFnQkQ4d1ExUDVRaUdpQUpJQVZCQVhSQkFYSWdESFFnRFdwQkFuUnFJZ3NxQWdCRDh3UTFQNVFpR1pJNEFnQWdDeUFhSUJtVE9BSUFJQVZCQVdvaUJTQVJSdzBBQ3lBTlFRRnFJZzBnRlVjTkFBc0xJQXBCRDNGQjBEbHFMUUFBSUFwQkJIVkIwRGxxTFFBQVFRSjBjaUVLSUF4QkFXb2lEQ0FRUncwQUN3c2dCQ0FRZFNFTUFrQUNRQ0FUSUJCMElnOUJBWEVOQUNBU1FYOUtEUUFnRndSQUlCSWhFUU5BSUE5QkFYVWhEZ0pBSUF4QkFVZ2lGUTBBSUE5QkFrZ2lGZzBBSUF4QkFYUWhHQ0FPUVFFZ0RrRUJTaHNoRTBFQUlRMERRRUVBSVFVRFFDQUJJQVVnR0d3Z0RXcEJBblJxSWdzZ0N5b0NBRVB6QkRVL2xDSWFJQUVnQlVFQmRFRUJjaUFNYkNBTmFrRUNkR29pQ3lvQ0FFUHpCRFUvbENJWmtqZ0NBQ0FMSUJvZ0daTTRBZ0FnQlVFQmFpSUZJQk5IRFFBTElBMUJBV29pRFNBTVJ3MEFDeUFKUlEwQUlCVU5BQ0FXRFFCQkFDRU5BMEJCQUNFRkEwQWdDU0FGSUJoc0lBMXFRUUowYWlJTElBc3FBZ0JEOHdRMVA1UWlHaUFKSUFWQkFYUkJBWElnREd3Z0RXcEJBblJxSWdzcUFnQkQ4d1ExUDVRaUdaSTRBZ0FnQ3lBYUlCbVRPQUlBSUFWQkFXb2lCU0FUUncwQUN5QU5RUUZxSWcwZ0RFY05BQXNMSUJSQkFXb2hGQ0FNUVFGMElRc2dDaUFNZENBS2NpRUtJQTlCQW5FTkF5QVJRWDlJSVFVZ0VVRUJhaUVSSUFzaERDQU9JUThnQlEwQUN3d0NDeUFKUVFCSFFRRnpJUk1nRWlFUkEwQWdEMEVCZFNFT0FrQWdERUVCU0NBVGNnMEFJQTlCQWtnTkFDQU1RUUYwSVJVZ0RrRUJJQTVCQVVvYklSWkJBQ0VOQTBCQkFDRUZBMEFnQ1NBRklCVnNJQTFxUVFKMGFpSUxJQXNxQWdCRDh3UTFQNVFpR2lBSklBVkJBWFJCQVhJZ0RHd2dEV3BCQW5ScUlnc3FBZ0JEOHdRMVA1UWlHWkk0QWdBZ0N5QWFJQm1UT0FJQUlBVkJBV29pQlNBV1J3MEFDeUFOUVFGcUlnMGdERWNOQUFzTElCUkJBV29oRkNBTVFRRjBJUXNnQ2lBTWRDQUtjaUVLSUE5QkFuRU5BaUFSUVg5SUlRVWdFVUVCYWlFUklBc2hEQ0FPSVE4Z0JRMEFDd3dCQ3lBUElRNGdEQ0VMQ3lBRVFRRkdJUVFDUUNBTFFRSklEUUFnRndSQUlBRWdEaUFRZFNBTElCQjBJQVFRUEFzZ0NVVU5BQ0FKSUE0Z0VIVWdDeUFRZENBRUVEd0xJQUFnQVNBQ0lBTWdDeUFKSUFZZ0NDQUtFQkVoQ2lBQUtBSUVSUTBBSUF0QkFrNEVRQ0FCSUE0Z0VIVWdDeUFRZENBRUVHQUxJQlFFUUVFQUlROERRQ0FPUVFGMElRNGdDaUFMSWdCQkFYVWlDM1loQmdKQUlBQkJBa2dOQUNBT1FRSklEUUFnQUVGK2NTRUVJQTVCQVhVaUFFRUJJQUJCQVVvYklRTkJBQ0VKQTBCQkFDRUZBMEFnQVNBRUlBVnNJQWxxUVFKMGFpSUFJQUFxQWdCRDh3UTFQNVFpR1NBQklBVkJBWFJCQVhJZ0Myd2dDV3BCQW5ScUlnQXFBZ0JEOHdRMVA1UWlDSkk0QWdBZ0FDQVpJQWlUT0FJQUlBVkJBV29pQlNBRFJ3MEFDeUFKUVFGcUlna2dDMGNOQUFzTElBWWdDbkloQ2lBUFFRRnFJZzhnRkVjTkFBc0xRUUFoRENBU1FRQktCRUFEUUNBS1FlQTVhaTBBQUNFS0FrQWdERUVmUmcwQUlBSWdESFVpQUVFQ1NBMEFRUUVnREhRaUJrRUJkQ0VFSUFCQkFYVWlBRUVCSUFCQkFVb2JJUU5CQUNFSkEwQkJBQ0VGQTBBZ0FTQUVJQVZzSUFscVFRSjBhaUlBSUFBcUFnQkQ4d1ExUDVRaUdTQUJJQVZCQVhSQkFYSWdESFFnQ1dwQkFuUnFJZ0FxQWdCRDh3UTFQNVFpQ0pJNEFnQWdBQ0FaSUFpVE9BSUFJQVZCQVdvaUJTQURSdzBBQ3lBSlFRRnFJZ2tnQmtjTkFBc0xJQXhCQVdvaURDQVFSdzBBQ3dzZ0N5QVFkQ0VEQWtBZ0IwVU5BQ0FDUVFGSURRQWdBcmVmdGlFSVFRQWhCUU5BSUFjZ0JVRUNkQ0lBYWlBQUlBRnFLZ0lBSUFpVU9BSUFJQVZCQVdvaUJTQUNSdzBBQ3dzZ0NrRi9JQU4wUVg5emNTRUtDeUFLQ3o4QkFYOGdBQ2dDRkVFRGRDQUFLQUljSWdCbklnRkJBM1JxSUFCQkVDQUJhM1lpQUNBQVFReDJJZ0JCQW5SQmdOa0JhaWdDQUV0cklBQnJRZmdCYXd0aEFRSi9Jd0JCRUdzaUFTUUFJQUJCQVd0QkFVMEVRQ0FCUWVqQ0FEWUNEQ0FCSUFFb0FneEJBMnBCZkhFMkFnd2dBU2dDREVHZ1BTZ0NBRUVDZEVIZ3dBQnFJQUJzUWFROUtBSUFRUVYwYW1wQnRBRnFJUUlMSUFGQkVHb2tBQ0FDQzI4QkFYOGpBRUdBQW1zaUJTUUFBa0FnQWlBRFRBMEFJQVJCZ01BRWNRMEFJQVVnQVVIL0FYRWdBaUFEYXlJQ1FZQUNJQUpCZ0FKSklnRWJFQVVhSUFGRkJFQURRQ0FBSUFWQmdBSVFFQ0FDUVlBQ2F5SUNRZjhCU3cwQUN3c2dBQ0FGSUFJUUVBc2dCVUdBQW1va0FBdnBBZ0VCZndKQUlBQWdBVVlOQUNBQklBQnJJQUpyUVFBZ0FrRUJkR3ROQkVBZ0FDQUJJQUlRQkE4TElBQWdBWE5CQTNFaEF3SkFBa0FnQUNBQlNRUkFJQU1FUUNBQUlRTU1Bd3NnQUVFRGNVVUVRQ0FBSVFNTUFnc2dBQ0VEQTBBZ0FrVU5CQ0FESUFFdEFBQTZBQUFnQVVFQmFpRUJJQUpCQVdzaEFpQURRUUZxSWdOQkEzRU5BQXNNQVFzQ1FDQUREUUFnQUNBQ2FrRURjUVJBQTBBZ0FrVU5CU0FBSUFKQkFXc2lBbW9pQXlBQklBSnFMUUFBT2dBQUlBTkJBM0VOQUFzTElBSkJBMDBOQUFOQUlBQWdBa0VFYXlJQ2FpQUJJQUpxS0FJQU5nSUFJQUpCQTBzTkFBc0xJQUpGRFFJRFFDQUFJQUpCQVdzaUFtb2dBU0FDYWkwQUFEb0FBQ0FDRFFBTERBSUxJQUpCQTAwTkFBTkFJQU1nQVNnQ0FEWUNBQ0FCUVFScUlRRWdBMEVFYWlFRElBSkJCR3NpQWtFRFN3MEFDd3NnQWtVTkFBTkFJQU1nQVMwQUFEb0FBQ0FEUVFGcUlRTWdBVUVCYWlFQklBSkJBV3NpQWcwQUN3c2dBQXRWQVFKL1FaRDRBU2dDQUNJQklBQkJBMnBCZkhFaUFtb2hBQUpBSUFKQkFVNUJBQ0FBSUFGTkd3MEFQd0JCRUhRZ0FFa0VRQ0FBRUFKRkRRRUxRWkQ0QVNBQU5nSUFJQUVQQzBHYyt3RkJNRFlDQUVGL0N4Y0FJQUF0QUFCQklIRkZCRUFnQVNBQ0lBQVFqQUVMQzg0TkFndC9BbjBqQUVFZ2F5SU5KQUFnRFNBSU5nSVlJQTBnQXpZQ0hDQUFLQUlJSWdrb0FtUWlDaUFKS0FKZ0lnc2dBQ2dDRENJUElBa29BZ2dnQmtFQmFteHFRUUYwYWk0QkFHb2hEa0YvSVF3Z0FDZ0NIQ0VSSUFBb0FoUWhFaUFBS0FJQUlSTUNRQUpBQWtBQ1FBSkFBbjhnQmtGL1JnUkFJQW9nQ3lBUFFRRjBhaTRCQUdvaUNTMEFBQ0lHSUFaQkFXcEJBWFlpQ2lBRFFRRnJJZ1lnQ1NBS2FpMEFBRW9pQXhzaUN5QUxJQXBCQUNBREd5SUtha0VCYWtFQmRpSURJQVlnQXlBSmFpMEFBRW9pQ3hzaUR5QVBJQU1nQ2lBTEd5SUtha0VCYWtFQmRpSURJQVlnQXlBSmFpMEFBRW9pQ3hzaUR5QVBJQU1nQ2lBTEd5SUtha0VCYWtFQmRpSURJQVlnQXlBSmFpMEFBRW9pQ3hzaUR5QVBJQU1nQ2lBTEd5SUtha0VCYWtFQmRTSURJQVlnQXlBSmFpMEFBRW9pQ3hzaUR5QVBJQU1nQ2lBTEd5SUxha0VCYWtFQmRTSURJQVlnQXlBSmFpMEFBRW9pRHhzaENpQURJQXNnRHhzaUN3UkFJQWtnQzJvdEFBQWhEQXRCQUNBS0lBc2dCaUFNYXlBSklBcHFMUUFBSUFaclNoc2lCa1VOQVJvZ0JpQUphaTBBQUVFQmFpRVFJQVlNQVFzZ0RpMEFBQ0VKSUFKQkEwNEVRQ0FKSUE1cUxRQUFRUXhxSUFOSURRSUxJQWtnQ1VFQmFrRUJkaUlKSUFOQkFXc2lCaUFKSUE1cUxRQUFTaUlER3lJS0lBb2dDVUVBSUFNYklnbHFRUUZxUVFGMklnTWdCaUFESUE1cUxRQUFTaUlLR3lJTElBc2dBeUFKSUFvYklnbHFRUUZxUVFGMklnTWdCaUFESUE1cUxRQUFTaUlLR3lJTElBc2dBeUFKSUFvYklnbHFRUUZxUVFGMklnTWdCaUFESUE1cUxRQUFTaUlLR3lJTElBc2dBeUFKSUFvYklnbHFRUUZxUVFGMUlnTWdCaUFESUE1cUxRQUFTaUlLR3lJTElBc2dBeUFKSUFvYklncHFRUUZxUVFGMUlnTWdCaUFESUE1cUxRQUFTaUlMR3lFSklBTWdDaUFMR3lJS0JFQWdDaUFPYWkwQUFDRU1DMEVBSUFrZ0NpQUdJQXhySUFrZ0Rtb3RBQUFnQm10S0d5SUdSUTBBR2lBR0lBNXFMUUFBUVFGcUlSQWdCZ3NoQXlBQUlBQW9BaUFnRUdzaUNUWUNJQ0FKUVg5TURRRWdBeUVHREFJTElBWkJBV3NoQTBFQklRa2dBU0FDUVFGMklnSkJBblJxSVE0Q1FDQUVRUUZIQkVBZ0FDQU5JQUVnRGlBQ0lBMUJIR29nQkVFQmFrRUJkU0lKSUFRZ0EwRUFJQTFCR0dvUUl3d0JDeUFOSUFoQkFYRWdDRUVCZEhJMkFoZ2dBQ0FOSUFFZ0RpQUNJQTFCSEdwQkFVRUJJQU5CQUNBTlFSaHFFQ01MSUEwb0FoQWhDQ0FOS0FJSXNpRVVJQTBvQWdTeUlSVWdEU2dDRkNFUUlBMG9BZ3doREFKQUlBUkJBa2dOQUNBSVFmLy9BSEZGRFFBZ0NFR0J3QUJPQkVBZ0RDQU1RUVVnQm10MWF5RU1EQUVMSUF3Z0FrRURkRUVHSUFacmRXb2lCa0VmZFNBR2NTRU1DeUFVUXdBQUFEaVVJUlFnRlVNQUFBQTRsQ0VWSUEwb0Fod2hCaUFBSUFBb0FpQWdFR3NpRURZQ0lDQUZJQUpCQW5ScVFRQWdCUnNoRVNBR0lBWWdER3RCQW0waURDQUdJQXhJR3lJTVFRQWdERUVBU2hzaURDQUdJQXhySWdaT0JFQWdBQ0FCSUFJZ0RDQUpJQVVnQXlBVklBZVVJQTBvQWhnaUFSQVJJQUFnRGlBQ0lBQW9BaUFnRUdzZ0RHb2lBRUVZYTBFQUlBQkJHRW9iUVFBZ0NCc2dCbW9nQ1NBUklBTWdGQ0FIbENBQklBbDFFQkVnQkVFQmRYUnlJUWtNQkFzZ0FDQU9JQUlnQmlBSklCRWdBeUFVSUFlVUlBMG9BaGdpRGlBSmRSQVJJUkVnQUNBQklBSWdBQ2dDSUNBUWF5QUdhaUlBUVJoclFRQWdBRUVZU2h0QkFDQUlRWUNBQVVjYklBeHFJQWtnQlNBRElCVWdCNVFnRGhBUklCRWdCRUVCZFhSeUlRa01Bd3NnQTBFQlNBUkFJQU1oQmd3QkN3TkFJQUFnQ1NBUWFpSUpOZ0lnSUFOQkFXc2lCa1VFUUNBQUlBazJBaUFNQXdzZ0FDQUpJQVlnRG1vdEFBQkJBV29pRUdzaUNUWUNJQ0FKUVg5S0RRRWdBMEVCU2lFTUlBWWhBeUFNRFFBTEN5QUdSUTBBSUFaQkNFNEVRQ0FHUVFkeFFRaHlJQVpCQTNaQkFXdDBJUVlMSUJNRVFDQUJJQUlnQmlBU0lBUWdFU0FISUFBb0FnUWdBQ2dDTEJDWUFTRUpEQUlMSUFFZ0FpQUdJQklnQkNBUklBY1FsZ0VoQ1F3QkN5QUFLQUlFUlFSQVFRQWhDUXdCQ3lBTlFYOGdCSFJCZjNNaUNTQUljU0lFTmdJWUlBUkZCRUJCQUNFSklBRkJBQ0FDUVFKMEVBVWFEQUVMQWtBZ0JRUkFJQUpCQVU0RVFDQUFLQUlvSVFOQkFDRUdBMEFnQVNBR1FRSjBJZ2hxSUFVZ0NHb3FBZ0JEQUFDQU8wTUFBSUM3SUFOQmpjemxBR3hCMythNzR3TnFJZ05CZ0lBQ2NSdVNPQUlBSUFaQkFXb2lCaUFDUncwQUN5QUFJQU0yQWlnTElBUWhDUXdCQ3lBQ1FRRklEUUFnQUNnQ0tDRURRUUFoQmdOQUlBRWdCa0VDZEdvZ0EwR056T1VBYkVIZjVydmpBMm9pQTBFVWRiSTRBZ0FnQmtFQmFpSUdJQUpIRFFBTElBQWdBellDS0FzZ0FTQUNJQWNnQUNnQ0xCQXVDeUFOUVNCcUpBQWdDUXVyQWdJRmZ3RjlJQUFvQWl3Z0Jtd2hDaUFBS0FJZ0lnc2dCVUVCZEdvdUFRQWdCbXdoQUNBSFFRRkhCRUFnQUNBS0lBZHRJZ2NnQUNBSFNCc2hBQXRCQUNBRklBZ2JJUXdnQzBFQUlBUWdDQnNpQkVFQmRHb3VBUUFpRFNBR2JDSUpRUUowSVFjZ0FpRUZJQWxCQVU0RVFDQUNRUUFnQnhBRklBZHFJUVVMUVFBZ0FDQUlHeUVKSUFRZ0RFZ0VRQ0FCSUFkcUlRZ0RRQ0FESUFSQkFuUWlBR29xQWdBZ0FFSEEyUUZxS2dJQWtrTUFBQUJDbHJ0RTd6bjYva0l1NWoraUVCKzJJUTRnQmlBTmJDRUFJQXNnQkVFQmFpSUVRUUYwYWk0QkFDSU5JQVpzSVFFRFFDQUZJQWdxQWdBZ0RwUTRBZ0FnQlVFRWFpRUZJQWhCQkdvaENDQUFRUUZxSWdBZ0FVZ05BQXNnQkNBTVJ3MEFDd3NnQWlBSlFRSjBha0VBSUFvZ0NXdEJBblFRQlJvTGd4Z0RGMzhCZlFGOEl3QkJ3QUZySWdZa0FDQUdRUUEyQW9nQlFYNGhCUUpBSUFBb0Fnd2lGVUV5YlNJUFFRTjFJaEFnQkVvTkFDQUFLQUlBSVJvZ0FDZ0NCQ0VJSUE5QkFuVWhEQ0FQUVFGMUlRc2dCQ0FWUVJsdFFRTnNJZ1VnQkNBRlNCc2hCUUpBQW44Q1FBSkFBa0FnQmdKL0FrQUNRQUpBQWtBQ1FBSkFBa0FnQWtFQlRBUkFJQVVnQUNnQ1FDSUJJQUVnQlVvYklRVU1BUXNnQVEwQkN5QUFLQUk4SWdSRkJFQWdBQ2dDQ0NBRmJDSUFRUUZJRFEwZ0EwRUFJQUJCQW5RUUJSb01EUXNnQlNBUFNnUkFJQVVoQkFOQUlBQkJBRUVBSUFNZ0JDQVBJQVFnRDBnYkVCTWlBVUVBU0FSQUlBRWhCUXdQQ3lBRElBQW9BZ2dnQVd4QkFuUnFJUU1nQkNBQmF5SUVRUUJLRFFBTERBMExJQVVnRDA0TkFVRUJJUkVnQlNBTFNnUkFJQXNoQ1F3RUN5QUVRZWdIUmdSQVFRQWhBVUhvQnlFRUlBVWhDUXdHQ3lBTUlBVWdCU0FMU0JzZ0JTQUZJQXhLR3lFSkRBTUxJQUFvQWpRaEZDQUFLQUk0SVFRZ0FDZ0NRQ0VKSUFaQmtBRnFJQUVnQWhCVFFRRWhEU0FBS0FJOElncEJBVWdFUUVFQklSRU1CQXNDUUFKQUFrQWdDa0hxQjBZTkFDQUVRZW9IUncwQUlBQW9Ba1JGRFFFTElBUkI2Z2RHQkVCQjZnY2hCRUVCSVJFTUJnc2dDa0hxQjBZTkFVRUJJUkVNQlFzZ0JFSHFCMFlOQWdzZ0FDZ0NDQ0FNYkNFUlFRRWhGd3dEQ3lBRVFlb0hSd1JBUVFFaEVVRUFJUUVnQlNFSkRBUUxJQVpCRUdzaUN5SVlKQUJCQVNFUklBVWhDVUVBSVFGQkFTRVNEQVVMSUFZZ0FDZ0NDQ0FNYkVFQ2RFRVBha0Z3Y1dzaUNpSUVKQUFnQUVFQVFRQWdDaUFNSUFrZ0NTQU1TaHNRRXhvZ0JTQUpTQ0VMUVg4aEJTQUxEUWdnQkVFUWF5SUxJaGdrQUVFQklSZEJBU0VSUVFFaEVnd0VDMEVBSVFFTElBVWdDVWdoQ2tGL0lRVWdDZzBHUWVvSElSTkJBU0VTUVFFZ0JFSHFCMFlOQVJvTFFRQWhFaUFFSVJNZ0FDZ0NDQ0FMSUFrZ0NTQUxTQnRzQzBFQmRFRVBha0Z3Y1dzaUN5SVlKQUJCQUNFS0lCTkI2Z2RISWc0TkFRdEI2Z2NoRTBFQUlRNE1BUXNnQUNBSWFpRUtJQUFvQWp4QjZnZEdCRUFnQ2hCRUdnc2dBQ0FKUWVnSGJDQUFLQUlNYlNJRVFRb2dCRUVLU2hzMkFpQWdEUVJBSUFBZ0FDZ0NNRFlDRkVHQS9RQWhCQUpBSUJOQjZBZEhEUUFnRkVITkNHc2lCVUVDU3cwQUlBVkJvQjlzUWNBK2FpRUVDeUFBSUFRMkFod0xJQUJCRUdvaEZrRUFJUVFDUUNBQlJTSVpSUVJBSUFzaEJRTkFJQW9nRmtFQUlBUkZJQVpCa0FGcUlBVWdCa0dNQVdvZ0FDZ0NMQkJEQkVCQmZTRUZEQVlMSUFVZ0JpZ0NqQUVpQ0NBQUtBSUliRUVCZEdvaEJTQUVJQWhxSWdRZ0NVZ05BQXNNQVFzZ0N5RUZBMEFDUUNBS0lCWWdHU0FFUlNBR1FaQUJhaUFGSUFaQmpBRnFJQUFvQWl3UVEwVUVRQ0FHS0FLTUFTSUlJQUFvQWdoc0lRY01BUXNnQmlBSk5nS01BU0FBS0FJSUlBbHNJZ2RCQVU0RVFDQUZRUUFnQjBFQmRCQUZHZ3NnQ1NFSUN5QUZJQWRCQVhScUlRVWdCQ0FJYWlJRUlBbElEUUFMQzBFQUlRcEJFU0VaSUExQkFYRkZEUUFnQmlnQ3BBRWdCaWdDckFGbmFrRVVRUUFnQUNnQ09FSHBCMFliYWtFUGF5QUNRUU4wU2cwQUFrQWdFMEhwQjBZRVFDQUdRWkFCYWtFTUVBWWlDRVVFUUVIcEJ5RVREQU1MSUFaQmtBRnFRUUVRQmlFSElBWkJrQUZxUVlBQ0VCWkJBbW9oQkNBR0tBS3NBV2NoQlNBR0tBS2tBU0VOREFFTFFRRWhDQ0FHUVpBQmFrRUJFQVloQnlBQ0lBWW9BcVFCSWcwZ0JpZ0NyQUZuSWdWcVFSbHJRUU4xYXlFRUN5QUdJQVlvQXBRQlFRQWdCQ0FGSUExcVFTQnJJQUlnQkdzaUFrRURkRW9pQkJzaURXczJBcFFCUVFBZ0FpQUVHeUVDUVFBZ0NDQUVHd3dCQzBFQUlRMUJBQ0VIUVFBTEloWkZJaHNnRjNFaEZ5QVlRUUVnRVNBV0cwRUNkRUVQYWtGd2NXc2lCQ0lJSkFBQ1FDQU9SUTBBSUJkRkRRQWdBRUVBUVFBZ0JDQU1JQWtnQ1NBTVNoc1FFeG9nQkNFS0N5QUFJQnBxSVFRQ1FBSkFBa0FDUUFKQUFrQWdGRUhOQ0dzT0JBQUJBUUlEQzBFTklRVU1Bd3RCRVNFRkRBSUxRUk1oQlF3QkMwRVZJUVVnRkVVTkFRc2dCaUFGTmdLQUFVRjlJUVVnQkVHY3pnQWdCa0dBQVdvUUJ3MEJDeUFHSUFBb0FqQTJBbkJCZlNFRklBUkJtTTRBSUFaQjhBQnFFQWNOQUFKL0lCWkZCRUJCQUNFT0lBaEJFR3NpQ0NRQUlBZEJBRWNNQVFzZ0NDQUFLQUlJSUF4c1FRSjBRUTlxUVhCeGF5SUlKQUFnQjBVRVFFRUFJUTVCQUF3QkN5QUdRUUEyQW1BZ0JFR2F6Z0FnQmtIZ0FHb1FCdzBCSUFRZ0FTQUNhaUFOSUFnZ0RFRUFFQmdhSUFZZ0JrR0lBV28yQWxBZ0JFRy9IeUFHUWRBQWFoQUhEUUZCQVNFT1FRRUxJUkVnQmlBWk5nSkFJQVJCbXM0QUlBWkJRR3NRQncwQUFuOGdFMEhvQjBjRVFBSkFJQk1nQUNnQ1BDSUhSZzBBSUFkQkFVZ05BQ0FBS0FKRURRQWdCRUc4SDBFQUVBY05Bd3NnQkNBQklBSWdBeUFQSUFrZ0NTQVBTaHNnQmtHUUFXb1FHQXdCQ3lBR1FmLy9BenNCaEFFZ0FDZ0NDQ0FKYkNJSFFRRk9CRUFnQTBFQUlBZEJBblFRQlJvTEFrQWdBQ2dDUEVIcEIwY05BQ0FPQkVBZ0FDZ0NSQTBCQ3lBR1FRQTJBakFnQkVHYXpnQWdCa0V3YWhBSERRSWdCQ0FHUVlRQmFrRUNJQU1nRUVFQUVCZ2FDMEVBQ3lFUEFrQWdFZzBBSUFBb0FnZ2dDV3dpRWtFQlNBMEFRUUFoQndOQUlBTWdCMEVDZEdvaUZDQVVLZ0lBSUFzZ0IwRUJkR291QVFDeVF3QUFBRGlVa2pnQ0FDQUhRUUZxSWdjZ0VrY05BQXNMSUFZZ0JrR0VBV28yQWlBZ0JFR2Z6Z0FnQmtFZ2FoQUhEUUFnQmlnQ2hBRW9BandoQ3dKQUlCRWdHM0lOQUNBRVFid2ZRUUFRQncwQklBWkJBRFlDRUNBRVFack9BQ0FHUVJCcUVBY05BVUVBSVFjZ0JDQUJJQUpxSUEwZ0NDQU1RUUFRR0JvZ0JpQUdRWWdCYWpZQ0FDQUVRYjhmSUFZUUJ3MEJRWUQzQWlBQUtBSU1iU0VGSUJWQmtBTklEUUFnQUNnQ0NDSUJRUUZJRFFBZ0NDQUJJQkJzUVFKMGFpRU5JQU1nQVNBSklCQnJiRUVDZEdvaEVnTkFRUUFoQkFOQUlCSWdBU0FFYkNBSGFrRUNkQ0lVYWlJWUlBc2dCQ0FGYkVFQ2RHb3FBZ0FpSENBY2xDSWNJQTBnRkdvcUFnQ1VRd0FBZ0Q4Z0hKTWdHQ29DQUpTU09BSUFJQVJCQVdvaUJDQVFSdzBBQ3lBSFFRRnFJZ2NnQVVjTkFBc0xBa0FnRGtVTkFBSkFJQUFvQWdnaUJVRUJTQTBBSUJWQmtBTklEUUFnQlVFQklBVkJBVW9iSVFjZ0VFRUJJQkJCQVVvYklRNUJBQ0VCQTBCQkFDRUVBMEFnQXlBRUlBVnNJQUZxUVFKMElnMXFJQWdnRFdvcUFnQTRBZ0FnQkVFQmFpSUVJQTVIRFFBTElBRkJBV29pQVNBSFJ3MEFDd3RCZ1BjQ0lBQW9BZ3h0SVFjZ0ZVR1FBMGdOQUNBRlFRRklEUUFnQXlBRklCQnNRUUowSWdGcUlRNGdBU0FJYWlFSVFRQWhBUU5BUVFBaEJBTkFJQTRnQkNBRmJDQUJha0VDZENJTmFpSVNJQXNnQkNBSGJFRUNkR29xQWdBaUhDQWNsQ0ljSUJJcUFnQ1VRd0FBZ0Q4Z0hKTWdDQ0FOYWlvQ0FKU1NPQUlBSUFSQkFXb2lCQ0FRUncwQUN5QUJRUUZxSWdFZ0JVY05BQXNMQWtBZ0YwVU5BQ0FBS0FJSUlRVWdDU0FNVGdSQUlBVWdFR3dpQVVFQlRnUkFRUUFoQkFOQUlBTWdCRUVDZENJSWFpQUlJQXBxS2dJQU9BSUFJQVJCQVdvaUJDQUJSdzBBQ3d0QmdQY0NJQUFvQWd4dElRZ2dGVUdRQTBnTkFTQUZRUUZJRFFFZ0F5QUJRUUowSWdGcUlRY2dBU0FLYWlFQlFRQWhDZ05BUVFBaEJBTkFJQWNnQkNBRmJDQUtha0VDZENJTWFpSU9JQXNnQkNBSWJFRUNkR29xQWdBaUhDQWNsQ0ljSUE0cUFnQ1VRd0FBZ0Q4Z0hKTWdBU0FNYWlvQ0FKU1NPQUlBSUFSQkFXb2lCQ0FRUncwQUN5QUtRUUZxSWdvZ0JVY05BQXNNQVF0QmdQY0NJQUFvQWd4dElRZ2dGVUdRQTBnTkFDQUZRUUZJRFFCQkFDRUJBMEJCQUNFRUEwQWdBeUFFSUFWc0lBRnFRUUowSWdkcUlnd2dDeUFFSUFoc1FRSjBhaW9DQUNJY0lCeVVJaHdnRENvQ0FKUkRBQUNBUHlBY2t5QUhJQXBxS2dJQWxKSTRBZ0FnQkVFQmFpSUVJQkJIRFFBTElBRkJBV29pQVNBRlJ3MEFDd3NDUUNBQUtBSW9JZ0ZGRFFBZ0FDZ0NDQ0VFSUFHeVF5MFZLanFVdTBUdk9mcitRaTdtUDZJUUh5RWRJQVFnQ1d3aUFVRUJTQTBBSUIyMklSeEJBQ0VFQTBBZ0F5QUVRUUowYWlJRklBVXFBZ0FnSEpRNEFnQWdCRUVCYWlJRUlBRkhEUUFMQ3lBR0tBS0lBU0VCSUFZb0Fxd0JJUU1nQUNBVE5nSThJQUFnRVVFQmN5QVdRUUJIY1RZQ1JDQUFRUUFnQVNBRGN5QUNRUUpJR3pZQ1ZDQVBJQWtnRDBFQVNCc2hCUXNMSUFaQndBRnFKQUFnQlF1b0FRQUNRQ0FCUVlBSVRnUkFJQUJFQUFBQUFBQUE0SCtpSVFBZ0FVSC9EMGdFUUNBQlFmOEhheUVCREFJTElBQkVBQUFBQUFBQTRIK2lJUUFnQVVIOUZ5QUJRZjBYU0J0Qi9nOXJJUUVNQVFzZ0FVR0JlRW9OQUNBQVJBQUFBQUFBQUJBQW9pRUFJQUZCZzNCS0JFQWdBVUgrQjJvaEFRd0JDeUFBUkFBQUFBQUFBQkFBb2lFQUlBRkJobWdnQVVHR2FFb2JRZndQYWlFQkN5QUFJQUZCL3dkcXJVSTBocitpQzlBdUFReC9Jd0JCRUdzaURDUUFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUlBQkI5QUZOQkVCQm9Qc0JLQUlBSWdWQkVDQUFRUXRxUVhoeElBQkJDMGtiSWdoQkEzWWlBbllpQVVFRGNRUkFJQUZCZjNOQkFYRWdBbW9pQTBFRGRDSUJRZEQ3QVdvb0FnQWlCRUVJYWlFQUFrQWdCQ2dDQ0NJQ0lBRkJ5UHNCYWlJQlJnUkFRYUQ3QVNBRlFYNGdBM2R4TmdJQURBRUxRYkQ3QVNnQ0FCb2dBaUFCTmdJTUlBRWdBallDQ0FzZ0JDQURRUU4wSWdGQkEzSTJBZ1FnQVNBRWFpSUJJQUVvQWdSQkFYSTJBZ1FNRFFzZ0NFR28rd0VvQWdBaUNrME5BU0FCQkVBQ1FFRUNJQUowSWdCQkFDQUFhM0lnQVNBQ2RIRWlBRUVBSUFCcmNVRUJheUlBSUFCQkRIWkJFSEVpQW5ZaUFVRUZka0VJY1NJQUlBSnlJQUVnQUhZaUFVRUNka0VFY1NJQWNpQUJJQUIySWdGQkFYWkJBbkVpQUhJZ0FTQUFkaUlCUVFGMlFRRnhJZ0J5SUFFZ0FIWnFJZ05CQTNRaUFFSFErd0ZxS0FJQUlnUW9BZ2dpQVNBQVFjajdBV29pQUVZRVFFR2crd0VnQlVGK0lBTjNjU0lGTmdJQURBRUxRYkQ3QVNnQ0FCb2dBU0FBTmdJTUlBQWdBVFlDQ0FzZ0JFRUlhaUVBSUFRZ0NFRURjallDQkNBRUlBaHFJZ0lnQTBFRGRDSUJJQWhySWdOQkFYSTJBZ1FnQVNBRWFpQUROZ0lBSUFvRVFDQUtRUU4ySWdGQkEzUkJ5UHNCYWlFSFFiVDdBU2dDQUNFRUFuOGdCVUVCSUFGMElnRnhSUVJBUWFEN0FTQUJJQVZ5TmdJQUlBY01BUXNnQnlnQ0NBc2hBU0FISUFRMkFnZ2dBU0FFTmdJTUlBUWdCellDRENBRUlBRTJBZ2dMUWJUN0FTQUNOZ0lBUWFqN0FTQUROZ0lBREEwTFFhVDdBU2dDQUNJR1JRMEJJQVpCQUNBR2EzRkJBV3NpQUNBQVFReDJRUkJ4SWdKMklnRkJCWFpCQ0hFaUFDQUNjaUFCSUFCMklnRkJBblpCQkhFaUFISWdBU0FBZGlJQlFRRjJRUUp4SWdCeUlBRWdBSFlpQVVFQmRrRUJjU0lBY2lBQklBQjJha0VDZEVIUS9RRnFLQUlBSWdFb0FnUkJlSEVnQ0dzaEJDQUJJUUlEUUFKQUlBSW9BaEFpQUVVRVFDQUNLQUlVSWdCRkRRRUxJQUFvQWdSQmVIRWdDR3NpQWlBRUlBSWdCRWtpQWhzaEJDQUFJQUVnQWhzaEFTQUFJUUlNQVFzTElBRWdDR29pQ1NBQlRRMENJQUVvQWhnaEN5QUJJQUVvQWd3aUEwY0VRQ0FCS0FJSUlnQkJzUHNCS0FJQVR3UkFJQUFvQWd3YUN5QUFJQU0yQWd3Z0F5QUFOZ0lJREF3TElBRkJGR29pQWlnQ0FDSUFSUVJBSUFFb0FoQWlBRVVOQkNBQlFSQnFJUUlMQTBBZ0FpRUhJQUFpQTBFVWFpSUNLQUlBSWdBTkFDQURRUkJxSVFJZ0F5Z0NFQ0lBRFFBTElBZEJBRFlDQUF3TEMwRi9JUWdnQUVHL2Ywc05BQ0FBUVF0cUlnQkJlSEVoQ0VHayt3RW9BZ0FpQ1VVTkFFRWZJUVZCQUNBSWF5RUVBa0FDUUFKQUFuOGdDRUgvLy84SFRRUkFJQUJCQ0hZaUFDQUFRWUQrUDJwQkVIWkJDSEVpQW5RaUFDQUFRWURnSDJwQkVIWkJCSEVpQVhRaUFDQUFRWUNBRDJwQkVIWkJBbkVpQUhSQkQzWWdBU0FDY2lBQWNtc2lBRUVCZENBSUlBQkJGV3AyUVFGeGNrRWNhaUVGQ3lBRlFRSjBRZEQ5QVdvb0FnQWlBa1VMQkVCQkFDRUFEQUVMUVFBaEFDQUlRUUJCR1NBRlFRRjJheUFGUVI5R0czUWhBUU5BQWtBZ0FpZ0NCRUY0Y1NBSWF5SUhJQVJQRFFBZ0FpRURJQWNpQkEwQVFRQWhCQ0FDSVFBTUF3c2dBQ0FDS0FJVUlnY2dCeUFDSUFGQkhYWkJCSEZxS0FJUUlnSkdHeUFBSUFjYklRQWdBVUVCZENFQklBSU5BQXNMSUFBZ0EzSkZCRUJCQWlBRmRDSUFRUUFnQUd0eUlBbHhJZ0JGRFFNZ0FFRUFJQUJyY1VFQmF5SUFJQUJCREhaQkVIRWlBbllpQVVFRmRrRUljU0lBSUFKeUlBRWdBSFlpQVVFQ2RrRUVjU0lBY2lBQklBQjJJZ0ZCQVhaQkFuRWlBSElnQVNBQWRpSUJRUUYyUVFGeElnQnlJQUVnQUhacVFRSjBRZEQ5QVdvb0FnQWhBQXNnQUVVTkFRc0RRQ0FBS0FJRVFYaHhJQWhySWdFZ0JFa2hBaUFCSUFRZ0Foc2hCQ0FBSUFNZ0Foc2hBeUFBS0FJUUlnRUVmeUFCQlNBQUtBSVVDeUlBRFFBTEN5QURSUTBBSUFSQnFQc0JLQUlBSUFoclR3MEFJQU1nQ0dvaUJpQURUUTBCSUFNb0FoZ2hCU0FESUFNb0Fnd2lBVWNFUUNBREtBSUlJZ0JCc1BzQktBSUFUd1JBSUFBb0Fnd2FDeUFBSUFFMkFnd2dBU0FBTmdJSURBb0xJQU5CRkdvaUFpZ0NBQ0lBUlFSQUlBTW9BaEFpQUVVTkJDQURRUkJxSVFJTEEwQWdBaUVISUFBaUFVRVVhaUlDS0FJQUlnQU5BQ0FCUVJCcUlRSWdBU2dDRUNJQURRQUxJQWRCQURZQ0FBd0pDeUFJUWFqN0FTZ0NBQ0lDVFFSQVFiVDdBU2dDQUNFREFrQWdBaUFJYXlJQlFSQlBCRUJCcVBzQklBRTJBZ0JCdFBzQklBTWdDR29pQURZQ0FDQUFJQUZCQVhJMkFnUWdBaUFEYWlBQk5nSUFJQU1nQ0VFRGNqWUNCQXdCQzBHMCt3RkJBRFlDQUVHbyt3RkJBRFlDQUNBRElBSkJBM0kyQWdRZ0FpQURhaUlBSUFBb0FnUkJBWEkyQWdRTElBTkJDR29oQUF3TEN5QUlRYXo3QVNnQ0FDSUdTUVJBUWF6N0FTQUdJQWhySWdFMkFnQkJ1UHNCUWJqN0FTZ0NBQ0lDSUFocUlnQTJBZ0FnQUNBQlFRRnlOZ0lFSUFJZ0NFRURjallDQkNBQ1FRaHFJUUFNQ3d0QkFDRUFJQWhCTDJvaUNRSi9RZmorQVNnQ0FBUkFRWUQvQVNnQ0FBd0JDMEdFL3dGQ2Z6Y0NBRUg4L2dGQ2dLQ0FnSUNBQkRjQ0FFSDQvZ0VnREVFTWFrRndjVUhZcXRXcUJYTTJBZ0JCalA4QlFRQTJBZ0JCM1A0QlFRQTJBZ0JCZ0NBTElnRnFJZ1ZCQUNBQmF5SUhjU0lDSUFoTkRRcEIyUDRCS0FJQUlnUUVRRUhRL2dFb0FnQWlBeUFDYWlJQklBTk5EUXNnQVNBRVN3MExDMEhjL2dFdEFBQkJCSEVOQlFKQUFrQkJ1UHNCS0FJQUlnTUVRRUhnL2dFaEFBTkFJQU1nQUNnQ0FDSUJUd1JBSUFFZ0FDZ0NCR29nQTBzTkF3c2dBQ2dDQ0NJQURRQUxDMEVBRUE4aUFVRi9SZzBHSUFJaEJVSDgvZ0VvQWdBaUEwRUJheUlBSUFGeEJFQWdBaUFCYXlBQUlBRnFRUUFnQTJ0eGFpRUZDeUFGSUFoTkRRWWdCVUgrLy8vL0Iwc05Ca0hZL2dFb0FnQWlCQVJBUWREK0FTZ0NBQ0lESUFWcUlnQWdBMDBOQnlBQUlBUkxEUWNMSUFVUUR5SUFJQUZIRFFFTUNBc2dCU0FHYXlBSGNTSUZRZjcvLy84SFN3MEZJQVVRRHlJQklBQW9BZ0FnQUNnQ0JHcEdEUVFnQVNFQUN3SkFJQWhCTUdvZ0JVME5BQ0FBUVg5R0RRQkJnUDhCS0FJQUlnRWdDU0FGYTJwQkFDQUJhM0VpQVVIKy8vLy9CMHNFUUNBQUlRRU1DQXNnQVJBUFFYOUhCRUFnQVNBRmFpRUZJQUFoQVF3SUMwRUFJQVZyRUE4YURBVUxJQUFpQVVGL1J3MEdEQVFMQUF0QkFDRUREQWNMUVFBaEFRd0ZDeUFCUVg5SERRSUxRZHorQVVIYy9nRW9BZ0JCQkhJMkFnQUxJQUpCL3YvLy93ZExEUUVnQWhBUElnRkJBQkFQSWdCUERRRWdBVUYvUmcwQklBQkJmMFlOQVNBQUlBRnJJZ1VnQ0VFb2FrME5BUXRCMFA0QlFkRCtBU2dDQUNBRmFpSUFOZ0lBUWRUK0FTZ0NBQ0FBU1FSQVFkVCtBU0FBTmdJQUN3SkFBa0FDUUVHNCt3RW9BZ0FpQndSQVFlRCtBU0VBQTBBZ0FTQUFLQUlBSWdNZ0FDZ0NCQ0lDYWtZTkFpQUFLQUlJSWdBTkFBc01BZ3RCc1BzQktBSUFJZ0JCQUNBQUlBRk5HMFVFUUVHdyt3RWdBVFlDQUF0QkFDRUFRZVQrQVNBRk5nSUFRZUQrQVNBQk5nSUFRY0Q3QVVGL05nSUFRY1Q3QVVINC9nRW9BZ0EyQWdCQjdQNEJRUUEyQWdBRFFDQUFRUU4wSWdOQjBQc0JhaUFEUWNqN0FXb2lBallDQUNBRFFkVDdBV29nQWpZQ0FDQUFRUUZxSWdCQklFY05BQXRCclBzQklBVkJLR3NpQTBGNElBRnJRUWR4UVFBZ0FVRUlha0VIY1JzaUFHc2lBallDQUVHNCt3RWdBQ0FCYWlJQU5nSUFJQUFnQWtFQmNqWUNCQ0FCSUFOcVFTZzJBZ1JCdlBzQlFZai9BU2dDQURZQ0FBd0NDeUFBTFFBTVFRaHhEUUFnQVNBSFRRMEFJQU1nQjBzTkFDQUFJQUlnQldvMkFnUkJ1UHNCSUFkQmVDQUhhMEVIY1VFQUlBZEJDR3BCQjNFYklnQnFJZ0kyQWdCQnJQc0JRYXo3QVNnQ0FDQUZhaUlCSUFCcklnQTJBZ0FnQWlBQVFRRnlOZ0lFSUFFZ0IycEJLRFlDQkVHOCt3RkJpUDhCS0FJQU5nSUFEQUVMUWJEN0FTZ0NBQ0lESUFGTEJFQkJzUHNCSUFFMkFnQWdBU0VEQ3lBQklBVnFJUUpCNFA0QklRQUNRQUpBQWtBQ1FBSkFBa0FEUUNBQ0lBQW9BZ0JIQkVBZ0FDZ0NDQ0lBRFFFTUFnc0xJQUF0QUF4QkNIRkZEUUVMUWVEK0FTRUFBMEFnQnlBQUtBSUFJZ0pQQkVBZ0FpQUFLQUlFYWlJRUlBZExEUU1MSUFBb0FnZ2hBQXdBQ3dBTElBQWdBVFlDQUNBQUlBQW9BZ1FnQldvMkFnUWdBVUY0SUFGclFRZHhRUUFnQVVFSWFrRUhjUnRxSWdrZ0NFRURjallDQkNBQ1FYZ2dBbXRCQjNGQkFDQUNRUWhxUVFkeEcyb2lCU0FKYXlBSWF5RUNJQWdnQ1dvaEJpQUZJQWRHQkVCQnVQc0JJQVkyQWdCQnJQc0JRYXo3QVNnQ0FDQUNhaUlBTmdJQUlBWWdBRUVCY2pZQ0JBd0RDeUFGUWJUN0FTZ0NBRVlFUUVHMCt3RWdCallDQUVHbyt3RkJxUHNCS0FJQUlBSnFJZ0EyQWdBZ0JpQUFRUUZ5TmdJRUlBQWdCbW9nQURZQ0FBd0RDeUFGS0FJRUlnQkJBM0ZCQVVZRVFDQUFRWGh4SVFjQ1FDQUFRZjhCVFFSQUlBVW9BZ2dpQXlBQVFRTjJJZ0JCQTNSQnlQc0Jha2NhSUFNZ0JTZ0NEQ0lCUmdSQVFhRDdBVUdnK3dFb0FnQkJmaUFBZDNFMkFnQU1BZ3NnQXlBQk5nSU1JQUVnQXpZQ0NBd0JDeUFGS0FJWUlRZ0NRQ0FGSUFVb0Fnd2lBVWNFUUNBRktBSUlJZ0FnQTA4RVFDQUFLQUlNR2dzZ0FDQUJOZ0lNSUFFZ0FEWUNDQXdCQ3dKQUlBVkJGR29pQUNnQ0FDSUVEUUFnQlVFUWFpSUFLQUlBSWdRTkFFRUFJUUVNQVFzRFFDQUFJUU1nQkNJQlFSUnFJZ0FvQWdBaUJBMEFJQUZCRUdvaEFDQUJLQUlRSWdRTkFBc2dBMEVBTmdJQUN5QUlSUTBBQWtBZ0JTQUZLQUljSWdOQkFuUkIwUDBCYWlJQUtBSUFSZ1JBSUFBZ0FUWUNBQ0FCRFFGQnBQc0JRYVQ3QVNnQ0FFRitJQU4zY1RZQ0FBd0NDeUFJUVJCQkZDQUlLQUlRSUFWR0cyb2dBVFlDQUNBQlJRMEJDeUFCSUFnMkFoZ2dCU2dDRUNJQUJFQWdBU0FBTmdJUUlBQWdBVFlDR0FzZ0JTZ0NGQ0lBUlEwQUlBRWdBRFlDRkNBQUlBRTJBaGdMSUFVZ0Iyb2hCU0FDSUFkcUlRSUxJQVVnQlNnQ0JFRitjVFlDQkNBR0lBSkJBWEkyQWdRZ0FpQUdhaUFDTmdJQUlBSkIvd0ZOQkVBZ0FrRURkaUlBUVFOMFFjajdBV29oQWdKL1FhRDdBU2dDQUNJQlFRRWdBSFFpQUhGRkJFQkJvUHNCSUFBZ0FYSTJBZ0FnQWd3QkN5QUNLQUlJQ3lFQUlBSWdCallDQ0NBQUlBWTJBZ3dnQmlBQ05nSU1JQVlnQURZQ0NBd0RDMEVmSVFBZ0FrSC8vLzhIVFFSQUlBSkJDSFlpQUNBQVFZRCtQMnBCRUhaQkNIRWlBM1FpQUNBQVFZRGdIMnBCRUhaQkJIRWlBWFFpQUNBQVFZQ0FEMnBCRUhaQkFuRWlBSFJCRDNZZ0FTQURjaUFBY21zaUFFRUJkQ0FDSUFCQkZXcDJRUUZ4Y2tFY2FpRUFDeUFHSUFBMkFod2dCa0lBTndJUUlBQkJBblJCMFAwQmFpRUVBa0JCcFBzQktBSUFJZ05CQVNBQWRDSUJjVVVFUUVHayt3RWdBU0FEY2pZQ0FDQUVJQVkyQWdBZ0JpQUVOZ0lZREFFTElBSkJBRUVaSUFCQkFYWnJJQUJCSDBZYmRDRUFJQVFvQWdBaEFRTkFJQUVpQXlnQ0JFRjRjU0FDUmcwRElBQkJIWFloQVNBQVFRRjBJUUFnQXlBQlFRUnhhaUlFS0FJUUlnRU5BQXNnQkNBR05nSVFJQVlnQXpZQ0dBc2dCaUFHTmdJTUlBWWdCallDQ0F3Q0MwR3Mrd0VnQlVFb2F5SURRWGdnQVd0QkIzRkJBQ0FCUVFocVFRZHhHeUlBYXlJQ05nSUFRYmo3QVNBQUlBRnFJZ0EyQWdBZ0FDQUNRUUZ5TmdJRUlBRWdBMnBCS0RZQ0JFRzgrd0ZCaVA4QktBSUFOZ0lBSUFjZ0JFRW5JQVJyUVFkeFFRQWdCRUVuYTBFSGNSdHFRUzlySWdBZ0FDQUhRUkJxU1JzaUFrRWJOZ0lFSUFKQjZQNEJLUUlBTndJUUlBSkI0UDRCS1FJQU53SUlRZWorQVNBQ1FRaHFOZ0lBUWVUK0FTQUZOZ0lBUWVEK0FTQUJOZ0lBUWV6K0FVRUFOZ0lBSUFKQkdHb2hBQU5BSUFCQkJ6WUNCQ0FBUVFocUlRRWdBRUVFYWlFQUlBRWdCRWtOQUFzZ0FpQUhSZzBESUFJZ0FpZ0NCRUYrY1RZQ0JDQUhJQUlnQjJzaUJFRUJjallDQkNBQ0lBUTJBZ0FnQkVIL0FVMEVRQ0FFUVFOMklnQkJBM1JCeVBzQmFpRUNBbjlCb1BzQktBSUFJZ0ZCQVNBQWRDSUFjVVVFUUVHZyt3RWdBQ0FCY2pZQ0FDQUNEQUVMSUFJb0FnZ0xJUUFnQWlBSE5nSUlJQUFnQnpZQ0RDQUhJQUkyQWd3Z0J5QUFOZ0lJREFRTFFSOGhBQ0FIUWdBM0FoQWdCRUgvLy84SFRRUkFJQVJCQ0hZaUFDQUFRWUQrUDJwQkVIWkJDSEVpQW5RaUFDQUFRWURnSDJwQkVIWkJCSEVpQVhRaUFDQUFRWUNBRDJwQkVIWkJBbkVpQUhSQkQzWWdBU0FDY2lBQWNtc2lBRUVCZENBRUlBQkJGV3AyUVFGeGNrRWNhaUVBQ3lBSElBQTJBaHdnQUVFQ2RFSFEvUUZxSVFNQ1FFR2srd0VvQWdBaUFrRUJJQUIwSWdGeFJRUkFRYVQ3QVNBQklBSnlOZ0lBSUFNZ0J6WUNBQ0FISUFNMkFoZ01BUXNnQkVFQVFSa2dBRUVCZG1zZ0FFRWZSaHQwSVFBZ0F5Z0NBQ0VCQTBBZ0FTSUNLQUlFUVhoeElBUkdEUVFnQUVFZGRpRUJJQUJCQVhRaEFDQUNJQUZCQkhGcUlnTW9BaEFpQVEwQUN5QURJQWMyQWhBZ0J5QUNOZ0lZQ3lBSElBYzJBZ3dnQnlBSE5nSUlEQU1MSUFNb0FnZ2lBQ0FHTmdJTUlBTWdCallDQ0NBR1FRQTJBaGdnQmlBRE5nSU1JQVlnQURZQ0NBc2dDVUVJYWlFQURBVUxJQUlvQWdnaUFDQUhOZ0lNSUFJZ0J6WUNDQ0FIUVFBMkFoZ2dCeUFDTmdJTUlBY2dBRFlDQ0F0QnJQc0JLQUlBSWdBZ0NFME5BRUdzK3dFZ0FDQUlheUlCTmdJQVFiajdBVUc0K3dFb0FnQWlBaUFJYWlJQU5nSUFJQUFnQVVFQmNqWUNCQ0FDSUFoQkEzSTJBZ1FnQWtFSWFpRUFEQU1MUVp6N0FVRXdOZ0lBUVFBaEFBd0NDd0pBSUFWRkRRQUNRQ0FES0FJY0lnSkJBblJCMFAwQmFpSUFLQUlBSUFOR0JFQWdBQ0FCTmdJQUlBRU5BVUdrK3dFZ0NVRitJQUozY1NJSk5nSUFEQUlMSUFWQkVFRVVJQVVvQWhBZ0EwWWJhaUFCTmdJQUlBRkZEUUVMSUFFZ0JUWUNHQ0FES0FJUUlnQUVRQ0FCSUFBMkFoQWdBQ0FCTmdJWUN5QURLQUlVSWdCRkRRQWdBU0FBTmdJVUlBQWdBVFlDR0FzQ1FDQUVRUTlOQkVBZ0F5QUVJQWhxSWdCQkEzSTJBZ1FnQUNBRGFpSUFJQUFvQWdSQkFYSTJBZ1FNQVFzZ0F5QUlRUU55TmdJRUlBWWdCRUVCY2pZQ0JDQUVJQVpxSUFRMkFnQWdCRUgvQVUwRVFDQUVRUU4ySWdCQkEzUkJ5UHNCYWlFQ0FuOUJvUHNCS0FJQUlnRkJBU0FBZENJQWNVVUVRRUdnK3dFZ0FDQUJjallDQUNBQ0RBRUxJQUlvQWdnTElRQWdBaUFHTmdJSUlBQWdCallDRENBR0lBSTJBZ3dnQmlBQU5nSUlEQUVMUVI4aEFDQUVRZi8vL3dkTkJFQWdCRUVJZGlJQUlBQkJnUDQvYWtFUWRrRUljU0lDZENJQUlBQkJnT0FmYWtFUWRrRUVjU0lCZENJQUlBQkJnSUFQYWtFUWRrRUNjU0lBZEVFUGRpQUJJQUp5SUFCeWF5SUFRUUYwSUFRZ0FFRVZhblpCQVhGeVFSeHFJUUFMSUFZZ0FEWUNIQ0FHUWdBM0FoQWdBRUVDZEVIUS9RRnFJUUlDUUFKQUlBbEJBU0FBZENJQmNVVUVRRUdrK3dFZ0FTQUpjallDQUNBQ0lBWTJBZ0FnQmlBQ05nSVlEQUVMSUFSQkFFRVpJQUJCQVhacklBQkJIMFliZENFQUlBSW9BZ0FoQ0FOQUlBZ2lBU2dDQkVGNGNTQUVSZzBDSUFCQkhYWWhBaUFBUVFGMElRQWdBU0FDUVFSeGFpSUNLQUlRSWdnTkFBc2dBaUFHTmdJUUlBWWdBVFlDR0FzZ0JpQUdOZ0lNSUFZZ0JqWUNDQXdCQ3lBQktBSUlJZ0FnQmpZQ0RDQUJJQVkyQWdnZ0JrRUFOZ0lZSUFZZ0FUWUNEQ0FHSUFBMkFnZ0xJQU5CQ0dvaEFBd0JDd0pBSUF0RkRRQUNRQ0FCS0FJY0lnSkJBblJCMFAwQmFpSUFLQUlBSUFGR0JFQWdBQ0FETmdJQUlBTU5BVUdrK3dFZ0JrRitJQUozY1RZQ0FBd0NDeUFMUVJCQkZDQUxLQUlRSUFGR0cyb2dBellDQUNBRFJRMEJDeUFESUFzMkFoZ2dBU2dDRUNJQUJFQWdBeUFBTmdJUUlBQWdBellDR0FzZ0FTZ0NGQ0lBUlEwQUlBTWdBRFlDRkNBQUlBTTJBaGdMQWtBZ0JFRVBUUVJBSUFFZ0JDQUlhaUlBUVFOeU5nSUVJQUFnQVdvaUFDQUFLQUlFUVFGeU5nSUVEQUVMSUFFZ0NFRURjallDQkNBSklBUkJBWEkyQWdRZ0JDQUphaUFFTmdJQUlBb0VRQ0FLUVFOMklnQkJBM1JCeVBzQmFpRURRYlQ3QVNnQ0FDRUNBbjlCQVNBQWRDSUFJQVZ4UlFSQVFhRDdBU0FBSUFWeU5nSUFJQU1NQVFzZ0F5Z0NDQXNoQUNBRElBSTJBZ2dnQUNBQ05nSU1JQUlnQXpZQ0RDQUNJQUEyQWdnTFFiVDdBU0FKTmdJQVFhajdBU0FFTmdJQUN5QUJRUWhxSVFBTElBeEJFR29rQUNBQUMvWUZBUXQvQWtBZ0FVRUJheUlLUVlBQ1R3UkFJQUFnQUNnQ0hDSURJQXBCR0NBS1oyc2lCbllpQWtFQmFpSUViaUlCTmdJa0lBQWdBQ2dDSUNJRklBSkJBQ0FGSUFGdUlnVkJBV29pQ0NBRWF5SUVJQVFnQ0VzYklBSWdCV3RxSWd0cklBRnNJZ0pySWdjMkFpQWdBQ0FCSUFNZ0Ftc2dDeHNpQWpZQ0hDQUNRWUNBZ0FSTkJFQWdBQ2dDR0NFRElBQW9BaWdoQkNBQUtBSVVJUVVnQUNnQ0JDRU1BMEFnQUNBQ1FRaDBJZ2cyQWh3Z0FDQUZRUWhxSWdVMkFoUkJBQ0VCSUFNZ0RFa0VRQ0FBSUFOQkFXb2lDVFlDR0NBQUtBSUFJQU5xTFFBQUlRRWdDU0VEQ3lBQUlBRTJBaWdnQUNBQklBUkJDSFJ5UVFGMlFmOEJjU0FIUVFoMFFZRCsvLzhIY1hKQi93RnpJZ2MyQWlBZ0FrR0JnQUpKSVFrZ0FTRUVJQWdoQWlBSkRRQUxDeUFMSUFaMElRZ2dBQ2dDRENFSEFrQWdCaUFBS0FJUUlnRk5CRUFnQVNFRkRBRUxJQUFvQWdnaEFpQUFLQUlFSVFRRFFFRUFJUU1nQWlBRVNRUi9JQUFnQWtFQmFpSUNOZ0lJSUFBb0FnQWdCQ0FDYTJvdEFBQUZRUUFMSUFGMElBZHlJUWNnQVVFUlNDRURJQUZCQ0dvaUJTRUJJQU1OQUFzTElBQWdCU0FHYXpZQ0VDQUFJQWNnQm5ZMkFnd2dBQ0FBS0FJVUlBWnFOZ0lVSUFkQmZ5QUdkRUYvYzNFZ0NISWlCaUFLVFEwQklBQkJBVFlDTENBS0R3c2dBQ0FBS0FJY0lnTWdBVzRpQWpZQ0pDQUFJQUFvQWlBaUJDQUJJQVFnQW00aUJFRi9jeUFCYWtFQUlBUkJBV29pQkNBQmF5SUJJQUVnQkVzYmFpSUdRWDl6YWlBQ2JDSUJheUlITmdJZ0lBQWdBaUFESUFGcklBWWJJZ0kyQWh3Z0FrR0FnSUFFU3cwQUlBQW9BaGdoQXlBQUtBSW9JUVFnQUNnQ0ZDRUZJQUFvQWdRaENnTkFJQUFnQWtFSWRDSUlOZ0ljSUFBZ0JVRUlhaUlGTmdJVVFRQWhBU0FESUFwSkJFQWdBQ0FEUVFGcUlnazJBaGdnQUNnQ0FDQURhaTBBQUNFQklBa2hBd3NnQUNBQk5nSW9JQUFnQVNBRVFRaDBja0VCZGtIL0FYRWdCMEVJZEVHQS92Ly9CM0Z5UWY4QmN5SUhOZ0lnSUFKQmdZQUNTU0VKSUFFaEJDQUlJUUlnQ1EwQUN3c2dCZ3VFQlFJS2Z3WjlJQUFvQWhnaENDQUFLQUlBSVFrZ0JVRUJUZ1JBQTBBZ0NDQUpRUUYxSWdsQkFuUnFJUWdnQjBFQmFpSUhJQVZIRFFBTEN5QUNJQVJCQVhSQmZIRnFJUWNnQUNBRlFRSjBhaWdDQ0NFTEFrQWdDVUVEVEFSQUlBc2dCeEE3REFFTElBbEJBblVpQ2tFQklBcEJBVW9iSVE1QkFDRUZJQUVnQ1VFQmRTSU5RUUZySUFac1FRSjBhaUVBSUFzb0Fpd2hERUVBSUFaQkFYUWlCbXRCQW5RaER3TkFJQWNnREM0QkFFRURkQ0lRUVFSeWFpQUFLZ0lBSWhNZ0NDQUZRUUowYWlvQ0FDSVVsQ0FCS2dJQUloRWdDQ0FGSUFwcVFRSjBhaW9DQUNJU2xKSTRBZ0FnQnlBUWFpQVVJQkdVSUJNZ0VwU1RPQUlBSUF4QkFtb2hEQ0FBSUE5cUlRQWdBU0FHUVFKMGFpRUJJQVZCQVdvaUJTQU9SdzBBQ3lBTElBY1FPeUFKUVFSSURRQWdDa0VCYWtFQmRTSUFRUUVnQUVFQlNoc2hBQ0FISUExQkFuUnFJUUZCQUNFRkEwQWdBVUVFYXlJR0tnSUFJUk1nQVVFSWF5SUJLZ0lBSVJRZ0J5QUhLZ0lFSWhFZ0NDQUZRUUowYWlvQ0FDSVNsQ0FIS2dJQUloVWdDQ0FGSUFwcVFRSjBhaW9DQUNJV2xKSTRBZ0FnQmlBUklCYVVJQlVnRXBTVE9BSUFJQUVnRXlBSUlBb2dCVUYvY3lJR2FrRUNkR29xQWdBaUVaUWdGQ0FJSUFZZ0RXcEJBblJxS2dJQUloS1VramdDQUNBSElCTWdFcFFnRkNBUmxKTTRBZ1FnQjBFSWFpRUhJQVZCQVdvaUJTQUFSdzBBQ3dzZ0JFRUNiU0VBSUFSQkFrNEVRQ0FDSUFSQkFuUWlBV29oQ0NBQklBTnFJUWRCQUNFRkEwQWdBaUFDS2dJQUloTWdCMEVFYXlJSEtnSUFJaFNVSUFoQkJHc2lDQ29DQUNJUklBTXFBZ0FpRXBTVE9BSUFJQWdnRVNBVWxDQVRJQktVa2pnQ0FDQURRUVJxSVFNZ0FrRUVhaUVDSUFWQkFXb2lCU0FBUncwQUN3c0xxUm9DSm44RGZTTUFRZEFBYXlJTUpBQWdBQ2dDQ0NFWUlBeEJBRFlDRENBTVFRQTJBZ2hCZnlFSEFrQWdBQ2dDQUNJS0tBSWtJZ2hCQUVnTkFDQUFJQW9vQWdRaUhFR0FFR29pRmlBWWJFRUNkR29nR0VIZ0FHeHFRZHdBYWlJTklBb29BZ2dpQzBFRGRDSUdhaUlVSUFacUloa2dCbW9oSnlBQUtBSVFJQVJzSVJFZ0FDZ0NHQ0VKSUFBb0FoUWhEeUFBS0FJTUlSQWdDaWdDSUNFYklBb29BaXdoQkFOQUlCRWdCQ0FPZEVjRVFDQUlJQTVLSVFZZ0RrRUJhaUVPSUFZTkFRd0NDd3NnQWtIN0NVc05BQ0FEUlEwQUlCaEJBU0FZUVFGS0d5RWRRUUFoQmtFQUlCRnJRUUowSVFRRFFDQUdRUUowSWdjZ0RFRVlhbW9nQUNBR0lCWnNRUUowYWtIY0FHb2lDRFlDQUNBTVFSQnFJQWRxSUFRZ0NHcEJnRUJyTmdJQUlBWkJBV29pQmlBZFJ3MEFDeUFCUVFBZ0FrRUJTaHRGQkVBZ0FDQVJJQTRRV3lBTVFSQnFJQU1nRVNBWUlBQW9BaEFnQ2tFUWFpQUFRZFFBYWhBNUlCRWdBQ2dDRUcwaEJ3d0JDeUFLS0FJTUlSNUJBQ0VHSUFBZ0FDZ0NORUVBUnpZQ09DQUZSUVJBSUF4QklHb2dBU0FDRUZNZ0RFRWdhaUVGQzBFQklTTUNRQ0FRUVFGSERRQWdDMEVCU0EwQUEwQWdEU0FHUVFKMGFpSUJJQUVxQWdBaUxDQU5JQVlnQzJwQkFuUnFLZ0lBSWkwZ0xDQXRYaHM0QWdBZ0JrRUJhaUlHSUF0SERRQUxDd0ovSUFVb0FoUWlDQ0FGS0FJY1p5SUVha0VnYXlJR0lBSkJBM1FpRlVnRVFFRUFJU05CQVNBR1FRRkhEUUVhSUFWQkR4QUdJZ0ZGQkVCQkFTRUdRUUVNQWdzZ0JTZ0NGQ0VJSUFFaEl5QUZLQUljWnlFRUN5QUZJQlVnQ0dzZ0JHc2dDR3BCSUdvMkFoUWdGU0VHUVFBTElTaERBQUFBQUNFc0FrQWdEdzBBSUFaQkVHb2dGVW9OQUFKOVF3QUFBQUFnQlVFQkVBWkZEUUFhSUFVZ0JVRUdFQllpQVVFRWFoQUpRUkFnQVhScUlRRWdCVUVERUFraEJDQVZJQVVvQWhRZ0JTZ0NIR2RxUVI1clRnUkFJQVZCaHoxQkFoQURJUjhMSUFGQkFXc2hKQ0FFUVFGcXNrTUFBTUE5bEFzaExDQUZLQUlVSUFVb0FoeG5ha0VnYXlFR0N5QUdRUU5xSVFZQ1FDQU9SUTBBSUFZZ0ZVb05BQ0FGUVFNUUJpRVhJQVVvQWhRZ0JTZ0NIR2RxUVIxcklRWUxJQW9nRHlBSklBMGdCaUFWVEFSL0lBVkJBeEFHQlVFQUN5QUZJQkFnRGhDZUFTQU1JQXRCQW5SQkQycEJjSEZySWlBaUV5UUFJQTVCQUVjZ0JTZ0NCRUVEZENJR0lBVW9BaFFnQlNnQ0hHZHFRU0JySWdSQkFrRUVJQmNiSWdGQkFYSnFUM0VoRmtFQUlRY0NRQ0FKSUE5TUloSU5BQ0FHSUJacklob2dBU0FFYWs4RVFDQUZJQUVRQmlFSElBVW9BaFFnQlNnQ0hHZHFRU0JySVFRTElDQWdEMEVDZEdvZ0J6WUNBQ0FQUVFGcUlnWWdDVVlOQUVFRVFRVWdGeHNoQVNBSElRZ0RRQ0FhSUFFZ0JHcFBCRUFnQlNBQkVBWWdDSE1pQ0NBSGNpRUhJQVVvQWhRZ0JTZ0NIR2RxUVNCcklRUUxJQ0FnQmtFQ2RHb2dDRFlDQUNBR1FRRnFJZ1lnQ1VjTkFBc0xRUUFoQmdKQUlCWkZEUUFnRGtFRGRFR3dPMm9pQVNBSElCZEJBblFpQkdwcUxRQUFJQUVnQkVFQ2NpQUhhbW90QUFCR0RRQWdCVUVCRUFaQkFYUWhCZ3NnRWtVRVFDQUdJQmRCQW5ScUlRRWdEa0VEZEVHd08yb2hCQ0FQSVFZRFFDQWdJQVpCQW5ScUlnY2dCQ0FCSUFjb0FnQnFhaXdBQURZQ0FDQUdRUUZxSWdZZ0NVY05BQXNMUVFJaEpTQVZJQVVvQWhRZ0JTZ0NIR2RxUVJ4clRnUkFJQVZCaWoxQkJSQURJU1VMSUJNZ0MwRUNkRUVQYWtGd2NTSUJheUlhSWdRa0FDQUtJQm9nRGlBUUVGNUJCaUVUSUFKQkJuUWhGaUFFSUFGcklpRWlKaVFBSUFVUUN5RUNBa0FnRWdSQUlCWWhCQXdCQ3lBUElRWWdGaUVFQTBBZ0d5QUdJZ0ZCQVdvaUJrRUJkR291QVFBZ0d5QUJRUUYwYWk0QkFHc2dFR3dnRG5RaUIwRURkQ0lJSUFkQk1DQUhRVEJLR3lJSElBY2dDRW9iSVNJZ0dpQUJRUUowSWlscUlTb2dCQ0VCSUJNaENFRUFJUWNEUUFKQUlBY2hFaUFCSWdRZ0NFRURkQ0FDYWt3TkFDQVNJQ29vQWdCT0RRQWdCQ0FpYXlFQklCSWdJbW9oQnlBRklBZ1FCaUVySUFVUUN5RUNRUUVoQ0NBckRRRUxDeUFoSUNscUlCSTJBZ0FnRTBFQmEwRUNJQk5CQWtvYklCTWdFa0VBU2hzaEV5QUdJQWxIRFFBTEN5QW1JQXRCQW5SQkQycEJjSEZySWdjaUFTUUFRUVVoQ0NBRUlBSkJNR3BPQkVBZ0JVR09QVUVIRUFNaENBc2dDMEVCZENFRUlCWWdCUkFMUVg5emFpRUNRUUFoQmlBZUlBa2dDU0FlU2hzaEcwRUJJQTUwSWg1QkFDQVhHeUVpSUFFZ0MwRUNkRUVQYWtGd2NTSUJheUlUSWhJa0FDQVNJQUZySWhJaUppUUFJQW9nRHlBSklDRWdHaUFJSUF4QkRHb2dERUVJYWlBQ0FuOGdEa0VDU1FSQVFRQWhBVUVBREFFTFFRQWhBVUVBSUJkRkRRQWFJQUlnRGtFRGRFRVFhazRpQVVFRGRBc2lHbXNnREVFRWFpQVRJQWNnRWlBUUlBNGdCUkNiQVNFaElBb2dEeUFKSUEwZ0J5QUZJQkFRblFFZ0hFRUNiU0FSYTBFQ2RFR0FRR3NoQWdOQUlBeEJHR29nQmtFQ2RHb29BZ0FpQ0NBSUlCRkJBblJxSUFJUURob2dCa0VCYWlJR0lCMUhEUUFMSUNZZ0N5QVFiQ0lJUVE5cVFYQnhheUlHSWdJa0FDQUNJQkFnRVd4QkFuUkJEMnBCY0hGcklnSWtBQ0FLSUE4Z0NTQUNJQUlnRVVFQ2RHcEJBQ0FRUVFKR0d5QUdJQk1nSWlBbElBd29BZ2dnRENnQ0RDQWdJQllnR21zZ0RDZ0NCQ0FGSUE0Z0lTQUFRU2hxSUFBb0FpUWdBQ2dDSUJCaEFrQWdBUVJBSUFWQkFSQUpJUUVnQ2lBUElBa2dEU0FISUJJZ0ZTQUZLQUlVYXlBRktBSWNaMnRCSUdvZ0JTQVFFRlFnQVVVTkFTQUtJQUlnQmlBT0lCQWdFU0FQSUFrZ0RTQVVJQmtnRXlBQUtBSW9JQUFvQWlRUVl3d0JDeUFLSUE4Z0NTQU5JQWNnRWlBVklBVW9BaFJySUFVb0FoeG5hMEVnYWlBRklCQVFWQXNDZnlBb1JRUkFRUUFoQmlBSVFRQktCRUFEUUNBTklBWkJBblJxUVlDQWdJOThOZ0lBSUFaQkFXb2lCaUFJUncwQUN3c2dDaUFDSUF4QkVHb2dEU0FQSUJzZ0VDQVlJQmNnRGlBQUtBSVFJQ01nQUNnQ0pCQWlJQXhCRUdvTUFRc2dDaUFDSUF4QkVHb2dEU0FQSUJzZ0VDQVlJQmNnRGlBQUtBSVFRUUFnQUNnQ0pCQWlJQXhCRUdvTElRSkJBQ0VHQWtBZ0RrVUVRQU5BSUFBZ0FDZ0NQQ0lCUVE4Z0FVRVBTaHNpQVRZQ1BDQUFJQUFvQWtBaUIwRVBJQWRCRDBvYklnYzJBa0FnREVFUWFpQUdRUUowYWlnQ0FDSUlJQWdnQnlBQklBb29BaXdnQUNvQ1NDQUFLZ0pFSUFBb0FsQWdBQ2dDVENBS0tBSThJQndnQUNnQ0pCQVpJQVpCQVdvaUJpQWRSdzBBREFJTEFBc0RRQ0FBSUFBb0Fqd2lBVUVQSUFGQkQwb2JJZ2MyQWp3Z0FDQUFLQUpBSWdGQkR5QUJRUTlLR3lJSU5nSkFJQXhCRUdvZ0JrRUNkR29vQWdBaUFTQUJJQWdnQnlBS0tBSXNJQUFxQWtnZ0FDb0NSQ0FBS0FKUUlBQW9Ba3dnQ2lnQ1BDQWNJQUFvQWlRUUdTQUJJQW9vQWl3aUIwRUNkR29pQVNBQklBQW9BandnSkNBUklBZHJJQUFxQWtRZ0xDQUFLQUpNSUI4Z0NpZ0NQQ0FjSUFBb0FpUVFHU0FHUVFGcUlnWWdIVWNOQUFzTElBQWdBQ2dDUERZQ1FDQUFLZ0pFSVMwZ0FDQXNPQUpFSUFBZ0xUZ0NTQ0FBS0FKTUlRRWdBQ0FmTmdKTUlBQWdBVFlDVUNBQUlDUTJBandnRGdSQUlBQWdIellDVUNBQUlDdzRBa2dnQUNBa05nSkFDeUFRUVFGR0JFQWdEU0FMUVFKMElnRnFJQTBnQVJBRUdnc0NRQ0FYQkVBZ0MwRUJTQTBCSUFSQkFTQUVRUUZLR3lFQlFRQWhCZ05BSUJRZ0JrRUNkQ0lFYWlJSElBY3FBZ0FpTENBRUlBMXFLZ0lBSWkwZ0xDQXRYUnM0QWdBZ0JrRUJhaUlHSUFGSERRQUxEQUVMSUJrZ0ZDQUxRUU4wSWdFUUJCb2dGQ0FOSUFFUUJCb2dDMEVCU0EwQUlCNnlRMjhTZ3pxVVF3QUFnRDhnQUNnQ05FRUtTQnNoTENBRVFRRWdCRUVCU2hzaEFVRUFJUVlEUUNBbklBWkJBblFpQkdvaUJ5QXNJQWNxQWdDU0lpMGdCQ0FOYWlvQ0FDSXVJQzBnTGwwYk9BSUFJQVpCQVdvaUJpQUJSdzBBQ3d0QkFDRUdBa0FnRDBFQVNnUkFBMEFnRFNBR1FRSjBJZ0ZxUVFBMkFnQWdBU0FaYWtHQWdJQ1BmRFlDQUNBQklCUnFRWUNBZ0k5OE5nSUFJQVpCQVdvaUJpQVBSdzBBQ3lBSklBdElCRUFnQ1NFR0EwQWdEU0FHUVFKMElnRnFRUUEyQWdBZ0FTQVpha0dBZ0lDUGZEWUNBQ0FCSUJScVFZQ0FnSTk4TmdJQUlBWkJBV29pQmlBTFJ3MEFDd3RCQUNFR0EwQWdEU0FHSUF0cVFRSjBJZ0ZxUVFBMkFnQWdBU0FaYWtHQWdJQ1BmRFlDQUNBQklCUnFRWUNBZ0k5OE5nSUFJQVpCQVdvaUJpQVBSdzBBQ3lBSklBdE9EUUVEUUNBTklBa2dDMnBCQW5RaUFXcEJBRFlDQUNBQklCbHFRWUNBZ0k5OE5nSUFJQUVnRkdwQmdJQ0FqM3cyQWdBZ0NVRUJhaUlKSUF0SERRQUxEQUVMSUFrZ0MwNE5BQ0FKSVFZRFFDQU5JQVpCQW5RaUFXcEJBRFlDQUNBQklCbHFRWUNBZ0k5OE5nSUFJQUVnRkdwQmdJQ0FqM3cyQWdBZ0JrRUJhaUlHSUF0SERRQUxBMEFnRFNBSklBdHFRUUowSWdGcVFRQTJBZ0FnQVNBWmFrR0FnSUNQZkRZQ0FDQUJJQlJxUVlDQWdJOThOZ0lBSUFsQkFXb2lDU0FMUncwQUN3c2dBQ0FGS0FJY05nSW9JQUlnQXlBUklCZ2dBQ2dDRUNBS1FSQnFJQUJCMUFCcUVEa2dBRUVBTmdJMFFYMGhCeUFWSUFVb0FoUWdCU2dDSEdkcVFTQnJUZ1JBSUFVb0Fpd0VRQ0FBUVFFMkFpd0xJQkVnQUNnQ0VHMGhCd3NMSUF4QjBBQnFKQUFnQnd2SEJRSUZmd3A5QWtBQ1FDQUZRd0FBQUFCY0RRQWdCa01BQUFBQVhBMEFJQUFnQVVZTkFTQUFJQUVnQkVFQ2RCQU9HZzhMUVFBaEMwRitJQU5CRHlBRFFROUtHeUlNYXlFTklBeEJmM01oRGtFQklBeHJJUTlCQUNBTWF5RVFJQWhCREd3aUEwR0lPMm9xQWdBZ0JwUWhGQ0FEUVlRN2Fpb0NBQ0FHbENFVklBTkJnRHRxS2dJQUlBYVVJUlpCQUNBS0lBY2dDRVliSUFvZ0JTQUdXeHNnQ2lBQ1FROGdBa0VQU2hzaUNDQU1SaHNpQWtFQlRnUkFJQWRCREd3aUEwR0lPMm9xQWdBZ0JaUWhGeUFEUVlRN2Fpb0NBQ0FGbENFWUlBTkJnRHRxS2dJQUlBV1VJUmxCQWlBTWF5RURJQUVnRDBFQ2RHb3FBZ0FoRVNBQklCQkJBblJxS2dJQUlSSWdBU0FPUVFKMGFpb0NBQ0VUSUFFZ0RVRUNkR29xQWdBaEJVRUFJUW9EUUNBQUlBcEJBblFpQjJvZ0JTQUJJQU1nQ21wQkFuUnFLZ0lBSWhxU0lCUWdCeUFKYWlvQ0FDSUZJQVdVSWdXVWxDQVJJQk9TSUJVZ0JaU1VJQklnRmlBRmxKUWdBU0FIYWlvQ0FDQUJJQW9nQ0d0QkFuUnFJZ2NxQWdBZ0dVTUFBSUEvSUFXVElnV1VsSklnR0NBRmxDQUhLZ0lFSUFkQkJHc3FBZ0NTbEpJZ0Z5QUZsQ0FIS2dJSUlBZEJDR3NxQWdDU2xKS1NrcEk0QWdBZ0V5RUZJQkloRXlBUklSSWdHaUVSSUFwQkFXb2lDaUFDUncwQUN5QUNJUXNMSUFaREFBQUFBRnNFUUNBQUlBRkdEUUVnQUNBQ1FRSjBJZ05xSUFFZ0Eyb2dCQ0FDYTBFQ2RCQU9HZzhMSUFRZ0Myc2lCMEVCU0EwQUlBQWdDMEVDZENJRWFpRURRUUlnREdzaEFpQUJJQVJxSWdFZ0RVRUNkR29xQWdBaEV5QUJJQTVCQW5ScUtnSUFJUVVnQVNBUVFRSjBhaW9DQUNFUklBRWdEMEVDZEdvcUFnQWhFa0VBSVFvRFFDQURJQXBCQW5RaUFHb2dGQ0FUSUFFZ0FpQUtha0VDZEdvcUFnQWlCcEtVSUJVZ0JTQVNrcFFnRmlBUmxDQUFJQUZxS2dJQWtwS1NPQUlBSUFVaEV5QVJJUVVnRWlFUklBWWhFaUFLUVFGcUlnb2dCMGNOQUFzTEM2QUNBUVovSUFOQkFXc2hDRUVmSUFObklnZHJJUVVDUUNBRFFRSklCRUFnQXlFRURBRUxJQU1oQkFOQUlBUWdBaUFHUVFGMElnUkJBbkpxTGdFQUlna2dDV3dnQWlBRWFpNEJBQ0lFSUFSc2FpQUZkbW9oQkNBR1FRSnFJZ1lnQ0VnTkFBc2dBMEYrY1NFR0N5QURJQVpLQkVBZ0JDQUNJQVpCQVhScUxnRUFJZ1FnQkd3Z0JYWnFJUVFMUVFBaEJVRWlJQWNnQkdkcWF5SUVRUUFnQkVFQVNoc2hCQ0FEUVFKSUJIOUJBQVZCQUNFR0EwQWdCU0FDSUFaQkFYUWlCVUVDY21vdUFRQWlCeUFIYkNBQ0lBVnFMZ0VBSWdVZ0JXeHFJQVIyYWlFRklBWkJBbW9pQmlBSVNBMEFDeUFEUVg1eEN5SUdJQU5JQkVBZ0FpQUdRUUYwYWk0QkFDSUNJQUpzSUFSMklBVnFJUVVMSUFFZ0JEWUNBQ0FBSUFVMkFnQUwwd0VCQlg4Z0FFR3dNRUVJRUFNaEFpQUFRZjR3UVFnUUF5RURJQUJCaFRGQkNCQURJUVFnQVNBQVFmNHdRUWdRQXlBQ0lBSkJCVzBpQlVGN2JHcEJBMnhxUVFGMFFaQXdhaUlDTGdFQ0lBSXVBUUFpQW1zaUJrSC8vd054UVpvemJFRVFkaUFHUVJCMVFab3piR29nQUVHRk1VRUlFQU5CRVhSQkVIVkJBWEpzSUFKcUlnQTJBZ1FnQVNBRElBVkJBMnhxUVFGMFFaQXdhaUlCTGdFQ0lBRXVBUUFpQVdzaUFrSC8vd054UVpvemJFRVFkaUFDUVJCMVFab3piR29nQkVFUmRFRVFkVUVCY213Z0FXb2dBR3MyQWdBTHhRSUJBMzhqQUVHUUFXc2lCaVFBSUFBb0FwZ1NJUWNnQmtFQU5nS0lBUUpBQWtBQ1FBSkFJQVFPQXdFQ0FBSUxJQUFnQUNnQzFCSkJBblJxUWZRU2FpZ0NBRUVCUncwQkN5QUdJQWRCRDJwQjhQLy8vd2R4UVFGMGF5SUlKQUFnQUNBQklBQW9BdFFTSUFRZ0JSQW9JQUVnQ0NBQVFjMFZhaUlCTEFBQUlBQkJ6aFZxTEFBQUlBQW9BcGdTRUNjZ0FDQUdJQVVRYmlBQUlBWWdBaUFJRUc4Z0FDQUdJQUpCQUJCRklBQkJBRFlDd0NBZ0FFRUFOZ0xJRWlBQUlBRXNBQUEyQXNRZ0RBRUxJQUFnQmlBQ1FRRVFSUXNnQUVIRUNtb2lBU0FCSUFBb0FwZ1NJZ1JCQVhScUlBQW9BcUFTSUFSclFRRjBJZ0VRRGlBQmFpQUNJQUFvQXBnU1FRRjBFQVFhSUFBZ0JpQUNJQWNRZVNBQUlBSWdCeEJ5SUFBZ0FDZ0NsQkpCQW5RZ0JtcEJCR3NvQWdBMkFvUVNJQU1nQnpZQ0FDQUdRWkFCYWlRQVFRQUw5UVlDQ244RWZpTUFRZUFBYXlFR0FuOENRQ0FCUVFCS0JFQURRQ0FHSUFKQkFuUnFJQUFnQWtFQmRHb3VBUUFpQlVFTWREWUNBQ0FFSUFWcUlRUWdBa0VCYWlJQ0lBRkhEUUFMSUFSQi94OUtCRUJCQUE4TElBRkJBV3NoQWtLQWdJQ0FCQ0VNSUFGQkFrZ0VRQ0FDSVFRTUFnc0RRQ0FHSUFJaUFFRUNkR29vQWdBaUJFR2UzLzhIYWtHOHZ2OFBTd1JBUVFBUEMwRUFJQXhCZ0lDQWdBUkJBQ0FFUVFkMGE2d2lEU0FOZmtJZ2lLZHJJZ1dzZmtJZWlLZEJmSEVpQ2tIdXhnWklEUU1hUVFBaEJFRUFRZi8vLy84QklBVWdCU0FGUVI5MUlnSnFJQUp6WnlJRlFRRnJkQ0lEUVJCMUlnaHRJZ2RCRUhRaUNVRVFkU0lDSUFOQi8vOERjV3hCRUhVZ0FpQUliR3BCQTNScklnTWdCMEVQZFVFQmFrRUJkV3dnQ1dvZ0EwRVFkU0FDYkdvZ0EwSDQvd054SUFKc1FSQjFhcXdoRGlBQlFRRjJJZ0ZCQVNBQlFRRkxHeUVKUVI4Z0JXdXRJUThEUUNBR0lBUkJBblJxSWdNb0FnQWlBaUFHSUFBZ0JFRi9jMnBCQW5ScUlnc29BZ0FpQWF3Z0RYNUNIb2hDQVh4Q0FZaW5JZ2hySWdkQmdJQ0FnSGhCLy8vLy93Y2dCMEYvU2lJSEd5QUlJQUlnQnh0QmYzTWdBaUFJSUFjYmNVRi9TaHVzSUE1K0lRd0NmZ0pBQWtBZ0JVRWZSZ1JBSUF4Q0FZTWdERUlCaDN3aURFS0FnSUNBQ0h4Qy8vLy8vdzlZRFFGQkFBOExJQXdnRDRkQ0FYeENBWWNpREVLQWdJQ0FDSHhDLy8vLy93OVlEUUZCQUE4TElBTWdERDRDQUNBQklBS3NJQTErUWg2SVFnRjhRZ0dJcHlJQ2F5SURRWUNBZ0lCNFFmLy8vLzhISUFOQmYwb2lBeHNnQWlBQklBTWJRWDl6SUFFZ0FpQURHM0ZCZjBvYnJDQU9maUlNUWdHRElBeENBWWQ4REFFTElBTWdERDRDQUNBQklBS3NJQTErUWg2SVFnRjhRZ0dJcHlJQ2F5SURRWUNBZ0lCNFFmLy8vLzhISUFOQmYwb2lBeHNnQWlBQklBTWJRWDl6SUFFZ0FpQURHM0ZCZjBvYnJDQU9maUFQaDBJQmZFSUJod3NpREVLQWdJQ0FDSHhDLy8vLy93OVdCRUJCQUE4TElBc2dERDRDQUNBRVFRRnFJZ1FnQ1VjTkFBc2dBRUVCYXlFQ0lBcXNJUXhCQUNFRUlBQWlBVUVCU2cwQUN3d0JDeUFCUVFGcklRUkNnSUNBZ0FRaERBdEJBQ0FHSUFSQkFuUnFLQUlBUVo3Zi93ZHFRYnkrL3c5TERRQWFRUUFnREVLQWdJQ0FnSUNBZ01BQVFRQWdCaWdDQUVFSGRHdXNJZ3dnREg1Q2dJQ0FnUEQvLy8vL0FJTjlRaUNIZmtJZWlLZEJmSEVpQUNBQVFlN0dCa2diQ3dzcEFRRi9Jd0JCRUdzaUFpUUFJQUlnQVRZQ0RFR1E5QUVvQWdBZ0FDQUJFSXNCSUFKQkVHb2tBQXU1QXdNQ2Z3RitBbndnQUwwaUEwSS9pS2NoQVFKQUFrQUNmQUpBSUFBQ2Z3SkFBa0FnQTBJZ2lLZEIvLy8vL3dkeElnSkJxOGFZaEFSUEJFQWdBTDFDLy8vLy8vLy8vLy8vQUlOQ2dJQ0FnSUNBZ1BqL0FGWUVRQ0FBRHdzZ0FFVHZPZnIrUWk2R1FHUkJBWE5GQkVBZ0FFUUFBQUFBQUFEZ2Y2SVBDeUFBUk5LOGV0MHJJNGJBWTBFQmN3MEJJQUJFVVRBdDFSQkpoOEJqUlEwQkRBWUxJQUpCdzl6WS9nTkpEUU1nQWtHeXhjTC9BMGtOQVFzZ0FFVCtnaXRsUnhYM1A2SWdBVUVEZEVIZzNRRnFLd01Bb0NJQW1VUUFBQUFBQUFEZ1FXTUVRQ0FBcWd3Q0MwR0FnSUNBZUF3QkN5QUJRUUZ6SUFGckN5SUJ0eUlFUkFBQTRQNUNMdWEvb3FBaUFDQUVSSFk4ZVRYdk9lbzlvaUlGb1F3QkN5QUNRWUNBd1BFRFRRMENRUUFoQVNBQUN5RUVJQUFnQkNBRUlBUWdCS0lpQUNBQUlBQWdBQ0FBUk5Da3ZuSnBOMlkrb2tUeGE5TEZRYjI3dnFDaVJDemVKYTlxVmhFL29LSkVrNzIrRm16QlpyK2dva1ErVlZWVlZWWEZQNkNpb1NJQW9rUUFBQUFBQUFBQVFDQUFvYU1nQmFHZ1JBQUFBQUFBQVBBL29DRUVJQUZGRFFBZ0JDQUJFQlFoQkFzZ0JBOExJQUJFQUFBQUFBQUE4RCtnQzdBQkFRUi9JQUFvQWd3aEJBSkFJQUFvQWhBaUJVRUJhaUlDUVNGSkJFQWdCU0VEREFFTEEwQWdBQ0FBS0FJRUlnTWdBQ2dDQ0NJQ0lBQW9BaGhxU3dSL0lBQWdBa0VCYWlJQ05nSUlJQUFvQWdBZ0F5QUNhMm9nQkRvQUFFRUFCVUYvQ3lBQUtBSXNjallDTENBRVFRaDJJUVFnQlVFUFNpRUNJQVZCQ0dzaUF5RUZJQUlOQUFzZ0EwRUJhaUVDQ3lBQUlBSTJBaEFnQUNBQklBTjBJQVJ5TmdJTUlBQWdBQ2dDRkVFQmFqWUNGQXVTQXdFQ2Z5QUFLQUljSWdRZ0EyNGhCU0FBQW44Z0FRUkFJQUFnQUNnQ0lDQUZJQUVnQTJ0c0lBUnFhallDSUNBRklBSWdBV3RzREFFTElBVWdBaUFEYTJ3Z0JHb0xJZ00yQWh3Z0EwR0FnSUFFVFFSQUlBQW9BaUFoQVFOQUFrQWdBVUVYZGlJRlFmOEJSd1JBSUFGQkgzWWhBaUFBS0FJb0lnUkJBRTRFUUVGL0lRRWdBQ0FBS0FJRUlBQW9BaGdpQXlBQUtBSUlha3NFZnlBQUlBTkJBV28yQWhnZ0FDZ0NBQ0FEYWlBQ0lBUnFPZ0FBUVFBRlFYOExJQUFvQWl4eU5nSXNDeUFBS0FJa0lnRUVRQ0FDUVFGcklRUURRRUYvSVFNZ0FDQUFLQUlFSUFBb0FoZ2lBaUFBS0FJSWFrc0VmeUFBSUFKQkFXbzJBaGdnQUNnQ0FDQUNhaUFFT2dBQVFRQWhBeUFBS0FJa0JTQUJDMEVCYXlJQk5nSWtJQUFnQUNnQ0xDQURjallDTENBQkRRQUxDeUFBSUFWQi93RnhOZ0lvSUFBb0Fod2hBeUFBS0FJZ0lRRU1BUXNnQUNBQUtBSWtRUUZxTmdJa0N5QUFJQU5CQ0hRaUF6WUNIQ0FBSUFGQkNIUkJnUDcvL3dkeElnRTJBaUFnQUNBQUtBSVVRUWhxTmdJVUlBTkJnWUNBQkVrTkFBc0xDOThGQVFwL0l3QWlEU0VWSUFBb0FnZ2hFeUFBS0FJRUlSQWdEU0FBS0FJc0loUWdDWFFpRDBFQ2RFRVBha0Z3Y1dzaURpUUFJQUFvQWlSQkFDQUpJQWdiYXlFU1FRRWdDWFFpRVVFQklBZ2JJUTBnRkNBUElBZ2JJUWdDUUFKQUlBWkJBVWNOQUNBSFFRSkhEUUFnQUNBQklBNGdBeUFFSUFVZ0VTQUtJQXNRRWlBQ0tBSUVJQkJCQW0xQkFuUnFJQTRnRDBFQ2RCQUVJUUVnRFVFQlNBMEJJQUJCUUdzaEEwRUFJUWtEUUNBRElBRWdDVUVDZEdvZ0FpZ0NBQ0FJSUFsc1FRSjBhaUFBS0FJOElCQWdFaUFORUJjZ0NVRUJhaUlKSUExSERRQUxJQTFCQVVnTkFTQUFRVUJySVFGQkFDRUpBMEFnQVNBT0lBbEJBblJxSUFJb0FnUWdDQ0FKYkVFQ2RHb2dBQ2dDUENBUUlCSWdEUkFYSUFsQkFXb2lDU0FOUncwQUN3d0JDd0pBSUFaQkFrWkJBQ0FIUVFGR0cwVUVRQ0FIUVFFZ0IwRUJTaHNoQjBFQUlRWWdEVUVCU0EwQklBQkJRR3NoRkFOQUlBQWdBU0FHSUE5c1FRSjBhaUFPSUFNZ0JpQVRiRUVDZEdvZ0JDQUZJQkVnQ2lBTEVCSWdBaUFHUVFKMGFpRVdRUUFoQ1FOQUlCUWdEaUFKUVFKMGFpQVdLQUlBSUFnZ0NXeEJBblJxSUFBb0Fqd2dFQ0FTSUEwUUZ5QUpRUUZxSWdrZ0RVY05BQXNnQmtFQmFpSUdJQWRIRFFBTERBSUxJQUlvQWdBaEJpQUFJQUVnRGlBRElBUWdCU0FSSUFvZ0N4QVNJQUFnQVNBUFFRSjBhaUFHSUJCQkFtMUJBblJxSWdFZ0F5QVRRUUowYWlBRUlBVWdFU0FLSUFzUUVrRUFJUWtnRDBFQVNnUkFBMEFnRGlBSlFRSjBJZ05xSWdRZ0JDb0NBRU1BQUFBL2xDQUJJQU5xS2dJQVF3QUFBRCtVa2pnQ0FDQUpRUUZxSWdrZ0QwY05BQXNMSUExQkFVZ05BU0FBUVVCcklRRkJBQ0VKQTBBZ0FTQU9JQWxCQW5ScUlBSW9BZ0FnQ0NBSmJFRUNkR29nQUNnQ1BDQVFJQklnRFJBWElBbEJBV29pQ1NBTlJ3MEFDd3dCQ3dOQUlBQWdBU0FHSUE5c1FRSjBhaUFPSUFNZ0JpQVRiRUVDZEdvZ0JDQUZJQkVnQ2lBTEVCSWdCa0VCYWlJR0lBZEhEUUFMQ3lBVkpBQUxteElDQ244RGZTQUFLQUlRSVJBZ0FDZ0NBQ0VNUVFFaEN5QUZLQUlBSWcwZ0FDZ0NDQ0lUS0FJNElBQW9BZ3dpRDBFQmRHb3VBUUFnQ0VFRGRHb2lDR3RCSUdzaUVTQUlRUUYxUVhCQmZDQUVRUUpHSUFsQkFFZHhJZ2diYWlBRVFRRjBRWDVCZnlBSUcyb2lDR3dnRFdvZ0NHMGlDQ0FJSUJGS0d5SUlRY0FBSUFoQndBQklHeUlJUVFST0JFQWdDRUVIY1VFQmRFSHdPbW91QVFCQkRpQUlRUU4yYTNWQkFXcEJmbkVoQ3dzZ0FDZ0NIQ0VOSUF0QkFTQUxJQWtiSUE4Z0VFZ2JJUXNDZndKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBSUF3RVFDQUFLQUlrSVJBZ0FpQURJQWtnQkNBQUtBSXNFSlVCSVFnZ0RSQUxJUkVnQzBFQlJnMEVBbjhDUUNBSkJFQWdBQ2dDTUNJQURRRWdDQ0FMYkVHQVFHdEJEblVNQWdzQ1FDQUxJQWdnQzJ3aURFR0FRR3NpRGtFT2RTSUlUQVJBSUFnaEFBd0JDeUFNUVlEQUFFZ0VRQ0FJSVFBTUFRc2dBQ2dDT0VVRVFDQUlJUUFNQVFzZ0RrR0FnSDl4SUFzaUFHNUJFSFFpRGtFTmRTQU9RUkIxYkVHQWdBSnFRUkIxSWd3Z0RFR09lMnhCZ0lBQmFrRVBkVUhWd0FCcWJFRUJkRUdBZ0lydkFXdEJFSFVnREd4QmdJQUJha0VQZGlBTWEwRVFkRUdBZ0lDQWVHdEJFSFVpRW1jaUZFR0FnSUNBQkNBT2F5SU1RUTExSUF4QkVIVnNRWUNBQW1wQkVIVWlEQ0FNUVk1N2JFR0FnQUZxUVE5MVFkWEFBR3BzUVFGMFFZQ0FpdThCYTBFUWRTQU1iRUdBZ0FGcVFROTJJQXhyUVJCMFFZQ0FnSUI0YTBFUWRTSU1aeUlPYTBFTGRDQVNJQlJCRVd0MFFSQjBRUkIxSWhKQjIydHNRWUNBQVdwQkQzVkIvRDFxSUJKc1FZQ0FBV3BCRDNacklBd2dEa0VSYTNSQkVIUkJFSFVpREVIYmEyeEJnSUFCYWtFUGRVSDhQV29nREd4QmdJQUJha0VQZG1wQkVIUkJFSFVnQkVFWGRFR0FnSUFFYTBFUWRXeEJnSUFCYWtFUGRTSU1JQVVvQWdBaURrb05BRUVBSUFnZ0RFRUFJQTVyU0JzaEFBc2dCMEVCVEEwRERBa0xJQUJCZjNOQkgzWkJBQ0FJSUF0c1FmLy9BVUdCZ0g0Z0NFR0F3QUJLR3lBTGJXb2lBRUVPZFNBQVFRQklHeUlBSUF0QkFXc2dBQ0FMU0J0cUN5RUFJQVJCQWt3TkJ5QU5JQXRCQW0waUIwRURiRUVEYWlJSUlBZEJmM05xSUFCcUlBQkJBMndpQ1NBQUlBZEtJZ3diSUFnZ0Iyc2dBR29nQ1VFRGFpQU1HeUFISUFocUVDRWdBRUVPZENJQUlBdHVJUWdNQ0FzZ0RSQUxJUkVnQzBFQlJnMEVBa0FnQkVFRFNBMEFJQWxGRFFBZ0RRSi9JQTBnQzBFQ2JTSUFRUUZxSWdkQkEyd2lBaUFBYWlJSUVGSWlBeUFDU0FSQUlBTkJBMjBNQVFzZ0F5QUhRUUYwYXdzaUNTQUNJQUJCZjNOcWFpQUpRUU5zSWdNZ0FDQUpTQ0lIR3lBQ0lBQnJJQWxxSUFOQkEyb2dCeHNnQ0JBeERBTUxRUUFnQjBFQlRDQUpHdzBCSUEwZ0MwRUJhaEFXSVFrTUFnc2dDeUFBYXlJRFFRRnFJZ2NnQUVFQmFpSUlJQUFnQzBFQmRTSUNTaUlKR3lFUElBSkJBV29pQWlBQ2JDRUNJQTBnQ1FSL0lBSWdCeUFEUVFKcWJFRUJkV3NGSUFBZ0NHeEJBWFVMSWdrZ0NTQVBhaUFDRUNFZ0FFRU9kQ0FMYmlFSURBZ0xJQTBDZnlBTklBdEJBWFVpQjBFQmFpSUFJQUJzSWdNUVVpSUNJQUFnQjJ4QkFYVklCRUFnQWtFRGRFRUJjaEE0UVFGclFRRjJJZ2xCQVdvaUFDQUpiRUVCZGd3QkN5QURJQXRCQVdvaUFDQUFRUUYwSUFNZ0FrRi9jMnBCQTNSQkFYSVFPR3RCQVhZaUNXc2lBQ0FMSUFsclFRSnFiRUVCZFdzTElnSWdBQ0FDYWlBREVERUxJQWxCRG5RZ0MyNGhDQXdHQ3lBSlJRMEZRUUFoQ1VFQUlRY0NRQ0FJUVlIQUFFZ05BQ0FBS0FJMERRQkJBU0VISUFSQkFVZ05BRUVBSVFzRFFDQURJQXRCQW5ScUlnY2dCeW9DQUl3NEFnQkJBU0VISUF0QkFXb2lDeUFFUncwQUN3c2dCRUVCU0EwQklCQWdFeWdDQ0NBUGFrRUNkR29xQWdBaUZTQVFJQTlCQW5ScUtnSUFJaFlnRnBSRGZSMlFKcElnRlNBVmxKS1JRMzBka0NhU0loV1ZJUmNnRmlBVmxTRVZBMEFnQWlBSlFRSjBJZ2hxSWdzZ0ZTQUxLZ0lBbENBWElBTWdDR29xQWdDVWtqZ0NBQ0FKUVFGcUlna2dCRWNOQUFzTUFRdEJBQ0VISUFsRkRRTUxRUUFDZjBFQUlBVW9BZ0JCRVVnTkFCcEJBQ0FBS0FJZ1FSRklEUUFhSUF3RVFDQU5JQWNRbWdFZ0J3d0JDeUFOUVFJUUJnc2dBQ2dDTkJzaEJ3d0NDeUFOSUFBZ0MwRUJhaEJSSUFCQkRuUWlBQ0FMYmlFSUlBbEZEUUlMSUFBZ0Mwa0VRRUVBSVFjZ0JFRUJTQTBCSUJBZ0V5Z0NDQ0FQYWtFQ2RHb3FBZ0FpRlNBUUlBOUJBblJxS2dJQUloWWdGcFJEZlIyUUpwSWdGU0FWbEpLUlEzMGRrQ2FTSWhXVklSY2dGaUFWbFNFVlFRQWhDUU5BSUFJZ0NVRUNkQ0lBYWlJSUlCVWdDQ29DQUpRZ0Z5QUFJQU5xS2dJQWxKSTRBZ0FnQ1VFQmFpSUpJQVJIRFFBTERBRUxJQVJCQVVnTkFVRUFJUWtEUUNBQ0lBbEJBblFpQUdvaUJ5QUhLZ0lBUS9NRU5UK1VJaFVnQUNBRGFpSUFLZ0lBUS9NRU5UK1VJaGFTT0FJQUlBQWdGaUFWa3pnQ0FDQUpRUUZxSWdrZ0JFY05BQXNNQVFzZ0RSQUxJUUFnQlNBRktBSUFJQUFnRVdzaUFHczJBZ0FNQVFzZ0RSQUxJUUFnQlNBRktBSUFJQUFnRVdzaUFHczJBZ0JCZ0lBQklRa2dDRUdBZ0FGR0RRRWdDQTBDSUFnaEJ3c2dDaUFLS0FJQVFYOGdCblJCZjNOeE5nSUFRZi8vQVNFRFFRQWhDVUVBSVFKQmdJQi9EQUlMSUFvZ0NpZ0NBRUYvSUFaMFFYOXpJQVowY1RZQ0FFSC8vd0VoQWtFQUlRZEJBQ0VEUVlDQUFRd0JDMEVBSVFjZ0NDRUpJQWhCRUhRaUJVRU5kU0FGUVJCMWJFR0FnQUpxUVJCMUlnSWdBa0dPZTJ4QmdJQUJha0VQZFVIVndBQnFiRUVCZEVHQWdJcnZBV3RCRUhVZ0FteEJnSUFCYWtFUGRpQUNhMEVRZEVHQWdJQ0FlR3RCRUhVaUEyY2lCa0dBZ0lDQUJDQUZheUlDUVExMUlBSkJFSFZzUVlDQUFtcEJFSFVpQWlBQ1FZNTdiRUdBZ0FGcVFROTFRZFhBQUdwc1FRRjBRWUNBaXU4QmEwRVFkU0FDYkVHQWdBRnFRUTkySUFKclFSQjBRWUNBZ0lCNGEwRVFkU0lDWnlJRmEwRUxkQ0FESUFaQkVXdDBRUkIwUVJCMUlnWkIyMnRzUVlDQUFXcEJEM1ZCL0QxcUlBWnNRWUNBQVdwQkQzWnJJQUlnQlVFUmEzUkJFSFJCRUhVaUJVSGJhMnhCZ0lBQmFrRVBkVUg4UFdvZ0JXeEJnSUFCYWtFUGRtcEJFSFJCRUhVZ0JFRVhkRUdBZ0lBRWEwRVFkV3hCZ0lBQmFrRVBkUXNoQkNBQklBQTJBaFFnQVNBSk5nSVFJQUVnQkRZQ0RDQUJJQUkyQWdnZ0FTQUROZ0lFSUFFZ0J6WUNBQXVaQ3dJSWZ3VjlJd0JCSUdzaURDUUFJQXdnQ2pZQ0dDQU1JQVEyQWh3Z0FDZ0NIQ0VFSUFBb0FnQWhEd0pBSUFOQkFVWUVRRUVDUVFFZ0Foc2lBMEVCSUFOQkFVc2JJUVlnQUNnQ0lDRURBa0FnRHdSQVFRQWhCU0FEUVFoT0JFQWdCQ0FCS2dJQVF3QUFBQUJkSWdVUUlDQUFJQUFvQWlCQkNHc2lBellDSUFzZ0FDZ0NCQVJBSUFGREFBQ0F2ME1BQUlBL0lBVWJPQUlBQ3lBQ1JRMEJRUUVoQ2dOQVFRQWhCU0FEUVFoT0JFQWdCQ0FDS2dJQVF3QUFBQUJkSWdVUUlDQUFJQUFvQWlCQkNHc2lBellDSUFzZ0FDZ0NCQVJBSUFKREFBQ0F2ME1BQUlBL0lBVWJPQUlBQ3lBS1FRRnFJZ29nQmtjTkFBc01BUXRCQUNFRklBTkJDRTRFUUNBRVFRRVFDU0VGSUFBZ0FDZ0NJRUVJYXlJRE5nSWdDeUFBS0FJRUJFQWdBVU1BQUlDL1F3QUFnRDhnQlJzNEFnQUxJQUpGRFFCQkFTRUtBMEJCQUNFRklBTkJDRTRFUUNBRVFRRVFDU0VGSUFBZ0FDZ0NJRUVJYXlJRE5nSWdDeUFBS0FJRUJFQWdBa01BQUlDL1F3QUFnRDhnQlJzNEFnQUxJQXBCQVdvaUNpQUdSdzBBQ3d0QkFTRUhJQWhGRFFFZ0NDQUJLZ0lBT0FJQURBRUxJQUFnRENBQklBSWdBeUFNUVJ4cUlBVWdCU0FIUVFFZ0RFRVlhaEFqSUF3b0FnaXlRd0FBQURpVUlSTWdEQ2dDQkxKREFBQUFPSlFoRlNBTUtBSVVJUXNnRENnQ0VDRU5JQXdvQWdBaEVRSkFJQU5CQWtZRVFDQU1LQUljSVE0Z0FDQUFLQUlnSUExQi8vOStjU0lTUVFCSFFRTjBJaEFnQzJwck5nSWdJQUVnQWlBTlFZREFBRW9pRFJzaEN5QUNJQUVnRFJzaERTQU9JQkJySVJCQkFDRU9Ba0FnRWtVTkFDQVBCRUFnQkNBTktnSUFJQXNxQWdTVUlBMHFBZ1FnQ3lvQ0FKU1RRd0FBQUFCZElnNFFJQXdCQ3lBRVFRRVFDU0VPQ3lBQUlBMUJBaUFRSUFVZ0JpQUhJQWhEQUFDQVB5QUpJQW9RQ2lFSElBc2dEU29DQkVFQVFRRWdEa0VCZEdzaUJHdXlsRGdDQUNBTElBMHFBZ0FnQkxLVU9BSUVJQUFvQWdSRkRRRWdBU0FWSUFFcUFnQ1VPQUlBSUFFZ0ZTQUJLZ0lFbERnQ0JDQUNJQk1nQWlvQ0FKUWlGRGdDQUNBQ0lCTWdBaW9DQkpRNEFnUWdBU0FCS2dJQUloTWdGSk00QWdBZ0FpQVRJQUlxQWdDU09BSUFJQUVnQVNvQ0JDSVRJQUlxQWdTVE9BSUVJQUlnRXlBQ0tnSUVramdDQkF3QkN5QU1LQUljSVFRZ0RDZ0NEQ0VQSUFBZ0FDZ0NJQ0FMYXlJT05nSWdJQXdvQWhnaENpQUVJQVFnRDJ0QkFtMGlDeUFFSUF0SUd5SUxRUUFnQzBFQVNoc2lDeUFFSUF0cklnUk9CRUFnQUNBQklBTWdDeUFGSUFZZ0J5QUlRd0FBZ0Q4Z0NTQUtFQW9nQUNBQ0lBTWdCQ0FBS0FJZ0lBNXJJQXRxSWdSQkdHdEJBQ0FFUVJoS0cwRUFJQTBiYWlBRlFRQWdCMEVBSUJOQkFDQUtJQVYxRUFweUlRY01BUXNnQUNBQ0lBTWdCQ0FGUVFBZ0IwRUFJQk5CQUNBS0lBVjFFQW9nQUNBQklBTWdBQ2dDSUNBT2F5QUVhaUlFUVJoclFRQWdCRUVZU2h0QkFDQU5RWUNBQVVjYklBdHFJQVVnQmlBSElBaERBQUNBUHlBSklBb1FDbkloQndzZ0FDZ0NCRVVOQUFKQUlBTkJBa1lOQUVNQUFBQUFJUlFDUUNBRFFRRklCRUJEQUFBQUFDRVREQUVMUVFBaEFFTUFBQUFBSVJNRFFDQVRJQUlnQUVFQ2RDSUVhaW9DQUNJV0lBRWdCR29xQWdDVWtpRVRJQlFnRmlBV2xKSWhGQ0FBUVFGcUlnQWdBMGNOQUFzTEFrQWdGU0FWbENBVWtpSVVJQlVnRTVRaUV5QVRraUlUa2lJV1ExSkpIVHBkUlFSQUlCUWdFNU1pRTBOU1NSMDZYVUVCY3cwQkN5QUNJQUVnQTBFQ2RCQUVHZ3dCQ3lBRFFRRklEUUZEQUFDQVB5QVdrWlVoRkVNQUFJQS9JQk9SbFNFVFFRQWhBQU5BSUFFZ0FFRUNkQ0lFYWlJRklCTWdGU0FGS2dJQWxDSVdJQUlnQkdvaUJDb0NBQ0lYazVRNEFnQWdCQ0FVSUJZZ0Y1S1VPQUlBSUFCQkFXb2lBQ0FEUncwQUN3c2dFVVVOQUNBRFFRRklEUUJCQUNFQUEwQWdBaUFBUVFKMGFpSUJJQUVxQWdDTU9BSUFJQUJCQVdvaUFDQURSdzBBQ3dzZ0RFRWdhaVFBSUFjTEVBQWdBU0FBUWNrd1FRZ1FBellDQUF0ZkFDQUFRUVJxUVFCQnBDRVFCUm9nQUVFQU5nTElJQ0FBUVlDQUJEWUNBQ0FBUVFFMkFzZ1NJQUFRZWlBQVFaUWhha0tBZ0lTQWdJREFBRGNDQUNBQVFhQWhha0tDZ0lDQXdBSTNBZ0FnQUNBQUtBS1lFa0VIZERZQ3pDQkJBQXVwQ1FFSWZ5TUFRYUFCYXlJSkpBQWdBQ0FDUVFGMVFRbHNRZUF6YWtFSUVBTWhCUUpBSUFSQkJIVWdCRUZ3Y1NBRVNHb2lDMEVBVEEwQUlBVkJFbXhCb0RKcUlRY0RRRUVBSVFVZ0NTQUdRUUowSWdocUlncEJBRFlDQUNBSlFkQUFhaUFJYWlJSUlBQWdCMEVJRUFNaUREWUNBQ0FNUVJGR0JFQURRQ0FJSUFBZ0JVRUJhaUlGUVFwR1FjSXpha0VJRUFNaUREWUNBQ0FNUVJGR0RRQUxJQW9nQlRZQ0FBc2dCa0VCYWlJR0lBdEhEUUFMUVFBaEJTQUxRUUJNRFFBRFFDQUJJQVZCRUhSQkMzVnFJUVlDUUNBSlFkQUFhaUFGUVFKMGFpZ0NBQ0lIUVFGT0JFQWdCaUFBSUFjUVpnd0JDeUFHUWdBM0FRQWdCa0lBTndFWUlBWkNBRGNCRUNBR1FnQTNBUWdMSUFWQkFXb2lCU0FMUncwQUMwRUFJUW9nQzBFQVRBMEFBMEFnQ1NBS1FRSjBJZ3hxS0FJQUlnaEJBVTRFUUNBQklBcEJFSFJCQzNWcUlnY3ZBUUFoQlVFQUlRWURRQ0FBUWVBd1FRZ1FBeUFGUVFGMGFpRUZJQVpCQVdvaUJpQUlSdzBBQ3lBSElBVTdBUUFnQnk4QkFpRUZRUUFoQmdOQUlBQkI0REJCQ0JBRElBVkJBWFJxSVFVZ0JrRUJhaUlHSUFoSERRQUxJQWNnQlRzQkFpQUhMd0VFSVFWQkFDRUdBMEFnQUVIZ01FRUlFQU1nQlVFQmRHb2hCU0FHUVFGcUlnWWdDRWNOQUFzZ0J5QUZPd0VFSUFjdkFRWWhCVUVBSVFZRFFDQUFRZUF3UVFnUUF5QUZRUUYwYWlFRklBWkJBV29pQmlBSVJ3MEFDeUFISUFVN0FRWWdCeThCQ0NFRlFRQWhCZ05BSUFCQjREQkJDQkFESUFWQkFYUnFJUVVnQmtFQmFpSUdJQWhIRFFBTElBY2dCVHNCQ0NBSEx3RUtJUVZCQUNFR0EwQWdBRUhnTUVFSUVBTWdCVUVCZEdvaEJTQUdRUUZxSWdZZ0NFY05BQXNnQnlBRk93RUtJQWN2QVF3aEJVRUFJUVlEUUNBQVFlQXdRUWdRQXlBRlFRRjBhaUVGSUFaQkFXb2lCaUFJUncwQUN5QUhJQVU3QVF3Z0J5OEJEaUVGUVFBaEJnTkFJQUJCNERCQkNCQURJQVZCQVhScUlRVWdCa0VCYWlJR0lBaEhEUUFMSUFjZ0JUc0JEaUFITHdFUUlRVkJBQ0VHQTBBZ0FFSGdNRUVJRUFNZ0JVRUJkR29oQlNBR1FRRnFJZ1lnQ0VjTkFBc2dCeUFGT3dFUUlBY3ZBUkloQlVFQUlRWURRQ0FBUWVBd1FRZ1FBeUFGUVFGMGFpRUZJQVpCQVdvaUJpQUlSdzBBQ3lBSElBVTdBUklnQnk4QkZDRUZRUUFoQmdOQUlBQkI0REJCQ0JBRElBVkJBWFJxSVFVZ0JrRUJhaUlHSUFoSERRQUxJQWNnQlRzQkZDQUhMd0VXSVFWQkFDRUdBMEFnQUVIZ01FRUlFQU1nQlVFQmRHb2hCU0FHUVFGcUlnWWdDRWNOQUFzZ0J5QUZPd0VXSUFjdkFSZ2hCVUVBSVFZRFFDQUFRZUF3UVFnUUF5QUZRUUYwYWlFRklBWkJBV29pQmlBSVJ3MEFDeUFISUFVN0FSZ2dCeThCR2lFRlFRQWhCZ05BSUFCQjREQkJDQkFESUFWQkFYUnFJUVVnQmtFQmFpSUdJQWhIRFFBTElBY2dCVHNCR2lBSEx3RWNJUVZCQUNFR0EwQWdBRUhnTUVFSUVBTWdCVUVCZEdvaEJTQUdRUUZxSWdZZ0NFY05BQXNnQnlBRk93RWNJQWN2QVI0aEJVRUFJUVlEUUNBQVFlQXdRUWdRQXlBRlFRRjBhaUVGSUFaQkFXb2lCaUFJUncwQUN5QUhJQVU3QVI0Z0NVSFFBR29nREdvaUJTQUZLQUlBSUFoQkJYUnlOZ0lBQ3lBS1FRRnFJZ29nQzBjTkFBc0xJQUFnQVNBRUlBSWdBeUFKUWRBQWFoQndJQWxCb0FGcUpBQUx4UVlCQVg4akFFRXdheUlGSkFBZ0FFSE9GV29DZndKQUlBTkZCRUFnQUNBQ1FRSjBha0hrRW1vb0FnQkZEUUVMSUFGQjVUQkJDQkFEUVFKcURBRUxJQUZCNlRCQkNCQURDeUlEUVFGeE9nQUFJQUJCelJWcUlBTkJBWFlpQWpvQUFBSkFJQVJCQWtZRVFDQUFJQUZCNEM5QkNCQURPZ0N3RlF3QkN5QUFJQUVnQWtFWWRFRVZkVUhBTDJwQkNCQURRUU4wT2dDd0ZTQUFJQUZCa0RGQkNCQURJQUF0QUxBVmFqb0FzQlVMSUFBb0FwUVNRUUpPQkVCQkFTRURBMEFnQUNBRGFrR3dGV29nQVVIZ0wwRUlFQU02QUFBZ0EwRUJhaUlESUFBb0FwUVNTQTBBQ3dzZ0FFRzRGV29nQVNBQUtBS3NGU0lDS0FJUUlBSXVBUUFnQUN3QXpSVkJBWFZzYWtFSUVBTWlBam9BQUNBRlFSQnFJQVVnQUNnQ3JCVWdBa0VZZEVFWWRSQkdJQUFvQXF3VklnSXVBUUpCQVU0RVFFRUFJUU1EUUFKQUFrQUNRQ0FCSUFJb0Fod2dCVUVRYWlBRFFRRjBhaTRCQUdwQkNCQURJZ0lPQ1FBQ0FnSUNBZ0lDQVFJTFFRQWdBVUdZTVVFSUVBTnJJUUlNQVFzZ0FVR1lNVUVJRUFOQkNHb2hBZ3NnQUNBRFFRRnFJZ05xUWJnVmFpQUNRUVJyT2dBQUlBTWdBQ2dDckJVaUFpNEJBa2dOQUFzTFFRUWhBeUFBUWM4VmFpQUFLQUtVRWtFRVJnUi9JQUZCNnpCQkNCQURCVUVFQ3pvQUFDQUFMUURORlVFQ1JnUkFBa0FDUUNBRVFRSkhEUUFnQUNnQzNCSkJBa2NOQUNBQlFjQXhRUWdRQXlJQ1FSQjBRUUZJRFFBZ0FFSEtGV29nQWlBQUx3SGdFbXBCQ1dzaUFqc0JBQXdCQ3lBQVFjb1ZhaUlDSUFGQm9ERkJDQkFESUFBb0Fvd1NRUUYyYkRzQkFDQUNJQUVnQUNnQ3pCSkJDQkFESUFJdkFRQnFJZ0k3QVFBTElBQWdBanNCNEJJZ0FFSE1GV29nQVNBQUtBTFFFa0VJRUFNNkFBQWdBRUhRRldvZ0FVSFNFRUVJRUFNaUFqb0FBRUVCSVFNQ1FDQUFLQUtVRWtFQlNBMEFJQUJCdEJWcUlBRWdBa0VZZEVFV2RVR1FFV29vQWdCQkNCQURPZ0FBSUFBb0FwUVNRUUpJRFFBRFFDQUFJQU5xUWJRVmFpQUJJQUFzQU5BVlFRSjBRWkFSYWlnQ0FFRUlFQU02QUFBZ0EwRUJhaUlESUFBb0FwUVNTQTBBQ3d0QkFDRURJQUJCMFJWcUlBUUVmMEVBQlNBQlFlSXdRUWdRQXdzNkFBQUxJQUFnQUN3QXpSVTJBdHdTSUFCQjBoVnFJQUZCZ1RGQkNCQURPZ0FBSUFWQk1Hb2tBQXZBQVFFRWZ5QUJRUUZySVFRZ0FVRUNUZ1JBSUFKQmdJQUVheUVGUVFBaEFRTkFJQUFnQVVFQ2RHb2lBeUFES0FJQUlnTkJFSFJCRUhVaUJpQUNRZi8vQTNGc1FSQjFJQVlnQWtFUWRXeHFJQU5CRDNWQkFXcEJBWFVnQW14cU5nSUFJQUlnQld4QkQzVkJBV3BCQVhVZ0Ftb2hBaUFCUVFGcUlnRWdCRWNOQUFzTElBQWdCRUVDZEdvaUFDQUFLQUlBSWdCQkVIUkJFSFVpQVNBQ1FmLy9BM0ZzUVJCMUlBRWdBa0VRZFd4cUlBQkJEM1ZCQVdwQkFYVWdBbXhxTmdJQUMzNEJBMzhnQVVFQmF5RURJQUZCQWs0RVFDQUNRWUNBQkdzaEJFRUFJUUVEUUNBQUlBRkJBWFJxSWdVZ0FpQUZMZ0VBYkVFUGRrRUJha0VCZGpzQkFDQUNJQVJzUVE5MVFRRnFRUUYxSUFKcUlRSWdBVUVCYWlJQklBTkhEUUFMQ3lBQUlBTkJBWFJxSWdBZ0FpQUFMZ0VBYkVFUGRrRUJha0VCZGpzQkFBdkpDQUlLZndGK0l3QkJ3QUpySWdRa0FFRUJJUU1nQWtFQlRnUkFRWkFKUWFBSklBSkJFRVliSVFrRFFDQUVRZUFCYWlBRklBbHFMUUFBUVFKMGFpQUJJQVZCQVhScUxnRUFJZ1pCQ0hWQkFYUkIwQTVxSWdjdUFRSWdCeTRCQUNJSGF5QUdRZjhCY1d3Z0IwRUlkR3BCQTNWQkFXcEJBWFUyQWdBZ0JVRUJhaUlGSUFKSERRQUxJQVFvQXVBQklRVUxRWUNBQkNFR0lBUkJnSUFFTmdLZ0FTQUVRUUFnQldzaUJUWUNwQUVnQWtFQmRTRUhBa0FnQWtFRVNDSUxEUUFnQlNFQkEwQWdCRUdnQVdvZ0EwRUJhaUlKUVFKMGFpSU1JQVpCQVhRZ0JFSGdBV29nQTBFRGRHb29BZ0FpRGF3aURpQUJySDVDRDRoQ0FYeENBWWluYXpZQ0FDQURRUUowSWdnZ0JFR2dBV3BxSVFvZ0JDQURRUUpQQkg4Z0NpQUVJQWhxS0FLWUFTSUZJQUZxSUFhc0lBNStRZytJUWdGOFFnR0lwMnMyQWdBZ0EwRUNSd1JBQTBBZ0JFR2dBV29nQTBFQmF5SUJRUUowYWlJSUlBTkJBblFnQkdvb0FwUUJJZ1lnQ0NnQ0FHb2dCYXdnRG41Q0Q0aENBWHhDQVlpbmF6WUNBQ0FEUVFOS0lRZ2dBU0VESUFZaEJTQUlEUUFMQ3lBRUtBS2tBUVVnQlFzZ0RXc2lCVFlDcEFFZ0J5QUpSZzBCSUF3b0FnQWhBU0FLS0FJQUlRWWdDU0VEREFBTEFBdEJnSUFFSVFZZ0JFR0FnQVEyQW1BZ0JFRUFJQVFvQXVRQmF5SUZOZ0prQWtBZ0N3MEFJQVJCNEFGcVFRUnlJUXRCQVNFRElBVWhBUU5BSUFSQjRBQnFJQU5CQVdvaUNVRUNkR29pRENBR1FRRjBJQXNnQTBFRGRHb29BZ0FpRGF3aURpQUJySDVDRDRoQ0FYeENBWWluYXpZQ0FDQURRUUowSWdnZ0JFSGdBR3BxSVFvZ0JDQURRUUpQQkg4Z0NpQUVJQWhxS0FKWUlnVWdBV29nQnF3Z0RuNUNENGhDQVh4Q0FZaW5hellDQUNBRFFRSkhCRUFEUUNBRVFlQUFhaUFEUVFGcklnRkJBblJxSWdnZ0EwRUNkQ0FFYWlnQ1ZDSUdJQWdvQWdCcUlBV3NJQTUrUWcrSVFnRjhRZ0dJcDJzMkFnQWdBMEVEU2lFSUlBRWhBeUFHSVFVZ0NBMEFDd3NnQkNnQ1pBVWdCUXNnRFdzaUJUWUNaQ0FISUFsR0RRRWdEQ2dDQUNFQklBb29BZ0FoQmlBSklRTU1BQXNBQ3lBQ1FRSk9CRUFnQjBFQklBZEJBVW9iSVFvZ0JDZ0NZQ0VHSUFRb0FxQUJJUUZCQUNFREEwQWdCQ0FEUVFKMGFrRUFJQU5CQVdvaUJVRUNkQ0lISUFSQjRBQnFhaWdDQUNJSklBWnJJZ1lnQVNBRVFhQUJhaUFIYWlnQ0FDSUhhaUlCYW1zMkFnQWdCQ0FEUVg5eklBSnFRUUowYWlBR0lBRnJOZ0lBSUFraEJpQUhJUUVnQlNJRElBcEhEUUFMQ3lBQUlBUWdBaEIzQWtBZ0FDQUNFQjBOQUVFQUlRVWdBa0VCVGdSQUEwQWdCQ0FDUVg0Z0JYUkJnSUFFYWhBcFFRQWhBd05BSUFBZ0EwRUJkR29nQkNBRFFRSjBhaWdDQUVFRWRrRUJha0VCZGpzQkFDQURRUUZxSWdNZ0FrY05BQXNnQUNBQ0VCMGhBU0FGUVE1TERRSWdCVUVCYWlFRklBRkZEUUFNQWdzQUN3TkFJQVFnQWtGK0lBVjBRWUNBQkdvUUtTQUFJQUlRSFNFQklBVkJEa3NOQVNBRlFRRnFJUVVnQVVVTkFBc0xJQVJCd0FKcUpBQUxueEVDRDM4QmZpTUFRZEFBYXlJRkpBQWdCU0FCTmdKTUlBVkJOMm9oRXlBRlFUaHFJUkZCQUNFQkFrQURRQUpBSUE1QkFFZ05BRUgvLy8vL0J5QU9heUFCU0FSQVFaejdBVUU5TmdJQVFYOGhEZ3dCQ3lBQklBNXFJUTRMSUFVb0Frd2lDaUVCQWtBQ1FBSkFJQW90QUFBaUJnUkFBMEFDUUFKQUlBWkIvd0Z4SWdaRkJFQWdBU0VHREFFTElBWkJKVWNOQVNBQklRWURRQ0FCTFFBQlFTVkhEUUVnQlNBQlFRSnFJZ2cyQWt3Z0JrRUJhaUVHSUFFdEFBSWhDU0FJSVFFZ0NVRWxSZzBBQ3dzZ0JpQUtheUVCSUFBRVFDQUFJQW9nQVJBUUN5QUJEUVlnQlNnQ1RDRUJJQVVDZndKQUlBVW9Ba3dzQUFGQk1HdEJDazhOQUNBQkxRQUNRU1JIRFFBZ0FTd0FBVUV3YXlFUVFRRWhFaUFCUVFOcURBRUxRWDhoRUNBQlFRRnFDeUlCTmdKTVFRQWhEd0pBSUFFc0FBQWlDMEVnYXlJSVFSOUxCRUFnQVNFR0RBRUxJQUVoQmtFQklBaDBJZ2xCaWRFRWNVVU5BQU5BSUFVZ0FVRUJhaUlHTmdKTUlBa2dEM0loRHlBQkxBQUJJZ3RCSUdzaUNFRWdUdzBCSUFZaEFVRUJJQWgwSWdsQmlkRUVjUTBBQ3dzQ1FDQUxRU3BHQkVBZ0JRSi9Ba0FnQml3QUFVRXdhMEVLVHcwQUlBVW9Ba3dpQVMwQUFrRWtSdzBBSUFFc0FBRkJBblFnQkdwQndBRnJRUW8yQWdBZ0FTd0FBVUVEZENBRGFrR0FBMnNvQWdBaERFRUJJUklnQVVFRGFnd0JDeUFTRFFaQkFDRVNRUUFoRENBQUJFQWdBaUFDS0FJQUlnRkJCR28yQWdBZ0FTZ0NBQ0VNQ3lBRktBSk1RUUZxQ3lJQk5nSk1JQXhCZjBvTkFVRUFJQXhySVF3Z0QwR0F3QUJ5SVE4TUFRc2dCVUhNQUdvUVRDSU1RUUJJRFFRZ0JTZ0NUQ0VCQzBGL0lRY0NRQ0FCTFFBQVFTNUhEUUFnQVMwQUFVRXFSZ1JBQWtBZ0FTd0FBa0V3YTBFS1R3MEFJQVVvQWt3aUFTMEFBMEVrUncwQUlBRXNBQUpCQW5RZ0JHcEJ3QUZyUVFvMkFnQWdBU3dBQWtFRGRDQURha0dBQTJzb0FnQWhCeUFGSUFGQkJHb2lBVFlDVEF3Q0N5QVNEUVVnQUFSL0lBSWdBaWdDQUNJQlFRUnFOZ0lBSUFFb0FnQUZRUUFMSVFjZ0JTQUZLQUpNUVFKcUlnRTJBa3dNQVFzZ0JTQUJRUUZxTmdKTUlBVkJ6QUJxRUV3aEJ5QUZLQUpNSVFFTFFRQWhCZ05BSUFZaENVRi9JUTBnQVN3QUFFSEJBR3RCT1VzTkNDQUZJQUZCQVdvaUN6WUNUQ0FCTEFBQUlRWWdDeUVCSUFZZ0NVRTZiR3BCNy9NQmFpMEFBQ0lHUVFGclFRaEpEUUFMQWtBQ1FDQUdRUk5IQkVBZ0JrVU5DaUFRUVFCT0JFQWdCQ0FRUVFKMGFpQUdOZ0lBSUFVZ0F5QVFRUU4wYWlrREFEY0RRQXdDQ3lBQVJRMElJQVZCUUdzZ0JpQUNFRXNnQlNnQ1RDRUxEQUlMSUJCQmYwb05DUXRCQUNFQklBQkZEUWNMSUE5Qi8vOTdjU0lJSUE4Z0QwR0F3QUJ4R3lFR1FRQWhEVUdVOUFFaEVDQVJJUThDUUFKQUFrQUNmd0pBQWtBQ1FBSkFBbjhDUUFKQUFrQUNRQUpBQWtBQ1FDQUxRUUZyTEFBQUlnRkJYM0VnQVNBQlFROXhRUU5HR3lBQklBa2JJZ0ZCMkFCckRpRUVGQlFVRkJRVUZCUU9GQThHRGc0T0ZBWVVGQlFVQWdVREZCUUpGQUVVRkFRQUN3SkFJQUZCd1FCckRnY09GQXNVRGc0T0FBc2dBVUhUQUVZTkNRd1RDeUFGS1FOQUlSUkJsUFFCREFVTFFRQWhBUUpBQWtBQ1FBSkFBa0FDUUFKQUlBbEIvd0Z4RGdnQUFRSURCQm9GQmhvTElBVW9Ba0FnRGpZQ0FBd1pDeUFGS0FKQUlBNDJBZ0FNR0FzZ0JTZ0NRQ0FPckRjREFBd1hDeUFGS0FKQUlBNDdBUUFNRmdzZ0JTZ0NRQ0FPT2dBQURCVUxJQVVvQWtBZ0RqWUNBQXdVQ3lBRktBSkFJQTZzTndNQURCTUxJQWRCQ0NBSFFRaExHeUVISUFaQkNISWhCa0g0QUNFQkN5QUZLUU5BSUJFZ0FVRWdjUkNKQVNFS0lBWkJDSEZGRFFNZ0JTa0RRRkFOQXlBQlFRUjJRWlQwQVdvaEVFRUNJUTBNQXdzZ0JTa0RRQ0FSRUlnQklRb2dCa0VJY1VVTkFpQUhJQkVnQ21zaUFVRUJhaUFCSUFkSUd5RUhEQUlMSUFVcEEwQWlGRUovVndSQUlBVkNBQ0FVZlNJVU53TkFRUUVoRFVHVTlBRU1BUXNnQmtHQUVIRUVRRUVCSVExQmxmUUJEQUVMUVpiMEFVR1U5QUVnQmtFQmNTSU5Hd3NoRUNBVUlCRVFod0VoQ2dzZ0JrSC8vM3R4SUFZZ0IwRi9TaHNoQmlBRktRTkFJUlFDUUNBSERRQWdGRkJGRFFCQkFDRUhJQkVoQ2d3TUN5QUhJQlJRSUJFZ0NtdHFJZ0VnQVNBSFNCc2hCd3dMQ3lBRktBSkFJZ0ZCbnZRQklBRWJJZ29nQnhDUEFTSUJJQWNnQ21vZ0FSc2hEeUFJSVFZZ0FTQUtheUFISUFFYklRY01DZ3NnQndSQUlBVW9Ba0FNQWd0QkFDRUJJQUJCSUNBTVFRQWdCaEFOREFJTElBVkJBRFlDRENBRklBVXBBMEErQWdnZ0JTQUZRUWhxTmdKQVFYOGhCeUFGUVFocUN5RUpRUUFoQVFKQUEwQWdDU2dDQUNJSVJRMEJBa0FnQlVFRWFpQUlFRTBpQ2tFQVNDSUlEUUFnQ2lBSElBRnJTdzBBSUFsQkJHb2hDU0FISUFFZ0Ntb2lBVXNOQVF3Q0N3dEJmeUVOSUFnTkN3c2dBRUVnSUF3Z0FTQUdFQTBnQVVVRVFFRUFJUUVNQVF0QkFDRUpJQVVvQWtBaEN3TkFJQXNvQWdBaUNFVU5BU0FGUVFScUlBZ1FUU0lJSUFscUlna2dBVW9OQVNBQUlBVkJCR29nQ0JBUUlBdEJCR29oQ3lBQklBbExEUUFMQ3lBQVFTQWdEQ0FCSUFaQmdNQUFjeEFOSUF3Z0FTQUJJQXhJR3lFQkRBZ0xJQUFnQlNzRFFDQU1JQWNnQmlBQlFRQVJJd0FoQVF3SEN5QUZJQVVwQTBBOEFEZEJBU0VISUJNaENpQUlJUVlNQkFzZ0JTQUJRUUZxSWdnMkFrd2dBUzBBQVNFR0lBZ2hBUXdBQ3dBTElBNGhEU0FBRFFRZ0VrVU5Ba0VCSVFFRFFDQUVJQUZCQW5ScUtBSUFJZ0FFUUNBRElBRkJBM1JxSUFBZ0FoQkxRUUVoRFNBQlFRRnFJZ0ZCQ2tjTkFRd0dDd3RCQVNFTklBRkJDazhOQkFOQUlBUWdBVUVDZEdvb0FnQU5BU0FCUVFGcUlnRkJDa2NOQUFzTUJBdEJmeUVOREFNTElBQkJJQ0FOSUE4Z0Ntc2lDU0FISUFjZ0NVZ2JJZ2hxSWdzZ0RDQUxJQXhLR3lJQklBc2dCaEFOSUFBZ0VDQU5FQkFnQUVFd0lBRWdDeUFHUVlDQUJITVFEU0FBUVRBZ0NDQUpRUUFRRFNBQUlBb2dDUkFRSUFCQklDQUJJQXNnQmtHQXdBQnpFQTBNQVFzTFFRQWhEUXNnQlVIUUFHb2tBQ0FOQzVJQkFRTjhSQUFBQUFBQUFQQS9JQUFnQUtJaUFrUUFBQUFBQUFEZ1A2SWlBNkVpQkVRQUFBQUFBQUR3UHlBRW9TQURvU0FDSUFJZ0FpQUNSSkFWeXhtZ0Fmbytva1IzVWNFV2JNRld2NkNpUkV4VlZWVlZWYVUvb0tJZ0FpQUNvaUlESUFPaUlBSWdBa1RVT0lpKzZmcW92YUpFeExHMHZaN3VJVDZnb2tTdFVweUFUMzZTdnFDaW9LSWdBQ0FCb3FHZ29BdDRBUUY5QWtBZ0FVRUJTQTBBUVFBaEF3TkFJQVFnQUNBRFFRSjBhaW9DQUNJRUlBU1VraUVFSUFOQkFXb2lBeUFCUncwQUN5QUJRUUZJRFFCREFBQ0FQeUFFUTMwZGtDYVNrWlVnQXBRaEFrRUFJUU1EUUNBQUlBSWdBQ29DQUpRNEFnQWdBRUVFYWlFQUlBTkJBV29pQXlBQlJ3MEFDd3NMOVFjRENYOEVmUUo4QWtBZ0JFRUJkQ0FCVGcwQUlBVkZEUUFnQWJJZ0JVRUNkRUhFM1FGcUtBSUFJQVJzSUFGcXNwVWlEeUFQbEVNQUFBQS9sQ0lQUTlzUHlUK1V1eEJRSVJOREFBQ0FQeUFQazBQYkQ4ay9sTHNRVUNFVVFRQWhCU0FCSUFOQkEzUk9CRUFnQTBFQ2RTRUlRUUVoQkFOQUlBUWlCVUVCYWlFRUlBVWdCU0FGYkdvZ0Eyd2dDR29nQVVnTkFBc0xJQUVnQTI0aENpQURRUUZJRFFBZ0U3WWhEeUFVdGlFUklBcEJBV3NpQ3lBRlFRRjBheUVJSUFvZ0JXc2hEQ0FLUVFOcklRa2dBa0YvU2lFTlFRQWhBZ05BSUFJZ0Ntd2hCZ0pBSUExRkJFQUNRQ0FGUlEwQVFRQWhBU0FBSUFaQkFuUnFJZ2NoQkNBTVFRRk9CRUFEUUNBRUlBVkJBblJxSWc0Z0JDb0NBQ0lRSUErVUlBNHFBZ0FpRWlBUmxKSTRBZ0FnQkNBUUlCR1VJQklnRDVTVE9BSUFJQVJCQkdvaEJDQUJRUUZxSWdFZ0RFY05BQXNMSUFoQkFFZ05BQ0FISUFoQkFuUnFJUVFnQ0NFQkEwQWdCQ0FGUVFKMGFpSUhJQVFxQWdBaUVDQVBsQ0FIS2dJQUloSWdFWlNTT0FJQUlBUWdFQ0FSbENBU0lBK1VremdDQUNBRVFRUnJJUVFnQVVFQVNpRUhJQUZCQVdzaEFTQUhEUUFMQ3lBQUlBWkJBblJxSVFZZ0MwRUJUZ1JBSUFZcUFnQWhFRUVBSVFFZ0JpRUVBMEFnQkNBUUlBK1VJQVFxQWdRaUVpQVJsSk00QWdBZ0JDQVFJQkdVSUJJZ0Q1U1NJaEE0QWdRZ0JFRUVhaUVFSUFGQkFXb2lBU0FMUncwQUN3c2dDVUVBU0EwQklBWWdDVUVDZEdvaEJDQUpJUUVEUUNBRUlBUXFBZ0FpRUNBUmxDQUVLZ0lFSWhJZ0Q1U1NPQUlFSUFRZ0VDQVBsQ0FTSUJHVWt6Z0NBQ0FFUVFScklRUWdBVUVBU2lFR0lBRkJBV3NoQVNBR0RRQUxEQUVMSUFBZ0JrRUNkR29oQmlBTFFRRk9CRUFnQmlvQ0FDRVFRUUFoQVNBR0lRUURRQ0FFSUJBZ0Q1UWdCQ29DQkNJU0lCR1VramdDQUNBRUlCSWdENVFnRUNBUmxKTWlFRGdDQkNBRVFRUnFJUVFnQVVFQmFpSUJJQXRIRFFBTEN5QUpRUUJPQkVBZ0JpQUpRUUowYWlFRUlBa2hBUU5BSUFRZ0JDb0NCQ0lRSUErVUlBUXFBZ0FpRWlBUmxKTTRBZ1FnQkNBU0lBK1VJQkFnRVpTU09BSUFJQVJCQkdzaEJDQUJRUUJLSVFjZ0FVRUJheUVCSUFjTkFBc0xJQVZGRFFCQkFDRUJJQVloQkNBTVFRRk9CRUFEUUNBRUlBVkJBblJxSWdjZ0J5b0NBQ0lRSUJHVUlBUXFBZ0FpRWlBUGxKTTRBZ0FnQkNBU0lCR1VJQkFnRDVTU09BSUFJQVJCQkdvaEJDQUJRUUZxSWdFZ0RFY05BQXNMSUFoQkFFZ05BQ0FHSUFoQkFuUnFJUVFnQ0NFQkEwQWdCQ0FGUVFKMGFpSUdJQVlxQWdBaUVDQVJsQ0FFS2dJQUloSWdENVNUT0FJQUlBUWdFaUFSbENBUUlBK1VramdDQUNBRVFRUnJJUVFnQVVFQVNpRUdJQUZCQVdzaEFTQUdEUUFMQ3lBQ1FRRnFJZ0lnQTBjTkFBc0xDOWNDQVFOL0l3QkJFR3NpQXlRQVFYOGhCUUpBQWtBZ0FVSC8vQUJNQkVBZ0FVSEFQa1lOQVNBQlFlRGRBRVlOQVF3Q0N5QUJRWUQ5QUVZTkFDQUJRWUQzQWtZTkFDQUJRY0M3QVVjTkFRc2dBa0VCYTBFQlN3MEFJQUJCQUFKL0lBTkI2TUlBTmdJTVFRQUxCSDlCQUFVZ0F5QURLQUlNUVFOcVFYeHhOZ0lNSUFNb0FneEJvRDBvQWdCQkFuUkI0TUFBYWlBQ2JFR2tQU2dDQUVFRmRHcHFRYlFCYWdzUUJTRUFRWDBoQlNBRFFlakNBRFlDQ0NBRElBTW9BZ2hCQTJwQmZIRWlCRFlDQ0NBQUlBSTJBakFnQUNBQ05nSUlJQUJCMkFBMkFnUWdBQ0FCTmdJWUlBQWdBVFlDRENBQUlBSTJBaEFnQUNBRVFkZ0FhaUlFTmdJQUlBQkIyQUJxRUVRTkFDQUFJQVJxSWdRZ0FTQUNFRndOQUVFQUlRVWdBMEVBTmdJQUlBUkJvTTRBSUFNUUJ4b2dBQ0FCUWYvL0EzRkJrQU51TmdKQUlBQkJBRFlDUENBQVFRQTJBaXdMSUFOQkVHb2tBQ0FGQytzQkFRWi9JQUFnQUNnQ0lDQUFLQUlrSWdRZ0F5QUNhMndpQTJzaUJqWUNJQ0FBSUFFRWZ5QUVJQUlnQVd0c0JTQUFLQUljSUFOckN5SUNOZ0ljSUFKQmdJQ0FCRTBFUUNBQUtBSVlJUU1nQUNnQ0tDRUVJQUFvQWhRaEJ5QUFLQUlFSVFnRFFDQUFJQUpCQ0hRaUNUWUNIQ0FBSUFkQkNHb2lCellDRkVFQUlRRWdBeUFJU1FSQUlBQWdBMEVCYWlJRk5nSVlJQUFvQWdBZ0Eyb3RBQUFoQVNBRklRTUxJQUFnQVRZQ0tDQUFJQVpCQ0hSQmdQNy8vd2R4SUFFZ0JFRUlkSEpCQVhaQi93Rnhja0gvQVhNaUJqWUNJQ0FDUVlHQUFra2hCU0FCSVFRZ0NTRUNJQVVOQUFzTEN3TUFBUXViQmdJS2Z3OTlJQVJCQkU0RVFDQUVRUU5ySVF3Z0EwRjhjU0VMSUFOQkEyc2hEU0FEUVFSSUlRNERRQ0FCSUFsQkFuUWlDbW9pQlVFTWFpRUhJQVVxQWdnaEVTQUZLZ0lFSVJZZ0JTb0NBQ0VYUXdBQUFBQWhGRU1BQUFBQUlSaERBQUFBQUNFWlF3QUFBQUFoRHlBQUlRWkJBQ0VJUXdBQUFBQWhFRU1BQUFBQUlSSkRBQUFBQUNFVFF3QUFBQUFoRlVFQUlRVWdEa1VFUUFOQUlCUWdCaW9DQUNJYUlBY3FBZ0FpRlpTU0lBWXFBZ1FpR3lBSEtnSUVJaENVa2lBR0tnSUlJaHdnQnlvQ0NDSVNsSklnQmlvQ0RDSWRJQWNxQWd3aUU1U1NJUlFnR0NBUklCcVVraUFWSUJ1VWtpQVFJQnlVa2lBU0lCMlVraUVZSUJrZ0ZpQWFsSklnRVNBYmxKSWdGU0FjbEpJZ0VDQWRsSkloR1NBUElCY2dHcFNTSUJZZ0c1U1NJQkVnSEpTU0lCVWdIWlNTSVE4Z0IwRVFhaUVISUFaQkVHb2hCaUFRSVJjZ0V5RVJJQkloRmlBSVFRUnFJZ2dnRFVnTkFBc2dEeUVRSUJraEVpQVlJUk1nQ3lFRkN5QUZRUUZ5SVFnQ2Z5QURJQVZNQkVBZ0JpRUZJQWNNQVFzZ0JrRUVhaUVGSUJRZ0Jpb0NBQ0lQSUFjcUFnQWlGWlNTSVJRZ0V5QVJJQStVa2lFVElCSWdGaUFQbEpJaEVpQVFJQmNnRDVTU0lSQWdCMEVFYWdzaEJ5QUlRUUZxSVFZQ2Z5QURJQWhNQkVBZ0JTRUlJQWNNQVFzZ0JVRUVhaUVJSUJRZ0JTb0NBQ0lQSUFjcUFnQWlGNVNTSVJRZ0V5QVZJQStVa2lFVElCSWdFU0FQbEpJaEVpQVFJQllnRDVTU0lSQWdCMEVFYWdzaEJTQURJQVpLQkVBZ0ZDQUlLZ0lBSWc4Z0JTb0NBSlNTSVJRZ0VpQVZJQStVa2lFU0lCQWdFU0FQbEpJaEVDQVRJQmNnRDVTU0lSTUxJQUlnQ21vZ0VEZ0NBQ0FDSUFwQkJISnFJQkk0QWdBZ0FpQUtRUWh5YWlBVE9BSUFJQUlnQ2tFTWNtb2dGRGdDQUNBSlFRUnFJZ2tnREVnTkFBc0xBa0FnQkNBSlRBMEFJQU5CQUVvRVFBTkFJQUVnQ1VFQ2RDSUlhaUVMUVFBaEJrTUFBQUFBSVJFRFFDQVJJQUFnQmtFQ2RDSUZhaW9DQUNBRklBdHFLZ0lBbEpJaEVTQUdRUUZxSWdZZ0EwY05BQXNnQWlBSWFpQVJPQUlBSUFsQkFXb2lDU0FFUncwQURBSUxBQXNnQWlBSlFRSjBha0VBSUFRZ0NXdEJBblFRQlJvTEM1VUNBZ04vQVgwakFDSUZJUWdnQlVHQUlHc2lCU1FBQW44Z0F3UkFJQVVnQUVHQUlCQUVHaUFEUVFGT0JFQURRQ0FGSUFaQkFuUWlCMm9nQUNBSGFpb0NBQ0FDSUFkcUtnSUFJZ21VT0FJQUlBVWdCa0YvYzBHQUNHcEJBblFpQjJvZ0NTQUFJQWRxS2dJQWxEZ0NBQ0FHUVFGcUlnWWdBMGNOQUFzTElBVWhBQXNnQUFzZ0FDQUJRWUFJSUFScklnTWdCRUVCYWhBelFRQWhBaUFFUVFCT0JFQURRRU1BQUFBQUlRa2dBaUFEYWlJR1FZQUlTQVJBQTBBZ0NTQUFJQVpCQW5ScUtnSUFJQUFnQmlBQ2EwRUNkR29xQWdDVWtpRUpJQVpCQVdvaUJrR0FDRWNOQUFzTElBRWdBa0VDZEdvaUJTQUpJQVVxQWdDU09BSUFJQUlnQkVjaEJTQUNRUUZxSVFJZ0JRMEFDd3NnQ0NRQUM5a0RBZ0YvQ1gwZ0FVRU1haUVESUFFcUFnZ2hDeUFCS2dJRUlRWWdBU29DQUNFRkFuOGdBaW9DRENFSElBSXFBZ2doQ0NBQ0tnSUVJUWtnQWlvQ0FDRUtRUUFoQVFOQUlBSWdBQ29DQUNJRUlBTXFBZ0FpREpRZ0I1SWlCemdDRENBQ0lBc2dCSlFnQ0pJaUNEZ0NDQ0FDSUFZZ0JKUWdDWklpQ1RnQ0JDQUNJQVVnQkpRZ0NwSWlDamdDQUNBQ0lBY2dBQ29DQkNJRUlBTXFBZ1FpQlpTU0lnYzRBZ3dnQWlBSUlBd2dCSlNTSWdnNEFnZ2dBaUFKSUFzZ0JKU1NJZ2s0QWdRZ0FpQUtJQVlnQkpTU0lnbzRBZ0FnQWlBSElBQXFBZ2dpQkNBREtnSUlJZ2FVa2lJSE9BSU1JQUlnQ0NBRklBU1VraUlJT0FJSUlBSWdDU0FNSUFTVWtpSUpPQUlFSUFJZ0NpQUxJQVNVa2lJS09BSUFJQUlnQnlBQUtnSU1JZ1FnQXlvQ0RDSUxsSklpQnpnQ0RDQUNJQWdnQmlBRWxKSWlDRGdDQ0NBQ0lBa2dCU0FFbEpJaUNUZ0NCQ0FDSUFvZ0RDQUVsSklpQ2pnQ0FDQURRUkJxSVFNZ0FFRVFhaUVBSUFGQkJHb2lBVUVWU0EwQUMwRUFDd1JBSUFNcUFnQWhEQ0FDSUFVZ0FDb0NBQ0lGbENBQ0tnSUFramdDQUNBQ0lBWWdCWlFnQWlvQ0JKSTRBZ1FnQWlBTElBV1VJQUlxQWdpU09BSUlJQUlnQlNBTWxDQUNLZ0lNa2pnQ0RDQURRUVJxSVFNZ0FFRUVhaUVBQ3d1b0FnSUdmd1I5SUFFcUFnQWhDaUFBUVFBZ0FrRUNkQkFGSVFRQ1FDQUJLZ0lBUXdBQUFBQmJEUUFnQWtFQUlBSkJBRW9iSVFkQkFTRUZBMEFnQXlBSFJnMEJRUUFoQWtNQUFBQUFJUWtnQXdSQUEwQWdDU0FFSUFKQkFuUnFLZ0lBSUFFZ0F5QUNhMEVDZEdvcUFnQ1VraUVKSUFKQkFXb2lBaUFEUncwQUN3c2dCQ0FEUVFKMGFpQUpJQUVnQTBFQmFpSUFRUUowYWlvQ0FKS01JQXFWSWdrNEFnQWdBd1JBSUFWQkFYWWhDRUVBSVFJRFFDQUVJQUpCQW5ScUlnWWdCaW9DQUNJTElBa2dCQ0FESUFKQmYzTnFRUUowYWlJR0tnSUFJZ3lVa2pnQ0FDQUdJQXdnQ1NBTGxKSTRBZ0FnQWtFQmFpSUNJQWhIRFFBTEN5QUZRUUZxSVFVZ0FDRURJQW9nQ2lBSklBbVVsSk1pQ2lBQktnSUFRMjhTZ3pxVVhVRUJjdzBBQ3dzTHpRZ0JDMzlCZnlFUEFrQWdBVUVBU0EwQUlBUkZEUUJCZkNFUElBRkZEUUFDZnlBQUxRQUFJZzVCZ0FGeEJFQkJnUGNDSUE1QkEzWkJBM0YwUVpBRGJnd0JDMEhBQjBIZ0F5QU9RUWh4R3lBT1FlQUFjVUhnQUVZTkFCcEJ3QllnRGtFRGRrRURjU0lIUVFOR0RRQWFRWUQzQWlBSGRFSGtBRzRMSVF0QkFTRUlJQUJCQVdvaENTQUJRUUZySWdjaENnSkFBa0FDUUFKQUFrQUNRQUpBSUE1QkEzRWlEQTREQXdBQkFnc2dBZ1JBUVFJaENFRUJJUTFCQUNFTUlBY2hDZ3dFQ3lBSFFRRnhEUVlnQkNBSFFRRjJJZ283QVFCQkFpRUlRUUFoREF3RUN5QUJRUUZNQkVBZ0JFSC8vd003QVFCQmZBOExJQWt0QUFBaURFSDhBVThFUUVFQ0lRZ2dBVUVDVEFSQUlBUkIvLzhET3dFQVFYd1BDeUFBTFFBQ1FRSjBJQXhxSVF3TElBUWdERHNCQUNBSElBaHJJZ2NnREVnTkJTQUhJQXhySVFvZ0NDQUphaUVKUVFJaENFRUFJUXdNQVFzZ0FVRUNTQTBFSUFBdEFBRWlEVUUvY1NJSVJRMEVJQWdnQzJ4QmdDMUxEUVFnQUVFQ2FpRUtJQUZCQW1zaEFVRUFJUXdDUUNBTlFjQUFjVVVFUUNBS0lRa01BUXNEUUNBQlFRRklEUVlnREVGK0lBb3RBQUFpQ1NBSlFmOEJSaUlMRzBIL0FYRWlDV29oRENBQklBbEJmM05xSVFFZ0NrRUJhaUlKSVFvZ0N3MEFDeUFCUVFCSURRVUxJQTFCZ0FGeEJFQkJBQ0VOSUFoQkFra0VRQ0FCSWdjaENnd0NDeUFJUVFGcklSRWdBU0lLSVFjRFFDQUVJQTFCQVhScUlSQWdCMEVBVEFSQUlCQkIvLzhET3dFQVFYd1BDMEVCSVFzZ0NTMEFBQ0lCUWZ3QlR3UkFJQWRCQVV3RVFDQVFRZi8vQXpzQkFFRjhEd3RCQWlFTElBa3RBQUZCQW5RZ0FXb2hBUXNnRUNBQk93RUFJQWNnQzJzaUJ5QUJTQTBHSUFrZ0Myb2hDU0FLSUF0cklBRnJJUW9nRFVFQmFpSU5JQkZIRFFBTFFRQWhEU0FLUVFCT0RRRU1CUXRCQVNFTklBSUVRQ0FISVFvZ0FTRUhEQUlMSUFFZ0NHMGlDaUFJYkNBQlJ3MEVJQWhCQWtrTkFpQUlRUUZySVF0QkFDRUhBMEFnQkNBSFFRRjBhaUFLT3dFQUlBZEJBV29pQnlBTFJ3MEFDeUFCSVFjTElBSkZEUUVMSUFRZ0NFRUJkR3BCQW1zaEMwSC8vd01oQVFKL1FYOGdCMEVCU0EwQUdpQUpMUUFBSWdKQi9BRkpCRUFnQWlFQlFRRU1BUXRCZnlBSFFRSklEUUFhSUFrdEFBRkJBblFnQW1vaEFVRUNDeUVDSUFzZ0FUc0JBQ0FCUVJCMFFSQjFJZ3RCQUVnTkFpQUhJQUpySWdjZ0MwZ05BaUFDSUFscUlRa2dEUVJBSUFnZ0Myd2dCMG9OQXlBSVFRSkpEUUlnQkNBQk93RUFRUUVoQVNBSVFRRnJJZ0pCQVVZTkFpQUVJQUpCQVhScUlRY0RRQ0FFSUFGQkFYUnFJQWN2QVFBN0FRQWdBVUVCYWlJQklBSkhEUUFMREFJTElBSWdDMm9nQ2tvTkFnd0JDeUFLUWZzSlNnMEJJQWhCQVhRZ0JHcEJBbXNnQ2pzQkFBc2dCUVJBSUFVZ0NTQUFhellDQUFzZ0NBUkFRUUFoQVFOQUlBa2dCQ0FCUVFGMGFpNEJBR29oQ1NBQlFRRnFJZ0VnQ0VjTkFBc0xJQVlFUUNBR0lBd2dBR3NnQ1dvMkFnQUxJQU1FUUNBRElBNDZBQUFMSUFnaER3c2dEd3RhQVFSL1FRRkJIeUFBWjJ0QkFYVWlBblFoQXdOQUlBQkJBQ0FFUVFGMElBTnFJQUowSWdFZ0FDQUJTU0lCRzJzaEFFRUFJQU1nQVJzZ0JHb2hCQ0FDUVFCS0lRRWdBMEVCZGlFRElBSkJBV3NoQWlBQkRRQUxJQVFMeFFRQ0NIOEVmU01BSVFjQ1FDQURRUUpIRFFBZ0JFRUJSdzBBSUFZcUFnUWhEeUFHS2dJQUlSQWdBa0VCVGdSQUlBQW9BZ1FoQXlBQUtBSUFJUUFnQlNvQ0FDRVJRUUFoQlFOQUlBTWdCVUVDZENJRWFpb0NBQ0VTSUFFZ0JVRURkQ0lIYWlBUUlBQWdCR29xQWdCRFlFS2lEWktTSWhCREFBQUFPSlE0QWdBZ0FTQUhRUVJ5YWlBUElCSkRZRUtpRFpLU0lnOURBQUFBT0pRNEFnQWdFU0FQbENFUElCRWdFSlFoRUNBRlFRRnFJZ1VnQWtjTkFBc0xJQVlnRHpnQ0JDQUdJQkE0QWdBUEN5QURRUUVnQTBFQlNoc2hDeUFDSUFSdElRa2dCeUFDUVFKMFFROXFRWEJ4YXlFS0lBVXFBZ0FoRUVFQUlRY0NRQ0FFUVFKT0JFQURRRUVBSVFVZ0JpQUhRUUowSWdocUlnd3FBZ0FoRHlBQ1FRQktCRUFnQUNBSWFpZ0NBQ0VOQTBBZ0NpQUZRUUowSWc1cUlBOGdEU0FPYWlvQ0FFTmdRcUlOa3BJaUR6Z0NBQ0FRSUErVUlROGdCVUVCYWlJRklBSkhEUUFMQ3lBTUlBODRBZ0FnQ1VFQlRnUkFJQUVnQ0dvaENFRUFJUVVEUUNBSUlBTWdCV3hCQW5ScUlBb2dCQ0FGYkVFQ2RHb3FBZ0JEQUFBQU9KUTRBZ0FnQlVFQmFpSUZJQWxIRFFBTEN5QUhRUUZxSWdjZ0MwY05BQXdDQ3dBTElBSkJBVWdoQ1FOQUlBWWdCMEVDZENJRWFpSUtLZ0lBSVE4Z0NVVUVRQ0FCSUFScUlRZ2dBQ0FFYWlnQ0FDRUVRUUFoQlFOQUlBZ2dBeUFGYkVFQ2RHb2dEeUFFSUFWQkFuUnFLZ0lBUTJCQ29nMlNraUlQUXdBQUFEaVVPQUlBSUJBZ0Q1UWhEeUFGUVFGcUlnVWdBa2NOQUFzTElBb2dEemdDQUNBSFFRRnFJZ2NnQzBjTkFBc0xDMlVBSUFBdEFBQWlBRUdBQVhFRVFDQUJJQUJCQTNaQkEzRjBRWkFEYlE4TElBQkI0QUJ4UWVBQVJnUkFJQUJCQ0hFRVFDQUJRVEp0RHdzZ0FVSGtBRzBQQ3lBQVFRTjJRUU54SWdCQkEwWUVRQ0FCUVR4c1FlZ0hiUThMSUFFZ0FIUkI1QUJ0Qy8wUkFoVi9ISDBnQUNnQ0NDRUpJd0JCSUdzaUVrRUJOZ0lBSUFCQkRHb2hERUVCSVFRRFFDQU1JQU1pQWtFQ2RDSUZRUUp5YWk4QkFDRUdJQklnQWtFQmFpSURRUUowYWlBRUlBVWdER291QVFCc0lnUTJBZ0FnQmtFQlJ3MEFDeUFKUVFBZ0NVRUFTaHNoRmlBRFFRSjBJQUJxTGdFS0lRd0RRQ0FNSVFWQkFDRURRUUVoREFKQUFrQUNRQUpBQWtBZ0FDQUNJZ2tFZnlBSlFRSjBJQUJxTGdFS0lRd2dDVUVCZEFWQkFBdEJBWFJxTGdFTVFRSnJEZ1FBQWdFREJBc2dBU0VDSUJJZ0NVRUNkR29vQWdBaUJrRUJTQTBEQTBBZ0FpQUNLZ0lBSWhnZ0Fpb0NJQ0lYa3pnQ0lDQUNJQmNnR0pJNEFnQWdBaUFDUVNScUtnSUFJaGdnQWlvQ0JDSVhramdDQkNBQ0lCY2dHSk00QWlRZ0FpQUNLZ0lJSWhzZ0Fpb0NLQ0lhSUFKQkxHb3FBZ0FpRjVKRDh3UTFQNVFpR1pNNEFpZ2dBaUFDUVF4cUtnSUFJaGdnRnlBYWswUHpCRFUvbENJWGt6Z0NMQ0FDSUJzZ0daSTRBZ2dnQWlBWElCaVNPQUlNSUFJcUFqQWhHaUFDSUFJcUFoQWlHU0FDUVRScUtnSUFJaGlUT0FJd0lBSWdHaUFDUVJScUtnSUFJaGVTT0FJMElBSWdGeUFha3pnQ0ZDQUNJQmdnR1pJNEFoQWdBaUFDS2dJWUloc2dBa0U4YWlvQ0FDSWFJQUlxQWpnaUY1TkQ4d1ExUDVRaUdaTTRBamdnQWlBQ1FSeHFLZ0lBSWhnZ0dpQVhra1B6QkRXL2xDSVhremdDUENBQ0lCY2dHSkk0QWh3Z0FpQWJJQm1TT0FJWUlBSkJRR3NoQWlBRFFRRnFJZ01nQmtjTkFBc01Bd3NnRWlBSlFRSjBhaWdDQUNFVElBVkJBVVlFUUNBQklRSWdFMEVCU0EwREEwQWdBaUFDS2dJQUlod2dBaW9DRUNJZ2tpSVlJQUlxQWdnaUlTQUNLZ0lZSWgyU0loZVRPQUlRSUFJZ0dDQVhramdDQUNBQ1FSUnFJQUlxQWdRaUdTQUNLZ0lVSWhpU0loNGdBa0VNYWlvQ0FDSWZJQUpCSEdvcUFnQWlGNUlpRzVNNEFnQWdBaUFaSUJpVElob2dJU0Fka3lJWmtqZ0NIQ0FDSUJ3Z0lKTWlHQ0FmSUJlVEloZVRPQUlZSUFJZ0dpQVpremdDRENBQ0lCZ2dGNUk0QWdnZ0FpQWVJQnVTT0FJRUlBSkJJR29oQWlBRFFRRnFJZ01nRTBjTkFBc01Bd3NnRTBFQlNBMENJQVZCQVVnTkFpQUZRUU5zSVE4Z0JVRUJkQ0VRSUJNZ0ZuUWlEVUVEYkNFVUlBMUJBWFFoRlNBQUtBSXdJUVpCQUNFTEEwQWdBU0FMSUF4c1FRTjBhaUVDUVFBaEVTQUdJZ01oQ0NBRElRUURRQ0FDS2dJQUlTUWdBaUFRUVFOMGFpSU9JQWdxQWdBaUtTQU9LZ0lFSWlxVUlBNHFBZ0FpR3lBSUtnSUVJaHFVa2lJcklBSXFBZ1FpTEpJaUlpQUVLZ0lBSWkwZ0FpQUZRUU4wYWlJSEtnSUVJaU9VSUFjcUFnQWlIQ0FFS2dJRUlobVVraUlnSUFNcUFnQWlJU0FDSUE5QkEzUnFJZ29xQWdRaUhaUWdDaW9DQUNJWUlBTXFBZ1FpRjVTU0loNlNJaCtUT0FJRUlBNGdKQ0FiSUNtVUlDb2dHcFNUSWh1U0lob2dIQ0F0bENBaklCbVVreUlaSUJnZ0laUWdIU0FYbEpNaUdKSWlGNU00QWdBZ0FpQWZJQ0tTT0FJRUlBSWdHaUFYa2pnQ0FDQUhJQ3dnSzVNaUdpQVpJQmlUSWhtVE9BSUVJQWNnSkNBYmt5SVlJQ0FnSHBNaUY1STRBZ0FnQ2lBYUlCbVNPQUlFSUFvZ0dDQVhremdDQUNBQ1FRaHFJUUlnQXlBVVFRTjBhaUVESUFnZ0ZVRURkR29oQ0NBRUlBMUJBM1JxSVFRZ0VVRUJhaUlSSUFWSERRQUxJQXRCQVdvaUN5QVRSdzBBQ3d3Q0N5QVNJQWxCQW5ScUtBSUFJZzlCQVVnTkFTQUFLQUl3SWdZZ0R5QVdkQ0lRSUFWc1FRTjBhaW9DQkNFaklBVkJBWFFoRkNBUVFRRjBJUlZCQUNFS0EwQWdBU0FLSUF4c1FRTjBhaUVDSUFZaUNDRUVJQVVoQXdOQUlBSWdCVUVEZEdvaUJ5QUNLZ0lBSUFjcUFnQWlIQ0FFS2dJQUlpQ1VJQWNxQWdRaUlTQUVLZ0lFSWhtVWt5SWRJQUlnRkVFRGRHb2lEU29DQUNJZUlBZ3FBZ0FpSDVRZ0RTb0NCQ0lZSUFncUFnUWlGNVNUSWh1U0locERBQUFBUDVTVE9BSUFJQWNnQWlvQ0JDQWdJQ0dVSUJ3Z0daU1NJaGtnSHlBWWxDQWVJQmVVa2lJWWtpSVhRd0FBQUQrVWt6Z0NCQ0FDSUJvZ0Fpb0NBSkk0QWdBZ0FpQVhJQUlxQWdTU09BSUVJQTBnSXlBWklCaVRsQ0lZSUFjcUFnQ1NPQUlBSUEwZ0J5b0NCQ0FqSUIwZ0c1T1VJaGVUT0FJRUlBY2dCeW9DQUNBWWt6Z0NBQ0FISUJjZ0J5b0NCSkk0QWdRZ0FrRUlhaUVDSUFnZ0ZVRURkR29oQ0NBRUlCQkJBM1JxSVFRZ0EwRUJheUlERFFBTElBcEJBV29pQ2lBUFJ3MEFDd3dCQ3lBU0lBbEJBblJxS0FJQUlnMUJBVWdOQUNBQUtBSXdJZzRnRFNBV2RDSVBJQVZzSWdaQkJIUnFJZ0lxQWdRaEpTQUNLZ0lBSVNZZ0RpQUdRUU4wYWlJQ0tnSUVJU2NnQWlvQ0FDRW9JQVZCQW5RaEVDQUZRUU5zSVJRZ0JVRUJkQ0VWUVFBaEJ3TkFJQVZCQVU0RVFDQUJJQWNnREd4QkEzUnFJZ0lnQlVFRGRHb2hBeUFDSUJWQkEzUnFJUWdnQWlBVVFRTjBhaUVFSUFJZ0VFRURkR29oQzBFQUlSRURRQ0FDS2dJQUlTNGdBaUFDS2dJRUlpOGdEaUFQSUJGc0lncEJCSFJxSWdZcUFnQWlNaUFJS2dJRUlpU1VJQWdxQWdBaUtTQUdLZ0lFSWhxVWtpSXFJQTRnQ2tFWWJHb2lCaW9DQUNJcklBUXFBZ1FpTEpRZ0JDb0NBQ0lpSUFZcUFnUWlHWlNTSWkyU0lqQWdEaUFLUVFOMGFpSUdLZ0lBSWlNZ0F5b0NCQ0ljbENBREtnSUFJaDBnQmlvQ0JDSVlsSklpSUNBT0lBcEJCWFJxSWdZcUFnQWlIaUFMS2dJRUloK1VJQXNxQWdBaUd5QUdLZ0lFSWhlVWtpSWhraUl4a3BJNEFnUWdBaUF1SUNrZ01wUWdKQ0FhbEpNaUdpQWlJQ3VVSUN3Z0daU1RJaG1TSWlJZ0hTQWpsQ0FjSUJpVWt5SVlJQnNnSHBRZ0h5QVhsSk1pRjVJaUhKS1NPQUlBSUFNZ0pTQWFJQm1USWgyVUlDY2dHQ0FYa3lJZWxKSWlIeUF2SUNZZ01KUWdLQ0F4bEpLU0locVNPQUlFSUFNZ0xpQW1JQ0tVSUNnZ0hKU1NraUlaSUNVZ0tpQXRreUlibENBbklDQWdJWk1pR0pTU0loZVRPQUlBSUFzZ0dpQWZremdDQkNBTElCY2dHWkk0QWdBZ0NDQWxJQjZVSUNjZ0haU1RJaG9nTHlBb0lEQ1VJQ1lnTVpTU2tpSVpramdDQkNBSUlDY2dHNVFnSlNBWWxKTWlHQ0F1SUNnZ0lwUWdKaUFjbEpLU0loZVNPQUlBSUFRZ0dTQWFremdDQkNBRUlCY2dHSk00QWdBZ0MwRUlhaUVMSUFSQkNHb2hCQ0FJUVFocUlRZ2dBMEVJYWlFRElBSkJDR29oQWlBUlFRRnFJaEVnQlVjTkFBc0xJQWRCQVdvaUJ5QU5SdzBBQ3dzZ0NVRUJheUVDSUFsQkFFb05BQXNMaEFJQkJuOGpBQ0lFSVFjZ0JDQUJJQUpzSWdoQkFuUkJEMnBCY0hGcklnVWtBQUpBSUFORkJFQWdBa0VCU0EwQklBRkJBVWdOQVVFQUlRUURRQ0FCSUFSc0lRWkJBQ0VEQTBBZ0JTQURJQVpxUVFKMGFpQUFJQUlnQTJ3Z0JHcEJBblJxS2dJQU9BSUFJQU5CQVdvaUF5QUJSdzBBQ3lBRVFRRnFJZ1FnQWtjTkFBc01BUXNnQWtFQlNBMEFJQUZCQVVnTkFDQUNRUUowUWVnNWFpRUdRUUFoQkFOQUlBWWdCRUVDZEdvb0FnQWdBV3doQ1VFQUlRTURRQ0FGSUFNZ0NXcEJBblJxSUFBZ0FpQURiQ0FFYWtFQ2RHb3FBZ0E0QWdBZ0EwRUJhaUlESUFGSERRQUxJQVJCQVdvaUJDQUNSdzBBQ3dzZ0FDQUZJQWhCQW5RUUJCb2dCeVFBQ3d3QUlBQWdBU0FDSUFNUVBndmJBd0VPZnlBRFFRRk9CRUFnQUNnQ0ZDRUlJQUFvQWhBaEJpQUFLQUlNSVFRZ0FDZ0NDQ0VKSUFBb0FnUWhCeUFBS0FJQUlRVURRQ0FCSUFwQkFuUWlDMnBCLy84QklBY2dCU0FDSUFwQkFYUnFMZ0VBUVFwMElnd2dCV3NpQlVILy93TnhRZElOYkVFUWRpQUZRUkIxUWRJTmJHb2lEV29pRGlBSGF5SUhRZi8vQTNGQml2VUFiRUVRZGlBSFFSQjFRWXIxQUd4cUlnOXFJZ1VnQ1dzaUIwSC8vd054UWF1eGZteEJFSFVnQjBFUWRVR3JzWDVzYWlBRmFpSUZRUWwxUVFGcVFRRjFJZ2xCZ0lCK0lBbEJnSUIrU2hzZ0JVSC8rLzhQU2hzN0FRQWdBU0FMUVFKeWFrSC8vd0VnQmlBRUlBd2dCR3NpQkVILy93TnhRY1kxYkVFUWRpQUVRUkIxUWNZMWJHb2lDMm9pRUNBR2F5SUdRZi8vQTNGQnFja0JiRUVRZGlBR1FSQjFRYW5KQVd4cUloRnFJZ1FnQ0dzaUJrSC8vd054UWZheGYyeEJFSFVnQmtFUWRVSDJzWDlzYWlBRWFpSUVRUWwxUVFGcVFRRjFJZ2hCZ0lCK0lBaEJnSUIrU2hzZ0JFSC8rLzhQU2hzN0FRQWdCQ0FHYWlFSUlBVWdCMm9oQ1NBUUlCRnFJUVlnRGlBUGFpRUhJQXNnREdvaEJDQU1JQTFxSVFVZ0NrRUJhaUlLSUFOSERRQUxJQUFnQ0RZQ0ZDQUFJQVkyQWhBZ0FDQUVOZ0lNSUFBZ0NUWUNDQ0FBSUFjMkFnUWdBQ0FGTmdJQUN3dG9BUUovSXdCQkVHc2lBaVFBQWtBQ1FDQUJJQUFvQWdCR0JFQWdBUkFJSUFBb0FnUWhBU0FBRUFnTUFRc2dBQ2dDQkNJRERRRWdBaUFCTmdJQVFlc0lJQUlRSGtFQUlRRUxJQUpCRUdva0FDQUJEd3NnQUNBRElBRVFQellDQkNBQ1FSQnFKQUFnQUF1akVnRVJmeU1BSWdjaEVpQUhJQUFvQXBRQ0lnZ2dBQ2dDakFJaUJHcEJBblJCRDJwQmNIRnJJZ2NrQUNBSElBQkJHR29pRXlBSVFRSjBFQVFoRENBQUtBS29BaUlIUVFScUlSQWdBQ2dDa0FJaER5QUhJUVVEUUNBQUlBd2dDRUVDZEdvZ0FpQUZJQU1nQkNBRElBUklHeUlPRUdjZ0RrRVFkQ0VOQWtBQ1FBSkFBa0FnQUNnQ2xBSWlFVUVTYXc0VEFBTURBd01EQVFNREF3TURBd01EQXdNREFnTUxJQTFCQVVnTkFpQUFLQUtZQWlJR1FSQjBRUkIxSVJSQkFDRUZBMEFnQVVILy93RWdFQ0FGUWYvL0EzRWdGR3hCRUhVaUNrRVNiR29pQkM0QkFDSUpJQXdnQlVFUWRVRUNkR29pQ0NnQ0FDSUxRZi8vQTNGc1FSQjFJQXRCRUhVZ0NXeHFJQVF1QVFJaUNTQUlLQUlFSWd0QkVIVnNhaUFMUWYvL0EzRWdDV3hCRUhWcUlBUXVBUVFpQ1NBSUtBSUlJZ3RCRUhWc2FpQUxRZi8vQTNFZ0NXeEJFSFZxSUFRdUFRWWlDU0FJS0FJTUlndEJFSFZzYWlBTFFmLy9BM0VnQ1d4QkVIVnFJQVF1QVFnaUNTQUlLQUlRSWd0QkVIVnNhaUFMUWYvL0EzRWdDV3hCRUhWcUlBUXVBUW9pQ1NBSUtBSVVJZ3RCRUhWc2FpQUxRZi8vQTNFZ0NXeEJFSFZxSUFRdUFRd2lDU0FJS0FJWUlndEJFSFZzYWlBTFFmLy9BM0VnQ1d4QkVIVnFJQVF1QVE0aUNTQUlLQUljSWd0QkVIVnNhaUFMUWYvL0EzRWdDV3hCRUhWcUlBUXVBUkFpQkNBSUtBSWdJZ2xCRUhWc2FpQUpRZi8vQTNFZ0JHeEJFSFZxSUJBZ0JpQUtRWDl6YWtFU2JHb2lCQzRCQUNJS0lBZ29Ba1FpQ1VFUWRXeHFJQWxCLy84RGNTQUtiRUVRZFdvZ0JDNEJBaUlLSUFnb0FrQWlDVUVRZFd4cUlBbEIvLzhEY1NBS2JFRVFkV29nQkM0QkJDSUtJQWdvQWp3aUNVRVFkV3hxSUFsQi8vOERjU0FLYkVFUWRXb2dCQzRCQmlJS0lBZ29BamdpQ1VFUWRXeHFJQWxCLy84RGNTQUtiRUVRZFdvZ0JDNEJDQ0lLSUFnb0FqUWlDVUVRZFd4cUlBbEIvLzhEY1NBS2JFRVFkV29nQkM0QkNpSUtJQWdvQWpBaUNVRVFkV3hxSUFsQi8vOERjU0FLYkVFUWRXb2dCQzRCRENJS0lBZ29BaXdpQ1VFUWRXeHFJQWxCLy84RGNTQUtiRUVRZFdvZ0JDNEJEaUlLSUFnb0FpZ2lDVUVRZFd4cUlBbEIvLzhEY1NBS2JFRVFkV29nQkM0QkVDSUVJQWdvQWlRaUNFRVFkV3hxSUFoQi8vOERjU0FFYkVFUWRXb2lDRUVGZFVFQmFrRUJkU0lFUVlDQWZpQUVRWUNBZmtvYklBaEIzLy8vQUVvYk93RUFJQUZCQW1vaEFTQUZJQTlxSWdVZ0RVZ05BQXNNQWd0QkFDRUlJQTFCQUV3TkFRTkFJQUZCLy84QklBY3VBUVFpQkNBTUlBaEJFSFZCQW5ScUlnVW9BbHdnQlNnQ0FHb2lCa0gvL3dOeGJFRVFkU0FHUVJCMUlBUnNhaUFITGdFR0lnUWdCU2dDV0NBRktBSUVhaUlHUVJCMWJHb2dCa0gvL3dOeElBUnNRUkIxYWlBSExnRUlJZ1FnQlNnQ1ZDQUZLQUlJYWlJR1FSQjFiR29nQmtILy93TnhJQVJzUVJCMWFpQUhMZ0VLSWdRZ0JTZ0NVQ0FGS0FJTWFpSUdRUkIxYkdvZ0JrSC8vd054SUFSc1FSQjFhaUFITGdFTUlnUWdCU2dDVENBRktBSVFhaUlHUVJCMWJHb2dCa0gvL3dOeElBUnNRUkIxYWlBSExnRU9JZ1FnQlNnQ1NDQUZLQUlVYWlJR1FSQjFiR29nQmtILy93TnhJQVJzUVJCMWFpQUhMZ0VRSWdRZ0JTZ0NSQ0FGS0FJWWFpSUdRUkIxYkdvZ0JrSC8vd054SUFSc1FSQjFhaUFITGdFU0lnUWdCU2dDUUNBRktBSWNhaUlHUVJCMWJHb2dCa0gvL3dOeElBUnNRUkIxYWlBSExnRVVJZ1FnQlNnQ1BDQUZLQUlnYWlJR1FSQjFiR29nQmtILy93TnhJQVJzUVJCMWFpQUhMZ0VXSWdRZ0JTZ0NPQ0FGS0FJa2FpSUdRUkIxYkdvZ0JrSC8vd054SUFSc1FSQjFhaUFITGdFWUlnUWdCU2dDTkNBRktBSW9haUlHUVJCMWJHb2dCa0gvL3dOeElBUnNRUkIxYWlBSExnRWFJZ1FnQlNnQ01DQUZLQUlzYWlJRlFSQjFiR29nQlVILy93TnhJQVJzUVJCMWFpSUZRUVYxUVFGcVFRRjFJZ1JCZ0lCK0lBUkJnSUIrU2hzZ0JVSGYvLzhBU2hzN0FRQWdBVUVDYWlFQklBZ2dEMm9pQ0NBTlNBMEFDd3dCQzBFQUlRZ2dEVUVBVEEwQUEwQWdBVUgvL3dFZ0J5NEJCQ0lFSUF3Z0NFRVFkVUVDZEdvaUJTZ0NqQUVnQlNnQ0FHb2lCa0gvL3dOeGJFRVFkU0FHUVJCMUlBUnNhaUFITGdFR0lnUWdCU2dDaUFFZ0JTZ0NCR29pQmtFUWRXeHFJQVpCLy84RGNTQUViRUVRZFdvZ0J5NEJDQ0lFSUFVb0FvUUJJQVVvQWdocUlnWkJFSFZzYWlBR1FmLy9BM0VnQkd4QkVIVnFJQWN1QVFvaUJDQUZLQUtBQVNBRktBSU1haUlHUVJCMWJHb2dCa0gvL3dOeElBUnNRUkIxYWlBSExnRU1JZ1FnQlNnQ2ZDQUZLQUlRYWlJR1FSQjFiR29nQmtILy93TnhJQVJzUVJCMWFpQUhMZ0VPSWdRZ0JTZ0NlQ0FGS0FJVWFpSUdRUkIxYkdvZ0JrSC8vd054SUFSc1FSQjFhaUFITGdFUUlnUWdCU2dDZENBRktBSVlhaUlHUVJCMWJHb2dCa0gvL3dOeElBUnNRUkIxYWlBSExnRVNJZ1FnQlNnQ2NDQUZLQUljYWlJR1FSQjFiR29nQmtILy93TnhJQVJzUVJCMWFpQUhMZ0VVSWdRZ0JTZ0NiQ0FGS0FJZ2FpSUdRUkIxYkdvZ0JrSC8vd054SUFSc1FSQjFhaUFITGdFV0lnUWdCU2dDYUNBRktBSWthaUlHUVJCMWJHb2dCa0gvL3dOeElBUnNRUkIxYWlBSExnRVlJZ1FnQlNnQ1pDQUZLQUlvYWlJR1FSQjFiR29nQmtILy93TnhJQVJzUVJCMWFpQUhMZ0VhSWdRZ0JTZ0NZQ0FGS0FJc2FpSUdRUkIxYkdvZ0JrSC8vd054SUFSc1FSQjFhaUFITGdFY0lnUWdCU2dDWENBRktBSXdhaUlHUVJCMWJHb2dCa0gvL3dOeElBUnNRUkIxYWlBSExnRWVJZ1FnQlNnQ1dDQUZLQUkwYWlJR1FSQjFiR29nQmtILy93TnhJQVJzUVJCMWFpQUhMZ0VnSWdRZ0JTZ0NWQ0FGS0FJNGFpSUdRUkIxYkdvZ0JrSC8vd054SUFSc1FSQjFhaUFITGdFaUlnUWdCU2dDVUNBRktBSThhaUlHUVJCMWJHb2dCa0gvL3dOeElBUnNRUkIxYWlBSExnRWtJZ1FnQlNnQ1RDQUZLQUpBYWlJR1FSQjFiR29nQmtILy93TnhJQVJzUVJCMWFpQUhMZ0VtSWdRZ0JTZ0NTQ0FGS0FKRWFpSUZRUkIxYkdvZ0JVSC8vd054SUFSc1FSQjFhaUlGUVFWMVFRRnFRUUYxSWdSQmdJQitJQVJCZ0lCK1Noc2dCVUhmLy84QVNoczdBUUFnQVVFQ2FpRUJJQWdnRDJvaUNDQU5TQTBBQ3dzZ0F5QU9heUlEUVFKT0JFQWdEQ0FNSUE1QkFuUnFJQkZCQW5RUUJCb2dBaUFPUVFGMGFpRUNJQUFvQXFnQ0lRVWdBQ2dDbEFJaENDQUFLQUtNQWlFRURBRUxDeUFUSUF3Z0RrRUNkR29nRVVFQ2RCQUVHaUFTSkFBTG1BTUJDbjhqQUNJRklRa2dCU0FBS0FLTUFpSUVRUUowUVI5cVFYQnhheUlGSkFBZ0JTQUFLUUlnTndJSUlBVWdBQ2tDR0RjQ0FDQUZRUkJxSVFvZ0FDZ0NrQUloQ3dOQUlBQWdDaUFDSUFNZ0JDQURJQVJJR3lJSEVENUJBQ0VJSUFkQkVYUWlERUVCVGdSQUEwQWdBVUgvL3dFZ0NFSC8vd054UVF4c1FSQjJJZzFCQTNSQjhBMXFJZ1l1QVFJZ0JTQUlRUkIxUVFGMGFpSUVMZ0VDYkNBR0xnRUFJQVF1QVFCc2FpQUdMZ0VFSUFRdUFRUnNhaUFHTGdFR0lBUXVBUVpzYWtFQUlBMXJRUU4wUWNnT2FpSUdMZ0VHSUFRdUFRaHNhaUFHTGdFRUlBUXVBUXBzYWlBR0xnRUNJQVF1QVF4c2FpQUdMZ0VBSUFRdUFRNXNhaUlFUVE1MVFRRnFRUUYxSWdaQmdJQitJQVpCZ0lCK1Noc2dCRUgvLy83L0Ewb2JPd0VBSUFGQkFtb2hBU0FJSUF0cUlnZ2dERWdOQUFzTElBTWdCMnNpQTBFQlRnUkFJQVVnQlNBSFFRSjBhaUlFS1FJQU53SUFJQVVnQkNrQ0NEY0NDQ0FDSUFkQkFYUnFJUUlnQUNnQ2pBSWhCQXdCQ3dzZ0FDQUZJQWRCQW5ScUlnRXBBZ0EzQWhnZ0FDQUJLUUlJTndJZ0lBa2tBQXVkQWdFQ2Z5QUFRYWdCYWlJRklBQW9BcVFDSWdSQkFYUnFJQUlnQUNnQ25BSWdCR3RCQVhRaUJCQUVHZ0pBQWtBQ1FBSkFBa0FnQUNnQ2lBSkJBV3NPQXdBQkFnTUxJQUFnQVNBRklBQW9BcHdDRUQwZ0FDQUJJQUFvQXFBQ1FRRjBhaUFDSUFScUlBTWdBQ2dDbkFKckVEME1Bd3NnQUNBQklBVWdBQ2dDbkFJUVFTQUFJQUVnQUNnQ29BSkJBWFJxSUFJZ0JHb2dBeUFBS0FLY0Ftc1FRUXdDQ3lBQUlBRWdCU0FBS0FLY0FoQkFJQUFnQVNBQUtBS2dBa0VCZEdvZ0FpQUVhaUFESUFBb0Fwd0NheEJBREFFTElBRWdCU0FBS0FLY0FrRUJkQkFFSUFBb0FxQUNRUUYwYWlBQ0lBUnFJQU1nQUNnQ25BSnJRUUYwRUFRYUN5QUZJQUlnQXlBQUtBS2tBaUlBYTBFQmRHb2dBRUVCZEJBRUdrRUFDOHdYQVF0L0l3QkJrQVZySWc4a0FDQVBJZ3BCQURZQ2pBVWdDa0lBTndPQUJTQUJLQUlFSVFnQ1FDQURSUTBBSUFoQkFVZ05BQU5BSUFBZ0NVR29JV3hxUVFBMkF0UVNJQWxCQVdvaUNTQUlSdzBBQ3dzZ0FDZ0M0RUlnQ0VnRVFDQUFRYWdoYWhBbUlRMGdBU2dDQkNFSUN3SkFJQWhCQVVjTkFDQUFLQUxnUWtFQ1J3MEFJQUVvQWd3Z0FDZ0NqQkpCNkFkc1JpRVNDd0pBQWtBZ0FDZ0MxQklOQUNBSVFRRklEUUJCQUNFSkEwQkJBaUVEUVFFaERrRzFmaUVMQWtBQ1FBSkFBa0FnQVNnQ0VDSU1EaFVEQmdZR0JnWUdCZ1lHQXdZR0JnWUdCZ1lHQmdFQUN5QU1RU2hHRFFFZ0RFRThSdzBGUVFRaEEwRURJUTRNQWd0QkJDRUREQUVMUVFRaEEwRUNJUTRMSUFBZ0NVR29JV3hxSWd3Z0F6WUNsQklnRENBT05nTFlFa0c0ZmlFTElBRW9BZ3hCQ25VaUEwRVBTdzBDUVFFZ0EzUkJnSkVDY1VVTkFpQU1JQU5CQVdvZ0FTZ0NDQkJySUExcUlRMGdDVUVCYWlJSklBRW9BZ1FpQ0VnTkFBc0xRUUloQ1FKQUlBRW9BZ0FpQTBFQ1J3UkFJQU1oQ1F3QkN5QUlRUUpIRFFBZ0FDZ0MzRUpCQVVjRVFFRUNJUWdnQUNnQzRFSkJBVWNOQVFzZ0FFRUFOZ0xZUWlBQVFRQTJBdEJDSUFCQnFEUnFJQUJCZ0JOcVFhd0NFQVFhSUFFb0FnUWhDQ0FCS0FJQUlRa0xJQUFnQ0RZQzRFSWdBQ0FKTmdMY1FrRzRmaUVMSUFFb0FnaEJ3RDVyUWNDNEFrc05BQUpBSUFKQkFVWU5BQ0FBS0FMVUVnMEFBa0FnQ0VFQlNBMEFRUUFoRGdOQVFRQWhDQ0FBSUE1QnFDRnNhaUlNS0FMWUVrRUFTZ1JBSUF4QjJCSnFJUU1EUUNBTUlBaEJBblJxUWVRU2FpQUVRUUVRQmpZQ0FDQUlRUUZxSWdnZ0F5Z0NBRWdOQUFzTElBd2dCRUVCRUFZMkF2QVNJQTVCQVdvaURpQUJLQUlFSWdoSURRQUxRUUFoQ3lBSVFRQk1EUUFEUUNBQUlBdEJxQ0ZzYWlJSlFnQTNBdlFTSUFsQi9CSnFRUUEyQWdBQ1FDQUpLQUx3RWtVTkFDQUpLQUxZRWlJRFFRRkdCRUFnQ1VIMEVtcEJBVFlDQUF3QkN5QUVJQU5CQW5SQjBEQnFLQUlBUVFnUUF5RURJQWxCMkJKcUtBSUFJZ3hCQVVnTkFDQURRUUZxSVFOQkFDRUlBMEFnQ1NBSVFRSjBha0gwRW1vZ0F5QUlka0VCY1RZQ0FDQUlRUUZxSWdnZ0RFZ05BQXNMSUF0QkFXb2lDeUFCS0FJRUlnaElEUUFMQ3lBQ0RRQWdBQ2dDMkJKQkFVZ05BQ0FBUVp3MGFpRU9RUUFoQ3dOQUFrQWdDRUVCU0EwQUlBNGdDMEVDZENJTWFpRVJRUUFoQ1NBTEJFQWdDMEVCYXlFREEwQWdBQ0FKUWFnaGJHb2lFQ0FNYWtIMEVtb29BZ0FFUUFKQUlBa05BQ0FJUVFKSERRQWdCQ0FLUVlBRmFoQWJJQkVvQWdBTkFDQUVJQXBCakFWcUVDVUxJQkFnQkNBTFFRRWdFQ0FEUVFKMGFrSDBFbW9vQWdCQkFFZEJBWFFRS0NBRUlBb2dFRUhORldvc0FBQWdFRUhPRldvc0FBQWdFQ2dDbUJJUUp5QUJLQUlFSVFnTElBbEJBV29pQ1NBSVNBMEFDd3dCQ3dOQUlBQWdDVUdvSVd4cUlnTW9BdlFTQkVBQ1FDQUpEUUFnQ0VFQ1J3MEFJQVFnQ2tHQUJXb1FHeUFSS0FJQURRQWdCQ0FLUVl3RmFoQWxDeUFESUFSQkFFRUJRUUFRS0NBRUlBb2dBMEhORldvc0FBQWdBMEhPRldvc0FBQWdBeWdDbUJJUUp5QUJLQUlFSVFnTElBbEJBV29pQ1NBSVNBMEFDd3NnQzBFQmFpSUxJQUFvQXRnU1NBMEFDd3NDUUNBSVFRSkhEUUFDUUFKQUFrQUNRQUpBQWtBZ0FnNERBQUlCQWdzZ0JDQUtRWUFGYWhBYklBQWdBQ2dDMUJKQkFuUnFRWXcwYWlnQ0FFVU5Bd3dFQ3lBQUlBQW9BdFFTUVFKMGFrSDBFbW9vQWdCQkFVWU5BUXNnQ2lBQUxnSFFRallDZ0FVZ0NpQUFMZ0hTUWpZQ2hBVU1Bd3NnQkNBS1FZQUZhaEFiSUFBZ0FDZ0MxQkpCQW5ScVFadzBhaWdDQUEwQkN5QUVJQXBCakFWcUVDVU1BUXNnQ2tFQU5nS01CUXNDUUNBQktBSUVJZ2hCQWtjTkFDQUtLQUtNQlEwQVFRSWhDQ0FBS0FMa1FrRUJSdzBBSUFCQnJDdHFRUUJCZ0FnUUJSb2dBRUVBTmdMc1FTQUFRUW82QUxBeklBQkI1QUEyQXF3eklBQkJBVFlDOERNZ0FTZ0NCQ0VJQ3dKL0lBZ2dBU2dDREd3Z0FTZ0NBQ0FCS0FJSWJFNGlFVVVFUUNBRklRd2dBRUdZRW1vTUFRc2dDaUFBS0FLWUVrRUNhaUFJYkVFQmRFRVBha0Z3Y1dzaURDSVBKQUFnQUVHWUVtb0xLQUlBSVFOQkFTRUlJQW9nRERZQ0FDQUtJQXdnQTBFQmRHcEJCR29pRGpZQ0JBSkFBa0FDUUFKQUFrQUNRQUpBQWtBZ0FrVUVRQ0FLS0FLTUJVVWhDQXdCQ3lBQUtBTGtRa1VOQUNBQktBSUVJUU1nQWtFQ1J3MEJJQU5CQWtjTkFTQUFJQUFvQXZ3elFRSjBha0djTkdvb0FnQkJBVVloQ0FzZ0FTZ0NCRUVBU2cwQkRBVUxJQU5CQVVnTkJDQUNRUUpIRFFFTUFnc2dDQVJBUVFFaENDQUFLQUxVRWlJTFFRQktRUUYwSVFNQ1FDQUxRUUZJRFFBZ0FrRUNSdzBBSUF0QkFuUWdBR3BCOEJKcUtBSUFRUUJIUVFGMElRTUxJQUFnQkNBS0tBSUFRUVJxSUFwQmlBVnFJQUlnQXhBY0lRTWdBQ0FBS0FMVUVrRUJhallDMUJJZ0F5QU5haUVOSUFFb0FnUWlDVUVDU0EwREEwQUNmMEVBSUFBb0F0UVNJQWhySWd0QkFVZ05BQm9nQWtFQ1J3UkFRUUZCQWlBQUtBTGtRaHNNQVFzZ0FDQUlRYWdoYkdvZ0MwRUNkR3BCOEJKcUtBSUFRUUJIUVFGMEN5RURJQUFnQ0VHb0lXeHFJZ3NnQkNBS0lBaEJBblJxS0FJQVFRUnFJQXBCaUFWcUlBSWdBeEFjSVFNZ0N5QUxLQUxVRWtFQmFqWUMxQklnQXlBTmFpRU5JQWhCQVdvaUNDQUJLQUlFSWdsSURRQUxEQU1MSUFKQkFrWU5BUXNnQUNBRUlBeEJCR29nQ2tHSUJXb2dBaUFBS0FMVUVrRUFTa0VCZEJBY0lRTWdBQ0FBS0FMVUVrRUJhallDMUJJZ0F5QU5haUVOSUFFb0FnUWlDVUVDU0EwQklBb29Bb2dGUVFGMElRUkJBU0VJQTBBZ0NpQUlRUUowYWlnQ0FFRUVha0VBSUFRUUJSb2dBQ0FJUWFnaGJHb2lBeUFES0FMVUVrRUJhallDMUJJZ0NFRUJhaUlJSUFFb0FnUWlDVWdOQUFzTUFRc2dBQ0FFSUF4QkJHb2dDa0dJQldwQkFnSi9RUUFnQUNnQzFCSWlBMEVCU0EwQUdpQURRUUowSUFCcVFmQVNhaWdDQUVFQVIwRUJkQXNRSENFRElBQWdBQ2dDMUJKQkFXbzJBdFFTSUFNZ0RXb2hEU0FCS0FJRUlnbEJBa2dOQUNBS0tBS0lCVUVCZENFRVFRRWhDQU5BSUFvZ0NFRUNkR29vQWdCQkJHcEJBQ0FFRUFVYUlBQWdDRUdvSVd4cUlnTWdBeWdDMUJKQkFXbzJBdFFTSUFoQkFXb2lDQ0FCS0FJRUlnbElEUUFMQ3lBSlFRSkhEUUFnQVNnQ0FFRUNSdzBBSUFCQjBNSUFhaUFNSUE0Z0NrR0FCV29nQUNnQ2pCSWdDaWdDaUFVUVpDQUtLQUtJQlNFRURBRUxJQXdnQUNnQzFFSTJBUUFnQUNBTUlBb29Bb2dGSWdSQkFYUnFLQUVBTmdMVVFnc2dCaUFCS0FJSUlBUnNJQUF1QVl3U1FlZ0hiRzBpQXpZQ0FDQVBJQU5CQVNBQktBSUFJZ3RCQWtZaUNSdEJBWFJCRDJwQmNIRnJJZzhpQXlRQUlBRW9BZ1FoQ0NBUlJRUkFJQU1nQUNnQ21CSWlCMEVDYWlBSWJFRUJkQ0lEUVE5cVFYQnhheUlNSkFBZ0NpQU1JQVVnQXhBRUlnTWdCMEVCZEdwQkJHbzJBZ1FnQ2lBRE5nSUFDeUFQSUFVZ0NSc2hEd0pBSUFzZ0NDQUlJQXRLRzBFQlNBMEFRUUFoQ1NBTUlRZ0RRQ0FBSUFsQnFDRnNha0dBRTJvZ0R5QUlRUUpxSUFRUVFpRUhBa0FnQVNnQ0FDSUxRUUpIRFFCQkFDRUlJQVlvQWdBaUJFRUJTQTBBQTBBZ0JTQUlRUUYwSWdNZ0NXcEJBWFJxSUFNZ0Qyb3ZBUUE3QVFBZ0NFRUJhaUlJSUFSSERRQUxDeUFISUExcUlRMGdDVUVCYWlJSklBc2dBU2dDQkNJSUlBZ2dDMG9iVGcwQklBb2dDVUVDZEdvb0FnQWhDQ0FLS0FLSUJTRUVEQUFMQUFzQ1FBSkFBa0FnQzBFQ1J3MEFJQWhCQVVjTkFDQVNEUUZCQUNFSUlBWW9BZ0FpQkVFQVRBMEFBMEFnQlNBSVFRSjBJZ05CQW5KcUlBTWdCV292QVFBN0FRQWdDRUVCYWlJSUlBUkhEUUFMQ3lBTklRc01BUXNnQUVHb05Hb2dEeUFNUVFKcUlBb29Bb2dGRUVJZ0RXb2hDeUFHS0FJQUlnTkJBVWdOQUVFQUlRZ0RRQ0FGSUFoQkFuUkJBbkpxSUE4Z0NFRUJkR292QVFBN0FRQWdDRUVCYWlJSUlBTkhEUUFMQzBFQUlRZ2dBU0FBS0FMRUlFRUNSZ1IvSUFBb0Fvd1NRUWhyUVh4eFFiZ0phaWdDQUNBQUtBS0VFbXdGUVFBTE5nSVVBa0FnQWtFQlJnUkFJQUFvQXVCQ0lnRkJBVWdOQVFOQUlBQWdDRUdvSVd4cVFRbzZBSWdTSUFoQkFXb2lDQ0FCUncwQUN3d0JDeUFBSUFvb0Fvd0ZOZ0xrUWdzTElBcEJrQVZxSkFBZ0N3c3hBUUYvSUFBUUpob2dBRUdvSVdvUUppRUJJQUJCMk1JQWFrRUFOZ0lBSUFCQ0FEY0MwRUlnQUVFQU5nTGtRaUFCQy93RUFRZC9JQUFvQW93U0lnUWdBRUdjSVdvb0FnQkhCRUFnQUNBRU5nS2NJU0FBUVpRaGFrS0FnSVNBZ0lEQUFEY0NBQ0FBUWFBaGFrS0NnSUNBd0FJM0FnQWdBQ0FBS0FLWUVrRUhkRFlDekNBTElBTUVRQ0FBSUFFZ0FoQjBJQUFnQUNnQ3dDQkJBV28yQXNBZ0R3c2dBQ0FBUWMwVmFpd0FBQ0lDTmdMRUlBSkFJQUpCQWtZRVFFRUFJUU1DUUNBQUtBS1VFaUlDUlEwQUlBSkJBblFnQVdwQkJHc2lDU2dDQUNJR1FRRklEUUFnQUVIUUlHb2hCeUFBS0FLY0VpRUtBMEFnQXlBQklBSWdCVUYvYzJvaUNFRUtiR29pQkM0QllpQUVMZ0ZnYWlBRUxnRmthaUFFTGdGbWFpQUVMZ0ZvYWlJRVNBUkFJQWNnQVNBSVFSQjBRUkIxUVFwc2FpSURMd0ZvT3dFSUlBY2dBeWtCWURjQkFDQUFJQUVnQ0VFQ2RHb29BZ0JCQ0hRMkFzd2dJQWtvQWdBaEJpQUVJUU1MSUFWQkFXb2lCU0FDUmcwQklBVWdDbXdnQmtnTkFBc0xJQUJCMENCcUlnUkNBRGNDQUNBQVFkZ2dha0VBT3dFQUlBQkIxQ0JxSUFNN0FRQWdBMEhNMlFCTUJFQWdBRUhXSUdwQkFEWUJBQ0FFUVFBMkFRQWdBRUdBNk13RklBTkJBU0FEUVFGS0cyNUJFSFJCRUhVZ0EwRVFkRUVRZFd4QkNuWTdBZFFnREFJTElBTkJ6dmtBU0EwQklBQkIxaUJxUVFBMkFRQWdBRUhRSUdwQkFEWUJBQ0FBUVlDQXpma0FJQU51SUFOQkVIUkJFSFZzUVE1Mk93SFVJQXdCQ3lBQVFkQWdha0lBTndJQUlBQkIyQ0JxUVFBN0FRQWdBQ0FFUVJCMFFSQjFRWUFrYkRZQ3pDQWdBQ2dDbEJJaEFnc2dBRUhhSUdvZ0FVRkFheUFBS0FLa0VrRUJkQkFFR2lBQVFaQWhhaUFCS0FLSUFUc0JBQ0FBUVpRaGFpQUNRUUowSUFGcUtRSUlOd0lBSUFCQnBDRnFJQUFvQXB3U05nSUFJQUJCb0NGcUlBSTJBZ0FMdlFFQkEzOGdBaTRCQWlJRVFRRk9CRUFnQWlnQ0dDQUVRZi8vQTNFZ0EyeEJBbTFxSVFSQkFDRURBMEFnQUNBRFFRRjBhaUFFTFFBQUlnVkJBWFpCQjNGQkNXdzdBUUFnQVNBRGFpQUNLQUlVSUFJdUFRSkJBV3NnQlVFQmNXd2dBMnBxTFFBQU9nQUFJQUFnQTBFQmNpSUdRUUYwYWlBRlFRVjJRUWxzT3dFQUlBRWdCbW9nQWlnQ0ZDQUdJQUl1QVFKQkFXc2dCVUVFZGtFQmNXeHFhaTBBQURvQUFDQUVRUUZxSVFRZ0EwRUNhaUlESUFJdUFRSklEUUFMQ3d2TEF3RUhmd0pBSUFNZ0JFd05BQ0FFUVFkT0JFQWdCQ0VHQTBBZ0FpNEJBaUFHUVFGMElnc2dBV29pQlVFRWF5NEJBR3dnQWk0QkFDQUZRUUpySWdrdUFRQnNhaUFDTGdFRUlBVkJCbXN1QVFCc2FpQUNMZ0VHSUFWQkNHc3VBUUJzYWlBQ0xnRUlJQVZCQ21zdUFRQnNhaUFDTGdFS0lBVkJER3N1QVFCc2FpRUlRUVloQndOQUlBZ2dBaUFIUVFGMElncHFMZ0VBSUFrZ0Ntc3VBUUJzYWlBQ0lBcEJBbkpxTGdFQUlBa2dCMEYvYzBFQmRHb3VBUUJzYWlFSUlBZEJBbW9pQnlBRVNBMEFDeUFBSUF0cUlBVXVBUUJCREhRZ0NHdEJDM1ZCQVdwQkFYVWlCVUdBZ0g0Z0JVR0FnSDVLR3lJRlFmLy9BU0FGUWYvL0FVZ2JPd0VBSUFaQkFXb2lCaUFEUncwQUN3d0JDeUFFSVFZRFFDQUFJQVpCQVhRaUJXb2dBU0FGYWlJRkxnRUFRUXgwSUFJdUFRSWdCVUVFYXk0QkFHd2dBaTRCQUNBRlFRSnJMZ0VBYkdvZ0FpNEJCQ0FGUVFackxnRUFiR29nQWk0QkJpQUZRUWhyTGdFQWJHb2dBaTRCQ0NBRlFRcHJMZ0VBYkdvZ0FpNEJDaUFGUVF4ckxnRUFiR3ByUVF0MVFRRnFRUUYxSWdWQmdJQitJQVZCZ0lCK1Noc2lCVUgvL3dFZ0JVSC8vd0ZJR3pzQkFDQUdRUUZxSWdZZ0EwY05BQXNMSUFCQkFDQUVRUUYwRUFVYUMwb0JBWDlCQUNBQ1FRRnFJQUpCQUVnYklnSWdBQ2dDQUNJRFNBUkFJQUFvQWdnZ0FXb2hBUU5BSUFBZ0Ftb3RBQXdnQVVZRVFDQUNEd3NnQWtFQmFpSUNJQU5JRFFBTEMwRi9DMG9CQVg5QkFDQUNRUUZxSUFKQkFFZ2JJZ0lnQUNnQ0FDSURTQVJBSUFGQkFYUkJBWEloQVFOQUlBQWdBbW90QUF3Z0FVWUVRQ0FDRHdzZ0FrRUJhaUlDSUFOSURRQUxDMEYvQzBjQkFYOUJBQ0FDUVFGcUlBSkJBRWdiSWdJZ0FDZ0NBQ0lEU0FSQUlBRkJBWFFoQVFOQUlBQWdBbW90QUF3Z0FVWUVRQ0FDRHdzZ0FrRUJhaUlDSUFOSURRQUxDMEYvQzdzQ0FBSkFJQUZCRkVzTkFBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFJQUZCQ1dzT0NnQUJBZ01FQlFZSENBa0tDeUFDSUFJb0FnQWlBVUVFYWpZQ0FDQUFJQUVvQWdBMkFnQVBDeUFDSUFJb0FnQWlBVUVFYWpZQ0FDQUFJQUUwQWdBM0F3QVBDeUFDSUFJb0FnQWlBVUVFYWpZQ0FDQUFJQUUxQWdBM0F3QVBDeUFDSUFJb0FnQkJCMnBCZUhFaUFVRUlhallDQUNBQUlBRXBBd0EzQXdBUEN5QUNJQUlvQWdBaUFVRUVhallDQUNBQUlBRXlBUUEzQXdBUEN5QUNJQUlvQWdBaUFVRUVhallDQUNBQUlBRXpBUUEzQXdBUEN5QUNJQUlvQWdBaUFVRUVhallDQUNBQUlBRXdBQUEzQXdBUEN5QUNJQUlvQWdBaUFVRUVhallDQUNBQUlBRXhBQUEzQXdBUEN5QUNJQUlvQWdCQkIycEJlSEVpQVVFSWFqWUNBQ0FBSUFFckF3QTVBd0FQQ3lBQUlBSkJBQkVHQUFzTFNnRURmeUFBS0FJQUxBQUFRVEJyUVFwSkJFQURRQ0FBS0FJQUlnRXNBQUFoQXlBQUlBRkJBV28yQWdBZ0F5QUNRUXBzYWtFd2F5RUNJQUVzQUFGQk1HdEJDa2tOQUFzTElBSUxFZ0FnQUVVRVFFRUFEd3NnQUNBQkVJNEJDL0VEQVFaL0l3QkI4QUJySWdna0FFRi9JUWNDUUFKQUFrQWdBVVVOQUNBQ1JRMEFEQUVMSUFRZ0FDZ0NERUdRQTIxdkRRRUxJQUZCQUNBQ0cwVUVRRUVBSVFJRFFDQUFRUUJCQUNBRElBQW9BZ2dnQW14QkFuUnFJQVFnQW1zUUV5SUhRUUJJSWdFTkFpQUNJQUlnQjJvaUJ5QUJHeUVCSUFjaEFpQUJJQVJJRFFBTElBQWdBVFlDU0F3QkN5QUNRUUJJRFFBQ1FDQUJMUUFBSWdkQmdBRnhCRUFnQjBFRmRrRURjU0lIUWM0SWFrSE5DQ0FIR3lFS1Flb0hJUWtNQVFzQ2Z5QUhRZUFBY1VIZ0FFWUVRRUhwQnlFSlFkRUlRZEFJSUFkQkVIRWJEQUVMUWVnSElRa2dCMEVGZGtFRGNVSE5DR29MSVFvTElBRWdBQ2dDREJBNklRc2dBUzBBQUNFTUlBRWdBaUFGSUFoQjZ3QnFJQWdnQ0VIc0FHb2dCaEEzSWdWQkFFZ0VRQ0FGSVFjTUFRc2dBU0FJS0FKc2FpRUJRWDRoQnlBRklBdHNJQVJLRFFBZ0FDQUxOZ0pBSUFBZ0NqWUNOQ0FBSUFrMkFqZ2dBRUVDUVFFZ0RFRUVjUnMyQWpBQ1FDQUZRUUZJQkVCQkFDRUhEQUVMUVFBaEFrRUFJUWNEUUNBQUlBRWdDQ0FDUVFGMGFpSUpMZ0VBSUFNZ0FDZ0NDQ0FIYkVFQ2RHb2dCQ0FIYXhBVElnWkJBRWdFUUNBR0lRY01Bd3NnQmlBSGFpRUhJQUVnQ1M0QkFHb2hBU0FDUVFGcUlnSWdCVWNOQUFzTElBQWdCellDU0NBQVFnQTNBa3dMSUFoQjhBQnFKQUFnQnd0N0FRSjhJQUFnQUtJaUFpQUNJQUtpb2lBQ1JIelZ6MW82MmVVOW9rVHJuQ3VLNXVWYXZxQ2lJQUlnQWtSOS9yRlg0eDNIUHFKRTFXSEJHYUFCS3IrZ29rU20rQkFSRVJHQlA2Q2dJUU1nQUNBQ0lBRkVBQUFBQUFBQTREK2lJQUlnQUtJaUFDQURvcUdpSUFHaElBQkVTVlZWVlZWVnhUK2lvS0VMdmdFQkFuOGpBRUVRYXlJQkpBQUNmQ0FBdlVJZ2lLZEIvLy8vL3dkeElnSkIrOE9rL3dOTkJFQkVBQUFBQUFBQThEOGdBa0dld1pyeUEwa05BUm9nQUVRQUFBQUFBQUFBQUJBdERBRUxJQUFnQUtFZ0FrR0FnTUQvQjA4TkFCb0NRQUpBQWtBQ1FDQUFJQUVRbEFGQkEzRU9Bd0FCQWdNTElBRXJBd0FnQVNzRENCQXREQU1MSUFFckF3QWdBU3NEQ0JCUG1nd0NDeUFCS3dNQUlBRXJBd2dRTFpvTUFRc2dBU3NEQUNBQkt3TUlFRThMSVFBZ0FVRVFhaVFBSUFBTCt3RUJCWDhnQWtFQmF5SURRWUFDVHdSQUlBQWdBVUVZSUFObmF5SUZkaUlDSUFKQkFXb2dBeUFGZGtFQmFoQWhRWDhnQlhSQmYzTWdBWEVoQmlBQUtBSU1JUUlDUUNBQUtBSVFJZ0VnQldvaUJFRWhTUVJBSUFFaEF3d0JDd05BUVg4aEJDQUFJQUFvQWdRaUF5QUFLQUlJSWdjZ0FDZ0NHR3BMQkg4Z0FDQUhRUUZxSWdRMkFnZ2dBQ2dDQUNBRElBUnJhaUFDT2dBQVFRQUZRWDhMSUFBb0FpeHlOZ0lzSUFKQkNIWWhBaUFCUVE5S0lRUWdBVUVJYXlJRElRRWdCQTBBQ3lBRElBVnFJUVFMSUFBZ0JEWUNFQ0FBSUFZZ0EzUWdBbkkyQWd3Z0FDQUFLQUlVSUFWcU5nSVVEd3NnQUNBQklBRkJBV29nQWhBaEN6Z0JBWDhnQUNBQUtBSWNJQUZ1SWdJMkFpUWdBQ2dDSUNBQ2JpSUFRWDl6SUFGcVFRQWdBRUVCYWlJQUlBRnJJZ0VnQUNBQlNSdHFDL29DQVFaL0lBQkNnSUNBZ0lBUU53SVlJQUJDZ0lDQWdKQUJOd0lRSUFCQ0FEY0NDQ0FBSUFJMkFnUWdBQ0FCTmdJQUlBSUVRQ0FBUVFFMkFoZ2dBUzBBQUNFRVFRRWhBd3NnQUVFQU5nSXNJQUFnQkRZQ0tDQUFRWUNBQWpZQ0hDQUFRUkUyQWhRZ0FDQUVRUUYyUWY4QWN5SUdOZ0lnQWtBZ0FpQURUUVJBSUFNaEJRd0JDeUFBSUFOQkFXb2lCVFlDR0NBQklBTnFMUUFBSVFjTElBQWdCellDS0NBQVFZQ0FnQVEyQWh3Z0FFRVpOZ0lVSUFBZ0J5QUVRUWgwY2tFQmRrSC9BWEVnQmtFSWRISkIvd0Z6SWdnMkFpQkJBQ0VESUFBQ2Z5QUNJQVZOQkVBZ0JTRUdRUUFNQVFzZ0FDQUZRUUZxSWdZMkFoZ2dBU0FGYWkwQUFBc2lCRFlDS0NBQVFZQ0FnSUI0TmdJY0lBQkJJVFlDRkNBQUlBUWdCMEVJZEhKQkFYWkIvd0Z4SUFoQkNIUnlRZjhCY3lJRk5nSWdJQUlnQmtzRVFDQUFJQVpCQVdvMkFoZ2dBU0FHYWkwQUFDRURDeUFBSUFNMkFpZ2dBQ0FESUFSQkNIUnlRUUYyUWY4QmNTQUZRUWgwY2tIL0FYTTJBaUFMMUFJQkJuOENRQ0FCSUFKT0RRQWdDRUVCSUFoQkFVb2JJUXNDUUNBR0lBaElEUUFnQVNFS0EwQUNRQ0FFSUFwQkFuUWlDV29pRENnQ0FFRUhTZzBBSUFVZ0NXb29BZ0FOQUVFQUlRa0RRQ0FIUVFFUUNTRU5JQU1nQUNnQ0NDQUpiQ0FLYWtFQ2RHb2lEaUFPS2dJQUlBMnlRd0FBQUwrU1FRRkJEU0FNS0FJQWEzU3lsRU1BQUlBNGxKSTRBZ0FnQ1VFQmFpSUpJQXRIRFFBTElBWWdDMnNoQmdzZ0NrRUJhaUlLSUFKT0RRRWdCaUFJVGcwQUN3c2dCaUFJU0EwQUEwQUNRQ0FFSUFGQkFuUWlDbW9pRENnQ0FFRUhTZzBBUVFBaENTQUZJQXBxS0FJQVFRRkhEUUFEUUNBSFFRRVFDU0VLSUFNZ0FDZ0NDQ0FKYkNBQmFrRUNkR29pRFNBTktnSUFJQXF5UXdBQUFMK1NRUUZCRFNBTUtBSUFhM1N5bEVNQUFJQTRsSkk0QWdBZ0NVRUJhaUlKSUF0SERRQUxJQVlnQzJzaEJnc2dBVUVCYWlJQklBSk9EUUVnQmlBSVRnMEFDd3NMbkFjQ0NYOEdmU01BSWdNaENpQURRYkFLYXlJRUlnTWtBQ0FEUWFBUGF5SUdJZ01rQUNBRFFlQUpheUlISkFCQkFDRURBMEFnQkNBRFFRSjBhaUFBSUFOQkEzUnFLZ0lBT0FJQUlBTkJBV29pQTBITUFrY05BQXRCQUNFREEwQWdCaUFEUVFKMGFpQUJJQU5CQTNScUtnSUFPQUlBSUFOQkFXb2lBMEhuQTBjTkFBc2dCQ0FHSUFkQnpBSkJtd0VRTTBNQUFJQS9JUXhCQUNFREEwQWdEQ0FHSUFOQkFuUnFLZ0lBSWc0Z0RwU1NJUXdnQTBFQmFpSURRY3dDUncwQUMwTUFBSUMvSVJGQkFTRUVRUUFoQTBNQUFJQy9JUTREUUFKQUlBY2dBMEVDZENJSmFpb0NBQ0lOUXdBQUFBQmVRUUZ6RFFBZ0VDQU5ROHk4akN1VUlnMGdEWlFpRFpRZ0RpQU1sRjVCQVhNTkFDQVBJQTJVSUJFZ0RKUmVCRUFnQlNFRUlBTWhCU0FSSVE0Z0RTRVJJQThoRUNBTUlROE1BUXNnQXlFRUlBMGhEaUFNSVJBTElBd2dCaUFEUWN3Q2FrRUNkR29xQWdBaURDQU1sQ0FHSUFscUtnSUFJZ3dnREpTVGtrTUFBSUEvbHlFTUlBTkJBV29pQTBHYkFVY05BQXRCQUNBRVFRRjBheUVMUVFBZ0JVRUJkR3NoQmdOQUlBY2dDRUVDZENJRWFpSUpRUUEyQWdBQ1FDQUdJQWhxSWdNZ0EwRWZkU0lEYWlBRGMwRURUd1JBSUFnZ0Myb2lBeUFEUVI5MUlnTnFJQU56UVFKTERRRUxJQUVnQkdvaEJVRUFJUU5EQUFBQUFDRU1BMEFnRENBQUlBTkJBblFpQkdvcUFnQWdCQ0FGYWlvQ0FKU1NJUXdnQTBFQmFpSURRWmdGUncwQUN5QUpJQXhEQUFDQXY1YzRBZ0FMSUFoQkFXb2lDRUcyQWtjTkFBdERBQUNBUHlFTVFRQWhBd05BSUF3Z0FTQURRUUowYWlvQ0FDSVBJQStVa2lFTUlBTkJBV29pQTBHWUJVY05BQXRCQUNFRlF3QUFnTDhoRVVNQUFBQUFJUTlCQUNFQVFRQWhBME1BQUFBQUlSQkRBQUNBdnlFT0EwQUNRQ0FISUFOQkFuUWlCR29xQWdBaURVTUFBQUFBWGtFQmN3MEFJQkFnRFVQTXZJd3JsQ0lOSUEyVUlnMlVJQTRnREpSZVFRRnpEUUFnRHlBTmxDQVJJQXlVWGdSQUlBTWhBQ0FSSVE0Z0RTRVJJQThoRUNBTUlROE1BUXNnRFNFT0lBd2hFQXNnRENBQklBTkJtQVZxUVFKMGFpb0NBQ0lNSUF5VUlBRWdCR29xQWdBaURDQU1sSk9TUXdBQWdEK1hJUXdnQTBFQmFpSURRYllDUncwQUN3SkFJQUJCQVVnTkFDQUFRYlVDVGcwQUlBY2dBRUVDZEdvaUFTb0NCQ0lPSUFGQkJHc3FBZ0FpRUpNZ0FTb0NBQ0lQSUJDVFF6TXpNeitVWGdSQVFYOGhCUXdCQ3lBUUlBNlRJQThnRHBORE16TXpQNVJlUlEwQVFRRWhCUXNnQWlBRklBQkJBWFJxTmdJQUlBb2tBQXYyQkFJRmZ3dDlJd0JCTUdzaUJDUUFJQUFvQWdBaEJrRUJJUVVEUUNBQklBVkJBblJxSUFWQkEzUWlCeUFHYWlJSUtnSUFJQWhCQkdzcUFnQWdCaUFIUVFSeWFpb0NBSkpEQUFBQVA1U1NRd0FBQUQrVU9BSUFJQVZCQVdvaUJVR0FDRWNOQUFzZ0FTQUdLZ0lFUXdBQUFEK1VJQVlxQWdDU1F3QUFBRCtVSWdrNEFnQWdBa0VDUmdSQUlBQW9BZ1FoQUVFQklRVURRQ0FCSUFWQkFuUnFJZ0lnQWlvQ0FDQUZRUU4wSWdJZ0FHb2lCaW9DQUNBR1FRUnJLZ0lBSUFBZ0FrRUVjbW9xQWdDU1F3QUFBRCtVa2tNQUFBQS9sSkk0QWdBZ0JVRUJhaUlGUVlBSVJ3MEFDeUFCSUFrZ0FDb0NCRU1BQUFBL2xDQUFLZ0lBa2tNQUFBQS9sSkk0QWdBTFFRQWhCU0FCSUFSQkVHcEJBRUVBUVFRZ0F4QTBJQVFnQkNvQ0VFTkhBNEEvbERnQ0VDQUVJQVFxQWhRaUNTQUpRMjhTQXp5VVEyOFNBenlVa3pnQ0ZDQUVJQVFxQWhnaUNTQUpRMjhTZ3p5VVEyOFNnenlVa3pnQ0dDQUVJQVFxQWh3aUNTQUpRNmFieER5VVE2YWJ4RHlVa3pnQ0hDQUVJQVFxQWlBaUNTQUpRMjhTQXoyVVEyOFNBejJVa3pnQ0lDQUVJQVJCRUdwQkJCQTJJQVFxQWd4REt2WW5QNVFpQ1NBRUtnSUlRNzJmT2orVUlncER6Y3hNUDVTU0lRMGdDaUFFS2dJRVF5aGNUeitVSWdwRHpjeE1QNVNTSVE0Z0NpQUVLZ0lBUTJabVpqK1VJZ3BEemN4TVA1U1NJUThnQ1VQTnpFdy9sQ0VRSUFwRHpjeE1QNUloRVVNQUFBQUFJUWxEQUFBQUFDRUtBMEFnQVNBRlFRSjBhaUlBSUJBZ0VwUWdEU0FMbENBT0lBeVVJQThnQ1pRZ0VTQUtsQ0FBS2dJQUloT1NrcEtTa2pnQ0FDQUxJUklnRENFTElBa2hEQ0FLSVFrZ0V5RUtJQVZCQVdvaUJVR0FDRWNOQUFzZ0JFRXdhaVFBQyswRUFnWi9BWDBnQXlBQ1FRRnFJZ01nQVNBQklBSktJZ1ViUVFKMFFZQ3hBV29vQWdBZ0FTQURJQUVnQTBvYlFRSjBhaWdDQUNBQklBSWdBU0FDU0J0QkFuUkJnTEVCYWlnQ0FDQUJJQUlnQlJ0QkFuUnFLQUlBYWhBV0lRUWdBVUVEVGdSQUEwQUNmeUFCSWdVZ0Frd0VRQ0FDSVFNQ1FDQUZRUUowSWdaQmdMRUJhaWdDQUNJSUlBWnFLQUlBSUFRZ0FrRUNkQ0FJYWlnQ0JDSUhRWDlCQUNBRUlBZFBHeUlIY1dzaUJFc0VRQU5BSUFGQkFXc2lBVUVDZEVHQXNRRnFLQUlBSUFacUtBSUFJZ2tnQkVzTkFBd0NDd0FMQTBBZ0F5SUJRUUZySVFNZ0NDQUJRUUowYWlnQ0FDSUpJQVJMRFFBTEN5QUFJQUlnQjJvZ0FXc2dCM05CRUhSQkVIVWlBallDQUNBS0lBS3lJZ29nQ3BTU0lRb2dBU0VDSUFRZ0NXc01BUXNnQlVFQ2RDSURJQUpCQVdvaUNFRUNkRUdBc1FGcUtBSUFhaWdDQUNFQkFrQWdCQ0FDUVFKMFFZQ3hBV29vQWdBZ0Eyb29BZ0FpQmtrTkFDQUJJQVJORFFBZ0FFRUFOZ0lBSUFRZ0Jtc01BUXNnQkNBQlFYOUJBQ0FCSUFSTkd5SUVjV3NoQmdOQUlBWWdBaUlCUVFGcklnSkJBblJCZ0xFQmFpZ0NBQ0FEYWlnQ0FDSUhTUTBBQ3lBQUlBUWdDR29nQVdzZ0JITkJFSFJCRUhVaUFUWUNBQ0FLSUFHeUlnb2dDcFNTSVFvZ0JpQUhhd3NoQkNBRlFRRnJJUUVnQUVFRWFpRUFJQVZCQTBvTkFBc0xJQUFnQWlBRUlBSkJBWFJCQVhJaUFVOGlBbXNnQkNBQlFYOUJBQ0FDR3lJQ2NXc2lBMEVCYWlJRlFRRjJJZ0ZySUFKelFSQjBRUkIxSWdJMkFnQWdBQ0FCSUFNZ0JVRitjVUVCYTBFQUlBRWJheUlBYTBFQUlBQnJjMEVRZEVFUWRTSUFOZ0lFSUFvZ0FySWlDaUFLbEpJZ0FMSWlDaUFLbEpJTG5RSUJCbjhnQUNBQlFRRnJJZ2hCQW5ScUtBSUFJZ2NnQjBFZmRTSUVhaUFFY3lFRUlBZEJIM1loQlFOQUlBRWdDRUVCYXlJSGF5SUdJQVFnQkNBR1NodEJBblJCZ0xFQmFpZ0NBQ0FHSUFRZ0JDQUdTQnRCQW5ScUtBSUFJQVZxSVFVZ0JDQUFJQWRCQW5ScUtBSUFJZ2tnQ1VFZmRTSUVhaUFFYzJvaEJDQUpRWDlNQkVBZ0JTQUVRUUZxSWdVZ0JpQUVJQVpJRzBFQ2RFR0FzUUZxS0FJQUlBWWdCU0FGSUFaSUcwRUNkR29vQWdCcUlRVUxJQWhCQVVvaEJpQUhJUWdnQmcwQUN5QURJQVVnQWtFQmFpSUFJQUVnQVNBQ1NpSURHMEVDZEVHQXNRRnFLQUlBSUFFZ0FDQUFJQUZJRzBFQ2RHb29BZ0FnQVNBQ0lBRWdBa2diUVFKMFFZQ3hBV29vQWdBZ0FTQUNJQU1iUVFKMGFpZ0NBR29RVVF2N0JBSUpmd045SXdCQkVHc2lCU0VISUFVa0FDQUZRZUFBYXlJSklnVWtBQ0FGSUFOQkdHb2lCa0VDZEVFUGFrRndjV3NpQ0NRQUlBWUNmMEVBSWdWQkFBMEFHZ05BSUFrZ0JVRUNkR29nQVNBRlFYOXpRUmhxUVFKMGFpb0NBRGdDQUNBRlFRRnFJZ1ZCR0VjTkFBdEJBQ0lGUVFBTkFCb0RRQ0FJSUFWQkFuUnFJQVFnQlVGL2MwRVlha0VDZEdvcUFnQ01PQUlBSUFWQkFXb2lCVUVZUncwQUMwRVlDeUlGU2dSQUlBZ2dCVUVDZEdwQkFDQUdJQVZyUVFKMEVBVWFDMEVBSVFZZ0EwRUVUZ1JBSUFOQkEyc2hDd05BSUFjZ0FDQUdRUUowSWdWcUtnSUFPQUlBSUFjZ0FDQUZRUVJ5SWd4cUtnSUFPQUlFSUFjZ0FDQUZRUWh5SWcxcUtnSUFPQUlJSUFjZ0FDQUZRUXh5SWc1cUtnSUFPQUlNSUFrZ0JTQUlhaUFIRURVZ0NDQUdRUmhxUVFKMGFpSUtJQWNxQWdBaUQ0dzRBZ0FnQWlBRmFpQVBPQUlBSUFvZ0J5b0NCQ0FQSUFFcUFnQ1VreUlRakRnQ0JDQUNJQXhxSUJBNEFnQWdDaUFIS2dJSUlCQWdBU29DQUpTVElBOGdBU29DQkpTVEloR01PQUlJSUFJZ0RXb2dFVGdDQUNBS0lBY3FBZ3dnRVNBQktnSUFsSk1nRUNBQktnSUVsSk1nRHlBQktnSUlsSk1pRDR3NEFnd2dBaUFPYWlBUE9BSUFJQVpCQkdvaUJpQUxTQTBBQ3dzZ0F5QUdTZ1JBQTBBZ0FDQUdRUUowSWdGcUtnSUFJUTlCQUNFRkEwQWdEeUFKSUFWQkFuUnFLZ0lBSUFnZ0JTQUdha0VDZEdvcUFnQ1VreUVQSUFWQkFXb2lCVUVZUncwQUN5QUlJQVpCR0dwQkFuUnFJQTg0QWdBZ0FTQUNhaUFQT0FJQUlBWkJBV29pQmlBRFJ3MEFDd3RCQUNFRkEwQWdCQ0FGUVFKMGFpQUNJQVZCZjNNZ0EycEJBblJxS2dJQU9BSUFJQVZCQVdvaUJVRVlSdzBBQ3lBSFFSQnFKQUFMNkFJQ0IzOEJmU01BUVJCcklnVWhCQ0FGSkFBZ0JVSGdBR3NpQmlRQVFRQWhCUU5BSUFZZ0JVRUNkR29nQVNBRlFYOXpRUmhxUVFKMGFpb0NBRGdDQUNBRlFRRnFJZ1ZCR0VjTkFBdEJBQ0VCSUFOQkJFNEVRQ0FEUVFOcklRY0RRQ0FFSUFBZ0FVRUNkQ0lGYWlJSUtnSUFPQUlBSUFRZ0FDQUZRUVJ5SWdscUtnSUFPQUlFSUFRZ0FDQUZRUWh5SWdwcUtnSUFPQUlJSUFRZ0FDQUZRUXh5SWd0cUtnSUFPQUlNSUFZZ0NFSGdBR3NnQkJBMUlBSWdCV29nQkNvQ0FEZ0NBQ0FDSUFscUlBUXFBZ1E0QWdBZ0FpQUthaUFFS2dJSU9BSUFJQUlnQzJvZ0JDb0NERGdDQUNBQlFRUnFJZ0VnQjBnTkFBc0xJQUVnQTBnRVFBTkFJQUZCR0dzaEJ5QUFJQUZCQW5RaUNHb3FBZ0FoREVFQUlRVURRQ0FNSUFZZ0JVRUNkR29xQWdBZ0FDQUZJQWRxUVFKMGFpb0NBSlNTSVF3Z0JVRUJhaUlGUVJoSERRQUxJQUlnQ0dvZ0REZ0NBQ0FCUVFGcUlnRWdBMGNOQUFzTElBUkJFR29rQUF1ZkdRSTFmd1Y5SXdCQjRDRnJJZ1loQXlBR0pBQWdBQ2dDQ0NJSVFRRWdDRUVCU2hzaEZVRUFJQUZySVJFZ0FDZ0NBQ0lLS0FJRUlnbEJnQkJxSVFRZ0NpZ0NJQ0VTSUFvb0FnZ2hDd05BSUFWQkFuUWlCeUFEUWRnaGFtb2dBQ0FFSUFWc1FRSjBha0hjQUdvaUV6WUNBQ0FEUWRBaGFpQUhhaUFUSUJGQkFuUnFRWUJBYXpZQ0FDQUZRUUZxSWdVZ0ZVY05BQXNnQUNBRUlBaHNRUUowYWtIY0FHb2hEQ0FBS0FJVUlRUUNRQUpBQWtBZ0FDZ0NOQ0lUUVFSS0RRQWdCQTBBSUFBb0FqaEZEUUVMSUF3Z0NFSGdBR3hxSVE0Z0JDQUFLQUlZSWdjZ0NpZ0NEQ0lGSUFVZ0Iwb2JJZ3hLSVJFZ0JpQUJJQWhzUVFKMFFROXFRWEJ4YXlJUEpBQWdCQ0FIU0FSQUlBNGdDMEVEZENJRmFpQUZhaUFGYWlFTlF3QUFBRDlEQUFEQVB5QVRHeUU0UVFBaEJnTkFJQVlnQzJ3aEZDQUVJUVVEUUNBT0lBVWdGR3BCQW5RaUZtb2lGeUFOSUJacUtnSUFJamtnRnlvQ0FDQTRreUk2SURrZ09sNGJPQUlBSUFWQkFXb2lCU0FIUncwQUN5QUdRUUZxSWdZZ0ZVY05BQXNMSUFRZ0RDQVJHeUVSSUFBb0FpZ2hCZ0pBSUFoQkFVZ05BQ0FFSUF4T0RRQkJBQ0VMQTBBZ0FTQUxiQ0VVSUFRaEJ3TkFRUUFoQlNBU0lBZEJBWFJxTGdFQUlnMGdBblFnRkdvaERDQVNJQWRCQVdvaUIwRUJkR291QVFBZ0RXc2dBblFpRFVFQVNnUkFBMEFnRHlBRklBeHFRUUowYWlBR1FZM001UUJzUWQvbXUrTURhaUlHUVJSMXNqZ0NBQ0FGUVFGcUlnVWdEVWNOQUFzTElBOGdERUVDZEdvZ0RVTUFBSUEvSUFBb0FpUVFMaUFISUJGSERRQUxJQXRCQVdvaUN5QUlSdzBBQ3dzZ0FDQUdOZ0lvSUFsQkFYWWdBV3RCQW5SQmdFQnJJUVpCQUNFRkEwQWdBMEhZSVdvZ0JVRUNkR29vQWdBaUNTQUpJQUZCQW5ScUlBWVFEaG9nQlVFQmFpSUZJQlZIRFFBTElBb2dEeUFEUWRBaGFpQU9JQVFnRVNBSUlBaEJBQ0FDSUFBb0FoQkJBQ0FBS0FJa0VDSU1BUXNDZlNBVFJRUkFJQU5CMkNGcUlBTkI4QUJxSUFnZ0FDZ0NKQkJXSUFOQmtBeHFJQU5COEFCcUlBTVFWU0FBUWRBRklBTW9BZ0JySWdJMkFqQkRBQUNBUHd3QkN5QUFLQUl3SVFKRHpjeE1Qd3NoUENBQ1FRRjBJZ1JCZ0FnZ0JFR0FDRWdiSWdkQmZ5QUhRWDlLR3lJRVFRRWdCRUVCU0JzZ0IwRUFJQWRySWdRZ0JDQUhTQnRCQVhac0lnUkJBU0FFUVFGS0d5RVpJQVlnQ1VFQ2RFRVBha0Z3Y1dzaUVpSUVKQUJCZ0FnZ0Iyc2hHa0dBQ0NBSFFRRjFheUViSUFNZ0IwRUNkQ0lOYTBIUUlXb2hGQ0FKUVFKdElSeEJnQWdnQW1zaEhTQUJJQWxxSWdoQkFuUWhIa0dBRUNBQmF5SU9RUUowSVJZZ0JDQU5RUTlxUVhCeGF5SVhKQUFnQTBIUUFXb2hEeUFLS0FJOElRdEIvdzhnQVd0QkFuUWhIMEgrRHlBQmEwRUNkQ0VnUWYwUElBRnJRUUowSVNGQi9BOGdBV3RCQW5RaElrSDdEeUFCYTBFQ2RDRWpRZm9QSUFGclFRSjBJU1JCK1E4Z0FXdEJBblFoSlVINER5QUJhMEVDZENFbVFmY1BJQUZyUVFKMElTZEI5ZzhnQVd0QkFuUWhLRUgxRHlBQmEwRUNkQ0VwUWZRUElBRnJRUUowSVNwQjh3OGdBV3RCQW5RaEswSHlEeUFCYTBFQ2RDRXNRZkVQSUFGclFRSjBJUzFCOEE4Z0FXdEJBblFoTGtIdkR5QUJhMEVDZENFdlFlNFBJQUZyUVFKMElUQkI3UThnQVd0QkFuUWhNVUhzRHlBQmEwRUNkQ0V5UWVzUElBRnJRUUowSVROQjZnOGdBV3RCQW5RaE5FSHBEeUFCYTBFQ2RDRTFRZWdQSUFGclFRSjBJVFpCQUNFS0EwQWdBMEhZSVdvZ0NrRUNkR29vQWdBaEJFRUFJUVVEUUNBRlFRSjBJZ1lnQTBId0FHcHFJQVFnQm1wQm9COXFLZ0lBT0FJQUlBVkJBV29pQlVHWUNFY05BQXNDUUNBVEJFQWdDa0VZYkNFRkRBRUxJQThnQXlBTElBbEJHQ0FBS0FJa0VEUWdBeUFES2dJQVEwY0RnRCtVT0FJQUlBTWdBeW9DQkNJNElEaER2amVHT0pTVE9BSUVJQU1nQXlvQ0NDSTRJRGhEdmplR09KUWlPQ0E0a2lJNElEaVNremdDQ0NBRElBTXFBZ3dpT0NBNFE3NDNoamlVUXdBQVFFQ1VRd0FBUUVDVWt6Z0NEQ0FESUFNcUFoQWlPQ0E0UTc0M2hqaVVRd0FBZ0VDVVF3QUFnRUNVa3pnQ0VDQURJQU1xQWhRaU9DQTRRNzQzaGppVVF3QUFvRUNVUXdBQW9FQ1VremdDRkNBRElBTXFBaGdpT0NBNFE3NDNoamlVUXdBQXdFQ1VRd0FBd0VDVWt6Z0NHQ0FESUFNcUFod2lPQ0E0UTc0M2hqaVVRd0FBNEVDVVF3QUE0RUNVa3pnQ0hDQURJQU1xQWlBaU9DQTRRNzQzaGppVVF3QUFBRUdVUXdBQUFFR1VremdDSUNBRElBTXFBaVFpT0NBNFE3NDNoamlVUXdBQUVFR1VRd0FBRUVHVWt6Z0NKQ0FESUFNcUFpZ2lPQ0E0UTc0M2hqaVVRd0FBSUVHVVF3QUFJRUdVa3pnQ0tDQURJQU1xQWl3aU9DQTRRNzQzaGppVVF3QUFNRUdVUXdBQU1FR1VremdDTENBRElBTXFBakFpT0NBNFE3NDNoamlVUXdBQVFFR1VRd0FBUUVHVWt6Z0NNQ0FESUFNcUFqUWlPQ0E0UTc0M2hqaVVRd0FBVUVHVVF3QUFVRUdVa3pnQ05DQURJQU1xQWpnaU9DQTRRNzQzaGppVVF3QUFZRUdVUXdBQVlFR1VremdDT0NBRElBTXFBandpT0NBNFE3NDNoamlVUXdBQWNFR1VRd0FBY0VHVWt6Z0NQQ0FESUFNcUFrQWlPQ0E0UTc0M2hqaVVRd0FBZ0VHVVF3QUFnRUdVa3pnQ1FDQURJQU1xQWtRaU9DQTRRNzQzaGppVVF3QUFpRUdVUXdBQWlFR1VremdDUkNBRElBTXFBa2dpT0NBNFE3NDNoamlVUXdBQWtFR1VRd0FBa0VHVWt6Z0NTQ0FESUFNcUFrd2lPQ0E0UTc0M2hqaVVRd0FBbUVHVVF3QUFtRUdVa3pnQ1RDQURJQU1xQWxBaU9DQTRRNzQzaGppVVF3QUFvRUdVUXdBQW9FR1VremdDVUNBRElBTXFBbFFpT0NBNFE3NDNoamlVUXdBQXFFR1VRd0FBcUVHVWt6Z0NWQ0FESUFNcUFsZ2lPQ0E0UTc0M2hqaVVRd0FBc0VHVVF3QUFzRUdVa3pnQ1dDQURJQU1xQWx3aU9DQTRRNzQzaGppVVF3QUF1RUdVUXdBQXVFR1VremdDWENBRElBTXFBbUFpT0NBNFE3NDNoamlVUXdBQXdFR1VRd0FBd0VHVWt6Z0NZQ0FNSUFwQkdHd2lCVUVDZEdvZ0EwRVlFRFlMSUJRZ0RDQUZRUUowYWlJM0lCY2dCeUFBS0FJa0VGb2dGQ0FYSUEwUUJCcERBQUNBUHlFNFFRQWhCVU1BQUlBL0lUc2dBa0VCVGdSQUEwQWdPQ0FQSUFVZ0dtcEJBblJxS2dJQUlqZ2dPSlNTSVRnZ095QVBJQVVnRzJwQkFuUnFLZ0lBSWprZ09aU1NJVHNnQlVFQmFpSUZJQmxIRFFBTEN5QUVJQVFnQVVFQ2RHb2dGaEFPSVFSREFBQUFBQ0U2UXdBQUFBQWhPU0FJUVFGSUloQkZCRUFnUENBN0lEZ2dPQ0E3WGhzZ09KV1JJanVVSVRoQkFDRUdRUUFoQlFOQUlBUWdCaUFPYWtFQ2RHb2dPQ0E3SURpVUlBSWdCVW9pR0JzaU9DQVBJQVZCQUNBQ0lCZ2JheUlGSUIxcUloaEJBblJxS2dJQWxEZ0NBQ0FGUVFGcUlRVWdPU0FZSUFGclFRSjBJQVJxUVlBZ2Fpb0NBQ0k1SURtVWtpRTVJQVpCQVdvaUJpQUlSdzBBQ3dzZ0F5QUVJQjlxS2dJQU9BSUFJQU1nQkNBZ2Fpb0NBRGdDQkNBRElBUWdJV29xQWdBNEFnZ2dBeUFFSUNKcUtnSUFPQUlNSUFNZ0JDQWphaW9DQURnQ0VDQURJQVFnSkdvcUFnQTRBaFFnQXlBRUlDVnFLZ0lBT0FJWUlBTWdCQ0FtYWlvQ0FEZ0NIQ0FESUFRZ0oyb3FBZ0E0QWlBZ0F5QUVJQ2hxS2dJQU9BSWtJQU1nQkNBcGFpb0NBRGdDS0NBRElBUWdLbW9xQWdBNEFpd2dBeUFFSUN0cUtnSUFPQUl3SUFNZ0JDQXNhaW9DQURnQ05DQURJQVFnTFdvcUFnQTRBamdnQXlBRUlDNXFLZ0lBT0FJOElBTWdCQ0F2YWlvQ0FEZ0NRQ0FESUFRZ01Hb3FBZ0E0QWtRZ0F5QUVJREZxS2dJQU9BSklJQU1nQkNBeWFpb0NBRGdDVENBRElBUWdNMm9xQWdBNEFsQWdBeUFFSURScUtnSUFPQUpVSUFNZ0JDQTFhaW9DQURnQ1dDQURJQVFnTm1vcUFnQTRBbHdnQkVHQVFHc2lCU0FSUVFKMGFpSUdJRGNnQmlBSUlBTWdBQ2dDSkJCWlFRQWhCZ0pBQWtBZ0VFVUVRQU5BSURvZ0JDQUdJQTVxUVFKMGFpb0NBQ0k0SURpVWtpRTZJQVpCQVdvaUJpQUlSdzBBQ3lBNUlEcER6Y3hNUHBSZURRRWdFQTBDSUFRZ0ZtcEJBQ0FlRUFVYURBSUxJRGxEQUFBQUFGNUZEUUVMSURrZ09sMUJBWE1OQUNBNVF3QUFnRCtTSURwREFBQ0FQNUtWa1NFNElBbEJBVTRFUUVNQUFJQS9JRGlUSVRsQkFDRUdBMEFnQkNBR0lBNXFRUUowYWlJUUlCQXFBZ0JEQUFDQVB5QTVJQXNnQmtFQ2RHb3FBZ0NVazVRNEFnQWdCa0VCYWlJR0lBbEhEUUFMQ3lBSklRWWdBVUVBVEEwQUEwQWdCQ0FHSUE1cVFRSjBhaUlRSURnZ0VDb0NBSlE0QWdBZ0JrRUJhaUlHSUFoSURRQUxDMEVBSVFZZ0VpQUZJQUFvQWp3aUJTQUZJQWtnQUNvQ1JJd2lPQ0E0SUFBb0Frd2lCU0FGUVFCQkFDQUFLQUlrRUJrZ0NVRUNUZ1JBQTBBZ0JrRUNkQ0lGSUFScVFZQkFheUFGSUF0cUtnSUFJQklnQ1NBR1FYOXpha0VDZENJUWFpb0NBSlFnQ3lBUWFpb0NBQ0FGSUJKcUtnSUFsSkk0QWdBZ0JrRUJhaUlHSUJ4SERRQUxDeUFLUVFGcUlnb2dGVWNOQUFzTElBQWdFMEVCYWpZQ05DQURRZUFoYWlRQUM2MEJBUUYvQWtBZ0FrRUNUUVIvSUFBTkFVRjVCVUYvQ3c4TElBQkJBRUdnUFNnQ0FFRUNkRUhnd0FCcUlBSnNRYVE5S0FJQVFRVjBha0hjQUdvUUJTSUFRWnc5TmdJQVFhQTlLQUlBSVFNZ0FFSUJOd0lRSUFBZ0FqWUNEQ0FBSUFJMkFnZ2dBQ0FETmdJRVFhZzlLQUlBSVFNZ0FFRUJOZ0ljSUFBZ0FrRUJSallDSUNBQVFRQTJBaVFnQUNBRE5nSVlJQUJCdkI5QkFCQUhHaUFBSUFFUVh5SUFOZ0lRUVFCQmZ5QUFHd3ZiQVFFR2Z3SkFJQUVnQUJDY0FTSUhTd1JBSUFFaEJnd0JDMEVCSVFZQ1FBSkFRWUNBQVNBQ2EwSGcvd0VnQVd0c1FROTJJZ1ZGQkVBZ0FTRUVRUUVoQXd3QkMwRUJJUU1EUUNBRlFRRnFJZ1ZCQVhRaUNDQUJhaUlFSUFkTEJFQWdCU0VHREFNTElBTkJBV29oQXlBRUlRRWdDRUVDYXlBQ2JFRVBkaUlGRFFBTEN5QUhJQVJySWdKQmZuRWdCR29oQVNBQ1FRRjJJQU5xSVFNTFFRQWdBMnNnQXlBSElBRWdCbW9pQWtraUJSc2hCQ0FCSUFJZ0JSc2hBd3NnQUNBRElBTWdCbW9pQUVHQWdBSWdBRUdBZ0FKSkcwR0FnQUlRTVNBRUM0VUJBUWQvSUFBb0FnZ2lCVUVCVGdSQUlBTWdBa0VCZEdwQkFXc2hCeUFBS0FKb0lRZ2dBQ2dDSUNJSkx3RUFJUVlEUUNBR1FSQjBJUW9nQVNBRVFRSjBhaUFJSUFVZ0Iyd2dCR3BxTFFBQVFVQnJJQWtnQkVFQmFpSUVRUUYwYWk0QkFDSUdJQXBCRUhWcklBSjBJQU5zYkVFQ2RUWUNBQ0FFSUFBb0FnZ2lCVWdOQUFzTEMxTUFBbjhDUUFKQUlBQkIvL3dBVEFSQUlBQkJ3RDVHRFFFZ0FFSGczUUJIRFFKQkJBOExJQUJCZ1AwQVJ3UkFRUUVnQUVHQTl3SkdEUU1hSUFCQndMc0JSdzBDUVFJUEMwRUREd3RCQmc4TFFRQUxDNFFDQVFaL0l3QWlCQ0VISUFRZ0FTQUNiQ0lJUVFKMFFROXFRWEJ4YXlJRkpBQUNRQ0FEUlFSQUlBSkJBVWdOQVNBQlFRRklEUUZCQUNFRUEwQWdBU0FFYkNFR1FRQWhBd05BSUFVZ0FpQURiQ0FFYWtFQ2RHb2dBQ0FESUFacVFRSjBhaW9DQURnQ0FDQURRUUZxSWdNZ0FVY05BQXNnQkVFQmFpSUVJQUpIRFFBTERBRUxJQUpCQVVnTkFDQUJRUUZJRFFBZ0FrRUNkRUhvT1dvaEJrRUFJUVFEUUNBR0lBUkJBblJxS0FJQUlBRnNJUWxCQUNFREEwQWdCU0FDSUFOc0lBUnFRUUowYWlBQUlBTWdDV3BCQW5ScUtnSUFPQUlBSUFOQkFXb2lBeUFCUncwQUN5QUVRUUZxSWdRZ0FrY05BQXNMSUFBZ0JTQUlRUUowRUFRYUlBY2tBQXZjR0FOTWZ3RitCWDBqQUVHZ0RHc2lGU0VVSUJVa0FDQVZRUUpCQVNBRUd5SXBJQUFvQWlBaUlTQUFLQUlJUVFGMGFrRUNheTRCQUNBaElBRkJBWFJxSWpzdUFRQWlLbXNnRDNSc1FRSjBRUTlxUVhCeGF5SWFJaFlrQUNBaElBQW9BZ2hCQVhScVFRSnJMZ0VBSUE5MFFRSjBJaHNnQTJvaEhDQVdRUkJySWp3aUZTUUFJQlZCRUdzaVBTSVZKQUFnRlVFUWF5SStJaFVrQUNBVlFSQnJJajhpRlNRQUlCVkJFR3NpTVNRQUlCUWdEallDL0FzZ0ZFRUFOZ0tFRENBVUlBbzJBdkFMSUJSQkFEWUM0QXNnRkNBQU5nTG9DeUFSS0FJQUlSVWdGQ0FUTmdLVURDQVVJQkkyQW93TUlCUWdDRFlDOUFzZ0ZDQVZOZ0tJRENBVVFRRWdEM1JCQVNBSEd5SWZRUUZLSWdjMkFwZ01JQlJCQURZQ2tBd2dGRUVCTmdMa0N5QVJJQUVnQWtnRWZ5QWFRUUFnQkJzaFFDQUlRUU5ISUFkeUlVRWdLVUVCYXlFeUlBRkJBbW9oTXlBQlFRRnFJU2dnQWtFQmF5RTBJQm9nRzJvZ0tpQVBkQ0kxUVFKMGF5SWxRUUFnTld0QkFuUWlCMm9oUWlBSElCcHFJU0pCZnlBZmRFRi9jeUVUSUFFaENFRUFJUnRCQVNFU0EwQWdGQ0FJSWhVMkF1d0xJQ0VnRlVFQmRHb2lIUzRCQUNFSElDRWdGVUVCYWlJSVFRRjBhaTRCQUNFV0lCUWdEQ0FPRUFzaU5tc2lFVUVCYXpZQ2dBd2dCeUFQZENFWElBMUJBQ0EySUFFZ0ZVWWJheUUzQW45QkFDQVFJQlZNRFFBYVFmLy9BQ0FSSUFZZ0ZVRUNkR29vQWdBZ055QVFJQlZySWcxQkF5QU5RUU5JRzIxcUlnMGdEU0FSU2hzaURVSC8vd0JLRFFBYUlBMUJBQ0FOUVFCS0d3c2hKQ0FYUVFKMElRMGdGaUFIYXlFSEFrQWdGU0FvUndSQUlCMHVBUUFnQjJzZ0QzUWdPeTRCQUNBUGRFZ05BUXNnRlNBYklCVWdHeHNnRWhzaEd3c2dCQ0FOYWlFV0FrQWdGU0FvUnlKRERRQWdHaUFBS0FJZ0loRWdLRUVCZEdvdUFRQWlGeUFSSUFGQkFYUnFMZ0VBYXlBUGRDSVNRUUowSWhscUlCb2dFa0VCZENBUklETkJBWFJxTGdFQUlCZHJJQTkwSWhGclFRSjBJaGRxSUJFZ0VtdEJBblFpRVJBRUdpQUpSUTBBSUJrZ0pXb2dGeUFsYWlBUkVBUWFDeUFXUVFBZ0JCc2hJQ0FESUExcUlTTWdCeUFQZENFWElCUWdDeUFWUVFKMElqaHFLQUlBSWhJMkF2Z0xRUUFnSEVFQUlCVWdBQ2dDREVnaUdCc2lIQ0FWSURSR0loNGJJU1pCZnlFWkFrQWdHMFVFUUNBVEloRWhEUXdCQ3lBVEloRWhEU0JCSUJKQkFFaHlSUTBBSUNFZ0cwRUJkR291QVFBZ0J5QXFhbXNnRDNRaUIwRUFJQWRCQUVvYkloa2dOV29oRFNBYklRY0RRQ0FoSUFjaUVrRUJheUlIUVFGMGFpNEJBQ0FQZENBTlNnMEFDeUFOSUJkcUlTY2dHMEVCYXlFV0lCc2dGU0FWSUJ0SUcwRUJheUVSQTBBQ1FDQVJJQllpRFVZRVFDQVJJUTBNQVFzZ0lTQU5RUUZxSWhaQkFYUnFMZ0VBSUE5MElDZElEUUVMQ3lBSElBMGdEU0FTU0JzaEVrRUFJUkZCQUNFTkEwQWdFU0FGSUFjZ0tXd2lGbW90QUFCeUlSRWdEU0FGSUJZZ01tcHFMUUFBY2lFTklBY2dFa2NoRmlBSFFRRnFJUWNnRmcwQUN3c2dKaUVjSUNNZ0dpQVlHeUVTSUNBZ1FDQVlHeUVZQW44Q1FDQUpSUTBBSUFvZ0ZVWUVRRUVBSVFjZ0hTNEJBQ0FxYXlBUGRDSUpRUUZJRFFFRFFDQWFJQWRCQW5RaUZtb2lJQ0FnS2dJQUlCWWdKV29xQWdDU1F3QUFBRCtVT0FJQUlBZEJBV29pQnlBSlJ3MEFDd3dCQ3lBS0lCVkdEUUJCQUNBYUlCbEJBblFpQjJvZ0dVRi9SaUlXR3lFZUlCUkI0QXRxSUJnZ0Z5QWtRUUYySWhnZ0h3Si9JQlVnTkVZRVFFRUFJUmtnRkVIZ0Myb2dFaUFYSUJnZ0h5QWVJQTlCQUVNQUFJQS9JQndnRVJBS0lSRkJBQ0FISUNWcUlCWWJEQUVMSUJSQjRBdHFJQklnRnlBWUlCOGdIaUFQSUNJZ0hTNEJBQ0FQZEVFQ2RHcERBQUNBUHlBY0lCRVFDaUVSSUVJZ0hTNEJBQ0FQZEVFQ2RHb2hHVUVBSUFjZ0pXb2dGaHNMSUE4Z0dVTUFBSUEvSUJ3Z0RSQUtEQUVMQWtBZ0dBUkFRUUZGQkVBZ09Db0NBQ0ZrSUFBb0FnZ2dGV3BCQW5RcUFnQWhZeUFPS0FJRUlUa2dEaWdDQUNFNklCUkIyQXRxSWtRZ0Rpa0NFRGNEQUNBVUlBNHBBZ2czQTlBTElBNG9BaGdoSXlBVVFjZ0xhaUpGSUE0b0FpdzJBZ0FnRkVIQUMyb2lSaUFPS1FJa053TUFJQlFnRGlrQ0hEY0R1QXNnRkVHQUMyb2lSeUFVUVpnTWFpSW1LQUlBTmdJQUlCUkIrQXBxSWtnZ0ZFR1FER29pSUNrREFEY0RBQ0FVUWZBS2FpSkpJQlJCaUF4cUlpY3BBd0EzQXdBZ0ZFSG9DbW9pU2lBVVFZQU1haUlyS1FNQU53TUFJQlJCNEFwcUlrc2dGRUg0QzJvaUxDa0RBRGNEQUNBVVFkZ0thaUpNSUJSQjhBdHFJaTBwQXdBM0F3QWdGRUhRQ21vaVRTQVVRZWdMYWlJdUtRTUFOd01BSUJRZ0ZDa0Q0QXMzQThnS0lEd2dFaUFYUVFKMEloWVFCQ0V2SUQwZ0dDQVdFQVFoTUNBZ1FYODJBZ0JCQUNFSElBMGdFWEloRVVNQUFBQUFJV0VnRkVIZ0Myb2dFaUFZSUJjZ0pDQWZRUUFnR2lBWlFRSjBhaUFaUVg5R0d5Sk9JQThnSGdSL1FRQUZJQ0lnSFM0QkFDQVBkRUVDZEdvTElCd2dFUkFrSVFsREFBQUFBQ0ZpSUJkQkFVZ2lUMFVFUUFOQUlHSWdMeUFIUVFKMElnMXFLZ0lBSUEwZ0Vtb3FBZ0NVa2lGaUlBZEJBV29pQnlBWFJ3MEFDMEVBSVFjRFFDQmhJREFnQjBFQ2RDSU5haW9DQUNBTklCaHFLZ0lBbEpJaFlTQUhRUUZxSWdjZ0YwY05BQXNMSUJSQnNBdHFJbEFnRGlrQ0tEY0RBQ0FVUWFnTGFpSlJJQTRwQWlBM0F3QWdGRUdnQzJvaVVpQU9LUUlZTndNQUlCUkJtQXRxSWxNZ0Rpa0NFRGNEQUNBVVFaQUxhaUpVSUE0cEFnZzNBd0FnRGlrQ0FDRmdJQlJCa0FwcUlsVWdMaWtEQURjREFDQVVRWmdLYWlKV0lDMHBBd0EzQXdBZ0ZFR2dDbW9pVnlBc0tRTUFOd01BSUJSQnFBcHFJbGdnS3lrREFEY0RBQ0FVUWJBS2FpSlpJQ2NwQXdBM0F3QWdGRUc0Q21vaVdpQWdLUU1BTndNQUlCUkJ3QXBxSWxzZ0ppZ0NBRFlDQUNBVUlHQTNBNGdMSUJRZ0ZDa0Q0QXMzQTRnS0lENGdFaUFXRUFRaFhDQS9JQmdnRmhBRUlWMGdIa1VFUUNBeElDSWdIUzRCQUNBUGRFRUNkR29nRmhBRUdnc2dGQ0FqSURwcUlsNGdPU0FqYXlKZkVBUWhEU0FPSURrMkFnUWdEaUE2TmdJQUlBNGdSQ2tEQURjQ0VDQU9JQTBwQTlBTE53SUlJQTRnSXpZQ0dDQU9JRVVvQWdBMkFpd2dEaUJHS1FNQU53SWtJQTRnRFNrRHVBczNBaHdnTGlCTktRTUFOd01BSUMwZ1RDa0RBRGNEQUNBc0lFc3BBd0EzQXdBZ0t5QktLUU1BTndNQUlDY2dTU2tEQURjREFDQWdJRWdwQXdBM0F3QWdKaUJIS0FJQU5nSUFJQTBnRFNrRHlBbzNBK0FMSUJJZ0x5QVdFQVFoRWlBWUlEQWdGaEFFSVJrZ1EwVUVRQ0FhSUFBb0FpQWlCeUFvUVFGMGFpNEJBQ0lqSUFjZ0FVRUJkR291QVFCcklBOTBJaGhCQW5ScUlCb2dHRUVCZENBSElETkJBWFJxTGdFQUlDTnJJQTkwSWdkclFRSjBhaUFISUJoclFRSjBFQVFhQ3lBTlFRRTJBcEFNUVFBaEJ5QmpJR1FnWXlCaklHUmVHME1BQUVCQWxTSmxraUZqSUdRZ1paSWlaQ0JpbENCaklHR1VraUZsUXdBQUFBQWhZU0FOUWVBTGFpQVNJQmtnRnlBa0lCOGdUaUFQSUI0RWYwRUFCU0FpSUIwdUFRQWdEM1JCQW5ScUN5QWNJQkVRSkNFUlF3QUFBQUFoWWlCUFJRUkFBMEFnWWlBdklBZEJBblFpR0dvcUFnQWdFaUFZYWlvQ0FKU1NJV0lnQjBFQmFpSUhJQmRIRFFBTFFRQWhCd05BSUdFZ01DQUhRUUowSWhocUtnSUFJQmdnR1dvcUFnQ1VraUZoSUFkQkFXb2lCeUFYUncwQUN3c2daU0JrSUdLVUlHTWdZWlNTWUVFQmMwVUVRQ0FPSUEwcEE0Z0xOd0lBSUE0Z1VDa0RBRGNDS0NBT0lGRXBBd0EzQWlBZ0RpQlNLUU1BTndJWUlBNGdVeWtEQURjQ0VDQU9JRlFwQXdBM0FnZ2dMaUJWS1FNQU53TUFJQzBnVmlrREFEY0RBQ0FzSUZjcEF3QTNBd0FnS3lCWUtRTUFOd01BSUNjZ1dTa0RBRGNEQUNBZ0lGb3BBd0EzQXdBZ0ppQmJLQUlBTmdJQUlBMGdEU2tEaUFvM0ErQUxJQklnWENBV0VBUWFJQmtnWFNBV0VBUWFJQjVGQkVBZ0lpQWRMZ0VBSUE5MFFRSjBhaUF4SUJZUUJCb0xJRjRnRFNCZkVBUWFJQWtoRVF0QkFDRUpEQUlMUVFBaENTQVVRUUEyQXBBTUlCUkI0QXRxSUJJZ0dDQVhJQ1FnSDBFQUlCb2dHVUVDZEdvZ0dVRi9SaHNnRHlBZUJIOUJBQVVnSWlBZExnRUFJQTkwUVFKMGFnc2dIQ0FOSUJGeUVDUWhFUXdCQzBFQUlRa2dGRUhnQzJvZ0VpQVhJQ1FnSDBFQUlCb2dHVUVDZEdvZ0dVRi9SaHNnRHlBZUJIOUJBQVVnSWlBZExnRUFJQTkwUVFKMGFndERBQUNBUHlBY0lBMGdFWElRQ2lFUkN5QVJDeUVISUFVZ0ZTQXBiQ0lOYWlBUk9nQUFJQVVnRFNBeWFtb2dCem9BQUNBR0lEaHFLQUlBSVFjZ0ZFRUFOZ0tZRENBSElEWWdOMnBxSVEwZ0pDQVhRUU4wU2lFU0lBSWdDRWNOQUFzZ0ZDZ0NpQXdGSUJVTE5nSUFJQlJCb0F4cUpBQUxCQUJCQUF2V0JBTVBmd1Y5QVh3Z0JpQUhTQVJBUVFFZ0EzUWlFRUVCSUJCQkFVb2JJUlFnQkVFQklBUkJBVW9iSVJjZ0EwRURSaUVZSUFOQkgwWWhHUU5BUXdBQWdEOGdBQ2dDSUNJT0lBWWlFRUVCYWlJR1FRRjBhaTRCQUNBT0lCQkJBWFFpR21vdUFRQnJJaE1nQTNRaUc3ZWZ0cFVoSVNBTElCQkJBblJxS0FJQVFRRnFJQk51SUFOMnNrTUFBQUMrbEx0RTd6bjYva0l1NWoraUVCKzJRd0FBQUQrVUlTQWdCQ0FRYkNFY1FRQWhFZ05BSUFvZ0FDZ0NDQ0lQSUJKc0lCQnFRUUowSWc1cUtnSUFJUjBnQ1NBT2Fpb0NBQ0VlSUFnZ0Rtb3FBZ0FDZlNBRVFRRkdCRUFnSFNBS0lBOGdFR3BCQW5RaUQyb3FBZ0FpSHlBZElCOWVHeUVkSUI0Z0NTQVBhaW9DQUNJZklCNGdIMTRiSVI0TElCNExJQjBnSFNBZVhodVRRd0FBQUFDWHUwVHZPZnIrUWk3bXY2SVFIeUVpQWtBZ0dRMEFJQUVnQlNBU2JFRUNkR29nQUNnQ0lDQWFhaTRCQUNBRGRFRUNkR29oRlNBQ0lCSWdIR3BxSVJaQkFDRVBBa0FnRTBFQVNnUkFJQ0VnSUNBaXRpSWRJQjJTSWgxRDh3UzFQNVFnSFNBWUd5SWRJQjBnSUY0YmxDSWRqQ0VlUVFBaEVRTkFRUUFoRGlBV0xRQUFJQkYyUVFGeFJRUkFBMEFnRlNBT0lBTjBJQkZxUVFKMGFpQWRJQjRnREVHTnpPVUFiRUhmNXJ2akEyb2lERUdBZ0FKeEd6Z0NBRUVCSVE4Z0RrRUJhaUlPSUJOSERRQUxDeUFSUVFGcUloRWdGRWNOQUFzTUFRc2dGaTBBQUNFUlFRQWhEZ05BSUE5QkFTQVJJQTUyUVFGeEd5RVBJQTVCQVdvaURpQVVSdzBBQ3dzZ0QwVU5BQ0FWSUJ0REFBQ0FQeUFORUM0TElCSkJBV29pRWlBWFJ3MEFDeUFHSUFkSERRQUxDd3U3QlFFTGZ5QUJJQUFvQVFRMkFRQWdBaUFBS0FFSU5nRUFJQUFnQVNBRlFRRjBJZ1pxS0FFQU5nRUVJQUFnQWlBR2FpZ0JBRFlCQ0VHQWdBUWdCRUVEZENJR2JTRUhJQU1vQWdRaENpQURLQUlBSVFzZ0JFRUJUZ1JBSUFkQkVIUkJFSFVpQXlBS0lBQXZBUUlpQjJ0QkVIUkJFSFZzUVE5MVFRRnFRUUYxSVEwZ0F5QUxJQUF2QVFBaUNHdEJFSFJCRUhWc1FROTFRUUZxUVFGMUlRNGdCa0VCSUFaQkFVb2JJUTlCQUNFREEwQWdBaUFEUVFGcUlnUkJBWFFpQ1dvaURFSC8vd0VnQnlBTmFpSUhRUkIwUVJCMUloQWdBU0FKYWk0QkFDSUpRUVYxYkNBTUxnRUFRUWgwYWlBSlFRdDBRWUR3QTNFZ0VHeEJFSFZxSUFnZ0Rtb2lDRUVRZEVFUWRTSU1JQUVnQTBFQmRHb2lBeTRCQkNBRExnRUFhaUFKUVFGMGFpSURRUWQxYkdvZ0EwRUpkRUdBL0FOeElBeHNRUkIxYWlJRFFRZDFRUUZxUVFGMUlnbEJnSUIrSUFsQmdJQitTaHNnQTBILy92OERTaHM3QVFBZ0JDSURJQTlIRFFBTEN5QUZJQVpLQkVBZ0NrRVFkRUVRZFNFRElBdEJFSFJCRUhVaEJBTkFJQVpCQVhRaENDQUNJQVpCQVdvaUJrRUJkQ0lIYWlJSlFmLy9BU0FCSUFkcUxnRUFJZ2RCQlhVZ0Eyd2dDUzRCQUVFSWRHb2dCMEVMZEVHQThBTnhJQU5zUVJCMWFpQUJJQWhxSWdndUFRUWdDQzRCQUdvZ0IwRUJkR29pQjBFSGRTQUViR29nQjBFSmRFR0EvQU54SUFSc1FSQjFhaUlIUVFkMVFRRnFRUUYxSWdoQmdJQitJQWhCZ0lCK1Noc2dCMEgvL3Y4RFNoczdBUUFnQlNBR1J3MEFDd3NnQUNBS093RUNJQUFnQ3pzQkFDQUZRUUZPQkVCQkFDRUdBMEFnQVNBR1FRRnFJZ1pCQVhRaUFHb2lBeUFETGdFQUlnTWdBQ0FDYWlJQUxnRUFJZ1JxSWdwQi8vOEJJQXBCLy84QlNCc2lDa0dBZ0g0Z0NrR0FnSDVLR3pzQkFDQUFJQU1nQkdzaUFFSC8vd0VnQUVILy93RklHeUlBUVlDQWZpQUFRWUNBZmtvYk93RUFJQVVnQmtjTkFBc0xDM29CQlg4Z0FVRUNUZ1JBUVFFaEF3TkFJQUFnQTBFQmRHb3VBUUFoQlNBRElRSUNRQU5BSUFVZ0FDQUNRUUZySWdaQkFYUnFMZ0VBSWdST0RRRWdBQ0FDUVFGMGFpQUVPd0VBSUFKQkFVb2hCQ0FHSVFJZ0JBMEFDMEVBSVFJTElBQWdBa0VCZEdvZ0JUc0JBQ0FEUVFGcUlnTWdBVWNOQUFzTEM0a0hBUVIvSUFBQ2Z3SkFJQUpCQVVnTkFDQUNJQUVnQWtHQU9Xb3RBQUJCNERkcVFRZ1FBeUlDYXlFRklBSkJFSFFpQWtFQlNBUkFEQUVMSUFKQkVIVWlBaUFCSUFKQmdEbHFMUUFBUWNBMmFrRUlFQU1pQW1zaEF5QUNRUkIwSWdKQkFFd05BQ0FDUVJCMUlnSWdBU0FDUVlBNWFpMEFBRUdnTldwQkNCQURJZ0pySVFRZ0FrRVFkRUVCU0EwQUlBQWdBU0FDUWYvL0EzRkJnRGxxTFFBQVFZQTBha0VJRUFNaUJqc0JBQ0FDSUFackRBRUxJQUJCQURzQkFFRUFDenNCQWlBQUFuOGdCRUVRZEVFQlRnUkFJQUFnQVNBRVFmLy9BM0ZCZ0RscUxRQUFRWUEwYWtFSUVBTWlBanNCQkNBRUlBSnJEQUVMSUFCQkFEc0JCRUVBQ3pzQkJrRUFJUVFnQUFKL0FrQWdBMEVRZENJQ1FRQk1CRUFnQUVFSWFpRUREQUVMSUFCQkNHb2hBeUFDUVJCMUlnSWdBU0FDUVlBNWFpMEFBRUdnTldwQkNCQURJZ0pySVFRZ0FrRVFkRUVCU0EwQUlBQWdBU0FDUWYvL0EzRkJnRGxxTFFBQVFZQTBha0VJRUFNaUF6c0JDQ0FDSUFOckRBRUxJQU5CQURzQkFFRUFDenNCQ2lBQUFuOGdCRUVRZEVFQlRnUkFJQUFnQVNBRVFmLy9BM0ZCZ0RscUxRQUFRWUEwYWtFSUVBTWlBanNCRENBRUlBSnJEQUVMSUFCQkFEc0JERUVBQ3pzQkRrRUFJUVJCQUNFQ0lBQUNmd0pBQWtBZ0JVRVFkQ0lEUVFGT0JFQWdBMEVRZFNJQ0lBRWdBa0dBT1dvdEFBQkJ3RFpxUVFnUUF5SURheUVDSUFOQkVIUWlBMEVBU2cwQkN5QUFRUkJxSVFVTUFRc2dBRUVRYWlFRklBTkJFSFVpQkNBQklBUkJnRGxxTFFBQVFhQTFha0VJRUFNaUEyc2hCQ0FEUVJCMFFRRklEUUFnQUNBQklBTkIvLzhEY1VHQU9Xb3RBQUJCZ0RScVFRZ1FBeUlGT3dFUUlBTWdCV3NNQVFzZ0JVRUFPd0VBUVFBTE93RVNJQUFDZnlBRVFSQjBRUUZPQkVBZ0FDQUJJQVJCLy84RGNVR0FPV290QUFCQmdEUnFRUWdRQXlJRE93RVVJQVFnQTJzTUFRc2dBRUVBT3dFVVFRQUxPd0VXUVFBaEJDQUFBbjhDUUNBQ1FSQjBJZ0pCQUV3RVFDQUFRUmhxSVFNTUFRc2dBRUVZYWlFRElBSkJFSFVpQWlBQklBSkJnRGxxTFFBQVFhQTFha0VJRUFNaUFtc2hCQ0FDUVJCMFFRRklEUUFnQUNBQklBSkIvLzhEY1VHQU9Xb3RBQUJCZ0RScVFRZ1FBeUlET3dFWUlBSWdBMnNNQVFzZ0EwRUFPd0VBUVFBTE93RWFJQVJCRUhSQkFVNEVRQ0FBSUFFZ0JFSC8vd054UVlBNWFpMEFBRUdBTkdwQkNCQURJZ0U3QVJ3Z0FDQUVJQUZyT3dFZUR3c2dBRUVBT3dFY0lBQkJBRHNCSGd1VkFRRUZmeUFFUVFGT0JFQWdBQ2dDQUNFRklBTXVBUUloQmlBRExnRUFJUWRCQUNFREEwQWdBU0FEUVFKMGFpQUNJQU5CQVhScUxnRUFRUWgwSUFWcUlnVTJBZ0FnQUNnQ0JDRUlJQUFnQlVFQ2RDSUZRZnovQTNFaUNTQUdiRUVRZFNBRlFSQjFJZ1VnQm14cU5nSUVJQUFnQ0NBRklBZHNhaUFISUFsc1FSQjFhaUlGTmdJQUlBTkJBV29pQXlBRVJ3MEFDd3NMNndRQkJIOENRQ0FBUVFCQnJBSVFCU0lEQW45QmZ5RUFBa0FnQVVIQVBrWU5BQ0FCUVlEOUFFWU5BQ0FCUWVEZEFFY05BZ3NDUUNBQ1FmLzhBRXdFUUNBQ1FjQStSZzBCSUFKQjROMEFSZzBCREFNTElBSkJnUDBBUmcwQUlBSkJnUGNDUmcwQUlBSkJ3THNCUncwQ0N5QUJRUXgyUVFWc0lBSkJESFlnQWtHQS9RQktheUFDUWNDN0FVcDFha0d4QzJvc0FBQUxOZ0trQWlBRElBSkIvLzhEY1VIb0IyNDJBcUFDSUFNZ0FVSC8vd054UWVnSGJpSUFOZ0tjQWlBRElBQkJDbXcyQW93Q0FrQWdBU0FDU0FSQVFRRWhBQ0FDSUFGQkFYUkdCRUFnQTBFQk5nS0lBa0VBSVFBTUFnc2dBMEVDTmdLSUFnd0JDeUFCSUFKS0JFQWdBMEVETmdLSUFpQUNRUUowSWdBZ0FVRURiRVlFUUNBRFFkQUxOZ0tvQWlBRFFwS0FnSUF3TndLVUFrRUFJUUFNQWdzZ0FrRURiQ0lFSUFGQkFYUkdCRUFnQTBHUUREWUNxQUlnQTBLU2dJQ0FJRGNDbEFKQkFDRUFEQUlMSUFFZ0FrRUJkRVlFUUNBRFFjQU1OZ0tvQWlBRFFwaUFnSUFRTndLVUFrRUFJUUFNQWdzZ0FTQUVSZ1JBSUFOQjRBdzJBcWdDSUFOQ3BJQ0FnQkEzQXBRQ1FRQWhBQXdDQ3lBQUlBRkdCRUFnQTBHUURUWUNxQUlnQTBLa2dJQ0FFRGNDbEFKQkFDRUFEQUlMUVg4aEFDQUNRUVpzSUFGSERRSWdBMEhBRFRZQ3FBSWdBMEtrZ0lDQUVEY0NsQUpCQUNFQURBRUxRUUFoQUNBRFFRQTJBb2dDQ3lBQklBQjBJUVVnQWtFUWRFRVFkU0VFSUFKQkQzWkJBV3BCQVhZaEJpQUJJQUJCRG5KMElBSnRRUUowSVFJRFFDQUNJZ0JCQVdvaEFpQUFRUkIxSUFSc0lBQWdCbXhxSUFCQi8vOERjU0FFYkVFUWRXb2dCVWdOQUFzZ0F5QUFOZ0tRQWtFQUlRQUxJQUFMY3dFRGZ3Si9RUUFnQUVFQVNBMEFHa0gvLy8vL0J5QUFRZjRlU2cwQUdpQUFRZjhBY1NFQlFRRWdBRUVIZGlJRGRDRUNJQUJCL3c5TUJIOGdBVUdBQVNBQmEyeEIwbjVzUVJCMUlBRnFJQU4wUVFkMUJTQUJRWUFCSUFGcmJFSFNmbXhCRUhVZ0FXb2dBa0VIZG13TElBSnFDd3ZJQVFFRWZ5QUVRUUZPQkVBRFFDQUNBbjhnQXlBR2NrVUVRQ0FCTEFBQUlnVWdBaXdBQUVFUWF5SUhJQVVnQjBvYkRBRUxJQUVnQm1vc0FBQkJCR3NpQlNBQ0xBQUFJZ2RCQ0dvaUNFb0VRQ0FISUFWQkFYUWdDR3RxREFFTElBVWdCMm9MSWdWQkFDQUZRUmgwUVJoMVFRQktHeUlGUVQ4Z0JVRVlkRUVZZFVFL1NCc2lCVG9BQUNBQUlBWkJBblJxSUFWQi93RnhJZ1ZCOFRoc1FSQjJJQVZCSFd4cUlnVkIxUTRnQlVIVkRra2JRYW9RYWhCcE5nSUFJQVpCQVdvaUJpQUVSdzBBQ3dzTDFBSUJCSDhnQUNBQlFSQjBRUkIxSWdOQkJXdzJBcHdTSUFBdUFaUVNJQU5CZ0lBVWJFRVFkV3doQkFKQUFrQUNRQ0FCSUFBb0Fvd1NSZ1JBSUFBb0FwQVNJQUpHRFFFTElBQkJnQk5xSUFOQjZBZHNJQUlRYUNFRklBQWdBallDa0JJZ0FDZ0NqQklnQVVjTkFRdEJBU0VHSUFRZ0FDZ0NtQkpHRFFFTElBQkJnakpCbVRJZ0FDZ0NsQkpCQkVZaUFodEI0REZCalRJZ0Foc2dBVUVJUmhzMkF0QVNJQVpGQkVBZ0FDQURRUlJzTmdLZ0VpQUFRY2dlUVpRdklBRkJlM0ZCQ0VZaUFoczJBcXdWSUFCQkNrRVFJQUliTmdLa0VrR1FNU0VDQWtBQ1FBSkFBa0FnQVVFTWF3NEZBQUVCQVFJQkMwR0tNU0VDREFFTFFZRXhJUUlnQVVFSVJ3MEJDeUFBSUFJMkFzd1NDeUFBUVFBMkFzUWdJQUJCQ2pvQWlCSWdBRUhrQURZQ2hCSWdBRUVCTmdMSUVpQUFRWVFLYWtFQVFZQUlFQVVhQ3lBQUlBUTJBcGdTSUFBZ0FUWUNqQklMSUFVTFJnRUNmeU1BUVJCcklnRWtBQUpBSUFCRkRRQkJtUHNCS0FJQUlnSkZCRUFnQVNBQU5nSUFRZXNJSUFFUUhnd0JDMEdZK3dFZ0FpQUFFRDgyQWdBTElBRkJFR29rQUF2a0FRRUZmd0pBSUFSQkFVZ05BRUh3Q1VIRUNTQUVRUVJHSWdVYlFhQUtRZEFKSUFVYklBTkJDRVlpQnhzaENFRUxRUU1nQlJ0QklrRU1JQVViSUFjYklRY2dBMEVRZENJRlFROTFJZ01nQUdvaENVRUFJUUFnQlVFUWRVRVNiQ0lGSUFOSUJFQURRQ0FDSUFCQkFuUnFJQU1nQlNBSklBZ2dBQ0FIYkNBQmFtb3NBQUJxSWdZZ0JTQUdTaHNnQXlBR1NCczJBZ0FnQUVFQmFpSUFJQVJIRFFBTUFnc0FDd05BSUFJZ0FFRUNkR29nQlNBRElBa2dDQ0FBSUFkc0lBRnFhaXdBQUdvaUJpQURJQVpLR3lBRklBWklHellDQUNBQVFRRnFJZ0FnQkVjTkFBc0xDOGdFQVFkL0l3QkJRR29pQkNRQUlBRkJFR29nQUVHd0ZXb2dBRUdJRW1vZ0FrRUNSaUFBS0FLVUVoQnFJQVJCSUdvZ0FFRzRGV29nQUNnQ3JCVVFkaUFCUVVCcklnVWdCRUVnYWlBQUtBS2tFaUFBS0FMSUlCQXJJQUZCSUdvaEF3SkFBa0FnQUNnQ3lCSkJBVVlFUUNBQVFRUTZBTThWREFFTElBQXNBTThWSWdoQkEwb05BQ0FBS0FLa0VpSUdRUUZPQkVCQkFDRUNBMEFnQkNBQ1FRRjBJZ2RxSUFBZ0IycEJxQkpxTGdFQUlna2dCRUVnYWlBSGFpNEJBQ0FKYXlBSWJFRUNkbW83QVFBZ0FrRUJhaUlDSUFaSERRQUxDeUFESUFRZ0JpQUFLQUxJSUJBckRBRUxJQU1nQlNBQUtBS2tFa0VCZEJBRUdnc2dBRUdvRW1vZ0JFRWdhaUFBS0FLa0VpSUNRUUYwRUFRYUlBQW9Bc0FnQkVBZ0F5QUNRZEx3QXhBcUlBVWdBQ2dDcEJKQjB2QURFQ29MSUFFQ2Z5QUFRYzBWYWkwQUFFRUNSZ1JBSUFCQnloVnFMZ0VBSUFCQnpCVnFMQUFBSUFFZ0FDZ0NqQklnQUNnQ2xCSVFiU0FBS0FLVUVpSUdRUUZPQkVBZ0FFSFFGV29zQUFCQkFuUkJ3Qk5xS0FJQUlRZEJBQ0VDQTBBZ0FTQUNRUXBzYWlJRElBY2dBQ0FDYWtHMEZXb3NBQUJCQld4cUlnVXNBQUJCQjNRN0FXQWdBeUFGTEFBQlFRZDBPd0ZpSUFNZ0JTd0FBa0VIZERzQlpDQURJQVVzQUFOQkIzUTdBV1lnQXlBRkxBQUVRUWQwT3dGb0lBSkJBV29pQWlBR1J3MEFDd3NnQUVIUkZXb3NBQUJCQVhSQitEQnFMZ0VBREFFTElBRkJBQ0FBS0FLVUVrRUNkQkFGUWVBQWFrRUFJQUFvQXBRU1FRcHNFQVVhSUFCQjBCVnFRUUE2QUFCQkFBczJBb2dCSUFSQlFHc2tBQXYzR3dFb2Z5TUFRU0JySWdRaEZpQUVKQUFnQkNBQUtBS2dFa0VCZEVFUGFrRndjV3NpRnlJRUpBQWdCQ0FBS0FLWUVpSUVJQUFvQXFBU2FrRUNkRUVQYWtGd2NXc2lFaUlLSkFBZ0NpQUFLQUtjRWtFQ2RDSUtRUTlxUVhCeGF5SVlJZ1lrQUNBR0lBcEJ6d0JxUVhCeGF5SUZKQUFnQUVIUEZXb3NBQUFoRVNBRVFRRk9CRUFnQUN3QXpSVkJBWFJCZkhGQjhEQnFJQUJCemhWcUxBQUFRUUYwYWk0QkFFRUVkQ0VNSUFCQjBoVnFMQUFBSVFZRFFDQUFJQWRCQW5ScUlnb2dBeUFIUVFGMGFpNEJBQ0lFUVE1MElnZzJBZ1FnQmtHMWlNN2RBR3hCNjhibHNBTnFJUVlDUUNBS0lBUkJBVTRFZnlBSVFZQUthd1VnQkVGL1NnMEJJQWhCZ0FweUN5SUlOZ0lFQ3lBS1FRQWdDQ0FNYWlJS2F5QUtJQVpCQUVnYk5nSUVJQVFnQm1vaEJpQUhRUUZxSWdjZ0FDZ0NtQkpJRFFBTEN5QUZJQUFwQW9RS053SUFJQVVnQUVHOENtb3BBZ0EzQWpnZ0JTQUFRYlFLYWlrQ0FEY0NNQ0FGSUFCQnJBcHFLUUlBTndJb0lBVWdBRUdrQ21vcEFnQTNBaUFnQlNBQVFad0thaWtDQURjQ0dDQUZJQUJCbEFwcUtRSUFOd0lRSUFVZ0FFR01DbW9wQWdBM0FnZ2dBQ2dDbEJKQkFVNEVRQ0FBUVFScUlSTWdBQ2dDb0JJaEVDQVJRUVJJSVNZZ0FpRVJBMEFnRmlBQklBNUJCSFJCWUhGcVFTQnFJZzBnQUNnQ3BCSkJBWFFRQkNFTVFRQWdBU0FPUVFKMGFpSUlLQUlRSWc4Z0R5QVBRUjkxSWdOcUlBTnpJZ3BuSWdaQkFXdDBJZ2xCLy84RGNVSC8vLy8vQVNBSlFSQjFJZ1J0SWdkQkVIUWlDMEVRZFNJRGJFRVFkU0FESUFSc2FrRURkR3NpQkNBSFFROTFRUUZxUVFGMWJDQUxhaUFFUVJCMUlBTnNhaUFFUWZqL0EzRWdBMnhCRUhWcUlRUUNmeUFLUWYvL0IwMEVRRUgvLy8vL0J5QUdRUTlySWdwMklnZEJnSUNBZ0hnZ0NuVWlDeUFFSUFRZ0MwZ2JJQVFnQjBvYklBcDBEQUVMSUFSQkR5QUdhM1VMSVFvZ0FDMEF6UlVoQzBHQWdBUWhCeUFBS0FJQUlnUWdEMGNFUUNBRUlBUWdCRUVmZFNJSGFpQUhjMmNpQjBFQmEzUWlCQ0FFUVJCMUlBTnNJQVJCLy84RGNTQURiRUVRZFdvaUJLd2dDYXgrUWgySXAwRjRjV3NpQ1VFUWRTQURiQ0FFYWlBSlFmLy9BM0VnQTJ4QkVIVnFJUU1nQlNBRktBSUFJZ2xCRUhSQkVIVWlGQUovSUFjZ0JtdEJIV29pQkVFUFRBUkFRZi8vLy84SFFSQWdCR3NpQkhZaUJrR0FnSUNBZUNBRWRTSUhJQU1nQXlBSFNCc2dBeUFHU2hzZ0JIUU1BUXNnQXlBRVFSQnJkVUVBSUFSQk1FZ2JDeUlIUWYvL0EzRWlBMnhCRUhVZ0ZDQUhRUkIxSWdSc2FpQUpRUTkxUVFGcVFRRjFJQWRzYWpZQ0FDQUZJQVVvQWdRaUJrRVFkRUVRZFNJSklBTnNRUkIxSUFRZ0NXeHFJQVpCRDNWQkFXcEJBWFVnQjJ4cU5nSUVJQVVnQlNnQ0NDSUdRUkIwUVJCMUlna2dBMnhCRUhVZ0JDQUpiR29nQmtFUGRVRUJha0VCZFNBSGJHbzJBZ2dnQlNBRktBSU1JZ1pCRUhSQkVIVWlDU0FEYkVFUWRTQUVJQWxzYWlBR1FROTFRUUZxUVFGMUlBZHNhallDRENBRklBVW9BaEFpQmtFUWRFRVFkU0lKSUFOc1FSQjFJQVFnQ1d4cUlBWkJEM1ZCQVdwQkFYVWdCMnhxTmdJUUlBVWdCU2dDRkNJR1FSQjBRUkIxSWdrZ0EyeEJFSFVnQkNBSmJHb2dCa0VQZFVFQmFrRUJkU0FIYkdvMkFoUWdCU0FGS0FJWUlnWkJFSFJCRUhVaUNTQURiRUVRZFNBRUlBbHNhaUFHUVE5MVFRRnFRUUYxSUFkc2FqWUNHQ0FGSUFVb0Fod2lCa0VRZEVFUWRTSUpJQU5zUVJCMUlBUWdDV3hxSUFaQkQzVkJBV3BCQVhVZ0IyeHFOZ0ljSUFVZ0JTZ0NJQ0lHUVJCMFFSQjFJZ2tnQTJ4QkVIVWdCQ0FKYkdvZ0JrRVBkVUVCYWtFQmRTQUhiR28yQWlBZ0JTQUZLQUlrSWdaQkVIUkJFSFVpQ1NBRGJFRVFkU0FFSUFsc2FpQUdRUTkxUVFGcVFRRjFJQWRzYWpZQ0pDQUZJQVVvQWlnaUJrRVFkRUVRZFNJSklBTnNRUkIxSUFRZ0NXeHFJQVpCRDNWQkFXcEJBWFVnQjJ4cU5nSW9JQVVnQlNnQ0xDSUdRUkIwUVJCMUlna2dBMnhCRUhVZ0JDQUpiR29nQmtFUGRVRUJha0VCZFNBSGJHbzJBaXdnQlNBRktBSXdJZ1pCRUhSQkVIVWlDU0FEYkVFUWRTQUVJQWxzYWlBR1FROTFRUUZxUVFGMUlBZHNhallDTUNBRklBVW9BalFpQmtFUWRFRVFkU0lKSUFOc1FSQjFJQVFnQ1d4cUlBWkJEM1ZCQVdwQkFYVWdCMnhxTmdJMElBVWdCU2dDT0NJR1FSQjBRUkIxSWdrZ0EyeEJFSFVnQkNBSmJHb2dCa0VQZFVFQmFrRUJkU0FIYkdvMkFqZ2dCU0FESUFVb0Fqd2lCa0VRZEVFUWRTSUpiRUVRZFNBRUlBbHNhaUFHUVE5MVFRRnFRUUYxSUFkc2FqWUNQQXNnRGtFS2JDQUJhaUVESUFBZ0R6WUNBQUpBQW44Q1FBSkFJQUFvQXNBZ1JRMEFJQUFvQXNRZ1FRSkhEUUFnRGtFQlN3MEFJQXRCQWtZTkFDQURRZ0EzQVdBZ0EwRUFPd0ZvSUFOQmdDQTdBV1FnQ0NBQUtBS0VFaUlHTmdJQURBRUxJQXRCQWtjRVFDQUFLQUtjRWlFSklCTU1BZ3NnQ0NnQ0FDRUdDd0pBUVFBZ0RpQW1JQTVCQWtaeEcwVUVRQ0FBS0FLZ0VpSUhJQVlnQUNnQ3BCSWlCR3ByUVFKcklRZ2dEa0VDUmdSQUlBQWdCMEVCZEdwQnhBcHFJQUlnQUNnQ25CSkJBblFRQkJvZ0FDZ0NvQkloQnlBQUtBS2tFaUVFQ3lBWElBaEJBWFJxSUFBZ0FDZ0NuQklnRG13Z0NHcEJBWFJxUWNRS2FpQU5JQWNnQ0dzZ0JCQkhJQTVGQkVBZ0FTNEJpQUVpQkNBS1FmLy9BM0ZzUVJCMUlBUWdDa0VRZFd4cVFRSjBJUW9MSUFaQmYwZ05BU0FHUVFGcUlRUWdDa0gvL3dOeElRY2dDa0VRZFNFS0lBQW9BcUFTSVFsQkFDRUlBMEFnRWlBUUlBaEJmM01pQzJwQkFuUnFJQWNnRnlBSklBdHFRUUYwYWk0QkFDSUxiRUVRZFNBS0lBdHNhallDQUNBRUlBaEdJUXNnQ0VFQmFpRUlJQXRGRFFBTERBRUxJQWRCZ0lBRVJnMEFJQVpCZjBnTkFDQUdRUUZxSVFRZ0IwSC8vd054SVFvZ0IwRVFkU0VKUVFBaENBTkFJQklnRUNBSVFYOXpha0VDZEdvaUN5QUxLQUlBSWd0QkVIUkJFSFVpRFNBS2JFRVFkU0FKSUExc2FpQUxRUTkxUVFGcVFRRjFJQWRzYWpZQ0FDQUVJQWhISVFzZ0NFRUJhaUVJSUFzTkFBc0xJQUFvQXB3U0lnbEJBVWdOQVNBUUlBWnJRUUowSUJKcVFRaHFJUWdnQXk0QmFDRUVJQU11QVdZaENpQURMZ0ZrSVFZZ0F5NEJZaUVMSUFNdUFXQWhBMEVBSVFjRFFDQVlJQWRCQW5RaURXb2dEU0FUYWlnQ0FDQUlLQUlBSWcxQkVIVWdBMndnRFVILy93TnhJQU5zUVJCMWFpQUlRUVJyS0FJQUlnMUJFSFVnQzJ4cUlBMUIvLzhEY1NBTGJFRVFkV29nQ0VFSWF5Z0NBQ0lOUVJCMUlBWnNhaUFOUWYvL0EzRWdCbXhCRUhWcUlBaEJER3NvQWdBaURVRVFkU0FLYkdvZ0RVSC8vd054SUFwc1FSQjFhaUFJUVJCcktBSUFJZzFCRUhVZ0JHeHFJQTFCLy84RGNTQUViRUVRZFdwQkFYUnFRUVJxSWcwMkFnQWdFaUFRUVFKMGFpQU5RUUYwTmdJQUlCQkJBV29oRUNBSVFRUnFJUWdnQjBFQmFpSUhJQWxIRFFBTElCZ0xJU2NnQ1VFQlNBMEFJQTlCQ25SQkVIVWhDeUFBS0FLa0VpSW9RUUYxSVNrZ0QwRVZkVUVCYWtFQmRTRXFJQVVvQWh3aEJDQUZLQUlrSVFZZ0JTZ0NMQ0VLSUFVb0FqUWhBeUFGS0FJOElRaEJBQ0VISUF3dUFSNGhEeUFNTGdFY0lRMGdEQzRCR2lFVUlBd3VBUmdoR1NBTUxnRVdJUm9nREM0QkZDRWJJQXd1QVJJaEhDQU1MZ0VRSVIwZ0RDNEJEaUVlSUF3dUFRd2hIeUFNTGdFS0lTQWdEQzRCQ0NFaElBd3VBUVloSWlBTUxnRUVJU01nREM0QkFpRWtJQXd1QVFBaEpRTkFJQWhCRUhVZ0pXd2dLV29nQ0VILy93TnhJQ1ZzUVJCMWFpQUhRUUowSWhVZ0JXb2lDQ2dDT0NJTVFSQjFJQ1JzYWlBTVFmLy9BM0VnSkd4QkVIVnFJQU5CRUhVZ0kyeHFJQU5CLy84RGNTQWpiRUVRZFdvZ0NDZ0NNQ0lEUVJCMUlDSnNhaUFEUWYvL0EzRWdJbXhCRUhWcUlBcEJFSFVnSVd4cUlBcEIvLzhEY1NBaGJFRVFkV29nQ0NnQ0tDSUtRUkIxSUNCc2FpQUtRZi8vQTNFZ0lHeEJFSFZxSUFaQkVIVWdIMnhxSUFaQi8vOERjU0FmYkVFUWRXb2dDQ2dDSUNJR1FSQjFJQjVzYWlBR1FmLy9BM0VnSG14QkVIVnFJQVJCRUhVZ0hXeHFJQVJCLy84RGNTQWRiRUVRZFdvZ0NDZ0NHQ0lFUVJCMUlCeHNhaUFFUWYvL0EzRWdIR3hCRUhWcUlRUWdCU0FIUVJCcVFRSjBhZ0ovQW44Z0tFRVFSZ1JBSUFRZ0NDZ0NGQ0lyUVJCMUlCdHNhaUFyUWYvL0EzRWdHMnhCRUhWcUlBZ29BaEFpQkVFUWRTQWFiR29nQkVILy93TnhJQnBzUVJCMWFpQUlLQUlNSWdSQkVIVWdHV3hxSUFSQi8vOERjU0FaYkVFUWRXb2dDQ2dDQ0NJRVFSQjFJQlJzYWlBRVFmLy9BM0VnRkd4QkVIVnFJQWdvQWdRaUJFRVFkU0FOYkdvZ0JFSC8vd054SUExc1FSQjFhaUFJS0FJQUlnUkJFSFVnRDJ4cUlBUkIvLzhEY1NBUGJFRVFkV29oQkFzZ0JBdEJnSUNBUUNBRVFZQ0FnRUJLR3lJRVFmLy8vejhnQkVILy8vOC9TQnRCQkhRaUJDQVZJQ2RxS0FJQUlnaHFJaFZCQUU0RVFDQVZRWUNBZ0lCNElBUWdDSEZCZjBvYkRBRUxRZi8vLy84SElCVWdCQ0FJY2tGL1Noc0xJZ2cyQWdBZ0VTQUhRUUYwYWtILy93RkJnSUIrSUFoQkVIVWdDMndnQ0NBcWJHb2dDRUgvL3dOeElBdHNRUkIxYWlJRVFRZDJRUUZxUVFGMklBUkJnUC8vZTBnYklBUkIvLzcvQTBvYk93RUFJQVloQkNBS0lRWWdBeUVLSUF3aEF5QUhRUUZxSWdjZ0NVY05BQXNMSUFVZ0JTQUpRUUowSWdScUlnTXBBZ0EzQWdBZ0JTQURLUUk0TndJNElBVWdBeWtDTURjQ01DQUZJQU1wQWlnM0FpZ2dCU0FES1FJZ053SWdJQVVnQXlrQ0dEY0NHQ0FGSUFNcEFoQTNBaEFnQlNBREtRSUlOd0lJSUJFZ0NVRUJkR29oRVNBRUlCTnFJUk1nRGtFQmFpSU9JQUFvQXBRU1NBMEFDd3NnQUVHRUNtb2lBQ0FGS1FJQU53SUFJQUFnQlNrQ09EY0NPQ0FBSUFVcEFqQTNBakFnQUNBRktRSW9Od0lvSUFBZ0JTa0NJRGNDSUNBQUlBVXBBaGczQWhnZ0FDQUZLUUlRTndJUUlBQWdCU2tDQ0RjQ0NDQVdRU0JxSkFBTGhnWUJBbjhqQUVFUWF5SUdKQUFnQmtFQU9nQVBJQUpCQ0U0RVFDQURRUUYwSUFScVFSQjBRUkIxUVFkc1FhQTVhaUVESUFKQkNHcEJCSFVpQWtFQklBSkJBVW9iSVFSQkFDRUNBMEFDUUNBRklBSkJBblJxS0FJQUlnZEJBVWdOQUNBR0lBTWdCMEVmY1NJSFFRWWdCMEVHU1J0cUxRQUFPZ0FPSUFFdUFRQkJBVTRFUUNBQklBQWdCa0VPYWtFSUVBTkJBWFJCQVdzZ0FTOEJBR3c3QVFBTElBRXVBUUpCQUVvRVFDQUJJQUFnQmtFT2FrRUlFQU5CQVhSQkFXc2dBUzhCQW13N0FRSUxJQUV1QVFSQkFVNEVRQ0FCSUFBZ0JrRU9ha0VJRUFOQkFYUkJBV3NnQVM4QkJHdzdBUVFMSUFFdUFRWkJBVTRFUUNBQklBQWdCa0VPYWtFSUVBTkJBWFJCQVdzZ0FTOEJCbXc3QVFZTElBRXVBUWhCQVU0RVFDQUJJQUFnQmtFT2FrRUlFQU5CQVhSQkFXc2dBUzhCQ0d3N0FRZ0xJQUV1QVFwQkFVNEVRQ0FCSUFBZ0JrRU9ha0VJRUFOQkFYUkJBV3NnQVM4QkNtdzdBUW9MSUFFdUFReEJBVTRFUUNBQklBQWdCa0VPYWtFSUVBTkJBWFJCQVdzZ0FTOEJER3c3QVF3TElBRXVBUTVCQVU0RVFDQUJJQUFnQmtFT2FrRUlFQU5CQVhSQkFXc2dBUzhCRG13N0FRNExJQUV1QVJCQkFVNEVRQ0FCSUFBZ0JrRU9ha0VJRUFOQkFYUkJBV3NnQVM4QkVHdzdBUkFMSUFFdUFSSkJBVTRFUUNBQklBQWdCa0VPYWtFSUVBTkJBWFJCQVdzZ0FTOEJFbXc3QVJJTElBRXVBUlJCQVU0RVFDQUJJQUFnQmtFT2FrRUlFQU5CQVhSQkFXc2dBUzhCRkd3N0FSUUxJQUV1QVJaQkFVNEVRQ0FCSUFBZ0JrRU9ha0VJRUFOQkFYUkJBV3NnQVM4QkZtdzdBUllMSUFFdUFSaEJBVTRFUUNBQklBQWdCa0VPYWtFSUVBTkJBWFJCQVdzZ0FTOEJHR3c3QVJnTElBRXVBUnBCQVU0RVFDQUJJQUFnQmtFT2FrRUlFQU5CQVhSQkFXc2dBUzhCR213N0FSb0xJQUV1QVJ4QkFVNEVRQ0FCSUFBZ0JrRU9ha0VJRUFOQkFYUkJBV3NnQVM4QkhHdzdBUndMSUFFdUFSNUJBVWdOQUNBQklBQWdCa0VPYWtFSUVBTkJBWFJCQVdzZ0FTOEJIbXc3QVI0TElBRkJJR29oQVNBQ1FRRnFJZ0lnQkVjTkFBc0xJQVpCRUdva0FBdGhBUUovSUFBUUZTSUJCRUJCbVBzQktBSUFJZ0JGQkVCQkNCQVZJZ0JCQURZQ0JDQUFJQUUyQWdCQm1Qc0JJQUEyQWdBZ0FROExBMEFnQUNJQ0tBSUVJZ0FOQUF0QkNCQVZJZ0JCQURZQ0JDQUFJQUUyQWdBZ0FpQUFOZ0lFQ3lBQkM5TURBUVovSXdCQkVHc2lCU1FBQWtBZ0FDZ0N3Q0FFUUNBQVFZZ2hhaUFBUVl3aGFpQUJJQUlRR2lBQVFmd2dha0VCTmdJQURBRUxBa0FnQUVIOElHb29BZ0JGRFFBZ0JVRUlhaUFGUVF4cUlBRWdBaEFhQWtBZ0JTZ0NEQ0lESUFCQmpDRnFLQUlBSWdSS0JFQWdBRUdJSVdvaUJ5QUhLQUlBSUFNZ0JHdDFOZ0lBREFFTElBTWdCRTROQUNBRklBVW9BZ2dnQkNBRGEzVTJBZ2dMSUFVb0FnZ2lCaUFBUVlnaGFpZ0NBQ0lEVEEwQUlBQWdBeUFEWnlJRFFRRnJkQ0lJTmdLSUlVRUFJUWRCQUNFRUlBZ2dCa0VaSUFOcklnTkJBQ0FEUVFCS0czVWlBMEVCSUFOQkFVb2JiU0lEUVFGT0JFQUNRRUVZSUFObklnUnJJZ1pGRFFBZ0EwSC9BRTBFUUNBRElBUkJHR3QwSUFOQk9DQUVhM1p5SVFNTUFRc2dBeUFFUVFocWRDQURJQVoyY2lFREMwR0FnQUpCaHVrQ0lBUkJBWEViSUFSQkFYWjJJZ1FnQTBIL0FIRkJnSURVQm14QkVIWnNRUkIySUFScVFRUjBJUVFMUVlDQUJDQUVheUFDYlNFRElBSkJBVWdOQUNBRFFRSjBJUU1EUUNBQklBZEJBWFJxSWdZZ0JpNEJBQ0lHSUFSQi9QOERjV3hCRUhZZ0JFRVFkaUFHYkdvN0FRQWdBeUFFYWlJRVFZQ0FCRW9OQVNBSFFRRnFJZ2NnQWtnTkFBc0xJQUJCQURZQy9DQUxJQVZCRUdva0FBdm1BZ0VIZnlNQUlnZ2hEU0FJSUFaQkFuUkJEMnBCY0hGcklnb2tBQ0FHUVFGT0JFQWdCMEVDYXlBR2JDRU1JQVVvQWdBaUNFRVFkRUVRZFNFTElBaEJEM1ZCQVdwQkFYVWhEa0VBSVFnRFFDQUtJQWhCQVhScVFmLy9BVUdBZ0g0Z0N5QUVJQWdnREdwQkFuUnFLQUlBSWdsQi8vOERjV3hCRUhVZ0N5QUpRUkIxYkdvZ0NTQU9iR29pQ1VFSWRpQUpRWUNBZ0h4SUd5QUpRZi8vL3dOS0d6c0JBQ0FJUVFGcUlnZ2dCa2NOQUFzZ0IwRUJheUFHYkNFTElBb2dCa0VCZEdvaENTQUZLQUlFSWdkQkVIUkJFSFVoQlNBSFFROTFRUUZxUVFGMUlReEJBQ0VJQTBBZ0NTQUlRUUYwYWtILy93RkJnSUIrSUFVZ0JDQUlJQXRxUVFKMGFpZ0NBQ0lIUWYvL0EzRnNRUkIxSUFVZ0IwRVFkV3hxSUFjZ0RHeHFJZ2RCQ0hZZ0IwR0FnSUI4U0JzZ0IwSC8vLzhEU2hzN0FRQWdDRUVCYWlJSUlBWkhEUUFMQ3lBQUlBRWdDaUFHRUJvZ0FpQURJQW9nQmtFQmRHb2dCaEFhSUEwa0FBdndGQUVmZnlNQVFVQnFJZ2NrQUNBSElBQW9BcGdTSUFBb0FxQVNha0VDZEVFUGFrRndjV3NpRHlJRUpBQWdCQ0FBS0FLZ0VrRUJkRUVQYWtGd2NXc2lEQ1FBSUFjZ0FFR1VJV29vQWdCQkJuVTJBZ2dnQnlBQVFaZ2hhaWdDQUNJV1FRWjFJaGMyQWd3Z0FDZ0N5QklFUUNBQVFmSWdha0lBTndFQUlBQkI2aUJxUWdBM0FRQWdBRUhpSUdwQ0FEY0JBQ0FBUWRvZ2FrSUFOd0VBQ3lBSFFUUnFJQWRCUEdvZ0IwRXdhaUFIUVRocUlBQkJCR29nQjBFSWFpQUFLQUtjRWlBQUtBS1VFaEJ6SUFCQm9DRnFLQUlBSVFnQ1FDQUhLQUkwSUFjb0FqaDFJQWNvQWpBZ0J5Z0NQSFZJQkVBZ0NFRUJheUVOSUFCQnBDRnFLQUlBSVFnTUFRc2dBRUdrSVdvb0FnQWhEUXNnQUVHRUlXb3ZBUUFoQ1NBQUtBTEFJQ0VFSUFBb0FzUWdJUVlnQUVIYUlHb2lCU0FBS0FLa0VrSHgrZ01RS2lBSFFSQnFJQVVnQUNnQ3BCSWlBMEVCZEJBRUdpQUVRUUVnQkVFQlNCdEJBWFFpQzBHdUNXb2dDMEd5Q1dvZ0JrRUNSaHN1QVFBaERnSkFJQUFvQXNBZ0RRQWdBQ2dDeENCQkFrWUVRQ0FBUVpBaGFpNEJBRUdBZ0FFZ0FFSFlJR292QVFBZ0FFSFdJR292QVFBZ0FFSFVJR292QVFBZ0FDOEIwQ0FnQUVIU0lHb3ZBUUJxYW1wcWF5SUVRYzBaSUFSQkVIUkJFSFZCelJsS0cwSC8vd054YkVFT2RpRUpEQUVMSUFVZ0F4QWRJZ1JCZ0lDQXdBQWdCRUdBZ0lEQUFFZ2JJZ1JCZ0lDQUFpQUVRWUNBZ0FKS0d5SUVRUU4wUWZqL0EzRWdEbXhCRUhVZ0JFRU5ka0gvL3dOeElBNXNha0VPZFNFT0lBQW9BcVFTSVFOQmdJQUJJUWtMSUFCQmdDRnFLQUlBSVJ3Z0RDQUFLQUtnRWlJRUlBTnJJQUFvQXN3Z1FRZDFRUUZxUVFGMUloTnJRUUpySWdaQkFYUWlCV29nQUNBRmFrSEVDbW9nQjBFUWFpQUVJQVpySUFNUVIwRUFJQUFvQXBnaElnVWdCU0FGUVI5MUlnTnFJQU56SWhCbklnTkJBV3QwSWdWQi8vOERjVUgvLy8vL0FTQUZRUkIxSWdwdEloRkJFSFFpRWtFUWRTSUZiRUVRZFNBRklBcHNha0VEZEdzaUNpQVJRUTkxUVFGcVFRRjFiQ0FTYWlBS1FSQjFJQVZzYWlBS1Fmai9BM0VnQld4QkVIVnFJUVVDZnlBUVFmLy9BMDBFUUVILy8vLy9CeUFEUVJCcklnTjJJZ3BCZ0lDQWdIZ2dBM1VpRUNBRklBVWdFRWdiSUFVZ0Nrb2JJQU4wREFFTElBVkJFQ0FEYTNVTElRVWdBQ2dDcEJJaUVDQUdhaUlESUFBb0FxQVNJaEZJQkVBZ0JVSC8vLy8vQXlBRlFmLy8vLzhEU0JzaUJVSC8vd054SVFZZ0JVRVFkU0VGQTBBZ0R5QURRUUowYWlBR0lBd2dBMEVCZEdvdUFRQWlDbXhCRUhVZ0JTQUtiR28yQWdBZ0EwRUJhaUlESUJGSURRQUxDeUFBS0FLVUVpSVlRUUZPQkVBZ0NDQU5iQ0lGUVlBQklBVkJnQUZLRzBFQ2RDQUFha0g4QTJzaEdTQUxRYW9KYWk0QkFDRUtJQUF1QVl3U1FZQWtiQ0VTSUE1QkVIUkJFSFVoR2lBQVFkZ2dhaThCQUNFRElBQkIxaUJxTHdFQUlRc2dBRUhVSUdvdkFRQWhCU0FBUWRJZ2FpOEJBQ0VJSUFBdkFkQWdJUVlnQUNnQ25CSWhGQU5BQWtBZ0ZFRUFUQVJBSUFsQkVIUkJFSFVoRFNBRFFSQjBRUkIxSVF3Z0MwRVFkRUVRZFNFTElBVkJFSFJCRUhVaEJTQUlRUkIwUVJCMUlRZ2dCa0VRZEVFUWRTRUdEQUVMSUFsQkVIUkJFSFVoRFNBRFFSQjBRUkIxSVF3Z0MwRVFkRUVRZFNFTElBVkJFSFJCRUhVaEJTQUlRUkIwUVJCMUlRZ2dCa0VRZEVFUWRTRUdJQVFnRTJ0QkFuUWdEMnBCQ0dvaEEwRUFJUTREUUNBUElBUkJBblJxSUFNb0FnQWlDVUVRZFNBR2JDQUpRZi8vQTNFZ0JteEJFSFZxSUFOQkJHc29BZ0FpQ1VFUWRTQUliR29nQ1VILy93TnhJQWhzUVJCMWFpQURRUWhyS0FJQUlnbEJFSFVnQld4cUlBbEIvLzhEY1NBRmJFRVFkV29nQTBFTWF5Z0NBQ0lKUVJCMUlBdHNhaUFKUWYvL0EzRWdDMnhCRUhWcUlBTkJFR3NvQWdBaUNVRVFkU0FNYkdvZ0NVSC8vd054SUF4c1FSQjFhaUFaSUJ4QnRZak8zUUJzUWV2RzViQURhaUljUVJkMlFmd0RjV29vQWdBaUNVRVFkU0FOYkdvZ0NVSC8vd054SUExc1FSQjFha0VDZEVFSWFqWUNBQ0FFUVFGcUlRUWdBMEVFYWlFRElBNUJBV29pRGlBVVJ3MEFDd3NnQUNBQUtBTE1JQ0lEUVJCMVFZOEZiQ0FEYWlBRFFmLy9BM0ZCandWc1FSQjJhaUlESUJJZ0F5QVNTQnNpQXpZQ3pDQWdBMEVIZFVFQmFrRUJkU0VUSUEwZ0dteEJEM1loQ1NBS0lBeHNRUTkySVFNZ0NpQUxiRUVQZGlFTElBVWdDbXhCRDNZaEJTQUlJQXBzUVE5MklRZ2dCaUFLYkVFUGRpRUdJQnRCQVdvaUd5QVlSdzBBQ3lBQUlBTTdBZGdnSUFBZ0N6c0IxaUFnQUNBRk93SFVJQ0FBSUFnN0FkSWdJQUFnQmpzQjBDQUxJQkZCQW5RZ0QycEJRR29pQmlBQUtRS0VDamNDQUNBR0lBQkJ2QXBxS1FJQU53STRJQVlnQUVHMENtb3BBZ0EzQWpBZ0JpQUFRYXdLYWlrQ0FEY0NLQ0FHSUFCQnBBcHFLUUlBTndJZ0lBWWdBRUdjQ21vcEFnQTNBaGdnQmlBQVFaUUthaWtDQURjQ0VDQUdJQUJCakFwcUtRSUFOd0lJSUFBb0FwZ1NJZzVCQVU0RVFDQVFRUUYxSVI0Z0YwRVFkRUVRZFNFS0lCWkJGWFZCQVdwQkFYVWhIeUFHS0FJY0lRUWdCaWdDSkNFTklBWW9BaXdoRENBR0tBSTBJUVVnQmlnQ1BDRURJQWN1QVNJaER5QUhMZ0VnSVJFZ0J5NEJIaUVTSUFjdUFSd2hGQ0FITGdFYUlSWWdCeTRCR0NFWElBY3VBUlloR0NBSExnRVVJUmtnQnk0QkVpRWFJQWN1QVJBaEd5QVFRUXRJSVNCQkFDRUlBMEFnQTBFUWRTQWJiQ0FlYWlBRFFmLy9BM0VnRzJ4QkVIVnFJQWhCQW5RZ0Jtb2lBeWdDT0NJTFFSQjFJQnBzYWlBTFFmLy9BM0VnR214QkVIVnFJQVZCRUhVZ0dXeHFJQVZCLy84RGNTQVpiRUVRZFdvZ0F5Z0NNQ0lGUVJCMUlCaHNhaUFGUWYvL0EzRWdHR3hCRUhWcUlBeEJFSFVnRjJ4cUlBeEIvLzhEY1NBWGJFRVFkV29nQXlnQ0tDSU1RUkIxSUJac2FpQU1RZi8vQTNFZ0ZteEJFSFZxSUExQkVIVWdGR3hxSUExQi8vOERjU0FVYkVFUWRXb2dBeWdDSUNJTlFSQjFJQkpzYWlBTlFmLy9BM0VnRW14QkVIVnFJQVJCRUhVZ0VXeHFJQVJCLy84RGNTQVJiRUVRZFdvZ0F5Z0NHQ0lFUVJCMUlBOXNhaUFFUWYvL0EzRWdEMnhCRUhWcUlRUWdDRUVRYWlFVlFRb2hBeUFnUlFSQUEwQWdCQ0FIUVJCcUlBTkJBWFJxTGdFQUloMGdCaUFWSUFOQmYzTnFRUUowYWlnQ0FDSWhRUkIxYkdvZ0lVSC8vd054SUIxc1FSQjFhaUVFSUFOQkFXb2lBeUFRUncwQUN3c0NmeUFHSUJWQkFuUnFJaDBvQWdBaUF5QUVRWUNBZ0VBZ0JFR0FnSUJBU2hzaUJFSC8vLzgvSUFSQi8vLy9QMGdiUVFSMElnUnFJaFZCQUU0RVFDQVZRWUNBZ0lCNElBTWdCSEZCZjBvYkRBRUxRZi8vLy84SElCVWdBeUFFY2tGL1Noc0xJUU1nSFNBRE5nSUFJQUlnQ0VFQmRHcEIvLzhCUVlDQWZpQURRUkIxSUFwc0lBTWdIMnhxSUFOQi8vOERjU0FLYkVFUWRXb2lCRUVIZGtFQmFrRUJkaUFFUVlELy8zdElHeUFFUWYvKy93TktHenNCQUNBTklRUWdEQ0VOSUFVaERDQUxJUVVnQ0VFQmFpSUlJQTVIRFFBTEN5QUFRWVFLYWlJQ0lBWWdEa0VDZEdvaUJDa0NBRGNDQUNBQ0lBUXBBamczQWpnZ0FpQUVLUUl3TndJd0lBSWdCQ2tDS0RjQ0tDQUNJQVFwQWlBM0FpQWdBaUFFS1FJWU53SVlJQUlnQkNrQ0VEY0NFQ0FDSUFRcEFnZzNBZ2dnQUNBSk93R0VJU0FBSUJ3MkFvQWhJQUVnRXpZQ0RDQUJJQk0yQWdnZ0FTQVROZ0lFSUFFZ0V6WUNBQ0FIUVVCckpBQUxnd1lCRG44Z0FTQUNRUUYwYWlFTUlBQWdBa0VCYXlJTFFRRjBhaUVKSUFKQkFrZ2hEZ0pBQTBBZ0FDNEJBQ0lGSUFFdUFRQWlDR3NoQkVFQklRTkJBQ0VHSUE1RkJFQURRQ0FGUVJCMElRY2dBQ0FEUVFGMElncHFMZ0VBSWdVZ0IwRVFkV3NnQVNBS2FpNEJBR3NpQnlBRUlBUWdCMG9pQnhzaEJDQURJQVlnQnhzaEJpQURRUUZxSWdNZ0FrY05BQXNMUVlDQUFpQU1MZ0VBSWdjZ0NTNEJBR3BySWdNZ0JDQURJQVJJSWdNYlFYOUtEUUVDUUNBQ0lBWWdBeHNpQlVVRVFDQUFJQWc3QVFBTUFRc0NRQUpBSUFJZ0JVY0VRQ0FGUVFGT0RRRkJBQ0VJREFJTElBbEJnSUIrSUFkck93RUFEQUlMUVFFaEF5QUZRUUZHRFFBRFFDQUlJQUVnQTBFQmRHb3VBUUJxSVFnZ0EwRUJhaUlESUFWSERRQUxDeUFJSUFFZ0JVRUJkQ0lQYWlJUUxnRUFRUUYxSWdwcUlRUkJnSUFDSVFZQ1FDQUNJQVZNRFFCQmdJQUNJQWRySVFZZ0JTQUxJZ05PRFFBRFFDQUdJQUVnQTBFQmRHb3VBUUJySVFZZ0EwRUJheUlESUFWS0RRQUxDeUFBSUE5cUlnZ3VBUUFnQUNBRlFRRnJRUUYwYWlJSExnRUFhaUlEUVFGMUlBTkJBWEZxSVFVQ1FDQUdJQXBySWdNZ0JFZ0VRQ0FGSUFRaUJrb05BU0FESUFVZ0F5QUZTaHNoQmd3QkN5QURJZ1lnQlVnTkFDQUVJQVVnQkNBRlNoc2hCZ3NnQnlBR0lBcHJJZ1k3QVFBZ0NDQUdJQkF2QVFCcU93RUFDeUFOUVFGcUlnMUJGRWNOQUFzZ0FDQUNFR1VnQUNBQUxnRUFJZ1lnQVM0QkFDSURJQU1nQmtnYklnUTdBUUFnQWtFQ1NDSUdSUVJBUVFFaEF3TkFJQUFnQTBFQmRDSUxhaUlGSUFVdUFRQWlCU0FCSUF0cUxnRUFJQVJCRUhSQkVIVnFJZ1JCLy84QklBUkIvLzhCU0JzaUJFR0FnSDRnQkVHQWdINUtHeUlFSUFRZ0JVZ2JJZ1E3QVFBZ0EwRUJhaUlESUFKSERRQUxDeUFKSUFrdUFRQWlBMEdBZ0FJZ0RDNEJBR3NpQkNBRElBUklHeUlFT3dFQUlBWU5BQ0FDUVFKcklRTURRQ0FBSUFOQkFYUWlBbW9pQmlBR0xnRUFJZ1lnQkVFUWRFRVFkU0FCSUFKcUxnRUNheUlDSUFJZ0Jrb2JJZ1E3QVFBZ0EwRUFTaUVDSUFOQkFXc2hBeUFDRFFBTEN3dk1BZ0VKZnlNQVFkQUFheUlGSkFBZ0JVRWdhaUFGUVVCcklBSWdBU3dBQUJCR0lBSXZBUUlpQTBFUWRFRVFkU0lIUVFGSUlndEZCRUFnQWk0QkJDRUlBMEFnQlNBRFFRRnJJZ1pCQVhScUlBRWdBMm9zQUFBaUNrRUtkQ0lFUWVZQWF5QUVRZVlBY2lBS1FSOTFjU0FLUVFCS0d5SUVRUkIxSUFoc0lBVkJRR3NnQm1vdEFBQWdDVUVRZEVFUWRXeEJDSFZxSUFSQi92OERjU0FJYkVFUWRXb2lDVHNCQUNBRFFRRktJUVFnQmlFRElBUU5BQXNMSUF0RkJFQWdBU3dBQUNBSGJDSUJJQUlvQWdocUlRUWdBaWdDRENBQlFRRjBhaUVHUVFBaEF3TkFJQUFnQTBFQmRDSUJhaUFCSUFWcUxnRUFRUTUwSUFFZ0Jtb3VBUUJ0SUFNZ0JHb3RBQUJCQjNScUlnRkJBQ0FCUVFCS0d5SUJRZi8vQVNBQlFmLy9BVWdiT3dFQUlBTkJBV29pQXlBQ0xnRUNJZ2RJRFFBTEN5QUFJQUlvQWlRZ0J4QjFJQVZCMEFCcUpBQUwyQUlCQlg4Q1FDQUNRUUZJRFFBQ1FBTkFRUUFoQTBFQUlRUURRQ0FCSUFOQkFuUnFLQUlBSWdVZ0JVRWZkU0lGYWlBRmN5SUZJQVFnQkNBRlNDSUZHeUVFSUFNZ0JpQUZHeUVHSUFOQkFXb2lBeUFDUncwQUN5QUVRUVIyUVFGcVFRRjJJZ05CZ0lBQ1R3UkFJQUVnQWtHKy93TWdBMEgrL3drZ0EwSCsvd2xJR3lJRFFRNTBRWUNBLy84QmF5QURJQVpCQVdwc1FRSjFiV3NRS1NBSFFRRnFJZ2RCQ2tjTkFRd0NDd3NnQjBFS1JnMEFJQUpCQVVnTkFVRUFJUU1EUUNBQUlBTkJBWFJxSUFFZ0EwRUNkR29vQWdCQkJIVkJBV3BCQVhZN0FRQWdBMEVCYWlJRElBSkhEUUFMREFFTElBSkJBVWdOQUVFQUlRTURRQ0FBSUFOQkFYUnFBbjlCLy84QklBRWdBMEVDZEdvaUJpZ0NBRUVFZFNJRVFmNy9BMG9OQUJwQmdJQitJQVJCLy85N1NBMEFHaUFFUVFGcVFRRjFDeUlFT3dFQUlBWWdCRUVGZERZQ0FDQURRUUZxSWdNZ0FrY05BQXNMQzRvQkFRTi9Jd0JCRUdzaUJDUUFBa0FDUUFKL1FaRDdBU2dDQUNJRkJFQWdBMEVCU0FSL1FYOEZJQVVnQUNBQklBSWdBMEVBUVFBUVRnc01BUXRCbFBzQktBSUFJZ1ZGRFFFZ0JTQUFJQUVnQWlBREVINExJZ1pCQUVvTkFRc2dCQ0FETmdJTUlBUWdBallDQ0NBRUlBRTJBZ1FnQkNBQU5nSUFRYlFJSUFRUUhnc2dCRUVRYWlRQUlBWUxreElCSG44akFFRWdheUlLSVFnZ0NpUUFJQUFvQW93U0lna2dBRUc4SUdvb0FnQkhCRUJCLy84QklBQW9BcVFTSWdaQkFXcHRJUWNnQmtFQlRnUkFBMEFnQUNBRVFRRjBha0hVSDJvZ0JTQUhhaUlGT3dFQUlBUkJBV29pQkNBR1J3MEFDd3NnQUNBSk5nSzhJQ0FBUWJRZ2FrS0FnSUNBZ0pDZUdEY0NBQXNDUUFKQUlBQW9Bc0FnUlFSQUFrQWdBQ2dDeENBTkFFRUFJUVFnQUNnQ3BCSWlCVUVBU2dSQUEwQWdBQ0FFUVFGMGFpSUdRZFFmYWlJSklBa3VBUUFpQ1NBR1FhZ1NhaTRCQUNBSmF5SUdRZi8vQTNGQjNQOEFiRUVRZGlBR1FSQjJRZHovQUd4cWFqc0JBQ0FFUVFGcUlnUWdCVWNOQUFzTElBQkIxQlZxSVFsQkFDRUVBa0FnQUNnQ2xCSWlCMEVBVEFSQVFRQWhCZ3dCQzBFQUlRWkJBQ0VGQTBBZ0FTQUVRUUowYWlnQ0VDSUxJQVVnQlNBTFNDSUxHeUVGSUFRZ0JpQUxHeUVHSUFSQkFXb2lCQ0FIUncwQUN3c2dBQ0FBS0FLY0VpSUZRUUowYWtIVUZXb2dDU0FIUVFKMFFRUnJJQVZzRUE0YUlBa2dBQ0FBS0FLY0VpSUZJQVpzUVFKMGFrRUVhaUFGUVFKMEVBUWFJQUFvQXBRU0lnbEJBVWdOQUNBQVFiUWdhaWdDQUNFRVFRQWhCUU5BSUFBZ0JDQUJJQVZCQW5ScUlnWkJFR29vQWdBZ0JHc2lCRUVRZFVHYUpHeHFJQVJCLy84RGNVR2FKR3hCRUhacUlnUTJBclFnSUFZb0FoQWlCaUFFUVJCMVFienFmbXdnQkdvZ0JFSC8vd054UWJ6cWZteEJFSFZxU0FSQUlBQWdCallDdENBZ0JpRUVDeUFGUVFGcUlnVWdDVWNOQUFzTElBQW9Bc0FnUlEwQkN5QUtJQU5CQW5SQnp3QnFRWEJ4YXlJSEpBQWdBRUdZSVdvb0FnQWlBVUVRZEVFUWRTSUZJQUJCaENGcUx3RUFJZ1JzUVJCMUlBVWdCRUVRZENJRVFSOTFiR29nQVVFUGRVRUJha0VCZFNBRVFSQjFiR29pQlVFUWRTRUVBbjhnQlVILy8vOEFURUVBSUFCQnRDQnFLQUlBSWdGQmdZQ0FCRWdiUlFSQVFRQWdBVUVRZFNJQklBRnNJQVFnQkd4QkJYUnJJZ1JCQVVnTkFSb0NRRUVZSUFSbklnRnJJZ1ZGRFFBZ0JFSC9BRTBFUUNBRUlBRkJHR3QwSUFSQk9DQUJhM1p5SVFRTUFRc2dCQ0FCUVFocWRDQUVJQVYyY2lFRUN5QUVRZjhBY1VHQWdOUUdiRUVRZGtHQWdBUnlRWUNBQWtHRzZRSWdBVUVCY1JzZ0FVRUJkblpzUVlDQWZIRU1BUXRCQUNBQlFSQjBRUkIxSWdZZ0FVRVFkV3dnQlVFUWRFRVFkU0lLSUFWQi8vOERjV3hCRUhVZ0JDQUtiR29nQlVFUGRVRUJha0VCZGlBRmJHcEJCWFJySUFZZ0FVSC8vd054YkVFUWRXb2dBVUVQZFVFQmFrRUJkU0FCYkdvaUJFRUJTQTBBR2dKQVFSZ2dCR2NpQVdzaUJVVU5BQ0FFUWY4QVRRUkFJQVFnQVVFWWEzUWdCRUU0SUFGcmRuSWhCQXdCQ3lBRUlBRkJDR3AwSUFRZ0JYWnlJUVFMUVlDQUFrR0c2UUlnQVVFQmNSc2dBVUVCZG5ZaUFTQUVRZjhBY1VHQWdOUUdiRUVRZG14QkVIWWdBV3BCQ0hRTElRRWdCMEZBYXlFS1FmOEJJUVVEUUNBRklnUkJBWFVoQlNBRElBUklEUUFMSUFCQnVDQnFLQUlBSVFZZ0EwRUJTQ0lKUlFSQVFRQWhCUU5BSUFvZ0JVRUNkR29nQUNBR1FiV0l6dDBBYkVIcnh1V3dBMm9pQmtFWWRTQUVjVUVDZEdwQjFCVnFLQUlBTmdJQUlBVkJBV29pQlNBRFJ3MEFDd3NnQUNBR05nSzRJQ0FJSUFCQjFCOXFJQUFvQXFRU0lBQW9Bc2dnRUNzZ0J5QUFRYXdnYWlrQ0FEY0NPQ0FISUFCQnBDQnFLUUlBTndJd0lBY2dBRUdjSUdvcEFnQTNBaWdnQnlBQVFaUWdhaWtDQURjQ0lDQUhJQUJCakNCcUtRSUFOd0lZSUFjZ0FFR0VJR29wQWdBM0FoQWdCeUFBUWZ3ZmFpa0NBRGNDQ0NBSElBQkI5QjlxSWdzcEFnQTNBZ0FnQ1VVRVFDQUJRUXAwUVJCMUlRd2dBQ2dDcEJJaUhrRUJkU0VmSUFGQkZYVkJBV3BCQVhVaElDQUhLQUljSVFVZ0J5Z0NKQ0VHSUFjb0Fpd2hDaUFIS0FJMElRRWdCeWdDUENFRUlBZ3VBUjRoRFNBSUxnRWNJUTRnQ0M0QkdpRVBJQWd1QVJnaEVDQUlMZ0VXSVJFZ0NDNEJGQ0VTSUFndUFSSWhFeUFJTGdFUUlSUWdDQzRCRGlFVklBZ3VBUXdoRmlBSUxnRUtJUmNnQ0M0QkNDRVlJQWd1QVFZaEdTQUlMZ0VFSVJvZ0NDNEJBaUViSUFndUFRQWhIRUVBSVFBRFFDQUVRUkIxSUJ4c0lCOXFJQVJCLy84RGNTQWNiRUVRZFdvZ0FFRUNkQ0FIYWlJRUtBSTRJZ2xCRUhVZ0cyeHFJQWxCLy84RGNTQWJiRUVRZFdvZ0FVRVFkU0FhYkdvZ0FVSC8vd054SUJwc1FSQjFhaUFFS0FJd0lnRkJFSFVnR1d4cUlBRkIvLzhEY1NBWmJFRVFkV29nQ2tFUWRTQVliR29nQ2tILy93TnhJQmhzUVJCMWFpQUVLQUlvSWdwQkVIVWdGMnhxSUFwQi8vOERjU0FYYkVFUWRXb2dCa0VRZFNBV2JHb2dCa0gvL3dOeElCWnNRUkIxYWlBRUtBSWdJZ1pCRUhVZ0ZXeHFJQVpCLy84RGNTQVZiRUVRZFdvZ0JVRVFkU0FVYkdvZ0JVSC8vd054SUJSc1FSQjFhaUFFS0FJWUlnVkJFSFVnRTJ4cUlBVkIvLzhEY1NBVGJFRVFkV29oQlFKL0FuOGdIa0VRUmdSQUlBVWdCQ2dDRkNJRlFSQjFJQkpzYWlBRlFmLy9BM0VnRW14QkVIVnFJQVFvQWhBaUJVRVFkU0FSYkdvZ0JVSC8vd054SUJGc1FSQjFhaUFFS0FJTUlnVkJFSFVnRUd4cUlBVkIvLzhEY1NBUWJFRVFkV29nQkNnQ0NDSUZRUkIxSUE5c2FpQUZRZi8vQTNFZ0QyeEJFSFZxSUFRb0FnUWlCVUVRZFNBT2JHb2dCVUgvL3dOeElBNXNRUkIxYWlBRUtBSUFJZ1ZCRUhVZ0RXeHFJQVZCLy84RGNTQU5iRUVRZFdvaEJRc2dCUXRCZ0lDQVFDQUZRWUNBZ0VCS0d5SUZRZi8vL3o4Z0JVSC8vLzgvU0J0QkJIUWlCU0FISUFCQkVHcEJBblJxSWlFb0FnQWlCR29pSFVFQVRnUkFJQjFCZ0lDQWdIZ2dCQ0FGY1VGL1Noc01BUXRCLy8vLy93Y2dIU0FFSUFWeVFYOUtHd3NoQkNBaElBUTJBZ0FnQWlBQVFRRjBhaUlGSUFVdUFRQkIvLzhCUVlDQWZpQUVRUkIxSUF4c0lBUWdJR3hxSUFSQi8vOERjU0FNYkVFUWRXb2lCVUVIZFVFQmFrRUJkU0FGUVlELy8zdElHeUFGUWYvKy93TktHMm9pQlVHQWdINGdCVUdBZ0g1S0d5SUZRZi8vQVNBRlFmLy9BVWdiT3dFQUlBWWhCU0FLSVFZZ0FTRUtJQWtoQVNBQVFRRnFJZ0FnQTBjTkFBc0xJQXNnQnlBRFFRSjBhaUlBS1FJQU53SUFJQXNnQUNrQ09EY0NPQ0FMSUFBcEFqQTNBakFnQ3lBQUtRSW9Od0lvSUFzZ0FDa0NJRGNDSUNBTElBQXBBaGczQWhnZ0N5QUFLUUlRTndJUUlBc2dBQ2tDQ0RjQ0NBd0JDeUFBUWZRZmFrRUFJQUFvQXFRU1FRSjBFQVVhQ3lBSVFTQnFKQUFMVlFFRWYwSC8vd0VnQUNnQ3BCSWlBa0VCYW0waEJDQUNRUUZPQkVBRFFDQUFJQUZCQVhScVFkUWZhaUFESUFScUlnTTdBUUFnQVVFQmFpSUJJQUpIRFFBTEN5QUFRYlFnYWtLQWdJQ0FnSkNlR0RjQ0FBdHlBQUpBSUFNRVFFRUFJUVlnQlVFQVRBMEJBMEFnQUNBQklBWnNJQUpxUVFKMGFpQURJQVFnQm14QkFuUnFLZ0lBT0FJQUlBWkJBV29pQmlBRlJ3MEFDd3dCQzBFQUlRWWdCVUVBVEEwQUEwQWdBQ0FCSUFac0lBSnFRUUowYWtFQU5nSUFJQVpCQVdvaUJpQUZSdzBBQ3dzTE53RUJmeU1BUVRCcklnSWtBRUVDRUF3YVFRRVFEQm9nQWlBQktBSUFOZ0lBSUFCQmpBSnFJQUlRaWdFaEFDQUNRVEJxSkFBZ0FBc2xBUUYvSXdCQkVHc2lBaVFBSUFJZ0FUWUNEQ0FBSUFFUWZDRUFJQUpCRUdva0FDQUFDNXNHQVExL0l3QkJnQUZySWdnaEJ5QUlKQUFDUUNBRVFRRklCRUJCZnlFRkRBRUxJQWNnQjBFSWFqWUNBRUY5SVFVZ0FDQUhFSDBOQUNBSUlBUWdCeWdDQ0VFWmJVRURiQ0lGSUFRZ0JVZ2JJZ1JCQTNSQkQycEJjSEZySWd3a0FFRUNFQXdoRUVFQkVBd2hFUUpBSUFKQkFFZ0VRRUYvSVFVTUFRc2dBZ1JBUVh3aEJTQUFLQUlFSWdwQkFYUkJBV3NnQWtvTkFRSkFJQXBCQVVnTkFDQUtRUUZySVE0Z0J5Z0NDQ0VQUVFBaENDQUJJUXNnQWlFRkEwQkJmQ0VHSUFWQkFVZ05BU0FMSUFVZ0NTQU9SeUFIUWY4QWFpQUhRUkJxUVFBZ0IwRU1haEEzSWdaQkFFZ05BU0FMSUFjb0Fnd2dEeENEQVNFTklBa0VRRUY4SVFZZ0NDQU5SdzBDQ3lBRklBY29BZ3dpQ0dzaEJTQUlJQXRxSVFzZ0RTSUlJUVlnQ1VFQmFpSUpJQXBIRFFBTEN5QUdRWDRnQmtFQVNCc2hCU0FFSUFaSURRRWdCa0VBU0EwQkN5QUFLQUlFSWdWQkFVNEVRQ0FDUVFCSElRc2dBRUdNQW1vaENDQU1RUVJxSVEwZ0FpRUpRUUFoQmdOQUlBc2dDVUVCU0hFRVFFRjlJUVVNQXdzZ0FDZ0NDQ0VLSUFkQkFEWUNFQ0FJSUFFZ0NTQU1JQVFnQmlBRlFRRnJSeUFIUVJCcUVFNGlCRUVCU0FSQUlBUWhCUXdEQ3lBUUlCRWdCaUFLU0J0QkEycEJmSEVoQ2lBSEtBSVFJZ1ZCQUNBQ0d5RU9JQUVnQldvaER3SkFJQUFvQWdnZ0Jrd0VRQ0FBSUFaQmZ4QklJZ1ZCZjBZTkFRTkFJQU1nQUNnQ0FDQUZJQXhCQVNBRVFRQkJBUkVIQUNBQUlBWWdCUkJJSWdWQmYwY05BQXNNQVFzZ0FDQUdRWDhRU2lJRlFYOUhCRUFEUUNBRElBQW9BZ0FnQlNBTVFRSWdCRUVBUVFFUkJ3QWdBQ0FHSUFVUVNpSUZRWDlIRFFBTEN5QUFJQVpCZnhCSklnVkJmMFlOQUFOQUlBTWdBQ2dDQUNBRklBMUJBaUFFUVFCQkFSRUhBQ0FBSUFZZ0JSQkpJZ1ZCZjBjTkFBc0xJQWdnQ21vaENDQUpJQTVySVFrZ0R5QUJJQUliSVFFZ0JrRUJhaUlHSUFBb0FnUWlCVWdOQUFzTFFRQWhCaUFBS0FJQUlnVkJBRW9FUUFOQUlBQWdCbW90QUF4Qi93RkdCRUFnQXlBRklBWkJBRUVBSUFSQkFFRUJFUWNBSUFBb0FnQWhCUXNnQmtFQmFpSUdJQVZJRFFBTEN5QUVJUVVMQ3lBSFFZQUJhaVFBSUFVTGdnRUJBWDhDUUNBQlFRRnJRZjRCU3dSQUlBSkZEUUVnQWtGL05nSUFRUUFQQzBFQ0VBeEJBMnBCZkhGQkFYUkJBUkFNUVFOcVFYeHhRUUYwYWtHTUFtb1FGU0lEUlFSQVFRQWhBeUFDUlEwQklBSkJlVFlDQUVFQUR3c2dBeUFBSUFFUWdBRWhBQ0FDQkVBZ0FpQUFOZ0lBQ3lBQVJRMEFJQU1RQ0VFQUlRTUxJQU1MN2dFQkJIOUJmeUVFQWtBZ0FrRUJhMEgrQVVzTkFDQUFRUUkyQWdnZ0FFRUVOZ0lFSUFBZ0FqWUNBQU5BSUFBZ0Eyb2dBMEdBQ0dvdEFBQTZBQXdnQTBFQmFpSURJQUpIRFFBTElBQVFnZ0ZGRFFBZ0FFR01BbW9oQTBFQ0VBd2hBa0VCRUF3aEJRSkFJQUFvQWdoQkFVZ0VRRUVBSVFJTUFRc2dBa0VEYWtGOGNTRUdRUUFoQWdOQUlBTWdBVUVDRURBaUJBMENJQU1nQm1vaEF5QUNRUUZxSWdJZ0FDZ0NDRWdOQUFzTElBQW9BZ1FnQWtvRVFDQUZRUU5xUVh4eElRVURRQ0FESUFGQkFSQXdJZ1FOQWlBRElBVnFJUU1nQWtFQmFpSUNJQUFvQWdSSURRQUxDMEVBSVFRTElBUUxpQUlCQTM4akFFRVFheUlESkFBQ1FFRUFRWkQ3QVNnQ0FDSUNSVUdVK3dFb0FnQWlCQnNOQUFKQUlBSUVRQ0FDRUFoQmtQc0JRUUEyQWdBTUFRc2dCRVVOQUNBRUVBaEJsUHNCUVFBMkFnQUxRWmo3QVNnQ0FDSUNSUTBBQTBBZ0FpZ0NBQkFJSUFJb0FnUWhCQ0FDRUFnZ0JDSUNEUUFMUVpqN0FVRUFOZ0lBQ3lBRFFRQTJBZ3dDUUNBQlFRRnJRUUZOQkVCQmtQc0JJQUFnQVNBRFFReHFFSmNCTmdJQURBRUxRWlQ3QVNBQUlBRWdBMEVNYWhCL05nSUFDeUFES0FJTUlnSkJmMHdFUUNBRElBSkJCMnBCQjAwRWYwSFFPeUFDUVFKMGF5Z0NBQVZCK1R3TE5nSUVJQU1nQWpZQ0FFR0dDQ0FERUI0Z0F5Z0NEQ0VDQ3lBRFFSQnFKQUFnQWd0WEFRUi9JQUFvQWdnZ0FDZ0NCR29pQWtIL0FVd0VRQ0FBS0FJQUlnTkJBRXdFUUVFQkR3c0NRQU5BSUFBZ0FXb3RBQXdpQkVIL0FVZEJBQ0FDSUFSTUd3MEJJQUZCQVdvaUFTQURTQTBBQzBFQkR3c0xRUUFMYWdFQmYwRUJJUU1DUUNBQlFRRklCRUJCZnlFRERBRUxBa0FDUUFKQUlBQXRBQUJCQTNGQkFXc09Bd0FBQVFJTFFRSWhBd3dCQzBGOElRTWdBVUVDU0EwQklBQXRBQUZCUDNFaEF3dEJmQ0FBSUFJUU9pQURiQ0lBSUFCQkdXd2dBa0VEYkVvYkR3c2dBd3NRQUNNQUlBQnJRWEJ4SWdBa0FDQUFDd1lBSUFBa0FBc0VBQ01BQzRNQkFnTi9BWDRDUUNBQVFvQ0FnSUFRVkFSQUlBQWhCUXdCQ3dOQUlBRkJBV3NpQVNBQUlBQkNDb0FpQlVJS2ZuMm5RVEJ5T2dBQUlBQkMvLy8vLzU4QlZpRUNJQVVoQUNBQ0RRQUxDeUFGcHlJQ0JFQURRQ0FCUVFGcklnRWdBaUFDUVFwdUlnTkJDbXhyUVRCeU9nQUFJQUpCQ1VzaEJDQURJUUlnQkEwQUN3c2dBUXN0QUNBQVVFVUVRQU5BSUFGQkFXc2lBU0FBcDBFSGNVRXdjam9BQUNBQVFnT0lJZ0JDQUZJTkFBc0xJQUVMTlFBZ0FGQkZCRUFEUUNBQlFRRnJJZ0VnQUtkQkQzRkJnUGdCYWkwQUFDQUNjam9BQUNBQVFnU0lJZ0JDQUZJTkFBc0xJQUVMVmdFQmZ5TUFRVEJySWdJa0FDQUFLQUlFR2lBQUtBSUFHaUFDSUFFMkFpd0NmeUFDSUFJb0Fpd2lBVUVFYWpZQ0xFRi9JQUVvQWdBaUFVVU5BQm9nQVNBQUtBSU1OZ0lBUVFBTElRRWdBa0V3YWlRQUlBRUx4d0lCQTM4akFFSFFBV3NpQXlRQUlBTWdBallDekFGQkFDRUNJQU5Cb0FGcVFRQkJLQkFGR2lBRElBTW9Bc3dCTmdMSUFRSkFRUUFnQVNBRFFjZ0JhaUFEUWRBQWFpQURRYUFCYWhBc1FRQklEUUFnQUNnQ1RFRUFUaUVDSUFBb0FnQWhCQ0FBTEFCS1FRQk1CRUFnQUNBRVFWOXhOZ0lBQ3lBRVFTQnhJUVVDZnlBQUtBSXdCRUFnQUNBQklBTkJ5QUZxSUFOQjBBQnFJQU5Cb0FGcUVDd01BUXNnQUVIUUFEWUNNQ0FBSUFOQjBBQnFOZ0lRSUFBZ0F6WUNIQ0FBSUFNMkFoUWdBQ2dDTENFRUlBQWdBellDTENBQUlBRWdBMEhJQVdvZ0EwSFFBR29nQTBHZ0FXb1FMQ0FFUlEwQUdpQUFRUUJCQUNBQUtBSWtFUUFBR2lBQVFRQTJBakFnQUNBRU5nSXNJQUJCQURZQ0hDQUFRUUEyQWhBZ0FDZ0NGQm9nQUVFQU5nSVVRUUFMR2lBQUlBQW9BZ0FnQlhJMkFnQWdBa1VOQUFzZ0EwSFFBV29rQUF1cEFRRURmd0pBSUFFZ0FpZ0NFQ0lFQkg4Z0JBVWdBaENOQVEwQklBSW9BaEFMSUFJb0FoUWlCV3RMQkVBZ0FpQUFJQUVnQWlnQ0pCRUFBQm9QQ3dKQUlBSXNBRXRCQUVnTkFDQUJJUVFEUUNBRUlnTkZEUUVnQUNBRFFRRnJJZ1JxTFFBQVFRcEhEUUFMSUFJZ0FDQURJQUlvQWlRUkFBQWdBMGtOQVNBQUlBTnFJUUFnQVNBRGF5RUJJQUlvQWhRaEJRc2dCU0FBSUFFUUJCb2dBaUFDS0FJVUlBRnFOZ0lVQ3d0WkFRRi9JQUFnQUMwQVNpSUJRUUZySUFGeU9nQktJQUFvQWdBaUFVRUljUVJBSUFBZ0FVRWdjallDQUVGL0R3c2dBRUlBTndJRUlBQWdBQ2dDTENJQk5nSWNJQUFnQVRZQ0ZDQUFJQUVnQUNnQ01HbzJBaEJCQUF1TEFnQUNRQ0FBQkg4Z0FVSC9BRTBOQVFKQVFkVDZBU2dDQUNnQ0FFVUVRQ0FCUVlCL2NVR0F2d05HRFFNTUFRc2dBVUgvRDAwRVFDQUFJQUZCUDNGQmdBRnlPZ0FCSUFBZ0FVRUdka0hBQVhJNkFBQkJBZzhMSUFGQmdMQURUMEVBSUFGQmdFQnhRWURBQTBjYlJRUkFJQUFnQVVFL2NVR0FBWEk2QUFJZ0FDQUJRUXgyUWVBQmNqb0FBQ0FBSUFGQkJuWkJQM0ZCZ0FGeU9nQUJRUU1QQ3lBQlFZQ0FCR3RCLy84L1RRUkFJQUFnQVVFL2NVR0FBWEk2QUFNZ0FDQUJRUkoyUWZBQmNqb0FBQ0FBSUFGQkJuWkJQM0ZCZ0FGeU9nQUNJQUFnQVVFTWRrRS9jVUdBQVhJNkFBRkJCQThMQzBHYyt3RkJHVFlDQUVGL0JVRUJDdzhMSUFBZ0FUb0FBRUVCQzdvQkFRRi9JQUZCQUVjaEFnSkFBa0FDUUNBQlJRMEFJQUJCQTNGRkRRQURRQ0FBTFFBQVJRMENJQUJCQVdvaEFDQUJRUUZySWdGQkFFY2hBaUFCUlEwQklBQkJBM0VOQUFzTElBSkZEUUVMQWtBZ0FDMEFBRVVOQUNBQlFRUkpEUUFEUUNBQUtBSUFJZ0pCZjNNZ0FrR0Jnb1FJYTNGQmdJR0NoSGh4RFFFZ0FFRUVhaUVBSUFGQkJHc2lBVUVEU3cwQUN3c2dBVVVOQUFOQUlBQXRBQUJGQkVBZ0FBOExJQUJCQVdvaEFDQUJRUUZySWdFTkFBc0xRUUFMQkFCQ0FBc0VBRUVBQy9vQ0FRZC9Jd0JCSUdzaUF5UUFJQU1nQUNnQ0hDSUZOZ0lRSUFBb0FoUWhCQ0FESUFJMkFod2dBeUFCTmdJWUlBTWdCQ0FGYXlJQk5nSVVJQUVnQW1vaEJVRUNJUWNnQTBFUWFpRUJBbjhDUUFKQUFuOUJBQ0FBS0FJOElBTkJFR3BCQWlBRFFReHFFQUFpQkVVTkFCcEJuUHNCSUFRMkFnQkJmd3RGQkVBRFFDQUZJQU1vQWd3aUJFWU5BaUFFUVg5TURRTWdBU0FFSUFFb0FnUWlDRXNpQmtFRGRHb2lDU0FFSUFoQkFDQUdHMnNpQ0NBSktBSUFhallDQUNBQlFReEJCQ0FHRzJvaUNTQUpLQUlBSUFock5nSUFJQVVnQkdzaEJRSi9RUUFnQUNnQ1BDQUJRUWhxSUFFZ0Joc2lBU0FISUFacklnY2dBMEVNYWhBQUlnUkZEUUFhUVp6N0FTQUVOZ0lBUVg4TFJRMEFDd3NnQlVGL1J3MEJDeUFBSUFBb0Fpd2lBVFlDSENBQUlBRTJBaFFnQUNBQklBQW9BakJxTmdJUUlBSU1BUXNnQUVFQU5nSWNJQUJDQURjREVDQUFJQUFvQWdCQklISTJBZ0JCQUNBSFFRSkdEUUFhSUFJZ0FTZ0NCR3NMSVFBZ0EwRWdhaVFBSUFBTHVBNENFSDhDZkNNQVFiQUVheUlHSkFBZ0FpQUNRUU5yUVJodElnUkJBQ0FFUVFCS0d5SU5RV2hzYWlFSVFmVGRBU2dDQUNJSklBTkJBV3NpQjJwQkFFNEVRQ0FESUFscUlRUWdEU0FIYXlFQ0EwQWdCa0hBQW1vZ0JVRURkR29nQWtFQVNBUjhSQUFBQUFBQUFBQUFCU0FDUVFKMFFZRGVBV29vQWdDM0N6a0RBQ0FDUVFGcUlRSWdCVUVCYWlJRklBUkhEUUFMQ3lBSVFSaHJJUXBCQUNFRUlBbEJBQ0FKUVFCS0d5RUZJQU5CQVVnaEN3TkFBa0FnQ3dSQVJBQUFBQUFBQUFBQUlSUU1BUXNnQkNBSGFpRU1RUUFoQWtRQUFBQUFBQUFBQUNFVUEwQWdGQ0FBSUFKQkEzUnFLd01BSUFaQndBSnFJQXdnQW10QkEzUnFLd01Bb3FBaEZDQUNRUUZxSWdJZ0EwY05BQXNMSUFZZ0JFRURkR29nRkRrREFDQUVJQVZHSVFJZ0JFRUJhaUVFSUFKRkRRQUxRUzhnQ0dzaEVFRXdJQWhySVE0Z0NFRVpheUVSSUFraEJBSkFBMEFnQmlBRVFRTjBhaXNEQUNFVVFRQWhBaUFFSVFVZ0JFRUJTQ0lIUlFSQUEwQWdCa0hnQTJvZ0FrRUNkR29DZnlBVUFuOGdGRVFBQUFBQUFBQndQcUlpRkpsRUFBQUFBQUFBNEVGakJFQWdGS29NQVF0QmdJQ0FnSGdMdHlJVVJBQUFBQUFBQUhEQm9xQWlGWmxFQUFBQUFBQUE0RUZqQkVBZ0Zhb01BUXRCZ0lDQWdIZ0xOZ0lBSUFZZ0JVRUJheUlGUVFOMGFpc0RBQ0FVb0NFVUlBSkJBV29pQWlBRVJ3MEFDd3NDZnlBVUlBb1FGQ0lVSUJSRUFBQUFBQUFBd0QraW5FUUFBQUFBQUFBZ3dLS2dJaFNaUkFBQUFBQUFBT0JCWXdSQUlCU3FEQUVMUVlDQWdJQjRDeUVMSUJRZ0M3ZWhJUlFDUUFKQUFrQUNmeUFLUVFGSUloSkZCRUFnQkVFQ2RDQUdhaUlDSUFJb0F0d0RJZ0lnQWlBT2RTSUNJQTUwYXlJRk5nTGNBeUFDSUF0cUlRc2dCU0FRZFF3QkN5QUtEUUVnQkVFQ2RDQUdhaWdDM0FOQkYzVUxJZ3hCQVVnTkFnd0JDMEVDSVF3Z0ZFUUFBQUFBQUFEZ1AyWkJBWE5GRFFCQkFDRU1EQUVMUVFBaEFrRUFJUVVnQjBVRVFBTkFJQVpCNEFOcUlBSkJBblJxSWhNb0FnQWhEMEgvLy84SElRY0Nmd0pBSUFVTkFFR0FnSUFJSVFjZ0R3MEFRUUFNQVFzZ0V5QUhJQTlyTmdJQVFRRUxJUVVnQWtFQmFpSUNJQVJIRFFBTEN3SkFJQklOQUFKQUFrQWdFUTRDQUFFQ0N5QUVRUUowSUFacUlnSWdBaWdDM0FOQi8vLy9BM0UyQXR3RERBRUxJQVJCQW5RZ0Jtb2lBaUFDS0FMY0EwSC8vLzhCY1RZQzNBTUxJQXRCQVdvaEN5QU1RUUpIRFFCRUFBQUFBQUFBOEQ4Z0ZLRWhGRUVDSVF3Z0JVVU5BQ0FVUkFBQUFBQUFBUEEvSUFvUUZLRWhGQXNnRkVRQUFBQUFBQUFBQUdFRVFFRUFJUVVDUUNBSklBUWlBazROQUFOQUlBWkI0QU5xSUFKQkFXc2lBa0VDZEdvb0FnQWdCWEloQlNBQ0lBbEtEUUFMSUFWRkRRQWdDaUVJQTBBZ0NFRVlheUVJSUFaQjRBTnFJQVJCQVdzaUJFRUNkR29vQWdCRkRRQUxEQU1MUVFFaEFnTkFJQUlpQlVFQmFpRUNJQVpCNEFOcUlBa2dCV3RCQW5ScUtBSUFSUTBBQ3lBRUlBVnFJUVVEUUNBR1FjQUNhaUFESUFScUlnZEJBM1JxSUFSQkFXb2lCQ0FOYWtFQ2RFR0EzZ0ZxS0FJQXR6a0RBRUVBSVFKRUFBQUFBQUFBQUFBaEZDQURRUUZPQkVBRFFDQVVJQUFnQWtFRGRHb3JBd0FnQmtIQUFtb2dCeUFDYTBFRGRHb3JBd0Npb0NFVUlBSkJBV29pQWlBRFJ3MEFDd3NnQmlBRVFRTjBhaUFVT1FNQUlBUWdCVWdOQUFzZ0JTRUVEQUVMQ3dKQUlCUkJHQ0FJYXhBVUloUkVBQUFBQUFBQWNFRm1RUUZ6UlFSQUlBWkI0QU5xSUFSQkFuUnFBbjhnRkFKL0lCUkVBQUFBQUFBQWNENmlJaFNaUkFBQUFBQUFBT0JCWXdSQUlCU3FEQUVMUVlDQWdJQjRDeUlDdDBRQUFBQUFBQUJ3d2FLZ0loU1pSQUFBQUFBQUFPQkJZd1JBSUJTcURBRUxRWUNBZ0lCNEN6WUNBQ0FFUVFGcUlRUU1BUXNDZnlBVW1VUUFBQUFBQUFEZ1FXTUVRQ0FVcWd3QkMwR0FnSUNBZUFzaEFpQUtJUWdMSUFaQjRBTnFJQVJCQW5ScUlBSTJBZ0FMUkFBQUFBQUFBUEEvSUFnUUZDRVVBa0FnQkVGL1RBMEFJQVFoQWdOQUlBWWdBa0VEZEdvZ0ZDQUdRZUFEYWlBQ1FRSjBhaWdDQUxlaU9RTUFJQlJFQUFBQUFBQUFjRDZpSVJRZ0FrRUFTaUVBSUFKQkFXc2hBaUFBRFFBTFFRQWhCeUFFUVFCSURRQWdDVUVBSUFsQkFFb2JJUUFnQkNFRkEwQWdBQ0FISUFBZ0Iwa2JJUU1nQkNBRmF5RUlRUUFoQWtRQUFBQUFBQUFBQUNFVUEwQWdGQ0FDUVFOMFFkRHpBV29yQXdBZ0JpQUNJQVZxUVFOMGFpc0RBS0tnSVJRZ0FpQURSeUVLSUFKQkFXb2hBaUFLRFFBTElBWkJvQUZxSUFoQkEzUnFJQlE1QXdBZ0JVRUJheUVGSUFRZ0IwY2hBaUFIUVFGcUlRY2dBZzBBQ3d0RUFBQUFBQUFBQUFBaEZDQUVRUUJPQkVBZ0JDRUNBMEFnRkNBR1FhQUJhaUFDUVFOMGFpc0RBS0FoRkNBQ1FRQktJUUFnQWtFQmF5RUNJQUFOQUFzTElBRWdGSm9nRkNBTUd6a0RBQ0FHS3dPZ0FTQVVvU0VVUVFFaEFpQUVRUUZPQkVBRFFDQVVJQVpCb0FGcUlBSkJBM1JxS3dNQW9DRVVJQUlnQkVjaEFDQUNRUUZxSVFJZ0FBMEFDd3NnQVNBVW1pQVVJQXdiT1FNSUlBWkJzQVJxSkFBZ0MwRUhjUXZNQ1FNRmZ3RitCSHdqQUVFd2F5SUVKQUFDUUFKQUFrQWdBTDBpQjBJZ2lLY2lBa0gvLy8vL0IzRWlBMEg2MUwyQUJFMEVRQ0FDUWYvL1AzRkIrOE1rUmcwQklBTkIvTEtMZ0FSTkJFQWdCMElBV1FSQUlBRWdBRVFBQUVCVSt5SDV2NkFpQUVReFkySWFZYlRRdmFBaUNEa0RBQ0FCSUFBZ0NLRkVNV05pR21HMDBMMmdPUU1JUVFFaEFnd0ZDeUFCSUFCRUFBQkFWUHNoK1QrZ0lnQkVNV05pR21HMDBEMmdJZ2c1QXdBZ0FTQUFJQWloUkRGallocGh0TkE5b0RrRENFRi9JUUlNQkFzZ0IwSUFXUVJBSUFFZ0FFUUFBRUJVK3lFSndLQWlBRVF4WTJJYVliVGd2YUFpQ0RrREFDQUJJQUFnQ0tGRU1XTmlHbUcwNEwyZ09RTUlRUUloQWd3RUN5QUJJQUJFQUFCQVZQc2hDVUNnSWdCRU1XTmlHbUcwNEQyZ0lnZzVBd0FnQVNBQUlBaWhSREZqWWhwaHRPQTlvRGtEQ0VGK0lRSU1Bd3NnQTBHN2pQR0FCRTBFUUNBRFFiejcxNEFFVFFSQUlBTkIvTExMZ0FSR0RRSWdCMElBV1FSQUlBRWdBRVFBQURCL2ZOa1N3S0FpQUVUS2xKT25rUTdwdmFBaUNEa0RBQ0FCSUFBZ0NLRkV5cFNUcDVFTzZiMmdPUU1JUVFNaEFnd0ZDeUFCSUFCRUFBQXdmM3paRWtDZ0lnQkV5cFNUcDVFTzZUMmdJZ2c1QXdBZ0FTQUFJQWloUk1xVWs2ZVJEdWs5b0RrRENFRjlJUUlNQkFzZ0EwSDd3K1NBQkVZTkFTQUhRZ0JaQkVBZ0FTQUFSQUFBUUZUN0lSbkFvQ0lBUkRGallocGh0UEM5b0NJSU9RTUFJQUVnQUNBSW9VUXhZMklhWWJUd3ZhQTVBd2hCQkNFQ0RBUUxJQUVnQUVRQUFFQlUreUVaUUtBaUFFUXhZMklhWWJUd1BhQWlDRGtEQUNBQklBQWdDS0ZFTVdOaUdtRzA4RDJnT1FNSVFYd2hBZ3dEQ3lBRFFmckQ1SWtFU3cwQkN5QUJJQUFnQUVTRHlNbHRNRi9rUDZKRUFBQUFBQUFBT0VPZ1JBQUFBQUFBQURqRG9DSUpSQUFBUUZUN0lmbS9vcUFpQ0NBSlJERmpZaHBodE5BOW9pSUxvU0lBT1FNQUlBTkJGSFlpQlNBQXZVSTBpS2RCL3c5eGEwRVJTQ0VEQW44Z0NabEVBQUFBQUFBQTRFRmpCRUFnQ2FvTUFRdEJnSUNBZ0hnTElRSUNRQ0FERFFBZ0FTQUlJQWxFQUFCZ0dtRzAwRDJpSWdDaElnb2dDVVJ6Y0FNdWlobWpPNklnQ0NBS29TQUFvYUVpQzZFaUFEa0RBQ0FGSUFDOVFqU0lwMEgvRDNGclFUSklCRUFnQ2lFSURBRUxJQUVnQ2lBSlJBQUFBQzZLR2FNN29pSUFvU0lJSUFsRXdVa2dKWnFEZXptaUlBb2dDS0VnQUtHaElndWhJZ0E1QXdBTElBRWdDQ0FBb1NBTG9Ua0RDQXdCQ3lBRFFZQ0F3UDhIVHdSQUlBRWdBQ0FBb1NJQU9RTUFJQUVnQURrRENFRUFJUUlNQVFzZ0IwTC8vLy8vLy8vL0I0TkNnSUNBZ0lDQWdMREJBSVMvSVFCQkFDRUNRUUVoQlFOQUlBUkJFR29nQWtFRGRHb0NmeUFBbVVRQUFBQUFBQURnUVdNRVFDQUFxZ3dCQzBHQWdJQ0FlQXUzSWdnNUF3QWdBQ0FJb1VRQUFBQUFBQUJ3UWFJaEFFRUJJUUlnQlVFQmNTRUdRUUFoQlNBR0RRQUxJQVFnQURrRElBSkFJQUJFQUFBQUFBQUFBQUJpQkVCQkFpRUNEQUVMUVFFaEJRTkFJQVVpQWtFQmF5RUZJQVJCRUdvZ0FrRURkR29yQXdCRUFBQUFBQUFBQUFCaERRQUxDeUFFUVJCcUlBUWdBMEVVZGtHV0NHc2dBa0VCYWhDVEFTRUNJQVFyQXdBaEFDQUhRbjlYQkVBZ0FTQUFtamtEQUNBQklBUXJBd2lhT1FNSVFRQWdBbXNoQWd3QkN5QUJJQUE1QXdBZ0FTQUVLd01JT1FNSUN5QUVRVEJxSkFBZ0FndXZBd0VFZlFKQUlBSUVRRU45SFpBbUlRWWdBMEVCU0FSQVEzMGRrQ1loQlF3Q0MwRUFJUUpEZlIyUUppRUZBMEFnQlNBQUlBSkJBblFpQkdvcUFnQWlCeUFCSUFScUtnSUFJZ2lUSWdVZ0JaU1NJUVVnQmlBSElBaVNJZ1lnQnBTU0lRWWdBa0VCYWlJQ0lBTkhEUUFMREFFTElBTkJBVWdFUUVOOUhaQW1JUVZEZlIyUUppRUdEQUVMUVFBaEFnTkFJQVlnQUNBQ1FRSjBhaW9DQUNJRklBV1VraUVHSUFKQkFXb2lBaUFEUncwQUN5QUdRMzBka0NhU0lRWkJBQ0VDUXdBQUFBQWhCUU5BSUFVZ0FTQUNRUUowYWlvQ0FDSUZJQVdVa2lFRklBSkJBV29pQWlBRFJ3MEFDeUFGUTMwZGtDYVNJUVVMQW4xREFBQUFBQ0FGa1NJSUlBaVVJZ1VnQnBFaUJ5QUhsQ0lHa2tQdmtwTWhYUTBBR2tQYkQ4ay9JQWdnQjVRZ0JTQUdRd1g0M0Q2VWtwUWdCU0FHUXlHeExUK1VraUFGSUFaRFpRbXdQWlNTbEpXVElBVWdCbDVCQVhORkRRQWFJQWdnQjVRZ0JpQUZRd1g0M0Q2VWtwUWdCaUFGUXlHeExUK1VraUFHSUFWRFpRbXdQWlNTbEpWRDJ3L0pQNUpEMncvSnY1SUxRNGY1SWthVVF3QUFBRCtTamlJRmkwTUFBQUJQWFFSQUlBV29Ed3RCZ0lDQWdIZ0w4QUVCQkg4akFDSUhJUW9nQVVFQklBRkJBVW9iSVFnZ0J5QUJRUUowUVE5cVFYQnhheUlISkFCREFBQ0FQeUFISUFFZ0FpQUZFRmVSbFNBR2xDRUdRUUFoQlFOQUlBQWdCVUVDZENJSmFpQUdJQWNnQ1dvb0FnQ3lsRGdDQUNBRlFRRnFJZ1VnQ0VjTkFBc2dBQ0FCUVg4Z0JDQUNJQU1RTDBFQklRSWdCRUVDVGdSQUlBRWdCRzRpQTBFQklBTkJBVW9iSVFoQkFDRUNRUUFoQVFOQUlBRWdBMndoQ1VFQUlRVkJBQ0VBQTBBZ0J5QUZJQWxxUVFKMGFpZ0NBQ0FBY2lFQUlBVkJBV29pQlNBSVJ3MEFDeUFBUVFCSElBRjBJQUp5SVFJZ0FVRUJhaUlCSUFSSERRQUxDeUFLSkFBZ0FndjRBUUVDZnlNQVFSQnJJZ01rQUFKQUFrQUNRQUpBSUFCQi8vd0FUQVJBSUFCQndENUdEUUVnQUVIZzNRQkdEUUVNQWdzZ0FFR0EvUUJHRFFBZ0FFR0E5d0pHRFFBZ0FFSEF1d0ZIRFFFTElBRkJBV3RCQWtrTkFRc2dBa1VOQVNBQ1FYODJBZ0FNQVFzQ2Z5QURRZWpDQURZQ0RFRUFDd1IvUVFBRklBTWdBeWdDREVFRGFrRjhjVFlDRENBREtBSU1RYUE5S0FJQVFRSjBRZURBQUdvZ0FXeEJwRDBvQWdCQkJYUnFha0cwQVdvTEVCVWlCRVVFUUVFQUlRUWdBa1VOQVNBQ1FYazJBZ0FNQVFzZ0JDQUFJQUVRTUNFQUlBSUVRQ0FDSUFBMkFnQUxJQUJGRFFBZ0JCQUlRUUFoQkFzZ0EwRVFhaVFBSUFRTGxBSUNBMzhCZlNNQUlnZ2hDaUFJSUFGQkFuUkJHMnBCY0hGcklnZ2tBRUVCSVFrZ0FDQUJRUUVnQkNBQ0lBTVFMeUFBSUFnZ0FpQUJFSmtCSVF3Z0NDQUJJQUlnQlJCWUlBY0VRQ0FCUVFFZ0FVRUJTaHNoQlVNQUFJQS9JQXlSbFNBR2xDRUdRUUFoQndOQUlBQWdCMEVDZENJTGFpQUdJQWdnQzJvb0FnQ3lsRGdDQUNBSFFRRnFJZ2NnQlVjTkFBc2dBQ0FCUVg4Z0JDQUNJQU1RTHdzZ0JFRUNUZ1JBSUFFZ0JHNGlBRUVCSUFCQkFVb2JJUUpCQUNFSlFRQWhBUU5BSUFBZ0FXd2hBMEVBSVFkQkFDRUZBMEFnQ0NBRElBZHFRUUowYWlnQ0FDQUZjaUVGSUFkQkFXb2lCeUFDUncwQUN5QUZRUUJISUFGMElBbHlJUWtnQVVFQmFpSUJJQVJIRFFBTEN5QUtKQUFnQ1F2ekJRSUlmd2Q5SXdBaUJDRUtJQVFnQTBFQ2RFRVBha0Z3Y1NJRWF5SUZJZ2NrQUNBSElBUnJJZ2trQUNBRlFRQWdBMEVCSUFOQkFVb2JJZ2hCQW5RUUJTRUhRUUFoQkFOQUlBa2dCRUVDZENJRmFpQUFJQVZxSWdZcUFnQWlERU1BQUFBQVhUWUNBQ0FHSUF5TE9BSUFJQUVnQldwQkFEWUNBQ0FFUVFGcUlnUWdDRWNOQUF0REFBQUFBQ0VNSUFOQkFYVWdBa2dFUUVFQUlRUURRQ0FNSUFBZ0JFRUNkR29xQWdDU0lRd2dCRUVCYWlJRUlBaEhEUUFMSUFLeVE4M01URCtTUXdBQWdEOGdERU45SFpBbVhrRUJjMFZCQUNBTVF3QUFnRUpkR3dSOUlBd0ZJQUJCZ0lDQS9BTTJBZ0FnQUVFRWFrRUFJQU5CQWlBRFFRSktHMEVDZEVFRWF4QUZHa01BQUlBL0M1V1VJUTlCQUNFRlF3QUFBQUFoREFOQUlBRWdCVUVDZENJRWFnSi9JQThnQUNBRWFpb0NBQ0lRbEk0aURZdERBQUFBVDEwRVFDQU5xQXdCQzBHQWdJQ0FlQXNpQmpZQ0FDQUVJQWRxSUFheUlnMGdEWkk0QWdBZ0RpQVFJQTJVa2lFT0lBSWdCbXNoQWlBTUlBMGdEWlNTSVF3Z0JVRUJhaUlGSUFoSERRQUxDd0pBSUFOQkEyb2dBa2dFUUNBSEtnSUFJUTRnQVNBQktBSUFJQUpxTmdJQUlBd2dBcklpRENBTWxKSWdEaUFNbEpJaERBd0JDeUFDUVFGSURRQWdBMEVDSUFOQkFrb2JJUXNnQUNvQ0FDRVFRUUFoQXdOQUlBeERBQUNBUDVJaUR5QUhLZ0lBa2lFTUlBNGdFSklpRFNBTmxDRU5RUUVoQkVFQUlRVURRQ0FQSUFjZ0JFRUNkQ0lHYWlvQ0FKSWlFU0FNSUF3Z0RpQUFJQVpxS2dJQWtpSU1JQXlVSWhLVUlBMGdFWlJlSWdZYklRd2dFaUFOSUFZYklRMGdCQ0FGSUFZYklRVWdCRUVCYWlJRUlBdEhEUUFMSUFBZ0JVRUNkQ0lFYWlvQ0FDRU5JQVFnQjJvaUJTQUZLZ0lBSWd4REFBQUFRSkk0QWdBZ0FTQUVhaUlFSUFRb0FnQkJBV28yQWdBZ0R5QU1raUVNSUE0Z0RaSWhEaUFEUVFGcUlnTWdBa2NOQUFzTFFRQWhCQU5BSUFFZ0JFRUNkQ0lBYWlJQ0lBSW9BZ0JCQUNBQUlBbHFLQUlBSWdCcmN5QUFhallDQUNBRVFRRnFJZ1FnQ0VjTkFBc2dDaVFBSUF3TC9BSUJCSDhnQUNnQ0hDSURJQU5CQW5ZaUFtc2hBd0pBSUFGRkJFQWdBeUVDREFFTElBQWdBQ2dDSUNBRGFqWUNJQXNnQUNBQ05nSWNJQUpCZ0lDQUJFMEVRQ0FBS0FJZ0lRRURRQUpBSUFGQkYzWWlCVUgvQVVjRVFDQUJRUjkySVFJZ0FDZ0NLQ0lCUVFCT0JFQWdBQ0FBS0FJRUlBQW9BaGdpQXlBQUtBSUlha3NFZnlBQUlBTkJBV28yQWhnZ0FDZ0NBQ0FEYWlBQklBSnFPZ0FBUVFBRlFYOExJQUFvQWl4eU5nSXNDeUFBS0FJa0lnRUVRQ0FDUVFGcklRTURRRUYvSVFJZ0FDQUFLQUlFSUFBb0FoZ2lCQ0FBS0FJSWFrc0VmeUFBSUFSQkFXbzJBaGdnQUNnQ0FDQUVhaUFET2dBQVFRQWhBaUFBS0FJa0JTQUJDMEVCYXlJQk5nSWtJQUFnQUNnQ0xDQUNjallDTENBQkRRQUxDeUFBSUFWQi93RnhOZ0lvSUFBb0Fod2hBaUFBS0FJZ0lRRU1BUXNnQUNBQUtBSWtRUUZxTmdJa0N5QUFJQUpCQ0hRaUFqWUNIQ0FBSUFGQkNIUkJnUDcvL3dkeElnRTJBaUFnQUNBQUtBSVVRUWhxTmdJVUlBSkJnWUNBQkVrTkFBc0xDL2tiQVJsL0l3QWlFQ0VtSUFoQkFDQUlRUUJLR3lJSUlBaEJCMHBCQTNRaUpHc2hGaUFBS0FJSUlSUUNRQ0FOUVFKSERRQWdBaUFCYTBHdzNRRnFMUUFBSWh3Z0Zrb0VRRUVBSVJ3TUFRc2dGaUFjYXlJSUlBaEJCMHBCQTNRaUpXc2hGZ3NnRUNBVVFRSjBRUTlxUVhCeElnaHJJaGtpRUNRQUlCQWdDR3NpR2lJUUpBQWdFQ0FJYXlJYkloQWtBQ0FOUVFOMElSY2dFQ0FJYXlJZEpBQUNRQUpBQWtBZ0FTQUNTQ0lUUlFSQUlBQkJOR29oSGlBQVFTQnFJU0FnQUNnQ01DSWlRUUZySVJFTUFRc2dEa0VEYWlFUklBVWdEbXRCQldzZ0RXd2hGU0FBS0FJZ0lpQWdBVUVCZEdvdkFRQWhFaUFCSVFnRFFDQVNRUkIwSVJBZ0d5QUlRUUowSWhocUlCY2dJQ0FJUVFGcUlnVkJBWFJxTGdFQUloSWdFRUVRZFdzaUVFRURiQ0FPZEVFRGRFRUVkU0llSUJjZ0hrb2JOZ0lBSUJnZ0hXb2dGU0FJUVg5eklBSnFiQ0FRYkNBUmRFRUdkU0FYUVFBZ0VDQU9kRUVCUmh0ck5nSUFJQVVpQ0NBQ1J3MEFDeUFBUVRScUlSNGdBRUVnYWlFZ0lBQW9BakFpSWtFQmF5RVJJQk1OQVFzZ0ZrRUFTQ0VGUVFFaEZRTkFJQlVnRVNBVmFrRUJkU0lJUVFGcUlBVWJJaFVnQ0VFQmF5QVJJQVViSWhGTURRQUxEQUVMSUFBb0FpQWlJeUFDUVFGMGFpOEJBQ0VGSUFBb0FqUWhKMEVCSVJVRFFDQVJJQlZxUVFGMUlpRWdGR3doS0NBRklSQkJBQ0VTUVFBaEV5QUNJUWdEUUNBUVFSQjBRUkIxSUNNZ0NFRUJheUlJUVFGMGFpNEJBQ0lRYXlBTmJDQW5JQWdnS0dwcUxRQUFiQ0FPZENJZlFRSjFJUmdnSDBFRVRnUi9JQjBnQ0VFQ2RHb29BZ0FnR0dvaUdFRUFJQmhCQUVvYkJTQVlDeUFESUFoQkFuUWlIMm9vQWdCcUlSZ0Nmd0pBSUJNTkFDQVlJQnNnSDJvb0FnQk9EUUJCQUNFVFFRQWdGeUFYSUJoS0d3d0JDMEVCSVJNZ0dDQUVJQjlxS0FJQUloOGdHQ0FmU0JzTElCSnFJUklnQVNBSVNBMEFDeUFWSUNGQkFXb2dFaUFXU2lJSUd5SVZJQ0ZCQVdzZ0VTQUlHeUlSVEEwQUN3dEJBQ0VJSUFFaEJRSkFJQUVnQWs0aUl3MEFJQlZCQVdzZ0ZHd2hJU0FnS0FJQUloOGdBVUVCZEdvdkFRQWhFQ0FlS0FJQUlSZ0NRQ0FWSUNKSUJFQWdGQ0FWYkNFaUlBRWlDQ0VGQTBBZ0VFRVFkQ0VSSUI4Z0NFRUJhaUlTUVFGMGFpNEJBQ0lRSUJGQkVIVnJJQTFzSWhNZ0dDQUlJQ0pxYWkwQUFHd2dEblFoRVNBVElCZ2dDQ0FoYW1vdEFBQnNJQTUwSWhSQkFuVWhFeUFVUVFST0JFQWdIU0FJUVFKMGFpZ0NBQ0FUYWlJVFFRQWdFMEVBU2hzaEV3c2dFVUVDZFNFVUlCRkJCRTRFUUNBZElBaEJBblJxS0FJQUlCUnFJaEZCQUNBUlFRQktHeUVVQ3lBWklBaEJBblFpRVdvZ0V5QURJQkZxS0FJQUloNUJBQ0FWUVFGS0cyb2lFellDQUNBUklCcHFJQjRnRkNBVGEyb2lFVUVBSUJGQkFFb2JOZ0lBSUFnZ0JTQWVRUUJLR3lFRklCSWlDQ0FDUncwQUN3d0JDeUFCSWhFaEJRTkFJQkJCRUhRaEVpQVlJQkVnSVdwcUxRQUFJQjhnRVVFQmFpSUlRUUYwYWk0QkFDSVFJQkpCRUhWcklBMXNiQ0FPZENJZVFRSjFJUlFnQkNBUlFRSjBJaE5xS0FJQUlSSWdIa0VFVGdSQUlCTWdIV29vQWdBZ0ZHb2lGRUVBSUJSQkFFb2JJUlFMSUJKQkFVNEVRQ0FUSUIxcUtBSUFJQkpxSWhKQkFDQVNRUUJLR3lFU0N5QVRJQmxxSUJRZ0F5QVRhaWdDQUNJZVFRQWdGVUVCU2h0cUloUTJBZ0FnRXlBYWFpQWVJQklnRkd0cUloSkJBQ0FTUVFCS0d6WUNBQ0FSSUFVZ0hrRUFTaHNoQlNBSUloRWdBa2NOQUFzTFFRQWhDQ0FqRFFBZ0FpRVFRUUFoRXdOQUlCb2dFRUVCYXlJUVFRSjBJaEpxS0FJQVFRRjFJQklnR1dvb0FnQnFJUU1DZndKQUlCTU5BQ0FESUJJZ0cyb29BZ0JPRFFCQkFDRVRRUUFnRnlBRElCZElHd3dCQzBFQklSTWdBeUFFSUJKcUtBSUFJaElnQXlBU1NCc0xJQWhxSVFnZ0FTQVFTQTBBQzBFUVFUQWdDQ0FXU2lJREd5RVZRU0JCd0FBZ0F4c2hGRUVBSVJNZ0FpRVFRUUFoQXdOQUlCb2dFRUVCYXlJUVFRSjBJaEZxS0FJQUlCVnNRUVoxSUJFZ0dXb29BZ0JxSVJJQ2Z3SkFJQU1OQUNBU0lCRWdHMm9vQWdCT0RRQkJBQ0FYSUJJZ0YwZ2JJUkZCQUF3QkN5QVNJQVFnRVdvb0FnQWlBeUFESUJKS0d5RVJRUUVMSVFNZ0VTQVRhaUVUSUFFZ0VFZ05BQXNnQ0NBV1RFRUZkQ0FWSUJNZ0Zrb2lBeHNpSFNBVklCUWdBeHNpRldwQkFYWWhDRUVBSVJBZ0FpRVNRUUFoRXdOQUlCb2dFa0VCYXlJU1FRSjBJaEZxS0FJQUlBaHNRUVoxSUJFZ0dXb29BZ0JxSVFNQ2Z3SkFJQk1OQUNBRElCRWdHMm9vQWdCT0RRQkJBQ0VUUVFBZ0Z5QURJQmRJR3d3QkMwRUJJUk1nQXlBRUlCRnFLQUlBSWhFZ0F5QVJTQnNMSUJCcUlSQWdBU0FTU0EwQUN5QWRJQWdnRUNBV1NpSURHeUlVSUFnZ0ZTQURHeUlWYWtFQmRpRUlRUUFoRUNBQ0lSSkJBQ0VUQTBBZ0dpQVNRUUZySWhKQkFuUWlFV29vQWdBZ0NHeEJCblVnRVNBWmFpZ0NBR29oQXdKL0FrQWdFdzBBSUFNZ0VTQWJhaWdDQUU0TkFFRUFJUk5CQUNBWElBTWdGMGdiREFFTFFRRWhFeUFESUFRZ0VXb29BZ0FpRVNBRElCRklHd3NnRUdvaEVDQUJJQkpJRFFBTElCUWdDQ0FRSUJaS0lnTWJJaFFnQ0NBVklBTWJJaFZxUVFGMklRaEJBQ0VRSUFJaEVrRUFJUk1EUUNBYUlCSkJBV3NpRWtFQ2RDSVJhaWdDQUNBSWJFRUdkU0FSSUJscUtBSUFhaUVEQW44Q1FDQVREUUFnQXlBUklCdHFLQUlBVGcwQVFRQWhFMEVBSUJjZ0F5QVhTQnNNQVF0QkFTRVRJQU1nQkNBUmFpZ0NBQ0lSSUFNZ0VVZ2JDeUFRYWlFUUlBRWdFa2dOQUFzZ0ZDQUlJQkFnRmtvaUF4c2lGQ0FJSUJVZ0F4dHFRUUYySVJGQkFDRVFJQUloRWtFQUlSTURRQ0FhSUJKQkFXc2lFa0VDZENJSWFpZ0NBQ0FSYkVFR2RTQUlJQmxxS0FJQWFpRURBbjhDUUNBVERRQWdBeUFJSUJ0cUtBSUFUZzBBUVFBaEUwRUFJQmNnQXlBWFNCc01BUXRCQVNFVElBTWdCQ0FJYWlnQ0FDSUlJQU1nQ0VnYkN5QVFhaUVRSUFFZ0VrZ05BQXNnRkNBUklCQWdGa29iSVJFZ0FpRVFRUUFoQ0VFQUlSTURRQ0FLSUJCQkFXc2lFRUVDZENJRGFpQURJQmxxS0FJQUlBTWdHbW9vQWdBZ0VXeEJCblZxSWhJZ0VrRUFJQmNnRWlBWFNCc2dFaUFESUJ0cUtBSUFUaUlTR3lBVEd5SVZJQU1nQkdvb0FnQWlBeUFESUJWS0d5SUROZ0lBSUFNZ0NHb2hDQ0FTSUJOeUlSTWdBU0FRU0EwQUN3c2dCZ0ovQWtBQ1FBSi9JQVVnQWtFQmF5SVRUZ1JBSUFJaEVTQWNJUkFnRmlBa2Fnd0JDeUFYUVFocUlRTWdBaUVTQWtBQ1FBTkFJQ0FvQWdBaUVDQVNRUUYwYWk0QkFDSVZJQkFnRXlJUlFRRjBhaTRCQUNJVGF5QVdJQWhySWhvZ0ZTQVFJQUZCQVhScUxnRUFJaEJyYmlJZGJDQUtJQkZCQW5RaUdHb2lHU2dDQUNJVWFpQVFJQlZySUIxc0lCcHFJQkFnRTJ0cUloQkJBQ0FRUVFCS0cyb2lFeUFZSUJ0cUtBSUFJaEFnQXlBRElCQklHMDRFUUNBUFFRRVFCZzBDSUJOQkNHc2hFeUFaS0FJQUlSUWdDRUVJYWlFSUN5QWNJaEJCQVU0RVFDQVJJQUZyUWJEZEFXb3RBQUFoRUFzZ0dVRUFJQmNnRXlBWFNCc2lFallDQUNBSUlCUWdIR3BySUJKcUlCQnFJUWdnRUNFY0lCRWlFa0VCYXlJVElBVktEUUFMREFFTElCeEJBRW9OQWd3REN5QVdJQ1JxQ3lFV0lCQkJBRXdFUUNBUklSSU1BZ3NnRVNFU0N5QVBJQklnQVd0QkFXb1FGaUFCYWd3QkMwRUFDeUlETmdJQVFRQWdKU0FCSUFOSUd5RUZBa0FDUUNBbFJRMEFJQUVnQTA0TkFDQUhJQTlCQVJBR05nSUFEQUVMSUFkQkFEWUNBQXNnRFVFQlNpRWJJQllnQ0dzZ0JXb2lDQ0FnS0FJQUlod2dFa0VCZEdvdUFRQWlEeUFjSUFGQkFYUnFMZ0VBSWhOcmJpRUZRUUFoQXlBQklCSklCRUFnRGtFRGRDRVpJQk1nRDJzZ0JXd2dDR29oQ0NBVElSQWdBU0VSQTBBZ0VFRVFkQ0VESUFvZ0VVRUNkR29pRHlBUEtBSUFJQndnRVVFQmFpSVJRUUYwYWk0QkFDSVFJQU5CRUhWcklBVnNhallDQUNBUklCSkhEUUFMSUJNaEVDQUJJUkVEUUNBUVFSQjBJUU1nQ2lBUlFRSjBhaUlGSUFnZ0hDQVJRUUZxSWhGQkFYUnFMZ0VBSWhBZ0EwRVFkV3NpQXlBRElBaEtHeUlESUFVb0FnQnFOZ0lBSUFnZ0Eyc2hDQ0FSSUJKSERRQUxRUVJCQXlBTlFRRktHeUVhUVFBZ0RVRURkR3NoSFVFQUlRTURRQ0FUUVJCMElSQWdDaUFCUVFKMElnOXFJaEVvQWdBZ0Eyb2hCUUpBSUJ3Z0FVRUJhaUlJUVFGMGFpNEJBQ0lUSUJCQkVIVnJJQTUwSWhaQkFrNEVRRUVBSVJVZ0VTQUZJQVVnQkNBUGFpZ0NBR3NpQlVFQUlBVkJBRW9iSWdWckloUTJBZ0FnRFNBV2JDRVFBa0FnRFVFQ1J3MEFJQlpCQWtZTkFDQUhLQUlBRFFBZ0FTQUdLQUlBU0NFVkN3SkFJQkFnRldvaUVFRURkQ0lWUVFKMVFRQWdGa0VDUmhzZ0VFRnJiR29nR1NBQUtBSTRJQUZCQVhScUxnRUFhaUFRYkNJV1FRRjFhaUlCSUJScUlpQWdFRUVFZEVnRVFDQUJJQlpCQW5WcUlRRU1BUXNnSUNBUVFSaHNUZzBBSUFFZ0ZrRURkV29oQVFzZ0N5QVBhaUlXSUJCQkFuUWdGR29nQVdvaUZFRUFJQlJCQUVvYklCQnVRUU4ySWhBMkFnQWdEU0FRYkNBUktBSUFJaFJCQTNWS0JFQWdGaUFVSUJ0MVFRTjFJaEEyQWdBTElCWWdFRUVJSUJCQkNFZ2JJaEEyQWdBZ0RDQVBhaUFSS0FJQUlBRnFJQkFnRld4TU5nSUFJQkVnRVNnQ0FDQWRJQllvQWdCc2FqWUNBQXdCQ3lBUklBVWdCU0FYYXlJQlFRQWdBVUVBU2hzaUJXczJBZ0FnQ3lBUGFrRUFOZ0lBSUF3Z0QycEJBVFlDQUFzZ0JRUi9JQXNnRDJvaUFTQUZJQnAySWhCQkNDQUJLQUlBSWdGckloRWdFQ0FSU0JzaUVDQUJhallDQUNBTUlBOXFJQkFnRjJ3aUFTQUZJQU5yVGpZQ0FDQUZJQUZyQlVFQUN5RURJQWdpQVNBU1J3MEFDeUFTSVFFTElBa2dBellDQUNBQklBSklCRUFEUUNBTElBRkJBblFpQUdvaUF5QUFJQXBxSWdRb0FnQWdHM1ZCQTNVMkFnQWdCRUVBTmdJQUlBQWdER29nQXlnQ0FFRUJTRFlDQUNBQlFRRnFJZ0VnQWtjTkFBc0xJQ1lrQUNBU0N6d0JBWDhnQUNBQUtBSWNRUTkySWdFMkFpUWdBQ2dDSUNBQmJpSUFRWDl6UVlDQUFtcEJBQ0FBUVFGcUlnQkJnSUFDYXlJQklBQWdBVWtiYWd1WEFRRUVmeUFCSUFKSUJFQWdCa0VCSUFaQkFVb2JJUWdEUUVFQUlRWWdCQ0FCUVFKMGFpSUpLQUlBSWdkQkFVNEVRQU5BSUFVZ0J4QUpJUWNnQXlBQUtBSUlJQVpzSUFGcVFRSjBhaUlLSUFvcUFnQWdCN0pEQUFBQVA1SkJBVUVPSUFrb0FnQWlCMnQwc3BSREFBQ0FPSlJEQUFBQXY1S1NPQUlBSUFaQkFXb2lCaUFJUncwQUN3c2dBVUVCYWlJQklBSkhEUUFMQ3d2eEFnSUhmd1I5SXdCQkVHc2lDU1FBSUFsQ0FEY0RDQUo5SUFRRVFFTUFtQmsrREFFTElBZEJBblFpQ0VHQTNRRnFLZ0lBSVE4Z0NFR1EzUUZxS2dJQUN5RVJJQUVnQWtnRVFDQUdRUUVnQmtFQlNoc2hDaUFGS0FJRVFRTjBRU0JxSVFzZ0IwSFVBR3dnQkVFcWJHcEJzTm9CYWlFSEEwQWdCeUFCUVJRZ0FVRVVTQnRCQVhRaUJHb2hEQ0FISUFSQkFYSnFJUTFCQUNFRUEwQUNmeUFMSUFVb0FoUnJJQVVvQWh4bmF5SUlRUTlPQkVBZ0JTQU1MUUFBUVFkMElBMHRBQUJCQm5RUVhRd0JDeUFJUVFKT0JFQWdCVUdnM1FGQkFoQURJZ1pCQVhWQkFDQUdRUUZ4YTNNTUFRdEJmeUFJUVFGSERRQWFRUUFnQlVFQkVBWnJDeUVHSUFNZ0FDZ0NDQ0FFYkNBQmFrRUNkR29pQ0NBSlFRaHFJQVJCQW5ScUlnNHFBZ0FpRWlBUElBZ3FBZ0JEQUFBUXdaZVVraUFHc2lJUWtqZ0NBQ0FPSUJJZ0VKSWdFU0FRbEpNNEFnQWdCRUVCYWlJRUlBcEhEUUFMSUFGQkFXb2lBU0FDUncwQUN3c2dDVUVRYWlRQUMyc0JBbjhDUUVHUSt3RW9BZ0FpQUFSQUlBQVFDRUdRK3dGQkFEWUNBQXdCQzBHVSt3RW9BZ0FpQUVVTkFDQUFFQWhCbFBzQlFRQTJBZ0FMUVpqN0FTZ0NBQ0lCQkVBRFFDQUJLQUlBRUFnZ0FTZ0NCQ0VBSUFFUUNDQUFJZ0VOQUF0Qm1Qc0JRUUEyQWdBTEN3dXM2QUUzQUVHQkNBdm5BUVFCQWdNRlJtRnBiR1ZrSUhSdklHTnlaV0YwWlNCUFVGVlRJR1JsWTI5a1pYSXNJR052WkdVNklDVmtJQ2NsY3ljdUFFWmhhV3hsWkNCMGJ5QmtaV052WkdVZ1QzQjFjeUJrWVhSaExDQnBibkIxZENBbGNDQWxaQ3dnYjNWMGNIVjBJQ1Z3SUNWa0xnQkRZVzRuZENCbWNtVmxJSFZ1ZEhKaFkydGxaQ0JpZFdabVpYSWdKWEF1QUFBQUFBQUFBQThJQndRTERBTUNEUW9GQmdrT0FRQUpCZ01FQlFnQkFnZTRmcHA1bW5sbVpyaCtNM01BQUFZQUFBQUVBQUFBQXdBQUFBQUJBQUFBQVFBQUFBQUFBQUFBQWY4Qi93TCtBdjREL1FBQkFBSC9BdjhDL2dQK0F3QkI4UWtMMVFFQy8vLy9BQUFCQVFBQkFBRUFBQUFBQUFFQUFBQUFBQUVBQUFBQkFBQUFBQUQvQWdFQUFRRUFBUC8vQUFBQUFBQUFBZjhBQWY4QS93SCtBdjcrQXYwQ0EvMzhBL3dFQlBzRit2c0crUVlGQ1BjQUFBRUFBQUFBQUFBQS93RUFBQUgvQUFILy93SC9BZ0gvQXY3K0F2NENBZ1A5QUFFQUFBQUFBQUFCQUFFQUFBSC9BUUFBQWdIL0F2Ly9BdjhDQXY4RC92NytBd0FCQUFBQkFBSC9BdjhDL3dJRC9nUCsvZ1FFL1FYOS9BYjhCZ1g3Q1ByNytRa0dBQU1BQndNQUFRb0FBZ1lTQ2d3RUFBSUFBQUFKQkFjRUFBTU1Cd2NBUWRBTEM1SVFLcS9WeWMvL1FBQVJBR1AvWVFFUS9xTUFKeXU5VnRuL0JnQmJBRmIvdWdBWEFJRDh3QmpZVGUzLzNQOW1BS2YvNlA5SUFVbjhDQW9sUGdBQUFBQUFBSWZIUGNsQUFJQUFodjhrQURZQkFQMUlBak1rUlVVTUFJQUFFZ0J5L3lBQmkvK2YvQnNRZXpnQUFBQUFBQUFBQUdnQ0RjajIveWNBT2dEUy82ei9lQUM0QU1YKzQvMEVCUVFWUUNNQUFBQUE1ajdHeFBQL0FBQVVBQm9BQlFEaC85WC8vUDlCQUZvQUJ3Qmovd2ovMVA5UkFpOEdOQXJIREFBQUFBQUFBQUFBNUZjRnhRTUE4di9zLy9IL0FnQVpBQ1VBR1FEdy83bi9sZit4L3pJQUpBRnZBdFlEQ0FXNEJRQUFBQUFBQUFBQWxHdG54QkVBREFBSUFBRUE5di9xLytMLzRQL3Evd01BTEFCa0FLZ0E4d0E5QVgwQnJRSEhBUUFBQUFBQUFBQUF2UUNvL1drQ1ozZDFBR0gvMHZzSWREUUEzUUNvOW5SdS9QOFJBdXJ5NVdiUS8vWUNqUENsWGJEL2lRTjE3d1pUbmYvTUE0THZaa2VWLzhjRGkvQW5PNW4vZ0FOaDhxNHVwZjhGQTgvMFhpSzUvMk1Db2ZlWUZ0TC9xUUdoK3JRTEFDRCtIL1lmNmgvWUg4SWZxQitJSDJJZk9oOEtIOWdlb0I1aUhpSWUzQjJRSFVJZDdoeVdIRG9jMkJ0eUd3b2JuQm9xR3JRWk9obThHRHdZdGhjdUY2QVdFQlorRmVnVVRoU3dFeEFUYmhMSUVSNFJkQkRHRHhZUFpBNnVEZmdNUUF5RUM4Z0tDZ3BLQ1lvSXhnY0NCejRHZUFXeUJPb0RJZ05hQXBJQnlnQUFBRGIvYnY2bS9kNzhGdnhPKzRqNnd2bisrRHI0ZHZlMjl2YjFPUFY4OU1EekNQTlM4cHp4NnZBNjhJenY0dTQ0N3BMdDhPeFE3TExyR091QzZ2RHBZT25TNkVyb3hPZEU1OGJtVE9iVzVXVGw5dVNPNUNqa3h1TnE0eExqdnVKdzRpVGkzdUdlNFdEaEtPSDI0TWJnbnVCNDRGamdQdUFvNEJiZ0N1QUM0QURnczJNQVJ6Z3JIaFVNQmdBQUFBREhwWkI4YldCVVJ6MHpLaUFYRHdnQThlSFR4N3V2cEptT2hIdHlhV0JZVUVoQU9USXNKaUVkR0JRUURBa0ZBZ0JWQ0FBQVlBZ0FBSEFJQUFBQUFBQUFCQVlZQndVQUFBSUFBQXdjS1EzODl3OHFHUTRCL2o0cDkvWWxRZndEK2dSQ0IvZ1FEaWI5SVFBQUFBQUFBQUFBRFJZbkZ3ei9KRUFiK3ZrS055c1JBUUVJQVFFRzlVbzE5L1EzVFBRSS9RTmRHL3dhSnpzRCtBSUFUUXNKK0JZcytnY29DUm9EQ2ZrVVpma0VBL2dxR2dEeElVUUNGLzQzTHY0UEEvOFZFQ242R3owbkJmVXFXQVFCL2p4QkJ2ei8rMGs0QWZjVFhoMzNBQXhqQmdRSTdXWXU4d01DRFFNQ0NldFVTTzcxTG1qcUNCSW1NQmNBOEVaVDZ3c0Y5WFVXK1BvWGRmUURBL2hmSEFUMkQwMDg4ZjhFZkFMOEF5WlVHT2NDRFNvTkh4WDhPQzcvL3lOUDh4UDVRVmozOGhRRVVUSGpGQUJMQSs4Rjl5eGMrQUg5RmtVZitsOHA5QVVuUXhEOEFRRDZlRGZjOHl4NkJPaFJCUXNEQndJQUNRcFlvQWdBQU5BSUFBQWdDUUFBQUFBQUFBd2pQRk5zaEoyMHp1UVBJRGROWlgyWHI4bmhFeXBDV1hLSm9yalI1Z3daTWtoaGVKT3N5TjhhTEVWYWNvZWZ0TTNoRFJZMVVHcUNuTFRONUE4WkxFQmFjNDZveE40VEdENVNaSGlScUw3V0ZoOHlUMmQ0bDZyTDR4VWRMVUZxZkphcnhPQWVNVXRoZVk2bHV0SGxFeGswUmwxMGo2YkEyeG9pUGt0aGRwR253dGtaSVRoR1czR1BwY1RmRlNJelNHRjFrYXZFM2hRZE1rTmFkWkNveGQwV0h6QkNYM1dTcU1UZUdDRXpUWFNHbnJUSTRCVWNSbGRxZkpXcXd0a2FJVFZBVTNXWXJjemhHeUpCWDJ5Qm02N1M0UlFhU0dOeGc1cXd5TnNpS3oxT1hYS2JzYzNsRngwMllYeUtvN1BSNVI0bU9GbDJnWjZ5eU9jVkhURS9WVytPbzhIZUd6Qk5aNFdlczhUWDZCMHZTbU44bDdERzNPMGhLajFNWFhtYnJzL2hIVFZYY0lpYXFyelE0eGdlTkZTRGxxYTZ5K1VsTUVCVWFIYWNzY25tVVFzS0NRb0pDZ252Q084SUNnbjhDQmNKN3doSUN4UUtXZ2svQ1FvSjRnamlDT0lJNGdpU0NMY0pKQWtrQ1FvSkNna0tDU1FKSkFrL0NUSUprQXpPQ2lRSkpBa0tDZUlJclFpZkNOVUlrZ2ljQ2FvSlB3bGFDVm9KV2dsYUNUOEpad2tLQ1pjTjhBdFBDSjhJNGdqaUNPSUk3d2dLQ2RVSTBneEZEQlFLV2duSENLMElud2lTQ0pJSVFnZ0FFQVVQclFnOENqd0tad2tLQ1ZvSlB3a2FDR29NckF3L0NhMEkrUW1DQ1NRSkNnbDNDSzBJQ2cyZ0RhWUtrZ2pWQ0p3Sk1nay9DWjhJTlFneUNYUUpGd2svQ1ZvSmRBbDBDWFFKbkFrL0NjTU9MUTZDQ2Q4SlB3bmlDT0lJL0FpZkNBQUl0Z3laREprS0hndVBDUmNKL0FqOENPSUlUd2kvRE9RTXdRcjJDbzhKMVFqVkNNY0lUd2cxQ0RrTHBRdEpDajhKWndreUNaSUl4d2pIQ0VJSW1ReDlERWtLRkFyaUNJVUl4d2l0Q0swSVhRaHFETzRNdEFwbkNlSUk0Z2ppQ084SWtnaENDRVVNeUF5Y0NRMEk3d2pFQ1Q4SnR3bUNDWVVJc3czU0RBb0pqQXBYQ3FvSlB3bGFDU1FKVHdoZkRjOE4zZ3Z3Qy93SW5nZXRDT0lJNGdqaUNFd05KZzBuQ0g4S09Rc3lDWFFKNGdpcUNld0pzQTZnRFo0SFpBcFJDOThKV2drL0Nad0oxUWpVQzhnTXRBcElDN1FLYWdoUENPOEl1Z2pIQ0c4T1NRN3BCN0VIWkFxTUNoUUt4QWtYQ1Q4Smh3eFZEVElKR2doSUMwZ0xKQW0zQ2NjSWR3Z0tEU1lOSGd2Y0NoY0phZ2ppQ084SVFnZ05DQmNKL0FpRkNIY0loUWcvQ1VrS2pBcU1DdmtKWndtQ0NhMEkxUWl0Q0swSUpBbDBDUzhLakFyZUM2d005Z3BJQzZvSkdnajhDQW9KTWdsTUNhMElhZ2hQQ084SXhBbnBDdWtLUEFvVUNqOEpYQTZCRHJvSUxnZUZDTUVLcGdweEN0RUpud2pwQ2xnTXBncjVDUjRMMFFtRkNGb0pyUWlGQ05TeWxJRnNZRlZTVDAwOU96azRNekV3TFNvcEtDWWtJaDhlRlF3S0F3RUEvL1gwN09uaDJjdStzSytobFloOWNtWmJVVWM4TkNzakhCUVRFZ3dMQlFDemlveVVsNVdabDZOMFExSTdYRWhrV1Z3QVFmQWJDK2NCRUFBQUFBQmpRaVFrSWlRaUlpSWlVMFVrTkNKMFprWkVSTEJtUkVRaVFWVkVWQ1IwalppTHFvUzd1TmlKaFBtb3VZdG9abVJFUkxMYXVibXE5Tmk3dTZyMHU3dmJpbWVidUxtSmRMZWJtSWlFMmJpNHFxVFpxNXVMOUttNHVhcWsyTi9haXRhUHZOcW85STJJbTZxb2l0emJpNlRieXRpSnFMcjJ1WXQwdWR1NWltUmtobVJtSWtSRVpFU295OTNhcUtlYWlHaEdwUGFyaVl1Sm05cmJpLy8rL2U0T0F3SUJBUC8rL05vakF3SUJBUC8rK3RBN0JBSUJBUC8rOXNKSENnSUJBUC84N0xkU0NBSUJBUC84NjdSYUVRSUJBUC80NEt0aEhnUUJBUC8rN0sxZkpRY0JBRUhnSFF2dURmLy8vNE1Ha2YvLy8vLy83RjBQWVAvLy8vLy93bE1aUjkzLy8vLy9va2tpUXFMLy8vL1Nma2tyT2EzLy8vL0pmVWN3T29MLy8vK21ia2s1UG1qUy8vLzdlMEUzUkdTci93QUFBQUFBQUFBQStnQURBQVlBQXdBREFBTUFCQUFEQUFNQUF3RE5BUUFBSUFBS0FCUXVaQUhRQ1FBQUVBc0FBSkFOQUFEUURRQUE4QTBBQUpBT0FBRGdEZ0FBTUE4QUFBY1hKalpGVldSMGc1T2lzc0hRMys4TkdTazNSVk5pY0grT25hdTd5OXpzRHhVaU16MU9YR3AraUppbnVjM2g4QW9WSkRJL1QxOXVmbzJkcmIzTjNlMFJGQ1V6TzA1WmEzdUdscVM0emVEd0NnOGdNME5SWUhDQmpwNnR2Y3pjN0FnVkpUTkJUMkp4Zm9xYnFMUEEwZG9NRHlJM1AwNVhiSGFEbEtlNXk5dnNFQk1nSkRoUFcyeDJpSnFydXN6YzdRc2NLenBLV1dsNGg1YWx0TVRUNHZFR0VDRXVQRXRjYTN1Sm5LbTV4OWJoQ3hNZUxEbEtXV2w1aDVpcHVzcmE2Z3dUSFM0NVIxaGtlSVNVcGJiSDJPa1JGeU11T0UxY2FudUdtS2U1ek43dERoRXROVDlMV1d0emhKZXJ2TTdkOEFrUUhTZzRSMWhuZDRtYXE3M04zdTBRRXlRd09VeFhhWGFFbHFlNXl0cnNEQkVkTmtkUlhtaCtpSldrdHNuZDdROGNMejVQWVhPQmpwdW90TUxRMys0SURoNHRQazVlYjMrUG42L0F6OS92RVI0eFBrOWNhM2VFa2FDdXZzemM2dzRUSkMwOVRGdHNlWXFhckwzTjN1NE1FaDh0UEV4YmEzdUttcXU3ek4zc0RSRWZLelZHVTJkeWc1V251Y3ZjN1JFV0l5bzZUbDF1Zll1YnFyek80UEFJRHlJeVExTmpjNE9Tb3JMQjBlRHZEUkFwUWtsV1gyK0FpWmFqdDg3aDhSRVpKVFEvUzF4bWQ0U1FvSysvMU9jVEh6RkJVMlIxaFpPaHJydkkxZVB5RWg4MFJGaG5kWDZLbGFPeHdNL2Y3eEFkTHoxTVdtcDNoWk9oc01IUjRQQVBGU015UFVsV1lXNTNnWTJ2eHRydFNRNXRDMjBMYlF0dEMyMExiUXR0QzIwTGJRdHRDMjBMa3d1VEMyMExIZ3VRREEwTW5BdndDL0FMd2d2Q0M4SUxrd3VUQzhJTG5BdElDeDRMSGd1bUNsQVByZytsQzRjTWh3eDJDL0FMSGdzeURLd01iUXNlQ3p3SytRbmNDbTBMdkExOURNSUxId3pMQzBnTGJRdHRDMjBMYlF0SUMwZ0xTQXRJQzBnTHdRcStFNzRUZGd2MURUa044QXNORE9rS1dBeFlESndMSGd2UkNld0p3UXBJQzB3Uk5SQ01Dc0VLbkF2Q0MyMExIZ3VsQzhzTGJRdHRDMjBMYlF0SUM2WUtKQTdMQzV3TDhBdndDemtMOWdyd0M1QU01d3VsQzlzTTJ3eWxDKzRNcnd0ckZKWVQ3QWtLRGNZTk9RMTlEQllNTUEybEM0d0tWd3AvQ3VrS0hndHhDdGtUTmhRSEVrd1JuQWxSQytjTGh3eGhESDhLdEFwSUN4NEw2UW9lQzR3S01neElDNU1MYlF0dEMyMExiUXVUQzVNTGt3dVRDMjBMYlF1VEM1TUxrd3RxRUljTXBRc2ZETUlMU0F0SUMyMExuQXM1QzJRTHl3dWNDOElMZlF3NUM3QU9zQTZzREI4TXBRdElDMjBMU0F1Y0MzWUw2UXJwQ2g0TFNBdElDMlFLRGcrdUQ0Y01NZ3lzREhZTDV3dVRDNU1MRFF3ZUMra0s2UXJwQ3VrS0ZBb0ZEL0FQSFEyOERSWU10QXJDQzNZTE1nd05EQjRMSGd0WENsY0tIZ3YyQ2hzVUhoT1pEQVVQY1ExaERGRUxWUTE3RFl3S0ZBcHhDclFLSGd2MkNzRUtEUkRORHRzTVdBeHRDMGdMU0F0dEMra0t0QXJwQ3JRSzZRb2VDMGdMOWdyWkU3NFQ1d3ZaRGF3TThBc05ESUFMSHd4UkM3UUt0QXEwQ2g0TDZRbzhDdFVRMVJBc0M5OEpod3d3RFRBTkF3d0REREFOOEFzZUMxY0tGQXFtQ3NFSzhBdGtDL1lLU0F1MENuOEtVUXNmREU0TVRneVFER0VNOEF2Q0M1TUxIZ3NYRVNvUGJRdElDeDRMU0FzZUN4NExTQXRJQzBnTEhndElDMjBMU0FzZUM2VUxaQXRrQzZVTHBRdndDeklNa0F4T0RQQUx3Z3VjQzV3TG5BdHRDN1FLaFJBMUVPNE1FdzF0QzVNTFNBdWxDNlVMSGd2cENyUUtIZ3NlQ3g0TDZRcndENjRQSHd6Q0MyMExiUXR0QzBnTGJRdHRDeDRMSGdzZUMra0tTQXZjQ2djUzN4RmhESEVOaHd5bEMxRUwzZ3N5RExRS2Z3cC9DbjhLdEFycENvd0tOUkN0RU0wT1NRNm1DdHdLU0F0SUM4SUxuQXR0Q3g0TGZ3cC9DdWtLU0F0M0VPSU53UW9lQ3g0TFNBdElDMGdMYlF0dEMwZ0xiUXR0QzIwTGt3dElDellVT1JQVkNHZ056UTZYRFJNTkhndnVESmNOVGd4UkM1d0p0d25CQ20wTGV3MWxEaklNZlF3ZERlY0xod3lIREtVTGtBd05ERzBMYlF0L0N1d0pnZ21sQzhJTDZRcnBDclFLNlFvZUM1d0w4QXNmREU0TVRneE9EQjhNd2d2Q0M0QUxPUXQvQ3FZSzNBckNDMmdOMlEwZERhd004QXZDQzVNTGJRdElDeDRMeXd1QUMxRUx3Z3ZDQzV3THl3c2ZEUEFMOEF2Q0MwZ0xIZ3R0QzIwTFNBdFFEMzhQd2d0OURCME5rQXpiRE5zTWx3MTREbkVOcGdxRkNKd0pGQW92Q3VITXliaTNyNTZhbVlkM2MzRnViV05pWDA5RU5ESXdMU3NnSHhzU0NnTUEvL3ZyNXRUSnhMYW5wcU9YaW54dWFGcE9URVpGT1MwaUdCVUxCZ1VFQXdDdmxLQ3dzcTJ1cExHdXhMYkd3TFpFUGtJOFNIVlZXbmFJbDQ2Z2pwc0FRZGNyQzhBQ0FXUm1aa1JFSkNKZ3BHdWV1YlM1aTJaQVFpUWlJZ0FCSU5DTGpiK1l1WnRvWUt0b3BtWm1ab1FCQUFBQUFCQVFBRkJ0VG11NWkyZGwwTlNOaTYyWmUyY2tBQUFBQUFBQUFUQUFBQUFBQUFBZ1JJZDdkM2RuUldKRVozaDJkbVpIWW9hSW5iaTJtWXVHMEtqNFM3MlBlV3NnTVNJaUlnQVJBdExyaTN1NWlXbUdZb2RvdG1TM3E0WmtSa1JHUWtJaWcwQ21aa1FrQWdFQWhxWm1SQ0lpUW9UVTlwNkxhMnRYWm1UYmZYcUpkbWVFY29lSmFhdHFNaUtrMW8yUHVaZDVaOEFpQUFBQUFBQUIwRzFLdTRiNW40bG1icHAyVjJWM1pRQUNBQ1FrUWtRallLUm1aQ1FBQWlHbmlxNW1aRlFDQW1ScmVIY2t4UmdBLy83OTlBd0RBZ0VBLy83ODRDWURBZ0VBLy83NzBUa0VBZ0VBLy83MHcwVUVBZ0VBLy92b3VGUUhBZ0VBLy83d3VsWU9BZ0VBLy83dnNsc2VCUUVBLy9qanNXUVRBZ0VBUWFBdUM3Y0IvLy8vbkFTYS8vLy8vLy9qWmc5Yy8vLy8vLy9WVXhoSTdQLy8vLytXVENFLzF2Ly8vNzU1VFNzM3VmLy8vL1dKUnlzN2kvLy8vLytEUWpKQ2E4TC8vNlowVERjMWZmLy9BQUFBQUFBQUFBQmtBQU1BS0FBREFBTUFBd0FGQUE0QURnQUtBQXNBQXdBSUFBa0FCd0FEQUZzQkFBQWdBQkFBWmlhckFYQVBBQUJ3RVFBQWNCVUFBTEFWQUFEUUZRQUEwQllBQUNBWEFBQndGd0FBQUFBQUFPQndMQThEQWdFQS91M0FoRVlYQkFELy9PS2JQUXNDQUVIZ0x3djBBZnIxNnN0SE1pb21JeUVmSFJ3Ykdoa1lGeFlWRkJNU0VSQVBEZzBNQ3dvSkNBY0dCUVFEQWdFQUFBQUFBQUFBQUZ6S3Z0aTIzNXJpbk9aNDdIcjB6UHcwQTRZTGlCTmtHV1lkU2lCQ0o2UTErZmYyOWZUcTBzckp5TVd1VWpzNE56WXVGZ3dMQ2drSEFFQUF5NVlBMThPbWZXNVNBQUFBQUVzWUFBQk9HQUFBZUFDQVFBRG9uZ29BNWdEejNjQzFBR1FBOEFBZ0FHUUF6VHdBTUFBZ3ExVUF3SUJBQU0yYVpqTUExYXVBVlNzQTRNQ2dnR0JBSUFCa0tCQUhBd0VBQVAzNjlPblV0cGFEZUc1aVZVZzhNU2dnR1JNUERRc0pDQWNHQlFRREFnRUEwdERPeThmQnQ2aU9hRW8wSlJzVURnb0dCQUlBUWVBeEMvTUIzOG0zcDVpS2ZHOWlXRTlHUGpneUxDY2pIeHNZRlJJUURnd0tDQVlFQXdJQkFMeXdtNHAzWVVNckdnb0FwWGRRUFM4akd4UU9DUVFBY1Q4QUFBQUFBSDB6R2hJUERBc0tDUWdIQmdVRUF3SUJBTVpwTFJZUERBc0tDUWdIQmdVRUF3SUJBTldpZEZNN0t5QVlFZzhNQ1FjR0JRTUNBTys3ZERzY0VBc0tDUWdIQmdVRUF3SUJBUHJsdklkV014NFREUW9JQmdVRUF3SUJBUG5yMWJtY2dHZFRRalVxSVJvVkVRMEtBUDc1Njg2a2RrMHVHeEFLQndVRUF3SUJBUC85K2UvY3Y1eDNWVGtsRnc4S0JnUUNBUC85Ky9idDM4dXptSHhpU3pjb0hSVVBBUC8rL2ZmY29tcERLaHdTREFrR0JBTUNBRUhnTXdzUjhiNnloRmRLS1E0QTM4R2RqR281SnhJQVFZQTBDNWNCZ0FEV0tnRHJnQlVBOUxoSUN3RDQxb0FxQndENDRhcFFHUVVBKyt6R2ZqWVNBd0Q2N3RPZlVpTVBCUUQ2NTh1b2dGZzFHUVlBL083WXVaUnNSeWdTQkFEOTgrSEhwb0JhT1I4TkF3RCs5dW5VdDVOdFNTd1hDZ0lBLy9ydzM4YW1nRm82SVJBR0FRRC8rL1RuMHJXU2Jrc3VHUXdGQVFELy9manUzY1NrZ0Z3OEl4SUlBd0VBLy8zNTh1WFF0Skp1VERBYkRnY0RBUUJCb0RVTGx3R0JBTTh5QU95QkZBRDF1VWdLQVBuVmdTb0dBUHJpcVZjYkJBRDc2Y0tDUGhRRUFQcnN6NkJqTHhFREFQL3cyYmFEVVNrTEFRRC8vdW5KbjJzOUZBSUJBUC81NmM2cWdGWXlGd2NCQVAvNjd0bTZsR3hHSnhJR0FRRC8vUFBpeUthQVdqZ2VEUVFCQVAvODllZlJ0Skp1VEM4WkN3UUJBUC85K08zYndxT0FYVDRsRXdnREFRRC8vdnJ4NHMyeGtXOVBNeDRQQmdJQkFFSEFOZ3VYQVlFQXl6WUE2b0VYQVBXNFNRb0ErdGVCS1FVQS9PaXRWaGdEQVAzd3lJRTREd0lBL2ZUWnBGNG1DZ0VBL2ZYaXZZUkhHd2NCQVAzMjU4dWZhVGdYQmdFQS8vanIxYk9GVlM4VEJRRUEvLzd6M2NLZmRVWWxEQUlCQVAvKytPclFxNEJWTUJZSUFnRUEvLzc2OE55OWxXdERKQkFHQWdFQS8vNzc4K1BKcG9CYU54ME5CUUlCQVAvKy9QYnExYmVUYlVrckZnb0VBZ0VBUWVBM0M1Y0JnZ0RJT2dEbmdob0E5TGhNREFENTFvSXJCZ0Q4NksxWEdBTUEvZkhMZ3pnT0FnRCs5dDJuWGlNSUFRRCsrZWpCZ2tFWEJRRUEvL3Z2MDZKakxROEVBUUQvKy9QZnVvTktJUXNEQVFELy9QWG15cDVwT1JnSUFnRUEvLzMzNjlhemhGUXNFd2NDQVFELy92cnczOFNmY0VVa0R3WUNBUUQvL3YzMTU5R3dpRjAzR3dzREFnRUEvLzc5L08vZHdwNTFUQ29TQkFNQ0FRQkJnamtMRHdJRkNRNFVHeU1zTmtGTldtaDNod0JCb0RrTHhRSCtNVU5OVWwxanhnc1NHQjhrTGY4dVFrNVhYbWpRRGhVZ0tqTkMvMTVvYlhCemR2ZzFSVkJZWDJZQUFBQUFBQUFBQVFFQkFnTURBd0lEQXdNQ0F3TURBQU1NRHpBelBEL0F3OHpQOFBQOC93RUFBQUFBQUFBQUF3QUFBQUFBQUFBQ0FBQUFBUUFBQUFjQUFBQUFBQUFBQkFBQUFBTUFBQUFHQUFBQUFRQUFBQVVBQUFBQ0FBQUFEd0FBQUFBQUFBQUlBQUFBQndBQUFBd0FBQUFEQUFBQUN3QUFBQVFBQUFBT0FBQUFBUUFBQUFrQUFBQUdBQUFBRFFBQUFBSUFBQUFLQUFBQUJRQkI4VG9MTDBES1JSdE0vMUtDV3JOaW9tdGdkUUFBblQ0QVFGNCtBTUFFUGdDQTdUNEFRSWsrQUFBQUFBREFURDhBQU0wOUFFR3hPd3ZWQXY4QS93RC9BUDhBL3dEK0FRQUIvd0QrQVAwQ0FBSC9BUDRBL1FNQUFmL3dIUUFBK0IwQUFBa2VBQUFhSGdBQUtSNEFBRG9lQUFCU0hnQUFZQjRBQUhOMVkyTmxjM01BYVc1MllXeHBaQ0JoY21kMWJXVnVkQUJpZFdabVpYSWdkRzl2SUhOdFlXeHNBR2x1ZEdWeWJtRnNJR1Z5Y205eUFHTnZjbkoxY0hSbFpDQnpkSEpsWVcwQWNtVnhkV1Z6ZENCdWIzUWdhVzF3YkdWdFpXNTBaV1FBYVc1MllXeHBaQ0J6ZEdGMFpRQnRaVzF2Y25rZ1lXeHNiMk5oZEdsdmJpQm1ZV2xzWldRQWRXNXJibTkzYmlCbGNuSnZjZ0FDQVFBWkZ3SUFmbngzYlZjcEV3a0VBZ0FBQUFDQXV3QUFlQUFBQUJVQUFBQVZBQUFBQUpwWlB3QUFBQUFBQUlBL0FBQ0FQeEFmQUFBREFBQUFDQUFBQUhnQUFBQUxBQUFBUUI4QUFEQWdBQUJnSUFBQWdBY0FBQU1BQUFCQUlnQUFZRllBQUpCWEFBQklXQUFBZ0NJQUFJZ0JBQUNnUGdBQWdEOEFBQkJCQUVHU1Bnc3BBUUFDQUFNQUJBQUZBQVlBQndBSUFBb0FEQUFPQUJBQUZBQVlBQndBSWdBb0FEQUFQQUJPQUdRQVFkVStDOUlCV2xCTFJUODRNU2dpSFJRU0NnQUFBQUFBQUFBQWJtUmFWRTVIUVRvekxTY2dHaFFNQUFBQUFBQUFkbTVuWFZaUVMwWkJPelV2S0I4WER3UUFBQUFBZm5kd2FGOVpVMDVJUWp3Mkx5Y2dHUkVNQVFBQWhuOTRjbWRoVzFWT1NFSThOaThwSXgwWEVBb0JrSW1DZkhGclpWOVlVa3hHUURrekxTY2hHZzhCbUpHS2hIdDFiMmxpWEZaUVNrTTlOekVySkJRQm9wdVVqb1YvZVhOc1ptQmFWRTFIUVRzMUxoNEJyS1dlbUkrSmczMTJjR3BrWGxkUlMwVS9PQzBVeU1qSXlNakl5TWpHd2J5M3NxMm9vNTZabElGb0FFSEF3QUFMbndRSUFBZ0FDQUFJQUJBQUVBQVFBQlVBRlFBWUFCMEFJZ0FrQUFBQUFBQUFBR29jalRoU3V4NDZDR25jT29MdFZ6dUpZN0k3QXlvRlBERGNPVHkwUG5jOEhLT2VQTkh5eFR6K2h2RThtNnNRUFFXdEtqMkV3a1k5VStaa1BSR0pnajJIbjVNOXk3S2xQZEcrdUQwNnY4dzlWSy9oUFJTSzl6ME9KUWMrMmZRU1BsOHhIejVvMXlzK2l1TTRQakJTUmo2VUgxUSt2MGRpUG83R2NENndsMzgrVWx1SFBtQVBqejZZNVpZK2VkdWVQbkR1cGo3WUc2OCsrMkMzUGhHN3Z6NUdKOGcrdDZMUVBuZ3EyVDZVdStFK0RGUHFQdDd0OGo0R2lmcyt2aEFDUHg5YUJqOGtud28vVU40T1B5c1dFejlCUlJjL0pXb2JQM09ESHovT2p5TS81bzBuUDNSOEt6OC9XaTgvR1NZelArZmVOaitaZ3pvL014TStQOFdNUVQ5MzcwUS9menBJUHlkdFN6L09oazQvNVlaUlAvRnNWRCtPT0ZjL2FlbFpQMFYvWEQvNitWNC9jMWxoUDYrZFl6L0J4bVUvejlSblB4SElhVC9Tb0dzL2JsOXRQMUFFYnovMGozQS81Z0p5UDcxZGN6OGZvWFEvdjgxMVAxZmtkait3NVhjL2w5SjRQK09yZVQ5emNuby9KeWQ3UCtmS2V6K2RYbncvTmVOOFA1eFpmVCs5d24wL2hoOStQOTV3ZmorcnQzNC96L1IrUHlZcGZ6K0dWWDgvdm5wL1A1YVpmei9Nc244L0ZNZC9QeHpYZnorQzQzOC8zZXgvUDdiemZ6K0srSDgveVB0L1A5YjlmejhILzM4L3BmOS9QK2ovZnovOS8zOC9BQUNBUCtBQkFBQ0hpQWc3Ly8vLy93VUFZQUFEQUNBQUJBQUlBQUlBQkFBRUFBRUFRZXpFQUFzR3dFRUFBSUJGQUVHQXhRQUx5VGovLzM4L2p2OS9QMnIrZnorVC9IOC9CL3AvUDhqMmZ6L1c4bjgvTU81L1A5Ym9mei9JNG44L0I5eC9QNVBVZno5cnpIOC9qOE4vUHdDNmZ6KzlyMzgveDZSL1B4Mlpmei9Bakg4L3NIOS9QK3h4Zno5MlkzOC9TMVIvUDI1RWZ6L2VNMzgvbWlKL1A2TVFmei82L1g0L25lcCtQNDNXZmovTHdYNC9WcXgrUHk2V2ZqOVRmMzQveG1kK1A0WlBmaitVTm40Lzd4eCtQNWdDZmorUDUzMC8wOHQ5UDJhdmZUOUdrbjAvZEhSOVAvRlZmVCs4Tm4wLzFSWjlQenoyZkQveTFIdy85cko4UDBtUWZEL3JiSHcvMjBoOFB4c2tmRCtwL25zL2g5aDdQN1N4ZXo4d2lucy8vR0Y3UHhjNWV6K0NEM3MvUGVWNlAwaTZlaitpam5vL1RXSjZQMGcxZWorVUIzby9NTmw1UHgycWVUOWFlbmsvNlVsNVA4Z1llVC81NW5nL2U3UjRQMDZCZUQ5elRYZy82aGg0UDdMamR6L05yWGMvT25kM1Avay9kejhLQ0hjL2JzOTJQeVdXZGo4dlhIWS9qQ0YyUHp6bWRUOUFxblUvbDIxMVAwSXdkVDlCOG5RL2xMTjBQenQwZEQ4M05IUS9oL056UHl5eWN6OG1jSE0vZGkxelB4cnFjajhVcG5JL1pHRnlQd29jY2o4RjFuRS9WNDl4UHdCSWNULy8vM0EvVmJkd1B3SnVjRDhHSkhBL1l0bHZQeFdPYno4Z1FtOC9oUFZ1UHorb2JqOVRXbTQvd0F0dVA0YThiVCtsYkcwL0hSeHRQKy9LYkQ4YmVXdy9vU1pzUDREVGF6KzdmMnMvVUN0clAwRFdhaitNZ0dvL01pcHFQelhUYVQrVGUyay9UU05wUDJUS2FEL1ljR2cvcUJab1A5VzdaejlnWUdjL1NBUm5QNCtuWmo4elNtWS9OdXhsUDVlTlpUOVhMbVUvZDg1a1AvVnRaRC9VREdRL0VxdGpQN0ZJWXordzVXSS9FSUppUDlFZFlqL3p1R0UvZDFOaFAxenRZRCtraG1BL1RoOWdQMXUzWHovTFRsOC9udVZlUDlWN1hqOXdFVjQvYnFaZFA5STZYVCthemx3L3htRmNQMW4wV3o5Umhscy9yaGRiUDNLb1dqK2RPRm8vTHNoWlB5ZFhXVCtINVZnL1QzTllQMzhBV0Q4WGpWYy9HQmxYUDRLa1ZqOVdMMVkvazdsVlB6cERWVDlMekZRL3gxUlVQNjdjVXo4QlpGTS92K3BTUCtsd1VqOS85bEUvZ250UlAvTC9VRC9QZzFBL0dnZFFQOUtKVHovNkMwOC9rSTFPUDVRT1RqOEpqMDAvN1E1TlAwR09URDhGRFV3L080dExQK0VJU3ovNWhVby9nd0pLUDM5K1NUL3UrVWcvejNSSVB5VHZSei90YUVjL0tlSkdQOXBhUmo4QTAwVS9tMHBGUDZ6QlJEOHlPRVEvTDY1RFA2SWpReitObUVJLzd3eENQOGlBUVQ4YTlFQS81V1pBUHlqWlB6L2xTajgvRzd3K1A4d3NQai8zbkQwL25RdzlQNzU3UEQ5YzZqcy9kVmc3UHdyR09qOGRNem8vclo4NVA3c0xPVDlIZHpnL1VlSTNQOXBNTnovanRqWS9heUEyUDNTSk5ULzk4VFEvQjFvMFA1UEJNeitnS0RNL01JOHlQMEwxTVQvWVdqRS84Yjh3UDQ0a01EK3ZpQzgvVmV3dVA0RlBMajh5c2kwL2FSUXRQeWQyTEQ5cjF5cy9OemdyUDR1WUtqOW4rQ2svekZjcFA3cTJLRDh5RlNnL00zTW5QNy9RSmovV0xTWS9lWW9sUDZmbUpEOWhRaVEvcVowalAzMzRJai9mVWlJL3o2d2hQMDBHSVQ5Ylh5QS8rTGNmUHlVUUh6L2laeDQvTUw4ZFB4QVdIVCtCYkJ3L2hNSWJQeG9ZR3o5RGJSby9BTUlaUDFFV0dUODJhaGcvc2IwWFA4RVFGejluWXhZL283VVZQM1lIRlQvaFdCUS81S2tUUDMvNkVqK3pTaEkvZ0pvUlArZnBFRC9vT0JBL2hJY1BQN3ZWRGorT0l3NC8vbkFOUHdxK0REK3pDZ3cvK2xZTFA5K2lDajlqN2drL2hqa0pQMG1FQ0Qrc3pnYy9yeGdIUDFSaUJqK2Jxd1UvZy9RRVB3ODlCRDg5aFFNL0Q4MENQNFlVQWoraFd3RS9ZYUlBUDQvUi96Nm5YZjQrRHVuOFBzSnorejdHL2ZrK0c0ZjRQc0VQOXo2NmwvVStCaC8wUHFpbDhqNmVLL0UrN0xEdlBwRTE3ajZRdWV3KzZEenJQcHEvNlQ2cFFlZytGY1BtUHQ5RDVUNEl4T00ra1VQaVBuekM0RDdJUU44K2VMN2RQb3c3M0Q0R3VObys1alBaUGk2djF6N2ZLZFkrK2FQVVBuMGQwejV1bHRFK3pBN1FQcGVHemo3Uy9jdytmWFRMUHBucXlUNG5ZTWcrS05YR1BwOUp4VDZLdmNNKzdERENQc2Fqd0Q0WkZyOCs1b2U5UGkzNXV6N3hhYm8rTXRxNFB2Rkp0ejR2dWJVKzdpZTBQaStXc2o3eUE3RStPWEd2UGdUZXJUNVdTcXcrTDdhcVBwQWhxVDU2aktjKzcvYWxQdTlncEQ1OHlxSStsek9oUGtDY256NTZCSjQrUkd5Y1BxSFRtajZST3BrK0ZxR1hQakFIbGo3aGJKUStLZEtTUGdzM2tUNkhtNDgrbnYrTlBsRmpqRDZpeG9vK2tTbUpQaUNNaHo1UTdvVStJbENFUHBleGdqNndFb0UrM3VaK1BxbW5lejdEWjNnK0x5ZDFQdTdsY1Q0RXBHNCtjMkZyUGp3ZWFENWkybVErNkpWaFBzOVFYajRhQzFzK3pNUlhQdVo5VkQ1ck5sRStYZTVOUHIrbFNqNlNYRWMrMmhKRVBwZklRRDdPZlQwK2dESTZQcTdtTmo1ZG1qTStqVTB3UGtJQUxUNTlzaWsrUW1RbVBwRVZJejV1eGg4KzIzWWNQdG9tR1Q1dDFoVSttSVVTUGxzMER6NjY0Z3MrdDVBSVBsUStCVDZVNndFKzhERDlQUWFLOWoxeDR1ODlNenJwUFUrUjRqM1A1OXM5dFQzVlBRT1R6ajNBNThjOThqdkJQWnlQdWozRDRyTTliRFd0UFp1SHBqMVYyWjg5bnlxWlBYNTdrajMyeTRzOUN4eUZQWWZYZkQxR2RtODlYUlJpUGRheFZEMjVUa2M5RU9zNVBlV0dMRDFBSWg4OUxMMFJQYkpYQkQyMTQrMDhZQmZUUEhaS3VEd0xmWjA4TXErQ1BQckJUenorSkJvOEtnL0pPNW1uT3pzdWZkYTUwa1p4dTZ2ZTQ3dW1qQ2U4Z1NsZHZPRmlpYnlnTUtTODdQMit2TFBLMmJ6Z2x2UzhNYkVIdlpNV0ZiMk1leUs5RStBdnZSNUVQYjJscDBxOW5RcFl2ZjVzWmIyK3puSzk2aGVBdlJ2SWhyM3RkNDI5WENlVXZXUFdtcjM5aEtHOUpqT292ZG5ncnIwUmpyVzl5anE4dmY3bXdyMnFrc205eUQzUXZWVG8xcjFLa3QyOXBEdmt2VjNrNnIxeWpQRzkzVFA0dlpyYS9yMVN3QUsrL0JJR3ZrZGxDYjR5dHd5K3VnZ1F2dDFaRTc2WXFoYSs2dm9adnRCS0hiNUhtaUMrVHVranZ1RTNKNzRBaGlxK3B0TXR2dE1nTWI2RGJUUyt0Ymszdm1VRk83NlRVRDYrT3B0QnZscmxSTDd3TGtpKytYZEx2blRBVHI1ZENGSytzMDlWdm5PV1dMNmMzRnUrS2lKZnZodG5ZcjV0cTJXK0grOW92aXd5Ykw2VWRHKytWTFp5dm1yM2RiN1ROM20ralhkOHZwYTJmNzUxZW9HK1JSbUR2cm0zaEw3UVZZYStpUE9IdnVHUWliN2FMWXUrY01xTXZxUm1qcjUwQXBDKzM1MlJ2dVE0azc2QjA1Uyt0bTJXdm9FSG1MN2lvSm0rMXptYnZsL1NuTDU1YXA2K0l3S2d2bDZab2I0bU1LTytmY2Frdm1CY3ByN084YWUreG9hcHZrY2JxNzVRcjZ5KzRFS3V2dlhWcjc2UGFMRytyZnF5dmsyTXRMNXVIYmErRUs2M3ZqQSt1YjdQemJxKzZseTh2b0xydmI2VWViKytId2ZCdmlPVXdyNmZJTVMra2F6RnZ2ZzN4NzdUd3NpK0lrM0t2dUxXeTc0VFlNMit0ZWpPdnNWdzBMNUMrTkcrTFgvVHZvTUYxYjVEaTlhK2JSRFl2ditVMmI3NUdOdStXWnpjdmgwZjNyNUdvZCsrMHlMaHZzR2o0cjRRSk9TK3ZxUGx2c3dpNTc0NG9laStBQi9xdmlTYzY3NmlHTzIrZXBUdXZxc1A4TDR6aXZHK0VnVHp2a1o5OUw3UDlmVytxbTMzdnRuaytMNVlXL3ErS05IN3ZrZEcvYjYxdXY2K09CY0F2N3ZRQUwva2lRRy9za0lDdnlYN0FyODdzd08vOW1vRXYxTWlCYjlUMlFXLzlZOEd2emhHQjc4ZC9BZS9vckVJdjhkbUNiK01Hd3EvOE04S3YvT0RDNytUTnd5LzBlb012NnlkRGI4a1VBNi9PQUlQditpekQ3OHlaUkMvR0JZUnY1ZkdFYit3ZGhLL1l5WVR2NjdWRTcrUmhCUy9EVE1WdngvaEZiL0lqaGEvQ0R3WHY5M29GNzlJbFJpL1NFRVp2OXpzR2I4RW1CcS93RUlidncvdEc3L3dsaHkvWTBBZHYyanBIYi8ra1I2L0pUb2Z2OXpoSDc4amlTQy8raThodjEvV0liOVNmQ0svMUNFanYrUEdJNzkvYXlTL3B3OGx2MXl6SmIrZFZpYS9hUGttdjcrYko3K2dQU2kvQzk4b3YvOS9LYjk5SUNxL2c4QXF2eEZnSzc4bi95dS94SjBzditnN0xiK1MyUzIvdzNZdXYza1RMNyswcnkrL2Mwc3d2N2ZtTUw5L2dURy95eHN5djVtMU1yL3FUak8vdmVjenZ4S0FOTC9vRnpXL1A2ODF2eFpHTnI5dTNEYS9SWEkzdjV3SE9MOXhuRGkveFRBNXY1YkVPYi9tVnpxL3N1bzZ2L3g4TzcvQ0RqeS9BNkE4djhFd1BiLzZ3RDIvclZBK3Y5dmZQcitEYmorL3Bmdy92MENLUUw5VEYwRy80S05CditRdlFyOWd1MEsvVTBaRHY3N1FRNytlV2tTLzl1TkV2OEpzUmI4RjlVVy92SHhHditnRFI3K0ppa2UvblJCSXZ5V1dTTDhnRzBtL2pwOUp2MjhqU3IvQnBrcS9oaWxMdjd5clM3OWpMVXkvZXE1TXZ3SXZUYi82cmsyL1lpNU92em10VHI5K0swKy9NNmxQdjFVbVVML21vbEMvNUI1UnYxQ2FVYjhvRlZLL2JZOVN2eDRKVTc4N2dsTy93L3BUdjdkeVZMOFc2bFMvMzJCVnZ4TFhWYit3VEZhL3Q4Rld2eWMyVjc4QXFsZS9RaDFZdit5UFdMLytBVm0vZUhOWnYxbmtXYitpVkZxL1VjUmF2Mll6VzcvaW9WdS93dzljdndwOVhMKzM2VnkveUZWZHZ6N0JYYjhZTEY2L1Y1WmV2L24vWHIvL2FGKy9hTkZmdnpNNVlMOWlvR0MvOHdaaHYrVnNZYjg2MG1HLzhEWml2d2liWXIrQS9tSy9XV0ZqdjVMRFk3OHNKV1MvSllaa3YzN21aTDgzUm1XL1RxVmx2OFVEWnIrYVlXYS96YjVtdjE0Ylo3OU5kMmUvbXRKbnYwUXRhTDlMaDJpL3J1Qm92Mjg1YWIrTGtXbS9CT2xwdjlrL2FyOEpsbXEvbE90cXYzdEFhNys4bEd1L1dlaHJ2MDg3YkwrZ2pXeS9TOTlzdjA4d2JiK3RnRzIvWmRCdHYzVWZici9mYlc2L29idHV2N3NJYjc4dVZXKy8rS0J2dnh2c2I3K1ZObkMvWjRCd3Y1REpjTDhQRW5HLzVsbHh2eE9oY2IrWDUzRy9jUzF5djZCeWNyOG10M0svQWZ0eXZ6SStjNys0Z0hPL2xNSnp2OFFEZEw5SlJIUy9Jb1IwdjFERGRML1NBWFcvcUQ5MXY5SjhkYjlRdVhXL0lmVjF2MFV3ZHIrOWFuYS9pS1IydjZiZGRyOFdGbmUvMlUxM3YrK0VkNzlYdTNlL0VmRjN2eDBtZUw5NlduaS9LbzU0dnl2QmVMOTk4M2kvSVNWNXZ4WldlYjljaG5tLzhyVjV2OXJrZWI4U0UzcS9ta0I2djNOdGVyK2RtWHEvRnNWNnY5L3Zlci80R1h1L1lVTjd2eHBzZTc4aWxIdS9lcnQ3dnlEaWU3OFhDSHkvWEMxOHYvQlJmTC9UZFh5L0JabDh2NGE3Zkw5VjNYeS9jLzU4djk4ZWZiK2FQbjIvbzExOXYvcDdmYitmbVgyL2tyWjl2OVBTZmI5aTduMi9Qd2wrdjJramZyL2hQSDYvcDFWK3Y3cHRmcjhiaFg2L3ladCt2OFN4ZnI4TngzNi9vdHQrdjRYdmZyKzFBbisvTWhWL3Yvd21mNzhUT0grL2RraC92eWRZZjc4a1ozKy9iblYvdndXRGY3L29qMysvR1p4L3Y1V25mNzlmc24rL2RMeC92OWZGZjcrRnpuKy9nZFovdjhqZGY3OWQ1SCsvUGVwL3YycnZmNy9qODMrL3FmZC92N3Y2Zjc4Wi9YKy94UDUvdjd2L2Y3LzYvMzgvT2Y1L1A2bjVmejlMOG44L0h1aC9QeVBiZno5WnkzOC93YmgvUDF1amZ6OG9pMzgvSjNCL1AxcFNmeisvTVg4L1dBNS9QeVhvZmo4bXYzNC9YSk4rUDhoa2ZqOXBNMzQvUWY5OVAwL0lmVCtXam4wL0ZGSjlQOHNTZlQrODBIdy81NHQ4UDAxRWZEL3YrWHMvemF4N1ArbGNlejlEQ25zLzNiUjZQN1pjZWovUkFYby9McVI1UDg1RGVUK3k0SGcvM0hwNFAwd1NlRDhFcDNjL0JEbDNQMC9JZGova1ZIWS94dDUxUC9abGRUOTE2blEvUkd4MFAyWHJjei9hWjNNL28rRnlQOEpZY2o4NXpYRS9DVDl4UHpTdWNEKzdHbkEvb0lSdlArVHJiaitLVUc0L2s3SnRQd0VTYlQvVmJtdy9FY2xyUDdjZ2F6L0pkV28vU2NocFB6a1lhVCtiWldnL2I3Qm5QN3I0Wmo5OFBtWS91SUZsUDIvQ1pEK2tBR1EvV2p4alA1RjFZajlNckdFL2p1QmdQMWtTWUQrdVFWOC9rVzVlUHdPWlhUOEl3Vncvb09aYlA4OEpXeitZS2xvLyswaFpQLzFrV0QrZmZsYy81WlZXUDlDcVZUOWp2VlEvb2MxVFA0emJVajhuNTFFL2RmQlFQM24zVHo4MC9FNC9xLzVOUDkvK1REL1UvRXMvalBoS1B3cnlTVDlTNlVnL1pkNUhQMGZSUmovN3dVVS9oTEJFUCtXY1F6OGdoMEkvT205QlB6UlZRRDhUT1Q4LzJCbytQNGo2UEQ4bTJEcy90TE02UHphTk9UK3ZaRGcvSWpvM1A1TU5OajhGM3pRL2ZLNHpQL2w3TWorQ1J6RS9HUkV3UDhMWUxqOS9uaTAvVm1Jc1AwZ2tLejlhNUNrL2tLSW9QK3RlSno5eEdTWS9KZElrUHdtSkl6OGpQaUkvZGZFZ1B3U2pIei9TVWg0LzVBQWRQejJ0R3ovaFZ4by8wd0FaUHhtb0Z6KzBUUlkvcXZFVVAvMlRFeit5TkJJL3pOTVFQMUJ4RHo5Q0RRNC9wS2NNUDN4QUN6L04xd2svbW0wSVAra0JCeis5bEFVL0dTWUVQd08yQWo5K1JBRS9IS1AvUG02Ni9ENzZ6dmsreXVEMlB1VHY4ejVSL1BBK0dnYnVQa2NONno3Z0VlZys3UlBsUG5jVDRqNkhFTjgrSkF2Y1BsZ0QyVDRxK2RVK3BPelNQczNkeno2dnpNdytVcm5KUHIranhqNytpOE0rR0hMQVBoWld2VDRBT0xvKzRCZTNQcjMxc3o2aDBiQStsYXV0UHFLRHFqN1BXYWMrSnk2a1BySUFvVDU1MFowK2hhQ2FQdDl0bHo2UE9aUStvQU9SUGhyTWpUNEZrNG8rYTFpSFBsWWNoRDdOM29BK3RqOTdQaEMvZEQ2N08yNCt5YlZuUGswdFlUNVpvbG8rL3hSVVBsR0ZUVDVqODBZK1JsOUFQZzNKT1Q3S01ETStrSllzUG5MNkpUNkNYQjgrMHJ3WVBuWWJFajUvZUFzK0FkUUVQaDFjL0QxeURlODlLYnpoUFdabzFEMU9Fc2M5Q0xxNVBiaGZyRDJFQTU4OWtxV1JQUWRHaEQwU3ltMDllZ1ZUUFpFK09EMmtkUjA5L0tvQ1BjcTl6enhXSTVvOFlRNUpQTVdudXpzOWVsYTZDVWJ4dXhMZFk3eFFpcWU4UVNUZHZPTmRDYjBqS0NTOWx2QSt2ZksyV2IzcWVuUzlHcDZIdlVMOWxMM0lXcUs5aHJhdnZWY1F2YjBXYU1xOW03M1h2Y01RNWIxcFlmSzlaYS8vdlVwOUJyNW9JUTIrK3NNVHZ1MWtHcjR1QkNHK3JLRW52bE05THI0UTF6UyswbTQ3dm9ZRVFyNFptRWkrZVNsUHZwUzRWYjVXUlZ5K3JzOWl2b2xYYWI3VzNHKytnRjkydm5qZmZMNVVyb0crZ2V1RXZqZ25pTDV5WVl1K0pKcU92a1hSa2I3TkJwVytzenFZdnU1c203NTBuWjYrUGN5aHZrRDVwTDV6SktpK3owMnJ2a2wxcnI3YW1yRytlTDYwdmh2Z3Q3NjYvN3ErU3gyK3ZzYzR3YjRsVXNTK1cybkh2bUYreXI0d2tjMit2S0hRdmdDdzA3N3h1OWEraDhYWnZyck0zTDZCMGQrKzA5UGl2cW5UNWI3NjBPaSt2Y3ZydnVyRDdyNTR1ZkcrWUt6MHZwcWM5NzRjaXZxKzMzVDl2bTB1QUw4RG9RRy9MUklEdithQkJMOHM4QVcvK2x3SHYweklDTDhlTWdxL2JKb0x2eklCRGI5c1pnNi9GOG9Qdnkwc0ViK3NqQksva09zVHY5VklGYjkycEJhL2NmNFh2OEJXR2I5aXJScS9VUUljdjRwVkhiOEpweDYveS9ZZnY4eEVJYjhKa1NLL2ZOc2p2eVFrSmIvOWFpYS9BckFudnpEektMK0VOQ3EvK25NcnY0K3hMTDgvN1MyL0J5Y3Z2K05lTUwvUWxERy95c2d5djg3Nk03L2FLalcvNkZnMnYvZUVONzhDcnppL0I5YzV2d1A5T3IveElEeS96MEk5djVwaVByOVBnRCsvNlp0QXYyaTFRYi9HekVLL0FlSkR2eGYxUkw4REJrYS94QlJIdjFZaFNMKzJLMG0vNFROS3Y5UTVTNytOUFV5L0NUOU52MFErVHI4OU8wKy84RFZRdjFvdVViOTVKRksvU2hoVHY4b0pWTC8zK0ZTL3p1VlZ2MDNRVnI5d3VGZS9ONTVZdjV5QldiK2dZbHEvUGtGYnYzVWRYTDlCOTF5L29zNWR2NVNqWHI4VWRsKy9Ja1pndjdvVFliL1ozbUcvZjZkaXY2bHRZNzlVTVdTL2Z2Smt2eWF4WmI5SmJXYS81U1pudi9qZFo3K0FrbWkvZTBScHYranphYi9Eb0dxL0RFdHJ2OER5YTcvZWwyeS9aRHB0djFEYWJiK2dkMjYvVXhKdnYyYXFiNy9aUDNDL3FkSnd2OVZpY2I5YjhIRy9PbnR5djNFRGM3LzlpSE8vM2d0MHZ4R01kTCtXQ1hXL2E0UjF2NC84ZGI4QWNuYS92ZVIydjhaVWQ3OFl3bmUvc2l4NHY1T1VlTCs3K1hpL0tGeDV2OW03ZWIvTkdIcS9Bbk42djNuS2VyOHZIM3UvSkhGN3YxakFlNy9KREh5L2RsWjh2MStkZkwrQzRYeS80Q0o5djNkaGZiOUhuWDIvVDlaOXY0NE1mcjhFUUg2L3NIQit2NUtlZnIrcHlYNi85ZkYrdjNVWGY3OHBPbisvRUZwL3Z5dDNmNzk0a1grLytLaC92NnE5ZjcrUHozKy9wZDUvdiszcWY3OW05SCsvRWZ0L3YrMytmNy9xLzM4LzVmaC9QNmJtZno4dHlYOC9mS0IvUDVWc2Z6OTVMWDgvTE9OK1A3R05majhMTFg0L1A4RjlQMUpLZlQ5SXlIdy9LRHQ4UC9laWV6KzkvM28vZ0ZGNlAwaVllVDhlMUhnL0NRVjRQeE1yZHo5R1JuWS9yRloxUDA1Y2REODRWM00vZGtkeVB4TXRjVDhjQ0hBL250aHVQNldlYlQ5QVdtdy9mZ3RyUDJ1eWFUOFpUMmcvbHVGbVAvSnBaVDgrNkdNL2kxeGlQK3JHWUQ5dEoxOC9KbjVkUHlqTFd6K0ZEbG8vVTBoWVA2TjRWaitMbjFRL0lMMVNQM2JSVUQrajNFNC92ZDVNUDl2WFNqOFR5RWcvZks5R1B5Nk9SRDlCWkVJL3pqRkFQK3oyUFQrMHN6cy9RbWc1UDYwVU56OFF1VFEvaGxVeVB5bnFMejhWZHkwL1pmd3FQelY2S0QraDhDVS94bDhqUDhESElEK3NLQjQvcVlJYlA5VFZHRDlLSWhZL0ttZ1RQNU9uRUQrazRBMC9leE1MUHpsQUNELzlaZ1UvNTRjQ1B5MUcvejViY2ZrK2w1SHpQaVNuN1Q1RnN1YytQTFBoUGt5cTJ6NjZsOVUreVh2UFByNVd5VDdmS01NK2NQSzhQcmV6dGo3N2JMQStnUjZxUHBMSW96NXphNTArYkFlWFBzV2NrRDdISzRvK3ViU0RQc2R2ZWo0aGEyMCtFVnhnUGlsRFV6NzlJRVkrSVBZNFBpYkRLejZraUI0K0xVY1JQbGYvQXo1dVkrMDl3cjNTUGRvT3VEM2VWNTA5KzVtQ1BieXNUejFsSEJvOW1RckpQQ3FuT3p6QmVOYTZMVVJ4dkZmWDQ3eE1nU2U5bEE5ZHZSVktpYjFhQnFTOWJidSt2U0pvMmIxT0MvUzk0MUVIdmkrWUZMNzMxeUcrcFJBdnZxWkJQTDVrYWttK1RZcFd2czJnWTc1UXJYQytSYTk5dmcxVGhiNmV5SXUrRFRpU3ZoS2htTDVtQTUrK3YxNmx2dGl5cTc1cC83RytLMFM0dnRpQXZyNHF0Y1MrMitES3ZxVUQwYjVGSGRlK2RTM2R2dkV6NDc1Mk1PbSt3Q0x2dm8wSzliNmI1L3ErMDF3QXZ6aEFBNy9iSFFhL20vVUl2MXJIQzcvM2tnNi9WRmdSdjFBWEZML056eGEvcklFWnY5QXNITDhhMFI2L2JXNGh2NnNFSkwrM2t5YS9kQnNwdjhlYks3K1RGQzYvdTRVd3Z5YnZNciszVURXL1ZhbzN2K1A3T2I5S1JUeS9ib1krdnplL1FMK0w3MEsvVXhkRnYzVTJSNy9hVEVtL2ExcEx2eEJmVGIreldrKy9QazFSdjVvMlU3K3pGbFcvY3UxV3Y4VzZXTCtWZmxxLzBEaGN2MkxwWGI4NGtGKy9RQzFodjJmQVlyK2NTV1MvenNobHYrczlaNy9qcUdpL3B3bHF2eWRnYTc5VXJHeS9IKzV0djNvbGI3OVlVbkMvcTNSeHYyZU1jcjkvbVhPLzU1dDB2NVdUZGI5K2dIYS9sbUozdjlRNWVMOHZCbm0vbnNkNXZ4ZCtlcitVS1h1L0RjcDd2M3BmZkwvVjZYeS9HR2w5dno3ZGZiOUFSbjYvSEtSK3Y4ejJmcjlOUG4rL25IcC92N2FyZjcrWjBYKy9RK3gvdjdUN2Y3K20vMzgvbE9OL1A1eWFmei9NSkg4L09JSitQLzJ5ZlQ4L3Qzdy9Lbzk3UC9NNmVqL1V1bmcvRVE5M1AvWTNkVC9WTlhNL0NBbHhQL0d4YmovNU1Hdy9rSVpwUHkrelpqOVR0Mk0vaEpOZ1AwNUlYVDlGMWxrL0F6NVdQeXVBVWo5bG5VNC9YcFpLUDh4clJqOXFIa0kvK2E0OVAwQWVPVDhOYlRRL01wd3ZQNGVzS2ovcm5pVS9QM1FnUDIwdEd6OWh5eFUvRFU4UVAyaTVDajlyQ3dVL0xveitQdDNVOGo3eDh1WStmK2phUHFhM3pqNklZc0krVHV1MVBpcFVxVDVSbjV3Ky9jNlBQbTNsZ2o3T3lXcytZcDlSUGpCUU56N1Q0QncrOFZVQ1BtSm96ejE4QUpvOUpQdElQUnVrdXp6emQxYTdaRDN4dkx2QVk3MW5YYWU5RkwzY3ZRUDdDTDV6ZnlPK05PYzl2cVF0V0w0bVRuSytFaUtHdm9rRms3NDB6NSsrMVh5c3ZqTU11YjRhZThXK1c4ZlJ2czN1M2I1UTcrbSt4OGIxdnBDNUFMOG1lUWEvSkNFTXY0MndFYjltSmhlL3VvRWN2NWpCSWI4VjVTYS9TdXNydjFiVE1MOWJuRFcvZzBVNnYvM05Qci84TkVPL3ZIbEh2MzJiUzcrRW1VKy9IM05UdjZFblY3OWp0bHEveGg1ZXZ6QmdZYjhQZW1TLzJHdG52d2MxYXI4ZjFXeS9xVXR2dnplWWNiOWl1bk8veWJGMXZ4WitkNy8ySG5tL0laUjZ2MVhkZTc5WitueS8rdXA5dnc2dmZyOTBSbisvRDdGL3Y4N3VmNy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9BQUFBQUFBQUFBQXBBQ2tBS1FCU0FGSUFld0NrQU1nQTNnQkIydjBBQzVnQktRQXBBQ2tBS1FCN0FIc0Fld0NrQUtRQThBQUtBUnNCSndFcEFDa0FLUUFwQUNrQUtRQXBBQ2tBZXdCN0FIc0Fld0R3QVBBQThBQUtBUW9CTVFFK0FVZ0JVQUY3QUhzQWV3QjdBSHNBZXdCN0FIc0E4QUR3QVBBQThBQXhBVEVCTVFFK0FUNEJWd0ZmQVdZQmJBSHdBUEFBOEFEd0FQQUE4QUR3QVBBQU1RRXhBVEVCTVFGWEFWY0JWd0ZmQVY4QmNnRjRBWDRCZ3dFQVFZRC9BQXU0QkNnSEJ3Y0hCd2NIQndjSEJ3Y0hCd2NIQndjSEJ3Y0hCd2NIQndjSEJ3Y0hCd2NIQndjSEJ3Y0hLQThYSEI4aUpDWW5LU29yTEMwdUx5OHhNak0wTlRZM056azZPenc5UGo4L1FVSkRSRVZHUjBjb0ZDRXBNRFU1UFVCQ1JVZEpTMHhPVUZKVlYxbGJYRjVnWW1WbmFXdHNibkJ5ZFhkNWUzeCtnQ2dYSnpNOFEwbFBVMWRiWG1Ga1ptbHJiM04yZVh4K2dZT0hpNDZSbEphWm01K2pwcW1zcnJHekl4d3hRVTVaWTJ0eWVINkVpSTJSbFptZnBhdXd0TG05d01mTjA5amM0ZVhvNy9YN0ZTRTZUMkZ3ZlltVW5hYXV0cjNEeWMvWjQrdnoreEVqUDFacWU0dVlwYkc3eGM3VzN1YnQraGtmTjB0YmFYV0FpcEthb2FpdXRMbSt5TkRYM3VYcjhQWC9FQ1JCV1c2QWtKK3R1Y1RQMmVMcTh2b0xLVXBuZ0plc3Y5SGg4ZjhKSzA5dWlxTzZ6K1AyRENkSFkzdVFwTGJHMXVUeC9Ra3NVWEdPcU1EVzYvOEhNVnAvb0wvYzl3WXpYNGFxeStvSEwxZDdtN2pVN1FZMFlZbXUwUEFGT1dxWHdPY0ZPMitleXZNRk4yZVR1K0FGUEhHaHp2Z0VRWHF2NEFSRGY3YnFBQUFBQUFBQUFBRGc0T0RnNE9EZzRLQ2dvS0M1dWJteXNxaUdQU1hnNE9EZzRPRGc0UER3OFBEUHo4L0d4cmVRUWlpZ29LQ2dvS0Nnb0xtNXVibkJ3Y0czdDZ5S1FDYnc4UER3OFBEdzhNL1B6OC9Nek16QndiU1BRaWk1dWJtNXVibTV1Y0hCd2NIQndjRzN0NnlLUVNmUHo4L1B6OC9Qejh6TXpNekp5Y204dkxDTlFpakJ3Y0hCd2NIQndjSEJ3Y0hDd3NLNHVLMkxRU2ZNek16TXpNek16TW5KeWNuR3hzYTd1NitNUWlnQVFjS0RBUXU1S1dBQXdBQWdBWUFCSUFDQUFPQUFRQUdnQVVBQW9BQUFBV0FCd0FFSUFHZ0F5QUFvQVlnQktBQ0lBT2dBU0FHb0FVZ0FxQUFJQVdnQnlBRVFBSEFBMEFBd0FaQUJNQUNRQVBBQVVBR3dBVkFBc0FBUUFYQUIwQUVZQUhnQTJBQTRBWmdCT0FDWUFQZ0FXQUc0QVZnQXVBQVlBWGdCMkFFRUFHUUF4QUFrQVlRQkpBQ0VBT1FBUkFHa0FVUUFwQUFFQVdRQnhBRU1BR3dBekFBc0FZd0JMQUNNQU93QVRBR3NBVXdBckFBTUFXd0J6QUVVQUhRQTFBQTBBWlFCTkFDVUFQUUFWQUcwQVZRQXRBQVVBWFFCMUFFY0FId0EzQUE4QVp3QlBBQ2NBUHdBWEFHOEFWd0F2QUFjQVh3QjNBRUJBR0VBd1FBaEFZRUJJUUNCQU9FQVFRR2hBVUVBb1FBQkFXRUJ3UUVKQUdrQXlRQXBBWWtCS1FDSkFPa0FTUUdwQVVrQXFRQUpBV2tCeVFFUkFIRUEwUUF4QVpFQk1RQ1JBUEVBVVFHeEFWRUFzUUFSQVhFQjBRRVpBSGtBMlFBNUFaa0JPUUNaQVBrQVdRRzVBVmtBdVFBWkFYa0IyUUVGQUdVQXhRQWxBWVVCSlFDRkFPVUFSUUdsQVVVQXBRQUZBV1VCeFFFTkFHMEF6UUF0QVkwQkxRQ05BTzBBVFFHdEFVMEFyUUFOQVcwQnpRRVZBSFVBMVFBMUFaVUJOUUNWQVBVQVZRRzFBVlVBdFFBVkFYVUIxUUVkQUgwQTNRQTlBWjBCUFFDZEFQMEFYUUc5QVYwQXZRQWRBWDBCM1FFQ0FHSUF3Z0FpQVlJQklnQ0NBT0lBUWdHaUFVSUFvZ0FDQVdJQndnRUtBR29BeWdBcUFZb0JLZ0NLQU9vQVNnR3FBVW9BcWdBS0FXb0J5Z0VTQUhJQTBnQXlBWklCTWdDU0FQSUFVZ0d5QVZJQXNnQVNBWElCMGdFYUFIb0EyZ0E2QVpvQk9nQ2FBUG9BV2dHNkFWb0F1Z0FhQVhvQjJnRUdBR1lBeGdBbUFZWUJKZ0NHQU9ZQVJnR21BVVlBcGdBR0FXWUJ4Z0VPQUc0QXpnQXVBWTRCTGdDT0FPNEFUZ0d1QVU0QXJnQU9BVzRCemdFV0FIWUExZ0EyQVpZQk5nQ1dBUFlBVmdHMkFWWUF0Z0FXQVhZQjFnRWVBSDRBM2dBK0FaNEJQZ0NlQVA0QVhnRytBVjRBdmdBZUFYNEIzZ0VEQUdNQXd3QWpBWU1CSXdDREFPTUFRd0dqQVVNQW93QURBV01Cd3dFTEFHc0F5d0FyQVlzQkt3Q0xBT3NBU3dHckFVc0Fxd0FMQVdzQnl3RVRBSE1BMHdBekFaTUJNd0NUQVBNQVV3R3pBVk1Bc3dBVEFYTUIwd0ViQUhzQTJ3QTdBWnNCT3dDYkFQc0FXd0c3QVZzQXV3QWJBWHNCMndFSEFHY0F4d0FuQVljQkp3Q0hBT2NBUndHbkFVY0Fwd0FIQVdjQnh3RVBBRzhBendBdkFZOEJMd0NQQU84QVR3R3ZBVThBcndBUEFXOEJ6d0VYQUhjQTF3QTNBWmNCTndDWEFQY0FWd0czQVZjQXR3QVhBWGNCMXdFZkFIOEEzd0EvQVo4QlB3Q2ZBUDhBWHdHL0FWOEF2d0FmQVg4QjN3RUFBSUEvQUFBQWdHUDZmeisvZFZhOGkrbC9Qd3B4MXJ4NXpYOC81ODRndlMrbWZ6ODZYbGE5cjNOL1B4UHloYjM1Tlg4L0txK2d2Ukx0Zmo4elpidTkvWmgrUHdRVDFyMjhPWDQvYzdmd3ZWWFBmVCtvcUFXK3kxbDlQN3Z2RXI0bDJYdy9YREFndm1kTmZELzFhUzIrbUxaN1AvT2JPcjYrRkhzL3dzVkh2dUpuZWovTjVsUytDYkI1UDRMK1liNDg3WGcvVFF4dnZvUWZlRCtjRDN5KzZrWjNQKzZEaEw1M1kzWS9QdnFLdmpaMWRUOTFhcEcrTUh4MFAwelVsNzV4ZUhNL2VqZWV2Z05xY2orM2s2Uys5RkJ4UDd6b3FyNVBMWEEvUVRheHZpSC9iajhCZkxlK2RzWnRQN1M1dmI1ZWcydy9GZS9EdnVjMWF6L2VHOHErSHQ1cFA4ay8wTDRTZkdnL2tscld2dFFQWnovemE5eStkSmxsUDZwejRyNEJHV1EvY1hIb3ZvMk9ZajhIWmU2K0tQcGdQeWRPOUw3bVcxOC9rQ3o2dnRlelhUOEFBQUMvRHdKY1B4dmtBcitnUmxvL2Q4SUZ2NTZCV0QvMm1naS9IYk5XUDNkdEM3OHgyMVEvMmprT3YrLzVVajhBQUJHL2JBOVJQOHEvRTcrOUcwOC9HSGtXdi9nZVRUL05LeG0vTkJsTFA4clhHNytJQ2trLzhYd2V2d3J6Umo4a0d5Ry8wZEpFUDBheUk3LzNxVUkvT2tJbXY1TjRRRC9qeWlpL3ZUNCtQeVZNSzcrUC9Ecy80OFV0dnlLeU9UOEJPREMva0Y4M1AyV2lNci96QkRVLzh3UTF2MldpTWorUVh6ZS9BVGd3UHlLeU9iL2p4UzAvai93N3Z5Vk1Leis5UGo2LzQ4b29QNU40UUw4NlFpWS85NmxDdjBheUl6L1Iwa1MvSkJzaFB3cnpSci94ZkI0L2lBcEp2OHJYR3o4MEdVdS96U3NaUC9nZVRiOFllUlkvdlJ0UHY4cS9FejlzRDFHL0FBQVJQKy81VXIvYU9RNC9NZHRVdjNkdEN6OGRzMWEvOXBvSVA1NkJXTDkzd2dVL29FWmF2eHZrQWo4UEFseS9BQUFBUDllelhiK1FMUG8rNWx0ZnZ5ZE85RDRvK21DL0IyWHVQbzJPWXI5eGNlZytBUmxrdjZwejRqNTBtV1cvODJ2Y1B0UVBaNytTV3RZK0VueG92OGsvMEQ0ZTNtbS8zaHZLUHVjMWE3OFY3OE0rWG9Oc3Y3UzV2VDUyeG0yL0FYeTNQaUgvYnI5Qk5yRStUeTF3djd6b3FqNzBVSEcvdDVPa1BnTnFjcjk2TjU0K2NYaHp2MHpVbHo0d2ZIUy9kV3FSUGpaMWRiOCsrb28rZDJOMnYrNkRoRDdxUm5lL25BOThQb1FmZUw5TkRHOCtQTzE0djRMK1lUNEpzSG0vemVaVVB1Sm5lci9DeFVjK3ZoUjd2L09iT2o2WXRudS85V2t0UG1kTmZMOWNNQ0ErSmRsOHY3dnZFajdMV1gyL3FLZ0ZQbFhQZmI5enQvQTl2RGwrdndRVDFqMzltSDYvTTJXN1BSTHRmcjhxcjZBOStUVi92eFB5aFQydmMzKy9PbDVXUFMrbWY3L256aUE5ZWMxL3Z3cHgxanlMNlgrL3YzVldQR1A2Zjc4QU1JMGtBQUNBdjc5MVZyeGorbisvQ25IV3ZJdnBmNy9uemlDOWVjMS92enBlVnIwdnBuKy9FL0tGdmE5emY3OHFyNkM5K1RWL3Z6Tmx1NzBTN1g2L0JCUFd2ZjJZZnI5enQvQzl2RGwrdjZpb0JiNVZ6MzIvdSs4U3ZzdFpmYjljTUNDK0pkbDh2L1ZwTGI1blRYeS84NXM2dnBpMmU3L0N4VWUrdmhSN3Y4M21WTDdpWjNxL2d2NWh2Z213ZWI5TkRHKytQTzE0djV3UGZMNkVIM2kvN29PRXZ1cEdkNzgrK29xK2QyTjJ2M1Zxa2I0MmRYVy9UTlNYdmpCOGRMOTZONTYrY1hoenY3ZVRwTDREYW5LL3ZPaXF2dlJRY2I5Qk5yRytUeTF3dndGOHQ3NGgvMjYvdExtOXZuYkdiYjhWNzhPK1hvTnN2OTRieXI3bk5XdS95VC9Rdmg3ZWFiK1NXdGErRW54b3YvTnIzTDdVRDJlL3FuUGl2blNaWmI5eGNlaStBUmxrdndkbDdyNk5qbUsvSjA3MHZpajZZTCtRTFBxKzVsdGZ2d0FBQUwvWHMxMi9HK1FDdnc4Q1hMOTN3Z1cvb0VaYXYvYWFDTCtlZ1ZpL2QyMEx2eDJ6VnIvYU9RNi9NZHRVdndBQUViL3YrVksveXI4VHYyd1BVYjhZZVJhL3ZSdFB2ODByR2IvNEhrMi95dGNidnpRWlM3L3hmQjYvaUFwSnZ5UWJJYjhLODBhL1JySWp2OUhTUkw4NlFpYS85NmxDditQS0tMK1RlRUMvSlV3cnY3MCtQci9qeFMyL2ovdzd2d0U0TUw4aXNqbS9aYUl5djVCZk43L3pCRFcvOHdRMXY1QmZONzlsb2pLL0lySTV2d0U0TUwrUC9EdS80OFV0djcwK1ByOGxUQ3UvazNoQXYrUEtLTC8zcVVLL09rSW12OUhTUkw5R3NpTy9Ddk5HdnlRYkliK0lDa20vOFh3ZXZ6UVpTNy9LMXh1LytCNU52ODByR2IrOUcwKy9HSGtXdjJ3UFViL0t2eE8vNy9sU3Z3QUFFYjh4MjFTLzJqa092eDJ6VnI5M2JRdS9ub0ZZdi9hYUNMK2dSbHEvZDhJRnZ3OENYTDhiNUFLLzE3TmR2d0FBQUwvbVcxKy9rQ3o2dmlqNllMOG5UdlMralk1aXZ3ZGw3cjRCR1dTL2NYSG92blNaWmIrcWMrSysxQTludi9OcjNMNFNmR2kva2xyV3ZoN2VhYi9KUDlDKzV6VnJ2OTRieXI1ZWcyeS9GZS9Edm5iR2JiKzB1YjIrSWY5dXZ3Rjh0NzVQTFhDL1FUYXh2dlJRY2IrODZLcStBMnB5djdlVHBMNXhlSE8vZWplZXZqQjhkTDlNMUplK05uVjF2M1Zxa2I1M1kzYS9QdnFLdnVwR2Q3L3VnNFMraEI5NHY1d1BmTDQ4N1hpL1RReHZ2Z213ZWIrQy9tRys0bWQ2djgzbVZMNitGSHUvd3NWSHZwaTJlNy96bXpxK1owMTh2L1ZwTGI0bDJYeS9YREFndnN0WmZiKzc3eEsrVmM5OXY2aW9CYjY4T1g2L2M3Znd2ZjJZZnI4RUU5YTlFdTErdnpObHU3MzVOWCsvS3ErZ3ZhOXpmNzhUOG9XOUw2Wi92enBlVnIxNXpYKy81ODRndll2cGY3OEtjZGE4WS9wL3Y3OTFWcndBQUlDL0FEQU5wV1A2ZjcrL2RWWThpK2wvdndweDFqeDV6WCsvNTg0Z1BTK21mNzg2WGxZOXIzTi92eFB5aFQzNU5YKy9LcStnUFJMdGZyOHpaYnM5L1poK3Z3UVQxajI4T1g2L2M3ZndQVlhQZmIrb3FBVSt5MWw5djd2dkVqNGwyWHkvWERBZ1BtZE5mTC8xYVMwK21MWjd2L09iT2o2K0ZIdS93c1ZIUHVKbmVyL041bFErQ2JCNXY0TCtZVDQ4N1hpL1RReHZQb1FmZUwrY0Qzdys2a1ozdis2RGhENTNZM2EvUHZxS1BqWjFkYjkxYXBFK01IeDB2MHpVbHo1eGVITy9lamVlUGdOcWNyKzNrNlErOUZCeHY3em9xajVQTFhDL1FUYXhQaUgvYnI4QmZMYytkc1p0djdTNXZUNWVnMnkvRmUvRFB1YzFhNy9lRzhvK0h0NXB2OGsvMEQ0U2ZHaS9rbHJXUHRRUFo3L3phOXcrZEpsbHY2cHo0ajRCR1dTL2NYSG9QbzJPWXI4SFplNCtLUHBndnlkTzlEN21XMSsva0N6NlB0ZXpYYjhBQUFBL0R3SmN2eHZrQWorZ1JscS9kOElGUDU2QldMLzJtZ2cvSGJOV3YzZHRDejh4MjFTLzJqa09QKy81VXI4QUFCRS9iQTlSdjhxL0V6KzlHMCsvR0hrV1AvZ2VUYi9OS3hrL05CbEx2OHJYR3orSUNrbS84WHdlUHdyelJyOGtHeUUvMGRKRXYwYXlJei8zcVVLL09rSW1QNU40UUwvanlpZy92VDQrdnlWTUt6K1AvRHUvNDhVdFB5S3lPYjhCT0RBL2tGODN2MldpTWovekJEVy84d1ExUDJXaU1yK1FYemMvQVRnd3Z5S3lPVC9qeFMyL2ovdzdQeVZNSzcrOVBqNC80OG9vdjVONFFEODZRaWEvOTZsQ1AwYXlJNy9SMGtRL0pCc2h2d3J6UmoveGZCNi9pQXBKUDhyWEc3ODBHVXMvelNzWnYvZ2VUVDhZZVJhL3ZSdFBQOHEvRTc5c0QxRS9BQUFSdisvNVVqL2FPUTYvTWR0VVAzZHRDNzhkczFZLzlwb0l2NTZCV0Q5M3dnVy9vRVphUHh2a0FyOFBBbHcvQUFBQXY5ZXpYVCtRTFBxKzVsdGZQeWRPOUw0byttQS9CMlh1dm8yT1lqOXhjZWkrQVJsa1A2cHo0cjUwbVdVLzgydmN2dFFQWnorU1d0YStFbnhvUDhrLzBMNGUzbWsvM2h2S3Z1YzFhejhWNzhPK1hvTnNQN1M1dmI1MnhtMC9BWHkzdmlIL2JqOUJOckcrVHkxd1A3em9xcjcwVUhFL3Q1T2t2Z05xY2o5Nk41NitjWGh6UDB6VWw3NHdmSFEvZFdxUnZqWjFkVDgrK29xK2QyTjJQKzZEaEw3cVJuYy9uQTk4dm9RZmVEOU5ERysrUE8xNFA0TCtZYjRKc0hrL3plWlV2dUpuZWovQ3hVZSt2aFI3UC9PYk9yNll0bnMvOVdrdHZtZE5mRDljTUNDK0pkbDhQN3Z2RXI3TFdYMC9xS2dGdmxYUGZUOXp0L0M5dkRsK1B3UVQxcjM5bUg0L00yVzd2Ukx0Zmo4cXI2QzkrVFYvUHhQeWhiMnZjMzgvT2w1V3ZTK21mei9uemlDOWVjMS9Qd3B4MXJ5TDZYOC92M1ZXdkdQNmZ6OEF5Rk9sQUFDQVA3OTFWanhqK244L0NuSFdQSXZwZnovbnppQTllYzEvUHpwZVZqMHZwbjgvRS9LRlBhOXpmejhxcjZBOStUVi9Qek5sdXowUzdYNC9CQlBXUGYyWWZqOXp0L0E5dkRsK1A2aW9CVDVWejMwL3UrOFNQc3RaZlQ5Y01DQStKZGw4UC9WcExUNW5UWHcvODVzNlBwaTJlei9DeFVjK3ZoUjdQODNtVkQ3aVozby9ndjVoUGdtd2VUOU5ERzgrUE8xNFA1d1BmRDZFSDNnLzdvT0VQdXBHZHo4KytvbytkMk4yUDNWcWtUNDJkWFUvVE5TWFBqQjhkRDk2TjU0K2NYaHpQN2VUcEQ0RGFuSS92T2lxUHZSUWNUOUJOckUrVHkxd1B3Rjh0ejRoLzI0L3RMbTlQbmJHYlQ4Vjc4TStYb05zUDk0YnlqN25OV3MveVQvUVBoN2VhVCtTV3RZK0VueG9QL05yM0Q3VUQyYy9xblBpUG5TWlpUOXhjZWcrQVJsa1B3ZGw3ajZOam1JL0owNzBQaWo2WUQrUUxQbys1bHRmUHdBQUFEL1hzMTAvRytRQ1B3OENYRDkzd2dVL29FWmFQL2FhQ0QrZWdWZy9kMjBMUHgyelZqL2FPUTQvTWR0VVB3QUFFVC92K1ZJL3lyOFRQMndQVVQ4WWVSWS92UnRQUDgwckdULzRIazAveXRjYlB6UVpTei94ZkI0L2lBcEpQeVFiSVQ4SzgwWS9ScklqUDlIU1JEODZRaVkvOTZsQ1ArUEtLRCtUZUVBL0pVd3JQNzArUGovanhTMC9qL3c3UHdFNE1EOGlzamsvWmFJeVA1QmZOei96QkRVLzh3UTFQNUJmTno5bG9qSS9Jckk1UHdFNE1EK1AvRHMvNDhVdFA3MCtQajhsVENzL2szaEFQK1BLS0QvM3FVSS9Pa0ltUDlIU1JEOUdzaU0vQ3ZOR1B5UWJJVCtJQ2trLzhYd2VQelFaU3ovSzF4cy8rQjVOUDgwckdUKzlHMDgvR0hrV1Ayd1BVVC9LdnhNLzcvbFNQd0FBRVQ4eDIxUS8yamtPUHgyelZqOTNiUXMvbm9GWVAvYWFDRCtnUmxvL2Q4SUZQdzhDWEQ4YjVBSS8xN05kUHdBQUFEL21XMTgva0N6NlBpajZZRDhuVHZRK2pZNWlQd2RsN2o0QkdXUS9jWEhvUG5TWlpUK3FjK0krMUE5blAvTnIzRDRTZkdnL2tscldQaDdlYVQvSlA5QSs1elZyUDk0YnlqNWVnMncvRmUvRFBuYkdiVCswdWIwK0lmOXVQd0Y4dHo1UExYQS9RVGF4UHZSUWNUKzg2S28rQTJweVA3ZVRwRDV4ZUhNL2VqZWVQakI4ZEQ5TTFKYytOblYxUDNWcWtUNTNZM1kvUHZxS1B1cEdkei91ZzRRK2hCOTRQNXdQZkQ0ODdYZy9UUXh2UGdtd2VUK0MvbUUrNG1kNlA4M21WRDYrRkhzL3dzVkhQcGkyZXovem16bytaMDE4UC9WcExUNGwyWHcvWERBZ1BzdFpmVCs3N3hJK1ZjOTlQNmlvQlQ2OE9YNC9jN2Z3UGYyWWZqOEVFOVk5RXUxK1B6Tmx1ejM1Tlg4L0txK2dQYTl6Zno4VDhvVTlMNlovUHpwZVZqMTV6WDgvNTg0Z1BZdnBmejhLY2RZOFkvcC9QNzkxVmp3QUFEQUFZQUNRQU1BQUVBQkFBSEFBb0FEUUFDQUFVQUNBQUxBQTRBQUVBRFFBWkFDVUFNUUFGQUJFQUhRQXBBRFVBQ1FBVkFDRUFMUUE1QUFJQURnQWFBQ1lBTWdBR0FCSUFIZ0FxQURZQUNnQVdBQ0lBTGdBNkFBTUFEd0FiQUNjQU13QUhBQk1BSHdBckFEY0FDd0FYQUNNQUx3QTdBQUJBREVBWVFDUkFNRUFFUUJCQUhFQW9RRFJBQ0VBVVFDQkFMRUE0UUFGQURVQVpRQ1ZBTVVBRlFCRkFIVUFwUURWQUNVQVZRQ0ZBTFVBNVFBSkFEa0FhUUNaQU1rQUdRQkpBSGtBcVFEWkFDa0FXUUNKQUxrQTZRQU5BRDBBYlFDZEFNMEFIUUJOQUgwQXJRRGRBQzBBWFFDTkFMMEE3UUFDQURJQVlnQ1NBTUlBRWdCQ0FISUFvZ0RTQUNJQVVnQ0NBTElBNGdBR0FEWUFaZ0NXQU1ZQUZnQkdBSFlBcGdEV0FDWUFWZ0NHQUxZQTVnQUtBRG9BYWdDYUFNb0FHZ0JLQUhvQXFnRGFBQ29BV2dDS0FMb0E2Z0FPQUQ0QWJnQ2VBTTRBSGdCT0FINEFyZ0RlQUM0QVhnQ09BTDRBN2dBREFETUFZd0NUQU1NQUV3QkRBSE1Bb3dEVEFDTUFVd0NEQUxNQTR3QUhBRGNBWndDWEFNY0FGd0JIQUhjQXB3RFhBQ2NBVndDSEFMY0E1d0FMQURzQWF3Q2JBTXNBR3dCTEFIc0Fxd0RiQUNzQVd3Q0xBTHNBNndBUEFEOEFid0NmQU04QUh3QlBBSDhBcndEZkFDOEFYd0NQQUw4QTd3RHdBQUFBaVlpSU93RUFBQUFGQURBQUF3QVFBQVFBQkFBRUFBRUFRWXl0QVFzR2dGUUFBSUJGQUVHaXJRRUxpUUlZQURBQVNBQmdBQWdBSUFBNEFGQUFhQUFRQUNnQVFBQllBSEFBQkFBY0FEUUFUQUJrQUF3QUpBQThBRlFBYkFBVUFDd0FSQUJjQUhRQUFRQVpBREVBU1FCaEFBa0FJUUE1QUZFQWFRQVJBQ2tBUVFCWkFIRUFCUUFkQURVQVRRQmxBQTBBSlFBOUFGVUFiUUFWQUMwQVJRQmRBSFVBQWdBYUFESUFTZ0JpQUFvQUlnQTZBRklBYWdBU0FDb0FRZ0JhQUhJQUJnQWVBRFlBVGdCbUFBNEFKZ0ErQUZZQWJnQVdBQzRBUmdCZUFIWUFBd0FiQURNQVN3QmpBQXNBSXdBN0FGTUFhd0FUQUNzQVF3QmJBSE1BQndBZkFEY0FUd0JuQUE4QUp3QS9BRmNBYndBWEFDOEFSd0JmQUhjQWVBQUFBSWlJQ0R3Q0FBQUFCUUFZQUFNQUNBQUNBQVFBQkFBQkFFRzhyd0VMQnFCV0FBQ0FSUUJCMHE4QkM0MEJEQUFZQUNRQU1BQUVBQkFBSEFBb0FEUUFDQUFVQUNBQUxBQTRBQUVBRFFBWkFDVUFNUUFGQUJFQUhRQXBBRFVBQ1FBVkFDRUFMUUE1QUFJQURnQWFBQ1lBTWdBR0FCSUFIZ0FxQURZQUNnQVdBQ0lBTGdBNkFBTUFEd0FiQUNjQU13QUhBQk1BSHdBckFEY0FDd0FYQUNNQUx3QTdBRHdBQUFDSmlJZzhBd0FBQUFVQURBQURBQVFBQkFBQkFFSDBzQUVMVGRCWEFBQ0FSUUFBQUFBQUFNQllBQUNBV3dBQVBGNEFBUFJnQUFDb1l3QUFXR1lBQUFScEFBQnNhZ0FBS0dzQUFKeHJBQURvYXdBQUlHd0FBRUJzQUFCWWJBQUFaR3dBQUFBQUFBQUJBRUdFdHdFTG9DTUJBQUFBQVFBQUFBRUFBQUFCQUFBQUFRQUFBQUVBQUFBQkFBQUFBUUFBQUFFQUFBQUJBQUFBQVFBQUFBRUFBQUFCQUFBQUFRQUFBQUVBQUFBQkFBQUFBUUFBQUFFQUFBQUJBQUFBQVFBQUFBRUFBQUFCQUFBQUFRQUFBQUVBQUFBQkFBQUFBUUFBQUFFQUFBQUJBQUFBQVFBQUFBRUFBQUFCQUFBQUFRQUFBQUVBQUFBQkFBQUFBUUFBQUFFQUFBQUJBQUFBQVFBQUFBRUFBQUFCQUFBQUFRQUFBQUVBQUFBQkFBQUFBUUFBQUFFQUFBQUJBQUFBQVFBQUFBRUFBQUFCQUFBQUFRQUFBQUVBQUFBQkFBQUFBUUFBQUFFQUFBQUJBQUFBQVFBQUFBRUFBQUFCQUFBQUFRQUFBQUVBQUFBQkFBQUFBUUFBQUFFQUFBQUJBQUFBQVFBQUFBRUFBQUFCQUFBQUFRQUFBQUVBQUFBQkFBQUFBUUFBQUFFQUFBQUJBQUFBQVFBQUFBRUFBQUFCQUFBQUFRQUFBQUVBQUFBQkFBQUFBUUFBQUFFQUFBQUJBQUFBQVFBQUFBRUFBQUFCQUFBQUFRQUFBQUVBQUFBQkFBQUFBUUFBQUFFQUFBQUJBQUFBQVFBQUFBRUFBQUFCQUFBQUFRQUFBQUVBQUFBQkFBQUFBUUFBQUFFQUFBQUJBQUFBQVFBQUFBRUFBQUFCQUFBQUFRQUFBQUVBQUFBQkFBQUFBUUFBQUFFQUFBQUJBQUFBQVFBQUFBRUFBQUFCQUFBQUFRQUFBQUVBQUFBQkFBQUFBUUFBQUFFQUFBQUJBQUFBQVFBQUFBRUFBQUFCQUFBQUFRQUFBQUVBQUFBQkFBQUFBUUFBQUFFQUFBQUJBQUFBQVFBQUFBRUFBQUFCQUFBQUFRQUFBQUVBQUFBQkFBQUFBUUFBQUFFQUFBQUJBQUFBQVFBQUFBRUFBQUFCQUFBQUFRQUFBQUVBQUFBQkFBQUFBUUFBQUFFQUFBQUJBQUFBQVFBQUFBRUFBQUFCQUFBQUFRQUFBQUVBQUFBQkFBQUFBUUFBQUFFQUFBQUJBQUFBQVFBQUFBRUFBQUFCQUFBQUFRQUFBQUVBQUFBQkFBQUFBUUFBQUFFQUFBQUJBQUFBQVFBQUFBRUFBQUFCQUFBQUFRQUFBQUVBQUFBQkFBQUFBUUFBQUFFQUFBQUJBQUFBQVFBQUFBRUFBQUFCQUFBQUFRQUFBQU1BQUFBRkFBQUFCd0FBQUFrQUFBQUxBQUFBRFFBQUFBOEFBQUFSQUFBQUV3QUFBQlVBQUFBWEFBQUFHUUFBQUJzQUFBQWRBQUFBSHdBQUFDRUFBQUFqQUFBQUpRQUFBQ2NBQUFBcEFBQUFLd0FBQUMwQUFBQXZBQUFBTVFBQUFETUFBQUExQUFBQU53QUFBRGtBQUFBN0FBQUFQUUFBQUQ4QUFBQkJBQUFBUXdBQUFFVUFBQUJIQUFBQVNRQUFBRXNBQUFCTkFBQUFUd0FBQUZFQUFBQlRBQUFBVlFBQUFGY0FBQUJaQUFBQVd3QUFBRjBBQUFCZkFBQUFZUUFBQUdNQUFBQmxBQUFBWndBQUFHa0FBQUJyQUFBQWJRQUFBRzhBQUFCeEFBQUFjd0FBQUhVQUFBQjNBQUFBZVFBQUFIc0FBQUI5QUFBQWZ3QUFBSUVBQUFDREFBQUFoUUFBQUljQUFBQ0pBQUFBaXdBQUFJMEFBQUNQQUFBQWtRQUFBSk1BQUFDVkFBQUFsd0FBQUprQUFBQ2JBQUFBblFBQUFKOEFBQUNoQUFBQW93QUFBS1VBQUFDbkFBQUFxUUFBQUtzQUFBQ3RBQUFBcndBQUFMRUFBQUN6QUFBQXRRQUFBTGNBQUFDNUFBQUF1d0FBQUwwQUFBQy9BQUFBd1FBQUFNTUFBQURGQUFBQXh3QUFBTWtBQUFETEFBQUF6UUFBQU04QUFBRFJBQUFBMHdBQUFOVUFBQURYQUFBQTJRQUFBTnNBQUFEZEFBQUEzd0FBQU9FQUFBRGpBQUFBNVFBQUFPY0FBQURwQUFBQTZ3QUFBTzBBQUFEdkFBQUE4UUFBQVBNQUFBRDFBQUFBOXdBQUFQa0FBQUQ3QUFBQS9RQUFBUDhBQUFBQkFRQUFBd0VBQUFVQkFBQUhBUUFBQ1FFQUFBc0JBQUFOQVFBQUR3RUFBQkVCQUFBVEFRQUFGUUVBQUJjQkFBQVpBUUFBR3dFQUFCMEJBQUFmQVFBQUlRRUFBQ01CQUFBbEFRQUFKd0VBQUNrQkFBQXJBUUFBTFFFQUFDOEJBQUF4QVFBQU13RUFBRFVCQUFBM0FRQUFPUUVBQURzQkFBQTlBUUFBUHdFQUFFRUJBQUJEQVFBQVJRRUFBRWNCQUFCSkFRQUFTd0VBQUUwQkFBQlBBUUFBVVFFQUFGTUJBQUJWQVFBQVZ3RUFBRmtCQUFCYkFRQUFYUUVBQUY4QkFBQU5BQUFBR1FBQUFDa0FBQUE5QUFBQVZRQUFBSEVBQUFDUkFBQUF0UUFBQU4wQUFBQUpBUUFBT1FFQUFHMEJBQUNsQVFBQTRRRUFBQ0VDQUFCbEFnQUFyUUlBQVBrQ0FBQkpBd0FBblFNQUFQVURBQUJSQkFBQXNRUUFBQlVGQUFCOUJRQUE2UVVBQUZrR0FBRE5CZ0FBUlFjQUFNRUhBQUJCQ0FBQXhRZ0FBRTBKQUFEWkNRQUFhUW9BQVAwS0FBQ1ZDd0FBTVF3QUFORU1BQUIxRFFBQUhRNEFBTWtPQUFCNUR3QUFMUkFBQU9VUUFBQ2hFUUFBWVJJQUFDVVRBQUR0RXdBQXVSUUFBSWtWQUFCZEZnQUFOUmNBQUJFWUFBRHhHQUFBMVJrQUFMMGFBQUNwR3dBQW1Sd0FBSTBkQUFDRkhnQUFnUjhBQUlFZ0FBQ0ZJUUFBalNJQUFKa2pBQUNwSkFBQXZTVUFBTlVtQUFEeEp3QUFFU2tBQURVcUFBQmRLd0FBaVN3QUFMa3RBQUR0TGdBQUpUQUFBR0V4QUFDaE1nQUE1VE1BQUMwMUFBQjVOZ0FBeVRjQUFCMDVBQUIxT2dBQTBUc0FBREU5QUFDVlBnQUEvVDhBQUdsQkFBRFpRZ0FBVFVRQUFNVkZBQUJCUndBQXdVZ0FBRVZLQUFETlN3QUFXVTBBQU9sT0FBQjlVQUFBRlZJQUFMRlRBQUJSVlFBQTlWWUFBSjFZQUFCSldnQUErVnNBQUsxZEFBQmxYd0FBSVdFQUFPRmlBQUNsWkFBQWJXWUFBRGxvQUFBSmFnQUEzV3NBQUxWdEFBQ1Jid0FBY1hFQUFGVnpBQUE5ZFFBQUtYY0FBQmw1QUFBTmV3QUFCWDBBQUFGL0FBQUJnUUFBQllNQUFBMkZBQUFaaHdBQUtZa0FBRDJMQUFCVmpRQUFjWThBQUpHUkFBQzFrd0FBM1pVQUFBbVlBQUE1bWdBQWJad0FBS1dlQUFEaG9BQUFJYU1BQUdXbEFBQ3Rwd0FBK2FrQUFFbXNBQUNkcmdBQTliQUFBRkd6QUFDeHRRQUFGYmdBQUgyNkFBRHB2QUFBV2I4QUFNM0JBQUJGeEFBQXdjWUFBRUhKQUFERnl3QUFUYzRBQU5uUUFBQnAwd0FBL2RVQUFKWFlBQUF4MndBQTBkMEFBSFhnQUFBZDR3QUF5ZVVBQUhub0FBQXQ2d0FBNWUwQUFLSHdBQUEvQUFBQWdRQUFBT2NBQUFCNUFRQUFQd0lBQUVFREFBQ0hCQUFBR1FZQUFQOEhBQUJCQ2dBQTV3d0FBUGtQQUFCL0V3QUFnUmNBQUFjY0FBQVpJUUFBdnlZQUFBRXRBQURuTXdBQWVUc0FBTDlEQUFEQlRBQUFoMVlBQUJsaEFBQi9iQUFBd1hnQUFPZUZBQUQ1a3dBQS82SUFBQUd6QUFBSHhBQUFHZFlBQUQvcEFBQ0IvUUFBNXhJQkFIa3BBUUEvUVFFQVFWb0JBSWQwQVFBWmtBRUEvNndCQUVITEFRRG42Z0VBK1FzQ0FIOHVBZ0NCVWdJQUIzZ0NBQm1mQWdDL3h3SUFBZklDQU9jZEF3QjVTd01BdjNvREFNR3JBd0NIM2dNQUdSTUVBSDlKQkFEQmdRUUE1N3NFQVBuM0JBRC9OUVVBQVhZRkFBZTRCUUFaL0FVQVAwSUdBSUdLQmdEbjFBWUFlU0VIQUQ5d0J3QkJ3UWNBaHhRSUFCbHFDQUQvd1FnQVFSd0pBT2Q0Q1FENTF3a0FmemtLQUlHZENnQUhCQXNBR1cwTEFML1lDd0FCUnd3QTU3Y01BSGtyRFFDL29RMEF3Um9PQUllV0RnQVpGUThBZjVZUEFNRWFFQURub1JBQStTc1JBUCs0RVFBQlNSSUFCOXdTQUJseUV3QS9DeFFBZ2FjVUFPZEdGUUI1NlJVQVA0OFdBRUU0RndDSDVCY0FHWlFZQVA5R0dRQkIvUmtBNTdZYUFQbHpHd0IvTkJ3QWdmZ2NBQWZBSFFBWml4NEF2MWtmQUFFc0lBRG5BU0VBZWRzaEFMKzRJZ0RCbVNNQWgzNGtBQmxuSlFCL1V5WUF3VU1uQU9jM0tBRDVMeWtBL3lzcUFBRXNLd0FITUN3QUdUZ3RBRDlFTGdDQlZDOEE1Mmd3QUhtQk1RQS9uaklBUWI4ekFJZmtOQUFaRGpZQS96czNBRUZ1T0FEbnBEa0ErZDg2QUg4ZlBBQ0JZejBBQjZ3K0FCbjVQd0MvU2tFQUFhRkNBT2Y3UXdCNVcwVUF2NzlHQU1Fb1NBQ0hsa2tBR1FsTEFIK0FUQURCL0UwQTUzMVBBUGtEVVFEL2psSUFBUjlVQUFlMFZRQVpUbGNBUCsxWUFJR1JXZ0RuT2x3QWVlbGRBRCtkWHdCQlZtRUFoeFJqQUJuWVpBRC9vR1lBUVc5b0FPZENhZ0Q1RzJ3QWYvcHRBRUVCQUFDcEFnQUFDUVVBQU1FSUFBQkJEZ0FBQ1JZQUFLa2dBQURCTGdBQUFVRUFBQ2xZQUFBSmRRQUFnWmdBQUlIREFBQUo5d0FBS1RRQkFBRjhBUURCendFQXFUQUNBQW1nQWdCQkh3TUF3YThEQUFsVEJBQ3BDZ1VBUWRnRkFJRzlCZ0FwdkFjQUNkWUlBQUVOQ2dBQll3c0FDZG9NQUNsMERnQ0JNeEFBUVJvU0FLa3FGQUFKWnhZQXdkRVlBRUZ0R3dBSlBCNEFxVUFoQU1GOUpBQUI5aWNBS2F3ckFBbWpMd0NCM1RNQWdWNDRBQWtwUFFBcFFFSUFBYWRIQU1GZ1RRQ3BjRk1BQ2RwWkFFR2dZQURCeG1jQUNWRnZBS2xDZHdCQm4zOEFnV3FJQUNtb2tRQUpYSnNBQVlxbEFBRTJzQUFKWkxzQUtSakhBSUZXMHdCQkkrQUFxWUx0QUFsNSt3REJDZ29CUVR3WkFRa1NLUUdwa0RrQndieEtBUUdiWEFFcE1HOEJDWUdDQVlHU2xnR0JhYXNCQ1F2QkFTbDgxd0VCd3U0QndlRUdBcW5nSHdJSnhEa0NRWkZVQXNGTmNBSUovNHdDcWFxcUFrRld5UUtCQitrQ0tjUUpBd21TS3dNQmQwNERBWGx5QXdtZWx3TXA3TDBEZ1dubEEwRWNEZ1NwQ2pnRUNUdGpCTUd6andSQmU3MEVDWmpzQktrUUhRWEI2MDRGQVRDQ0JTbmt0Z1VKRCswRmdiY2tCb0hrWFFZSm5aZ0dLZWpVQmdITkVnZkJVbElIcVlDVEJ3bGUxZ2RCOGhvSXdVUmhDQWxkcVFpcFF2TUlRZjArQ1lHVWpBa3BFTndKQ1hndENnSFVnQW9CTE5ZS0NZZ3RDeW53aGd1QmJPSUxRUVZBREtuQ253d0pyUUVOd2N4bERVRXF6QTBKempRT3FjQ2ZEc0VLRFE4QnRYd1BLY2p1RHdsTll4Q0JUTm9RZ2M5VEVRbmZ6eEVwaEU0U0FjalBFc0d6VXhPcFVOb1RDYWhqRkVIRDd4VEJxMzRWQ1dzUUZxa0twUlpCbER3WGdSSFhGeW1NZEJnSkRoVVpBYUc0R1FGUFh4b0pJZ2tiS1NTMkc0RmZaaHhCM2hrZHFhclFIUW5QaWg3QlZVZ2ZRVWtKSUFtMHpTQ3BvSlVod1JsaElnRXFNQ01wM0FJa0NUdlpKSUZSc3lXVEJnQUFSUTRBQUE4Y0FBQVJNd0FBVzFjQUFBMk9BQUIzM1FBQU9VMEJBR1BtQVFDVnN3SUFIOEVEQUNFZEJRQ3Ixd1lBM1FJSkFBZXpDd0RKL2c0QU0vOFNBT1hQRndBdmp4MEFNVjRrQVB0Z0xBQ3R2alVBbDZGQUFGazNUUUFEc1ZzQU5VTnNBRDhtZndCQmxwUUFTOU9zQUgwaHlBQW55ZVlBNlJZSkFkTmJMd0dGN1ZrQlR5YUpBVkZsdlFHYkR2Y0JUWXMyQXJkSmZBSjV2Y2dDbzE4Y0E5V3Vkd05mTDlzRFlXdEhCT3Z5dkFRZFhEd0ZSMFBHQlFsTFd3WnpIUHdHSldlcEIyL2hZd2h4U0N3Sk8yQURDdTN6NlFyWDFlQUxtZC9vREVQeUFnNTE5aThQZjl4d0VJR2N4aEdMTmpJVHZiSzBGR2NoVHhZcG13SVlFMEhRR2NVOHVSdVB3TDRka1FmaUg5dFZKQ0tOK0lZazkwVUxKN21kc2luamFINHNGUnB3TDU4dGlUS2hLY3MxSzU0M09WMGwwRHlIWTVaQVNRZU1STFBKc2tobGJneE5yOE9hVWJHaVgxWjc3MXhiTFptVVlCZWFDR2JaOTdwcmc4T3RjYlVaNDNlL0lsMStIU01BQUhGTkFBQ1JuQUFBL1NZQkFHVU1BZ0RwZHdNQW1hSUZBRFhXQ0FBdGNBMEE0ZVFUQUNIREhBRHR0eWdBZFpJNEFGbElUUUFwK21jQUpmaUpBRDNIdEFCUkp1b0FzUk1zQWQzU2ZBR0Y4dDRCeVZKVkFya3I0d0lWRkl3RFRRaFVCTUZ4UHdWQkxsTUd6WmVVQjVXTUNRazVkN2dLU1Zlb0RBWEs0QTVkRTJvUk1TZE5GTkd5a3hlOUprZ2JwY0IxSDZtVktDVFpuRzBwOWJsU0wyM0k1aldocGprOVlVRmNSYTJmWUU2MTdsbFlHWTVjWTJrY2ZtL2xnOVY4LzcwQUFBR29BUUNQYXdNQThaNEdBRDhqREFEQlBSVUFqN1lqQVBIOE9RRC9VVnNBQWZxTEFBOTEwUUJ4dnpJQlA1cTRBY0hjYlFJUHoxOERjWTZlQlA5N1BRWUJ0bE1JajV6OEN2RmhXQTQvcDR3U3dTWEZGNDlsTkI3eGdSUW0vL3VuTHdHY09qc1BZaUpKY1liQVdUK0tnbTNCV09PRUFRNEVBSkVoQ1FBUkxCTUFRZTRsQUVGUFJ3Q1JRNEFBRWZmZEFBRkdjd0VCa2xvQ0VRRzRBNUUxdkFWQmo2Y0lRUWJPREJHeW14S1JENW9hQVJwMkpRRk1CelNSbmxkSEVaMnNZRUdta1lFalVSWUF4WjR5QUJlNWF3Q1o5dGdBYTRtZ0FRM0UvZ0lmQVZBRklka2RDVE5zTUEvVm9xUVlwMmNJSnluOWZUeDd0ZWRiSFhjZGlhK2dMY210am5zQWllWVpBVG1XWGdJOUZ0Z0V0V04zQ2VFb3hoRWhBelFnZFVpQ09IMVhWMkMvVzY4Q2dkZ25CdmVFWGczcC9xMGJmNHZyTm9HMzVXZ1hBNXpCd1F6L0RqbHFoU0laN3BGTGdYZ3JualBoQ1ZTVml3QUFONWdBQVArbEFBQUV0UUFBWjhVQUFFWFhBQURCNmdBQS8vOEFBQUFBemtBQUFNaEFBQUM0UUFBQXFrQUFBS0pBQUFDYVFBQUFrRUFBQUl4QUFBQ2NRQUFBbGtBQUFKSkFBQUNPUUFBQW5FQUFBSlJBQUFDS1FBQUFrRUFBQUl4QUFBQ1VRQUFBbUVBQUFJNUFBQUJ3UUFBQWNFQUFBSEJBQUFCd1FBQUFjRUFBUWJEYUFRdnlBa2gvUVlGQ2dFR0FRSUErZ0VDQVFJQmNUbHhQWEU1YVQzUXBjeWh5S0lRYWhCcVJFYUVNc0FxeEN4aXpNSW8yaHphRU5ZWTRoVGVFTjRROWNrWmdTbGhMV0ZkS1dVSmJRMlE3YkRKNEtIb2xZU3RPTWxOT1ZGRllTMVpLVjBkYVNWMUtYVXB0S0hJa2RTSjFJbzhSa1JLU0U2SU1wUXF5QjcwR3ZnaXhDUmV5Tm5NL1prSmlSV05LV1VkYlNWdE9XVlpRWEVKZFFHWTdaenhvUEhVMGV5eUtJNFVmWVNaTkxUMWFYVHhwS21zcGJpMTBKbkVtY0NaOEdvUWJpQk9NRkpzT254Q2VFcW9Oc1FxN0NNQUdyd21mQ2hXeU8yNUhWa3RWVkZOYlFsaEpWMGhjUzJKSWFUcHJObk0wY2pkd09JRXpoQ2lXSVl3ZFlpTk5LaXA1WUVKc0syOG9kU3g3SUhna2R5Ri9JWVlpaXhXVEY1Z1VuaG1hR3FZVnJSQzREYmdLbGcyTER4YXlQM0pLVWxSVFhGSm5QbUJJWUVObFNXdEljVGQyTkgwMGRqUjFONGN4aVNlZElKRWRZU0ZOS0FBQVpqOEFBRXcvQUFBbVB3QUFBRDhBaG1zL0FCUXVQd0J3dlQ0QTBFdytBZ0VBUWJIZEFRc2dDQTBRRXhVWEdCb2JIQjBlSHlBZ0lTSWlJeVFrSlNVUEFBQUFDZ0FBQUFVQVFlYmRBUXZoRmVBL0FBQUFBQUFBNEw4REFBQUFCQUFBQUFRQUFBQUdBQUFBZy9taUFFUk9iZ0Q4S1JVQTBWY25BTjAwOVFCaTI4QUFQSm1WQUVHUVF3QmpVZjRBdTk2ckFMZGh4UUE2YmlRQTBrMUNBRWtHNEFBSjZpNEFISkxSQU9zZC9nQXBzUndBNkQ2bkFQVTFnZ0JFdXk0QW5PbUVBTFFtY0FCQmZsOEExcEU1QUZPRE9RQ2M5RGtBaTErRUFDajV2UUQ0SHpzQTN2K1hBQStZQlFBUkwrOEFDbHFMQUcwZmJRRFBmallBQ2NzbkFFWlB0d0NlWmo4QUxlcGZBTG9uZFFEbDY4Y0FQWHZ4QVBjNUJ3Q1NVb29BKzJ2cUFCK3hYd0FJWFkwQU1BTldBSHY4UmdEd3Eyc0FJTHpQQURiMG1nRGpxUjBBWG1HUkFBZ2I1Z0NGbVdVQW9CUmZBSTFBYUFDQTJQOEFKM05OQUFZR01RREtWaFVBeWFoekFIdmlZQUJyak1BQUdjUkhBTTFud3dBSjZOd0FXWU1xQUl0MnhBQ21ISllBUksvZEFCbFgwUUNsUGdVQUJRZi9BRE4rUHdEQ011Z0FtRS9lQUx0OU1nQW1QY01BSG12dkFKLzRYZ0ExSHpvQWYvTEtBUEdISFFCOGtDRUFhaVI4QU5WdStnQXdMWGNBRlR0REFMVVV4Z0RER1owQXJjVENBQ3hOUVFBTUFGMEFobjFHQU9OeExRQ2J4cG9BTTJJQUFMVFNmQUMwcDVjQU4xWFZBTmMrOWdDakVCZ0FUWGI4QUdTZEtnQncxNnNBWTN6NEFIcXdWd0FYRmVjQXdFbFdBRHZXMlFDbmhEZ0FKQ1BMQU5hS2R3QmFWQ01BQUIrNUFQRUtHd0FaenQ4QW56SC9BR1llYWdDWlYyRUFyUHRIQUg1LzJBQWlaYmNBTXVpSkFPYS9ZQUR2eE0wQWJEWUpBRjAvMUFBVzN0Y0FXRHZlQU42YmtnRFNJaWdBS0lib0FPSllUUURHeWpJQUNPTVdBT0I5eXdBWHdGQUE4eDJuQUJqZ1d3QXVFelFBZ3hKaUFJTklBUUQxamxzQXJiQi9BQjdwOGdCSVNrTUFFR2ZUQUtyZDJBQ3VYMElBYW1IT0FBb29wQURUbWJRQUJxYnlBRngzZndDandvTUFZVHlJQUlwemVBQ3ZqRm9BYjllOUFDMm1Zd0QwdjhzQWpZSHZBQ2JCWndCVnlrVUF5dGsyQUNpbzBnRENZWTBBRXNsM0FBUW1GQUFTUnBzQXhGbkVBTWpGUkFCTnNwRUFBQmZ6QU5SRHJRQXBTZVVBL2RVUUFBQysvQUFlbE13QWNNN3VBQk0rOVFEczhZQUFzK2ZEQU1mNEtBQ1RCWlFBd1hFK0FDNEpzd0FMUmZNQWlCS2NBS3NnZXdBdXRaOEFSNUxDQUhzeUx3QU1WVzBBY3FlUUFHdm5Id0F4eTVZQWVSWktBRUY1NGdEMDM0a0E2SlNYQU9MbWhBQ1pNWmNBaU8xckFGOWZOZ0M3L1E0QVNKcTBBR2VrYkFCeGNrSUFqVjB5QUo4VnVBQzg1UWtBalRFbEFQZDBPUUF3QlJ3QURRd0JBRXNJYUFBczdsZ0FSNnFRQUhUbkFnQzkxaVFBOTMybUFHNUljZ0NmRnU4QWpwU21BTFNSOWdEUlUxRUF6d3J5QUNDWU13RDFTMzRBc21Ob0FOMCtYd0JBWFFNQWhZbC9BRlZTS1FBM1pNQUFiZGdRQURKSU1nQmJUSFVBVG5IVUFFVlViZ0FMQ2NFQUt2VnBBQlJtMVFBbkI1MEFYUVJRQUxRNzJ3RHFkc1VBaC9rWEFFbHJmUUFkSjdvQWxta3BBTWJNckFDdEZGUUFrT0pxQUlqWmlRQXNjbEFBQktTK0FIY0hsQUR6TUhBQUFQd25BT3B4cUFCbXdra0FaT0E5QUpmZGd3Q2pQNWNBUTVUOUFBMkdqQUF4UWQ0QWtqbWRBTjF3akFBWHQrY0FDTjg3QUJVM0t3QmNnS0FBV29DVEFCQVJrZ0FQNk5nQWJJQ3ZBTnYvU3dBNGtBOEFXUmgyQUdLbEZRQmh5N3NBeDRtNUFCQkF2UURTOGdRQVNYVW5BT3UyOWdEYklyc0FDaFNxQUlrbUx3QmtnM1lBQ1RzekFBNlVHZ0JST3FvQUhhUENBSy90cmdCY0poSUFiY0pOQUMxNm5BREFWcGNBQXorREFBbnc5Z0FyUUl3QWJUR1pBRG0wQndBTUlCVUEyTU5iQVBXU3hBREdyVXNBVHNxbEFLYzN6UURtcVRZQXE1S1VBTjFDYUFBWlk5NEFkb3p2QUdpTFVnRDgyemNBcnFHckFOOFZNUUFBcnFFQURQdmFBR1JOWmdEdEJiY0FLV1V3QUZkV3Z3Qkgvem9BYXZtNUFIVys4d0Fvazk4QXE0QXdBR2FNOWdBRXl4VUEraUlHQU5ua0hRQTlzNlFBVnh1UEFEYk5DUUJPUXVrQUU3NmtBRE1qdFFEd3Fob0FUMldvQU5MQnBRQUxQdzhBVzNqTkFDUDVkZ0I3aXdRQWlSZHlBTWFtVXdCdmJ1SUE3K3NBQUp0S1dBREUycmNBcW1hNkFIYlB6d0RSQWgwQXNmRXRBSXlad1FERHJYY0Foa2phQVBkZG9BREdnUFFBclBBdkFOM3NtZ0EvWEx3QTBONXRBSkRISHdBcTI3WUFveVU2QUFDdm1nQ3RVNU1BdGxjRUFDa3R0QUJMZ0g0QTJnZW5BSGFxRGdCN1dhRUFGaElxQU55M0xRRDY1ZjBBaWR2K0FJbSsvUURrZG13QUJxbjhBRDZBY0FDRmJoVUEvWWYvQUNnK0J3Qmhaek1BS2hpR0FFMjk2Z0N6NTY4QWoyMXVBSlZuT1FBeHYxc0FoTmRJQUREZkZnREhMVU1BSldFMUFNbHd6Z0F3eTdnQXYyejlBS1FBb2dBRmJPUUFXdDJnQUNGdlJ3QmlFdElBdVZ5RUFIQmhTUUJyVnVBQW1WSUJBRkJWTndBZTFiY0FNL0hFQUJOdVh3QmRNT1FBaFM2cEFCMnl3d0NoTWpZQUNMZWtBT3F4MUFBVzl5RUFqMm5rQUNmL2R3QU1BNEFBalVBdEFFL05vQUFncFprQXM2TFRBQzlkQ2dDMCtVSUFFZHJMQUgyKzBBQ2IyOEVBcXhlOUFNcWlnUUFJYWx3QUxsVVhBQ2NBVlFCL0ZQQUE0UWVHQUJRTFpBQ1dRWTBBaDc3ZUFOcjlLZ0JySmJZQWU0azBBQVh6L2dDNXY1NEFhR3BQQUVvcXFBQlB4Rm9BTGZpOEFOZGFtQUQweDVVQURVMk5BQ0E2cGdDa1YxOEFGRCt4QUlBNGxRRE1JQUVBY2QyR0FNbmV0Z0MvWVBVQVRXVVJBQUVIYXdDTXNLd0Fzc0RRQUZGVlNBQWUrdzRBbFhMREFLTUdPd0RBUURVQUJ0eDdBT0JGekFCT0tmb0Exc3JJQU9qelFRQjhaTjRBbTJUWUFObStNUUNrbDhNQWQxalVBR25qeFFEdzJoTUF1am84QUVZWVJnQlZkVjhBMHIzMUFHNlN4Z0NzTGwwQURrVHRBQncrUWdCaHhJY0FLZjNwQU9mVzh3QWlmTW9BYjVFMUFBamd4UUQvMTQwQWJtcmlBTEQ5eGdDVENNRUFmRjEwQUd1dHNnRE5icDBBUG5KN0FNWVJhZ0QzejZrQUtYUGZBTFhKdWdDM0FGRUE0cklOQUhTNkpBRGxmV0FBZE5pS0FBMFZMQUNCR0F3QWZtYVVBQUVwRmdDZmVuWUEvZjIrQUZaRjd3RFpmallBN05rVEFJdTZ1UURFbC93QU1hZ25BUEZ1d3dDVXhUWUEyS2hXQUxTb3RRRFB6QTRBRW9rdEFHOVhOQUFzVm9rQW1jN2pBTllndVFCclhxb0FQaXFjQUJGZnpBRDlDMG9BNGZUN0FJNDdiUURpaGl3QTZkU0VBUHkwcVFEdjd0RUFMalhKQUM4NVlRQTRJVVFBRzluSUFJSDhDZ0Q3U21vQUx4ellBRk8waEFCT21Zd0FWQ0xNQUNwVjNBREF4dFlBQ3htV0FCcHd1QUJwbFdRQUpscGdBRDlTN2dCL0VROEE5TFVSQVB6TDlRQTB2QzBBTkx6dUFPaGR6QURkWG1BQVo0NmJBSkl6N3dESkY3Z0FZVmliQU9GWHZBQlJnOFlBMkQ0UUFOMXhTQUF0SE4wQXJ4aWhBQ0VzUmdCWjg5Y0EyWHFZQUo1VXdBQlBodm9BVmdiOEFPVjVyZ0NKSWpZQU9LMGlBR2VUM0FCVjZLb0FnaVk0QU1ybm13QlJEYVFBbVRPeEFLblhEZ0JwQlVnQVpiTHdBSCtJcHdDSVRKY0ErZEUyQUNHU3N3Qjdna29BbU04aEFFQ2YzQURjUjFVQTRYUTZBR2ZyUWdEK25kOEFYdFJmQUh0bnBBQzZySG9BVmZhaUFDdUlJd0JCdWxVQVdXNElBQ0VxaGdBNVI0TUFpZVBtQU9XZTFBQkorMEFBLzFicEFCd1B5Z0RGV1lvQWxQb3JBTlBCeFFBUHhjOEEyMXF1QUVmRmhnQ0ZRMklBSVlZN0FDeDVsQUFRWVljQUtreDdBSUFzR2dCRHZ4SUFpQ2FRQUhnOGlRQ294T1FBNWR0N0FNUTZ3Z0FtOU9vQTkyZUtBQTJTdndCbG95c0FQWk94QUwxOEN3Q2tVZHdBSjkxakFHbmgzUUNhbEJrQXFDbVZBR2pPS0FBSjdiUUFSSjhnQUU2WXlnQndnbU1BZm53akFBKzVNZ0NuOVk0QUZGYm5BQ0h4Q0FDMW5Tb0FiMzVOQUtVWlVRQzErYXNBZ3QvV0FKYmRZUUFXTmdJQXhEcWZBSU9pb1FCeTdXMEFPWTE2QUlLNHFRQnJNbHdBUmlkYkFBQTA3UURTQUhjQS9QUlZBQUZaVFFEZ2NZQUFRZFB6QVF0UlFQc2grVDhBQUFBQUxVUjBQZ0FBQUlDWVJ2ZzhBQUFBWUZITWVEc0FBQUNBZ3h2d09RQUFBRUFnSlhvNEFBQUFnQ0tDNHpZQUFBQUFIZk5wTlJoOEFBQXRLeUFnSURCWU1IZ0FLRzUxYkd3cEFFR3c5QUVMUVJFQUNnQVJFUkVBQUFBQUJRQUFBQUFBQUFrQUFBQUFDd0FBQUFBQUFBQUFFUUFQQ2hFUkVRTUtCd0FCQUFrTEN3QUFDUVlMQUFBTEFBWVJBQUFBRVJFUkFFR0I5UUVMSVFzQUFBQUFBQUFBQUJFQUNnb1JFUkVBQ2dBQUFnQUpDd0FBQUFrQUN3QUFDd0JCdS9VQkN3RU1BRUhIOVFFTEZRd0FBQUFBREFBQUFBQUpEQUFBQUFBQURBQUFEQUJCOWZVQkN3RU9BRUdCOWdFTEZRMEFBQUFFRFFBQUFBQUpEZ0FBQUFBQURnQUFEZ0JCci9ZQkN3RVFBRUc3OWdFTEhnOEFBQUFBRHdBQUFBQUpFQUFBQUFBQUVBQUFFQUFBRWdBQUFCSVNFZ0JCOHZZQkN3NFNBQUFBRWhJU0FBQUFBQUFBQ1FCQm8vY0JDd0VMQUVHdjl3RUxGUW9BQUFBQUNnQUFBQUFKQ3dBQUFBQUFDd0FBQ3dCQjNmY0JDd0VNQUVIcDl3RUxKd3dBQUFBQURBQUFBQUFKREFBQUFBQUFEQUFBREFBQU1ERXlNelExTmpjNE9VRkNRMFJGUmdCQmtQZ0JDd25nZzFBQUFBQUFBQVVBUWFUNEFRc0JBZ0JCdlBnQkN3NERBQUFBQkFBQUFKaC9BQUFBQkFCQjFQZ0JDd0VCQUVIaitBRUxCUXIvLy8vL0FFSFUrZ0VMQXNDRFwiO2Z1bmN0aW9uIGUoQSl7dHJ5e2lmKEE9PWImJncpcmV0dXJuIG5ldyBVaW50OEFycmF5KHcpO3ZhciBJPWZ1bmN0aW9uKEEpe2lmKGYoQSkpcmV0dXJuIGZ1bmN0aW9uKEEpe3RyeXtmb3IodmFyIEk9cChBKSxnPW5ldyBVaW50OEFycmF5KEkubGVuZ3RoKSxCPTA7QjxJLmxlbmd0aDsrK0IpZ1tCXT1JLmNoYXJDb2RlQXQoQik7cmV0dXJuIGd9Y2F0Y2goQSl7dGhyb3cgbmV3IEVycm9yKFwiQ29udmVydGluZyBiYXNlNjQgc3RyaW5nIHRvIGJ5dGVzIGZhaWxlZC5cIil9fShBLnNsaWNlKHIubGVuZ3RoKSl9KEEpO2lmKEkpcmV0dXJuIEk7dGhyb3dcImJvdGggYXN5bmMgYW5kIHN5bmMgZmV0Y2hpbmcgb2YgdGhlIHdhc20gZmFpbGVkXCJ9Y2F0Y2goQSl7bihBKX19ZnVuY3Rpb24geChJKXtmb3IoO0kubGVuZ3RoPjA7KXt2YXIgZz1JLnNoaWZ0KCk7aWYoXCJmdW5jdGlvblwiIT10eXBlb2YgZyl7dmFyIEI9Zy5mdW5jO1wibnVtYmVyXCI9PXR5cGVvZiBCP3ZvaWQgMD09PWcuYXJnP3EuZ2V0KEIpKCk6cS5nZXQoQikoZy5hcmcpOkIodm9pZCAwPT09Zy5hcmc/bnVsbDpnLmFyZyl9ZWxzZSBnKEEpfX1mKGIpfHwoVz1iLGI9QS5sb2NhdGVGaWxlP0EubG9jYXRlRmlsZShXLG8pOm8rVyk7dmFyIHY9e21hcHBpbmdzOnt9LGJ1ZmZlcnM6W251bGwsW10sW11dLHByaW50Q2hhcjpmdW5jdGlvbihBLEkpe3ZhciBnPXYuYnVmZmVyc1tBXTswPT09SXx8MTA9PT1JPygoMT09PUE/RzpSKSh5KGcsMCkpLGcubGVuZ3RoPTApOmcucHVzaChJKX0sdmFyYXJnczp2b2lkIDAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHYudmFyYXJncys9NCxoW3YudmFyYXJncy00Pj4yXX0sZ2V0U3RyOmZ1bmN0aW9uKEEpe3JldHVybiBIKEEpfSxnZXQ2NDpmdW5jdGlvbihBLEkpe3JldHVybiBBfX0scD1cImZ1bmN0aW9uXCI9PXR5cGVvZiBhdG9iP2F0b2I6ZnVuY3Rpb24oQSl7dmFyIEksZyxCLFEsQyxFLGk9XCJBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvPVwiLEQ9XCJcIixvPTA7QT1BLnJlcGxhY2UoL1teQS1aYS16MC05XFxcXCtcXFxcL1xcXFw9XS9nLFwiXCIpO2Rve0k9aS5pbmRleE9mKEEuY2hhckF0KG8rKykpPDwyfChRPWkuaW5kZXhPZihBLmNoYXJBdChvKyspKSk+PjQsZz0oMTUmUSk8PDR8KEM9aS5pbmRleE9mKEEuY2hhckF0KG8rKykpKT4+MixCPSgzJkMpPDw2fChFPWkuaW5kZXhPZihBLmNoYXJBdChvKyspKSksRCs9U3RyaW5nLmZyb21DaGFyQ29kZShJKSw2NCE9PUMmJihEKz1TdHJpbmcuZnJvbUNoYXJDb2RlKGcpKSw2NCE9PUUmJihEKz1TdHJpbmcuZnJvbUNoYXJDb2RlKEIpKX13aGlsZShvPEEubGVuZ3RoKTtyZXR1cm4gRH07dmFyIFQsTz17YjpmdW5jdGlvbihBLEksZyl7ay5jb3B5V2l0aGluKEEsSSxJK2cpfSxjOmZ1bmN0aW9uKEEpe24oXCJPT01cIil9LGE6ZnVuY3Rpb24oQSxJLGcsQil7Zm9yKHZhciBRPTAsQz0wO0M8ZztDKyspe2Zvcih2YXIgRT1oW0krOCpDPj4yXSxpPWhbSSsoOCpDKzQpPj4yXSxEPTA7RDxpO0QrKyl2LnByaW50Q2hhcihBLGtbRStEXSk7USs9aX1yZXR1cm4gaFtCPj4yXT1RLDB9fSxsPShmdW5jdGlvbigpe3ZhciBJPXthOk99O2Z1bmN0aW9uIGcoSSxnKXt2YXIgQixRPUkuZXhwb3J0cztBLmFzbT1RLEI9QS5hc20uZC5idWZmZXIsQS5IRUFQOD1zPW5ldyBJbnQ4QXJyYXkoQiksQS5IRUFQMTY9bmV3IEludDE2QXJyYXkoQiksQS5IRUFQMzI9aD1uZXcgSW50MzJBcnJheShCKSxBLkhFQVBVOD1rPW5ldyBVaW50OEFycmF5KEIpLEEuSEVBUFUxNj1uZXcgVWludDE2QXJyYXkoQiksQS5IRUFQVTMyPW5ldyBVaW50MzJBcnJheShCKSxBLkhFQVBGMzI9bmV3IEZsb2F0MzJBcnJheShCKSxBLkhFQVBGNjQ9bmV3IEZsb2F0NjRBcnJheShCKSxxPUEuYXNtLmUsZnVuY3Rpb24oSSl7aWYoZC0tLEEubW9uaXRvclJ1bkRlcGVuZGVuY2llcyYmQS5tb25pdG9yUnVuRGVwZW5kZW5jaWVzKGQpLDA9PWQmJihudWxsIT09UCYmKGNsZWFySW50ZXJ2YWwoUCksUD1udWxsKSx0KSl7dmFyIGc9dDt0PW51bGwsZygpfX0oKX1mdW5jdGlvbiBRKEEpe2coQS5pbnN0YW5jZSl9ZnVuY3Rpb24gQyhBKXtyZXR1cm4od3x8XCJmdW5jdGlvblwiIT10eXBlb2YgZmV0Y2g/UHJvbWlzZS5yZXNvbHZlKCkudGhlbigoZnVuY3Rpb24oKXtyZXR1cm4gZShiKX0pKTpmZXRjaChiLHtjcmVkZW50aWFsczpcInNhbWUtb3JpZ2luXCJ9KS50aGVuKChmdW5jdGlvbihBKXtpZighQS5vayl0aHJvd1wiZmFpbGVkIHRvIGxvYWQgd2FzbSBiaW5hcnkgZmlsZSBhdCBcXCdcIitiK1wiXFwnXCI7cmV0dXJuIEEuYXJyYXlCdWZmZXIoKX0pKS5jYXRjaCgoZnVuY3Rpb24oKXtyZXR1cm4gZShiKX0pKSkudGhlbigoZnVuY3Rpb24oQSl7cmV0dXJuIFdlYkFzc2VtYmx5Lmluc3RhbnRpYXRlKEEsSSl9KSkudGhlbihBLChmdW5jdGlvbihBKXtSKFwiZmFpbGVkIHRvIGFzeW5jaHJvbm91c2x5IHByZXBhcmUgd2FzbTogXCIrQSksbihBKX0pKX1pZihkKyssQS5tb25pdG9yUnVuRGVwZW5kZW5jaWVzJiZBLm1vbml0b3JSdW5EZXBlbmRlbmNpZXMoZCksQS5pbnN0YW50aWF0ZVdhc20pdHJ5e3JldHVybiBBLmluc3RhbnRpYXRlV2FzbShJLGcpfWNhdGNoKEEpe3JldHVybiBSKFwiTW9kdWxlLmluc3RhbnRpYXRlV2FzbSBjYWxsYmFjayBmYWlsZWQgd2l0aCBlcnJvcjogXCIrQSksITF9KHd8fFwiZnVuY3Rpb25cIiE9dHlwZW9mIFdlYkFzc2VtYmx5Lmluc3RhbnRpYXRlU3RyZWFtaW5nfHxmKGIpfHxcImZ1bmN0aW9uXCIhPXR5cGVvZiBmZXRjaD9DKFEpOmZldGNoKGIse2NyZWRlbnRpYWxzOlwic2FtZS1vcmlnaW5cIn0pLnRoZW4oKGZ1bmN0aW9uKEEpe3JldHVybiBXZWJBc3NlbWJseS5pbnN0YW50aWF0ZVN0cmVhbWluZyhBLEkpLnRoZW4oUSwoZnVuY3Rpb24oQSl7cmV0dXJuIFIoXCJ3YXNtIHN0cmVhbWluZyBjb21waWxlIGZhaWxlZDogXCIrQSksUihcImZhbGxpbmcgYmFjayB0byBBcnJheUJ1ZmZlciBpbnN0YW50aWF0aW9uXCIpLEMoUSl9KSl9KSkpLmNhdGNoKEIpfSgpLEEuX19fd2FzbV9jYWxsX2N0b3JzPWZ1bmN0aW9uKCl7cmV0dXJuKGw9QS5fX193YXNtX2NhbGxfY3RvcnM9QS5hc20uZikuYXBwbHkobnVsbCxhcmd1bWVudHMpfSksWD0oQS5fc3RvcFN0cmVhbT1mdW5jdGlvbigpe3JldHVybihBLl9zdG9wU3RyZWFtPUEuYXNtLmcpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sQS5fc3RhcnRTdHJlYW09ZnVuY3Rpb24oKXtyZXR1cm4oQS5fc3RhcnRTdHJlYW09QS5hc20uaCkuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxBLl9kZWNvZGU9ZnVuY3Rpb24oKXtyZXR1cm4oQS5fZGVjb2RlPUEuYXNtLmkpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sQS5fY3JlYXRlQnVmZmVyPWZ1bmN0aW9uKCl7cmV0dXJuKEEuX2NyZWF0ZUJ1ZmZlcj1BLmFzbS5qKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LEEuX2ZyZWVCdWZmZXI9ZnVuY3Rpb24oKXtyZXR1cm4oQS5fZnJlZUJ1ZmZlcj1BLmFzbS5rKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LEEuX21haW49ZnVuY3Rpb24oKXtyZXR1cm4oQS5fbWFpbj1BLmFzbS5sKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LEEuc3RhY2tTYXZlPWZ1bmN0aW9uKCl7cmV0dXJuKFg9QS5zdGFja1NhdmU9QS5hc20ubSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfSksWj1BLnN0YWNrUmVzdG9yZT1mdW5jdGlvbigpe3JldHVybihaPUEuc3RhY2tSZXN0b3JlPUEuYXNtLm4pLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sVj1BLnN0YWNrQWxsb2M9ZnVuY3Rpb24oKXtyZXR1cm4oVj1BLnN0YWNrQWxsb2M9QS5hc20ubykuYXBwbHkobnVsbCxhcmd1bWVudHMpfTtmdW5jdGlvbiB6KEEpe3RoaXMubmFtZT1cIkV4aXRTdGF0dXNcIix0aGlzLm1lc3NhZ2U9XCJQcm9ncmFtIHRlcm1pbmF0ZWQgd2l0aCBleGl0KFwiK0ErXCIpXCIsdGhpcy5zdGF0dXM9QX1mdW5jdGlvbiBqKEkpe2Z1bmN0aW9uIEIoKXtUfHwoVD0hMCxBLmNhbGxlZFJ1bj0hMCxTfHwoeChLKSx4KGMpLGcoQSksQS5vblJ1bnRpbWVJbml0aWFsaXplZCYmQS5vblJ1bnRpbWVJbml0aWFsaXplZCgpLHUmJmZ1bmN0aW9uKEkpe3ZhciBnLEI9QS5fbWFpbixRPShJPUl8fFtdKS5sZW5ndGgrMSxDPVYoNCooUSsxKSk7aFtDPj4yXT1MKGkpO2Zvcih2YXIgRT0xO0U8UTtFKyspaFsoQz4+MikrRV09TChJW0UtMV0pO2hbKEM+PjIpK1FdPTA7dHJ5e2c9QihRLEMpLEYmJjA9PT1nfHwoRnx8KEEub25FeGl0JiZBLm9uRXhpdChnKSxTPSEwKSxEKGcsbmV3IHooZykpKX1jYXRjaChBKXtpZihBIGluc3RhbmNlb2YgeilyZXR1cm47aWYoXCJ1bndpbmRcIj09QSlyZXR1cm4gdm9pZChGPSEwKTt2YXIgbz1BO0EmJlwib2JqZWN0XCI9PXR5cGVvZiBBJiZBLnN0YWNrJiYobz1bQSxBLnN0YWNrXSksUihcImV4Y2VwdGlvbiB0aHJvd246IFwiK28pLEQoMSxBKX19KEkpLGZ1bmN0aW9uKCl7aWYoQS5wb3N0UnVuKWZvcihcImZ1bmN0aW9uXCI9PXR5cGVvZiBBLnBvc3RSdW4mJihBLnBvc3RSdW49W0EucG9zdFJ1bl0pO0EucG9zdFJ1bi5sZW5ndGg7KUk9QS5wb3N0UnVuLnNoaWZ0KCksWS51bnNoaWZ0KEkpO3ZhciBJO3goWSl9KCkpKX1JPUl8fEUsZD4wfHwoZnVuY3Rpb24oKXtpZihBLnByZVJ1bilmb3IoXCJmdW5jdGlvblwiPT10eXBlb2YgQS5wcmVSdW4mJihBLnByZVJ1bj1bQS5wcmVSdW5dKTtBLnByZVJ1bi5sZW5ndGg7KUk9QS5wcmVSdW4uc2hpZnQoKSxNLnVuc2hpZnQoSSk7dmFyIEk7eChNKX0oKSxkPjB8fChBLnNldFN0YXR1cz8oQS5zZXRTdGF0dXMoXCJSdW5uaW5nLi4uXCIpLHNldFRpbWVvdXQoKGZ1bmN0aW9uKCl7c2V0VGltZW91dCgoZnVuY3Rpb24oKXtBLnNldFN0YXR1cyhcIlwiKX0pLDEpLEIoKX0pLDEpKTpCKCkpKX1pZihBLmN3cmFwPWZ1bmN0aW9uKEEsSSxnLEIpe3ZhciBRPShnPWd8fFtdKS5ldmVyeSgoZnVuY3Rpb24oQSl7cmV0dXJuXCJudW1iZXJcIj09PUF9KSk7cmV0dXJuXCJzdHJpbmdcIiE9PUkmJlEmJiFCP1UoQSk6ZnVuY3Rpb24oKXtyZXR1cm4gYShBLEksZyxhcmd1bWVudHMpfX0sdD1mdW5jdGlvbiBBKCl7VHx8aigpLFR8fCh0PUEpfSxBLnJ1bj1qLEEucHJlSW5pdClmb3IoXCJmdW5jdGlvblwiPT10eXBlb2YgQS5wcmVJbml0JiYoQS5wcmVJbml0PVtBLnByZUluaXRdKTtBLnByZUluaXQubGVuZ3RoPjA7KUEucHJlSW5pdC5wb3AoKSgpO3ZhciB1PSEwO3JldHVybiBBLm5vSW5pdGlhbFJ1biYmKHU9ITEpLEY9ITAsaigpLEEucmVhZHl9KTtBLmV4cG9ydHM9Z319LEk9e307ZnVuY3Rpb24gZyhCKXt2YXIgUT1JW0JdO2lmKHZvaWQgMCE9PVEpcmV0dXJuIFEuZXhwb3J0czt2YXIgQz1JW0JdPXtleHBvcnRzOnt9fTtyZXR1cm4gQVtCXShDLEMuZXhwb3J0cyxnKSxDLmV4cG9ydHN9Zy5uPUE9Pnt2YXIgST1BJiZBLl9fZXNNb2R1bGU/KCk9PkEuZGVmYXVsdDooKT0+QTtyZXR1cm4gZy5kKEkse2E6SX0pLEl9LGcuZD0oQSxJKT0+e2Zvcih2YXIgQiBpbiBJKWcubyhJLEIpJiYhZy5vKEEsQikmJk9iamVjdC5kZWZpbmVQcm9wZXJ0eShBLEIse2VudW1lcmFibGU6ITAsZ2V0OklbQl19KX0sZy5vPShBLEkpPT5PYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoQSxJKSwoKCk9PntcInVzZSBzdHJpY3RcIjt2YXIgQSxJPWcoMzA1KSxCPWcubihJKSxRPTAsQz0wLEU9MCxpPTAsRD0wLG89MDshYXN5bmMgZnVuY3Rpb24oKXtBPWF3YWl0IEIoKSgpLHNlbGYuYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwoYXN5bmMgZnVuY3Rpb24oSSl7dmFyIGc9SS5kYXRhO3N3aXRjaChnLnR5cGUpe2Nhc2VcInN0YXJ0U3RyZWFtXCI6bz1nLmRlY29kZWRTYW1wbGVzUGVyRnJhbWUsRD1vKmcuY2hhbm5lbENvdW50LEEuX3N0YXJ0U3RyZWFtKGcuc2FtcGxlUmF0ZUh6LGcuY2hhbm5lbENvdW50KTticmVhaztjYXNlXCJzdG9wU3RyZWFtXCI6QS5fc3RvcFN0cmVhbSgpO2JyZWFrO2Nhc2VcImRlY29kZVwiOntjb25zdCBJPWcuc3RhcnRUaW1lc3RhbXAsQj1mdW5jdGlvbihJKXtjb25zdCBnPUkuYnl0ZUxlbmd0aDtyZXR1cm4gMCE9USYmQzxnJiYoQS5fZnJlZUJ1ZmZlcihRKSxRPTAsQz0wKSwwPT1RJiYoUT1BLl9jcmVhdGVCdWZmZXIoSS5CWVRFU19QRVJfRUxFTUVOVCpnKSxDPWcpLEEuSEVBUFU4LnNldChJLFEpLFF9KG5ldyBVaW50OEFycmF5KGcuaW5wdXREYXRhKSksdz0oMCE9RSYmaTxEJiYoQS5fZnJlZUJ1ZmZlcihFKSxFPTAsaT0wKSwwPT1FJiYoRT1BLl9jcmVhdGVCdWZmZXIoRmxvYXQzMkFycmF5LkJZVEVTX1BFUl9FTEVNRU5UKkQpLGk9RCksRSksRj1uZXcgRmxvYXQzMkFycmF5KEEuSEVBUEYzMi5idWZmZXIsdyxEKSxHPUEuX2RlY29kZShCLGcuaW5wdXREYXRhLmJ5dGVMZW5ndGgsdyxvKSxSPUYuYnVmZmVyLnNsaWNlKHcsdytEKkYuQllURVNfUEVSX0VMRU1FTlQpO3Bvc3RNZXNzYWdlKHt0eXBlOlwiZGVjb2RlRG9uZVwiLHN0YXJ0VGltZXN0YW1wOkksb3V0cHV0RGF0YTpSLHNhbXBsZXNEZWNvZGVkOkd9LFtSXSk7YnJlYWt9Y2FzZVwicmVsZWFzZVwiOjAhPVEmJihBLl9mcmVlQnVmZmVyKFEpLFE9MCxDPTApLDAhPUUmJihBLl9mcmVlQnVmZmVyKEUpLEU9MCxpPTApLEEuX3N0b3BTdHJlYW0oKX19KSkscG9zdE1lc3NhZ2Uoe3R5cGU6XCJkZWNvZGVyUmVhZHlcIn0pfSgpfSkoKX0pKCk7JyxcIldvcmtlclwiLHZvaWQgMCx2b2lkIDApfX0sNjE0OkE9PntBLmV4cG9ydHM9ZnVuY3Rpb24oQSxlLEksZyl7dmFyIHQ9c2VsZnx8d2luZG93O3RyeXt0cnl7dmFyIGk7dHJ5e2k9bmV3IHQuQmxvYihbQV0pfWNhdGNoKGUpeyhpPW5ldyh0LkJsb2JCdWlsZGVyfHx0LldlYktpdEJsb2JCdWlsZGVyfHx0Lk1vekJsb2JCdWlsZGVyfHx0Lk1TQmxvYkJ1aWxkZXIpKS5hcHBlbmQoQSksaT1pLmdldEJsb2IoKX12YXIgQj10LlVSTHx8dC53ZWJraXRVUkwsQz1CLmNyZWF0ZU9iamVjdFVSTChpKSxRPW5ldyB0W2VdKEMsSSk7cmV0dXJuIEIucmV2b2tlT2JqZWN0VVJMKEMpLFF9Y2F0Y2goZyl7cmV0dXJuIG5ldyB0W2VdKFwiZGF0YTphcHBsaWNhdGlvbi9qYXZhc2NyaXB0LFwiLmNvbmNhdChlbmNvZGVVUklDb21wb25lbnQoQSkpLEkpfX1jYXRjaChBKXtpZighZyl0aHJvdyBFcnJvcihcIklubGluZSB3b3JrZXIgaXMgbm90IHN1cHBvcnRlZFwiKTtyZXR1cm4gbmV3IHRbZV0oZyxJKX19fX0sZT17fTtmdW5jdGlvbiBJKGcpe3ZhciB0PWVbZ107aWYodm9pZCAwIT09dClyZXR1cm4gdC5leHBvcnRzO3ZhciBpPWVbZ109e2V4cG9ydHM6e319O3JldHVybiBBW2ddLmNhbGwoaS5leHBvcnRzLGksaS5leHBvcnRzLEkpLGkuZXhwb3J0c31yZXR1cm4gSS5uPUE9Pnt2YXIgZT1BJiZBLl9fZXNNb2R1bGU/KCk9PkEuZGVmYXVsdDooKT0+QTtyZXR1cm4gSS5kKGUse2E6ZX0pLGV9LEkuZD0oQSxlKT0+e2Zvcih2YXIgZyBpbiBlKUkubyhlLGcpJiYhSS5vKEEsZykmJk9iamVjdC5kZWZpbmVQcm9wZXJ0eShBLGcse2VudW1lcmFibGU6ITAsZ2V0OmVbZ119KX0sSS5vPShBLGUpPT5PYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoQSxlKSxJLnI9QT0+e1widW5kZWZpbmVkXCIhPXR5cGVvZiBTeW1ib2wmJlN5bWJvbC50b1N0cmluZ1RhZyYmT2JqZWN0LmRlZmluZVByb3BlcnR5KEEsU3ltYm9sLnRvU3RyaW5nVGFnLHt2YWx1ZTpcIk1vZHVsZVwifSksT2JqZWN0LmRlZmluZVByb3BlcnR5KEEsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSl9LEkoMTE0KX0pKCl9LDk3MzooQSxlLEkpPT57XCJ1c2Ugc3RyaWN0XCI7dmFyIGc9W1wiQmlnSW50NjRBcnJheVwiLFwiQmlnVWludDY0QXJyYXlcIixcIkZsb2F0MzJBcnJheVwiLFwiRmxvYXQ2NEFycmF5XCIsXCJJbnQxNkFycmF5XCIsXCJJbnQzMkFycmF5XCIsXCJJbnQ4QXJyYXlcIixcIlVpbnQxNkFycmF5XCIsXCJVaW50MzJBcnJheVwiLFwiVWludDhBcnJheVwiLFwiVWludDhDbGFtcGVkQXJyYXlcIl0sdD1cInVuZGVmaW5lZFwiPT10eXBlb2YgZ2xvYmFsVGhpcz9JLmc6Z2xvYmFsVGhpcztBLmV4cG9ydHM9ZnVuY3Rpb24oKXtmb3IodmFyIEE9W10sZT0wO2U8Zy5sZW5ndGg7ZSsrKVwiZnVuY3Rpb25cIj09dHlwZW9mIHRbZ1tlXV0mJihBW0EubGVuZ3RoXT1nW2VdKTtyZXR1cm4gQX19LDg4Mjg6KEEsZSxJKT0+e1widXNlIHN0cmljdFwiO3ZhciBnPUkoODc1MCkoXCIlT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvciVcIiwhMCk7aWYoZyl0cnl7ZyhbXSxcImxlbmd0aFwiKX1jYXRjaChBKXtnPW51bGx9QS5leHBvcnRzPWd9fSxlPXt9O2Z1bmN0aW9uIEkoZyl7dmFyIHQ9ZVtnXTtpZih2b2lkIDAhPT10KXJldHVybiB0LmV4cG9ydHM7dmFyIGk9ZVtnXT17ZXhwb3J0czp7fX07cmV0dXJuIEFbZ10uY2FsbChpLmV4cG9ydHMsaSxpLmV4cG9ydHMsSSksaS5leHBvcnRzfXJldHVybiBJLmc9ZnVuY3Rpb24oKXtpZihcIm9iamVjdFwiPT10eXBlb2YgZ2xvYmFsVGhpcylyZXR1cm4gZ2xvYmFsVGhpczt0cnl7cmV0dXJuIHRoaXN8fG5ldyBGdW5jdGlvbihcInJldHVybiB0aGlzXCIpKCl9Y2F0Y2goQSl7aWYoXCJvYmplY3RcIj09dHlwZW9mIHdpbmRvdylyZXR1cm4gd2luZG93fX0oKSxJKDUwMTQpfSkoKX0pKTsiLCIvKiogQGxpY2Vuc2UgUmVhY3QgdjE3LjAuMlxuICogcmVhY3QtZG9tLmRldmVsb3BtZW50LmpzXG4gKlxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gIChmdW5jdGlvbigpIHtcbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcbnZhciBfYXNzaWduID0gcmVxdWlyZSgnb2JqZWN0LWFzc2lnbicpO1xudmFyIFNjaGVkdWxlciA9IHJlcXVpcmUoJ3NjaGVkdWxlcicpO1xudmFyIHRyYWNpbmcgPSByZXF1aXJlKCdzY2hlZHVsZXIvdHJhY2luZycpO1xuXG52YXIgUmVhY3RTaGFyZWRJbnRlcm5hbHMgPSBSZWFjdC5fX1NFQ1JFVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRDtcblxuLy8gYnkgY2FsbHMgdG8gdGhlc2UgbWV0aG9kcyBieSBhIEJhYmVsIHBsdWdpbi5cbi8vXG4vLyBJbiBQUk9EIChvciBpbiBwYWNrYWdlcyB3aXRob3V0IGFjY2VzcyB0byBSZWFjdCBpbnRlcm5hbHMpLFxuLy8gdGhleSBhcmUgbGVmdCBhcyB0aGV5IGFyZSBpbnN0ZWFkLlxuXG5mdW5jdGlvbiB3YXJuKGZvcm1hdCkge1xuICB7XG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgcHJpbnRXYXJuaW5nKCd3YXJuJywgZm9ybWF0LCBhcmdzKTtcbiAgfVxufVxuZnVuY3Rpb24gZXJyb3IoZm9ybWF0KSB7XG4gIHtcbiAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjIgPiAxID8gX2xlbjIgLSAxIDogMCksIF9rZXkyID0gMTsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgICAgYXJnc1tfa2V5MiAtIDFdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgICB9XG5cbiAgICBwcmludFdhcm5pbmcoJ2Vycm9yJywgZm9ybWF0LCBhcmdzKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwcmludFdhcm5pbmcobGV2ZWwsIGZvcm1hdCwgYXJncykge1xuICAvLyBXaGVuIGNoYW5naW5nIHRoaXMgbG9naWMsIHlvdSBtaWdodCB3YW50IHRvIGFsc29cbiAgLy8gdXBkYXRlIGNvbnNvbGVXaXRoU3RhY2tEZXYud3d3LmpzIGFzIHdlbGwuXG4gIHtcbiAgICB2YXIgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0RGVidWdDdXJyZW50RnJhbWU7XG4gICAgdmFyIHN0YWNrID0gUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5nZXRTdGFja0FkZGVuZHVtKCk7XG5cbiAgICBpZiAoc3RhY2sgIT09ICcnKSB7XG4gICAgICBmb3JtYXQgKz0gJyVzJztcbiAgICAgIGFyZ3MgPSBhcmdzLmNvbmNhdChbc3RhY2tdKTtcbiAgICB9XG5cbiAgICB2YXIgYXJnc1dpdGhGb3JtYXQgPSBhcmdzLm1hcChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgcmV0dXJuICcnICsgaXRlbTtcbiAgICB9KTsgLy8gQ2FyZWZ1bDogUk4gY3VycmVudGx5IGRlcGVuZHMgb24gdGhpcyBwcmVmaXhcblxuICAgIGFyZ3NXaXRoRm9ybWF0LnVuc2hpZnQoJ1dhcm5pbmc6ICcgKyBmb3JtYXQpOyAvLyBXZSBpbnRlbnRpb25hbGx5IGRvbid0IHVzZSBzcHJlYWQgKG9yIC5hcHBseSkgZGlyZWN0bHkgYmVjYXVzZSBpdFxuICAgIC8vIGJyZWFrcyBJRTk6IGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTM2MTBcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nXG5cbiAgICBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkuY2FsbChjb25zb2xlW2xldmVsXSwgY29uc29sZSwgYXJnc1dpdGhGb3JtYXQpO1xuICB9XG59XG5cbmlmICghUmVhY3QpIHtcbiAge1xuICAgIHRocm93IEVycm9yKCBcIlJlYWN0RE9NIHdhcyBsb2FkZWQgYmVmb3JlIFJlYWN0LiBNYWtlIHN1cmUgeW91IGxvYWQgdGhlIFJlYWN0IHBhY2thZ2UgYmVmb3JlIGxvYWRpbmcgUmVhY3RET00uXCIgKTtcbiAgfVxufVxuXG52YXIgRnVuY3Rpb25Db21wb25lbnQgPSAwO1xudmFyIENsYXNzQ29tcG9uZW50ID0gMTtcbnZhciBJbmRldGVybWluYXRlQ29tcG9uZW50ID0gMjsgLy8gQmVmb3JlIHdlIGtub3cgd2hldGhlciBpdCBpcyBmdW5jdGlvbiBvciBjbGFzc1xuXG52YXIgSG9zdFJvb3QgPSAzOyAvLyBSb290IG9mIGEgaG9zdCB0cmVlLiBDb3VsZCBiZSBuZXN0ZWQgaW5zaWRlIGFub3RoZXIgbm9kZS5cblxudmFyIEhvc3RQb3J0YWwgPSA0OyAvLyBBIHN1YnRyZWUuIENvdWxkIGJlIGFuIGVudHJ5IHBvaW50IHRvIGEgZGlmZmVyZW50IHJlbmRlcmVyLlxuXG52YXIgSG9zdENvbXBvbmVudCA9IDU7XG52YXIgSG9zdFRleHQgPSA2O1xudmFyIEZyYWdtZW50ID0gNztcbnZhciBNb2RlID0gODtcbnZhciBDb250ZXh0Q29uc3VtZXIgPSA5O1xudmFyIENvbnRleHRQcm92aWRlciA9IDEwO1xudmFyIEZvcndhcmRSZWYgPSAxMTtcbnZhciBQcm9maWxlciA9IDEyO1xudmFyIFN1c3BlbnNlQ29tcG9uZW50ID0gMTM7XG52YXIgTWVtb0NvbXBvbmVudCA9IDE0O1xudmFyIFNpbXBsZU1lbW9Db21wb25lbnQgPSAxNTtcbnZhciBMYXp5Q29tcG9uZW50ID0gMTY7XG52YXIgSW5jb21wbGV0ZUNsYXNzQ29tcG9uZW50ID0gMTc7XG52YXIgRGVoeWRyYXRlZEZyYWdtZW50ID0gMTg7XG52YXIgU3VzcGVuc2VMaXN0Q29tcG9uZW50ID0gMTk7XG52YXIgRnVuZGFtZW50YWxDb21wb25lbnQgPSAyMDtcbnZhciBTY29wZUNvbXBvbmVudCA9IDIxO1xudmFyIEJsb2NrID0gMjI7XG52YXIgT2Zmc2NyZWVuQ29tcG9uZW50ID0gMjM7XG52YXIgTGVnYWN5SGlkZGVuQ29tcG9uZW50ID0gMjQ7XG5cbi8vIEZpbHRlciBjZXJ0YWluIERPTSBhdHRyaWJ1dGVzIChlLmcuIHNyYywgaHJlZikgaWYgdGhlaXIgdmFsdWVzIGFyZSBlbXB0eSBzdHJpbmdzLlxuXG52YXIgZW5hYmxlUHJvZmlsZXJUaW1lciA9IHRydWU7IC8vIFJlY29yZCBkdXJhdGlvbnMgZm9yIGNvbW1pdCBhbmQgcGFzc2l2ZSBlZmZlY3RzIHBoYXNlcy5cblxudmFyIGVuYWJsZUZ1bmRhbWVudGFsQVBJID0gZmFsc2U7IC8vIEV4cGVyaW1lbnRhbCBTY29wZSBzdXBwb3J0LlxudmFyIGVuYWJsZU5ld1JlY29uY2lsZXIgPSBmYWxzZTsgLy8gRXJyb3JzIHRoYXQgYXJlIHRocm93biB3aGlsZSB1bm1vdW50aW5nIChvciBhZnRlciBpbiB0aGUgY2FzZSBvZiBwYXNzaXZlIGVmZmVjdHMpXG52YXIgd2FybkFib3V0U3RyaW5nUmVmcyA9IGZhbHNlO1xuXG52YXIgYWxsTmF0aXZlRXZlbnRzID0gbmV3IFNldCgpO1xuLyoqXG4gKiBNYXBwaW5nIGZyb20gcmVnaXN0cmF0aW9uIG5hbWUgdG8gZXZlbnQgbmFtZVxuICovXG5cblxudmFyIHJlZ2lzdHJhdGlvbk5hbWVEZXBlbmRlbmNpZXMgPSB7fTtcbi8qKlxuICogTWFwcGluZyBmcm9tIGxvd2VyY2FzZSByZWdpc3RyYXRpb24gbmFtZXMgdG8gdGhlIHByb3Blcmx5IGNhc2VkIHZlcnNpb24sXG4gKiB1c2VkIHRvIHdhcm4gaW4gdGhlIGNhc2Ugb2YgbWlzc2luZyBldmVudCBoYW5kbGVycy4gQXZhaWxhYmxlXG4gKiBvbmx5IGluIHRydWUuXG4gKiBAdHlwZSB7T2JqZWN0fVxuICovXG5cbnZhciBwb3NzaWJsZVJlZ2lzdHJhdGlvbk5hbWVzID0gIHt9IDsgLy8gVHJ1c3QgdGhlIGRldmVsb3BlciB0byBvbmx5IHVzZSBwb3NzaWJsZVJlZ2lzdHJhdGlvbk5hbWVzIGluIHRydWVcblxuZnVuY3Rpb24gcmVnaXN0ZXJUd29QaGFzZUV2ZW50KHJlZ2lzdHJhdGlvbk5hbWUsIGRlcGVuZGVuY2llcykge1xuICByZWdpc3RlckRpcmVjdEV2ZW50KHJlZ2lzdHJhdGlvbk5hbWUsIGRlcGVuZGVuY2llcyk7XG4gIHJlZ2lzdGVyRGlyZWN0RXZlbnQocmVnaXN0cmF0aW9uTmFtZSArICdDYXB0dXJlJywgZGVwZW5kZW5jaWVzKTtcbn1cbmZ1bmN0aW9uIHJlZ2lzdGVyRGlyZWN0RXZlbnQocmVnaXN0cmF0aW9uTmFtZSwgZGVwZW5kZW5jaWVzKSB7XG4gIHtcbiAgICBpZiAocmVnaXN0cmF0aW9uTmFtZURlcGVuZGVuY2llc1tyZWdpc3RyYXRpb25OYW1lXSkge1xuICAgICAgZXJyb3IoJ0V2ZW50UmVnaXN0cnk6IE1vcmUgdGhhbiBvbmUgcGx1Z2luIGF0dGVtcHRlZCB0byBwdWJsaXNoIHRoZSBzYW1lICcgKyAncmVnaXN0cmF0aW9uIG5hbWUsIGAlc2AuJywgcmVnaXN0cmF0aW9uTmFtZSk7XG4gICAgfVxuICB9XG5cbiAgcmVnaXN0cmF0aW9uTmFtZURlcGVuZGVuY2llc1tyZWdpc3RyYXRpb25OYW1lXSA9IGRlcGVuZGVuY2llcztcblxuICB7XG4gICAgdmFyIGxvd2VyQ2FzZWROYW1lID0gcmVnaXN0cmF0aW9uTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgIHBvc3NpYmxlUmVnaXN0cmF0aW9uTmFtZXNbbG93ZXJDYXNlZE5hbWVdID0gcmVnaXN0cmF0aW9uTmFtZTtcblxuICAgIGlmIChyZWdpc3RyYXRpb25OYW1lID09PSAnb25Eb3VibGVDbGljaycpIHtcbiAgICAgIHBvc3NpYmxlUmVnaXN0cmF0aW9uTmFtZXMub25kYmxjbGljayA9IHJlZ2lzdHJhdGlvbk5hbWU7XG4gICAgfVxuICB9XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBkZXBlbmRlbmNpZXMubGVuZ3RoOyBpKyspIHtcbiAgICBhbGxOYXRpdmVFdmVudHMuYWRkKGRlcGVuZGVuY2llc1tpXSk7XG4gIH1cbn1cblxudmFyIGNhblVzZURPTSA9ICEhKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiB3aW5kb3cuZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiB3aW5kb3cuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCAhPT0gJ3VuZGVmaW5lZCcpO1xuXG4vLyBBIHJlc2VydmVkIGF0dHJpYnV0ZS5cbi8vIEl0IGlzIGhhbmRsZWQgYnkgUmVhY3Qgc2VwYXJhdGVseSBhbmQgc2hvdWxkbid0IGJlIHdyaXR0ZW4gdG8gdGhlIERPTS5cbnZhciBSRVNFUlZFRCA9IDA7IC8vIEEgc2ltcGxlIHN0cmluZyBhdHRyaWJ1dGUuXG4vLyBBdHRyaWJ1dGVzIHRoYXQgYXJlbid0IGluIHRoZSBmaWx0ZXIgYXJlIHByZXN1bWVkIHRvIGhhdmUgdGhpcyB0eXBlLlxuXG52YXIgU1RSSU5HID0gMTsgLy8gQSBzdHJpbmcgYXR0cmlidXRlIHRoYXQgYWNjZXB0cyBib29sZWFucyBpbiBSZWFjdC4gSW4gSFRNTCwgdGhlc2UgYXJlIGNhbGxlZFxuLy8gXCJlbnVtZXJhdGVkXCIgYXR0cmlidXRlcyB3aXRoIFwidHJ1ZVwiIGFuZCBcImZhbHNlXCIgYXMgcG9zc2libGUgdmFsdWVzLlxuLy8gV2hlbiB0cnVlLCBpdCBzaG91bGQgYmUgc2V0IHRvIGEgXCJ0cnVlXCIgc3RyaW5nLlxuLy8gV2hlbiBmYWxzZSwgaXQgc2hvdWxkIGJlIHNldCB0byBhIFwiZmFsc2VcIiBzdHJpbmcuXG5cbnZhciBCT09MRUFOSVNIX1NUUklORyA9IDI7IC8vIEEgcmVhbCBib29sZWFuIGF0dHJpYnV0ZS5cbi8vIFdoZW4gdHJ1ZSwgaXQgc2hvdWxkIGJlIHByZXNlbnQgKHNldCBlaXRoZXIgdG8gYW4gZW1wdHkgc3RyaW5nIG9yIGl0cyBuYW1lKS5cbi8vIFdoZW4gZmFsc2UsIGl0IHNob3VsZCBiZSBvbWl0dGVkLlxuXG52YXIgQk9PTEVBTiA9IDM7IC8vIEFuIGF0dHJpYnV0ZSB0aGF0IGNhbiBiZSB1c2VkIGFzIGEgZmxhZyBhcyB3ZWxsIGFzIHdpdGggYSB2YWx1ZS5cbi8vIFdoZW4gdHJ1ZSwgaXQgc2hvdWxkIGJlIHByZXNlbnQgKHNldCBlaXRoZXIgdG8gYW4gZW1wdHkgc3RyaW5nIG9yIGl0cyBuYW1lKS5cbi8vIFdoZW4gZmFsc2UsIGl0IHNob3VsZCBiZSBvbWl0dGVkLlxuLy8gRm9yIGFueSBvdGhlciB2YWx1ZSwgc2hvdWxkIGJlIHByZXNlbnQgd2l0aCB0aGF0IHZhbHVlLlxuXG52YXIgT1ZFUkxPQURFRF9CT09MRUFOID0gNDsgLy8gQW4gYXR0cmlidXRlIHRoYXQgbXVzdCBiZSBudW1lcmljIG9yIHBhcnNlIGFzIGEgbnVtZXJpYy5cbi8vIFdoZW4gZmFsc3ksIGl0IHNob3VsZCBiZSByZW1vdmVkLlxuXG52YXIgTlVNRVJJQyA9IDU7IC8vIEFuIGF0dHJpYnV0ZSB0aGF0IG11c3QgYmUgcG9zaXRpdmUgbnVtZXJpYyBvciBwYXJzZSBhcyBhIHBvc2l0aXZlIG51bWVyaWMuXG4vLyBXaGVuIGZhbHN5LCBpdCBzaG91bGQgYmUgcmVtb3ZlZC5cblxudmFyIFBPU0lUSVZFX05VTUVSSUMgPSA2O1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuICovXG52YXIgQVRUUklCVVRFX05BTUVfU1RBUlRfQ0hBUiA9IFwiOkEtWl9hLXpcXFxcdTAwQzAtXFxcXHUwMEQ2XFxcXHUwMEQ4LVxcXFx1MDBGNlxcXFx1MDBGOC1cXFxcdTAyRkZcXFxcdTAzNzAtXFxcXHUwMzdEXFxcXHUwMzdGLVxcXFx1MUZGRlxcXFx1MjAwQy1cXFxcdTIwMERcXFxcdTIwNzAtXFxcXHUyMThGXFxcXHUyQzAwLVxcXFx1MkZFRlxcXFx1MzAwMS1cXFxcdUQ3RkZcXFxcdUY5MDAtXFxcXHVGRENGXFxcXHVGREYwLVxcXFx1RkZGRFwiO1xuLyogZXNsaW50LWVuYWJsZSBtYXgtbGVuICovXG5cbnZhciBBVFRSSUJVVEVfTkFNRV9DSEFSID0gQVRUUklCVVRFX05BTUVfU1RBUlRfQ0hBUiArIFwiXFxcXC0uMC05XFxcXHUwMEI3XFxcXHUwMzAwLVxcXFx1MDM2RlxcXFx1MjAzRi1cXFxcdTIwNDBcIjtcbnZhciBST09UX0FUVFJJQlVURV9OQU1FID0gJ2RhdGEtcmVhY3Ryb290JztcbnZhciBWQUxJRF9BVFRSSUJVVEVfTkFNRV9SRUdFWCA9IG5ldyBSZWdFeHAoJ15bJyArIEFUVFJJQlVURV9OQU1FX1NUQVJUX0NIQVIgKyAnXVsnICsgQVRUUklCVVRFX05BTUVfQ0hBUiArICddKiQnKTtcbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgaWxsZWdhbEF0dHJpYnV0ZU5hbWVDYWNoZSA9IHt9O1xudmFyIHZhbGlkYXRlZEF0dHJpYnV0ZU5hbWVDYWNoZSA9IHt9O1xuZnVuY3Rpb24gaXNBdHRyaWJ1dGVOYW1lU2FmZShhdHRyaWJ1dGVOYW1lKSB7XG4gIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbGlkYXRlZEF0dHJpYnV0ZU5hbWVDYWNoZSwgYXR0cmlidXRlTmFtZSkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGlsbGVnYWxBdHRyaWJ1dGVOYW1lQ2FjaGUsIGF0dHJpYnV0ZU5hbWUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKFZBTElEX0FUVFJJQlVURV9OQU1FX1JFR0VYLnRlc3QoYXR0cmlidXRlTmFtZSkpIHtcbiAgICB2YWxpZGF0ZWRBdHRyaWJ1dGVOYW1lQ2FjaGVbYXR0cmlidXRlTmFtZV0gPSB0cnVlO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWxsZWdhbEF0dHJpYnV0ZU5hbWVDYWNoZVthdHRyaWJ1dGVOYW1lXSA9IHRydWU7XG5cbiAge1xuICAgIGVycm9yKCdJbnZhbGlkIGF0dHJpYnV0ZSBuYW1lOiBgJXNgJywgYXR0cmlidXRlTmFtZSk7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBzaG91bGRJZ25vcmVBdHRyaWJ1dGUobmFtZSwgcHJvcGVydHlJbmZvLCBpc0N1c3RvbUNvbXBvbmVudFRhZykge1xuICBpZiAocHJvcGVydHlJbmZvICE9PSBudWxsKSB7XG4gICAgcmV0dXJuIHByb3BlcnR5SW5mby50eXBlID09PSBSRVNFUlZFRDtcbiAgfVxuXG4gIGlmIChpc0N1c3RvbUNvbXBvbmVudFRhZykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChuYW1lLmxlbmd0aCA+IDIgJiYgKG5hbWVbMF0gPT09ICdvJyB8fCBuYW1lWzBdID09PSAnTycpICYmIChuYW1lWzFdID09PSAnbicgfHwgbmFtZVsxXSA9PT0gJ04nKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gc2hvdWxkUmVtb3ZlQXR0cmlidXRlV2l0aFdhcm5pbmcobmFtZSwgdmFsdWUsIHByb3BlcnR5SW5mbywgaXNDdXN0b21Db21wb25lbnRUYWcpIHtcbiAgaWYgKHByb3BlcnR5SW5mbyAhPT0gbnVsbCAmJiBwcm9wZXJ0eUluZm8udHlwZSA9PT0gUkVTRVJWRUQpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBzd2l0Y2ggKHR5cGVvZiB2YWx1ZSkge1xuICAgIGNhc2UgJ2Z1bmN0aW9uJzogLy8gJEZsb3dJc3N1ZSBzeW1ib2wgaXMgcGVyZmVjdGx5IHZhbGlkIGhlcmVcblxuICAgIGNhc2UgJ3N5bWJvbCc6XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgICByZXR1cm4gdHJ1ZTtcblxuICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAge1xuICAgICAgICBpZiAoaXNDdXN0b21Db21wb25lbnRUYWcpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocHJvcGVydHlJbmZvICE9PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuICFwcm9wZXJ0eUluZm8uYWNjZXB0c0Jvb2xlYW5zO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBwcmVmaXggPSBuYW1lLnRvTG93ZXJDYXNlKCkuc2xpY2UoMCwgNSk7XG4gICAgICAgICAgcmV0dXJuIHByZWZpeCAhPT0gJ2RhdGEtJyAmJiBwcmVmaXggIT09ICdhcmlhLSc7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cbmZ1bmN0aW9uIHNob3VsZFJlbW92ZUF0dHJpYnV0ZShuYW1lLCB2YWx1ZSwgcHJvcGVydHlJbmZvLCBpc0N1c3RvbUNvbXBvbmVudFRhZykge1xuICBpZiAodmFsdWUgPT09IG51bGwgfHwgdHlwZW9mIHZhbHVlID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKHNob3VsZFJlbW92ZUF0dHJpYnV0ZVdpdGhXYXJuaW5nKG5hbWUsIHZhbHVlLCBwcm9wZXJ0eUluZm8sIGlzQ3VzdG9tQ29tcG9uZW50VGFnKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKGlzQ3VzdG9tQ29tcG9uZW50VGFnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKHByb3BlcnR5SW5mbyAhPT0gbnVsbCkge1xuXG4gICAgc3dpdGNoIChwcm9wZXJ0eUluZm8udHlwZSkge1xuICAgICAgY2FzZSBCT09MRUFOOlxuICAgICAgICByZXR1cm4gIXZhbHVlO1xuXG4gICAgICBjYXNlIE9WRVJMT0FERURfQk9PTEVBTjpcbiAgICAgICAgcmV0dXJuIHZhbHVlID09PSBmYWxzZTtcblxuICAgICAgY2FzZSBOVU1FUklDOlxuICAgICAgICByZXR1cm4gaXNOYU4odmFsdWUpO1xuXG4gICAgICBjYXNlIFBPU0lUSVZFX05VTUVSSUM6XG4gICAgICAgIHJldHVybiBpc05hTih2YWx1ZSkgfHwgdmFsdWUgPCAxO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGdldFByb3BlcnR5SW5mbyhuYW1lKSB7XG4gIHJldHVybiBwcm9wZXJ0aWVzLmhhc093blByb3BlcnR5KG5hbWUpID8gcHJvcGVydGllc1tuYW1lXSA6IG51bGw7XG59XG5cbmZ1bmN0aW9uIFByb3BlcnR5SW5mb1JlY29yZChuYW1lLCB0eXBlLCBtdXN0VXNlUHJvcGVydHksIGF0dHJpYnV0ZU5hbWUsIGF0dHJpYnV0ZU5hbWVzcGFjZSwgc2FuaXRpemVVUkwsIHJlbW92ZUVtcHR5U3RyaW5nKSB7XG4gIHRoaXMuYWNjZXB0c0Jvb2xlYW5zID0gdHlwZSA9PT0gQk9PTEVBTklTSF9TVFJJTkcgfHwgdHlwZSA9PT0gQk9PTEVBTiB8fCB0eXBlID09PSBPVkVSTE9BREVEX0JPT0xFQU47XG4gIHRoaXMuYXR0cmlidXRlTmFtZSA9IGF0dHJpYnV0ZU5hbWU7XG4gIHRoaXMuYXR0cmlidXRlTmFtZXNwYWNlID0gYXR0cmlidXRlTmFtZXNwYWNlO1xuICB0aGlzLm11c3RVc2VQcm9wZXJ0eSA9IG11c3RVc2VQcm9wZXJ0eTtcbiAgdGhpcy5wcm9wZXJ0eU5hbWUgPSBuYW1lO1xuICB0aGlzLnR5cGUgPSB0eXBlO1xuICB0aGlzLnNhbml0aXplVVJMID0gc2FuaXRpemVVUkw7XG4gIHRoaXMucmVtb3ZlRW1wdHlTdHJpbmcgPSByZW1vdmVFbXB0eVN0cmluZztcbn0gLy8gV2hlbiBhZGRpbmcgYXR0cmlidXRlcyB0byB0aGlzIGxpc3QsIGJlIHN1cmUgdG8gYWxzbyBhZGQgdGhlbSB0b1xuLy8gdGhlIGBwb3NzaWJsZVN0YW5kYXJkTmFtZXNgIG1vZHVsZSB0byBlbnN1cmUgY2FzaW5nIGFuZCBpbmNvcnJlY3Rcbi8vIG5hbWUgd2FybmluZ3MuXG5cblxudmFyIHByb3BlcnRpZXMgPSB7fTsgLy8gVGhlc2UgcHJvcHMgYXJlIHJlc2VydmVkIGJ5IFJlYWN0LiBUaGV5IHNob3VsZG4ndCBiZSB3cml0dGVuIHRvIHRoZSBET00uXG5cbnZhciByZXNlcnZlZFByb3BzID0gWydjaGlsZHJlbicsICdkYW5nZXJvdXNseVNldElubmVySFRNTCcsIC8vIFRPRE86IFRoaXMgcHJldmVudHMgdGhlIGFzc2lnbm1lbnQgb2YgZGVmYXVsdFZhbHVlIHRvIHJlZ3VsYXJcbi8vIGVsZW1lbnRzIChub3QganVzdCBpbnB1dHMpLiBOb3cgdGhhdCBSZWFjdERPTUlucHV0IGFzc2lnbnMgdG8gdGhlXG4vLyBkZWZhdWx0VmFsdWUgcHJvcGVydHkgLS0gZG8gd2UgbmVlZCB0aGlzP1xuJ2RlZmF1bHRWYWx1ZScsICdkZWZhdWx0Q2hlY2tlZCcsICdpbm5lckhUTUwnLCAnc3VwcHJlc3NDb250ZW50RWRpdGFibGVXYXJuaW5nJywgJ3N1cHByZXNzSHlkcmF0aW9uV2FybmluZycsICdzdHlsZSddO1xucmVzZXJ2ZWRQcm9wcy5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gIHByb3BlcnRpZXNbbmFtZV0gPSBuZXcgUHJvcGVydHlJbmZvUmVjb3JkKG5hbWUsIFJFU0VSVkVELCBmYWxzZSwgLy8gbXVzdFVzZVByb3BlcnR5XG4gIG5hbWUsIC8vIGF0dHJpYnV0ZU5hbWVcbiAgbnVsbCwgLy8gYXR0cmlidXRlTmFtZXNwYWNlXG4gIGZhbHNlLCAvLyBzYW5pdGl6ZVVSTFxuICBmYWxzZSk7XG59KTsgLy8gQSBmZXcgUmVhY3Qgc3RyaW5nIGF0dHJpYnV0ZXMgaGF2ZSBhIGRpZmZlcmVudCBuYW1lLlxuLy8gVGhpcyBpcyBhIG1hcHBpbmcgZnJvbSBSZWFjdCBwcm9wIG5hbWVzIHRvIHRoZSBhdHRyaWJ1dGUgbmFtZXMuXG5cbltbJ2FjY2VwdENoYXJzZXQnLCAnYWNjZXB0LWNoYXJzZXQnXSwgWydjbGFzc05hbWUnLCAnY2xhc3MnXSwgWydodG1sRm9yJywgJ2ZvciddLCBbJ2h0dHBFcXVpdicsICdodHRwLWVxdWl2J11dLmZvckVhY2goZnVuY3Rpb24gKF9yZWYpIHtcbiAgdmFyIG5hbWUgPSBfcmVmWzBdLFxuICAgICAgYXR0cmlidXRlTmFtZSA9IF9yZWZbMV07XG4gIHByb3BlcnRpZXNbbmFtZV0gPSBuZXcgUHJvcGVydHlJbmZvUmVjb3JkKG5hbWUsIFNUUklORywgZmFsc2UsIC8vIG11c3RVc2VQcm9wZXJ0eVxuICBhdHRyaWJ1dGVOYW1lLCAvLyBhdHRyaWJ1dGVOYW1lXG4gIG51bGwsIC8vIGF0dHJpYnV0ZU5hbWVzcGFjZVxuICBmYWxzZSwgLy8gc2FuaXRpemVVUkxcbiAgZmFsc2UpO1xufSk7IC8vIFRoZXNlIGFyZSBcImVudW1lcmF0ZWRcIiBIVE1MIGF0dHJpYnV0ZXMgdGhhdCBhY2NlcHQgXCJ0cnVlXCIgYW5kIFwiZmFsc2VcIi5cbi8vIEluIFJlYWN0LCB3ZSBsZXQgdXNlcnMgcGFzcyBgdHJ1ZWAgYW5kIGBmYWxzZWAgZXZlbiB0aG91Z2ggdGVjaG5pY2FsbHlcbi8vIHRoZXNlIGFyZW4ndCBib29sZWFuIGF0dHJpYnV0ZXMgKHRoZXkgYXJlIGNvZXJjZWQgdG8gc3RyaW5ncykuXG5cblsnY29udGVudEVkaXRhYmxlJywgJ2RyYWdnYWJsZScsICdzcGVsbENoZWNrJywgJ3ZhbHVlJ10uZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICBwcm9wZXJ0aWVzW25hbWVdID0gbmV3IFByb3BlcnR5SW5mb1JlY29yZChuYW1lLCBCT09MRUFOSVNIX1NUUklORywgZmFsc2UsIC8vIG11c3RVc2VQcm9wZXJ0eVxuICBuYW1lLnRvTG93ZXJDYXNlKCksIC8vIGF0dHJpYnV0ZU5hbWVcbiAgbnVsbCwgLy8gYXR0cmlidXRlTmFtZXNwYWNlXG4gIGZhbHNlLCAvLyBzYW5pdGl6ZVVSTFxuICBmYWxzZSk7XG59KTsgLy8gVGhlc2UgYXJlIFwiZW51bWVyYXRlZFwiIFNWRyBhdHRyaWJ1dGVzIHRoYXQgYWNjZXB0IFwidHJ1ZVwiIGFuZCBcImZhbHNlXCIuXG4vLyBJbiBSZWFjdCwgd2UgbGV0IHVzZXJzIHBhc3MgYHRydWVgIGFuZCBgZmFsc2VgIGV2ZW4gdGhvdWdoIHRlY2huaWNhbGx5XG4vLyB0aGVzZSBhcmVuJ3QgYm9vbGVhbiBhdHRyaWJ1dGVzICh0aGV5IGFyZSBjb2VyY2VkIHRvIHN0cmluZ3MpLlxuLy8gU2luY2UgdGhlc2UgYXJlIFNWRyBhdHRyaWJ1dGVzLCB0aGVpciBhdHRyaWJ1dGUgbmFtZXMgYXJlIGNhc2Utc2Vuc2l0aXZlLlxuXG5bJ2F1dG9SZXZlcnNlJywgJ2V4dGVybmFsUmVzb3VyY2VzUmVxdWlyZWQnLCAnZm9jdXNhYmxlJywgJ3ByZXNlcnZlQWxwaGEnXS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gIHByb3BlcnRpZXNbbmFtZV0gPSBuZXcgUHJvcGVydHlJbmZvUmVjb3JkKG5hbWUsIEJPT0xFQU5JU0hfU1RSSU5HLCBmYWxzZSwgLy8gbXVzdFVzZVByb3BlcnR5XG4gIG5hbWUsIC8vIGF0dHJpYnV0ZU5hbWVcbiAgbnVsbCwgLy8gYXR0cmlidXRlTmFtZXNwYWNlXG4gIGZhbHNlLCAvLyBzYW5pdGl6ZVVSTFxuICBmYWxzZSk7XG59KTsgLy8gVGhlc2UgYXJlIEhUTUwgYm9vbGVhbiBhdHRyaWJ1dGVzLlxuXG5bJ2FsbG93RnVsbFNjcmVlbicsICdhc3luYycsIC8vIE5vdGU6IHRoZXJlIGlzIGEgc3BlY2lhbCBjYXNlIHRoYXQgcHJldmVudHMgaXQgZnJvbSBiZWluZyB3cml0dGVuIHRvIHRoZSBET01cbi8vIG9uIHRoZSBjbGllbnQgc2lkZSBiZWNhdXNlIHRoZSBicm93c2VycyBhcmUgaW5jb25zaXN0ZW50LiBJbnN0ZWFkIHdlIGNhbGwgZm9jdXMoKS5cbidhdXRvRm9jdXMnLCAnYXV0b1BsYXknLCAnY29udHJvbHMnLCAnZGVmYXVsdCcsICdkZWZlcicsICdkaXNhYmxlZCcsICdkaXNhYmxlUGljdHVyZUluUGljdHVyZScsICdkaXNhYmxlUmVtb3RlUGxheWJhY2snLCAnZm9ybU5vVmFsaWRhdGUnLCAnaGlkZGVuJywgJ2xvb3AnLCAnbm9Nb2R1bGUnLCAnbm9WYWxpZGF0ZScsICdvcGVuJywgJ3BsYXlzSW5saW5lJywgJ3JlYWRPbmx5JywgJ3JlcXVpcmVkJywgJ3JldmVyc2VkJywgJ3Njb3BlZCcsICdzZWFtbGVzcycsIC8vIE1pY3JvZGF0YVxuJ2l0ZW1TY29wZSddLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgcHJvcGVydGllc1tuYW1lXSA9IG5ldyBQcm9wZXJ0eUluZm9SZWNvcmQobmFtZSwgQk9PTEVBTiwgZmFsc2UsIC8vIG11c3RVc2VQcm9wZXJ0eVxuICBuYW1lLnRvTG93ZXJDYXNlKCksIC8vIGF0dHJpYnV0ZU5hbWVcbiAgbnVsbCwgLy8gYXR0cmlidXRlTmFtZXNwYWNlXG4gIGZhbHNlLCAvLyBzYW5pdGl6ZVVSTFxuICBmYWxzZSk7XG59KTsgLy8gVGhlc2UgYXJlIHRoZSBmZXcgUmVhY3QgcHJvcHMgdGhhdCB3ZSBzZXQgYXMgRE9NIHByb3BlcnRpZXNcbi8vIHJhdGhlciB0aGFuIGF0dHJpYnV0ZXMuIFRoZXNlIGFyZSBhbGwgYm9vbGVhbnMuXG5cblsnY2hlY2tlZCcsIC8vIE5vdGU6IGBvcHRpb24uc2VsZWN0ZWRgIGlzIG5vdCB1cGRhdGVkIGlmIGBzZWxlY3QubXVsdGlwbGVgIGlzXG4vLyBkaXNhYmxlZCB3aXRoIGByZW1vdmVBdHRyaWJ1dGVgLiBXZSBoYXZlIHNwZWNpYWwgbG9naWMgZm9yIGhhbmRsaW5nIHRoaXMuXG4nbXVsdGlwbGUnLCAnbXV0ZWQnLCAnc2VsZWN0ZWQnIC8vIE5PVEU6IGlmIHlvdSBhZGQgYSBjYW1lbENhc2VkIHByb3AgdG8gdGhpcyBsaXN0LFxuLy8geW91J2xsIG5lZWQgdG8gc2V0IGF0dHJpYnV0ZU5hbWUgdG8gbmFtZS50b0xvd2VyQ2FzZSgpXG4vLyBpbnN0ZWFkIGluIHRoZSBhc3NpZ25tZW50IGJlbG93LlxuXS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gIHByb3BlcnRpZXNbbmFtZV0gPSBuZXcgUHJvcGVydHlJbmZvUmVjb3JkKG5hbWUsIEJPT0xFQU4sIHRydWUsIC8vIG11c3RVc2VQcm9wZXJ0eVxuICBuYW1lLCAvLyBhdHRyaWJ1dGVOYW1lXG4gIG51bGwsIC8vIGF0dHJpYnV0ZU5hbWVzcGFjZVxuICBmYWxzZSwgLy8gc2FuaXRpemVVUkxcbiAgZmFsc2UpO1xufSk7IC8vIFRoZXNlIGFyZSBIVE1MIGF0dHJpYnV0ZXMgdGhhdCBhcmUgXCJvdmVybG9hZGVkIGJvb2xlYW5zXCI6IHRoZXkgYmVoYXZlIGxpa2Vcbi8vIGJvb2xlYW5zLCBidXQgY2FuIGFsc28gYWNjZXB0IGEgc3RyaW5nIHZhbHVlLlxuXG5bJ2NhcHR1cmUnLCAnZG93bmxvYWQnIC8vIE5PVEU6IGlmIHlvdSBhZGQgYSBjYW1lbENhc2VkIHByb3AgdG8gdGhpcyBsaXN0LFxuLy8geW91J2xsIG5lZWQgdG8gc2V0IGF0dHJpYnV0ZU5hbWUgdG8gbmFtZS50b0xvd2VyQ2FzZSgpXG4vLyBpbnN0ZWFkIGluIHRoZSBhc3NpZ25tZW50IGJlbG93LlxuXS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gIHByb3BlcnRpZXNbbmFtZV0gPSBuZXcgUHJvcGVydHlJbmZvUmVjb3JkKG5hbWUsIE9WRVJMT0FERURfQk9PTEVBTiwgZmFsc2UsIC8vIG11c3RVc2VQcm9wZXJ0eVxuICBuYW1lLCAvLyBhdHRyaWJ1dGVOYW1lXG4gIG51bGwsIC8vIGF0dHJpYnV0ZU5hbWVzcGFjZVxuICBmYWxzZSwgLy8gc2FuaXRpemVVUkxcbiAgZmFsc2UpO1xufSk7IC8vIFRoZXNlIGFyZSBIVE1MIGF0dHJpYnV0ZXMgdGhhdCBtdXN0IGJlIHBvc2l0aXZlIG51bWJlcnMuXG5cblsnY29scycsICdyb3dzJywgJ3NpemUnLCAnc3BhbicgLy8gTk9URTogaWYgeW91IGFkZCBhIGNhbWVsQ2FzZWQgcHJvcCB0byB0aGlzIGxpc3QsXG4vLyB5b3UnbGwgbmVlZCB0byBzZXQgYXR0cmlidXRlTmFtZSB0byBuYW1lLnRvTG93ZXJDYXNlKClcbi8vIGluc3RlYWQgaW4gdGhlIGFzc2lnbm1lbnQgYmVsb3cuXG5dLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgcHJvcGVydGllc1tuYW1lXSA9IG5ldyBQcm9wZXJ0eUluZm9SZWNvcmQobmFtZSwgUE9TSVRJVkVfTlVNRVJJQywgZmFsc2UsIC8vIG11c3RVc2VQcm9wZXJ0eVxuICBuYW1lLCAvLyBhdHRyaWJ1dGVOYW1lXG4gIG51bGwsIC8vIGF0dHJpYnV0ZU5hbWVzcGFjZVxuICBmYWxzZSwgLy8gc2FuaXRpemVVUkxcbiAgZmFsc2UpO1xufSk7IC8vIFRoZXNlIGFyZSBIVE1MIGF0dHJpYnV0ZXMgdGhhdCBtdXN0IGJlIG51bWJlcnMuXG5cblsncm93U3BhbicsICdzdGFydCddLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgcHJvcGVydGllc1tuYW1lXSA9IG5ldyBQcm9wZXJ0eUluZm9SZWNvcmQobmFtZSwgTlVNRVJJQywgZmFsc2UsIC8vIG11c3RVc2VQcm9wZXJ0eVxuICBuYW1lLnRvTG93ZXJDYXNlKCksIC8vIGF0dHJpYnV0ZU5hbWVcbiAgbnVsbCwgLy8gYXR0cmlidXRlTmFtZXNwYWNlXG4gIGZhbHNlLCAvLyBzYW5pdGl6ZVVSTFxuICBmYWxzZSk7XG59KTtcbnZhciBDQU1FTElaRSA9IC9bXFwtXFw6XShbYS16XSkvZztcblxudmFyIGNhcGl0YWxpemUgPSBmdW5jdGlvbiAodG9rZW4pIHtcbiAgcmV0dXJuIHRva2VuWzFdLnRvVXBwZXJDYXNlKCk7XG59OyAvLyBUaGlzIGlzIGEgbGlzdCBvZiBhbGwgU1ZHIGF0dHJpYnV0ZXMgdGhhdCBuZWVkIHNwZWNpYWwgY2FzaW5nLCBuYW1lc3BhY2luZyxcbi8vIG9yIGJvb2xlYW4gdmFsdWUgYXNzaWdubWVudC4gUmVndWxhciBhdHRyaWJ1dGVzIHRoYXQganVzdCBhY2NlcHQgc3RyaW5nc1xuLy8gYW5kIGhhdmUgdGhlIHNhbWUgbmFtZXMgYXJlIG9taXR0ZWQsIGp1c3QgbGlrZSBpbiB0aGUgSFRNTCBhdHRyaWJ1dGUgZmlsdGVyLlxuLy8gU29tZSBvZiB0aGVzZSBhdHRyaWJ1dGVzIGNhbiBiZSBoYXJkIHRvIGZpbmQuIFRoaXMgbGlzdCB3YXMgY3JlYXRlZCBieVxuLy8gc2NyYXBpbmcgdGhlIE1ETiBkb2N1bWVudGF0aW9uLlxuXG5cblsnYWNjZW50LWhlaWdodCcsICdhbGlnbm1lbnQtYmFzZWxpbmUnLCAnYXJhYmljLWZvcm0nLCAnYmFzZWxpbmUtc2hpZnQnLCAnY2FwLWhlaWdodCcsICdjbGlwLXBhdGgnLCAnY2xpcC1ydWxlJywgJ2NvbG9yLWludGVycG9sYXRpb24nLCAnY29sb3ItaW50ZXJwb2xhdGlvbi1maWx0ZXJzJywgJ2NvbG9yLXByb2ZpbGUnLCAnY29sb3ItcmVuZGVyaW5nJywgJ2RvbWluYW50LWJhc2VsaW5lJywgJ2VuYWJsZS1iYWNrZ3JvdW5kJywgJ2ZpbGwtb3BhY2l0eScsICdmaWxsLXJ1bGUnLCAnZmxvb2QtY29sb3InLCAnZmxvb2Qtb3BhY2l0eScsICdmb250LWZhbWlseScsICdmb250LXNpemUnLCAnZm9udC1zaXplLWFkanVzdCcsICdmb250LXN0cmV0Y2gnLCAnZm9udC1zdHlsZScsICdmb250LXZhcmlhbnQnLCAnZm9udC13ZWlnaHQnLCAnZ2x5cGgtbmFtZScsICdnbHlwaC1vcmllbnRhdGlvbi1ob3Jpem9udGFsJywgJ2dseXBoLW9yaWVudGF0aW9uLXZlcnRpY2FsJywgJ2hvcml6LWFkdi14JywgJ2hvcml6LW9yaWdpbi14JywgJ2ltYWdlLXJlbmRlcmluZycsICdsZXR0ZXItc3BhY2luZycsICdsaWdodGluZy1jb2xvcicsICdtYXJrZXItZW5kJywgJ21hcmtlci1taWQnLCAnbWFya2VyLXN0YXJ0JywgJ292ZXJsaW5lLXBvc2l0aW9uJywgJ292ZXJsaW5lLXRoaWNrbmVzcycsICdwYWludC1vcmRlcicsICdwYW5vc2UtMScsICdwb2ludGVyLWV2ZW50cycsICdyZW5kZXJpbmctaW50ZW50JywgJ3NoYXBlLXJlbmRlcmluZycsICdzdG9wLWNvbG9yJywgJ3N0b3Atb3BhY2l0eScsICdzdHJpa2V0aHJvdWdoLXBvc2l0aW9uJywgJ3N0cmlrZXRocm91Z2gtdGhpY2tuZXNzJywgJ3N0cm9rZS1kYXNoYXJyYXknLCAnc3Ryb2tlLWRhc2hvZmZzZXQnLCAnc3Ryb2tlLWxpbmVjYXAnLCAnc3Ryb2tlLWxpbmVqb2luJywgJ3N0cm9rZS1taXRlcmxpbWl0JywgJ3N0cm9rZS1vcGFjaXR5JywgJ3N0cm9rZS13aWR0aCcsICd0ZXh0LWFuY2hvcicsICd0ZXh0LWRlY29yYXRpb24nLCAndGV4dC1yZW5kZXJpbmcnLCAndW5kZXJsaW5lLXBvc2l0aW9uJywgJ3VuZGVybGluZS10aGlja25lc3MnLCAndW5pY29kZS1iaWRpJywgJ3VuaWNvZGUtcmFuZ2UnLCAndW5pdHMtcGVyLWVtJywgJ3YtYWxwaGFiZXRpYycsICd2LWhhbmdpbmcnLCAndi1pZGVvZ3JhcGhpYycsICd2LW1hdGhlbWF0aWNhbCcsICd2ZWN0b3ItZWZmZWN0JywgJ3ZlcnQtYWR2LXknLCAndmVydC1vcmlnaW4teCcsICd2ZXJ0LW9yaWdpbi15JywgJ3dvcmQtc3BhY2luZycsICd3cml0aW5nLW1vZGUnLCAneG1sbnM6eGxpbmsnLCAneC1oZWlnaHQnIC8vIE5PVEU6IGlmIHlvdSBhZGQgYSBjYW1lbENhc2VkIHByb3AgdG8gdGhpcyBsaXN0LFxuLy8geW91J2xsIG5lZWQgdG8gc2V0IGF0dHJpYnV0ZU5hbWUgdG8gbmFtZS50b0xvd2VyQ2FzZSgpXG4vLyBpbnN0ZWFkIGluIHRoZSBhc3NpZ25tZW50IGJlbG93LlxuXS5mb3JFYWNoKGZ1bmN0aW9uIChhdHRyaWJ1dGVOYW1lKSB7XG4gIHZhciBuYW1lID0gYXR0cmlidXRlTmFtZS5yZXBsYWNlKENBTUVMSVpFLCBjYXBpdGFsaXplKTtcbiAgcHJvcGVydGllc1tuYW1lXSA9IG5ldyBQcm9wZXJ0eUluZm9SZWNvcmQobmFtZSwgU1RSSU5HLCBmYWxzZSwgLy8gbXVzdFVzZVByb3BlcnR5XG4gIGF0dHJpYnV0ZU5hbWUsIG51bGwsIC8vIGF0dHJpYnV0ZU5hbWVzcGFjZVxuICBmYWxzZSwgLy8gc2FuaXRpemVVUkxcbiAgZmFsc2UpO1xufSk7IC8vIFN0cmluZyBTVkcgYXR0cmlidXRlcyB3aXRoIHRoZSB4bGluayBuYW1lc3BhY2UuXG5cblsneGxpbms6YWN0dWF0ZScsICd4bGluazphcmNyb2xlJywgJ3hsaW5rOnJvbGUnLCAneGxpbms6c2hvdycsICd4bGluazp0aXRsZScsICd4bGluazp0eXBlJyAvLyBOT1RFOiBpZiB5b3UgYWRkIGEgY2FtZWxDYXNlZCBwcm9wIHRvIHRoaXMgbGlzdCxcbi8vIHlvdSdsbCBuZWVkIHRvIHNldCBhdHRyaWJ1dGVOYW1lIHRvIG5hbWUudG9Mb3dlckNhc2UoKVxuLy8gaW5zdGVhZCBpbiB0aGUgYXNzaWdubWVudCBiZWxvdy5cbl0uZm9yRWFjaChmdW5jdGlvbiAoYXR0cmlidXRlTmFtZSkge1xuICB2YXIgbmFtZSA9IGF0dHJpYnV0ZU5hbWUucmVwbGFjZShDQU1FTElaRSwgY2FwaXRhbGl6ZSk7XG4gIHByb3BlcnRpZXNbbmFtZV0gPSBuZXcgUHJvcGVydHlJbmZvUmVjb3JkKG5hbWUsIFNUUklORywgZmFsc2UsIC8vIG11c3RVc2VQcm9wZXJ0eVxuICBhdHRyaWJ1dGVOYW1lLCAnaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycsIGZhbHNlLCAvLyBzYW5pdGl6ZVVSTFxuICBmYWxzZSk7XG59KTsgLy8gU3RyaW5nIFNWRyBhdHRyaWJ1dGVzIHdpdGggdGhlIHhtbCBuYW1lc3BhY2UuXG5cblsneG1sOmJhc2UnLCAneG1sOmxhbmcnLCAneG1sOnNwYWNlJyAvLyBOT1RFOiBpZiB5b3UgYWRkIGEgY2FtZWxDYXNlZCBwcm9wIHRvIHRoaXMgbGlzdCxcbi8vIHlvdSdsbCBuZWVkIHRvIHNldCBhdHRyaWJ1dGVOYW1lIHRvIG5hbWUudG9Mb3dlckNhc2UoKVxuLy8gaW5zdGVhZCBpbiB0aGUgYXNzaWdubWVudCBiZWxvdy5cbl0uZm9yRWFjaChmdW5jdGlvbiAoYXR0cmlidXRlTmFtZSkge1xuICB2YXIgbmFtZSA9IGF0dHJpYnV0ZU5hbWUucmVwbGFjZShDQU1FTElaRSwgY2FwaXRhbGl6ZSk7XG4gIHByb3BlcnRpZXNbbmFtZV0gPSBuZXcgUHJvcGVydHlJbmZvUmVjb3JkKG5hbWUsIFNUUklORywgZmFsc2UsIC8vIG11c3RVc2VQcm9wZXJ0eVxuICBhdHRyaWJ1dGVOYW1lLCAnaHR0cDovL3d3dy53My5vcmcvWE1MLzE5OTgvbmFtZXNwYWNlJywgZmFsc2UsIC8vIHNhbml0aXplVVJMXG4gIGZhbHNlKTtcbn0pOyAvLyBUaGVzZSBhdHRyaWJ1dGUgZXhpc3RzIGJvdGggaW4gSFRNTCBhbmQgU1ZHLlxuLy8gVGhlIGF0dHJpYnV0ZSBuYW1lIGlzIGNhc2Utc2Vuc2l0aXZlIGluIFNWRyBzbyB3ZSBjYW4ndCBqdXN0IHVzZVxuLy8gdGhlIFJlYWN0IG5hbWUgbGlrZSB3ZSBkbyBmb3IgYXR0cmlidXRlcyB0aGF0IGV4aXN0IG9ubHkgaW4gSFRNTC5cblxuWyd0YWJJbmRleCcsICdjcm9zc09yaWdpbiddLmZvckVhY2goZnVuY3Rpb24gKGF0dHJpYnV0ZU5hbWUpIHtcbiAgcHJvcGVydGllc1thdHRyaWJ1dGVOYW1lXSA9IG5ldyBQcm9wZXJ0eUluZm9SZWNvcmQoYXR0cmlidXRlTmFtZSwgU1RSSU5HLCBmYWxzZSwgLy8gbXVzdFVzZVByb3BlcnR5XG4gIGF0dHJpYnV0ZU5hbWUudG9Mb3dlckNhc2UoKSwgLy8gYXR0cmlidXRlTmFtZVxuICBudWxsLCAvLyBhdHRyaWJ1dGVOYW1lc3BhY2VcbiAgZmFsc2UsIC8vIHNhbml0aXplVVJMXG4gIGZhbHNlKTtcbn0pOyAvLyBUaGVzZSBhdHRyaWJ1dGVzIGFjY2VwdCBVUkxzLiBUaGVzZSBtdXN0IG5vdCBhbGxvdyBqYXZhc2NyaXB0OiBVUkxTLlxuLy8gVGhlc2Ugd2lsbCBhbHNvIG5lZWQgdG8gYWNjZXB0IFRydXN0ZWQgVHlwZXMgb2JqZWN0IGluIHRoZSBmdXR1cmUuXG5cbnZhciB4bGlua0hyZWYgPSAneGxpbmtIcmVmJztcbnByb3BlcnRpZXNbeGxpbmtIcmVmXSA9IG5ldyBQcm9wZXJ0eUluZm9SZWNvcmQoJ3hsaW5rSHJlZicsIFNUUklORywgZmFsc2UsIC8vIG11c3RVc2VQcm9wZXJ0eVxuJ3hsaW5rOmhyZWYnLCAnaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycsIHRydWUsIC8vIHNhbml0aXplVVJMXG5mYWxzZSk7XG5bJ3NyYycsICdocmVmJywgJ2FjdGlvbicsICdmb3JtQWN0aW9uJ10uZm9yRWFjaChmdW5jdGlvbiAoYXR0cmlidXRlTmFtZSkge1xuICBwcm9wZXJ0aWVzW2F0dHJpYnV0ZU5hbWVdID0gbmV3IFByb3BlcnR5SW5mb1JlY29yZChhdHRyaWJ1dGVOYW1lLCBTVFJJTkcsIGZhbHNlLCAvLyBtdXN0VXNlUHJvcGVydHlcbiAgYXR0cmlidXRlTmFtZS50b0xvd2VyQ2FzZSgpLCAvLyBhdHRyaWJ1dGVOYW1lXG4gIG51bGwsIC8vIGF0dHJpYnV0ZU5hbWVzcGFjZVxuICB0cnVlLCAvLyBzYW5pdGl6ZVVSTFxuICB0cnVlKTtcbn0pO1xuXG4vLyBhbmQgYW55IG5ld2xpbmUgb3IgdGFiIGFyZSBmaWx0ZXJlZCBvdXQgYXMgaWYgdGhleSdyZSBub3QgcGFydCBvZiB0aGUgVVJMLlxuLy8gaHR0cHM6Ly91cmwuc3BlYy53aGF0d2cub3JnLyN1cmwtcGFyc2luZ1xuLy8gVGFiIG9yIG5ld2xpbmUgYXJlIGRlZmluZWQgYXMgXFxyXFxuXFx0OlxuLy8gaHR0cHM6Ly9pbmZyYS5zcGVjLndoYXR3Zy5vcmcvI2FzY2lpLXRhYi1vci1uZXdsaW5lXG4vLyBBIEMwIGNvbnRyb2wgaXMgYSBjb2RlIHBvaW50IGluIHRoZSByYW5nZSBcXHUwMDAwIE5VTEwgdG8gXFx1MDAxRlxuLy8gSU5GT1JNQVRJT04gU0VQQVJBVE9SIE9ORSwgaW5jbHVzaXZlOlxuLy8gaHR0cHM6Ly9pbmZyYS5zcGVjLndoYXR3Zy5vcmcvI2MwLWNvbnRyb2wtb3Itc3BhY2VcblxuLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiAqL1xuXG52YXIgaXNKYXZhU2NyaXB0UHJvdG9jb2wgPSAvXltcXHUwMDAwLVxcdTAwMUYgXSpqW1xcclxcblxcdF0qYVtcXHJcXG5cXHRdKnZbXFxyXFxuXFx0XSphW1xcclxcblxcdF0qc1tcXHJcXG5cXHRdKmNbXFxyXFxuXFx0XSpyW1xcclxcblxcdF0qaVtcXHJcXG5cXHRdKnBbXFxyXFxuXFx0XSp0W1xcclxcblxcdF0qXFw6L2k7XG52YXIgZGlkV2FybiA9IGZhbHNlO1xuXG5mdW5jdGlvbiBzYW5pdGl6ZVVSTCh1cmwpIHtcbiAge1xuICAgIGlmICghZGlkV2FybiAmJiBpc0phdmFTY3JpcHRQcm90b2NvbC50ZXN0KHVybCkpIHtcbiAgICAgIGRpZFdhcm4gPSB0cnVlO1xuXG4gICAgICBlcnJvcignQSBmdXR1cmUgdmVyc2lvbiBvZiBSZWFjdCB3aWxsIGJsb2NrIGphdmFzY3JpcHQ6IFVSTHMgYXMgYSBzZWN1cml0eSBwcmVjYXV0aW9uLiAnICsgJ1VzZSBldmVudCBoYW5kbGVycyBpbnN0ZWFkIGlmIHlvdSBjYW4uIElmIHlvdSBuZWVkIHRvIGdlbmVyYXRlIHVuc2FmZSBIVE1MIHRyeSAnICsgJ3VzaW5nIGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MIGluc3RlYWQuIFJlYWN0IHdhcyBwYXNzZWQgJXMuJywgSlNPTi5zdHJpbmdpZnkodXJsKSk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogR2V0IHRoZSB2YWx1ZSBmb3IgYSBwcm9wZXJ0eSBvbiBhIG5vZGUuIE9ubHkgdXNlZCBpbiBERVYgZm9yIFNTUiB2YWxpZGF0aW9uLlxuICogVGhlIFwiZXhwZWN0ZWRcIiBhcmd1bWVudCBpcyB1c2VkIGFzIGEgaGludCBvZiB3aGF0IHRoZSBleHBlY3RlZCB2YWx1ZSBpcy5cbiAqIFNvbWUgcHJvcGVydGllcyBoYXZlIG11bHRpcGxlIGVxdWl2YWxlbnQgdmFsdWVzLlxuICovXG5mdW5jdGlvbiBnZXRWYWx1ZUZvclByb3BlcnR5KG5vZGUsIG5hbWUsIGV4cGVjdGVkLCBwcm9wZXJ0eUluZm8pIHtcbiAge1xuICAgIGlmIChwcm9wZXJ0eUluZm8ubXVzdFVzZVByb3BlcnR5KSB7XG4gICAgICB2YXIgcHJvcGVydHlOYW1lID0gcHJvcGVydHlJbmZvLnByb3BlcnR5TmFtZTtcbiAgICAgIHJldHVybiBub2RlW3Byb3BlcnR5TmFtZV07XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICggcHJvcGVydHlJbmZvLnNhbml0aXplVVJMKSB7XG4gICAgICAgIC8vIElmIHdlIGhhdmVuJ3QgZnVsbHkgZGlzYWJsZWQgamF2YXNjcmlwdDogVVJMcywgYW5kIGlmXG4gICAgICAgIC8vIHRoZSBoeWRyYXRpb24gaXMgc3VjY2Vzc2Z1bCBvZiBhIGphdmFzY3JpcHQ6IFVSTCwgd2VcbiAgICAgICAgLy8gc3RpbGwgd2FudCB0byB3YXJuIG9uIHRoZSBjbGllbnQuXG4gICAgICAgIHNhbml0aXplVVJMKCcnICsgZXhwZWN0ZWQpO1xuICAgICAgfVxuXG4gICAgICB2YXIgYXR0cmlidXRlTmFtZSA9IHByb3BlcnR5SW5mby5hdHRyaWJ1dGVOYW1lO1xuICAgICAgdmFyIHN0cmluZ1ZhbHVlID0gbnVsbDtcblxuICAgICAgaWYgKHByb3BlcnR5SW5mby50eXBlID09PSBPVkVSTE9BREVEX0JPT0xFQU4pIHtcbiAgICAgICAgaWYgKG5vZGUuaGFzQXR0cmlidXRlKGF0dHJpYnV0ZU5hbWUpKSB7XG4gICAgICAgICAgdmFyIHZhbHVlID0gbm9kZS5nZXRBdHRyaWJ1dGUoYXR0cmlidXRlTmFtZSk7XG5cbiAgICAgICAgICBpZiAodmFsdWUgPT09ICcnKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoc2hvdWxkUmVtb3ZlQXR0cmlidXRlKG5hbWUsIGV4cGVjdGVkLCBwcm9wZXJ0eUluZm8sIGZhbHNlKSkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICh2YWx1ZSA9PT0gJycgKyBleHBlY3RlZCkge1xuICAgICAgICAgICAgcmV0dXJuIGV4cGVjdGVkO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChub2RlLmhhc0F0dHJpYnV0ZShhdHRyaWJ1dGVOYW1lKSkge1xuICAgICAgICBpZiAoc2hvdWxkUmVtb3ZlQXR0cmlidXRlKG5hbWUsIGV4cGVjdGVkLCBwcm9wZXJ0eUluZm8sIGZhbHNlKSkge1xuICAgICAgICAgIC8vIFdlIGhhZCBhbiBhdHRyaWJ1dGUgYnV0IHNob3VsZG4ndCBoYXZlIGhhZCBvbmUsIHNvIHJlYWQgaXRcbiAgICAgICAgICAvLyBmb3IgdGhlIGVycm9yIG1lc3NhZ2UuXG4gICAgICAgICAgcmV0dXJuIG5vZGUuZ2V0QXR0cmlidXRlKGF0dHJpYnV0ZU5hbWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHByb3BlcnR5SW5mby50eXBlID09PSBCT09MRUFOKSB7XG4gICAgICAgICAgLy8gSWYgdGhpcyB3YXMgYSBib29sZWFuLCBpdCBkb2Vzbid0IG1hdHRlciB3aGF0IHRoZSB2YWx1ZSBpc1xuICAgICAgICAgIC8vIHRoZSBmYWN0IHRoYXQgd2UgaGF2ZSBpdCBpcyB0aGUgc2FtZSBhcyB0aGUgZXhwZWN0ZWQuXG4gICAgICAgICAgcmV0dXJuIGV4cGVjdGVkO1xuICAgICAgICB9IC8vIEV2ZW4gaWYgdGhpcyBwcm9wZXJ0eSB1c2VzIGEgbmFtZXNwYWNlIHdlIHVzZSBnZXRBdHRyaWJ1dGVcbiAgICAgICAgLy8gYmVjYXVzZSB3ZSBhc3N1bWUgaXRzIG5hbWVzcGFjZWQgbmFtZSBpcyB0aGUgc2FtZSBhcyBvdXIgY29uZmlnLlxuICAgICAgICAvLyBUbyB1c2UgZ2V0QXR0cmlidXRlTlMgd2UgbmVlZCB0aGUgbG9jYWwgbmFtZSB3aGljaCB3ZSBkb24ndCBoYXZlXG4gICAgICAgIC8vIGluIG91ciBjb25maWcgYXRtLlxuXG5cbiAgICAgICAgc3RyaW5nVmFsdWUgPSBub2RlLmdldEF0dHJpYnV0ZShhdHRyaWJ1dGVOYW1lKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHNob3VsZFJlbW92ZUF0dHJpYnV0ZShuYW1lLCBleHBlY3RlZCwgcHJvcGVydHlJbmZvLCBmYWxzZSkpIHtcbiAgICAgICAgcmV0dXJuIHN0cmluZ1ZhbHVlID09PSBudWxsID8gZXhwZWN0ZWQgOiBzdHJpbmdWYWx1ZTtcbiAgICAgIH0gZWxzZSBpZiAoc3RyaW5nVmFsdWUgPT09ICcnICsgZXhwZWN0ZWQpIHtcbiAgICAgICAgcmV0dXJuIGV4cGVjdGVkO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHN0cmluZ1ZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuLyoqXG4gKiBHZXQgdGhlIHZhbHVlIGZvciBhIGF0dHJpYnV0ZSBvbiBhIG5vZGUuIE9ubHkgdXNlZCBpbiBERVYgZm9yIFNTUiB2YWxpZGF0aW9uLlxuICogVGhlIHRoaXJkIGFyZ3VtZW50IGlzIHVzZWQgYXMgYSBoaW50IG9mIHdoYXQgdGhlIGV4cGVjdGVkIHZhbHVlIGlzLiBTb21lXG4gKiBhdHRyaWJ1dGVzIGhhdmUgbXVsdGlwbGUgZXF1aXZhbGVudCB2YWx1ZXMuXG4gKi9cblxuZnVuY3Rpb24gZ2V0VmFsdWVGb3JBdHRyaWJ1dGUobm9kZSwgbmFtZSwgZXhwZWN0ZWQpIHtcbiAge1xuICAgIGlmICghaXNBdHRyaWJ1dGVOYW1lU2FmZShuYW1lKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gSWYgdGhlIG9iamVjdCBpcyBhbiBvcGFxdWUgcmVmZXJlbmNlIElELCBpdCdzIGV4cGVjdGVkIHRoYXRcbiAgICAvLyB0aGUgbmV4dCBwcm9wIGlzIGRpZmZlcmVudCB0aGFuIHRoZSBzZXJ2ZXIgdmFsdWUsIHNvIGp1c3QgcmV0dXJuXG4gICAgLy8gZXhwZWN0ZWRcblxuXG4gICAgaWYgKGlzT3BhcXVlSHlkcmF0aW5nT2JqZWN0KGV4cGVjdGVkKSkge1xuICAgICAgcmV0dXJuIGV4cGVjdGVkO1xuICAgIH1cblxuICAgIGlmICghbm9kZS5oYXNBdHRyaWJ1dGUobmFtZSkpIHtcbiAgICAgIHJldHVybiBleHBlY3RlZCA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgdmFsdWUgPSBub2RlLmdldEF0dHJpYnV0ZShuYW1lKTtcblxuICAgIGlmICh2YWx1ZSA9PT0gJycgKyBleHBlY3RlZCkge1xuICAgICAgcmV0dXJuIGV4cGVjdGVkO1xuICAgIH1cblxuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxufVxuLyoqXG4gKiBTZXRzIHRoZSB2YWx1ZSBmb3IgYSBwcm9wZXJ0eSBvbiBhIG5vZGUuXG4gKlxuICogQHBhcmFtIHtET01FbGVtZW50fSBub2RlXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICogQHBhcmFtIHsqfSB2YWx1ZVxuICovXG5cbmZ1bmN0aW9uIHNldFZhbHVlRm9yUHJvcGVydHkobm9kZSwgbmFtZSwgdmFsdWUsIGlzQ3VzdG9tQ29tcG9uZW50VGFnKSB7XG4gIHZhciBwcm9wZXJ0eUluZm8gPSBnZXRQcm9wZXJ0eUluZm8obmFtZSk7XG5cbiAgaWYgKHNob3VsZElnbm9yZUF0dHJpYnV0ZShuYW1lLCBwcm9wZXJ0eUluZm8sIGlzQ3VzdG9tQ29tcG9uZW50VGFnKSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChzaG91bGRSZW1vdmVBdHRyaWJ1dGUobmFtZSwgdmFsdWUsIHByb3BlcnR5SW5mbywgaXNDdXN0b21Db21wb25lbnRUYWcpKSB7XG4gICAgdmFsdWUgPSBudWxsO1xuICB9IC8vIElmIHRoZSBwcm9wIGlzbid0IGluIHRoZSBzcGVjaWFsIGxpc3QsIHRyZWF0IGl0IGFzIGEgc2ltcGxlIGF0dHJpYnV0ZS5cblxuXG4gIGlmIChpc0N1c3RvbUNvbXBvbmVudFRhZyB8fCBwcm9wZXJ0eUluZm8gPT09IG51bGwpIHtcbiAgICBpZiAoaXNBdHRyaWJ1dGVOYW1lU2FmZShuYW1lKSkge1xuICAgICAgdmFyIF9hdHRyaWJ1dGVOYW1lID0gbmFtZTtcblxuICAgICAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgICAgIG5vZGUucmVtb3ZlQXR0cmlidXRlKF9hdHRyaWJ1dGVOYW1lKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5vZGUuc2V0QXR0cmlidXRlKF9hdHRyaWJ1dGVOYW1lLCAgJycgKyB2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIG11c3RVc2VQcm9wZXJ0eSA9IHByb3BlcnR5SW5mby5tdXN0VXNlUHJvcGVydHk7XG5cbiAgaWYgKG11c3RVc2VQcm9wZXJ0eSkge1xuICAgIHZhciBwcm9wZXJ0eU5hbWUgPSBwcm9wZXJ0eUluZm8ucHJvcGVydHlOYW1lO1xuXG4gICAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgICB2YXIgdHlwZSA9IHByb3BlcnR5SW5mby50eXBlO1xuICAgICAgbm9kZVtwcm9wZXJ0eU5hbWVdID0gdHlwZSA9PT0gQk9PTEVBTiA/IGZhbHNlIDogJyc7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIENvbnRyYXJ5IHRvIGBzZXRBdHRyaWJ1dGVgLCBvYmplY3QgcHJvcGVydGllcyBhcmUgcHJvcGVybHlcbiAgICAgIC8vIGB0b1N0cmluZ2BlZCBieSBJRTgvOS5cbiAgICAgIG5vZGVbcHJvcGVydHlOYW1lXSA9IHZhbHVlO1xuICAgIH1cblxuICAgIHJldHVybjtcbiAgfSAvLyBUaGUgcmVzdCBhcmUgdHJlYXRlZCBhcyBhdHRyaWJ1dGVzIHdpdGggc3BlY2lhbCBjYXNlcy5cblxuXG4gIHZhciBhdHRyaWJ1dGVOYW1lID0gcHJvcGVydHlJbmZvLmF0dHJpYnV0ZU5hbWUsXG4gICAgICBhdHRyaWJ1dGVOYW1lc3BhY2UgPSBwcm9wZXJ0eUluZm8uYXR0cmlidXRlTmFtZXNwYWNlO1xuXG4gIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgIG5vZGUucmVtb3ZlQXR0cmlidXRlKGF0dHJpYnV0ZU5hbWUpO1xuICB9IGVsc2Uge1xuICAgIHZhciBfdHlwZSA9IHByb3BlcnR5SW5mby50eXBlO1xuICAgIHZhciBhdHRyaWJ1dGVWYWx1ZTtcblxuICAgIGlmIChfdHlwZSA9PT0gQk9PTEVBTiB8fCBfdHlwZSA9PT0gT1ZFUkxPQURFRF9CT09MRUFOICYmIHZhbHVlID09PSB0cnVlKSB7XG4gICAgICAvLyBJZiBhdHRyaWJ1dGUgdHlwZSBpcyBib29sZWFuLCB3ZSBrbm93IGZvciBzdXJlIGl0IHdvbid0IGJlIGFuIGV4ZWN1dGlvbiBzaW5rXG4gICAgICAvLyBhbmQgd2Ugd29uJ3QgcmVxdWlyZSBUcnVzdGVkIFR5cGUgaGVyZS5cbiAgICAgIGF0dHJpYnV0ZVZhbHVlID0gJyc7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGBzZXRBdHRyaWJ1dGVgIHdpdGggb2JqZWN0cyBiZWNvbWVzIG9ubHkgYFtvYmplY3RdYCBpbiBJRTgvOSxcbiAgICAgIC8vICgnJyArIHZhbHVlKSBtYWtlcyBpdCBvdXRwdXQgdGhlIGNvcnJlY3QgdG9TdHJpbmcoKS12YWx1ZS5cbiAgICAgIHtcbiAgICAgICAgYXR0cmlidXRlVmFsdWUgPSAnJyArIHZhbHVlO1xuICAgICAgfVxuXG4gICAgICBpZiAocHJvcGVydHlJbmZvLnNhbml0aXplVVJMKSB7XG4gICAgICAgIHNhbml0aXplVVJMKGF0dHJpYnV0ZVZhbHVlLnRvU3RyaW5nKCkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChhdHRyaWJ1dGVOYW1lc3BhY2UpIHtcbiAgICAgIG5vZGUuc2V0QXR0cmlidXRlTlMoYXR0cmlidXRlTmFtZXNwYWNlLCBhdHRyaWJ1dGVOYW1lLCBhdHRyaWJ1dGVWYWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5vZGUuc2V0QXR0cmlidXRlKGF0dHJpYnV0ZU5hbWUsIGF0dHJpYnV0ZVZhbHVlKTtcbiAgICB9XG4gIH1cbn1cblxuLy8gQVRURU5USU9OXG4vLyBXaGVuIGFkZGluZyBuZXcgc3ltYm9scyB0byB0aGlzIGZpbGUsXG4vLyBQbGVhc2UgY29uc2lkZXIgYWxzbyBhZGRpbmcgdG8gJ3JlYWN0LWRldnRvb2xzLXNoYXJlZC9zcmMvYmFja2VuZC9SZWFjdFN5bWJvbHMnXG4vLyBUaGUgU3ltYm9sIHVzZWQgdG8gdGFnIHRoZSBSZWFjdEVsZW1lbnQtbGlrZSB0eXBlcy4gSWYgdGhlcmUgaXMgbm8gbmF0aXZlIFN5bWJvbFxuLy8gbm9yIHBvbHlmaWxsLCB0aGVuIGEgcGxhaW4gbnVtYmVyIGlzIHVzZWQgZm9yIHBlcmZvcm1hbmNlLlxudmFyIFJFQUNUX0VMRU1FTlRfVFlQRSA9IDB4ZWFjNztcbnZhciBSRUFDVF9QT1JUQUxfVFlQRSA9IDB4ZWFjYTtcbnZhciBSRUFDVF9GUkFHTUVOVF9UWVBFID0gMHhlYWNiO1xudmFyIFJFQUNUX1NUUklDVF9NT0RFX1RZUEUgPSAweGVhY2M7XG52YXIgUkVBQ1RfUFJPRklMRVJfVFlQRSA9IDB4ZWFkMjtcbnZhciBSRUFDVF9QUk9WSURFUl9UWVBFID0gMHhlYWNkO1xudmFyIFJFQUNUX0NPTlRFWFRfVFlQRSA9IDB4ZWFjZTtcbnZhciBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFID0gMHhlYWQwO1xudmFyIFJFQUNUX1NVU1BFTlNFX1RZUEUgPSAweGVhZDE7XG52YXIgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFID0gMHhlYWQ4O1xudmFyIFJFQUNUX01FTU9fVFlQRSA9IDB4ZWFkMztcbnZhciBSRUFDVF9MQVpZX1RZUEUgPSAweGVhZDQ7XG52YXIgUkVBQ1RfQkxPQ0tfVFlQRSA9IDB4ZWFkOTtcbnZhciBSRUFDVF9TRVJWRVJfQkxPQ0tfVFlQRSA9IDB4ZWFkYTtcbnZhciBSRUFDVF9GVU5EQU1FTlRBTF9UWVBFID0gMHhlYWQ1O1xudmFyIFJFQUNUX1NDT1BFX1RZUEUgPSAweGVhZDc7XG52YXIgUkVBQ1RfT1BBUVVFX0lEX1RZUEUgPSAweGVhZTA7XG52YXIgUkVBQ1RfREVCVUdfVFJBQ0lOR19NT0RFX1RZUEUgPSAweGVhZTE7XG52YXIgUkVBQ1RfT0ZGU0NSRUVOX1RZUEUgPSAweGVhZTI7XG52YXIgUkVBQ1RfTEVHQUNZX0hJRERFTl9UWVBFID0gMHhlYWUzO1xuXG5pZiAodHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2wuZm9yKSB7XG4gIHZhciBzeW1ib2xGb3IgPSBTeW1ib2wuZm9yO1xuICBSRUFDVF9FTEVNRU5UX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LmVsZW1lbnQnKTtcbiAgUkVBQ1RfUE9SVEFMX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LnBvcnRhbCcpO1xuICBSRUFDVF9GUkFHTUVOVF9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5mcmFnbWVudCcpO1xuICBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5zdHJpY3RfbW9kZScpO1xuICBSRUFDVF9QUk9GSUxFUl9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5wcm9maWxlcicpO1xuICBSRUFDVF9QUk9WSURFUl9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5wcm92aWRlcicpO1xuICBSRUFDVF9DT05URVhUX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LmNvbnRleHQnKTtcbiAgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSA9IHN5bWJvbEZvcigncmVhY3QuZm9yd2FyZF9yZWYnKTtcbiAgUkVBQ1RfU1VTUEVOU0VfVFlQRSA9IHN5bWJvbEZvcigncmVhY3Quc3VzcGVuc2UnKTtcbiAgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5zdXNwZW5zZV9saXN0Jyk7XG4gIFJFQUNUX01FTU9fVFlQRSA9IHN5bWJvbEZvcigncmVhY3QubWVtbycpO1xuICBSRUFDVF9MQVpZX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LmxhenknKTtcbiAgUkVBQ1RfQkxPQ0tfVFlQRSA9IHN5bWJvbEZvcigncmVhY3QuYmxvY2snKTtcbiAgUkVBQ1RfU0VSVkVSX0JMT0NLX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LnNlcnZlci5ibG9jaycpO1xuICBSRUFDVF9GVU5EQU1FTlRBTF9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5mdW5kYW1lbnRhbCcpO1xuICBSRUFDVF9TQ09QRV9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5zY29wZScpO1xuICBSRUFDVF9PUEFRVUVfSURfVFlQRSA9IHN5bWJvbEZvcigncmVhY3Qub3BhcXVlLmlkJyk7XG4gIFJFQUNUX0RFQlVHX1RSQUNJTkdfTU9ERV9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5kZWJ1Z190cmFjZV9tb2RlJyk7XG4gIFJFQUNUX09GRlNDUkVFTl9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5vZmZzY3JlZW4nKTtcbiAgUkVBQ1RfTEVHQUNZX0hJRERFTl9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5sZWdhY3lfaGlkZGVuJyk7XG59XG5cbnZhciBNQVlCRV9JVEVSQVRPUl9TWU1CT0wgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC5pdGVyYXRvcjtcbnZhciBGQVVYX0lURVJBVE9SX1NZTUJPTCA9ICdAQGl0ZXJhdG9yJztcbmZ1bmN0aW9uIGdldEl0ZXJhdG9yRm4obWF5YmVJdGVyYWJsZSkge1xuICBpZiAobWF5YmVJdGVyYWJsZSA9PT0gbnVsbCB8fCB0eXBlb2YgbWF5YmVJdGVyYWJsZSAhPT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBtYXliZUl0ZXJhdG9yID0gTUFZQkVfSVRFUkFUT1JfU1lNQk9MICYmIG1heWJlSXRlcmFibGVbTUFZQkVfSVRFUkFUT1JfU1lNQk9MXSB8fCBtYXliZUl0ZXJhYmxlW0ZBVVhfSVRFUkFUT1JfU1lNQk9MXTtcblxuICBpZiAodHlwZW9mIG1heWJlSXRlcmF0b3IgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gbWF5YmVJdGVyYXRvcjtcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG4vLyBIZWxwZXJzIHRvIHBhdGNoIGNvbnNvbGUubG9ncyB0byBhdm9pZCBsb2dnaW5nIGR1cmluZyBzaWRlLWVmZmVjdCBmcmVlXG4vLyByZXBsYXlpbmcgb24gcmVuZGVyIGZ1bmN0aW9uLiBUaGlzIGN1cnJlbnRseSBvbmx5IHBhdGNoZXMgdGhlIG9iamVjdFxuLy8gbGF6aWx5IHdoaWNoIHdvbid0IGNvdmVyIGlmIHRoZSBsb2cgZnVuY3Rpb24gd2FzIGV4dHJhY3RlZCBlYWdlcmx5LlxuLy8gV2UgY291bGQgYWxzbyBlYWdlcmx5IHBhdGNoIHRoZSBtZXRob2QuXG52YXIgZGlzYWJsZWREZXB0aCA9IDA7XG52YXIgcHJldkxvZztcbnZhciBwcmV2SW5mbztcbnZhciBwcmV2V2FybjtcbnZhciBwcmV2RXJyb3I7XG52YXIgcHJldkdyb3VwO1xudmFyIHByZXZHcm91cENvbGxhcHNlZDtcbnZhciBwcmV2R3JvdXBFbmQ7XG5cbmZ1bmN0aW9uIGRpc2FibGVkTG9nKCkge31cblxuZGlzYWJsZWRMb2cuX19yZWFjdERpc2FibGVkTG9nID0gdHJ1ZTtcbmZ1bmN0aW9uIGRpc2FibGVMb2dzKCkge1xuICB7XG4gICAgaWYgKGRpc2FibGVkRGVwdGggPT09IDApIHtcbiAgICAgIC8qIGVzbGludC1kaXNhYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgICAgcHJldkxvZyA9IGNvbnNvbGUubG9nO1xuICAgICAgcHJldkluZm8gPSBjb25zb2xlLmluZm87XG4gICAgICBwcmV2V2FybiA9IGNvbnNvbGUud2FybjtcbiAgICAgIHByZXZFcnJvciA9IGNvbnNvbGUuZXJyb3I7XG4gICAgICBwcmV2R3JvdXAgPSBjb25zb2xlLmdyb3VwO1xuICAgICAgcHJldkdyb3VwQ29sbGFwc2VkID0gY29uc29sZS5ncm91cENvbGxhcHNlZDtcbiAgICAgIHByZXZHcm91cEVuZCA9IGNvbnNvbGUuZ3JvdXBFbmQ7IC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTkwOTlcblxuICAgICAgdmFyIHByb3BzID0ge1xuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIHZhbHVlOiBkaXNhYmxlZExvZyxcbiAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgIH07IC8vICRGbG93Rml4TWUgRmxvdyB0aGlua3MgY29uc29sZSBpcyBpbW11dGFibGUuXG5cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGNvbnNvbGUsIHtcbiAgICAgICAgaW5mbzogcHJvcHMsXG4gICAgICAgIGxvZzogcHJvcHMsXG4gICAgICAgIHdhcm46IHByb3BzLFxuICAgICAgICBlcnJvcjogcHJvcHMsXG4gICAgICAgIGdyb3VwOiBwcm9wcyxcbiAgICAgICAgZ3JvdXBDb2xsYXBzZWQ6IHByb3BzLFxuICAgICAgICBncm91cEVuZDogcHJvcHNcbiAgICAgIH0pO1xuICAgICAgLyogZXNsaW50LWVuYWJsZSByZWFjdC1pbnRlcm5hbC9uby1wcm9kdWN0aW9uLWxvZ2dpbmcgKi9cbiAgICB9XG5cbiAgICBkaXNhYmxlZERlcHRoKys7XG4gIH1cbn1cbmZ1bmN0aW9uIHJlZW5hYmxlTG9ncygpIHtcbiAge1xuICAgIGRpc2FibGVkRGVwdGgtLTtcblxuICAgIGlmIChkaXNhYmxlZERlcHRoID09PSAwKSB7XG4gICAgICAvKiBlc2xpbnQtZGlzYWJsZSByZWFjdC1pbnRlcm5hbC9uby1wcm9kdWN0aW9uLWxvZ2dpbmcgKi9cbiAgICAgIHZhciBwcm9wcyA9IHtcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgfTsgLy8gJEZsb3dGaXhNZSBGbG93IHRoaW5rcyBjb25zb2xlIGlzIGltbXV0YWJsZS5cblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoY29uc29sZSwge1xuICAgICAgICBsb2c6IF9hc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZMb2dcbiAgICAgICAgfSksXG4gICAgICAgIGluZm86IF9hc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZJbmZvXG4gICAgICAgIH0pLFxuICAgICAgICB3YXJuOiBfYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2V2FyblxuICAgICAgICB9KSxcbiAgICAgICAgZXJyb3I6IF9hc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZFcnJvclxuICAgICAgICB9KSxcbiAgICAgICAgZ3JvdXA6IF9hc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZHcm91cFxuICAgICAgICB9KSxcbiAgICAgICAgZ3JvdXBDb2xsYXBzZWQ6IF9hc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZHcm91cENvbGxhcHNlZFxuICAgICAgICB9KSxcbiAgICAgICAgZ3JvdXBFbmQ6IF9hc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZHcm91cEVuZFxuICAgICAgICB9KVxuICAgICAgfSk7XG4gICAgICAvKiBlc2xpbnQtZW5hYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgIH1cblxuICAgIGlmIChkaXNhYmxlZERlcHRoIDwgMCkge1xuICAgICAgZXJyb3IoJ2Rpc2FibGVkRGVwdGggZmVsbCBiZWxvdyB6ZXJvLiAnICsgJ1RoaXMgaXMgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgIH1cbiAgfVxufVxuXG52YXIgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0Q3VycmVudERpc3BhdGNoZXI7XG52YXIgcHJlZml4O1xuZnVuY3Rpb24gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUobmFtZSwgc291cmNlLCBvd25lckZuKSB7XG4gIHtcbiAgICBpZiAocHJlZml4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIEV4dHJhY3QgdGhlIFZNIHNwZWNpZmljIHByZWZpeCB1c2VkIGJ5IGVhY2ggbGluZS5cbiAgICAgIHRyeSB7XG4gICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgIHZhciBtYXRjaCA9IHguc3RhY2sudHJpbSgpLm1hdGNoKC9cXG4oICooYXQgKT8pLyk7XG4gICAgICAgIHByZWZpeCA9IG1hdGNoICYmIG1hdGNoWzFdIHx8ICcnO1xuICAgICAgfVxuICAgIH0gLy8gV2UgdXNlIHRoZSBwcmVmaXggdG8gZW5zdXJlIG91ciBzdGFja3MgbGluZSB1cCB3aXRoIG5hdGl2ZSBzdGFjayBmcmFtZXMuXG5cblxuICAgIHJldHVybiAnXFxuJyArIHByZWZpeCArIG5hbWU7XG4gIH1cbn1cbnZhciByZWVudHJ5ID0gZmFsc2U7XG52YXIgY29tcG9uZW50RnJhbWVDYWNoZTtcblxue1xuICB2YXIgUG9zc2libHlXZWFrTWFwID0gdHlwZW9mIFdlYWtNYXAgPT09ICdmdW5jdGlvbicgPyBXZWFrTWFwIDogTWFwO1xuICBjb21wb25lbnRGcmFtZUNhY2hlID0gbmV3IFBvc3NpYmx5V2Vha01hcCgpO1xufVxuXG5mdW5jdGlvbiBkZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lKGZuLCBjb25zdHJ1Y3QpIHtcbiAgLy8gSWYgc29tZXRoaW5nIGFza2VkIGZvciBhIHN0YWNrIGluc2lkZSBhIGZha2UgcmVuZGVyLCBpdCBzaG91bGQgZ2V0IGlnbm9yZWQuXG4gIGlmICghZm4gfHwgcmVlbnRyeSkge1xuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIHtcbiAgICB2YXIgZnJhbWUgPSBjb21wb25lbnRGcmFtZUNhY2hlLmdldChmbik7XG5cbiAgICBpZiAoZnJhbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGZyYW1lO1xuICAgIH1cbiAgfVxuXG4gIHZhciBjb250cm9sO1xuICByZWVudHJ5ID0gdHJ1ZTtcbiAgdmFyIHByZXZpb3VzUHJlcGFyZVN0YWNrVHJhY2UgPSBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZTsgLy8gJEZsb3dGaXhNZSBJdCBkb2VzIGFjY2VwdCB1bmRlZmluZWQuXG5cbiAgRXJyb3IucHJlcGFyZVN0YWNrVHJhY2UgPSB1bmRlZmluZWQ7XG4gIHZhciBwcmV2aW91c0Rpc3BhdGNoZXI7XG5cbiAge1xuICAgIHByZXZpb3VzRGlzcGF0Y2hlciA9IFJlYWN0Q3VycmVudERpc3BhdGNoZXIuY3VycmVudDsgLy8gU2V0IHRoZSBkaXNwYXRjaGVyIGluIERFViBiZWNhdXNlIHRoaXMgbWlnaHQgYmUgY2FsbCBpbiB0aGUgcmVuZGVyIGZ1bmN0aW9uXG4gICAgLy8gZm9yIHdhcm5pbmdzLlxuXG4gICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlci5jdXJyZW50ID0gbnVsbDtcbiAgICBkaXNhYmxlTG9ncygpO1xuICB9XG5cbiAgdHJ5IHtcbiAgICAvLyBUaGlzIHNob3VsZCB0aHJvdy5cbiAgICBpZiAoY29uc3RydWN0KSB7XG4gICAgICAvLyBTb21ldGhpbmcgc2hvdWxkIGJlIHNldHRpbmcgdGhlIHByb3BzIGluIHRoZSBjb25zdHJ1Y3Rvci5cbiAgICAgIHZhciBGYWtlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgfTsgLy8gJEZsb3dGaXhNZVxuXG5cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShGYWtlLnByb3RvdHlwZSwgJ3Byb3BzJywge1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAvLyBXZSB1c2UgYSB0aHJvd2luZyBzZXR0ZXIgaW5zdGVhZCBvZiBmcm96ZW4gb3Igbm9uLXdyaXRhYmxlIHByb3BzXG4gICAgICAgICAgLy8gYmVjYXVzZSB0aGF0IHdvbid0IHRocm93IGluIGEgbm9uLXN0cmljdCBtb2RlIGZ1bmN0aW9uLlxuICAgICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09ICdvYmplY3QnICYmIFJlZmxlY3QuY29uc3RydWN0KSB7XG4gICAgICAgIC8vIFdlIGNvbnN0cnVjdCBhIGRpZmZlcmVudCBjb250cm9sIGZvciB0aGlzIGNhc2UgdG8gaW5jbHVkZSBhbnkgZXh0cmFcbiAgICAgICAgLy8gZnJhbWVzIGFkZGVkIGJ5IHRoZSBjb25zdHJ1Y3QgY2FsbC5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBSZWZsZWN0LmNvbnN0cnVjdChGYWtlLCBbXSk7XG4gICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICBjb250cm9sID0geDtcbiAgICAgICAgfVxuXG4gICAgICAgIFJlZmxlY3QuY29uc3RydWN0KGZuLCBbXSwgRmFrZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIEZha2UuY2FsbCgpO1xuICAgICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgICAgY29udHJvbCA9IHg7XG4gICAgICAgIH1cblxuICAgICAgICBmbi5jYWxsKEZha2UucHJvdG90eXBlKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgY29udHJvbCA9IHg7XG4gICAgICB9XG5cbiAgICAgIGZuKCk7XG4gICAgfVxuICB9IGNhdGNoIChzYW1wbGUpIHtcbiAgICAvLyBUaGlzIGlzIGlubGluZWQgbWFudWFsbHkgYmVjYXVzZSBjbG9zdXJlIGRvZXNuJ3QgZG8gaXQgZm9yIHVzLlxuICAgIGlmIChzYW1wbGUgJiYgY29udHJvbCAmJiB0eXBlb2Ygc2FtcGxlLnN0YWNrID09PSAnc3RyaW5nJykge1xuICAgICAgLy8gVGhpcyBleHRyYWN0cyB0aGUgZmlyc3QgZnJhbWUgZnJvbSB0aGUgc2FtcGxlIHRoYXQgaXNuJ3QgYWxzbyBpbiB0aGUgY29udHJvbC5cbiAgICAgIC8vIFNraXBwaW5nIG9uZSBmcmFtZSB0aGF0IHdlIGFzc3VtZSBpcyB0aGUgZnJhbWUgdGhhdCBjYWxscyB0aGUgdHdvLlxuICAgICAgdmFyIHNhbXBsZUxpbmVzID0gc2FtcGxlLnN0YWNrLnNwbGl0KCdcXG4nKTtcbiAgICAgIHZhciBjb250cm9sTGluZXMgPSBjb250cm9sLnN0YWNrLnNwbGl0KCdcXG4nKTtcbiAgICAgIHZhciBzID0gc2FtcGxlTGluZXMubGVuZ3RoIC0gMTtcbiAgICAgIHZhciBjID0gY29udHJvbExpbmVzLmxlbmd0aCAtIDE7XG5cbiAgICAgIHdoaWxlIChzID49IDEgJiYgYyA+PSAwICYmIHNhbXBsZUxpbmVzW3NdICE9PSBjb250cm9sTGluZXNbY10pIHtcbiAgICAgICAgLy8gV2UgZXhwZWN0IGF0IGxlYXN0IG9uZSBzdGFjayBmcmFtZSB0byBiZSBzaGFyZWQuXG4gICAgICAgIC8vIFR5cGljYWxseSB0aGlzIHdpbGwgYmUgdGhlIHJvb3QgbW9zdCBvbmUuIEhvd2V2ZXIsIHN0YWNrIGZyYW1lcyBtYXkgYmVcbiAgICAgICAgLy8gY3V0IG9mZiBkdWUgdG8gbWF4aW11bSBzdGFjayBsaW1pdHMuIEluIHRoaXMgY2FzZSwgb25lIG1heWJlIGN1dCBvZmZcbiAgICAgICAgLy8gZWFybGllciB0aGFuIHRoZSBvdGhlci4gV2UgYXNzdW1lIHRoYXQgdGhlIHNhbXBsZSBpcyBsb25nZXIgb3IgdGhlIHNhbWVcbiAgICAgICAgLy8gYW5kIHRoZXJlIGZvciBjdXQgb2ZmIGVhcmxpZXIuIFNvIHdlIHNob3VsZCBmaW5kIHRoZSByb290IG1vc3QgZnJhbWUgaW5cbiAgICAgICAgLy8gdGhlIHNhbXBsZSBzb21ld2hlcmUgaW4gdGhlIGNvbnRyb2wuXG4gICAgICAgIGMtLTtcbiAgICAgIH1cblxuICAgICAgZm9yICg7IHMgPj0gMSAmJiBjID49IDA7IHMtLSwgYy0tKSB7XG4gICAgICAgIC8vIE5leHQgd2UgZmluZCB0aGUgZmlyc3Qgb25lIHRoYXQgaXNuJ3QgdGhlIHNhbWUgd2hpY2ggc2hvdWxkIGJlIHRoZVxuICAgICAgICAvLyBmcmFtZSB0aGF0IGNhbGxlZCBvdXIgc2FtcGxlIGZ1bmN0aW9uIGFuZCB0aGUgY29udHJvbC5cbiAgICAgICAgaWYgKHNhbXBsZUxpbmVzW3NdICE9PSBjb250cm9sTGluZXNbY10pIHtcbiAgICAgICAgICAvLyBJbiBWOCwgdGhlIGZpcnN0IGxpbmUgaXMgZGVzY3JpYmluZyB0aGUgbWVzc2FnZSBidXQgb3RoZXIgVk1zIGRvbid0LlxuICAgICAgICAgIC8vIElmIHdlJ3JlIGFib3V0IHRvIHJldHVybiB0aGUgZmlyc3QgbGluZSwgYW5kIHRoZSBjb250cm9sIGlzIGFsc28gb24gdGhlIHNhbWVcbiAgICAgICAgICAvLyBsaW5lLCB0aGF0J3MgYSBwcmV0dHkgZ29vZCBpbmRpY2F0b3IgdGhhdCBvdXIgc2FtcGxlIHRocmV3IGF0IHNhbWUgbGluZSBhc1xuICAgICAgICAgIC8vIHRoZSBjb250cm9sLiBJLmUuIGJlZm9yZSB3ZSBlbnRlcmVkIHRoZSBzYW1wbGUgZnJhbWUuIFNvIHdlIGlnbm9yZSB0aGlzIHJlc3VsdC5cbiAgICAgICAgICAvLyBUaGlzIGNhbiBoYXBwZW4gaWYgeW91IHBhc3NlZCBhIGNsYXNzIHRvIGZ1bmN0aW9uIGNvbXBvbmVudCwgb3Igbm9uLWZ1bmN0aW9uLlxuICAgICAgICAgIGlmIChzICE9PSAxIHx8IGMgIT09IDEpIHtcbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgcy0tO1xuICAgICAgICAgICAgICBjLS07IC8vIFdlIG1heSBzdGlsbCBoYXZlIHNpbWlsYXIgaW50ZXJtZWRpYXRlIGZyYW1lcyBmcm9tIHRoZSBjb25zdHJ1Y3QgY2FsbC5cbiAgICAgICAgICAgICAgLy8gVGhlIG5leHQgb25lIHRoYXQgaXNuJ3QgdGhlIHNhbWUgc2hvdWxkIGJlIG91ciBtYXRjaCB0aG91Z2guXG5cbiAgICAgICAgICAgICAgaWYgKGMgPCAwIHx8IHNhbXBsZUxpbmVzW3NdICE9PSBjb250cm9sTGluZXNbY10pIHtcbiAgICAgICAgICAgICAgICAvLyBWOCBhZGRzIGEgXCJuZXdcIiBwcmVmaXggZm9yIG5hdGl2ZSBjbGFzc2VzLiBMZXQncyByZW1vdmUgaXQgdG8gbWFrZSBpdCBwcmV0dGllci5cbiAgICAgICAgICAgICAgICB2YXIgX2ZyYW1lID0gJ1xcbicgKyBzYW1wbGVMaW5lc1tzXS5yZXBsYWNlKCcgYXQgbmV3ICcsICcgYXQgJyk7XG5cbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudEZyYW1lQ2FjaGUuc2V0KGZuLCBfZnJhbWUpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gLy8gUmV0dXJuIHRoZSBsaW5lIHdlIGZvdW5kLlxuXG5cbiAgICAgICAgICAgICAgICByZXR1cm4gX2ZyYW1lO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IHdoaWxlIChzID49IDEgJiYgYyA+PSAwKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSBmaW5hbGx5IHtcbiAgICByZWVudHJ5ID0gZmFsc2U7XG5cbiAgICB7XG4gICAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyLmN1cnJlbnQgPSBwcmV2aW91c0Rpc3BhdGNoZXI7XG4gICAgICByZWVuYWJsZUxvZ3MoKTtcbiAgICB9XG5cbiAgICBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZSA9IHByZXZpb3VzUHJlcGFyZVN0YWNrVHJhY2U7XG4gIH0gLy8gRmFsbGJhY2sgdG8ganVzdCB1c2luZyB0aGUgbmFtZSBpZiB3ZSBjb3VsZG4ndCBtYWtlIGl0IHRocm93LlxuXG5cbiAgdmFyIG5hbWUgPSBmbiA/IGZuLmRpc3BsYXlOYW1lIHx8IGZuLm5hbWUgOiAnJztcbiAgdmFyIHN5bnRoZXRpY0ZyYW1lID0gbmFtZSA/IGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKG5hbWUpIDogJyc7XG5cbiAge1xuICAgIGlmICh0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNvbXBvbmVudEZyYW1lQ2FjaGUuc2V0KGZuLCBzeW50aGV0aWNGcmFtZSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHN5bnRoZXRpY0ZyYW1lO1xufVxuXG5mdW5jdGlvbiBkZXNjcmliZUNsYXNzQ29tcG9uZW50RnJhbWUoY3Rvciwgc291cmNlLCBvd25lckZuKSB7XG4gIHtcbiAgICByZXR1cm4gZGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZShjdG9yLCB0cnVlKTtcbiAgfVxufVxuZnVuY3Rpb24gZGVzY3JpYmVGdW5jdGlvbkNvbXBvbmVudEZyYW1lKGZuLCBzb3VyY2UsIG93bmVyRm4pIHtcbiAge1xuICAgIHJldHVybiBkZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lKGZuLCBmYWxzZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gc2hvdWxkQ29uc3RydWN0KENvbXBvbmVudCkge1xuICB2YXIgcHJvdG90eXBlID0gQ29tcG9uZW50LnByb3RvdHlwZTtcbiAgcmV0dXJuICEhKHByb3RvdHlwZSAmJiBwcm90b3R5cGUuaXNSZWFjdENvbXBvbmVudCk7XG59XG5cbmZ1bmN0aW9uIGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVih0eXBlLCBzb3VyY2UsIG93bmVyRm4pIHtcblxuICBpZiAodHlwZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAge1xuICAgICAgcmV0dXJuIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUodHlwZSwgc2hvdWxkQ29uc3RydWN0KHR5cGUpKTtcbiAgICB9XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKHR5cGUpO1xuICB9XG5cbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9UWVBFOlxuICAgICAgcmV0dXJuIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKCdTdXNwZW5zZScpO1xuXG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEU6XG4gICAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUoJ1N1c3BlbnNlTGlzdCcpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0Jykge1xuICAgIHN3aXRjaCAodHlwZS4kJHR5cGVvZikge1xuICAgICAgY2FzZSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFOlxuICAgICAgICByZXR1cm4gZGVzY3JpYmVGdW5jdGlvbkNvbXBvbmVudEZyYW1lKHR5cGUucmVuZGVyKTtcblxuICAgICAgY2FzZSBSRUFDVF9NRU1PX1RZUEU6XG4gICAgICAgIC8vIE1lbW8gbWF5IGNvbnRhaW4gYW55IGNvbXBvbmVudCB0eXBlIHNvIHdlIHJlY3Vyc2l2ZWx5IHJlc29sdmUgaXQuXG4gICAgICAgIHJldHVybiBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYodHlwZS50eXBlLCBzb3VyY2UsIG93bmVyRm4pO1xuXG4gICAgICBjYXNlIFJFQUNUX0JMT0NLX1RZUEU6XG4gICAgICAgIHJldHVybiBkZXNjcmliZUZ1bmN0aW9uQ29tcG9uZW50RnJhbWUodHlwZS5fcmVuZGVyKTtcblxuICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgbGF6eUNvbXBvbmVudCA9IHR5cGU7XG4gICAgICAgICAgdmFyIHBheWxvYWQgPSBsYXp5Q29tcG9uZW50Ll9wYXlsb2FkO1xuICAgICAgICAgIHZhciBpbml0ID0gbGF6eUNvbXBvbmVudC5faW5pdDtcblxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBMYXp5IG1heSBjb250YWluIGFueSBjb21wb25lbnQgdHlwZSBzbyB3ZSByZWN1cnNpdmVseSByZXNvbHZlIGl0LlxuICAgICAgICAgICAgcmV0dXJuIGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVihpbml0KHBheWxvYWQpLCBzb3VyY2UsIG93bmVyRm4pO1xuICAgICAgICAgIH0gY2F0Y2ggKHgpIHt9XG4gICAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gJyc7XG59XG5cbmZ1bmN0aW9uIGRlc2NyaWJlRmliZXIoZmliZXIpIHtcbiAgdmFyIG93bmVyID0gIGZpYmVyLl9kZWJ1Z093bmVyID8gZmliZXIuX2RlYnVnT3duZXIudHlwZSA6IG51bGwgO1xuICB2YXIgc291cmNlID0gIGZpYmVyLl9kZWJ1Z1NvdXJjZSA7XG5cbiAgc3dpdGNoIChmaWJlci50YWcpIHtcbiAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUoZmliZXIudHlwZSk7XG5cbiAgICBjYXNlIExhenlDb21wb25lbnQ6XG4gICAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUoJ0xhenknKTtcblxuICAgIGNhc2UgU3VzcGVuc2VDb21wb25lbnQ6XG4gICAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUoJ1N1c3BlbnNlJyk7XG5cbiAgICBjYXNlIFN1c3BlbnNlTGlzdENvbXBvbmVudDpcbiAgICAgIHJldHVybiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZSgnU3VzcGVuc2VMaXN0Jyk7XG5cbiAgICBjYXNlIEZ1bmN0aW9uQ29tcG9uZW50OlxuICAgIGNhc2UgSW5kZXRlcm1pbmF0ZUNvbXBvbmVudDpcbiAgICBjYXNlIFNpbXBsZU1lbW9Db21wb25lbnQ6XG4gICAgICByZXR1cm4gZGVzY3JpYmVGdW5jdGlvbkNvbXBvbmVudEZyYW1lKGZpYmVyLnR5cGUpO1xuXG4gICAgY2FzZSBGb3J3YXJkUmVmOlxuICAgICAgcmV0dXJuIGRlc2NyaWJlRnVuY3Rpb25Db21wb25lbnRGcmFtZShmaWJlci50eXBlLnJlbmRlcik7XG5cbiAgICBjYXNlIEJsb2NrOlxuICAgICAgcmV0dXJuIGRlc2NyaWJlRnVuY3Rpb25Db21wb25lbnRGcmFtZShmaWJlci50eXBlLl9yZW5kZXIpO1xuXG4gICAgY2FzZSBDbGFzc0NvbXBvbmVudDpcbiAgICAgIHJldHVybiBkZXNjcmliZUNsYXNzQ29tcG9uZW50RnJhbWUoZmliZXIudHlwZSk7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuICcnO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldFN0YWNrQnlGaWJlckluRGV2QW5kUHJvZCh3b3JrSW5Qcm9ncmVzcykge1xuICB0cnkge1xuICAgIHZhciBpbmZvID0gJyc7XG4gICAgdmFyIG5vZGUgPSB3b3JrSW5Qcm9ncmVzcztcblxuICAgIGRvIHtcbiAgICAgIGluZm8gKz0gZGVzY3JpYmVGaWJlcihub2RlKTtcbiAgICAgIG5vZGUgPSBub2RlLnJldHVybjtcbiAgICB9IHdoaWxlIChub2RlKTtcblxuICAgIHJldHVybiBpbmZvO1xuICB9IGNhdGNoICh4KSB7XG4gICAgcmV0dXJuICdcXG5FcnJvciBnZW5lcmF0aW5nIHN0YWNrOiAnICsgeC5tZXNzYWdlICsgJ1xcbicgKyB4LnN0YWNrO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldFdyYXBwZWROYW1lKG91dGVyVHlwZSwgaW5uZXJUeXBlLCB3cmFwcGVyTmFtZSkge1xuICB2YXIgZnVuY3Rpb25OYW1lID0gaW5uZXJUeXBlLmRpc3BsYXlOYW1lIHx8IGlubmVyVHlwZS5uYW1lIHx8ICcnO1xuICByZXR1cm4gb3V0ZXJUeXBlLmRpc3BsYXlOYW1lIHx8IChmdW5jdGlvbk5hbWUgIT09ICcnID8gd3JhcHBlck5hbWUgKyBcIihcIiArIGZ1bmN0aW9uTmFtZSArIFwiKVwiIDogd3JhcHBlck5hbWUpO1xufVxuXG5mdW5jdGlvbiBnZXRDb250ZXh0TmFtZSh0eXBlKSB7XG4gIHJldHVybiB0eXBlLmRpc3BsYXlOYW1lIHx8ICdDb250ZXh0Jztcbn1cblxuZnVuY3Rpb24gZ2V0Q29tcG9uZW50TmFtZSh0eXBlKSB7XG4gIGlmICh0eXBlID09IG51bGwpIHtcbiAgICAvLyBIb3N0IHJvb3QsIHRleHQgbm9kZSBvciBqdXN0IGludmFsaWQgdHlwZS5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHtcbiAgICBpZiAodHlwZW9mIHR5cGUudGFnID09PSAnbnVtYmVyJykge1xuICAgICAgZXJyb3IoJ1JlY2VpdmVkIGFuIHVuZXhwZWN0ZWQgb2JqZWN0IGluIGdldENvbXBvbmVudE5hbWUoKS4gJyArICdUaGlzIGlzIGxpa2VseSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIHR5cGUuZGlzcGxheU5hbWUgfHwgdHlwZS5uYW1lIHx8IG51bGw7XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHR5cGU7XG4gIH1cblxuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlIFJFQUNUX0ZSQUdNRU5UX1RZUEU6XG4gICAgICByZXR1cm4gJ0ZyYWdtZW50JztcblxuICAgIGNhc2UgUkVBQ1RfUE9SVEFMX1RZUEU6XG4gICAgICByZXR1cm4gJ1BvcnRhbCc7XG5cbiAgICBjYXNlIFJFQUNUX1BST0ZJTEVSX1RZUEU6XG4gICAgICByZXR1cm4gJ1Byb2ZpbGVyJztcblxuICAgIGNhc2UgUkVBQ1RfU1RSSUNUX01PREVfVFlQRTpcbiAgICAgIHJldHVybiAnU3RyaWN0TW9kZSc7XG5cbiAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX1RZUEU6XG4gICAgICByZXR1cm4gJ1N1c3BlbnNlJztcblxuICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFOlxuICAgICAgcmV0dXJuICdTdXNwZW5zZUxpc3QnO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0Jykge1xuICAgIHN3aXRjaCAodHlwZS4kJHR5cGVvZikge1xuICAgICAgY2FzZSBSRUFDVF9DT05URVhUX1RZUEU6XG4gICAgICAgIHZhciBjb250ZXh0ID0gdHlwZTtcbiAgICAgICAgcmV0dXJuIGdldENvbnRleHROYW1lKGNvbnRleHQpICsgJy5Db25zdW1lcic7XG5cbiAgICAgIGNhc2UgUkVBQ1RfUFJPVklERVJfVFlQRTpcbiAgICAgICAgdmFyIHByb3ZpZGVyID0gdHlwZTtcbiAgICAgICAgcmV0dXJuIGdldENvbnRleHROYW1lKHByb3ZpZGVyLl9jb250ZXh0KSArICcuUHJvdmlkZXInO1xuXG4gICAgICBjYXNlIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU6XG4gICAgICAgIHJldHVybiBnZXRXcmFwcGVkTmFtZSh0eXBlLCB0eXBlLnJlbmRlciwgJ0ZvcndhcmRSZWYnKTtcblxuICAgICAgY2FzZSBSRUFDVF9NRU1PX1RZUEU6XG4gICAgICAgIHJldHVybiBnZXRDb21wb25lbnROYW1lKHR5cGUudHlwZSk7XG5cbiAgICAgIGNhc2UgUkVBQ1RfQkxPQ0tfVFlQRTpcbiAgICAgICAgcmV0dXJuIGdldENvbXBvbmVudE5hbWUodHlwZS5fcmVuZGVyKTtcblxuICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgbGF6eUNvbXBvbmVudCA9IHR5cGU7XG4gICAgICAgICAgdmFyIHBheWxvYWQgPSBsYXp5Q29tcG9uZW50Ll9wYXlsb2FkO1xuICAgICAgICAgIHZhciBpbml0ID0gbGF6eUNvbXBvbmVudC5faW5pdDtcblxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0Q29tcG9uZW50TmFtZShpbml0KHBheWxvYWQpKTtcbiAgICAgICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxudmFyIFJlYWN0RGVidWdDdXJyZW50RnJhbWUgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdERlYnVnQ3VycmVudEZyYW1lO1xudmFyIGN1cnJlbnQgPSBudWxsO1xudmFyIGlzUmVuZGVyaW5nID0gZmFsc2U7XG5mdW5jdGlvbiBnZXRDdXJyZW50RmliZXJPd25lck5hbWVJbkRldk9yTnVsbCgpIHtcbiAge1xuICAgIGlmIChjdXJyZW50ID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgb3duZXIgPSBjdXJyZW50Ll9kZWJ1Z093bmVyO1xuXG4gICAgaWYgKG93bmVyICE9PSBudWxsICYmIHR5cGVvZiBvd25lciAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHJldHVybiBnZXRDb21wb25lbnROYW1lKG93bmVyLnR5cGUpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiBnZXRDdXJyZW50RmliZXJTdGFja0luRGV2KCkge1xuICB7XG4gICAgaWYgKGN1cnJlbnQgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiAnJztcbiAgICB9IC8vIFNhZmUgYmVjYXVzZSBpZiBjdXJyZW50IGZpYmVyIGV4aXN0cywgd2UgYXJlIHJlY29uY2lsaW5nLFxuICAgIC8vIGFuZCBpdCBpcyBndWFyYW50ZWVkIHRvIGJlIHRoZSB3b3JrLWluLXByb2dyZXNzIHZlcnNpb24uXG5cblxuICAgIHJldHVybiBnZXRTdGFja0J5RmliZXJJbkRldkFuZFByb2QoY3VycmVudCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVzZXRDdXJyZW50RmliZXIoKSB7XG4gIHtcbiAgICBSZWFjdERlYnVnQ3VycmVudEZyYW1lLmdldEN1cnJlbnRTdGFjayA9IG51bGw7XG4gICAgY3VycmVudCA9IG51bGw7XG4gICAgaXNSZW5kZXJpbmcgPSBmYWxzZTtcbiAgfVxufVxuZnVuY3Rpb24gc2V0Q3VycmVudEZpYmVyKGZpYmVyKSB7XG4gIHtcbiAgICBSZWFjdERlYnVnQ3VycmVudEZyYW1lLmdldEN1cnJlbnRTdGFjayA9IGdldEN1cnJlbnRGaWJlclN0YWNrSW5EZXY7XG4gICAgY3VycmVudCA9IGZpYmVyO1xuICAgIGlzUmVuZGVyaW5nID0gZmFsc2U7XG4gIH1cbn1cbmZ1bmN0aW9uIHNldElzUmVuZGVyaW5nKHJlbmRlcmluZykge1xuICB7XG4gICAgaXNSZW5kZXJpbmcgPSByZW5kZXJpbmc7XG4gIH1cbn1cbmZ1bmN0aW9uIGdldElzUmVuZGVyaW5nKCkge1xuICB7XG4gICAgcmV0dXJuIGlzUmVuZGVyaW5nO1xuICB9XG59XG5cbi8vIEZsb3cgZG9lcyBub3QgYWxsb3cgc3RyaW5nIGNvbmNhdGVuYXRpb24gb2YgbW9zdCBub24tc3RyaW5nIHR5cGVzLiBUbyB3b3JrXG4vLyBhcm91bmQgdGhpcyBsaW1pdGF0aW9uLCB3ZSB1c2UgYW4gb3BhcXVlIHR5cGUgdGhhdCBjYW4gb25seSBiZSBvYnRhaW5lZCBieVxuLy8gcGFzc2luZyB0aGUgdmFsdWUgdGhyb3VnaCBnZXRUb1N0cmluZ1ZhbHVlIGZpcnN0LlxuZnVuY3Rpb24gdG9TdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuICcnICsgdmFsdWU7XG59XG5mdW5jdGlvbiBnZXRUb1N0cmluZ1ZhbHVlKHZhbHVlKSB7XG4gIHN3aXRjaCAodHlwZW9mIHZhbHVlKSB7XG4gICAgY2FzZSAnYm9vbGVhbic6XG4gICAgY2FzZSAnbnVtYmVyJzpcbiAgICBjYXNlICdvYmplY3QnOlxuICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgY2FzZSAndW5kZWZpbmVkJzpcbiAgICAgIHJldHVybiB2YWx1ZTtcblxuICAgIGRlZmF1bHQ6XG4gICAgICAvLyBmdW5jdGlvbiwgc3ltYm9sIGFyZSBhc3NpZ25lZCBhcyBlbXB0eSBzdHJpbmdzXG4gICAgICByZXR1cm4gJyc7XG4gIH1cbn1cblxudmFyIGhhc1JlYWRPbmx5VmFsdWUgPSB7XG4gIGJ1dHRvbjogdHJ1ZSxcbiAgY2hlY2tib3g6IHRydWUsXG4gIGltYWdlOiB0cnVlLFxuICBoaWRkZW46IHRydWUsXG4gIHJhZGlvOiB0cnVlLFxuICByZXNldDogdHJ1ZSxcbiAgc3VibWl0OiB0cnVlXG59O1xuZnVuY3Rpb24gY2hlY2tDb250cm9sbGVkVmFsdWVQcm9wcyh0YWdOYW1lLCBwcm9wcykge1xuICB7XG4gICAgaWYgKCEoaGFzUmVhZE9ubHlWYWx1ZVtwcm9wcy50eXBlXSB8fCBwcm9wcy5vbkNoYW5nZSB8fCBwcm9wcy5vbklucHV0IHx8IHByb3BzLnJlYWRPbmx5IHx8IHByb3BzLmRpc2FibGVkIHx8IHByb3BzLnZhbHVlID09IG51bGwpKSB7XG4gICAgICBlcnJvcignWW91IHByb3ZpZGVkIGEgYHZhbHVlYCBwcm9wIHRvIGEgZm9ybSBmaWVsZCB3aXRob3V0IGFuICcgKyAnYG9uQ2hhbmdlYCBoYW5kbGVyLiBUaGlzIHdpbGwgcmVuZGVyIGEgcmVhZC1vbmx5IGZpZWxkLiBJZiAnICsgJ3RoZSBmaWVsZCBzaG91bGQgYmUgbXV0YWJsZSB1c2UgYGRlZmF1bHRWYWx1ZWAuIE90aGVyd2lzZSwgJyArICdzZXQgZWl0aGVyIGBvbkNoYW5nZWAgb3IgYHJlYWRPbmx5YC4nKTtcbiAgICB9XG5cbiAgICBpZiAoIShwcm9wcy5vbkNoYW5nZSB8fCBwcm9wcy5yZWFkT25seSB8fCBwcm9wcy5kaXNhYmxlZCB8fCBwcm9wcy5jaGVja2VkID09IG51bGwpKSB7XG4gICAgICBlcnJvcignWW91IHByb3ZpZGVkIGEgYGNoZWNrZWRgIHByb3AgdG8gYSBmb3JtIGZpZWxkIHdpdGhvdXQgYW4gJyArICdgb25DaGFuZ2VgIGhhbmRsZXIuIFRoaXMgd2lsbCByZW5kZXIgYSByZWFkLW9ubHkgZmllbGQuIElmICcgKyAndGhlIGZpZWxkIHNob3VsZCBiZSBtdXRhYmxlIHVzZSBgZGVmYXVsdENoZWNrZWRgLiBPdGhlcndpc2UsICcgKyAnc2V0IGVpdGhlciBgb25DaGFuZ2VgIG9yIGByZWFkT25seWAuJyk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGlzQ2hlY2thYmxlKGVsZW0pIHtcbiAgdmFyIHR5cGUgPSBlbGVtLnR5cGU7XG4gIHZhciBub2RlTmFtZSA9IGVsZW0ubm9kZU5hbWU7XG4gIHJldHVybiBub2RlTmFtZSAmJiBub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSAnaW5wdXQnICYmICh0eXBlID09PSAnY2hlY2tib3gnIHx8IHR5cGUgPT09ICdyYWRpbycpO1xufVxuXG5mdW5jdGlvbiBnZXRUcmFja2VyKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUuX3ZhbHVlVHJhY2tlcjtcbn1cblxuZnVuY3Rpb24gZGV0YWNoVHJhY2tlcihub2RlKSB7XG4gIG5vZGUuX3ZhbHVlVHJhY2tlciA9IG51bGw7XG59XG5cbmZ1bmN0aW9uIGdldFZhbHVlRnJvbU5vZGUobm9kZSkge1xuICB2YXIgdmFsdWUgPSAnJztcblxuICBpZiAoIW5vZGUpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cblxuICBpZiAoaXNDaGVja2FibGUobm9kZSkpIHtcbiAgICB2YWx1ZSA9IG5vZGUuY2hlY2tlZCA/ICd0cnVlJyA6ICdmYWxzZSc7XG4gIH0gZWxzZSB7XG4gICAgdmFsdWUgPSBub2RlLnZhbHVlO1xuICB9XG5cbiAgcmV0dXJuIHZhbHVlO1xufVxuXG5mdW5jdGlvbiB0cmFja1ZhbHVlT25Ob2RlKG5vZGUpIHtcbiAgdmFyIHZhbHVlRmllbGQgPSBpc0NoZWNrYWJsZShub2RlKSA/ICdjaGVja2VkJyA6ICd2YWx1ZSc7XG4gIHZhciBkZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihub2RlLmNvbnN0cnVjdG9yLnByb3RvdHlwZSwgdmFsdWVGaWVsZCk7XG4gIHZhciBjdXJyZW50VmFsdWUgPSAnJyArIG5vZGVbdmFsdWVGaWVsZF07IC8vIGlmIHNvbWVvbmUgaGFzIGFscmVhZHkgZGVmaW5lZCBhIHZhbHVlIG9yIFNhZmFyaSwgdGhlbiBiYWlsXG4gIC8vIGFuZCBkb24ndCB0cmFjayB2YWx1ZSB3aWxsIGNhdXNlIG92ZXIgcmVwb3J0aW5nIG9mIGNoYW5nZXMsXG4gIC8vIGJ1dCBpdCdzIGJldHRlciB0aGVuIGEgaGFyZCBmYWlsdXJlXG4gIC8vIChuZWVkZWQgZm9yIGNlcnRhaW4gdGVzdHMgdGhhdCBzcHlPbiBpbnB1dCB2YWx1ZXMgYW5kIFNhZmFyaSlcblxuICBpZiAobm9kZS5oYXNPd25Qcm9wZXJ0eSh2YWx1ZUZpZWxkKSB8fCB0eXBlb2YgZGVzY3JpcHRvciA9PT0gJ3VuZGVmaW5lZCcgfHwgdHlwZW9mIGRlc2NyaXB0b3IuZ2V0ICE9PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBkZXNjcmlwdG9yLnNldCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBnZXQgPSBkZXNjcmlwdG9yLmdldCxcbiAgICAgIHNldCA9IGRlc2NyaXB0b3Iuc2V0O1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkobm9kZSwgdmFsdWVGaWVsZCwge1xuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBnZXQuY2FsbCh0aGlzKTtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICBjdXJyZW50VmFsdWUgPSAnJyArIHZhbHVlO1xuICAgICAgc2V0LmNhbGwodGhpcywgdmFsdWUpO1xuICAgIH1cbiAgfSk7IC8vIFdlIGNvdWxkJ3ZlIHBhc3NlZCB0aGlzIHRoZSBmaXJzdCB0aW1lXG4gIC8vIGJ1dCBpdCB0cmlnZ2VycyBhIGJ1ZyBpbiBJRTExIGFuZCBFZGdlIDE0LzE1LlxuICAvLyBDYWxsaW5nIGRlZmluZVByb3BlcnR5KCkgYWdhaW4gc2hvdWxkIGJlIGVxdWl2YWxlbnQuXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTE3NjhcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkobm9kZSwgdmFsdWVGaWVsZCwge1xuICAgIGVudW1lcmFibGU6IGRlc2NyaXB0b3IuZW51bWVyYWJsZVxuICB9KTtcbiAgdmFyIHRyYWNrZXIgPSB7XG4gICAgZ2V0VmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBjdXJyZW50VmFsdWU7XG4gICAgfSxcbiAgICBzZXRWYWx1ZTogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICBjdXJyZW50VmFsdWUgPSAnJyArIHZhbHVlO1xuICAgIH0sXG4gICAgc3RvcFRyYWNraW5nOiBmdW5jdGlvbiAoKSB7XG4gICAgICBkZXRhY2hUcmFja2VyKG5vZGUpO1xuICAgICAgZGVsZXRlIG5vZGVbdmFsdWVGaWVsZF07XG4gICAgfVxuICB9O1xuICByZXR1cm4gdHJhY2tlcjtcbn1cblxuZnVuY3Rpb24gdHJhY2sobm9kZSkge1xuICBpZiAoZ2V0VHJhY2tlcihub2RlKSkge1xuICAgIHJldHVybjtcbiAgfSAvLyBUT0RPOiBPbmNlIGl0J3MganVzdCBGaWJlciB3ZSBjYW4gbW92ZSB0aGlzIHRvIG5vZGUuX3dyYXBwZXJTdGF0ZVxuXG5cbiAgbm9kZS5fdmFsdWVUcmFja2VyID0gdHJhY2tWYWx1ZU9uTm9kZShub2RlKTtcbn1cbmZ1bmN0aW9uIHVwZGF0ZVZhbHVlSWZDaGFuZ2VkKG5vZGUpIHtcbiAgaWYgKCFub2RlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIHRyYWNrZXIgPSBnZXRUcmFja2VyKG5vZGUpOyAvLyBpZiB0aGVyZSBpcyBubyB0cmFja2VyIGF0IHRoaXMgcG9pbnQgaXQncyB1bmxpa2VseVxuICAvLyB0aGF0IHRyeWluZyBhZ2FpbiB3aWxsIHN1Y2NlZWRcblxuICBpZiAoIXRyYWNrZXIpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHZhciBsYXN0VmFsdWUgPSB0cmFja2VyLmdldFZhbHVlKCk7XG4gIHZhciBuZXh0VmFsdWUgPSBnZXRWYWx1ZUZyb21Ob2RlKG5vZGUpO1xuXG4gIGlmIChuZXh0VmFsdWUgIT09IGxhc3RWYWx1ZSkge1xuICAgIHRyYWNrZXIuc2V0VmFsdWUobmV4dFZhbHVlKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gZ2V0QWN0aXZlRWxlbWVudChkb2MpIHtcbiAgZG9jID0gZG9jIHx8ICh0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnID8gZG9jdW1lbnQgOiB1bmRlZmluZWQpO1xuXG4gIGlmICh0eXBlb2YgZG9jID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdHJ5IHtcbiAgICByZXR1cm4gZG9jLmFjdGl2ZUVsZW1lbnQgfHwgZG9jLmJvZHk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZG9jLmJvZHk7XG4gIH1cbn1cblxudmFyIGRpZFdhcm5WYWx1ZURlZmF1bHRWYWx1ZSA9IGZhbHNlO1xudmFyIGRpZFdhcm5DaGVja2VkRGVmYXVsdENoZWNrZWQgPSBmYWxzZTtcbnZhciBkaWRXYXJuQ29udHJvbGxlZFRvVW5jb250cm9sbGVkID0gZmFsc2U7XG52YXIgZGlkV2FyblVuY29udHJvbGxlZFRvQ29udHJvbGxlZCA9IGZhbHNlO1xuXG5mdW5jdGlvbiBpc0NvbnRyb2xsZWQocHJvcHMpIHtcbiAgdmFyIHVzZXNDaGVja2VkID0gcHJvcHMudHlwZSA9PT0gJ2NoZWNrYm94JyB8fCBwcm9wcy50eXBlID09PSAncmFkaW8nO1xuICByZXR1cm4gdXNlc0NoZWNrZWQgPyBwcm9wcy5jaGVja2VkICE9IG51bGwgOiBwcm9wcy52YWx1ZSAhPSBudWxsO1xufVxuLyoqXG4gKiBJbXBsZW1lbnRzIGFuIDxpbnB1dD4gaG9zdCBjb21wb25lbnQgdGhhdCBhbGxvd3Mgc2V0dGluZyB0aGVzZSBvcHRpb25hbFxuICogcHJvcHM6IGBjaGVja2VkYCwgYHZhbHVlYCwgYGRlZmF1bHRDaGVja2VkYCwgYW5kIGBkZWZhdWx0VmFsdWVgLlxuICpcbiAqIElmIGBjaGVja2VkYCBvciBgdmFsdWVgIGFyZSBub3Qgc3VwcGxpZWQgKG9yIG51bGwvdW5kZWZpbmVkKSwgdXNlciBhY3Rpb25zXG4gKiB0aGF0IGFmZmVjdCB0aGUgY2hlY2tlZCBzdGF0ZSBvciB2YWx1ZSB3aWxsIHRyaWdnZXIgdXBkYXRlcyB0byB0aGUgZWxlbWVudC5cbiAqXG4gKiBJZiB0aGV5IGFyZSBzdXBwbGllZCAoYW5kIG5vdCBudWxsL3VuZGVmaW5lZCksIHRoZSByZW5kZXJlZCBlbGVtZW50IHdpbGwgbm90XG4gKiB0cmlnZ2VyIHVwZGF0ZXMgdG8gdGhlIGVsZW1lbnQuIEluc3RlYWQsIHRoZSBwcm9wcyBtdXN0IGNoYW5nZSBpbiBvcmRlciBmb3JcbiAqIHRoZSByZW5kZXJlZCBlbGVtZW50IHRvIGJlIHVwZGF0ZWQuXG4gKlxuICogVGhlIHJlbmRlcmVkIGVsZW1lbnQgd2lsbCBiZSBpbml0aWFsaXplZCBhcyB1bmNoZWNrZWQgKG9yIGBkZWZhdWx0Q2hlY2tlZGApXG4gKiB3aXRoIGFuIGVtcHR5IHZhbHVlIChvciBgZGVmYXVsdFZhbHVlYCkuXG4gKlxuICogU2VlIGh0dHA6Ly93d3cudzMub3JnL1RSLzIwMTIvV0QtaHRtbDUtMjAxMjEwMjUvdGhlLWlucHV0LWVsZW1lbnQuaHRtbFxuICovXG5cblxuZnVuY3Rpb24gZ2V0SG9zdFByb3BzKGVsZW1lbnQsIHByb3BzKSB7XG4gIHZhciBub2RlID0gZWxlbWVudDtcbiAgdmFyIGNoZWNrZWQgPSBwcm9wcy5jaGVja2VkO1xuXG4gIHZhciBob3N0UHJvcHMgPSBfYXNzaWduKHt9LCBwcm9wcywge1xuICAgIGRlZmF1bHRDaGVja2VkOiB1bmRlZmluZWQsXG4gICAgZGVmYXVsdFZhbHVlOiB1bmRlZmluZWQsXG4gICAgdmFsdWU6IHVuZGVmaW5lZCxcbiAgICBjaGVja2VkOiBjaGVja2VkICE9IG51bGwgPyBjaGVja2VkIDogbm9kZS5fd3JhcHBlclN0YXRlLmluaXRpYWxDaGVja2VkXG4gIH0pO1xuXG4gIHJldHVybiBob3N0UHJvcHM7XG59XG5mdW5jdGlvbiBpbml0V3JhcHBlclN0YXRlKGVsZW1lbnQsIHByb3BzKSB7XG4gIHtcbiAgICBjaGVja0NvbnRyb2xsZWRWYWx1ZVByb3BzKCdpbnB1dCcsIHByb3BzKTtcblxuICAgIGlmIChwcm9wcy5jaGVja2VkICE9PSB1bmRlZmluZWQgJiYgcHJvcHMuZGVmYXVsdENoZWNrZWQgIT09IHVuZGVmaW5lZCAmJiAhZGlkV2FybkNoZWNrZWREZWZhdWx0Q2hlY2tlZCkge1xuICAgICAgZXJyb3IoJyVzIGNvbnRhaW5zIGFuIGlucHV0IG9mIHR5cGUgJXMgd2l0aCBib3RoIGNoZWNrZWQgYW5kIGRlZmF1bHRDaGVja2VkIHByb3BzLiAnICsgJ0lucHV0IGVsZW1lbnRzIG11c3QgYmUgZWl0aGVyIGNvbnRyb2xsZWQgb3IgdW5jb250cm9sbGVkICcgKyAnKHNwZWNpZnkgZWl0aGVyIHRoZSBjaGVja2VkIHByb3AsIG9yIHRoZSBkZWZhdWx0Q2hlY2tlZCBwcm9wLCBidXQgbm90ICcgKyAnYm90aCkuIERlY2lkZSBiZXR3ZWVuIHVzaW5nIGEgY29udHJvbGxlZCBvciB1bmNvbnRyb2xsZWQgaW5wdXQgJyArICdlbGVtZW50IGFuZCByZW1vdmUgb25lIG9mIHRoZXNlIHByb3BzLiBNb3JlIGluZm86ICcgKyAnaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL2NvbnRyb2xsZWQtY29tcG9uZW50cycsIGdldEN1cnJlbnRGaWJlck93bmVyTmFtZUluRGV2T3JOdWxsKCkgfHwgJ0EgY29tcG9uZW50JywgcHJvcHMudHlwZSk7XG5cbiAgICAgIGRpZFdhcm5DaGVja2VkRGVmYXVsdENoZWNrZWQgPSB0cnVlO1xuICAgIH1cblxuICAgIGlmIChwcm9wcy52YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHByb3BzLmRlZmF1bHRWYWx1ZSAhPT0gdW5kZWZpbmVkICYmICFkaWRXYXJuVmFsdWVEZWZhdWx0VmFsdWUpIHtcbiAgICAgIGVycm9yKCclcyBjb250YWlucyBhbiBpbnB1dCBvZiB0eXBlICVzIHdpdGggYm90aCB2YWx1ZSBhbmQgZGVmYXVsdFZhbHVlIHByb3BzLiAnICsgJ0lucHV0IGVsZW1lbnRzIG11c3QgYmUgZWl0aGVyIGNvbnRyb2xsZWQgb3IgdW5jb250cm9sbGVkICcgKyAnKHNwZWNpZnkgZWl0aGVyIHRoZSB2YWx1ZSBwcm9wLCBvciB0aGUgZGVmYXVsdFZhbHVlIHByb3AsIGJ1dCBub3QgJyArICdib3RoKS4gRGVjaWRlIGJldHdlZW4gdXNpbmcgYSBjb250cm9sbGVkIG9yIHVuY29udHJvbGxlZCBpbnB1dCAnICsgJ2VsZW1lbnQgYW5kIHJlbW92ZSBvbmUgb2YgdGhlc2UgcHJvcHMuIE1vcmUgaW5mbzogJyArICdodHRwczovL3JlYWN0anMub3JnL2xpbmsvY29udHJvbGxlZC1jb21wb25lbnRzJywgZ2V0Q3VycmVudEZpYmVyT3duZXJOYW1lSW5EZXZPck51bGwoKSB8fCAnQSBjb21wb25lbnQnLCBwcm9wcy50eXBlKTtcblxuICAgICAgZGlkV2FyblZhbHVlRGVmYXVsdFZhbHVlID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICB2YXIgbm9kZSA9IGVsZW1lbnQ7XG4gIHZhciBkZWZhdWx0VmFsdWUgPSBwcm9wcy5kZWZhdWx0VmFsdWUgPT0gbnVsbCA/ICcnIDogcHJvcHMuZGVmYXVsdFZhbHVlO1xuICBub2RlLl93cmFwcGVyU3RhdGUgPSB7XG4gICAgaW5pdGlhbENoZWNrZWQ6IHByb3BzLmNoZWNrZWQgIT0gbnVsbCA/IHByb3BzLmNoZWNrZWQgOiBwcm9wcy5kZWZhdWx0Q2hlY2tlZCxcbiAgICBpbml0aWFsVmFsdWU6IGdldFRvU3RyaW5nVmFsdWUocHJvcHMudmFsdWUgIT0gbnVsbCA/IHByb3BzLnZhbHVlIDogZGVmYXVsdFZhbHVlKSxcbiAgICBjb250cm9sbGVkOiBpc0NvbnRyb2xsZWQocHJvcHMpXG4gIH07XG59XG5mdW5jdGlvbiB1cGRhdGVDaGVja2VkKGVsZW1lbnQsIHByb3BzKSB7XG4gIHZhciBub2RlID0gZWxlbWVudDtcbiAgdmFyIGNoZWNrZWQgPSBwcm9wcy5jaGVja2VkO1xuXG4gIGlmIChjaGVja2VkICE9IG51bGwpIHtcbiAgICBzZXRWYWx1ZUZvclByb3BlcnR5KG5vZGUsICdjaGVja2VkJywgY2hlY2tlZCwgZmFsc2UpO1xuICB9XG59XG5mdW5jdGlvbiB1cGRhdGVXcmFwcGVyKGVsZW1lbnQsIHByb3BzKSB7XG4gIHZhciBub2RlID0gZWxlbWVudDtcblxuICB7XG4gICAgdmFyIGNvbnRyb2xsZWQgPSBpc0NvbnRyb2xsZWQocHJvcHMpO1xuXG4gICAgaWYgKCFub2RlLl93cmFwcGVyU3RhdGUuY29udHJvbGxlZCAmJiBjb250cm9sbGVkICYmICFkaWRXYXJuVW5jb250cm9sbGVkVG9Db250cm9sbGVkKSB7XG4gICAgICBlcnJvcignQSBjb21wb25lbnQgaXMgY2hhbmdpbmcgYW4gdW5jb250cm9sbGVkIGlucHV0IHRvIGJlIGNvbnRyb2xsZWQuICcgKyAnVGhpcyBpcyBsaWtlbHkgY2F1c2VkIGJ5IHRoZSB2YWx1ZSBjaGFuZ2luZyBmcm9tIHVuZGVmaW5lZCB0byAnICsgJ2EgZGVmaW5lZCB2YWx1ZSwgd2hpY2ggc2hvdWxkIG5vdCBoYXBwZW4uICcgKyAnRGVjaWRlIGJldHdlZW4gdXNpbmcgYSBjb250cm9sbGVkIG9yIHVuY29udHJvbGxlZCBpbnB1dCAnICsgJ2VsZW1lbnQgZm9yIHRoZSBsaWZldGltZSBvZiB0aGUgY29tcG9uZW50LiBNb3JlIGluZm86IGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9jb250cm9sbGVkLWNvbXBvbmVudHMnKTtcblxuICAgICAgZGlkV2FyblVuY29udHJvbGxlZFRvQ29udHJvbGxlZCA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKG5vZGUuX3dyYXBwZXJTdGF0ZS5jb250cm9sbGVkICYmICFjb250cm9sbGVkICYmICFkaWRXYXJuQ29udHJvbGxlZFRvVW5jb250cm9sbGVkKSB7XG4gICAgICBlcnJvcignQSBjb21wb25lbnQgaXMgY2hhbmdpbmcgYSBjb250cm9sbGVkIGlucHV0IHRvIGJlIHVuY29udHJvbGxlZC4gJyArICdUaGlzIGlzIGxpa2VseSBjYXVzZWQgYnkgdGhlIHZhbHVlIGNoYW5naW5nIGZyb20gYSBkZWZpbmVkIHRvICcgKyAndW5kZWZpbmVkLCB3aGljaCBzaG91bGQgbm90IGhhcHBlbi4gJyArICdEZWNpZGUgYmV0d2VlbiB1c2luZyBhIGNvbnRyb2xsZWQgb3IgdW5jb250cm9sbGVkIGlucHV0ICcgKyAnZWxlbWVudCBmb3IgdGhlIGxpZmV0aW1lIG9mIHRoZSBjb21wb25lbnQuIE1vcmUgaW5mbzogaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL2NvbnRyb2xsZWQtY29tcG9uZW50cycpO1xuXG4gICAgICBkaWRXYXJuQ29udHJvbGxlZFRvVW5jb250cm9sbGVkID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICB1cGRhdGVDaGVja2VkKGVsZW1lbnQsIHByb3BzKTtcbiAgdmFyIHZhbHVlID0gZ2V0VG9TdHJpbmdWYWx1ZShwcm9wcy52YWx1ZSk7XG4gIHZhciB0eXBlID0gcHJvcHMudHlwZTtcblxuICBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgIGlmICh0eXBlID09PSAnbnVtYmVyJykge1xuICAgICAgaWYgKHZhbHVlID09PSAwICYmIG5vZGUudmFsdWUgPT09ICcnIHx8IC8vIFdlIGV4cGxpY2l0bHkgd2FudCB0byBjb2VyY2UgdG8gbnVtYmVyIGhlcmUgaWYgcG9zc2libGUuXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgICAgIG5vZGUudmFsdWUgIT0gdmFsdWUpIHtcbiAgICAgICAgbm9kZS52YWx1ZSA9IHRvU3RyaW5nKHZhbHVlKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG5vZGUudmFsdWUgIT09IHRvU3RyaW5nKHZhbHVlKSkge1xuICAgICAgbm9kZS52YWx1ZSA9IHRvU3RyaW5nKHZhbHVlKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gJ3N1Ym1pdCcgfHwgdHlwZSA9PT0gJ3Jlc2V0Jykge1xuICAgIC8vIFN1Ym1pdC9yZXNldCBpbnB1dHMgbmVlZCB0aGUgYXR0cmlidXRlIHJlbW92ZWQgY29tcGxldGVseSB0byBhdm9pZFxuICAgIC8vIGJsYW5rLXRleHQgYnV0dG9ucy5cbiAgICBub2RlLnJlbW92ZUF0dHJpYnV0ZSgndmFsdWUnKTtcbiAgICByZXR1cm47XG4gIH1cblxuICB7XG4gICAgLy8gV2hlbiBzeW5jaW5nIHRoZSB2YWx1ZSBhdHRyaWJ1dGUsIHRoZSB2YWx1ZSBjb21lcyBmcm9tIGEgY2FzY2FkZSBvZlxuICAgIC8vIHByb3BlcnRpZXM6XG4gICAgLy8gIDEuIFRoZSB2YWx1ZSBSZWFjdCBwcm9wZXJ0eVxuICAgIC8vICAyLiBUaGUgZGVmYXVsdFZhbHVlIFJlYWN0IHByb3BlcnR5XG4gICAgLy8gIDMuIE90aGVyd2lzZSB0aGVyZSBzaG91bGQgYmUgbm8gY2hhbmdlXG4gICAgaWYgKHByb3BzLmhhc093blByb3BlcnR5KCd2YWx1ZScpKSB7XG4gICAgICBzZXREZWZhdWx0VmFsdWUobm9kZSwgcHJvcHMudHlwZSwgdmFsdWUpO1xuICAgIH0gZWxzZSBpZiAocHJvcHMuaGFzT3duUHJvcGVydHkoJ2RlZmF1bHRWYWx1ZScpKSB7XG4gICAgICBzZXREZWZhdWx0VmFsdWUobm9kZSwgcHJvcHMudHlwZSwgZ2V0VG9TdHJpbmdWYWx1ZShwcm9wcy5kZWZhdWx0VmFsdWUpKTtcbiAgICB9XG4gIH1cblxuICB7XG4gICAgLy8gV2hlbiBzeW5jaW5nIHRoZSBjaGVja2VkIGF0dHJpYnV0ZSwgaXQgb25seSBjaGFuZ2VzIHdoZW4gaXQgbmVlZHNcbiAgICAvLyB0byBiZSByZW1vdmVkLCBzdWNoIGFzIHRyYW5zaXRpb25pbmcgZnJvbSBhIGNoZWNrYm94IGludG8gYSB0ZXh0IGlucHV0XG4gICAgaWYgKHByb3BzLmNoZWNrZWQgPT0gbnVsbCAmJiBwcm9wcy5kZWZhdWx0Q2hlY2tlZCAhPSBudWxsKSB7XG4gICAgICBub2RlLmRlZmF1bHRDaGVja2VkID0gISFwcm9wcy5kZWZhdWx0Q2hlY2tlZDtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIHBvc3RNb3VudFdyYXBwZXIoZWxlbWVudCwgcHJvcHMsIGlzSHlkcmF0aW5nKSB7XG4gIHZhciBub2RlID0gZWxlbWVudDsgLy8gRG8gbm90IGFzc2lnbiB2YWx1ZSBpZiBpdCBpcyBhbHJlYWR5IHNldC4gVGhpcyBwcmV2ZW50cyB1c2VyIHRleHQgaW5wdXRcbiAgLy8gZnJvbSBiZWluZyBsb3N0IGR1cmluZyBTU1IgaHlkcmF0aW9uLlxuXG4gIGlmIChwcm9wcy5oYXNPd25Qcm9wZXJ0eSgndmFsdWUnKSB8fCBwcm9wcy5oYXNPd25Qcm9wZXJ0eSgnZGVmYXVsdFZhbHVlJykpIHtcbiAgICB2YXIgdHlwZSA9IHByb3BzLnR5cGU7XG4gICAgdmFyIGlzQnV0dG9uID0gdHlwZSA9PT0gJ3N1Ym1pdCcgfHwgdHlwZSA9PT0gJ3Jlc2V0JzsgLy8gQXZvaWQgc2V0dGluZyB2YWx1ZSBhdHRyaWJ1dGUgb24gc3VibWl0L3Jlc2V0IGlucHV0cyBhcyBpdCBvdmVycmlkZXMgdGhlXG4gICAgLy8gZGVmYXVsdCB2YWx1ZSBwcm92aWRlZCBieSB0aGUgYnJvd3Nlci4gU2VlOiAjMTI4NzJcblxuICAgIGlmIChpc0J1dHRvbiAmJiAocHJvcHMudmFsdWUgPT09IHVuZGVmaW5lZCB8fCBwcm9wcy52YWx1ZSA9PT0gbnVsbCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgaW5pdGlhbFZhbHVlID0gdG9TdHJpbmcobm9kZS5fd3JhcHBlclN0YXRlLmluaXRpYWxWYWx1ZSk7IC8vIERvIG5vdCBhc3NpZ24gdmFsdWUgaWYgaXQgaXMgYWxyZWFkeSBzZXQuIFRoaXMgcHJldmVudHMgdXNlciB0ZXh0IGlucHV0XG4gICAgLy8gZnJvbSBiZWluZyBsb3N0IGR1cmluZyBTU1IgaHlkcmF0aW9uLlxuXG4gICAgaWYgKCFpc0h5ZHJhdGluZykge1xuICAgICAge1xuICAgICAgICAvLyBXaGVuIHN5bmNpbmcgdGhlIHZhbHVlIGF0dHJpYnV0ZSwgdGhlIHZhbHVlIHByb3BlcnR5IHNob3VsZCB1c2VcbiAgICAgICAgLy8gdGhlIHdyYXBwZXJTdGF0ZS5faW5pdGlhbFZhbHVlIHByb3BlcnR5LiBUaGlzIHVzZXM6XG4gICAgICAgIC8vXG4gICAgICAgIC8vICAgMS4gVGhlIHZhbHVlIFJlYWN0IHByb3BlcnR5IHdoZW4gcHJlc2VudFxuICAgICAgICAvLyAgIDIuIFRoZSBkZWZhdWx0VmFsdWUgUmVhY3QgcHJvcGVydHkgd2hlbiBwcmVzZW50XG4gICAgICAgIC8vICAgMy4gQW4gZW1wdHkgc3RyaW5nXG4gICAgICAgIGlmIChpbml0aWFsVmFsdWUgIT09IG5vZGUudmFsdWUpIHtcbiAgICAgICAgICBub2RlLnZhbHVlID0gaW5pdGlhbFZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAge1xuICAgICAgLy8gT3RoZXJ3aXNlLCB0aGUgdmFsdWUgYXR0cmlidXRlIGlzIHN5bmNocm9uaXplZCB0byB0aGUgcHJvcGVydHksXG4gICAgICAvLyBzbyB3ZSBhc3NpZ24gZGVmYXVsdFZhbHVlIHRvIHRoZSBzYW1lIHRoaW5nIGFzIHRoZSB2YWx1ZSBwcm9wZXJ0eVxuICAgICAgLy8gYXNzaWdubWVudCBzdGVwIGFib3ZlLlxuICAgICAgbm9kZS5kZWZhdWx0VmFsdWUgPSBpbml0aWFsVmFsdWU7XG4gICAgfVxuICB9IC8vIE5vcm1hbGx5LCB3ZSdkIGp1c3QgZG8gYG5vZGUuY2hlY2tlZCA9IG5vZGUuY2hlY2tlZGAgdXBvbiBpbml0aWFsIG1vdW50LCBsZXNzIHRoaXMgYnVnXG4gIC8vIHRoaXMgaXMgbmVlZGVkIHRvIHdvcmsgYXJvdW5kIGEgY2hyb21lIGJ1ZyB3aGVyZSBzZXR0aW5nIGRlZmF1bHRDaGVja2VkXG4gIC8vIHdpbGwgc29tZXRpbWVzIGluZmx1ZW5jZSB0aGUgdmFsdWUgb2YgY2hlY2tlZCAoZXZlbiBhZnRlciBkZXRhY2htZW50KS5cbiAgLy8gUmVmZXJlbmNlOiBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD02MDg0MTZcbiAgLy8gV2UgbmVlZCB0byB0ZW1wb3JhcmlseSB1bnNldCBuYW1lIHRvIGF2b2lkIGRpc3J1cHRpbmcgcmFkaW8gYnV0dG9uIGdyb3Vwcy5cblxuXG4gIHZhciBuYW1lID0gbm9kZS5uYW1lO1xuXG4gIGlmIChuYW1lICE9PSAnJykge1xuICAgIG5vZGUubmFtZSA9ICcnO1xuICB9XG5cbiAge1xuICAgIC8vIFdoZW4gc3luY2luZyB0aGUgY2hlY2tlZCBhdHRyaWJ1dGUsIGJvdGggdGhlIGNoZWNrZWQgcHJvcGVydHkgYW5kXG4gICAgLy8gYXR0cmlidXRlIGFyZSBhc3NpZ25lZCBhdCB0aGUgc2FtZSB0aW1lIHVzaW5nIGRlZmF1bHRDaGVja2VkLiBUaGlzIHVzZXM6XG4gICAgLy9cbiAgICAvLyAgIDEuIFRoZSBjaGVja2VkIFJlYWN0IHByb3BlcnR5IHdoZW4gcHJlc2VudFxuICAgIC8vICAgMi4gVGhlIGRlZmF1bHRDaGVja2VkIFJlYWN0IHByb3BlcnR5IHdoZW4gcHJlc2VudFxuICAgIC8vICAgMy4gT3RoZXJ3aXNlLCBmYWxzZVxuICAgIG5vZGUuZGVmYXVsdENoZWNrZWQgPSAhbm9kZS5kZWZhdWx0Q2hlY2tlZDtcbiAgICBub2RlLmRlZmF1bHRDaGVja2VkID0gISFub2RlLl93cmFwcGVyU3RhdGUuaW5pdGlhbENoZWNrZWQ7XG4gIH1cblxuICBpZiAobmFtZSAhPT0gJycpIHtcbiAgICBub2RlLm5hbWUgPSBuYW1lO1xuICB9XG59XG5mdW5jdGlvbiByZXN0b3JlQ29udHJvbGxlZFN0YXRlKGVsZW1lbnQsIHByb3BzKSB7XG4gIHZhciBub2RlID0gZWxlbWVudDtcbiAgdXBkYXRlV3JhcHBlcihub2RlLCBwcm9wcyk7XG4gIHVwZGF0ZU5hbWVkQ291c2lucyhub2RlLCBwcm9wcyk7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZU5hbWVkQ291c2lucyhyb290Tm9kZSwgcHJvcHMpIHtcbiAgdmFyIG5hbWUgPSBwcm9wcy5uYW1lO1xuXG4gIGlmIChwcm9wcy50eXBlID09PSAncmFkaW8nICYmIG5hbWUgIT0gbnVsbCkge1xuICAgIHZhciBxdWVyeVJvb3QgPSByb290Tm9kZTtcblxuICAgIHdoaWxlIChxdWVyeVJvb3QucGFyZW50Tm9kZSkge1xuICAgICAgcXVlcnlSb290ID0gcXVlcnlSb290LnBhcmVudE5vZGU7XG4gICAgfSAvLyBJZiBgcm9vdE5vZGUuZm9ybWAgd2FzIG5vbi1udWxsLCB0aGVuIHdlIGNvdWxkIHRyeSBgZm9ybS5lbGVtZW50c2AsXG4gICAgLy8gYnV0IHRoYXQgc29tZXRpbWVzIGJlaGF2ZXMgc3RyYW5nZWx5IGluIElFOC4gV2UgY291bGQgYWxzbyB0cnkgdXNpbmdcbiAgICAvLyBgZm9ybS5nZXRFbGVtZW50c0J5TmFtZWAsIGJ1dCB0aGF0IHdpbGwgb25seSByZXR1cm4gZGlyZWN0IGNoaWxkcmVuXG4gICAgLy8gYW5kIHdvbid0IGluY2x1ZGUgaW5wdXRzIHRoYXQgdXNlIHRoZSBIVE1MNSBgZm9ybT1gIGF0dHJpYnV0ZS4gU2luY2VcbiAgICAvLyB0aGUgaW5wdXQgbWlnaHQgbm90IGV2ZW4gYmUgaW4gYSBmb3JtLiBJdCBtaWdodCBub3QgZXZlbiBiZSBpbiB0aGVcbiAgICAvLyBkb2N1bWVudC4gTGV0J3MganVzdCB1c2UgdGhlIGxvY2FsIGBxdWVyeVNlbGVjdG9yQWxsYCB0byBlbnN1cmUgd2UgZG9uJ3RcbiAgICAvLyBtaXNzIGFueXRoaW5nLlxuXG5cbiAgICB2YXIgZ3JvdXAgPSBxdWVyeVJvb3QucXVlcnlTZWxlY3RvckFsbCgnaW5wdXRbbmFtZT0nICsgSlNPTi5zdHJpbmdpZnkoJycgKyBuYW1lKSArICddW3R5cGU9XCJyYWRpb1wiXScpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBncm91cC5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIG90aGVyTm9kZSA9IGdyb3VwW2ldO1xuXG4gICAgICBpZiAob3RoZXJOb2RlID09PSByb290Tm9kZSB8fCBvdGhlck5vZGUuZm9ybSAhPT0gcm9vdE5vZGUuZm9ybSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH0gLy8gVGhpcyB3aWxsIHRocm93IGlmIHJhZGlvIGJ1dHRvbnMgcmVuZGVyZWQgYnkgZGlmZmVyZW50IGNvcGllcyBvZiBSZWFjdFxuICAgICAgLy8gYW5kIHRoZSBzYW1lIG5hbWUgYXJlIHJlbmRlcmVkIGludG8gdGhlIHNhbWUgZm9ybSAoc2FtZSBhcyAjMTkzOSkuXG4gICAgICAvLyBUaGF0J3MgcHJvYmFibHkgb2theTsgd2UgZG9uJ3Qgc3VwcG9ydCBpdCBqdXN0IGFzIHdlIGRvbid0IHN1cHBvcnRcbiAgICAgIC8vIG1peGluZyBSZWFjdCByYWRpbyBidXR0b25zIHdpdGggbm9uLVJlYWN0IG9uZXMuXG5cblxuICAgICAgdmFyIG90aGVyUHJvcHMgPSBnZXRGaWJlckN1cnJlbnRQcm9wc0Zyb21Ob2RlKG90aGVyTm9kZSk7XG5cbiAgICAgIGlmICghb3RoZXJQcm9wcykge1xuICAgICAgICB7XG4gICAgICAgICAgdGhyb3cgRXJyb3IoIFwiUmVhY3RET01JbnB1dDogTWl4aW5nIFJlYWN0IGFuZCBub24tUmVhY3QgcmFkaW8gaW5wdXRzIHdpdGggdGhlIHNhbWUgYG5hbWVgIGlzIG5vdCBzdXBwb3J0ZWQuXCIgKTtcbiAgICAgICAgfVxuICAgICAgfSAvLyBXZSBuZWVkIHVwZGF0ZSB0aGUgdHJhY2tlZCB2YWx1ZSBvbiB0aGUgbmFtZWQgY291c2luIHNpbmNlIHRoZSB2YWx1ZVxuICAgICAgLy8gd2FzIGNoYW5nZWQgYnV0IHRoZSBpbnB1dCBzYXcgbm8gZXZlbnQgb3IgdmFsdWUgc2V0XG5cblxuICAgICAgdXBkYXRlVmFsdWVJZkNoYW5nZWQob3RoZXJOb2RlKTsgLy8gSWYgdGhpcyBpcyBhIGNvbnRyb2xsZWQgcmFkaW8gYnV0dG9uIGdyb3VwLCBmb3JjaW5nIHRoZSBpbnB1dCB0aGF0XG4gICAgICAvLyB3YXMgcHJldmlvdXNseSBjaGVja2VkIHRvIHVwZGF0ZSB3aWxsIGNhdXNlIGl0IHRvIGJlIGNvbWUgcmUtY2hlY2tlZFxuICAgICAgLy8gYXMgYXBwcm9wcmlhdGUuXG5cbiAgICAgIHVwZGF0ZVdyYXBwZXIob3RoZXJOb2RlLCBvdGhlclByb3BzKTtcbiAgICB9XG4gIH1cbn0gLy8gSW4gQ2hyb21lLCBhc3NpZ25pbmcgZGVmYXVsdFZhbHVlIHRvIGNlcnRhaW4gaW5wdXQgdHlwZXMgdHJpZ2dlcnMgaW5wdXQgdmFsaWRhdGlvbi5cbi8vIEZvciBudW1iZXIgaW5wdXRzLCB0aGUgZGlzcGxheSB2YWx1ZSBsb3NlcyB0cmFpbGluZyBkZWNpbWFsIHBvaW50cy4gRm9yIGVtYWlsIGlucHV0cyxcbi8vIENocm9tZSByYWlzZXMgXCJUaGUgc3BlY2lmaWVkIHZhbHVlIDx4PiBpcyBub3QgYSB2YWxpZCBlbWFpbCBhZGRyZXNzXCIuXG4vL1xuLy8gSGVyZSB3ZSBjaGVjayB0byBzZWUgaWYgdGhlIGRlZmF1bHRWYWx1ZSBoYXMgYWN0dWFsbHkgY2hhbmdlZCwgYXZvaWRpbmcgdGhlc2UgcHJvYmxlbXNcbi8vIHdoZW4gdGhlIHVzZXIgaXMgaW5wdXR0aW5nIHRleHRcbi8vXG4vLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzcyNTNcblxuXG5mdW5jdGlvbiBzZXREZWZhdWx0VmFsdWUobm9kZSwgdHlwZSwgdmFsdWUpIHtcbiAgaWYgKCAvLyBGb2N1c2VkIG51bWJlciBpbnB1dHMgc3luY2hyb25pemUgb24gYmx1ci4gU2VlIENoYW5nZUV2ZW50UGx1Z2luLmpzXG4gIHR5cGUgIT09ICdudW1iZXInIHx8IGdldEFjdGl2ZUVsZW1lbnQobm9kZS5vd25lckRvY3VtZW50KSAhPT0gbm9kZSkge1xuICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICBub2RlLmRlZmF1bHRWYWx1ZSA9IHRvU3RyaW5nKG5vZGUuX3dyYXBwZXJTdGF0ZS5pbml0aWFsVmFsdWUpO1xuICAgIH0gZWxzZSBpZiAobm9kZS5kZWZhdWx0VmFsdWUgIT09IHRvU3RyaW5nKHZhbHVlKSkge1xuICAgICAgbm9kZS5kZWZhdWx0VmFsdWUgPSB0b1N0cmluZyh2YWx1ZSk7XG4gICAgfVxuICB9XG59XG5cbnZhciBkaWRXYXJuU2VsZWN0ZWRTZXRPbk9wdGlvbiA9IGZhbHNlO1xudmFyIGRpZFdhcm5JbnZhbGlkQ2hpbGQgPSBmYWxzZTtcblxuZnVuY3Rpb24gZmxhdHRlbkNoaWxkcmVuKGNoaWxkcmVuKSB7XG4gIHZhciBjb250ZW50ID0gJyc7IC8vIEZsYXR0ZW4gY2hpbGRyZW4uIFdlJ2xsIHdhcm4gaWYgdGhleSBhcmUgaW52YWxpZFxuICAvLyBkdXJpbmcgdmFsaWRhdGVQcm9wcygpIHdoaWNoIHJ1bnMgZm9yIGh5ZHJhdGlvbiB0b28uXG4gIC8vIE5vdGUgdGhhdCB0aGlzIHdvdWxkIHRocm93IG9uIG5vbi1lbGVtZW50IG9iamVjdHMuXG4gIC8vIEVsZW1lbnRzIGFyZSBzdHJpbmdpZmllZCAod2hpY2ggaXMgbm9ybWFsbHkgaXJyZWxldmFudFxuICAvLyBidXQgbWF0dGVycyBmb3IgPGZidD4pLlxuXG4gIFJlYWN0LkNoaWxkcmVuLmZvckVhY2goY2hpbGRyZW4sIGZ1bmN0aW9uIChjaGlsZCkge1xuICAgIGlmIChjaGlsZCA9PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29udGVudCArPSBjaGlsZDsgLy8gTm90ZTogd2UgZG9uJ3Qgd2FybiBhYm91dCBpbnZhbGlkIGNoaWxkcmVuIGhlcmUuXG4gICAgLy8gSW5zdGVhZCwgdGhpcyBpcyBkb25lIHNlcGFyYXRlbHkgYmVsb3cgc28gdGhhdFxuICAgIC8vIGl0IGhhcHBlbnMgZHVyaW5nIHRoZSBoeWRyYXRpb24gY29kZSBwYXRoIHRvby5cbiAgfSk7XG4gIHJldHVybiBjb250ZW50O1xufVxuLyoqXG4gKiBJbXBsZW1lbnRzIGFuIDxvcHRpb24+IGhvc3QgY29tcG9uZW50IHRoYXQgd2FybnMgd2hlbiBgc2VsZWN0ZWRgIGlzIHNldC5cbiAqL1xuXG5cbmZ1bmN0aW9uIHZhbGlkYXRlUHJvcHMoZWxlbWVudCwgcHJvcHMpIHtcbiAge1xuICAgIC8vIFRoaXMgbWlycm9ycyB0aGUgY29kZSBwYXRoIGFib3ZlLCBidXQgcnVucyBmb3IgaHlkcmF0aW9uIHRvby5cbiAgICAvLyBXYXJuIGFib3V0IGludmFsaWQgY2hpbGRyZW4gaGVyZSBzbyB0aGF0IGNsaWVudCBhbmQgaHlkcmF0aW9uIGFyZSBjb25zaXN0ZW50LlxuICAgIC8vIFRPRE86IHRoaXMgc2VlbXMgbGlrZSBpdCBjb3VsZCBjYXVzZSBhIERFVi1vbmx5IHRocm93IGZvciBoeWRyYXRpb25cbiAgICAvLyBpZiBjaGlsZHJlbiBjb250YWlucyBhIG5vbi1lbGVtZW50IG9iamVjdC4gV2Ugc2hvdWxkIHRyeSB0byBhdm9pZCB0aGF0LlxuICAgIGlmICh0eXBlb2YgcHJvcHMuY2hpbGRyZW4gPT09ICdvYmplY3QnICYmIHByb3BzLmNoaWxkcmVuICE9PSBudWxsKSB7XG4gICAgICBSZWFjdC5DaGlsZHJlbi5mb3JFYWNoKHByb3BzLmNoaWxkcmVuLCBmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgaWYgKGNoaWxkID09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGNoaWxkID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgY2hpbGQgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBjaGlsZC50eXBlICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghZGlkV2FybkludmFsaWRDaGlsZCkge1xuICAgICAgICAgIGRpZFdhcm5JbnZhbGlkQ2hpbGQgPSB0cnVlO1xuXG4gICAgICAgICAgZXJyb3IoJ09ubHkgc3RyaW5ncyBhbmQgbnVtYmVycyBhcmUgc3VwcG9ydGVkIGFzIDxvcHRpb24+IGNoaWxkcmVuLicpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IC8vIFRPRE86IFJlbW92ZSBzdXBwb3J0IGZvciBgc2VsZWN0ZWRgIGluIDxvcHRpb24+LlxuXG5cbiAgICBpZiAocHJvcHMuc2VsZWN0ZWQgIT0gbnVsbCAmJiAhZGlkV2FyblNlbGVjdGVkU2V0T25PcHRpb24pIHtcbiAgICAgIGVycm9yKCdVc2UgdGhlIGBkZWZhdWx0VmFsdWVgIG9yIGB2YWx1ZWAgcHJvcHMgb24gPHNlbGVjdD4gaW5zdGVhZCBvZiAnICsgJ3NldHRpbmcgYHNlbGVjdGVkYCBvbiA8b3B0aW9uPi4nKTtcblxuICAgICAgZGlkV2FyblNlbGVjdGVkU2V0T25PcHRpb24gPSB0cnVlO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gcG9zdE1vdW50V3JhcHBlciQxKGVsZW1lbnQsIHByb3BzKSB7XG4gIC8vIHZhbHVlPVwiXCIgc2hvdWxkIG1ha2UgYSB2YWx1ZSBhdHRyaWJ1dGUgKCM2MjE5KVxuICBpZiAocHJvcHMudmFsdWUgIT0gbnVsbCkge1xuICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKCd2YWx1ZScsIHRvU3RyaW5nKGdldFRvU3RyaW5nVmFsdWUocHJvcHMudmFsdWUpKSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGdldEhvc3RQcm9wcyQxKGVsZW1lbnQsIHByb3BzKSB7XG4gIHZhciBob3N0UHJvcHMgPSBfYXNzaWduKHtcbiAgICBjaGlsZHJlbjogdW5kZWZpbmVkXG4gIH0sIHByb3BzKTtcblxuICB2YXIgY29udGVudCA9IGZsYXR0ZW5DaGlsZHJlbihwcm9wcy5jaGlsZHJlbik7XG5cbiAgaWYgKGNvbnRlbnQpIHtcbiAgICBob3N0UHJvcHMuY2hpbGRyZW4gPSBjb250ZW50O1xuICB9XG5cbiAgcmV0dXJuIGhvc3RQcm9wcztcbn1cblxudmFyIGRpZFdhcm5WYWx1ZURlZmF1bHRWYWx1ZSQxO1xuXG57XG4gIGRpZFdhcm5WYWx1ZURlZmF1bHRWYWx1ZSQxID0gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bSgpIHtcbiAgdmFyIG93bmVyTmFtZSA9IGdldEN1cnJlbnRGaWJlck93bmVyTmFtZUluRGV2T3JOdWxsKCk7XG5cbiAgaWYgKG93bmVyTmFtZSkge1xuICAgIHJldHVybiAnXFxuXFxuQ2hlY2sgdGhlIHJlbmRlciBtZXRob2Qgb2YgYCcgKyBvd25lck5hbWUgKyAnYC4nO1xuICB9XG5cbiAgcmV0dXJuICcnO1xufVxuXG52YXIgdmFsdWVQcm9wTmFtZXMgPSBbJ3ZhbHVlJywgJ2RlZmF1bHRWYWx1ZSddO1xuLyoqXG4gKiBWYWxpZGF0aW9uIGZ1bmN0aW9uIGZvciBgdmFsdWVgIGFuZCBgZGVmYXVsdFZhbHVlYC5cbiAqL1xuXG5mdW5jdGlvbiBjaGVja1NlbGVjdFByb3BUeXBlcyhwcm9wcykge1xuICB7XG4gICAgY2hlY2tDb250cm9sbGVkVmFsdWVQcm9wcygnc2VsZWN0JywgcHJvcHMpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWx1ZVByb3BOYW1lcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHByb3BOYW1lID0gdmFsdWVQcm9wTmFtZXNbaV07XG5cbiAgICAgIGlmIChwcm9wc1twcm9wTmFtZV0gPT0gbnVsbCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgdmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5KHByb3BzW3Byb3BOYW1lXSk7XG5cbiAgICAgIGlmIChwcm9wcy5tdWx0aXBsZSAmJiAhaXNBcnJheSkge1xuICAgICAgICBlcnJvcignVGhlIGAlc2AgcHJvcCBzdXBwbGllZCB0byA8c2VsZWN0PiBtdXN0IGJlIGFuIGFycmF5IGlmICcgKyAnYG11bHRpcGxlYCBpcyB0cnVlLiVzJywgcHJvcE5hbWUsIGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bSgpKTtcbiAgICAgIH0gZWxzZSBpZiAoIXByb3BzLm11bHRpcGxlICYmIGlzQXJyYXkpIHtcbiAgICAgICAgZXJyb3IoJ1RoZSBgJXNgIHByb3Agc3VwcGxpZWQgdG8gPHNlbGVjdD4gbXVzdCBiZSBhIHNjYWxhciAnICsgJ3ZhbHVlIGlmIGBtdWx0aXBsZWAgaXMgZmFsc2UuJXMnLCBwcm9wTmFtZSwgZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKCkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiB1cGRhdGVPcHRpb25zKG5vZGUsIG11bHRpcGxlLCBwcm9wVmFsdWUsIHNldERlZmF1bHRTZWxlY3RlZCkge1xuICB2YXIgb3B0aW9ucyA9IG5vZGUub3B0aW9ucztcblxuICBpZiAobXVsdGlwbGUpIHtcbiAgICB2YXIgc2VsZWN0ZWRWYWx1ZXMgPSBwcm9wVmFsdWU7XG4gICAgdmFyIHNlbGVjdGVkVmFsdWUgPSB7fTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2VsZWN0ZWRWYWx1ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIC8vIFByZWZpeCB0byBhdm9pZCBjaGFvcyB3aXRoIHNwZWNpYWwga2V5cy5cbiAgICAgIHNlbGVjdGVkVmFsdWVbJyQnICsgc2VsZWN0ZWRWYWx1ZXNbaV1dID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgb3B0aW9ucy5sZW5ndGg7IF9pKyspIHtcbiAgICAgIHZhciBzZWxlY3RlZCA9IHNlbGVjdGVkVmFsdWUuaGFzT3duUHJvcGVydHkoJyQnICsgb3B0aW9uc1tfaV0udmFsdWUpO1xuXG4gICAgICBpZiAob3B0aW9uc1tfaV0uc2VsZWN0ZWQgIT09IHNlbGVjdGVkKSB7XG4gICAgICAgIG9wdGlvbnNbX2ldLnNlbGVjdGVkID0gc2VsZWN0ZWQ7XG4gICAgICB9XG5cbiAgICAgIGlmIChzZWxlY3RlZCAmJiBzZXREZWZhdWx0U2VsZWN0ZWQpIHtcbiAgICAgICAgb3B0aW9uc1tfaV0uZGVmYXVsdFNlbGVjdGVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gRG8gbm90IHNldCBgc2VsZWN0LnZhbHVlYCBhcyBleGFjdCBiZWhhdmlvciBpc24ndCBjb25zaXN0ZW50IGFjcm9zcyBhbGxcbiAgICAvLyBicm93c2VycyBmb3IgYWxsIGNhc2VzLlxuICAgIHZhciBfc2VsZWN0ZWRWYWx1ZSA9IHRvU3RyaW5nKGdldFRvU3RyaW5nVmFsdWUocHJvcFZhbHVlKSk7XG5cbiAgICB2YXIgZGVmYXVsdFNlbGVjdGVkID0gbnVsbDtcblxuICAgIGZvciAodmFyIF9pMiA9IDA7IF9pMiA8IG9wdGlvbnMubGVuZ3RoOyBfaTIrKykge1xuICAgICAgaWYgKG9wdGlvbnNbX2kyXS52YWx1ZSA9PT0gX3NlbGVjdGVkVmFsdWUpIHtcbiAgICAgICAgb3B0aW9uc1tfaTJdLnNlbGVjdGVkID0gdHJ1ZTtcblxuICAgICAgICBpZiAoc2V0RGVmYXVsdFNlbGVjdGVkKSB7XG4gICAgICAgICAgb3B0aW9uc1tfaTJdLmRlZmF1bHRTZWxlY3RlZCA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChkZWZhdWx0U2VsZWN0ZWQgPT09IG51bGwgJiYgIW9wdGlvbnNbX2kyXS5kaXNhYmxlZCkge1xuICAgICAgICBkZWZhdWx0U2VsZWN0ZWQgPSBvcHRpb25zW19pMl07XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGRlZmF1bHRTZWxlY3RlZCAhPT0gbnVsbCkge1xuICAgICAgZGVmYXVsdFNlbGVjdGVkLnNlbGVjdGVkID0gdHJ1ZTtcbiAgICB9XG4gIH1cbn1cbi8qKlxuICogSW1wbGVtZW50cyBhIDxzZWxlY3Q+IGhvc3QgY29tcG9uZW50IHRoYXQgYWxsb3dzIG9wdGlvbmFsbHkgc2V0dGluZyB0aGVcbiAqIHByb3BzIGB2YWx1ZWAgYW5kIGBkZWZhdWx0VmFsdWVgLiBJZiBgbXVsdGlwbGVgIGlzIGZhbHNlLCB0aGUgcHJvcCBtdXN0IGJlIGFcbiAqIHN0cmluZ2FibGUuIElmIGBtdWx0aXBsZWAgaXMgdHJ1ZSwgdGhlIHByb3AgbXVzdCBiZSBhbiBhcnJheSBvZiBzdHJpbmdhYmxlcy5cbiAqXG4gKiBJZiBgdmFsdWVgIGlzIG5vdCBzdXBwbGllZCAob3IgbnVsbC91bmRlZmluZWQpLCB1c2VyIGFjdGlvbnMgdGhhdCBjaGFuZ2UgdGhlXG4gKiBzZWxlY3RlZCBvcHRpb24gd2lsbCB0cmlnZ2VyIHVwZGF0ZXMgdG8gdGhlIHJlbmRlcmVkIG9wdGlvbnMuXG4gKlxuICogSWYgaXQgaXMgc3VwcGxpZWQgKGFuZCBub3QgbnVsbC91bmRlZmluZWQpLCB0aGUgcmVuZGVyZWQgb3B0aW9ucyB3aWxsIG5vdFxuICogdXBkYXRlIGluIHJlc3BvbnNlIHRvIHVzZXIgYWN0aW9ucy4gSW5zdGVhZCwgdGhlIGB2YWx1ZWAgcHJvcCBtdXN0IGNoYW5nZSBpblxuICogb3JkZXIgZm9yIHRoZSByZW5kZXJlZCBvcHRpb25zIHRvIHVwZGF0ZS5cbiAqXG4gKiBJZiBgZGVmYXVsdFZhbHVlYCBpcyBwcm92aWRlZCwgYW55IG9wdGlvbnMgd2l0aCB0aGUgc3VwcGxpZWQgdmFsdWVzIHdpbGwgYmVcbiAqIHNlbGVjdGVkLlxuICovXG5cblxuZnVuY3Rpb24gZ2V0SG9zdFByb3BzJDIoZWxlbWVudCwgcHJvcHMpIHtcbiAgcmV0dXJuIF9hc3NpZ24oe30sIHByb3BzLCB7XG4gICAgdmFsdWU6IHVuZGVmaW5lZFxuICB9KTtcbn1cbmZ1bmN0aW9uIGluaXRXcmFwcGVyU3RhdGUkMShlbGVtZW50LCBwcm9wcykge1xuICB2YXIgbm9kZSA9IGVsZW1lbnQ7XG5cbiAge1xuICAgIGNoZWNrU2VsZWN0UHJvcFR5cGVzKHByb3BzKTtcbiAgfVxuXG4gIG5vZGUuX3dyYXBwZXJTdGF0ZSA9IHtcbiAgICB3YXNNdWx0aXBsZTogISFwcm9wcy5tdWx0aXBsZVxuICB9O1xuXG4gIHtcbiAgICBpZiAocHJvcHMudmFsdWUgIT09IHVuZGVmaW5lZCAmJiBwcm9wcy5kZWZhdWx0VmFsdWUgIT09IHVuZGVmaW5lZCAmJiAhZGlkV2FyblZhbHVlRGVmYXVsdFZhbHVlJDEpIHtcbiAgICAgIGVycm9yKCdTZWxlY3QgZWxlbWVudHMgbXVzdCBiZSBlaXRoZXIgY29udHJvbGxlZCBvciB1bmNvbnRyb2xsZWQgJyArICcoc3BlY2lmeSBlaXRoZXIgdGhlIHZhbHVlIHByb3AsIG9yIHRoZSBkZWZhdWx0VmFsdWUgcHJvcCwgYnV0IG5vdCAnICsgJ2JvdGgpLiBEZWNpZGUgYmV0d2VlbiB1c2luZyBhIGNvbnRyb2xsZWQgb3IgdW5jb250cm9sbGVkIHNlbGVjdCAnICsgJ2VsZW1lbnQgYW5kIHJlbW92ZSBvbmUgb2YgdGhlc2UgcHJvcHMuIE1vcmUgaW5mbzogJyArICdodHRwczovL3JlYWN0anMub3JnL2xpbmsvY29udHJvbGxlZC1jb21wb25lbnRzJyk7XG5cbiAgICAgIGRpZFdhcm5WYWx1ZURlZmF1bHRWYWx1ZSQxID0gdHJ1ZTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIHBvc3RNb3VudFdyYXBwZXIkMihlbGVtZW50LCBwcm9wcykge1xuICB2YXIgbm9kZSA9IGVsZW1lbnQ7XG4gIG5vZGUubXVsdGlwbGUgPSAhIXByb3BzLm11bHRpcGxlO1xuICB2YXIgdmFsdWUgPSBwcm9wcy52YWx1ZTtcblxuICBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgIHVwZGF0ZU9wdGlvbnMobm9kZSwgISFwcm9wcy5tdWx0aXBsZSwgdmFsdWUsIGZhbHNlKTtcbiAgfSBlbHNlIGlmIChwcm9wcy5kZWZhdWx0VmFsdWUgIT0gbnVsbCkge1xuICAgIHVwZGF0ZU9wdGlvbnMobm9kZSwgISFwcm9wcy5tdWx0aXBsZSwgcHJvcHMuZGVmYXVsdFZhbHVlLCB0cnVlKTtcbiAgfVxufVxuZnVuY3Rpb24gcG9zdFVwZGF0ZVdyYXBwZXIoZWxlbWVudCwgcHJvcHMpIHtcbiAgdmFyIG5vZGUgPSBlbGVtZW50O1xuICB2YXIgd2FzTXVsdGlwbGUgPSBub2RlLl93cmFwcGVyU3RhdGUud2FzTXVsdGlwbGU7XG4gIG5vZGUuX3dyYXBwZXJTdGF0ZS53YXNNdWx0aXBsZSA9ICEhcHJvcHMubXVsdGlwbGU7XG4gIHZhciB2YWx1ZSA9IHByb3BzLnZhbHVlO1xuXG4gIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgdXBkYXRlT3B0aW9ucyhub2RlLCAhIXByb3BzLm11bHRpcGxlLCB2YWx1ZSwgZmFsc2UpO1xuICB9IGVsc2UgaWYgKHdhc011bHRpcGxlICE9PSAhIXByb3BzLm11bHRpcGxlKSB7XG4gICAgLy8gRm9yIHNpbXBsaWNpdHksIHJlYXBwbHkgYGRlZmF1bHRWYWx1ZWAgaWYgYG11bHRpcGxlYCBpcyB0b2dnbGVkLlxuICAgIGlmIChwcm9wcy5kZWZhdWx0VmFsdWUgIT0gbnVsbCkge1xuICAgICAgdXBkYXRlT3B0aW9ucyhub2RlLCAhIXByb3BzLm11bHRpcGxlLCBwcm9wcy5kZWZhdWx0VmFsdWUsIHRydWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBSZXZlcnQgdGhlIHNlbGVjdCBiYWNrIHRvIGl0cyBkZWZhdWx0IHVuc2VsZWN0ZWQgc3RhdGUuXG4gICAgICB1cGRhdGVPcHRpb25zKG5vZGUsICEhcHJvcHMubXVsdGlwbGUsIHByb3BzLm11bHRpcGxlID8gW10gOiAnJywgZmFsc2UpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gcmVzdG9yZUNvbnRyb2xsZWRTdGF0ZSQxKGVsZW1lbnQsIHByb3BzKSB7XG4gIHZhciBub2RlID0gZWxlbWVudDtcbiAgdmFyIHZhbHVlID0gcHJvcHMudmFsdWU7XG5cbiAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICB1cGRhdGVPcHRpb25zKG5vZGUsICEhcHJvcHMubXVsdGlwbGUsIHZhbHVlLCBmYWxzZSk7XG4gIH1cbn1cblxudmFyIGRpZFdhcm5WYWxEZWZhdWx0VmFsID0gZmFsc2U7XG5cbi8qKlxuICogSW1wbGVtZW50cyBhIDx0ZXh0YXJlYT4gaG9zdCBjb21wb25lbnQgdGhhdCBhbGxvd3Mgc2V0dGluZyBgdmFsdWVgLCBhbmRcbiAqIGBkZWZhdWx0VmFsdWVgLiBUaGlzIGRpZmZlcnMgZnJvbSB0aGUgdHJhZGl0aW9uYWwgRE9NIEFQSSBiZWNhdXNlIHZhbHVlIGlzXG4gKiB1c3VhbGx5IHNldCBhcyBQQ0RBVEEgY2hpbGRyZW4uXG4gKlxuICogSWYgYHZhbHVlYCBpcyBub3Qgc3VwcGxpZWQgKG9yIG51bGwvdW5kZWZpbmVkKSwgdXNlciBhY3Rpb25zIHRoYXQgYWZmZWN0IHRoZVxuICogdmFsdWUgd2lsbCB0cmlnZ2VyIHVwZGF0ZXMgdG8gdGhlIGVsZW1lbnQuXG4gKlxuICogSWYgYHZhbHVlYCBpcyBzdXBwbGllZCAoYW5kIG5vdCBudWxsL3VuZGVmaW5lZCksIHRoZSByZW5kZXJlZCBlbGVtZW50IHdpbGxcbiAqIG5vdCB0cmlnZ2VyIHVwZGF0ZXMgdG8gdGhlIGVsZW1lbnQuIEluc3RlYWQsIHRoZSBgdmFsdWVgIHByb3AgbXVzdCBjaGFuZ2UgaW5cbiAqIG9yZGVyIGZvciB0aGUgcmVuZGVyZWQgZWxlbWVudCB0byBiZSB1cGRhdGVkLlxuICpcbiAqIFRoZSByZW5kZXJlZCBlbGVtZW50IHdpbGwgYmUgaW5pdGlhbGl6ZWQgd2l0aCBhbiBlbXB0eSB2YWx1ZSwgdGhlIHByb3BcbiAqIGBkZWZhdWx0VmFsdWVgIGlmIHNwZWNpZmllZCwgb3IgdGhlIGNoaWxkcmVuIGNvbnRlbnQgKGRlcHJlY2F0ZWQpLlxuICovXG5mdW5jdGlvbiBnZXRIb3N0UHJvcHMkMyhlbGVtZW50LCBwcm9wcykge1xuICB2YXIgbm9kZSA9IGVsZW1lbnQ7XG5cbiAgaWYgKCEocHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwgPT0gbnVsbCkpIHtcbiAgICB7XG4gICAgICB0aHJvdyBFcnJvciggXCJgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxgIGRvZXMgbm90IG1ha2Ugc2Vuc2Ugb24gPHRleHRhcmVhPi5cIiApO1xuICAgIH1cbiAgfSAvLyBBbHdheXMgc2V0IGNoaWxkcmVuIHRvIHRoZSBzYW1lIHRoaW5nLiBJbiBJRTksIHRoZSBzZWxlY3Rpb24gcmFuZ2Ugd2lsbFxuICAvLyBnZXQgcmVzZXQgaWYgYHRleHRDb250ZW50YCBpcyBtdXRhdGVkLiAgV2UgY291bGQgYWRkIGEgY2hlY2sgaW4gc2V0VGV4dENvbnRlbnRcbiAgLy8gdG8gb25seSBzZXQgdGhlIHZhbHVlIGlmL3doZW4gdGhlIHZhbHVlIGRpZmZlcnMgZnJvbSB0aGUgbm9kZSB2YWx1ZSAod2hpY2ggd291bGRcbiAgLy8gY29tcGxldGVseSBzb2x2ZSB0aGlzIElFOSBidWcpLCBidXQgU2ViYXN0aWFuK1NvcGhpZSBzZWVtZWQgdG8gbGlrZSB0aGlzXG4gIC8vIHNvbHV0aW9uLiBUaGUgdmFsdWUgY2FuIGJlIGEgYm9vbGVhbiBvciBvYmplY3Qgc28gdGhhdCdzIHdoeSBpdCdzIGZvcmNlZFxuICAvLyB0byBiZSBhIHN0cmluZy5cblxuXG4gIHZhciBob3N0UHJvcHMgPSBfYXNzaWduKHt9LCBwcm9wcywge1xuICAgIHZhbHVlOiB1bmRlZmluZWQsXG4gICAgZGVmYXVsdFZhbHVlOiB1bmRlZmluZWQsXG4gICAgY2hpbGRyZW46IHRvU3RyaW5nKG5vZGUuX3dyYXBwZXJTdGF0ZS5pbml0aWFsVmFsdWUpXG4gIH0pO1xuXG4gIHJldHVybiBob3N0UHJvcHM7XG59XG5mdW5jdGlvbiBpbml0V3JhcHBlclN0YXRlJDIoZWxlbWVudCwgcHJvcHMpIHtcbiAgdmFyIG5vZGUgPSBlbGVtZW50O1xuXG4gIHtcbiAgICBjaGVja0NvbnRyb2xsZWRWYWx1ZVByb3BzKCd0ZXh0YXJlYScsIHByb3BzKTtcblxuICAgIGlmIChwcm9wcy52YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHByb3BzLmRlZmF1bHRWYWx1ZSAhPT0gdW5kZWZpbmVkICYmICFkaWRXYXJuVmFsRGVmYXVsdFZhbCkge1xuICAgICAgZXJyb3IoJyVzIGNvbnRhaW5zIGEgdGV4dGFyZWEgd2l0aCBib3RoIHZhbHVlIGFuZCBkZWZhdWx0VmFsdWUgcHJvcHMuICcgKyAnVGV4dGFyZWEgZWxlbWVudHMgbXVzdCBiZSBlaXRoZXIgY29udHJvbGxlZCBvciB1bmNvbnRyb2xsZWQgJyArICcoc3BlY2lmeSBlaXRoZXIgdGhlIHZhbHVlIHByb3AsIG9yIHRoZSBkZWZhdWx0VmFsdWUgcHJvcCwgYnV0IG5vdCAnICsgJ2JvdGgpLiBEZWNpZGUgYmV0d2VlbiB1c2luZyBhIGNvbnRyb2xsZWQgb3IgdW5jb250cm9sbGVkIHRleHRhcmVhICcgKyAnYW5kIHJlbW92ZSBvbmUgb2YgdGhlc2UgcHJvcHMuIE1vcmUgaW5mbzogJyArICdodHRwczovL3JlYWN0anMub3JnL2xpbmsvY29udHJvbGxlZC1jb21wb25lbnRzJywgZ2V0Q3VycmVudEZpYmVyT3duZXJOYW1lSW5EZXZPck51bGwoKSB8fCAnQSBjb21wb25lbnQnKTtcblxuICAgICAgZGlkV2FyblZhbERlZmF1bHRWYWwgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHZhciBpbml0aWFsVmFsdWUgPSBwcm9wcy52YWx1ZTsgLy8gT25seSBib3RoZXIgZmV0Y2hpbmcgZGVmYXVsdCB2YWx1ZSBpZiB3ZSdyZSBnb2luZyB0byB1c2UgaXRcblxuICBpZiAoaW5pdGlhbFZhbHVlID09IG51bGwpIHtcbiAgICB2YXIgY2hpbGRyZW4gPSBwcm9wcy5jaGlsZHJlbixcbiAgICAgICAgZGVmYXVsdFZhbHVlID0gcHJvcHMuZGVmYXVsdFZhbHVlO1xuXG4gICAgaWYgKGNoaWxkcmVuICE9IG51bGwpIHtcbiAgICAgIHtcbiAgICAgICAgZXJyb3IoJ1VzZSB0aGUgYGRlZmF1bHRWYWx1ZWAgb3IgYHZhbHVlYCBwcm9wcyBpbnN0ZWFkIG9mIHNldHRpbmcgJyArICdjaGlsZHJlbiBvbiA8dGV4dGFyZWE+LicpO1xuICAgICAgfVxuXG4gICAgICB7XG4gICAgICAgIGlmICghKGRlZmF1bHRWYWx1ZSA9PSBudWxsKSkge1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKCBcIklmIHlvdSBzdXBwbHkgYGRlZmF1bHRWYWx1ZWAgb24gYSA8dGV4dGFyZWE+LCBkbyBub3QgcGFzcyBjaGlsZHJlbi5cIiApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGNoaWxkcmVuKSkge1xuICAgICAgICAgIGlmICghKGNoaWxkcmVuLmxlbmd0aCA8PSAxKSkge1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICB0aHJvdyBFcnJvciggXCI8dGV4dGFyZWE+IGNhbiBvbmx5IGhhdmUgYXQgbW9zdCBvbmUgY2hpbGQuXCIgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjaGlsZHJlbiA9IGNoaWxkcmVuWzBdO1xuICAgICAgICB9XG5cbiAgICAgICAgZGVmYXVsdFZhbHVlID0gY2hpbGRyZW47XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGRlZmF1bHRWYWx1ZSA9PSBudWxsKSB7XG4gICAgICBkZWZhdWx0VmFsdWUgPSAnJztcbiAgICB9XG5cbiAgICBpbml0aWFsVmFsdWUgPSBkZWZhdWx0VmFsdWU7XG4gIH1cblxuICBub2RlLl93cmFwcGVyU3RhdGUgPSB7XG4gICAgaW5pdGlhbFZhbHVlOiBnZXRUb1N0cmluZ1ZhbHVlKGluaXRpYWxWYWx1ZSlcbiAgfTtcbn1cbmZ1bmN0aW9uIHVwZGF0ZVdyYXBwZXIkMShlbGVtZW50LCBwcm9wcykge1xuICB2YXIgbm9kZSA9IGVsZW1lbnQ7XG4gIHZhciB2YWx1ZSA9IGdldFRvU3RyaW5nVmFsdWUocHJvcHMudmFsdWUpO1xuICB2YXIgZGVmYXVsdFZhbHVlID0gZ2V0VG9TdHJpbmdWYWx1ZShwcm9wcy5kZWZhdWx0VmFsdWUpO1xuXG4gIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgLy8gQ2FzdCBgdmFsdWVgIHRvIGEgc3RyaW5nIHRvIGVuc3VyZSB0aGUgdmFsdWUgaXMgc2V0IGNvcnJlY3RseS4gV2hpbGVcbiAgICAvLyBicm93c2VycyB0eXBpY2FsbHkgZG8gdGhpcyBhcyBuZWNlc3NhcnksIGpzZG9tIGRvZXNuJ3QuXG4gICAgdmFyIG5ld1ZhbHVlID0gdG9TdHJpbmcodmFsdWUpOyAvLyBUbyBhdm9pZCBzaWRlIGVmZmVjdHMgKHN1Y2ggYXMgbG9zaW5nIHRleHQgc2VsZWN0aW9uKSwgb25seSBzZXQgdmFsdWUgaWYgY2hhbmdlZFxuXG4gICAgaWYgKG5ld1ZhbHVlICE9PSBub2RlLnZhbHVlKSB7XG4gICAgICBub2RlLnZhbHVlID0gbmV3VmFsdWU7XG4gICAgfVxuXG4gICAgaWYgKHByb3BzLmRlZmF1bHRWYWx1ZSA9PSBudWxsICYmIG5vZGUuZGVmYXVsdFZhbHVlICE9PSBuZXdWYWx1ZSkge1xuICAgICAgbm9kZS5kZWZhdWx0VmFsdWUgPSBuZXdWYWx1ZTtcbiAgICB9XG4gIH1cblxuICBpZiAoZGVmYXVsdFZhbHVlICE9IG51bGwpIHtcbiAgICBub2RlLmRlZmF1bHRWYWx1ZSA9IHRvU3RyaW5nKGRlZmF1bHRWYWx1ZSk7XG4gIH1cbn1cbmZ1bmN0aW9uIHBvc3RNb3VudFdyYXBwZXIkMyhlbGVtZW50LCBwcm9wcykge1xuICB2YXIgbm9kZSA9IGVsZW1lbnQ7IC8vIFRoaXMgaXMgaW4gcG9zdE1vdW50IGJlY2F1c2Ugd2UgbmVlZCBhY2Nlc3MgdG8gdGhlIERPTSBub2RlLCB3aGljaCBpcyBub3RcbiAgLy8gYXZhaWxhYmxlIHVudGlsIGFmdGVyIHRoZSBjb21wb25lbnQgaGFzIG1vdW50ZWQuXG5cbiAgdmFyIHRleHRDb250ZW50ID0gbm9kZS50ZXh0Q29udGVudDsgLy8gT25seSBzZXQgbm9kZS52YWx1ZSBpZiB0ZXh0Q29udGVudCBpcyBlcXVhbCB0byB0aGUgZXhwZWN0ZWRcbiAgLy8gaW5pdGlhbCB2YWx1ZS4gSW4gSUUxMC9JRTExIHRoZXJlIGlzIGEgYnVnIHdoZXJlIHRoZSBwbGFjZWhvbGRlciBhdHRyaWJ1dGVcbiAgLy8gd2lsbCBwb3B1bGF0ZSB0ZXh0Q29udGVudCBhcyB3ZWxsLlxuICAvLyBodHRwczovL2RldmVsb3Blci5taWNyb3NvZnQuY29tL21pY3Jvc29mdC1lZGdlL3BsYXRmb3JtL2lzc3Vlcy8xMDE1MjUvXG5cbiAgaWYgKHRleHRDb250ZW50ID09PSBub2RlLl93cmFwcGVyU3RhdGUuaW5pdGlhbFZhbHVlKSB7XG4gICAgaWYgKHRleHRDb250ZW50ICE9PSAnJyAmJiB0ZXh0Q29udGVudCAhPT0gbnVsbCkge1xuICAgICAgbm9kZS52YWx1ZSA9IHRleHRDb250ZW50O1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gcmVzdG9yZUNvbnRyb2xsZWRTdGF0ZSQyKGVsZW1lbnQsIHByb3BzKSB7XG4gIC8vIERPTSBjb21wb25lbnQgaXMgc3RpbGwgbW91bnRlZDsgdXBkYXRlXG4gIHVwZGF0ZVdyYXBwZXIkMShlbGVtZW50LCBwcm9wcyk7XG59XG5cbnZhciBIVE1MX05BTUVTUEFDRSA9ICdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sJztcbnZhciBNQVRIX05BTUVTUEFDRSA9ICdodHRwOi8vd3d3LnczLm9yZy8xOTk4L01hdGgvTWF0aE1MJztcbnZhciBTVkdfTkFNRVNQQUNFID0gJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJztcbnZhciBOYW1lc3BhY2VzID0ge1xuICBodG1sOiBIVE1MX05BTUVTUEFDRSxcbiAgbWF0aG1sOiBNQVRIX05BTUVTUEFDRSxcbiAgc3ZnOiBTVkdfTkFNRVNQQUNFXG59OyAvLyBBc3N1bWVzIHRoZXJlIGlzIG5vIHBhcmVudCBuYW1lc3BhY2UuXG5cbmZ1bmN0aW9uIGdldEludHJpbnNpY05hbWVzcGFjZSh0eXBlKSB7XG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgJ3N2Zyc6XG4gICAgICByZXR1cm4gU1ZHX05BTUVTUEFDRTtcblxuICAgIGNhc2UgJ21hdGgnOlxuICAgICAgcmV0dXJuIE1BVEhfTkFNRVNQQUNFO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBIVE1MX05BTUVTUEFDRTtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0Q2hpbGROYW1lc3BhY2UocGFyZW50TmFtZXNwYWNlLCB0eXBlKSB7XG4gIGlmIChwYXJlbnROYW1lc3BhY2UgPT0gbnVsbCB8fCBwYXJlbnROYW1lc3BhY2UgPT09IEhUTUxfTkFNRVNQQUNFKSB7XG4gICAgLy8gTm8gKG9yIGRlZmF1bHQpIHBhcmVudCBuYW1lc3BhY2U6IHBvdGVudGlhbCBlbnRyeSBwb2ludC5cbiAgICByZXR1cm4gZ2V0SW50cmluc2ljTmFtZXNwYWNlKHR5cGUpO1xuICB9XG5cbiAgaWYgKHBhcmVudE5hbWVzcGFjZSA9PT0gU1ZHX05BTUVTUEFDRSAmJiB0eXBlID09PSAnZm9yZWlnbk9iamVjdCcpIHtcbiAgICAvLyBXZSdyZSBsZWF2aW5nIFNWRy5cbiAgICByZXR1cm4gSFRNTF9OQU1FU1BBQ0U7XG4gIH0gLy8gQnkgZGVmYXVsdCwgcGFzcyBuYW1lc3BhY2UgYmVsb3cuXG5cblxuICByZXR1cm4gcGFyZW50TmFtZXNwYWNlO1xufVxuXG4vKiBnbG9iYWxzIE1TQXBwICovXG5cbi8qKlxuICogQ3JlYXRlIGEgZnVuY3Rpb24gd2hpY2ggaGFzICd1bnNhZmUnIHByaXZpbGVnZXMgKHJlcXVpcmVkIGJ5IHdpbmRvd3M4IGFwcHMpXG4gKi9cbnZhciBjcmVhdGVNaWNyb3NvZnRVbnNhZmVMb2NhbEZ1bmN0aW9uID0gZnVuY3Rpb24gKGZ1bmMpIHtcbiAgaWYgKHR5cGVvZiBNU0FwcCAhPT0gJ3VuZGVmaW5lZCcgJiYgTVNBcHAuZXhlY1Vuc2FmZUxvY2FsRnVuY3Rpb24pIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGFyZzAsIGFyZzEsIGFyZzIsIGFyZzMpIHtcbiAgICAgIE1TQXBwLmV4ZWNVbnNhZmVMb2NhbEZ1bmN0aW9uKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmMoYXJnMCwgYXJnMSwgYXJnMiwgYXJnMyk7XG4gICAgICB9KTtcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBmdW5jO1xuICB9XG59O1xuXG52YXIgcmV1c2FibGVTVkdDb250YWluZXI7XG4vKipcbiAqIFNldCB0aGUgaW5uZXJIVE1MIHByb3BlcnR5IG9mIGEgbm9kZVxuICpcbiAqIEBwYXJhbSB7RE9NRWxlbWVudH0gbm9kZVxuICogQHBhcmFtIHtzdHJpbmd9IGh0bWxcbiAqIEBpbnRlcm5hbFxuICovXG5cbnZhciBzZXRJbm5lckhUTUwgPSBjcmVhdGVNaWNyb3NvZnRVbnNhZmVMb2NhbEZ1bmN0aW9uKGZ1bmN0aW9uIChub2RlLCBodG1sKSB7XG4gIGlmIChub2RlLm5hbWVzcGFjZVVSSSA9PT0gTmFtZXNwYWNlcy5zdmcpIHtcblxuICAgIGlmICghKCdpbm5lckhUTUwnIGluIG5vZGUpKSB7XG4gICAgICAvLyBJRSBkb2VzIG5vdCBoYXZlIGlubmVySFRNTCBmb3IgU1ZHIG5vZGVzLCBzbyBpbnN0ZWFkIHdlIGluamVjdCB0aGVcbiAgICAgIC8vIG5ldyBtYXJrdXAgaW4gYSB0ZW1wIG5vZGUgYW5kIHRoZW4gbW92ZSB0aGUgY2hpbGQgbm9kZXMgYWNyb3NzIGludG9cbiAgICAgIC8vIHRoZSB0YXJnZXQgbm9kZVxuICAgICAgcmV1c2FibGVTVkdDb250YWluZXIgPSByZXVzYWJsZVNWR0NvbnRhaW5lciB8fCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgIHJldXNhYmxlU1ZHQ29udGFpbmVyLmlubmVySFRNTCA9ICc8c3ZnPicgKyBodG1sLnZhbHVlT2YoKS50b1N0cmluZygpICsgJzwvc3ZnPic7XG4gICAgICB2YXIgc3ZnTm9kZSA9IHJldXNhYmxlU1ZHQ29udGFpbmVyLmZpcnN0Q2hpbGQ7XG5cbiAgICAgIHdoaWxlIChub2RlLmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgbm9kZS5yZW1vdmVDaGlsZChub2RlLmZpcnN0Q2hpbGQpO1xuICAgICAgfVxuXG4gICAgICB3aGlsZSAoc3ZnTm9kZS5maXJzdENoaWxkKSB7XG4gICAgICAgIG5vZGUuYXBwZW5kQ2hpbGQoc3ZnTm9kZS5maXJzdENoaWxkKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxuXG4gIG5vZGUuaW5uZXJIVE1MID0gaHRtbDtcbn0pO1xuXG4vKipcbiAqIEhUTUwgbm9kZVR5cGUgdmFsdWVzIHRoYXQgcmVwcmVzZW50IHRoZSB0eXBlIG9mIHRoZSBub2RlXG4gKi9cbnZhciBFTEVNRU5UX05PREUgPSAxO1xudmFyIFRFWFRfTk9ERSA9IDM7XG52YXIgQ09NTUVOVF9OT0RFID0gODtcbnZhciBET0NVTUVOVF9OT0RFID0gOTtcbnZhciBET0NVTUVOVF9GUkFHTUVOVF9OT0RFID0gMTE7XG5cbi8qKlxuICogU2V0IHRoZSB0ZXh0Q29udGVudCBwcm9wZXJ0eSBvZiBhIG5vZGUuIEZvciB0ZXh0IHVwZGF0ZXMsIGl0J3MgZmFzdGVyXG4gKiB0byBzZXQgdGhlIGBub2RlVmFsdWVgIG9mIHRoZSBUZXh0IG5vZGUgZGlyZWN0bHkgaW5zdGVhZCBvZiB1c2luZ1xuICogYC50ZXh0Q29udGVudGAgd2hpY2ggd2lsbCByZW1vdmUgdGhlIGV4aXN0aW5nIG5vZGUgYW5kIGNyZWF0ZSBhIG5ldyBvbmUuXG4gKlxuICogQHBhcmFtIHtET01FbGVtZW50fSBub2RlXG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dFxuICogQGludGVybmFsXG4gKi9cblxudmFyIHNldFRleHRDb250ZW50ID0gZnVuY3Rpb24gKG5vZGUsIHRleHQpIHtcbiAgaWYgKHRleHQpIHtcbiAgICB2YXIgZmlyc3RDaGlsZCA9IG5vZGUuZmlyc3RDaGlsZDtcblxuICAgIGlmIChmaXJzdENoaWxkICYmIGZpcnN0Q2hpbGQgPT09IG5vZGUubGFzdENoaWxkICYmIGZpcnN0Q2hpbGQubm9kZVR5cGUgPT09IFRFWFRfTk9ERSkge1xuICAgICAgZmlyc3RDaGlsZC5ub2RlVmFsdWUgPSB0ZXh0O1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxuXG4gIG5vZGUudGV4dENvbnRlbnQgPSB0ZXh0O1xufTtcblxuLy8gTGlzdCBkZXJpdmVkIGZyb20gR2Vja28gc291cmNlIGNvZGU6XG4vLyBodHRwczovL2dpdGh1Yi5jb20vbW96aWxsYS9nZWNrby1kZXYvYmxvYi80ZTYzOGVmYzcxL2xheW91dC9zdHlsZS90ZXN0L3Byb3BlcnR5X2RhdGFiYXNlLmpzXG52YXIgc2hvcnRoYW5kVG9Mb25naGFuZCA9IHtcbiAgYW5pbWF0aW9uOiBbJ2FuaW1hdGlvbkRlbGF5JywgJ2FuaW1hdGlvbkRpcmVjdGlvbicsICdhbmltYXRpb25EdXJhdGlvbicsICdhbmltYXRpb25GaWxsTW9kZScsICdhbmltYXRpb25JdGVyYXRpb25Db3VudCcsICdhbmltYXRpb25OYW1lJywgJ2FuaW1hdGlvblBsYXlTdGF0ZScsICdhbmltYXRpb25UaW1pbmdGdW5jdGlvbiddLFxuICBiYWNrZ3JvdW5kOiBbJ2JhY2tncm91bmRBdHRhY2htZW50JywgJ2JhY2tncm91bmRDbGlwJywgJ2JhY2tncm91bmRDb2xvcicsICdiYWNrZ3JvdW5kSW1hZ2UnLCAnYmFja2dyb3VuZE9yaWdpbicsICdiYWNrZ3JvdW5kUG9zaXRpb25YJywgJ2JhY2tncm91bmRQb3NpdGlvblknLCAnYmFja2dyb3VuZFJlcGVhdCcsICdiYWNrZ3JvdW5kU2l6ZSddLFxuICBiYWNrZ3JvdW5kUG9zaXRpb246IFsnYmFja2dyb3VuZFBvc2l0aW9uWCcsICdiYWNrZ3JvdW5kUG9zaXRpb25ZJ10sXG4gIGJvcmRlcjogWydib3JkZXJCb3R0b21Db2xvcicsICdib3JkZXJCb3R0b21TdHlsZScsICdib3JkZXJCb3R0b21XaWR0aCcsICdib3JkZXJJbWFnZU91dHNldCcsICdib3JkZXJJbWFnZVJlcGVhdCcsICdib3JkZXJJbWFnZVNsaWNlJywgJ2JvcmRlckltYWdlU291cmNlJywgJ2JvcmRlckltYWdlV2lkdGgnLCAnYm9yZGVyTGVmdENvbG9yJywgJ2JvcmRlckxlZnRTdHlsZScsICdib3JkZXJMZWZ0V2lkdGgnLCAnYm9yZGVyUmlnaHRDb2xvcicsICdib3JkZXJSaWdodFN0eWxlJywgJ2JvcmRlclJpZ2h0V2lkdGgnLCAnYm9yZGVyVG9wQ29sb3InLCAnYm9yZGVyVG9wU3R5bGUnLCAnYm9yZGVyVG9wV2lkdGgnXSxcbiAgYm9yZGVyQmxvY2tFbmQ6IFsnYm9yZGVyQmxvY2tFbmRDb2xvcicsICdib3JkZXJCbG9ja0VuZFN0eWxlJywgJ2JvcmRlckJsb2NrRW5kV2lkdGgnXSxcbiAgYm9yZGVyQmxvY2tTdGFydDogWydib3JkZXJCbG9ja1N0YXJ0Q29sb3InLCAnYm9yZGVyQmxvY2tTdGFydFN0eWxlJywgJ2JvcmRlckJsb2NrU3RhcnRXaWR0aCddLFxuICBib3JkZXJCb3R0b206IFsnYm9yZGVyQm90dG9tQ29sb3InLCAnYm9yZGVyQm90dG9tU3R5bGUnLCAnYm9yZGVyQm90dG9tV2lkdGgnXSxcbiAgYm9yZGVyQ29sb3I6IFsnYm9yZGVyQm90dG9tQ29sb3InLCAnYm9yZGVyTGVmdENvbG9yJywgJ2JvcmRlclJpZ2h0Q29sb3InLCAnYm9yZGVyVG9wQ29sb3InXSxcbiAgYm9yZGVySW1hZ2U6IFsnYm9yZGVySW1hZ2VPdXRzZXQnLCAnYm9yZGVySW1hZ2VSZXBlYXQnLCAnYm9yZGVySW1hZ2VTbGljZScsICdib3JkZXJJbWFnZVNvdXJjZScsICdib3JkZXJJbWFnZVdpZHRoJ10sXG4gIGJvcmRlcklubGluZUVuZDogWydib3JkZXJJbmxpbmVFbmRDb2xvcicsICdib3JkZXJJbmxpbmVFbmRTdHlsZScsICdib3JkZXJJbmxpbmVFbmRXaWR0aCddLFxuICBib3JkZXJJbmxpbmVTdGFydDogWydib3JkZXJJbmxpbmVTdGFydENvbG9yJywgJ2JvcmRlcklubGluZVN0YXJ0U3R5bGUnLCAnYm9yZGVySW5saW5lU3RhcnRXaWR0aCddLFxuICBib3JkZXJMZWZ0OiBbJ2JvcmRlckxlZnRDb2xvcicsICdib3JkZXJMZWZ0U3R5bGUnLCAnYm9yZGVyTGVmdFdpZHRoJ10sXG4gIGJvcmRlclJhZGl1czogWydib3JkZXJCb3R0b21MZWZ0UmFkaXVzJywgJ2JvcmRlckJvdHRvbVJpZ2h0UmFkaXVzJywgJ2JvcmRlclRvcExlZnRSYWRpdXMnLCAnYm9yZGVyVG9wUmlnaHRSYWRpdXMnXSxcbiAgYm9yZGVyUmlnaHQ6IFsnYm9yZGVyUmlnaHRDb2xvcicsICdib3JkZXJSaWdodFN0eWxlJywgJ2JvcmRlclJpZ2h0V2lkdGgnXSxcbiAgYm9yZGVyU3R5bGU6IFsnYm9yZGVyQm90dG9tU3R5bGUnLCAnYm9yZGVyTGVmdFN0eWxlJywgJ2JvcmRlclJpZ2h0U3R5bGUnLCAnYm9yZGVyVG9wU3R5bGUnXSxcbiAgYm9yZGVyVG9wOiBbJ2JvcmRlclRvcENvbG9yJywgJ2JvcmRlclRvcFN0eWxlJywgJ2JvcmRlclRvcFdpZHRoJ10sXG4gIGJvcmRlcldpZHRoOiBbJ2JvcmRlckJvdHRvbVdpZHRoJywgJ2JvcmRlckxlZnRXaWR0aCcsICdib3JkZXJSaWdodFdpZHRoJywgJ2JvcmRlclRvcFdpZHRoJ10sXG4gIGNvbHVtblJ1bGU6IFsnY29sdW1uUnVsZUNvbG9yJywgJ2NvbHVtblJ1bGVTdHlsZScsICdjb2x1bW5SdWxlV2lkdGgnXSxcbiAgY29sdW1uczogWydjb2x1bW5Db3VudCcsICdjb2x1bW5XaWR0aCddLFxuICBmbGV4OiBbJ2ZsZXhCYXNpcycsICdmbGV4R3JvdycsICdmbGV4U2hyaW5rJ10sXG4gIGZsZXhGbG93OiBbJ2ZsZXhEaXJlY3Rpb24nLCAnZmxleFdyYXAnXSxcbiAgZm9udDogWydmb250RmFtaWx5JywgJ2ZvbnRGZWF0dXJlU2V0dGluZ3MnLCAnZm9udEtlcm5pbmcnLCAnZm9udExhbmd1YWdlT3ZlcnJpZGUnLCAnZm9udFNpemUnLCAnZm9udFNpemVBZGp1c3QnLCAnZm9udFN0cmV0Y2gnLCAnZm9udFN0eWxlJywgJ2ZvbnRWYXJpYW50JywgJ2ZvbnRWYXJpYW50QWx0ZXJuYXRlcycsICdmb250VmFyaWFudENhcHMnLCAnZm9udFZhcmlhbnRFYXN0QXNpYW4nLCAnZm9udFZhcmlhbnRMaWdhdHVyZXMnLCAnZm9udFZhcmlhbnROdW1lcmljJywgJ2ZvbnRWYXJpYW50UG9zaXRpb24nLCAnZm9udFdlaWdodCcsICdsaW5lSGVpZ2h0J10sXG4gIGZvbnRWYXJpYW50OiBbJ2ZvbnRWYXJpYW50QWx0ZXJuYXRlcycsICdmb250VmFyaWFudENhcHMnLCAnZm9udFZhcmlhbnRFYXN0QXNpYW4nLCAnZm9udFZhcmlhbnRMaWdhdHVyZXMnLCAnZm9udFZhcmlhbnROdW1lcmljJywgJ2ZvbnRWYXJpYW50UG9zaXRpb24nXSxcbiAgZ2FwOiBbJ2NvbHVtbkdhcCcsICdyb3dHYXAnXSxcbiAgZ3JpZDogWydncmlkQXV0b0NvbHVtbnMnLCAnZ3JpZEF1dG9GbG93JywgJ2dyaWRBdXRvUm93cycsICdncmlkVGVtcGxhdGVBcmVhcycsICdncmlkVGVtcGxhdGVDb2x1bW5zJywgJ2dyaWRUZW1wbGF0ZVJvd3MnXSxcbiAgZ3JpZEFyZWE6IFsnZ3JpZENvbHVtbkVuZCcsICdncmlkQ29sdW1uU3RhcnQnLCAnZ3JpZFJvd0VuZCcsICdncmlkUm93U3RhcnQnXSxcbiAgZ3JpZENvbHVtbjogWydncmlkQ29sdW1uRW5kJywgJ2dyaWRDb2x1bW5TdGFydCddLFxuICBncmlkQ29sdW1uR2FwOiBbJ2NvbHVtbkdhcCddLFxuICBncmlkR2FwOiBbJ2NvbHVtbkdhcCcsICdyb3dHYXAnXSxcbiAgZ3JpZFJvdzogWydncmlkUm93RW5kJywgJ2dyaWRSb3dTdGFydCddLFxuICBncmlkUm93R2FwOiBbJ3Jvd0dhcCddLFxuICBncmlkVGVtcGxhdGU6IFsnZ3JpZFRlbXBsYXRlQXJlYXMnLCAnZ3JpZFRlbXBsYXRlQ29sdW1ucycsICdncmlkVGVtcGxhdGVSb3dzJ10sXG4gIGxpc3RTdHlsZTogWydsaXN0U3R5bGVJbWFnZScsICdsaXN0U3R5bGVQb3NpdGlvbicsICdsaXN0U3R5bGVUeXBlJ10sXG4gIG1hcmdpbjogWydtYXJnaW5Cb3R0b20nLCAnbWFyZ2luTGVmdCcsICdtYXJnaW5SaWdodCcsICdtYXJnaW5Ub3AnXSxcbiAgbWFya2VyOiBbJ21hcmtlckVuZCcsICdtYXJrZXJNaWQnLCAnbWFya2VyU3RhcnQnXSxcbiAgbWFzazogWydtYXNrQ2xpcCcsICdtYXNrQ29tcG9zaXRlJywgJ21hc2tJbWFnZScsICdtYXNrTW9kZScsICdtYXNrT3JpZ2luJywgJ21hc2tQb3NpdGlvblgnLCAnbWFza1Bvc2l0aW9uWScsICdtYXNrUmVwZWF0JywgJ21hc2tTaXplJ10sXG4gIG1hc2tQb3NpdGlvbjogWydtYXNrUG9zaXRpb25YJywgJ21hc2tQb3NpdGlvblknXSxcbiAgb3V0bGluZTogWydvdXRsaW5lQ29sb3InLCAnb3V0bGluZVN0eWxlJywgJ291dGxpbmVXaWR0aCddLFxuICBvdmVyZmxvdzogWydvdmVyZmxvd1gnLCAnb3ZlcmZsb3dZJ10sXG4gIHBhZGRpbmc6IFsncGFkZGluZ0JvdHRvbScsICdwYWRkaW5nTGVmdCcsICdwYWRkaW5nUmlnaHQnLCAncGFkZGluZ1RvcCddLFxuICBwbGFjZUNvbnRlbnQ6IFsnYWxpZ25Db250ZW50JywgJ2p1c3RpZnlDb250ZW50J10sXG4gIHBsYWNlSXRlbXM6IFsnYWxpZ25JdGVtcycsICdqdXN0aWZ5SXRlbXMnXSxcbiAgcGxhY2VTZWxmOiBbJ2FsaWduU2VsZicsICdqdXN0aWZ5U2VsZiddLFxuICB0ZXh0RGVjb3JhdGlvbjogWyd0ZXh0RGVjb3JhdGlvbkNvbG9yJywgJ3RleHREZWNvcmF0aW9uTGluZScsICd0ZXh0RGVjb3JhdGlvblN0eWxlJ10sXG4gIHRleHRFbXBoYXNpczogWyd0ZXh0RW1waGFzaXNDb2xvcicsICd0ZXh0RW1waGFzaXNTdHlsZSddLFxuICB0cmFuc2l0aW9uOiBbJ3RyYW5zaXRpb25EZWxheScsICd0cmFuc2l0aW9uRHVyYXRpb24nLCAndHJhbnNpdGlvblByb3BlcnR5JywgJ3RyYW5zaXRpb25UaW1pbmdGdW5jdGlvbiddLFxuICB3b3JkV3JhcDogWydvdmVyZmxvd1dyYXAnXVxufTtcblxuLyoqXG4gKiBDU1MgcHJvcGVydGllcyB3aGljaCBhY2NlcHQgbnVtYmVycyBidXQgYXJlIG5vdCBpbiB1bml0cyBvZiBcInB4XCIuXG4gKi9cbnZhciBpc1VuaXRsZXNzTnVtYmVyID0ge1xuICBhbmltYXRpb25JdGVyYXRpb25Db3VudDogdHJ1ZSxcbiAgYm9yZGVySW1hZ2VPdXRzZXQ6IHRydWUsXG4gIGJvcmRlckltYWdlU2xpY2U6IHRydWUsXG4gIGJvcmRlckltYWdlV2lkdGg6IHRydWUsXG4gIGJveEZsZXg6IHRydWUsXG4gIGJveEZsZXhHcm91cDogdHJ1ZSxcbiAgYm94T3JkaW5hbEdyb3VwOiB0cnVlLFxuICBjb2x1bW5Db3VudDogdHJ1ZSxcbiAgY29sdW1uczogdHJ1ZSxcbiAgZmxleDogdHJ1ZSxcbiAgZmxleEdyb3c6IHRydWUsXG4gIGZsZXhQb3NpdGl2ZTogdHJ1ZSxcbiAgZmxleFNocmluazogdHJ1ZSxcbiAgZmxleE5lZ2F0aXZlOiB0cnVlLFxuICBmbGV4T3JkZXI6IHRydWUsXG4gIGdyaWRBcmVhOiB0cnVlLFxuICBncmlkUm93OiB0cnVlLFxuICBncmlkUm93RW5kOiB0cnVlLFxuICBncmlkUm93U3BhbjogdHJ1ZSxcbiAgZ3JpZFJvd1N0YXJ0OiB0cnVlLFxuICBncmlkQ29sdW1uOiB0cnVlLFxuICBncmlkQ29sdW1uRW5kOiB0cnVlLFxuICBncmlkQ29sdW1uU3BhbjogdHJ1ZSxcbiAgZ3JpZENvbHVtblN0YXJ0OiB0cnVlLFxuICBmb250V2VpZ2h0OiB0cnVlLFxuICBsaW5lQ2xhbXA6IHRydWUsXG4gIGxpbmVIZWlnaHQ6IHRydWUsXG4gIG9wYWNpdHk6IHRydWUsXG4gIG9yZGVyOiB0cnVlLFxuICBvcnBoYW5zOiB0cnVlLFxuICB0YWJTaXplOiB0cnVlLFxuICB3aWRvd3M6IHRydWUsXG4gIHpJbmRleDogdHJ1ZSxcbiAgem9vbTogdHJ1ZSxcbiAgLy8gU1ZHLXJlbGF0ZWQgcHJvcGVydGllc1xuICBmaWxsT3BhY2l0eTogdHJ1ZSxcbiAgZmxvb2RPcGFjaXR5OiB0cnVlLFxuICBzdG9wT3BhY2l0eTogdHJ1ZSxcbiAgc3Ryb2tlRGFzaGFycmF5OiB0cnVlLFxuICBzdHJva2VEYXNob2Zmc2V0OiB0cnVlLFxuICBzdHJva2VNaXRlcmxpbWl0OiB0cnVlLFxuICBzdHJva2VPcGFjaXR5OiB0cnVlLFxuICBzdHJva2VXaWR0aDogdHJ1ZVxufTtcbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHByZWZpeCB2ZW5kb3Itc3BlY2lmaWMgcHJlZml4LCBlZzogV2Via2l0XG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IHN0eWxlIG5hbWUsIGVnOiB0cmFuc2l0aW9uRHVyYXRpb25cbiAqIEByZXR1cm4ge3N0cmluZ30gc3R5bGUgbmFtZSBwcmVmaXhlZCB3aXRoIGBwcmVmaXhgLCBwcm9wZXJseSBjYW1lbENhc2VkLCBlZzpcbiAqIFdlYmtpdFRyYW5zaXRpb25EdXJhdGlvblxuICovXG5cbmZ1bmN0aW9uIHByZWZpeEtleShwcmVmaXgsIGtleSkge1xuICByZXR1cm4gcHJlZml4ICsga2V5LmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsga2V5LnN1YnN0cmluZygxKTtcbn1cbi8qKlxuICogU3VwcG9ydCBzdHlsZSBuYW1lcyB0aGF0IG1heSBjb21lIHBhc3NlZCBpbiBwcmVmaXhlZCBieSBhZGRpbmcgcGVybXV0YXRpb25zXG4gKiBvZiB2ZW5kb3IgcHJlZml4ZXMuXG4gKi9cblxuXG52YXIgcHJlZml4ZXMgPSBbJ1dlYmtpdCcsICdtcycsICdNb3onLCAnTyddOyAvLyBVc2luZyBPYmplY3Qua2V5cyBoZXJlLCBvciBlbHNlIHRoZSB2YW5pbGxhIGZvci1pbiBsb29wIG1ha2VzIElFOCBnbyBpbnRvIGFuXG4vLyBpbmZpbml0ZSBsb29wLCBiZWNhdXNlIGl0IGl0ZXJhdGVzIG92ZXIgdGhlIG5ld2x5IGFkZGVkIHByb3BzIHRvby5cblxuT2JqZWN0LmtleXMoaXNVbml0bGVzc051bWJlcikuZm9yRWFjaChmdW5jdGlvbiAocHJvcCkge1xuICBwcmVmaXhlcy5mb3JFYWNoKGZ1bmN0aW9uIChwcmVmaXgpIHtcbiAgICBpc1VuaXRsZXNzTnVtYmVyW3ByZWZpeEtleShwcmVmaXgsIHByb3ApXSA9IGlzVW5pdGxlc3NOdW1iZXJbcHJvcF07XG4gIH0pO1xufSk7XG5cbi8qKlxuICogQ29udmVydCBhIHZhbHVlIGludG8gdGhlIHByb3BlciBjc3Mgd3JpdGFibGUgdmFsdWUuIFRoZSBzdHlsZSBuYW1lIGBuYW1lYFxuICogc2hvdWxkIGJlIGxvZ2ljYWwgKG5vIGh5cGhlbnMpLCBhcyBzcGVjaWZpZWRcbiAqIGluIGBDU1NQcm9wZXJ0eS5pc1VuaXRsZXNzTnVtYmVyYC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBDU1MgcHJvcGVydHkgbmFtZSBzdWNoIGFzIGB0b3BNYXJnaW5gLlxuICogQHBhcmFtIHsqfSB2YWx1ZSBDU1MgcHJvcGVydHkgdmFsdWUgc3VjaCBhcyBgMTBweGAuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IE5vcm1hbGl6ZWQgc3R5bGUgdmFsdWUgd2l0aCBkaW1lbnNpb25zIGFwcGxpZWQuXG4gKi9cblxuZnVuY3Rpb24gZGFuZ2Vyb3VzU3R5bGVWYWx1ZShuYW1lLCB2YWx1ZSwgaXNDdXN0b21Qcm9wZXJ0eSkge1xuICAvLyBOb3RlIHRoYXQgd2UndmUgcmVtb3ZlZCBlc2NhcGVUZXh0Rm9yQnJvd3NlcigpIGNhbGxzIGhlcmUgc2luY2UgdGhlXG4gIC8vIHdob2xlIHN0cmluZyB3aWxsIGJlIGVzY2FwZWQgd2hlbiB0aGUgYXR0cmlidXRlIGlzIGluamVjdGVkIGludG9cbiAgLy8gdGhlIG1hcmt1cC4gSWYgeW91IHByb3ZpZGUgdW5zYWZlIHVzZXIgZGF0YSBoZXJlIHRoZXkgY2FuIGluamVjdFxuICAvLyBhcmJpdHJhcnkgQ1NTIHdoaWNoIG1heSBiZSBwcm9ibGVtYXRpYyAoSSBjb3VsZG4ndCByZXBybyB0aGlzKTpcbiAgLy8gaHR0cHM6Ly93d3cub3dhc3Aub3JnL2luZGV4LnBocC9YU1NfRmlsdGVyX0V2YXNpb25fQ2hlYXRfU2hlZXRcbiAgLy8gaHR0cDovL3d3dy50aGVzcGFubmVyLmNvLnVrLzIwMDcvMTEvMjYvdWx0aW1hdGUteHNzLWNzcy1pbmplY3Rpb24vXG4gIC8vIFRoaXMgaXMgbm90IGFuIFhTUyBob2xlIGJ1dCBpbnN0ZWFkIGEgcG90ZW50aWFsIENTUyBpbmplY3Rpb24gaXNzdWVcbiAgLy8gd2hpY2ggaGFzIGxlYWQgdG8gYSBncmVhdGVyIGRpc2N1c3Npb24gYWJvdXQgaG93IHdlJ3JlIGdvaW5nIHRvXG4gIC8vIHRydXN0IFVSTHMgbW92aW5nIGZvcndhcmQuIFNlZSAjMjExNTkwMVxuICB2YXIgaXNFbXB0eSA9IHZhbHVlID09IG51bGwgfHwgdHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicgfHwgdmFsdWUgPT09ICcnO1xuXG4gIGlmIChpc0VtcHR5KSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAgaWYgKCFpc0N1c3RvbVByb3BlcnR5ICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgJiYgdmFsdWUgIT09IDAgJiYgIShpc1VuaXRsZXNzTnVtYmVyLmhhc093blByb3BlcnR5KG5hbWUpICYmIGlzVW5pdGxlc3NOdW1iZXJbbmFtZV0pKSB7XG4gICAgcmV0dXJuIHZhbHVlICsgJ3B4JzsgLy8gUHJlc3VtZXMgaW1wbGljaXQgJ3B4JyBzdWZmaXggZm9yIHVuaXRsZXNzIG51bWJlcnNcbiAgfVxuXG4gIHJldHVybiAoJycgKyB2YWx1ZSkudHJpbSgpO1xufVxuXG52YXIgdXBwZXJjYXNlUGF0dGVybiA9IC8oW0EtWl0pL2c7XG52YXIgbXNQYXR0ZXJuID0gL15tcy0vO1xuLyoqXG4gKiBIeXBoZW5hdGVzIGEgY2FtZWxjYXNlZCBDU1MgcHJvcGVydHkgbmFtZSwgZm9yIGV4YW1wbGU6XG4gKlxuICogICA+IGh5cGhlbmF0ZVN0eWxlTmFtZSgnYmFja2dyb3VuZENvbG9yJylcbiAqICAgPCBcImJhY2tncm91bmQtY29sb3JcIlxuICogICA+IGh5cGhlbmF0ZVN0eWxlTmFtZSgnTW96VHJhbnNpdGlvbicpXG4gKiAgIDwgXCItbW96LXRyYW5zaXRpb25cIlxuICogICA+IGh5cGhlbmF0ZVN0eWxlTmFtZSgnbXNUcmFuc2l0aW9uJylcbiAqICAgPCBcIi1tcy10cmFuc2l0aW9uXCJcbiAqXG4gKiBBcyBNb2Rlcm5penIgc3VnZ2VzdHMgKGh0dHA6Ly9tb2Rlcm5penIuY29tL2RvY3MvI3ByZWZpeGVkKSwgYW4gYG1zYCBwcmVmaXhcbiAqIGlzIGNvbnZlcnRlZCB0byBgLW1zLWAuXG4gKi9cblxuZnVuY3Rpb24gaHlwaGVuYXRlU3R5bGVOYW1lKG5hbWUpIHtcbiAgcmV0dXJuIG5hbWUucmVwbGFjZSh1cHBlcmNhc2VQYXR0ZXJuLCAnLSQxJykudG9Mb3dlckNhc2UoKS5yZXBsYWNlKG1zUGF0dGVybiwgJy1tcy0nKTtcbn1cblxudmFyIHdhcm5WYWxpZFN0eWxlID0gZnVuY3Rpb24gKCkge307XG5cbntcbiAgLy8gJ21zVHJhbnNmb3JtJyBpcyBjb3JyZWN0LCBidXQgdGhlIG90aGVyIHByZWZpeGVzIHNob3VsZCBiZSBjYXBpdGFsaXplZFxuICB2YXIgYmFkVmVuZG9yZWRTdHlsZU5hbWVQYXR0ZXJuID0gL14oPzp3ZWJraXR8bW96fG8pW0EtWl0vO1xuICB2YXIgbXNQYXR0ZXJuJDEgPSAvXi1tcy0vO1xuICB2YXIgaHlwaGVuUGF0dGVybiA9IC8tKC4pL2c7IC8vIHN0eWxlIHZhbHVlcyBzaG91bGRuJ3QgY29udGFpbiBhIHNlbWljb2xvblxuXG4gIHZhciBiYWRTdHlsZVZhbHVlV2l0aFNlbWljb2xvblBhdHRlcm4gPSAvO1xccyokLztcbiAgdmFyIHdhcm5lZFN0eWxlTmFtZXMgPSB7fTtcbiAgdmFyIHdhcm5lZFN0eWxlVmFsdWVzID0ge307XG4gIHZhciB3YXJuZWRGb3JOYU5WYWx1ZSA9IGZhbHNlO1xuICB2YXIgd2FybmVkRm9ySW5maW5pdHlWYWx1ZSA9IGZhbHNlO1xuXG4gIHZhciBjYW1lbGl6ZSA9IGZ1bmN0aW9uIChzdHJpbmcpIHtcbiAgICByZXR1cm4gc3RyaW5nLnJlcGxhY2UoaHlwaGVuUGF0dGVybiwgZnVuY3Rpb24gKF8sIGNoYXJhY3Rlcikge1xuICAgICAgcmV0dXJuIGNoYXJhY3Rlci50b1VwcGVyQ2FzZSgpO1xuICAgIH0pO1xuICB9O1xuXG4gIHZhciB3YXJuSHlwaGVuYXRlZFN0eWxlTmFtZSA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgaWYgKHdhcm5lZFN0eWxlTmFtZXMuaGFzT3duUHJvcGVydHkobmFtZSkgJiYgd2FybmVkU3R5bGVOYW1lc1tuYW1lXSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHdhcm5lZFN0eWxlTmFtZXNbbmFtZV0gPSB0cnVlO1xuXG4gICAgZXJyb3IoJ1Vuc3VwcG9ydGVkIHN0eWxlIHByb3BlcnR5ICVzLiBEaWQgeW91IG1lYW4gJXM/JywgbmFtZSwgLy8gQXMgQW5kaSBTbWl0aCBzdWdnZXN0c1xuICAgIC8vIChodHRwOi8vd3d3LmFuZGlzbWl0aC5jb20vYmxvZy8yMDEyLzAyL21vZGVybml6ci1wcmVmaXhlZC8pLCBhbiBgLW1zYCBwcmVmaXhcbiAgICAvLyBpcyBjb252ZXJ0ZWQgdG8gbG93ZXJjYXNlIGBtc2AuXG4gICAgY2FtZWxpemUobmFtZS5yZXBsYWNlKG1zUGF0dGVybiQxLCAnbXMtJykpKTtcbiAgfTtcblxuICB2YXIgd2FybkJhZFZlbmRvcmVkU3R5bGVOYW1lID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICBpZiAod2FybmVkU3R5bGVOYW1lcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSAmJiB3YXJuZWRTdHlsZU5hbWVzW25hbWVdKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgd2FybmVkU3R5bGVOYW1lc1tuYW1lXSA9IHRydWU7XG5cbiAgICBlcnJvcignVW5zdXBwb3J0ZWQgdmVuZG9yLXByZWZpeGVkIHN0eWxlIHByb3BlcnR5ICVzLiBEaWQgeW91IG1lYW4gJXM/JywgbmFtZSwgbmFtZS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIG5hbWUuc2xpY2UoMSkpO1xuICB9O1xuXG4gIHZhciB3YXJuU3R5bGVWYWx1ZVdpdGhTZW1pY29sb24gPSBmdW5jdGlvbiAobmFtZSwgdmFsdWUpIHtcbiAgICBpZiAod2FybmVkU3R5bGVWYWx1ZXMuaGFzT3duUHJvcGVydHkodmFsdWUpICYmIHdhcm5lZFN0eWxlVmFsdWVzW3ZhbHVlXSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHdhcm5lZFN0eWxlVmFsdWVzW3ZhbHVlXSA9IHRydWU7XG5cbiAgICBlcnJvcihcIlN0eWxlIHByb3BlcnR5IHZhbHVlcyBzaG91bGRuJ3QgY29udGFpbiBhIHNlbWljb2xvbi4gXCIgKyAnVHJ5IFwiJXM6ICVzXCIgaW5zdGVhZC4nLCBuYW1lLCB2YWx1ZS5yZXBsYWNlKGJhZFN0eWxlVmFsdWVXaXRoU2VtaWNvbG9uUGF0dGVybiwgJycpKTtcbiAgfTtcblxuICB2YXIgd2FyblN0eWxlVmFsdWVJc05hTiA9IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSkge1xuICAgIGlmICh3YXJuZWRGb3JOYU5WYWx1ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHdhcm5lZEZvck5hTlZhbHVlID0gdHJ1ZTtcblxuICAgIGVycm9yKCdgTmFOYCBpcyBhbiBpbnZhbGlkIHZhbHVlIGZvciB0aGUgYCVzYCBjc3Mgc3R5bGUgcHJvcGVydHkuJywgbmFtZSk7XG4gIH07XG5cbiAgdmFyIHdhcm5TdHlsZVZhbHVlSXNJbmZpbml0eSA9IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSkge1xuICAgIGlmICh3YXJuZWRGb3JJbmZpbml0eVZhbHVlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgd2FybmVkRm9ySW5maW5pdHlWYWx1ZSA9IHRydWU7XG5cbiAgICBlcnJvcignYEluZmluaXR5YCBpcyBhbiBpbnZhbGlkIHZhbHVlIGZvciB0aGUgYCVzYCBjc3Mgc3R5bGUgcHJvcGVydHkuJywgbmFtZSk7XG4gIH07XG5cbiAgd2FyblZhbGlkU3R5bGUgPSBmdW5jdGlvbiAobmFtZSwgdmFsdWUpIHtcbiAgICBpZiAobmFtZS5pbmRleE9mKCctJykgPiAtMSkge1xuICAgICAgd2Fybkh5cGhlbmF0ZWRTdHlsZU5hbWUobmFtZSk7XG4gICAgfSBlbHNlIGlmIChiYWRWZW5kb3JlZFN0eWxlTmFtZVBhdHRlcm4udGVzdChuYW1lKSkge1xuICAgICAgd2FybkJhZFZlbmRvcmVkU3R5bGVOYW1lKG5hbWUpO1xuICAgIH0gZWxzZSBpZiAoYmFkU3R5bGVWYWx1ZVdpdGhTZW1pY29sb25QYXR0ZXJuLnRlc3QodmFsdWUpKSB7XG4gICAgICB3YXJuU3R5bGVWYWx1ZVdpdGhTZW1pY29sb24obmFtZSwgdmFsdWUpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgICBpZiAoaXNOYU4odmFsdWUpKSB7XG4gICAgICAgIHdhcm5TdHlsZVZhbHVlSXNOYU4obmFtZSwgdmFsdWUpO1xuICAgICAgfSBlbHNlIGlmICghaXNGaW5pdGUodmFsdWUpKSB7XG4gICAgICAgIHdhcm5TdHlsZVZhbHVlSXNJbmZpbml0eShuYW1lLCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xufVxuXG52YXIgd2FyblZhbGlkU3R5bGUkMSA9IHdhcm5WYWxpZFN0eWxlO1xuXG4vKipcbiAqIE9wZXJhdGlvbnMgZm9yIGRlYWxpbmcgd2l0aCBDU1MgcHJvcGVydGllcy5cbiAqL1xuXG4vKipcbiAqIFRoaXMgY3JlYXRlcyBhIHN0cmluZyB0aGF0IGlzIGV4cGVjdGVkIHRvIGJlIGVxdWl2YWxlbnQgdG8gdGhlIHN0eWxlXG4gKiBhdHRyaWJ1dGUgZ2VuZXJhdGVkIGJ5IHNlcnZlci1zaWRlIHJlbmRlcmluZy4gSXQgYnktcGFzc2VzIHdhcm5pbmdzIGFuZFxuICogc2VjdXJpdHkgY2hlY2tzIHNvIGl0J3Mgbm90IHNhZmUgdG8gdXNlIHRoaXMgdmFsdWUgZm9yIGFueXRoaW5nIG90aGVyIHRoYW5cbiAqIGNvbXBhcmlzb24uIEl0IGlzIG9ubHkgdXNlZCBpbiBERVYgZm9yIFNTUiB2YWxpZGF0aW9uLlxuICovXG5cbmZ1bmN0aW9uIGNyZWF0ZURhbmdlcm91c1N0cmluZ0ZvclN0eWxlcyhzdHlsZXMpIHtcbiAge1xuICAgIHZhciBzZXJpYWxpemVkID0gJyc7XG4gICAgdmFyIGRlbGltaXRlciA9ICcnO1xuXG4gICAgZm9yICh2YXIgc3R5bGVOYW1lIGluIHN0eWxlcykge1xuICAgICAgaWYgKCFzdHlsZXMuaGFzT3duUHJvcGVydHkoc3R5bGVOYW1lKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgdmFyIHN0eWxlVmFsdWUgPSBzdHlsZXNbc3R5bGVOYW1lXTtcblxuICAgICAgaWYgKHN0eWxlVmFsdWUgIT0gbnVsbCkge1xuICAgICAgICB2YXIgaXNDdXN0b21Qcm9wZXJ0eSA9IHN0eWxlTmFtZS5pbmRleE9mKCctLScpID09PSAwO1xuICAgICAgICBzZXJpYWxpemVkICs9IGRlbGltaXRlciArIChpc0N1c3RvbVByb3BlcnR5ID8gc3R5bGVOYW1lIDogaHlwaGVuYXRlU3R5bGVOYW1lKHN0eWxlTmFtZSkpICsgJzonO1xuICAgICAgICBzZXJpYWxpemVkICs9IGRhbmdlcm91c1N0eWxlVmFsdWUoc3R5bGVOYW1lLCBzdHlsZVZhbHVlLCBpc0N1c3RvbVByb3BlcnR5KTtcbiAgICAgICAgZGVsaW1pdGVyID0gJzsnO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBzZXJpYWxpemVkIHx8IG51bGw7XG4gIH1cbn1cbi8qKlxuICogU2V0cyB0aGUgdmFsdWUgZm9yIG11bHRpcGxlIHN0eWxlcyBvbiBhIG5vZGUuICBJZiBhIHZhbHVlIGlzIHNwZWNpZmllZCBhc1xuICogJycgKGVtcHR5IHN0cmluZyksIHRoZSBjb3JyZXNwb25kaW5nIHN0eWxlIHByb3BlcnR5IHdpbGwgYmUgdW5zZXQuXG4gKlxuICogQHBhcmFtIHtET01FbGVtZW50fSBub2RlXG4gKiBAcGFyYW0ge29iamVjdH0gc3R5bGVzXG4gKi9cblxuZnVuY3Rpb24gc2V0VmFsdWVGb3JTdHlsZXMobm9kZSwgc3R5bGVzKSB7XG4gIHZhciBzdHlsZSA9IG5vZGUuc3R5bGU7XG5cbiAgZm9yICh2YXIgc3R5bGVOYW1lIGluIHN0eWxlcykge1xuICAgIGlmICghc3R5bGVzLmhhc093blByb3BlcnR5KHN0eWxlTmFtZSkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIHZhciBpc0N1c3RvbVByb3BlcnR5ID0gc3R5bGVOYW1lLmluZGV4T2YoJy0tJykgPT09IDA7XG5cbiAgICB7XG4gICAgICBpZiAoIWlzQ3VzdG9tUHJvcGVydHkpIHtcbiAgICAgICAgd2FyblZhbGlkU3R5bGUkMShzdHlsZU5hbWUsIHN0eWxlc1tzdHlsZU5hbWVdKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgc3R5bGVWYWx1ZSA9IGRhbmdlcm91c1N0eWxlVmFsdWUoc3R5bGVOYW1lLCBzdHlsZXNbc3R5bGVOYW1lXSwgaXNDdXN0b21Qcm9wZXJ0eSk7XG5cbiAgICBpZiAoc3R5bGVOYW1lID09PSAnZmxvYXQnKSB7XG4gICAgICBzdHlsZU5hbWUgPSAnY3NzRmxvYXQnO1xuICAgIH1cblxuICAgIGlmIChpc0N1c3RvbVByb3BlcnR5KSB7XG4gICAgICBzdHlsZS5zZXRQcm9wZXJ0eShzdHlsZU5hbWUsIHN0eWxlVmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdHlsZVtzdHlsZU5hbWVdID0gc3R5bGVWYWx1ZTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNWYWx1ZUVtcHR5KHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA9PSBudWxsIHx8IHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nIHx8IHZhbHVlID09PSAnJztcbn1cbi8qKlxuICogR2l2ZW4ge2NvbG9yOiAncmVkJywgb3ZlcmZsb3c6ICdoaWRkZW4nfSByZXR1cm5zIHtcbiAqICAgY29sb3I6ICdjb2xvcicsXG4gKiAgIG92ZXJmbG93WDogJ292ZXJmbG93JyxcbiAqICAgb3ZlcmZsb3dZOiAnb3ZlcmZsb3cnLFxuICogfS4gVGhpcyBjYW4gYmUgcmVhZCBhcyBcInRoZSBvdmVyZmxvd1kgcHJvcGVydHkgd2FzIHNldCBieSB0aGUgb3ZlcmZsb3dcbiAqIHNob3J0aGFuZFwiLiBUaGF0IGlzLCB0aGUgdmFsdWVzIGFyZSB0aGUgcHJvcGVydHkgdGhhdCBlYWNoIHdhcyBkZXJpdmVkIGZyb20uXG4gKi9cblxuXG5mdW5jdGlvbiBleHBhbmRTaG9ydGhhbmRNYXAoc3R5bGVzKSB7XG4gIHZhciBleHBhbmRlZCA9IHt9O1xuXG4gIGZvciAodmFyIGtleSBpbiBzdHlsZXMpIHtcbiAgICB2YXIgbG9uZ2hhbmRzID0gc2hvcnRoYW5kVG9Mb25naGFuZFtrZXldIHx8IFtrZXldO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsb25naGFuZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGV4cGFuZGVkW2xvbmdoYW5kc1tpXV0gPSBrZXk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGV4cGFuZGVkO1xufVxuLyoqXG4gKiBXaGVuIG1peGluZyBzaG9ydGhhbmQgYW5kIGxvbmdoYW5kIHByb3BlcnR5IG5hbWVzLCB3ZSB3YXJuIGR1cmluZyB1cGRhdGVzIGlmXG4gKiB3ZSBleHBlY3QgYW4gaW5jb3JyZWN0IHJlc3VsdCB0byBvY2N1ci4gSW4gcGFydGljdWxhciwgd2Ugd2FybiBmb3I6XG4gKlxuICogVXBkYXRpbmcgYSBzaG9ydGhhbmQgcHJvcGVydHkgKGxvbmdoYW5kIGdldHMgb3ZlcndyaXR0ZW4pOlxuICogICB7Zm9udDogJ2ZvbycsIGZvbnRWYXJpYW50OiAnYmFyJ30gLT4ge2ZvbnQ6ICdiYXonLCBmb250VmFyaWFudDogJ2Jhcid9XG4gKiAgIGJlY29tZXMgLnN0eWxlLmZvbnQgPSAnYmF6J1xuICogUmVtb3ZpbmcgYSBzaG9ydGhhbmQgcHJvcGVydHkgKGxvbmdoYW5kIGdldHMgbG9zdCB0b28pOlxuICogICB7Zm9udDogJ2ZvbycsIGZvbnRWYXJpYW50OiAnYmFyJ30gLT4ge2ZvbnRWYXJpYW50OiAnYmFyJ31cbiAqICAgYmVjb21lcyAuc3R5bGUuZm9udCA9ICcnXG4gKiBSZW1vdmluZyBhIGxvbmdoYW5kIHByb3BlcnR5IChzaG91bGQgcmV2ZXJ0IHRvIHNob3J0aGFuZDsgZG9lc24ndCk6XG4gKiAgIHtmb250OiAnZm9vJywgZm9udFZhcmlhbnQ6ICdiYXInfSAtPiB7Zm9udDogJ2Zvbyd9XG4gKiAgIGJlY29tZXMgLnN0eWxlLmZvbnRWYXJpYW50ID0gJydcbiAqL1xuXG5cbmZ1bmN0aW9uIHZhbGlkYXRlU2hvcnRoYW5kUHJvcGVydHlDb2xsaXNpb25JbkRldihzdHlsZVVwZGF0ZXMsIG5leHRTdHlsZXMpIHtcbiAge1xuICAgIGlmICghbmV4dFN0eWxlcykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBleHBhbmRlZFVwZGF0ZXMgPSBleHBhbmRTaG9ydGhhbmRNYXAoc3R5bGVVcGRhdGVzKTtcbiAgICB2YXIgZXhwYW5kZWRTdHlsZXMgPSBleHBhbmRTaG9ydGhhbmRNYXAobmV4dFN0eWxlcyk7XG4gICAgdmFyIHdhcm5lZEFib3V0ID0ge307XG5cbiAgICBmb3IgKHZhciBrZXkgaW4gZXhwYW5kZWRVcGRhdGVzKSB7XG4gICAgICB2YXIgb3JpZ2luYWxLZXkgPSBleHBhbmRlZFVwZGF0ZXNba2V5XTtcbiAgICAgIHZhciBjb3JyZWN0T3JpZ2luYWxLZXkgPSBleHBhbmRlZFN0eWxlc1trZXldO1xuXG4gICAgICBpZiAoY29ycmVjdE9yaWdpbmFsS2V5ICYmIG9yaWdpbmFsS2V5ICE9PSBjb3JyZWN0T3JpZ2luYWxLZXkpIHtcbiAgICAgICAgdmFyIHdhcm5pbmdLZXkgPSBvcmlnaW5hbEtleSArICcsJyArIGNvcnJlY3RPcmlnaW5hbEtleTtcblxuICAgICAgICBpZiAod2FybmVkQWJvdXRbd2FybmluZ0tleV0pIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHdhcm5lZEFib3V0W3dhcm5pbmdLZXldID0gdHJ1ZTtcblxuICAgICAgICBlcnJvcignJXMgYSBzdHlsZSBwcm9wZXJ0eSBkdXJpbmcgcmVyZW5kZXIgKCVzKSB3aGVuIGEgJyArICdjb25mbGljdGluZyBwcm9wZXJ0eSBpcyBzZXQgKCVzKSBjYW4gbGVhZCB0byBzdHlsaW5nIGJ1Z3MuIFRvICcgKyBcImF2b2lkIHRoaXMsIGRvbid0IG1peCBzaG9ydGhhbmQgYW5kIG5vbi1zaG9ydGhhbmQgcHJvcGVydGllcyBcIiArICdmb3IgdGhlIHNhbWUgdmFsdWU7IGluc3RlYWQsIHJlcGxhY2UgdGhlIHNob3J0aGFuZCB3aXRoICcgKyAnc2VwYXJhdGUgdmFsdWVzLicsIGlzVmFsdWVFbXB0eShzdHlsZVVwZGF0ZXNbb3JpZ2luYWxLZXldKSA/ICdSZW1vdmluZycgOiAnVXBkYXRpbmcnLCBvcmlnaW5hbEtleSwgY29ycmVjdE9yaWdpbmFsS2V5KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLy8gRm9yIEhUTUwsIGNlcnRhaW4gdGFncyBzaG91bGQgb21pdCB0aGVpciBjbG9zZSB0YWcuIFdlIGtlZXAgYSBsaXN0IGZvclxuLy8gdGhvc2Ugc3BlY2lhbC1jYXNlIHRhZ3MuXG52YXIgb21pdHRlZENsb3NlVGFncyA9IHtcbiAgYXJlYTogdHJ1ZSxcbiAgYmFzZTogdHJ1ZSxcbiAgYnI6IHRydWUsXG4gIGNvbDogdHJ1ZSxcbiAgZW1iZWQ6IHRydWUsXG4gIGhyOiB0cnVlLFxuICBpbWc6IHRydWUsXG4gIGlucHV0OiB0cnVlLFxuICBrZXlnZW46IHRydWUsXG4gIGxpbms6IHRydWUsXG4gIG1ldGE6IHRydWUsXG4gIHBhcmFtOiB0cnVlLFxuICBzb3VyY2U6IHRydWUsXG4gIHRyYWNrOiB0cnVlLFxuICB3YnI6IHRydWUgLy8gTk9URTogbWVudWl0ZW0ncyBjbG9zZSB0YWcgc2hvdWxkIGJlIG9taXR0ZWQsIGJ1dCB0aGF0IGNhdXNlcyBwcm9ibGVtcy5cblxufTtcblxuLy8gYG9taXR0ZWRDbG9zZVRhZ3NgIGV4Y2VwdCB0aGF0IGBtZW51aXRlbWAgc2hvdWxkIHN0aWxsIGhhdmUgaXRzIGNsb3NpbmcgdGFnLlxuXG52YXIgdm9pZEVsZW1lbnRUYWdzID0gX2Fzc2lnbih7XG4gIG1lbnVpdGVtOiB0cnVlXG59LCBvbWl0dGVkQ2xvc2VUYWdzKTtcblxudmFyIEhUTUwgPSAnX19odG1sJztcblxuZnVuY3Rpb24gYXNzZXJ0VmFsaWRQcm9wcyh0YWcsIHByb3BzKSB7XG4gIGlmICghcHJvcHMpIHtcbiAgICByZXR1cm47XG4gIH0gLy8gTm90ZSB0aGUgdXNlIG9mIGA9PWAgd2hpY2ggY2hlY2tzIGZvciBudWxsIG9yIHVuZGVmaW5lZC5cblxuXG4gIGlmICh2b2lkRWxlbWVudFRhZ3NbdGFnXSkge1xuICAgIGlmICghKHByb3BzLmNoaWxkcmVuID09IG51bGwgJiYgcHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwgPT0gbnVsbCkpIHtcbiAgICAgIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoIHRhZyArIFwiIGlzIGEgdm9pZCBlbGVtZW50IHRhZyBhbmQgbXVzdCBuZWl0aGVyIGhhdmUgYGNoaWxkcmVuYCBub3IgdXNlIGBkYW5nZXJvdXNseVNldElubmVySFRNTGAuXCIgKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAocHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwgIT0gbnVsbCkge1xuICAgIGlmICghKHByb3BzLmNoaWxkcmVuID09IG51bGwpKSB7XG4gICAgICB7XG4gICAgICAgIHRocm93IEVycm9yKCBcIkNhbiBvbmx5IHNldCBvbmUgb2YgYGNoaWxkcmVuYCBvciBgcHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxgLlwiICk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCEodHlwZW9mIHByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MID09PSAnb2JqZWN0JyAmJiBIVE1MIGluIHByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MKSkge1xuICAgICAge1xuICAgICAgICB0aHJvdyBFcnJvciggXCJgcHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxgIG11c3QgYmUgaW4gdGhlIGZvcm0gYHtfX2h0bWw6IC4uLn1gLiBQbGVhc2UgdmlzaXQgaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL2Rhbmdlcm91c2x5LXNldC1pbm5lci1odG1sIGZvciBtb3JlIGluZm9ybWF0aW9uLlwiICk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAge1xuICAgIGlmICghcHJvcHMuc3VwcHJlc3NDb250ZW50RWRpdGFibGVXYXJuaW5nICYmIHByb3BzLmNvbnRlbnRFZGl0YWJsZSAmJiBwcm9wcy5jaGlsZHJlbiAhPSBudWxsKSB7XG4gICAgICBlcnJvcignQSBjb21wb25lbnQgaXMgYGNvbnRlbnRFZGl0YWJsZWAgYW5kIGNvbnRhaW5zIGBjaGlsZHJlbmAgbWFuYWdlZCBieSAnICsgJ1JlYWN0LiBJdCBpcyBub3cgeW91ciByZXNwb25zaWJpbGl0eSB0byBndWFyYW50ZWUgdGhhdCBub25lIG9mICcgKyAndGhvc2Ugbm9kZXMgYXJlIHVuZXhwZWN0ZWRseSBtb2RpZmllZCBvciBkdXBsaWNhdGVkLiBUaGlzIGlzICcgKyAncHJvYmFibHkgbm90IGludGVudGlvbmFsLicpO1xuICAgIH1cbiAgfVxuXG4gIGlmICghKHByb3BzLnN0eWxlID09IG51bGwgfHwgdHlwZW9mIHByb3BzLnN0eWxlID09PSAnb2JqZWN0JykpIHtcbiAgICB7XG4gICAgICB0aHJvdyBFcnJvciggXCJUaGUgYHN0eWxlYCBwcm9wIGV4cGVjdHMgYSBtYXBwaW5nIGZyb20gc3R5bGUgcHJvcGVydGllcyB0byB2YWx1ZXMsIG5vdCBhIHN0cmluZy4gRm9yIGV4YW1wbGUsIHN0eWxlPXt7bWFyZ2luUmlnaHQ6IHNwYWNpbmcgKyAnZW0nfX0gd2hlbiB1c2luZyBKU1guXCIgKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNDdXN0b21Db21wb25lbnQodGFnTmFtZSwgcHJvcHMpIHtcbiAgaWYgKHRhZ05hbWUuaW5kZXhPZignLScpID09PSAtMSkge1xuICAgIHJldHVybiB0eXBlb2YgcHJvcHMuaXMgPT09ICdzdHJpbmcnO1xuICB9XG5cbiAgc3dpdGNoICh0YWdOYW1lKSB7XG4gICAgLy8gVGhlc2UgYXJlIHJlc2VydmVkIFNWRyBhbmQgTWF0aE1MIGVsZW1lbnRzLlxuICAgIC8vIFdlIGRvbid0IG1pbmQgdGhpcyBsaXN0IHRvbyBtdWNoIGJlY2F1c2Ugd2UgZXhwZWN0IGl0IHRvIG5ldmVyIGdyb3cuXG4gICAgLy8gVGhlIGFsdGVybmF0aXZlIGlzIHRvIHRyYWNrIHRoZSBuYW1lc3BhY2UgaW4gYSBmZXcgcGxhY2VzIHdoaWNoIGlzIGNvbnZvbHV0ZWQuXG4gICAgLy8gaHR0cHM6Ly93M2MuZ2l0aHViLmlvL3dlYmNvbXBvbmVudHMvc3BlYy9jdXN0b20vI2N1c3RvbS1lbGVtZW50cy1jb3JlLWNvbmNlcHRzXG4gICAgY2FzZSAnYW5ub3RhdGlvbi14bWwnOlxuICAgIGNhc2UgJ2NvbG9yLXByb2ZpbGUnOlxuICAgIGNhc2UgJ2ZvbnQtZmFjZSc6XG4gICAgY2FzZSAnZm9udC1mYWNlLXNyYyc6XG4gICAgY2FzZSAnZm9udC1mYWNlLXVyaSc6XG4gICAgY2FzZSAnZm9udC1mYWNlLWZvcm1hdCc6XG4gICAgY2FzZSAnZm9udC1mYWNlLW5hbWUnOlxuICAgIGNhc2UgJ21pc3NpbmctZ2x5cGgnOlxuICAgICAgcmV0dXJuIGZhbHNlO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiB0cnVlO1xuICB9XG59XG5cbi8vIFdoZW4gYWRkaW5nIGF0dHJpYnV0ZXMgdG8gdGhlIEhUTUwgb3IgU1ZHIGFsbG93ZWQgYXR0cmlidXRlIGxpc3QsIGJlIHN1cmUgdG9cbi8vIGFsc28gYWRkIHRoZW0gdG8gdGhpcyBtb2R1bGUgdG8gZW5zdXJlIGNhc2luZyBhbmQgaW5jb3JyZWN0IG5hbWVcbi8vIHdhcm5pbmdzLlxudmFyIHBvc3NpYmxlU3RhbmRhcmROYW1lcyA9IHtcbiAgLy8gSFRNTFxuICBhY2NlcHQ6ICdhY2NlcHQnLFxuICBhY2NlcHRjaGFyc2V0OiAnYWNjZXB0Q2hhcnNldCcsXG4gICdhY2NlcHQtY2hhcnNldCc6ICdhY2NlcHRDaGFyc2V0JyxcbiAgYWNjZXNza2V5OiAnYWNjZXNzS2V5JyxcbiAgYWN0aW9uOiAnYWN0aW9uJyxcbiAgYWxsb3dmdWxsc2NyZWVuOiAnYWxsb3dGdWxsU2NyZWVuJyxcbiAgYWx0OiAnYWx0JyxcbiAgYXM6ICdhcycsXG4gIGFzeW5jOiAnYXN5bmMnLFxuICBhdXRvY2FwaXRhbGl6ZTogJ2F1dG9DYXBpdGFsaXplJyxcbiAgYXV0b2NvbXBsZXRlOiAnYXV0b0NvbXBsZXRlJyxcbiAgYXV0b2NvcnJlY3Q6ICdhdXRvQ29ycmVjdCcsXG4gIGF1dG9mb2N1czogJ2F1dG9Gb2N1cycsXG4gIGF1dG9wbGF5OiAnYXV0b1BsYXknLFxuICBhdXRvc2F2ZTogJ2F1dG9TYXZlJyxcbiAgY2FwdHVyZTogJ2NhcHR1cmUnLFxuICBjZWxscGFkZGluZzogJ2NlbGxQYWRkaW5nJyxcbiAgY2VsbHNwYWNpbmc6ICdjZWxsU3BhY2luZycsXG4gIGNoYWxsZW5nZTogJ2NoYWxsZW5nZScsXG4gIGNoYXJzZXQ6ICdjaGFyU2V0JyxcbiAgY2hlY2tlZDogJ2NoZWNrZWQnLFxuICBjaGlsZHJlbjogJ2NoaWxkcmVuJyxcbiAgY2l0ZTogJ2NpdGUnLFxuICBjbGFzczogJ2NsYXNzTmFtZScsXG4gIGNsYXNzaWQ6ICdjbGFzc0lEJyxcbiAgY2xhc3NuYW1lOiAnY2xhc3NOYW1lJyxcbiAgY29sczogJ2NvbHMnLFxuICBjb2xzcGFuOiAnY29sU3BhbicsXG4gIGNvbnRlbnQ6ICdjb250ZW50JyxcbiAgY29udGVudGVkaXRhYmxlOiAnY29udGVudEVkaXRhYmxlJyxcbiAgY29udGV4dG1lbnU6ICdjb250ZXh0TWVudScsXG4gIGNvbnRyb2xzOiAnY29udHJvbHMnLFxuICBjb250cm9sc2xpc3Q6ICdjb250cm9sc0xpc3QnLFxuICBjb29yZHM6ICdjb29yZHMnLFxuICBjcm9zc29yaWdpbjogJ2Nyb3NzT3JpZ2luJyxcbiAgZGFuZ2Vyb3VzbHlzZXRpbm5lcmh0bWw6ICdkYW5nZXJvdXNseVNldElubmVySFRNTCcsXG4gIGRhdGE6ICdkYXRhJyxcbiAgZGF0ZXRpbWU6ICdkYXRlVGltZScsXG4gIGRlZmF1bHQ6ICdkZWZhdWx0JyxcbiAgZGVmYXVsdGNoZWNrZWQ6ICdkZWZhdWx0Q2hlY2tlZCcsXG4gIGRlZmF1bHR2YWx1ZTogJ2RlZmF1bHRWYWx1ZScsXG4gIGRlZmVyOiAnZGVmZXInLFxuICBkaXI6ICdkaXInLFxuICBkaXNhYmxlZDogJ2Rpc2FibGVkJyxcbiAgZGlzYWJsZXBpY3R1cmVpbnBpY3R1cmU6ICdkaXNhYmxlUGljdHVyZUluUGljdHVyZScsXG4gIGRpc2FibGVyZW1vdGVwbGF5YmFjazogJ2Rpc2FibGVSZW1vdGVQbGF5YmFjaycsXG4gIGRvd25sb2FkOiAnZG93bmxvYWQnLFxuICBkcmFnZ2FibGU6ICdkcmFnZ2FibGUnLFxuICBlbmN0eXBlOiAnZW5jVHlwZScsXG4gIGVudGVya2V5aGludDogJ2VudGVyS2V5SGludCcsXG4gIGZvcjogJ2h0bWxGb3InLFxuICBmb3JtOiAnZm9ybScsXG4gIGZvcm1tZXRob2Q6ICdmb3JtTWV0aG9kJyxcbiAgZm9ybWFjdGlvbjogJ2Zvcm1BY3Rpb24nLFxuICBmb3JtZW5jdHlwZTogJ2Zvcm1FbmNUeXBlJyxcbiAgZm9ybW5vdmFsaWRhdGU6ICdmb3JtTm9WYWxpZGF0ZScsXG4gIGZvcm10YXJnZXQ6ICdmb3JtVGFyZ2V0JyxcbiAgZnJhbWVib3JkZXI6ICdmcmFtZUJvcmRlcicsXG4gIGhlYWRlcnM6ICdoZWFkZXJzJyxcbiAgaGVpZ2h0OiAnaGVpZ2h0JyxcbiAgaGlkZGVuOiAnaGlkZGVuJyxcbiAgaGlnaDogJ2hpZ2gnLFxuICBocmVmOiAnaHJlZicsXG4gIGhyZWZsYW5nOiAnaHJlZkxhbmcnLFxuICBodG1sZm9yOiAnaHRtbEZvcicsXG4gIGh0dHBlcXVpdjogJ2h0dHBFcXVpdicsXG4gICdodHRwLWVxdWl2JzogJ2h0dHBFcXVpdicsXG4gIGljb246ICdpY29uJyxcbiAgaWQ6ICdpZCcsXG4gIGlubmVyaHRtbDogJ2lubmVySFRNTCcsXG4gIGlucHV0bW9kZTogJ2lucHV0TW9kZScsXG4gIGludGVncml0eTogJ2ludGVncml0eScsXG4gIGlzOiAnaXMnLFxuICBpdGVtaWQ6ICdpdGVtSUQnLFxuICBpdGVtcHJvcDogJ2l0ZW1Qcm9wJyxcbiAgaXRlbXJlZjogJ2l0ZW1SZWYnLFxuICBpdGVtc2NvcGU6ICdpdGVtU2NvcGUnLFxuICBpdGVtdHlwZTogJ2l0ZW1UeXBlJyxcbiAga2V5cGFyYW1zOiAna2V5UGFyYW1zJyxcbiAga2V5dHlwZTogJ2tleVR5cGUnLFxuICBraW5kOiAna2luZCcsXG4gIGxhYmVsOiAnbGFiZWwnLFxuICBsYW5nOiAnbGFuZycsXG4gIGxpc3Q6ICdsaXN0JyxcbiAgbG9vcDogJ2xvb3AnLFxuICBsb3c6ICdsb3cnLFxuICBtYW5pZmVzdDogJ21hbmlmZXN0JyxcbiAgbWFyZ2lud2lkdGg6ICdtYXJnaW5XaWR0aCcsXG4gIG1hcmdpbmhlaWdodDogJ21hcmdpbkhlaWdodCcsXG4gIG1heDogJ21heCcsXG4gIG1heGxlbmd0aDogJ21heExlbmd0aCcsXG4gIG1lZGlhOiAnbWVkaWEnLFxuICBtZWRpYWdyb3VwOiAnbWVkaWFHcm91cCcsXG4gIG1ldGhvZDogJ21ldGhvZCcsXG4gIG1pbjogJ21pbicsXG4gIG1pbmxlbmd0aDogJ21pbkxlbmd0aCcsXG4gIG11bHRpcGxlOiAnbXVsdGlwbGUnLFxuICBtdXRlZDogJ211dGVkJyxcbiAgbmFtZTogJ25hbWUnLFxuICBub21vZHVsZTogJ25vTW9kdWxlJyxcbiAgbm9uY2U6ICdub25jZScsXG4gIG5vdmFsaWRhdGU6ICdub1ZhbGlkYXRlJyxcbiAgb3BlbjogJ29wZW4nLFxuICBvcHRpbXVtOiAnb3B0aW11bScsXG4gIHBhdHRlcm46ICdwYXR0ZXJuJyxcbiAgcGxhY2Vob2xkZXI6ICdwbGFjZWhvbGRlcicsXG4gIHBsYXlzaW5saW5lOiAncGxheXNJbmxpbmUnLFxuICBwb3N0ZXI6ICdwb3N0ZXInLFxuICBwcmVsb2FkOiAncHJlbG9hZCcsXG4gIHByb2ZpbGU6ICdwcm9maWxlJyxcbiAgcmFkaW9ncm91cDogJ3JhZGlvR3JvdXAnLFxuICByZWFkb25seTogJ3JlYWRPbmx5JyxcbiAgcmVmZXJyZXJwb2xpY3k6ICdyZWZlcnJlclBvbGljeScsXG4gIHJlbDogJ3JlbCcsXG4gIHJlcXVpcmVkOiAncmVxdWlyZWQnLFxuICByZXZlcnNlZDogJ3JldmVyc2VkJyxcbiAgcm9sZTogJ3JvbGUnLFxuICByb3dzOiAncm93cycsXG4gIHJvd3NwYW46ICdyb3dTcGFuJyxcbiAgc2FuZGJveDogJ3NhbmRib3gnLFxuICBzY29wZTogJ3Njb3BlJyxcbiAgc2NvcGVkOiAnc2NvcGVkJyxcbiAgc2Nyb2xsaW5nOiAnc2Nyb2xsaW5nJyxcbiAgc2VhbWxlc3M6ICdzZWFtbGVzcycsXG4gIHNlbGVjdGVkOiAnc2VsZWN0ZWQnLFxuICBzaGFwZTogJ3NoYXBlJyxcbiAgc2l6ZTogJ3NpemUnLFxuICBzaXplczogJ3NpemVzJyxcbiAgc3BhbjogJ3NwYW4nLFxuICBzcGVsbGNoZWNrOiAnc3BlbGxDaGVjaycsXG4gIHNyYzogJ3NyYycsXG4gIHNyY2RvYzogJ3NyY0RvYycsXG4gIHNyY2xhbmc6ICdzcmNMYW5nJyxcbiAgc3Jjc2V0OiAnc3JjU2V0JyxcbiAgc3RhcnQ6ICdzdGFydCcsXG4gIHN0ZXA6ICdzdGVwJyxcbiAgc3R5bGU6ICdzdHlsZScsXG4gIHN1bW1hcnk6ICdzdW1tYXJ5JyxcbiAgdGFiaW5kZXg6ICd0YWJJbmRleCcsXG4gIHRhcmdldDogJ3RhcmdldCcsXG4gIHRpdGxlOiAndGl0bGUnLFxuICB0eXBlOiAndHlwZScsXG4gIHVzZW1hcDogJ3VzZU1hcCcsXG4gIHZhbHVlOiAndmFsdWUnLFxuICB3aWR0aDogJ3dpZHRoJyxcbiAgd21vZGU6ICd3bW9kZScsXG4gIHdyYXA6ICd3cmFwJyxcbiAgLy8gU1ZHXG4gIGFib3V0OiAnYWJvdXQnLFxuICBhY2NlbnRoZWlnaHQ6ICdhY2NlbnRIZWlnaHQnLFxuICAnYWNjZW50LWhlaWdodCc6ICdhY2NlbnRIZWlnaHQnLFxuICBhY2N1bXVsYXRlOiAnYWNjdW11bGF0ZScsXG4gIGFkZGl0aXZlOiAnYWRkaXRpdmUnLFxuICBhbGlnbm1lbnRiYXNlbGluZTogJ2FsaWdubWVudEJhc2VsaW5lJyxcbiAgJ2FsaWdubWVudC1iYXNlbGluZSc6ICdhbGlnbm1lbnRCYXNlbGluZScsXG4gIGFsbG93cmVvcmRlcjogJ2FsbG93UmVvcmRlcicsXG4gIGFscGhhYmV0aWM6ICdhbHBoYWJldGljJyxcbiAgYW1wbGl0dWRlOiAnYW1wbGl0dWRlJyxcbiAgYXJhYmljZm9ybTogJ2FyYWJpY0Zvcm0nLFxuICAnYXJhYmljLWZvcm0nOiAnYXJhYmljRm9ybScsXG4gIGFzY2VudDogJ2FzY2VudCcsXG4gIGF0dHJpYnV0ZW5hbWU6ICdhdHRyaWJ1dGVOYW1lJyxcbiAgYXR0cmlidXRldHlwZTogJ2F0dHJpYnV0ZVR5cGUnLFxuICBhdXRvcmV2ZXJzZTogJ2F1dG9SZXZlcnNlJyxcbiAgYXppbXV0aDogJ2F6aW11dGgnLFxuICBiYXNlZnJlcXVlbmN5OiAnYmFzZUZyZXF1ZW5jeScsXG4gIGJhc2VsaW5lc2hpZnQ6ICdiYXNlbGluZVNoaWZ0JyxcbiAgJ2Jhc2VsaW5lLXNoaWZ0JzogJ2Jhc2VsaW5lU2hpZnQnLFxuICBiYXNlcHJvZmlsZTogJ2Jhc2VQcm9maWxlJyxcbiAgYmJveDogJ2Jib3gnLFxuICBiZWdpbjogJ2JlZ2luJyxcbiAgYmlhczogJ2JpYXMnLFxuICBieTogJ2J5JyxcbiAgY2FsY21vZGU6ICdjYWxjTW9kZScsXG4gIGNhcGhlaWdodDogJ2NhcEhlaWdodCcsXG4gICdjYXAtaGVpZ2h0JzogJ2NhcEhlaWdodCcsXG4gIGNsaXA6ICdjbGlwJyxcbiAgY2xpcHBhdGg6ICdjbGlwUGF0aCcsXG4gICdjbGlwLXBhdGgnOiAnY2xpcFBhdGgnLFxuICBjbGlwcGF0aHVuaXRzOiAnY2xpcFBhdGhVbml0cycsXG4gIGNsaXBydWxlOiAnY2xpcFJ1bGUnLFxuICAnY2xpcC1ydWxlJzogJ2NsaXBSdWxlJyxcbiAgY29sb3I6ICdjb2xvcicsXG4gIGNvbG9yaW50ZXJwb2xhdGlvbjogJ2NvbG9ySW50ZXJwb2xhdGlvbicsXG4gICdjb2xvci1pbnRlcnBvbGF0aW9uJzogJ2NvbG9ySW50ZXJwb2xhdGlvbicsXG4gIGNvbG9yaW50ZXJwb2xhdGlvbmZpbHRlcnM6ICdjb2xvckludGVycG9sYXRpb25GaWx0ZXJzJyxcbiAgJ2NvbG9yLWludGVycG9sYXRpb24tZmlsdGVycyc6ICdjb2xvckludGVycG9sYXRpb25GaWx0ZXJzJyxcbiAgY29sb3Jwcm9maWxlOiAnY29sb3JQcm9maWxlJyxcbiAgJ2NvbG9yLXByb2ZpbGUnOiAnY29sb3JQcm9maWxlJyxcbiAgY29sb3JyZW5kZXJpbmc6ICdjb2xvclJlbmRlcmluZycsXG4gICdjb2xvci1yZW5kZXJpbmcnOiAnY29sb3JSZW5kZXJpbmcnLFxuICBjb250ZW50c2NyaXB0dHlwZTogJ2NvbnRlbnRTY3JpcHRUeXBlJyxcbiAgY29udGVudHN0eWxldHlwZTogJ2NvbnRlbnRTdHlsZVR5cGUnLFxuICBjdXJzb3I6ICdjdXJzb3InLFxuICBjeDogJ2N4JyxcbiAgY3k6ICdjeScsXG4gIGQ6ICdkJyxcbiAgZGF0YXR5cGU6ICdkYXRhdHlwZScsXG4gIGRlY2VsZXJhdGU6ICdkZWNlbGVyYXRlJyxcbiAgZGVzY2VudDogJ2Rlc2NlbnQnLFxuICBkaWZmdXNlY29uc3RhbnQ6ICdkaWZmdXNlQ29uc3RhbnQnLFxuICBkaXJlY3Rpb246ICdkaXJlY3Rpb24nLFxuICBkaXNwbGF5OiAnZGlzcGxheScsXG4gIGRpdmlzb3I6ICdkaXZpc29yJyxcbiAgZG9taW5hbnRiYXNlbGluZTogJ2RvbWluYW50QmFzZWxpbmUnLFxuICAnZG9taW5hbnQtYmFzZWxpbmUnOiAnZG9taW5hbnRCYXNlbGluZScsXG4gIGR1cjogJ2R1cicsXG4gIGR4OiAnZHgnLFxuICBkeTogJ2R5JyxcbiAgZWRnZW1vZGU6ICdlZGdlTW9kZScsXG4gIGVsZXZhdGlvbjogJ2VsZXZhdGlvbicsXG4gIGVuYWJsZWJhY2tncm91bmQ6ICdlbmFibGVCYWNrZ3JvdW5kJyxcbiAgJ2VuYWJsZS1iYWNrZ3JvdW5kJzogJ2VuYWJsZUJhY2tncm91bmQnLFxuICBlbmQ6ICdlbmQnLFxuICBleHBvbmVudDogJ2V4cG9uZW50JyxcbiAgZXh0ZXJuYWxyZXNvdXJjZXNyZXF1aXJlZDogJ2V4dGVybmFsUmVzb3VyY2VzUmVxdWlyZWQnLFxuICBmaWxsOiAnZmlsbCcsXG4gIGZpbGxvcGFjaXR5OiAnZmlsbE9wYWNpdHknLFxuICAnZmlsbC1vcGFjaXR5JzogJ2ZpbGxPcGFjaXR5JyxcbiAgZmlsbHJ1bGU6ICdmaWxsUnVsZScsXG4gICdmaWxsLXJ1bGUnOiAnZmlsbFJ1bGUnLFxuICBmaWx0ZXI6ICdmaWx0ZXInLFxuICBmaWx0ZXJyZXM6ICdmaWx0ZXJSZXMnLFxuICBmaWx0ZXJ1bml0czogJ2ZpbHRlclVuaXRzJyxcbiAgZmxvb2RvcGFjaXR5OiAnZmxvb2RPcGFjaXR5JyxcbiAgJ2Zsb29kLW9wYWNpdHknOiAnZmxvb2RPcGFjaXR5JyxcbiAgZmxvb2Rjb2xvcjogJ2Zsb29kQ29sb3InLFxuICAnZmxvb2QtY29sb3InOiAnZmxvb2RDb2xvcicsXG4gIGZvY3VzYWJsZTogJ2ZvY3VzYWJsZScsXG4gIGZvbnRmYW1pbHk6ICdmb250RmFtaWx5JyxcbiAgJ2ZvbnQtZmFtaWx5JzogJ2ZvbnRGYW1pbHknLFxuICBmb250c2l6ZTogJ2ZvbnRTaXplJyxcbiAgJ2ZvbnQtc2l6ZSc6ICdmb250U2l6ZScsXG4gIGZvbnRzaXplYWRqdXN0OiAnZm9udFNpemVBZGp1c3QnLFxuICAnZm9udC1zaXplLWFkanVzdCc6ICdmb250U2l6ZUFkanVzdCcsXG4gIGZvbnRzdHJldGNoOiAnZm9udFN0cmV0Y2gnLFxuICAnZm9udC1zdHJldGNoJzogJ2ZvbnRTdHJldGNoJyxcbiAgZm9udHN0eWxlOiAnZm9udFN0eWxlJyxcbiAgJ2ZvbnQtc3R5bGUnOiAnZm9udFN0eWxlJyxcbiAgZm9udHZhcmlhbnQ6ICdmb250VmFyaWFudCcsXG4gICdmb250LXZhcmlhbnQnOiAnZm9udFZhcmlhbnQnLFxuICBmb250d2VpZ2h0OiAnZm9udFdlaWdodCcsXG4gICdmb250LXdlaWdodCc6ICdmb250V2VpZ2h0JyxcbiAgZm9ybWF0OiAnZm9ybWF0JyxcbiAgZnJvbTogJ2Zyb20nLFxuICBmeDogJ2Z4JyxcbiAgZnk6ICdmeScsXG4gIGcxOiAnZzEnLFxuICBnMjogJ2cyJyxcbiAgZ2x5cGhuYW1lOiAnZ2x5cGhOYW1lJyxcbiAgJ2dseXBoLW5hbWUnOiAnZ2x5cGhOYW1lJyxcbiAgZ2x5cGhvcmllbnRhdGlvbmhvcml6b250YWw6ICdnbHlwaE9yaWVudGF0aW9uSG9yaXpvbnRhbCcsXG4gICdnbHlwaC1vcmllbnRhdGlvbi1ob3Jpem9udGFsJzogJ2dseXBoT3JpZW50YXRpb25Ib3Jpem9udGFsJyxcbiAgZ2x5cGhvcmllbnRhdGlvbnZlcnRpY2FsOiAnZ2x5cGhPcmllbnRhdGlvblZlcnRpY2FsJyxcbiAgJ2dseXBoLW9yaWVudGF0aW9uLXZlcnRpY2FsJzogJ2dseXBoT3JpZW50YXRpb25WZXJ0aWNhbCcsXG4gIGdseXBocmVmOiAnZ2x5cGhSZWYnLFxuICBncmFkaWVudHRyYW5zZm9ybTogJ2dyYWRpZW50VHJhbnNmb3JtJyxcbiAgZ3JhZGllbnR1bml0czogJ2dyYWRpZW50VW5pdHMnLFxuICBoYW5naW5nOiAnaGFuZ2luZycsXG4gIGhvcml6YWR2eDogJ2hvcml6QWR2WCcsXG4gICdob3Jpei1hZHYteCc6ICdob3JpekFkdlgnLFxuICBob3Jpem9yaWdpbng6ICdob3Jpek9yaWdpblgnLFxuICAnaG9yaXotb3JpZ2luLXgnOiAnaG9yaXpPcmlnaW5YJyxcbiAgaWRlb2dyYXBoaWM6ICdpZGVvZ3JhcGhpYycsXG4gIGltYWdlcmVuZGVyaW5nOiAnaW1hZ2VSZW5kZXJpbmcnLFxuICAnaW1hZ2UtcmVuZGVyaW5nJzogJ2ltYWdlUmVuZGVyaW5nJyxcbiAgaW4yOiAnaW4yJyxcbiAgaW46ICdpbicsXG4gIGlubGlzdDogJ2lubGlzdCcsXG4gIGludGVyY2VwdDogJ2ludGVyY2VwdCcsXG4gIGsxOiAnazEnLFxuICBrMjogJ2syJyxcbiAgazM6ICdrMycsXG4gIGs0OiAnazQnLFxuICBrOiAnaycsXG4gIGtlcm5lbG1hdHJpeDogJ2tlcm5lbE1hdHJpeCcsXG4gIGtlcm5lbHVuaXRsZW5ndGg6ICdrZXJuZWxVbml0TGVuZ3RoJyxcbiAga2VybmluZzogJ2tlcm5pbmcnLFxuICBrZXlwb2ludHM6ICdrZXlQb2ludHMnLFxuICBrZXlzcGxpbmVzOiAna2V5U3BsaW5lcycsXG4gIGtleXRpbWVzOiAna2V5VGltZXMnLFxuICBsZW5ndGhhZGp1c3Q6ICdsZW5ndGhBZGp1c3QnLFxuICBsZXR0ZXJzcGFjaW5nOiAnbGV0dGVyU3BhY2luZycsXG4gICdsZXR0ZXItc3BhY2luZyc6ICdsZXR0ZXJTcGFjaW5nJyxcbiAgbGlnaHRpbmdjb2xvcjogJ2xpZ2h0aW5nQ29sb3InLFxuICAnbGlnaHRpbmctY29sb3InOiAnbGlnaHRpbmdDb2xvcicsXG4gIGxpbWl0aW5nY29uZWFuZ2xlOiAnbGltaXRpbmdDb25lQW5nbGUnLFxuICBsb2NhbDogJ2xvY2FsJyxcbiAgbWFya2VyZW5kOiAnbWFya2VyRW5kJyxcbiAgJ21hcmtlci1lbmQnOiAnbWFya2VyRW5kJyxcbiAgbWFya2VyaGVpZ2h0OiAnbWFya2VySGVpZ2h0JyxcbiAgbWFya2VybWlkOiAnbWFya2VyTWlkJyxcbiAgJ21hcmtlci1taWQnOiAnbWFya2VyTWlkJyxcbiAgbWFya2Vyc3RhcnQ6ICdtYXJrZXJTdGFydCcsXG4gICdtYXJrZXItc3RhcnQnOiAnbWFya2VyU3RhcnQnLFxuICBtYXJrZXJ1bml0czogJ21hcmtlclVuaXRzJyxcbiAgbWFya2Vyd2lkdGg6ICdtYXJrZXJXaWR0aCcsXG4gIG1hc2s6ICdtYXNrJyxcbiAgbWFza2NvbnRlbnR1bml0czogJ21hc2tDb250ZW50VW5pdHMnLFxuICBtYXNrdW5pdHM6ICdtYXNrVW5pdHMnLFxuICBtYXRoZW1hdGljYWw6ICdtYXRoZW1hdGljYWwnLFxuICBtb2RlOiAnbW9kZScsXG4gIG51bW9jdGF2ZXM6ICdudW1PY3RhdmVzJyxcbiAgb2Zmc2V0OiAnb2Zmc2V0JyxcbiAgb3BhY2l0eTogJ29wYWNpdHknLFxuICBvcGVyYXRvcjogJ29wZXJhdG9yJyxcbiAgb3JkZXI6ICdvcmRlcicsXG4gIG9yaWVudDogJ29yaWVudCcsXG4gIG9yaWVudGF0aW9uOiAnb3JpZW50YXRpb24nLFxuICBvcmlnaW46ICdvcmlnaW4nLFxuICBvdmVyZmxvdzogJ292ZXJmbG93JyxcbiAgb3ZlcmxpbmVwb3NpdGlvbjogJ292ZXJsaW5lUG9zaXRpb24nLFxuICAnb3ZlcmxpbmUtcG9zaXRpb24nOiAnb3ZlcmxpbmVQb3NpdGlvbicsXG4gIG92ZXJsaW5ldGhpY2tuZXNzOiAnb3ZlcmxpbmVUaGlja25lc3MnLFxuICAnb3ZlcmxpbmUtdGhpY2tuZXNzJzogJ292ZXJsaW5lVGhpY2tuZXNzJyxcbiAgcGFpbnRvcmRlcjogJ3BhaW50T3JkZXInLFxuICAncGFpbnQtb3JkZXInOiAncGFpbnRPcmRlcicsXG4gIHBhbm9zZTE6ICdwYW5vc2UxJyxcbiAgJ3Bhbm9zZS0xJzogJ3Bhbm9zZTEnLFxuICBwYXRobGVuZ3RoOiAncGF0aExlbmd0aCcsXG4gIHBhdHRlcm5jb250ZW50dW5pdHM6ICdwYXR0ZXJuQ29udGVudFVuaXRzJyxcbiAgcGF0dGVybnRyYW5zZm9ybTogJ3BhdHRlcm5UcmFuc2Zvcm0nLFxuICBwYXR0ZXJudW5pdHM6ICdwYXR0ZXJuVW5pdHMnLFxuICBwb2ludGVyZXZlbnRzOiAncG9pbnRlckV2ZW50cycsXG4gICdwb2ludGVyLWV2ZW50cyc6ICdwb2ludGVyRXZlbnRzJyxcbiAgcG9pbnRzOiAncG9pbnRzJyxcbiAgcG9pbnRzYXR4OiAncG9pbnRzQXRYJyxcbiAgcG9pbnRzYXR5OiAncG9pbnRzQXRZJyxcbiAgcG9pbnRzYXR6OiAncG9pbnRzQXRaJyxcbiAgcHJlZml4OiAncHJlZml4JyxcbiAgcHJlc2VydmVhbHBoYTogJ3ByZXNlcnZlQWxwaGEnLFxuICBwcmVzZXJ2ZWFzcGVjdHJhdGlvOiAncHJlc2VydmVBc3BlY3RSYXRpbycsXG4gIHByaW1pdGl2ZXVuaXRzOiAncHJpbWl0aXZlVW5pdHMnLFxuICBwcm9wZXJ0eTogJ3Byb3BlcnR5JyxcbiAgcjogJ3InLFxuICByYWRpdXM6ICdyYWRpdXMnLFxuICByZWZ4OiAncmVmWCcsXG4gIHJlZnk6ICdyZWZZJyxcbiAgcmVuZGVyaW5naW50ZW50OiAncmVuZGVyaW5nSW50ZW50JyxcbiAgJ3JlbmRlcmluZy1pbnRlbnQnOiAncmVuZGVyaW5nSW50ZW50JyxcbiAgcmVwZWF0Y291bnQ6ICdyZXBlYXRDb3VudCcsXG4gIHJlcGVhdGR1cjogJ3JlcGVhdER1cicsXG4gIHJlcXVpcmVkZXh0ZW5zaW9uczogJ3JlcXVpcmVkRXh0ZW5zaW9ucycsXG4gIHJlcXVpcmVkZmVhdHVyZXM6ICdyZXF1aXJlZEZlYXR1cmVzJyxcbiAgcmVzb3VyY2U6ICdyZXNvdXJjZScsXG4gIHJlc3RhcnQ6ICdyZXN0YXJ0JyxcbiAgcmVzdWx0OiAncmVzdWx0JyxcbiAgcmVzdWx0czogJ3Jlc3VsdHMnLFxuICByb3RhdGU6ICdyb3RhdGUnLFxuICByeDogJ3J4JyxcbiAgcnk6ICdyeScsXG4gIHNjYWxlOiAnc2NhbGUnLFxuICBzZWN1cml0eTogJ3NlY3VyaXR5JyxcbiAgc2VlZDogJ3NlZWQnLFxuICBzaGFwZXJlbmRlcmluZzogJ3NoYXBlUmVuZGVyaW5nJyxcbiAgJ3NoYXBlLXJlbmRlcmluZyc6ICdzaGFwZVJlbmRlcmluZycsXG4gIHNsb3BlOiAnc2xvcGUnLFxuICBzcGFjaW5nOiAnc3BhY2luZycsXG4gIHNwZWN1bGFyY29uc3RhbnQ6ICdzcGVjdWxhckNvbnN0YW50JyxcbiAgc3BlY3VsYXJleHBvbmVudDogJ3NwZWN1bGFyRXhwb25lbnQnLFxuICBzcGVlZDogJ3NwZWVkJyxcbiAgc3ByZWFkbWV0aG9kOiAnc3ByZWFkTWV0aG9kJyxcbiAgc3RhcnRvZmZzZXQ6ICdzdGFydE9mZnNldCcsXG4gIHN0ZGRldmlhdGlvbjogJ3N0ZERldmlhdGlvbicsXG4gIHN0ZW1oOiAnc3RlbWgnLFxuICBzdGVtdjogJ3N0ZW12JyxcbiAgc3RpdGNodGlsZXM6ICdzdGl0Y2hUaWxlcycsXG4gIHN0b3Bjb2xvcjogJ3N0b3BDb2xvcicsXG4gICdzdG9wLWNvbG9yJzogJ3N0b3BDb2xvcicsXG4gIHN0b3BvcGFjaXR5OiAnc3RvcE9wYWNpdHknLFxuICAnc3RvcC1vcGFjaXR5JzogJ3N0b3BPcGFjaXR5JyxcbiAgc3RyaWtldGhyb3VnaHBvc2l0aW9uOiAnc3RyaWtldGhyb3VnaFBvc2l0aW9uJyxcbiAgJ3N0cmlrZXRocm91Z2gtcG9zaXRpb24nOiAnc3RyaWtldGhyb3VnaFBvc2l0aW9uJyxcbiAgc3RyaWtldGhyb3VnaHRoaWNrbmVzczogJ3N0cmlrZXRocm91Z2hUaGlja25lc3MnLFxuICAnc3RyaWtldGhyb3VnaC10aGlja25lc3MnOiAnc3RyaWtldGhyb3VnaFRoaWNrbmVzcycsXG4gIHN0cmluZzogJ3N0cmluZycsXG4gIHN0cm9rZTogJ3N0cm9rZScsXG4gIHN0cm9rZWRhc2hhcnJheTogJ3N0cm9rZURhc2hhcnJheScsXG4gICdzdHJva2UtZGFzaGFycmF5JzogJ3N0cm9rZURhc2hhcnJheScsXG4gIHN0cm9rZWRhc2hvZmZzZXQ6ICdzdHJva2VEYXNob2Zmc2V0JyxcbiAgJ3N0cm9rZS1kYXNob2Zmc2V0JzogJ3N0cm9rZURhc2hvZmZzZXQnLFxuICBzdHJva2VsaW5lY2FwOiAnc3Ryb2tlTGluZWNhcCcsXG4gICdzdHJva2UtbGluZWNhcCc6ICdzdHJva2VMaW5lY2FwJyxcbiAgc3Ryb2tlbGluZWpvaW46ICdzdHJva2VMaW5lam9pbicsXG4gICdzdHJva2UtbGluZWpvaW4nOiAnc3Ryb2tlTGluZWpvaW4nLFxuICBzdHJva2VtaXRlcmxpbWl0OiAnc3Ryb2tlTWl0ZXJsaW1pdCcsXG4gICdzdHJva2UtbWl0ZXJsaW1pdCc6ICdzdHJva2VNaXRlcmxpbWl0JyxcbiAgc3Ryb2tld2lkdGg6ICdzdHJva2VXaWR0aCcsXG4gICdzdHJva2Utd2lkdGgnOiAnc3Ryb2tlV2lkdGgnLFxuICBzdHJva2VvcGFjaXR5OiAnc3Ryb2tlT3BhY2l0eScsXG4gICdzdHJva2Utb3BhY2l0eSc6ICdzdHJva2VPcGFjaXR5JyxcbiAgc3VwcHJlc3Njb250ZW50ZWRpdGFibGV3YXJuaW5nOiAnc3VwcHJlc3NDb250ZW50RWRpdGFibGVXYXJuaW5nJyxcbiAgc3VwcHJlc3NoeWRyYXRpb253YXJuaW5nOiAnc3VwcHJlc3NIeWRyYXRpb25XYXJuaW5nJyxcbiAgc3VyZmFjZXNjYWxlOiAnc3VyZmFjZVNjYWxlJyxcbiAgc3lzdGVtbGFuZ3VhZ2U6ICdzeXN0ZW1MYW5ndWFnZScsXG4gIHRhYmxldmFsdWVzOiAndGFibGVWYWx1ZXMnLFxuICB0YXJnZXR4OiAndGFyZ2V0WCcsXG4gIHRhcmdldHk6ICd0YXJnZXRZJyxcbiAgdGV4dGFuY2hvcjogJ3RleHRBbmNob3InLFxuICAndGV4dC1hbmNob3InOiAndGV4dEFuY2hvcicsXG4gIHRleHRkZWNvcmF0aW9uOiAndGV4dERlY29yYXRpb24nLFxuICAndGV4dC1kZWNvcmF0aW9uJzogJ3RleHREZWNvcmF0aW9uJyxcbiAgdGV4dGxlbmd0aDogJ3RleHRMZW5ndGgnLFxuICB0ZXh0cmVuZGVyaW5nOiAndGV4dFJlbmRlcmluZycsXG4gICd0ZXh0LXJlbmRlcmluZyc6ICd0ZXh0UmVuZGVyaW5nJyxcbiAgdG86ICd0bycsXG4gIHRyYW5zZm9ybTogJ3RyYW5zZm9ybScsXG4gIHR5cGVvZjogJ3R5cGVvZicsXG4gIHUxOiAndTEnLFxuICB1MjogJ3UyJyxcbiAgdW5kZXJsaW5lcG9zaXRpb246ICd1bmRlcmxpbmVQb3NpdGlvbicsXG4gICd1bmRlcmxpbmUtcG9zaXRpb24nOiAndW5kZXJsaW5lUG9zaXRpb24nLFxuICB1bmRlcmxpbmV0aGlja25lc3M6ICd1bmRlcmxpbmVUaGlja25lc3MnLFxuICAndW5kZXJsaW5lLXRoaWNrbmVzcyc6ICd1bmRlcmxpbmVUaGlja25lc3MnLFxuICB1bmljb2RlOiAndW5pY29kZScsXG4gIHVuaWNvZGViaWRpOiAndW5pY29kZUJpZGknLFxuICAndW5pY29kZS1iaWRpJzogJ3VuaWNvZGVCaWRpJyxcbiAgdW5pY29kZXJhbmdlOiAndW5pY29kZVJhbmdlJyxcbiAgJ3VuaWNvZGUtcmFuZ2UnOiAndW5pY29kZVJhbmdlJyxcbiAgdW5pdHNwZXJlbTogJ3VuaXRzUGVyRW0nLFxuICAndW5pdHMtcGVyLWVtJzogJ3VuaXRzUGVyRW0nLFxuICB1bnNlbGVjdGFibGU6ICd1bnNlbGVjdGFibGUnLFxuICB2YWxwaGFiZXRpYzogJ3ZBbHBoYWJldGljJyxcbiAgJ3YtYWxwaGFiZXRpYyc6ICd2QWxwaGFiZXRpYycsXG4gIHZhbHVlczogJ3ZhbHVlcycsXG4gIHZlY3RvcmVmZmVjdDogJ3ZlY3RvckVmZmVjdCcsXG4gICd2ZWN0b3ItZWZmZWN0JzogJ3ZlY3RvckVmZmVjdCcsXG4gIHZlcnNpb246ICd2ZXJzaW9uJyxcbiAgdmVydGFkdnk6ICd2ZXJ0QWR2WScsXG4gICd2ZXJ0LWFkdi15JzogJ3ZlcnRBZHZZJyxcbiAgdmVydG9yaWdpbng6ICd2ZXJ0T3JpZ2luWCcsXG4gICd2ZXJ0LW9yaWdpbi14JzogJ3ZlcnRPcmlnaW5YJyxcbiAgdmVydG9yaWdpbnk6ICd2ZXJ0T3JpZ2luWScsXG4gICd2ZXJ0LW9yaWdpbi15JzogJ3ZlcnRPcmlnaW5ZJyxcbiAgdmhhbmdpbmc6ICd2SGFuZ2luZycsXG4gICd2LWhhbmdpbmcnOiAndkhhbmdpbmcnLFxuICB2aWRlb2dyYXBoaWM6ICd2SWRlb2dyYXBoaWMnLFxuICAndi1pZGVvZ3JhcGhpYyc6ICd2SWRlb2dyYXBoaWMnLFxuICB2aWV3Ym94OiAndmlld0JveCcsXG4gIHZpZXd0YXJnZXQ6ICd2aWV3VGFyZ2V0JyxcbiAgdmlzaWJpbGl0eTogJ3Zpc2liaWxpdHknLFxuICB2bWF0aGVtYXRpY2FsOiAndk1hdGhlbWF0aWNhbCcsXG4gICd2LW1hdGhlbWF0aWNhbCc6ICd2TWF0aGVtYXRpY2FsJyxcbiAgdm9jYWI6ICd2b2NhYicsXG4gIHdpZHRoczogJ3dpZHRocycsXG4gIHdvcmRzcGFjaW5nOiAnd29yZFNwYWNpbmcnLFxuICAnd29yZC1zcGFjaW5nJzogJ3dvcmRTcGFjaW5nJyxcbiAgd3JpdGluZ21vZGU6ICd3cml0aW5nTW9kZScsXG4gICd3cml0aW5nLW1vZGUnOiAnd3JpdGluZ01vZGUnLFxuICB4MTogJ3gxJyxcbiAgeDI6ICd4MicsXG4gIHg6ICd4JyxcbiAgeGNoYW5uZWxzZWxlY3RvcjogJ3hDaGFubmVsU2VsZWN0b3InLFxuICB4aGVpZ2h0OiAneEhlaWdodCcsXG4gICd4LWhlaWdodCc6ICd4SGVpZ2h0JyxcbiAgeGxpbmthY3R1YXRlOiAneGxpbmtBY3R1YXRlJyxcbiAgJ3hsaW5rOmFjdHVhdGUnOiAneGxpbmtBY3R1YXRlJyxcbiAgeGxpbmthcmNyb2xlOiAneGxpbmtBcmNyb2xlJyxcbiAgJ3hsaW5rOmFyY3JvbGUnOiAneGxpbmtBcmNyb2xlJyxcbiAgeGxpbmtocmVmOiAneGxpbmtIcmVmJyxcbiAgJ3hsaW5rOmhyZWYnOiAneGxpbmtIcmVmJyxcbiAgeGxpbmtyb2xlOiAneGxpbmtSb2xlJyxcbiAgJ3hsaW5rOnJvbGUnOiAneGxpbmtSb2xlJyxcbiAgeGxpbmtzaG93OiAneGxpbmtTaG93JyxcbiAgJ3hsaW5rOnNob3cnOiAneGxpbmtTaG93JyxcbiAgeGxpbmt0aXRsZTogJ3hsaW5rVGl0bGUnLFxuICAneGxpbms6dGl0bGUnOiAneGxpbmtUaXRsZScsXG4gIHhsaW5rdHlwZTogJ3hsaW5rVHlwZScsXG4gICd4bGluazp0eXBlJzogJ3hsaW5rVHlwZScsXG4gIHhtbGJhc2U6ICd4bWxCYXNlJyxcbiAgJ3htbDpiYXNlJzogJ3htbEJhc2UnLFxuICB4bWxsYW5nOiAneG1sTGFuZycsXG4gICd4bWw6bGFuZyc6ICd4bWxMYW5nJyxcbiAgeG1sbnM6ICd4bWxucycsXG4gICd4bWw6c3BhY2UnOiAneG1sU3BhY2UnLFxuICB4bWxuc3hsaW5rOiAneG1sbnNYbGluaycsXG4gICd4bWxuczp4bGluayc6ICd4bWxuc1hsaW5rJyxcbiAgeG1sc3BhY2U6ICd4bWxTcGFjZScsXG4gIHkxOiAneTEnLFxuICB5MjogJ3kyJyxcbiAgeTogJ3knLFxuICB5Y2hhbm5lbHNlbGVjdG9yOiAneUNoYW5uZWxTZWxlY3RvcicsXG4gIHo6ICd6JyxcbiAgem9vbWFuZHBhbjogJ3pvb21BbmRQYW4nXG59O1xuXG52YXIgYXJpYVByb3BlcnRpZXMgPSB7XG4gICdhcmlhLWN1cnJlbnQnOiAwLFxuICAvLyBzdGF0ZVxuICAnYXJpYS1kZXRhaWxzJzogMCxcbiAgJ2FyaWEtZGlzYWJsZWQnOiAwLFxuICAvLyBzdGF0ZVxuICAnYXJpYS1oaWRkZW4nOiAwLFxuICAvLyBzdGF0ZVxuICAnYXJpYS1pbnZhbGlkJzogMCxcbiAgLy8gc3RhdGVcbiAgJ2FyaWEta2V5c2hvcnRjdXRzJzogMCxcbiAgJ2FyaWEtbGFiZWwnOiAwLFxuICAnYXJpYS1yb2xlZGVzY3JpcHRpb24nOiAwLFxuICAvLyBXaWRnZXQgQXR0cmlidXRlc1xuICAnYXJpYS1hdXRvY29tcGxldGUnOiAwLFxuICAnYXJpYS1jaGVja2VkJzogMCxcbiAgJ2FyaWEtZXhwYW5kZWQnOiAwLFxuICAnYXJpYS1oYXNwb3B1cCc6IDAsXG4gICdhcmlhLWxldmVsJzogMCxcbiAgJ2FyaWEtbW9kYWwnOiAwLFxuICAnYXJpYS1tdWx0aWxpbmUnOiAwLFxuICAnYXJpYS1tdWx0aXNlbGVjdGFibGUnOiAwLFxuICAnYXJpYS1vcmllbnRhdGlvbic6IDAsXG4gICdhcmlhLXBsYWNlaG9sZGVyJzogMCxcbiAgJ2FyaWEtcHJlc3NlZCc6IDAsXG4gICdhcmlhLXJlYWRvbmx5JzogMCxcbiAgJ2FyaWEtcmVxdWlyZWQnOiAwLFxuICAnYXJpYS1zZWxlY3RlZCc6IDAsXG4gICdhcmlhLXNvcnQnOiAwLFxuICAnYXJpYS12YWx1ZW1heCc6IDAsXG4gICdhcmlhLXZhbHVlbWluJzogMCxcbiAgJ2FyaWEtdmFsdWVub3cnOiAwLFxuICAnYXJpYS12YWx1ZXRleHQnOiAwLFxuICAvLyBMaXZlIFJlZ2lvbiBBdHRyaWJ1dGVzXG4gICdhcmlhLWF0b21pYyc6IDAsXG4gICdhcmlhLWJ1c3knOiAwLFxuICAnYXJpYS1saXZlJzogMCxcbiAgJ2FyaWEtcmVsZXZhbnQnOiAwLFxuICAvLyBEcmFnLWFuZC1Ecm9wIEF0dHJpYnV0ZXNcbiAgJ2FyaWEtZHJvcGVmZmVjdCc6IDAsXG4gICdhcmlhLWdyYWJiZWQnOiAwLFxuICAvLyBSZWxhdGlvbnNoaXAgQXR0cmlidXRlc1xuICAnYXJpYS1hY3RpdmVkZXNjZW5kYW50JzogMCxcbiAgJ2FyaWEtY29sY291bnQnOiAwLFxuICAnYXJpYS1jb2xpbmRleCc6IDAsXG4gICdhcmlhLWNvbHNwYW4nOiAwLFxuICAnYXJpYS1jb250cm9scyc6IDAsXG4gICdhcmlhLWRlc2NyaWJlZGJ5JzogMCxcbiAgJ2FyaWEtZXJyb3JtZXNzYWdlJzogMCxcbiAgJ2FyaWEtZmxvd3RvJzogMCxcbiAgJ2FyaWEtbGFiZWxsZWRieSc6IDAsXG4gICdhcmlhLW93bnMnOiAwLFxuICAnYXJpYS1wb3NpbnNldCc6IDAsXG4gICdhcmlhLXJvd2NvdW50JzogMCxcbiAgJ2FyaWEtcm93aW5kZXgnOiAwLFxuICAnYXJpYS1yb3dzcGFuJzogMCxcbiAgJ2FyaWEtc2V0c2l6ZSc6IDBcbn07XG5cbnZhciB3YXJuZWRQcm9wZXJ0aWVzID0ge307XG52YXIgckFSSUEgPSBuZXcgUmVnRXhwKCdeKGFyaWEpLVsnICsgQVRUUklCVVRFX05BTUVfQ0hBUiArICddKiQnKTtcbnZhciByQVJJQUNhbWVsID0gbmV3IFJlZ0V4cCgnXihhcmlhKVtBLVpdWycgKyBBVFRSSUJVVEVfTkFNRV9DSEFSICsgJ10qJCcpO1xudmFyIGhhc093blByb3BlcnR5JDEgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG5mdW5jdGlvbiB2YWxpZGF0ZVByb3BlcnR5KHRhZ05hbWUsIG5hbWUpIHtcbiAge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eSQxLmNhbGwod2FybmVkUHJvcGVydGllcywgbmFtZSkgJiYgd2FybmVkUHJvcGVydGllc1tuYW1lXSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgaWYgKHJBUklBQ2FtZWwudGVzdChuYW1lKSkge1xuICAgICAgdmFyIGFyaWFOYW1lID0gJ2FyaWEtJyArIG5hbWUuc2xpY2UoNCkudG9Mb3dlckNhc2UoKTtcbiAgICAgIHZhciBjb3JyZWN0TmFtZSA9IGFyaWFQcm9wZXJ0aWVzLmhhc093blByb3BlcnR5KGFyaWFOYW1lKSA/IGFyaWFOYW1lIDogbnVsbDsgLy8gSWYgdGhpcyBpcyBhbiBhcmlhLSogYXR0cmlidXRlLCBidXQgaXMgbm90IGxpc3RlZCBpbiB0aGUga25vd24gRE9NXG4gICAgICAvLyBET00gcHJvcGVydGllcywgdGhlbiBpdCBpcyBhbiBpbnZhbGlkIGFyaWEtKiBhdHRyaWJ1dGUuXG5cbiAgICAgIGlmIChjb3JyZWN0TmFtZSA9PSBudWxsKSB7XG4gICAgICAgIGVycm9yKCdJbnZhbGlkIEFSSUEgYXR0cmlidXRlIGAlc2AuIEFSSUEgYXR0cmlidXRlcyBmb2xsb3cgdGhlIHBhdHRlcm4gYXJpYS0qIGFuZCBtdXN0IGJlIGxvd2VyY2FzZS4nLCBuYW1lKTtcblxuICAgICAgICB3YXJuZWRQcm9wZXJ0aWVzW25hbWVdID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9IC8vIGFyaWEtKiBhdHRyaWJ1dGVzIHNob3VsZCBiZSBsb3dlcmNhc2U7IHN1Z2dlc3QgdGhlIGxvd2VyY2FzZSB2ZXJzaW9uLlxuXG5cbiAgICAgIGlmIChuYW1lICE9PSBjb3JyZWN0TmFtZSkge1xuICAgICAgICBlcnJvcignSW52YWxpZCBBUklBIGF0dHJpYnV0ZSBgJXNgLiBEaWQgeW91IG1lYW4gYCVzYD8nLCBuYW1lLCBjb3JyZWN0TmFtZSk7XG5cbiAgICAgICAgd2FybmVkUHJvcGVydGllc1tuYW1lXSA9IHRydWU7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChyQVJJQS50ZXN0KG5hbWUpKSB7XG4gICAgICB2YXIgbG93ZXJDYXNlZE5hbWUgPSBuYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICB2YXIgc3RhbmRhcmROYW1lID0gYXJpYVByb3BlcnRpZXMuaGFzT3duUHJvcGVydHkobG93ZXJDYXNlZE5hbWUpID8gbG93ZXJDYXNlZE5hbWUgOiBudWxsOyAvLyBJZiB0aGlzIGlzIGFuIGFyaWEtKiBhdHRyaWJ1dGUsIGJ1dCBpcyBub3QgbGlzdGVkIGluIHRoZSBrbm93biBET01cbiAgICAgIC8vIERPTSBwcm9wZXJ0aWVzLCB0aGVuIGl0IGlzIGFuIGludmFsaWQgYXJpYS0qIGF0dHJpYnV0ZS5cblxuICAgICAgaWYgKHN0YW5kYXJkTmFtZSA9PSBudWxsKSB7XG4gICAgICAgIHdhcm5lZFByb3BlcnRpZXNbbmFtZV0gPSB0cnVlO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9IC8vIGFyaWEtKiBhdHRyaWJ1dGVzIHNob3VsZCBiZSBsb3dlcmNhc2U7IHN1Z2dlc3QgdGhlIGxvd2VyY2FzZSB2ZXJzaW9uLlxuXG5cbiAgICAgIGlmIChuYW1lICE9PSBzdGFuZGFyZE5hbWUpIHtcbiAgICAgICAgZXJyb3IoJ1Vua25vd24gQVJJQSBhdHRyaWJ1dGUgYCVzYC4gRGlkIHlvdSBtZWFuIGAlc2A/JywgbmFtZSwgc3RhbmRhcmROYW1lKTtcblxuICAgICAgICB3YXJuZWRQcm9wZXJ0aWVzW25hbWVdID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIHdhcm5JbnZhbGlkQVJJQVByb3BzKHR5cGUsIHByb3BzKSB7XG4gIHtcbiAgICB2YXIgaW52YWxpZFByb3BzID0gW107XG5cbiAgICBmb3IgKHZhciBrZXkgaW4gcHJvcHMpIHtcbiAgICAgIHZhciBpc1ZhbGlkID0gdmFsaWRhdGVQcm9wZXJ0eSh0eXBlLCBrZXkpO1xuXG4gICAgICBpZiAoIWlzVmFsaWQpIHtcbiAgICAgICAgaW52YWxpZFByb3BzLnB1c2goa2V5KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgdW5rbm93blByb3BTdHJpbmcgPSBpbnZhbGlkUHJvcHMubWFwKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgICByZXR1cm4gJ2AnICsgcHJvcCArICdgJztcbiAgICB9KS5qb2luKCcsICcpO1xuXG4gICAgaWYgKGludmFsaWRQcm9wcy5sZW5ndGggPT09IDEpIHtcbiAgICAgIGVycm9yKCdJbnZhbGlkIGFyaWEgcHJvcCAlcyBvbiA8JXM+IHRhZy4gJyArICdGb3IgZGV0YWlscywgc2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9pbnZhbGlkLWFyaWEtcHJvcHMnLCB1bmtub3duUHJvcFN0cmluZywgdHlwZSk7XG4gICAgfSBlbHNlIGlmIChpbnZhbGlkUHJvcHMubGVuZ3RoID4gMSkge1xuICAgICAgZXJyb3IoJ0ludmFsaWQgYXJpYSBwcm9wcyAlcyBvbiA8JXM+IHRhZy4gJyArICdGb3IgZGV0YWlscywgc2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9pbnZhbGlkLWFyaWEtcHJvcHMnLCB1bmtub3duUHJvcFN0cmluZywgdHlwZSk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlUHJvcGVydGllcyh0eXBlLCBwcm9wcykge1xuICBpZiAoaXNDdXN0b21Db21wb25lbnQodHlwZSwgcHJvcHMpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgd2FybkludmFsaWRBUklBUHJvcHModHlwZSwgcHJvcHMpO1xufVxuXG52YXIgZGlkV2FyblZhbHVlTnVsbCA9IGZhbHNlO1xuZnVuY3Rpb24gdmFsaWRhdGVQcm9wZXJ0aWVzJDEodHlwZSwgcHJvcHMpIHtcbiAge1xuICAgIGlmICh0eXBlICE9PSAnaW5wdXQnICYmIHR5cGUgIT09ICd0ZXh0YXJlYScgJiYgdHlwZSAhPT0gJ3NlbGVjdCcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAocHJvcHMgIT0gbnVsbCAmJiBwcm9wcy52YWx1ZSA9PT0gbnVsbCAmJiAhZGlkV2FyblZhbHVlTnVsbCkge1xuICAgICAgZGlkV2FyblZhbHVlTnVsbCA9IHRydWU7XG5cbiAgICAgIGlmICh0eXBlID09PSAnc2VsZWN0JyAmJiBwcm9wcy5tdWx0aXBsZSkge1xuICAgICAgICBlcnJvcignYHZhbHVlYCBwcm9wIG9uIGAlc2Agc2hvdWxkIG5vdCBiZSBudWxsLiAnICsgJ0NvbnNpZGVyIHVzaW5nIGFuIGVtcHR5IGFycmF5IHdoZW4gYG11bHRpcGxlYCBpcyBzZXQgdG8gYHRydWVgICcgKyAndG8gY2xlYXIgdGhlIGNvbXBvbmVudCBvciBgdW5kZWZpbmVkYCBmb3IgdW5jb250cm9sbGVkIGNvbXBvbmVudHMuJywgdHlwZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlcnJvcignYHZhbHVlYCBwcm9wIG9uIGAlc2Agc2hvdWxkIG5vdCBiZSBudWxsLiAnICsgJ0NvbnNpZGVyIHVzaW5nIGFuIGVtcHR5IHN0cmluZyB0byBjbGVhciB0aGUgY29tcG9uZW50IG9yIGB1bmRlZmluZWRgICcgKyAnZm9yIHVuY29udHJvbGxlZCBjb21wb25lbnRzLicsIHR5cGUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG52YXIgdmFsaWRhdGVQcm9wZXJ0eSQxID0gZnVuY3Rpb24gKCkge307XG5cbntcbiAgdmFyIHdhcm5lZFByb3BlcnRpZXMkMSA9IHt9O1xuICB2YXIgX2hhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbiAgdmFyIEVWRU5UX05BTUVfUkVHRVggPSAvXm9uLi87XG4gIHZhciBJTlZBTElEX0VWRU5UX05BTUVfUkVHRVggPSAvXm9uW15BLVpdLztcbiAgdmFyIHJBUklBJDEgPSBuZXcgUmVnRXhwKCdeKGFyaWEpLVsnICsgQVRUUklCVVRFX05BTUVfQ0hBUiArICddKiQnKTtcbiAgdmFyIHJBUklBQ2FtZWwkMSA9IG5ldyBSZWdFeHAoJ14oYXJpYSlbQS1aXVsnICsgQVRUUklCVVRFX05BTUVfQ0hBUiArICddKiQnKTtcblxuICB2YWxpZGF0ZVByb3BlcnR5JDEgPSBmdW5jdGlvbiAodGFnTmFtZSwgbmFtZSwgdmFsdWUsIGV2ZW50UmVnaXN0cnkpIHtcbiAgICBpZiAoX2hhc093blByb3BlcnR5LmNhbGwod2FybmVkUHJvcGVydGllcyQxLCBuYW1lKSAmJiB3YXJuZWRQcm9wZXJ0aWVzJDFbbmFtZV0pIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHZhciBsb3dlckNhc2VkTmFtZSA9IG5hbWUudG9Mb3dlckNhc2UoKTtcblxuICAgIGlmIChsb3dlckNhc2VkTmFtZSA9PT0gJ29uZm9jdXNpbicgfHwgbG93ZXJDYXNlZE5hbWUgPT09ICdvbmZvY3Vzb3V0Jykge1xuICAgICAgZXJyb3IoJ1JlYWN0IHVzZXMgb25Gb2N1cyBhbmQgb25CbHVyIGluc3RlYWQgb2Ygb25Gb2N1c0luIGFuZCBvbkZvY3VzT3V0LiAnICsgJ0FsbCBSZWFjdCBldmVudHMgYXJlIG5vcm1hbGl6ZWQgdG8gYnViYmxlLCBzbyBvbkZvY3VzSW4gYW5kIG9uRm9jdXNPdXQgJyArICdhcmUgbm90IG5lZWRlZC9zdXBwb3J0ZWQgYnkgUmVhY3QuJyk7XG5cbiAgICAgIHdhcm5lZFByb3BlcnRpZXMkMVtuYW1lXSA9IHRydWU7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IC8vIFdlIGNhbid0IHJlbHkgb24gdGhlIGV2ZW50IHN5c3RlbSBiZWluZyBpbmplY3RlZCBvbiB0aGUgc2VydmVyLlxuXG5cbiAgICBpZiAoZXZlbnRSZWdpc3RyeSAhPSBudWxsKSB7XG4gICAgICB2YXIgcmVnaXN0cmF0aW9uTmFtZURlcGVuZGVuY2llcyA9IGV2ZW50UmVnaXN0cnkucmVnaXN0cmF0aW9uTmFtZURlcGVuZGVuY2llcyxcbiAgICAgICAgICBwb3NzaWJsZVJlZ2lzdHJhdGlvbk5hbWVzID0gZXZlbnRSZWdpc3RyeS5wb3NzaWJsZVJlZ2lzdHJhdGlvbk5hbWVzO1xuXG4gICAgICBpZiAocmVnaXN0cmF0aW9uTmFtZURlcGVuZGVuY2llcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgdmFyIHJlZ2lzdHJhdGlvbk5hbWUgPSBwb3NzaWJsZVJlZ2lzdHJhdGlvbk5hbWVzLmhhc093blByb3BlcnR5KGxvd2VyQ2FzZWROYW1lKSA/IHBvc3NpYmxlUmVnaXN0cmF0aW9uTmFtZXNbbG93ZXJDYXNlZE5hbWVdIDogbnVsbDtcblxuICAgICAgaWYgKHJlZ2lzdHJhdGlvbk5hbWUgIT0gbnVsbCkge1xuICAgICAgICBlcnJvcignSW52YWxpZCBldmVudCBoYW5kbGVyIHByb3BlcnR5IGAlc2AuIERpZCB5b3UgbWVhbiBgJXNgPycsIG5hbWUsIHJlZ2lzdHJhdGlvbk5hbWUpO1xuXG4gICAgICAgIHdhcm5lZFByb3BlcnRpZXMkMVtuYW1lXSA9IHRydWU7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoRVZFTlRfTkFNRV9SRUdFWC50ZXN0KG5hbWUpKSB7XG4gICAgICAgIGVycm9yKCdVbmtub3duIGV2ZW50IGhhbmRsZXIgcHJvcGVydHkgYCVzYC4gSXQgd2lsbCBiZSBpZ25vcmVkLicsIG5hbWUpO1xuXG4gICAgICAgIHdhcm5lZFByb3BlcnRpZXMkMVtuYW1lXSA9IHRydWU7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoRVZFTlRfTkFNRV9SRUdFWC50ZXN0KG5hbWUpKSB7XG4gICAgICAvLyBJZiBubyBldmVudCBwbHVnaW5zIGhhdmUgYmVlbiBpbmplY3RlZCwgd2UgYXJlIGluIGEgc2VydmVyIGVudmlyb25tZW50LlxuICAgICAgLy8gU28gd2UgY2FuJ3QgdGVsbCBpZiB0aGUgZXZlbnQgbmFtZSBpcyBjb3JyZWN0IGZvciBzdXJlLCBidXQgd2UgY2FuIGZpbHRlclxuICAgICAgLy8gb3V0IGtub3duIGJhZCBvbmVzIGxpa2UgYG9uY2xpY2tgLiBXZSBjYW4ndCBzdWdnZXN0IGEgc3BlY2lmaWMgcmVwbGFjZW1lbnQgdGhvdWdoLlxuICAgICAgaWYgKElOVkFMSURfRVZFTlRfTkFNRV9SRUdFWC50ZXN0KG5hbWUpKSB7XG4gICAgICAgIGVycm9yKCdJbnZhbGlkIGV2ZW50IGhhbmRsZXIgcHJvcGVydHkgYCVzYC4gJyArICdSZWFjdCBldmVudHMgdXNlIHRoZSBjYW1lbENhc2UgbmFtaW5nIGNvbnZlbnRpb24sIGZvciBleGFtcGxlIGBvbkNsaWNrYC4nLCBuYW1lKTtcbiAgICAgIH1cblxuICAgICAgd2FybmVkUHJvcGVydGllcyQxW25hbWVdID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gLy8gTGV0IHRoZSBBUklBIGF0dHJpYnV0ZSBob29rIHZhbGlkYXRlIEFSSUEgYXR0cmlidXRlc1xuXG5cbiAgICBpZiAockFSSUEkMS50ZXN0KG5hbWUpIHx8IHJBUklBQ2FtZWwkMS50ZXN0KG5hbWUpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAobG93ZXJDYXNlZE5hbWUgPT09ICdpbm5lcmh0bWwnKSB7XG4gICAgICBlcnJvcignRGlyZWN0bHkgc2V0dGluZyBwcm9wZXJ0eSBgaW5uZXJIVE1MYCBpcyBub3QgcGVybWl0dGVkLiAnICsgJ0ZvciBtb3JlIGluZm9ybWF0aW9uLCBsb29rdXAgZG9jdW1lbnRhdGlvbiBvbiBgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxgLicpO1xuXG4gICAgICB3YXJuZWRQcm9wZXJ0aWVzJDFbbmFtZV0gPSB0cnVlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgaWYgKGxvd2VyQ2FzZWROYW1lID09PSAnYXJpYScpIHtcbiAgICAgIGVycm9yKCdUaGUgYGFyaWFgIGF0dHJpYnV0ZSBpcyByZXNlcnZlZCBmb3IgZnV0dXJlIHVzZSBpbiBSZWFjdC4gJyArICdQYXNzIGluZGl2aWR1YWwgYGFyaWEtYCBhdHRyaWJ1dGVzIGluc3RlYWQuJyk7XG5cbiAgICAgIHdhcm5lZFByb3BlcnRpZXMkMVtuYW1lXSA9IHRydWU7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAobG93ZXJDYXNlZE5hbWUgPT09ICdpcycgJiYgdmFsdWUgIT09IG51bGwgJiYgdmFsdWUgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICBlcnJvcignUmVjZWl2ZWQgYSBgJXNgIGZvciBhIHN0cmluZyBhdHRyaWJ1dGUgYGlzYC4gSWYgdGhpcyBpcyBleHBlY3RlZCwgY2FzdCAnICsgJ3RoZSB2YWx1ZSB0byBhIHN0cmluZy4nLCB0eXBlb2YgdmFsdWUpO1xuXG4gICAgICB3YXJuZWRQcm9wZXJ0aWVzJDFbbmFtZV0gPSB0cnVlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgJiYgaXNOYU4odmFsdWUpKSB7XG4gICAgICBlcnJvcignUmVjZWl2ZWQgTmFOIGZvciB0aGUgYCVzYCBhdHRyaWJ1dGUuIElmIHRoaXMgaXMgZXhwZWN0ZWQsIGNhc3QgJyArICd0aGUgdmFsdWUgdG8gYSBzdHJpbmcuJywgbmFtZSk7XG5cbiAgICAgIHdhcm5lZFByb3BlcnRpZXMkMVtuYW1lXSA9IHRydWU7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICB2YXIgcHJvcGVydHlJbmZvID0gZ2V0UHJvcGVydHlJbmZvKG5hbWUpO1xuICAgIHZhciBpc1Jlc2VydmVkID0gcHJvcGVydHlJbmZvICE9PSBudWxsICYmIHByb3BlcnR5SW5mby50eXBlID09PSBSRVNFUlZFRDsgLy8gS25vd24gYXR0cmlidXRlcyBzaG91bGQgbWF0Y2ggdGhlIGNhc2luZyBzcGVjaWZpZWQgaW4gdGhlIHByb3BlcnR5IGNvbmZpZy5cblxuICAgIGlmIChwb3NzaWJsZVN0YW5kYXJkTmFtZXMuaGFzT3duUHJvcGVydHkobG93ZXJDYXNlZE5hbWUpKSB7XG4gICAgICB2YXIgc3RhbmRhcmROYW1lID0gcG9zc2libGVTdGFuZGFyZE5hbWVzW2xvd2VyQ2FzZWROYW1lXTtcblxuICAgICAgaWYgKHN0YW5kYXJkTmFtZSAhPT0gbmFtZSkge1xuICAgICAgICBlcnJvcignSW52YWxpZCBET00gcHJvcGVydHkgYCVzYC4gRGlkIHlvdSBtZWFuIGAlc2A/JywgbmFtZSwgc3RhbmRhcmROYW1lKTtcblxuICAgICAgICB3YXJuZWRQcm9wZXJ0aWVzJDFbbmFtZV0gPSB0cnVlO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCFpc1Jlc2VydmVkICYmIG5hbWUgIT09IGxvd2VyQ2FzZWROYW1lKSB7XG4gICAgICAvLyBVbmtub3duIGF0dHJpYnV0ZXMgc2hvdWxkIGhhdmUgbG93ZXJjYXNlIGNhc2luZyBzaW5jZSB0aGF0J3MgaG93IHRoZXlcbiAgICAgIC8vIHdpbGwgYmUgY2FzZWQgYW55d2F5IHdpdGggc2VydmVyIHJlbmRlcmluZy5cbiAgICAgIGVycm9yKCdSZWFjdCBkb2VzIG5vdCByZWNvZ25pemUgdGhlIGAlc2AgcHJvcCBvbiBhIERPTSBlbGVtZW50LiBJZiB5b3UgJyArICdpbnRlbnRpb25hbGx5IHdhbnQgaXQgdG8gYXBwZWFyIGluIHRoZSBET00gYXMgYSBjdXN0b20gJyArICdhdHRyaWJ1dGUsIHNwZWxsIGl0IGFzIGxvd2VyY2FzZSBgJXNgIGluc3RlYWQuICcgKyAnSWYgeW91IGFjY2lkZW50YWxseSBwYXNzZWQgaXQgZnJvbSBhIHBhcmVudCBjb21wb25lbnQsIHJlbW92ZSAnICsgJ2l0IGZyb20gdGhlIERPTSBlbGVtZW50LicsIG5hbWUsIGxvd2VyQ2FzZWROYW1lKTtcblxuICAgICAgd2FybmVkUHJvcGVydGllcyQxW25hbWVdID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJyAmJiBzaG91bGRSZW1vdmVBdHRyaWJ1dGVXaXRoV2FybmluZyhuYW1lLCB2YWx1ZSwgcHJvcGVydHlJbmZvLCBmYWxzZSkpIHtcbiAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICBlcnJvcignUmVjZWl2ZWQgYCVzYCBmb3IgYSBub24tYm9vbGVhbiBhdHRyaWJ1dGUgYCVzYC5cXG5cXG4nICsgJ0lmIHlvdSB3YW50IHRvIHdyaXRlIGl0IHRvIHRoZSBET00sIHBhc3MgYSBzdHJpbmcgaW5zdGVhZDogJyArICclcz1cIiVzXCIgb3IgJXM9e3ZhbHVlLnRvU3RyaW5nKCl9LicsIHZhbHVlLCBuYW1lLCBuYW1lLCB2YWx1ZSwgbmFtZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlcnJvcignUmVjZWl2ZWQgYCVzYCBmb3IgYSBub24tYm9vbGVhbiBhdHRyaWJ1dGUgYCVzYC5cXG5cXG4nICsgJ0lmIHlvdSB3YW50IHRvIHdyaXRlIGl0IHRvIHRoZSBET00sIHBhc3MgYSBzdHJpbmcgaW5zdGVhZDogJyArICclcz1cIiVzXCIgb3IgJXM9e3ZhbHVlLnRvU3RyaW5nKCl9LlxcblxcbicgKyAnSWYgeW91IHVzZWQgdG8gY29uZGl0aW9uYWxseSBvbWl0IGl0IHdpdGggJXM9e2NvbmRpdGlvbiAmJiB2YWx1ZX0sICcgKyAncGFzcyAlcz17Y29uZGl0aW9uID8gdmFsdWUgOiB1bmRlZmluZWR9IGluc3RlYWQuJywgdmFsdWUsIG5hbWUsIG5hbWUsIHZhbHVlLCBuYW1lLCBuYW1lLCBuYW1lKTtcbiAgICAgIH1cblxuICAgICAgd2FybmVkUHJvcGVydGllcyQxW25hbWVdID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gLy8gTm93IHRoYXQgd2UndmUgdmFsaWRhdGVkIGNhc2luZywgZG8gbm90IHZhbGlkYXRlXG4gICAgLy8gZGF0YSB0eXBlcyBmb3IgcmVzZXJ2ZWQgcHJvcHNcblxuXG4gICAgaWYgKGlzUmVzZXJ2ZWQpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gLy8gV2FybiB3aGVuIGEga25vd24gYXR0cmlidXRlIGlzIGEgYmFkIHR5cGVcblxuXG4gICAgaWYgKHNob3VsZFJlbW92ZUF0dHJpYnV0ZVdpdGhXYXJuaW5nKG5hbWUsIHZhbHVlLCBwcm9wZXJ0eUluZm8sIGZhbHNlKSkge1xuICAgICAgd2FybmVkUHJvcGVydGllcyQxW25hbWVdID0gdHJ1ZTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IC8vIFdhcm4gd2hlbiBwYXNzaW5nIHRoZSBzdHJpbmdzICdmYWxzZScgb3IgJ3RydWUnIGludG8gYSBib29sZWFuIHByb3BcblxuXG4gICAgaWYgKCh2YWx1ZSA9PT0gJ2ZhbHNlJyB8fCB2YWx1ZSA9PT0gJ3RydWUnKSAmJiBwcm9wZXJ0eUluZm8gIT09IG51bGwgJiYgcHJvcGVydHlJbmZvLnR5cGUgPT09IEJPT0xFQU4pIHtcbiAgICAgIGVycm9yKCdSZWNlaXZlZCB0aGUgc3RyaW5nIGAlc2AgZm9yIHRoZSBib29sZWFuIGF0dHJpYnV0ZSBgJXNgLiAnICsgJyVzICcgKyAnRGlkIHlvdSBtZWFuICVzPXslc30/JywgdmFsdWUsIG5hbWUsIHZhbHVlID09PSAnZmFsc2UnID8gJ1RoZSBicm93c2VyIHdpbGwgaW50ZXJwcmV0IGl0IGFzIGEgdHJ1dGh5IHZhbHVlLicgOiAnQWx0aG91Z2ggdGhpcyB3b3JrcywgaXQgd2lsbCBub3Qgd29yayBhcyBleHBlY3RlZCBpZiB5b3UgcGFzcyB0aGUgc3RyaW5nIFwiZmFsc2VcIi4nLCBuYW1lLCB2YWx1ZSk7XG5cbiAgICAgIHdhcm5lZFByb3BlcnRpZXMkMVtuYW1lXSA9IHRydWU7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcbn1cblxudmFyIHdhcm5Vbmtub3duUHJvcGVydGllcyA9IGZ1bmN0aW9uICh0eXBlLCBwcm9wcywgZXZlbnRSZWdpc3RyeSkge1xuICB7XG4gICAgdmFyIHVua25vd25Qcm9wcyA9IFtdO1xuXG4gICAgZm9yICh2YXIga2V5IGluIHByb3BzKSB7XG4gICAgICB2YXIgaXNWYWxpZCA9IHZhbGlkYXRlUHJvcGVydHkkMSh0eXBlLCBrZXksIHByb3BzW2tleV0sIGV2ZW50UmVnaXN0cnkpO1xuXG4gICAgICBpZiAoIWlzVmFsaWQpIHtcbiAgICAgICAgdW5rbm93blByb3BzLnB1c2goa2V5KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgdW5rbm93blByb3BTdHJpbmcgPSB1bmtub3duUHJvcHMubWFwKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgICByZXR1cm4gJ2AnICsgcHJvcCArICdgJztcbiAgICB9KS5qb2luKCcsICcpO1xuXG4gICAgaWYgKHVua25vd25Qcm9wcy5sZW5ndGggPT09IDEpIHtcbiAgICAgIGVycm9yKCdJbnZhbGlkIHZhbHVlIGZvciBwcm9wICVzIG9uIDwlcz4gdGFnLiBFaXRoZXIgcmVtb3ZlIGl0IGZyb20gdGhlIGVsZW1lbnQsICcgKyAnb3IgcGFzcyBhIHN0cmluZyBvciBudW1iZXIgdmFsdWUgdG8ga2VlcCBpdCBpbiB0aGUgRE9NLiAnICsgJ0ZvciBkZXRhaWxzLCBzZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL2F0dHJpYnV0ZS1iZWhhdmlvciAnLCB1bmtub3duUHJvcFN0cmluZywgdHlwZSk7XG4gICAgfSBlbHNlIGlmICh1bmtub3duUHJvcHMubGVuZ3RoID4gMSkge1xuICAgICAgZXJyb3IoJ0ludmFsaWQgdmFsdWVzIGZvciBwcm9wcyAlcyBvbiA8JXM+IHRhZy4gRWl0aGVyIHJlbW92ZSB0aGVtIGZyb20gdGhlIGVsZW1lbnQsICcgKyAnb3IgcGFzcyBhIHN0cmluZyBvciBudW1iZXIgdmFsdWUgdG8ga2VlcCB0aGVtIGluIHRoZSBET00uICcgKyAnRm9yIGRldGFpbHMsIHNlZSBodHRwczovL3JlYWN0anMub3JnL2xpbmsvYXR0cmlidXRlLWJlaGF2aW9yICcsIHVua25vd25Qcm9wU3RyaW5nLCB0eXBlKTtcbiAgICB9XG4gIH1cbn07XG5cbmZ1bmN0aW9uIHZhbGlkYXRlUHJvcGVydGllcyQyKHR5cGUsIHByb3BzLCBldmVudFJlZ2lzdHJ5KSB7XG4gIGlmIChpc0N1c3RvbUNvbXBvbmVudCh0eXBlLCBwcm9wcykpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB3YXJuVW5rbm93blByb3BlcnRpZXModHlwZSwgcHJvcHMsIGV2ZW50UmVnaXN0cnkpO1xufVxuXG52YXIgSVNfRVZFTlRfSEFORExFX05PTl9NQU5BR0VEX05PREUgPSAxO1xudmFyIElTX05PTl9ERUxFR0FURUQgPSAxIDw8IDE7XG52YXIgSVNfQ0FQVFVSRV9QSEFTRSA9IDEgPDwgMjtcbnZhciBJU19SRVBMQVlFRCA9IDEgPDwgNDtcbi8vIHNldCB0byBMRUdBQ1lfRkJfU1VQUE9SVC4gTEVHQUNZX0ZCX1NVUFBPUlQgb25seSBnZXRzIHNldCB3aGVuXG4vLyB3ZSBjYWxsIHdpbGxEZWZlckxhdGVyRm9yTGVnYWN5RkJTdXBwb3J0LCB0aHVzIG5vdCBiYWlsaW5nIG91dFxuLy8gd2lsbCByZXN1bHQgaW4gZW5kbGVzcyBjeWNsZXMgbGlrZSBhbiBpbmZpbml0ZSBsb29wLlxuLy8gV2UgYWxzbyBkb24ndCB3YW50IHRvIGRlZmVyIGR1cmluZyBldmVudCByZXBsYXlpbmcuXG5cbnZhciBTSE9VTERfTk9UX1BST0NFU1NfUE9MWUZJTExfRVZFTlRfUExVR0lOUyA9IElTX0VWRU5UX0hBTkRMRV9OT05fTUFOQUdFRF9OT0RFIHwgSVNfTk9OX0RFTEVHQVRFRCB8IElTX0NBUFRVUkVfUEhBU0U7XG5cbi8qKlxuICogR2V0cyB0aGUgdGFyZ2V0IG5vZGUgZnJvbSBhIG5hdGl2ZSBicm93c2VyIGV2ZW50IGJ5IGFjY291bnRpbmcgZm9yXG4gKiBpbmNvbnNpc3RlbmNpZXMgaW4gYnJvd3NlciBET00gQVBJcy5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gKiBAcmV0dXJuIHtET01FdmVudFRhcmdldH0gVGFyZ2V0IG5vZGUuXG4gKi9cblxuZnVuY3Rpb24gZ2V0RXZlbnRUYXJnZXQobmF0aXZlRXZlbnQpIHtcbiAgLy8gRmFsbGJhY2sgdG8gbmF0aXZlRXZlbnQuc3JjRWxlbWVudCBmb3IgSUU5XG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTI1MDZcbiAgdmFyIHRhcmdldCA9IG5hdGl2ZUV2ZW50LnRhcmdldCB8fCBuYXRpdmVFdmVudC5zcmNFbGVtZW50IHx8IHdpbmRvdzsgLy8gTm9ybWFsaXplIFNWRyA8dXNlPiBlbGVtZW50IGV2ZW50cyAjNDk2M1xuXG4gIGlmICh0YXJnZXQuY29ycmVzcG9uZGluZ1VzZUVsZW1lbnQpIHtcbiAgICB0YXJnZXQgPSB0YXJnZXQuY29ycmVzcG9uZGluZ1VzZUVsZW1lbnQ7XG4gIH0gLy8gU2FmYXJpIG1heSBmaXJlIGV2ZW50cyBvbiB0ZXh0IG5vZGVzIChOb2RlLlRFWFRfTk9ERSBpcyAzKS5cbiAgLy8gQHNlZSBodHRwOi8vd3d3LnF1aXJrc21vZGUub3JnL2pzL2V2ZW50c19wcm9wZXJ0aWVzLmh0bWxcblxuXG4gIHJldHVybiB0YXJnZXQubm9kZVR5cGUgPT09IFRFWFRfTk9ERSA/IHRhcmdldC5wYXJlbnROb2RlIDogdGFyZ2V0O1xufVxuXG52YXIgcmVzdG9yZUltcGwgPSBudWxsO1xudmFyIHJlc3RvcmVUYXJnZXQgPSBudWxsO1xudmFyIHJlc3RvcmVRdWV1ZSA9IG51bGw7XG5cbmZ1bmN0aW9uIHJlc3RvcmVTdGF0ZU9mVGFyZ2V0KHRhcmdldCkge1xuICAvLyBXZSBwZXJmb3JtIHRoaXMgdHJhbnNsYXRpb24gYXQgdGhlIGVuZCBvZiB0aGUgZXZlbnQgbG9vcCBzbyB0aGF0IHdlXG4gIC8vIGFsd2F5cyByZWNlaXZlIHRoZSBjb3JyZWN0IGZpYmVyIGhlcmVcbiAgdmFyIGludGVybmFsSW5zdGFuY2UgPSBnZXRJbnN0YW5jZUZyb21Ob2RlKHRhcmdldCk7XG5cbiAgaWYgKCFpbnRlcm5hbEluc3RhbmNlKSB7XG4gICAgLy8gVW5tb3VudGVkXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKCEodHlwZW9mIHJlc3RvcmVJbXBsID09PSAnZnVuY3Rpb24nKSkge1xuICAgIHtcbiAgICAgIHRocm93IEVycm9yKCBcInNldFJlc3RvcmVJbXBsZW1lbnRhdGlvbigpIG5lZWRzIHRvIGJlIGNhbGxlZCB0byBoYW5kbGUgYSB0YXJnZXQgZm9yIGNvbnRyb2xsZWQgZXZlbnRzLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiICk7XG4gICAgfVxuICB9XG5cbiAgdmFyIHN0YXRlTm9kZSA9IGludGVybmFsSW5zdGFuY2Uuc3RhdGVOb2RlOyAvLyBHdWFyZCBhZ2FpbnN0IEZpYmVyIGJlaW5nIHVubW91bnRlZC5cblxuICBpZiAoc3RhdGVOb2RlKSB7XG4gICAgdmFyIF9wcm9wcyA9IGdldEZpYmVyQ3VycmVudFByb3BzRnJvbU5vZGUoc3RhdGVOb2RlKTtcblxuICAgIHJlc3RvcmVJbXBsKGludGVybmFsSW5zdGFuY2Uuc3RhdGVOb2RlLCBpbnRlcm5hbEluc3RhbmNlLnR5cGUsIF9wcm9wcyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gc2V0UmVzdG9yZUltcGxlbWVudGF0aW9uKGltcGwpIHtcbiAgcmVzdG9yZUltcGwgPSBpbXBsO1xufVxuZnVuY3Rpb24gZW5xdWV1ZVN0YXRlUmVzdG9yZSh0YXJnZXQpIHtcbiAgaWYgKHJlc3RvcmVUYXJnZXQpIHtcbiAgICBpZiAocmVzdG9yZVF1ZXVlKSB7XG4gICAgICByZXN0b3JlUXVldWUucHVzaCh0YXJnZXQpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN0b3JlUXVldWUgPSBbdGFyZ2V0XTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcmVzdG9yZVRhcmdldCA9IHRhcmdldDtcbiAgfVxufVxuZnVuY3Rpb24gbmVlZHNTdGF0ZVJlc3RvcmUoKSB7XG4gIHJldHVybiByZXN0b3JlVGFyZ2V0ICE9PSBudWxsIHx8IHJlc3RvcmVRdWV1ZSAhPT0gbnVsbDtcbn1cbmZ1bmN0aW9uIHJlc3RvcmVTdGF0ZUlmTmVlZGVkKCkge1xuICBpZiAoIXJlc3RvcmVUYXJnZXQpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgdGFyZ2V0ID0gcmVzdG9yZVRhcmdldDtcbiAgdmFyIHF1ZXVlZFRhcmdldHMgPSByZXN0b3JlUXVldWU7XG4gIHJlc3RvcmVUYXJnZXQgPSBudWxsO1xuICByZXN0b3JlUXVldWUgPSBudWxsO1xuICByZXN0b3JlU3RhdGVPZlRhcmdldCh0YXJnZXQpO1xuXG4gIGlmIChxdWV1ZWRUYXJnZXRzKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBxdWV1ZWRUYXJnZXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICByZXN0b3JlU3RhdGVPZlRhcmdldChxdWV1ZWRUYXJnZXRzW2ldKTtcbiAgICB9XG4gIH1cbn1cblxuLy8gdGhlIHJlbmRlcmVyLiBTdWNoIGFzIHdoZW4gd2UncmUgZGlzcGF0Y2hpbmcgZXZlbnRzIG9yIGlmIHRoaXJkIHBhcnR5XG4vLyBsaWJyYXJpZXMgbmVlZCB0byBjYWxsIGJhdGNoZWRVcGRhdGVzLiBFdmVudHVhbGx5LCB0aGlzIEFQSSB3aWxsIGdvIGF3YXkgd2hlblxuLy8gZXZlcnl0aGluZyBpcyBiYXRjaGVkIGJ5IGRlZmF1bHQuIFdlJ2xsIHRoZW4gaGF2ZSBhIHNpbWlsYXIgQVBJIHRvIG9wdC1vdXQgb2Zcbi8vIHNjaGVkdWxlZCB3b3JrIGFuZCBpbnN0ZWFkIGRvIHN5bmNocm9ub3VzIHdvcmsuXG4vLyBEZWZhdWx0c1xuXG52YXIgYmF0Y2hlZFVwZGF0ZXNJbXBsID0gZnVuY3Rpb24gKGZuLCBib29ra2VlcGluZykge1xuICByZXR1cm4gZm4oYm9va2tlZXBpbmcpO1xufTtcblxudmFyIGRpc2NyZXRlVXBkYXRlc0ltcGwgPSBmdW5jdGlvbiAoZm4sIGEsIGIsIGMsIGQpIHtcbiAgcmV0dXJuIGZuKGEsIGIsIGMsIGQpO1xufTtcblxudmFyIGZsdXNoRGlzY3JldGVVcGRhdGVzSW1wbCA9IGZ1bmN0aW9uICgpIHt9O1xuXG52YXIgYmF0Y2hlZEV2ZW50VXBkYXRlc0ltcGwgPSBiYXRjaGVkVXBkYXRlc0ltcGw7XG52YXIgaXNJbnNpZGVFdmVudEhhbmRsZXIgPSBmYWxzZTtcbnZhciBpc0JhdGNoaW5nRXZlbnRVcGRhdGVzID0gZmFsc2U7XG5cbmZ1bmN0aW9uIGZpbmlzaEV2ZW50SGFuZGxlcigpIHtcbiAgLy8gSGVyZSB3ZSB3YWl0IHVudGlsIGFsbCB1cGRhdGVzIGhhdmUgcHJvcGFnYXRlZCwgd2hpY2ggaXMgaW1wb3J0YW50XG4gIC8vIHdoZW4gdXNpbmcgY29udHJvbGxlZCBjb21wb25lbnRzIHdpdGhpbiBsYXllcnM6XG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTY5OFxuICAvLyBUaGVuIHdlIHJlc3RvcmUgc3RhdGUgb2YgYW55IGNvbnRyb2xsZWQgY29tcG9uZW50LlxuICB2YXIgY29udHJvbGxlZENvbXBvbmVudHNIYXZlUGVuZGluZ1VwZGF0ZXMgPSBuZWVkc1N0YXRlUmVzdG9yZSgpO1xuXG4gIGlmIChjb250cm9sbGVkQ29tcG9uZW50c0hhdmVQZW5kaW5nVXBkYXRlcykge1xuICAgIC8vIElmIGEgY29udHJvbGxlZCBldmVudCB3YXMgZmlyZWQsIHdlIG1heSBuZWVkIHRvIHJlc3RvcmUgdGhlIHN0YXRlIG9mXG4gICAgLy8gdGhlIERPTSBub2RlIGJhY2sgdG8gdGhlIGNvbnRyb2xsZWQgdmFsdWUuIFRoaXMgaXMgbmVjZXNzYXJ5IHdoZW4gUmVhY3RcbiAgICAvLyBiYWlscyBvdXQgb2YgdGhlIHVwZGF0ZSB3aXRob3V0IHRvdWNoaW5nIHRoZSBET00uXG4gICAgZmx1c2hEaXNjcmV0ZVVwZGF0ZXNJbXBsKCk7XG4gICAgcmVzdG9yZVN0YXRlSWZOZWVkZWQoKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBiYXRjaGVkVXBkYXRlcyhmbiwgYm9va2tlZXBpbmcpIHtcbiAgaWYgKGlzSW5zaWRlRXZlbnRIYW5kbGVyKSB7XG4gICAgLy8gSWYgd2UgYXJlIGN1cnJlbnRseSBpbnNpZGUgYW5vdGhlciBiYXRjaCwgd2UgbmVlZCB0byB3YWl0IHVudGlsIGl0XG4gICAgLy8gZnVsbHkgY29tcGxldGVzIGJlZm9yZSByZXN0b3Jpbmcgc3RhdGUuXG4gICAgcmV0dXJuIGZuKGJvb2trZWVwaW5nKTtcbiAgfVxuXG4gIGlzSW5zaWRlRXZlbnRIYW5kbGVyID0gdHJ1ZTtcblxuICB0cnkge1xuICAgIHJldHVybiBiYXRjaGVkVXBkYXRlc0ltcGwoZm4sIGJvb2trZWVwaW5nKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBpc0luc2lkZUV2ZW50SGFuZGxlciA9IGZhbHNlO1xuICAgIGZpbmlzaEV2ZW50SGFuZGxlcigpO1xuICB9XG59XG5mdW5jdGlvbiBiYXRjaGVkRXZlbnRVcGRhdGVzKGZuLCBhLCBiKSB7XG4gIGlmIChpc0JhdGNoaW5nRXZlbnRVcGRhdGVzKSB7XG4gICAgLy8gSWYgd2UgYXJlIGN1cnJlbnRseSBpbnNpZGUgYW5vdGhlciBiYXRjaCwgd2UgbmVlZCB0byB3YWl0IHVudGlsIGl0XG4gICAgLy8gZnVsbHkgY29tcGxldGVzIGJlZm9yZSByZXN0b3Jpbmcgc3RhdGUuXG4gICAgcmV0dXJuIGZuKGEsIGIpO1xuICB9XG5cbiAgaXNCYXRjaGluZ0V2ZW50VXBkYXRlcyA9IHRydWU7XG5cbiAgdHJ5IHtcbiAgICByZXR1cm4gYmF0Y2hlZEV2ZW50VXBkYXRlc0ltcGwoZm4sIGEsIGIpO1xuICB9IGZpbmFsbHkge1xuICAgIGlzQmF0Y2hpbmdFdmVudFVwZGF0ZXMgPSBmYWxzZTtcbiAgICBmaW5pc2hFdmVudEhhbmRsZXIoKTtcbiAgfVxufVxuZnVuY3Rpb24gZGlzY3JldGVVcGRhdGVzKGZuLCBhLCBiLCBjLCBkKSB7XG4gIHZhciBwcmV2SXNJbnNpZGVFdmVudEhhbmRsZXIgPSBpc0luc2lkZUV2ZW50SGFuZGxlcjtcbiAgaXNJbnNpZGVFdmVudEhhbmRsZXIgPSB0cnVlO1xuXG4gIHRyeSB7XG4gICAgcmV0dXJuIGRpc2NyZXRlVXBkYXRlc0ltcGwoZm4sIGEsIGIsIGMsIGQpO1xuICB9IGZpbmFsbHkge1xuICAgIGlzSW5zaWRlRXZlbnRIYW5kbGVyID0gcHJldklzSW5zaWRlRXZlbnRIYW5kbGVyO1xuXG4gICAgaWYgKCFpc0luc2lkZUV2ZW50SGFuZGxlcikge1xuICAgICAgZmluaXNoRXZlbnRIYW5kbGVyKCk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBmbHVzaERpc2NyZXRlVXBkYXRlc0lmTmVlZGVkKHRpbWVTdGFtcCkge1xuICB7XG4gICAgaWYgKCFpc0luc2lkZUV2ZW50SGFuZGxlcikge1xuICAgICAgZmx1c2hEaXNjcmV0ZVVwZGF0ZXNJbXBsKCk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBzZXRCYXRjaGluZ0ltcGxlbWVudGF0aW9uKF9iYXRjaGVkVXBkYXRlc0ltcGwsIF9kaXNjcmV0ZVVwZGF0ZXNJbXBsLCBfZmx1c2hEaXNjcmV0ZVVwZGF0ZXNJbXBsLCBfYmF0Y2hlZEV2ZW50VXBkYXRlc0ltcGwpIHtcbiAgYmF0Y2hlZFVwZGF0ZXNJbXBsID0gX2JhdGNoZWRVcGRhdGVzSW1wbDtcbiAgZGlzY3JldGVVcGRhdGVzSW1wbCA9IF9kaXNjcmV0ZVVwZGF0ZXNJbXBsO1xuICBmbHVzaERpc2NyZXRlVXBkYXRlc0ltcGwgPSBfZmx1c2hEaXNjcmV0ZVVwZGF0ZXNJbXBsO1xuICBiYXRjaGVkRXZlbnRVcGRhdGVzSW1wbCA9IF9iYXRjaGVkRXZlbnRVcGRhdGVzSW1wbDtcbn1cblxuZnVuY3Rpb24gaXNJbnRlcmFjdGl2ZSh0YWcpIHtcbiAgcmV0dXJuIHRhZyA9PT0gJ2J1dHRvbicgfHwgdGFnID09PSAnaW5wdXQnIHx8IHRhZyA9PT0gJ3NlbGVjdCcgfHwgdGFnID09PSAndGV4dGFyZWEnO1xufVxuXG5mdW5jdGlvbiBzaG91bGRQcmV2ZW50TW91c2VFdmVudChuYW1lLCB0eXBlLCBwcm9wcykge1xuICBzd2l0Y2ggKG5hbWUpIHtcbiAgICBjYXNlICdvbkNsaWNrJzpcbiAgICBjYXNlICdvbkNsaWNrQ2FwdHVyZSc6XG4gICAgY2FzZSAnb25Eb3VibGVDbGljayc6XG4gICAgY2FzZSAnb25Eb3VibGVDbGlja0NhcHR1cmUnOlxuICAgIGNhc2UgJ29uTW91c2VEb3duJzpcbiAgICBjYXNlICdvbk1vdXNlRG93bkNhcHR1cmUnOlxuICAgIGNhc2UgJ29uTW91c2VNb3ZlJzpcbiAgICBjYXNlICdvbk1vdXNlTW92ZUNhcHR1cmUnOlxuICAgIGNhc2UgJ29uTW91c2VVcCc6XG4gICAgY2FzZSAnb25Nb3VzZVVwQ2FwdHVyZSc6XG4gICAgY2FzZSAnb25Nb3VzZUVudGVyJzpcbiAgICAgIHJldHVybiAhIShwcm9wcy5kaXNhYmxlZCAmJiBpc0ludGVyYWN0aXZlKHR5cGUpKTtcblxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IGluc3QgVGhlIGluc3RhbmNlLCB3aGljaCBpcyB0aGUgc291cmNlIG9mIGV2ZW50cy5cbiAqIEBwYXJhbSB7c3RyaW5nfSByZWdpc3RyYXRpb25OYW1lIE5hbWUgb2YgbGlzdGVuZXIgKGUuZy4gYG9uQ2xpY2tgKS5cbiAqIEByZXR1cm4gez9mdW5jdGlvbn0gVGhlIHN0b3JlZCBjYWxsYmFjay5cbiAqL1xuXG5cbmZ1bmN0aW9uIGdldExpc3RlbmVyKGluc3QsIHJlZ2lzdHJhdGlvbk5hbWUpIHtcbiAgdmFyIHN0YXRlTm9kZSA9IGluc3Quc3RhdGVOb2RlO1xuXG4gIGlmIChzdGF0ZU5vZGUgPT09IG51bGwpIHtcbiAgICAvLyBXb3JrIGluIHByb2dyZXNzIChleDogb25sb2FkIGV2ZW50cyBpbiBpbmNyZW1lbnRhbCBtb2RlKS5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBwcm9wcyA9IGdldEZpYmVyQ3VycmVudFByb3BzRnJvbU5vZGUoc3RhdGVOb2RlKTtcblxuICBpZiAocHJvcHMgPT09IG51bGwpIHtcbiAgICAvLyBXb3JrIGluIHByb2dyZXNzLlxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIGxpc3RlbmVyID0gcHJvcHNbcmVnaXN0cmF0aW9uTmFtZV07XG5cbiAgaWYgKHNob3VsZFByZXZlbnRNb3VzZUV2ZW50KHJlZ2lzdHJhdGlvbk5hbWUsIGluc3QudHlwZSwgcHJvcHMpKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBpZiAoISghbGlzdGVuZXIgfHwgdHlwZW9mIGxpc3RlbmVyID09PSAnZnVuY3Rpb24nKSkge1xuICAgIHtcbiAgICAgIHRocm93IEVycm9yKCBcIkV4cGVjdGVkIGBcIiArIHJlZ2lzdHJhdGlvbk5hbWUgKyBcImAgbGlzdGVuZXIgdG8gYmUgYSBmdW5jdGlvbiwgaW5zdGVhZCBnb3QgYSB2YWx1ZSBvZiBgXCIgKyB0eXBlb2YgbGlzdGVuZXIgKyBcImAgdHlwZS5cIiApO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBsaXN0ZW5lcjtcbn1cblxudmFyIHBhc3NpdmVCcm93c2VyRXZlbnRzU3VwcG9ydGVkID0gZmFsc2U7IC8vIENoZWNrIGlmIGJyb3dzZXIgc3VwcG9ydCBldmVudHMgd2l0aCBwYXNzaXZlIGxpc3RlbmVyc1xuLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0V2ZW50VGFyZ2V0L2FkZEV2ZW50TGlzdGVuZXIjU2FmZWx5X2RldGVjdGluZ19vcHRpb25fc3VwcG9ydFxuXG5pZiAoY2FuVXNlRE9NKSB7XG4gIHRyeSB7XG4gICAgdmFyIG9wdGlvbnMgPSB7fTsgLy8gJEZsb3dGaXhNZTogSWdub3JlIEZsb3cgY29tcGxhaW5pbmcgYWJvdXQgbmVlZGluZyBhIHZhbHVlXG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob3B0aW9ucywgJ3Bhc3NpdmUnLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcGFzc2l2ZUJyb3dzZXJFdmVudHNTdXBwb3J0ZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCd0ZXN0Jywgb3B0aW9ucywgb3B0aW9ucyk7XG4gICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Rlc3QnLCBvcHRpb25zLCBvcHRpb25zKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHBhc3NpdmVCcm93c2VyRXZlbnRzU3VwcG9ydGVkID0gZmFsc2U7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW52b2tlR3VhcmRlZENhbGxiYWNrUHJvZChuYW1lLCBmdW5jLCBjb250ZXh0LCBhLCBiLCBjLCBkLCBlLCBmKSB7XG4gIHZhciBmdW5jQXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMyk7XG5cbiAgdHJ5IHtcbiAgICBmdW5jLmFwcGx5KGNvbnRleHQsIGZ1bmNBcmdzKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICB0aGlzLm9uRXJyb3IoZXJyb3IpO1xuICB9XG59XG5cbnZhciBpbnZva2VHdWFyZGVkQ2FsbGJhY2tJbXBsID0gaW52b2tlR3VhcmRlZENhbGxiYWNrUHJvZDtcblxue1xuICAvLyBJbiBERVYgbW9kZSwgd2Ugc3dhcCBvdXQgaW52b2tlR3VhcmRlZENhbGxiYWNrIGZvciBhIHNwZWNpYWwgdmVyc2lvblxuICAvLyB0aGF0IHBsYXlzIG1vcmUgbmljZWx5IHdpdGggdGhlIGJyb3dzZXIncyBEZXZUb29scy4gVGhlIGlkZWEgaXMgdG8gcHJlc2VydmVcbiAgLy8gXCJQYXVzZSBvbiBleGNlcHRpb25zXCIgYmVoYXZpb3IuIEJlY2F1c2UgUmVhY3Qgd3JhcHMgYWxsIHVzZXItcHJvdmlkZWRcbiAgLy8gZnVuY3Rpb25zIGluIGludm9rZUd1YXJkZWRDYWxsYmFjaywgYW5kIHRoZSBwcm9kdWN0aW9uIHZlcnNpb24gb2ZcbiAgLy8gaW52b2tlR3VhcmRlZENhbGxiYWNrIHVzZXMgYSB0cnktY2F0Y2gsIGFsbCB1c2VyIGV4Y2VwdGlvbnMgYXJlIHRyZWF0ZWRcbiAgLy8gbGlrZSBjYXVnaHQgZXhjZXB0aW9ucywgYW5kIHRoZSBEZXZUb29scyB3b24ndCBwYXVzZSB1bmxlc3MgdGhlIGRldmVsb3BlclxuICAvLyB0YWtlcyB0aGUgZXh0cmEgc3RlcCBvZiBlbmFibGluZyBwYXVzZSBvbiBjYXVnaHQgZXhjZXB0aW9ucy4gVGhpcyBpc1xuICAvLyB1bmludHVpdGl2ZSwgdGhvdWdoLCBiZWNhdXNlIGV2ZW4gdGhvdWdoIFJlYWN0IGhhcyBjYXVnaHQgdGhlIGVycm9yLCBmcm9tXG4gIC8vIHRoZSBkZXZlbG9wZXIncyBwZXJzcGVjdGl2ZSwgdGhlIGVycm9yIGlzIHVuY2F1Z2h0LlxuICAvL1xuICAvLyBUbyBwcmVzZXJ2ZSB0aGUgZXhwZWN0ZWQgXCJQYXVzZSBvbiBleGNlcHRpb25zXCIgYmVoYXZpb3IsIHdlIGRvbid0IHVzZSBhXG4gIC8vIHRyeS1jYXRjaCBpbiBERVYuIEluc3RlYWQsIHdlIHN5bmNocm9ub3VzbHkgZGlzcGF0Y2ggYSBmYWtlIGV2ZW50IHRvIGEgZmFrZVxuICAvLyBET00gbm9kZSwgYW5kIGNhbGwgdGhlIHVzZXItcHJvdmlkZWQgY2FsbGJhY2sgZnJvbSBpbnNpZGUgYW4gZXZlbnQgaGFuZGxlclxuICAvLyBmb3IgdGhhdCBmYWtlIGV2ZW50LiBJZiB0aGUgY2FsbGJhY2sgdGhyb3dzLCB0aGUgZXJyb3IgaXMgXCJjYXB0dXJlZFwiIHVzaW5nXG4gIC8vIGEgZ2xvYmFsIGV2ZW50IGhhbmRsZXIuIEJ1dCBiZWNhdXNlIHRoZSBlcnJvciBoYXBwZW5zIGluIGEgZGlmZmVyZW50XG4gIC8vIGV2ZW50IGxvb3AgY29udGV4dCwgaXQgZG9lcyBub3QgaW50ZXJydXB0IHRoZSBub3JtYWwgcHJvZ3JhbSBmbG93LlxuICAvLyBFZmZlY3RpdmVseSwgdGhpcyBnaXZlcyB1cyB0cnktY2F0Y2ggYmVoYXZpb3Igd2l0aG91dCBhY3R1YWxseSB1c2luZ1xuICAvLyB0cnktY2F0Y2guIE5lYXQhXG4gIC8vIENoZWNrIHRoYXQgdGhlIGJyb3dzZXIgc3VwcG9ydHMgdGhlIEFQSXMgd2UgbmVlZCB0byBpbXBsZW1lbnQgb3VyIHNwZWNpYWxcbiAgLy8gREVWIHZlcnNpb24gb2YgaW52b2tlR3VhcmRlZENhbGxiYWNrXG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2Ygd2luZG93LmRpc3BhdGNoRXZlbnQgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgZG9jdW1lbnQuY3JlYXRlRXZlbnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICB2YXIgZmFrZU5vZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdyZWFjdCcpO1xuXG4gICAgaW52b2tlR3VhcmRlZENhbGxiYWNrSW1wbCA9IGZ1bmN0aW9uIGludm9rZUd1YXJkZWRDYWxsYmFja0RldihuYW1lLCBmdW5jLCBjb250ZXh0LCBhLCBiLCBjLCBkLCBlLCBmKSB7XG4gICAgICAvLyBJZiBkb2N1bWVudCBkb2Vzbid0IGV4aXN0IHdlIGtub3cgZm9yIHN1cmUgd2Ugd2lsbCBjcmFzaCBpbiB0aGlzIG1ldGhvZFxuICAgICAgLy8gd2hlbiB3ZSBjYWxsIGRvY3VtZW50LmNyZWF0ZUV2ZW50KCkuIEhvd2V2ZXIgdGhpcyBjYW4gY2F1c2UgY29uZnVzaW5nXG4gICAgICAvLyBlcnJvcnM6IGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9va2luY3ViYXRvci9jcmVhdGUtcmVhY3QtYXBwL2lzc3Vlcy8zNDgyXG4gICAgICAvLyBTbyB3ZSBwcmVlbXB0aXZlbHkgdGhyb3cgd2l0aCBhIGJldHRlciBtZXNzYWdlIGluc3RlYWQuXG4gICAgICBpZiAoISh0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnKSkge1xuICAgICAgICB7XG4gICAgICAgICAgdGhyb3cgRXJyb3IoIFwiVGhlIGBkb2N1bWVudGAgZ2xvYmFsIHdhcyBkZWZpbmVkIHdoZW4gUmVhY3Qgd2FzIGluaXRpYWxpemVkLCBidXQgaXMgbm90IGRlZmluZWQgYW55bW9yZS4gVGhpcyBjYW4gaGFwcGVuIGluIGEgdGVzdCBlbnZpcm9ubWVudCBpZiBhIGNvbXBvbmVudCBzY2hlZHVsZXMgYW4gdXBkYXRlIGZyb20gYW4gYXN5bmNocm9ub3VzIGNhbGxiYWNrLCBidXQgdGhlIHRlc3QgaGFzIGFscmVhZHkgZmluaXNoZWQgcnVubmluZy4gVG8gc29sdmUgdGhpcywgeW91IGNhbiBlaXRoZXIgdW5tb3VudCB0aGUgY29tcG9uZW50IGF0IHRoZSBlbmQgb2YgeW91ciB0ZXN0IChhbmQgZW5zdXJlIHRoYXQgYW55IGFzeW5jaHJvbm91cyBvcGVyYXRpb25zIGdldCBjYW5jZWxlZCBpbiBgY29tcG9uZW50V2lsbFVubW91bnRgKSwgb3IgeW91IGNhbiBjaGFuZ2UgdGhlIHRlc3QgaXRzZWxmIHRvIGJlIGFzeW5jaHJvbm91cy5cIiApO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBldnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnRXZlbnQnKTtcbiAgICAgIHZhciBkaWRDYWxsID0gZmFsc2U7IC8vIEtlZXBzIHRyYWNrIG9mIHdoZXRoZXIgdGhlIHVzZXItcHJvdmlkZWQgY2FsbGJhY2sgdGhyZXcgYW4gZXJyb3IuIFdlXG4gICAgICAvLyBzZXQgdGhpcyB0byB0cnVlIGF0IHRoZSBiZWdpbm5pbmcsIHRoZW4gc2V0IGl0IHRvIGZhbHNlIHJpZ2h0IGFmdGVyXG4gICAgICAvLyBjYWxsaW5nIHRoZSBmdW5jdGlvbi4gSWYgdGhlIGZ1bmN0aW9uIGVycm9ycywgYGRpZEVycm9yYCB3aWxsIG5ldmVyIGJlXG4gICAgICAvLyBzZXQgdG8gZmFsc2UuIFRoaXMgc3RyYXRlZ3kgd29ya3MgZXZlbiBpZiB0aGUgYnJvd3NlciBpcyBmbGFreSBhbmRcbiAgICAgIC8vIGZhaWxzIHRvIGNhbGwgb3VyIGdsb2JhbCBlcnJvciBoYW5kbGVyLCBiZWNhdXNlIGl0IGRvZXNuJ3QgcmVseSBvblxuICAgICAgLy8gdGhlIGVycm9yIGV2ZW50IGF0IGFsbC5cblxuICAgICAgdmFyIGRpZEVycm9yID0gdHJ1ZTsgLy8gS2VlcHMgdHJhY2sgb2YgdGhlIHZhbHVlIG9mIHdpbmRvdy5ldmVudCBzbyB0aGF0IHdlIGNhbiByZXNldCBpdFxuICAgICAgLy8gZHVyaW5nIHRoZSBjYWxsYmFjayB0byBsZXQgdXNlciBjb2RlIGFjY2VzcyB3aW5kb3cuZXZlbnQgaW4gdGhlXG4gICAgICAvLyBicm93c2VycyB0aGF0IHN1cHBvcnQgaXQuXG5cbiAgICAgIHZhciB3aW5kb3dFdmVudCA9IHdpbmRvdy5ldmVudDsgLy8gS2VlcHMgdHJhY2sgb2YgdGhlIGRlc2NyaXB0b3Igb2Ygd2luZG93LmV2ZW50IHRvIHJlc3RvcmUgaXQgYWZ0ZXIgZXZlbnRcbiAgICAgIC8vIGRpc3BhdGNoaW5nOiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzEzNjg4XG5cbiAgICAgIHZhciB3aW5kb3dFdmVudERlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHdpbmRvdywgJ2V2ZW50Jyk7XG5cbiAgICAgIGZ1bmN0aW9uIHJlc3RvcmVBZnRlckRpc3BhdGNoKCkge1xuICAgICAgICAvLyBXZSBpbW1lZGlhdGVseSByZW1vdmUgdGhlIGNhbGxiYWNrIGZyb20gZXZlbnQgbGlzdGVuZXJzIHNvIHRoYXRcbiAgICAgICAgLy8gbmVzdGVkIGBpbnZva2VHdWFyZGVkQ2FsbGJhY2tgIGNhbGxzIGRvIG5vdCBjbGFzaC4gT3RoZXJ3aXNlLCBhXG4gICAgICAgIC8vIG5lc3RlZCBjYWxsIHdvdWxkIHRyaWdnZXIgdGhlIGZha2UgZXZlbnQgaGFuZGxlcnMgb2YgYW55IGNhbGwgaGlnaGVyXG4gICAgICAgIC8vIGluIHRoZSBzdGFjay5cbiAgICAgICAgZmFrZU5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihldnRUeXBlLCBjYWxsQ2FsbGJhY2ssIGZhbHNlKTsgLy8gV2UgY2hlY2sgZm9yIHdpbmRvdy5oYXNPd25Qcm9wZXJ0eSgnZXZlbnQnKSB0byBwcmV2ZW50IHRoZVxuICAgICAgICAvLyB3aW5kb3cuZXZlbnQgYXNzaWdubWVudCBpbiBib3RoIElFIDw9IDEwIGFzIHRoZXkgdGhyb3cgYW4gZXJyb3JcbiAgICAgICAgLy8gXCJNZW1iZXIgbm90IGZvdW5kXCIgaW4gc3RyaWN0IG1vZGUsIGFuZCBpbiBGaXJlZm94IHdoaWNoIGRvZXMgbm90XG4gICAgICAgIC8vIHN1cHBvcnQgd2luZG93LmV2ZW50LlxuXG4gICAgICAgIGlmICh0eXBlb2Ygd2luZG93LmV2ZW50ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuaGFzT3duUHJvcGVydHkoJ2V2ZW50JykpIHtcbiAgICAgICAgICB3aW5kb3cuZXZlbnQgPSB3aW5kb3dFdmVudDtcbiAgICAgICAgfVxuICAgICAgfSAvLyBDcmVhdGUgYW4gZXZlbnQgaGFuZGxlciBmb3Igb3VyIGZha2UgZXZlbnQuIFdlIHdpbGwgc3luY2hyb25vdXNseVxuICAgICAgLy8gZGlzcGF0Y2ggb3VyIGZha2UgZXZlbnQgdXNpbmcgYGRpc3BhdGNoRXZlbnRgLiBJbnNpZGUgdGhlIGhhbmRsZXIsIHdlXG4gICAgICAvLyBjYWxsIHRoZSB1c2VyLXByb3ZpZGVkIGNhbGxiYWNrLlxuXG5cbiAgICAgIHZhciBmdW5jQXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMyk7XG5cbiAgICAgIGZ1bmN0aW9uIGNhbGxDYWxsYmFjaygpIHtcbiAgICAgICAgZGlkQ2FsbCA9IHRydWU7XG4gICAgICAgIHJlc3RvcmVBZnRlckRpc3BhdGNoKCk7XG4gICAgICAgIGZ1bmMuYXBwbHkoY29udGV4dCwgZnVuY0FyZ3MpO1xuICAgICAgICBkaWRFcnJvciA9IGZhbHNlO1xuICAgICAgfSAvLyBDcmVhdGUgYSBnbG9iYWwgZXJyb3IgZXZlbnQgaGFuZGxlci4gV2UgdXNlIHRoaXMgdG8gY2FwdHVyZSB0aGUgdmFsdWVcbiAgICAgIC8vIHRoYXQgd2FzIHRocm93bi4gSXQncyBwb3NzaWJsZSB0aGF0IHRoaXMgZXJyb3IgaGFuZGxlciB3aWxsIGZpcmUgbW9yZVxuICAgICAgLy8gdGhhbiBvbmNlOyBmb3IgZXhhbXBsZSwgaWYgbm9uLVJlYWN0IGNvZGUgYWxzbyBjYWxscyBgZGlzcGF0Y2hFdmVudGBcbiAgICAgIC8vIGFuZCBhIGhhbmRsZXIgZm9yIHRoYXQgZXZlbnQgdGhyb3dzLiBXZSBzaG91bGQgYmUgcmVzaWxpZW50IHRvIG1vc3Qgb2ZcbiAgICAgIC8vIHRob3NlIGNhc2VzLiBFdmVuIGlmIG91ciBlcnJvciBldmVudCBoYW5kbGVyIGZpcmVzIG1vcmUgdGhhbiBvbmNlLCB0aGVcbiAgICAgIC8vIGxhc3QgZXJyb3IgZXZlbnQgaXMgYWx3YXlzIHVzZWQuIElmIHRoZSBjYWxsYmFjayBhY3R1YWxseSBkb2VzIGVycm9yLFxuICAgICAgLy8gd2Uga25vdyB0aGF0IHRoZSBsYXN0IGVycm9yIGV2ZW50IGlzIHRoZSBjb3JyZWN0IG9uZSwgYmVjYXVzZSBpdCdzIG5vdFxuICAgICAgLy8gcG9zc2libGUgZm9yIGFueXRoaW5nIGVsc2UgdG8gaGF2ZSBoYXBwZW5lZCBpbiBiZXR3ZWVuIG91ciBjYWxsYmFja1xuICAgICAgLy8gZXJyb3JpbmcgYW5kIHRoZSBjb2RlIHRoYXQgZm9sbG93cyB0aGUgYGRpc3BhdGNoRXZlbnRgIGNhbGwgYmVsb3cuIElmXG4gICAgICAvLyB0aGUgY2FsbGJhY2sgZG9lc24ndCBlcnJvciwgYnV0IHRoZSBlcnJvciBldmVudCB3YXMgZmlyZWQsIHdlIGtub3cgdG9cbiAgICAgIC8vIGlnbm9yZSBpdCBiZWNhdXNlIGBkaWRFcnJvcmAgd2lsbCBiZSBmYWxzZSwgYXMgZGVzY3JpYmVkIGFib3ZlLlxuXG5cbiAgICAgIHZhciBlcnJvcjsgLy8gVXNlIHRoaXMgdG8gdHJhY2sgd2hldGhlciB0aGUgZXJyb3IgZXZlbnQgaXMgZXZlciBjYWxsZWQuXG5cbiAgICAgIHZhciBkaWRTZXRFcnJvciA9IGZhbHNlO1xuICAgICAgdmFyIGlzQ3Jvc3NPcmlnaW5FcnJvciA9IGZhbHNlO1xuXG4gICAgICBmdW5jdGlvbiBoYW5kbGVXaW5kb3dFcnJvcihldmVudCkge1xuICAgICAgICBlcnJvciA9IGV2ZW50LmVycm9yO1xuICAgICAgICBkaWRTZXRFcnJvciA9IHRydWU7XG5cbiAgICAgICAgaWYgKGVycm9yID09PSBudWxsICYmIGV2ZW50LmNvbG5vID09PSAwICYmIGV2ZW50LmxpbmVubyA9PT0gMCkge1xuICAgICAgICAgIGlzQ3Jvc3NPcmlnaW5FcnJvciA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZXZlbnQuZGVmYXVsdFByZXZlbnRlZCkge1xuICAgICAgICAgIC8vIFNvbWUgb3RoZXIgZXJyb3IgaGFuZGxlciBoYXMgcHJldmVudGVkIGRlZmF1bHQuXG4gICAgICAgICAgLy8gQnJvd3NlcnMgc2lsZW5jZSB0aGUgZXJyb3IgcmVwb3J0IGlmIHRoaXMgaGFwcGVucy5cbiAgICAgICAgICAvLyBXZSdsbCByZW1lbWJlciB0aGlzIHRvIGxhdGVyIGRlY2lkZSB3aGV0aGVyIHRvIGxvZyBpdCBvciBub3QuXG4gICAgICAgICAgaWYgKGVycm9yICE9IG51bGwgJiYgdHlwZW9mIGVycm9yID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgZXJyb3IuX3N1cHByZXNzTG9nZ2luZyA9IHRydWU7XG4gICAgICAgICAgICB9IGNhdGNoIChpbm5lcikgey8vIElnbm9yZS5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gLy8gQ3JlYXRlIGEgZmFrZSBldmVudCB0eXBlLlxuXG5cbiAgICAgIHZhciBldnRUeXBlID0gXCJyZWFjdC1cIiArIChuYW1lID8gbmFtZSA6ICdpbnZva2VndWFyZGVkY2FsbGJhY2snKTsgLy8gQXR0YWNoIG91ciBldmVudCBoYW5kbGVyc1xuXG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignZXJyb3InLCBoYW5kbGVXaW5kb3dFcnJvcik7XG4gICAgICBmYWtlTm9kZS5hZGRFdmVudExpc3RlbmVyKGV2dFR5cGUsIGNhbGxDYWxsYmFjaywgZmFsc2UpOyAvLyBTeW5jaHJvbm91c2x5IGRpc3BhdGNoIG91ciBmYWtlIGV2ZW50LiBJZiB0aGUgdXNlci1wcm92aWRlZCBmdW5jdGlvblxuICAgICAgLy8gZXJyb3JzLCBpdCB3aWxsIHRyaWdnZXIgb3VyIGdsb2JhbCBlcnJvciBoYW5kbGVyLlxuXG4gICAgICBldnQuaW5pdEV2ZW50KGV2dFR5cGUsIGZhbHNlLCBmYWxzZSk7XG4gICAgICBmYWtlTm9kZS5kaXNwYXRjaEV2ZW50KGV2dCk7XG5cbiAgICAgIGlmICh3aW5kb3dFdmVudERlc2NyaXB0b3IpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHdpbmRvdywgJ2V2ZW50Jywgd2luZG93RXZlbnREZXNjcmlwdG9yKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGRpZENhbGwgJiYgZGlkRXJyb3IpIHtcbiAgICAgICAgaWYgKCFkaWRTZXRFcnJvcikge1xuICAgICAgICAgIC8vIFRoZSBjYWxsYmFjayBlcnJvcmVkLCBidXQgdGhlIGVycm9yIGV2ZW50IG5ldmVyIGZpcmVkLlxuICAgICAgICAgIGVycm9yID0gbmV3IEVycm9yKCdBbiBlcnJvciB3YXMgdGhyb3duIGluc2lkZSBvbmUgb2YgeW91ciBjb21wb25lbnRzLCBidXQgUmVhY3QgJyArIFwiZG9lc24ndCBrbm93IHdoYXQgaXQgd2FzLiBUaGlzIGlzIGxpa2VseSBkdWUgdG8gYnJvd3NlciBcIiArICdmbGFraW5lc3MuIFJlYWN0IGRvZXMgaXRzIGJlc3QgdG8gcHJlc2VydmUgdGhlIFwiUGF1c2Ugb24gJyArICdleGNlcHRpb25zXCIgYmVoYXZpb3Igb2YgdGhlIERldlRvb2xzLCB3aGljaCByZXF1aXJlcyBzb21lICcgKyBcIkRFVi1tb2RlIG9ubHkgdHJpY2tzLiBJdCdzIHBvc3NpYmxlIHRoYXQgdGhlc2UgZG9uJ3Qgd29yayBpbiBcIiArICd5b3VyIGJyb3dzZXIuIFRyeSB0cmlnZ2VyaW5nIHRoZSBlcnJvciBpbiBwcm9kdWN0aW9uIG1vZGUsICcgKyAnb3Igc3dpdGNoaW5nIHRvIGEgbW9kZXJuIGJyb3dzZXIuIElmIHlvdSBzdXNwZWN0IHRoYXQgdGhpcyBpcyAnICsgJ2FjdHVhbGx5IGFuIGlzc3VlIHdpdGggUmVhY3QsIHBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgICAgICB9IGVsc2UgaWYgKGlzQ3Jvc3NPcmlnaW5FcnJvcikge1xuICAgICAgICAgIGVycm9yID0gbmV3IEVycm9yKFwiQSBjcm9zcy1vcmlnaW4gZXJyb3Igd2FzIHRocm93bi4gUmVhY3QgZG9lc24ndCBoYXZlIGFjY2VzcyB0byBcIiArICd0aGUgYWN0dWFsIGVycm9yIG9iamVjdCBpbiBkZXZlbG9wbWVudC4gJyArICdTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL2Nyb3Nzb3JpZ2luLWVycm9yIGZvciBtb3JlIGluZm9ybWF0aW9uLicpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5vbkVycm9yKGVycm9yKTtcbiAgICAgIH0gLy8gUmVtb3ZlIG91ciBldmVudCBsaXN0ZW5lcnNcblxuXG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignZXJyb3InLCBoYW5kbGVXaW5kb3dFcnJvcik7XG5cbiAgICAgIGlmICghZGlkQ2FsbCkge1xuICAgICAgICAvLyBTb21ldGhpbmcgd2VudCByZWFsbHkgd3JvbmcsIGFuZCBvdXIgZXZlbnQgd2FzIG5vdCBkaXNwYXRjaGVkLlxuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzE2NzM0XG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTY1ODVcbiAgICAgICAgLy8gRmFsbCBiYWNrIHRvIHRoZSBwcm9kdWN0aW9uIGltcGxlbWVudGF0aW9uLlxuICAgICAgICByZXN0b3JlQWZ0ZXJEaXNwYXRjaCgpO1xuICAgICAgICByZXR1cm4gaW52b2tlR3VhcmRlZENhbGxiYWNrUHJvZC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuICAgIH07XG4gIH1cbn1cblxudmFyIGludm9rZUd1YXJkZWRDYWxsYmFja0ltcGwkMSA9IGludm9rZUd1YXJkZWRDYWxsYmFja0ltcGw7XG5cbnZhciBoYXNFcnJvciA9IGZhbHNlO1xudmFyIGNhdWdodEVycm9yID0gbnVsbDsgLy8gVXNlZCBieSBldmVudCBzeXN0ZW0gdG8gY2FwdHVyZS9yZXRocm93IHRoZSBmaXJzdCBlcnJvci5cblxudmFyIGhhc1JldGhyb3dFcnJvciA9IGZhbHNlO1xudmFyIHJldGhyb3dFcnJvciA9IG51bGw7XG52YXIgcmVwb3J0ZXIgPSB7XG4gIG9uRXJyb3I6IGZ1bmN0aW9uIChlcnJvcikge1xuICAgIGhhc0Vycm9yID0gdHJ1ZTtcbiAgICBjYXVnaHRFcnJvciA9IGVycm9yO1xuICB9XG59O1xuLyoqXG4gKiBDYWxsIGEgZnVuY3Rpb24gd2hpbGUgZ3VhcmRpbmcgYWdhaW5zdCBlcnJvcnMgdGhhdCBoYXBwZW5zIHdpdGhpbiBpdC5cbiAqIFJldHVybnMgYW4gZXJyb3IgaWYgaXQgdGhyb3dzLCBvdGhlcndpc2UgbnVsbC5cbiAqXG4gKiBJbiBwcm9kdWN0aW9uLCB0aGlzIGlzIGltcGxlbWVudGVkIHVzaW5nIGEgdHJ5LWNhdGNoLiBUaGUgcmVhc29uIHdlIGRvbid0XG4gKiB1c2UgYSB0cnktY2F0Y2ggZGlyZWN0bHkgaXMgc28gdGhhdCB3ZSBjYW4gc3dhcCBvdXQgYSBkaWZmZXJlbnRcbiAqIGltcGxlbWVudGF0aW9uIGluIERFViBtb2RlLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIG9mIHRoZSBndWFyZCB0byB1c2UgZm9yIGxvZ2dpbmcgb3IgZGVidWdnaW5nXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBpbnZva2VcbiAqIEBwYXJhbSB7Kn0gY29udGV4dCBUaGUgY29udGV4dCB0byB1c2Ugd2hlbiBjYWxsaW5nIHRoZSBmdW5jdGlvblxuICogQHBhcmFtIHsuLi4qfSBhcmdzIEFyZ3VtZW50cyBmb3IgZnVuY3Rpb25cbiAqL1xuXG5mdW5jdGlvbiBpbnZva2VHdWFyZGVkQ2FsbGJhY2sobmFtZSwgZnVuYywgY29udGV4dCwgYSwgYiwgYywgZCwgZSwgZikge1xuICBoYXNFcnJvciA9IGZhbHNlO1xuICBjYXVnaHRFcnJvciA9IG51bGw7XG4gIGludm9rZUd1YXJkZWRDYWxsYmFja0ltcGwkMS5hcHBseShyZXBvcnRlciwgYXJndW1lbnRzKTtcbn1cbi8qKlxuICogU2FtZSBhcyBpbnZva2VHdWFyZGVkQ2FsbGJhY2ssIGJ1dCBpbnN0ZWFkIG9mIHJldHVybmluZyBhbiBlcnJvciwgaXQgc3RvcmVzXG4gKiBpdCBpbiBhIGdsb2JhbCBzbyBpdCBjYW4gYmUgcmV0aHJvd24gYnkgYHJldGhyb3dDYXVnaHRFcnJvcmAgbGF0ZXIuXG4gKiBUT0RPOiBTZWUgaWYgY2F1Z2h0RXJyb3IgYW5kIHJldGhyb3dFcnJvciBjYW4gYmUgdW5pZmllZC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBvZiB0aGUgZ3VhcmQgdG8gdXNlIGZvciBsb2dnaW5nIG9yIGRlYnVnZ2luZ1xuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gaW52b2tlXG4gKiBAcGFyYW0geyp9IGNvbnRleHQgVGhlIGNvbnRleHQgdG8gdXNlIHdoZW4gY2FsbGluZyB0aGUgZnVuY3Rpb25cbiAqIEBwYXJhbSB7Li4uKn0gYXJncyBBcmd1bWVudHMgZm9yIGZ1bmN0aW9uXG4gKi9cblxuZnVuY3Rpb24gaW52b2tlR3VhcmRlZENhbGxiYWNrQW5kQ2F0Y2hGaXJzdEVycm9yKG5hbWUsIGZ1bmMsIGNvbnRleHQsIGEsIGIsIGMsIGQsIGUsIGYpIHtcbiAgaW52b2tlR3VhcmRlZENhbGxiYWNrLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgaWYgKGhhc0Vycm9yKSB7XG4gICAgdmFyIGVycm9yID0gY2xlYXJDYXVnaHRFcnJvcigpO1xuXG4gICAgaWYgKCFoYXNSZXRocm93RXJyb3IpIHtcbiAgICAgIGhhc1JldGhyb3dFcnJvciA9IHRydWU7XG4gICAgICByZXRocm93RXJyb3IgPSBlcnJvcjtcbiAgICB9XG4gIH1cbn1cbi8qKlxuICogRHVyaW5nIGV4ZWN1dGlvbiBvZiBndWFyZGVkIGZ1bmN0aW9ucyB3ZSB3aWxsIGNhcHR1cmUgdGhlIGZpcnN0IGVycm9yIHdoaWNoXG4gKiB3ZSB3aWxsIHJldGhyb3cgdG8gYmUgaGFuZGxlZCBieSB0aGUgdG9wIGxldmVsIGVycm9yIGhhbmRsZXIuXG4gKi9cblxuZnVuY3Rpb24gcmV0aHJvd0NhdWdodEVycm9yKCkge1xuICBpZiAoaGFzUmV0aHJvd0Vycm9yKSB7XG4gICAgdmFyIGVycm9yID0gcmV0aHJvd0Vycm9yO1xuICAgIGhhc1JldGhyb3dFcnJvciA9IGZhbHNlO1xuICAgIHJldGhyb3dFcnJvciA9IG51bGw7XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbn1cbmZ1bmN0aW9uIGhhc0NhdWdodEVycm9yKCkge1xuICByZXR1cm4gaGFzRXJyb3I7XG59XG5mdW5jdGlvbiBjbGVhckNhdWdodEVycm9yKCkge1xuICBpZiAoaGFzRXJyb3IpIHtcbiAgICB2YXIgZXJyb3IgPSBjYXVnaHRFcnJvcjtcbiAgICBoYXNFcnJvciA9IGZhbHNlO1xuICAgIGNhdWdodEVycm9yID0gbnVsbDtcbiAgICByZXR1cm4gZXJyb3I7XG4gIH0gZWxzZSB7XG4gICAge1xuICAgICAge1xuICAgICAgICB0aHJvdyBFcnJvciggXCJjbGVhckNhdWdodEVycm9yIHdhcyBjYWxsZWQgYnV0IG5vIGVycm9yIHdhcyBjYXB0dXJlZC4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS5cIiApO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIGBSZWFjdEluc3RhbmNlTWFwYCBtYWludGFpbnMgYSBtYXBwaW5nIGZyb20gYSBwdWJsaWMgZmFjaW5nIHN0YXRlZnVsXG4gKiBpbnN0YW5jZSAoa2V5KSBhbmQgdGhlIGludGVybmFsIHJlcHJlc2VudGF0aW9uICh2YWx1ZSkuIFRoaXMgYWxsb3dzIHB1YmxpY1xuICogbWV0aG9kcyB0byBhY2NlcHQgdGhlIHVzZXIgZmFjaW5nIGluc3RhbmNlIGFzIGFuIGFyZ3VtZW50IGFuZCBtYXAgdGhlbSBiYWNrXG4gKiB0byBpbnRlcm5hbCBtZXRob2RzLlxuICpcbiAqIE5vdGUgdGhhdCB0aGlzIG1vZHVsZSBpcyBjdXJyZW50bHkgc2hhcmVkIGFuZCBhc3N1bWVkIHRvIGJlIHN0YXRlbGVzcy5cbiAqIElmIHRoaXMgYmVjb21lcyBhbiBhY3R1YWwgTWFwLCB0aGF0IHdpbGwgYnJlYWsuXG4gKi9cbmZ1bmN0aW9uIGdldChrZXkpIHtcbiAgcmV0dXJuIGtleS5fcmVhY3RJbnRlcm5hbHM7XG59XG5mdW5jdGlvbiBoYXMoa2V5KSB7XG4gIHJldHVybiBrZXkuX3JlYWN0SW50ZXJuYWxzICE9PSB1bmRlZmluZWQ7XG59XG5mdW5jdGlvbiBzZXQoa2V5LCB2YWx1ZSkge1xuICBrZXkuX3JlYWN0SW50ZXJuYWxzID0gdmFsdWU7XG59XG5cbi8vIERvbid0IGNoYW5nZSB0aGVzZSB0d28gdmFsdWVzLiBUaGV5J3JlIHVzZWQgYnkgUmVhY3QgRGV2IFRvb2xzLlxudmFyIE5vRmxhZ3MgPVxuLyogICAgICAgICAgICAgICAgICAgICAgKi9cbjA7XG52YXIgUGVyZm9ybWVkV29yayA9XG4vKiAgICAgICAgICAgICAgICAqL1xuMTsgLy8gWW91IGNhbiBjaGFuZ2UgdGhlIHJlc3QgKGFuZCBhZGQgbW9yZSkuXG5cbnZhciBQbGFjZW1lbnQgPVxuLyogICAgICAgICAgICAgICAgICAgICovXG4yO1xudmFyIFVwZGF0ZSA9XG4vKiAgICAgICAgICAgICAgICAgICAgICAgKi9cbjQ7XG52YXIgUGxhY2VtZW50QW5kVXBkYXRlID1cbi8qICAgICAgICAgICAqL1xuNjtcbnZhciBEZWxldGlvbiA9XG4vKiAgICAgICAgICAgICAgICAgICAgICovXG44O1xudmFyIENvbnRlbnRSZXNldCA9XG4vKiAgICAgICAgICAgICAgICAgKi9cbjE2O1xudmFyIENhbGxiYWNrID1cbi8qICAgICAgICAgICAgICAgICAgICAgKi9cbjMyO1xudmFyIERpZENhcHR1cmUgPVxuLyogICAgICAgICAgICAgICAgICAgKi9cbjY0O1xudmFyIFJlZiA9XG4vKiAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cbjEyODtcbnZhciBTbmFwc2hvdCA9XG4vKiAgICAgICAgICAgICAgICAgICAgICovXG4yNTY7XG52YXIgUGFzc2l2ZSA9XG4vKiAgICAgICAgICAgICAgICAgICAgICAqL1xuNTEyOyAvLyBUT0RPIChlZmZlY3RzKSBSZW1vdmUgdGhpcyBiaXQgb25jZSB0aGUgbmV3IHJlY29uY2lsZXIgaXMgc3luY2VkIHRvIHRoZSBvbGQuXG5cbnZhciBQYXNzaXZlVW5tb3VudFBlbmRpbmdEZXYgPVxuLyogICAgICovXG44MTkyO1xudmFyIEh5ZHJhdGluZyA9XG4vKiAgICAgICAgICAgICAgICAgICAgKi9cbjEwMjQ7XG52YXIgSHlkcmF0aW5nQW5kVXBkYXRlID1cbi8qICAgICAgICAgICAqL1xuMTAyODsgLy8gUGFzc2l2ZSAmIFVwZGF0ZSAmIENhbGxiYWNrICYgUmVmICYgU25hcHNob3RcblxudmFyIExpZmVjeWNsZUVmZmVjdE1hc2sgPVxuLyogICAgICAgICAgKi9cbjkzMjsgLy8gVW5pb24gb2YgYWxsIGhvc3QgZWZmZWN0c1xuXG52YXIgSG9zdEVmZmVjdE1hc2sgPVxuLyogICAgICAgICAgICAgICAqL1xuMjA0NzsgLy8gVGhlc2UgYXJlIG5vdCByZWFsbHkgc2lkZSBlZmZlY3RzLCBidXQgd2Ugc3RpbGwgcmV1c2UgdGhpcyBmaWVsZC5cblxudmFyIEluY29tcGxldGUgPVxuLyogICAgICAgICAgICAgICAgICAgKi9cbjIwNDg7XG52YXIgU2hvdWxkQ2FwdHVyZSA9XG4vKiAgICAgICAgICAgICAgICAqL1xuNDA5NjtcbnZhciBGb3JjZVVwZGF0ZUZvckxlZ2FjeVN1c3BlbnNlID1cbi8qICovXG4xNjM4NDsgLy8gU3RhdGljIHRhZ3MgZGVzY3JpYmUgYXNwZWN0cyBvZiBhIGZpYmVyIHRoYXQgYXJlIG5vdCBzcGVjaWZpYyB0byBhIHJlbmRlcixcblxudmFyIFJlYWN0Q3VycmVudE93bmVyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3RDdXJyZW50T3duZXI7XG5mdW5jdGlvbiBnZXROZWFyZXN0TW91bnRlZEZpYmVyKGZpYmVyKSB7XG4gIHZhciBub2RlID0gZmliZXI7XG4gIHZhciBuZWFyZXN0TW91bnRlZCA9IGZpYmVyO1xuXG4gIGlmICghZmliZXIuYWx0ZXJuYXRlKSB7XG4gICAgLy8gSWYgdGhlcmUgaXMgbm8gYWx0ZXJuYXRlLCB0aGlzIG1pZ2h0IGJlIGEgbmV3IHRyZWUgdGhhdCBpc24ndCBpbnNlcnRlZFxuICAgIC8vIHlldC4gSWYgaXQgaXMsIHRoZW4gaXQgd2lsbCBoYXZlIGEgcGVuZGluZyBpbnNlcnRpb24gZWZmZWN0IG9uIGl0LlxuICAgIHZhciBuZXh0Tm9kZSA9IG5vZGU7XG5cbiAgICBkbyB7XG4gICAgICBub2RlID0gbmV4dE5vZGU7XG5cbiAgICAgIGlmICgobm9kZS5mbGFncyAmIChQbGFjZW1lbnQgfCBIeWRyYXRpbmcpKSAhPT0gTm9GbGFncykge1xuICAgICAgICAvLyBUaGlzIGlzIGFuIGluc2VydGlvbiBvciBpbi1wcm9ncmVzcyBoeWRyYXRpb24uIFRoZSBuZWFyZXN0IHBvc3NpYmxlXG4gICAgICAgIC8vIG1vdW50ZWQgZmliZXIgaXMgdGhlIHBhcmVudCBidXQgd2UgbmVlZCB0byBjb250aW51ZSB0byBmaWd1cmUgb3V0XG4gICAgICAgIC8vIGlmIHRoYXQgb25lIGlzIHN0aWxsIG1vdW50ZWQuXG4gICAgICAgIG5lYXJlc3RNb3VudGVkID0gbm9kZS5yZXR1cm47XG4gICAgICB9XG5cbiAgICAgIG5leHROb2RlID0gbm9kZS5yZXR1cm47XG4gICAgfSB3aGlsZSAobmV4dE5vZGUpO1xuICB9IGVsc2Uge1xuICAgIHdoaWxlIChub2RlLnJldHVybikge1xuICAgICAgbm9kZSA9IG5vZGUucmV0dXJuO1xuICAgIH1cbiAgfVxuXG4gIGlmIChub2RlLnRhZyA9PT0gSG9zdFJvb3QpIHtcbiAgICAvLyBUT0RPOiBDaGVjayBpZiB0aGlzIHdhcyBhIG5lc3RlZCBIb3N0Um9vdCB3aGVuIHVzZWQgd2l0aFxuICAgIC8vIHJlbmRlckNvbnRhaW5lckludG9TdWJ0cmVlLlxuICAgIHJldHVybiBuZWFyZXN0TW91bnRlZDtcbiAgfSAvLyBJZiB3ZSBkaWRuJ3QgaGl0IHRoZSByb290LCB0aGF0IG1lYW5zIHRoYXQgd2UncmUgaW4gYW4gZGlzY29ubmVjdGVkIHRyZWVcbiAgLy8gdGhhdCBoYXMgYmVlbiB1bm1vdW50ZWQuXG5cblxuICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGdldFN1c3BlbnNlSW5zdGFuY2VGcm9tRmliZXIoZmliZXIpIHtcbiAgaWYgKGZpYmVyLnRhZyA9PT0gU3VzcGVuc2VDb21wb25lbnQpIHtcbiAgICB2YXIgc3VzcGVuc2VTdGF0ZSA9IGZpYmVyLm1lbW9pemVkU3RhdGU7XG5cbiAgICBpZiAoc3VzcGVuc2VTdGF0ZSA9PT0gbnVsbCkge1xuICAgICAgdmFyIGN1cnJlbnQgPSBmaWJlci5hbHRlcm5hdGU7XG5cbiAgICAgIGlmIChjdXJyZW50ICE9PSBudWxsKSB7XG4gICAgICAgIHN1c3BlbnNlU3RhdGUgPSBjdXJyZW50Lm1lbW9pemVkU3RhdGU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHN1c3BlbnNlU3RhdGUgIT09IG51bGwpIHtcbiAgICAgIHJldHVybiBzdXNwZW5zZVN0YXRlLmRlaHlkcmF0ZWQ7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBnZXRDb250YWluZXJGcm9tRmliZXIoZmliZXIpIHtcbiAgcmV0dXJuIGZpYmVyLnRhZyA9PT0gSG9zdFJvb3QgPyBmaWJlci5zdGF0ZU5vZGUuY29udGFpbmVySW5mbyA6IG51bGw7XG59XG5mdW5jdGlvbiBpc0ZpYmVyTW91bnRlZChmaWJlcikge1xuICByZXR1cm4gZ2V0TmVhcmVzdE1vdW50ZWRGaWJlcihmaWJlcikgPT09IGZpYmVyO1xufVxuZnVuY3Rpb24gaXNNb3VudGVkKGNvbXBvbmVudCkge1xuICB7XG4gICAgdmFyIG93bmVyID0gUmVhY3RDdXJyZW50T3duZXIuY3VycmVudDtcblxuICAgIGlmIChvd25lciAhPT0gbnVsbCAmJiBvd25lci50YWcgPT09IENsYXNzQ29tcG9uZW50KSB7XG4gICAgICB2YXIgb3duZXJGaWJlciA9IG93bmVyO1xuICAgICAgdmFyIGluc3RhbmNlID0gb3duZXJGaWJlci5zdGF0ZU5vZGU7XG5cbiAgICAgIGlmICghaW5zdGFuY2UuX3dhcm5lZEFib3V0UmVmc0luUmVuZGVyKSB7XG4gICAgICAgIGVycm9yKCclcyBpcyBhY2Nlc3NpbmcgaXNNb3VudGVkIGluc2lkZSBpdHMgcmVuZGVyKCkgZnVuY3Rpb24uICcgKyAncmVuZGVyKCkgc2hvdWxkIGJlIGEgcHVyZSBmdW5jdGlvbiBvZiBwcm9wcyBhbmQgc3RhdGUuIEl0IHNob3VsZCAnICsgJ25ldmVyIGFjY2VzcyBzb21ldGhpbmcgdGhhdCByZXF1aXJlcyBzdGFsZSBkYXRhIGZyb20gdGhlIHByZXZpb3VzICcgKyAncmVuZGVyLCBzdWNoIGFzIHJlZnMuIE1vdmUgdGhpcyBsb2dpYyB0byBjb21wb25lbnREaWRNb3VudCBhbmQgJyArICdjb21wb25lbnREaWRVcGRhdGUgaW5zdGVhZC4nLCBnZXRDb21wb25lbnROYW1lKG93bmVyRmliZXIudHlwZSkgfHwgJ0EgY29tcG9uZW50Jyk7XG4gICAgICB9XG5cbiAgICAgIGluc3RhbmNlLl93YXJuZWRBYm91dFJlZnNJblJlbmRlciA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgdmFyIGZpYmVyID0gZ2V0KGNvbXBvbmVudCk7XG5cbiAgaWYgKCFmaWJlcikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBnZXROZWFyZXN0TW91bnRlZEZpYmVyKGZpYmVyKSA9PT0gZmliZXI7XG59XG5cbmZ1bmN0aW9uIGFzc2VydElzTW91bnRlZChmaWJlcikge1xuICBpZiAoIShnZXROZWFyZXN0TW91bnRlZEZpYmVyKGZpYmVyKSA9PT0gZmliZXIpKSB7XG4gICAge1xuICAgICAgdGhyb3cgRXJyb3IoIFwiVW5hYmxlIHRvIGZpbmQgbm9kZSBvbiBhbiB1bm1vdW50ZWQgY29tcG9uZW50LlwiICk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGZpbmRDdXJyZW50RmliZXJVc2luZ1Nsb3dQYXRoKGZpYmVyKSB7XG4gIHZhciBhbHRlcm5hdGUgPSBmaWJlci5hbHRlcm5hdGU7XG5cbiAgaWYgKCFhbHRlcm5hdGUpIHtcbiAgICAvLyBJZiB0aGVyZSBpcyBubyBhbHRlcm5hdGUsIHRoZW4gd2Ugb25seSBuZWVkIHRvIGNoZWNrIGlmIGl0IGlzIG1vdW50ZWQuXG4gICAgdmFyIG5lYXJlc3RNb3VudGVkID0gZ2V0TmVhcmVzdE1vdW50ZWRGaWJlcihmaWJlcik7XG5cbiAgICBpZiAoIShuZWFyZXN0TW91bnRlZCAhPT0gbnVsbCkpIHtcbiAgICAgIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoIFwiVW5hYmxlIHRvIGZpbmQgbm9kZSBvbiBhbiB1bm1vdW50ZWQgY29tcG9uZW50LlwiICk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG5lYXJlc3RNb3VudGVkICE9PSBmaWJlcikge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZpYmVyO1xuICB9IC8vIElmIHdlIGhhdmUgdHdvIHBvc3NpYmxlIGJyYW5jaGVzLCB3ZSdsbCB3YWxrIGJhY2t3YXJkcyB1cCB0byB0aGUgcm9vdFxuICAvLyB0byBzZWUgd2hhdCBwYXRoIHRoZSByb290IHBvaW50cyB0by4gT24gdGhlIHdheSB3ZSBtYXkgaGl0IG9uZSBvZiB0aGVcbiAgLy8gc3BlY2lhbCBjYXNlcyBhbmQgd2UnbGwgZGVhbCB3aXRoIHRoZW0uXG5cblxuICB2YXIgYSA9IGZpYmVyO1xuICB2YXIgYiA9IGFsdGVybmF0ZTtcblxuICB3aGlsZSAodHJ1ZSkge1xuICAgIHZhciBwYXJlbnRBID0gYS5yZXR1cm47XG5cbiAgICBpZiAocGFyZW50QSA9PT0gbnVsbCkge1xuICAgICAgLy8gV2UncmUgYXQgdGhlIHJvb3QuXG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICB2YXIgcGFyZW50QiA9IHBhcmVudEEuYWx0ZXJuYXRlO1xuXG4gICAgaWYgKHBhcmVudEIgPT09IG51bGwpIHtcbiAgICAgIC8vIFRoZXJlIGlzIG5vIGFsdGVybmF0ZS4gVGhpcyBpcyBhbiB1bnVzdWFsIGNhc2UuIEN1cnJlbnRseSwgaXQgb25seVxuICAgICAgLy8gaGFwcGVucyB3aGVuIGEgU3VzcGVuc2UgY29tcG9uZW50IGlzIGhpZGRlbi4gQW4gZXh0cmEgZnJhZ21lbnQgZmliZXJcbiAgICAgIC8vIGlzIGluc2VydGVkIGluIGJldHdlZW4gdGhlIFN1c3BlbnNlIGZpYmVyIGFuZCBpdHMgY2hpbGRyZW4uIFNraXBcbiAgICAgIC8vIG92ZXIgdGhpcyBleHRyYSBmcmFnbWVudCBmaWJlciBhbmQgcHJvY2VlZCB0byB0aGUgbmV4dCBwYXJlbnQuXG4gICAgICB2YXIgbmV4dFBhcmVudCA9IHBhcmVudEEucmV0dXJuO1xuXG4gICAgICBpZiAobmV4dFBhcmVudCAhPT0gbnVsbCkge1xuICAgICAgICBhID0gYiA9IG5leHRQYXJlbnQ7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfSAvLyBJZiB0aGVyZSdzIG5vIHBhcmVudCwgd2UncmUgYXQgdGhlIHJvb3QuXG5cblxuICAgICAgYnJlYWs7XG4gICAgfSAvLyBJZiBib3RoIGNvcGllcyBvZiB0aGUgcGFyZW50IGZpYmVyIHBvaW50IHRvIHRoZSBzYW1lIGNoaWxkLCB3ZSBjYW5cbiAgICAvLyBhc3N1bWUgdGhhdCB0aGUgY2hpbGQgaXMgY3VycmVudC4gVGhpcyBoYXBwZW5zIHdoZW4gd2UgYmFpbG91dCBvbiBsb3dcbiAgICAvLyBwcmlvcml0eTogdGhlIGJhaWxlZCBvdXQgZmliZXIncyBjaGlsZCByZXVzZXMgdGhlIGN1cnJlbnQgY2hpbGQuXG5cblxuICAgIGlmIChwYXJlbnRBLmNoaWxkID09PSBwYXJlbnRCLmNoaWxkKSB7XG4gICAgICB2YXIgY2hpbGQgPSBwYXJlbnRBLmNoaWxkO1xuXG4gICAgICB3aGlsZSAoY2hpbGQpIHtcbiAgICAgICAgaWYgKGNoaWxkID09PSBhKSB7XG4gICAgICAgICAgLy8gV2UndmUgZGV0ZXJtaW5lZCB0aGF0IEEgaXMgdGhlIGN1cnJlbnQgYnJhbmNoLlxuICAgICAgICAgIGFzc2VydElzTW91bnRlZChwYXJlbnRBKTtcbiAgICAgICAgICByZXR1cm4gZmliZXI7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY2hpbGQgPT09IGIpIHtcbiAgICAgICAgICAvLyBXZSd2ZSBkZXRlcm1pbmVkIHRoYXQgQiBpcyB0aGUgY3VycmVudCBicmFuY2guXG4gICAgICAgICAgYXNzZXJ0SXNNb3VudGVkKHBhcmVudEEpO1xuICAgICAgICAgIHJldHVybiBhbHRlcm5hdGU7XG4gICAgICAgIH1cblxuICAgICAgICBjaGlsZCA9IGNoaWxkLnNpYmxpbmc7XG4gICAgICB9IC8vIFdlIHNob3VsZCBuZXZlciBoYXZlIGFuIGFsdGVybmF0ZSBmb3IgYW55IG1vdW50aW5nIG5vZGUuIFNvIHRoZSBvbmx5XG4gICAgICAvLyB3YXkgdGhpcyBjb3VsZCBwb3NzaWJseSBoYXBwZW4gaXMgaWYgdGhpcyB3YXMgdW5tb3VudGVkLCBpZiBhdCBhbGwuXG5cblxuICAgICAge1xuICAgICAgICB7XG4gICAgICAgICAgdGhyb3cgRXJyb3IoIFwiVW5hYmxlIHRvIGZpbmQgbm9kZSBvbiBhbiB1bm1vdW50ZWQgY29tcG9uZW50LlwiICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoYS5yZXR1cm4gIT09IGIucmV0dXJuKSB7XG4gICAgICAvLyBUaGUgcmV0dXJuIHBvaW50ZXIgb2YgQSBhbmQgdGhlIHJldHVybiBwb2ludGVyIG9mIEIgcG9pbnQgdG8gZGlmZmVyZW50XG4gICAgICAvLyBmaWJlcnMuIFdlIGFzc3VtZSB0aGF0IHJldHVybiBwb2ludGVycyBuZXZlciBjcmlzcy1jcm9zcywgc28gQSBtdXN0XG4gICAgICAvLyBiZWxvbmcgdG8gdGhlIGNoaWxkIHNldCBvZiBBLnJldHVybiwgYW5kIEIgbXVzdCBiZWxvbmcgdG8gdGhlIGNoaWxkXG4gICAgICAvLyBzZXQgb2YgQi5yZXR1cm4uXG4gICAgICBhID0gcGFyZW50QTtcbiAgICAgIGIgPSBwYXJlbnRCO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBUaGUgcmV0dXJuIHBvaW50ZXJzIHBvaW50IHRvIHRoZSBzYW1lIGZpYmVyLiBXZSdsbCBoYXZlIHRvIHVzZSB0aGVcbiAgICAgIC8vIGRlZmF1bHQsIHNsb3cgcGF0aDogc2NhbiB0aGUgY2hpbGQgc2V0cyBvZiBlYWNoIHBhcmVudCBhbHRlcm5hdGUgdG8gc2VlXG4gICAgICAvLyB3aGljaCBjaGlsZCBiZWxvbmdzIHRvIHdoaWNoIHNldC5cbiAgICAgIC8vXG4gICAgICAvLyBTZWFyY2ggcGFyZW50IEEncyBjaGlsZCBzZXRcbiAgICAgIHZhciBkaWRGaW5kQ2hpbGQgPSBmYWxzZTtcbiAgICAgIHZhciBfY2hpbGQgPSBwYXJlbnRBLmNoaWxkO1xuXG4gICAgICB3aGlsZSAoX2NoaWxkKSB7XG4gICAgICAgIGlmIChfY2hpbGQgPT09IGEpIHtcbiAgICAgICAgICBkaWRGaW5kQ2hpbGQgPSB0cnVlO1xuICAgICAgICAgIGEgPSBwYXJlbnRBO1xuICAgICAgICAgIGIgPSBwYXJlbnRCO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKF9jaGlsZCA9PT0gYikge1xuICAgICAgICAgIGRpZEZpbmRDaGlsZCA9IHRydWU7XG4gICAgICAgICAgYiA9IHBhcmVudEE7XG4gICAgICAgICAgYSA9IHBhcmVudEI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBfY2hpbGQgPSBfY2hpbGQuc2libGluZztcbiAgICAgIH1cblxuICAgICAgaWYgKCFkaWRGaW5kQ2hpbGQpIHtcbiAgICAgICAgLy8gU2VhcmNoIHBhcmVudCBCJ3MgY2hpbGQgc2V0XG4gICAgICAgIF9jaGlsZCA9IHBhcmVudEIuY2hpbGQ7XG5cbiAgICAgICAgd2hpbGUgKF9jaGlsZCkge1xuICAgICAgICAgIGlmIChfY2hpbGQgPT09IGEpIHtcbiAgICAgICAgICAgIGRpZEZpbmRDaGlsZCA9IHRydWU7XG4gICAgICAgICAgICBhID0gcGFyZW50QjtcbiAgICAgICAgICAgIGIgPSBwYXJlbnRBO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKF9jaGlsZCA9PT0gYikge1xuICAgICAgICAgICAgZGlkRmluZENoaWxkID0gdHJ1ZTtcbiAgICAgICAgICAgIGIgPSBwYXJlbnRCO1xuICAgICAgICAgICAgYSA9IHBhcmVudEE7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBfY2hpbGQgPSBfY2hpbGQuc2libGluZztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghZGlkRmluZENoaWxkKSB7XG4gICAgICAgICAge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoIFwiQ2hpbGQgd2FzIG5vdCBmb3VuZCBpbiBlaXRoZXIgcGFyZW50IHNldC4gVGhpcyBpbmRpY2F0ZXMgYSBidWcgaW4gUmVhY3QgcmVsYXRlZCB0byB0aGUgcmV0dXJuIHBvaW50ZXIuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCEoYS5hbHRlcm5hdGUgPT09IGIpKSB7XG4gICAgICB7XG4gICAgICAgIHRocm93IEVycm9yKCBcIlJldHVybiBmaWJlcnMgc2hvdWxkIGFsd2F5cyBiZSBlYWNoIG90aGVycycgYWx0ZXJuYXRlcy4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS5cIiApO1xuICAgICAgfVxuICAgIH1cbiAgfSAvLyBJZiB0aGUgcm9vdCBpcyBub3QgYSBob3N0IGNvbnRhaW5lciwgd2UncmUgaW4gYSBkaXNjb25uZWN0ZWQgdHJlZS4gSS5lLlxuICAvLyB1bm1vdW50ZWQuXG5cblxuICBpZiAoIShhLnRhZyA9PT0gSG9zdFJvb3QpKSB7XG4gICAge1xuICAgICAgdGhyb3cgRXJyb3IoIFwiVW5hYmxlIHRvIGZpbmQgbm9kZSBvbiBhbiB1bm1vdW50ZWQgY29tcG9uZW50LlwiICk7XG4gICAgfVxuICB9XG5cbiAgaWYgKGEuc3RhdGVOb2RlLmN1cnJlbnQgPT09IGEpIHtcbiAgICAvLyBXZSd2ZSBkZXRlcm1pbmVkIHRoYXQgQSBpcyB0aGUgY3VycmVudCBicmFuY2guXG4gICAgcmV0dXJuIGZpYmVyO1xuICB9IC8vIE90aGVyd2lzZSBCIGhhcyB0byBiZSBjdXJyZW50IGJyYW5jaC5cblxuXG4gIHJldHVybiBhbHRlcm5hdGU7XG59XG5mdW5jdGlvbiBmaW5kQ3VycmVudEhvc3RGaWJlcihwYXJlbnQpIHtcbiAgdmFyIGN1cnJlbnRQYXJlbnQgPSBmaW5kQ3VycmVudEZpYmVyVXNpbmdTbG93UGF0aChwYXJlbnQpO1xuXG4gIGlmICghY3VycmVudFBhcmVudCkge1xuICAgIHJldHVybiBudWxsO1xuICB9IC8vIE5leHQgd2UnbGwgZHJpbGwgZG93biB0aGlzIGNvbXBvbmVudCB0byBmaW5kIHRoZSBmaXJzdCBIb3N0Q29tcG9uZW50L1RleHQuXG5cblxuICB2YXIgbm9kZSA9IGN1cnJlbnRQYXJlbnQ7XG5cbiAgd2hpbGUgKHRydWUpIHtcbiAgICBpZiAobm9kZS50YWcgPT09IEhvc3RDb21wb25lbnQgfHwgbm9kZS50YWcgPT09IEhvc3RUZXh0KSB7XG4gICAgICByZXR1cm4gbm9kZTtcbiAgICB9IGVsc2UgaWYgKG5vZGUuY2hpbGQpIHtcbiAgICAgIG5vZGUuY2hpbGQucmV0dXJuID0gbm9kZTtcbiAgICAgIG5vZGUgPSBub2RlLmNoaWxkO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKG5vZGUgPT09IGN1cnJlbnRQYXJlbnQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHdoaWxlICghbm9kZS5zaWJsaW5nKSB7XG4gICAgICBpZiAoIW5vZGUucmV0dXJuIHx8IG5vZGUucmV0dXJuID09PSBjdXJyZW50UGFyZW50KSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICBub2RlID0gbm9kZS5yZXR1cm47XG4gICAgfVxuXG4gICAgbm9kZS5zaWJsaW5nLnJldHVybiA9IG5vZGUucmV0dXJuO1xuICAgIG5vZGUgPSBub2RlLnNpYmxpbmc7XG4gIH0gLy8gRmxvdyBuZWVkcyB0aGUgcmV0dXJuIG51bGwgaGVyZSwgYnV0IEVTTGludCBjb21wbGFpbnMgYWJvdXQgaXQuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnJlYWNoYWJsZVxuXG5cbiAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBmaW5kQ3VycmVudEhvc3RGaWJlcldpdGhOb1BvcnRhbHMocGFyZW50KSB7XG4gIHZhciBjdXJyZW50UGFyZW50ID0gZmluZEN1cnJlbnRGaWJlclVzaW5nU2xvd1BhdGgocGFyZW50KTtcblxuICBpZiAoIWN1cnJlbnRQYXJlbnQpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfSAvLyBOZXh0IHdlJ2xsIGRyaWxsIGRvd24gdGhpcyBjb21wb25lbnQgdG8gZmluZCB0aGUgZmlyc3QgSG9zdENvbXBvbmVudC9UZXh0LlxuXG5cbiAgdmFyIG5vZGUgPSBjdXJyZW50UGFyZW50O1xuXG4gIHdoaWxlICh0cnVlKSB7XG4gICAgaWYgKG5vZGUudGFnID09PSBIb3N0Q29tcG9uZW50IHx8IG5vZGUudGFnID09PSBIb3N0VGV4dCB8fCBlbmFibGVGdW5kYW1lbnRhbEFQSSApIHtcbiAgICAgIHJldHVybiBub2RlO1xuICAgIH0gZWxzZSBpZiAobm9kZS5jaGlsZCAmJiBub2RlLnRhZyAhPT0gSG9zdFBvcnRhbCkge1xuICAgICAgbm9kZS5jaGlsZC5yZXR1cm4gPSBub2RlO1xuICAgICAgbm9kZSA9IG5vZGUuY2hpbGQ7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpZiAobm9kZSA9PT0gY3VycmVudFBhcmVudCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgd2hpbGUgKCFub2RlLnNpYmxpbmcpIHtcbiAgICAgIGlmICghbm9kZS5yZXR1cm4gfHwgbm9kZS5yZXR1cm4gPT09IGN1cnJlbnRQYXJlbnQpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIG5vZGUgPSBub2RlLnJldHVybjtcbiAgICB9XG5cbiAgICBub2RlLnNpYmxpbmcucmV0dXJuID0gbm9kZS5yZXR1cm47XG4gICAgbm9kZSA9IG5vZGUuc2libGluZztcbiAgfSAvLyBGbG93IG5lZWRzIHRoZSByZXR1cm4gbnVsbCBoZXJlLCBidXQgRVNMaW50IGNvbXBsYWlucyBhYm91dCBpdC5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVucmVhY2hhYmxlXG5cblxuICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGRvZXNGaWJlckNvbnRhaW4ocGFyZW50RmliZXIsIGNoaWxkRmliZXIpIHtcbiAgdmFyIG5vZGUgPSBjaGlsZEZpYmVyO1xuICB2YXIgcGFyZW50RmliZXJBbHRlcm5hdGUgPSBwYXJlbnRGaWJlci5hbHRlcm5hdGU7XG5cbiAgd2hpbGUgKG5vZGUgIT09IG51bGwpIHtcbiAgICBpZiAobm9kZSA9PT0gcGFyZW50RmliZXIgfHwgbm9kZSA9PT0gcGFyZW50RmliZXJBbHRlcm5hdGUpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIG5vZGUgPSBub2RlLnJldHVybjtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxudmFyIGF0dGVtcHRVc2VyQmxvY2tpbmdIeWRyYXRpb247XG5mdW5jdGlvbiBzZXRBdHRlbXB0VXNlckJsb2NraW5nSHlkcmF0aW9uKGZuKSB7XG4gIGF0dGVtcHRVc2VyQmxvY2tpbmdIeWRyYXRpb24gPSBmbjtcbn1cbnZhciBhdHRlbXB0Q29udGludW91c0h5ZHJhdGlvbjtcbmZ1bmN0aW9uIHNldEF0dGVtcHRDb250aW51b3VzSHlkcmF0aW9uKGZuKSB7XG4gIGF0dGVtcHRDb250aW51b3VzSHlkcmF0aW9uID0gZm47XG59XG52YXIgYXR0ZW1wdEh5ZHJhdGlvbkF0Q3VycmVudFByaW9yaXR5O1xuZnVuY3Rpb24gc2V0QXR0ZW1wdEh5ZHJhdGlvbkF0Q3VycmVudFByaW9yaXR5KGZuKSB7XG4gIGF0dGVtcHRIeWRyYXRpb25BdEN1cnJlbnRQcmlvcml0eSA9IGZuO1xufVxudmFyIGF0dGVtcHRIeWRyYXRpb25BdFByaW9yaXR5O1xuZnVuY3Rpb24gc2V0QXR0ZW1wdEh5ZHJhdGlvbkF0UHJpb3JpdHkoZm4pIHtcbiAgYXR0ZW1wdEh5ZHJhdGlvbkF0UHJpb3JpdHkgPSBmbjtcbn0gLy8gVE9ETzogVXBncmFkZSB0aGlzIGRlZmluaXRpb24gb25jZSB3ZSdyZSBvbiBhIG5ld2VyIHZlcnNpb24gb2YgRmxvdyB0aGF0XG52YXIgaGFzU2NoZWR1bGVkUmVwbGF5QXR0ZW1wdCA9IGZhbHNlOyAvLyBUaGUgcXVldWUgb2YgZGlzY3JldGUgZXZlbnRzIHRvIGJlIHJlcGxheWVkLlxuXG52YXIgcXVldWVkRGlzY3JldGVFdmVudHMgPSBbXTsgLy8gSW5kaWNhdGVzIGlmIGFueSBjb250aW51b3VzIGV2ZW50IHRhcmdldHMgYXJlIG5vbi1udWxsIGZvciBlYXJseSBiYWlsb3V0LlxuLy8gaWYgdGhlIGxhc3QgdGFyZ2V0IHdhcyBkZWh5ZHJhdGVkLlxuXG52YXIgcXVldWVkRm9jdXMgPSBudWxsO1xudmFyIHF1ZXVlZERyYWcgPSBudWxsO1xudmFyIHF1ZXVlZE1vdXNlID0gbnVsbDsgLy8gRm9yIHBvaW50ZXIgZXZlbnRzIHRoZXJlIGNhbiBiZSBvbmUgbGF0ZXN0IGV2ZW50IHBlciBwb2ludGVySWQuXG5cbnZhciBxdWV1ZWRQb2ludGVycyA9IG5ldyBNYXAoKTtcbnZhciBxdWV1ZWRQb2ludGVyQ2FwdHVyZXMgPSBuZXcgTWFwKCk7IC8vIFdlIGNvdWxkIGNvbnNpZGVyIHJlcGxheWluZyBzZWxlY3Rpb25jaGFuZ2UgYW5kIHRvdWNobW92ZXMgdG9vLlxuXG52YXIgcXVldWVkRXhwbGljaXRIeWRyYXRpb25UYXJnZXRzID0gW107XG5mdW5jdGlvbiBoYXNRdWV1ZWREaXNjcmV0ZUV2ZW50cygpIHtcbiAgcmV0dXJuIHF1ZXVlZERpc2NyZXRlRXZlbnRzLmxlbmd0aCA+IDA7XG59XG52YXIgZGlzY3JldGVSZXBsYXlhYmxlRXZlbnRzID0gWydtb3VzZWRvd24nLCAnbW91c2V1cCcsICd0b3VjaGNhbmNlbCcsICd0b3VjaGVuZCcsICd0b3VjaHN0YXJ0JywgJ2F1eGNsaWNrJywgJ2RibGNsaWNrJywgJ3BvaW50ZXJjYW5jZWwnLCAncG9pbnRlcmRvd24nLCAncG9pbnRlcnVwJywgJ2RyYWdlbmQnLCAnZHJhZ3N0YXJ0JywgJ2Ryb3AnLCAnY29tcG9zaXRpb25lbmQnLCAnY29tcG9zaXRpb25zdGFydCcsICdrZXlkb3duJywgJ2tleXByZXNzJywgJ2tleXVwJywgJ2lucHV0JywgJ3RleHRJbnB1dCcsIC8vIEludGVudGlvbmFsbHkgY2FtZWxDYXNlXG4nY29weScsICdjdXQnLCAncGFzdGUnLCAnY2xpY2snLCAnY2hhbmdlJywgJ2NvbnRleHRtZW51JywgJ3Jlc2V0JywgJ3N1Ym1pdCddO1xuZnVuY3Rpb24gaXNSZXBsYXlhYmxlRGlzY3JldGVFdmVudChldmVudFR5cGUpIHtcbiAgcmV0dXJuIGRpc2NyZXRlUmVwbGF5YWJsZUV2ZW50cy5pbmRleE9mKGV2ZW50VHlwZSkgPiAtMTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlUXVldWVkUmVwbGF5YWJsZUV2ZW50KGJsb2NrZWRPbiwgZG9tRXZlbnROYW1lLCBldmVudFN5c3RlbUZsYWdzLCB0YXJnZXRDb250YWluZXIsIG5hdGl2ZUV2ZW50KSB7XG4gIHJldHVybiB7XG4gICAgYmxvY2tlZE9uOiBibG9ja2VkT24sXG4gICAgZG9tRXZlbnROYW1lOiBkb21FdmVudE5hbWUsXG4gICAgZXZlbnRTeXN0ZW1GbGFnczogZXZlbnRTeXN0ZW1GbGFncyB8IElTX1JFUExBWUVELFxuICAgIG5hdGl2ZUV2ZW50OiBuYXRpdmVFdmVudCxcbiAgICB0YXJnZXRDb250YWluZXJzOiBbdGFyZ2V0Q29udGFpbmVyXVxuICB9O1xufVxuXG5mdW5jdGlvbiBxdWV1ZURpc2NyZXRlRXZlbnQoYmxvY2tlZE9uLCBkb21FdmVudE5hbWUsIGV2ZW50U3lzdGVtRmxhZ3MsIHRhcmdldENvbnRhaW5lciwgbmF0aXZlRXZlbnQpIHtcbiAgdmFyIHF1ZXVlZEV2ZW50ID0gY3JlYXRlUXVldWVkUmVwbGF5YWJsZUV2ZW50KGJsb2NrZWRPbiwgZG9tRXZlbnROYW1lLCBldmVudFN5c3RlbUZsYWdzLCB0YXJnZXRDb250YWluZXIsIG5hdGl2ZUV2ZW50KTtcbiAgcXVldWVkRGlzY3JldGVFdmVudHMucHVzaChxdWV1ZWRFdmVudCk7XG59IC8vIFJlc2V0cyB0aGUgcmVwbGF5aW5nIGZvciB0aGlzIHR5cGUgb2YgY29udGludW91cyBldmVudCB0byBubyBldmVudC5cblxuZnVuY3Rpb24gY2xlYXJJZkNvbnRpbnVvdXNFdmVudChkb21FdmVudE5hbWUsIG5hdGl2ZUV2ZW50KSB7XG4gIHN3aXRjaCAoZG9tRXZlbnROYW1lKSB7XG4gICAgY2FzZSAnZm9jdXNpbic6XG4gICAgY2FzZSAnZm9jdXNvdXQnOlxuICAgICAgcXVldWVkRm9jdXMgPSBudWxsO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdkcmFnZW50ZXInOlxuICAgIGNhc2UgJ2RyYWdsZWF2ZSc6XG4gICAgICBxdWV1ZWREcmFnID0gbnVsbDtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnbW91c2VvdmVyJzpcbiAgICBjYXNlICdtb3VzZW91dCc6XG4gICAgICBxdWV1ZWRNb3VzZSA9IG51bGw7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ3BvaW50ZXJvdmVyJzpcbiAgICBjYXNlICdwb2ludGVyb3V0JzpcbiAgICAgIHtcbiAgICAgICAgdmFyIHBvaW50ZXJJZCA9IG5hdGl2ZUV2ZW50LnBvaW50ZXJJZDtcbiAgICAgICAgcXVldWVkUG9pbnRlcnMuZGVsZXRlKHBvaW50ZXJJZCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgY2FzZSAnZ290cG9pbnRlcmNhcHR1cmUnOlxuICAgIGNhc2UgJ2xvc3Rwb2ludGVyY2FwdHVyZSc6XG4gICAgICB7XG4gICAgICAgIHZhciBfcG9pbnRlcklkID0gbmF0aXZlRXZlbnQucG9pbnRlcklkO1xuICAgICAgICBxdWV1ZWRQb2ludGVyQ2FwdHVyZXMuZGVsZXRlKF9wb2ludGVySWQpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBhY2N1bXVsYXRlT3JDcmVhdGVDb250aW51b3VzUXVldWVkUmVwbGF5YWJsZUV2ZW50KGV4aXN0aW5nUXVldWVkRXZlbnQsIGJsb2NrZWRPbiwgZG9tRXZlbnROYW1lLCBldmVudFN5c3RlbUZsYWdzLCB0YXJnZXRDb250YWluZXIsIG5hdGl2ZUV2ZW50KSB7XG4gIGlmIChleGlzdGluZ1F1ZXVlZEV2ZW50ID09PSBudWxsIHx8IGV4aXN0aW5nUXVldWVkRXZlbnQubmF0aXZlRXZlbnQgIT09IG5hdGl2ZUV2ZW50KSB7XG4gICAgdmFyIHF1ZXVlZEV2ZW50ID0gY3JlYXRlUXVldWVkUmVwbGF5YWJsZUV2ZW50KGJsb2NrZWRPbiwgZG9tRXZlbnROYW1lLCBldmVudFN5c3RlbUZsYWdzLCB0YXJnZXRDb250YWluZXIsIG5hdGl2ZUV2ZW50KTtcblxuICAgIGlmIChibG9ja2VkT24gIT09IG51bGwpIHtcbiAgICAgIHZhciBfZmliZXIyID0gZ2V0SW5zdGFuY2VGcm9tTm9kZShibG9ja2VkT24pO1xuXG4gICAgICBpZiAoX2ZpYmVyMiAhPT0gbnVsbCkge1xuICAgICAgICAvLyBBdHRlbXB0IHRvIGluY3JlYXNlIHRoZSBwcmlvcml0eSBvZiB0aGlzIHRhcmdldC5cbiAgICAgICAgYXR0ZW1wdENvbnRpbnVvdXNIeWRyYXRpb24oX2ZpYmVyMik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHF1ZXVlZEV2ZW50O1xuICB9IC8vIElmIHdlIGhhdmUgYWxyZWFkeSBxdWV1ZWQgdGhpcyBleGFjdCBldmVudCwgdGhlbiBpdCdzIGJlY2F1c2VcbiAgLy8gdGhlIGRpZmZlcmVudCBldmVudCBzeXN0ZW1zIGhhdmUgZGlmZmVyZW50IERPTSBldmVudCBsaXN0ZW5lcnMuXG4gIC8vIFdlIGNhbiBhY2N1bXVsYXRlIHRoZSBmbGFncywgYW5kIHRoZSB0YXJnZXRDb250YWluZXJzLCBhbmRcbiAgLy8gc3RvcmUgYSBzaW5nbGUgZXZlbnQgdG8gYmUgcmVwbGF5ZWQuXG5cblxuICBleGlzdGluZ1F1ZXVlZEV2ZW50LmV2ZW50U3lzdGVtRmxhZ3MgfD0gZXZlbnRTeXN0ZW1GbGFncztcbiAgdmFyIHRhcmdldENvbnRhaW5lcnMgPSBleGlzdGluZ1F1ZXVlZEV2ZW50LnRhcmdldENvbnRhaW5lcnM7XG5cbiAgaWYgKHRhcmdldENvbnRhaW5lciAhPT0gbnVsbCAmJiB0YXJnZXRDb250YWluZXJzLmluZGV4T2YodGFyZ2V0Q29udGFpbmVyKSA9PT0gLTEpIHtcbiAgICB0YXJnZXRDb250YWluZXJzLnB1c2godGFyZ2V0Q29udGFpbmVyKTtcbiAgfVxuXG4gIHJldHVybiBleGlzdGluZ1F1ZXVlZEV2ZW50O1xufVxuXG5mdW5jdGlvbiBxdWV1ZUlmQ29udGludW91c0V2ZW50KGJsb2NrZWRPbiwgZG9tRXZlbnROYW1lLCBldmVudFN5c3RlbUZsYWdzLCB0YXJnZXRDb250YWluZXIsIG5hdGl2ZUV2ZW50KSB7XG4gIC8vIFRoZXNlIHNldCByZWxhdGVkVGFyZ2V0IHRvIG51bGwgYmVjYXVzZSB0aGUgcmVwbGF5ZWQgZXZlbnQgd2lsbCBiZSB0cmVhdGVkIGFzIGlmIHdlXG4gIC8vIG1vdmVkIGZyb20gb3V0c2lkZSB0aGUgd2luZG93IChubyB0YXJnZXQpIG9udG8gdGhlIHRhcmdldCBvbmNlIGl0IGh5ZHJhdGVzLlxuICAvLyBJbnN0ZWFkIG9mIG11dGF0aW5nIHdlIGNvdWxkIGNsb25lIHRoZSBldmVudC5cbiAgc3dpdGNoIChkb21FdmVudE5hbWUpIHtcbiAgICBjYXNlICdmb2N1c2luJzpcbiAgICAgIHtcbiAgICAgICAgdmFyIGZvY3VzRXZlbnQgPSBuYXRpdmVFdmVudDtcbiAgICAgICAgcXVldWVkRm9jdXMgPSBhY2N1bXVsYXRlT3JDcmVhdGVDb250aW51b3VzUXVldWVkUmVwbGF5YWJsZUV2ZW50KHF1ZXVlZEZvY3VzLCBibG9ja2VkT24sIGRvbUV2ZW50TmFtZSwgZXZlbnRTeXN0ZW1GbGFncywgdGFyZ2V0Q29udGFpbmVyLCBmb2N1c0V2ZW50KTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICBjYXNlICdkcmFnZW50ZXInOlxuICAgICAge1xuICAgICAgICB2YXIgZHJhZ0V2ZW50ID0gbmF0aXZlRXZlbnQ7XG4gICAgICAgIHF1ZXVlZERyYWcgPSBhY2N1bXVsYXRlT3JDcmVhdGVDb250aW51b3VzUXVldWVkUmVwbGF5YWJsZUV2ZW50KHF1ZXVlZERyYWcsIGJsb2NrZWRPbiwgZG9tRXZlbnROYW1lLCBldmVudFN5c3RlbUZsYWdzLCB0YXJnZXRDb250YWluZXIsIGRyYWdFdmVudCk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgY2FzZSAnbW91c2VvdmVyJzpcbiAgICAgIHtcbiAgICAgICAgdmFyIG1vdXNlRXZlbnQgPSBuYXRpdmVFdmVudDtcbiAgICAgICAgcXVldWVkTW91c2UgPSBhY2N1bXVsYXRlT3JDcmVhdGVDb250aW51b3VzUXVldWVkUmVwbGF5YWJsZUV2ZW50KHF1ZXVlZE1vdXNlLCBibG9ja2VkT24sIGRvbUV2ZW50TmFtZSwgZXZlbnRTeXN0ZW1GbGFncywgdGFyZ2V0Q29udGFpbmVyLCBtb3VzZUV2ZW50KTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICBjYXNlICdwb2ludGVyb3Zlcic6XG4gICAgICB7XG4gICAgICAgIHZhciBwb2ludGVyRXZlbnQgPSBuYXRpdmVFdmVudDtcbiAgICAgICAgdmFyIHBvaW50ZXJJZCA9IHBvaW50ZXJFdmVudC5wb2ludGVySWQ7XG4gICAgICAgIHF1ZXVlZFBvaW50ZXJzLnNldChwb2ludGVySWQsIGFjY3VtdWxhdGVPckNyZWF0ZUNvbnRpbnVvdXNRdWV1ZWRSZXBsYXlhYmxlRXZlbnQocXVldWVkUG9pbnRlcnMuZ2V0KHBvaW50ZXJJZCkgfHwgbnVsbCwgYmxvY2tlZE9uLCBkb21FdmVudE5hbWUsIGV2ZW50U3lzdGVtRmxhZ3MsIHRhcmdldENvbnRhaW5lciwgcG9pbnRlckV2ZW50KSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgY2FzZSAnZ290cG9pbnRlcmNhcHR1cmUnOlxuICAgICAge1xuICAgICAgICB2YXIgX3BvaW50ZXJFdmVudCA9IG5hdGl2ZUV2ZW50O1xuICAgICAgICB2YXIgX3BvaW50ZXJJZDIgPSBfcG9pbnRlckV2ZW50LnBvaW50ZXJJZDtcbiAgICAgICAgcXVldWVkUG9pbnRlckNhcHR1cmVzLnNldChfcG9pbnRlcklkMiwgYWNjdW11bGF0ZU9yQ3JlYXRlQ29udGludW91c1F1ZXVlZFJlcGxheWFibGVFdmVudChxdWV1ZWRQb2ludGVyQ2FwdHVyZXMuZ2V0KF9wb2ludGVySWQyKSB8fCBudWxsLCBibG9ja2VkT24sIGRvbUV2ZW50TmFtZSwgZXZlbnRTeXN0ZW1GbGFncywgdGFyZ2V0Q29udGFpbmVyLCBfcG9pbnRlckV2ZW50KSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufSAvLyBDaGVjayBpZiB0aGlzIHRhcmdldCBpcyB1bmJsb2NrZWQuIFJldHVybnMgdHJ1ZSBpZiBpdCdzIHVuYmxvY2tlZC5cblxuZnVuY3Rpb24gYXR0ZW1wdEV4cGxpY2l0SHlkcmF0aW9uVGFyZ2V0KHF1ZXVlZFRhcmdldCkge1xuICAvLyBUT0RPOiBUaGlzIGZ1bmN0aW9uIHNoYXJlcyBhIGxvdCBvZiBsb2dpYyB3aXRoIGF0dGVtcHRUb0Rpc3BhdGNoRXZlbnQuXG4gIC8vIFRyeSB0byB1bmlmeSB0aGVtLiBJdCdzIGEgYml0IHRyaWNreSBzaW5jZSBpdCB3b3VsZCByZXF1aXJlIHR3byByZXR1cm5cbiAgLy8gdmFsdWVzLlxuICB2YXIgdGFyZ2V0SW5zdCA9IGdldENsb3Nlc3RJbnN0YW5jZUZyb21Ob2RlKHF1ZXVlZFRhcmdldC50YXJnZXQpO1xuXG4gIGlmICh0YXJnZXRJbnN0ICE9PSBudWxsKSB7XG4gICAgdmFyIG5lYXJlc3RNb3VudGVkID0gZ2V0TmVhcmVzdE1vdW50ZWRGaWJlcih0YXJnZXRJbnN0KTtcblxuICAgIGlmIChuZWFyZXN0TW91bnRlZCAhPT0gbnVsbCkge1xuICAgICAgdmFyIHRhZyA9IG5lYXJlc3RNb3VudGVkLnRhZztcblxuICAgICAgaWYgKHRhZyA9PT0gU3VzcGVuc2VDb21wb25lbnQpIHtcbiAgICAgICAgdmFyIGluc3RhbmNlID0gZ2V0U3VzcGVuc2VJbnN0YW5jZUZyb21GaWJlcihuZWFyZXN0TW91bnRlZCk7XG5cbiAgICAgICAgaWYgKGluc3RhbmNlICE9PSBudWxsKSB7XG4gICAgICAgICAgLy8gV2UncmUgYmxvY2tlZCBvbiBoeWRyYXRpbmcgdGhpcyBib3VuZGFyeS5cbiAgICAgICAgICAvLyBJbmNyZWFzZSBpdHMgcHJpb3JpdHkuXG4gICAgICAgICAgcXVldWVkVGFyZ2V0LmJsb2NrZWRPbiA9IGluc3RhbmNlO1xuICAgICAgICAgIGF0dGVtcHRIeWRyYXRpb25BdFByaW9yaXR5KHF1ZXVlZFRhcmdldC5sYW5lUHJpb3JpdHksIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIFNjaGVkdWxlci51bnN0YWJsZV9ydW5XaXRoUHJpb3JpdHkocXVldWVkVGFyZ2V0LnByaW9yaXR5LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIGF0dGVtcHRIeWRyYXRpb25BdEN1cnJlbnRQcmlvcml0eShuZWFyZXN0TW91bnRlZCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodGFnID09PSBIb3N0Um9vdCkge1xuICAgICAgICB2YXIgcm9vdCA9IG5lYXJlc3RNb3VudGVkLnN0YXRlTm9kZTtcblxuICAgICAgICBpZiAocm9vdC5oeWRyYXRlKSB7XG4gICAgICAgICAgcXVldWVkVGFyZ2V0LmJsb2NrZWRPbiA9IGdldENvbnRhaW5lckZyb21GaWJlcihuZWFyZXN0TW91bnRlZCk7IC8vIFdlIGRvbid0IGN1cnJlbnRseSBoYXZlIGEgd2F5IHRvIGluY3JlYXNlIHRoZSBwcmlvcml0eSBvZlxuICAgICAgICAgIC8vIGEgcm9vdCBvdGhlciB0aGFuIHN5bmMuXG5cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBxdWV1ZWRUYXJnZXQuYmxvY2tlZE9uID0gbnVsbDtcbn1cblxuZnVuY3Rpb24gYXR0ZW1wdFJlcGxheUNvbnRpbnVvdXNRdWV1ZWRFdmVudChxdWV1ZWRFdmVudCkge1xuICBpZiAocXVldWVkRXZlbnQuYmxvY2tlZE9uICE9PSBudWxsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIHRhcmdldENvbnRhaW5lcnMgPSBxdWV1ZWRFdmVudC50YXJnZXRDb250YWluZXJzO1xuXG4gIHdoaWxlICh0YXJnZXRDb250YWluZXJzLmxlbmd0aCA+IDApIHtcbiAgICB2YXIgdGFyZ2V0Q29udGFpbmVyID0gdGFyZ2V0Q29udGFpbmVyc1swXTtcbiAgICB2YXIgbmV4dEJsb2NrZWRPbiA9IGF0dGVtcHRUb0Rpc3BhdGNoRXZlbnQocXVldWVkRXZlbnQuZG9tRXZlbnROYW1lLCBxdWV1ZWRFdmVudC5ldmVudFN5c3RlbUZsYWdzLCB0YXJnZXRDb250YWluZXIsIHF1ZXVlZEV2ZW50Lm5hdGl2ZUV2ZW50KTtcblxuICAgIGlmIChuZXh0QmxvY2tlZE9uICE9PSBudWxsKSB7XG4gICAgICAvLyBXZSdyZSBzdGlsbCBibG9ja2VkLiBUcnkgYWdhaW4gbGF0ZXIuXG4gICAgICB2YXIgX2ZpYmVyMyA9IGdldEluc3RhbmNlRnJvbU5vZGUobmV4dEJsb2NrZWRPbik7XG5cbiAgICAgIGlmIChfZmliZXIzICE9PSBudWxsKSB7XG4gICAgICAgIGF0dGVtcHRDb250aW51b3VzSHlkcmF0aW9uKF9maWJlcjMpO1xuICAgICAgfVxuXG4gICAgICBxdWV1ZWRFdmVudC5ibG9ja2VkT24gPSBuZXh0QmxvY2tlZE9uO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gLy8gVGhpcyB0YXJnZXQgY29udGFpbmVyIHdhcyBzdWNjZXNzZnVsbHkgZGlzcGF0Y2hlZC4gVHJ5IHRoZSBuZXh0LlxuXG5cbiAgICB0YXJnZXRDb250YWluZXJzLnNoaWZ0KCk7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gYXR0ZW1wdFJlcGxheUNvbnRpbnVvdXNRdWV1ZWRFdmVudEluTWFwKHF1ZXVlZEV2ZW50LCBrZXksIG1hcCkge1xuICBpZiAoYXR0ZW1wdFJlcGxheUNvbnRpbnVvdXNRdWV1ZWRFdmVudChxdWV1ZWRFdmVudCkpIHtcbiAgICBtYXAuZGVsZXRlKGtleSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVwbGF5VW5ibG9ja2VkRXZlbnRzKCkge1xuICBoYXNTY2hlZHVsZWRSZXBsYXlBdHRlbXB0ID0gZmFsc2U7IC8vIEZpcnN0IHJlcGxheSBkaXNjcmV0ZSBldmVudHMuXG5cbiAgd2hpbGUgKHF1ZXVlZERpc2NyZXRlRXZlbnRzLmxlbmd0aCA+IDApIHtcbiAgICB2YXIgbmV4dERpc2NyZXRlRXZlbnQgPSBxdWV1ZWREaXNjcmV0ZUV2ZW50c1swXTtcblxuICAgIGlmIChuZXh0RGlzY3JldGVFdmVudC5ibG9ja2VkT24gIT09IG51bGwpIHtcbiAgICAgIC8vIFdlJ3JlIHN0aWxsIGJsb2NrZWQuXG4gICAgICAvLyBJbmNyZWFzZSB0aGUgcHJpb3JpdHkgb2YgdGhpcyBib3VuZGFyeSB0byB1bmJsb2NrXG4gICAgICAvLyB0aGUgbmV4dCBkaXNjcmV0ZSBldmVudC5cbiAgICAgIHZhciBfZmliZXI0ID0gZ2V0SW5zdGFuY2VGcm9tTm9kZShuZXh0RGlzY3JldGVFdmVudC5ibG9ja2VkT24pO1xuXG4gICAgICBpZiAoX2ZpYmVyNCAhPT0gbnVsbCkge1xuICAgICAgICBhdHRlbXB0VXNlckJsb2NraW5nSHlkcmF0aW9uKF9maWJlcjQpO1xuICAgICAgfVxuXG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICB2YXIgdGFyZ2V0Q29udGFpbmVycyA9IG5leHREaXNjcmV0ZUV2ZW50LnRhcmdldENvbnRhaW5lcnM7XG5cbiAgICB3aGlsZSAodGFyZ2V0Q29udGFpbmVycy5sZW5ndGggPiAwKSB7XG4gICAgICB2YXIgdGFyZ2V0Q29udGFpbmVyID0gdGFyZ2V0Q29udGFpbmVyc1swXTtcbiAgICAgIHZhciBuZXh0QmxvY2tlZE9uID0gYXR0ZW1wdFRvRGlzcGF0Y2hFdmVudChuZXh0RGlzY3JldGVFdmVudC5kb21FdmVudE5hbWUsIG5leHREaXNjcmV0ZUV2ZW50LmV2ZW50U3lzdGVtRmxhZ3MsIHRhcmdldENvbnRhaW5lciwgbmV4dERpc2NyZXRlRXZlbnQubmF0aXZlRXZlbnQpO1xuXG4gICAgICBpZiAobmV4dEJsb2NrZWRPbiAhPT0gbnVsbCkge1xuICAgICAgICAvLyBXZSdyZSBzdGlsbCBibG9ja2VkLiBUcnkgYWdhaW4gbGF0ZXIuXG4gICAgICAgIG5leHREaXNjcmV0ZUV2ZW50LmJsb2NrZWRPbiA9IG5leHRCbG9ja2VkT247XG4gICAgICAgIGJyZWFrO1xuICAgICAgfSAvLyBUaGlzIHRhcmdldCBjb250YWluZXIgd2FzIHN1Y2Nlc3NmdWxseSBkaXNwYXRjaGVkLiBUcnkgdGhlIG5leHQuXG5cblxuICAgICAgdGFyZ2V0Q29udGFpbmVycy5zaGlmdCgpO1xuICAgIH1cblxuICAgIGlmIChuZXh0RGlzY3JldGVFdmVudC5ibG9ja2VkT24gPT09IG51bGwpIHtcbiAgICAgIC8vIFdlJ3ZlIHN1Y2Nlc3NmdWxseSByZXBsYXllZCB0aGUgZmlyc3QgZXZlbnQuIExldCdzIHRyeSB0aGUgbmV4dCBvbmUuXG4gICAgICBxdWV1ZWREaXNjcmV0ZUV2ZW50cy5zaGlmdCgpO1xuICAgIH1cbiAgfSAvLyBOZXh0IHJlcGxheSBhbnkgY29udGludW91cyBldmVudHMuXG5cblxuICBpZiAocXVldWVkRm9jdXMgIT09IG51bGwgJiYgYXR0ZW1wdFJlcGxheUNvbnRpbnVvdXNRdWV1ZWRFdmVudChxdWV1ZWRGb2N1cykpIHtcbiAgICBxdWV1ZWRGb2N1cyA9IG51bGw7XG4gIH1cblxuICBpZiAocXVldWVkRHJhZyAhPT0gbnVsbCAmJiBhdHRlbXB0UmVwbGF5Q29udGludW91c1F1ZXVlZEV2ZW50KHF1ZXVlZERyYWcpKSB7XG4gICAgcXVldWVkRHJhZyA9IG51bGw7XG4gIH1cblxuICBpZiAocXVldWVkTW91c2UgIT09IG51bGwgJiYgYXR0ZW1wdFJlcGxheUNvbnRpbnVvdXNRdWV1ZWRFdmVudChxdWV1ZWRNb3VzZSkpIHtcbiAgICBxdWV1ZWRNb3VzZSA9IG51bGw7XG4gIH1cblxuICBxdWV1ZWRQb2ludGVycy5mb3JFYWNoKGF0dGVtcHRSZXBsYXlDb250aW51b3VzUXVldWVkRXZlbnRJbk1hcCk7XG4gIHF1ZXVlZFBvaW50ZXJDYXB0dXJlcy5mb3JFYWNoKGF0dGVtcHRSZXBsYXlDb250aW51b3VzUXVldWVkRXZlbnRJbk1hcCk7XG59XG5cbmZ1bmN0aW9uIHNjaGVkdWxlQ2FsbGJhY2tJZlVuYmxvY2tlZChxdWV1ZWRFdmVudCwgdW5ibG9ja2VkKSB7XG4gIGlmIChxdWV1ZWRFdmVudC5ibG9ja2VkT24gPT09IHVuYmxvY2tlZCkge1xuICAgIHF1ZXVlZEV2ZW50LmJsb2NrZWRPbiA9IG51bGw7XG5cbiAgICBpZiAoIWhhc1NjaGVkdWxlZFJlcGxheUF0dGVtcHQpIHtcbiAgICAgIGhhc1NjaGVkdWxlZFJlcGxheUF0dGVtcHQgPSB0cnVlOyAvLyBTY2hlZHVsZSBhIGNhbGxiYWNrIHRvIGF0dGVtcHQgcmVwbGF5aW5nIGFzIG1hbnkgZXZlbnRzIGFzIGFyZVxuICAgICAgLy8gbm93IHVuYmxvY2tlZC4gVGhpcyBmaXJzdCBtaWdodCBub3QgYWN0dWFsbHkgYmUgdW5ibG9ja2VkIHlldC5cbiAgICAgIC8vIFdlIGNvdWxkIGNoZWNrIGl0IGVhcmx5IHRvIGF2b2lkIHNjaGVkdWxpbmcgYW4gdW5uZWNlc3NhcnkgY2FsbGJhY2suXG5cbiAgICAgIFNjaGVkdWxlci51bnN0YWJsZV9zY2hlZHVsZUNhbGxiYWNrKFNjaGVkdWxlci51bnN0YWJsZV9Ob3JtYWxQcmlvcml0eSwgcmVwbGF5VW5ibG9ja2VkRXZlbnRzKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcmV0cnlJZkJsb2NrZWRPbih1bmJsb2NrZWQpIHtcbiAgLy8gTWFyayBhbnl0aGluZyB0aGF0IHdhcyBibG9ja2VkIG9uIHRoaXMgYXMgbm8gbG9uZ2VyIGJsb2NrZWRcbiAgLy8gYW5kIGVsaWdpYmxlIGZvciBhIHJlcGxheS5cbiAgaWYgKHF1ZXVlZERpc2NyZXRlRXZlbnRzLmxlbmd0aCA+IDApIHtcbiAgICBzY2hlZHVsZUNhbGxiYWNrSWZVbmJsb2NrZWQocXVldWVkRGlzY3JldGVFdmVudHNbMF0sIHVuYmxvY2tlZCk7IC8vIFRoaXMgaXMgYSBleHBvbmVudGlhbCBzZWFyY2ggZm9yIGVhY2ggYm91bmRhcnkgdGhhdCBjb21taXRzLiBJIHRoaW5rIGl0J3NcbiAgICAvLyB3b3J0aCBpdCBiZWNhdXNlIHdlIGV4cGVjdCB2ZXJ5IGZldyBkaXNjcmV0ZSBldmVudHMgdG8gcXVldWUgdXAgYW5kIG9uY2VcbiAgICAvLyB3ZSBhcmUgYWN0dWFsbHkgZnVsbHkgdW5ibG9ja2VkIGl0IHdpbGwgYmUgZmFzdCB0byByZXBsYXkgdGhlbS5cblxuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgcXVldWVkRGlzY3JldGVFdmVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBxdWV1ZWRFdmVudCA9IHF1ZXVlZERpc2NyZXRlRXZlbnRzW2ldO1xuXG4gICAgICBpZiAocXVldWVkRXZlbnQuYmxvY2tlZE9uID09PSB1bmJsb2NrZWQpIHtcbiAgICAgICAgcXVldWVkRXZlbnQuYmxvY2tlZE9uID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAocXVldWVkRm9jdXMgIT09IG51bGwpIHtcbiAgICBzY2hlZHVsZUNhbGxiYWNrSWZVbmJsb2NrZWQocXVldWVkRm9jdXMsIHVuYmxvY2tlZCk7XG4gIH1cblxuICBpZiAocXVldWVkRHJhZyAhPT0gbnVsbCkge1xuICAgIHNjaGVkdWxlQ2FsbGJhY2tJZlVuYmxvY2tlZChxdWV1ZWREcmFnLCB1bmJsb2NrZWQpO1xuICB9XG5cbiAgaWYgKHF1ZXVlZE1vdXNlICE9PSBudWxsKSB7XG4gICAgc2NoZWR1bGVDYWxsYmFja0lmVW5ibG9ja2VkKHF1ZXVlZE1vdXNlLCB1bmJsb2NrZWQpO1xuICB9XG5cbiAgdmFyIHVuYmxvY2sgPSBmdW5jdGlvbiAocXVldWVkRXZlbnQpIHtcbiAgICByZXR1cm4gc2NoZWR1bGVDYWxsYmFja0lmVW5ibG9ja2VkKHF1ZXVlZEV2ZW50LCB1bmJsb2NrZWQpO1xuICB9O1xuXG4gIHF1ZXVlZFBvaW50ZXJzLmZvckVhY2godW5ibG9jayk7XG4gIHF1ZXVlZFBvaW50ZXJDYXB0dXJlcy5mb3JFYWNoKHVuYmxvY2spO1xuXG4gIGZvciAodmFyIF9pID0gMDsgX2kgPCBxdWV1ZWRFeHBsaWNpdEh5ZHJhdGlvblRhcmdldHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgdmFyIHF1ZXVlZFRhcmdldCA9IHF1ZXVlZEV4cGxpY2l0SHlkcmF0aW9uVGFyZ2V0c1tfaV07XG5cbiAgICBpZiAocXVldWVkVGFyZ2V0LmJsb2NrZWRPbiA9PT0gdW5ibG9ja2VkKSB7XG4gICAgICBxdWV1ZWRUYXJnZXQuYmxvY2tlZE9uID0gbnVsbDtcbiAgICB9XG4gIH1cblxuICB3aGlsZSAocXVldWVkRXhwbGljaXRIeWRyYXRpb25UYXJnZXRzLmxlbmd0aCA+IDApIHtcbiAgICB2YXIgbmV4dEV4cGxpY2l0VGFyZ2V0ID0gcXVldWVkRXhwbGljaXRIeWRyYXRpb25UYXJnZXRzWzBdO1xuXG4gICAgaWYgKG5leHRFeHBsaWNpdFRhcmdldC5ibG9ja2VkT24gIT09IG51bGwpIHtcbiAgICAgIC8vIFdlJ3JlIHN0aWxsIGJsb2NrZWQuXG4gICAgICBicmVhaztcbiAgICB9IGVsc2Uge1xuICAgICAgYXR0ZW1wdEV4cGxpY2l0SHlkcmF0aW9uVGFyZ2V0KG5leHRFeHBsaWNpdFRhcmdldCk7XG5cbiAgICAgIGlmIChuZXh0RXhwbGljaXRUYXJnZXQuYmxvY2tlZE9uID09PSBudWxsKSB7XG4gICAgICAgIC8vIFdlJ3JlIHVuYmxvY2tlZC5cbiAgICAgICAgcXVldWVkRXhwbGljaXRIeWRyYXRpb25UYXJnZXRzLnNoaWZ0KCk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbnZhciBEaXNjcmV0ZUV2ZW50ID0gMDtcbnZhciBVc2VyQmxvY2tpbmdFdmVudCA9IDE7XG52YXIgQ29udGludW91c0V2ZW50ID0gMjtcblxuLyoqXG4gKiBHZW5lcmF0ZSBhIG1hcHBpbmcgb2Ygc3RhbmRhcmQgdmVuZG9yIHByZWZpeGVzIHVzaW5nIHRoZSBkZWZpbmVkIHN0eWxlIHByb3BlcnR5IGFuZCBldmVudCBuYW1lLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHlsZVByb3BcbiAqIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWVcbiAqIEByZXR1cm5zIHtvYmplY3R9XG4gKi9cblxuZnVuY3Rpb24gbWFrZVByZWZpeE1hcChzdHlsZVByb3AsIGV2ZW50TmFtZSkge1xuICB2YXIgcHJlZml4ZXMgPSB7fTtcbiAgcHJlZml4ZXNbc3R5bGVQcm9wLnRvTG93ZXJDYXNlKCldID0gZXZlbnROYW1lLnRvTG93ZXJDYXNlKCk7XG4gIHByZWZpeGVzWydXZWJraXQnICsgc3R5bGVQcm9wXSA9ICd3ZWJraXQnICsgZXZlbnROYW1lO1xuICBwcmVmaXhlc1snTW96JyArIHN0eWxlUHJvcF0gPSAnbW96JyArIGV2ZW50TmFtZTtcbiAgcmV0dXJuIHByZWZpeGVzO1xufVxuLyoqXG4gKiBBIGxpc3Qgb2YgZXZlbnQgbmFtZXMgdG8gYSBjb25maWd1cmFibGUgbGlzdCBvZiB2ZW5kb3IgcHJlZml4ZXMuXG4gKi9cblxuXG52YXIgdmVuZG9yUHJlZml4ZXMgPSB7XG4gIGFuaW1hdGlvbmVuZDogbWFrZVByZWZpeE1hcCgnQW5pbWF0aW9uJywgJ0FuaW1hdGlvbkVuZCcpLFxuICBhbmltYXRpb25pdGVyYXRpb246IG1ha2VQcmVmaXhNYXAoJ0FuaW1hdGlvbicsICdBbmltYXRpb25JdGVyYXRpb24nKSxcbiAgYW5pbWF0aW9uc3RhcnQ6IG1ha2VQcmVmaXhNYXAoJ0FuaW1hdGlvbicsICdBbmltYXRpb25TdGFydCcpLFxuICB0cmFuc2l0aW9uZW5kOiBtYWtlUHJlZml4TWFwKCdUcmFuc2l0aW9uJywgJ1RyYW5zaXRpb25FbmQnKVxufTtcbi8qKlxuICogRXZlbnQgbmFtZXMgdGhhdCBoYXZlIGFscmVhZHkgYmVlbiBkZXRlY3RlZCBhbmQgcHJlZml4ZWQgKGlmIGFwcGxpY2FibGUpLlxuICovXG5cbnZhciBwcmVmaXhlZEV2ZW50TmFtZXMgPSB7fTtcbi8qKlxuICogRWxlbWVudCB0byBjaGVjayBmb3IgcHJlZml4ZXMgb24uXG4gKi9cblxudmFyIHN0eWxlID0ge307XG4vKipcbiAqIEJvb3RzdHJhcCBpZiBhIERPTSBleGlzdHMuXG4gKi9cblxuaWYgKGNhblVzZURPTSkge1xuICBzdHlsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpLnN0eWxlOyAvLyBPbiBzb21lIHBsYXRmb3JtcywgaW4gcGFydGljdWxhciBzb21lIHJlbGVhc2VzIG9mIEFuZHJvaWQgNC54LFxuICAvLyB0aGUgdW4tcHJlZml4ZWQgXCJhbmltYXRpb25cIiBhbmQgXCJ0cmFuc2l0aW9uXCIgcHJvcGVydGllcyBhcmUgZGVmaW5lZCBvbiB0aGVcbiAgLy8gc3R5bGUgb2JqZWN0IGJ1dCB0aGUgZXZlbnRzIHRoYXQgZmlyZSB3aWxsIHN0aWxsIGJlIHByZWZpeGVkLCBzbyB3ZSBuZWVkXG4gIC8vIHRvIGNoZWNrIGlmIHRoZSB1bi1wcmVmaXhlZCBldmVudHMgYXJlIHVzYWJsZSwgYW5kIGlmIG5vdCByZW1vdmUgdGhlbSBmcm9tIHRoZSBtYXAuXG5cbiAgaWYgKCEoJ0FuaW1hdGlvbkV2ZW50JyBpbiB3aW5kb3cpKSB7XG4gICAgZGVsZXRlIHZlbmRvclByZWZpeGVzLmFuaW1hdGlvbmVuZC5hbmltYXRpb247XG4gICAgZGVsZXRlIHZlbmRvclByZWZpeGVzLmFuaW1hdGlvbml0ZXJhdGlvbi5hbmltYXRpb247XG4gICAgZGVsZXRlIHZlbmRvclByZWZpeGVzLmFuaW1hdGlvbnN0YXJ0LmFuaW1hdGlvbjtcbiAgfSAvLyBTYW1lIGFzIGFib3ZlXG5cblxuICBpZiAoISgnVHJhbnNpdGlvbkV2ZW50JyBpbiB3aW5kb3cpKSB7XG4gICAgZGVsZXRlIHZlbmRvclByZWZpeGVzLnRyYW5zaXRpb25lbmQudHJhbnNpdGlvbjtcbiAgfVxufVxuLyoqXG4gKiBBdHRlbXB0cyB0byBkZXRlcm1pbmUgdGhlIGNvcnJlY3QgdmVuZG9yIHByZWZpeGVkIGV2ZW50IG5hbWUuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50TmFtZVxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuXG5cbmZ1bmN0aW9uIGdldFZlbmRvclByZWZpeGVkRXZlbnROYW1lKGV2ZW50TmFtZSkge1xuICBpZiAocHJlZml4ZWRFdmVudE5hbWVzW2V2ZW50TmFtZV0pIHtcbiAgICByZXR1cm4gcHJlZml4ZWRFdmVudE5hbWVzW2V2ZW50TmFtZV07XG4gIH0gZWxzZSBpZiAoIXZlbmRvclByZWZpeGVzW2V2ZW50TmFtZV0pIHtcbiAgICByZXR1cm4gZXZlbnROYW1lO1xuICB9XG5cbiAgdmFyIHByZWZpeE1hcCA9IHZlbmRvclByZWZpeGVzW2V2ZW50TmFtZV07XG5cbiAgZm9yICh2YXIgc3R5bGVQcm9wIGluIHByZWZpeE1hcCkge1xuICAgIGlmIChwcmVmaXhNYXAuaGFzT3duUHJvcGVydHkoc3R5bGVQcm9wKSAmJiBzdHlsZVByb3AgaW4gc3R5bGUpIHtcbiAgICAgIHJldHVybiBwcmVmaXhlZEV2ZW50TmFtZXNbZXZlbnROYW1lXSA9IHByZWZpeE1hcFtzdHlsZVByb3BdO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBldmVudE5hbWU7XG59XG5cbnZhciBBTklNQVRJT05fRU5EID0gZ2V0VmVuZG9yUHJlZml4ZWRFdmVudE5hbWUoJ2FuaW1hdGlvbmVuZCcpO1xudmFyIEFOSU1BVElPTl9JVEVSQVRJT04gPSBnZXRWZW5kb3JQcmVmaXhlZEV2ZW50TmFtZSgnYW5pbWF0aW9uaXRlcmF0aW9uJyk7XG52YXIgQU5JTUFUSU9OX1NUQVJUID0gZ2V0VmVuZG9yUHJlZml4ZWRFdmVudE5hbWUoJ2FuaW1hdGlvbnN0YXJ0Jyk7XG52YXIgVFJBTlNJVElPTl9FTkQgPSBnZXRWZW5kb3JQcmVmaXhlZEV2ZW50TmFtZSgndHJhbnNpdGlvbmVuZCcpO1xuXG52YXIgdG9wTGV2ZWxFdmVudHNUb1JlYWN0TmFtZXMgPSBuZXcgTWFwKCk7XG52YXIgZXZlbnRQcmlvcml0aWVzID0gbmV3IE1hcCgpOyAvLyBXZSBzdG9yZSBtb3N0IG9mIHRoZSBldmVudHMgaW4gdGhpcyBtb2R1bGUgaW4gcGFpcnMgb2YgdHdvIHN0cmluZ3Mgc28gd2UgY2FuIHJlLXVzZVxuLy8gdGhlIGNvZGUgcmVxdWlyZWQgdG8gYXBwbHkgdGhlIHNhbWUgbG9naWMgZm9yIGV2ZW50IHByaW9yaXRpemF0aW9uIGFuZCB0aGF0IG9mIHRoZVxuLy8gU2ltcGxlRXZlbnRQbHVnaW4uIFRoaXMgY29tcGxpY2F0ZXMgdGhpbmdzIHNsaWdodGx5LCBidXQgdGhlIGFpbSBpcyB0byByZWR1Y2UgY29kZVxuLy8gZHVwbGljYXRpb24gKGZvciB3aGljaCB0aGVyZSB3b3VsZCBiZSBxdWl0ZSBhIGJpdCkuIEZvciB0aGUgZXZlbnRzIHRoYXQgYXJlIG5vdCBuZWVkZWRcbi8vIGZvciB0aGUgU2ltcGxlRXZlbnRQbHVnaW4gKG90aGVyRGlzY3JldGVFdmVudHMpIHdlIHByb2Nlc3MgdGhlbSBzZXBhcmF0ZWx5IGFzIGFuXG4vLyBhcnJheSBvZiB0b3AgbGV2ZWwgZXZlbnRzLlxuLy8gTGFzdGx5LCB3ZSBpZ25vcmUgcHJldHRpZXIgc28gd2UgY2FuIGtlZXAgdGhlIGZvcm1hdHRpbmcgc2FuZS5cbi8vIHByZXR0aWVyLWlnbm9yZVxuXG52YXIgZGlzY3JldGVFdmVudFBhaXJzRm9yU2ltcGxlRXZlbnRQbHVnaW4gPSBbJ2NhbmNlbCcsICdjYW5jZWwnLCAnY2xpY2snLCAnY2xpY2snLCAnY2xvc2UnLCAnY2xvc2UnLCAnY29udGV4dG1lbnUnLCAnY29udGV4dE1lbnUnLCAnY29weScsICdjb3B5JywgJ2N1dCcsICdjdXQnLCAnYXV4Y2xpY2snLCAnYXV4Q2xpY2snLCAnZGJsY2xpY2snLCAnZG91YmxlQ2xpY2snLCAvLyBDYXJlZnVsIVxuJ2RyYWdlbmQnLCAnZHJhZ0VuZCcsICdkcmFnc3RhcnQnLCAnZHJhZ1N0YXJ0JywgJ2Ryb3AnLCAnZHJvcCcsICdmb2N1c2luJywgJ2ZvY3VzJywgLy8gQ2FyZWZ1bCFcbidmb2N1c291dCcsICdibHVyJywgLy8gQ2FyZWZ1bCFcbidpbnB1dCcsICdpbnB1dCcsICdpbnZhbGlkJywgJ2ludmFsaWQnLCAna2V5ZG93bicsICdrZXlEb3duJywgJ2tleXByZXNzJywgJ2tleVByZXNzJywgJ2tleXVwJywgJ2tleVVwJywgJ21vdXNlZG93bicsICdtb3VzZURvd24nLCAnbW91c2V1cCcsICdtb3VzZVVwJywgJ3Bhc3RlJywgJ3Bhc3RlJywgJ3BhdXNlJywgJ3BhdXNlJywgJ3BsYXknLCAncGxheScsICdwb2ludGVyY2FuY2VsJywgJ3BvaW50ZXJDYW5jZWwnLCAncG9pbnRlcmRvd24nLCAncG9pbnRlckRvd24nLCAncG9pbnRlcnVwJywgJ3BvaW50ZXJVcCcsICdyYXRlY2hhbmdlJywgJ3JhdGVDaGFuZ2UnLCAncmVzZXQnLCAncmVzZXQnLCAnc2Vla2VkJywgJ3NlZWtlZCcsICdzdWJtaXQnLCAnc3VibWl0JywgJ3RvdWNoY2FuY2VsJywgJ3RvdWNoQ2FuY2VsJywgJ3RvdWNoZW5kJywgJ3RvdWNoRW5kJywgJ3RvdWNoc3RhcnQnLCAndG91Y2hTdGFydCcsICd2b2x1bWVjaGFuZ2UnLCAndm9sdW1lQ2hhbmdlJ107XG52YXIgb3RoZXJEaXNjcmV0ZUV2ZW50cyA9IFsnY2hhbmdlJywgJ3NlbGVjdGlvbmNoYW5nZScsICd0ZXh0SW5wdXQnLCAnY29tcG9zaXRpb25zdGFydCcsICdjb21wb3NpdGlvbmVuZCcsICdjb21wb3NpdGlvbnVwZGF0ZSddO1xuXG5cbnZhciB1c2VyQmxvY2tpbmdQYWlyc0ZvclNpbXBsZUV2ZW50UGx1Z2luID0gWydkcmFnJywgJ2RyYWcnLCAnZHJhZ2VudGVyJywgJ2RyYWdFbnRlcicsICdkcmFnZXhpdCcsICdkcmFnRXhpdCcsICdkcmFnbGVhdmUnLCAnZHJhZ0xlYXZlJywgJ2RyYWdvdmVyJywgJ2RyYWdPdmVyJywgJ21vdXNlbW92ZScsICdtb3VzZU1vdmUnLCAnbW91c2VvdXQnLCAnbW91c2VPdXQnLCAnbW91c2VvdmVyJywgJ21vdXNlT3ZlcicsICdwb2ludGVybW92ZScsICdwb2ludGVyTW92ZScsICdwb2ludGVyb3V0JywgJ3BvaW50ZXJPdXQnLCAncG9pbnRlcm92ZXInLCAncG9pbnRlck92ZXInLCAnc2Nyb2xsJywgJ3Njcm9sbCcsICd0b2dnbGUnLCAndG9nZ2xlJywgJ3RvdWNobW92ZScsICd0b3VjaE1vdmUnLCAnd2hlZWwnLCAnd2hlZWwnXTsgLy8gcHJldHRpZXItaWdub3JlXG5cbnZhciBjb250aW51b3VzUGFpcnNGb3JTaW1wbGVFdmVudFBsdWdpbiA9IFsnYWJvcnQnLCAnYWJvcnQnLCBBTklNQVRJT05fRU5ELCAnYW5pbWF0aW9uRW5kJywgQU5JTUFUSU9OX0lURVJBVElPTiwgJ2FuaW1hdGlvbkl0ZXJhdGlvbicsIEFOSU1BVElPTl9TVEFSVCwgJ2FuaW1hdGlvblN0YXJ0JywgJ2NhbnBsYXknLCAnY2FuUGxheScsICdjYW5wbGF5dGhyb3VnaCcsICdjYW5QbGF5VGhyb3VnaCcsICdkdXJhdGlvbmNoYW5nZScsICdkdXJhdGlvbkNoYW5nZScsICdlbXB0aWVkJywgJ2VtcHRpZWQnLCAnZW5jcnlwdGVkJywgJ2VuY3J5cHRlZCcsICdlbmRlZCcsICdlbmRlZCcsICdlcnJvcicsICdlcnJvcicsICdnb3Rwb2ludGVyY2FwdHVyZScsICdnb3RQb2ludGVyQ2FwdHVyZScsICdsb2FkJywgJ2xvYWQnLCAnbG9hZGVkZGF0YScsICdsb2FkZWREYXRhJywgJ2xvYWRlZG1ldGFkYXRhJywgJ2xvYWRlZE1ldGFkYXRhJywgJ2xvYWRzdGFydCcsICdsb2FkU3RhcnQnLCAnbG9zdHBvaW50ZXJjYXB0dXJlJywgJ2xvc3RQb2ludGVyQ2FwdHVyZScsICdwbGF5aW5nJywgJ3BsYXlpbmcnLCAncHJvZ3Jlc3MnLCAncHJvZ3Jlc3MnLCAnc2Vla2luZycsICdzZWVraW5nJywgJ3N0YWxsZWQnLCAnc3RhbGxlZCcsICdzdXNwZW5kJywgJ3N1c3BlbmQnLCAndGltZXVwZGF0ZScsICd0aW1lVXBkYXRlJywgVFJBTlNJVElPTl9FTkQsICd0cmFuc2l0aW9uRW5kJywgJ3dhaXRpbmcnLCAnd2FpdGluZyddO1xuLyoqXG4gKiBUdXJuc1xuICogWydhYm9ydCcsIC4uLl1cbiAqXG4gKiBpbnRvXG4gKlxuICogdG9wTGV2ZWxFdmVudHNUb1JlYWN0TmFtZXMgPSBuZXcgTWFwKFtcbiAqICAgWydhYm9ydCcsICdvbkFib3J0J10sXG4gKiBdKTtcbiAqXG4gKiBhbmQgcmVnaXN0ZXJzIHRoZW0uXG4gKi9cblxuZnVuY3Rpb24gcmVnaXN0ZXJTaW1wbGVQbHVnaW5FdmVudHNBbmRTZXRUaGVpclByaW9yaXRpZXMoZXZlbnRUeXBlcywgcHJpb3JpdHkpIHtcbiAgLy8gQXMgdGhlIGV2ZW50IHR5cGVzIGFyZSBpbiBwYWlycyBvZiB0d28sIHdlIG5lZWQgdG8gaXRlcmF0ZVxuICAvLyB0aHJvdWdoIGluIHR3b3MuIFRoZSBldmVudHMgYXJlIGluIHBhaXJzIG9mIHR3byB0byBzYXZlIGNvZGVcbiAgLy8gYW5kIGltcHJvdmUgaW5pdCBwZXJmIG9mIHByb2Nlc3NpbmcgdGhpcyBhcnJheSwgYXMgaXQgd2lsbFxuICAvLyByZXN1bHQgaW4gZmFyIGZld2VyIG9iamVjdCBhbGxvY2F0aW9ucyBhbmQgcHJvcGVydHkgYWNjZXNzZXNcbiAgLy8gaWYgd2Ugb25seSB1c2UgdGhyZWUgYXJyYXlzIHRvIHByb2Nlc3MgYWxsIHRoZSBjYXRlZ29yaWVzIG9mXG4gIC8vIGluc3RlYWQgb2YgdHVwbGVzLlxuICBmb3IgKHZhciBpID0gMDsgaSA8IGV2ZW50VHlwZXMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICB2YXIgdG9wRXZlbnQgPSBldmVudFR5cGVzW2ldO1xuICAgIHZhciBldmVudCA9IGV2ZW50VHlwZXNbaSArIDFdO1xuICAgIHZhciBjYXBpdGFsaXplZEV2ZW50ID0gZXZlbnRbMF0udG9VcHBlckNhc2UoKSArIGV2ZW50LnNsaWNlKDEpO1xuICAgIHZhciByZWFjdE5hbWUgPSAnb24nICsgY2FwaXRhbGl6ZWRFdmVudDtcbiAgICBldmVudFByaW9yaXRpZXMuc2V0KHRvcEV2ZW50LCBwcmlvcml0eSk7XG4gICAgdG9wTGV2ZWxFdmVudHNUb1JlYWN0TmFtZXMuc2V0KHRvcEV2ZW50LCByZWFjdE5hbWUpO1xuICAgIHJlZ2lzdGVyVHdvUGhhc2VFdmVudChyZWFjdE5hbWUsIFt0b3BFdmVudF0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIHNldEV2ZW50UHJpb3JpdGllcyhldmVudFR5cGVzLCBwcmlvcml0eSkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGV2ZW50VHlwZXMubGVuZ3RoOyBpKyspIHtcbiAgICBldmVudFByaW9yaXRpZXMuc2V0KGV2ZW50VHlwZXNbaV0sIHByaW9yaXR5KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRFdmVudFByaW9yaXR5Rm9yUGx1Z2luU3lzdGVtKGRvbUV2ZW50TmFtZSkge1xuICB2YXIgcHJpb3JpdHkgPSBldmVudFByaW9yaXRpZXMuZ2V0KGRvbUV2ZW50TmFtZSk7IC8vIERlZmF1bHQgdG8gYSBDb250aW51b3VzRXZlbnQuIE5vdGU6IHdlIG1pZ2h0XG4gIC8vIHdhbnQgdG8gd2FybiBpZiB3ZSBjYW4ndCBkZXRlY3QgdGhlIHByaW9yaXR5XG4gIC8vIGZvciB0aGUgZXZlbnQuXG5cbiAgcmV0dXJuIHByaW9yaXR5ID09PSB1bmRlZmluZWQgPyBDb250aW51b3VzRXZlbnQgOiBwcmlvcml0eTtcbn1cbmZ1bmN0aW9uIHJlZ2lzdGVyU2ltcGxlRXZlbnRzKCkge1xuICByZWdpc3RlclNpbXBsZVBsdWdpbkV2ZW50c0FuZFNldFRoZWlyUHJpb3JpdGllcyhkaXNjcmV0ZUV2ZW50UGFpcnNGb3JTaW1wbGVFdmVudFBsdWdpbiwgRGlzY3JldGVFdmVudCk7XG4gIHJlZ2lzdGVyU2ltcGxlUGx1Z2luRXZlbnRzQW5kU2V0VGhlaXJQcmlvcml0aWVzKHVzZXJCbG9ja2luZ1BhaXJzRm9yU2ltcGxlRXZlbnRQbHVnaW4sIFVzZXJCbG9ja2luZ0V2ZW50KTtcbiAgcmVnaXN0ZXJTaW1wbGVQbHVnaW5FdmVudHNBbmRTZXRUaGVpclByaW9yaXRpZXMoY29udGludW91c1BhaXJzRm9yU2ltcGxlRXZlbnRQbHVnaW4sIENvbnRpbnVvdXNFdmVudCk7XG4gIHNldEV2ZW50UHJpb3JpdGllcyhvdGhlckRpc2NyZXRlRXZlbnRzLCBEaXNjcmV0ZUV2ZW50KTtcbn1cblxudmFyIFNjaGVkdWxlcl9ub3cgPSBTY2hlZHVsZXIudW5zdGFibGVfbm93O1xuXG57XG4gIC8vIFByb3ZpZGUgZXhwbGljaXQgZXJyb3IgbWVzc2FnZSB3aGVuIHByb2R1Y3Rpb24rcHJvZmlsaW5nIGJ1bmRsZSBvZiBlLmcuXG4gIC8vIHJlYWN0LWRvbSBpcyB1c2VkIHdpdGggcHJvZHVjdGlvbiAobm9uLXByb2ZpbGluZykgYnVuZGxlIG9mXG4gIC8vIHNjaGVkdWxlci90cmFjaW5nXG4gIGlmICghKHRyYWNpbmcuX19pbnRlcmFjdGlvbnNSZWYgIT0gbnVsbCAmJiB0cmFjaW5nLl9faW50ZXJhY3Rpb25zUmVmLmN1cnJlbnQgIT0gbnVsbCkpIHtcbiAgICB7XG4gICAgICB0aHJvdyBFcnJvciggXCJJdCBpcyBub3Qgc3VwcG9ydGVkIHRvIHJ1biB0aGUgcHJvZmlsaW5nIHZlcnNpb24gb2YgYSByZW5kZXJlciAoZm9yIGV4YW1wbGUsIGByZWFjdC1kb20vcHJvZmlsaW5nYCkgd2l0aG91dCBhbHNvIHJlcGxhY2luZyB0aGUgYHNjaGVkdWxlci90cmFjaW5nYCBtb2R1bGUgd2l0aCBgc2NoZWR1bGVyL3RyYWNpbmctcHJvZmlsaW5nYC4gWW91ciBidW5kbGVyIG1pZ2h0IGhhdmUgYSBzZXR0aW5nIGZvciBhbGlhc2luZyBib3RoIG1vZHVsZXMuIExlYXJuIG1vcmUgYXQgaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3Byb2ZpbGluZ1wiICk7XG4gICAgfVxuICB9XG59XG4vLyBhc2NlbmRpbmcgbnVtYmVycyBzbyB3ZSBjYW4gY29tcGFyZSB0aGVtIGxpa2UgbnVtYmVycy4gVGhleSBzdGFydCBhdCA5MCB0b1xuLy8gYXZvaWQgY2xhc2hpbmcgd2l0aCBTY2hlZHVsZXIncyBwcmlvcml0aWVzLlxuXG52YXIgSW1tZWRpYXRlUHJpb3JpdHkgPSA5OTtcbnZhciBVc2VyQmxvY2tpbmdQcmlvcml0eSA9IDk4O1xudmFyIE5vcm1hbFByaW9yaXR5ID0gOTc7XG52YXIgTG93UHJpb3JpdHkgPSA5NjtcbnZhciBJZGxlUHJpb3JpdHkgPSA5NTsgLy8gTm9Qcmlvcml0eSBpcyB0aGUgYWJzZW5jZSBvZiBwcmlvcml0eS4gQWxzbyBSZWFjdC1vbmx5LlxuXG52YXIgTm9Qcmlvcml0eSA9IDkwO1xudmFyIGluaXRpYWxUaW1lTXMgPSBTY2hlZHVsZXJfbm93KCk7IC8vIElmIHRoZSBpbml0aWFsIHRpbWVzdGFtcCBpcyByZWFzb25hYmx5IHNtYWxsLCB1c2UgU2NoZWR1bGVyJ3MgYG5vd2AgZGlyZWN0bHkuXG5cbnZhciBTeW5jTGFuZVByaW9yaXR5ID0gMTU7XG52YXIgU3luY0JhdGNoZWRMYW5lUHJpb3JpdHkgPSAxNDtcbnZhciBJbnB1dERpc2NyZXRlSHlkcmF0aW9uTGFuZVByaW9yaXR5ID0gMTM7XG52YXIgSW5wdXREaXNjcmV0ZUxhbmVQcmlvcml0eSA9IDEyO1xudmFyIElucHV0Q29udGludW91c0h5ZHJhdGlvbkxhbmVQcmlvcml0eSA9IDExO1xudmFyIElucHV0Q29udGludW91c0xhbmVQcmlvcml0eSA9IDEwO1xudmFyIERlZmF1bHRIeWRyYXRpb25MYW5lUHJpb3JpdHkgPSA5O1xudmFyIERlZmF1bHRMYW5lUHJpb3JpdHkgPSA4O1xudmFyIFRyYW5zaXRpb25IeWRyYXRpb25Qcmlvcml0eSA9IDc7XG52YXIgVHJhbnNpdGlvblByaW9yaXR5ID0gNjtcbnZhciBSZXRyeUxhbmVQcmlvcml0eSA9IDU7XG52YXIgU2VsZWN0aXZlSHlkcmF0aW9uTGFuZVByaW9yaXR5ID0gNDtcbnZhciBJZGxlSHlkcmF0aW9uTGFuZVByaW9yaXR5ID0gMztcbnZhciBJZGxlTGFuZVByaW9yaXR5ID0gMjtcbnZhciBPZmZzY3JlZW5MYW5lUHJpb3JpdHkgPSAxO1xudmFyIE5vTGFuZVByaW9yaXR5ID0gMDtcbnZhciBUb3RhbExhbmVzID0gMzE7XG52YXIgTm9MYW5lcyA9XG4vKiAgICAgICAgICAgICAgICAgICAgICAgICovXG4wO1xudmFyIE5vTGFuZSA9XG4vKiAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cbjA7XG52YXIgU3luY0xhbmUgPVxuLyogICAgICAgICAgICAgICAgICAgICAgICAqL1xuMTtcbnZhciBTeW5jQmF0Y2hlZExhbmUgPVxuLyogICAgICAgICAgICAgICAgICovXG4yO1xudmFyIElucHV0RGlzY3JldGVIeWRyYXRpb25MYW5lID1cbi8qICAgICAgKi9cbjQ7XG52YXIgSW5wdXREaXNjcmV0ZUxhbmVzID1cbi8qICAgICAgICAgICAgICAgICAgICAqL1xuMjQ7XG52YXIgSW5wdXRDb250aW51b3VzSHlkcmF0aW9uTGFuZSA9XG4vKiAgICAgICAgICAgKi9cbjMyO1xudmFyIElucHV0Q29udGludW91c0xhbmVzID1cbi8qICAgICAgICAgICAgICAgICAgKi9cbjE5MjtcbnZhciBEZWZhdWx0SHlkcmF0aW9uTGFuZSA9XG4vKiAgICAgICAgICAgICovXG4yNTY7XG52YXIgRGVmYXVsdExhbmVzID1cbi8qICAgICAgICAgICAgICAgICAgICovXG4zNTg0O1xudmFyIFRyYW5zaXRpb25IeWRyYXRpb25MYW5lID1cbi8qICAgICAgICAgICAgICAgICovXG40MDk2O1xudmFyIFRyYW5zaXRpb25MYW5lcyA9XG4vKiAgICAgICAgICAgICAgICAgICAgICAgKi9cbjQxODYxMTI7XG52YXIgUmV0cnlMYW5lcyA9XG4vKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuNjI5MTQ1NjA7XG52YXIgU29tZVJldHJ5TGFuZSA9XG4vKiAgICAgICAgICAgICAgICAgICovXG4zMzU1NDQzMjtcbnZhciBTZWxlY3RpdmVIeWRyYXRpb25MYW5lID1cbi8qICAgICAgICAgICovXG42NzEwODg2NDtcbnZhciBOb25JZGxlTGFuZXMgPVxuLyogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuMTM0MjE3NzI3O1xudmFyIElkbGVIeWRyYXRpb25MYW5lID1cbi8qICAgICAgICAgICAgICAgKi9cbjEzNDIxNzcyODtcbnZhciBJZGxlTGFuZXMgPVxuLyogICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG44MDUzMDYzNjg7XG52YXIgT2Zmc2NyZWVuTGFuZSA9XG4vKiAgICAgICAgICAgICAgICAgICAqL1xuMTA3Mzc0MTgyNDtcbnZhciBOb1RpbWVzdGFtcCA9IC0xO1xuZnVuY3Rpb24gc2V0Q3VycmVudFVwZGF0ZUxhbmVQcmlvcml0eShuZXdMYW5lUHJpb3JpdHkpIHtcbn0gLy8gXCJSZWdpc3RlcnNcIiB1c2VkIHRvIFwicmV0dXJuXCIgbXVsdGlwbGUgdmFsdWVzXG4vLyBVc2VkIGJ5IGdldEhpZ2hlc3RQcmlvcml0eUxhbmVzIGFuZCBnZXROZXh0TGFuZXM6XG5cbnZhciByZXR1cm5faGlnaGVzdExhbmVQcmlvcml0eSA9IERlZmF1bHRMYW5lUHJpb3JpdHk7XG5cbmZ1bmN0aW9uIGdldEhpZ2hlc3RQcmlvcml0eUxhbmVzKGxhbmVzKSB7XG4gIGlmICgoU3luY0xhbmUgJiBsYW5lcykgIT09IE5vTGFuZXMpIHtcbiAgICByZXR1cm5faGlnaGVzdExhbmVQcmlvcml0eSA9IFN5bmNMYW5lUHJpb3JpdHk7XG4gICAgcmV0dXJuIFN5bmNMYW5lO1xuICB9XG5cbiAgaWYgKChTeW5jQmF0Y2hlZExhbmUgJiBsYW5lcykgIT09IE5vTGFuZXMpIHtcbiAgICByZXR1cm5faGlnaGVzdExhbmVQcmlvcml0eSA9IFN5bmNCYXRjaGVkTGFuZVByaW9yaXR5O1xuICAgIHJldHVybiBTeW5jQmF0Y2hlZExhbmU7XG4gIH1cblxuICBpZiAoKElucHV0RGlzY3JldGVIeWRyYXRpb25MYW5lICYgbGFuZXMpICE9PSBOb0xhbmVzKSB7XG4gICAgcmV0dXJuX2hpZ2hlc3RMYW5lUHJpb3JpdHkgPSBJbnB1dERpc2NyZXRlSHlkcmF0aW9uTGFuZVByaW9yaXR5O1xuICAgIHJldHVybiBJbnB1dERpc2NyZXRlSHlkcmF0aW9uTGFuZTtcbiAgfVxuXG4gIHZhciBpbnB1dERpc2NyZXRlTGFuZXMgPSBJbnB1dERpc2NyZXRlTGFuZXMgJiBsYW5lcztcblxuICBpZiAoaW5wdXREaXNjcmV0ZUxhbmVzICE9PSBOb0xhbmVzKSB7XG4gICAgcmV0dXJuX2hpZ2hlc3RMYW5lUHJpb3JpdHkgPSBJbnB1dERpc2NyZXRlTGFuZVByaW9yaXR5O1xuICAgIHJldHVybiBpbnB1dERpc2NyZXRlTGFuZXM7XG4gIH1cblxuICBpZiAoKGxhbmVzICYgSW5wdXRDb250aW51b3VzSHlkcmF0aW9uTGFuZSkgIT09IE5vTGFuZXMpIHtcbiAgICByZXR1cm5faGlnaGVzdExhbmVQcmlvcml0eSA9IElucHV0Q29udGludW91c0h5ZHJhdGlvbkxhbmVQcmlvcml0eTtcbiAgICByZXR1cm4gSW5wdXRDb250aW51b3VzSHlkcmF0aW9uTGFuZTtcbiAgfVxuXG4gIHZhciBpbnB1dENvbnRpbnVvdXNMYW5lcyA9IElucHV0Q29udGludW91c0xhbmVzICYgbGFuZXM7XG5cbiAgaWYgKGlucHV0Q29udGludW91c0xhbmVzICE9PSBOb0xhbmVzKSB7XG4gICAgcmV0dXJuX2hpZ2hlc3RMYW5lUHJpb3JpdHkgPSBJbnB1dENvbnRpbnVvdXNMYW5lUHJpb3JpdHk7XG4gICAgcmV0dXJuIGlucHV0Q29udGludW91c0xhbmVzO1xuICB9XG5cbiAgaWYgKChsYW5lcyAmIERlZmF1bHRIeWRyYXRpb25MYW5lKSAhPT0gTm9MYW5lcykge1xuICAgIHJldHVybl9oaWdoZXN0TGFuZVByaW9yaXR5ID0gRGVmYXVsdEh5ZHJhdGlvbkxhbmVQcmlvcml0eTtcbiAgICByZXR1cm4gRGVmYXVsdEh5ZHJhdGlvbkxhbmU7XG4gIH1cblxuICB2YXIgZGVmYXVsdExhbmVzID0gRGVmYXVsdExhbmVzICYgbGFuZXM7XG5cbiAgaWYgKGRlZmF1bHRMYW5lcyAhPT0gTm9MYW5lcykge1xuICAgIHJldHVybl9oaWdoZXN0TGFuZVByaW9yaXR5ID0gRGVmYXVsdExhbmVQcmlvcml0eTtcbiAgICByZXR1cm4gZGVmYXVsdExhbmVzO1xuICB9XG5cbiAgaWYgKChsYW5lcyAmIFRyYW5zaXRpb25IeWRyYXRpb25MYW5lKSAhPT0gTm9MYW5lcykge1xuICAgIHJldHVybl9oaWdoZXN0TGFuZVByaW9yaXR5ID0gVHJhbnNpdGlvbkh5ZHJhdGlvblByaW9yaXR5O1xuICAgIHJldHVybiBUcmFuc2l0aW9uSHlkcmF0aW9uTGFuZTtcbiAgfVxuXG4gIHZhciB0cmFuc2l0aW9uTGFuZXMgPSBUcmFuc2l0aW9uTGFuZXMgJiBsYW5lcztcblxuICBpZiAodHJhbnNpdGlvbkxhbmVzICE9PSBOb0xhbmVzKSB7XG4gICAgcmV0dXJuX2hpZ2hlc3RMYW5lUHJpb3JpdHkgPSBUcmFuc2l0aW9uUHJpb3JpdHk7XG4gICAgcmV0dXJuIHRyYW5zaXRpb25MYW5lcztcbiAgfVxuXG4gIHZhciByZXRyeUxhbmVzID0gUmV0cnlMYW5lcyAmIGxhbmVzO1xuXG4gIGlmIChyZXRyeUxhbmVzICE9PSBOb0xhbmVzKSB7XG4gICAgcmV0dXJuX2hpZ2hlc3RMYW5lUHJpb3JpdHkgPSBSZXRyeUxhbmVQcmlvcml0eTtcbiAgICByZXR1cm4gcmV0cnlMYW5lcztcbiAgfVxuXG4gIGlmIChsYW5lcyAmIFNlbGVjdGl2ZUh5ZHJhdGlvbkxhbmUpIHtcbiAgICByZXR1cm5faGlnaGVzdExhbmVQcmlvcml0eSA9IFNlbGVjdGl2ZUh5ZHJhdGlvbkxhbmVQcmlvcml0eTtcbiAgICByZXR1cm4gU2VsZWN0aXZlSHlkcmF0aW9uTGFuZTtcbiAgfVxuXG4gIGlmICgobGFuZXMgJiBJZGxlSHlkcmF0aW9uTGFuZSkgIT09IE5vTGFuZXMpIHtcbiAgICByZXR1cm5faGlnaGVzdExhbmVQcmlvcml0eSA9IElkbGVIeWRyYXRpb25MYW5lUHJpb3JpdHk7XG4gICAgcmV0dXJuIElkbGVIeWRyYXRpb25MYW5lO1xuICB9XG5cbiAgdmFyIGlkbGVMYW5lcyA9IElkbGVMYW5lcyAmIGxhbmVzO1xuXG4gIGlmIChpZGxlTGFuZXMgIT09IE5vTGFuZXMpIHtcbiAgICByZXR1cm5faGlnaGVzdExhbmVQcmlvcml0eSA9IElkbGVMYW5lUHJpb3JpdHk7XG4gICAgcmV0dXJuIGlkbGVMYW5lcztcbiAgfVxuXG4gIGlmICgoT2Zmc2NyZWVuTGFuZSAmIGxhbmVzKSAhPT0gTm9MYW5lcykge1xuICAgIHJldHVybl9oaWdoZXN0TGFuZVByaW9yaXR5ID0gT2Zmc2NyZWVuTGFuZVByaW9yaXR5O1xuICAgIHJldHVybiBPZmZzY3JlZW5MYW5lO1xuICB9XG5cbiAge1xuICAgIGVycm9yKCdTaG91bGQgaGF2ZSBmb3VuZCBtYXRjaGluZyBsYW5lcy4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC4nKTtcbiAgfSAvLyBUaGlzIHNob3VsZG4ndCBiZSByZWFjaGFibGUsIGJ1dCBhcyBhIGZhbGxiYWNrLCByZXR1cm4gdGhlIGVudGlyZSBiaXRtYXNrLlxuXG5cbiAgcmV0dXJuX2hpZ2hlc3RMYW5lUHJpb3JpdHkgPSBEZWZhdWx0TGFuZVByaW9yaXR5O1xuICByZXR1cm4gbGFuZXM7XG59XG5cbmZ1bmN0aW9uIHNjaGVkdWxlclByaW9yaXR5VG9MYW5lUHJpb3JpdHkoc2NoZWR1bGVyUHJpb3JpdHlMZXZlbCkge1xuICBzd2l0Y2ggKHNjaGVkdWxlclByaW9yaXR5TGV2ZWwpIHtcbiAgICBjYXNlIEltbWVkaWF0ZVByaW9yaXR5OlxuICAgICAgcmV0dXJuIFN5bmNMYW5lUHJpb3JpdHk7XG5cbiAgICBjYXNlIFVzZXJCbG9ja2luZ1ByaW9yaXR5OlxuICAgICAgcmV0dXJuIElucHV0Q29udGludW91c0xhbmVQcmlvcml0eTtcblxuICAgIGNhc2UgTm9ybWFsUHJpb3JpdHk6XG4gICAgY2FzZSBMb3dQcmlvcml0eTpcbiAgICAgIC8vIFRPRE86IEhhbmRsZSBMb3dTY2hlZHVsZXJQcmlvcml0eSwgc29tZWhvdy4gTWF5YmUgdGhlIHNhbWUgbGFuZSBhcyBoeWRyYXRpb24uXG4gICAgICByZXR1cm4gRGVmYXVsdExhbmVQcmlvcml0eTtcblxuICAgIGNhc2UgSWRsZVByaW9yaXR5OlxuICAgICAgcmV0dXJuIElkbGVMYW5lUHJpb3JpdHk7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIE5vTGFuZVByaW9yaXR5O1xuICB9XG59XG5mdW5jdGlvbiBsYW5lUHJpb3JpdHlUb1NjaGVkdWxlclByaW9yaXR5KGxhbmVQcmlvcml0eSkge1xuICBzd2l0Y2ggKGxhbmVQcmlvcml0eSkge1xuICAgIGNhc2UgU3luY0xhbmVQcmlvcml0eTpcbiAgICBjYXNlIFN5bmNCYXRjaGVkTGFuZVByaW9yaXR5OlxuICAgICAgcmV0dXJuIEltbWVkaWF0ZVByaW9yaXR5O1xuXG4gICAgY2FzZSBJbnB1dERpc2NyZXRlSHlkcmF0aW9uTGFuZVByaW9yaXR5OlxuICAgIGNhc2UgSW5wdXREaXNjcmV0ZUxhbmVQcmlvcml0eTpcbiAgICBjYXNlIElucHV0Q29udGludW91c0h5ZHJhdGlvbkxhbmVQcmlvcml0eTpcbiAgICBjYXNlIElucHV0Q29udGludW91c0xhbmVQcmlvcml0eTpcbiAgICAgIHJldHVybiBVc2VyQmxvY2tpbmdQcmlvcml0eTtcblxuICAgIGNhc2UgRGVmYXVsdEh5ZHJhdGlvbkxhbmVQcmlvcml0eTpcbiAgICBjYXNlIERlZmF1bHRMYW5lUHJpb3JpdHk6XG4gICAgY2FzZSBUcmFuc2l0aW9uSHlkcmF0aW9uUHJpb3JpdHk6XG4gICAgY2FzZSBUcmFuc2l0aW9uUHJpb3JpdHk6XG4gICAgY2FzZSBTZWxlY3RpdmVIeWRyYXRpb25MYW5lUHJpb3JpdHk6XG4gICAgY2FzZSBSZXRyeUxhbmVQcmlvcml0eTpcbiAgICAgIHJldHVybiBOb3JtYWxQcmlvcml0eTtcblxuICAgIGNhc2UgSWRsZUh5ZHJhdGlvbkxhbmVQcmlvcml0eTpcbiAgICBjYXNlIElkbGVMYW5lUHJpb3JpdHk6XG4gICAgY2FzZSBPZmZzY3JlZW5MYW5lUHJpb3JpdHk6XG4gICAgICByZXR1cm4gSWRsZVByaW9yaXR5O1xuXG4gICAgY2FzZSBOb0xhbmVQcmlvcml0eTpcbiAgICAgIHJldHVybiBOb1ByaW9yaXR5O1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHtcbiAgICAgICAge1xuICAgICAgICAgIHRocm93IEVycm9yKCBcIkludmFsaWQgdXBkYXRlIHByaW9yaXR5OiBcIiArIGxhbmVQcmlvcml0eSArIFwiLiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0LlwiICk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICB9XG59XG5mdW5jdGlvbiBnZXROZXh0TGFuZXMocm9vdCwgd2lwTGFuZXMpIHtcbiAgLy8gRWFybHkgYmFpbG91dCBpZiB0aGVyZSdzIG5vIHBlbmRpbmcgd29yayBsZWZ0LlxuICB2YXIgcGVuZGluZ0xhbmVzID0gcm9vdC5wZW5kaW5nTGFuZXM7XG5cbiAgaWYgKHBlbmRpbmdMYW5lcyA9PT0gTm9MYW5lcykge1xuICAgIHJldHVybl9oaWdoZXN0TGFuZVByaW9yaXR5ID0gTm9MYW5lUHJpb3JpdHk7XG4gICAgcmV0dXJuIE5vTGFuZXM7XG4gIH1cblxuICB2YXIgbmV4dExhbmVzID0gTm9MYW5lcztcbiAgdmFyIG5leHRMYW5lUHJpb3JpdHkgPSBOb0xhbmVQcmlvcml0eTtcbiAgdmFyIGV4cGlyZWRMYW5lcyA9IHJvb3QuZXhwaXJlZExhbmVzO1xuICB2YXIgc3VzcGVuZGVkTGFuZXMgPSByb290LnN1c3BlbmRlZExhbmVzO1xuICB2YXIgcGluZ2VkTGFuZXMgPSByb290LnBpbmdlZExhbmVzOyAvLyBDaGVjayBpZiBhbnkgd29yayBoYXMgZXhwaXJlZC5cblxuICBpZiAoZXhwaXJlZExhbmVzICE9PSBOb0xhbmVzKSB7XG4gICAgbmV4dExhbmVzID0gZXhwaXJlZExhbmVzO1xuICAgIG5leHRMYW5lUHJpb3JpdHkgPSByZXR1cm5faGlnaGVzdExhbmVQcmlvcml0eSA9IFN5bmNMYW5lUHJpb3JpdHk7XG4gIH0gZWxzZSB7XG4gICAgLy8gRG8gbm90IHdvcmsgb24gYW55IGlkbGUgd29yayB1bnRpbCBhbGwgdGhlIG5vbi1pZGxlIHdvcmsgaGFzIGZpbmlzaGVkLFxuICAgIC8vIGV2ZW4gaWYgdGhlIHdvcmsgaXMgc3VzcGVuZGVkLlxuICAgIHZhciBub25JZGxlUGVuZGluZ0xhbmVzID0gcGVuZGluZ0xhbmVzICYgTm9uSWRsZUxhbmVzO1xuXG4gICAgaWYgKG5vbklkbGVQZW5kaW5nTGFuZXMgIT09IE5vTGFuZXMpIHtcbiAgICAgIHZhciBub25JZGxlVW5ibG9ja2VkTGFuZXMgPSBub25JZGxlUGVuZGluZ0xhbmVzICYgfnN1c3BlbmRlZExhbmVzO1xuXG4gICAgICBpZiAobm9uSWRsZVVuYmxvY2tlZExhbmVzICE9PSBOb0xhbmVzKSB7XG4gICAgICAgIG5leHRMYW5lcyA9IGdldEhpZ2hlc3RQcmlvcml0eUxhbmVzKG5vbklkbGVVbmJsb2NrZWRMYW5lcyk7XG4gICAgICAgIG5leHRMYW5lUHJpb3JpdHkgPSByZXR1cm5faGlnaGVzdExhbmVQcmlvcml0eTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBub25JZGxlUGluZ2VkTGFuZXMgPSBub25JZGxlUGVuZGluZ0xhbmVzICYgcGluZ2VkTGFuZXM7XG5cbiAgICAgICAgaWYgKG5vbklkbGVQaW5nZWRMYW5lcyAhPT0gTm9MYW5lcykge1xuICAgICAgICAgIG5leHRMYW5lcyA9IGdldEhpZ2hlc3RQcmlvcml0eUxhbmVzKG5vbklkbGVQaW5nZWRMYW5lcyk7XG4gICAgICAgICAgbmV4dExhbmVQcmlvcml0eSA9IHJldHVybl9oaWdoZXN0TGFuZVByaW9yaXR5O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRoZSBvbmx5IHJlbWFpbmluZyB3b3JrIGlzIElkbGUuXG4gICAgICB2YXIgdW5ibG9ja2VkTGFuZXMgPSBwZW5kaW5nTGFuZXMgJiB+c3VzcGVuZGVkTGFuZXM7XG5cbiAgICAgIGlmICh1bmJsb2NrZWRMYW5lcyAhPT0gTm9MYW5lcykge1xuICAgICAgICBuZXh0TGFuZXMgPSBnZXRIaWdoZXN0UHJpb3JpdHlMYW5lcyh1bmJsb2NrZWRMYW5lcyk7XG4gICAgICAgIG5leHRMYW5lUHJpb3JpdHkgPSByZXR1cm5faGlnaGVzdExhbmVQcmlvcml0eTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChwaW5nZWRMYW5lcyAhPT0gTm9MYW5lcykge1xuICAgICAgICAgIG5leHRMYW5lcyA9IGdldEhpZ2hlc3RQcmlvcml0eUxhbmVzKHBpbmdlZExhbmVzKTtcbiAgICAgICAgICBuZXh0TGFuZVByaW9yaXR5ID0gcmV0dXJuX2hpZ2hlc3RMYW5lUHJpb3JpdHk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAobmV4dExhbmVzID09PSBOb0xhbmVzKSB7XG4gICAgLy8gVGhpcyBzaG91bGQgb25seSBiZSByZWFjaGFibGUgaWYgd2UncmUgc3VzcGVuZGVkXG4gICAgLy8gVE9ETzogQ29uc2lkZXIgd2FybmluZyBpbiB0aGlzIHBhdGggaWYgYSBmYWxsYmFjayB0aW1lciBpcyBub3Qgc2NoZWR1bGVkLlxuICAgIHJldHVybiBOb0xhbmVzO1xuICB9IC8vIElmIHRoZXJlIGFyZSBoaWdoZXIgcHJpb3JpdHkgbGFuZXMsIHdlJ2xsIGluY2x1ZGUgdGhlbSBldmVuIGlmIHRoZXlcbiAgLy8gYXJlIHN1c3BlbmRlZC5cblxuXG4gIG5leHRMYW5lcyA9IHBlbmRpbmdMYW5lcyAmIGdldEVxdWFsT3JIaWdoZXJQcmlvcml0eUxhbmVzKG5leHRMYW5lcyk7IC8vIElmIHdlJ3JlIGFscmVhZHkgaW4gdGhlIG1pZGRsZSBvZiBhIHJlbmRlciwgc3dpdGNoaW5nIGxhbmVzIHdpbGwgaW50ZXJydXB0XG4gIC8vIGl0IGFuZCB3ZSdsbCBsb3NlIG91ciBwcm9ncmVzcy4gV2Ugc2hvdWxkIG9ubHkgZG8gdGhpcyBpZiB0aGUgbmV3IGxhbmVzIGFyZVxuICAvLyBoaWdoZXIgcHJpb3JpdHkuXG5cbiAgaWYgKHdpcExhbmVzICE9PSBOb0xhbmVzICYmIHdpcExhbmVzICE9PSBuZXh0TGFuZXMgJiYgLy8gSWYgd2UgYWxyZWFkeSBzdXNwZW5kZWQgd2l0aCBhIGRlbGF5LCB0aGVuIGludGVycnVwdGluZyBpcyBmaW5lLiBEb24ndFxuICAvLyBib3RoZXIgd2FpdGluZyB1bnRpbCB0aGUgcm9vdCBpcyBjb21wbGV0ZS5cbiAgKHdpcExhbmVzICYgc3VzcGVuZGVkTGFuZXMpID09PSBOb0xhbmVzKSB7XG4gICAgZ2V0SGlnaGVzdFByaW9yaXR5TGFuZXMod2lwTGFuZXMpO1xuICAgIHZhciB3aXBMYW5lUHJpb3JpdHkgPSByZXR1cm5faGlnaGVzdExhbmVQcmlvcml0eTtcblxuICAgIGlmIChuZXh0TGFuZVByaW9yaXR5IDw9IHdpcExhbmVQcmlvcml0eSkge1xuICAgICAgcmV0dXJuIHdpcExhbmVzO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm5faGlnaGVzdExhbmVQcmlvcml0eSA9IG5leHRMYW5lUHJpb3JpdHk7XG4gICAgfVxuICB9IC8vIENoZWNrIGZvciBlbnRhbmdsZWQgbGFuZXMgYW5kIGFkZCB0aGVtIHRvIHRoZSBiYXRjaC5cbiAgLy9cbiAgLy8gQSBsYW5lIGlzIHNhaWQgdG8gYmUgZW50YW5nbGVkIHdpdGggYW5vdGhlciB3aGVuIGl0J3Mgbm90IGFsbG93ZWQgdG8gcmVuZGVyXG4gIC8vIGluIGEgYmF0Y2ggdGhhdCBkb2VzIG5vdCBhbHNvIGluY2x1ZGUgdGhlIG90aGVyIGxhbmUuIFR5cGljYWxseSB3ZSBkbyB0aGlzXG4gIC8vIHdoZW4gbXVsdGlwbGUgdXBkYXRlcyBoYXZlIHRoZSBzYW1lIHNvdXJjZSwgYW5kIHdlIG9ubHkgd2FudCB0byByZXNwb25kIHRvXG4gIC8vIHRoZSBtb3N0IHJlY2VudCBldmVudCBmcm9tIHRoYXQgc291cmNlLlxuICAvL1xuICAvLyBOb3RlIHRoYXQgd2UgYXBwbHkgZW50YW5nbGVtZW50cyAqYWZ0ZXIqIGNoZWNraW5nIGZvciBwYXJ0aWFsIHdvcmsgYWJvdmUuXG4gIC8vIFRoaXMgbWVhbnMgdGhhdCBpZiBhIGxhbmUgaXMgZW50YW5nbGVkIGR1cmluZyBhbiBpbnRlcmxlYXZlZCBldmVudCB3aGlsZVxuICAvLyBpdCdzIGFscmVhZHkgcmVuZGVyaW5nLCB3ZSB3b24ndCBpbnRlcnJ1cHQgaXQuIFRoaXMgaXMgaW50ZW50aW9uYWwsIHNpbmNlXG4gIC8vIGVudGFuZ2xlbWVudCBpcyB1c3VhbGx5IFwiYmVzdCBlZmZvcnRcIjogd2UnbGwgdHJ5IG91ciBiZXN0IHRvIHJlbmRlciB0aGVcbiAgLy8gbGFuZXMgaW4gdGhlIHNhbWUgYmF0Y2gsIGJ1dCBpdCdzIG5vdCB3b3J0aCB0aHJvd2luZyBvdXQgcGFydGlhbGx5XG4gIC8vIGNvbXBsZXRlZCB3b3JrIGluIG9yZGVyIHRvIGRvIGl0LlxuICAvL1xuICAvLyBGb3IgdGhvc2UgZXhjZXB0aW9ucyB3aGVyZSBlbnRhbmdsZW1lbnQgaXMgc2VtYW50aWNhbGx5IGltcG9ydGFudCwgbGlrZVxuICAvLyB1c2VNdXRhYmxlU291cmNlLCB3ZSBzaG91bGQgZW5zdXJlIHRoYXQgdGhlcmUgaXMgbm8gcGFydGlhbCB3b3JrIGF0IHRoZVxuICAvLyB0aW1lIHdlIGFwcGx5IHRoZSBlbnRhbmdsZW1lbnQuXG5cblxuICB2YXIgZW50YW5nbGVkTGFuZXMgPSByb290LmVudGFuZ2xlZExhbmVzO1xuXG4gIGlmIChlbnRhbmdsZWRMYW5lcyAhPT0gTm9MYW5lcykge1xuICAgIHZhciBlbnRhbmdsZW1lbnRzID0gcm9vdC5lbnRhbmdsZW1lbnRzO1xuICAgIHZhciBsYW5lcyA9IG5leHRMYW5lcyAmIGVudGFuZ2xlZExhbmVzO1xuXG4gICAgd2hpbGUgKGxhbmVzID4gMCkge1xuICAgICAgdmFyIGluZGV4ID0gcGlja0FyYml0cmFyeUxhbmVJbmRleChsYW5lcyk7XG4gICAgICB2YXIgbGFuZSA9IDEgPDwgaW5kZXg7XG4gICAgICBuZXh0TGFuZXMgfD0gZW50YW5nbGVtZW50c1tpbmRleF07XG4gICAgICBsYW5lcyAmPSB+bGFuZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmV4dExhbmVzO1xufVxuZnVuY3Rpb24gZ2V0TW9zdFJlY2VudEV2ZW50VGltZShyb290LCBsYW5lcykge1xuICB2YXIgZXZlbnRUaW1lcyA9IHJvb3QuZXZlbnRUaW1lcztcbiAgdmFyIG1vc3RSZWNlbnRFdmVudFRpbWUgPSBOb1RpbWVzdGFtcDtcblxuICB3aGlsZSAobGFuZXMgPiAwKSB7XG4gICAgdmFyIGluZGV4ID0gcGlja0FyYml0cmFyeUxhbmVJbmRleChsYW5lcyk7XG4gICAgdmFyIGxhbmUgPSAxIDw8IGluZGV4O1xuICAgIHZhciBldmVudFRpbWUgPSBldmVudFRpbWVzW2luZGV4XTtcblxuICAgIGlmIChldmVudFRpbWUgPiBtb3N0UmVjZW50RXZlbnRUaW1lKSB7XG4gICAgICBtb3N0UmVjZW50RXZlbnRUaW1lID0gZXZlbnRUaW1lO1xuICAgIH1cblxuICAgIGxhbmVzICY9IH5sYW5lO1xuICB9XG5cbiAgcmV0dXJuIG1vc3RSZWNlbnRFdmVudFRpbWU7XG59XG5cbmZ1bmN0aW9uIGNvbXB1dGVFeHBpcmF0aW9uVGltZShsYW5lLCBjdXJyZW50VGltZSkge1xuICAvLyBUT0RPOiBFeHBpcmF0aW9uIGhldXJpc3RpYyBpcyBjb25zdGFudCBwZXIgbGFuZSwgc28gY291bGQgdXNlIGEgbWFwLlxuICBnZXRIaWdoZXN0UHJpb3JpdHlMYW5lcyhsYW5lKTtcbiAgdmFyIHByaW9yaXR5ID0gcmV0dXJuX2hpZ2hlc3RMYW5lUHJpb3JpdHk7XG5cbiAgaWYgKHByaW9yaXR5ID49IElucHV0Q29udGludW91c0xhbmVQcmlvcml0eSkge1xuICAgIC8vIFVzZXIgaW50ZXJhY3Rpb25zIHNob3VsZCBleHBpcmUgc2xpZ2h0bHkgbW9yZSBxdWlja2x5LlxuICAgIC8vXG4gICAgLy8gTk9URTogVGhpcyBpcyBzZXQgdG8gdGhlIGNvcnJlc3BvbmRpbmcgY29uc3RhbnQgYXMgaW4gU2NoZWR1bGVyLmpzLiBXaGVuXG4gICAgLy8gd2UgbWFkZSBpdCBsYXJnZXIsIGEgcHJvZHVjdCBtZXRyaWMgaW4gd3d3IHJlZ3Jlc3NlZCwgc3VnZ2VzdGluZyB0aGVyZSdzXG4gICAgLy8gYSB1c2VyIGludGVyYWN0aW9uIHRoYXQncyBiZWluZyBzdGFydmVkIGJ5IGEgc2VyaWVzIG9mIHN5bmNocm9ub3VzXG4gICAgLy8gdXBkYXRlcy4gSWYgdGhhdCB0aGVvcnkgaXMgY29ycmVjdCwgdGhlIHByb3BlciBzb2x1dGlvbiBpcyB0byBmaXggdGhlXG4gICAgLy8gc3RhcnZhdGlvbi4gSG93ZXZlciwgdGhpcyBzY2VuYXJpbyBzdXBwb3J0cyB0aGUgaWRlYSB0aGF0IGV4cGlyYXRpb25cbiAgICAvLyB0aW1lcyBhcmUgYW4gaW1wb3J0YW50IHNhZmVndWFyZCB3aGVuIHN0YXJ2YXRpb24gZG9lcyBoYXBwZW4uXG4gICAgLy9cbiAgICAvLyBBbHNvIG5vdGUgdGhhdCwgaW4gdGhlIGNhc2Ugb2YgdXNlciBpbnB1dCBzcGVjaWZpY2FsbHksIHRoaXMgd2lsbCBzb29uIG5vXG4gICAgLy8gbG9uZ2VyIGJlIGFuIGlzc3VlIGJlY2F1c2Ugd2UgcGxhbiB0byBtYWtlIHVzZXIgaW5wdXQgc3luY2hyb25vdXMgYnlcbiAgICAvLyBkZWZhdWx0ICh1bnRpbCB5b3UgZW50ZXIgYHN0YXJ0VHJhbnNpdGlvbmAsIG9mIGNvdXJzZS4pXG4gICAgLy9cbiAgICAvLyBJZiB3ZXJlbid0IHBsYW5uaW5nIHRvIG1ha2UgdGhlc2UgdXBkYXRlcyBzeW5jaHJvbm91cyBzb29uIGFueXdheSwgSVxuICAgIC8vIHdvdWxkIHByb2JhYmx5IG1ha2UgdGhpcyBudW1iZXIgYSBjb25maWd1cmFibGUgcGFyYW1ldGVyLlxuICAgIHJldHVybiBjdXJyZW50VGltZSArIDI1MDtcbiAgfSBlbHNlIGlmIChwcmlvcml0eSA+PSBUcmFuc2l0aW9uUHJpb3JpdHkpIHtcbiAgICByZXR1cm4gY3VycmVudFRpbWUgKyA1MDAwO1xuICB9IGVsc2Uge1xuICAgIC8vIEFueXRoaW5nIGlkbGUgcHJpb3JpdHkgb3IgbG93ZXIgc2hvdWxkIG5ldmVyIGV4cGlyZS5cbiAgICByZXR1cm4gTm9UaW1lc3RhbXA7XG4gIH1cbn1cblxuZnVuY3Rpb24gbWFya1N0YXJ2ZWRMYW5lc0FzRXhwaXJlZChyb290LCBjdXJyZW50VGltZSkge1xuICAvLyBUT0RPOiBUaGlzIGdldHMgY2FsbGVkIGV2ZXJ5IHRpbWUgd2UgeWllbGQuIFdlIGNhbiBvcHRpbWl6ZSBieSBzdG9yaW5nXG4gIC8vIHRoZSBlYXJsaWVzdCBleHBpcmF0aW9uIHRpbWUgb24gdGhlIHJvb3QuIFRoZW4gdXNlIHRoYXQgdG8gcXVpY2tseSBiYWlsIG91dFxuICAvLyBvZiB0aGlzIGZ1bmN0aW9uLlxuICB2YXIgcGVuZGluZ0xhbmVzID0gcm9vdC5wZW5kaW5nTGFuZXM7XG4gIHZhciBzdXNwZW5kZWRMYW5lcyA9IHJvb3Quc3VzcGVuZGVkTGFuZXM7XG4gIHZhciBwaW5nZWRMYW5lcyA9IHJvb3QucGluZ2VkTGFuZXM7XG4gIHZhciBleHBpcmF0aW9uVGltZXMgPSByb290LmV4cGlyYXRpb25UaW1lczsgLy8gSXRlcmF0ZSB0aHJvdWdoIHRoZSBwZW5kaW5nIGxhbmVzIGFuZCBjaGVjayBpZiB3ZSd2ZSByZWFjaGVkIHRoZWlyXG4gIC8vIGV4cGlyYXRpb24gdGltZS4gSWYgc28sIHdlJ2xsIGFzc3VtZSB0aGUgdXBkYXRlIGlzIGJlaW5nIHN0YXJ2ZWQgYW5kIG1hcmtcbiAgLy8gaXQgYXMgZXhwaXJlZCB0byBmb3JjZSBpdCB0byBmaW5pc2guXG5cbiAgdmFyIGxhbmVzID0gcGVuZGluZ0xhbmVzO1xuXG4gIHdoaWxlIChsYW5lcyA+IDApIHtcbiAgICB2YXIgaW5kZXggPSBwaWNrQXJiaXRyYXJ5TGFuZUluZGV4KGxhbmVzKTtcbiAgICB2YXIgbGFuZSA9IDEgPDwgaW5kZXg7XG4gICAgdmFyIGV4cGlyYXRpb25UaW1lID0gZXhwaXJhdGlvblRpbWVzW2luZGV4XTtcblxuICAgIGlmIChleHBpcmF0aW9uVGltZSA9PT0gTm9UaW1lc3RhbXApIHtcbiAgICAgIC8vIEZvdW5kIGEgcGVuZGluZyBsYW5lIHdpdGggbm8gZXhwaXJhdGlvbiB0aW1lLiBJZiBpdCdzIG5vdCBzdXNwZW5kZWQsIG9yXG4gICAgICAvLyBpZiBpdCdzIHBpbmdlZCwgYXNzdW1lIGl0J3MgQ1BVLWJvdW5kLiBDb21wdXRlIGEgbmV3IGV4cGlyYXRpb24gdGltZVxuICAgICAgLy8gdXNpbmcgdGhlIGN1cnJlbnQgdGltZS5cbiAgICAgIGlmICgobGFuZSAmIHN1c3BlbmRlZExhbmVzKSA9PT0gTm9MYW5lcyB8fCAobGFuZSAmIHBpbmdlZExhbmVzKSAhPT0gTm9MYW5lcykge1xuICAgICAgICAvLyBBc3N1bWVzIHRpbWVzdGFtcHMgYXJlIG1vbm90b25pY2FsbHkgaW5jcmVhc2luZy5cbiAgICAgICAgZXhwaXJhdGlvblRpbWVzW2luZGV4XSA9IGNvbXB1dGVFeHBpcmF0aW9uVGltZShsYW5lLCBjdXJyZW50VGltZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChleHBpcmF0aW9uVGltZSA8PSBjdXJyZW50VGltZSkge1xuICAgICAgLy8gVGhpcyBsYW5lIGV4cGlyZWRcbiAgICAgIHJvb3QuZXhwaXJlZExhbmVzIHw9IGxhbmU7XG4gICAgfVxuXG4gICAgbGFuZXMgJj0gfmxhbmU7XG4gIH1cbn0gLy8gVGhpcyByZXR1cm5zIHRoZSBoaWdoZXN0IHByaW9yaXR5IHBlbmRpbmcgbGFuZXMgcmVnYXJkbGVzcyBvZiB3aGV0aGVyIHRoZXlcbmZ1bmN0aW9uIGdldExhbmVzVG9SZXRyeVN5bmNocm9ub3VzbHlPbkVycm9yKHJvb3QpIHtcbiAgdmFyIGV2ZXJ5dGhpbmdCdXRPZmZzY3JlZW4gPSByb290LnBlbmRpbmdMYW5lcyAmIH5PZmZzY3JlZW5MYW5lO1xuXG4gIGlmIChldmVyeXRoaW5nQnV0T2Zmc2NyZWVuICE9PSBOb0xhbmVzKSB7XG4gICAgcmV0dXJuIGV2ZXJ5dGhpbmdCdXRPZmZzY3JlZW47XG4gIH1cblxuICBpZiAoZXZlcnl0aGluZ0J1dE9mZnNjcmVlbiAmIE9mZnNjcmVlbkxhbmUpIHtcbiAgICByZXR1cm4gT2Zmc2NyZWVuTGFuZTtcbiAgfVxuXG4gIHJldHVybiBOb0xhbmVzO1xufVxuZnVuY3Rpb24gcmV0dXJuTmV4dExhbmVzUHJpb3JpdHkoKSB7XG4gIHJldHVybiByZXR1cm5faGlnaGVzdExhbmVQcmlvcml0eTtcbn1cbmZ1bmN0aW9uIGluY2x1ZGVzTm9uSWRsZVdvcmsobGFuZXMpIHtcbiAgcmV0dXJuIChsYW5lcyAmIE5vbklkbGVMYW5lcykgIT09IE5vTGFuZXM7XG59XG5mdW5jdGlvbiBpbmNsdWRlc09ubHlSZXRyaWVzKGxhbmVzKSB7XG4gIHJldHVybiAobGFuZXMgJiBSZXRyeUxhbmVzKSA9PT0gbGFuZXM7XG59XG5mdW5jdGlvbiBpbmNsdWRlc09ubHlUcmFuc2l0aW9ucyhsYW5lcykge1xuICByZXR1cm4gKGxhbmVzICYgVHJhbnNpdGlvbkxhbmVzKSA9PT0gbGFuZXM7XG59IC8vIFRvIGVuc3VyZSBjb25zaXN0ZW5jeSBhY3Jvc3MgbXVsdGlwbGUgdXBkYXRlcyBpbiB0aGUgc2FtZSBldmVudCwgdGhpcyBzaG91bGRcbi8vIGJlIGEgcHVyZSBmdW5jdGlvbiwgc28gdGhhdCBpdCBhbHdheXMgcmV0dXJucyB0aGUgc2FtZSBsYW5lIGZvciBnaXZlbiBpbnB1dHMuXG5cbmZ1bmN0aW9uIGZpbmRVcGRhdGVMYW5lKGxhbmVQcmlvcml0eSwgd2lwTGFuZXMpIHtcbiAgc3dpdGNoIChsYW5lUHJpb3JpdHkpIHtcbiAgICBjYXNlIE5vTGFuZVByaW9yaXR5OlxuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIFN5bmNMYW5lUHJpb3JpdHk6XG4gICAgICByZXR1cm4gU3luY0xhbmU7XG5cbiAgICBjYXNlIFN5bmNCYXRjaGVkTGFuZVByaW9yaXR5OlxuICAgICAgcmV0dXJuIFN5bmNCYXRjaGVkTGFuZTtcblxuICAgIGNhc2UgSW5wdXREaXNjcmV0ZUxhbmVQcmlvcml0eTpcbiAgICAgIHtcbiAgICAgICAgdmFyIF9sYW5lID0gcGlja0FyYml0cmFyeUxhbmUoSW5wdXREaXNjcmV0ZUxhbmVzICYgfndpcExhbmVzKTtcblxuICAgICAgICBpZiAoX2xhbmUgPT09IE5vTGFuZSkge1xuICAgICAgICAgIC8vIFNoaWZ0IHRvIHRoZSBuZXh0IHByaW9yaXR5IGxldmVsXG4gICAgICAgICAgcmV0dXJuIGZpbmRVcGRhdGVMYW5lKElucHV0Q29udGludW91c0xhbmVQcmlvcml0eSwgd2lwTGFuZXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIF9sYW5lO1xuICAgICAgfVxuXG4gICAgY2FzZSBJbnB1dENvbnRpbnVvdXNMYW5lUHJpb3JpdHk6XG4gICAgICB7XG4gICAgICAgIHZhciBfbGFuZTIgPSBwaWNrQXJiaXRyYXJ5TGFuZShJbnB1dENvbnRpbnVvdXNMYW5lcyAmIH53aXBMYW5lcyk7XG5cbiAgICAgICAgaWYgKF9sYW5lMiA9PT0gTm9MYW5lKSB7XG4gICAgICAgICAgLy8gU2hpZnQgdG8gdGhlIG5leHQgcHJpb3JpdHkgbGV2ZWxcbiAgICAgICAgICByZXR1cm4gZmluZFVwZGF0ZUxhbmUoRGVmYXVsdExhbmVQcmlvcml0eSwgd2lwTGFuZXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIF9sYW5lMjtcbiAgICAgIH1cblxuICAgIGNhc2UgRGVmYXVsdExhbmVQcmlvcml0eTpcbiAgICAgIHtcbiAgICAgICAgdmFyIF9sYW5lMyA9IHBpY2tBcmJpdHJhcnlMYW5lKERlZmF1bHRMYW5lcyAmIH53aXBMYW5lcyk7XG5cbiAgICAgICAgaWYgKF9sYW5lMyA9PT0gTm9MYW5lKSB7XG4gICAgICAgICAgLy8gSWYgYWxsIHRoZSBkZWZhdWx0IGxhbmVzIGFyZSBhbHJlYWR5IGJlaW5nIHdvcmtlZCBvbiwgbG9vayBmb3IgYVxuICAgICAgICAgIC8vIGxhbmUgaW4gdGhlIHRyYW5zaXRpb24gcmFuZ2UuXG4gICAgICAgICAgX2xhbmUzID0gcGlja0FyYml0cmFyeUxhbmUoVHJhbnNpdGlvbkxhbmVzICYgfndpcExhbmVzKTtcblxuICAgICAgICAgIGlmIChfbGFuZTMgPT09IE5vTGFuZSkge1xuICAgICAgICAgICAgLy8gQWxsIHRoZSB0cmFuc2l0aW9uIGxhbmVzIGFyZSB0YWtlbiwgdG9vLiBUaGlzIHNob3VsZCBiZSB2ZXJ5XG4gICAgICAgICAgICAvLyByYXJlLCBidXQgYXMgYSBsYXN0IHJlc29ydCwgcGljayBhIGRlZmF1bHQgbGFuZS4gVGhpcyB3aWxsIGhhdmVcbiAgICAgICAgICAgIC8vIHRoZSBlZmZlY3Qgb2YgaW50ZXJydXB0aW5nIHRoZSBjdXJyZW50IHdvcmstaW4tcHJvZ3Jlc3MgcmVuZGVyLlxuICAgICAgICAgICAgX2xhbmUzID0gcGlja0FyYml0cmFyeUxhbmUoRGVmYXVsdExhbmVzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gX2xhbmUzO1xuICAgICAgfVxuXG4gICAgY2FzZSBUcmFuc2l0aW9uUHJpb3JpdHk6IC8vIFNob3VsZCBiZSBoYW5kbGVkIGJ5IGZpbmRUcmFuc2l0aW9uTGFuZSBpbnN0ZWFkXG5cbiAgICBjYXNlIFJldHJ5TGFuZVByaW9yaXR5OlxuICAgICAgLy8gU2hvdWxkIGJlIGhhbmRsZWQgYnkgZmluZFJldHJ5TGFuZSBpbnN0ZWFkXG4gICAgICBicmVhaztcblxuICAgIGNhc2UgSWRsZUxhbmVQcmlvcml0eTpcbiAgICAgIHZhciBsYW5lID0gcGlja0FyYml0cmFyeUxhbmUoSWRsZUxhbmVzICYgfndpcExhbmVzKTtcblxuICAgICAgaWYgKGxhbmUgPT09IE5vTGFuZSkge1xuICAgICAgICBsYW5lID0gcGlja0FyYml0cmFyeUxhbmUoSWRsZUxhbmVzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGxhbmU7XG4gIH1cblxuICB7XG4gICAge1xuICAgICAgdGhyb3cgRXJyb3IoIFwiSW52YWxpZCB1cGRhdGUgcHJpb3JpdHk6IFwiICsgbGFuZVByaW9yaXR5ICsgXCIuIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuXCIgKTtcbiAgICB9XG4gIH1cbn0gLy8gVG8gZW5zdXJlIGNvbnNpc3RlbmN5IGFjcm9zcyBtdWx0aXBsZSB1cGRhdGVzIGluIHRoZSBzYW1lIGV2ZW50LCB0aGlzIHNob3VsZFxuLy8gYmUgcHVyZSBmdW5jdGlvbiwgc28gdGhhdCBpdCBhbHdheXMgcmV0dXJucyB0aGUgc2FtZSBsYW5lIGZvciBnaXZlbiBpbnB1dHMuXG5cbmZ1bmN0aW9uIGZpbmRUcmFuc2l0aW9uTGFuZSh3aXBMYW5lcywgcGVuZGluZ0xhbmVzKSB7XG4gIC8vIEZpcnN0IGxvb2sgZm9yIGxhbmVzIHRoYXQgYXJlIGNvbXBsZXRlbHkgdW5jbGFpbWVkLCBpLmUuIGhhdmUgbm9cbiAgLy8gcGVuZGluZyB3b3JrLlxuICB2YXIgbGFuZSA9IHBpY2tBcmJpdHJhcnlMYW5lKFRyYW5zaXRpb25MYW5lcyAmIH5wZW5kaW5nTGFuZXMpO1xuXG4gIGlmIChsYW5lID09PSBOb0xhbmUpIHtcbiAgICAvLyBJZiBhbGwgbGFuZXMgaGF2ZSBwZW5kaW5nIHdvcmssIGxvb2sgZm9yIGEgbGFuZSB0aGF0IGlzbid0IGN1cnJlbnRseVxuICAgIC8vIGJlaW5nIHdvcmtlZCBvbi5cbiAgICBsYW5lID0gcGlja0FyYml0cmFyeUxhbmUoVHJhbnNpdGlvbkxhbmVzICYgfndpcExhbmVzKTtcblxuICAgIGlmIChsYW5lID09PSBOb0xhbmUpIHtcbiAgICAgIC8vIElmIGV2ZXJ5dGhpbmcgaXMgYmVpbmcgd29ya2VkIG9uLCBwaWNrIGFueSBsYW5lLiBUaGlzIGhhcyB0aGVcbiAgICAgIC8vIGVmZmVjdCBvZiBpbnRlcnJ1cHRpbmcgdGhlIGN1cnJlbnQgd29yay1pbi1wcm9ncmVzcy5cbiAgICAgIGxhbmUgPSBwaWNrQXJiaXRyYXJ5TGFuZShUcmFuc2l0aW9uTGFuZXMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBsYW5lO1xufSAvLyBUbyBlbnN1cmUgY29uc2lzdGVuY3kgYWNyb3NzIG11bHRpcGxlIHVwZGF0ZXMgaW4gdGhlIHNhbWUgZXZlbnQsIHRoaXMgc2hvdWxkXG4vLyBiZSBwdXJlIGZ1bmN0aW9uLCBzbyB0aGF0IGl0IGFsd2F5cyByZXR1cm5zIHRoZSBzYW1lIGxhbmUgZm9yIGdpdmVuIGlucHV0cy5cblxuZnVuY3Rpb24gZmluZFJldHJ5TGFuZSh3aXBMYW5lcykge1xuICAvLyBUaGlzIGlzIGEgZm9yayBvZiBgZmluZFVwZGF0ZUxhbmVgIGRlc2lnbmVkIHNwZWNpZmljYWxseSBmb3IgU3VzcGVuc2VcbiAgLy8gXCJyZXRyaWVzXCIg4oCUIGEgc3BlY2lhbCB1cGRhdGUgdGhhdCBhdHRlbXB0cyB0byBmbGlwIGEgU3VzcGVuc2UgYm91bmRhcnlcbiAgLy8gZnJvbSBpdHMgcGxhY2Vob2xkZXIgc3RhdGUgdG8gaXRzIHByaW1hcnkvcmVzb2x2ZWQgc3RhdGUuXG4gIHZhciBsYW5lID0gcGlja0FyYml0cmFyeUxhbmUoUmV0cnlMYW5lcyAmIH53aXBMYW5lcyk7XG5cbiAgaWYgKGxhbmUgPT09IE5vTGFuZSkge1xuICAgIGxhbmUgPSBwaWNrQXJiaXRyYXJ5TGFuZShSZXRyeUxhbmVzKTtcbiAgfVxuXG4gIHJldHVybiBsYW5lO1xufVxuXG5mdW5jdGlvbiBnZXRIaWdoZXN0UHJpb3JpdHlMYW5lKGxhbmVzKSB7XG4gIHJldHVybiBsYW5lcyAmIC1sYW5lcztcbn1cblxuZnVuY3Rpb24gZ2V0TG93ZXN0UHJpb3JpdHlMYW5lKGxhbmVzKSB7XG4gIC8vIFRoaXMgZmluZHMgdGhlIG1vc3Qgc2lnbmlmaWNhbnQgbm9uLXplcm8gYml0LlxuICB2YXIgaW5kZXggPSAzMSAtIGNsejMyKGxhbmVzKTtcbiAgcmV0dXJuIGluZGV4IDwgMCA/IE5vTGFuZXMgOiAxIDw8IGluZGV4O1xufVxuXG5mdW5jdGlvbiBnZXRFcXVhbE9ySGlnaGVyUHJpb3JpdHlMYW5lcyhsYW5lcykge1xuICByZXR1cm4gKGdldExvd2VzdFByaW9yaXR5TGFuZShsYW5lcykgPDwgMSkgLSAxO1xufVxuXG5mdW5jdGlvbiBwaWNrQXJiaXRyYXJ5TGFuZShsYW5lcykge1xuICAvLyBUaGlzIHdyYXBwZXIgZnVuY3Rpb24gZ2V0cyBpbmxpbmVkLiBPbmx5IGV4aXN0cyBzbyB0byBjb21tdW5pY2F0ZSB0aGF0IGl0XG4gIC8vIGRvZXNuJ3QgbWF0dGVyIHdoaWNoIGJpdCBpcyBzZWxlY3RlZDsgeW91IGNhbiBwaWNrIGFueSBiaXQgd2l0aG91dFxuICAvLyBhZmZlY3RpbmcgdGhlIGFsZ29yaXRobXMgd2hlcmUgaXRzIHVzZWQuIEhlcmUgSSdtIHVzaW5nXG4gIC8vIGdldEhpZ2hlc3RQcmlvcml0eUxhbmUgYmVjYXVzZSBpdCByZXF1aXJlcyB0aGUgZmV3ZXN0IG9wZXJhdGlvbnMuXG4gIHJldHVybiBnZXRIaWdoZXN0UHJpb3JpdHlMYW5lKGxhbmVzKTtcbn1cblxuZnVuY3Rpb24gcGlja0FyYml0cmFyeUxhbmVJbmRleChsYW5lcykge1xuICByZXR1cm4gMzEgLSBjbHozMihsYW5lcyk7XG59XG5cbmZ1bmN0aW9uIGxhbmVUb0luZGV4KGxhbmUpIHtcbiAgcmV0dXJuIHBpY2tBcmJpdHJhcnlMYW5lSW5kZXgobGFuZSk7XG59XG5cbmZ1bmN0aW9uIGluY2x1ZGVzU29tZUxhbmUoYSwgYikge1xuICByZXR1cm4gKGEgJiBiKSAhPT0gTm9MYW5lcztcbn1cbmZ1bmN0aW9uIGlzU3Vic2V0T2ZMYW5lcyhzZXQsIHN1YnNldCkge1xuICByZXR1cm4gKHNldCAmIHN1YnNldCkgPT09IHN1YnNldDtcbn1cbmZ1bmN0aW9uIG1lcmdlTGFuZXMoYSwgYikge1xuICByZXR1cm4gYSB8IGI7XG59XG5mdW5jdGlvbiByZW1vdmVMYW5lcyhzZXQsIHN1YnNldCkge1xuICByZXR1cm4gc2V0ICYgfnN1YnNldDtcbn0gLy8gU2VlbXMgcmVkdW5kYW50LCBidXQgaXQgY2hhbmdlcyB0aGUgdHlwZSBmcm9tIGEgc2luZ2xlIGxhbmUgKHVzZWQgZm9yXG4vLyB1cGRhdGVzKSB0byBhIGdyb3VwIG9mIGxhbmVzICh1c2VkIGZvciBmbHVzaGluZyB3b3JrKS5cblxuZnVuY3Rpb24gbGFuZVRvTGFuZXMobGFuZSkge1xuICByZXR1cm4gbGFuZTtcbn1cbmZ1bmN0aW9uIGhpZ2hlclByaW9yaXR5TGFuZShhLCBiKSB7XG4gIC8vIFRoaXMgd29ya3MgYmVjYXVzZSB0aGUgYml0IHJhbmdlcyBkZWNyZWFzZSBpbiBwcmlvcml0eSBhcyB5b3UgZ28gbGVmdC5cbiAgcmV0dXJuIGEgIT09IE5vTGFuZSAmJiBhIDwgYiA/IGEgOiBiO1xufVxuZnVuY3Rpb24gY3JlYXRlTGFuZU1hcChpbml0aWFsKSB7XG4gIC8vIEludGVudGlvbmFsbHkgcHVzaGluZyBvbmUgYnkgb25lLlxuICAvLyBodHRwczovL3Y4LmRldi9ibG9nL2VsZW1lbnRzLWtpbmRzI2F2b2lkLWNyZWF0aW5nLWhvbGVzXG4gIHZhciBsYW5lTWFwID0gW107XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBUb3RhbExhbmVzOyBpKyspIHtcbiAgICBsYW5lTWFwLnB1c2goaW5pdGlhbCk7XG4gIH1cblxuICByZXR1cm4gbGFuZU1hcDtcbn1cbmZ1bmN0aW9uIG1hcmtSb290VXBkYXRlZChyb290LCB1cGRhdGVMYW5lLCBldmVudFRpbWUpIHtcbiAgcm9vdC5wZW5kaW5nTGFuZXMgfD0gdXBkYXRlTGFuZTsgLy8gVE9ETzogVGhlb3JldGljYWxseSwgYW55IHVwZGF0ZSB0byBhbnkgbGFuZSBjYW4gdW5ibG9jayBhbnkgb3RoZXIgbGFuZS4gQnV0XG4gIC8vIGl0J3Mgbm90IHByYWN0aWNhbCB0byB0cnkgZXZlcnkgc2luZ2xlIHBvc3NpYmxlIGNvbWJpbmF0aW9uLiBXZSBuZWVkIGFcbiAgLy8gaGV1cmlzdGljIHRvIGRlY2lkZSB3aGljaCBsYW5lcyB0byBhdHRlbXB0IHRvIHJlbmRlciwgYW5kIGluIHdoaWNoIGJhdGNoZXMuXG4gIC8vIEZvciBub3csIHdlIHVzZSB0aGUgc2FtZSBoZXVyaXN0aWMgYXMgaW4gdGhlIG9sZCBFeHBpcmF0aW9uVGltZXMgbW9kZWw6XG4gIC8vIHJldHJ5IGFueSBsYW5lIGF0IGVxdWFsIG9yIGxvd2VyIHByaW9yaXR5LCBidXQgZG9uJ3QgdHJ5IHVwZGF0ZXMgYXQgaGlnaGVyXG4gIC8vIHByaW9yaXR5IHdpdGhvdXQgYWxzbyBpbmNsdWRpbmcgdGhlIGxvd2VyIHByaW9yaXR5IHVwZGF0ZXMuIFRoaXMgd29ya3Mgd2VsbFxuICAvLyB3aGVuIGNvbnNpZGVyaW5nIHVwZGF0ZXMgYWNyb3NzIGRpZmZlcmVudCBwcmlvcml0eSBsZXZlbHMsIGJ1dCBpc24ndFxuICAvLyBzdWZmaWNpZW50IGZvciB1cGRhdGVzIHdpdGhpbiB0aGUgc2FtZSBwcmlvcml0eSwgc2luY2Ugd2Ugd2FudCB0byB0cmVhdFxuICAvLyB0aG9zZSB1cGRhdGVzIGFzIHBhcmFsbGVsLlxuICAvLyBVbnN1c3BlbmQgYW55IHVwZGF0ZSBhdCBlcXVhbCBvciBsb3dlciBwcmlvcml0eS5cblxuICB2YXIgaGlnaGVyUHJpb3JpdHlMYW5lcyA9IHVwZGF0ZUxhbmUgLSAxOyAvLyBUdXJucyAwYjEwMDAgaW50byAwYjAxMTFcblxuICByb290LnN1c3BlbmRlZExhbmVzICY9IGhpZ2hlclByaW9yaXR5TGFuZXM7XG4gIHJvb3QucGluZ2VkTGFuZXMgJj0gaGlnaGVyUHJpb3JpdHlMYW5lcztcbiAgdmFyIGV2ZW50VGltZXMgPSByb290LmV2ZW50VGltZXM7XG4gIHZhciBpbmRleCA9IGxhbmVUb0luZGV4KHVwZGF0ZUxhbmUpOyAvLyBXZSBjYW4gYWx3YXlzIG92ZXJ3cml0ZSBhbiBleGlzdGluZyB0aW1lc3RhbXAgYmVjYXVzZSB3ZSBwcmVmZXIgdGhlIG1vc3RcbiAgLy8gcmVjZW50IGV2ZW50LCBhbmQgd2UgYXNzdW1lIHRpbWUgaXMgbW9ub3RvbmljYWxseSBpbmNyZWFzaW5nLlxuXG4gIGV2ZW50VGltZXNbaW5kZXhdID0gZXZlbnRUaW1lO1xufVxuZnVuY3Rpb24gbWFya1Jvb3RTdXNwZW5kZWQocm9vdCwgc3VzcGVuZGVkTGFuZXMpIHtcbiAgcm9vdC5zdXNwZW5kZWRMYW5lcyB8PSBzdXNwZW5kZWRMYW5lcztcbiAgcm9vdC5waW5nZWRMYW5lcyAmPSB+c3VzcGVuZGVkTGFuZXM7IC8vIFRoZSBzdXNwZW5kZWQgbGFuZXMgYXJlIG5vIGxvbmdlciBDUFUtYm91bmQuIENsZWFyIHRoZWlyIGV4cGlyYXRpb24gdGltZXMuXG5cbiAgdmFyIGV4cGlyYXRpb25UaW1lcyA9IHJvb3QuZXhwaXJhdGlvblRpbWVzO1xuICB2YXIgbGFuZXMgPSBzdXNwZW5kZWRMYW5lcztcblxuICB3aGlsZSAobGFuZXMgPiAwKSB7XG4gICAgdmFyIGluZGV4ID0gcGlja0FyYml0cmFyeUxhbmVJbmRleChsYW5lcyk7XG4gICAgdmFyIGxhbmUgPSAxIDw8IGluZGV4O1xuICAgIGV4cGlyYXRpb25UaW1lc1tpbmRleF0gPSBOb1RpbWVzdGFtcDtcbiAgICBsYW5lcyAmPSB+bGFuZTtcbiAgfVxufVxuZnVuY3Rpb24gbWFya1Jvb3RQaW5nZWQocm9vdCwgcGluZ2VkTGFuZXMsIGV2ZW50VGltZSkge1xuICByb290LnBpbmdlZExhbmVzIHw9IHJvb3Quc3VzcGVuZGVkTGFuZXMgJiBwaW5nZWRMYW5lcztcbn1cbmZ1bmN0aW9uIG1hcmtEaXNjcmV0ZVVwZGF0ZXNFeHBpcmVkKHJvb3QpIHtcbiAgcm9vdC5leHBpcmVkTGFuZXMgfD0gSW5wdXREaXNjcmV0ZUxhbmVzICYgcm9vdC5wZW5kaW5nTGFuZXM7XG59XG5mdW5jdGlvbiBoYXNEaXNjcmV0ZUxhbmVzKGxhbmVzKSB7XG4gIHJldHVybiAobGFuZXMgJiBJbnB1dERpc2NyZXRlTGFuZXMpICE9PSBOb0xhbmVzO1xufVxuZnVuY3Rpb24gbWFya1Jvb3RNdXRhYmxlUmVhZChyb290LCB1cGRhdGVMYW5lKSB7XG4gIHJvb3QubXV0YWJsZVJlYWRMYW5lcyB8PSB1cGRhdGVMYW5lICYgcm9vdC5wZW5kaW5nTGFuZXM7XG59XG5mdW5jdGlvbiBtYXJrUm9vdEZpbmlzaGVkKHJvb3QsIHJlbWFpbmluZ0xhbmVzKSB7XG4gIHZhciBub0xvbmdlclBlbmRpbmdMYW5lcyA9IHJvb3QucGVuZGluZ0xhbmVzICYgfnJlbWFpbmluZ0xhbmVzO1xuICByb290LnBlbmRpbmdMYW5lcyA9IHJlbWFpbmluZ0xhbmVzOyAvLyBMZXQncyB0cnkgZXZlcnl0aGluZyBhZ2FpblxuXG4gIHJvb3Quc3VzcGVuZGVkTGFuZXMgPSAwO1xuICByb290LnBpbmdlZExhbmVzID0gMDtcbiAgcm9vdC5leHBpcmVkTGFuZXMgJj0gcmVtYWluaW5nTGFuZXM7XG4gIHJvb3QubXV0YWJsZVJlYWRMYW5lcyAmPSByZW1haW5pbmdMYW5lcztcbiAgcm9vdC5lbnRhbmdsZWRMYW5lcyAmPSByZW1haW5pbmdMYW5lcztcbiAgdmFyIGVudGFuZ2xlbWVudHMgPSByb290LmVudGFuZ2xlbWVudHM7XG4gIHZhciBldmVudFRpbWVzID0gcm9vdC5ldmVudFRpbWVzO1xuICB2YXIgZXhwaXJhdGlvblRpbWVzID0gcm9vdC5leHBpcmF0aW9uVGltZXM7IC8vIENsZWFyIHRoZSBsYW5lcyB0aGF0IG5vIGxvbmdlciBoYXZlIHBlbmRpbmcgd29ya1xuXG4gIHZhciBsYW5lcyA9IG5vTG9uZ2VyUGVuZGluZ0xhbmVzO1xuXG4gIHdoaWxlIChsYW5lcyA+IDApIHtcbiAgICB2YXIgaW5kZXggPSBwaWNrQXJiaXRyYXJ5TGFuZUluZGV4KGxhbmVzKTtcbiAgICB2YXIgbGFuZSA9IDEgPDwgaW5kZXg7XG4gICAgZW50YW5nbGVtZW50c1tpbmRleF0gPSBOb0xhbmVzO1xuICAgIGV2ZW50VGltZXNbaW5kZXhdID0gTm9UaW1lc3RhbXA7XG4gICAgZXhwaXJhdGlvblRpbWVzW2luZGV4XSA9IE5vVGltZXN0YW1wO1xuICAgIGxhbmVzICY9IH5sYW5lO1xuICB9XG59XG5mdW5jdGlvbiBtYXJrUm9vdEVudGFuZ2xlZChyb290LCBlbnRhbmdsZWRMYW5lcykge1xuICByb290LmVudGFuZ2xlZExhbmVzIHw9IGVudGFuZ2xlZExhbmVzO1xuICB2YXIgZW50YW5nbGVtZW50cyA9IHJvb3QuZW50YW5nbGVtZW50cztcbiAgdmFyIGxhbmVzID0gZW50YW5nbGVkTGFuZXM7XG5cbiAgd2hpbGUgKGxhbmVzID4gMCkge1xuICAgIHZhciBpbmRleCA9IHBpY2tBcmJpdHJhcnlMYW5lSW5kZXgobGFuZXMpO1xuICAgIHZhciBsYW5lID0gMSA8PCBpbmRleDtcbiAgICBlbnRhbmdsZW1lbnRzW2luZGV4XSB8PSBlbnRhbmdsZWRMYW5lcztcbiAgICBsYW5lcyAmPSB+bGFuZTtcbiAgfVxufVxudmFyIGNsejMyID0gTWF0aC5jbHozMiA/IE1hdGguY2x6MzIgOiBjbHozMkZhbGxiYWNrOyAvLyBDb3VudCBsZWFkaW5nIHplcm9zLiBPbmx5IHVzZWQgb24gbGFuZXMsIHNvIGFzc3VtZSBpbnB1dCBpcyBhbiBpbnRlZ2VyLlxuLy8gQmFzZWQgb246XG4vLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9NYXRoL2NsejMyXG5cbnZhciBsb2cgPSBNYXRoLmxvZztcbnZhciBMTjIgPSBNYXRoLkxOMjtcblxuZnVuY3Rpb24gY2x6MzJGYWxsYmFjayhsYW5lcykge1xuICBpZiAobGFuZXMgPT09IDApIHtcbiAgICByZXR1cm4gMzI7XG4gIH1cblxuICByZXR1cm4gMzEgLSAobG9nKGxhbmVzKSAvIExOMiB8IDApIHwgMDtcbn1cblxuLy8gSW50ZW50aW9uYWxseSBub3QgbmFtZWQgaW1wb3J0cyBiZWNhdXNlIFJvbGx1cCB3b3VsZCB1c2UgZHluYW1pYyBkaXNwYXRjaCBmb3JcbnZhciBVc2VyQmxvY2tpbmdQcmlvcml0eSQxID0gU2NoZWR1bGVyLnVuc3RhYmxlX1VzZXJCbG9ja2luZ1ByaW9yaXR5LFxuICAgIHJ1bldpdGhQcmlvcml0eSA9IFNjaGVkdWxlci51bnN0YWJsZV9ydW5XaXRoUHJpb3JpdHk7IC8vIFRPRE86IGNhbiB3ZSBzdG9wIGV4cG9ydGluZyB0aGVzZT9cblxudmFyIF9lbmFibGVkID0gdHJ1ZTsgLy8gVGhpcyBpcyBleHBvcnRlZCBpbiBGQiBidWlsZHMgZm9yIHVzZSBieSBsZWdhY3kgRkIgbGF5ZXIgaW5mcmEuXG4vLyBXZSdkIGxpa2UgdG8gcmVtb3ZlIHRoaXMgYnV0IGl0J3Mgbm90IGNsZWFyIGlmIHRoaXMgaXMgc2FmZS5cblxuZnVuY3Rpb24gc2V0RW5hYmxlZChlbmFibGVkKSB7XG4gIF9lbmFibGVkID0gISFlbmFibGVkO1xufVxuZnVuY3Rpb24gaXNFbmFibGVkKCkge1xuICByZXR1cm4gX2VuYWJsZWQ7XG59XG5mdW5jdGlvbiBjcmVhdGVFdmVudExpc3RlbmVyV3JhcHBlcldpdGhQcmlvcml0eSh0YXJnZXRDb250YWluZXIsIGRvbUV2ZW50TmFtZSwgZXZlbnRTeXN0ZW1GbGFncykge1xuICB2YXIgZXZlbnRQcmlvcml0eSA9IGdldEV2ZW50UHJpb3JpdHlGb3JQbHVnaW5TeXN0ZW0oZG9tRXZlbnROYW1lKTtcbiAgdmFyIGxpc3RlbmVyV3JhcHBlcjtcblxuICBzd2l0Y2ggKGV2ZW50UHJpb3JpdHkpIHtcbiAgICBjYXNlIERpc2NyZXRlRXZlbnQ6XG4gICAgICBsaXN0ZW5lcldyYXBwZXIgPSBkaXNwYXRjaERpc2NyZXRlRXZlbnQ7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgVXNlckJsb2NraW5nRXZlbnQ6XG4gICAgICBsaXN0ZW5lcldyYXBwZXIgPSBkaXNwYXRjaFVzZXJCbG9ja2luZ1VwZGF0ZTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBDb250aW51b3VzRXZlbnQ6XG4gICAgZGVmYXVsdDpcbiAgICAgIGxpc3RlbmVyV3JhcHBlciA9IGRpc3BhdGNoRXZlbnQ7XG4gICAgICBicmVhaztcbiAgfVxuXG4gIHJldHVybiBsaXN0ZW5lcldyYXBwZXIuYmluZChudWxsLCBkb21FdmVudE5hbWUsIGV2ZW50U3lzdGVtRmxhZ3MsIHRhcmdldENvbnRhaW5lcik7XG59XG5cbmZ1bmN0aW9uIGRpc3BhdGNoRGlzY3JldGVFdmVudChkb21FdmVudE5hbWUsIGV2ZW50U3lzdGVtRmxhZ3MsIGNvbnRhaW5lciwgbmF0aXZlRXZlbnQpIHtcbiAge1xuICAgIGZsdXNoRGlzY3JldGVVcGRhdGVzSWZOZWVkZWQobmF0aXZlRXZlbnQudGltZVN0YW1wKTtcbiAgfVxuXG4gIGRpc2NyZXRlVXBkYXRlcyhkaXNwYXRjaEV2ZW50LCBkb21FdmVudE5hbWUsIGV2ZW50U3lzdGVtRmxhZ3MsIGNvbnRhaW5lciwgbmF0aXZlRXZlbnQpO1xufVxuXG5mdW5jdGlvbiBkaXNwYXRjaFVzZXJCbG9ja2luZ1VwZGF0ZShkb21FdmVudE5hbWUsIGV2ZW50U3lzdGVtRmxhZ3MsIGNvbnRhaW5lciwgbmF0aXZlRXZlbnQpIHtcbiAge1xuICAgIHJ1bldpdGhQcmlvcml0eShVc2VyQmxvY2tpbmdQcmlvcml0eSQxLCBkaXNwYXRjaEV2ZW50LmJpbmQobnVsbCwgZG9tRXZlbnROYW1lLCBldmVudFN5c3RlbUZsYWdzLCBjb250YWluZXIsIG5hdGl2ZUV2ZW50KSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZGlzcGF0Y2hFdmVudChkb21FdmVudE5hbWUsIGV2ZW50U3lzdGVtRmxhZ3MsIHRhcmdldENvbnRhaW5lciwgbmF0aXZlRXZlbnQpIHtcbiAgaWYgKCFfZW5hYmxlZCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBhbGxvd1JlcGxheSA9IHRydWU7XG5cbiAge1xuICAgIC8vIFRPRE86IHJlcGxheWluZyBjYXB0dXJlIHBoYXNlIGV2ZW50cyBpcyBjdXJyZW50bHkgYnJva2VuXG4gICAgLy8gYmVjYXVzZSB3ZSB1c2VkIHRvIGRvIGl0IGR1cmluZyB0b3AtbGV2ZWwgbmF0aXZlIGJ1YmJsZSBoYW5kbGVyc1xuICAgIC8vIGJ1dCBub3cgd2UgdXNlIGRpZmZlcmVudCBidWJibGUgYW5kIGNhcHR1cmUgaGFuZGxlcnMuXG4gICAgLy8gSW4gZWFnZXIgbW9kZSwgd2UgYXR0YWNoIGNhcHR1cmUgbGlzdGVuZXJzIGVhcmx5LCBzbyB3ZSBuZWVkXG4gICAgLy8gdG8gZmlsdGVyIHRoZW0gb3V0IHVudGlsIHdlIGZpeCB0aGUgbG9naWMgdG8gaGFuZGxlIHRoZW0gY29ycmVjdGx5LlxuICAgIC8vIFRoaXMgY291bGQndmUgYmVlbiBvdXRzaWRlIHRoZSBmbGFnIGJ1dCBJIHB1dCBpdCBpbnNpZGUgdG8gcmVkdWNlIHJpc2suXG4gICAgYWxsb3dSZXBsYXkgPSAoZXZlbnRTeXN0ZW1GbGFncyAmIElTX0NBUFRVUkVfUEhBU0UpID09PSAwO1xuICB9XG5cbiAgaWYgKGFsbG93UmVwbGF5ICYmIGhhc1F1ZXVlZERpc2NyZXRlRXZlbnRzKCkgJiYgaXNSZXBsYXlhYmxlRGlzY3JldGVFdmVudChkb21FdmVudE5hbWUpKSB7XG4gICAgLy8gSWYgd2UgYWxyZWFkeSBoYXZlIGEgcXVldWUgb2YgZGlzY3JldGUgZXZlbnRzLCBhbmQgdGhpcyBpcyBhbm90aGVyIGRpc2NyZXRlXG4gICAgLy8gZXZlbnQsIHRoZW4gd2UgY2FuJ3QgZGlzcGF0Y2ggaXQgcmVnYXJkbGVzcyBvZiBpdHMgdGFyZ2V0LCBzaW5jZSB0aGV5XG4gICAgLy8gbmVlZCB0byBkaXNwYXRjaCBpbiBvcmRlci5cbiAgICBxdWV1ZURpc2NyZXRlRXZlbnQobnVsbCwgLy8gRmxhZ3MgdGhhdCB3ZSdyZSBub3QgYWN0dWFsbHkgYmxvY2tlZCBvbiBhbnl0aGluZyBhcyBmYXIgYXMgd2Uga25vdy5cbiAgICBkb21FdmVudE5hbWUsIGV2ZW50U3lzdGVtRmxhZ3MsIHRhcmdldENvbnRhaW5lciwgbmF0aXZlRXZlbnQpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBibG9ja2VkT24gPSBhdHRlbXB0VG9EaXNwYXRjaEV2ZW50KGRvbUV2ZW50TmFtZSwgZXZlbnRTeXN0ZW1GbGFncywgdGFyZ2V0Q29udGFpbmVyLCBuYXRpdmVFdmVudCk7XG5cbiAgaWYgKGJsb2NrZWRPbiA9PT0gbnVsbCkge1xuICAgIC8vIFdlIHN1Y2Nlc3NmdWxseSBkaXNwYXRjaGVkIHRoaXMgZXZlbnQuXG4gICAgaWYgKGFsbG93UmVwbGF5KSB7XG4gICAgICBjbGVhcklmQ29udGludW91c0V2ZW50KGRvbUV2ZW50TmFtZSwgbmF0aXZlRXZlbnQpO1xuICAgIH1cblxuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChhbGxvd1JlcGxheSkge1xuICAgIGlmIChpc1JlcGxheWFibGVEaXNjcmV0ZUV2ZW50KGRvbUV2ZW50TmFtZSkpIHtcbiAgICAgIC8vIFRoaXMgdGhpcyB0byBiZSByZXBsYXllZCBsYXRlciBvbmNlIHRoZSB0YXJnZXQgaXMgYXZhaWxhYmxlLlxuICAgICAgcXVldWVEaXNjcmV0ZUV2ZW50KGJsb2NrZWRPbiwgZG9tRXZlbnROYW1lLCBldmVudFN5c3RlbUZsYWdzLCB0YXJnZXRDb250YWluZXIsIG5hdGl2ZUV2ZW50KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAocXVldWVJZkNvbnRpbnVvdXNFdmVudChibG9ja2VkT24sIGRvbUV2ZW50TmFtZSwgZXZlbnRTeXN0ZW1GbGFncywgdGFyZ2V0Q29udGFpbmVyLCBuYXRpdmVFdmVudCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIFdlIG5lZWQgdG8gY2xlYXIgb25seSBpZiB3ZSBkaWRuJ3QgcXVldWUgYmVjYXVzZVxuICAgIC8vIHF1ZXVlaW5nIGlzIGFjY3VtbXVsYXRpdmUuXG5cblxuICAgIGNsZWFySWZDb250aW51b3VzRXZlbnQoZG9tRXZlbnROYW1lLCBuYXRpdmVFdmVudCk7XG4gIH0gLy8gVGhpcyBpcyBub3QgcmVwbGF5YWJsZSBzbyB3ZSdsbCBpbnZva2UgaXQgYnV0IHdpdGhvdXQgYSB0YXJnZXQsXG4gIC8vIGluIGNhc2UgdGhlIGV2ZW50IHN5c3RlbSBuZWVkcyB0byB0cmFjZSBpdC5cblxuXG4gIGRpc3BhdGNoRXZlbnRGb3JQbHVnaW5FdmVudFN5c3RlbShkb21FdmVudE5hbWUsIGV2ZW50U3lzdGVtRmxhZ3MsIG5hdGl2ZUV2ZW50LCBudWxsLCB0YXJnZXRDb250YWluZXIpO1xufSAvLyBBdHRlbXB0IGRpc3BhdGNoaW5nIGFuIGV2ZW50LiBSZXR1cm5zIGEgU3VzcGVuc2VJbnN0YW5jZSBvciBDb250YWluZXIgaWYgaXQncyBibG9ja2VkLlxuXG5mdW5jdGlvbiBhdHRlbXB0VG9EaXNwYXRjaEV2ZW50KGRvbUV2ZW50TmFtZSwgZXZlbnRTeXN0ZW1GbGFncywgdGFyZ2V0Q29udGFpbmVyLCBuYXRpdmVFdmVudCkge1xuICAvLyBUT0RPOiBXYXJuIGlmIF9lbmFibGVkIGlzIGZhbHNlLlxuICB2YXIgbmF0aXZlRXZlbnRUYXJnZXQgPSBnZXRFdmVudFRhcmdldChuYXRpdmVFdmVudCk7XG4gIHZhciB0YXJnZXRJbnN0ID0gZ2V0Q2xvc2VzdEluc3RhbmNlRnJvbU5vZGUobmF0aXZlRXZlbnRUYXJnZXQpO1xuXG4gIGlmICh0YXJnZXRJbnN0ICE9PSBudWxsKSB7XG4gICAgdmFyIG5lYXJlc3RNb3VudGVkID0gZ2V0TmVhcmVzdE1vdW50ZWRGaWJlcih0YXJnZXRJbnN0KTtcblxuICAgIGlmIChuZWFyZXN0TW91bnRlZCA9PT0gbnVsbCkge1xuICAgICAgLy8gVGhpcyB0cmVlIGhhcyBiZWVuIHVubW91bnRlZCBhbHJlYWR5LiBEaXNwYXRjaCB3aXRob3V0IGEgdGFyZ2V0LlxuICAgICAgdGFyZ2V0SW5zdCA9IG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciB0YWcgPSBuZWFyZXN0TW91bnRlZC50YWc7XG5cbiAgICAgIGlmICh0YWcgPT09IFN1c3BlbnNlQ29tcG9uZW50KSB7XG4gICAgICAgIHZhciBpbnN0YW5jZSA9IGdldFN1c3BlbnNlSW5zdGFuY2VGcm9tRmliZXIobmVhcmVzdE1vdW50ZWQpO1xuXG4gICAgICAgIGlmIChpbnN0YW5jZSAhPT0gbnVsbCkge1xuICAgICAgICAgIC8vIFF1ZXVlIHRoZSBldmVudCB0byBiZSByZXBsYXllZCBsYXRlci4gQWJvcnQgZGlzcGF0Y2hpbmcgc2luY2Ugd2VcbiAgICAgICAgICAvLyBkb24ndCB3YW50IHRoaXMgZXZlbnQgZGlzcGF0Y2hlZCB0d2ljZSB0aHJvdWdoIHRoZSBldmVudCBzeXN0ZW0uXG4gICAgICAgICAgLy8gVE9ETzogSWYgdGhpcyBpcyB0aGUgZmlyc3QgZGlzY3JldGUgZXZlbnQgaW4gdGhlIHF1ZXVlLiBTY2hlZHVsZSBhbiBpbmNyZWFzZWRcbiAgICAgICAgICAvLyBwcmlvcml0eSBmb3IgdGhpcyBib3VuZGFyeS5cbiAgICAgICAgICByZXR1cm4gaW5zdGFuY2U7XG4gICAgICAgIH0gLy8gVGhpcyBzaG91bGRuJ3QgaGFwcGVuLCBzb21ldGhpbmcgd2VudCB3cm9uZyBidXQgdG8gYXZvaWQgYmxvY2tpbmdcbiAgICAgICAgLy8gdGhlIHdob2xlIHN5c3RlbSwgZGlzcGF0Y2ggdGhlIGV2ZW50IHdpdGhvdXQgYSB0YXJnZXQuXG4gICAgICAgIC8vIFRPRE86IFdhcm4uXG5cblxuICAgICAgICB0YXJnZXRJbnN0ID0gbnVsbDtcbiAgICAgIH0gZWxzZSBpZiAodGFnID09PSBIb3N0Um9vdCkge1xuICAgICAgICB2YXIgcm9vdCA9IG5lYXJlc3RNb3VudGVkLnN0YXRlTm9kZTtcblxuICAgICAgICBpZiAocm9vdC5oeWRyYXRlKSB7XG4gICAgICAgICAgLy8gSWYgdGhpcyBoYXBwZW5zIGR1cmluZyBhIHJlcGxheSBzb21ldGhpbmcgd2VudCB3cm9uZyBhbmQgaXQgbWlnaHQgYmxvY2tcbiAgICAgICAgICAvLyB0aGUgd2hvbGUgc3lzdGVtLlxuICAgICAgICAgIHJldHVybiBnZXRDb250YWluZXJGcm9tRmliZXIobmVhcmVzdE1vdW50ZWQpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGFyZ2V0SW5zdCA9IG51bGw7XG4gICAgICB9IGVsc2UgaWYgKG5lYXJlc3RNb3VudGVkICE9PSB0YXJnZXRJbnN0KSB7XG4gICAgICAgIC8vIElmIHdlIGdldCBhbiBldmVudCAoZXg6IGltZyBvbmxvYWQpIGJlZm9yZSBjb21taXR0aW5nIHRoYXRcbiAgICAgICAgLy8gY29tcG9uZW50J3MgbW91bnQsIGlnbm9yZSBpdCBmb3Igbm93ICh0aGF0IGlzLCB0cmVhdCBpdCBhcyBpZiBpdCB3YXMgYW5cbiAgICAgICAgLy8gZXZlbnQgb24gYSBub24tUmVhY3QgdHJlZSkuIFdlIG1pZ2h0IGFsc28gY29uc2lkZXIgcXVldWVpbmcgZXZlbnRzIGFuZFxuICAgICAgICAvLyBkaXNwYXRjaGluZyB0aGVtIGFmdGVyIHRoZSBtb3VudC5cbiAgICAgICAgdGFyZ2V0SW5zdCA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZGlzcGF0Y2hFdmVudEZvclBsdWdpbkV2ZW50U3lzdGVtKGRvbUV2ZW50TmFtZSwgZXZlbnRTeXN0ZW1GbGFncywgbmF0aXZlRXZlbnQsIHRhcmdldEluc3QsIHRhcmdldENvbnRhaW5lcik7IC8vIFdlJ3JlIG5vdCBibG9ja2VkIG9uIGFueXRoaW5nLlxuXG4gIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiBhZGRFdmVudEJ1YmJsZUxpc3RlbmVyKHRhcmdldCwgZXZlbnRUeXBlLCBsaXN0ZW5lcikge1xuICB0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcihldmVudFR5cGUsIGxpc3RlbmVyLCBmYWxzZSk7XG4gIHJldHVybiBsaXN0ZW5lcjtcbn1cbmZ1bmN0aW9uIGFkZEV2ZW50Q2FwdHVyZUxpc3RlbmVyKHRhcmdldCwgZXZlbnRUeXBlLCBsaXN0ZW5lcikge1xuICB0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcihldmVudFR5cGUsIGxpc3RlbmVyLCB0cnVlKTtcbiAgcmV0dXJuIGxpc3RlbmVyO1xufVxuZnVuY3Rpb24gYWRkRXZlbnRDYXB0dXJlTGlzdGVuZXJXaXRoUGFzc2l2ZUZsYWcodGFyZ2V0LCBldmVudFR5cGUsIGxpc3RlbmVyLCBwYXNzaXZlKSB7XG4gIHRhcmdldC5hZGRFdmVudExpc3RlbmVyKGV2ZW50VHlwZSwgbGlzdGVuZXIsIHtcbiAgICBjYXB0dXJlOiB0cnVlLFxuICAgIHBhc3NpdmU6IHBhc3NpdmVcbiAgfSk7XG4gIHJldHVybiBsaXN0ZW5lcjtcbn1cbmZ1bmN0aW9uIGFkZEV2ZW50QnViYmxlTGlzdGVuZXJXaXRoUGFzc2l2ZUZsYWcodGFyZ2V0LCBldmVudFR5cGUsIGxpc3RlbmVyLCBwYXNzaXZlKSB7XG4gIHRhcmdldC5hZGRFdmVudExpc3RlbmVyKGV2ZW50VHlwZSwgbGlzdGVuZXIsIHtcbiAgICBwYXNzaXZlOiBwYXNzaXZlXG4gIH0pO1xuICByZXR1cm4gbGlzdGVuZXI7XG59XG5cbi8qKlxuICogVGhlc2UgdmFyaWFibGVzIHN0b3JlIGluZm9ybWF0aW9uIGFib3V0IHRleHQgY29udGVudCBvZiBhIHRhcmdldCBub2RlLFxuICogYWxsb3dpbmcgY29tcGFyaXNvbiBvZiBjb250ZW50IGJlZm9yZSBhbmQgYWZ0ZXIgYSBnaXZlbiBldmVudC5cbiAqXG4gKiBJZGVudGlmeSB0aGUgbm9kZSB3aGVyZSBzZWxlY3Rpb24gY3VycmVudGx5IGJlZ2lucywgdGhlbiBvYnNlcnZlXG4gKiBib3RoIGl0cyB0ZXh0IGNvbnRlbnQgYW5kIGl0cyBjdXJyZW50IHBvc2l0aW9uIGluIHRoZSBET00uIFNpbmNlIHRoZVxuICogYnJvd3NlciBtYXkgbmF0aXZlbHkgcmVwbGFjZSB0aGUgdGFyZ2V0IG5vZGUgZHVyaW5nIGNvbXBvc2l0aW9uLCB3ZSBjYW5cbiAqIHVzZSBpdHMgcG9zaXRpb24gdG8gZmluZCBpdHMgcmVwbGFjZW1lbnQuXG4gKlxuICpcbiAqL1xudmFyIHJvb3QgPSBudWxsO1xudmFyIHN0YXJ0VGV4dCA9IG51bGw7XG52YXIgZmFsbGJhY2tUZXh0ID0gbnVsbDtcbmZ1bmN0aW9uIGluaXRpYWxpemUobmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgcm9vdCA9IG5hdGl2ZUV2ZW50VGFyZ2V0O1xuICBzdGFydFRleHQgPSBnZXRUZXh0KCk7XG4gIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gcmVzZXQoKSB7XG4gIHJvb3QgPSBudWxsO1xuICBzdGFydFRleHQgPSBudWxsO1xuICBmYWxsYmFja1RleHQgPSBudWxsO1xufVxuZnVuY3Rpb24gZ2V0RGF0YSgpIHtcbiAgaWYgKGZhbGxiYWNrVGV4dCkge1xuICAgIHJldHVybiBmYWxsYmFja1RleHQ7XG4gIH1cblxuICB2YXIgc3RhcnQ7XG4gIHZhciBzdGFydFZhbHVlID0gc3RhcnRUZXh0O1xuICB2YXIgc3RhcnRMZW5ndGggPSBzdGFydFZhbHVlLmxlbmd0aDtcbiAgdmFyIGVuZDtcbiAgdmFyIGVuZFZhbHVlID0gZ2V0VGV4dCgpO1xuICB2YXIgZW5kTGVuZ3RoID0gZW5kVmFsdWUubGVuZ3RoO1xuXG4gIGZvciAoc3RhcnQgPSAwOyBzdGFydCA8IHN0YXJ0TGVuZ3RoOyBzdGFydCsrKSB7XG4gICAgaWYgKHN0YXJ0VmFsdWVbc3RhcnRdICE9PSBlbmRWYWx1ZVtzdGFydF0pIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHZhciBtaW5FbmQgPSBzdGFydExlbmd0aCAtIHN0YXJ0O1xuXG4gIGZvciAoZW5kID0gMTsgZW5kIDw9IG1pbkVuZDsgZW5kKyspIHtcbiAgICBpZiAoc3RhcnRWYWx1ZVtzdGFydExlbmd0aCAtIGVuZF0gIT09IGVuZFZhbHVlW2VuZExlbmd0aCAtIGVuZF0pIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHZhciBzbGljZVRhaWwgPSBlbmQgPiAxID8gMSAtIGVuZCA6IHVuZGVmaW5lZDtcbiAgZmFsbGJhY2tUZXh0ID0gZW5kVmFsdWUuc2xpY2Uoc3RhcnQsIHNsaWNlVGFpbCk7XG4gIHJldHVybiBmYWxsYmFja1RleHQ7XG59XG5mdW5jdGlvbiBnZXRUZXh0KCkge1xuICBpZiAoJ3ZhbHVlJyBpbiByb290KSB7XG4gICAgcmV0dXJuIHJvb3QudmFsdWU7XG4gIH1cblxuICByZXR1cm4gcm9vdC50ZXh0Q29udGVudDtcbn1cblxuLyoqXG4gKiBgY2hhckNvZGVgIHJlcHJlc2VudHMgdGhlIGFjdHVhbCBcImNoYXJhY3RlciBjb2RlXCIgYW5kIGlzIHNhZmUgdG8gdXNlIHdpdGhcbiAqIGBTdHJpbmcuZnJvbUNoYXJDb2RlYC4gQXMgc3VjaCwgb25seSBrZXlzIHRoYXQgY29ycmVzcG9uZCB0byBwcmludGFibGVcbiAqIGNoYXJhY3RlcnMgcHJvZHVjZSBhIHZhbGlkIGBjaGFyQ29kZWAsIHRoZSBvbmx5IGV4Y2VwdGlvbiB0byB0aGlzIGlzIEVudGVyLlxuICogVGhlIFRhYi1rZXkgaXMgY29uc2lkZXJlZCBub24tcHJpbnRhYmxlIGFuZCBkb2VzIG5vdCBoYXZlIGEgYGNoYXJDb2RlYCxcbiAqIHByZXN1bWFibHkgYmVjYXVzZSBpdCBkb2VzIG5vdCBwcm9kdWNlIGEgdGFiLWNoYXJhY3RlciBpbiBicm93c2Vycy5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IE5vcm1hbGl6ZWQgYGNoYXJDb2RlYCBwcm9wZXJ0eS5cbiAqL1xuZnVuY3Rpb24gZ2V0RXZlbnRDaGFyQ29kZShuYXRpdmVFdmVudCkge1xuICB2YXIgY2hhckNvZGU7XG4gIHZhciBrZXlDb2RlID0gbmF0aXZlRXZlbnQua2V5Q29kZTtcblxuICBpZiAoJ2NoYXJDb2RlJyBpbiBuYXRpdmVFdmVudCkge1xuICAgIGNoYXJDb2RlID0gbmF0aXZlRXZlbnQuY2hhckNvZGU7IC8vIEZGIGRvZXMgbm90IHNldCBgY2hhckNvZGVgIGZvciB0aGUgRW50ZXIta2V5LCBjaGVjayBhZ2FpbnN0IGBrZXlDb2RlYC5cblxuICAgIGlmIChjaGFyQ29kZSA9PT0gMCAmJiBrZXlDb2RlID09PSAxMykge1xuICAgICAgY2hhckNvZGUgPSAxMztcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gSUU4IGRvZXMgbm90IGltcGxlbWVudCBgY2hhckNvZGVgLCBidXQgYGtleUNvZGVgIGhhcyB0aGUgY29ycmVjdCB2YWx1ZS5cbiAgICBjaGFyQ29kZSA9IGtleUNvZGU7XG4gIH0gLy8gSUUgYW5kIEVkZ2UgKG9uIFdpbmRvd3MpIGFuZCBDaHJvbWUgLyBTYWZhcmkgKG9uIFdpbmRvd3MgYW5kIExpbnV4KVxuICAvLyByZXBvcnQgRW50ZXIgYXMgY2hhckNvZGUgMTAgd2hlbiBjdHJsIGlzIHByZXNzZWQuXG5cblxuICBpZiAoY2hhckNvZGUgPT09IDEwKSB7XG4gICAgY2hhckNvZGUgPSAxMztcbiAgfSAvLyBTb21lIG5vbi1wcmludGFibGUga2V5cyBhcmUgcmVwb3J0ZWQgaW4gYGNoYXJDb2RlYC9ga2V5Q29kZWAsIGRpc2NhcmQgdGhlbS5cbiAgLy8gTXVzdCBub3QgZGlzY2FyZCB0aGUgKG5vbi0pcHJpbnRhYmxlIEVudGVyLWtleS5cblxuXG4gIGlmIChjaGFyQ29kZSA+PSAzMiB8fCBjaGFyQ29kZSA9PT0gMTMpIHtcbiAgICByZXR1cm4gY2hhckNvZGU7XG4gIH1cblxuICByZXR1cm4gMDtcbn1cblxuZnVuY3Rpb24gZnVuY3Rpb25UaGF0UmV0dXJuc1RydWUoKSB7XG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBmdW5jdGlvblRoYXRSZXR1cm5zRmFsc2UoKSB7XG4gIHJldHVybiBmYWxzZTtcbn0gLy8gVGhpcyBpcyBpbnRlbnRpb25hbGx5IGEgZmFjdG9yeSBzbyB0aGF0IHdlIGhhdmUgZGlmZmVyZW50IHJldHVybmVkIGNvbnN0cnVjdG9ycy5cbi8vIElmIHdlIGhhZCBhIHNpbmdsZSBjb25zdHJ1Y3RvciwgaXQgd291bGQgYmUgbWVnYW1vcnBoaWMgYW5kIGVuZ2luZXMgd291bGQgZGVvcHQuXG5cblxuZnVuY3Rpb24gY3JlYXRlU3ludGhldGljRXZlbnQoSW50ZXJmYWNlKSB7XG4gIC8qKlxuICAgKiBTeW50aGV0aWMgZXZlbnRzIGFyZSBkaXNwYXRjaGVkIGJ5IGV2ZW50IHBsdWdpbnMsIHR5cGljYWxseSBpbiByZXNwb25zZSB0byBhXG4gICAqIHRvcC1sZXZlbCBldmVudCBkZWxlZ2F0aW9uIGhhbmRsZXIuXG4gICAqXG4gICAqIFRoZXNlIHN5c3RlbXMgc2hvdWxkIGdlbmVyYWxseSB1c2UgcG9vbGluZyB0byByZWR1Y2UgdGhlIGZyZXF1ZW5jeSBvZiBnYXJiYWdlXG4gICAqIGNvbGxlY3Rpb24uIFRoZSBzeXN0ZW0gc2hvdWxkIGNoZWNrIGBpc1BlcnNpc3RlbnRgIHRvIGRldGVybWluZSB3aGV0aGVyIHRoZVxuICAgKiBldmVudCBzaG91bGQgYmUgcmVsZWFzZWQgaW50byB0aGUgcG9vbCBhZnRlciBiZWluZyBkaXNwYXRjaGVkLiBVc2VycyB0aGF0XG4gICAqIG5lZWQgYSBwZXJzaXN0ZWQgZXZlbnQgc2hvdWxkIGludm9rZSBgcGVyc2lzdGAuXG4gICAqXG4gICAqIFN5bnRoZXRpYyBldmVudHMgKGFuZCBzdWJjbGFzc2VzKSBpbXBsZW1lbnQgdGhlIERPTSBMZXZlbCAzIEV2ZW50cyBBUEkgYnlcbiAgICogbm9ybWFsaXppbmcgYnJvd3NlciBxdWlya3MuIFN1YmNsYXNzZXMgZG8gbm90IG5lY2Vzc2FyaWx5IGhhdmUgdG8gaW1wbGVtZW50IGFcbiAgICogRE9NIGludGVyZmFjZTsgY3VzdG9tIGFwcGxpY2F0aW9uLXNwZWNpZmljIGV2ZW50cyBjYW4gYWxzbyBzdWJjbGFzcyB0aGlzLlxuICAgKi9cbiAgZnVuY3Rpb24gU3ludGhldGljQmFzZUV2ZW50KHJlYWN0TmFtZSwgcmVhY3RFdmVudFR5cGUsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICAgIHRoaXMuX3JlYWN0TmFtZSA9IHJlYWN0TmFtZTtcbiAgICB0aGlzLl90YXJnZXRJbnN0ID0gdGFyZ2V0SW5zdDtcbiAgICB0aGlzLnR5cGUgPSByZWFjdEV2ZW50VHlwZTtcbiAgICB0aGlzLm5hdGl2ZUV2ZW50ID0gbmF0aXZlRXZlbnQ7XG4gICAgdGhpcy50YXJnZXQgPSBuYXRpdmVFdmVudFRhcmdldDtcbiAgICB0aGlzLmN1cnJlbnRUYXJnZXQgPSBudWxsO1xuXG4gICAgZm9yICh2YXIgX3Byb3BOYW1lIGluIEludGVyZmFjZSkge1xuICAgICAgaWYgKCFJbnRlcmZhY2UuaGFzT3duUHJvcGVydHkoX3Byb3BOYW1lKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgdmFyIG5vcm1hbGl6ZSA9IEludGVyZmFjZVtfcHJvcE5hbWVdO1xuXG4gICAgICBpZiAobm9ybWFsaXplKSB7XG4gICAgICAgIHRoaXNbX3Byb3BOYW1lXSA9IG5vcm1hbGl6ZShuYXRpdmVFdmVudCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzW19wcm9wTmFtZV0gPSBuYXRpdmVFdmVudFtfcHJvcE5hbWVdO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBkZWZhdWx0UHJldmVudGVkID0gbmF0aXZlRXZlbnQuZGVmYXVsdFByZXZlbnRlZCAhPSBudWxsID8gbmF0aXZlRXZlbnQuZGVmYXVsdFByZXZlbnRlZCA6IG5hdGl2ZUV2ZW50LnJldHVyblZhbHVlID09PSBmYWxzZTtcblxuICAgIGlmIChkZWZhdWx0UHJldmVudGVkKSB7XG4gICAgICB0aGlzLmlzRGVmYXVsdFByZXZlbnRlZCA9IGZ1bmN0aW9uVGhhdFJldHVybnNUcnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmlzRGVmYXVsdFByZXZlbnRlZCA9IGZ1bmN0aW9uVGhhdFJldHVybnNGYWxzZTtcbiAgICB9XG5cbiAgICB0aGlzLmlzUHJvcGFnYXRpb25TdG9wcGVkID0gZnVuY3Rpb25UaGF0UmV0dXJuc0ZhbHNlO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgX2Fzc2lnbihTeW50aGV0aWNCYXNlRXZlbnQucHJvdG90eXBlLCB7XG4gICAgcHJldmVudERlZmF1bHQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuZGVmYXVsdFByZXZlbnRlZCA9IHRydWU7XG4gICAgICB2YXIgZXZlbnQgPSB0aGlzLm5hdGl2ZUV2ZW50O1xuXG4gICAgICBpZiAoIWV2ZW50KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKGV2ZW50LnByZXZlbnREZWZhdWx0KSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7IC8vICRGbG93Rml4TWUgLSBmbG93IGlzIG5vdCBhd2FyZSBvZiBgdW5rbm93bmAgaW4gSUVcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGV2ZW50LnJldHVyblZhbHVlICE9PSAndW5rbm93bicpIHtcbiAgICAgICAgZXZlbnQucmV0dXJuVmFsdWUgPSBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5pc0RlZmF1bHRQcmV2ZW50ZWQgPSBmdW5jdGlvblRoYXRSZXR1cm5zVHJ1ZTtcbiAgICB9LFxuICAgIHN0b3BQcm9wYWdhdGlvbjogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGV2ZW50ID0gdGhpcy5uYXRpdmVFdmVudDtcblxuICAgICAgaWYgKCFldmVudCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChldmVudC5zdG9wUHJvcGFnYXRpb24pIHtcbiAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7IC8vICRGbG93Rml4TWUgLSBmbG93IGlzIG5vdCBhd2FyZSBvZiBgdW5rbm93bmAgaW4gSUVcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGV2ZW50LmNhbmNlbEJ1YmJsZSAhPT0gJ3Vua25vd24nKSB7XG4gICAgICAgIC8vIFRoZSBDaGFuZ2VFdmVudFBsdWdpbiByZWdpc3RlcnMgYSBcInByb3BlcnR5Y2hhbmdlXCIgZXZlbnQgZm9yXG4gICAgICAgIC8vIElFLiBUaGlzIGV2ZW50IGRvZXMgbm90IHN1cHBvcnQgYnViYmxpbmcgb3IgY2FuY2VsbGluZywgYW5kXG4gICAgICAgIC8vIGFueSByZWZlcmVuY2VzIHRvIGNhbmNlbEJ1YmJsZSB0aHJvdyBcIk1lbWJlciBub3QgZm91bmRcIi4gIEFcbiAgICAgICAgLy8gdHlwZW9mIGNoZWNrIG9mIFwidW5rbm93blwiIGNpcmN1bXZlbnRzIHRoaXMgaXNzdWUgKGFuZCBpcyBhbHNvXG4gICAgICAgIC8vIElFIHNwZWNpZmljKS5cbiAgICAgICAgZXZlbnQuY2FuY2VsQnViYmxlID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5pc1Byb3BhZ2F0aW9uU3RvcHBlZCA9IGZ1bmN0aW9uVGhhdFJldHVybnNUcnVlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBXZSByZWxlYXNlIGFsbCBkaXNwYXRjaGVkIGBTeW50aGV0aWNFdmVudGBzIGFmdGVyIGVhY2ggZXZlbnQgbG9vcCwgYWRkaW5nXG4gICAgICogdGhlbSBiYWNrIGludG8gdGhlIHBvb2wuIFRoaXMgYWxsb3dzIGEgd2F5IHRvIGhvbGQgb250byBhIHJlZmVyZW5jZSB0aGF0XG4gICAgICogd29uJ3QgYmUgYWRkZWQgYmFjayBpbnRvIHRoZSBwb29sLlxuICAgICAqL1xuICAgIHBlcnNpc3Q6IGZ1bmN0aW9uICgpIHsvLyBNb2Rlcm4gZXZlbnQgc3lzdGVtIGRvZXNuJ3QgdXNlIHBvb2xpbmcuXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiB0aGlzIGV2ZW50IHNob3VsZCBiZSByZWxlYXNlZCBiYWNrIGludG8gdGhlIHBvb2wuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoaXMgc2hvdWxkIG5vdCBiZSByZWxlYXNlZCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgICAqL1xuICAgIGlzUGVyc2lzdGVudDogZnVuY3Rpb25UaGF0UmV0dXJuc1RydWVcbiAgfSk7XG5cbiAgcmV0dXJuIFN5bnRoZXRpY0Jhc2VFdmVudDtcbn1cbi8qKlxuICogQGludGVyZmFjZSBFdmVudFxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMvXG4gKi9cblxuXG52YXIgRXZlbnRJbnRlcmZhY2UgPSB7XG4gIGV2ZW50UGhhc2U6IDAsXG4gIGJ1YmJsZXM6IDAsXG4gIGNhbmNlbGFibGU6IDAsXG4gIHRpbWVTdGFtcDogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgcmV0dXJuIGV2ZW50LnRpbWVTdGFtcCB8fCBEYXRlLm5vdygpO1xuICB9LFxuICBkZWZhdWx0UHJldmVudGVkOiAwLFxuICBpc1RydXN0ZWQ6IDBcbn07XG52YXIgU3ludGhldGljRXZlbnQgPSBjcmVhdGVTeW50aGV0aWNFdmVudChFdmVudEludGVyZmFjZSk7XG5cbnZhciBVSUV2ZW50SW50ZXJmYWNlID0gX2Fzc2lnbih7fSwgRXZlbnRJbnRlcmZhY2UsIHtcbiAgdmlldzogMCxcbiAgZGV0YWlsOiAwXG59KTtcblxudmFyIFN5bnRoZXRpY1VJRXZlbnQgPSBjcmVhdGVTeW50aGV0aWNFdmVudChVSUV2ZW50SW50ZXJmYWNlKTtcbnZhciBsYXN0TW92ZW1lbnRYO1xudmFyIGxhc3RNb3ZlbWVudFk7XG52YXIgbGFzdE1vdXNlRXZlbnQ7XG5cbmZ1bmN0aW9uIHVwZGF0ZU1vdXNlTW92ZW1lbnRQb2x5ZmlsbFN0YXRlKGV2ZW50KSB7XG4gIGlmIChldmVudCAhPT0gbGFzdE1vdXNlRXZlbnQpIHtcbiAgICBpZiAobGFzdE1vdXNlRXZlbnQgJiYgZXZlbnQudHlwZSA9PT0gJ21vdXNlbW92ZScpIHtcbiAgICAgIGxhc3RNb3ZlbWVudFggPSBldmVudC5zY3JlZW5YIC0gbGFzdE1vdXNlRXZlbnQuc2NyZWVuWDtcbiAgICAgIGxhc3RNb3ZlbWVudFkgPSBldmVudC5zY3JlZW5ZIC0gbGFzdE1vdXNlRXZlbnQuc2NyZWVuWTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGFzdE1vdmVtZW50WCA9IDA7XG4gICAgICBsYXN0TW92ZW1lbnRZID0gMDtcbiAgICB9XG5cbiAgICBsYXN0TW91c2VFdmVudCA9IGV2ZW50O1xuICB9XG59XG4vKipcbiAqIEBpbnRlcmZhY2UgTW91c2VFdmVudFxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMvXG4gKi9cblxuXG52YXIgTW91c2VFdmVudEludGVyZmFjZSA9IF9hc3NpZ24oe30sIFVJRXZlbnRJbnRlcmZhY2UsIHtcbiAgc2NyZWVuWDogMCxcbiAgc2NyZWVuWTogMCxcbiAgY2xpZW50WDogMCxcbiAgY2xpZW50WTogMCxcbiAgcGFnZVg6IDAsXG4gIHBhZ2VZOiAwLFxuICBjdHJsS2V5OiAwLFxuICBzaGlmdEtleTogMCxcbiAgYWx0S2V5OiAwLFxuICBtZXRhS2V5OiAwLFxuICBnZXRNb2RpZmllclN0YXRlOiBnZXRFdmVudE1vZGlmaWVyU3RhdGUsXG4gIGJ1dHRvbjogMCxcbiAgYnV0dG9uczogMCxcbiAgcmVsYXRlZFRhcmdldDogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgaWYgKGV2ZW50LnJlbGF0ZWRUYXJnZXQgPT09IHVuZGVmaW5lZCkgcmV0dXJuIGV2ZW50LmZyb21FbGVtZW50ID09PSBldmVudC5zcmNFbGVtZW50ID8gZXZlbnQudG9FbGVtZW50IDogZXZlbnQuZnJvbUVsZW1lbnQ7XG4gICAgcmV0dXJuIGV2ZW50LnJlbGF0ZWRUYXJnZXQ7XG4gIH0sXG4gIG1vdmVtZW50WDogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgaWYgKCdtb3ZlbWVudFgnIGluIGV2ZW50KSB7XG4gICAgICByZXR1cm4gZXZlbnQubW92ZW1lbnRYO1xuICAgIH1cblxuICAgIHVwZGF0ZU1vdXNlTW92ZW1lbnRQb2x5ZmlsbFN0YXRlKGV2ZW50KTtcbiAgICByZXR1cm4gbGFzdE1vdmVtZW50WDtcbiAgfSxcbiAgbW92ZW1lbnRZOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICBpZiAoJ21vdmVtZW50WScgaW4gZXZlbnQpIHtcbiAgICAgIHJldHVybiBldmVudC5tb3ZlbWVudFk7XG4gICAgfSAvLyBEb24ndCBuZWVkIHRvIGNhbGwgdXBkYXRlTW91c2VNb3ZlbWVudFBvbHlmaWxsU3RhdGUoKSBoZXJlXG4gICAgLy8gYmVjYXVzZSBpdCdzIGd1YXJhbnRlZWQgdG8gaGF2ZSBhbHJlYWR5IHJ1biB3aGVuIG1vdmVtZW50WFxuICAgIC8vIHdhcyBjb3BpZWQuXG5cblxuICAgIHJldHVybiBsYXN0TW92ZW1lbnRZO1xuICB9XG59KTtcblxudmFyIFN5bnRoZXRpY01vdXNlRXZlbnQgPSBjcmVhdGVTeW50aGV0aWNFdmVudChNb3VzZUV2ZW50SW50ZXJmYWNlKTtcbi8qKlxuICogQGludGVyZmFjZSBEcmFnRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtRXZlbnRzL1xuICovXG5cbnZhciBEcmFnRXZlbnRJbnRlcmZhY2UgPSBfYXNzaWduKHt9LCBNb3VzZUV2ZW50SW50ZXJmYWNlLCB7XG4gIGRhdGFUcmFuc2ZlcjogMFxufSk7XG5cbnZhciBTeW50aGV0aWNEcmFnRXZlbnQgPSBjcmVhdGVTeW50aGV0aWNFdmVudChEcmFnRXZlbnRJbnRlcmZhY2UpO1xuLyoqXG4gKiBAaW50ZXJmYWNlIEZvY3VzRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtRXZlbnRzL1xuICovXG5cbnZhciBGb2N1c0V2ZW50SW50ZXJmYWNlID0gX2Fzc2lnbih7fSwgVUlFdmVudEludGVyZmFjZSwge1xuICByZWxhdGVkVGFyZ2V0OiAwXG59KTtcblxudmFyIFN5bnRoZXRpY0ZvY3VzRXZlbnQgPSBjcmVhdGVTeW50aGV0aWNFdmVudChGb2N1c0V2ZW50SW50ZXJmYWNlKTtcbi8qKlxuICogQGludGVyZmFjZSBFdmVudFxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9jc3MzLWFuaW1hdGlvbnMvI0FuaW1hdGlvbkV2ZW50LWludGVyZmFjZVxuICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvQW5pbWF0aW9uRXZlbnRcbiAqL1xuXG52YXIgQW5pbWF0aW9uRXZlbnRJbnRlcmZhY2UgPSBfYXNzaWduKHt9LCBFdmVudEludGVyZmFjZSwge1xuICBhbmltYXRpb25OYW1lOiAwLFxuICBlbGFwc2VkVGltZTogMCxcbiAgcHNldWRvRWxlbWVudDogMFxufSk7XG5cbnZhciBTeW50aGV0aWNBbmltYXRpb25FdmVudCA9IGNyZWF0ZVN5bnRoZXRpY0V2ZW50KEFuaW1hdGlvbkV2ZW50SW50ZXJmYWNlKTtcbi8qKlxuICogQGludGVyZmFjZSBFdmVudFxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9jbGlwYm9hcmQtYXBpcy9cbiAqL1xuXG52YXIgQ2xpcGJvYXJkRXZlbnRJbnRlcmZhY2UgPSBfYXNzaWduKHt9LCBFdmVudEludGVyZmFjZSwge1xuICBjbGlwYm9hcmREYXRhOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICByZXR1cm4gJ2NsaXBib2FyZERhdGEnIGluIGV2ZW50ID8gZXZlbnQuY2xpcGJvYXJkRGF0YSA6IHdpbmRvdy5jbGlwYm9hcmREYXRhO1xuICB9XG59KTtcblxudmFyIFN5bnRoZXRpY0NsaXBib2FyZEV2ZW50ID0gY3JlYXRlU3ludGhldGljRXZlbnQoQ2xpcGJvYXJkRXZlbnRJbnRlcmZhY2UpO1xuLyoqXG4gKiBAaW50ZXJmYWNlIEV2ZW50XG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0zLUV2ZW50cy8jZXZlbnRzLWNvbXBvc2l0aW9uZXZlbnRzXG4gKi9cblxudmFyIENvbXBvc2l0aW9uRXZlbnRJbnRlcmZhY2UgPSBfYXNzaWduKHt9LCBFdmVudEludGVyZmFjZSwge1xuICBkYXRhOiAwXG59KTtcblxudmFyIFN5bnRoZXRpY0NvbXBvc2l0aW9uRXZlbnQgPSBjcmVhdGVTeW50aGV0aWNFdmVudChDb21wb3NpdGlvbkV2ZW50SW50ZXJmYWNlKTtcbi8qKlxuICogQGludGVyZmFjZSBFdmVudFxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi8yMDEzL1dELURPTS1MZXZlbC0zLUV2ZW50cy0yMDEzMTEwNVxuICogICAgICAvI2V2ZW50cy1pbnB1dGV2ZW50c1xuICovXG4vLyBIYXBwZW5zIHRvIHNoYXJlIHRoZSBzYW1lIGxpc3QgZm9yIG5vdy5cblxudmFyIFN5bnRoZXRpY0lucHV0RXZlbnQgPSBTeW50aGV0aWNDb21wb3NpdGlvbkV2ZW50O1xuLyoqXG4gKiBOb3JtYWxpemF0aW9uIG9mIGRlcHJlY2F0ZWQgSFRNTDUgYGtleWAgdmFsdWVzXG4gKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9LZXlib2FyZEV2ZW50I0tleV9uYW1lc1xuICovXG5cbnZhciBub3JtYWxpemVLZXkgPSB7XG4gIEVzYzogJ0VzY2FwZScsXG4gIFNwYWNlYmFyOiAnICcsXG4gIExlZnQ6ICdBcnJvd0xlZnQnLFxuICBVcDogJ0Fycm93VXAnLFxuICBSaWdodDogJ0Fycm93UmlnaHQnLFxuICBEb3duOiAnQXJyb3dEb3duJyxcbiAgRGVsOiAnRGVsZXRlJyxcbiAgV2luOiAnT1MnLFxuICBNZW51OiAnQ29udGV4dE1lbnUnLFxuICBBcHBzOiAnQ29udGV4dE1lbnUnLFxuICBTY3JvbGw6ICdTY3JvbGxMb2NrJyxcbiAgTW96UHJpbnRhYmxlS2V5OiAnVW5pZGVudGlmaWVkJ1xufTtcbi8qKlxuICogVHJhbnNsYXRpb24gZnJvbSBsZWdhY3kgYGtleUNvZGVgIHRvIEhUTUw1IGBrZXlgXG4gKiBPbmx5IHNwZWNpYWwga2V5cyBzdXBwb3J0ZWQsIGFsbCBvdGhlcnMgZGVwZW5kIG9uIGtleWJvYXJkIGxheW91dCBvciBicm93c2VyXG4gKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9LZXlib2FyZEV2ZW50I0tleV9uYW1lc1xuICovXG5cbnZhciB0cmFuc2xhdGVUb0tleSA9IHtcbiAgJzgnOiAnQmFja3NwYWNlJyxcbiAgJzknOiAnVGFiJyxcbiAgJzEyJzogJ0NsZWFyJyxcbiAgJzEzJzogJ0VudGVyJyxcbiAgJzE2JzogJ1NoaWZ0JyxcbiAgJzE3JzogJ0NvbnRyb2wnLFxuICAnMTgnOiAnQWx0JyxcbiAgJzE5JzogJ1BhdXNlJyxcbiAgJzIwJzogJ0NhcHNMb2NrJyxcbiAgJzI3JzogJ0VzY2FwZScsXG4gICczMic6ICcgJyxcbiAgJzMzJzogJ1BhZ2VVcCcsXG4gICczNCc6ICdQYWdlRG93bicsXG4gICczNSc6ICdFbmQnLFxuICAnMzYnOiAnSG9tZScsXG4gICczNyc6ICdBcnJvd0xlZnQnLFxuICAnMzgnOiAnQXJyb3dVcCcsXG4gICczOSc6ICdBcnJvd1JpZ2h0JyxcbiAgJzQwJzogJ0Fycm93RG93bicsXG4gICc0NSc6ICdJbnNlcnQnLFxuICAnNDYnOiAnRGVsZXRlJyxcbiAgJzExMic6ICdGMScsXG4gICcxMTMnOiAnRjInLFxuICAnMTE0JzogJ0YzJyxcbiAgJzExNSc6ICdGNCcsXG4gICcxMTYnOiAnRjUnLFxuICAnMTE3JzogJ0Y2JyxcbiAgJzExOCc6ICdGNycsXG4gICcxMTknOiAnRjgnLFxuICAnMTIwJzogJ0Y5JyxcbiAgJzEyMSc6ICdGMTAnLFxuICAnMTIyJzogJ0YxMScsXG4gICcxMjMnOiAnRjEyJyxcbiAgJzE0NCc6ICdOdW1Mb2NrJyxcbiAgJzE0NSc6ICdTY3JvbGxMb2NrJyxcbiAgJzIyNCc6ICdNZXRhJ1xufTtcbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQHJldHVybiB7c3RyaW5nfSBOb3JtYWxpemVkIGBrZXlgIHByb3BlcnR5LlxuICovXG5cbmZ1bmN0aW9uIGdldEV2ZW50S2V5KG5hdGl2ZUV2ZW50KSB7XG4gIGlmIChuYXRpdmVFdmVudC5rZXkpIHtcbiAgICAvLyBOb3JtYWxpemUgaW5jb25zaXN0ZW50IHZhbHVlcyByZXBvcnRlZCBieSBicm93c2VycyBkdWUgdG9cbiAgICAvLyBpbXBsZW1lbnRhdGlvbnMgb2YgYSB3b3JraW5nIGRyYWZ0IHNwZWNpZmljYXRpb24uXG4gICAgLy8gRmlyZUZveCBpbXBsZW1lbnRzIGBrZXlgIGJ1dCByZXR1cm5zIGBNb3pQcmludGFibGVLZXlgIGZvciBhbGxcbiAgICAvLyBwcmludGFibGUgY2hhcmFjdGVycyAobm9ybWFsaXplZCB0byBgVW5pZGVudGlmaWVkYCksIGlnbm9yZSBpdC5cbiAgICB2YXIga2V5ID0gbm9ybWFsaXplS2V5W25hdGl2ZUV2ZW50LmtleV0gfHwgbmF0aXZlRXZlbnQua2V5O1xuXG4gICAgaWYgKGtleSAhPT0gJ1VuaWRlbnRpZmllZCcpIHtcbiAgICAgIHJldHVybiBrZXk7XG4gICAgfVxuICB9IC8vIEJyb3dzZXIgZG9lcyBub3QgaW1wbGVtZW50IGBrZXlgLCBwb2x5ZmlsbCBhcyBtdWNoIG9mIGl0IGFzIHdlIGNhbi5cblxuXG4gIGlmIChuYXRpdmVFdmVudC50eXBlID09PSAna2V5cHJlc3MnKSB7XG4gICAgdmFyIGNoYXJDb2RlID0gZ2V0RXZlbnRDaGFyQ29kZShuYXRpdmVFdmVudCk7IC8vIFRoZSBlbnRlci1rZXkgaXMgdGVjaG5pY2FsbHkgYm90aCBwcmludGFibGUgYW5kIG5vbi1wcmludGFibGUgYW5kIGNhblxuICAgIC8vIHRodXMgYmUgY2FwdHVyZWQgYnkgYGtleXByZXNzYCwgbm8gb3RoZXIgbm9uLXByaW50YWJsZSBrZXkgc2hvdWxkLlxuXG4gICAgcmV0dXJuIGNoYXJDb2RlID09PSAxMyA/ICdFbnRlcicgOiBTdHJpbmcuZnJvbUNoYXJDb2RlKGNoYXJDb2RlKTtcbiAgfVxuXG4gIGlmIChuYXRpdmVFdmVudC50eXBlID09PSAna2V5ZG93bicgfHwgbmF0aXZlRXZlbnQudHlwZSA9PT0gJ2tleXVwJykge1xuICAgIC8vIFdoaWxlIHVzZXIga2V5Ym9hcmQgbGF5b3V0IGRldGVybWluZXMgdGhlIGFjdHVhbCBtZWFuaW5nIG9mIGVhY2hcbiAgICAvLyBga2V5Q29kZWAgdmFsdWUsIGFsbW9zdCBhbGwgZnVuY3Rpb24ga2V5cyBoYXZlIGEgdW5pdmVyc2FsIHZhbHVlLlxuICAgIHJldHVybiB0cmFuc2xhdGVUb0tleVtuYXRpdmVFdmVudC5rZXlDb2RlXSB8fCAnVW5pZGVudGlmaWVkJztcbiAgfVxuXG4gIHJldHVybiAnJztcbn1cbi8qKlxuICogVHJhbnNsYXRpb24gZnJvbSBtb2RpZmllciBrZXkgdG8gdGhlIGFzc29jaWF0ZWQgcHJvcGVydHkgaW4gdGhlIGV2ZW50LlxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMvI2tleXMtTW9kaWZpZXJzXG4gKi9cblxuXG52YXIgbW9kaWZpZXJLZXlUb1Byb3AgPSB7XG4gIEFsdDogJ2FsdEtleScsXG4gIENvbnRyb2w6ICdjdHJsS2V5JyxcbiAgTWV0YTogJ21ldGFLZXknLFxuICBTaGlmdDogJ3NoaWZ0S2V5J1xufTsgLy8gT2xkZXIgYnJvd3NlcnMgKFNhZmFyaSA8PSAxMCwgaU9TIFNhZmFyaSA8PSAxMC4yKSBkbyBub3Qgc3VwcG9ydFxuLy8gZ2V0TW9kaWZpZXJTdGF0ZS4gSWYgZ2V0TW9kaWZpZXJTdGF0ZSBpcyBub3Qgc3VwcG9ydGVkLCB3ZSBtYXAgaXQgdG8gYSBzZXQgb2Zcbi8vIG1vZGlmaWVyIGtleXMgZXhwb3NlZCBieSB0aGUgZXZlbnQuIEluIHRoaXMgY2FzZSwgTG9jay1rZXlzIGFyZSBub3Qgc3VwcG9ydGVkLlxuXG5mdW5jdGlvbiBtb2RpZmllclN0YXRlR2V0dGVyKGtleUFyZykge1xuICB2YXIgc3ludGhldGljRXZlbnQgPSB0aGlzO1xuICB2YXIgbmF0aXZlRXZlbnQgPSBzeW50aGV0aWNFdmVudC5uYXRpdmVFdmVudDtcblxuICBpZiAobmF0aXZlRXZlbnQuZ2V0TW9kaWZpZXJTdGF0ZSkge1xuICAgIHJldHVybiBuYXRpdmVFdmVudC5nZXRNb2RpZmllclN0YXRlKGtleUFyZyk7XG4gIH1cblxuICB2YXIga2V5UHJvcCA9IG1vZGlmaWVyS2V5VG9Qcm9wW2tleUFyZ107XG4gIHJldHVybiBrZXlQcm9wID8gISFuYXRpdmVFdmVudFtrZXlQcm9wXSA6IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBnZXRFdmVudE1vZGlmaWVyU3RhdGUobmF0aXZlRXZlbnQpIHtcbiAgcmV0dXJuIG1vZGlmaWVyU3RhdGVHZXR0ZXI7XG59XG4vKipcbiAqIEBpbnRlcmZhY2UgS2V5Ym9hcmRFdmVudFxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMvXG4gKi9cblxuXG52YXIgS2V5Ym9hcmRFdmVudEludGVyZmFjZSA9IF9hc3NpZ24oe30sIFVJRXZlbnRJbnRlcmZhY2UsIHtcbiAga2V5OiBnZXRFdmVudEtleSxcbiAgY29kZTogMCxcbiAgbG9jYXRpb246IDAsXG4gIGN0cmxLZXk6IDAsXG4gIHNoaWZ0S2V5OiAwLFxuICBhbHRLZXk6IDAsXG4gIG1ldGFLZXk6IDAsXG4gIHJlcGVhdDogMCxcbiAgbG9jYWxlOiAwLFxuICBnZXRNb2RpZmllclN0YXRlOiBnZXRFdmVudE1vZGlmaWVyU3RhdGUsXG4gIC8vIExlZ2FjeSBJbnRlcmZhY2VcbiAgY2hhckNvZGU6IGZ1bmN0aW9uIChldmVudCkge1xuICAgIC8vIGBjaGFyQ29kZWAgaXMgdGhlIHJlc3VsdCBvZiBhIEtleVByZXNzIGV2ZW50IGFuZCByZXByZXNlbnRzIHRoZSB2YWx1ZSBvZlxuICAgIC8vIHRoZSBhY3R1YWwgcHJpbnRhYmxlIGNoYXJhY3Rlci5cbiAgICAvLyBLZXlQcmVzcyBpcyBkZXByZWNhdGVkLCBidXQgaXRzIHJlcGxhY2VtZW50IGlzIG5vdCB5ZXQgZmluYWwgYW5kIG5vdFxuICAgIC8vIGltcGxlbWVudGVkIGluIGFueSBtYWpvciBicm93c2VyLiBPbmx5IEtleVByZXNzIGhhcyBjaGFyQ29kZS5cbiAgICBpZiAoZXZlbnQudHlwZSA9PT0gJ2tleXByZXNzJykge1xuICAgICAgcmV0dXJuIGdldEV2ZW50Q2hhckNvZGUoZXZlbnQpO1xuICAgIH1cblxuICAgIHJldHVybiAwO1xuICB9LFxuICBrZXlDb2RlOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAvLyBga2V5Q29kZWAgaXMgdGhlIHJlc3VsdCBvZiBhIEtleURvd24vVXAgZXZlbnQgYW5kIHJlcHJlc2VudHMgdGhlIHZhbHVlIG9mXG4gICAgLy8gcGh5c2ljYWwga2V5Ym9hcmQga2V5LlxuICAgIC8vIFRoZSBhY3R1YWwgbWVhbmluZyBvZiB0aGUgdmFsdWUgZGVwZW5kcyBvbiB0aGUgdXNlcnMnIGtleWJvYXJkIGxheW91dFxuICAgIC8vIHdoaWNoIGNhbm5vdCBiZSBkZXRlY3RlZC4gQXNzdW1pbmcgdGhhdCBpdCBpcyBhIFVTIGtleWJvYXJkIGxheW91dFxuICAgIC8vIHByb3ZpZGVzIGEgc3VycHJpc2luZ2x5IGFjY3VyYXRlIG1hcHBpbmcgZm9yIFVTIGFuZCBFdXJvcGVhbiB1c2Vycy5cbiAgICAvLyBEdWUgdG8gdGhpcywgaXQgaXMgbGVmdCB0byB0aGUgdXNlciB0byBpbXBsZW1lbnQgYXQgdGhpcyB0aW1lLlxuICAgIGlmIChldmVudC50eXBlID09PSAna2V5ZG93bicgfHwgZXZlbnQudHlwZSA9PT0gJ2tleXVwJykge1xuICAgICAgcmV0dXJuIGV2ZW50LmtleUNvZGU7XG4gICAgfVxuXG4gICAgcmV0dXJuIDA7XG4gIH0sXG4gIHdoaWNoOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAvLyBgd2hpY2hgIGlzIGFuIGFsaWFzIGZvciBlaXRoZXIgYGtleUNvZGVgIG9yIGBjaGFyQ29kZWAgZGVwZW5kaW5nIG9uIHRoZVxuICAgIC8vIHR5cGUgb2YgdGhlIGV2ZW50LlxuICAgIGlmIChldmVudC50eXBlID09PSAna2V5cHJlc3MnKSB7XG4gICAgICByZXR1cm4gZ2V0RXZlbnRDaGFyQ29kZShldmVudCk7XG4gICAgfVxuXG4gICAgaWYgKGV2ZW50LnR5cGUgPT09ICdrZXlkb3duJyB8fCBldmVudC50eXBlID09PSAna2V5dXAnKSB7XG4gICAgICByZXR1cm4gZXZlbnQua2V5Q29kZTtcbiAgICB9XG5cbiAgICByZXR1cm4gMDtcbiAgfVxufSk7XG5cbnZhciBTeW50aGV0aWNLZXlib2FyZEV2ZW50ID0gY3JlYXRlU3ludGhldGljRXZlbnQoS2V5Ym9hcmRFdmVudEludGVyZmFjZSk7XG4vKipcbiAqIEBpbnRlcmZhY2UgUG9pbnRlckV2ZW50XG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL3BvaW50ZXJldmVudHMvXG4gKi9cblxudmFyIFBvaW50ZXJFdmVudEludGVyZmFjZSA9IF9hc3NpZ24oe30sIE1vdXNlRXZlbnRJbnRlcmZhY2UsIHtcbiAgcG9pbnRlcklkOiAwLFxuICB3aWR0aDogMCxcbiAgaGVpZ2h0OiAwLFxuICBwcmVzc3VyZTogMCxcbiAgdGFuZ2VudGlhbFByZXNzdXJlOiAwLFxuICB0aWx0WDogMCxcbiAgdGlsdFk6IDAsXG4gIHR3aXN0OiAwLFxuICBwb2ludGVyVHlwZTogMCxcbiAgaXNQcmltYXJ5OiAwXG59KTtcblxudmFyIFN5bnRoZXRpY1BvaW50ZXJFdmVudCA9IGNyZWF0ZVN5bnRoZXRpY0V2ZW50KFBvaW50ZXJFdmVudEludGVyZmFjZSk7XG4vKipcbiAqIEBpbnRlcmZhY2UgVG91Y2hFdmVudFxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi90b3VjaC1ldmVudHMvXG4gKi9cblxudmFyIFRvdWNoRXZlbnRJbnRlcmZhY2UgPSBfYXNzaWduKHt9LCBVSUV2ZW50SW50ZXJmYWNlLCB7XG4gIHRvdWNoZXM6IDAsXG4gIHRhcmdldFRvdWNoZXM6IDAsXG4gIGNoYW5nZWRUb3VjaGVzOiAwLFxuICBhbHRLZXk6IDAsXG4gIG1ldGFLZXk6IDAsXG4gIGN0cmxLZXk6IDAsXG4gIHNoaWZ0S2V5OiAwLFxuICBnZXRNb2RpZmllclN0YXRlOiBnZXRFdmVudE1vZGlmaWVyU3RhdGVcbn0pO1xuXG52YXIgU3ludGhldGljVG91Y2hFdmVudCA9IGNyZWF0ZVN5bnRoZXRpY0V2ZW50KFRvdWNoRXZlbnRJbnRlcmZhY2UpO1xuLyoqXG4gKiBAaW50ZXJmYWNlIEV2ZW50XG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSLzIwMDkvV0QtY3NzMy10cmFuc2l0aW9ucy0yMDA5MDMyMC8jdHJhbnNpdGlvbi1ldmVudHMtXG4gKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9UcmFuc2l0aW9uRXZlbnRcbiAqL1xuXG52YXIgVHJhbnNpdGlvbkV2ZW50SW50ZXJmYWNlID0gX2Fzc2lnbih7fSwgRXZlbnRJbnRlcmZhY2UsIHtcbiAgcHJvcGVydHlOYW1lOiAwLFxuICBlbGFwc2VkVGltZTogMCxcbiAgcHNldWRvRWxlbWVudDogMFxufSk7XG5cbnZhciBTeW50aGV0aWNUcmFuc2l0aW9uRXZlbnQgPSBjcmVhdGVTeW50aGV0aWNFdmVudChUcmFuc2l0aW9uRXZlbnRJbnRlcmZhY2UpO1xuLyoqXG4gKiBAaW50ZXJmYWNlIFdoZWVsRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtRXZlbnRzL1xuICovXG5cbnZhciBXaGVlbEV2ZW50SW50ZXJmYWNlID0gX2Fzc2lnbih7fSwgTW91c2VFdmVudEludGVyZmFjZSwge1xuICBkZWx0YVg6IGZ1bmN0aW9uIChldmVudCkge1xuICAgIHJldHVybiAnZGVsdGFYJyBpbiBldmVudCA/IGV2ZW50LmRlbHRhWCA6IC8vIEZhbGxiYWNrIHRvIGB3aGVlbERlbHRhWGAgZm9yIFdlYmtpdCBhbmQgbm9ybWFsaXplIChyaWdodCBpcyBwb3NpdGl2ZSkuXG4gICAgJ3doZWVsRGVsdGFYJyBpbiBldmVudCA/IC1ldmVudC53aGVlbERlbHRhWCA6IDA7XG4gIH0sXG4gIGRlbHRhWTogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgcmV0dXJuICdkZWx0YVknIGluIGV2ZW50ID8gZXZlbnQuZGVsdGFZIDogLy8gRmFsbGJhY2sgdG8gYHdoZWVsRGVsdGFZYCBmb3IgV2Via2l0IGFuZCBub3JtYWxpemUgKGRvd24gaXMgcG9zaXRpdmUpLlxuICAgICd3aGVlbERlbHRhWScgaW4gZXZlbnQgPyAtZXZlbnQud2hlZWxEZWx0YVkgOiAvLyBGYWxsYmFjayB0byBgd2hlZWxEZWx0YWAgZm9yIElFPDkgYW5kIG5vcm1hbGl6ZSAoZG93biBpcyBwb3NpdGl2ZSkuXG4gICAgJ3doZWVsRGVsdGEnIGluIGV2ZW50ID8gLWV2ZW50LndoZWVsRGVsdGEgOiAwO1xuICB9LFxuICBkZWx0YVo6IDAsXG4gIC8vIEJyb3dzZXJzIHdpdGhvdXQgXCJkZWx0YU1vZGVcIiBpcyByZXBvcnRpbmcgaW4gcmF3IHdoZWVsIGRlbHRhIHdoZXJlIG9uZVxuICAvLyBub3RjaCBvbiB0aGUgc2Nyb2xsIGlzIGFsd2F5cyArLy0gMTIwLCByb3VnaGx5IGVxdWl2YWxlbnQgdG8gcGl4ZWxzLlxuICAvLyBBIGdvb2QgYXBwcm94aW1hdGlvbiBvZiBET01fREVMVEFfTElORSAoMSkgaXMgNSUgb2Ygdmlld3BvcnQgc2l6ZSBvclxuICAvLyB+NDAgcGl4ZWxzLCBmb3IgRE9NX0RFTFRBX1NDUkVFTiAoMikgaXQgaXMgODcuNSUgb2Ygdmlld3BvcnQgc2l6ZS5cbiAgZGVsdGFNb2RlOiAwXG59KTtcblxudmFyIFN5bnRoZXRpY1doZWVsRXZlbnQgPSBjcmVhdGVTeW50aGV0aWNFdmVudChXaGVlbEV2ZW50SW50ZXJmYWNlKTtcblxudmFyIEVORF9LRVlDT0RFUyA9IFs5LCAxMywgMjcsIDMyXTsgLy8gVGFiLCBSZXR1cm4sIEVzYywgU3BhY2VcblxudmFyIFNUQVJUX0tFWUNPREUgPSAyMjk7XG52YXIgY2FuVXNlQ29tcG9zaXRpb25FdmVudCA9IGNhblVzZURPTSAmJiAnQ29tcG9zaXRpb25FdmVudCcgaW4gd2luZG93O1xudmFyIGRvY3VtZW50TW9kZSA9IG51bGw7XG5cbmlmIChjYW5Vc2VET00gJiYgJ2RvY3VtZW50TW9kZScgaW4gZG9jdW1lbnQpIHtcbiAgZG9jdW1lbnRNb2RlID0gZG9jdW1lbnQuZG9jdW1lbnRNb2RlO1xufSAvLyBXZWJraXQgb2ZmZXJzIGEgdmVyeSB1c2VmdWwgYHRleHRJbnB1dGAgZXZlbnQgdGhhdCBjYW4gYmUgdXNlZCB0b1xuLy8gZGlyZWN0bHkgcmVwcmVzZW50IGBiZWZvcmVJbnB1dGAuIFRoZSBJRSBgdGV4dGlucHV0YCBldmVudCBpcyBub3QgYXNcbi8vIHVzZWZ1bCwgc28gd2UgZG9uJ3QgdXNlIGl0LlxuXG5cbnZhciBjYW5Vc2VUZXh0SW5wdXRFdmVudCA9IGNhblVzZURPTSAmJiAnVGV4dEV2ZW50JyBpbiB3aW5kb3cgJiYgIWRvY3VtZW50TW9kZTsgLy8gSW4gSUU5Kywgd2UgaGF2ZSBhY2Nlc3MgdG8gY29tcG9zaXRpb24gZXZlbnRzLCBidXQgdGhlIGRhdGEgc3VwcGxpZWRcbi8vIGJ5IHRoZSBuYXRpdmUgY29tcG9zaXRpb25lbmQgZXZlbnQgbWF5IGJlIGluY29ycmVjdC4gSmFwYW5lc2UgaWRlb2dyYXBoaWNcbi8vIHNwYWNlcywgZm9yIGluc3RhbmNlIChcXHUzMDAwKSBhcmUgbm90IHJlY29yZGVkIGNvcnJlY3RseS5cblxudmFyIHVzZUZhbGxiYWNrQ29tcG9zaXRpb25EYXRhID0gY2FuVXNlRE9NICYmICghY2FuVXNlQ29tcG9zaXRpb25FdmVudCB8fCBkb2N1bWVudE1vZGUgJiYgZG9jdW1lbnRNb2RlID4gOCAmJiBkb2N1bWVudE1vZGUgPD0gMTEpO1xudmFyIFNQQUNFQkFSX0NPREUgPSAzMjtcbnZhciBTUEFDRUJBUl9DSEFSID0gU3RyaW5nLmZyb21DaGFyQ29kZShTUEFDRUJBUl9DT0RFKTtcblxuZnVuY3Rpb24gcmVnaXN0ZXJFdmVudHMoKSB7XG4gIHJlZ2lzdGVyVHdvUGhhc2VFdmVudCgnb25CZWZvcmVJbnB1dCcsIFsnY29tcG9zaXRpb25lbmQnLCAna2V5cHJlc3MnLCAndGV4dElucHV0JywgJ3Bhc3RlJ10pO1xuICByZWdpc3RlclR3b1BoYXNlRXZlbnQoJ29uQ29tcG9zaXRpb25FbmQnLCBbJ2NvbXBvc2l0aW9uZW5kJywgJ2ZvY3Vzb3V0JywgJ2tleWRvd24nLCAna2V5cHJlc3MnLCAna2V5dXAnLCAnbW91c2Vkb3duJ10pO1xuICByZWdpc3RlclR3b1BoYXNlRXZlbnQoJ29uQ29tcG9zaXRpb25TdGFydCcsIFsnY29tcG9zaXRpb25zdGFydCcsICdmb2N1c291dCcsICdrZXlkb3duJywgJ2tleXByZXNzJywgJ2tleXVwJywgJ21vdXNlZG93biddKTtcbiAgcmVnaXN0ZXJUd29QaGFzZUV2ZW50KCdvbkNvbXBvc2l0aW9uVXBkYXRlJywgWydjb21wb3NpdGlvbnVwZGF0ZScsICdmb2N1c291dCcsICdrZXlkb3duJywgJ2tleXByZXNzJywgJ2tleXVwJywgJ21vdXNlZG93biddKTtcbn0gLy8gVHJhY2sgd2hldGhlciB3ZSd2ZSBldmVyIGhhbmRsZWQgYSBrZXlwcmVzcyBvbiB0aGUgc3BhY2Uga2V5LlxuXG5cbnZhciBoYXNTcGFjZUtleXByZXNzID0gZmFsc2U7XG4vKipcbiAqIFJldHVybiB3aGV0aGVyIGEgbmF0aXZlIGtleXByZXNzIGV2ZW50IGlzIGFzc3VtZWQgdG8gYmUgYSBjb21tYW5kLlxuICogVGhpcyBpcyByZXF1aXJlZCBiZWNhdXNlIEZpcmVmb3ggZmlyZXMgYGtleXByZXNzYCBldmVudHMgZm9yIGtleSBjb21tYW5kc1xuICogKGN1dCwgY29weSwgc2VsZWN0LWFsbCwgZXRjLikgZXZlbiB0aG91Z2ggbm8gY2hhcmFjdGVyIGlzIGluc2VydGVkLlxuICovXG5cbmZ1bmN0aW9uIGlzS2V5cHJlc3NDb21tYW5kKG5hdGl2ZUV2ZW50KSB7XG4gIHJldHVybiAobmF0aXZlRXZlbnQuY3RybEtleSB8fCBuYXRpdmVFdmVudC5hbHRLZXkgfHwgbmF0aXZlRXZlbnQubWV0YUtleSkgJiYgLy8gY3RybEtleSAmJiBhbHRLZXkgaXMgZXF1aXZhbGVudCB0byBBbHRHciwgYW5kIGlzIG5vdCBhIGNvbW1hbmQuXG4gICEobmF0aXZlRXZlbnQuY3RybEtleSAmJiBuYXRpdmVFdmVudC5hbHRLZXkpO1xufVxuLyoqXG4gKiBUcmFuc2xhdGUgbmF0aXZlIHRvcCBsZXZlbCBldmVudHMgaW50byBldmVudCB0eXBlcy5cbiAqL1xuXG5cbmZ1bmN0aW9uIGdldENvbXBvc2l0aW9uRXZlbnRUeXBlKGRvbUV2ZW50TmFtZSkge1xuICBzd2l0Y2ggKGRvbUV2ZW50TmFtZSkge1xuICAgIGNhc2UgJ2NvbXBvc2l0aW9uc3RhcnQnOlxuICAgICAgcmV0dXJuICdvbkNvbXBvc2l0aW9uU3RhcnQnO1xuXG4gICAgY2FzZSAnY29tcG9zaXRpb25lbmQnOlxuICAgICAgcmV0dXJuICdvbkNvbXBvc2l0aW9uRW5kJztcblxuICAgIGNhc2UgJ2NvbXBvc2l0aW9udXBkYXRlJzpcbiAgICAgIHJldHVybiAnb25Db21wb3NpdGlvblVwZGF0ZSc7XG4gIH1cbn1cbi8qKlxuICogRG9lcyBvdXIgZmFsbGJhY2sgYmVzdC1ndWVzcyBtb2RlbCB0aGluayB0aGlzIGV2ZW50IHNpZ25pZmllcyB0aGF0XG4gKiBjb21wb3NpdGlvbiBoYXMgYmVndW4/XG4gKi9cblxuXG5mdW5jdGlvbiBpc0ZhbGxiYWNrQ29tcG9zaXRpb25TdGFydChkb21FdmVudE5hbWUsIG5hdGl2ZUV2ZW50KSB7XG4gIHJldHVybiBkb21FdmVudE5hbWUgPT09ICdrZXlkb3duJyAmJiBuYXRpdmVFdmVudC5rZXlDb2RlID09PSBTVEFSVF9LRVlDT0RFO1xufVxuLyoqXG4gKiBEb2VzIG91ciBmYWxsYmFjayBtb2RlIHRoaW5rIHRoYXQgdGhpcyBldmVudCBpcyB0aGUgZW5kIG9mIGNvbXBvc2l0aW9uP1xuICovXG5cblxuZnVuY3Rpb24gaXNGYWxsYmFja0NvbXBvc2l0aW9uRW5kKGRvbUV2ZW50TmFtZSwgbmF0aXZlRXZlbnQpIHtcbiAgc3dpdGNoIChkb21FdmVudE5hbWUpIHtcbiAgICBjYXNlICdrZXl1cCc6XG4gICAgICAvLyBDb21tYW5kIGtleXMgaW5zZXJ0IG9yIGNsZWFyIElNRSBpbnB1dC5cbiAgICAgIHJldHVybiBFTkRfS0VZQ09ERVMuaW5kZXhPZihuYXRpdmVFdmVudC5rZXlDb2RlKSAhPT0gLTE7XG5cbiAgICBjYXNlICdrZXlkb3duJzpcbiAgICAgIC8vIEV4cGVjdCBJTUUga2V5Q29kZSBvbiBlYWNoIGtleWRvd24uIElmIHdlIGdldCBhbnkgb3RoZXJcbiAgICAgIC8vIGNvZGUgd2UgbXVzdCBoYXZlIGV4aXRlZCBlYXJsaWVyLlxuICAgICAgcmV0dXJuIG5hdGl2ZUV2ZW50LmtleUNvZGUgIT09IFNUQVJUX0tFWUNPREU7XG5cbiAgICBjYXNlICdrZXlwcmVzcyc6XG4gICAgY2FzZSAnbW91c2Vkb3duJzpcbiAgICBjYXNlICdmb2N1c291dCc6XG4gICAgICAvLyBFdmVudHMgYXJlIG5vdCBwb3NzaWJsZSB3aXRob3V0IGNhbmNlbGxpbmcgSU1FLlxuICAgICAgcmV0dXJuIHRydWU7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG4vKipcbiAqIEdvb2dsZSBJbnB1dCBUb29scyBwcm92aWRlcyBjb21wb3NpdGlvbiBkYXRhIHZpYSBhIEN1c3RvbUV2ZW50LFxuICogd2l0aCB0aGUgYGRhdGFgIHByb3BlcnR5IHBvcHVsYXRlZCBpbiB0aGUgYGRldGFpbGAgb2JqZWN0LiBJZiB0aGlzXG4gKiBpcyBhdmFpbGFibGUgb24gdGhlIGV2ZW50IG9iamVjdCwgdXNlIGl0LiBJZiBub3QsIHRoaXMgaXMgYSBwbGFpblxuICogY29tcG9zaXRpb24gZXZlbnQgYW5kIHdlIGhhdmUgbm90aGluZyBzcGVjaWFsIHRvIGV4dHJhY3QuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50XG4gKiBAcmV0dXJuIHs/c3RyaW5nfVxuICovXG5cblxuZnVuY3Rpb24gZ2V0RGF0YUZyb21DdXN0b21FdmVudChuYXRpdmVFdmVudCkge1xuICB2YXIgZGV0YWlsID0gbmF0aXZlRXZlbnQuZGV0YWlsO1xuXG4gIGlmICh0eXBlb2YgZGV0YWlsID09PSAnb2JqZWN0JyAmJiAnZGF0YScgaW4gZGV0YWlsKSB7XG4gICAgcmV0dXJuIGRldGFpbC5kYXRhO1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG4vKipcbiAqIENoZWNrIGlmIGEgY29tcG9zaXRpb24gZXZlbnQgd2FzIHRyaWdnZXJlZCBieSBLb3JlYW4gSU1FLlxuICogT3VyIGZhbGxiYWNrIG1vZGUgZG9lcyBub3Qgd29yayB3ZWxsIHdpdGggSUUncyBLb3JlYW4gSU1FLFxuICogc28ganVzdCB1c2UgbmF0aXZlIGNvbXBvc2l0aW9uIGV2ZW50cyB3aGVuIEtvcmVhbiBJTUUgaXMgdXNlZC5cbiAqIEFsdGhvdWdoIENvbXBvc2l0aW9uRXZlbnQubG9jYWxlIHByb3BlcnR5IGlzIGRlcHJlY2F0ZWQsXG4gKiBpdCBpcyBhdmFpbGFibGUgaW4gSUUsIHdoZXJlIG91ciBmYWxsYmFjayBtb2RlIGlzIGVuYWJsZWQuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50XG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5cblxuZnVuY3Rpb24gaXNVc2luZ0tvcmVhbklNRShuYXRpdmVFdmVudCkge1xuICByZXR1cm4gbmF0aXZlRXZlbnQubG9jYWxlID09PSAna28nO1xufSAvLyBUcmFjayB0aGUgY3VycmVudCBJTUUgY29tcG9zaXRpb24gc3RhdHVzLCBpZiBhbnkuXG5cblxudmFyIGlzQ29tcG9zaW5nID0gZmFsc2U7XG4vKipcbiAqIEByZXR1cm4gez9vYmplY3R9IEEgU3ludGhldGljQ29tcG9zaXRpb25FdmVudC5cbiAqL1xuXG5mdW5jdGlvbiBleHRyYWN0Q29tcG9zaXRpb25FdmVudChkaXNwYXRjaFF1ZXVlLCBkb21FdmVudE5hbWUsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICB2YXIgZXZlbnRUeXBlO1xuICB2YXIgZmFsbGJhY2tEYXRhO1xuXG4gIGlmIChjYW5Vc2VDb21wb3NpdGlvbkV2ZW50KSB7XG4gICAgZXZlbnRUeXBlID0gZ2V0Q29tcG9zaXRpb25FdmVudFR5cGUoZG9tRXZlbnROYW1lKTtcbiAgfSBlbHNlIGlmICghaXNDb21wb3NpbmcpIHtcbiAgICBpZiAoaXNGYWxsYmFja0NvbXBvc2l0aW9uU3RhcnQoZG9tRXZlbnROYW1lLCBuYXRpdmVFdmVudCkpIHtcbiAgICAgIGV2ZW50VHlwZSA9ICdvbkNvbXBvc2l0aW9uU3RhcnQnO1xuICAgIH1cbiAgfSBlbHNlIGlmIChpc0ZhbGxiYWNrQ29tcG9zaXRpb25FbmQoZG9tRXZlbnROYW1lLCBuYXRpdmVFdmVudCkpIHtcbiAgICBldmVudFR5cGUgPSAnb25Db21wb3NpdGlvbkVuZCc7XG4gIH1cblxuICBpZiAoIWV2ZW50VHlwZSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgaWYgKHVzZUZhbGxiYWNrQ29tcG9zaXRpb25EYXRhICYmICFpc1VzaW5nS29yZWFuSU1FKG5hdGl2ZUV2ZW50KSkge1xuICAgIC8vIFRoZSBjdXJyZW50IGNvbXBvc2l0aW9uIGlzIHN0b3JlZCBzdGF0aWNhbGx5IGFuZCBtdXN0IG5vdCBiZVxuICAgIC8vIG92ZXJ3cml0dGVuIHdoaWxlIGNvbXBvc2l0aW9uIGNvbnRpbnVlcy5cbiAgICBpZiAoIWlzQ29tcG9zaW5nICYmIGV2ZW50VHlwZSA9PT0gJ29uQ29tcG9zaXRpb25TdGFydCcpIHtcbiAgICAgIGlzQ29tcG9zaW5nID0gaW5pdGlhbGl6ZShuYXRpdmVFdmVudFRhcmdldCk7XG4gICAgfSBlbHNlIGlmIChldmVudFR5cGUgPT09ICdvbkNvbXBvc2l0aW9uRW5kJykge1xuICAgICAgaWYgKGlzQ29tcG9zaW5nKSB7XG4gICAgICAgIGZhbGxiYWNrRGF0YSA9IGdldERhdGEoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB2YXIgbGlzdGVuZXJzID0gYWNjdW11bGF0ZVR3b1BoYXNlTGlzdGVuZXJzKHRhcmdldEluc3QsIGV2ZW50VHlwZSk7XG5cbiAgaWYgKGxpc3RlbmVycy5sZW5ndGggPiAwKSB7XG4gICAgdmFyIGV2ZW50ID0gbmV3IFN5bnRoZXRpY0NvbXBvc2l0aW9uRXZlbnQoZXZlbnRUeXBlLCBkb21FdmVudE5hbWUsIG51bGwsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG4gICAgZGlzcGF0Y2hRdWV1ZS5wdXNoKHtcbiAgICAgIGV2ZW50OiBldmVudCxcbiAgICAgIGxpc3RlbmVyczogbGlzdGVuZXJzXG4gICAgfSk7XG5cbiAgICBpZiAoZmFsbGJhY2tEYXRhKSB7XG4gICAgICAvLyBJbmplY3QgZGF0YSBnZW5lcmF0ZWQgZnJvbSBmYWxsYmFjayBwYXRoIGludG8gdGhlIHN5bnRoZXRpYyBldmVudC5cbiAgICAgIC8vIFRoaXMgbWF0Y2hlcyB0aGUgcHJvcGVydHkgb2YgbmF0aXZlIENvbXBvc2l0aW9uRXZlbnRJbnRlcmZhY2UuXG4gICAgICBldmVudC5kYXRhID0gZmFsbGJhY2tEYXRhO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgY3VzdG9tRGF0YSA9IGdldERhdGFGcm9tQ3VzdG9tRXZlbnQobmF0aXZlRXZlbnQpO1xuXG4gICAgICBpZiAoY3VzdG9tRGF0YSAhPT0gbnVsbCkge1xuICAgICAgICBldmVudC5kYXRhID0gY3VzdG9tRGF0YTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0TmF0aXZlQmVmb3JlSW5wdXRDaGFycyhkb21FdmVudE5hbWUsIG5hdGl2ZUV2ZW50KSB7XG4gIHN3aXRjaCAoZG9tRXZlbnROYW1lKSB7XG4gICAgY2FzZSAnY29tcG9zaXRpb25lbmQnOlxuICAgICAgcmV0dXJuIGdldERhdGFGcm9tQ3VzdG9tRXZlbnQobmF0aXZlRXZlbnQpO1xuXG4gICAgY2FzZSAna2V5cHJlc3MnOlxuICAgICAgLyoqXG4gICAgICAgKiBJZiBuYXRpdmUgYHRleHRJbnB1dGAgZXZlbnRzIGFyZSBhdmFpbGFibGUsIG91ciBnb2FsIGlzIHRvIG1ha2VcbiAgICAgICAqIHVzZSBvZiB0aGVtLiBIb3dldmVyLCB0aGVyZSBpcyBhIHNwZWNpYWwgY2FzZTogdGhlIHNwYWNlYmFyIGtleS5cbiAgICAgICAqIEluIFdlYmtpdCwgcHJldmVudGluZyBkZWZhdWx0IG9uIGEgc3BhY2ViYXIgYHRleHRJbnB1dGAgZXZlbnRcbiAgICAgICAqIGNhbmNlbHMgY2hhcmFjdGVyIGluc2VydGlvbiwgYnV0IGl0ICphbHNvKiBjYXVzZXMgdGhlIGJyb3dzZXJcbiAgICAgICAqIHRvIGZhbGwgYmFjayB0byBpdHMgZGVmYXVsdCBzcGFjZWJhciBiZWhhdmlvciBvZiBzY3JvbGxpbmcgdGhlXG4gICAgICAgKiBwYWdlLlxuICAgICAgICpcbiAgICAgICAqIFRyYWNraW5nIGF0OlxuICAgICAgICogaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTM1NTEwM1xuICAgICAgICpcbiAgICAgICAqIFRvIGF2b2lkIHRoaXMgaXNzdWUsIHVzZSB0aGUga2V5cHJlc3MgZXZlbnQgYXMgaWYgbm8gYHRleHRJbnB1dGBcbiAgICAgICAqIGV2ZW50IGlzIGF2YWlsYWJsZS5cbiAgICAgICAqL1xuICAgICAgdmFyIHdoaWNoID0gbmF0aXZlRXZlbnQud2hpY2g7XG5cbiAgICAgIGlmICh3aGljaCAhPT0gU1BBQ0VCQVJfQ09ERSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgaGFzU3BhY2VLZXlwcmVzcyA9IHRydWU7XG4gICAgICByZXR1cm4gU1BBQ0VCQVJfQ0hBUjtcblxuICAgIGNhc2UgJ3RleHRJbnB1dCc6XG4gICAgICAvLyBSZWNvcmQgdGhlIGNoYXJhY3RlcnMgdG8gYmUgYWRkZWQgdG8gdGhlIERPTS5cbiAgICAgIHZhciBjaGFycyA9IG5hdGl2ZUV2ZW50LmRhdGE7IC8vIElmIGl0J3MgYSBzcGFjZWJhciBjaGFyYWN0ZXIsIGFzc3VtZSB0aGF0IHdlIGhhdmUgYWxyZWFkeSBoYW5kbGVkXG4gICAgICAvLyBpdCBhdCB0aGUga2V5cHJlc3MgbGV2ZWwgYW5kIGJhaWwgaW1tZWRpYXRlbHkuIEFuZHJvaWQgQ2hyb21lXG4gICAgICAvLyBkb2Vzbid0IGdpdmUgdXMga2V5Y29kZXMsIHNvIHdlIG5lZWQgdG8gaWdub3JlIGl0LlxuXG4gICAgICBpZiAoY2hhcnMgPT09IFNQQUNFQkFSX0NIQVIgJiYgaGFzU3BhY2VLZXlwcmVzcykge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGNoYXJzO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIC8vIEZvciBvdGhlciBuYXRpdmUgZXZlbnQgdHlwZXMsIGRvIG5vdGhpbmcuXG4gICAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuLyoqXG4gKiBGb3IgYnJvd3NlcnMgdGhhdCBkbyBub3QgcHJvdmlkZSB0aGUgYHRleHRJbnB1dGAgZXZlbnQsIGV4dHJhY3QgdGhlXG4gKiBhcHByb3ByaWF0ZSBzdHJpbmcgdG8gdXNlIGZvciBTeW50aGV0aWNJbnB1dEV2ZW50LlxuICovXG5cblxuZnVuY3Rpb24gZ2V0RmFsbGJhY2tCZWZvcmVJbnB1dENoYXJzKGRvbUV2ZW50TmFtZSwgbmF0aXZlRXZlbnQpIHtcbiAgLy8gSWYgd2UgYXJlIGN1cnJlbnRseSBjb21wb3NpbmcgKElNRSkgYW5kIHVzaW5nIGEgZmFsbGJhY2sgdG8gZG8gc28sXG4gIC8vIHRyeSB0byBleHRyYWN0IHRoZSBjb21wb3NlZCBjaGFyYWN0ZXJzIGZyb20gdGhlIGZhbGxiYWNrIG9iamVjdC5cbiAgLy8gSWYgY29tcG9zaXRpb24gZXZlbnQgaXMgYXZhaWxhYmxlLCB3ZSBleHRyYWN0IGEgc3RyaW5nIG9ubHkgYXRcbiAgLy8gY29tcG9zaXRpb25ldmVudCwgb3RoZXJ3aXNlIGV4dHJhY3QgaXQgYXQgZmFsbGJhY2sgZXZlbnRzLlxuICBpZiAoaXNDb21wb3NpbmcpIHtcbiAgICBpZiAoZG9tRXZlbnROYW1lID09PSAnY29tcG9zaXRpb25lbmQnIHx8ICFjYW5Vc2VDb21wb3NpdGlvbkV2ZW50ICYmIGlzRmFsbGJhY2tDb21wb3NpdGlvbkVuZChkb21FdmVudE5hbWUsIG5hdGl2ZUV2ZW50KSkge1xuICAgICAgdmFyIGNoYXJzID0gZ2V0RGF0YSgpO1xuICAgICAgcmVzZXQoKTtcbiAgICAgIGlzQ29tcG9zaW5nID0gZmFsc2U7XG4gICAgICByZXR1cm4gY2hhcnM7XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBzd2l0Y2ggKGRvbUV2ZW50TmFtZSkge1xuICAgIGNhc2UgJ3Bhc3RlJzpcbiAgICAgIC8vIElmIGEgcGFzdGUgZXZlbnQgb2NjdXJzIGFmdGVyIGEga2V5cHJlc3MsIHRocm93IG91dCB0aGUgaW5wdXRcbiAgICAgIC8vIGNoYXJzLiBQYXN0ZSBldmVudHMgc2hvdWxkIG5vdCBsZWFkIHRvIEJlZm9yZUlucHV0IGV2ZW50cy5cbiAgICAgIHJldHVybiBudWxsO1xuXG4gICAgY2FzZSAna2V5cHJlc3MnOlxuICAgICAgLyoqXG4gICAgICAgKiBBcyBvZiB2MjcsIEZpcmVmb3ggbWF5IGZpcmUga2V5cHJlc3MgZXZlbnRzIGV2ZW4gd2hlbiBubyBjaGFyYWN0ZXJcbiAgICAgICAqIHdpbGwgYmUgaW5zZXJ0ZWQuIEEgZmV3IHBvc3NpYmlsaXRpZXM6XG4gICAgICAgKlxuICAgICAgICogLSBgd2hpY2hgIGlzIGAwYC4gQXJyb3cga2V5cywgRXNjIGtleSwgZXRjLlxuICAgICAgICpcbiAgICAgICAqIC0gYHdoaWNoYCBpcyB0aGUgcHJlc3NlZCBrZXkgY29kZSwgYnV0IG5vIGNoYXIgaXMgYXZhaWxhYmxlLlxuICAgICAgICogICBFeDogJ0FsdEdyICsgZGAgaW4gUG9saXNoLiBUaGVyZSBpcyBubyBtb2RpZmllZCBjaGFyYWN0ZXIgZm9yXG4gICAgICAgKiAgIHRoaXMga2V5IGNvbWJpbmF0aW9uIGFuZCBubyBjaGFyYWN0ZXIgaXMgaW5zZXJ0ZWQgaW50byB0aGVcbiAgICAgICAqICAgZG9jdW1lbnQsIGJ1dCBGRiBmaXJlcyB0aGUga2V5cHJlc3MgZm9yIGNoYXIgY29kZSBgMTAwYCBhbnl3YXkuXG4gICAgICAgKiAgIE5vIGBpbnB1dGAgZXZlbnQgd2lsbCBvY2N1ci5cbiAgICAgICAqXG4gICAgICAgKiAtIGB3aGljaGAgaXMgdGhlIHByZXNzZWQga2V5IGNvZGUsIGJ1dCBhIGNvbW1hbmQgY29tYmluYXRpb24gaXNcbiAgICAgICAqICAgYmVpbmcgdXNlZC4gRXg6IGBDbWQrQ2AuIE5vIGNoYXJhY3RlciBpcyBpbnNlcnRlZCwgYW5kIG5vXG4gICAgICAgKiAgIGBpbnB1dGAgZXZlbnQgd2lsbCBvY2N1ci5cbiAgICAgICAqL1xuICAgICAgaWYgKCFpc0tleXByZXNzQ29tbWFuZChuYXRpdmVFdmVudCkpIHtcbiAgICAgICAgLy8gSUUgZmlyZXMgdGhlIGBrZXlwcmVzc2AgZXZlbnQgd2hlbiBhIHVzZXIgdHlwZXMgYW4gZW1vamkgdmlhXG4gICAgICAgIC8vIFRvdWNoIGtleWJvYXJkIG9mIFdpbmRvd3MuICBJbiBzdWNoIGEgY2FzZSwgdGhlIGBjaGFyYCBwcm9wZXJ0eVxuICAgICAgICAvLyBob2xkcyBhbiBlbW9qaSBjaGFyYWN0ZXIgbGlrZSBgXFx1RDgzRFxcdURFMEFgLiAgQmVjYXVzZSBpdHMgbGVuZ3RoXG4gICAgICAgIC8vIGlzIDIsIHRoZSBwcm9wZXJ0eSBgd2hpY2hgIGRvZXMgbm90IHJlcHJlc2VudCBhbiBlbW9qaSBjb3JyZWN0bHkuXG4gICAgICAgIC8vIEluIHN1Y2ggYSBjYXNlLCB3ZSBkaXJlY3RseSByZXR1cm4gdGhlIGBjaGFyYCBwcm9wZXJ0eSBpbnN0ZWFkIG9mXG4gICAgICAgIC8vIHVzaW5nIGB3aGljaGAuXG4gICAgICAgIGlmIChuYXRpdmVFdmVudC5jaGFyICYmIG5hdGl2ZUV2ZW50LmNoYXIubGVuZ3RoID4gMSkge1xuICAgICAgICAgIHJldHVybiBuYXRpdmVFdmVudC5jaGFyO1xuICAgICAgICB9IGVsc2UgaWYgKG5hdGl2ZUV2ZW50LndoaWNoKSB7XG4gICAgICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUobmF0aXZlRXZlbnQud2hpY2gpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBudWxsO1xuXG4gICAgY2FzZSAnY29tcG9zaXRpb25lbmQnOlxuICAgICAgcmV0dXJuIHVzZUZhbGxiYWNrQ29tcG9zaXRpb25EYXRhICYmICFpc1VzaW5nS29yZWFuSU1FKG5hdGl2ZUV2ZW50KSA/IG51bGwgOiBuYXRpdmVFdmVudC5kYXRhO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBudWxsO1xuICB9XG59XG4vKipcbiAqIEV4dHJhY3QgYSBTeW50aGV0aWNJbnB1dEV2ZW50IGZvciBgYmVmb3JlSW5wdXRgLCBiYXNlZCBvbiBlaXRoZXIgbmF0aXZlXG4gKiBgdGV4dElucHV0YCBvciBmYWxsYmFjayBiZWhhdmlvci5cbiAqXG4gKiBAcmV0dXJuIHs/b2JqZWN0fSBBIFN5bnRoZXRpY0lucHV0RXZlbnQuXG4gKi9cblxuXG5mdW5jdGlvbiBleHRyYWN0QmVmb3JlSW5wdXRFdmVudChkaXNwYXRjaFF1ZXVlLCBkb21FdmVudE5hbWUsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICB2YXIgY2hhcnM7XG5cbiAgaWYgKGNhblVzZVRleHRJbnB1dEV2ZW50KSB7XG4gICAgY2hhcnMgPSBnZXROYXRpdmVCZWZvcmVJbnB1dENoYXJzKGRvbUV2ZW50TmFtZSwgbmF0aXZlRXZlbnQpO1xuICB9IGVsc2Uge1xuICAgIGNoYXJzID0gZ2V0RmFsbGJhY2tCZWZvcmVJbnB1dENoYXJzKGRvbUV2ZW50TmFtZSwgbmF0aXZlRXZlbnQpO1xuICB9IC8vIElmIG5vIGNoYXJhY3RlcnMgYXJlIGJlaW5nIGluc2VydGVkLCBubyBCZWZvcmVJbnB1dCBldmVudCBzaG91bGRcbiAgLy8gYmUgZmlyZWQuXG5cblxuICBpZiAoIWNoYXJzKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgbGlzdGVuZXJzID0gYWNjdW11bGF0ZVR3b1BoYXNlTGlzdGVuZXJzKHRhcmdldEluc3QsICdvbkJlZm9yZUlucHV0Jyk7XG5cbiAgaWYgKGxpc3RlbmVycy5sZW5ndGggPiAwKSB7XG4gICAgdmFyIGV2ZW50ID0gbmV3IFN5bnRoZXRpY0lucHV0RXZlbnQoJ29uQmVmb3JlSW5wdXQnLCAnYmVmb3JlaW5wdXQnLCBudWxsLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xuICAgIGRpc3BhdGNoUXVldWUucHVzaCh7XG4gICAgICBldmVudDogZXZlbnQsXG4gICAgICBsaXN0ZW5lcnM6IGxpc3RlbmVyc1xuICAgIH0pO1xuICAgIGV2ZW50LmRhdGEgPSBjaGFycztcbiAgfVxufVxuLyoqXG4gKiBDcmVhdGUgYW4gYG9uQmVmb3JlSW5wdXRgIGV2ZW50IHRvIG1hdGNoXG4gKiBodHRwOi8vd3d3LnczLm9yZy9UUi8yMDEzL1dELURPTS1MZXZlbC0zLUV2ZW50cy0yMDEzMTEwNS8jZXZlbnRzLWlucHV0ZXZlbnRzLlxuICpcbiAqIFRoaXMgZXZlbnQgcGx1Z2luIGlzIGJhc2VkIG9uIHRoZSBuYXRpdmUgYHRleHRJbnB1dGAgZXZlbnRcbiAqIGF2YWlsYWJsZSBpbiBDaHJvbWUsIFNhZmFyaSwgT3BlcmEsIGFuZCBJRS4gVGhpcyBldmVudCBmaXJlcyBhZnRlclxuICogYG9uS2V5UHJlc3NgIGFuZCBgb25Db21wb3NpdGlvbkVuZGAsIGJ1dCBiZWZvcmUgYG9uSW5wdXRgLlxuICpcbiAqIGBiZWZvcmVJbnB1dGAgaXMgc3BlYydkIGJ1dCBub3QgaW1wbGVtZW50ZWQgaW4gYW55IGJyb3dzZXJzLCBhbmRcbiAqIHRoZSBgaW5wdXRgIGV2ZW50IGRvZXMgbm90IHByb3ZpZGUgYW55IHVzZWZ1bCBpbmZvcm1hdGlvbiBhYm91dCB3aGF0IGhhc1xuICogYWN0dWFsbHkgYmVlbiBhZGRlZCwgY29udHJhcnkgdG8gdGhlIHNwZWMuIFRodXMsIGB0ZXh0SW5wdXRgIGlzIHRoZSBiZXN0XG4gKiBhdmFpbGFibGUgZXZlbnQgdG8gaWRlbnRpZnkgdGhlIGNoYXJhY3RlcnMgdGhhdCBoYXZlIGFjdHVhbGx5IGJlZW4gaW5zZXJ0ZWRcbiAqIGludG8gdGhlIHRhcmdldCBub2RlLlxuICpcbiAqIFRoaXMgcGx1Z2luIGlzIGFsc28gcmVzcG9uc2libGUgZm9yIGVtaXR0aW5nIGBjb21wb3NpdGlvbmAgZXZlbnRzLCB0aHVzXG4gKiBhbGxvd2luZyB1cyB0byBzaGFyZSBjb21wb3NpdGlvbiBmYWxsYmFjayBjb2RlIGZvciBib3RoIGBiZWZvcmVJbnB1dGAgYW5kXG4gKiBgY29tcG9zaXRpb25gIGV2ZW50IHR5cGVzLlxuICovXG5cblxuZnVuY3Rpb24gZXh0cmFjdEV2ZW50cyhkaXNwYXRjaFF1ZXVlLCBkb21FdmVudE5hbWUsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCwgZXZlbnRTeXN0ZW1GbGFncywgdGFyZ2V0Q29udGFpbmVyKSB7XG4gIGV4dHJhY3RDb21wb3NpdGlvbkV2ZW50KGRpc3BhdGNoUXVldWUsIGRvbUV2ZW50TmFtZSwgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbiAgZXh0cmFjdEJlZm9yZUlucHV0RXZlbnQoZGlzcGF0Y2hRdWV1ZSwgZG9tRXZlbnROYW1lLCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xufVxuXG4vKipcbiAqIEBzZWUgaHR0cDovL3d3dy53aGF0d2cub3JnL3NwZWNzL3dlYi1hcHBzL2N1cnJlbnQtd29yay9tdWx0aXBhZ2UvdGhlLWlucHV0LWVsZW1lbnQuaHRtbCNpbnB1dC10eXBlLWF0dHItc3VtbWFyeVxuICovXG52YXIgc3VwcG9ydGVkSW5wdXRUeXBlcyA9IHtcbiAgY29sb3I6IHRydWUsXG4gIGRhdGU6IHRydWUsXG4gIGRhdGV0aW1lOiB0cnVlLFxuICAnZGF0ZXRpbWUtbG9jYWwnOiB0cnVlLFxuICBlbWFpbDogdHJ1ZSxcbiAgbW9udGg6IHRydWUsXG4gIG51bWJlcjogdHJ1ZSxcbiAgcGFzc3dvcmQ6IHRydWUsXG4gIHJhbmdlOiB0cnVlLFxuICBzZWFyY2g6IHRydWUsXG4gIHRlbDogdHJ1ZSxcbiAgdGV4dDogdHJ1ZSxcbiAgdGltZTogdHJ1ZSxcbiAgdXJsOiB0cnVlLFxuICB3ZWVrOiB0cnVlXG59O1xuXG5mdW5jdGlvbiBpc1RleHRJbnB1dEVsZW1lbnQoZWxlbSkge1xuICB2YXIgbm9kZU5hbWUgPSBlbGVtICYmIGVsZW0ubm9kZU5hbWUgJiYgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuXG4gIGlmIChub2RlTmFtZSA9PT0gJ2lucHV0Jykge1xuICAgIHJldHVybiAhIXN1cHBvcnRlZElucHV0VHlwZXNbZWxlbS50eXBlXTtcbiAgfVxuXG4gIGlmIChub2RlTmFtZSA9PT0gJ3RleHRhcmVhJykge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBhbiBldmVudCBpcyBzdXBwb3J0ZWQgaW4gdGhlIGN1cnJlbnQgZXhlY3V0aW9uIGVudmlyb25tZW50LlxuICpcbiAqIE5PVEU6IFRoaXMgd2lsbCBub3Qgd29yayBjb3JyZWN0bHkgZm9yIG5vbi1nZW5lcmljIGV2ZW50cyBzdWNoIGFzIGBjaGFuZ2VgLFxuICogYHJlc2V0YCwgYGxvYWRgLCBgZXJyb3JgLCBhbmQgYHNlbGVjdGAuXG4gKlxuICogQm9ycm93cyBmcm9tIE1vZGVybml6ci5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gZXZlbnROYW1lU3VmZml4IEV2ZW50IG5hbWUsIGUuZy4gXCJjbGlja1wiLlxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgZXZlbnQgaXMgc3VwcG9ydGVkLlxuICogQGludGVybmFsXG4gKiBAbGljZW5zZSBNb2Rlcm5penIgMy4wLjBwcmUgKEN1c3RvbSBCdWlsZCkgfCBNSVRcbiAqL1xuXG5mdW5jdGlvbiBpc0V2ZW50U3VwcG9ydGVkKGV2ZW50TmFtZVN1ZmZpeCkge1xuICBpZiAoIWNhblVzZURPTSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBldmVudE5hbWUgPSAnb24nICsgZXZlbnROYW1lU3VmZml4O1xuICB2YXIgaXNTdXBwb3J0ZWQgPSAoZXZlbnROYW1lIGluIGRvY3VtZW50KTtcblxuICBpZiAoIWlzU3VwcG9ydGVkKSB7XG4gICAgdmFyIGVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBlbGVtZW50LnNldEF0dHJpYnV0ZShldmVudE5hbWUsICdyZXR1cm47Jyk7XG4gICAgaXNTdXBwb3J0ZWQgPSB0eXBlb2YgZWxlbWVudFtldmVudE5hbWVdID09PSAnZnVuY3Rpb24nO1xuICB9XG5cbiAgcmV0dXJuIGlzU3VwcG9ydGVkO1xufVxuXG5mdW5jdGlvbiByZWdpc3RlckV2ZW50cyQxKCkge1xuICByZWdpc3RlclR3b1BoYXNlRXZlbnQoJ29uQ2hhbmdlJywgWydjaGFuZ2UnLCAnY2xpY2snLCAnZm9jdXNpbicsICdmb2N1c291dCcsICdpbnB1dCcsICdrZXlkb3duJywgJ2tleXVwJywgJ3NlbGVjdGlvbmNoYW5nZSddKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlQW5kQWNjdW11bGF0ZUNoYW5nZUV2ZW50KGRpc3BhdGNoUXVldWUsIGluc3QsIG5hdGl2ZUV2ZW50LCB0YXJnZXQpIHtcbiAgLy8gRmxhZyB0aGlzIGV2ZW50IGxvb3AgYXMgbmVlZGluZyBzdGF0ZSByZXN0b3JlLlxuICBlbnF1ZXVlU3RhdGVSZXN0b3JlKHRhcmdldCk7XG4gIHZhciBsaXN0ZW5lcnMgPSBhY2N1bXVsYXRlVHdvUGhhc2VMaXN0ZW5lcnMoaW5zdCwgJ29uQ2hhbmdlJyk7XG5cbiAgaWYgKGxpc3RlbmVycy5sZW5ndGggPiAwKSB7XG4gICAgdmFyIGV2ZW50ID0gbmV3IFN5bnRoZXRpY0V2ZW50KCdvbkNoYW5nZScsICdjaGFuZ2UnLCBudWxsLCBuYXRpdmVFdmVudCwgdGFyZ2V0KTtcbiAgICBkaXNwYXRjaFF1ZXVlLnB1c2goe1xuICAgICAgZXZlbnQ6IGV2ZW50LFxuICAgICAgbGlzdGVuZXJzOiBsaXN0ZW5lcnNcbiAgICB9KTtcbiAgfVxufVxuLyoqXG4gKiBGb3IgSUUgc2hpbXNcbiAqL1xuXG5cbnZhciBhY3RpdmVFbGVtZW50ID0gbnVsbDtcbnZhciBhY3RpdmVFbGVtZW50SW5zdCA9IG51bGw7XG4vKipcbiAqIFNFQ1RJT046IGhhbmRsZSBgY2hhbmdlYCBldmVudFxuICovXG5cbmZ1bmN0aW9uIHNob3VsZFVzZUNoYW5nZUV2ZW50KGVsZW0pIHtcbiAgdmFyIG5vZGVOYW1lID0gZWxlbS5ub2RlTmFtZSAmJiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG4gIHJldHVybiBub2RlTmFtZSA9PT0gJ3NlbGVjdCcgfHwgbm9kZU5hbWUgPT09ICdpbnB1dCcgJiYgZWxlbS50eXBlID09PSAnZmlsZSc7XG59XG5cbmZ1bmN0aW9uIG1hbnVhbERpc3BhdGNoQ2hhbmdlRXZlbnQobmF0aXZlRXZlbnQpIHtcbiAgdmFyIGRpc3BhdGNoUXVldWUgPSBbXTtcbiAgY3JlYXRlQW5kQWNjdW11bGF0ZUNoYW5nZUV2ZW50KGRpc3BhdGNoUXVldWUsIGFjdGl2ZUVsZW1lbnRJbnN0LCBuYXRpdmVFdmVudCwgZ2V0RXZlbnRUYXJnZXQobmF0aXZlRXZlbnQpKTsgLy8gSWYgY2hhbmdlIGFuZCBwcm9wZXJ0eWNoYW5nZSBidWJibGVkLCB3ZSdkIGp1c3QgYmluZCB0byBpdCBsaWtlIGFsbCB0aGVcbiAgLy8gb3RoZXIgZXZlbnRzIGFuZCBoYXZlIGl0IGdvIHRocm91Z2ggUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLiBTaW5jZSBpdFxuICAvLyBkb2Vzbid0LCB3ZSBtYW51YWxseSBsaXN0ZW4gZm9yIHRoZSBldmVudHMgYW5kIHNvIHdlIGhhdmUgdG8gZW5xdWV1ZSBhbmRcbiAgLy8gcHJvY2VzcyB0aGUgYWJzdHJhY3QgZXZlbnQgbWFudWFsbHkuXG4gIC8vXG4gIC8vIEJhdGNoaW5nIGlzIG5lY2Vzc2FyeSBoZXJlIGluIG9yZGVyIHRvIGVuc3VyZSB0aGF0IGFsbCBldmVudCBoYW5kbGVycyBydW5cbiAgLy8gYmVmb3JlIHRoZSBuZXh0IHJlcmVuZGVyIChpbmNsdWRpbmcgZXZlbnQgaGFuZGxlcnMgYXR0YWNoZWQgdG8gYW5jZXN0b3JcbiAgLy8gZWxlbWVudHMgaW5zdGVhZCBvZiBkaXJlY3RseSBvbiB0aGUgaW5wdXQpLiBXaXRob3V0IHRoaXMsIGNvbnRyb2xsZWRcbiAgLy8gY29tcG9uZW50cyBkb24ndCB3b3JrIHByb3Blcmx5IGluIGNvbmp1bmN0aW9uIHdpdGggZXZlbnQgYnViYmxpbmcgYmVjYXVzZVxuICAvLyB0aGUgY29tcG9uZW50IGlzIHJlcmVuZGVyZWQgYW5kIHRoZSB2YWx1ZSByZXZlcnRlZCBiZWZvcmUgYWxsIHRoZSBldmVudFxuICAvLyBoYW5kbGVycyBjYW4gcnVuLiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy83MDguXG5cbiAgYmF0Y2hlZFVwZGF0ZXMocnVuRXZlbnRJbkJhdGNoLCBkaXNwYXRjaFF1ZXVlKTtcbn1cblxuZnVuY3Rpb24gcnVuRXZlbnRJbkJhdGNoKGRpc3BhdGNoUXVldWUpIHtcbiAgcHJvY2Vzc0Rpc3BhdGNoUXVldWUoZGlzcGF0Y2hRdWV1ZSwgMCk7XG59XG5cbmZ1bmN0aW9uIGdldEluc3RJZlZhbHVlQ2hhbmdlZCh0YXJnZXRJbnN0KSB7XG4gIHZhciB0YXJnZXROb2RlID0gZ2V0Tm9kZUZyb21JbnN0YW5jZSh0YXJnZXRJbnN0KTtcblxuICBpZiAodXBkYXRlVmFsdWVJZkNoYW5nZWQodGFyZ2V0Tm9kZSkpIHtcbiAgICByZXR1cm4gdGFyZ2V0SW5zdDtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRUYXJnZXRJbnN0Rm9yQ2hhbmdlRXZlbnQoZG9tRXZlbnROYW1lLCB0YXJnZXRJbnN0KSB7XG4gIGlmIChkb21FdmVudE5hbWUgPT09ICdjaGFuZ2UnKSB7XG4gICAgcmV0dXJuIHRhcmdldEluc3Q7XG4gIH1cbn1cbi8qKlxuICogU0VDVElPTjogaGFuZGxlIGBpbnB1dGAgZXZlbnRcbiAqL1xuXG5cbnZhciBpc0lucHV0RXZlbnRTdXBwb3J0ZWQgPSBmYWxzZTtcblxuaWYgKGNhblVzZURPTSkge1xuICAvLyBJRTkgY2xhaW1zIHRvIHN1cHBvcnQgdGhlIGlucHV0IGV2ZW50IGJ1dCBmYWlscyB0byB0cmlnZ2VyIGl0IHdoZW5cbiAgLy8gZGVsZXRpbmcgdGV4dCwgc28gd2UgaWdub3JlIGl0cyBpbnB1dCBldmVudHMuXG4gIGlzSW5wdXRFdmVudFN1cHBvcnRlZCA9IGlzRXZlbnRTdXBwb3J0ZWQoJ2lucHV0JykgJiYgKCFkb2N1bWVudC5kb2N1bWVudE1vZGUgfHwgZG9jdW1lbnQuZG9jdW1lbnRNb2RlID4gOSk7XG59XG4vKipcbiAqIChGb3IgSUUgPD05KSBTdGFydHMgdHJhY2tpbmcgcHJvcGVydHljaGFuZ2UgZXZlbnRzIG9uIHRoZSBwYXNzZWQtaW4gZWxlbWVudFxuICogYW5kIG92ZXJyaWRlIHRoZSB2YWx1ZSBwcm9wZXJ0eSBzbyB0aGF0IHdlIGNhbiBkaXN0aW5ndWlzaCB1c2VyIGV2ZW50cyBmcm9tXG4gKiB2YWx1ZSBjaGFuZ2VzIGluIEpTLlxuICovXG5cblxuZnVuY3Rpb24gc3RhcnRXYXRjaGluZ0ZvclZhbHVlQ2hhbmdlKHRhcmdldCwgdGFyZ2V0SW5zdCkge1xuICBhY3RpdmVFbGVtZW50ID0gdGFyZ2V0O1xuICBhY3RpdmVFbGVtZW50SW5zdCA9IHRhcmdldEluc3Q7XG4gIGFjdGl2ZUVsZW1lbnQuYXR0YWNoRXZlbnQoJ29ucHJvcGVydHljaGFuZ2UnLCBoYW5kbGVQcm9wZXJ0eUNoYW5nZSk7XG59XG4vKipcbiAqIChGb3IgSUUgPD05KSBSZW1vdmVzIHRoZSBldmVudCBsaXN0ZW5lcnMgZnJvbSB0aGUgY3VycmVudGx5LXRyYWNrZWQgZWxlbWVudCxcbiAqIGlmIGFueSBleGlzdHMuXG4gKi9cblxuXG5mdW5jdGlvbiBzdG9wV2F0Y2hpbmdGb3JWYWx1ZUNoYW5nZSgpIHtcbiAgaWYgKCFhY3RpdmVFbGVtZW50KSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgYWN0aXZlRWxlbWVudC5kZXRhY2hFdmVudCgnb25wcm9wZXJ0eWNoYW5nZScsIGhhbmRsZVByb3BlcnR5Q2hhbmdlKTtcbiAgYWN0aXZlRWxlbWVudCA9IG51bGw7XG4gIGFjdGl2ZUVsZW1lbnRJbnN0ID0gbnVsbDtcbn1cbi8qKlxuICogKEZvciBJRSA8PTkpIEhhbmRsZXMgYSBwcm9wZXJ0eWNoYW5nZSBldmVudCwgc2VuZGluZyBhIGBjaGFuZ2VgIGV2ZW50IGlmXG4gKiB0aGUgdmFsdWUgb2YgdGhlIGFjdGl2ZSBlbGVtZW50IGhhcyBjaGFuZ2VkLlxuICovXG5cblxuZnVuY3Rpb24gaGFuZGxlUHJvcGVydHlDaGFuZ2UobmF0aXZlRXZlbnQpIHtcbiAgaWYgKG5hdGl2ZUV2ZW50LnByb3BlcnR5TmFtZSAhPT0gJ3ZhbHVlJykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChnZXRJbnN0SWZWYWx1ZUNoYW5nZWQoYWN0aXZlRWxlbWVudEluc3QpKSB7XG4gICAgbWFudWFsRGlzcGF0Y2hDaGFuZ2VFdmVudChuYXRpdmVFdmVudCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaGFuZGxlRXZlbnRzRm9ySW5wdXRFdmVudFBvbHlmaWxsKGRvbUV2ZW50TmFtZSwgdGFyZ2V0LCB0YXJnZXRJbnN0KSB7XG4gIGlmIChkb21FdmVudE5hbWUgPT09ICdmb2N1c2luJykge1xuICAgIC8vIEluIElFOSwgcHJvcGVydHljaGFuZ2UgZmlyZXMgZm9yIG1vc3QgaW5wdXQgZXZlbnRzIGJ1dCBpcyBidWdneSBhbmRcbiAgICAvLyBkb2Vzbid0IGZpcmUgd2hlbiB0ZXh0IGlzIGRlbGV0ZWQsIGJ1dCBjb252ZW5pZW50bHksIHNlbGVjdGlvbmNoYW5nZVxuICAgIC8vIGFwcGVhcnMgdG8gZmlyZSBpbiBhbGwgb2YgdGhlIHJlbWFpbmluZyBjYXNlcyBzbyB3ZSBjYXRjaCB0aG9zZSBhbmRcbiAgICAvLyBmb3J3YXJkIHRoZSBldmVudCBpZiB0aGUgdmFsdWUgaGFzIGNoYW5nZWRcbiAgICAvLyBJbiBlaXRoZXIgY2FzZSwgd2UgZG9uJ3Qgd2FudCB0byBjYWxsIHRoZSBldmVudCBoYW5kbGVyIGlmIHRoZSB2YWx1ZVxuICAgIC8vIGlzIGNoYW5nZWQgZnJvbSBKUyBzbyB3ZSByZWRlZmluZSBhIHNldHRlciBmb3IgYC52YWx1ZWAgdGhhdCB1cGRhdGVzXG4gICAgLy8gb3VyIGFjdGl2ZUVsZW1lbnRWYWx1ZSB2YXJpYWJsZSwgYWxsb3dpbmcgdXMgdG8gaWdub3JlIHRob3NlIGNoYW5nZXNcbiAgICAvL1xuICAgIC8vIHN0b3BXYXRjaGluZygpIHNob3VsZCBiZSBhIG5vb3AgaGVyZSBidXQgd2UgY2FsbCBpdCBqdXN0IGluIGNhc2Ugd2VcbiAgICAvLyBtaXNzZWQgYSBibHVyIGV2ZW50IHNvbWVob3cuXG4gICAgc3RvcFdhdGNoaW5nRm9yVmFsdWVDaGFuZ2UoKTtcbiAgICBzdGFydFdhdGNoaW5nRm9yVmFsdWVDaGFuZ2UodGFyZ2V0LCB0YXJnZXRJbnN0KTtcbiAgfSBlbHNlIGlmIChkb21FdmVudE5hbWUgPT09ICdmb2N1c291dCcpIHtcbiAgICBzdG9wV2F0Y2hpbmdGb3JWYWx1ZUNoYW5nZSgpO1xuICB9XG59IC8vIEZvciBJRTggYW5kIElFOS5cblxuXG5mdW5jdGlvbiBnZXRUYXJnZXRJbnN0Rm9ySW5wdXRFdmVudFBvbHlmaWxsKGRvbUV2ZW50TmFtZSwgdGFyZ2V0SW5zdCkge1xuICBpZiAoZG9tRXZlbnROYW1lID09PSAnc2VsZWN0aW9uY2hhbmdlJyB8fCBkb21FdmVudE5hbWUgPT09ICdrZXl1cCcgfHwgZG9tRXZlbnROYW1lID09PSAna2V5ZG93bicpIHtcbiAgICAvLyBPbiB0aGUgc2VsZWN0aW9uY2hhbmdlIGV2ZW50LCB0aGUgdGFyZ2V0IGlzIGp1c3QgZG9jdW1lbnQgd2hpY2ggaXNuJ3RcbiAgICAvLyBoZWxwZnVsIGZvciB1cyBzbyBqdXN0IGNoZWNrIGFjdGl2ZUVsZW1lbnQgaW5zdGVhZC5cbiAgICAvL1xuICAgIC8vIDk5JSBvZiB0aGUgdGltZSwga2V5ZG93biBhbmQga2V5dXAgYXJlbid0IG5lY2Vzc2FyeS4gSUU4IGZhaWxzIHRvIGZpcmVcbiAgICAvLyBwcm9wZXJ0eWNoYW5nZSBvbiB0aGUgZmlyc3QgaW5wdXQgZXZlbnQgYWZ0ZXIgc2V0dGluZyBgdmFsdWVgIGZyb20gYVxuICAgIC8vIHNjcmlwdCBhbmQgZmlyZXMgb25seSBrZXlkb3duLCBrZXlwcmVzcywga2V5dXAuIENhdGNoaW5nIGtleXVwIHVzdWFsbHlcbiAgICAvLyBnZXRzIGl0IGFuZCBjYXRjaGluZyBrZXlkb3duIGxldHMgdXMgZmlyZSBhbiBldmVudCBmb3IgdGhlIGZpcnN0XG4gICAgLy8ga2V5c3Ryb2tlIGlmIHVzZXIgZG9lcyBhIGtleSByZXBlYXQgKGl0J2xsIGJlIGEgbGl0dGxlIGRlbGF5ZWQ6IHJpZ2h0XG4gICAgLy8gYmVmb3JlIHRoZSBzZWNvbmQga2V5c3Ryb2tlKS4gT3RoZXIgaW5wdXQgbWV0aG9kcyAoZS5nLiwgcGFzdGUpIHNlZW0gdG9cbiAgICAvLyBmaXJlIHNlbGVjdGlvbmNoYW5nZSBub3JtYWxseS5cbiAgICByZXR1cm4gZ2V0SW5zdElmVmFsdWVDaGFuZ2VkKGFjdGl2ZUVsZW1lbnRJbnN0KTtcbiAgfVxufVxuLyoqXG4gKiBTRUNUSU9OOiBoYW5kbGUgYGNsaWNrYCBldmVudFxuICovXG5cblxuZnVuY3Rpb24gc2hvdWxkVXNlQ2xpY2tFdmVudChlbGVtKSB7XG4gIC8vIFVzZSB0aGUgYGNsaWNrYCBldmVudCB0byBkZXRlY3QgY2hhbmdlcyB0byBjaGVja2JveCBhbmQgcmFkaW8gaW5wdXRzLlxuICAvLyBUaGlzIGFwcHJvYWNoIHdvcmtzIGFjcm9zcyBhbGwgYnJvd3NlcnMsIHdoZXJlYXMgYGNoYW5nZWAgZG9lcyBub3QgZmlyZVxuICAvLyB1bnRpbCBgYmx1cmAgaW4gSUU4LlxuICB2YXIgbm9kZU5hbWUgPSBlbGVtLm5vZGVOYW1lO1xuICByZXR1cm4gbm9kZU5hbWUgJiYgbm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ2lucHV0JyAmJiAoZWxlbS50eXBlID09PSAnY2hlY2tib3gnIHx8IGVsZW0udHlwZSA9PT0gJ3JhZGlvJyk7XG59XG5cbmZ1bmN0aW9uIGdldFRhcmdldEluc3RGb3JDbGlja0V2ZW50KGRvbUV2ZW50TmFtZSwgdGFyZ2V0SW5zdCkge1xuICBpZiAoZG9tRXZlbnROYW1lID09PSAnY2xpY2snKSB7XG4gICAgcmV0dXJuIGdldEluc3RJZlZhbHVlQ2hhbmdlZCh0YXJnZXRJbnN0KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRUYXJnZXRJbnN0Rm9ySW5wdXRPckNoYW5nZUV2ZW50KGRvbUV2ZW50TmFtZSwgdGFyZ2V0SW5zdCkge1xuICBpZiAoZG9tRXZlbnROYW1lID09PSAnaW5wdXQnIHx8IGRvbUV2ZW50TmFtZSA9PT0gJ2NoYW5nZScpIHtcbiAgICByZXR1cm4gZ2V0SW5zdElmVmFsdWVDaGFuZ2VkKHRhcmdldEluc3QpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGhhbmRsZUNvbnRyb2xsZWRJbnB1dEJsdXIobm9kZSkge1xuICB2YXIgc3RhdGUgPSBub2RlLl93cmFwcGVyU3RhdGU7XG5cbiAgaWYgKCFzdGF0ZSB8fCAhc3RhdGUuY29udHJvbGxlZCB8fCBub2RlLnR5cGUgIT09ICdudW1iZXInKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAge1xuICAgIC8vIElmIGNvbnRyb2xsZWQsIGFzc2lnbiB0aGUgdmFsdWUgYXR0cmlidXRlIHRvIHRoZSBjdXJyZW50IHZhbHVlIG9uIGJsdXJcbiAgICBzZXREZWZhdWx0VmFsdWUobm9kZSwgJ251bWJlcicsIG5vZGUudmFsdWUpO1xuICB9XG59XG4vKipcbiAqIFRoaXMgcGx1Z2luIGNyZWF0ZXMgYW4gYG9uQ2hhbmdlYCBldmVudCB0aGF0IG5vcm1hbGl6ZXMgY2hhbmdlIGV2ZW50c1xuICogYWNyb3NzIGZvcm0gZWxlbWVudHMuIFRoaXMgZXZlbnQgZmlyZXMgYXQgYSB0aW1lIHdoZW4gaXQncyBwb3NzaWJsZSB0b1xuICogY2hhbmdlIHRoZSBlbGVtZW50J3MgdmFsdWUgd2l0aG91dCBzZWVpbmcgYSBmbGlja2VyLlxuICpcbiAqIFN1cHBvcnRlZCBlbGVtZW50cyBhcmU6XG4gKiAtIGlucHV0IChzZWUgYGlzVGV4dElucHV0RWxlbWVudGApXG4gKiAtIHRleHRhcmVhXG4gKiAtIHNlbGVjdFxuICovXG5cblxuZnVuY3Rpb24gZXh0cmFjdEV2ZW50cyQxKGRpc3BhdGNoUXVldWUsIGRvbUV2ZW50TmFtZSwgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0LCBldmVudFN5c3RlbUZsYWdzLCB0YXJnZXRDb250YWluZXIpIHtcbiAgdmFyIHRhcmdldE5vZGUgPSB0YXJnZXRJbnN0ID8gZ2V0Tm9kZUZyb21JbnN0YW5jZSh0YXJnZXRJbnN0KSA6IHdpbmRvdztcbiAgdmFyIGdldFRhcmdldEluc3RGdW5jLCBoYW5kbGVFdmVudEZ1bmM7XG5cbiAgaWYgKHNob3VsZFVzZUNoYW5nZUV2ZW50KHRhcmdldE5vZGUpKSB7XG4gICAgZ2V0VGFyZ2V0SW5zdEZ1bmMgPSBnZXRUYXJnZXRJbnN0Rm9yQ2hhbmdlRXZlbnQ7XG4gIH0gZWxzZSBpZiAoaXNUZXh0SW5wdXRFbGVtZW50KHRhcmdldE5vZGUpKSB7XG4gICAgaWYgKGlzSW5wdXRFdmVudFN1cHBvcnRlZCkge1xuICAgICAgZ2V0VGFyZ2V0SW5zdEZ1bmMgPSBnZXRUYXJnZXRJbnN0Rm9ySW5wdXRPckNoYW5nZUV2ZW50O1xuICAgIH0gZWxzZSB7XG4gICAgICBnZXRUYXJnZXRJbnN0RnVuYyA9IGdldFRhcmdldEluc3RGb3JJbnB1dEV2ZW50UG9seWZpbGw7XG4gICAgICBoYW5kbGVFdmVudEZ1bmMgPSBoYW5kbGVFdmVudHNGb3JJbnB1dEV2ZW50UG9seWZpbGw7XG4gICAgfVxuICB9IGVsc2UgaWYgKHNob3VsZFVzZUNsaWNrRXZlbnQodGFyZ2V0Tm9kZSkpIHtcbiAgICBnZXRUYXJnZXRJbnN0RnVuYyA9IGdldFRhcmdldEluc3RGb3JDbGlja0V2ZW50O1xuICB9XG5cbiAgaWYgKGdldFRhcmdldEluc3RGdW5jKSB7XG4gICAgdmFyIGluc3QgPSBnZXRUYXJnZXRJbnN0RnVuYyhkb21FdmVudE5hbWUsIHRhcmdldEluc3QpO1xuXG4gICAgaWYgKGluc3QpIHtcbiAgICAgIGNyZWF0ZUFuZEFjY3VtdWxhdGVDaGFuZ2VFdmVudChkaXNwYXRjaFF1ZXVlLCBpbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxuXG4gIGlmIChoYW5kbGVFdmVudEZ1bmMpIHtcbiAgICBoYW5kbGVFdmVudEZ1bmMoZG9tRXZlbnROYW1lLCB0YXJnZXROb2RlLCB0YXJnZXRJbnN0KTtcbiAgfSAvLyBXaGVuIGJsdXJyaW5nLCBzZXQgdGhlIHZhbHVlIGF0dHJpYnV0ZSBmb3IgbnVtYmVyIGlucHV0c1xuXG5cbiAgaWYgKGRvbUV2ZW50TmFtZSA9PT0gJ2ZvY3Vzb3V0Jykge1xuICAgIGhhbmRsZUNvbnRyb2xsZWRJbnB1dEJsdXIodGFyZ2V0Tm9kZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVnaXN0ZXJFdmVudHMkMigpIHtcbiAgcmVnaXN0ZXJEaXJlY3RFdmVudCgnb25Nb3VzZUVudGVyJywgWydtb3VzZW91dCcsICdtb3VzZW92ZXInXSk7XG4gIHJlZ2lzdGVyRGlyZWN0RXZlbnQoJ29uTW91c2VMZWF2ZScsIFsnbW91c2VvdXQnLCAnbW91c2VvdmVyJ10pO1xuICByZWdpc3RlckRpcmVjdEV2ZW50KCdvblBvaW50ZXJFbnRlcicsIFsncG9pbnRlcm91dCcsICdwb2ludGVyb3ZlciddKTtcbiAgcmVnaXN0ZXJEaXJlY3RFdmVudCgnb25Qb2ludGVyTGVhdmUnLCBbJ3BvaW50ZXJvdXQnLCAncG9pbnRlcm92ZXInXSk7XG59XG4vKipcbiAqIEZvciBhbG1vc3QgZXZlcnkgaW50ZXJhY3Rpb24gd2UgY2FyZSBhYm91dCwgdGhlcmUgd2lsbCBiZSBib3RoIGEgdG9wLWxldmVsXG4gKiBgbW91c2VvdmVyYCBhbmQgYG1vdXNlb3V0YCBldmVudCB0aGF0IG9jY3Vycy4gT25seSB1c2UgYG1vdXNlb3V0YCBzbyB0aGF0XG4gKiB3ZSBkbyBub3QgZXh0cmFjdCBkdXBsaWNhdGUgZXZlbnRzLiBIb3dldmVyLCBtb3ZpbmcgdGhlIG1vdXNlIGludG8gdGhlXG4gKiBicm93c2VyIGZyb20gb3V0c2lkZSB3aWxsIG5vdCBmaXJlIGEgYG1vdXNlb3V0YCBldmVudC4gSW4gdGhpcyBjYXNlLCB3ZSB1c2VcbiAqIHRoZSBgbW91c2VvdmVyYCB0b3AtbGV2ZWwgZXZlbnQuXG4gKi9cblxuXG5mdW5jdGlvbiBleHRyYWN0RXZlbnRzJDIoZGlzcGF0Y2hRdWV1ZSwgZG9tRXZlbnROYW1lLCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQsIGV2ZW50U3lzdGVtRmxhZ3MsIHRhcmdldENvbnRhaW5lcikge1xuICB2YXIgaXNPdmVyRXZlbnQgPSBkb21FdmVudE5hbWUgPT09ICdtb3VzZW92ZXInIHx8IGRvbUV2ZW50TmFtZSA9PT0gJ3BvaW50ZXJvdmVyJztcbiAgdmFyIGlzT3V0RXZlbnQgPSBkb21FdmVudE5hbWUgPT09ICdtb3VzZW91dCcgfHwgZG9tRXZlbnROYW1lID09PSAncG9pbnRlcm91dCc7XG5cbiAgaWYgKGlzT3ZlckV2ZW50ICYmIChldmVudFN5c3RlbUZsYWdzICYgSVNfUkVQTEFZRUQpID09PSAwKSB7XG4gICAgLy8gSWYgdGhpcyBpcyBhbiBvdmVyIGV2ZW50IHdpdGggYSB0YXJnZXQsIHdlIG1pZ2h0IGhhdmUgYWxyZWFkeSBkaXNwYXRjaGVkXG4gICAgLy8gdGhlIGV2ZW50IGluIHRoZSBvdXQgZXZlbnQgb2YgdGhlIG90aGVyIHRhcmdldC4gSWYgdGhpcyBpcyByZXBsYXllZCxcbiAgICAvLyB0aGVuIGl0J3MgYmVjYXVzZSB3ZSBjb3VsZG4ndCBkaXNwYXRjaCBhZ2FpbnN0IHRoaXMgdGFyZ2V0IHByZXZpb3VzbHlcbiAgICAvLyBzbyB3ZSBoYXZlIHRvIGRvIGl0IG5vdyBpbnN0ZWFkLlxuICAgIHZhciByZWxhdGVkID0gbmF0aXZlRXZlbnQucmVsYXRlZFRhcmdldCB8fCBuYXRpdmVFdmVudC5mcm9tRWxlbWVudDtcblxuICAgIGlmIChyZWxhdGVkKSB7XG4gICAgICAvLyBJZiB0aGUgcmVsYXRlZCBub2RlIGlzIG1hbmFnZWQgYnkgUmVhY3QsIHdlIGNhbiBhc3N1bWUgdGhhdCB3ZSBoYXZlXG4gICAgICAvLyBhbHJlYWR5IGRpc3BhdGNoZWQgdGhlIGNvcnJlc3BvbmRpbmcgZXZlbnRzIGR1cmluZyBpdHMgbW91c2VvdXQuXG4gICAgICBpZiAoZ2V0Q2xvc2VzdEluc3RhbmNlRnJvbU5vZGUocmVsYXRlZCkgfHwgaXNDb250YWluZXJNYXJrZWRBc1Jvb3QocmVsYXRlZCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmICghaXNPdXRFdmVudCAmJiAhaXNPdmVyRXZlbnQpIHtcbiAgICAvLyBNdXN0IG5vdCBiZSBhIG1vdXNlIG9yIHBvaW50ZXIgaW4gb3Igb3V0IC0gaWdub3JpbmcuXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIHdpbjsgLy8gVE9ETzogd2h5IGlzIHRoaXMgbnVsbGFibGUgaW4gdGhlIHR5cGVzIGJ1dCB3ZSByZWFkIGZyb20gaXQ/XG5cbiAgaWYgKG5hdGl2ZUV2ZW50VGFyZ2V0LndpbmRvdyA9PT0gbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgICAvLyBgbmF0aXZlRXZlbnRUYXJnZXRgIGlzIHByb2JhYmx5IGEgd2luZG93IG9iamVjdC5cbiAgICB3aW4gPSBuYXRpdmVFdmVudFRhcmdldDtcbiAgfSBlbHNlIHtcbiAgICAvLyBUT0RPOiBGaWd1cmUgb3V0IHdoeSBgb3duZXJEb2N1bWVudGAgaXMgc29tZXRpbWVzIHVuZGVmaW5lZCBpbiBJRTguXG4gICAgdmFyIGRvYyA9IG5hdGl2ZUV2ZW50VGFyZ2V0Lm93bmVyRG9jdW1lbnQ7XG5cbiAgICBpZiAoZG9jKSB7XG4gICAgICB3aW4gPSBkb2MuZGVmYXVsdFZpZXcgfHwgZG9jLnBhcmVudFdpbmRvdztcbiAgICB9IGVsc2Uge1xuICAgICAgd2luID0gd2luZG93O1xuICAgIH1cbiAgfVxuXG4gIHZhciBmcm9tO1xuICB2YXIgdG87XG5cbiAgaWYgKGlzT3V0RXZlbnQpIHtcbiAgICB2YXIgX3JlbGF0ZWQgPSBuYXRpdmVFdmVudC5yZWxhdGVkVGFyZ2V0IHx8IG5hdGl2ZUV2ZW50LnRvRWxlbWVudDtcblxuICAgIGZyb20gPSB0YXJnZXRJbnN0O1xuICAgIHRvID0gX3JlbGF0ZWQgPyBnZXRDbG9zZXN0SW5zdGFuY2VGcm9tTm9kZShfcmVsYXRlZCkgOiBudWxsO1xuXG4gICAgaWYgKHRvICE9PSBudWxsKSB7XG4gICAgICB2YXIgbmVhcmVzdE1vdW50ZWQgPSBnZXROZWFyZXN0TW91bnRlZEZpYmVyKHRvKTtcblxuICAgICAgaWYgKHRvICE9PSBuZWFyZXN0TW91bnRlZCB8fCB0by50YWcgIT09IEhvc3RDb21wb25lbnQgJiYgdG8udGFnICE9PSBIb3N0VGV4dCkge1xuICAgICAgICB0byA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIE1vdmluZyB0byBhIG5vZGUgZnJvbSBvdXRzaWRlIHRoZSB3aW5kb3cuXG4gICAgZnJvbSA9IG51bGw7XG4gICAgdG8gPSB0YXJnZXRJbnN0O1xuICB9XG5cbiAgaWYgKGZyb20gPT09IHRvKSB7XG4gICAgLy8gTm90aGluZyBwZXJ0YWlucyB0byBvdXIgbWFuYWdlZCBjb21wb25lbnRzLlxuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBTeW50aGV0aWNFdmVudEN0b3IgPSBTeW50aGV0aWNNb3VzZUV2ZW50O1xuICB2YXIgbGVhdmVFdmVudFR5cGUgPSAnb25Nb3VzZUxlYXZlJztcbiAgdmFyIGVudGVyRXZlbnRUeXBlID0gJ29uTW91c2VFbnRlcic7XG4gIHZhciBldmVudFR5cGVQcmVmaXggPSAnbW91c2UnO1xuXG4gIGlmIChkb21FdmVudE5hbWUgPT09ICdwb2ludGVyb3V0JyB8fCBkb21FdmVudE5hbWUgPT09ICdwb2ludGVyb3ZlcicpIHtcbiAgICBTeW50aGV0aWNFdmVudEN0b3IgPSBTeW50aGV0aWNQb2ludGVyRXZlbnQ7XG4gICAgbGVhdmVFdmVudFR5cGUgPSAnb25Qb2ludGVyTGVhdmUnO1xuICAgIGVudGVyRXZlbnRUeXBlID0gJ29uUG9pbnRlckVudGVyJztcbiAgICBldmVudFR5cGVQcmVmaXggPSAncG9pbnRlcic7XG4gIH1cblxuICB2YXIgZnJvbU5vZGUgPSBmcm9tID09IG51bGwgPyB3aW4gOiBnZXROb2RlRnJvbUluc3RhbmNlKGZyb20pO1xuICB2YXIgdG9Ob2RlID0gdG8gPT0gbnVsbCA/IHdpbiA6IGdldE5vZGVGcm9tSW5zdGFuY2UodG8pO1xuICB2YXIgbGVhdmUgPSBuZXcgU3ludGhldGljRXZlbnRDdG9yKGxlYXZlRXZlbnRUeXBlLCBldmVudFR5cGVQcmVmaXggKyAnbGVhdmUnLCBmcm9tLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xuICBsZWF2ZS50YXJnZXQgPSBmcm9tTm9kZTtcbiAgbGVhdmUucmVsYXRlZFRhcmdldCA9IHRvTm9kZTtcbiAgdmFyIGVudGVyID0gbnVsbDsgLy8gV2Ugc2hvdWxkIG9ubHkgcHJvY2VzcyB0aGlzIG5hdGl2ZUV2ZW50IGlmIHdlIGFyZSBwcm9jZXNzaW5nXG4gIC8vIHRoZSBmaXJzdCBhbmNlc3Rvci4gTmV4dCB0aW1lLCB3ZSB3aWxsIGlnbm9yZSB0aGUgZXZlbnQuXG5cbiAgdmFyIG5hdGl2ZVRhcmdldEluc3QgPSBnZXRDbG9zZXN0SW5zdGFuY2VGcm9tTm9kZShuYXRpdmVFdmVudFRhcmdldCk7XG5cbiAgaWYgKG5hdGl2ZVRhcmdldEluc3QgPT09IHRhcmdldEluc3QpIHtcbiAgICB2YXIgZW50ZXJFdmVudCA9IG5ldyBTeW50aGV0aWNFdmVudEN0b3IoZW50ZXJFdmVudFR5cGUsIGV2ZW50VHlwZVByZWZpeCArICdlbnRlcicsIHRvLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xuICAgIGVudGVyRXZlbnQudGFyZ2V0ID0gdG9Ob2RlO1xuICAgIGVudGVyRXZlbnQucmVsYXRlZFRhcmdldCA9IGZyb21Ob2RlO1xuICAgIGVudGVyID0gZW50ZXJFdmVudDtcbiAgfVxuXG4gIGFjY3VtdWxhdGVFbnRlckxlYXZlVHdvUGhhc2VMaXN0ZW5lcnMoZGlzcGF0Y2hRdWV1ZSwgbGVhdmUsIGVudGVyLCBmcm9tLCB0byk7XG59XG5cbi8qKlxuICogaW5saW5lZCBPYmplY3QuaXMgcG9seWZpbGwgdG8gYXZvaWQgcmVxdWlyaW5nIGNvbnN1bWVycyBzaGlwIHRoZWlyIG93blxuICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvT2JqZWN0L2lzXG4gKi9cbmZ1bmN0aW9uIGlzKHgsIHkpIHtcbiAgcmV0dXJuIHggPT09IHkgJiYgKHggIT09IDAgfHwgMSAvIHggPT09IDEgLyB5KSB8fCB4ICE9PSB4ICYmIHkgIT09IHkgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1zZWxmLWNvbXBhcmVcbiAgO1xufVxuXG52YXIgb2JqZWN0SXMgPSB0eXBlb2YgT2JqZWN0LmlzID09PSAnZnVuY3Rpb24nID8gT2JqZWN0LmlzIDogaXM7XG5cbnZhciBoYXNPd25Qcm9wZXJ0eSQyID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbi8qKlxuICogUGVyZm9ybXMgZXF1YWxpdHkgYnkgaXRlcmF0aW5nIHRocm91Z2gga2V5cyBvbiBhbiBvYmplY3QgYW5kIHJldHVybmluZyBmYWxzZVxuICogd2hlbiBhbnkga2V5IGhhcyB2YWx1ZXMgd2hpY2ggYXJlIG5vdCBzdHJpY3RseSBlcXVhbCBiZXR3ZWVuIHRoZSBhcmd1bWVudHMuXG4gKiBSZXR1cm5zIHRydWUgd2hlbiB0aGUgdmFsdWVzIG9mIGFsbCBrZXlzIGFyZSBzdHJpY3RseSBlcXVhbC5cbiAqL1xuXG5mdW5jdGlvbiBzaGFsbG93RXF1YWwob2JqQSwgb2JqQikge1xuICBpZiAob2JqZWN0SXMob2JqQSwgb2JqQikpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmICh0eXBlb2Ygb2JqQSAhPT0gJ29iamVjdCcgfHwgb2JqQSA9PT0gbnVsbCB8fCB0eXBlb2Ygb2JqQiAhPT0gJ29iamVjdCcgfHwgb2JqQiA9PT0gbnVsbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBrZXlzQSA9IE9iamVjdC5rZXlzKG9iakEpO1xuICB2YXIga2V5c0IgPSBPYmplY3Qua2V5cyhvYmpCKTtcblxuICBpZiAoa2V5c0EubGVuZ3RoICE9PSBrZXlzQi5sZW5ndGgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0gLy8gVGVzdCBmb3IgQSdzIGtleXMgZGlmZmVyZW50IGZyb20gQi5cblxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwga2V5c0EubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoIWhhc093blByb3BlcnR5JDIuY2FsbChvYmpCLCBrZXlzQVtpXSkgfHwgIW9iamVjdElzKG9iakFba2V5c0FbaV1dLCBvYmpCW2tleXNBW2ldXSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuLyoqXG4gKiBHaXZlbiBhbnkgbm9kZSByZXR1cm4gdGhlIGZpcnN0IGxlYWYgbm9kZSB3aXRob3V0IGNoaWxkcmVuLlxuICpcbiAqIEBwYXJhbSB7RE9NRWxlbWVudHxET01UZXh0Tm9kZX0gbm9kZVxuICogQHJldHVybiB7RE9NRWxlbWVudHxET01UZXh0Tm9kZX1cbiAqL1xuXG5mdW5jdGlvbiBnZXRMZWFmTm9kZShub2RlKSB7XG4gIHdoaWxlIChub2RlICYmIG5vZGUuZmlyc3RDaGlsZCkge1xuICAgIG5vZGUgPSBub2RlLmZpcnN0Q2hpbGQ7XG4gIH1cblxuICByZXR1cm4gbm9kZTtcbn1cbi8qKlxuICogR2V0IHRoZSBuZXh0IHNpYmxpbmcgd2l0aGluIGEgY29udGFpbmVyLiBUaGlzIHdpbGwgd2FsayB1cCB0aGVcbiAqIERPTSBpZiBhIG5vZGUncyBzaWJsaW5ncyBoYXZlIGJlZW4gZXhoYXVzdGVkLlxuICpcbiAqIEBwYXJhbSB7RE9NRWxlbWVudHxET01UZXh0Tm9kZX0gbm9kZVxuICogQHJldHVybiB7P0RPTUVsZW1lbnR8RE9NVGV4dE5vZGV9XG4gKi9cblxuXG5mdW5jdGlvbiBnZXRTaWJsaW5nTm9kZShub2RlKSB7XG4gIHdoaWxlIChub2RlKSB7XG4gICAgaWYgKG5vZGUubmV4dFNpYmxpbmcpIHtcbiAgICAgIHJldHVybiBub2RlLm5leHRTaWJsaW5nO1xuICAgIH1cblxuICAgIG5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG4gIH1cbn1cbi8qKlxuICogR2V0IG9iamVjdCBkZXNjcmliaW5nIHRoZSBub2RlcyB3aGljaCBjb250YWluIGNoYXJhY3RlcnMgYXQgb2Zmc2V0LlxuICpcbiAqIEBwYXJhbSB7RE9NRWxlbWVudHxET01UZXh0Tm9kZX0gcm9vdFxuICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldFxuICogQHJldHVybiB7P29iamVjdH1cbiAqL1xuXG5cbmZ1bmN0aW9uIGdldE5vZGVGb3JDaGFyYWN0ZXJPZmZzZXQocm9vdCwgb2Zmc2V0KSB7XG4gIHZhciBub2RlID0gZ2V0TGVhZk5vZGUocm9vdCk7XG4gIHZhciBub2RlU3RhcnQgPSAwO1xuICB2YXIgbm9kZUVuZCA9IDA7XG5cbiAgd2hpbGUgKG5vZGUpIHtcbiAgICBpZiAobm9kZS5ub2RlVHlwZSA9PT0gVEVYVF9OT0RFKSB7XG4gICAgICBub2RlRW5kID0gbm9kZVN0YXJ0ICsgbm9kZS50ZXh0Q29udGVudC5sZW5ndGg7XG5cbiAgICAgIGlmIChub2RlU3RhcnQgPD0gb2Zmc2V0ICYmIG5vZGVFbmQgPj0gb2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbm9kZTogbm9kZSxcbiAgICAgICAgICBvZmZzZXQ6IG9mZnNldCAtIG5vZGVTdGFydFxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICBub2RlU3RhcnQgPSBub2RlRW5kO1xuICAgIH1cblxuICAgIG5vZGUgPSBnZXRMZWFmTm9kZShnZXRTaWJsaW5nTm9kZShub2RlKSk7XG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR9IG91dGVyTm9kZVxuICogQHJldHVybiB7P29iamVjdH1cbiAqL1xuXG5mdW5jdGlvbiBnZXRPZmZzZXRzKG91dGVyTm9kZSkge1xuICB2YXIgb3duZXJEb2N1bWVudCA9IG91dGVyTm9kZS5vd25lckRvY3VtZW50O1xuICB2YXIgd2luID0gb3duZXJEb2N1bWVudCAmJiBvd25lckRvY3VtZW50LmRlZmF1bHRWaWV3IHx8IHdpbmRvdztcbiAgdmFyIHNlbGVjdGlvbiA9IHdpbi5nZXRTZWxlY3Rpb24gJiYgd2luLmdldFNlbGVjdGlvbigpO1xuXG4gIGlmICghc2VsZWN0aW9uIHx8IHNlbGVjdGlvbi5yYW5nZUNvdW50ID09PSAwKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgYW5jaG9yTm9kZSA9IHNlbGVjdGlvbi5hbmNob3JOb2RlLFxuICAgICAgYW5jaG9yT2Zmc2V0ID0gc2VsZWN0aW9uLmFuY2hvck9mZnNldCxcbiAgICAgIGZvY3VzTm9kZSA9IHNlbGVjdGlvbi5mb2N1c05vZGUsXG4gICAgICBmb2N1c09mZnNldCA9IHNlbGVjdGlvbi5mb2N1c09mZnNldDsgLy8gSW4gRmlyZWZveCwgYW5jaG9yTm9kZSBhbmQgZm9jdXNOb2RlIGNhbiBiZSBcImFub255bW91cyBkaXZzXCIsIGUuZy4gdGhlXG4gIC8vIHVwL2Rvd24gYnV0dG9ucyBvbiBhbiA8aW5wdXQgdHlwZT1cIm51bWJlclwiPi4gQW5vbnltb3VzIGRpdnMgZG8gbm90IHNlZW0gdG9cbiAgLy8gZXhwb3NlIHByb3BlcnRpZXMsIHRyaWdnZXJpbmcgYSBcIlBlcm1pc3Npb24gZGVuaWVkIGVycm9yXCIgaWYgYW55IG9mIGl0c1xuICAvLyBwcm9wZXJ0aWVzIGFyZSBhY2Nlc3NlZC4gVGhlIG9ubHkgc2VlbWluZ2x5IHBvc3NpYmxlIHdheSB0byBhdm9pZCBlcnJvcmluZ1xuICAvLyBpcyB0byBhY2Nlc3MgYSBwcm9wZXJ0eSB0aGF0IHR5cGljYWxseSB3b3JrcyBmb3Igbm9uLWFub255bW91cyBkaXZzIGFuZFxuICAvLyBjYXRjaCBhbnkgZXJyb3IgdGhhdCBtYXkgb3RoZXJ3aXNlIGFyaXNlLiBTZWVcbiAgLy8gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MjA4NDI3XG5cbiAgdHJ5IHtcbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby11bnVzZWQtZXhwcmVzc2lvbnMgKi9cbiAgICBhbmNob3JOb2RlLm5vZGVUeXBlO1xuICAgIGZvY3VzTm9kZS5ub2RlVHlwZTtcbiAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLXVudXNlZC1leHByZXNzaW9ucyAqL1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICByZXR1cm4gZ2V0TW9kZXJuT2Zmc2V0c0Zyb21Qb2ludHMob3V0ZXJOb2RlLCBhbmNob3JOb2RlLCBhbmNob3JPZmZzZXQsIGZvY3VzTm9kZSwgZm9jdXNPZmZzZXQpO1xufVxuLyoqXG4gKiBSZXR1cm5zIHtzdGFydCwgZW5kfSB3aGVyZSBgc3RhcnRgIGlzIHRoZSBjaGFyYWN0ZXIvY29kZXBvaW50IGluZGV4IG9mXG4gKiAoYW5jaG9yTm9kZSwgYW5jaG9yT2Zmc2V0KSB3aXRoaW4gdGhlIHRleHRDb250ZW50IG9mIGBvdXRlck5vZGVgLCBhbmRcbiAqIGBlbmRgIGlzIHRoZSBpbmRleCBvZiAoZm9jdXNOb2RlLCBmb2N1c09mZnNldCkuXG4gKlxuICogUmV0dXJucyBudWxsIGlmIHlvdSBwYXNzIGluIGdhcmJhZ2UgaW5wdXQgYnV0IHdlIHNob3VsZCBwcm9iYWJseSBqdXN0IGNyYXNoLlxuICpcbiAqIEV4cG9ydGVkIG9ubHkgZm9yIHRlc3RpbmcuXG4gKi9cblxuZnVuY3Rpb24gZ2V0TW9kZXJuT2Zmc2V0c0Zyb21Qb2ludHMob3V0ZXJOb2RlLCBhbmNob3JOb2RlLCBhbmNob3JPZmZzZXQsIGZvY3VzTm9kZSwgZm9jdXNPZmZzZXQpIHtcbiAgdmFyIGxlbmd0aCA9IDA7XG4gIHZhciBzdGFydCA9IC0xO1xuICB2YXIgZW5kID0gLTE7XG4gIHZhciBpbmRleFdpdGhpbkFuY2hvciA9IDA7XG4gIHZhciBpbmRleFdpdGhpbkZvY3VzID0gMDtcbiAgdmFyIG5vZGUgPSBvdXRlck5vZGU7XG4gIHZhciBwYXJlbnROb2RlID0gbnVsbDtcblxuICBvdXRlcjogd2hpbGUgKHRydWUpIHtcbiAgICB2YXIgbmV4dCA9IG51bGw7XG5cbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgaWYgKG5vZGUgPT09IGFuY2hvck5vZGUgJiYgKGFuY2hvck9mZnNldCA9PT0gMCB8fCBub2RlLm5vZGVUeXBlID09PSBURVhUX05PREUpKSB7XG4gICAgICAgIHN0YXJ0ID0gbGVuZ3RoICsgYW5jaG9yT2Zmc2V0O1xuICAgICAgfVxuXG4gICAgICBpZiAobm9kZSA9PT0gZm9jdXNOb2RlICYmIChmb2N1c09mZnNldCA9PT0gMCB8fCBub2RlLm5vZGVUeXBlID09PSBURVhUX05PREUpKSB7XG4gICAgICAgIGVuZCA9IGxlbmd0aCArIGZvY3VzT2Zmc2V0O1xuICAgICAgfVxuXG4gICAgICBpZiAobm9kZS5ub2RlVHlwZSA9PT0gVEVYVF9OT0RFKSB7XG4gICAgICAgIGxlbmd0aCArPSBub2RlLm5vZGVWYWx1ZS5sZW5ndGg7XG4gICAgICB9XG5cbiAgICAgIGlmICgobmV4dCA9IG5vZGUuZmlyc3RDaGlsZCkgPT09IG51bGwpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9IC8vIE1vdmluZyBmcm9tIGBub2RlYCB0byBpdHMgZmlyc3QgY2hpbGQgYG5leHRgLlxuXG5cbiAgICAgIHBhcmVudE5vZGUgPSBub2RlO1xuICAgICAgbm9kZSA9IG5leHQ7XG4gICAgfVxuXG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIGlmIChub2RlID09PSBvdXRlck5vZGUpIHtcbiAgICAgICAgLy8gSWYgYG91dGVyTm9kZWAgaGFzIGNoaWxkcmVuLCB0aGlzIGlzIGFsd2F5cyB0aGUgc2Vjb25kIHRpbWUgdmlzaXRpbmdcbiAgICAgICAgLy8gaXQuIElmIGl0IGhhcyBubyBjaGlsZHJlbiwgdGhpcyBpcyBzdGlsbCB0aGUgZmlyc3QgbG9vcCwgYW5kIHRoZSBvbmx5XG4gICAgICAgIC8vIHZhbGlkIHNlbGVjdGlvbiBpcyBhbmNob3JOb2RlIGFuZCBmb2N1c05vZGUgYm90aCBlcXVhbCB0byB0aGlzIG5vZGVcbiAgICAgICAgLy8gYW5kIGJvdGggb2Zmc2V0cyAwLCBpbiB3aGljaCBjYXNlIHdlIHdpbGwgaGF2ZSBoYW5kbGVkIGFib3ZlLlxuICAgICAgICBicmVhayBvdXRlcjtcbiAgICAgIH1cblxuICAgICAgaWYgKHBhcmVudE5vZGUgPT09IGFuY2hvck5vZGUgJiYgKytpbmRleFdpdGhpbkFuY2hvciA9PT0gYW5jaG9yT2Zmc2V0KSB7XG4gICAgICAgIHN0YXJ0ID0gbGVuZ3RoO1xuICAgICAgfVxuXG4gICAgICBpZiAocGFyZW50Tm9kZSA9PT0gZm9jdXNOb2RlICYmICsraW5kZXhXaXRoaW5Gb2N1cyA9PT0gZm9jdXNPZmZzZXQpIHtcbiAgICAgICAgZW5kID0gbGVuZ3RoO1xuICAgICAgfVxuXG4gICAgICBpZiAoKG5leHQgPSBub2RlLm5leHRTaWJsaW5nKSAhPT0gbnVsbCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgbm9kZSA9IHBhcmVudE5vZGU7XG4gICAgICBwYXJlbnROb2RlID0gbm9kZS5wYXJlbnROb2RlO1xuICAgIH0gLy8gTW92aW5nIGZyb20gYG5vZGVgIHRvIGl0cyBuZXh0IHNpYmxpbmcgYG5leHRgLlxuXG5cbiAgICBub2RlID0gbmV4dDtcbiAgfVxuXG4gIGlmIChzdGFydCA9PT0gLTEgfHwgZW5kID09PSAtMSkge1xuICAgIC8vIFRoaXMgc2hvdWxkIG5ldmVyIGhhcHBlbi4gKFdvdWxkIGhhcHBlbiBpZiB0aGUgYW5jaG9yL2ZvY3VzIG5vZGVzIGFyZW4ndFxuICAgIC8vIGFjdHVhbGx5IGluc2lkZSB0aGUgcGFzc2VkLWluIG5vZGUuKVxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBzdGFydDogc3RhcnQsXG4gICAgZW5kOiBlbmRcbiAgfTtcbn1cbi8qKlxuICogSW4gbW9kZXJuIG5vbi1JRSBicm93c2Vycywgd2UgY2FuIHN1cHBvcnQgYm90aCBmb3J3YXJkIGFuZCBiYWNrd2FyZFxuICogc2VsZWN0aW9ucy5cbiAqXG4gKiBOb3RlOiBJRTEwKyBzdXBwb3J0cyB0aGUgU2VsZWN0aW9uIG9iamVjdCwgYnV0IGl0IGRvZXMgbm90IHN1cHBvcnRcbiAqIHRoZSBgZXh0ZW5kYCBtZXRob2QsIHdoaWNoIG1lYW5zIHRoYXQgZXZlbiBpbiBtb2Rlcm4gSUUsIGl0J3Mgbm90IHBvc3NpYmxlXG4gKiB0byBwcm9ncmFtbWF0aWNhbGx5IGNyZWF0ZSBhIGJhY2t3YXJkIHNlbGVjdGlvbi4gVGh1cywgZm9yIGFsbCBJRVxuICogdmVyc2lvbnMsIHdlIHVzZSB0aGUgb2xkIElFIEFQSSB0byBjcmVhdGUgb3VyIHNlbGVjdGlvbnMuXG4gKlxuICogQHBhcmFtIHtET01FbGVtZW50fERPTVRleHROb2RlfSBub2RlXG4gKiBAcGFyYW0ge29iamVjdH0gb2Zmc2V0c1xuICovXG5cbmZ1bmN0aW9uIHNldE9mZnNldHMobm9kZSwgb2Zmc2V0cykge1xuICB2YXIgZG9jID0gbm9kZS5vd25lckRvY3VtZW50IHx8IGRvY3VtZW50O1xuICB2YXIgd2luID0gZG9jICYmIGRvYy5kZWZhdWx0VmlldyB8fCB3aW5kb3c7IC8vIEVkZ2UgZmFpbHMgd2l0aCBcIk9iamVjdCBleHBlY3RlZFwiIGluIHNvbWUgc2NlbmFyaW9zLlxuICAvLyAoRm9yIGluc3RhbmNlOiBUaW55TUNFIGVkaXRvciB1c2VkIGluIGEgbGlzdCBjb21wb25lbnQgdGhhdCBzdXBwb3J0cyBwYXN0aW5nIHRvIGFkZCBtb3JlLFxuICAvLyBmYWlscyB3aGVuIHBhc3RpbmcgMTAwKyBpdGVtcylcblxuICBpZiAoIXdpbi5nZXRTZWxlY3Rpb24pIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgc2VsZWN0aW9uID0gd2luLmdldFNlbGVjdGlvbigpO1xuICB2YXIgbGVuZ3RoID0gbm9kZS50ZXh0Q29udGVudC5sZW5ndGg7XG4gIHZhciBzdGFydCA9IE1hdGgubWluKG9mZnNldHMuc3RhcnQsIGxlbmd0aCk7XG4gIHZhciBlbmQgPSBvZmZzZXRzLmVuZCA9PT0gdW5kZWZpbmVkID8gc3RhcnQgOiBNYXRoLm1pbihvZmZzZXRzLmVuZCwgbGVuZ3RoKTsgLy8gSUUgMTEgdXNlcyBtb2Rlcm4gc2VsZWN0aW9uLCBidXQgZG9lc24ndCBzdXBwb3J0IHRoZSBleHRlbmQgbWV0aG9kLlxuICAvLyBGbGlwIGJhY2t3YXJkIHNlbGVjdGlvbnMsIHNvIHdlIGNhbiBzZXQgd2l0aCBhIHNpbmdsZSByYW5nZS5cblxuICBpZiAoIXNlbGVjdGlvbi5leHRlbmQgJiYgc3RhcnQgPiBlbmQpIHtcbiAgICB2YXIgdGVtcCA9IGVuZDtcbiAgICBlbmQgPSBzdGFydDtcbiAgICBzdGFydCA9IHRlbXA7XG4gIH1cblxuICB2YXIgc3RhcnRNYXJrZXIgPSBnZXROb2RlRm9yQ2hhcmFjdGVyT2Zmc2V0KG5vZGUsIHN0YXJ0KTtcbiAgdmFyIGVuZE1hcmtlciA9IGdldE5vZGVGb3JDaGFyYWN0ZXJPZmZzZXQobm9kZSwgZW5kKTtcblxuICBpZiAoc3RhcnRNYXJrZXIgJiYgZW5kTWFya2VyKSB7XG4gICAgaWYgKHNlbGVjdGlvbi5yYW5nZUNvdW50ID09PSAxICYmIHNlbGVjdGlvbi5hbmNob3JOb2RlID09PSBzdGFydE1hcmtlci5ub2RlICYmIHNlbGVjdGlvbi5hbmNob3JPZmZzZXQgPT09IHN0YXJ0TWFya2VyLm9mZnNldCAmJiBzZWxlY3Rpb24uZm9jdXNOb2RlID09PSBlbmRNYXJrZXIubm9kZSAmJiBzZWxlY3Rpb24uZm9jdXNPZmZzZXQgPT09IGVuZE1hcmtlci5vZmZzZXQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgcmFuZ2UgPSBkb2MuY3JlYXRlUmFuZ2UoKTtcbiAgICByYW5nZS5zZXRTdGFydChzdGFydE1hcmtlci5ub2RlLCBzdGFydE1hcmtlci5vZmZzZXQpO1xuICAgIHNlbGVjdGlvbi5yZW1vdmVBbGxSYW5nZXMoKTtcblxuICAgIGlmIChzdGFydCA+IGVuZCkge1xuICAgICAgc2VsZWN0aW9uLmFkZFJhbmdlKHJhbmdlKTtcbiAgICAgIHNlbGVjdGlvbi5leHRlbmQoZW5kTWFya2VyLm5vZGUsIGVuZE1hcmtlci5vZmZzZXQpO1xuICAgIH0gZWxzZSB7XG4gICAgICByYW5nZS5zZXRFbmQoZW5kTWFya2VyLm5vZGUsIGVuZE1hcmtlci5vZmZzZXQpO1xuICAgICAgc2VsZWN0aW9uLmFkZFJhbmdlKHJhbmdlKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNUZXh0Tm9kZShub2RlKSB7XG4gIHJldHVybiBub2RlICYmIG5vZGUubm9kZVR5cGUgPT09IFRFWFRfTk9ERTtcbn1cblxuZnVuY3Rpb24gY29udGFpbnNOb2RlKG91dGVyTm9kZSwgaW5uZXJOb2RlKSB7XG4gIGlmICghb3V0ZXJOb2RlIHx8ICFpbm5lck5vZGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0gZWxzZSBpZiAob3V0ZXJOb2RlID09PSBpbm5lck5vZGUpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBlbHNlIGlmIChpc1RleHROb2RlKG91dGVyTm9kZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0gZWxzZSBpZiAoaXNUZXh0Tm9kZShpbm5lck5vZGUpKSB7XG4gICAgcmV0dXJuIGNvbnRhaW5zTm9kZShvdXRlck5vZGUsIGlubmVyTm9kZS5wYXJlbnROb2RlKTtcbiAgfSBlbHNlIGlmICgnY29udGFpbnMnIGluIG91dGVyTm9kZSkge1xuICAgIHJldHVybiBvdXRlck5vZGUuY29udGFpbnMoaW5uZXJOb2RlKTtcbiAgfSBlbHNlIGlmIChvdXRlck5vZGUuY29tcGFyZURvY3VtZW50UG9zaXRpb24pIHtcbiAgICByZXR1cm4gISEob3V0ZXJOb2RlLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKGlubmVyTm9kZSkgJiAxNik7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGlzSW5Eb2N1bWVudChub2RlKSB7XG4gIHJldHVybiBub2RlICYmIG5vZGUub3duZXJEb2N1bWVudCAmJiBjb250YWluc05vZGUobm9kZS5vd25lckRvY3VtZW50LmRvY3VtZW50RWxlbWVudCwgbm9kZSk7XG59XG5cbmZ1bmN0aW9uIGlzU2FtZU9yaWdpbkZyYW1lKGlmcmFtZSkge1xuICB0cnkge1xuICAgIC8vIEFjY2Vzc2luZyB0aGUgY29udGVudERvY3VtZW50IG9mIGEgSFRNTElmcmFtZUVsZW1lbnQgY2FuIGNhdXNlIHRoZSBicm93c2VyXG4gICAgLy8gdG8gdGhyb3csIGUuZy4gaWYgaXQgaGFzIGEgY3Jvc3Mtb3JpZ2luIHNyYyBhdHRyaWJ1dGUuXG4gICAgLy8gU2FmYXJpIHdpbGwgc2hvdyBhbiBlcnJvciBpbiB0aGUgY29uc29sZSB3aGVuIHRoZSBhY2Nlc3MgcmVzdWx0cyBpbiBcIkJsb2NrZWQgYSBmcmFtZSB3aXRoIG9yaWdpblwiLiBlLmc6XG4gICAgLy8gaWZyYW1lLmNvbnRlbnREb2N1bWVudC5kZWZhdWx0VmlldztcbiAgICAvLyBBIHNhZmV0eSB3YXkgaXMgdG8gYWNjZXNzIG9uZSBvZiB0aGUgY3Jvc3Mgb3JpZ2luIHByb3BlcnRpZXM6IFdpbmRvdyBvciBMb2NhdGlvblxuICAgIC8vIFdoaWNoIG1pZ2h0IHJlc3VsdCBpbiBcIlNlY3VyaXR5RXJyb3JcIiBET00gRXhjZXB0aW9uIGFuZCBpdCBpcyBjb21wYXRpYmxlIHRvIFNhZmFyaS5cbiAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9icm93c2Vycy5odG1sI2ludGVncmF0aW9uLXdpdGgtaWRsXG4gICAgcmV0dXJuIHR5cGVvZiBpZnJhbWUuY29udGVudFdpbmRvdy5sb2NhdGlvbi5ocmVmID09PSAnc3RyaW5nJztcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldEFjdGl2ZUVsZW1lbnREZWVwKCkge1xuICB2YXIgd2luID0gd2luZG93O1xuICB2YXIgZWxlbWVudCA9IGdldEFjdGl2ZUVsZW1lbnQoKTtcblxuICB3aGlsZSAoZWxlbWVudCBpbnN0YW5jZW9mIHdpbi5IVE1MSUZyYW1lRWxlbWVudCkge1xuICAgIGlmIChpc1NhbWVPcmlnaW5GcmFtZShlbGVtZW50KSkge1xuICAgICAgd2luID0gZWxlbWVudC5jb250ZW50V2luZG93O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZWxlbWVudDtcbiAgICB9XG5cbiAgICBlbGVtZW50ID0gZ2V0QWN0aXZlRWxlbWVudCh3aW4uZG9jdW1lbnQpO1xuICB9XG5cbiAgcmV0dXJuIGVsZW1lbnQ7XG59XG4vKipcbiAqIEBSZWFjdElucHV0U2VsZWN0aW9uOiBSZWFjdCBpbnB1dCBzZWxlY3Rpb24gbW9kdWxlLiBCYXNlZCBvbiBTZWxlY3Rpb24uanMsXG4gKiBidXQgbW9kaWZpZWQgdG8gYmUgc3VpdGFibGUgZm9yIHJlYWN0IGFuZCBoYXMgYSBjb3VwbGUgb2YgYnVnIGZpeGVzIChkb2Vzbid0XG4gKiBhc3N1bWUgYnV0dG9ucyBoYXZlIHJhbmdlIHNlbGVjdGlvbnMgYWxsb3dlZCkuXG4gKiBJbnB1dCBzZWxlY3Rpb24gbW9kdWxlIGZvciBSZWFjdC5cbiAqL1xuXG4vKipcbiAqIEBoYXNTZWxlY3Rpb25DYXBhYmlsaXRpZXM6IHdlIGdldCB0aGUgZWxlbWVudCB0eXBlcyB0aGF0IHN1cHBvcnQgc2VsZWN0aW9uXG4gKiBmcm9tIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvI2RvLW5vdC1hcHBseSwgbG9va2luZyBhdCBgc2VsZWN0aW9uU3RhcnRgXG4gKiBhbmQgYHNlbGVjdGlvbkVuZGAgcm93cy5cbiAqL1xuXG5cbmZ1bmN0aW9uIGhhc1NlbGVjdGlvbkNhcGFiaWxpdGllcyhlbGVtKSB7XG4gIHZhciBub2RlTmFtZSA9IGVsZW0gJiYgZWxlbS5ub2RlTmFtZSAmJiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG4gIHJldHVybiBub2RlTmFtZSAmJiAobm9kZU5hbWUgPT09ICdpbnB1dCcgJiYgKGVsZW0udHlwZSA9PT0gJ3RleHQnIHx8IGVsZW0udHlwZSA9PT0gJ3NlYXJjaCcgfHwgZWxlbS50eXBlID09PSAndGVsJyB8fCBlbGVtLnR5cGUgPT09ICd1cmwnIHx8IGVsZW0udHlwZSA9PT0gJ3Bhc3N3b3JkJykgfHwgbm9kZU5hbWUgPT09ICd0ZXh0YXJlYScgfHwgZWxlbS5jb250ZW50RWRpdGFibGUgPT09ICd0cnVlJyk7XG59XG5mdW5jdGlvbiBnZXRTZWxlY3Rpb25JbmZvcm1hdGlvbigpIHtcbiAgdmFyIGZvY3VzZWRFbGVtID0gZ2V0QWN0aXZlRWxlbWVudERlZXAoKTtcbiAgcmV0dXJuIHtcbiAgICBmb2N1c2VkRWxlbTogZm9jdXNlZEVsZW0sXG4gICAgc2VsZWN0aW9uUmFuZ2U6IGhhc1NlbGVjdGlvbkNhcGFiaWxpdGllcyhmb2N1c2VkRWxlbSkgPyBnZXRTZWxlY3Rpb24oZm9jdXNlZEVsZW0pIDogbnVsbFxuICB9O1xufVxuLyoqXG4gKiBAcmVzdG9yZVNlbGVjdGlvbjogSWYgYW55IHNlbGVjdGlvbiBpbmZvcm1hdGlvbiB3YXMgcG90ZW50aWFsbHkgbG9zdCxcbiAqIHJlc3RvcmUgaXQuIFRoaXMgaXMgdXNlZnVsIHdoZW4gcGVyZm9ybWluZyBvcGVyYXRpb25zIHRoYXQgY291bGQgcmVtb3ZlIGRvbVxuICogbm9kZXMgYW5kIHBsYWNlIHRoZW0gYmFjayBpbiwgcmVzdWx0aW5nIGluIGZvY3VzIGJlaW5nIGxvc3QuXG4gKi9cblxuZnVuY3Rpb24gcmVzdG9yZVNlbGVjdGlvbihwcmlvclNlbGVjdGlvbkluZm9ybWF0aW9uKSB7XG4gIHZhciBjdXJGb2N1c2VkRWxlbSA9IGdldEFjdGl2ZUVsZW1lbnREZWVwKCk7XG4gIHZhciBwcmlvckZvY3VzZWRFbGVtID0gcHJpb3JTZWxlY3Rpb25JbmZvcm1hdGlvbi5mb2N1c2VkRWxlbTtcbiAgdmFyIHByaW9yU2VsZWN0aW9uUmFuZ2UgPSBwcmlvclNlbGVjdGlvbkluZm9ybWF0aW9uLnNlbGVjdGlvblJhbmdlO1xuXG4gIGlmIChjdXJGb2N1c2VkRWxlbSAhPT0gcHJpb3JGb2N1c2VkRWxlbSAmJiBpc0luRG9jdW1lbnQocHJpb3JGb2N1c2VkRWxlbSkpIHtcbiAgICBpZiAocHJpb3JTZWxlY3Rpb25SYW5nZSAhPT0gbnVsbCAmJiBoYXNTZWxlY3Rpb25DYXBhYmlsaXRpZXMocHJpb3JGb2N1c2VkRWxlbSkpIHtcbiAgICAgIHNldFNlbGVjdGlvbihwcmlvckZvY3VzZWRFbGVtLCBwcmlvclNlbGVjdGlvblJhbmdlKTtcbiAgICB9IC8vIEZvY3VzaW5nIGEgbm9kZSBjYW4gY2hhbmdlIHRoZSBzY3JvbGwgcG9zaXRpb24sIHdoaWNoIGlzIHVuZGVzaXJhYmxlXG5cblxuICAgIHZhciBhbmNlc3RvcnMgPSBbXTtcbiAgICB2YXIgYW5jZXN0b3IgPSBwcmlvckZvY3VzZWRFbGVtO1xuXG4gICAgd2hpbGUgKGFuY2VzdG9yID0gYW5jZXN0b3IucGFyZW50Tm9kZSkge1xuICAgICAgaWYgKGFuY2VzdG9yLm5vZGVUeXBlID09PSBFTEVNRU5UX05PREUpIHtcbiAgICAgICAgYW5jZXN0b3JzLnB1c2goe1xuICAgICAgICAgIGVsZW1lbnQ6IGFuY2VzdG9yLFxuICAgICAgICAgIGxlZnQ6IGFuY2VzdG9yLnNjcm9sbExlZnQsXG4gICAgICAgICAgdG9wOiBhbmNlc3Rvci5zY3JvbGxUb3BcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBwcmlvckZvY3VzZWRFbGVtLmZvY3VzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBwcmlvckZvY3VzZWRFbGVtLmZvY3VzKCk7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhbmNlc3RvcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBpbmZvID0gYW5jZXN0b3JzW2ldO1xuICAgICAgaW5mby5lbGVtZW50LnNjcm9sbExlZnQgPSBpbmZvLmxlZnQ7XG4gICAgICBpbmZvLmVsZW1lbnQuc2Nyb2xsVG9wID0gaW5mby50b3A7XG4gICAgfVxuICB9XG59XG4vKipcbiAqIEBnZXRTZWxlY3Rpb246IEdldHMgdGhlIHNlbGVjdGlvbiBib3VuZHMgb2YgYSBmb2N1c2VkIHRleHRhcmVhLCBpbnB1dCBvclxuICogY29udGVudEVkaXRhYmxlIG5vZGUuXG4gKiAtQGlucHV0OiBMb29rIHVwIHNlbGVjdGlvbiBib3VuZHMgb2YgdGhpcyBpbnB1dFxuICogLUByZXR1cm4ge3N0YXJ0OiBzZWxlY3Rpb25TdGFydCwgZW5kOiBzZWxlY3Rpb25FbmR9XG4gKi9cblxuZnVuY3Rpb24gZ2V0U2VsZWN0aW9uKGlucHV0KSB7XG4gIHZhciBzZWxlY3Rpb247XG5cbiAgaWYgKCdzZWxlY3Rpb25TdGFydCcgaW4gaW5wdXQpIHtcbiAgICAvLyBNb2Rlcm4gYnJvd3NlciB3aXRoIGlucHV0IG9yIHRleHRhcmVhLlxuICAgIHNlbGVjdGlvbiA9IHtcbiAgICAgIHN0YXJ0OiBpbnB1dC5zZWxlY3Rpb25TdGFydCxcbiAgICAgIGVuZDogaW5wdXQuc2VsZWN0aW9uRW5kXG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICAvLyBDb250ZW50IGVkaXRhYmxlIG9yIG9sZCBJRSB0ZXh0YXJlYS5cbiAgICBzZWxlY3Rpb24gPSBnZXRPZmZzZXRzKGlucHV0KTtcbiAgfVxuXG4gIHJldHVybiBzZWxlY3Rpb24gfHwge1xuICAgIHN0YXJ0OiAwLFxuICAgIGVuZDogMFxuICB9O1xufVxuLyoqXG4gKiBAc2V0U2VsZWN0aW9uOiBTZXRzIHRoZSBzZWxlY3Rpb24gYm91bmRzIG9mIGEgdGV4dGFyZWEgb3IgaW5wdXQgYW5kIGZvY3VzZXNcbiAqIHRoZSBpbnB1dC5cbiAqIC1AaW5wdXQgICAgIFNldCBzZWxlY3Rpb24gYm91bmRzIG9mIHRoaXMgaW5wdXQgb3IgdGV4dGFyZWFcbiAqIC1Ab2Zmc2V0cyAgIE9iamVjdCBvZiBzYW1lIGZvcm0gdGhhdCBpcyByZXR1cm5lZCBmcm9tIGdldCpcbiAqL1xuXG5mdW5jdGlvbiBzZXRTZWxlY3Rpb24oaW5wdXQsIG9mZnNldHMpIHtcbiAgdmFyIHN0YXJ0ID0gb2Zmc2V0cy5zdGFydDtcbiAgdmFyIGVuZCA9IG9mZnNldHMuZW5kO1xuXG4gIGlmIChlbmQgPT09IHVuZGVmaW5lZCkge1xuICAgIGVuZCA9IHN0YXJ0O1xuICB9XG5cbiAgaWYgKCdzZWxlY3Rpb25TdGFydCcgaW4gaW5wdXQpIHtcbiAgICBpbnB1dC5zZWxlY3Rpb25TdGFydCA9IHN0YXJ0O1xuICAgIGlucHV0LnNlbGVjdGlvbkVuZCA9IE1hdGgubWluKGVuZCwgaW5wdXQudmFsdWUubGVuZ3RoKTtcbiAgfSBlbHNlIHtcbiAgICBzZXRPZmZzZXRzKGlucHV0LCBvZmZzZXRzKTtcbiAgfVxufVxuXG52YXIgc2tpcFNlbGVjdGlvbkNoYW5nZUV2ZW50ID0gY2FuVXNlRE9NICYmICdkb2N1bWVudE1vZGUnIGluIGRvY3VtZW50ICYmIGRvY3VtZW50LmRvY3VtZW50TW9kZSA8PSAxMTtcblxuZnVuY3Rpb24gcmVnaXN0ZXJFdmVudHMkMygpIHtcbiAgcmVnaXN0ZXJUd29QaGFzZUV2ZW50KCdvblNlbGVjdCcsIFsnZm9jdXNvdXQnLCAnY29udGV4dG1lbnUnLCAnZHJhZ2VuZCcsICdmb2N1c2luJywgJ2tleWRvd24nLCAna2V5dXAnLCAnbW91c2Vkb3duJywgJ21vdXNldXAnLCAnc2VsZWN0aW9uY2hhbmdlJ10pO1xufVxuXG52YXIgYWN0aXZlRWxlbWVudCQxID0gbnVsbDtcbnZhciBhY3RpdmVFbGVtZW50SW5zdCQxID0gbnVsbDtcbnZhciBsYXN0U2VsZWN0aW9uID0gbnVsbDtcbnZhciBtb3VzZURvd24gPSBmYWxzZTtcbi8qKlxuICogR2V0IGFuIG9iamVjdCB3aGljaCBpcyBhIHVuaXF1ZSByZXByZXNlbnRhdGlvbiBvZiB0aGUgY3VycmVudCBzZWxlY3Rpb24uXG4gKlxuICogVGhlIHJldHVybiB2YWx1ZSB3aWxsIG5vdCBiZSBjb25zaXN0ZW50IGFjcm9zcyBub2RlcyBvciBicm93c2VycywgYnV0XG4gKiB0d28gaWRlbnRpY2FsIHNlbGVjdGlvbnMgb24gdGhlIHNhbWUgbm9kZSB3aWxsIHJldHVybiBpZGVudGljYWwgb2JqZWN0cy5cbiAqL1xuXG5mdW5jdGlvbiBnZXRTZWxlY3Rpb24kMShub2RlKSB7XG4gIGlmICgnc2VsZWN0aW9uU3RhcnQnIGluIG5vZGUgJiYgaGFzU2VsZWN0aW9uQ2FwYWJpbGl0aWVzKG5vZGUpKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHN0YXJ0OiBub2RlLnNlbGVjdGlvblN0YXJ0LFxuICAgICAgZW5kOiBub2RlLnNlbGVjdGlvbkVuZFxuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgdmFyIHdpbiA9IG5vZGUub3duZXJEb2N1bWVudCAmJiBub2RlLm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXcgfHwgd2luZG93O1xuICAgIHZhciBzZWxlY3Rpb24gPSB3aW4uZ2V0U2VsZWN0aW9uKCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGFuY2hvck5vZGU6IHNlbGVjdGlvbi5hbmNob3JOb2RlLFxuICAgICAgYW5jaG9yT2Zmc2V0OiBzZWxlY3Rpb24uYW5jaG9yT2Zmc2V0LFxuICAgICAgZm9jdXNOb2RlOiBzZWxlY3Rpb24uZm9jdXNOb2RlLFxuICAgICAgZm9jdXNPZmZzZXQ6IHNlbGVjdGlvbi5mb2N1c09mZnNldFxuICAgIH07XG4gIH1cbn1cbi8qKlxuICogR2V0IGRvY3VtZW50IGFzc29jaWF0ZWQgd2l0aCB0aGUgZXZlbnQgdGFyZ2V0LlxuICovXG5cblxuZnVuY3Rpb24gZ2V0RXZlbnRUYXJnZXREb2N1bWVudChldmVudFRhcmdldCkge1xuICByZXR1cm4gZXZlbnRUYXJnZXQud2luZG93ID09PSBldmVudFRhcmdldCA/IGV2ZW50VGFyZ2V0LmRvY3VtZW50IDogZXZlbnRUYXJnZXQubm9kZVR5cGUgPT09IERPQ1VNRU5UX05PREUgPyBldmVudFRhcmdldCA6IGV2ZW50VGFyZ2V0Lm93bmVyRG9jdW1lbnQ7XG59XG4vKipcbiAqIFBvbGwgc2VsZWN0aW9uIHRvIHNlZSB3aGV0aGVyIGl0J3MgY2hhbmdlZC5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnRcbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudFRhcmdldFxuICogQHJldHVybiB7P1N5bnRoZXRpY0V2ZW50fVxuICovXG5cblxuZnVuY3Rpb24gY29uc3RydWN0U2VsZWN0RXZlbnQoZGlzcGF0Y2hRdWV1ZSwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gIC8vIEVuc3VyZSB3ZSBoYXZlIHRoZSByaWdodCBlbGVtZW50LCBhbmQgdGhhdCB0aGUgdXNlciBpcyBub3QgZHJhZ2dpbmcgYVxuICAvLyBzZWxlY3Rpb24gKHRoaXMgbWF0Y2hlcyBuYXRpdmUgYHNlbGVjdGAgZXZlbnQgYmVoYXZpb3IpLiBJbiBIVE1MNSwgc2VsZWN0XG4gIC8vIGZpcmVzIG9ubHkgb24gaW5wdXQgYW5kIHRleHRhcmVhIHRodXMgaWYgdGhlcmUncyBubyBmb2N1c2VkIGVsZW1lbnQgd2VcbiAgLy8gd29uJ3QgZGlzcGF0Y2guXG4gIHZhciBkb2MgPSBnZXRFdmVudFRhcmdldERvY3VtZW50KG5hdGl2ZUV2ZW50VGFyZ2V0KTtcblxuICBpZiAobW91c2VEb3duIHx8IGFjdGl2ZUVsZW1lbnQkMSA9PSBudWxsIHx8IGFjdGl2ZUVsZW1lbnQkMSAhPT0gZ2V0QWN0aXZlRWxlbWVudChkb2MpKSB7XG4gICAgcmV0dXJuO1xuICB9IC8vIE9ubHkgZmlyZSB3aGVuIHNlbGVjdGlvbiBoYXMgYWN0dWFsbHkgY2hhbmdlZC5cblxuXG4gIHZhciBjdXJyZW50U2VsZWN0aW9uID0gZ2V0U2VsZWN0aW9uJDEoYWN0aXZlRWxlbWVudCQxKTtcblxuICBpZiAoIWxhc3RTZWxlY3Rpb24gfHwgIXNoYWxsb3dFcXVhbChsYXN0U2VsZWN0aW9uLCBjdXJyZW50U2VsZWN0aW9uKSkge1xuICAgIGxhc3RTZWxlY3Rpb24gPSBjdXJyZW50U2VsZWN0aW9uO1xuICAgIHZhciBsaXN0ZW5lcnMgPSBhY2N1bXVsYXRlVHdvUGhhc2VMaXN0ZW5lcnMoYWN0aXZlRWxlbWVudEluc3QkMSwgJ29uU2VsZWN0Jyk7XG5cbiAgICBpZiAobGlzdGVuZXJzLmxlbmd0aCA+IDApIHtcbiAgICAgIHZhciBldmVudCA9IG5ldyBTeW50aGV0aWNFdmVudCgnb25TZWxlY3QnLCAnc2VsZWN0JywgbnVsbCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbiAgICAgIGRpc3BhdGNoUXVldWUucHVzaCh7XG4gICAgICAgIGV2ZW50OiBldmVudCxcbiAgICAgICAgbGlzdGVuZXJzOiBsaXN0ZW5lcnNcbiAgICAgIH0pO1xuICAgICAgZXZlbnQudGFyZ2V0ID0gYWN0aXZlRWxlbWVudCQxO1xuICAgIH1cbiAgfVxufVxuLyoqXG4gKiBUaGlzIHBsdWdpbiBjcmVhdGVzIGFuIGBvblNlbGVjdGAgZXZlbnQgdGhhdCBub3JtYWxpemVzIHNlbGVjdCBldmVudHNcbiAqIGFjcm9zcyBmb3JtIGVsZW1lbnRzLlxuICpcbiAqIFN1cHBvcnRlZCBlbGVtZW50cyBhcmU6XG4gKiAtIGlucHV0IChzZWUgYGlzVGV4dElucHV0RWxlbWVudGApXG4gKiAtIHRleHRhcmVhXG4gKiAtIGNvbnRlbnRFZGl0YWJsZVxuICpcbiAqIFRoaXMgZGlmZmVycyBmcm9tIG5hdGl2ZSBicm93c2VyIGltcGxlbWVudGF0aW9ucyBpbiB0aGUgZm9sbG93aW5nIHdheXM6XG4gKiAtIEZpcmVzIG9uIGNvbnRlbnRFZGl0YWJsZSBmaWVsZHMgYXMgd2VsbCBhcyBpbnB1dHMuXG4gKiAtIEZpcmVzIGZvciBjb2xsYXBzZWQgc2VsZWN0aW9uLlxuICogLSBGaXJlcyBhZnRlciB1c2VyIGlucHV0LlxuICovXG5cblxuZnVuY3Rpb24gZXh0cmFjdEV2ZW50cyQzKGRpc3BhdGNoUXVldWUsIGRvbUV2ZW50TmFtZSwgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0LCBldmVudFN5c3RlbUZsYWdzLCB0YXJnZXRDb250YWluZXIpIHtcblxuICB2YXIgdGFyZ2V0Tm9kZSA9IHRhcmdldEluc3QgPyBnZXROb2RlRnJvbUluc3RhbmNlKHRhcmdldEluc3QpIDogd2luZG93O1xuXG4gIHN3aXRjaCAoZG9tRXZlbnROYW1lKSB7XG4gICAgLy8gVHJhY2sgdGhlIGlucHV0IG5vZGUgdGhhdCBoYXMgZm9jdXMuXG4gICAgY2FzZSAnZm9jdXNpbic6XG4gICAgICBpZiAoaXNUZXh0SW5wdXRFbGVtZW50KHRhcmdldE5vZGUpIHx8IHRhcmdldE5vZGUuY29udGVudEVkaXRhYmxlID09PSAndHJ1ZScpIHtcbiAgICAgICAgYWN0aXZlRWxlbWVudCQxID0gdGFyZ2V0Tm9kZTtcbiAgICAgICAgYWN0aXZlRWxlbWVudEluc3QkMSA9IHRhcmdldEluc3Q7XG4gICAgICAgIGxhc3RTZWxlY3Rpb24gPSBudWxsO1xuICAgICAgfVxuXG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ2ZvY3Vzb3V0JzpcbiAgICAgIGFjdGl2ZUVsZW1lbnQkMSA9IG51bGw7XG4gICAgICBhY3RpdmVFbGVtZW50SW5zdCQxID0gbnVsbDtcbiAgICAgIGxhc3RTZWxlY3Rpb24gPSBudWxsO1xuICAgICAgYnJlYWs7XG4gICAgLy8gRG9uJ3QgZmlyZSB0aGUgZXZlbnQgd2hpbGUgdGhlIHVzZXIgaXMgZHJhZ2dpbmcuIFRoaXMgbWF0Y2hlcyB0aGVcbiAgICAvLyBzZW1hbnRpY3Mgb2YgdGhlIG5hdGl2ZSBzZWxlY3QgZXZlbnQuXG5cbiAgICBjYXNlICdtb3VzZWRvd24nOlxuICAgICAgbW91c2VEb3duID0gdHJ1ZTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnY29udGV4dG1lbnUnOlxuICAgIGNhc2UgJ21vdXNldXAnOlxuICAgIGNhc2UgJ2RyYWdlbmQnOlxuICAgICAgbW91c2VEb3duID0gZmFsc2U7XG4gICAgICBjb25zdHJ1Y3RTZWxlY3RFdmVudChkaXNwYXRjaFF1ZXVlLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xuICAgICAgYnJlYWs7XG4gICAgLy8gQ2hyb21lIGFuZCBJRSBmaXJlIG5vbi1zdGFuZGFyZCBldmVudCB3aGVuIHNlbGVjdGlvbiBpcyBjaGFuZ2VkIChhbmRcbiAgICAvLyBzb21ldGltZXMgd2hlbiBpdCBoYXNuJ3QpLiBJRSdzIGV2ZW50IGZpcmVzIG91dCBvZiBvcmRlciB3aXRoIHJlc3BlY3RcbiAgICAvLyB0byBrZXkgYW5kIGlucHV0IGV2ZW50cyBvbiBkZWxldGlvbiwgc28gd2UgZGlzY2FyZCBpdC5cbiAgICAvL1xuICAgIC8vIEZpcmVmb3ggZG9lc24ndCBzdXBwb3J0IHNlbGVjdGlvbmNoYW5nZSwgc28gY2hlY2sgc2VsZWN0aW9uIHN0YXR1c1xuICAgIC8vIGFmdGVyIGVhY2gga2V5IGVudHJ5LiBUaGUgc2VsZWN0aW9uIGNoYW5nZXMgYWZ0ZXIga2V5ZG93biBhbmQgYmVmb3JlXG4gICAgLy8ga2V5dXAsIGJ1dCB3ZSBjaGVjayBvbiBrZXlkb3duIGFzIHdlbGwgaW4gdGhlIGNhc2Ugb2YgaG9sZGluZyBkb3duIGFcbiAgICAvLyBrZXksIHdoZW4gbXVsdGlwbGUga2V5ZG93biBldmVudHMgYXJlIGZpcmVkIGJ1dCBvbmx5IG9uZSBrZXl1cCBpcy5cbiAgICAvLyBUaGlzIGlzIGFsc28gb3VyIGFwcHJvYWNoIGZvciBJRSBoYW5kbGluZywgZm9yIHRoZSByZWFzb24gYWJvdmUuXG5cbiAgICBjYXNlICdzZWxlY3Rpb25jaGFuZ2UnOlxuICAgICAgaWYgKHNraXBTZWxlY3Rpb25DaGFuZ2VFdmVudCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgIC8vIGZhbGxzIHRocm91Z2hcblxuICAgIGNhc2UgJ2tleWRvd24nOlxuICAgIGNhc2UgJ2tleXVwJzpcbiAgICAgIGNvbnN0cnVjdFNlbGVjdEV2ZW50KGRpc3BhdGNoUXVldWUsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZXh0cmFjdEV2ZW50cyQ0KGRpc3BhdGNoUXVldWUsIGRvbUV2ZW50TmFtZSwgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0LCBldmVudFN5c3RlbUZsYWdzLCB0YXJnZXRDb250YWluZXIpIHtcbiAgdmFyIHJlYWN0TmFtZSA9IHRvcExldmVsRXZlbnRzVG9SZWFjdE5hbWVzLmdldChkb21FdmVudE5hbWUpO1xuXG4gIGlmIChyZWFjdE5hbWUgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBTeW50aGV0aWNFdmVudEN0b3IgPSBTeW50aGV0aWNFdmVudDtcbiAgdmFyIHJlYWN0RXZlbnRUeXBlID0gZG9tRXZlbnROYW1lO1xuXG4gIHN3aXRjaCAoZG9tRXZlbnROYW1lKSB7XG4gICAgY2FzZSAna2V5cHJlc3MnOlxuICAgICAgLy8gRmlyZWZveCBjcmVhdGVzIGEga2V5cHJlc3MgZXZlbnQgZm9yIGZ1bmN0aW9uIGtleXMgdG9vLiBUaGlzIHJlbW92ZXNcbiAgICAgIC8vIHRoZSB1bndhbnRlZCBrZXlwcmVzcyBldmVudHMuIEVudGVyIGlzIGhvd2V2ZXIgYm90aCBwcmludGFibGUgYW5kXG4gICAgICAvLyBub24tcHJpbnRhYmxlLiBPbmUgd291bGQgZXhwZWN0IFRhYiB0byBiZSBhcyB3ZWxsIChidXQgaXQgaXNuJ3QpLlxuICAgICAgaWYgKGdldEV2ZW50Q2hhckNvZGUobmF0aXZlRXZlbnQpID09PSAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cblxuICAgIGNhc2UgJ2tleWRvd24nOlxuICAgIGNhc2UgJ2tleXVwJzpcbiAgICAgIFN5bnRoZXRpY0V2ZW50Q3RvciA9IFN5bnRoZXRpY0tleWJvYXJkRXZlbnQ7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ2ZvY3VzaW4nOlxuICAgICAgcmVhY3RFdmVudFR5cGUgPSAnZm9jdXMnO1xuICAgICAgU3ludGhldGljRXZlbnRDdG9yID0gU3ludGhldGljRm9jdXNFdmVudDtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnZm9jdXNvdXQnOlxuICAgICAgcmVhY3RFdmVudFR5cGUgPSAnYmx1cic7XG4gICAgICBTeW50aGV0aWNFdmVudEN0b3IgPSBTeW50aGV0aWNGb2N1c0V2ZW50O1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdiZWZvcmVibHVyJzpcbiAgICBjYXNlICdhZnRlcmJsdXInOlxuICAgICAgU3ludGhldGljRXZlbnRDdG9yID0gU3ludGhldGljRm9jdXNFdmVudDtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnY2xpY2snOlxuICAgICAgLy8gRmlyZWZveCBjcmVhdGVzIGEgY2xpY2sgZXZlbnQgb24gcmlnaHQgbW91c2UgY2xpY2tzLiBUaGlzIHJlbW92ZXMgdGhlXG4gICAgICAvLyB1bndhbnRlZCBjbGljayBldmVudHMuXG4gICAgICBpZiAobmF0aXZlRXZlbnQuYnV0dG9uID09PSAyKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cblxuICAgIGNhc2UgJ2F1eGNsaWNrJzpcbiAgICBjYXNlICdkYmxjbGljayc6XG4gICAgY2FzZSAnbW91c2Vkb3duJzpcbiAgICBjYXNlICdtb3VzZW1vdmUnOlxuICAgIGNhc2UgJ21vdXNldXAnOiAvLyBUT0RPOiBEaXNhYmxlZCBlbGVtZW50cyBzaG91bGQgbm90IHJlc3BvbmQgdG8gbW91c2UgZXZlbnRzXG5cbiAgICAvKiBmYWxscyB0aHJvdWdoICovXG5cbiAgICBjYXNlICdtb3VzZW91dCc6XG4gICAgY2FzZSAnbW91c2VvdmVyJzpcbiAgICBjYXNlICdjb250ZXh0bWVudSc6XG4gICAgICBTeW50aGV0aWNFdmVudEN0b3IgPSBTeW50aGV0aWNNb3VzZUV2ZW50O1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdkcmFnJzpcbiAgICBjYXNlICdkcmFnZW5kJzpcbiAgICBjYXNlICdkcmFnZW50ZXInOlxuICAgIGNhc2UgJ2RyYWdleGl0JzpcbiAgICBjYXNlICdkcmFnbGVhdmUnOlxuICAgIGNhc2UgJ2RyYWdvdmVyJzpcbiAgICBjYXNlICdkcmFnc3RhcnQnOlxuICAgIGNhc2UgJ2Ryb3AnOlxuICAgICAgU3ludGhldGljRXZlbnRDdG9yID0gU3ludGhldGljRHJhZ0V2ZW50O1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICd0b3VjaGNhbmNlbCc6XG4gICAgY2FzZSAndG91Y2hlbmQnOlxuICAgIGNhc2UgJ3RvdWNobW92ZSc6XG4gICAgY2FzZSAndG91Y2hzdGFydCc6XG4gICAgICBTeW50aGV0aWNFdmVudEN0b3IgPSBTeW50aGV0aWNUb3VjaEV2ZW50O1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIEFOSU1BVElPTl9FTkQ6XG4gICAgY2FzZSBBTklNQVRJT05fSVRFUkFUSU9OOlxuICAgIGNhc2UgQU5JTUFUSU9OX1NUQVJUOlxuICAgICAgU3ludGhldGljRXZlbnRDdG9yID0gU3ludGhldGljQW5pbWF0aW9uRXZlbnQ7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgVFJBTlNJVElPTl9FTkQ6XG4gICAgICBTeW50aGV0aWNFdmVudEN0b3IgPSBTeW50aGV0aWNUcmFuc2l0aW9uRXZlbnQ7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ3Njcm9sbCc6XG4gICAgICBTeW50aGV0aWNFdmVudEN0b3IgPSBTeW50aGV0aWNVSUV2ZW50O1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICd3aGVlbCc6XG4gICAgICBTeW50aGV0aWNFdmVudEN0b3IgPSBTeW50aGV0aWNXaGVlbEV2ZW50O1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdjb3B5JzpcbiAgICBjYXNlICdjdXQnOlxuICAgIGNhc2UgJ3Bhc3RlJzpcbiAgICAgIFN5bnRoZXRpY0V2ZW50Q3RvciA9IFN5bnRoZXRpY0NsaXBib2FyZEV2ZW50O1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdnb3Rwb2ludGVyY2FwdHVyZSc6XG4gICAgY2FzZSAnbG9zdHBvaW50ZXJjYXB0dXJlJzpcbiAgICBjYXNlICdwb2ludGVyY2FuY2VsJzpcbiAgICBjYXNlICdwb2ludGVyZG93bic6XG4gICAgY2FzZSAncG9pbnRlcm1vdmUnOlxuICAgIGNhc2UgJ3BvaW50ZXJvdXQnOlxuICAgIGNhc2UgJ3BvaW50ZXJvdmVyJzpcbiAgICBjYXNlICdwb2ludGVydXAnOlxuICAgICAgU3ludGhldGljRXZlbnRDdG9yID0gU3ludGhldGljUG9pbnRlckV2ZW50O1xuICAgICAgYnJlYWs7XG4gIH1cblxuICB2YXIgaW5DYXB0dXJlUGhhc2UgPSAoZXZlbnRTeXN0ZW1GbGFncyAmIElTX0NBUFRVUkVfUEhBU0UpICE9PSAwO1xuXG4gIHtcbiAgICAvLyBTb21lIGV2ZW50cyBkb24ndCBidWJibGUgaW4gdGhlIGJyb3dzZXIuXG4gICAgLy8gSW4gdGhlIHBhc3QsIFJlYWN0IGhhcyBhbHdheXMgYnViYmxlZCB0aGVtLCBidXQgdGhpcyBjYW4gYmUgc3VycHJpc2luZy5cbiAgICAvLyBXZSdyZSBnb2luZyB0byB0cnkgYWxpZ25pbmcgY2xvc2VyIHRvIHRoZSBicm93c2VyIGJlaGF2aW9yIGJ5IG5vdCBidWJibGluZ1xuICAgIC8vIHRoZW0gaW4gUmVhY3QgZWl0aGVyLiBXZSdsbCBzdGFydCBieSBub3QgYnViYmxpbmcgb25TY3JvbGwsIGFuZCB0aGVuIGV4cGFuZC5cbiAgICB2YXIgYWNjdW11bGF0ZVRhcmdldE9ubHkgPSAhaW5DYXB0dXJlUGhhc2UgJiYgLy8gVE9ETzogaWRlYWxseSwgd2UnZCBldmVudHVhbGx5IGFkZCBhbGwgZXZlbnRzIGZyb21cbiAgICAvLyBub25EZWxlZ2F0ZWRFdmVudHMgbGlzdCBpbiBET01QbHVnaW5FdmVudFN5c3RlbS5cbiAgICAvLyBUaGVuIHdlIGNhbiByZW1vdmUgdGhpcyBzcGVjaWFsIGxpc3QuXG4gICAgLy8gVGhpcyBpcyBhIGJyZWFraW5nIGNoYW5nZSB0aGF0IGNhbiB3YWl0IHVudGlsIFJlYWN0IDE4LlxuICAgIGRvbUV2ZW50TmFtZSA9PT0gJ3Njcm9sbCc7XG5cbiAgICB2YXIgX2xpc3RlbmVycyA9IGFjY3VtdWxhdGVTaW5nbGVQaGFzZUxpc3RlbmVycyh0YXJnZXRJbnN0LCByZWFjdE5hbWUsIG5hdGl2ZUV2ZW50LnR5cGUsIGluQ2FwdHVyZVBoYXNlLCBhY2N1bXVsYXRlVGFyZ2V0T25seSk7XG5cbiAgICBpZiAoX2xpc3RlbmVycy5sZW5ndGggPiAwKSB7XG4gICAgICAvLyBJbnRlbnRpb25hbGx5IGNyZWF0ZSBldmVudCBsYXppbHkuXG4gICAgICB2YXIgX2V2ZW50ID0gbmV3IFN5bnRoZXRpY0V2ZW50Q3RvcihyZWFjdE5hbWUsIHJlYWN0RXZlbnRUeXBlLCBudWxsLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xuXG4gICAgICBkaXNwYXRjaFF1ZXVlLnB1c2goe1xuICAgICAgICBldmVudDogX2V2ZW50LFxuICAgICAgICBsaXN0ZW5lcnM6IF9saXN0ZW5lcnNcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxufVxuXG4vLyBUT0RPOiByZW1vdmUgdG9wLWxldmVsIHNpZGUgZWZmZWN0LlxucmVnaXN0ZXJTaW1wbGVFdmVudHMoKTtcbnJlZ2lzdGVyRXZlbnRzJDIoKTtcbnJlZ2lzdGVyRXZlbnRzJDEoKTtcbnJlZ2lzdGVyRXZlbnRzJDMoKTtcbnJlZ2lzdGVyRXZlbnRzKCk7XG5cbmZ1bmN0aW9uIGV4dHJhY3RFdmVudHMkNShkaXNwYXRjaFF1ZXVlLCBkb21FdmVudE5hbWUsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCwgZXZlbnRTeXN0ZW1GbGFncywgdGFyZ2V0Q29udGFpbmVyKSB7XG4gIC8vIFRPRE86IHdlIHNob3VsZCByZW1vdmUgdGhlIGNvbmNlcHQgb2YgYSBcIlNpbXBsZUV2ZW50UGx1Z2luXCIuXG4gIC8vIFRoaXMgaXMgdGhlIGJhc2ljIGZ1bmN0aW9uYWxpdHkgb2YgdGhlIGV2ZW50IHN5c3RlbS4gQWxsXG4gIC8vIHRoZSBvdGhlciBwbHVnaW5zIGFyZSBlc3NlbnRpYWxseSBwb2x5ZmlsbHMuIFNvIHRoZSBwbHVnaW5cbiAgLy8gc2hvdWxkIHByb2JhYmx5IGJlIGlubGluZWQgc29tZXdoZXJlIGFuZCBoYXZlIGl0cyBsb2dpY1xuICAvLyBiZSBjb3JlIHRoZSB0byBldmVudCBzeXN0ZW0uIFRoaXMgd291bGQgcG90ZW50aWFsbHkgYWxsb3dcbiAgLy8gdXMgdG8gc2hpcCBidWlsZHMgb2YgUmVhY3Qgd2l0aG91dCB0aGUgcG9seWZpbGxlZCBwbHVnaW5zIGJlbG93LlxuICBleHRyYWN0RXZlbnRzJDQoZGlzcGF0Y2hRdWV1ZSwgZG9tRXZlbnROYW1lLCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQsIGV2ZW50U3lzdGVtRmxhZ3MpO1xuICB2YXIgc2hvdWxkUHJvY2Vzc1BvbHlmaWxsUGx1Z2lucyA9IChldmVudFN5c3RlbUZsYWdzICYgU0hPVUxEX05PVF9QUk9DRVNTX1BPTFlGSUxMX0VWRU5UX1BMVUdJTlMpID09PSAwOyAvLyBXZSBkb24ndCBwcm9jZXNzIHRoZXNlIGV2ZW50cyB1bmxlc3Mgd2UgYXJlIGluIHRoZVxuICAvLyBldmVudCdzIG5hdGl2ZSBcImJ1YmJsZVwiIHBoYXNlLCB3aGljaCBtZWFucyB0aGF0IHdlJ3JlXG4gIC8vIG5vdCBpbiB0aGUgY2FwdHVyZSBwaGFzZS4gVGhhdCdzIGJlY2F1c2Ugd2UgZW11bGF0ZVxuICAvLyB0aGUgY2FwdHVyZSBwaGFzZSBoZXJlIHN0aWxsLiBUaGlzIGlzIGEgdHJhZGUtb2ZmLFxuICAvLyBiZWNhdXNlIGluIGFuIGlkZWFsIHdvcmxkIHdlIHdvdWxkIG5vdCBlbXVsYXRlIGFuZCB1c2VcbiAgLy8gdGhlIHBoYXNlcyBwcm9wZXJseSwgbGlrZSB3ZSBkbyB3aXRoIHRoZSBTaW1wbGVFdmVudFxuICAvLyBwbHVnaW4uIEhvd2V2ZXIsIHRoZSBwbHVnaW5zIGJlbG93IGVpdGhlciBleHBlY3RcbiAgLy8gZW11bGF0aW9uIChFbnRlckxlYXZlKSBvciB1c2Ugc3RhdGUgbG9jYWxpemVkIHRvIHRoYXRcbiAgLy8gcGx1Z2luIChCZWZvcmVJbnB1dCwgQ2hhbmdlLCBTZWxlY3QpLiBUaGUgc3RhdGUgaW5cbiAgLy8gdGhlc2UgbW9kdWxlcyBjb21wbGljYXRlcyB0aGluZ3MsIGFzIHlvdSdsbCBlc3NlbnRpYWxseVxuICAvLyBnZXQgdGhlIGNhc2Ugd2hlcmUgdGhlIGNhcHR1cmUgcGhhc2UgZXZlbnQgbWlnaHQgY2hhbmdlXG4gIC8vIHN0YXRlLCBvbmx5IGZvciB0aGUgZm9sbG93aW5nIGJ1YmJsZSBldmVudCB0byBjb21lIGluXG4gIC8vIGxhdGVyIGFuZCBub3QgdHJpZ2dlciBhbnl0aGluZyBhcyB0aGUgc3RhdGUgbm93XG4gIC8vIGludmFsaWRhdGVzIHRoZSBoZXVyaXN0aWNzIG9mIHRoZSBldmVudCBwbHVnaW4uIFdlXG4gIC8vIGNvdWxkIGFsdGVyIGFsbCB0aGVzZSBwbHVnaW5zIHRvIHdvcmsgaW4gc3VjaCB3YXlzLCBidXRcbiAgLy8gdGhhdCBtaWdodCBjYXVzZSBvdGhlciB1bmtub3duIHNpZGUtZWZmZWN0cyB0aGF0IHdlXG4gIC8vIGNhbid0IGZvcnNlZSByaWdodCBub3cuXG5cbiAgaWYgKHNob3VsZFByb2Nlc3NQb2x5ZmlsbFBsdWdpbnMpIHtcbiAgICBleHRyYWN0RXZlbnRzJDIoZGlzcGF0Y2hRdWV1ZSwgZG9tRXZlbnROYW1lLCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQsIGV2ZW50U3lzdGVtRmxhZ3MpO1xuICAgIGV4dHJhY3RFdmVudHMkMShkaXNwYXRjaFF1ZXVlLCBkb21FdmVudE5hbWUsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG4gICAgZXh0cmFjdEV2ZW50cyQzKGRpc3BhdGNoUXVldWUsIGRvbUV2ZW50TmFtZSwgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbiAgICBleHRyYWN0RXZlbnRzKGRpc3BhdGNoUXVldWUsIGRvbUV2ZW50TmFtZSwgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbiAgfVxufSAvLyBMaXN0IG9mIGV2ZW50cyB0aGF0IG5lZWQgdG8gYmUgaW5kaXZpZHVhbGx5IGF0dGFjaGVkIHRvIG1lZGlhIGVsZW1lbnRzLlxuXG5cbnZhciBtZWRpYUV2ZW50VHlwZXMgPSBbJ2Fib3J0JywgJ2NhbnBsYXknLCAnY2FucGxheXRocm91Z2gnLCAnZHVyYXRpb25jaGFuZ2UnLCAnZW1wdGllZCcsICdlbmNyeXB0ZWQnLCAnZW5kZWQnLCAnZXJyb3InLCAnbG9hZGVkZGF0YScsICdsb2FkZWRtZXRhZGF0YScsICdsb2Fkc3RhcnQnLCAncGF1c2UnLCAncGxheScsICdwbGF5aW5nJywgJ3Byb2dyZXNzJywgJ3JhdGVjaGFuZ2UnLCAnc2Vla2VkJywgJ3NlZWtpbmcnLCAnc3RhbGxlZCcsICdzdXNwZW5kJywgJ3RpbWV1cGRhdGUnLCAndm9sdW1lY2hhbmdlJywgJ3dhaXRpbmcnXTsgLy8gV2Ugc2hvdWxkIG5vdCBkZWxlZ2F0ZSB0aGVzZSBldmVudHMgdG8gdGhlIGNvbnRhaW5lciwgYnV0IHJhdGhlclxuLy8gc2V0IHRoZW0gb24gdGhlIGFjdHVhbCB0YXJnZXQgZWxlbWVudCBpdHNlbGYuIFRoaXMgaXMgcHJpbWFyaWx5XG4vLyBiZWNhdXNlIHRoZXNlIGV2ZW50cyBkbyBub3QgY29uc2lzdGVudGx5IGJ1YmJsZSBpbiB0aGUgRE9NLlxuXG52YXIgbm9uRGVsZWdhdGVkRXZlbnRzID0gbmV3IFNldChbJ2NhbmNlbCcsICdjbG9zZScsICdpbnZhbGlkJywgJ2xvYWQnLCAnc2Nyb2xsJywgJ3RvZ2dsZSddLmNvbmNhdChtZWRpYUV2ZW50VHlwZXMpKTtcblxuZnVuY3Rpb24gZXhlY3V0ZURpc3BhdGNoKGV2ZW50LCBsaXN0ZW5lciwgY3VycmVudFRhcmdldCkge1xuICB2YXIgdHlwZSA9IGV2ZW50LnR5cGUgfHwgJ3Vua25vd24tZXZlbnQnO1xuICBldmVudC5jdXJyZW50VGFyZ2V0ID0gY3VycmVudFRhcmdldDtcbiAgaW52b2tlR3VhcmRlZENhbGxiYWNrQW5kQ2F0Y2hGaXJzdEVycm9yKHR5cGUsIGxpc3RlbmVyLCB1bmRlZmluZWQsIGV2ZW50KTtcbiAgZXZlbnQuY3VycmVudFRhcmdldCA9IG51bGw7XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NEaXNwYXRjaFF1ZXVlSXRlbXNJbk9yZGVyKGV2ZW50LCBkaXNwYXRjaExpc3RlbmVycywgaW5DYXB0dXJlUGhhc2UpIHtcbiAgdmFyIHByZXZpb3VzSW5zdGFuY2U7XG5cbiAgaWYgKGluQ2FwdHVyZVBoYXNlKSB7XG4gICAgZm9yICh2YXIgaSA9IGRpc3BhdGNoTGlzdGVuZXJzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICB2YXIgX2Rpc3BhdGNoTGlzdGVuZXJzJGkgPSBkaXNwYXRjaExpc3RlbmVyc1tpXSxcbiAgICAgICAgICBpbnN0YW5jZSA9IF9kaXNwYXRjaExpc3RlbmVycyRpLmluc3RhbmNlLFxuICAgICAgICAgIGN1cnJlbnRUYXJnZXQgPSBfZGlzcGF0Y2hMaXN0ZW5lcnMkaS5jdXJyZW50VGFyZ2V0LFxuICAgICAgICAgIGxpc3RlbmVyID0gX2Rpc3BhdGNoTGlzdGVuZXJzJGkubGlzdGVuZXI7XG5cbiAgICAgIGlmIChpbnN0YW5jZSAhPT0gcHJldmlvdXNJbnN0YW5jZSAmJiBldmVudC5pc1Byb3BhZ2F0aW9uU3RvcHBlZCgpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgZXhlY3V0ZURpc3BhdGNoKGV2ZW50LCBsaXN0ZW5lciwgY3VycmVudFRhcmdldCk7XG4gICAgICBwcmV2aW91c0luc3RhbmNlID0gaW5zdGFuY2U7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBkaXNwYXRjaExpc3RlbmVycy5sZW5ndGg7IF9pKyspIHtcbiAgICAgIHZhciBfZGlzcGF0Y2hMaXN0ZW5lcnMkX2kgPSBkaXNwYXRjaExpc3RlbmVyc1tfaV0sXG4gICAgICAgICAgX2luc3RhbmNlID0gX2Rpc3BhdGNoTGlzdGVuZXJzJF9pLmluc3RhbmNlLFxuICAgICAgICAgIF9jdXJyZW50VGFyZ2V0ID0gX2Rpc3BhdGNoTGlzdGVuZXJzJF9pLmN1cnJlbnRUYXJnZXQsXG4gICAgICAgICAgX2xpc3RlbmVyID0gX2Rpc3BhdGNoTGlzdGVuZXJzJF9pLmxpc3RlbmVyO1xuXG4gICAgICBpZiAoX2luc3RhbmNlICE9PSBwcmV2aW91c0luc3RhbmNlICYmIGV2ZW50LmlzUHJvcGFnYXRpb25TdG9wcGVkKCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBleGVjdXRlRGlzcGF0Y2goZXZlbnQsIF9saXN0ZW5lciwgX2N1cnJlbnRUYXJnZXQpO1xuICAgICAgcHJldmlvdXNJbnN0YW5jZSA9IF9pbnN0YW5jZTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJvY2Vzc0Rpc3BhdGNoUXVldWUoZGlzcGF0Y2hRdWV1ZSwgZXZlbnRTeXN0ZW1GbGFncykge1xuICB2YXIgaW5DYXB0dXJlUGhhc2UgPSAoZXZlbnRTeXN0ZW1GbGFncyAmIElTX0NBUFRVUkVfUEhBU0UpICE9PSAwO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZGlzcGF0Y2hRdWV1ZS5sZW5ndGg7IGkrKykge1xuICAgIHZhciBfZGlzcGF0Y2hRdWV1ZSRpID0gZGlzcGF0Y2hRdWV1ZVtpXSxcbiAgICAgICAgZXZlbnQgPSBfZGlzcGF0Y2hRdWV1ZSRpLmV2ZW50LFxuICAgICAgICBsaXN0ZW5lcnMgPSBfZGlzcGF0Y2hRdWV1ZSRpLmxpc3RlbmVycztcbiAgICBwcm9jZXNzRGlzcGF0Y2hRdWV1ZUl0ZW1zSW5PcmRlcihldmVudCwgbGlzdGVuZXJzLCBpbkNhcHR1cmVQaGFzZSk7IC8vICBldmVudCBzeXN0ZW0gZG9lc24ndCB1c2UgcG9vbGluZy5cbiAgfSAvLyBUaGlzIHdvdWxkIGJlIGEgZ29vZCB0aW1lIHRvIHJldGhyb3cgaWYgYW55IG9mIHRoZSBldmVudCBoYW5kbGVycyB0aHJldy5cblxuXG4gIHJldGhyb3dDYXVnaHRFcnJvcigpO1xufVxuXG5mdW5jdGlvbiBkaXNwYXRjaEV2ZW50c0ZvclBsdWdpbnMoZG9tRXZlbnROYW1lLCBldmVudFN5c3RlbUZsYWdzLCBuYXRpdmVFdmVudCwgdGFyZ2V0SW5zdCwgdGFyZ2V0Q29udGFpbmVyKSB7XG4gIHZhciBuYXRpdmVFdmVudFRhcmdldCA9IGdldEV2ZW50VGFyZ2V0KG5hdGl2ZUV2ZW50KTtcbiAgdmFyIGRpc3BhdGNoUXVldWUgPSBbXTtcbiAgZXh0cmFjdEV2ZW50cyQ1KGRpc3BhdGNoUXVldWUsIGRvbUV2ZW50TmFtZSwgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0LCBldmVudFN5c3RlbUZsYWdzKTtcbiAgcHJvY2Vzc0Rpc3BhdGNoUXVldWUoZGlzcGF0Y2hRdWV1ZSwgZXZlbnRTeXN0ZW1GbGFncyk7XG59XG5cbmZ1bmN0aW9uIGxpc3RlblRvTm9uRGVsZWdhdGVkRXZlbnQoZG9tRXZlbnROYW1lLCB0YXJnZXRFbGVtZW50KSB7XG4gIHZhciBpc0NhcHR1cmVQaGFzZUxpc3RlbmVyID0gZmFsc2U7XG4gIHZhciBsaXN0ZW5lclNldCA9IGdldEV2ZW50TGlzdGVuZXJTZXQodGFyZ2V0RWxlbWVudCk7XG4gIHZhciBsaXN0ZW5lclNldEtleSA9IGdldExpc3RlbmVyU2V0S2V5KGRvbUV2ZW50TmFtZSwgaXNDYXB0dXJlUGhhc2VMaXN0ZW5lcik7XG5cbiAgaWYgKCFsaXN0ZW5lclNldC5oYXMobGlzdGVuZXJTZXRLZXkpKSB7XG4gICAgYWRkVHJhcHBlZEV2ZW50TGlzdGVuZXIodGFyZ2V0RWxlbWVudCwgZG9tRXZlbnROYW1lLCBJU19OT05fREVMRUdBVEVELCBpc0NhcHR1cmVQaGFzZUxpc3RlbmVyKTtcbiAgICBsaXN0ZW5lclNldC5hZGQobGlzdGVuZXJTZXRLZXkpO1xuICB9XG59XG52YXIgbGlzdGVuaW5nTWFya2VyID0gJ19yZWFjdExpc3RlbmluZycgKyBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zbGljZSgyKTtcbmZ1bmN0aW9uIGxpc3RlblRvQWxsU3VwcG9ydGVkRXZlbnRzKHJvb3RDb250YWluZXJFbGVtZW50KSB7XG4gIHtcbiAgICBpZiAocm9vdENvbnRhaW5lckVsZW1lbnRbbGlzdGVuaW5nTWFya2VyXSkge1xuICAgICAgLy8gUGVyZm9ybWFuY2Ugb3B0aW1pemF0aW9uOiBkb24ndCBpdGVyYXRlIHRocm91Z2ggZXZlbnRzXG4gICAgICAvLyBmb3IgdGhlIHNhbWUgcG9ydGFsIGNvbnRhaW5lciBvciByb290IG5vZGUgbW9yZSB0aGFuIG9uY2UuXG4gICAgICAvLyBUT0RPOiBvbmNlIHdlIHJlbW92ZSB0aGUgZmxhZywgd2UgbWF5IGJlIGFibGUgdG8gYWxzb1xuICAgICAgLy8gcmVtb3ZlIHNvbWUgb2YgdGhlIGJvb2trZWVwaW5nIG1hcHMgdXNlZCBmb3IgbGF6aW5lc3MuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgcm9vdENvbnRhaW5lckVsZW1lbnRbbGlzdGVuaW5nTWFya2VyXSA9IHRydWU7XG4gICAgYWxsTmF0aXZlRXZlbnRzLmZvckVhY2goZnVuY3Rpb24gKGRvbUV2ZW50TmFtZSkge1xuICAgICAgaWYgKCFub25EZWxlZ2F0ZWRFdmVudHMuaGFzKGRvbUV2ZW50TmFtZSkpIHtcbiAgICAgICAgbGlzdGVuVG9OYXRpdmVFdmVudChkb21FdmVudE5hbWUsIGZhbHNlLCByb290Q29udGFpbmVyRWxlbWVudCwgbnVsbCk7XG4gICAgICB9XG5cbiAgICAgIGxpc3RlblRvTmF0aXZlRXZlbnQoZG9tRXZlbnROYW1lLCB0cnVlLCByb290Q29udGFpbmVyRWxlbWVudCwgbnVsbCk7XG4gICAgfSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGxpc3RlblRvTmF0aXZlRXZlbnQoZG9tRXZlbnROYW1lLCBpc0NhcHR1cmVQaGFzZUxpc3RlbmVyLCByb290Q29udGFpbmVyRWxlbWVudCwgdGFyZ2V0RWxlbWVudCkge1xuICB2YXIgZXZlbnRTeXN0ZW1GbGFncyA9IGFyZ3VtZW50cy5sZW5ndGggPiA0ICYmIGFyZ3VtZW50c1s0XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzRdIDogMDtcbiAgdmFyIHRhcmdldCA9IHJvb3RDb250YWluZXJFbGVtZW50OyAvLyBzZWxlY3Rpb25jaGFuZ2UgbmVlZHMgdG8gYmUgYXR0YWNoZWQgdG8gdGhlIGRvY3VtZW50XG4gIC8vIG90aGVyd2lzZSBpdCB3b24ndCBjYXB0dXJlIGluY29taW5nIGV2ZW50cyB0aGF0IGFyZSBvbmx5XG4gIC8vIHRyaWdnZXJlZCBvbiB0aGUgZG9jdW1lbnQgZGlyZWN0bHkuXG5cbiAgaWYgKGRvbUV2ZW50TmFtZSA9PT0gJ3NlbGVjdGlvbmNoYW5nZScgJiYgcm9vdENvbnRhaW5lckVsZW1lbnQubm9kZVR5cGUgIT09IERPQ1VNRU5UX05PREUpIHtcbiAgICB0YXJnZXQgPSByb290Q29udGFpbmVyRWxlbWVudC5vd25lckRvY3VtZW50O1xuICB9IC8vIElmIHRoZSBldmVudCBjYW4gYmUgZGVsZWdhdGVkIChvciBpcyBjYXB0dXJlIHBoYXNlKSwgd2UgY2FuXG4gIC8vIHJlZ2lzdGVyIGl0IHRvIHRoZSByb290IGNvbnRhaW5lci4gT3RoZXJ3aXNlLCB3ZSBzaG91bGRcbiAgLy8gcmVnaXN0ZXIgdGhlIGV2ZW50IHRvIHRoZSB0YXJnZXQgZWxlbWVudCBhbmQgbWFyayBpdCBhc1xuICAvLyBhIG5vbi1kZWxlZ2F0ZWQgZXZlbnQuXG5cblxuICBpZiAodGFyZ2V0RWxlbWVudCAhPT0gbnVsbCAmJiAhaXNDYXB0dXJlUGhhc2VMaXN0ZW5lciAmJiBub25EZWxlZ2F0ZWRFdmVudHMuaGFzKGRvbUV2ZW50TmFtZSkpIHtcbiAgICAvLyBGb3IgYWxsIG5vbi1kZWxlZ2F0ZWQgZXZlbnRzLCBhcGFydCBmcm9tIHNjcm9sbCwgd2UgYXR0YWNoXG4gICAgLy8gdGhlaXIgZXZlbnQgbGlzdGVuZXJzIHRvIHRoZSByZXNwZWN0aXZlIGVsZW1lbnRzIHRoYXQgdGhlaXJcbiAgICAvLyBldmVudHMgZmlyZSBvbi4gVGhhdCBtZWFucyB3ZSBjYW4gc2tpcCB0aGlzIHN0ZXAsIGFzIGV2ZW50XG4gICAgLy8gbGlzdGVuZXIgaGFzIGFscmVhZHkgYmVlbiBhZGRlZCBwcmV2aW91c2x5LiBIb3dldmVyLCB3ZVxuICAgIC8vIHNwZWNpYWwgY2FzZSB0aGUgc2Nyb2xsIGV2ZW50IGJlY2F1c2UgdGhlIHJlYWxpdHkgaXMgdGhhdCBhbnlcbiAgICAvLyBlbGVtZW50IGNhbiBzY3JvbGwuXG4gICAgLy8gVE9ETzogaWRlYWxseSwgd2UnZCBldmVudHVhbGx5IGFwcGx5IHRoZSBzYW1lIGxvZ2ljIHRvIGFsbFxuICAgIC8vIGV2ZW50cyBmcm9tIHRoZSBub25EZWxlZ2F0ZWRFdmVudHMgbGlzdC4gVGhlbiB3ZSBjYW4gcmVtb3ZlXG4gICAgLy8gdGhpcyBzcGVjaWFsIGNhc2UgYW5kIHVzZSB0aGUgc2FtZSBsb2dpYyBmb3IgYWxsIGV2ZW50cy5cbiAgICBpZiAoZG9tRXZlbnROYW1lICE9PSAnc2Nyb2xsJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGV2ZW50U3lzdGVtRmxhZ3MgfD0gSVNfTk9OX0RFTEVHQVRFRDtcbiAgICB0YXJnZXQgPSB0YXJnZXRFbGVtZW50O1xuICB9XG5cbiAgdmFyIGxpc3RlbmVyU2V0ID0gZ2V0RXZlbnRMaXN0ZW5lclNldCh0YXJnZXQpO1xuICB2YXIgbGlzdGVuZXJTZXRLZXkgPSBnZXRMaXN0ZW5lclNldEtleShkb21FdmVudE5hbWUsIGlzQ2FwdHVyZVBoYXNlTGlzdGVuZXIpOyAvLyBJZiB0aGUgbGlzdGVuZXIgZW50cnkgaXMgZW1wdHkgb3Igd2Ugc2hvdWxkIHVwZ3JhZGUsIHRoZW5cbiAgLy8gd2UgbmVlZCB0byB0cmFwIGFuIGV2ZW50IGxpc3RlbmVyIG9udG8gdGhlIHRhcmdldC5cblxuICBpZiAoIWxpc3RlbmVyU2V0LmhhcyhsaXN0ZW5lclNldEtleSkpIHtcbiAgICBpZiAoaXNDYXB0dXJlUGhhc2VMaXN0ZW5lcikge1xuICAgICAgZXZlbnRTeXN0ZW1GbGFncyB8PSBJU19DQVBUVVJFX1BIQVNFO1xuICAgIH1cblxuICAgIGFkZFRyYXBwZWRFdmVudExpc3RlbmVyKHRhcmdldCwgZG9tRXZlbnROYW1lLCBldmVudFN5c3RlbUZsYWdzLCBpc0NhcHR1cmVQaGFzZUxpc3RlbmVyKTtcbiAgICBsaXN0ZW5lclNldC5hZGQobGlzdGVuZXJTZXRLZXkpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGFkZFRyYXBwZWRFdmVudExpc3RlbmVyKHRhcmdldENvbnRhaW5lciwgZG9tRXZlbnROYW1lLCBldmVudFN5c3RlbUZsYWdzLCBpc0NhcHR1cmVQaGFzZUxpc3RlbmVyLCBpc0RlZmVycmVkTGlzdGVuZXJGb3JMZWdhY3lGQlN1cHBvcnQpIHtcbiAgdmFyIGxpc3RlbmVyID0gY3JlYXRlRXZlbnRMaXN0ZW5lcldyYXBwZXJXaXRoUHJpb3JpdHkodGFyZ2V0Q29udGFpbmVyLCBkb21FdmVudE5hbWUsIGV2ZW50U3lzdGVtRmxhZ3MpOyAvLyBJZiBwYXNzaXZlIG9wdGlvbiBpcyBub3Qgc3VwcG9ydGVkLCB0aGVuIHRoZSBldmVudCB3aWxsIGJlXG4gIC8vIGFjdGl2ZSBhbmQgbm90IHBhc3NpdmUuXG5cbiAgdmFyIGlzUGFzc2l2ZUxpc3RlbmVyID0gdW5kZWZpbmVkO1xuXG4gIGlmIChwYXNzaXZlQnJvd3NlckV2ZW50c1N1cHBvcnRlZCkge1xuICAgIC8vIEJyb3dzZXJzIGludHJvZHVjZWQgYW4gaW50ZXJ2ZW50aW9uLCBtYWtpbmcgdGhlc2UgZXZlbnRzXG4gICAgLy8gcGFzc2l2ZSBieSBkZWZhdWx0IG9uIGRvY3VtZW50LiBSZWFjdCBkb2Vzbid0IGJpbmQgdGhlbVxuICAgIC8vIHRvIGRvY3VtZW50IGFueW1vcmUsIGJ1dCBjaGFuZ2luZyB0aGlzIG5vdyB3b3VsZCB1bmRvXG4gICAgLy8gdGhlIHBlcmZvcm1hbmNlIHdpbnMgZnJvbSB0aGUgY2hhbmdlLiBTbyB3ZSBlbXVsYXRlXG4gICAgLy8gdGhlIGV4aXN0aW5nIGJlaGF2aW9yIG1hbnVhbGx5IG9uIHRoZSByb290cyBub3cuXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xOTY1MVxuICAgIGlmIChkb21FdmVudE5hbWUgPT09ICd0b3VjaHN0YXJ0JyB8fCBkb21FdmVudE5hbWUgPT09ICd0b3VjaG1vdmUnIHx8IGRvbUV2ZW50TmFtZSA9PT0gJ3doZWVsJykge1xuICAgICAgaXNQYXNzaXZlTGlzdGVuZXIgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHRhcmdldENvbnRhaW5lciA9ICB0YXJnZXRDb250YWluZXI7XG4gIHZhciB1bnN1YnNjcmliZUxpc3RlbmVyOyAvLyBXaGVuIGxlZ2FjeUZCU3VwcG9ydCBpcyBlbmFibGVkLCBpdCdzIGZvciB3aGVuIHdlXG5cblxuICBpZiAoaXNDYXB0dXJlUGhhc2VMaXN0ZW5lcikge1xuICAgIGlmIChpc1Bhc3NpdmVMaXN0ZW5lciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB1bnN1YnNjcmliZUxpc3RlbmVyID0gYWRkRXZlbnRDYXB0dXJlTGlzdGVuZXJXaXRoUGFzc2l2ZUZsYWcodGFyZ2V0Q29udGFpbmVyLCBkb21FdmVudE5hbWUsIGxpc3RlbmVyLCBpc1Bhc3NpdmVMaXN0ZW5lcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHVuc3Vic2NyaWJlTGlzdGVuZXIgPSBhZGRFdmVudENhcHR1cmVMaXN0ZW5lcih0YXJnZXRDb250YWluZXIsIGRvbUV2ZW50TmFtZSwgbGlzdGVuZXIpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoaXNQYXNzaXZlTGlzdGVuZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdW5zdWJzY3JpYmVMaXN0ZW5lciA9IGFkZEV2ZW50QnViYmxlTGlzdGVuZXJXaXRoUGFzc2l2ZUZsYWcodGFyZ2V0Q29udGFpbmVyLCBkb21FdmVudE5hbWUsIGxpc3RlbmVyLCBpc1Bhc3NpdmVMaXN0ZW5lcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHVuc3Vic2NyaWJlTGlzdGVuZXIgPSBhZGRFdmVudEJ1YmJsZUxpc3RlbmVyKHRhcmdldENvbnRhaW5lciwgZG9tRXZlbnROYW1lLCBsaXN0ZW5lcik7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGlzTWF0Y2hpbmdSb290Q29udGFpbmVyKGdyYW5kQ29udGFpbmVyLCB0YXJnZXRDb250YWluZXIpIHtcbiAgcmV0dXJuIGdyYW5kQ29udGFpbmVyID09PSB0YXJnZXRDb250YWluZXIgfHwgZ3JhbmRDb250YWluZXIubm9kZVR5cGUgPT09IENPTU1FTlRfTk9ERSAmJiBncmFuZENvbnRhaW5lci5wYXJlbnROb2RlID09PSB0YXJnZXRDb250YWluZXI7XG59XG5cbmZ1bmN0aW9uIGRpc3BhdGNoRXZlbnRGb3JQbHVnaW5FdmVudFN5c3RlbShkb21FdmVudE5hbWUsIGV2ZW50U3lzdGVtRmxhZ3MsIG5hdGl2ZUV2ZW50LCB0YXJnZXRJbnN0LCB0YXJnZXRDb250YWluZXIpIHtcbiAgdmFyIGFuY2VzdG9ySW5zdCA9IHRhcmdldEluc3Q7XG5cbiAgaWYgKChldmVudFN5c3RlbUZsYWdzICYgSVNfRVZFTlRfSEFORExFX05PTl9NQU5BR0VEX05PREUpID09PSAwICYmIChldmVudFN5c3RlbUZsYWdzICYgSVNfTk9OX0RFTEVHQVRFRCkgPT09IDApIHtcbiAgICB2YXIgdGFyZ2V0Q29udGFpbmVyTm9kZSA9IHRhcmdldENvbnRhaW5lcjsgLy8gSWYgd2UgYXJlIHVzaW5nIHRoZSBsZWdhY3kgRkIgc3VwcG9ydCBmbGFnLCB3ZVxuXG4gICAgaWYgKHRhcmdldEluc3QgIT09IG51bGwpIHtcbiAgICAgIC8vIFRoZSBiZWxvdyBsb2dpYyBhdHRlbXB0cyB0byB3b3JrIG91dCBpZiB3ZSBuZWVkIHRvIGNoYW5nZVxuICAgICAgLy8gdGhlIHRhcmdldCBmaWJlciB0byBhIGRpZmZlcmVudCBhbmNlc3Rvci4gV2UgaGFkIHNpbWlsYXIgbG9naWNcbiAgICAgIC8vIGluIHRoZSBsZWdhY3kgZXZlbnQgc3lzdGVtLCBleGNlcHQgdGhlIGJpZyBkaWZmZXJlbmNlIGJldHdlZW5cbiAgICAgIC8vIHN5c3RlbXMgaXMgdGhhdCB0aGUgbW9kZXJuIGV2ZW50IHN5c3RlbSBub3cgaGFzIGFuIGV2ZW50IGxpc3RlbmVyXG4gICAgICAvLyBhdHRhY2hlZCB0byBlYWNoIFJlYWN0IFJvb3QgYW5kIFJlYWN0IFBvcnRhbCBSb290LiBUb2dldGhlcixcbiAgICAgIC8vIHRoZSBET00gbm9kZXMgcmVwcmVzZW50aW5nIHRoZXNlIHJvb3RzIGFyZSB0aGUgXCJyb290Q29udGFpbmVyXCIuXG4gICAgICAvLyBUbyBmaWd1cmUgb3V0IHdoaWNoIGFuY2VzdG9yIGluc3RhbmNlIHdlIHNob3VsZCB1c2UsIHdlIHRyYXZlcnNlXG4gICAgICAvLyB1cCB0aGUgZmliZXIgdHJlZSBmcm9tIHRoZSB0YXJnZXQgaW5zdGFuY2UgYW5kIGF0dGVtcHQgdG8gZmluZFxuICAgICAgLy8gcm9vdCBib3VuZGFyaWVzIHRoYXQgbWF0Y2ggdGhhdCBvZiBvdXIgY3VycmVudCBcInJvb3RDb250YWluZXJcIi5cbiAgICAgIC8vIElmIHdlIGZpbmQgdGhhdCBcInJvb3RDb250YWluZXJcIiwgd2UgZmluZCB0aGUgcGFyZW50IGZpYmVyXG4gICAgICAvLyBzdWItdHJlZSBmb3IgdGhhdCByb290IGFuZCBtYWtlIHRoYXQgb3VyIGFuY2VzdG9yIGluc3RhbmNlLlxuICAgICAgdmFyIG5vZGUgPSB0YXJnZXRJbnN0O1xuXG4gICAgICBtYWluTG9vcDogd2hpbGUgKHRydWUpIHtcbiAgICAgICAgaWYgKG5vZGUgPT09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbm9kZVRhZyA9IG5vZGUudGFnO1xuXG4gICAgICAgIGlmIChub2RlVGFnID09PSBIb3N0Um9vdCB8fCBub2RlVGFnID09PSBIb3N0UG9ydGFsKSB7XG4gICAgICAgICAgdmFyIGNvbnRhaW5lciA9IG5vZGUuc3RhdGVOb2RlLmNvbnRhaW5lckluZm87XG5cbiAgICAgICAgICBpZiAoaXNNYXRjaGluZ1Jvb3RDb250YWluZXIoY29udGFpbmVyLCB0YXJnZXRDb250YWluZXJOb2RlKSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKG5vZGVUYWcgPT09IEhvc3RQb3J0YWwpIHtcbiAgICAgICAgICAgIC8vIFRoZSB0YXJnZXQgaXMgYSBwb3J0YWwsIGJ1dCBpdCdzIG5vdCB0aGUgcm9vdENvbnRhaW5lciB3ZSdyZSBsb29raW5nIGZvci5cbiAgICAgICAgICAgIC8vIE5vcm1hbGx5IHBvcnRhbHMgaGFuZGxlIHRoZWlyIG93biBldmVudHMgYWxsIHRoZSB3YXkgZG93biB0byB0aGUgcm9vdC5cbiAgICAgICAgICAgIC8vIFNvIHdlIHNob3VsZCBiZSBhYmxlIHRvIHN0b3Agbm93LiBIb3dldmVyLCB3ZSBkb24ndCBrbm93IGlmIHRoaXMgcG9ydGFsXG4gICAgICAgICAgICAvLyB3YXMgcGFydCBvZiAqb3VyKiByb290LlxuICAgICAgICAgICAgdmFyIGdyYW5kTm9kZSA9IG5vZGUucmV0dXJuO1xuXG4gICAgICAgICAgICB3aGlsZSAoZ3JhbmROb2RlICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgIHZhciBncmFuZFRhZyA9IGdyYW5kTm9kZS50YWc7XG5cbiAgICAgICAgICAgICAgaWYgKGdyYW5kVGFnID09PSBIb3N0Um9vdCB8fCBncmFuZFRhZyA9PT0gSG9zdFBvcnRhbCkge1xuICAgICAgICAgICAgICAgIHZhciBncmFuZENvbnRhaW5lciA9IGdyYW5kTm9kZS5zdGF0ZU5vZGUuY29udGFpbmVySW5mbztcblxuICAgICAgICAgICAgICAgIGlmIChpc01hdGNoaW5nUm9vdENvbnRhaW5lcihncmFuZENvbnRhaW5lciwgdGFyZ2V0Q29udGFpbmVyTm9kZSkpIHtcbiAgICAgICAgICAgICAgICAgIC8vIFRoaXMgaXMgdGhlIHJvb3RDb250YWluZXIgd2UncmUgbG9va2luZyBmb3IgYW5kIHdlIGZvdW5kIGl0IGFzXG4gICAgICAgICAgICAgICAgICAvLyBhIHBhcmVudCBvZiB0aGUgUG9ydGFsLiBUaGF0IG1lYW5zIHdlIGNhbiBpZ25vcmUgaXQgYmVjYXVzZSB0aGVcbiAgICAgICAgICAgICAgICAgIC8vIFBvcnRhbCB3aWxsIGJ1YmJsZSB0aHJvdWdoIHRvIHVzLlxuICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGdyYW5kTm9kZSA9IGdyYW5kTm9kZS5yZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSAvLyBOb3cgd2UgbmVlZCB0byBmaW5kIGl0J3MgY29ycmVzcG9uZGluZyBob3N0IGZpYmVyIGluIHRoZSBvdGhlclxuICAgICAgICAgIC8vIHRyZWUuIFRvIGRvIHRoaXMgd2UgY2FuIHVzZSBnZXRDbG9zZXN0SW5zdGFuY2VGcm9tTm9kZSwgYnV0IHdlXG4gICAgICAgICAgLy8gbmVlZCB0byB2YWxpZGF0ZSB0aGF0IHRoZSBmaWJlciBpcyBhIGhvc3QgaW5zdGFuY2UsIG90aGVyd2lzZVxuICAgICAgICAgIC8vIHdlIG5lZWQgdG8gdHJhdmVyc2UgdXAgdGhyb3VnaCB0aGUgRE9NIHRpbGwgd2UgZmluZCB0aGUgY29ycmVjdFxuICAgICAgICAgIC8vIG5vZGUgdGhhdCBpcyBmcm9tIHRoZSBvdGhlciB0cmVlLlxuXG5cbiAgICAgICAgICB3aGlsZSAoY29udGFpbmVyICE9PSBudWxsKSB7XG4gICAgICAgICAgICB2YXIgcGFyZW50Tm9kZSA9IGdldENsb3Nlc3RJbnN0YW5jZUZyb21Ob2RlKGNvbnRhaW5lcik7XG5cbiAgICAgICAgICAgIGlmIChwYXJlbnROb2RlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHBhcmVudFRhZyA9IHBhcmVudE5vZGUudGFnO1xuXG4gICAgICAgICAgICBpZiAocGFyZW50VGFnID09PSBIb3N0Q29tcG9uZW50IHx8IHBhcmVudFRhZyA9PT0gSG9zdFRleHQpIHtcbiAgICAgICAgICAgICAgbm9kZSA9IGFuY2VzdG9ySW5zdCA9IHBhcmVudE5vZGU7XG4gICAgICAgICAgICAgIGNvbnRpbnVlIG1haW5Mb29wO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb250YWluZXIgPSBjb250YWluZXIucGFyZW50Tm9kZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBub2RlID0gbm9kZS5yZXR1cm47XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgYmF0Y2hlZEV2ZW50VXBkYXRlcyhmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGRpc3BhdGNoRXZlbnRzRm9yUGx1Z2lucyhkb21FdmVudE5hbWUsIGV2ZW50U3lzdGVtRmxhZ3MsIG5hdGl2ZUV2ZW50LCBhbmNlc3Rvckluc3QpO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlRGlzcGF0Y2hMaXN0ZW5lcihpbnN0YW5jZSwgbGlzdGVuZXIsIGN1cnJlbnRUYXJnZXQpIHtcbiAgcmV0dXJuIHtcbiAgICBpbnN0YW5jZTogaW5zdGFuY2UsXG4gICAgbGlzdGVuZXI6IGxpc3RlbmVyLFxuICAgIGN1cnJlbnRUYXJnZXQ6IGN1cnJlbnRUYXJnZXRcbiAgfTtcbn1cblxuZnVuY3Rpb24gYWNjdW11bGF0ZVNpbmdsZVBoYXNlTGlzdGVuZXJzKHRhcmdldEZpYmVyLCByZWFjdE5hbWUsIG5hdGl2ZUV2ZW50VHlwZSwgaW5DYXB0dXJlUGhhc2UsIGFjY3VtdWxhdGVUYXJnZXRPbmx5KSB7XG4gIHZhciBjYXB0dXJlTmFtZSA9IHJlYWN0TmFtZSAhPT0gbnVsbCA/IHJlYWN0TmFtZSArICdDYXB0dXJlJyA6IG51bGw7XG4gIHZhciByZWFjdEV2ZW50TmFtZSA9IGluQ2FwdHVyZVBoYXNlID8gY2FwdHVyZU5hbWUgOiByZWFjdE5hbWU7XG4gIHZhciBsaXN0ZW5lcnMgPSBbXTtcbiAgdmFyIGluc3RhbmNlID0gdGFyZ2V0RmliZXI7XG4gIHZhciBsYXN0SG9zdENvbXBvbmVudCA9IG51bGw7IC8vIEFjY3VtdWxhdGUgYWxsIGluc3RhbmNlcyBhbmQgbGlzdGVuZXJzIHZpYSB0aGUgdGFyZ2V0IC0+IHJvb3QgcGF0aC5cblxuICB3aGlsZSAoaW5zdGFuY2UgIT09IG51bGwpIHtcbiAgICB2YXIgX2luc3RhbmNlMiA9IGluc3RhbmNlLFxuICAgICAgICBzdGF0ZU5vZGUgPSBfaW5zdGFuY2UyLnN0YXRlTm9kZSxcbiAgICAgICAgdGFnID0gX2luc3RhbmNlMi50YWc7IC8vIEhhbmRsZSBsaXN0ZW5lcnMgdGhhdCBhcmUgb24gSG9zdENvbXBvbmVudHMgKGkuZS4gPGRpdj4pXG5cbiAgICBpZiAodGFnID09PSBIb3N0Q29tcG9uZW50ICYmIHN0YXRlTm9kZSAhPT0gbnVsbCkge1xuICAgICAgbGFzdEhvc3RDb21wb25lbnQgPSBzdGF0ZU5vZGU7IC8vIGNyZWF0ZUV2ZW50SGFuZGxlIGxpc3RlbmVyc1xuXG5cbiAgICAgIGlmIChyZWFjdEV2ZW50TmFtZSAhPT0gbnVsbCkge1xuICAgICAgICB2YXIgbGlzdGVuZXIgPSBnZXRMaXN0ZW5lcihpbnN0YW5jZSwgcmVhY3RFdmVudE5hbWUpO1xuXG4gICAgICAgIGlmIChsaXN0ZW5lciAhPSBudWxsKSB7XG4gICAgICAgICAgbGlzdGVuZXJzLnB1c2goY3JlYXRlRGlzcGF0Y2hMaXN0ZW5lcihpbnN0YW5jZSwgbGlzdGVuZXIsIGxhc3RIb3N0Q29tcG9uZW50KSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IC8vIElmIHdlIGFyZSBvbmx5IGFjY3VtdWxhdGluZyBldmVudHMgZm9yIHRoZSB0YXJnZXQsIHRoZW4gd2UgZG9uJ3RcbiAgICAvLyBjb250aW51ZSB0byBwcm9wYWdhdGUgdGhyb3VnaCB0aGUgUmVhY3QgZmliZXIgdHJlZSB0byBmaW5kIG90aGVyXG4gICAgLy8gbGlzdGVuZXJzLlxuXG5cbiAgICBpZiAoYWNjdW11bGF0ZVRhcmdldE9ubHkpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGluc3RhbmNlID0gaW5zdGFuY2UucmV0dXJuO1xuICB9XG5cbiAgcmV0dXJuIGxpc3RlbmVycztcbn0gLy8gV2Ugc2hvdWxkIG9ubHkgdXNlIHRoaXMgZnVuY3Rpb24gZm9yOlxuLy8gLSBCZWZvcmVJbnB1dEV2ZW50UGx1Z2luXG4vLyAtIENoYW5nZUV2ZW50UGx1Z2luXG4vLyAtIFNlbGVjdEV2ZW50UGx1Z2luXG4vLyBUaGlzIGlzIGJlY2F1c2Ugd2Ugb25seSBwcm9jZXNzIHRoZXNlIHBsdWdpbnNcbi8vIGluIHRoZSBidWJibGUgcGhhc2UsIHNvIHdlIG5lZWQgdG8gYWNjdW11bGF0ZSB0d29cbi8vIHBoYXNlIGV2ZW50IGxpc3RlbmVycyAodmlhIGVtdWxhdGlvbikuXG5cbmZ1bmN0aW9uIGFjY3VtdWxhdGVUd29QaGFzZUxpc3RlbmVycyh0YXJnZXRGaWJlciwgcmVhY3ROYW1lKSB7XG4gIHZhciBjYXB0dXJlTmFtZSA9IHJlYWN0TmFtZSArICdDYXB0dXJlJztcbiAgdmFyIGxpc3RlbmVycyA9IFtdO1xuICB2YXIgaW5zdGFuY2UgPSB0YXJnZXRGaWJlcjsgLy8gQWNjdW11bGF0ZSBhbGwgaW5zdGFuY2VzIGFuZCBsaXN0ZW5lcnMgdmlhIHRoZSB0YXJnZXQgLT4gcm9vdCBwYXRoLlxuXG4gIHdoaWxlIChpbnN0YW5jZSAhPT0gbnVsbCkge1xuICAgIHZhciBfaW5zdGFuY2UzID0gaW5zdGFuY2UsXG4gICAgICAgIHN0YXRlTm9kZSA9IF9pbnN0YW5jZTMuc3RhdGVOb2RlLFxuICAgICAgICB0YWcgPSBfaW5zdGFuY2UzLnRhZzsgLy8gSGFuZGxlIGxpc3RlbmVycyB0aGF0IGFyZSBvbiBIb3N0Q29tcG9uZW50cyAoaS5lLiA8ZGl2PilcblxuICAgIGlmICh0YWcgPT09IEhvc3RDb21wb25lbnQgJiYgc3RhdGVOb2RlICE9PSBudWxsKSB7XG4gICAgICB2YXIgY3VycmVudFRhcmdldCA9IHN0YXRlTm9kZTtcbiAgICAgIHZhciBjYXB0dXJlTGlzdGVuZXIgPSBnZXRMaXN0ZW5lcihpbnN0YW5jZSwgY2FwdHVyZU5hbWUpO1xuXG4gICAgICBpZiAoY2FwdHVyZUxpc3RlbmVyICE9IG51bGwpIHtcbiAgICAgICAgbGlzdGVuZXJzLnVuc2hpZnQoY3JlYXRlRGlzcGF0Y2hMaXN0ZW5lcihpbnN0YW5jZSwgY2FwdHVyZUxpc3RlbmVyLCBjdXJyZW50VGFyZ2V0KSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBidWJibGVMaXN0ZW5lciA9IGdldExpc3RlbmVyKGluc3RhbmNlLCByZWFjdE5hbWUpO1xuXG4gICAgICBpZiAoYnViYmxlTGlzdGVuZXIgIT0gbnVsbCkge1xuICAgICAgICBsaXN0ZW5lcnMucHVzaChjcmVhdGVEaXNwYXRjaExpc3RlbmVyKGluc3RhbmNlLCBidWJibGVMaXN0ZW5lciwgY3VycmVudFRhcmdldCkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGluc3RhbmNlID0gaW5zdGFuY2UucmV0dXJuO1xuICB9XG5cbiAgcmV0dXJuIGxpc3RlbmVycztcbn1cblxuZnVuY3Rpb24gZ2V0UGFyZW50KGluc3QpIHtcbiAgaWYgKGluc3QgPT09IG51bGwpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGRvIHtcbiAgICBpbnN0ID0gaW5zdC5yZXR1cm47IC8vIFRPRE86IElmIHRoaXMgaXMgYSBIb3N0Um9vdCB3ZSBtaWdodCB3YW50IHRvIGJhaWwgb3V0LlxuICAgIC8vIFRoYXQgaXMgZGVwZW5kaW5nIG9uIGlmIHdlIHdhbnQgbmVzdGVkIHN1YnRyZWVzIChsYXllcnMpIHRvIGJ1YmJsZVxuICAgIC8vIGV2ZW50cyB0byB0aGVpciBwYXJlbnQuIFdlIGNvdWxkIGFsc28gZ28gdGhyb3VnaCBwYXJlbnROb2RlIG9uIHRoZVxuICAgIC8vIGhvc3Qgbm9kZSBidXQgdGhhdCB3b3VsZG4ndCB3b3JrIGZvciBSZWFjdCBOYXRpdmUgYW5kIGRvZXNuJ3QgbGV0IHVzXG4gICAgLy8gZG8gdGhlIHBvcnRhbCBmZWF0dXJlLlxuICB9IHdoaWxlIChpbnN0ICYmIGluc3QudGFnICE9PSBIb3N0Q29tcG9uZW50KTtcblxuICBpZiAoaW5zdCkge1xuICAgIHJldHVybiBpbnN0O1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG4vKipcbiAqIFJldHVybiB0aGUgbG93ZXN0IGNvbW1vbiBhbmNlc3RvciBvZiBBIGFuZCBCLCBvciBudWxsIGlmIHRoZXkgYXJlIGluXG4gKiBkaWZmZXJlbnQgdHJlZXMuXG4gKi9cblxuXG5mdW5jdGlvbiBnZXRMb3dlc3RDb21tb25BbmNlc3RvcihpbnN0QSwgaW5zdEIpIHtcbiAgdmFyIG5vZGVBID0gaW5zdEE7XG4gIHZhciBub2RlQiA9IGluc3RCO1xuICB2YXIgZGVwdGhBID0gMDtcblxuICBmb3IgKHZhciB0ZW1wQSA9IG5vZGVBOyB0ZW1wQTsgdGVtcEEgPSBnZXRQYXJlbnQodGVtcEEpKSB7XG4gICAgZGVwdGhBKys7XG4gIH1cblxuICB2YXIgZGVwdGhCID0gMDtcblxuICBmb3IgKHZhciB0ZW1wQiA9IG5vZGVCOyB0ZW1wQjsgdGVtcEIgPSBnZXRQYXJlbnQodGVtcEIpKSB7XG4gICAgZGVwdGhCKys7XG4gIH0gLy8gSWYgQSBpcyBkZWVwZXIsIGNyYXdsIHVwLlxuXG5cbiAgd2hpbGUgKGRlcHRoQSAtIGRlcHRoQiA+IDApIHtcbiAgICBub2RlQSA9IGdldFBhcmVudChub2RlQSk7XG4gICAgZGVwdGhBLS07XG4gIH0gLy8gSWYgQiBpcyBkZWVwZXIsIGNyYXdsIHVwLlxuXG5cbiAgd2hpbGUgKGRlcHRoQiAtIGRlcHRoQSA+IDApIHtcbiAgICBub2RlQiA9IGdldFBhcmVudChub2RlQik7XG4gICAgZGVwdGhCLS07XG4gIH0gLy8gV2FsayBpbiBsb2Nrc3RlcCB1bnRpbCB3ZSBmaW5kIGEgbWF0Y2guXG5cblxuICB2YXIgZGVwdGggPSBkZXB0aEE7XG5cbiAgd2hpbGUgKGRlcHRoLS0pIHtcbiAgICBpZiAobm9kZUEgPT09IG5vZGVCIHx8IG5vZGVCICE9PSBudWxsICYmIG5vZGVBID09PSBub2RlQi5hbHRlcm5hdGUpIHtcbiAgICAgIHJldHVybiBub2RlQTtcbiAgICB9XG5cbiAgICBub2RlQSA9IGdldFBhcmVudChub2RlQSk7XG4gICAgbm9kZUIgPSBnZXRQYXJlbnQobm9kZUIpO1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIGFjY3VtdWxhdGVFbnRlckxlYXZlTGlzdGVuZXJzRm9yRXZlbnQoZGlzcGF0Y2hRdWV1ZSwgZXZlbnQsIHRhcmdldCwgY29tbW9uLCBpbkNhcHR1cmVQaGFzZSkge1xuICB2YXIgcmVnaXN0cmF0aW9uTmFtZSA9IGV2ZW50Ll9yZWFjdE5hbWU7XG4gIHZhciBsaXN0ZW5lcnMgPSBbXTtcbiAgdmFyIGluc3RhbmNlID0gdGFyZ2V0O1xuXG4gIHdoaWxlIChpbnN0YW5jZSAhPT0gbnVsbCkge1xuICAgIGlmIChpbnN0YW5jZSA9PT0gY29tbW9uKSB7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICB2YXIgX2luc3RhbmNlNCA9IGluc3RhbmNlLFxuICAgICAgICBhbHRlcm5hdGUgPSBfaW5zdGFuY2U0LmFsdGVybmF0ZSxcbiAgICAgICAgc3RhdGVOb2RlID0gX2luc3RhbmNlNC5zdGF0ZU5vZGUsXG4gICAgICAgIHRhZyA9IF9pbnN0YW5jZTQudGFnO1xuXG4gICAgaWYgKGFsdGVybmF0ZSAhPT0gbnVsbCAmJiBhbHRlcm5hdGUgPT09IGNvbW1vbikge1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgaWYgKHRhZyA9PT0gSG9zdENvbXBvbmVudCAmJiBzdGF0ZU5vZGUgIT09IG51bGwpIHtcbiAgICAgIHZhciBjdXJyZW50VGFyZ2V0ID0gc3RhdGVOb2RlO1xuXG4gICAgICBpZiAoaW5DYXB0dXJlUGhhc2UpIHtcbiAgICAgICAgdmFyIGNhcHR1cmVMaXN0ZW5lciA9IGdldExpc3RlbmVyKGluc3RhbmNlLCByZWdpc3RyYXRpb25OYW1lKTtcblxuICAgICAgICBpZiAoY2FwdHVyZUxpc3RlbmVyICE9IG51bGwpIHtcbiAgICAgICAgICBsaXN0ZW5lcnMudW5zaGlmdChjcmVhdGVEaXNwYXRjaExpc3RlbmVyKGluc3RhbmNlLCBjYXB0dXJlTGlzdGVuZXIsIGN1cnJlbnRUYXJnZXQpKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICghaW5DYXB0dXJlUGhhc2UpIHtcbiAgICAgICAgdmFyIGJ1YmJsZUxpc3RlbmVyID0gZ2V0TGlzdGVuZXIoaW5zdGFuY2UsIHJlZ2lzdHJhdGlvbk5hbWUpO1xuXG4gICAgICAgIGlmIChidWJibGVMaXN0ZW5lciAhPSBudWxsKSB7XG4gICAgICAgICAgbGlzdGVuZXJzLnB1c2goY3JlYXRlRGlzcGF0Y2hMaXN0ZW5lcihpbnN0YW5jZSwgYnViYmxlTGlzdGVuZXIsIGN1cnJlbnRUYXJnZXQpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGluc3RhbmNlID0gaW5zdGFuY2UucmV0dXJuO1xuICB9XG5cbiAgaWYgKGxpc3RlbmVycy5sZW5ndGggIT09IDApIHtcbiAgICBkaXNwYXRjaFF1ZXVlLnB1c2goe1xuICAgICAgZXZlbnQ6IGV2ZW50LFxuICAgICAgbGlzdGVuZXJzOiBsaXN0ZW5lcnNcbiAgICB9KTtcbiAgfVxufSAvLyBXZSBzaG91bGQgb25seSB1c2UgdGhpcyBmdW5jdGlvbiBmb3I6XG4vLyAtIEVudGVyTGVhdmVFdmVudFBsdWdpblxuLy8gVGhpcyBpcyBiZWNhdXNlIHdlIG9ubHkgcHJvY2VzcyB0aGlzIHBsdWdpblxuLy8gaW4gdGhlIGJ1YmJsZSBwaGFzZSwgc28gd2UgbmVlZCB0byBhY2N1bXVsYXRlIHR3b1xuLy8gcGhhc2UgZXZlbnQgbGlzdGVuZXJzLlxuXG5cbmZ1bmN0aW9uIGFjY3VtdWxhdGVFbnRlckxlYXZlVHdvUGhhc2VMaXN0ZW5lcnMoZGlzcGF0Y2hRdWV1ZSwgbGVhdmVFdmVudCwgZW50ZXJFdmVudCwgZnJvbSwgdG8pIHtcbiAgdmFyIGNvbW1vbiA9IGZyb20gJiYgdG8gPyBnZXRMb3dlc3RDb21tb25BbmNlc3Rvcihmcm9tLCB0bykgOiBudWxsO1xuXG4gIGlmIChmcm9tICE9PSBudWxsKSB7XG4gICAgYWNjdW11bGF0ZUVudGVyTGVhdmVMaXN0ZW5lcnNGb3JFdmVudChkaXNwYXRjaFF1ZXVlLCBsZWF2ZUV2ZW50LCBmcm9tLCBjb21tb24sIGZhbHNlKTtcbiAgfVxuXG4gIGlmICh0byAhPT0gbnVsbCAmJiBlbnRlckV2ZW50ICE9PSBudWxsKSB7XG4gICAgYWNjdW11bGF0ZUVudGVyTGVhdmVMaXN0ZW5lcnNGb3JFdmVudChkaXNwYXRjaFF1ZXVlLCBlbnRlckV2ZW50LCB0bywgY29tbW9uLCB0cnVlKTtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0TGlzdGVuZXJTZXRLZXkoZG9tRXZlbnROYW1lLCBjYXB0dXJlKSB7XG4gIHJldHVybiBkb21FdmVudE5hbWUgKyBcIl9fXCIgKyAoY2FwdHVyZSA/ICdjYXB0dXJlJyA6ICdidWJibGUnKTtcbn1cblxudmFyIGRpZFdhcm5JbnZhbGlkSHlkcmF0aW9uID0gZmFsc2U7XG52YXIgREFOR0VST1VTTFlfU0VUX0lOTkVSX0hUTUwgPSAnZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwnO1xudmFyIFNVUFBSRVNTX0NPTlRFTlRfRURJVEFCTEVfV0FSTklORyA9ICdzdXBwcmVzc0NvbnRlbnRFZGl0YWJsZVdhcm5pbmcnO1xudmFyIFNVUFBSRVNTX0hZRFJBVElPTl9XQVJOSU5HID0gJ3N1cHByZXNzSHlkcmF0aW9uV2FybmluZyc7XG52YXIgQVVUT0ZPQ1VTID0gJ2F1dG9Gb2N1cyc7XG52YXIgQ0hJTERSRU4gPSAnY2hpbGRyZW4nO1xudmFyIFNUWUxFID0gJ3N0eWxlJztcbnZhciBIVE1MJDEgPSAnX19odG1sJztcbnZhciBIVE1MX05BTUVTUEFDRSQxID0gTmFtZXNwYWNlcy5odG1sO1xudmFyIHdhcm5lZFVua25vd25UYWdzO1xudmFyIHN1cHByZXNzSHlkcmF0aW9uV2FybmluZztcbnZhciB2YWxpZGF0ZVByb3BlcnRpZXNJbkRldmVsb3BtZW50O1xudmFyIHdhcm5Gb3JUZXh0RGlmZmVyZW5jZTtcbnZhciB3YXJuRm9yUHJvcERpZmZlcmVuY2U7XG52YXIgd2FybkZvckV4dHJhQXR0cmlidXRlcztcbnZhciB3YXJuRm9ySW52YWxpZEV2ZW50TGlzdGVuZXI7XG52YXIgY2FuRGlmZlN0eWxlRm9ySHlkcmF0aW9uV2FybmluZztcbnZhciBub3JtYWxpemVNYXJrdXBGb3JUZXh0T3JBdHRyaWJ1dGU7XG52YXIgbm9ybWFsaXplSFRNTDtcblxue1xuICB3YXJuZWRVbmtub3duVGFncyA9IHtcbiAgICAvLyBUaGVyZSBhcmUgd29ya2luZyBwb2x5ZmlsbHMgZm9yIDxkaWFsb2c+LiBMZXQgcGVvcGxlIHVzZSBpdC5cbiAgICBkaWFsb2c6IHRydWUsXG4gICAgLy8gRWxlY3Ryb24gc2hpcHMgYSBjdXN0b20gPHdlYnZpZXc+IHRhZyB0byBkaXNwbGF5IGV4dGVybmFsIHdlYiBjb250ZW50IGluXG4gICAgLy8gYW4gaXNvbGF0ZWQgZnJhbWUgYW5kIHByb2Nlc3MuXG4gICAgLy8gVGhpcyB0YWcgaXMgbm90IHByZXNlbnQgaW4gbm9uIEVsZWN0cm9uIGVudmlyb25tZW50cyBzdWNoIGFzIEpTRG9tIHdoaWNoXG4gICAgLy8gaXMgb2Z0ZW4gdXNlZCBmb3IgdGVzdGluZyBwdXJwb3Nlcy5cbiAgICAvLyBAc2VlIGh0dHBzOi8vZWxlY3Ryb25qcy5vcmcvZG9jcy9hcGkvd2Vidmlldy10YWdcbiAgICB3ZWJ2aWV3OiB0cnVlXG4gIH07XG5cbiAgdmFsaWRhdGVQcm9wZXJ0aWVzSW5EZXZlbG9wbWVudCA9IGZ1bmN0aW9uICh0eXBlLCBwcm9wcykge1xuICAgIHZhbGlkYXRlUHJvcGVydGllcyh0eXBlLCBwcm9wcyk7XG4gICAgdmFsaWRhdGVQcm9wZXJ0aWVzJDEodHlwZSwgcHJvcHMpO1xuICAgIHZhbGlkYXRlUHJvcGVydGllcyQyKHR5cGUsIHByb3BzLCB7XG4gICAgICByZWdpc3RyYXRpb25OYW1lRGVwZW5kZW5jaWVzOiByZWdpc3RyYXRpb25OYW1lRGVwZW5kZW5jaWVzLFxuICAgICAgcG9zc2libGVSZWdpc3RyYXRpb25OYW1lczogcG9zc2libGVSZWdpc3RyYXRpb25OYW1lc1xuICAgIH0pO1xuICB9OyAvLyBJRSAxMSBwYXJzZXMgJiBub3JtYWxpemVzIHRoZSBzdHlsZSBhdHRyaWJ1dGUgYXMgb3Bwb3NlZCB0byBvdGhlclxuICAvLyBicm93c2Vycy4gSXQgYWRkcyBzcGFjZXMgYW5kIHNvcnRzIHRoZSBwcm9wZXJ0aWVzIGluIHNvbWVcbiAgLy8gbm9uLWFscGhhYmV0aWNhbCBvcmRlci4gSGFuZGxpbmcgdGhhdCB3b3VsZCByZXF1aXJlIHNvcnRpbmcgQ1NTXG4gIC8vIHByb3BlcnRpZXMgaW4gdGhlIGNsaWVudCAmIHNlcnZlciB2ZXJzaW9ucyBvciBhcHBseWluZ1xuICAvLyBgZXhwZWN0ZWRTdHlsZWAgdG8gYSB0ZW1wb3JhcnkgRE9NIG5vZGUgdG8gcmVhZCBpdHMgYHN0eWxlYCBhdHRyaWJ1dGVcbiAgLy8gbm9ybWFsaXplZC4gU2luY2UgaXQgb25seSBhZmZlY3RzIElFLCB3ZSdyZSBza2lwcGluZyBzdHlsZSB3YXJuaW5nc1xuICAvLyBpbiB0aGF0IGJyb3dzZXIgY29tcGxldGVseSBpbiBmYXZvciBvZiBkb2luZyBhbGwgdGhhdCB3b3JrLlxuICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xMTgwN1xuXG5cbiAgY2FuRGlmZlN0eWxlRm9ySHlkcmF0aW9uV2FybmluZyA9IGNhblVzZURPTSAmJiAhZG9jdW1lbnQuZG9jdW1lbnRNb2RlOyAvLyBIVE1MIHBhcnNpbmcgbm9ybWFsaXplcyBDUiBhbmQgQ1JMRiB0byBMRi5cbiAgLy8gSXQgYWxzbyBjYW4gdHVybiBcXHUwMDAwIGludG8gXFx1RkZGRCBpbnNpZGUgYXR0cmlidXRlcy5cbiAgLy8gaHR0cHM6Ly93d3cudzMub3JnL1RSL2h0bWw1L3NpbmdsZS1wYWdlLmh0bWwjcHJlcHJvY2Vzc2luZy10aGUtaW5wdXQtc3RyZWFtXG4gIC8vIElmIHdlIGhhdmUgYSBtaXNtYXRjaCwgaXQgbWlnaHQgYmUgY2F1c2VkIGJ5IHRoYXQuXG4gIC8vIFdlIHdpbGwgc3RpbGwgcGF0Y2ggdXAgaW4gdGhpcyBjYXNlIGJ1dCBub3QgZmlyZSB0aGUgd2FybmluZy5cblxuICB2YXIgTk9STUFMSVpFX05FV0xJTkVTX1JFR0VYID0gL1xcclxcbj8vZztcbiAgdmFyIE5PUk1BTElaRV9OVUxMX0FORF9SRVBMQUNFTUVOVF9SRUdFWCA9IC9cXHUwMDAwfFxcdUZGRkQvZztcblxuICBub3JtYWxpemVNYXJrdXBGb3JUZXh0T3JBdHRyaWJ1dGUgPSBmdW5jdGlvbiAobWFya3VwKSB7XG4gICAgdmFyIG1hcmt1cFN0cmluZyA9IHR5cGVvZiBtYXJrdXAgPT09ICdzdHJpbmcnID8gbWFya3VwIDogJycgKyBtYXJrdXA7XG4gICAgcmV0dXJuIG1hcmt1cFN0cmluZy5yZXBsYWNlKE5PUk1BTElaRV9ORVdMSU5FU19SRUdFWCwgJ1xcbicpLnJlcGxhY2UoTk9STUFMSVpFX05VTExfQU5EX1JFUExBQ0VNRU5UX1JFR0VYLCAnJyk7XG4gIH07XG5cbiAgd2FybkZvclRleHREaWZmZXJlbmNlID0gZnVuY3Rpb24gKHNlcnZlclRleHQsIGNsaWVudFRleHQpIHtcbiAgICBpZiAoZGlkV2FybkludmFsaWRIeWRyYXRpb24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgbm9ybWFsaXplZENsaWVudFRleHQgPSBub3JtYWxpemVNYXJrdXBGb3JUZXh0T3JBdHRyaWJ1dGUoY2xpZW50VGV4dCk7XG4gICAgdmFyIG5vcm1hbGl6ZWRTZXJ2ZXJUZXh0ID0gbm9ybWFsaXplTWFya3VwRm9yVGV4dE9yQXR0cmlidXRlKHNlcnZlclRleHQpO1xuXG4gICAgaWYgKG5vcm1hbGl6ZWRTZXJ2ZXJUZXh0ID09PSBub3JtYWxpemVkQ2xpZW50VGV4dCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGRpZFdhcm5JbnZhbGlkSHlkcmF0aW9uID0gdHJ1ZTtcblxuICAgIGVycm9yKCdUZXh0IGNvbnRlbnQgZGlkIG5vdCBtYXRjaC4gU2VydmVyOiBcIiVzXCIgQ2xpZW50OiBcIiVzXCInLCBub3JtYWxpemVkU2VydmVyVGV4dCwgbm9ybWFsaXplZENsaWVudFRleHQpO1xuICB9O1xuXG4gIHdhcm5Gb3JQcm9wRGlmZmVyZW5jZSA9IGZ1bmN0aW9uIChwcm9wTmFtZSwgc2VydmVyVmFsdWUsIGNsaWVudFZhbHVlKSB7XG4gICAgaWYgKGRpZFdhcm5JbnZhbGlkSHlkcmF0aW9uKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIG5vcm1hbGl6ZWRDbGllbnRWYWx1ZSA9IG5vcm1hbGl6ZU1hcmt1cEZvclRleHRPckF0dHJpYnV0ZShjbGllbnRWYWx1ZSk7XG4gICAgdmFyIG5vcm1hbGl6ZWRTZXJ2ZXJWYWx1ZSA9IG5vcm1hbGl6ZU1hcmt1cEZvclRleHRPckF0dHJpYnV0ZShzZXJ2ZXJWYWx1ZSk7XG5cbiAgICBpZiAobm9ybWFsaXplZFNlcnZlclZhbHVlID09PSBub3JtYWxpemVkQ2xpZW50VmFsdWUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBkaWRXYXJuSW52YWxpZEh5ZHJhdGlvbiA9IHRydWU7XG5cbiAgICBlcnJvcignUHJvcCBgJXNgIGRpZCBub3QgbWF0Y2guIFNlcnZlcjogJXMgQ2xpZW50OiAlcycsIHByb3BOYW1lLCBKU09OLnN0cmluZ2lmeShub3JtYWxpemVkU2VydmVyVmFsdWUpLCBKU09OLnN0cmluZ2lmeShub3JtYWxpemVkQ2xpZW50VmFsdWUpKTtcbiAgfTtcblxuICB3YXJuRm9yRXh0cmFBdHRyaWJ1dGVzID0gZnVuY3Rpb24gKGF0dHJpYnV0ZU5hbWVzKSB7XG4gICAgaWYgKGRpZFdhcm5JbnZhbGlkSHlkcmF0aW9uKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZGlkV2FybkludmFsaWRIeWRyYXRpb24gPSB0cnVlO1xuICAgIHZhciBuYW1lcyA9IFtdO1xuICAgIGF0dHJpYnV0ZU5hbWVzLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgIG5hbWVzLnB1c2gobmFtZSk7XG4gICAgfSk7XG5cbiAgICBlcnJvcignRXh0cmEgYXR0cmlidXRlcyBmcm9tIHRoZSBzZXJ2ZXI6ICVzJywgbmFtZXMpO1xuICB9O1xuXG4gIHdhcm5Gb3JJbnZhbGlkRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uIChyZWdpc3RyYXRpb25OYW1lLCBsaXN0ZW5lcikge1xuICAgIGlmIChsaXN0ZW5lciA9PT0gZmFsc2UpIHtcbiAgICAgIGVycm9yKCdFeHBlY3RlZCBgJXNgIGxpc3RlbmVyIHRvIGJlIGEgZnVuY3Rpb24sIGluc3RlYWQgZ290IGBmYWxzZWAuXFxuXFxuJyArICdJZiB5b3UgdXNlZCB0byBjb25kaXRpb25hbGx5IG9taXQgaXQgd2l0aCAlcz17Y29uZGl0aW9uICYmIHZhbHVlfSwgJyArICdwYXNzICVzPXtjb25kaXRpb24gPyB2YWx1ZSA6IHVuZGVmaW5lZH0gaW5zdGVhZC4nLCByZWdpc3RyYXRpb25OYW1lLCByZWdpc3RyYXRpb25OYW1lLCByZWdpc3RyYXRpb25OYW1lKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZXJyb3IoJ0V4cGVjdGVkIGAlc2AgbGlzdGVuZXIgdG8gYmUgYSBmdW5jdGlvbiwgaW5zdGVhZCBnb3QgYSB2YWx1ZSBvZiBgJXNgIHR5cGUuJywgcmVnaXN0cmF0aW9uTmFtZSwgdHlwZW9mIGxpc3RlbmVyKTtcbiAgICB9XG4gIH07IC8vIFBhcnNlIHRoZSBIVE1MIGFuZCByZWFkIGl0IGJhY2sgdG8gbm9ybWFsaXplIHRoZSBIVE1MIHN0cmluZyBzbyB0aGF0IGl0XG4gIC8vIGNhbiBiZSB1c2VkIGZvciBjb21wYXJpc29uLlxuXG5cbiAgbm9ybWFsaXplSFRNTCA9IGZ1bmN0aW9uIChwYXJlbnQsIGh0bWwpIHtcbiAgICAvLyBXZSBjb3VsZCBoYXZlIGNyZWF0ZWQgYSBzZXBhcmF0ZSBkb2N1bWVudCBoZXJlIHRvIGF2b2lkXG4gICAgLy8gcmUtaW5pdGlhbGl6aW5nIGN1c3RvbSBlbGVtZW50cyBpZiB0aGV5IGV4aXN0LiBCdXQgdGhpcyBicmVha3NcbiAgICAvLyBob3cgPG5vc2NyaXB0PiBpcyBiZWluZyBoYW5kbGVkLiBTbyB3ZSB1c2UgdGhlIHNhbWUgZG9jdW1lbnQuXG4gICAgLy8gU2VlIHRoZSBkaXNjdXNzaW9uIGluIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9wdWxsLzExMTU3LlxuICAgIHZhciB0ZXN0RWxlbWVudCA9IHBhcmVudC5uYW1lc3BhY2VVUkkgPT09IEhUTUxfTkFNRVNQQUNFJDEgPyBwYXJlbnQub3duZXJEb2N1bWVudC5jcmVhdGVFbGVtZW50KHBhcmVudC50YWdOYW1lKSA6IHBhcmVudC5vd25lckRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhwYXJlbnQubmFtZXNwYWNlVVJJLCBwYXJlbnQudGFnTmFtZSk7XG4gICAgdGVzdEVsZW1lbnQuaW5uZXJIVE1MID0gaHRtbDtcbiAgICByZXR1cm4gdGVzdEVsZW1lbnQuaW5uZXJIVE1MO1xuICB9O1xufVxuXG5mdW5jdGlvbiBnZXRPd25lckRvY3VtZW50RnJvbVJvb3RDb250YWluZXIocm9vdENvbnRhaW5lckVsZW1lbnQpIHtcbiAgcmV0dXJuIHJvb3RDb250YWluZXJFbGVtZW50Lm5vZGVUeXBlID09PSBET0NVTUVOVF9OT0RFID8gcm9vdENvbnRhaW5lckVsZW1lbnQgOiByb290Q29udGFpbmVyRWxlbWVudC5vd25lckRvY3VtZW50O1xufVxuXG5mdW5jdGlvbiBub29wKCkge31cblxuZnVuY3Rpb24gdHJhcENsaWNrT25Ob25JbnRlcmFjdGl2ZUVsZW1lbnQobm9kZSkge1xuICAvLyBNb2JpbGUgU2FmYXJpIGRvZXMgbm90IGZpcmUgcHJvcGVybHkgYnViYmxlIGNsaWNrIGV2ZW50cyBvblxuICAvLyBub24taW50ZXJhY3RpdmUgZWxlbWVudHMsIHdoaWNoIG1lYW5zIGRlbGVnYXRlZCBjbGljayBsaXN0ZW5lcnMgZG8gbm90XG4gIC8vIGZpcmUuIFRoZSB3b3JrYXJvdW5kIGZvciB0aGlzIGJ1ZyBpbnZvbHZlcyBhdHRhY2hpbmcgYW4gZW1wdHkgY2xpY2tcbiAgLy8gbGlzdGVuZXIgb24gdGhlIHRhcmdldCBub2RlLlxuICAvLyBodHRwczovL3d3dy5xdWlya3Ntb2RlLm9yZy9ibG9nL2FyY2hpdmVzLzIwMTAvMDkvY2xpY2tfZXZlbnRfZGVsLmh0bWxcbiAgLy8gSnVzdCBzZXQgaXQgdXNpbmcgdGhlIG9uY2xpY2sgcHJvcGVydHkgc28gdGhhdCB3ZSBkb24ndCBoYXZlIHRvIG1hbmFnZSBhbnlcbiAgLy8gYm9va2tlZXBpbmcgZm9yIGl0LiBOb3Qgc3VyZSBpZiB3ZSBuZWVkIHRvIGNsZWFyIGl0IHdoZW4gdGhlIGxpc3RlbmVyIGlzXG4gIC8vIHJlbW92ZWQuXG4gIC8vIFRPRE86IE9ubHkgZG8gdGhpcyBmb3IgdGhlIHJlbGV2YW50IFNhZmFyaXMgbWF5YmU/XG4gIG5vZGUub25jbGljayA9IG5vb3A7XG59XG5cbmZ1bmN0aW9uIHNldEluaXRpYWxET01Qcm9wZXJ0aWVzKHRhZywgZG9tRWxlbWVudCwgcm9vdENvbnRhaW5lckVsZW1lbnQsIG5leHRQcm9wcywgaXNDdXN0b21Db21wb25lbnRUYWcpIHtcbiAgZm9yICh2YXIgcHJvcEtleSBpbiBuZXh0UHJvcHMpIHtcbiAgICBpZiAoIW5leHRQcm9wcy5oYXNPd25Qcm9wZXJ0eShwcm9wS2V5KSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgdmFyIG5leHRQcm9wID0gbmV4dFByb3BzW3Byb3BLZXldO1xuXG4gICAgaWYgKHByb3BLZXkgPT09IFNUWUxFKSB7XG4gICAgICB7XG4gICAgICAgIGlmIChuZXh0UHJvcCkge1xuICAgICAgICAgIC8vIEZyZWV6ZSB0aGUgbmV4dCBzdHlsZSBvYmplY3Qgc28gdGhhdCB3ZSBjYW4gYXNzdW1lIGl0IHdvbid0IGJlXG4gICAgICAgICAgLy8gbXV0YXRlZC4gV2UgaGF2ZSBhbHJlYWR5IHdhcm5lZCBmb3IgdGhpcyBpbiB0aGUgcGFzdC5cbiAgICAgICAgICBPYmplY3QuZnJlZXplKG5leHRQcm9wKTtcbiAgICAgICAgfVxuICAgICAgfSAvLyBSZWxpZXMgb24gYHVwZGF0ZVN0eWxlc0J5SURgIG5vdCBtdXRhdGluZyBgc3R5bGVVcGRhdGVzYC5cblxuXG4gICAgICBzZXRWYWx1ZUZvclN0eWxlcyhkb21FbGVtZW50LCBuZXh0UHJvcCk7XG4gICAgfSBlbHNlIGlmIChwcm9wS2V5ID09PSBEQU5HRVJPVVNMWV9TRVRfSU5ORVJfSFRNTCkge1xuICAgICAgdmFyIG5leHRIdG1sID0gbmV4dFByb3AgPyBuZXh0UHJvcFtIVE1MJDFdIDogdW5kZWZpbmVkO1xuXG4gICAgICBpZiAobmV4dEh0bWwgIT0gbnVsbCkge1xuICAgICAgICBzZXRJbm5lckhUTUwoZG9tRWxlbWVudCwgbmV4dEh0bWwpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocHJvcEtleSA9PT0gQ0hJTERSRU4pIHtcbiAgICAgIGlmICh0eXBlb2YgbmV4dFByb3AgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIC8vIEF2b2lkIHNldHRpbmcgaW5pdGlhbCB0ZXh0Q29udGVudCB3aGVuIHRoZSB0ZXh0IGlzIGVtcHR5LiBJbiBJRTExIHNldHRpbmdcbiAgICAgICAgLy8gdGV4dENvbnRlbnQgb24gYSA8dGV4dGFyZWE+IHdpbGwgY2F1c2UgdGhlIHBsYWNlaG9sZGVyIHRvIG5vdFxuICAgICAgICAvLyBzaG93IHdpdGhpbiB0aGUgPHRleHRhcmVhPiB1bnRpbCBpdCBoYXMgYmVlbiBmb2N1c2VkIGFuZCBibHVycmVkIGFnYWluLlxuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzY3MzEjaXNzdWVjb21tZW50LTI1NDg3NDU1M1xuICAgICAgICB2YXIgY2FuU2V0VGV4dENvbnRlbnQgPSB0YWcgIT09ICd0ZXh0YXJlYScgfHwgbmV4dFByb3AgIT09ICcnO1xuXG4gICAgICAgIGlmIChjYW5TZXRUZXh0Q29udGVudCkge1xuICAgICAgICAgIHNldFRleHRDb250ZW50KGRvbUVsZW1lbnQsIG5leHRQcm9wKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgbmV4dFByb3AgPT09ICdudW1iZXInKSB7XG4gICAgICAgIHNldFRleHRDb250ZW50KGRvbUVsZW1lbnQsICcnICsgbmV4dFByb3ApO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocHJvcEtleSA9PT0gU1VQUFJFU1NfQ09OVEVOVF9FRElUQUJMRV9XQVJOSU5HIHx8IHByb3BLZXkgPT09IFNVUFBSRVNTX0hZRFJBVElPTl9XQVJOSU5HKSA7IGVsc2UgaWYgKHByb3BLZXkgPT09IEFVVE9GT0NVUykgOyBlbHNlIGlmIChyZWdpc3RyYXRpb25OYW1lRGVwZW5kZW5jaWVzLmhhc093blByb3BlcnR5KHByb3BLZXkpKSB7XG4gICAgICBpZiAobmV4dFByb3AgIT0gbnVsbCkge1xuICAgICAgICBpZiAoIHR5cGVvZiBuZXh0UHJvcCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHdhcm5Gb3JJbnZhbGlkRXZlbnRMaXN0ZW5lcihwcm9wS2V5LCBuZXh0UHJvcCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocHJvcEtleSA9PT0gJ29uU2Nyb2xsJykge1xuICAgICAgICAgIGxpc3RlblRvTm9uRGVsZWdhdGVkRXZlbnQoJ3Njcm9sbCcsIGRvbUVsZW1lbnQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChuZXh0UHJvcCAhPSBudWxsKSB7XG4gICAgICBzZXRWYWx1ZUZvclByb3BlcnR5KGRvbUVsZW1lbnQsIHByb3BLZXksIG5leHRQcm9wLCBpc0N1c3RvbUNvbXBvbmVudFRhZyk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZURPTVByb3BlcnRpZXMoZG9tRWxlbWVudCwgdXBkYXRlUGF5bG9hZCwgd2FzQ3VzdG9tQ29tcG9uZW50VGFnLCBpc0N1c3RvbUNvbXBvbmVudFRhZykge1xuICAvLyBUT0RPOiBIYW5kbGUgd2FzQ3VzdG9tQ29tcG9uZW50VGFnXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdXBkYXRlUGF5bG9hZC5sZW5ndGg7IGkgKz0gMikge1xuICAgIHZhciBwcm9wS2V5ID0gdXBkYXRlUGF5bG9hZFtpXTtcbiAgICB2YXIgcHJvcFZhbHVlID0gdXBkYXRlUGF5bG9hZFtpICsgMV07XG5cbiAgICBpZiAocHJvcEtleSA9PT0gU1RZTEUpIHtcbiAgICAgIHNldFZhbHVlRm9yU3R5bGVzKGRvbUVsZW1lbnQsIHByb3BWYWx1ZSk7XG4gICAgfSBlbHNlIGlmIChwcm9wS2V5ID09PSBEQU5HRVJPVVNMWV9TRVRfSU5ORVJfSFRNTCkge1xuICAgICAgc2V0SW5uZXJIVE1MKGRvbUVsZW1lbnQsIHByb3BWYWx1ZSk7XG4gICAgfSBlbHNlIGlmIChwcm9wS2V5ID09PSBDSElMRFJFTikge1xuICAgICAgc2V0VGV4dENvbnRlbnQoZG9tRWxlbWVudCwgcHJvcFZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2V0VmFsdWVGb3JQcm9wZXJ0eShkb21FbGVtZW50LCBwcm9wS2V5LCBwcm9wVmFsdWUsIGlzQ3VzdG9tQ29tcG9uZW50VGFnKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlRWxlbWVudCh0eXBlLCBwcm9wcywgcm9vdENvbnRhaW5lckVsZW1lbnQsIHBhcmVudE5hbWVzcGFjZSkge1xuICB2YXIgaXNDdXN0b21Db21wb25lbnRUYWc7IC8vIFdlIGNyZWF0ZSB0YWdzIGluIHRoZSBuYW1lc3BhY2Ugb2YgdGhlaXIgcGFyZW50IGNvbnRhaW5lciwgZXhjZXB0IEhUTUxcbiAgLy8gdGFncyBnZXQgbm8gbmFtZXNwYWNlLlxuXG4gIHZhciBvd25lckRvY3VtZW50ID0gZ2V0T3duZXJEb2N1bWVudEZyb21Sb290Q29udGFpbmVyKHJvb3RDb250YWluZXJFbGVtZW50KTtcbiAgdmFyIGRvbUVsZW1lbnQ7XG4gIHZhciBuYW1lc3BhY2VVUkkgPSBwYXJlbnROYW1lc3BhY2U7XG5cbiAgaWYgKG5hbWVzcGFjZVVSSSA9PT0gSFRNTF9OQU1FU1BBQ0UkMSkge1xuICAgIG5hbWVzcGFjZVVSSSA9IGdldEludHJpbnNpY05hbWVzcGFjZSh0eXBlKTtcbiAgfVxuXG4gIGlmIChuYW1lc3BhY2VVUkkgPT09IEhUTUxfTkFNRVNQQUNFJDEpIHtcbiAgICB7XG4gICAgICBpc0N1c3RvbUNvbXBvbmVudFRhZyA9IGlzQ3VzdG9tQ29tcG9uZW50KHR5cGUsIHByb3BzKTsgLy8gU2hvdWxkIHRoaXMgY2hlY2sgYmUgZ2F0ZWQgYnkgcGFyZW50IG5hbWVzcGFjZT8gTm90IHN1cmUgd2Ugd2FudCB0b1xuICAgICAgLy8gYWxsb3cgPFNWRz4gb3IgPG1BVEg+LlxuXG4gICAgICBpZiAoIWlzQ3VzdG9tQ29tcG9uZW50VGFnICYmIHR5cGUgIT09IHR5cGUudG9Mb3dlckNhc2UoKSkge1xuICAgICAgICBlcnJvcignPCVzIC8+IGlzIHVzaW5nIGluY29ycmVjdCBjYXNpbmcuICcgKyAnVXNlIFBhc2NhbENhc2UgZm9yIFJlYWN0IGNvbXBvbmVudHMsICcgKyAnb3IgbG93ZXJjYXNlIGZvciBIVE1MIGVsZW1lbnRzLicsIHR5cGUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0eXBlID09PSAnc2NyaXB0Jykge1xuICAgICAgLy8gQ3JlYXRlIHRoZSBzY3JpcHQgdmlhIC5pbm5lckhUTUwgc28gaXRzIFwicGFyc2VyLWluc2VydGVkXCIgZmxhZyBpc1xuICAgICAgLy8gc2V0IHRvIHRydWUgYW5kIGl0IGRvZXMgbm90IGV4ZWN1dGVcbiAgICAgIHZhciBkaXYgPSBvd25lckRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuXG4gICAgICBkaXYuaW5uZXJIVE1MID0gJzxzY3JpcHQ+PCcgKyAnL3NjcmlwdD4nOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgICAvLyBUaGlzIGlzIGd1YXJhbnRlZWQgdG8geWllbGQgYSBzY3JpcHQgZWxlbWVudC5cblxuICAgICAgdmFyIGZpcnN0Q2hpbGQgPSBkaXYuZmlyc3RDaGlsZDtcbiAgICAgIGRvbUVsZW1lbnQgPSBkaXYucmVtb3ZlQ2hpbGQoZmlyc3RDaGlsZCk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgcHJvcHMuaXMgPT09ICdzdHJpbmcnKSB7XG4gICAgICAvLyAkRmxvd0lzc3VlIGBjcmVhdGVFbGVtZW50YCBzaG91bGQgYmUgdXBkYXRlZCBmb3IgV2ViIENvbXBvbmVudHNcbiAgICAgIGRvbUVsZW1lbnQgPSBvd25lckRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodHlwZSwge1xuICAgICAgICBpczogcHJvcHMuaXNcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBTZXBhcmF0ZSBlbHNlIGJyYW5jaCBpbnN0ZWFkIG9mIHVzaW5nIGBwcm9wcy5pcyB8fCB1bmRlZmluZWRgIGFib3ZlIGJlY2F1c2Ugb2YgYSBGaXJlZm94IGJ1Zy5cbiAgICAgIC8vIFNlZSBkaXNjdXNzaW9uIGluIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9wdWxsLzY4OTZcbiAgICAgIC8vIGFuZCBkaXNjdXNzaW9uIGluIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTEyNzYyNDBcbiAgICAgIGRvbUVsZW1lbnQgPSBvd25lckRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodHlwZSk7IC8vIE5vcm1hbGx5IGF0dHJpYnV0ZXMgYXJlIGFzc2lnbmVkIGluIGBzZXRJbml0aWFsRE9NUHJvcGVydGllc2AsIGhvd2V2ZXIgdGhlIGBtdWx0aXBsZWAgYW5kIGBzaXplYFxuICAgICAgLy8gYXR0cmlidXRlcyBvbiBgc2VsZWN0YHMgbmVlZHMgdG8gYmUgYWRkZWQgYmVmb3JlIGBvcHRpb25gcyBhcmUgaW5zZXJ0ZWQuXG4gICAgICAvLyBUaGlzIHByZXZlbnRzOlxuICAgICAgLy8gLSBhIGJ1ZyB3aGVyZSB0aGUgYHNlbGVjdGAgZG9lcyBub3Qgc2Nyb2xsIHRvIHRoZSBjb3JyZWN0IG9wdGlvbiBiZWNhdXNlIHNpbmd1bGFyXG4gICAgICAvLyAgYHNlbGVjdGAgZWxlbWVudHMgYXV0b21hdGljYWxseSBwaWNrIHRoZSBmaXJzdCBpdGVtICMxMzIyMlxuICAgICAgLy8gLSBhIGJ1ZyB3aGVyZSB0aGUgYHNlbGVjdGAgc2V0IHRoZSBmaXJzdCBpdGVtIGFzIHNlbGVjdGVkIGRlc3BpdGUgdGhlIGBzaXplYCBhdHRyaWJ1dGUgIzE0MjM5XG4gICAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xMzIyMlxuICAgICAgLy8gYW5kIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTQyMzlcblxuICAgICAgaWYgKHR5cGUgPT09ICdzZWxlY3QnKSB7XG4gICAgICAgIHZhciBub2RlID0gZG9tRWxlbWVudDtcblxuICAgICAgICBpZiAocHJvcHMubXVsdGlwbGUpIHtcbiAgICAgICAgICBub2RlLm11bHRpcGxlID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIGlmIChwcm9wcy5zaXplKSB7XG4gICAgICAgICAgLy8gU2V0dGluZyBhIHNpemUgZ3JlYXRlciB0aGFuIDEgY2F1c2VzIGEgc2VsZWN0IHRvIGJlaGF2ZSBsaWtlIGBtdWx0aXBsZT10cnVlYCwgd2hlcmVcbiAgICAgICAgICAvLyBpdCBpcyBwb3NzaWJsZSB0aGF0IG5vIG9wdGlvbiBpcyBzZWxlY3RlZC5cbiAgICAgICAgICAvL1xuICAgICAgICAgIC8vIFRoaXMgaXMgb25seSBuZWNlc3Nhcnkgd2hlbiBhIHNlbGVjdCBpbiBcInNpbmdsZSBzZWxlY3Rpb24gbW9kZVwiLlxuICAgICAgICAgIG5vZGUuc2l6ZSA9IHByb3BzLnNpemU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgZG9tRWxlbWVudCA9IG93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKG5hbWVzcGFjZVVSSSwgdHlwZSk7XG4gIH1cblxuICB7XG4gICAgaWYgKG5hbWVzcGFjZVVSSSA9PT0gSFRNTF9OQU1FU1BBQ0UkMSkge1xuICAgICAgaWYgKCFpc0N1c3RvbUNvbXBvbmVudFRhZyAmJiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoZG9tRWxlbWVudCkgPT09ICdbb2JqZWN0IEhUTUxVbmtub3duRWxlbWVudF0nICYmICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwod2FybmVkVW5rbm93blRhZ3MsIHR5cGUpKSB7XG4gICAgICAgIHdhcm5lZFVua25vd25UYWdzW3R5cGVdID0gdHJ1ZTtcblxuICAgICAgICBlcnJvcignVGhlIHRhZyA8JXM+IGlzIHVucmVjb2duaXplZCBpbiB0aGlzIGJyb3dzZXIuICcgKyAnSWYgeW91IG1lYW50IHRvIHJlbmRlciBhIFJlYWN0IGNvbXBvbmVudCwgc3RhcnQgaXRzIG5hbWUgd2l0aCAnICsgJ2FuIHVwcGVyY2FzZSBsZXR0ZXIuJywgdHlwZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGRvbUVsZW1lbnQ7XG59XG5mdW5jdGlvbiBjcmVhdGVUZXh0Tm9kZSh0ZXh0LCByb290Q29udGFpbmVyRWxlbWVudCkge1xuICByZXR1cm4gZ2V0T3duZXJEb2N1bWVudEZyb21Sb290Q29udGFpbmVyKHJvb3RDb250YWluZXJFbGVtZW50KS5jcmVhdGVUZXh0Tm9kZSh0ZXh0KTtcbn1cbmZ1bmN0aW9uIHNldEluaXRpYWxQcm9wZXJ0aWVzKGRvbUVsZW1lbnQsIHRhZywgcmF3UHJvcHMsIHJvb3RDb250YWluZXJFbGVtZW50KSB7XG4gIHZhciBpc0N1c3RvbUNvbXBvbmVudFRhZyA9IGlzQ3VzdG9tQ29tcG9uZW50KHRhZywgcmF3UHJvcHMpO1xuXG4gIHtcbiAgICB2YWxpZGF0ZVByb3BlcnRpZXNJbkRldmVsb3BtZW50KHRhZywgcmF3UHJvcHMpO1xuICB9IC8vIFRPRE86IE1ha2Ugc3VyZSB0aGF0IHdlIGNoZWNrIGlzTW91bnRlZCBiZWZvcmUgZmlyaW5nIGFueSBvZiB0aGVzZSBldmVudHMuXG5cblxuICB2YXIgcHJvcHM7XG5cbiAgc3dpdGNoICh0YWcpIHtcbiAgICBjYXNlICdkaWFsb2cnOlxuICAgICAgbGlzdGVuVG9Ob25EZWxlZ2F0ZWRFdmVudCgnY2FuY2VsJywgZG9tRWxlbWVudCk7XG4gICAgICBsaXN0ZW5Ub05vbkRlbGVnYXRlZEV2ZW50KCdjbG9zZScsIGRvbUVsZW1lbnQpO1xuICAgICAgcHJvcHMgPSByYXdQcm9wcztcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnaWZyYW1lJzpcbiAgICBjYXNlICdvYmplY3QnOlxuICAgIGNhc2UgJ2VtYmVkJzpcbiAgICAgIC8vIFdlIGxpc3RlbiB0byB0aGlzIGV2ZW50IGluIGNhc2UgdG8gZW5zdXJlIGVtdWxhdGVkIGJ1YmJsZVxuICAgICAgLy8gbGlzdGVuZXJzIHN0aWxsIGZpcmUgZm9yIHRoZSBsb2FkIGV2ZW50LlxuICAgICAgbGlzdGVuVG9Ob25EZWxlZ2F0ZWRFdmVudCgnbG9hZCcsIGRvbUVsZW1lbnQpO1xuICAgICAgcHJvcHMgPSByYXdQcm9wcztcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAndmlkZW8nOlxuICAgIGNhc2UgJ2F1ZGlvJzpcbiAgICAgIC8vIFdlIGxpc3RlbiB0byB0aGVzZSBldmVudHMgaW4gY2FzZSB0byBlbnN1cmUgZW11bGF0ZWQgYnViYmxlXG4gICAgICAvLyBsaXN0ZW5lcnMgc3RpbGwgZmlyZSBmb3IgYWxsIHRoZSBtZWRpYSBldmVudHMuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1lZGlhRXZlbnRUeXBlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBsaXN0ZW5Ub05vbkRlbGVnYXRlZEV2ZW50KG1lZGlhRXZlbnRUeXBlc1tpXSwgZG9tRWxlbWVudCk7XG4gICAgICB9XG5cbiAgICAgIHByb3BzID0gcmF3UHJvcHM7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ3NvdXJjZSc6XG4gICAgICAvLyBXZSBsaXN0ZW4gdG8gdGhpcyBldmVudCBpbiBjYXNlIHRvIGVuc3VyZSBlbXVsYXRlZCBidWJibGVcbiAgICAgIC8vIGxpc3RlbmVycyBzdGlsbCBmaXJlIGZvciB0aGUgZXJyb3IgZXZlbnQuXG4gICAgICBsaXN0ZW5Ub05vbkRlbGVnYXRlZEV2ZW50KCdlcnJvcicsIGRvbUVsZW1lbnQpO1xuICAgICAgcHJvcHMgPSByYXdQcm9wcztcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnaW1nJzpcbiAgICBjYXNlICdpbWFnZSc6XG4gICAgY2FzZSAnbGluayc6XG4gICAgICAvLyBXZSBsaXN0ZW4gdG8gdGhlc2UgZXZlbnRzIGluIGNhc2UgdG8gZW5zdXJlIGVtdWxhdGVkIGJ1YmJsZVxuICAgICAgLy8gbGlzdGVuZXJzIHN0aWxsIGZpcmUgZm9yIGVycm9yIGFuZCBsb2FkIGV2ZW50cy5cbiAgICAgIGxpc3RlblRvTm9uRGVsZWdhdGVkRXZlbnQoJ2Vycm9yJywgZG9tRWxlbWVudCk7XG4gICAgICBsaXN0ZW5Ub05vbkRlbGVnYXRlZEV2ZW50KCdsb2FkJywgZG9tRWxlbWVudCk7XG4gICAgICBwcm9wcyA9IHJhd1Byb3BzO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdkZXRhaWxzJzpcbiAgICAgIC8vIFdlIGxpc3RlbiB0byB0aGlzIGV2ZW50IGluIGNhc2UgdG8gZW5zdXJlIGVtdWxhdGVkIGJ1YmJsZVxuICAgICAgLy8gbGlzdGVuZXJzIHN0aWxsIGZpcmUgZm9yIHRoZSB0b2dnbGUgZXZlbnQuXG4gICAgICBsaXN0ZW5Ub05vbkRlbGVnYXRlZEV2ZW50KCd0b2dnbGUnLCBkb21FbGVtZW50KTtcbiAgICAgIHByb3BzID0gcmF3UHJvcHM7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ2lucHV0JzpcbiAgICAgIGluaXRXcmFwcGVyU3RhdGUoZG9tRWxlbWVudCwgcmF3UHJvcHMpO1xuICAgICAgcHJvcHMgPSBnZXRIb3N0UHJvcHMoZG9tRWxlbWVudCwgcmF3UHJvcHMpOyAvLyBXZSBsaXN0ZW4gdG8gdGhpcyBldmVudCBpbiBjYXNlIHRvIGVuc3VyZSBlbXVsYXRlZCBidWJibGVcbiAgICAgIC8vIGxpc3RlbmVycyBzdGlsbCBmaXJlIGZvciB0aGUgaW52YWxpZCBldmVudC5cblxuICAgICAgbGlzdGVuVG9Ob25EZWxlZ2F0ZWRFdmVudCgnaW52YWxpZCcsIGRvbUVsZW1lbnQpO1xuXG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ29wdGlvbic6XG4gICAgICB2YWxpZGF0ZVByb3BzKGRvbUVsZW1lbnQsIHJhd1Byb3BzKTtcbiAgICAgIHByb3BzID0gZ2V0SG9zdFByb3BzJDEoZG9tRWxlbWVudCwgcmF3UHJvcHMpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdzZWxlY3QnOlxuICAgICAgaW5pdFdyYXBwZXJTdGF0ZSQxKGRvbUVsZW1lbnQsIHJhd1Byb3BzKTtcbiAgICAgIHByb3BzID0gZ2V0SG9zdFByb3BzJDIoZG9tRWxlbWVudCwgcmF3UHJvcHMpOyAvLyBXZSBsaXN0ZW4gdG8gdGhpcyBldmVudCBpbiBjYXNlIHRvIGVuc3VyZSBlbXVsYXRlZCBidWJibGVcbiAgICAgIC8vIGxpc3RlbmVycyBzdGlsbCBmaXJlIGZvciB0aGUgaW52YWxpZCBldmVudC5cblxuICAgICAgbGlzdGVuVG9Ob25EZWxlZ2F0ZWRFdmVudCgnaW52YWxpZCcsIGRvbUVsZW1lbnQpO1xuXG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ3RleHRhcmVhJzpcbiAgICAgIGluaXRXcmFwcGVyU3RhdGUkMihkb21FbGVtZW50LCByYXdQcm9wcyk7XG4gICAgICBwcm9wcyA9IGdldEhvc3RQcm9wcyQzKGRvbUVsZW1lbnQsIHJhd1Byb3BzKTsgLy8gV2UgbGlzdGVuIHRvIHRoaXMgZXZlbnQgaW4gY2FzZSB0byBlbnN1cmUgZW11bGF0ZWQgYnViYmxlXG4gICAgICAvLyBsaXN0ZW5lcnMgc3RpbGwgZmlyZSBmb3IgdGhlIGludmFsaWQgZXZlbnQuXG5cbiAgICAgIGxpc3RlblRvTm9uRGVsZWdhdGVkRXZlbnQoJ2ludmFsaWQnLCBkb21FbGVtZW50KTtcblxuICAgICAgYnJlYWs7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgcHJvcHMgPSByYXdQcm9wcztcbiAgfVxuXG4gIGFzc2VydFZhbGlkUHJvcHModGFnLCBwcm9wcyk7XG4gIHNldEluaXRpYWxET01Qcm9wZXJ0aWVzKHRhZywgZG9tRWxlbWVudCwgcm9vdENvbnRhaW5lckVsZW1lbnQsIHByb3BzLCBpc0N1c3RvbUNvbXBvbmVudFRhZyk7XG5cbiAgc3dpdGNoICh0YWcpIHtcbiAgICBjYXNlICdpbnB1dCc6XG4gICAgICAvLyBUT0RPOiBNYWtlIHN1cmUgd2UgY2hlY2sgaWYgdGhpcyBpcyBzdGlsbCB1bm1vdW50ZWQgb3IgZG8gYW55IGNsZWFuXG4gICAgICAvLyB1cCBuZWNlc3Nhcnkgc2luY2Ugd2UgbmV2ZXIgc3RvcCB0cmFja2luZyBhbnltb3JlLlxuICAgICAgdHJhY2soZG9tRWxlbWVudCk7XG4gICAgICBwb3N0TW91bnRXcmFwcGVyKGRvbUVsZW1lbnQsIHJhd1Byb3BzLCBmYWxzZSk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ3RleHRhcmVhJzpcbiAgICAgIC8vIFRPRE86IE1ha2Ugc3VyZSB3ZSBjaGVjayBpZiB0aGlzIGlzIHN0aWxsIHVubW91bnRlZCBvciBkbyBhbnkgY2xlYW5cbiAgICAgIC8vIHVwIG5lY2Vzc2FyeSBzaW5jZSB3ZSBuZXZlciBzdG9wIHRyYWNraW5nIGFueW1vcmUuXG4gICAgICB0cmFjayhkb21FbGVtZW50KTtcbiAgICAgIHBvc3RNb3VudFdyYXBwZXIkMyhkb21FbGVtZW50KTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnb3B0aW9uJzpcbiAgICAgIHBvc3RNb3VudFdyYXBwZXIkMShkb21FbGVtZW50LCByYXdQcm9wcyk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ3NlbGVjdCc6XG4gICAgICBwb3N0TW91bnRXcmFwcGVyJDIoZG9tRWxlbWVudCwgcmF3UHJvcHMpO1xuICAgICAgYnJlYWs7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgaWYgKHR5cGVvZiBwcm9wcy5vbkNsaWNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8vIFRPRE86IFRoaXMgY2FzdCBtYXkgbm90IGJlIHNvdW5kIGZvciBTVkcsIE1hdGhNTCBvciBjdXN0b20gZWxlbWVudHMuXG4gICAgICAgIHRyYXBDbGlja09uTm9uSW50ZXJhY3RpdmVFbGVtZW50KGRvbUVsZW1lbnQpO1xuICAgICAgfVxuXG4gICAgICBicmVhaztcbiAgfVxufSAvLyBDYWxjdWxhdGUgdGhlIGRpZmYgYmV0d2VlbiB0aGUgdHdvIG9iamVjdHMuXG5cbmZ1bmN0aW9uIGRpZmZQcm9wZXJ0aWVzKGRvbUVsZW1lbnQsIHRhZywgbGFzdFJhd1Byb3BzLCBuZXh0UmF3UHJvcHMsIHJvb3RDb250YWluZXJFbGVtZW50KSB7XG4gIHtcbiAgICB2YWxpZGF0ZVByb3BlcnRpZXNJbkRldmVsb3BtZW50KHRhZywgbmV4dFJhd1Byb3BzKTtcbiAgfVxuXG4gIHZhciB1cGRhdGVQYXlsb2FkID0gbnVsbDtcbiAgdmFyIGxhc3RQcm9wcztcbiAgdmFyIG5leHRQcm9wcztcblxuICBzd2l0Y2ggKHRhZykge1xuICAgIGNhc2UgJ2lucHV0JzpcbiAgICAgIGxhc3RQcm9wcyA9IGdldEhvc3RQcm9wcyhkb21FbGVtZW50LCBsYXN0UmF3UHJvcHMpO1xuICAgICAgbmV4dFByb3BzID0gZ2V0SG9zdFByb3BzKGRvbUVsZW1lbnQsIG5leHRSYXdQcm9wcyk7XG4gICAgICB1cGRhdGVQYXlsb2FkID0gW107XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ29wdGlvbic6XG4gICAgICBsYXN0UHJvcHMgPSBnZXRIb3N0UHJvcHMkMShkb21FbGVtZW50LCBsYXN0UmF3UHJvcHMpO1xuICAgICAgbmV4dFByb3BzID0gZ2V0SG9zdFByb3BzJDEoZG9tRWxlbWVudCwgbmV4dFJhd1Byb3BzKTtcbiAgICAgIHVwZGF0ZVBheWxvYWQgPSBbXTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnc2VsZWN0JzpcbiAgICAgIGxhc3RQcm9wcyA9IGdldEhvc3RQcm9wcyQyKGRvbUVsZW1lbnQsIGxhc3RSYXdQcm9wcyk7XG4gICAgICBuZXh0UHJvcHMgPSBnZXRIb3N0UHJvcHMkMihkb21FbGVtZW50LCBuZXh0UmF3UHJvcHMpO1xuICAgICAgdXBkYXRlUGF5bG9hZCA9IFtdO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICd0ZXh0YXJlYSc6XG4gICAgICBsYXN0UHJvcHMgPSBnZXRIb3N0UHJvcHMkMyhkb21FbGVtZW50LCBsYXN0UmF3UHJvcHMpO1xuICAgICAgbmV4dFByb3BzID0gZ2V0SG9zdFByb3BzJDMoZG9tRWxlbWVudCwgbmV4dFJhd1Byb3BzKTtcbiAgICAgIHVwZGF0ZVBheWxvYWQgPSBbXTtcbiAgICAgIGJyZWFrO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIGxhc3RQcm9wcyA9IGxhc3RSYXdQcm9wcztcbiAgICAgIG5leHRQcm9wcyA9IG5leHRSYXdQcm9wcztcblxuICAgICAgaWYgKHR5cGVvZiBsYXN0UHJvcHMub25DbGljayAhPT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgbmV4dFByb3BzLm9uQ2xpY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgLy8gVE9ETzogVGhpcyBjYXN0IG1heSBub3QgYmUgc291bmQgZm9yIFNWRywgTWF0aE1MIG9yIGN1c3RvbSBlbGVtZW50cy5cbiAgICAgICAgdHJhcENsaWNrT25Ob25JbnRlcmFjdGl2ZUVsZW1lbnQoZG9tRWxlbWVudCk7XG4gICAgICB9XG5cbiAgICAgIGJyZWFrO1xuICB9XG5cbiAgYXNzZXJ0VmFsaWRQcm9wcyh0YWcsIG5leHRQcm9wcyk7XG4gIHZhciBwcm9wS2V5O1xuICB2YXIgc3R5bGVOYW1lO1xuICB2YXIgc3R5bGVVcGRhdGVzID0gbnVsbDtcblxuICBmb3IgKHByb3BLZXkgaW4gbGFzdFByb3BzKSB7XG4gICAgaWYgKG5leHRQcm9wcy5oYXNPd25Qcm9wZXJ0eShwcm9wS2V5KSB8fCAhbGFzdFByb3BzLmhhc093blByb3BlcnR5KHByb3BLZXkpIHx8IGxhc3RQcm9wc1twcm9wS2V5XSA9PSBudWxsKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpZiAocHJvcEtleSA9PT0gU1RZTEUpIHtcbiAgICAgIHZhciBsYXN0U3R5bGUgPSBsYXN0UHJvcHNbcHJvcEtleV07XG5cbiAgICAgIGZvciAoc3R5bGVOYW1lIGluIGxhc3RTdHlsZSkge1xuICAgICAgICBpZiAobGFzdFN0eWxlLmhhc093blByb3BlcnR5KHN0eWxlTmFtZSkpIHtcbiAgICAgICAgICBpZiAoIXN0eWxlVXBkYXRlcykge1xuICAgICAgICAgICAgc3R5bGVVcGRhdGVzID0ge307XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgc3R5bGVVcGRhdGVzW3N0eWxlTmFtZV0gPSAnJztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocHJvcEtleSA9PT0gREFOR0VST1VTTFlfU0VUX0lOTkVSX0hUTUwgfHwgcHJvcEtleSA9PT0gQ0hJTERSRU4pIDsgZWxzZSBpZiAocHJvcEtleSA9PT0gU1VQUFJFU1NfQ09OVEVOVF9FRElUQUJMRV9XQVJOSU5HIHx8IHByb3BLZXkgPT09IFNVUFBSRVNTX0hZRFJBVElPTl9XQVJOSU5HKSA7IGVsc2UgaWYgKHByb3BLZXkgPT09IEFVVE9GT0NVUykgOyBlbHNlIGlmIChyZWdpc3RyYXRpb25OYW1lRGVwZW5kZW5jaWVzLmhhc093blByb3BlcnR5KHByb3BLZXkpKSB7XG4gICAgICAvLyBUaGlzIGlzIGEgc3BlY2lhbCBjYXNlLiBJZiBhbnkgbGlzdGVuZXIgdXBkYXRlcyB3ZSBuZWVkIHRvIGVuc3VyZVxuICAgICAgLy8gdGhhdCB0aGUgXCJjdXJyZW50XCIgZmliZXIgcG9pbnRlciBnZXRzIHVwZGF0ZWQgc28gd2UgbmVlZCBhIGNvbW1pdFxuICAgICAgLy8gdG8gdXBkYXRlIHRoaXMgZWxlbWVudC5cbiAgICAgIGlmICghdXBkYXRlUGF5bG9hZCkge1xuICAgICAgICB1cGRhdGVQYXlsb2FkID0gW107XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEZvciBhbGwgb3RoZXIgZGVsZXRlZCBwcm9wZXJ0aWVzIHdlIGFkZCBpdCB0byB0aGUgcXVldWUuIFdlIHVzZVxuICAgICAgLy8gdGhlIGFsbG93ZWQgcHJvcGVydHkgbGlzdCBpbiB0aGUgY29tbWl0IHBoYXNlIGluc3RlYWQuXG4gICAgICAodXBkYXRlUGF5bG9hZCA9IHVwZGF0ZVBheWxvYWQgfHwgW10pLnB1c2gocHJvcEtleSwgbnVsbCk7XG4gICAgfVxuICB9XG5cbiAgZm9yIChwcm9wS2V5IGluIG5leHRQcm9wcykge1xuICAgIHZhciBuZXh0UHJvcCA9IG5leHRQcm9wc1twcm9wS2V5XTtcbiAgICB2YXIgbGFzdFByb3AgPSBsYXN0UHJvcHMgIT0gbnVsbCA/IGxhc3RQcm9wc1twcm9wS2V5XSA6IHVuZGVmaW5lZDtcblxuICAgIGlmICghbmV4dFByb3BzLmhhc093blByb3BlcnR5KHByb3BLZXkpIHx8IG5leHRQcm9wID09PSBsYXN0UHJvcCB8fCBuZXh0UHJvcCA9PSBudWxsICYmIGxhc3RQcm9wID09IG51bGwpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGlmIChwcm9wS2V5ID09PSBTVFlMRSkge1xuICAgICAge1xuICAgICAgICBpZiAobmV4dFByb3ApIHtcbiAgICAgICAgICAvLyBGcmVlemUgdGhlIG5leHQgc3R5bGUgb2JqZWN0IHNvIHRoYXQgd2UgY2FuIGFzc3VtZSBpdCB3b24ndCBiZVxuICAgICAgICAgIC8vIG11dGF0ZWQuIFdlIGhhdmUgYWxyZWFkeSB3YXJuZWQgZm9yIHRoaXMgaW4gdGhlIHBhc3QuXG4gICAgICAgICAgT2JqZWN0LmZyZWV6ZShuZXh0UHJvcCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGxhc3RQcm9wKSB7XG4gICAgICAgIC8vIFVuc2V0IHN0eWxlcyBvbiBgbGFzdFByb3BgIGJ1dCBub3Qgb24gYG5leHRQcm9wYC5cbiAgICAgICAgZm9yIChzdHlsZU5hbWUgaW4gbGFzdFByb3ApIHtcbiAgICAgICAgICBpZiAobGFzdFByb3AuaGFzT3duUHJvcGVydHkoc3R5bGVOYW1lKSAmJiAoIW5leHRQcm9wIHx8ICFuZXh0UHJvcC5oYXNPd25Qcm9wZXJ0eShzdHlsZU5hbWUpKSkge1xuICAgICAgICAgICAgaWYgKCFzdHlsZVVwZGF0ZXMpIHtcbiAgICAgICAgICAgICAgc3R5bGVVcGRhdGVzID0ge307XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHN0eWxlVXBkYXRlc1tzdHlsZU5hbWVdID0gJyc7XG4gICAgICAgICAgfVxuICAgICAgICB9IC8vIFVwZGF0ZSBzdHlsZXMgdGhhdCBjaGFuZ2VkIHNpbmNlIGBsYXN0UHJvcGAuXG5cblxuICAgICAgICBmb3IgKHN0eWxlTmFtZSBpbiBuZXh0UHJvcCkge1xuICAgICAgICAgIGlmIChuZXh0UHJvcC5oYXNPd25Qcm9wZXJ0eShzdHlsZU5hbWUpICYmIGxhc3RQcm9wW3N0eWxlTmFtZV0gIT09IG5leHRQcm9wW3N0eWxlTmFtZV0pIHtcbiAgICAgICAgICAgIGlmICghc3R5bGVVcGRhdGVzKSB7XG4gICAgICAgICAgICAgIHN0eWxlVXBkYXRlcyA9IHt9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzdHlsZVVwZGF0ZXNbc3R5bGVOYW1lXSA9IG5leHRQcm9wW3N0eWxlTmFtZV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBSZWxpZXMgb24gYHVwZGF0ZVN0eWxlc0J5SURgIG5vdCBtdXRhdGluZyBgc3R5bGVVcGRhdGVzYC5cbiAgICAgICAgaWYgKCFzdHlsZVVwZGF0ZXMpIHtcbiAgICAgICAgICBpZiAoIXVwZGF0ZVBheWxvYWQpIHtcbiAgICAgICAgICAgIHVwZGF0ZVBheWxvYWQgPSBbXTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB1cGRhdGVQYXlsb2FkLnB1c2gocHJvcEtleSwgc3R5bGVVcGRhdGVzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN0eWxlVXBkYXRlcyA9IG5leHRQcm9wO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocHJvcEtleSA9PT0gREFOR0VST1VTTFlfU0VUX0lOTkVSX0hUTUwpIHtcbiAgICAgIHZhciBuZXh0SHRtbCA9IG5leHRQcm9wID8gbmV4dFByb3BbSFRNTCQxXSA6IHVuZGVmaW5lZDtcbiAgICAgIHZhciBsYXN0SHRtbCA9IGxhc3RQcm9wID8gbGFzdFByb3BbSFRNTCQxXSA6IHVuZGVmaW5lZDtcblxuICAgICAgaWYgKG5leHRIdG1sICE9IG51bGwpIHtcbiAgICAgICAgaWYgKGxhc3RIdG1sICE9PSBuZXh0SHRtbCkge1xuICAgICAgICAgICh1cGRhdGVQYXlsb2FkID0gdXBkYXRlUGF5bG9hZCB8fCBbXSkucHVzaChwcm9wS2V5LCBuZXh0SHRtbCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHByb3BLZXkgPT09IENISUxEUkVOKSB7XG4gICAgICBpZiAodHlwZW9mIG5leHRQcm9wID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgbmV4dFByb3AgPT09ICdudW1iZXInKSB7XG4gICAgICAgICh1cGRhdGVQYXlsb2FkID0gdXBkYXRlUGF5bG9hZCB8fCBbXSkucHVzaChwcm9wS2V5LCAnJyArIG5leHRQcm9wKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHByb3BLZXkgPT09IFNVUFBSRVNTX0NPTlRFTlRfRURJVEFCTEVfV0FSTklORyB8fCBwcm9wS2V5ID09PSBTVVBQUkVTU19IWURSQVRJT05fV0FSTklORykgOyBlbHNlIGlmIChyZWdpc3RyYXRpb25OYW1lRGVwZW5kZW5jaWVzLmhhc093blByb3BlcnR5KHByb3BLZXkpKSB7XG4gICAgICBpZiAobmV4dFByb3AgIT0gbnVsbCkge1xuICAgICAgICAvLyBXZSBlYWdlcmx5IGxpc3RlbiB0byB0aGlzIGV2ZW4gdGhvdWdoIHdlIGhhdmVuJ3QgY29tbWl0dGVkIHlldC5cbiAgICAgICAgaWYgKCB0eXBlb2YgbmV4dFByb3AgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICB3YXJuRm9ySW52YWxpZEV2ZW50TGlzdGVuZXIocHJvcEtleSwgbmV4dFByb3ApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHByb3BLZXkgPT09ICdvblNjcm9sbCcpIHtcbiAgICAgICAgICBsaXN0ZW5Ub05vbkRlbGVnYXRlZEV2ZW50KCdzY3JvbGwnLCBkb21FbGVtZW50KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoIXVwZGF0ZVBheWxvYWQgJiYgbGFzdFByb3AgIT09IG5leHRQcm9wKSB7XG4gICAgICAgIC8vIFRoaXMgaXMgYSBzcGVjaWFsIGNhc2UuIElmIGFueSBsaXN0ZW5lciB1cGRhdGVzIHdlIG5lZWQgdG8gZW5zdXJlXG4gICAgICAgIC8vIHRoYXQgdGhlIFwiY3VycmVudFwiIHByb3BzIHBvaW50ZXIgZ2V0cyB1cGRhdGVkIHNvIHdlIG5lZWQgYSBjb21taXRcbiAgICAgICAgLy8gdG8gdXBkYXRlIHRoaXMgZWxlbWVudC5cbiAgICAgICAgdXBkYXRlUGF5bG9hZCA9IFtdO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodHlwZW9mIG5leHRQcm9wID09PSAnb2JqZWN0JyAmJiBuZXh0UHJvcCAhPT0gbnVsbCAmJiBuZXh0UHJvcC4kJHR5cGVvZiA9PT0gUkVBQ1RfT1BBUVVFX0lEX1RZUEUpIHtcbiAgICAgIC8vIElmIHdlIGVuY291bnRlciB1c2VPcGFxdWVSZWZlcmVuY2UncyBvcGFxdWUgb2JqZWN0LCB0aGlzIG1lYW5zIHdlIGFyZSBoeWRyYXRpbmcuXG4gICAgICAvLyBJbiB0aGlzIGNhc2UsIGNhbGwgdGhlIG9wYXF1ZSBvYmplY3QncyB0b1N0cmluZyBmdW5jdGlvbiB3aGljaCBnZW5lcmF0ZXMgYSBuZXcgY2xpZW50XG4gICAgICAvLyBJRCBzbyBjbGllbnQgYW5kIHNlcnZlciBJRHMgbWF0Y2ggYW5kIHRocm93cyB0byByZXJlbmRlci5cbiAgICAgIG5leHRQcm9wLnRvU3RyaW5nKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEZvciBhbnkgb3RoZXIgcHJvcGVydHkgd2UgYWx3YXlzIGFkZCBpdCB0byB0aGUgcXVldWUgYW5kIHRoZW4gd2VcbiAgICAgIC8vIGZpbHRlciBpdCBvdXQgdXNpbmcgdGhlIGFsbG93ZWQgcHJvcGVydHkgbGlzdCBkdXJpbmcgdGhlIGNvbW1pdC5cbiAgICAgICh1cGRhdGVQYXlsb2FkID0gdXBkYXRlUGF5bG9hZCB8fCBbXSkucHVzaChwcm9wS2V5LCBuZXh0UHJvcCk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHN0eWxlVXBkYXRlcykge1xuICAgIHtcbiAgICAgIHZhbGlkYXRlU2hvcnRoYW5kUHJvcGVydHlDb2xsaXNpb25JbkRldihzdHlsZVVwZGF0ZXMsIG5leHRQcm9wc1tTVFlMRV0pO1xuICAgIH1cblxuICAgICh1cGRhdGVQYXlsb2FkID0gdXBkYXRlUGF5bG9hZCB8fCBbXSkucHVzaChTVFlMRSwgc3R5bGVVcGRhdGVzKTtcbiAgfVxuXG4gIHJldHVybiB1cGRhdGVQYXlsb2FkO1xufSAvLyBBcHBseSB0aGUgZGlmZi5cblxuZnVuY3Rpb24gdXBkYXRlUHJvcGVydGllcyhkb21FbGVtZW50LCB1cGRhdGVQYXlsb2FkLCB0YWcsIGxhc3RSYXdQcm9wcywgbmV4dFJhd1Byb3BzKSB7XG4gIC8vIFVwZGF0ZSBjaGVja2VkICpiZWZvcmUqIG5hbWUuXG4gIC8vIEluIHRoZSBtaWRkbGUgb2YgYW4gdXBkYXRlLCBpdCBpcyBwb3NzaWJsZSB0byBoYXZlIG11bHRpcGxlIGNoZWNrZWQuXG4gIC8vIFdoZW4gYSBjaGVja2VkIHJhZGlvIHRyaWVzIHRvIGNoYW5nZSBuYW1lLCBicm93c2VyIG1ha2VzIGFub3RoZXIgcmFkaW8ncyBjaGVja2VkIGZhbHNlLlxuICBpZiAodGFnID09PSAnaW5wdXQnICYmIG5leHRSYXdQcm9wcy50eXBlID09PSAncmFkaW8nICYmIG5leHRSYXdQcm9wcy5uYW1lICE9IG51bGwpIHtcbiAgICB1cGRhdGVDaGVja2VkKGRvbUVsZW1lbnQsIG5leHRSYXdQcm9wcyk7XG4gIH1cblxuICB2YXIgd2FzQ3VzdG9tQ29tcG9uZW50VGFnID0gaXNDdXN0b21Db21wb25lbnQodGFnLCBsYXN0UmF3UHJvcHMpO1xuICB2YXIgaXNDdXN0b21Db21wb25lbnRUYWcgPSBpc0N1c3RvbUNvbXBvbmVudCh0YWcsIG5leHRSYXdQcm9wcyk7IC8vIEFwcGx5IHRoZSBkaWZmLlxuXG4gIHVwZGF0ZURPTVByb3BlcnRpZXMoZG9tRWxlbWVudCwgdXBkYXRlUGF5bG9hZCwgd2FzQ3VzdG9tQ29tcG9uZW50VGFnLCBpc0N1c3RvbUNvbXBvbmVudFRhZyk7IC8vIFRPRE86IEVuc3VyZSB0aGF0IGFuIHVwZGF0ZSBnZXRzIHNjaGVkdWxlZCBpZiBhbnkgb2YgdGhlIHNwZWNpYWwgcHJvcHNcbiAgLy8gY2hhbmdlZC5cblxuICBzd2l0Y2ggKHRhZykge1xuICAgIGNhc2UgJ2lucHV0JzpcbiAgICAgIC8vIFVwZGF0ZSB0aGUgd3JhcHBlciBhcm91bmQgaW5wdXRzICphZnRlciogdXBkYXRpbmcgcHJvcHMuIFRoaXMgaGFzIHRvXG4gICAgICAvLyBoYXBwZW4gYWZ0ZXIgYHVwZGF0ZURPTVByb3BlcnRpZXNgLiBPdGhlcndpc2UgSFRNTDUgaW5wdXQgdmFsaWRhdGlvbnNcbiAgICAgIC8vIHJhaXNlIHdhcm5pbmdzIGFuZCBwcmV2ZW50IHRoZSBuZXcgdmFsdWUgZnJvbSBiZWluZyBhc3NpZ25lZC5cbiAgICAgIHVwZGF0ZVdyYXBwZXIoZG9tRWxlbWVudCwgbmV4dFJhd1Byb3BzKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAndGV4dGFyZWEnOlxuICAgICAgdXBkYXRlV3JhcHBlciQxKGRvbUVsZW1lbnQsIG5leHRSYXdQcm9wcyk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ3NlbGVjdCc6XG4gICAgICAvLyA8c2VsZWN0PiB2YWx1ZSB1cGRhdGUgbmVlZHMgdG8gb2NjdXIgYWZ0ZXIgPG9wdGlvbj4gY2hpbGRyZW5cbiAgICAgIC8vIHJlY29uY2lsaWF0aW9uXG4gICAgICBwb3N0VXBkYXRlV3JhcHBlcihkb21FbGVtZW50LCBuZXh0UmF3UHJvcHMpO1xuICAgICAgYnJlYWs7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0UG9zc2libGVTdGFuZGFyZE5hbWUocHJvcE5hbWUpIHtcbiAge1xuICAgIHZhciBsb3dlckNhc2VkTmFtZSA9IHByb3BOYW1lLnRvTG93ZXJDYXNlKCk7XG5cbiAgICBpZiAoIXBvc3NpYmxlU3RhbmRhcmROYW1lcy5oYXNPd25Qcm9wZXJ0eShsb3dlckNhc2VkTmFtZSkpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiBwb3NzaWJsZVN0YW5kYXJkTmFtZXNbbG93ZXJDYXNlZE5hbWVdIHx8IG51bGw7XG4gIH1cbn1cblxuZnVuY3Rpb24gZGlmZkh5ZHJhdGVkUHJvcGVydGllcyhkb21FbGVtZW50LCB0YWcsIHJhd1Byb3BzLCBwYXJlbnROYW1lc3BhY2UsIHJvb3RDb250YWluZXJFbGVtZW50KSB7XG4gIHZhciBpc0N1c3RvbUNvbXBvbmVudFRhZztcbiAgdmFyIGV4dHJhQXR0cmlidXRlTmFtZXM7XG5cbiAge1xuICAgIHN1cHByZXNzSHlkcmF0aW9uV2FybmluZyA9IHJhd1Byb3BzW1NVUFBSRVNTX0hZRFJBVElPTl9XQVJOSU5HXSA9PT0gdHJ1ZTtcbiAgICBpc0N1c3RvbUNvbXBvbmVudFRhZyA9IGlzQ3VzdG9tQ29tcG9uZW50KHRhZywgcmF3UHJvcHMpO1xuICAgIHZhbGlkYXRlUHJvcGVydGllc0luRGV2ZWxvcG1lbnQodGFnLCByYXdQcm9wcyk7XG4gIH0gLy8gVE9ETzogTWFrZSBzdXJlIHRoYXQgd2UgY2hlY2sgaXNNb3VudGVkIGJlZm9yZSBmaXJpbmcgYW55IG9mIHRoZXNlIGV2ZW50cy5cblxuXG4gIHN3aXRjaCAodGFnKSB7XG4gICAgY2FzZSAnZGlhbG9nJzpcbiAgICAgIGxpc3RlblRvTm9uRGVsZWdhdGVkRXZlbnQoJ2NhbmNlbCcsIGRvbUVsZW1lbnQpO1xuICAgICAgbGlzdGVuVG9Ob25EZWxlZ2F0ZWRFdmVudCgnY2xvc2UnLCBkb21FbGVtZW50KTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnaWZyYW1lJzpcbiAgICBjYXNlICdvYmplY3QnOlxuICAgIGNhc2UgJ2VtYmVkJzpcbiAgICAgIC8vIFdlIGxpc3RlbiB0byB0aGlzIGV2ZW50IGluIGNhc2UgdG8gZW5zdXJlIGVtdWxhdGVkIGJ1YmJsZVxuICAgICAgLy8gbGlzdGVuZXJzIHN0aWxsIGZpcmUgZm9yIHRoZSBsb2FkIGV2ZW50LlxuICAgICAgbGlzdGVuVG9Ob25EZWxlZ2F0ZWRFdmVudCgnbG9hZCcsIGRvbUVsZW1lbnQpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICd2aWRlbyc6XG4gICAgY2FzZSAnYXVkaW8nOlxuICAgICAgLy8gV2UgbGlzdGVuIHRvIHRoZXNlIGV2ZW50cyBpbiBjYXNlIHRvIGVuc3VyZSBlbXVsYXRlZCBidWJibGVcbiAgICAgIC8vIGxpc3RlbmVycyBzdGlsbCBmaXJlIGZvciBhbGwgdGhlIG1lZGlhIGV2ZW50cy5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWVkaWFFdmVudFR5cGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxpc3RlblRvTm9uRGVsZWdhdGVkRXZlbnQobWVkaWFFdmVudFR5cGVzW2ldLCBkb21FbGVtZW50KTtcbiAgICAgIH1cblxuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdzb3VyY2UnOlxuICAgICAgLy8gV2UgbGlzdGVuIHRvIHRoaXMgZXZlbnQgaW4gY2FzZSB0byBlbnN1cmUgZW11bGF0ZWQgYnViYmxlXG4gICAgICAvLyBsaXN0ZW5lcnMgc3RpbGwgZmlyZSBmb3IgdGhlIGVycm9yIGV2ZW50LlxuICAgICAgbGlzdGVuVG9Ob25EZWxlZ2F0ZWRFdmVudCgnZXJyb3InLCBkb21FbGVtZW50KTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnaW1nJzpcbiAgICBjYXNlICdpbWFnZSc6XG4gICAgY2FzZSAnbGluayc6XG4gICAgICAvLyBXZSBsaXN0ZW4gdG8gdGhlc2UgZXZlbnRzIGluIGNhc2UgdG8gZW5zdXJlIGVtdWxhdGVkIGJ1YmJsZVxuICAgICAgLy8gbGlzdGVuZXJzIHN0aWxsIGZpcmUgZm9yIGVycm9yIGFuZCBsb2FkIGV2ZW50cy5cbiAgICAgIGxpc3RlblRvTm9uRGVsZWdhdGVkRXZlbnQoJ2Vycm9yJywgZG9tRWxlbWVudCk7XG4gICAgICBsaXN0ZW5Ub05vbkRlbGVnYXRlZEV2ZW50KCdsb2FkJywgZG9tRWxlbWVudCk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ2RldGFpbHMnOlxuICAgICAgLy8gV2UgbGlzdGVuIHRvIHRoaXMgZXZlbnQgaW4gY2FzZSB0byBlbnN1cmUgZW11bGF0ZWQgYnViYmxlXG4gICAgICAvLyBsaXN0ZW5lcnMgc3RpbGwgZmlyZSBmb3IgdGhlIHRvZ2dsZSBldmVudC5cbiAgICAgIGxpc3RlblRvTm9uRGVsZWdhdGVkRXZlbnQoJ3RvZ2dsZScsIGRvbUVsZW1lbnQpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdpbnB1dCc6XG4gICAgICBpbml0V3JhcHBlclN0YXRlKGRvbUVsZW1lbnQsIHJhd1Byb3BzKTsgLy8gV2UgbGlzdGVuIHRvIHRoaXMgZXZlbnQgaW4gY2FzZSB0byBlbnN1cmUgZW11bGF0ZWQgYnViYmxlXG4gICAgICAvLyBsaXN0ZW5lcnMgc3RpbGwgZmlyZSBmb3IgdGhlIGludmFsaWQgZXZlbnQuXG5cbiAgICAgIGxpc3RlblRvTm9uRGVsZWdhdGVkRXZlbnQoJ2ludmFsaWQnLCBkb21FbGVtZW50KTtcblxuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdvcHRpb24nOlxuICAgICAgdmFsaWRhdGVQcm9wcyhkb21FbGVtZW50LCByYXdQcm9wcyk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ3NlbGVjdCc6XG4gICAgICBpbml0V3JhcHBlclN0YXRlJDEoZG9tRWxlbWVudCwgcmF3UHJvcHMpOyAvLyBXZSBsaXN0ZW4gdG8gdGhpcyBldmVudCBpbiBjYXNlIHRvIGVuc3VyZSBlbXVsYXRlZCBidWJibGVcbiAgICAgIC8vIGxpc3RlbmVycyBzdGlsbCBmaXJlIGZvciB0aGUgaW52YWxpZCBldmVudC5cblxuICAgICAgbGlzdGVuVG9Ob25EZWxlZ2F0ZWRFdmVudCgnaW52YWxpZCcsIGRvbUVsZW1lbnQpO1xuXG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ3RleHRhcmVhJzpcbiAgICAgIGluaXRXcmFwcGVyU3RhdGUkMihkb21FbGVtZW50LCByYXdQcm9wcyk7IC8vIFdlIGxpc3RlbiB0byB0aGlzIGV2ZW50IGluIGNhc2UgdG8gZW5zdXJlIGVtdWxhdGVkIGJ1YmJsZVxuICAgICAgLy8gbGlzdGVuZXJzIHN0aWxsIGZpcmUgZm9yIHRoZSBpbnZhbGlkIGV2ZW50LlxuXG4gICAgICBsaXN0ZW5Ub05vbkRlbGVnYXRlZEV2ZW50KCdpbnZhbGlkJywgZG9tRWxlbWVudCk7XG5cbiAgICAgIGJyZWFrO1xuICB9XG5cbiAgYXNzZXJ0VmFsaWRQcm9wcyh0YWcsIHJhd1Byb3BzKTtcblxuICB7XG4gICAgZXh0cmFBdHRyaWJ1dGVOYW1lcyA9IG5ldyBTZXQoKTtcbiAgICB2YXIgYXR0cmlidXRlcyA9IGRvbUVsZW1lbnQuYXR0cmlidXRlcztcblxuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhdHRyaWJ1dGVzLmxlbmd0aDsgX2krKykge1xuICAgICAgdmFyIG5hbWUgPSBhdHRyaWJ1dGVzW19pXS5uYW1lLnRvTG93ZXJDYXNlKCk7XG5cbiAgICAgIHN3aXRjaCAobmFtZSkge1xuICAgICAgICAvLyBCdWlsdC1pbiBTU1IgYXR0cmlidXRlIGlzIGFsbG93ZWRcbiAgICAgICAgY2FzZSAnZGF0YS1yZWFjdHJvb3QnOlxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICAvLyBDb250cm9sbGVkIGF0dHJpYnV0ZXMgYXJlIG5vdCB2YWxpZGF0ZWRcbiAgICAgICAgLy8gVE9ETzogT25seSBpZ25vcmUgdGhlbSBvbiBjb250cm9sbGVkIHRhZ3MuXG5cbiAgICAgICAgY2FzZSAndmFsdWUnOlxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ2NoZWNrZWQnOlxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ3NlbGVjdGVkJzpcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIC8vIEludGVudGlvbmFsbHkgdXNlIHRoZSBvcmlnaW5hbCBuYW1lLlxuICAgICAgICAgIC8vIFNlZSBkaXNjdXNzaW9uIGluIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9wdWxsLzEwNjc2LlxuICAgICAgICAgIGV4dHJhQXR0cmlidXRlTmFtZXMuYWRkKGF0dHJpYnV0ZXNbX2ldLm5hbWUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHZhciB1cGRhdGVQYXlsb2FkID0gbnVsbDtcblxuICBmb3IgKHZhciBwcm9wS2V5IGluIHJhd1Byb3BzKSB7XG4gICAgaWYgKCFyYXdQcm9wcy5oYXNPd25Qcm9wZXJ0eShwcm9wS2V5KSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgdmFyIG5leHRQcm9wID0gcmF3UHJvcHNbcHJvcEtleV07XG5cbiAgICBpZiAocHJvcEtleSA9PT0gQ0hJTERSRU4pIHtcbiAgICAgIC8vIEZvciB0ZXh0IGNvbnRlbnQgY2hpbGRyZW4gd2UgY29tcGFyZSBhZ2FpbnN0IHRleHRDb250ZW50LiBUaGlzXG4gICAgICAvLyBtaWdodCBtYXRjaCBhZGRpdGlvbmFsIEhUTUwgdGhhdCBpcyBoaWRkZW4gd2hlbiB3ZSByZWFkIGl0IHVzaW5nXG4gICAgICAvLyB0ZXh0Q29udGVudC4gRS5nLiBcImZvb1wiIHdpbGwgbWF0Y2ggXCJmPHNwYW4+b288L3NwYW4+XCIgYnV0IHRoYXQgc3RpbGxcbiAgICAgIC8vIHNhdGlzZmllcyBvdXIgcmVxdWlyZW1lbnQuIE91ciByZXF1aXJlbWVudCBpcyBub3QgdG8gcHJvZHVjZSBwZXJmZWN0XG4gICAgICAvLyBIVE1MIGFuZCBhdHRyaWJ1dGVzLiBJZGVhbGx5IHdlIHNob3VsZCBwcmVzZXJ2ZSBzdHJ1Y3R1cmUgYnV0IGl0J3NcbiAgICAgIC8vIG9rIG5vdCB0byBpZiB0aGUgdmlzaWJsZSBjb250ZW50IGlzIHN0aWxsIGVub3VnaCB0byBpbmRpY2F0ZSB3aGF0XG4gICAgICAvLyBldmVuIGxpc3RlbmVycyB0aGVzZSBub2RlcyBtaWdodCBiZSB3aXJlZCB1cCB0by5cbiAgICAgIC8vIFRPRE86IFdhcm4gaWYgdGhlcmUgaXMgbW9yZSB0aGFuIGEgc2luZ2xlIHRleHROb2RlIGFzIGEgY2hpbGQuXG4gICAgICAvLyBUT0RPOiBTaG91bGQgd2UgdXNlIGRvbUVsZW1lbnQuZmlyc3RDaGlsZC5ub2RlVmFsdWUgdG8gY29tcGFyZT9cbiAgICAgIGlmICh0eXBlb2YgbmV4dFByb3AgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGlmIChkb21FbGVtZW50LnRleHRDb250ZW50ICE9PSBuZXh0UHJvcCkge1xuICAgICAgICAgIGlmICggIXN1cHByZXNzSHlkcmF0aW9uV2FybmluZykge1xuICAgICAgICAgICAgd2FybkZvclRleHREaWZmZXJlbmNlKGRvbUVsZW1lbnQudGV4dENvbnRlbnQsIG5leHRQcm9wKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB1cGRhdGVQYXlsb2FkID0gW0NISUxEUkVOLCBuZXh0UHJvcF07XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIG5leHRQcm9wID09PSAnbnVtYmVyJykge1xuICAgICAgICBpZiAoZG9tRWxlbWVudC50ZXh0Q29udGVudCAhPT0gJycgKyBuZXh0UHJvcCkge1xuICAgICAgICAgIGlmICggIXN1cHByZXNzSHlkcmF0aW9uV2FybmluZykge1xuICAgICAgICAgICAgd2FybkZvclRleHREaWZmZXJlbmNlKGRvbUVsZW1lbnQudGV4dENvbnRlbnQsIG5leHRQcm9wKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB1cGRhdGVQYXlsb2FkID0gW0NISUxEUkVOLCAnJyArIG5leHRQcm9wXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocmVnaXN0cmF0aW9uTmFtZURlcGVuZGVuY2llcy5oYXNPd25Qcm9wZXJ0eShwcm9wS2V5KSkge1xuICAgICAgaWYgKG5leHRQcm9wICE9IG51bGwpIHtcbiAgICAgICAgaWYgKCB0eXBlb2YgbmV4dFByb3AgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICB3YXJuRm9ySW52YWxpZEV2ZW50TGlzdGVuZXIocHJvcEtleSwgbmV4dFByb3ApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHByb3BLZXkgPT09ICdvblNjcm9sbCcpIHtcbiAgICAgICAgICBsaXN0ZW5Ub05vbkRlbGVnYXRlZEV2ZW50KCdzY3JvbGwnLCBkb21FbGVtZW50KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoIC8vIENvbnZpbmNlIEZsb3cgd2UndmUgY2FsY3VsYXRlZCBpdCAoaXQncyBERVYtb25seSBpbiB0aGlzIG1ldGhvZC4pXG4gICAgdHlwZW9mIGlzQ3VzdG9tQ29tcG9uZW50VGFnID09PSAnYm9vbGVhbicpIHtcbiAgICAgIC8vIFZhbGlkYXRlIHRoYXQgdGhlIHByb3BlcnRpZXMgY29ycmVzcG9uZCB0byB0aGVpciBleHBlY3RlZCB2YWx1ZXMuXG4gICAgICB2YXIgc2VydmVyVmFsdWUgPSB2b2lkIDA7XG4gICAgICB2YXIgcHJvcGVydHlJbmZvID0gZ2V0UHJvcGVydHlJbmZvKHByb3BLZXkpO1xuXG4gICAgICBpZiAoc3VwcHJlc3NIeWRyYXRpb25XYXJuaW5nKSA7IGVsc2UgaWYgKHByb3BLZXkgPT09IFNVUFBSRVNTX0NPTlRFTlRfRURJVEFCTEVfV0FSTklORyB8fCBwcm9wS2V5ID09PSBTVVBQUkVTU19IWURSQVRJT05fV0FSTklORyB8fCAvLyBDb250cm9sbGVkIGF0dHJpYnV0ZXMgYXJlIG5vdCB2YWxpZGF0ZWRcbiAgICAgIC8vIFRPRE86IE9ubHkgaWdub3JlIHRoZW0gb24gY29udHJvbGxlZCB0YWdzLlxuICAgICAgcHJvcEtleSA9PT0gJ3ZhbHVlJyB8fCBwcm9wS2V5ID09PSAnY2hlY2tlZCcgfHwgcHJvcEtleSA9PT0gJ3NlbGVjdGVkJykgOyBlbHNlIGlmIChwcm9wS2V5ID09PSBEQU5HRVJPVVNMWV9TRVRfSU5ORVJfSFRNTCkge1xuICAgICAgICB2YXIgc2VydmVySFRNTCA9IGRvbUVsZW1lbnQuaW5uZXJIVE1MO1xuICAgICAgICB2YXIgbmV4dEh0bWwgPSBuZXh0UHJvcCA/IG5leHRQcm9wW0hUTUwkMV0gOiB1bmRlZmluZWQ7XG5cbiAgICAgICAgaWYgKG5leHRIdG1sICE9IG51bGwpIHtcbiAgICAgICAgICB2YXIgZXhwZWN0ZWRIVE1MID0gbm9ybWFsaXplSFRNTChkb21FbGVtZW50LCBuZXh0SHRtbCk7XG5cbiAgICAgICAgICBpZiAoZXhwZWN0ZWRIVE1MICE9PSBzZXJ2ZXJIVE1MKSB7XG4gICAgICAgICAgICB3YXJuRm9yUHJvcERpZmZlcmVuY2UocHJvcEtleSwgc2VydmVySFRNTCwgZXhwZWN0ZWRIVE1MKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAocHJvcEtleSA9PT0gU1RZTEUpIHtcbiAgICAgICAgLy8gJEZsb3dGaXhNZSAtIFNob3VsZCBiZSBpbmZlcnJlZCBhcyBub3QgdW5kZWZpbmVkLlxuICAgICAgICBleHRyYUF0dHJpYnV0ZU5hbWVzLmRlbGV0ZShwcm9wS2V5KTtcblxuICAgICAgICBpZiAoY2FuRGlmZlN0eWxlRm9ySHlkcmF0aW9uV2FybmluZykge1xuICAgICAgICAgIHZhciBleHBlY3RlZFN0eWxlID0gY3JlYXRlRGFuZ2Vyb3VzU3RyaW5nRm9yU3R5bGVzKG5leHRQcm9wKTtcbiAgICAgICAgICBzZXJ2ZXJWYWx1ZSA9IGRvbUVsZW1lbnQuZ2V0QXR0cmlidXRlKCdzdHlsZScpO1xuXG4gICAgICAgICAgaWYgKGV4cGVjdGVkU3R5bGUgIT09IHNlcnZlclZhbHVlKSB7XG4gICAgICAgICAgICB3YXJuRm9yUHJvcERpZmZlcmVuY2UocHJvcEtleSwgc2VydmVyVmFsdWUsIGV4cGVjdGVkU3R5bGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChpc0N1c3RvbUNvbXBvbmVudFRhZykge1xuICAgICAgICAvLyAkRmxvd0ZpeE1lIC0gU2hvdWxkIGJlIGluZmVycmVkIGFzIG5vdCB1bmRlZmluZWQuXG4gICAgICAgIGV4dHJhQXR0cmlidXRlTmFtZXMuZGVsZXRlKHByb3BLZXkudG9Mb3dlckNhc2UoKSk7XG4gICAgICAgIHNlcnZlclZhbHVlID0gZ2V0VmFsdWVGb3JBdHRyaWJ1dGUoZG9tRWxlbWVudCwgcHJvcEtleSwgbmV4dFByb3ApO1xuXG4gICAgICAgIGlmIChuZXh0UHJvcCAhPT0gc2VydmVyVmFsdWUpIHtcbiAgICAgICAgICB3YXJuRm9yUHJvcERpZmZlcmVuY2UocHJvcEtleSwgc2VydmVyVmFsdWUsIG5leHRQcm9wKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICghc2hvdWxkSWdub3JlQXR0cmlidXRlKHByb3BLZXksIHByb3BlcnR5SW5mbywgaXNDdXN0b21Db21wb25lbnRUYWcpICYmICFzaG91bGRSZW1vdmVBdHRyaWJ1dGUocHJvcEtleSwgbmV4dFByb3AsIHByb3BlcnR5SW5mbywgaXNDdXN0b21Db21wb25lbnRUYWcpKSB7XG4gICAgICAgIHZhciBpc01pc21hdGNoRHVlVG9CYWRDYXNpbmcgPSBmYWxzZTtcblxuICAgICAgICBpZiAocHJvcGVydHlJbmZvICE9PSBudWxsKSB7XG4gICAgICAgICAgLy8gJEZsb3dGaXhNZSAtIFNob3VsZCBiZSBpbmZlcnJlZCBhcyBub3QgdW5kZWZpbmVkLlxuICAgICAgICAgIGV4dHJhQXR0cmlidXRlTmFtZXMuZGVsZXRlKHByb3BlcnR5SW5mby5hdHRyaWJ1dGVOYW1lKTtcbiAgICAgICAgICBzZXJ2ZXJWYWx1ZSA9IGdldFZhbHVlRm9yUHJvcGVydHkoZG9tRWxlbWVudCwgcHJvcEtleSwgbmV4dFByb3AsIHByb3BlcnR5SW5mbyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIG93bk5hbWVzcGFjZSA9IHBhcmVudE5hbWVzcGFjZTtcblxuICAgICAgICAgIGlmIChvd25OYW1lc3BhY2UgPT09IEhUTUxfTkFNRVNQQUNFJDEpIHtcbiAgICAgICAgICAgIG93bk5hbWVzcGFjZSA9IGdldEludHJpbnNpY05hbWVzcGFjZSh0YWcpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChvd25OYW1lc3BhY2UgPT09IEhUTUxfTkFNRVNQQUNFJDEpIHtcbiAgICAgICAgICAgIC8vICRGbG93Rml4TWUgLSBTaG91bGQgYmUgaW5mZXJyZWQgYXMgbm90IHVuZGVmaW5lZC5cbiAgICAgICAgICAgIGV4dHJhQXR0cmlidXRlTmFtZXMuZGVsZXRlKHByb3BLZXkudG9Mb3dlckNhc2UoKSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBzdGFuZGFyZE5hbWUgPSBnZXRQb3NzaWJsZVN0YW5kYXJkTmFtZShwcm9wS2V5KTtcblxuICAgICAgICAgICAgaWYgKHN0YW5kYXJkTmFtZSAhPT0gbnVsbCAmJiBzdGFuZGFyZE5hbWUgIT09IHByb3BLZXkpIHtcbiAgICAgICAgICAgICAgLy8gSWYgYW4gU1ZHIHByb3AgaXMgc3VwcGxpZWQgd2l0aCBiYWQgY2FzaW5nLCBpdCB3aWxsXG4gICAgICAgICAgICAgIC8vIGJlIHN1Y2Nlc3NmdWxseSBwYXJzZWQgZnJvbSBIVE1MLCBidXQgd2lsbCBwcm9kdWNlIGEgbWlzbWF0Y2hcbiAgICAgICAgICAgICAgLy8gKGFuZCB3b3VsZCBiZSBpbmNvcnJlY3RseSByZW5kZXJlZCBvbiB0aGUgY2xpZW50KS5cbiAgICAgICAgICAgICAgLy8gSG93ZXZlciwgd2UgYWxyZWFkeSB3YXJuIGFib3V0IGJhZCBjYXNpbmcgZWxzZXdoZXJlLlxuICAgICAgICAgICAgICAvLyBTbyB3ZSdsbCBza2lwIHRoZSBtaXNsZWFkaW5nIGV4dHJhIG1pc21hdGNoIHdhcm5pbmcgaW4gdGhpcyBjYXNlLlxuICAgICAgICAgICAgICBpc01pc21hdGNoRHVlVG9CYWRDYXNpbmcgPSB0cnVlOyAvLyAkRmxvd0ZpeE1lIC0gU2hvdWxkIGJlIGluZmVycmVkIGFzIG5vdCB1bmRlZmluZWQuXG5cbiAgICAgICAgICAgICAgZXh0cmFBdHRyaWJ1dGVOYW1lcy5kZWxldGUoc3RhbmRhcmROYW1lKTtcbiAgICAgICAgICAgIH0gLy8gJEZsb3dGaXhNZSAtIFNob3VsZCBiZSBpbmZlcnJlZCBhcyBub3QgdW5kZWZpbmVkLlxuXG5cbiAgICAgICAgICAgIGV4dHJhQXR0cmlidXRlTmFtZXMuZGVsZXRlKHByb3BLZXkpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHNlcnZlclZhbHVlID0gZ2V0VmFsdWVGb3JBdHRyaWJ1dGUoZG9tRWxlbWVudCwgcHJvcEtleSwgbmV4dFByb3ApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG5leHRQcm9wICE9PSBzZXJ2ZXJWYWx1ZSAmJiAhaXNNaXNtYXRjaER1ZVRvQmFkQ2FzaW5nKSB7XG4gICAgICAgICAgd2FybkZvclByb3BEaWZmZXJlbmNlKHByb3BLZXksIHNlcnZlclZhbHVlLCBuZXh0UHJvcCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB7XG4gICAgLy8gJEZsb3dGaXhNZSAtIFNob3VsZCBiZSBpbmZlcnJlZCBhcyBub3QgdW5kZWZpbmVkLlxuICAgIGlmIChleHRyYUF0dHJpYnV0ZU5hbWVzLnNpemUgPiAwICYmICFzdXBwcmVzc0h5ZHJhdGlvbldhcm5pbmcpIHtcbiAgICAgIC8vICRGbG93Rml4TWUgLSBTaG91bGQgYmUgaW5mZXJyZWQgYXMgbm90IHVuZGVmaW5lZC5cbiAgICAgIHdhcm5Gb3JFeHRyYUF0dHJpYnV0ZXMoZXh0cmFBdHRyaWJ1dGVOYW1lcyk7XG4gICAgfVxuICB9XG5cbiAgc3dpdGNoICh0YWcpIHtcbiAgICBjYXNlICdpbnB1dCc6XG4gICAgICAvLyBUT0RPOiBNYWtlIHN1cmUgd2UgY2hlY2sgaWYgdGhpcyBpcyBzdGlsbCB1bm1vdW50ZWQgb3IgZG8gYW55IGNsZWFuXG4gICAgICAvLyB1cCBuZWNlc3Nhcnkgc2luY2Ugd2UgbmV2ZXIgc3RvcCB0cmFja2luZyBhbnltb3JlLlxuICAgICAgdHJhY2soZG9tRWxlbWVudCk7XG4gICAgICBwb3N0TW91bnRXcmFwcGVyKGRvbUVsZW1lbnQsIHJhd1Byb3BzLCB0cnVlKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAndGV4dGFyZWEnOlxuICAgICAgLy8gVE9ETzogTWFrZSBzdXJlIHdlIGNoZWNrIGlmIHRoaXMgaXMgc3RpbGwgdW5tb3VudGVkIG9yIGRvIGFueSBjbGVhblxuICAgICAgLy8gdXAgbmVjZXNzYXJ5IHNpbmNlIHdlIG5ldmVyIHN0b3AgdHJhY2tpbmcgYW55bW9yZS5cbiAgICAgIHRyYWNrKGRvbUVsZW1lbnQpO1xuICAgICAgcG9zdE1vdW50V3JhcHBlciQzKGRvbUVsZW1lbnQpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdzZWxlY3QnOlxuICAgIGNhc2UgJ29wdGlvbic6XG4gICAgICAvLyBGb3IgaW5wdXQgYW5kIHRleHRhcmVhIHdlIGN1cnJlbnQgYWx3YXlzIHNldCB0aGUgdmFsdWUgcHJvcGVydHkgYXRcbiAgICAgIC8vIHBvc3QgbW91bnQgdG8gZm9yY2UgaXQgdG8gZGl2ZXJnZSBmcm9tIGF0dHJpYnV0ZXMuIEhvd2V2ZXIsIGZvclxuICAgICAgLy8gb3B0aW9uIGFuZCBzZWxlY3Qgd2UgZG9uJ3QgcXVpdGUgZG8gdGhlIHNhbWUgdGhpbmcgYW5kIHNlbGVjdFxuICAgICAgLy8gaXMgbm90IHJlc2lsaWVudCB0byB0aGUgRE9NIHN0YXRlIGNoYW5naW5nIHNvIHdlIGRvbid0IGRvIHRoYXQgaGVyZS5cbiAgICAgIC8vIFRPRE86IENvbnNpZGVyIG5vdCBkb2luZyB0aGlzIGZvciBpbnB1dCBhbmQgdGV4dGFyZWEuXG4gICAgICBicmVhaztcblxuICAgIGRlZmF1bHQ6XG4gICAgICBpZiAodHlwZW9mIHJhd1Byb3BzLm9uQ2xpY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgLy8gVE9ETzogVGhpcyBjYXN0IG1heSBub3QgYmUgc291bmQgZm9yIFNWRywgTWF0aE1MIG9yIGN1c3RvbSBlbGVtZW50cy5cbiAgICAgICAgdHJhcENsaWNrT25Ob25JbnRlcmFjdGl2ZUVsZW1lbnQoZG9tRWxlbWVudCk7XG4gICAgICB9XG5cbiAgICAgIGJyZWFrO1xuICB9XG5cbiAgcmV0dXJuIHVwZGF0ZVBheWxvYWQ7XG59XG5mdW5jdGlvbiBkaWZmSHlkcmF0ZWRUZXh0KHRleHROb2RlLCB0ZXh0KSB7XG4gIHZhciBpc0RpZmZlcmVudCA9IHRleHROb2RlLm5vZGVWYWx1ZSAhPT0gdGV4dDtcbiAgcmV0dXJuIGlzRGlmZmVyZW50O1xufVxuZnVuY3Rpb24gd2FybkZvclVubWF0Y2hlZFRleHQodGV4dE5vZGUsIHRleHQpIHtcbiAge1xuICAgIHdhcm5Gb3JUZXh0RGlmZmVyZW5jZSh0ZXh0Tm9kZS5ub2RlVmFsdWUsIHRleHQpO1xuICB9XG59XG5mdW5jdGlvbiB3YXJuRm9yRGVsZXRlZEh5ZHJhdGFibGVFbGVtZW50KHBhcmVudE5vZGUsIGNoaWxkKSB7XG4gIHtcbiAgICBpZiAoZGlkV2FybkludmFsaWRIeWRyYXRpb24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBkaWRXYXJuSW52YWxpZEh5ZHJhdGlvbiA9IHRydWU7XG5cbiAgICBlcnJvcignRGlkIG5vdCBleHBlY3Qgc2VydmVyIEhUTUwgdG8gY29udGFpbiBhIDwlcz4gaW4gPCVzPi4nLCBjaGlsZC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpLCBwYXJlbnROb2RlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkpO1xuICB9XG59XG5mdW5jdGlvbiB3YXJuRm9yRGVsZXRlZEh5ZHJhdGFibGVUZXh0KHBhcmVudE5vZGUsIGNoaWxkKSB7XG4gIHtcbiAgICBpZiAoZGlkV2FybkludmFsaWRIeWRyYXRpb24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBkaWRXYXJuSW52YWxpZEh5ZHJhdGlvbiA9IHRydWU7XG5cbiAgICBlcnJvcignRGlkIG5vdCBleHBlY3Qgc2VydmVyIEhUTUwgdG8gY29udGFpbiB0aGUgdGV4dCBub2RlIFwiJXNcIiBpbiA8JXM+LicsIGNoaWxkLm5vZGVWYWx1ZSwgcGFyZW50Tm9kZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpKTtcbiAgfVxufVxuZnVuY3Rpb24gd2FybkZvckluc2VydGVkSHlkcmF0ZWRFbGVtZW50KHBhcmVudE5vZGUsIHRhZywgcHJvcHMpIHtcbiAge1xuICAgIGlmIChkaWRXYXJuSW52YWxpZEh5ZHJhdGlvbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGRpZFdhcm5JbnZhbGlkSHlkcmF0aW9uID0gdHJ1ZTtcblxuICAgIGVycm9yKCdFeHBlY3RlZCBzZXJ2ZXIgSFRNTCB0byBjb250YWluIGEgbWF0Y2hpbmcgPCVzPiBpbiA8JXM+LicsIHRhZywgcGFyZW50Tm9kZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpKTtcbiAgfVxufVxuZnVuY3Rpb24gd2FybkZvckluc2VydGVkSHlkcmF0ZWRUZXh0KHBhcmVudE5vZGUsIHRleHQpIHtcbiAge1xuICAgIGlmICh0ZXh0ID09PSAnJykge1xuICAgICAgLy8gV2UgZXhwZWN0IHRvIGluc2VydCBlbXB0eSB0ZXh0IG5vZGVzIHNpbmNlIHRoZXkncmUgbm90IHJlcHJlc2VudGVkIGluXG4gICAgICAvLyB0aGUgSFRNTC5cbiAgICAgIC8vIFRPRE86IFJlbW92ZSB0aGlzIHNwZWNpYWwgY2FzZSBpZiB3ZSBjYW4ganVzdCBhdm9pZCBpbnNlcnRpbmcgZW1wdHlcbiAgICAgIC8vIHRleHQgbm9kZXMuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGRpZFdhcm5JbnZhbGlkSHlkcmF0aW9uKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZGlkV2FybkludmFsaWRIeWRyYXRpb24gPSB0cnVlO1xuXG4gICAgZXJyb3IoJ0V4cGVjdGVkIHNlcnZlciBIVE1MIHRvIGNvbnRhaW4gYSBtYXRjaGluZyB0ZXh0IG5vZGUgZm9yIFwiJXNcIiBpbiA8JXM+LicsIHRleHQsIHBhcmVudE5vZGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKSk7XG4gIH1cbn1cbmZ1bmN0aW9uIHJlc3RvcmVDb250cm9sbGVkU3RhdGUkMyhkb21FbGVtZW50LCB0YWcsIHByb3BzKSB7XG4gIHN3aXRjaCAodGFnKSB7XG4gICAgY2FzZSAnaW5wdXQnOlxuICAgICAgcmVzdG9yZUNvbnRyb2xsZWRTdGF0ZShkb21FbGVtZW50LCBwcm9wcyk7XG4gICAgICByZXR1cm47XG5cbiAgICBjYXNlICd0ZXh0YXJlYSc6XG4gICAgICByZXN0b3JlQ29udHJvbGxlZFN0YXRlJDIoZG9tRWxlbWVudCwgcHJvcHMpO1xuICAgICAgcmV0dXJuO1xuXG4gICAgY2FzZSAnc2VsZWN0JzpcbiAgICAgIHJlc3RvcmVDb250cm9sbGVkU3RhdGUkMShkb21FbGVtZW50LCBwcm9wcyk7XG4gICAgICByZXR1cm47XG4gIH1cbn1cblxudmFyIHZhbGlkYXRlRE9NTmVzdGluZyA9IGZ1bmN0aW9uICgpIHt9O1xuXG52YXIgdXBkYXRlZEFuY2VzdG9ySW5mbyA9IGZ1bmN0aW9uICgpIHt9O1xuXG57XG4gIC8vIFRoaXMgdmFsaWRhdGlvbiBjb2RlIHdhcyB3cml0dGVuIGJhc2VkIG9uIHRoZSBIVE1MNSBwYXJzaW5nIHNwZWM6XG4gIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI2hhcy1hbi1lbGVtZW50LWluLXNjb3BlXG4gIC8vXG4gIC8vIE5vdGU6IHRoaXMgZG9lcyBub3QgY2F0Y2ggYWxsIGludmFsaWQgbmVzdGluZywgbm9yIGRvZXMgaXQgdHJ5IHRvIChhcyBpdCdzXG4gIC8vIG5vdCBjbGVhciB3aGF0IHByYWN0aWNhbCBiZW5lZml0IGRvaW5nIHNvIHByb3ZpZGVzKTsgaW5zdGVhZCwgd2Ugd2FybiBvbmx5XG4gIC8vIGZvciBjYXNlcyB3aGVyZSB0aGUgcGFyc2VyIHdpbGwgZ2l2ZSBhIHBhcnNlIHRyZWUgZGlmZmVyaW5nIGZyb20gd2hhdCBSZWFjdFxuICAvLyBpbnRlbmRlZC4gRm9yIGV4YW1wbGUsIDxiPjxkaXY+PC9kaXY+PC9iPiBpcyBpbnZhbGlkIGJ1dCB3ZSBkb24ndCB3YXJuXG4gIC8vIGJlY2F1c2UgaXQgc3RpbGwgcGFyc2VzIGNvcnJlY3RseTsgd2UgZG8gd2FybiBmb3Igb3RoZXIgY2FzZXMgbGlrZSBuZXN0ZWRcbiAgLy8gPHA+IHRhZ3Mgd2hlcmUgdGhlIGJlZ2lubmluZyBvZiB0aGUgc2Vjb25kIGVsZW1lbnQgaW1wbGljaXRseSBjbG9zZXMgdGhlXG4gIC8vIGZpcnN0LCBjYXVzaW5nIGEgY29uZnVzaW5nIG1lc3MuXG4gIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI3NwZWNpYWxcbiAgdmFyIHNwZWNpYWxUYWdzID0gWydhZGRyZXNzJywgJ2FwcGxldCcsICdhcmVhJywgJ2FydGljbGUnLCAnYXNpZGUnLCAnYmFzZScsICdiYXNlZm9udCcsICdiZ3NvdW5kJywgJ2Jsb2NrcXVvdGUnLCAnYm9keScsICdicicsICdidXR0b24nLCAnY2FwdGlvbicsICdjZW50ZXInLCAnY29sJywgJ2NvbGdyb3VwJywgJ2RkJywgJ2RldGFpbHMnLCAnZGlyJywgJ2RpdicsICdkbCcsICdkdCcsICdlbWJlZCcsICdmaWVsZHNldCcsICdmaWdjYXB0aW9uJywgJ2ZpZ3VyZScsICdmb290ZXInLCAnZm9ybScsICdmcmFtZScsICdmcmFtZXNldCcsICdoMScsICdoMicsICdoMycsICdoNCcsICdoNScsICdoNicsICdoZWFkJywgJ2hlYWRlcicsICdoZ3JvdXAnLCAnaHInLCAnaHRtbCcsICdpZnJhbWUnLCAnaW1nJywgJ2lucHV0JywgJ2lzaW5kZXgnLCAnbGknLCAnbGluaycsICdsaXN0aW5nJywgJ21haW4nLCAnbWFycXVlZScsICdtZW51JywgJ21lbnVpdGVtJywgJ21ldGEnLCAnbmF2JywgJ25vZW1iZWQnLCAnbm9mcmFtZXMnLCAnbm9zY3JpcHQnLCAnb2JqZWN0JywgJ29sJywgJ3AnLCAncGFyYW0nLCAncGxhaW50ZXh0JywgJ3ByZScsICdzY3JpcHQnLCAnc2VjdGlvbicsICdzZWxlY3QnLCAnc291cmNlJywgJ3N0eWxlJywgJ3N1bW1hcnknLCAndGFibGUnLCAndGJvZHknLCAndGQnLCAndGVtcGxhdGUnLCAndGV4dGFyZWEnLCAndGZvb3QnLCAndGgnLCAndGhlYWQnLCAndGl0bGUnLCAndHInLCAndHJhY2snLCAndWwnLCAnd2JyJywgJ3htcCddOyAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNoYXMtYW4tZWxlbWVudC1pbi1zY29wZVxuXG4gIHZhciBpblNjb3BlVGFncyA9IFsnYXBwbGV0JywgJ2NhcHRpb24nLCAnaHRtbCcsICd0YWJsZScsICd0ZCcsICd0aCcsICdtYXJxdWVlJywgJ29iamVjdCcsICd0ZW1wbGF0ZScsIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI2h0bWwtaW50ZWdyYXRpb24tcG9pbnRcbiAgLy8gVE9ETzogRGlzdGluZ3Vpc2ggYnkgbmFtZXNwYWNlIGhlcmUgLS0gZm9yIDx0aXRsZT4sIGluY2x1ZGluZyBpdCBoZXJlXG4gIC8vIGVycnMgb24gdGhlIHNpZGUgb2YgZmV3ZXIgd2FybmluZ3NcbiAgJ2ZvcmVpZ25PYmplY3QnLCAnZGVzYycsICd0aXRsZSddOyAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNoYXMtYW4tZWxlbWVudC1pbi1idXR0b24tc2NvcGVcblxuICB2YXIgYnV0dG9uU2NvcGVUYWdzID0gaW5TY29wZVRhZ3MuY29uY2F0KFsnYnV0dG9uJ10pOyAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNnZW5lcmF0ZS1pbXBsaWVkLWVuZC10YWdzXG5cbiAgdmFyIGltcGxpZWRFbmRUYWdzID0gWydkZCcsICdkdCcsICdsaScsICdvcHRpb24nLCAnb3B0Z3JvdXAnLCAncCcsICdycCcsICdydCddO1xuICB2YXIgZW1wdHlBbmNlc3RvckluZm8gPSB7XG4gICAgY3VycmVudDogbnVsbCxcbiAgICBmb3JtVGFnOiBudWxsLFxuICAgIGFUYWdJblNjb3BlOiBudWxsLFxuICAgIGJ1dHRvblRhZ0luU2NvcGU6IG51bGwsXG4gICAgbm9iclRhZ0luU2NvcGU6IG51bGwsXG4gICAgcFRhZ0luQnV0dG9uU2NvcGU6IG51bGwsXG4gICAgbGlzdEl0ZW1UYWdBdXRvY2xvc2luZzogbnVsbCxcbiAgICBkbEl0ZW1UYWdBdXRvY2xvc2luZzogbnVsbFxuICB9O1xuXG4gIHVwZGF0ZWRBbmNlc3RvckluZm8gPSBmdW5jdGlvbiAob2xkSW5mbywgdGFnKSB7XG4gICAgdmFyIGFuY2VzdG9ySW5mbyA9IF9hc3NpZ24oe30sIG9sZEluZm8gfHwgZW1wdHlBbmNlc3RvckluZm8pO1xuXG4gICAgdmFyIGluZm8gPSB7XG4gICAgICB0YWc6IHRhZ1xuICAgIH07XG5cbiAgICBpZiAoaW5TY29wZVRhZ3MuaW5kZXhPZih0YWcpICE9PSAtMSkge1xuICAgICAgYW5jZXN0b3JJbmZvLmFUYWdJblNjb3BlID0gbnVsbDtcbiAgICAgIGFuY2VzdG9ySW5mby5idXR0b25UYWdJblNjb3BlID0gbnVsbDtcbiAgICAgIGFuY2VzdG9ySW5mby5ub2JyVGFnSW5TY29wZSA9IG51bGw7XG4gICAgfVxuXG4gICAgaWYgKGJ1dHRvblNjb3BlVGFncy5pbmRleE9mKHRhZykgIT09IC0xKSB7XG4gICAgICBhbmNlc3RvckluZm8ucFRhZ0luQnV0dG9uU2NvcGUgPSBudWxsO1xuICAgIH0gLy8gU2VlIHJ1bGVzIGZvciAnbGknLCAnZGQnLCAnZHQnIHN0YXJ0IHRhZ3MgaW5cbiAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNwYXJzaW5nLW1haW4taW5ib2R5XG5cblxuICAgIGlmIChzcGVjaWFsVGFncy5pbmRleE9mKHRhZykgIT09IC0xICYmIHRhZyAhPT0gJ2FkZHJlc3MnICYmIHRhZyAhPT0gJ2RpdicgJiYgdGFnICE9PSAncCcpIHtcbiAgICAgIGFuY2VzdG9ySW5mby5saXN0SXRlbVRhZ0F1dG9jbG9zaW5nID0gbnVsbDtcbiAgICAgIGFuY2VzdG9ySW5mby5kbEl0ZW1UYWdBdXRvY2xvc2luZyA9IG51bGw7XG4gICAgfVxuXG4gICAgYW5jZXN0b3JJbmZvLmN1cnJlbnQgPSBpbmZvO1xuXG4gICAgaWYgKHRhZyA9PT0gJ2Zvcm0nKSB7XG4gICAgICBhbmNlc3RvckluZm8uZm9ybVRhZyA9IGluZm87XG4gICAgfVxuXG4gICAgaWYgKHRhZyA9PT0gJ2EnKSB7XG4gICAgICBhbmNlc3RvckluZm8uYVRhZ0luU2NvcGUgPSBpbmZvO1xuICAgIH1cblxuICAgIGlmICh0YWcgPT09ICdidXR0b24nKSB7XG4gICAgICBhbmNlc3RvckluZm8uYnV0dG9uVGFnSW5TY29wZSA9IGluZm87XG4gICAgfVxuXG4gICAgaWYgKHRhZyA9PT0gJ25vYnInKSB7XG4gICAgICBhbmNlc3RvckluZm8ubm9iclRhZ0luU2NvcGUgPSBpbmZvO1xuICAgIH1cblxuICAgIGlmICh0YWcgPT09ICdwJykge1xuICAgICAgYW5jZXN0b3JJbmZvLnBUYWdJbkJ1dHRvblNjb3BlID0gaW5mbztcbiAgICB9XG5cbiAgICBpZiAodGFnID09PSAnbGknKSB7XG4gICAgICBhbmNlc3RvckluZm8ubGlzdEl0ZW1UYWdBdXRvY2xvc2luZyA9IGluZm87XG4gICAgfVxuXG4gICAgaWYgKHRhZyA9PT0gJ2RkJyB8fCB0YWcgPT09ICdkdCcpIHtcbiAgICAgIGFuY2VzdG9ySW5mby5kbEl0ZW1UYWdBdXRvY2xvc2luZyA9IGluZm87XG4gICAgfVxuXG4gICAgcmV0dXJuIGFuY2VzdG9ySW5mbztcbiAgfTtcbiAgLyoqXG4gICAqIFJldHVybnMgd2hldGhlclxuICAgKi9cblxuXG4gIHZhciBpc1RhZ1ZhbGlkV2l0aFBhcmVudCA9IGZ1bmN0aW9uICh0YWcsIHBhcmVudFRhZykge1xuICAgIC8vIEZpcnN0LCBsZXQncyBjaGVjayBpZiB3ZSdyZSBpbiBhbiB1bnVzdWFsIHBhcnNpbmcgbW9kZS4uLlxuICAgIHN3aXRjaCAocGFyZW50VGFnKSB7XG4gICAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNwYXJzaW5nLW1haW4taW5zZWxlY3RcbiAgICAgIGNhc2UgJ3NlbGVjdCc6XG4gICAgICAgIHJldHVybiB0YWcgPT09ICdvcHRpb24nIHx8IHRhZyA9PT0gJ29wdGdyb3VwJyB8fCB0YWcgPT09ICcjdGV4dCc7XG5cbiAgICAgIGNhc2UgJ29wdGdyb3VwJzpcbiAgICAgICAgcmV0dXJuIHRhZyA9PT0gJ29wdGlvbicgfHwgdGFnID09PSAnI3RleHQnO1xuICAgICAgLy8gU3RyaWN0bHkgc3BlYWtpbmcsIHNlZWluZyBhbiA8b3B0aW9uPiBkb2Vzbid0IG1lYW4gd2UncmUgaW4gYSA8c2VsZWN0PlxuICAgICAgLy8gYnV0XG5cbiAgICAgIGNhc2UgJ29wdGlvbic6XG4gICAgICAgIHJldHVybiB0YWcgPT09ICcjdGV4dCc7XG4gICAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNwYXJzaW5nLW1haW4taW50ZFxuICAgICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjcGFyc2luZy1tYWluLWluY2FwdGlvblxuICAgICAgLy8gTm8gc3BlY2lhbCBiZWhhdmlvciBzaW5jZSB0aGVzZSBydWxlcyBmYWxsIGJhY2sgdG8gXCJpbiBib2R5XCIgbW9kZSBmb3JcbiAgICAgIC8vIGFsbCBleGNlcHQgc3BlY2lhbCB0YWJsZSBub2RlcyB3aGljaCBjYXVzZSBiYWQgcGFyc2luZyBiZWhhdmlvciBhbnl3YXkuXG4gICAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNwYXJzaW5nLW1haW4taW50clxuXG4gICAgICBjYXNlICd0cic6XG4gICAgICAgIHJldHVybiB0YWcgPT09ICd0aCcgfHwgdGFnID09PSAndGQnIHx8IHRhZyA9PT0gJ3N0eWxlJyB8fCB0YWcgPT09ICdzY3JpcHQnIHx8IHRhZyA9PT0gJ3RlbXBsYXRlJztcbiAgICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI3BhcnNpbmctbWFpbi1pbnRib2R5XG5cbiAgICAgIGNhc2UgJ3Rib2R5JzpcbiAgICAgIGNhc2UgJ3RoZWFkJzpcbiAgICAgIGNhc2UgJ3Rmb290JzpcbiAgICAgICAgcmV0dXJuIHRhZyA9PT0gJ3RyJyB8fCB0YWcgPT09ICdzdHlsZScgfHwgdGFnID09PSAnc2NyaXB0JyB8fCB0YWcgPT09ICd0ZW1wbGF0ZSc7XG4gICAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNwYXJzaW5nLW1haW4taW5jb2xncm91cFxuXG4gICAgICBjYXNlICdjb2xncm91cCc6XG4gICAgICAgIHJldHVybiB0YWcgPT09ICdjb2wnIHx8IHRhZyA9PT0gJ3RlbXBsYXRlJztcbiAgICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI3BhcnNpbmctbWFpbi1pbnRhYmxlXG5cbiAgICAgIGNhc2UgJ3RhYmxlJzpcbiAgICAgICAgcmV0dXJuIHRhZyA9PT0gJ2NhcHRpb24nIHx8IHRhZyA9PT0gJ2NvbGdyb3VwJyB8fCB0YWcgPT09ICd0Ym9keScgfHwgdGFnID09PSAndGZvb3QnIHx8IHRhZyA9PT0gJ3RoZWFkJyB8fCB0YWcgPT09ICdzdHlsZScgfHwgdGFnID09PSAnc2NyaXB0JyB8fCB0YWcgPT09ICd0ZW1wbGF0ZSc7XG4gICAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNwYXJzaW5nLW1haW4taW5oZWFkXG5cbiAgICAgIGNhc2UgJ2hlYWQnOlxuICAgICAgICByZXR1cm4gdGFnID09PSAnYmFzZScgfHwgdGFnID09PSAnYmFzZWZvbnQnIHx8IHRhZyA9PT0gJ2Jnc291bmQnIHx8IHRhZyA9PT0gJ2xpbmsnIHx8IHRhZyA9PT0gJ21ldGEnIHx8IHRhZyA9PT0gJ3RpdGxlJyB8fCB0YWcgPT09ICdub3NjcmlwdCcgfHwgdGFnID09PSAnbm9mcmFtZXMnIHx8IHRhZyA9PT0gJ3N0eWxlJyB8fCB0YWcgPT09ICdzY3JpcHQnIHx8IHRhZyA9PT0gJ3RlbXBsYXRlJztcbiAgICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3NlbWFudGljcy5odG1sI3RoZS1odG1sLWVsZW1lbnRcblxuICAgICAgY2FzZSAnaHRtbCc6XG4gICAgICAgIHJldHVybiB0YWcgPT09ICdoZWFkJyB8fCB0YWcgPT09ICdib2R5JyB8fCB0YWcgPT09ICdmcmFtZXNldCc7XG5cbiAgICAgIGNhc2UgJ2ZyYW1lc2V0JzpcbiAgICAgICAgcmV0dXJuIHRhZyA9PT0gJ2ZyYW1lJztcblxuICAgICAgY2FzZSAnI2RvY3VtZW50JzpcbiAgICAgICAgcmV0dXJuIHRhZyA9PT0gJ2h0bWwnO1xuICAgIH0gLy8gUHJvYmFibHkgaW4gdGhlIFwiaW4gYm9keVwiIHBhcnNpbmcgbW9kZSwgc28gd2Ugb3V0bGF3IG9ubHkgdGFnIGNvbWJvc1xuICAgIC8vIHdoZXJlIHRoZSBwYXJzaW5nIHJ1bGVzIGNhdXNlIGltcGxpY2l0IG9wZW5zIG9yIGNsb3NlcyB0byBiZSBhZGRlZC5cbiAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNwYXJzaW5nLW1haW4taW5ib2R5XG5cblxuICAgIHN3aXRjaCAodGFnKSB7XG4gICAgICBjYXNlICdoMSc6XG4gICAgICBjYXNlICdoMic6XG4gICAgICBjYXNlICdoMyc6XG4gICAgICBjYXNlICdoNCc6XG4gICAgICBjYXNlICdoNSc6XG4gICAgICBjYXNlICdoNic6XG4gICAgICAgIHJldHVybiBwYXJlbnRUYWcgIT09ICdoMScgJiYgcGFyZW50VGFnICE9PSAnaDInICYmIHBhcmVudFRhZyAhPT0gJ2gzJyAmJiBwYXJlbnRUYWcgIT09ICdoNCcgJiYgcGFyZW50VGFnICE9PSAnaDUnICYmIHBhcmVudFRhZyAhPT0gJ2g2JztcblxuICAgICAgY2FzZSAncnAnOlxuICAgICAgY2FzZSAncnQnOlxuICAgICAgICByZXR1cm4gaW1wbGllZEVuZFRhZ3MuaW5kZXhPZihwYXJlbnRUYWcpID09PSAtMTtcblxuICAgICAgY2FzZSAnYm9keSc6XG4gICAgICBjYXNlICdjYXB0aW9uJzpcbiAgICAgIGNhc2UgJ2NvbCc6XG4gICAgICBjYXNlICdjb2xncm91cCc6XG4gICAgICBjYXNlICdmcmFtZXNldCc6XG4gICAgICBjYXNlICdmcmFtZSc6XG4gICAgICBjYXNlICdoZWFkJzpcbiAgICAgIGNhc2UgJ2h0bWwnOlxuICAgICAgY2FzZSAndGJvZHknOlxuICAgICAgY2FzZSAndGQnOlxuICAgICAgY2FzZSAndGZvb3QnOlxuICAgICAgY2FzZSAndGgnOlxuICAgICAgY2FzZSAndGhlYWQnOlxuICAgICAgY2FzZSAndHInOlxuICAgICAgICAvLyBUaGVzZSB0YWdzIGFyZSBvbmx5IHZhbGlkIHdpdGggYSBmZXcgcGFyZW50cyB0aGF0IGhhdmUgc3BlY2lhbCBjaGlsZFxuICAgICAgICAvLyBwYXJzaW5nIHJ1bGVzIC0tIGlmIHdlJ3JlIGRvd24gaGVyZSwgdGhlbiBub25lIG9mIHRob3NlIG1hdGNoZWQgYW5kXG4gICAgICAgIC8vIHNvIHdlIGFsbG93IGl0IG9ubHkgaWYgd2UgZG9uJ3Qga25vdyB3aGF0IHRoZSBwYXJlbnQgaXMsIGFzIGFsbCBvdGhlclxuICAgICAgICAvLyBjYXNlcyBhcmUgaW52YWxpZC5cbiAgICAgICAgcmV0dXJuIHBhcmVudFRhZyA9PSBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9O1xuICAvKipcbiAgICogUmV0dXJucyB3aGV0aGVyXG4gICAqL1xuXG5cbiAgdmFyIGZpbmRJbnZhbGlkQW5jZXN0b3JGb3JUYWcgPSBmdW5jdGlvbiAodGFnLCBhbmNlc3RvckluZm8pIHtcbiAgICBzd2l0Y2ggKHRhZykge1xuICAgICAgY2FzZSAnYWRkcmVzcyc6XG4gICAgICBjYXNlICdhcnRpY2xlJzpcbiAgICAgIGNhc2UgJ2FzaWRlJzpcbiAgICAgIGNhc2UgJ2Jsb2NrcXVvdGUnOlxuICAgICAgY2FzZSAnY2VudGVyJzpcbiAgICAgIGNhc2UgJ2RldGFpbHMnOlxuICAgICAgY2FzZSAnZGlhbG9nJzpcbiAgICAgIGNhc2UgJ2Rpcic6XG4gICAgICBjYXNlICdkaXYnOlxuICAgICAgY2FzZSAnZGwnOlxuICAgICAgY2FzZSAnZmllbGRzZXQnOlxuICAgICAgY2FzZSAnZmlnY2FwdGlvbic6XG4gICAgICBjYXNlICdmaWd1cmUnOlxuICAgICAgY2FzZSAnZm9vdGVyJzpcbiAgICAgIGNhc2UgJ2hlYWRlcic6XG4gICAgICBjYXNlICdoZ3JvdXAnOlxuICAgICAgY2FzZSAnbWFpbic6XG4gICAgICBjYXNlICdtZW51JzpcbiAgICAgIGNhc2UgJ25hdic6XG4gICAgICBjYXNlICdvbCc6XG4gICAgICBjYXNlICdwJzpcbiAgICAgIGNhc2UgJ3NlY3Rpb24nOlxuICAgICAgY2FzZSAnc3VtbWFyeSc6XG4gICAgICBjYXNlICd1bCc6XG4gICAgICBjYXNlICdwcmUnOlxuICAgICAgY2FzZSAnbGlzdGluZyc6XG4gICAgICBjYXNlICd0YWJsZSc6XG4gICAgICBjYXNlICdocic6XG4gICAgICBjYXNlICd4bXAnOlxuICAgICAgY2FzZSAnaDEnOlxuICAgICAgY2FzZSAnaDInOlxuICAgICAgY2FzZSAnaDMnOlxuICAgICAgY2FzZSAnaDQnOlxuICAgICAgY2FzZSAnaDUnOlxuICAgICAgY2FzZSAnaDYnOlxuICAgICAgICByZXR1cm4gYW5jZXN0b3JJbmZvLnBUYWdJbkJ1dHRvblNjb3BlO1xuXG4gICAgICBjYXNlICdmb3JtJzpcbiAgICAgICAgcmV0dXJuIGFuY2VzdG9ySW5mby5mb3JtVGFnIHx8IGFuY2VzdG9ySW5mby5wVGFnSW5CdXR0b25TY29wZTtcblxuICAgICAgY2FzZSAnbGknOlxuICAgICAgICByZXR1cm4gYW5jZXN0b3JJbmZvLmxpc3RJdGVtVGFnQXV0b2Nsb3Npbmc7XG5cbiAgICAgIGNhc2UgJ2RkJzpcbiAgICAgIGNhc2UgJ2R0JzpcbiAgICAgICAgcmV0dXJuIGFuY2VzdG9ySW5mby5kbEl0ZW1UYWdBdXRvY2xvc2luZztcblxuICAgICAgY2FzZSAnYnV0dG9uJzpcbiAgICAgICAgcmV0dXJuIGFuY2VzdG9ySW5mby5idXR0b25UYWdJblNjb3BlO1xuXG4gICAgICBjYXNlICdhJzpcbiAgICAgICAgLy8gU3BlYyBzYXlzIHNvbWV0aGluZyBhYm91dCBzdG9yaW5nIGEgbGlzdCBvZiBtYXJrZXJzLCBidXQgaXQgc291bmRzXG4gICAgICAgIC8vIGVxdWl2YWxlbnQgdG8gdGhpcyBjaGVjay5cbiAgICAgICAgcmV0dXJuIGFuY2VzdG9ySW5mby5hVGFnSW5TY29wZTtcblxuICAgICAgY2FzZSAnbm9icic6XG4gICAgICAgIHJldHVybiBhbmNlc3RvckluZm8ubm9iclRhZ0luU2NvcGU7XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH07XG5cbiAgdmFyIGRpZFdhcm4kMSA9IHt9O1xuXG4gIHZhbGlkYXRlRE9NTmVzdGluZyA9IGZ1bmN0aW9uIChjaGlsZFRhZywgY2hpbGRUZXh0LCBhbmNlc3RvckluZm8pIHtcbiAgICBhbmNlc3RvckluZm8gPSBhbmNlc3RvckluZm8gfHwgZW1wdHlBbmNlc3RvckluZm87XG4gICAgdmFyIHBhcmVudEluZm8gPSBhbmNlc3RvckluZm8uY3VycmVudDtcbiAgICB2YXIgcGFyZW50VGFnID0gcGFyZW50SW5mbyAmJiBwYXJlbnRJbmZvLnRhZztcblxuICAgIGlmIChjaGlsZFRleHQgIT0gbnVsbCkge1xuICAgICAgaWYgKGNoaWxkVGFnICE9IG51bGwpIHtcbiAgICAgICAgZXJyb3IoJ3ZhbGlkYXRlRE9NTmVzdGluZzogd2hlbiBjaGlsZFRleHQgaXMgcGFzc2VkLCBjaGlsZFRhZyBzaG91bGQgYmUgbnVsbCcpO1xuICAgICAgfVxuXG4gICAgICBjaGlsZFRhZyA9ICcjdGV4dCc7XG4gICAgfVxuXG4gICAgdmFyIGludmFsaWRQYXJlbnQgPSBpc1RhZ1ZhbGlkV2l0aFBhcmVudChjaGlsZFRhZywgcGFyZW50VGFnKSA/IG51bGwgOiBwYXJlbnRJbmZvO1xuICAgIHZhciBpbnZhbGlkQW5jZXN0b3IgPSBpbnZhbGlkUGFyZW50ID8gbnVsbCA6IGZpbmRJbnZhbGlkQW5jZXN0b3JGb3JUYWcoY2hpbGRUYWcsIGFuY2VzdG9ySW5mbyk7XG4gICAgdmFyIGludmFsaWRQYXJlbnRPckFuY2VzdG9yID0gaW52YWxpZFBhcmVudCB8fCBpbnZhbGlkQW5jZXN0b3I7XG5cbiAgICBpZiAoIWludmFsaWRQYXJlbnRPckFuY2VzdG9yKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGFuY2VzdG9yVGFnID0gaW52YWxpZFBhcmVudE9yQW5jZXN0b3IudGFnO1xuICAgIHZhciB3YXJuS2V5ID0gISFpbnZhbGlkUGFyZW50ICsgJ3wnICsgY2hpbGRUYWcgKyAnfCcgKyBhbmNlc3RvclRhZztcblxuICAgIGlmIChkaWRXYXJuJDFbd2FybktleV0pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBkaWRXYXJuJDFbd2FybktleV0gPSB0cnVlO1xuICAgIHZhciB0YWdEaXNwbGF5TmFtZSA9IGNoaWxkVGFnO1xuICAgIHZhciB3aGl0ZXNwYWNlSW5mbyA9ICcnO1xuXG4gICAgaWYgKGNoaWxkVGFnID09PSAnI3RleHQnKSB7XG4gICAgICBpZiAoL1xcUy8udGVzdChjaGlsZFRleHQpKSB7XG4gICAgICAgIHRhZ0Rpc3BsYXlOYW1lID0gJ1RleHQgbm9kZXMnO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGFnRGlzcGxheU5hbWUgPSAnV2hpdGVzcGFjZSB0ZXh0IG5vZGVzJztcbiAgICAgICAgd2hpdGVzcGFjZUluZm8gPSBcIiBNYWtlIHN1cmUgeW91IGRvbid0IGhhdmUgYW55IGV4dHJhIHdoaXRlc3BhY2UgYmV0d2VlbiB0YWdzIG9uIFwiICsgJ2VhY2ggbGluZSBvZiB5b3VyIHNvdXJjZSBjb2RlLic7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRhZ0Rpc3BsYXlOYW1lID0gJzwnICsgY2hpbGRUYWcgKyAnPic7XG4gICAgfVxuXG4gICAgaWYgKGludmFsaWRQYXJlbnQpIHtcbiAgICAgIHZhciBpbmZvID0gJyc7XG5cbiAgICAgIGlmIChhbmNlc3RvclRhZyA9PT0gJ3RhYmxlJyAmJiBjaGlsZFRhZyA9PT0gJ3RyJykge1xuICAgICAgICBpbmZvICs9ICcgQWRkIGEgPHRib2R5PiwgPHRoZWFkPiBvciA8dGZvb3Q+IHRvIHlvdXIgY29kZSB0byBtYXRjaCB0aGUgRE9NIHRyZWUgZ2VuZXJhdGVkIGJ5ICcgKyAndGhlIGJyb3dzZXIuJztcbiAgICAgIH1cblxuICAgICAgZXJyb3IoJ3ZhbGlkYXRlRE9NTmVzdGluZyguLi4pOiAlcyBjYW5ub3QgYXBwZWFyIGFzIGEgY2hpbGQgb2YgPCVzPi4lcyVzJywgdGFnRGlzcGxheU5hbWUsIGFuY2VzdG9yVGFnLCB3aGl0ZXNwYWNlSW5mbywgaW5mbyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVycm9yKCd2YWxpZGF0ZURPTU5lc3RpbmcoLi4uKTogJXMgY2Fubm90IGFwcGVhciBhcyBhIGRlc2NlbmRhbnQgb2YgJyArICc8JXM+LicsIHRhZ0Rpc3BsYXlOYW1lLCBhbmNlc3RvclRhZyk7XG4gICAgfVxuICB9O1xufVxuXG52YXIgU1VQUFJFU1NfSFlEUkFUSU9OX1dBUk5JTkckMTtcblxue1xuICBTVVBQUkVTU19IWURSQVRJT05fV0FSTklORyQxID0gJ3N1cHByZXNzSHlkcmF0aW9uV2FybmluZyc7XG59XG5cbnZhciBTVVNQRU5TRV9TVEFSVF9EQVRBID0gJyQnO1xudmFyIFNVU1BFTlNFX0VORF9EQVRBID0gJy8kJztcbnZhciBTVVNQRU5TRV9QRU5ESU5HX1NUQVJUX0RBVEEgPSAnJD8nO1xudmFyIFNVU1BFTlNFX0ZBTExCQUNLX1NUQVJUX0RBVEEgPSAnJCEnO1xudmFyIFNUWUxFJDEgPSAnc3R5bGUnO1xudmFyIGV2ZW50c0VuYWJsZWQgPSBudWxsO1xudmFyIHNlbGVjdGlvbkluZm9ybWF0aW9uID0gbnVsbDtcblxuZnVuY3Rpb24gc2hvdWxkQXV0b0ZvY3VzSG9zdENvbXBvbmVudCh0eXBlLCBwcm9wcykge1xuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlICdidXR0b24nOlxuICAgIGNhc2UgJ2lucHV0JzpcbiAgICBjYXNlICdzZWxlY3QnOlxuICAgIGNhc2UgJ3RleHRhcmVhJzpcbiAgICAgIHJldHVybiAhIXByb3BzLmF1dG9Gb2N1cztcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGdldFJvb3RIb3N0Q29udGV4dChyb290Q29udGFpbmVySW5zdGFuY2UpIHtcbiAgdmFyIHR5cGU7XG4gIHZhciBuYW1lc3BhY2U7XG4gIHZhciBub2RlVHlwZSA9IHJvb3RDb250YWluZXJJbnN0YW5jZS5ub2RlVHlwZTtcblxuICBzd2l0Y2ggKG5vZGVUeXBlKSB7XG4gICAgY2FzZSBET0NVTUVOVF9OT0RFOlxuICAgIGNhc2UgRE9DVU1FTlRfRlJBR01FTlRfTk9ERTpcbiAgICAgIHtcbiAgICAgICAgdHlwZSA9IG5vZGVUeXBlID09PSBET0NVTUVOVF9OT0RFID8gJyNkb2N1bWVudCcgOiAnI2ZyYWdtZW50JztcbiAgICAgICAgdmFyIHJvb3QgPSByb290Q29udGFpbmVySW5zdGFuY2UuZG9jdW1lbnRFbGVtZW50O1xuICAgICAgICBuYW1lc3BhY2UgPSByb290ID8gcm9vdC5uYW1lc3BhY2VVUkkgOiBnZXRDaGlsZE5hbWVzcGFjZShudWxsLCAnJyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgZGVmYXVsdDpcbiAgICAgIHtcbiAgICAgICAgdmFyIGNvbnRhaW5lciA9IG5vZGVUeXBlID09PSBDT01NRU5UX05PREUgPyByb290Q29udGFpbmVySW5zdGFuY2UucGFyZW50Tm9kZSA6IHJvb3RDb250YWluZXJJbnN0YW5jZTtcbiAgICAgICAgdmFyIG93bk5hbWVzcGFjZSA9IGNvbnRhaW5lci5uYW1lc3BhY2VVUkkgfHwgbnVsbDtcbiAgICAgICAgdHlwZSA9IGNvbnRhaW5lci50YWdOYW1lO1xuICAgICAgICBuYW1lc3BhY2UgPSBnZXRDaGlsZE5hbWVzcGFjZShvd25OYW1lc3BhY2UsIHR5cGUpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgfVxuXG4gIHtcbiAgICB2YXIgdmFsaWRhdGVkVGFnID0gdHlwZS50b0xvd2VyQ2FzZSgpO1xuICAgIHZhciBhbmNlc3RvckluZm8gPSB1cGRhdGVkQW5jZXN0b3JJbmZvKG51bGwsIHZhbGlkYXRlZFRhZyk7XG4gICAgcmV0dXJuIHtcbiAgICAgIG5hbWVzcGFjZTogbmFtZXNwYWNlLFxuICAgICAgYW5jZXN0b3JJbmZvOiBhbmNlc3RvckluZm9cbiAgICB9O1xuICB9XG59XG5mdW5jdGlvbiBnZXRDaGlsZEhvc3RDb250ZXh0KHBhcmVudEhvc3RDb250ZXh0LCB0eXBlLCByb290Q29udGFpbmVySW5zdGFuY2UpIHtcbiAge1xuICAgIHZhciBwYXJlbnRIb3N0Q29udGV4dERldiA9IHBhcmVudEhvc3RDb250ZXh0O1xuICAgIHZhciBuYW1lc3BhY2UgPSBnZXRDaGlsZE5hbWVzcGFjZShwYXJlbnRIb3N0Q29udGV4dERldi5uYW1lc3BhY2UsIHR5cGUpO1xuICAgIHZhciBhbmNlc3RvckluZm8gPSB1cGRhdGVkQW5jZXN0b3JJbmZvKHBhcmVudEhvc3RDb250ZXh0RGV2LmFuY2VzdG9ySW5mbywgdHlwZSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIG5hbWVzcGFjZTogbmFtZXNwYWNlLFxuICAgICAgYW5jZXN0b3JJbmZvOiBhbmNlc3RvckluZm9cbiAgICB9O1xuICB9XG59XG5mdW5jdGlvbiBnZXRQdWJsaWNJbnN0YW5jZShpbnN0YW5jZSkge1xuICByZXR1cm4gaW5zdGFuY2U7XG59XG5mdW5jdGlvbiBwcmVwYXJlRm9yQ29tbWl0KGNvbnRhaW5lckluZm8pIHtcbiAgZXZlbnRzRW5hYmxlZCA9IGlzRW5hYmxlZCgpO1xuICBzZWxlY3Rpb25JbmZvcm1hdGlvbiA9IGdldFNlbGVjdGlvbkluZm9ybWF0aW9uKCk7XG4gIHZhciBhY3RpdmVJbnN0YW5jZSA9IG51bGw7XG5cbiAgc2V0RW5hYmxlZChmYWxzZSk7XG4gIHJldHVybiBhY3RpdmVJbnN0YW5jZTtcbn1cbmZ1bmN0aW9uIHJlc2V0QWZ0ZXJDb21taXQoY29udGFpbmVySW5mbykge1xuICByZXN0b3JlU2VsZWN0aW9uKHNlbGVjdGlvbkluZm9ybWF0aW9uKTtcbiAgc2V0RW5hYmxlZChldmVudHNFbmFibGVkKTtcbiAgZXZlbnRzRW5hYmxlZCA9IG51bGw7XG4gIHNlbGVjdGlvbkluZm9ybWF0aW9uID0gbnVsbDtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUluc3RhbmNlKHR5cGUsIHByb3BzLCByb290Q29udGFpbmVySW5zdGFuY2UsIGhvc3RDb250ZXh0LCBpbnRlcm5hbEluc3RhbmNlSGFuZGxlKSB7XG4gIHZhciBwYXJlbnROYW1lc3BhY2U7XG5cbiAge1xuICAgIC8vIFRPRE86IHRha2UgbmFtZXNwYWNlIGludG8gYWNjb3VudCB3aGVuIHZhbGlkYXRpbmcuXG4gICAgdmFyIGhvc3RDb250ZXh0RGV2ID0gaG9zdENvbnRleHQ7XG4gICAgdmFsaWRhdGVET01OZXN0aW5nKHR5cGUsIG51bGwsIGhvc3RDb250ZXh0RGV2LmFuY2VzdG9ySW5mbyk7XG5cbiAgICBpZiAodHlwZW9mIHByb3BzLmNoaWxkcmVuID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgcHJvcHMuY2hpbGRyZW4gPT09ICdudW1iZXInKSB7XG4gICAgICB2YXIgc3RyaW5nID0gJycgKyBwcm9wcy5jaGlsZHJlbjtcbiAgICAgIHZhciBvd25BbmNlc3RvckluZm8gPSB1cGRhdGVkQW5jZXN0b3JJbmZvKGhvc3RDb250ZXh0RGV2LmFuY2VzdG9ySW5mbywgdHlwZSk7XG4gICAgICB2YWxpZGF0ZURPTU5lc3RpbmcobnVsbCwgc3RyaW5nLCBvd25BbmNlc3RvckluZm8pO1xuICAgIH1cblxuICAgIHBhcmVudE5hbWVzcGFjZSA9IGhvc3RDb250ZXh0RGV2Lm5hbWVzcGFjZTtcbiAgfVxuXG4gIHZhciBkb21FbGVtZW50ID0gY3JlYXRlRWxlbWVudCh0eXBlLCBwcm9wcywgcm9vdENvbnRhaW5lckluc3RhbmNlLCBwYXJlbnROYW1lc3BhY2UpO1xuICBwcmVjYWNoZUZpYmVyTm9kZShpbnRlcm5hbEluc3RhbmNlSGFuZGxlLCBkb21FbGVtZW50KTtcbiAgdXBkYXRlRmliZXJQcm9wcyhkb21FbGVtZW50LCBwcm9wcyk7XG4gIHJldHVybiBkb21FbGVtZW50O1xufVxuZnVuY3Rpb24gYXBwZW5kSW5pdGlhbENoaWxkKHBhcmVudEluc3RhbmNlLCBjaGlsZCkge1xuICBwYXJlbnRJbnN0YW5jZS5hcHBlbmRDaGlsZChjaGlsZCk7XG59XG5mdW5jdGlvbiBmaW5hbGl6ZUluaXRpYWxDaGlsZHJlbihkb21FbGVtZW50LCB0eXBlLCBwcm9wcywgcm9vdENvbnRhaW5lckluc3RhbmNlLCBob3N0Q29udGV4dCkge1xuICBzZXRJbml0aWFsUHJvcGVydGllcyhkb21FbGVtZW50LCB0eXBlLCBwcm9wcywgcm9vdENvbnRhaW5lckluc3RhbmNlKTtcbiAgcmV0dXJuIHNob3VsZEF1dG9Gb2N1c0hvc3RDb21wb25lbnQodHlwZSwgcHJvcHMpO1xufVxuZnVuY3Rpb24gcHJlcGFyZVVwZGF0ZShkb21FbGVtZW50LCB0eXBlLCBvbGRQcm9wcywgbmV3UHJvcHMsIHJvb3RDb250YWluZXJJbnN0YW5jZSwgaG9zdENvbnRleHQpIHtcbiAge1xuICAgIHZhciBob3N0Q29udGV4dERldiA9IGhvc3RDb250ZXh0O1xuXG4gICAgaWYgKHR5cGVvZiBuZXdQcm9wcy5jaGlsZHJlbiAhPT0gdHlwZW9mIG9sZFByb3BzLmNoaWxkcmVuICYmICh0eXBlb2YgbmV3UHJvcHMuY2hpbGRyZW4gPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBuZXdQcm9wcy5jaGlsZHJlbiA9PT0gJ251bWJlcicpKSB7XG4gICAgICB2YXIgc3RyaW5nID0gJycgKyBuZXdQcm9wcy5jaGlsZHJlbjtcbiAgICAgIHZhciBvd25BbmNlc3RvckluZm8gPSB1cGRhdGVkQW5jZXN0b3JJbmZvKGhvc3RDb250ZXh0RGV2LmFuY2VzdG9ySW5mbywgdHlwZSk7XG4gICAgICB2YWxpZGF0ZURPTU5lc3RpbmcobnVsbCwgc3RyaW5nLCBvd25BbmNlc3RvckluZm8pO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBkaWZmUHJvcGVydGllcyhkb21FbGVtZW50LCB0eXBlLCBvbGRQcm9wcywgbmV3UHJvcHMpO1xufVxuZnVuY3Rpb24gc2hvdWxkU2V0VGV4dENvbnRlbnQodHlwZSwgcHJvcHMpIHtcbiAgcmV0dXJuIHR5cGUgPT09ICd0ZXh0YXJlYScgfHwgdHlwZSA9PT0gJ29wdGlvbicgfHwgdHlwZSA9PT0gJ25vc2NyaXB0JyB8fCB0eXBlb2YgcHJvcHMuY2hpbGRyZW4gPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBwcm9wcy5jaGlsZHJlbiA9PT0gJ251bWJlcicgfHwgdHlwZW9mIHByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MID09PSAnb2JqZWN0JyAmJiBwcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTCAhPT0gbnVsbCAmJiBwcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTC5fX2h0bWwgIT0gbnVsbDtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVRleHRJbnN0YW5jZSh0ZXh0LCByb290Q29udGFpbmVySW5zdGFuY2UsIGhvc3RDb250ZXh0LCBpbnRlcm5hbEluc3RhbmNlSGFuZGxlKSB7XG4gIHtcbiAgICB2YXIgaG9zdENvbnRleHREZXYgPSBob3N0Q29udGV4dDtcbiAgICB2YWxpZGF0ZURPTU5lc3RpbmcobnVsbCwgdGV4dCwgaG9zdENvbnRleHREZXYuYW5jZXN0b3JJbmZvKTtcbiAgfVxuXG4gIHZhciB0ZXh0Tm9kZSA9IGNyZWF0ZVRleHROb2RlKHRleHQsIHJvb3RDb250YWluZXJJbnN0YW5jZSk7XG4gIHByZWNhY2hlRmliZXJOb2RlKGludGVybmFsSW5zdGFuY2VIYW5kbGUsIHRleHROb2RlKTtcbiAgcmV0dXJuIHRleHROb2RlO1xufVxuLy8gaWYgYSBjb21wb25lbnQganVzdCBpbXBvcnRzIFJlYWN0RE9NIChlLmcuIGZvciBmaW5kRE9NTm9kZSkuXG4vLyBTb21lIGVudmlyb25tZW50cyBtaWdodCBub3QgaGF2ZSBzZXRUaW1lb3V0IG9yIGNsZWFyVGltZW91dC5cblxudmFyIHNjaGVkdWxlVGltZW91dCA9IHR5cGVvZiBzZXRUaW1lb3V0ID09PSAnZnVuY3Rpb24nID8gc2V0VGltZW91dCA6IHVuZGVmaW5lZDtcbnZhciBjYW5jZWxUaW1lb3V0ID0gdHlwZW9mIGNsZWFyVGltZW91dCA9PT0gJ2Z1bmN0aW9uJyA/IGNsZWFyVGltZW91dCA6IHVuZGVmaW5lZDtcbnZhciBub1RpbWVvdXQgPSAtMTsgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLVxuZnVuY3Rpb24gY29tbWl0TW91bnQoZG9tRWxlbWVudCwgdHlwZSwgbmV3UHJvcHMsIGludGVybmFsSW5zdGFuY2VIYW5kbGUpIHtcbiAgLy8gRGVzcGl0ZSB0aGUgbmFtaW5nIHRoYXQgbWlnaHQgaW1wbHkgb3RoZXJ3aXNlLCB0aGlzIG1ldGhvZCBvbmx5XG4gIC8vIGZpcmVzIGlmIHRoZXJlIGlzIGFuIGBVcGRhdGVgIGVmZmVjdCBzY2hlZHVsZWQgZHVyaW5nIG1vdW50aW5nLlxuICAvLyBUaGlzIGhhcHBlbnMgaWYgYGZpbmFsaXplSW5pdGlhbENoaWxkcmVuYCByZXR1cm5zIGB0cnVlYCAod2hpY2ggaXRcbiAgLy8gZG9lcyB0byBpbXBsZW1lbnQgdGhlIGBhdXRvRm9jdXNgIGF0dHJpYnV0ZSBvbiB0aGUgY2xpZW50KS4gQnV0XG4gIC8vIHRoZXJlIGFyZSBhbHNvIG90aGVyIGNhc2VzIHdoZW4gdGhpcyBtaWdodCBoYXBwZW4gKHN1Y2ggYXMgcGF0Y2hpbmdcbiAgLy8gdXAgdGV4dCBjb250ZW50IGR1cmluZyBoeWRyYXRpb24gbWlzbWF0Y2gpLiBTbyB3ZSdsbCBjaGVjayB0aGlzIGFnYWluLlxuICBpZiAoc2hvdWxkQXV0b0ZvY3VzSG9zdENvbXBvbmVudCh0eXBlLCBuZXdQcm9wcykpIHtcbiAgICBkb21FbGVtZW50LmZvY3VzKCk7XG4gIH1cbn1cbmZ1bmN0aW9uIGNvbW1pdFVwZGF0ZShkb21FbGVtZW50LCB1cGRhdGVQYXlsb2FkLCB0eXBlLCBvbGRQcm9wcywgbmV3UHJvcHMsIGludGVybmFsSW5zdGFuY2VIYW5kbGUpIHtcbiAgLy8gVXBkYXRlIHRoZSBwcm9wcyBoYW5kbGUgc28gdGhhdCB3ZSBrbm93IHdoaWNoIHByb3BzIGFyZSB0aGUgb25lcyB3aXRoXG4gIC8vIHdpdGggY3VycmVudCBldmVudCBoYW5kbGVycy5cbiAgdXBkYXRlRmliZXJQcm9wcyhkb21FbGVtZW50LCBuZXdQcm9wcyk7IC8vIEFwcGx5IHRoZSBkaWZmIHRvIHRoZSBET00gbm9kZS5cblxuICB1cGRhdGVQcm9wZXJ0aWVzKGRvbUVsZW1lbnQsIHVwZGF0ZVBheWxvYWQsIHR5cGUsIG9sZFByb3BzLCBuZXdQcm9wcyk7XG59XG5mdW5jdGlvbiByZXNldFRleHRDb250ZW50KGRvbUVsZW1lbnQpIHtcbiAgc2V0VGV4dENvbnRlbnQoZG9tRWxlbWVudCwgJycpO1xufVxuZnVuY3Rpb24gY29tbWl0VGV4dFVwZGF0ZSh0ZXh0SW5zdGFuY2UsIG9sZFRleHQsIG5ld1RleHQpIHtcbiAgdGV4dEluc3RhbmNlLm5vZGVWYWx1ZSA9IG5ld1RleHQ7XG59XG5mdW5jdGlvbiBhcHBlbmRDaGlsZChwYXJlbnRJbnN0YW5jZSwgY2hpbGQpIHtcbiAgcGFyZW50SW5zdGFuY2UuYXBwZW5kQ2hpbGQoY2hpbGQpO1xufVxuZnVuY3Rpb24gYXBwZW5kQ2hpbGRUb0NvbnRhaW5lcihjb250YWluZXIsIGNoaWxkKSB7XG4gIHZhciBwYXJlbnROb2RlO1xuXG4gIGlmIChjb250YWluZXIubm9kZVR5cGUgPT09IENPTU1FTlRfTk9ERSkge1xuICAgIHBhcmVudE5vZGUgPSBjb250YWluZXIucGFyZW50Tm9kZTtcbiAgICBwYXJlbnROb2RlLmluc2VydEJlZm9yZShjaGlsZCwgY29udGFpbmVyKTtcbiAgfSBlbHNlIHtcbiAgICBwYXJlbnROb2RlID0gY29udGFpbmVyO1xuICAgIHBhcmVudE5vZGUuYXBwZW5kQ2hpbGQoY2hpbGQpO1xuICB9IC8vIFRoaXMgY29udGFpbmVyIG1pZ2h0IGJlIHVzZWQgZm9yIGEgcG9ydGFsLlxuICAvLyBJZiBzb21ldGhpbmcgaW5zaWRlIGEgcG9ydGFsIGlzIGNsaWNrZWQsIHRoYXQgY2xpY2sgc2hvdWxkIGJ1YmJsZVxuICAvLyB0aHJvdWdoIHRoZSBSZWFjdCB0cmVlLiBIb3dldmVyLCBvbiBNb2JpbGUgU2FmYXJpIHRoZSBjbGljayB3b3VsZFxuICAvLyBuZXZlciBidWJibGUgdGhyb3VnaCB0aGUgKkRPTSogdHJlZSB1bmxlc3MgYW4gYW5jZXN0b3Igd2l0aCBvbmNsaWNrXG4gIC8vIGV2ZW50IGV4aXN0cy4gU28gd2Ugd291bGRuJ3Qgc2VlIGl0IGFuZCBkaXNwYXRjaCBpdC5cbiAgLy8gVGhpcyBpcyB3aHkgd2UgZW5zdXJlIHRoYXQgbm9uIFJlYWN0IHJvb3QgY29udGFpbmVycyBoYXZlIGlubGluZSBvbmNsaWNrXG4gIC8vIGRlZmluZWQuXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTE5MThcblxuXG4gIHZhciByZWFjdFJvb3RDb250YWluZXIgPSBjb250YWluZXIuX3JlYWN0Um9vdENvbnRhaW5lcjtcblxuICBpZiAoKHJlYWN0Um9vdENvbnRhaW5lciA9PT0gbnVsbCB8fCByZWFjdFJvb3RDb250YWluZXIgPT09IHVuZGVmaW5lZCkgJiYgcGFyZW50Tm9kZS5vbmNsaWNrID09PSBudWxsKSB7XG4gICAgLy8gVE9ETzogVGhpcyBjYXN0IG1heSBub3QgYmUgc291bmQgZm9yIFNWRywgTWF0aE1MIG9yIGN1c3RvbSBlbGVtZW50cy5cbiAgICB0cmFwQ2xpY2tPbk5vbkludGVyYWN0aXZlRWxlbWVudChwYXJlbnROb2RlKTtcbiAgfVxufVxuZnVuY3Rpb24gaW5zZXJ0QmVmb3JlKHBhcmVudEluc3RhbmNlLCBjaGlsZCwgYmVmb3JlQ2hpbGQpIHtcbiAgcGFyZW50SW5zdGFuY2UuaW5zZXJ0QmVmb3JlKGNoaWxkLCBiZWZvcmVDaGlsZCk7XG59XG5mdW5jdGlvbiBpbnNlcnRJbkNvbnRhaW5lckJlZm9yZShjb250YWluZXIsIGNoaWxkLCBiZWZvcmVDaGlsZCkge1xuICBpZiAoY29udGFpbmVyLm5vZGVUeXBlID09PSBDT01NRU5UX05PREUpIHtcbiAgICBjb250YWluZXIucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoY2hpbGQsIGJlZm9yZUNoaWxkKTtcbiAgfSBlbHNlIHtcbiAgICBjb250YWluZXIuaW5zZXJ0QmVmb3JlKGNoaWxkLCBiZWZvcmVDaGlsZCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVtb3ZlQ2hpbGQocGFyZW50SW5zdGFuY2UsIGNoaWxkKSB7XG4gIHBhcmVudEluc3RhbmNlLnJlbW92ZUNoaWxkKGNoaWxkKTtcbn1cbmZ1bmN0aW9uIHJlbW92ZUNoaWxkRnJvbUNvbnRhaW5lcihjb250YWluZXIsIGNoaWxkKSB7XG4gIGlmIChjb250YWluZXIubm9kZVR5cGUgPT09IENPTU1FTlRfTk9ERSkge1xuICAgIGNvbnRhaW5lci5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGNoaWxkKTtcbiAgfSBlbHNlIHtcbiAgICBjb250YWluZXIucmVtb3ZlQ2hpbGQoY2hpbGQpO1xuICB9XG59XG5mdW5jdGlvbiBoaWRlSW5zdGFuY2UoaW5zdGFuY2UpIHtcbiAgLy8gVE9ETzogRG9lcyB0aGlzIHdvcmsgZm9yIGFsbCBlbGVtZW50IHR5cGVzPyBXaGF0IGFib3V0IE1hdGhNTD8gU2hvdWxkIHdlXG4gIC8vIHBhc3MgaG9zdCBjb250ZXh0IHRvIHRoaXMgbWV0aG9kP1xuICBpbnN0YW5jZSA9IGluc3RhbmNlO1xuICB2YXIgc3R5bGUgPSBpbnN0YW5jZS5zdHlsZTtcblxuICBpZiAodHlwZW9mIHN0eWxlLnNldFByb3BlcnR5ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgc3R5bGUuc2V0UHJvcGVydHkoJ2Rpc3BsYXknLCAnbm9uZScsICdpbXBvcnRhbnQnKTtcbiAgfSBlbHNlIHtcbiAgICBzdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICB9XG59XG5mdW5jdGlvbiBoaWRlVGV4dEluc3RhbmNlKHRleHRJbnN0YW5jZSkge1xuICB0ZXh0SW5zdGFuY2Uubm9kZVZhbHVlID0gJyc7XG59XG5mdW5jdGlvbiB1bmhpZGVJbnN0YW5jZShpbnN0YW5jZSwgcHJvcHMpIHtcbiAgaW5zdGFuY2UgPSBpbnN0YW5jZTtcbiAgdmFyIHN0eWxlUHJvcCA9IHByb3BzW1NUWUxFJDFdO1xuICB2YXIgZGlzcGxheSA9IHN0eWxlUHJvcCAhPT0gdW5kZWZpbmVkICYmIHN0eWxlUHJvcCAhPT0gbnVsbCAmJiBzdHlsZVByb3AuaGFzT3duUHJvcGVydHkoJ2Rpc3BsYXknKSA/IHN0eWxlUHJvcC5kaXNwbGF5IDogbnVsbDtcbiAgaW5zdGFuY2Uuc3R5bGUuZGlzcGxheSA9IGRhbmdlcm91c1N0eWxlVmFsdWUoJ2Rpc3BsYXknLCBkaXNwbGF5KTtcbn1cbmZ1bmN0aW9uIHVuaGlkZVRleHRJbnN0YW5jZSh0ZXh0SW5zdGFuY2UsIHRleHQpIHtcbiAgdGV4dEluc3RhbmNlLm5vZGVWYWx1ZSA9IHRleHQ7XG59XG5mdW5jdGlvbiBjbGVhckNvbnRhaW5lcihjb250YWluZXIpIHtcbiAgaWYgKGNvbnRhaW5lci5ub2RlVHlwZSA9PT0gRUxFTUVOVF9OT0RFKSB7XG4gICAgY29udGFpbmVyLnRleHRDb250ZW50ID0gJyc7XG4gIH0gZWxzZSBpZiAoY29udGFpbmVyLm5vZGVUeXBlID09PSBET0NVTUVOVF9OT0RFKSB7XG4gICAgdmFyIGJvZHkgPSBjb250YWluZXIuYm9keTtcblxuICAgIGlmIChib2R5ICE9IG51bGwpIHtcbiAgICAgIGJvZHkudGV4dENvbnRlbnQgPSAnJztcbiAgICB9XG4gIH1cbn0gLy8gLS0tLS0tLS0tLS0tLS0tLS0tLVxuZnVuY3Rpb24gY2FuSHlkcmF0ZUluc3RhbmNlKGluc3RhbmNlLCB0eXBlLCBwcm9wcykge1xuICBpZiAoaW5zdGFuY2Uubm9kZVR5cGUgIT09IEVMRU1FTlRfTk9ERSB8fCB0eXBlLnRvTG93ZXJDYXNlKCkgIT09IGluc3RhbmNlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfSAvLyBUaGlzIGhhcyBub3cgYmVlbiByZWZpbmVkIHRvIGFuIGVsZW1lbnQgbm9kZS5cblxuXG4gIHJldHVybiBpbnN0YW5jZTtcbn1cbmZ1bmN0aW9uIGNhbkh5ZHJhdGVUZXh0SW5zdGFuY2UoaW5zdGFuY2UsIHRleHQpIHtcbiAgaWYgKHRleHQgPT09ICcnIHx8IGluc3RhbmNlLm5vZGVUeXBlICE9PSBURVhUX05PREUpIHtcbiAgICAvLyBFbXB0eSBzdHJpbmdzIGFyZSBub3QgcGFyc2VkIGJ5IEhUTUwgc28gdGhlcmUgd29uJ3QgYmUgYSBjb3JyZWN0IG1hdGNoIGhlcmUuXG4gICAgcmV0dXJuIG51bGw7XG4gIH0gLy8gVGhpcyBoYXMgbm93IGJlZW4gcmVmaW5lZCB0byBhIHRleHQgbm9kZS5cblxuXG4gIHJldHVybiBpbnN0YW5jZTtcbn1cbmZ1bmN0aW9uIGlzU3VzcGVuc2VJbnN0YW5jZVBlbmRpbmcoaW5zdGFuY2UpIHtcbiAgcmV0dXJuIGluc3RhbmNlLmRhdGEgPT09IFNVU1BFTlNFX1BFTkRJTkdfU1RBUlRfREFUQTtcbn1cbmZ1bmN0aW9uIGlzU3VzcGVuc2VJbnN0YW5jZUZhbGxiYWNrKGluc3RhbmNlKSB7XG4gIHJldHVybiBpbnN0YW5jZS5kYXRhID09PSBTVVNQRU5TRV9GQUxMQkFDS19TVEFSVF9EQVRBO1xufVxuXG5mdW5jdGlvbiBnZXROZXh0SHlkcmF0YWJsZShub2RlKSB7XG4gIC8vIFNraXAgbm9uLWh5ZHJhdGFibGUgbm9kZXMuXG4gIGZvciAoOyBub2RlICE9IG51bGw7IG5vZGUgPSBub2RlLm5leHRTaWJsaW5nKSB7XG4gICAgdmFyIG5vZGVUeXBlID0gbm9kZS5ub2RlVHlwZTtcblxuICAgIGlmIChub2RlVHlwZSA9PT0gRUxFTUVOVF9OT0RFIHx8IG5vZGVUeXBlID09PSBURVhUX05PREUpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBub2RlO1xufVxuXG5mdW5jdGlvbiBnZXROZXh0SHlkcmF0YWJsZVNpYmxpbmcoaW5zdGFuY2UpIHtcbiAgcmV0dXJuIGdldE5leHRIeWRyYXRhYmxlKGluc3RhbmNlLm5leHRTaWJsaW5nKTtcbn1cbmZ1bmN0aW9uIGdldEZpcnN0SHlkcmF0YWJsZUNoaWxkKHBhcmVudEluc3RhbmNlKSB7XG4gIHJldHVybiBnZXROZXh0SHlkcmF0YWJsZShwYXJlbnRJbnN0YW5jZS5maXJzdENoaWxkKTtcbn1cbmZ1bmN0aW9uIGh5ZHJhdGVJbnN0YW5jZShpbnN0YW5jZSwgdHlwZSwgcHJvcHMsIHJvb3RDb250YWluZXJJbnN0YW5jZSwgaG9zdENvbnRleHQsIGludGVybmFsSW5zdGFuY2VIYW5kbGUpIHtcbiAgcHJlY2FjaGVGaWJlck5vZGUoaW50ZXJuYWxJbnN0YW5jZUhhbmRsZSwgaW5zdGFuY2UpOyAvLyBUT0RPOiBQb3NzaWJseSBkZWZlciB0aGlzIHVudGlsIHRoZSBjb21taXQgcGhhc2Ugd2hlcmUgYWxsIHRoZSBldmVudHNcbiAgLy8gZ2V0IGF0dGFjaGVkLlxuXG4gIHVwZGF0ZUZpYmVyUHJvcHMoaW5zdGFuY2UsIHByb3BzKTtcbiAgdmFyIHBhcmVudE5hbWVzcGFjZTtcblxuICB7XG4gICAgdmFyIGhvc3RDb250ZXh0RGV2ID0gaG9zdENvbnRleHQ7XG4gICAgcGFyZW50TmFtZXNwYWNlID0gaG9zdENvbnRleHREZXYubmFtZXNwYWNlO1xuICB9XG5cbiAgcmV0dXJuIGRpZmZIeWRyYXRlZFByb3BlcnRpZXMoaW5zdGFuY2UsIHR5cGUsIHByb3BzLCBwYXJlbnROYW1lc3BhY2UpO1xufVxuZnVuY3Rpb24gaHlkcmF0ZVRleHRJbnN0YW5jZSh0ZXh0SW5zdGFuY2UsIHRleHQsIGludGVybmFsSW5zdGFuY2VIYW5kbGUpIHtcbiAgcHJlY2FjaGVGaWJlck5vZGUoaW50ZXJuYWxJbnN0YW5jZUhhbmRsZSwgdGV4dEluc3RhbmNlKTtcbiAgcmV0dXJuIGRpZmZIeWRyYXRlZFRleHQodGV4dEluc3RhbmNlLCB0ZXh0KTtcbn1cbmZ1bmN0aW9uIGdldE5leHRIeWRyYXRhYmxlSW5zdGFuY2VBZnRlclN1c3BlbnNlSW5zdGFuY2Uoc3VzcGVuc2VJbnN0YW5jZSkge1xuICB2YXIgbm9kZSA9IHN1c3BlbnNlSW5zdGFuY2UubmV4dFNpYmxpbmc7IC8vIFNraXAgcGFzdCBhbGwgbm9kZXMgd2l0aGluIHRoaXMgc3VzcGVuc2UgYm91bmRhcnkuXG4gIC8vIFRoZXJlIG1pZ2h0IGJlIG5lc3RlZCBub2RlcyBzbyB3ZSBuZWVkIHRvIGtlZXAgdHJhY2sgb2YgaG93XG4gIC8vIGRlZXAgd2UgYXJlIGFuZCBvbmx5IGJyZWFrIG91dCB3aGVuIHdlJ3JlIGJhY2sgb24gdG9wLlxuXG4gIHZhciBkZXB0aCA9IDA7XG5cbiAgd2hpbGUgKG5vZGUpIHtcbiAgICBpZiAobm9kZS5ub2RlVHlwZSA9PT0gQ09NTUVOVF9OT0RFKSB7XG4gICAgICB2YXIgZGF0YSA9IG5vZGUuZGF0YTtcblxuICAgICAgaWYgKGRhdGEgPT09IFNVU1BFTlNFX0VORF9EQVRBKSB7XG4gICAgICAgIGlmIChkZXB0aCA9PT0gMCkge1xuICAgICAgICAgIHJldHVybiBnZXROZXh0SHlkcmF0YWJsZVNpYmxpbmcobm9kZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZGVwdGgtLTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChkYXRhID09PSBTVVNQRU5TRV9TVEFSVF9EQVRBIHx8IGRhdGEgPT09IFNVU1BFTlNFX0ZBTExCQUNLX1NUQVJUX0RBVEEgfHwgZGF0YSA9PT0gU1VTUEVOU0VfUEVORElOR19TVEFSVF9EQVRBKSB7XG4gICAgICAgIGRlcHRoKys7XG4gICAgICB9XG4gICAgfVxuXG4gICAgbm9kZSA9IG5vZGUubmV4dFNpYmxpbmc7XG4gIH0gLy8gVE9ETzogV2Fybiwgd2UgZGlkbid0IGZpbmQgdGhlIGVuZCBjb21tZW50IGJvdW5kYXJ5LlxuXG5cbiAgcmV0dXJuIG51bGw7XG59IC8vIFJldHVybnMgdGhlIFN1c3BlbnNlSW5zdGFuY2UgaWYgdGhpcyBub2RlIGlzIGEgZGlyZWN0IGNoaWxkIG9mIGFcbi8vIFN1c3BlbnNlSW5zdGFuY2UuIEkuZS4gaWYgaXRzIHByZXZpb3VzIHNpYmxpbmcgaXMgYSBDb21tZW50IHdpdGhcbi8vIFNVU1BFTlNFX3hfU1RBUlRfREFUQS4gT3RoZXJ3aXNlLCBudWxsLlxuXG5mdW5jdGlvbiBnZXRQYXJlbnRTdXNwZW5zZUluc3RhbmNlKHRhcmdldEluc3RhbmNlKSB7XG4gIHZhciBub2RlID0gdGFyZ2V0SW5zdGFuY2UucHJldmlvdXNTaWJsaW5nOyAvLyBTa2lwIHBhc3QgYWxsIG5vZGVzIHdpdGhpbiB0aGlzIHN1c3BlbnNlIGJvdW5kYXJ5LlxuICAvLyBUaGVyZSBtaWdodCBiZSBuZXN0ZWQgbm9kZXMgc28gd2UgbmVlZCB0byBrZWVwIHRyYWNrIG9mIGhvd1xuICAvLyBkZWVwIHdlIGFyZSBhbmQgb25seSBicmVhayBvdXQgd2hlbiB3ZSdyZSBiYWNrIG9uIHRvcC5cblxuICB2YXIgZGVwdGggPSAwO1xuXG4gIHdoaWxlIChub2RlKSB7XG4gICAgaWYgKG5vZGUubm9kZVR5cGUgPT09IENPTU1FTlRfTk9ERSkge1xuICAgICAgdmFyIGRhdGEgPSBub2RlLmRhdGE7XG5cbiAgICAgIGlmIChkYXRhID09PSBTVVNQRU5TRV9TVEFSVF9EQVRBIHx8IGRhdGEgPT09IFNVU1BFTlNFX0ZBTExCQUNLX1NUQVJUX0RBVEEgfHwgZGF0YSA9PT0gU1VTUEVOU0VfUEVORElOR19TVEFSVF9EQVRBKSB7XG4gICAgICAgIGlmIChkZXB0aCA9PT0gMCkge1xuICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRlcHRoLS07XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoZGF0YSA9PT0gU1VTUEVOU0VfRU5EX0RBVEEpIHtcbiAgICAgICAgZGVwdGgrKztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBub2RlID0gbm9kZS5wcmV2aW91c1NpYmxpbmc7XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGNvbW1pdEh5ZHJhdGVkQ29udGFpbmVyKGNvbnRhaW5lcikge1xuICAvLyBSZXRyeSBpZiBhbnkgZXZlbnQgcmVwbGF5aW5nIHdhcyBibG9ja2VkIG9uIHRoaXMuXG4gIHJldHJ5SWZCbG9ja2VkT24oY29udGFpbmVyKTtcbn1cbmZ1bmN0aW9uIGNvbW1pdEh5ZHJhdGVkU3VzcGVuc2VJbnN0YW5jZShzdXNwZW5zZUluc3RhbmNlKSB7XG4gIC8vIFJldHJ5IGlmIGFueSBldmVudCByZXBsYXlpbmcgd2FzIGJsb2NrZWQgb24gdGhpcy5cbiAgcmV0cnlJZkJsb2NrZWRPbihzdXNwZW5zZUluc3RhbmNlKTtcbn1cbmZ1bmN0aW9uIGRpZE5vdE1hdGNoSHlkcmF0ZWRDb250YWluZXJUZXh0SW5zdGFuY2UocGFyZW50Q29udGFpbmVyLCB0ZXh0SW5zdGFuY2UsIHRleHQpIHtcbiAge1xuICAgIHdhcm5Gb3JVbm1hdGNoZWRUZXh0KHRleHRJbnN0YW5jZSwgdGV4dCk7XG4gIH1cbn1cbmZ1bmN0aW9uIGRpZE5vdE1hdGNoSHlkcmF0ZWRUZXh0SW5zdGFuY2UocGFyZW50VHlwZSwgcGFyZW50UHJvcHMsIHBhcmVudEluc3RhbmNlLCB0ZXh0SW5zdGFuY2UsIHRleHQpIHtcbiAgaWYgKCBwYXJlbnRQcm9wc1tTVVBQUkVTU19IWURSQVRJT05fV0FSTklORyQxXSAhPT0gdHJ1ZSkge1xuICAgIHdhcm5Gb3JVbm1hdGNoZWRUZXh0KHRleHRJbnN0YW5jZSwgdGV4dCk7XG4gIH1cbn1cbmZ1bmN0aW9uIGRpZE5vdEh5ZHJhdGVDb250YWluZXJJbnN0YW5jZShwYXJlbnRDb250YWluZXIsIGluc3RhbmNlKSB7XG4gIHtcbiAgICBpZiAoaW5zdGFuY2Uubm9kZVR5cGUgPT09IEVMRU1FTlRfTk9ERSkge1xuICAgICAgd2FybkZvckRlbGV0ZWRIeWRyYXRhYmxlRWxlbWVudChwYXJlbnRDb250YWluZXIsIGluc3RhbmNlKTtcbiAgICB9IGVsc2UgaWYgKGluc3RhbmNlLm5vZGVUeXBlID09PSBDT01NRU5UX05PREUpIDsgZWxzZSB7XG4gICAgICB3YXJuRm9yRGVsZXRlZEh5ZHJhdGFibGVUZXh0KHBhcmVudENvbnRhaW5lciwgaW5zdGFuY2UpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gZGlkTm90SHlkcmF0ZUluc3RhbmNlKHBhcmVudFR5cGUsIHBhcmVudFByb3BzLCBwYXJlbnRJbnN0YW5jZSwgaW5zdGFuY2UpIHtcbiAgaWYgKCBwYXJlbnRQcm9wc1tTVVBQUkVTU19IWURSQVRJT05fV0FSTklORyQxXSAhPT0gdHJ1ZSkge1xuICAgIGlmIChpbnN0YW5jZS5ub2RlVHlwZSA9PT0gRUxFTUVOVF9OT0RFKSB7XG4gICAgICB3YXJuRm9yRGVsZXRlZEh5ZHJhdGFibGVFbGVtZW50KHBhcmVudEluc3RhbmNlLCBpbnN0YW5jZSk7XG4gICAgfSBlbHNlIGlmIChpbnN0YW5jZS5ub2RlVHlwZSA9PT0gQ09NTUVOVF9OT0RFKSA7IGVsc2Uge1xuICAgICAgd2FybkZvckRlbGV0ZWRIeWRyYXRhYmxlVGV4dChwYXJlbnRJbnN0YW5jZSwgaW5zdGFuY2UpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gZGlkTm90RmluZEh5ZHJhdGFibGVDb250YWluZXJJbnN0YW5jZShwYXJlbnRDb250YWluZXIsIHR5cGUsIHByb3BzKSB7XG4gIHtcbiAgICB3YXJuRm9ySW5zZXJ0ZWRIeWRyYXRlZEVsZW1lbnQocGFyZW50Q29udGFpbmVyLCB0eXBlKTtcbiAgfVxufVxuZnVuY3Rpb24gZGlkTm90RmluZEh5ZHJhdGFibGVDb250YWluZXJUZXh0SW5zdGFuY2UocGFyZW50Q29udGFpbmVyLCB0ZXh0KSB7XG4gIHtcbiAgICB3YXJuRm9ySW5zZXJ0ZWRIeWRyYXRlZFRleHQocGFyZW50Q29udGFpbmVyLCB0ZXh0KTtcbiAgfVxufVxuZnVuY3Rpb24gZGlkTm90RmluZEh5ZHJhdGFibGVJbnN0YW5jZShwYXJlbnRUeXBlLCBwYXJlbnRQcm9wcywgcGFyZW50SW5zdGFuY2UsIHR5cGUsIHByb3BzKSB7XG4gIGlmICggcGFyZW50UHJvcHNbU1VQUFJFU1NfSFlEUkFUSU9OX1dBUk5JTkckMV0gIT09IHRydWUpIHtcbiAgICB3YXJuRm9ySW5zZXJ0ZWRIeWRyYXRlZEVsZW1lbnQocGFyZW50SW5zdGFuY2UsIHR5cGUpO1xuICB9XG59XG5mdW5jdGlvbiBkaWROb3RGaW5kSHlkcmF0YWJsZVRleHRJbnN0YW5jZShwYXJlbnRUeXBlLCBwYXJlbnRQcm9wcywgcGFyZW50SW5zdGFuY2UsIHRleHQpIHtcbiAgaWYgKCBwYXJlbnRQcm9wc1tTVVBQUkVTU19IWURSQVRJT05fV0FSTklORyQxXSAhPT0gdHJ1ZSkge1xuICAgIHdhcm5Gb3JJbnNlcnRlZEh5ZHJhdGVkVGV4dChwYXJlbnRJbnN0YW5jZSwgdGV4dCk7XG4gIH1cbn1cbmZ1bmN0aW9uIGRpZE5vdEZpbmRIeWRyYXRhYmxlU3VzcGVuc2VJbnN0YW5jZShwYXJlbnRUeXBlLCBwYXJlbnRQcm9wcywgcGFyZW50SW5zdGFuY2UpIHtcbiAgaWYgKCBwYXJlbnRQcm9wc1tTVVBQUkVTU19IWURSQVRJT05fV0FSTklORyQxXSAhPT0gdHJ1ZSkgO1xufVxudmFyIGNsaWVudElkID0gMDtcbmZ1bmN0aW9uIG1ha2VDbGllbnRJZEluREVWKHdhcm5PbkFjY2Vzc0luREVWKSB7XG4gIHZhciBpZCA9ICdyOicgKyAoY2xpZW50SWQrKykudG9TdHJpbmcoMzYpO1xuICByZXR1cm4ge1xuICAgIHRvU3RyaW5nOiBmdW5jdGlvbiAoKSB7XG4gICAgICB3YXJuT25BY2Nlc3NJbkRFVigpO1xuICAgICAgcmV0dXJuIGlkO1xuICAgIH0sXG4gICAgdmFsdWVPZjogZnVuY3Rpb24gKCkge1xuICAgICAgd2Fybk9uQWNjZXNzSW5ERVYoKTtcbiAgICAgIHJldHVybiBpZDtcbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiBpc09wYXF1ZUh5ZHJhdGluZ09iamVjdCh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT09IG51bGwgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZS4kJHR5cGVvZiA9PT0gUkVBQ1RfT1BBUVVFX0lEX1RZUEU7XG59XG5mdW5jdGlvbiBtYWtlT3BhcXVlSHlkcmF0aW5nT2JqZWN0KGF0dGVtcHRUb1JlYWRWYWx1ZSkge1xuICByZXR1cm4ge1xuICAgICQkdHlwZW9mOiBSRUFDVF9PUEFRVUVfSURfVFlQRSxcbiAgICB0b1N0cmluZzogYXR0ZW1wdFRvUmVhZFZhbHVlLFxuICAgIHZhbHVlT2Y6IGF0dGVtcHRUb1JlYWRWYWx1ZVxuICB9O1xufVxuZnVuY3Rpb24gcHJlcGFyZVBvcnRhbE1vdW50KHBvcnRhbEluc3RhbmNlKSB7XG4gIHtcbiAgICBsaXN0ZW5Ub0FsbFN1cHBvcnRlZEV2ZW50cyhwb3J0YWxJbnN0YW5jZSk7XG4gIH1cbn1cblxudmFyIHJhbmRvbUtleSA9IE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnNsaWNlKDIpO1xudmFyIGludGVybmFsSW5zdGFuY2VLZXkgPSAnX19yZWFjdEZpYmVyJCcgKyByYW5kb21LZXk7XG52YXIgaW50ZXJuYWxQcm9wc0tleSA9ICdfX3JlYWN0UHJvcHMkJyArIHJhbmRvbUtleTtcbnZhciBpbnRlcm5hbENvbnRhaW5lckluc3RhbmNlS2V5ID0gJ19fcmVhY3RDb250YWluZXIkJyArIHJhbmRvbUtleTtcbnZhciBpbnRlcm5hbEV2ZW50SGFuZGxlcnNLZXkgPSAnX19yZWFjdEV2ZW50cyQnICsgcmFuZG9tS2V5O1xuZnVuY3Rpb24gcHJlY2FjaGVGaWJlck5vZGUoaG9zdEluc3QsIG5vZGUpIHtcbiAgbm9kZVtpbnRlcm5hbEluc3RhbmNlS2V5XSA9IGhvc3RJbnN0O1xufVxuZnVuY3Rpb24gbWFya0NvbnRhaW5lckFzUm9vdChob3N0Um9vdCwgbm9kZSkge1xuICBub2RlW2ludGVybmFsQ29udGFpbmVySW5zdGFuY2VLZXldID0gaG9zdFJvb3Q7XG59XG5mdW5jdGlvbiB1bm1hcmtDb250YWluZXJBc1Jvb3Qobm9kZSkge1xuICBub2RlW2ludGVybmFsQ29udGFpbmVySW5zdGFuY2VLZXldID0gbnVsbDtcbn1cbmZ1bmN0aW9uIGlzQ29udGFpbmVyTWFya2VkQXNSb290KG5vZGUpIHtcbiAgcmV0dXJuICEhbm9kZVtpbnRlcm5hbENvbnRhaW5lckluc3RhbmNlS2V5XTtcbn0gLy8gR2l2ZW4gYSBET00gbm9kZSwgcmV0dXJuIHRoZSBjbG9zZXN0IEhvc3RDb21wb25lbnQgb3IgSG9zdFRleHQgZmliZXIgYW5jZXN0b3IuXG4vLyBJZiB0aGUgdGFyZ2V0IG5vZGUgaXMgcGFydCBvZiBhIGh5ZHJhdGVkIG9yIG5vdCB5ZXQgcmVuZGVyZWQgc3VidHJlZSwgdGhlblxuLy8gdGhpcyBtYXkgYWxzbyByZXR1cm4gYSBTdXNwZW5zZUNvbXBvbmVudCBvciBIb3N0Um9vdCB0byBpbmRpY2F0ZSB0aGF0LlxuLy8gQ29uY2VwdHVhbGx5IHRoZSBIb3N0Um9vdCBmaWJlciBpcyBhIGNoaWxkIG9mIHRoZSBDb250YWluZXIgbm9kZS4gU28gaWYgeW91XG4vLyBwYXNzIHRoZSBDb250YWluZXIgbm9kZSBhcyB0aGUgdGFyZ2V0Tm9kZSwgeW91IHdpbGwgbm90IGFjdHVhbGx5IGdldCB0aGVcbi8vIEhvc3RSb290IGJhY2suIFRvIGdldCB0byB0aGUgSG9zdFJvb3QsIHlvdSBuZWVkIHRvIHBhc3MgYSBjaGlsZCBvZiBpdC5cbi8vIFRoZSBzYW1lIHRoaW5nIGFwcGxpZXMgdG8gU3VzcGVuc2UgYm91bmRhcmllcy5cblxuZnVuY3Rpb24gZ2V0Q2xvc2VzdEluc3RhbmNlRnJvbU5vZGUodGFyZ2V0Tm9kZSkge1xuICB2YXIgdGFyZ2V0SW5zdCA9IHRhcmdldE5vZGVbaW50ZXJuYWxJbnN0YW5jZUtleV07XG5cbiAgaWYgKHRhcmdldEluc3QpIHtcbiAgICAvLyBEb24ndCByZXR1cm4gSG9zdFJvb3Qgb3IgU3VzcGVuc2VDb21wb25lbnQgaGVyZS5cbiAgICByZXR1cm4gdGFyZ2V0SW5zdDtcbiAgfSAvLyBJZiB0aGUgZGlyZWN0IGV2ZW50IHRhcmdldCBpc24ndCBhIFJlYWN0IG93bmVkIERPTSBub2RlLCB3ZSBuZWVkIHRvIGxvb2tcbiAgLy8gdG8gc2VlIGlmIG9uZSBvZiBpdHMgcGFyZW50cyBpcyBhIFJlYWN0IG93bmVkIERPTSBub2RlLlxuXG5cbiAgdmFyIHBhcmVudE5vZGUgPSB0YXJnZXROb2RlLnBhcmVudE5vZGU7XG5cbiAgd2hpbGUgKHBhcmVudE5vZGUpIHtcbiAgICAvLyBXZSdsbCBjaGVjayBpZiB0aGlzIGlzIGEgY29udGFpbmVyIHJvb3QgdGhhdCBjb3VsZCBpbmNsdWRlXG4gICAgLy8gUmVhY3Qgbm9kZXMgaW4gdGhlIGZ1dHVyZS4gV2UgbmVlZCB0byBjaGVjayB0aGlzIGZpcnN0IGJlY2F1c2VcbiAgICAvLyBpZiB3ZSdyZSBhIGNoaWxkIG9mIGEgZGVoeWRyYXRlZCBjb250YWluZXIsIHdlIG5lZWQgdG8gZmlyc3RcbiAgICAvLyBmaW5kIHRoYXQgaW5uZXIgY29udGFpbmVyIGJlZm9yZSBtb3Zpbmcgb24gdG8gZmluZGluZyB0aGUgcGFyZW50XG4gICAgLy8gaW5zdGFuY2UuIE5vdGUgdGhhdCB3ZSBkb24ndCBjaGVjayB0aGlzIGZpZWxkIG9uICB0aGUgdGFyZ2V0Tm9kZVxuICAgIC8vIGl0c2VsZiBiZWNhdXNlIHRoZSBmaWJlcnMgYXJlIGNvbmNlcHR1YWxseSBiZXR3ZWVuIHRoZSBjb250YWluZXJcbiAgICAvLyBub2RlIGFuZCB0aGUgZmlyc3QgY2hpbGQuIEl0IGlzbid0IHN1cnJvdW5kaW5nIHRoZSBjb250YWluZXIgbm9kZS5cbiAgICAvLyBJZiBpdCdzIG5vdCBhIGNvbnRhaW5lciwgd2UgY2hlY2sgaWYgaXQncyBhbiBpbnN0YW5jZS5cbiAgICB0YXJnZXRJbnN0ID0gcGFyZW50Tm9kZVtpbnRlcm5hbENvbnRhaW5lckluc3RhbmNlS2V5XSB8fCBwYXJlbnROb2RlW2ludGVybmFsSW5zdGFuY2VLZXldO1xuXG4gICAgaWYgKHRhcmdldEluc3QpIHtcbiAgICAgIC8vIFNpbmNlIHRoaXMgd2Fzbid0IHRoZSBkaXJlY3QgdGFyZ2V0IG9mIHRoZSBldmVudCwgd2UgbWlnaHQgaGF2ZVxuICAgICAgLy8gc3RlcHBlZCBwYXN0IGRlaHlkcmF0ZWQgRE9NIG5vZGVzIHRvIGdldCBoZXJlLiBIb3dldmVyIHRoZXkgY291bGRcbiAgICAgIC8vIGFsc28gaGF2ZSBiZWVuIG5vbi1SZWFjdCBub2Rlcy4gV2UgbmVlZCB0byBhbnN3ZXIgd2hpY2ggb25lLlxuICAgICAgLy8gSWYgd2UgdGhlIGluc3RhbmNlIGRvZXNuJ3QgaGF2ZSBhbnkgY2hpbGRyZW4sIHRoZW4gdGhlcmUgY2FuJ3QgYmVcbiAgICAgIC8vIGEgbmVzdGVkIHN1c3BlbnNlIGJvdW5kYXJ5IHdpdGhpbiBpdC4gU28gd2UgY2FuIHVzZSB0aGlzIGFzIGEgZmFzdFxuICAgICAgLy8gYmFpbG91dC4gTW9zdCBvZiB0aGUgdGltZSwgd2hlbiBwZW9wbGUgYWRkIG5vbi1SZWFjdCBjaGlsZHJlbiB0b1xuICAgICAgLy8gdGhlIHRyZWUsIGl0IGlzIHVzaW5nIGEgcmVmIHRvIGEgY2hpbGQtbGVzcyBET00gbm9kZS5cbiAgICAgIC8vIE5vcm1hbGx5IHdlJ2Qgb25seSBuZWVkIHRvIGNoZWNrIG9uZSBvZiB0aGUgZmliZXJzIGJlY2F1c2UgaWYgaXRcbiAgICAgIC8vIGhhcyBldmVyIGdvbmUgZnJvbSBoYXZpbmcgY2hpbGRyZW4gdG8gZGVsZXRpbmcgdGhlbSBvciB2aWNlIHZlcnNhXG4gICAgICAvLyBpdCB3b3VsZCBoYXZlIGRlbGV0ZWQgdGhlIGRlaHlkcmF0ZWQgYm91bmRhcnkgbmVzdGVkIGluc2lkZSBhbHJlYWR5LlxuICAgICAgLy8gSG93ZXZlciwgc2luY2UgdGhlIEhvc3RSb290IHN0YXJ0cyBvdXQgd2l0aCBhbiBhbHRlcm5hdGUgaXQgbWlnaHRcbiAgICAgIC8vIGhhdmUgb25lIG9uIHRoZSBhbHRlcm5hdGUgc28gd2UgbmVlZCB0byBjaGVjayBpbiBjYXNlIHRoaXMgd2FzIGFcbiAgICAgIC8vIHJvb3QuXG4gICAgICB2YXIgYWx0ZXJuYXRlID0gdGFyZ2V0SW5zdC5hbHRlcm5hdGU7XG5cbiAgICAgIGlmICh0YXJnZXRJbnN0LmNoaWxkICE9PSBudWxsIHx8IGFsdGVybmF0ZSAhPT0gbnVsbCAmJiBhbHRlcm5hdGUuY2hpbGQgIT09IG51bGwpIHtcbiAgICAgICAgLy8gTmV4dCB3ZSBuZWVkIHRvIGZpZ3VyZSBvdXQgaWYgdGhlIG5vZGUgdGhhdCBza2lwcGVkIHBhc3QgaXNcbiAgICAgICAgLy8gbmVzdGVkIHdpdGhpbiBhIGRlaHlkcmF0ZWQgYm91bmRhcnkgYW5kIGlmIHNvLCB3aGljaCBvbmUuXG4gICAgICAgIHZhciBzdXNwZW5zZUluc3RhbmNlID0gZ2V0UGFyZW50U3VzcGVuc2VJbnN0YW5jZSh0YXJnZXROb2RlKTtcblxuICAgICAgICB3aGlsZSAoc3VzcGVuc2VJbnN0YW5jZSAhPT0gbnVsbCkge1xuICAgICAgICAgIC8vIFdlIGZvdW5kIGEgc3VzcGVuc2UgaW5zdGFuY2UuIFRoYXQgbWVhbnMgdGhhdCB3ZSBoYXZlbid0XG4gICAgICAgICAgLy8gaHlkcmF0ZWQgaXQgeWV0LiBFdmVuIHRob3VnaCB3ZSBsZWF2ZSB0aGUgY29tbWVudHMgaW4gdGhlXG4gICAgICAgICAgLy8gRE9NIGFmdGVyIGh5ZHJhdGluZywgYW5kIHRoZXJlIGFyZSBib3VuZGFyaWVzIGluIHRoZSBET01cbiAgICAgICAgICAvLyB0aGF0IGNvdWxkIGFscmVhZHkgYmUgaHlkcmF0ZWQsIHdlIHdvdWxkbid0IGhhdmUgZm91bmQgdGhlbVxuICAgICAgICAgIC8vIHRocm91Z2ggdGhpcyBwYXNzIHNpbmNlIGlmIHRoZSB0YXJnZXQgaXMgaHlkcmF0ZWQgaXQgd291bGRcbiAgICAgICAgICAvLyBoYXZlIGhhZCBhbiBpbnRlcm5hbEluc3RhbmNlS2V5IG9uIGl0LlxuICAgICAgICAgIC8vIExldCdzIGdldCB0aGUgZmliZXIgYXNzb2NpYXRlZCB3aXRoIHRoZSBTdXNwZW5zZUNvbXBvbmVudFxuICAgICAgICAgIC8vIGFzIHRoZSBkZWVwZXN0IGluc3RhbmNlLlxuICAgICAgICAgIHZhciB0YXJnZXRTdXNwZW5zZUluc3QgPSBzdXNwZW5zZUluc3RhbmNlW2ludGVybmFsSW5zdGFuY2VLZXldO1xuXG4gICAgICAgICAgaWYgKHRhcmdldFN1c3BlbnNlSW5zdCkge1xuICAgICAgICAgICAgcmV0dXJuIHRhcmdldFN1c3BlbnNlSW5zdDtcbiAgICAgICAgICB9IC8vIElmIHdlIGRvbid0IGZpbmQgYSBGaWJlciBvbiB0aGUgY29tbWVudCwgaXQgbWlnaHQgYmUgYmVjYXVzZVxuICAgICAgICAgIC8vIHdlIGhhdmVuJ3QgZ290dGVuIHRvIGh5ZHJhdGUgaXQgeWV0LiBUaGVyZSBtaWdodCBzdGlsbCBiZSBhXG4gICAgICAgICAgLy8gcGFyZW50IGJvdW5kYXJ5IHRoYXQgaGFzbid0IGFib3ZlIHRoaXMgb25lIHNvIHdlIG5lZWQgdG8gZmluZFxuICAgICAgICAgIC8vIHRoZSBvdXRlciBtb3N0IHRoYXQgaXMga25vd24uXG5cblxuICAgICAgICAgIHN1c3BlbnNlSW5zdGFuY2UgPSBnZXRQYXJlbnRTdXNwZW5zZUluc3RhbmNlKHN1c3BlbnNlSW5zdGFuY2UpOyAvLyBJZiB3ZSBkb24ndCBmaW5kIG9uZSwgdGhlbiB0aGF0IHNob3VsZCBtZWFuIHRoYXQgdGhlIHBhcmVudFxuICAgICAgICAgIC8vIGhvc3QgY29tcG9uZW50IGFsc28gaGFzbid0IGh5ZHJhdGVkIHlldC4gV2UgY2FuIHJldHVybiBpdFxuICAgICAgICAgIC8vIGJlbG93IHNpbmNlIGl0IHdpbGwgYmFpbCBvdXQgb24gdGhlIGlzTW91bnRlZCBjaGVjayBsYXRlci5cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGFyZ2V0SW5zdDtcbiAgICB9XG5cbiAgICB0YXJnZXROb2RlID0gcGFyZW50Tm9kZTtcbiAgICBwYXJlbnROb2RlID0gdGFyZ2V0Tm9kZS5wYXJlbnROb2RlO1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG4vKipcbiAqIEdpdmVuIGEgRE9NIG5vZGUsIHJldHVybiB0aGUgUmVhY3RET01Db21wb25lbnQgb3IgUmVhY3RET01UZXh0Q29tcG9uZW50XG4gKiBpbnN0YW5jZSwgb3IgbnVsbCBpZiB0aGUgbm9kZSB3YXMgbm90IHJlbmRlcmVkIGJ5IHRoaXMgUmVhY3QuXG4gKi9cblxuZnVuY3Rpb24gZ2V0SW5zdGFuY2VGcm9tTm9kZShub2RlKSB7XG4gIHZhciBpbnN0ID0gbm9kZVtpbnRlcm5hbEluc3RhbmNlS2V5XSB8fCBub2RlW2ludGVybmFsQ29udGFpbmVySW5zdGFuY2VLZXldO1xuXG4gIGlmIChpbnN0KSB7XG4gICAgaWYgKGluc3QudGFnID09PSBIb3N0Q29tcG9uZW50IHx8IGluc3QudGFnID09PSBIb3N0VGV4dCB8fCBpbnN0LnRhZyA9PT0gU3VzcGVuc2VDb21wb25lbnQgfHwgaW5zdC50YWcgPT09IEhvc3RSb290KSB7XG4gICAgICByZXR1cm4gaW5zdDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG4vKipcbiAqIEdpdmVuIGEgUmVhY3RET01Db21wb25lbnQgb3IgUmVhY3RET01UZXh0Q29tcG9uZW50LCByZXR1cm4gdGhlIGNvcnJlc3BvbmRpbmdcbiAqIERPTSBub2RlLlxuICovXG5cbmZ1bmN0aW9uIGdldE5vZGVGcm9tSW5zdGFuY2UoaW5zdCkge1xuICBpZiAoaW5zdC50YWcgPT09IEhvc3RDb21wb25lbnQgfHwgaW5zdC50YWcgPT09IEhvc3RUZXh0KSB7XG4gICAgLy8gSW4gRmliZXIgdGhpcywgaXMganVzdCB0aGUgc3RhdGUgbm9kZSByaWdodCBub3cuIFdlIGFzc3VtZSBpdCB3aWxsIGJlXG4gICAgLy8gYSBob3N0IGNvbXBvbmVudCBvciBob3N0IHRleHQuXG4gICAgcmV0dXJuIGluc3Quc3RhdGVOb2RlO1xuICB9IC8vIFdpdGhvdXQgdGhpcyBmaXJzdCBpbnZhcmlhbnQsIHBhc3NpbmcgYSBub24tRE9NLWNvbXBvbmVudCB0cmlnZ2VycyB0aGUgbmV4dFxuICAvLyBpbnZhcmlhbnQgZm9yIGEgbWlzc2luZyBwYXJlbnQsIHdoaWNoIGlzIHN1cGVyIGNvbmZ1c2luZy5cblxuXG4gIHtcbiAgICB7XG4gICAgICB0aHJvdyBFcnJvciggXCJnZXROb2RlRnJvbUluc3RhbmNlOiBJbnZhbGlkIGFyZ3VtZW50LlwiICk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBnZXRGaWJlckN1cnJlbnRQcm9wc0Zyb21Ob2RlKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGVbaW50ZXJuYWxQcm9wc0tleV0gfHwgbnVsbDtcbn1cbmZ1bmN0aW9uIHVwZGF0ZUZpYmVyUHJvcHMobm9kZSwgcHJvcHMpIHtcbiAgbm9kZVtpbnRlcm5hbFByb3BzS2V5XSA9IHByb3BzO1xufVxuZnVuY3Rpb24gZ2V0RXZlbnRMaXN0ZW5lclNldChub2RlKSB7XG4gIHZhciBlbGVtZW50TGlzdGVuZXJTZXQgPSBub2RlW2ludGVybmFsRXZlbnRIYW5kbGVyc0tleV07XG5cbiAgaWYgKGVsZW1lbnRMaXN0ZW5lclNldCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZWxlbWVudExpc3RlbmVyU2V0ID0gbm9kZVtpbnRlcm5hbEV2ZW50SGFuZGxlcnNLZXldID0gbmV3IFNldCgpO1xuICB9XG5cbiAgcmV0dXJuIGVsZW1lbnRMaXN0ZW5lclNldDtcbn1cblxudmFyIGxvZ2dlZFR5cGVGYWlsdXJlcyA9IHt9O1xudmFyIFJlYWN0RGVidWdDdXJyZW50RnJhbWUkMSA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0RGVidWdDdXJyZW50RnJhbWU7XG5cbmZ1bmN0aW9uIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KGVsZW1lbnQpIHtcbiAge1xuICAgIGlmIChlbGVtZW50KSB7XG4gICAgICB2YXIgb3duZXIgPSBlbGVtZW50Ll9vd25lcjtcbiAgICAgIHZhciBzdGFjayA9IGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVihlbGVtZW50LnR5cGUsIGVsZW1lbnQuX3NvdXJjZSwgb3duZXIgPyBvd25lci50eXBlIDogbnVsbCk7XG4gICAgICBSZWFjdERlYnVnQ3VycmVudEZyYW1lJDEuc2V0RXh0cmFTdGFja0ZyYW1lKHN0YWNrKTtcbiAgICB9IGVsc2Uge1xuICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSQxLnNldEV4dHJhU3RhY2tGcmFtZShudWxsKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY2hlY2tQcm9wVHlwZXModHlwZVNwZWNzLCB2YWx1ZXMsIGxvY2F0aW9uLCBjb21wb25lbnROYW1lLCBlbGVtZW50KSB7XG4gIHtcbiAgICAvLyAkRmxvd0ZpeE1lIFRoaXMgaXMgb2theSBidXQgRmxvdyBkb2Vzbid0IGtub3cgaXQuXG4gICAgdmFyIGhhcyA9IEZ1bmN0aW9uLmNhbGwuYmluZChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5KTtcblxuICAgIGZvciAodmFyIHR5cGVTcGVjTmFtZSBpbiB0eXBlU3BlY3MpIHtcbiAgICAgIGlmIChoYXModHlwZVNwZWNzLCB0eXBlU3BlY05hbWUpKSB7XG4gICAgICAgIHZhciBlcnJvciQxID0gdm9pZCAwOyAvLyBQcm9wIHR5cGUgdmFsaWRhdGlvbiBtYXkgdGhyb3cuIEluIGNhc2UgdGhleSBkbywgd2UgZG9uJ3Qgd2FudCB0b1xuICAgICAgICAvLyBmYWlsIHRoZSByZW5kZXIgcGhhc2Ugd2hlcmUgaXQgZGlkbid0IGZhaWwgYmVmb3JlLiBTbyB3ZSBsb2cgaXQuXG4gICAgICAgIC8vIEFmdGVyIHRoZXNlIGhhdmUgYmVlbiBjbGVhbmVkIHVwLCB3ZSdsbCBsZXQgdGhlbSB0aHJvdy5cblxuICAgICAgICB0cnkge1xuICAgICAgICAgIC8vIFRoaXMgaXMgaW50ZW50aW9uYWxseSBhbiBpbnZhcmlhbnQgdGhhdCBnZXRzIGNhdWdodC4gSXQncyB0aGUgc2FtZVxuICAgICAgICAgIC8vIGJlaGF2aW9yIGFzIHdpdGhvdXQgdGhpcyBzdGF0ZW1lbnQgZXhjZXB0IHdpdGggYSBiZXR0ZXIgbWVzc2FnZS5cbiAgICAgICAgICBpZiAodHlwZW9mIHR5cGVTcGVjc1t0eXBlU3BlY05hbWVdICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB2YXIgZXJyID0gRXJyb3IoKGNvbXBvbmVudE5hbWUgfHwgJ1JlYWN0IGNsYXNzJykgKyAnOiAnICsgbG9jYXRpb24gKyAnIHR5cGUgYCcgKyB0eXBlU3BlY05hbWUgKyAnYCBpcyBpbnZhbGlkOyAnICsgJ2l0IG11c3QgYmUgYSBmdW5jdGlvbiwgdXN1YWxseSBmcm9tIHRoZSBgcHJvcC10eXBlc2AgcGFja2FnZSwgYnV0IHJlY2VpdmVkIGAnICsgdHlwZW9mIHR5cGVTcGVjc1t0eXBlU3BlY05hbWVdICsgJ2AuJyArICdUaGlzIG9mdGVuIGhhcHBlbnMgYmVjYXVzZSBvZiB0eXBvcyBzdWNoIGFzIGBQcm9wVHlwZXMuZnVuY3Rpb25gIGluc3RlYWQgb2YgYFByb3BUeXBlcy5mdW5jYC4nKTtcbiAgICAgICAgICAgIGVyci5uYW1lID0gJ0ludmFyaWFudCBWaW9sYXRpb24nO1xuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGVycm9yJDEgPSB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSh2YWx1ZXMsIHR5cGVTcGVjTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIG51bGwsICdTRUNSRVRfRE9fTk9UX1BBU1NfVEhJU19PUl9ZT1VfV0lMTF9CRV9GSVJFRCcpO1xuICAgICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICAgIGVycm9yJDEgPSBleDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlcnJvciQxICYmICEoZXJyb3IkMSBpbnN0YW5jZW9mIEVycm9yKSkge1xuICAgICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KGVsZW1lbnQpO1xuXG4gICAgICAgICAgZXJyb3IoJyVzOiB0eXBlIHNwZWNpZmljYXRpb24gb2YgJXMnICsgJyBgJXNgIGlzIGludmFsaWQ7IHRoZSB0eXBlIGNoZWNrZXIgJyArICdmdW5jdGlvbiBtdXN0IHJldHVybiBgbnVsbGAgb3IgYW4gYEVycm9yYCBidXQgcmV0dXJuZWQgYSAlcy4gJyArICdZb3UgbWF5IGhhdmUgZm9yZ290dGVuIHRvIHBhc3MgYW4gYXJndW1lbnQgdG8gdGhlIHR5cGUgY2hlY2tlciAnICsgJ2NyZWF0b3IgKGFycmF5T2YsIGluc3RhbmNlT2YsIG9iamVjdE9mLCBvbmVPZiwgb25lT2ZUeXBlLCBhbmQgJyArICdzaGFwZSBhbGwgcmVxdWlyZSBhbiBhcmd1bWVudCkuJywgY29tcG9uZW50TmFtZSB8fCAnUmVhY3QgY2xhc3MnLCBsb2NhdGlvbiwgdHlwZVNwZWNOYW1lLCB0eXBlb2YgZXJyb3IkMSk7XG5cbiAgICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChudWxsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlcnJvciQxIGluc3RhbmNlb2YgRXJyb3IgJiYgIShlcnJvciQxLm1lc3NhZ2UgaW4gbG9nZ2VkVHlwZUZhaWx1cmVzKSkge1xuICAgICAgICAgIC8vIE9ubHkgbW9uaXRvciB0aGlzIGZhaWx1cmUgb25jZSBiZWNhdXNlIHRoZXJlIHRlbmRzIHRvIGJlIGEgbG90IG9mIHRoZVxuICAgICAgICAgIC8vIHNhbWUgZXJyb3IuXG4gICAgICAgICAgbG9nZ2VkVHlwZUZhaWx1cmVzW2Vycm9yJDEubWVzc2FnZV0gPSB0cnVlO1xuICAgICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KGVsZW1lbnQpO1xuXG4gICAgICAgICAgZXJyb3IoJ0ZhaWxlZCAlcyB0eXBlOiAlcycsIGxvY2F0aW9uLCBlcnJvciQxLm1lc3NhZ2UpO1xuXG4gICAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQobnVsbCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxudmFyIHZhbHVlU3RhY2sgPSBbXTtcbnZhciBmaWJlclN0YWNrO1xuXG57XG4gIGZpYmVyU3RhY2sgPSBbXTtcbn1cblxudmFyIGluZGV4ID0gLTE7XG5cbmZ1bmN0aW9uIGNyZWF0ZUN1cnNvcihkZWZhdWx0VmFsdWUpIHtcbiAgcmV0dXJuIHtcbiAgICBjdXJyZW50OiBkZWZhdWx0VmFsdWVcbiAgfTtcbn1cblxuZnVuY3Rpb24gcG9wKGN1cnNvciwgZmliZXIpIHtcbiAgaWYgKGluZGV4IDwgMCkge1xuICAgIHtcbiAgICAgIGVycm9yKCdVbmV4cGVjdGVkIHBvcC4nKTtcbiAgICB9XG5cbiAgICByZXR1cm47XG4gIH1cblxuICB7XG4gICAgaWYgKGZpYmVyICE9PSBmaWJlclN0YWNrW2luZGV4XSkge1xuICAgICAgZXJyb3IoJ1VuZXhwZWN0ZWQgRmliZXIgcG9wcGVkLicpO1xuICAgIH1cbiAgfVxuXG4gIGN1cnNvci5jdXJyZW50ID0gdmFsdWVTdGFja1tpbmRleF07XG4gIHZhbHVlU3RhY2tbaW5kZXhdID0gbnVsbDtcblxuICB7XG4gICAgZmliZXJTdGFja1tpbmRleF0gPSBudWxsO1xuICB9XG5cbiAgaW5kZXgtLTtcbn1cblxuZnVuY3Rpb24gcHVzaChjdXJzb3IsIHZhbHVlLCBmaWJlcikge1xuICBpbmRleCsrO1xuICB2YWx1ZVN0YWNrW2luZGV4XSA9IGN1cnNvci5jdXJyZW50O1xuXG4gIHtcbiAgICBmaWJlclN0YWNrW2luZGV4XSA9IGZpYmVyO1xuICB9XG5cbiAgY3Vyc29yLmN1cnJlbnQgPSB2YWx1ZTtcbn1cblxudmFyIHdhcm5lZEFib3V0TWlzc2luZ0dldENoaWxkQ29udGV4dDtcblxue1xuICB3YXJuZWRBYm91dE1pc3NpbmdHZXRDaGlsZENvbnRleHQgPSB7fTtcbn1cblxudmFyIGVtcHR5Q29udGV4dE9iamVjdCA9IHt9O1xuXG57XG4gIE9iamVjdC5mcmVlemUoZW1wdHlDb250ZXh0T2JqZWN0KTtcbn0gLy8gQSBjdXJzb3IgdG8gdGhlIGN1cnJlbnQgbWVyZ2VkIGNvbnRleHQgb2JqZWN0IG9uIHRoZSBzdGFjay5cblxuXG52YXIgY29udGV4dFN0YWNrQ3Vyc29yID0gY3JlYXRlQ3Vyc29yKGVtcHR5Q29udGV4dE9iamVjdCk7IC8vIEEgY3Vyc29yIHRvIGEgYm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgdGhlIGNvbnRleHQgaGFzIGNoYW5nZWQuXG5cbnZhciBkaWRQZXJmb3JtV29ya1N0YWNrQ3Vyc29yID0gY3JlYXRlQ3Vyc29yKGZhbHNlKTsgLy8gS2VlcCB0cmFjayBvZiB0aGUgcHJldmlvdXMgY29udGV4dCBvYmplY3QgdGhhdCB3YXMgb24gdGhlIHN0YWNrLlxuLy8gV2UgdXNlIHRoaXMgdG8gZ2V0IGFjY2VzcyB0byB0aGUgcGFyZW50IGNvbnRleHQgYWZ0ZXIgd2UgaGF2ZSBhbHJlYWR5XG4vLyBwdXNoZWQgdGhlIG5leHQgY29udGV4dCBwcm92aWRlciwgYW5kIG5vdyBuZWVkIHRvIG1lcmdlIHRoZWlyIGNvbnRleHRzLlxuXG52YXIgcHJldmlvdXNDb250ZXh0ID0gZW1wdHlDb250ZXh0T2JqZWN0O1xuXG5mdW5jdGlvbiBnZXRVbm1hc2tlZENvbnRleHQod29ya0luUHJvZ3Jlc3MsIENvbXBvbmVudCwgZGlkUHVzaE93bkNvbnRleHRJZlByb3ZpZGVyKSB7XG4gIHtcbiAgICBpZiAoZGlkUHVzaE93bkNvbnRleHRJZlByb3ZpZGVyICYmIGlzQ29udGV4dFByb3ZpZGVyKENvbXBvbmVudCkpIHtcbiAgICAgIC8vIElmIHRoZSBmaWJlciBpcyBhIGNvbnRleHQgcHJvdmlkZXIgaXRzZWxmLCB3aGVuIHdlIHJlYWQgaXRzIGNvbnRleHRcbiAgICAgIC8vIHdlIG1heSBoYXZlIGFscmVhZHkgcHVzaGVkIGl0cyBvd24gY2hpbGQgY29udGV4dCBvbiB0aGUgc3RhY2suIEEgY29udGV4dFxuICAgICAgLy8gcHJvdmlkZXIgc2hvdWxkIG5vdCBcInNlZVwiIGl0cyBvd24gY2hpbGQgY29udGV4dC4gVGhlcmVmb3JlIHdlIHJlYWQgdGhlXG4gICAgICAvLyBwcmV2aW91cyAocGFyZW50KSBjb250ZXh0IGluc3RlYWQgZm9yIGEgY29udGV4dCBwcm92aWRlci5cbiAgICAgIHJldHVybiBwcmV2aW91c0NvbnRleHQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNvbnRleHRTdGFja0N1cnNvci5jdXJyZW50O1xuICB9XG59XG5cbmZ1bmN0aW9uIGNhY2hlQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgdW5tYXNrZWRDb250ZXh0LCBtYXNrZWRDb250ZXh0KSB7XG4gIHtcbiAgICB2YXIgaW5zdGFuY2UgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG4gICAgaW5zdGFuY2UuX19yZWFjdEludGVybmFsTWVtb2l6ZWRVbm1hc2tlZENoaWxkQ29udGV4dCA9IHVubWFza2VkQ29udGV4dDtcbiAgICBpbnN0YW5jZS5fX3JlYWN0SW50ZXJuYWxNZW1vaXplZE1hc2tlZENoaWxkQ29udGV4dCA9IG1hc2tlZENvbnRleHQ7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0TWFza2VkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgdW5tYXNrZWRDb250ZXh0KSB7XG4gIHtcbiAgICB2YXIgdHlwZSA9IHdvcmtJblByb2dyZXNzLnR5cGU7XG4gICAgdmFyIGNvbnRleHRUeXBlcyA9IHR5cGUuY29udGV4dFR5cGVzO1xuXG4gICAgaWYgKCFjb250ZXh0VHlwZXMpIHtcbiAgICAgIHJldHVybiBlbXB0eUNvbnRleHRPYmplY3Q7XG4gICAgfSAvLyBBdm9pZCByZWNyZWF0aW5nIG1hc2tlZCBjb250ZXh0IHVubGVzcyB1bm1hc2tlZCBjb250ZXh0IGhhcyBjaGFuZ2VkLlxuICAgIC8vIEZhaWxpbmcgdG8gZG8gdGhpcyB3aWxsIHJlc3VsdCBpbiB1bm5lY2Vzc2FyeSBjYWxscyB0byBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzLlxuICAgIC8vIFRoaXMgbWF5IHRyaWdnZXIgaW5maW5pdGUgbG9vcHMgaWYgY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyBjYWxscyBzZXRTdGF0ZS5cblxuXG4gICAgdmFyIGluc3RhbmNlID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuXG4gICAgaWYgKGluc3RhbmNlICYmIGluc3RhbmNlLl9fcmVhY3RJbnRlcm5hbE1lbW9pemVkVW5tYXNrZWRDaGlsZENvbnRleHQgPT09IHVubWFza2VkQ29udGV4dCkge1xuICAgICAgcmV0dXJuIGluc3RhbmNlLl9fcmVhY3RJbnRlcm5hbE1lbW9pemVkTWFza2VkQ2hpbGRDb250ZXh0O1xuICAgIH1cblxuICAgIHZhciBjb250ZXh0ID0ge307XG5cbiAgICBmb3IgKHZhciBrZXkgaW4gY29udGV4dFR5cGVzKSB7XG4gICAgICBjb250ZXh0W2tleV0gPSB1bm1hc2tlZENvbnRleHRba2V5XTtcbiAgICB9XG5cbiAgICB7XG4gICAgICB2YXIgbmFtZSA9IGdldENvbXBvbmVudE5hbWUodHlwZSkgfHwgJ1Vua25vd24nO1xuICAgICAgY2hlY2tQcm9wVHlwZXMoY29udGV4dFR5cGVzLCBjb250ZXh0LCAnY29udGV4dCcsIG5hbWUpO1xuICAgIH0gLy8gQ2FjaGUgdW5tYXNrZWQgY29udGV4dCBzbyB3ZSBjYW4gYXZvaWQgcmVjcmVhdGluZyBtYXNrZWQgY29udGV4dCB1bmxlc3MgbmVjZXNzYXJ5LlxuICAgIC8vIENvbnRleHQgaXMgY3JlYXRlZCBiZWZvcmUgdGhlIGNsYXNzIGNvbXBvbmVudCBpcyBpbnN0YW50aWF0ZWQgc28gY2hlY2sgZm9yIGluc3RhbmNlLlxuXG5cbiAgICBpZiAoaW5zdGFuY2UpIHtcbiAgICAgIGNhY2hlQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgdW5tYXNrZWRDb250ZXh0LCBjb250ZXh0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gY29udGV4dDtcbiAgfVxufVxuXG5mdW5jdGlvbiBoYXNDb250ZXh0Q2hhbmdlZCgpIHtcbiAge1xuICAgIHJldHVybiBkaWRQZXJmb3JtV29ya1N0YWNrQ3Vyc29yLmN1cnJlbnQ7XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNDb250ZXh0UHJvdmlkZXIodHlwZSkge1xuICB7XG4gICAgdmFyIGNoaWxkQ29udGV4dFR5cGVzID0gdHlwZS5jaGlsZENvbnRleHRUeXBlcztcbiAgICByZXR1cm4gY2hpbGRDb250ZXh0VHlwZXMgIT09IG51bGwgJiYgY2hpbGRDb250ZXh0VHlwZXMgIT09IHVuZGVmaW5lZDtcbiAgfVxufVxuXG5mdW5jdGlvbiBwb3BDb250ZXh0KGZpYmVyKSB7XG4gIHtcbiAgICBwb3AoZGlkUGVyZm9ybVdvcmtTdGFja0N1cnNvciwgZmliZXIpO1xuICAgIHBvcChjb250ZXh0U3RhY2tDdXJzb3IsIGZpYmVyKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwb3BUb3BMZXZlbENvbnRleHRPYmplY3QoZmliZXIpIHtcbiAge1xuICAgIHBvcChkaWRQZXJmb3JtV29ya1N0YWNrQ3Vyc29yLCBmaWJlcik7XG4gICAgcG9wKGNvbnRleHRTdGFja0N1cnNvciwgZmliZXIpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHB1c2hUb3BMZXZlbENvbnRleHRPYmplY3QoZmliZXIsIGNvbnRleHQsIGRpZENoYW5nZSkge1xuICB7XG4gICAgaWYgKCEoY29udGV4dFN0YWNrQ3Vyc29yLmN1cnJlbnQgPT09IGVtcHR5Q29udGV4dE9iamVjdCkpIHtcbiAgICAgIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoIFwiVW5leHBlY3RlZCBjb250ZXh0IGZvdW5kIG9uIHN0YWNrLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiICk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcHVzaChjb250ZXh0U3RhY2tDdXJzb3IsIGNvbnRleHQsIGZpYmVyKTtcbiAgICBwdXNoKGRpZFBlcmZvcm1Xb3JrU3RhY2tDdXJzb3IsIGRpZENoYW5nZSwgZmliZXIpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NDaGlsZENvbnRleHQoZmliZXIsIHR5cGUsIHBhcmVudENvbnRleHQpIHtcbiAge1xuICAgIHZhciBpbnN0YW5jZSA9IGZpYmVyLnN0YXRlTm9kZTtcbiAgICB2YXIgY2hpbGRDb250ZXh0VHlwZXMgPSB0eXBlLmNoaWxkQ29udGV4dFR5cGVzOyAvLyBUT0RPIChidmF1Z2huKSBSZXBsYWNlIHRoaXMgYmVoYXZpb3Igd2l0aCBhbiBpbnZhcmlhbnQoKSBpbiB0aGUgZnV0dXJlLlxuICAgIC8vIEl0IGhhcyBvbmx5IGJlZW4gYWRkZWQgaW4gRmliZXIgdG8gbWF0Y2ggdGhlICh1bmludGVudGlvbmFsKSBiZWhhdmlvciBpbiBTdGFjay5cblxuICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuZ2V0Q2hpbGRDb250ZXh0ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB7XG4gICAgICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZSh0eXBlKSB8fCAnVW5rbm93bic7XG5cbiAgICAgICAgaWYgKCF3YXJuZWRBYm91dE1pc3NpbmdHZXRDaGlsZENvbnRleHRbY29tcG9uZW50TmFtZV0pIHtcbiAgICAgICAgICB3YXJuZWRBYm91dE1pc3NpbmdHZXRDaGlsZENvbnRleHRbY29tcG9uZW50TmFtZV0gPSB0cnVlO1xuXG4gICAgICAgICAgZXJyb3IoJyVzLmNoaWxkQ29udGV4dFR5cGVzIGlzIHNwZWNpZmllZCBidXQgdGhlcmUgaXMgbm8gZ2V0Q2hpbGRDb250ZXh0KCkgbWV0aG9kICcgKyAnb24gdGhlIGluc3RhbmNlLiBZb3UgY2FuIGVpdGhlciBkZWZpbmUgZ2V0Q2hpbGRDb250ZXh0KCkgb24gJXMgb3IgcmVtb3ZlICcgKyAnY2hpbGRDb250ZXh0VHlwZXMgZnJvbSBpdC4nLCBjb21wb25lbnROYW1lLCBjb21wb25lbnROYW1lKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcGFyZW50Q29udGV4dDtcbiAgICB9XG5cbiAgICB2YXIgY2hpbGRDb250ZXh0ID0gaW5zdGFuY2UuZ2V0Q2hpbGRDb250ZXh0KCk7XG5cbiAgICBmb3IgKHZhciBjb250ZXh0S2V5IGluIGNoaWxkQ29udGV4dCkge1xuICAgICAgaWYgKCEoY29udGV4dEtleSBpbiBjaGlsZENvbnRleHRUeXBlcykpIHtcbiAgICAgICAge1xuICAgICAgICAgIHRocm93IEVycm9yKCAoZ2V0Q29tcG9uZW50TmFtZSh0eXBlKSB8fCAnVW5rbm93bicpICsgXCIuZ2V0Q2hpbGRDb250ZXh0KCk6IGtleSBcXFwiXCIgKyBjb250ZXh0S2V5ICsgXCJcXFwiIGlzIG5vdCBkZWZpbmVkIGluIGNoaWxkQ29udGV4dFR5cGVzLlwiICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB7XG4gICAgICB2YXIgbmFtZSA9IGdldENvbXBvbmVudE5hbWUodHlwZSkgfHwgJ1Vua25vd24nO1xuICAgICAgY2hlY2tQcm9wVHlwZXMoY2hpbGRDb250ZXh0VHlwZXMsIGNoaWxkQ29udGV4dCwgJ2NoaWxkIGNvbnRleHQnLCBuYW1lKTtcbiAgICB9XG5cbiAgICByZXR1cm4gX2Fzc2lnbih7fSwgcGFyZW50Q29udGV4dCwgY2hpbGRDb250ZXh0KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwdXNoQ29udGV4dFByb3ZpZGVyKHdvcmtJblByb2dyZXNzKSB7XG4gIHtcbiAgICB2YXIgaW5zdGFuY2UgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7IC8vIFdlIHB1c2ggdGhlIGNvbnRleHQgYXMgZWFybHkgYXMgcG9zc2libGUgdG8gZW5zdXJlIHN0YWNrIGludGVncml0eS5cbiAgICAvLyBJZiB0aGUgaW5zdGFuY2UgZG9lcyBub3QgZXhpc3QgeWV0LCB3ZSB3aWxsIHB1c2ggbnVsbCBhdCBmaXJzdCxcbiAgICAvLyBhbmQgcmVwbGFjZSBpdCBvbiB0aGUgc3RhY2sgbGF0ZXIgd2hlbiBpbnZhbGlkYXRpbmcgdGhlIGNvbnRleHQuXG5cbiAgICB2YXIgbWVtb2l6ZWRNZXJnZWRDaGlsZENvbnRleHQgPSBpbnN0YW5jZSAmJiBpbnN0YW5jZS5fX3JlYWN0SW50ZXJuYWxNZW1vaXplZE1lcmdlZENoaWxkQ29udGV4dCB8fCBlbXB0eUNvbnRleHRPYmplY3Q7IC8vIFJlbWVtYmVyIHRoZSBwYXJlbnQgY29udGV4dCBzbyB3ZSBjYW4gbWVyZ2Ugd2l0aCBpdCBsYXRlci5cbiAgICAvLyBJbmhlcml0IHRoZSBwYXJlbnQncyBkaWQtcGVyZm9ybS13b3JrIHZhbHVlIHRvIGF2b2lkIGluYWR2ZXJ0ZW50bHkgYmxvY2tpbmcgdXBkYXRlcy5cblxuICAgIHByZXZpb3VzQ29udGV4dCA9IGNvbnRleHRTdGFja0N1cnNvci5jdXJyZW50O1xuICAgIHB1c2goY29udGV4dFN0YWNrQ3Vyc29yLCBtZW1vaXplZE1lcmdlZENoaWxkQ29udGV4dCwgd29ya0luUHJvZ3Jlc3MpO1xuICAgIHB1c2goZGlkUGVyZm9ybVdvcmtTdGFja0N1cnNvciwgZGlkUGVyZm9ybVdvcmtTdGFja0N1cnNvci5jdXJyZW50LCB3b3JrSW5Qcm9ncmVzcyk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW52YWxpZGF0ZUNvbnRleHRQcm92aWRlcih3b3JrSW5Qcm9ncmVzcywgdHlwZSwgZGlkQ2hhbmdlKSB7XG4gIHtcbiAgICB2YXIgaW5zdGFuY2UgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG5cbiAgICBpZiAoIWluc3RhbmNlKSB7XG4gICAgICB7XG4gICAgICAgIHRocm93IEVycm9yKCBcIkV4cGVjdGVkIHRvIGhhdmUgYW4gaW5zdGFuY2UgYnkgdGhpcyBwb2ludC4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS5cIiApO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChkaWRDaGFuZ2UpIHtcbiAgICAgIC8vIE1lcmdlIHBhcmVudCBhbmQgb3duIGNvbnRleHQuXG4gICAgICAvLyBTa2lwIHRoaXMgaWYgd2UncmUgbm90IHVwZGF0aW5nIGR1ZSB0byBzQ1UuXG4gICAgICAvLyBUaGlzIGF2b2lkcyB1bm5lY2Vzc2FyaWx5IHJlY29tcHV0aW5nIG1lbW9pemVkIHZhbHVlcy5cbiAgICAgIHZhciBtZXJnZWRDb250ZXh0ID0gcHJvY2Vzc0NoaWxkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgdHlwZSwgcHJldmlvdXNDb250ZXh0KTtcbiAgICAgIGluc3RhbmNlLl9fcmVhY3RJbnRlcm5hbE1lbW9pemVkTWVyZ2VkQ2hpbGRDb250ZXh0ID0gbWVyZ2VkQ29udGV4dDsgLy8gUmVwbGFjZSB0aGUgb2xkIChvciBlbXB0eSkgY29udGV4dCB3aXRoIHRoZSBuZXcgb25lLlxuICAgICAgLy8gSXQgaXMgaW1wb3J0YW50IHRvIHVud2luZCB0aGUgY29udGV4dCBpbiB0aGUgcmV2ZXJzZSBvcmRlci5cblxuICAgICAgcG9wKGRpZFBlcmZvcm1Xb3JrU3RhY2tDdXJzb3IsIHdvcmtJblByb2dyZXNzKTtcbiAgICAgIHBvcChjb250ZXh0U3RhY2tDdXJzb3IsIHdvcmtJblByb2dyZXNzKTsgLy8gTm93IHB1c2ggdGhlIG5ldyBjb250ZXh0IGFuZCBtYXJrIHRoYXQgaXQgaGFzIGNoYW5nZWQuXG5cbiAgICAgIHB1c2goY29udGV4dFN0YWNrQ3Vyc29yLCBtZXJnZWRDb250ZXh0LCB3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICBwdXNoKGRpZFBlcmZvcm1Xb3JrU3RhY2tDdXJzb3IsIGRpZENoYW5nZSwgd29ya0luUHJvZ3Jlc3MpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwb3AoZGlkUGVyZm9ybVdvcmtTdGFja0N1cnNvciwgd29ya0luUHJvZ3Jlc3MpO1xuICAgICAgcHVzaChkaWRQZXJmb3JtV29ya1N0YWNrQ3Vyc29yLCBkaWRDaGFuZ2UsIHdvcmtJblByb2dyZXNzKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZmluZEN1cnJlbnRVbm1hc2tlZENvbnRleHQoZmliZXIpIHtcbiAge1xuICAgIC8vIEN1cnJlbnRseSB0aGlzIGlzIG9ubHkgdXNlZCB3aXRoIHJlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyOyBub3Qgc3VyZSBpZiBpdFxuICAgIC8vIG1ha2VzIHNlbnNlIGVsc2V3aGVyZVxuICAgIGlmICghKGlzRmliZXJNb3VudGVkKGZpYmVyKSAmJiBmaWJlci50YWcgPT09IENsYXNzQ29tcG9uZW50KSkge1xuICAgICAge1xuICAgICAgICB0aHJvdyBFcnJvciggXCJFeHBlY3RlZCBzdWJ0cmVlIHBhcmVudCB0byBiZSBhIG1vdW50ZWQgY2xhc3MgY29tcG9uZW50LiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiICk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIG5vZGUgPSBmaWJlcjtcblxuICAgIGRvIHtcbiAgICAgIHN3aXRjaCAobm9kZS50YWcpIHtcbiAgICAgICAgY2FzZSBIb3N0Um9vdDpcbiAgICAgICAgICByZXR1cm4gbm9kZS5zdGF0ZU5vZGUuY29udGV4dDtcblxuICAgICAgICBjYXNlIENsYXNzQ29tcG9uZW50OlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHZhciBDb21wb25lbnQgPSBub2RlLnR5cGU7XG5cbiAgICAgICAgICAgIGlmIChpc0NvbnRleHRQcm92aWRlcihDb21wb25lbnQpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBub2RlLnN0YXRlTm9kZS5fX3JlYWN0SW50ZXJuYWxNZW1vaXplZE1lcmdlZENoaWxkQ29udGV4dDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBub2RlID0gbm9kZS5yZXR1cm47XG4gICAgfSB3aGlsZSAobm9kZSAhPT0gbnVsbCk7XG5cbiAgICB7XG4gICAgICB7XG4gICAgICAgIHRocm93IEVycm9yKCBcIkZvdW5kIHVuZXhwZWN0ZWQgZGV0YWNoZWQgc3VidHJlZSBwYXJlbnQuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCIgKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxudmFyIExlZ2FjeVJvb3QgPSAwO1xudmFyIEJsb2NraW5nUm9vdCA9IDE7XG52YXIgQ29uY3VycmVudFJvb3QgPSAyO1xuXG52YXIgcmVuZGVyZXJJRCA9IG51bGw7XG52YXIgaW5qZWN0ZWRIb29rID0gbnVsbDtcbnZhciBoYXNMb2dnZWRFcnJvciA9IGZhbHNlO1xudmFyIGlzRGV2VG9vbHNQcmVzZW50ID0gdHlwZW9mIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXyAhPT0gJ3VuZGVmaW5lZCc7XG5mdW5jdGlvbiBpbmplY3RJbnRlcm5hbHMoaW50ZXJuYWxzKSB7XG4gIGlmICh0eXBlb2YgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fID09PSAndW5kZWZpbmVkJykge1xuICAgIC8vIE5vIERldlRvb2xzXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIGhvb2sgPSBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX187XG5cbiAgaWYgKGhvb2suaXNEaXNhYmxlZCkge1xuICAgIC8vIFRoaXMgaXNuJ3QgYSByZWFsIHByb3BlcnR5IG9uIHRoZSBob29rLCBidXQgaXQgY2FuIGJlIHNldCB0byBvcHQgb3V0XG4gICAgLy8gb2YgRGV2VG9vbHMgaW50ZWdyYXRpb24gYW5kIGFzc29jaWF0ZWQgd2FybmluZ3MgYW5kIGxvZ3MuXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8zODc3XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAoIWhvb2suc3VwcG9ydHNGaWJlcikge1xuICAgIHtcbiAgICAgIGVycm9yKCdUaGUgaW5zdGFsbGVkIHZlcnNpb24gb2YgUmVhY3QgRGV2VG9vbHMgaXMgdG9vIG9sZCBhbmQgd2lsbCBub3Qgd29yayAnICsgJ3dpdGggdGhlIGN1cnJlbnQgdmVyc2lvbiBvZiBSZWFjdC4gUGxlYXNlIHVwZGF0ZSBSZWFjdCBEZXZUb29scy4gJyArICdodHRwczovL3JlYWN0anMub3JnL2xpbmsvcmVhY3QtZGV2dG9vbHMnKTtcbiAgICB9IC8vIERldlRvb2xzIGV4aXN0cywgZXZlbiB0aG91Z2ggaXQgZG9lc24ndCBzdXBwb3J0IEZpYmVyLlxuXG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHRyeSB7XG4gICAgcmVuZGVyZXJJRCA9IGhvb2suaW5qZWN0KGludGVybmFscyk7IC8vIFdlIGhhdmUgc3VjY2Vzc2Z1bGx5IGluamVjdGVkLCBzbyBub3cgaXQgaXMgc2FmZSB0byBzZXQgdXAgaG9va3MuXG5cbiAgICBpbmplY3RlZEhvb2sgPSBob29rO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICAvLyBDYXRjaCBhbGwgZXJyb3JzIGJlY2F1c2UgaXQgaXMgdW5zYWZlIHRvIHRocm93IGR1cmluZyBpbml0aWFsaXphdGlvbi5cbiAgICB7XG4gICAgICBlcnJvcignUmVhY3QgaW5zdHJ1bWVudGF0aW9uIGVuY291bnRlcmVkIGFuIGVycm9yOiAlcy4nLCBlcnIpO1xuICAgIH1cbiAgfSAvLyBEZXZUb29scyBleGlzdHNcblxuXG4gIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gb25TY2hlZHVsZVJvb3Qocm9vdCwgY2hpbGRyZW4pIHtcbiAge1xuICAgIGlmIChpbmplY3RlZEhvb2sgJiYgdHlwZW9mIGluamVjdGVkSG9vay5vblNjaGVkdWxlRmliZXJSb290ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0cnkge1xuICAgICAgICBpbmplY3RlZEhvb2sub25TY2hlZHVsZUZpYmVyUm9vdChyZW5kZXJlcklELCByb290LCBjaGlsZHJlbik7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgaWYgKCAhaGFzTG9nZ2VkRXJyb3IpIHtcbiAgICAgICAgICBoYXNMb2dnZWRFcnJvciA9IHRydWU7XG5cbiAgICAgICAgICBlcnJvcignUmVhY3QgaW5zdHJ1bWVudGF0aW9uIGVuY291bnRlcmVkIGFuIGVycm9yOiAlcycsIGVycik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIG9uQ29tbWl0Um9vdChyb290LCBwcmlvcml0eUxldmVsKSB7XG4gIGlmIChpbmplY3RlZEhvb2sgJiYgdHlwZW9mIGluamVjdGVkSG9vay5vbkNvbW1pdEZpYmVyUm9vdCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHRyeSB7XG4gICAgICB2YXIgZGlkRXJyb3IgPSAocm9vdC5jdXJyZW50LmZsYWdzICYgRGlkQ2FwdHVyZSkgPT09IERpZENhcHR1cmU7XG5cbiAgICAgIGlmIChlbmFibGVQcm9maWxlclRpbWVyKSB7XG4gICAgICAgIGluamVjdGVkSG9vay5vbkNvbW1pdEZpYmVyUm9vdChyZW5kZXJlcklELCByb290LCBwcmlvcml0eUxldmVsLCBkaWRFcnJvcik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbmplY3RlZEhvb2sub25Db21taXRGaWJlclJvb3QocmVuZGVyZXJJRCwgcm9vdCwgdW5kZWZpbmVkLCBkaWRFcnJvcik7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICB7XG4gICAgICAgIGlmICghaGFzTG9nZ2VkRXJyb3IpIHtcbiAgICAgICAgICBoYXNMb2dnZWRFcnJvciA9IHRydWU7XG5cbiAgICAgICAgICBlcnJvcignUmVhY3QgaW5zdHJ1bWVudGF0aW9uIGVuY291bnRlcmVkIGFuIGVycm9yOiAlcycsIGVycik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIG9uQ29tbWl0VW5tb3VudChmaWJlcikge1xuICBpZiAoaW5qZWN0ZWRIb29rICYmIHR5cGVvZiBpbmplY3RlZEhvb2sub25Db21taXRGaWJlclVubW91bnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICB0cnkge1xuICAgICAgaW5qZWN0ZWRIb29rLm9uQ29tbWl0RmliZXJVbm1vdW50KHJlbmRlcmVySUQsIGZpYmVyKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHtcbiAgICAgICAgaWYgKCFoYXNMb2dnZWRFcnJvcikge1xuICAgICAgICAgIGhhc0xvZ2dlZEVycm9yID0gdHJ1ZTtcblxuICAgICAgICAgIGVycm9yKCdSZWFjdCBpbnN0cnVtZW50YXRpb24gZW5jb3VudGVyZWQgYW4gZXJyb3I6ICVzJywgZXJyKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG52YXIgU2NoZWR1bGVyX3J1bldpdGhQcmlvcml0eSA9IFNjaGVkdWxlci51bnN0YWJsZV9ydW5XaXRoUHJpb3JpdHksXG4gICAgU2NoZWR1bGVyX3NjaGVkdWxlQ2FsbGJhY2sgPSBTY2hlZHVsZXIudW5zdGFibGVfc2NoZWR1bGVDYWxsYmFjayxcbiAgICBTY2hlZHVsZXJfY2FuY2VsQ2FsbGJhY2sgPSBTY2hlZHVsZXIudW5zdGFibGVfY2FuY2VsQ2FsbGJhY2ssXG4gICAgU2NoZWR1bGVyX3Nob3VsZFlpZWxkID0gU2NoZWR1bGVyLnVuc3RhYmxlX3Nob3VsZFlpZWxkLFxuICAgIFNjaGVkdWxlcl9yZXF1ZXN0UGFpbnQgPSBTY2hlZHVsZXIudW5zdGFibGVfcmVxdWVzdFBhaW50LFxuICAgIFNjaGVkdWxlcl9ub3ckMSA9IFNjaGVkdWxlci51bnN0YWJsZV9ub3csXG4gICAgU2NoZWR1bGVyX2dldEN1cnJlbnRQcmlvcml0eUxldmVsID0gU2NoZWR1bGVyLnVuc3RhYmxlX2dldEN1cnJlbnRQcmlvcml0eUxldmVsLFxuICAgIFNjaGVkdWxlcl9JbW1lZGlhdGVQcmlvcml0eSA9IFNjaGVkdWxlci51bnN0YWJsZV9JbW1lZGlhdGVQcmlvcml0eSxcbiAgICBTY2hlZHVsZXJfVXNlckJsb2NraW5nUHJpb3JpdHkgPSBTY2hlZHVsZXIudW5zdGFibGVfVXNlckJsb2NraW5nUHJpb3JpdHksXG4gICAgU2NoZWR1bGVyX05vcm1hbFByaW9yaXR5ID0gU2NoZWR1bGVyLnVuc3RhYmxlX05vcm1hbFByaW9yaXR5LFxuICAgIFNjaGVkdWxlcl9Mb3dQcmlvcml0eSA9IFNjaGVkdWxlci51bnN0YWJsZV9Mb3dQcmlvcml0eSxcbiAgICBTY2hlZHVsZXJfSWRsZVByaW9yaXR5ID0gU2NoZWR1bGVyLnVuc3RhYmxlX0lkbGVQcmlvcml0eTtcblxue1xuICAvLyBQcm92aWRlIGV4cGxpY2l0IGVycm9yIG1lc3NhZ2Ugd2hlbiBwcm9kdWN0aW9uK3Byb2ZpbGluZyBidW5kbGUgb2YgZS5nLlxuICAvLyByZWFjdC1kb20gaXMgdXNlZCB3aXRoIHByb2R1Y3Rpb24gKG5vbi1wcm9maWxpbmcpIGJ1bmRsZSBvZlxuICAvLyBzY2hlZHVsZXIvdHJhY2luZ1xuICBpZiAoISh0cmFjaW5nLl9faW50ZXJhY3Rpb25zUmVmICE9IG51bGwgJiYgdHJhY2luZy5fX2ludGVyYWN0aW9uc1JlZi5jdXJyZW50ICE9IG51bGwpKSB7XG4gICAge1xuICAgICAgdGhyb3cgRXJyb3IoIFwiSXQgaXMgbm90IHN1cHBvcnRlZCB0byBydW4gdGhlIHByb2ZpbGluZyB2ZXJzaW9uIG9mIGEgcmVuZGVyZXIgKGZvciBleGFtcGxlLCBgcmVhY3QtZG9tL3Byb2ZpbGluZ2ApIHdpdGhvdXQgYWxzbyByZXBsYWNpbmcgdGhlIGBzY2hlZHVsZXIvdHJhY2luZ2AgbW9kdWxlIHdpdGggYHNjaGVkdWxlci90cmFjaW5nLXByb2ZpbGluZ2AuIFlvdXIgYnVuZGxlciBtaWdodCBoYXZlIGEgc2V0dGluZyBmb3IgYWxpYXNpbmcgYm90aCBtb2R1bGVzLiBMZWFybiBtb3JlIGF0IGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9wcm9maWxpbmdcIiApO1xuICAgIH1cbiAgfVxufVxuXG52YXIgZmFrZUNhbGxiYWNrTm9kZSA9IHt9OyAvLyBFeGNlcHQgZm9yIE5vUHJpb3JpdHksIHRoZXNlIGNvcnJlc3BvbmQgdG8gU2NoZWR1bGVyIHByaW9yaXRpZXMuIFdlIHVzZVxuLy8gYXNjZW5kaW5nIG51bWJlcnMgc28gd2UgY2FuIGNvbXBhcmUgdGhlbSBsaWtlIG51bWJlcnMuIFRoZXkgc3RhcnQgYXQgOTAgdG9cbi8vIGF2b2lkIGNsYXNoaW5nIHdpdGggU2NoZWR1bGVyJ3MgcHJpb3JpdGllcy5cblxudmFyIEltbWVkaWF0ZVByaW9yaXR5JDEgPSA5OTtcbnZhciBVc2VyQmxvY2tpbmdQcmlvcml0eSQyID0gOTg7XG52YXIgTm9ybWFsUHJpb3JpdHkkMSA9IDk3O1xudmFyIExvd1ByaW9yaXR5JDEgPSA5NjtcbnZhciBJZGxlUHJpb3JpdHkkMSA9IDk1OyAvLyBOb1ByaW9yaXR5IGlzIHRoZSBhYnNlbmNlIG9mIHByaW9yaXR5LiBBbHNvIFJlYWN0LW9ubHkuXG5cbnZhciBOb1ByaW9yaXR5JDEgPSA5MDtcbnZhciBzaG91bGRZaWVsZCA9IFNjaGVkdWxlcl9zaG91bGRZaWVsZDtcbnZhciByZXF1ZXN0UGFpbnQgPSAvLyBGYWxsIGJhY2sgZ3JhY2VmdWxseSBpZiB3ZSdyZSBydW5uaW5nIGFuIG9sZGVyIHZlcnNpb24gb2YgU2NoZWR1bGVyLlxuU2NoZWR1bGVyX3JlcXVlc3RQYWludCAhPT0gdW5kZWZpbmVkID8gU2NoZWR1bGVyX3JlcXVlc3RQYWludCA6IGZ1bmN0aW9uICgpIHt9O1xudmFyIHN5bmNRdWV1ZSA9IG51bGw7XG52YXIgaW1tZWRpYXRlUXVldWVDYWxsYmFja05vZGUgPSBudWxsO1xudmFyIGlzRmx1c2hpbmdTeW5jUXVldWUgPSBmYWxzZTtcbnZhciBpbml0aWFsVGltZU1zJDEgPSBTY2hlZHVsZXJfbm93JDEoKTsgLy8gSWYgdGhlIGluaXRpYWwgdGltZXN0YW1wIGlzIHJlYXNvbmFibHkgc21hbGwsIHVzZSBTY2hlZHVsZXIncyBgbm93YCBkaXJlY3RseS5cbi8vIFRoaXMgd2lsbCBiZSB0aGUgY2FzZSBmb3IgbW9kZXJuIGJyb3dzZXJzIHRoYXQgc3VwcG9ydCBgcGVyZm9ybWFuY2Uubm93YC4gSW5cbi8vIG9sZGVyIGJyb3dzZXJzLCBTY2hlZHVsZXIgZmFsbHMgYmFjayB0byBgRGF0ZS5ub3dgLCB3aGljaCByZXR1cm5zIGEgVW5peFxuLy8gdGltZXN0YW1wLiBJbiB0aGF0IGNhc2UsIHN1YnRyYWN0IHRoZSBtb2R1bGUgaW5pdGlhbGl6YXRpb24gdGltZSB0byBzaW11bGF0ZVxuLy8gdGhlIGJlaGF2aW9yIG9mIHBlcmZvcm1hbmNlLm5vdyBhbmQga2VlcCBvdXIgdGltZXMgc21hbGwgZW5vdWdoIHRvIGZpdFxuLy8gd2l0aGluIDMyIGJpdHMuXG4vLyBUT0RPOiBDb25zaWRlciBsaWZ0aW5nIHRoaXMgaW50byBTY2hlZHVsZXIuXG5cbnZhciBub3cgPSBpbml0aWFsVGltZU1zJDEgPCAxMDAwMCA/IFNjaGVkdWxlcl9ub3ckMSA6IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIFNjaGVkdWxlcl9ub3ckMSgpIC0gaW5pdGlhbFRpbWVNcyQxO1xufTtcbmZ1bmN0aW9uIGdldEN1cnJlbnRQcmlvcml0eUxldmVsKCkge1xuICBzd2l0Y2ggKFNjaGVkdWxlcl9nZXRDdXJyZW50UHJpb3JpdHlMZXZlbCgpKSB7XG4gICAgY2FzZSBTY2hlZHVsZXJfSW1tZWRpYXRlUHJpb3JpdHk6XG4gICAgICByZXR1cm4gSW1tZWRpYXRlUHJpb3JpdHkkMTtcblxuICAgIGNhc2UgU2NoZWR1bGVyX1VzZXJCbG9ja2luZ1ByaW9yaXR5OlxuICAgICAgcmV0dXJuIFVzZXJCbG9ja2luZ1ByaW9yaXR5JDI7XG5cbiAgICBjYXNlIFNjaGVkdWxlcl9Ob3JtYWxQcmlvcml0eTpcbiAgICAgIHJldHVybiBOb3JtYWxQcmlvcml0eSQxO1xuXG4gICAgY2FzZSBTY2hlZHVsZXJfTG93UHJpb3JpdHk6XG4gICAgICByZXR1cm4gTG93UHJpb3JpdHkkMTtcblxuICAgIGNhc2UgU2NoZWR1bGVyX0lkbGVQcmlvcml0eTpcbiAgICAgIHJldHVybiBJZGxlUHJpb3JpdHkkMTtcblxuICAgIGRlZmF1bHQ6XG4gICAgICB7XG4gICAgICAgIHtcbiAgICAgICAgICB0aHJvdyBFcnJvciggXCJVbmtub3duIHByaW9yaXR5IGxldmVsLlwiICk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICB9XG59XG5cbmZ1bmN0aW9uIHJlYWN0UHJpb3JpdHlUb1NjaGVkdWxlclByaW9yaXR5KHJlYWN0UHJpb3JpdHlMZXZlbCkge1xuICBzd2l0Y2ggKHJlYWN0UHJpb3JpdHlMZXZlbCkge1xuICAgIGNhc2UgSW1tZWRpYXRlUHJpb3JpdHkkMTpcbiAgICAgIHJldHVybiBTY2hlZHVsZXJfSW1tZWRpYXRlUHJpb3JpdHk7XG5cbiAgICBjYXNlIFVzZXJCbG9ja2luZ1ByaW9yaXR5JDI6XG4gICAgICByZXR1cm4gU2NoZWR1bGVyX1VzZXJCbG9ja2luZ1ByaW9yaXR5O1xuXG4gICAgY2FzZSBOb3JtYWxQcmlvcml0eSQxOlxuICAgICAgcmV0dXJuIFNjaGVkdWxlcl9Ob3JtYWxQcmlvcml0eTtcblxuICAgIGNhc2UgTG93UHJpb3JpdHkkMTpcbiAgICAgIHJldHVybiBTY2hlZHVsZXJfTG93UHJpb3JpdHk7XG5cbiAgICBjYXNlIElkbGVQcmlvcml0eSQxOlxuICAgICAgcmV0dXJuIFNjaGVkdWxlcl9JZGxlUHJpb3JpdHk7XG5cbiAgICBkZWZhdWx0OlxuICAgICAge1xuICAgICAgICB7XG4gICAgICAgICAgdGhyb3cgRXJyb3IoIFwiVW5rbm93biBwcmlvcml0eSBsZXZlbC5cIiApO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgfVxufVxuXG5mdW5jdGlvbiBydW5XaXRoUHJpb3JpdHkkMShyZWFjdFByaW9yaXR5TGV2ZWwsIGZuKSB7XG4gIHZhciBwcmlvcml0eUxldmVsID0gcmVhY3RQcmlvcml0eVRvU2NoZWR1bGVyUHJpb3JpdHkocmVhY3RQcmlvcml0eUxldmVsKTtcbiAgcmV0dXJuIFNjaGVkdWxlcl9ydW5XaXRoUHJpb3JpdHkocHJpb3JpdHlMZXZlbCwgZm4pO1xufVxuZnVuY3Rpb24gc2NoZWR1bGVDYWxsYmFjayhyZWFjdFByaW9yaXR5TGV2ZWwsIGNhbGxiYWNrLCBvcHRpb25zKSB7XG4gIHZhciBwcmlvcml0eUxldmVsID0gcmVhY3RQcmlvcml0eVRvU2NoZWR1bGVyUHJpb3JpdHkocmVhY3RQcmlvcml0eUxldmVsKTtcbiAgcmV0dXJuIFNjaGVkdWxlcl9zY2hlZHVsZUNhbGxiYWNrKHByaW9yaXR5TGV2ZWwsIGNhbGxiYWNrLCBvcHRpb25zKTtcbn1cbmZ1bmN0aW9uIHNjaGVkdWxlU3luY0NhbGxiYWNrKGNhbGxiYWNrKSB7XG4gIC8vIFB1c2ggdGhpcyBjYWxsYmFjayBpbnRvIGFuIGludGVybmFsIHF1ZXVlLiBXZSdsbCBmbHVzaCB0aGVzZSBlaXRoZXIgaW5cbiAgLy8gdGhlIG5leHQgdGljaywgb3IgZWFybGllciBpZiBzb21ldGhpbmcgY2FsbHMgYGZsdXNoU3luY0NhbGxiYWNrUXVldWVgLlxuICBpZiAoc3luY1F1ZXVlID09PSBudWxsKSB7XG4gICAgc3luY1F1ZXVlID0gW2NhbGxiYWNrXTsgLy8gRmx1c2ggdGhlIHF1ZXVlIGluIHRoZSBuZXh0IHRpY2ssIGF0IHRoZSBlYXJsaWVzdC5cblxuICAgIGltbWVkaWF0ZVF1ZXVlQ2FsbGJhY2tOb2RlID0gU2NoZWR1bGVyX3NjaGVkdWxlQ2FsbGJhY2soU2NoZWR1bGVyX0ltbWVkaWF0ZVByaW9yaXR5LCBmbHVzaFN5bmNDYWxsYmFja1F1ZXVlSW1wbCk7XG4gIH0gZWxzZSB7XG4gICAgLy8gUHVzaCBvbnRvIGV4aXN0aW5nIHF1ZXVlLiBEb24ndCBuZWVkIHRvIHNjaGVkdWxlIGEgY2FsbGJhY2sgYmVjYXVzZVxuICAgIC8vIHdlIGFscmVhZHkgc2NoZWR1bGVkIG9uZSB3aGVuIHdlIGNyZWF0ZWQgdGhlIHF1ZXVlLlxuICAgIHN5bmNRdWV1ZS5wdXNoKGNhbGxiYWNrKTtcbiAgfVxuXG4gIHJldHVybiBmYWtlQ2FsbGJhY2tOb2RlO1xufVxuZnVuY3Rpb24gY2FuY2VsQ2FsbGJhY2soY2FsbGJhY2tOb2RlKSB7XG4gIGlmIChjYWxsYmFja05vZGUgIT09IGZha2VDYWxsYmFja05vZGUpIHtcbiAgICBTY2hlZHVsZXJfY2FuY2VsQ2FsbGJhY2soY2FsbGJhY2tOb2RlKTtcbiAgfVxufVxuZnVuY3Rpb24gZmx1c2hTeW5jQ2FsbGJhY2tRdWV1ZSgpIHtcbiAgaWYgKGltbWVkaWF0ZVF1ZXVlQ2FsbGJhY2tOb2RlICE9PSBudWxsKSB7XG4gICAgdmFyIG5vZGUgPSBpbW1lZGlhdGVRdWV1ZUNhbGxiYWNrTm9kZTtcbiAgICBpbW1lZGlhdGVRdWV1ZUNhbGxiYWNrTm9kZSA9IG51bGw7XG4gICAgU2NoZWR1bGVyX2NhbmNlbENhbGxiYWNrKG5vZGUpO1xuICB9XG5cbiAgZmx1c2hTeW5jQ2FsbGJhY2tRdWV1ZUltcGwoKTtcbn1cblxuZnVuY3Rpb24gZmx1c2hTeW5jQ2FsbGJhY2tRdWV1ZUltcGwoKSB7XG4gIGlmICghaXNGbHVzaGluZ1N5bmNRdWV1ZSAmJiBzeW5jUXVldWUgIT09IG51bGwpIHtcbiAgICAvLyBQcmV2ZW50IHJlLWVudHJhbmN5LlxuICAgIGlzRmx1c2hpbmdTeW5jUXVldWUgPSB0cnVlO1xuICAgIHZhciBpID0gMDtcblxuICAgIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciBfaXNTeW5jMiA9IHRydWU7XG4gICAgICAgIHZhciBfcXVldWUgPSBzeW5jUXVldWU7XG4gICAgICAgIHJ1bldpdGhQcmlvcml0eSQxKEltbWVkaWF0ZVByaW9yaXR5JDEsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBmb3IgKDsgaSA8IF9xdWV1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGNhbGxiYWNrID0gX3F1ZXVlW2ldO1xuXG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgIGNhbGxiYWNrID0gY2FsbGJhY2soX2lzU3luYzIpO1xuICAgICAgICAgICAgfSB3aGlsZSAoY2FsbGJhY2sgIT09IG51bGwpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHN5bmNRdWV1ZSA9IG51bGw7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAvLyBJZiBzb21ldGhpbmcgdGhyb3dzLCBsZWF2ZSB0aGUgcmVtYWluaW5nIGNhbGxiYWNrcyBvbiB0aGUgcXVldWUuXG4gICAgICAgIGlmIChzeW5jUXVldWUgIT09IG51bGwpIHtcbiAgICAgICAgICBzeW5jUXVldWUgPSBzeW5jUXVldWUuc2xpY2UoaSArIDEpO1xuICAgICAgICB9IC8vIFJlc3VtZSBmbHVzaGluZyBpbiB0aGUgbmV4dCB0aWNrXG5cblxuICAgICAgICBTY2hlZHVsZXJfc2NoZWR1bGVDYWxsYmFjayhTY2hlZHVsZXJfSW1tZWRpYXRlUHJpb3JpdHksIGZsdXNoU3luY0NhbGxiYWNrUXVldWUpO1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGlzRmx1c2hpbmdTeW5jUXVldWUgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLy8gVE9ETzogdGhpcyBpcyBzcGVjaWFsIGJlY2F1c2UgaXQgZ2V0cyBpbXBvcnRlZCBkdXJpbmcgYnVpbGQuXG52YXIgUmVhY3RWZXJzaW9uID0gJzE3LjAuMic7XG5cbnZhciBOb01vZGUgPSAwO1xudmFyIFN0cmljdE1vZGUgPSAxOyAvLyBUT0RPOiBSZW1vdmUgQmxvY2tpbmdNb2RlIGFuZCBDb25jdXJyZW50TW9kZSBieSByZWFkaW5nIGZyb20gdGhlIHJvb3Rcbi8vIHRhZyBpbnN0ZWFkXG5cbnZhciBCbG9ja2luZ01vZGUgPSAyO1xudmFyIENvbmN1cnJlbnRNb2RlID0gNDtcbnZhciBQcm9maWxlTW9kZSA9IDg7XG52YXIgRGVidWdUcmFjaW5nTW9kZSA9IDE2O1xuXG52YXIgUmVhY3RDdXJyZW50QmF0Y2hDb25maWcgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdEN1cnJlbnRCYXRjaENvbmZpZztcbnZhciBOb1RyYW5zaXRpb24gPSAwO1xuZnVuY3Rpb24gcmVxdWVzdEN1cnJlbnRUcmFuc2l0aW9uKCkge1xuICByZXR1cm4gUmVhY3RDdXJyZW50QmF0Y2hDb25maWcudHJhbnNpdGlvbjtcbn1cblxudmFyIFJlYWN0U3RyaWN0TW9kZVdhcm5pbmdzID0ge1xuICByZWNvcmRVbnNhZmVMaWZlY3ljbGVXYXJuaW5nczogZnVuY3Rpb24gKGZpYmVyLCBpbnN0YW5jZSkge30sXG4gIGZsdXNoUGVuZGluZ1Vuc2FmZUxpZmVjeWNsZVdhcm5pbmdzOiBmdW5jdGlvbiAoKSB7fSxcbiAgcmVjb3JkTGVnYWN5Q29udGV4dFdhcm5pbmc6IGZ1bmN0aW9uIChmaWJlciwgaW5zdGFuY2UpIHt9LFxuICBmbHVzaExlZ2FjeUNvbnRleHRXYXJuaW5nOiBmdW5jdGlvbiAoKSB7fSxcbiAgZGlzY2FyZFBlbmRpbmdXYXJuaW5nczogZnVuY3Rpb24gKCkge31cbn07XG5cbntcbiAgdmFyIGZpbmRTdHJpY3RSb290ID0gZnVuY3Rpb24gKGZpYmVyKSB7XG4gICAgdmFyIG1heWJlU3RyaWN0Um9vdCA9IG51bGw7XG4gICAgdmFyIG5vZGUgPSBmaWJlcjtcblxuICAgIHdoaWxlIChub2RlICE9PSBudWxsKSB7XG4gICAgICBpZiAobm9kZS5tb2RlICYgU3RyaWN0TW9kZSkge1xuICAgICAgICBtYXliZVN0cmljdFJvb3QgPSBub2RlO1xuICAgICAgfVxuXG4gICAgICBub2RlID0gbm9kZS5yZXR1cm47XG4gICAgfVxuXG4gICAgcmV0dXJuIG1heWJlU3RyaWN0Um9vdDtcbiAgfTtcblxuICB2YXIgc2V0VG9Tb3J0ZWRTdHJpbmcgPSBmdW5jdGlvbiAoc2V0KSB7XG4gICAgdmFyIGFycmF5ID0gW107XG4gICAgc2V0LmZvckVhY2goZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICBhcnJheS5wdXNoKHZhbHVlKTtcbiAgICB9KTtcbiAgICByZXR1cm4gYXJyYXkuc29ydCgpLmpvaW4oJywgJyk7XG4gIH07XG5cbiAgdmFyIHBlbmRpbmdDb21wb25lbnRXaWxsTW91bnRXYXJuaW5ncyA9IFtdO1xuICB2YXIgcGVuZGluZ1VOU0FGRV9Db21wb25lbnRXaWxsTW91bnRXYXJuaW5ncyA9IFtdO1xuICB2YXIgcGVuZGluZ0NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNXYXJuaW5ncyA9IFtdO1xuICB2YXIgcGVuZGluZ1VOU0FGRV9Db21wb25lbnRXaWxsUmVjZWl2ZVByb3BzV2FybmluZ3MgPSBbXTtcbiAgdmFyIHBlbmRpbmdDb21wb25lbnRXaWxsVXBkYXRlV2FybmluZ3MgPSBbXTtcbiAgdmFyIHBlbmRpbmdVTlNBRkVfQ29tcG9uZW50V2lsbFVwZGF0ZVdhcm5pbmdzID0gW107IC8vIFRyYWNrcyBjb21wb25lbnRzIHdlIGhhdmUgYWxyZWFkeSB3YXJuZWQgYWJvdXQuXG5cbiAgdmFyIGRpZFdhcm5BYm91dFVuc2FmZUxpZmVjeWNsZXMgPSBuZXcgU2V0KCk7XG5cbiAgUmVhY3RTdHJpY3RNb2RlV2FybmluZ3MucmVjb3JkVW5zYWZlTGlmZWN5Y2xlV2FybmluZ3MgPSBmdW5jdGlvbiAoZmliZXIsIGluc3RhbmNlKSB7XG4gICAgLy8gRGVkdXAgc3RyYXRlZ3k6IFdhcm4gb25jZSBwZXIgY29tcG9uZW50LlxuICAgIGlmIChkaWRXYXJuQWJvdXRVbnNhZmVMaWZlY3ljbGVzLmhhcyhmaWJlci50eXBlKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50V2lsbE1vdW50ID09PSAnZnVuY3Rpb24nICYmIC8vIERvbid0IHdhcm4gYWJvdXQgcmVhY3QtbGlmZWN5Y2xlcy1jb21wYXQgcG9seWZpbGxlZCBjb21wb25lbnRzLlxuICAgIGluc3RhbmNlLmNvbXBvbmVudFdpbGxNb3VudC5fX3N1cHByZXNzRGVwcmVjYXRpb25XYXJuaW5nICE9PSB0cnVlKSB7XG4gICAgICBwZW5kaW5nQ29tcG9uZW50V2lsbE1vdW50V2FybmluZ3MucHVzaChmaWJlcik7XG4gICAgfVxuXG4gICAgaWYgKGZpYmVyLm1vZGUgJiBTdHJpY3RNb2RlICYmIHR5cGVvZiBpbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbE1vdW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBwZW5kaW5nVU5TQUZFX0NvbXBvbmVudFdpbGxNb3VudFdhcm5pbmdzLnB1c2goZmliZXIpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyA9PT0gJ2Z1bmN0aW9uJyAmJiBpbnN0YW5jZS5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzLl9fc3VwcHJlc3NEZXByZWNhdGlvbldhcm5pbmcgIT09IHRydWUpIHtcbiAgICAgIHBlbmRpbmdDb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzV2FybmluZ3MucHVzaChmaWJlcik7XG4gICAgfVxuXG4gICAgaWYgKGZpYmVyLm1vZGUgJiBTdHJpY3RNb2RlICYmIHR5cGVvZiBpbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcGVuZGluZ1VOU0FGRV9Db21wb25lbnRXaWxsUmVjZWl2ZVByb3BzV2FybmluZ3MucHVzaChmaWJlcik7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnRXaWxsVXBkYXRlID09PSAnZnVuY3Rpb24nICYmIGluc3RhbmNlLmNvbXBvbmVudFdpbGxVcGRhdGUuX19zdXBwcmVzc0RlcHJlY2F0aW9uV2FybmluZyAhPT0gdHJ1ZSkge1xuICAgICAgcGVuZGluZ0NvbXBvbmVudFdpbGxVcGRhdGVXYXJuaW5ncy5wdXNoKGZpYmVyKTtcbiAgICB9XG5cbiAgICBpZiAoZmliZXIubW9kZSAmIFN0cmljdE1vZGUgJiYgdHlwZW9mIGluc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsVXBkYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBwZW5kaW5nVU5TQUZFX0NvbXBvbmVudFdpbGxVcGRhdGVXYXJuaW5ncy5wdXNoKGZpYmVyKTtcbiAgICB9XG4gIH07XG5cbiAgUmVhY3RTdHJpY3RNb2RlV2FybmluZ3MuZmx1c2hQZW5kaW5nVW5zYWZlTGlmZWN5Y2xlV2FybmluZ3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgLy8gV2UgZG8gYW4gaW5pdGlhbCBwYXNzIHRvIGdhdGhlciBjb21wb25lbnQgbmFtZXNcbiAgICB2YXIgY29tcG9uZW50V2lsbE1vdW50VW5pcXVlTmFtZXMgPSBuZXcgU2V0KCk7XG5cbiAgICBpZiAocGVuZGluZ0NvbXBvbmVudFdpbGxNb3VudFdhcm5pbmdzLmxlbmd0aCA+IDApIHtcbiAgICAgIHBlbmRpbmdDb21wb25lbnRXaWxsTW91bnRXYXJuaW5ncy5mb3JFYWNoKGZ1bmN0aW9uIChmaWJlcikge1xuICAgICAgICBjb21wb25lbnRXaWxsTW91bnRVbmlxdWVOYW1lcy5hZGQoZ2V0Q29tcG9uZW50TmFtZShmaWJlci50eXBlKSB8fCAnQ29tcG9uZW50Jyk7XG4gICAgICAgIGRpZFdhcm5BYm91dFVuc2FmZUxpZmVjeWNsZXMuYWRkKGZpYmVyLnR5cGUpO1xuICAgICAgfSk7XG4gICAgICBwZW5kaW5nQ29tcG9uZW50V2lsbE1vdW50V2FybmluZ3MgPSBbXTtcbiAgICB9XG5cbiAgICB2YXIgVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudFVuaXF1ZU5hbWVzID0gbmV3IFNldCgpO1xuXG4gICAgaWYgKHBlbmRpbmdVTlNBRkVfQ29tcG9uZW50V2lsbE1vdW50V2FybmluZ3MubGVuZ3RoID4gMCkge1xuICAgICAgcGVuZGluZ1VOU0FGRV9Db21wb25lbnRXaWxsTW91bnRXYXJuaW5ncy5mb3JFYWNoKGZ1bmN0aW9uIChmaWJlcikge1xuICAgICAgICBVTlNBRkVfY29tcG9uZW50V2lsbE1vdW50VW5pcXVlTmFtZXMuYWRkKGdldENvbXBvbmVudE5hbWUoZmliZXIudHlwZSkgfHwgJ0NvbXBvbmVudCcpO1xuICAgICAgICBkaWRXYXJuQWJvdXRVbnNhZmVMaWZlY3ljbGVzLmFkZChmaWJlci50eXBlKTtcbiAgICAgIH0pO1xuICAgICAgcGVuZGluZ1VOU0FGRV9Db21wb25lbnRXaWxsTW91bnRXYXJuaW5ncyA9IFtdO1xuICAgIH1cblxuICAgIHZhciBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzVW5pcXVlTmFtZXMgPSBuZXcgU2V0KCk7XG5cbiAgICBpZiAocGVuZGluZ0NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNXYXJuaW5ncy5sZW5ndGggPiAwKSB7XG4gICAgICBwZW5kaW5nQ29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc1dhcm5pbmdzLmZvckVhY2goZnVuY3Rpb24gKGZpYmVyKSB7XG4gICAgICAgIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNVbmlxdWVOYW1lcy5hZGQoZ2V0Q29tcG9uZW50TmFtZShmaWJlci50eXBlKSB8fCAnQ29tcG9uZW50Jyk7XG4gICAgICAgIGRpZFdhcm5BYm91dFVuc2FmZUxpZmVjeWNsZXMuYWRkKGZpYmVyLnR5cGUpO1xuICAgICAgfSk7XG4gICAgICBwZW5kaW5nQ29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc1dhcm5pbmdzID0gW107XG4gICAgfVxuXG4gICAgdmFyIFVOU0FGRV9jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzVW5pcXVlTmFtZXMgPSBuZXcgU2V0KCk7XG5cbiAgICBpZiAocGVuZGluZ1VOU0FGRV9Db21wb25lbnRXaWxsUmVjZWl2ZVByb3BzV2FybmluZ3MubGVuZ3RoID4gMCkge1xuICAgICAgcGVuZGluZ1VOU0FGRV9Db21wb25lbnRXaWxsUmVjZWl2ZVByb3BzV2FybmluZ3MuZm9yRWFjaChmdW5jdGlvbiAoZmliZXIpIHtcbiAgICAgICAgVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNVbmlxdWVOYW1lcy5hZGQoZ2V0Q29tcG9uZW50TmFtZShmaWJlci50eXBlKSB8fCAnQ29tcG9uZW50Jyk7XG4gICAgICAgIGRpZFdhcm5BYm91dFVuc2FmZUxpZmVjeWNsZXMuYWRkKGZpYmVyLnR5cGUpO1xuICAgICAgfSk7XG4gICAgICBwZW5kaW5nVU5TQUZFX0NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNXYXJuaW5ncyA9IFtdO1xuICAgIH1cblxuICAgIHZhciBjb21wb25lbnRXaWxsVXBkYXRlVW5pcXVlTmFtZXMgPSBuZXcgU2V0KCk7XG5cbiAgICBpZiAocGVuZGluZ0NvbXBvbmVudFdpbGxVcGRhdGVXYXJuaW5ncy5sZW5ndGggPiAwKSB7XG4gICAgICBwZW5kaW5nQ29tcG9uZW50V2lsbFVwZGF0ZVdhcm5pbmdzLmZvckVhY2goZnVuY3Rpb24gKGZpYmVyKSB7XG4gICAgICAgIGNvbXBvbmVudFdpbGxVcGRhdGVVbmlxdWVOYW1lcy5hZGQoZ2V0Q29tcG9uZW50TmFtZShmaWJlci50eXBlKSB8fCAnQ29tcG9uZW50Jyk7XG4gICAgICAgIGRpZFdhcm5BYm91dFVuc2FmZUxpZmVjeWNsZXMuYWRkKGZpYmVyLnR5cGUpO1xuICAgICAgfSk7XG4gICAgICBwZW5kaW5nQ29tcG9uZW50V2lsbFVwZGF0ZVdhcm5pbmdzID0gW107XG4gICAgfVxuXG4gICAgdmFyIFVOU0FGRV9jb21wb25lbnRXaWxsVXBkYXRlVW5pcXVlTmFtZXMgPSBuZXcgU2V0KCk7XG5cbiAgICBpZiAocGVuZGluZ1VOU0FGRV9Db21wb25lbnRXaWxsVXBkYXRlV2FybmluZ3MubGVuZ3RoID4gMCkge1xuICAgICAgcGVuZGluZ1VOU0FGRV9Db21wb25lbnRXaWxsVXBkYXRlV2FybmluZ3MuZm9yRWFjaChmdW5jdGlvbiAoZmliZXIpIHtcbiAgICAgICAgVU5TQUZFX2NvbXBvbmVudFdpbGxVcGRhdGVVbmlxdWVOYW1lcy5hZGQoZ2V0Q29tcG9uZW50TmFtZShmaWJlci50eXBlKSB8fCAnQ29tcG9uZW50Jyk7XG4gICAgICAgIGRpZFdhcm5BYm91dFVuc2FmZUxpZmVjeWNsZXMuYWRkKGZpYmVyLnR5cGUpO1xuICAgICAgfSk7XG4gICAgICBwZW5kaW5nVU5TQUZFX0NvbXBvbmVudFdpbGxVcGRhdGVXYXJuaW5ncyA9IFtdO1xuICAgIH0gLy8gRmluYWxseSwgd2UgZmx1c2ggYWxsIHRoZSB3YXJuaW5nc1xuICAgIC8vIFVOU0FGRV8gb25lcyBiZWZvcmUgdGhlIGRlcHJlY2F0ZWQgb25lcywgc2luY2UgdGhleSdsbCBiZSAnbG91ZGVyJ1xuXG5cbiAgICBpZiAoVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudFVuaXF1ZU5hbWVzLnNpemUgPiAwKSB7XG4gICAgICB2YXIgc29ydGVkTmFtZXMgPSBzZXRUb1NvcnRlZFN0cmluZyhVTlNBRkVfY29tcG9uZW50V2lsbE1vdW50VW5pcXVlTmFtZXMpO1xuXG4gICAgICBlcnJvcignVXNpbmcgVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudCBpbiBzdHJpY3QgbW9kZSBpcyBub3QgcmVjb21tZW5kZWQgYW5kIG1heSBpbmRpY2F0ZSBidWdzIGluIHlvdXIgY29kZS4gJyArICdTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3Vuc2FmZS1jb21wb25lbnQtbGlmZWN5Y2xlcyBmb3IgZGV0YWlscy5cXG5cXG4nICsgJyogTW92ZSBjb2RlIHdpdGggc2lkZSBlZmZlY3RzIHRvIGNvbXBvbmVudERpZE1vdW50LCBhbmQgc2V0IGluaXRpYWwgc3RhdGUgaW4gdGhlIGNvbnN0cnVjdG9yLlxcbicgKyAnXFxuUGxlYXNlIHVwZGF0ZSB0aGUgZm9sbG93aW5nIGNvbXBvbmVudHM6ICVzJywgc29ydGVkTmFtZXMpO1xuICAgIH1cblxuICAgIGlmIChVTlNBRkVfY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc1VuaXF1ZU5hbWVzLnNpemUgPiAwKSB7XG4gICAgICB2YXIgX3NvcnRlZE5hbWVzID0gc2V0VG9Tb3J0ZWRTdHJpbmcoVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNVbmlxdWVOYW1lcyk7XG5cbiAgICAgIGVycm9yKCdVc2luZyBVTlNBRkVfY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyBpbiBzdHJpY3QgbW9kZSBpcyBub3QgcmVjb21tZW5kZWQgJyArICdhbmQgbWF5IGluZGljYXRlIGJ1Z3MgaW4geW91ciBjb2RlLiAnICsgJ1NlZSBodHRwczovL3JlYWN0anMub3JnL2xpbmsvdW5zYWZlLWNvbXBvbmVudC1saWZlY3ljbGVzIGZvciBkZXRhaWxzLlxcblxcbicgKyAnKiBNb3ZlIGRhdGEgZmV0Y2hpbmcgY29kZSBvciBzaWRlIGVmZmVjdHMgdG8gY29tcG9uZW50RGlkVXBkYXRlLlxcbicgKyBcIiogSWYgeW91J3JlIHVwZGF0aW5nIHN0YXRlIHdoZW5ldmVyIHByb3BzIGNoYW5nZSwgXCIgKyAncmVmYWN0b3IgeW91ciBjb2RlIHRvIHVzZSBtZW1vaXphdGlvbiB0ZWNobmlxdWVzIG9yIG1vdmUgaXQgdG8gJyArICdzdGF0aWMgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzLiBMZWFybiBtb3JlIGF0OiBodHRwczovL3JlYWN0anMub3JnL2xpbmsvZGVyaXZlZC1zdGF0ZVxcbicgKyAnXFxuUGxlYXNlIHVwZGF0ZSB0aGUgZm9sbG93aW5nIGNvbXBvbmVudHM6ICVzJywgX3NvcnRlZE5hbWVzKTtcbiAgICB9XG5cbiAgICBpZiAoVU5TQUZFX2NvbXBvbmVudFdpbGxVcGRhdGVVbmlxdWVOYW1lcy5zaXplID4gMCkge1xuICAgICAgdmFyIF9zb3J0ZWROYW1lczIgPSBzZXRUb1NvcnRlZFN0cmluZyhVTlNBRkVfY29tcG9uZW50V2lsbFVwZGF0ZVVuaXF1ZU5hbWVzKTtcblxuICAgICAgZXJyb3IoJ1VzaW5nIFVOU0FGRV9jb21wb25lbnRXaWxsVXBkYXRlIGluIHN0cmljdCBtb2RlIGlzIG5vdCByZWNvbW1lbmRlZCAnICsgJ2FuZCBtYXkgaW5kaWNhdGUgYnVncyBpbiB5b3VyIGNvZGUuICcgKyAnU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay91bnNhZmUtY29tcG9uZW50LWxpZmVjeWNsZXMgZm9yIGRldGFpbHMuXFxuXFxuJyArICcqIE1vdmUgZGF0YSBmZXRjaGluZyBjb2RlIG9yIHNpZGUgZWZmZWN0cyB0byBjb21wb25lbnREaWRVcGRhdGUuXFxuJyArICdcXG5QbGVhc2UgdXBkYXRlIHRoZSBmb2xsb3dpbmcgY29tcG9uZW50czogJXMnLCBfc29ydGVkTmFtZXMyKTtcbiAgICB9XG5cbiAgICBpZiAoY29tcG9uZW50V2lsbE1vdW50VW5pcXVlTmFtZXMuc2l6ZSA+IDApIHtcbiAgICAgIHZhciBfc29ydGVkTmFtZXMzID0gc2V0VG9Tb3J0ZWRTdHJpbmcoY29tcG9uZW50V2lsbE1vdW50VW5pcXVlTmFtZXMpO1xuXG4gICAgICB3YXJuKCdjb21wb25lbnRXaWxsTW91bnQgaGFzIGJlZW4gcmVuYW1lZCwgYW5kIGlzIG5vdCByZWNvbW1lbmRlZCBmb3IgdXNlLiAnICsgJ1NlZSBodHRwczovL3JlYWN0anMub3JnL2xpbmsvdW5zYWZlLWNvbXBvbmVudC1saWZlY3ljbGVzIGZvciBkZXRhaWxzLlxcblxcbicgKyAnKiBNb3ZlIGNvZGUgd2l0aCBzaWRlIGVmZmVjdHMgdG8gY29tcG9uZW50RGlkTW91bnQsIGFuZCBzZXQgaW5pdGlhbCBzdGF0ZSBpbiB0aGUgY29uc3RydWN0b3IuXFxuJyArICcqIFJlbmFtZSBjb21wb25lbnRXaWxsTW91bnQgdG8gVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudCB0byBzdXBwcmVzcyAnICsgJ3RoaXMgd2FybmluZyBpbiBub24tc3RyaWN0IG1vZGUuIEluIFJlYWN0IDE4LngsIG9ubHkgdGhlIFVOU0FGRV8gbmFtZSB3aWxsIHdvcmsuICcgKyAnVG8gcmVuYW1lIGFsbCBkZXByZWNhdGVkIGxpZmVjeWNsZXMgdG8gdGhlaXIgbmV3IG5hbWVzLCB5b3UgY2FuIHJ1biAnICsgJ2BucHggcmVhY3QtY29kZW1vZCByZW5hbWUtdW5zYWZlLWxpZmVjeWNsZXNgIGluIHlvdXIgcHJvamVjdCBzb3VyY2UgZm9sZGVyLlxcbicgKyAnXFxuUGxlYXNlIHVwZGF0ZSB0aGUgZm9sbG93aW5nIGNvbXBvbmVudHM6ICVzJywgX3NvcnRlZE5hbWVzMyk7XG4gICAgfVxuXG4gICAgaWYgKGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNVbmlxdWVOYW1lcy5zaXplID4gMCkge1xuICAgICAgdmFyIF9zb3J0ZWROYW1lczQgPSBzZXRUb1NvcnRlZFN0cmluZyhjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzVW5pcXVlTmFtZXMpO1xuXG4gICAgICB3YXJuKCdjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzIGhhcyBiZWVuIHJlbmFtZWQsIGFuZCBpcyBub3QgcmVjb21tZW5kZWQgZm9yIHVzZS4gJyArICdTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3Vuc2FmZS1jb21wb25lbnQtbGlmZWN5Y2xlcyBmb3IgZGV0YWlscy5cXG5cXG4nICsgJyogTW92ZSBkYXRhIGZldGNoaW5nIGNvZGUgb3Igc2lkZSBlZmZlY3RzIHRvIGNvbXBvbmVudERpZFVwZGF0ZS5cXG4nICsgXCIqIElmIHlvdSdyZSB1cGRhdGluZyBzdGF0ZSB3aGVuZXZlciBwcm9wcyBjaGFuZ2UsIHJlZmFjdG9yIHlvdXIgXCIgKyAnY29kZSB0byB1c2UgbWVtb2l6YXRpb24gdGVjaG5pcXVlcyBvciBtb3ZlIGl0IHRvICcgKyAnc3RhdGljIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcy4gTGVhcm4gbW9yZSBhdDogaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL2Rlcml2ZWQtc3RhdGVcXG4nICsgJyogUmVuYW1lIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgdG8gVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgdG8gc3VwcHJlc3MgJyArICd0aGlzIHdhcm5pbmcgaW4gbm9uLXN0cmljdCBtb2RlLiBJbiBSZWFjdCAxOC54LCBvbmx5IHRoZSBVTlNBRkVfIG5hbWUgd2lsbCB3b3JrLiAnICsgJ1RvIHJlbmFtZSBhbGwgZGVwcmVjYXRlZCBsaWZlY3ljbGVzIHRvIHRoZWlyIG5ldyBuYW1lcywgeW91IGNhbiBydW4gJyArICdgbnB4IHJlYWN0LWNvZGVtb2QgcmVuYW1lLXVuc2FmZS1saWZlY3ljbGVzYCBpbiB5b3VyIHByb2plY3Qgc291cmNlIGZvbGRlci5cXG4nICsgJ1xcblBsZWFzZSB1cGRhdGUgdGhlIGZvbGxvd2luZyBjb21wb25lbnRzOiAlcycsIF9zb3J0ZWROYW1lczQpO1xuICAgIH1cblxuICAgIGlmIChjb21wb25lbnRXaWxsVXBkYXRlVW5pcXVlTmFtZXMuc2l6ZSA+IDApIHtcbiAgICAgIHZhciBfc29ydGVkTmFtZXM1ID0gc2V0VG9Tb3J0ZWRTdHJpbmcoY29tcG9uZW50V2lsbFVwZGF0ZVVuaXF1ZU5hbWVzKTtcblxuICAgICAgd2FybignY29tcG9uZW50V2lsbFVwZGF0ZSBoYXMgYmVlbiByZW5hbWVkLCBhbmQgaXMgbm90IHJlY29tbWVuZGVkIGZvciB1c2UuICcgKyAnU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay91bnNhZmUtY29tcG9uZW50LWxpZmVjeWNsZXMgZm9yIGRldGFpbHMuXFxuXFxuJyArICcqIE1vdmUgZGF0YSBmZXRjaGluZyBjb2RlIG9yIHNpZGUgZWZmZWN0cyB0byBjb21wb25lbnREaWRVcGRhdGUuXFxuJyArICcqIFJlbmFtZSBjb21wb25lbnRXaWxsVXBkYXRlIHRvIFVOU0FGRV9jb21wb25lbnRXaWxsVXBkYXRlIHRvIHN1cHByZXNzICcgKyAndGhpcyB3YXJuaW5nIGluIG5vbi1zdHJpY3QgbW9kZS4gSW4gUmVhY3QgMTgueCwgb25seSB0aGUgVU5TQUZFXyBuYW1lIHdpbGwgd29yay4gJyArICdUbyByZW5hbWUgYWxsIGRlcHJlY2F0ZWQgbGlmZWN5Y2xlcyB0byB0aGVpciBuZXcgbmFtZXMsIHlvdSBjYW4gcnVuICcgKyAnYG5weCByZWFjdC1jb2RlbW9kIHJlbmFtZS11bnNhZmUtbGlmZWN5Y2xlc2AgaW4geW91ciBwcm9qZWN0IHNvdXJjZSBmb2xkZXIuXFxuJyArICdcXG5QbGVhc2UgdXBkYXRlIHRoZSBmb2xsb3dpbmcgY29tcG9uZW50czogJXMnLCBfc29ydGVkTmFtZXM1KTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIHBlbmRpbmdMZWdhY3lDb250ZXh0V2FybmluZyA9IG5ldyBNYXAoKTsgLy8gVHJhY2tzIGNvbXBvbmVudHMgd2UgaGF2ZSBhbHJlYWR5IHdhcm5lZCBhYm91dC5cblxuICB2YXIgZGlkV2FybkFib3V0TGVnYWN5Q29udGV4dCA9IG5ldyBTZXQoKTtcblxuICBSZWFjdFN0cmljdE1vZGVXYXJuaW5ncy5yZWNvcmRMZWdhY3lDb250ZXh0V2FybmluZyA9IGZ1bmN0aW9uIChmaWJlciwgaW5zdGFuY2UpIHtcbiAgICB2YXIgc3RyaWN0Um9vdCA9IGZpbmRTdHJpY3RSb290KGZpYmVyKTtcblxuICAgIGlmIChzdHJpY3RSb290ID09PSBudWxsKSB7XG4gICAgICBlcnJvcignRXhwZWN0ZWQgdG8gZmluZCBhIFN0cmljdE1vZGUgY29tcG9uZW50IGluIGEgc3RyaWN0IG1vZGUgdHJlZS4gJyArICdUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuXG4gICAgICByZXR1cm47XG4gICAgfSAvLyBEZWR1cCBzdHJhdGVneTogV2FybiBvbmNlIHBlciBjb21wb25lbnQuXG5cblxuICAgIGlmIChkaWRXYXJuQWJvdXRMZWdhY3lDb250ZXh0LmhhcyhmaWJlci50eXBlKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciB3YXJuaW5nc0ZvclJvb3QgPSBwZW5kaW5nTGVnYWN5Q29udGV4dFdhcm5pbmcuZ2V0KHN0cmljdFJvb3QpO1xuXG4gICAgaWYgKGZpYmVyLnR5cGUuY29udGV4dFR5cGVzICE9IG51bGwgfHwgZmliZXIudHlwZS5jaGlsZENvbnRleHRUeXBlcyAhPSBudWxsIHx8IGluc3RhbmNlICE9PSBudWxsICYmIHR5cGVvZiBpbnN0YW5jZS5nZXRDaGlsZENvbnRleHQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGlmICh3YXJuaW5nc0ZvclJvb3QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB3YXJuaW5nc0ZvclJvb3QgPSBbXTtcbiAgICAgICAgcGVuZGluZ0xlZ2FjeUNvbnRleHRXYXJuaW5nLnNldChzdHJpY3RSb290LCB3YXJuaW5nc0ZvclJvb3QpO1xuICAgICAgfVxuXG4gICAgICB3YXJuaW5nc0ZvclJvb3QucHVzaChmaWJlcik7XG4gICAgfVxuICB9O1xuXG4gIFJlYWN0U3RyaWN0TW9kZVdhcm5pbmdzLmZsdXNoTGVnYWN5Q29udGV4dFdhcm5pbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgcGVuZGluZ0xlZ2FjeUNvbnRleHRXYXJuaW5nLmZvckVhY2goZnVuY3Rpb24gKGZpYmVyQXJyYXksIHN0cmljdFJvb3QpIHtcbiAgICAgIGlmIChmaWJlckFycmF5Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBmaXJzdEZpYmVyID0gZmliZXJBcnJheVswXTtcbiAgICAgIHZhciB1bmlxdWVOYW1lcyA9IG5ldyBTZXQoKTtcbiAgICAgIGZpYmVyQXJyYXkuZm9yRWFjaChmdW5jdGlvbiAoZmliZXIpIHtcbiAgICAgICAgdW5pcXVlTmFtZXMuYWRkKGdldENvbXBvbmVudE5hbWUoZmliZXIudHlwZSkgfHwgJ0NvbXBvbmVudCcpO1xuICAgICAgICBkaWRXYXJuQWJvdXRMZWdhY3lDb250ZXh0LmFkZChmaWJlci50eXBlKTtcbiAgICAgIH0pO1xuICAgICAgdmFyIHNvcnRlZE5hbWVzID0gc2V0VG9Tb3J0ZWRTdHJpbmcodW5pcXVlTmFtZXMpO1xuXG4gICAgICB0cnkge1xuICAgICAgICBzZXRDdXJyZW50RmliZXIoZmlyc3RGaWJlcik7XG5cbiAgICAgICAgZXJyb3IoJ0xlZ2FjeSBjb250ZXh0IEFQSSBoYXMgYmVlbiBkZXRlY3RlZCB3aXRoaW4gYSBzdHJpY3QtbW9kZSB0cmVlLicgKyAnXFxuXFxuVGhlIG9sZCBBUEkgd2lsbCBiZSBzdXBwb3J0ZWQgaW4gYWxsIDE2LnggcmVsZWFzZXMsIGJ1dCBhcHBsaWNhdGlvbnMgJyArICd1c2luZyBpdCBzaG91bGQgbWlncmF0ZSB0byB0aGUgbmV3IHZlcnNpb24uJyArICdcXG5cXG5QbGVhc2UgdXBkYXRlIHRoZSBmb2xsb3dpbmcgY29tcG9uZW50czogJXMnICsgJ1xcblxcbkxlYXJuIG1vcmUgYWJvdXQgdGhpcyB3YXJuaW5nIGhlcmU6IGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9sZWdhY3ktY29udGV4dCcsIHNvcnRlZE5hbWVzKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHJlc2V0Q3VycmVudEZpYmVyKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgUmVhY3RTdHJpY3RNb2RlV2FybmluZ3MuZGlzY2FyZFBlbmRpbmdXYXJuaW5ncyA9IGZ1bmN0aW9uICgpIHtcbiAgICBwZW5kaW5nQ29tcG9uZW50V2lsbE1vdW50V2FybmluZ3MgPSBbXTtcbiAgICBwZW5kaW5nVU5TQUZFX0NvbXBvbmVudFdpbGxNb3VudFdhcm5pbmdzID0gW107XG4gICAgcGVuZGluZ0NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNXYXJuaW5ncyA9IFtdO1xuICAgIHBlbmRpbmdVTlNBRkVfQ29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc1dhcm5pbmdzID0gW107XG4gICAgcGVuZGluZ0NvbXBvbmVudFdpbGxVcGRhdGVXYXJuaW5ncyA9IFtdO1xuICAgIHBlbmRpbmdVTlNBRkVfQ29tcG9uZW50V2lsbFVwZGF0ZVdhcm5pbmdzID0gW107XG4gICAgcGVuZGluZ0xlZ2FjeUNvbnRleHRXYXJuaW5nID0gbmV3IE1hcCgpO1xuICB9O1xufVxuXG5mdW5jdGlvbiByZXNvbHZlRGVmYXVsdFByb3BzKENvbXBvbmVudCwgYmFzZVByb3BzKSB7XG4gIGlmIChDb21wb25lbnQgJiYgQ29tcG9uZW50LmRlZmF1bHRQcm9wcykge1xuICAgIC8vIFJlc29sdmUgZGVmYXVsdCBwcm9wcy4gVGFrZW4gZnJvbSBSZWFjdEVsZW1lbnRcbiAgICB2YXIgcHJvcHMgPSBfYXNzaWduKHt9LCBiYXNlUHJvcHMpO1xuXG4gICAgdmFyIGRlZmF1bHRQcm9wcyA9IENvbXBvbmVudC5kZWZhdWx0UHJvcHM7XG5cbiAgICBmb3IgKHZhciBwcm9wTmFtZSBpbiBkZWZhdWx0UHJvcHMpIHtcbiAgICAgIGlmIChwcm9wc1twcm9wTmFtZV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBwcm9wc1twcm9wTmFtZV0gPSBkZWZhdWx0UHJvcHNbcHJvcE5hbWVdO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBwcm9wcztcbiAgfVxuXG4gIHJldHVybiBiYXNlUHJvcHM7XG59XG5cbi8vIE1heCAzMSBiaXQgaW50ZWdlci4gVGhlIG1heCBpbnRlZ2VyIHNpemUgaW4gVjggZm9yIDMyLWJpdCBzeXN0ZW1zLlxuLy8gTWF0aC5wb3coMiwgMzApIC0gMVxuLy8gMGIxMTExMTExMTExMTExMTExMTExMTExMTExMTExMTFcbnZhciBNQVhfU0lHTkVEXzMxX0JJVF9JTlQgPSAxMDczNzQxODIzO1xuXG52YXIgdmFsdWVDdXJzb3IgPSBjcmVhdGVDdXJzb3IobnVsbCk7XG52YXIgcmVuZGVyZXJTaWdpbDtcblxue1xuICAvLyBVc2UgdGhpcyB0byBkZXRlY3QgbXVsdGlwbGUgcmVuZGVyZXJzIHVzaW5nIHRoZSBzYW1lIGNvbnRleHRcbiAgcmVuZGVyZXJTaWdpbCA9IHt9O1xufVxuXG52YXIgY3VycmVudGx5UmVuZGVyaW5nRmliZXIgPSBudWxsO1xudmFyIGxhc3RDb250ZXh0RGVwZW5kZW5jeSA9IG51bGw7XG52YXIgbGFzdENvbnRleHRXaXRoQWxsQml0c09ic2VydmVkID0gbnVsbDtcbnZhciBpc0Rpc2FsbG93ZWRDb250ZXh0UmVhZEluREVWID0gZmFsc2U7XG5mdW5jdGlvbiByZXNldENvbnRleHREZXBlbmRlbmNpZXMoKSB7XG4gIC8vIFRoaXMgaXMgY2FsbGVkIHJpZ2h0IGJlZm9yZSBSZWFjdCB5aWVsZHMgZXhlY3V0aW9uLCB0byBlbnN1cmUgYHJlYWRDb250ZXh0YFxuICAvLyBjYW5ub3QgYmUgY2FsbGVkIG91dHNpZGUgdGhlIHJlbmRlciBwaGFzZS5cbiAgY3VycmVudGx5UmVuZGVyaW5nRmliZXIgPSBudWxsO1xuICBsYXN0Q29udGV4dERlcGVuZGVuY3kgPSBudWxsO1xuICBsYXN0Q29udGV4dFdpdGhBbGxCaXRzT2JzZXJ2ZWQgPSBudWxsO1xuXG4gIHtcbiAgICBpc0Rpc2FsbG93ZWRDb250ZXh0UmVhZEluREVWID0gZmFsc2U7XG4gIH1cbn1cbmZ1bmN0aW9uIGVudGVyRGlzYWxsb3dlZENvbnRleHRSZWFkSW5ERVYoKSB7XG4gIHtcbiAgICBpc0Rpc2FsbG93ZWRDb250ZXh0UmVhZEluREVWID0gdHJ1ZTtcbiAgfVxufVxuZnVuY3Rpb24gZXhpdERpc2FsbG93ZWRDb250ZXh0UmVhZEluREVWKCkge1xuICB7XG4gICAgaXNEaXNhbGxvd2VkQ29udGV4dFJlYWRJbkRFViA9IGZhbHNlO1xuICB9XG59XG5mdW5jdGlvbiBwdXNoUHJvdmlkZXIocHJvdmlkZXJGaWJlciwgbmV4dFZhbHVlKSB7XG4gIHZhciBjb250ZXh0ID0gcHJvdmlkZXJGaWJlci50eXBlLl9jb250ZXh0O1xuXG4gIHtcbiAgICBwdXNoKHZhbHVlQ3Vyc29yLCBjb250ZXh0Ll9jdXJyZW50VmFsdWUsIHByb3ZpZGVyRmliZXIpO1xuICAgIGNvbnRleHQuX2N1cnJlbnRWYWx1ZSA9IG5leHRWYWx1ZTtcblxuICAgIHtcbiAgICAgIGlmIChjb250ZXh0Ll9jdXJyZW50UmVuZGVyZXIgIT09IHVuZGVmaW5lZCAmJiBjb250ZXh0Ll9jdXJyZW50UmVuZGVyZXIgIT09IG51bGwgJiYgY29udGV4dC5fY3VycmVudFJlbmRlcmVyICE9PSByZW5kZXJlclNpZ2lsKSB7XG4gICAgICAgIGVycm9yKCdEZXRlY3RlZCBtdWx0aXBsZSByZW5kZXJlcnMgY29uY3VycmVudGx5IHJlbmRlcmluZyB0aGUgJyArICdzYW1lIGNvbnRleHQgcHJvdmlkZXIuIFRoaXMgaXMgY3VycmVudGx5IHVuc3VwcG9ydGVkLicpO1xuICAgICAgfVxuXG4gICAgICBjb250ZXh0Ll9jdXJyZW50UmVuZGVyZXIgPSByZW5kZXJlclNpZ2lsO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gcG9wUHJvdmlkZXIocHJvdmlkZXJGaWJlcikge1xuICB2YXIgY3VycmVudFZhbHVlID0gdmFsdWVDdXJzb3IuY3VycmVudDtcbiAgcG9wKHZhbHVlQ3Vyc29yLCBwcm92aWRlckZpYmVyKTtcbiAgdmFyIGNvbnRleHQgPSBwcm92aWRlckZpYmVyLnR5cGUuX2NvbnRleHQ7XG5cbiAge1xuICAgIGNvbnRleHQuX2N1cnJlbnRWYWx1ZSA9IGN1cnJlbnRWYWx1ZTtcbiAgfVxufVxuZnVuY3Rpb24gY2FsY3VsYXRlQ2hhbmdlZEJpdHMoY29udGV4dCwgbmV3VmFsdWUsIG9sZFZhbHVlKSB7XG4gIGlmIChvYmplY3RJcyhvbGRWYWx1ZSwgbmV3VmFsdWUpKSB7XG4gICAgLy8gTm8gY2hhbmdlXG4gICAgcmV0dXJuIDA7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGNoYW5nZWRCaXRzID0gdHlwZW9mIGNvbnRleHQuX2NhbGN1bGF0ZUNoYW5nZWRCaXRzID09PSAnZnVuY3Rpb24nID8gY29udGV4dC5fY2FsY3VsYXRlQ2hhbmdlZEJpdHMob2xkVmFsdWUsIG5ld1ZhbHVlKSA6IE1BWF9TSUdORURfMzFfQklUX0lOVDtcblxuICAgIHtcbiAgICAgIGlmICgoY2hhbmdlZEJpdHMgJiBNQVhfU0lHTkVEXzMxX0JJVF9JTlQpICE9PSBjaGFuZ2VkQml0cykge1xuICAgICAgICBlcnJvcignY2FsY3VsYXRlQ2hhbmdlZEJpdHM6IEV4cGVjdGVkIHRoZSByZXR1cm4gdmFsdWUgdG8gYmUgYSAnICsgJzMxLWJpdCBpbnRlZ2VyLiBJbnN0ZWFkIHJlY2VpdmVkOiAlcycsIGNoYW5nZWRCaXRzKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gY2hhbmdlZEJpdHMgfCAwO1xuICB9XG59XG5mdW5jdGlvbiBzY2hlZHVsZVdvcmtPblBhcmVudFBhdGgocGFyZW50LCByZW5kZXJMYW5lcykge1xuICAvLyBVcGRhdGUgdGhlIGNoaWxkIGxhbmVzIG9mIGFsbCB0aGUgYW5jZXN0b3JzLCBpbmNsdWRpbmcgdGhlIGFsdGVybmF0ZXMuXG4gIHZhciBub2RlID0gcGFyZW50O1xuXG4gIHdoaWxlIChub2RlICE9PSBudWxsKSB7XG4gICAgdmFyIGFsdGVybmF0ZSA9IG5vZGUuYWx0ZXJuYXRlO1xuXG4gICAgaWYgKCFpc1N1YnNldE9mTGFuZXMobm9kZS5jaGlsZExhbmVzLCByZW5kZXJMYW5lcykpIHtcbiAgICAgIG5vZGUuY2hpbGRMYW5lcyA9IG1lcmdlTGFuZXMobm9kZS5jaGlsZExhbmVzLCByZW5kZXJMYW5lcyk7XG5cbiAgICAgIGlmIChhbHRlcm5hdGUgIT09IG51bGwpIHtcbiAgICAgICAgYWx0ZXJuYXRlLmNoaWxkTGFuZXMgPSBtZXJnZUxhbmVzKGFsdGVybmF0ZS5jaGlsZExhbmVzLCByZW5kZXJMYW5lcyk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChhbHRlcm5hdGUgIT09IG51bGwgJiYgIWlzU3Vic2V0T2ZMYW5lcyhhbHRlcm5hdGUuY2hpbGRMYW5lcywgcmVuZGVyTGFuZXMpKSB7XG4gICAgICBhbHRlcm5hdGUuY2hpbGRMYW5lcyA9IG1lcmdlTGFuZXMoYWx0ZXJuYXRlLmNoaWxkTGFuZXMsIHJlbmRlckxhbmVzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gTmVpdGhlciBhbHRlcm5hdGUgd2FzIHVwZGF0ZWQsIHdoaWNoIG1lYW5zIHRoZSByZXN0IG9mIHRoZVxuICAgICAgLy8gYW5jZXN0b3IgcGF0aCBhbHJlYWR5IGhhcyBzdWZmaWNpZW50IHByaW9yaXR5LlxuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgbm9kZSA9IG5vZGUucmV0dXJuO1xuICB9XG59XG5mdW5jdGlvbiBwcm9wYWdhdGVDb250ZXh0Q2hhbmdlKHdvcmtJblByb2dyZXNzLCBjb250ZXh0LCBjaGFuZ2VkQml0cywgcmVuZGVyTGFuZXMpIHtcbiAgdmFyIGZpYmVyID0gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG5cbiAgaWYgKGZpYmVyICE9PSBudWxsKSB7XG4gICAgLy8gU2V0IHRoZSByZXR1cm4gcG9pbnRlciBvZiB0aGUgY2hpbGQgdG8gdGhlIHdvcmstaW4tcHJvZ3Jlc3MgZmliZXIuXG4gICAgZmliZXIucmV0dXJuID0gd29ya0luUHJvZ3Jlc3M7XG4gIH1cblxuICB3aGlsZSAoZmliZXIgIT09IG51bGwpIHtcbiAgICB2YXIgbmV4dEZpYmVyID0gdm9pZCAwOyAvLyBWaXNpdCB0aGlzIGZpYmVyLlxuXG4gICAgdmFyIGxpc3QgPSBmaWJlci5kZXBlbmRlbmNpZXM7XG5cbiAgICBpZiAobGlzdCAhPT0gbnVsbCkge1xuICAgICAgbmV4dEZpYmVyID0gZmliZXIuY2hpbGQ7XG4gICAgICB2YXIgZGVwZW5kZW5jeSA9IGxpc3QuZmlyc3RDb250ZXh0O1xuXG4gICAgICB3aGlsZSAoZGVwZW5kZW5jeSAhPT0gbnVsbCkge1xuICAgICAgICAvLyBDaGVjayBpZiB0aGUgY29udGV4dCBtYXRjaGVzLlxuICAgICAgICBpZiAoZGVwZW5kZW5jeS5jb250ZXh0ID09PSBjb250ZXh0ICYmIChkZXBlbmRlbmN5Lm9ic2VydmVkQml0cyAmIGNoYW5nZWRCaXRzKSAhPT0gMCkge1xuICAgICAgICAgIC8vIE1hdGNoISBTY2hlZHVsZSBhbiB1cGRhdGUgb24gdGhpcyBmaWJlci5cbiAgICAgICAgICBpZiAoZmliZXIudGFnID09PSBDbGFzc0NvbXBvbmVudCkge1xuICAgICAgICAgICAgLy8gU2NoZWR1bGUgYSBmb3JjZSB1cGRhdGUgb24gdGhlIHdvcmstaW4tcHJvZ3Jlc3MuXG4gICAgICAgICAgICB2YXIgdXBkYXRlID0gY3JlYXRlVXBkYXRlKE5vVGltZXN0YW1wLCBwaWNrQXJiaXRyYXJ5TGFuZShyZW5kZXJMYW5lcykpO1xuICAgICAgICAgICAgdXBkYXRlLnRhZyA9IEZvcmNlVXBkYXRlOyAvLyBUT0RPOiBCZWNhdXNlIHdlIGRvbid0IGhhdmUgYSB3b3JrLWluLXByb2dyZXNzLCB0aGlzIHdpbGwgYWRkIHRoZVxuICAgICAgICAgICAgLy8gdXBkYXRlIHRvIHRoZSBjdXJyZW50IGZpYmVyLCB0b28sIHdoaWNoIG1lYW5zIGl0IHdpbGwgcGVyc2lzdCBldmVuIGlmXG4gICAgICAgICAgICAvLyB0aGlzIHJlbmRlciBpcyB0aHJvd24gYXdheS4gU2luY2UgaXQncyBhIHJhY2UgY29uZGl0aW9uLCBub3Qgc3VyZSBpdCdzXG4gICAgICAgICAgICAvLyB3b3J0aCBmaXhpbmcuXG5cbiAgICAgICAgICAgIGVucXVldWVVcGRhdGUoZmliZXIsIHVwZGF0ZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZmliZXIubGFuZXMgPSBtZXJnZUxhbmVzKGZpYmVyLmxhbmVzLCByZW5kZXJMYW5lcyk7XG4gICAgICAgICAgdmFyIGFsdGVybmF0ZSA9IGZpYmVyLmFsdGVybmF0ZTtcblxuICAgICAgICAgIGlmIChhbHRlcm5hdGUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGFsdGVybmF0ZS5sYW5lcyA9IG1lcmdlTGFuZXMoYWx0ZXJuYXRlLmxhbmVzLCByZW5kZXJMYW5lcyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgc2NoZWR1bGVXb3JrT25QYXJlbnRQYXRoKGZpYmVyLnJldHVybiwgcmVuZGVyTGFuZXMpOyAvLyBNYXJrIHRoZSB1cGRhdGVkIGxhbmVzIG9uIHRoZSBsaXN0LCB0b28uXG5cbiAgICAgICAgICBsaXN0LmxhbmVzID0gbWVyZ2VMYW5lcyhsaXN0LmxhbmVzLCByZW5kZXJMYW5lcyk7IC8vIFNpbmNlIHdlIGFscmVhZHkgZm91bmQgYSBtYXRjaCwgd2UgY2FuIHN0b3AgdHJhdmVyc2luZyB0aGVcbiAgICAgICAgICAvLyBkZXBlbmRlbmN5IGxpc3QuXG5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIGRlcGVuZGVuY3kgPSBkZXBlbmRlbmN5Lm5leHQ7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChmaWJlci50YWcgPT09IENvbnRleHRQcm92aWRlcikge1xuICAgICAgLy8gRG9uJ3Qgc2NhbiBkZWVwZXIgaWYgdGhpcyBpcyBhIG1hdGNoaW5nIHByb3ZpZGVyXG4gICAgICBuZXh0RmliZXIgPSBmaWJlci50eXBlID09PSB3b3JrSW5Qcm9ncmVzcy50eXBlID8gbnVsbCA6IGZpYmVyLmNoaWxkO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBUcmF2ZXJzZSBkb3duLlxuICAgICAgbmV4dEZpYmVyID0gZmliZXIuY2hpbGQ7XG4gICAgfVxuXG4gICAgaWYgKG5leHRGaWJlciAhPT0gbnVsbCkge1xuICAgICAgLy8gU2V0IHRoZSByZXR1cm4gcG9pbnRlciBvZiB0aGUgY2hpbGQgdG8gdGhlIHdvcmstaW4tcHJvZ3Jlc3MgZmliZXIuXG4gICAgICBuZXh0RmliZXIucmV0dXJuID0gZmliZXI7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIE5vIGNoaWxkLiBUcmF2ZXJzZSB0byBuZXh0IHNpYmxpbmcuXG4gICAgICBuZXh0RmliZXIgPSBmaWJlcjtcblxuICAgICAgd2hpbGUgKG5leHRGaWJlciAhPT0gbnVsbCkge1xuICAgICAgICBpZiAobmV4dEZpYmVyID09PSB3b3JrSW5Qcm9ncmVzcykge1xuICAgICAgICAgIC8vIFdlJ3JlIGJhY2sgdG8gdGhlIHJvb3Qgb2YgdGhpcyBzdWJ0cmVlLiBFeGl0LlxuICAgICAgICAgIG5leHRGaWJlciA9IG51bGw7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc2libGluZyA9IG5leHRGaWJlci5zaWJsaW5nO1xuXG4gICAgICAgIGlmIChzaWJsaW5nICE9PSBudWxsKSB7XG4gICAgICAgICAgLy8gU2V0IHRoZSByZXR1cm4gcG9pbnRlciBvZiB0aGUgc2libGluZyB0byB0aGUgd29yay1pbi1wcm9ncmVzcyBmaWJlci5cbiAgICAgICAgICBzaWJsaW5nLnJldHVybiA9IG5leHRGaWJlci5yZXR1cm47XG4gICAgICAgICAgbmV4dEZpYmVyID0gc2libGluZztcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfSAvLyBObyBtb3JlIHNpYmxpbmdzLiBUcmF2ZXJzZSB1cC5cblxuXG4gICAgICAgIG5leHRGaWJlciA9IG5leHRGaWJlci5yZXR1cm47XG4gICAgICB9XG4gICAgfVxuXG4gICAgZmliZXIgPSBuZXh0RmliZXI7XG4gIH1cbn1cbmZ1bmN0aW9uIHByZXBhcmVUb1JlYWRDb250ZXh0KHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcykge1xuICBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciA9IHdvcmtJblByb2dyZXNzO1xuICBsYXN0Q29udGV4dERlcGVuZGVuY3kgPSBudWxsO1xuICBsYXN0Q29udGV4dFdpdGhBbGxCaXRzT2JzZXJ2ZWQgPSBudWxsO1xuICB2YXIgZGVwZW5kZW5jaWVzID0gd29ya0luUHJvZ3Jlc3MuZGVwZW5kZW5jaWVzO1xuXG4gIGlmIChkZXBlbmRlbmNpZXMgIT09IG51bGwpIHtcbiAgICB2YXIgZmlyc3RDb250ZXh0ID0gZGVwZW5kZW5jaWVzLmZpcnN0Q29udGV4dDtcblxuICAgIGlmIChmaXJzdENvbnRleHQgIT09IG51bGwpIHtcbiAgICAgIGlmIChpbmNsdWRlc1NvbWVMYW5lKGRlcGVuZGVuY2llcy5sYW5lcywgcmVuZGVyTGFuZXMpKSB7XG4gICAgICAgIC8vIENvbnRleHQgbGlzdCBoYXMgYSBwZW5kaW5nIHVwZGF0ZS4gTWFyayB0aGF0IHRoaXMgZmliZXIgcGVyZm9ybWVkIHdvcmsuXG4gICAgICAgIG1hcmtXb3JrSW5Qcm9ncmVzc1JlY2VpdmVkVXBkYXRlKCk7XG4gICAgICB9IC8vIFJlc2V0IHRoZSB3b3JrLWluLXByb2dyZXNzIGxpc3RcblxuXG4gICAgICBkZXBlbmRlbmNpZXMuZmlyc3RDb250ZXh0ID0gbnVsbDtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIHJlYWRDb250ZXh0KGNvbnRleHQsIG9ic2VydmVkQml0cykge1xuICB7XG4gICAgLy8gVGhpcyB3YXJuaW5nIHdvdWxkIGZpcmUgaWYgeW91IHJlYWQgY29udGV4dCBpbnNpZGUgYSBIb29rIGxpa2UgdXNlTWVtby5cbiAgICAvLyBVbmxpa2UgdGhlIGNsYXNzIGNoZWNrIGJlbG93LCBpdCdzIG5vdCBlbmZvcmNlZCBpbiBwcm9kdWN0aW9uIGZvciBwZXJmLlxuICAgIGlmIChpc0Rpc2FsbG93ZWRDb250ZXh0UmVhZEluREVWKSB7XG4gICAgICBlcnJvcignQ29udGV4dCBjYW4gb25seSBiZSByZWFkIHdoaWxlIFJlYWN0IGlzIHJlbmRlcmluZy4gJyArICdJbiBjbGFzc2VzLCB5b3UgY2FuIHJlYWQgaXQgaW4gdGhlIHJlbmRlciBtZXRob2Qgb3IgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzLiAnICsgJ0luIGZ1bmN0aW9uIGNvbXBvbmVudHMsIHlvdSBjYW4gcmVhZCBpdCBkaXJlY3RseSBpbiB0aGUgZnVuY3Rpb24gYm9keSwgYnV0IG5vdCAnICsgJ2luc2lkZSBIb29rcyBsaWtlIHVzZVJlZHVjZXIoKSBvciB1c2VNZW1vKCkuJyk7XG4gICAgfVxuICB9XG5cbiAgaWYgKGxhc3RDb250ZXh0V2l0aEFsbEJpdHNPYnNlcnZlZCA9PT0gY29udGV4dCkgOyBlbHNlIGlmIChvYnNlcnZlZEJpdHMgPT09IGZhbHNlIHx8IG9ic2VydmVkQml0cyA9PT0gMCkgOyBlbHNlIHtcbiAgICB2YXIgcmVzb2x2ZWRPYnNlcnZlZEJpdHM7IC8vIEF2b2lkIGRlb3B0aW5nIG9uIG9ic2VydmFibGUgYXJndW1lbnRzIG9yIGhldGVyb2dlbmVvdXMgdHlwZXMuXG5cbiAgICBpZiAodHlwZW9mIG9ic2VydmVkQml0cyAhPT0gJ251bWJlcicgfHwgb2JzZXJ2ZWRCaXRzID09PSBNQVhfU0lHTkVEXzMxX0JJVF9JTlQpIHtcbiAgICAgIC8vIE9ic2VydmUgYWxsIHVwZGF0ZXMuXG4gICAgICBsYXN0Q29udGV4dFdpdGhBbGxCaXRzT2JzZXJ2ZWQgPSBjb250ZXh0O1xuICAgICAgcmVzb2x2ZWRPYnNlcnZlZEJpdHMgPSBNQVhfU0lHTkVEXzMxX0JJVF9JTlQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc29sdmVkT2JzZXJ2ZWRCaXRzID0gb2JzZXJ2ZWRCaXRzO1xuICAgIH1cblxuICAgIHZhciBjb250ZXh0SXRlbSA9IHtcbiAgICAgIGNvbnRleHQ6IGNvbnRleHQsXG4gICAgICBvYnNlcnZlZEJpdHM6IHJlc29sdmVkT2JzZXJ2ZWRCaXRzLFxuICAgICAgbmV4dDogbnVsbFxuICAgIH07XG5cbiAgICBpZiAobGFzdENvbnRleHREZXBlbmRlbmN5ID09PSBudWxsKSB7XG4gICAgICBpZiAoIShjdXJyZW50bHlSZW5kZXJpbmdGaWJlciAhPT0gbnVsbCkpIHtcbiAgICAgICAge1xuICAgICAgICAgIHRocm93IEVycm9yKCBcIkNvbnRleHQgY2FuIG9ubHkgYmUgcmVhZCB3aGlsZSBSZWFjdCBpcyByZW5kZXJpbmcuIEluIGNsYXNzZXMsIHlvdSBjYW4gcmVhZCBpdCBpbiB0aGUgcmVuZGVyIG1ldGhvZCBvciBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMuIEluIGZ1bmN0aW9uIGNvbXBvbmVudHMsIHlvdSBjYW4gcmVhZCBpdCBkaXJlY3RseSBpbiB0aGUgZnVuY3Rpb24gYm9keSwgYnV0IG5vdCBpbnNpZGUgSG9va3MgbGlrZSB1c2VSZWR1Y2VyKCkgb3IgdXNlTWVtbygpLlwiICk7XG4gICAgICAgIH1cbiAgICAgIH0gLy8gVGhpcyBpcyB0aGUgZmlyc3QgZGVwZW5kZW5jeSBmb3IgdGhpcyBjb21wb25lbnQuIENyZWF0ZSBhIG5ldyBsaXN0LlxuXG5cbiAgICAgIGxhc3RDb250ZXh0RGVwZW5kZW5jeSA9IGNvbnRleHRJdGVtO1xuICAgICAgY3VycmVudGx5UmVuZGVyaW5nRmliZXIuZGVwZW5kZW5jaWVzID0ge1xuICAgICAgICBsYW5lczogTm9MYW5lcyxcbiAgICAgICAgZmlyc3RDb250ZXh0OiBjb250ZXh0SXRlbSxcbiAgICAgICAgcmVzcG9uZGVyczogbnVsbFxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gQXBwZW5kIGEgbmV3IGNvbnRleHQgaXRlbS5cbiAgICAgIGxhc3RDb250ZXh0RGVwZW5kZW5jeSA9IGxhc3RDb250ZXh0RGVwZW5kZW5jeS5uZXh0ID0gY29udGV4dEl0ZW07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuICBjb250ZXh0Ll9jdXJyZW50VmFsdWUgO1xufVxuXG52YXIgVXBkYXRlU3RhdGUgPSAwO1xudmFyIFJlcGxhY2VTdGF0ZSA9IDE7XG52YXIgRm9yY2VVcGRhdGUgPSAyO1xudmFyIENhcHR1cmVVcGRhdGUgPSAzOyAvLyBHbG9iYWwgc3RhdGUgdGhhdCBpcyByZXNldCBhdCB0aGUgYmVnaW5uaW5nIG9mIGNhbGxpbmcgYHByb2Nlc3NVcGRhdGVRdWV1ZWAuXG4vLyBJdCBzaG91bGQgb25seSBiZSByZWFkIHJpZ2h0IGFmdGVyIGNhbGxpbmcgYHByb2Nlc3NVcGRhdGVRdWV1ZWAsIHZpYVxuLy8gYGNoZWNrSGFzRm9yY2VVcGRhdGVBZnRlclByb2Nlc3NpbmdgLlxuXG52YXIgaGFzRm9yY2VVcGRhdGUgPSBmYWxzZTtcbnZhciBkaWRXYXJuVXBkYXRlSW5zaWRlVXBkYXRlO1xudmFyIGN1cnJlbnRseVByb2Nlc3NpbmdRdWV1ZTtcblxue1xuICBkaWRXYXJuVXBkYXRlSW5zaWRlVXBkYXRlID0gZmFsc2U7XG4gIGN1cnJlbnRseVByb2Nlc3NpbmdRdWV1ZSA9IG51bGw7XG59XG5cbmZ1bmN0aW9uIGluaXRpYWxpemVVcGRhdGVRdWV1ZShmaWJlcikge1xuICB2YXIgcXVldWUgPSB7XG4gICAgYmFzZVN0YXRlOiBmaWJlci5tZW1vaXplZFN0YXRlLFxuICAgIGZpcnN0QmFzZVVwZGF0ZTogbnVsbCxcbiAgICBsYXN0QmFzZVVwZGF0ZTogbnVsbCxcbiAgICBzaGFyZWQ6IHtcbiAgICAgIHBlbmRpbmc6IG51bGxcbiAgICB9LFxuICAgIGVmZmVjdHM6IG51bGxcbiAgfTtcbiAgZmliZXIudXBkYXRlUXVldWUgPSBxdWV1ZTtcbn1cbmZ1bmN0aW9uIGNsb25lVXBkYXRlUXVldWUoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpIHtcbiAgLy8gQ2xvbmUgdGhlIHVwZGF0ZSBxdWV1ZSBmcm9tIGN1cnJlbnQuIFVubGVzcyBpdCdzIGFscmVhZHkgYSBjbG9uZS5cbiAgdmFyIHF1ZXVlID0gd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWU7XG4gIHZhciBjdXJyZW50UXVldWUgPSBjdXJyZW50LnVwZGF0ZVF1ZXVlO1xuXG4gIGlmIChxdWV1ZSA9PT0gY3VycmVudFF1ZXVlKSB7XG4gICAgdmFyIGNsb25lID0ge1xuICAgICAgYmFzZVN0YXRlOiBjdXJyZW50UXVldWUuYmFzZVN0YXRlLFxuICAgICAgZmlyc3RCYXNlVXBkYXRlOiBjdXJyZW50UXVldWUuZmlyc3RCYXNlVXBkYXRlLFxuICAgICAgbGFzdEJhc2VVcGRhdGU6IGN1cnJlbnRRdWV1ZS5sYXN0QmFzZVVwZGF0ZSxcbiAgICAgIHNoYXJlZDogY3VycmVudFF1ZXVlLnNoYXJlZCxcbiAgICAgIGVmZmVjdHM6IGN1cnJlbnRRdWV1ZS5lZmZlY3RzXG4gICAgfTtcbiAgICB3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZSA9IGNsb25lO1xuICB9XG59XG5mdW5jdGlvbiBjcmVhdGVVcGRhdGUoZXZlbnRUaW1lLCBsYW5lKSB7XG4gIHZhciB1cGRhdGUgPSB7XG4gICAgZXZlbnRUaW1lOiBldmVudFRpbWUsXG4gICAgbGFuZTogbGFuZSxcbiAgICB0YWc6IFVwZGF0ZVN0YXRlLFxuICAgIHBheWxvYWQ6IG51bGwsXG4gICAgY2FsbGJhY2s6IG51bGwsXG4gICAgbmV4dDogbnVsbFxuICB9O1xuICByZXR1cm4gdXBkYXRlO1xufVxuZnVuY3Rpb24gZW5xdWV1ZVVwZGF0ZShmaWJlciwgdXBkYXRlKSB7XG4gIHZhciB1cGRhdGVRdWV1ZSA9IGZpYmVyLnVwZGF0ZVF1ZXVlO1xuXG4gIGlmICh1cGRhdGVRdWV1ZSA9PT0gbnVsbCkge1xuICAgIC8vIE9ubHkgb2NjdXJzIGlmIHRoZSBmaWJlciBoYXMgYmVlbiB1bm1vdW50ZWQuXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIHNoYXJlZFF1ZXVlID0gdXBkYXRlUXVldWUuc2hhcmVkO1xuICB2YXIgcGVuZGluZyA9IHNoYXJlZFF1ZXVlLnBlbmRpbmc7XG5cbiAgaWYgKHBlbmRpbmcgPT09IG51bGwpIHtcbiAgICAvLyBUaGlzIGlzIHRoZSBmaXJzdCB1cGRhdGUuIENyZWF0ZSBhIGNpcmN1bGFyIGxpc3QuXG4gICAgdXBkYXRlLm5leHQgPSB1cGRhdGU7XG4gIH0gZWxzZSB7XG4gICAgdXBkYXRlLm5leHQgPSBwZW5kaW5nLm5leHQ7XG4gICAgcGVuZGluZy5uZXh0ID0gdXBkYXRlO1xuICB9XG5cbiAgc2hhcmVkUXVldWUucGVuZGluZyA9IHVwZGF0ZTtcblxuICB7XG4gICAgaWYgKGN1cnJlbnRseVByb2Nlc3NpbmdRdWV1ZSA9PT0gc2hhcmVkUXVldWUgJiYgIWRpZFdhcm5VcGRhdGVJbnNpZGVVcGRhdGUpIHtcbiAgICAgIGVycm9yKCdBbiB1cGRhdGUgKHNldFN0YXRlLCByZXBsYWNlU3RhdGUsIG9yIGZvcmNlVXBkYXRlKSB3YXMgc2NoZWR1bGVkICcgKyAnZnJvbSBpbnNpZGUgYW4gdXBkYXRlIGZ1bmN0aW9uLiBVcGRhdGUgZnVuY3Rpb25zIHNob3VsZCBiZSBwdXJlLCAnICsgJ3dpdGggemVybyBzaWRlLWVmZmVjdHMuIENvbnNpZGVyIHVzaW5nIGNvbXBvbmVudERpZFVwZGF0ZSBvciBhICcgKyAnY2FsbGJhY2suJyk7XG5cbiAgICAgIGRpZFdhcm5VcGRhdGVJbnNpZGVVcGRhdGUgPSB0cnVlO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gZW5xdWV1ZUNhcHR1cmVkVXBkYXRlKHdvcmtJblByb2dyZXNzLCBjYXB0dXJlZFVwZGF0ZSkge1xuICAvLyBDYXB0dXJlZCB1cGRhdGVzIGFyZSB1cGRhdGVzIHRoYXQgYXJlIHRocm93biBieSBhIGNoaWxkIGR1cmluZyB0aGUgcmVuZGVyXG4gIC8vIHBoYXNlLiBUaGV5IHNob3VsZCBiZSBkaXNjYXJkZWQgaWYgdGhlIHJlbmRlciBpcyBhYm9ydGVkLiBUaGVyZWZvcmUsXG4gIC8vIHdlIHNob3VsZCBvbmx5IHB1dCB0aGVtIG9uIHRoZSB3b3JrLWluLXByb2dyZXNzIHF1ZXVlLCBub3QgdGhlIGN1cnJlbnQgb25lLlxuICB2YXIgcXVldWUgPSB3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZTsgLy8gQ2hlY2sgaWYgdGhlIHdvcmstaW4tcHJvZ3Jlc3MgcXVldWUgaXMgYSBjbG9uZS5cblxuICB2YXIgY3VycmVudCA9IHdvcmtJblByb2dyZXNzLmFsdGVybmF0ZTtcblxuICBpZiAoY3VycmVudCAhPT0gbnVsbCkge1xuICAgIHZhciBjdXJyZW50UXVldWUgPSBjdXJyZW50LnVwZGF0ZVF1ZXVlO1xuXG4gICAgaWYgKHF1ZXVlID09PSBjdXJyZW50UXVldWUpIHtcbiAgICAgIC8vIFRoZSB3b3JrLWluLXByb2dyZXNzIHF1ZXVlIGlzIHRoZSBzYW1lIGFzIGN1cnJlbnQuIFRoaXMgaGFwcGVucyB3aGVuXG4gICAgICAvLyB3ZSBiYWlsIG91dCBvbiBhIHBhcmVudCBmaWJlciB0aGF0IHRoZW4gY2FwdHVyZXMgYW4gZXJyb3IgdGhyb3duIGJ5XG4gICAgICAvLyBhIGNoaWxkLiBTaW5jZSB3ZSB3YW50IHRvIGFwcGVuZCB0aGUgdXBkYXRlIG9ubHkgdG8gdGhlIHdvcmstaW5cbiAgICAgIC8vIC1wcm9ncmVzcyBxdWV1ZSwgd2UgbmVlZCB0byBjbG9uZSB0aGUgdXBkYXRlcy4gV2UgdXN1YWxseSBjbG9uZSBkdXJpbmdcbiAgICAgIC8vIHByb2Nlc3NVcGRhdGVRdWV1ZSwgYnV0IHRoYXQgZGlkbid0IGhhcHBlbiBpbiB0aGlzIGNhc2UgYmVjYXVzZSB3ZVxuICAgICAgLy8gc2tpcHBlZCBvdmVyIHRoZSBwYXJlbnQgd2hlbiB3ZSBiYWlsZWQgb3V0LlxuICAgICAgdmFyIG5ld0ZpcnN0ID0gbnVsbDtcbiAgICAgIHZhciBuZXdMYXN0ID0gbnVsbDtcbiAgICAgIHZhciBmaXJzdEJhc2VVcGRhdGUgPSBxdWV1ZS5maXJzdEJhc2VVcGRhdGU7XG5cbiAgICAgIGlmIChmaXJzdEJhc2VVcGRhdGUgIT09IG51bGwpIHtcbiAgICAgICAgLy8gTG9vcCB0aHJvdWdoIHRoZSB1cGRhdGVzIGFuZCBjbG9uZSB0aGVtLlxuICAgICAgICB2YXIgdXBkYXRlID0gZmlyc3RCYXNlVXBkYXRlO1xuXG4gICAgICAgIGRvIHtcbiAgICAgICAgICB2YXIgY2xvbmUgPSB7XG4gICAgICAgICAgICBldmVudFRpbWU6IHVwZGF0ZS5ldmVudFRpbWUsXG4gICAgICAgICAgICBsYW5lOiB1cGRhdGUubGFuZSxcbiAgICAgICAgICAgIHRhZzogdXBkYXRlLnRhZyxcbiAgICAgICAgICAgIHBheWxvYWQ6IHVwZGF0ZS5wYXlsb2FkLFxuICAgICAgICAgICAgY2FsbGJhY2s6IHVwZGF0ZS5jYWxsYmFjayxcbiAgICAgICAgICAgIG5leHQ6IG51bGxcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgaWYgKG5ld0xhc3QgPT09IG51bGwpIHtcbiAgICAgICAgICAgIG5ld0ZpcnN0ID0gbmV3TGFzdCA9IGNsb25lO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBuZXdMYXN0Lm5leHQgPSBjbG9uZTtcbiAgICAgICAgICAgIG5ld0xhc3QgPSBjbG9uZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB1cGRhdGUgPSB1cGRhdGUubmV4dDtcbiAgICAgICAgfSB3aGlsZSAodXBkYXRlICE9PSBudWxsKTsgLy8gQXBwZW5kIHRoZSBjYXB0dXJlZCB1cGRhdGUgdGhlIGVuZCBvZiB0aGUgY2xvbmVkIGxpc3QuXG5cblxuICAgICAgICBpZiAobmV3TGFzdCA9PT0gbnVsbCkge1xuICAgICAgICAgIG5ld0ZpcnN0ID0gbmV3TGFzdCA9IGNhcHR1cmVkVXBkYXRlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5ld0xhc3QubmV4dCA9IGNhcHR1cmVkVXBkYXRlO1xuICAgICAgICAgIG5ld0xhc3QgPSBjYXB0dXJlZFVwZGF0ZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gVGhlcmUgYXJlIG5vIGJhc2UgdXBkYXRlcy5cbiAgICAgICAgbmV3Rmlyc3QgPSBuZXdMYXN0ID0gY2FwdHVyZWRVcGRhdGU7XG4gICAgICB9XG5cbiAgICAgIHF1ZXVlID0ge1xuICAgICAgICBiYXNlU3RhdGU6IGN1cnJlbnRRdWV1ZS5iYXNlU3RhdGUsXG4gICAgICAgIGZpcnN0QmFzZVVwZGF0ZTogbmV3Rmlyc3QsXG4gICAgICAgIGxhc3RCYXNlVXBkYXRlOiBuZXdMYXN0LFxuICAgICAgICBzaGFyZWQ6IGN1cnJlbnRRdWV1ZS5zaGFyZWQsXG4gICAgICAgIGVmZmVjdHM6IGN1cnJlbnRRdWV1ZS5lZmZlY3RzXG4gICAgICB9O1xuICAgICAgd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWUgPSBxdWV1ZTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH0gLy8gQXBwZW5kIHRoZSB1cGRhdGUgdG8gdGhlIGVuZCBvZiB0aGUgbGlzdC5cblxuXG4gIHZhciBsYXN0QmFzZVVwZGF0ZSA9IHF1ZXVlLmxhc3RCYXNlVXBkYXRlO1xuXG4gIGlmIChsYXN0QmFzZVVwZGF0ZSA9PT0gbnVsbCkge1xuICAgIHF1ZXVlLmZpcnN0QmFzZVVwZGF0ZSA9IGNhcHR1cmVkVXBkYXRlO1xuICB9IGVsc2Uge1xuICAgIGxhc3RCYXNlVXBkYXRlLm5leHQgPSBjYXB0dXJlZFVwZGF0ZTtcbiAgfVxuXG4gIHF1ZXVlLmxhc3RCYXNlVXBkYXRlID0gY2FwdHVyZWRVcGRhdGU7XG59XG5cbmZ1bmN0aW9uIGdldFN0YXRlRnJvbVVwZGF0ZSh3b3JrSW5Qcm9ncmVzcywgcXVldWUsIHVwZGF0ZSwgcHJldlN0YXRlLCBuZXh0UHJvcHMsIGluc3RhbmNlKSB7XG4gIHN3aXRjaCAodXBkYXRlLnRhZykge1xuICAgIGNhc2UgUmVwbGFjZVN0YXRlOlxuICAgICAge1xuICAgICAgICB2YXIgcGF5bG9hZCA9IHVwZGF0ZS5wYXlsb2FkO1xuXG4gICAgICAgIGlmICh0eXBlb2YgcGF5bG9hZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIC8vIFVwZGF0ZXIgZnVuY3Rpb25cbiAgICAgICAgICB7XG4gICAgICAgICAgICBlbnRlckRpc2FsbG93ZWRDb250ZXh0UmVhZEluREVWKCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIG5leHRTdGF0ZSA9IHBheWxvYWQuY2FsbChpbnN0YW5jZSwgcHJldlN0YXRlLCBuZXh0UHJvcHMpO1xuXG4gICAgICAgICAge1xuICAgICAgICAgICAgaWYgKCB3b3JrSW5Qcm9ncmVzcy5tb2RlICYgU3RyaWN0TW9kZSkge1xuICAgICAgICAgICAgICBkaXNhYmxlTG9ncygpO1xuXG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcGF5bG9hZC5jYWxsKGluc3RhbmNlLCBwcmV2U3RhdGUsIG5leHRQcm9wcyk7XG4gICAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgcmVlbmFibGVMb2dzKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZXhpdERpc2FsbG93ZWRDb250ZXh0UmVhZEluREVWKCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIG5leHRTdGF0ZTtcbiAgICAgICAgfSAvLyBTdGF0ZSBvYmplY3RcblxuXG4gICAgICAgIHJldHVybiBwYXlsb2FkO1xuICAgICAgfVxuXG4gICAgY2FzZSBDYXB0dXJlVXBkYXRlOlxuICAgICAge1xuICAgICAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyA9IHdvcmtJblByb2dyZXNzLmZsYWdzICYgflNob3VsZENhcHR1cmUgfCBEaWRDYXB0dXJlO1xuICAgICAgfVxuICAgIC8vIEludGVudGlvbmFsIGZhbGx0aHJvdWdoXG5cbiAgICBjYXNlIFVwZGF0ZVN0YXRlOlxuICAgICAge1xuICAgICAgICB2YXIgX3BheWxvYWQgPSB1cGRhdGUucGF5bG9hZDtcbiAgICAgICAgdmFyIHBhcnRpYWxTdGF0ZTtcblxuICAgICAgICBpZiAodHlwZW9mIF9wYXlsb2FkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgLy8gVXBkYXRlciBmdW5jdGlvblxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGVudGVyRGlzYWxsb3dlZENvbnRleHRSZWFkSW5ERVYoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBwYXJ0aWFsU3RhdGUgPSBfcGF5bG9hZC5jYWxsKGluc3RhbmNlLCBwcmV2U3RhdGUsIG5leHRQcm9wcyk7XG5cbiAgICAgICAgICB7XG4gICAgICAgICAgICBpZiAoIHdvcmtJblByb2dyZXNzLm1vZGUgJiBTdHJpY3RNb2RlKSB7XG4gICAgICAgICAgICAgIGRpc2FibGVMb2dzKCk7XG5cbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBfcGF5bG9hZC5jYWxsKGluc3RhbmNlLCBwcmV2U3RhdGUsIG5leHRQcm9wcyk7XG4gICAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgcmVlbmFibGVMb2dzKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZXhpdERpc2FsbG93ZWRDb250ZXh0UmVhZEluREVWKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIFBhcnRpYWwgc3RhdGUgb2JqZWN0XG4gICAgICAgICAgcGFydGlhbFN0YXRlID0gX3BheWxvYWQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocGFydGlhbFN0YXRlID09PSBudWxsIHx8IHBhcnRpYWxTdGF0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgLy8gTnVsbCBhbmQgdW5kZWZpbmVkIGFyZSB0cmVhdGVkIGFzIG5vLW9wcy5cbiAgICAgICAgICByZXR1cm4gcHJldlN0YXRlO1xuICAgICAgICB9IC8vIE1lcmdlIHRoZSBwYXJ0aWFsIHN0YXRlIGFuZCB0aGUgcHJldmlvdXMgc3RhdGUuXG5cblxuICAgICAgICByZXR1cm4gX2Fzc2lnbih7fSwgcHJldlN0YXRlLCBwYXJ0aWFsU3RhdGUpO1xuICAgICAgfVxuXG4gICAgY2FzZSBGb3JjZVVwZGF0ZTpcbiAgICAgIHtcbiAgICAgICAgaGFzRm9yY2VVcGRhdGUgPSB0cnVlO1xuICAgICAgICByZXR1cm4gcHJldlN0YXRlO1xuICAgICAgfVxuICB9XG5cbiAgcmV0dXJuIHByZXZTdGF0ZTtcbn1cblxuZnVuY3Rpb24gcHJvY2Vzc1VwZGF0ZVF1ZXVlKHdvcmtJblByb2dyZXNzLCBwcm9wcywgaW5zdGFuY2UsIHJlbmRlckxhbmVzKSB7XG4gIC8vIFRoaXMgaXMgYWx3YXlzIG5vbi1udWxsIG9uIGEgQ2xhc3NDb21wb25lbnQgb3IgSG9zdFJvb3RcbiAgdmFyIHF1ZXVlID0gd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWU7XG4gIGhhc0ZvcmNlVXBkYXRlID0gZmFsc2U7XG5cbiAge1xuICAgIGN1cnJlbnRseVByb2Nlc3NpbmdRdWV1ZSA9IHF1ZXVlLnNoYXJlZDtcbiAgfVxuXG4gIHZhciBmaXJzdEJhc2VVcGRhdGUgPSBxdWV1ZS5maXJzdEJhc2VVcGRhdGU7XG4gIHZhciBsYXN0QmFzZVVwZGF0ZSA9IHF1ZXVlLmxhc3RCYXNlVXBkYXRlOyAvLyBDaGVjayBpZiB0aGVyZSBhcmUgcGVuZGluZyB1cGRhdGVzLiBJZiBzbywgdHJhbnNmZXIgdGhlbSB0byB0aGUgYmFzZSBxdWV1ZS5cblxuICB2YXIgcGVuZGluZ1F1ZXVlID0gcXVldWUuc2hhcmVkLnBlbmRpbmc7XG5cbiAgaWYgKHBlbmRpbmdRdWV1ZSAhPT0gbnVsbCkge1xuICAgIHF1ZXVlLnNoYXJlZC5wZW5kaW5nID0gbnVsbDsgLy8gVGhlIHBlbmRpbmcgcXVldWUgaXMgY2lyY3VsYXIuIERpc2Nvbm5lY3QgdGhlIHBvaW50ZXIgYmV0d2VlbiBmaXJzdFxuICAgIC8vIGFuZCBsYXN0IHNvIHRoYXQgaXQncyBub24tY2lyY3VsYXIuXG5cbiAgICB2YXIgbGFzdFBlbmRpbmdVcGRhdGUgPSBwZW5kaW5nUXVldWU7XG4gICAgdmFyIGZpcnN0UGVuZGluZ1VwZGF0ZSA9IGxhc3RQZW5kaW5nVXBkYXRlLm5leHQ7XG4gICAgbGFzdFBlbmRpbmdVcGRhdGUubmV4dCA9IG51bGw7IC8vIEFwcGVuZCBwZW5kaW5nIHVwZGF0ZXMgdG8gYmFzZSBxdWV1ZVxuXG4gICAgaWYgKGxhc3RCYXNlVXBkYXRlID09PSBudWxsKSB7XG4gICAgICBmaXJzdEJhc2VVcGRhdGUgPSBmaXJzdFBlbmRpbmdVcGRhdGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxhc3RCYXNlVXBkYXRlLm5leHQgPSBmaXJzdFBlbmRpbmdVcGRhdGU7XG4gICAgfVxuXG4gICAgbGFzdEJhc2VVcGRhdGUgPSBsYXN0UGVuZGluZ1VwZGF0ZTsgLy8gSWYgdGhlcmUncyBhIGN1cnJlbnQgcXVldWUsIGFuZCBpdCdzIGRpZmZlcmVudCBmcm9tIHRoZSBiYXNlIHF1ZXVlLCB0aGVuXG4gICAgLy8gd2UgbmVlZCB0byB0cmFuc2ZlciB0aGUgdXBkYXRlcyB0byB0aGF0IHF1ZXVlLCB0b28uIEJlY2F1c2UgdGhlIGJhc2VcbiAgICAvLyBxdWV1ZSBpcyBhIHNpbmdseS1saW5rZWQgbGlzdCB3aXRoIG5vIGN5Y2xlcywgd2UgY2FuIGFwcGVuZCB0byBib3RoXG4gICAgLy8gbGlzdHMgYW5kIHRha2UgYWR2YW50YWdlIG9mIHN0cnVjdHVyYWwgc2hhcmluZy5cbiAgICAvLyBUT0RPOiBQYXNzIGBjdXJyZW50YCBhcyBhcmd1bWVudFxuXG4gICAgdmFyIGN1cnJlbnQgPSB3b3JrSW5Qcm9ncmVzcy5hbHRlcm5hdGU7XG5cbiAgICBpZiAoY3VycmVudCAhPT0gbnVsbCkge1xuICAgICAgLy8gVGhpcyBpcyBhbHdheXMgbm9uLW51bGwgb24gYSBDbGFzc0NvbXBvbmVudCBvciBIb3N0Um9vdFxuICAgICAgdmFyIGN1cnJlbnRRdWV1ZSA9IGN1cnJlbnQudXBkYXRlUXVldWU7XG4gICAgICB2YXIgY3VycmVudExhc3RCYXNlVXBkYXRlID0gY3VycmVudFF1ZXVlLmxhc3RCYXNlVXBkYXRlO1xuXG4gICAgICBpZiAoY3VycmVudExhc3RCYXNlVXBkYXRlICE9PSBsYXN0QmFzZVVwZGF0ZSkge1xuICAgICAgICBpZiAoY3VycmVudExhc3RCYXNlVXBkYXRlID09PSBudWxsKSB7XG4gICAgICAgICAgY3VycmVudFF1ZXVlLmZpcnN0QmFzZVVwZGF0ZSA9IGZpcnN0UGVuZGluZ1VwZGF0ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjdXJyZW50TGFzdEJhc2VVcGRhdGUubmV4dCA9IGZpcnN0UGVuZGluZ1VwZGF0ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGN1cnJlbnRRdWV1ZS5sYXN0QmFzZVVwZGF0ZSA9IGxhc3RQZW5kaW5nVXBkYXRlO1xuICAgICAgfVxuICAgIH1cbiAgfSAvLyBUaGVzZSB2YWx1ZXMgbWF5IGNoYW5nZSBhcyB3ZSBwcm9jZXNzIHRoZSBxdWV1ZS5cblxuXG4gIGlmIChmaXJzdEJhc2VVcGRhdGUgIT09IG51bGwpIHtcbiAgICAvLyBJdGVyYXRlIHRocm91Z2ggdGhlIGxpc3Qgb2YgdXBkYXRlcyB0byBjb21wdXRlIHRoZSByZXN1bHQuXG4gICAgdmFyIG5ld1N0YXRlID0gcXVldWUuYmFzZVN0YXRlOyAvLyBUT0RPOiBEb24ndCBuZWVkIHRvIGFjY3VtdWxhdGUgdGhpcy4gSW5zdGVhZCwgd2UgY2FuIHJlbW92ZSByZW5kZXJMYW5lc1xuICAgIC8vIGZyb20gdGhlIG9yaWdpbmFsIGxhbmVzLlxuXG4gICAgdmFyIG5ld0xhbmVzID0gTm9MYW5lcztcbiAgICB2YXIgbmV3QmFzZVN0YXRlID0gbnVsbDtcbiAgICB2YXIgbmV3Rmlyc3RCYXNlVXBkYXRlID0gbnVsbDtcbiAgICB2YXIgbmV3TGFzdEJhc2VVcGRhdGUgPSBudWxsO1xuICAgIHZhciB1cGRhdGUgPSBmaXJzdEJhc2VVcGRhdGU7XG5cbiAgICBkbyB7XG4gICAgICB2YXIgdXBkYXRlTGFuZSA9IHVwZGF0ZS5sYW5lO1xuICAgICAgdmFyIHVwZGF0ZUV2ZW50VGltZSA9IHVwZGF0ZS5ldmVudFRpbWU7XG5cbiAgICAgIGlmICghaXNTdWJzZXRPZkxhbmVzKHJlbmRlckxhbmVzLCB1cGRhdGVMYW5lKSkge1xuICAgICAgICAvLyBQcmlvcml0eSBpcyBpbnN1ZmZpY2llbnQuIFNraXAgdGhpcyB1cGRhdGUuIElmIHRoaXMgaXMgdGhlIGZpcnN0XG4gICAgICAgIC8vIHNraXBwZWQgdXBkYXRlLCB0aGUgcHJldmlvdXMgdXBkYXRlL3N0YXRlIGlzIHRoZSBuZXcgYmFzZVxuICAgICAgICAvLyB1cGRhdGUvc3RhdGUuXG4gICAgICAgIHZhciBjbG9uZSA9IHtcbiAgICAgICAgICBldmVudFRpbWU6IHVwZGF0ZUV2ZW50VGltZSxcbiAgICAgICAgICBsYW5lOiB1cGRhdGVMYW5lLFxuICAgICAgICAgIHRhZzogdXBkYXRlLnRhZyxcbiAgICAgICAgICBwYXlsb2FkOiB1cGRhdGUucGF5bG9hZCxcbiAgICAgICAgICBjYWxsYmFjazogdXBkYXRlLmNhbGxiYWNrLFxuICAgICAgICAgIG5leHQ6IG51bGxcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAobmV3TGFzdEJhc2VVcGRhdGUgPT09IG51bGwpIHtcbiAgICAgICAgICBuZXdGaXJzdEJhc2VVcGRhdGUgPSBuZXdMYXN0QmFzZVVwZGF0ZSA9IGNsb25lO1xuICAgICAgICAgIG5ld0Jhc2VTdGF0ZSA9IG5ld1N0YXRlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5ld0xhc3RCYXNlVXBkYXRlID0gbmV3TGFzdEJhc2VVcGRhdGUubmV4dCA9IGNsb25lO1xuICAgICAgICB9IC8vIFVwZGF0ZSB0aGUgcmVtYWluaW5nIHByaW9yaXR5IGluIHRoZSBxdWV1ZS5cblxuXG4gICAgICAgIG5ld0xhbmVzID0gbWVyZ2VMYW5lcyhuZXdMYW5lcywgdXBkYXRlTGFuZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBUaGlzIHVwZGF0ZSBkb2VzIGhhdmUgc3VmZmljaWVudCBwcmlvcml0eS5cbiAgICAgICAgaWYgKG5ld0xhc3RCYXNlVXBkYXRlICE9PSBudWxsKSB7XG4gICAgICAgICAgdmFyIF9jbG9uZSA9IHtcbiAgICAgICAgICAgIGV2ZW50VGltZTogdXBkYXRlRXZlbnRUaW1lLFxuICAgICAgICAgICAgLy8gVGhpcyB1cGRhdGUgaXMgZ29pbmcgdG8gYmUgY29tbWl0dGVkIHNvIHdlIG5ldmVyIHdhbnQgdW5jb21taXRcbiAgICAgICAgICAgIC8vIGl0LiBVc2luZyBOb0xhbmUgd29ya3MgYmVjYXVzZSAwIGlzIGEgc3Vic2V0IG9mIGFsbCBiaXRtYXNrcywgc29cbiAgICAgICAgICAgIC8vIHRoaXMgd2lsbCBuZXZlciBiZSBza2lwcGVkIGJ5IHRoZSBjaGVjayBhYm92ZS5cbiAgICAgICAgICAgIGxhbmU6IE5vTGFuZSxcbiAgICAgICAgICAgIHRhZzogdXBkYXRlLnRhZyxcbiAgICAgICAgICAgIHBheWxvYWQ6IHVwZGF0ZS5wYXlsb2FkLFxuICAgICAgICAgICAgY2FsbGJhY2s6IHVwZGF0ZS5jYWxsYmFjayxcbiAgICAgICAgICAgIG5leHQ6IG51bGxcbiAgICAgICAgICB9O1xuICAgICAgICAgIG5ld0xhc3RCYXNlVXBkYXRlID0gbmV3TGFzdEJhc2VVcGRhdGUubmV4dCA9IF9jbG9uZTtcbiAgICAgICAgfSAvLyBQcm9jZXNzIHRoaXMgdXBkYXRlLlxuXG5cbiAgICAgICAgbmV3U3RhdGUgPSBnZXRTdGF0ZUZyb21VcGRhdGUod29ya0luUHJvZ3Jlc3MsIHF1ZXVlLCB1cGRhdGUsIG5ld1N0YXRlLCBwcm9wcywgaW5zdGFuY2UpO1xuICAgICAgICB2YXIgY2FsbGJhY2sgPSB1cGRhdGUuY2FsbGJhY2s7XG5cbiAgICAgICAgaWYgKGNhbGxiYWNrICE9PSBudWxsKSB7XG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gQ2FsbGJhY2s7XG4gICAgICAgICAgdmFyIGVmZmVjdHMgPSBxdWV1ZS5lZmZlY3RzO1xuXG4gICAgICAgICAgaWYgKGVmZmVjdHMgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHF1ZXVlLmVmZmVjdHMgPSBbdXBkYXRlXTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZWZmZWN0cy5wdXNoKHVwZGF0ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHVwZGF0ZSA9IHVwZGF0ZS5uZXh0O1xuXG4gICAgICBpZiAodXBkYXRlID09PSBudWxsKSB7XG4gICAgICAgIHBlbmRpbmdRdWV1ZSA9IHF1ZXVlLnNoYXJlZC5wZW5kaW5nO1xuXG4gICAgICAgIGlmIChwZW5kaW5nUXVldWUgPT09IG51bGwpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBBbiB1cGRhdGUgd2FzIHNjaGVkdWxlZCBmcm9tIGluc2lkZSBhIHJlZHVjZXIuIEFkZCB0aGUgbmV3XG4gICAgICAgICAgLy8gcGVuZGluZyB1cGRhdGVzIHRvIHRoZSBlbmQgb2YgdGhlIGxpc3QgYW5kIGtlZXAgcHJvY2Vzc2luZy5cbiAgICAgICAgICB2YXIgX2xhc3RQZW5kaW5nVXBkYXRlID0gcGVuZGluZ1F1ZXVlOyAvLyBJbnRlbnRpb25hbGx5IHVuc291bmQuIFBlbmRpbmcgdXBkYXRlcyBmb3JtIGEgY2lyY3VsYXIgbGlzdCwgYnV0IHdlXG4gICAgICAgICAgLy8gdW5yYXZlbCB0aGVtIHdoZW4gdHJhbnNmZXJyaW5nIHRoZW0gdG8gdGhlIGJhc2UgcXVldWUuXG5cbiAgICAgICAgICB2YXIgX2ZpcnN0UGVuZGluZ1VwZGF0ZSA9IF9sYXN0UGVuZGluZ1VwZGF0ZS5uZXh0O1xuICAgICAgICAgIF9sYXN0UGVuZGluZ1VwZGF0ZS5uZXh0ID0gbnVsbDtcbiAgICAgICAgICB1cGRhdGUgPSBfZmlyc3RQZW5kaW5nVXBkYXRlO1xuICAgICAgICAgIHF1ZXVlLmxhc3RCYXNlVXBkYXRlID0gX2xhc3RQZW5kaW5nVXBkYXRlO1xuICAgICAgICAgIHF1ZXVlLnNoYXJlZC5wZW5kaW5nID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gd2hpbGUgKHRydWUpO1xuXG4gICAgaWYgKG5ld0xhc3RCYXNlVXBkYXRlID09PSBudWxsKSB7XG4gICAgICBuZXdCYXNlU3RhdGUgPSBuZXdTdGF0ZTtcbiAgICB9XG5cbiAgICBxdWV1ZS5iYXNlU3RhdGUgPSBuZXdCYXNlU3RhdGU7XG4gICAgcXVldWUuZmlyc3RCYXNlVXBkYXRlID0gbmV3Rmlyc3RCYXNlVXBkYXRlO1xuICAgIHF1ZXVlLmxhc3RCYXNlVXBkYXRlID0gbmV3TGFzdEJhc2VVcGRhdGU7IC8vIFNldCB0aGUgcmVtYWluaW5nIGV4cGlyYXRpb24gdGltZSB0byBiZSB3aGF0ZXZlciBpcyByZW1haW5pbmcgaW4gdGhlIHF1ZXVlLlxuICAgIC8vIFRoaXMgc2hvdWxkIGJlIGZpbmUgYmVjYXVzZSB0aGUgb25seSB0d28gb3RoZXIgdGhpbmdzIHRoYXQgY29udHJpYnV0ZSB0b1xuICAgIC8vIGV4cGlyYXRpb24gdGltZSBhcmUgcHJvcHMgYW5kIGNvbnRleHQuIFdlJ3JlIGFscmVhZHkgaW4gdGhlIG1pZGRsZSBvZiB0aGVcbiAgICAvLyBiZWdpbiBwaGFzZSBieSB0aGUgdGltZSB3ZSBzdGFydCBwcm9jZXNzaW5nIHRoZSBxdWV1ZSwgc28gd2UndmUgYWxyZWFkeVxuICAgIC8vIGRlYWx0IHdpdGggdGhlIHByb3BzLiBDb250ZXh0IGluIGNvbXBvbmVudHMgdGhhdCBzcGVjaWZ5XG4gICAgLy8gc2hvdWxkQ29tcG9uZW50VXBkYXRlIGlzIHRyaWNreTsgYnV0IHdlJ2xsIGhhdmUgdG8gYWNjb3VudCBmb3JcbiAgICAvLyB0aGF0IHJlZ2FyZGxlc3MuXG5cbiAgICBtYXJrU2tpcHBlZFVwZGF0ZUxhbmVzKG5ld0xhbmVzKTtcbiAgICB3b3JrSW5Qcm9ncmVzcy5sYW5lcyA9IG5ld0xhbmVzO1xuICAgIHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSBuZXdTdGF0ZTtcbiAgfVxuXG4gIHtcbiAgICBjdXJyZW50bHlQcm9jZXNzaW5nUXVldWUgPSBudWxsO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNhbGxDYWxsYmFjayhjYWxsYmFjaywgY29udGV4dCkge1xuICBpZiAoISh0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicpKSB7XG4gICAge1xuICAgICAgdGhyb3cgRXJyb3IoIFwiSW52YWxpZCBhcmd1bWVudCBwYXNzZWQgYXMgY2FsbGJhY2suIEV4cGVjdGVkIGEgZnVuY3Rpb24uIEluc3RlYWQgcmVjZWl2ZWQ6IFwiICsgY2FsbGJhY2sgKTtcbiAgICB9XG4gIH1cblxuICBjYWxsYmFjay5jYWxsKGNvbnRleHQpO1xufVxuXG5mdW5jdGlvbiByZXNldEhhc0ZvcmNlVXBkYXRlQmVmb3JlUHJvY2Vzc2luZygpIHtcbiAgaGFzRm9yY2VVcGRhdGUgPSBmYWxzZTtcbn1cbmZ1bmN0aW9uIGNoZWNrSGFzRm9yY2VVcGRhdGVBZnRlclByb2Nlc3NpbmcoKSB7XG4gIHJldHVybiBoYXNGb3JjZVVwZGF0ZTtcbn1cbmZ1bmN0aW9uIGNvbW1pdFVwZGF0ZVF1ZXVlKGZpbmlzaGVkV29yaywgZmluaXNoZWRRdWV1ZSwgaW5zdGFuY2UpIHtcbiAgLy8gQ29tbWl0IHRoZSBlZmZlY3RzXG4gIHZhciBlZmZlY3RzID0gZmluaXNoZWRRdWV1ZS5lZmZlY3RzO1xuICBmaW5pc2hlZFF1ZXVlLmVmZmVjdHMgPSBudWxsO1xuXG4gIGlmIChlZmZlY3RzICE9PSBudWxsKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlZmZlY3RzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgZWZmZWN0ID0gZWZmZWN0c1tpXTtcbiAgICAgIHZhciBjYWxsYmFjayA9IGVmZmVjdC5jYWxsYmFjaztcblxuICAgICAgaWYgKGNhbGxiYWNrICE9PSBudWxsKSB7XG4gICAgICAgIGVmZmVjdC5jYWxsYmFjayA9IG51bGw7XG4gICAgICAgIGNhbGxDYWxsYmFjayhjYWxsYmFjaywgaW5zdGFuY2UpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG52YXIgZmFrZUludGVybmFsSW5zdGFuY2UgPSB7fTtcbnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheTsgLy8gUmVhY3QuQ29tcG9uZW50IHVzZXMgYSBzaGFyZWQgZnJvemVuIG9iamVjdCBieSBkZWZhdWx0LlxuLy8gV2UnbGwgdXNlIGl0IHRvIGRldGVybWluZSB3aGV0aGVyIHdlIG5lZWQgdG8gaW5pdGlhbGl6ZSBsZWdhY3kgcmVmcy5cblxudmFyIGVtcHR5UmVmc09iamVjdCA9IG5ldyBSZWFjdC5Db21wb25lbnQoKS5yZWZzO1xudmFyIGRpZFdhcm5BYm91dFN0YXRlQXNzaWdubWVudEZvckNvbXBvbmVudDtcbnZhciBkaWRXYXJuQWJvdXRVbmluaXRpYWxpemVkU3RhdGU7XG52YXIgZGlkV2FybkFib3V0R2V0U25hcHNob3RCZWZvcmVVcGRhdGVXaXRob3V0RGlkVXBkYXRlO1xudmFyIGRpZFdhcm5BYm91dExlZ2FjeUxpZmVjeWNsZXNBbmREZXJpdmVkU3RhdGU7XG52YXIgZGlkV2FybkFib3V0VW5kZWZpbmVkRGVyaXZlZFN0YXRlO1xudmFyIHdhcm5PblVuZGVmaW5lZERlcml2ZWRTdGF0ZTtcbnZhciB3YXJuT25JbnZhbGlkQ2FsbGJhY2s7XG52YXIgZGlkV2FybkFib3V0RGlyZWN0bHlBc3NpZ25pbmdQcm9wc1RvU3RhdGU7XG52YXIgZGlkV2FybkFib3V0Q29udGV4dFR5cGVBbmRDb250ZXh0VHlwZXM7XG52YXIgZGlkV2FybkFib3V0SW52YWxpZGF0ZUNvbnRleHRUeXBlO1xuXG57XG4gIGRpZFdhcm5BYm91dFN0YXRlQXNzaWdubWVudEZvckNvbXBvbmVudCA9IG5ldyBTZXQoKTtcbiAgZGlkV2FybkFib3V0VW5pbml0aWFsaXplZFN0YXRlID0gbmV3IFNldCgpO1xuICBkaWRXYXJuQWJvdXRHZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZVdpdGhvdXREaWRVcGRhdGUgPSBuZXcgU2V0KCk7XG4gIGRpZFdhcm5BYm91dExlZ2FjeUxpZmVjeWNsZXNBbmREZXJpdmVkU3RhdGUgPSBuZXcgU2V0KCk7XG4gIGRpZFdhcm5BYm91dERpcmVjdGx5QXNzaWduaW5nUHJvcHNUb1N0YXRlID0gbmV3IFNldCgpO1xuICBkaWRXYXJuQWJvdXRVbmRlZmluZWREZXJpdmVkU3RhdGUgPSBuZXcgU2V0KCk7XG4gIGRpZFdhcm5BYm91dENvbnRleHRUeXBlQW5kQ29udGV4dFR5cGVzID0gbmV3IFNldCgpO1xuICBkaWRXYXJuQWJvdXRJbnZhbGlkYXRlQ29udGV4dFR5cGUgPSBuZXcgU2V0KCk7XG4gIHZhciBkaWRXYXJuT25JbnZhbGlkQ2FsbGJhY2sgPSBuZXcgU2V0KCk7XG5cbiAgd2Fybk9uSW52YWxpZENhbGxiYWNrID0gZnVuY3Rpb24gKGNhbGxiYWNrLCBjYWxsZXJOYW1lKSB7XG4gICAgaWYgKGNhbGxiYWNrID09PSBudWxsIHx8IHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBrZXkgPSBjYWxsZXJOYW1lICsgJ18nICsgY2FsbGJhY2s7XG5cbiAgICBpZiAoIWRpZFdhcm5PbkludmFsaWRDYWxsYmFjay5oYXMoa2V5KSkge1xuICAgICAgZGlkV2Fybk9uSW52YWxpZENhbGxiYWNrLmFkZChrZXkpO1xuXG4gICAgICBlcnJvcignJXMoLi4uKTogRXhwZWN0ZWQgdGhlIGxhc3Qgb3B0aW9uYWwgYGNhbGxiYWNrYCBhcmd1bWVudCB0byBiZSBhICcgKyAnZnVuY3Rpb24uIEluc3RlYWQgcmVjZWl2ZWQ6ICVzLicsIGNhbGxlck5hbWUsIGNhbGxiYWNrKTtcbiAgICB9XG4gIH07XG5cbiAgd2Fybk9uVW5kZWZpbmVkRGVyaXZlZFN0YXRlID0gZnVuY3Rpb24gKHR5cGUsIHBhcnRpYWxTdGF0ZSkge1xuICAgIGlmIChwYXJ0aWFsU3RhdGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lKHR5cGUpIHx8ICdDb21wb25lbnQnO1xuXG4gICAgICBpZiAoIWRpZFdhcm5BYm91dFVuZGVmaW5lZERlcml2ZWRTdGF0ZS5oYXMoY29tcG9uZW50TmFtZSkpIHtcbiAgICAgICAgZGlkV2FybkFib3V0VW5kZWZpbmVkRGVyaXZlZFN0YXRlLmFkZChjb21wb25lbnROYW1lKTtcblxuICAgICAgICBlcnJvcignJXMuZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzKCk6IEEgdmFsaWQgc3RhdGUgb2JqZWN0IChvciBudWxsKSBtdXN0IGJlIHJldHVybmVkLiAnICsgJ1lvdSBoYXZlIHJldHVybmVkIHVuZGVmaW5lZC4nLCBjb21wb25lbnROYW1lKTtcbiAgICAgIH1cbiAgICB9XG4gIH07IC8vIFRoaXMgaXMgc28gZ3Jvc3MgYnV0IGl0J3MgYXQgbGVhc3Qgbm9uLWNyaXRpY2FsIGFuZCBjYW4gYmUgcmVtb3ZlZCBpZlxuICAvLyBpdCBjYXVzZXMgcHJvYmxlbXMuIFRoaXMgaXMgbWVhbnQgdG8gZ2l2ZSBhIG5pY2VyIGVycm9yIG1lc3NhZ2UgZm9yXG4gIC8vIFJlYWN0RE9NMTUudW5zdGFibGVfcmVuZGVyU3VidHJlZUludG9Db250YWluZXIocmVhY3RET00xNkNvbXBvbmVudCxcbiAgLy8gLi4uKSkgd2hpY2ggb3RoZXJ3aXNlIHRocm93cyBhIFwiX3Byb2Nlc3NDaGlsZENvbnRleHQgaXMgbm90IGEgZnVuY3Rpb25cIlxuICAvLyBleGNlcHRpb24uXG5cblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZmFrZUludGVybmFsSW5zdGFuY2UsICdfcHJvY2Vzc0NoaWxkQ29udGV4dCcsIHtcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAge1xuICAgICAgICB7XG4gICAgICAgICAgdGhyb3cgRXJyb3IoIFwiX3Byb2Nlc3NDaGlsZENvbnRleHQgaXMgbm90IGF2YWlsYWJsZSBpbiBSZWFjdCAxNisuIFRoaXMgbGlrZWx5IG1lYW5zIHlvdSBoYXZlIG11bHRpcGxlIGNvcGllcyBvZiBSZWFjdCBhbmQgYXJlIGF0dGVtcHRpbmcgdG8gbmVzdCBhIFJlYWN0IDE1IHRyZWUgaW5zaWRlIGEgUmVhY3QgMTYgdHJlZSB1c2luZyB1bnN0YWJsZV9yZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lciwgd2hpY2ggaXNuJ3Qgc3VwcG9ydGVkLiBUcnkgdG8gbWFrZSBzdXJlIHlvdSBoYXZlIG9ubHkgb25lIGNvcHkgb2YgUmVhY3QgKGFuZCBpZGVhbGx5LCBzd2l0Y2ggdG8gUmVhY3RET00uY3JlYXRlUG9ydGFsKS5cIiApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgT2JqZWN0LmZyZWV6ZShmYWtlSW50ZXJuYWxJbnN0YW5jZSk7XG59XG5cbmZ1bmN0aW9uIGFwcGx5RGVyaXZlZFN0YXRlRnJvbVByb3BzKHdvcmtJblByb2dyZXNzLCBjdG9yLCBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMsIG5leHRQcm9wcykge1xuICB2YXIgcHJldlN0YXRlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTtcblxuICB7XG4gICAgaWYgKCB3b3JrSW5Qcm9ncmVzcy5tb2RlICYgU3RyaWN0TW9kZSkge1xuICAgICAgZGlzYWJsZUxvZ3MoKTtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gSW52b2tlIHRoZSBmdW5jdGlvbiBhbiBleHRyYSB0aW1lIHRvIGhlbHAgZGV0ZWN0IHNpZGUtZWZmZWN0cy5cbiAgICAgICAgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzKG5leHRQcm9wcywgcHJldlN0YXRlKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHJlZW5hYmxlTG9ncygpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHZhciBwYXJ0aWFsU3RhdGUgPSBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMobmV4dFByb3BzLCBwcmV2U3RhdGUpO1xuXG4gIHtcbiAgICB3YXJuT25VbmRlZmluZWREZXJpdmVkU3RhdGUoY3RvciwgcGFydGlhbFN0YXRlKTtcbiAgfSAvLyBNZXJnZSB0aGUgcGFydGlhbCBzdGF0ZSBhbmQgdGhlIHByZXZpb3VzIHN0YXRlLlxuXG5cbiAgdmFyIG1lbW9pemVkU3RhdGUgPSBwYXJ0aWFsU3RhdGUgPT09IG51bGwgfHwgcGFydGlhbFN0YXRlID09PSB1bmRlZmluZWQgPyBwcmV2U3RhdGUgOiBfYXNzaWduKHt9LCBwcmV2U3RhdGUsIHBhcnRpYWxTdGF0ZSk7XG4gIHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSBtZW1vaXplZFN0YXRlOyAvLyBPbmNlIHRoZSB1cGRhdGUgcXVldWUgaXMgZW1wdHksIHBlcnNpc3QgdGhlIGRlcml2ZWQgc3RhdGUgb250byB0aGVcbiAgLy8gYmFzZSBzdGF0ZS5cblxuICBpZiAod29ya0luUHJvZ3Jlc3MubGFuZXMgPT09IE5vTGFuZXMpIHtcbiAgICAvLyBRdWV1ZSBpcyBhbHdheXMgbm9uLW51bGwgZm9yIGNsYXNzZXNcbiAgICB2YXIgdXBkYXRlUXVldWUgPSB3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZTtcbiAgICB1cGRhdGVRdWV1ZS5iYXNlU3RhdGUgPSBtZW1vaXplZFN0YXRlO1xuICB9XG59XG52YXIgY2xhc3NDb21wb25lbnRVcGRhdGVyID0ge1xuICBpc01vdW50ZWQ6IGlzTW91bnRlZCxcbiAgZW5xdWV1ZVNldFN0YXRlOiBmdW5jdGlvbiAoaW5zdCwgcGF5bG9hZCwgY2FsbGJhY2spIHtcbiAgICB2YXIgZmliZXIgPSBnZXQoaW5zdCk7XG4gICAgdmFyIGV2ZW50VGltZSA9IHJlcXVlc3RFdmVudFRpbWUoKTtcbiAgICB2YXIgbGFuZSA9IHJlcXVlc3RVcGRhdGVMYW5lKGZpYmVyKTtcbiAgICB2YXIgdXBkYXRlID0gY3JlYXRlVXBkYXRlKGV2ZW50VGltZSwgbGFuZSk7XG4gICAgdXBkYXRlLnBheWxvYWQgPSBwYXlsb2FkO1xuXG4gICAgaWYgKGNhbGxiYWNrICE9PSB1bmRlZmluZWQgJiYgY2FsbGJhY2sgIT09IG51bGwpIHtcbiAgICAgIHtcbiAgICAgICAgd2Fybk9uSW52YWxpZENhbGxiYWNrKGNhbGxiYWNrLCAnc2V0U3RhdGUnKTtcbiAgICAgIH1cblxuICAgICAgdXBkYXRlLmNhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgfVxuXG4gICAgZW5xdWV1ZVVwZGF0ZShmaWJlciwgdXBkYXRlKTtcbiAgICBzY2hlZHVsZVVwZGF0ZU9uRmliZXIoZmliZXIsIGxhbmUsIGV2ZW50VGltZSk7XG4gIH0sXG4gIGVucXVldWVSZXBsYWNlU3RhdGU6IGZ1bmN0aW9uIChpbnN0LCBwYXlsb2FkLCBjYWxsYmFjaykge1xuICAgIHZhciBmaWJlciA9IGdldChpbnN0KTtcbiAgICB2YXIgZXZlbnRUaW1lID0gcmVxdWVzdEV2ZW50VGltZSgpO1xuICAgIHZhciBsYW5lID0gcmVxdWVzdFVwZGF0ZUxhbmUoZmliZXIpO1xuICAgIHZhciB1cGRhdGUgPSBjcmVhdGVVcGRhdGUoZXZlbnRUaW1lLCBsYW5lKTtcbiAgICB1cGRhdGUudGFnID0gUmVwbGFjZVN0YXRlO1xuICAgIHVwZGF0ZS5wYXlsb2FkID0gcGF5bG9hZDtcblxuICAgIGlmIChjYWxsYmFjayAhPT0gdW5kZWZpbmVkICYmIGNhbGxiYWNrICE9PSBudWxsKSB7XG4gICAgICB7XG4gICAgICAgIHdhcm5PbkludmFsaWRDYWxsYmFjayhjYWxsYmFjaywgJ3JlcGxhY2VTdGF0ZScpO1xuICAgICAgfVxuXG4gICAgICB1cGRhdGUuY2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICB9XG5cbiAgICBlbnF1ZXVlVXBkYXRlKGZpYmVyLCB1cGRhdGUpO1xuICAgIHNjaGVkdWxlVXBkYXRlT25GaWJlcihmaWJlciwgbGFuZSwgZXZlbnRUaW1lKTtcbiAgfSxcbiAgZW5xdWV1ZUZvcmNlVXBkYXRlOiBmdW5jdGlvbiAoaW5zdCwgY2FsbGJhY2spIHtcbiAgICB2YXIgZmliZXIgPSBnZXQoaW5zdCk7XG4gICAgdmFyIGV2ZW50VGltZSA9IHJlcXVlc3RFdmVudFRpbWUoKTtcbiAgICB2YXIgbGFuZSA9IHJlcXVlc3RVcGRhdGVMYW5lKGZpYmVyKTtcbiAgICB2YXIgdXBkYXRlID0gY3JlYXRlVXBkYXRlKGV2ZW50VGltZSwgbGFuZSk7XG4gICAgdXBkYXRlLnRhZyA9IEZvcmNlVXBkYXRlO1xuXG4gICAgaWYgKGNhbGxiYWNrICE9PSB1bmRlZmluZWQgJiYgY2FsbGJhY2sgIT09IG51bGwpIHtcbiAgICAgIHtcbiAgICAgICAgd2Fybk9uSW52YWxpZENhbGxiYWNrKGNhbGxiYWNrLCAnZm9yY2VVcGRhdGUnKTtcbiAgICAgIH1cblxuICAgICAgdXBkYXRlLmNhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgfVxuXG4gICAgZW5xdWV1ZVVwZGF0ZShmaWJlciwgdXBkYXRlKTtcbiAgICBzY2hlZHVsZVVwZGF0ZU9uRmliZXIoZmliZXIsIGxhbmUsIGV2ZW50VGltZSk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGNoZWNrU2hvdWxkQ29tcG9uZW50VXBkYXRlKHdvcmtJblByb2dyZXNzLCBjdG9yLCBvbGRQcm9wcywgbmV3UHJvcHMsIG9sZFN0YXRlLCBuZXdTdGF0ZSwgbmV4dENvbnRleHQpIHtcbiAgdmFyIGluc3RhbmNlID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuXG4gIGlmICh0eXBlb2YgaW5zdGFuY2Uuc2hvdWxkQ29tcG9uZW50VXBkYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAge1xuICAgICAgaWYgKCB3b3JrSW5Qcm9ncmVzcy5tb2RlICYgU3RyaWN0TW9kZSkge1xuICAgICAgICBkaXNhYmxlTG9ncygpO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgLy8gSW52b2tlIHRoZSBmdW5jdGlvbiBhbiBleHRyYSB0aW1lIHRvIGhlbHAgZGV0ZWN0IHNpZGUtZWZmZWN0cy5cbiAgICAgICAgICBpbnN0YW5jZS5zaG91bGRDb21wb25lbnRVcGRhdGUobmV3UHJvcHMsIG5ld1N0YXRlLCBuZXh0Q29udGV4dCk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgcmVlbmFibGVMb2dzKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgc2hvdWxkVXBkYXRlID0gaW5zdGFuY2Uuc2hvdWxkQ29tcG9uZW50VXBkYXRlKG5ld1Byb3BzLCBuZXdTdGF0ZSwgbmV4dENvbnRleHQpO1xuXG4gICAge1xuICAgICAgaWYgKHNob3VsZFVwZGF0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGVycm9yKCclcy5zaG91bGRDb21wb25lbnRVcGRhdGUoKTogUmV0dXJuZWQgdW5kZWZpbmVkIGluc3RlYWQgb2YgYSAnICsgJ2Jvb2xlYW4gdmFsdWUuIE1ha2Ugc3VyZSB0byByZXR1cm4gdHJ1ZSBvciBmYWxzZS4nLCBnZXRDb21wb25lbnROYW1lKGN0b3IpIHx8ICdDb21wb25lbnQnKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gc2hvdWxkVXBkYXRlO1xuICB9XG5cbiAgaWYgKGN0b3IucHJvdG90eXBlICYmIGN0b3IucHJvdG90eXBlLmlzUHVyZVJlYWN0Q29tcG9uZW50KSB7XG4gICAgcmV0dXJuICFzaGFsbG93RXF1YWwob2xkUHJvcHMsIG5ld1Byb3BzKSB8fCAhc2hhbGxvd0VxdWFsKG9sZFN0YXRlLCBuZXdTdGF0ZSk7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gY2hlY2tDbGFzc0luc3RhbmNlKHdvcmtJblByb2dyZXNzLCBjdG9yLCBuZXdQcm9wcykge1xuICB2YXIgaW5zdGFuY2UgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG5cbiAge1xuICAgIHZhciBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZShjdG9yKSB8fCAnQ29tcG9uZW50JztcbiAgICB2YXIgcmVuZGVyUHJlc2VudCA9IGluc3RhbmNlLnJlbmRlcjtcblxuICAgIGlmICghcmVuZGVyUHJlc2VudCkge1xuICAgICAgaWYgKGN0b3IucHJvdG90eXBlICYmIHR5cGVvZiBjdG9yLnByb3RvdHlwZS5yZW5kZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgZXJyb3IoJyVzKC4uLik6IE5vIGByZW5kZXJgIG1ldGhvZCBmb3VuZCBvbiB0aGUgcmV0dXJuZWQgY29tcG9uZW50ICcgKyAnaW5zdGFuY2U6IGRpZCB5b3UgYWNjaWRlbnRhbGx5IHJldHVybiBhbiBvYmplY3QgZnJvbSB0aGUgY29uc3RydWN0b3I/JywgbmFtZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlcnJvcignJXMoLi4uKTogTm8gYHJlbmRlcmAgbWV0aG9kIGZvdW5kIG9uIHRoZSByZXR1cm5lZCBjb21wb25lbnQgJyArICdpbnN0YW5jZTogeW91IG1heSBoYXZlIGZvcmdvdHRlbiB0byBkZWZpbmUgYHJlbmRlcmAuJywgbmFtZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGluc3RhbmNlLmdldEluaXRpYWxTdGF0ZSAmJiAhaW5zdGFuY2UuZ2V0SW5pdGlhbFN0YXRlLmlzUmVhY3RDbGFzc0FwcHJvdmVkICYmICFpbnN0YW5jZS5zdGF0ZSkge1xuICAgICAgZXJyb3IoJ2dldEluaXRpYWxTdGF0ZSB3YXMgZGVmaW5lZCBvbiAlcywgYSBwbGFpbiBKYXZhU2NyaXB0IGNsYXNzLiAnICsgJ1RoaXMgaXMgb25seSBzdXBwb3J0ZWQgZm9yIGNsYXNzZXMgY3JlYXRlZCB1c2luZyBSZWFjdC5jcmVhdGVDbGFzcy4gJyArICdEaWQgeW91IG1lYW4gdG8gZGVmaW5lIGEgc3RhdGUgcHJvcGVydHkgaW5zdGVhZD8nLCBuYW1lKTtcbiAgICB9XG5cbiAgICBpZiAoaW5zdGFuY2UuZ2V0RGVmYXVsdFByb3BzICYmICFpbnN0YW5jZS5nZXREZWZhdWx0UHJvcHMuaXNSZWFjdENsYXNzQXBwcm92ZWQpIHtcbiAgICAgIGVycm9yKCdnZXREZWZhdWx0UHJvcHMgd2FzIGRlZmluZWQgb24gJXMsIGEgcGxhaW4gSmF2YVNjcmlwdCBjbGFzcy4gJyArICdUaGlzIGlzIG9ubHkgc3VwcG9ydGVkIGZvciBjbGFzc2VzIGNyZWF0ZWQgdXNpbmcgUmVhY3QuY3JlYXRlQ2xhc3MuICcgKyAnVXNlIGEgc3RhdGljIHByb3BlcnR5IHRvIGRlZmluZSBkZWZhdWx0UHJvcHMgaW5zdGVhZC4nLCBuYW1lKTtcbiAgICB9XG5cbiAgICBpZiAoaW5zdGFuY2UucHJvcFR5cGVzKSB7XG4gICAgICBlcnJvcigncHJvcFR5cGVzIHdhcyBkZWZpbmVkIGFzIGFuIGluc3RhbmNlIHByb3BlcnR5IG9uICVzLiBVc2UgYSBzdGF0aWMgJyArICdwcm9wZXJ0eSB0byBkZWZpbmUgcHJvcFR5cGVzIGluc3RlYWQuJywgbmFtZSk7XG4gICAgfVxuXG4gICAgaWYgKGluc3RhbmNlLmNvbnRleHRUeXBlKSB7XG4gICAgICBlcnJvcignY29udGV4dFR5cGUgd2FzIGRlZmluZWQgYXMgYW4gaW5zdGFuY2UgcHJvcGVydHkgb24gJXMuIFVzZSBhIHN0YXRpYyAnICsgJ3Byb3BlcnR5IHRvIGRlZmluZSBjb250ZXh0VHlwZSBpbnN0ZWFkLicsIG5hbWUpO1xuICAgIH1cblxuICAgIHtcbiAgICAgIGlmIChpbnN0YW5jZS5jb250ZXh0VHlwZXMpIHtcbiAgICAgICAgZXJyb3IoJ2NvbnRleHRUeXBlcyB3YXMgZGVmaW5lZCBhcyBhbiBpbnN0YW5jZSBwcm9wZXJ0eSBvbiAlcy4gVXNlIGEgc3RhdGljICcgKyAncHJvcGVydHkgdG8gZGVmaW5lIGNvbnRleHRUeXBlcyBpbnN0ZWFkLicsIG5hbWUpO1xuICAgICAgfVxuXG4gICAgICBpZiAoY3Rvci5jb250ZXh0VHlwZSAmJiBjdG9yLmNvbnRleHRUeXBlcyAmJiAhZGlkV2FybkFib3V0Q29udGV4dFR5cGVBbmRDb250ZXh0VHlwZXMuaGFzKGN0b3IpKSB7XG4gICAgICAgIGRpZFdhcm5BYm91dENvbnRleHRUeXBlQW5kQ29udGV4dFR5cGVzLmFkZChjdG9yKTtcblxuICAgICAgICBlcnJvcignJXMgZGVjbGFyZXMgYm90aCBjb250ZXh0VHlwZXMgYW5kIGNvbnRleHRUeXBlIHN0YXRpYyBwcm9wZXJ0aWVzLiAnICsgJ1RoZSBsZWdhY3kgY29udGV4dFR5cGVzIHByb3BlcnR5IHdpbGwgYmUgaWdub3JlZC4nLCBuYW1lKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFNob3VsZFVwZGF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgZXJyb3IoJyVzIGhhcyBhIG1ldGhvZCBjYWxsZWQgJyArICdjb21wb25lbnRTaG91bGRVcGRhdGUoKS4gRGlkIHlvdSBtZWFuIHNob3VsZENvbXBvbmVudFVwZGF0ZSgpPyAnICsgJ1RoZSBuYW1lIGlzIHBocmFzZWQgYXMgYSBxdWVzdGlvbiBiZWNhdXNlIHRoZSBmdW5jdGlvbiBpcyAnICsgJ2V4cGVjdGVkIHRvIHJldHVybiBhIHZhbHVlLicsIG5hbWUpO1xuICAgIH1cblxuICAgIGlmIChjdG9yLnByb3RvdHlwZSAmJiBjdG9yLnByb3RvdHlwZS5pc1B1cmVSZWFjdENvbXBvbmVudCAmJiB0eXBlb2YgaW5zdGFuY2Uuc2hvdWxkQ29tcG9uZW50VXBkYXRlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgZXJyb3IoJyVzIGhhcyBhIG1ldGhvZCBjYWxsZWQgc2hvdWxkQ29tcG9uZW50VXBkYXRlKCkuICcgKyAnc2hvdWxkQ29tcG9uZW50VXBkYXRlIHNob3VsZCBub3QgYmUgdXNlZCB3aGVuIGV4dGVuZGluZyBSZWFjdC5QdXJlQ29tcG9uZW50LiAnICsgJ1BsZWFzZSBleHRlbmQgUmVhY3QuQ29tcG9uZW50IGlmIHNob3VsZENvbXBvbmVudFVwZGF0ZSBpcyB1c2VkLicsIGdldENvbXBvbmVudE5hbWUoY3RvcikgfHwgJ0EgcHVyZSBjb21wb25lbnQnKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudERpZFVubW91bnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGVycm9yKCclcyBoYXMgYSBtZXRob2QgY2FsbGVkICcgKyAnY29tcG9uZW50RGlkVW5tb3VudCgpLiBCdXQgdGhlcmUgaXMgbm8gc3VjaCBsaWZlY3ljbGUgbWV0aG9kLiAnICsgJ0RpZCB5b3UgbWVhbiBjb21wb25lbnRXaWxsVW5tb3VudCgpPycsIG5hbWUpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50RGlkUmVjZWl2ZVByb3BzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBlcnJvcignJXMgaGFzIGEgbWV0aG9kIGNhbGxlZCAnICsgJ2NvbXBvbmVudERpZFJlY2VpdmVQcm9wcygpLiBCdXQgdGhlcmUgaXMgbm8gc3VjaCBsaWZlY3ljbGUgbWV0aG9kLiAnICsgJ0lmIHlvdSBtZWFudCB0byB1cGRhdGUgdGhlIHN0YXRlIGluIHJlc3BvbnNlIHRvIGNoYW5naW5nIHByb3BzLCAnICsgJ3VzZSBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKCkuIElmIHlvdSBtZWFudCB0byBmZXRjaCBkYXRhIG9yICcgKyAncnVuIHNpZGUtZWZmZWN0cyBvciBtdXRhdGlvbnMgYWZ0ZXIgUmVhY3QgaGFzIHVwZGF0ZWQgdGhlIFVJLCB1c2UgY29tcG9uZW50RGlkVXBkYXRlKCkuJywgbmFtZSk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnRXaWxsUmVjaWV2ZVByb3BzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBlcnJvcignJXMgaGFzIGEgbWV0aG9kIGNhbGxlZCAnICsgJ2NvbXBvbmVudFdpbGxSZWNpZXZlUHJvcHMoKS4gRGlkIHlvdSBtZWFuIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMoKT8nLCBuYW1lKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGluc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsUmVjaWV2ZVByb3BzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBlcnJvcignJXMgaGFzIGEgbWV0aG9kIGNhbGxlZCAnICsgJ1VOU0FGRV9jb21wb25lbnRXaWxsUmVjaWV2ZVByb3BzKCkuIERpZCB5b3UgbWVhbiBVTlNBRkVfY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcygpPycsIG5hbWUpO1xuICAgIH1cblxuICAgIHZhciBoYXNNdXRhdGVkUHJvcHMgPSBpbnN0YW5jZS5wcm9wcyAhPT0gbmV3UHJvcHM7XG5cbiAgICBpZiAoaW5zdGFuY2UucHJvcHMgIT09IHVuZGVmaW5lZCAmJiBoYXNNdXRhdGVkUHJvcHMpIHtcbiAgICAgIGVycm9yKCclcyguLi4pOiBXaGVuIGNhbGxpbmcgc3VwZXIoKSBpbiBgJXNgLCBtYWtlIHN1cmUgdG8gcGFzcyAnICsgXCJ1cCB0aGUgc2FtZSBwcm9wcyB0aGF0IHlvdXIgY29tcG9uZW50J3MgY29uc3RydWN0b3Igd2FzIHBhc3NlZC5cIiwgbmFtZSwgbmFtZSk7XG4gICAgfVxuXG4gICAgaWYgKGluc3RhbmNlLmRlZmF1bHRQcm9wcykge1xuICAgICAgZXJyb3IoJ1NldHRpbmcgZGVmYXVsdFByb3BzIGFzIGFuIGluc3RhbmNlIHByb3BlcnR5IG9uICVzIGlzIG5vdCBzdXBwb3J0ZWQgYW5kIHdpbGwgYmUgaWdub3JlZC4nICsgJyBJbnN0ZWFkLCBkZWZpbmUgZGVmYXVsdFByb3BzIGFzIGEgc3RhdGljIHByb3BlcnR5IG9uICVzLicsIG5hbWUsIG5hbWUpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudERpZFVwZGF0ZSAhPT0gJ2Z1bmN0aW9uJyAmJiAhZGlkV2FybkFib3V0R2V0U25hcHNob3RCZWZvcmVVcGRhdGVXaXRob3V0RGlkVXBkYXRlLmhhcyhjdG9yKSkge1xuICAgICAgZGlkV2FybkFib3V0R2V0U25hcHNob3RCZWZvcmVVcGRhdGVXaXRob3V0RGlkVXBkYXRlLmFkZChjdG9yKTtcblxuICAgICAgZXJyb3IoJyVzOiBnZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSgpIHNob3VsZCBiZSB1c2VkIHdpdGggY29tcG9uZW50RGlkVXBkYXRlKCkuICcgKyAnVGhpcyBjb21wb25lbnQgZGVmaW5lcyBnZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSgpIG9ubHkuJywgZ2V0Q29tcG9uZW50TmFtZShjdG9yKSk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGVycm9yKCclczogZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzKCkgaXMgZGVmaW5lZCBhcyBhbiBpbnN0YW5jZSBtZXRob2QgJyArICdhbmQgd2lsbCBiZSBpZ25vcmVkLiBJbnN0ZWFkLCBkZWNsYXJlIGl0IGFzIGEgc3RhdGljIG1ldGhvZC4nLCBuYW1lKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGluc3RhbmNlLmdldERlcml2ZWRTdGF0ZUZyb21FcnJvciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgZXJyb3IoJyVzOiBnZXREZXJpdmVkU3RhdGVGcm9tRXJyb3IoKSBpcyBkZWZpbmVkIGFzIGFuIGluc3RhbmNlIG1ldGhvZCAnICsgJ2FuZCB3aWxsIGJlIGlnbm9yZWQuIEluc3RlYWQsIGRlY2xhcmUgaXQgYXMgYSBzdGF0aWMgbWV0aG9kLicsIG5hbWUpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgY3Rvci5nZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgZXJyb3IoJyVzOiBnZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSgpIGlzIGRlZmluZWQgYXMgYSBzdGF0aWMgbWV0aG9kICcgKyAnYW5kIHdpbGwgYmUgaWdub3JlZC4gSW5zdGVhZCwgZGVjbGFyZSBpdCBhcyBhbiBpbnN0YW5jZSBtZXRob2QuJywgbmFtZSk7XG4gICAgfVxuXG4gICAgdmFyIF9zdGF0ZSA9IGluc3RhbmNlLnN0YXRlO1xuXG4gICAgaWYgKF9zdGF0ZSAmJiAodHlwZW9mIF9zdGF0ZSAhPT0gJ29iamVjdCcgfHwgaXNBcnJheShfc3RhdGUpKSkge1xuICAgICAgZXJyb3IoJyVzLnN0YXRlOiBtdXN0IGJlIHNldCB0byBhbiBvYmplY3Qgb3IgbnVsbCcsIG5hbWUpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuZ2V0Q2hpbGRDb250ZXh0ID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBjdG9yLmNoaWxkQ29udGV4dFR5cGVzICE9PSAnb2JqZWN0Jykge1xuICAgICAgZXJyb3IoJyVzLmdldENoaWxkQ29udGV4dCgpOiBjaGlsZENvbnRleHRUeXBlcyBtdXN0IGJlIGRlZmluZWQgaW4gb3JkZXIgdG8gJyArICd1c2UgZ2V0Q2hpbGRDb250ZXh0KCkuJywgbmFtZSk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGFkb3B0Q2xhc3NJbnN0YW5jZSh3b3JrSW5Qcm9ncmVzcywgaW5zdGFuY2UpIHtcbiAgaW5zdGFuY2UudXBkYXRlciA9IGNsYXNzQ29tcG9uZW50VXBkYXRlcjtcbiAgd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlID0gaW5zdGFuY2U7IC8vIFRoZSBpbnN0YW5jZSBuZWVkcyBhY2Nlc3MgdG8gdGhlIGZpYmVyIHNvIHRoYXQgaXQgY2FuIHNjaGVkdWxlIHVwZGF0ZXNcblxuICBzZXQoaW5zdGFuY2UsIHdvcmtJblByb2dyZXNzKTtcblxuICB7XG4gICAgaW5zdGFuY2UuX3JlYWN0SW50ZXJuYWxJbnN0YW5jZSA9IGZha2VJbnRlcm5hbEluc3RhbmNlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNvbnN0cnVjdENsYXNzSW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MsIGN0b3IsIHByb3BzKSB7XG4gIHZhciBpc0xlZ2FjeUNvbnRleHRDb25zdW1lciA9IGZhbHNlO1xuICB2YXIgdW5tYXNrZWRDb250ZXh0ID0gZW1wdHlDb250ZXh0T2JqZWN0O1xuICB2YXIgY29udGV4dCA9IGVtcHR5Q29udGV4dE9iamVjdDtcbiAgdmFyIGNvbnRleHRUeXBlID0gY3Rvci5jb250ZXh0VHlwZTtcblxuICB7XG4gICAgaWYgKCdjb250ZXh0VHlwZScgaW4gY3Rvcikge1xuICAgICAgdmFyIGlzVmFsaWQgPSAvLyBBbGxvdyBudWxsIGZvciBjb25kaXRpb25hbCBkZWNsYXJhdGlvblxuICAgICAgY29udGV4dFR5cGUgPT09IG51bGwgfHwgY29udGV4dFR5cGUgIT09IHVuZGVmaW5lZCAmJiBjb250ZXh0VHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfQ09OVEVYVF9UWVBFICYmIGNvbnRleHRUeXBlLl9jb250ZXh0ID09PSB1bmRlZmluZWQ7IC8vIE5vdCBhIDxDb250ZXh0LkNvbnN1bWVyPlxuXG4gICAgICBpZiAoIWlzVmFsaWQgJiYgIWRpZFdhcm5BYm91dEludmFsaWRhdGVDb250ZXh0VHlwZS5oYXMoY3RvcikpIHtcbiAgICAgICAgZGlkV2FybkFib3V0SW52YWxpZGF0ZUNvbnRleHRUeXBlLmFkZChjdG9yKTtcbiAgICAgICAgdmFyIGFkZGVuZHVtID0gJyc7XG5cbiAgICAgICAgaWYgKGNvbnRleHRUeXBlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBhZGRlbmR1bSA9ICcgSG93ZXZlciwgaXQgaXMgc2V0IHRvIHVuZGVmaW5lZC4gJyArICdUaGlzIGNhbiBiZSBjYXVzZWQgYnkgYSB0eXBvIG9yIGJ5IG1peGluZyB1cCBuYW1lZCBhbmQgZGVmYXVsdCBpbXBvcnRzLiAnICsgJ1RoaXMgY2FuIGFsc28gaGFwcGVuIGR1ZSB0byBhIGNpcmN1bGFyIGRlcGVuZGVuY3ksIHNvICcgKyAndHJ5IG1vdmluZyB0aGUgY3JlYXRlQ29udGV4dCgpIGNhbGwgdG8gYSBzZXBhcmF0ZSBmaWxlLic7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGNvbnRleHRUeXBlICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgIGFkZGVuZHVtID0gJyBIb3dldmVyLCBpdCBpcyBzZXQgdG8gYSAnICsgdHlwZW9mIGNvbnRleHRUeXBlICsgJy4nO1xuICAgICAgICB9IGVsc2UgaWYgKGNvbnRleHRUeXBlLiQkdHlwZW9mID09PSBSRUFDVF9QUk9WSURFUl9UWVBFKSB7XG4gICAgICAgICAgYWRkZW5kdW0gPSAnIERpZCB5b3UgYWNjaWRlbnRhbGx5IHBhc3MgdGhlIENvbnRleHQuUHJvdmlkZXIgaW5zdGVhZD8nO1xuICAgICAgICB9IGVsc2UgaWYgKGNvbnRleHRUeXBlLl9jb250ZXh0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAvLyA8Q29udGV4dC5Db25zdW1lcj5cbiAgICAgICAgICBhZGRlbmR1bSA9ICcgRGlkIHlvdSBhY2NpZGVudGFsbHkgcGFzcyB0aGUgQ29udGV4dC5Db25zdW1lciBpbnN0ZWFkPyc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYWRkZW5kdW0gPSAnIEhvd2V2ZXIsIGl0IGlzIHNldCB0byBhbiBvYmplY3Qgd2l0aCBrZXlzIHsnICsgT2JqZWN0LmtleXMoY29udGV4dFR5cGUpLmpvaW4oJywgJykgKyAnfS4nO1xuICAgICAgICB9XG5cbiAgICAgICAgZXJyb3IoJyVzIGRlZmluZXMgYW4gaW52YWxpZCBjb250ZXh0VHlwZS4gJyArICdjb250ZXh0VHlwZSBzaG91bGQgcG9pbnQgdG8gdGhlIENvbnRleHQgb2JqZWN0IHJldHVybmVkIGJ5IFJlYWN0LmNyZWF0ZUNvbnRleHQoKS4lcycsIGdldENvbXBvbmVudE5hbWUoY3RvcikgfHwgJ0NvbXBvbmVudCcsIGFkZGVuZHVtKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAodHlwZW9mIGNvbnRleHRUeXBlID09PSAnb2JqZWN0JyAmJiBjb250ZXh0VHlwZSAhPT0gbnVsbCkge1xuICAgIGNvbnRleHQgPSByZWFkQ29udGV4dChjb250ZXh0VHlwZSk7XG4gIH0gZWxzZSB7XG4gICAgdW5tYXNrZWRDb250ZXh0ID0gZ2V0VW5tYXNrZWRDb250ZXh0KHdvcmtJblByb2dyZXNzLCBjdG9yLCB0cnVlKTtcbiAgICB2YXIgY29udGV4dFR5cGVzID0gY3Rvci5jb250ZXh0VHlwZXM7XG4gICAgaXNMZWdhY3lDb250ZXh0Q29uc3VtZXIgPSBjb250ZXh0VHlwZXMgIT09IG51bGwgJiYgY29udGV4dFR5cGVzICE9PSB1bmRlZmluZWQ7XG4gICAgY29udGV4dCA9IGlzTGVnYWN5Q29udGV4dENvbnN1bWVyID8gZ2V0TWFza2VkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgdW5tYXNrZWRDb250ZXh0KSA6IGVtcHR5Q29udGV4dE9iamVjdDtcbiAgfSAvLyBJbnN0YW50aWF0ZSB0d2ljZSB0byBoZWxwIGRldGVjdCBzaWRlLWVmZmVjdHMuXG5cblxuICB7XG4gICAgaWYgKCB3b3JrSW5Qcm9ncmVzcy5tb2RlICYgU3RyaWN0TW9kZSkge1xuICAgICAgZGlzYWJsZUxvZ3MoKTtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgbmV3IGN0b3IocHJvcHMsIGNvbnRleHQpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5ld1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgcmVlbmFibGVMb2dzKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdmFyIGluc3RhbmNlID0gbmV3IGN0b3IocHJvcHMsIGNvbnRleHQpO1xuICB2YXIgc3RhdGUgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID0gaW5zdGFuY2Uuc3RhdGUgIT09IG51bGwgJiYgaW5zdGFuY2Uuc3RhdGUgIT09IHVuZGVmaW5lZCA/IGluc3RhbmNlLnN0YXRlIDogbnVsbDtcbiAgYWRvcHRDbGFzc0luc3RhbmNlKHdvcmtJblByb2dyZXNzLCBpbnN0YW5jZSk7XG5cbiAge1xuICAgIGlmICh0eXBlb2YgY3Rvci5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMgPT09ICdmdW5jdGlvbicgJiYgc3RhdGUgPT09IG51bGwpIHtcbiAgICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZShjdG9yKSB8fCAnQ29tcG9uZW50JztcblxuICAgICAgaWYgKCFkaWRXYXJuQWJvdXRVbmluaXRpYWxpemVkU3RhdGUuaGFzKGNvbXBvbmVudE5hbWUpKSB7XG4gICAgICAgIGRpZFdhcm5BYm91dFVuaW5pdGlhbGl6ZWRTdGF0ZS5hZGQoY29tcG9uZW50TmFtZSk7XG5cbiAgICAgICAgZXJyb3IoJ2Alc2AgdXNlcyBgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzYCBidXQgaXRzIGluaXRpYWwgc3RhdGUgaXMgJyArICclcy4gVGhpcyBpcyBub3QgcmVjb21tZW5kZWQuIEluc3RlYWQsIGRlZmluZSB0aGUgaW5pdGlhbCBzdGF0ZSBieSAnICsgJ2Fzc2lnbmluZyBhbiBvYmplY3QgdG8gYHRoaXMuc3RhdGVgIGluIHRoZSBjb25zdHJ1Y3RvciBvZiBgJXNgLiAnICsgJ1RoaXMgZW5zdXJlcyB0aGF0IGBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHNgIGFyZ3VtZW50cyBoYXZlIGEgY29uc2lzdGVudCBzaGFwZS4nLCBjb21wb25lbnROYW1lLCBpbnN0YW5jZS5zdGF0ZSA9PT0gbnVsbCA/ICdudWxsJyA6ICd1bmRlZmluZWQnLCBjb21wb25lbnROYW1lKTtcbiAgICAgIH1cbiAgICB9IC8vIElmIG5ldyBjb21wb25lbnQgQVBJcyBhcmUgZGVmaW5lZCwgXCJ1bnNhZmVcIiBsaWZlY3ljbGVzIHdvbid0IGJlIGNhbGxlZC5cbiAgICAvLyBXYXJuIGFib3V0IHRoZXNlIGxpZmVjeWNsZXMgaWYgdGhleSBhcmUgcHJlc2VudC5cbiAgICAvLyBEb24ndCB3YXJuIGFib3V0IHJlYWN0LWxpZmVjeWNsZXMtY29tcGF0IHBvbHlmaWxsZWQgbWV0aG9kcyB0aG91Z2guXG5cblxuICAgIGlmICh0eXBlb2YgY3Rvci5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMgPT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIGluc3RhbmNlLmdldFNuYXBzaG90QmVmb3JlVXBkYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB2YXIgZm91bmRXaWxsTW91bnROYW1lID0gbnVsbDtcbiAgICAgIHZhciBmb3VuZFdpbGxSZWNlaXZlUHJvcHNOYW1lID0gbnVsbDtcbiAgICAgIHZhciBmb3VuZFdpbGxVcGRhdGVOYW1lID0gbnVsbDtcblxuICAgICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnRXaWxsTW91bnQgPT09ICdmdW5jdGlvbicgJiYgaW5zdGFuY2UuY29tcG9uZW50V2lsbE1vdW50Ll9fc3VwcHJlc3NEZXByZWNhdGlvbldhcm5pbmcgIT09IHRydWUpIHtcbiAgICAgICAgZm91bmRXaWxsTW91bnROYW1lID0gJ2NvbXBvbmVudFdpbGxNb3VudCc7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBpbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbE1vdW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGZvdW5kV2lsbE1vdW50TmFtZSA9ICdVTlNBRkVfY29tcG9uZW50V2lsbE1vdW50JztcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzID09PSAnZnVuY3Rpb24nICYmIGluc3RhbmNlLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMuX19zdXBwcmVzc0RlcHJlY2F0aW9uV2FybmluZyAhPT0gdHJ1ZSkge1xuICAgICAgICBmb3VuZFdpbGxSZWNlaXZlUHJvcHNOYW1lID0gJ2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMnO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgZm91bmRXaWxsUmVjZWl2ZVByb3BzTmFtZSA9ICdVTlNBRkVfY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyc7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50V2lsbFVwZGF0ZSA9PT0gJ2Z1bmN0aW9uJyAmJiBpbnN0YW5jZS5jb21wb25lbnRXaWxsVXBkYXRlLl9fc3VwcHJlc3NEZXByZWNhdGlvbldhcm5pbmcgIT09IHRydWUpIHtcbiAgICAgICAgZm91bmRXaWxsVXBkYXRlTmFtZSA9ICdjb21wb25lbnRXaWxsVXBkYXRlJztcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGluc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsVXBkYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGZvdW5kV2lsbFVwZGF0ZU5hbWUgPSAnVU5TQUZFX2NvbXBvbmVudFdpbGxVcGRhdGUnO1xuICAgICAgfVxuXG4gICAgICBpZiAoZm91bmRXaWxsTW91bnROYW1lICE9PSBudWxsIHx8IGZvdW5kV2lsbFJlY2VpdmVQcm9wc05hbWUgIT09IG51bGwgfHwgZm91bmRXaWxsVXBkYXRlTmFtZSAhPT0gbnVsbCkge1xuICAgICAgICB2YXIgX2NvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lKGN0b3IpIHx8ICdDb21wb25lbnQnO1xuXG4gICAgICAgIHZhciBuZXdBcGlOYW1lID0gdHlwZW9mIGN0b3IuZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzID09PSAnZnVuY3Rpb24nID8gJ2dldERlcml2ZWRTdGF0ZUZyb21Qcm9wcygpJyA6ICdnZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSgpJztcblxuICAgICAgICBpZiAoIWRpZFdhcm5BYm91dExlZ2FjeUxpZmVjeWNsZXNBbmREZXJpdmVkU3RhdGUuaGFzKF9jb21wb25lbnROYW1lKSkge1xuICAgICAgICAgIGRpZFdhcm5BYm91dExlZ2FjeUxpZmVjeWNsZXNBbmREZXJpdmVkU3RhdGUuYWRkKF9jb21wb25lbnROYW1lKTtcblxuICAgICAgICAgIGVycm9yKCdVbnNhZmUgbGVnYWN5IGxpZmVjeWNsZXMgd2lsbCBub3QgYmUgY2FsbGVkIGZvciBjb21wb25lbnRzIHVzaW5nIG5ldyBjb21wb25lbnQgQVBJcy5cXG5cXG4nICsgJyVzIHVzZXMgJXMgYnV0IGFsc28gY29udGFpbnMgdGhlIGZvbGxvd2luZyBsZWdhY3kgbGlmZWN5Y2xlczolcyVzJXNcXG5cXG4nICsgJ1RoZSBhYm92ZSBsaWZlY3ljbGVzIHNob3VsZCBiZSByZW1vdmVkLiBMZWFybiBtb3JlIGFib3V0IHRoaXMgd2FybmluZyBoZXJlOlxcbicgKyAnaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3Vuc2FmZS1jb21wb25lbnQtbGlmZWN5Y2xlcycsIF9jb21wb25lbnROYW1lLCBuZXdBcGlOYW1lLCBmb3VuZFdpbGxNb3VudE5hbWUgIT09IG51bGwgPyBcIlxcbiAgXCIgKyBmb3VuZFdpbGxNb3VudE5hbWUgOiAnJywgZm91bmRXaWxsUmVjZWl2ZVByb3BzTmFtZSAhPT0gbnVsbCA/IFwiXFxuICBcIiArIGZvdW5kV2lsbFJlY2VpdmVQcm9wc05hbWUgOiAnJywgZm91bmRXaWxsVXBkYXRlTmFtZSAhPT0gbnVsbCA/IFwiXFxuICBcIiArIGZvdW5kV2lsbFVwZGF0ZU5hbWUgOiAnJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0gLy8gQ2FjaGUgdW5tYXNrZWQgY29udGV4dCBzbyB3ZSBjYW4gYXZvaWQgcmVjcmVhdGluZyBtYXNrZWQgY29udGV4dCB1bmxlc3MgbmVjZXNzYXJ5LlxuICAvLyBSZWFjdEZpYmVyQ29udGV4dCB1c3VhbGx5IHVwZGF0ZXMgdGhpcyBjYWNoZSBidXQgY2FuJ3QgZm9yIG5ld2x5LWNyZWF0ZWQgaW5zdGFuY2VzLlxuXG5cbiAgaWYgKGlzTGVnYWN5Q29udGV4dENvbnN1bWVyKSB7XG4gICAgY2FjaGVDb250ZXh0KHdvcmtJblByb2dyZXNzLCB1bm1hc2tlZENvbnRleHQsIGNvbnRleHQpO1xuICB9XG5cbiAgcmV0dXJuIGluc3RhbmNlO1xufVxuXG5mdW5jdGlvbiBjYWxsQ29tcG9uZW50V2lsbE1vdW50KHdvcmtJblByb2dyZXNzLCBpbnN0YW5jZSkge1xuICB2YXIgb2xkU3RhdGUgPSBpbnN0YW5jZS5zdGF0ZTtcblxuICBpZiAodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFdpbGxNb3VudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGluc3RhbmNlLmNvbXBvbmVudFdpbGxNb3VudCgpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBpbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbE1vdW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudCgpO1xuICB9XG5cbiAgaWYgKG9sZFN0YXRlICE9PSBpbnN0YW5jZS5zdGF0ZSkge1xuICAgIHtcbiAgICAgIGVycm9yKCclcy5jb21wb25lbnRXaWxsTW91bnQoKTogQXNzaWduaW5nIGRpcmVjdGx5IHRvIHRoaXMuc3RhdGUgaXMgJyArIFwiZGVwcmVjYXRlZCAoZXhjZXB0IGluc2lkZSBhIGNvbXBvbmVudCdzIFwiICsgJ2NvbnN0cnVjdG9yKS4gVXNlIHNldFN0YXRlIGluc3RlYWQuJywgZ2V0Q29tcG9uZW50TmFtZSh3b3JrSW5Qcm9ncmVzcy50eXBlKSB8fCAnQ29tcG9uZW50Jyk7XG4gICAgfVxuXG4gICAgY2xhc3NDb21wb25lbnRVcGRhdGVyLmVucXVldWVSZXBsYWNlU3RhdGUoaW5zdGFuY2UsIGluc3RhbmNlLnN0YXRlLCBudWxsKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjYWxsQ29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyh3b3JrSW5Qcm9ncmVzcywgaW5zdGFuY2UsIG5ld1Byb3BzLCBuZXh0Q29udGV4dCkge1xuICB2YXIgb2xkU3RhdGUgPSBpbnN0YW5jZS5zdGF0ZTtcblxuICBpZiAodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICBpbnN0YW5jZS5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKG5ld1Byb3BzLCBuZXh0Q29udGV4dCk7XG4gIH1cblxuICBpZiAodHlwZW9mIGluc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMobmV3UHJvcHMsIG5leHRDb250ZXh0KTtcbiAgfVxuXG4gIGlmIChpbnN0YW5jZS5zdGF0ZSAhPT0gb2xkU3RhdGUpIHtcbiAgICB7XG4gICAgICB2YXIgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWUod29ya0luUHJvZ3Jlc3MudHlwZSkgfHwgJ0NvbXBvbmVudCc7XG5cbiAgICAgIGlmICghZGlkV2FybkFib3V0U3RhdGVBc3NpZ25tZW50Rm9yQ29tcG9uZW50Lmhhcyhjb21wb25lbnROYW1lKSkge1xuICAgICAgICBkaWRXYXJuQWJvdXRTdGF0ZUFzc2lnbm1lbnRGb3JDb21wb25lbnQuYWRkKGNvbXBvbmVudE5hbWUpO1xuXG4gICAgICAgIGVycm9yKCclcy5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKCk6IEFzc2lnbmluZyBkaXJlY3RseSB0byAnICsgXCJ0aGlzLnN0YXRlIGlzIGRlcHJlY2F0ZWQgKGV4Y2VwdCBpbnNpZGUgYSBjb21wb25lbnQncyBcIiArICdjb25zdHJ1Y3RvcikuIFVzZSBzZXRTdGF0ZSBpbnN0ZWFkLicsIGNvbXBvbmVudE5hbWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNsYXNzQ29tcG9uZW50VXBkYXRlci5lbnF1ZXVlUmVwbGFjZVN0YXRlKGluc3RhbmNlLCBpbnN0YW5jZS5zdGF0ZSwgbnVsbCk7XG4gIH1cbn0gLy8gSW52b2tlcyB0aGUgbW91bnQgbGlmZS1jeWNsZXMgb24gYSBwcmV2aW91c2x5IG5ldmVyIHJlbmRlcmVkIGluc3RhbmNlLlxuXG5cbmZ1bmN0aW9uIG1vdW50Q2xhc3NJbnN0YW5jZSh3b3JrSW5Qcm9ncmVzcywgY3RvciwgbmV3UHJvcHMsIHJlbmRlckxhbmVzKSB7XG4gIHtcbiAgICBjaGVja0NsYXNzSW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MsIGN0b3IsIG5ld1Byb3BzKTtcbiAgfVxuXG4gIHZhciBpbnN0YW5jZSA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcbiAgaW5zdGFuY2UucHJvcHMgPSBuZXdQcm9wcztcbiAgaW5zdGFuY2Uuc3RhdGUgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO1xuICBpbnN0YW5jZS5yZWZzID0gZW1wdHlSZWZzT2JqZWN0O1xuICBpbml0aWFsaXplVXBkYXRlUXVldWUod29ya0luUHJvZ3Jlc3MpO1xuICB2YXIgY29udGV4dFR5cGUgPSBjdG9yLmNvbnRleHRUeXBlO1xuXG4gIGlmICh0eXBlb2YgY29udGV4dFR5cGUgPT09ICdvYmplY3QnICYmIGNvbnRleHRUeXBlICE9PSBudWxsKSB7XG4gICAgaW5zdGFuY2UuY29udGV4dCA9IHJlYWRDb250ZXh0KGNvbnRleHRUeXBlKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgdW5tYXNrZWRDb250ZXh0ID0gZ2V0VW5tYXNrZWRDb250ZXh0KHdvcmtJblByb2dyZXNzLCBjdG9yLCB0cnVlKTtcbiAgICBpbnN0YW5jZS5jb250ZXh0ID0gZ2V0TWFza2VkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgdW5tYXNrZWRDb250ZXh0KTtcbiAgfVxuXG4gIHtcbiAgICBpZiAoaW5zdGFuY2Uuc3RhdGUgPT09IG5ld1Byb3BzKSB7XG4gICAgICB2YXIgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWUoY3RvcikgfHwgJ0NvbXBvbmVudCc7XG5cbiAgICAgIGlmICghZGlkV2FybkFib3V0RGlyZWN0bHlBc3NpZ25pbmdQcm9wc1RvU3RhdGUuaGFzKGNvbXBvbmVudE5hbWUpKSB7XG4gICAgICAgIGRpZFdhcm5BYm91dERpcmVjdGx5QXNzaWduaW5nUHJvcHNUb1N0YXRlLmFkZChjb21wb25lbnROYW1lKTtcblxuICAgICAgICBlcnJvcignJXM6IEl0IGlzIG5vdCByZWNvbW1lbmRlZCB0byBhc3NpZ24gcHJvcHMgZGlyZWN0bHkgdG8gc3RhdGUgJyArIFwiYmVjYXVzZSB1cGRhdGVzIHRvIHByb3BzIHdvbid0IGJlIHJlZmxlY3RlZCBpbiBzdGF0ZS4gXCIgKyAnSW4gbW9zdCBjYXNlcywgaXQgaXMgYmV0dGVyIHRvIHVzZSBwcm9wcyBkaXJlY3RseS4nLCBjb21wb25lbnROYW1lKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAod29ya0luUHJvZ3Jlc3MubW9kZSAmIFN0cmljdE1vZGUpIHtcbiAgICAgIFJlYWN0U3RyaWN0TW9kZVdhcm5pbmdzLnJlY29yZExlZ2FjeUNvbnRleHRXYXJuaW5nKHdvcmtJblByb2dyZXNzLCBpbnN0YW5jZSk7XG4gICAgfVxuXG4gICAge1xuICAgICAgUmVhY3RTdHJpY3RNb2RlV2FybmluZ3MucmVjb3JkVW5zYWZlTGlmZWN5Y2xlV2FybmluZ3Mod29ya0luUHJvZ3Jlc3MsIGluc3RhbmNlKTtcbiAgICB9XG4gIH1cblxuICBwcm9jZXNzVXBkYXRlUXVldWUod29ya0luUHJvZ3Jlc3MsIG5ld1Byb3BzLCBpbnN0YW5jZSwgcmVuZGVyTGFuZXMpO1xuICBpbnN0YW5jZS5zdGF0ZSA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7XG4gIHZhciBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMgPSBjdG9yLmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcztcblxuICBpZiAodHlwZW9mIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGFwcGx5RGVyaXZlZFN0YXRlRnJvbVByb3BzKHdvcmtJblByb2dyZXNzLCBjdG9yLCBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMsIG5ld1Byb3BzKTtcbiAgICBpbnN0YW5jZS5zdGF0ZSA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7XG4gIH0gLy8gSW4gb3JkZXIgdG8gc3VwcG9ydCByZWFjdC1saWZlY3ljbGVzLWNvbXBhdCBwb2x5ZmlsbGVkIGNvbXBvbmVudHMsXG4gIC8vIFVuc2FmZSBsaWZlY3ljbGVzIHNob3VsZCBub3QgYmUgaW52b2tlZCBmb3IgY29tcG9uZW50cyB1c2luZyB0aGUgbmV3IEFQSXMuXG5cblxuICBpZiAodHlwZW9mIGN0b3IuZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzICE9PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBpbnN0YW5jZS5nZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSAhPT0gJ2Z1bmN0aW9uJyAmJiAodHlwZW9mIGluc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsTW91bnQgPT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFdpbGxNb3VudCA9PT0gJ2Z1bmN0aW9uJykpIHtcbiAgICBjYWxsQ29tcG9uZW50V2lsbE1vdW50KHdvcmtJblByb2dyZXNzLCBpbnN0YW5jZSk7IC8vIElmIHdlIGhhZCBhZGRpdGlvbmFsIHN0YXRlIHVwZGF0ZXMgZHVyaW5nIHRoaXMgbGlmZS1jeWNsZSwgbGV0J3NcbiAgICAvLyBwcm9jZXNzIHRoZW0gbm93LlxuXG4gICAgcHJvY2Vzc1VwZGF0ZVF1ZXVlKHdvcmtJblByb2dyZXNzLCBuZXdQcm9wcywgaW5zdGFuY2UsIHJlbmRlckxhbmVzKTtcbiAgICBpbnN0YW5jZS5zdGF0ZSA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7XG4gIH1cblxuICBpZiAodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudERpZE1vdW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gVXBkYXRlO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlc3VtZU1vdW50Q2xhc3NJbnN0YW5jZSh3b3JrSW5Qcm9ncmVzcywgY3RvciwgbmV3UHJvcHMsIHJlbmRlckxhbmVzKSB7XG4gIHZhciBpbnN0YW5jZSA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcbiAgdmFyIG9sZFByb3BzID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcztcbiAgaW5zdGFuY2UucHJvcHMgPSBvbGRQcm9wcztcbiAgdmFyIG9sZENvbnRleHQgPSBpbnN0YW5jZS5jb250ZXh0O1xuICB2YXIgY29udGV4dFR5cGUgPSBjdG9yLmNvbnRleHRUeXBlO1xuICB2YXIgbmV4dENvbnRleHQgPSBlbXB0eUNvbnRleHRPYmplY3Q7XG5cbiAgaWYgKHR5cGVvZiBjb250ZXh0VHlwZSA9PT0gJ29iamVjdCcgJiYgY29udGV4dFR5cGUgIT09IG51bGwpIHtcbiAgICBuZXh0Q29udGV4dCA9IHJlYWRDb250ZXh0KGNvbnRleHRUeXBlKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgbmV4dExlZ2FjeVVubWFza2VkQ29udGV4dCA9IGdldFVubWFza2VkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgY3RvciwgdHJ1ZSk7XG4gICAgbmV4dENvbnRleHQgPSBnZXRNYXNrZWRDb250ZXh0KHdvcmtJblByb2dyZXNzLCBuZXh0TGVnYWN5VW5tYXNrZWRDb250ZXh0KTtcbiAgfVxuXG4gIHZhciBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMgPSBjdG9yLmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcztcbiAgdmFyIGhhc05ld0xpZmVjeWNsZXMgPSB0eXBlb2YgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzID09PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBpbnN0YW5jZS5nZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSA9PT0gJ2Z1bmN0aW9uJzsgLy8gTm90ZTogRHVyaW5nIHRoZXNlIGxpZmUtY3ljbGVzLCBpbnN0YW5jZS5wcm9wcy9pbnN0YW5jZS5zdGF0ZSBhcmUgd2hhdFxuICAvLyBldmVyIHRoZSBwcmV2aW91c2x5IGF0dGVtcHRlZCB0byByZW5kZXIgLSBub3QgdGhlIFwiY3VycmVudFwiLiBIb3dldmVyLFxuICAvLyBkdXJpbmcgY29tcG9uZW50RGlkVXBkYXRlIHdlIHBhc3MgdGhlIFwiY3VycmVudFwiIHByb3BzLlxuICAvLyBJbiBvcmRlciB0byBzdXBwb3J0IHJlYWN0LWxpZmVjeWNsZXMtY29tcGF0IHBvbHlmaWxsZWQgY29tcG9uZW50cyxcbiAgLy8gVW5zYWZlIGxpZmVjeWNsZXMgc2hvdWxkIG5vdCBiZSBpbnZva2VkIGZvciBjb21wb25lbnRzIHVzaW5nIHRoZSBuZXcgQVBJcy5cblxuICBpZiAoIWhhc05ld0xpZmVjeWNsZXMgJiYgKHR5cGVvZiBpbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyA9PT0gJ2Z1bmN0aW9uJykpIHtcbiAgICBpZiAob2xkUHJvcHMgIT09IG5ld1Byb3BzIHx8IG9sZENvbnRleHQgIT09IG5leHRDb250ZXh0KSB7XG4gICAgICBjYWxsQ29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyh3b3JrSW5Qcm9ncmVzcywgaW5zdGFuY2UsIG5ld1Byb3BzLCBuZXh0Q29udGV4dCk7XG4gICAgfVxuICB9XG5cbiAgcmVzZXRIYXNGb3JjZVVwZGF0ZUJlZm9yZVByb2Nlc3NpbmcoKTtcbiAgdmFyIG9sZFN0YXRlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTtcbiAgdmFyIG5ld1N0YXRlID0gaW5zdGFuY2Uuc3RhdGUgPSBvbGRTdGF0ZTtcbiAgcHJvY2Vzc1VwZGF0ZVF1ZXVlKHdvcmtJblByb2dyZXNzLCBuZXdQcm9wcywgaW5zdGFuY2UsIHJlbmRlckxhbmVzKTtcbiAgbmV3U3RhdGUgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO1xuXG4gIGlmIChvbGRQcm9wcyA9PT0gbmV3UHJvcHMgJiYgb2xkU3RhdGUgPT09IG5ld1N0YXRlICYmICFoYXNDb250ZXh0Q2hhbmdlZCgpICYmICFjaGVja0hhc0ZvcmNlVXBkYXRlQWZ0ZXJQcm9jZXNzaW5nKCkpIHtcbiAgICAvLyBJZiBhbiB1cGRhdGUgd2FzIGFscmVhZHkgaW4gcHJvZ3Jlc3MsIHdlIHNob3VsZCBzY2hlZHVsZSBhbiBVcGRhdGVcbiAgICAvLyBlZmZlY3QgZXZlbiB0aG91Z2ggd2UncmUgYmFpbGluZyBvdXQsIHNvIHRoYXQgY1dVL2NEVSBhcmUgY2FsbGVkLlxuICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50RGlkTW91bnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IFVwZGF0ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAodHlwZW9mIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGFwcGx5RGVyaXZlZFN0YXRlRnJvbVByb3BzKHdvcmtJblByb2dyZXNzLCBjdG9yLCBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMsIG5ld1Byb3BzKTtcbiAgICBuZXdTdGF0ZSA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7XG4gIH1cblxuICB2YXIgc2hvdWxkVXBkYXRlID0gY2hlY2tIYXNGb3JjZVVwZGF0ZUFmdGVyUHJvY2Vzc2luZygpIHx8IGNoZWNrU2hvdWxkQ29tcG9uZW50VXBkYXRlKHdvcmtJblByb2dyZXNzLCBjdG9yLCBvbGRQcm9wcywgbmV3UHJvcHMsIG9sZFN0YXRlLCBuZXdTdGF0ZSwgbmV4dENvbnRleHQpO1xuXG4gIGlmIChzaG91bGRVcGRhdGUpIHtcbiAgICAvLyBJbiBvcmRlciB0byBzdXBwb3J0IHJlYWN0LWxpZmVjeWNsZXMtY29tcGF0IHBvbHlmaWxsZWQgY29tcG9uZW50cyxcbiAgICAvLyBVbnNhZmUgbGlmZWN5Y2xlcyBzaG91bGQgbm90IGJlIGludm9rZWQgZm9yIGNvbXBvbmVudHMgdXNpbmcgdGhlIG5ldyBBUElzLlxuICAgIGlmICghaGFzTmV3TGlmZWN5Y2xlcyAmJiAodHlwZW9mIGluc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsTW91bnQgPT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFdpbGxNb3VudCA9PT0gJ2Z1bmN0aW9uJykpIHtcbiAgICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50V2lsbE1vdW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGluc3RhbmNlLmNvbXBvbmVudFdpbGxNb3VudCgpO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIGluc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsTW91bnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudCgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50RGlkTW91bnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IFVwZGF0ZTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gSWYgYW4gdXBkYXRlIHdhcyBhbHJlYWR5IGluIHByb2dyZXNzLCB3ZSBzaG91bGQgc2NoZWR1bGUgYW4gVXBkYXRlXG4gICAgLy8gZWZmZWN0IGV2ZW4gdGhvdWdoIHdlJ3JlIGJhaWxpbmcgb3V0LCBzbyB0aGF0IGNXVS9jRFUgYXJlIGNhbGxlZC5cbiAgICBpZiAodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudERpZE1vdW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSBVcGRhdGU7XG4gICAgfSAvLyBJZiBzaG91bGRDb21wb25lbnRVcGRhdGUgcmV0dXJuZWQgZmFsc2UsIHdlIHNob3VsZCBzdGlsbCB1cGRhdGUgdGhlXG4gICAgLy8gbWVtb2l6ZWQgc3RhdGUgdG8gaW5kaWNhdGUgdGhhdCB0aGlzIHdvcmsgY2FuIGJlIHJldXNlZC5cblxuXG4gICAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcyA9IG5ld1Byb3BzO1xuICAgIHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSBuZXdTdGF0ZTtcbiAgfSAvLyBVcGRhdGUgdGhlIGV4aXN0aW5nIGluc3RhbmNlJ3Mgc3RhdGUsIHByb3BzLCBhbmQgY29udGV4dCBwb2ludGVycyBldmVuXG4gIC8vIGlmIHNob3VsZENvbXBvbmVudFVwZGF0ZSByZXR1cm5zIGZhbHNlLlxuXG5cbiAgaW5zdGFuY2UucHJvcHMgPSBuZXdQcm9wcztcbiAgaW5zdGFuY2Uuc3RhdGUgPSBuZXdTdGF0ZTtcbiAgaW5zdGFuY2UuY29udGV4dCA9IG5leHRDb250ZXh0O1xuICByZXR1cm4gc2hvdWxkVXBkYXRlO1xufSAvLyBJbnZva2VzIHRoZSB1cGRhdGUgbGlmZS1jeWNsZXMgYW5kIHJldHVybnMgZmFsc2UgaWYgaXQgc2hvdWxkbid0IHJlcmVuZGVyLlxuXG5cbmZ1bmN0aW9uIHVwZGF0ZUNsYXNzSW5zdGFuY2UoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIGN0b3IsIG5ld1Byb3BzLCByZW5kZXJMYW5lcykge1xuICB2YXIgaW5zdGFuY2UgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG4gIGNsb25lVXBkYXRlUXVldWUoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpO1xuICB2YXIgdW5yZXNvbHZlZE9sZFByb3BzID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcztcbiAgdmFyIG9sZFByb3BzID0gd29ya0luUHJvZ3Jlc3MudHlwZSA9PT0gd29ya0luUHJvZ3Jlc3MuZWxlbWVudFR5cGUgPyB1bnJlc29sdmVkT2xkUHJvcHMgOiByZXNvbHZlRGVmYXVsdFByb3BzKHdvcmtJblByb2dyZXNzLnR5cGUsIHVucmVzb2x2ZWRPbGRQcm9wcyk7XG4gIGluc3RhbmNlLnByb3BzID0gb2xkUHJvcHM7XG4gIHZhciB1bnJlc29sdmVkTmV3UHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHM7XG4gIHZhciBvbGRDb250ZXh0ID0gaW5zdGFuY2UuY29udGV4dDtcbiAgdmFyIGNvbnRleHRUeXBlID0gY3Rvci5jb250ZXh0VHlwZTtcbiAgdmFyIG5leHRDb250ZXh0ID0gZW1wdHlDb250ZXh0T2JqZWN0O1xuXG4gIGlmICh0eXBlb2YgY29udGV4dFR5cGUgPT09ICdvYmplY3QnICYmIGNvbnRleHRUeXBlICE9PSBudWxsKSB7XG4gICAgbmV4dENvbnRleHQgPSByZWFkQ29udGV4dChjb250ZXh0VHlwZSk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIG5leHRVbm1hc2tlZENvbnRleHQgPSBnZXRVbm1hc2tlZENvbnRleHQod29ya0luUHJvZ3Jlc3MsIGN0b3IsIHRydWUpO1xuICAgIG5leHRDb250ZXh0ID0gZ2V0TWFza2VkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgbmV4dFVubWFza2VkQ29udGV4dCk7XG4gIH1cblxuICB2YXIgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzID0gY3Rvci5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHM7XG4gIHZhciBoYXNOZXdMaWZlY3ljbGVzID0gdHlwZW9mIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgaW5zdGFuY2UuZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUgPT09ICdmdW5jdGlvbic7IC8vIE5vdGU6IER1cmluZyB0aGVzZSBsaWZlLWN5Y2xlcywgaW5zdGFuY2UucHJvcHMvaW5zdGFuY2Uuc3RhdGUgYXJlIHdoYXRcbiAgLy8gZXZlciB0aGUgcHJldmlvdXNseSBhdHRlbXB0ZWQgdG8gcmVuZGVyIC0gbm90IHRoZSBcImN1cnJlbnRcIi4gSG93ZXZlcixcbiAgLy8gZHVyaW5nIGNvbXBvbmVudERpZFVwZGF0ZSB3ZSBwYXNzIHRoZSBcImN1cnJlbnRcIiBwcm9wcy5cbiAgLy8gSW4gb3JkZXIgdG8gc3VwcG9ydCByZWFjdC1saWZlY3ljbGVzLWNvbXBhdCBwb2x5ZmlsbGVkIGNvbXBvbmVudHMsXG4gIC8vIFVuc2FmZSBsaWZlY3ljbGVzIHNob3VsZCBub3QgYmUgaW52b2tlZCBmb3IgY29tcG9uZW50cyB1c2luZyB0aGUgbmV3IEFQSXMuXG5cbiAgaWYgKCFoYXNOZXdMaWZlY3ljbGVzICYmICh0eXBlb2YgaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgPT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgPT09ICdmdW5jdGlvbicpKSB7XG4gICAgaWYgKHVucmVzb2x2ZWRPbGRQcm9wcyAhPT0gdW5yZXNvbHZlZE5ld1Byb3BzIHx8IG9sZENvbnRleHQgIT09IG5leHRDb250ZXh0KSB7XG4gICAgICBjYWxsQ29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyh3b3JrSW5Qcm9ncmVzcywgaW5zdGFuY2UsIG5ld1Byb3BzLCBuZXh0Q29udGV4dCk7XG4gICAgfVxuICB9XG5cbiAgcmVzZXRIYXNGb3JjZVVwZGF0ZUJlZm9yZVByb2Nlc3NpbmcoKTtcbiAgdmFyIG9sZFN0YXRlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTtcbiAgdmFyIG5ld1N0YXRlID0gaW5zdGFuY2Uuc3RhdGUgPSBvbGRTdGF0ZTtcbiAgcHJvY2Vzc1VwZGF0ZVF1ZXVlKHdvcmtJblByb2dyZXNzLCBuZXdQcm9wcywgaW5zdGFuY2UsIHJlbmRlckxhbmVzKTtcbiAgbmV3U3RhdGUgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO1xuXG4gIGlmICh1bnJlc29sdmVkT2xkUHJvcHMgPT09IHVucmVzb2x2ZWROZXdQcm9wcyAmJiBvbGRTdGF0ZSA9PT0gbmV3U3RhdGUgJiYgIWhhc0NvbnRleHRDaGFuZ2VkKCkgJiYgIWNoZWNrSGFzRm9yY2VVcGRhdGVBZnRlclByb2Nlc3NpbmcoKSkge1xuICAgIC8vIElmIGFuIHVwZGF0ZSB3YXMgYWxyZWFkeSBpbiBwcm9ncmVzcywgd2Ugc2hvdWxkIHNjaGVkdWxlIGFuIFVwZGF0ZVxuICAgIC8vIGVmZmVjdCBldmVuIHRob3VnaCB3ZSdyZSBiYWlsaW5nIG91dCwgc28gdGhhdCBjV1UvY0RVIGFyZSBjYWxsZWQuXG4gICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnREaWRVcGRhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGlmICh1bnJlc29sdmVkT2xkUHJvcHMgIT09IGN1cnJlbnQubWVtb2l6ZWRQcm9wcyB8fCBvbGRTdGF0ZSAhPT0gY3VycmVudC5tZW1vaXplZFN0YXRlKSB7XG4gICAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IFVwZGF0ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGluc3RhbmNlLmdldFNuYXBzaG90QmVmb3JlVXBkYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBpZiAodW5yZXNvbHZlZE9sZFByb3BzICE9PSBjdXJyZW50Lm1lbW9pemVkUHJvcHMgfHwgb2xkU3RhdGUgIT09IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZSkge1xuICAgICAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSBTbmFwc2hvdDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAodHlwZW9mIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGFwcGx5RGVyaXZlZFN0YXRlRnJvbVByb3BzKHdvcmtJblByb2dyZXNzLCBjdG9yLCBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMsIG5ld1Byb3BzKTtcbiAgICBuZXdTdGF0ZSA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7XG4gIH1cblxuICB2YXIgc2hvdWxkVXBkYXRlID0gY2hlY2tIYXNGb3JjZVVwZGF0ZUFmdGVyUHJvY2Vzc2luZygpIHx8IGNoZWNrU2hvdWxkQ29tcG9uZW50VXBkYXRlKHdvcmtJblByb2dyZXNzLCBjdG9yLCBvbGRQcm9wcywgbmV3UHJvcHMsIG9sZFN0YXRlLCBuZXdTdGF0ZSwgbmV4dENvbnRleHQpO1xuXG4gIGlmIChzaG91bGRVcGRhdGUpIHtcbiAgICAvLyBJbiBvcmRlciB0byBzdXBwb3J0IHJlYWN0LWxpZmVjeWNsZXMtY29tcGF0IHBvbHlmaWxsZWQgY29tcG9uZW50cyxcbiAgICAvLyBVbnNhZmUgbGlmZWN5Y2xlcyBzaG91bGQgbm90IGJlIGludm9rZWQgZm9yIGNvbXBvbmVudHMgdXNpbmcgdGhlIG5ldyBBUElzLlxuICAgIGlmICghaGFzTmV3TGlmZWN5Y2xlcyAmJiAodHlwZW9mIGluc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsVXBkYXRlID09PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnRXaWxsVXBkYXRlID09PSAnZnVuY3Rpb24nKSkge1xuICAgICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnRXaWxsVXBkYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGluc3RhbmNlLmNvbXBvbmVudFdpbGxVcGRhdGUobmV3UHJvcHMsIG5ld1N0YXRlLCBuZXh0Q29udGV4dCk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxVcGRhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxVcGRhdGUobmV3UHJvcHMsIG5ld1N0YXRlLCBuZXh0Q29udGV4dCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnREaWRVcGRhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IFVwZGF0ZTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGluc3RhbmNlLmdldFNuYXBzaG90QmVmb3JlVXBkYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSBTbmFwc2hvdDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gSWYgYW4gdXBkYXRlIHdhcyBhbHJlYWR5IGluIHByb2dyZXNzLCB3ZSBzaG91bGQgc2NoZWR1bGUgYW4gVXBkYXRlXG4gICAgLy8gZWZmZWN0IGV2ZW4gdGhvdWdoIHdlJ3JlIGJhaWxpbmcgb3V0LCBzbyB0aGF0IGNXVS9jRFUgYXJlIGNhbGxlZC5cbiAgICBpZiAodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudERpZFVwZGF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaWYgKHVucmVzb2x2ZWRPbGRQcm9wcyAhPT0gY3VycmVudC5tZW1vaXplZFByb3BzIHx8IG9sZFN0YXRlICE9PSBjdXJyZW50Lm1lbW9pemVkU3RhdGUpIHtcbiAgICAgICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gVXBkYXRlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGlmICh1bnJlc29sdmVkT2xkUHJvcHMgIT09IGN1cnJlbnQubWVtb2l6ZWRQcm9wcyB8fCBvbGRTdGF0ZSAhPT0gY3VycmVudC5tZW1vaXplZFN0YXRlKSB7XG4gICAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IFNuYXBzaG90O1xuICAgICAgfVxuICAgIH0gLy8gSWYgc2hvdWxkQ29tcG9uZW50VXBkYXRlIHJldHVybmVkIGZhbHNlLCB3ZSBzaG91bGQgc3RpbGwgdXBkYXRlIHRoZVxuICAgIC8vIG1lbW9pemVkIHByb3BzL3N0YXRlIHRvIGluZGljYXRlIHRoYXQgdGhpcyB3b3JrIGNhbiBiZSByZXVzZWQuXG5cblxuICAgIHdvcmtJblByb2dyZXNzLm1lbW9pemVkUHJvcHMgPSBuZXdQcm9wcztcbiAgICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID0gbmV3U3RhdGU7XG4gIH0gLy8gVXBkYXRlIHRoZSBleGlzdGluZyBpbnN0YW5jZSdzIHN0YXRlLCBwcm9wcywgYW5kIGNvbnRleHQgcG9pbnRlcnMgZXZlblxuICAvLyBpZiBzaG91bGRDb21wb25lbnRVcGRhdGUgcmV0dXJucyBmYWxzZS5cblxuXG4gIGluc3RhbmNlLnByb3BzID0gbmV3UHJvcHM7XG4gIGluc3RhbmNlLnN0YXRlID0gbmV3U3RhdGU7XG4gIGluc3RhbmNlLmNvbnRleHQgPSBuZXh0Q29udGV4dDtcbiAgcmV0dXJuIHNob3VsZFVwZGF0ZTtcbn1cblxudmFyIGRpZFdhcm5BYm91dE1hcHM7XG52YXIgZGlkV2FybkFib3V0R2VuZXJhdG9ycztcbnZhciBkaWRXYXJuQWJvdXRTdHJpbmdSZWZzO1xudmFyIG93bmVySGFzS2V5VXNlV2FybmluZztcbnZhciBvd25lckhhc0Z1bmN0aW9uVHlwZVdhcm5pbmc7XG5cbnZhciB3YXJuRm9yTWlzc2luZ0tleSA9IGZ1bmN0aW9uIChjaGlsZCwgcmV0dXJuRmliZXIpIHt9O1xuXG57XG4gIGRpZFdhcm5BYm91dE1hcHMgPSBmYWxzZTtcbiAgZGlkV2FybkFib3V0R2VuZXJhdG9ycyA9IGZhbHNlO1xuICBkaWRXYXJuQWJvdXRTdHJpbmdSZWZzID0ge307XG4gIC8qKlxuICAgKiBXYXJuIGlmIHRoZXJlJ3Mgbm8ga2V5IGV4cGxpY2l0bHkgc2V0IG9uIGR5bmFtaWMgYXJyYXlzIG9mIGNoaWxkcmVuIG9yXG4gICAqIG9iamVjdCBrZXlzIGFyZSBub3QgdmFsaWQuIFRoaXMgYWxsb3dzIHVzIHRvIGtlZXAgdHJhY2sgb2YgY2hpbGRyZW4gYmV0d2VlblxuICAgKiB1cGRhdGVzLlxuICAgKi9cblxuICBvd25lckhhc0tleVVzZVdhcm5pbmcgPSB7fTtcbiAgb3duZXJIYXNGdW5jdGlvblR5cGVXYXJuaW5nID0ge307XG5cbiAgd2FybkZvck1pc3NpbmdLZXkgPSBmdW5jdGlvbiAoY2hpbGQsIHJldHVybkZpYmVyKSB7XG4gICAgaWYgKGNoaWxkID09PSBudWxsIHx8IHR5cGVvZiBjaGlsZCAhPT0gJ29iamVjdCcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoIWNoaWxkLl9zdG9yZSB8fCBjaGlsZC5fc3RvcmUudmFsaWRhdGVkIHx8IGNoaWxkLmtleSAhPSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKCEodHlwZW9mIGNoaWxkLl9zdG9yZSA9PT0gJ29iamVjdCcpKSB7XG4gICAgICB7XG4gICAgICAgIHRocm93IEVycm9yKCBcIlJlYWN0IENvbXBvbmVudCBpbiB3YXJuRm9yTWlzc2luZ0tleSBzaG91bGQgaGF2ZSBhIF9zdG9yZS4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS5cIiApO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNoaWxkLl9zdG9yZS52YWxpZGF0ZWQgPSB0cnVlO1xuICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZShyZXR1cm5GaWJlci50eXBlKSB8fCAnQ29tcG9uZW50JztcblxuICAgIGlmIChvd25lckhhc0tleVVzZVdhcm5pbmdbY29tcG9uZW50TmFtZV0pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBvd25lckhhc0tleVVzZVdhcm5pbmdbY29tcG9uZW50TmFtZV0gPSB0cnVlO1xuXG4gICAgZXJyb3IoJ0VhY2ggY2hpbGQgaW4gYSBsaXN0IHNob3VsZCBoYXZlIGEgdW5pcXVlICcgKyAnXCJrZXlcIiBwcm9wLiBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3dhcm5pbmcta2V5cyBmb3IgJyArICdtb3JlIGluZm9ybWF0aW9uLicpO1xuICB9O1xufVxuXG52YXIgaXNBcnJheSQxID0gQXJyYXkuaXNBcnJheTtcblxuZnVuY3Rpb24gY29lcmNlUmVmKHJldHVybkZpYmVyLCBjdXJyZW50LCBlbGVtZW50KSB7XG4gIHZhciBtaXhlZFJlZiA9IGVsZW1lbnQucmVmO1xuXG4gIGlmIChtaXhlZFJlZiAhPT0gbnVsbCAmJiB0eXBlb2YgbWl4ZWRSZWYgIT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIG1peGVkUmVmICE9PSAnb2JqZWN0Jykge1xuICAgIHtcbiAgICAgIC8vIFRPRE86IENsZWFuIHRoaXMgdXAgb25jZSB3ZSB0dXJuIG9uIHRoZSBzdHJpbmcgcmVmIHdhcm5pbmcgZm9yXG4gICAgICAvLyBldmVyeW9uZSwgYmVjYXVzZSB0aGUgc3RyaWN0IG1vZGUgY2FzZSB3aWxsIG5vIGxvbmdlciBiZSByZWxldmFudFxuICAgICAgaWYgKChyZXR1cm5GaWJlci5tb2RlICYgU3RyaWN0TW9kZSB8fCB3YXJuQWJvdXRTdHJpbmdSZWZzKSAmJiAvLyBXZSB3YXJuIGluIFJlYWN0RWxlbWVudC5qcyBpZiBvd25lciBhbmQgc2VsZiBhcmUgZXF1YWwgZm9yIHN0cmluZyByZWZzXG4gICAgICAvLyBiZWNhdXNlIHRoZXNlIGNhbm5vdCBiZSBhdXRvbWF0aWNhbGx5IGNvbnZlcnRlZCB0byBhbiBhcnJvdyBmdW5jdGlvblxuICAgICAgLy8gdXNpbmcgYSBjb2RlbW9kLiBUaGVyZWZvcmUsIHdlIGRvbid0IGhhdmUgdG8gd2FybiBhYm91dCBzdHJpbmcgcmVmcyBhZ2Fpbi5cbiAgICAgICEoZWxlbWVudC5fb3duZXIgJiYgZWxlbWVudC5fc2VsZiAmJiBlbGVtZW50Ll9vd25lci5zdGF0ZU5vZGUgIT09IGVsZW1lbnQuX3NlbGYpKSB7XG4gICAgICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZShyZXR1cm5GaWJlci50eXBlKSB8fCAnQ29tcG9uZW50JztcblxuICAgICAgICBpZiAoIWRpZFdhcm5BYm91dFN0cmluZ1JlZnNbY29tcG9uZW50TmFtZV0pIHtcbiAgICAgICAgICB7XG4gICAgICAgICAgICBlcnJvcignQSBzdHJpbmcgcmVmLCBcIiVzXCIsIGhhcyBiZWVuIGZvdW5kIHdpdGhpbiBhIHN0cmljdCBtb2RlIHRyZWUuICcgKyAnU3RyaW5nIHJlZnMgYXJlIGEgc291cmNlIG9mIHBvdGVudGlhbCBidWdzIGFuZCBzaG91bGQgYmUgYXZvaWRlZC4gJyArICdXZSByZWNvbW1lbmQgdXNpbmcgdXNlUmVmKCkgb3IgY3JlYXRlUmVmKCkgaW5zdGVhZC4gJyArICdMZWFybiBtb3JlIGFib3V0IHVzaW5nIHJlZnMgc2FmZWx5IGhlcmU6ICcgKyAnaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3N0cmljdC1tb2RlLXN0cmluZy1yZWYnLCBtaXhlZFJlZik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZGlkV2FybkFib3V0U3RyaW5nUmVmc1tjb21wb25lbnROYW1lXSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZWxlbWVudC5fb3duZXIpIHtcbiAgICAgIHZhciBvd25lciA9IGVsZW1lbnQuX293bmVyO1xuICAgICAgdmFyIGluc3Q7XG5cbiAgICAgIGlmIChvd25lcikge1xuICAgICAgICB2YXIgb3duZXJGaWJlciA9IG93bmVyO1xuXG4gICAgICAgIGlmICghKG93bmVyRmliZXIudGFnID09PSBDbGFzc0NvbXBvbmVudCkpIHtcbiAgICAgICAgICB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvciggXCJGdW5jdGlvbiBjb21wb25lbnRzIGNhbm5vdCBoYXZlIHN0cmluZyByZWZzLiBXZSByZWNvbW1lbmQgdXNpbmcgdXNlUmVmKCkgaW5zdGVhZC4gTGVhcm4gbW9yZSBhYm91dCB1c2luZyByZWZzIHNhZmVseSBoZXJlOiBodHRwczovL3JlYWN0anMub3JnL2xpbmsvc3RyaWN0LW1vZGUtc3RyaW5nLXJlZlwiICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaW5zdCA9IG93bmVyRmliZXIuc3RhdGVOb2RlO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWluc3QpIHtcbiAgICAgICAge1xuICAgICAgICAgIHRocm93IEVycm9yKCBcIk1pc3Npbmcgb3duZXIgZm9yIHN0cmluZyByZWYgXCIgKyBtaXhlZFJlZiArIFwiLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiICk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIHN0cmluZ1JlZiA9ICcnICsgbWl4ZWRSZWY7IC8vIENoZWNrIGlmIHByZXZpb3VzIHN0cmluZyByZWYgbWF0Y2hlcyBuZXcgc3RyaW5nIHJlZlxuXG4gICAgICBpZiAoY3VycmVudCAhPT0gbnVsbCAmJiBjdXJyZW50LnJlZiAhPT0gbnVsbCAmJiB0eXBlb2YgY3VycmVudC5yZWYgPT09ICdmdW5jdGlvbicgJiYgY3VycmVudC5yZWYuX3N0cmluZ1JlZiA9PT0gc3RyaW5nUmVmKSB7XG4gICAgICAgIHJldHVybiBjdXJyZW50LnJlZjtcbiAgICAgIH1cblxuICAgICAgdmFyIHJlZiA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB2YXIgcmVmcyA9IGluc3QucmVmcztcblxuICAgICAgICBpZiAocmVmcyA9PT0gZW1wdHlSZWZzT2JqZWN0KSB7XG4gICAgICAgICAgLy8gVGhpcyBpcyBhIGxhenkgcG9vbGVkIGZyb3plbiBvYmplY3QsIHNvIHdlIG5lZWQgdG8gaW5pdGlhbGl6ZS5cbiAgICAgICAgICByZWZzID0gaW5zdC5yZWZzID0ge307XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICBkZWxldGUgcmVmc1tzdHJpbmdSZWZdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlZnNbc3RyaW5nUmVmXSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICByZWYuX3N0cmluZ1JlZiA9IHN0cmluZ1JlZjtcbiAgICAgIHJldHVybiByZWY7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICghKHR5cGVvZiBtaXhlZFJlZiA9PT0gJ3N0cmluZycpKSB7XG4gICAgICAgIHtcbiAgICAgICAgICB0aHJvdyBFcnJvciggXCJFeHBlY3RlZCByZWYgdG8gYmUgYSBmdW5jdGlvbiwgYSBzdHJpbmcsIGFuIG9iamVjdCByZXR1cm5lZCBieSBSZWFjdC5jcmVhdGVSZWYoKSwgb3IgbnVsbC5cIiApO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICghZWxlbWVudC5fb3duZXIpIHtcbiAgICAgICAge1xuICAgICAgICAgIHRocm93IEVycm9yKCBcIkVsZW1lbnQgcmVmIHdhcyBzcGVjaWZpZWQgYXMgYSBzdHJpbmcgKFwiICsgbWl4ZWRSZWYgKyBcIikgYnV0IG5vIG93bmVyIHdhcyBzZXQuIFRoaXMgY291bGQgaGFwcGVuIGZvciBvbmUgb2YgdGhlIGZvbGxvd2luZyByZWFzb25zOlxcbjEuIFlvdSBtYXkgYmUgYWRkaW5nIGEgcmVmIHRvIGEgZnVuY3Rpb24gY29tcG9uZW50XFxuMi4gWW91IG1heSBiZSBhZGRpbmcgYSByZWYgdG8gYSBjb21wb25lbnQgdGhhdCB3YXMgbm90IGNyZWF0ZWQgaW5zaWRlIGEgY29tcG9uZW50J3MgcmVuZGVyIG1ldGhvZFxcbjMuIFlvdSBoYXZlIG11bHRpcGxlIGNvcGllcyBvZiBSZWFjdCBsb2FkZWRcXG5TZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3JlZnMtbXVzdC1oYXZlLW93bmVyIGZvciBtb3JlIGluZm9ybWF0aW9uLlwiICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbWl4ZWRSZWY7XG59XG5cbmZ1bmN0aW9uIHRocm93T25JbnZhbGlkT2JqZWN0VHlwZShyZXR1cm5GaWJlciwgbmV3Q2hpbGQpIHtcbiAgaWYgKHJldHVybkZpYmVyLnR5cGUgIT09ICd0ZXh0YXJlYScpIHtcbiAgICB7XG4gICAgICB7XG4gICAgICAgIHRocm93IEVycm9yKCBcIk9iamVjdHMgYXJlIG5vdCB2YWxpZCBhcyBhIFJlYWN0IGNoaWxkIChmb3VuZDogXCIgKyAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG5ld0NoaWxkKSA9PT0gJ1tvYmplY3QgT2JqZWN0XScgPyAnb2JqZWN0IHdpdGgga2V5cyB7JyArIE9iamVjdC5rZXlzKG5ld0NoaWxkKS5qb2luKCcsICcpICsgJ30nIDogbmV3Q2hpbGQpICsgXCIpLiBJZiB5b3UgbWVhbnQgdG8gcmVuZGVyIGEgY29sbGVjdGlvbiBvZiBjaGlsZHJlbiwgdXNlIGFuIGFycmF5IGluc3RlYWQuXCIgKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gd2Fybk9uRnVuY3Rpb25UeXBlKHJldHVybkZpYmVyKSB7XG4gIHtcbiAgICB2YXIgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWUocmV0dXJuRmliZXIudHlwZSkgfHwgJ0NvbXBvbmVudCc7XG5cbiAgICBpZiAob3duZXJIYXNGdW5jdGlvblR5cGVXYXJuaW5nW2NvbXBvbmVudE5hbWVdKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgb3duZXJIYXNGdW5jdGlvblR5cGVXYXJuaW5nW2NvbXBvbmVudE5hbWVdID0gdHJ1ZTtcblxuICAgIGVycm9yKCdGdW5jdGlvbnMgYXJlIG5vdCB2YWxpZCBhcyBhIFJlYWN0IGNoaWxkLiBUaGlzIG1heSBoYXBwZW4gaWYgJyArICd5b3UgcmV0dXJuIGEgQ29tcG9uZW50IGluc3RlYWQgb2YgPENvbXBvbmVudCAvPiBmcm9tIHJlbmRlci4gJyArICdPciBtYXliZSB5b3UgbWVhbnQgdG8gY2FsbCB0aGlzIGZ1bmN0aW9uIHJhdGhlciB0aGFuIHJldHVybiBpdC4nKTtcbiAgfVxufSAvLyBXZSBhdm9pZCBpbmxpbmluZyB0aGlzIHRvIGF2b2lkIHBvdGVudGlhbCBkZW9wdHMgZnJvbSB1c2luZyB0cnkvY2F0Y2guXG4vLyB0byBiZSBhYmxlIHRvIG9wdGltaXplIGVhY2ggcGF0aCBpbmRpdmlkdWFsbHkgYnkgYnJhbmNoaW5nIGVhcmx5LiBUaGlzIG5lZWRzXG4vLyBhIGNvbXBpbGVyIG9yIHdlIGNhbiBkbyBpdCBtYW51YWxseS4gSGVscGVycyB0aGF0IGRvbid0IG5lZWQgdGhpcyBicmFuY2hpbmdcbi8vIGxpdmUgb3V0c2lkZSBvZiB0aGlzIGZ1bmN0aW9uLlxuXG5cbmZ1bmN0aW9uIENoaWxkUmVjb25jaWxlcihzaG91bGRUcmFja1NpZGVFZmZlY3RzKSB7XG4gIGZ1bmN0aW9uIGRlbGV0ZUNoaWxkKHJldHVybkZpYmVyLCBjaGlsZFRvRGVsZXRlKSB7XG4gICAgaWYgKCFzaG91bGRUcmFja1NpZGVFZmZlY3RzKSB7XG4gICAgICAvLyBOb29wLlxuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gRGVsZXRpb25zIGFyZSBhZGRlZCBpbiByZXZlcnNlZCBvcmRlciBzbyB3ZSBhZGQgaXQgdG8gdGhlIGZyb250LlxuICAgIC8vIEF0IHRoaXMgcG9pbnQsIHRoZSByZXR1cm4gZmliZXIncyBlZmZlY3QgbGlzdCBpcyBlbXB0eSBleGNlcHQgZm9yXG4gICAgLy8gZGVsZXRpb25zLCBzbyB3ZSBjYW4ganVzdCBhcHBlbmQgdGhlIGRlbGV0aW9uIHRvIHRoZSBsaXN0LiBUaGUgcmVtYWluaW5nXG4gICAgLy8gZWZmZWN0cyBhcmVuJ3QgYWRkZWQgdW50aWwgdGhlIGNvbXBsZXRlIHBoYXNlLiBPbmNlIHdlIGltcGxlbWVudFxuICAgIC8vIHJlc3VtaW5nLCB0aGlzIG1heSBub3QgYmUgdHJ1ZS5cblxuXG4gICAgdmFyIGxhc3QgPSByZXR1cm5GaWJlci5sYXN0RWZmZWN0O1xuXG4gICAgaWYgKGxhc3QgIT09IG51bGwpIHtcbiAgICAgIGxhc3QubmV4dEVmZmVjdCA9IGNoaWxkVG9EZWxldGU7XG4gICAgICByZXR1cm5GaWJlci5sYXN0RWZmZWN0ID0gY2hpbGRUb0RlbGV0ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuRmliZXIuZmlyc3RFZmZlY3QgPSByZXR1cm5GaWJlci5sYXN0RWZmZWN0ID0gY2hpbGRUb0RlbGV0ZTtcbiAgICB9XG5cbiAgICBjaGlsZFRvRGVsZXRlLm5leHRFZmZlY3QgPSBudWxsO1xuICAgIGNoaWxkVG9EZWxldGUuZmxhZ3MgPSBEZWxldGlvbjtcbiAgfVxuXG4gIGZ1bmN0aW9uIGRlbGV0ZVJlbWFpbmluZ0NoaWxkcmVuKHJldHVybkZpYmVyLCBjdXJyZW50Rmlyc3RDaGlsZCkge1xuICAgIGlmICghc2hvdWxkVHJhY2tTaWRlRWZmZWN0cykge1xuICAgICAgLy8gTm9vcC5cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0gLy8gVE9ETzogRm9yIHRoZSBzaG91bGRDbG9uZSBjYXNlLCB0aGlzIGNvdWxkIGJlIG1pY3JvLW9wdGltaXplZCBhIGJpdCBieVxuICAgIC8vIGFzc3VtaW5nIHRoYXQgYWZ0ZXIgdGhlIGZpcnN0IGNoaWxkIHdlJ3ZlIGFscmVhZHkgYWRkZWQgZXZlcnl0aGluZy5cblxuXG4gICAgdmFyIGNoaWxkVG9EZWxldGUgPSBjdXJyZW50Rmlyc3RDaGlsZDtcblxuICAgIHdoaWxlIChjaGlsZFRvRGVsZXRlICE9PSBudWxsKSB7XG4gICAgICBkZWxldGVDaGlsZChyZXR1cm5GaWJlciwgY2hpbGRUb0RlbGV0ZSk7XG4gICAgICBjaGlsZFRvRGVsZXRlID0gY2hpbGRUb0RlbGV0ZS5zaWJsaW5nO1xuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgZnVuY3Rpb24gbWFwUmVtYWluaW5nQ2hpbGRyZW4ocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkKSB7XG4gICAgLy8gQWRkIHRoZSByZW1haW5pbmcgY2hpbGRyZW4gdG8gYSB0ZW1wb3JhcnkgbWFwIHNvIHRoYXQgd2UgY2FuIGZpbmQgdGhlbSBieVxuICAgIC8vIGtleXMgcXVpY2tseS4gSW1wbGljaXQgKG51bGwpIGtleXMgZ2V0IGFkZGVkIHRvIHRoaXMgc2V0IHdpdGggdGhlaXIgaW5kZXhcbiAgICAvLyBpbnN0ZWFkLlxuICAgIHZhciBleGlzdGluZ0NoaWxkcmVuID0gbmV3IE1hcCgpO1xuICAgIHZhciBleGlzdGluZ0NoaWxkID0gY3VycmVudEZpcnN0Q2hpbGQ7XG5cbiAgICB3aGlsZSAoZXhpc3RpbmdDaGlsZCAhPT0gbnVsbCkge1xuICAgICAgaWYgKGV4aXN0aW5nQ2hpbGQua2V5ICE9PSBudWxsKSB7XG4gICAgICAgIGV4aXN0aW5nQ2hpbGRyZW4uc2V0KGV4aXN0aW5nQ2hpbGQua2V5LCBleGlzdGluZ0NoaWxkKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGV4aXN0aW5nQ2hpbGRyZW4uc2V0KGV4aXN0aW5nQ2hpbGQuaW5kZXgsIGV4aXN0aW5nQ2hpbGQpO1xuICAgICAgfVxuXG4gICAgICBleGlzdGluZ0NoaWxkID0gZXhpc3RpbmdDaGlsZC5zaWJsaW5nO1xuICAgIH1cblxuICAgIHJldHVybiBleGlzdGluZ0NoaWxkcmVuO1xuICB9XG5cbiAgZnVuY3Rpb24gdXNlRmliZXIoZmliZXIsIHBlbmRpbmdQcm9wcykge1xuICAgIC8vIFdlIGN1cnJlbnRseSBzZXQgc2libGluZyB0byBudWxsIGFuZCBpbmRleCB0byAwIGhlcmUgYmVjYXVzZSBpdCBpcyBlYXN5XG4gICAgLy8gdG8gZm9yZ2V0IHRvIGRvIGJlZm9yZSByZXR1cm5pbmcgaXQuIEUuZy4gZm9yIHRoZSBzaW5nbGUgY2hpbGQgY2FzZS5cbiAgICB2YXIgY2xvbmUgPSBjcmVhdGVXb3JrSW5Qcm9ncmVzcyhmaWJlciwgcGVuZGluZ1Byb3BzKTtcbiAgICBjbG9uZS5pbmRleCA9IDA7XG4gICAgY2xvbmUuc2libGluZyA9IG51bGw7XG4gICAgcmV0dXJuIGNsb25lO1xuICB9XG5cbiAgZnVuY3Rpb24gcGxhY2VDaGlsZChuZXdGaWJlciwgbGFzdFBsYWNlZEluZGV4LCBuZXdJbmRleCkge1xuICAgIG5ld0ZpYmVyLmluZGV4ID0gbmV3SW5kZXg7XG5cbiAgICBpZiAoIXNob3VsZFRyYWNrU2lkZUVmZmVjdHMpIHtcbiAgICAgIC8vIE5vb3AuXG4gICAgICByZXR1cm4gbGFzdFBsYWNlZEluZGV4O1xuICAgIH1cblxuICAgIHZhciBjdXJyZW50ID0gbmV3RmliZXIuYWx0ZXJuYXRlO1xuXG4gICAgaWYgKGN1cnJlbnQgIT09IG51bGwpIHtcbiAgICAgIHZhciBvbGRJbmRleCA9IGN1cnJlbnQuaW5kZXg7XG5cbiAgICAgIGlmIChvbGRJbmRleCA8IGxhc3RQbGFjZWRJbmRleCkge1xuICAgICAgICAvLyBUaGlzIGlzIGEgbW92ZS5cbiAgICAgICAgbmV3RmliZXIuZmxhZ3MgPSBQbGFjZW1lbnQ7XG4gICAgICAgIHJldHVybiBsYXN0UGxhY2VkSW5kZXg7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBUaGlzIGl0ZW0gY2FuIHN0YXkgaW4gcGxhY2UuXG4gICAgICAgIHJldHVybiBvbGRJbmRleDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVGhpcyBpcyBhbiBpbnNlcnRpb24uXG4gICAgICBuZXdGaWJlci5mbGFncyA9IFBsYWNlbWVudDtcbiAgICAgIHJldHVybiBsYXN0UGxhY2VkSW5kZXg7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcGxhY2VTaW5nbGVDaGlsZChuZXdGaWJlcikge1xuICAgIC8vIFRoaXMgaXMgc2ltcGxlciBmb3IgdGhlIHNpbmdsZSBjaGlsZCBjYXNlLiBXZSBvbmx5IG5lZWQgdG8gZG8gYVxuICAgIC8vIHBsYWNlbWVudCBmb3IgaW5zZXJ0aW5nIG5ldyBjaGlsZHJlbi5cbiAgICBpZiAoc2hvdWxkVHJhY2tTaWRlRWZmZWN0cyAmJiBuZXdGaWJlci5hbHRlcm5hdGUgPT09IG51bGwpIHtcbiAgICAgIG5ld0ZpYmVyLmZsYWdzID0gUGxhY2VtZW50O1xuICAgIH1cblxuICAgIHJldHVybiBuZXdGaWJlcjtcbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZVRleHROb2RlKHJldHVybkZpYmVyLCBjdXJyZW50LCB0ZXh0Q29udGVudCwgbGFuZXMpIHtcbiAgICBpZiAoY3VycmVudCA9PT0gbnVsbCB8fCBjdXJyZW50LnRhZyAhPT0gSG9zdFRleHQpIHtcbiAgICAgIC8vIEluc2VydFxuICAgICAgdmFyIGNyZWF0ZWQgPSBjcmVhdGVGaWJlckZyb21UZXh0KHRleHRDb250ZW50LCByZXR1cm5GaWJlci5tb2RlLCBsYW5lcyk7XG4gICAgICBjcmVhdGVkLnJldHVybiA9IHJldHVybkZpYmVyO1xuICAgICAgcmV0dXJuIGNyZWF0ZWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFVwZGF0ZVxuICAgICAgdmFyIGV4aXN0aW5nID0gdXNlRmliZXIoY3VycmVudCwgdGV4dENvbnRlbnQpO1xuICAgICAgZXhpc3RpbmcucmV0dXJuID0gcmV0dXJuRmliZXI7XG4gICAgICByZXR1cm4gZXhpc3Rpbmc7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlRWxlbWVudChyZXR1cm5GaWJlciwgY3VycmVudCwgZWxlbWVudCwgbGFuZXMpIHtcbiAgICBpZiAoY3VycmVudCAhPT0gbnVsbCkge1xuICAgICAgaWYgKGN1cnJlbnQuZWxlbWVudFR5cGUgPT09IGVsZW1lbnQudHlwZSB8fCAoIC8vIEtlZXAgdGhpcyBjaGVjayBpbmxpbmUgc28gaXQgb25seSBydW5zIG9uIHRoZSBmYWxzZSBwYXRoOlxuICAgICAgIGlzQ29tcGF0aWJsZUZhbWlseUZvckhvdFJlbG9hZGluZyhjdXJyZW50LCBlbGVtZW50KSApKSB7XG4gICAgICAgIC8vIE1vdmUgYmFzZWQgb24gaW5kZXhcbiAgICAgICAgdmFyIGV4aXN0aW5nID0gdXNlRmliZXIoY3VycmVudCwgZWxlbWVudC5wcm9wcyk7XG4gICAgICAgIGV4aXN0aW5nLnJlZiA9IGNvZXJjZVJlZihyZXR1cm5GaWJlciwgY3VycmVudCwgZWxlbWVudCk7XG4gICAgICAgIGV4aXN0aW5nLnJldHVybiA9IHJldHVybkZpYmVyO1xuXG4gICAgICAgIHtcbiAgICAgICAgICBleGlzdGluZy5fZGVidWdTb3VyY2UgPSBlbGVtZW50Ll9zb3VyY2U7XG4gICAgICAgICAgZXhpc3RpbmcuX2RlYnVnT3duZXIgPSBlbGVtZW50Ll9vd25lcjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBleGlzdGluZztcbiAgICAgIH1cbiAgICB9IC8vIEluc2VydFxuXG5cbiAgICB2YXIgY3JlYXRlZCA9IGNyZWF0ZUZpYmVyRnJvbUVsZW1lbnQoZWxlbWVudCwgcmV0dXJuRmliZXIubW9kZSwgbGFuZXMpO1xuICAgIGNyZWF0ZWQucmVmID0gY29lcmNlUmVmKHJldHVybkZpYmVyLCBjdXJyZW50LCBlbGVtZW50KTtcbiAgICBjcmVhdGVkLnJldHVybiA9IHJldHVybkZpYmVyO1xuICAgIHJldHVybiBjcmVhdGVkO1xuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlUG9ydGFsKHJldHVybkZpYmVyLCBjdXJyZW50LCBwb3J0YWwsIGxhbmVzKSB7XG4gICAgaWYgKGN1cnJlbnQgPT09IG51bGwgfHwgY3VycmVudC50YWcgIT09IEhvc3RQb3J0YWwgfHwgY3VycmVudC5zdGF0ZU5vZGUuY29udGFpbmVySW5mbyAhPT0gcG9ydGFsLmNvbnRhaW5lckluZm8gfHwgY3VycmVudC5zdGF0ZU5vZGUuaW1wbGVtZW50YXRpb24gIT09IHBvcnRhbC5pbXBsZW1lbnRhdGlvbikge1xuICAgICAgLy8gSW5zZXJ0XG4gICAgICB2YXIgY3JlYXRlZCA9IGNyZWF0ZUZpYmVyRnJvbVBvcnRhbChwb3J0YWwsIHJldHVybkZpYmVyLm1vZGUsIGxhbmVzKTtcbiAgICAgIGNyZWF0ZWQucmV0dXJuID0gcmV0dXJuRmliZXI7XG4gICAgICByZXR1cm4gY3JlYXRlZDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVXBkYXRlXG4gICAgICB2YXIgZXhpc3RpbmcgPSB1c2VGaWJlcihjdXJyZW50LCBwb3J0YWwuY2hpbGRyZW4gfHwgW10pO1xuICAgICAgZXhpc3RpbmcucmV0dXJuID0gcmV0dXJuRmliZXI7XG4gICAgICByZXR1cm4gZXhpc3Rpbmc7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlRnJhZ21lbnQocmV0dXJuRmliZXIsIGN1cnJlbnQsIGZyYWdtZW50LCBsYW5lcywga2V5KSB7XG4gICAgaWYgKGN1cnJlbnQgPT09IG51bGwgfHwgY3VycmVudC50YWcgIT09IEZyYWdtZW50KSB7XG4gICAgICAvLyBJbnNlcnRcbiAgICAgIHZhciBjcmVhdGVkID0gY3JlYXRlRmliZXJGcm9tRnJhZ21lbnQoZnJhZ21lbnQsIHJldHVybkZpYmVyLm1vZGUsIGxhbmVzLCBrZXkpO1xuICAgICAgY3JlYXRlZC5yZXR1cm4gPSByZXR1cm5GaWJlcjtcbiAgICAgIHJldHVybiBjcmVhdGVkO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBVcGRhdGVcbiAgICAgIHZhciBleGlzdGluZyA9IHVzZUZpYmVyKGN1cnJlbnQsIGZyYWdtZW50KTtcbiAgICAgIGV4aXN0aW5nLnJldHVybiA9IHJldHVybkZpYmVyO1xuICAgICAgcmV0dXJuIGV4aXN0aW5nO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUNoaWxkKHJldHVybkZpYmVyLCBuZXdDaGlsZCwgbGFuZXMpIHtcbiAgICBpZiAodHlwZW9mIG5ld0NoaWxkID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgbmV3Q2hpbGQgPT09ICdudW1iZXInKSB7XG4gICAgICAvLyBUZXh0IG5vZGVzIGRvbid0IGhhdmUga2V5cy4gSWYgdGhlIHByZXZpb3VzIG5vZGUgaXMgaW1wbGljaXRseSBrZXllZFxuICAgICAgLy8gd2UgY2FuIGNvbnRpbnVlIHRvIHJlcGxhY2UgaXQgd2l0aG91dCBhYm9ydGluZyBldmVuIGlmIGl0IGlzIG5vdCBhIHRleHRcbiAgICAgIC8vIG5vZGUuXG4gICAgICB2YXIgY3JlYXRlZCA9IGNyZWF0ZUZpYmVyRnJvbVRleHQoJycgKyBuZXdDaGlsZCwgcmV0dXJuRmliZXIubW9kZSwgbGFuZXMpO1xuICAgICAgY3JlYXRlZC5yZXR1cm4gPSByZXR1cm5GaWJlcjtcbiAgICAgIHJldHVybiBjcmVhdGVkO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgbmV3Q2hpbGQgPT09ICdvYmplY3QnICYmIG5ld0NoaWxkICE9PSBudWxsKSB7XG4gICAgICBzd2l0Y2ggKG5ld0NoaWxkLiQkdHlwZW9mKSB7XG4gICAgICAgIGNhc2UgUkVBQ1RfRUxFTUVOVF9UWVBFOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHZhciBfY3JlYXRlZCA9IGNyZWF0ZUZpYmVyRnJvbUVsZW1lbnQobmV3Q2hpbGQsIHJldHVybkZpYmVyLm1vZGUsIGxhbmVzKTtcblxuICAgICAgICAgICAgX2NyZWF0ZWQucmVmID0gY29lcmNlUmVmKHJldHVybkZpYmVyLCBudWxsLCBuZXdDaGlsZCk7XG4gICAgICAgICAgICBfY3JlYXRlZC5yZXR1cm4gPSByZXR1cm5GaWJlcjtcbiAgICAgICAgICAgIHJldHVybiBfY3JlYXRlZDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgY2FzZSBSRUFDVF9QT1JUQUxfVFlQRTpcbiAgICAgICAgICB7XG4gICAgICAgICAgICB2YXIgX2NyZWF0ZWQyID0gY3JlYXRlRmliZXJGcm9tUG9ydGFsKG5ld0NoaWxkLCByZXR1cm5GaWJlci5tb2RlLCBsYW5lcyk7XG5cbiAgICAgICAgICAgIF9jcmVhdGVkMi5yZXR1cm4gPSByZXR1cm5GaWJlcjtcbiAgICAgICAgICAgIHJldHVybiBfY3JlYXRlZDI7XG4gICAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoaXNBcnJheSQxKG5ld0NoaWxkKSB8fCBnZXRJdGVyYXRvckZuKG5ld0NoaWxkKSkge1xuICAgICAgICB2YXIgX2NyZWF0ZWQzID0gY3JlYXRlRmliZXJGcm9tRnJhZ21lbnQobmV3Q2hpbGQsIHJldHVybkZpYmVyLm1vZGUsIGxhbmVzLCBudWxsKTtcblxuICAgICAgICBfY3JlYXRlZDMucmV0dXJuID0gcmV0dXJuRmliZXI7XG4gICAgICAgIHJldHVybiBfY3JlYXRlZDM7XG4gICAgICB9XG5cbiAgICAgIHRocm93T25JbnZhbGlkT2JqZWN0VHlwZShyZXR1cm5GaWJlciwgbmV3Q2hpbGQpO1xuICAgIH1cblxuICAgIHtcbiAgICAgIGlmICh0eXBlb2YgbmV3Q2hpbGQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgd2Fybk9uRnVuY3Rpb25UeXBlKHJldHVybkZpYmVyKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZVNsb3QocmV0dXJuRmliZXIsIG9sZEZpYmVyLCBuZXdDaGlsZCwgbGFuZXMpIHtcbiAgICAvLyBVcGRhdGUgdGhlIGZpYmVyIGlmIHRoZSBrZXlzIG1hdGNoLCBvdGhlcndpc2UgcmV0dXJuIG51bGwuXG4gICAgdmFyIGtleSA9IG9sZEZpYmVyICE9PSBudWxsID8gb2xkRmliZXIua2V5IDogbnVsbDtcblxuICAgIGlmICh0eXBlb2YgbmV3Q2hpbGQgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBuZXdDaGlsZCA9PT0gJ251bWJlcicpIHtcbiAgICAgIC8vIFRleHQgbm9kZXMgZG9uJ3QgaGF2ZSBrZXlzLiBJZiB0aGUgcHJldmlvdXMgbm9kZSBpcyBpbXBsaWNpdGx5IGtleWVkXG4gICAgICAvLyB3ZSBjYW4gY29udGludWUgdG8gcmVwbGFjZSBpdCB3aXRob3V0IGFib3J0aW5nIGV2ZW4gaWYgaXQgaXMgbm90IGEgdGV4dFxuICAgICAgLy8gbm9kZS5cbiAgICAgIGlmIChrZXkgIT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB1cGRhdGVUZXh0Tm9kZShyZXR1cm5GaWJlciwgb2xkRmliZXIsICcnICsgbmV3Q2hpbGQsIGxhbmVzKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIG5ld0NoaWxkID09PSAnb2JqZWN0JyAmJiBuZXdDaGlsZCAhPT0gbnVsbCkge1xuICAgICAgc3dpdGNoIChuZXdDaGlsZC4kJHR5cGVvZikge1xuICAgICAgICBjYXNlIFJFQUNUX0VMRU1FTlRfVFlQRTpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBpZiAobmV3Q2hpbGQua2V5ID09PSBrZXkpIHtcbiAgICAgICAgICAgICAgaWYgKG5ld0NoaWxkLnR5cGUgPT09IFJFQUNUX0ZSQUdNRU5UX1RZUEUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdXBkYXRlRnJhZ21lbnQocmV0dXJuRmliZXIsIG9sZEZpYmVyLCBuZXdDaGlsZC5wcm9wcy5jaGlsZHJlbiwgbGFuZXMsIGtleSk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICByZXR1cm4gdXBkYXRlRWxlbWVudChyZXR1cm5GaWJlciwgb2xkRmliZXIsIG5ld0NoaWxkLCBsYW5lcyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgY2FzZSBSRUFDVF9QT1JUQUxfVFlQRTpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBpZiAobmV3Q2hpbGQua2V5ID09PSBrZXkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHVwZGF0ZVBvcnRhbChyZXR1cm5GaWJlciwgb2xkRmliZXIsIG5ld0NoaWxkLCBsYW5lcyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChpc0FycmF5JDEobmV3Q2hpbGQpIHx8IGdldEl0ZXJhdG9yRm4obmV3Q2hpbGQpKSB7XG4gICAgICAgIGlmIChrZXkgIT09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB1cGRhdGVGcmFnbWVudChyZXR1cm5GaWJlciwgb2xkRmliZXIsIG5ld0NoaWxkLCBsYW5lcywgbnVsbCk7XG4gICAgICB9XG5cbiAgICAgIHRocm93T25JbnZhbGlkT2JqZWN0VHlwZShyZXR1cm5GaWJlciwgbmV3Q2hpbGQpO1xuICAgIH1cblxuICAgIHtcbiAgICAgIGlmICh0eXBlb2YgbmV3Q2hpbGQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgd2Fybk9uRnVuY3Rpb25UeXBlKHJldHVybkZpYmVyKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZUZyb21NYXAoZXhpc3RpbmdDaGlsZHJlbiwgcmV0dXJuRmliZXIsIG5ld0lkeCwgbmV3Q2hpbGQsIGxhbmVzKSB7XG4gICAgaWYgKHR5cGVvZiBuZXdDaGlsZCA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIG5ld0NoaWxkID09PSAnbnVtYmVyJykge1xuICAgICAgLy8gVGV4dCBub2RlcyBkb24ndCBoYXZlIGtleXMsIHNvIHdlIG5laXRoZXIgaGF2ZSB0byBjaGVjayB0aGUgb2xkIG5vclxuICAgICAgLy8gbmV3IG5vZGUgZm9yIHRoZSBrZXkuIElmIGJvdGggYXJlIHRleHQgbm9kZXMsIHRoZXkgbWF0Y2guXG4gICAgICB2YXIgbWF0Y2hlZEZpYmVyID0gZXhpc3RpbmdDaGlsZHJlbi5nZXQobmV3SWR4KSB8fCBudWxsO1xuICAgICAgcmV0dXJuIHVwZGF0ZVRleHROb2RlKHJldHVybkZpYmVyLCBtYXRjaGVkRmliZXIsICcnICsgbmV3Q2hpbGQsIGxhbmVzKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIG5ld0NoaWxkID09PSAnb2JqZWN0JyAmJiBuZXdDaGlsZCAhPT0gbnVsbCkge1xuICAgICAgc3dpdGNoIChuZXdDaGlsZC4kJHR5cGVvZikge1xuICAgICAgICBjYXNlIFJFQUNUX0VMRU1FTlRfVFlQRTpcbiAgICAgICAgICB7XG4gICAgICAgICAgICB2YXIgX21hdGNoZWRGaWJlciA9IGV4aXN0aW5nQ2hpbGRyZW4uZ2V0KG5ld0NoaWxkLmtleSA9PT0gbnVsbCA/IG5ld0lkeCA6IG5ld0NoaWxkLmtleSkgfHwgbnVsbDtcblxuICAgICAgICAgICAgaWYgKG5ld0NoaWxkLnR5cGUgPT09IFJFQUNUX0ZSQUdNRU5UX1RZUEUpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHVwZGF0ZUZyYWdtZW50KHJldHVybkZpYmVyLCBfbWF0Y2hlZEZpYmVyLCBuZXdDaGlsZC5wcm9wcy5jaGlsZHJlbiwgbGFuZXMsIG5ld0NoaWxkLmtleSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB1cGRhdGVFbGVtZW50KHJldHVybkZpYmVyLCBfbWF0Y2hlZEZpYmVyLCBuZXdDaGlsZCwgbGFuZXMpO1xuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHZhciBfbWF0Y2hlZEZpYmVyMiA9IGV4aXN0aW5nQ2hpbGRyZW4uZ2V0KG5ld0NoaWxkLmtleSA9PT0gbnVsbCA/IG5ld0lkeCA6IG5ld0NoaWxkLmtleSkgfHwgbnVsbDtcblxuICAgICAgICAgICAgcmV0dXJuIHVwZGF0ZVBvcnRhbChyZXR1cm5GaWJlciwgX21hdGNoZWRGaWJlcjIsIG5ld0NoaWxkLCBsYW5lcyk7XG4gICAgICAgICAgfVxuXG4gICAgICB9XG5cbiAgICAgIGlmIChpc0FycmF5JDEobmV3Q2hpbGQpIHx8IGdldEl0ZXJhdG9yRm4obmV3Q2hpbGQpKSB7XG4gICAgICAgIHZhciBfbWF0Y2hlZEZpYmVyMyA9IGV4aXN0aW5nQ2hpbGRyZW4uZ2V0KG5ld0lkeCkgfHwgbnVsbDtcblxuICAgICAgICByZXR1cm4gdXBkYXRlRnJhZ21lbnQocmV0dXJuRmliZXIsIF9tYXRjaGVkRmliZXIzLCBuZXdDaGlsZCwgbGFuZXMsIG51bGwpO1xuICAgICAgfVxuXG4gICAgICB0aHJvd09uSW52YWxpZE9iamVjdFR5cGUocmV0dXJuRmliZXIsIG5ld0NoaWxkKTtcbiAgICB9XG5cbiAgICB7XG4gICAgICBpZiAodHlwZW9mIG5ld0NoaWxkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHdhcm5PbkZ1bmN0aW9uVHlwZShyZXR1cm5GaWJlcik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgLyoqXG4gICAqIFdhcm5zIGlmIHRoZXJlIGlzIGEgZHVwbGljYXRlIG9yIG1pc3Npbmcga2V5XG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gd2Fybk9uSW52YWxpZEtleShjaGlsZCwga25vd25LZXlzLCByZXR1cm5GaWJlcikge1xuICAgIHtcbiAgICAgIGlmICh0eXBlb2YgY2hpbGQgIT09ICdvYmplY3QnIHx8IGNoaWxkID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBrbm93bktleXM7XG4gICAgICB9XG5cbiAgICAgIHN3aXRjaCAoY2hpbGQuJCR0eXBlb2YpIHtcbiAgICAgICAgY2FzZSBSRUFDVF9FTEVNRU5UX1RZUEU6XG4gICAgICAgIGNhc2UgUkVBQ1RfUE9SVEFMX1RZUEU6XG4gICAgICAgICAgd2FybkZvck1pc3NpbmdLZXkoY2hpbGQsIHJldHVybkZpYmVyKTtcbiAgICAgICAgICB2YXIga2V5ID0gY2hpbGQua2V5O1xuXG4gICAgICAgICAgaWYgKHR5cGVvZiBrZXkgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoa25vd25LZXlzID09PSBudWxsKSB7XG4gICAgICAgICAgICBrbm93bktleXMgPSBuZXcgU2V0KCk7XG4gICAgICAgICAgICBrbm93bktleXMuYWRkKGtleSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoIWtub3duS2V5cy5oYXMoa2V5KSkge1xuICAgICAgICAgICAga25vd25LZXlzLmFkZChrZXkpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZXJyb3IoJ0VuY291bnRlcmVkIHR3byBjaGlsZHJlbiB3aXRoIHRoZSBzYW1lIGtleSwgYCVzYC4gJyArICdLZXlzIHNob3VsZCBiZSB1bmlxdWUgc28gdGhhdCBjb21wb25lbnRzIG1haW50YWluIHRoZWlyIGlkZW50aXR5ICcgKyAnYWNyb3NzIHVwZGF0ZXMuIE5vbi11bmlxdWUga2V5cyBtYXkgY2F1c2UgY2hpbGRyZW4gdG8gYmUgJyArICdkdXBsaWNhdGVkIGFuZC9vciBvbWl0dGVkIOKAlCB0aGUgYmVoYXZpb3IgaXMgdW5zdXBwb3J0ZWQgYW5kICcgKyAnY291bGQgY2hhbmdlIGluIGEgZnV0dXJlIHZlcnNpb24uJywga2V5KTtcblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBrbm93bktleXM7XG4gIH1cblxuICBmdW5jdGlvbiByZWNvbmNpbGVDaGlsZHJlbkFycmF5KHJldHVybkZpYmVyLCBjdXJyZW50Rmlyc3RDaGlsZCwgbmV3Q2hpbGRyZW4sIGxhbmVzKSB7XG4gICAgLy8gVGhpcyBhbGdvcml0aG0gY2FuJ3Qgb3B0aW1pemUgYnkgc2VhcmNoaW5nIGZyb20gYm90aCBlbmRzIHNpbmNlIHdlXG4gICAgLy8gZG9uJ3QgaGF2ZSBiYWNrcG9pbnRlcnMgb24gZmliZXJzLiBJJ20gdHJ5aW5nIHRvIHNlZSBob3cgZmFyIHdlIGNhbiBnZXRcbiAgICAvLyB3aXRoIHRoYXQgbW9kZWwuIElmIGl0IGVuZHMgdXAgbm90IGJlaW5nIHdvcnRoIHRoZSB0cmFkZW9mZnMsIHdlIGNhblxuICAgIC8vIGFkZCBpdCBsYXRlci5cbiAgICAvLyBFdmVuIHdpdGggYSB0d28gZW5kZWQgb3B0aW1pemF0aW9uLCB3ZSdkIHdhbnQgdG8gb3B0aW1pemUgZm9yIHRoZSBjYXNlXG4gICAgLy8gd2hlcmUgdGhlcmUgYXJlIGZldyBjaGFuZ2VzIGFuZCBicnV0ZSBmb3JjZSB0aGUgY29tcGFyaXNvbiBpbnN0ZWFkIG9mXG4gICAgLy8gZ29pbmcgZm9yIHRoZSBNYXAuIEl0J2QgbGlrZSB0byBleHBsb3JlIGhpdHRpbmcgdGhhdCBwYXRoIGZpcnN0IGluXG4gICAgLy8gZm9yd2FyZC1vbmx5IG1vZGUgYW5kIG9ubHkgZ28gZm9yIHRoZSBNYXAgb25jZSB3ZSBub3RpY2UgdGhhdCB3ZSBuZWVkXG4gICAgLy8gbG90cyBvZiBsb29rIGFoZWFkLiBUaGlzIGRvZXNuJ3QgaGFuZGxlIHJldmVyc2FsIGFzIHdlbGwgYXMgdHdvIGVuZGVkXG4gICAgLy8gc2VhcmNoIGJ1dCB0aGF0J3MgdW51c3VhbC4gQmVzaWRlcywgZm9yIHRoZSB0d28gZW5kZWQgb3B0aW1pemF0aW9uIHRvXG4gICAgLy8gd29yayBvbiBJdGVyYWJsZXMsIHdlJ2QgbmVlZCB0byBjb3B5IHRoZSB3aG9sZSBzZXQuXG4gICAgLy8gSW4gdGhpcyBmaXJzdCBpdGVyYXRpb24sIHdlJ2xsIGp1c3QgbGl2ZSB3aXRoIGhpdHRpbmcgdGhlIGJhZCBjYXNlXG4gICAgLy8gKGFkZGluZyBldmVyeXRoaW5nIHRvIGEgTWFwKSBpbiBmb3IgZXZlcnkgaW5zZXJ0L21vdmUuXG4gICAgLy8gSWYgeW91IGNoYW5nZSB0aGlzIGNvZGUsIGFsc28gdXBkYXRlIHJlY29uY2lsZUNoaWxkcmVuSXRlcmF0b3IoKSB3aGljaFxuICAgIC8vIHVzZXMgdGhlIHNhbWUgYWxnb3JpdGhtLlxuICAgIHtcbiAgICAgIC8vIEZpcnN0LCB2YWxpZGF0ZSBrZXlzLlxuICAgICAgdmFyIGtub3duS2V5cyA9IG51bGw7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbmV3Q2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGNoaWxkID0gbmV3Q2hpbGRyZW5baV07XG4gICAgICAgIGtub3duS2V5cyA9IHdhcm5PbkludmFsaWRLZXkoY2hpbGQsIGtub3duS2V5cywgcmV0dXJuRmliZXIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciByZXN1bHRpbmdGaXJzdENoaWxkID0gbnVsbDtcbiAgICB2YXIgcHJldmlvdXNOZXdGaWJlciA9IG51bGw7XG4gICAgdmFyIG9sZEZpYmVyID0gY3VycmVudEZpcnN0Q2hpbGQ7XG4gICAgdmFyIGxhc3RQbGFjZWRJbmRleCA9IDA7XG4gICAgdmFyIG5ld0lkeCA9IDA7XG4gICAgdmFyIG5leHRPbGRGaWJlciA9IG51bGw7XG5cbiAgICBmb3IgKDsgb2xkRmliZXIgIT09IG51bGwgJiYgbmV3SWR4IDwgbmV3Q2hpbGRyZW4ubGVuZ3RoOyBuZXdJZHgrKykge1xuICAgICAgaWYgKG9sZEZpYmVyLmluZGV4ID4gbmV3SWR4KSB7XG4gICAgICAgIG5leHRPbGRGaWJlciA9IG9sZEZpYmVyO1xuICAgICAgICBvbGRGaWJlciA9IG51bGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuZXh0T2xkRmliZXIgPSBvbGRGaWJlci5zaWJsaW5nO1xuICAgICAgfVxuXG4gICAgICB2YXIgbmV3RmliZXIgPSB1cGRhdGVTbG90KHJldHVybkZpYmVyLCBvbGRGaWJlciwgbmV3Q2hpbGRyZW5bbmV3SWR4XSwgbGFuZXMpO1xuXG4gICAgICBpZiAobmV3RmliZXIgPT09IG51bGwpIHtcbiAgICAgICAgLy8gVE9ETzogVGhpcyBicmVha3Mgb24gZW1wdHkgc2xvdHMgbGlrZSBudWxsIGNoaWxkcmVuLiBUaGF0J3NcbiAgICAgICAgLy8gdW5mb3J0dW5hdGUgYmVjYXVzZSBpdCB0cmlnZ2VycyB0aGUgc2xvdyBwYXRoIGFsbCB0aGUgdGltZS4gV2UgbmVlZFxuICAgICAgICAvLyBhIGJldHRlciB3YXkgdG8gY29tbXVuaWNhdGUgd2hldGhlciB0aGlzIHdhcyBhIG1pc3Mgb3IgbnVsbCxcbiAgICAgICAgLy8gYm9vbGVhbiwgdW5kZWZpbmVkLCBldGMuXG4gICAgICAgIGlmIChvbGRGaWJlciA9PT0gbnVsbCkge1xuICAgICAgICAgIG9sZEZpYmVyID0gbmV4dE9sZEZpYmVyO1xuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGlmIChzaG91bGRUcmFja1NpZGVFZmZlY3RzKSB7XG4gICAgICAgIGlmIChvbGRGaWJlciAmJiBuZXdGaWJlci5hbHRlcm5hdGUgPT09IG51bGwpIHtcbiAgICAgICAgICAvLyBXZSBtYXRjaGVkIHRoZSBzbG90LCBidXQgd2UgZGlkbid0IHJldXNlIHRoZSBleGlzdGluZyBmaWJlciwgc28gd2VcbiAgICAgICAgICAvLyBuZWVkIHRvIGRlbGV0ZSB0aGUgZXhpc3RpbmcgY2hpbGQuXG4gICAgICAgICAgZGVsZXRlQ2hpbGQocmV0dXJuRmliZXIsIG9sZEZpYmVyKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBsYXN0UGxhY2VkSW5kZXggPSBwbGFjZUNoaWxkKG5ld0ZpYmVyLCBsYXN0UGxhY2VkSW5kZXgsIG5ld0lkeCk7XG5cbiAgICAgIGlmIChwcmV2aW91c05ld0ZpYmVyID09PSBudWxsKSB7XG4gICAgICAgIC8vIFRPRE86IE1vdmUgb3V0IG9mIHRoZSBsb29wLiBUaGlzIG9ubHkgaGFwcGVucyBmb3IgdGhlIGZpcnN0IHJ1bi5cbiAgICAgICAgcmVzdWx0aW5nRmlyc3RDaGlsZCA9IG5ld0ZpYmVyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gVE9ETzogRGVmZXIgc2libGluZ3MgaWYgd2UncmUgbm90IGF0IHRoZSByaWdodCBpbmRleCBmb3IgdGhpcyBzbG90LlxuICAgICAgICAvLyBJLmUuIGlmIHdlIGhhZCBudWxsIHZhbHVlcyBiZWZvcmUsIHRoZW4gd2Ugd2FudCB0byBkZWZlciB0aGlzXG4gICAgICAgIC8vIGZvciBlYWNoIG51bGwgdmFsdWUuIEhvd2V2ZXIsIHdlIGFsc28gZG9uJ3Qgd2FudCB0byBjYWxsIHVwZGF0ZVNsb3RcbiAgICAgICAgLy8gd2l0aCB0aGUgcHJldmlvdXMgb25lLlxuICAgICAgICBwcmV2aW91c05ld0ZpYmVyLnNpYmxpbmcgPSBuZXdGaWJlcjtcbiAgICAgIH1cblxuICAgICAgcHJldmlvdXNOZXdGaWJlciA9IG5ld0ZpYmVyO1xuICAgICAgb2xkRmliZXIgPSBuZXh0T2xkRmliZXI7XG4gICAgfVxuXG4gICAgaWYgKG5ld0lkeCA9PT0gbmV3Q2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICAvLyBXZSd2ZSByZWFjaGVkIHRoZSBlbmQgb2YgdGhlIG5ldyBjaGlsZHJlbi4gV2UgY2FuIGRlbGV0ZSB0aGUgcmVzdC5cbiAgICAgIGRlbGV0ZVJlbWFpbmluZ0NoaWxkcmVuKHJldHVybkZpYmVyLCBvbGRGaWJlcik7XG4gICAgICByZXR1cm4gcmVzdWx0aW5nRmlyc3RDaGlsZDtcbiAgICB9XG5cbiAgICBpZiAob2xkRmliZXIgPT09IG51bGwpIHtcbiAgICAgIC8vIElmIHdlIGRvbid0IGhhdmUgYW55IG1vcmUgZXhpc3RpbmcgY2hpbGRyZW4gd2UgY2FuIGNob29zZSBhIGZhc3QgcGF0aFxuICAgICAgLy8gc2luY2UgdGhlIHJlc3Qgd2lsbCBhbGwgYmUgaW5zZXJ0aW9ucy5cbiAgICAgIGZvciAoOyBuZXdJZHggPCBuZXdDaGlsZHJlbi5sZW5ndGg7IG5ld0lkeCsrKSB7XG4gICAgICAgIHZhciBfbmV3RmliZXIgPSBjcmVhdGVDaGlsZChyZXR1cm5GaWJlciwgbmV3Q2hpbGRyZW5bbmV3SWR4XSwgbGFuZXMpO1xuXG4gICAgICAgIGlmIChfbmV3RmliZXIgPT09IG51bGwpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxhc3RQbGFjZWRJbmRleCA9IHBsYWNlQ2hpbGQoX25ld0ZpYmVyLCBsYXN0UGxhY2VkSW5kZXgsIG5ld0lkeCk7XG5cbiAgICAgICAgaWYgKHByZXZpb3VzTmV3RmliZXIgPT09IG51bGwpIHtcbiAgICAgICAgICAvLyBUT0RPOiBNb3ZlIG91dCBvZiB0aGUgbG9vcC4gVGhpcyBvbmx5IGhhcHBlbnMgZm9yIHRoZSBmaXJzdCBydW4uXG4gICAgICAgICAgcmVzdWx0aW5nRmlyc3RDaGlsZCA9IF9uZXdGaWJlcjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwcmV2aW91c05ld0ZpYmVyLnNpYmxpbmcgPSBfbmV3RmliZXI7XG4gICAgICAgIH1cblxuICAgICAgICBwcmV2aW91c05ld0ZpYmVyID0gX25ld0ZpYmVyO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0aW5nRmlyc3RDaGlsZDtcbiAgICB9IC8vIEFkZCBhbGwgY2hpbGRyZW4gdG8gYSBrZXkgbWFwIGZvciBxdWljayBsb29rdXBzLlxuXG5cbiAgICB2YXIgZXhpc3RpbmdDaGlsZHJlbiA9IG1hcFJlbWFpbmluZ0NoaWxkcmVuKHJldHVybkZpYmVyLCBvbGRGaWJlcik7IC8vIEtlZXAgc2Nhbm5pbmcgYW5kIHVzZSB0aGUgbWFwIHRvIHJlc3RvcmUgZGVsZXRlZCBpdGVtcyBhcyBtb3Zlcy5cblxuICAgIGZvciAoOyBuZXdJZHggPCBuZXdDaGlsZHJlbi5sZW5ndGg7IG5ld0lkeCsrKSB7XG4gICAgICB2YXIgX25ld0ZpYmVyMiA9IHVwZGF0ZUZyb21NYXAoZXhpc3RpbmdDaGlsZHJlbiwgcmV0dXJuRmliZXIsIG5ld0lkeCwgbmV3Q2hpbGRyZW5bbmV3SWR4XSwgbGFuZXMpO1xuXG4gICAgICBpZiAoX25ld0ZpYmVyMiAhPT0gbnVsbCkge1xuICAgICAgICBpZiAoc2hvdWxkVHJhY2tTaWRlRWZmZWN0cykge1xuICAgICAgICAgIGlmIChfbmV3RmliZXIyLmFsdGVybmF0ZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gVGhlIG5ldyBmaWJlciBpcyBhIHdvcmsgaW4gcHJvZ3Jlc3MsIGJ1dCBpZiB0aGVyZSBleGlzdHMgYVxuICAgICAgICAgICAgLy8gY3VycmVudCwgdGhhdCBtZWFucyB0aGF0IHdlIHJldXNlZCB0aGUgZmliZXIuIFdlIG5lZWQgdG8gZGVsZXRlXG4gICAgICAgICAgICAvLyBpdCBmcm9tIHRoZSBjaGlsZCBsaXN0IHNvIHRoYXQgd2UgZG9uJ3QgYWRkIGl0IHRvIHRoZSBkZWxldGlvblxuICAgICAgICAgICAgLy8gbGlzdC5cbiAgICAgICAgICAgIGV4aXN0aW5nQ2hpbGRyZW4uZGVsZXRlKF9uZXdGaWJlcjIua2V5ID09PSBudWxsID8gbmV3SWR4IDogX25ld0ZpYmVyMi5rZXkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGxhc3RQbGFjZWRJbmRleCA9IHBsYWNlQ2hpbGQoX25ld0ZpYmVyMiwgbGFzdFBsYWNlZEluZGV4LCBuZXdJZHgpO1xuXG4gICAgICAgIGlmIChwcmV2aW91c05ld0ZpYmVyID09PSBudWxsKSB7XG4gICAgICAgICAgcmVzdWx0aW5nRmlyc3RDaGlsZCA9IF9uZXdGaWJlcjI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcHJldmlvdXNOZXdGaWJlci5zaWJsaW5nID0gX25ld0ZpYmVyMjtcbiAgICAgICAgfVxuXG4gICAgICAgIHByZXZpb3VzTmV3RmliZXIgPSBfbmV3RmliZXIyO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChzaG91bGRUcmFja1NpZGVFZmZlY3RzKSB7XG4gICAgICAvLyBBbnkgZXhpc3RpbmcgY2hpbGRyZW4gdGhhdCB3ZXJlbid0IGNvbnN1bWVkIGFib3ZlIHdlcmUgZGVsZXRlZC4gV2UgbmVlZFxuICAgICAgLy8gdG8gYWRkIHRoZW0gdG8gdGhlIGRlbGV0aW9uIGxpc3QuXG4gICAgICBleGlzdGluZ0NoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgIHJldHVybiBkZWxldGVDaGlsZChyZXR1cm5GaWJlciwgY2hpbGQpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdGluZ0ZpcnN0Q2hpbGQ7XG4gIH1cblxuICBmdW5jdGlvbiByZWNvbmNpbGVDaGlsZHJlbkl0ZXJhdG9yKHJldHVybkZpYmVyLCBjdXJyZW50Rmlyc3RDaGlsZCwgbmV3Q2hpbGRyZW5JdGVyYWJsZSwgbGFuZXMpIHtcbiAgICAvLyBUaGlzIGlzIHRoZSBzYW1lIGltcGxlbWVudGF0aW9uIGFzIHJlY29uY2lsZUNoaWxkcmVuQXJyYXkoKSxcbiAgICAvLyBidXQgdXNpbmcgdGhlIGl0ZXJhdG9yIGluc3RlYWQuXG4gICAgdmFyIGl0ZXJhdG9yRm4gPSBnZXRJdGVyYXRvckZuKG5ld0NoaWxkcmVuSXRlcmFibGUpO1xuXG4gICAgaWYgKCEodHlwZW9mIGl0ZXJhdG9yRm4gPT09ICdmdW5jdGlvbicpKSB7XG4gICAgICB7XG4gICAgICAgIHRocm93IEVycm9yKCBcIkFuIG9iamVjdCBpcyBub3QgYW4gaXRlcmFibGUuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCIgKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB7XG4gICAgICAvLyBXZSBkb24ndCBzdXBwb3J0IHJlbmRlcmluZyBHZW5lcmF0b3JzIGJlY2F1c2UgaXQncyBhIG11dGF0aW9uLlxuICAgICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTI5OTVcbiAgICAgIGlmICh0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIC8vICRGbG93Rml4TWUgRmxvdyBkb2Vzbid0IGtub3cgYWJvdXQgdG9TdHJpbmdUYWdcbiAgICAgIG5ld0NoaWxkcmVuSXRlcmFibGVbU3ltYm9sLnRvU3RyaW5nVGFnXSA9PT0gJ0dlbmVyYXRvcicpIHtcbiAgICAgICAgaWYgKCFkaWRXYXJuQWJvdXRHZW5lcmF0b3JzKSB7XG4gICAgICAgICAgZXJyb3IoJ1VzaW5nIEdlbmVyYXRvcnMgYXMgY2hpbGRyZW4gaXMgdW5zdXBwb3J0ZWQgYW5kIHdpbGwgbGlrZWx5IHlpZWxkICcgKyAndW5leHBlY3RlZCByZXN1bHRzIGJlY2F1c2UgZW51bWVyYXRpbmcgYSBnZW5lcmF0b3IgbXV0YXRlcyBpdC4gJyArICdZb3UgbWF5IGNvbnZlcnQgaXQgdG8gYW4gYXJyYXkgd2l0aCBgQXJyYXkuZnJvbSgpYCBvciB0aGUgJyArICdgWy4uLnNwcmVhZF1gIG9wZXJhdG9yIGJlZm9yZSByZW5kZXJpbmcuIEtlZXAgaW4gbWluZCAnICsgJ3lvdSBtaWdodCBuZWVkIHRvIHBvbHlmaWxsIHRoZXNlIGZlYXR1cmVzIGZvciBvbGRlciBicm93c2Vycy4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGRpZFdhcm5BYm91dEdlbmVyYXRvcnMgPSB0cnVlO1xuICAgICAgfSAvLyBXYXJuIGFib3V0IHVzaW5nIE1hcHMgYXMgY2hpbGRyZW5cblxuXG4gICAgICBpZiAobmV3Q2hpbGRyZW5JdGVyYWJsZS5lbnRyaWVzID09PSBpdGVyYXRvckZuKSB7XG4gICAgICAgIGlmICghZGlkV2FybkFib3V0TWFwcykge1xuICAgICAgICAgIGVycm9yKCdVc2luZyBNYXBzIGFzIGNoaWxkcmVuIGlzIG5vdCBzdXBwb3J0ZWQuICcgKyAnVXNlIGFuIGFycmF5IG9mIGtleWVkIFJlYWN0RWxlbWVudHMgaW5zdGVhZC4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGRpZFdhcm5BYm91dE1hcHMgPSB0cnVlO1xuICAgICAgfSAvLyBGaXJzdCwgdmFsaWRhdGUga2V5cy5cbiAgICAgIC8vIFdlJ2xsIGdldCBhIGRpZmZlcmVudCBpdGVyYXRvciBsYXRlciBmb3IgdGhlIG1haW4gcGFzcy5cblxuXG4gICAgICB2YXIgX25ld0NoaWxkcmVuID0gaXRlcmF0b3JGbi5jYWxsKG5ld0NoaWxkcmVuSXRlcmFibGUpO1xuXG4gICAgICBpZiAoX25ld0NoaWxkcmVuKSB7XG4gICAgICAgIHZhciBrbm93bktleXMgPSBudWxsO1xuXG4gICAgICAgIHZhciBfc3RlcCA9IF9uZXdDaGlsZHJlbi5uZXh0KCk7XG5cbiAgICAgICAgZm9yICg7ICFfc3RlcC5kb25lOyBfc3RlcCA9IF9uZXdDaGlsZHJlbi5uZXh0KCkpIHtcbiAgICAgICAgICB2YXIgY2hpbGQgPSBfc3RlcC52YWx1ZTtcbiAgICAgICAgICBrbm93bktleXMgPSB3YXJuT25JbnZhbGlkS2V5KGNoaWxkLCBrbm93bktleXMsIHJldHVybkZpYmVyKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBuZXdDaGlsZHJlbiA9IGl0ZXJhdG9yRm4uY2FsbChuZXdDaGlsZHJlbkl0ZXJhYmxlKTtcblxuICAgIGlmICghKG5ld0NoaWxkcmVuICE9IG51bGwpKSB7XG4gICAgICB7XG4gICAgICAgIHRocm93IEVycm9yKCBcIkFuIGl0ZXJhYmxlIG9iamVjdCBwcm92aWRlZCBubyBpdGVyYXRvci5cIiApO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciByZXN1bHRpbmdGaXJzdENoaWxkID0gbnVsbDtcbiAgICB2YXIgcHJldmlvdXNOZXdGaWJlciA9IG51bGw7XG4gICAgdmFyIG9sZEZpYmVyID0gY3VycmVudEZpcnN0Q2hpbGQ7XG4gICAgdmFyIGxhc3RQbGFjZWRJbmRleCA9IDA7XG4gICAgdmFyIG5ld0lkeCA9IDA7XG4gICAgdmFyIG5leHRPbGRGaWJlciA9IG51bGw7XG4gICAgdmFyIHN0ZXAgPSBuZXdDaGlsZHJlbi5uZXh0KCk7XG5cbiAgICBmb3IgKDsgb2xkRmliZXIgIT09IG51bGwgJiYgIXN0ZXAuZG9uZTsgbmV3SWR4KyssIHN0ZXAgPSBuZXdDaGlsZHJlbi5uZXh0KCkpIHtcbiAgICAgIGlmIChvbGRGaWJlci5pbmRleCA+IG5ld0lkeCkge1xuICAgICAgICBuZXh0T2xkRmliZXIgPSBvbGRGaWJlcjtcbiAgICAgICAgb2xkRmliZXIgPSBudWxsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbmV4dE9sZEZpYmVyID0gb2xkRmliZXIuc2libGluZztcbiAgICAgIH1cblxuICAgICAgdmFyIG5ld0ZpYmVyID0gdXBkYXRlU2xvdChyZXR1cm5GaWJlciwgb2xkRmliZXIsIHN0ZXAudmFsdWUsIGxhbmVzKTtcblxuICAgICAgaWYgKG5ld0ZpYmVyID09PSBudWxsKSB7XG4gICAgICAgIC8vIFRPRE86IFRoaXMgYnJlYWtzIG9uIGVtcHR5IHNsb3RzIGxpa2UgbnVsbCBjaGlsZHJlbi4gVGhhdCdzXG4gICAgICAgIC8vIHVuZm9ydHVuYXRlIGJlY2F1c2UgaXQgdHJpZ2dlcnMgdGhlIHNsb3cgcGF0aCBhbGwgdGhlIHRpbWUuIFdlIG5lZWRcbiAgICAgICAgLy8gYSBiZXR0ZXIgd2F5IHRvIGNvbW11bmljYXRlIHdoZXRoZXIgdGhpcyB3YXMgYSBtaXNzIG9yIG51bGwsXG4gICAgICAgIC8vIGJvb2xlYW4sIHVuZGVmaW5lZCwgZXRjLlxuICAgICAgICBpZiAob2xkRmliZXIgPT09IG51bGwpIHtcbiAgICAgICAgICBvbGRGaWJlciA9IG5leHRPbGRGaWJlcjtcbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBpZiAoc2hvdWxkVHJhY2tTaWRlRWZmZWN0cykge1xuICAgICAgICBpZiAob2xkRmliZXIgJiYgbmV3RmliZXIuYWx0ZXJuYXRlID09PSBudWxsKSB7XG4gICAgICAgICAgLy8gV2UgbWF0Y2hlZCB0aGUgc2xvdCwgYnV0IHdlIGRpZG4ndCByZXVzZSB0aGUgZXhpc3RpbmcgZmliZXIsIHNvIHdlXG4gICAgICAgICAgLy8gbmVlZCB0byBkZWxldGUgdGhlIGV4aXN0aW5nIGNoaWxkLlxuICAgICAgICAgIGRlbGV0ZUNoaWxkKHJldHVybkZpYmVyLCBvbGRGaWJlcik7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgbGFzdFBsYWNlZEluZGV4ID0gcGxhY2VDaGlsZChuZXdGaWJlciwgbGFzdFBsYWNlZEluZGV4LCBuZXdJZHgpO1xuXG4gICAgICBpZiAocHJldmlvdXNOZXdGaWJlciA9PT0gbnVsbCkge1xuICAgICAgICAvLyBUT0RPOiBNb3ZlIG91dCBvZiB0aGUgbG9vcC4gVGhpcyBvbmx5IGhhcHBlbnMgZm9yIHRoZSBmaXJzdCBydW4uXG4gICAgICAgIHJlc3VsdGluZ0ZpcnN0Q2hpbGQgPSBuZXdGaWJlcjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFRPRE86IERlZmVyIHNpYmxpbmdzIGlmIHdlJ3JlIG5vdCBhdCB0aGUgcmlnaHQgaW5kZXggZm9yIHRoaXMgc2xvdC5cbiAgICAgICAgLy8gSS5lLiBpZiB3ZSBoYWQgbnVsbCB2YWx1ZXMgYmVmb3JlLCB0aGVuIHdlIHdhbnQgdG8gZGVmZXIgdGhpc1xuICAgICAgICAvLyBmb3IgZWFjaCBudWxsIHZhbHVlLiBIb3dldmVyLCB3ZSBhbHNvIGRvbid0IHdhbnQgdG8gY2FsbCB1cGRhdGVTbG90XG4gICAgICAgIC8vIHdpdGggdGhlIHByZXZpb3VzIG9uZS5cbiAgICAgICAgcHJldmlvdXNOZXdGaWJlci5zaWJsaW5nID0gbmV3RmliZXI7XG4gICAgICB9XG5cbiAgICAgIHByZXZpb3VzTmV3RmliZXIgPSBuZXdGaWJlcjtcbiAgICAgIG9sZEZpYmVyID0gbmV4dE9sZEZpYmVyO1xuICAgIH1cblxuICAgIGlmIChzdGVwLmRvbmUpIHtcbiAgICAgIC8vIFdlJ3ZlIHJlYWNoZWQgdGhlIGVuZCBvZiB0aGUgbmV3IGNoaWxkcmVuLiBXZSBjYW4gZGVsZXRlIHRoZSByZXN0LlxuICAgICAgZGVsZXRlUmVtYWluaW5nQ2hpbGRyZW4ocmV0dXJuRmliZXIsIG9sZEZpYmVyKTtcbiAgICAgIHJldHVybiByZXN1bHRpbmdGaXJzdENoaWxkO1xuICAgIH1cblxuICAgIGlmIChvbGRGaWJlciA9PT0gbnVsbCkge1xuICAgICAgLy8gSWYgd2UgZG9uJ3QgaGF2ZSBhbnkgbW9yZSBleGlzdGluZyBjaGlsZHJlbiB3ZSBjYW4gY2hvb3NlIGEgZmFzdCBwYXRoXG4gICAgICAvLyBzaW5jZSB0aGUgcmVzdCB3aWxsIGFsbCBiZSBpbnNlcnRpb25zLlxuICAgICAgZm9yICg7ICFzdGVwLmRvbmU7IG5ld0lkeCsrLCBzdGVwID0gbmV3Q2hpbGRyZW4ubmV4dCgpKSB7XG4gICAgICAgIHZhciBfbmV3RmliZXIzID0gY3JlYXRlQ2hpbGQocmV0dXJuRmliZXIsIHN0ZXAudmFsdWUsIGxhbmVzKTtcblxuICAgICAgICBpZiAoX25ld0ZpYmVyMyA9PT0gbnVsbCkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgbGFzdFBsYWNlZEluZGV4ID0gcGxhY2VDaGlsZChfbmV3RmliZXIzLCBsYXN0UGxhY2VkSW5kZXgsIG5ld0lkeCk7XG5cbiAgICAgICAgaWYgKHByZXZpb3VzTmV3RmliZXIgPT09IG51bGwpIHtcbiAgICAgICAgICAvLyBUT0RPOiBNb3ZlIG91dCBvZiB0aGUgbG9vcC4gVGhpcyBvbmx5IGhhcHBlbnMgZm9yIHRoZSBmaXJzdCBydW4uXG4gICAgICAgICAgcmVzdWx0aW5nRmlyc3RDaGlsZCA9IF9uZXdGaWJlcjM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcHJldmlvdXNOZXdGaWJlci5zaWJsaW5nID0gX25ld0ZpYmVyMztcbiAgICAgICAgfVxuXG4gICAgICAgIHByZXZpb3VzTmV3RmliZXIgPSBfbmV3RmliZXIzO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0aW5nRmlyc3RDaGlsZDtcbiAgICB9IC8vIEFkZCBhbGwgY2hpbGRyZW4gdG8gYSBrZXkgbWFwIGZvciBxdWljayBsb29rdXBzLlxuXG5cbiAgICB2YXIgZXhpc3RpbmdDaGlsZHJlbiA9IG1hcFJlbWFpbmluZ0NoaWxkcmVuKHJldHVybkZpYmVyLCBvbGRGaWJlcik7IC8vIEtlZXAgc2Nhbm5pbmcgYW5kIHVzZSB0aGUgbWFwIHRvIHJlc3RvcmUgZGVsZXRlZCBpdGVtcyBhcyBtb3Zlcy5cblxuICAgIGZvciAoOyAhc3RlcC5kb25lOyBuZXdJZHgrKywgc3RlcCA9IG5ld0NoaWxkcmVuLm5leHQoKSkge1xuICAgICAgdmFyIF9uZXdGaWJlcjQgPSB1cGRhdGVGcm9tTWFwKGV4aXN0aW5nQ2hpbGRyZW4sIHJldHVybkZpYmVyLCBuZXdJZHgsIHN0ZXAudmFsdWUsIGxhbmVzKTtcblxuICAgICAgaWYgKF9uZXdGaWJlcjQgIT09IG51bGwpIHtcbiAgICAgICAgaWYgKHNob3VsZFRyYWNrU2lkZUVmZmVjdHMpIHtcbiAgICAgICAgICBpZiAoX25ld0ZpYmVyNC5hbHRlcm5hdGUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIFRoZSBuZXcgZmliZXIgaXMgYSB3b3JrIGluIHByb2dyZXNzLCBidXQgaWYgdGhlcmUgZXhpc3RzIGFcbiAgICAgICAgICAgIC8vIGN1cnJlbnQsIHRoYXQgbWVhbnMgdGhhdCB3ZSByZXVzZWQgdGhlIGZpYmVyLiBXZSBuZWVkIHRvIGRlbGV0ZVxuICAgICAgICAgICAgLy8gaXQgZnJvbSB0aGUgY2hpbGQgbGlzdCBzbyB0aGF0IHdlIGRvbid0IGFkZCBpdCB0byB0aGUgZGVsZXRpb25cbiAgICAgICAgICAgIC8vIGxpc3QuXG4gICAgICAgICAgICBleGlzdGluZ0NoaWxkcmVuLmRlbGV0ZShfbmV3RmliZXI0LmtleSA9PT0gbnVsbCA/IG5ld0lkeCA6IF9uZXdGaWJlcjQua2V5KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBsYXN0UGxhY2VkSW5kZXggPSBwbGFjZUNoaWxkKF9uZXdGaWJlcjQsIGxhc3RQbGFjZWRJbmRleCwgbmV3SWR4KTtcblxuICAgICAgICBpZiAocHJldmlvdXNOZXdGaWJlciA9PT0gbnVsbCkge1xuICAgICAgICAgIHJlc3VsdGluZ0ZpcnN0Q2hpbGQgPSBfbmV3RmliZXI0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHByZXZpb3VzTmV3RmliZXIuc2libGluZyA9IF9uZXdGaWJlcjQ7XG4gICAgICAgIH1cblxuICAgICAgICBwcmV2aW91c05ld0ZpYmVyID0gX25ld0ZpYmVyNDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoc2hvdWxkVHJhY2tTaWRlRWZmZWN0cykge1xuICAgICAgLy8gQW55IGV4aXN0aW5nIGNoaWxkcmVuIHRoYXQgd2VyZW4ndCBjb25zdW1lZCBhYm92ZSB3ZXJlIGRlbGV0ZWQuIFdlIG5lZWRcbiAgICAgIC8vIHRvIGFkZCB0aGVtIHRvIHRoZSBkZWxldGlvbiBsaXN0LlxuICAgICAgZXhpc3RpbmdDaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICByZXR1cm4gZGVsZXRlQ2hpbGQocmV0dXJuRmliZXIsIGNoaWxkKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHRpbmdGaXJzdENoaWxkO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVjb25jaWxlU2luZ2xlVGV4dE5vZGUocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkLCB0ZXh0Q29udGVudCwgbGFuZXMpIHtcbiAgICAvLyBUaGVyZSdzIG5vIG5lZWQgdG8gY2hlY2sgZm9yIGtleXMgb24gdGV4dCBub2RlcyBzaW5jZSB3ZSBkb24ndCBoYXZlIGFcbiAgICAvLyB3YXkgdG8gZGVmaW5lIHRoZW0uXG4gICAgaWYgKGN1cnJlbnRGaXJzdENoaWxkICE9PSBudWxsICYmIGN1cnJlbnRGaXJzdENoaWxkLnRhZyA9PT0gSG9zdFRleHQpIHtcbiAgICAgIC8vIFdlIGFscmVhZHkgaGF2ZSBhbiBleGlzdGluZyBub2RlIHNvIGxldCdzIGp1c3QgdXBkYXRlIGl0IGFuZCBkZWxldGVcbiAgICAgIC8vIHRoZSByZXN0LlxuICAgICAgZGVsZXRlUmVtYWluaW5nQ2hpbGRyZW4ocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkLnNpYmxpbmcpO1xuICAgICAgdmFyIGV4aXN0aW5nID0gdXNlRmliZXIoY3VycmVudEZpcnN0Q2hpbGQsIHRleHRDb250ZW50KTtcbiAgICAgIGV4aXN0aW5nLnJldHVybiA9IHJldHVybkZpYmVyO1xuICAgICAgcmV0dXJuIGV4aXN0aW5nO1xuICAgIH0gLy8gVGhlIGV4aXN0aW5nIGZpcnN0IGNoaWxkIGlzIG5vdCBhIHRleHQgbm9kZSBzbyB3ZSBuZWVkIHRvIGNyZWF0ZSBvbmVcbiAgICAvLyBhbmQgZGVsZXRlIHRoZSBleGlzdGluZyBvbmVzLlxuXG5cbiAgICBkZWxldGVSZW1haW5pbmdDaGlsZHJlbihyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQpO1xuICAgIHZhciBjcmVhdGVkID0gY3JlYXRlRmliZXJGcm9tVGV4dCh0ZXh0Q29udGVudCwgcmV0dXJuRmliZXIubW9kZSwgbGFuZXMpO1xuICAgIGNyZWF0ZWQucmV0dXJuID0gcmV0dXJuRmliZXI7XG4gICAgcmV0dXJuIGNyZWF0ZWQ7XG4gIH1cblxuICBmdW5jdGlvbiByZWNvbmNpbGVTaW5nbGVFbGVtZW50KHJldHVybkZpYmVyLCBjdXJyZW50Rmlyc3RDaGlsZCwgZWxlbWVudCwgbGFuZXMpIHtcbiAgICB2YXIga2V5ID0gZWxlbWVudC5rZXk7XG4gICAgdmFyIGNoaWxkID0gY3VycmVudEZpcnN0Q2hpbGQ7XG5cbiAgICB3aGlsZSAoY2hpbGQgIT09IG51bGwpIHtcbiAgICAgIC8vIFRPRE86IElmIGtleSA9PT0gbnVsbCBhbmQgY2hpbGQua2V5ID09PSBudWxsLCB0aGVuIHRoaXMgb25seSBhcHBsaWVzIHRvXG4gICAgICAvLyB0aGUgZmlyc3QgaXRlbSBpbiB0aGUgbGlzdC5cbiAgICAgIGlmIChjaGlsZC5rZXkgPT09IGtleSkge1xuICAgICAgICBzd2l0Y2ggKGNoaWxkLnRhZykge1xuICAgICAgICAgIGNhc2UgRnJhZ21lbnQ6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGlmIChlbGVtZW50LnR5cGUgPT09IFJFQUNUX0ZSQUdNRU5UX1RZUEUpIHtcbiAgICAgICAgICAgICAgICBkZWxldGVSZW1haW5pbmdDaGlsZHJlbihyZXR1cm5GaWJlciwgY2hpbGQuc2libGluZyk7XG4gICAgICAgICAgICAgICAgdmFyIGV4aXN0aW5nID0gdXNlRmliZXIoY2hpbGQsIGVsZW1lbnQucHJvcHMuY2hpbGRyZW4pO1xuICAgICAgICAgICAgICAgIGV4aXN0aW5nLnJldHVybiA9IHJldHVybkZpYmVyO1xuXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgZXhpc3RpbmcuX2RlYnVnU291cmNlID0gZWxlbWVudC5fc291cmNlO1xuICAgICAgICAgICAgICAgICAgZXhpc3RpbmcuX2RlYnVnT3duZXIgPSBlbGVtZW50Ll9vd25lcjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gZXhpc3Rpbmc7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIGNhc2UgQmxvY2s6XG5cbiAgICAgICAgICAvLyBXZSBpbnRlbnRpb25hbGx5IGZhbGx0aHJvdWdoIGhlcmUgaWYgZW5hYmxlQmxvY2tzQVBJIGlzIG5vdCBvbi5cbiAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVkIG5vLWZhbGx0aHJvdWdoXG5cbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBpZiAoY2hpbGQuZWxlbWVudFR5cGUgPT09IGVsZW1lbnQudHlwZSB8fCAoIC8vIEtlZXAgdGhpcyBjaGVjayBpbmxpbmUgc28gaXQgb25seSBydW5zIG9uIHRoZSBmYWxzZSBwYXRoOlxuICAgICAgICAgICAgICAgaXNDb21wYXRpYmxlRmFtaWx5Rm9ySG90UmVsb2FkaW5nKGNoaWxkLCBlbGVtZW50KSApKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlUmVtYWluaW5nQ2hpbGRyZW4ocmV0dXJuRmliZXIsIGNoaWxkLnNpYmxpbmcpO1xuXG4gICAgICAgICAgICAgICAgdmFyIF9leGlzdGluZzMgPSB1c2VGaWJlcihjaGlsZCwgZWxlbWVudC5wcm9wcyk7XG5cbiAgICAgICAgICAgICAgICBfZXhpc3RpbmczLnJlZiA9IGNvZXJjZVJlZihyZXR1cm5GaWJlciwgY2hpbGQsIGVsZW1lbnQpO1xuICAgICAgICAgICAgICAgIF9leGlzdGluZzMucmV0dXJuID0gcmV0dXJuRmliZXI7XG5cbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICBfZXhpc3RpbmczLl9kZWJ1Z1NvdXJjZSA9IGVsZW1lbnQuX3NvdXJjZTtcbiAgICAgICAgICAgICAgICAgIF9leGlzdGluZzMuX2RlYnVnT3duZXIgPSBlbGVtZW50Ll9vd25lcjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gX2V4aXN0aW5nMztcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IC8vIERpZG4ndCBtYXRjaC5cblxuXG4gICAgICAgIGRlbGV0ZVJlbWFpbmluZ0NoaWxkcmVuKHJldHVybkZpYmVyLCBjaGlsZCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVsZXRlQ2hpbGQocmV0dXJuRmliZXIsIGNoaWxkKTtcbiAgICAgIH1cblxuICAgICAgY2hpbGQgPSBjaGlsZC5zaWJsaW5nO1xuICAgIH1cblxuICAgIGlmIChlbGVtZW50LnR5cGUgPT09IFJFQUNUX0ZSQUdNRU5UX1RZUEUpIHtcbiAgICAgIHZhciBjcmVhdGVkID0gY3JlYXRlRmliZXJGcm9tRnJhZ21lbnQoZWxlbWVudC5wcm9wcy5jaGlsZHJlbiwgcmV0dXJuRmliZXIubW9kZSwgbGFuZXMsIGVsZW1lbnQua2V5KTtcbiAgICAgIGNyZWF0ZWQucmV0dXJuID0gcmV0dXJuRmliZXI7XG4gICAgICByZXR1cm4gY3JlYXRlZDtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIF9jcmVhdGVkNCA9IGNyZWF0ZUZpYmVyRnJvbUVsZW1lbnQoZWxlbWVudCwgcmV0dXJuRmliZXIubW9kZSwgbGFuZXMpO1xuXG4gICAgICBfY3JlYXRlZDQucmVmID0gY29lcmNlUmVmKHJldHVybkZpYmVyLCBjdXJyZW50Rmlyc3RDaGlsZCwgZWxlbWVudCk7XG4gICAgICBfY3JlYXRlZDQucmV0dXJuID0gcmV0dXJuRmliZXI7XG4gICAgICByZXR1cm4gX2NyZWF0ZWQ0O1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlY29uY2lsZVNpbmdsZVBvcnRhbChyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQsIHBvcnRhbCwgbGFuZXMpIHtcbiAgICB2YXIga2V5ID0gcG9ydGFsLmtleTtcbiAgICB2YXIgY2hpbGQgPSBjdXJyZW50Rmlyc3RDaGlsZDtcblxuICAgIHdoaWxlIChjaGlsZCAhPT0gbnVsbCkge1xuICAgICAgLy8gVE9ETzogSWYga2V5ID09PSBudWxsIGFuZCBjaGlsZC5rZXkgPT09IG51bGwsIHRoZW4gdGhpcyBvbmx5IGFwcGxpZXMgdG9cbiAgICAgIC8vIHRoZSBmaXJzdCBpdGVtIGluIHRoZSBsaXN0LlxuICAgICAgaWYgKGNoaWxkLmtleSA9PT0ga2V5KSB7XG4gICAgICAgIGlmIChjaGlsZC50YWcgPT09IEhvc3RQb3J0YWwgJiYgY2hpbGQuc3RhdGVOb2RlLmNvbnRhaW5lckluZm8gPT09IHBvcnRhbC5jb250YWluZXJJbmZvICYmIGNoaWxkLnN0YXRlTm9kZS5pbXBsZW1lbnRhdGlvbiA9PT0gcG9ydGFsLmltcGxlbWVudGF0aW9uKSB7XG4gICAgICAgICAgZGVsZXRlUmVtYWluaW5nQ2hpbGRyZW4ocmV0dXJuRmliZXIsIGNoaWxkLnNpYmxpbmcpO1xuICAgICAgICAgIHZhciBleGlzdGluZyA9IHVzZUZpYmVyKGNoaWxkLCBwb3J0YWwuY2hpbGRyZW4gfHwgW10pO1xuICAgICAgICAgIGV4aXN0aW5nLnJldHVybiA9IHJldHVybkZpYmVyO1xuICAgICAgICAgIHJldHVybiBleGlzdGluZztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkZWxldGVSZW1haW5pbmdDaGlsZHJlbihyZXR1cm5GaWJlciwgY2hpbGQpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWxldGVDaGlsZChyZXR1cm5GaWJlciwgY2hpbGQpO1xuICAgICAgfVxuXG4gICAgICBjaGlsZCA9IGNoaWxkLnNpYmxpbmc7XG4gICAgfVxuXG4gICAgdmFyIGNyZWF0ZWQgPSBjcmVhdGVGaWJlckZyb21Qb3J0YWwocG9ydGFsLCByZXR1cm5GaWJlci5tb2RlLCBsYW5lcyk7XG4gICAgY3JlYXRlZC5yZXR1cm4gPSByZXR1cm5GaWJlcjtcbiAgICByZXR1cm4gY3JlYXRlZDtcbiAgfSAvLyBUaGlzIEFQSSB3aWxsIHRhZyB0aGUgY2hpbGRyZW4gd2l0aCB0aGUgc2lkZS1lZmZlY3Qgb2YgdGhlIHJlY29uY2lsaWF0aW9uXG4gIC8vIGl0c2VsZi4gVGhleSB3aWxsIGJlIGFkZGVkIHRvIHRoZSBzaWRlLWVmZmVjdCBsaXN0IGFzIHdlIHBhc3MgdGhyb3VnaCB0aGVcbiAgLy8gY2hpbGRyZW4gYW5kIHRoZSBwYXJlbnQuXG5cblxuICBmdW5jdGlvbiByZWNvbmNpbGVDaGlsZEZpYmVycyhyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQsIG5ld0NoaWxkLCBsYW5lcykge1xuICAgIC8vIFRoaXMgZnVuY3Rpb24gaXMgbm90IHJlY3Vyc2l2ZS5cbiAgICAvLyBJZiB0aGUgdG9wIGxldmVsIGl0ZW0gaXMgYW4gYXJyYXksIHdlIHRyZWF0IGl0IGFzIGEgc2V0IG9mIGNoaWxkcmVuLFxuICAgIC8vIG5vdCBhcyBhIGZyYWdtZW50LiBOZXN0ZWQgYXJyYXlzIG9uIHRoZSBvdGhlciBoYW5kIHdpbGwgYmUgdHJlYXRlZCBhc1xuICAgIC8vIGZyYWdtZW50IG5vZGVzLiBSZWN1cnNpb24gaGFwcGVucyBhdCB0aGUgbm9ybWFsIGZsb3cuXG4gICAgLy8gSGFuZGxlIHRvcCBsZXZlbCB1bmtleWVkIGZyYWdtZW50cyBhcyBpZiB0aGV5IHdlcmUgYXJyYXlzLlxuICAgIC8vIFRoaXMgbGVhZHMgdG8gYW4gYW1iaWd1aXR5IGJldHdlZW4gPD57Wy4uLl19PC8+IGFuZCA8Pi4uLjwvPi5cbiAgICAvLyBXZSB0cmVhdCB0aGUgYW1iaWd1b3VzIGNhc2VzIGFib3ZlIHRoZSBzYW1lLlxuICAgIHZhciBpc1Vua2V5ZWRUb3BMZXZlbEZyYWdtZW50ID0gdHlwZW9mIG5ld0NoaWxkID09PSAnb2JqZWN0JyAmJiBuZXdDaGlsZCAhPT0gbnVsbCAmJiBuZXdDaGlsZC50eXBlID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFICYmIG5ld0NoaWxkLmtleSA9PT0gbnVsbDtcblxuICAgIGlmIChpc1Vua2V5ZWRUb3BMZXZlbEZyYWdtZW50KSB7XG4gICAgICBuZXdDaGlsZCA9IG5ld0NoaWxkLnByb3BzLmNoaWxkcmVuO1xuICAgIH0gLy8gSGFuZGxlIG9iamVjdCB0eXBlc1xuXG5cbiAgICB2YXIgaXNPYmplY3QgPSB0eXBlb2YgbmV3Q2hpbGQgPT09ICdvYmplY3QnICYmIG5ld0NoaWxkICE9PSBudWxsO1xuXG4gICAgaWYgKGlzT2JqZWN0KSB7XG4gICAgICBzd2l0Y2ggKG5ld0NoaWxkLiQkdHlwZW9mKSB7XG4gICAgICAgIGNhc2UgUkVBQ1RfRUxFTUVOVF9UWVBFOlxuICAgICAgICAgIHJldHVybiBwbGFjZVNpbmdsZUNoaWxkKHJlY29uY2lsZVNpbmdsZUVsZW1lbnQocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkLCBuZXdDaGlsZCwgbGFuZXMpKTtcblxuICAgICAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxuICAgICAgICAgIHJldHVybiBwbGFjZVNpbmdsZUNoaWxkKHJlY29uY2lsZVNpbmdsZVBvcnRhbChyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQsIG5ld0NoaWxkLCBsYW5lcykpO1xuXG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBuZXdDaGlsZCA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIG5ld0NoaWxkID09PSAnbnVtYmVyJykge1xuICAgICAgcmV0dXJuIHBsYWNlU2luZ2xlQ2hpbGQocmVjb25jaWxlU2luZ2xlVGV4dE5vZGUocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkLCAnJyArIG5ld0NoaWxkLCBsYW5lcykpO1xuICAgIH1cblxuICAgIGlmIChpc0FycmF5JDEobmV3Q2hpbGQpKSB7XG4gICAgICByZXR1cm4gcmVjb25jaWxlQ2hpbGRyZW5BcnJheShyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQsIG5ld0NoaWxkLCBsYW5lcyk7XG4gICAgfVxuXG4gICAgaWYgKGdldEl0ZXJhdG9yRm4obmV3Q2hpbGQpKSB7XG4gICAgICByZXR1cm4gcmVjb25jaWxlQ2hpbGRyZW5JdGVyYXRvcihyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQsIG5ld0NoaWxkLCBsYW5lcyk7XG4gICAgfVxuXG4gICAgaWYgKGlzT2JqZWN0KSB7XG4gICAgICB0aHJvd09uSW52YWxpZE9iamVjdFR5cGUocmV0dXJuRmliZXIsIG5ld0NoaWxkKTtcbiAgICB9XG5cbiAgICB7XG4gICAgICBpZiAodHlwZW9mIG5ld0NoaWxkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHdhcm5PbkZ1bmN0aW9uVHlwZShyZXR1cm5GaWJlcik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBuZXdDaGlsZCA9PT0gJ3VuZGVmaW5lZCcgJiYgIWlzVW5rZXllZFRvcExldmVsRnJhZ21lbnQpIHtcbiAgICAgIC8vIElmIHRoZSBuZXcgY2hpbGQgaXMgdW5kZWZpbmVkLCBhbmQgdGhlIHJldHVybiBmaWJlciBpcyBhIGNvbXBvc2l0ZVxuICAgICAgLy8gY29tcG9uZW50LCB0aHJvdyBhbiBlcnJvci4gSWYgRmliZXIgcmV0dXJuIHR5cGVzIGFyZSBkaXNhYmxlZCxcbiAgICAgIC8vIHdlIGFscmVhZHkgdGhyZXcgYWJvdmUuXG4gICAgICBzd2l0Y2ggKHJldHVybkZpYmVyLnRhZykge1xuICAgICAgICBjYXNlIENsYXNzQ29tcG9uZW50OlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgdmFyIGluc3RhbmNlID0gcmV0dXJuRmliZXIuc3RhdGVOb2RlO1xuXG4gICAgICAgICAgICAgIGlmIChpbnN0YW5jZS5yZW5kZXIuX2lzTW9ja0Z1bmN0aW9uKSB7XG4gICAgICAgICAgICAgICAgLy8gV2UgYWxsb3cgYXV0by1tb2NrcyB0byBwcm9jZWVkIGFzIGlmIHRoZXkncmUgcmV0dXJuaW5nIG51bGwuXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIC8vIEludGVudGlvbmFsbHkgZmFsbCB0aHJvdWdoIHRvIHRoZSBuZXh0IGNhc2UsIHdoaWNoIGhhbmRsZXMgYm90aFxuICAgICAgICAvLyBmdW5jdGlvbnMgYW5kIGNsYXNzZXNcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lZCBuby1mYWxsdGhyb3VnaFxuXG4gICAgICAgIGNhc2UgQmxvY2s6XG4gICAgICAgIGNhc2UgRnVuY3Rpb25Db21wb25lbnQ6XG4gICAgICAgIGNhc2UgRm9yd2FyZFJlZjpcbiAgICAgICAgY2FzZSBTaW1wbGVNZW1vQ29tcG9uZW50OlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRocm93IEVycm9yKCAoZ2V0Q29tcG9uZW50TmFtZShyZXR1cm5GaWJlci50eXBlKSB8fCAnQ29tcG9uZW50JykgKyBcIiguLi4pOiBOb3RoaW5nIHdhcyByZXR1cm5lZCBmcm9tIHJlbmRlci4gVGhpcyB1c3VhbGx5IG1lYW5zIGEgcmV0dXJuIHN0YXRlbWVudCBpcyBtaXNzaW5nLiBPciwgdG8gcmVuZGVyIG5vdGhpbmcsIHJldHVybiBudWxsLlwiICk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgfSAvLyBSZW1haW5pbmcgY2FzZXMgYXJlIGFsbCB0cmVhdGVkIGFzIGVtcHR5LlxuXG5cbiAgICByZXR1cm4gZGVsZXRlUmVtYWluaW5nQ2hpbGRyZW4ocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkKTtcbiAgfVxuXG4gIHJldHVybiByZWNvbmNpbGVDaGlsZEZpYmVycztcbn1cblxudmFyIHJlY29uY2lsZUNoaWxkRmliZXJzID0gQ2hpbGRSZWNvbmNpbGVyKHRydWUpO1xudmFyIG1vdW50Q2hpbGRGaWJlcnMgPSBDaGlsZFJlY29uY2lsZXIoZmFsc2UpO1xuZnVuY3Rpb24gY2xvbmVDaGlsZEZpYmVycyhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcykge1xuICBpZiAoIShjdXJyZW50ID09PSBudWxsIHx8IHdvcmtJblByb2dyZXNzLmNoaWxkID09PSBjdXJyZW50LmNoaWxkKSkge1xuICAgIHtcbiAgICAgIHRocm93IEVycm9yKCBcIlJlc3VtaW5nIHdvcmsgbm90IHlldCBpbXBsZW1lbnRlZC5cIiApO1xuICAgIH1cbiAgfVxuXG4gIGlmICh3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9PT0gbnVsbCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBjdXJyZW50Q2hpbGQgPSB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbiAgdmFyIG5ld0NoaWxkID0gY3JlYXRlV29ya0luUHJvZ3Jlc3MoY3VycmVudENoaWxkLCBjdXJyZW50Q2hpbGQucGVuZGluZ1Byb3BzKTtcbiAgd29ya0luUHJvZ3Jlc3MuY2hpbGQgPSBuZXdDaGlsZDtcbiAgbmV3Q2hpbGQucmV0dXJuID0gd29ya0luUHJvZ3Jlc3M7XG5cbiAgd2hpbGUgKGN1cnJlbnRDaGlsZC5zaWJsaW5nICE9PSBudWxsKSB7XG4gICAgY3VycmVudENoaWxkID0gY3VycmVudENoaWxkLnNpYmxpbmc7XG4gICAgbmV3Q2hpbGQgPSBuZXdDaGlsZC5zaWJsaW5nID0gY3JlYXRlV29ya0luUHJvZ3Jlc3MoY3VycmVudENoaWxkLCBjdXJyZW50Q2hpbGQucGVuZGluZ1Byb3BzKTtcbiAgICBuZXdDaGlsZC5yZXR1cm4gPSB3b3JrSW5Qcm9ncmVzcztcbiAgfVxuXG4gIG5ld0NoaWxkLnNpYmxpbmcgPSBudWxsO1xufSAvLyBSZXNldCBhIHdvcmtJblByb2dyZXNzIGNoaWxkIHNldCB0byBwcmVwYXJlIGl0IGZvciBhIHNlY29uZCBwYXNzLlxuXG5mdW5jdGlvbiByZXNldENoaWxkRmliZXJzKHdvcmtJblByb2dyZXNzLCBsYW5lcykge1xuICB2YXIgY2hpbGQgPSB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcblxuICB3aGlsZSAoY2hpbGQgIT09IG51bGwpIHtcbiAgICByZXNldFdvcmtJblByb2dyZXNzKGNoaWxkLCBsYW5lcyk7XG4gICAgY2hpbGQgPSBjaGlsZC5zaWJsaW5nO1xuICB9XG59XG5cbnZhciBOT19DT05URVhUID0ge307XG52YXIgY29udGV4dFN0YWNrQ3Vyc29yJDEgPSBjcmVhdGVDdXJzb3IoTk9fQ09OVEVYVCk7XG52YXIgY29udGV4dEZpYmVyU3RhY2tDdXJzb3IgPSBjcmVhdGVDdXJzb3IoTk9fQ09OVEVYVCk7XG52YXIgcm9vdEluc3RhbmNlU3RhY2tDdXJzb3IgPSBjcmVhdGVDdXJzb3IoTk9fQ09OVEVYVCk7XG5cbmZ1bmN0aW9uIHJlcXVpcmVkQ29udGV4dChjKSB7XG4gIGlmICghKGMgIT09IE5PX0NPTlRFWFQpKSB7XG4gICAge1xuICAgICAgdGhyb3cgRXJyb3IoIFwiRXhwZWN0ZWQgaG9zdCBjb250ZXh0IHRvIGV4aXN0LiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiICk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGM7XG59XG5cbmZ1bmN0aW9uIGdldFJvb3RIb3N0Q29udGFpbmVyKCkge1xuICB2YXIgcm9vdEluc3RhbmNlID0gcmVxdWlyZWRDb250ZXh0KHJvb3RJbnN0YW5jZVN0YWNrQ3Vyc29yLmN1cnJlbnQpO1xuICByZXR1cm4gcm9vdEluc3RhbmNlO1xufVxuXG5mdW5jdGlvbiBwdXNoSG9zdENvbnRhaW5lcihmaWJlciwgbmV4dFJvb3RJbnN0YW5jZSkge1xuICAvLyBQdXNoIGN1cnJlbnQgcm9vdCBpbnN0YW5jZSBvbnRvIHRoZSBzdGFjaztcbiAgLy8gVGhpcyBhbGxvd3MgdXMgdG8gcmVzZXQgcm9vdCB3aGVuIHBvcnRhbHMgYXJlIHBvcHBlZC5cbiAgcHVzaChyb290SW5zdGFuY2VTdGFja0N1cnNvciwgbmV4dFJvb3RJbnN0YW5jZSwgZmliZXIpOyAvLyBUcmFjayB0aGUgY29udGV4dCBhbmQgdGhlIEZpYmVyIHRoYXQgcHJvdmlkZWQgaXQuXG4gIC8vIFRoaXMgZW5hYmxlcyB1cyB0byBwb3Agb25seSBGaWJlcnMgdGhhdCBwcm92aWRlIHVuaXF1ZSBjb250ZXh0cy5cblxuICBwdXNoKGNvbnRleHRGaWJlclN0YWNrQ3Vyc29yLCBmaWJlciwgZmliZXIpOyAvLyBGaW5hbGx5LCB3ZSBuZWVkIHRvIHB1c2ggdGhlIGhvc3QgY29udGV4dCB0byB0aGUgc3RhY2suXG4gIC8vIEhvd2V2ZXIsIHdlIGNhbid0IGp1c3QgY2FsbCBnZXRSb290SG9zdENvbnRleHQoKSBhbmQgcHVzaCBpdCBiZWNhdXNlXG4gIC8vIHdlJ2QgaGF2ZSBhIGRpZmZlcmVudCBudW1iZXIgb2YgZW50cmllcyBvbiB0aGUgc3RhY2sgZGVwZW5kaW5nIG9uXG4gIC8vIHdoZXRoZXIgZ2V0Um9vdEhvc3RDb250ZXh0KCkgdGhyb3dzIHNvbWV3aGVyZSBpbiByZW5kZXJlciBjb2RlIG9yIG5vdC5cbiAgLy8gU28gd2UgcHVzaCBhbiBlbXB0eSB2YWx1ZSBmaXJzdC4gVGhpcyBsZXRzIHVzIHNhZmVseSB1bndpbmQgb24gZXJyb3JzLlxuXG4gIHB1c2goY29udGV4dFN0YWNrQ3Vyc29yJDEsIE5PX0NPTlRFWFQsIGZpYmVyKTtcbiAgdmFyIG5leHRSb290Q29udGV4dCA9IGdldFJvb3RIb3N0Q29udGV4dChuZXh0Um9vdEluc3RhbmNlKTsgLy8gTm93IHRoYXQgd2Uga25vdyB0aGlzIGZ1bmN0aW9uIGRvZXNuJ3QgdGhyb3csIHJlcGxhY2UgaXQuXG5cbiAgcG9wKGNvbnRleHRTdGFja0N1cnNvciQxLCBmaWJlcik7XG4gIHB1c2goY29udGV4dFN0YWNrQ3Vyc29yJDEsIG5leHRSb290Q29udGV4dCwgZmliZXIpO1xufVxuXG5mdW5jdGlvbiBwb3BIb3N0Q29udGFpbmVyKGZpYmVyKSB7XG4gIHBvcChjb250ZXh0U3RhY2tDdXJzb3IkMSwgZmliZXIpO1xuICBwb3AoY29udGV4dEZpYmVyU3RhY2tDdXJzb3IsIGZpYmVyKTtcbiAgcG9wKHJvb3RJbnN0YW5jZVN0YWNrQ3Vyc29yLCBmaWJlcik7XG59XG5cbmZ1bmN0aW9uIGdldEhvc3RDb250ZXh0KCkge1xuICB2YXIgY29udGV4dCA9IHJlcXVpcmVkQ29udGV4dChjb250ZXh0U3RhY2tDdXJzb3IkMS5jdXJyZW50KTtcbiAgcmV0dXJuIGNvbnRleHQ7XG59XG5cbmZ1bmN0aW9uIHB1c2hIb3N0Q29udGV4dChmaWJlcikge1xuICB2YXIgcm9vdEluc3RhbmNlID0gcmVxdWlyZWRDb250ZXh0KHJvb3RJbnN0YW5jZVN0YWNrQ3Vyc29yLmN1cnJlbnQpO1xuICB2YXIgY29udGV4dCA9IHJlcXVpcmVkQ29udGV4dChjb250ZXh0U3RhY2tDdXJzb3IkMS5jdXJyZW50KTtcbiAgdmFyIG5leHRDb250ZXh0ID0gZ2V0Q2hpbGRIb3N0Q29udGV4dChjb250ZXh0LCBmaWJlci50eXBlKTsgLy8gRG9uJ3QgcHVzaCB0aGlzIEZpYmVyJ3MgY29udGV4dCB1bmxlc3MgaXQncyB1bmlxdWUuXG5cbiAgaWYgKGNvbnRleHQgPT09IG5leHRDb250ZXh0KSB7XG4gICAgcmV0dXJuO1xuICB9IC8vIFRyYWNrIHRoZSBjb250ZXh0IGFuZCB0aGUgRmliZXIgdGhhdCBwcm92aWRlZCBpdC5cbiAgLy8gVGhpcyBlbmFibGVzIHVzIHRvIHBvcCBvbmx5IEZpYmVycyB0aGF0IHByb3ZpZGUgdW5pcXVlIGNvbnRleHRzLlxuXG5cbiAgcHVzaChjb250ZXh0RmliZXJTdGFja0N1cnNvciwgZmliZXIsIGZpYmVyKTtcbiAgcHVzaChjb250ZXh0U3RhY2tDdXJzb3IkMSwgbmV4dENvbnRleHQsIGZpYmVyKTtcbn1cblxuZnVuY3Rpb24gcG9wSG9zdENvbnRleHQoZmliZXIpIHtcbiAgLy8gRG8gbm90IHBvcCB1bmxlc3MgdGhpcyBGaWJlciBwcm92aWRlZCB0aGUgY3VycmVudCBjb250ZXh0LlxuICAvLyBwdXNoSG9zdENvbnRleHQoKSBvbmx5IHB1c2hlcyBGaWJlcnMgdGhhdCBwcm92aWRlIHVuaXF1ZSBjb250ZXh0cy5cbiAgaWYgKGNvbnRleHRGaWJlclN0YWNrQ3Vyc29yLmN1cnJlbnQgIT09IGZpYmVyKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgcG9wKGNvbnRleHRTdGFja0N1cnNvciQxLCBmaWJlcik7XG4gIHBvcChjb250ZXh0RmliZXJTdGFja0N1cnNvciwgZmliZXIpO1xufVxuXG52YXIgRGVmYXVsdFN1c3BlbnNlQ29udGV4dCA9IDA7IC8vIFRoZSBTdXNwZW5zZSBDb250ZXh0IGlzIHNwbGl0IGludG8gdHdvIHBhcnRzLiBUaGUgbG93ZXIgYml0cyBpc1xuLy8gaW5oZXJpdGVkIGRlZXBseSBkb3duIHRoZSBzdWJ0cmVlLiBUaGUgdXBwZXIgYml0cyBvbmx5IGFmZmVjdFxuLy8gdGhpcyBpbW1lZGlhdGUgc3VzcGVuc2UgYm91bmRhcnkgYW5kIGdldHMgcmVzZXQgZWFjaCBuZXdcbi8vIGJvdW5kYXJ5IG9yIHN1c3BlbnNlIGxpc3QuXG5cbnZhciBTdWJ0cmVlU3VzcGVuc2VDb250ZXh0TWFzayA9IDE7IC8vIFN1YnRyZWUgRmxhZ3M6XG4vLyBJbnZpc2libGVQYXJlbnRTdXNwZW5zZUNvbnRleHQgaW5kaWNhdGVzIHRoYXQgb25lIG9mIG91ciBwYXJlbnQgU3VzcGVuc2Vcbi8vIGJvdW5kYXJpZXMgaXMgbm90IGN1cnJlbnRseSBzaG93aW5nIHZpc2libGUgbWFpbiBjb250ZW50LlxuLy8gRWl0aGVyIGJlY2F1c2UgaXQgaXMgYWxyZWFkeSBzaG93aW5nIGEgZmFsbGJhY2sgb3IgaXMgbm90IG1vdW50ZWQgYXQgYWxsLlxuLy8gV2UgY2FuIHVzZSB0aGlzIHRvIGRldGVybWluZSBpZiBpdCBpcyBkZXNpcmFibGUgdG8gdHJpZ2dlciBhIGZhbGxiYWNrIGF0XG4vLyB0aGUgcGFyZW50LiBJZiBub3QsIHRoZW4gd2UgbWlnaHQgbmVlZCB0byB0cmlnZ2VyIHVuZGVzaXJhYmxlIGJvdW5kYXJpZXNcbi8vIGFuZC9vciBzdXNwZW5kIHRoZSBjb21taXQgdG8gYXZvaWQgaGlkaW5nIHRoZSBwYXJlbnQgY29udGVudC5cblxudmFyIEludmlzaWJsZVBhcmVudFN1c3BlbnNlQ29udGV4dCA9IDE7IC8vIFNoYWxsb3cgRmxhZ3M6XG4vLyBGb3JjZVN1c3BlbnNlRmFsbGJhY2sgY2FuIGJlIHVzZWQgYnkgU3VzcGVuc2VMaXN0IHRvIGZvcmNlIG5ld2x5IGFkZGVkXG4vLyBpdGVtcyBpbnRvIHRoZWlyIGZhbGxiYWNrIHN0YXRlIGR1cmluZyBvbmUgb2YgdGhlIHJlbmRlciBwYXNzZXMuXG5cbnZhciBGb3JjZVN1c3BlbnNlRmFsbGJhY2sgPSAyO1xudmFyIHN1c3BlbnNlU3RhY2tDdXJzb3IgPSBjcmVhdGVDdXJzb3IoRGVmYXVsdFN1c3BlbnNlQ29udGV4dCk7XG5mdW5jdGlvbiBoYXNTdXNwZW5zZUNvbnRleHQocGFyZW50Q29udGV4dCwgZmxhZykge1xuICByZXR1cm4gKHBhcmVudENvbnRleHQgJiBmbGFnKSAhPT0gMDtcbn1cbmZ1bmN0aW9uIHNldERlZmF1bHRTaGFsbG93U3VzcGVuc2VDb250ZXh0KHBhcmVudENvbnRleHQpIHtcbiAgcmV0dXJuIHBhcmVudENvbnRleHQgJiBTdWJ0cmVlU3VzcGVuc2VDb250ZXh0TWFzaztcbn1cbmZ1bmN0aW9uIHNldFNoYWxsb3dTdXNwZW5zZUNvbnRleHQocGFyZW50Q29udGV4dCwgc2hhbGxvd0NvbnRleHQpIHtcbiAgcmV0dXJuIHBhcmVudENvbnRleHQgJiBTdWJ0cmVlU3VzcGVuc2VDb250ZXh0TWFzayB8IHNoYWxsb3dDb250ZXh0O1xufVxuZnVuY3Rpb24gYWRkU3VidHJlZVN1c3BlbnNlQ29udGV4dChwYXJlbnRDb250ZXh0LCBzdWJ0cmVlQ29udGV4dCkge1xuICByZXR1cm4gcGFyZW50Q29udGV4dCB8IHN1YnRyZWVDb250ZXh0O1xufVxuZnVuY3Rpb24gcHVzaFN1c3BlbnNlQ29udGV4dChmaWJlciwgbmV3Q29udGV4dCkge1xuICBwdXNoKHN1c3BlbnNlU3RhY2tDdXJzb3IsIG5ld0NvbnRleHQsIGZpYmVyKTtcbn1cbmZ1bmN0aW9uIHBvcFN1c3BlbnNlQ29udGV4dChmaWJlcikge1xuICBwb3Aoc3VzcGVuc2VTdGFja0N1cnNvciwgZmliZXIpO1xufVxuXG5mdW5jdGlvbiBzaG91bGRDYXB0dXJlU3VzcGVuc2Uod29ya0luUHJvZ3Jlc3MsIGhhc0ludmlzaWJsZVBhcmVudCkge1xuICAvLyBJZiBpdCB3YXMgdGhlIHByaW1hcnkgY2hpbGRyZW4gdGhhdCBqdXN0IHN1c3BlbmRlZCwgY2FwdHVyZSBhbmQgcmVuZGVyIHRoZVxuICAvLyBmYWxsYmFjay4gT3RoZXJ3aXNlLCBkb24ndCBjYXB0dXJlIGFuZCBidWJibGUgdG8gdGhlIG5leHQgYm91bmRhcnkuXG4gIHZhciBuZXh0U3RhdGUgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO1xuXG4gIGlmIChuZXh0U3RhdGUgIT09IG51bGwpIHtcbiAgICBpZiAobmV4dFN0YXRlLmRlaHlkcmF0ZWQgIT09IG51bGwpIHtcbiAgICAgIC8vIEEgZGVoeWRyYXRlZCBib3VuZGFyeSBhbHdheXMgY2FwdHVyZXMuXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIgcHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFByb3BzOyAvLyBJbiBvcmRlciB0byBjYXB0dXJlLCB0aGUgU3VzcGVuc2UgY29tcG9uZW50IG11c3QgaGF2ZSBhIGZhbGxiYWNrIHByb3AuXG5cbiAgaWYgKHByb3BzLmZhbGxiYWNrID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0gLy8gUmVndWxhciBib3VuZGFyaWVzIGFsd2F5cyBjYXB0dXJlLlxuXG5cbiAgaWYgKHByb3BzLnVuc3RhYmxlX2F2b2lkVGhpc0ZhbGxiYWNrICE9PSB0cnVlKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gLy8gSWYgaXQncyBhIGJvdW5kYXJ5IHdlIHNob3VsZCBhdm9pZCwgdGhlbiB3ZSBwcmVmZXIgdG8gYnViYmxlIHVwIHRvIHRoZVxuICAvLyBwYXJlbnQgYm91bmRhcnkgaWYgaXQgaXMgY3VycmVudGx5IGludmlzaWJsZS5cblxuXG4gIGlmIChoYXNJbnZpc2libGVQYXJlbnQpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0gLy8gSWYgdGhlIHBhcmVudCBpcyBub3QgYWJsZSB0byBoYW5kbGUgaXQsIHdlIG11c3QgaGFuZGxlIGl0LlxuXG5cbiAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBmaW5kRmlyc3RTdXNwZW5kZWQocm93KSB7XG4gIHZhciBub2RlID0gcm93O1xuXG4gIHdoaWxlIChub2RlICE9PSBudWxsKSB7XG4gICAgaWYgKG5vZGUudGFnID09PSBTdXNwZW5zZUNvbXBvbmVudCkge1xuICAgICAgdmFyIHN0YXRlID0gbm9kZS5tZW1vaXplZFN0YXRlO1xuXG4gICAgICBpZiAoc3RhdGUgIT09IG51bGwpIHtcbiAgICAgICAgdmFyIGRlaHlkcmF0ZWQgPSBzdGF0ZS5kZWh5ZHJhdGVkO1xuXG4gICAgICAgIGlmIChkZWh5ZHJhdGVkID09PSBudWxsIHx8IGlzU3VzcGVuc2VJbnN0YW5jZVBlbmRpbmcoZGVoeWRyYXRlZCkgfHwgaXNTdXNwZW5zZUluc3RhbmNlRmFsbGJhY2soZGVoeWRyYXRlZCkpIHtcbiAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobm9kZS50YWcgPT09IFN1c3BlbnNlTGlzdENvbXBvbmVudCAmJiAvLyByZXZlYWxPcmRlciB1bmRlZmluZWQgY2FuJ3QgYmUgdHJ1c3RlZCBiZWNhdXNlIGl0IGRvbid0XG4gICAgLy8ga2VlcCB0cmFjayBvZiB3aGV0aGVyIGl0IHN1c3BlbmRlZCBvciBub3QuXG4gICAgbm9kZS5tZW1vaXplZFByb3BzLnJldmVhbE9yZGVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHZhciBkaWRTdXNwZW5kID0gKG5vZGUuZmxhZ3MgJiBEaWRDYXB0dXJlKSAhPT0gTm9GbGFncztcblxuICAgICAgaWYgKGRpZFN1c3BlbmQpIHtcbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChub2RlLmNoaWxkICE9PSBudWxsKSB7XG4gICAgICBub2RlLmNoaWxkLnJldHVybiA9IG5vZGU7XG4gICAgICBub2RlID0gbm9kZS5jaGlsZDtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGlmIChub2RlID09PSByb3cpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHdoaWxlIChub2RlLnNpYmxpbmcgPT09IG51bGwpIHtcbiAgICAgIGlmIChub2RlLnJldHVybiA9PT0gbnVsbCB8fCBub2RlLnJldHVybiA9PT0gcm93KSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICBub2RlID0gbm9kZS5yZXR1cm47XG4gICAgfVxuXG4gICAgbm9kZS5zaWJsaW5nLnJldHVybiA9IG5vZGUucmV0dXJuO1xuICAgIG5vZGUgPSBub2RlLnNpYmxpbmc7XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxudmFyIE5vRmxhZ3MkMSA9XG4vKiAgKi9cbjA7IC8vIFJlcHJlc2VudHMgd2hldGhlciBlZmZlY3Qgc2hvdWxkIGZpcmUuXG5cbnZhciBIYXNFZmZlY3QgPVxuLyogKi9cbjE7IC8vIFJlcHJlc2VudHMgdGhlIHBoYXNlIGluIHdoaWNoIHRoZSBlZmZlY3QgKG5vdCB0aGUgY2xlYW4tdXApIGZpcmVzLlxuXG52YXIgTGF5b3V0ID1cbi8qICAgICovXG4yO1xudmFyIFBhc3NpdmUkMSA9XG4vKiAgICovXG40O1xuXG4vLyBUaGlzIG1heSBoYXZlIGJlZW4gYW4gaW5zZXJ0aW9uIG9yIGEgaHlkcmF0aW9uLlxuXG52YXIgaHlkcmF0aW9uUGFyZW50RmliZXIgPSBudWxsO1xudmFyIG5leHRIeWRyYXRhYmxlSW5zdGFuY2UgPSBudWxsO1xudmFyIGlzSHlkcmF0aW5nID0gZmFsc2U7XG5cbmZ1bmN0aW9uIGVudGVySHlkcmF0aW9uU3RhdGUoZmliZXIpIHtcblxuICB2YXIgcGFyZW50SW5zdGFuY2UgPSBmaWJlci5zdGF0ZU5vZGUuY29udGFpbmVySW5mbztcbiAgbmV4dEh5ZHJhdGFibGVJbnN0YW5jZSA9IGdldEZpcnN0SHlkcmF0YWJsZUNoaWxkKHBhcmVudEluc3RhbmNlKTtcbiAgaHlkcmF0aW9uUGFyZW50RmliZXIgPSBmaWJlcjtcbiAgaXNIeWRyYXRpbmcgPSB0cnVlO1xuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gZGVsZXRlSHlkcmF0YWJsZUluc3RhbmNlKHJldHVybkZpYmVyLCBpbnN0YW5jZSkge1xuICB7XG4gICAgc3dpdGNoIChyZXR1cm5GaWJlci50YWcpIHtcbiAgICAgIGNhc2UgSG9zdFJvb3Q6XG4gICAgICAgIGRpZE5vdEh5ZHJhdGVDb250YWluZXJJbnN0YW5jZShyZXR1cm5GaWJlci5zdGF0ZU5vZGUuY29udGFpbmVySW5mbywgaW5zdGFuY2UpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgICAgICBkaWROb3RIeWRyYXRlSW5zdGFuY2UocmV0dXJuRmliZXIudHlwZSwgcmV0dXJuRmliZXIubWVtb2l6ZWRQcm9wcywgcmV0dXJuRmliZXIuc3RhdGVOb2RlLCBpbnN0YW5jZSk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHZhciBjaGlsZFRvRGVsZXRlID0gY3JlYXRlRmliZXJGcm9tSG9zdEluc3RhbmNlRm9yRGVsZXRpb24oKTtcbiAgY2hpbGRUb0RlbGV0ZS5zdGF0ZU5vZGUgPSBpbnN0YW5jZTtcbiAgY2hpbGRUb0RlbGV0ZS5yZXR1cm4gPSByZXR1cm5GaWJlcjtcbiAgY2hpbGRUb0RlbGV0ZS5mbGFncyA9IERlbGV0aW9uOyAvLyBUaGlzIG1pZ2h0IHNlZW0gbGlrZSBpdCBiZWxvbmdzIG9uIHByb2dyZXNzZWRGaXJzdERlbGV0aW9uLiBIb3dldmVyLFxuICAvLyB0aGVzZSBjaGlsZHJlbiBhcmUgbm90IHBhcnQgb2YgdGhlIHJlY29uY2lsaWF0aW9uIGxpc3Qgb2YgY2hpbGRyZW4uXG4gIC8vIEV2ZW4gaWYgd2UgYWJvcnQgYW5kIHJlcmVjb25jaWxlIHRoZSBjaGlsZHJlbiwgdGhhdCB3aWxsIHRyeSB0byBoeWRyYXRlXG4gIC8vIGFnYWluIGFuZCB0aGUgbm9kZXMgYXJlIHN0aWxsIGluIHRoZSBob3N0IHRyZWUgc28gdGhlc2Ugd2lsbCBiZVxuICAvLyByZWNyZWF0ZWQuXG5cbiAgaWYgKHJldHVybkZpYmVyLmxhc3RFZmZlY3QgIT09IG51bGwpIHtcbiAgICByZXR1cm5GaWJlci5sYXN0RWZmZWN0Lm5leHRFZmZlY3QgPSBjaGlsZFRvRGVsZXRlO1xuICAgIHJldHVybkZpYmVyLmxhc3RFZmZlY3QgPSBjaGlsZFRvRGVsZXRlO1xuICB9IGVsc2Uge1xuICAgIHJldHVybkZpYmVyLmZpcnN0RWZmZWN0ID0gcmV0dXJuRmliZXIubGFzdEVmZmVjdCA9IGNoaWxkVG9EZWxldGU7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW5zZXJ0Tm9uSHlkcmF0ZWRJbnN0YW5jZShyZXR1cm5GaWJlciwgZmliZXIpIHtcbiAgZmliZXIuZmxhZ3MgPSBmaWJlci5mbGFncyAmIH5IeWRyYXRpbmcgfCBQbGFjZW1lbnQ7XG5cbiAge1xuICAgIHN3aXRjaCAocmV0dXJuRmliZXIudGFnKSB7XG4gICAgICBjYXNlIEhvc3RSb290OlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIHBhcmVudENvbnRhaW5lciA9IHJldHVybkZpYmVyLnN0YXRlTm9kZS5jb250YWluZXJJbmZvO1xuXG4gICAgICAgICAgc3dpdGNoIChmaWJlci50YWcpIHtcbiAgICAgICAgICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICAgICAgICAgICAgdmFyIHR5cGUgPSBmaWJlci50eXBlO1xuICAgICAgICAgICAgICB2YXIgcHJvcHMgPSBmaWJlci5wZW5kaW5nUHJvcHM7XG4gICAgICAgICAgICAgIGRpZE5vdEZpbmRIeWRyYXRhYmxlQ29udGFpbmVySW5zdGFuY2UocGFyZW50Q29udGFpbmVyLCB0eXBlKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgSG9zdFRleHQ6XG4gICAgICAgICAgICAgIHZhciB0ZXh0ID0gZmliZXIucGVuZGluZ1Byb3BzO1xuICAgICAgICAgICAgICBkaWROb3RGaW5kSHlkcmF0YWJsZUNvbnRhaW5lclRleHRJbnN0YW5jZShwYXJlbnRDb250YWluZXIsIHRleHQpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgcGFyZW50VHlwZSA9IHJldHVybkZpYmVyLnR5cGU7XG4gICAgICAgICAgdmFyIHBhcmVudFByb3BzID0gcmV0dXJuRmliZXIubWVtb2l6ZWRQcm9wcztcbiAgICAgICAgICB2YXIgcGFyZW50SW5zdGFuY2UgPSByZXR1cm5GaWJlci5zdGF0ZU5vZGU7XG5cbiAgICAgICAgICBzd2l0Y2ggKGZpYmVyLnRhZykge1xuICAgICAgICAgICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgICAgICAgICAgICB2YXIgX3R5cGUgPSBmaWJlci50eXBlO1xuICAgICAgICAgICAgICB2YXIgX3Byb3BzID0gZmliZXIucGVuZGluZ1Byb3BzO1xuICAgICAgICAgICAgICBkaWROb3RGaW5kSHlkcmF0YWJsZUluc3RhbmNlKHBhcmVudFR5cGUsIHBhcmVudFByb3BzLCBwYXJlbnRJbnN0YW5jZSwgX3R5cGUpO1xuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSBIb3N0VGV4dDpcbiAgICAgICAgICAgICAgdmFyIF90ZXh0ID0gZmliZXIucGVuZGluZ1Byb3BzO1xuICAgICAgICAgICAgICBkaWROb3RGaW5kSHlkcmF0YWJsZVRleHRJbnN0YW5jZShwYXJlbnRUeXBlLCBwYXJlbnRQcm9wcywgcGFyZW50SW5zdGFuY2UsIF90ZXh0KTtcbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgU3VzcGVuc2VDb21wb25lbnQ6XG4gICAgICAgICAgICAgIGRpZE5vdEZpbmRIeWRyYXRhYmxlU3VzcGVuc2VJbnN0YW5jZShwYXJlbnRUeXBlLCBwYXJlbnRQcm9wcyk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gdHJ5SHlkcmF0ZShmaWJlciwgbmV4dEluc3RhbmNlKSB7XG4gIHN3aXRjaCAoZmliZXIudGFnKSB7XG4gICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgICAge1xuICAgICAgICB2YXIgdHlwZSA9IGZpYmVyLnR5cGU7XG4gICAgICAgIHZhciBwcm9wcyA9IGZpYmVyLnBlbmRpbmdQcm9wcztcbiAgICAgICAgdmFyIGluc3RhbmNlID0gY2FuSHlkcmF0ZUluc3RhbmNlKG5leHRJbnN0YW5jZSwgdHlwZSk7XG5cbiAgICAgICAgaWYgKGluc3RhbmNlICE9PSBudWxsKSB7XG4gICAgICAgICAgZmliZXIuc3RhdGVOb2RlID0gaW5zdGFuY2U7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICBjYXNlIEhvc3RUZXh0OlxuICAgICAge1xuICAgICAgICB2YXIgdGV4dCA9IGZpYmVyLnBlbmRpbmdQcm9wcztcbiAgICAgICAgdmFyIHRleHRJbnN0YW5jZSA9IGNhbkh5ZHJhdGVUZXh0SW5zdGFuY2UobmV4dEluc3RhbmNlLCB0ZXh0KTtcblxuICAgICAgICBpZiAodGV4dEluc3RhbmNlICE9PSBudWxsKSB7XG4gICAgICAgICAgZmliZXIuc3RhdGVOb2RlID0gdGV4dEluc3RhbmNlO1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgY2FzZSBTdXNwZW5zZUNvbXBvbmVudDpcbiAgICAgIHtcblxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbmZ1bmN0aW9uIHRyeVRvQ2xhaW1OZXh0SHlkcmF0YWJsZUluc3RhbmNlKGZpYmVyKSB7XG4gIGlmICghaXNIeWRyYXRpbmcpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgbmV4dEluc3RhbmNlID0gbmV4dEh5ZHJhdGFibGVJbnN0YW5jZTtcblxuICBpZiAoIW5leHRJbnN0YW5jZSkge1xuICAgIC8vIE5vdGhpbmcgdG8gaHlkcmF0ZS4gTWFrZSBpdCBhbiBpbnNlcnRpb24uXG4gICAgaW5zZXJ0Tm9uSHlkcmF0ZWRJbnN0YW5jZShoeWRyYXRpb25QYXJlbnRGaWJlciwgZmliZXIpO1xuICAgIGlzSHlkcmF0aW5nID0gZmFsc2U7XG4gICAgaHlkcmF0aW9uUGFyZW50RmliZXIgPSBmaWJlcjtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgZmlyc3RBdHRlbXB0ZWRJbnN0YW5jZSA9IG5leHRJbnN0YW5jZTtcblxuICBpZiAoIXRyeUh5ZHJhdGUoZmliZXIsIG5leHRJbnN0YW5jZSkpIHtcbiAgICAvLyBJZiB3ZSBjYW4ndCBoeWRyYXRlIHRoaXMgaW5zdGFuY2UgbGV0J3MgdHJ5IHRoZSBuZXh0IG9uZS5cbiAgICAvLyBXZSB1c2UgdGhpcyBhcyBhIGhldXJpc3RpYy4gSXQncyBiYXNlZCBvbiBpbnR1aXRpb24gYW5kIG5vdCBkYXRhIHNvIGl0XG4gICAgLy8gbWlnaHQgYmUgZmxhd2VkIG9yIHVubmVjZXNzYXJ5LlxuICAgIG5leHRJbnN0YW5jZSA9IGdldE5leHRIeWRyYXRhYmxlU2libGluZyhmaXJzdEF0dGVtcHRlZEluc3RhbmNlKTtcblxuICAgIGlmICghbmV4dEluc3RhbmNlIHx8ICF0cnlIeWRyYXRlKGZpYmVyLCBuZXh0SW5zdGFuY2UpKSB7XG4gICAgICAvLyBOb3RoaW5nIHRvIGh5ZHJhdGUuIE1ha2UgaXQgYW4gaW5zZXJ0aW9uLlxuICAgICAgaW5zZXJ0Tm9uSHlkcmF0ZWRJbnN0YW5jZShoeWRyYXRpb25QYXJlbnRGaWJlciwgZmliZXIpO1xuICAgICAgaXNIeWRyYXRpbmcgPSBmYWxzZTtcbiAgICAgIGh5ZHJhdGlvblBhcmVudEZpYmVyID0gZmliZXI7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyBXZSBtYXRjaGVkIHRoZSBuZXh0IG9uZSwgd2UnbGwgbm93IGFzc3VtZSB0aGF0IHRoZSBmaXJzdCBvbmUgd2FzXG4gICAgLy8gc3VwZXJmbHVvdXMgYW5kIHdlJ2xsIGRlbGV0ZSBpdC4gU2luY2Ugd2UgY2FuJ3QgZWFnZXJseSBkZWxldGUgaXRcbiAgICAvLyB3ZSdsbCBoYXZlIHRvIHNjaGVkdWxlIGEgZGVsZXRpb24uIFRvIGRvIHRoYXQsIHRoaXMgbm9kZSBuZWVkcyBhIGR1bW15XG4gICAgLy8gZmliZXIgYXNzb2NpYXRlZCB3aXRoIGl0LlxuXG5cbiAgICBkZWxldGVIeWRyYXRhYmxlSW5zdGFuY2UoaHlkcmF0aW9uUGFyZW50RmliZXIsIGZpcnN0QXR0ZW1wdGVkSW5zdGFuY2UpO1xuICB9XG5cbiAgaHlkcmF0aW9uUGFyZW50RmliZXIgPSBmaWJlcjtcbiAgbmV4dEh5ZHJhdGFibGVJbnN0YW5jZSA9IGdldEZpcnN0SHlkcmF0YWJsZUNoaWxkKG5leHRJbnN0YW5jZSk7XG59XG5cbmZ1bmN0aW9uIHByZXBhcmVUb0h5ZHJhdGVIb3N0SW5zdGFuY2UoZmliZXIsIHJvb3RDb250YWluZXJJbnN0YW5jZSwgaG9zdENvbnRleHQpIHtcblxuICB2YXIgaW5zdGFuY2UgPSBmaWJlci5zdGF0ZU5vZGU7XG4gIHZhciB1cGRhdGVQYXlsb2FkID0gaHlkcmF0ZUluc3RhbmNlKGluc3RhbmNlLCBmaWJlci50eXBlLCBmaWJlci5tZW1vaXplZFByb3BzLCByb290Q29udGFpbmVySW5zdGFuY2UsIGhvc3RDb250ZXh0LCBmaWJlcik7IC8vIFRPRE86IFR5cGUgdGhpcyBzcGVjaWZpYyB0byB0aGlzIHR5cGUgb2YgY29tcG9uZW50LlxuXG4gIGZpYmVyLnVwZGF0ZVF1ZXVlID0gdXBkYXRlUGF5bG9hZDsgLy8gSWYgdGhlIHVwZGF0ZSBwYXlsb2FkIGluZGljYXRlcyB0aGF0IHRoZXJlIGlzIGEgY2hhbmdlIG9yIGlmIHRoZXJlXG4gIC8vIGlzIGEgbmV3IHJlZiB3ZSBtYXJrIHRoaXMgYXMgYW4gdXBkYXRlLlxuXG4gIGlmICh1cGRhdGVQYXlsb2FkICE9PSBudWxsKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIHByZXBhcmVUb0h5ZHJhdGVIb3N0VGV4dEluc3RhbmNlKGZpYmVyKSB7XG5cbiAgdmFyIHRleHRJbnN0YW5jZSA9IGZpYmVyLnN0YXRlTm9kZTtcbiAgdmFyIHRleHRDb250ZW50ID0gZmliZXIubWVtb2l6ZWRQcm9wcztcbiAgdmFyIHNob3VsZFVwZGF0ZSA9IGh5ZHJhdGVUZXh0SW5zdGFuY2UodGV4dEluc3RhbmNlLCB0ZXh0Q29udGVudCwgZmliZXIpO1xuXG4gIHtcbiAgICBpZiAoc2hvdWxkVXBkYXRlKSB7XG4gICAgICAvLyBXZSBhc3N1bWUgdGhhdCBwcmVwYXJlVG9IeWRyYXRlSG9zdFRleHRJbnN0YW5jZSBpcyBjYWxsZWQgaW4gYSBjb250ZXh0IHdoZXJlIHRoZVxuICAgICAgLy8gaHlkcmF0aW9uIHBhcmVudCBpcyB0aGUgcGFyZW50IGhvc3QgY29tcG9uZW50IG9mIHRoaXMgaG9zdCB0ZXh0LlxuICAgICAgdmFyIHJldHVybkZpYmVyID0gaHlkcmF0aW9uUGFyZW50RmliZXI7XG5cbiAgICAgIGlmIChyZXR1cm5GaWJlciAhPT0gbnVsbCkge1xuICAgICAgICBzd2l0Y2ggKHJldHVybkZpYmVyLnRhZykge1xuICAgICAgICAgIGNhc2UgSG9zdFJvb3Q6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHZhciBwYXJlbnRDb250YWluZXIgPSByZXR1cm5GaWJlci5zdGF0ZU5vZGUuY29udGFpbmVySW5mbztcbiAgICAgICAgICAgICAgZGlkTm90TWF0Y2hIeWRyYXRlZENvbnRhaW5lclRleHRJbnN0YW5jZShwYXJlbnRDb250YWluZXIsIHRleHRJbnN0YW5jZSwgdGV4dENvbnRlbnQpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgdmFyIHBhcmVudFR5cGUgPSByZXR1cm5GaWJlci50eXBlO1xuICAgICAgICAgICAgICB2YXIgcGFyZW50UHJvcHMgPSByZXR1cm5GaWJlci5tZW1vaXplZFByb3BzO1xuICAgICAgICAgICAgICB2YXIgcGFyZW50SW5zdGFuY2UgPSByZXR1cm5GaWJlci5zdGF0ZU5vZGU7XG4gICAgICAgICAgICAgIGRpZE5vdE1hdGNoSHlkcmF0ZWRUZXh0SW5zdGFuY2UocGFyZW50VHlwZSwgcGFyZW50UHJvcHMsIHBhcmVudEluc3RhbmNlLCB0ZXh0SW5zdGFuY2UsIHRleHRDb250ZW50KTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gc2hvdWxkVXBkYXRlO1xufVxuXG5mdW5jdGlvbiBza2lwUGFzdERlaHlkcmF0ZWRTdXNwZW5zZUluc3RhbmNlKGZpYmVyKSB7XG5cbiAgdmFyIHN1c3BlbnNlU3RhdGUgPSBmaWJlci5tZW1vaXplZFN0YXRlO1xuICB2YXIgc3VzcGVuc2VJbnN0YW5jZSA9IHN1c3BlbnNlU3RhdGUgIT09IG51bGwgPyBzdXNwZW5zZVN0YXRlLmRlaHlkcmF0ZWQgOiBudWxsO1xuXG4gIGlmICghc3VzcGVuc2VJbnN0YW5jZSkge1xuICAgIHtcbiAgICAgIHRocm93IEVycm9yKCBcIkV4cGVjdGVkIHRvIGhhdmUgYSBoeWRyYXRlZCBzdXNwZW5zZSBpbnN0YW5jZS4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS5cIiApO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBnZXROZXh0SHlkcmF0YWJsZUluc3RhbmNlQWZ0ZXJTdXNwZW5zZUluc3RhbmNlKHN1c3BlbnNlSW5zdGFuY2UpO1xufVxuXG5mdW5jdGlvbiBwb3BUb05leHRIb3N0UGFyZW50KGZpYmVyKSB7XG4gIHZhciBwYXJlbnQgPSBmaWJlci5yZXR1cm47XG5cbiAgd2hpbGUgKHBhcmVudCAhPT0gbnVsbCAmJiBwYXJlbnQudGFnICE9PSBIb3N0Q29tcG9uZW50ICYmIHBhcmVudC50YWcgIT09IEhvc3RSb290ICYmIHBhcmVudC50YWcgIT09IFN1c3BlbnNlQ29tcG9uZW50KSB7XG4gICAgcGFyZW50ID0gcGFyZW50LnJldHVybjtcbiAgfVxuXG4gIGh5ZHJhdGlvblBhcmVudEZpYmVyID0gcGFyZW50O1xufVxuXG5mdW5jdGlvbiBwb3BIeWRyYXRpb25TdGF0ZShmaWJlcikge1xuXG4gIGlmIChmaWJlciAhPT0gaHlkcmF0aW9uUGFyZW50RmliZXIpIHtcbiAgICAvLyBXZSdyZSBkZWVwZXIgdGhhbiB0aGUgY3VycmVudCBoeWRyYXRpb24gY29udGV4dCwgaW5zaWRlIGFuIGluc2VydGVkXG4gICAgLy8gdHJlZS5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoIWlzSHlkcmF0aW5nKSB7XG4gICAgLy8gSWYgd2UncmUgbm90IGN1cnJlbnRseSBoeWRyYXRpbmcgYnV0IHdlJ3JlIGluIGEgaHlkcmF0aW9uIGNvbnRleHQsIHRoZW5cbiAgICAvLyB3ZSB3ZXJlIGFuIGluc2VydGlvbiBhbmQgbm93IG5lZWQgdG8gcG9wIHVwIHJlZW50ZXIgaHlkcmF0aW9uIG9mIG91clxuICAgIC8vIHNpYmxpbmdzLlxuICAgIHBvcFRvTmV4dEhvc3RQYXJlbnQoZmliZXIpO1xuICAgIGlzSHlkcmF0aW5nID0gdHJ1ZTtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIgdHlwZSA9IGZpYmVyLnR5cGU7IC8vIElmIHdlIGhhdmUgYW55IHJlbWFpbmluZyBoeWRyYXRhYmxlIG5vZGVzLCB3ZSBuZWVkIHRvIGRlbGV0ZSB0aGVtIG5vdy5cbiAgLy8gV2Ugb25seSBkbyB0aGlzIGRlZXBlciB0aGFuIGhlYWQgYW5kIGJvZHkgc2luY2UgdGhleSB0ZW5kIHRvIGhhdmUgcmFuZG9tXG4gIC8vIG90aGVyIG5vZGVzIGluIHRoZW0uIFdlIGFsc28gaWdub3JlIGNvbXBvbmVudHMgd2l0aCBwdXJlIHRleHQgY29udGVudCBpblxuICAvLyBzaWRlIG9mIHRoZW0uXG4gIC8vIFRPRE86IEJldHRlciBoZXVyaXN0aWMuXG5cbiAgaWYgKGZpYmVyLnRhZyAhPT0gSG9zdENvbXBvbmVudCB8fCB0eXBlICE9PSAnaGVhZCcgJiYgdHlwZSAhPT0gJ2JvZHknICYmICFzaG91bGRTZXRUZXh0Q29udGVudCh0eXBlLCBmaWJlci5tZW1vaXplZFByb3BzKSkge1xuICAgIHZhciBuZXh0SW5zdGFuY2UgPSBuZXh0SHlkcmF0YWJsZUluc3RhbmNlO1xuXG4gICAgd2hpbGUgKG5leHRJbnN0YW5jZSkge1xuICAgICAgZGVsZXRlSHlkcmF0YWJsZUluc3RhbmNlKGZpYmVyLCBuZXh0SW5zdGFuY2UpO1xuICAgICAgbmV4dEluc3RhbmNlID0gZ2V0TmV4dEh5ZHJhdGFibGVTaWJsaW5nKG5leHRJbnN0YW5jZSk7XG4gICAgfVxuICB9XG5cbiAgcG9wVG9OZXh0SG9zdFBhcmVudChmaWJlcik7XG5cbiAgaWYgKGZpYmVyLnRhZyA9PT0gU3VzcGVuc2VDb21wb25lbnQpIHtcbiAgICBuZXh0SHlkcmF0YWJsZUluc3RhbmNlID0gc2tpcFBhc3REZWh5ZHJhdGVkU3VzcGVuc2VJbnN0YW5jZShmaWJlcik7XG4gIH0gZWxzZSB7XG4gICAgbmV4dEh5ZHJhdGFibGVJbnN0YW5jZSA9IGh5ZHJhdGlvblBhcmVudEZpYmVyID8gZ2V0TmV4dEh5ZHJhdGFibGVTaWJsaW5nKGZpYmVyLnN0YXRlTm9kZSkgOiBudWxsO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIHJlc2V0SHlkcmF0aW9uU3RhdGUoKSB7XG5cbiAgaHlkcmF0aW9uUGFyZW50RmliZXIgPSBudWxsO1xuICBuZXh0SHlkcmF0YWJsZUluc3RhbmNlID0gbnVsbDtcbiAgaXNIeWRyYXRpbmcgPSBmYWxzZTtcbn1cblxuZnVuY3Rpb24gZ2V0SXNIeWRyYXRpbmcoKSB7XG4gIHJldHVybiBpc0h5ZHJhdGluZztcbn1cblxuLy8gYW5kIHNob3VsZCBiZSByZXNldCBiZWZvcmUgc3RhcnRpbmcgYSBuZXcgcmVuZGVyLlxuLy8gVGhpcyB0cmFja3Mgd2hpY2ggbXV0YWJsZSBzb3VyY2VzIG5lZWQgdG8gYmUgcmVzZXQgYWZ0ZXIgYSByZW5kZXIuXG5cbnZhciB3b3JrSW5Qcm9ncmVzc1NvdXJjZXMgPSBbXTtcbnZhciByZW5kZXJlclNpZ2lsJDE7XG5cbntcbiAgLy8gVXNlZCB0byBkZXRlY3QgbXVsdGlwbGUgcmVuZGVyZXJzIHVzaW5nIHRoZSBzYW1lIG11dGFibGUgc291cmNlLlxuICByZW5kZXJlclNpZ2lsJDEgPSB7fTtcbn1cblxuZnVuY3Rpb24gbWFya1NvdXJjZUFzRGlydHkobXV0YWJsZVNvdXJjZSkge1xuICB3b3JrSW5Qcm9ncmVzc1NvdXJjZXMucHVzaChtdXRhYmxlU291cmNlKTtcbn1cbmZ1bmN0aW9uIHJlc2V0V29ya0luUHJvZ3Jlc3NWZXJzaW9ucygpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB3b3JrSW5Qcm9ncmVzc1NvdXJjZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgbXV0YWJsZVNvdXJjZSA9IHdvcmtJblByb2dyZXNzU291cmNlc1tpXTtcblxuICAgIHtcbiAgICAgIG11dGFibGVTb3VyY2UuX3dvcmtJblByb2dyZXNzVmVyc2lvblByaW1hcnkgPSBudWxsO1xuICAgIH1cbiAgfVxuXG4gIHdvcmtJblByb2dyZXNzU291cmNlcy5sZW5ndGggPSAwO1xufVxuZnVuY3Rpb24gZ2V0V29ya0luUHJvZ3Jlc3NWZXJzaW9uKG11dGFibGVTb3VyY2UpIHtcbiAge1xuICAgIHJldHVybiBtdXRhYmxlU291cmNlLl93b3JrSW5Qcm9ncmVzc1ZlcnNpb25QcmltYXJ5O1xuICB9XG59XG5mdW5jdGlvbiBzZXRXb3JrSW5Qcm9ncmVzc1ZlcnNpb24obXV0YWJsZVNvdXJjZSwgdmVyc2lvbikge1xuICB7XG4gICAgbXV0YWJsZVNvdXJjZS5fd29ya0luUHJvZ3Jlc3NWZXJzaW9uUHJpbWFyeSA9IHZlcnNpb247XG4gIH1cblxuICB3b3JrSW5Qcm9ncmVzc1NvdXJjZXMucHVzaChtdXRhYmxlU291cmNlKTtcbn1cbmZ1bmN0aW9uIHdhcm5BYm91dE11bHRpcGxlUmVuZGVyZXJzREVWKG11dGFibGVTb3VyY2UpIHtcbiAge1xuICAgIHtcbiAgICAgIGlmIChtdXRhYmxlU291cmNlLl9jdXJyZW50UHJpbWFyeVJlbmRlcmVyID09IG51bGwpIHtcbiAgICAgICAgbXV0YWJsZVNvdXJjZS5fY3VycmVudFByaW1hcnlSZW5kZXJlciA9IHJlbmRlcmVyU2lnaWwkMTtcbiAgICAgIH0gZWxzZSBpZiAobXV0YWJsZVNvdXJjZS5fY3VycmVudFByaW1hcnlSZW5kZXJlciAhPT0gcmVuZGVyZXJTaWdpbCQxKSB7XG4gICAgICAgIGVycm9yKCdEZXRlY3RlZCBtdWx0aXBsZSByZW5kZXJlcnMgY29uY3VycmVudGx5IHJlbmRlcmluZyB0aGUgJyArICdzYW1lIG11dGFibGUgc291cmNlLiBUaGlzIGlzIGN1cnJlbnRseSB1bnN1cHBvcnRlZC4nKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn0gLy8gRWFnZXIgcmVhZHMgdGhlIHZlcnNpb24gb2YgYSBtdXRhYmxlIHNvdXJjZSBhbmQgc3RvcmVzIGl0IG9uIHRoZSByb290LlxuXG52YXIgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3RDdXJyZW50RGlzcGF0Y2hlcixcbiAgICBSZWFjdEN1cnJlbnRCYXRjaENvbmZpZyQxID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3RDdXJyZW50QmF0Y2hDb25maWc7XG52YXIgZGlkV2FybkFib3V0TWlzbWF0Y2hlZEhvb2tzRm9yQ29tcG9uZW50O1xudmFyIGRpZFdhcm5BYm91dFVzZU9wYXF1ZUlkZW50aWZpZXI7XG5cbntcbiAgZGlkV2FybkFib3V0VXNlT3BhcXVlSWRlbnRpZmllciA9IHt9O1xuICBkaWRXYXJuQWJvdXRNaXNtYXRjaGVkSG9va3NGb3JDb21wb25lbnQgPSBuZXcgU2V0KCk7XG59XG5cbi8vIFRoZXNlIGFyZSBzZXQgcmlnaHQgYmVmb3JlIGNhbGxpbmcgdGhlIGNvbXBvbmVudC5cbnZhciByZW5kZXJMYW5lcyA9IE5vTGFuZXM7IC8vIFRoZSB3b3JrLWluLXByb2dyZXNzIGZpYmVyLiBJJ3ZlIG5hbWVkIGl0IGRpZmZlcmVudGx5IHRvIGRpc3Rpbmd1aXNoIGl0IGZyb21cbi8vIHRoZSB3b3JrLWluLXByb2dyZXNzIGhvb2suXG5cbnZhciBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxID0gbnVsbDsgLy8gSG9va3MgYXJlIHN0b3JlZCBhcyBhIGxpbmtlZCBsaXN0IG9uIHRoZSBmaWJlcidzIG1lbW9pemVkU3RhdGUgZmllbGQuIFRoZVxuLy8gY3VycmVudCBob29rIGxpc3QgaXMgdGhlIGxpc3QgdGhhdCBiZWxvbmdzIHRvIHRoZSBjdXJyZW50IGZpYmVyLiBUaGVcbi8vIHdvcmstaW4tcHJvZ3Jlc3MgaG9vayBsaXN0IGlzIGEgbmV3IGxpc3QgdGhhdCB3aWxsIGJlIGFkZGVkIHRvIHRoZVxuLy8gd29yay1pbi1wcm9ncmVzcyBmaWJlci5cblxudmFyIGN1cnJlbnRIb29rID0gbnVsbDtcbnZhciB3b3JrSW5Qcm9ncmVzc0hvb2sgPSBudWxsOyAvLyBXaGV0aGVyIGFuIHVwZGF0ZSB3YXMgc2NoZWR1bGVkIGF0IGFueSBwb2ludCBkdXJpbmcgdGhlIHJlbmRlciBwaGFzZS4gVGhpc1xuLy8gZG9lcyBub3QgZ2V0IHJlc2V0IGlmIHdlIGRvIGFub3RoZXIgcmVuZGVyIHBhc3M7IG9ubHkgd2hlbiB3ZSdyZSBjb21wbGV0ZWx5XG4vLyBmaW5pc2hlZCBldmFsdWF0aW5nIHRoaXMgY29tcG9uZW50LiBUaGlzIGlzIGFuIG9wdGltaXphdGlvbiBzbyB3ZSBrbm93XG4vLyB3aGV0aGVyIHdlIG5lZWQgdG8gY2xlYXIgcmVuZGVyIHBoYXNlIHVwZGF0ZXMgYWZ0ZXIgYSB0aHJvdy5cblxudmFyIGRpZFNjaGVkdWxlUmVuZGVyUGhhc2VVcGRhdGUgPSBmYWxzZTsgLy8gV2hlcmUgYW4gdXBkYXRlIHdhcyBzY2hlZHVsZWQgb25seSBkdXJpbmcgdGhlIGN1cnJlbnQgcmVuZGVyIHBhc3MuIFRoaXNcbi8vIGdldHMgcmVzZXQgYWZ0ZXIgZWFjaCBhdHRlbXB0LlxuLy8gVE9ETzogTWF5YmUgdGhlcmUncyBzb21lIHdheSB0byBjb25zb2xpZGF0ZSB0aGlzIHdpdGhcbi8vIGBkaWRTY2hlZHVsZVJlbmRlclBoYXNlVXBkYXRlYC4gT3Igd2l0aCBgbnVtYmVyT2ZSZVJlbmRlcnNgLlxuXG52YXIgZGlkU2NoZWR1bGVSZW5kZXJQaGFzZVVwZGF0ZUR1cmluZ1RoaXNQYXNzID0gZmFsc2U7XG52YXIgUkVfUkVOREVSX0xJTUlUID0gMjU7IC8vIEluIERFViwgdGhpcyBpcyB0aGUgbmFtZSBvZiB0aGUgY3VycmVudGx5IGV4ZWN1dGluZyBwcmltaXRpdmUgaG9va1xuXG52YXIgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBudWxsOyAvLyBJbiBERVYsIHRoaXMgbGlzdCBlbnN1cmVzIHRoYXQgaG9va3MgYXJlIGNhbGxlZCBpbiB0aGUgc2FtZSBvcmRlciBiZXR3ZWVuIHJlbmRlcnMuXG4vLyBUaGUgbGlzdCBzdG9yZXMgdGhlIG9yZGVyIG9mIGhvb2tzIHVzZWQgZHVyaW5nIHRoZSBpbml0aWFsIHJlbmRlciAobW91bnQpLlxuLy8gU3Vic2VxdWVudCByZW5kZXJzICh1cGRhdGVzKSByZWZlcmVuY2UgdGhpcyBsaXN0LlxuXG52YXIgaG9va1R5cGVzRGV2ID0gbnVsbDtcbnZhciBob29rVHlwZXNVcGRhdGVJbmRleERldiA9IC0xOyAvLyBJbiBERVYsIHRoaXMgdHJhY2tzIHdoZXRoZXIgY3VycmVudGx5IHJlbmRlcmluZyBjb21wb25lbnQgbmVlZHMgdG8gaWdub3JlXG4vLyB0aGUgZGVwZW5kZW5jaWVzIGZvciBIb29rcyB0aGF0IG5lZWQgdGhlbSAoZS5nLiB1c2VFZmZlY3Qgb3IgdXNlTWVtbykuXG4vLyBXaGVuIHRydWUsIHN1Y2ggSG9va3Mgd2lsbCBhbHdheXMgYmUgXCJyZW1vdW50ZWRcIi4gT25seSB1c2VkIGR1cmluZyBob3QgcmVsb2FkLlxuXG52YXIgaWdub3JlUHJldmlvdXNEZXBlbmRlbmNpZXMgPSBmYWxzZTtcblxuZnVuY3Rpb24gbW91bnRIb29rVHlwZXNEZXYoKSB7XG4gIHtcbiAgICB2YXIgaG9va05hbWUgPSBjdXJyZW50SG9va05hbWVJbkRldjtcblxuICAgIGlmIChob29rVHlwZXNEZXYgPT09IG51bGwpIHtcbiAgICAgIGhvb2tUeXBlc0RldiA9IFtob29rTmFtZV07XG4gICAgfSBlbHNlIHtcbiAgICAgIGhvb2tUeXBlc0Rldi5wdXNoKGhvb2tOYW1lKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gdXBkYXRlSG9va1R5cGVzRGV2KCkge1xuICB7XG4gICAgdmFyIGhvb2tOYW1lID0gY3VycmVudEhvb2tOYW1lSW5EZXY7XG5cbiAgICBpZiAoaG9va1R5cGVzRGV2ICE9PSBudWxsKSB7XG4gICAgICBob29rVHlwZXNVcGRhdGVJbmRleERldisrO1xuXG4gICAgICBpZiAoaG9va1R5cGVzRGV2W2hvb2tUeXBlc1VwZGF0ZUluZGV4RGV2XSAhPT0gaG9va05hbWUpIHtcbiAgICAgICAgd2Fybk9uSG9va01pc21hdGNoSW5EZXYoaG9va05hbWUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjaGVja0RlcHNBcmVBcnJheURldihkZXBzKSB7XG4gIHtcbiAgICBpZiAoZGVwcyAhPT0gdW5kZWZpbmVkICYmIGRlcHMgIT09IG51bGwgJiYgIUFycmF5LmlzQXJyYXkoZGVwcykpIHtcbiAgICAgIC8vIFZlcmlmeSBkZXBzLCBidXQgb25seSBvbiBtb3VudCB0byBhdm9pZCBleHRyYSBjaGVja3MuXG4gICAgICAvLyBJdCdzIHVubGlrZWx5IHRoZWlyIHR5cGUgd291bGQgY2hhbmdlIGFzIHVzdWFsbHkgeW91IGRlZmluZSB0aGVtIGlubGluZS5cbiAgICAgIGVycm9yKCclcyByZWNlaXZlZCBhIGZpbmFsIGFyZ3VtZW50IHRoYXQgaXMgbm90IGFuIGFycmF5IChpbnN0ZWFkLCByZWNlaXZlZCBgJXNgKS4gV2hlbiAnICsgJ3NwZWNpZmllZCwgdGhlIGZpbmFsIGFyZ3VtZW50IG11c3QgYmUgYW4gYXJyYXkuJywgY3VycmVudEhvb2tOYW1lSW5EZXYsIHR5cGVvZiBkZXBzKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gd2Fybk9uSG9va01pc21hdGNoSW5EZXYoY3VycmVudEhvb2tOYW1lKSB7XG4gIHtcbiAgICB2YXIgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWUoY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMS50eXBlKTtcblxuICAgIGlmICghZGlkV2FybkFib3V0TWlzbWF0Y2hlZEhvb2tzRm9yQ29tcG9uZW50Lmhhcyhjb21wb25lbnROYW1lKSkge1xuICAgICAgZGlkV2FybkFib3V0TWlzbWF0Y2hlZEhvb2tzRm9yQ29tcG9uZW50LmFkZChjb21wb25lbnROYW1lKTtcblxuICAgICAgaWYgKGhvb2tUeXBlc0RldiAhPT0gbnVsbCkge1xuICAgICAgICB2YXIgdGFibGUgPSAnJztcbiAgICAgICAgdmFyIHNlY29uZENvbHVtblN0YXJ0ID0gMzA7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPD0gaG9va1R5cGVzVXBkYXRlSW5kZXhEZXY7IGkrKykge1xuICAgICAgICAgIHZhciBvbGRIb29rTmFtZSA9IGhvb2tUeXBlc0RldltpXTtcbiAgICAgICAgICB2YXIgbmV3SG9va05hbWUgPSBpID09PSBob29rVHlwZXNVcGRhdGVJbmRleERldiA/IGN1cnJlbnRIb29rTmFtZSA6IG9sZEhvb2tOYW1lO1xuICAgICAgICAgIHZhciByb3cgPSBpICsgMSArIFwiLiBcIiArIG9sZEhvb2tOYW1lOyAvLyBFeHRyYSBzcGFjZSBzbyBzZWNvbmQgY29sdW1uIGxpbmVzIHVwXG4gICAgICAgICAgLy8gbG9sIEAgSUUgbm90IHN1cHBvcnRpbmcgU3RyaW5nI3JlcGVhdFxuXG4gICAgICAgICAgd2hpbGUgKHJvdy5sZW5ndGggPCBzZWNvbmRDb2x1bW5TdGFydCkge1xuICAgICAgICAgICAgcm93ICs9ICcgJztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByb3cgKz0gbmV3SG9va05hbWUgKyAnXFxuJztcbiAgICAgICAgICB0YWJsZSArPSByb3c7XG4gICAgICAgIH1cblxuICAgICAgICBlcnJvcignUmVhY3QgaGFzIGRldGVjdGVkIGEgY2hhbmdlIGluIHRoZSBvcmRlciBvZiBIb29rcyBjYWxsZWQgYnkgJXMuICcgKyAnVGhpcyB3aWxsIGxlYWQgdG8gYnVncyBhbmQgZXJyb3JzIGlmIG5vdCBmaXhlZC4gJyArICdGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVhZCB0aGUgUnVsZXMgb2YgSG9va3M6IGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9ydWxlcy1vZi1ob29rc1xcblxcbicgKyAnICAgUHJldmlvdXMgcmVuZGVyICAgICAgICAgICAgTmV4dCByZW5kZXJcXG4nICsgJyAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcbicgKyAnJXMnICsgJyAgIF5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXlxcbicsIGNvbXBvbmVudE5hbWUsIHRhYmxlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gdGhyb3dJbnZhbGlkSG9va0Vycm9yKCkge1xuICB7XG4gICAge1xuICAgICAgdGhyb3cgRXJyb3IoIFwiSW52YWxpZCBob29rIGNhbGwuIEhvb2tzIGNhbiBvbmx5IGJlIGNhbGxlZCBpbnNpZGUgb2YgdGhlIGJvZHkgb2YgYSBmdW5jdGlvbiBjb21wb25lbnQuIFRoaXMgY291bGQgaGFwcGVuIGZvciBvbmUgb2YgdGhlIGZvbGxvd2luZyByZWFzb25zOlxcbjEuIFlvdSBtaWdodCBoYXZlIG1pc21hdGNoaW5nIHZlcnNpb25zIG9mIFJlYWN0IGFuZCB0aGUgcmVuZGVyZXIgKHN1Y2ggYXMgUmVhY3QgRE9NKVxcbjIuIFlvdSBtaWdodCBiZSBicmVha2luZyB0aGUgUnVsZXMgb2YgSG9va3NcXG4zLiBZb3UgbWlnaHQgaGF2ZSBtb3JlIHRoYW4gb25lIGNvcHkgb2YgUmVhY3QgaW4gdGhlIHNhbWUgYXBwXFxuU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9pbnZhbGlkLWhvb2stY2FsbCBmb3IgdGlwcyBhYm91dCBob3cgdG8gZGVidWcgYW5kIGZpeCB0aGlzIHByb2JsZW0uXCIgKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gYXJlSG9va0lucHV0c0VxdWFsKG5leHREZXBzLCBwcmV2RGVwcykge1xuICB7XG4gICAgaWYgKGlnbm9yZVByZXZpb3VzRGVwZW5kZW5jaWVzKSB7XG4gICAgICAvLyBPbmx5IHRydWUgd2hlbiB0aGlzIGNvbXBvbmVudCBpcyBiZWluZyBob3QgcmVsb2FkZWQuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgaWYgKHByZXZEZXBzID09PSBudWxsKSB7XG4gICAge1xuICAgICAgZXJyb3IoJyVzIHJlY2VpdmVkIGEgZmluYWwgYXJndW1lbnQgZHVyaW5nIHRoaXMgcmVuZGVyLCBidXQgbm90IGR1cmluZyAnICsgJ3RoZSBwcmV2aW91cyByZW5kZXIuIEV2ZW4gdGhvdWdoIHRoZSBmaW5hbCBhcmd1bWVudCBpcyBvcHRpb25hbCwgJyArICdpdHMgdHlwZSBjYW5ub3QgY2hhbmdlIGJldHdlZW4gcmVuZGVycy4nLCBjdXJyZW50SG9va05hbWVJbkRldik7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAge1xuICAgIC8vIERvbid0IGJvdGhlciBjb21wYXJpbmcgbGVuZ3RocyBpbiBwcm9kIGJlY2F1c2UgdGhlc2UgYXJyYXlzIHNob3VsZCBiZVxuICAgIC8vIHBhc3NlZCBpbmxpbmUuXG4gICAgaWYgKG5leHREZXBzLmxlbmd0aCAhPT0gcHJldkRlcHMubGVuZ3RoKSB7XG4gICAgICBlcnJvcignVGhlIGZpbmFsIGFyZ3VtZW50IHBhc3NlZCB0byAlcyBjaGFuZ2VkIHNpemUgYmV0d2VlbiByZW5kZXJzLiBUaGUgJyArICdvcmRlciBhbmQgc2l6ZSBvZiB0aGlzIGFycmF5IG11c3QgcmVtYWluIGNvbnN0YW50LlxcblxcbicgKyAnUHJldmlvdXM6ICVzXFxuJyArICdJbmNvbWluZzogJXMnLCBjdXJyZW50SG9va05hbWVJbkRldiwgXCJbXCIgKyBwcmV2RGVwcy5qb2luKCcsICcpICsgXCJdXCIsIFwiW1wiICsgbmV4dERlcHMuam9pbignLCAnKSArIFwiXVwiKTtcbiAgICB9XG4gIH1cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHByZXZEZXBzLmxlbmd0aCAmJiBpIDwgbmV4dERlcHMubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAob2JqZWN0SXMobmV4dERlcHNbaV0sIHByZXZEZXBzW2ldKSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIHJlbmRlcldpdGhIb29rcyhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgQ29tcG9uZW50LCBwcm9wcywgc2Vjb25kQXJnLCBuZXh0UmVuZGVyTGFuZXMpIHtcbiAgcmVuZGVyTGFuZXMgPSBuZXh0UmVuZGVyTGFuZXM7XG4gIGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEgPSB3b3JrSW5Qcm9ncmVzcztcblxuICB7XG4gICAgaG9va1R5cGVzRGV2ID0gY3VycmVudCAhPT0gbnVsbCA/IGN1cnJlbnQuX2RlYnVnSG9va1R5cGVzIDogbnVsbDtcbiAgICBob29rVHlwZXNVcGRhdGVJbmRleERldiA9IC0xOyAvLyBVc2VkIGZvciBob3QgcmVsb2FkaW5nOlxuXG4gICAgaWdub3JlUHJldmlvdXNEZXBlbmRlbmNpZXMgPSBjdXJyZW50ICE9PSBudWxsICYmIGN1cnJlbnQudHlwZSAhPT0gd29ya0luUHJvZ3Jlc3MudHlwZTtcbiAgfVxuXG4gIHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSBudWxsO1xuICB3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZSA9IG51bGw7XG4gIHdvcmtJblByb2dyZXNzLmxhbmVzID0gTm9MYW5lczsgLy8gVGhlIGZvbGxvd2luZyBzaG91bGQgaGF2ZSBhbHJlYWR5IGJlZW4gcmVzZXRcbiAgLy8gY3VycmVudEhvb2sgPSBudWxsO1xuICAvLyB3b3JrSW5Qcm9ncmVzc0hvb2sgPSBudWxsO1xuICAvLyBkaWRTY2hlZHVsZVJlbmRlclBoYXNlVXBkYXRlID0gZmFsc2U7XG4gIC8vIFRPRE8gV2FybiBpZiBubyBob29rcyBhcmUgdXNlZCBhdCBhbGwgZHVyaW5nIG1vdW50LCB0aGVuIHNvbWUgYXJlIHVzZWQgZHVyaW5nIHVwZGF0ZS5cbiAgLy8gQ3VycmVudGx5IHdlIHdpbGwgaWRlbnRpZnkgdGhlIHVwZGF0ZSByZW5kZXIgYXMgYSBtb3VudCBiZWNhdXNlIG1lbW9pemVkU3RhdGUgPT09IG51bGwuXG4gIC8vIFRoaXMgaXMgdHJpY2t5IGJlY2F1c2UgaXQncyB2YWxpZCBmb3IgY2VydGFpbiB0eXBlcyBvZiBjb21wb25lbnRzIChlLmcuIFJlYWN0LmxhenkpXG4gIC8vIFVzaW5nIG1lbW9pemVkU3RhdGUgdG8gZGlmZmVyZW50aWF0ZSBiZXR3ZWVuIG1vdW50L3VwZGF0ZSBvbmx5IHdvcmtzIGlmIGF0IGxlYXN0IG9uZSBzdGF0ZWZ1bCBob29rIGlzIHVzZWQuXG4gIC8vIE5vbi1zdGF0ZWZ1bCBob29rcyAoZS5nLiBjb250ZXh0KSBkb24ndCBnZXQgYWRkZWQgdG8gbWVtb2l6ZWRTdGF0ZSxcbiAgLy8gc28gbWVtb2l6ZWRTdGF0ZSB3b3VsZCBiZSBudWxsIGR1cmluZyB1cGRhdGVzIGFuZCBtb3VudHMuXG5cbiAge1xuICAgIGlmIChjdXJyZW50ICE9PSBudWxsICYmIGN1cnJlbnQubWVtb2l6ZWRTdGF0ZSAhPT0gbnVsbCkge1xuICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQgPSBIb29rc0Rpc3BhdGNoZXJPblVwZGF0ZUluREVWO1xuICAgIH0gZWxzZSBpZiAoaG9va1R5cGVzRGV2ICE9PSBudWxsKSB7XG4gICAgICAvLyBUaGlzIGRpc3BhdGNoZXIgaGFuZGxlcyBhbiBlZGdlIGNhc2Ugd2hlcmUgYSBjb21wb25lbnQgaXMgdXBkYXRpbmcsXG4gICAgICAvLyBidXQgbm8gc3RhdGVmdWwgaG9va3MgaGF2ZSBiZWVuIHVzZWQuXG4gICAgICAvLyBXZSB3YW50IHRvIG1hdGNoIHRoZSBwcm9kdWN0aW9uIGNvZGUgYmVoYXZpb3IgKHdoaWNoIHdpbGwgdXNlIEhvb2tzRGlzcGF0Y2hlck9uTW91bnQpLFxuICAgICAgLy8gYnV0IHdpdGggdGhlIGV4dHJhIERFViB2YWxpZGF0aW9uIHRvIGVuc3VyZSBob29rcyBvcmRlcmluZyBoYXNuJ3QgY2hhbmdlZC5cbiAgICAgIC8vIFRoaXMgZGlzcGF0Y2hlciBkb2VzIHRoYXQuXG4gICAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudCA9IEhvb2tzRGlzcGF0Y2hlck9uTW91bnRXaXRoSG9va1R5cGVzSW5ERVY7XG4gICAgfSBlbHNlIHtcbiAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50ID0gSG9va3NEaXNwYXRjaGVyT25Nb3VudEluREVWO1xuICAgIH1cbiAgfVxuXG4gIHZhciBjaGlsZHJlbiA9IENvbXBvbmVudChwcm9wcywgc2Vjb25kQXJnKTsgLy8gQ2hlY2sgaWYgdGhlcmUgd2FzIGEgcmVuZGVyIHBoYXNlIHVwZGF0ZVxuXG4gIGlmIChkaWRTY2hlZHVsZVJlbmRlclBoYXNlVXBkYXRlRHVyaW5nVGhpc1Bhc3MpIHtcbiAgICAvLyBLZWVwIHJlbmRlcmluZyBpbiBhIGxvb3AgZm9yIGFzIGxvbmcgYXMgcmVuZGVyIHBoYXNlIHVwZGF0ZXMgY29udGludWUgdG9cbiAgICAvLyBiZSBzY2hlZHVsZWQuIFVzZSBhIGNvdW50ZXIgdG8gcHJldmVudCBpbmZpbml0ZSBsb29wcy5cbiAgICB2YXIgbnVtYmVyT2ZSZVJlbmRlcnMgPSAwO1xuXG4gICAgZG8ge1xuICAgICAgZGlkU2NoZWR1bGVSZW5kZXJQaGFzZVVwZGF0ZUR1cmluZ1RoaXNQYXNzID0gZmFsc2U7XG5cbiAgICAgIGlmICghKG51bWJlck9mUmVSZW5kZXJzIDwgUkVfUkVOREVSX0xJTUlUKSkge1xuICAgICAgICB7XG4gICAgICAgICAgdGhyb3cgRXJyb3IoIFwiVG9vIG1hbnkgcmUtcmVuZGVycy4gUmVhY3QgbGltaXRzIHRoZSBudW1iZXIgb2YgcmVuZGVycyB0byBwcmV2ZW50IGFuIGluZmluaXRlIGxvb3AuXCIgKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBudW1iZXJPZlJlUmVuZGVycyArPSAxO1xuXG4gICAgICB7XG4gICAgICAgIC8vIEV2ZW4gd2hlbiBob3QgcmVsb2FkaW5nLCBhbGxvdyBkZXBlbmRlbmNpZXMgdG8gc3RhYmlsaXplXG4gICAgICAgIC8vIGFmdGVyIGZpcnN0IHJlbmRlciB0byBwcmV2ZW50IGluZmluaXRlIHJlbmRlciBwaGFzZSB1cGRhdGVzLlxuICAgICAgICBpZ25vcmVQcmV2aW91c0RlcGVuZGVuY2llcyA9IGZhbHNlO1xuICAgICAgfSAvLyBTdGFydCBvdmVyIGZyb20gdGhlIGJlZ2lubmluZyBvZiB0aGUgbGlzdFxuXG5cbiAgICAgIGN1cnJlbnRIb29rID0gbnVsbDtcbiAgICAgIHdvcmtJblByb2dyZXNzSG9vayA9IG51bGw7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZSA9IG51bGw7XG5cbiAgICAgIHtcbiAgICAgICAgLy8gQWxzbyB2YWxpZGF0ZSBob29rIG9yZGVyIGZvciBjYXNjYWRpbmcgdXBkYXRlcy5cbiAgICAgICAgaG9va1R5cGVzVXBkYXRlSW5kZXhEZXYgPSAtMTtcbiAgICAgIH1cblxuICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQgPSAgSG9va3NEaXNwYXRjaGVyT25SZXJlbmRlckluREVWIDtcbiAgICAgIGNoaWxkcmVuID0gQ29tcG9uZW50KHByb3BzLCBzZWNvbmRBcmcpO1xuICAgIH0gd2hpbGUgKGRpZFNjaGVkdWxlUmVuZGVyUGhhc2VVcGRhdGVEdXJpbmdUaGlzUGFzcyk7XG4gIH0gLy8gV2UgY2FuIGFzc3VtZSB0aGUgcHJldmlvdXMgZGlzcGF0Y2hlciBpcyBhbHdheXMgdGhpcyBvbmUsIHNpbmNlIHdlIHNldCBpdFxuICAvLyBhdCB0aGUgYmVnaW5uaW5nIG9mIHRoZSByZW5kZXIgcGhhc2UgYW5kIHRoZXJlJ3Mgbm8gcmUtZW50cmFuY3kuXG5cblxuICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudCA9IENvbnRleHRPbmx5RGlzcGF0Y2hlcjtcblxuICB7XG4gICAgd29ya0luUHJvZ3Jlc3MuX2RlYnVnSG9va1R5cGVzID0gaG9va1R5cGVzRGV2O1xuICB9IC8vIFRoaXMgY2hlY2sgdXNlcyBjdXJyZW50SG9vayBzbyB0aGF0IGl0IHdvcmtzIHRoZSBzYW1lIGluIERFViBhbmQgcHJvZCBidW5kbGVzLlxuICAvLyBob29rVHlwZXNEZXYgY291bGQgY2F0Y2ggbW9yZSBjYXNlcyAoZS5nLiBjb250ZXh0KSBidXQgb25seSBpbiBERVYgYnVuZGxlcy5cblxuXG4gIHZhciBkaWRSZW5kZXJUb29GZXdIb29rcyA9IGN1cnJlbnRIb29rICE9PSBudWxsICYmIGN1cnJlbnRIb29rLm5leHQgIT09IG51bGw7XG4gIHJlbmRlckxhbmVzID0gTm9MYW5lcztcbiAgY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMSA9IG51bGw7XG4gIGN1cnJlbnRIb29rID0gbnVsbDtcbiAgd29ya0luUHJvZ3Jlc3NIb29rID0gbnVsbDtcblxuICB7XG4gICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBudWxsO1xuICAgIGhvb2tUeXBlc0RldiA9IG51bGw7XG4gICAgaG9va1R5cGVzVXBkYXRlSW5kZXhEZXYgPSAtMTtcbiAgfVxuXG4gIGRpZFNjaGVkdWxlUmVuZGVyUGhhc2VVcGRhdGUgPSBmYWxzZTtcblxuICBpZiAoISFkaWRSZW5kZXJUb29GZXdIb29rcykge1xuICAgIHtcbiAgICAgIHRocm93IEVycm9yKCBcIlJlbmRlcmVkIGZld2VyIGhvb2tzIHRoYW4gZXhwZWN0ZWQuIFRoaXMgbWF5IGJlIGNhdXNlZCBieSBhbiBhY2NpZGVudGFsIGVhcmx5IHJldHVybiBzdGF0ZW1lbnQuXCIgKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gY2hpbGRyZW47XG59XG5mdW5jdGlvbiBiYWlsb3V0SG9va3MoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIGxhbmVzKSB7XG4gIHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlID0gY3VycmVudC51cGRhdGVRdWV1ZTtcbiAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgJj0gfihQYXNzaXZlIHwgVXBkYXRlKTtcbiAgY3VycmVudC5sYW5lcyA9IHJlbW92ZUxhbmVzKGN1cnJlbnQubGFuZXMsIGxhbmVzKTtcbn1cbmZ1bmN0aW9uIHJlc2V0SG9va3NBZnRlclRocm93KCkge1xuICAvLyBXZSBjYW4gYXNzdW1lIHRoZSBwcmV2aW91cyBkaXNwYXRjaGVyIGlzIGFsd2F5cyB0aGlzIG9uZSwgc2luY2Ugd2Ugc2V0IGl0XG4gIC8vIGF0IHRoZSBiZWdpbm5pbmcgb2YgdGhlIHJlbmRlciBwaGFzZSBhbmQgdGhlcmUncyBubyByZS1lbnRyYW5jeS5cbiAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQgPSBDb250ZXh0T25seURpc3BhdGNoZXI7XG5cbiAgaWYgKGRpZFNjaGVkdWxlUmVuZGVyUGhhc2VVcGRhdGUpIHtcbiAgICAvLyBUaGVyZSB3ZXJlIHJlbmRlciBwaGFzZSB1cGRhdGVzLiBUaGVzZSBhcmUgb25seSB2YWxpZCBmb3IgdGhpcyByZW5kZXJcbiAgICAvLyBwaGFzZSwgd2hpY2ggd2UgYXJlIG5vdyBhYm9ydGluZy4gUmVtb3ZlIHRoZSB1cGRhdGVzIGZyb20gdGhlIHF1ZXVlcyBzb1xuICAgIC8vIHRoZXkgZG8gbm90IHBlcnNpc3QgdG8gdGhlIG5leHQgcmVuZGVyLiBEbyBub3QgcmVtb3ZlIHVwZGF0ZXMgZnJvbSBob29rc1xuICAgIC8vIHRoYXQgd2VyZW4ndCBwcm9jZXNzZWQuXG4gICAgLy9cbiAgICAvLyBPbmx5IHJlc2V0IHRoZSB1cGRhdGVzIGZyb20gdGhlIHF1ZXVlIGlmIGl0IGhhcyBhIGNsb25lLiBJZiBpdCBkb2VzXG4gICAgLy8gbm90IGhhdmUgYSBjbG9uZSwgdGhhdCBtZWFucyBpdCB3YXNuJ3QgcHJvY2Vzc2VkLCBhbmQgdGhlIHVwZGF0ZXMgd2VyZVxuICAgIC8vIHNjaGVkdWxlZCBiZWZvcmUgd2UgZW50ZXJlZCB0aGUgcmVuZGVyIHBoYXNlLlxuICAgIHZhciBob29rID0gY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMS5tZW1vaXplZFN0YXRlO1xuXG4gICAgd2hpbGUgKGhvb2sgIT09IG51bGwpIHtcbiAgICAgIHZhciBxdWV1ZSA9IGhvb2sucXVldWU7XG5cbiAgICAgIGlmIChxdWV1ZSAhPT0gbnVsbCkge1xuICAgICAgICBxdWV1ZS5wZW5kaW5nID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgaG9vayA9IGhvb2submV4dDtcbiAgICB9XG5cbiAgICBkaWRTY2hlZHVsZVJlbmRlclBoYXNlVXBkYXRlID0gZmFsc2U7XG4gIH1cblxuICByZW5kZXJMYW5lcyA9IE5vTGFuZXM7XG4gIGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEgPSBudWxsO1xuICBjdXJyZW50SG9vayA9IG51bGw7XG4gIHdvcmtJblByb2dyZXNzSG9vayA9IG51bGw7XG5cbiAge1xuICAgIGhvb2tUeXBlc0RldiA9IG51bGw7XG4gICAgaG9va1R5cGVzVXBkYXRlSW5kZXhEZXYgPSAtMTtcbiAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IG51bGw7XG4gICAgaXNVcGRhdGluZ09wYXF1ZVZhbHVlSW5SZW5kZXJQaGFzZSA9IGZhbHNlO1xuICB9XG5cbiAgZGlkU2NoZWR1bGVSZW5kZXJQaGFzZVVwZGF0ZUR1cmluZ1RoaXNQYXNzID0gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIG1vdW50V29ya0luUHJvZ3Jlc3NIb29rKCkge1xuICB2YXIgaG9vayA9IHtcbiAgICBtZW1vaXplZFN0YXRlOiBudWxsLFxuICAgIGJhc2VTdGF0ZTogbnVsbCxcbiAgICBiYXNlUXVldWU6IG51bGwsXG4gICAgcXVldWU6IG51bGwsXG4gICAgbmV4dDogbnVsbFxuICB9O1xuXG4gIGlmICh3b3JrSW5Qcm9ncmVzc0hvb2sgPT09IG51bGwpIHtcbiAgICAvLyBUaGlzIGlzIHRoZSBmaXJzdCBob29rIGluIHRoZSBsaXN0XG4gICAgY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMS5tZW1vaXplZFN0YXRlID0gd29ya0luUHJvZ3Jlc3NIb29rID0gaG9vaztcbiAgfSBlbHNlIHtcbiAgICAvLyBBcHBlbmQgdG8gdGhlIGVuZCBvZiB0aGUgbGlzdFxuICAgIHdvcmtJblByb2dyZXNzSG9vayA9IHdvcmtJblByb2dyZXNzSG9vay5uZXh0ID0gaG9vaztcbiAgfVxuXG4gIHJldHVybiB3b3JrSW5Qcm9ncmVzc0hvb2s7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZVdvcmtJblByb2dyZXNzSG9vaygpIHtcbiAgLy8gVGhpcyBmdW5jdGlvbiBpcyB1c2VkIGJvdGggZm9yIHVwZGF0ZXMgYW5kIGZvciByZS1yZW5kZXJzIHRyaWdnZXJlZCBieSBhXG4gIC8vIHJlbmRlciBwaGFzZSB1cGRhdGUuIEl0IGFzc3VtZXMgdGhlcmUgaXMgZWl0aGVyIGEgY3VycmVudCBob29rIHdlIGNhblxuICAvLyBjbG9uZSwgb3IgYSB3b3JrLWluLXByb2dyZXNzIGhvb2sgZnJvbSBhIHByZXZpb3VzIHJlbmRlciBwYXNzIHRoYXQgd2UgY2FuXG4gIC8vIHVzZSBhcyBhIGJhc2UuIFdoZW4gd2UgcmVhY2ggdGhlIGVuZCBvZiB0aGUgYmFzZSBsaXN0LCB3ZSBtdXN0IHN3aXRjaCB0b1xuICAvLyB0aGUgZGlzcGF0Y2hlciB1c2VkIGZvciBtb3VudHMuXG4gIHZhciBuZXh0Q3VycmVudEhvb2s7XG5cbiAgaWYgKGN1cnJlbnRIb29rID09PSBudWxsKSB7XG4gICAgdmFyIGN1cnJlbnQgPSBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxLmFsdGVybmF0ZTtcblxuICAgIGlmIChjdXJyZW50ICE9PSBudWxsKSB7XG4gICAgICBuZXh0Q3VycmVudEhvb2sgPSBjdXJyZW50Lm1lbW9pemVkU3RhdGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5leHRDdXJyZW50SG9vayA9IG51bGw7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIG5leHRDdXJyZW50SG9vayA9IGN1cnJlbnRIb29rLm5leHQ7XG4gIH1cblxuICB2YXIgbmV4dFdvcmtJblByb2dyZXNzSG9vaztcblxuICBpZiAod29ya0luUHJvZ3Jlc3NIb29rID09PSBudWxsKSB7XG4gICAgbmV4dFdvcmtJblByb2dyZXNzSG9vayA9IGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEubWVtb2l6ZWRTdGF0ZTtcbiAgfSBlbHNlIHtcbiAgICBuZXh0V29ya0luUHJvZ3Jlc3NIb29rID0gd29ya0luUHJvZ3Jlc3NIb29rLm5leHQ7XG4gIH1cblxuICBpZiAobmV4dFdvcmtJblByb2dyZXNzSG9vayAhPT0gbnVsbCkge1xuICAgIC8vIFRoZXJlJ3MgYWxyZWFkeSBhIHdvcmstaW4tcHJvZ3Jlc3MuIFJldXNlIGl0LlxuICAgIHdvcmtJblByb2dyZXNzSG9vayA9IG5leHRXb3JrSW5Qcm9ncmVzc0hvb2s7XG4gICAgbmV4dFdvcmtJblByb2dyZXNzSG9vayA9IHdvcmtJblByb2dyZXNzSG9vay5uZXh0O1xuICAgIGN1cnJlbnRIb29rID0gbmV4dEN1cnJlbnRIb29rO1xuICB9IGVsc2Uge1xuICAgIC8vIENsb25lIGZyb20gdGhlIGN1cnJlbnQgaG9vay5cbiAgICBpZiAoIShuZXh0Q3VycmVudEhvb2sgIT09IG51bGwpKSB7XG4gICAgICB7XG4gICAgICAgIHRocm93IEVycm9yKCBcIlJlbmRlcmVkIG1vcmUgaG9va3MgdGhhbiBkdXJpbmcgdGhlIHByZXZpb3VzIHJlbmRlci5cIiApO1xuICAgICAgfVxuICAgIH1cblxuICAgIGN1cnJlbnRIb29rID0gbmV4dEN1cnJlbnRIb29rO1xuICAgIHZhciBuZXdIb29rID0ge1xuICAgICAgbWVtb2l6ZWRTdGF0ZTogY3VycmVudEhvb2subWVtb2l6ZWRTdGF0ZSxcbiAgICAgIGJhc2VTdGF0ZTogY3VycmVudEhvb2suYmFzZVN0YXRlLFxuICAgICAgYmFzZVF1ZXVlOiBjdXJyZW50SG9vay5iYXNlUXVldWUsXG4gICAgICBxdWV1ZTogY3VycmVudEhvb2sucXVldWUsXG4gICAgICBuZXh0OiBudWxsXG4gICAgfTtcblxuICAgIGlmICh3b3JrSW5Qcm9ncmVzc0hvb2sgPT09IG51bGwpIHtcbiAgICAgIC8vIFRoaXMgaXMgdGhlIGZpcnN0IGhvb2sgaW4gdGhlIGxpc3QuXG4gICAgICBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxLm1lbW9pemVkU3RhdGUgPSB3b3JrSW5Qcm9ncmVzc0hvb2sgPSBuZXdIb29rO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBBcHBlbmQgdG8gdGhlIGVuZCBvZiB0aGUgbGlzdC5cbiAgICAgIHdvcmtJblByb2dyZXNzSG9vayA9IHdvcmtJblByb2dyZXNzSG9vay5uZXh0ID0gbmV3SG9vaztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gd29ya0luUHJvZ3Jlc3NIb29rO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVGdW5jdGlvbkNvbXBvbmVudFVwZGF0ZVF1ZXVlKCkge1xuICByZXR1cm4ge1xuICAgIGxhc3RFZmZlY3Q6IG51bGxcbiAgfTtcbn1cblxuZnVuY3Rpb24gYmFzaWNTdGF0ZVJlZHVjZXIoc3RhdGUsIGFjdGlvbikge1xuICAvLyAkRmxvd0ZpeE1lOiBGbG93IGRvZXNuJ3QgbGlrZSBtaXhlZCB0eXBlc1xuICByZXR1cm4gdHlwZW9mIGFjdGlvbiA9PT0gJ2Z1bmN0aW9uJyA/IGFjdGlvbihzdGF0ZSkgOiBhY3Rpb247XG59XG5cbmZ1bmN0aW9uIG1vdW50UmVkdWNlcihyZWR1Y2VyLCBpbml0aWFsQXJnLCBpbml0KSB7XG4gIHZhciBob29rID0gbW91bnRXb3JrSW5Qcm9ncmVzc0hvb2soKTtcbiAgdmFyIGluaXRpYWxTdGF0ZTtcblxuICBpZiAoaW5pdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgaW5pdGlhbFN0YXRlID0gaW5pdChpbml0aWFsQXJnKTtcbiAgfSBlbHNlIHtcbiAgICBpbml0aWFsU3RhdGUgPSBpbml0aWFsQXJnO1xuICB9XG5cbiAgaG9vay5tZW1vaXplZFN0YXRlID0gaG9vay5iYXNlU3RhdGUgPSBpbml0aWFsU3RhdGU7XG4gIHZhciBxdWV1ZSA9IGhvb2sucXVldWUgPSB7XG4gICAgcGVuZGluZzogbnVsbCxcbiAgICBkaXNwYXRjaDogbnVsbCxcbiAgICBsYXN0UmVuZGVyZWRSZWR1Y2VyOiByZWR1Y2VyLFxuICAgIGxhc3RSZW5kZXJlZFN0YXRlOiBpbml0aWFsU3RhdGVcbiAgfTtcbiAgdmFyIGRpc3BhdGNoID0gcXVldWUuZGlzcGF0Y2ggPSBkaXNwYXRjaEFjdGlvbi5iaW5kKG51bGwsIGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEsIHF1ZXVlKTtcbiAgcmV0dXJuIFtob29rLm1lbW9pemVkU3RhdGUsIGRpc3BhdGNoXTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlUmVkdWNlcihyZWR1Y2VyLCBpbml0aWFsQXJnLCBpbml0KSB7XG4gIHZhciBob29rID0gdXBkYXRlV29ya0luUHJvZ3Jlc3NIb29rKCk7XG4gIHZhciBxdWV1ZSA9IGhvb2sucXVldWU7XG5cbiAgaWYgKCEocXVldWUgIT09IG51bGwpKSB7XG4gICAge1xuICAgICAgdGhyb3cgRXJyb3IoIFwiU2hvdWxkIGhhdmUgYSBxdWV1ZS4gVGhpcyBpcyBsaWtlbHkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiICk7XG4gICAgfVxuICB9XG5cbiAgcXVldWUubGFzdFJlbmRlcmVkUmVkdWNlciA9IHJlZHVjZXI7XG4gIHZhciBjdXJyZW50ID0gY3VycmVudEhvb2s7IC8vIFRoZSBsYXN0IHJlYmFzZSB1cGRhdGUgdGhhdCBpcyBOT1QgcGFydCBvZiB0aGUgYmFzZSBzdGF0ZS5cblxuICB2YXIgYmFzZVF1ZXVlID0gY3VycmVudC5iYXNlUXVldWU7IC8vIFRoZSBsYXN0IHBlbmRpbmcgdXBkYXRlIHRoYXQgaGFzbid0IGJlZW4gcHJvY2Vzc2VkIHlldC5cblxuICB2YXIgcGVuZGluZ1F1ZXVlID0gcXVldWUucGVuZGluZztcblxuICBpZiAocGVuZGluZ1F1ZXVlICE9PSBudWxsKSB7XG4gICAgLy8gV2UgaGF2ZSBuZXcgdXBkYXRlcyB0aGF0IGhhdmVuJ3QgYmVlbiBwcm9jZXNzZWQgeWV0LlxuICAgIC8vIFdlJ2xsIGFkZCB0aGVtIHRvIHRoZSBiYXNlIHF1ZXVlLlxuICAgIGlmIChiYXNlUXVldWUgIT09IG51bGwpIHtcbiAgICAgIC8vIE1lcmdlIHRoZSBwZW5kaW5nIHF1ZXVlIGFuZCB0aGUgYmFzZSBxdWV1ZS5cbiAgICAgIHZhciBiYXNlRmlyc3QgPSBiYXNlUXVldWUubmV4dDtcbiAgICAgIHZhciBwZW5kaW5nRmlyc3QgPSBwZW5kaW5nUXVldWUubmV4dDtcbiAgICAgIGJhc2VRdWV1ZS5uZXh0ID0gcGVuZGluZ0ZpcnN0O1xuICAgICAgcGVuZGluZ1F1ZXVlLm5leHQgPSBiYXNlRmlyc3Q7XG4gICAgfVxuXG4gICAge1xuICAgICAgaWYgKGN1cnJlbnQuYmFzZVF1ZXVlICE9PSBiYXNlUXVldWUpIHtcbiAgICAgICAgLy8gSW50ZXJuYWwgaW52YXJpYW50IHRoYXQgc2hvdWxkIG5ldmVyIGhhcHBlbiwgYnV0IGZlYXNpYmx5IGNvdWxkIGluXG4gICAgICAgIC8vIHRoZSBmdXR1cmUgaWYgd2UgaW1wbGVtZW50IHJlc3VtaW5nLCBvciBzb21lIGZvcm0gb2YgdGhhdC5cbiAgICAgICAgZXJyb3IoJ0ludGVybmFsIGVycm9yOiBFeHBlY3RlZCB3b3JrLWluLXByb2dyZXNzIHF1ZXVlIHRvIGJlIGEgY2xvbmUuICcgKyAnVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC4nKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjdXJyZW50LmJhc2VRdWV1ZSA9IGJhc2VRdWV1ZSA9IHBlbmRpbmdRdWV1ZTtcbiAgICBxdWV1ZS5wZW5kaW5nID0gbnVsbDtcbiAgfVxuXG4gIGlmIChiYXNlUXVldWUgIT09IG51bGwpIHtcbiAgICAvLyBXZSBoYXZlIGEgcXVldWUgdG8gcHJvY2Vzcy5cbiAgICB2YXIgZmlyc3QgPSBiYXNlUXVldWUubmV4dDtcbiAgICB2YXIgbmV3U3RhdGUgPSBjdXJyZW50LmJhc2VTdGF0ZTtcbiAgICB2YXIgbmV3QmFzZVN0YXRlID0gbnVsbDtcbiAgICB2YXIgbmV3QmFzZVF1ZXVlRmlyc3QgPSBudWxsO1xuICAgIHZhciBuZXdCYXNlUXVldWVMYXN0ID0gbnVsbDtcbiAgICB2YXIgdXBkYXRlID0gZmlyc3Q7XG5cbiAgICBkbyB7XG4gICAgICB2YXIgdXBkYXRlTGFuZSA9IHVwZGF0ZS5sYW5lO1xuXG4gICAgICBpZiAoIWlzU3Vic2V0T2ZMYW5lcyhyZW5kZXJMYW5lcywgdXBkYXRlTGFuZSkpIHtcbiAgICAgICAgLy8gUHJpb3JpdHkgaXMgaW5zdWZmaWNpZW50LiBTa2lwIHRoaXMgdXBkYXRlLiBJZiB0aGlzIGlzIHRoZSBmaXJzdFxuICAgICAgICAvLyBza2lwcGVkIHVwZGF0ZSwgdGhlIHByZXZpb3VzIHVwZGF0ZS9zdGF0ZSBpcyB0aGUgbmV3IGJhc2VcbiAgICAgICAgLy8gdXBkYXRlL3N0YXRlLlxuICAgICAgICB2YXIgY2xvbmUgPSB7XG4gICAgICAgICAgbGFuZTogdXBkYXRlTGFuZSxcbiAgICAgICAgICBhY3Rpb246IHVwZGF0ZS5hY3Rpb24sXG4gICAgICAgICAgZWFnZXJSZWR1Y2VyOiB1cGRhdGUuZWFnZXJSZWR1Y2VyLFxuICAgICAgICAgIGVhZ2VyU3RhdGU6IHVwZGF0ZS5lYWdlclN0YXRlLFxuICAgICAgICAgIG5leHQ6IG51bGxcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAobmV3QmFzZVF1ZXVlTGFzdCA9PT0gbnVsbCkge1xuICAgICAgICAgIG5ld0Jhc2VRdWV1ZUZpcnN0ID0gbmV3QmFzZVF1ZXVlTGFzdCA9IGNsb25lO1xuICAgICAgICAgIG5ld0Jhc2VTdGF0ZSA9IG5ld1N0YXRlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5ld0Jhc2VRdWV1ZUxhc3QgPSBuZXdCYXNlUXVldWVMYXN0Lm5leHQgPSBjbG9uZTtcbiAgICAgICAgfSAvLyBVcGRhdGUgdGhlIHJlbWFpbmluZyBwcmlvcml0eSBpbiB0aGUgcXVldWUuXG4gICAgICAgIC8vIFRPRE86IERvbid0IG5lZWQgdG8gYWNjdW11bGF0ZSB0aGlzLiBJbnN0ZWFkLCB3ZSBjYW4gcmVtb3ZlXG4gICAgICAgIC8vIHJlbmRlckxhbmVzIGZyb20gdGhlIG9yaWdpbmFsIGxhbmVzLlxuXG5cbiAgICAgICAgY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMS5sYW5lcyA9IG1lcmdlTGFuZXMoY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMS5sYW5lcywgdXBkYXRlTGFuZSk7XG4gICAgICAgIG1hcmtTa2lwcGVkVXBkYXRlTGFuZXModXBkYXRlTGFuZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBUaGlzIHVwZGF0ZSBkb2VzIGhhdmUgc3VmZmljaWVudCBwcmlvcml0eS5cbiAgICAgICAgaWYgKG5ld0Jhc2VRdWV1ZUxhc3QgIT09IG51bGwpIHtcbiAgICAgICAgICB2YXIgX2Nsb25lID0ge1xuICAgICAgICAgICAgLy8gVGhpcyB1cGRhdGUgaXMgZ29pbmcgdG8gYmUgY29tbWl0dGVkIHNvIHdlIG5ldmVyIHdhbnQgdW5jb21taXRcbiAgICAgICAgICAgIC8vIGl0LiBVc2luZyBOb0xhbmUgd29ya3MgYmVjYXVzZSAwIGlzIGEgc3Vic2V0IG9mIGFsbCBiaXRtYXNrcywgc29cbiAgICAgICAgICAgIC8vIHRoaXMgd2lsbCBuZXZlciBiZSBza2lwcGVkIGJ5IHRoZSBjaGVjayBhYm92ZS5cbiAgICAgICAgICAgIGxhbmU6IE5vTGFuZSxcbiAgICAgICAgICAgIGFjdGlvbjogdXBkYXRlLmFjdGlvbixcbiAgICAgICAgICAgIGVhZ2VyUmVkdWNlcjogdXBkYXRlLmVhZ2VyUmVkdWNlcixcbiAgICAgICAgICAgIGVhZ2VyU3RhdGU6IHVwZGF0ZS5lYWdlclN0YXRlLFxuICAgICAgICAgICAgbmV4dDogbnVsbFxuICAgICAgICAgIH07XG4gICAgICAgICAgbmV3QmFzZVF1ZXVlTGFzdCA9IG5ld0Jhc2VRdWV1ZUxhc3QubmV4dCA9IF9jbG9uZTtcbiAgICAgICAgfSAvLyBQcm9jZXNzIHRoaXMgdXBkYXRlLlxuXG5cbiAgICAgICAgaWYgKHVwZGF0ZS5lYWdlclJlZHVjZXIgPT09IHJlZHVjZXIpIHtcbiAgICAgICAgICAvLyBJZiB0aGlzIHVwZGF0ZSB3YXMgcHJvY2Vzc2VkIGVhZ2VybHksIGFuZCBpdHMgcmVkdWNlciBtYXRjaGVzIHRoZVxuICAgICAgICAgIC8vIGN1cnJlbnQgcmVkdWNlciwgd2UgY2FuIHVzZSB0aGUgZWFnZXJseSBjb21wdXRlZCBzdGF0ZS5cbiAgICAgICAgICBuZXdTdGF0ZSA9IHVwZGF0ZS5lYWdlclN0YXRlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBhY3Rpb24gPSB1cGRhdGUuYWN0aW9uO1xuICAgICAgICAgIG5ld1N0YXRlID0gcmVkdWNlcihuZXdTdGF0ZSwgYWN0aW9uKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB1cGRhdGUgPSB1cGRhdGUubmV4dDtcbiAgICB9IHdoaWxlICh1cGRhdGUgIT09IG51bGwgJiYgdXBkYXRlICE9PSBmaXJzdCk7XG5cbiAgICBpZiAobmV3QmFzZVF1ZXVlTGFzdCA9PT0gbnVsbCkge1xuICAgICAgbmV3QmFzZVN0YXRlID0gbmV3U3RhdGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5ld0Jhc2VRdWV1ZUxhc3QubmV4dCA9IG5ld0Jhc2VRdWV1ZUZpcnN0O1xuICAgIH0gLy8gTWFyayB0aGF0IHRoZSBmaWJlciBwZXJmb3JtZWQgd29yaywgYnV0IG9ubHkgaWYgdGhlIG5ldyBzdGF0ZSBpc1xuICAgIC8vIGRpZmZlcmVudCBmcm9tIHRoZSBjdXJyZW50IHN0YXRlLlxuXG5cbiAgICBpZiAoIW9iamVjdElzKG5ld1N0YXRlLCBob29rLm1lbW9pemVkU3RhdGUpKSB7XG4gICAgICBtYXJrV29ya0luUHJvZ3Jlc3NSZWNlaXZlZFVwZGF0ZSgpO1xuICAgIH1cblxuICAgIGhvb2subWVtb2l6ZWRTdGF0ZSA9IG5ld1N0YXRlO1xuICAgIGhvb2suYmFzZVN0YXRlID0gbmV3QmFzZVN0YXRlO1xuICAgIGhvb2suYmFzZVF1ZXVlID0gbmV3QmFzZVF1ZXVlTGFzdDtcbiAgICBxdWV1ZS5sYXN0UmVuZGVyZWRTdGF0ZSA9IG5ld1N0YXRlO1xuICB9XG5cbiAgdmFyIGRpc3BhdGNoID0gcXVldWUuZGlzcGF0Y2g7XG4gIHJldHVybiBbaG9vay5tZW1vaXplZFN0YXRlLCBkaXNwYXRjaF07XG59XG5cbmZ1bmN0aW9uIHJlcmVuZGVyUmVkdWNlcihyZWR1Y2VyLCBpbml0aWFsQXJnLCBpbml0KSB7XG4gIHZhciBob29rID0gdXBkYXRlV29ya0luUHJvZ3Jlc3NIb29rKCk7XG4gIHZhciBxdWV1ZSA9IGhvb2sucXVldWU7XG5cbiAgaWYgKCEocXVldWUgIT09IG51bGwpKSB7XG4gICAge1xuICAgICAgdGhyb3cgRXJyb3IoIFwiU2hvdWxkIGhhdmUgYSBxdWV1ZS4gVGhpcyBpcyBsaWtlbHkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiICk7XG4gICAgfVxuICB9XG5cbiAgcXVldWUubGFzdFJlbmRlcmVkUmVkdWNlciA9IHJlZHVjZXI7IC8vIFRoaXMgaXMgYSByZS1yZW5kZXIuIEFwcGx5IHRoZSBuZXcgcmVuZGVyIHBoYXNlIHVwZGF0ZXMgdG8gdGhlIHByZXZpb3VzXG4gIC8vIHdvcmstaW4tcHJvZ3Jlc3MgaG9vay5cblxuICB2YXIgZGlzcGF0Y2ggPSBxdWV1ZS5kaXNwYXRjaDtcbiAgdmFyIGxhc3RSZW5kZXJQaGFzZVVwZGF0ZSA9IHF1ZXVlLnBlbmRpbmc7XG4gIHZhciBuZXdTdGF0ZSA9IGhvb2subWVtb2l6ZWRTdGF0ZTtcblxuICBpZiAobGFzdFJlbmRlclBoYXNlVXBkYXRlICE9PSBudWxsKSB7XG4gICAgLy8gVGhlIHF1ZXVlIGRvZXNuJ3QgcGVyc2lzdCBwYXN0IHRoaXMgcmVuZGVyIHBhc3MuXG4gICAgcXVldWUucGVuZGluZyA9IG51bGw7XG4gICAgdmFyIGZpcnN0UmVuZGVyUGhhc2VVcGRhdGUgPSBsYXN0UmVuZGVyUGhhc2VVcGRhdGUubmV4dDtcbiAgICB2YXIgdXBkYXRlID0gZmlyc3RSZW5kZXJQaGFzZVVwZGF0ZTtcblxuICAgIGRvIHtcbiAgICAgIC8vIFByb2Nlc3MgdGhpcyByZW5kZXIgcGhhc2UgdXBkYXRlLiBXZSBkb24ndCBoYXZlIHRvIGNoZWNrIHRoZVxuICAgICAgLy8gcHJpb3JpdHkgYmVjYXVzZSBpdCB3aWxsIGFsd2F5cyBiZSB0aGUgc2FtZSBhcyB0aGUgY3VycmVudFxuICAgICAgLy8gcmVuZGVyJ3MuXG4gICAgICB2YXIgYWN0aW9uID0gdXBkYXRlLmFjdGlvbjtcbiAgICAgIG5ld1N0YXRlID0gcmVkdWNlcihuZXdTdGF0ZSwgYWN0aW9uKTtcbiAgICAgIHVwZGF0ZSA9IHVwZGF0ZS5uZXh0O1xuICAgIH0gd2hpbGUgKHVwZGF0ZSAhPT0gZmlyc3RSZW5kZXJQaGFzZVVwZGF0ZSk7IC8vIE1hcmsgdGhhdCB0aGUgZmliZXIgcGVyZm9ybWVkIHdvcmssIGJ1dCBvbmx5IGlmIHRoZSBuZXcgc3RhdGUgaXNcbiAgICAvLyBkaWZmZXJlbnQgZnJvbSB0aGUgY3VycmVudCBzdGF0ZS5cblxuXG4gICAgaWYgKCFvYmplY3RJcyhuZXdTdGF0ZSwgaG9vay5tZW1vaXplZFN0YXRlKSkge1xuICAgICAgbWFya1dvcmtJblByb2dyZXNzUmVjZWl2ZWRVcGRhdGUoKTtcbiAgICB9XG5cbiAgICBob29rLm1lbW9pemVkU3RhdGUgPSBuZXdTdGF0ZTsgLy8gRG9uJ3QgcGVyc2lzdCB0aGUgc3RhdGUgYWNjdW11bGF0ZWQgZnJvbSB0aGUgcmVuZGVyIHBoYXNlIHVwZGF0ZXMgdG9cbiAgICAvLyB0aGUgYmFzZSBzdGF0ZSB1bmxlc3MgdGhlIHF1ZXVlIGlzIGVtcHR5LlxuICAgIC8vIFRPRE86IE5vdCBzdXJlIGlmIHRoaXMgaXMgdGhlIGRlc2lyZWQgc2VtYW50aWNzLCBidXQgaXQncyB3aGF0IHdlXG4gICAgLy8gZG8gZm9yIGdEU0ZQLiBJIGNhbid0IHJlbWVtYmVyIHdoeS5cblxuICAgIGlmIChob29rLmJhc2VRdWV1ZSA9PT0gbnVsbCkge1xuICAgICAgaG9vay5iYXNlU3RhdGUgPSBuZXdTdGF0ZTtcbiAgICB9XG5cbiAgICBxdWV1ZS5sYXN0UmVuZGVyZWRTdGF0ZSA9IG5ld1N0YXRlO1xuICB9XG5cbiAgcmV0dXJuIFtuZXdTdGF0ZSwgZGlzcGF0Y2hdO1xufVxuXG5mdW5jdGlvbiByZWFkRnJvbVVuc3ViY3JpYmVkTXV0YWJsZVNvdXJjZShyb290LCBzb3VyY2UsIGdldFNuYXBzaG90KSB7XG4gIHtcbiAgICB3YXJuQWJvdXRNdWx0aXBsZVJlbmRlcmVyc0RFVihzb3VyY2UpO1xuICB9XG5cbiAgdmFyIGdldFZlcnNpb24gPSBzb3VyY2UuX2dldFZlcnNpb247XG4gIHZhciB2ZXJzaW9uID0gZ2V0VmVyc2lvbihzb3VyY2UuX3NvdXJjZSk7IC8vIElzIGl0IHNhZmUgZm9yIHRoaXMgY29tcG9uZW50IHRvIHJlYWQgZnJvbSB0aGlzIHNvdXJjZSBkdXJpbmcgdGhlIGN1cnJlbnQgcmVuZGVyP1xuXG4gIHZhciBpc1NhZmVUb1JlYWRGcm9tU291cmNlID0gZmFsc2U7IC8vIENoZWNrIHRoZSB2ZXJzaW9uIGZpcnN0LlxuICAvLyBJZiB0aGlzIHJlbmRlciBoYXMgYWxyZWFkeSBiZWVuIHN0YXJ0ZWQgd2l0aCBhIHNwZWNpZmljIHZlcnNpb24sXG4gIC8vIHdlIGNhbiB1c2UgaXQgYWxvbmUgdG8gZGV0ZXJtaW5lIGlmIHdlIGNhbiBzYWZlbHkgcmVhZCBmcm9tIHRoZSBzb3VyY2UuXG5cbiAgdmFyIGN1cnJlbnRSZW5kZXJWZXJzaW9uID0gZ2V0V29ya0luUHJvZ3Jlc3NWZXJzaW9uKHNvdXJjZSk7XG5cbiAgaWYgKGN1cnJlbnRSZW5kZXJWZXJzaW9uICE9PSBudWxsKSB7XG4gICAgLy8gSXQncyBzYWZlIHRvIHJlYWQgaWYgdGhlIHN0b3JlIGhhc24ndCBiZWVuIG11dGF0ZWQgc2luY2UgdGhlIGxhc3QgdGltZVxuICAgIC8vIHdlIHJlYWQgc29tZXRoaW5nLlxuICAgIGlzU2FmZVRvUmVhZEZyb21Tb3VyY2UgPSBjdXJyZW50UmVuZGVyVmVyc2lvbiA9PT0gdmVyc2lvbjtcbiAgfSBlbHNlIHtcbiAgICAvLyBJZiB0aGVyZSdzIG5vIHZlcnNpb24sIHRoZW4gdGhpcyBpcyB0aGUgZmlyc3QgdGltZSB3ZSd2ZSByZWFkIGZyb20gdGhlXG4gICAgLy8gc291cmNlIGR1cmluZyB0aGUgY3VycmVudCByZW5kZXIgcGFzcywgc28gd2UgbmVlZCB0byBkbyBhIGJpdCBtb3JlIHdvcmsuXG4gICAgLy8gV2hhdCB3ZSBuZWVkIHRvIGRldGVybWluZSBpcyBpZiB0aGVyZSBhcmUgYW55IGhvb2tzIHRoYXQgYWxyZWFkeVxuICAgIC8vIHN1YnNjcmliZWQgdG8gdGhlIHNvdXJjZSwgYW5kIGlmIHNvLCB3aGV0aGVyIHRoZXJlIGFyZSBhbnkgcGVuZGluZ1xuICAgIC8vIG11dGF0aW9ucyB0aGF0IGhhdmVuJ3QgYmVlbiBzeW5jaHJvbml6ZWQgeWV0LlxuICAgIC8vXG4gICAgLy8gSWYgdGhlcmUgYXJlIG5vIHBlbmRpbmcgbXV0YXRpb25zLCB0aGVuIGByb290Lm11dGFibGVSZWFkTGFuZXNgIHdpbGwgYmVcbiAgICAvLyBlbXB0eSwgYW5kIHdlIGtub3cgd2UgY2FuIHNhZmVseSByZWFkLlxuICAgIC8vXG4gICAgLy8gSWYgdGhlcmUgKmFyZSogcGVuZGluZyBtdXRhdGlvbnMsIHdlIG1heSBzdGlsbCBiZSBhYmxlIHRvIHNhZmVseSByZWFkXG4gICAgLy8gaWYgdGhlIGN1cnJlbnRseSByZW5kZXJpbmcgbGFuZXMgYXJlIGluY2x1c2l2ZSBvZiB0aGUgcGVuZGluZyBtdXRhdGlvblxuICAgIC8vIGxhbmVzLCBzaW5jZSB0aGF0IGd1YXJhbnRlZXMgdGhhdCB0aGUgdmFsdWUgd2UncmUgYWJvdXQgdG8gcmVhZCBmcm9tXG4gICAgLy8gdGhlIHNvdXJjZSBpcyBjb25zaXN0ZW50IHdpdGggdGhlIHZhbHVlcyB0aGF0IHdlIHJlYWQgZHVyaW5nIHRoZSBtb3N0XG4gICAgLy8gcmVjZW50IG11dGF0aW9uLlxuICAgIGlzU2FmZVRvUmVhZEZyb21Tb3VyY2UgPSBpc1N1YnNldE9mTGFuZXMocmVuZGVyTGFuZXMsIHJvb3QubXV0YWJsZVJlYWRMYW5lcyk7XG5cbiAgICBpZiAoaXNTYWZlVG9SZWFkRnJvbVNvdXJjZSkge1xuICAgICAgLy8gSWYgaXQncyBzYWZlIHRvIHJlYWQgZnJvbSB0aGlzIHNvdXJjZSBkdXJpbmcgdGhlIGN1cnJlbnQgcmVuZGVyLFxuICAgICAgLy8gc3RvcmUgdGhlIHZlcnNpb24gaW4gY2FzZSBvdGhlciBjb21wb25lbnRzIHJlYWQgZnJvbSBpdC5cbiAgICAgIC8vIEEgY2hhbmdlZCB2ZXJzaW9uIG51bWJlciB3aWxsIGxldCB0aG9zZSBjb21wb25lbnRzIGtub3cgdG8gdGhyb3cgYW5kIHJlc3RhcnQgdGhlIHJlbmRlci5cbiAgICAgIHNldFdvcmtJblByb2dyZXNzVmVyc2lvbihzb3VyY2UsIHZlcnNpb24pO1xuICAgIH1cbiAgfVxuXG4gIGlmIChpc1NhZmVUb1JlYWRGcm9tU291cmNlKSB7XG4gICAgdmFyIHNuYXBzaG90ID0gZ2V0U25hcHNob3Qoc291cmNlLl9zb3VyY2UpO1xuXG4gICAge1xuICAgICAgaWYgKHR5cGVvZiBzbmFwc2hvdCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBlcnJvcignTXV0YWJsZSBzb3VyY2Ugc2hvdWxkIG5vdCByZXR1cm4gYSBmdW5jdGlvbiBhcyB0aGUgc25hcHNob3QgdmFsdWUuICcgKyAnRnVuY3Rpb25zIG1heSBjbG9zZSBvdmVyIG11dGFibGUgdmFsdWVzIGFuZCBjYXVzZSB0ZWFyaW5nLicpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBzbmFwc2hvdDtcbiAgfSBlbHNlIHtcbiAgICAvLyBUaGlzIGhhbmRsZXMgdGhlIHNwZWNpYWwgY2FzZSBvZiBhIG11dGFibGUgc291cmNlIGJlaW5nIHNoYXJlZCBiZXR3ZWVuIHJlbmRlcmVycy5cbiAgICAvLyBJbiB0aGF0IGNhc2UsIGlmIHRoZSBzb3VyY2UgaXMgbXV0YXRlZCBiZXR3ZWVuIHRoZSBmaXJzdCBhbmQgc2Vjb25kIHJlbmRlcmVyLFxuICAgIC8vIFRoZSBzZWNvbmQgcmVuZGVyZXIgZG9uJ3Qga25vdyB0aGF0IGl0IG5lZWRzIHRvIHJlc2V0IHRoZSBXSVAgdmVyc2lvbiBkdXJpbmcgdW53aW5kLFxuICAgIC8vIChiZWNhdXNlIHRoZSBob29rIG9ubHkgbWFya3Mgc291cmNlcyBhcyBkaXJ0eSBpZiBpdCdzIHdyaXR0ZW4gdG8gdGhlaXIgV0lQIHZlcnNpb24pLlxuICAgIC8vIFRoYXQgd291bGQgY2F1c2UgdGhpcyB0ZWFyIGNoZWNrIHRvIHRocm93IGFnYWluIGFuZCBldmVudHVhbGx5IGJlIHZpc2libGUgdG8gdGhlIHVzZXIuXG4gICAgLy8gV2UgY2FuIGF2b2lkIHRoaXMgaW5maW5pdGUgbG9vcCBieSBleHBsaWNpdGx5IG1hcmtpbmcgdGhlIHNvdXJjZSBhcyBkaXJ0eS5cbiAgICAvL1xuICAgIC8vIFRoaXMgY2FuIGxlYWQgdG8gdGVhcmluZyBpbiB0aGUgZmlyc3QgcmVuZGVyZXIgd2hlbiBpdCByZXN1bWVzLFxuICAgIC8vIGJ1dCB0aGVyZSdzIG5vdGhpbmcgd2UgY2FuIGRvIGFib3V0IHRoYXQgKHNob3J0IG9mIHRocm93aW5nIGhlcmUgYW5kIHJlZnVzaW5nIHRvIGNvbnRpbnVlIHRoZSByZW5kZXIpLlxuICAgIG1hcmtTb3VyY2VBc0RpcnR5KHNvdXJjZSk7XG5cbiAgICB7XG4gICAgICB7XG4gICAgICAgIHRocm93IEVycm9yKCBcIkNhbm5vdCByZWFkIGZyb20gbXV0YWJsZSBzb3VyY2UgZHVyaW5nIHRoZSBjdXJyZW50IHJlbmRlciB3aXRob3V0IHRlYXJpbmcuIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiICk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHVzZU11dGFibGVTb3VyY2UoaG9vaywgc291cmNlLCBnZXRTbmFwc2hvdCwgc3Vic2NyaWJlKSB7XG4gIHZhciByb290ID0gZ2V0V29ya0luUHJvZ3Jlc3NSb290KCk7XG5cbiAgaWYgKCEocm9vdCAhPT0gbnVsbCkpIHtcbiAgICB7XG4gICAgICB0aHJvdyBFcnJvciggXCJFeHBlY3RlZCBhIHdvcmstaW4tcHJvZ3Jlc3Mgcm9vdC4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCIgKTtcbiAgICB9XG4gIH1cblxuICB2YXIgZ2V0VmVyc2lvbiA9IHNvdXJjZS5fZ2V0VmVyc2lvbjtcbiAgdmFyIHZlcnNpb24gPSBnZXRWZXJzaW9uKHNvdXJjZS5fc291cmNlKTtcbiAgdmFyIGRpc3BhdGNoZXIgPSBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudDsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHByZWZlci1jb25zdFxuXG4gIHZhciBfZGlzcGF0Y2hlciR1c2VTdGF0ZSA9IGRpc3BhdGNoZXIudXNlU3RhdGUoZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiByZWFkRnJvbVVuc3ViY3JpYmVkTXV0YWJsZVNvdXJjZShyb290LCBzb3VyY2UsIGdldFNuYXBzaG90KTtcbiAgfSksXG4gICAgICBjdXJyZW50U25hcHNob3QgPSBfZGlzcGF0Y2hlciR1c2VTdGF0ZVswXSxcbiAgICAgIHNldFNuYXBzaG90ID0gX2Rpc3BhdGNoZXIkdXNlU3RhdGVbMV07XG5cbiAgdmFyIHNuYXBzaG90ID0gY3VycmVudFNuYXBzaG90OyAvLyBHcmFiIGEgaGFuZGxlIHRvIHRoZSBzdGF0ZSBob29rIGFzIHdlbGwuXG4gIC8vIFdlIHVzZSBpdCB0byBjbGVhciB0aGUgcGVuZGluZyB1cGRhdGUgcXVldWUgaWYgd2UgaGF2ZSBhIG5ldyBzb3VyY2UuXG5cbiAgdmFyIHN0YXRlSG9vayA9IHdvcmtJblByb2dyZXNzSG9vaztcbiAgdmFyIG1lbW9pemVkU3RhdGUgPSBob29rLm1lbW9pemVkU3RhdGU7XG4gIHZhciByZWZzID0gbWVtb2l6ZWRTdGF0ZS5yZWZzO1xuICB2YXIgcHJldkdldFNuYXBzaG90ID0gcmVmcy5nZXRTbmFwc2hvdDtcbiAgdmFyIHByZXZTb3VyY2UgPSBtZW1vaXplZFN0YXRlLnNvdXJjZTtcbiAgdmFyIHByZXZTdWJzY3JpYmUgPSBtZW1vaXplZFN0YXRlLnN1YnNjcmliZTtcbiAgdmFyIGZpYmVyID0gY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMTtcbiAgaG9vay5tZW1vaXplZFN0YXRlID0ge1xuICAgIHJlZnM6IHJlZnMsXG4gICAgc291cmNlOiBzb3VyY2UsXG4gICAgc3Vic2NyaWJlOiBzdWJzY3JpYmVcbiAgfTsgLy8gU3luYyB0aGUgdmFsdWVzIG5lZWRlZCBieSBvdXIgc3Vic2NyaXB0aW9uIGhhbmRsZXIgYWZ0ZXIgZWFjaCBjb21taXQuXG5cbiAgZGlzcGF0Y2hlci51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgIHJlZnMuZ2V0U25hcHNob3QgPSBnZXRTbmFwc2hvdDsgLy8gTm9ybWFsbHkgdGhlIGRpc3BhdGNoIGZ1bmN0aW9uIGZvciBhIHN0YXRlIGhvb2sgbmV2ZXIgY2hhbmdlcyxcbiAgICAvLyBidXQgdGhpcyBob29rIHJlY3JlYXRlcyB0aGUgcXVldWUgaW4gY2VydGFpbiBjYXNlcyAgdG8gYXZvaWQgdXBkYXRlcyBmcm9tIHN0YWxlIHNvdXJjZXMuXG4gICAgLy8gaGFuZGxlQ2hhbmdlKCkgYmVsb3cgbmVlZHMgdG8gcmVmZXJlbmNlIHRoZSBkaXNwYXRjaCBmdW5jdGlvbiB3aXRob3V0IHJlLXN1YnNjcmliaW5nLFxuICAgIC8vIHNvIHdlIHVzZSBhIHJlZiB0byBlbnN1cmUgdGhhdCBpdCBhbHdheXMgaGFzIHRoZSBsYXRlc3QgdmVyc2lvbi5cblxuICAgIHJlZnMuc2V0U25hcHNob3QgPSBzZXRTbmFwc2hvdDsgLy8gQ2hlY2sgZm9yIGEgcG9zc2libGUgY2hhbmdlIGJldHdlZW4gd2hlbiB3ZSBsYXN0IHJlbmRlcmVkIG5vdy5cblxuICAgIHZhciBtYXliZU5ld1ZlcnNpb24gPSBnZXRWZXJzaW9uKHNvdXJjZS5fc291cmNlKTtcblxuICAgIGlmICghb2JqZWN0SXModmVyc2lvbiwgbWF5YmVOZXdWZXJzaW9uKSkge1xuICAgICAgdmFyIG1heWJlTmV3U25hcHNob3QgPSBnZXRTbmFwc2hvdChzb3VyY2UuX3NvdXJjZSk7XG5cbiAgICAgIHtcbiAgICAgICAgaWYgKHR5cGVvZiBtYXliZU5ld1NuYXBzaG90ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgZXJyb3IoJ011dGFibGUgc291cmNlIHNob3VsZCBub3QgcmV0dXJuIGEgZnVuY3Rpb24gYXMgdGhlIHNuYXBzaG90IHZhbHVlLiAnICsgJ0Z1bmN0aW9ucyBtYXkgY2xvc2Ugb3ZlciBtdXRhYmxlIHZhbHVlcyBhbmQgY2F1c2UgdGVhcmluZy4nKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoIW9iamVjdElzKHNuYXBzaG90LCBtYXliZU5ld1NuYXBzaG90KSkge1xuICAgICAgICBzZXRTbmFwc2hvdChtYXliZU5ld1NuYXBzaG90KTtcbiAgICAgICAgdmFyIGxhbmUgPSByZXF1ZXN0VXBkYXRlTGFuZShmaWJlcik7XG4gICAgICAgIG1hcmtSb290TXV0YWJsZVJlYWQocm9vdCwgbGFuZSk7XG4gICAgICB9IC8vIElmIHRoZSBzb3VyY2UgbXV0YXRlZCBiZXR3ZWVuIHJlbmRlciBhbmQgbm93LFxuICAgICAgLy8gdGhlcmUgbWF5IGJlIHN0YXRlIHVwZGF0ZXMgYWxyZWFkeSBzY2hlZHVsZWQgZnJvbSB0aGUgb2xkIHNvdXJjZS5cbiAgICAgIC8vIEVudGFuZ2xlIHRoZSB1cGRhdGVzIHNvIHRoYXQgdGhleSByZW5kZXIgaW4gdGhlIHNhbWUgYmF0Y2guXG5cblxuICAgICAgbWFya1Jvb3RFbnRhbmdsZWQocm9vdCwgcm9vdC5tdXRhYmxlUmVhZExhbmVzKTtcbiAgICB9XG4gIH0sIFtnZXRTbmFwc2hvdCwgc291cmNlLCBzdWJzY3JpYmVdKTsgLy8gSWYgd2UgZ290IGEgbmV3IHNvdXJjZSBvciBzdWJzY3JpYmUgZnVuY3Rpb24sIHJlLXN1YnNjcmliZSBpbiBhIHBhc3NpdmUgZWZmZWN0LlxuXG4gIGRpc3BhdGNoZXIudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgaGFuZGxlQ2hhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGxhdGVzdEdldFNuYXBzaG90ID0gcmVmcy5nZXRTbmFwc2hvdDtcbiAgICAgIHZhciBsYXRlc3RTZXRTbmFwc2hvdCA9IHJlZnMuc2V0U25hcHNob3Q7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGxhdGVzdFNldFNuYXBzaG90KGxhdGVzdEdldFNuYXBzaG90KHNvdXJjZS5fc291cmNlKSk7IC8vIFJlY29yZCBhIHBlbmRpbmcgbXV0YWJsZSBzb3VyY2UgdXBkYXRlIHdpdGggdGhlIHNhbWUgZXhwaXJhdGlvbiB0aW1lLlxuXG4gICAgICAgIHZhciBsYW5lID0gcmVxdWVzdFVwZGF0ZUxhbmUoZmliZXIpO1xuICAgICAgICBtYXJrUm9vdE11dGFibGVSZWFkKHJvb3QsIGxhbmUpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgLy8gQSBzZWxlY3RvciBtaWdodCB0aHJvdyBhZnRlciBhIHNvdXJjZSBtdXRhdGlvbi5cbiAgICAgICAgLy8gZS5nLiBpdCBtaWdodCB0cnkgdG8gcmVhZCBmcm9tIGEgcGFydCBvZiB0aGUgc3RvcmUgdGhhdCBubyBsb25nZXIgZXhpc3RzLlxuICAgICAgICAvLyBJbiB0aGlzIGNhc2Ugd2Ugc2hvdWxkIHN0aWxsIHNjaGVkdWxlIGFuIHVwZGF0ZSB3aXRoIFJlYWN0LlxuICAgICAgICAvLyBXb3JzdCBjYXNlIHRoZSBzZWxlY3RvciB3aWxsIHRocm93IGFnYWluIGFuZCB0aGVuIGFuIGVycm9yIGJvdW5kYXJ5IHdpbGwgaGFuZGxlIGl0LlxuICAgICAgICBsYXRlc3RTZXRTbmFwc2hvdChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgdW5zdWJzY3JpYmUgPSBzdWJzY3JpYmUoc291cmNlLl9zb3VyY2UsIGhhbmRsZUNoYW5nZSk7XG5cbiAgICB7XG4gICAgICBpZiAodHlwZW9mIHVuc3Vic2NyaWJlICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGVycm9yKCdNdXRhYmxlIHNvdXJjZSBzdWJzY3JpYmUgZnVuY3Rpb24gbXVzdCByZXR1cm4gYW4gdW5zdWJzY3JpYmUgZnVuY3Rpb24uJyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHVuc3Vic2NyaWJlO1xuICB9LCBbc291cmNlLCBzdWJzY3JpYmVdKTsgLy8gSWYgYW55IG9mIHRoZSBpbnB1dHMgdG8gdXNlTXV0YWJsZVNvdXJjZSBjaGFuZ2UsIHJlYWRpbmcgaXMgcG90ZW50aWFsbHkgdW5zYWZlLlxuICAvL1xuICAvLyBJZiBlaXRoZXIgdGhlIHNvdXJjZSBvciB0aGUgc3Vic2NyaXB0aW9uIGhhdmUgY2hhbmdlZCB3ZSBjYW4ndCBjYW4ndCB0cnVzdCB0aGUgdXBkYXRlIHF1ZXVlLlxuICAvLyBNYXliZSB0aGUgc291cmNlIGNoYW5nZWQgaW4gYSB3YXkgdGhhdCB0aGUgb2xkIHN1YnNjcmlwdGlvbiBpZ25vcmVkIGJ1dCB0aGUgbmV3IG9uZSBkZXBlbmRzIG9uLlxuICAvL1xuICAvLyBJZiB0aGUgZ2V0U25hcHNob3QgZnVuY3Rpb24gY2hhbmdlZCwgd2UgYWxzbyBzaG91bGRuJ3QgcmVseSBvbiB0aGUgdXBkYXRlIHF1ZXVlLlxuICAvLyBJdCdzIHBvc3NpYmxlIHRoYXQgdGhlIHVuZGVybHlpbmcgc291cmNlIHdhcyBtdXRhdGVkIGJldHdlZW4gdGhlIHdoZW4gdGhlIGxhc3QgXCJjaGFuZ2VcIiBldmVudCBmaXJlZCxcbiAgLy8gYW5kIHdoZW4gdGhlIGN1cnJlbnQgcmVuZGVyICh3aXRoIHRoZSBuZXcgZ2V0U25hcHNob3QgZnVuY3Rpb24pIGlzIHByb2Nlc3NlZC5cbiAgLy9cbiAgLy8gSW4gYm90aCBjYXNlcywgd2UgbmVlZCB0byB0aHJvdyBhd2F5IHBlbmRpbmcgdXBkYXRlcyAoc2luY2UgdGhleSBhcmUgbm8gbG9uZ2VyIHJlbGV2YW50KVxuICAvLyBhbmQgdHJlYXQgcmVhZGluZyBmcm9tIHRoZSBzb3VyY2UgYXMgd2UgZG8gaW4gdGhlIG1vdW50IGNhc2UuXG5cbiAgaWYgKCFvYmplY3RJcyhwcmV2R2V0U25hcHNob3QsIGdldFNuYXBzaG90KSB8fCAhb2JqZWN0SXMocHJldlNvdXJjZSwgc291cmNlKSB8fCAhb2JqZWN0SXMocHJldlN1YnNjcmliZSwgc3Vic2NyaWJlKSkge1xuICAgIC8vIENyZWF0ZSBhIG5ldyBxdWV1ZSBhbmQgc2V0U3RhdGUgbWV0aG9kLFxuICAgIC8vIFNvIGlmIHRoZXJlIGFyZSBpbnRlcmxlYXZlZCB1cGRhdGVzLCB0aGV5IGdldCBwdXNoZWQgdG8gdGhlIG9sZGVyIHF1ZXVlLlxuICAgIC8vIFdoZW4gdGhpcyBiZWNvbWVzIGN1cnJlbnQsIHRoZSBwcmV2aW91cyBxdWV1ZSBhbmQgZGlzcGF0Y2ggbWV0aG9kIHdpbGwgYmUgZGlzY2FyZGVkLFxuICAgIC8vIGluY2x1ZGluZyBhbnkgaW50ZXJsZWF2aW5nIHVwZGF0ZXMgdGhhdCBvY2N1ci5cbiAgICB2YXIgbmV3UXVldWUgPSB7XG4gICAgICBwZW5kaW5nOiBudWxsLFxuICAgICAgZGlzcGF0Y2g6IG51bGwsXG4gICAgICBsYXN0UmVuZGVyZWRSZWR1Y2VyOiBiYXNpY1N0YXRlUmVkdWNlcixcbiAgICAgIGxhc3RSZW5kZXJlZFN0YXRlOiBzbmFwc2hvdFxuICAgIH07XG4gICAgbmV3UXVldWUuZGlzcGF0Y2ggPSBzZXRTbmFwc2hvdCA9IGRpc3BhdGNoQWN0aW9uLmJpbmQobnVsbCwgY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMSwgbmV3UXVldWUpO1xuICAgIHN0YXRlSG9vay5xdWV1ZSA9IG5ld1F1ZXVlO1xuICAgIHN0YXRlSG9vay5iYXNlUXVldWUgPSBudWxsO1xuICAgIHNuYXBzaG90ID0gcmVhZEZyb21VbnN1YmNyaWJlZE11dGFibGVTb3VyY2Uocm9vdCwgc291cmNlLCBnZXRTbmFwc2hvdCk7XG4gICAgc3RhdGVIb29rLm1lbW9pemVkU3RhdGUgPSBzdGF0ZUhvb2suYmFzZVN0YXRlID0gc25hcHNob3Q7XG4gIH1cblxuICByZXR1cm4gc25hcHNob3Q7XG59XG5cbmZ1bmN0aW9uIG1vdW50TXV0YWJsZVNvdXJjZShzb3VyY2UsIGdldFNuYXBzaG90LCBzdWJzY3JpYmUpIHtcbiAgdmFyIGhvb2sgPSBtb3VudFdvcmtJblByb2dyZXNzSG9vaygpO1xuICBob29rLm1lbW9pemVkU3RhdGUgPSB7XG4gICAgcmVmczoge1xuICAgICAgZ2V0U25hcHNob3Q6IGdldFNuYXBzaG90LFxuICAgICAgc2V0U25hcHNob3Q6IG51bGxcbiAgICB9LFxuICAgIHNvdXJjZTogc291cmNlLFxuICAgIHN1YnNjcmliZTogc3Vic2NyaWJlXG4gIH07XG4gIHJldHVybiB1c2VNdXRhYmxlU291cmNlKGhvb2ssIHNvdXJjZSwgZ2V0U25hcHNob3QsIHN1YnNjcmliZSk7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZU11dGFibGVTb3VyY2Uoc291cmNlLCBnZXRTbmFwc2hvdCwgc3Vic2NyaWJlKSB7XG4gIHZhciBob29rID0gdXBkYXRlV29ya0luUHJvZ3Jlc3NIb29rKCk7XG4gIHJldHVybiB1c2VNdXRhYmxlU291cmNlKGhvb2ssIHNvdXJjZSwgZ2V0U25hcHNob3QsIHN1YnNjcmliZSk7XG59XG5cbmZ1bmN0aW9uIG1vdW50U3RhdGUoaW5pdGlhbFN0YXRlKSB7XG4gIHZhciBob29rID0gbW91bnRXb3JrSW5Qcm9ncmVzc0hvb2soKTtcblxuICBpZiAodHlwZW9mIGluaXRpYWxTdGF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIC8vICRGbG93Rml4TWU6IEZsb3cgZG9lc24ndCBsaWtlIG1peGVkIHR5cGVzXG4gICAgaW5pdGlhbFN0YXRlID0gaW5pdGlhbFN0YXRlKCk7XG4gIH1cblxuICBob29rLm1lbW9pemVkU3RhdGUgPSBob29rLmJhc2VTdGF0ZSA9IGluaXRpYWxTdGF0ZTtcbiAgdmFyIHF1ZXVlID0gaG9vay5xdWV1ZSA9IHtcbiAgICBwZW5kaW5nOiBudWxsLFxuICAgIGRpc3BhdGNoOiBudWxsLFxuICAgIGxhc3RSZW5kZXJlZFJlZHVjZXI6IGJhc2ljU3RhdGVSZWR1Y2VyLFxuICAgIGxhc3RSZW5kZXJlZFN0YXRlOiBpbml0aWFsU3RhdGVcbiAgfTtcbiAgdmFyIGRpc3BhdGNoID0gcXVldWUuZGlzcGF0Y2ggPSBkaXNwYXRjaEFjdGlvbi5iaW5kKG51bGwsIGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEsIHF1ZXVlKTtcbiAgcmV0dXJuIFtob29rLm1lbW9pemVkU3RhdGUsIGRpc3BhdGNoXTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlU3RhdGUoaW5pdGlhbFN0YXRlKSB7XG4gIHJldHVybiB1cGRhdGVSZWR1Y2VyKGJhc2ljU3RhdGVSZWR1Y2VyKTtcbn1cblxuZnVuY3Rpb24gcmVyZW5kZXJTdGF0ZShpbml0aWFsU3RhdGUpIHtcbiAgcmV0dXJuIHJlcmVuZGVyUmVkdWNlcihiYXNpY1N0YXRlUmVkdWNlcik7XG59XG5cbmZ1bmN0aW9uIHB1c2hFZmZlY3QodGFnLCBjcmVhdGUsIGRlc3Ryb3ksIGRlcHMpIHtcbiAgdmFyIGVmZmVjdCA9IHtcbiAgICB0YWc6IHRhZyxcbiAgICBjcmVhdGU6IGNyZWF0ZSxcbiAgICBkZXN0cm95OiBkZXN0cm95LFxuICAgIGRlcHM6IGRlcHMsXG4gICAgLy8gQ2lyY3VsYXJcbiAgICBuZXh0OiBudWxsXG4gIH07XG4gIHZhciBjb21wb25lbnRVcGRhdGVRdWV1ZSA9IGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEudXBkYXRlUXVldWU7XG5cbiAgaWYgKGNvbXBvbmVudFVwZGF0ZVF1ZXVlID09PSBudWxsKSB7XG4gICAgY29tcG9uZW50VXBkYXRlUXVldWUgPSBjcmVhdGVGdW5jdGlvbkNvbXBvbmVudFVwZGF0ZVF1ZXVlKCk7XG4gICAgY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMS51cGRhdGVRdWV1ZSA9IGNvbXBvbmVudFVwZGF0ZVF1ZXVlO1xuICAgIGNvbXBvbmVudFVwZGF0ZVF1ZXVlLmxhc3RFZmZlY3QgPSBlZmZlY3QubmV4dCA9IGVmZmVjdDtcbiAgfSBlbHNlIHtcbiAgICB2YXIgbGFzdEVmZmVjdCA9IGNvbXBvbmVudFVwZGF0ZVF1ZXVlLmxhc3RFZmZlY3Q7XG5cbiAgICBpZiAobGFzdEVmZmVjdCA9PT0gbnVsbCkge1xuICAgICAgY29tcG9uZW50VXBkYXRlUXVldWUubGFzdEVmZmVjdCA9IGVmZmVjdC5uZXh0ID0gZWZmZWN0O1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgZmlyc3RFZmZlY3QgPSBsYXN0RWZmZWN0Lm5leHQ7XG4gICAgICBsYXN0RWZmZWN0Lm5leHQgPSBlZmZlY3Q7XG4gICAgICBlZmZlY3QubmV4dCA9IGZpcnN0RWZmZWN0O1xuICAgICAgY29tcG9uZW50VXBkYXRlUXVldWUubGFzdEVmZmVjdCA9IGVmZmVjdDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZWZmZWN0O1xufVxuXG5mdW5jdGlvbiBtb3VudFJlZihpbml0aWFsVmFsdWUpIHtcbiAgdmFyIGhvb2sgPSBtb3VudFdvcmtJblByb2dyZXNzSG9vaygpO1xuICB2YXIgcmVmID0ge1xuICAgIGN1cnJlbnQ6IGluaXRpYWxWYWx1ZVxuICB9O1xuXG4gIHtcbiAgICBPYmplY3Quc2VhbChyZWYpO1xuICB9XG5cbiAgaG9vay5tZW1vaXplZFN0YXRlID0gcmVmO1xuICByZXR1cm4gcmVmO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVSZWYoaW5pdGlhbFZhbHVlKSB7XG4gIHZhciBob29rID0gdXBkYXRlV29ya0luUHJvZ3Jlc3NIb29rKCk7XG4gIHJldHVybiBob29rLm1lbW9pemVkU3RhdGU7XG59XG5cbmZ1bmN0aW9uIG1vdW50RWZmZWN0SW1wbChmaWJlckZsYWdzLCBob29rRmxhZ3MsIGNyZWF0ZSwgZGVwcykge1xuICB2YXIgaG9vayA9IG1vdW50V29ya0luUHJvZ3Jlc3NIb29rKCk7XG4gIHZhciBuZXh0RGVwcyA9IGRlcHMgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBkZXBzO1xuICBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxLmZsYWdzIHw9IGZpYmVyRmxhZ3M7XG4gIGhvb2subWVtb2l6ZWRTdGF0ZSA9IHB1c2hFZmZlY3QoSGFzRWZmZWN0IHwgaG9va0ZsYWdzLCBjcmVhdGUsIHVuZGVmaW5lZCwgbmV4dERlcHMpO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVFZmZlY3RJbXBsKGZpYmVyRmxhZ3MsIGhvb2tGbGFncywgY3JlYXRlLCBkZXBzKSB7XG4gIHZhciBob29rID0gdXBkYXRlV29ya0luUHJvZ3Jlc3NIb29rKCk7XG4gIHZhciBuZXh0RGVwcyA9IGRlcHMgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBkZXBzO1xuICB2YXIgZGVzdHJveSA9IHVuZGVmaW5lZDtcblxuICBpZiAoY3VycmVudEhvb2sgIT09IG51bGwpIHtcbiAgICB2YXIgcHJldkVmZmVjdCA9IGN1cnJlbnRIb29rLm1lbW9pemVkU3RhdGU7XG4gICAgZGVzdHJveSA9IHByZXZFZmZlY3QuZGVzdHJveTtcblxuICAgIGlmIChuZXh0RGVwcyAhPT0gbnVsbCkge1xuICAgICAgdmFyIHByZXZEZXBzID0gcHJldkVmZmVjdC5kZXBzO1xuXG4gICAgICBpZiAoYXJlSG9va0lucHV0c0VxdWFsKG5leHREZXBzLCBwcmV2RGVwcykpIHtcbiAgICAgICAgcHVzaEVmZmVjdChob29rRmxhZ3MsIGNyZWF0ZSwgZGVzdHJveSwgbmV4dERlcHMpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMS5mbGFncyB8PSBmaWJlckZsYWdzO1xuICBob29rLm1lbW9pemVkU3RhdGUgPSBwdXNoRWZmZWN0KEhhc0VmZmVjdCB8IGhvb2tGbGFncywgY3JlYXRlLCBkZXN0cm95LCBuZXh0RGVwcyk7XG59XG5cbmZ1bmN0aW9uIG1vdW50RWZmZWN0KGNyZWF0ZSwgZGVwcykge1xuICB7XG4gICAgLy8gJEZsb3dFeHBlY3RlZEVycm9yIC0gamVzdCBpc24ndCBhIGdsb2JhbCwgYW5kIGlzbid0IHJlY29nbml6ZWQgb3V0c2lkZSBvZiB0ZXN0c1xuICAgIGlmICgndW5kZWZpbmVkJyAhPT0gdHlwZW9mIGplc3QpIHtcbiAgICAgIHdhcm5JZk5vdEN1cnJlbnRseUFjdGluZ0VmZmVjdHNJbkRFVihjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbW91bnRFZmZlY3RJbXBsKFVwZGF0ZSB8IFBhc3NpdmUsIFBhc3NpdmUkMSwgY3JlYXRlLCBkZXBzKTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlRWZmZWN0KGNyZWF0ZSwgZGVwcykge1xuICB7XG4gICAgLy8gJEZsb3dFeHBlY3RlZEVycm9yIC0gamVzdCBpc24ndCBhIGdsb2JhbCwgYW5kIGlzbid0IHJlY29nbml6ZWQgb3V0c2lkZSBvZiB0ZXN0c1xuICAgIGlmICgndW5kZWZpbmVkJyAhPT0gdHlwZW9mIGplc3QpIHtcbiAgICAgIHdhcm5JZk5vdEN1cnJlbnRseUFjdGluZ0VmZmVjdHNJbkRFVihjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdXBkYXRlRWZmZWN0SW1wbChVcGRhdGUgfCBQYXNzaXZlLCBQYXNzaXZlJDEsIGNyZWF0ZSwgZGVwcyk7XG59XG5cbmZ1bmN0aW9uIG1vdW50TGF5b3V0RWZmZWN0KGNyZWF0ZSwgZGVwcykge1xuICByZXR1cm4gbW91bnRFZmZlY3RJbXBsKFVwZGF0ZSwgTGF5b3V0LCBjcmVhdGUsIGRlcHMpO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVMYXlvdXRFZmZlY3QoY3JlYXRlLCBkZXBzKSB7XG4gIHJldHVybiB1cGRhdGVFZmZlY3RJbXBsKFVwZGF0ZSwgTGF5b3V0LCBjcmVhdGUsIGRlcHMpO1xufVxuXG5mdW5jdGlvbiBpbXBlcmF0aXZlSGFuZGxlRWZmZWN0KGNyZWF0ZSwgcmVmKSB7XG4gIGlmICh0eXBlb2YgcmVmID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdmFyIHJlZkNhbGxiYWNrID0gcmVmO1xuXG4gICAgdmFyIF9pbnN0ID0gY3JlYXRlKCk7XG5cbiAgICByZWZDYWxsYmFjayhfaW5zdCk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIHJlZkNhbGxiYWNrKG51bGwpO1xuICAgIH07XG4gIH0gZWxzZSBpZiAocmVmICE9PSBudWxsICYmIHJlZiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdmFyIHJlZk9iamVjdCA9IHJlZjtcblxuICAgIHtcbiAgICAgIGlmICghcmVmT2JqZWN0Lmhhc093blByb3BlcnR5KCdjdXJyZW50JykpIHtcbiAgICAgICAgZXJyb3IoJ0V4cGVjdGVkIHVzZUltcGVyYXRpdmVIYW5kbGUoKSBmaXJzdCBhcmd1bWVudCB0byBlaXRoZXIgYmUgYSAnICsgJ3JlZiBjYWxsYmFjayBvciBSZWFjdC5jcmVhdGVSZWYoKSBvYmplY3QuIEluc3RlYWQgcmVjZWl2ZWQ6ICVzLicsICdhbiBvYmplY3Qgd2l0aCBrZXlzIHsnICsgT2JqZWN0LmtleXMocmVmT2JqZWN0KS5qb2luKCcsICcpICsgJ30nKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgX2luc3QyID0gY3JlYXRlKCk7XG5cbiAgICByZWZPYmplY3QuY3VycmVudCA9IF9pbnN0MjtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgcmVmT2JqZWN0LmN1cnJlbnQgPSBudWxsO1xuICAgIH07XG4gIH1cbn1cblxuZnVuY3Rpb24gbW91bnRJbXBlcmF0aXZlSGFuZGxlKHJlZiwgY3JlYXRlLCBkZXBzKSB7XG4gIHtcbiAgICBpZiAodHlwZW9mIGNyZWF0ZSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgZXJyb3IoJ0V4cGVjdGVkIHVzZUltcGVyYXRpdmVIYW5kbGUoKSBzZWNvbmQgYXJndW1lbnQgdG8gYmUgYSBmdW5jdGlvbiAnICsgJ3RoYXQgY3JlYXRlcyBhIGhhbmRsZS4gSW5zdGVhZCByZWNlaXZlZDogJXMuJywgY3JlYXRlICE9PSBudWxsID8gdHlwZW9mIGNyZWF0ZSA6ICdudWxsJyk7XG4gICAgfVxuICB9IC8vIFRPRE86IElmIGRlcHMgYXJlIHByb3ZpZGVkLCBzaG91bGQgd2Ugc2tpcCBjb21wYXJpbmcgdGhlIHJlZiBpdHNlbGY/XG5cblxuICB2YXIgZWZmZWN0RGVwcyA9IGRlcHMgIT09IG51bGwgJiYgZGVwcyAhPT0gdW5kZWZpbmVkID8gZGVwcy5jb25jYXQoW3JlZl0pIDogbnVsbDtcbiAgcmV0dXJuIG1vdW50RWZmZWN0SW1wbChVcGRhdGUsIExheW91dCwgaW1wZXJhdGl2ZUhhbmRsZUVmZmVjdC5iaW5kKG51bGwsIGNyZWF0ZSwgcmVmKSwgZWZmZWN0RGVwcyk7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUltcGVyYXRpdmVIYW5kbGUocmVmLCBjcmVhdGUsIGRlcHMpIHtcbiAge1xuICAgIGlmICh0eXBlb2YgY3JlYXRlICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICBlcnJvcignRXhwZWN0ZWQgdXNlSW1wZXJhdGl2ZUhhbmRsZSgpIHNlY29uZCBhcmd1bWVudCB0byBiZSBhIGZ1bmN0aW9uICcgKyAndGhhdCBjcmVhdGVzIGEgaGFuZGxlLiBJbnN0ZWFkIHJlY2VpdmVkOiAlcy4nLCBjcmVhdGUgIT09IG51bGwgPyB0eXBlb2YgY3JlYXRlIDogJ251bGwnKTtcbiAgICB9XG4gIH0gLy8gVE9ETzogSWYgZGVwcyBhcmUgcHJvdmlkZWQsIHNob3VsZCB3ZSBza2lwIGNvbXBhcmluZyB0aGUgcmVmIGl0c2VsZj9cblxuXG4gIHZhciBlZmZlY3REZXBzID0gZGVwcyAhPT0gbnVsbCAmJiBkZXBzICE9PSB1bmRlZmluZWQgPyBkZXBzLmNvbmNhdChbcmVmXSkgOiBudWxsO1xuICByZXR1cm4gdXBkYXRlRWZmZWN0SW1wbChVcGRhdGUsIExheW91dCwgaW1wZXJhdGl2ZUhhbmRsZUVmZmVjdC5iaW5kKG51bGwsIGNyZWF0ZSwgcmVmKSwgZWZmZWN0RGVwcyk7XG59XG5cbmZ1bmN0aW9uIG1vdW50RGVidWdWYWx1ZSh2YWx1ZSwgZm9ybWF0dGVyRm4pIHsvLyBUaGlzIGhvb2sgaXMgbm9ybWFsbHkgYSBuby1vcC5cbiAgLy8gVGhlIHJlYWN0LWRlYnVnLWhvb2tzIHBhY2thZ2UgaW5qZWN0cyBpdHMgb3duIGltcGxlbWVudGF0aW9uXG4gIC8vIHNvIHRoYXQgZS5nLiBEZXZUb29scyBjYW4gZGlzcGxheSBjdXN0b20gaG9vayB2YWx1ZXMuXG59XG5cbnZhciB1cGRhdGVEZWJ1Z1ZhbHVlID0gbW91bnREZWJ1Z1ZhbHVlO1xuXG5mdW5jdGlvbiBtb3VudENhbGxiYWNrKGNhbGxiYWNrLCBkZXBzKSB7XG4gIHZhciBob29rID0gbW91bnRXb3JrSW5Qcm9ncmVzc0hvb2soKTtcbiAgdmFyIG5leHREZXBzID0gZGVwcyA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IGRlcHM7XG4gIGhvb2subWVtb2l6ZWRTdGF0ZSA9IFtjYWxsYmFjaywgbmV4dERlcHNdO1xuICByZXR1cm4gY2FsbGJhY2s7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUNhbGxiYWNrKGNhbGxiYWNrLCBkZXBzKSB7XG4gIHZhciBob29rID0gdXBkYXRlV29ya0luUHJvZ3Jlc3NIb29rKCk7XG4gIHZhciBuZXh0RGVwcyA9IGRlcHMgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBkZXBzO1xuICB2YXIgcHJldlN0YXRlID0gaG9vay5tZW1vaXplZFN0YXRlO1xuXG4gIGlmIChwcmV2U3RhdGUgIT09IG51bGwpIHtcbiAgICBpZiAobmV4dERlcHMgIT09IG51bGwpIHtcbiAgICAgIHZhciBwcmV2RGVwcyA9IHByZXZTdGF0ZVsxXTtcblxuICAgICAgaWYgKGFyZUhvb2tJbnB1dHNFcXVhbChuZXh0RGVwcywgcHJldkRlcHMpKSB7XG4gICAgICAgIHJldHVybiBwcmV2U3RhdGVbMF07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaG9vay5tZW1vaXplZFN0YXRlID0gW2NhbGxiYWNrLCBuZXh0RGVwc107XG4gIHJldHVybiBjYWxsYmFjaztcbn1cblxuZnVuY3Rpb24gbW91bnRNZW1vKG5leHRDcmVhdGUsIGRlcHMpIHtcbiAgdmFyIGhvb2sgPSBtb3VudFdvcmtJblByb2dyZXNzSG9vaygpO1xuICB2YXIgbmV4dERlcHMgPSBkZXBzID09PSB1bmRlZmluZWQgPyBudWxsIDogZGVwcztcbiAgdmFyIG5leHRWYWx1ZSA9IG5leHRDcmVhdGUoKTtcbiAgaG9vay5tZW1vaXplZFN0YXRlID0gW25leHRWYWx1ZSwgbmV4dERlcHNdO1xuICByZXR1cm4gbmV4dFZhbHVlO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVNZW1vKG5leHRDcmVhdGUsIGRlcHMpIHtcbiAgdmFyIGhvb2sgPSB1cGRhdGVXb3JrSW5Qcm9ncmVzc0hvb2soKTtcbiAgdmFyIG5leHREZXBzID0gZGVwcyA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IGRlcHM7XG4gIHZhciBwcmV2U3RhdGUgPSBob29rLm1lbW9pemVkU3RhdGU7XG5cbiAgaWYgKHByZXZTdGF0ZSAhPT0gbnVsbCkge1xuICAgIC8vIEFzc3VtZSB0aGVzZSBhcmUgZGVmaW5lZC4gSWYgdGhleSdyZSBub3QsIGFyZUhvb2tJbnB1dHNFcXVhbCB3aWxsIHdhcm4uXG4gICAgaWYgKG5leHREZXBzICE9PSBudWxsKSB7XG4gICAgICB2YXIgcHJldkRlcHMgPSBwcmV2U3RhdGVbMV07XG5cbiAgICAgIGlmIChhcmVIb29rSW5wdXRzRXF1YWwobmV4dERlcHMsIHByZXZEZXBzKSkge1xuICAgICAgICByZXR1cm4gcHJldlN0YXRlWzBdO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHZhciBuZXh0VmFsdWUgPSBuZXh0Q3JlYXRlKCk7XG4gIGhvb2subWVtb2l6ZWRTdGF0ZSA9IFtuZXh0VmFsdWUsIG5leHREZXBzXTtcbiAgcmV0dXJuIG5leHRWYWx1ZTtcbn1cblxuZnVuY3Rpb24gbW91bnREZWZlcnJlZFZhbHVlKHZhbHVlKSB7XG4gIHZhciBfbW91bnRTdGF0ZSA9IG1vdW50U3RhdGUodmFsdWUpLFxuICAgICAgcHJldlZhbHVlID0gX21vdW50U3RhdGVbMF0sXG4gICAgICBzZXRWYWx1ZSA9IF9tb3VudFN0YXRlWzFdO1xuXG4gIG1vdW50RWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcHJldlRyYW5zaXRpb24gPSBSZWFjdEN1cnJlbnRCYXRjaENvbmZpZyQxLnRyYW5zaXRpb247XG4gICAgUmVhY3RDdXJyZW50QmF0Y2hDb25maWckMS50cmFuc2l0aW9uID0gMTtcblxuICAgIHRyeSB7XG4gICAgICBzZXRWYWx1ZSh2YWx1ZSk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIFJlYWN0Q3VycmVudEJhdGNoQ29uZmlnJDEudHJhbnNpdGlvbiA9IHByZXZUcmFuc2l0aW9uO1xuICAgIH1cbiAgfSwgW3ZhbHVlXSk7XG4gIHJldHVybiBwcmV2VmFsdWU7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZURlZmVycmVkVmFsdWUodmFsdWUpIHtcbiAgdmFyIF91cGRhdGVTdGF0ZSA9IHVwZGF0ZVN0YXRlKCksXG4gICAgICBwcmV2VmFsdWUgPSBfdXBkYXRlU3RhdGVbMF0sXG4gICAgICBzZXRWYWx1ZSA9IF91cGRhdGVTdGF0ZVsxXTtcblxuICB1cGRhdGVFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgIHZhciBwcmV2VHJhbnNpdGlvbiA9IFJlYWN0Q3VycmVudEJhdGNoQ29uZmlnJDEudHJhbnNpdGlvbjtcbiAgICBSZWFjdEN1cnJlbnRCYXRjaENvbmZpZyQxLnRyYW5zaXRpb24gPSAxO1xuXG4gICAgdHJ5IHtcbiAgICAgIHNldFZhbHVlKHZhbHVlKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgUmVhY3RDdXJyZW50QmF0Y2hDb25maWckMS50cmFuc2l0aW9uID0gcHJldlRyYW5zaXRpb247XG4gICAgfVxuICB9LCBbdmFsdWVdKTtcbiAgcmV0dXJuIHByZXZWYWx1ZTtcbn1cblxuZnVuY3Rpb24gcmVyZW5kZXJEZWZlcnJlZFZhbHVlKHZhbHVlKSB7XG4gIHZhciBfcmVyZW5kZXJTdGF0ZSA9IHJlcmVuZGVyU3RhdGUoKSxcbiAgICAgIHByZXZWYWx1ZSA9IF9yZXJlbmRlclN0YXRlWzBdLFxuICAgICAgc2V0VmFsdWUgPSBfcmVyZW5kZXJTdGF0ZVsxXTtcblxuICB1cGRhdGVFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgIHZhciBwcmV2VHJhbnNpdGlvbiA9IFJlYWN0Q3VycmVudEJhdGNoQ29uZmlnJDEudHJhbnNpdGlvbjtcbiAgICBSZWFjdEN1cnJlbnRCYXRjaENvbmZpZyQxLnRyYW5zaXRpb24gPSAxO1xuXG4gICAgdHJ5IHtcbiAgICAgIHNldFZhbHVlKHZhbHVlKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgUmVhY3RDdXJyZW50QmF0Y2hDb25maWckMS50cmFuc2l0aW9uID0gcHJldlRyYW5zaXRpb247XG4gICAgfVxuICB9LCBbdmFsdWVdKTtcbiAgcmV0dXJuIHByZXZWYWx1ZTtcbn1cblxuZnVuY3Rpb24gc3RhcnRUcmFuc2l0aW9uKHNldFBlbmRpbmcsIGNhbGxiYWNrKSB7XG4gIHZhciBwcmlvcml0eUxldmVsID0gZ2V0Q3VycmVudFByaW9yaXR5TGV2ZWwoKTtcblxuICB7XG4gICAgcnVuV2l0aFByaW9yaXR5JDEocHJpb3JpdHlMZXZlbCA8IFVzZXJCbG9ja2luZ1ByaW9yaXR5JDIgPyBVc2VyQmxvY2tpbmdQcmlvcml0eSQyIDogcHJpb3JpdHlMZXZlbCwgZnVuY3Rpb24gKCkge1xuICAgICAgc2V0UGVuZGluZyh0cnVlKTtcbiAgICB9KTtcbiAgICBydW5XaXRoUHJpb3JpdHkkMShwcmlvcml0eUxldmVsID4gTm9ybWFsUHJpb3JpdHkkMSA/IE5vcm1hbFByaW9yaXR5JDEgOiBwcmlvcml0eUxldmVsLCBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgcHJldlRyYW5zaXRpb24gPSBSZWFjdEN1cnJlbnRCYXRjaENvbmZpZyQxLnRyYW5zaXRpb247XG4gICAgICBSZWFjdEN1cnJlbnRCYXRjaENvbmZpZyQxLnRyYW5zaXRpb24gPSAxO1xuXG4gICAgICB0cnkge1xuICAgICAgICBzZXRQZW5kaW5nKGZhbHNlKTtcbiAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIFJlYWN0Q3VycmVudEJhdGNoQ29uZmlnJDEudHJhbnNpdGlvbiA9IHByZXZUcmFuc2l0aW9uO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIG1vdW50VHJhbnNpdGlvbigpIHtcbiAgdmFyIF9tb3VudFN0YXRlMiA9IG1vdW50U3RhdGUoZmFsc2UpLFxuICAgICAgaXNQZW5kaW5nID0gX21vdW50U3RhdGUyWzBdLFxuICAgICAgc2V0UGVuZGluZyA9IF9tb3VudFN0YXRlMlsxXTsgLy8gVGhlIGBzdGFydGAgbWV0aG9kIGNhbiBiZSBzdG9yZWQgb24gYSByZWYsIHNpbmNlIGBzZXRQZW5kaW5nYFxuICAvLyBuZXZlciBjaGFuZ2VzLlxuXG5cbiAgdmFyIHN0YXJ0ID0gc3RhcnRUcmFuc2l0aW9uLmJpbmQobnVsbCwgc2V0UGVuZGluZyk7XG4gIG1vdW50UmVmKHN0YXJ0KTtcbiAgcmV0dXJuIFtzdGFydCwgaXNQZW5kaW5nXTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlVHJhbnNpdGlvbigpIHtcbiAgdmFyIF91cGRhdGVTdGF0ZTIgPSB1cGRhdGVTdGF0ZSgpLFxuICAgICAgaXNQZW5kaW5nID0gX3VwZGF0ZVN0YXRlMlswXTtcblxuICB2YXIgc3RhcnRSZWYgPSB1cGRhdGVSZWYoKTtcbiAgdmFyIHN0YXJ0ID0gc3RhcnRSZWYuY3VycmVudDtcbiAgcmV0dXJuIFtzdGFydCwgaXNQZW5kaW5nXTtcbn1cblxuZnVuY3Rpb24gcmVyZW5kZXJUcmFuc2l0aW9uKCkge1xuICB2YXIgX3JlcmVuZGVyU3RhdGUyID0gcmVyZW5kZXJTdGF0ZSgpLFxuICAgICAgaXNQZW5kaW5nID0gX3JlcmVuZGVyU3RhdGUyWzBdO1xuXG4gIHZhciBzdGFydFJlZiA9IHVwZGF0ZVJlZigpO1xuICB2YXIgc3RhcnQgPSBzdGFydFJlZi5jdXJyZW50O1xuICByZXR1cm4gW3N0YXJ0LCBpc1BlbmRpbmddO1xufVxuXG52YXIgaXNVcGRhdGluZ09wYXF1ZVZhbHVlSW5SZW5kZXJQaGFzZSA9IGZhbHNlO1xuZnVuY3Rpb24gZ2V0SXNVcGRhdGluZ09wYXF1ZVZhbHVlSW5SZW5kZXJQaGFzZUluREVWKCkge1xuICB7XG4gICAgcmV0dXJuIGlzVXBkYXRpbmdPcGFxdWVWYWx1ZUluUmVuZGVyUGhhc2U7XG4gIH1cbn1cblxuZnVuY3Rpb24gd2Fybk9uT3BhcXVlSWRlbnRpZmllckFjY2Vzc0luREVWKGZpYmVyKSB7XG4gIHtcbiAgICAvLyBUT0RPOiBTaG91bGQgd2FybiBpbiBlZmZlY3RzIGFuZCBjYWxsYmFja3MsIHRvb1xuICAgIHZhciBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZShmaWJlci50eXBlKSB8fCAnVW5rbm93bic7XG5cbiAgICBpZiAoZ2V0SXNSZW5kZXJpbmcoKSAmJiAhZGlkV2FybkFib3V0VXNlT3BhcXVlSWRlbnRpZmllcltuYW1lXSkge1xuICAgICAgZXJyb3IoJ1RoZSBvYmplY3QgcGFzc2VkIGJhY2sgZnJvbSB1c2VPcGFxdWVJZGVudGlmaWVyIGlzIG1lYW50IHRvIGJlICcgKyAncGFzc2VkIHRocm91Z2ggdG8gYXR0cmlidXRlcyBvbmx5LiBEbyBub3QgcmVhZCB0aGUgJyArICd2YWx1ZSBkaXJlY3RseS4nKTtcblxuICAgICAgZGlkV2FybkFib3V0VXNlT3BhcXVlSWRlbnRpZmllcltuYW1lXSA9IHRydWU7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIG1vdW50T3BhcXVlSWRlbnRpZmllcigpIHtcbiAgdmFyIG1ha2VJZCA9ICBtYWtlQ2xpZW50SWRJbkRFVi5iaW5kKG51bGwsIHdhcm5Pbk9wYXF1ZUlkZW50aWZpZXJBY2Nlc3NJbkRFVi5iaW5kKG51bGwsIGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEpKSA7XG5cbiAgaWYgKGdldElzSHlkcmF0aW5nKCkpIHtcbiAgICB2YXIgZGlkVXBncmFkZSA9IGZhbHNlO1xuICAgIHZhciBmaWJlciA9IGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDE7XG5cbiAgICB2YXIgcmVhZFZhbHVlID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKCFkaWRVcGdyYWRlKSB7XG4gICAgICAgIC8vIE9ubHkgdXBncmFkZSBvbmNlLiBUaGlzIHdvcmtzIGV2ZW4gaW5zaWRlIHRoZSByZW5kZXIgcGhhc2UgYmVjYXVzZVxuICAgICAgICAvLyB0aGUgdXBkYXRlIGlzIGFkZGVkIHRvIGEgc2hhcmVkIHF1ZXVlLCB3aGljaCBvdXRsYXN0cyB0aGVcbiAgICAgICAgLy8gaW4tcHJvZ3Jlc3MgcmVuZGVyLlxuICAgICAgICBkaWRVcGdyYWRlID0gdHJ1ZTtcblxuICAgICAgICB7XG4gICAgICAgICAgaXNVcGRhdGluZ09wYXF1ZVZhbHVlSW5SZW5kZXJQaGFzZSA9IHRydWU7XG4gICAgICAgICAgc2V0SWQobWFrZUlkKCkpO1xuICAgICAgICAgIGlzVXBkYXRpbmdPcGFxdWVWYWx1ZUluUmVuZGVyUGhhc2UgPSBmYWxzZTtcbiAgICAgICAgICB3YXJuT25PcGFxdWVJZGVudGlmaWVyQWNjZXNzSW5ERVYoZmliZXIpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHtcbiAgICAgICAge1xuICAgICAgICAgIHRocm93IEVycm9yKCBcIlRoZSBvYmplY3QgcGFzc2VkIGJhY2sgZnJvbSB1c2VPcGFxdWVJZGVudGlmaWVyIGlzIG1lYW50IHRvIGJlIHBhc3NlZCB0aHJvdWdoIHRvIGF0dHJpYnV0ZXMgb25seS4gRG8gbm90IHJlYWQgdGhlIHZhbHVlIGRpcmVjdGx5LlwiICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIGlkID0gbWFrZU9wYXF1ZUh5ZHJhdGluZ09iamVjdChyZWFkVmFsdWUpO1xuICAgIHZhciBzZXRJZCA9IG1vdW50U3RhdGUoaWQpWzFdO1xuXG4gICAgaWYgKChjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxLm1vZGUgJiBCbG9ja2luZ01vZGUpID09PSBOb01vZGUpIHtcbiAgICAgIGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEuZmxhZ3MgfD0gVXBkYXRlIHwgUGFzc2l2ZTtcbiAgICAgIHB1c2hFZmZlY3QoSGFzRWZmZWN0IHwgUGFzc2l2ZSQxLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHNldElkKG1ha2VJZCgpKTtcbiAgICAgIH0sIHVuZGVmaW5lZCwgbnVsbCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGlkO1xuICB9IGVsc2Uge1xuICAgIHZhciBfaWQgPSBtYWtlSWQoKTtcblxuICAgIG1vdW50U3RhdGUoX2lkKTtcbiAgICByZXR1cm4gX2lkO1xuICB9XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZU9wYXF1ZUlkZW50aWZpZXIoKSB7XG4gIHZhciBpZCA9IHVwZGF0ZVN0YXRlKClbMF07XG4gIHJldHVybiBpZDtcbn1cblxuZnVuY3Rpb24gcmVyZW5kZXJPcGFxdWVJZGVudGlmaWVyKCkge1xuICB2YXIgaWQgPSByZXJlbmRlclN0YXRlKClbMF07XG4gIHJldHVybiBpZDtcbn1cblxuZnVuY3Rpb24gZGlzcGF0Y2hBY3Rpb24oZmliZXIsIHF1ZXVlLCBhY3Rpb24pIHtcbiAge1xuICAgIGlmICh0eXBlb2YgYXJndW1lbnRzWzNdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBlcnJvcihcIlN0YXRlIHVwZGF0ZXMgZnJvbSB0aGUgdXNlU3RhdGUoKSBhbmQgdXNlUmVkdWNlcigpIEhvb2tzIGRvbid0IHN1cHBvcnQgdGhlIFwiICsgJ3NlY29uZCBjYWxsYmFjayBhcmd1bWVudC4gVG8gZXhlY3V0ZSBhIHNpZGUgZWZmZWN0IGFmdGVyICcgKyAncmVuZGVyaW5nLCBkZWNsYXJlIGl0IGluIHRoZSBjb21wb25lbnQgYm9keSB3aXRoIHVzZUVmZmVjdCgpLicpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBldmVudFRpbWUgPSByZXF1ZXN0RXZlbnRUaW1lKCk7XG4gIHZhciBsYW5lID0gcmVxdWVzdFVwZGF0ZUxhbmUoZmliZXIpO1xuICB2YXIgdXBkYXRlID0ge1xuICAgIGxhbmU6IGxhbmUsXG4gICAgYWN0aW9uOiBhY3Rpb24sXG4gICAgZWFnZXJSZWR1Y2VyOiBudWxsLFxuICAgIGVhZ2VyU3RhdGU6IG51bGwsXG4gICAgbmV4dDogbnVsbFxuICB9OyAvLyBBcHBlbmQgdGhlIHVwZGF0ZSB0byB0aGUgZW5kIG9mIHRoZSBsaXN0LlxuXG4gIHZhciBwZW5kaW5nID0gcXVldWUucGVuZGluZztcblxuICBpZiAocGVuZGluZyA9PT0gbnVsbCkge1xuICAgIC8vIFRoaXMgaXMgdGhlIGZpcnN0IHVwZGF0ZS4gQ3JlYXRlIGEgY2lyY3VsYXIgbGlzdC5cbiAgICB1cGRhdGUubmV4dCA9IHVwZGF0ZTtcbiAgfSBlbHNlIHtcbiAgICB1cGRhdGUubmV4dCA9IHBlbmRpbmcubmV4dDtcbiAgICBwZW5kaW5nLm5leHQgPSB1cGRhdGU7XG4gIH1cblxuICBxdWV1ZS5wZW5kaW5nID0gdXBkYXRlO1xuICB2YXIgYWx0ZXJuYXRlID0gZmliZXIuYWx0ZXJuYXRlO1xuXG4gIGlmIChmaWJlciA9PT0gY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMSB8fCBhbHRlcm5hdGUgIT09IG51bGwgJiYgYWx0ZXJuYXRlID09PSBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxKSB7XG4gICAgLy8gVGhpcyBpcyBhIHJlbmRlciBwaGFzZSB1cGRhdGUuIFN0YXNoIGl0IGluIGEgbGF6aWx5LWNyZWF0ZWQgbWFwIG9mXG4gICAgLy8gcXVldWUgLT4gbGlua2VkIGxpc3Qgb2YgdXBkYXRlcy4gQWZ0ZXIgdGhpcyByZW5kZXIgcGFzcywgd2UnbGwgcmVzdGFydFxuICAgIC8vIGFuZCBhcHBseSB0aGUgc3Rhc2hlZCB1cGRhdGVzIG9uIHRvcCBvZiB0aGUgd29yay1pbi1wcm9ncmVzcyBob29rLlxuICAgIGRpZFNjaGVkdWxlUmVuZGVyUGhhc2VVcGRhdGVEdXJpbmdUaGlzUGFzcyA9IGRpZFNjaGVkdWxlUmVuZGVyUGhhc2VVcGRhdGUgPSB0cnVlO1xuICB9IGVsc2Uge1xuICAgIGlmIChmaWJlci5sYW5lcyA9PT0gTm9MYW5lcyAmJiAoYWx0ZXJuYXRlID09PSBudWxsIHx8IGFsdGVybmF0ZS5sYW5lcyA9PT0gTm9MYW5lcykpIHtcbiAgICAgIC8vIFRoZSBxdWV1ZSBpcyBjdXJyZW50bHkgZW1wdHksIHdoaWNoIG1lYW5zIHdlIGNhbiBlYWdlcmx5IGNvbXB1dGUgdGhlXG4gICAgICAvLyBuZXh0IHN0YXRlIGJlZm9yZSBlbnRlcmluZyB0aGUgcmVuZGVyIHBoYXNlLiBJZiB0aGUgbmV3IHN0YXRlIGlzIHRoZVxuICAgICAgLy8gc2FtZSBhcyB0aGUgY3VycmVudCBzdGF0ZSwgd2UgbWF5IGJlIGFibGUgdG8gYmFpbCBvdXQgZW50aXJlbHkuXG4gICAgICB2YXIgbGFzdFJlbmRlcmVkUmVkdWNlciA9IHF1ZXVlLmxhc3RSZW5kZXJlZFJlZHVjZXI7XG5cbiAgICAgIGlmIChsYXN0UmVuZGVyZWRSZWR1Y2VyICE9PSBudWxsKSB7XG4gICAgICAgIHZhciBwcmV2RGlzcGF0Y2hlcjtcblxuICAgICAgICB7XG4gICAgICAgICAgcHJldkRpc3BhdGNoZXIgPSBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudDtcbiAgICAgICAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudCA9IEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPblVwZGF0ZUluREVWO1xuICAgICAgICB9XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB2YXIgY3VycmVudFN0YXRlID0gcXVldWUubGFzdFJlbmRlcmVkU3RhdGU7XG4gICAgICAgICAgdmFyIGVhZ2VyU3RhdGUgPSBsYXN0UmVuZGVyZWRSZWR1Y2VyKGN1cnJlbnRTdGF0ZSwgYWN0aW9uKTsgLy8gU3Rhc2ggdGhlIGVhZ2VybHkgY29tcHV0ZWQgc3RhdGUsIGFuZCB0aGUgcmVkdWNlciB1c2VkIHRvIGNvbXB1dGVcbiAgICAgICAgICAvLyBpdCwgb24gdGhlIHVwZGF0ZSBvYmplY3QuIElmIHRoZSByZWR1Y2VyIGhhc24ndCBjaGFuZ2VkIGJ5IHRoZVxuICAgICAgICAgIC8vIHRpbWUgd2UgZW50ZXIgdGhlIHJlbmRlciBwaGFzZSwgdGhlbiB0aGUgZWFnZXIgc3RhdGUgY2FuIGJlIHVzZWRcbiAgICAgICAgICAvLyB3aXRob3V0IGNhbGxpbmcgdGhlIHJlZHVjZXIgYWdhaW4uXG5cbiAgICAgICAgICB1cGRhdGUuZWFnZXJSZWR1Y2VyID0gbGFzdFJlbmRlcmVkUmVkdWNlcjtcbiAgICAgICAgICB1cGRhdGUuZWFnZXJTdGF0ZSA9IGVhZ2VyU3RhdGU7XG5cbiAgICAgICAgICBpZiAob2JqZWN0SXMoZWFnZXJTdGF0ZSwgY3VycmVudFN0YXRlKSkge1xuICAgICAgICAgICAgLy8gRmFzdCBwYXRoLiBXZSBjYW4gYmFpbCBvdXQgd2l0aG91dCBzY2hlZHVsaW5nIFJlYWN0IHRvIHJlLXJlbmRlci5cbiAgICAgICAgICAgIC8vIEl0J3Mgc3RpbGwgcG9zc2libGUgdGhhdCB3ZSdsbCBuZWVkIHRvIHJlYmFzZSB0aGlzIHVwZGF0ZSBsYXRlcixcbiAgICAgICAgICAgIC8vIGlmIHRoZSBjb21wb25lbnQgcmUtcmVuZGVycyBmb3IgYSBkaWZmZXJlbnQgcmVhc29uIGFuZCBieSB0aGF0XG4gICAgICAgICAgICAvLyB0aW1lIHRoZSByZWR1Y2VyIGhhcyBjaGFuZ2VkLlxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHsvLyBTdXBwcmVzcyB0aGUgZXJyb3IuIEl0IHdpbGwgdGhyb3cgYWdhaW4gaW4gdGhlIHJlbmRlciBwaGFzZS5cbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICB7XG4gICAgICAgICAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudCA9IHByZXZEaXNwYXRjaGVyO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHtcbiAgICAgIC8vICRGbG93RXhwZWN0ZWRFcnJvciAtIGplc3QgaXNuJ3QgYSBnbG9iYWwsIGFuZCBpc24ndCByZWNvZ25pemVkIG91dHNpZGUgb2YgdGVzdHNcbiAgICAgIGlmICgndW5kZWZpbmVkJyAhPT0gdHlwZW9mIGplc3QpIHtcbiAgICAgICAgd2FybklmTm90U2NvcGVkV2l0aE1hdGNoaW5nQWN0KGZpYmVyKTtcbiAgICAgICAgd2FybklmTm90Q3VycmVudGx5QWN0aW5nVXBkYXRlc0luRGV2KGZpYmVyKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBzY2hlZHVsZVVwZGF0ZU9uRmliZXIoZmliZXIsIGxhbmUsIGV2ZW50VGltZSk7XG4gIH1cbn1cblxudmFyIENvbnRleHRPbmx5RGlzcGF0Y2hlciA9IHtcbiAgcmVhZENvbnRleHQ6IHJlYWRDb250ZXh0LFxuICB1c2VDYWxsYmFjazogdGhyb3dJbnZhbGlkSG9va0Vycm9yLFxuICB1c2VDb250ZXh0OiB0aHJvd0ludmFsaWRIb29rRXJyb3IsXG4gIHVzZUVmZmVjdDogdGhyb3dJbnZhbGlkSG9va0Vycm9yLFxuICB1c2VJbXBlcmF0aXZlSGFuZGxlOiB0aHJvd0ludmFsaWRIb29rRXJyb3IsXG4gIHVzZUxheW91dEVmZmVjdDogdGhyb3dJbnZhbGlkSG9va0Vycm9yLFxuICB1c2VNZW1vOiB0aHJvd0ludmFsaWRIb29rRXJyb3IsXG4gIHVzZVJlZHVjZXI6IHRocm93SW52YWxpZEhvb2tFcnJvcixcbiAgdXNlUmVmOiB0aHJvd0ludmFsaWRIb29rRXJyb3IsXG4gIHVzZVN0YXRlOiB0aHJvd0ludmFsaWRIb29rRXJyb3IsXG4gIHVzZURlYnVnVmFsdWU6IHRocm93SW52YWxpZEhvb2tFcnJvcixcbiAgdXNlRGVmZXJyZWRWYWx1ZTogdGhyb3dJbnZhbGlkSG9va0Vycm9yLFxuICB1c2VUcmFuc2l0aW9uOiB0aHJvd0ludmFsaWRIb29rRXJyb3IsXG4gIHVzZU11dGFibGVTb3VyY2U6IHRocm93SW52YWxpZEhvb2tFcnJvcixcbiAgdXNlT3BhcXVlSWRlbnRpZmllcjogdGhyb3dJbnZhbGlkSG9va0Vycm9yLFxuICB1bnN0YWJsZV9pc05ld1JlY29uY2lsZXI6IGVuYWJsZU5ld1JlY29uY2lsZXJcbn07XG52YXIgSG9va3NEaXNwYXRjaGVyT25Nb3VudEluREVWID0gbnVsbDtcbnZhciBIb29rc0Rpc3BhdGNoZXJPbk1vdW50V2l0aEhvb2tUeXBlc0luREVWID0gbnVsbDtcbnZhciBIb29rc0Rpc3BhdGNoZXJPblVwZGF0ZUluREVWID0gbnVsbDtcbnZhciBIb29rc0Rpc3BhdGNoZXJPblJlcmVuZGVySW5ERVYgPSBudWxsO1xudmFyIEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPbk1vdW50SW5ERVYgPSBudWxsO1xudmFyIEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPblVwZGF0ZUluREVWID0gbnVsbDtcbnZhciBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25SZXJlbmRlckluREVWID0gbnVsbDtcblxue1xuICB2YXIgd2FybkludmFsaWRDb250ZXh0QWNjZXNzID0gZnVuY3Rpb24gKCkge1xuICAgIGVycm9yKCdDb250ZXh0IGNhbiBvbmx5IGJlIHJlYWQgd2hpbGUgUmVhY3QgaXMgcmVuZGVyaW5nLiAnICsgJ0luIGNsYXNzZXMsIHlvdSBjYW4gcmVhZCBpdCBpbiB0aGUgcmVuZGVyIG1ldGhvZCBvciBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMuICcgKyAnSW4gZnVuY3Rpb24gY29tcG9uZW50cywgeW91IGNhbiByZWFkIGl0IGRpcmVjdGx5IGluIHRoZSBmdW5jdGlvbiBib2R5LCBidXQgbm90ICcgKyAnaW5zaWRlIEhvb2tzIGxpa2UgdXNlUmVkdWNlcigpIG9yIHVzZU1lbW8oKS4nKTtcbiAgfTtcblxuICB2YXIgd2FybkludmFsaWRIb29rQWNjZXNzID0gZnVuY3Rpb24gKCkge1xuICAgIGVycm9yKCdEbyBub3QgY2FsbCBIb29rcyBpbnNpZGUgdXNlRWZmZWN0KC4uLiksIHVzZU1lbW8oLi4uKSwgb3Igb3RoZXIgYnVpbHQtaW4gSG9va3MuICcgKyAnWW91IGNhbiBvbmx5IGNhbGwgSG9va3MgYXQgdGhlIHRvcCBsZXZlbCBvZiB5b3VyIFJlYWN0IGZ1bmN0aW9uLiAnICsgJ0ZvciBtb3JlIGluZm9ybWF0aW9uLCBzZWUgJyArICdodHRwczovL3JlYWN0anMub3JnL2xpbmsvcnVsZXMtb2YtaG9va3MnKTtcbiAgfTtcblxuICBIb29rc0Rpc3BhdGNoZXJPbk1vdW50SW5ERVYgPSB7XG4gICAgcmVhZENvbnRleHQ6IGZ1bmN0aW9uIChjb250ZXh0LCBvYnNlcnZlZEJpdHMpIHtcbiAgICAgIHJldHVybiByZWFkQ29udGV4dChjb250ZXh0LCBvYnNlcnZlZEJpdHMpO1xuICAgIH0sXG4gICAgdXNlQ2FsbGJhY2s6IGZ1bmN0aW9uIChjYWxsYmFjaywgZGVwcykge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlQ2FsbGJhY2snO1xuICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgIGNoZWNrRGVwc0FyZUFycmF5RGV2KGRlcHMpO1xuICAgICAgcmV0dXJuIG1vdW50Q2FsbGJhY2soY2FsbGJhY2ssIGRlcHMpO1xuICAgIH0sXG4gICAgdXNlQ29udGV4dDogZnVuY3Rpb24gKGNvbnRleHQsIG9ic2VydmVkQml0cykge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlQ29udGV4dCc7XG4gICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHJlYWRDb250ZXh0KGNvbnRleHQsIG9ic2VydmVkQml0cyk7XG4gICAgfSxcbiAgICB1c2VFZmZlY3Q6IGZ1bmN0aW9uIChjcmVhdGUsIGRlcHMpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUVmZmVjdCc7XG4gICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgY2hlY2tEZXBzQXJlQXJyYXlEZXYoZGVwcyk7XG4gICAgICByZXR1cm4gbW91bnRFZmZlY3QoY3JlYXRlLCBkZXBzKTtcbiAgICB9LFxuICAgIHVzZUltcGVyYXRpdmVIYW5kbGU6IGZ1bmN0aW9uIChyZWYsIGNyZWF0ZSwgZGVwcykge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlSW1wZXJhdGl2ZUhhbmRsZSc7XG4gICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgY2hlY2tEZXBzQXJlQXJyYXlEZXYoZGVwcyk7XG4gICAgICByZXR1cm4gbW91bnRJbXBlcmF0aXZlSGFuZGxlKHJlZiwgY3JlYXRlLCBkZXBzKTtcbiAgICB9LFxuICAgIHVzZUxheW91dEVmZmVjdDogZnVuY3Rpb24gKGNyZWF0ZSwgZGVwcykge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlTGF5b3V0RWZmZWN0JztcbiAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICBjaGVja0RlcHNBcmVBcnJheURldihkZXBzKTtcbiAgICAgIHJldHVybiBtb3VudExheW91dEVmZmVjdChjcmVhdGUsIGRlcHMpO1xuICAgIH0sXG4gICAgdXNlTWVtbzogZnVuY3Rpb24gKGNyZWF0ZSwgZGVwcykge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlTWVtbyc7XG4gICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgY2hlY2tEZXBzQXJlQXJyYXlEZXYoZGVwcyk7XG4gICAgICB2YXIgcHJldkRpc3BhdGNoZXIgPSBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudDtcbiAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50ID0gSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uTW91bnRJbkRFVjtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIG1vdW50TWVtbyhjcmVhdGUsIGRlcHMpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQgPSBwcmV2RGlzcGF0Y2hlcjtcbiAgICAgIH1cbiAgICB9LFxuICAgIHVzZVJlZHVjZXI6IGZ1bmN0aW9uIChyZWR1Y2VyLCBpbml0aWFsQXJnLCBpbml0KSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VSZWR1Y2VyJztcbiAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICB2YXIgcHJldkRpc3BhdGNoZXIgPSBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudDtcbiAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50ID0gSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uTW91bnRJbkRFVjtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIG1vdW50UmVkdWNlcihyZWR1Y2VyLCBpbml0aWFsQXJnLCBpbml0KTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50ID0gcHJldkRpc3BhdGNoZXI7XG4gICAgICB9XG4gICAgfSxcbiAgICB1c2VSZWY6IGZ1bmN0aW9uIChpbml0aWFsVmFsdWUpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZVJlZic7XG4gICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIG1vdW50UmVmKGluaXRpYWxWYWx1ZSk7XG4gICAgfSxcbiAgICB1c2VTdGF0ZTogZnVuY3Rpb24gKGluaXRpYWxTdGF0ZSkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlU3RhdGUnO1xuICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgIHZhciBwcmV2RGlzcGF0Y2hlciA9IFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50O1xuICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQgPSBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25Nb3VudEluREVWO1xuXG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gbW91bnRTdGF0ZShpbml0aWFsU3RhdGUpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQgPSBwcmV2RGlzcGF0Y2hlcjtcbiAgICAgIH1cbiAgICB9LFxuICAgIHVzZURlYnVnVmFsdWU6IGZ1bmN0aW9uICh2YWx1ZSwgZm9ybWF0dGVyRm4pIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZURlYnVnVmFsdWUnO1xuICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiBtb3VudERlYnVnVmFsdWUoKTtcbiAgICB9LFxuICAgIHVzZURlZmVycmVkVmFsdWU6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlRGVmZXJyZWRWYWx1ZSc7XG4gICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIG1vdW50RGVmZXJyZWRWYWx1ZSh2YWx1ZSk7XG4gICAgfSxcbiAgICB1c2VUcmFuc2l0aW9uOiBmdW5jdGlvbiAoKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VUcmFuc2l0aW9uJztcbiAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gbW91bnRUcmFuc2l0aW9uKCk7XG4gICAgfSxcbiAgICB1c2VNdXRhYmxlU291cmNlOiBmdW5jdGlvbiAoc291cmNlLCBnZXRTbmFwc2hvdCwgc3Vic2NyaWJlKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VNdXRhYmxlU291cmNlJztcbiAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gbW91bnRNdXRhYmxlU291cmNlKHNvdXJjZSwgZ2V0U25hcHNob3QsIHN1YnNjcmliZSk7XG4gICAgfSxcbiAgICB1c2VPcGFxdWVJZGVudGlmaWVyOiBmdW5jdGlvbiAoKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VPcGFxdWVJZGVudGlmaWVyJztcbiAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gbW91bnRPcGFxdWVJZGVudGlmaWVyKCk7XG4gICAgfSxcbiAgICB1bnN0YWJsZV9pc05ld1JlY29uY2lsZXI6IGVuYWJsZU5ld1JlY29uY2lsZXJcbiAgfTtcbiAgSG9va3NEaXNwYXRjaGVyT25Nb3VudFdpdGhIb29rVHlwZXNJbkRFViA9IHtcbiAgICByZWFkQ29udGV4dDogZnVuY3Rpb24gKGNvbnRleHQsIG9ic2VydmVkQml0cykge1xuICAgICAgcmV0dXJuIHJlYWRDb250ZXh0KGNvbnRleHQsIG9ic2VydmVkQml0cyk7XG4gICAgfSxcbiAgICB1c2VDYWxsYmFjazogZnVuY3Rpb24gKGNhbGxiYWNrLCBkZXBzKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VDYWxsYmFjayc7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiBtb3VudENhbGxiYWNrKGNhbGxiYWNrLCBkZXBzKTtcbiAgICB9LFxuICAgIHVzZUNvbnRleHQ6IGZ1bmN0aW9uIChjb250ZXh0LCBvYnNlcnZlZEJpdHMpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUNvbnRleHQnO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gcmVhZENvbnRleHQoY29udGV4dCwgb2JzZXJ2ZWRCaXRzKTtcbiAgICB9LFxuICAgIHVzZUVmZmVjdDogZnVuY3Rpb24gKGNyZWF0ZSwgZGVwcykge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlRWZmZWN0JztcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIG1vdW50RWZmZWN0KGNyZWF0ZSwgZGVwcyk7XG4gICAgfSxcbiAgICB1c2VJbXBlcmF0aXZlSGFuZGxlOiBmdW5jdGlvbiAocmVmLCBjcmVhdGUsIGRlcHMpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUltcGVyYXRpdmVIYW5kbGUnO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gbW91bnRJbXBlcmF0aXZlSGFuZGxlKHJlZiwgY3JlYXRlLCBkZXBzKTtcbiAgICB9LFxuICAgIHVzZUxheW91dEVmZmVjdDogZnVuY3Rpb24gKGNyZWF0ZSwgZGVwcykge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlTGF5b3V0RWZmZWN0JztcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIG1vdW50TGF5b3V0RWZmZWN0KGNyZWF0ZSwgZGVwcyk7XG4gICAgfSxcbiAgICB1c2VNZW1vOiBmdW5jdGlvbiAoY3JlYXRlLCBkZXBzKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VNZW1vJztcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgdmFyIHByZXZEaXNwYXRjaGVyID0gUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQ7XG4gICAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudCA9IEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPbk1vdW50SW5ERVY7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBtb3VudE1lbW8oY3JlYXRlLCBkZXBzKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50ID0gcHJldkRpc3BhdGNoZXI7XG4gICAgICB9XG4gICAgfSxcbiAgICB1c2VSZWR1Y2VyOiBmdW5jdGlvbiAocmVkdWNlciwgaW5pdGlhbEFyZywgaW5pdCkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlUmVkdWNlcic7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHZhciBwcmV2RGlzcGF0Y2hlciA9IFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50O1xuICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQgPSBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25Nb3VudEluREVWO1xuXG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gbW91bnRSZWR1Y2VyKHJlZHVjZXIsIGluaXRpYWxBcmcsIGluaXQpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQgPSBwcmV2RGlzcGF0Y2hlcjtcbiAgICAgIH1cbiAgICB9LFxuICAgIHVzZVJlZjogZnVuY3Rpb24gKGluaXRpYWxWYWx1ZSkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlUmVmJztcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIG1vdW50UmVmKGluaXRpYWxWYWx1ZSk7XG4gICAgfSxcbiAgICB1c2VTdGF0ZTogZnVuY3Rpb24gKGluaXRpYWxTdGF0ZSkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlU3RhdGUnO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICB2YXIgcHJldkRpc3BhdGNoZXIgPSBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudDtcbiAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50ID0gSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uTW91bnRJbkRFVjtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIG1vdW50U3RhdGUoaW5pdGlhbFN0YXRlKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50ID0gcHJldkRpc3BhdGNoZXI7XG4gICAgICB9XG4gICAgfSxcbiAgICB1c2VEZWJ1Z1ZhbHVlOiBmdW5jdGlvbiAodmFsdWUsIGZvcm1hdHRlckZuKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VEZWJ1Z1ZhbHVlJztcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIG1vdW50RGVidWdWYWx1ZSgpO1xuICAgIH0sXG4gICAgdXNlRGVmZXJyZWRWYWx1ZTogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VEZWZlcnJlZFZhbHVlJztcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIG1vdW50RGVmZXJyZWRWYWx1ZSh2YWx1ZSk7XG4gICAgfSxcbiAgICB1c2VUcmFuc2l0aW9uOiBmdW5jdGlvbiAoKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VUcmFuc2l0aW9uJztcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIG1vdW50VHJhbnNpdGlvbigpO1xuICAgIH0sXG4gICAgdXNlTXV0YWJsZVNvdXJjZTogZnVuY3Rpb24gKHNvdXJjZSwgZ2V0U25hcHNob3QsIHN1YnNjcmliZSkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlTXV0YWJsZVNvdXJjZSc7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiBtb3VudE11dGFibGVTb3VyY2Uoc291cmNlLCBnZXRTbmFwc2hvdCwgc3Vic2NyaWJlKTtcbiAgICB9LFxuICAgIHVzZU9wYXF1ZUlkZW50aWZpZXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZU9wYXF1ZUlkZW50aWZpZXInO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gbW91bnRPcGFxdWVJZGVudGlmaWVyKCk7XG4gICAgfSxcbiAgICB1bnN0YWJsZV9pc05ld1JlY29uY2lsZXI6IGVuYWJsZU5ld1JlY29uY2lsZXJcbiAgfTtcbiAgSG9va3NEaXNwYXRjaGVyT25VcGRhdGVJbkRFViA9IHtcbiAgICByZWFkQ29udGV4dDogZnVuY3Rpb24gKGNvbnRleHQsIG9ic2VydmVkQml0cykge1xuICAgICAgcmV0dXJuIHJlYWRDb250ZXh0KGNvbnRleHQsIG9ic2VydmVkQml0cyk7XG4gICAgfSxcbiAgICB1c2VDYWxsYmFjazogZnVuY3Rpb24gKGNhbGxiYWNrLCBkZXBzKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VDYWxsYmFjayc7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiB1cGRhdGVDYWxsYmFjayhjYWxsYmFjaywgZGVwcyk7XG4gICAgfSxcbiAgICB1c2VDb250ZXh0OiBmdW5jdGlvbiAoY29udGV4dCwgb2JzZXJ2ZWRCaXRzKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VDb250ZXh0JztcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHJlYWRDb250ZXh0KGNvbnRleHQsIG9ic2VydmVkQml0cyk7XG4gICAgfSxcbiAgICB1c2VFZmZlY3Q6IGZ1bmN0aW9uIChjcmVhdGUsIGRlcHMpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUVmZmVjdCc7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiB1cGRhdGVFZmZlY3QoY3JlYXRlLCBkZXBzKTtcbiAgICB9LFxuICAgIHVzZUltcGVyYXRpdmVIYW5kbGU6IGZ1bmN0aW9uIChyZWYsIGNyZWF0ZSwgZGVwcykge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlSW1wZXJhdGl2ZUhhbmRsZSc7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiB1cGRhdGVJbXBlcmF0aXZlSGFuZGxlKHJlZiwgY3JlYXRlLCBkZXBzKTtcbiAgICB9LFxuICAgIHVzZUxheW91dEVmZmVjdDogZnVuY3Rpb24gKGNyZWF0ZSwgZGVwcykge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlTGF5b3V0RWZmZWN0JztcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHVwZGF0ZUxheW91dEVmZmVjdChjcmVhdGUsIGRlcHMpO1xuICAgIH0sXG4gICAgdXNlTWVtbzogZnVuY3Rpb24gKGNyZWF0ZSwgZGVwcykge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlTWVtbyc7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHZhciBwcmV2RGlzcGF0Y2hlciA9IFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50O1xuICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQgPSBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25VcGRhdGVJbkRFVjtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIHVwZGF0ZU1lbW8oY3JlYXRlLCBkZXBzKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50ID0gcHJldkRpc3BhdGNoZXI7XG4gICAgICB9XG4gICAgfSxcbiAgICB1c2VSZWR1Y2VyOiBmdW5jdGlvbiAocmVkdWNlciwgaW5pdGlhbEFyZywgaW5pdCkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlUmVkdWNlcic7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHZhciBwcmV2RGlzcGF0Y2hlciA9IFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50O1xuICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQgPSBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25VcGRhdGVJbkRFVjtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIHVwZGF0ZVJlZHVjZXIocmVkdWNlciwgaW5pdGlhbEFyZywgaW5pdCk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudCA9IHByZXZEaXNwYXRjaGVyO1xuICAgICAgfVxuICAgIH0sXG4gICAgdXNlUmVmOiBmdW5jdGlvbiAoaW5pdGlhbFZhbHVlKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VSZWYnO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gdXBkYXRlUmVmKCk7XG4gICAgfSxcbiAgICB1c2VTdGF0ZTogZnVuY3Rpb24gKGluaXRpYWxTdGF0ZSkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlU3RhdGUnO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICB2YXIgcHJldkRpc3BhdGNoZXIgPSBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudDtcbiAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50ID0gSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uVXBkYXRlSW5ERVY7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiB1cGRhdGVTdGF0ZShpbml0aWFsU3RhdGUpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQgPSBwcmV2RGlzcGF0Y2hlcjtcbiAgICAgIH1cbiAgICB9LFxuICAgIHVzZURlYnVnVmFsdWU6IGZ1bmN0aW9uICh2YWx1ZSwgZm9ybWF0dGVyRm4pIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZURlYnVnVmFsdWUnO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gdXBkYXRlRGVidWdWYWx1ZSgpO1xuICAgIH0sXG4gICAgdXNlRGVmZXJyZWRWYWx1ZTogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VEZWZlcnJlZFZhbHVlJztcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHVwZGF0ZURlZmVycmVkVmFsdWUodmFsdWUpO1xuICAgIH0sXG4gICAgdXNlVHJhbnNpdGlvbjogZnVuY3Rpb24gKCkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlVHJhbnNpdGlvbic7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiB1cGRhdGVUcmFuc2l0aW9uKCk7XG4gICAgfSxcbiAgICB1c2VNdXRhYmxlU291cmNlOiBmdW5jdGlvbiAoc291cmNlLCBnZXRTbmFwc2hvdCwgc3Vic2NyaWJlKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VNdXRhYmxlU291cmNlJztcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHVwZGF0ZU11dGFibGVTb3VyY2Uoc291cmNlLCBnZXRTbmFwc2hvdCwgc3Vic2NyaWJlKTtcbiAgICB9LFxuICAgIHVzZU9wYXF1ZUlkZW50aWZpZXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZU9wYXF1ZUlkZW50aWZpZXInO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gdXBkYXRlT3BhcXVlSWRlbnRpZmllcigpO1xuICAgIH0sXG4gICAgdW5zdGFibGVfaXNOZXdSZWNvbmNpbGVyOiBlbmFibGVOZXdSZWNvbmNpbGVyXG4gIH07XG4gIEhvb2tzRGlzcGF0Y2hlck9uUmVyZW5kZXJJbkRFViA9IHtcbiAgICByZWFkQ29udGV4dDogZnVuY3Rpb24gKGNvbnRleHQsIG9ic2VydmVkQml0cykge1xuICAgICAgcmV0dXJuIHJlYWRDb250ZXh0KGNvbnRleHQsIG9ic2VydmVkQml0cyk7XG4gICAgfSxcbiAgICB1c2VDYWxsYmFjazogZnVuY3Rpb24gKGNhbGxiYWNrLCBkZXBzKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VDYWxsYmFjayc7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiB1cGRhdGVDYWxsYmFjayhjYWxsYmFjaywgZGVwcyk7XG4gICAgfSxcbiAgICB1c2VDb250ZXh0OiBmdW5jdGlvbiAoY29udGV4dCwgb2JzZXJ2ZWRCaXRzKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VDb250ZXh0JztcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHJlYWRDb250ZXh0KGNvbnRleHQsIG9ic2VydmVkQml0cyk7XG4gICAgfSxcbiAgICB1c2VFZmZlY3Q6IGZ1bmN0aW9uIChjcmVhdGUsIGRlcHMpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUVmZmVjdCc7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiB1cGRhdGVFZmZlY3QoY3JlYXRlLCBkZXBzKTtcbiAgICB9LFxuICAgIHVzZUltcGVyYXRpdmVIYW5kbGU6IGZ1bmN0aW9uIChyZWYsIGNyZWF0ZSwgZGVwcykge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlSW1wZXJhdGl2ZUhhbmRsZSc7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiB1cGRhdGVJbXBlcmF0aXZlSGFuZGxlKHJlZiwgY3JlYXRlLCBkZXBzKTtcbiAgICB9LFxuICAgIHVzZUxheW91dEVmZmVjdDogZnVuY3Rpb24gKGNyZWF0ZSwgZGVwcykge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlTGF5b3V0RWZmZWN0JztcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHVwZGF0ZUxheW91dEVmZmVjdChjcmVhdGUsIGRlcHMpO1xuICAgIH0sXG4gICAgdXNlTWVtbzogZnVuY3Rpb24gKGNyZWF0ZSwgZGVwcykge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlTWVtbyc7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHZhciBwcmV2RGlzcGF0Y2hlciA9IFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50O1xuICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQgPSBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25SZXJlbmRlckluREVWO1xuXG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gdXBkYXRlTWVtbyhjcmVhdGUsIGRlcHMpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQgPSBwcmV2RGlzcGF0Y2hlcjtcbiAgICAgIH1cbiAgICB9LFxuICAgIHVzZVJlZHVjZXI6IGZ1bmN0aW9uIChyZWR1Y2VyLCBpbml0aWFsQXJnLCBpbml0KSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VSZWR1Y2VyJztcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgdmFyIHByZXZEaXNwYXRjaGVyID0gUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQ7XG4gICAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudCA9IEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPblJlcmVuZGVySW5ERVY7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiByZXJlbmRlclJlZHVjZXIocmVkdWNlciwgaW5pdGlhbEFyZywgaW5pdCk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudCA9IHByZXZEaXNwYXRjaGVyO1xuICAgICAgfVxuICAgIH0sXG4gICAgdXNlUmVmOiBmdW5jdGlvbiAoaW5pdGlhbFZhbHVlKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VSZWYnO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gdXBkYXRlUmVmKCk7XG4gICAgfSxcbiAgICB1c2VTdGF0ZTogZnVuY3Rpb24gKGluaXRpYWxTdGF0ZSkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlU3RhdGUnO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICB2YXIgcHJldkRpc3BhdGNoZXIgPSBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudDtcbiAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50ID0gSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uUmVyZW5kZXJJbkRFVjtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIHJlcmVuZGVyU3RhdGUoaW5pdGlhbFN0YXRlKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50ID0gcHJldkRpc3BhdGNoZXI7XG4gICAgICB9XG4gICAgfSxcbiAgICB1c2VEZWJ1Z1ZhbHVlOiBmdW5jdGlvbiAodmFsdWUsIGZvcm1hdHRlckZuKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VEZWJ1Z1ZhbHVlJztcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHVwZGF0ZURlYnVnVmFsdWUoKTtcbiAgICB9LFxuICAgIHVzZURlZmVycmVkVmFsdWU6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlRGVmZXJyZWRWYWx1ZSc7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiByZXJlbmRlckRlZmVycmVkVmFsdWUodmFsdWUpO1xuICAgIH0sXG4gICAgdXNlVHJhbnNpdGlvbjogZnVuY3Rpb24gKCkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlVHJhbnNpdGlvbic7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiByZXJlbmRlclRyYW5zaXRpb24oKTtcbiAgICB9LFxuICAgIHVzZU11dGFibGVTb3VyY2U6IGZ1bmN0aW9uIChzb3VyY2UsIGdldFNuYXBzaG90LCBzdWJzY3JpYmUpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZU11dGFibGVTb3VyY2UnO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gdXBkYXRlTXV0YWJsZVNvdXJjZShzb3VyY2UsIGdldFNuYXBzaG90LCBzdWJzY3JpYmUpO1xuICAgIH0sXG4gICAgdXNlT3BhcXVlSWRlbnRpZmllcjogZnVuY3Rpb24gKCkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlT3BhcXVlSWRlbnRpZmllcic7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiByZXJlbmRlck9wYXF1ZUlkZW50aWZpZXIoKTtcbiAgICB9LFxuICAgIHVuc3RhYmxlX2lzTmV3UmVjb25jaWxlcjogZW5hYmxlTmV3UmVjb25jaWxlclxuICB9O1xuICBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25Nb3VudEluREVWID0ge1xuICAgIHJlYWRDb250ZXh0OiBmdW5jdGlvbiAoY29udGV4dCwgb2JzZXJ2ZWRCaXRzKSB7XG4gICAgICB3YXJuSW52YWxpZENvbnRleHRBY2Nlc3MoKTtcbiAgICAgIHJldHVybiByZWFkQ29udGV4dChjb250ZXh0LCBvYnNlcnZlZEJpdHMpO1xuICAgIH0sXG4gICAgdXNlQ2FsbGJhY2s6IGZ1bmN0aW9uIChjYWxsYmFjaywgZGVwcykge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlQ2FsbGJhY2snO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIG1vdW50Q2FsbGJhY2soY2FsbGJhY2ssIGRlcHMpO1xuICAgIH0sXG4gICAgdXNlQ29udGV4dDogZnVuY3Rpb24gKGNvbnRleHQsIG9ic2VydmVkQml0cykge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlQ29udGV4dCc7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gcmVhZENvbnRleHQoY29udGV4dCwgb2JzZXJ2ZWRCaXRzKTtcbiAgICB9LFxuICAgIHVzZUVmZmVjdDogZnVuY3Rpb24gKGNyZWF0ZSwgZGVwcykge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlRWZmZWN0JztcbiAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiBtb3VudEVmZmVjdChjcmVhdGUsIGRlcHMpO1xuICAgIH0sXG4gICAgdXNlSW1wZXJhdGl2ZUhhbmRsZTogZnVuY3Rpb24gKHJlZiwgY3JlYXRlLCBkZXBzKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VJbXBlcmF0aXZlSGFuZGxlJztcbiAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiBtb3VudEltcGVyYXRpdmVIYW5kbGUocmVmLCBjcmVhdGUsIGRlcHMpO1xuICAgIH0sXG4gICAgdXNlTGF5b3V0RWZmZWN0OiBmdW5jdGlvbiAoY3JlYXRlLCBkZXBzKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VMYXlvdXRFZmZlY3QnO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIG1vdW50TGF5b3V0RWZmZWN0KGNyZWF0ZSwgZGVwcyk7XG4gICAgfSxcbiAgICB1c2VNZW1vOiBmdW5jdGlvbiAoY3JlYXRlLCBkZXBzKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VNZW1vJztcbiAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgIHZhciBwcmV2RGlzcGF0Y2hlciA9IFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50O1xuICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQgPSBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25Nb3VudEluREVWO1xuXG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gbW91bnRNZW1vKGNyZWF0ZSwgZGVwcyk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudCA9IHByZXZEaXNwYXRjaGVyO1xuICAgICAgfVxuICAgIH0sXG4gICAgdXNlUmVkdWNlcjogZnVuY3Rpb24gKHJlZHVjZXIsIGluaXRpYWxBcmcsIGluaXQpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZVJlZHVjZXInO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgdmFyIHByZXZEaXNwYXRjaGVyID0gUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQ7XG4gICAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudCA9IEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPbk1vdW50SW5ERVY7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBtb3VudFJlZHVjZXIocmVkdWNlciwgaW5pdGlhbEFyZywgaW5pdCk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudCA9IHByZXZEaXNwYXRjaGVyO1xuICAgICAgfVxuICAgIH0sXG4gICAgdXNlUmVmOiBmdW5jdGlvbiAoaW5pdGlhbFZhbHVlKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VSZWYnO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIG1vdW50UmVmKGluaXRpYWxWYWx1ZSk7XG4gICAgfSxcbiAgICB1c2VTdGF0ZTogZnVuY3Rpb24gKGluaXRpYWxTdGF0ZSkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlU3RhdGUnO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgdmFyIHByZXZEaXNwYXRjaGVyID0gUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQ7XG4gICAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudCA9IEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPbk1vdW50SW5ERVY7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBtb3VudFN0YXRlKGluaXRpYWxTdGF0ZSk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudCA9IHByZXZEaXNwYXRjaGVyO1xuICAgICAgfVxuICAgIH0sXG4gICAgdXNlRGVidWdWYWx1ZTogZnVuY3Rpb24gKHZhbHVlLCBmb3JtYXR0ZXJGbikge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlRGVidWdWYWx1ZSc7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gbW91bnREZWJ1Z1ZhbHVlKCk7XG4gICAgfSxcbiAgICB1c2VEZWZlcnJlZFZhbHVlOiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZURlZmVycmVkVmFsdWUnO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIG1vdW50RGVmZXJyZWRWYWx1ZSh2YWx1ZSk7XG4gICAgfSxcbiAgICB1c2VUcmFuc2l0aW9uOiBmdW5jdGlvbiAoKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VUcmFuc2l0aW9uJztcbiAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiBtb3VudFRyYW5zaXRpb24oKTtcbiAgICB9LFxuICAgIHVzZU11dGFibGVTb3VyY2U6IGZ1bmN0aW9uIChzb3VyY2UsIGdldFNuYXBzaG90LCBzdWJzY3JpYmUpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZU11dGFibGVTb3VyY2UnO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIG1vdW50TXV0YWJsZVNvdXJjZShzb3VyY2UsIGdldFNuYXBzaG90LCBzdWJzY3JpYmUpO1xuICAgIH0sXG4gICAgdXNlT3BhcXVlSWRlbnRpZmllcjogZnVuY3Rpb24gKCkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlT3BhcXVlSWRlbnRpZmllcic7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gbW91bnRPcGFxdWVJZGVudGlmaWVyKCk7XG4gICAgfSxcbiAgICB1bnN0YWJsZV9pc05ld1JlY29uY2lsZXI6IGVuYWJsZU5ld1JlY29uY2lsZXJcbiAgfTtcbiAgSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uVXBkYXRlSW5ERVYgPSB7XG4gICAgcmVhZENvbnRleHQ6IGZ1bmN0aW9uIChjb250ZXh0LCBvYnNlcnZlZEJpdHMpIHtcbiAgICAgIHdhcm5JbnZhbGlkQ29udGV4dEFjY2VzcygpO1xuICAgICAgcmV0dXJuIHJlYWRDb250ZXh0KGNvbnRleHQsIG9ic2VydmVkQml0cyk7XG4gICAgfSxcbiAgICB1c2VDYWxsYmFjazogZnVuY3Rpb24gKGNhbGxiYWNrLCBkZXBzKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VDYWxsYmFjayc7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHVwZGF0ZUNhbGxiYWNrKGNhbGxiYWNrLCBkZXBzKTtcbiAgICB9LFxuICAgIHVzZUNvbnRleHQ6IGZ1bmN0aW9uIChjb250ZXh0LCBvYnNlcnZlZEJpdHMpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUNvbnRleHQnO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiByZWFkQ29udGV4dChjb250ZXh0LCBvYnNlcnZlZEJpdHMpO1xuICAgIH0sXG4gICAgdXNlRWZmZWN0OiBmdW5jdGlvbiAoY3JlYXRlLCBkZXBzKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VFZmZlY3QnO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiB1cGRhdGVFZmZlY3QoY3JlYXRlLCBkZXBzKTtcbiAgICB9LFxuICAgIHVzZUltcGVyYXRpdmVIYW5kbGU6IGZ1bmN0aW9uIChyZWYsIGNyZWF0ZSwgZGVwcykge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlSW1wZXJhdGl2ZUhhbmRsZSc7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHVwZGF0ZUltcGVyYXRpdmVIYW5kbGUocmVmLCBjcmVhdGUsIGRlcHMpO1xuICAgIH0sXG4gICAgdXNlTGF5b3V0RWZmZWN0OiBmdW5jdGlvbiAoY3JlYXRlLCBkZXBzKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VMYXlvdXRFZmZlY3QnO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiB1cGRhdGVMYXlvdXRFZmZlY3QoY3JlYXRlLCBkZXBzKTtcbiAgICB9LFxuICAgIHVzZU1lbW86IGZ1bmN0aW9uIChjcmVhdGUsIGRlcHMpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZU1lbW8nO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHZhciBwcmV2RGlzcGF0Y2hlciA9IFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50O1xuICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQgPSBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25VcGRhdGVJbkRFVjtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIHVwZGF0ZU1lbW8oY3JlYXRlLCBkZXBzKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50ID0gcHJldkRpc3BhdGNoZXI7XG4gICAgICB9XG4gICAgfSxcbiAgICB1c2VSZWR1Y2VyOiBmdW5jdGlvbiAocmVkdWNlciwgaW5pdGlhbEFyZywgaW5pdCkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlUmVkdWNlcic7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgdmFyIHByZXZEaXNwYXRjaGVyID0gUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQ7XG4gICAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudCA9IEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPblVwZGF0ZUluREVWO1xuXG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gdXBkYXRlUmVkdWNlcihyZWR1Y2VyLCBpbml0aWFsQXJnLCBpbml0KTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50ID0gcHJldkRpc3BhdGNoZXI7XG4gICAgICB9XG4gICAgfSxcbiAgICB1c2VSZWY6IGZ1bmN0aW9uIChpbml0aWFsVmFsdWUpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZVJlZic7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHVwZGF0ZVJlZigpO1xuICAgIH0sXG4gICAgdXNlU3RhdGU6IGZ1bmN0aW9uIChpbml0aWFsU3RhdGUpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZVN0YXRlJztcbiAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICB2YXIgcHJldkRpc3BhdGNoZXIgPSBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudDtcbiAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50ID0gSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uVXBkYXRlSW5ERVY7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiB1cGRhdGVTdGF0ZShpbml0aWFsU3RhdGUpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQgPSBwcmV2RGlzcGF0Y2hlcjtcbiAgICAgIH1cbiAgICB9LFxuICAgIHVzZURlYnVnVmFsdWU6IGZ1bmN0aW9uICh2YWx1ZSwgZm9ybWF0dGVyRm4pIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZURlYnVnVmFsdWUnO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiB1cGRhdGVEZWJ1Z1ZhbHVlKCk7XG4gICAgfSxcbiAgICB1c2VEZWZlcnJlZFZhbHVlOiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZURlZmVycmVkVmFsdWUnO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiB1cGRhdGVEZWZlcnJlZFZhbHVlKHZhbHVlKTtcbiAgICB9LFxuICAgIHVzZVRyYW5zaXRpb246IGZ1bmN0aW9uICgpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZVRyYW5zaXRpb24nO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiB1cGRhdGVUcmFuc2l0aW9uKCk7XG4gICAgfSxcbiAgICB1c2VNdXRhYmxlU291cmNlOiBmdW5jdGlvbiAoc291cmNlLCBnZXRTbmFwc2hvdCwgc3Vic2NyaWJlKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VNdXRhYmxlU291cmNlJztcbiAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gdXBkYXRlTXV0YWJsZVNvdXJjZShzb3VyY2UsIGdldFNuYXBzaG90LCBzdWJzY3JpYmUpO1xuICAgIH0sXG4gICAgdXNlT3BhcXVlSWRlbnRpZmllcjogZnVuY3Rpb24gKCkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlT3BhcXVlSWRlbnRpZmllcic7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHVwZGF0ZU9wYXF1ZUlkZW50aWZpZXIoKTtcbiAgICB9LFxuICAgIHVuc3RhYmxlX2lzTmV3UmVjb25jaWxlcjogZW5hYmxlTmV3UmVjb25jaWxlclxuICB9O1xuICBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25SZXJlbmRlckluREVWID0ge1xuICAgIHJlYWRDb250ZXh0OiBmdW5jdGlvbiAoY29udGV4dCwgb2JzZXJ2ZWRCaXRzKSB7XG4gICAgICB3YXJuSW52YWxpZENvbnRleHRBY2Nlc3MoKTtcbiAgICAgIHJldHVybiByZWFkQ29udGV4dChjb250ZXh0LCBvYnNlcnZlZEJpdHMpO1xuICAgIH0sXG4gICAgdXNlQ2FsbGJhY2s6IGZ1bmN0aW9uIChjYWxsYmFjaywgZGVwcykge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlQ2FsbGJhY2snO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiB1cGRhdGVDYWxsYmFjayhjYWxsYmFjaywgZGVwcyk7XG4gICAgfSxcbiAgICB1c2VDb250ZXh0OiBmdW5jdGlvbiAoY29udGV4dCwgb2JzZXJ2ZWRCaXRzKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VDb250ZXh0JztcbiAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gcmVhZENvbnRleHQoY29udGV4dCwgb2JzZXJ2ZWRCaXRzKTtcbiAgICB9LFxuICAgIHVzZUVmZmVjdDogZnVuY3Rpb24gKGNyZWF0ZSwgZGVwcykge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlRWZmZWN0JztcbiAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gdXBkYXRlRWZmZWN0KGNyZWF0ZSwgZGVwcyk7XG4gICAgfSxcbiAgICB1c2VJbXBlcmF0aXZlSGFuZGxlOiBmdW5jdGlvbiAocmVmLCBjcmVhdGUsIGRlcHMpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUltcGVyYXRpdmVIYW5kbGUnO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiB1cGRhdGVJbXBlcmF0aXZlSGFuZGxlKHJlZiwgY3JlYXRlLCBkZXBzKTtcbiAgICB9LFxuICAgIHVzZUxheW91dEVmZmVjdDogZnVuY3Rpb24gKGNyZWF0ZSwgZGVwcykge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlTGF5b3V0RWZmZWN0JztcbiAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gdXBkYXRlTGF5b3V0RWZmZWN0KGNyZWF0ZSwgZGVwcyk7XG4gICAgfSxcbiAgICB1c2VNZW1vOiBmdW5jdGlvbiAoY3JlYXRlLCBkZXBzKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VNZW1vJztcbiAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICB2YXIgcHJldkRpc3BhdGNoZXIgPSBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudDtcbiAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50ID0gSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uVXBkYXRlSW5ERVY7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiB1cGRhdGVNZW1vKGNyZWF0ZSwgZGVwcyk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudCA9IHByZXZEaXNwYXRjaGVyO1xuICAgICAgfVxuICAgIH0sXG4gICAgdXNlUmVkdWNlcjogZnVuY3Rpb24gKHJlZHVjZXIsIGluaXRpYWxBcmcsIGluaXQpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZVJlZHVjZXInO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHZhciBwcmV2RGlzcGF0Y2hlciA9IFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50O1xuICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQgPSBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25VcGRhdGVJbkRFVjtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIHJlcmVuZGVyUmVkdWNlcihyZWR1Y2VyLCBpbml0aWFsQXJnLCBpbml0KTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50ID0gcHJldkRpc3BhdGNoZXI7XG4gICAgICB9XG4gICAgfSxcbiAgICB1c2VSZWY6IGZ1bmN0aW9uIChpbml0aWFsVmFsdWUpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZVJlZic7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHVwZGF0ZVJlZigpO1xuICAgIH0sXG4gICAgdXNlU3RhdGU6IGZ1bmN0aW9uIChpbml0aWFsU3RhdGUpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZVN0YXRlJztcbiAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICB2YXIgcHJldkRpc3BhdGNoZXIgPSBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudDtcbiAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50ID0gSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uVXBkYXRlSW5ERVY7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiByZXJlbmRlclN0YXRlKGluaXRpYWxTdGF0ZSk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudCA9IHByZXZEaXNwYXRjaGVyO1xuICAgICAgfVxuICAgIH0sXG4gICAgdXNlRGVidWdWYWx1ZTogZnVuY3Rpb24gKHZhbHVlLCBmb3JtYXR0ZXJGbikge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlRGVidWdWYWx1ZSc7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHVwZGF0ZURlYnVnVmFsdWUoKTtcbiAgICB9LFxuICAgIHVzZURlZmVycmVkVmFsdWU6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlRGVmZXJyZWRWYWx1ZSc7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHJlcmVuZGVyRGVmZXJyZWRWYWx1ZSh2YWx1ZSk7XG4gICAgfSxcbiAgICB1c2VUcmFuc2l0aW9uOiBmdW5jdGlvbiAoKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VUcmFuc2l0aW9uJztcbiAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gcmVyZW5kZXJUcmFuc2l0aW9uKCk7XG4gICAgfSxcbiAgICB1c2VNdXRhYmxlU291cmNlOiBmdW5jdGlvbiAoc291cmNlLCBnZXRTbmFwc2hvdCwgc3Vic2NyaWJlKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VNdXRhYmxlU291cmNlJztcbiAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gdXBkYXRlTXV0YWJsZVNvdXJjZShzb3VyY2UsIGdldFNuYXBzaG90LCBzdWJzY3JpYmUpO1xuICAgIH0sXG4gICAgdXNlT3BhcXVlSWRlbnRpZmllcjogZnVuY3Rpb24gKCkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlT3BhcXVlSWRlbnRpZmllcic7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHJlcmVuZGVyT3BhcXVlSWRlbnRpZmllcigpO1xuICAgIH0sXG4gICAgdW5zdGFibGVfaXNOZXdSZWNvbmNpbGVyOiBlbmFibGVOZXdSZWNvbmNpbGVyXG4gIH07XG59XG5cbnZhciBub3ckMSA9IFNjaGVkdWxlci51bnN0YWJsZV9ub3c7XG52YXIgY29tbWl0VGltZSA9IDA7XG52YXIgcHJvZmlsZXJTdGFydFRpbWUgPSAtMTtcblxuZnVuY3Rpb24gZ2V0Q29tbWl0VGltZSgpIHtcbiAgcmV0dXJuIGNvbW1pdFRpbWU7XG59XG5cbmZ1bmN0aW9uIHJlY29yZENvbW1pdFRpbWUoKSB7XG5cbiAgY29tbWl0VGltZSA9IG5vdyQxKCk7XG59XG5cbmZ1bmN0aW9uIHN0YXJ0UHJvZmlsZXJUaW1lcihmaWJlcikge1xuXG4gIHByb2ZpbGVyU3RhcnRUaW1lID0gbm93JDEoKTtcblxuICBpZiAoZmliZXIuYWN0dWFsU3RhcnRUaW1lIDwgMCkge1xuICAgIGZpYmVyLmFjdHVhbFN0YXJ0VGltZSA9IG5vdyQxKCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gc3RvcFByb2ZpbGVyVGltZXJJZlJ1bm5pbmcoZmliZXIpIHtcblxuICBwcm9maWxlclN0YXJ0VGltZSA9IC0xO1xufVxuXG5mdW5jdGlvbiBzdG9wUHJvZmlsZXJUaW1lcklmUnVubmluZ0FuZFJlY29yZERlbHRhKGZpYmVyLCBvdmVycmlkZUJhc2VUaW1lKSB7XG5cbiAgaWYgKHByb2ZpbGVyU3RhcnRUaW1lID49IDApIHtcbiAgICB2YXIgZWxhcHNlZFRpbWUgPSBub3ckMSgpIC0gcHJvZmlsZXJTdGFydFRpbWU7XG4gICAgZmliZXIuYWN0dWFsRHVyYXRpb24gKz0gZWxhcHNlZFRpbWU7XG5cbiAgICBpZiAob3ZlcnJpZGVCYXNlVGltZSkge1xuICAgICAgZmliZXIuc2VsZkJhc2VEdXJhdGlvbiA9IGVsYXBzZWRUaW1lO1xuICAgIH1cblxuICAgIHByb2ZpbGVyU3RhcnRUaW1lID0gLTE7XG4gIH1cbn1cblxuZnVuY3Rpb24gdHJhbnNmZXJBY3R1YWxEdXJhdGlvbihmaWJlcikge1xuICAvLyBUcmFuc2ZlciB0aW1lIHNwZW50IHJlbmRlcmluZyB0aGVzZSBjaGlsZHJlbiBzbyB3ZSBkb24ndCBsb3NlIGl0XG4gIC8vIGFmdGVyIHdlIHJlcmVuZGVyLiBUaGlzIGlzIHVzZWQgYXMgYSBoZWxwZXIgaW4gc3BlY2lhbCBjYXNlc1xuICAvLyB3aGVyZSB3ZSBzaG91bGQgY291bnQgdGhlIHdvcmsgb2YgbXVsdGlwbGUgcGFzc2VzLlxuICB2YXIgY2hpbGQgPSBmaWJlci5jaGlsZDtcblxuICB3aGlsZSAoY2hpbGQpIHtcbiAgICBmaWJlci5hY3R1YWxEdXJhdGlvbiArPSBjaGlsZC5hY3R1YWxEdXJhdGlvbjtcbiAgICBjaGlsZCA9IGNoaWxkLnNpYmxpbmc7XG4gIH1cbn1cblxudmFyIFJlYWN0Q3VycmVudE93bmVyJDEgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdEN1cnJlbnRPd25lcjtcbnZhciBkaWRSZWNlaXZlVXBkYXRlID0gZmFsc2U7XG52YXIgZGlkV2FybkFib3V0QmFkQ2xhc3M7XG52YXIgZGlkV2FybkFib3V0TW9kdWxlUGF0dGVybkNvbXBvbmVudDtcbnZhciBkaWRXYXJuQWJvdXRDb250ZXh0VHlwZU9uRnVuY3Rpb25Db21wb25lbnQ7XG52YXIgZGlkV2FybkFib3V0R2V0RGVyaXZlZFN0YXRlT25GdW5jdGlvbkNvbXBvbmVudDtcbnZhciBkaWRXYXJuQWJvdXRGdW5jdGlvblJlZnM7XG52YXIgZGlkV2FybkFib3V0UmVhc3NpZ25pbmdQcm9wcztcbnZhciBkaWRXYXJuQWJvdXRSZXZlYWxPcmRlcjtcbnZhciBkaWRXYXJuQWJvdXRUYWlsT3B0aW9ucztcblxue1xuICBkaWRXYXJuQWJvdXRCYWRDbGFzcyA9IHt9O1xuICBkaWRXYXJuQWJvdXRNb2R1bGVQYXR0ZXJuQ29tcG9uZW50ID0ge307XG4gIGRpZFdhcm5BYm91dENvbnRleHRUeXBlT25GdW5jdGlvbkNvbXBvbmVudCA9IHt9O1xuICBkaWRXYXJuQWJvdXRHZXREZXJpdmVkU3RhdGVPbkZ1bmN0aW9uQ29tcG9uZW50ID0ge307XG4gIGRpZFdhcm5BYm91dEZ1bmN0aW9uUmVmcyA9IHt9O1xuICBkaWRXYXJuQWJvdXRSZWFzc2lnbmluZ1Byb3BzID0gZmFsc2U7XG4gIGRpZFdhcm5BYm91dFJldmVhbE9yZGVyID0ge307XG4gIGRpZFdhcm5BYm91dFRhaWxPcHRpb25zID0ge307XG59XG5cbmZ1bmN0aW9uIHJlY29uY2lsZUNoaWxkcmVuKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBuZXh0Q2hpbGRyZW4sIHJlbmRlckxhbmVzKSB7XG4gIGlmIChjdXJyZW50ID09PSBudWxsKSB7XG4gICAgLy8gSWYgdGhpcyBpcyBhIGZyZXNoIG5ldyBjb21wb25lbnQgdGhhdCBoYXNuJ3QgYmVlbiByZW5kZXJlZCB5ZXQsIHdlXG4gICAgLy8gd29uJ3QgdXBkYXRlIGl0cyBjaGlsZCBzZXQgYnkgYXBwbHlpbmcgbWluaW1hbCBzaWRlLWVmZmVjdHMuIEluc3RlYWQsXG4gICAgLy8gd2Ugd2lsbCBhZGQgdGhlbSBhbGwgdG8gdGhlIGNoaWxkIGJlZm9yZSBpdCBnZXRzIHJlbmRlcmVkLiBUaGF0IG1lYW5zXG4gICAgLy8gd2UgY2FuIG9wdGltaXplIHRoaXMgcmVjb25jaWxpYXRpb24gcGFzcyBieSBub3QgdHJhY2tpbmcgc2lkZS1lZmZlY3RzLlxuICAgIHdvcmtJblByb2dyZXNzLmNoaWxkID0gbW91bnRDaGlsZEZpYmVycyh3b3JrSW5Qcm9ncmVzcywgbnVsbCwgbmV4dENoaWxkcmVuLCByZW5kZXJMYW5lcyk7XG4gIH0gZWxzZSB7XG4gICAgLy8gSWYgdGhlIGN1cnJlbnQgY2hpbGQgaXMgdGhlIHNhbWUgYXMgdGhlIHdvcmsgaW4gcHJvZ3Jlc3MsIGl0IG1lYW5zIHRoYXRcbiAgICAvLyB3ZSBoYXZlbid0IHlldCBzdGFydGVkIGFueSB3b3JrIG9uIHRoZXNlIGNoaWxkcmVuLiBUaGVyZWZvcmUsIHdlIHVzZVxuICAgIC8vIHRoZSBjbG9uZSBhbGdvcml0aG0gdG8gY3JlYXRlIGEgY29weSBvZiBhbGwgdGhlIGN1cnJlbnQgY2hpbGRyZW4uXG4gICAgLy8gSWYgd2UgaGFkIGFueSBwcm9ncmVzc2VkIHdvcmsgYWxyZWFkeSwgdGhhdCBpcyBpbnZhbGlkIGF0IHRoaXMgcG9pbnQgc29cbiAgICAvLyBsZXQncyB0aHJvdyBpdCBvdXQuXG4gICAgd29ya0luUHJvZ3Jlc3MuY2hpbGQgPSByZWNvbmNpbGVDaGlsZEZpYmVycyh3b3JrSW5Qcm9ncmVzcywgY3VycmVudC5jaGlsZCwgbmV4dENoaWxkcmVuLCByZW5kZXJMYW5lcyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZm9yY2VVbm1vdW50Q3VycmVudEFuZFJlY29uY2lsZShjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgbmV4dENoaWxkcmVuLCByZW5kZXJMYW5lcykge1xuICAvLyBUaGlzIGZ1bmN0aW9uIGlzIGZvcmsgb2YgcmVjb25jaWxlQ2hpbGRyZW4uIEl0J3MgdXNlZCBpbiBjYXNlcyB3aGVyZSB3ZVxuICAvLyB3YW50IHRvIHJlY29uY2lsZSB3aXRob3V0IG1hdGNoaW5nIGFnYWluc3QgdGhlIGV4aXN0aW5nIHNldC4gVGhpcyBoYXMgdGhlXG4gIC8vIGVmZmVjdCBvZiBhbGwgY3VycmVudCBjaGlsZHJlbiBiZWluZyB1bm1vdW50ZWQ7IGV2ZW4gaWYgdGhlIHR5cGUgYW5kIGtleVxuICAvLyBhcmUgdGhlIHNhbWUsIHRoZSBvbGQgY2hpbGQgaXMgdW5tb3VudGVkIGFuZCBhIG5ldyBjaGlsZCBpcyBjcmVhdGVkLlxuICAvL1xuICAvLyBUbyBkbyB0aGlzLCB3ZSdyZSBnb2luZyB0byBnbyB0aHJvdWdoIHRoZSByZWNvbmNpbGUgYWxnb3JpdGhtIHR3aWNlLiBJblxuICAvLyB0aGUgZmlyc3QgcGFzcywgd2Ugc2NoZWR1bGUgYSBkZWxldGlvbiBmb3IgYWxsIHRoZSBjdXJyZW50IGNoaWxkcmVuIGJ5XG4gIC8vIHBhc3NpbmcgbnVsbC5cbiAgd29ya0luUHJvZ3Jlc3MuY2hpbGQgPSByZWNvbmNpbGVDaGlsZEZpYmVycyh3b3JrSW5Qcm9ncmVzcywgY3VycmVudC5jaGlsZCwgbnVsbCwgcmVuZGVyTGFuZXMpOyAvLyBJbiB0aGUgc2Vjb25kIHBhc3MsIHdlIG1vdW50IHRoZSBuZXcgY2hpbGRyZW4uIFRoZSB0cmljayBoZXJlIGlzIHRoYXQgd2VcbiAgLy8gcGFzcyBudWxsIGluIHBsYWNlIG9mIHdoZXJlIHdlIHVzdWFsbHkgcGFzcyB0aGUgY3VycmVudCBjaGlsZCBzZXQuIFRoaXMgaGFzXG4gIC8vIHRoZSBlZmZlY3Qgb2YgcmVtb3VudGluZyBhbGwgY2hpbGRyZW4gcmVnYXJkbGVzcyBvZiB3aGV0aGVyIHRoZWlyXG4gIC8vIGlkZW50aXRpZXMgbWF0Y2guXG5cbiAgd29ya0luUHJvZ3Jlc3MuY2hpbGQgPSByZWNvbmNpbGVDaGlsZEZpYmVycyh3b3JrSW5Qcm9ncmVzcywgbnVsbCwgbmV4dENoaWxkcmVuLCByZW5kZXJMYW5lcyk7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUZvcndhcmRSZWYoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIENvbXBvbmVudCwgbmV4dFByb3BzLCByZW5kZXJMYW5lcykge1xuICAvLyBUT0RPOiBjdXJyZW50IGNhbiBiZSBub24tbnVsbCBoZXJlIGV2ZW4gaWYgdGhlIGNvbXBvbmVudFxuICAvLyBoYXNuJ3QgeWV0IG1vdW50ZWQuIFRoaXMgaGFwcGVucyBhZnRlciB0aGUgZmlyc3QgcmVuZGVyIHN1c3BlbmRzLlxuICAvLyBXZSdsbCBuZWVkIHRvIGZpZ3VyZSBvdXQgaWYgdGhpcyBpcyBmaW5lIG9yIGNhbiBjYXVzZSBpc3N1ZXMuXG4gIHtcbiAgICBpZiAod29ya0luUHJvZ3Jlc3MudHlwZSAhPT0gd29ya0luUHJvZ3Jlc3MuZWxlbWVudFR5cGUpIHtcbiAgICAgIC8vIExhenkgY29tcG9uZW50IHByb3BzIGNhbid0IGJlIHZhbGlkYXRlZCBpbiBjcmVhdGVFbGVtZW50XG4gICAgICAvLyBiZWNhdXNlIHRoZXkncmUgb25seSBndWFyYW50ZWVkIHRvIGJlIHJlc29sdmVkIGhlcmUuXG4gICAgICB2YXIgaW5uZXJQcm9wVHlwZXMgPSBDb21wb25lbnQucHJvcFR5cGVzO1xuXG4gICAgICBpZiAoaW5uZXJQcm9wVHlwZXMpIHtcbiAgICAgICAgY2hlY2tQcm9wVHlwZXMoaW5uZXJQcm9wVHlwZXMsIG5leHRQcm9wcywgLy8gUmVzb2x2ZWQgcHJvcHNcbiAgICAgICAgJ3Byb3AnLCBnZXRDb21wb25lbnROYW1lKENvbXBvbmVudCkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHZhciByZW5kZXIgPSBDb21wb25lbnQucmVuZGVyO1xuICB2YXIgcmVmID0gd29ya0luUHJvZ3Jlc3MucmVmOyAvLyBUaGUgcmVzdCBpcyBhIGZvcmsgb2YgdXBkYXRlRnVuY3Rpb25Db21wb25lbnRcblxuICB2YXIgbmV4dENoaWxkcmVuO1xuICBwcmVwYXJlVG9SZWFkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpO1xuXG4gIHtcbiAgICBSZWFjdEN1cnJlbnRPd25lciQxLmN1cnJlbnQgPSB3b3JrSW5Qcm9ncmVzcztcbiAgICBzZXRJc1JlbmRlcmluZyh0cnVlKTtcbiAgICBuZXh0Q2hpbGRyZW4gPSByZW5kZXJXaXRoSG9va3MoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlciwgbmV4dFByb3BzLCByZWYsIHJlbmRlckxhbmVzKTtcblxuICAgIGlmICggd29ya0luUHJvZ3Jlc3MubW9kZSAmIFN0cmljdE1vZGUpIHtcbiAgICAgIGRpc2FibGVMb2dzKCk7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIG5leHRDaGlsZHJlbiA9IHJlbmRlcldpdGhIb29rcyhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyLCBuZXh0UHJvcHMsIHJlZiwgcmVuZGVyTGFuZXMpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgcmVlbmFibGVMb2dzKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgc2V0SXNSZW5kZXJpbmcoZmFsc2UpO1xuICB9XG5cbiAgaWYgKGN1cnJlbnQgIT09IG51bGwgJiYgIWRpZFJlY2VpdmVVcGRhdGUpIHtcbiAgICBiYWlsb3V0SG9va3MoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKTtcbiAgICByZXR1cm4gYmFpbG91dE9uQWxyZWFkeUZpbmlzaGVkV29yayhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpO1xuICB9IC8vIFJlYWN0IERldlRvb2xzIHJlYWRzIHRoaXMgZmxhZy5cblxuXG4gIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IFBlcmZvcm1lZFdvcms7XG4gIHJlY29uY2lsZUNoaWxkcmVuKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBuZXh0Q2hpbGRyZW4sIHJlbmRlckxhbmVzKTtcbiAgcmV0dXJuIHdvcmtJblByb2dyZXNzLmNoaWxkO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVNZW1vQ29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBDb21wb25lbnQsIG5leHRQcm9wcywgdXBkYXRlTGFuZXMsIHJlbmRlckxhbmVzKSB7XG4gIGlmIChjdXJyZW50ID09PSBudWxsKSB7XG4gICAgdmFyIHR5cGUgPSBDb21wb25lbnQudHlwZTtcblxuICAgIGlmIChpc1NpbXBsZUZ1bmN0aW9uQ29tcG9uZW50KHR5cGUpICYmIENvbXBvbmVudC5jb21wYXJlID09PSBudWxsICYmIC8vIFNpbXBsZU1lbW9Db21wb25lbnQgY29kZXBhdGggZG9lc24ndCByZXNvbHZlIG91dGVyIHByb3BzIGVpdGhlci5cbiAgICBDb21wb25lbnQuZGVmYXVsdFByb3BzID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHZhciByZXNvbHZlZFR5cGUgPSB0eXBlO1xuXG4gICAgICB7XG4gICAgICAgIHJlc29sdmVkVHlwZSA9IHJlc29sdmVGdW5jdGlvbkZvckhvdFJlbG9hZGluZyh0eXBlKTtcbiAgICAgIH0gLy8gSWYgdGhpcyBpcyBhIHBsYWluIGZ1bmN0aW9uIGNvbXBvbmVudCB3aXRob3V0IGRlZmF1bHQgcHJvcHMsXG4gICAgICAvLyBhbmQgd2l0aCBvbmx5IHRoZSBkZWZhdWx0IHNoYWxsb3cgY29tcGFyaXNvbiwgd2UgdXBncmFkZSBpdFxuICAgICAgLy8gdG8gYSBTaW1wbGVNZW1vQ29tcG9uZW50IHRvIGFsbG93IGZhc3QgcGF0aCB1cGRhdGVzLlxuXG5cbiAgICAgIHdvcmtJblByb2dyZXNzLnRhZyA9IFNpbXBsZU1lbW9Db21wb25lbnQ7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy50eXBlID0gcmVzb2x2ZWRUeXBlO1xuXG4gICAgICB7XG4gICAgICAgIHZhbGlkYXRlRnVuY3Rpb25Db21wb25lbnRJbkRldih3b3JrSW5Qcm9ncmVzcywgdHlwZSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB1cGRhdGVTaW1wbGVNZW1vQ29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZXNvbHZlZFR5cGUsIG5leHRQcm9wcywgdXBkYXRlTGFuZXMsIHJlbmRlckxhbmVzKTtcbiAgICB9XG5cbiAgICB7XG4gICAgICB2YXIgaW5uZXJQcm9wVHlwZXMgPSB0eXBlLnByb3BUeXBlcztcblxuICAgICAgaWYgKGlubmVyUHJvcFR5cGVzKSB7XG4gICAgICAgIC8vIElubmVyIG1lbW8gY29tcG9uZW50IHByb3BzIGFyZW4ndCBjdXJyZW50bHkgdmFsaWRhdGVkIGluIGNyZWF0ZUVsZW1lbnQuXG4gICAgICAgIC8vIFdlIGNvdWxkIG1vdmUgaXQgdGhlcmUsIGJ1dCB3ZSdkIHN0aWxsIG5lZWQgdGhpcyBmb3IgbGF6eSBjb2RlIHBhdGguXG4gICAgICAgIGNoZWNrUHJvcFR5cGVzKGlubmVyUHJvcFR5cGVzLCBuZXh0UHJvcHMsIC8vIFJlc29sdmVkIHByb3BzXG4gICAgICAgICdwcm9wJywgZ2V0Q29tcG9uZW50TmFtZSh0eXBlKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGNoaWxkID0gY3JlYXRlRmliZXJGcm9tVHlwZUFuZFByb3BzKENvbXBvbmVudC50eXBlLCBudWxsLCBuZXh0UHJvcHMsIHdvcmtJblByb2dyZXNzLCB3b3JrSW5Qcm9ncmVzcy5tb2RlLCByZW5kZXJMYW5lcyk7XG4gICAgY2hpbGQucmVmID0gd29ya0luUHJvZ3Jlc3MucmVmO1xuICAgIGNoaWxkLnJldHVybiA9IHdvcmtJblByb2dyZXNzO1xuICAgIHdvcmtJblByb2dyZXNzLmNoaWxkID0gY2hpbGQ7XG4gICAgcmV0dXJuIGNoaWxkO1xuICB9XG5cbiAge1xuICAgIHZhciBfdHlwZSA9IENvbXBvbmVudC50eXBlO1xuICAgIHZhciBfaW5uZXJQcm9wVHlwZXMgPSBfdHlwZS5wcm9wVHlwZXM7XG5cbiAgICBpZiAoX2lubmVyUHJvcFR5cGVzKSB7XG4gICAgICAvLyBJbm5lciBtZW1vIGNvbXBvbmVudCBwcm9wcyBhcmVuJ3QgY3VycmVudGx5IHZhbGlkYXRlZCBpbiBjcmVhdGVFbGVtZW50LlxuICAgICAgLy8gV2UgY291bGQgbW92ZSBpdCB0aGVyZSwgYnV0IHdlJ2Qgc3RpbGwgbmVlZCB0aGlzIGZvciBsYXp5IGNvZGUgcGF0aC5cbiAgICAgIGNoZWNrUHJvcFR5cGVzKF9pbm5lclByb3BUeXBlcywgbmV4dFByb3BzLCAvLyBSZXNvbHZlZCBwcm9wc1xuICAgICAgJ3Byb3AnLCBnZXRDb21wb25lbnROYW1lKF90eXBlKSk7XG4gICAgfVxuICB9XG5cbiAgdmFyIGN1cnJlbnRDaGlsZCA9IGN1cnJlbnQuY2hpbGQ7IC8vIFRoaXMgaXMgYWx3YXlzIGV4YWN0bHkgb25lIGNoaWxkXG5cbiAgaWYgKCFpbmNsdWRlc1NvbWVMYW5lKHVwZGF0ZUxhbmVzLCByZW5kZXJMYW5lcykpIHtcbiAgICAvLyBUaGlzIHdpbGwgYmUgdGhlIHByb3BzIHdpdGggcmVzb2x2ZWQgZGVmYXVsdFByb3BzLFxuICAgIC8vIHVubGlrZSBjdXJyZW50Lm1lbW9pemVkUHJvcHMgd2hpY2ggd2lsbCBiZSB0aGUgdW5yZXNvbHZlZCBvbmVzLlxuICAgIHZhciBwcmV2UHJvcHMgPSBjdXJyZW50Q2hpbGQubWVtb2l6ZWRQcm9wczsgLy8gRGVmYXVsdCB0byBzaGFsbG93IGNvbXBhcmlzb25cblxuICAgIHZhciBjb21wYXJlID0gQ29tcG9uZW50LmNvbXBhcmU7XG4gICAgY29tcGFyZSA9IGNvbXBhcmUgIT09IG51bGwgPyBjb21wYXJlIDogc2hhbGxvd0VxdWFsO1xuXG4gICAgaWYgKGNvbXBhcmUocHJldlByb3BzLCBuZXh0UHJvcHMpICYmIGN1cnJlbnQucmVmID09PSB3b3JrSW5Qcm9ncmVzcy5yZWYpIHtcbiAgICAgIHJldHVybiBiYWlsb3V0T25BbHJlYWR5RmluaXNoZWRXb3JrKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcyk7XG4gICAgfVxuICB9IC8vIFJlYWN0IERldlRvb2xzIHJlYWRzIHRoaXMgZmxhZy5cblxuXG4gIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IFBlcmZvcm1lZFdvcms7XG4gIHZhciBuZXdDaGlsZCA9IGNyZWF0ZVdvcmtJblByb2dyZXNzKGN1cnJlbnRDaGlsZCwgbmV4dFByb3BzKTtcbiAgbmV3Q2hpbGQucmVmID0gd29ya0luUHJvZ3Jlc3MucmVmO1xuICBuZXdDaGlsZC5yZXR1cm4gPSB3b3JrSW5Qcm9ncmVzcztcbiAgd29ya0luUHJvZ3Jlc3MuY2hpbGQgPSBuZXdDaGlsZDtcbiAgcmV0dXJuIG5ld0NoaWxkO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVTaW1wbGVNZW1vQ29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBDb21wb25lbnQsIG5leHRQcm9wcywgdXBkYXRlTGFuZXMsIHJlbmRlckxhbmVzKSB7XG4gIC8vIFRPRE86IGN1cnJlbnQgY2FuIGJlIG5vbi1udWxsIGhlcmUgZXZlbiBpZiB0aGUgY29tcG9uZW50XG4gIC8vIGhhc24ndCB5ZXQgbW91bnRlZC4gVGhpcyBoYXBwZW5zIHdoZW4gdGhlIGlubmVyIHJlbmRlciBzdXNwZW5kcy5cbiAgLy8gV2UnbGwgbmVlZCB0byBmaWd1cmUgb3V0IGlmIHRoaXMgaXMgZmluZSBvciBjYW4gY2F1c2UgaXNzdWVzLlxuICB7XG4gICAgaWYgKHdvcmtJblByb2dyZXNzLnR5cGUgIT09IHdvcmtJblByb2dyZXNzLmVsZW1lbnRUeXBlKSB7XG4gICAgICAvLyBMYXp5IGNvbXBvbmVudCBwcm9wcyBjYW4ndCBiZSB2YWxpZGF0ZWQgaW4gY3JlYXRlRWxlbWVudFxuICAgICAgLy8gYmVjYXVzZSB0aGV5J3JlIG9ubHkgZ3VhcmFudGVlZCB0byBiZSByZXNvbHZlZCBoZXJlLlxuICAgICAgdmFyIG91dGVyTWVtb1R5cGUgPSB3b3JrSW5Qcm9ncmVzcy5lbGVtZW50VHlwZTtcblxuICAgICAgaWYgKG91dGVyTWVtb1R5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0xBWllfVFlQRSkge1xuICAgICAgICAvLyBXZSB3YXJuIHdoZW4geW91IGRlZmluZSBwcm9wVHlwZXMgb24gbGF6eSgpXG4gICAgICAgIC8vIHNvIGxldCdzIGp1c3Qgc2tpcCBvdmVyIGl0IHRvIGZpbmQgbWVtbygpIG91dGVyIHdyYXBwZXIuXG4gICAgICAgIC8vIElubmVyIHByb3BzIGZvciBtZW1vIGFyZSB2YWxpZGF0ZWQgbGF0ZXIuXG4gICAgICAgIHZhciBsYXp5Q29tcG9uZW50ID0gb3V0ZXJNZW1vVHlwZTtcbiAgICAgICAgdmFyIHBheWxvYWQgPSBsYXp5Q29tcG9uZW50Ll9wYXlsb2FkO1xuICAgICAgICB2YXIgaW5pdCA9IGxhenlDb21wb25lbnQuX2luaXQ7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBvdXRlck1lbW9UeXBlID0gaW5pdChwYXlsb2FkKTtcbiAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgIG91dGVyTWVtb1R5cGUgPSBudWxsO1xuICAgICAgICB9IC8vIElubmVyIHByb3BUeXBlcyB3aWxsIGJlIHZhbGlkYXRlZCBpbiB0aGUgZnVuY3Rpb24gY29tcG9uZW50IHBhdGguXG5cblxuICAgICAgICB2YXIgb3V0ZXJQcm9wVHlwZXMgPSBvdXRlck1lbW9UeXBlICYmIG91dGVyTWVtb1R5cGUucHJvcFR5cGVzO1xuXG4gICAgICAgIGlmIChvdXRlclByb3BUeXBlcykge1xuICAgICAgICAgIGNoZWNrUHJvcFR5cGVzKG91dGVyUHJvcFR5cGVzLCBuZXh0UHJvcHMsIC8vIFJlc29sdmVkIChTaW1wbGVNZW1vQ29tcG9uZW50IGhhcyBubyBkZWZhdWx0UHJvcHMpXG4gICAgICAgICAgJ3Byb3AnLCBnZXRDb21wb25lbnROYW1lKG91dGVyTWVtb1R5cGUpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChjdXJyZW50ICE9PSBudWxsKSB7XG4gICAgdmFyIHByZXZQcm9wcyA9IGN1cnJlbnQubWVtb2l6ZWRQcm9wcztcblxuICAgIGlmIChzaGFsbG93RXF1YWwocHJldlByb3BzLCBuZXh0UHJvcHMpICYmIGN1cnJlbnQucmVmID09PSB3b3JrSW5Qcm9ncmVzcy5yZWYgJiYgKCAvLyBQcmV2ZW50IGJhaWxvdXQgaWYgdGhlIGltcGxlbWVudGF0aW9uIGNoYW5nZWQgZHVlIHRvIGhvdCByZWxvYWQuXG4gICAgIHdvcmtJblByb2dyZXNzLnR5cGUgPT09IGN1cnJlbnQudHlwZSApKSB7XG4gICAgICBkaWRSZWNlaXZlVXBkYXRlID0gZmFsc2U7XG5cbiAgICAgIGlmICghaW5jbHVkZXNTb21lTGFuZShyZW5kZXJMYW5lcywgdXBkYXRlTGFuZXMpKSB7XG4gICAgICAgIC8vIFRoZSBwZW5kaW5nIGxhbmVzIHdlcmUgY2xlYXJlZCBhdCB0aGUgYmVnaW5uaW5nIG9mIGJlZ2luV29yay4gV2UncmVcbiAgICAgICAgLy8gYWJvdXQgdG8gYmFpbCBvdXQsIGJ1dCB0aGVyZSBtaWdodCBiZSBvdGhlciBsYW5lcyB0aGF0IHdlcmVuJ3RcbiAgICAgICAgLy8gaW5jbHVkZWQgaW4gdGhlIGN1cnJlbnQgcmVuZGVyLiBVc3VhbGx5LCB0aGUgcHJpb3JpdHkgbGV2ZWwgb2YgdGhlXG4gICAgICAgIC8vIHJlbWFpbmluZyB1cGRhdGVzIGlzIGFjY3VtbGF0ZWQgZHVyaW5nIHRoZSBldmFsdWF0aW9uIG9mIHRoZVxuICAgICAgICAvLyBjb21wb25lbnQgKGkuZS4gd2hlbiBwcm9jZXNzaW5nIHRoZSB1cGRhdGUgcXVldWUpLiBCdXQgc2luY2Ugc2luY2VcbiAgICAgICAgLy8gd2UncmUgYmFpbGluZyBvdXQgZWFybHkgKndpdGhvdXQqIGV2YWx1YXRpbmcgdGhlIGNvbXBvbmVudCwgd2UgbmVlZFxuICAgICAgICAvLyB0byBhY2NvdW50IGZvciBpdCBoZXJlLCB0b28uIFJlc2V0IHRvIHRoZSB2YWx1ZSBvZiB0aGUgY3VycmVudCBmaWJlci5cbiAgICAgICAgLy8gTk9URTogVGhpcyBvbmx5IGFwcGxpZXMgdG8gU2ltcGxlTWVtb0NvbXBvbmVudCwgbm90IE1lbW9Db21wb25lbnQsXG4gICAgICAgIC8vIGJlY2F1c2UgYSBNZW1vQ29tcG9uZW50IGZpYmVyIGRvZXMgbm90IGhhdmUgaG9va3Mgb3IgYW4gdXBkYXRlIHF1ZXVlO1xuICAgICAgICAvLyByYXRoZXIsIGl0IHdyYXBzIGFyb3VuZCBhbiBpbm5lciBjb21wb25lbnQsIHdoaWNoIG1heSBvciBtYXkgbm90XG4gICAgICAgIC8vIGNvbnRhaW5zIGhvb2tzLlxuICAgICAgICAvLyBUT0RPOiBNb3ZlIHRoZSByZXNldCBhdCBpbiBiZWdpbldvcmsgb3V0IG9mIHRoZSBjb21tb24gcGF0aCBzbyB0aGF0XG4gICAgICAgIC8vIHRoaXMgaXMgbm8gbG9uZ2VyIG5lY2Vzc2FyeS5cbiAgICAgICAgd29ya0luUHJvZ3Jlc3MubGFuZXMgPSBjdXJyZW50LmxhbmVzO1xuICAgICAgICByZXR1cm4gYmFpbG91dE9uQWxyZWFkeUZpbmlzaGVkV29yayhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpO1xuICAgICAgfSBlbHNlIGlmICgoY3VycmVudC5mbGFncyAmIEZvcmNlVXBkYXRlRm9yTGVnYWN5U3VzcGVuc2UpICE9PSBOb0ZsYWdzKSB7XG4gICAgICAgIC8vIFRoaXMgaXMgYSBzcGVjaWFsIGNhc2UgdGhhdCBvbmx5IGV4aXN0cyBmb3IgbGVnYWN5IG1vZGUuXG4gICAgICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvcHVsbC8xOTIxNi5cbiAgICAgICAgZGlkUmVjZWl2ZVVwZGF0ZSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHVwZGF0ZUZ1bmN0aW9uQ29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBDb21wb25lbnQsIG5leHRQcm9wcywgcmVuZGVyTGFuZXMpO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVPZmZzY3JlZW5Db21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKSB7XG4gIHZhciBuZXh0UHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHM7XG4gIHZhciBuZXh0Q2hpbGRyZW4gPSBuZXh0UHJvcHMuY2hpbGRyZW47XG4gIHZhciBwcmV2U3RhdGUgPSBjdXJyZW50ICE9PSBudWxsID8gY3VycmVudC5tZW1vaXplZFN0YXRlIDogbnVsbDtcblxuICBpZiAobmV4dFByb3BzLm1vZGUgPT09ICdoaWRkZW4nIHx8IG5leHRQcm9wcy5tb2RlID09PSAndW5zdGFibGUtZGVmZXItd2l0aG91dC1oaWRpbmcnKSB7XG4gICAgaWYgKCh3b3JrSW5Qcm9ncmVzcy5tb2RlICYgQ29uY3VycmVudE1vZGUpID09PSBOb01vZGUpIHtcbiAgICAgIC8vIEluIGxlZ2FjeSBzeW5jIG1vZGUsIGRvbid0IGRlZmVyIHRoZSBzdWJ0cmVlLiBSZW5kZXIgaXQgbm93LlxuICAgICAgLy8gVE9ETzogRmlndXJlIG91dCB3aGF0IHdlIHNob3VsZCBkbyBpbiBCbG9ja2luZyBtb2RlLlxuICAgICAgdmFyIG5leHRTdGF0ZSA9IHtcbiAgICAgICAgYmFzZUxhbmVzOiBOb0xhbmVzXG4gICAgICB9O1xuICAgICAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IG5leHRTdGF0ZTtcbiAgICAgIHB1c2hSZW5kZXJMYW5lcyh3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpO1xuICAgIH0gZWxzZSBpZiAoIWluY2x1ZGVzU29tZUxhbmUocmVuZGVyTGFuZXMsIE9mZnNjcmVlbkxhbmUpKSB7XG4gICAgICB2YXIgbmV4dEJhc2VMYW5lcztcblxuICAgICAgaWYgKHByZXZTdGF0ZSAhPT0gbnVsbCkge1xuICAgICAgICB2YXIgcHJldkJhc2VMYW5lcyA9IHByZXZTdGF0ZS5iYXNlTGFuZXM7XG4gICAgICAgIG5leHRCYXNlTGFuZXMgPSBtZXJnZUxhbmVzKHByZXZCYXNlTGFuZXMsIHJlbmRlckxhbmVzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5leHRCYXNlTGFuZXMgPSByZW5kZXJMYW5lcztcbiAgICAgIH0gLy8gU2NoZWR1bGUgdGhpcyBmaWJlciB0byByZS1yZW5kZXIgYXQgb2Zmc2NyZWVuIHByaW9yaXR5LiBUaGVuIGJhaWxvdXQuXG5cblxuICAgICAge1xuICAgICAgICBtYXJrU3Bhd25lZFdvcmsoT2Zmc2NyZWVuTGFuZSk7XG4gICAgICB9XG5cbiAgICAgIHdvcmtJblByb2dyZXNzLmxhbmVzID0gd29ya0luUHJvZ3Jlc3MuY2hpbGRMYW5lcyA9IGxhbmVUb0xhbmVzKE9mZnNjcmVlbkxhbmUpO1xuICAgICAgdmFyIF9uZXh0U3RhdGUgPSB7XG4gICAgICAgIGJhc2VMYW5lczogbmV4dEJhc2VMYW5lc1xuICAgICAgfTtcbiAgICAgIHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSBfbmV4dFN0YXRlOyAvLyBXZSdyZSBhYm91dCB0byBiYWlsIG91dCwgYnV0IHdlIG5lZWQgdG8gcHVzaCB0aGlzIHRvIHRoZSBzdGFjayBhbnl3YXlcbiAgICAgIC8vIHRvIGF2b2lkIGEgcHVzaC9wb3AgbWlzYWxpZ25tZW50LlxuXG4gICAgICBwdXNoUmVuZGVyTGFuZXMod29ya0luUHJvZ3Jlc3MsIG5leHRCYXNlTGFuZXMpO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFJlbmRlcmluZyBhdCBvZmZzY3JlZW4sIHNvIHdlIGNhbiBjbGVhciB0aGUgYmFzZSBsYW5lcy5cbiAgICAgIHZhciBfbmV4dFN0YXRlMiA9IHtcbiAgICAgICAgYmFzZUxhbmVzOiBOb0xhbmVzXG4gICAgICB9O1xuICAgICAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IF9uZXh0U3RhdGUyOyAvLyBQdXNoIHRoZSBsYW5lcyB0aGF0IHdlcmUgc2tpcHBlZCB3aGVuIHdlIGJhaWxlZCBvdXQuXG5cbiAgICAgIHZhciBzdWJ0cmVlUmVuZGVyTGFuZXMgPSBwcmV2U3RhdGUgIT09IG51bGwgPyBwcmV2U3RhdGUuYmFzZUxhbmVzIDogcmVuZGVyTGFuZXM7XG4gICAgICBwdXNoUmVuZGVyTGFuZXMod29ya0luUHJvZ3Jlc3MsIHN1YnRyZWVSZW5kZXJMYW5lcyk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBfc3VidHJlZVJlbmRlckxhbmVzO1xuXG4gICAgaWYgKHByZXZTdGF0ZSAhPT0gbnVsbCkge1xuICAgICAgX3N1YnRyZWVSZW5kZXJMYW5lcyA9IG1lcmdlTGFuZXMocHJldlN0YXRlLmJhc2VMYW5lcywgcmVuZGVyTGFuZXMpOyAvLyBTaW5jZSB3ZSdyZSBub3QgaGlkZGVuIGFueW1vcmUsIHJlc2V0IHRoZSBzdGF0ZVxuXG4gICAgICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID0gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gV2Ugd2VyZW4ndCBwcmV2aW91c2x5IGhpZGRlbiwgYW5kIHdlIHN0aWxsIGFyZW4ndCwgc28gdGhlcmUncyBub3RoaW5nXG4gICAgICAvLyBzcGVjaWFsIHRvIGRvLiBOZWVkIHRvIHB1c2ggdG8gdGhlIHN0YWNrIHJlZ2FyZGxlc3MsIHRob3VnaCwgdG8gYXZvaWRcbiAgICAgIC8vIGEgcHVzaC9wb3AgbWlzYWxpZ25tZW50LlxuICAgICAgX3N1YnRyZWVSZW5kZXJMYW5lcyA9IHJlbmRlckxhbmVzO1xuICAgIH1cblxuICAgIHB1c2hSZW5kZXJMYW5lcyh3b3JrSW5Qcm9ncmVzcywgX3N1YnRyZWVSZW5kZXJMYW5lcyk7XG4gIH1cblxuICByZWNvbmNpbGVDaGlsZHJlbihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgbmV4dENoaWxkcmVuLCByZW5kZXJMYW5lcyk7XG4gIHJldHVybiB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbn0gLy8gTm90ZTogVGhlc2UgaGFwcGVuIHRvIGhhdmUgaWRlbnRpY2FsIGJlZ2luIHBoYXNlcywgZm9yIG5vdy4gV2Ugc2hvdWxkbid0IGhvbGRcbi8vIG91cnNlbHZlcyB0byB0aGlzIGNvbnN0cmFpbnQsIHRob3VnaC4gSWYgdGhlIGJlaGF2aW9yIGRpdmVyZ2VzLCB3ZSBzaG91bGRcbi8vIGZvcmsgdGhlIGZ1bmN0aW9uLlxuXG5cbnZhciB1cGRhdGVMZWdhY3lIaWRkZW5Db21wb25lbnQgPSB1cGRhdGVPZmZzY3JlZW5Db21wb25lbnQ7XG5cbmZ1bmN0aW9uIHVwZGF0ZUZyYWdtZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcykge1xuICB2YXIgbmV4dENoaWxkcmVuID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzO1xuICByZWNvbmNpbGVDaGlsZHJlbihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgbmV4dENoaWxkcmVuLCByZW5kZXJMYW5lcyk7XG4gIHJldHVybiB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbn1cblxuZnVuY3Rpb24gdXBkYXRlTW9kZShjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpIHtcbiAgdmFyIG5leHRDaGlsZHJlbiA9IHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcy5jaGlsZHJlbjtcbiAgcmVjb25jaWxlQ2hpbGRyZW4oY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIG5leHRDaGlsZHJlbiwgcmVuZGVyTGFuZXMpO1xuICByZXR1cm4gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZVByb2ZpbGVyKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcykge1xuICB7XG4gICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gVXBkYXRlOyAvLyBSZXNldCBlZmZlY3QgZHVyYXRpb25zIGZvciB0aGUgbmV4dCBldmVudHVhbCBlZmZlY3QgcGhhc2UuXG4gICAgLy8gVGhlc2UgYXJlIHJlc2V0IGR1cmluZyByZW5kZXIgdG8gYWxsb3cgdGhlIERldlRvb2xzIGNvbW1pdCBob29rIGEgY2hhbmNlIHRvIHJlYWQgdGhlbSxcblxuICAgIHZhciBzdGF0ZU5vZGUgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG4gICAgc3RhdGVOb2RlLmVmZmVjdER1cmF0aW9uID0gMDtcbiAgICBzdGF0ZU5vZGUucGFzc2l2ZUVmZmVjdER1cmF0aW9uID0gMDtcbiAgfVxuXG4gIHZhciBuZXh0UHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHM7XG4gIHZhciBuZXh0Q2hpbGRyZW4gPSBuZXh0UHJvcHMuY2hpbGRyZW47XG4gIHJlY29uY2lsZUNoaWxkcmVuKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBuZXh0Q2hpbGRyZW4sIHJlbmRlckxhbmVzKTtcbiAgcmV0dXJuIHdvcmtJblByb2dyZXNzLmNoaWxkO1xufVxuXG5mdW5jdGlvbiBtYXJrUmVmKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKSB7XG4gIHZhciByZWYgPSB3b3JrSW5Qcm9ncmVzcy5yZWY7XG5cbiAgaWYgKGN1cnJlbnQgPT09IG51bGwgJiYgcmVmICE9PSBudWxsIHx8IGN1cnJlbnQgIT09IG51bGwgJiYgY3VycmVudC5yZWYgIT09IHJlZikge1xuICAgIC8vIFNjaGVkdWxlIGEgUmVmIGVmZmVjdFxuICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IFJlZjtcbiAgfVxufVxuXG5mdW5jdGlvbiB1cGRhdGVGdW5jdGlvbkNvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgQ29tcG9uZW50LCBuZXh0UHJvcHMsIHJlbmRlckxhbmVzKSB7XG4gIHtcbiAgICBpZiAod29ya0luUHJvZ3Jlc3MudHlwZSAhPT0gd29ya0luUHJvZ3Jlc3MuZWxlbWVudFR5cGUpIHtcbiAgICAgIC8vIExhenkgY29tcG9uZW50IHByb3BzIGNhbid0IGJlIHZhbGlkYXRlZCBpbiBjcmVhdGVFbGVtZW50XG4gICAgICAvLyBiZWNhdXNlIHRoZXkncmUgb25seSBndWFyYW50ZWVkIHRvIGJlIHJlc29sdmVkIGhlcmUuXG4gICAgICB2YXIgaW5uZXJQcm9wVHlwZXMgPSBDb21wb25lbnQucHJvcFR5cGVzO1xuXG4gICAgICBpZiAoaW5uZXJQcm9wVHlwZXMpIHtcbiAgICAgICAgY2hlY2tQcm9wVHlwZXMoaW5uZXJQcm9wVHlwZXMsIG5leHRQcm9wcywgLy8gUmVzb2x2ZWQgcHJvcHNcbiAgICAgICAgJ3Byb3AnLCBnZXRDb21wb25lbnROYW1lKENvbXBvbmVudCkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHZhciBjb250ZXh0O1xuXG4gIHtcbiAgICB2YXIgdW5tYXNrZWRDb250ZXh0ID0gZ2V0VW5tYXNrZWRDb250ZXh0KHdvcmtJblByb2dyZXNzLCBDb21wb25lbnQsIHRydWUpO1xuICAgIGNvbnRleHQgPSBnZXRNYXNrZWRDb250ZXh0KHdvcmtJblByb2dyZXNzLCB1bm1hc2tlZENvbnRleHQpO1xuICB9XG5cbiAgdmFyIG5leHRDaGlsZHJlbjtcbiAgcHJlcGFyZVRvUmVhZENvbnRleHQod29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKTtcblxuICB7XG4gICAgUmVhY3RDdXJyZW50T3duZXIkMS5jdXJyZW50ID0gd29ya0luUHJvZ3Jlc3M7XG4gICAgc2V0SXNSZW5kZXJpbmcodHJ1ZSk7XG4gICAgbmV4dENoaWxkcmVuID0gcmVuZGVyV2l0aEhvb2tzKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBDb21wb25lbnQsIG5leHRQcm9wcywgY29udGV4dCwgcmVuZGVyTGFuZXMpO1xuXG4gICAgaWYgKCB3b3JrSW5Qcm9ncmVzcy5tb2RlICYgU3RyaWN0TW9kZSkge1xuICAgICAgZGlzYWJsZUxvZ3MoKTtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgbmV4dENoaWxkcmVuID0gcmVuZGVyV2l0aEhvb2tzKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBDb21wb25lbnQsIG5leHRQcm9wcywgY29udGV4dCwgcmVuZGVyTGFuZXMpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgcmVlbmFibGVMb2dzKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgc2V0SXNSZW5kZXJpbmcoZmFsc2UpO1xuICB9XG5cbiAgaWYgKGN1cnJlbnQgIT09IG51bGwgJiYgIWRpZFJlY2VpdmVVcGRhdGUpIHtcbiAgICBiYWlsb3V0SG9va3MoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKTtcbiAgICByZXR1cm4gYmFpbG91dE9uQWxyZWFkeUZpbmlzaGVkV29yayhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpO1xuICB9IC8vIFJlYWN0IERldlRvb2xzIHJlYWRzIHRoaXMgZmxhZy5cblxuXG4gIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IFBlcmZvcm1lZFdvcms7XG4gIHJlY29uY2lsZUNoaWxkcmVuKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBuZXh0Q2hpbGRyZW4sIHJlbmRlckxhbmVzKTtcbiAgcmV0dXJuIHdvcmtJblByb2dyZXNzLmNoaWxkO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVDbGFzc0NvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgQ29tcG9uZW50LCBuZXh0UHJvcHMsIHJlbmRlckxhbmVzKSB7XG4gIHtcbiAgICBpZiAod29ya0luUHJvZ3Jlc3MudHlwZSAhPT0gd29ya0luUHJvZ3Jlc3MuZWxlbWVudFR5cGUpIHtcbiAgICAgIC8vIExhenkgY29tcG9uZW50IHByb3BzIGNhbid0IGJlIHZhbGlkYXRlZCBpbiBjcmVhdGVFbGVtZW50XG4gICAgICAvLyBiZWNhdXNlIHRoZXkncmUgb25seSBndWFyYW50ZWVkIHRvIGJlIHJlc29sdmVkIGhlcmUuXG4gICAgICB2YXIgaW5uZXJQcm9wVHlwZXMgPSBDb21wb25lbnQucHJvcFR5cGVzO1xuXG4gICAgICBpZiAoaW5uZXJQcm9wVHlwZXMpIHtcbiAgICAgICAgY2hlY2tQcm9wVHlwZXMoaW5uZXJQcm9wVHlwZXMsIG5leHRQcm9wcywgLy8gUmVzb2x2ZWQgcHJvcHNcbiAgICAgICAgJ3Byb3AnLCBnZXRDb21wb25lbnROYW1lKENvbXBvbmVudCkpO1xuICAgICAgfVxuICAgIH1cbiAgfSAvLyBQdXNoIGNvbnRleHQgcHJvdmlkZXJzIGVhcmx5IHRvIHByZXZlbnQgY29udGV4dCBzdGFjayBtaXNtYXRjaGVzLlxuICAvLyBEdXJpbmcgbW91bnRpbmcgd2UgZG9uJ3Qga25vdyB0aGUgY2hpbGQgY29udGV4dCB5ZXQgYXMgdGhlIGluc3RhbmNlIGRvZXNuJ3QgZXhpc3QuXG4gIC8vIFdlIHdpbGwgaW52YWxpZGF0ZSB0aGUgY2hpbGQgY29udGV4dCBpbiBmaW5pc2hDbGFzc0NvbXBvbmVudCgpIHJpZ2h0IGFmdGVyIHJlbmRlcmluZy5cblxuXG4gIHZhciBoYXNDb250ZXh0O1xuXG4gIGlmIChpc0NvbnRleHRQcm92aWRlcihDb21wb25lbnQpKSB7XG4gICAgaGFzQ29udGV4dCA9IHRydWU7XG4gICAgcHVzaENvbnRleHRQcm92aWRlcih3b3JrSW5Qcm9ncmVzcyk7XG4gIH0gZWxzZSB7XG4gICAgaGFzQ29udGV4dCA9IGZhbHNlO1xuICB9XG5cbiAgcHJlcGFyZVRvUmVhZENvbnRleHQod29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKTtcbiAgdmFyIGluc3RhbmNlID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuICB2YXIgc2hvdWxkVXBkYXRlO1xuXG4gIGlmIChpbnN0YW5jZSA9PT0gbnVsbCkge1xuICAgIGlmIChjdXJyZW50ICE9PSBudWxsKSB7XG4gICAgICAvLyBBIGNsYXNzIGNvbXBvbmVudCB3aXRob3V0IGFuIGluc3RhbmNlIG9ubHkgbW91bnRzIGlmIGl0IHN1c3BlbmRlZFxuICAgICAgLy8gaW5zaWRlIGEgbm9uLWNvbmN1cnJlbnQgdHJlZSwgaW4gYW4gaW5jb25zaXN0ZW50IHN0YXRlLiBXZSB3YW50IHRvXG4gICAgICAvLyB0cmVhdCBpdCBsaWtlIGEgbmV3IG1vdW50LCBldmVuIHRob3VnaCBhbiBlbXB0eSB2ZXJzaW9uIG9mIGl0IGFscmVhZHlcbiAgICAgIC8vIGNvbW1pdHRlZC4gRGlzY29ubmVjdCB0aGUgYWx0ZXJuYXRlIHBvaW50ZXJzLlxuICAgICAgY3VycmVudC5hbHRlcm5hdGUgPSBudWxsO1xuICAgICAgd29ya0luUHJvZ3Jlc3MuYWx0ZXJuYXRlID0gbnVsbDsgLy8gU2luY2UgdGhpcyBpcyBjb25jZXB0dWFsbHkgYSBuZXcgZmliZXIsIHNjaGVkdWxlIGEgUGxhY2VtZW50IGVmZmVjdFxuXG4gICAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSBQbGFjZW1lbnQ7XG4gICAgfSAvLyBJbiB0aGUgaW5pdGlhbCBwYXNzIHdlIG1pZ2h0IG5lZWQgdG8gY29uc3RydWN0IHRoZSBpbnN0YW5jZS5cblxuXG4gICAgY29uc3RydWN0Q2xhc3NJbnN0YW5jZSh3b3JrSW5Qcm9ncmVzcywgQ29tcG9uZW50LCBuZXh0UHJvcHMpO1xuICAgIG1vdW50Q2xhc3NJbnN0YW5jZSh3b3JrSW5Qcm9ncmVzcywgQ29tcG9uZW50LCBuZXh0UHJvcHMsIHJlbmRlckxhbmVzKTtcbiAgICBzaG91bGRVcGRhdGUgPSB0cnVlO1xuICB9IGVsc2UgaWYgKGN1cnJlbnQgPT09IG51bGwpIHtcbiAgICAvLyBJbiBhIHJlc3VtZSwgd2UnbGwgYWxyZWFkeSBoYXZlIGFuIGluc3RhbmNlIHdlIGNhbiByZXVzZS5cbiAgICBzaG91bGRVcGRhdGUgPSByZXN1bWVNb3VudENsYXNzSW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MsIENvbXBvbmVudCwgbmV4dFByb3BzLCByZW5kZXJMYW5lcyk7XG4gIH0gZWxzZSB7XG4gICAgc2hvdWxkVXBkYXRlID0gdXBkYXRlQ2xhc3NJbnN0YW5jZShjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgQ29tcG9uZW50LCBuZXh0UHJvcHMsIHJlbmRlckxhbmVzKTtcbiAgfVxuXG4gIHZhciBuZXh0VW5pdE9mV29yayA9IGZpbmlzaENsYXNzQ29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBDb21wb25lbnQsIHNob3VsZFVwZGF0ZSwgaGFzQ29udGV4dCwgcmVuZGVyTGFuZXMpO1xuXG4gIHtcbiAgICB2YXIgaW5zdCA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcblxuICAgIGlmIChzaG91bGRVcGRhdGUgJiYgaW5zdC5wcm9wcyAhPT0gbmV4dFByb3BzKSB7XG4gICAgICBpZiAoIWRpZFdhcm5BYm91dFJlYXNzaWduaW5nUHJvcHMpIHtcbiAgICAgICAgZXJyb3IoJ0l0IGxvb2tzIGxpa2UgJXMgaXMgcmVhc3NpZ25pbmcgaXRzIG93biBgdGhpcy5wcm9wc2Agd2hpbGUgcmVuZGVyaW5nLiAnICsgJ1RoaXMgaXMgbm90IHN1cHBvcnRlZCBhbmQgY2FuIGxlYWQgdG8gY29uZnVzaW5nIGJ1Z3MuJywgZ2V0Q29tcG9uZW50TmFtZSh3b3JrSW5Qcm9ncmVzcy50eXBlKSB8fCAnYSBjb21wb25lbnQnKTtcbiAgICAgIH1cblxuICAgICAgZGlkV2FybkFib3V0UmVhc3NpZ25pbmdQcm9wcyA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5leHRVbml0T2ZXb3JrO1xufVxuXG5mdW5jdGlvbiBmaW5pc2hDbGFzc0NvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgQ29tcG9uZW50LCBzaG91bGRVcGRhdGUsIGhhc0NvbnRleHQsIHJlbmRlckxhbmVzKSB7XG4gIC8vIFJlZnMgc2hvdWxkIHVwZGF0ZSBldmVuIGlmIHNob3VsZENvbXBvbmVudFVwZGF0ZSByZXR1cm5zIGZhbHNlXG4gIG1hcmtSZWYoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpO1xuICB2YXIgZGlkQ2FwdHVyZUVycm9yID0gKHdvcmtJblByb2dyZXNzLmZsYWdzICYgRGlkQ2FwdHVyZSkgIT09IE5vRmxhZ3M7XG5cbiAgaWYgKCFzaG91bGRVcGRhdGUgJiYgIWRpZENhcHR1cmVFcnJvcikge1xuICAgIC8vIENvbnRleHQgcHJvdmlkZXJzIHNob3VsZCBkZWZlciB0byBzQ1UgZm9yIHJlbmRlcmluZ1xuICAgIGlmIChoYXNDb250ZXh0KSB7XG4gICAgICBpbnZhbGlkYXRlQ29udGV4dFByb3ZpZGVyKHdvcmtJblByb2dyZXNzLCBDb21wb25lbnQsIGZhbHNlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYmFpbG91dE9uQWxyZWFkeUZpbmlzaGVkV29yayhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpO1xuICB9XG5cbiAgdmFyIGluc3RhbmNlID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlOyAvLyBSZXJlbmRlclxuXG4gIFJlYWN0Q3VycmVudE93bmVyJDEuY3VycmVudCA9IHdvcmtJblByb2dyZXNzO1xuICB2YXIgbmV4dENoaWxkcmVuO1xuXG4gIGlmIChkaWRDYXB0dXJlRXJyb3IgJiYgdHlwZW9mIENvbXBvbmVudC5nZXREZXJpdmVkU3RhdGVGcm9tRXJyb3IgIT09ICdmdW5jdGlvbicpIHtcbiAgICAvLyBJZiB3ZSBjYXB0dXJlZCBhbiBlcnJvciwgYnV0IGdldERlcml2ZWRTdGF0ZUZyb21FcnJvciBpcyBub3QgZGVmaW5lZCxcbiAgICAvLyB1bm1vdW50IGFsbCB0aGUgY2hpbGRyZW4uIGNvbXBvbmVudERpZENhdGNoIHdpbGwgc2NoZWR1bGUgYW4gdXBkYXRlIHRvXG4gICAgLy8gcmUtcmVuZGVyIGEgZmFsbGJhY2suIFRoaXMgaXMgdGVtcG9yYXJ5IHVudGlsIHdlIG1pZ3JhdGUgZXZlcnlvbmUgdG9cbiAgICAvLyB0aGUgbmV3IEFQSS5cbiAgICAvLyBUT0RPOiBXYXJuIGluIGEgZnV0dXJlIHJlbGVhc2UuXG4gICAgbmV4dENoaWxkcmVuID0gbnVsbDtcblxuICAgIHtcbiAgICAgIHN0b3BQcm9maWxlclRpbWVySWZSdW5uaW5nKCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHtcbiAgICAgIHNldElzUmVuZGVyaW5nKHRydWUpO1xuICAgICAgbmV4dENoaWxkcmVuID0gaW5zdGFuY2UucmVuZGVyKCk7XG5cbiAgICAgIGlmICggd29ya0luUHJvZ3Jlc3MubW9kZSAmIFN0cmljdE1vZGUpIHtcbiAgICAgICAgZGlzYWJsZUxvZ3MoKTtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgIGluc3RhbmNlLnJlbmRlcigpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIHJlZW5hYmxlTG9ncygpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHNldElzUmVuZGVyaW5nKGZhbHNlKTtcbiAgICB9XG4gIH0gLy8gUmVhY3QgRGV2VG9vbHMgcmVhZHMgdGhpcyBmbGFnLlxuXG5cbiAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gUGVyZm9ybWVkV29yaztcblxuICBpZiAoY3VycmVudCAhPT0gbnVsbCAmJiBkaWRDYXB0dXJlRXJyb3IpIHtcbiAgICAvLyBJZiB3ZSdyZSByZWNvdmVyaW5nIGZyb20gYW4gZXJyb3IsIHJlY29uY2lsZSB3aXRob3V0IHJldXNpbmcgYW55IG9mXG4gICAgLy8gdGhlIGV4aXN0aW5nIGNoaWxkcmVuLiBDb25jZXB0dWFsbHksIHRoZSBub3JtYWwgY2hpbGRyZW4gYW5kIHRoZSBjaGlsZHJlblxuICAgIC8vIHRoYXQgYXJlIHNob3duIG9uIGVycm9yIGFyZSB0d28gZGlmZmVyZW50IHNldHMsIHNvIHdlIHNob3VsZG4ndCByZXVzZVxuICAgIC8vIG5vcm1hbCBjaGlsZHJlbiBldmVuIGlmIHRoZWlyIGlkZW50aXRpZXMgbWF0Y2guXG4gICAgZm9yY2VVbm1vdW50Q3VycmVudEFuZFJlY29uY2lsZShjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgbmV4dENoaWxkcmVuLCByZW5kZXJMYW5lcyk7XG4gIH0gZWxzZSB7XG4gICAgcmVjb25jaWxlQ2hpbGRyZW4oY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIG5leHRDaGlsZHJlbiwgcmVuZGVyTGFuZXMpO1xuICB9IC8vIE1lbW9pemUgc3RhdGUgdXNpbmcgdGhlIHZhbHVlcyB3ZSBqdXN0IHVzZWQgdG8gcmVuZGVyLlxuICAvLyBUT0RPOiBSZXN0cnVjdHVyZSBzbyB3ZSBuZXZlciByZWFkIHZhbHVlcyBmcm9tIHRoZSBpbnN0YW5jZS5cblxuXG4gIHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSBpbnN0YW5jZS5zdGF0ZTsgLy8gVGhlIGNvbnRleHQgbWlnaHQgaGF2ZSBjaGFuZ2VkIHNvIHdlIG5lZWQgdG8gcmVjYWxjdWxhdGUgaXQuXG5cbiAgaWYgKGhhc0NvbnRleHQpIHtcbiAgICBpbnZhbGlkYXRlQ29udGV4dFByb3ZpZGVyKHdvcmtJblByb2dyZXNzLCBDb21wb25lbnQsIHRydWUpO1xuICB9XG5cbiAgcmV0dXJuIHdvcmtJblByb2dyZXNzLmNoaWxkO1xufVxuXG5mdW5jdGlvbiBwdXNoSG9zdFJvb3RDb250ZXh0KHdvcmtJblByb2dyZXNzKSB7XG4gIHZhciByb290ID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuXG4gIGlmIChyb290LnBlbmRpbmdDb250ZXh0KSB7XG4gICAgcHVzaFRvcExldmVsQ29udGV4dE9iamVjdCh3b3JrSW5Qcm9ncmVzcywgcm9vdC5wZW5kaW5nQ29udGV4dCwgcm9vdC5wZW5kaW5nQ29udGV4dCAhPT0gcm9vdC5jb250ZXh0KTtcbiAgfSBlbHNlIGlmIChyb290LmNvbnRleHQpIHtcbiAgICAvLyBTaG91bGQgYWx3YXlzIGJlIHNldFxuICAgIHB1c2hUb3BMZXZlbENvbnRleHRPYmplY3Qod29ya0luUHJvZ3Jlc3MsIHJvb3QuY29udGV4dCwgZmFsc2UpO1xuICB9XG5cbiAgcHVzaEhvc3RDb250YWluZXIod29ya0luUHJvZ3Jlc3MsIHJvb3QuY29udGFpbmVySW5mbyk7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUhvc3RSb290KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcykge1xuICBwdXNoSG9zdFJvb3RDb250ZXh0KHdvcmtJblByb2dyZXNzKTtcbiAgdmFyIHVwZGF0ZVF1ZXVlID0gd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWU7XG5cbiAgaWYgKCEoY3VycmVudCAhPT0gbnVsbCAmJiB1cGRhdGVRdWV1ZSAhPT0gbnVsbCkpIHtcbiAgICB7XG4gICAgICB0aHJvdyBFcnJvciggXCJJZiB0aGUgcm9vdCBkb2VzIG5vdCBoYXZlIGFuIHVwZGF0ZVF1ZXVlLCB3ZSBzaG91bGQgaGF2ZSBhbHJlYWR5IGJhaWxlZCBvdXQuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCIgKTtcbiAgICB9XG4gIH1cblxuICB2YXIgbmV4dFByb3BzID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzO1xuICB2YXIgcHJldlN0YXRlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTtcbiAgdmFyIHByZXZDaGlsZHJlbiA9IHByZXZTdGF0ZSAhPT0gbnVsbCA/IHByZXZTdGF0ZS5lbGVtZW50IDogbnVsbDtcbiAgY2xvbmVVcGRhdGVRdWV1ZShjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcyk7XG4gIHByb2Nlc3NVcGRhdGVRdWV1ZSh3b3JrSW5Qcm9ncmVzcywgbmV4dFByb3BzLCBudWxsLCByZW5kZXJMYW5lcyk7XG4gIHZhciBuZXh0U3RhdGUgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlOyAvLyBDYXV0aW9uOiBSZWFjdCBEZXZUb29scyBjdXJyZW50bHkgZGVwZW5kcyBvbiB0aGlzIHByb3BlcnR5XG4gIC8vIGJlaW5nIGNhbGxlZCBcImVsZW1lbnRcIi5cblxuICB2YXIgbmV4dENoaWxkcmVuID0gbmV4dFN0YXRlLmVsZW1lbnQ7XG5cbiAgaWYgKG5leHRDaGlsZHJlbiA9PT0gcHJldkNoaWxkcmVuKSB7XG4gICAgcmVzZXRIeWRyYXRpb25TdGF0ZSgpO1xuICAgIHJldHVybiBiYWlsb3V0T25BbHJlYWR5RmluaXNoZWRXb3JrKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcyk7XG4gIH1cblxuICB2YXIgcm9vdCA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcblxuICBpZiAocm9vdC5oeWRyYXRlICYmIGVudGVySHlkcmF0aW9uU3RhdGUod29ya0luUHJvZ3Jlc3MpKSB7XG4gICAgLy8gSWYgd2UgZG9uJ3QgaGF2ZSBhbnkgY3VycmVudCBjaGlsZHJlbiB0aGlzIG1pZ2h0IGJlIHRoZSBmaXJzdCBwYXNzLlxuICAgIC8vIFdlIGFsd2F5cyB0cnkgdG8gaHlkcmF0ZS4gSWYgdGhpcyBpc24ndCBhIGh5ZHJhdGlvbiBwYXNzIHRoZXJlIHdvbid0XG4gICAgLy8gYmUgYW55IGNoaWxkcmVuIHRvIGh5ZHJhdGUgd2hpY2ggaXMgZWZmZWN0aXZlbHkgdGhlIHNhbWUgdGhpbmcgYXNcbiAgICAvLyBub3QgaHlkcmF0aW5nLlxuICAgIHtcbiAgICAgIHZhciBtdXRhYmxlU291cmNlRWFnZXJIeWRyYXRpb25EYXRhID0gcm9vdC5tdXRhYmxlU291cmNlRWFnZXJIeWRyYXRpb25EYXRhO1xuXG4gICAgICBpZiAobXV0YWJsZVNvdXJjZUVhZ2VySHlkcmF0aW9uRGF0YSAhPSBudWxsKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbXV0YWJsZVNvdXJjZUVhZ2VySHlkcmF0aW9uRGF0YS5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgICAgIHZhciBtdXRhYmxlU291cmNlID0gbXV0YWJsZVNvdXJjZUVhZ2VySHlkcmF0aW9uRGF0YVtpXTtcbiAgICAgICAgICB2YXIgdmVyc2lvbiA9IG11dGFibGVTb3VyY2VFYWdlckh5ZHJhdGlvbkRhdGFbaSArIDFdO1xuICAgICAgICAgIHNldFdvcmtJblByb2dyZXNzVmVyc2lvbihtdXRhYmxlU291cmNlLCB2ZXJzaW9uKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBjaGlsZCA9IG1vdW50Q2hpbGRGaWJlcnMod29ya0luUHJvZ3Jlc3MsIG51bGwsIG5leHRDaGlsZHJlbiwgcmVuZGVyTGFuZXMpO1xuICAgIHdvcmtJblByb2dyZXNzLmNoaWxkID0gY2hpbGQ7XG4gICAgdmFyIG5vZGUgPSBjaGlsZDtcblxuICAgIHdoaWxlIChub2RlKSB7XG4gICAgICAvLyBNYXJrIGVhY2ggY2hpbGQgYXMgaHlkcmF0aW5nLiBUaGlzIGlzIGEgZmFzdCBwYXRoIHRvIGtub3cgd2hldGhlciB0aGlzXG4gICAgICAvLyB0cmVlIGlzIHBhcnQgb2YgYSBoeWRyYXRpbmcgdHJlZS4gVGhpcyBpcyB1c2VkIHRvIGRldGVybWluZSBpZiBhIGNoaWxkXG4gICAgICAvLyBub2RlIGhhcyBmdWxseSBtb3VudGVkIHlldCwgYW5kIGZvciBzY2hlZHVsaW5nIGV2ZW50IHJlcGxheWluZy5cbiAgICAgIC8vIENvbmNlcHR1YWxseSB0aGlzIGlzIHNpbWlsYXIgdG8gUGxhY2VtZW50IGluIHRoYXQgYSBuZXcgc3VidHJlZSBpc1xuICAgICAgLy8gaW5zZXJ0ZWQgaW50byB0aGUgUmVhY3QgdHJlZSBoZXJlLiBJdCBqdXN0IGhhcHBlbnMgdG8gbm90IG5lZWQgRE9NXG4gICAgICAvLyBtdXRhdGlvbnMgYmVjYXVzZSBpdCBhbHJlYWR5IGV4aXN0cy5cbiAgICAgIG5vZGUuZmxhZ3MgPSBub2RlLmZsYWdzICYgflBsYWNlbWVudCB8IEh5ZHJhdGluZztcbiAgICAgIG5vZGUgPSBub2RlLnNpYmxpbmc7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIE90aGVyd2lzZSByZXNldCBoeWRyYXRpb24gc3RhdGUgaW4gY2FzZSB3ZSBhYm9ydGVkIGFuZCByZXN1bWVkIGFub3RoZXJcbiAgICAvLyByb290LlxuICAgIHJlY29uY2lsZUNoaWxkcmVuKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBuZXh0Q2hpbGRyZW4sIHJlbmRlckxhbmVzKTtcbiAgICByZXNldEh5ZHJhdGlvblN0YXRlKCk7XG4gIH1cblxuICByZXR1cm4gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUhvc3RDb21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKSB7XG4gIHB1c2hIb3N0Q29udGV4dCh3b3JrSW5Qcm9ncmVzcyk7XG5cbiAgaWYgKGN1cnJlbnQgPT09IG51bGwpIHtcbiAgICB0cnlUb0NsYWltTmV4dEh5ZHJhdGFibGVJbnN0YW5jZSh3b3JrSW5Qcm9ncmVzcyk7XG4gIH1cblxuICB2YXIgdHlwZSA9IHdvcmtJblByb2dyZXNzLnR5cGU7XG4gIHZhciBuZXh0UHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHM7XG4gIHZhciBwcmV2UHJvcHMgPSBjdXJyZW50ICE9PSBudWxsID8gY3VycmVudC5tZW1vaXplZFByb3BzIDogbnVsbDtcbiAgdmFyIG5leHRDaGlsZHJlbiA9IG5leHRQcm9wcy5jaGlsZHJlbjtcbiAgdmFyIGlzRGlyZWN0VGV4dENoaWxkID0gc2hvdWxkU2V0VGV4dENvbnRlbnQodHlwZSwgbmV4dFByb3BzKTtcblxuICBpZiAoaXNEaXJlY3RUZXh0Q2hpbGQpIHtcbiAgICAvLyBXZSBzcGVjaWFsIGNhc2UgYSBkaXJlY3QgdGV4dCBjaGlsZCBvZiBhIGhvc3Qgbm9kZS4gVGhpcyBpcyBhIGNvbW1vblxuICAgIC8vIGNhc2UuIFdlIHdvbid0IGhhbmRsZSBpdCBhcyBhIHJlaWZpZWQgY2hpbGQuIFdlIHdpbGwgaW5zdGVhZCBoYW5kbGVcbiAgICAvLyB0aGlzIGluIHRoZSBob3N0IGVudmlyb25tZW50IHRoYXQgYWxzbyBoYXMgYWNjZXNzIHRvIHRoaXMgcHJvcC4gVGhhdFxuICAgIC8vIGF2b2lkcyBhbGxvY2F0aW5nIGFub3RoZXIgSG9zdFRleHQgZmliZXIgYW5kIHRyYXZlcnNpbmcgaXQuXG4gICAgbmV4dENoaWxkcmVuID0gbnVsbDtcbiAgfSBlbHNlIGlmIChwcmV2UHJvcHMgIT09IG51bGwgJiYgc2hvdWxkU2V0VGV4dENvbnRlbnQodHlwZSwgcHJldlByb3BzKSkge1xuICAgIC8vIElmIHdlJ3JlIHN3aXRjaGluZyBmcm9tIGEgZGlyZWN0IHRleHQgY2hpbGQgdG8gYSBub3JtYWwgY2hpbGQsIG9yIHRvXG4gICAgLy8gZW1wdHksIHdlIG5lZWQgdG8gc2NoZWR1bGUgdGhlIHRleHQgY29udGVudCB0byBiZSByZXNldC5cbiAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSBDb250ZW50UmVzZXQ7XG4gIH1cblxuICBtYXJrUmVmKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKTtcbiAgcmVjb25jaWxlQ2hpbGRyZW4oY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIG5leHRDaGlsZHJlbiwgcmVuZGVyTGFuZXMpO1xuICByZXR1cm4gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUhvc3RUZXh0KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKSB7XG4gIGlmIChjdXJyZW50ID09PSBudWxsKSB7XG4gICAgdHJ5VG9DbGFpbU5leHRIeWRyYXRhYmxlSW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MpO1xuICB9IC8vIE5vdGhpbmcgdG8gZG8gaGVyZS4gVGhpcyBpcyB0ZXJtaW5hbC4gV2UnbGwgZG8gdGhlIGNvbXBsZXRpb24gc3RlcFxuICAvLyBpbW1lZGlhdGVseSBhZnRlci5cblxuXG4gIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiBtb3VudExhenlDb21wb25lbnQoX2N1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBlbGVtZW50VHlwZSwgdXBkYXRlTGFuZXMsIHJlbmRlckxhbmVzKSB7XG4gIGlmIChfY3VycmVudCAhPT0gbnVsbCkge1xuICAgIC8vIEEgbGF6eSBjb21wb25lbnQgb25seSBtb3VudHMgaWYgaXQgc3VzcGVuZGVkIGluc2lkZSBhIG5vbi1cbiAgICAvLyBjb25jdXJyZW50IHRyZWUsIGluIGFuIGluY29uc2lzdGVudCBzdGF0ZS4gV2Ugd2FudCB0byB0cmVhdCBpdCBsaWtlXG4gICAgLy8gYSBuZXcgbW91bnQsIGV2ZW4gdGhvdWdoIGFuIGVtcHR5IHZlcnNpb24gb2YgaXQgYWxyZWFkeSBjb21taXR0ZWQuXG4gICAgLy8gRGlzY29ubmVjdCB0aGUgYWx0ZXJuYXRlIHBvaW50ZXJzLlxuICAgIF9jdXJyZW50LmFsdGVybmF0ZSA9IG51bGw7XG4gICAgd29ya0luUHJvZ3Jlc3MuYWx0ZXJuYXRlID0gbnVsbDsgLy8gU2luY2UgdGhpcyBpcyBjb25jZXB0dWFsbHkgYSBuZXcgZmliZXIsIHNjaGVkdWxlIGEgUGxhY2VtZW50IGVmZmVjdFxuXG4gICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gUGxhY2VtZW50O1xuICB9XG5cbiAgdmFyIHByb3BzID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzO1xuICB2YXIgbGF6eUNvbXBvbmVudCA9IGVsZW1lbnRUeXBlO1xuICB2YXIgcGF5bG9hZCA9IGxhenlDb21wb25lbnQuX3BheWxvYWQ7XG4gIHZhciBpbml0ID0gbGF6eUNvbXBvbmVudC5faW5pdDtcbiAgdmFyIENvbXBvbmVudCA9IGluaXQocGF5bG9hZCk7IC8vIFN0b3JlIHRoZSB1bndyYXBwZWQgY29tcG9uZW50IGluIHRoZSB0eXBlLlxuXG4gIHdvcmtJblByb2dyZXNzLnR5cGUgPSBDb21wb25lbnQ7XG4gIHZhciByZXNvbHZlZFRhZyA9IHdvcmtJblByb2dyZXNzLnRhZyA9IHJlc29sdmVMYXp5Q29tcG9uZW50VGFnKENvbXBvbmVudCk7XG4gIHZhciByZXNvbHZlZFByb3BzID0gcmVzb2x2ZURlZmF1bHRQcm9wcyhDb21wb25lbnQsIHByb3BzKTtcbiAgdmFyIGNoaWxkO1xuXG4gIHN3aXRjaCAocmVzb2x2ZWRUYWcpIHtcbiAgICBjYXNlIEZ1bmN0aW9uQ29tcG9uZW50OlxuICAgICAge1xuICAgICAgICB7XG4gICAgICAgICAgdmFsaWRhdGVGdW5jdGlvbkNvbXBvbmVudEluRGV2KHdvcmtJblByb2dyZXNzLCBDb21wb25lbnQpO1xuICAgICAgICAgIHdvcmtJblByb2dyZXNzLnR5cGUgPSBDb21wb25lbnQgPSByZXNvbHZlRnVuY3Rpb25Gb3JIb3RSZWxvYWRpbmcoQ29tcG9uZW50KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNoaWxkID0gdXBkYXRlRnVuY3Rpb25Db21wb25lbnQobnVsbCwgd29ya0luUHJvZ3Jlc3MsIENvbXBvbmVudCwgcmVzb2x2ZWRQcm9wcywgcmVuZGVyTGFuZXMpO1xuICAgICAgICByZXR1cm4gY2hpbGQ7XG4gICAgICB9XG5cbiAgICBjYXNlIENsYXNzQ29tcG9uZW50OlxuICAgICAge1xuICAgICAgICB7XG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3MudHlwZSA9IENvbXBvbmVudCA9IHJlc29sdmVDbGFzc0ZvckhvdFJlbG9hZGluZyhDb21wb25lbnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgY2hpbGQgPSB1cGRhdGVDbGFzc0NvbXBvbmVudChudWxsLCB3b3JrSW5Qcm9ncmVzcywgQ29tcG9uZW50LCByZXNvbHZlZFByb3BzLCByZW5kZXJMYW5lcyk7XG4gICAgICAgIHJldHVybiBjaGlsZDtcbiAgICAgIH1cblxuICAgIGNhc2UgRm9yd2FyZFJlZjpcbiAgICAgIHtcbiAgICAgICAge1xuICAgICAgICAgIHdvcmtJblByb2dyZXNzLnR5cGUgPSBDb21wb25lbnQgPSByZXNvbHZlRm9yd2FyZFJlZkZvckhvdFJlbG9hZGluZyhDb21wb25lbnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgY2hpbGQgPSB1cGRhdGVGb3J3YXJkUmVmKG51bGwsIHdvcmtJblByb2dyZXNzLCBDb21wb25lbnQsIHJlc29sdmVkUHJvcHMsIHJlbmRlckxhbmVzKTtcbiAgICAgICAgcmV0dXJuIGNoaWxkO1xuICAgICAgfVxuXG4gICAgY2FzZSBNZW1vQ29tcG9uZW50OlxuICAgICAge1xuICAgICAgICB7XG4gICAgICAgICAgaWYgKHdvcmtJblByb2dyZXNzLnR5cGUgIT09IHdvcmtJblByb2dyZXNzLmVsZW1lbnRUeXBlKSB7XG4gICAgICAgICAgICB2YXIgb3V0ZXJQcm9wVHlwZXMgPSBDb21wb25lbnQucHJvcFR5cGVzO1xuXG4gICAgICAgICAgICBpZiAob3V0ZXJQcm9wVHlwZXMpIHtcbiAgICAgICAgICAgICAgY2hlY2tQcm9wVHlwZXMob3V0ZXJQcm9wVHlwZXMsIHJlc29sdmVkUHJvcHMsIC8vIFJlc29sdmVkIGZvciBvdXRlciBvbmx5XG4gICAgICAgICAgICAgICdwcm9wJywgZ2V0Q29tcG9uZW50TmFtZShDb21wb25lbnQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjaGlsZCA9IHVwZGF0ZU1lbW9Db21wb25lbnQobnVsbCwgd29ya0luUHJvZ3Jlc3MsIENvbXBvbmVudCwgcmVzb2x2ZURlZmF1bHRQcm9wcyhDb21wb25lbnQudHlwZSwgcmVzb2x2ZWRQcm9wcyksIC8vIFRoZSBpbm5lciB0eXBlIGNhbiBoYXZlIGRlZmF1bHRzIHRvb1xuICAgICAgICB1cGRhdGVMYW5lcywgcmVuZGVyTGFuZXMpO1xuICAgICAgICByZXR1cm4gY2hpbGQ7XG4gICAgICB9XG4gIH1cblxuICB2YXIgaGludCA9ICcnO1xuXG4gIHtcbiAgICBpZiAoQ29tcG9uZW50ICE9PSBudWxsICYmIHR5cGVvZiBDb21wb25lbnQgPT09ICdvYmplY3QnICYmIENvbXBvbmVudC4kJHR5cGVvZiA9PT0gUkVBQ1RfTEFaWV9UWVBFKSB7XG4gICAgICBoaW50ID0gJyBEaWQgeW91IHdyYXAgYSBjb21wb25lbnQgaW4gUmVhY3QubGF6eSgpIG1vcmUgdGhhbiBvbmNlPyc7XG4gICAgfVxuICB9IC8vIFRoaXMgbWVzc2FnZSBpbnRlbnRpb25hbGx5IGRvZXNuJ3QgbWVudGlvbiBGb3J3YXJkUmVmIG9yIE1lbW9Db21wb25lbnRcbiAgLy8gYmVjYXVzZSB0aGUgZmFjdCB0aGF0IGl0J3MgYSBzZXBhcmF0ZSB0eXBlIG9mIHdvcmsgaXMgYW5cbiAgLy8gaW1wbGVtZW50YXRpb24gZGV0YWlsLlxuXG5cbiAge1xuICAgIHtcbiAgICAgIHRocm93IEVycm9yKCBcIkVsZW1lbnQgdHlwZSBpcyBpbnZhbGlkLiBSZWNlaXZlZCBhIHByb21pc2UgdGhhdCByZXNvbHZlcyB0bzogXCIgKyBDb21wb25lbnQgKyBcIi4gTGF6eSBlbGVtZW50IHR5cGUgbXVzdCByZXNvbHZlIHRvIGEgY2xhc3Mgb3IgZnVuY3Rpb24uXCIgKyBoaW50ICk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIG1vdW50SW5jb21wbGV0ZUNsYXNzQ29tcG9uZW50KF9jdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgQ29tcG9uZW50LCBuZXh0UHJvcHMsIHJlbmRlckxhbmVzKSB7XG4gIGlmIChfY3VycmVudCAhPT0gbnVsbCkge1xuICAgIC8vIEFuIGluY29tcGxldGUgY29tcG9uZW50IG9ubHkgbW91bnRzIGlmIGl0IHN1c3BlbmRlZCBpbnNpZGUgYSBub24tXG4gICAgLy8gY29uY3VycmVudCB0cmVlLCBpbiBhbiBpbmNvbnNpc3RlbnQgc3RhdGUuIFdlIHdhbnQgdG8gdHJlYXQgaXQgbGlrZVxuICAgIC8vIGEgbmV3IG1vdW50LCBldmVuIHRob3VnaCBhbiBlbXB0eSB2ZXJzaW9uIG9mIGl0IGFscmVhZHkgY29tbWl0dGVkLlxuICAgIC8vIERpc2Nvbm5lY3QgdGhlIGFsdGVybmF0ZSBwb2ludGVycy5cbiAgICBfY3VycmVudC5hbHRlcm5hdGUgPSBudWxsO1xuICAgIHdvcmtJblByb2dyZXNzLmFsdGVybmF0ZSA9IG51bGw7IC8vIFNpbmNlIHRoaXMgaXMgY29uY2VwdHVhbGx5IGEgbmV3IGZpYmVyLCBzY2hlZHVsZSBhIFBsYWNlbWVudCBlZmZlY3RcblxuICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IFBsYWNlbWVudDtcbiAgfSAvLyBQcm9tb3RlIHRoZSBmaWJlciB0byBhIGNsYXNzIGFuZCB0cnkgcmVuZGVyaW5nIGFnYWluLlxuXG5cbiAgd29ya0luUHJvZ3Jlc3MudGFnID0gQ2xhc3NDb21wb25lbnQ7IC8vIFRoZSByZXN0IG9mIHRoaXMgZnVuY3Rpb24gaXMgYSBmb3JrIG9mIGB1cGRhdGVDbGFzc0NvbXBvbmVudGBcbiAgLy8gUHVzaCBjb250ZXh0IHByb3ZpZGVycyBlYXJseSB0byBwcmV2ZW50IGNvbnRleHQgc3RhY2sgbWlzbWF0Y2hlcy5cbiAgLy8gRHVyaW5nIG1vdW50aW5nIHdlIGRvbid0IGtub3cgdGhlIGNoaWxkIGNvbnRleHQgeWV0IGFzIHRoZSBpbnN0YW5jZSBkb2Vzbid0IGV4aXN0LlxuICAvLyBXZSB3aWxsIGludmFsaWRhdGUgdGhlIGNoaWxkIGNvbnRleHQgaW4gZmluaXNoQ2xhc3NDb21wb25lbnQoKSByaWdodCBhZnRlciByZW5kZXJpbmcuXG5cbiAgdmFyIGhhc0NvbnRleHQ7XG5cbiAgaWYgKGlzQ29udGV4dFByb3ZpZGVyKENvbXBvbmVudCkpIHtcbiAgICBoYXNDb250ZXh0ID0gdHJ1ZTtcbiAgICBwdXNoQ29udGV4dFByb3ZpZGVyKHdvcmtJblByb2dyZXNzKTtcbiAgfSBlbHNlIHtcbiAgICBoYXNDb250ZXh0ID0gZmFsc2U7XG4gIH1cblxuICBwcmVwYXJlVG9SZWFkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpO1xuICBjb25zdHJ1Y3RDbGFzc0luc3RhbmNlKHdvcmtJblByb2dyZXNzLCBDb21wb25lbnQsIG5leHRQcm9wcyk7XG4gIG1vdW50Q2xhc3NJbnN0YW5jZSh3b3JrSW5Qcm9ncmVzcywgQ29tcG9uZW50LCBuZXh0UHJvcHMsIHJlbmRlckxhbmVzKTtcbiAgcmV0dXJuIGZpbmlzaENsYXNzQ29tcG9uZW50KG51bGwsIHdvcmtJblByb2dyZXNzLCBDb21wb25lbnQsIHRydWUsIGhhc0NvbnRleHQsIHJlbmRlckxhbmVzKTtcbn1cblxuZnVuY3Rpb24gbW91bnRJbmRldGVybWluYXRlQ29tcG9uZW50KF9jdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgQ29tcG9uZW50LCByZW5kZXJMYW5lcykge1xuICBpZiAoX2N1cnJlbnQgIT09IG51bGwpIHtcbiAgICAvLyBBbiBpbmRldGVybWluYXRlIGNvbXBvbmVudCBvbmx5IG1vdW50cyBpZiBpdCBzdXNwZW5kZWQgaW5zaWRlIGEgbm9uLVxuICAgIC8vIGNvbmN1cnJlbnQgdHJlZSwgaW4gYW4gaW5jb25zaXN0ZW50IHN0YXRlLiBXZSB3YW50IHRvIHRyZWF0IGl0IGxpa2VcbiAgICAvLyBhIG5ldyBtb3VudCwgZXZlbiB0aG91Z2ggYW4gZW1wdHkgdmVyc2lvbiBvZiBpdCBhbHJlYWR5IGNvbW1pdHRlZC5cbiAgICAvLyBEaXNjb25uZWN0IHRoZSBhbHRlcm5hdGUgcG9pbnRlcnMuXG4gICAgX2N1cnJlbnQuYWx0ZXJuYXRlID0gbnVsbDtcbiAgICB3b3JrSW5Qcm9ncmVzcy5hbHRlcm5hdGUgPSBudWxsOyAvLyBTaW5jZSB0aGlzIGlzIGNvbmNlcHR1YWxseSBhIG5ldyBmaWJlciwgc2NoZWR1bGUgYSBQbGFjZW1lbnQgZWZmZWN0XG5cbiAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSBQbGFjZW1lbnQ7XG4gIH1cblxuICB2YXIgcHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHM7XG4gIHZhciBjb250ZXh0O1xuXG4gIHtcbiAgICB2YXIgdW5tYXNrZWRDb250ZXh0ID0gZ2V0VW5tYXNrZWRDb250ZXh0KHdvcmtJblByb2dyZXNzLCBDb21wb25lbnQsIGZhbHNlKTtcbiAgICBjb250ZXh0ID0gZ2V0TWFza2VkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgdW5tYXNrZWRDb250ZXh0KTtcbiAgfVxuXG4gIHByZXBhcmVUb1JlYWRDb250ZXh0KHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcyk7XG4gIHZhciB2YWx1ZTtcblxuICB7XG4gICAgaWYgKENvbXBvbmVudC5wcm90b3R5cGUgJiYgdHlwZW9mIENvbXBvbmVudC5wcm90b3R5cGUucmVuZGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB2YXIgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWUoQ29tcG9uZW50KSB8fCAnVW5rbm93bic7XG5cbiAgICAgIGlmICghZGlkV2FybkFib3V0QmFkQ2xhc3NbY29tcG9uZW50TmFtZV0pIHtcbiAgICAgICAgZXJyb3IoXCJUaGUgPCVzIC8+IGNvbXBvbmVudCBhcHBlYXJzIHRvIGhhdmUgYSByZW5kZXIgbWV0aG9kLCBidXQgZG9lc24ndCBleHRlbmQgUmVhY3QuQ29tcG9uZW50LiBcIiArICdUaGlzIGlzIGxpa2VseSB0byBjYXVzZSBlcnJvcnMuIENoYW5nZSAlcyB0byBleHRlbmQgUmVhY3QuQ29tcG9uZW50IGluc3RlYWQuJywgY29tcG9uZW50TmFtZSwgY29tcG9uZW50TmFtZSk7XG5cbiAgICAgICAgZGlkV2FybkFib3V0QmFkQ2xhc3NbY29tcG9uZW50TmFtZV0gPSB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh3b3JrSW5Qcm9ncmVzcy5tb2RlICYgU3RyaWN0TW9kZSkge1xuICAgICAgUmVhY3RTdHJpY3RNb2RlV2FybmluZ3MucmVjb3JkTGVnYWN5Q29udGV4dFdhcm5pbmcod29ya0luUHJvZ3Jlc3MsIG51bGwpO1xuICAgIH1cblxuICAgIHNldElzUmVuZGVyaW5nKHRydWUpO1xuICAgIFJlYWN0Q3VycmVudE93bmVyJDEuY3VycmVudCA9IHdvcmtJblByb2dyZXNzO1xuICAgIHZhbHVlID0gcmVuZGVyV2l0aEhvb2tzKG51bGwsIHdvcmtJblByb2dyZXNzLCBDb21wb25lbnQsIHByb3BzLCBjb250ZXh0LCByZW5kZXJMYW5lcyk7XG4gICAgc2V0SXNSZW5kZXJpbmcoZmFsc2UpO1xuICB9IC8vIFJlYWN0IERldlRvb2xzIHJlYWRzIHRoaXMgZmxhZy5cblxuXG4gIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IFBlcmZvcm1lZFdvcms7XG5cbiAge1xuICAgIC8vIFN1cHBvcnQgZm9yIG1vZHVsZSBjb21wb25lbnRzIGlzIGRlcHJlY2F0ZWQgYW5kIGlzIHJlbW92ZWQgYmVoaW5kIGEgZmxhZy5cbiAgICAvLyBXaGV0aGVyIG9yIG5vdCBpdCB3b3VsZCBjcmFzaCBsYXRlciwgd2Ugd2FudCB0byBzaG93IGEgZ29vZCBtZXNzYWdlIGluIERFViBmaXJzdC5cbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAhPT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUucmVuZGVyID09PSAnZnVuY3Rpb24nICYmIHZhbHVlLiQkdHlwZW9mID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHZhciBfY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWUoQ29tcG9uZW50KSB8fCAnVW5rbm93bic7XG5cbiAgICAgIGlmICghZGlkV2FybkFib3V0TW9kdWxlUGF0dGVybkNvbXBvbmVudFtfY29tcG9uZW50TmFtZV0pIHtcbiAgICAgICAgZXJyb3IoJ1RoZSA8JXMgLz4gY29tcG9uZW50IGFwcGVhcnMgdG8gYmUgYSBmdW5jdGlvbiBjb21wb25lbnQgdGhhdCByZXR1cm5zIGEgY2xhc3MgaW5zdGFuY2UuICcgKyAnQ2hhbmdlICVzIHRvIGEgY2xhc3MgdGhhdCBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCBpbnN0ZWFkLiAnICsgXCJJZiB5b3UgY2FuJ3QgdXNlIGEgY2xhc3MgdHJ5IGFzc2lnbmluZyB0aGUgcHJvdG90eXBlIG9uIHRoZSBmdW5jdGlvbiBhcyBhIHdvcmthcm91bmQuIFwiICsgXCJgJXMucHJvdG90eXBlID0gUmVhY3QuQ29tcG9uZW50LnByb3RvdHlwZWAuIERvbid0IHVzZSBhbiBhcnJvdyBmdW5jdGlvbiBzaW5jZSBpdCBcIiArICdjYW5ub3QgYmUgY2FsbGVkIHdpdGggYG5ld2AgYnkgUmVhY3QuJywgX2NvbXBvbmVudE5hbWUsIF9jb21wb25lbnROYW1lLCBfY29tcG9uZW50TmFtZSk7XG5cbiAgICAgICAgZGlkV2FybkFib3V0TW9kdWxlUGF0dGVybkNvbXBvbmVudFtfY29tcG9uZW50TmFtZV0gPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmICggLy8gUnVuIHRoZXNlIGNoZWNrcyBpbiBwcm9kdWN0aW9uIG9ubHkgaWYgdGhlIGZsYWcgaXMgb2ZmLlxuICAvLyBFdmVudHVhbGx5IHdlJ2xsIGRlbGV0ZSB0aGlzIGJyYW5jaCBhbHRvZ2V0aGVyLlxuICAgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAhPT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUucmVuZGVyID09PSAnZnVuY3Rpb24nICYmIHZhbHVlLiQkdHlwZW9mID09PSB1bmRlZmluZWQpIHtcbiAgICB7XG4gICAgICB2YXIgX2NvbXBvbmVudE5hbWUyID0gZ2V0Q29tcG9uZW50TmFtZShDb21wb25lbnQpIHx8ICdVbmtub3duJztcblxuICAgICAgaWYgKCFkaWRXYXJuQWJvdXRNb2R1bGVQYXR0ZXJuQ29tcG9uZW50W19jb21wb25lbnROYW1lMl0pIHtcbiAgICAgICAgZXJyb3IoJ1RoZSA8JXMgLz4gY29tcG9uZW50IGFwcGVhcnMgdG8gYmUgYSBmdW5jdGlvbiBjb21wb25lbnQgdGhhdCByZXR1cm5zIGEgY2xhc3MgaW5zdGFuY2UuICcgKyAnQ2hhbmdlICVzIHRvIGEgY2xhc3MgdGhhdCBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCBpbnN0ZWFkLiAnICsgXCJJZiB5b3UgY2FuJ3QgdXNlIGEgY2xhc3MgdHJ5IGFzc2lnbmluZyB0aGUgcHJvdG90eXBlIG9uIHRoZSBmdW5jdGlvbiBhcyBhIHdvcmthcm91bmQuIFwiICsgXCJgJXMucHJvdG90eXBlID0gUmVhY3QuQ29tcG9uZW50LnByb3RvdHlwZWAuIERvbid0IHVzZSBhbiBhcnJvdyBmdW5jdGlvbiBzaW5jZSBpdCBcIiArICdjYW5ub3QgYmUgY2FsbGVkIHdpdGggYG5ld2AgYnkgUmVhY3QuJywgX2NvbXBvbmVudE5hbWUyLCBfY29tcG9uZW50TmFtZTIsIF9jb21wb25lbnROYW1lMik7XG5cbiAgICAgICAgZGlkV2FybkFib3V0TW9kdWxlUGF0dGVybkNvbXBvbmVudFtfY29tcG9uZW50TmFtZTJdID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9IC8vIFByb2NlZWQgdW5kZXIgdGhlIGFzc3VtcHRpb24gdGhhdCB0aGlzIGlzIGEgY2xhc3MgaW5zdGFuY2VcblxuXG4gICAgd29ya0luUHJvZ3Jlc3MudGFnID0gQ2xhc3NDb21wb25lbnQ7IC8vIFRocm93IG91dCBhbnkgaG9va3MgdGhhdCB3ZXJlIHVzZWQuXG5cbiAgICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID0gbnVsbDtcbiAgICB3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZSA9IG51bGw7IC8vIFB1c2ggY29udGV4dCBwcm92aWRlcnMgZWFybHkgdG8gcHJldmVudCBjb250ZXh0IHN0YWNrIG1pc21hdGNoZXMuXG4gICAgLy8gRHVyaW5nIG1vdW50aW5nIHdlIGRvbid0IGtub3cgdGhlIGNoaWxkIGNvbnRleHQgeWV0IGFzIHRoZSBpbnN0YW5jZSBkb2Vzbid0IGV4aXN0LlxuICAgIC8vIFdlIHdpbGwgaW52YWxpZGF0ZSB0aGUgY2hpbGQgY29udGV4dCBpbiBmaW5pc2hDbGFzc0NvbXBvbmVudCgpIHJpZ2h0IGFmdGVyIHJlbmRlcmluZy5cblxuICAgIHZhciBoYXNDb250ZXh0ID0gZmFsc2U7XG5cbiAgICBpZiAoaXNDb250ZXh0UHJvdmlkZXIoQ29tcG9uZW50KSkge1xuICAgICAgaGFzQ29udGV4dCA9IHRydWU7XG4gICAgICBwdXNoQ29udGV4dFByb3ZpZGVyKHdvcmtJblByb2dyZXNzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaGFzQ29udGV4dCA9IGZhbHNlO1xuICAgIH1cblxuICAgIHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSB2YWx1ZS5zdGF0ZSAhPT0gbnVsbCAmJiB2YWx1ZS5zdGF0ZSAhPT0gdW5kZWZpbmVkID8gdmFsdWUuc3RhdGUgOiBudWxsO1xuICAgIGluaXRpYWxpemVVcGRhdGVRdWV1ZSh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgdmFyIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyA9IENvbXBvbmVudC5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHM7XG5cbiAgICBpZiAodHlwZW9mIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgYXBwbHlEZXJpdmVkU3RhdGVGcm9tUHJvcHMod29ya0luUHJvZ3Jlc3MsIENvbXBvbmVudCwgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzLCBwcm9wcyk7XG4gICAgfVxuXG4gICAgYWRvcHRDbGFzc0luc3RhbmNlKHdvcmtJblByb2dyZXNzLCB2YWx1ZSk7XG4gICAgbW91bnRDbGFzc0luc3RhbmNlKHdvcmtJblByb2dyZXNzLCBDb21wb25lbnQsIHByb3BzLCByZW5kZXJMYW5lcyk7XG4gICAgcmV0dXJuIGZpbmlzaENsYXNzQ29tcG9uZW50KG51bGwsIHdvcmtJblByb2dyZXNzLCBDb21wb25lbnQsIHRydWUsIGhhc0NvbnRleHQsIHJlbmRlckxhbmVzKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBQcm9jZWVkIHVuZGVyIHRoZSBhc3N1bXB0aW9uIHRoYXQgdGhpcyBpcyBhIGZ1bmN0aW9uIGNvbXBvbmVudFxuICAgIHdvcmtJblByb2dyZXNzLnRhZyA9IEZ1bmN0aW9uQ29tcG9uZW50O1xuXG4gICAge1xuXG4gICAgICBpZiAoIHdvcmtJblByb2dyZXNzLm1vZGUgJiBTdHJpY3RNb2RlKSB7XG4gICAgICAgIGRpc2FibGVMb2dzKCk7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB2YWx1ZSA9IHJlbmRlcldpdGhIb29rcyhudWxsLCB3b3JrSW5Qcm9ncmVzcywgQ29tcG9uZW50LCBwcm9wcywgY29udGV4dCwgcmVuZGVyTGFuZXMpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIHJlZW5hYmxlTG9ncygpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmVjb25jaWxlQ2hpbGRyZW4obnVsbCwgd29ya0luUHJvZ3Jlc3MsIHZhbHVlLCByZW5kZXJMYW5lcyk7XG5cbiAgICB7XG4gICAgICB2YWxpZGF0ZUZ1bmN0aW9uQ29tcG9uZW50SW5EZXYod29ya0luUHJvZ3Jlc3MsIENvbXBvbmVudCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHdvcmtJblByb2dyZXNzLmNoaWxkO1xuICB9XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlRnVuY3Rpb25Db21wb25lbnRJbkRldih3b3JrSW5Qcm9ncmVzcywgQ29tcG9uZW50KSB7XG4gIHtcbiAgICBpZiAoQ29tcG9uZW50KSB7XG4gICAgICBpZiAoQ29tcG9uZW50LmNoaWxkQ29udGV4dFR5cGVzKSB7XG4gICAgICAgIGVycm9yKCclcyguLi4pOiBjaGlsZENvbnRleHRUeXBlcyBjYW5ub3QgYmUgZGVmaW5lZCBvbiBhIGZ1bmN0aW9uIGNvbXBvbmVudC4nLCBDb21wb25lbnQuZGlzcGxheU5hbWUgfHwgQ29tcG9uZW50Lm5hbWUgfHwgJ0NvbXBvbmVudCcpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh3b3JrSW5Qcm9ncmVzcy5yZWYgIT09IG51bGwpIHtcbiAgICAgIHZhciBpbmZvID0gJyc7XG4gICAgICB2YXIgb3duZXJOYW1lID0gZ2V0Q3VycmVudEZpYmVyT3duZXJOYW1lSW5EZXZPck51bGwoKTtcblxuICAgICAgaWYgKG93bmVyTmFtZSkge1xuICAgICAgICBpbmZvICs9ICdcXG5cXG5DaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiBgJyArIG93bmVyTmFtZSArICdgLic7XG4gICAgICB9XG5cbiAgICAgIHZhciB3YXJuaW5nS2V5ID0gb3duZXJOYW1lIHx8IHdvcmtJblByb2dyZXNzLl9kZWJ1Z0lEIHx8ICcnO1xuICAgICAgdmFyIGRlYnVnU291cmNlID0gd29ya0luUHJvZ3Jlc3MuX2RlYnVnU291cmNlO1xuXG4gICAgICBpZiAoZGVidWdTb3VyY2UpIHtcbiAgICAgICAgd2FybmluZ0tleSA9IGRlYnVnU291cmNlLmZpbGVOYW1lICsgJzonICsgZGVidWdTb3VyY2UubGluZU51bWJlcjtcbiAgICAgIH1cblxuICAgICAgaWYgKCFkaWRXYXJuQWJvdXRGdW5jdGlvblJlZnNbd2FybmluZ0tleV0pIHtcbiAgICAgICAgZGlkV2FybkFib3V0RnVuY3Rpb25SZWZzW3dhcm5pbmdLZXldID0gdHJ1ZTtcblxuICAgICAgICBlcnJvcignRnVuY3Rpb24gY29tcG9uZW50cyBjYW5ub3QgYmUgZ2l2ZW4gcmVmcy4gJyArICdBdHRlbXB0cyB0byBhY2Nlc3MgdGhpcyByZWYgd2lsbCBmYWlsLiAnICsgJ0RpZCB5b3UgbWVhbiB0byB1c2UgUmVhY3QuZm9yd2FyZFJlZigpPyVzJywgaW5mbyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBDb21wb25lbnQuZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB2YXIgX2NvbXBvbmVudE5hbWUzID0gZ2V0Q29tcG9uZW50TmFtZShDb21wb25lbnQpIHx8ICdVbmtub3duJztcblxuICAgICAgaWYgKCFkaWRXYXJuQWJvdXRHZXREZXJpdmVkU3RhdGVPbkZ1bmN0aW9uQ29tcG9uZW50W19jb21wb25lbnROYW1lM10pIHtcbiAgICAgICAgZXJyb3IoJyVzOiBGdW5jdGlvbiBjb21wb25lbnRzIGRvIG5vdCBzdXBwb3J0IGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcy4nLCBfY29tcG9uZW50TmFtZTMpO1xuXG4gICAgICAgIGRpZFdhcm5BYm91dEdldERlcml2ZWRTdGF0ZU9uRnVuY3Rpb25Db21wb25lbnRbX2NvbXBvbmVudE5hbWUzXSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBDb21wb25lbnQuY29udGV4dFR5cGUgPT09ICdvYmplY3QnICYmIENvbXBvbmVudC5jb250ZXh0VHlwZSAhPT0gbnVsbCkge1xuICAgICAgdmFyIF9jb21wb25lbnROYW1lNCA9IGdldENvbXBvbmVudE5hbWUoQ29tcG9uZW50KSB8fCAnVW5rbm93bic7XG5cbiAgICAgIGlmICghZGlkV2FybkFib3V0Q29udGV4dFR5cGVPbkZ1bmN0aW9uQ29tcG9uZW50W19jb21wb25lbnROYW1lNF0pIHtcbiAgICAgICAgZXJyb3IoJyVzOiBGdW5jdGlvbiBjb21wb25lbnRzIGRvIG5vdCBzdXBwb3J0IGNvbnRleHRUeXBlLicsIF9jb21wb25lbnROYW1lNCk7XG5cbiAgICAgICAgZGlkV2FybkFib3V0Q29udGV4dFR5cGVPbkZ1bmN0aW9uQ29tcG9uZW50W19jb21wb25lbnROYW1lNF0gPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG52YXIgU1VTUEVOREVEX01BUktFUiA9IHtcbiAgZGVoeWRyYXRlZDogbnVsbCxcbiAgcmV0cnlMYW5lOiBOb0xhbmVcbn07XG5cbmZ1bmN0aW9uIG1vdW50U3VzcGVuc2VPZmZzY3JlZW5TdGF0ZShyZW5kZXJMYW5lcykge1xuICByZXR1cm4ge1xuICAgIGJhc2VMYW5lczogcmVuZGVyTGFuZXNcbiAgfTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlU3VzcGVuc2VPZmZzY3JlZW5TdGF0ZShwcmV2T2Zmc2NyZWVuU3RhdGUsIHJlbmRlckxhbmVzKSB7XG4gIHJldHVybiB7XG4gICAgYmFzZUxhbmVzOiBtZXJnZUxhbmVzKHByZXZPZmZzY3JlZW5TdGF0ZS5iYXNlTGFuZXMsIHJlbmRlckxhbmVzKVxuICB9O1xufSAvLyBUT0RPOiBQcm9iYWJseSBzaG91bGQgaW5saW5lIHRoaXMgYmFja1xuXG5cbmZ1bmN0aW9uIHNob3VsZFJlbWFpbk9uRmFsbGJhY2soc3VzcGVuc2VDb250ZXh0LCBjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpIHtcbiAgLy8gSWYgd2UncmUgYWxyZWFkeSBzaG93aW5nIGEgZmFsbGJhY2ssIHRoZXJlIGFyZSBjYXNlcyB3aGVyZSB3ZSBuZWVkIHRvXG4gIC8vIHJlbWFpbiBvbiB0aGF0IGZhbGxiYWNrIHJlZ2FyZGxlc3Mgb2Ygd2hldGhlciB0aGUgY29udGVudCBoYXMgcmVzb2x2ZWQuXG4gIC8vIEZvciBleGFtcGxlLCBTdXNwZW5zZUxpc3QgY29vcmRpbmF0ZXMgd2hlbiBuZXN0ZWQgY29udGVudCBhcHBlYXJzLlxuICBpZiAoY3VycmVudCAhPT0gbnVsbCkge1xuICAgIHZhciBzdXNwZW5zZVN0YXRlID0gY3VycmVudC5tZW1vaXplZFN0YXRlO1xuXG4gICAgaWYgKHN1c3BlbnNlU3RhdGUgPT09IG51bGwpIHtcbiAgICAgIC8vIEN1cnJlbnRseSBzaG93aW5nIGNvbnRlbnQuIERvbid0IGhpZGUgaXQsIGV2ZW4gaWYgRm9yY2VTdXNwZW5zZUZhbGxhY2tcbiAgICAgIC8vIGlzIHRydWUuIE1vcmUgcHJlY2lzZSBuYW1lIG1pZ2h0IGJlIFwiRm9yY2VSZW1haW5TdXNwZW5zZUZhbGxiYWNrXCIuXG4gICAgICAvLyBOb3RlOiBUaGlzIGlzIGEgZmFjdG9yaW5nIHNtZWxsLiBDYW4ndCByZW1haW4gb24gYSBmYWxsYmFjayBpZiB0aGVyZSdzXG4gICAgICAvLyBubyBmYWxsYmFjayB0byByZW1haW4gb24uXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9IC8vIE5vdCBjdXJyZW50bHkgc2hvd2luZyBjb250ZW50LiBDb25zdWx0IHRoZSBTdXNwZW5zZSBjb250ZXh0LlxuXG5cbiAgcmV0dXJuIGhhc1N1c3BlbnNlQ29udGV4dChzdXNwZW5zZUNvbnRleHQsIEZvcmNlU3VzcGVuc2VGYWxsYmFjayk7XG59XG5cbmZ1bmN0aW9uIGdldFJlbWFpbmluZ1dvcmtJblByaW1hcnlUcmVlKGN1cnJlbnQsIHJlbmRlckxhbmVzKSB7XG4gIC8vIFRPRE86IFNob3VsZCBub3QgcmVtb3ZlIHJlbmRlciBsYW5lcyB0aGF0IHdlcmUgcGluZ2VkIGR1cmluZyB0aGlzIHJlbmRlclxuICByZXR1cm4gcmVtb3ZlTGFuZXMoY3VycmVudC5jaGlsZExhbmVzLCByZW5kZXJMYW5lcyk7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZVN1c3BlbnNlQ29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcykge1xuICB2YXIgbmV4dFByb3BzID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzOyAvLyBUaGlzIGlzIHVzZWQgYnkgRGV2VG9vbHMgdG8gZm9yY2UgYSBib3VuZGFyeSB0byBzdXNwZW5kLlxuXG4gIHtcbiAgICBpZiAoc2hvdWxkU3VzcGVuZCh3b3JrSW5Qcm9ncmVzcykpIHtcbiAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IERpZENhcHR1cmU7XG4gICAgfVxuICB9XG5cbiAgdmFyIHN1c3BlbnNlQ29udGV4dCA9IHN1c3BlbnNlU3RhY2tDdXJzb3IuY3VycmVudDtcbiAgdmFyIHNob3dGYWxsYmFjayA9IGZhbHNlO1xuICB2YXIgZGlkU3VzcGVuZCA9ICh3b3JrSW5Qcm9ncmVzcy5mbGFncyAmIERpZENhcHR1cmUpICE9PSBOb0ZsYWdzO1xuXG4gIGlmIChkaWRTdXNwZW5kIHx8IHNob3VsZFJlbWFpbk9uRmFsbGJhY2soc3VzcGVuc2VDb250ZXh0LCBjdXJyZW50KSkge1xuICAgIC8vIFNvbWV0aGluZyBpbiB0aGlzIGJvdW5kYXJ5J3Mgc3VidHJlZSBhbHJlYWR5IHN1c3BlbmRlZC4gU3dpdGNoIHRvXG4gICAgLy8gcmVuZGVyaW5nIHRoZSBmYWxsYmFjayBjaGlsZHJlbi5cbiAgICBzaG93RmFsbGJhY2sgPSB0cnVlO1xuICAgIHdvcmtJblByb2dyZXNzLmZsYWdzICY9IH5EaWRDYXB0dXJlO1xuICB9IGVsc2Uge1xuICAgIC8vIEF0dGVtcHRpbmcgdGhlIG1haW4gY29udGVudFxuICAgIGlmIChjdXJyZW50ID09PSBudWxsIHx8IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZSAhPT0gbnVsbCkge1xuICAgICAgLy8gVGhpcyBpcyBhIG5ldyBtb3VudCBvciB0aGlzIGJvdW5kYXJ5IGlzIGFscmVhZHkgc2hvd2luZyBhIGZhbGxiYWNrIHN0YXRlLlxuICAgICAgLy8gTWFyayB0aGlzIHN1YnRyZWUgY29udGV4dCBhcyBoYXZpbmcgYXQgbGVhc3Qgb25lIGludmlzaWJsZSBwYXJlbnQgdGhhdCBjb3VsZFxuICAgICAgLy8gaGFuZGxlIHRoZSBmYWxsYmFjayBzdGF0ZS5cbiAgICAgIC8vIEJvdW5kYXJpZXMgd2l0aG91dCBmYWxsYmFja3Mgb3Igc2hvdWxkIGJlIGF2b2lkZWQgYXJlIG5vdCBjb25zaWRlcmVkIHNpbmNlXG4gICAgICAvLyB0aGV5IGNhbm5vdCBoYW5kbGUgcHJlZmVycmVkIGZhbGxiYWNrIHN0YXRlcy5cbiAgICAgIGlmIChuZXh0UHJvcHMuZmFsbGJhY2sgIT09IHVuZGVmaW5lZCAmJiBuZXh0UHJvcHMudW5zdGFibGVfYXZvaWRUaGlzRmFsbGJhY2sgIT09IHRydWUpIHtcbiAgICAgICAgc3VzcGVuc2VDb250ZXh0ID0gYWRkU3VidHJlZVN1c3BlbnNlQ29udGV4dChzdXNwZW5zZUNvbnRleHQsIEludmlzaWJsZVBhcmVudFN1c3BlbnNlQ29udGV4dCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgc3VzcGVuc2VDb250ZXh0ID0gc2V0RGVmYXVsdFNoYWxsb3dTdXNwZW5zZUNvbnRleHQoc3VzcGVuc2VDb250ZXh0KTtcbiAgcHVzaFN1c3BlbnNlQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgc3VzcGVuc2VDb250ZXh0KTsgLy8gT0ssIHRoZSBuZXh0IHBhcnQgaXMgY29uZnVzaW5nLiBXZSdyZSBhYm91dCB0byByZWNvbmNpbGUgdGhlIFN1c3BlbnNlXG4gIC8vIGJvdW5kYXJ5J3MgY2hpbGRyZW4uIFRoaXMgaW52b2x2ZXMgc29tZSBjdXN0b20gcmVjb25jaWxhdGlvbiBsb2dpYy4gVHdvXG4gIC8vIG1haW4gcmVhc29ucyB0aGlzIGlzIHNvIGNvbXBsaWNhdGVkLlxuICAvL1xuICAvLyBGaXJzdCwgTGVnYWN5IE1vZGUgaGFzIGRpZmZlcmVudCBzZW1hbnRpY3MgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LiBUaGVcbiAgLy8gcHJpbWFyeSB0cmVlIHdpbGwgY29tbWl0IGluIGFuIGluY29uc2lzdGVudCBzdGF0ZSwgc28gd2hlbiB3ZSBkbyB0aGVcbiAgLy8gc2Vjb25kIHBhc3MgdG8gcmVuZGVyIHRoZSBmYWxsYmFjaywgd2UgZG8gc29tZSBleGNlZWRpbmdseSwgdWgsIGNsZXZlclxuICAvLyBoYWNrcyB0byBtYWtlIHRoYXQgbm90IHRvdGFsbHkgYnJlYWsuIExpa2UgdHJhbnNmZXJyaW5nIGVmZmVjdHMgYW5kXG4gIC8vIGRlbGV0aW9ucyBmcm9tIGhpZGRlbiB0cmVlLiBJbiBDb25jdXJyZW50IE1vZGUsIGl0J3MgbXVjaCBzaW1wbGVyLFxuICAvLyBiZWNhdXNlIHdlIGJhaWxvdXQgb24gdGhlIHByaW1hcnkgdHJlZSBjb21wbGV0ZWx5IGFuZCBsZWF2ZSBpdCBpbiBpdHMgb2xkXG4gIC8vIHN0YXRlLCBubyBlZmZlY3RzLiBTYW1lIGFzIHdoYXQgd2UgZG8gZm9yIE9mZnNjcmVlbiAoZXhjZXB0IHRoYXRcbiAgLy8gT2Zmc2NyZWVuIGRvZXNuJ3QgaGF2ZSB0aGUgZmlyc3QgcmVuZGVyIHBhc3MpLlxuICAvL1xuICAvLyBTZWNvbmQgaXMgaHlkcmF0aW9uLiBEdXJpbmcgaHlkcmF0aW9uLCB0aGUgU3VzcGVuc2UgZmliZXIgaGFzIGEgc2xpZ2h0bHlcbiAgLy8gZGlmZmVyZW50IGxheW91dCwgd2hlcmUgdGhlIGNoaWxkIHBvaW50cyB0byBhIGRlaHlkcmF0ZWQgZnJhZ21lbnQsIHdoaWNoXG4gIC8vIGNvbnRhaW5zIHRoZSBET00gcmVuZGVyZWQgYnkgdGhlIHNlcnZlci5cbiAgLy9cbiAgLy8gVGhpcmQsIGV2ZW4gaWYgeW91IHNldCBhbGwgdGhhdCBhc2lkZSwgU3VzcGVuc2UgaXMgbGlrZSBlcnJvciBib3VuZGFyaWVzIGluXG4gIC8vIHRoYXQgd2UgZmlyc3Qgd2UgdHJ5IHRvIHJlbmRlciBvbmUgdHJlZSwgYW5kIGlmIHRoYXQgZmFpbHMsIHdlIHJlbmRlciBhZ2FpblxuICAvLyBhbmQgc3dpdGNoIHRvIGEgZGlmZmVyZW50IHRyZWUuIExpa2UgYSB0cnkvY2F0Y2ggYmxvY2suIFNvIHdlIGhhdmUgdG8gdHJhY2tcbiAgLy8gd2hpY2ggYnJhbmNoIHdlJ3JlIGN1cnJlbnRseSByZW5kZXJpbmcuIElkZWFsbHkgd2Ugd291bGQgbW9kZWwgdGhpcyB1c2luZ1xuICAvLyBhIHN0YWNrLlxuXG4gIGlmIChjdXJyZW50ID09PSBudWxsKSB7XG4gICAgLy8gSW5pdGlhbCBtb3VudFxuICAgIC8vIElmIHdlJ3JlIGN1cnJlbnRseSBoeWRyYXRpbmcsIHRyeSB0byBoeWRyYXRlIHRoaXMgYm91bmRhcnkuXG4gICAgLy8gQnV0IG9ubHkgaWYgdGhpcyBoYXMgYSBmYWxsYmFjay5cbiAgICBpZiAobmV4dFByb3BzLmZhbGxiYWNrICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRyeVRvQ2xhaW1OZXh0SHlkcmF0YWJsZUluc3RhbmNlKHdvcmtJblByb2dyZXNzKTsgLy8gVGhpcyBjb3VsZCd2ZSBiZWVuIGEgZGVoeWRyYXRlZCBzdXNwZW5zZSBjb21wb25lbnQuXG4gICAgfVxuXG4gICAgdmFyIG5leHRQcmltYXJ5Q2hpbGRyZW4gPSBuZXh0UHJvcHMuY2hpbGRyZW47XG4gICAgdmFyIG5leHRGYWxsYmFja0NoaWxkcmVuID0gbmV4dFByb3BzLmZhbGxiYWNrO1xuXG4gICAgaWYgKHNob3dGYWxsYmFjaykge1xuICAgICAgdmFyIGZhbGxiYWNrRnJhZ21lbnQgPSBtb3VudFN1c3BlbnNlRmFsbGJhY2tDaGlsZHJlbih3b3JrSW5Qcm9ncmVzcywgbmV4dFByaW1hcnlDaGlsZHJlbiwgbmV4dEZhbGxiYWNrQ2hpbGRyZW4sIHJlbmRlckxhbmVzKTtcbiAgICAgIHZhciBwcmltYXJ5Q2hpbGRGcmFnbWVudCA9IHdvcmtJblByb2dyZXNzLmNoaWxkO1xuICAgICAgcHJpbWFyeUNoaWxkRnJhZ21lbnQubWVtb2l6ZWRTdGF0ZSA9IG1vdW50U3VzcGVuc2VPZmZzY3JlZW5TdGF0ZShyZW5kZXJMYW5lcyk7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID0gU1VTUEVOREVEX01BUktFUjtcbiAgICAgIHJldHVybiBmYWxsYmFja0ZyYWdtZW50O1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIG5leHRQcm9wcy51bnN0YWJsZV9leHBlY3RlZExvYWRUaW1lID09PSAnbnVtYmVyJykge1xuICAgICAgLy8gVGhpcyBpcyBhIENQVS1ib3VuZCB0cmVlLiBTa2lwIHRoaXMgdHJlZSBhbmQgc2hvdyBhIHBsYWNlaG9sZGVyIHRvXG4gICAgICAvLyB1bmJsb2NrIHRoZSBzdXJyb3VuZGluZyBjb250ZW50LiBUaGVuIGltbWVkaWF0ZWx5IHJldHJ5IGFmdGVyIHRoZVxuICAgICAgLy8gaW5pdGlhbCBjb21taXQuXG4gICAgICB2YXIgX2ZhbGxiYWNrRnJhZ21lbnQgPSBtb3VudFN1c3BlbnNlRmFsbGJhY2tDaGlsZHJlbih3b3JrSW5Qcm9ncmVzcywgbmV4dFByaW1hcnlDaGlsZHJlbiwgbmV4dEZhbGxiYWNrQ2hpbGRyZW4sIHJlbmRlckxhbmVzKTtcblxuICAgICAgdmFyIF9wcmltYXJ5Q2hpbGRGcmFnbWVudCA9IHdvcmtJblByb2dyZXNzLmNoaWxkO1xuICAgICAgX3ByaW1hcnlDaGlsZEZyYWdtZW50Lm1lbW9pemVkU3RhdGUgPSBtb3VudFN1c3BlbnNlT2Zmc2NyZWVuU3RhdGUocmVuZGVyTGFuZXMpO1xuICAgICAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IFNVU1BFTkRFRF9NQVJLRVI7IC8vIFNpbmNlIG5vdGhpbmcgYWN0dWFsbHkgc3VzcGVuZGVkLCB0aGVyZSB3aWxsIG5vdGhpbmcgdG8gcGluZyB0aGlzIHRvXG4gICAgICAvLyBnZXQgaXQgc3RhcnRlZCBiYWNrIHVwIHRvIGF0dGVtcHQgdGhlIG5leHQgaXRlbS4gV2hpbGUgaW4gdGVybXMgb2ZcbiAgICAgIC8vIHByaW9yaXR5IHRoaXMgd29yayBoYXMgdGhlIHNhbWUgcHJpb3JpdHkgYXMgdGhpcyBjdXJyZW50IHJlbmRlciwgaXQnc1xuICAgICAgLy8gbm90IHBhcnQgb2YgdGhlIHNhbWUgdHJhbnNpdGlvbiBvbmNlIHRoZSB0cmFuc2l0aW9uIGhhcyBjb21taXR0ZWQuIElmXG4gICAgICAvLyBpdCdzIHN5bmMsIHdlIHN0aWxsIHdhbnQgdG8geWllbGQgc28gdGhhdCBpdCBjYW4gYmUgcGFpbnRlZC5cbiAgICAgIC8vIENvbmNlcHR1YWxseSwgdGhpcyBpcyByZWFsbHkgdGhlIHNhbWUgYXMgcGluZ2luZy4gV2UgY2FuIHVzZSBhbnlcbiAgICAgIC8vIFJldHJ5TGFuZSBldmVuIGlmIGl0J3MgdGhlIG9uZSBjdXJyZW50bHkgcmVuZGVyaW5nIHNpbmNlIHdlJ3JlIGxlYXZpbmdcbiAgICAgIC8vIGl0IGJlaGluZCBvbiB0aGlzIG5vZGUuXG5cbiAgICAgIHdvcmtJblByb2dyZXNzLmxhbmVzID0gU29tZVJldHJ5TGFuZTtcblxuICAgICAge1xuICAgICAgICBtYXJrU3Bhd25lZFdvcmsoU29tZVJldHJ5TGFuZSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBfZmFsbGJhY2tGcmFnbWVudDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG1vdW50U3VzcGVuc2VQcmltYXJ5Q2hpbGRyZW4od29ya0luUHJvZ3Jlc3MsIG5leHRQcmltYXJ5Q2hpbGRyZW4sIHJlbmRlckxhbmVzKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gVGhpcyBpcyBhbiB1cGRhdGUuXG4gICAgLy8gSWYgdGhlIGN1cnJlbnQgZmliZXIgaGFzIGEgU3VzcGVuc2VTdGF0ZSwgdGhhdCBtZWFucyBpdCdzIGFscmVhZHkgc2hvd2luZ1xuICAgIC8vIGEgZmFsbGJhY2suXG4gICAgdmFyIHByZXZTdGF0ZSA9IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZTtcblxuICAgIGlmIChwcmV2U3RhdGUgIT09IG51bGwpIHtcblxuICAgICAgaWYgKHNob3dGYWxsYmFjaykge1xuICAgICAgICB2YXIgX25leHRGYWxsYmFja0NoaWxkcmVuMiA9IG5leHRQcm9wcy5mYWxsYmFjaztcbiAgICAgICAgdmFyIF9uZXh0UHJpbWFyeUNoaWxkcmVuMiA9IG5leHRQcm9wcy5jaGlsZHJlbjtcblxuICAgICAgICB2YXIgX2ZhbGxiYWNrQ2hpbGRGcmFnbWVudCA9IHVwZGF0ZVN1c3BlbnNlRmFsbGJhY2tDaGlsZHJlbihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgX25leHRQcmltYXJ5Q2hpbGRyZW4yLCBfbmV4dEZhbGxiYWNrQ2hpbGRyZW4yLCByZW5kZXJMYW5lcyk7XG5cbiAgICAgICAgdmFyIF9wcmltYXJ5Q2hpbGRGcmFnbWVudDMgPSB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbiAgICAgICAgdmFyIHByZXZPZmZzY3JlZW5TdGF0ZSA9IGN1cnJlbnQuY2hpbGQubWVtb2l6ZWRTdGF0ZTtcbiAgICAgICAgX3ByaW1hcnlDaGlsZEZyYWdtZW50My5tZW1vaXplZFN0YXRlID0gcHJldk9mZnNjcmVlblN0YXRlID09PSBudWxsID8gbW91bnRTdXNwZW5zZU9mZnNjcmVlblN0YXRlKHJlbmRlckxhbmVzKSA6IHVwZGF0ZVN1c3BlbnNlT2Zmc2NyZWVuU3RhdGUocHJldk9mZnNjcmVlblN0YXRlLCByZW5kZXJMYW5lcyk7XG4gICAgICAgIF9wcmltYXJ5Q2hpbGRGcmFnbWVudDMuY2hpbGRMYW5lcyA9IGdldFJlbWFpbmluZ1dvcmtJblByaW1hcnlUcmVlKGN1cnJlbnQsIHJlbmRlckxhbmVzKTtcbiAgICAgICAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IFNVU1BFTkRFRF9NQVJLRVI7XG4gICAgICAgIHJldHVybiBfZmFsbGJhY2tDaGlsZEZyYWdtZW50O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIF9uZXh0UHJpbWFyeUNoaWxkcmVuMyA9IG5leHRQcm9wcy5jaGlsZHJlbjtcblxuICAgICAgICB2YXIgX3ByaW1hcnlDaGlsZEZyYWdtZW50NCA9IHVwZGF0ZVN1c3BlbnNlUHJpbWFyeUNoaWxkcmVuKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBfbmV4dFByaW1hcnlDaGlsZHJlbjMsIHJlbmRlckxhbmVzKTtcblxuICAgICAgICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIF9wcmltYXJ5Q2hpbGRGcmFnbWVudDQ7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRoZSBjdXJyZW50IHRyZWUgaXMgbm90IGFscmVhZHkgc2hvd2luZyBhIGZhbGxiYWNrLlxuICAgICAgaWYgKHNob3dGYWxsYmFjaykge1xuICAgICAgICAvLyBUaW1lZCBvdXQuXG4gICAgICAgIHZhciBfbmV4dEZhbGxiYWNrQ2hpbGRyZW4zID0gbmV4dFByb3BzLmZhbGxiYWNrO1xuICAgICAgICB2YXIgX25leHRQcmltYXJ5Q2hpbGRyZW40ID0gbmV4dFByb3BzLmNoaWxkcmVuO1xuXG4gICAgICAgIHZhciBfZmFsbGJhY2tDaGlsZEZyYWdtZW50MiA9IHVwZGF0ZVN1c3BlbnNlRmFsbGJhY2tDaGlsZHJlbihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgX25leHRQcmltYXJ5Q2hpbGRyZW40LCBfbmV4dEZhbGxiYWNrQ2hpbGRyZW4zLCByZW5kZXJMYW5lcyk7XG5cbiAgICAgICAgdmFyIF9wcmltYXJ5Q2hpbGRGcmFnbWVudDUgPSB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbiAgICAgICAgdmFyIF9wcmV2T2Zmc2NyZWVuU3RhdGUgPSBjdXJyZW50LmNoaWxkLm1lbW9pemVkU3RhdGU7XG4gICAgICAgIF9wcmltYXJ5Q2hpbGRGcmFnbWVudDUubWVtb2l6ZWRTdGF0ZSA9IF9wcmV2T2Zmc2NyZWVuU3RhdGUgPT09IG51bGwgPyBtb3VudFN1c3BlbnNlT2Zmc2NyZWVuU3RhdGUocmVuZGVyTGFuZXMpIDogdXBkYXRlU3VzcGVuc2VPZmZzY3JlZW5TdGF0ZShfcHJldk9mZnNjcmVlblN0YXRlLCByZW5kZXJMYW5lcyk7XG4gICAgICAgIF9wcmltYXJ5Q2hpbGRGcmFnbWVudDUuY2hpbGRMYW5lcyA9IGdldFJlbWFpbmluZ1dvcmtJblByaW1hcnlUcmVlKGN1cnJlbnQsIHJlbmRlckxhbmVzKTsgLy8gU2tpcCB0aGUgcHJpbWFyeSBjaGlsZHJlbiwgYW5kIGNvbnRpbnVlIHdvcmtpbmcgb24gdGhlXG4gICAgICAgIC8vIGZhbGxiYWNrIGNoaWxkcmVuLlxuXG4gICAgICAgIHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSBTVVNQRU5ERURfTUFSS0VSO1xuICAgICAgICByZXR1cm4gX2ZhbGxiYWNrQ2hpbGRGcmFnbWVudDI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBTdGlsbCBoYXZlbid0IHRpbWVkIG91dC4gQ29udGludWUgcmVuZGVyaW5nIHRoZSBjaGlsZHJlbiwgbGlrZSB3ZVxuICAgICAgICAvLyBub3JtYWxseSBkby5cbiAgICAgICAgdmFyIF9uZXh0UHJpbWFyeUNoaWxkcmVuNSA9IG5leHRQcm9wcy5jaGlsZHJlbjtcblxuICAgICAgICB2YXIgX3ByaW1hcnlDaGlsZEZyYWdtZW50NiA9IHVwZGF0ZVN1c3BlbnNlUHJpbWFyeUNoaWxkcmVuKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBfbmV4dFByaW1hcnlDaGlsZHJlbjUsIHJlbmRlckxhbmVzKTtcblxuICAgICAgICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIF9wcmltYXJ5Q2hpbGRGcmFnbWVudDY7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIG1vdW50U3VzcGVuc2VQcmltYXJ5Q2hpbGRyZW4od29ya0luUHJvZ3Jlc3MsIHByaW1hcnlDaGlsZHJlbiwgcmVuZGVyTGFuZXMpIHtcbiAgdmFyIG1vZGUgPSB3b3JrSW5Qcm9ncmVzcy5tb2RlO1xuICB2YXIgcHJpbWFyeUNoaWxkUHJvcHMgPSB7XG4gICAgbW9kZTogJ3Zpc2libGUnLFxuICAgIGNoaWxkcmVuOiBwcmltYXJ5Q2hpbGRyZW5cbiAgfTtcbiAgdmFyIHByaW1hcnlDaGlsZEZyYWdtZW50ID0gY3JlYXRlRmliZXJGcm9tT2Zmc2NyZWVuKHByaW1hcnlDaGlsZFByb3BzLCBtb2RlLCByZW5kZXJMYW5lcywgbnVsbCk7XG4gIHByaW1hcnlDaGlsZEZyYWdtZW50LnJldHVybiA9IHdvcmtJblByb2dyZXNzO1xuICB3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IHByaW1hcnlDaGlsZEZyYWdtZW50O1xuICByZXR1cm4gcHJpbWFyeUNoaWxkRnJhZ21lbnQ7XG59XG5cbmZ1bmN0aW9uIG1vdW50U3VzcGVuc2VGYWxsYmFja0NoaWxkcmVuKHdvcmtJblByb2dyZXNzLCBwcmltYXJ5Q2hpbGRyZW4sIGZhbGxiYWNrQ2hpbGRyZW4sIHJlbmRlckxhbmVzKSB7XG4gIHZhciBtb2RlID0gd29ya0luUHJvZ3Jlc3MubW9kZTtcbiAgdmFyIHByb2dyZXNzZWRQcmltYXJ5RnJhZ21lbnQgPSB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbiAgdmFyIHByaW1hcnlDaGlsZFByb3BzID0ge1xuICAgIG1vZGU6ICdoaWRkZW4nLFxuICAgIGNoaWxkcmVuOiBwcmltYXJ5Q2hpbGRyZW5cbiAgfTtcbiAgdmFyIHByaW1hcnlDaGlsZEZyYWdtZW50O1xuICB2YXIgZmFsbGJhY2tDaGlsZEZyYWdtZW50O1xuXG4gIGlmICgobW9kZSAmIEJsb2NraW5nTW9kZSkgPT09IE5vTW9kZSAmJiBwcm9ncmVzc2VkUHJpbWFyeUZyYWdtZW50ICE9PSBudWxsKSB7XG4gICAgLy8gSW4gbGVnYWN5IG1vZGUsIHdlIGNvbW1pdCB0aGUgcHJpbWFyeSB0cmVlIGFzIGlmIGl0IHN1Y2Nlc3NmdWxseVxuICAgIC8vIGNvbXBsZXRlZCwgZXZlbiB0aG91Z2ggaXQncyBpbiBhbiBpbmNvbnNpc3RlbnQgc3RhdGUuXG4gICAgcHJpbWFyeUNoaWxkRnJhZ21lbnQgPSBwcm9ncmVzc2VkUHJpbWFyeUZyYWdtZW50O1xuICAgIHByaW1hcnlDaGlsZEZyYWdtZW50LmNoaWxkTGFuZXMgPSBOb0xhbmVzO1xuICAgIHByaW1hcnlDaGlsZEZyYWdtZW50LnBlbmRpbmdQcm9wcyA9IHByaW1hcnlDaGlsZFByb3BzO1xuXG4gICAgaWYgKCB3b3JrSW5Qcm9ncmVzcy5tb2RlICYgUHJvZmlsZU1vZGUpIHtcbiAgICAgIC8vIFJlc2V0IHRoZSBkdXJhdGlvbnMgZnJvbSB0aGUgZmlyc3QgcGFzcyBzbyB0aGV5IGFyZW4ndCBpbmNsdWRlZCBpbiB0aGVcbiAgICAgIC8vIGZpbmFsIGFtb3VudHMuIFRoaXMgc2VlbXMgY291bnRlcmludHVpdGl2ZSwgc2luY2Ugd2UncmUgaW50ZW50aW9uYWxseVxuICAgICAgLy8gbm90IG1lYXN1cmluZyBwYXJ0IG9mIHRoZSByZW5kZXIgcGhhc2UsIGJ1dCB0aGlzIG1ha2VzIGl0IG1hdGNoIHdoYXQgd2VcbiAgICAgIC8vIGRvIGluIENvbmN1cnJlbnQgTW9kZS5cbiAgICAgIHByaW1hcnlDaGlsZEZyYWdtZW50LmFjdHVhbER1cmF0aW9uID0gMDtcbiAgICAgIHByaW1hcnlDaGlsZEZyYWdtZW50LmFjdHVhbFN0YXJ0VGltZSA9IC0xO1xuICAgICAgcHJpbWFyeUNoaWxkRnJhZ21lbnQuc2VsZkJhc2VEdXJhdGlvbiA9IDA7XG4gICAgICBwcmltYXJ5Q2hpbGRGcmFnbWVudC50cmVlQmFzZUR1cmF0aW9uID0gMDtcbiAgICB9XG5cbiAgICBmYWxsYmFja0NoaWxkRnJhZ21lbnQgPSBjcmVhdGVGaWJlckZyb21GcmFnbWVudChmYWxsYmFja0NoaWxkcmVuLCBtb2RlLCByZW5kZXJMYW5lcywgbnVsbCk7XG4gIH0gZWxzZSB7XG4gICAgcHJpbWFyeUNoaWxkRnJhZ21lbnQgPSBjcmVhdGVGaWJlckZyb21PZmZzY3JlZW4ocHJpbWFyeUNoaWxkUHJvcHMsIG1vZGUsIE5vTGFuZXMsIG51bGwpO1xuICAgIGZhbGxiYWNrQ2hpbGRGcmFnbWVudCA9IGNyZWF0ZUZpYmVyRnJvbUZyYWdtZW50KGZhbGxiYWNrQ2hpbGRyZW4sIG1vZGUsIHJlbmRlckxhbmVzLCBudWxsKTtcbiAgfVxuXG4gIHByaW1hcnlDaGlsZEZyYWdtZW50LnJldHVybiA9IHdvcmtJblByb2dyZXNzO1xuICBmYWxsYmFja0NoaWxkRnJhZ21lbnQucmV0dXJuID0gd29ya0luUHJvZ3Jlc3M7XG4gIHByaW1hcnlDaGlsZEZyYWdtZW50LnNpYmxpbmcgPSBmYWxsYmFja0NoaWxkRnJhZ21lbnQ7XG4gIHdvcmtJblByb2dyZXNzLmNoaWxkID0gcHJpbWFyeUNoaWxkRnJhZ21lbnQ7XG4gIHJldHVybiBmYWxsYmFja0NoaWxkRnJhZ21lbnQ7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVdvcmtJblByb2dyZXNzT2Zmc2NyZWVuRmliZXIoY3VycmVudCwgb2Zmc2NyZWVuUHJvcHMpIHtcbiAgLy8gVGhlIHByb3BzIGFyZ3VtZW50IHRvIGBjcmVhdGVXb3JrSW5Qcm9ncmVzc2AgaXMgYGFueWAgdHlwZWQsIHNvIHdlIHVzZSB0aGlzXG4gIC8vIHdyYXBwZXIgZnVuY3Rpb24gdG8gY29uc3RyYWluIGl0LlxuICByZXR1cm4gY3JlYXRlV29ya0luUHJvZ3Jlc3MoY3VycmVudCwgb2Zmc2NyZWVuUHJvcHMpO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVTdXNwZW5zZVByaW1hcnlDaGlsZHJlbihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcHJpbWFyeUNoaWxkcmVuLCByZW5kZXJMYW5lcykge1xuICB2YXIgY3VycmVudFByaW1hcnlDaGlsZEZyYWdtZW50ID0gY3VycmVudC5jaGlsZDtcbiAgdmFyIGN1cnJlbnRGYWxsYmFja0NoaWxkRnJhZ21lbnQgPSBjdXJyZW50UHJpbWFyeUNoaWxkRnJhZ21lbnQuc2libGluZztcbiAgdmFyIHByaW1hcnlDaGlsZEZyYWdtZW50ID0gY3JlYXRlV29ya0luUHJvZ3Jlc3NPZmZzY3JlZW5GaWJlcihjdXJyZW50UHJpbWFyeUNoaWxkRnJhZ21lbnQsIHtcbiAgICBtb2RlOiAndmlzaWJsZScsXG4gICAgY2hpbGRyZW46IHByaW1hcnlDaGlsZHJlblxuICB9KTtcblxuICBpZiAoKHdvcmtJblByb2dyZXNzLm1vZGUgJiBCbG9ja2luZ01vZGUpID09PSBOb01vZGUpIHtcbiAgICBwcmltYXJ5Q2hpbGRGcmFnbWVudC5sYW5lcyA9IHJlbmRlckxhbmVzO1xuICB9XG5cbiAgcHJpbWFyeUNoaWxkRnJhZ21lbnQucmV0dXJuID0gd29ya0luUHJvZ3Jlc3M7XG4gIHByaW1hcnlDaGlsZEZyYWdtZW50LnNpYmxpbmcgPSBudWxsO1xuXG4gIGlmIChjdXJyZW50RmFsbGJhY2tDaGlsZEZyYWdtZW50ICE9PSBudWxsKSB7XG4gICAgLy8gRGVsZXRlIHRoZSBmYWxsYmFjayBjaGlsZCBmcmFnbWVudFxuICAgIGN1cnJlbnRGYWxsYmFja0NoaWxkRnJhZ21lbnQubmV4dEVmZmVjdCA9IG51bGw7XG4gICAgY3VycmVudEZhbGxiYWNrQ2hpbGRGcmFnbWVudC5mbGFncyA9IERlbGV0aW9uO1xuICAgIHdvcmtJblByb2dyZXNzLmZpcnN0RWZmZWN0ID0gd29ya0luUHJvZ3Jlc3MubGFzdEVmZmVjdCA9IGN1cnJlbnRGYWxsYmFja0NoaWxkRnJhZ21lbnQ7XG4gIH1cblxuICB3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IHByaW1hcnlDaGlsZEZyYWdtZW50O1xuICByZXR1cm4gcHJpbWFyeUNoaWxkRnJhZ21lbnQ7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZVN1c3BlbnNlRmFsbGJhY2tDaGlsZHJlbihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcHJpbWFyeUNoaWxkcmVuLCBmYWxsYmFja0NoaWxkcmVuLCByZW5kZXJMYW5lcykge1xuICB2YXIgbW9kZSA9IHdvcmtJblByb2dyZXNzLm1vZGU7XG4gIHZhciBjdXJyZW50UHJpbWFyeUNoaWxkRnJhZ21lbnQgPSBjdXJyZW50LmNoaWxkO1xuICB2YXIgY3VycmVudEZhbGxiYWNrQ2hpbGRGcmFnbWVudCA9IGN1cnJlbnRQcmltYXJ5Q2hpbGRGcmFnbWVudC5zaWJsaW5nO1xuICB2YXIgcHJpbWFyeUNoaWxkUHJvcHMgPSB7XG4gICAgbW9kZTogJ2hpZGRlbicsXG4gICAgY2hpbGRyZW46IHByaW1hcnlDaGlsZHJlblxuICB9O1xuICB2YXIgcHJpbWFyeUNoaWxkRnJhZ21lbnQ7XG5cbiAgaWYgKCAvLyBJbiBsZWdhY3kgbW9kZSwgd2UgY29tbWl0IHRoZSBwcmltYXJ5IHRyZWUgYXMgaWYgaXQgc3VjY2Vzc2Z1bGx5XG4gIC8vIGNvbXBsZXRlZCwgZXZlbiB0aG91Z2ggaXQncyBpbiBhbiBpbmNvbnNpc3RlbnQgc3RhdGUuXG4gIChtb2RlICYgQmxvY2tpbmdNb2RlKSA9PT0gTm9Nb2RlICYmIC8vIE1ha2Ugc3VyZSB3ZSdyZSBvbiB0aGUgc2Vjb25kIHBhc3MsIGkuZS4gdGhlIHByaW1hcnkgY2hpbGQgZnJhZ21lbnQgd2FzXG4gIC8vIGFscmVhZHkgY2xvbmVkLiBJbiBsZWdhY3kgbW9kZSwgdGhlIG9ubHkgY2FzZSB3aGVyZSB0aGlzIGlzbid0IHRydWUgaXNcbiAgLy8gd2hlbiBEZXZUb29scyBmb3JjZXMgdXMgdG8gZGlzcGxheSBhIGZhbGxiYWNrOyB3ZSBza2lwIHRoZSBmaXJzdCByZW5kZXJcbiAgLy8gcGFzcyBlbnRpcmVseSBhbmQgZ28gc3RyYWlnaHQgdG8gcmVuZGVyaW5nIHRoZSBmYWxsYmFjay4gKEluIENvbmN1cnJlbnRcbiAgLy8gTW9kZSwgU3VzcGVuc2VMaXN0IGNhbiBhbHNvIHRyaWdnZXIgdGhpcyBzY2VuYXJpbywgYnV0IHRoaXMgaXMgYSBsZWdhY3ktXG4gIC8vIG9ubHkgY29kZXBhdGguKVxuICB3b3JrSW5Qcm9ncmVzcy5jaGlsZCAhPT0gY3VycmVudFByaW1hcnlDaGlsZEZyYWdtZW50KSB7XG4gICAgdmFyIHByb2dyZXNzZWRQcmltYXJ5RnJhZ21lbnQgPSB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbiAgICBwcmltYXJ5Q2hpbGRGcmFnbWVudCA9IHByb2dyZXNzZWRQcmltYXJ5RnJhZ21lbnQ7XG4gICAgcHJpbWFyeUNoaWxkRnJhZ21lbnQuY2hpbGRMYW5lcyA9IE5vTGFuZXM7XG4gICAgcHJpbWFyeUNoaWxkRnJhZ21lbnQucGVuZGluZ1Byb3BzID0gcHJpbWFyeUNoaWxkUHJvcHM7XG5cbiAgICBpZiAoIHdvcmtJblByb2dyZXNzLm1vZGUgJiBQcm9maWxlTW9kZSkge1xuICAgICAgLy8gUmVzZXQgdGhlIGR1cmF0aW9ucyBmcm9tIHRoZSBmaXJzdCBwYXNzIHNvIHRoZXkgYXJlbid0IGluY2x1ZGVkIGluIHRoZVxuICAgICAgLy8gZmluYWwgYW1vdW50cy4gVGhpcyBzZWVtcyBjb3VudGVyaW50dWl0aXZlLCBzaW5jZSB3ZSdyZSBpbnRlbnRpb25hbGx5XG4gICAgICAvLyBub3QgbWVhc3VyaW5nIHBhcnQgb2YgdGhlIHJlbmRlciBwaGFzZSwgYnV0IHRoaXMgbWFrZXMgaXQgbWF0Y2ggd2hhdCB3ZVxuICAgICAgLy8gZG8gaW4gQ29uY3VycmVudCBNb2RlLlxuICAgICAgcHJpbWFyeUNoaWxkRnJhZ21lbnQuYWN0dWFsRHVyYXRpb24gPSAwO1xuICAgICAgcHJpbWFyeUNoaWxkRnJhZ21lbnQuYWN0dWFsU3RhcnRUaW1lID0gLTE7XG4gICAgICBwcmltYXJ5Q2hpbGRGcmFnbWVudC5zZWxmQmFzZUR1cmF0aW9uID0gY3VycmVudFByaW1hcnlDaGlsZEZyYWdtZW50LnNlbGZCYXNlRHVyYXRpb247XG4gICAgICBwcmltYXJ5Q2hpbGRGcmFnbWVudC50cmVlQmFzZUR1cmF0aW9uID0gY3VycmVudFByaW1hcnlDaGlsZEZyYWdtZW50LnRyZWVCYXNlRHVyYXRpb247XG4gICAgfSAvLyBUaGUgZmFsbGJhY2sgZmliZXIgd2FzIGFkZGVkIGFzIGEgZGVsZXRpb24gZWZmZWN0IGR1cmluZyB0aGUgZmlyc3QgcGFzcy5cbiAgICAvLyBIb3dldmVyLCBzaW5jZSB3ZSdyZSBnb2luZyB0byByZW1haW4gb24gdGhlIGZhbGxiYWNrLCB3ZSBubyBsb25nZXIgd2FudFxuICAgIC8vIHRvIGRlbGV0ZSBpdC4gU28gd2UgbmVlZCB0byByZW1vdmUgaXQgZnJvbSB0aGUgbGlzdC4gRGVsZXRpb25zIGFyZSBzdG9yZWRcbiAgICAvLyBvbiB0aGUgc2FtZSBsaXN0IGFzIGVmZmVjdHMuIFdlIHdhbnQgdG8ga2VlcCB0aGUgZWZmZWN0cyBmcm9tIHRoZSBwcmltYXJ5XG4gICAgLy8gdHJlZS4gU28gd2UgY29weSB0aGUgcHJpbWFyeSBjaGlsZCBmcmFnbWVudCdzIGVmZmVjdCBsaXN0LCB3aGljaCBkb2VzIG5vdFxuICAgIC8vIGluY2x1ZGUgdGhlIGZhbGxiYWNrIGRlbGV0aW9uIGVmZmVjdC5cblxuXG4gICAgdmFyIHByb2dyZXNzZWRMYXN0RWZmZWN0ID0gcHJpbWFyeUNoaWxkRnJhZ21lbnQubGFzdEVmZmVjdDtcblxuICAgIGlmIChwcm9ncmVzc2VkTGFzdEVmZmVjdCAhPT0gbnVsbCkge1xuICAgICAgd29ya0luUHJvZ3Jlc3MuZmlyc3RFZmZlY3QgPSBwcmltYXJ5Q2hpbGRGcmFnbWVudC5maXJzdEVmZmVjdDtcbiAgICAgIHdvcmtJblByb2dyZXNzLmxhc3RFZmZlY3QgPSBwcm9ncmVzc2VkTGFzdEVmZmVjdDtcbiAgICAgIHByb2dyZXNzZWRMYXN0RWZmZWN0Lm5leHRFZmZlY3QgPSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBUT0RPOiBSZXNldCB0aGlzIHNvbWV3aGVyZSBlbHNlPyBMb2wgbGVnYWN5IG1vZGUgaXMgc28gd2VpcmQuXG4gICAgICB3b3JrSW5Qcm9ncmVzcy5maXJzdEVmZmVjdCA9IHdvcmtJblByb2dyZXNzLmxhc3RFZmZlY3QgPSBudWxsO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBwcmltYXJ5Q2hpbGRGcmFnbWVudCA9IGNyZWF0ZVdvcmtJblByb2dyZXNzT2Zmc2NyZWVuRmliZXIoY3VycmVudFByaW1hcnlDaGlsZEZyYWdtZW50LCBwcmltYXJ5Q2hpbGRQcm9wcyk7XG4gIH1cblxuICB2YXIgZmFsbGJhY2tDaGlsZEZyYWdtZW50O1xuXG4gIGlmIChjdXJyZW50RmFsbGJhY2tDaGlsZEZyYWdtZW50ICE9PSBudWxsKSB7XG4gICAgZmFsbGJhY2tDaGlsZEZyYWdtZW50ID0gY3JlYXRlV29ya0luUHJvZ3Jlc3MoY3VycmVudEZhbGxiYWNrQ2hpbGRGcmFnbWVudCwgZmFsbGJhY2tDaGlsZHJlbik7XG4gIH0gZWxzZSB7XG4gICAgZmFsbGJhY2tDaGlsZEZyYWdtZW50ID0gY3JlYXRlRmliZXJGcm9tRnJhZ21lbnQoZmFsbGJhY2tDaGlsZHJlbiwgbW9kZSwgcmVuZGVyTGFuZXMsIG51bGwpOyAvLyBOZWVkcyBhIHBsYWNlbWVudCBlZmZlY3QgYmVjYXVzZSB0aGUgcGFyZW50ICh0aGUgU3VzcGVuc2UgYm91bmRhcnkpIGFscmVhZHlcbiAgICAvLyBtb3VudGVkIGJ1dCB0aGlzIGlzIGEgbmV3IGZpYmVyLlxuXG4gICAgZmFsbGJhY2tDaGlsZEZyYWdtZW50LmZsYWdzIHw9IFBsYWNlbWVudDtcbiAgfVxuXG4gIGZhbGxiYWNrQ2hpbGRGcmFnbWVudC5yZXR1cm4gPSB3b3JrSW5Qcm9ncmVzcztcbiAgcHJpbWFyeUNoaWxkRnJhZ21lbnQucmV0dXJuID0gd29ya0luUHJvZ3Jlc3M7XG4gIHByaW1hcnlDaGlsZEZyYWdtZW50LnNpYmxpbmcgPSBmYWxsYmFja0NoaWxkRnJhZ21lbnQ7XG4gIHdvcmtJblByb2dyZXNzLmNoaWxkID0gcHJpbWFyeUNoaWxkRnJhZ21lbnQ7XG4gIHJldHVybiBmYWxsYmFja0NoaWxkRnJhZ21lbnQ7XG59XG5cbmZ1bmN0aW9uIHNjaGVkdWxlV29ya09uRmliZXIoZmliZXIsIHJlbmRlckxhbmVzKSB7XG4gIGZpYmVyLmxhbmVzID0gbWVyZ2VMYW5lcyhmaWJlci5sYW5lcywgcmVuZGVyTGFuZXMpO1xuICB2YXIgYWx0ZXJuYXRlID0gZmliZXIuYWx0ZXJuYXRlO1xuXG4gIGlmIChhbHRlcm5hdGUgIT09IG51bGwpIHtcbiAgICBhbHRlcm5hdGUubGFuZXMgPSBtZXJnZUxhbmVzKGFsdGVybmF0ZS5sYW5lcywgcmVuZGVyTGFuZXMpO1xuICB9XG5cbiAgc2NoZWR1bGVXb3JrT25QYXJlbnRQYXRoKGZpYmVyLnJldHVybiwgcmVuZGVyTGFuZXMpO1xufVxuXG5mdW5jdGlvbiBwcm9wYWdhdGVTdXNwZW5zZUNvbnRleHRDaGFuZ2Uod29ya0luUHJvZ3Jlc3MsIGZpcnN0Q2hpbGQsIHJlbmRlckxhbmVzKSB7XG4gIC8vIE1hcmsgYW55IFN1c3BlbnNlIGJvdW5kYXJpZXMgd2l0aCBmYWxsYmFja3MgYXMgaGF2aW5nIHdvcmsgdG8gZG8uXG4gIC8vIElmIHRoZXkgd2VyZSBwcmV2aW91c2x5IGZvcmNlZCBpbnRvIGZhbGxiYWNrcywgdGhleSBtYXkgbm93IGJlIGFibGVcbiAgLy8gdG8gdW5ibG9jay5cbiAgdmFyIG5vZGUgPSBmaXJzdENoaWxkO1xuXG4gIHdoaWxlIChub2RlICE9PSBudWxsKSB7XG4gICAgaWYgKG5vZGUudGFnID09PSBTdXNwZW5zZUNvbXBvbmVudCkge1xuICAgICAgdmFyIHN0YXRlID0gbm9kZS5tZW1vaXplZFN0YXRlO1xuXG4gICAgICBpZiAoc3RhdGUgIT09IG51bGwpIHtcbiAgICAgICAgc2NoZWR1bGVXb3JrT25GaWJlcihub2RlLCByZW5kZXJMYW5lcyk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChub2RlLnRhZyA9PT0gU3VzcGVuc2VMaXN0Q29tcG9uZW50KSB7XG4gICAgICAvLyBJZiB0aGUgdGFpbCBpcyBoaWRkZW4gdGhlcmUgbWlnaHQgbm90IGJlIGFuIFN1c3BlbnNlIGJvdW5kYXJpZXNcbiAgICAgIC8vIHRvIHNjaGVkdWxlIHdvcmsgb24uIEluIHRoaXMgY2FzZSB3ZSBoYXZlIHRvIHNjaGVkdWxlIGl0IG9uIHRoZVxuICAgICAgLy8gbGlzdCBpdHNlbGYuXG4gICAgICAvLyBXZSBkb24ndCBoYXZlIHRvIHRyYXZlcnNlIHRvIHRoZSBjaGlsZHJlbiBvZiB0aGUgbGlzdCBzaW5jZVxuICAgICAgLy8gdGhlIGxpc3Qgd2lsbCBwcm9wYWdhdGUgdGhlIGNoYW5nZSB3aGVuIGl0IHJlcmVuZGVycy5cbiAgICAgIHNjaGVkdWxlV29ya09uRmliZXIobm9kZSwgcmVuZGVyTGFuZXMpO1xuICAgIH0gZWxzZSBpZiAobm9kZS5jaGlsZCAhPT0gbnVsbCkge1xuICAgICAgbm9kZS5jaGlsZC5yZXR1cm4gPSBub2RlO1xuICAgICAgbm9kZSA9IG5vZGUuY2hpbGQ7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpZiAobm9kZSA9PT0gd29ya0luUHJvZ3Jlc3MpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB3aGlsZSAobm9kZS5zaWJsaW5nID09PSBudWxsKSB7XG4gICAgICBpZiAobm9kZS5yZXR1cm4gPT09IG51bGwgfHwgbm9kZS5yZXR1cm4gPT09IHdvcmtJblByb2dyZXNzKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgbm9kZSA9IG5vZGUucmV0dXJuO1xuICAgIH1cblxuICAgIG5vZGUuc2libGluZy5yZXR1cm4gPSBub2RlLnJldHVybjtcbiAgICBub2RlID0gbm9kZS5zaWJsaW5nO1xuICB9XG59XG5cbmZ1bmN0aW9uIGZpbmRMYXN0Q29udGVudFJvdyhmaXJzdENoaWxkKSB7XG4gIC8vIFRoaXMgaXMgZ29pbmcgdG8gZmluZCB0aGUgbGFzdCByb3cgYW1vbmcgdGhlc2UgY2hpbGRyZW4gdGhhdCBpcyBhbHJlYWR5XG4gIC8vIHNob3dpbmcgY29udGVudCBvbiB0aGUgc2NyZWVuLCBhcyBvcHBvc2VkIHRvIGJlaW5nIGluIGZhbGxiYWNrIHN0YXRlIG9yXG4gIC8vIG5ldy4gSWYgYSByb3cgaGFzIG11bHRpcGxlIFN1c3BlbnNlIGJvdW5kYXJpZXMsIGFueSBvZiB0aGVtIGJlaW5nIGluIHRoZVxuICAvLyBmYWxsYmFjayBzdGF0ZSwgY291bnRzIGFzIHRoZSB3aG9sZSByb3cgYmVpbmcgaW4gYSBmYWxsYmFjayBzdGF0ZS5cbiAgLy8gTm90ZSB0aGF0IHRoZSBcInJvd3NcIiB3aWxsIGJlIHdvcmtJblByb2dyZXNzLCBidXQgYW55IG5lc3RlZCBjaGlsZHJlblxuICAvLyB3aWxsIHN0aWxsIGJlIGN1cnJlbnQgc2luY2Ugd2UgaGF2ZW4ndCByZW5kZXJlZCB0aGVtIHlldC4gVGhlIG1vdW50ZWRcbiAgLy8gb3JkZXIgbWF5IG5vdCBiZSB0aGUgc2FtZSBhcyB0aGUgbmV3IG9yZGVyLiBXZSB1c2UgdGhlIG5ldyBvcmRlci5cbiAgdmFyIHJvdyA9IGZpcnN0Q2hpbGQ7XG4gIHZhciBsYXN0Q29udGVudFJvdyA9IG51bGw7XG5cbiAgd2hpbGUgKHJvdyAhPT0gbnVsbCkge1xuICAgIHZhciBjdXJyZW50Um93ID0gcm93LmFsdGVybmF0ZTsgLy8gTmV3IHJvd3MgY2FuJ3QgYmUgY29udGVudCByb3dzLlxuXG4gICAgaWYgKGN1cnJlbnRSb3cgIT09IG51bGwgJiYgZmluZEZpcnN0U3VzcGVuZGVkKGN1cnJlbnRSb3cpID09PSBudWxsKSB7XG4gICAgICBsYXN0Q29udGVudFJvdyA9IHJvdztcbiAgICB9XG5cbiAgICByb3cgPSByb3cuc2libGluZztcbiAgfVxuXG4gIHJldHVybiBsYXN0Q29udGVudFJvdztcbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVSZXZlYWxPcmRlcihyZXZlYWxPcmRlcikge1xuICB7XG4gICAgaWYgKHJldmVhbE9yZGVyICE9PSB1bmRlZmluZWQgJiYgcmV2ZWFsT3JkZXIgIT09ICdmb3J3YXJkcycgJiYgcmV2ZWFsT3JkZXIgIT09ICdiYWNrd2FyZHMnICYmIHJldmVhbE9yZGVyICE9PSAndG9nZXRoZXInICYmICFkaWRXYXJuQWJvdXRSZXZlYWxPcmRlcltyZXZlYWxPcmRlcl0pIHtcbiAgICAgIGRpZFdhcm5BYm91dFJldmVhbE9yZGVyW3JldmVhbE9yZGVyXSA9IHRydWU7XG5cbiAgICAgIGlmICh0eXBlb2YgcmV2ZWFsT3JkZXIgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHN3aXRjaCAocmV2ZWFsT3JkZXIudG9Mb3dlckNhc2UoKSkge1xuICAgICAgICAgIGNhc2UgJ3RvZ2V0aGVyJzpcbiAgICAgICAgICBjYXNlICdmb3J3YXJkcyc6XG4gICAgICAgICAgY2FzZSAnYmFja3dhcmRzJzpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgZXJyb3IoJ1wiJXNcIiBpcyBub3QgYSB2YWxpZCB2YWx1ZSBmb3IgcmV2ZWFsT3JkZXIgb24gPFN1c3BlbnNlTGlzdCAvPi4gJyArICdVc2UgbG93ZXJjYXNlIFwiJXNcIiBpbnN0ZWFkLicsIHJldmVhbE9yZGVyLCByZXZlYWxPcmRlci50b0xvd2VyQ2FzZSgpKTtcblxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIGNhc2UgJ2ZvcndhcmQnOlxuICAgICAgICAgIGNhc2UgJ2JhY2t3YXJkJzpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgZXJyb3IoJ1wiJXNcIiBpcyBub3QgYSB2YWxpZCB2YWx1ZSBmb3IgcmV2ZWFsT3JkZXIgb24gPFN1c3BlbnNlTGlzdCAvPi4gJyArICdSZWFjdCB1c2VzIHRoZSAtcyBzdWZmaXggaW4gdGhlIHNwZWxsaW5nLiBVc2UgXCIlc3NcIiBpbnN0ZWFkLicsIHJldmVhbE9yZGVyLCByZXZlYWxPcmRlci50b0xvd2VyQ2FzZSgpKTtcblxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBlcnJvcignXCIlc1wiIGlzIG5vdCBhIHN1cHBvcnRlZCByZXZlYWxPcmRlciBvbiA8U3VzcGVuc2VMaXN0IC8+LiAnICsgJ0RpZCB5b3UgbWVhbiBcInRvZ2V0aGVyXCIsIFwiZm9yd2FyZHNcIiBvciBcImJhY2t3YXJkc1wiPycsIHJldmVhbE9yZGVyKTtcblxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVycm9yKCclcyBpcyBub3QgYSBzdXBwb3J0ZWQgdmFsdWUgZm9yIHJldmVhbE9yZGVyIG9uIDxTdXNwZW5zZUxpc3QgLz4uICcgKyAnRGlkIHlvdSBtZWFuIFwidG9nZXRoZXJcIiwgXCJmb3J3YXJkc1wiIG9yIFwiYmFja3dhcmRzXCI/JywgcmV2ZWFsT3JkZXIpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZVRhaWxPcHRpb25zKHRhaWxNb2RlLCByZXZlYWxPcmRlcikge1xuICB7XG4gICAgaWYgKHRhaWxNb2RlICE9PSB1bmRlZmluZWQgJiYgIWRpZFdhcm5BYm91dFRhaWxPcHRpb25zW3RhaWxNb2RlXSkge1xuICAgICAgaWYgKHRhaWxNb2RlICE9PSAnY29sbGFwc2VkJyAmJiB0YWlsTW9kZSAhPT0gJ2hpZGRlbicpIHtcbiAgICAgICAgZGlkV2FybkFib3V0VGFpbE9wdGlvbnNbdGFpbE1vZGVdID0gdHJ1ZTtcblxuICAgICAgICBlcnJvcignXCIlc1wiIGlzIG5vdCBhIHN1cHBvcnRlZCB2YWx1ZSBmb3IgdGFpbCBvbiA8U3VzcGVuc2VMaXN0IC8+LiAnICsgJ0RpZCB5b3UgbWVhbiBcImNvbGxhcHNlZFwiIG9yIFwiaGlkZGVuXCI/JywgdGFpbE1vZGUpO1xuICAgICAgfSBlbHNlIGlmIChyZXZlYWxPcmRlciAhPT0gJ2ZvcndhcmRzJyAmJiByZXZlYWxPcmRlciAhPT0gJ2JhY2t3YXJkcycpIHtcbiAgICAgICAgZGlkV2FybkFib3V0VGFpbE9wdGlvbnNbdGFpbE1vZGVdID0gdHJ1ZTtcblxuICAgICAgICBlcnJvcignPFN1c3BlbnNlTGlzdCB0YWlsPVwiJXNcIiAvPiBpcyBvbmx5IHZhbGlkIGlmIHJldmVhbE9yZGVyIGlzICcgKyAnXCJmb3J3YXJkc1wiIG9yIFwiYmFja3dhcmRzXCIuICcgKyAnRGlkIHlvdSBtZWFuIHRvIHNwZWNpZnkgcmV2ZWFsT3JkZXI9XCJmb3J3YXJkc1wiPycsIHRhaWxNb2RlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVTdXNwZW5zZUxpc3ROZXN0ZWRDaGlsZChjaGlsZFNsb3QsIGluZGV4KSB7XG4gIHtcbiAgICB2YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXkoY2hpbGRTbG90KTtcbiAgICB2YXIgaXNJdGVyYWJsZSA9ICFpc0FycmF5ICYmIHR5cGVvZiBnZXRJdGVyYXRvckZuKGNoaWxkU2xvdCkgPT09ICdmdW5jdGlvbic7XG5cbiAgICBpZiAoaXNBcnJheSB8fCBpc0l0ZXJhYmxlKSB7XG4gICAgICB2YXIgdHlwZSA9IGlzQXJyYXkgPyAnYXJyYXknIDogJ2l0ZXJhYmxlJztcblxuICAgICAgZXJyb3IoJ0EgbmVzdGVkICVzIHdhcyBwYXNzZWQgdG8gcm93ICMlcyBpbiA8U3VzcGVuc2VMaXN0IC8+LiBXcmFwIGl0IGluICcgKyAnYW4gYWRkaXRpb25hbCBTdXNwZW5zZUxpc3QgdG8gY29uZmlndXJlIGl0cyByZXZlYWxPcmRlcjogJyArICc8U3VzcGVuc2VMaXN0IHJldmVhbE9yZGVyPS4uLj4gLi4uICcgKyAnPFN1c3BlbnNlTGlzdCByZXZlYWxPcmRlcj0uLi4+eyVzfTwvU3VzcGVuc2VMaXN0PiAuLi4gJyArICc8L1N1c3BlbnNlTGlzdD4nLCB0eXBlLCBpbmRleCwgdHlwZSk7XG5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVTdXNwZW5zZUxpc3RDaGlsZHJlbihjaGlsZHJlbiwgcmV2ZWFsT3JkZXIpIHtcbiAge1xuICAgIGlmICgocmV2ZWFsT3JkZXIgPT09ICdmb3J3YXJkcycgfHwgcmV2ZWFsT3JkZXIgPT09ICdiYWNrd2FyZHMnKSAmJiBjaGlsZHJlbiAhPT0gdW5kZWZpbmVkICYmIGNoaWxkcmVuICE9PSBudWxsICYmIGNoaWxkcmVuICE9PSBmYWxzZSkge1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBpZiAoIXZhbGlkYXRlU3VzcGVuc2VMaXN0TmVzdGVkQ2hpbGQoY2hpbGRyZW5baV0sIGkpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgaXRlcmF0b3JGbiA9IGdldEl0ZXJhdG9yRm4oY2hpbGRyZW4pO1xuXG4gICAgICAgIGlmICh0eXBlb2YgaXRlcmF0b3JGbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHZhciBjaGlsZHJlbkl0ZXJhdG9yID0gaXRlcmF0b3JGbi5jYWxsKGNoaWxkcmVuKTtcblxuICAgICAgICAgIGlmIChjaGlsZHJlbkl0ZXJhdG9yKSB7XG4gICAgICAgICAgICB2YXIgc3RlcCA9IGNoaWxkcmVuSXRlcmF0b3IubmV4dCgpO1xuICAgICAgICAgICAgdmFyIF9pID0gMDtcblxuICAgICAgICAgICAgZm9yICg7ICFzdGVwLmRvbmU7IHN0ZXAgPSBjaGlsZHJlbkl0ZXJhdG9yLm5leHQoKSkge1xuICAgICAgICAgICAgICBpZiAoIXZhbGlkYXRlU3VzcGVuc2VMaXN0TmVzdGVkQ2hpbGQoc3RlcC52YWx1ZSwgX2kpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgX2krKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZXJyb3IoJ0Egc2luZ2xlIHJvdyB3YXMgcGFzc2VkIHRvIGEgPFN1c3BlbnNlTGlzdCByZXZlYWxPcmRlcj1cIiVzXCIgLz4uICcgKyAnVGhpcyBpcyBub3QgdXNlZnVsIHNpbmNlIGl0IG5lZWRzIG11bHRpcGxlIHJvd3MuICcgKyAnRGlkIHlvdSBtZWFuIHRvIHBhc3MgbXVsdGlwbGUgY2hpbGRyZW4gb3IgYW4gYXJyYXk/JywgcmV2ZWFsT3JkZXIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGluaXRTdXNwZW5zZUxpc3RSZW5kZXJTdGF0ZSh3b3JrSW5Qcm9ncmVzcywgaXNCYWNrd2FyZHMsIHRhaWwsIGxhc3RDb250ZW50Um93LCB0YWlsTW9kZSwgbGFzdEVmZmVjdEJlZm9yZVJlbmRlcmluZykge1xuICB2YXIgcmVuZGVyU3RhdGUgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO1xuXG4gIGlmIChyZW5kZXJTdGF0ZSA9PT0gbnVsbCkge1xuICAgIHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSB7XG4gICAgICBpc0JhY2t3YXJkczogaXNCYWNrd2FyZHMsXG4gICAgICByZW5kZXJpbmc6IG51bGwsXG4gICAgICByZW5kZXJpbmdTdGFydFRpbWU6IDAsXG4gICAgICBsYXN0OiBsYXN0Q29udGVudFJvdyxcbiAgICAgIHRhaWw6IHRhaWwsXG4gICAgICB0YWlsTW9kZTogdGFpbE1vZGUsXG4gICAgICBsYXN0RWZmZWN0OiBsYXN0RWZmZWN0QmVmb3JlUmVuZGVyaW5nXG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICAvLyBXZSBjYW4gcmV1c2UgdGhlIGV4aXN0aW5nIG9iamVjdCBmcm9tIHByZXZpb3VzIHJlbmRlcnMuXG4gICAgcmVuZGVyU3RhdGUuaXNCYWNrd2FyZHMgPSBpc0JhY2t3YXJkcztcbiAgICByZW5kZXJTdGF0ZS5yZW5kZXJpbmcgPSBudWxsO1xuICAgIHJlbmRlclN0YXRlLnJlbmRlcmluZ1N0YXJ0VGltZSA9IDA7XG4gICAgcmVuZGVyU3RhdGUubGFzdCA9IGxhc3RDb250ZW50Um93O1xuICAgIHJlbmRlclN0YXRlLnRhaWwgPSB0YWlsO1xuICAgIHJlbmRlclN0YXRlLnRhaWxNb2RlID0gdGFpbE1vZGU7XG4gICAgcmVuZGVyU3RhdGUubGFzdEVmZmVjdCA9IGxhc3RFZmZlY3RCZWZvcmVSZW5kZXJpbmc7XG4gIH1cbn0gLy8gVGhpcyBjYW4gZW5kIHVwIHJlbmRlcmluZyB0aGlzIGNvbXBvbmVudCBtdWx0aXBsZSBwYXNzZXMuXG4vLyBUaGUgZmlyc3QgcGFzcyBzcGxpdHMgdGhlIGNoaWxkcmVuIGZpYmVycyBpbnRvIHR3byBzZXRzLiBBIGhlYWQgYW5kIHRhaWwuXG4vLyBXZSBmaXJzdCByZW5kZXIgdGhlIGhlYWQuIElmIGFueXRoaW5nIGlzIGluIGZhbGxiYWNrIHN0YXRlLCB3ZSBkbyBhbm90aGVyXG4vLyBwYXNzIHRocm91Z2ggYmVnaW5Xb3JrIHRvIHJlcmVuZGVyIGFsbCBjaGlsZHJlbiAoaW5jbHVkaW5nIHRoZSB0YWlsKSB3aXRoXG4vLyB0aGUgZm9yY2Ugc3VzcGVuZCBjb250ZXh0LiBJZiB0aGUgZmlyc3QgcmVuZGVyIGRpZG4ndCBoYXZlIGFueXRoaW5nIGluXG4vLyBpbiBmYWxsYmFjayBzdGF0ZS4gVGhlbiB3ZSByZW5kZXIgZWFjaCByb3cgaW4gdGhlIHRhaWwgb25lLWJ5LW9uZS5cbi8vIFRoYXQgaGFwcGVucyBpbiB0aGUgY29tcGxldGVXb3JrIHBoYXNlIHdpdGhvdXQgZ29pbmcgYmFjayB0byBiZWdpbldvcmsuXG5cblxuZnVuY3Rpb24gdXBkYXRlU3VzcGVuc2VMaXN0Q29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcykge1xuICB2YXIgbmV4dFByb3BzID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzO1xuICB2YXIgcmV2ZWFsT3JkZXIgPSBuZXh0UHJvcHMucmV2ZWFsT3JkZXI7XG4gIHZhciB0YWlsTW9kZSA9IG5leHRQcm9wcy50YWlsO1xuICB2YXIgbmV3Q2hpbGRyZW4gPSBuZXh0UHJvcHMuY2hpbGRyZW47XG4gIHZhbGlkYXRlUmV2ZWFsT3JkZXIocmV2ZWFsT3JkZXIpO1xuICB2YWxpZGF0ZVRhaWxPcHRpb25zKHRhaWxNb2RlLCByZXZlYWxPcmRlcik7XG4gIHZhbGlkYXRlU3VzcGVuc2VMaXN0Q2hpbGRyZW4obmV3Q2hpbGRyZW4sIHJldmVhbE9yZGVyKTtcbiAgcmVjb25jaWxlQ2hpbGRyZW4oY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIG5ld0NoaWxkcmVuLCByZW5kZXJMYW5lcyk7XG4gIHZhciBzdXNwZW5zZUNvbnRleHQgPSBzdXNwZW5zZVN0YWNrQ3Vyc29yLmN1cnJlbnQ7XG4gIHZhciBzaG91bGRGb3JjZUZhbGxiYWNrID0gaGFzU3VzcGVuc2VDb250ZXh0KHN1c3BlbnNlQ29udGV4dCwgRm9yY2VTdXNwZW5zZUZhbGxiYWNrKTtcblxuICBpZiAoc2hvdWxkRm9yY2VGYWxsYmFjaykge1xuICAgIHN1c3BlbnNlQ29udGV4dCA9IHNldFNoYWxsb3dTdXNwZW5zZUNvbnRleHQoc3VzcGVuc2VDb250ZXh0LCBGb3JjZVN1c3BlbnNlRmFsbGJhY2spO1xuICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IERpZENhcHR1cmU7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGRpZFN1c3BlbmRCZWZvcmUgPSBjdXJyZW50ICE9PSBudWxsICYmIChjdXJyZW50LmZsYWdzICYgRGlkQ2FwdHVyZSkgIT09IE5vRmxhZ3M7XG5cbiAgICBpZiAoZGlkU3VzcGVuZEJlZm9yZSkge1xuICAgICAgLy8gSWYgd2UgcHJldmlvdXNseSBmb3JjZWQgYSBmYWxsYmFjaywgd2UgbmVlZCB0byBzY2hlZHVsZSB3b3JrXG4gICAgICAvLyBvbiBhbnkgbmVzdGVkIGJvdW5kYXJpZXMgdG8gbGV0IHRoZW0ga25vdyB0byB0cnkgdG8gcmVuZGVyXG4gICAgICAvLyBhZ2Fpbi4gVGhpcyBpcyB0aGUgc2FtZSBhcyBjb250ZXh0IHVwZGF0aW5nLlxuICAgICAgcHJvcGFnYXRlU3VzcGVuc2VDb250ZXh0Q2hhbmdlKHdvcmtJblByb2dyZXNzLCB3b3JrSW5Qcm9ncmVzcy5jaGlsZCwgcmVuZGVyTGFuZXMpO1xuICAgIH1cblxuICAgIHN1c3BlbnNlQ29udGV4dCA9IHNldERlZmF1bHRTaGFsbG93U3VzcGVuc2VDb250ZXh0KHN1c3BlbnNlQ29udGV4dCk7XG4gIH1cblxuICBwdXNoU3VzcGVuc2VDb250ZXh0KHdvcmtJblByb2dyZXNzLCBzdXNwZW5zZUNvbnRleHQpO1xuXG4gIGlmICgod29ya0luUHJvZ3Jlc3MubW9kZSAmIEJsb2NraW5nTW9kZSkgPT09IE5vTW9kZSkge1xuICAgIC8vIEluIGxlZ2FjeSBtb2RlLCBTdXNwZW5zZUxpc3QgZG9lc24ndCB3b3JrIHNvIHdlIGp1c3RcbiAgICAvLyB1c2UgbWFrZSBpdCBhIG5vb3AgYnkgdHJlYXRpbmcgaXQgYXMgdGhlIGRlZmF1bHQgcmV2ZWFsT3JkZXIuXG4gICAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IG51bGw7XG4gIH0gZWxzZSB7XG4gICAgc3dpdGNoIChyZXZlYWxPcmRlcikge1xuICAgICAgY2FzZSAnZm9yd2FyZHMnOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIGxhc3RDb250ZW50Um93ID0gZmluZExhc3RDb250ZW50Um93KHdvcmtJblByb2dyZXNzLmNoaWxkKTtcbiAgICAgICAgICB2YXIgdGFpbDtcblxuICAgICAgICAgIGlmIChsYXN0Q29udGVudFJvdyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gVGhlIHdob2xlIGxpc3QgaXMgcGFydCBvZiB0aGUgdGFpbC5cbiAgICAgICAgICAgIC8vIFRPRE86IFdlIGNvdWxkIGZhc3QgcGF0aCBieSBqdXN0IHJlbmRlcmluZyB0aGUgdGFpbCBub3cuXG4gICAgICAgICAgICB0YWlsID0gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IG51bGw7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIERpc2Nvbm5lY3QgdGhlIHRhaWwgcm93cyBhZnRlciB0aGUgY29udGVudCByb3cuXG4gICAgICAgICAgICAvLyBXZSdyZSBnb2luZyB0byByZW5kZXIgdGhlbSBzZXBhcmF0ZWx5IGxhdGVyLlxuICAgICAgICAgICAgdGFpbCA9IGxhc3RDb250ZW50Um93LnNpYmxpbmc7XG4gICAgICAgICAgICBsYXN0Q29udGVudFJvdy5zaWJsaW5nID0gbnVsbDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpbml0U3VzcGVuc2VMaXN0UmVuZGVyU3RhdGUod29ya0luUHJvZ3Jlc3MsIGZhbHNlLCAvLyBpc0JhY2t3YXJkc1xuICAgICAgICAgIHRhaWwsIGxhc3RDb250ZW50Um93LCB0YWlsTW9kZSwgd29ya0luUHJvZ3Jlc3MubGFzdEVmZmVjdCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSAnYmFja3dhcmRzJzpcbiAgICAgICAge1xuICAgICAgICAgIC8vIFdlJ3JlIGdvaW5nIHRvIGZpbmQgdGhlIGZpcnN0IHJvdyB0aGF0IGhhcyBleGlzdGluZyBjb250ZW50LlxuICAgICAgICAgIC8vIEF0IHRoZSBzYW1lIHRpbWUgd2UncmUgZ29pbmcgdG8gcmV2ZXJzZSB0aGUgbGlzdCBvZiBldmVyeXRoaW5nXG4gICAgICAgICAgLy8gd2UgcGFzcyBpbiB0aGUgbWVhbnRpbWUuIFRoYXQncyBnb2luZyB0byBiZSBvdXIgdGFpbCBpbiByZXZlcnNlXG4gICAgICAgICAgLy8gb3JkZXIuXG4gICAgICAgICAgdmFyIF90YWlsID0gbnVsbDtcbiAgICAgICAgICB2YXIgcm93ID0gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3MuY2hpbGQgPSBudWxsO1xuXG4gICAgICAgICAgd2hpbGUgKHJvdyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdmFyIGN1cnJlbnRSb3cgPSByb3cuYWx0ZXJuYXRlOyAvLyBOZXcgcm93cyBjYW4ndCBiZSBjb250ZW50IHJvd3MuXG5cbiAgICAgICAgICAgIGlmIChjdXJyZW50Um93ICE9PSBudWxsICYmIGZpbmRGaXJzdFN1c3BlbmRlZChjdXJyZW50Um93KSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAvLyBUaGlzIGlzIHRoZSBiZWdpbm5pbmcgb2YgdGhlIG1haW4gY29udGVudC5cbiAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MuY2hpbGQgPSByb3c7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgbmV4dFJvdyA9IHJvdy5zaWJsaW5nO1xuICAgICAgICAgICAgcm93LnNpYmxpbmcgPSBfdGFpbDtcbiAgICAgICAgICAgIF90YWlsID0gcm93O1xuICAgICAgICAgICAgcm93ID0gbmV4dFJvdztcbiAgICAgICAgICB9IC8vIFRPRE86IElmIHdvcmtJblByb2dyZXNzLmNoaWxkIGlzIG51bGwsIHdlIGNhbiBjb250aW51ZSBvbiB0aGUgdGFpbCBpbW1lZGlhdGVseS5cblxuXG4gICAgICAgICAgaW5pdFN1c3BlbnNlTGlzdFJlbmRlclN0YXRlKHdvcmtJblByb2dyZXNzLCB0cnVlLCAvLyBpc0JhY2t3YXJkc1xuICAgICAgICAgIF90YWlsLCBudWxsLCAvLyBsYXN0XG4gICAgICAgICAgdGFpbE1vZGUsIHdvcmtJblByb2dyZXNzLmxhc3RFZmZlY3QpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgJ3RvZ2V0aGVyJzpcbiAgICAgICAge1xuICAgICAgICAgIGluaXRTdXNwZW5zZUxpc3RSZW5kZXJTdGF0ZSh3b3JrSW5Qcm9ncmVzcywgZmFsc2UsIC8vIGlzQmFja3dhcmRzXG4gICAgICAgICAgbnVsbCwgLy8gdGFpbFxuICAgICAgICAgIG51bGwsIC8vIGxhc3RcbiAgICAgICAgICB1bmRlZmluZWQsIHdvcmtJblByb2dyZXNzLmxhc3RFZmZlY3QpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHtcbiAgICAgICAgICAvLyBUaGUgZGVmYXVsdCByZXZlYWwgb3JkZXIgaXMgdGhlIHNhbWUgYXMgbm90IGhhdmluZ1xuICAgICAgICAgIC8vIGEgYm91bmRhcnkuXG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZVBvcnRhbENvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpIHtcbiAgcHVzaEhvc3RDb250YWluZXIod29ya0luUHJvZ3Jlc3MsIHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZS5jb250YWluZXJJbmZvKTtcbiAgdmFyIG5leHRDaGlsZHJlbiA9IHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcztcblxuICBpZiAoY3VycmVudCA9PT0gbnVsbCkge1xuICAgIC8vIFBvcnRhbHMgYXJlIHNwZWNpYWwgYmVjYXVzZSB3ZSBkb24ndCBhcHBlbmQgdGhlIGNoaWxkcmVuIGR1cmluZyBtb3VudFxuICAgIC8vIGJ1dCBhdCBjb21taXQuIFRoZXJlZm9yZSB3ZSBuZWVkIHRvIHRyYWNrIGluc2VydGlvbnMgd2hpY2ggdGhlIG5vcm1hbFxuICAgIC8vIGZsb3cgZG9lc24ndCBkbyBkdXJpbmcgbW91bnQuIFRoaXMgZG9lc24ndCBoYXBwZW4gYXQgdGhlIHJvb3QgYmVjYXVzZVxuICAgIC8vIHRoZSByb290IGFsd2F5cyBzdGFydHMgd2l0aCBhIFwiY3VycmVudFwiIHdpdGggYSBudWxsIGNoaWxkLlxuICAgIC8vIFRPRE86IENvbnNpZGVyIHVuaWZ5aW5nIHRoaXMgd2l0aCBob3cgdGhlIHJvb3Qgd29ya3MuXG4gICAgd29ya0luUHJvZ3Jlc3MuY2hpbGQgPSByZWNvbmNpbGVDaGlsZEZpYmVycyh3b3JrSW5Qcm9ncmVzcywgbnVsbCwgbmV4dENoaWxkcmVuLCByZW5kZXJMYW5lcyk7XG4gIH0gZWxzZSB7XG4gICAgcmVjb25jaWxlQ2hpbGRyZW4oY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIG5leHRDaGlsZHJlbiwgcmVuZGVyTGFuZXMpO1xuICB9XG5cbiAgcmV0dXJuIHdvcmtJblByb2dyZXNzLmNoaWxkO1xufVxuXG52YXIgaGFzV2FybmVkQWJvdXRVc2luZ05vVmFsdWVQcm9wT25Db250ZXh0UHJvdmlkZXIgPSBmYWxzZTtcblxuZnVuY3Rpb24gdXBkYXRlQ29udGV4dFByb3ZpZGVyKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcykge1xuICB2YXIgcHJvdmlkZXJUeXBlID0gd29ya0luUHJvZ3Jlc3MudHlwZTtcbiAgdmFyIGNvbnRleHQgPSBwcm92aWRlclR5cGUuX2NvbnRleHQ7XG4gIHZhciBuZXdQcm9wcyA9IHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcztcbiAgdmFyIG9sZFByb3BzID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcztcbiAgdmFyIG5ld1ZhbHVlID0gbmV3UHJvcHMudmFsdWU7XG5cbiAge1xuICAgIGlmICghKCd2YWx1ZScgaW4gbmV3UHJvcHMpKSB7XG4gICAgICBpZiAoIWhhc1dhcm5lZEFib3V0VXNpbmdOb1ZhbHVlUHJvcE9uQ29udGV4dFByb3ZpZGVyKSB7XG4gICAgICAgIGhhc1dhcm5lZEFib3V0VXNpbmdOb1ZhbHVlUHJvcE9uQ29udGV4dFByb3ZpZGVyID0gdHJ1ZTtcblxuICAgICAgICBlcnJvcignVGhlIGB2YWx1ZWAgcHJvcCBpcyByZXF1aXJlZCBmb3IgdGhlIGA8Q29udGV4dC5Qcm92aWRlcj5gLiBEaWQgeW91IG1pc3NwZWxsIGl0IG9yIGZvcmdldCB0byBwYXNzIGl0PycpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBwcm92aWRlclByb3BUeXBlcyA9IHdvcmtJblByb2dyZXNzLnR5cGUucHJvcFR5cGVzO1xuXG4gICAgaWYgKHByb3ZpZGVyUHJvcFR5cGVzKSB7XG4gICAgICBjaGVja1Byb3BUeXBlcyhwcm92aWRlclByb3BUeXBlcywgbmV3UHJvcHMsICdwcm9wJywgJ0NvbnRleHQuUHJvdmlkZXInKTtcbiAgICB9XG4gIH1cblxuICBwdXNoUHJvdmlkZXIod29ya0luUHJvZ3Jlc3MsIG5ld1ZhbHVlKTtcblxuICBpZiAob2xkUHJvcHMgIT09IG51bGwpIHtcbiAgICB2YXIgb2xkVmFsdWUgPSBvbGRQcm9wcy52YWx1ZTtcbiAgICB2YXIgY2hhbmdlZEJpdHMgPSBjYWxjdWxhdGVDaGFuZ2VkQml0cyhjb250ZXh0LCBuZXdWYWx1ZSwgb2xkVmFsdWUpO1xuXG4gICAgaWYgKGNoYW5nZWRCaXRzID09PSAwKSB7XG4gICAgICAvLyBObyBjaGFuZ2UuIEJhaWxvdXQgZWFybHkgaWYgY2hpbGRyZW4gYXJlIHRoZSBzYW1lLlxuICAgICAgaWYgKG9sZFByb3BzLmNoaWxkcmVuID09PSBuZXdQcm9wcy5jaGlsZHJlbiAmJiAhaGFzQ29udGV4dENoYW5nZWQoKSkge1xuICAgICAgICByZXR1cm4gYmFpbG91dE9uQWxyZWFkeUZpbmlzaGVkV29yayhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBUaGUgY29udGV4dCB2YWx1ZSBjaGFuZ2VkLiBTZWFyY2ggZm9yIG1hdGNoaW5nIGNvbnN1bWVycyBhbmQgc2NoZWR1bGVcbiAgICAgIC8vIHRoZW0gdG8gdXBkYXRlLlxuICAgICAgcHJvcGFnYXRlQ29udGV4dENoYW5nZSh3b3JrSW5Qcm9ncmVzcywgY29udGV4dCwgY2hhbmdlZEJpdHMsIHJlbmRlckxhbmVzKTtcbiAgICB9XG4gIH1cblxuICB2YXIgbmV3Q2hpbGRyZW4gPSBuZXdQcm9wcy5jaGlsZHJlbjtcbiAgcmVjb25jaWxlQ2hpbGRyZW4oY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIG5ld0NoaWxkcmVuLCByZW5kZXJMYW5lcyk7XG4gIHJldHVybiB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbn1cblxudmFyIGhhc1dhcm5lZEFib3V0VXNpbmdDb250ZXh0QXNDb25zdW1lciA9IGZhbHNlO1xuXG5mdW5jdGlvbiB1cGRhdGVDb250ZXh0Q29uc3VtZXIoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKSB7XG4gIHZhciBjb250ZXh0ID0gd29ya0luUHJvZ3Jlc3MudHlwZTsgLy8gVGhlIGxvZ2ljIGJlbG93IGZvciBDb250ZXh0IGRpZmZlcnMgZGVwZW5kaW5nIG9uIFBST0Qgb3IgREVWIG1vZGUuIEluXG4gIC8vIERFViBtb2RlLCB3ZSBjcmVhdGUgYSBzZXBhcmF0ZSBvYmplY3QgZm9yIENvbnRleHQuQ29uc3VtZXIgdGhhdCBhY3RzXG4gIC8vIGxpa2UgYSBwcm94eSB0byBDb250ZXh0LiBUaGlzIHByb3h5IG9iamVjdCBhZGRzIHVubmVjZXNzYXJ5IGNvZGUgaW4gUFJPRFxuICAvLyBzbyB3ZSB1c2UgdGhlIG9sZCBiZWhhdmlvdXIgKENvbnRleHQuQ29uc3VtZXIgcmVmZXJlbmNlcyBDb250ZXh0KSB0b1xuICAvLyByZWR1Y2Ugc2l6ZSBhbmQgb3ZlcmhlYWQuIFRoZSBzZXBhcmF0ZSBvYmplY3QgcmVmZXJlbmNlcyBjb250ZXh0IHZpYVxuICAvLyBhIHByb3BlcnR5IGNhbGxlZCBcIl9jb250ZXh0XCIsIHdoaWNoIGFsc28gZ2l2ZXMgdXMgdGhlIGFiaWxpdHkgdG8gY2hlY2tcbiAgLy8gaW4gREVWIG1vZGUgaWYgdGhpcyBwcm9wZXJ0eSBleGlzdHMgb3Igbm90IGFuZCB3YXJuIGlmIGl0IGRvZXMgbm90LlxuXG4gIHtcbiAgICBpZiAoY29udGV4dC5fY29udGV4dCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBUaGlzIG1heSBiZSBiZWNhdXNlIGl0J3MgYSBDb250ZXh0IChyYXRoZXIgdGhhbiBhIENvbnN1bWVyKS5cbiAgICAgIC8vIE9yIGl0IG1heSBiZSBiZWNhdXNlIGl0J3Mgb2xkZXIgUmVhY3Qgd2hlcmUgdGhleSdyZSB0aGUgc2FtZSB0aGluZy5cbiAgICAgIC8vIFdlIG9ubHkgd2FudCB0byB3YXJuIGlmIHdlJ3JlIHN1cmUgaXQncyBhIG5ldyBSZWFjdC5cbiAgICAgIGlmIChjb250ZXh0ICE9PSBjb250ZXh0LkNvbnN1bWVyKSB7XG4gICAgICAgIGlmICghaGFzV2FybmVkQWJvdXRVc2luZ0NvbnRleHRBc0NvbnN1bWVyKSB7XG4gICAgICAgICAgaGFzV2FybmVkQWJvdXRVc2luZ0NvbnRleHRBc0NvbnN1bWVyID0gdHJ1ZTtcblxuICAgICAgICAgIGVycm9yKCdSZW5kZXJpbmcgPENvbnRleHQ+IGRpcmVjdGx5IGlzIG5vdCBzdXBwb3J0ZWQgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiAnICsgJ2EgZnV0dXJlIG1ham9yIHJlbGVhc2UuIERpZCB5b3UgbWVhbiB0byByZW5kZXIgPENvbnRleHQuQ29uc3VtZXI+IGluc3RlYWQ/Jyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29udGV4dCA9IGNvbnRleHQuX2NvbnRleHQ7XG4gICAgfVxuICB9XG5cbiAgdmFyIG5ld1Byb3BzID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzO1xuICB2YXIgcmVuZGVyID0gbmV3UHJvcHMuY2hpbGRyZW47XG5cbiAge1xuICAgIGlmICh0eXBlb2YgcmVuZGVyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICBlcnJvcignQSBjb250ZXh0IGNvbnN1bWVyIHdhcyByZW5kZXJlZCB3aXRoIG11bHRpcGxlIGNoaWxkcmVuLCBvciBhIGNoaWxkICcgKyBcInRoYXQgaXNuJ3QgYSBmdW5jdGlvbi4gQSBjb250ZXh0IGNvbnN1bWVyIGV4cGVjdHMgYSBzaW5nbGUgY2hpbGQgXCIgKyAndGhhdCBpcyBhIGZ1bmN0aW9uLiBJZiB5b3UgZGlkIHBhc3MgYSBmdW5jdGlvbiwgbWFrZSBzdXJlIHRoZXJlICcgKyAnaXMgbm8gdHJhaWxpbmcgb3IgbGVhZGluZyB3aGl0ZXNwYWNlIGFyb3VuZCBpdC4nKTtcbiAgICB9XG4gIH1cblxuICBwcmVwYXJlVG9SZWFkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpO1xuICB2YXIgbmV3VmFsdWUgPSByZWFkQ29udGV4dChjb250ZXh0LCBuZXdQcm9wcy51bnN0YWJsZV9vYnNlcnZlZEJpdHMpO1xuICB2YXIgbmV3Q2hpbGRyZW47XG5cbiAge1xuICAgIFJlYWN0Q3VycmVudE93bmVyJDEuY3VycmVudCA9IHdvcmtJblByb2dyZXNzO1xuICAgIHNldElzUmVuZGVyaW5nKHRydWUpO1xuICAgIG5ld0NoaWxkcmVuID0gcmVuZGVyKG5ld1ZhbHVlKTtcbiAgICBzZXRJc1JlbmRlcmluZyhmYWxzZSk7XG4gIH0gLy8gUmVhY3QgRGV2VG9vbHMgcmVhZHMgdGhpcyBmbGFnLlxuXG5cbiAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gUGVyZm9ybWVkV29yaztcbiAgcmVjb25jaWxlQ2hpbGRyZW4oY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIG5ld0NoaWxkcmVuLCByZW5kZXJMYW5lcyk7XG4gIHJldHVybiB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbn1cblxuZnVuY3Rpb24gbWFya1dvcmtJblByb2dyZXNzUmVjZWl2ZWRVcGRhdGUoKSB7XG4gIGRpZFJlY2VpdmVVcGRhdGUgPSB0cnVlO1xufVxuXG5mdW5jdGlvbiBiYWlsb3V0T25BbHJlYWR5RmluaXNoZWRXb3JrKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcykge1xuICBpZiAoY3VycmVudCAhPT0gbnVsbCkge1xuICAgIC8vIFJldXNlIHByZXZpb3VzIGRlcGVuZGVuY2llc1xuICAgIHdvcmtJblByb2dyZXNzLmRlcGVuZGVuY2llcyA9IGN1cnJlbnQuZGVwZW5kZW5jaWVzO1xuICB9XG5cbiAge1xuICAgIC8vIERvbid0IHVwZGF0ZSBcImJhc2VcIiByZW5kZXIgdGltZXMgZm9yIGJhaWxvdXRzLlxuICAgIHN0b3BQcm9maWxlclRpbWVySWZSdW5uaW5nKCk7XG4gIH1cblxuICBtYXJrU2tpcHBlZFVwZGF0ZUxhbmVzKHdvcmtJblByb2dyZXNzLmxhbmVzKTsgLy8gQ2hlY2sgaWYgdGhlIGNoaWxkcmVuIGhhdmUgYW55IHBlbmRpbmcgd29yay5cblxuICBpZiAoIWluY2x1ZGVzU29tZUxhbmUocmVuZGVyTGFuZXMsIHdvcmtJblByb2dyZXNzLmNoaWxkTGFuZXMpKSB7XG4gICAgLy8gVGhlIGNoaWxkcmVuIGRvbid0IGhhdmUgYW55IHdvcmsgZWl0aGVyLiBXZSBjYW4gc2tpcCB0aGVtLlxuICAgIC8vIFRPRE86IE9uY2Ugd2UgYWRkIGJhY2sgcmVzdW1pbmcsIHdlIHNob3VsZCBjaGVjayBpZiB0aGUgY2hpbGRyZW4gYXJlXG4gICAgLy8gYSB3b3JrLWluLXByb2dyZXNzIHNldC4gSWYgc28sIHdlIG5lZWQgdG8gdHJhbnNmZXIgdGhlaXIgZWZmZWN0cy5cbiAgICByZXR1cm4gbnVsbDtcbiAgfSBlbHNlIHtcbiAgICAvLyBUaGlzIGZpYmVyIGRvZXNuJ3QgaGF2ZSB3b3JrLCBidXQgaXRzIHN1YnRyZWUgZG9lcy4gQ2xvbmUgdGhlIGNoaWxkXG4gICAgLy8gZmliZXJzIGFuZCBjb250aW51ZS5cbiAgICBjbG9uZUNoaWxkRmliZXJzKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKTtcbiAgICByZXR1cm4gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVtb3VudEZpYmVyKGN1cnJlbnQsIG9sZFdvcmtJblByb2dyZXNzLCBuZXdXb3JrSW5Qcm9ncmVzcykge1xuICB7XG4gICAgdmFyIHJldHVybkZpYmVyID0gb2xkV29ya0luUHJvZ3Jlc3MucmV0dXJuO1xuXG4gICAgaWYgKHJldHVybkZpYmVyID09PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBzd2FwIHRoZSByb290IGZpYmVyLicpO1xuICAgIH0gLy8gRGlzY29ubmVjdCBmcm9tIHRoZSBvbGQgY3VycmVudC5cbiAgICAvLyBJdCB3aWxsIGdldCBkZWxldGVkLlxuXG5cbiAgICBjdXJyZW50LmFsdGVybmF0ZSA9IG51bGw7XG4gICAgb2xkV29ya0luUHJvZ3Jlc3MuYWx0ZXJuYXRlID0gbnVsbDsgLy8gQ29ubmVjdCB0byB0aGUgbmV3IHRyZWUuXG5cbiAgICBuZXdXb3JrSW5Qcm9ncmVzcy5pbmRleCA9IG9sZFdvcmtJblByb2dyZXNzLmluZGV4O1xuICAgIG5ld1dvcmtJblByb2dyZXNzLnNpYmxpbmcgPSBvbGRXb3JrSW5Qcm9ncmVzcy5zaWJsaW5nO1xuICAgIG5ld1dvcmtJblByb2dyZXNzLnJldHVybiA9IG9sZFdvcmtJblByb2dyZXNzLnJldHVybjtcbiAgICBuZXdXb3JrSW5Qcm9ncmVzcy5yZWYgPSBvbGRXb3JrSW5Qcm9ncmVzcy5yZWY7IC8vIFJlcGxhY2UgdGhlIGNoaWxkL3NpYmxpbmcgcG9pbnRlcnMgYWJvdmUgaXQuXG5cbiAgICBpZiAob2xkV29ya0luUHJvZ3Jlc3MgPT09IHJldHVybkZpYmVyLmNoaWxkKSB7XG4gICAgICByZXR1cm5GaWJlci5jaGlsZCA9IG5ld1dvcmtJblByb2dyZXNzO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgcHJldlNpYmxpbmcgPSByZXR1cm5GaWJlci5jaGlsZDtcblxuICAgICAgaWYgKHByZXZTaWJsaW5nID09PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgcGFyZW50IHRvIGhhdmUgYSBjaGlsZC4nKTtcbiAgICAgIH1cblxuICAgICAgd2hpbGUgKHByZXZTaWJsaW5nLnNpYmxpbmcgIT09IG9sZFdvcmtJblByb2dyZXNzKSB7XG4gICAgICAgIHByZXZTaWJsaW5nID0gcHJldlNpYmxpbmcuc2libGluZztcblxuICAgICAgICBpZiAocHJldlNpYmxpbmcgPT09IG51bGwpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIHRvIGZpbmQgdGhlIHByZXZpb3VzIHNpYmxpbmcuJyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcHJldlNpYmxpbmcuc2libGluZyA9IG5ld1dvcmtJblByb2dyZXNzO1xuICAgIH0gLy8gRGVsZXRlIHRoZSBvbGQgZmliZXIgYW5kIHBsYWNlIHRoZSBuZXcgb25lLlxuICAgIC8vIFNpbmNlIHRoZSBvbGQgZmliZXIgaXMgZGlzY29ubmVjdGVkLCB3ZSBoYXZlIHRvIHNjaGVkdWxlIGl0IG1hbnVhbGx5LlxuXG5cbiAgICB2YXIgbGFzdCA9IHJldHVybkZpYmVyLmxhc3RFZmZlY3Q7XG5cbiAgICBpZiAobGFzdCAhPT0gbnVsbCkge1xuICAgICAgbGFzdC5uZXh0RWZmZWN0ID0gY3VycmVudDtcbiAgICAgIHJldHVybkZpYmVyLmxhc3RFZmZlY3QgPSBjdXJyZW50O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm5GaWJlci5maXJzdEVmZmVjdCA9IHJldHVybkZpYmVyLmxhc3RFZmZlY3QgPSBjdXJyZW50O1xuICAgIH1cblxuICAgIGN1cnJlbnQubmV4dEVmZmVjdCA9IG51bGw7XG4gICAgY3VycmVudC5mbGFncyA9IERlbGV0aW9uO1xuICAgIG5ld1dvcmtJblByb2dyZXNzLmZsYWdzIHw9IFBsYWNlbWVudDsgLy8gUmVzdGFydCB3b3JrIGZyb20gdGhlIG5ldyBmaWJlci5cblxuICAgIHJldHVybiBuZXdXb3JrSW5Qcm9ncmVzcztcbiAgfVxufVxuXG5mdW5jdGlvbiBiZWdpbldvcmsoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKSB7XG4gIHZhciB1cGRhdGVMYW5lcyA9IHdvcmtJblByb2dyZXNzLmxhbmVzO1xuXG4gIHtcbiAgICBpZiAod29ya0luUHJvZ3Jlc3MuX2RlYnVnTmVlZHNSZW1vdW50ICYmIGN1cnJlbnQgIT09IG51bGwpIHtcbiAgICAgIC8vIFRoaXMgd2lsbCByZXN0YXJ0IHRoZSBiZWdpbiBwaGFzZSB3aXRoIGEgbmV3IGZpYmVyLlxuICAgICAgcmV0dXJuIHJlbW91bnRGaWJlcihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgY3JlYXRlRmliZXJGcm9tVHlwZUFuZFByb3BzKHdvcmtJblByb2dyZXNzLnR5cGUsIHdvcmtJblByb2dyZXNzLmtleSwgd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzLCB3b3JrSW5Qcm9ncmVzcy5fZGVidWdPd25lciB8fCBudWxsLCB3b3JrSW5Qcm9ncmVzcy5tb2RlLCB3b3JrSW5Qcm9ncmVzcy5sYW5lcykpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChjdXJyZW50ICE9PSBudWxsKSB7XG4gICAgdmFyIG9sZFByb3BzID0gY3VycmVudC5tZW1vaXplZFByb3BzO1xuICAgIHZhciBuZXdQcm9wcyA9IHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcztcblxuICAgIGlmIChvbGRQcm9wcyAhPT0gbmV3UHJvcHMgfHwgaGFzQ29udGV4dENoYW5nZWQoKSB8fCAoIC8vIEZvcmNlIGEgcmUtcmVuZGVyIGlmIHRoZSBpbXBsZW1lbnRhdGlvbiBjaGFuZ2VkIGR1ZSB0byBob3QgcmVsb2FkOlxuICAgICB3b3JrSW5Qcm9ncmVzcy50eXBlICE9PSBjdXJyZW50LnR5cGUgKSkge1xuICAgICAgLy8gSWYgcHJvcHMgb3IgY29udGV4dCBjaGFuZ2VkLCBtYXJrIHRoZSBmaWJlciBhcyBoYXZpbmcgcGVyZm9ybWVkIHdvcmsuXG4gICAgICAvLyBUaGlzIG1heSBiZSB1bnNldCBpZiB0aGUgcHJvcHMgYXJlIGRldGVybWluZWQgdG8gYmUgZXF1YWwgbGF0ZXIgKG1lbW8pLlxuICAgICAgZGlkUmVjZWl2ZVVwZGF0ZSA9IHRydWU7XG4gICAgfSBlbHNlIGlmICghaW5jbHVkZXNTb21lTGFuZShyZW5kZXJMYW5lcywgdXBkYXRlTGFuZXMpKSB7XG4gICAgICBkaWRSZWNlaXZlVXBkYXRlID0gZmFsc2U7IC8vIFRoaXMgZmliZXIgZG9lcyBub3QgaGF2ZSBhbnkgcGVuZGluZyB3b3JrLiBCYWlsb3V0IHdpdGhvdXQgZW50ZXJpbmdcbiAgICAgIC8vIHRoZSBiZWdpbiBwaGFzZS4gVGhlcmUncyBzdGlsbCBzb21lIGJvb2trZWVwaW5nIHdlIHRoYXQgbmVlZHMgdG8gYmUgZG9uZVxuICAgICAgLy8gaW4gdGhpcyBvcHRpbWl6ZWQgcGF0aCwgbW9zdGx5IHB1c2hpbmcgc3R1ZmYgb250byB0aGUgc3RhY2suXG5cbiAgICAgIHN3aXRjaCAod29ya0luUHJvZ3Jlc3MudGFnKSB7XG4gICAgICAgIGNhc2UgSG9zdFJvb3Q6XG4gICAgICAgICAgcHVzaEhvc3RSb290Q29udGV4dCh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgcmVzZXRIeWRyYXRpb25TdGF0ZSgpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICAgICAgICBwdXNoSG9zdENvbnRleHQod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgQ2xhc3NDb21wb25lbnQ6XG4gICAgICAgICAge1xuICAgICAgICAgICAgdmFyIENvbXBvbmVudCA9IHdvcmtJblByb2dyZXNzLnR5cGU7XG5cbiAgICAgICAgICAgIGlmIChpc0NvbnRleHRQcm92aWRlcihDb21wb25lbnQpKSB7XG4gICAgICAgICAgICAgIHB1c2hDb250ZXh0UHJvdmlkZXIod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgY2FzZSBIb3N0UG9ydGFsOlxuICAgICAgICAgIHB1c2hIb3N0Q29udGFpbmVyKHdvcmtJblByb2dyZXNzLCB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUuY29udGFpbmVySW5mbyk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBDb250ZXh0UHJvdmlkZXI6XG4gICAgICAgICAge1xuICAgICAgICAgICAgdmFyIG5ld1ZhbHVlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcy52YWx1ZTtcbiAgICAgICAgICAgIHB1c2hQcm92aWRlcih3b3JrSW5Qcm9ncmVzcywgbmV3VmFsdWUpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgUHJvZmlsZXI6XG4gICAgICAgICAge1xuICAgICAgICAgICAgLy8gUHJvZmlsZXIgc2hvdWxkIG9ubHkgY2FsbCBvblJlbmRlciB3aGVuIG9uZSBvZiBpdHMgZGVzY2VuZGFudHMgYWN0dWFsbHkgcmVuZGVyZWQuXG4gICAgICAgICAgICB2YXIgaGFzQ2hpbGRXb3JrID0gaW5jbHVkZXNTb21lTGFuZShyZW5kZXJMYW5lcywgd29ya0luUHJvZ3Jlc3MuY2hpbGRMYW5lcyk7XG5cbiAgICAgICAgICAgIGlmIChoYXNDaGlsZFdvcmspIHtcbiAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gVXBkYXRlO1xuICAgICAgICAgICAgfSAvLyBSZXNldCBlZmZlY3QgZHVyYXRpb25zIGZvciB0aGUgbmV4dCBldmVudHVhbCBlZmZlY3QgcGhhc2UuXG4gICAgICAgICAgICAvLyBUaGVzZSBhcmUgcmVzZXQgZHVyaW5nIHJlbmRlciB0byBhbGxvdyB0aGUgRGV2VG9vbHMgY29tbWl0IGhvb2sgYSBjaGFuY2UgdG8gcmVhZCB0aGVtLFxuXG5cbiAgICAgICAgICAgIHZhciBzdGF0ZU5vZGUgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG4gICAgICAgICAgICBzdGF0ZU5vZGUuZWZmZWN0RHVyYXRpb24gPSAwO1xuICAgICAgICAgICAgc3RhdGVOb2RlLnBhc3NpdmVFZmZlY3REdXJhdGlvbiA9IDA7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBTdXNwZW5zZUNvbXBvbmVudDpcbiAgICAgICAgICB7XG4gICAgICAgICAgICB2YXIgc3RhdGUgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO1xuXG4gICAgICAgICAgICBpZiAoc3RhdGUgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgLy8gd2hldGhlciB0byByZXRyeSB0aGUgcHJpbWFyeSBjaGlsZHJlbiwgb3IgdG8gc2tpcCBvdmVyIGl0IGFuZFxuICAgICAgICAgICAgICAvLyBnbyBzdHJhaWdodCB0byB0aGUgZmFsbGJhY2suIENoZWNrIHRoZSBwcmlvcml0eSBvZiB0aGUgcHJpbWFyeVxuICAgICAgICAgICAgICAvLyBjaGlsZCBmcmFnbWVudC5cblxuXG4gICAgICAgICAgICAgIHZhciBwcmltYXJ5Q2hpbGRGcmFnbWVudCA9IHdvcmtJblByb2dyZXNzLmNoaWxkO1xuICAgICAgICAgICAgICB2YXIgcHJpbWFyeUNoaWxkTGFuZXMgPSBwcmltYXJ5Q2hpbGRGcmFnbWVudC5jaGlsZExhbmVzO1xuXG4gICAgICAgICAgICAgIGlmIChpbmNsdWRlc1NvbWVMYW5lKHJlbmRlckxhbmVzLCBwcmltYXJ5Q2hpbGRMYW5lcykpIHtcbiAgICAgICAgICAgICAgICAvLyBUaGUgcHJpbWFyeSBjaGlsZHJlbiBoYXZlIHBlbmRpbmcgd29yay4gVXNlIHRoZSBub3JtYWwgcGF0aFxuICAgICAgICAgICAgICAgIC8vIHRvIGF0dGVtcHQgdG8gcmVuZGVyIHRoZSBwcmltYXJ5IGNoaWxkcmVuIGFnYWluLlxuICAgICAgICAgICAgICAgIHJldHVybiB1cGRhdGVTdXNwZW5zZUNvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIFRoZSBwcmltYXJ5IGNoaWxkIGZyYWdtZW50IGRvZXMgbm90IGhhdmUgcGVuZGluZyB3b3JrIG1hcmtlZFxuICAgICAgICAgICAgICAgIC8vIG9uIGl0XG4gICAgICAgICAgICAgICAgcHVzaFN1c3BlbnNlQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgc2V0RGVmYXVsdFNoYWxsb3dTdXNwZW5zZUNvbnRleHQoc3VzcGVuc2VTdGFja0N1cnNvci5jdXJyZW50KSk7IC8vIFRoZSBwcmltYXJ5IGNoaWxkcmVuIGRvIG5vdCBoYXZlIHBlbmRpbmcgd29yayB3aXRoIHN1ZmZpY2llbnRcbiAgICAgICAgICAgICAgICAvLyBwcmlvcml0eS4gQmFpbG91dC5cblxuICAgICAgICAgICAgICAgIHZhciBjaGlsZCA9IGJhaWxvdXRPbkFscmVhZHlGaW5pc2hlZFdvcmsoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKTtcblxuICAgICAgICAgICAgICAgIGlmIChjaGlsZCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgLy8gVGhlIGZhbGxiYWNrIGNoaWxkcmVuIGhhdmUgcGVuZGluZyB3b3JrLiBTa2lwIG92ZXIgdGhlXG4gICAgICAgICAgICAgICAgICAvLyBwcmltYXJ5IGNoaWxkcmVuIGFuZCB3b3JrIG9uIHRoZSBmYWxsYmFjay5cbiAgICAgICAgICAgICAgICAgIHJldHVybiBjaGlsZC5zaWJsaW5nO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHB1c2hTdXNwZW5zZUNvbnRleHQod29ya0luUHJvZ3Jlc3MsIHNldERlZmF1bHRTaGFsbG93U3VzcGVuc2VDb250ZXh0KHN1c3BlbnNlU3RhY2tDdXJzb3IuY3VycmVudCkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgY2FzZSBTdXNwZW5zZUxpc3RDb21wb25lbnQ6XG4gICAgICAgICAge1xuICAgICAgICAgICAgdmFyIGRpZFN1c3BlbmRCZWZvcmUgPSAoY3VycmVudC5mbGFncyAmIERpZENhcHR1cmUpICE9PSBOb0ZsYWdzO1xuXG4gICAgICAgICAgICB2YXIgX2hhc0NoaWxkV29yayA9IGluY2x1ZGVzU29tZUxhbmUocmVuZGVyTGFuZXMsIHdvcmtJblByb2dyZXNzLmNoaWxkTGFuZXMpO1xuXG4gICAgICAgICAgICBpZiAoZGlkU3VzcGVuZEJlZm9yZSkge1xuICAgICAgICAgICAgICBpZiAoX2hhc0NoaWxkV29yaykge1xuICAgICAgICAgICAgICAgIC8vIElmIHNvbWV0aGluZyB3YXMgaW4gZmFsbGJhY2sgc3RhdGUgbGFzdCB0aW1lLCBhbmQgd2UgaGF2ZSBhbGwgdGhlXG4gICAgICAgICAgICAgICAgLy8gc2FtZSBjaGlsZHJlbiB0aGVuIHdlJ3JlIHN0aWxsIGluIHByb2dyZXNzaXZlIGxvYWRpbmcgc3RhdGUuXG4gICAgICAgICAgICAgICAgLy8gU29tZXRoaW5nIG1pZ2h0IGdldCB1bmJsb2NrZWQgYnkgc3RhdGUgdXBkYXRlcyBvciByZXRyaWVzIGluIHRoZVxuICAgICAgICAgICAgICAgIC8vIHRyZWUgd2hpY2ggd2lsbCBhZmZlY3QgdGhlIHRhaWwuIFNvIHdlIG5lZWQgdG8gdXNlIHRoZSBub3JtYWxcbiAgICAgICAgICAgICAgICAvLyBwYXRoIHRvIGNvbXB1dGUgdGhlIGNvcnJlY3QgdGFpbC5cbiAgICAgICAgICAgICAgICByZXR1cm4gdXBkYXRlU3VzcGVuc2VMaXN0Q29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcyk7XG4gICAgICAgICAgICAgIH0gLy8gSWYgbm9uZSBvZiB0aGUgY2hpbGRyZW4gaGFkIGFueSB3b3JrLCB0aGF0IG1lYW5zIHRoYXQgbm9uZSBvZlxuICAgICAgICAgICAgICAvLyB0aGVtIGdvdCByZXRyaWVkIHNvIHRoZXknbGwgc3RpbGwgYmUgYmxvY2tlZCBpbiB0aGUgc2FtZSB3YXlcbiAgICAgICAgICAgICAgLy8gYXMgYmVmb3JlLiBXZSBjYW4gZmFzdCBiYWlsIG91dC5cblxuXG4gICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IERpZENhcHR1cmU7XG4gICAgICAgICAgICB9IC8vIElmIG5vdGhpbmcgc3VzcGVuZGVkIGJlZm9yZSBhbmQgd2UncmUgcmVuZGVyaW5nIHRoZSBzYW1lIGNoaWxkcmVuLFxuICAgICAgICAgICAgLy8gdGhlbiB0aGUgdGFpbCBkb2Vzbid0IG1hdHRlci4gQW55dGhpbmcgbmV3IHRoYXQgc3VzcGVuZHMgd2lsbCB3b3JrXG4gICAgICAgICAgICAvLyBpbiB0aGUgXCJ0b2dldGhlclwiIG1vZGUsIHNvIHdlIGNhbiBjb250aW51ZSBmcm9tIHRoZSBzdGF0ZSB3ZSBoYWQuXG5cblxuICAgICAgICAgICAgdmFyIHJlbmRlclN0YXRlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTtcblxuICAgICAgICAgICAgaWYgKHJlbmRlclN0YXRlICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgIC8vIFJlc2V0IHRvIHRoZSBcInRvZ2V0aGVyXCIgbW9kZSBpbiBjYXNlIHdlJ3ZlIHN0YXJ0ZWQgYSBkaWZmZXJlbnRcbiAgICAgICAgICAgICAgLy8gdXBkYXRlIGluIHRoZSBwYXN0IGJ1dCBkaWRuJ3QgY29tcGxldGUgaXQuXG4gICAgICAgICAgICAgIHJlbmRlclN0YXRlLnJlbmRlcmluZyA9IG51bGw7XG4gICAgICAgICAgICAgIHJlbmRlclN0YXRlLnRhaWwgPSBudWxsO1xuICAgICAgICAgICAgICByZW5kZXJTdGF0ZS5sYXN0RWZmZWN0ID0gbnVsbDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcHVzaFN1c3BlbnNlQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgc3VzcGVuc2VTdGFja0N1cnNvci5jdXJyZW50KTtcblxuICAgICAgICAgICAgaWYgKF9oYXNDaGlsZFdvcmspIHtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyBJZiBub25lIG9mIHRoZSBjaGlsZHJlbiBoYWQgYW55IHdvcmssIHRoYXQgbWVhbnMgdGhhdCBub25lIG9mXG4gICAgICAgICAgICAgIC8vIHRoZW0gZ290IHJldHJpZWQgc28gdGhleSdsbCBzdGlsbCBiZSBibG9ja2VkIGluIHRoZSBzYW1lIHdheVxuICAgICAgICAgICAgICAvLyBhcyBiZWZvcmUuIFdlIGNhbiBmYXN0IGJhaWwgb3V0LlxuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgY2FzZSBPZmZzY3JlZW5Db21wb25lbnQ6XG4gICAgICAgIGNhc2UgTGVnYWN5SGlkZGVuQ29tcG9uZW50OlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIC8vIE5lZWQgdG8gY2hlY2sgaWYgdGhlIHRyZWUgc3RpbGwgbmVlZHMgdG8gYmUgZGVmZXJyZWQuIFRoaXMgaXNcbiAgICAgICAgICAgIC8vIGFsbW9zdCBpZGVudGljYWwgdG8gdGhlIGxvZ2ljIHVzZWQgaW4gdGhlIG5vcm1hbCB1cGRhdGUgcGF0aCxcbiAgICAgICAgICAgIC8vIHNvIHdlJ2xsIGp1c3QgZW50ZXIgdGhhdC4gVGhlIG9ubHkgZGlmZmVyZW5jZSBpcyB3ZSdsbCBiYWlsIG91dFxuICAgICAgICAgICAgLy8gYXQgdGhlIG5leHQgbGV2ZWwgaW5zdGVhZCBvZiB0aGlzIG9uZSwgYmVjYXVzZSB0aGUgY2hpbGQgcHJvcHNcbiAgICAgICAgICAgIC8vIGhhdmUgbm90IGNoYW5nZWQuIFdoaWNoIGlzIGZpbmUuXG4gICAgICAgICAgICAvLyBUT0RPOiBQcm9iYWJseSBzaG91bGQgcmVmYWN0b3IgYGJlZ2luV29ya2AgdG8gc3BsaXQgdGhlIGJhaWxvdXRcbiAgICAgICAgICAgIC8vIHBhdGggZnJvbSB0aGUgbm9ybWFsIHBhdGguIEknbSB0ZW1wdGVkIHRvIGRvIGEgbGFiZWxlZCBicmVhayBoZXJlXG4gICAgICAgICAgICAvLyBidXQgSSB3b24ndCA6KVxuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MubGFuZXMgPSBOb0xhbmVzO1xuICAgICAgICAgICAgcmV0dXJuIHVwZGF0ZU9mZnNjcmVlbkNvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpO1xuICAgICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGJhaWxvdXRPbkFscmVhZHlGaW5pc2hlZFdvcmsoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKChjdXJyZW50LmZsYWdzICYgRm9yY2VVcGRhdGVGb3JMZWdhY3lTdXNwZW5zZSkgIT09IE5vRmxhZ3MpIHtcbiAgICAgICAgLy8gVGhpcyBpcyBhIHNwZWNpYWwgY2FzZSB0aGF0IG9ubHkgZXhpc3RzIGZvciBsZWdhY3kgbW9kZS5cbiAgICAgICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9wdWxsLzE5MjE2LlxuICAgICAgICBkaWRSZWNlaXZlVXBkYXRlID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEFuIHVwZGF0ZSB3YXMgc2NoZWR1bGVkIG9uIHRoaXMgZmliZXIsIGJ1dCB0aGVyZSBhcmUgbm8gbmV3IHByb3BzXG4gICAgICAgIC8vIG5vciBsZWdhY3kgY29udGV4dC4gU2V0IHRoaXMgdG8gZmFsc2UuIElmIGFuIHVwZGF0ZSBxdWV1ZSBvciBjb250ZXh0XG4gICAgICAgIC8vIGNvbnN1bWVyIHByb2R1Y2VzIGEgY2hhbmdlZCB2YWx1ZSwgaXQgd2lsbCBzZXQgdGhpcyB0byB0cnVlLiBPdGhlcndpc2UsXG4gICAgICAgIC8vIHRoZSBjb21wb25lbnQgd2lsbCBhc3N1bWUgdGhlIGNoaWxkcmVuIGhhdmUgbm90IGNoYW5nZWQgYW5kIGJhaWwgb3V0LlxuICAgICAgICBkaWRSZWNlaXZlVXBkYXRlID0gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGRpZFJlY2VpdmVVcGRhdGUgPSBmYWxzZTtcbiAgfSAvLyBCZWZvcmUgZW50ZXJpbmcgdGhlIGJlZ2luIHBoYXNlLCBjbGVhciBwZW5kaW5nIHVwZGF0ZSBwcmlvcml0eS5cbiAgLy8gVE9ETzogVGhpcyBhc3N1bWVzIHRoYXQgd2UncmUgYWJvdXQgdG8gZXZhbHVhdGUgdGhlIGNvbXBvbmVudCBhbmQgcHJvY2Vzc1xuICAvLyB0aGUgdXBkYXRlIHF1ZXVlLiBIb3dldmVyLCB0aGVyZSdzIGFuIGV4Y2VwdGlvbjogU2ltcGxlTWVtb0NvbXBvbmVudFxuICAvLyBzb21ldGltZXMgYmFpbHMgb3V0IGxhdGVyIGluIHRoZSBiZWdpbiBwaGFzZS4gVGhpcyBpbmRpY2F0ZXMgdGhhdCB3ZSBzaG91bGRcbiAgLy8gbW92ZSB0aGlzIGFzc2lnbm1lbnQgb3V0IG9mIHRoZSBjb21tb24gcGF0aCBhbmQgaW50byBlYWNoIGJyYW5jaC5cblxuXG4gIHdvcmtJblByb2dyZXNzLmxhbmVzID0gTm9MYW5lcztcblxuICBzd2l0Y2ggKHdvcmtJblByb2dyZXNzLnRhZykge1xuICAgIGNhc2UgSW5kZXRlcm1pbmF0ZUNvbXBvbmVudDpcbiAgICAgIHtcbiAgICAgICAgcmV0dXJuIG1vdW50SW5kZXRlcm1pbmF0ZUNvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgd29ya0luUHJvZ3Jlc3MudHlwZSwgcmVuZGVyTGFuZXMpO1xuICAgICAgfVxuXG4gICAgY2FzZSBMYXp5Q29tcG9uZW50OlxuICAgICAge1xuICAgICAgICB2YXIgZWxlbWVudFR5cGUgPSB3b3JrSW5Qcm9ncmVzcy5lbGVtZW50VHlwZTtcbiAgICAgICAgcmV0dXJuIG1vdW50TGF6eUNvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgZWxlbWVudFR5cGUsIHVwZGF0ZUxhbmVzLCByZW5kZXJMYW5lcyk7XG4gICAgICB9XG5cbiAgICBjYXNlIEZ1bmN0aW9uQ29tcG9uZW50OlxuICAgICAge1xuICAgICAgICB2YXIgX0NvbXBvbmVudCA9IHdvcmtJblByb2dyZXNzLnR5cGU7XG4gICAgICAgIHZhciB1bnJlc29sdmVkUHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHM7XG4gICAgICAgIHZhciByZXNvbHZlZFByb3BzID0gd29ya0luUHJvZ3Jlc3MuZWxlbWVudFR5cGUgPT09IF9Db21wb25lbnQgPyB1bnJlc29sdmVkUHJvcHMgOiByZXNvbHZlRGVmYXVsdFByb3BzKF9Db21wb25lbnQsIHVucmVzb2x2ZWRQcm9wcyk7XG4gICAgICAgIHJldHVybiB1cGRhdGVGdW5jdGlvbkNvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgX0NvbXBvbmVudCwgcmVzb2x2ZWRQcm9wcywgcmVuZGVyTGFuZXMpO1xuICAgICAgfVxuXG4gICAgY2FzZSBDbGFzc0NvbXBvbmVudDpcbiAgICAgIHtcbiAgICAgICAgdmFyIF9Db21wb25lbnQyID0gd29ya0luUHJvZ3Jlc3MudHlwZTtcbiAgICAgICAgdmFyIF91bnJlc29sdmVkUHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHM7XG5cbiAgICAgICAgdmFyIF9yZXNvbHZlZFByb3BzID0gd29ya0luUHJvZ3Jlc3MuZWxlbWVudFR5cGUgPT09IF9Db21wb25lbnQyID8gX3VucmVzb2x2ZWRQcm9wcyA6IHJlc29sdmVEZWZhdWx0UHJvcHMoX0NvbXBvbmVudDIsIF91bnJlc29sdmVkUHJvcHMpO1xuXG4gICAgICAgIHJldHVybiB1cGRhdGVDbGFzc0NvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgX0NvbXBvbmVudDIsIF9yZXNvbHZlZFByb3BzLCByZW5kZXJMYW5lcyk7XG4gICAgICB9XG5cbiAgICBjYXNlIEhvc3RSb290OlxuICAgICAgcmV0dXJuIHVwZGF0ZUhvc3RSb290KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcyk7XG5cbiAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICByZXR1cm4gdXBkYXRlSG9zdENvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpO1xuXG4gICAgY2FzZSBIb3N0VGV4dDpcbiAgICAgIHJldHVybiB1cGRhdGVIb3N0VGV4dChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcyk7XG5cbiAgICBjYXNlIFN1c3BlbnNlQ29tcG9uZW50OlxuICAgICAgcmV0dXJuIHVwZGF0ZVN1c3BlbnNlQ29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcyk7XG5cbiAgICBjYXNlIEhvc3RQb3J0YWw6XG4gICAgICByZXR1cm4gdXBkYXRlUG9ydGFsQ29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcyk7XG5cbiAgICBjYXNlIEZvcndhcmRSZWY6XG4gICAgICB7XG4gICAgICAgIHZhciB0eXBlID0gd29ya0luUHJvZ3Jlc3MudHlwZTtcbiAgICAgICAgdmFyIF91bnJlc29sdmVkUHJvcHMyID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzO1xuXG4gICAgICAgIHZhciBfcmVzb2x2ZWRQcm9wczIgPSB3b3JrSW5Qcm9ncmVzcy5lbGVtZW50VHlwZSA9PT0gdHlwZSA/IF91bnJlc29sdmVkUHJvcHMyIDogcmVzb2x2ZURlZmF1bHRQcm9wcyh0eXBlLCBfdW5yZXNvbHZlZFByb3BzMik7XG5cbiAgICAgICAgcmV0dXJuIHVwZGF0ZUZvcndhcmRSZWYoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHR5cGUsIF9yZXNvbHZlZFByb3BzMiwgcmVuZGVyTGFuZXMpO1xuICAgICAgfVxuXG4gICAgY2FzZSBGcmFnbWVudDpcbiAgICAgIHJldHVybiB1cGRhdGVGcmFnbWVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpO1xuXG4gICAgY2FzZSBNb2RlOlxuICAgICAgcmV0dXJuIHVwZGF0ZU1vZGUoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKTtcblxuICAgIGNhc2UgUHJvZmlsZXI6XG4gICAgICByZXR1cm4gdXBkYXRlUHJvZmlsZXIoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKTtcblxuICAgIGNhc2UgQ29udGV4dFByb3ZpZGVyOlxuICAgICAgcmV0dXJuIHVwZGF0ZUNvbnRleHRQcm92aWRlcihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpO1xuXG4gICAgY2FzZSBDb250ZXh0Q29uc3VtZXI6XG4gICAgICByZXR1cm4gdXBkYXRlQ29udGV4dENvbnN1bWVyKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcyk7XG5cbiAgICBjYXNlIE1lbW9Db21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIHZhciBfdHlwZTIgPSB3b3JrSW5Qcm9ncmVzcy50eXBlO1xuICAgICAgICB2YXIgX3VucmVzb2x2ZWRQcm9wczMgPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHM7IC8vIFJlc29sdmUgb3V0ZXIgcHJvcHMgZmlyc3QsIHRoZW4gcmVzb2x2ZSBpbm5lciBwcm9wcy5cblxuICAgICAgICB2YXIgX3Jlc29sdmVkUHJvcHMzID0gcmVzb2x2ZURlZmF1bHRQcm9wcyhfdHlwZTIsIF91bnJlc29sdmVkUHJvcHMzKTtcblxuICAgICAgICB7XG4gICAgICAgICAgaWYgKHdvcmtJblByb2dyZXNzLnR5cGUgIT09IHdvcmtJblByb2dyZXNzLmVsZW1lbnRUeXBlKSB7XG4gICAgICAgICAgICB2YXIgb3V0ZXJQcm9wVHlwZXMgPSBfdHlwZTIucHJvcFR5cGVzO1xuXG4gICAgICAgICAgICBpZiAob3V0ZXJQcm9wVHlwZXMpIHtcbiAgICAgICAgICAgICAgY2hlY2tQcm9wVHlwZXMob3V0ZXJQcm9wVHlwZXMsIF9yZXNvbHZlZFByb3BzMywgLy8gUmVzb2x2ZWQgZm9yIG91dGVyIG9ubHlcbiAgICAgICAgICAgICAgJ3Byb3AnLCBnZXRDb21wb25lbnROYW1lKF90eXBlMikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIF9yZXNvbHZlZFByb3BzMyA9IHJlc29sdmVEZWZhdWx0UHJvcHMoX3R5cGUyLnR5cGUsIF9yZXNvbHZlZFByb3BzMyk7XG4gICAgICAgIHJldHVybiB1cGRhdGVNZW1vQ29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBfdHlwZTIsIF9yZXNvbHZlZFByb3BzMywgdXBkYXRlTGFuZXMsIHJlbmRlckxhbmVzKTtcbiAgICAgIH1cblxuICAgIGNhc2UgU2ltcGxlTWVtb0NvbXBvbmVudDpcbiAgICAgIHtcbiAgICAgICAgcmV0dXJuIHVwZGF0ZVNpbXBsZU1lbW9Db21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHdvcmtJblByb2dyZXNzLnR5cGUsIHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcywgdXBkYXRlTGFuZXMsIHJlbmRlckxhbmVzKTtcbiAgICAgIH1cblxuICAgIGNhc2UgSW5jb21wbGV0ZUNsYXNzQ29tcG9uZW50OlxuICAgICAge1xuICAgICAgICB2YXIgX0NvbXBvbmVudDMgPSB3b3JrSW5Qcm9ncmVzcy50eXBlO1xuICAgICAgICB2YXIgX3VucmVzb2x2ZWRQcm9wczQgPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHM7XG5cbiAgICAgICAgdmFyIF9yZXNvbHZlZFByb3BzNCA9IHdvcmtJblByb2dyZXNzLmVsZW1lbnRUeXBlID09PSBfQ29tcG9uZW50MyA/IF91bnJlc29sdmVkUHJvcHM0IDogcmVzb2x2ZURlZmF1bHRQcm9wcyhfQ29tcG9uZW50MywgX3VucmVzb2x2ZWRQcm9wczQpO1xuXG4gICAgICAgIHJldHVybiBtb3VudEluY29tcGxldGVDbGFzc0NvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgX0NvbXBvbmVudDMsIF9yZXNvbHZlZFByb3BzNCwgcmVuZGVyTGFuZXMpO1xuICAgICAgfVxuXG4gICAgY2FzZSBTdXNwZW5zZUxpc3RDb21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIHJldHVybiB1cGRhdGVTdXNwZW5zZUxpc3RDb21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKTtcbiAgICAgIH1cblxuICAgIGNhc2UgRnVuZGFtZW50YWxDb21wb25lbnQ6XG4gICAgICB7XG5cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICBjYXNlIFNjb3BlQ29tcG9uZW50OlxuICAgICAge1xuXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgY2FzZSBCbG9jazpcbiAgICAgIHtcblxuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgIGNhc2UgT2Zmc2NyZWVuQ29tcG9uZW50OlxuICAgICAge1xuICAgICAgICByZXR1cm4gdXBkYXRlT2Zmc2NyZWVuQ29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcyk7XG4gICAgICB9XG5cbiAgICBjYXNlIExlZ2FjeUhpZGRlbkNvbXBvbmVudDpcbiAgICAgIHtcbiAgICAgICAgcmV0dXJuIHVwZGF0ZUxlZ2FjeUhpZGRlbkNvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpO1xuICAgICAgfVxuICB9XG5cbiAge1xuICAgIHtcbiAgICAgIHRocm93IEVycm9yKCBcIlVua25vd24gdW5pdCBvZiB3b3JrIHRhZyAoXCIgKyB3b3JrSW5Qcm9ncmVzcy50YWcgKyBcIikuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCIgKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gbWFya1VwZGF0ZSh3b3JrSW5Qcm9ncmVzcykge1xuICAvLyBUYWcgdGhlIGZpYmVyIHdpdGggYW4gdXBkYXRlIGVmZmVjdC4gVGhpcyB0dXJucyBhIFBsYWNlbWVudCBpbnRvXG4gIC8vIGEgUGxhY2VtZW50QW5kVXBkYXRlLlxuICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSBVcGRhdGU7XG59XG5cbmZ1bmN0aW9uIG1hcmtSZWYkMSh3b3JrSW5Qcm9ncmVzcykge1xuICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSBSZWY7XG59XG5cbnZhciBhcHBlbmRBbGxDaGlsZHJlbjtcbnZhciB1cGRhdGVIb3N0Q29udGFpbmVyO1xudmFyIHVwZGF0ZUhvc3RDb21wb25lbnQkMTtcbnZhciB1cGRhdGVIb3N0VGV4dCQxO1xuXG57XG4gIC8vIE11dGF0aW9uIG1vZGVcbiAgYXBwZW5kQWxsQ2hpbGRyZW4gPSBmdW5jdGlvbiAocGFyZW50LCB3b3JrSW5Qcm9ncmVzcywgbmVlZHNWaXNpYmlsaXR5VG9nZ2xlLCBpc0hpZGRlbikge1xuICAgIC8vIFdlIG9ubHkgaGF2ZSB0aGUgdG9wIEZpYmVyIHRoYXQgd2FzIGNyZWF0ZWQgYnV0IHdlIG5lZWQgcmVjdXJzZSBkb3duIGl0c1xuICAgIC8vIGNoaWxkcmVuIHRvIGZpbmQgYWxsIHRoZSB0ZXJtaW5hbCBub2Rlcy5cbiAgICB2YXIgbm9kZSA9IHdvcmtJblByb2dyZXNzLmNoaWxkO1xuXG4gICAgd2hpbGUgKG5vZGUgIT09IG51bGwpIHtcbiAgICAgIGlmIChub2RlLnRhZyA9PT0gSG9zdENvbXBvbmVudCB8fCBub2RlLnRhZyA9PT0gSG9zdFRleHQpIHtcbiAgICAgICAgYXBwZW5kSW5pdGlhbENoaWxkKHBhcmVudCwgbm9kZS5zdGF0ZU5vZGUpO1xuICAgICAgfSBlbHNlIGlmIChub2RlLnRhZyA9PT0gSG9zdFBvcnRhbCkgOyBlbHNlIGlmIChub2RlLmNoaWxkICE9PSBudWxsKSB7XG4gICAgICAgIG5vZGUuY2hpbGQucmV0dXJuID0gbm9kZTtcbiAgICAgICAgbm9kZSA9IG5vZGUuY2hpbGQ7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAobm9kZSA9PT0gd29ya0luUHJvZ3Jlc3MpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB3aGlsZSAobm9kZS5zaWJsaW5nID09PSBudWxsKSB7XG4gICAgICAgIGlmIChub2RlLnJldHVybiA9PT0gbnVsbCB8fCBub2RlLnJldHVybiA9PT0gd29ya0luUHJvZ3Jlc3MpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBub2RlID0gbm9kZS5yZXR1cm47XG4gICAgICB9XG5cbiAgICAgIG5vZGUuc2libGluZy5yZXR1cm4gPSBub2RlLnJldHVybjtcbiAgICAgIG5vZGUgPSBub2RlLnNpYmxpbmc7XG4gICAgfVxuICB9O1xuXG4gIHVwZGF0ZUhvc3RDb250YWluZXIgPSBmdW5jdGlvbiAod29ya0luUHJvZ3Jlc3MpIHsvLyBOb29wXG4gIH07XG5cbiAgdXBkYXRlSG9zdENvbXBvbmVudCQxID0gZnVuY3Rpb24gKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCB0eXBlLCBuZXdQcm9wcywgcm9vdENvbnRhaW5lckluc3RhbmNlKSB7XG4gICAgLy8gSWYgd2UgaGF2ZSBhbiBhbHRlcm5hdGUsIHRoYXQgbWVhbnMgdGhpcyBpcyBhbiB1cGRhdGUgYW5kIHdlIG5lZWQgdG9cbiAgICAvLyBzY2hlZHVsZSBhIHNpZGUtZWZmZWN0IHRvIGRvIHRoZSB1cGRhdGVzLlxuICAgIHZhciBvbGRQcm9wcyA9IGN1cnJlbnQubWVtb2l6ZWRQcm9wcztcblxuICAgIGlmIChvbGRQcm9wcyA9PT0gbmV3UHJvcHMpIHtcbiAgICAgIC8vIEluIG11dGF0aW9uIG1vZGUsIHRoaXMgaXMgc3VmZmljaWVudCBmb3IgYSBiYWlsb3V0IGJlY2F1c2VcbiAgICAgIC8vIHdlIHdvbid0IHRvdWNoIHRoaXMgbm9kZSBldmVuIGlmIGNoaWxkcmVuIGNoYW5nZWQuXG4gICAgICByZXR1cm47XG4gICAgfSAvLyBJZiB3ZSBnZXQgdXBkYXRlZCBiZWNhdXNlIG9uZSBvZiBvdXIgY2hpbGRyZW4gdXBkYXRlZCwgd2UgZG9uJ3RcbiAgICAvLyBoYXZlIG5ld1Byb3BzIHNvIHdlJ2xsIGhhdmUgdG8gcmV1c2UgdGhlbS5cbiAgICAvLyBUT0RPOiBTcGxpdCB0aGUgdXBkYXRlIEFQSSBhcyBzZXBhcmF0ZSBmb3IgdGhlIHByb3BzIHZzLiBjaGlsZHJlbi5cbiAgICAvLyBFdmVuIGJldHRlciB3b3VsZCBiZSBpZiBjaGlsZHJlbiB3ZXJlbid0IHNwZWNpYWwgY2FzZWQgYXQgYWxsIHRoby5cblxuXG4gICAgdmFyIGluc3RhbmNlID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuICAgIHZhciBjdXJyZW50SG9zdENvbnRleHQgPSBnZXRIb3N0Q29udGV4dCgpOyAvLyBUT0RPOiBFeHBlcmllbmNpbmcgYW4gZXJyb3Igd2hlcmUgb2xkUHJvcHMgaXMgbnVsbC4gU3VnZ2VzdHMgYSBob3N0XG4gICAgLy8gY29tcG9uZW50IGlzIGhpdHRpbmcgdGhlIHJlc3VtZSBwYXRoLiBGaWd1cmUgb3V0IHdoeS4gUG9zc2libHlcbiAgICAvLyByZWxhdGVkIHRvIGBoaWRkZW5gLlxuXG4gICAgdmFyIHVwZGF0ZVBheWxvYWQgPSBwcmVwYXJlVXBkYXRlKGluc3RhbmNlLCB0eXBlLCBvbGRQcm9wcywgbmV3UHJvcHMsIHJvb3RDb250YWluZXJJbnN0YW5jZSwgY3VycmVudEhvc3RDb250ZXh0KTsgLy8gVE9ETzogVHlwZSB0aGlzIHNwZWNpZmljIHRvIHRoaXMgdHlwZSBvZiBjb21wb25lbnQuXG5cbiAgICB3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZSA9IHVwZGF0ZVBheWxvYWQ7IC8vIElmIHRoZSB1cGRhdGUgcGF5bG9hZCBpbmRpY2F0ZXMgdGhhdCB0aGVyZSBpcyBhIGNoYW5nZSBvciBpZiB0aGVyZVxuICAgIC8vIGlzIGEgbmV3IHJlZiB3ZSBtYXJrIHRoaXMgYXMgYW4gdXBkYXRlLiBBbGwgdGhlIHdvcmsgaXMgZG9uZSBpbiBjb21taXRXb3JrLlxuXG4gICAgaWYgKHVwZGF0ZVBheWxvYWQpIHtcbiAgICAgIG1hcmtVcGRhdGUod29ya0luUHJvZ3Jlc3MpO1xuICAgIH1cbiAgfTtcblxuICB1cGRhdGVIb3N0VGV4dCQxID0gZnVuY3Rpb24gKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBvbGRUZXh0LCBuZXdUZXh0KSB7XG4gICAgLy8gSWYgdGhlIHRleHQgZGlmZmVycywgbWFyayBpdCBhcyBhbiB1cGRhdGUuIEFsbCB0aGUgd29yayBpbiBkb25lIGluIGNvbW1pdFdvcmsuXG4gICAgaWYgKG9sZFRleHQgIT09IG5ld1RleHQpIHtcbiAgICAgIG1hcmtVcGRhdGUod29ya0luUHJvZ3Jlc3MpO1xuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gY3V0T2ZmVGFpbElmTmVlZGVkKHJlbmRlclN0YXRlLCBoYXNSZW5kZXJlZEFUYWlsRmFsbGJhY2spIHtcbiAgaWYgKGdldElzSHlkcmF0aW5nKCkpIHtcbiAgICAvLyBJZiB3ZSdyZSBoeWRyYXRpbmcsIHdlIHNob3VsZCBjb25zdW1lIGFzIG1hbnkgaXRlbXMgYXMgd2UgY2FuXG4gICAgLy8gc28gd2UgZG9uJ3QgbGVhdmUgYW55IGJlaGluZC5cbiAgICByZXR1cm47XG4gIH1cblxuICBzd2l0Y2ggKHJlbmRlclN0YXRlLnRhaWxNb2RlKSB7XG4gICAgY2FzZSAnaGlkZGVuJzpcbiAgICAgIHtcbiAgICAgICAgLy8gQW55IGluc2VydGlvbnMgYXQgdGhlIGVuZCBvZiB0aGUgdGFpbCBsaXN0IGFmdGVyIHRoaXMgcG9pbnRcbiAgICAgICAgLy8gc2hvdWxkIGJlIGludmlzaWJsZS4gSWYgdGhlcmUgYXJlIGFscmVhZHkgbW91bnRlZCBib3VuZGFyaWVzXG4gICAgICAgIC8vIGFueXRoaW5nIGJlZm9yZSB0aGVtIGFyZSBub3QgY29uc2lkZXJlZCBmb3IgY29sbGFwc2luZy5cbiAgICAgICAgLy8gVGhlcmVmb3JlIHdlIG5lZWQgdG8gZ28gdGhyb3VnaCB0aGUgd2hvbGUgdGFpbCB0byBmaW5kIGlmXG4gICAgICAgIC8vIHRoZXJlIGFyZSBhbnkuXG4gICAgICAgIHZhciB0YWlsTm9kZSA9IHJlbmRlclN0YXRlLnRhaWw7XG4gICAgICAgIHZhciBsYXN0VGFpbE5vZGUgPSBudWxsO1xuXG4gICAgICAgIHdoaWxlICh0YWlsTm9kZSAhPT0gbnVsbCkge1xuICAgICAgICAgIGlmICh0YWlsTm9kZS5hbHRlcm5hdGUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGxhc3RUYWlsTm9kZSA9IHRhaWxOb2RlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRhaWxOb2RlID0gdGFpbE5vZGUuc2libGluZztcbiAgICAgICAgfSAvLyBOZXh0IHdlJ3JlIHNpbXBseSBnb2luZyB0byBkZWxldGUgYWxsIGluc2VydGlvbnMgYWZ0ZXIgdGhlXG4gICAgICAgIC8vIGxhc3QgcmVuZGVyZWQgaXRlbS5cblxuXG4gICAgICAgIGlmIChsYXN0VGFpbE5vZGUgPT09IG51bGwpIHtcbiAgICAgICAgICAvLyBBbGwgcmVtYWluaW5nIGl0ZW1zIGluIHRoZSB0YWlsIGFyZSBpbnNlcnRpb25zLlxuICAgICAgICAgIHJlbmRlclN0YXRlLnRhaWwgPSBudWxsO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIERldGFjaCB0aGUgaW5zZXJ0aW9uIGFmdGVyIHRoZSBsYXN0IG5vZGUgdGhhdCB3YXMgYWxyZWFkeVxuICAgICAgICAgIC8vIGluc2VydGVkLlxuICAgICAgICAgIGxhc3RUYWlsTm9kZS5zaWJsaW5nID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgY2FzZSAnY29sbGFwc2VkJzpcbiAgICAgIHtcbiAgICAgICAgLy8gQW55IGluc2VydGlvbnMgYXQgdGhlIGVuZCBvZiB0aGUgdGFpbCBsaXN0IGFmdGVyIHRoaXMgcG9pbnRcbiAgICAgICAgLy8gc2hvdWxkIGJlIGludmlzaWJsZS4gSWYgdGhlcmUgYXJlIGFscmVhZHkgbW91bnRlZCBib3VuZGFyaWVzXG4gICAgICAgIC8vIGFueXRoaW5nIGJlZm9yZSB0aGVtIGFyZSBub3QgY29uc2lkZXJlZCBmb3IgY29sbGFwc2luZy5cbiAgICAgICAgLy8gVGhlcmVmb3JlIHdlIG5lZWQgdG8gZ28gdGhyb3VnaCB0aGUgd2hvbGUgdGFpbCB0byBmaW5kIGlmXG4gICAgICAgIC8vIHRoZXJlIGFyZSBhbnkuXG4gICAgICAgIHZhciBfdGFpbE5vZGUgPSByZW5kZXJTdGF0ZS50YWlsO1xuICAgICAgICB2YXIgX2xhc3RUYWlsTm9kZSA9IG51bGw7XG5cbiAgICAgICAgd2hpbGUgKF90YWlsTm9kZSAhPT0gbnVsbCkge1xuICAgICAgICAgIGlmIChfdGFpbE5vZGUuYWx0ZXJuYXRlICE9PSBudWxsKSB7XG4gICAgICAgICAgICBfbGFzdFRhaWxOb2RlID0gX3RhaWxOb2RlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIF90YWlsTm9kZSA9IF90YWlsTm9kZS5zaWJsaW5nO1xuICAgICAgICB9IC8vIE5leHQgd2UncmUgc2ltcGx5IGdvaW5nIHRvIGRlbGV0ZSBhbGwgaW5zZXJ0aW9ucyBhZnRlciB0aGVcbiAgICAgICAgLy8gbGFzdCByZW5kZXJlZCBpdGVtLlxuXG5cbiAgICAgICAgaWYgKF9sYXN0VGFpbE5vZGUgPT09IG51bGwpIHtcbiAgICAgICAgICAvLyBBbGwgcmVtYWluaW5nIGl0ZW1zIGluIHRoZSB0YWlsIGFyZSBpbnNlcnRpb25zLlxuICAgICAgICAgIGlmICghaGFzUmVuZGVyZWRBVGFpbEZhbGxiYWNrICYmIHJlbmRlclN0YXRlLnRhaWwgIT09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIFdlIHN1c3BlbmRlZCBkdXJpbmcgdGhlIGhlYWQuIFdlIHdhbnQgdG8gc2hvdyBhdCBsZWFzdCBvbmVcbiAgICAgICAgICAgIC8vIHJvdyBhdCB0aGUgdGFpbC4gU28gd2UnbGwga2VlcCBvbiBhbmQgY3V0IG9mZiB0aGUgcmVzdC5cbiAgICAgICAgICAgIHJlbmRlclN0YXRlLnRhaWwuc2libGluZyA9IG51bGw7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlbmRlclN0YXRlLnRhaWwgPSBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBEZXRhY2ggdGhlIGluc2VydGlvbiBhZnRlciB0aGUgbGFzdCBub2RlIHRoYXQgd2FzIGFscmVhZHlcbiAgICAgICAgICAvLyBpbnNlcnRlZC5cbiAgICAgICAgICBfbGFzdFRhaWxOb2RlLnNpYmxpbmcgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY29tcGxldGVXb3JrKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcykge1xuICB2YXIgbmV3UHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHM7XG5cbiAgc3dpdGNoICh3b3JrSW5Qcm9ncmVzcy50YWcpIHtcbiAgICBjYXNlIEluZGV0ZXJtaW5hdGVDb21wb25lbnQ6XG4gICAgY2FzZSBMYXp5Q29tcG9uZW50OlxuICAgIGNhc2UgU2ltcGxlTWVtb0NvbXBvbmVudDpcbiAgICBjYXNlIEZ1bmN0aW9uQ29tcG9uZW50OlxuICAgIGNhc2UgRm9yd2FyZFJlZjpcbiAgICBjYXNlIEZyYWdtZW50OlxuICAgIGNhc2UgTW9kZTpcbiAgICBjYXNlIFByb2ZpbGVyOlxuICAgIGNhc2UgQ29udGV4dENvbnN1bWVyOlxuICAgIGNhc2UgTWVtb0NvbXBvbmVudDpcbiAgICAgIHJldHVybiBudWxsO1xuXG4gICAgY2FzZSBDbGFzc0NvbXBvbmVudDpcbiAgICAgIHtcbiAgICAgICAgdmFyIENvbXBvbmVudCA9IHdvcmtJblByb2dyZXNzLnR5cGU7XG5cbiAgICAgICAgaWYgKGlzQ29udGV4dFByb3ZpZGVyKENvbXBvbmVudCkpIHtcbiAgICAgICAgICBwb3BDb250ZXh0KHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgY2FzZSBIb3N0Um9vdDpcbiAgICAgIHtcbiAgICAgICAgcG9wSG9zdENvbnRhaW5lcih3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgIHBvcFRvcExldmVsQ29udGV4dE9iamVjdCh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgIHJlc2V0V29ya0luUHJvZ3Jlc3NWZXJzaW9ucygpO1xuICAgICAgICB2YXIgZmliZXJSb290ID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuXG4gICAgICAgIGlmIChmaWJlclJvb3QucGVuZGluZ0NvbnRleHQpIHtcbiAgICAgICAgICBmaWJlclJvb3QuY29udGV4dCA9IGZpYmVyUm9vdC5wZW5kaW5nQ29udGV4dDtcbiAgICAgICAgICBmaWJlclJvb3QucGVuZGluZ0NvbnRleHQgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGN1cnJlbnQgPT09IG51bGwgfHwgY3VycmVudC5jaGlsZCA9PT0gbnVsbCkge1xuICAgICAgICAgIC8vIElmIHdlIGh5ZHJhdGVkLCBwb3Agc28gdGhhdCB3ZSBjYW4gZGVsZXRlIGFueSByZW1haW5pbmcgY2hpbGRyZW5cbiAgICAgICAgICAvLyB0aGF0IHdlcmVuJ3QgaHlkcmF0ZWQuXG4gICAgICAgICAgdmFyIHdhc0h5ZHJhdGVkID0gcG9wSHlkcmF0aW9uU3RhdGUod29ya0luUHJvZ3Jlc3MpO1xuXG4gICAgICAgICAgaWYgKHdhc0h5ZHJhdGVkKSB7XG4gICAgICAgICAgICAvLyBJZiB3ZSBoeWRyYXRlZCwgdGhlbiB3ZSdsbCBuZWVkIHRvIHNjaGVkdWxlIGFuIHVwZGF0ZSBmb3JcbiAgICAgICAgICAgIC8vIHRoZSBjb21taXQgc2lkZS1lZmZlY3RzIG9uIHRoZSByb290LlxuICAgICAgICAgICAgbWFya1VwZGF0ZSh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgfSBlbHNlIGlmICghZmliZXJSb290Lmh5ZHJhdGUpIHtcbiAgICAgICAgICAgIC8vIFNjaGVkdWxlIGFuIGVmZmVjdCB0byBjbGVhciB0aGlzIGNvbnRhaW5lciBhdCB0aGUgc3RhcnQgb2YgdGhlIG5leHQgY29tbWl0LlxuICAgICAgICAgICAgLy8gVGhpcyBoYW5kbGVzIHRoZSBjYXNlIG9mIFJlYWN0IHJlbmRlcmluZyBpbnRvIGEgY29udGFpbmVyIHdpdGggcHJldmlvdXMgY2hpbGRyZW4uXG4gICAgICAgICAgICAvLyBJdCdzIGFsc28gc2FmZSB0byBkbyBmb3IgdXBkYXRlcyB0b28sIGJlY2F1c2UgY3VycmVudC5jaGlsZCB3b3VsZCBvbmx5IGJlIG51bGxcbiAgICAgICAgICAgIC8vIGlmIHRoZSBwcmV2aW91cyByZW5kZXIgd2FzIG51bGwgKHNvIHRoZSB0aGUgY29udGFpbmVyIHdvdWxkIGFscmVhZHkgYmUgZW1wdHkpLlxuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gU25hcHNob3Q7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdXBkYXRlSG9zdENvbnRhaW5lcih3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgICAge1xuICAgICAgICBwb3BIb3N0Q29udGV4dCh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgIHZhciByb290Q29udGFpbmVySW5zdGFuY2UgPSBnZXRSb290SG9zdENvbnRhaW5lcigpO1xuICAgICAgICB2YXIgdHlwZSA9IHdvcmtJblByb2dyZXNzLnR5cGU7XG5cbiAgICAgICAgaWYgKGN1cnJlbnQgIT09IG51bGwgJiYgd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlICE9IG51bGwpIHtcbiAgICAgICAgICB1cGRhdGVIb3N0Q29tcG9uZW50JDEoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHR5cGUsIG5ld1Byb3BzLCByb290Q29udGFpbmVySW5zdGFuY2UpO1xuXG4gICAgICAgICAgaWYgKGN1cnJlbnQucmVmICE9PSB3b3JrSW5Qcm9ncmVzcy5yZWYpIHtcbiAgICAgICAgICAgIG1hcmtSZWYkMSh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICghbmV3UHJvcHMpIHtcbiAgICAgICAgICAgIGlmICghKHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSAhPT0gbnVsbCkpIHtcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRocm93IEVycm9yKCBcIldlIG11c3QgaGF2ZSBuZXcgcHJvcHMgZm9yIG5ldyBtb3VudHMuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCIgKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSAvLyBUaGlzIGNhbiBoYXBwZW4gd2hlbiB3ZSBhYm9ydCB3b3JrLlxuXG5cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBjdXJyZW50SG9zdENvbnRleHQgPSBnZXRIb3N0Q29udGV4dCgpOyAvLyBUT0RPOiBNb3ZlIGNyZWF0ZUluc3RhbmNlIHRvIGJlZ2luV29yayBhbmQga2VlcCBpdCBvbiBhIGNvbnRleHRcbiAgICAgICAgICAvLyBcInN0YWNrXCIgYXMgdGhlIHBhcmVudC4gVGhlbiBhcHBlbmQgY2hpbGRyZW4gYXMgd2UgZ28gaW4gYmVnaW5Xb3JrXG4gICAgICAgICAgLy8gb3IgY29tcGxldGVXb3JrIGRlcGVuZGluZyBvbiB3aGV0aGVyIHdlIHdhbnQgdG8gYWRkIHRoZW0gdG9wLT5kb3duIG9yXG4gICAgICAgICAgLy8gYm90dG9tLT51cC4gVG9wLT5kb3duIGlzIGZhc3RlciBpbiBJRTExLlxuXG4gICAgICAgICAgdmFyIF93YXNIeWRyYXRlZCA9IHBvcEh5ZHJhdGlvblN0YXRlKHdvcmtJblByb2dyZXNzKTtcblxuICAgICAgICAgIGlmIChfd2FzSHlkcmF0ZWQpIHtcbiAgICAgICAgICAgIC8vIFRPRE86IE1vdmUgdGhpcyBhbmQgY3JlYXRlSW5zdGFuY2Ugc3RlcCBpbnRvIHRoZSBiZWdpblBoYXNlXG4gICAgICAgICAgICAvLyB0byBjb25zb2xpZGF0ZS5cbiAgICAgICAgICAgIGlmIChwcmVwYXJlVG9IeWRyYXRlSG9zdEluc3RhbmNlKHdvcmtJblByb2dyZXNzLCByb290Q29udGFpbmVySW5zdGFuY2UsIGN1cnJlbnRIb3N0Q29udGV4dCkpIHtcbiAgICAgICAgICAgICAgLy8gSWYgY2hhbmdlcyB0byB0aGUgaHlkcmF0ZWQgbm9kZSBuZWVkIHRvIGJlIGFwcGxpZWQgYXQgdGhlXG4gICAgICAgICAgICAgIC8vIGNvbW1pdC1waGFzZSB3ZSBtYXJrIHRoaXMgYXMgc3VjaC5cbiAgICAgICAgICAgICAgbWFya1VwZGF0ZSh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBpbnN0YW5jZSA9IGNyZWF0ZUluc3RhbmNlKHR5cGUsIG5ld1Byb3BzLCByb290Q29udGFpbmVySW5zdGFuY2UsIGN1cnJlbnRIb3N0Q29udGV4dCwgd29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgICAgYXBwZW5kQWxsQ2hpbGRyZW4oaW5zdGFuY2UsIHdvcmtJblByb2dyZXNzLCBmYWxzZSwgZmFsc2UpO1xuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlID0gaW5zdGFuY2U7IC8vIENlcnRhaW4gcmVuZGVyZXJzIHJlcXVpcmUgY29tbWl0LXRpbWUgZWZmZWN0cyBmb3IgaW5pdGlhbCBtb3VudC5cbiAgICAgICAgICAgIC8vIChlZyBET00gcmVuZGVyZXIgc3VwcG9ydHMgYXV0by1mb2N1cyBmb3IgY2VydGFpbiBlbGVtZW50cykuXG4gICAgICAgICAgICAvLyBNYWtlIHN1cmUgc3VjaCByZW5kZXJlcnMgZ2V0IHNjaGVkdWxlZCBmb3IgbGF0ZXIgd29yay5cblxuICAgICAgICAgICAgaWYgKGZpbmFsaXplSW5pdGlhbENoaWxkcmVuKGluc3RhbmNlLCB0eXBlLCBuZXdQcm9wcywgcm9vdENvbnRhaW5lckluc3RhbmNlKSkge1xuICAgICAgICAgICAgICBtYXJrVXBkYXRlKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAod29ya0luUHJvZ3Jlc3MucmVmICE9PSBudWxsKSB7XG4gICAgICAgICAgICAvLyBJZiB0aGVyZSBpcyBhIHJlZiBvbiBhIGhvc3Qgbm9kZSB3ZSBuZWVkIHRvIHNjaGVkdWxlIGEgY2FsbGJhY2tcbiAgICAgICAgICAgIG1hcmtSZWYkMSh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICBjYXNlIEhvc3RUZXh0OlxuICAgICAge1xuICAgICAgICB2YXIgbmV3VGV4dCA9IG5ld1Byb3BzO1xuXG4gICAgICAgIGlmIChjdXJyZW50ICYmIHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSAhPSBudWxsKSB7XG4gICAgICAgICAgdmFyIG9sZFRleHQgPSBjdXJyZW50Lm1lbW9pemVkUHJvcHM7IC8vIElmIHdlIGhhdmUgYW4gYWx0ZXJuYXRlLCB0aGF0IG1lYW5zIHRoaXMgaXMgYW4gdXBkYXRlIGFuZCB3ZSBuZWVkXG4gICAgICAgICAgLy8gdG8gc2NoZWR1bGUgYSBzaWRlLWVmZmVjdCB0byBkbyB0aGUgdXBkYXRlcy5cblxuICAgICAgICAgIHVwZGF0ZUhvc3RUZXh0JDEoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIG9sZFRleHQsIG5ld1RleHQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICh0eXBlb2YgbmV3VGV4dCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGlmICghKHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSAhPT0gbnVsbCkpIHtcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRocm93IEVycm9yKCBcIldlIG11c3QgaGF2ZSBuZXcgcHJvcHMgZm9yIG5ldyBtb3VudHMuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCIgKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSAvLyBUaGlzIGNhbiBoYXBwZW4gd2hlbiB3ZSBhYm9ydCB3b3JrLlxuXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIF9yb290Q29udGFpbmVySW5zdGFuY2UgPSBnZXRSb290SG9zdENvbnRhaW5lcigpO1xuXG4gICAgICAgICAgdmFyIF9jdXJyZW50SG9zdENvbnRleHQgPSBnZXRIb3N0Q29udGV4dCgpO1xuXG4gICAgICAgICAgdmFyIF93YXNIeWRyYXRlZDIgPSBwb3BIeWRyYXRpb25TdGF0ZSh3b3JrSW5Qcm9ncmVzcyk7XG5cbiAgICAgICAgICBpZiAoX3dhc0h5ZHJhdGVkMikge1xuICAgICAgICAgICAgaWYgKHByZXBhcmVUb0h5ZHJhdGVIb3N0VGV4dEluc3RhbmNlKHdvcmtJblByb2dyZXNzKSkge1xuICAgICAgICAgICAgICBtYXJrVXBkYXRlKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlID0gY3JlYXRlVGV4dEluc3RhbmNlKG5ld1RleHQsIF9yb290Q29udGFpbmVySW5zdGFuY2UsIF9jdXJyZW50SG9zdENvbnRleHQsIHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgIGNhc2UgU3VzcGVuc2VDb21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIHBvcFN1c3BlbnNlQ29udGV4dCh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgIHZhciBuZXh0U3RhdGUgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO1xuXG4gICAgICAgIGlmICgod29ya0luUHJvZ3Jlc3MuZmxhZ3MgJiBEaWRDYXB0dXJlKSAhPT0gTm9GbGFncykge1xuICAgICAgICAgIC8vIFNvbWV0aGluZyBzdXNwZW5kZWQuIFJlLXJlbmRlciB3aXRoIHRoZSBmYWxsYmFjayBjaGlsZHJlbi5cbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5sYW5lcyA9IHJlbmRlckxhbmVzOyAvLyBEbyBub3QgcmVzZXQgdGhlIGVmZmVjdCBsaXN0LlxuXG4gICAgICAgICAgaWYgKCAod29ya0luUHJvZ3Jlc3MubW9kZSAmIFByb2ZpbGVNb2RlKSAhPT0gTm9Nb2RlKSB7XG4gICAgICAgICAgICB0cmFuc2ZlckFjdHVhbER1cmF0aW9uKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gd29ya0luUHJvZ3Jlc3M7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbmV4dERpZFRpbWVvdXQgPSBuZXh0U3RhdGUgIT09IG51bGw7XG4gICAgICAgIHZhciBwcmV2RGlkVGltZW91dCA9IGZhbHNlO1xuXG4gICAgICAgIGlmIChjdXJyZW50ID09PSBudWxsKSB7XG4gICAgICAgICAgaWYgKHdvcmtJblByb2dyZXNzLm1lbW9pemVkUHJvcHMuZmFsbGJhY2sgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcG9wSHlkcmF0aW9uU3RhdGUod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgcHJldlN0YXRlID0gY3VycmVudC5tZW1vaXplZFN0YXRlO1xuICAgICAgICAgIHByZXZEaWRUaW1lb3V0ID0gcHJldlN0YXRlICE9PSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG5leHREaWRUaW1lb3V0ICYmICFwcmV2RGlkVGltZW91dCkge1xuICAgICAgICAgIC8vIElmIHRoaXMgc3VidHJlZWUgaXMgcnVubmluZyBpbiBibG9ja2luZyBtb2RlIHdlIGNhbiBzdXNwZW5kLFxuICAgICAgICAgIC8vIG90aGVyd2lzZSB3ZSB3b24ndCBzdXNwZW5kLlxuICAgICAgICAgIC8vIFRPRE86IFRoaXMgd2lsbCBzdGlsbCBzdXNwZW5kIGEgc3luY2hyb25vdXMgdHJlZSBpZiBhbnl0aGluZ1xuICAgICAgICAgIC8vIGluIHRoZSBjb25jdXJyZW50IHRyZWUgYWxyZWFkeSBzdXNwZW5kZWQgZHVyaW5nIHRoaXMgcmVuZGVyLlxuICAgICAgICAgIC8vIFRoaXMgaXMgYSBrbm93biBidWcuXG4gICAgICAgICAgaWYgKCh3b3JrSW5Qcm9ncmVzcy5tb2RlICYgQmxvY2tpbmdNb2RlKSAhPT0gTm9Nb2RlKSB7XG4gICAgICAgICAgICAvLyBUT0RPOiBNb3ZlIHRoaXMgYmFjayB0byB0aHJvd0V4Y2VwdGlvbiBiZWNhdXNlIHRoaXMgaXMgdG9vIGxhdGVcbiAgICAgICAgICAgIC8vIGlmIHRoaXMgaXMgYSBsYXJnZSB0cmVlIHdoaWNoIGlzIGNvbW1vbiBmb3IgaW5pdGlhbCBsb2Fkcy4gV2VcbiAgICAgICAgICAgIC8vIGRvbid0IGtub3cgaWYgd2Ugc2hvdWxkIHJlc3RhcnQgYSByZW5kZXIgb3Igbm90IHVudGlsIHdlIGdldFxuICAgICAgICAgICAgLy8gdGhpcyBtYXJrZXIsIGFuZCB0aGlzIGlzIHRvbyBsYXRlLlxuICAgICAgICAgICAgLy8gSWYgdGhpcyByZW5kZXIgYWxyZWFkeSBoYWQgYSBwaW5nIG9yIGxvd2VyIHByaSB1cGRhdGVzLFxuICAgICAgICAgICAgLy8gYW5kIHRoaXMgaXMgdGhlIGZpcnN0IHRpbWUgd2Uga25vdyB3ZSdyZSBnb2luZyB0byBzdXNwZW5kIHdlXG4gICAgICAgICAgICAvLyBzaG91bGQgYmUgYWJsZSB0byBpbW1lZGlhdGVseSByZXN0YXJ0IGZyb20gd2l0aGluIHRocm93RXhjZXB0aW9uLlxuICAgICAgICAgICAgdmFyIGhhc0ludmlzaWJsZUNoaWxkQ29udGV4dCA9IGN1cnJlbnQgPT09IG51bGwgJiYgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcy51bnN0YWJsZV9hdm9pZFRoaXNGYWxsYmFjayAhPT0gdHJ1ZTtcblxuICAgICAgICAgICAgaWYgKGhhc0ludmlzaWJsZUNoaWxkQ29udGV4dCB8fCBoYXNTdXNwZW5zZUNvbnRleHQoc3VzcGVuc2VTdGFja0N1cnNvci5jdXJyZW50LCBJbnZpc2libGVQYXJlbnRTdXNwZW5zZUNvbnRleHQpKSB7XG4gICAgICAgICAgICAgIC8vIElmIHRoaXMgd2FzIGluIGFuIGludmlzaWJsZSB0cmVlIG9yIGEgbmV3IHJlbmRlciwgdGhlbiBzaG93aW5nXG4gICAgICAgICAgICAgIC8vIHRoaXMgYm91bmRhcnkgaXMgb2suXG4gICAgICAgICAgICAgIHJlbmRlckRpZFN1c3BlbmQoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vIE90aGVyd2lzZSwgd2UncmUgZ29pbmcgdG8gaGF2ZSB0byBoaWRlIGNvbnRlbnQgc28gd2Ugc2hvdWxkXG4gICAgICAgICAgICAgIC8vIHN1c3BlbmQgZm9yIGxvbmdlciBpZiBwb3NzaWJsZS5cbiAgICAgICAgICAgICAgcmVuZGVyRGlkU3VzcGVuZERlbGF5SWZQb3NzaWJsZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHtcbiAgICAgICAgICAvLyBUT0RPOiBPbmx5IHNjaGVkdWxlIHVwZGF0ZXMgaWYgdGhlc2UgdmFsdWVzIGFyZSBub24gZXF1YWwsIGkuZS4gaXQgY2hhbmdlZC5cbiAgICAgICAgICBpZiAobmV4dERpZFRpbWVvdXQgfHwgcHJldkRpZFRpbWVvdXQpIHtcbiAgICAgICAgICAgIC8vIElmIHRoaXMgYm91bmRhcnkganVzdCB0aW1lZCBvdXQsIHNjaGVkdWxlIGFuIGVmZmVjdCB0byBhdHRhY2ggYVxuICAgICAgICAgICAgLy8gcmV0cnkgbGlzdGVuZXIgdG8gdGhlIHByb21pc2UuIFRoaXMgZmxhZyBpcyBhbHNvIHVzZWQgdG8gaGlkZSB0aGVcbiAgICAgICAgICAgIC8vIHByaW1hcnkgY2hpbGRyZW4uIEluIG11dGF0aW9uIG1vZGUsIHdlIGFsc28gbmVlZCB0aGUgZmxhZyB0b1xuICAgICAgICAgICAgLy8gKnVuaGlkZSogY2hpbGRyZW4gdGhhdCB3ZXJlIHByZXZpb3VzbHkgaGlkZGVuLCBzbyBjaGVjayBpZiB0aGlzXG4gICAgICAgICAgICAvLyBpcyBjdXJyZW50bHkgdGltZWQgb3V0LCB0b28uXG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSBVcGRhdGU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICBjYXNlIEhvc3RQb3J0YWw6XG4gICAgICBwb3BIb3N0Q29udGFpbmVyKHdvcmtJblByb2dyZXNzKTtcbiAgICAgIHVwZGF0ZUhvc3RDb250YWluZXIod29ya0luUHJvZ3Jlc3MpO1xuXG4gICAgICBpZiAoY3VycmVudCA9PT0gbnVsbCkge1xuICAgICAgICBwcmVwYXJlUG9ydGFsTW91bnQod29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlLmNvbnRhaW5lckluZm8pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbnVsbDtcblxuICAgIGNhc2UgQ29udGV4dFByb3ZpZGVyOlxuICAgICAgLy8gUG9wIHByb3ZpZGVyIGZpYmVyXG4gICAgICBwb3BQcm92aWRlcih3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICByZXR1cm4gbnVsbDtcblxuICAgIGNhc2UgSW5jb21wbGV0ZUNsYXNzQ29tcG9uZW50OlxuICAgICAge1xuICAgICAgICAvLyBTYW1lIGFzIGNsYXNzIGNvbXBvbmVudCBjYXNlLiBJIHB1dCBpdCBkb3duIGhlcmUgc28gdGhhdCB0aGUgdGFncyBhcmVcbiAgICAgICAgLy8gc2VxdWVudGlhbCB0byBlbnN1cmUgdGhpcyBzd2l0Y2ggaXMgY29tcGlsZWQgdG8gYSBqdW1wIHRhYmxlLlxuICAgICAgICB2YXIgX0NvbXBvbmVudCA9IHdvcmtJblByb2dyZXNzLnR5cGU7XG5cbiAgICAgICAgaWYgKGlzQ29udGV4dFByb3ZpZGVyKF9Db21wb25lbnQpKSB7XG4gICAgICAgICAgcG9wQ29udGV4dCh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgIGNhc2UgU3VzcGVuc2VMaXN0Q29tcG9uZW50OlxuICAgICAge1xuICAgICAgICBwb3BTdXNwZW5zZUNvbnRleHQod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICB2YXIgcmVuZGVyU3RhdGUgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO1xuXG4gICAgICAgIGlmIChyZW5kZXJTdGF0ZSA9PT0gbnVsbCkge1xuICAgICAgICAgIC8vIFdlJ3JlIHJ1bm5pbmcgaW4gdGhlIGRlZmF1bHQsIFwiaW5kZXBlbmRlbnRcIiBtb2RlLlxuICAgICAgICAgIC8vIFdlIGRvbid0IGRvIGFueXRoaW5nIGluIHRoaXMgbW9kZS5cbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBkaWRTdXNwZW5kQWxyZWFkeSA9ICh3b3JrSW5Qcm9ncmVzcy5mbGFncyAmIERpZENhcHR1cmUpICE9PSBOb0ZsYWdzO1xuICAgICAgICB2YXIgcmVuZGVyZWRUYWlsID0gcmVuZGVyU3RhdGUucmVuZGVyaW5nO1xuXG4gICAgICAgIGlmIChyZW5kZXJlZFRhaWwgPT09IG51bGwpIHtcbiAgICAgICAgICAvLyBXZSBqdXN0IHJlbmRlcmVkIHRoZSBoZWFkLlxuICAgICAgICAgIGlmICghZGlkU3VzcGVuZEFscmVhZHkpIHtcbiAgICAgICAgICAgIC8vIFRoaXMgaXMgdGhlIGZpcnN0IHBhc3MuIFdlIG5lZWQgdG8gZmlndXJlIG91dCBpZiBhbnl0aGluZyBpcyBzdGlsbFxuICAgICAgICAgICAgLy8gc3VzcGVuZGVkIGluIHRoZSByZW5kZXJlZCBzZXQuXG4gICAgICAgICAgICAvLyBJZiBuZXcgY29udGVudCB1bnN1c3BlbmRlZCwgYnV0IHRoZXJlJ3Mgc3RpbGwgc29tZSBjb250ZW50IHRoYXRcbiAgICAgICAgICAgIC8vIGRpZG4ndC4gVGhlbiB3ZSBuZWVkIHRvIGRvIGEgc2Vjb25kIHBhc3MgdGhhdCBmb3JjZXMgZXZlcnl0aGluZ1xuICAgICAgICAgICAgLy8gdG8ga2VlcCBzaG93aW5nIHRoZWlyIGZhbGxiYWNrcy5cbiAgICAgICAgICAgIC8vIFdlIG1pZ2h0IGJlIHN1c3BlbmRlZCBpZiBzb21ldGhpbmcgaW4gdGhpcyByZW5kZXIgcGFzcyBzdXNwZW5kZWQsIG9yXG4gICAgICAgICAgICAvLyBzb21ldGhpbmcgaW4gdGhlIHByZXZpb3VzIGNvbW1pdHRlZCBwYXNzIHN1c3BlbmRlZC4gT3RoZXJ3aXNlLFxuICAgICAgICAgICAgLy8gdGhlcmUncyBubyBjaGFuY2Ugc28gd2UgY2FuIHNraXAgdGhlIGV4cGVuc2l2ZSBjYWxsIHRvXG4gICAgICAgICAgICAvLyBmaW5kRmlyc3RTdXNwZW5kZWQuXG4gICAgICAgICAgICB2YXIgY2Fubm90QmVTdXNwZW5kZWQgPSByZW5kZXJIYXNOb3RTdXNwZW5kZWRZZXQoKSAmJiAoY3VycmVudCA9PT0gbnVsbCB8fCAoY3VycmVudC5mbGFncyAmIERpZENhcHR1cmUpID09PSBOb0ZsYWdzKTtcblxuICAgICAgICAgICAgaWYgKCFjYW5ub3RCZVN1c3BlbmRlZCkge1xuICAgICAgICAgICAgICB2YXIgcm93ID0gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG5cbiAgICAgICAgICAgICAgd2hpbGUgKHJvdyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHZhciBzdXNwZW5kZWQgPSBmaW5kRmlyc3RTdXNwZW5kZWQocm93KTtcblxuICAgICAgICAgICAgICAgIGlmIChzdXNwZW5kZWQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgIGRpZFN1c3BlbmRBbHJlYWR5ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IERpZENhcHR1cmU7XG4gICAgICAgICAgICAgICAgICBjdXRPZmZUYWlsSWZOZWVkZWQocmVuZGVyU3RhdGUsIGZhbHNlKTsgLy8gSWYgdGhpcyBpcyBhIG5ld2x5IHN1c3BlbmRlZCB0cmVlLCBpdCBtaWdodCBub3QgZ2V0IGNvbW1pdHRlZCBhc1xuICAgICAgICAgICAgICAgICAgLy8gcGFydCBvZiB0aGUgc2Vjb25kIHBhc3MuIEluIHRoYXQgY2FzZSBub3RoaW5nIHdpbGwgc3Vic2NyaWJlIHRvXG4gICAgICAgICAgICAgICAgICAvLyBpdHMgdGhlbm5hYmxlcy4gSW5zdGVhZCwgd2UnbGwgdHJhbnNmZXIgaXRzIHRoZW5uYWJsZXMgdG8gdGhlXG4gICAgICAgICAgICAgICAgICAvLyBTdXNwZW5zZUxpc3Qgc28gdGhhdCBpdCBjYW4gcmV0cnkgaWYgdGhleSByZXNvbHZlLlxuICAgICAgICAgICAgICAgICAgLy8gVGhlcmUgbWlnaHQgYmUgbXVsdGlwbGUgb2YgdGhlc2UgaW4gdGhlIGxpc3QgYnV0IHNpbmNlIHdlJ3JlXG4gICAgICAgICAgICAgICAgICAvLyBnb2luZyB0byB3YWl0IGZvciBhbGwgb2YgdGhlbSBhbnl3YXksIGl0IGRvZXNuJ3QgcmVhbGx5IG1hdHRlclxuICAgICAgICAgICAgICAgICAgLy8gd2hpY2ggb25lcyBnZXRzIHRvIHBpbmcuIEluIHRoZW9yeSB3ZSBjb3VsZCBnZXQgY2xldmVyIGFuZCBrZWVwXG4gICAgICAgICAgICAgICAgICAvLyB0cmFjayBvZiBob3cgbWFueSBkZXBlbmRlbmNpZXMgcmVtYWluIGJ1dCBpdCBnZXRzIHRyaWNreSBiZWNhdXNlXG4gICAgICAgICAgICAgICAgICAvLyBpbiB0aGUgbWVhbnRpbWUsIHdlIGNhbiBhZGQvcmVtb3ZlL2NoYW5nZSBpdGVtcyBhbmQgZGVwZW5kZW5jaWVzLlxuICAgICAgICAgICAgICAgICAgLy8gV2UgbWlnaHQgYmFpbCBvdXQgb2YgdGhlIGxvb3AgYmVmb3JlIGZpbmRpbmcgYW55IGJ1dCB0aGF0XG4gICAgICAgICAgICAgICAgICAvLyBkb2Vzbid0IG1hdHRlciBzaW5jZSB0aGF0IG1lYW5zIHRoYXQgdGhlIG90aGVyIGJvdW5kYXJpZXMgdGhhdFxuICAgICAgICAgICAgICAgICAgLy8gd2UgZGlkIGZpbmQgYWxyZWFkeSBoYXMgdGhlaXIgbGlzdGVuZXJzIGF0dGFjaGVkLlxuXG4gICAgICAgICAgICAgICAgICB2YXIgbmV3VGhlbm5hYmxlcyA9IHN1c3BlbmRlZC51cGRhdGVRdWV1ZTtcblxuICAgICAgICAgICAgICAgICAgaWYgKG5ld1RoZW5uYWJsZXMgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWUgPSBuZXdUaGVubmFibGVzO1xuICAgICAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSBVcGRhdGU7XG4gICAgICAgICAgICAgICAgICB9IC8vIFJlcmVuZGVyIHRoZSB3aG9sZSBsaXN0LCBidXQgdGhpcyB0aW1lLCB3ZSdsbCBmb3JjZSBmYWxsYmFja3NcbiAgICAgICAgICAgICAgICAgIC8vIHRvIHN0YXkgaW4gcGxhY2UuXG4gICAgICAgICAgICAgICAgICAvLyBSZXNldCB0aGUgZWZmZWN0IGxpc3QgYmVmb3JlIGRvaW5nIHRoZSBzZWNvbmQgcGFzcyBzaW5jZSB0aGF0J3Mgbm93IGludmFsaWQuXG5cblxuICAgICAgICAgICAgICAgICAgaWYgKHJlbmRlclN0YXRlLmxhc3RFZmZlY3QgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MuZmlyc3RFZmZlY3QgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5sYXN0RWZmZWN0ID0gcmVuZGVyU3RhdGUubGFzdEVmZmVjdDsgLy8gUmVzZXQgdGhlIGNoaWxkIGZpYmVycyB0byB0aGVpciBvcmlnaW5hbCBzdGF0ZS5cblxuICAgICAgICAgICAgICAgICAgcmVzZXRDaGlsZEZpYmVycyh3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpOyAvLyBTZXQgdXAgdGhlIFN1c3BlbnNlIENvbnRleHQgdG8gZm9yY2Ugc3VzcGVuc2UgYW5kIGltbWVkaWF0ZWx5XG4gICAgICAgICAgICAgICAgICAvLyByZXJlbmRlciB0aGUgY2hpbGRyZW4uXG5cbiAgICAgICAgICAgICAgICAgIHB1c2hTdXNwZW5zZUNvbnRleHQod29ya0luUHJvZ3Jlc3MsIHNldFNoYWxsb3dTdXNwZW5zZUNvbnRleHQoc3VzcGVuc2VTdGFja0N1cnNvci5jdXJyZW50LCBGb3JjZVN1c3BlbnNlRmFsbGJhY2spKTtcbiAgICAgICAgICAgICAgICAgIHJldHVybiB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByb3cgPSByb3cuc2libGluZztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAocmVuZGVyU3RhdGUudGFpbCAhPT0gbnVsbCAmJiBub3coKSA+IGdldFJlbmRlclRhcmdldFRpbWUoKSkge1xuICAgICAgICAgICAgICAvLyBXZSBoYXZlIGFscmVhZHkgcGFzc2VkIG91ciBDUFUgZGVhZGxpbmUgYnV0IHdlIHN0aWxsIGhhdmUgcm93c1xuICAgICAgICAgICAgICAvLyBsZWZ0IGluIHRoZSB0YWlsLiBXZSdsbCBqdXN0IGdpdmUgdXAgZnVydGhlciBhdHRlbXB0cyB0byByZW5kZXJcbiAgICAgICAgICAgICAgLy8gdGhlIG1haW4gY29udGVudCBhbmQgb25seSByZW5kZXIgZmFsbGJhY2tzLlxuICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSBEaWRDYXB0dXJlO1xuICAgICAgICAgICAgICBkaWRTdXNwZW5kQWxyZWFkeSA9IHRydWU7XG4gICAgICAgICAgICAgIGN1dE9mZlRhaWxJZk5lZWRlZChyZW5kZXJTdGF0ZSwgZmFsc2UpOyAvLyBTaW5jZSBub3RoaW5nIGFjdHVhbGx5IHN1c3BlbmRlZCwgdGhlcmUgd2lsbCBub3RoaW5nIHRvIHBpbmcgdGhpc1xuICAgICAgICAgICAgICAvLyB0byBnZXQgaXQgc3RhcnRlZCBiYWNrIHVwIHRvIGF0dGVtcHQgdGhlIG5leHQgaXRlbS4gV2hpbGUgaW4gdGVybXNcbiAgICAgICAgICAgICAgLy8gb2YgcHJpb3JpdHkgdGhpcyB3b3JrIGhhcyB0aGUgc2FtZSBwcmlvcml0eSBhcyB0aGlzIGN1cnJlbnQgcmVuZGVyLFxuICAgICAgICAgICAgICAvLyBpdCdzIG5vdCBwYXJ0IG9mIHRoZSBzYW1lIHRyYW5zaXRpb24gb25jZSB0aGUgdHJhbnNpdGlvbiBoYXNcbiAgICAgICAgICAgICAgLy8gY29tbWl0dGVkLiBJZiBpdCdzIHN5bmMsIHdlIHN0aWxsIHdhbnQgdG8geWllbGQgc28gdGhhdCBpdCBjYW4gYmVcbiAgICAgICAgICAgICAgLy8gcGFpbnRlZC4gQ29uY2VwdHVhbGx5LCB0aGlzIGlzIHJlYWxseSB0aGUgc2FtZSBhcyBwaW5naW5nLlxuICAgICAgICAgICAgICAvLyBXZSBjYW4gdXNlIGFueSBSZXRyeUxhbmUgZXZlbiBpZiBpdCdzIHRoZSBvbmUgY3VycmVudGx5IHJlbmRlcmluZ1xuICAgICAgICAgICAgICAvLyBzaW5jZSB3ZSdyZSBsZWF2aW5nIGl0IGJlaGluZCBvbiB0aGlzIG5vZGUuXG5cbiAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MubGFuZXMgPSBTb21lUmV0cnlMYW5lO1xuXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBtYXJrU3Bhd25lZFdvcmsoU29tZVJldHJ5TGFuZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY3V0T2ZmVGFpbElmTmVlZGVkKHJlbmRlclN0YXRlLCBmYWxzZSk7XG4gICAgICAgICAgfSAvLyBOZXh0IHdlJ3JlIGdvaW5nIHRvIHJlbmRlciB0aGUgdGFpbC5cblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIEFwcGVuZCB0aGUgcmVuZGVyZWQgcm93IHRvIHRoZSBjaGlsZCBsaXN0LlxuICAgICAgICAgIGlmICghZGlkU3VzcGVuZEFscmVhZHkpIHtcbiAgICAgICAgICAgIHZhciBfc3VzcGVuZGVkID0gZmluZEZpcnN0U3VzcGVuZGVkKHJlbmRlcmVkVGFpbCk7XG5cbiAgICAgICAgICAgIGlmIChfc3VzcGVuZGVkICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IERpZENhcHR1cmU7XG4gICAgICAgICAgICAgIGRpZFN1c3BlbmRBbHJlYWR5ID0gdHJ1ZTsgLy8gRW5zdXJlIHdlIHRyYW5zZmVyIHRoZSB1cGRhdGUgcXVldWUgdG8gdGhlIHBhcmVudCBzbyB0aGF0IGl0IGRvZXNuJ3RcbiAgICAgICAgICAgICAgLy8gZ2V0IGxvc3QgaWYgdGhpcyByb3cgZW5kcyB1cCBkcm9wcGVkIGR1cmluZyBhIHNlY29uZCBwYXNzLlxuXG4gICAgICAgICAgICAgIHZhciBfbmV3VGhlbm5hYmxlcyA9IF9zdXNwZW5kZWQudXBkYXRlUXVldWU7XG5cbiAgICAgICAgICAgICAgaWYgKF9uZXdUaGVubmFibGVzICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWUgPSBfbmV3VGhlbm5hYmxlcztcbiAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSBVcGRhdGU7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBjdXRPZmZUYWlsSWZOZWVkZWQocmVuZGVyU3RhdGUsIHRydWUpOyAvLyBUaGlzIG1pZ2h0IGhhdmUgYmVlbiBtb2RpZmllZC5cblxuICAgICAgICAgICAgICBpZiAocmVuZGVyU3RhdGUudGFpbCA9PT0gbnVsbCAmJiByZW5kZXJTdGF0ZS50YWlsTW9kZSA9PT0gJ2hpZGRlbicgJiYgIXJlbmRlcmVkVGFpbC5hbHRlcm5hdGUgJiYgIWdldElzSHlkcmF0aW5nKCkgLy8gV2UgZG9uJ3QgY3V0IGl0IGlmIHdlJ3JlIGh5ZHJhdGluZy5cbiAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAvLyBXZSBuZWVkIHRvIGRlbGV0ZSB0aGUgcm93IHdlIGp1c3QgcmVuZGVyZWQuXG4gICAgICAgICAgICAgICAgICAvLyBSZXNldCB0aGUgZWZmZWN0IGxpc3QgdG8gd2hhdCBpdCB3YXMgYmVmb3JlIHdlIHJlbmRlcmVkIHRoaXNcbiAgICAgICAgICAgICAgICAgIC8vIGNoaWxkLiBUaGUgbmVzdGVkIGNoaWxkcmVuIGhhdmUgYWxyZWFkeSBhcHBlbmRlZCB0aGVtc2VsdmVzLlxuICAgICAgICAgICAgICAgICAgdmFyIGxhc3RFZmZlY3QgPSB3b3JrSW5Qcm9ncmVzcy5sYXN0RWZmZWN0ID0gcmVuZGVyU3RhdGUubGFzdEVmZmVjdDsgLy8gUmVtb3ZlIGFueSBlZmZlY3RzIHRoYXQgd2VyZSBhcHBlbmRlZCBhZnRlciB0aGlzIHBvaW50LlxuXG4gICAgICAgICAgICAgICAgICBpZiAobGFzdEVmZmVjdCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBsYXN0RWZmZWN0Lm5leHRFZmZlY3QgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgfSAvLyBXZSdyZSBkb25lLlxuXG5cbiAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIC8vIFRoZSB0aW1lIGl0IHRvb2sgdG8gcmVuZGVyIGxhc3Qgcm93IGlzIGdyZWF0ZXIgdGhhbiB0aGUgcmVtYWluaW5nXG4gICAgICAgICAgICAvLyB0aW1lIHdlIGhhdmUgdG8gcmVuZGVyLiBTbyByZW5kZXJpbmcgb25lIG1vcmUgcm93IHdvdWxkIGxpa2VseVxuICAgICAgICAgICAgLy8gZXhjZWVkIGl0LlxuICAgICAgICAgICAgbm93KCkgKiAyIC0gcmVuZGVyU3RhdGUucmVuZGVyaW5nU3RhcnRUaW1lID4gZ2V0UmVuZGVyVGFyZ2V0VGltZSgpICYmIHJlbmRlckxhbmVzICE9PSBPZmZzY3JlZW5MYW5lKSB7XG4gICAgICAgICAgICAgIC8vIFdlIGhhdmUgbm93IHBhc3NlZCBvdXIgQ1BVIGRlYWRsaW5lIGFuZCB3ZSdsbCBqdXN0IGdpdmUgdXAgZnVydGhlclxuICAgICAgICAgICAgICAvLyBhdHRlbXB0cyB0byByZW5kZXIgdGhlIG1haW4gY29udGVudCBhbmQgb25seSByZW5kZXIgZmFsbGJhY2tzLlxuICAgICAgICAgICAgICAvLyBUaGUgYXNzdW1wdGlvbiBpcyB0aGF0IHRoaXMgaXMgdXN1YWxseSBmYXN0ZXIuXG4gICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IERpZENhcHR1cmU7XG4gICAgICAgICAgICAgIGRpZFN1c3BlbmRBbHJlYWR5ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgY3V0T2ZmVGFpbElmTmVlZGVkKHJlbmRlclN0YXRlLCBmYWxzZSk7IC8vIFNpbmNlIG5vdGhpbmcgYWN0dWFsbHkgc3VzcGVuZGVkLCB0aGVyZSB3aWxsIG5vdGhpbmcgdG8gcGluZyB0aGlzXG4gICAgICAgICAgICAgIC8vIHRvIGdldCBpdCBzdGFydGVkIGJhY2sgdXAgdG8gYXR0ZW1wdCB0aGUgbmV4dCBpdGVtLiBXaGlsZSBpbiB0ZXJtc1xuICAgICAgICAgICAgICAvLyBvZiBwcmlvcml0eSB0aGlzIHdvcmsgaGFzIHRoZSBzYW1lIHByaW9yaXR5IGFzIHRoaXMgY3VycmVudCByZW5kZXIsXG4gICAgICAgICAgICAgIC8vIGl0J3Mgbm90IHBhcnQgb2YgdGhlIHNhbWUgdHJhbnNpdGlvbiBvbmNlIHRoZSB0cmFuc2l0aW9uIGhhc1xuICAgICAgICAgICAgICAvLyBjb21taXR0ZWQuIElmIGl0J3Mgc3luYywgd2Ugc3RpbGwgd2FudCB0byB5aWVsZCBzbyB0aGF0IGl0IGNhbiBiZVxuICAgICAgICAgICAgICAvLyBwYWludGVkLiBDb25jZXB0dWFsbHksIHRoaXMgaXMgcmVhbGx5IHRoZSBzYW1lIGFzIHBpbmdpbmcuXG4gICAgICAgICAgICAgIC8vIFdlIGNhbiB1c2UgYW55IFJldHJ5TGFuZSBldmVuIGlmIGl0J3MgdGhlIG9uZSBjdXJyZW50bHkgcmVuZGVyaW5nXG4gICAgICAgICAgICAgIC8vIHNpbmNlIHdlJ3JlIGxlYXZpbmcgaXQgYmVoaW5kIG9uIHRoaXMgbm9kZS5cblxuICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5sYW5lcyA9IFNvbWVSZXRyeUxhbmU7XG5cbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG1hcmtTcGF3bmVkV29yayhTb21lUmV0cnlMYW5lKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChyZW5kZXJTdGF0ZS5pc0JhY2t3YXJkcykge1xuICAgICAgICAgICAgLy8gVGhlIGVmZmVjdCBsaXN0IG9mIHRoZSBiYWNrd2FyZHMgdGFpbCB3aWxsIGhhdmUgYmVlbiBhZGRlZFxuICAgICAgICAgICAgLy8gdG8gdGhlIGVuZC4gVGhpcyBicmVha3MgdGhlIGd1YXJhbnRlZSB0aGF0IGxpZmUtY3ljbGVzIGZpcmUgaW5cbiAgICAgICAgICAgIC8vIHNpYmxpbmcgb3JkZXIgYnV0IHRoYXQgaXNuJ3QgYSBzdHJvbmcgZ3VhcmFudGVlIHByb21pc2VkIGJ5IFJlYWN0LlxuICAgICAgICAgICAgLy8gRXNwZWNpYWxseSBzaW5jZSB0aGVzZSBtaWdodCBhbHNvIGp1c3QgcG9wIGluIGR1cmluZyBmdXR1cmUgY29tbWl0cy5cbiAgICAgICAgICAgIC8vIEFwcGVuZCB0byB0aGUgYmVnaW5uaW5nIG9mIHRoZSBsaXN0LlxuICAgICAgICAgICAgcmVuZGVyZWRUYWlsLnNpYmxpbmcgPSB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLmNoaWxkID0gcmVuZGVyZWRUYWlsO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgcHJldmlvdXNTaWJsaW5nID0gcmVuZGVyU3RhdGUubGFzdDtcblxuICAgICAgICAgICAgaWYgKHByZXZpb3VzU2libGluZyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICBwcmV2aW91c1NpYmxpbmcuc2libGluZyA9IHJlbmRlcmVkVGFpbDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLmNoaWxkID0gcmVuZGVyZWRUYWlsO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZW5kZXJTdGF0ZS5sYXN0ID0gcmVuZGVyZWRUYWlsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChyZW5kZXJTdGF0ZS50YWlsICE9PSBudWxsKSB7XG4gICAgICAgICAgLy8gV2Ugc3RpbGwgaGF2ZSB0YWlsIHJvd3MgdG8gcmVuZGVyLlxuICAgICAgICAgIC8vIFBvcCBhIHJvdy5cbiAgICAgICAgICB2YXIgbmV4dCA9IHJlbmRlclN0YXRlLnRhaWw7XG4gICAgICAgICAgcmVuZGVyU3RhdGUucmVuZGVyaW5nID0gbmV4dDtcbiAgICAgICAgICByZW5kZXJTdGF0ZS50YWlsID0gbmV4dC5zaWJsaW5nO1xuICAgICAgICAgIHJlbmRlclN0YXRlLmxhc3RFZmZlY3QgPSB3b3JrSW5Qcm9ncmVzcy5sYXN0RWZmZWN0O1xuICAgICAgICAgIHJlbmRlclN0YXRlLnJlbmRlcmluZ1N0YXJ0VGltZSA9IG5vdygpO1xuICAgICAgICAgIG5leHQuc2libGluZyA9IG51bGw7IC8vIFJlc3RvcmUgdGhlIGNvbnRleHQuXG4gICAgICAgICAgLy8gVE9ETzogV2UgY2FuIHByb2JhYmx5IGp1c3QgYXZvaWQgcG9wcGluZyBpdCBpbnN0ZWFkIGFuZCBvbmx5XG4gICAgICAgICAgLy8gc2V0dGluZyBpdCB0aGUgZmlyc3QgdGltZSB3ZSBnbyBmcm9tIG5vdCBzdXNwZW5kZWQgdG8gc3VzcGVuZGVkLlxuXG4gICAgICAgICAgdmFyIHN1c3BlbnNlQ29udGV4dCA9IHN1c3BlbnNlU3RhY2tDdXJzb3IuY3VycmVudDtcblxuICAgICAgICAgIGlmIChkaWRTdXNwZW5kQWxyZWFkeSkge1xuICAgICAgICAgICAgc3VzcGVuc2VDb250ZXh0ID0gc2V0U2hhbGxvd1N1c3BlbnNlQ29udGV4dChzdXNwZW5zZUNvbnRleHQsIEZvcmNlU3VzcGVuc2VGYWxsYmFjayk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN1c3BlbnNlQ29udGV4dCA9IHNldERlZmF1bHRTaGFsbG93U3VzcGVuc2VDb250ZXh0KHN1c3BlbnNlQ29udGV4dCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcHVzaFN1c3BlbnNlQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgc3VzcGVuc2VDb250ZXh0KTsgLy8gRG8gYSBwYXNzIG92ZXIgdGhlIG5leHQgcm93LlxuXG4gICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgIGNhc2UgRnVuZGFtZW50YWxDb21wb25lbnQ6XG4gICAgICB7XG5cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICBjYXNlIFNjb3BlQ29tcG9uZW50OlxuICAgICAge1xuXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgY2FzZSBCbG9jazpcblxuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIE9mZnNjcmVlbkNvbXBvbmVudDpcbiAgICBjYXNlIExlZ2FjeUhpZGRlbkNvbXBvbmVudDpcbiAgICAgIHtcbiAgICAgICAgcG9wUmVuZGVyTGFuZXMod29ya0luUHJvZ3Jlc3MpO1xuXG4gICAgICAgIGlmIChjdXJyZW50ICE9PSBudWxsKSB7XG4gICAgICAgICAgdmFyIF9uZXh0U3RhdGUgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO1xuICAgICAgICAgIHZhciBfcHJldlN0YXRlID0gY3VycmVudC5tZW1vaXplZFN0YXRlO1xuICAgICAgICAgIHZhciBwcmV2SXNIaWRkZW4gPSBfcHJldlN0YXRlICE9PSBudWxsO1xuICAgICAgICAgIHZhciBuZXh0SXNIaWRkZW4gPSBfbmV4dFN0YXRlICE9PSBudWxsO1xuXG4gICAgICAgICAgaWYgKHByZXZJc0hpZGRlbiAhPT0gbmV4dElzSGlkZGVuICYmIG5ld1Byb3BzLm1vZGUgIT09ICd1bnN0YWJsZS1kZWZlci13aXRob3V0LWhpZGluZycpIHtcbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IFVwZGF0ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgfVxuXG4gIHtcbiAgICB7XG4gICAgICB0aHJvdyBFcnJvciggXCJVbmtub3duIHVuaXQgb2Ygd29yayB0YWcgKFwiICsgd29ya0luUHJvZ3Jlc3MudGFnICsgXCIpLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiICk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHVud2luZFdvcmsod29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKSB7XG4gIHN3aXRjaCAod29ya0luUHJvZ3Jlc3MudGFnKSB7XG4gICAgY2FzZSBDbGFzc0NvbXBvbmVudDpcbiAgICAgIHtcbiAgICAgICAgdmFyIENvbXBvbmVudCA9IHdvcmtJblByb2dyZXNzLnR5cGU7XG5cbiAgICAgICAgaWYgKGlzQ29udGV4dFByb3ZpZGVyKENvbXBvbmVudCkpIHtcbiAgICAgICAgICBwb3BDb250ZXh0KHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBmbGFncyA9IHdvcmtJblByb2dyZXNzLmZsYWdzO1xuXG4gICAgICAgIGlmIChmbGFncyAmIFNob3VsZENhcHR1cmUpIHtcbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyA9IGZsYWdzICYgflNob3VsZENhcHR1cmUgfCBEaWRDYXB0dXJlO1xuXG4gICAgICAgICAgaWYgKCAod29ya0luUHJvZ3Jlc3MubW9kZSAmIFByb2ZpbGVNb2RlKSAhPT0gTm9Nb2RlKSB7XG4gICAgICAgICAgICB0cmFuc2ZlckFjdHVhbER1cmF0aW9uKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gd29ya0luUHJvZ3Jlc3M7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgIGNhc2UgSG9zdFJvb3Q6XG4gICAgICB7XG4gICAgICAgIHBvcEhvc3RDb250YWluZXIod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICBwb3BUb3BMZXZlbENvbnRleHRPYmplY3Qod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICByZXNldFdvcmtJblByb2dyZXNzVmVyc2lvbnMoKTtcbiAgICAgICAgdmFyIF9mbGFncyA9IHdvcmtJblByb2dyZXNzLmZsYWdzO1xuXG4gICAgICAgIGlmICghKChfZmxhZ3MgJiBEaWRDYXB0dXJlKSA9PT0gTm9GbGFncykpIHtcbiAgICAgICAgICB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvciggXCJUaGUgcm9vdCBmYWlsZWQgdG8gdW5tb3VudCBhZnRlciBhbiBlcnJvci4gVGhpcyBpcyBsaWtlbHkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgPSBfZmxhZ3MgJiB+U2hvdWxkQ2FwdHVyZSB8IERpZENhcHR1cmU7XG4gICAgICAgIHJldHVybiB3b3JrSW5Qcm9ncmVzcztcbiAgICAgIH1cblxuICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICAgIHtcbiAgICAgICAgLy8gVE9ETzogcG9wSHlkcmF0aW9uU3RhdGVcbiAgICAgICAgcG9wSG9zdENvbnRleHQod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgIGNhc2UgU3VzcGVuc2VDb21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIHBvcFN1c3BlbnNlQ29udGV4dCh3b3JrSW5Qcm9ncmVzcyk7XG5cbiAgICAgICAgdmFyIF9mbGFnczIgPSB3b3JrSW5Qcm9ncmVzcy5mbGFncztcblxuICAgICAgICBpZiAoX2ZsYWdzMiAmIFNob3VsZENhcHR1cmUpIHtcbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyA9IF9mbGFnczIgJiB+U2hvdWxkQ2FwdHVyZSB8IERpZENhcHR1cmU7IC8vIENhcHR1cmVkIGEgc3VzcGVuc2UgZWZmZWN0LiBSZS1yZW5kZXIgdGhlIGJvdW5kYXJ5LlxuXG4gICAgICAgICAgaWYgKCAod29ya0luUHJvZ3Jlc3MubW9kZSAmIFByb2ZpbGVNb2RlKSAhPT0gTm9Nb2RlKSB7XG4gICAgICAgICAgICB0cmFuc2ZlckFjdHVhbER1cmF0aW9uKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gd29ya0luUHJvZ3Jlc3M7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgIGNhc2UgU3VzcGVuc2VMaXN0Q29tcG9uZW50OlxuICAgICAge1xuICAgICAgICBwb3BTdXNwZW5zZUNvbnRleHQod29ya0luUHJvZ3Jlc3MpOyAvLyBTdXNwZW5zZUxpc3QgZG9lc24ndCBhY3R1YWxseSBjYXRjaCBhbnl0aGluZy4gSXQgc2hvdWxkJ3ZlIGJlZW5cbiAgICAgICAgLy8gY2F1Z2h0IGJ5IGEgbmVzdGVkIGJvdW5kYXJ5LiBJZiBub3QsIGl0IHNob3VsZCBidWJibGUgdGhyb3VnaC5cblxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgIGNhc2UgSG9zdFBvcnRhbDpcbiAgICAgIHBvcEhvc3RDb250YWluZXIod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgcmV0dXJuIG51bGw7XG5cbiAgICBjYXNlIENvbnRleHRQcm92aWRlcjpcbiAgICAgIHBvcFByb3ZpZGVyKHdvcmtJblByb2dyZXNzKTtcbiAgICAgIHJldHVybiBudWxsO1xuXG4gICAgY2FzZSBPZmZzY3JlZW5Db21wb25lbnQ6XG4gICAgY2FzZSBMZWdhY3lIaWRkZW5Db21wb25lbnQ6XG4gICAgICBwb3BSZW5kZXJMYW5lcyh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICByZXR1cm4gbnVsbDtcblxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG5mdW5jdGlvbiB1bndpbmRJbnRlcnJ1cHRlZFdvcmsoaW50ZXJydXB0ZWRXb3JrKSB7XG4gIHN3aXRjaCAoaW50ZXJydXB0ZWRXb3JrLnRhZykge1xuICAgIGNhc2UgQ2xhc3NDb21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIHZhciBjaGlsZENvbnRleHRUeXBlcyA9IGludGVycnVwdGVkV29yay50eXBlLmNoaWxkQ29udGV4dFR5cGVzO1xuXG4gICAgICAgIGlmIChjaGlsZENvbnRleHRUeXBlcyAhPT0gbnVsbCAmJiBjaGlsZENvbnRleHRUeXBlcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcG9wQ29udGV4dChpbnRlcnJ1cHRlZFdvcmspO1xuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICBjYXNlIEhvc3RSb290OlxuICAgICAge1xuICAgICAgICBwb3BIb3N0Q29udGFpbmVyKGludGVycnVwdGVkV29yayk7XG4gICAgICAgIHBvcFRvcExldmVsQ29udGV4dE9iamVjdChpbnRlcnJ1cHRlZFdvcmspO1xuICAgICAgICByZXNldFdvcmtJblByb2dyZXNzVmVyc2lvbnMoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIHBvcEhvc3RDb250ZXh0KGludGVycnVwdGVkV29yayk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgY2FzZSBIb3N0UG9ydGFsOlxuICAgICAgcG9wSG9zdENvbnRhaW5lcihpbnRlcnJ1cHRlZFdvcmspO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIFN1c3BlbnNlQ29tcG9uZW50OlxuICAgICAgcG9wU3VzcGVuc2VDb250ZXh0KGludGVycnVwdGVkV29yayk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgU3VzcGVuc2VMaXN0Q29tcG9uZW50OlxuICAgICAgcG9wU3VzcGVuc2VDb250ZXh0KGludGVycnVwdGVkV29yayk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgQ29udGV4dFByb3ZpZGVyOlxuICAgICAgcG9wUHJvdmlkZXIoaW50ZXJydXB0ZWRXb3JrKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBPZmZzY3JlZW5Db21wb25lbnQ6XG4gICAgY2FzZSBMZWdhY3lIaWRkZW5Db21wb25lbnQ6XG4gICAgICBwb3BSZW5kZXJMYW5lcyhpbnRlcnJ1cHRlZFdvcmspO1xuICAgICAgYnJlYWs7XG4gIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlQ2FwdHVyZWRWYWx1ZSh2YWx1ZSwgc291cmNlKSB7XG4gIC8vIElmIHRoZSB2YWx1ZSBpcyBhbiBlcnJvciwgY2FsbCB0aGlzIGZ1bmN0aW9uIGltbWVkaWF0ZWx5IGFmdGVyIGl0IGlzIHRocm93blxuICAvLyBzbyB0aGUgc3RhY2sgaXMgYWNjdXJhdGUuXG4gIHJldHVybiB7XG4gICAgdmFsdWU6IHZhbHVlLFxuICAgIHNvdXJjZTogc291cmNlLFxuICAgIHN0YWNrOiBnZXRTdGFja0J5RmliZXJJbkRldkFuZFByb2Qoc291cmNlKVxuICB9O1xufVxuXG4vLyBUaGlzIG1vZHVsZSBpcyBmb3JrZWQgaW4gZGlmZmVyZW50IGVudmlyb25tZW50cy5cbi8vIEJ5IGRlZmF1bHQsIHJldHVybiBgdHJ1ZWAgdG8gbG9nIGVycm9ycyB0byB0aGUgY29uc29sZS5cbi8vIEZvcmtzIGNhbiByZXR1cm4gYGZhbHNlYCBpZiB0aGlzIGlzbid0IGRlc2lyYWJsZS5cbmZ1bmN0aW9uIHNob3dFcnJvckRpYWxvZyhib3VuZGFyeSwgZXJyb3JJbmZvKSB7XG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBsb2dDYXB0dXJlZEVycm9yKGJvdW5kYXJ5LCBlcnJvckluZm8pIHtcbiAgdHJ5IHtcbiAgICB2YXIgbG9nRXJyb3IgPSBzaG93RXJyb3JEaWFsb2coYm91bmRhcnksIGVycm9ySW5mbyk7IC8vIEFsbG93IGluamVjdGVkIHNob3dFcnJvckRpYWxvZygpIHRvIHByZXZlbnQgZGVmYXVsdCBjb25zb2xlLmVycm9yIGxvZ2dpbmcuXG4gICAgLy8gVGhpcyBlbmFibGVzIHJlbmRlcmVycyBsaWtlIFJlYWN0TmF0aXZlIHRvIGJldHRlciBtYW5hZ2UgcmVkYm94IGJlaGF2aW9yLlxuXG4gICAgaWYgKGxvZ0Vycm9yID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBlcnJvciA9IGVycm9ySW5mby52YWx1ZTtcblxuICAgIGlmICh0cnVlKSB7XG4gICAgICB2YXIgc291cmNlID0gZXJyb3JJbmZvLnNvdXJjZTtcbiAgICAgIHZhciBzdGFjayA9IGVycm9ySW5mby5zdGFjaztcbiAgICAgIHZhciBjb21wb25lbnRTdGFjayA9IHN0YWNrICE9PSBudWxsID8gc3RhY2sgOiAnJzsgLy8gQnJvd3NlcnMgc3VwcG9ydCBzaWxlbmNpbmcgdW5jYXVnaHQgZXJyb3JzIGJ5IGNhbGxpbmdcbiAgICAgIC8vIGBwcmV2ZW50RGVmYXVsdCgpYCBpbiB3aW5kb3cgYGVycm9yYCBoYW5kbGVyLlxuICAgICAgLy8gV2UgcmVjb3JkIHRoaXMgaW5mb3JtYXRpb24gYXMgYW4gZXhwYW5kbyBvbiB0aGUgZXJyb3IuXG5cbiAgICAgIGlmIChlcnJvciAhPSBudWxsICYmIGVycm9yLl9zdXBwcmVzc0xvZ2dpbmcpIHtcbiAgICAgICAgaWYgKGJvdW5kYXJ5LnRhZyA9PT0gQ2xhc3NDb21wb25lbnQpIHtcbiAgICAgICAgICAvLyBUaGUgZXJyb3IgaXMgcmVjb3ZlcmFibGUgYW5kIHdhcyBzaWxlbmNlZC5cbiAgICAgICAgICAvLyBJZ25vcmUgaXQgYW5kIGRvbid0IHByaW50IHRoZSBzdGFjayBhZGRlbmR1bS5cbiAgICAgICAgICAvLyBUaGlzIGlzIGhhbmR5IGZvciB0ZXN0aW5nIGVycm9yIGJvdW5kYXJpZXMgd2l0aG91dCBub2lzZS5cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gLy8gVGhlIGVycm9yIGlzIGZhdGFsLiBTaW5jZSB0aGUgc2lsZW5jaW5nIG1pZ2h0IGhhdmVcbiAgICAgICAgLy8gYmVlbiBhY2NpZGVudGFsLCB3ZSdsbCBzdXJmYWNlIGl0IGFueXdheS5cbiAgICAgICAgLy8gSG93ZXZlciwgdGhlIGJyb3dzZXIgd291bGQgaGF2ZSBzaWxlbmNlZCB0aGUgb3JpZ2luYWwgZXJyb3JcbiAgICAgICAgLy8gc28gd2UnbGwgcHJpbnQgaXQgZmlyc3QsIGFuZCB0aGVuIHByaW50IHRoZSBzdGFjayBhZGRlbmR1bS5cblxuXG4gICAgICAgIGNvbnNvbGVbJ2Vycm9yJ10oZXJyb3IpOyAvLyBEb24ndCB0cmFuc2Zvcm0gdG8gb3VyIHdyYXBwZXJcbiAgICAgICAgLy8gRm9yIGEgbW9yZSBkZXRhaWxlZCBkZXNjcmlwdGlvbiBvZiB0aGlzIGJsb2NrLCBzZWU6XG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9wdWxsLzEzMzg0XG4gICAgICB9XG5cbiAgICAgIHZhciBjb21wb25lbnROYW1lID0gc291cmNlID8gZ2V0Q29tcG9uZW50TmFtZShzb3VyY2UudHlwZSkgOiBudWxsO1xuICAgICAgdmFyIGNvbXBvbmVudE5hbWVNZXNzYWdlID0gY29tcG9uZW50TmFtZSA/IFwiVGhlIGFib3ZlIGVycm9yIG9jY3VycmVkIGluIHRoZSA8XCIgKyBjb21wb25lbnROYW1lICsgXCI+IGNvbXBvbmVudDpcIiA6ICdUaGUgYWJvdmUgZXJyb3Igb2NjdXJyZWQgaW4gb25lIG9mIHlvdXIgUmVhY3QgY29tcG9uZW50czonO1xuICAgICAgdmFyIGVycm9yQm91bmRhcnlNZXNzYWdlO1xuICAgICAgdmFyIGVycm9yQm91bmRhcnlOYW1lID0gZ2V0Q29tcG9uZW50TmFtZShib3VuZGFyeS50eXBlKTtcblxuICAgICAgaWYgKGVycm9yQm91bmRhcnlOYW1lKSB7XG4gICAgICAgIGVycm9yQm91bmRhcnlNZXNzYWdlID0gXCJSZWFjdCB3aWxsIHRyeSB0byByZWNyZWF0ZSB0aGlzIGNvbXBvbmVudCB0cmVlIGZyb20gc2NyYXRjaCBcIiArIChcInVzaW5nIHRoZSBlcnJvciBib3VuZGFyeSB5b3UgcHJvdmlkZWQsIFwiICsgZXJyb3JCb3VuZGFyeU5hbWUgKyBcIi5cIik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlcnJvckJvdW5kYXJ5TWVzc2FnZSA9ICdDb25zaWRlciBhZGRpbmcgYW4gZXJyb3IgYm91bmRhcnkgdG8geW91ciB0cmVlIHRvIGN1c3RvbWl6ZSBlcnJvciBoYW5kbGluZyBiZWhhdmlvci5cXG4nICsgJ1Zpc2l0IGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9lcnJvci1ib3VuZGFyaWVzIHRvIGxlYXJuIG1vcmUgYWJvdXQgZXJyb3IgYm91bmRhcmllcy4nO1xuICAgICAgfVxuXG4gICAgICB2YXIgY29tYmluZWRNZXNzYWdlID0gY29tcG9uZW50TmFtZU1lc3NhZ2UgKyBcIlxcblwiICsgY29tcG9uZW50U3RhY2sgKyBcIlxcblxcblwiICsgKFwiXCIgKyBlcnJvckJvdW5kYXJ5TWVzc2FnZSk7IC8vIEluIGRldmVsb3BtZW50LCB3ZSBwcm92aWRlIG91ciBvd24gbWVzc2FnZSB3aXRoIGp1c3QgdGhlIGNvbXBvbmVudCBzdGFjay5cbiAgICAgIC8vIFdlIGRvbid0IGluY2x1ZGUgdGhlIG9yaWdpbmFsIGVycm9yIG1lc3NhZ2UgYW5kIEpTIHN0YWNrIGJlY2F1c2UgdGhlIGJyb3dzZXJcbiAgICAgIC8vIGhhcyBhbHJlYWR5IHByaW50ZWQgaXQuIEV2ZW4gaWYgdGhlIGFwcGxpY2F0aW9uIHN3YWxsb3dzIHRoZSBlcnJvciwgaXQgaXMgc3RpbGxcbiAgICAgIC8vIGRpc3BsYXllZCBieSB0aGUgYnJvd3NlciB0aGFua3MgdG8gdGhlIERFVi1vbmx5IGZha2UgZXZlbnQgdHJpY2sgaW4gUmVhY3RFcnJvclV0aWxzLlxuXG4gICAgICBjb25zb2xlWydlcnJvciddKGNvbWJpbmVkTWVzc2FnZSk7IC8vIERvbid0IHRyYW5zZm9ybSB0byBvdXIgd3JhcHBlclxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBJbiBwcm9kdWN0aW9uLCB3ZSBwcmludCB0aGUgZXJyb3IgZGlyZWN0bHkuXG4gICAgICAvLyBUaGlzIHdpbGwgaW5jbHVkZSB0aGUgbWVzc2FnZSwgdGhlIEpTIHN0YWNrLCBhbmQgYW55dGhpbmcgdGhlIGJyb3dzZXIgd2FudHMgdG8gc2hvdy5cbiAgICAgIC8vIFdlIHBhc3MgdGhlIGVycm9yIG9iamVjdCBpbnN0ZWFkIG9mIGN1c3RvbSBtZXNzYWdlIHNvIHRoYXQgdGhlIGJyb3dzZXIgZGlzcGxheXMgdGhlIGVycm9yIG5hdGl2ZWx5LlxuICAgICAgY29uc29sZVsnZXJyb3InXShlcnJvcik7IC8vIERvbid0IHRyYW5zZm9ybSB0byBvdXIgd3JhcHBlclxuICAgIH1cbiAgfSBjYXRjaCAoZSkge1xuICAgIC8vIFRoaXMgbWV0aG9kIG11c3Qgbm90IHRocm93LCBvciBSZWFjdCBpbnRlcm5hbCBzdGF0ZSB3aWxsIGdldCBtZXNzZWQgdXAuXG4gICAgLy8gSWYgY29uc29sZS5lcnJvciBpcyBvdmVycmlkZGVuLCBvciBsb2dDYXB0dXJlZEVycm9yKCkgc2hvd3MgYSBkaWFsb2cgdGhhdCB0aHJvd3MsXG4gICAgLy8gd2Ugd2FudCB0byByZXBvcnQgdGhpcyBlcnJvciBvdXRzaWRlIG9mIHRoZSBub3JtYWwgc3RhY2sgYXMgYSBsYXN0IHJlc29ydC5cbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzEzMTg4XG4gICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICB0aHJvdyBlO1xuICAgIH0pO1xuICB9XG59XG5cbnZhciBQb3NzaWJseVdlYWtNYXAkMSA9IHR5cGVvZiBXZWFrTWFwID09PSAnZnVuY3Rpb24nID8gV2Vha01hcCA6IE1hcDtcblxuZnVuY3Rpb24gY3JlYXRlUm9vdEVycm9yVXBkYXRlKGZpYmVyLCBlcnJvckluZm8sIGxhbmUpIHtcbiAgdmFyIHVwZGF0ZSA9IGNyZWF0ZVVwZGF0ZShOb1RpbWVzdGFtcCwgbGFuZSk7IC8vIFVubW91bnQgdGhlIHJvb3QgYnkgcmVuZGVyaW5nIG51bGwuXG5cbiAgdXBkYXRlLnRhZyA9IENhcHR1cmVVcGRhdGU7IC8vIENhdXRpb246IFJlYWN0IERldlRvb2xzIGN1cnJlbnRseSBkZXBlbmRzIG9uIHRoaXMgcHJvcGVydHlcbiAgLy8gYmVpbmcgY2FsbGVkIFwiZWxlbWVudFwiLlxuXG4gIHVwZGF0ZS5wYXlsb2FkID0ge1xuICAgIGVsZW1lbnQ6IG51bGxcbiAgfTtcbiAgdmFyIGVycm9yID0gZXJyb3JJbmZvLnZhbHVlO1xuXG4gIHVwZGF0ZS5jYWxsYmFjayA9IGZ1bmN0aW9uICgpIHtcbiAgICBvblVuY2F1Z2h0RXJyb3IoZXJyb3IpO1xuICAgIGxvZ0NhcHR1cmVkRXJyb3IoZmliZXIsIGVycm9ySW5mbyk7XG4gIH07XG5cbiAgcmV0dXJuIHVwZGF0ZTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlQ2xhc3NFcnJvclVwZGF0ZShmaWJlciwgZXJyb3JJbmZvLCBsYW5lKSB7XG4gIHZhciB1cGRhdGUgPSBjcmVhdGVVcGRhdGUoTm9UaW1lc3RhbXAsIGxhbmUpO1xuICB1cGRhdGUudGFnID0gQ2FwdHVyZVVwZGF0ZTtcbiAgdmFyIGdldERlcml2ZWRTdGF0ZUZyb21FcnJvciA9IGZpYmVyLnR5cGUuZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yO1xuXG4gIGlmICh0eXBlb2YgZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdmFyIGVycm9yJDEgPSBlcnJvckluZm8udmFsdWU7XG5cbiAgICB1cGRhdGUucGF5bG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGxvZ0NhcHR1cmVkRXJyb3IoZmliZXIsIGVycm9ySW5mbyk7XG4gICAgICByZXR1cm4gZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yKGVycm9yJDEpO1xuICAgIH07XG4gIH1cblxuICB2YXIgaW5zdCA9IGZpYmVyLnN0YXRlTm9kZTtcblxuICBpZiAoaW5zdCAhPT0gbnVsbCAmJiB0eXBlb2YgaW5zdC5jb21wb25lbnREaWRDYXRjaCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHVwZGF0ZS5jYWxsYmFjayA9IGZ1bmN0aW9uIGNhbGxiYWNrKCkge1xuICAgICAge1xuICAgICAgICBtYXJrRmFpbGVkRXJyb3JCb3VuZGFyeUZvckhvdFJlbG9hZGluZyhmaWJlcik7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8vIFRvIHByZXNlcnZlIHRoZSBwcmVleGlzdGluZyByZXRyeSBiZWhhdmlvciBvZiBlcnJvciBib3VuZGFyaWVzLFxuICAgICAgICAvLyB3ZSBrZWVwIHRyYWNrIG9mIHdoaWNoIG9uZXMgYWxyZWFkeSBmYWlsZWQgZHVyaW5nIHRoaXMgYmF0Y2guXG4gICAgICAgIC8vIFRoaXMgZ2V0cyByZXNldCBiZWZvcmUgd2UgeWllbGQgYmFjayB0byB0aGUgYnJvd3Nlci5cbiAgICAgICAgLy8gVE9ETzogV2FybiBpbiBzdHJpY3QgbW9kZSBpZiBnZXREZXJpdmVkU3RhdGVGcm9tRXJyb3IgaXNcbiAgICAgICAgLy8gbm90IGRlZmluZWQuXG4gICAgICAgIG1hcmtMZWdhY3lFcnJvckJvdW5kYXJ5QXNGYWlsZWQodGhpcyk7IC8vIE9ubHkgbG9nIGhlcmUgaWYgY29tcG9uZW50RGlkQ2F0Y2ggaXMgdGhlIG9ubHkgZXJyb3IgYm91bmRhcnkgbWV0aG9kIGRlZmluZWRcblxuICAgICAgICBsb2dDYXB0dXJlZEVycm9yKGZpYmVyLCBlcnJvckluZm8pO1xuICAgICAgfVxuXG4gICAgICB2YXIgZXJyb3IkMSA9IGVycm9ySW5mby52YWx1ZTtcbiAgICAgIHZhciBzdGFjayA9IGVycm9ySW5mby5zdGFjaztcbiAgICAgIHRoaXMuY29tcG9uZW50RGlkQ2F0Y2goZXJyb3IkMSwge1xuICAgICAgICBjb21wb25lbnRTdGFjazogc3RhY2sgIT09IG51bGwgPyBzdGFjayA6ICcnXG4gICAgICB9KTtcblxuICAgICAge1xuICAgICAgICBpZiAodHlwZW9mIGdldERlcml2ZWRTdGF0ZUZyb21FcnJvciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIC8vIElmIGNvbXBvbmVudERpZENhdGNoIGlzIHRoZSBvbmx5IGVycm9yIGJvdW5kYXJ5IG1ldGhvZCBkZWZpbmVkLFxuICAgICAgICAgIC8vIHRoZW4gaXQgbmVlZHMgdG8gY2FsbCBzZXRTdGF0ZSB0byByZWNvdmVyIGZyb20gZXJyb3JzLlxuICAgICAgICAgIC8vIElmIG5vIHN0YXRlIHVwZGF0ZSBpcyBzY2hlZHVsZWQgdGhlbiB0aGUgYm91bmRhcnkgd2lsbCBzd2FsbG93IHRoZSBlcnJvci5cbiAgICAgICAgICBpZiAoIWluY2x1ZGVzU29tZUxhbmUoZmliZXIubGFuZXMsIFN5bmNMYW5lKSkge1xuICAgICAgICAgICAgZXJyb3IoJyVzOiBFcnJvciBib3VuZGFyaWVzIHNob3VsZCBpbXBsZW1lbnQgZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yKCkuICcgKyAnSW4gdGhhdCBtZXRob2QsIHJldHVybiBhIHN0YXRlIHVwZGF0ZSB0byBkaXNwbGF5IGFuIGVycm9yIG1lc3NhZ2Ugb3IgZmFsbGJhY2sgVUkuJywgZ2V0Q29tcG9uZW50TmFtZShmaWJlci50eXBlKSB8fCAnVW5rbm93bicpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgdXBkYXRlLmNhbGxiYWNrID0gZnVuY3Rpb24gKCkge1xuICAgICAgbWFya0ZhaWxlZEVycm9yQm91bmRhcnlGb3JIb3RSZWxvYWRpbmcoZmliZXIpO1xuICAgIH07XG4gIH1cblxuICByZXR1cm4gdXBkYXRlO1xufVxuXG5mdW5jdGlvbiBhdHRhY2hQaW5nTGlzdGVuZXIocm9vdCwgd2FrZWFibGUsIGxhbmVzKSB7XG4gIC8vIEF0dGFjaCBhIGxpc3RlbmVyIHRvIHRoZSBwcm9taXNlIHRvIFwicGluZ1wiIHRoZSByb290IGFuZCByZXRyeS4gQnV0IG9ubHkgaWZcbiAgLy8gb25lIGRvZXMgbm90IGFscmVhZHkgZXhpc3QgZm9yIHRoZSBsYW5lcyB3ZSdyZSBjdXJyZW50bHkgcmVuZGVyaW5nICh3aGljaFxuICAvLyBhY3RzIGxpa2UgYSBcInRocmVhZCBJRFwiIGhlcmUpLlxuICB2YXIgcGluZ0NhY2hlID0gcm9vdC5waW5nQ2FjaGU7XG4gIHZhciB0aHJlYWRJRHM7XG5cbiAgaWYgKHBpbmdDYWNoZSA9PT0gbnVsbCkge1xuICAgIHBpbmdDYWNoZSA9IHJvb3QucGluZ0NhY2hlID0gbmV3IFBvc3NpYmx5V2Vha01hcCQxKCk7XG4gICAgdGhyZWFkSURzID0gbmV3IFNldCgpO1xuICAgIHBpbmdDYWNoZS5zZXQod2FrZWFibGUsIHRocmVhZElEcyk7XG4gIH0gZWxzZSB7XG4gICAgdGhyZWFkSURzID0gcGluZ0NhY2hlLmdldCh3YWtlYWJsZSk7XG5cbiAgICBpZiAodGhyZWFkSURzID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocmVhZElEcyA9IG5ldyBTZXQoKTtcbiAgICAgIHBpbmdDYWNoZS5zZXQod2FrZWFibGUsIHRocmVhZElEcyk7XG4gICAgfVxuICB9XG5cbiAgaWYgKCF0aHJlYWRJRHMuaGFzKGxhbmVzKSkge1xuICAgIC8vIE1lbW9pemUgdXNpbmcgdGhlIHRocmVhZCBJRCB0byBwcmV2ZW50IHJlZHVuZGFudCBsaXN0ZW5lcnMuXG4gICAgdGhyZWFkSURzLmFkZChsYW5lcyk7XG4gICAgdmFyIHBpbmcgPSBwaW5nU3VzcGVuZGVkUm9vdC5iaW5kKG51bGwsIHJvb3QsIHdha2VhYmxlLCBsYW5lcyk7XG4gICAgd2FrZWFibGUudGhlbihwaW5nLCBwaW5nKTtcbiAgfVxufVxuXG5mdW5jdGlvbiB0aHJvd0V4Y2VwdGlvbihyb290LCByZXR1cm5GaWJlciwgc291cmNlRmliZXIsIHZhbHVlLCByb290UmVuZGVyTGFuZXMpIHtcbiAgLy8gVGhlIHNvdXJjZSBmaWJlciBkaWQgbm90IGNvbXBsZXRlLlxuICBzb3VyY2VGaWJlci5mbGFncyB8PSBJbmNvbXBsZXRlOyAvLyBJdHMgZWZmZWN0IGxpc3QgaXMgbm8gbG9uZ2VyIHZhbGlkLlxuXG4gIHNvdXJjZUZpYmVyLmZpcnN0RWZmZWN0ID0gc291cmNlRmliZXIubGFzdEVmZmVjdCA9IG51bGw7XG5cbiAgaWYgKHZhbHVlICE9PSBudWxsICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIHZhbHVlLnRoZW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAvLyBUaGlzIGlzIGEgd2FrZWFibGUuXG4gICAgdmFyIHdha2VhYmxlID0gdmFsdWU7XG5cbiAgICBpZiAoKHNvdXJjZUZpYmVyLm1vZGUgJiBCbG9ja2luZ01vZGUpID09PSBOb01vZGUpIHtcbiAgICAgIC8vIFJlc2V0IHRoZSBtZW1vaXplZFN0YXRlIHRvIHdoYXQgaXQgd2FzIGJlZm9yZSB3ZSBhdHRlbXB0ZWRcbiAgICAgIC8vIHRvIHJlbmRlciBpdC5cbiAgICAgIHZhciBjdXJyZW50U291cmNlID0gc291cmNlRmliZXIuYWx0ZXJuYXRlO1xuXG4gICAgICBpZiAoY3VycmVudFNvdXJjZSkge1xuICAgICAgICBzb3VyY2VGaWJlci51cGRhdGVRdWV1ZSA9IGN1cnJlbnRTb3VyY2UudXBkYXRlUXVldWU7XG4gICAgICAgIHNvdXJjZUZpYmVyLm1lbW9pemVkU3RhdGUgPSBjdXJyZW50U291cmNlLm1lbW9pemVkU3RhdGU7XG4gICAgICAgIHNvdXJjZUZpYmVyLmxhbmVzID0gY3VycmVudFNvdXJjZS5sYW5lcztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNvdXJjZUZpYmVyLnVwZGF0ZVF1ZXVlID0gbnVsbDtcbiAgICAgICAgc291cmNlRmliZXIubWVtb2l6ZWRTdGF0ZSA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGhhc0ludmlzaWJsZVBhcmVudEJvdW5kYXJ5ID0gaGFzU3VzcGVuc2VDb250ZXh0KHN1c3BlbnNlU3RhY2tDdXJzb3IuY3VycmVudCwgSW52aXNpYmxlUGFyZW50U3VzcGVuc2VDb250ZXh0KTsgLy8gU2NoZWR1bGUgdGhlIG5lYXJlc3QgU3VzcGVuc2UgdG8gcmUtcmVuZGVyIHRoZSB0aW1lZCBvdXQgdmlldy5cblxuICAgIHZhciBfd29ya0luUHJvZ3Jlc3MgPSByZXR1cm5GaWJlcjtcblxuICAgIGRvIHtcbiAgICAgIGlmIChfd29ya0luUHJvZ3Jlc3MudGFnID09PSBTdXNwZW5zZUNvbXBvbmVudCAmJiBzaG91bGRDYXB0dXJlU3VzcGVuc2UoX3dvcmtJblByb2dyZXNzLCBoYXNJbnZpc2libGVQYXJlbnRCb3VuZGFyeSkpIHtcbiAgICAgICAgLy8gRm91bmQgdGhlIG5lYXJlc3QgYm91bmRhcnkuXG4gICAgICAgIC8vIFN0YXNoIHRoZSBwcm9taXNlIG9uIHRoZSBib3VuZGFyeSBmaWJlci4gSWYgdGhlIGJvdW5kYXJ5IHRpbWVzIG91dCwgd2UnbGxcbiAgICAgICAgLy8gYXR0YWNoIGFub3RoZXIgbGlzdGVuZXIgdG8gZmxpcCB0aGUgYm91bmRhcnkgYmFjayB0byBpdHMgbm9ybWFsIHN0YXRlLlxuICAgICAgICB2YXIgd2FrZWFibGVzID0gX3dvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlO1xuXG4gICAgICAgIGlmICh3YWtlYWJsZXMgPT09IG51bGwpIHtcbiAgICAgICAgICB2YXIgdXBkYXRlUXVldWUgPSBuZXcgU2V0KCk7XG4gICAgICAgICAgdXBkYXRlUXVldWUuYWRkKHdha2VhYmxlKTtcbiAgICAgICAgICBfd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWUgPSB1cGRhdGVRdWV1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB3YWtlYWJsZXMuYWRkKHdha2VhYmxlKTtcbiAgICAgICAgfSAvLyBJZiB0aGUgYm91bmRhcnkgaXMgb3V0c2lkZSBvZiBibG9ja2luZyBtb2RlLCB3ZSBzaG91bGQgKm5vdCpcbiAgICAgICAgLy8gc3VzcGVuZCB0aGUgY29tbWl0LiBQcmV0ZW5kIGFzIGlmIHRoZSBzdXNwZW5kZWQgY29tcG9uZW50IHJlbmRlcmVkXG4gICAgICAgIC8vIG51bGwgYW5kIGtlZXAgcmVuZGVyaW5nLiBJbiB0aGUgY29tbWl0IHBoYXNlLCB3ZSdsbCBzY2hlZHVsZSBhXG4gICAgICAgIC8vIHN1YnNlcXVlbnQgc3luY2hyb25vdXMgdXBkYXRlIHRvIHJlLXJlbmRlciB0aGUgU3VzcGVuc2UuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIE5vdGU6IEl0IGRvZXNuJ3QgbWF0dGVyIHdoZXRoZXIgdGhlIGNvbXBvbmVudCB0aGF0IHN1c3BlbmRlZCB3YXNcbiAgICAgICAgLy8gaW5zaWRlIGEgYmxvY2tpbmcgbW9kZSB0cmVlLiBJZiB0aGUgU3VzcGVuc2UgaXMgb3V0c2lkZSBvZiBpdCwgd2VcbiAgICAgICAgLy8gc2hvdWxkICpub3QqIHN1c3BlbmQgdGhlIGNvbW1pdC5cblxuXG4gICAgICAgIGlmICgoX3dvcmtJblByb2dyZXNzLm1vZGUgJiBCbG9ja2luZ01vZGUpID09PSBOb01vZGUpIHtcbiAgICAgICAgICBfd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gRGlkQ2FwdHVyZTtcbiAgICAgICAgICBzb3VyY2VGaWJlci5mbGFncyB8PSBGb3JjZVVwZGF0ZUZvckxlZ2FjeVN1c3BlbnNlOyAvLyBXZSdyZSBnb2luZyB0byBjb21taXQgdGhpcyBmaWJlciBldmVuIHRob3VnaCBpdCBkaWRuJ3QgY29tcGxldGUuXG4gICAgICAgICAgLy8gQnV0IHdlIHNob3VsZG4ndCBjYWxsIGFueSBsaWZlY3ljbGUgbWV0aG9kcyBvciBjYWxsYmFja3MuIFJlbW92ZVxuICAgICAgICAgIC8vIGFsbCBsaWZlY3ljbGUgZWZmZWN0IHRhZ3MuXG5cbiAgICAgICAgICBzb3VyY2VGaWJlci5mbGFncyAmPSB+KExpZmVjeWNsZUVmZmVjdE1hc2sgfCBJbmNvbXBsZXRlKTtcblxuICAgICAgICAgIGlmIChzb3VyY2VGaWJlci50YWcgPT09IENsYXNzQ29tcG9uZW50KSB7XG4gICAgICAgICAgICB2YXIgY3VycmVudFNvdXJjZUZpYmVyID0gc291cmNlRmliZXIuYWx0ZXJuYXRlO1xuXG4gICAgICAgICAgICBpZiAoY3VycmVudFNvdXJjZUZpYmVyID09PSBudWxsKSB7XG4gICAgICAgICAgICAgIC8vIFRoaXMgaXMgYSBuZXcgbW91bnQuIENoYW5nZSB0aGUgdGFnIHNvIGl0J3Mgbm90IG1pc3Rha2VuIGZvciBhXG4gICAgICAgICAgICAgIC8vIGNvbXBsZXRlZCBjbGFzcyBjb21wb25lbnQuIEZvciBleGFtcGxlLCB3ZSBzaG91bGQgbm90IGNhbGxcbiAgICAgICAgICAgICAgLy8gY29tcG9uZW50V2lsbFVubW91bnQgaWYgaXQgaXMgZGVsZXRlZC5cbiAgICAgICAgICAgICAgc291cmNlRmliZXIudGFnID0gSW5jb21wbGV0ZUNsYXNzQ29tcG9uZW50O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gV2hlbiB3ZSB0cnkgcmVuZGVyaW5nIGFnYWluLCB3ZSBzaG91bGQgbm90IHJldXNlIHRoZSBjdXJyZW50IGZpYmVyLFxuICAgICAgICAgICAgICAvLyBzaW5jZSBpdCdzIGtub3duIHRvIGJlIGluIGFuIGluY29uc2lzdGVudCBzdGF0ZS4gVXNlIGEgZm9yY2UgdXBkYXRlIHRvXG4gICAgICAgICAgICAgIC8vIHByZXZlbnQgYSBiYWlsIG91dC5cbiAgICAgICAgICAgICAgdmFyIHVwZGF0ZSA9IGNyZWF0ZVVwZGF0ZShOb1RpbWVzdGFtcCwgU3luY0xhbmUpO1xuICAgICAgICAgICAgICB1cGRhdGUudGFnID0gRm9yY2VVcGRhdGU7XG4gICAgICAgICAgICAgIGVucXVldWVVcGRhdGUoc291cmNlRmliZXIsIHVwZGF0ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSAvLyBUaGUgc291cmNlIGZpYmVyIGRpZCBub3QgY29tcGxldGUuIE1hcmsgaXQgd2l0aCBTeW5jIHByaW9yaXR5IHRvXG4gICAgICAgICAgLy8gaW5kaWNhdGUgdGhhdCBpdCBzdGlsbCBoYXMgcGVuZGluZyB3b3JrLlxuXG5cbiAgICAgICAgICBzb3VyY2VGaWJlci5sYW5lcyA9IG1lcmdlTGFuZXMoc291cmNlRmliZXIubGFuZXMsIFN5bmNMYW5lKTsgLy8gRXhpdCB3aXRob3V0IHN1c3BlbmRpbmcuXG5cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gLy8gQ29uZmlybWVkIHRoYXQgdGhlIGJvdW5kYXJ5IGlzIGluIGEgY29uY3VycmVudCBtb2RlIHRyZWUuIENvbnRpbnVlXG4gICAgICAgIC8vIHdpdGggdGhlIG5vcm1hbCBzdXNwZW5kIHBhdGguXG4gICAgICAgIC8vXG4gICAgICAgIC8vIEFmdGVyIHRoaXMgd2UnbGwgdXNlIGEgc2V0IG9mIGhldXJpc3RpY3MgdG8gZGV0ZXJtaW5lIHdoZXRoZXIgdGhpc1xuICAgICAgICAvLyByZW5kZXIgcGFzcyB3aWxsIHJ1biB0byBjb21wbGV0aW9uIG9yIHJlc3RhcnQgb3IgXCJzdXNwZW5kXCIgdGhlIGNvbW1pdC5cbiAgICAgICAgLy8gVGhlIGFjdHVhbCBsb2dpYyBmb3IgdGhpcyBpcyBzcHJlYWQgb3V0IGluIGRpZmZlcmVudCBwbGFjZXMuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIFRoaXMgZmlyc3QgcHJpbmNpcGxlIGlzIHRoYXQgaWYgd2UncmUgZ29pbmcgdG8gc3VzcGVuZCB3aGVuIHdlIGNvbXBsZXRlXG4gICAgICAgIC8vIGEgcm9vdCwgdGhlbiB3ZSBzaG91bGQgYWxzbyByZXN0YXJ0IGlmIHdlIGdldCBhbiB1cGRhdGUgb3IgcGluZyB0aGF0XG4gICAgICAgIC8vIG1pZ2h0IHVuc3VzcGVuZCBpdCwgYW5kIHZpY2UgdmVyc2EuIFRoZSBvbmx5IHJlYXNvbiB0byBzdXNwZW5kIGlzXG4gICAgICAgIC8vIGJlY2F1c2UgeW91IHRoaW5rIHlvdSBtaWdodCB3YW50IHRvIHJlc3RhcnQgYmVmb3JlIGNvbW1pdHRpbmcuIEhvd2V2ZXIsXG4gICAgICAgIC8vIGl0IGRvZXNuJ3QgbWFrZSBzZW5zZSB0byByZXN0YXJ0IG9ubHkgd2hpbGUgaW4gdGhlIHBlcmlvZCB3ZSdyZSBzdXNwZW5kZWQuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIFJlc3RhcnRpbmcgdG9vIGFnZ3Jlc3NpdmVseSBpcyBhbHNvIG5vdCBnb29kIGJlY2F1c2UgaXQgc3RhcnZlcyBvdXQgYW55XG4gICAgICAgIC8vIGludGVybWVkaWF0ZSBsb2FkaW5nIHN0YXRlLiBTbyB3ZSB1c2UgaGV1cmlzdGljcyB0byBkZXRlcm1pbmUgd2hlbi5cbiAgICAgICAgLy8gU3VzcGVuc2UgSGV1cmlzdGljc1xuICAgICAgICAvL1xuICAgICAgICAvLyBJZiBub3RoaW5nIHRocmV3IGEgUHJvbWlzZSBvciBhbGwgdGhlIHNhbWUgZmFsbGJhY2tzIGFyZSBhbHJlYWR5IHNob3dpbmcsXG4gICAgICAgIC8vIHRoZW4gZG9uJ3Qgc3VzcGVuZC9yZXN0YXJ0LlxuICAgICAgICAvL1xuICAgICAgICAvLyBJZiB0aGlzIGlzIGFuIGluaXRpYWwgcmVuZGVyIG9mIGEgbmV3IHRyZWUgb2YgU3VzcGVuc2UgYm91bmRhcmllcyBhbmRcbiAgICAgICAgLy8gdGhvc2UgdHJpZ2dlciBhIGZhbGxiYWNrLCB0aGVuIGRvbid0IHN1c3BlbmQvcmVzdGFydC4gV2Ugd2FudCB0byBlbnN1cmVcbiAgICAgICAgLy8gdGhhdCB3ZSBjYW4gc2hvdyB0aGUgaW5pdGlhbCBsb2FkaW5nIHN0YXRlIGFzIHF1aWNrbHkgYXMgcG9zc2libGUuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIElmIHdlIGhpdCBhIFwiRGVsYXllZFwiIGNhc2UsIHN1Y2ggYXMgd2hlbiB3ZSdkIHN3aXRjaCBmcm9tIGNvbnRlbnQgYmFjayBpbnRvXG4gICAgICAgIC8vIGEgZmFsbGJhY2ssIHRoZW4gd2Ugc2hvdWxkIGFsd2F5cyBzdXNwZW5kL3Jlc3RhcnQuIFRyYW5zaXRpb25zIGFwcGx5XG4gICAgICAgIC8vIHRvIHRoaXMgY2FzZS4gSWYgbm9uZSBpcyBkZWZpbmVkLCBKTkQgaXMgdXNlZCBpbnN0ZWFkLlxuICAgICAgICAvL1xuICAgICAgICAvLyBJZiB3ZSdyZSBhbHJlYWR5IHNob3dpbmcgYSBmYWxsYmFjayBhbmQgaXQgZ2V0cyBcInJldHJpZWRcIiwgYWxsb3dpbmcgdXMgdG8gc2hvd1xuICAgICAgICAvLyBhbm90aGVyIGxldmVsLCBidXQgdGhlcmUncyBzdGlsbCBhbiBpbm5lciBib3VuZGFyeSB0aGF0IHdvdWxkIHNob3cgYSBmYWxsYmFjayxcbiAgICAgICAgLy8gdGhlbiB3ZSBzdXNwZW5kL3Jlc3RhcnQgZm9yIDUwMG1zIHNpbmNlIHRoZSBsYXN0IHRpbWUgd2Ugc2hvd2VkIGEgZmFsbGJhY2tcbiAgICAgICAgLy8gYW55d2hlcmUgaW4gdGhlIHRyZWUuIFRoaXMgZWZmZWN0aXZlbHkgdGhyb3R0bGVzIHByb2dyZXNzaXZlIGxvYWRpbmcgaW50byBhXG4gICAgICAgIC8vIGNvbnNpc3RlbnQgdHJhaW4gb2YgY29tbWl0cy4gVGhpcyBhbHNvIGdpdmVzIHVzIGFuIG9wcG9ydHVuaXR5IHRvIHJlc3RhcnQgdG9cbiAgICAgICAgLy8gZ2V0IHRvIHRoZSBjb21wbGV0ZWQgc3RhdGUgc2xpZ2h0bHkgZWFybGllci5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gSWYgdGhlcmUncyBhbWJpZ3VpdHkgZHVlIHRvIGJhdGNoaW5nIGl0J3MgcmVzb2x2ZWQgaW4gcHJlZmVyZW5jZSBvZjpcbiAgICAgICAgLy8gMSkgXCJkZWxheWVkXCIsIDIpIFwiaW5pdGlhbCByZW5kZXJcIiwgMykgXCJyZXRyeVwiLlxuICAgICAgICAvL1xuICAgICAgICAvLyBXZSB3YW50IHRvIGVuc3VyZSB0aGF0IGEgXCJidXN5XCIgc3RhdGUgZG9lc24ndCBnZXQgZm9yY2UgY29tbWl0dGVkLiBXZSB3YW50IHRvXG4gICAgICAgIC8vIGVuc3VyZSB0aGF0IG5ldyBpbml0aWFsIGxvYWRpbmcgc3RhdGVzIGNhbiBjb21taXQgYXMgc29vbiBhcyBwb3NzaWJsZS5cblxuXG4gICAgICAgIGF0dGFjaFBpbmdMaXN0ZW5lcihyb290LCB3YWtlYWJsZSwgcm9vdFJlbmRlckxhbmVzKTtcbiAgICAgICAgX3dvcmtJblByb2dyZXNzLmZsYWdzIHw9IFNob3VsZENhcHR1cmU7XG4gICAgICAgIF93b3JrSW5Qcm9ncmVzcy5sYW5lcyA9IHJvb3RSZW5kZXJMYW5lcztcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSAvLyBUaGlzIGJvdW5kYXJ5IGFscmVhZHkgY2FwdHVyZWQgZHVyaW5nIHRoaXMgcmVuZGVyLiBDb250aW51ZSB0byB0aGUgbmV4dFxuICAgICAgLy8gYm91bmRhcnkuXG5cblxuICAgICAgX3dvcmtJblByb2dyZXNzID0gX3dvcmtJblByb2dyZXNzLnJldHVybjtcbiAgICB9IHdoaWxlIChfd29ya0luUHJvZ3Jlc3MgIT09IG51bGwpOyAvLyBObyBib3VuZGFyeSB3YXMgZm91bmQuIEZhbGx0aHJvdWdoIHRvIGVycm9yIG1vZGUuXG4gICAgLy8gVE9ETzogVXNlIGludmFyaWFudCBzbyB0aGUgbWVzc2FnZSBpcyBzdHJpcHBlZCBpbiBwcm9kP1xuXG5cbiAgICB2YWx1ZSA9IG5ldyBFcnJvcigoZ2V0Q29tcG9uZW50TmFtZShzb3VyY2VGaWJlci50eXBlKSB8fCAnQSBSZWFjdCBjb21wb25lbnQnKSArICcgc3VzcGVuZGVkIHdoaWxlIHJlbmRlcmluZywgYnV0IG5vIGZhbGxiYWNrIFVJIHdhcyBzcGVjaWZpZWQuXFxuJyArICdcXG4nICsgJ0FkZCBhIDxTdXNwZW5zZSBmYWxsYmFjaz0uLi4+IGNvbXBvbmVudCBoaWdoZXIgaW4gdGhlIHRyZWUgdG8gJyArICdwcm92aWRlIGEgbG9hZGluZyBpbmRpY2F0b3Igb3IgcGxhY2Vob2xkZXIgdG8gZGlzcGxheS4nKTtcbiAgfSAvLyBXZSBkaWRuJ3QgZmluZCBhIGJvdW5kYXJ5IHRoYXQgY291bGQgaGFuZGxlIHRoaXMgdHlwZSBvZiBleGNlcHRpb24uIFN0YXJ0XG4gIC8vIG92ZXIgYW5kIHRyYXZlcnNlIHBhcmVudCBwYXRoIGFnYWluLCB0aGlzIHRpbWUgdHJlYXRpbmcgdGhlIGV4Y2VwdGlvblxuICAvLyBhcyBhbiBlcnJvci5cblxuXG4gIHJlbmRlckRpZEVycm9yKCk7XG4gIHZhbHVlID0gY3JlYXRlQ2FwdHVyZWRWYWx1ZSh2YWx1ZSwgc291cmNlRmliZXIpO1xuICB2YXIgd29ya0luUHJvZ3Jlc3MgPSByZXR1cm5GaWJlcjtcblxuICBkbyB7XG4gICAgc3dpdGNoICh3b3JrSW5Qcm9ncmVzcy50YWcpIHtcbiAgICAgIGNhc2UgSG9zdFJvb3Q6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgX2Vycm9ySW5mbyA9IHZhbHVlO1xuICAgICAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IFNob3VsZENhcHR1cmU7XG4gICAgICAgICAgdmFyIGxhbmUgPSBwaWNrQXJiaXRyYXJ5TGFuZShyb290UmVuZGVyTGFuZXMpO1xuICAgICAgICAgIHdvcmtJblByb2dyZXNzLmxhbmVzID0gbWVyZ2VMYW5lcyh3b3JrSW5Qcm9ncmVzcy5sYW5lcywgbGFuZSk7XG5cbiAgICAgICAgICB2YXIgX3VwZGF0ZSA9IGNyZWF0ZVJvb3RFcnJvclVwZGF0ZSh3b3JrSW5Qcm9ncmVzcywgX2Vycm9ySW5mbywgbGFuZSk7XG5cbiAgICAgICAgICBlbnF1ZXVlQ2FwdHVyZWRVcGRhdGUod29ya0luUHJvZ3Jlc3MsIF91cGRhdGUpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIENsYXNzQ29tcG9uZW50OlxuICAgICAgICAvLyBDYXB0dXJlIGFuZCByZXRyeVxuICAgICAgICB2YXIgZXJyb3JJbmZvID0gdmFsdWU7XG4gICAgICAgIHZhciBjdG9yID0gd29ya0luUHJvZ3Jlc3MudHlwZTtcbiAgICAgICAgdmFyIGluc3RhbmNlID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuXG4gICAgICAgIGlmICgod29ya0luUHJvZ3Jlc3MuZmxhZ3MgJiBEaWRDYXB0dXJlKSA9PT0gTm9GbGFncyAmJiAodHlwZW9mIGN0b3IuZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yID09PSAnZnVuY3Rpb24nIHx8IGluc3RhbmNlICE9PSBudWxsICYmIHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnREaWRDYXRjaCA9PT0gJ2Z1bmN0aW9uJyAmJiAhaXNBbHJlYWR5RmFpbGVkTGVnYWN5RXJyb3JCb3VuZGFyeShpbnN0YW5jZSkpKSB7XG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gU2hvdWxkQ2FwdHVyZTtcblxuICAgICAgICAgIHZhciBfbGFuZSA9IHBpY2tBcmJpdHJhcnlMYW5lKHJvb3RSZW5kZXJMYW5lcyk7XG5cbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5sYW5lcyA9IG1lcmdlTGFuZXMod29ya0luUHJvZ3Jlc3MubGFuZXMsIF9sYW5lKTsgLy8gU2NoZWR1bGUgdGhlIGVycm9yIGJvdW5kYXJ5IHRvIHJlLXJlbmRlciB1c2luZyB1cGRhdGVkIHN0YXRlXG5cbiAgICAgICAgICB2YXIgX3VwZGF0ZTIgPSBjcmVhdGVDbGFzc0Vycm9yVXBkYXRlKHdvcmtJblByb2dyZXNzLCBlcnJvckluZm8sIF9sYW5lKTtcblxuICAgICAgICAgIGVucXVldWVDYXB0dXJlZFVwZGF0ZSh3b3JrSW5Qcm9ncmVzcywgX3VwZGF0ZTIpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIHdvcmtJblByb2dyZXNzID0gd29ya0luUHJvZ3Jlc3MucmV0dXJuO1xuICB9IHdoaWxlICh3b3JrSW5Qcm9ncmVzcyAhPT0gbnVsbCk7XG59XG5cbnZhciBkaWRXYXJuQWJvdXRVbmRlZmluZWRTbmFwc2hvdEJlZm9yZVVwZGF0ZSA9IG51bGw7XG5cbntcbiAgZGlkV2FybkFib3V0VW5kZWZpbmVkU25hcHNob3RCZWZvcmVVcGRhdGUgPSBuZXcgU2V0KCk7XG59XG5cbnZhciBQb3NzaWJseVdlYWtTZXQgPSB0eXBlb2YgV2Vha1NldCA9PT0gJ2Z1bmN0aW9uJyA/IFdlYWtTZXQgOiBTZXQ7XG5cbnZhciBjYWxsQ29tcG9uZW50V2lsbFVubW91bnRXaXRoVGltZXIgPSBmdW5jdGlvbiAoY3VycmVudCwgaW5zdGFuY2UpIHtcbiAgaW5zdGFuY2UucHJvcHMgPSBjdXJyZW50Lm1lbW9pemVkUHJvcHM7XG4gIGluc3RhbmNlLnN0YXRlID0gY3VycmVudC5tZW1vaXplZFN0YXRlO1xuXG4gIHtcbiAgICBpbnN0YW5jZS5jb21wb25lbnRXaWxsVW5tb3VudCgpO1xuICB9XG59OyAvLyBDYXB0dXJlIGVycm9ycyBzbyB0aGV5IGRvbid0IGludGVycnVwdCB1bm1vdW50aW5nLlxuXG5cbmZ1bmN0aW9uIHNhZmVseUNhbGxDb21wb25lbnRXaWxsVW5tb3VudChjdXJyZW50LCBpbnN0YW5jZSkge1xuICB7XG4gICAgaW52b2tlR3VhcmRlZENhbGxiYWNrKG51bGwsIGNhbGxDb21wb25lbnRXaWxsVW5tb3VudFdpdGhUaW1lciwgbnVsbCwgY3VycmVudCwgaW5zdGFuY2UpO1xuXG4gICAgaWYgKGhhc0NhdWdodEVycm9yKCkpIHtcbiAgICAgIHZhciB1bm1vdW50RXJyb3IgPSBjbGVhckNhdWdodEVycm9yKCk7XG4gICAgICBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihjdXJyZW50LCB1bm1vdW50RXJyb3IpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBzYWZlbHlEZXRhY2hSZWYoY3VycmVudCkge1xuICB2YXIgcmVmID0gY3VycmVudC5yZWY7XG5cbiAgaWYgKHJlZiAhPT0gbnVsbCkge1xuICAgIGlmICh0eXBlb2YgcmVmID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB7XG4gICAgICAgIGludm9rZUd1YXJkZWRDYWxsYmFjayhudWxsLCByZWYsIG51bGwsIG51bGwpO1xuXG4gICAgICAgIGlmIChoYXNDYXVnaHRFcnJvcigpKSB7XG4gICAgICAgICAgdmFyIHJlZkVycm9yID0gY2xlYXJDYXVnaHRFcnJvcigpO1xuICAgICAgICAgIGNhcHR1cmVDb21taXRQaGFzZUVycm9yKGN1cnJlbnQsIHJlZkVycm9yKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZWYuY3VycmVudCA9IG51bGw7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHNhZmVseUNhbGxEZXN0cm95KGN1cnJlbnQsIGRlc3Ryb3kpIHtcbiAge1xuICAgIGludm9rZUd1YXJkZWRDYWxsYmFjayhudWxsLCBkZXN0cm95LCBudWxsKTtcblxuICAgIGlmIChoYXNDYXVnaHRFcnJvcigpKSB7XG4gICAgICB2YXIgZXJyb3IgPSBjbGVhckNhdWdodEVycm9yKCk7XG4gICAgICBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihjdXJyZW50LCBlcnJvcik7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNvbW1pdEJlZm9yZU11dGF0aW9uTGlmZUN5Y2xlcyhjdXJyZW50LCBmaW5pc2hlZFdvcmspIHtcbiAgc3dpdGNoIChmaW5pc2hlZFdvcmsudGFnKSB7XG4gICAgY2FzZSBGdW5jdGlvbkNvbXBvbmVudDpcbiAgICBjYXNlIEZvcndhcmRSZWY6XG4gICAgY2FzZSBTaW1wbGVNZW1vQ29tcG9uZW50OlxuICAgIGNhc2UgQmxvY2s6XG4gICAgICB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgIGNhc2UgQ2xhc3NDb21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIGlmIChmaW5pc2hlZFdvcmsuZmxhZ3MgJiBTbmFwc2hvdCkge1xuICAgICAgICAgIGlmIChjdXJyZW50ICE9PSBudWxsKSB7XG4gICAgICAgICAgICB2YXIgcHJldlByb3BzID0gY3VycmVudC5tZW1vaXplZFByb3BzO1xuICAgICAgICAgICAgdmFyIHByZXZTdGF0ZSA9IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZTtcbiAgICAgICAgICAgIHZhciBpbnN0YW5jZSA9IGZpbmlzaGVkV29yay5zdGF0ZU5vZGU7IC8vIFdlIGNvdWxkIHVwZGF0ZSBpbnN0YW5jZSBwcm9wcyBhbmQgc3RhdGUgaGVyZSxcbiAgICAgICAgICAgIC8vIGJ1dCBpbnN0ZWFkIHdlIHJlbHkgb24gdGhlbSBiZWluZyBzZXQgZHVyaW5nIGxhc3QgcmVuZGVyLlxuICAgICAgICAgICAgLy8gVE9ETzogcmV2aXNpdCB0aGlzIHdoZW4gd2UgaW1wbGVtZW50IHJlc3VtaW5nLlxuXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGlmIChmaW5pc2hlZFdvcmsudHlwZSA9PT0gZmluaXNoZWRXb3JrLmVsZW1lbnRUeXBlICYmICFkaWRXYXJuQWJvdXRSZWFzc2lnbmluZ1Byb3BzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGluc3RhbmNlLnByb3BzICE9PSBmaW5pc2hlZFdvcmsubWVtb2l6ZWRQcm9wcykge1xuICAgICAgICAgICAgICAgICAgZXJyb3IoJ0V4cGVjdGVkICVzIHByb3BzIHRvIG1hdGNoIG1lbW9pemVkIHByb3BzIGJlZm9yZSAnICsgJ2dldFNuYXBzaG90QmVmb3JlVXBkYXRlLiAnICsgJ1RoaXMgbWlnaHQgZWl0aGVyIGJlIGJlY2F1c2Ugb2YgYSBidWcgaW4gUmVhY3QsIG9yIGJlY2F1c2UgJyArICdhIGNvbXBvbmVudCByZWFzc2lnbnMgaXRzIG93biBgdGhpcy5wcm9wc2AuICcgKyAnUGxlYXNlIGZpbGUgYW4gaXNzdWUuJywgZ2V0Q29tcG9uZW50TmFtZShmaW5pc2hlZFdvcmsudHlwZSkgfHwgJ2luc3RhbmNlJyk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGluc3RhbmNlLnN0YXRlICE9PSBmaW5pc2hlZFdvcmsubWVtb2l6ZWRTdGF0ZSkge1xuICAgICAgICAgICAgICAgICAgZXJyb3IoJ0V4cGVjdGVkICVzIHN0YXRlIHRvIG1hdGNoIG1lbW9pemVkIHN0YXRlIGJlZm9yZSAnICsgJ2dldFNuYXBzaG90QmVmb3JlVXBkYXRlLiAnICsgJ1RoaXMgbWlnaHQgZWl0aGVyIGJlIGJlY2F1c2Ugb2YgYSBidWcgaW4gUmVhY3QsIG9yIGJlY2F1c2UgJyArICdhIGNvbXBvbmVudCByZWFzc2lnbnMgaXRzIG93biBgdGhpcy5zdGF0ZWAuICcgKyAnUGxlYXNlIGZpbGUgYW4gaXNzdWUuJywgZ2V0Q29tcG9uZW50TmFtZShmaW5pc2hlZFdvcmsudHlwZSkgfHwgJ2luc3RhbmNlJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBzbmFwc2hvdCA9IGluc3RhbmNlLmdldFNuYXBzaG90QmVmb3JlVXBkYXRlKGZpbmlzaGVkV29yay5lbGVtZW50VHlwZSA9PT0gZmluaXNoZWRXb3JrLnR5cGUgPyBwcmV2UHJvcHMgOiByZXNvbHZlRGVmYXVsdFByb3BzKGZpbmlzaGVkV29yay50eXBlLCBwcmV2UHJvcHMpLCBwcmV2U3RhdGUpO1xuXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHZhciBkaWRXYXJuU2V0ID0gZGlkV2FybkFib3V0VW5kZWZpbmVkU25hcHNob3RCZWZvcmVVcGRhdGU7XG5cbiAgICAgICAgICAgICAgaWYgKHNuYXBzaG90ID09PSB1bmRlZmluZWQgJiYgIWRpZFdhcm5TZXQuaGFzKGZpbmlzaGVkV29yay50eXBlKSkge1xuICAgICAgICAgICAgICAgIGRpZFdhcm5TZXQuYWRkKGZpbmlzaGVkV29yay50eXBlKTtcblxuICAgICAgICAgICAgICAgIGVycm9yKCclcy5nZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSgpOiBBIHNuYXBzaG90IHZhbHVlIChvciBudWxsKSAnICsgJ211c3QgYmUgcmV0dXJuZWQuIFlvdSBoYXZlIHJldHVybmVkIHVuZGVmaW5lZC4nLCBnZXRDb21wb25lbnROYW1lKGZpbmlzaGVkV29yay50eXBlKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaW5zdGFuY2UuX19yZWFjdEludGVybmFsU25hcHNob3RCZWZvcmVVcGRhdGUgPSBzbmFwc2hvdDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICBjYXNlIEhvc3RSb290OlxuICAgICAge1xuICAgICAgICB7XG4gICAgICAgICAgaWYgKGZpbmlzaGVkV29yay5mbGFncyAmIFNuYXBzaG90KSB7XG4gICAgICAgICAgICB2YXIgcm9vdCA9IGZpbmlzaGVkV29yay5zdGF0ZU5vZGU7XG4gICAgICAgICAgICBjbGVhckNvbnRhaW5lcihyb290LmNvbnRhaW5lckluZm8pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICBjYXNlIEhvc3RUZXh0OlxuICAgIGNhc2UgSG9zdFBvcnRhbDpcbiAgICBjYXNlIEluY29tcGxldGVDbGFzc0NvbXBvbmVudDpcbiAgICAgIC8vIE5vdGhpbmcgdG8gZG8gZm9yIHRoZXNlIGNvbXBvbmVudCB0eXBlc1xuICAgICAgcmV0dXJuO1xuICB9XG5cbiAge1xuICAgIHtcbiAgICAgIHRocm93IEVycm9yKCBcIlRoaXMgdW5pdCBvZiB3b3JrIHRhZyBzaG91bGQgbm90IGhhdmUgc2lkZS1lZmZlY3RzLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiICk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNvbW1pdEhvb2tFZmZlY3RMaXN0VW5tb3VudCh0YWcsIGZpbmlzaGVkV29yaykge1xuICB2YXIgdXBkYXRlUXVldWUgPSBmaW5pc2hlZFdvcmsudXBkYXRlUXVldWU7XG4gIHZhciBsYXN0RWZmZWN0ID0gdXBkYXRlUXVldWUgIT09IG51bGwgPyB1cGRhdGVRdWV1ZS5sYXN0RWZmZWN0IDogbnVsbDtcblxuICBpZiAobGFzdEVmZmVjdCAhPT0gbnVsbCkge1xuICAgIHZhciBmaXJzdEVmZmVjdCA9IGxhc3RFZmZlY3QubmV4dDtcbiAgICB2YXIgZWZmZWN0ID0gZmlyc3RFZmZlY3Q7XG5cbiAgICBkbyB7XG4gICAgICBpZiAoKGVmZmVjdC50YWcgJiB0YWcpID09PSB0YWcpIHtcbiAgICAgICAgLy8gVW5tb3VudFxuICAgICAgICB2YXIgZGVzdHJveSA9IGVmZmVjdC5kZXN0cm95O1xuICAgICAgICBlZmZlY3QuZGVzdHJveSA9IHVuZGVmaW5lZDtcblxuICAgICAgICBpZiAoZGVzdHJveSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgZGVzdHJveSgpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGVmZmVjdCA9IGVmZmVjdC5uZXh0O1xuICAgIH0gd2hpbGUgKGVmZmVjdCAhPT0gZmlyc3RFZmZlY3QpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNvbW1pdEhvb2tFZmZlY3RMaXN0TW91bnQodGFnLCBmaW5pc2hlZFdvcmspIHtcbiAgdmFyIHVwZGF0ZVF1ZXVlID0gZmluaXNoZWRXb3JrLnVwZGF0ZVF1ZXVlO1xuICB2YXIgbGFzdEVmZmVjdCA9IHVwZGF0ZVF1ZXVlICE9PSBudWxsID8gdXBkYXRlUXVldWUubGFzdEVmZmVjdCA6IG51bGw7XG5cbiAgaWYgKGxhc3RFZmZlY3QgIT09IG51bGwpIHtcbiAgICB2YXIgZmlyc3RFZmZlY3QgPSBsYXN0RWZmZWN0Lm5leHQ7XG4gICAgdmFyIGVmZmVjdCA9IGZpcnN0RWZmZWN0O1xuXG4gICAgZG8ge1xuICAgICAgaWYgKChlZmZlY3QudGFnICYgdGFnKSA9PT0gdGFnKSB7XG4gICAgICAgIC8vIE1vdW50XG4gICAgICAgIHZhciBjcmVhdGUgPSBlZmZlY3QuY3JlYXRlO1xuICAgICAgICBlZmZlY3QuZGVzdHJveSA9IGNyZWF0ZSgpO1xuXG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgZGVzdHJveSA9IGVmZmVjdC5kZXN0cm95O1xuXG4gICAgICAgICAgaWYgKGRlc3Ryb3kgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgZGVzdHJveSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdmFyIGFkZGVuZHVtID0gdm9pZCAwO1xuXG4gICAgICAgICAgICBpZiAoZGVzdHJveSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICBhZGRlbmR1bSA9ICcgWW91IHJldHVybmVkIG51bGwuIElmIHlvdXIgZWZmZWN0IGRvZXMgbm90IHJlcXVpcmUgY2xlYW4gJyArICd1cCwgcmV0dXJuIHVuZGVmaW5lZCAob3Igbm90aGluZykuJztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGRlc3Ryb3kudGhlbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICBhZGRlbmR1bSA9ICdcXG5cXG5JdCBsb29rcyBsaWtlIHlvdSB3cm90ZSB1c2VFZmZlY3QoYXN5bmMgKCkgPT4gLi4uKSBvciByZXR1cm5lZCBhIFByb21pc2UuICcgKyAnSW5zdGVhZCwgd3JpdGUgdGhlIGFzeW5jIGZ1bmN0aW9uIGluc2lkZSB5b3VyIGVmZmVjdCAnICsgJ2FuZCBjYWxsIGl0IGltbWVkaWF0ZWx5OlxcblxcbicgKyAndXNlRWZmZWN0KCgpID0+IHtcXG4nICsgJyAgYXN5bmMgZnVuY3Rpb24gZmV0Y2hEYXRhKCkge1xcbicgKyAnICAgIC8vIFlvdSBjYW4gYXdhaXQgaGVyZVxcbicgKyAnICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgTXlBUEkuZ2V0RGF0YShzb21lSWQpO1xcbicgKyAnICAgIC8vIC4uLlxcbicgKyAnICB9XFxuJyArICcgIGZldGNoRGF0YSgpO1xcbicgKyBcIn0sIFtzb21lSWRdKTsgLy8gT3IgW10gaWYgZWZmZWN0IGRvZXNuJ3QgbmVlZCBwcm9wcyBvciBzdGF0ZVxcblxcblwiICsgJ0xlYXJuIG1vcmUgYWJvdXQgZGF0YSBmZXRjaGluZyB3aXRoIEhvb2tzOiBodHRwczovL3JlYWN0anMub3JnL2xpbmsvaG9va3MtZGF0YS1mZXRjaGluZyc7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBhZGRlbmR1bSA9ICcgWW91IHJldHVybmVkOiAnICsgZGVzdHJveTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZXJyb3IoJ0FuIGVmZmVjdCBmdW5jdGlvbiBtdXN0IG5vdCByZXR1cm4gYW55dGhpbmcgYmVzaWRlcyBhIGZ1bmN0aW9uLCAnICsgJ3doaWNoIGlzIHVzZWQgZm9yIGNsZWFuLXVwLiVzJywgYWRkZW5kdW0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBlZmZlY3QgPSBlZmZlY3QubmV4dDtcbiAgICB9IHdoaWxlIChlZmZlY3QgIT09IGZpcnN0RWZmZWN0KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzY2hlZHVsZVBhc3NpdmVFZmZlY3RzKGZpbmlzaGVkV29yaykge1xuICB2YXIgdXBkYXRlUXVldWUgPSBmaW5pc2hlZFdvcmsudXBkYXRlUXVldWU7XG4gIHZhciBsYXN0RWZmZWN0ID0gdXBkYXRlUXVldWUgIT09IG51bGwgPyB1cGRhdGVRdWV1ZS5sYXN0RWZmZWN0IDogbnVsbDtcblxuICBpZiAobGFzdEVmZmVjdCAhPT0gbnVsbCkge1xuICAgIHZhciBmaXJzdEVmZmVjdCA9IGxhc3RFZmZlY3QubmV4dDtcbiAgICB2YXIgZWZmZWN0ID0gZmlyc3RFZmZlY3Q7XG5cbiAgICBkbyB7XG4gICAgICB2YXIgX2VmZmVjdCA9IGVmZmVjdCxcbiAgICAgICAgICBuZXh0ID0gX2VmZmVjdC5uZXh0LFxuICAgICAgICAgIHRhZyA9IF9lZmZlY3QudGFnO1xuXG4gICAgICBpZiAoKHRhZyAmIFBhc3NpdmUkMSkgIT09IE5vRmxhZ3MkMSAmJiAodGFnICYgSGFzRWZmZWN0KSAhPT0gTm9GbGFncyQxKSB7XG4gICAgICAgIGVucXVldWVQZW5kaW5nUGFzc2l2ZUhvb2tFZmZlY3RVbm1vdW50KGZpbmlzaGVkV29yaywgZWZmZWN0KTtcbiAgICAgICAgZW5xdWV1ZVBlbmRpbmdQYXNzaXZlSG9va0VmZmVjdE1vdW50KGZpbmlzaGVkV29yaywgZWZmZWN0KTtcbiAgICAgIH1cblxuICAgICAgZWZmZWN0ID0gbmV4dDtcbiAgICB9IHdoaWxlIChlZmZlY3QgIT09IGZpcnN0RWZmZWN0KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjb21taXRMaWZlQ3ljbGVzKGZpbmlzaGVkUm9vdCwgY3VycmVudCwgZmluaXNoZWRXb3JrLCBjb21taXR0ZWRMYW5lcykge1xuICBzd2l0Y2ggKGZpbmlzaGVkV29yay50YWcpIHtcbiAgICBjYXNlIEZ1bmN0aW9uQ29tcG9uZW50OlxuICAgIGNhc2UgRm9yd2FyZFJlZjpcbiAgICBjYXNlIFNpbXBsZU1lbW9Db21wb25lbnQ6XG4gICAgY2FzZSBCbG9jazpcbiAgICAgIHtcbiAgICAgICAgLy8gQXQgdGhpcyBwb2ludCBsYXlvdXQgZWZmZWN0cyBoYXZlIGFscmVhZHkgYmVlbiBkZXN0cm95ZWQgKGR1cmluZyBtdXRhdGlvbiBwaGFzZSkuXG4gICAgICAgIC8vIFRoaXMgaXMgZG9uZSB0byBwcmV2ZW50IHNpYmxpbmcgY29tcG9uZW50IGVmZmVjdHMgZnJvbSBpbnRlcmZlcmluZyB3aXRoIGVhY2ggb3RoZXIsXG4gICAgICAgIC8vIGUuZy4gYSBkZXN0cm95IGZ1bmN0aW9uIGluIG9uZSBjb21wb25lbnQgc2hvdWxkIG5ldmVyIG92ZXJyaWRlIGEgcmVmIHNldFxuICAgICAgICAvLyBieSBhIGNyZWF0ZSBmdW5jdGlvbiBpbiBhbm90aGVyIGNvbXBvbmVudCBkdXJpbmcgdGhlIHNhbWUgY29tbWl0LlxuICAgICAgICB7XG4gICAgICAgICAgY29tbWl0SG9va0VmZmVjdExpc3RNb3VudChMYXlvdXQgfCBIYXNFZmZlY3QsIGZpbmlzaGVkV29yayk7XG4gICAgICAgIH1cblxuICAgICAgICBzY2hlZHVsZVBhc3NpdmVFZmZlY3RzKGZpbmlzaGVkV29yayk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgIGNhc2UgQ2xhc3NDb21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIHZhciBpbnN0YW5jZSA9IGZpbmlzaGVkV29yay5zdGF0ZU5vZGU7XG5cbiAgICAgICAgaWYgKGZpbmlzaGVkV29yay5mbGFncyAmIFVwZGF0ZSkge1xuICAgICAgICAgIGlmIChjdXJyZW50ID09PSBudWxsKSB7XG4gICAgICAgICAgICAvLyBXZSBjb3VsZCB1cGRhdGUgaW5zdGFuY2UgcHJvcHMgYW5kIHN0YXRlIGhlcmUsXG4gICAgICAgICAgICAvLyBidXQgaW5zdGVhZCB3ZSByZWx5IG9uIHRoZW0gYmVpbmcgc2V0IGR1cmluZyBsYXN0IHJlbmRlci5cbiAgICAgICAgICAgIC8vIFRPRE86IHJldmlzaXQgdGhpcyB3aGVuIHdlIGltcGxlbWVudCByZXN1bWluZy5cbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgaWYgKGZpbmlzaGVkV29yay50eXBlID09PSBmaW5pc2hlZFdvcmsuZWxlbWVudFR5cGUgJiYgIWRpZFdhcm5BYm91dFJlYXNzaWduaW5nUHJvcHMpIHtcbiAgICAgICAgICAgICAgICBpZiAoaW5zdGFuY2UucHJvcHMgIT09IGZpbmlzaGVkV29yay5tZW1vaXplZFByb3BzKSB7XG4gICAgICAgICAgICAgICAgICBlcnJvcignRXhwZWN0ZWQgJXMgcHJvcHMgdG8gbWF0Y2ggbWVtb2l6ZWQgcHJvcHMgYmVmb3JlICcgKyAnY29tcG9uZW50RGlkTW91bnQuICcgKyAnVGhpcyBtaWdodCBlaXRoZXIgYmUgYmVjYXVzZSBvZiBhIGJ1ZyBpbiBSZWFjdCwgb3IgYmVjYXVzZSAnICsgJ2EgY29tcG9uZW50IHJlYXNzaWducyBpdHMgb3duIGB0aGlzLnByb3BzYC4gJyArICdQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nLCBnZXRDb21wb25lbnROYW1lKGZpbmlzaGVkV29yay50eXBlKSB8fCAnaW5zdGFuY2UnKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoaW5zdGFuY2Uuc3RhdGUgIT09IGZpbmlzaGVkV29yay5tZW1vaXplZFN0YXRlKSB7XG4gICAgICAgICAgICAgICAgICBlcnJvcignRXhwZWN0ZWQgJXMgc3RhdGUgdG8gbWF0Y2ggbWVtb2l6ZWQgc3RhdGUgYmVmb3JlICcgKyAnY29tcG9uZW50RGlkTW91bnQuICcgKyAnVGhpcyBtaWdodCBlaXRoZXIgYmUgYmVjYXVzZSBvZiBhIGJ1ZyBpbiBSZWFjdCwgb3IgYmVjYXVzZSAnICsgJ2EgY29tcG9uZW50IHJlYXNzaWducyBpdHMgb3duIGB0aGlzLnN0YXRlYC4gJyArICdQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nLCBnZXRDb21wb25lbnROYW1lKGZpbmlzaGVkV29yay50eXBlKSB8fCAnaW5zdGFuY2UnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBpbnN0YW5jZS5jb21wb25lbnREaWRNb3VudCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgcHJldlByb3BzID0gZmluaXNoZWRXb3JrLmVsZW1lbnRUeXBlID09PSBmaW5pc2hlZFdvcmsudHlwZSA/IGN1cnJlbnQubWVtb2l6ZWRQcm9wcyA6IHJlc29sdmVEZWZhdWx0UHJvcHMoZmluaXNoZWRXb3JrLnR5cGUsIGN1cnJlbnQubWVtb2l6ZWRQcm9wcyk7XG4gICAgICAgICAgICB2YXIgcHJldlN0YXRlID0gY3VycmVudC5tZW1vaXplZFN0YXRlOyAvLyBXZSBjb3VsZCB1cGRhdGUgaW5zdGFuY2UgcHJvcHMgYW5kIHN0YXRlIGhlcmUsXG4gICAgICAgICAgICAvLyBidXQgaW5zdGVhZCB3ZSByZWx5IG9uIHRoZW0gYmVpbmcgc2V0IGR1cmluZyBsYXN0IHJlbmRlci5cbiAgICAgICAgICAgIC8vIFRPRE86IHJldmlzaXQgdGhpcyB3aGVuIHdlIGltcGxlbWVudCByZXN1bWluZy5cblxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBpZiAoZmluaXNoZWRXb3JrLnR5cGUgPT09IGZpbmlzaGVkV29yay5lbGVtZW50VHlwZSAmJiAhZGlkV2FybkFib3V0UmVhc3NpZ25pbmdQcm9wcykge1xuICAgICAgICAgICAgICAgIGlmIChpbnN0YW5jZS5wcm9wcyAhPT0gZmluaXNoZWRXb3JrLm1lbW9pemVkUHJvcHMpIHtcbiAgICAgICAgICAgICAgICAgIGVycm9yKCdFeHBlY3RlZCAlcyBwcm9wcyB0byBtYXRjaCBtZW1vaXplZCBwcm9wcyBiZWZvcmUgJyArICdjb21wb25lbnREaWRVcGRhdGUuICcgKyAnVGhpcyBtaWdodCBlaXRoZXIgYmUgYmVjYXVzZSBvZiBhIGJ1ZyBpbiBSZWFjdCwgb3IgYmVjYXVzZSAnICsgJ2EgY29tcG9uZW50IHJlYXNzaWducyBpdHMgb3duIGB0aGlzLnByb3BzYC4gJyArICdQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nLCBnZXRDb21wb25lbnROYW1lKGZpbmlzaGVkV29yay50eXBlKSB8fCAnaW5zdGFuY2UnKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoaW5zdGFuY2Uuc3RhdGUgIT09IGZpbmlzaGVkV29yay5tZW1vaXplZFN0YXRlKSB7XG4gICAgICAgICAgICAgICAgICBlcnJvcignRXhwZWN0ZWQgJXMgc3RhdGUgdG8gbWF0Y2ggbWVtb2l6ZWQgc3RhdGUgYmVmb3JlICcgKyAnY29tcG9uZW50RGlkVXBkYXRlLiAnICsgJ1RoaXMgbWlnaHQgZWl0aGVyIGJlIGJlY2F1c2Ugb2YgYSBidWcgaW4gUmVhY3QsIG9yIGJlY2F1c2UgJyArICdhIGNvbXBvbmVudCByZWFzc2lnbnMgaXRzIG93biBgdGhpcy5zdGF0ZWAuICcgKyAnUGxlYXNlIGZpbGUgYW4gaXNzdWUuJywgZ2V0Q29tcG9uZW50TmFtZShmaW5pc2hlZFdvcmsudHlwZSkgfHwgJ2luc3RhbmNlJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgaW5zdGFuY2UuY29tcG9uZW50RGlkVXBkYXRlKHByZXZQcm9wcywgcHJldlN0YXRlLCBpbnN0YW5jZS5fX3JlYWN0SW50ZXJuYWxTbmFwc2hvdEJlZm9yZVVwZGF0ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IC8vIFRPRE86IEkgdGhpbmsgdGhpcyBpcyBub3cgYWx3YXlzIG5vbi1udWxsIGJ5IHRoZSB0aW1lIGl0IHJlYWNoZXMgdGhlXG4gICAgICAgIC8vIGNvbW1pdCBwaGFzZS4gQ29uc2lkZXIgcmVtb3ZpbmcgdGhlIHR5cGUgY2hlY2suXG5cblxuICAgICAgICB2YXIgdXBkYXRlUXVldWUgPSBmaW5pc2hlZFdvcmsudXBkYXRlUXVldWU7XG5cbiAgICAgICAgaWYgKHVwZGF0ZVF1ZXVlICE9PSBudWxsKSB7XG4gICAgICAgICAge1xuICAgICAgICAgICAgaWYgKGZpbmlzaGVkV29yay50eXBlID09PSBmaW5pc2hlZFdvcmsuZWxlbWVudFR5cGUgJiYgIWRpZFdhcm5BYm91dFJlYXNzaWduaW5nUHJvcHMpIHtcbiAgICAgICAgICAgICAgaWYgKGluc3RhbmNlLnByb3BzICE9PSBmaW5pc2hlZFdvcmsubWVtb2l6ZWRQcm9wcykge1xuICAgICAgICAgICAgICAgIGVycm9yKCdFeHBlY3RlZCAlcyBwcm9wcyB0byBtYXRjaCBtZW1vaXplZCBwcm9wcyBiZWZvcmUgJyArICdwcm9jZXNzaW5nIHRoZSB1cGRhdGUgcXVldWUuICcgKyAnVGhpcyBtaWdodCBlaXRoZXIgYmUgYmVjYXVzZSBvZiBhIGJ1ZyBpbiBSZWFjdCwgb3IgYmVjYXVzZSAnICsgJ2EgY29tcG9uZW50IHJlYXNzaWducyBpdHMgb3duIGB0aGlzLnByb3BzYC4gJyArICdQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nLCBnZXRDb21wb25lbnROYW1lKGZpbmlzaGVkV29yay50eXBlKSB8fCAnaW5zdGFuY2UnKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmIChpbnN0YW5jZS5zdGF0ZSAhPT0gZmluaXNoZWRXb3JrLm1lbW9pemVkU3RhdGUpIHtcbiAgICAgICAgICAgICAgICBlcnJvcignRXhwZWN0ZWQgJXMgc3RhdGUgdG8gbWF0Y2ggbWVtb2l6ZWQgc3RhdGUgYmVmb3JlICcgKyAncHJvY2Vzc2luZyB0aGUgdXBkYXRlIHF1ZXVlLiAnICsgJ1RoaXMgbWlnaHQgZWl0aGVyIGJlIGJlY2F1c2Ugb2YgYSBidWcgaW4gUmVhY3QsIG9yIGJlY2F1c2UgJyArICdhIGNvbXBvbmVudCByZWFzc2lnbnMgaXRzIG93biBgdGhpcy5zdGF0ZWAuICcgKyAnUGxlYXNlIGZpbGUgYW4gaXNzdWUuJywgZ2V0Q29tcG9uZW50TmFtZShmaW5pc2hlZFdvcmsudHlwZSkgfHwgJ2luc3RhbmNlJyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IC8vIFdlIGNvdWxkIHVwZGF0ZSBpbnN0YW5jZSBwcm9wcyBhbmQgc3RhdGUgaGVyZSxcbiAgICAgICAgICAvLyBidXQgaW5zdGVhZCB3ZSByZWx5IG9uIHRoZW0gYmVpbmcgc2V0IGR1cmluZyBsYXN0IHJlbmRlci5cbiAgICAgICAgICAvLyBUT0RPOiByZXZpc2l0IHRoaXMgd2hlbiB3ZSBpbXBsZW1lbnQgcmVzdW1pbmcuXG5cblxuICAgICAgICAgIGNvbW1pdFVwZGF0ZVF1ZXVlKGZpbmlzaGVkV29yaywgdXBkYXRlUXVldWUsIGluc3RhbmNlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgIGNhc2UgSG9zdFJvb3Q6XG4gICAgICB7XG4gICAgICAgIC8vIFRPRE86IEkgdGhpbmsgdGhpcyBpcyBub3cgYWx3YXlzIG5vbi1udWxsIGJ5IHRoZSB0aW1lIGl0IHJlYWNoZXMgdGhlXG4gICAgICAgIC8vIGNvbW1pdCBwaGFzZS4gQ29uc2lkZXIgcmVtb3ZpbmcgdGhlIHR5cGUgY2hlY2suXG4gICAgICAgIHZhciBfdXBkYXRlUXVldWUgPSBmaW5pc2hlZFdvcmsudXBkYXRlUXVldWU7XG5cbiAgICAgICAgaWYgKF91cGRhdGVRdWV1ZSAhPT0gbnVsbCkge1xuICAgICAgICAgIHZhciBfaW5zdGFuY2UgPSBudWxsO1xuXG4gICAgICAgICAgaWYgKGZpbmlzaGVkV29yay5jaGlsZCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgc3dpdGNoIChmaW5pc2hlZFdvcmsuY2hpbGQudGFnKSB7XG4gICAgICAgICAgICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICAgICAgICAgICAgICBfaW5zdGFuY2UgPSBnZXRQdWJsaWNJbnN0YW5jZShmaW5pc2hlZFdvcmsuY2hpbGQuc3RhdGVOb2RlKTtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICBjYXNlIENsYXNzQ29tcG9uZW50OlxuICAgICAgICAgICAgICAgIF9pbnN0YW5jZSA9IGZpbmlzaGVkV29yay5jaGlsZC5zdGF0ZU5vZGU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29tbWl0VXBkYXRlUXVldWUoZmluaXNoZWRXb3JrLCBfdXBkYXRlUXVldWUsIF9pbnN0YW5jZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIHZhciBfaW5zdGFuY2UyID0gZmluaXNoZWRXb3JrLnN0YXRlTm9kZTsgLy8gUmVuZGVyZXJzIG1heSBzY2hlZHVsZSB3b3JrIHRvIGJlIGRvbmUgYWZ0ZXIgaG9zdCBjb21wb25lbnRzIGFyZSBtb3VudGVkXG4gICAgICAgIC8vIChlZyBET00gcmVuZGVyZXIgbWF5IHNjaGVkdWxlIGF1dG8tZm9jdXMgZm9yIGlucHV0cyBhbmQgZm9ybSBjb250cm9scykuXG4gICAgICAgIC8vIFRoZXNlIGVmZmVjdHMgc2hvdWxkIG9ubHkgYmUgY29tbWl0dGVkIHdoZW4gY29tcG9uZW50cyBhcmUgZmlyc3QgbW91bnRlZCxcbiAgICAgICAgLy8gYWthIHdoZW4gdGhlcmUgaXMgbm8gY3VycmVudC9hbHRlcm5hdGUuXG5cbiAgICAgICAgaWYgKGN1cnJlbnQgPT09IG51bGwgJiYgZmluaXNoZWRXb3JrLmZsYWdzICYgVXBkYXRlKSB7XG4gICAgICAgICAgdmFyIHR5cGUgPSBmaW5pc2hlZFdvcmsudHlwZTtcbiAgICAgICAgICB2YXIgcHJvcHMgPSBmaW5pc2hlZFdvcmsubWVtb2l6ZWRQcm9wcztcbiAgICAgICAgICBjb21taXRNb3VudChfaW5zdGFuY2UyLCB0eXBlLCBwcm9wcyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICBjYXNlIEhvc3RUZXh0OlxuICAgICAge1xuICAgICAgICAvLyBXZSBoYXZlIG5vIGxpZmUtY3ljbGVzIGFzc29jaWF0ZWQgd2l0aCB0ZXh0LlxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICBjYXNlIEhvc3RQb3J0YWw6XG4gICAgICB7XG4gICAgICAgIC8vIFdlIGhhdmUgbm8gbGlmZS1jeWNsZXMgYXNzb2NpYXRlZCB3aXRoIHBvcnRhbHMuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgIGNhc2UgUHJvZmlsZXI6XG4gICAgICB7XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgX2ZpbmlzaGVkV29yayRtZW1vaXplMiA9IGZpbmlzaGVkV29yay5tZW1vaXplZFByb3BzLFxuICAgICAgICAgICAgICBvbkNvbW1pdCA9IF9maW5pc2hlZFdvcmskbWVtb2l6ZTIub25Db21taXQsXG4gICAgICAgICAgICAgIG9uUmVuZGVyID0gX2ZpbmlzaGVkV29yayRtZW1vaXplMi5vblJlbmRlcjtcbiAgICAgICAgICB2YXIgZWZmZWN0RHVyYXRpb24gPSBmaW5pc2hlZFdvcmsuc3RhdGVOb2RlLmVmZmVjdER1cmF0aW9uO1xuICAgICAgICAgIHZhciBjb21taXRUaW1lID0gZ2V0Q29tbWl0VGltZSgpO1xuXG4gICAgICAgICAgaWYgKHR5cGVvZiBvblJlbmRlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBvblJlbmRlcihmaW5pc2hlZFdvcmsubWVtb2l6ZWRQcm9wcy5pZCwgY3VycmVudCA9PT0gbnVsbCA/ICdtb3VudCcgOiAndXBkYXRlJywgZmluaXNoZWRXb3JrLmFjdHVhbER1cmF0aW9uLCBmaW5pc2hlZFdvcmsudHJlZUJhc2VEdXJhdGlvbiwgZmluaXNoZWRXb3JrLmFjdHVhbFN0YXJ0VGltZSwgY29tbWl0VGltZSwgZmluaXNoZWRSb290Lm1lbW9pemVkSW50ZXJhY3Rpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICBjYXNlIFN1c3BlbnNlQ29tcG9uZW50OlxuICAgICAge1xuICAgICAgICBjb21taXRTdXNwZW5zZUh5ZHJhdGlvbkNhbGxiYWNrcyhmaW5pc2hlZFJvb3QsIGZpbmlzaGVkV29yayk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgIGNhc2UgU3VzcGVuc2VMaXN0Q29tcG9uZW50OlxuICAgIGNhc2UgSW5jb21wbGV0ZUNsYXNzQ29tcG9uZW50OlxuICAgIGNhc2UgRnVuZGFtZW50YWxDb21wb25lbnQ6XG4gICAgY2FzZSBTY29wZUNvbXBvbmVudDpcbiAgICBjYXNlIE9mZnNjcmVlbkNvbXBvbmVudDpcbiAgICBjYXNlIExlZ2FjeUhpZGRlbkNvbXBvbmVudDpcbiAgICAgIHJldHVybjtcbiAgfVxuXG4gIHtcbiAgICB7XG4gICAgICB0aHJvdyBFcnJvciggXCJUaGlzIHVuaXQgb2Ygd29yayB0YWcgc2hvdWxkIG5vdCBoYXZlIHNpZGUtZWZmZWN0cy4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS5cIiApO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBoaWRlT3JVbmhpZGVBbGxDaGlsZHJlbihmaW5pc2hlZFdvcmssIGlzSGlkZGVuKSB7XG4gIHtcbiAgICAvLyBXZSBvbmx5IGhhdmUgdGhlIHRvcCBGaWJlciB0aGF0IHdhcyBpbnNlcnRlZCBidXQgd2UgbmVlZCB0byByZWN1cnNlIGRvd24gaXRzXG4gICAgLy8gY2hpbGRyZW4gdG8gZmluZCBhbGwgdGhlIHRlcm1pbmFsIG5vZGVzLlxuICAgIHZhciBub2RlID0gZmluaXNoZWRXb3JrO1xuXG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIGlmIChub2RlLnRhZyA9PT0gSG9zdENvbXBvbmVudCkge1xuICAgICAgICB2YXIgaW5zdGFuY2UgPSBub2RlLnN0YXRlTm9kZTtcblxuICAgICAgICBpZiAoaXNIaWRkZW4pIHtcbiAgICAgICAgICBoaWRlSW5zdGFuY2UoaW5zdGFuY2UpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHVuaGlkZUluc3RhbmNlKG5vZGUuc3RhdGVOb2RlLCBub2RlLm1lbW9pemVkUHJvcHMpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKG5vZGUudGFnID09PSBIb3N0VGV4dCkge1xuICAgICAgICB2YXIgX2luc3RhbmNlMyA9IG5vZGUuc3RhdGVOb2RlO1xuXG4gICAgICAgIGlmIChpc0hpZGRlbikge1xuICAgICAgICAgIGhpZGVUZXh0SW5zdGFuY2UoX2luc3RhbmNlMyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdW5oaWRlVGV4dEluc3RhbmNlKF9pbnN0YW5jZTMsIG5vZGUubWVtb2l6ZWRQcm9wcyk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoKG5vZGUudGFnID09PSBPZmZzY3JlZW5Db21wb25lbnQgfHwgbm9kZS50YWcgPT09IExlZ2FjeUhpZGRlbkNvbXBvbmVudCkgJiYgbm9kZS5tZW1vaXplZFN0YXRlICE9PSBudWxsICYmIG5vZGUgIT09IGZpbmlzaGVkV29yaykgOyBlbHNlIGlmIChub2RlLmNoaWxkICE9PSBudWxsKSB7XG4gICAgICAgIG5vZGUuY2hpbGQucmV0dXJuID0gbm9kZTtcbiAgICAgICAgbm9kZSA9IG5vZGUuY2hpbGQ7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAobm9kZSA9PT0gZmluaXNoZWRXb3JrKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgd2hpbGUgKG5vZGUuc2libGluZyA9PT0gbnVsbCkge1xuICAgICAgICBpZiAobm9kZS5yZXR1cm4gPT09IG51bGwgfHwgbm9kZS5yZXR1cm4gPT09IGZpbmlzaGVkV29yaykge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIG5vZGUgPSBub2RlLnJldHVybjtcbiAgICAgIH1cblxuICAgICAgbm9kZS5zaWJsaW5nLnJldHVybiA9IG5vZGUucmV0dXJuO1xuICAgICAgbm9kZSA9IG5vZGUuc2libGluZztcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY29tbWl0QXR0YWNoUmVmKGZpbmlzaGVkV29yaykge1xuICB2YXIgcmVmID0gZmluaXNoZWRXb3JrLnJlZjtcblxuICBpZiAocmVmICE9PSBudWxsKSB7XG4gICAgdmFyIGluc3RhbmNlID0gZmluaXNoZWRXb3JrLnN0YXRlTm9kZTtcbiAgICB2YXIgaW5zdGFuY2VUb1VzZTtcblxuICAgIHN3aXRjaCAoZmluaXNoZWRXb3JrLnRhZykge1xuICAgICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgICAgICBpbnN0YW5jZVRvVXNlID0gZ2V0UHVibGljSW5zdGFuY2UoaW5zdGFuY2UpO1xuICAgICAgICBicmVhaztcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaW5zdGFuY2VUb1VzZSA9IGluc3RhbmNlO1xuICAgIH0gLy8gTW92ZWQgb3V0c2lkZSB0byBlbnN1cmUgRENFIHdvcmtzIHdpdGggdGhpcyBmbGFnXG5cbiAgICBpZiAodHlwZW9mIHJlZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmVmKGluc3RhbmNlVG9Vc2UpO1xuICAgIH0gZWxzZSB7XG4gICAgICB7XG4gICAgICAgIGlmICghcmVmLmhhc093blByb3BlcnR5KCdjdXJyZW50JykpIHtcbiAgICAgICAgICBlcnJvcignVW5leHBlY3RlZCByZWYgb2JqZWN0IHByb3ZpZGVkIGZvciAlcy4gJyArICdVc2UgZWl0aGVyIGEgcmVmLXNldHRlciBmdW5jdGlvbiBvciBSZWFjdC5jcmVhdGVSZWYoKS4nLCBnZXRDb21wb25lbnROYW1lKGZpbmlzaGVkV29yay50eXBlKSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmVmLmN1cnJlbnQgPSBpbnN0YW5jZVRvVXNlO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjb21taXREZXRhY2hSZWYoY3VycmVudCkge1xuICB2YXIgY3VycmVudFJlZiA9IGN1cnJlbnQucmVmO1xuXG4gIGlmIChjdXJyZW50UmVmICE9PSBudWxsKSB7XG4gICAgaWYgKHR5cGVvZiBjdXJyZW50UmVmID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjdXJyZW50UmVmKG51bGwpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjdXJyZW50UmVmLmN1cnJlbnQgPSBudWxsO1xuICAgIH1cbiAgfVxufSAvLyBVc2VyLW9yaWdpbmF0aW5nIGVycm9ycyAobGlmZWN5Y2xlcyBhbmQgcmVmcykgc2hvdWxkIG5vdCBpbnRlcnJ1cHRcbi8vIGRlbGV0aW9uLCBzbyBkb24ndCBsZXQgdGhlbSB0aHJvdy4gSG9zdC1vcmlnaW5hdGluZyBlcnJvcnMgc2hvdWxkXG4vLyBpbnRlcnJ1cHQgZGVsZXRpb24sIHNvIGl0J3Mgb2theVxuXG5cbmZ1bmN0aW9uIGNvbW1pdFVubW91bnQoZmluaXNoZWRSb290LCBjdXJyZW50LCByZW5kZXJQcmlvcml0eUxldmVsKSB7XG4gIG9uQ29tbWl0VW5tb3VudChjdXJyZW50KTtcblxuICBzd2l0Y2ggKGN1cnJlbnQudGFnKSB7XG4gICAgY2FzZSBGdW5jdGlvbkNvbXBvbmVudDpcbiAgICBjYXNlIEZvcndhcmRSZWY6XG4gICAgY2FzZSBNZW1vQ29tcG9uZW50OlxuICAgIGNhc2UgU2ltcGxlTWVtb0NvbXBvbmVudDpcbiAgICBjYXNlIEJsb2NrOlxuICAgICAge1xuICAgICAgICB2YXIgdXBkYXRlUXVldWUgPSBjdXJyZW50LnVwZGF0ZVF1ZXVlO1xuXG4gICAgICAgIGlmICh1cGRhdGVRdWV1ZSAhPT0gbnVsbCkge1xuICAgICAgICAgIHZhciBsYXN0RWZmZWN0ID0gdXBkYXRlUXVldWUubGFzdEVmZmVjdDtcblxuICAgICAgICAgIGlmIChsYXN0RWZmZWN0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICB2YXIgZmlyc3RFZmZlY3QgPSBsYXN0RWZmZWN0Lm5leHQ7XG4gICAgICAgICAgICB2YXIgZWZmZWN0ID0gZmlyc3RFZmZlY3Q7XG5cbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgdmFyIF9lZmZlY3QyID0gZWZmZWN0LFxuICAgICAgICAgICAgICAgICAgZGVzdHJveSA9IF9lZmZlY3QyLmRlc3Ryb3ksXG4gICAgICAgICAgICAgICAgICB0YWcgPSBfZWZmZWN0Mi50YWc7XG5cbiAgICAgICAgICAgICAgaWYgKGRlc3Ryb3kgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGlmICgodGFnICYgUGFzc2l2ZSQxKSAhPT0gTm9GbGFncyQxKSB7XG4gICAgICAgICAgICAgICAgICBlbnF1ZXVlUGVuZGluZ1Bhc3NpdmVIb29rRWZmZWN0VW5tb3VudChjdXJyZW50LCBlZmZlY3QpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHNhZmVseUNhbGxEZXN0cm95KGN1cnJlbnQsIGRlc3Ryb3kpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGVmZmVjdCA9IGVmZmVjdC5uZXh0O1xuICAgICAgICAgICAgfSB3aGlsZSAoZWZmZWN0ICE9PSBmaXJzdEVmZmVjdCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgY2FzZSBDbGFzc0NvbXBvbmVudDpcbiAgICAgIHtcbiAgICAgICAgc2FmZWx5RGV0YWNoUmVmKGN1cnJlbnQpO1xuICAgICAgICB2YXIgaW5zdGFuY2UgPSBjdXJyZW50LnN0YXRlTm9kZTtcblxuICAgICAgICBpZiAodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFdpbGxVbm1vdW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgc2FmZWx5Q2FsbENvbXBvbmVudFdpbGxVbm1vdW50KGN1cnJlbnQsIGluc3RhbmNlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICAgIHtcbiAgICAgICAgc2FmZWx5RGV0YWNoUmVmKGN1cnJlbnQpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICBjYXNlIEhvc3RQb3J0YWw6XG4gICAgICB7XG4gICAgICAgIC8vIFRPRE86IHRoaXMgaXMgcmVjdXJzaXZlLlxuICAgICAgICAvLyBXZSBhcmUgYWxzbyBub3QgdXNpbmcgdGhpcyBwYXJlbnQgYmVjYXVzZVxuICAgICAgICAvLyB0aGUgcG9ydGFsIHdpbGwgZ2V0IHB1c2hlZCBpbW1lZGlhdGVseS5cbiAgICAgICAge1xuICAgICAgICAgIHVubW91bnRIb3N0Q29tcG9uZW50cyhmaW5pc2hlZFJvb3QsIGN1cnJlbnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgY2FzZSBGdW5kYW1lbnRhbENvbXBvbmVudDpcbiAgICAgIHtcblxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICBjYXNlIERlaHlkcmF0ZWRGcmFnbWVudDpcbiAgICAgIHtcblxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICBjYXNlIFNjb3BlQ29tcG9uZW50OlxuICAgICAge1xuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjb21taXROZXN0ZWRVbm1vdW50cyhmaW5pc2hlZFJvb3QsIHJvb3QsIHJlbmRlclByaW9yaXR5TGV2ZWwpIHtcbiAgLy8gV2hpbGUgd2UncmUgaW5zaWRlIGEgcmVtb3ZlZCBob3N0IG5vZGUgd2UgZG9uJ3Qgd2FudCB0byBjYWxsXG4gIC8vIHJlbW92ZUNoaWxkIG9uIHRoZSBpbm5lciBub2RlcyBiZWNhdXNlIHRoZXkncmUgcmVtb3ZlZCBieSB0aGUgdG9wXG4gIC8vIGNhbGwgYW55d2F5LiBXZSBhbHNvIHdhbnQgdG8gY2FsbCBjb21wb25lbnRXaWxsVW5tb3VudCBvbiBhbGxcbiAgLy8gY29tcG9zaXRlcyBiZWZvcmUgdGhpcyBob3N0IG5vZGUgaXMgcmVtb3ZlZCBmcm9tIHRoZSB0cmVlLiBUaGVyZWZvcmVcbiAgLy8gd2UgZG8gYW4gaW5uZXIgbG9vcCB3aGlsZSB3ZSdyZSBzdGlsbCBpbnNpZGUgdGhlIGhvc3Qgbm9kZS5cbiAgdmFyIG5vZGUgPSByb290O1xuXG4gIHdoaWxlICh0cnVlKSB7XG4gICAgY29tbWl0VW5tb3VudChmaW5pc2hlZFJvb3QsIG5vZGUpOyAvLyBWaXNpdCBjaGlsZHJlbiBiZWNhdXNlIHRoZXkgbWF5IGNvbnRhaW4gbW9yZSBjb21wb3NpdGUgb3IgaG9zdCBub2Rlcy5cbiAgICAvLyBTa2lwIHBvcnRhbHMgYmVjYXVzZSBjb21taXRVbm1vdW50KCkgY3VycmVudGx5IHZpc2l0cyB0aGVtIHJlY3Vyc2l2ZWx5LlxuXG4gICAgaWYgKG5vZGUuY2hpbGQgIT09IG51bGwgJiYgKCAvLyBJZiB3ZSB1c2UgbXV0YXRpb24gd2UgZHJpbGwgZG93biBpbnRvIHBvcnRhbHMgdXNpbmcgY29tbWl0VW5tb3VudCBhYm92ZS5cbiAgICAvLyBJZiB3ZSBkb24ndCB1c2UgbXV0YXRpb24gd2UgZHJpbGwgZG93biBpbnRvIHBvcnRhbHMgaGVyZSBpbnN0ZWFkLlxuICAgICBub2RlLnRhZyAhPT0gSG9zdFBvcnRhbCkpIHtcbiAgICAgIG5vZGUuY2hpbGQucmV0dXJuID0gbm9kZTtcbiAgICAgIG5vZGUgPSBub2RlLmNoaWxkO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKG5vZGUgPT09IHJvb3QpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB3aGlsZSAobm9kZS5zaWJsaW5nID09PSBudWxsKSB7XG4gICAgICBpZiAobm9kZS5yZXR1cm4gPT09IG51bGwgfHwgbm9kZS5yZXR1cm4gPT09IHJvb3QpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBub2RlID0gbm9kZS5yZXR1cm47XG4gICAgfVxuXG4gICAgbm9kZS5zaWJsaW5nLnJldHVybiA9IG5vZGUucmV0dXJuO1xuICAgIG5vZGUgPSBub2RlLnNpYmxpbmc7XG4gIH1cbn1cblxuZnVuY3Rpb24gZGV0YWNoRmliZXJNdXRhdGlvbihmaWJlcikge1xuICAvLyBDdXQgb2ZmIHRoZSByZXR1cm4gcG9pbnRlcnMgdG8gZGlzY29ubmVjdCBpdCBmcm9tIHRoZSB0cmVlLiBJZGVhbGx5LCB3ZVxuICAvLyBzaG91bGQgY2xlYXIgdGhlIGNoaWxkIHBvaW50ZXIgb2YgdGhlIHBhcmVudCBhbHRlcm5hdGUgdG8gbGV0IHRoaXNcbiAgLy8gZ2V0IEdDOmVkIGJ1dCB3ZSBkb24ndCBrbm93IHdoaWNoIGZvciBzdXJlIHdoaWNoIHBhcmVudCBpcyB0aGUgY3VycmVudFxuICAvLyBvbmUgc28gd2UnbGwgc2V0dGxlIGZvciBHQzppbmcgdGhlIHN1YnRyZWUgb2YgdGhpcyBjaGlsZC4gVGhpcyBjaGlsZFxuICAvLyBpdHNlbGYgd2lsbCBiZSBHQzplZCB3aGVuIHRoZSBwYXJlbnQgdXBkYXRlcyB0aGUgbmV4dCB0aW1lLlxuICAvLyBOb3RlOiB3ZSBjYW5ub3QgbnVsbCBvdXQgc2libGluZyBoZXJlLCBvdGhlcndpc2UgaXQgY2FuIGNhdXNlIGlzc3Vlc1xuICAvLyB3aXRoIGZpbmRET01Ob2RlIGFuZCBob3cgaXQgcmVxdWlyZXMgdGhlIHNpYmxpbmcgZmllbGQgdG8gY2Fycnkgb3V0XG4gIC8vIHRyYXZlcnNhbCBpbiBhIGxhdGVyIGVmZmVjdC4gU2VlIFBSICMxNjgyMC4gV2Ugbm93IGNsZWFyIHRoZSBzaWJsaW5nXG4gIC8vIGZpZWxkIGFmdGVyIGVmZmVjdHMsIHNlZTogZGV0YWNoRmliZXJBZnRlckVmZmVjdHMuXG4gIC8vXG4gIC8vIERvbid0IGRpc2Nvbm5lY3Qgc3RhdGVOb2RlIG5vdzsgaXQgd2lsbCBiZSBkZXRhY2hlZCBpbiBkZXRhY2hGaWJlckFmdGVyRWZmZWN0cy5cbiAgLy8gSXQgbWF5IGJlIHJlcXVpcmVkIGlmIHRoZSBjdXJyZW50IGNvbXBvbmVudCBpcyBhbiBlcnJvciBib3VuZGFyeSxcbiAgLy8gYW5kIG9uZSBvZiBpdHMgZGVzY2VuZGFudHMgdGhyb3dzIHdoaWxlIHVubW91bnRpbmcgYSBwYXNzaXZlIGVmZmVjdC5cbiAgZmliZXIuYWx0ZXJuYXRlID0gbnVsbDtcbiAgZmliZXIuY2hpbGQgPSBudWxsO1xuICBmaWJlci5kZXBlbmRlbmNpZXMgPSBudWxsO1xuICBmaWJlci5maXJzdEVmZmVjdCA9IG51bGw7XG4gIGZpYmVyLmxhc3RFZmZlY3QgPSBudWxsO1xuICBmaWJlci5tZW1vaXplZFByb3BzID0gbnVsbDtcbiAgZmliZXIubWVtb2l6ZWRTdGF0ZSA9IG51bGw7XG4gIGZpYmVyLnBlbmRpbmdQcm9wcyA9IG51bGw7XG4gIGZpYmVyLnJldHVybiA9IG51bGw7XG4gIGZpYmVyLnVwZGF0ZVF1ZXVlID0gbnVsbDtcblxuICB7XG4gICAgZmliZXIuX2RlYnVnT3duZXIgPSBudWxsO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldEhvc3RQYXJlbnRGaWJlcihmaWJlcikge1xuICB2YXIgcGFyZW50ID0gZmliZXIucmV0dXJuO1xuXG4gIHdoaWxlIChwYXJlbnQgIT09IG51bGwpIHtcbiAgICBpZiAoaXNIb3N0UGFyZW50KHBhcmVudCkpIHtcbiAgICAgIHJldHVybiBwYXJlbnQ7XG4gICAgfVxuXG4gICAgcGFyZW50ID0gcGFyZW50LnJldHVybjtcbiAgfVxuXG4gIHtcbiAgICB7XG4gICAgICB0aHJvdyBFcnJvciggXCJFeHBlY3RlZCB0byBmaW5kIGEgaG9zdCBwYXJlbnQuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCIgKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNIb3N0UGFyZW50KGZpYmVyKSB7XG4gIHJldHVybiBmaWJlci50YWcgPT09IEhvc3RDb21wb25lbnQgfHwgZmliZXIudGFnID09PSBIb3N0Um9vdCB8fCBmaWJlci50YWcgPT09IEhvc3RQb3J0YWw7XG59XG5cbmZ1bmN0aW9uIGdldEhvc3RTaWJsaW5nKGZpYmVyKSB7XG4gIC8vIFdlJ3JlIGdvaW5nIHRvIHNlYXJjaCBmb3J3YXJkIGludG8gdGhlIHRyZWUgdW50aWwgd2UgZmluZCBhIHNpYmxpbmcgaG9zdFxuICAvLyBub2RlLiBVbmZvcnR1bmF0ZWx5LCBpZiBtdWx0aXBsZSBpbnNlcnRpb25zIGFyZSBkb25lIGluIGEgcm93IHdlIGhhdmUgdG9cbiAgLy8gc2VhcmNoIHBhc3QgdGhlbS4gVGhpcyBsZWFkcyB0byBleHBvbmVudGlhbCBzZWFyY2ggZm9yIHRoZSBuZXh0IHNpYmxpbmcuXG4gIC8vIFRPRE86IEZpbmQgYSBtb3JlIGVmZmljaWVudCB3YXkgdG8gZG8gdGhpcy5cbiAgdmFyIG5vZGUgPSBmaWJlcjtcblxuICBzaWJsaW5nczogd2hpbGUgKHRydWUpIHtcbiAgICAvLyBJZiB3ZSBkaWRuJ3QgZmluZCBhbnl0aGluZywgbGV0J3MgdHJ5IHRoZSBuZXh0IHNpYmxpbmcuXG4gICAgd2hpbGUgKG5vZGUuc2libGluZyA9PT0gbnVsbCkge1xuICAgICAgaWYgKG5vZGUucmV0dXJuID09PSBudWxsIHx8IGlzSG9zdFBhcmVudChub2RlLnJldHVybikpIHtcbiAgICAgICAgLy8gSWYgd2UgcG9wIG91dCBvZiB0aGUgcm9vdCBvciBoaXQgdGhlIHBhcmVudCB0aGUgZmliZXIgd2UgYXJlIHRoZVxuICAgICAgICAvLyBsYXN0IHNpYmxpbmcuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICBub2RlID0gbm9kZS5yZXR1cm47XG4gICAgfVxuXG4gICAgbm9kZS5zaWJsaW5nLnJldHVybiA9IG5vZGUucmV0dXJuO1xuICAgIG5vZGUgPSBub2RlLnNpYmxpbmc7XG5cbiAgICB3aGlsZSAobm9kZS50YWcgIT09IEhvc3RDb21wb25lbnQgJiYgbm9kZS50YWcgIT09IEhvc3RUZXh0ICYmIG5vZGUudGFnICE9PSBEZWh5ZHJhdGVkRnJhZ21lbnQpIHtcbiAgICAgIC8vIElmIGl0IGlzIG5vdCBob3N0IG5vZGUgYW5kLCB3ZSBtaWdodCBoYXZlIGEgaG9zdCBub2RlIGluc2lkZSBpdC5cbiAgICAgIC8vIFRyeSB0byBzZWFyY2ggZG93biB1bnRpbCB3ZSBmaW5kIG9uZS5cbiAgICAgIGlmIChub2RlLmZsYWdzICYgUGxhY2VtZW50KSB7XG4gICAgICAgIC8vIElmIHdlIGRvbid0IGhhdmUgYSBjaGlsZCwgdHJ5IHRoZSBzaWJsaW5ncyBpbnN0ZWFkLlxuICAgICAgICBjb250aW51ZSBzaWJsaW5ncztcbiAgICAgIH0gLy8gSWYgd2UgZG9uJ3QgaGF2ZSBhIGNoaWxkLCB0cnkgdGhlIHNpYmxpbmdzIGluc3RlYWQuXG4gICAgICAvLyBXZSBhbHNvIHNraXAgcG9ydGFscyBiZWNhdXNlIHRoZXkgYXJlIG5vdCBwYXJ0IG9mIHRoaXMgaG9zdCB0cmVlLlxuXG5cbiAgICAgIGlmIChub2RlLmNoaWxkID09PSBudWxsIHx8IG5vZGUudGFnID09PSBIb3N0UG9ydGFsKSB7XG4gICAgICAgIGNvbnRpbnVlIHNpYmxpbmdzO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbm9kZS5jaGlsZC5yZXR1cm4gPSBub2RlO1xuICAgICAgICBub2RlID0gbm9kZS5jaGlsZDtcbiAgICAgIH1cbiAgICB9IC8vIENoZWNrIGlmIHRoaXMgaG9zdCBub2RlIGlzIHN0YWJsZSBvciBhYm91dCB0byBiZSBwbGFjZWQuXG5cblxuICAgIGlmICghKG5vZGUuZmxhZ3MgJiBQbGFjZW1lbnQpKSB7XG4gICAgICAvLyBGb3VuZCBpdCFcbiAgICAgIHJldHVybiBub2RlLnN0YXRlTm9kZTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY29tbWl0UGxhY2VtZW50KGZpbmlzaGVkV29yaykge1xuXG5cbiAgdmFyIHBhcmVudEZpYmVyID0gZ2V0SG9zdFBhcmVudEZpYmVyKGZpbmlzaGVkV29yayk7IC8vIE5vdGU6IHRoZXNlIHR3byB2YXJpYWJsZXMgKm11c3QqIGFsd2F5cyBiZSB1cGRhdGVkIHRvZ2V0aGVyLlxuXG4gIHZhciBwYXJlbnQ7XG4gIHZhciBpc0NvbnRhaW5lcjtcbiAgdmFyIHBhcmVudFN0YXRlTm9kZSA9IHBhcmVudEZpYmVyLnN0YXRlTm9kZTtcblxuICBzd2l0Y2ggKHBhcmVudEZpYmVyLnRhZykge1xuICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICAgIHBhcmVudCA9IHBhcmVudFN0YXRlTm9kZTtcbiAgICAgIGlzQ29udGFpbmVyID0gZmFsc2U7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgSG9zdFJvb3Q6XG4gICAgICBwYXJlbnQgPSBwYXJlbnRTdGF0ZU5vZGUuY29udGFpbmVySW5mbztcbiAgICAgIGlzQ29udGFpbmVyID0gdHJ1ZTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBIb3N0UG9ydGFsOlxuICAgICAgcGFyZW50ID0gcGFyZW50U3RhdGVOb2RlLmNvbnRhaW5lckluZm87XG4gICAgICBpc0NvbnRhaW5lciA9IHRydWU7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgRnVuZGFtZW50YWxDb21wb25lbnQ6XG5cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUtbm8tZmFsbHRocm91Z2hcblxuICAgIGRlZmF1bHQ6XG4gICAgICB7XG4gICAgICAgIHtcbiAgICAgICAgICB0aHJvdyBFcnJvciggXCJJbnZhbGlkIGhvc3QgcGFyZW50IGZpYmVyLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiICk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICB9XG5cbiAgaWYgKHBhcmVudEZpYmVyLmZsYWdzICYgQ29udGVudFJlc2V0KSB7XG4gICAgLy8gUmVzZXQgdGhlIHRleHQgY29udGVudCBvZiB0aGUgcGFyZW50IGJlZm9yZSBkb2luZyBhbnkgaW5zZXJ0aW9uc1xuICAgIHJlc2V0VGV4dENvbnRlbnQocGFyZW50KTsgLy8gQ2xlYXIgQ29udGVudFJlc2V0IGZyb20gdGhlIGVmZmVjdCB0YWdcblxuICAgIHBhcmVudEZpYmVyLmZsYWdzICY9IH5Db250ZW50UmVzZXQ7XG4gIH1cblxuICB2YXIgYmVmb3JlID0gZ2V0SG9zdFNpYmxpbmcoZmluaXNoZWRXb3JrKTsgLy8gV2Ugb25seSBoYXZlIHRoZSB0b3AgRmliZXIgdGhhdCB3YXMgaW5zZXJ0ZWQgYnV0IHdlIG5lZWQgdG8gcmVjdXJzZSBkb3duIGl0c1xuICAvLyBjaGlsZHJlbiB0byBmaW5kIGFsbCB0aGUgdGVybWluYWwgbm9kZXMuXG5cbiAgaWYgKGlzQ29udGFpbmVyKSB7XG4gICAgaW5zZXJ0T3JBcHBlbmRQbGFjZW1lbnROb2RlSW50b0NvbnRhaW5lcihmaW5pc2hlZFdvcmssIGJlZm9yZSwgcGFyZW50KTtcbiAgfSBlbHNlIHtcbiAgICBpbnNlcnRPckFwcGVuZFBsYWNlbWVudE5vZGUoZmluaXNoZWRXb3JrLCBiZWZvcmUsIHBhcmVudCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW5zZXJ0T3JBcHBlbmRQbGFjZW1lbnROb2RlSW50b0NvbnRhaW5lcihub2RlLCBiZWZvcmUsIHBhcmVudCkge1xuICB2YXIgdGFnID0gbm9kZS50YWc7XG4gIHZhciBpc0hvc3QgPSB0YWcgPT09IEhvc3RDb21wb25lbnQgfHwgdGFnID09PSBIb3N0VGV4dDtcblxuICBpZiAoaXNIb3N0IHx8IGVuYWJsZUZ1bmRhbWVudGFsQVBJICkge1xuICAgIHZhciBzdGF0ZU5vZGUgPSBpc0hvc3QgPyBub2RlLnN0YXRlTm9kZSA6IG5vZGUuc3RhdGVOb2RlLmluc3RhbmNlO1xuXG4gICAgaWYgKGJlZm9yZSkge1xuICAgICAgaW5zZXJ0SW5Db250YWluZXJCZWZvcmUocGFyZW50LCBzdGF0ZU5vZGUsIGJlZm9yZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFwcGVuZENoaWxkVG9Db250YWluZXIocGFyZW50LCBzdGF0ZU5vZGUpO1xuICAgIH1cbiAgfSBlbHNlIGlmICh0YWcgPT09IEhvc3RQb3J0YWwpIDsgZWxzZSB7XG4gICAgdmFyIGNoaWxkID0gbm9kZS5jaGlsZDtcblxuICAgIGlmIChjaGlsZCAhPT0gbnVsbCkge1xuICAgICAgaW5zZXJ0T3JBcHBlbmRQbGFjZW1lbnROb2RlSW50b0NvbnRhaW5lcihjaGlsZCwgYmVmb3JlLCBwYXJlbnQpO1xuICAgICAgdmFyIHNpYmxpbmcgPSBjaGlsZC5zaWJsaW5nO1xuXG4gICAgICB3aGlsZSAoc2libGluZyAhPT0gbnVsbCkge1xuICAgICAgICBpbnNlcnRPckFwcGVuZFBsYWNlbWVudE5vZGVJbnRvQ29udGFpbmVyKHNpYmxpbmcsIGJlZm9yZSwgcGFyZW50KTtcbiAgICAgICAgc2libGluZyA9IHNpYmxpbmcuc2libGluZztcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gaW5zZXJ0T3JBcHBlbmRQbGFjZW1lbnROb2RlKG5vZGUsIGJlZm9yZSwgcGFyZW50KSB7XG4gIHZhciB0YWcgPSBub2RlLnRhZztcbiAgdmFyIGlzSG9zdCA9IHRhZyA9PT0gSG9zdENvbXBvbmVudCB8fCB0YWcgPT09IEhvc3RUZXh0O1xuXG4gIGlmIChpc0hvc3QgfHwgZW5hYmxlRnVuZGFtZW50YWxBUEkgKSB7XG4gICAgdmFyIHN0YXRlTm9kZSA9IGlzSG9zdCA/IG5vZGUuc3RhdGVOb2RlIDogbm9kZS5zdGF0ZU5vZGUuaW5zdGFuY2U7XG5cbiAgICBpZiAoYmVmb3JlKSB7XG4gICAgICBpbnNlcnRCZWZvcmUocGFyZW50LCBzdGF0ZU5vZGUsIGJlZm9yZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFwcGVuZENoaWxkKHBhcmVudCwgc3RhdGVOb2RlKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAodGFnID09PSBIb3N0UG9ydGFsKSA7IGVsc2Uge1xuICAgIHZhciBjaGlsZCA9IG5vZGUuY2hpbGQ7XG5cbiAgICBpZiAoY2hpbGQgIT09IG51bGwpIHtcbiAgICAgIGluc2VydE9yQXBwZW5kUGxhY2VtZW50Tm9kZShjaGlsZCwgYmVmb3JlLCBwYXJlbnQpO1xuICAgICAgdmFyIHNpYmxpbmcgPSBjaGlsZC5zaWJsaW5nO1xuXG4gICAgICB3aGlsZSAoc2libGluZyAhPT0gbnVsbCkge1xuICAgICAgICBpbnNlcnRPckFwcGVuZFBsYWNlbWVudE5vZGUoc2libGluZywgYmVmb3JlLCBwYXJlbnQpO1xuICAgICAgICBzaWJsaW5nID0gc2libGluZy5zaWJsaW5nO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiB1bm1vdW50SG9zdENvbXBvbmVudHMoZmluaXNoZWRSb290LCBjdXJyZW50LCByZW5kZXJQcmlvcml0eUxldmVsKSB7XG4gIC8vIFdlIG9ubHkgaGF2ZSB0aGUgdG9wIEZpYmVyIHRoYXQgd2FzIGRlbGV0ZWQgYnV0IHdlIG5lZWQgdG8gcmVjdXJzZSBkb3duIGl0c1xuICAvLyBjaGlsZHJlbiB0byBmaW5kIGFsbCB0aGUgdGVybWluYWwgbm9kZXMuXG4gIHZhciBub2RlID0gY3VycmVudDsgLy8gRWFjaCBpdGVyYXRpb24sIGN1cnJlbnRQYXJlbnQgaXMgcG9wdWxhdGVkIHdpdGggbm9kZSdzIGhvc3QgcGFyZW50IGlmIG5vdFxuICAvLyBjdXJyZW50UGFyZW50SXNWYWxpZC5cblxuICB2YXIgY3VycmVudFBhcmVudElzVmFsaWQgPSBmYWxzZTsgLy8gTm90ZTogdGhlc2UgdHdvIHZhcmlhYmxlcyAqbXVzdCogYWx3YXlzIGJlIHVwZGF0ZWQgdG9nZXRoZXIuXG5cbiAgdmFyIGN1cnJlbnRQYXJlbnQ7XG4gIHZhciBjdXJyZW50UGFyZW50SXNDb250YWluZXI7XG5cbiAgd2hpbGUgKHRydWUpIHtcbiAgICBpZiAoIWN1cnJlbnRQYXJlbnRJc1ZhbGlkKSB7XG4gICAgICB2YXIgcGFyZW50ID0gbm9kZS5yZXR1cm47XG5cbiAgICAgIGZpbmRQYXJlbnQ6IHdoaWxlICh0cnVlKSB7XG4gICAgICAgIGlmICghKHBhcmVudCAhPT0gbnVsbCkpIHtcbiAgICAgICAgICB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvciggXCJFeHBlY3RlZCB0byBmaW5kIGEgaG9zdCBwYXJlbnQuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCIgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcGFyZW50U3RhdGVOb2RlID0gcGFyZW50LnN0YXRlTm9kZTtcblxuICAgICAgICBzd2l0Y2ggKHBhcmVudC50YWcpIHtcbiAgICAgICAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICAgICAgICBjdXJyZW50UGFyZW50ID0gcGFyZW50U3RhdGVOb2RlO1xuICAgICAgICAgICAgY3VycmVudFBhcmVudElzQ29udGFpbmVyID0gZmFsc2U7XG4gICAgICAgICAgICBicmVhayBmaW5kUGFyZW50O1xuXG4gICAgICAgICAgY2FzZSBIb3N0Um9vdDpcbiAgICAgICAgICAgIGN1cnJlbnRQYXJlbnQgPSBwYXJlbnRTdGF0ZU5vZGUuY29udGFpbmVySW5mbztcbiAgICAgICAgICAgIGN1cnJlbnRQYXJlbnRJc0NvbnRhaW5lciA9IHRydWU7XG4gICAgICAgICAgICBicmVhayBmaW5kUGFyZW50O1xuXG4gICAgICAgICAgY2FzZSBIb3N0UG9ydGFsOlxuICAgICAgICAgICAgY3VycmVudFBhcmVudCA9IHBhcmVudFN0YXRlTm9kZS5jb250YWluZXJJbmZvO1xuICAgICAgICAgICAgY3VycmVudFBhcmVudElzQ29udGFpbmVyID0gdHJ1ZTtcbiAgICAgICAgICAgIGJyZWFrIGZpbmRQYXJlbnQ7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHBhcmVudCA9IHBhcmVudC5yZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGN1cnJlbnRQYXJlbnRJc1ZhbGlkID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAobm9kZS50YWcgPT09IEhvc3RDb21wb25lbnQgfHwgbm9kZS50YWcgPT09IEhvc3RUZXh0KSB7XG4gICAgICBjb21taXROZXN0ZWRVbm1vdW50cyhmaW5pc2hlZFJvb3QsIG5vZGUpOyAvLyBBZnRlciBhbGwgdGhlIGNoaWxkcmVuIGhhdmUgdW5tb3VudGVkLCBpdCBpcyBub3cgc2FmZSB0byByZW1vdmUgdGhlXG4gICAgICAvLyBub2RlIGZyb20gdGhlIHRyZWUuXG5cbiAgICAgIGlmIChjdXJyZW50UGFyZW50SXNDb250YWluZXIpIHtcbiAgICAgICAgcmVtb3ZlQ2hpbGRGcm9tQ29udGFpbmVyKGN1cnJlbnRQYXJlbnQsIG5vZGUuc3RhdGVOb2RlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlbW92ZUNoaWxkKGN1cnJlbnRQYXJlbnQsIG5vZGUuc3RhdGVOb2RlKTtcbiAgICAgIH0gLy8gRG9uJ3QgdmlzaXQgY2hpbGRyZW4gYmVjYXVzZSB3ZSBhbHJlYWR5IHZpc2l0ZWQgdGhlbS5cblxuICAgIH0gZWxzZSBpZiAobm9kZS50YWcgPT09IEhvc3RQb3J0YWwpIHtcbiAgICAgIGlmIChub2RlLmNoaWxkICE9PSBudWxsKSB7XG4gICAgICAgIC8vIFdoZW4gd2UgZ28gaW50byBhIHBvcnRhbCwgaXQgYmVjb21lcyB0aGUgcGFyZW50IHRvIHJlbW92ZSBmcm9tLlxuICAgICAgICAvLyBXZSB3aWxsIHJlYXNzaWduIGl0IGJhY2sgd2hlbiB3ZSBwb3AgdGhlIHBvcnRhbCBvbiB0aGUgd2F5IHVwLlxuICAgICAgICBjdXJyZW50UGFyZW50ID0gbm9kZS5zdGF0ZU5vZGUuY29udGFpbmVySW5mbztcbiAgICAgICAgY3VycmVudFBhcmVudElzQ29udGFpbmVyID0gdHJ1ZTsgLy8gVmlzaXQgY2hpbGRyZW4gYmVjYXVzZSBwb3J0YWxzIG1pZ2h0IGNvbnRhaW4gaG9zdCBjb21wb25lbnRzLlxuXG4gICAgICAgIG5vZGUuY2hpbGQucmV0dXJuID0gbm9kZTtcbiAgICAgICAgbm9kZSA9IG5vZGUuY2hpbGQ7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb21taXRVbm1vdW50KGZpbmlzaGVkUm9vdCwgbm9kZSk7IC8vIFZpc2l0IGNoaWxkcmVuIGJlY2F1c2Ugd2UgbWF5IGZpbmQgbW9yZSBob3N0IGNvbXBvbmVudHMgYmVsb3cuXG5cbiAgICAgIGlmIChub2RlLmNoaWxkICE9PSBudWxsKSB7XG4gICAgICAgIG5vZGUuY2hpbGQucmV0dXJuID0gbm9kZTtcbiAgICAgICAgbm9kZSA9IG5vZGUuY2hpbGQ7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChub2RlID09PSBjdXJyZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgd2hpbGUgKG5vZGUuc2libGluZyA9PT0gbnVsbCkge1xuICAgICAgaWYgKG5vZGUucmV0dXJuID09PSBudWxsIHx8IG5vZGUucmV0dXJuID09PSBjdXJyZW50KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgbm9kZSA9IG5vZGUucmV0dXJuO1xuXG4gICAgICBpZiAobm9kZS50YWcgPT09IEhvc3RQb3J0YWwpIHtcbiAgICAgICAgLy8gV2hlbiB3ZSBnbyBvdXQgb2YgdGhlIHBvcnRhbCwgd2UgbmVlZCB0byByZXN0b3JlIHRoZSBwYXJlbnQuXG4gICAgICAgIC8vIFNpbmNlIHdlIGRvbid0IGtlZXAgYSBzdGFjayBvZiB0aGVtLCB3ZSB3aWxsIHNlYXJjaCBmb3IgaXQuXG4gICAgICAgIGN1cnJlbnRQYXJlbnRJc1ZhbGlkID0gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgbm9kZS5zaWJsaW5nLnJldHVybiA9IG5vZGUucmV0dXJuO1xuICAgIG5vZGUgPSBub2RlLnNpYmxpbmc7XG4gIH1cbn1cblxuZnVuY3Rpb24gY29tbWl0RGVsZXRpb24oZmluaXNoZWRSb290LCBjdXJyZW50LCByZW5kZXJQcmlvcml0eUxldmVsKSB7XG4gIHtcbiAgICAvLyBSZWN1cnNpdmVseSBkZWxldGUgYWxsIGhvc3Qgbm9kZXMgZnJvbSB0aGUgcGFyZW50LlxuICAgIC8vIERldGFjaCByZWZzIGFuZCBjYWxsIGNvbXBvbmVudFdpbGxVbm1vdW50KCkgb24gdGhlIHdob2xlIHN1YnRyZWUuXG4gICAgdW5tb3VudEhvc3RDb21wb25lbnRzKGZpbmlzaGVkUm9vdCwgY3VycmVudCk7XG4gIH1cblxuICB2YXIgYWx0ZXJuYXRlID0gY3VycmVudC5hbHRlcm5hdGU7XG4gIGRldGFjaEZpYmVyTXV0YXRpb24oY3VycmVudCk7XG5cbiAgaWYgKGFsdGVybmF0ZSAhPT0gbnVsbCkge1xuICAgIGRldGFjaEZpYmVyTXV0YXRpb24oYWx0ZXJuYXRlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjb21taXRXb3JrKGN1cnJlbnQsIGZpbmlzaGVkV29yaykge1xuXG4gIHN3aXRjaCAoZmluaXNoZWRXb3JrLnRhZykge1xuICAgIGNhc2UgRnVuY3Rpb25Db21wb25lbnQ6XG4gICAgY2FzZSBGb3J3YXJkUmVmOlxuICAgIGNhc2UgTWVtb0NvbXBvbmVudDpcbiAgICBjYXNlIFNpbXBsZU1lbW9Db21wb25lbnQ6XG4gICAgY2FzZSBCbG9jazpcbiAgICAgIHtcbiAgICAgICAgLy8gTGF5b3V0IGVmZmVjdHMgYXJlIGRlc3Ryb3llZCBkdXJpbmcgdGhlIG11dGF0aW9uIHBoYXNlIHNvIHRoYXQgYWxsXG4gICAgICAgIC8vIGRlc3Ryb3kgZnVuY3Rpb25zIGZvciBhbGwgZmliZXJzIGFyZSBjYWxsZWQgYmVmb3JlIGFueSBjcmVhdGUgZnVuY3Rpb25zLlxuICAgICAgICAvLyBUaGlzIHByZXZlbnRzIHNpYmxpbmcgY29tcG9uZW50IGVmZmVjdHMgZnJvbSBpbnRlcmZlcmluZyB3aXRoIGVhY2ggb3RoZXIsXG4gICAgICAgIC8vIGUuZy4gYSBkZXN0cm95IGZ1bmN0aW9uIGluIG9uZSBjb21wb25lbnQgc2hvdWxkIG5ldmVyIG92ZXJyaWRlIGEgcmVmIHNldFxuICAgICAgICAvLyBieSBhIGNyZWF0ZSBmdW5jdGlvbiBpbiBhbm90aGVyIGNvbXBvbmVudCBkdXJpbmcgdGhlIHNhbWUgY29tbWl0LlxuICAgICAgICB7XG4gICAgICAgICAgY29tbWl0SG9va0VmZmVjdExpc3RVbm1vdW50KExheW91dCB8IEhhc0VmZmVjdCwgZmluaXNoZWRXb3JrKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgIGNhc2UgQ2xhc3NDb21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICAgIHtcbiAgICAgICAgdmFyIGluc3RhbmNlID0gZmluaXNoZWRXb3JrLnN0YXRlTm9kZTtcblxuICAgICAgICBpZiAoaW5zdGFuY2UgIT0gbnVsbCkge1xuICAgICAgICAgIC8vIENvbW1pdCB0aGUgd29yayBwcmVwYXJlZCBlYXJsaWVyLlxuICAgICAgICAgIHZhciBuZXdQcm9wcyA9IGZpbmlzaGVkV29yay5tZW1vaXplZFByb3BzOyAvLyBGb3IgaHlkcmF0aW9uIHdlIHJldXNlIHRoZSB1cGRhdGUgcGF0aCBidXQgd2UgdHJlYXQgdGhlIG9sZFByb3BzXG4gICAgICAgICAgLy8gYXMgdGhlIG5ld1Byb3BzLiBUaGUgdXBkYXRlUGF5bG9hZCB3aWxsIGNvbnRhaW4gdGhlIHJlYWwgY2hhbmdlIGluXG4gICAgICAgICAgLy8gdGhpcyBjYXNlLlxuXG4gICAgICAgICAgdmFyIG9sZFByb3BzID0gY3VycmVudCAhPT0gbnVsbCA/IGN1cnJlbnQubWVtb2l6ZWRQcm9wcyA6IG5ld1Byb3BzO1xuICAgICAgICAgIHZhciB0eXBlID0gZmluaXNoZWRXb3JrLnR5cGU7IC8vIFRPRE86IFR5cGUgdGhlIHVwZGF0ZVF1ZXVlIHRvIGJlIHNwZWNpZmljIHRvIGhvc3QgY29tcG9uZW50cy5cblxuICAgICAgICAgIHZhciB1cGRhdGVQYXlsb2FkID0gZmluaXNoZWRXb3JrLnVwZGF0ZVF1ZXVlO1xuICAgICAgICAgIGZpbmlzaGVkV29yay51cGRhdGVRdWV1ZSA9IG51bGw7XG5cbiAgICAgICAgICBpZiAodXBkYXRlUGF5bG9hZCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgY29tbWl0VXBkYXRlKGluc3RhbmNlLCB1cGRhdGVQYXlsb2FkLCB0eXBlLCBvbGRQcm9wcywgbmV3UHJvcHMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgIGNhc2UgSG9zdFRleHQ6XG4gICAgICB7XG4gICAgICAgIGlmICghKGZpbmlzaGVkV29yay5zdGF0ZU5vZGUgIT09IG51bGwpKSB7XG4gICAgICAgICAge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoIFwiVGhpcyBzaG91bGQgaGF2ZSBhIHRleHQgbm9kZSBpbml0aWFsaXplZC4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS5cIiApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB0ZXh0SW5zdGFuY2UgPSBmaW5pc2hlZFdvcmsuc3RhdGVOb2RlO1xuICAgICAgICB2YXIgbmV3VGV4dCA9IGZpbmlzaGVkV29yay5tZW1vaXplZFByb3BzOyAvLyBGb3IgaHlkcmF0aW9uIHdlIHJldXNlIHRoZSB1cGRhdGUgcGF0aCBidXQgd2UgdHJlYXQgdGhlIG9sZFByb3BzXG4gICAgICAgIC8vIGFzIHRoZSBuZXdQcm9wcy4gVGhlIHVwZGF0ZVBheWxvYWQgd2lsbCBjb250YWluIHRoZSByZWFsIGNoYW5nZSBpblxuICAgICAgICAvLyB0aGlzIGNhc2UuXG5cbiAgICAgICAgdmFyIG9sZFRleHQgPSBjdXJyZW50ICE9PSBudWxsID8gY3VycmVudC5tZW1vaXplZFByb3BzIDogbmV3VGV4dDtcbiAgICAgICAgY29tbWl0VGV4dFVwZGF0ZSh0ZXh0SW5zdGFuY2UsIG9sZFRleHQsIG5ld1RleHQpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICBjYXNlIEhvc3RSb290OlxuICAgICAge1xuICAgICAgICB7XG4gICAgICAgICAgdmFyIF9yb290ID0gZmluaXNoZWRXb3JrLnN0YXRlTm9kZTtcblxuICAgICAgICAgIGlmIChfcm9vdC5oeWRyYXRlKSB7XG4gICAgICAgICAgICAvLyBXZSd2ZSBqdXN0IGh5ZHJhdGVkLiBObyBuZWVkIHRvIGh5ZHJhdGUgYWdhaW4uXG4gICAgICAgICAgICBfcm9vdC5oeWRyYXRlID0gZmFsc2U7XG4gICAgICAgICAgICBjb21taXRIeWRyYXRlZENvbnRhaW5lcihfcm9vdC5jb250YWluZXJJbmZvKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICBjYXNlIFByb2ZpbGVyOlxuICAgICAge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICBjYXNlIFN1c3BlbnNlQ29tcG9uZW50OlxuICAgICAge1xuICAgICAgICBjb21taXRTdXNwZW5zZUNvbXBvbmVudChmaW5pc2hlZFdvcmspO1xuICAgICAgICBhdHRhY2hTdXNwZW5zZVJldHJ5TGlzdGVuZXJzKGZpbmlzaGVkV29yayk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgIGNhc2UgU3VzcGVuc2VMaXN0Q29tcG9uZW50OlxuICAgICAge1xuICAgICAgICBhdHRhY2hTdXNwZW5zZVJldHJ5TGlzdGVuZXJzKGZpbmlzaGVkV29yayk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgIGNhc2UgSW5jb21wbGV0ZUNsYXNzQ29tcG9uZW50OlxuICAgICAge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICBjYXNlIEZ1bmRhbWVudGFsQ29tcG9uZW50OlxuICAgICAge1xuXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgY2FzZSBTY29wZUNvbXBvbmVudDpcbiAgICAgIHtcblxuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgIGNhc2UgT2Zmc2NyZWVuQ29tcG9uZW50OlxuICAgIGNhc2UgTGVnYWN5SGlkZGVuQ29tcG9uZW50OlxuICAgICAge1xuICAgICAgICB2YXIgbmV3U3RhdGUgPSBmaW5pc2hlZFdvcmsubWVtb2l6ZWRTdGF0ZTtcbiAgICAgICAgdmFyIGlzSGlkZGVuID0gbmV3U3RhdGUgIT09IG51bGw7XG4gICAgICAgIGhpZGVPclVuaGlkZUFsbENoaWxkcmVuKGZpbmlzaGVkV29yaywgaXNIaWRkZW4pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gIH1cblxuICB7XG4gICAge1xuICAgICAgdGhyb3cgRXJyb3IoIFwiVGhpcyB1bml0IG9mIHdvcmsgdGFnIHNob3VsZCBub3QgaGF2ZSBzaWRlLWVmZmVjdHMuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCIgKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY29tbWl0U3VzcGVuc2VDb21wb25lbnQoZmluaXNoZWRXb3JrKSB7XG4gIHZhciBuZXdTdGF0ZSA9IGZpbmlzaGVkV29yay5tZW1vaXplZFN0YXRlO1xuXG4gIGlmIChuZXdTdGF0ZSAhPT0gbnVsbCkge1xuICAgIG1hcmtDb21taXRUaW1lT2ZGYWxsYmFjaygpO1xuXG4gICAge1xuICAgICAgLy8gSGlkZSB0aGUgT2Zmc2NyZWVuIGNvbXBvbmVudCB0aGF0IGNvbnRhaW5zIHRoZSBwcmltYXJ5IGNoaWxkcmVuLiBUT0RPOlxuICAgICAgLy8gSWRlYWxseSwgdGhpcyBlZmZlY3Qgd291bGQgaGF2ZSBiZWVuIHNjaGVkdWxlZCBvbiB0aGUgT2Zmc2NyZWVuIGZpYmVyXG4gICAgICAvLyBpdHNlbGYuIFRoYXQncyBob3cgdW5oaWRpbmcgd29ya3M6IHRoZSBPZmZzY3JlZW4gY29tcG9uZW50IHNjaGVkdWxlcyBhblxuICAgICAgLy8gZWZmZWN0IG9uIGl0c2VsZi4gSG93ZXZlciwgaW4gdGhpcyBjYXNlLCB0aGUgY29tcG9uZW50IGRpZG4ndCBjb21wbGV0ZSxcbiAgICAgIC8vIHNvIHRoZSBmaWJlciB3YXMgbmV2ZXIgYWRkZWQgdG8gdGhlIGVmZmVjdCBsaXN0IGluIHRoZSBub3JtYWwgcGF0aC4gV2VcbiAgICAgIC8vIGNvdWxkIGhhdmUgYXBwZW5kZWQgaXQgdG8gdGhlIGVmZmVjdCBsaXN0IGluIHRoZSBTdXNwZW5zZSBjb21wb25lbnQnc1xuICAgICAgLy8gc2Vjb25kIHBhc3MsIGJ1dCBkb2luZyBpdCB0aGlzIHdheSBpcyBsZXNzIGNvbXBsaWNhdGVkLiBUaGlzIHdvdWxkIGJlXG4gICAgICAvLyBzaW1wbGVyIGlmIHdlIGdvdCByaWQgb2YgdGhlIGVmZmVjdCBsaXN0IGFuZCB0cmF2ZXJzZWQgdGhlIHRyZWUsIGxpa2VcbiAgICAgIC8vIHdlJ3JlIHBsYW5uaW5nIHRvIGRvLlxuICAgICAgdmFyIHByaW1hcnlDaGlsZFBhcmVudCA9IGZpbmlzaGVkV29yay5jaGlsZDtcbiAgICAgIGhpZGVPclVuaGlkZUFsbENoaWxkcmVuKHByaW1hcnlDaGlsZFBhcmVudCwgdHJ1ZSk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNvbW1pdFN1c3BlbnNlSHlkcmF0aW9uQ2FsbGJhY2tzKGZpbmlzaGVkUm9vdCwgZmluaXNoZWRXb3JrKSB7XG5cbiAgdmFyIG5ld1N0YXRlID0gZmluaXNoZWRXb3JrLm1lbW9pemVkU3RhdGU7XG5cbiAgaWYgKG5ld1N0YXRlID09PSBudWxsKSB7XG4gICAgdmFyIGN1cnJlbnQgPSBmaW5pc2hlZFdvcmsuYWx0ZXJuYXRlO1xuXG4gICAgaWYgKGN1cnJlbnQgIT09IG51bGwpIHtcbiAgICAgIHZhciBwcmV2U3RhdGUgPSBjdXJyZW50Lm1lbW9pemVkU3RhdGU7XG5cbiAgICAgIGlmIChwcmV2U3RhdGUgIT09IG51bGwpIHtcbiAgICAgICAgdmFyIHN1c3BlbnNlSW5zdGFuY2UgPSBwcmV2U3RhdGUuZGVoeWRyYXRlZDtcblxuICAgICAgICBpZiAoc3VzcGVuc2VJbnN0YW5jZSAhPT0gbnVsbCkge1xuICAgICAgICAgIGNvbW1pdEh5ZHJhdGVkU3VzcGVuc2VJbnN0YW5jZShzdXNwZW5zZUluc3RhbmNlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBhdHRhY2hTdXNwZW5zZVJldHJ5TGlzdGVuZXJzKGZpbmlzaGVkV29yaykge1xuICAvLyBJZiB0aGlzIGJvdW5kYXJ5IGp1c3QgdGltZWQgb3V0LCB0aGVuIGl0IHdpbGwgaGF2ZSBhIHNldCBvZiB3YWtlYWJsZXMuXG4gIC8vIEZvciBlYWNoIHdha2VhYmxlLCBhdHRhY2ggYSBsaXN0ZW5lciBzbyB0aGF0IHdoZW4gaXQgcmVzb2x2ZXMsIFJlYWN0XG4gIC8vIGF0dGVtcHRzIHRvIHJlLXJlbmRlciB0aGUgYm91bmRhcnkgaW4gdGhlIHByaW1hcnkgKHByZS10aW1lb3V0KSBzdGF0ZS5cbiAgdmFyIHdha2VhYmxlcyA9IGZpbmlzaGVkV29yay51cGRhdGVRdWV1ZTtcblxuICBpZiAod2FrZWFibGVzICE9PSBudWxsKSB7XG4gICAgZmluaXNoZWRXb3JrLnVwZGF0ZVF1ZXVlID0gbnVsbDtcbiAgICB2YXIgcmV0cnlDYWNoZSA9IGZpbmlzaGVkV29yay5zdGF0ZU5vZGU7XG5cbiAgICBpZiAocmV0cnlDYWNoZSA9PT0gbnVsbCkge1xuICAgICAgcmV0cnlDYWNoZSA9IGZpbmlzaGVkV29yay5zdGF0ZU5vZGUgPSBuZXcgUG9zc2libHlXZWFrU2V0KCk7XG4gICAgfVxuXG4gICAgd2FrZWFibGVzLmZvckVhY2goZnVuY3Rpb24gKHdha2VhYmxlKSB7XG4gICAgICAvLyBNZW1vaXplIHVzaW5nIHRoZSBib3VuZGFyeSBmaWJlciB0byBwcmV2ZW50IHJlZHVuZGFudCBsaXN0ZW5lcnMuXG4gICAgICB2YXIgcmV0cnkgPSByZXNvbHZlUmV0cnlXYWtlYWJsZS5iaW5kKG51bGwsIGZpbmlzaGVkV29yaywgd2FrZWFibGUpO1xuXG4gICAgICBpZiAoIXJldHJ5Q2FjaGUuaGFzKHdha2VhYmxlKSkge1xuICAgICAgICB7XG4gICAgICAgICAgaWYgKHdha2VhYmxlLl9fcmVhY3REb05vdFRyYWNlSW50ZXJhY3Rpb25zICE9PSB0cnVlKSB7XG4gICAgICAgICAgICByZXRyeSA9IHRyYWNpbmcudW5zdGFibGVfd3JhcChyZXRyeSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0cnlDYWNoZS5hZGQod2FrZWFibGUpO1xuICAgICAgICB3YWtlYWJsZS50aGVuKHJldHJ5LCByZXRyeSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn0gLy8gVGhpcyBmdW5jdGlvbiBkZXRlY3RzIHdoZW4gYSBTdXNwZW5zZSBib3VuZGFyeSBnb2VzIGZyb20gdmlzaWJsZSB0byBoaWRkZW4uXG4vLyBJdCByZXR1cm5zIGZhbHNlIGlmIHRoZSBib3VuZGFyeSBpcyBhbHJlYWR5IGhpZGRlbi5cbi8vIFRPRE86IFVzZSBhbiBlZmZlY3QgdGFnLlxuXG5cbmZ1bmN0aW9uIGlzU3VzcGVuc2VCb3VuZGFyeUJlaW5nSGlkZGVuKGN1cnJlbnQsIGZpbmlzaGVkV29yaykge1xuICBpZiAoY3VycmVudCAhPT0gbnVsbCkge1xuICAgIHZhciBvbGRTdGF0ZSA9IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZTtcblxuICAgIGlmIChvbGRTdGF0ZSA9PT0gbnVsbCB8fCBvbGRTdGF0ZS5kZWh5ZHJhdGVkICE9PSBudWxsKSB7XG4gICAgICB2YXIgbmV3U3RhdGUgPSBmaW5pc2hlZFdvcmsubWVtb2l6ZWRTdGF0ZTtcbiAgICAgIHJldHVybiBuZXdTdGF0ZSAhPT0gbnVsbCAmJiBuZXdTdGF0ZS5kZWh5ZHJhdGVkID09PSBudWxsO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gY29tbWl0UmVzZXRUZXh0Q29udGVudChjdXJyZW50KSB7XG5cbiAgcmVzZXRUZXh0Q29udGVudChjdXJyZW50LnN0YXRlTm9kZSk7XG59XG5cbnZhciBDT01QT05FTlRfVFlQRSA9IDA7XG52YXIgSEFTX1BTRVVET19DTEFTU19UWVBFID0gMTtcbnZhciBST0xFX1RZUEUgPSAyO1xudmFyIFRFU1RfTkFNRV9UWVBFID0gMztcbnZhciBURVhUX1RZUEUgPSA0O1xuXG5pZiAodHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2wuZm9yKSB7XG4gIHZhciBzeW1ib2xGb3IkMSA9IFN5bWJvbC5mb3I7XG4gIENPTVBPTkVOVF9UWVBFID0gc3ltYm9sRm9yJDEoJ3NlbGVjdG9yLmNvbXBvbmVudCcpO1xuICBIQVNfUFNFVURPX0NMQVNTX1RZUEUgPSBzeW1ib2xGb3IkMSgnc2VsZWN0b3IuaGFzX3BzZXVkb19jbGFzcycpO1xuICBST0xFX1RZUEUgPSBzeW1ib2xGb3IkMSgnc2VsZWN0b3Iucm9sZScpO1xuICBURVNUX05BTUVfVFlQRSA9IHN5bWJvbEZvciQxKCdzZWxlY3Rvci50ZXN0X2lkJyk7XG4gIFRFWFRfVFlQRSA9IHN5bWJvbEZvciQxKCdzZWxlY3Rvci50ZXh0Jyk7XG59XG52YXIgY29tbWl0SG9va3MgPSBbXTtcbmZ1bmN0aW9uIG9uQ29tbWl0Um9vdCQxKCkge1xuICB7XG4gICAgY29tbWl0SG9va3MuZm9yRWFjaChmdW5jdGlvbiAoY29tbWl0SG9vaykge1xuICAgICAgcmV0dXJuIGNvbW1pdEhvb2soKTtcbiAgICB9KTtcbiAgfVxufVxuXG52YXIgY2VpbCA9IE1hdGguY2VpbDtcbnZhciBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDIgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdEN1cnJlbnREaXNwYXRjaGVyLFxuICAgIFJlYWN0Q3VycmVudE93bmVyJDIgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdEN1cnJlbnRPd25lcixcbiAgICBJc1NvbWVSZW5kZXJlckFjdGluZyA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLklzU29tZVJlbmRlcmVyQWN0aW5nO1xudmFyIE5vQ29udGV4dCA9XG4vKiAgICAgICAgICAgICAqL1xuMDtcbnZhciBCYXRjaGVkQ29udGV4dCA9XG4vKiAgICAgICAgICAgICAgICovXG4xO1xudmFyIEV2ZW50Q29udGV4dCA9XG4vKiAgICAgICAgICAgICAgICAgKi9cbjI7XG52YXIgRGlzY3JldGVFdmVudENvbnRleHQgPVxuLyogICAgICAgICAqL1xuNDtcbnZhciBMZWdhY3lVbmJhdGNoZWRDb250ZXh0ID1cbi8qICAgICAgICovXG44O1xudmFyIFJlbmRlckNvbnRleHQgPVxuLyogICAgICAgICAgICAgICAgKi9cbjE2O1xudmFyIENvbW1pdENvbnRleHQgPVxuLyogICAgICAgICAgICAgICAgKi9cbjMyO1xudmFyIFJldHJ5QWZ0ZXJFcnJvciA9XG4vKiAgICAgICAqL1xuNjQ7XG52YXIgUm9vdEluY29tcGxldGUgPSAwO1xudmFyIFJvb3RGYXRhbEVycm9yZWQgPSAxO1xudmFyIFJvb3RFcnJvcmVkID0gMjtcbnZhciBSb290U3VzcGVuZGVkID0gMztcbnZhciBSb290U3VzcGVuZGVkV2l0aERlbGF5ID0gNDtcbnZhciBSb290Q29tcGxldGVkID0gNTsgLy8gRGVzY3JpYmVzIHdoZXJlIHdlIGFyZSBpbiB0aGUgUmVhY3QgZXhlY3V0aW9uIHN0YWNrXG5cbnZhciBleGVjdXRpb25Db250ZXh0ID0gTm9Db250ZXh0OyAvLyBUaGUgcm9vdCB3ZSdyZSB3b3JraW5nIG9uXG5cbnZhciB3b3JrSW5Qcm9ncmVzc1Jvb3QgPSBudWxsOyAvLyBUaGUgZmliZXIgd2UncmUgd29ya2luZyBvblxuXG52YXIgd29ya0luUHJvZ3Jlc3MgPSBudWxsOyAvLyBUaGUgbGFuZXMgd2UncmUgcmVuZGVyaW5nXG5cbnZhciB3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcyA9IE5vTGFuZXM7IC8vIFN0YWNrIHRoYXQgYWxsb3dzIGNvbXBvbmVudHMgdG8gY2hhbmdlIHRoZSByZW5kZXIgbGFuZXMgZm9yIGl0cyBzdWJ0cmVlXG4vLyBUaGlzIGlzIGEgc3VwZXJzZXQgb2YgdGhlIGxhbmVzIHdlIHN0YXJ0ZWQgd29ya2luZyBvbiBhdCB0aGUgcm9vdC4gVGhlIG9ubHlcbi8vIGNhc2Ugd2hlcmUgaXQncyBkaWZmZXJlbnQgZnJvbSBgd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXNgIGlzIHdoZW4gd2Vcbi8vIGVudGVyIGEgc3VidHJlZSB0aGF0IGlzIGhpZGRlbiBhbmQgbmVlZHMgdG8gYmUgdW5oaWRkZW46IFN1c3BlbnNlIGFuZFxuLy8gT2Zmc2NyZWVuIGNvbXBvbmVudC5cbi8vXG4vLyBNb3N0IHRoaW5ncyBpbiB0aGUgd29yayBsb29wIHNob3VsZCBkZWFsIHdpdGggd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMuXG4vLyBNb3N0IHRoaW5ncyBpbiBiZWdpbi9jb21wbGV0ZSBwaGFzZXMgc2hvdWxkIGRlYWwgd2l0aCBzdWJ0cmVlUmVuZGVyTGFuZXMuXG5cbnZhciBzdWJ0cmVlUmVuZGVyTGFuZXMgPSBOb0xhbmVzO1xudmFyIHN1YnRyZWVSZW5kZXJMYW5lc0N1cnNvciA9IGNyZWF0ZUN1cnNvcihOb0xhbmVzKTsgLy8gV2hldGhlciB0byByb290IGNvbXBsZXRlZCwgZXJyb3JlZCwgc3VzcGVuZGVkLCBldGMuXG5cbnZhciB3b3JrSW5Qcm9ncmVzc1Jvb3RFeGl0U3RhdHVzID0gUm9vdEluY29tcGxldGU7IC8vIEEgZmF0YWwgZXJyb3IsIGlmIG9uZSBpcyB0aHJvd25cblxudmFyIHdvcmtJblByb2dyZXNzUm9vdEZhdGFsRXJyb3IgPSBudWxsOyAvLyBcIkluY2x1ZGVkXCIgbGFuZXMgcmVmZXIgdG8gbGFuZXMgdGhhdCB3ZXJlIHdvcmtlZCBvbiBkdXJpbmcgdGhpcyByZW5kZXIuIEl0J3Ncbi8vIHNsaWdodGx5IGRpZmZlcmVudCB0aGFuIGByZW5kZXJMYW5lc2AgYmVjYXVzZSBgcmVuZGVyTGFuZXNgIGNhbiBjaGFuZ2UgYXMgeW91XG4vLyBlbnRlciBhbmQgZXhpdCBhbiBPZmZzY3JlZW4gdHJlZS4gVGhpcyB2YWx1ZSBpcyB0aGUgY29tYmluYXRpb24gb2YgYWxsIHJlbmRlclxuLy8gbGFuZXMgZm9yIHRoZSBlbnRpcmUgcmVuZGVyIHBoYXNlLlxuXG52YXIgd29ya0luUHJvZ3Jlc3NSb290SW5jbHVkZWRMYW5lcyA9IE5vTGFuZXM7IC8vIFRoZSB3b3JrIGxlZnQgb3ZlciBieSBjb21wb25lbnRzIHRoYXQgd2VyZSB2aXNpdGVkIGR1cmluZyB0aGlzIHJlbmRlci4gT25seVxuLy8gaW5jbHVkZXMgdW5wcm9jZXNzZWQgdXBkYXRlcywgbm90IHdvcmsgaW4gYmFpbGVkIG91dCBjaGlsZHJlbi5cblxudmFyIHdvcmtJblByb2dyZXNzUm9vdFNraXBwZWRMYW5lcyA9IE5vTGFuZXM7IC8vIExhbmVzIHRoYXQgd2VyZSB1cGRhdGVkIChpbiBhbiBpbnRlcmxlYXZlZCBldmVudCkgZHVyaW5nIHRoaXMgcmVuZGVyLlxuXG52YXIgd29ya0luUHJvZ3Jlc3NSb290VXBkYXRlZExhbmVzID0gTm9MYW5lczsgLy8gTGFuZXMgdGhhdCB3ZXJlIHBpbmdlZCAoaW4gYW4gaW50ZXJsZWF2ZWQgZXZlbnQpIGR1cmluZyB0aGlzIHJlbmRlci5cblxudmFyIHdvcmtJblByb2dyZXNzUm9vdFBpbmdlZExhbmVzID0gTm9MYW5lcztcbnZhciBtb3N0UmVjZW50bHlVcGRhdGVkUm9vdCA9IG51bGw7IC8vIFRoZSBtb3N0IHJlY2VudCB0aW1lIHdlIGNvbW1pdHRlZCBhIGZhbGxiYWNrLiBUaGlzIGxldHMgdXMgZW5zdXJlIGEgdHJhaW5cbi8vIG1vZGVsIHdoZXJlIHdlIGRvbid0IGNvbW1pdCBuZXcgbG9hZGluZyBzdGF0ZXMgaW4gdG9vIHF1aWNrIHN1Y2Nlc3Npb24uXG5cbnZhciBnbG9iYWxNb3N0UmVjZW50RmFsbGJhY2tUaW1lID0gMDtcbnZhciBGQUxMQkFDS19USFJPVFRMRV9NUyA9IDUwMDsgLy8gVGhlIGFic29sdXRlIHRpbWUgZm9yIHdoZW4gd2Ugc2hvdWxkIHN0YXJ0IGdpdmluZyB1cCBvbiByZW5kZXJpbmdcbi8vIG1vcmUgYW5kIHByZWZlciBDUFUgc3VzcGVuc2UgaGV1cmlzdGljcyBpbnN0ZWFkLlxuXG52YXIgd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyVGFyZ2V0VGltZSA9IEluZmluaXR5OyAvLyBIb3cgbG9uZyBhIHJlbmRlciBpcyBzdXBwb3NlZCB0byB0YWtlIGJlZm9yZSB3ZSBzdGFydCBmb2xsb3dpbmcgQ1BVXG4vLyBzdXNwZW5zZSBoZXVyaXN0aWNzIGFuZCBvcHQgb3V0IG9mIHJlbmRlcmluZyBtb3JlIGNvbnRlbnQuXG5cbnZhciBSRU5ERVJfVElNRU9VVF9NUyA9IDUwMDtcblxuZnVuY3Rpb24gcmVzZXRSZW5kZXJUaW1lcigpIHtcbiAgd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyVGFyZ2V0VGltZSA9IG5vdygpICsgUkVOREVSX1RJTUVPVVRfTVM7XG59XG5cbmZ1bmN0aW9uIGdldFJlbmRlclRhcmdldFRpbWUoKSB7XG4gIHJldHVybiB3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJUYXJnZXRUaW1lO1xufVxudmFyIG5leHRFZmZlY3QgPSBudWxsO1xudmFyIGhhc1VuY2F1Z2h0RXJyb3IgPSBmYWxzZTtcbnZhciBmaXJzdFVuY2F1Z2h0RXJyb3IgPSBudWxsO1xudmFyIGxlZ2FjeUVycm9yQm91bmRhcmllc1RoYXRBbHJlYWR5RmFpbGVkID0gbnVsbDtcbnZhciByb290RG9lc0hhdmVQYXNzaXZlRWZmZWN0cyA9IGZhbHNlO1xudmFyIHJvb3RXaXRoUGVuZGluZ1Bhc3NpdmVFZmZlY3RzID0gbnVsbDtcbnZhciBwZW5kaW5nUGFzc2l2ZUVmZmVjdHNSZW5kZXJQcmlvcml0eSA9IE5vUHJpb3JpdHkkMTtcbnZhciBwZW5kaW5nUGFzc2l2ZUVmZmVjdHNMYW5lcyA9IE5vTGFuZXM7XG52YXIgcGVuZGluZ1Bhc3NpdmVIb29rRWZmZWN0c01vdW50ID0gW107XG52YXIgcGVuZGluZ1Bhc3NpdmVIb29rRWZmZWN0c1VubW91bnQgPSBbXTtcbnZhciByb290c1dpdGhQZW5kaW5nRGlzY3JldGVVcGRhdGVzID0gbnVsbDsgLy8gVXNlIHRoZXNlIHRvIHByZXZlbnQgYW4gaW5maW5pdGUgbG9vcCBvZiBuZXN0ZWQgdXBkYXRlc1xuXG52YXIgTkVTVEVEX1VQREFURV9MSU1JVCA9IDUwO1xudmFyIG5lc3RlZFVwZGF0ZUNvdW50ID0gMDtcbnZhciByb290V2l0aE5lc3RlZFVwZGF0ZXMgPSBudWxsO1xudmFyIE5FU1RFRF9QQVNTSVZFX1VQREFURV9MSU1JVCA9IDUwO1xudmFyIG5lc3RlZFBhc3NpdmVVcGRhdGVDb3VudCA9IDA7IC8vIE1hcmtzIHRoZSBuZWVkIHRvIHJlc2NoZWR1bGUgcGVuZGluZyBpbnRlcmFjdGlvbnMgYXQgdGhlc2UgbGFuZXNcbi8vIGR1cmluZyB0aGUgY29tbWl0IHBoYXNlLiBUaGlzIGVuYWJsZXMgdGhlbSB0byBiZSB0cmFjZWQgYWNyb3NzIGNvbXBvbmVudHNcbi8vIHRoYXQgc3Bhd24gbmV3IHdvcmsgZHVyaW5nIHJlbmRlci4gRS5nLiBoaWRkZW4gYm91bmRhcmllcywgc3VzcGVuZGVkIFNTUlxuLy8gaHlkcmF0aW9uIG9yIFN1c3BlbnNlTGlzdC5cbi8vIFRPRE86IENhbiB1c2UgYSBiaXRtYXNrIGluc3RlYWQgb2YgYW4gYXJyYXlcblxudmFyIHNwYXduZWRXb3JrRHVyaW5nUmVuZGVyID0gbnVsbDsgLy8gSWYgdHdvIHVwZGF0ZXMgYXJlIHNjaGVkdWxlZCB3aXRoaW4gdGhlIHNhbWUgZXZlbnQsIHdlIHNob3VsZCB0cmVhdCB0aGVpclxuLy8gZXZlbnQgdGltZXMgYXMgc2ltdWx0YW5lb3VzLCBldmVuIGlmIHRoZSBhY3R1YWwgY2xvY2sgdGltZSBoYXMgYWR2YW5jZWRcbi8vIGJldHdlZW4gdGhlIGZpcnN0IGFuZCBzZWNvbmQgY2FsbC5cblxudmFyIGN1cnJlbnRFdmVudFRpbWUgPSBOb1RpbWVzdGFtcDtcbnZhciBjdXJyZW50RXZlbnRXaXBMYW5lcyA9IE5vTGFuZXM7XG52YXIgY3VycmVudEV2ZW50UGVuZGluZ0xhbmVzID0gTm9MYW5lczsgLy8gRGV2IG9ubHkgZmxhZyB0aGF0IHRyYWNrcyBpZiBwYXNzaXZlIGVmZmVjdHMgYXJlIGN1cnJlbnRseSBiZWluZyBmbHVzaGVkLlxuLy8gV2Ugd2FybiBhYm91dCBzdGF0ZSB1cGRhdGVzIGZvciB1bm1vdW50ZWQgY29tcG9uZW50cyBkaWZmZXJlbnRseSBpbiB0aGlzIGNhc2UuXG5cbnZhciBpc0ZsdXNoaW5nUGFzc2l2ZUVmZmVjdHMgPSBmYWxzZTtcbnZhciBmb2N1c2VkSW5zdGFuY2VIYW5kbGUgPSBudWxsO1xudmFyIHNob3VsZEZpcmVBZnRlckFjdGl2ZUluc3RhbmNlQmx1ciA9IGZhbHNlO1xuZnVuY3Rpb24gZ2V0V29ya0luUHJvZ3Jlc3NSb290KCkge1xuICByZXR1cm4gd29ya0luUHJvZ3Jlc3NSb290O1xufVxuZnVuY3Rpb24gcmVxdWVzdEV2ZW50VGltZSgpIHtcbiAgaWYgKChleGVjdXRpb25Db250ZXh0ICYgKFJlbmRlckNvbnRleHQgfCBDb21taXRDb250ZXh0KSkgIT09IE5vQ29udGV4dCkge1xuICAgIC8vIFdlJ3JlIGluc2lkZSBSZWFjdCwgc28gaXQncyBmaW5lIHRvIHJlYWQgdGhlIGFjdHVhbCB0aW1lLlxuICAgIHJldHVybiBub3coKTtcbiAgfSAvLyBXZSdyZSBub3QgaW5zaWRlIFJlYWN0LCBzbyB3ZSBtYXkgYmUgaW4gdGhlIG1pZGRsZSBvZiBhIGJyb3dzZXIgZXZlbnQuXG5cblxuICBpZiAoY3VycmVudEV2ZW50VGltZSAhPT0gTm9UaW1lc3RhbXApIHtcbiAgICAvLyBVc2UgdGhlIHNhbWUgc3RhcnQgdGltZSBmb3IgYWxsIHVwZGF0ZXMgdW50aWwgd2UgZW50ZXIgUmVhY3QgYWdhaW4uXG4gICAgcmV0dXJuIGN1cnJlbnRFdmVudFRpbWU7XG4gIH0gLy8gVGhpcyBpcyB0aGUgZmlyc3QgdXBkYXRlIHNpbmNlIFJlYWN0IHlpZWxkZWQuIENvbXB1dGUgYSBuZXcgc3RhcnQgdGltZS5cblxuXG4gIGN1cnJlbnRFdmVudFRpbWUgPSBub3coKTtcbiAgcmV0dXJuIGN1cnJlbnRFdmVudFRpbWU7XG59XG5mdW5jdGlvbiByZXF1ZXN0VXBkYXRlTGFuZShmaWJlcikge1xuICAvLyBTcGVjaWFsIGNhc2VzXG4gIHZhciBtb2RlID0gZmliZXIubW9kZTtcblxuICBpZiAoKG1vZGUgJiBCbG9ja2luZ01vZGUpID09PSBOb01vZGUpIHtcbiAgICByZXR1cm4gU3luY0xhbmU7XG4gIH0gZWxzZSBpZiAoKG1vZGUgJiBDb25jdXJyZW50TW9kZSkgPT09IE5vTW9kZSkge1xuICAgIHJldHVybiBnZXRDdXJyZW50UHJpb3JpdHlMZXZlbCgpID09PSBJbW1lZGlhdGVQcmlvcml0eSQxID8gU3luY0xhbmUgOiBTeW5jQmF0Y2hlZExhbmU7XG4gIH0gLy8gVGhlIGFsZ29yaXRobSBmb3IgYXNzaWduaW5nIGFuIHVwZGF0ZSB0byBhIGxhbmUgc2hvdWxkIGJlIHN0YWJsZSBmb3IgYWxsXG4gIC8vIHVwZGF0ZXMgYXQgdGhlIHNhbWUgcHJpb3JpdHkgd2l0aGluIHRoZSBzYW1lIGV2ZW50LiBUbyBkbyB0aGlzLCB0aGUgaW5wdXRzXG4gIC8vIHRvIHRoZSBhbGdvcml0aG0gbXVzdCBiZSB0aGUgc2FtZS4gRm9yIGV4YW1wbGUsIHdlIHVzZSB0aGUgYHJlbmRlckxhbmVzYFxuICAvLyB0byBhdm9pZCBjaG9vc2luZyBhIGxhbmUgdGhhdCBpcyBhbHJlYWR5IGluIHRoZSBtaWRkbGUgb2YgcmVuZGVyaW5nLlxuICAvL1xuICAvLyBIb3dldmVyLCB0aGUgXCJpbmNsdWRlZFwiIGxhbmVzIGNvdWxkIGJlIG11dGF0ZWQgaW4gYmV0d2VlbiB1cGRhdGVzIGluIHRoZVxuICAvLyBzYW1lIGV2ZW50LCBsaWtlIGlmIHlvdSBwZXJmb3JtIGFuIHVwZGF0ZSBpbnNpZGUgYGZsdXNoU3luY2AuIE9yIGFueSBvdGhlclxuICAvLyBjb2RlIHBhdGggdGhhdCBtaWdodCBjYWxsIGBwcmVwYXJlRnJlc2hTdGFja2AuXG4gIC8vXG4gIC8vIFRoZSB0cmljayB3ZSB1c2UgaXMgdG8gY2FjaGUgdGhlIGZpcnN0IG9mIGVhY2ggb2YgdGhlc2UgaW5wdXRzIHdpdGhpbiBhblxuICAvLyBldmVudC4gVGhlbiByZXNldCB0aGUgY2FjaGVkIHZhbHVlcyBvbmNlIHdlIGNhbiBiZSBzdXJlIHRoZSBldmVudCBpcyBvdmVyLlxuICAvLyBPdXIgaGV1cmlzdGljIGZvciB0aGF0IGlzIHdoZW5ldmVyIHdlIGVudGVyIGEgY29uY3VycmVudCB3b3JrIGxvb3AuXG4gIC8vXG4gIC8vIFdlJ2xsIGRvIHRoZSBzYW1lIGZvciBgY3VycmVudEV2ZW50UGVuZGluZ0xhbmVzYCBiZWxvdy5cblxuXG4gIGlmIChjdXJyZW50RXZlbnRXaXBMYW5lcyA9PT0gTm9MYW5lcykge1xuICAgIGN1cnJlbnRFdmVudFdpcExhbmVzID0gd29ya0luUHJvZ3Jlc3NSb290SW5jbHVkZWRMYW5lcztcbiAgfVxuXG4gIHZhciBpc1RyYW5zaXRpb24gPSByZXF1ZXN0Q3VycmVudFRyYW5zaXRpb24oKSAhPT0gTm9UcmFuc2l0aW9uO1xuXG4gIGlmIChpc1RyYW5zaXRpb24pIHtcbiAgICBpZiAoY3VycmVudEV2ZW50UGVuZGluZ0xhbmVzICE9PSBOb0xhbmVzKSB7XG4gICAgICBjdXJyZW50RXZlbnRQZW5kaW5nTGFuZXMgPSBtb3N0UmVjZW50bHlVcGRhdGVkUm9vdCAhPT0gbnVsbCA/IG1vc3RSZWNlbnRseVVwZGF0ZWRSb290LnBlbmRpbmdMYW5lcyA6IE5vTGFuZXM7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZpbmRUcmFuc2l0aW9uTGFuZShjdXJyZW50RXZlbnRXaXBMYW5lcywgY3VycmVudEV2ZW50UGVuZGluZ0xhbmVzKTtcbiAgfSAvLyBUT0RPOiBSZW1vdmUgdGhpcyBkZXBlbmRlbmN5IG9uIHRoZSBTY2hlZHVsZXIgcHJpb3JpdHkuXG4gIC8vIFRvIGRvIHRoYXQsIHdlJ3JlIHJlcGxhY2luZyBpdCB3aXRoIGFuIHVwZGF0ZSBsYW5lIHByaW9yaXR5LlxuXG5cbiAgdmFyIHNjaGVkdWxlclByaW9yaXR5ID0gZ2V0Q3VycmVudFByaW9yaXR5TGV2ZWwoKTsgLy8gVGhlIG9sZCBiZWhhdmlvciB3YXMgdXNpbmcgdGhlIHByaW9yaXR5IGxldmVsIG9mIHRoZSBTY2hlZHVsZXIuXG4gIC8vIFRoaXMgY291cGxlcyBSZWFjdCB0byB0aGUgU2NoZWR1bGVyIGludGVybmFscywgc28gd2UncmUgcmVwbGFjaW5nIGl0XG4gIC8vIHdpdGggdGhlIGN1cnJlbnRVcGRhdGVMYW5lUHJpb3JpdHkgYWJvdmUuIEFzIGFuIGV4YW1wbGUgb2YgaG93IHRoaXNcbiAgLy8gY291bGQgYmUgcHJvYmxlbWF0aWMsIGlmIHdlJ3JlIG5vdCBpbnNpZGUgYFNjaGVkdWxlci5ydW5XaXRoUHJpb3JpdHlgLFxuICAvLyB0aGVuIHdlJ2xsIGdldCB0aGUgcHJpb3JpdHkgb2YgdGhlIGN1cnJlbnQgcnVubmluZyBTY2hlZHVsZXIgdGFzayxcbiAgLy8gd2hpY2ggaXMgcHJvYmFibHkgbm90IHdoYXQgd2Ugd2FudC5cblxuICB2YXIgbGFuZTtcblxuICBpZiAoIC8vIFRPRE86IFRlbXBvcmFyeS4gV2UncmUgcmVtb3ZpbmcgdGhlIGNvbmNlcHQgb2YgZGlzY3JldGUgdXBkYXRlcy5cbiAgKGV4ZWN1dGlvbkNvbnRleHQgJiBEaXNjcmV0ZUV2ZW50Q29udGV4dCkgIT09IE5vQ29udGV4dCAmJiBzY2hlZHVsZXJQcmlvcml0eSA9PT0gVXNlckJsb2NraW5nUHJpb3JpdHkkMikge1xuICAgIGxhbmUgPSBmaW5kVXBkYXRlTGFuZShJbnB1dERpc2NyZXRlTGFuZVByaW9yaXR5LCBjdXJyZW50RXZlbnRXaXBMYW5lcyk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIHNjaGVkdWxlckxhbmVQcmlvcml0eSA9IHNjaGVkdWxlclByaW9yaXR5VG9MYW5lUHJpb3JpdHkoc2NoZWR1bGVyUHJpb3JpdHkpO1xuXG4gICAgbGFuZSA9IGZpbmRVcGRhdGVMYW5lKHNjaGVkdWxlckxhbmVQcmlvcml0eSwgY3VycmVudEV2ZW50V2lwTGFuZXMpO1xuICB9XG5cbiAgcmV0dXJuIGxhbmU7XG59XG5cbmZ1bmN0aW9uIHJlcXVlc3RSZXRyeUxhbmUoZmliZXIpIHtcbiAgLy8gVGhpcyBpcyBhIGZvcmsgb2YgYHJlcXVlc3RVcGRhdGVMYW5lYCBkZXNpZ25lZCBzcGVjaWZpY2FsbHkgZm9yIFN1c3BlbnNlXG4gIC8vIFwicmV0cmllc1wiIOKAlCBhIHNwZWNpYWwgdXBkYXRlIHRoYXQgYXR0ZW1wdHMgdG8gZmxpcCBhIFN1c3BlbnNlIGJvdW5kYXJ5XG4gIC8vIGZyb20gaXRzIHBsYWNlaG9sZGVyIHN0YXRlIHRvIGl0cyBwcmltYXJ5L3Jlc29sdmVkIHN0YXRlLlxuICAvLyBTcGVjaWFsIGNhc2VzXG4gIHZhciBtb2RlID0gZmliZXIubW9kZTtcblxuICBpZiAoKG1vZGUgJiBCbG9ja2luZ01vZGUpID09PSBOb01vZGUpIHtcbiAgICByZXR1cm4gU3luY0xhbmU7XG4gIH0gZWxzZSBpZiAoKG1vZGUgJiBDb25jdXJyZW50TW9kZSkgPT09IE5vTW9kZSkge1xuICAgIHJldHVybiBnZXRDdXJyZW50UHJpb3JpdHlMZXZlbCgpID09PSBJbW1lZGlhdGVQcmlvcml0eSQxID8gU3luY0xhbmUgOiBTeW5jQmF0Y2hlZExhbmU7XG4gIH0gLy8gU2VlIGByZXF1ZXN0VXBkYXRlTGFuZWAgZm9yIGV4cGxhbmF0aW9uIG9mIGBjdXJyZW50RXZlbnRXaXBMYW5lc2BcblxuXG4gIGlmIChjdXJyZW50RXZlbnRXaXBMYW5lcyA9PT0gTm9MYW5lcykge1xuICAgIGN1cnJlbnRFdmVudFdpcExhbmVzID0gd29ya0luUHJvZ3Jlc3NSb290SW5jbHVkZWRMYW5lcztcbiAgfVxuXG4gIHJldHVybiBmaW5kUmV0cnlMYW5lKGN1cnJlbnRFdmVudFdpcExhbmVzKTtcbn1cblxuZnVuY3Rpb24gc2NoZWR1bGVVcGRhdGVPbkZpYmVyKGZpYmVyLCBsYW5lLCBldmVudFRpbWUpIHtcbiAgY2hlY2tGb3JOZXN0ZWRVcGRhdGVzKCk7XG4gIHdhcm5BYm91dFJlbmRlclBoYXNlVXBkYXRlc0luREVWKGZpYmVyKTtcbiAgdmFyIHJvb3QgPSBtYXJrVXBkYXRlTGFuZUZyb21GaWJlclRvUm9vdChmaWJlciwgbGFuZSk7XG5cbiAgaWYgKHJvb3QgPT09IG51bGwpIHtcbiAgICB3YXJuQWJvdXRVcGRhdGVPblVubW91bnRlZEZpYmVySW5ERVYoZmliZXIpO1xuICAgIHJldHVybiBudWxsO1xuICB9IC8vIE1hcmsgdGhhdCB0aGUgcm9vdCBoYXMgYSBwZW5kaW5nIHVwZGF0ZS5cblxuXG4gIG1hcmtSb290VXBkYXRlZChyb290LCBsYW5lLCBldmVudFRpbWUpO1xuXG4gIGlmIChyb290ID09PSB3b3JrSW5Qcm9ncmVzc1Jvb3QpIHtcbiAgICAvLyBSZWNlaXZlZCBhbiB1cGRhdGUgdG8gYSB0cmVlIHRoYXQncyBpbiB0aGUgbWlkZGxlIG9mIHJlbmRlcmluZy4gTWFya1xuICAgIC8vIHRoYXQgdGhlcmUgd2FzIGFuIGludGVybGVhdmVkIHVwZGF0ZSB3b3JrIG9uIHRoaXMgcm9vdC4gVW5sZXNzIHRoZVxuICAgIC8vIGBkZWZlclJlbmRlclBoYXNlVXBkYXRlVG9OZXh0QmF0Y2hgIGZsYWcgaXMgb2ZmIGFuZCB0aGlzIGlzIGEgcmVuZGVyXG4gICAgLy8gcGhhc2UgdXBkYXRlLiBJbiB0aGF0IGNhc2UsIHdlIGRvbid0IHRyZWF0IHJlbmRlciBwaGFzZSB1cGRhdGVzIGFzIGlmXG4gICAgLy8gdGhleSB3ZXJlIGludGVybGVhdmVkLCBmb3IgYmFja3dhcmRzIGNvbXBhdCByZWFzb25zLlxuICAgIHtcbiAgICAgIHdvcmtJblByb2dyZXNzUm9vdFVwZGF0ZWRMYW5lcyA9IG1lcmdlTGFuZXMod29ya0luUHJvZ3Jlc3NSb290VXBkYXRlZExhbmVzLCBsYW5lKTtcbiAgICB9XG5cbiAgICBpZiAod29ya0luUHJvZ3Jlc3NSb290RXhpdFN0YXR1cyA9PT0gUm9vdFN1c3BlbmRlZFdpdGhEZWxheSkge1xuICAgICAgLy8gVGhlIHJvb3QgYWxyZWFkeSBzdXNwZW5kZWQgd2l0aCBhIGRlbGF5LCB3aGljaCBtZWFucyB0aGlzIHJlbmRlclxuICAgICAgLy8gZGVmaW5pdGVseSB3b24ndCBmaW5pc2guIFNpbmNlIHdlIGhhdmUgYSBuZXcgdXBkYXRlLCBsZXQncyBtYXJrIGl0IGFzXG4gICAgICAvLyBzdXNwZW5kZWQgbm93LCByaWdodCBiZWZvcmUgbWFya2luZyB0aGUgaW5jb21pbmcgdXBkYXRlLiBUaGlzIGhhcyB0aGVcbiAgICAgIC8vIGVmZmVjdCBvZiBpbnRlcnJ1cHRpbmcgdGhlIGN1cnJlbnQgcmVuZGVyIGFuZCBzd2l0Y2hpbmcgdG8gdGhlIHVwZGF0ZS5cbiAgICAgIC8vIFRPRE86IE1ha2Ugc3VyZSB0aGlzIGRvZXNuJ3Qgb3ZlcnJpZGUgcGluZ3MgdGhhdCBoYXBwZW4gd2hpbGUgd2UndmVcbiAgICAgIC8vIGFscmVhZHkgc3RhcnRlZCByZW5kZXJpbmcuXG4gICAgICBtYXJrUm9vdFN1c3BlbmRlZCQxKHJvb3QsIHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzKTtcbiAgICB9XG4gIH0gLy8gVE9ETzogcmVxdWVzdFVwZGF0ZUxhbmVQcmlvcml0eSBhbHNvIHJlYWRzIHRoZSBwcmlvcml0eS4gUGFzcyB0aGVcbiAgLy8gcHJpb3JpdHkgYXMgYW4gYXJndW1lbnQgdG8gdGhhdCBmdW5jdGlvbiBhbmQgdGhpcyBvbmUuXG5cblxuICB2YXIgcHJpb3JpdHlMZXZlbCA9IGdldEN1cnJlbnRQcmlvcml0eUxldmVsKCk7XG5cbiAgaWYgKGxhbmUgPT09IFN5bmNMYW5lKSB7XG4gICAgaWYgKCAvLyBDaGVjayBpZiB3ZSdyZSBpbnNpZGUgdW5iYXRjaGVkVXBkYXRlc1xuICAgIChleGVjdXRpb25Db250ZXh0ICYgTGVnYWN5VW5iYXRjaGVkQ29udGV4dCkgIT09IE5vQ29udGV4dCAmJiAvLyBDaGVjayBpZiB3ZSdyZSBub3QgYWxyZWFkeSByZW5kZXJpbmdcbiAgICAoZXhlY3V0aW9uQ29udGV4dCAmIChSZW5kZXJDb250ZXh0IHwgQ29tbWl0Q29udGV4dCkpID09PSBOb0NvbnRleHQpIHtcbiAgICAgIC8vIFJlZ2lzdGVyIHBlbmRpbmcgaW50ZXJhY3Rpb25zIG9uIHRoZSByb290IHRvIGF2b2lkIGxvc2luZyB0cmFjZWQgaW50ZXJhY3Rpb24gZGF0YS5cbiAgICAgIHNjaGVkdWxlUGVuZGluZ0ludGVyYWN0aW9ucyhyb290LCBsYW5lKTsgLy8gVGhpcyBpcyBhIGxlZ2FjeSBlZGdlIGNhc2UuIFRoZSBpbml0aWFsIG1vdW50IG9mIGEgUmVhY3RET00ucmVuZGVyLWVkXG4gICAgICAvLyByb290IGluc2lkZSBvZiBiYXRjaGVkVXBkYXRlcyBzaG91bGQgYmUgc3luY2hyb25vdXMsIGJ1dCBsYXlvdXQgdXBkYXRlc1xuICAgICAgLy8gc2hvdWxkIGJlIGRlZmVycmVkIHVudGlsIHRoZSBlbmQgb2YgdGhlIGJhdGNoLlxuXG4gICAgICBwZXJmb3JtU3luY1dvcmtPblJvb3Qocm9vdCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVuc3VyZVJvb3RJc1NjaGVkdWxlZChyb290LCBldmVudFRpbWUpO1xuICAgICAgc2NoZWR1bGVQZW5kaW5nSW50ZXJhY3Rpb25zKHJvb3QsIGxhbmUpO1xuXG4gICAgICBpZiAoZXhlY3V0aW9uQ29udGV4dCA9PT0gTm9Db250ZXh0KSB7XG4gICAgICAgIC8vIEZsdXNoIHRoZSBzeW5jaHJvbm91cyB3b3JrIG5vdywgdW5sZXNzIHdlJ3JlIGFscmVhZHkgd29ya2luZyBvciBpbnNpZGVcbiAgICAgICAgLy8gYSBiYXRjaC4gVGhpcyBpcyBpbnRlbnRpb25hbGx5IGluc2lkZSBzY2hlZHVsZVVwZGF0ZU9uRmliZXIgaW5zdGVhZCBvZlxuICAgICAgICAvLyBzY2hlZHVsZUNhbGxiYWNrRm9yRmliZXIgdG8gcHJlc2VydmUgdGhlIGFiaWxpdHkgdG8gc2NoZWR1bGUgYSBjYWxsYmFja1xuICAgICAgICAvLyB3aXRob3V0IGltbWVkaWF0ZWx5IGZsdXNoaW5nIGl0LiBXZSBvbmx5IGRvIHRoaXMgZm9yIHVzZXItaW5pdGlhdGVkXG4gICAgICAgIC8vIHVwZGF0ZXMsIHRvIHByZXNlcnZlIGhpc3RvcmljYWwgYmVoYXZpb3Igb2YgbGVnYWN5IG1vZGUuXG4gICAgICAgIHJlc2V0UmVuZGVyVGltZXIoKTtcbiAgICAgICAgZmx1c2hTeW5jQ2FsbGJhY2tRdWV1ZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBTY2hlZHVsZSBhIGRpc2NyZXRlIHVwZGF0ZSBidXQgb25seSBpZiBpdCdzIG5vdCBTeW5jLlxuICAgIGlmICgoZXhlY3V0aW9uQ29udGV4dCAmIERpc2NyZXRlRXZlbnRDb250ZXh0KSAhPT0gTm9Db250ZXh0ICYmICggLy8gT25seSB1cGRhdGVzIGF0IHVzZXItYmxvY2tpbmcgcHJpb3JpdHkgb3IgZ3JlYXRlciBhcmUgY29uc2lkZXJlZFxuICAgIC8vIGRpc2NyZXRlLCBldmVuIGluc2lkZSBhIGRpc2NyZXRlIGV2ZW50LlxuICAgIHByaW9yaXR5TGV2ZWwgPT09IFVzZXJCbG9ja2luZ1ByaW9yaXR5JDIgfHwgcHJpb3JpdHlMZXZlbCA9PT0gSW1tZWRpYXRlUHJpb3JpdHkkMSkpIHtcbiAgICAgIC8vIFRoaXMgaXMgdGhlIHJlc3VsdCBvZiBhIGRpc2NyZXRlIGV2ZW50LiBUcmFjayB0aGUgbG93ZXN0IHByaW9yaXR5XG4gICAgICAvLyBkaXNjcmV0ZSB1cGRhdGUgcGVyIHJvb3Qgc28gd2UgY2FuIGZsdXNoIHRoZW0gZWFybHksIGlmIG5lZWRlZC5cbiAgICAgIGlmIChyb290c1dpdGhQZW5kaW5nRGlzY3JldGVVcGRhdGVzID09PSBudWxsKSB7XG4gICAgICAgIHJvb3RzV2l0aFBlbmRpbmdEaXNjcmV0ZVVwZGF0ZXMgPSBuZXcgU2V0KFtyb290XSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByb290c1dpdGhQZW5kaW5nRGlzY3JldGVVcGRhdGVzLmFkZChyb290KTtcbiAgICAgIH1cbiAgICB9IC8vIFNjaGVkdWxlIG90aGVyIHVwZGF0ZXMgYWZ0ZXIgaW4gY2FzZSB0aGUgY2FsbGJhY2sgaXMgc3luYy5cblxuXG4gICAgZW5zdXJlUm9vdElzU2NoZWR1bGVkKHJvb3QsIGV2ZW50VGltZSk7XG4gICAgc2NoZWR1bGVQZW5kaW5nSW50ZXJhY3Rpb25zKHJvb3QsIGxhbmUpO1xuICB9IC8vIFdlIHVzZSB0aGlzIHdoZW4gYXNzaWduaW5nIGEgbGFuZSBmb3IgYSB0cmFuc2l0aW9uIGluc2lkZVxuICAvLyBgcmVxdWVzdFVwZGF0ZUxhbmVgLiBXZSBhc3N1bWUgaXQncyB0aGUgc2FtZSBhcyB0aGUgcm9vdCBiZWluZyB1cGRhdGVkLFxuICAvLyBzaW5jZSBpbiB0aGUgY29tbW9uIGNhc2Ugb2YgYSBzaW5nbGUgcm9vdCBhcHAgaXQgcHJvYmFibHkgaXMuIElmIGl0J3Mgbm90XG4gIC8vIHRoZSBzYW1lIHJvb3QsIHRoZW4gaXQncyBub3QgYSBodWdlIGRlYWwsIHdlIGp1c3QgbWlnaHQgYmF0Y2ggbW9yZSBzdHVmZlxuICAvLyB0b2dldGhlciBtb3JlIHRoYW4gbmVjZXNzYXJ5LlxuXG5cbiAgbW9zdFJlY2VudGx5VXBkYXRlZFJvb3QgPSByb290O1xufSAvLyBUaGlzIGlzIHNwbGl0IGludG8gYSBzZXBhcmF0ZSBmdW5jdGlvbiBzbyB3ZSBjYW4gbWFyayBhIGZpYmVyIHdpdGggcGVuZGluZ1xuLy8gd29yayB3aXRob3V0IHRyZWF0aW5nIGl0IGFzIGEgdHlwaWNhbCB1cGRhdGUgdGhhdCBvcmlnaW5hdGVzIGZyb20gYW4gZXZlbnQ7XG4vLyBlLmcuIHJldHJ5aW5nIGEgU3VzcGVuc2UgYm91bmRhcnkgaXNuJ3QgYW4gdXBkYXRlLCBidXQgaXQgZG9lcyBzY2hlZHVsZSB3b3JrXG4vLyBvbiBhIGZpYmVyLlxuXG5mdW5jdGlvbiBtYXJrVXBkYXRlTGFuZUZyb21GaWJlclRvUm9vdChzb3VyY2VGaWJlciwgbGFuZSkge1xuICAvLyBVcGRhdGUgdGhlIHNvdXJjZSBmaWJlcidzIGxhbmVzXG4gIHNvdXJjZUZpYmVyLmxhbmVzID0gbWVyZ2VMYW5lcyhzb3VyY2VGaWJlci5sYW5lcywgbGFuZSk7XG4gIHZhciBhbHRlcm5hdGUgPSBzb3VyY2VGaWJlci5hbHRlcm5hdGU7XG5cbiAgaWYgKGFsdGVybmF0ZSAhPT0gbnVsbCkge1xuICAgIGFsdGVybmF0ZS5sYW5lcyA9IG1lcmdlTGFuZXMoYWx0ZXJuYXRlLmxhbmVzLCBsYW5lKTtcbiAgfVxuXG4gIHtcbiAgICBpZiAoYWx0ZXJuYXRlID09PSBudWxsICYmIChzb3VyY2VGaWJlci5mbGFncyAmIChQbGFjZW1lbnQgfCBIeWRyYXRpbmcpKSAhPT0gTm9GbGFncykge1xuICAgICAgd2FybkFib3V0VXBkYXRlT25Ob3RZZXRNb3VudGVkRmliZXJJbkRFVihzb3VyY2VGaWJlcik7XG4gICAgfVxuICB9IC8vIFdhbGsgdGhlIHBhcmVudCBwYXRoIHRvIHRoZSByb290IGFuZCB1cGRhdGUgdGhlIGNoaWxkIGV4cGlyYXRpb24gdGltZS5cblxuXG4gIHZhciBub2RlID0gc291cmNlRmliZXI7XG4gIHZhciBwYXJlbnQgPSBzb3VyY2VGaWJlci5yZXR1cm47XG5cbiAgd2hpbGUgKHBhcmVudCAhPT0gbnVsbCkge1xuICAgIHBhcmVudC5jaGlsZExhbmVzID0gbWVyZ2VMYW5lcyhwYXJlbnQuY2hpbGRMYW5lcywgbGFuZSk7XG4gICAgYWx0ZXJuYXRlID0gcGFyZW50LmFsdGVybmF0ZTtcblxuICAgIGlmIChhbHRlcm5hdGUgIT09IG51bGwpIHtcbiAgICAgIGFsdGVybmF0ZS5jaGlsZExhbmVzID0gbWVyZ2VMYW5lcyhhbHRlcm5hdGUuY2hpbGRMYW5lcywgbGFuZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHtcbiAgICAgICAgaWYgKChwYXJlbnQuZmxhZ3MgJiAoUGxhY2VtZW50IHwgSHlkcmF0aW5nKSkgIT09IE5vRmxhZ3MpIHtcbiAgICAgICAgICB3YXJuQWJvdXRVcGRhdGVPbk5vdFlldE1vdW50ZWRGaWJlckluREVWKHNvdXJjZUZpYmVyKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIG5vZGUgPSBwYXJlbnQ7XG4gICAgcGFyZW50ID0gcGFyZW50LnJldHVybjtcbiAgfVxuXG4gIGlmIChub2RlLnRhZyA9PT0gSG9zdFJvb3QpIHtcbiAgICB2YXIgcm9vdCA9IG5vZGUuc3RhdGVOb2RlO1xuICAgIHJldHVybiByb290O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBudWxsO1xuICB9XG59IC8vIFVzZSB0aGlzIGZ1bmN0aW9uIHRvIHNjaGVkdWxlIGEgdGFzayBmb3IgYSByb290LiBUaGVyZSdzIG9ubHkgb25lIHRhc2sgcGVyXG4vLyByb290OyBpZiBhIHRhc2sgd2FzIGFscmVhZHkgc2NoZWR1bGVkLCB3ZSdsbCBjaGVjayB0byBtYWtlIHN1cmUgdGhlIHByaW9yaXR5XG4vLyBvZiB0aGUgZXhpc3RpbmcgdGFzayBpcyB0aGUgc2FtZSBhcyB0aGUgcHJpb3JpdHkgb2YgdGhlIG5leHQgbGV2ZWwgdGhhdCB0aGVcbi8vIHJvb3QgaGFzIHdvcmsgb24uIFRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIG9uIGV2ZXJ5IHVwZGF0ZSwgYW5kIHJpZ2h0IGJlZm9yZVxuLy8gZXhpdGluZyBhIHRhc2suXG5cblxuZnVuY3Rpb24gZW5zdXJlUm9vdElzU2NoZWR1bGVkKHJvb3QsIGN1cnJlbnRUaW1lKSB7XG4gIHZhciBleGlzdGluZ0NhbGxiYWNrTm9kZSA9IHJvb3QuY2FsbGJhY2tOb2RlOyAvLyBDaGVjayBpZiBhbnkgbGFuZXMgYXJlIGJlaW5nIHN0YXJ2ZWQgYnkgb3RoZXIgd29yay4gSWYgc28sIG1hcmsgdGhlbSBhc1xuICAvLyBleHBpcmVkIHNvIHdlIGtub3cgdG8gd29yayBvbiB0aG9zZSBuZXh0LlxuXG4gIG1hcmtTdGFydmVkTGFuZXNBc0V4cGlyZWQocm9vdCwgY3VycmVudFRpbWUpOyAvLyBEZXRlcm1pbmUgdGhlIG5leHQgbGFuZXMgdG8gd29yayBvbiwgYW5kIHRoZWlyIHByaW9yaXR5LlxuXG4gIHZhciBuZXh0TGFuZXMgPSBnZXROZXh0TGFuZXMocm9vdCwgcm9vdCA9PT0gd29ya0luUHJvZ3Jlc3NSb290ID8gd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMgOiBOb0xhbmVzKTsgLy8gVGhpcyByZXR1cm5zIHRoZSBwcmlvcml0eSBsZXZlbCBjb21wdXRlZCBkdXJpbmcgdGhlIGBnZXROZXh0TGFuZXNgIGNhbGwuXG5cbiAgdmFyIG5ld0NhbGxiYWNrUHJpb3JpdHkgPSByZXR1cm5OZXh0TGFuZXNQcmlvcml0eSgpO1xuXG4gIGlmIChuZXh0TGFuZXMgPT09IE5vTGFuZXMpIHtcbiAgICAvLyBTcGVjaWFsIGNhc2U6IFRoZXJlJ3Mgbm90aGluZyB0byB3b3JrIG9uLlxuICAgIGlmIChleGlzdGluZ0NhbGxiYWNrTm9kZSAhPT0gbnVsbCkge1xuICAgICAgY2FuY2VsQ2FsbGJhY2soZXhpc3RpbmdDYWxsYmFja05vZGUpO1xuICAgICAgcm9vdC5jYWxsYmFja05vZGUgPSBudWxsO1xuICAgICAgcm9vdC5jYWxsYmFja1ByaW9yaXR5ID0gTm9MYW5lUHJpb3JpdHk7XG4gICAgfVxuXG4gICAgcmV0dXJuO1xuICB9IC8vIENoZWNrIGlmIHRoZXJlJ3MgYW4gZXhpc3RpbmcgdGFzay4gV2UgbWF5IGJlIGFibGUgdG8gcmV1c2UgaXQuXG5cblxuICBpZiAoZXhpc3RpbmdDYWxsYmFja05vZGUgIT09IG51bGwpIHtcbiAgICB2YXIgZXhpc3RpbmdDYWxsYmFja1ByaW9yaXR5ID0gcm9vdC5jYWxsYmFja1ByaW9yaXR5O1xuXG4gICAgaWYgKGV4aXN0aW5nQ2FsbGJhY2tQcmlvcml0eSA9PT0gbmV3Q2FsbGJhY2tQcmlvcml0eSkge1xuICAgICAgLy8gVGhlIHByaW9yaXR5IGhhc24ndCBjaGFuZ2VkLiBXZSBjYW4gcmV1c2UgdGhlIGV4aXN0aW5nIHRhc2suIEV4aXQuXG4gICAgICByZXR1cm47XG4gICAgfSAvLyBUaGUgcHJpb3JpdHkgY2hhbmdlZC4gQ2FuY2VsIHRoZSBleGlzdGluZyBjYWxsYmFjay4gV2UnbGwgc2NoZWR1bGUgYSBuZXdcbiAgICAvLyBvbmUgYmVsb3cuXG5cblxuICAgIGNhbmNlbENhbGxiYWNrKGV4aXN0aW5nQ2FsbGJhY2tOb2RlKTtcbiAgfSAvLyBTY2hlZHVsZSBhIG5ldyBjYWxsYmFjay5cblxuXG4gIHZhciBuZXdDYWxsYmFja05vZGU7XG5cbiAgaWYgKG5ld0NhbGxiYWNrUHJpb3JpdHkgPT09IFN5bmNMYW5lUHJpb3JpdHkpIHtcbiAgICAvLyBTcGVjaWFsIGNhc2U6IFN5bmMgUmVhY3QgY2FsbGJhY2tzIGFyZSBzY2hlZHVsZWQgb24gYSBzcGVjaWFsXG4gICAgLy8gaW50ZXJuYWwgcXVldWVcbiAgICBuZXdDYWxsYmFja05vZGUgPSBzY2hlZHVsZVN5bmNDYWxsYmFjayhwZXJmb3JtU3luY1dvcmtPblJvb3QuYmluZChudWxsLCByb290KSk7XG4gIH0gZWxzZSBpZiAobmV3Q2FsbGJhY2tQcmlvcml0eSA9PT0gU3luY0JhdGNoZWRMYW5lUHJpb3JpdHkpIHtcbiAgICBuZXdDYWxsYmFja05vZGUgPSBzY2hlZHVsZUNhbGxiYWNrKEltbWVkaWF0ZVByaW9yaXR5JDEsIHBlcmZvcm1TeW5jV29ya09uUm9vdC5iaW5kKG51bGwsIHJvb3QpKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgc2NoZWR1bGVyUHJpb3JpdHlMZXZlbCA9IGxhbmVQcmlvcml0eVRvU2NoZWR1bGVyUHJpb3JpdHkobmV3Q2FsbGJhY2tQcmlvcml0eSk7XG4gICAgbmV3Q2FsbGJhY2tOb2RlID0gc2NoZWR1bGVDYWxsYmFjayhzY2hlZHVsZXJQcmlvcml0eUxldmVsLCBwZXJmb3JtQ29uY3VycmVudFdvcmtPblJvb3QuYmluZChudWxsLCByb290KSk7XG4gIH1cblxuICByb290LmNhbGxiYWNrUHJpb3JpdHkgPSBuZXdDYWxsYmFja1ByaW9yaXR5O1xuICByb290LmNhbGxiYWNrTm9kZSA9IG5ld0NhbGxiYWNrTm9kZTtcbn0gLy8gVGhpcyBpcyB0aGUgZW50cnkgcG9pbnQgZm9yIGV2ZXJ5IGNvbmN1cnJlbnQgdGFzaywgaS5lLiBhbnl0aGluZyB0aGF0XG4vLyBnb2VzIHRocm91Z2ggU2NoZWR1bGVyLlxuXG5cbmZ1bmN0aW9uIHBlcmZvcm1Db25jdXJyZW50V29ya09uUm9vdChyb290KSB7XG4gIC8vIFNpbmNlIHdlIGtub3cgd2UncmUgaW4gYSBSZWFjdCBldmVudCwgd2UgY2FuIGNsZWFyIHRoZSBjdXJyZW50XG4gIC8vIGV2ZW50IHRpbWUuIFRoZSBuZXh0IHVwZGF0ZSB3aWxsIGNvbXB1dGUgYSBuZXcgZXZlbnQgdGltZS5cbiAgY3VycmVudEV2ZW50VGltZSA9IE5vVGltZXN0YW1wO1xuICBjdXJyZW50RXZlbnRXaXBMYW5lcyA9IE5vTGFuZXM7XG4gIGN1cnJlbnRFdmVudFBlbmRpbmdMYW5lcyA9IE5vTGFuZXM7XG5cbiAgaWYgKCEoKGV4ZWN1dGlvbkNvbnRleHQgJiAoUmVuZGVyQ29udGV4dCB8IENvbW1pdENvbnRleHQpKSA9PT0gTm9Db250ZXh0KSkge1xuICAgIHtcbiAgICAgIHRocm93IEVycm9yKCBcIlNob3VsZCBub3QgYWxyZWFkeSBiZSB3b3JraW5nLlwiICk7XG4gICAgfVxuICB9IC8vIEZsdXNoIGFueSBwZW5kaW5nIHBhc3NpdmUgZWZmZWN0cyBiZWZvcmUgZGVjaWRpbmcgd2hpY2ggbGFuZXMgdG8gd29yayBvbixcbiAgLy8gaW4gY2FzZSB0aGV5IHNjaGVkdWxlIGFkZGl0aW9uYWwgd29yay5cblxuXG4gIHZhciBvcmlnaW5hbENhbGxiYWNrTm9kZSA9IHJvb3QuY2FsbGJhY2tOb2RlO1xuICB2YXIgZGlkRmx1c2hQYXNzaXZlRWZmZWN0cyA9IGZsdXNoUGFzc2l2ZUVmZmVjdHMoKTtcblxuICBpZiAoZGlkRmx1c2hQYXNzaXZlRWZmZWN0cykge1xuICAgIC8vIFNvbWV0aGluZyBpbiB0aGUgcGFzc2l2ZSBlZmZlY3QgcGhhc2UgbWF5IGhhdmUgY2FuY2VsZWQgdGhlIGN1cnJlbnQgdGFzay5cbiAgICAvLyBDaGVjayBpZiB0aGUgdGFzayBub2RlIGZvciB0aGlzIHJvb3Qgd2FzIGNoYW5nZWQuXG4gICAgaWYgKHJvb3QuY2FsbGJhY2tOb2RlICE9PSBvcmlnaW5hbENhbGxiYWNrTm9kZSkge1xuICAgICAgLy8gVGhlIGN1cnJlbnQgdGFzayB3YXMgY2FuY2VsZWQuIEV4aXQuIFdlIGRvbid0IG5lZWQgdG8gY2FsbFxuICAgICAgLy8gYGVuc3VyZVJvb3RJc1NjaGVkdWxlZGAgYmVjYXVzZSB0aGUgY2hlY2sgYWJvdmUgaW1wbGllcyBlaXRoZXIgdGhhdFxuICAgICAgLy8gdGhlcmUncyBhIG5ldyB0YXNrLCBvciB0aGF0IHRoZXJlJ3Mgbm8gcmVtYWluaW5nIHdvcmsgb24gdGhpcyByb290LlxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9IC8vIERldGVybWluZSB0aGUgbmV4dCBleHBpcmF0aW9uIHRpbWUgdG8gd29yayBvbiwgdXNpbmcgdGhlIGZpZWxkcyBzdG9yZWRcbiAgLy8gb24gdGhlIHJvb3QuXG5cblxuICB2YXIgbGFuZXMgPSBnZXROZXh0TGFuZXMocm9vdCwgcm9vdCA9PT0gd29ya0luUHJvZ3Jlc3NSb290ID8gd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMgOiBOb0xhbmVzKTtcblxuICBpZiAobGFuZXMgPT09IE5vTGFuZXMpIHtcbiAgICAvLyBEZWZlbnNpdmUgY29kaW5nLiBUaGlzIGlzIG5ldmVyIGV4cGVjdGVkIHRvIGhhcHBlbi5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBleGl0U3RhdHVzID0gcmVuZGVyUm9vdENvbmN1cnJlbnQocm9vdCwgbGFuZXMpO1xuXG4gIGlmIChpbmNsdWRlc1NvbWVMYW5lKHdvcmtJblByb2dyZXNzUm9vdEluY2x1ZGVkTGFuZXMsIHdvcmtJblByb2dyZXNzUm9vdFVwZGF0ZWRMYW5lcykpIHtcbiAgICAvLyBUaGUgcmVuZGVyIGluY2x1ZGVkIGxhbmVzIHRoYXQgd2VyZSB1cGRhdGVkIGR1cmluZyB0aGUgcmVuZGVyIHBoYXNlLlxuICAgIC8vIEZvciBleGFtcGxlLCB3aGVuIHVuaGlkaW5nIGEgaGlkZGVuIHRyZWUsIHdlIGluY2x1ZGUgYWxsIHRoZSBsYW5lc1xuICAgIC8vIHRoYXQgd2VyZSBwcmV2aW91c2x5IHNraXBwZWQgd2hlbiB0aGUgdHJlZSB3YXMgaGlkZGVuLiBUaGF0IHNldCBvZlxuICAgIC8vIGxhbmVzIGlzIGEgc3VwZXJzZXQgb2YgdGhlIGxhbmVzIHdlIHN0YXJ0ZWQgcmVuZGVyaW5nIHdpdGguXG4gICAgLy9cbiAgICAvLyBTbyB3ZSdsbCB0aHJvdyBvdXQgdGhlIGN1cnJlbnQgd29yayBhbmQgcmVzdGFydC5cbiAgICBwcmVwYXJlRnJlc2hTdGFjayhyb290LCBOb0xhbmVzKTtcbiAgfSBlbHNlIGlmIChleGl0U3RhdHVzICE9PSBSb290SW5jb21wbGV0ZSkge1xuICAgIGlmIChleGl0U3RhdHVzID09PSBSb290RXJyb3JlZCkge1xuICAgICAgZXhlY3V0aW9uQ29udGV4dCB8PSBSZXRyeUFmdGVyRXJyb3I7IC8vIElmIGFuIGVycm9yIG9jY3VycmVkIGR1cmluZyBoeWRyYXRpb24sXG4gICAgICAvLyBkaXNjYXJkIHNlcnZlciByZXNwb25zZSBhbmQgZmFsbCBiYWNrIHRvIGNsaWVudCBzaWRlIHJlbmRlci5cblxuICAgICAgaWYgKHJvb3QuaHlkcmF0ZSkge1xuICAgICAgICByb290Lmh5ZHJhdGUgPSBmYWxzZTtcbiAgICAgICAgY2xlYXJDb250YWluZXIocm9vdC5jb250YWluZXJJbmZvKTtcbiAgICAgIH0gLy8gSWYgc29tZXRoaW5nIHRocmV3IGFuIGVycm9yLCB0cnkgcmVuZGVyaW5nIG9uZSBtb3JlIHRpbWUuIFdlJ2xsIHJlbmRlclxuICAgICAgLy8gc3luY2hyb25vdXNseSB0byBibG9jayBjb25jdXJyZW50IGRhdGEgbXV0YXRpb25zLCBhbmQgd2UnbGwgaW5jbHVkZXNcbiAgICAgIC8vIGFsbCBwZW5kaW5nIHVwZGF0ZXMgYXJlIGluY2x1ZGVkLiBJZiBpdCBzdGlsbCBmYWlscyBhZnRlciB0aGUgc2Vjb25kXG4gICAgICAvLyBhdHRlbXB0LCB3ZSdsbCBnaXZlIHVwIGFuZCBjb21taXQgdGhlIHJlc3VsdGluZyB0cmVlLlxuXG5cbiAgICAgIGxhbmVzID0gZ2V0TGFuZXNUb1JldHJ5U3luY2hyb25vdXNseU9uRXJyb3Iocm9vdCk7XG5cbiAgICAgIGlmIChsYW5lcyAhPT0gTm9MYW5lcykge1xuICAgICAgICBleGl0U3RhdHVzID0gcmVuZGVyUm9vdFN5bmMocm9vdCwgbGFuZXMpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChleGl0U3RhdHVzID09PSBSb290RmF0YWxFcnJvcmVkKSB7XG4gICAgICB2YXIgZmF0YWxFcnJvciA9IHdvcmtJblByb2dyZXNzUm9vdEZhdGFsRXJyb3I7XG4gICAgICBwcmVwYXJlRnJlc2hTdGFjayhyb290LCBOb0xhbmVzKTtcbiAgICAgIG1hcmtSb290U3VzcGVuZGVkJDEocm9vdCwgbGFuZXMpO1xuICAgICAgZW5zdXJlUm9vdElzU2NoZWR1bGVkKHJvb3QsIG5vdygpKTtcbiAgICAgIHRocm93IGZhdGFsRXJyb3I7XG4gICAgfSAvLyBXZSBub3cgaGF2ZSBhIGNvbnNpc3RlbnQgdHJlZS4gVGhlIG5leHQgc3RlcCBpcyBlaXRoZXIgdG8gY29tbWl0IGl0LFxuICAgIC8vIG9yLCBpZiBzb21ldGhpbmcgc3VzcGVuZGVkLCB3YWl0IHRvIGNvbW1pdCBpdCBhZnRlciBhIHRpbWVvdXQuXG5cblxuICAgIHZhciBmaW5pc2hlZFdvcmsgPSByb290LmN1cnJlbnQuYWx0ZXJuYXRlO1xuICAgIHJvb3QuZmluaXNoZWRXb3JrID0gZmluaXNoZWRXb3JrO1xuICAgIHJvb3QuZmluaXNoZWRMYW5lcyA9IGxhbmVzO1xuICAgIGZpbmlzaENvbmN1cnJlbnRSZW5kZXIocm9vdCwgZXhpdFN0YXR1cywgbGFuZXMpO1xuICB9XG5cbiAgZW5zdXJlUm9vdElzU2NoZWR1bGVkKHJvb3QsIG5vdygpKTtcblxuICBpZiAocm9vdC5jYWxsYmFja05vZGUgPT09IG9yaWdpbmFsQ2FsbGJhY2tOb2RlKSB7XG4gICAgLy8gVGhlIHRhc2sgbm9kZSBzY2hlZHVsZWQgZm9yIHRoaXMgcm9vdCBpcyB0aGUgc2FtZSBvbmUgdGhhdCdzXG4gICAgLy8gY3VycmVudGx5IGV4ZWN1dGVkLiBOZWVkIHRvIHJldHVybiBhIGNvbnRpbnVhdGlvbi5cbiAgICByZXR1cm4gcGVyZm9ybUNvbmN1cnJlbnRXb3JrT25Sb290LmJpbmQobnVsbCwgcm9vdCk7XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gZmluaXNoQ29uY3VycmVudFJlbmRlcihyb290LCBleGl0U3RhdHVzLCBsYW5lcykge1xuICBzd2l0Y2ggKGV4aXRTdGF0dXMpIHtcbiAgICBjYXNlIFJvb3RJbmNvbXBsZXRlOlxuICAgIGNhc2UgUm9vdEZhdGFsRXJyb3JlZDpcbiAgICAgIHtcbiAgICAgICAge1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKCBcIlJvb3QgZGlkIG5vdCBjb21wbGV0ZS4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC5cIiApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIC8vIEZsb3cga25vd3MgYWJvdXQgaW52YXJpYW50LCBzbyBpdCBjb21wbGFpbnMgaWYgSSBhZGQgYSBicmVha1xuICAgIC8vIHN0YXRlbWVudCwgYnV0IGVzbGludCBkb2Vzbid0IGtub3cgYWJvdXQgaW52YXJpYW50LCBzbyBpdCBjb21wbGFpbnNcbiAgICAvLyBpZiBJIGRvLiBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZmFsbHRocm91Z2hcblxuICAgIGNhc2UgUm9vdEVycm9yZWQ6XG4gICAgICB7XG4gICAgICAgIC8vIFdlIHNob3VsZCBoYXZlIGFscmVhZHkgYXR0ZW1wdGVkIHRvIHJldHJ5IHRoaXMgdHJlZS4gSWYgd2UgcmVhY2hlZFxuICAgICAgICAvLyB0aGlzIHBvaW50LCBpdCBlcnJvcmVkIGFnYWluLiBDb21taXQgaXQuXG4gICAgICAgIGNvbW1pdFJvb3Qocm9vdCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgY2FzZSBSb290U3VzcGVuZGVkOlxuICAgICAge1xuICAgICAgICBtYXJrUm9vdFN1c3BlbmRlZCQxKHJvb3QsIGxhbmVzKTsgLy8gV2UgaGF2ZSBhbiBhY2NlcHRhYmxlIGxvYWRpbmcgc3RhdGUuIFdlIG5lZWQgdG8gZmlndXJlIG91dCBpZiB3ZVxuICAgICAgICAvLyBzaG91bGQgaW1tZWRpYXRlbHkgY29tbWl0IGl0IG9yIHdhaXQgYSBiaXQuXG5cbiAgICAgICAgaWYgKGluY2x1ZGVzT25seVJldHJpZXMobGFuZXMpICYmIC8vIGRvIG5vdCBkZWxheSBpZiB3ZSdyZSBpbnNpZGUgYW4gYWN0KCkgc2NvcGVcbiAgICAgICAgIXNob3VsZEZvcmNlRmx1c2hGYWxsYmFja3NJbkRFVigpKSB7XG4gICAgICAgICAgLy8gVGhpcyByZW5kZXIgb25seSBpbmNsdWRlZCByZXRyaWVzLCBubyB1cGRhdGVzLiBUaHJvdHRsZSBjb21taXR0aW5nXG4gICAgICAgICAgLy8gcmV0cmllcyBzbyB0aGF0IHdlIGRvbid0IHNob3cgdG9vIG1hbnkgbG9hZGluZyBzdGF0ZXMgdG9vIHF1aWNrbHkuXG4gICAgICAgICAgdmFyIG1zVW50aWxUaW1lb3V0ID0gZ2xvYmFsTW9zdFJlY2VudEZhbGxiYWNrVGltZSArIEZBTExCQUNLX1RIUk9UVExFX01TIC0gbm93KCk7IC8vIERvbid0IGJvdGhlciB3aXRoIGEgdmVyeSBzaG9ydCBzdXNwZW5zZSB0aW1lLlxuXG4gICAgICAgICAgaWYgKG1zVW50aWxUaW1lb3V0ID4gMTApIHtcbiAgICAgICAgICAgIHZhciBuZXh0TGFuZXMgPSBnZXROZXh0TGFuZXMocm9vdCwgTm9MYW5lcyk7XG5cbiAgICAgICAgICAgIGlmIChuZXh0TGFuZXMgIT09IE5vTGFuZXMpIHtcbiAgICAgICAgICAgICAgLy8gVGhlcmUncyBhZGRpdGlvbmFsIHdvcmsgb24gdGhpcyByb290LlxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHN1c3BlbmRlZExhbmVzID0gcm9vdC5zdXNwZW5kZWRMYW5lcztcblxuICAgICAgICAgICAgaWYgKCFpc1N1YnNldE9mTGFuZXMoc3VzcGVuZGVkTGFuZXMsIGxhbmVzKSkge1xuICAgICAgICAgICAgICAvLyBXZSBzaG91bGQgcHJlZmVyIHRvIHJlbmRlciB0aGUgZmFsbGJhY2sgb2YgYXQgdGhlIGxhc3RcbiAgICAgICAgICAgICAgLy8gc3VzcGVuZGVkIGxldmVsLiBQaW5nIHRoZSBsYXN0IHN1c3BlbmRlZCBsZXZlbCB0byB0cnlcbiAgICAgICAgICAgICAgLy8gcmVuZGVyaW5nIGl0IGFnYWluLlxuICAgICAgICAgICAgICAvLyBGSVhNRTogV2hhdCBpZiB0aGUgc3VzcGVuZGVkIGxhbmVzIGFyZSBJZGxlPyBTaG91bGQgbm90IHJlc3RhcnQuXG4gICAgICAgICAgICAgIHZhciBldmVudFRpbWUgPSByZXF1ZXN0RXZlbnRUaW1lKCk7XG4gICAgICAgICAgICAgIG1hcmtSb290UGluZ2VkKHJvb3QsIHN1c3BlbmRlZExhbmVzKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9IC8vIFRoZSByZW5kZXIgaXMgc3VzcGVuZGVkLCBpdCBoYXNuJ3QgdGltZWQgb3V0LCBhbmQgdGhlcmUncyBub1xuICAgICAgICAgICAgLy8gbG93ZXIgcHJpb3JpdHkgd29yayB0byBkby4gSW5zdGVhZCBvZiBjb21taXR0aW5nIHRoZSBmYWxsYmFja1xuICAgICAgICAgICAgLy8gaW1tZWRpYXRlbHksIHdhaXQgZm9yIG1vcmUgZGF0YSB0byBhcnJpdmUuXG5cblxuICAgICAgICAgICAgcm9vdC50aW1lb3V0SGFuZGxlID0gc2NoZWR1bGVUaW1lb3V0KGNvbW1pdFJvb3QuYmluZChudWxsLCByb290KSwgbXNVbnRpbFRpbWVvdXQpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9IC8vIFRoZSB3b3JrIGV4cGlyZWQuIENvbW1pdCBpbW1lZGlhdGVseS5cblxuXG4gICAgICAgIGNvbW1pdFJvb3Qocm9vdCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgY2FzZSBSb290U3VzcGVuZGVkV2l0aERlbGF5OlxuICAgICAge1xuICAgICAgICBtYXJrUm9vdFN1c3BlbmRlZCQxKHJvb3QsIGxhbmVzKTtcblxuICAgICAgICBpZiAoaW5jbHVkZXNPbmx5VHJhbnNpdGlvbnMobGFuZXMpKSB7XG4gICAgICAgICAgLy8gVGhpcyBpcyBhIHRyYW5zaXRpb24sIHNvIHdlIHNob3VsZCBleGl0IHdpdGhvdXQgY29tbWl0dGluZyBhXG4gICAgICAgICAgLy8gcGxhY2Vob2xkZXIgYW5kIHdpdGhvdXQgc2NoZWR1bGluZyBhIHRpbWVvdXQuIERlbGF5IGluZGVmaW5pdGVseVxuICAgICAgICAgIC8vIHVudGlsIHdlIHJlY2VpdmUgbW9yZSBkYXRhLlxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFzaG91bGRGb3JjZUZsdXNoRmFsbGJhY2tzSW5ERVYoKSkge1xuICAgICAgICAgIC8vIFRoaXMgaXMgbm90IGEgdHJhbnNpdGlvbiwgYnV0IHdlIGRpZCB0cmlnZ2VyIGFuIGF2b2lkZWQgc3RhdGUuXG4gICAgICAgICAgLy8gU2NoZWR1bGUgYSBwbGFjZWhvbGRlciB0byBkaXNwbGF5IGFmdGVyIGEgc2hvcnQgZGVsYXksIHVzaW5nIHRoZSBKdXN0XG4gICAgICAgICAgLy8gTm90aWNlYWJsZSBEaWZmZXJlbmNlLlxuICAgICAgICAgIC8vIFRPRE86IElzIHRoZSBKTkQgb3B0aW1pemF0aW9uIHdvcnRoIHRoZSBhZGRlZCBjb21wbGV4aXR5PyBJZiB0aGlzIGlzXG4gICAgICAgICAgLy8gdGhlIG9ubHkgcmVhc29uIHdlIHRyYWNrIHRoZSBldmVudCB0aW1lLCB0aGVuIHByb2JhYmx5IG5vdC5cbiAgICAgICAgICAvLyBDb25zaWRlciByZW1vdmluZy5cbiAgICAgICAgICB2YXIgbW9zdFJlY2VudEV2ZW50VGltZSA9IGdldE1vc3RSZWNlbnRFdmVudFRpbWUocm9vdCwgbGFuZXMpO1xuICAgICAgICAgIHZhciBldmVudFRpbWVNcyA9IG1vc3RSZWNlbnRFdmVudFRpbWU7XG4gICAgICAgICAgdmFyIHRpbWVFbGFwc2VkTXMgPSBub3coKSAtIGV2ZW50VGltZU1zO1xuXG4gICAgICAgICAgdmFyIF9tc1VudGlsVGltZW91dCA9IGpuZCh0aW1lRWxhcHNlZE1zKSAtIHRpbWVFbGFwc2VkTXM7IC8vIERvbid0IGJvdGhlciB3aXRoIGEgdmVyeSBzaG9ydCBzdXNwZW5zZSB0aW1lLlxuXG5cbiAgICAgICAgICBpZiAoX21zVW50aWxUaW1lb3V0ID4gMTApIHtcbiAgICAgICAgICAgIC8vIEluc3RlYWQgb2YgY29tbWl0dGluZyB0aGUgZmFsbGJhY2sgaW1tZWRpYXRlbHksIHdhaXQgZm9yIG1vcmUgZGF0YVxuICAgICAgICAgICAgLy8gdG8gYXJyaXZlLlxuICAgICAgICAgICAgcm9vdC50aW1lb3V0SGFuZGxlID0gc2NoZWR1bGVUaW1lb3V0KGNvbW1pdFJvb3QuYmluZChudWxsLCByb290KSwgX21zVW50aWxUaW1lb3V0KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfSAvLyBDb21taXQgdGhlIHBsYWNlaG9sZGVyLlxuXG5cbiAgICAgICAgY29tbWl0Um9vdChyb290KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICBjYXNlIFJvb3RDb21wbGV0ZWQ6XG4gICAgICB7XG4gICAgICAgIC8vIFRoZSB3b3JrIGNvbXBsZXRlZC4gUmVhZHkgdG8gY29tbWl0LlxuICAgICAgICBjb21taXRSb290KHJvb3QpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgIGRlZmF1bHQ6XG4gICAgICB7XG4gICAgICAgIHtcbiAgICAgICAgICB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvciggXCJVbmtub3duIHJvb3QgZXhpdCBzdGF0dXMuXCIgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBtYXJrUm9vdFN1c3BlbmRlZCQxKHJvb3QsIHN1c3BlbmRlZExhbmVzKSB7XG4gIC8vIFdoZW4gc3VzcGVuZGluZywgd2Ugc2hvdWxkIGFsd2F5cyBleGNsdWRlIGxhbmVzIHRoYXQgd2VyZSBwaW5nZWQgb3IgKG1vcmVcbiAgLy8gcmFyZWx5LCBzaW5jZSB3ZSB0cnkgdG8gYXZvaWQgaXQpIHVwZGF0ZWQgZHVyaW5nIHRoZSByZW5kZXIgcGhhc2UuXG4gIC8vIFRPRE86IExvbCBtYXliZSB0aGVyZSdzIGEgYmV0dGVyIHdheSB0byBmYWN0b3IgdGhpcyBiZXNpZGVzIHRoaXNcbiAgLy8gb2Jub3hpb3VzbHkgbmFtZWQgZnVuY3Rpb24gOilcbiAgc3VzcGVuZGVkTGFuZXMgPSByZW1vdmVMYW5lcyhzdXNwZW5kZWRMYW5lcywgd29ya0luUHJvZ3Jlc3NSb290UGluZ2VkTGFuZXMpO1xuICBzdXNwZW5kZWRMYW5lcyA9IHJlbW92ZUxhbmVzKHN1c3BlbmRlZExhbmVzLCB3b3JrSW5Qcm9ncmVzc1Jvb3RVcGRhdGVkTGFuZXMpO1xuICBtYXJrUm9vdFN1c3BlbmRlZChyb290LCBzdXNwZW5kZWRMYW5lcyk7XG59IC8vIFRoaXMgaXMgdGhlIGVudHJ5IHBvaW50IGZvciBzeW5jaHJvbm91cyB0YXNrcyB0aGF0IGRvbid0IGdvXG4vLyB0aHJvdWdoIFNjaGVkdWxlclxuXG5cbmZ1bmN0aW9uIHBlcmZvcm1TeW5jV29ya09uUm9vdChyb290KSB7XG4gIGlmICghKChleGVjdXRpb25Db250ZXh0ICYgKFJlbmRlckNvbnRleHQgfCBDb21taXRDb250ZXh0KSkgPT09IE5vQ29udGV4dCkpIHtcbiAgICB7XG4gICAgICB0aHJvdyBFcnJvciggXCJTaG91bGQgbm90IGFscmVhZHkgYmUgd29ya2luZy5cIiApO1xuICAgIH1cbiAgfVxuXG4gIGZsdXNoUGFzc2l2ZUVmZmVjdHMoKTtcbiAgdmFyIGxhbmVzO1xuICB2YXIgZXhpdFN0YXR1cztcblxuICBpZiAocm9vdCA9PT0gd29ya0luUHJvZ3Jlc3NSb290ICYmIGluY2x1ZGVzU29tZUxhbmUocm9vdC5leHBpcmVkTGFuZXMsIHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzKSkge1xuICAgIC8vIFRoZXJlJ3MgYSBwYXJ0aWFsIHRyZWUsIGFuZCBhdCBsZWFzdCBvbmUgb2YgaXRzIGxhbmVzIGhhcyBleHBpcmVkLiBGaW5pc2hcbiAgICAvLyByZW5kZXJpbmcgaXQgYmVmb3JlIHJlbmRlcmluZyB0aGUgcmVzdCBvZiB0aGUgZXhwaXJlZCB3b3JrLlxuICAgIGxhbmVzID0gd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXM7XG4gICAgZXhpdFN0YXR1cyA9IHJlbmRlclJvb3RTeW5jKHJvb3QsIGxhbmVzKTtcblxuICAgIGlmIChpbmNsdWRlc1NvbWVMYW5lKHdvcmtJblByb2dyZXNzUm9vdEluY2x1ZGVkTGFuZXMsIHdvcmtJblByb2dyZXNzUm9vdFVwZGF0ZWRMYW5lcykpIHtcbiAgICAgIC8vIFRoZSByZW5kZXIgaW5jbHVkZWQgbGFuZXMgdGhhdCB3ZXJlIHVwZGF0ZWQgZHVyaW5nIHRoZSByZW5kZXIgcGhhc2UuXG4gICAgICAvLyBGb3IgZXhhbXBsZSwgd2hlbiB1bmhpZGluZyBhIGhpZGRlbiB0cmVlLCB3ZSBpbmNsdWRlIGFsbCB0aGUgbGFuZXNcbiAgICAgIC8vIHRoYXQgd2VyZSBwcmV2aW91c2x5IHNraXBwZWQgd2hlbiB0aGUgdHJlZSB3YXMgaGlkZGVuLiBUaGF0IHNldCBvZlxuICAgICAgLy8gbGFuZXMgaXMgYSBzdXBlcnNldCBvZiB0aGUgbGFuZXMgd2Ugc3RhcnRlZCByZW5kZXJpbmcgd2l0aC5cbiAgICAgIC8vXG4gICAgICAvLyBOb3RlIHRoYXQgdGhpcyBvbmx5IGhhcHBlbnMgd2hlbiBwYXJ0IG9mIHRoZSB0cmVlIGlzIHJlbmRlcmVkXG4gICAgICAvLyBjb25jdXJyZW50bHkuIElmIHRoZSB3aG9sZSB0cmVlIGlzIHJlbmRlcmVkIHN5bmNocm9ub3VzbHksIHRoZW4gdGhlcmVcbiAgICAgIC8vIGFyZSBubyBpbnRlcmxlYXZlZCBldmVudHMuXG4gICAgICBsYW5lcyA9IGdldE5leHRMYW5lcyhyb290LCBsYW5lcyk7XG4gICAgICBleGl0U3RhdHVzID0gcmVuZGVyUm9vdFN5bmMocm9vdCwgbGFuZXMpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBsYW5lcyA9IGdldE5leHRMYW5lcyhyb290LCBOb0xhbmVzKTtcbiAgICBleGl0U3RhdHVzID0gcmVuZGVyUm9vdFN5bmMocm9vdCwgbGFuZXMpO1xuICB9XG5cbiAgaWYgKHJvb3QudGFnICE9PSBMZWdhY3lSb290ICYmIGV4aXRTdGF0dXMgPT09IFJvb3RFcnJvcmVkKSB7XG4gICAgZXhlY3V0aW9uQ29udGV4dCB8PSBSZXRyeUFmdGVyRXJyb3I7IC8vIElmIGFuIGVycm9yIG9jY3VycmVkIGR1cmluZyBoeWRyYXRpb24sXG4gICAgLy8gZGlzY2FyZCBzZXJ2ZXIgcmVzcG9uc2UgYW5kIGZhbGwgYmFjayB0byBjbGllbnQgc2lkZSByZW5kZXIuXG5cbiAgICBpZiAocm9vdC5oeWRyYXRlKSB7XG4gICAgICByb290Lmh5ZHJhdGUgPSBmYWxzZTtcbiAgICAgIGNsZWFyQ29udGFpbmVyKHJvb3QuY29udGFpbmVySW5mbyk7XG4gICAgfSAvLyBJZiBzb21ldGhpbmcgdGhyZXcgYW4gZXJyb3IsIHRyeSByZW5kZXJpbmcgb25lIG1vcmUgdGltZS4gV2UnbGwgcmVuZGVyXG4gICAgLy8gc3luY2hyb25vdXNseSB0byBibG9jayBjb25jdXJyZW50IGRhdGEgbXV0YXRpb25zLCBhbmQgd2UnbGwgaW5jbHVkZXNcbiAgICAvLyBhbGwgcGVuZGluZyB1cGRhdGVzIGFyZSBpbmNsdWRlZC4gSWYgaXQgc3RpbGwgZmFpbHMgYWZ0ZXIgdGhlIHNlY29uZFxuICAgIC8vIGF0dGVtcHQsIHdlJ2xsIGdpdmUgdXAgYW5kIGNvbW1pdCB0aGUgcmVzdWx0aW5nIHRyZWUuXG5cblxuICAgIGxhbmVzID0gZ2V0TGFuZXNUb1JldHJ5U3luY2hyb25vdXNseU9uRXJyb3Iocm9vdCk7XG5cbiAgICBpZiAobGFuZXMgIT09IE5vTGFuZXMpIHtcbiAgICAgIGV4aXRTdGF0dXMgPSByZW5kZXJSb290U3luYyhyb290LCBsYW5lcyk7XG4gICAgfVxuICB9XG5cbiAgaWYgKGV4aXRTdGF0dXMgPT09IFJvb3RGYXRhbEVycm9yZWQpIHtcbiAgICB2YXIgZmF0YWxFcnJvciA9IHdvcmtJblByb2dyZXNzUm9vdEZhdGFsRXJyb3I7XG4gICAgcHJlcGFyZUZyZXNoU3RhY2socm9vdCwgTm9MYW5lcyk7XG4gICAgbWFya1Jvb3RTdXNwZW5kZWQkMShyb290LCBsYW5lcyk7XG4gICAgZW5zdXJlUm9vdElzU2NoZWR1bGVkKHJvb3QsIG5vdygpKTtcbiAgICB0aHJvdyBmYXRhbEVycm9yO1xuICB9IC8vIFdlIG5vdyBoYXZlIGEgY29uc2lzdGVudCB0cmVlLiBCZWNhdXNlIHRoaXMgaXMgYSBzeW5jIHJlbmRlciwgd2VcbiAgLy8gd2lsbCBjb21taXQgaXQgZXZlbiBpZiBzb21ldGhpbmcgc3VzcGVuZGVkLlxuXG5cbiAgdmFyIGZpbmlzaGVkV29yayA9IHJvb3QuY3VycmVudC5hbHRlcm5hdGU7XG4gIHJvb3QuZmluaXNoZWRXb3JrID0gZmluaXNoZWRXb3JrO1xuICByb290LmZpbmlzaGVkTGFuZXMgPSBsYW5lcztcbiAgY29tbWl0Um9vdChyb290KTsgLy8gQmVmb3JlIGV4aXRpbmcsIG1ha2Ugc3VyZSB0aGVyZSdzIGEgY2FsbGJhY2sgc2NoZWR1bGVkIGZvciB0aGUgbmV4dFxuICAvLyBwZW5kaW5nIGxldmVsLlxuXG4gIGVuc3VyZVJvb3RJc1NjaGVkdWxlZChyb290LCBub3coKSk7XG4gIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gZmx1c2hEaXNjcmV0ZVVwZGF0ZXMoKSB7XG4gIC8vIFRPRE86IFNob3VsZCBiZSBhYmxlIHRvIGZsdXNoIGluc2lkZSBiYXRjaGVkVXBkYXRlcywgYnV0IG5vdCBpbnNpZGUgYGFjdGAuXG4gIC8vIEhvd2V2ZXIsIGBhY3RgIHVzZXMgYGJhdGNoZWRVcGRhdGVzYCwgc28gdGhlcmUncyBubyB3YXkgdG8gZGlzdGluZ3Vpc2hcbiAgLy8gdGhvc2UgdHdvIGNhc2VzLiBOZWVkIHRvIGZpeCB0aGlzIGJlZm9yZSBleHBvc2luZyBmbHVzaERpc2NyZXRlVXBkYXRlc1xuICAvLyBhcyBhIHB1YmxpYyBBUEkuXG4gIGlmICgoZXhlY3V0aW9uQ29udGV4dCAmIChCYXRjaGVkQ29udGV4dCB8IFJlbmRlckNvbnRleHQgfCBDb21taXRDb250ZXh0KSkgIT09IE5vQ29udGV4dCkge1xuICAgIHtcbiAgICAgIGlmICgoZXhlY3V0aW9uQ29udGV4dCAmIFJlbmRlckNvbnRleHQpICE9PSBOb0NvbnRleHQpIHtcbiAgICAgICAgZXJyb3IoJ3Vuc3RhYmxlX2ZsdXNoRGlzY3JldGVVcGRhdGVzOiBDYW5ub3QgZmx1c2ggdXBkYXRlcyB3aGVuIFJlYWN0IGlzICcgKyAnYWxyZWFkeSByZW5kZXJpbmcuJyk7XG4gICAgICB9XG4gICAgfSAvLyBXZSdyZSBhbHJlYWR5IHJlbmRlcmluZywgc28gd2UgY2FuJ3Qgc3luY2hyb25vdXNseSBmbHVzaCBwZW5kaW5nIHdvcmsuXG4gICAgLy8gVGhpcyBpcyBwcm9iYWJseSBhIG5lc3RlZCBldmVudCBkaXNwYXRjaCB0cmlnZ2VyZWQgYnkgYSBsaWZlY3ljbGUvZWZmZWN0LFxuICAgIC8vIGxpa2UgYGVsLmZvY3VzKClgLiBFeGl0LlxuXG5cbiAgICByZXR1cm47XG4gIH1cblxuICBmbHVzaFBlbmRpbmdEaXNjcmV0ZVVwZGF0ZXMoKTsgLy8gSWYgdGhlIGRpc2NyZXRlIHVwZGF0ZXMgc2NoZWR1bGVkIHBhc3NpdmUgZWZmZWN0cywgZmx1c2ggdGhlbSBub3cgc28gdGhhdFxuICAvLyB0aGV5IGZpcmUgYmVmb3JlIHRoZSBuZXh0IHNlcmlhbCBldmVudC5cblxuICBmbHVzaFBhc3NpdmVFZmZlY3RzKCk7XG59XG5cbmZ1bmN0aW9uIGZsdXNoUGVuZGluZ0Rpc2NyZXRlVXBkYXRlcygpIHtcbiAgaWYgKHJvb3RzV2l0aFBlbmRpbmdEaXNjcmV0ZVVwZGF0ZXMgIT09IG51bGwpIHtcbiAgICAvLyBGb3IgZWFjaCByb290IHdpdGggcGVuZGluZyBkaXNjcmV0ZSB1cGRhdGVzLCBzY2hlZHVsZSBhIGNhbGxiYWNrIHRvXG4gICAgLy8gaW1tZWRpYXRlbHkgZmx1c2ggdGhlbS5cbiAgICB2YXIgcm9vdHMgPSByb290c1dpdGhQZW5kaW5nRGlzY3JldGVVcGRhdGVzO1xuICAgIHJvb3RzV2l0aFBlbmRpbmdEaXNjcmV0ZVVwZGF0ZXMgPSBudWxsO1xuICAgIHJvb3RzLmZvckVhY2goZnVuY3Rpb24gKHJvb3QpIHtcbiAgICAgIG1hcmtEaXNjcmV0ZVVwZGF0ZXNFeHBpcmVkKHJvb3QpO1xuICAgICAgZW5zdXJlUm9vdElzU2NoZWR1bGVkKHJvb3QsIG5vdygpKTtcbiAgICB9KTtcbiAgfSAvLyBOb3cgZmx1c2ggdGhlIGltbWVkaWF0ZSBxdWV1ZS5cblxuXG4gIGZsdXNoU3luY0NhbGxiYWNrUXVldWUoKTtcbn1cblxuZnVuY3Rpb24gYmF0Y2hlZFVwZGF0ZXMkMShmbiwgYSkge1xuICB2YXIgcHJldkV4ZWN1dGlvbkNvbnRleHQgPSBleGVjdXRpb25Db250ZXh0O1xuICBleGVjdXRpb25Db250ZXh0IHw9IEJhdGNoZWRDb250ZXh0O1xuXG4gIHRyeSB7XG4gICAgcmV0dXJuIGZuKGEpO1xuICB9IGZpbmFsbHkge1xuICAgIGV4ZWN1dGlvbkNvbnRleHQgPSBwcmV2RXhlY3V0aW9uQ29udGV4dDtcblxuICAgIGlmIChleGVjdXRpb25Db250ZXh0ID09PSBOb0NvbnRleHQpIHtcbiAgICAgIC8vIEZsdXNoIHRoZSBpbW1lZGlhdGUgY2FsbGJhY2tzIHRoYXQgd2VyZSBzY2hlZHVsZWQgZHVyaW5nIHRoaXMgYmF0Y2hcbiAgICAgIHJlc2V0UmVuZGVyVGltZXIoKTtcbiAgICAgIGZsdXNoU3luY0NhbGxiYWNrUXVldWUoKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGJhdGNoZWRFdmVudFVwZGF0ZXMkMShmbiwgYSkge1xuICB2YXIgcHJldkV4ZWN1dGlvbkNvbnRleHQgPSBleGVjdXRpb25Db250ZXh0O1xuICBleGVjdXRpb25Db250ZXh0IHw9IEV2ZW50Q29udGV4dDtcblxuICB0cnkge1xuICAgIHJldHVybiBmbihhKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBleGVjdXRpb25Db250ZXh0ID0gcHJldkV4ZWN1dGlvbkNvbnRleHQ7XG5cbiAgICBpZiAoZXhlY3V0aW9uQ29udGV4dCA9PT0gTm9Db250ZXh0KSB7XG4gICAgICAvLyBGbHVzaCB0aGUgaW1tZWRpYXRlIGNhbGxiYWNrcyB0aGF0IHdlcmUgc2NoZWR1bGVkIGR1cmluZyB0aGlzIGJhdGNoXG4gICAgICByZXNldFJlbmRlclRpbWVyKCk7XG4gICAgICBmbHVzaFN5bmNDYWxsYmFja1F1ZXVlKCk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBkaXNjcmV0ZVVwZGF0ZXMkMShmbiwgYSwgYiwgYywgZCkge1xuICB2YXIgcHJldkV4ZWN1dGlvbkNvbnRleHQgPSBleGVjdXRpb25Db250ZXh0O1xuICBleGVjdXRpb25Db250ZXh0IHw9IERpc2NyZXRlRXZlbnRDb250ZXh0O1xuXG4gIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIHJ1bldpdGhQcmlvcml0eSQxKFVzZXJCbG9ja2luZ1ByaW9yaXR5JDIsIGZuLmJpbmQobnVsbCwgYSwgYiwgYywgZCkpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBleGVjdXRpb25Db250ZXh0ID0gcHJldkV4ZWN1dGlvbkNvbnRleHQ7XG5cbiAgICAgIGlmIChleGVjdXRpb25Db250ZXh0ID09PSBOb0NvbnRleHQpIHtcbiAgICAgICAgLy8gRmx1c2ggdGhlIGltbWVkaWF0ZSBjYWxsYmFja3MgdGhhdCB3ZXJlIHNjaGVkdWxlZCBkdXJpbmcgdGhpcyBiYXRjaFxuICAgICAgICByZXNldFJlbmRlclRpbWVyKCk7XG4gICAgICAgIGZsdXNoU3luY0NhbGxiYWNrUXVldWUoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIHVuYmF0Y2hlZFVwZGF0ZXMoZm4sIGEpIHtcbiAgdmFyIHByZXZFeGVjdXRpb25Db250ZXh0ID0gZXhlY3V0aW9uQ29udGV4dDtcbiAgZXhlY3V0aW9uQ29udGV4dCAmPSB+QmF0Y2hlZENvbnRleHQ7XG4gIGV4ZWN1dGlvbkNvbnRleHQgfD0gTGVnYWN5VW5iYXRjaGVkQ29udGV4dDtcblxuICB0cnkge1xuICAgIHJldHVybiBmbihhKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBleGVjdXRpb25Db250ZXh0ID0gcHJldkV4ZWN1dGlvbkNvbnRleHQ7XG5cbiAgICBpZiAoZXhlY3V0aW9uQ29udGV4dCA9PT0gTm9Db250ZXh0KSB7XG4gICAgICAvLyBGbHVzaCB0aGUgaW1tZWRpYXRlIGNhbGxiYWNrcyB0aGF0IHdlcmUgc2NoZWR1bGVkIGR1cmluZyB0aGlzIGJhdGNoXG4gICAgICByZXNldFJlbmRlclRpbWVyKCk7XG4gICAgICBmbHVzaFN5bmNDYWxsYmFja1F1ZXVlKCk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBmbHVzaFN5bmMoZm4sIGEpIHtcbiAgdmFyIHByZXZFeGVjdXRpb25Db250ZXh0ID0gZXhlY3V0aW9uQ29udGV4dDtcblxuICBpZiAoKHByZXZFeGVjdXRpb25Db250ZXh0ICYgKFJlbmRlckNvbnRleHQgfCBDb21taXRDb250ZXh0KSkgIT09IE5vQ29udGV4dCkge1xuICAgIHtcbiAgICAgIGVycm9yKCdmbHVzaFN5bmMgd2FzIGNhbGxlZCBmcm9tIGluc2lkZSBhIGxpZmVjeWNsZSBtZXRob2QuIFJlYWN0IGNhbm5vdCAnICsgJ2ZsdXNoIHdoZW4gUmVhY3QgaXMgYWxyZWFkeSByZW5kZXJpbmcuIENvbnNpZGVyIG1vdmluZyB0aGlzIGNhbGwgdG8gJyArICdhIHNjaGVkdWxlciB0YXNrIG9yIG1pY3JvIHRhc2suJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZuKGEpO1xuICB9XG5cbiAgZXhlY3V0aW9uQ29udGV4dCB8PSBCYXRjaGVkQ29udGV4dDtcblxuICB7XG4gICAgdHJ5IHtcbiAgICAgIGlmIChmbikge1xuICAgICAgICByZXR1cm4gcnVuV2l0aFByaW9yaXR5JDEoSW1tZWRpYXRlUHJpb3JpdHkkMSwgZm4uYmluZChudWxsLCBhKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgIH0gZmluYWxseSB7XG4gICAgICBleGVjdXRpb25Db250ZXh0ID0gcHJldkV4ZWN1dGlvbkNvbnRleHQ7IC8vIEZsdXNoIHRoZSBpbW1lZGlhdGUgY2FsbGJhY2tzIHRoYXQgd2VyZSBzY2hlZHVsZWQgZHVyaW5nIHRoaXMgYmF0Y2guXG4gICAgICAvLyBOb3RlIHRoYXQgdGhpcyB3aWxsIGhhcHBlbiBldmVuIGlmIGJhdGNoZWRVcGRhdGVzIGlzIGhpZ2hlciB1cFxuICAgICAgLy8gdGhlIHN0YWNrLlxuXG4gICAgICBmbHVzaFN5bmNDYWxsYmFja1F1ZXVlKCk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBwdXNoUmVuZGVyTGFuZXMoZmliZXIsIGxhbmVzKSB7XG4gIHB1c2goc3VidHJlZVJlbmRlckxhbmVzQ3Vyc29yLCBzdWJ0cmVlUmVuZGVyTGFuZXMsIGZpYmVyKTtcbiAgc3VidHJlZVJlbmRlckxhbmVzID0gbWVyZ2VMYW5lcyhzdWJ0cmVlUmVuZGVyTGFuZXMsIGxhbmVzKTtcbiAgd29ya0luUHJvZ3Jlc3NSb290SW5jbHVkZWRMYW5lcyA9IG1lcmdlTGFuZXMod29ya0luUHJvZ3Jlc3NSb290SW5jbHVkZWRMYW5lcywgbGFuZXMpO1xufVxuZnVuY3Rpb24gcG9wUmVuZGVyTGFuZXMoZmliZXIpIHtcbiAgc3VidHJlZVJlbmRlckxhbmVzID0gc3VidHJlZVJlbmRlckxhbmVzQ3Vyc29yLmN1cnJlbnQ7XG4gIHBvcChzdWJ0cmVlUmVuZGVyTGFuZXNDdXJzb3IsIGZpYmVyKTtcbn1cblxuZnVuY3Rpb24gcHJlcGFyZUZyZXNoU3RhY2socm9vdCwgbGFuZXMpIHtcbiAgcm9vdC5maW5pc2hlZFdvcmsgPSBudWxsO1xuICByb290LmZpbmlzaGVkTGFuZXMgPSBOb0xhbmVzO1xuICB2YXIgdGltZW91dEhhbmRsZSA9IHJvb3QudGltZW91dEhhbmRsZTtcblxuICBpZiAodGltZW91dEhhbmRsZSAhPT0gbm9UaW1lb3V0KSB7XG4gICAgLy8gVGhlIHJvb3QgcHJldmlvdXMgc3VzcGVuZGVkIGFuZCBzY2hlZHVsZWQgYSB0aW1lb3V0IHRvIGNvbW1pdCBhIGZhbGxiYWNrXG4gICAgLy8gc3RhdGUuIE5vdyB0aGF0IHdlIGhhdmUgYWRkaXRpb25hbCB3b3JrLCBjYW5jZWwgdGhlIHRpbWVvdXQuXG4gICAgcm9vdC50aW1lb3V0SGFuZGxlID0gbm9UaW1lb3V0OyAvLyAkRmxvd0ZpeE1lIENvbXBsYWlucyBub1RpbWVvdXQgaXMgbm90IGEgVGltZW91dElELCBkZXNwaXRlIHRoZSBjaGVjayBhYm92ZVxuXG4gICAgY2FuY2VsVGltZW91dCh0aW1lb3V0SGFuZGxlKTtcbiAgfVxuXG4gIGlmICh3b3JrSW5Qcm9ncmVzcyAhPT0gbnVsbCkge1xuICAgIHZhciBpbnRlcnJ1cHRlZFdvcmsgPSB3b3JrSW5Qcm9ncmVzcy5yZXR1cm47XG5cbiAgICB3aGlsZSAoaW50ZXJydXB0ZWRXb3JrICE9PSBudWxsKSB7XG4gICAgICB1bndpbmRJbnRlcnJ1cHRlZFdvcmsoaW50ZXJydXB0ZWRXb3JrKTtcbiAgICAgIGludGVycnVwdGVkV29yayA9IGludGVycnVwdGVkV29yay5yZXR1cm47XG4gICAgfVxuICB9XG5cbiAgd29ya0luUHJvZ3Jlc3NSb290ID0gcm9vdDtcbiAgd29ya0luUHJvZ3Jlc3MgPSBjcmVhdGVXb3JrSW5Qcm9ncmVzcyhyb290LmN1cnJlbnQsIG51bGwpO1xuICB3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcyA9IHN1YnRyZWVSZW5kZXJMYW5lcyA9IHdvcmtJblByb2dyZXNzUm9vdEluY2x1ZGVkTGFuZXMgPSBsYW5lcztcbiAgd29ya0luUHJvZ3Jlc3NSb290RXhpdFN0YXR1cyA9IFJvb3RJbmNvbXBsZXRlO1xuICB3b3JrSW5Qcm9ncmVzc1Jvb3RGYXRhbEVycm9yID0gbnVsbDtcbiAgd29ya0luUHJvZ3Jlc3NSb290U2tpcHBlZExhbmVzID0gTm9MYW5lcztcbiAgd29ya0luUHJvZ3Jlc3NSb290VXBkYXRlZExhbmVzID0gTm9MYW5lcztcbiAgd29ya0luUHJvZ3Jlc3NSb290UGluZ2VkTGFuZXMgPSBOb0xhbmVzO1xuXG4gIHtcbiAgICBzcGF3bmVkV29ya0R1cmluZ1JlbmRlciA9IG51bGw7XG4gIH1cblxuICB7XG4gICAgUmVhY3RTdHJpY3RNb2RlV2FybmluZ3MuZGlzY2FyZFBlbmRpbmdXYXJuaW5ncygpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGhhbmRsZUVycm9yKHJvb3QsIHRocm93blZhbHVlKSB7XG4gIGRvIHtcbiAgICB2YXIgZXJyb3JlZFdvcmsgPSB3b3JrSW5Qcm9ncmVzcztcblxuICAgIHRyeSB7XG4gICAgICAvLyBSZXNldCBtb2R1bGUtbGV2ZWwgc3RhdGUgdGhhdCB3YXMgc2V0IGR1cmluZyB0aGUgcmVuZGVyIHBoYXNlLlxuICAgICAgcmVzZXRDb250ZXh0RGVwZW5kZW5jaWVzKCk7XG4gICAgICByZXNldEhvb2tzQWZ0ZXJUaHJvdygpO1xuICAgICAgcmVzZXRDdXJyZW50RmliZXIoKTsgLy8gVE9ETzogSSBmb3VuZCBhbmQgYWRkZWQgdGhpcyBtaXNzaW5nIGxpbmUgd2hpbGUgaW52ZXN0aWdhdGluZyBhXG4gICAgICAvLyBzZXBhcmF0ZSBpc3N1ZS4gV3JpdGUgYSByZWdyZXNzaW9uIHRlc3QgdXNpbmcgc3RyaW5nIHJlZnMuXG5cbiAgICAgIFJlYWN0Q3VycmVudE93bmVyJDIuY3VycmVudCA9IG51bGw7XG5cbiAgICAgIGlmIChlcnJvcmVkV29yayA9PT0gbnVsbCB8fCBlcnJvcmVkV29yay5yZXR1cm4gPT09IG51bGwpIHtcbiAgICAgICAgLy8gRXhwZWN0ZWQgdG8gYmUgd29ya2luZyBvbiBhIG5vbi1yb290IGZpYmVyLiBUaGlzIGlzIGEgZmF0YWwgZXJyb3JcbiAgICAgICAgLy8gYmVjYXVzZSB0aGVyZSdzIG5vIGFuY2VzdG9yIHRoYXQgY2FuIGhhbmRsZSBpdDsgdGhlIHJvb3QgaXNcbiAgICAgICAgLy8gc3VwcG9zZWQgdG8gY2FwdHVyZSBhbGwgZXJyb3JzIHRoYXQgd2VyZW4ndCBjYXVnaHQgYnkgYW4gZXJyb3JcbiAgICAgICAgLy8gYm91bmRhcnkuXG4gICAgICAgIHdvcmtJblByb2dyZXNzUm9vdEV4aXRTdGF0dXMgPSBSb290RmF0YWxFcnJvcmVkO1xuICAgICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RGYXRhbEVycm9yID0gdGhyb3duVmFsdWU7IC8vIFNldCBgd29ya0luUHJvZ3Jlc3NgIHRvIG51bGwuIFRoaXMgcmVwcmVzZW50cyBhZHZhbmNpbmcgdG8gdGhlIG5leHRcbiAgICAgICAgLy8gc2libGluZywgb3IgdGhlIHBhcmVudCBpZiB0aGVyZSBhcmUgbm8gc2libGluZ3MuIEJ1dCBzaW5jZSB0aGUgcm9vdFxuICAgICAgICAvLyBoYXMgbm8gc2libGluZ3Mgbm9yIGEgcGFyZW50LCB3ZSBzZXQgaXQgdG8gbnVsbC4gVXN1YWxseSB0aGlzIGlzXG4gICAgICAgIC8vIGhhbmRsZWQgYnkgYGNvbXBsZXRlVW5pdE9mV29ya2Agb3IgYHVud2luZFdvcmtgLCBidXQgc2luY2Ugd2UncmVcbiAgICAgICAgLy8gaW50ZW50aW9uYWxseSBub3QgY2FsbGluZyB0aG9zZSwgd2UgbmVlZCBzZXQgaXQgaGVyZS5cbiAgICAgICAgLy8gVE9ETzogQ29uc2lkZXIgY2FsbGluZyBgdW53aW5kV29ya2AgdG8gcG9wIHRoZSBjb250ZXh0cy5cblxuICAgICAgICB3b3JrSW5Qcm9ncmVzcyA9IG51bGw7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKGVuYWJsZVByb2ZpbGVyVGltZXIgJiYgZXJyb3JlZFdvcmsubW9kZSAmIFByb2ZpbGVNb2RlKSB7XG4gICAgICAgIC8vIFJlY29yZCB0aGUgdGltZSBzcGVudCByZW5kZXJpbmcgYmVmb3JlIGFuIGVycm9yIHdhcyB0aHJvd24uIFRoaXNcbiAgICAgICAgLy8gYXZvaWRzIGluYWNjdXJhdGUgUHJvZmlsZXIgZHVyYXRpb25zIGluIHRoZSBjYXNlIG9mIGFcbiAgICAgICAgLy8gc3VzcGVuZGVkIHJlbmRlci5cbiAgICAgICAgc3RvcFByb2ZpbGVyVGltZXJJZlJ1bm5pbmdBbmRSZWNvcmREZWx0YShlcnJvcmVkV29yaywgdHJ1ZSk7XG4gICAgICB9XG5cbiAgICAgIHRocm93RXhjZXB0aW9uKHJvb3QsIGVycm9yZWRXb3JrLnJldHVybiwgZXJyb3JlZFdvcmssIHRocm93blZhbHVlLCB3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcyk7XG4gICAgICBjb21wbGV0ZVVuaXRPZldvcmsoZXJyb3JlZFdvcmspO1xuICAgIH0gY2F0Y2ggKHlldEFub3RoZXJUaHJvd25WYWx1ZSkge1xuICAgICAgLy8gU29tZXRoaW5nIGluIHRoZSByZXR1cm4gcGF0aCBhbHNvIHRocmV3LlxuICAgICAgdGhyb3duVmFsdWUgPSB5ZXRBbm90aGVyVGhyb3duVmFsdWU7XG5cbiAgICAgIGlmICh3b3JrSW5Qcm9ncmVzcyA9PT0gZXJyb3JlZFdvcmsgJiYgZXJyb3JlZFdvcmsgIT09IG51bGwpIHtcbiAgICAgICAgLy8gSWYgdGhpcyBib3VuZGFyeSBoYXMgYWxyZWFkeSBlcnJvcmVkLCB0aGVuIHdlIGhhZCB0cm91YmxlIHByb2Nlc3NpbmdcbiAgICAgICAgLy8gdGhlIGVycm9yLiBCdWJibGUgaXQgdG8gdGhlIG5leHQgYm91bmRhcnkuXG4gICAgICAgIGVycm9yZWRXb3JrID0gZXJyb3JlZFdvcmsucmV0dXJuO1xuICAgICAgICB3b3JrSW5Qcm9ncmVzcyA9IGVycm9yZWRXb3JrO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZXJyb3JlZFdvcmsgPSB3b3JrSW5Qcm9ncmVzcztcbiAgICAgIH1cblxuICAgICAgY29udGludWU7XG4gICAgfSAvLyBSZXR1cm4gdG8gdGhlIG5vcm1hbCB3b3JrIGxvb3AuXG5cblxuICAgIHJldHVybjtcbiAgfSB3aGlsZSAodHJ1ZSk7XG59XG5cbmZ1bmN0aW9uIHB1c2hEaXNwYXRjaGVyKCkge1xuICB2YXIgcHJldkRpc3BhdGNoZXIgPSBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDIuY3VycmVudDtcbiAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQyLmN1cnJlbnQgPSBDb250ZXh0T25seURpc3BhdGNoZXI7XG5cbiAgaWYgKHByZXZEaXNwYXRjaGVyID09PSBudWxsKSB7XG4gICAgLy8gVGhlIFJlYWN0IGlzb21vcnBoaWMgcGFja2FnZSBkb2VzIG5vdCBpbmNsdWRlIGEgZGVmYXVsdCBkaXNwYXRjaGVyLlxuICAgIC8vIEluc3RlYWQgdGhlIGZpcnN0IHJlbmRlcmVyIHdpbGwgbGF6aWx5IGF0dGFjaCBvbmUsIGluIG9yZGVyIHRvIGdpdmVcbiAgICAvLyBuaWNlciBlcnJvciBtZXNzYWdlcy5cbiAgICByZXR1cm4gQ29udGV4dE9ubHlEaXNwYXRjaGVyO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBwcmV2RGlzcGF0Y2hlcjtcbiAgfVxufVxuXG5mdW5jdGlvbiBwb3BEaXNwYXRjaGVyKHByZXZEaXNwYXRjaGVyKSB7XG4gIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMi5jdXJyZW50ID0gcHJldkRpc3BhdGNoZXI7XG59XG5cbmZ1bmN0aW9uIHB1c2hJbnRlcmFjdGlvbnMocm9vdCkge1xuICB7XG4gICAgdmFyIHByZXZJbnRlcmFjdGlvbnMgPSB0cmFjaW5nLl9faW50ZXJhY3Rpb25zUmVmLmN1cnJlbnQ7XG4gICAgdHJhY2luZy5fX2ludGVyYWN0aW9uc1JlZi5jdXJyZW50ID0gcm9vdC5tZW1vaXplZEludGVyYWN0aW9ucztcbiAgICByZXR1cm4gcHJldkludGVyYWN0aW9ucztcbiAgfVxufVxuXG5mdW5jdGlvbiBwb3BJbnRlcmFjdGlvbnMocHJldkludGVyYWN0aW9ucykge1xuICB7XG4gICAgdHJhY2luZy5fX2ludGVyYWN0aW9uc1JlZi5jdXJyZW50ID0gcHJldkludGVyYWN0aW9ucztcbiAgfVxufVxuXG5mdW5jdGlvbiBtYXJrQ29tbWl0VGltZU9mRmFsbGJhY2soKSB7XG4gIGdsb2JhbE1vc3RSZWNlbnRGYWxsYmFja1RpbWUgPSBub3coKTtcbn1cbmZ1bmN0aW9uIG1hcmtTa2lwcGVkVXBkYXRlTGFuZXMobGFuZSkge1xuICB3b3JrSW5Qcm9ncmVzc1Jvb3RTa2lwcGVkTGFuZXMgPSBtZXJnZUxhbmVzKGxhbmUsIHdvcmtJblByb2dyZXNzUm9vdFNraXBwZWRMYW5lcyk7XG59XG5mdW5jdGlvbiByZW5kZXJEaWRTdXNwZW5kKCkge1xuICBpZiAod29ya0luUHJvZ3Jlc3NSb290RXhpdFN0YXR1cyA9PT0gUm9vdEluY29tcGxldGUpIHtcbiAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RFeGl0U3RhdHVzID0gUm9vdFN1c3BlbmRlZDtcbiAgfVxufVxuZnVuY3Rpb24gcmVuZGVyRGlkU3VzcGVuZERlbGF5SWZQb3NzaWJsZSgpIHtcbiAgaWYgKHdvcmtJblByb2dyZXNzUm9vdEV4aXRTdGF0dXMgPT09IFJvb3RJbmNvbXBsZXRlIHx8IHdvcmtJblByb2dyZXNzUm9vdEV4aXRTdGF0dXMgPT09IFJvb3RTdXNwZW5kZWQpIHtcbiAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RFeGl0U3RhdHVzID0gUm9vdFN1c3BlbmRlZFdpdGhEZWxheTtcbiAgfSAvLyBDaGVjayBpZiB0aGVyZSBhcmUgdXBkYXRlcyB0aGF0IHdlIHNraXBwZWQgdHJlZSB0aGF0IG1pZ2h0IGhhdmUgdW5ibG9ja2VkXG4gIC8vIHRoaXMgcmVuZGVyLlxuXG5cbiAgaWYgKHdvcmtJblByb2dyZXNzUm9vdCAhPT0gbnVsbCAmJiAoaW5jbHVkZXNOb25JZGxlV29yayh3b3JrSW5Qcm9ncmVzc1Jvb3RTa2lwcGVkTGFuZXMpIHx8IGluY2x1ZGVzTm9uSWRsZVdvcmsod29ya0luUHJvZ3Jlc3NSb290VXBkYXRlZExhbmVzKSkpIHtcbiAgICAvLyBNYXJrIHRoZSBjdXJyZW50IHJlbmRlciBhcyBzdXNwZW5kZWQgc28gdGhhdCB3ZSBzd2l0Y2ggdG8gd29ya2luZyBvblxuICAgIC8vIHRoZSB1cGRhdGVzIHRoYXQgd2VyZSBza2lwcGVkLiBVc3VhbGx5IHdlIG9ubHkgc3VzcGVuZCBhdCB0aGUgZW5kIG9mXG4gICAgLy8gdGhlIHJlbmRlciBwaGFzZS5cbiAgICAvLyBUT0RPOiBXZSBzaG91bGQgcHJvYmFibHkgYWx3YXlzIG1hcmsgdGhlIHJvb3QgYXMgc3VzcGVuZGVkIGltbWVkaWF0ZWx5XG4gICAgLy8gKGluc2lkZSB0aGlzIGZ1bmN0aW9uKSwgc2luY2UgYnkgc3VzcGVuZGluZyBhdCB0aGUgZW5kIG9mIHRoZSByZW5kZXJcbiAgICAvLyBwaGFzZSBpbnRyb2R1Y2VzIGEgcG90ZW50aWFsIG1pc3Rha2Ugd2hlcmUgd2Ugc3VzcGVuZCBsYW5lcyB0aGF0IHdlcmVcbiAgICAvLyBwaW5nZWQgb3IgdXBkYXRlZCB3aGlsZSB3ZSB3ZXJlIHJlbmRlcmluZy5cbiAgICBtYXJrUm9vdFN1c3BlbmRlZCQxKHdvcmtJblByb2dyZXNzUm9vdCwgd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMpO1xuICB9XG59XG5mdW5jdGlvbiByZW5kZXJEaWRFcnJvcigpIHtcbiAgaWYgKHdvcmtJblByb2dyZXNzUm9vdEV4aXRTdGF0dXMgIT09IFJvb3RDb21wbGV0ZWQpIHtcbiAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RFeGl0U3RhdHVzID0gUm9vdEVycm9yZWQ7XG4gIH1cbn0gLy8gQ2FsbGVkIGR1cmluZyByZW5kZXIgdG8gZGV0ZXJtaW5lIGlmIGFueXRoaW5nIGhhcyBzdXNwZW5kZWQuXG4vLyBSZXR1cm5zIGZhbHNlIGlmIHdlJ3JlIG5vdCBzdXJlLlxuXG5mdW5jdGlvbiByZW5kZXJIYXNOb3RTdXNwZW5kZWRZZXQoKSB7XG4gIC8vIElmIHNvbWV0aGluZyBlcnJvcmVkIG9yIGNvbXBsZXRlZCwgd2UgY2FuJ3QgcmVhbGx5IGJlIHN1cmUsXG4gIC8vIHNvIHRob3NlIGFyZSBmYWxzZS5cbiAgcmV0dXJuIHdvcmtJblByb2dyZXNzUm9vdEV4aXRTdGF0dXMgPT09IFJvb3RJbmNvbXBsZXRlO1xufVxuXG5mdW5jdGlvbiByZW5kZXJSb290U3luYyhyb290LCBsYW5lcykge1xuICB2YXIgcHJldkV4ZWN1dGlvbkNvbnRleHQgPSBleGVjdXRpb25Db250ZXh0O1xuICBleGVjdXRpb25Db250ZXh0IHw9IFJlbmRlckNvbnRleHQ7XG4gIHZhciBwcmV2RGlzcGF0Y2hlciA9IHB1c2hEaXNwYXRjaGVyKCk7IC8vIElmIHRoZSByb290IG9yIGxhbmVzIGhhdmUgY2hhbmdlZCwgdGhyb3cgb3V0IHRoZSBleGlzdGluZyBzdGFja1xuICAvLyBhbmQgcHJlcGFyZSBhIGZyZXNoIG9uZS4gT3RoZXJ3aXNlIHdlJ2xsIGNvbnRpbnVlIHdoZXJlIHdlIGxlZnQgb2ZmLlxuXG4gIGlmICh3b3JrSW5Qcm9ncmVzc1Jvb3QgIT09IHJvb3QgfHwgd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMgIT09IGxhbmVzKSB7XG4gICAgcHJlcGFyZUZyZXNoU3RhY2socm9vdCwgbGFuZXMpO1xuICAgIHN0YXJ0V29ya09uUGVuZGluZ0ludGVyYWN0aW9ucyhyb290LCBsYW5lcyk7XG4gIH1cblxuICB2YXIgcHJldkludGVyYWN0aW9ucyA9IHB1c2hJbnRlcmFjdGlvbnMocm9vdCk7XG5cbiAgZG8ge1xuICAgIHRyeSB7XG4gICAgICB3b3JrTG9vcFN5bmMoKTtcbiAgICAgIGJyZWFrO1xuICAgIH0gY2F0Y2ggKHRocm93blZhbHVlKSB7XG4gICAgICBoYW5kbGVFcnJvcihyb290LCB0aHJvd25WYWx1ZSk7XG4gICAgfVxuICB9IHdoaWxlICh0cnVlKTtcblxuICByZXNldENvbnRleHREZXBlbmRlbmNpZXMoKTtcblxuICB7XG4gICAgcG9wSW50ZXJhY3Rpb25zKHByZXZJbnRlcmFjdGlvbnMpO1xuICB9XG5cbiAgZXhlY3V0aW9uQ29udGV4dCA9IHByZXZFeGVjdXRpb25Db250ZXh0O1xuICBwb3BEaXNwYXRjaGVyKHByZXZEaXNwYXRjaGVyKTtcblxuICBpZiAod29ya0luUHJvZ3Jlc3MgIT09IG51bGwpIHtcbiAgICAvLyBUaGlzIGlzIGEgc3luYyByZW5kZXIsIHNvIHdlIHNob3VsZCBoYXZlIGZpbmlzaGVkIHRoZSB3aG9sZSB0cmVlLlxuICAgIHtcbiAgICAgIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoIFwiQ2Fubm90IGNvbW1pdCBhbiBpbmNvbXBsZXRlIHJvb3QuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCIgKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuXG4gIHdvcmtJblByb2dyZXNzUm9vdCA9IG51bGw7XG4gIHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzID0gTm9MYW5lcztcbiAgcmV0dXJuIHdvcmtJblByb2dyZXNzUm9vdEV4aXRTdGF0dXM7XG59IC8vIFRoZSB3b3JrIGxvb3AgaXMgYW4gZXh0cmVtZWx5IGhvdCBwYXRoLiBUZWxsIENsb3N1cmUgbm90IHRvIGlubGluZSBpdC5cblxuLyoqIEBub2lubGluZSAqL1xuXG5cbmZ1bmN0aW9uIHdvcmtMb29wU3luYygpIHtcbiAgLy8gQWxyZWFkeSB0aW1lZCBvdXQsIHNvIHBlcmZvcm0gd29yayB3aXRob3V0IGNoZWNraW5nIGlmIHdlIG5lZWQgdG8geWllbGQuXG4gIHdoaWxlICh3b3JrSW5Qcm9ncmVzcyAhPT0gbnVsbCkge1xuICAgIHBlcmZvcm1Vbml0T2ZXb3JrKHdvcmtJblByb2dyZXNzKTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZW5kZXJSb290Q29uY3VycmVudChyb290LCBsYW5lcykge1xuICB2YXIgcHJldkV4ZWN1dGlvbkNvbnRleHQgPSBleGVjdXRpb25Db250ZXh0O1xuICBleGVjdXRpb25Db250ZXh0IHw9IFJlbmRlckNvbnRleHQ7XG4gIHZhciBwcmV2RGlzcGF0Y2hlciA9IHB1c2hEaXNwYXRjaGVyKCk7IC8vIElmIHRoZSByb290IG9yIGxhbmVzIGhhdmUgY2hhbmdlZCwgdGhyb3cgb3V0IHRoZSBleGlzdGluZyBzdGFja1xuICAvLyBhbmQgcHJlcGFyZSBhIGZyZXNoIG9uZS4gT3RoZXJ3aXNlIHdlJ2xsIGNvbnRpbnVlIHdoZXJlIHdlIGxlZnQgb2ZmLlxuXG4gIGlmICh3b3JrSW5Qcm9ncmVzc1Jvb3QgIT09IHJvb3QgfHwgd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMgIT09IGxhbmVzKSB7XG4gICAgcmVzZXRSZW5kZXJUaW1lcigpO1xuICAgIHByZXBhcmVGcmVzaFN0YWNrKHJvb3QsIGxhbmVzKTtcbiAgICBzdGFydFdvcmtPblBlbmRpbmdJbnRlcmFjdGlvbnMocm9vdCwgbGFuZXMpO1xuICB9XG5cbiAgdmFyIHByZXZJbnRlcmFjdGlvbnMgPSBwdXNoSW50ZXJhY3Rpb25zKHJvb3QpO1xuXG4gIGRvIHtcbiAgICB0cnkge1xuICAgICAgd29ya0xvb3BDb25jdXJyZW50KCk7XG4gICAgICBicmVhaztcbiAgICB9IGNhdGNoICh0aHJvd25WYWx1ZSkge1xuICAgICAgaGFuZGxlRXJyb3Iocm9vdCwgdGhyb3duVmFsdWUpO1xuICAgIH1cbiAgfSB3aGlsZSAodHJ1ZSk7XG5cbiAgcmVzZXRDb250ZXh0RGVwZW5kZW5jaWVzKCk7XG5cbiAge1xuICAgIHBvcEludGVyYWN0aW9ucyhwcmV2SW50ZXJhY3Rpb25zKTtcbiAgfVxuXG4gIHBvcERpc3BhdGNoZXIocHJldkRpc3BhdGNoZXIpO1xuICBleGVjdXRpb25Db250ZXh0ID0gcHJldkV4ZWN1dGlvbkNvbnRleHQ7XG5cblxuICBpZiAod29ya0luUHJvZ3Jlc3MgIT09IG51bGwpIHtcblxuICAgIHJldHVybiBSb290SW5jb21wbGV0ZTtcbiAgfSBlbHNlIHtcblxuXG4gICAgd29ya0luUHJvZ3Jlc3NSb290ID0gbnVsbDtcbiAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcyA9IE5vTGFuZXM7IC8vIFJldHVybiB0aGUgZmluYWwgZXhpdCBzdGF0dXMuXG5cbiAgICByZXR1cm4gd29ya0luUHJvZ3Jlc3NSb290RXhpdFN0YXR1cztcbiAgfVxufVxuLyoqIEBub2lubGluZSAqL1xuXG5cbmZ1bmN0aW9uIHdvcmtMb29wQ29uY3VycmVudCgpIHtcbiAgLy8gUGVyZm9ybSB3b3JrIHVudGlsIFNjaGVkdWxlciBhc2tzIHVzIHRvIHlpZWxkXG4gIHdoaWxlICh3b3JrSW5Qcm9ncmVzcyAhPT0gbnVsbCAmJiAhc2hvdWxkWWllbGQoKSkge1xuICAgIHBlcmZvcm1Vbml0T2ZXb3JrKHdvcmtJblByb2dyZXNzKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwZXJmb3JtVW5pdE9mV29yayh1bml0T2ZXb3JrKSB7XG4gIC8vIFRoZSBjdXJyZW50LCBmbHVzaGVkLCBzdGF0ZSBvZiB0aGlzIGZpYmVyIGlzIHRoZSBhbHRlcm5hdGUuIElkZWFsbHlcbiAgLy8gbm90aGluZyBzaG91bGQgcmVseSBvbiB0aGlzLCBidXQgcmVseWluZyBvbiBpdCBoZXJlIG1lYW5zIHRoYXQgd2UgZG9uJ3RcbiAgLy8gbmVlZCBhbiBhZGRpdGlvbmFsIGZpZWxkIG9uIHRoZSB3b3JrIGluIHByb2dyZXNzLlxuICB2YXIgY3VycmVudCA9IHVuaXRPZldvcmsuYWx0ZXJuYXRlO1xuICBzZXRDdXJyZW50RmliZXIodW5pdE9mV29yayk7XG4gIHZhciBuZXh0O1xuXG4gIGlmICggKHVuaXRPZldvcmsubW9kZSAmIFByb2ZpbGVNb2RlKSAhPT0gTm9Nb2RlKSB7XG4gICAgc3RhcnRQcm9maWxlclRpbWVyKHVuaXRPZldvcmspO1xuICAgIG5leHQgPSBiZWdpbldvcmskMShjdXJyZW50LCB1bml0T2ZXb3JrLCBzdWJ0cmVlUmVuZGVyTGFuZXMpO1xuICAgIHN0b3BQcm9maWxlclRpbWVySWZSdW5uaW5nQW5kUmVjb3JkRGVsdGEodW5pdE9mV29yaywgdHJ1ZSk7XG4gIH0gZWxzZSB7XG4gICAgbmV4dCA9IGJlZ2luV29yayQxKGN1cnJlbnQsIHVuaXRPZldvcmssIHN1YnRyZWVSZW5kZXJMYW5lcyk7XG4gIH1cblxuICByZXNldEN1cnJlbnRGaWJlcigpO1xuICB1bml0T2ZXb3JrLm1lbW9pemVkUHJvcHMgPSB1bml0T2ZXb3JrLnBlbmRpbmdQcm9wcztcblxuICBpZiAobmV4dCA9PT0gbnVsbCkge1xuICAgIC8vIElmIHRoaXMgZG9lc24ndCBzcGF3biBuZXcgd29yaywgY29tcGxldGUgdGhlIGN1cnJlbnQgd29yay5cbiAgICBjb21wbGV0ZVVuaXRPZldvcmsodW5pdE9mV29yayk7XG4gIH0gZWxzZSB7XG4gICAgd29ya0luUHJvZ3Jlc3MgPSBuZXh0O1xuICB9XG5cbiAgUmVhY3RDdXJyZW50T3duZXIkMi5jdXJyZW50ID0gbnVsbDtcbn1cblxuZnVuY3Rpb24gY29tcGxldGVVbml0T2ZXb3JrKHVuaXRPZldvcmspIHtcbiAgLy8gQXR0ZW1wdCB0byBjb21wbGV0ZSB0aGUgY3VycmVudCB1bml0IG9mIHdvcmssIHRoZW4gbW92ZSB0byB0aGUgbmV4dFxuICAvLyBzaWJsaW5nLiBJZiB0aGVyZSBhcmUgbm8gbW9yZSBzaWJsaW5ncywgcmV0dXJuIHRvIHRoZSBwYXJlbnQgZmliZXIuXG4gIHZhciBjb21wbGV0ZWRXb3JrID0gdW5pdE9mV29yaztcblxuICBkbyB7XG4gICAgLy8gVGhlIGN1cnJlbnQsIGZsdXNoZWQsIHN0YXRlIG9mIHRoaXMgZmliZXIgaXMgdGhlIGFsdGVybmF0ZS4gSWRlYWxseVxuICAgIC8vIG5vdGhpbmcgc2hvdWxkIHJlbHkgb24gdGhpcywgYnV0IHJlbHlpbmcgb24gaXQgaGVyZSBtZWFucyB0aGF0IHdlIGRvbid0XG4gICAgLy8gbmVlZCBhbiBhZGRpdGlvbmFsIGZpZWxkIG9uIHRoZSB3b3JrIGluIHByb2dyZXNzLlxuICAgIHZhciBjdXJyZW50ID0gY29tcGxldGVkV29yay5hbHRlcm5hdGU7XG4gICAgdmFyIHJldHVybkZpYmVyID0gY29tcGxldGVkV29yay5yZXR1cm47IC8vIENoZWNrIGlmIHRoZSB3b3JrIGNvbXBsZXRlZCBvciBpZiBzb21ldGhpbmcgdGhyZXcuXG5cbiAgICBpZiAoKGNvbXBsZXRlZFdvcmsuZmxhZ3MgJiBJbmNvbXBsZXRlKSA9PT0gTm9GbGFncykge1xuICAgICAgc2V0Q3VycmVudEZpYmVyKGNvbXBsZXRlZFdvcmspO1xuICAgICAgdmFyIG5leHQgPSB2b2lkIDA7XG5cbiAgICAgIGlmICggKGNvbXBsZXRlZFdvcmsubW9kZSAmIFByb2ZpbGVNb2RlKSA9PT0gTm9Nb2RlKSB7XG4gICAgICAgIG5leHQgPSBjb21wbGV0ZVdvcmsoY3VycmVudCwgY29tcGxldGVkV29yaywgc3VidHJlZVJlbmRlckxhbmVzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0YXJ0UHJvZmlsZXJUaW1lcihjb21wbGV0ZWRXb3JrKTtcbiAgICAgICAgbmV4dCA9IGNvbXBsZXRlV29yayhjdXJyZW50LCBjb21wbGV0ZWRXb3JrLCBzdWJ0cmVlUmVuZGVyTGFuZXMpOyAvLyBVcGRhdGUgcmVuZGVyIGR1cmF0aW9uIGFzc3VtaW5nIHdlIGRpZG4ndCBlcnJvci5cblxuICAgICAgICBzdG9wUHJvZmlsZXJUaW1lcklmUnVubmluZ0FuZFJlY29yZERlbHRhKGNvbXBsZXRlZFdvcmssIGZhbHNlKTtcbiAgICAgIH1cblxuICAgICAgcmVzZXRDdXJyZW50RmliZXIoKTtcblxuICAgICAgaWYgKG5leHQgIT09IG51bGwpIHtcbiAgICAgICAgLy8gQ29tcGxldGluZyB0aGlzIGZpYmVyIHNwYXduZWQgbmV3IHdvcmsuIFdvcmsgb24gdGhhdCBuZXh0LlxuICAgICAgICB3b3JrSW5Qcm9ncmVzcyA9IG5leHQ7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgcmVzZXRDaGlsZExhbmVzKGNvbXBsZXRlZFdvcmspO1xuXG4gICAgICBpZiAocmV0dXJuRmliZXIgIT09IG51bGwgJiYgLy8gRG8gbm90IGFwcGVuZCBlZmZlY3RzIHRvIHBhcmVudHMgaWYgYSBzaWJsaW5nIGZhaWxlZCB0byBjb21wbGV0ZVxuICAgICAgKHJldHVybkZpYmVyLmZsYWdzICYgSW5jb21wbGV0ZSkgPT09IE5vRmxhZ3MpIHtcbiAgICAgICAgLy8gQXBwZW5kIGFsbCB0aGUgZWZmZWN0cyBvZiB0aGUgc3VidHJlZSBhbmQgdGhpcyBmaWJlciBvbnRvIHRoZSBlZmZlY3RcbiAgICAgICAgLy8gbGlzdCBvZiB0aGUgcGFyZW50LiBUaGUgY29tcGxldGlvbiBvcmRlciBvZiB0aGUgY2hpbGRyZW4gYWZmZWN0cyB0aGVcbiAgICAgICAgLy8gc2lkZS1lZmZlY3Qgb3JkZXIuXG4gICAgICAgIGlmIChyZXR1cm5GaWJlci5maXJzdEVmZmVjdCA9PT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybkZpYmVyLmZpcnN0RWZmZWN0ID0gY29tcGxldGVkV29yay5maXJzdEVmZmVjdDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjb21wbGV0ZWRXb3JrLmxhc3RFZmZlY3QgIT09IG51bGwpIHtcbiAgICAgICAgICBpZiAocmV0dXJuRmliZXIubGFzdEVmZmVjdCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuRmliZXIubGFzdEVmZmVjdC5uZXh0RWZmZWN0ID0gY29tcGxldGVkV29yay5maXJzdEVmZmVjdDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm5GaWJlci5sYXN0RWZmZWN0ID0gY29tcGxldGVkV29yay5sYXN0RWZmZWN0O1xuICAgICAgICB9IC8vIElmIHRoaXMgZmliZXIgaGFkIHNpZGUtZWZmZWN0cywgd2UgYXBwZW5kIGl0IEFGVEVSIHRoZSBjaGlsZHJlbidzXG4gICAgICAgIC8vIHNpZGUtZWZmZWN0cy4gV2UgY2FuIHBlcmZvcm0gY2VydGFpbiBzaWRlLWVmZmVjdHMgZWFybGllciBpZiBuZWVkZWQsXG4gICAgICAgIC8vIGJ5IGRvaW5nIG11bHRpcGxlIHBhc3NlcyBvdmVyIHRoZSBlZmZlY3QgbGlzdC4gV2UgZG9uJ3Qgd2FudCB0b1xuICAgICAgICAvLyBzY2hlZHVsZSBvdXIgb3duIHNpZGUtZWZmZWN0IG9uIG91ciBvd24gbGlzdCBiZWNhdXNlIGlmIGVuZCB1cFxuICAgICAgICAvLyByZXVzaW5nIGNoaWxkcmVuIHdlJ2xsIHNjaGVkdWxlIHRoaXMgZWZmZWN0IG9udG8gaXRzZWxmIHNpbmNlIHdlJ3JlXG4gICAgICAgIC8vIGF0IHRoZSBlbmQuXG5cblxuICAgICAgICB2YXIgZmxhZ3MgPSBjb21wbGV0ZWRXb3JrLmZsYWdzOyAvLyBTa2lwIGJvdGggTm9Xb3JrIGFuZCBQZXJmb3JtZWRXb3JrIHRhZ3Mgd2hlbiBjcmVhdGluZyB0aGUgZWZmZWN0XG4gICAgICAgIC8vIGxpc3QuIFBlcmZvcm1lZFdvcmsgZWZmZWN0IGlzIHJlYWQgYnkgUmVhY3QgRGV2VG9vbHMgYnV0IHNob3VsZG4ndCBiZVxuICAgICAgICAvLyBjb21taXR0ZWQuXG5cbiAgICAgICAgaWYgKGZsYWdzID4gUGVyZm9ybWVkV29yaykge1xuICAgICAgICAgIGlmIChyZXR1cm5GaWJlci5sYXN0RWZmZWN0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm5GaWJlci5sYXN0RWZmZWN0Lm5leHRFZmZlY3QgPSBjb21wbGV0ZWRXb3JrO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm5GaWJlci5maXJzdEVmZmVjdCA9IGNvbXBsZXRlZFdvcms7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuRmliZXIubGFzdEVmZmVjdCA9IGNvbXBsZXRlZFdvcms7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVGhpcyBmaWJlciBkaWQgbm90IGNvbXBsZXRlIGJlY2F1c2Ugc29tZXRoaW5nIHRocmV3LiBQb3AgdmFsdWVzIG9mZlxuICAgICAgLy8gdGhlIHN0YWNrIHdpdGhvdXQgZW50ZXJpbmcgdGhlIGNvbXBsZXRlIHBoYXNlLiBJZiB0aGlzIGlzIGEgYm91bmRhcnksXG4gICAgICAvLyBjYXB0dXJlIHZhbHVlcyBpZiBwb3NzaWJsZS5cbiAgICAgIHZhciBfbmV4dCA9IHVud2luZFdvcmsoY29tcGxldGVkV29yayk7IC8vIEJlY2F1c2UgdGhpcyBmaWJlciBkaWQgbm90IGNvbXBsZXRlLCBkb24ndCByZXNldCBpdHMgZXhwaXJhdGlvbiB0aW1lLlxuXG5cbiAgICAgIGlmIChfbmV4dCAhPT0gbnVsbCkge1xuICAgICAgICAvLyBJZiBjb21wbGV0aW5nIHRoaXMgd29yayBzcGF3bmVkIG5ldyB3b3JrLCBkbyB0aGF0IG5leHQuIFdlJ2xsIGNvbWVcbiAgICAgICAgLy8gYmFjayBoZXJlIGFnYWluLlxuICAgICAgICAvLyBTaW5jZSB3ZSdyZSByZXN0YXJ0aW5nLCByZW1vdmUgYW55dGhpbmcgdGhhdCBpcyBub3QgYSBob3N0IGVmZmVjdFxuICAgICAgICAvLyBmcm9tIHRoZSBlZmZlY3QgdGFnLlxuICAgICAgICBfbmV4dC5mbGFncyAmPSBIb3N0RWZmZWN0TWFzaztcbiAgICAgICAgd29ya0luUHJvZ3Jlc3MgPSBfbmV4dDtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoIChjb21wbGV0ZWRXb3JrLm1vZGUgJiBQcm9maWxlTW9kZSkgIT09IE5vTW9kZSkge1xuICAgICAgICAvLyBSZWNvcmQgdGhlIHJlbmRlciBkdXJhdGlvbiBmb3IgdGhlIGZpYmVyIHRoYXQgZXJyb3JlZC5cbiAgICAgICAgc3RvcFByb2ZpbGVyVGltZXJJZlJ1bm5pbmdBbmRSZWNvcmREZWx0YShjb21wbGV0ZWRXb3JrLCBmYWxzZSk7IC8vIEluY2x1ZGUgdGhlIHRpbWUgc3BlbnQgd29ya2luZyBvbiBmYWlsZWQgY2hpbGRyZW4gYmVmb3JlIGNvbnRpbnVpbmcuXG5cbiAgICAgICAgdmFyIGFjdHVhbER1cmF0aW9uID0gY29tcGxldGVkV29yay5hY3R1YWxEdXJhdGlvbjtcbiAgICAgICAgdmFyIGNoaWxkID0gY29tcGxldGVkV29yay5jaGlsZDtcblxuICAgICAgICB3aGlsZSAoY2hpbGQgIT09IG51bGwpIHtcbiAgICAgICAgICBhY3R1YWxEdXJhdGlvbiArPSBjaGlsZC5hY3R1YWxEdXJhdGlvbjtcbiAgICAgICAgICBjaGlsZCA9IGNoaWxkLnNpYmxpbmc7XG4gICAgICAgIH1cblxuICAgICAgICBjb21wbGV0ZWRXb3JrLmFjdHVhbER1cmF0aW9uID0gYWN0dWFsRHVyYXRpb247XG4gICAgICB9XG5cbiAgICAgIGlmIChyZXR1cm5GaWJlciAhPT0gbnVsbCkge1xuICAgICAgICAvLyBNYXJrIHRoZSBwYXJlbnQgZmliZXIgYXMgaW5jb21wbGV0ZSBhbmQgY2xlYXIgaXRzIGVmZmVjdCBsaXN0LlxuICAgICAgICByZXR1cm5GaWJlci5maXJzdEVmZmVjdCA9IHJldHVybkZpYmVyLmxhc3RFZmZlY3QgPSBudWxsO1xuICAgICAgICByZXR1cm5GaWJlci5mbGFncyB8PSBJbmNvbXBsZXRlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBzaWJsaW5nRmliZXIgPSBjb21wbGV0ZWRXb3JrLnNpYmxpbmc7XG5cbiAgICBpZiAoc2libGluZ0ZpYmVyICE9PSBudWxsKSB7XG4gICAgICAvLyBJZiB0aGVyZSBpcyBtb3JlIHdvcmsgdG8gZG8gaW4gdGhpcyByZXR1cm5GaWJlciwgZG8gdGhhdCBuZXh0LlxuICAgICAgd29ya0luUHJvZ3Jlc3MgPSBzaWJsaW5nRmliZXI7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyBPdGhlcndpc2UsIHJldHVybiB0byB0aGUgcGFyZW50XG5cblxuICAgIGNvbXBsZXRlZFdvcmsgPSByZXR1cm5GaWJlcjsgLy8gVXBkYXRlIHRoZSBuZXh0IHRoaW5nIHdlJ3JlIHdvcmtpbmcgb24gaW4gY2FzZSBzb21ldGhpbmcgdGhyb3dzLlxuXG4gICAgd29ya0luUHJvZ3Jlc3MgPSBjb21wbGV0ZWRXb3JrO1xuICB9IHdoaWxlIChjb21wbGV0ZWRXb3JrICE9PSBudWxsKTsgLy8gV2UndmUgcmVhY2hlZCB0aGUgcm9vdC5cblxuXG4gIGlmICh3b3JrSW5Qcm9ncmVzc1Jvb3RFeGl0U3RhdHVzID09PSBSb290SW5jb21wbGV0ZSkge1xuICAgIHdvcmtJblByb2dyZXNzUm9vdEV4aXRTdGF0dXMgPSBSb290Q29tcGxldGVkO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlc2V0Q2hpbGRMYW5lcyhjb21wbGV0ZWRXb3JrKSB7XG4gIGlmICggLy8gVE9ETzogTW92ZSB0aGlzIGNoZWNrIG91dCBvZiB0aGUgaG90IHBhdGggYnkgbW92aW5nIGByZXNldENoaWxkTGFuZXNgXG4gIC8vIHRvIHN3aXRjaCBzdGF0ZW1lbnQgaW4gYGNvbXBsZXRlV29ya2AuXG4gIChjb21wbGV0ZWRXb3JrLnRhZyA9PT0gTGVnYWN5SGlkZGVuQ29tcG9uZW50IHx8IGNvbXBsZXRlZFdvcmsudGFnID09PSBPZmZzY3JlZW5Db21wb25lbnQpICYmIGNvbXBsZXRlZFdvcmsubWVtb2l6ZWRTdGF0ZSAhPT0gbnVsbCAmJiAhaW5jbHVkZXNTb21lTGFuZShzdWJ0cmVlUmVuZGVyTGFuZXMsIE9mZnNjcmVlbkxhbmUpICYmIChjb21wbGV0ZWRXb3JrLm1vZGUgJiBDb25jdXJyZW50TW9kZSkgIT09IE5vTGFuZXMpIHtcbiAgICAvLyBUaGUgY2hpbGRyZW4gb2YgdGhpcyBjb21wb25lbnQgYXJlIGhpZGRlbi4gRG9uJ3QgYnViYmxlIHRoZWlyXG4gICAgLy8gZXhwaXJhdGlvbiB0aW1lcy5cbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgbmV3Q2hpbGRMYW5lcyA9IE5vTGFuZXM7IC8vIEJ1YmJsZSB1cCB0aGUgZWFybGllc3QgZXhwaXJhdGlvbiB0aW1lLlxuXG4gIGlmICggKGNvbXBsZXRlZFdvcmsubW9kZSAmIFByb2ZpbGVNb2RlKSAhPT0gTm9Nb2RlKSB7XG4gICAgLy8gSW4gcHJvZmlsaW5nIG1vZGUsIHJlc2V0Q2hpbGRFeHBpcmF0aW9uVGltZSBpcyBhbHNvIHVzZWQgdG8gcmVzZXRcbiAgICAvLyBwcm9maWxlciBkdXJhdGlvbnMuXG4gICAgdmFyIGFjdHVhbER1cmF0aW9uID0gY29tcGxldGVkV29yay5hY3R1YWxEdXJhdGlvbjtcbiAgICB2YXIgdHJlZUJhc2VEdXJhdGlvbiA9IGNvbXBsZXRlZFdvcmsuc2VsZkJhc2VEdXJhdGlvbjsgLy8gV2hlbiBhIGZpYmVyIGlzIGNsb25lZCwgaXRzIGFjdHVhbER1cmF0aW9uIGlzIHJlc2V0IHRvIDAuIFRoaXMgdmFsdWUgd2lsbFxuICAgIC8vIG9ubHkgYmUgdXBkYXRlZCBpZiB3b3JrIGlzIGRvbmUgb24gdGhlIGZpYmVyIChpLmUuIGl0IGRvZXNuJ3QgYmFpbG91dCkuXG4gICAgLy8gV2hlbiB3b3JrIGlzIGRvbmUsIGl0IHNob3VsZCBidWJibGUgdG8gdGhlIHBhcmVudCdzIGFjdHVhbER1cmF0aW9uLiBJZlxuICAgIC8vIHRoZSBmaWJlciBoYXMgbm90IGJlZW4gY2xvbmVkIHRob3VnaCwgKG1lYW5pbmcgbm8gd29yayB3YXMgZG9uZSksIHRoZW5cbiAgICAvLyB0aGlzIHZhbHVlIHdpbGwgcmVmbGVjdCB0aGUgYW1vdW50IG9mIHRpbWUgc3BlbnQgd29ya2luZyBvbiBhIHByZXZpb3VzXG4gICAgLy8gcmVuZGVyLiBJbiB0aGF0IGNhc2UgaXQgc2hvdWxkIG5vdCBidWJibGUuIFdlIGRldGVybWluZSB3aGV0aGVyIGl0IHdhc1xuICAgIC8vIGNsb25lZCBieSBjb21wYXJpbmcgdGhlIGNoaWxkIHBvaW50ZXIuXG5cbiAgICB2YXIgc2hvdWxkQnViYmxlQWN0dWFsRHVyYXRpb25zID0gY29tcGxldGVkV29yay5hbHRlcm5hdGUgPT09IG51bGwgfHwgY29tcGxldGVkV29yay5jaGlsZCAhPT0gY29tcGxldGVkV29yay5hbHRlcm5hdGUuY2hpbGQ7XG4gICAgdmFyIGNoaWxkID0gY29tcGxldGVkV29yay5jaGlsZDtcblxuICAgIHdoaWxlIChjaGlsZCAhPT0gbnVsbCkge1xuICAgICAgbmV3Q2hpbGRMYW5lcyA9IG1lcmdlTGFuZXMobmV3Q2hpbGRMYW5lcywgbWVyZ2VMYW5lcyhjaGlsZC5sYW5lcywgY2hpbGQuY2hpbGRMYW5lcykpO1xuXG4gICAgICBpZiAoc2hvdWxkQnViYmxlQWN0dWFsRHVyYXRpb25zKSB7XG4gICAgICAgIGFjdHVhbER1cmF0aW9uICs9IGNoaWxkLmFjdHVhbER1cmF0aW9uO1xuICAgICAgfVxuXG4gICAgICB0cmVlQmFzZUR1cmF0aW9uICs9IGNoaWxkLnRyZWVCYXNlRHVyYXRpb247XG4gICAgICBjaGlsZCA9IGNoaWxkLnNpYmxpbmc7XG4gICAgfVxuXG4gICAgdmFyIGlzVGltZWRPdXRTdXNwZW5zZSA9IGNvbXBsZXRlZFdvcmsudGFnID09PSBTdXNwZW5zZUNvbXBvbmVudCAmJiBjb21wbGV0ZWRXb3JrLm1lbW9pemVkU3RhdGUgIT09IG51bGw7XG5cbiAgICBpZiAoaXNUaW1lZE91dFN1c3BlbnNlKSB7XG4gICAgICAvLyBEb24ndCBjb3VudCB0aW1lIHNwZW50IGluIGEgdGltZWQgb3V0IFN1c3BlbnNlIHN1YnRyZWUgYXMgcGFydCBvZiB0aGUgYmFzZSBkdXJhdGlvbi5cbiAgICAgIHZhciBwcmltYXJ5Q2hpbGRGcmFnbWVudCA9IGNvbXBsZXRlZFdvcmsuY2hpbGQ7XG5cbiAgICAgIGlmIChwcmltYXJ5Q2hpbGRGcmFnbWVudCAhPT0gbnVsbCkge1xuICAgICAgICB0cmVlQmFzZUR1cmF0aW9uIC09IHByaW1hcnlDaGlsZEZyYWdtZW50LnRyZWVCYXNlRHVyYXRpb247XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29tcGxldGVkV29yay5hY3R1YWxEdXJhdGlvbiA9IGFjdHVhbER1cmF0aW9uO1xuICAgIGNvbXBsZXRlZFdvcmsudHJlZUJhc2VEdXJhdGlvbiA9IHRyZWVCYXNlRHVyYXRpb247XG4gIH0gZWxzZSB7XG4gICAgdmFyIF9jaGlsZCA9IGNvbXBsZXRlZFdvcmsuY2hpbGQ7XG5cbiAgICB3aGlsZSAoX2NoaWxkICE9PSBudWxsKSB7XG4gICAgICBuZXdDaGlsZExhbmVzID0gbWVyZ2VMYW5lcyhuZXdDaGlsZExhbmVzLCBtZXJnZUxhbmVzKF9jaGlsZC5sYW5lcywgX2NoaWxkLmNoaWxkTGFuZXMpKTtcbiAgICAgIF9jaGlsZCA9IF9jaGlsZC5zaWJsaW5nO1xuICAgIH1cbiAgfVxuXG4gIGNvbXBsZXRlZFdvcmsuY2hpbGRMYW5lcyA9IG5ld0NoaWxkTGFuZXM7XG59XG5cbmZ1bmN0aW9uIGNvbW1pdFJvb3Qocm9vdCkge1xuICB2YXIgcmVuZGVyUHJpb3JpdHlMZXZlbCA9IGdldEN1cnJlbnRQcmlvcml0eUxldmVsKCk7XG4gIHJ1bldpdGhQcmlvcml0eSQxKEltbWVkaWF0ZVByaW9yaXR5JDEsIGNvbW1pdFJvb3RJbXBsLmJpbmQobnVsbCwgcm9vdCwgcmVuZGVyUHJpb3JpdHlMZXZlbCkpO1xuICByZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gY29tbWl0Um9vdEltcGwocm9vdCwgcmVuZGVyUHJpb3JpdHlMZXZlbCkge1xuICBkbyB7XG4gICAgLy8gYGZsdXNoUGFzc2l2ZUVmZmVjdHNgIHdpbGwgY2FsbCBgZmx1c2hTeW5jVXBkYXRlUXVldWVgIGF0IHRoZSBlbmQsIHdoaWNoXG4gICAgLy8gbWVhbnMgYGZsdXNoUGFzc2l2ZUVmZmVjdHNgIHdpbGwgc29tZXRpbWVzIHJlc3VsdCBpbiBhZGRpdGlvbmFsXG4gICAgLy8gcGFzc2l2ZSBlZmZlY3RzLiBTbyB3ZSBuZWVkIHRvIGtlZXAgZmx1c2hpbmcgaW4gYSBsb29wIHVudGlsIHRoZXJlIGFyZVxuICAgIC8vIG5vIG1vcmUgcGVuZGluZyBlZmZlY3RzLlxuICAgIC8vIFRPRE86IE1pZ2h0IGJlIGJldHRlciBpZiBgZmx1c2hQYXNzaXZlRWZmZWN0c2AgZGlkIG5vdCBhdXRvbWF0aWNhbGx5XG4gICAgLy8gZmx1c2ggc3luY2hyb25vdXMgd29yayBhdCB0aGUgZW5kLCB0byBhdm9pZCBmYWN0b3JpbmcgaGF6YXJkcyBsaWtlIHRoaXMuXG4gICAgZmx1c2hQYXNzaXZlRWZmZWN0cygpO1xuICB9IHdoaWxlIChyb290V2l0aFBlbmRpbmdQYXNzaXZlRWZmZWN0cyAhPT0gbnVsbCk7XG5cbiAgZmx1c2hSZW5kZXJQaGFzZVN0cmljdE1vZGVXYXJuaW5nc0luREVWKCk7XG5cbiAgaWYgKCEoKGV4ZWN1dGlvbkNvbnRleHQgJiAoUmVuZGVyQ29udGV4dCB8IENvbW1pdENvbnRleHQpKSA9PT0gTm9Db250ZXh0KSkge1xuICAgIHtcbiAgICAgIHRocm93IEVycm9yKCBcIlNob3VsZCBub3QgYWxyZWFkeSBiZSB3b3JraW5nLlwiICk7XG4gICAgfVxuICB9XG5cbiAgdmFyIGZpbmlzaGVkV29yayA9IHJvb3QuZmluaXNoZWRXb3JrO1xuICB2YXIgbGFuZXMgPSByb290LmZpbmlzaGVkTGFuZXM7XG5cbiAgaWYgKGZpbmlzaGVkV29yayA9PT0gbnVsbCkge1xuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICByb290LmZpbmlzaGVkV29yayA9IG51bGw7XG4gIHJvb3QuZmluaXNoZWRMYW5lcyA9IE5vTGFuZXM7XG5cbiAgaWYgKCEoZmluaXNoZWRXb3JrICE9PSByb290LmN1cnJlbnQpKSB7XG4gICAge1xuICAgICAgdGhyb3cgRXJyb3IoIFwiQ2Fubm90IGNvbW1pdCB0aGUgc2FtZSB0cmVlIGFzIGJlZm9yZS4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS5cIiApO1xuICAgIH1cbiAgfSAvLyBjb21taXRSb290IG5ldmVyIHJldHVybnMgYSBjb250aW51YXRpb247IGl0IGFsd2F5cyBmaW5pc2hlcyBzeW5jaHJvbm91c2x5LlxuICAvLyBTbyB3ZSBjYW4gY2xlYXIgdGhlc2Ugbm93IHRvIGFsbG93IGEgbmV3IGNhbGxiYWNrIHRvIGJlIHNjaGVkdWxlZC5cblxuXG4gIHJvb3QuY2FsbGJhY2tOb2RlID0gbnVsbDsgLy8gVXBkYXRlIHRoZSBmaXJzdCBhbmQgbGFzdCBwZW5kaW5nIHRpbWVzIG9uIHRoaXMgcm9vdC4gVGhlIG5ldyBmaXJzdFxuICAvLyBwZW5kaW5nIHRpbWUgaXMgd2hhdGV2ZXIgaXMgbGVmdCBvbiB0aGUgcm9vdCBmaWJlci5cblxuICB2YXIgcmVtYWluaW5nTGFuZXMgPSBtZXJnZUxhbmVzKGZpbmlzaGVkV29yay5sYW5lcywgZmluaXNoZWRXb3JrLmNoaWxkTGFuZXMpO1xuICBtYXJrUm9vdEZpbmlzaGVkKHJvb3QsIHJlbWFpbmluZ0xhbmVzKTsgLy8gQ2xlYXIgYWxyZWFkeSBmaW5pc2hlZCBkaXNjcmV0ZSB1cGRhdGVzIGluIGNhc2UgdGhhdCBhIGxhdGVyIGNhbGwgb2ZcbiAgLy8gYGZsdXNoRGlzY3JldGVVcGRhdGVzYCBzdGFydHMgYSB1c2VsZXNzIHJlbmRlciBwYXNzIHdoaWNoIG1heSBjYW5jZWxzXG4gIC8vIGEgc2NoZWR1bGVkIHRpbWVvdXQuXG5cbiAgaWYgKHJvb3RzV2l0aFBlbmRpbmdEaXNjcmV0ZVVwZGF0ZXMgIT09IG51bGwpIHtcbiAgICBpZiAoIWhhc0Rpc2NyZXRlTGFuZXMocmVtYWluaW5nTGFuZXMpICYmIHJvb3RzV2l0aFBlbmRpbmdEaXNjcmV0ZVVwZGF0ZXMuaGFzKHJvb3QpKSB7XG4gICAgICByb290c1dpdGhQZW5kaW5nRGlzY3JldGVVcGRhdGVzLmRlbGV0ZShyb290KTtcbiAgICB9XG4gIH1cblxuICBpZiAocm9vdCA9PT0gd29ya0luUHJvZ3Jlc3NSb290KSB7XG4gICAgLy8gV2UgY2FuIHJlc2V0IHRoZXNlIG5vdyB0aGF0IHRoZXkgYXJlIGZpbmlzaGVkLlxuICAgIHdvcmtJblByb2dyZXNzUm9vdCA9IG51bGw7XG4gICAgd29ya0luUHJvZ3Jlc3MgPSBudWxsO1xuICAgIHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzID0gTm9MYW5lcztcbiAgfSAvLyBHZXQgdGhlIGxpc3Qgb2YgZWZmZWN0cy5cblxuXG4gIHZhciBmaXJzdEVmZmVjdDtcblxuICBpZiAoZmluaXNoZWRXb3JrLmZsYWdzID4gUGVyZm9ybWVkV29yaykge1xuICAgIC8vIEEgZmliZXIncyBlZmZlY3QgbGlzdCBjb25zaXN0cyBvbmx5IG9mIGl0cyBjaGlsZHJlbiwgbm90IGl0c2VsZi4gU28gaWZcbiAgICAvLyB0aGUgcm9vdCBoYXMgYW4gZWZmZWN0LCB3ZSBuZWVkIHRvIGFkZCBpdCB0byB0aGUgZW5kIG9mIHRoZSBsaXN0LiBUaGVcbiAgICAvLyByZXN1bHRpbmcgbGlzdCBpcyB0aGUgc2V0IHRoYXQgd291bGQgYmVsb25nIHRvIHRoZSByb290J3MgcGFyZW50LCBpZiBpdFxuICAgIC8vIGhhZCBvbmU7IHRoYXQgaXMsIGFsbCB0aGUgZWZmZWN0cyBpbiB0aGUgdHJlZSBpbmNsdWRpbmcgdGhlIHJvb3QuXG4gICAgaWYgKGZpbmlzaGVkV29yay5sYXN0RWZmZWN0ICE9PSBudWxsKSB7XG4gICAgICBmaW5pc2hlZFdvcmsubGFzdEVmZmVjdC5uZXh0RWZmZWN0ID0gZmluaXNoZWRXb3JrO1xuICAgICAgZmlyc3RFZmZlY3QgPSBmaW5pc2hlZFdvcmsuZmlyc3RFZmZlY3Q7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZpcnN0RWZmZWN0ID0gZmluaXNoZWRXb3JrO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBUaGVyZSBpcyBubyBlZmZlY3Qgb24gdGhlIHJvb3QuXG4gICAgZmlyc3RFZmZlY3QgPSBmaW5pc2hlZFdvcmsuZmlyc3RFZmZlY3Q7XG4gIH1cblxuICBpZiAoZmlyc3RFZmZlY3QgIT09IG51bGwpIHtcblxuICAgIHZhciBwcmV2RXhlY3V0aW9uQ29udGV4dCA9IGV4ZWN1dGlvbkNvbnRleHQ7XG4gICAgZXhlY3V0aW9uQ29udGV4dCB8PSBDb21taXRDb250ZXh0O1xuICAgIHZhciBwcmV2SW50ZXJhY3Rpb25zID0gcHVzaEludGVyYWN0aW9ucyhyb290KTsgLy8gUmVzZXQgdGhpcyB0byBudWxsIGJlZm9yZSBjYWxsaW5nIGxpZmVjeWNsZXNcblxuICAgIFJlYWN0Q3VycmVudE93bmVyJDIuY3VycmVudCA9IG51bGw7IC8vIFRoZSBjb21taXQgcGhhc2UgaXMgYnJva2VuIGludG8gc2V2ZXJhbCBzdWItcGhhc2VzLiBXZSBkbyBhIHNlcGFyYXRlIHBhc3NcbiAgICAvLyBvZiB0aGUgZWZmZWN0IGxpc3QgZm9yIGVhY2ggcGhhc2U6IGFsbCBtdXRhdGlvbiBlZmZlY3RzIGNvbWUgYmVmb3JlIGFsbFxuICAgIC8vIGxheW91dCBlZmZlY3RzLCBhbmQgc28gb24uXG4gICAgLy8gVGhlIGZpcnN0IHBoYXNlIGEgXCJiZWZvcmUgbXV0YXRpb25cIiBwaGFzZS4gV2UgdXNlIHRoaXMgcGhhc2UgdG8gcmVhZCB0aGVcbiAgICAvLyBzdGF0ZSBvZiB0aGUgaG9zdCB0cmVlIHJpZ2h0IGJlZm9yZSB3ZSBtdXRhdGUgaXQuIFRoaXMgaXMgd2hlcmVcbiAgICAvLyBnZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSBpcyBjYWxsZWQuXG5cbiAgICBmb2N1c2VkSW5zdGFuY2VIYW5kbGUgPSBwcmVwYXJlRm9yQ29tbWl0KHJvb3QuY29udGFpbmVySW5mbyk7XG4gICAgc2hvdWxkRmlyZUFmdGVyQWN0aXZlSW5zdGFuY2VCbHVyID0gZmFsc2U7XG4gICAgbmV4dEVmZmVjdCA9IGZpcnN0RWZmZWN0O1xuXG4gICAgZG8ge1xuICAgICAge1xuICAgICAgICBpbnZva2VHdWFyZGVkQ2FsbGJhY2sobnVsbCwgY29tbWl0QmVmb3JlTXV0YXRpb25FZmZlY3RzLCBudWxsKTtcblxuICAgICAgICBpZiAoaGFzQ2F1Z2h0RXJyb3IoKSkge1xuICAgICAgICAgIGlmICghKG5leHRFZmZlY3QgIT09IG51bGwpKSB7XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHRocm93IEVycm9yKCBcIlNob3VsZCBiZSB3b3JraW5nIG9uIGFuIGVmZmVjdC5cIiApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBlcnJvciA9IGNsZWFyQ2F1Z2h0RXJyb3IoKTtcbiAgICAgICAgICBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihuZXh0RWZmZWN0LCBlcnJvcik7XG4gICAgICAgICAgbmV4dEVmZmVjdCA9IG5leHRFZmZlY3QubmV4dEVmZmVjdDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gd2hpbGUgKG5leHRFZmZlY3QgIT09IG51bGwpOyAvLyBXZSBubyBsb25nZXIgbmVlZCB0byB0cmFjayB0aGUgYWN0aXZlIGluc3RhbmNlIGZpYmVyXG5cblxuICAgIGZvY3VzZWRJbnN0YW5jZUhhbmRsZSA9IG51bGw7XG5cbiAgICB7XG4gICAgICAvLyBNYXJrIHRoZSBjdXJyZW50IGNvbW1pdCB0aW1lIHRvIGJlIHNoYXJlZCBieSBhbGwgUHJvZmlsZXJzIGluIHRoaXNcbiAgICAgIC8vIGJhdGNoLiBUaGlzIGVuYWJsZXMgdGhlbSB0byBiZSBncm91cGVkIGxhdGVyLlxuICAgICAgcmVjb3JkQ29tbWl0VGltZSgpO1xuICAgIH0gLy8gVGhlIG5leHQgcGhhc2UgaXMgdGhlIG11dGF0aW9uIHBoYXNlLCB3aGVyZSB3ZSBtdXRhdGUgdGhlIGhvc3QgdHJlZS5cblxuXG4gICAgbmV4dEVmZmVjdCA9IGZpcnN0RWZmZWN0O1xuXG4gICAgZG8ge1xuICAgICAge1xuICAgICAgICBpbnZva2VHdWFyZGVkQ2FsbGJhY2sobnVsbCwgY29tbWl0TXV0YXRpb25FZmZlY3RzLCBudWxsLCByb290LCByZW5kZXJQcmlvcml0eUxldmVsKTtcblxuICAgICAgICBpZiAoaGFzQ2F1Z2h0RXJyb3IoKSkge1xuICAgICAgICAgIGlmICghKG5leHRFZmZlY3QgIT09IG51bGwpKSB7XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHRocm93IEVycm9yKCBcIlNob3VsZCBiZSB3b3JraW5nIG9uIGFuIGVmZmVjdC5cIiApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBfZXJyb3IgPSBjbGVhckNhdWdodEVycm9yKCk7XG5cbiAgICAgICAgICBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihuZXh0RWZmZWN0LCBfZXJyb3IpO1xuICAgICAgICAgIG5leHRFZmZlY3QgPSBuZXh0RWZmZWN0Lm5leHRFZmZlY3Q7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IHdoaWxlIChuZXh0RWZmZWN0ICE9PSBudWxsKTtcblxuICAgIHJlc2V0QWZ0ZXJDb21taXQocm9vdC5jb250YWluZXJJbmZvKTsgLy8gVGhlIHdvcmstaW4tcHJvZ3Jlc3MgdHJlZSBpcyBub3cgdGhlIGN1cnJlbnQgdHJlZS4gVGhpcyBtdXN0IGNvbWUgYWZ0ZXJcbiAgICAvLyB0aGUgbXV0YXRpb24gcGhhc2UsIHNvIHRoYXQgdGhlIHByZXZpb3VzIHRyZWUgaXMgc3RpbGwgY3VycmVudCBkdXJpbmdcbiAgICAvLyBjb21wb25lbnRXaWxsVW5tb3VudCwgYnV0IGJlZm9yZSB0aGUgbGF5b3V0IHBoYXNlLCBzbyB0aGF0IHRoZSBmaW5pc2hlZFxuICAgIC8vIHdvcmsgaXMgY3VycmVudCBkdXJpbmcgY29tcG9uZW50RGlkTW91bnQvVXBkYXRlLlxuXG4gICAgcm9vdC5jdXJyZW50ID0gZmluaXNoZWRXb3JrOyAvLyBUaGUgbmV4dCBwaGFzZSBpcyB0aGUgbGF5b3V0IHBoYXNlLCB3aGVyZSB3ZSBjYWxsIGVmZmVjdHMgdGhhdCByZWFkXG4gICAgLy8gdGhlIGhvc3QgdHJlZSBhZnRlciBpdCdzIGJlZW4gbXV0YXRlZC4gVGhlIGlkaW9tYXRpYyB1c2UgY2FzZSBmb3IgdGhpcyBpc1xuICAgIC8vIGxheW91dCwgYnV0IGNsYXNzIGNvbXBvbmVudCBsaWZlY3ljbGVzIGFsc28gZmlyZSBoZXJlIGZvciBsZWdhY3kgcmVhc29ucy5cblxuICAgIG5leHRFZmZlY3QgPSBmaXJzdEVmZmVjdDtcblxuICAgIGRvIHtcbiAgICAgIHtcbiAgICAgICAgaW52b2tlR3VhcmRlZENhbGxiYWNrKG51bGwsIGNvbW1pdExheW91dEVmZmVjdHMsIG51bGwsIHJvb3QsIGxhbmVzKTtcblxuICAgICAgICBpZiAoaGFzQ2F1Z2h0RXJyb3IoKSkge1xuICAgICAgICAgIGlmICghKG5leHRFZmZlY3QgIT09IG51bGwpKSB7XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHRocm93IEVycm9yKCBcIlNob3VsZCBiZSB3b3JraW5nIG9uIGFuIGVmZmVjdC5cIiApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBfZXJyb3IyID0gY2xlYXJDYXVnaHRFcnJvcigpO1xuXG4gICAgICAgICAgY2FwdHVyZUNvbW1pdFBoYXNlRXJyb3IobmV4dEVmZmVjdCwgX2Vycm9yMik7XG4gICAgICAgICAgbmV4dEVmZmVjdCA9IG5leHRFZmZlY3QubmV4dEVmZmVjdDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gd2hpbGUgKG5leHRFZmZlY3QgIT09IG51bGwpO1xuXG4gICAgbmV4dEVmZmVjdCA9IG51bGw7IC8vIFRlbGwgU2NoZWR1bGVyIHRvIHlpZWxkIGF0IHRoZSBlbmQgb2YgdGhlIGZyYW1lLCBzbyB0aGUgYnJvd3NlciBoYXMgYW5cbiAgICAvLyBvcHBvcnR1bml0eSB0byBwYWludC5cblxuICAgIHJlcXVlc3RQYWludCgpO1xuXG4gICAge1xuICAgICAgcG9wSW50ZXJhY3Rpb25zKHByZXZJbnRlcmFjdGlvbnMpO1xuICAgIH1cblxuICAgIGV4ZWN1dGlvbkNvbnRleHQgPSBwcmV2RXhlY3V0aW9uQ29udGV4dDtcbiAgfSBlbHNlIHtcbiAgICAvLyBObyBlZmZlY3RzLlxuICAgIHJvb3QuY3VycmVudCA9IGZpbmlzaGVkV29yazsgLy8gTWVhc3VyZSB0aGVzZSBhbnl3YXkgc28gdGhlIGZsYW1lZ3JhcGggZXhwbGljaXRseSBzaG93cyB0aGF0IHRoZXJlIHdlcmVcbiAgICAvLyBubyBlZmZlY3RzLlxuICAgIC8vIFRPRE86IE1heWJlIHRoZXJlJ3MgYSBiZXR0ZXIgd2F5IHRvIHJlcG9ydCB0aGlzLlxuXG4gICAge1xuICAgICAgcmVjb3JkQ29tbWl0VGltZSgpO1xuICAgIH1cbiAgfVxuXG4gIHZhciByb290RGlkSGF2ZVBhc3NpdmVFZmZlY3RzID0gcm9vdERvZXNIYXZlUGFzc2l2ZUVmZmVjdHM7XG5cbiAgaWYgKHJvb3REb2VzSGF2ZVBhc3NpdmVFZmZlY3RzKSB7XG4gICAgLy8gVGhpcyBjb21taXQgaGFzIHBhc3NpdmUgZWZmZWN0cy4gU3Rhc2ggYSByZWZlcmVuY2UgdG8gdGhlbS4gQnV0IGRvbid0XG4gICAgLy8gc2NoZWR1bGUgYSBjYWxsYmFjayB1bnRpbCBhZnRlciBmbHVzaGluZyBsYXlvdXQgd29yay5cbiAgICByb290RG9lc0hhdmVQYXNzaXZlRWZmZWN0cyA9IGZhbHNlO1xuICAgIHJvb3RXaXRoUGVuZGluZ1Bhc3NpdmVFZmZlY3RzID0gcm9vdDtcbiAgICBwZW5kaW5nUGFzc2l2ZUVmZmVjdHNMYW5lcyA9IGxhbmVzO1xuICAgIHBlbmRpbmdQYXNzaXZlRWZmZWN0c1JlbmRlclByaW9yaXR5ID0gcmVuZGVyUHJpb3JpdHlMZXZlbDtcbiAgfSBlbHNlIHtcbiAgICAvLyBXZSBhcmUgZG9uZSB3aXRoIHRoZSBlZmZlY3QgY2hhaW4gYXQgdGhpcyBwb2ludCBzbyBsZXQncyBjbGVhciB0aGVcbiAgICAvLyBuZXh0RWZmZWN0IHBvaW50ZXJzIHRvIGFzc2lzdCB3aXRoIEdDLiBJZiB3ZSBoYXZlIHBhc3NpdmUgZWZmZWN0cywgd2UnbGxcbiAgICAvLyBjbGVhciB0aGlzIGluIGZsdXNoUGFzc2l2ZUVmZmVjdHMuXG4gICAgbmV4dEVmZmVjdCA9IGZpcnN0RWZmZWN0O1xuXG4gICAgd2hpbGUgKG5leHRFZmZlY3QgIT09IG51bGwpIHtcbiAgICAgIHZhciBuZXh0TmV4dEVmZmVjdCA9IG5leHRFZmZlY3QubmV4dEVmZmVjdDtcbiAgICAgIG5leHRFZmZlY3QubmV4dEVmZmVjdCA9IG51bGw7XG5cbiAgICAgIGlmIChuZXh0RWZmZWN0LmZsYWdzICYgRGVsZXRpb24pIHtcbiAgICAgICAgZGV0YWNoRmliZXJBZnRlckVmZmVjdHMobmV4dEVmZmVjdCk7XG4gICAgICB9XG5cbiAgICAgIG5leHRFZmZlY3QgPSBuZXh0TmV4dEVmZmVjdDtcbiAgICB9XG4gIH0gLy8gUmVhZCB0aGlzIGFnYWluLCBzaW5jZSBhbiBlZmZlY3QgbWlnaHQgaGF2ZSB1cGRhdGVkIGl0XG5cblxuICByZW1haW5pbmdMYW5lcyA9IHJvb3QucGVuZGluZ0xhbmVzOyAvLyBDaGVjayBpZiB0aGVyZSdzIHJlbWFpbmluZyB3b3JrIG9uIHRoaXMgcm9vdFxuXG4gIGlmIChyZW1haW5pbmdMYW5lcyAhPT0gTm9MYW5lcykge1xuICAgIHtcbiAgICAgIGlmIChzcGF3bmVkV29ya0R1cmluZ1JlbmRlciAhPT0gbnVsbCkge1xuICAgICAgICB2YXIgZXhwaXJhdGlvblRpbWVzID0gc3Bhd25lZFdvcmtEdXJpbmdSZW5kZXI7XG4gICAgICAgIHNwYXduZWRXb3JrRHVyaW5nUmVuZGVyID0gbnVsbDtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGV4cGlyYXRpb25UaW1lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHNjaGVkdWxlSW50ZXJhY3Rpb25zKHJvb3QsIGV4cGlyYXRpb25UaW1lc1tpXSwgcm9vdC5tZW1vaXplZEludGVyYWN0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgc2NoZWR1bGVQZW5kaW5nSW50ZXJhY3Rpb25zKHJvb3QsIHJlbWFpbmluZ0xhbmVzKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gSWYgdGhlcmUncyBubyByZW1haW5pbmcgd29yaywgd2UgY2FuIGNsZWFyIHRoZSBzZXQgb2YgYWxyZWFkeSBmYWlsZWRcbiAgICAvLyBlcnJvciBib3VuZGFyaWVzLlxuICAgIGxlZ2FjeUVycm9yQm91bmRhcmllc1RoYXRBbHJlYWR5RmFpbGVkID0gbnVsbDtcbiAgfVxuXG4gIHtcbiAgICBpZiAoIXJvb3REaWRIYXZlUGFzc2l2ZUVmZmVjdHMpIHtcbiAgICAgIC8vIElmIHRoZXJlIGFyZSBubyBwYXNzaXZlIGVmZmVjdHMsIHRoZW4gd2UgY2FuIGNvbXBsZXRlIHRoZSBwZW5kaW5nIGludGVyYWN0aW9ucy5cbiAgICAgIC8vIE90aGVyd2lzZSwgd2UnbGwgd2FpdCB1bnRpbCBhZnRlciB0aGUgcGFzc2l2ZSBlZmZlY3RzIGFyZSBmbHVzaGVkLlxuICAgICAgLy8gV2FpdCB0byBkbyB0aGlzIHVudGlsIGFmdGVyIHJlbWFpbmluZyB3b3JrIGhhcyBiZWVuIHNjaGVkdWxlZCxcbiAgICAgIC8vIHNvIHRoYXQgd2UgZG9uJ3QgcHJlbWF0dXJlbHkgc2lnbmFsIGNvbXBsZXRlIGZvciBpbnRlcmFjdGlvbnMgd2hlbiB0aGVyZSdzIGUuZy4gaGlkZGVuIHdvcmsuXG4gICAgICBmaW5pc2hQZW5kaW5nSW50ZXJhY3Rpb25zKHJvb3QsIGxhbmVzKTtcbiAgICB9XG4gIH1cblxuICBpZiAocmVtYWluaW5nTGFuZXMgPT09IFN5bmNMYW5lKSB7XG4gICAgLy8gQ291bnQgdGhlIG51bWJlciBvZiB0aW1lcyB0aGUgcm9vdCBzeW5jaHJvbm91c2x5IHJlLXJlbmRlcnMgd2l0aG91dFxuICAgIC8vIGZpbmlzaGluZy4gSWYgdGhlcmUgYXJlIHRvbyBtYW55LCBpdCBpbmRpY2F0ZXMgYW4gaW5maW5pdGUgdXBkYXRlIGxvb3AuXG4gICAgaWYgKHJvb3QgPT09IHJvb3RXaXRoTmVzdGVkVXBkYXRlcykge1xuICAgICAgbmVzdGVkVXBkYXRlQ291bnQrKztcbiAgICB9IGVsc2Uge1xuICAgICAgbmVzdGVkVXBkYXRlQ291bnQgPSAwO1xuICAgICAgcm9vdFdpdGhOZXN0ZWRVcGRhdGVzID0gcm9vdDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgbmVzdGVkVXBkYXRlQ291bnQgPSAwO1xuICB9XG5cbiAgb25Db21taXRSb290KGZpbmlzaGVkV29yay5zdGF0ZU5vZGUsIHJlbmRlclByaW9yaXR5TGV2ZWwpO1xuXG4gIHtcbiAgICBvbkNvbW1pdFJvb3QkMSgpO1xuICB9IC8vIEFsd2F5cyBjYWxsIHRoaXMgYmVmb3JlIGV4aXRpbmcgYGNvbW1pdFJvb3RgLCB0byBlbnN1cmUgdGhhdCBhbnlcbiAgLy8gYWRkaXRpb25hbCB3b3JrIG9uIHRoaXMgcm9vdCBpcyBzY2hlZHVsZWQuXG5cblxuICBlbnN1cmVSb290SXNTY2hlZHVsZWQocm9vdCwgbm93KCkpO1xuXG4gIGlmIChoYXNVbmNhdWdodEVycm9yKSB7XG4gICAgaGFzVW5jYXVnaHRFcnJvciA9IGZhbHNlO1xuICAgIHZhciBfZXJyb3IzID0gZmlyc3RVbmNhdWdodEVycm9yO1xuICAgIGZpcnN0VW5jYXVnaHRFcnJvciA9IG51bGw7XG4gICAgdGhyb3cgX2Vycm9yMztcbiAgfVxuXG4gIGlmICgoZXhlY3V0aW9uQ29udGV4dCAmIExlZ2FjeVVuYmF0Y2hlZENvbnRleHQpICE9PSBOb0NvbnRleHQpIHtcbiAgICAvLyBhIFJlYWN0RE9NLnJlbmRlci1lZCByb290IGluc2lkZSBvZiBiYXRjaGVkVXBkYXRlcy4gVGhlIGNvbW1pdCBmaXJlZFxuICAgIC8vIHN5bmNocm9ub3VzbHksIGJ1dCBsYXlvdXQgdXBkYXRlcyBzaG91bGQgYmUgZGVmZXJyZWQgdW50aWwgdGhlIGVuZFxuICAgIC8vIG9mIHRoZSBiYXRjaC5cblxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH0gLy8gSWYgbGF5b3V0IHdvcmsgd2FzIHNjaGVkdWxlZCwgZmx1c2ggaXQgbm93LlxuXG5cbiAgZmx1c2hTeW5jQ2FsbGJhY2tRdWV1ZSgpO1xuXG4gIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiBjb21taXRCZWZvcmVNdXRhdGlvbkVmZmVjdHMoKSB7XG4gIHdoaWxlIChuZXh0RWZmZWN0ICE9PSBudWxsKSB7XG4gICAgdmFyIGN1cnJlbnQgPSBuZXh0RWZmZWN0LmFsdGVybmF0ZTtcblxuICAgIGlmICghc2hvdWxkRmlyZUFmdGVyQWN0aXZlSW5zdGFuY2VCbHVyICYmIGZvY3VzZWRJbnN0YW5jZUhhbmRsZSAhPT0gbnVsbCkge1xuICAgICAgaWYgKChuZXh0RWZmZWN0LmZsYWdzICYgRGVsZXRpb24pICE9PSBOb0ZsYWdzKSB7XG4gICAgICAgIGlmIChkb2VzRmliZXJDb250YWluKG5leHRFZmZlY3QsIGZvY3VzZWRJbnN0YW5jZUhhbmRsZSkpIHtcbiAgICAgICAgICBzaG91bGRGaXJlQWZ0ZXJBY3RpdmVJbnN0YW5jZUJsdXIgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBUT0RPOiBNb3ZlIHRoaXMgb3V0IG9mIHRoZSBob3QgcGF0aCB1c2luZyBhIGRlZGljYXRlZCBlZmZlY3QgdGFnLlxuICAgICAgICBpZiAobmV4dEVmZmVjdC50YWcgPT09IFN1c3BlbnNlQ29tcG9uZW50ICYmIGlzU3VzcGVuc2VCb3VuZGFyeUJlaW5nSGlkZGVuKGN1cnJlbnQsIG5leHRFZmZlY3QpICYmIGRvZXNGaWJlckNvbnRhaW4obmV4dEVmZmVjdCwgZm9jdXNlZEluc3RhbmNlSGFuZGxlKSkge1xuICAgICAgICAgIHNob3VsZEZpcmVBZnRlckFjdGl2ZUluc3RhbmNlQmx1ciA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgZmxhZ3MgPSBuZXh0RWZmZWN0LmZsYWdzO1xuXG4gICAgaWYgKChmbGFncyAmIFNuYXBzaG90KSAhPT0gTm9GbGFncykge1xuICAgICAgc2V0Q3VycmVudEZpYmVyKG5leHRFZmZlY3QpO1xuICAgICAgY29tbWl0QmVmb3JlTXV0YXRpb25MaWZlQ3ljbGVzKGN1cnJlbnQsIG5leHRFZmZlY3QpO1xuICAgICAgcmVzZXRDdXJyZW50RmliZXIoKTtcbiAgICB9XG5cbiAgICBpZiAoKGZsYWdzICYgUGFzc2l2ZSkgIT09IE5vRmxhZ3MpIHtcbiAgICAgIC8vIElmIHRoZXJlIGFyZSBwYXNzaXZlIGVmZmVjdHMsIHNjaGVkdWxlIGEgY2FsbGJhY2sgdG8gZmx1c2ggYXRcbiAgICAgIC8vIHRoZSBlYXJsaWVzdCBvcHBvcnR1bml0eS5cbiAgICAgIGlmICghcm9vdERvZXNIYXZlUGFzc2l2ZUVmZmVjdHMpIHtcbiAgICAgICAgcm9vdERvZXNIYXZlUGFzc2l2ZUVmZmVjdHMgPSB0cnVlO1xuICAgICAgICBzY2hlZHVsZUNhbGxiYWNrKE5vcm1hbFByaW9yaXR5JDEsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBmbHVzaFBhc3NpdmVFZmZlY3RzKCk7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIG5leHRFZmZlY3QgPSBuZXh0RWZmZWN0Lm5leHRFZmZlY3Q7XG4gIH1cbn1cblxuZnVuY3Rpb24gY29tbWl0TXV0YXRpb25FZmZlY3RzKHJvb3QsIHJlbmRlclByaW9yaXR5TGV2ZWwpIHtcbiAgLy8gVE9ETzogU2hvdWxkIHByb2JhYmx5IG1vdmUgdGhlIGJ1bGsgb2YgdGhpcyBmdW5jdGlvbiB0byBjb21taXRXb3JrLlxuICB3aGlsZSAobmV4dEVmZmVjdCAhPT0gbnVsbCkge1xuICAgIHNldEN1cnJlbnRGaWJlcihuZXh0RWZmZWN0KTtcbiAgICB2YXIgZmxhZ3MgPSBuZXh0RWZmZWN0LmZsYWdzO1xuXG4gICAgaWYgKGZsYWdzICYgQ29udGVudFJlc2V0KSB7XG4gICAgICBjb21taXRSZXNldFRleHRDb250ZW50KG5leHRFZmZlY3QpO1xuICAgIH1cblxuICAgIGlmIChmbGFncyAmIFJlZikge1xuICAgICAgdmFyIGN1cnJlbnQgPSBuZXh0RWZmZWN0LmFsdGVybmF0ZTtcblxuICAgICAgaWYgKGN1cnJlbnQgIT09IG51bGwpIHtcbiAgICAgICAgY29tbWl0RGV0YWNoUmVmKGN1cnJlbnQpO1xuICAgICAgfVxuICAgIH0gLy8gVGhlIGZvbGxvd2luZyBzd2l0Y2ggc3RhdGVtZW50IGlzIG9ubHkgY29uY2VybmVkIGFib3V0IHBsYWNlbWVudCxcbiAgICAvLyB1cGRhdGVzLCBhbmQgZGVsZXRpb25zLiBUbyBhdm9pZCBuZWVkaW5nIHRvIGFkZCBhIGNhc2UgZm9yIGV2ZXJ5IHBvc3NpYmxlXG4gICAgLy8gYml0bWFwIHZhbHVlLCB3ZSByZW1vdmUgdGhlIHNlY29uZGFyeSBlZmZlY3RzIGZyb20gdGhlIGVmZmVjdCB0YWcgYW5kXG4gICAgLy8gc3dpdGNoIG9uIHRoYXQgdmFsdWUuXG5cblxuICAgIHZhciBwcmltYXJ5RmxhZ3MgPSBmbGFncyAmIChQbGFjZW1lbnQgfCBVcGRhdGUgfCBEZWxldGlvbiB8IEh5ZHJhdGluZyk7XG5cbiAgICBzd2l0Y2ggKHByaW1hcnlGbGFncykge1xuICAgICAgY2FzZSBQbGFjZW1lbnQ6XG4gICAgICAgIHtcbiAgICAgICAgICBjb21taXRQbGFjZW1lbnQobmV4dEVmZmVjdCk7IC8vIENsZWFyIHRoZSBcInBsYWNlbWVudFwiIGZyb20gZWZmZWN0IHRhZyBzbyB0aGF0IHdlIGtub3cgdGhhdCB0aGlzIGlzXG4gICAgICAgICAgLy8gaW5zZXJ0ZWQsIGJlZm9yZSBhbnkgbGlmZS1jeWNsZXMgbGlrZSBjb21wb25lbnREaWRNb3VudCBnZXRzIGNhbGxlZC5cbiAgICAgICAgICAvLyBUT0RPOiBmaW5kRE9NTm9kZSBkb2Vzbid0IHJlbHkgb24gdGhpcyBhbnkgbW9yZSBidXQgaXNNb3VudGVkIGRvZXNcbiAgICAgICAgICAvLyBhbmQgaXNNb3VudGVkIGlzIGRlcHJlY2F0ZWQgYW55d2F5IHNvIHdlIHNob3VsZCBiZSBhYmxlIHRvIGtpbGwgdGhpcy5cblxuICAgICAgICAgIG5leHRFZmZlY3QuZmxhZ3MgJj0gflBsYWNlbWVudDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIFBsYWNlbWVudEFuZFVwZGF0ZTpcbiAgICAgICAge1xuICAgICAgICAgIC8vIFBsYWNlbWVudFxuICAgICAgICAgIGNvbW1pdFBsYWNlbWVudChuZXh0RWZmZWN0KTsgLy8gQ2xlYXIgdGhlIFwicGxhY2VtZW50XCIgZnJvbSBlZmZlY3QgdGFnIHNvIHRoYXQgd2Uga25vdyB0aGF0IHRoaXMgaXNcbiAgICAgICAgICAvLyBpbnNlcnRlZCwgYmVmb3JlIGFueSBsaWZlLWN5Y2xlcyBsaWtlIGNvbXBvbmVudERpZE1vdW50IGdldHMgY2FsbGVkLlxuXG4gICAgICAgICAgbmV4dEVmZmVjdC5mbGFncyAmPSB+UGxhY2VtZW50OyAvLyBVcGRhdGVcblxuICAgICAgICAgIHZhciBfY3VycmVudCA9IG5leHRFZmZlY3QuYWx0ZXJuYXRlO1xuICAgICAgICAgIGNvbW1pdFdvcmsoX2N1cnJlbnQsIG5leHRFZmZlY3QpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgSHlkcmF0aW5nOlxuICAgICAgICB7XG4gICAgICAgICAgbmV4dEVmZmVjdC5mbGFncyAmPSB+SHlkcmF0aW5nO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgSHlkcmF0aW5nQW5kVXBkYXRlOlxuICAgICAgICB7XG4gICAgICAgICAgbmV4dEVmZmVjdC5mbGFncyAmPSB+SHlkcmF0aW5nOyAvLyBVcGRhdGVcblxuICAgICAgICAgIHZhciBfY3VycmVudDIgPSBuZXh0RWZmZWN0LmFsdGVybmF0ZTtcbiAgICAgICAgICBjb21taXRXb3JrKF9jdXJyZW50MiwgbmV4dEVmZmVjdCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBVcGRhdGU6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgX2N1cnJlbnQzID0gbmV4dEVmZmVjdC5hbHRlcm5hdGU7XG4gICAgICAgICAgY29tbWl0V29yayhfY3VycmVudDMsIG5leHRFZmZlY3QpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgRGVsZXRpb246XG4gICAgICAgIHtcbiAgICAgICAgICBjb21taXREZWxldGlvbihyb290LCBuZXh0RWZmZWN0KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJlc2V0Q3VycmVudEZpYmVyKCk7XG4gICAgbmV4dEVmZmVjdCA9IG5leHRFZmZlY3QubmV4dEVmZmVjdDtcbiAgfVxufVxuXG5mdW5jdGlvbiBjb21taXRMYXlvdXRFZmZlY3RzKHJvb3QsIGNvbW1pdHRlZExhbmVzKSB7XG5cblxuICB3aGlsZSAobmV4dEVmZmVjdCAhPT0gbnVsbCkge1xuICAgIHNldEN1cnJlbnRGaWJlcihuZXh0RWZmZWN0KTtcbiAgICB2YXIgZmxhZ3MgPSBuZXh0RWZmZWN0LmZsYWdzO1xuXG4gICAgaWYgKGZsYWdzICYgKFVwZGF0ZSB8IENhbGxiYWNrKSkge1xuICAgICAgdmFyIGN1cnJlbnQgPSBuZXh0RWZmZWN0LmFsdGVybmF0ZTtcbiAgICAgIGNvbW1pdExpZmVDeWNsZXMocm9vdCwgY3VycmVudCwgbmV4dEVmZmVjdCk7XG4gICAgfVxuXG4gICAge1xuICAgICAgaWYgKGZsYWdzICYgUmVmKSB7XG4gICAgICAgIGNvbW1pdEF0dGFjaFJlZihuZXh0RWZmZWN0KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXNldEN1cnJlbnRGaWJlcigpO1xuICAgIG5leHRFZmZlY3QgPSBuZXh0RWZmZWN0Lm5leHRFZmZlY3Q7XG4gIH1cbn1cblxuZnVuY3Rpb24gZmx1c2hQYXNzaXZlRWZmZWN0cygpIHtcbiAgLy8gUmV0dXJucyB3aGV0aGVyIHBhc3NpdmUgZWZmZWN0cyB3ZXJlIGZsdXNoZWQuXG4gIGlmIChwZW5kaW5nUGFzc2l2ZUVmZmVjdHNSZW5kZXJQcmlvcml0eSAhPT0gTm9Qcmlvcml0eSQxKSB7XG4gICAgdmFyIHByaW9yaXR5TGV2ZWwgPSBwZW5kaW5nUGFzc2l2ZUVmZmVjdHNSZW5kZXJQcmlvcml0eSA+IE5vcm1hbFByaW9yaXR5JDEgPyBOb3JtYWxQcmlvcml0eSQxIDogcGVuZGluZ1Bhc3NpdmVFZmZlY3RzUmVuZGVyUHJpb3JpdHk7XG4gICAgcGVuZGluZ1Bhc3NpdmVFZmZlY3RzUmVuZGVyUHJpb3JpdHkgPSBOb1ByaW9yaXR5JDE7XG5cbiAgICB7XG4gICAgICByZXR1cm4gcnVuV2l0aFByaW9yaXR5JDEocHJpb3JpdHlMZXZlbCwgZmx1c2hQYXNzaXZlRWZmZWN0c0ltcGwpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGVucXVldWVQZW5kaW5nUGFzc2l2ZUhvb2tFZmZlY3RNb3VudChmaWJlciwgZWZmZWN0KSB7XG4gIHBlbmRpbmdQYXNzaXZlSG9va0VmZmVjdHNNb3VudC5wdXNoKGVmZmVjdCwgZmliZXIpO1xuXG4gIGlmICghcm9vdERvZXNIYXZlUGFzc2l2ZUVmZmVjdHMpIHtcbiAgICByb290RG9lc0hhdmVQYXNzaXZlRWZmZWN0cyA9IHRydWU7XG4gICAgc2NoZWR1bGVDYWxsYmFjayhOb3JtYWxQcmlvcml0eSQxLCBmdW5jdGlvbiAoKSB7XG4gICAgICBmbHVzaFBhc3NpdmVFZmZlY3RzKCk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9KTtcbiAgfVxufVxuZnVuY3Rpb24gZW5xdWV1ZVBlbmRpbmdQYXNzaXZlSG9va0VmZmVjdFVubW91bnQoZmliZXIsIGVmZmVjdCkge1xuICBwZW5kaW5nUGFzc2l2ZUhvb2tFZmZlY3RzVW5tb3VudC5wdXNoKGVmZmVjdCwgZmliZXIpO1xuXG4gIHtcbiAgICBmaWJlci5mbGFncyB8PSBQYXNzaXZlVW5tb3VudFBlbmRpbmdEZXY7XG4gICAgdmFyIGFsdGVybmF0ZSA9IGZpYmVyLmFsdGVybmF0ZTtcblxuICAgIGlmIChhbHRlcm5hdGUgIT09IG51bGwpIHtcbiAgICAgIGFsdGVybmF0ZS5mbGFncyB8PSBQYXNzaXZlVW5tb3VudFBlbmRpbmdEZXY7XG4gICAgfVxuICB9XG5cbiAgaWYgKCFyb290RG9lc0hhdmVQYXNzaXZlRWZmZWN0cykge1xuICAgIHJvb3REb2VzSGF2ZVBhc3NpdmVFZmZlY3RzID0gdHJ1ZTtcbiAgICBzY2hlZHVsZUNhbGxiYWNrKE5vcm1hbFByaW9yaXR5JDEsIGZ1bmN0aW9uICgpIHtcbiAgICAgIGZsdXNoUGFzc2l2ZUVmZmVjdHMoKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGludm9rZVBhc3NpdmVFZmZlY3RDcmVhdGUoZWZmZWN0KSB7XG4gIHZhciBjcmVhdGUgPSBlZmZlY3QuY3JlYXRlO1xuICBlZmZlY3QuZGVzdHJveSA9IGNyZWF0ZSgpO1xufVxuXG5mdW5jdGlvbiBmbHVzaFBhc3NpdmVFZmZlY3RzSW1wbCgpIHtcbiAgaWYgKHJvb3RXaXRoUGVuZGluZ1Bhc3NpdmVFZmZlY3RzID09PSBudWxsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIHJvb3QgPSByb290V2l0aFBlbmRpbmdQYXNzaXZlRWZmZWN0cztcbiAgdmFyIGxhbmVzID0gcGVuZGluZ1Bhc3NpdmVFZmZlY3RzTGFuZXM7XG4gIHJvb3RXaXRoUGVuZGluZ1Bhc3NpdmVFZmZlY3RzID0gbnVsbDtcbiAgcGVuZGluZ1Bhc3NpdmVFZmZlY3RzTGFuZXMgPSBOb0xhbmVzO1xuXG4gIGlmICghKChleGVjdXRpb25Db250ZXh0ICYgKFJlbmRlckNvbnRleHQgfCBDb21taXRDb250ZXh0KSkgPT09IE5vQ29udGV4dCkpIHtcbiAgICB7XG4gICAgICB0aHJvdyBFcnJvciggXCJDYW5ub3QgZmx1c2ggcGFzc2l2ZSBlZmZlY3RzIHdoaWxlIGFscmVhZHkgcmVuZGVyaW5nLlwiICk7XG4gICAgfVxuICB9XG5cbiAge1xuICAgIGlzRmx1c2hpbmdQYXNzaXZlRWZmZWN0cyA9IHRydWU7XG4gIH1cblxuICB2YXIgcHJldkV4ZWN1dGlvbkNvbnRleHQgPSBleGVjdXRpb25Db250ZXh0O1xuICBleGVjdXRpb25Db250ZXh0IHw9IENvbW1pdENvbnRleHQ7XG4gIHZhciBwcmV2SW50ZXJhY3Rpb25zID0gcHVzaEludGVyYWN0aW9ucyhyb290KTsgLy8gSXQncyBpbXBvcnRhbnQgdGhhdCBBTEwgcGVuZGluZyBwYXNzaXZlIGVmZmVjdCBkZXN0cm95IGZ1bmN0aW9ucyBhcmUgY2FsbGVkXG4gIC8vIGJlZm9yZSBBTlkgcGFzc2l2ZSBlZmZlY3QgY3JlYXRlIGZ1bmN0aW9ucyBhcmUgY2FsbGVkLlxuICAvLyBPdGhlcndpc2UgZWZmZWN0cyBpbiBzaWJsaW5nIGNvbXBvbmVudHMgbWlnaHQgaW50ZXJmZXJlIHdpdGggZWFjaCBvdGhlci5cbiAgLy8gZS5nLiBhIGRlc3Ryb3kgZnVuY3Rpb24gaW4gb25lIGNvbXBvbmVudCBtYXkgdW5pbnRlbnRpb25hbGx5IG92ZXJyaWRlIGEgcmVmXG4gIC8vIHZhbHVlIHNldCBieSBhIGNyZWF0ZSBmdW5jdGlvbiBpbiBhbm90aGVyIGNvbXBvbmVudC5cbiAgLy8gTGF5b3V0IGVmZmVjdHMgaGF2ZSB0aGUgc2FtZSBjb25zdHJhaW50LlxuICAvLyBGaXJzdCBwYXNzOiBEZXN0cm95IHN0YWxlIHBhc3NpdmUgZWZmZWN0cy5cblxuICB2YXIgdW5tb3VudEVmZmVjdHMgPSBwZW5kaW5nUGFzc2l2ZUhvb2tFZmZlY3RzVW5tb3VudDtcbiAgcGVuZGluZ1Bhc3NpdmVIb29rRWZmZWN0c1VubW91bnQgPSBbXTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHVubW91bnRFZmZlY3RzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgdmFyIF9lZmZlY3QgPSB1bm1vdW50RWZmZWN0c1tpXTtcbiAgICB2YXIgZmliZXIgPSB1bm1vdW50RWZmZWN0c1tpICsgMV07XG4gICAgdmFyIGRlc3Ryb3kgPSBfZWZmZWN0LmRlc3Ryb3k7XG4gICAgX2VmZmVjdC5kZXN0cm95ID0gdW5kZWZpbmVkO1xuXG4gICAge1xuICAgICAgZmliZXIuZmxhZ3MgJj0gflBhc3NpdmVVbm1vdW50UGVuZGluZ0RldjtcbiAgICAgIHZhciBhbHRlcm5hdGUgPSBmaWJlci5hbHRlcm5hdGU7XG5cbiAgICAgIGlmIChhbHRlcm5hdGUgIT09IG51bGwpIHtcbiAgICAgICAgYWx0ZXJuYXRlLmZsYWdzICY9IH5QYXNzaXZlVW5tb3VudFBlbmRpbmdEZXY7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBkZXN0cm95ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB7XG4gICAgICAgIHNldEN1cnJlbnRGaWJlcihmaWJlcik7XG5cbiAgICAgICAge1xuICAgICAgICAgIGludm9rZUd1YXJkZWRDYWxsYmFjayhudWxsLCBkZXN0cm95LCBudWxsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChoYXNDYXVnaHRFcnJvcigpKSB7XG4gICAgICAgICAgaWYgKCEoZmliZXIgIT09IG51bGwpKSB7XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHRocm93IEVycm9yKCBcIlNob3VsZCBiZSB3b3JraW5nIG9uIGFuIGVmZmVjdC5cIiApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBlcnJvciA9IGNsZWFyQ2F1Z2h0RXJyb3IoKTtcbiAgICAgICAgICBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihmaWJlciwgZXJyb3IpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVzZXRDdXJyZW50RmliZXIoKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gLy8gU2Vjb25kIHBhc3M6IENyZWF0ZSBuZXcgcGFzc2l2ZSBlZmZlY3RzLlxuXG5cbiAgdmFyIG1vdW50RWZmZWN0cyA9IHBlbmRpbmdQYXNzaXZlSG9va0VmZmVjdHNNb3VudDtcbiAgcGVuZGluZ1Bhc3NpdmVIb29rRWZmZWN0c01vdW50ID0gW107XG5cbiAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IG1vdW50RWZmZWN0cy5sZW5ndGg7IF9pICs9IDIpIHtcbiAgICB2YXIgX2VmZmVjdDIgPSBtb3VudEVmZmVjdHNbX2ldO1xuICAgIHZhciBfZmliZXIgPSBtb3VudEVmZmVjdHNbX2kgKyAxXTtcblxuICAgIHtcbiAgICAgIHNldEN1cnJlbnRGaWJlcihfZmliZXIpO1xuXG4gICAgICB7XG4gICAgICAgIGludm9rZUd1YXJkZWRDYWxsYmFjayhudWxsLCBpbnZva2VQYXNzaXZlRWZmZWN0Q3JlYXRlLCBudWxsLCBfZWZmZWN0Mik7XG4gICAgICB9XG5cbiAgICAgIGlmIChoYXNDYXVnaHRFcnJvcigpKSB7XG4gICAgICAgIGlmICghKF9maWJlciAhPT0gbnVsbCkpIHtcbiAgICAgICAgICB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvciggXCJTaG91bGQgYmUgd29ya2luZyBvbiBhbiBlZmZlY3QuXCIgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgX2Vycm9yNCA9IGNsZWFyQ2F1Z2h0RXJyb3IoKTtcblxuICAgICAgICBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihfZmliZXIsIF9lcnJvcjQpO1xuICAgICAgfVxuXG4gICAgICByZXNldEN1cnJlbnRGaWJlcigpO1xuICAgIH1cbiAgfSAvLyBOb3RlOiBUaGlzIGN1cnJlbnRseSBhc3N1bWVzIHRoZXJlIGFyZSBubyBwYXNzaXZlIGVmZmVjdHMgb24gdGhlIHJvb3QgZmliZXJcbiAgLy8gYmVjYXVzZSB0aGUgcm9vdCBpcyBub3QgcGFydCBvZiBpdHMgb3duIGVmZmVjdCBsaXN0LlxuICAvLyBUaGlzIGNvdWxkIGNoYW5nZSBpbiB0aGUgZnV0dXJlLlxuXG5cbiAgdmFyIGVmZmVjdCA9IHJvb3QuY3VycmVudC5maXJzdEVmZmVjdDtcblxuICB3aGlsZSAoZWZmZWN0ICE9PSBudWxsKSB7XG4gICAgdmFyIG5leHROZXh0RWZmZWN0ID0gZWZmZWN0Lm5leHRFZmZlY3Q7IC8vIFJlbW92ZSBuZXh0RWZmZWN0IHBvaW50ZXIgdG8gYXNzaXN0IEdDXG5cbiAgICBlZmZlY3QubmV4dEVmZmVjdCA9IG51bGw7XG5cbiAgICBpZiAoZWZmZWN0LmZsYWdzICYgRGVsZXRpb24pIHtcbiAgICAgIGRldGFjaEZpYmVyQWZ0ZXJFZmZlY3RzKGVmZmVjdCk7XG4gICAgfVxuXG4gICAgZWZmZWN0ID0gbmV4dE5leHRFZmZlY3Q7XG4gIH1cblxuICB7XG4gICAgcG9wSW50ZXJhY3Rpb25zKHByZXZJbnRlcmFjdGlvbnMpO1xuICAgIGZpbmlzaFBlbmRpbmdJbnRlcmFjdGlvbnMocm9vdCwgbGFuZXMpO1xuICB9XG5cbiAge1xuICAgIGlzRmx1c2hpbmdQYXNzaXZlRWZmZWN0cyA9IGZhbHNlO1xuICB9XG5cbiAgZXhlY3V0aW9uQ29udGV4dCA9IHByZXZFeGVjdXRpb25Db250ZXh0O1xuICBmbHVzaFN5bmNDYWxsYmFja1F1ZXVlKCk7IC8vIElmIGFkZGl0aW9uYWwgcGFzc2l2ZSBlZmZlY3RzIHdlcmUgc2NoZWR1bGVkLCBpbmNyZW1lbnQgYSBjb3VudGVyLiBJZiB0aGlzXG4gIC8vIGV4Y2VlZHMgdGhlIGxpbWl0LCB3ZSdsbCBmaXJlIGEgd2FybmluZy5cblxuICBuZXN0ZWRQYXNzaXZlVXBkYXRlQ291bnQgPSByb290V2l0aFBlbmRpbmdQYXNzaXZlRWZmZWN0cyA9PT0gbnVsbCA/IDAgOiBuZXN0ZWRQYXNzaXZlVXBkYXRlQ291bnQgKyAxO1xuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gaXNBbHJlYWR5RmFpbGVkTGVnYWN5RXJyb3JCb3VuZGFyeShpbnN0YW5jZSkge1xuICByZXR1cm4gbGVnYWN5RXJyb3JCb3VuZGFyaWVzVGhhdEFscmVhZHlGYWlsZWQgIT09IG51bGwgJiYgbGVnYWN5RXJyb3JCb3VuZGFyaWVzVGhhdEFscmVhZHlGYWlsZWQuaGFzKGluc3RhbmNlKTtcbn1cbmZ1bmN0aW9uIG1hcmtMZWdhY3lFcnJvckJvdW5kYXJ5QXNGYWlsZWQoaW5zdGFuY2UpIHtcbiAgaWYgKGxlZ2FjeUVycm9yQm91bmRhcmllc1RoYXRBbHJlYWR5RmFpbGVkID09PSBudWxsKSB7XG4gICAgbGVnYWN5RXJyb3JCb3VuZGFyaWVzVGhhdEFscmVhZHlGYWlsZWQgPSBuZXcgU2V0KFtpbnN0YW5jZV0pO1xuICB9IGVsc2Uge1xuICAgIGxlZ2FjeUVycm9yQm91bmRhcmllc1RoYXRBbHJlYWR5RmFpbGVkLmFkZChpbnN0YW5jZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJlcGFyZVRvVGhyb3dVbmNhdWdodEVycm9yKGVycm9yKSB7XG4gIGlmICghaGFzVW5jYXVnaHRFcnJvcikge1xuICAgIGhhc1VuY2F1Z2h0RXJyb3IgPSB0cnVlO1xuICAgIGZpcnN0VW5jYXVnaHRFcnJvciA9IGVycm9yO1xuICB9XG59XG5cbnZhciBvblVuY2F1Z2h0RXJyb3IgPSBwcmVwYXJlVG9UaHJvd1VuY2F1Z2h0RXJyb3I7XG5cbmZ1bmN0aW9uIGNhcHR1cmVDb21taXRQaGFzZUVycm9yT25Sb290KHJvb3RGaWJlciwgc291cmNlRmliZXIsIGVycm9yKSB7XG4gIHZhciBlcnJvckluZm8gPSBjcmVhdGVDYXB0dXJlZFZhbHVlKGVycm9yLCBzb3VyY2VGaWJlcik7XG4gIHZhciB1cGRhdGUgPSBjcmVhdGVSb290RXJyb3JVcGRhdGUocm9vdEZpYmVyLCBlcnJvckluZm8sIFN5bmNMYW5lKTtcbiAgZW5xdWV1ZVVwZGF0ZShyb290RmliZXIsIHVwZGF0ZSk7XG4gIHZhciBldmVudFRpbWUgPSByZXF1ZXN0RXZlbnRUaW1lKCk7XG4gIHZhciByb290ID0gbWFya1VwZGF0ZUxhbmVGcm9tRmliZXJUb1Jvb3Qocm9vdEZpYmVyLCBTeW5jTGFuZSk7XG5cbiAgaWYgKHJvb3QgIT09IG51bGwpIHtcbiAgICBtYXJrUm9vdFVwZGF0ZWQocm9vdCwgU3luY0xhbmUsIGV2ZW50VGltZSk7XG4gICAgZW5zdXJlUm9vdElzU2NoZWR1bGVkKHJvb3QsIGV2ZW50VGltZSk7XG4gICAgc2NoZWR1bGVQZW5kaW5nSW50ZXJhY3Rpb25zKHJvb3QsIFN5bmNMYW5lKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihzb3VyY2VGaWJlciwgZXJyb3IpIHtcbiAgaWYgKHNvdXJjZUZpYmVyLnRhZyA9PT0gSG9zdFJvb3QpIHtcbiAgICAvLyBFcnJvciB3YXMgdGhyb3duIGF0IHRoZSByb290LiBUaGVyZSBpcyBubyBwYXJlbnQsIHNvIHRoZSByb290XG4gICAgLy8gaXRzZWxmIHNob3VsZCBjYXB0dXJlIGl0LlxuICAgIGNhcHR1cmVDb21taXRQaGFzZUVycm9yT25Sb290KHNvdXJjZUZpYmVyLCBzb3VyY2VGaWJlciwgZXJyb3IpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBmaWJlciA9IHNvdXJjZUZpYmVyLnJldHVybjtcblxuICB3aGlsZSAoZmliZXIgIT09IG51bGwpIHtcbiAgICBpZiAoZmliZXIudGFnID09PSBIb3N0Um9vdCkge1xuICAgICAgY2FwdHVyZUNvbW1pdFBoYXNlRXJyb3JPblJvb3QoZmliZXIsIHNvdXJjZUZpYmVyLCBlcnJvcik7XG4gICAgICByZXR1cm47XG4gICAgfSBlbHNlIGlmIChmaWJlci50YWcgPT09IENsYXNzQ29tcG9uZW50KSB7XG4gICAgICB2YXIgY3RvciA9IGZpYmVyLnR5cGU7XG4gICAgICB2YXIgaW5zdGFuY2UgPSBmaWJlci5zdGF0ZU5vZGU7XG5cbiAgICAgIGlmICh0eXBlb2YgY3Rvci5nZXREZXJpdmVkU3RhdGVGcm9tRXJyb3IgPT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudERpZENhdGNoID09PSAnZnVuY3Rpb24nICYmICFpc0FscmVhZHlGYWlsZWRMZWdhY3lFcnJvckJvdW5kYXJ5KGluc3RhbmNlKSkge1xuICAgICAgICB2YXIgZXJyb3JJbmZvID0gY3JlYXRlQ2FwdHVyZWRWYWx1ZShlcnJvciwgc291cmNlRmliZXIpO1xuICAgICAgICB2YXIgdXBkYXRlID0gY3JlYXRlQ2xhc3NFcnJvclVwZGF0ZShmaWJlciwgZXJyb3JJbmZvLCBTeW5jTGFuZSk7XG4gICAgICAgIGVucXVldWVVcGRhdGUoZmliZXIsIHVwZGF0ZSk7XG4gICAgICAgIHZhciBldmVudFRpbWUgPSByZXF1ZXN0RXZlbnRUaW1lKCk7XG4gICAgICAgIHZhciByb290ID0gbWFya1VwZGF0ZUxhbmVGcm9tRmliZXJUb1Jvb3QoZmliZXIsIFN5bmNMYW5lKTtcblxuICAgICAgICBpZiAocm9vdCAhPT0gbnVsbCkge1xuICAgICAgICAgIG1hcmtSb290VXBkYXRlZChyb290LCBTeW5jTGFuZSwgZXZlbnRUaW1lKTtcbiAgICAgICAgICBlbnN1cmVSb290SXNTY2hlZHVsZWQocm9vdCwgZXZlbnRUaW1lKTtcbiAgICAgICAgICBzY2hlZHVsZVBlbmRpbmdJbnRlcmFjdGlvbnMocm9vdCwgU3luY0xhbmUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIFRoaXMgY29tcG9uZW50IGhhcyBhbHJlYWR5IGJlZW4gdW5tb3VudGVkLlxuICAgICAgICAgIC8vIFdlIGNhbid0IHNjaGVkdWxlIGFueSBmb2xsb3cgdXAgd29yayBmb3IgdGhlIHJvb3QgYmVjYXVzZSB0aGUgZmliZXIgaXMgYWxyZWFkeSB1bm1vdW50ZWQsXG4gICAgICAgICAgLy8gYnV0IHdlIGNhbiBzdGlsbCBjYWxsIHRoZSBsb2ctb25seSBib3VuZGFyeSBzbyB0aGUgZXJyb3IgaXNuJ3Qgc3dhbGxvd2VkLlxuICAgICAgICAgIC8vXG4gICAgICAgICAgLy8gVE9ETyBUaGlzIGlzIG9ubHkgYSB0ZW1wb3JhcnkgYmFuZGFpZCBmb3IgdGhlIG9sZCByZWNvbmNpbGVyIGZvcmsuXG4gICAgICAgICAgLy8gV2UgY2FuIGRlbGV0ZSB0aGlzIHNwZWNpYWwgY2FzZSBvbmNlIHRoZSBuZXcgZm9yayBpcyBtZXJnZWQuXG4gICAgICAgICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnREaWRDYXRjaCA9PT0gJ2Z1bmN0aW9uJyAmJiAhaXNBbHJlYWR5RmFpbGVkTGVnYWN5RXJyb3JCb3VuZGFyeShpbnN0YW5jZSkpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGluc3RhbmNlLmNvbXBvbmVudERpZENhdGNoKGVycm9yLCBlcnJvckluZm8pO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3JUb0lnbm9yZSkgey8vIFRPRE8gSWdub3JlIHRoaXMgZXJyb3I/IFJldGhyb3cgaXQ/XG4gICAgICAgICAgICAgIC8vIFRoaXMgaXMga2luZCBvZiBhbiBlZGdlIGNhc2UuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZpYmVyID0gZmliZXIucmV0dXJuO1xuICB9XG59XG5mdW5jdGlvbiBwaW5nU3VzcGVuZGVkUm9vdChyb290LCB3YWtlYWJsZSwgcGluZ2VkTGFuZXMpIHtcbiAgdmFyIHBpbmdDYWNoZSA9IHJvb3QucGluZ0NhY2hlO1xuXG4gIGlmIChwaW5nQ2FjaGUgIT09IG51bGwpIHtcbiAgICAvLyBUaGUgd2FrZWFibGUgcmVzb2x2ZWQsIHNvIHdlIG5vIGxvbmdlciBuZWVkIHRvIG1lbW9pemUsIGJlY2F1c2UgaXQgd2lsbFxuICAgIC8vIG5ldmVyIGJlIHRocm93biBhZ2Fpbi5cbiAgICBwaW5nQ2FjaGUuZGVsZXRlKHdha2VhYmxlKTtcbiAgfVxuXG4gIHZhciBldmVudFRpbWUgPSByZXF1ZXN0RXZlbnRUaW1lKCk7XG4gIG1hcmtSb290UGluZ2VkKHJvb3QsIHBpbmdlZExhbmVzKTtcblxuICBpZiAod29ya0luUHJvZ3Jlc3NSb290ID09PSByb290ICYmIGlzU3Vic2V0T2ZMYW5lcyh3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcywgcGluZ2VkTGFuZXMpKSB7XG4gICAgLy8gUmVjZWl2ZWQgYSBwaW5nIGF0IHRoZSBzYW1lIHByaW9yaXR5IGxldmVsIGF0IHdoaWNoIHdlJ3JlIGN1cnJlbnRseVxuICAgIC8vIHJlbmRlcmluZy4gV2UgbWlnaHQgd2FudCB0byByZXN0YXJ0IHRoaXMgcmVuZGVyLiBUaGlzIHNob3VsZCBtaXJyb3JcbiAgICAvLyB0aGUgbG9naWMgb2Ygd2hldGhlciBvciBub3QgYSByb290IHN1c3BlbmRzIG9uY2UgaXQgY29tcGxldGVzLlxuICAgIC8vIFRPRE86IElmIHdlJ3JlIHJlbmRlcmluZyBzeW5jIGVpdGhlciBkdWUgdG8gU3luYywgQmF0Y2hlZCBvciBleHBpcmVkLFxuICAgIC8vIHdlIHNob3VsZCBwcm9iYWJseSBuZXZlciByZXN0YXJ0LlxuICAgIC8vIElmIHdlJ3JlIHN1c3BlbmRlZCB3aXRoIGRlbGF5LCBvciBpZiBpdCdzIGEgcmV0cnksIHdlJ2xsIGFsd2F5cyBzdXNwZW5kXG4gICAgLy8gc28gd2UgY2FuIGFsd2F5cyByZXN0YXJ0LlxuICAgIGlmICh3b3JrSW5Qcm9ncmVzc1Jvb3RFeGl0U3RhdHVzID09PSBSb290U3VzcGVuZGVkV2l0aERlbGF5IHx8IHdvcmtJblByb2dyZXNzUm9vdEV4aXRTdGF0dXMgPT09IFJvb3RTdXNwZW5kZWQgJiYgaW5jbHVkZXNPbmx5UmV0cmllcyh3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcykgJiYgbm93KCkgLSBnbG9iYWxNb3N0UmVjZW50RmFsbGJhY2tUaW1lIDwgRkFMTEJBQ0tfVEhST1RUTEVfTVMpIHtcbiAgICAgIC8vIFJlc3RhcnQgZnJvbSB0aGUgcm9vdC5cbiAgICAgIHByZXBhcmVGcmVzaFN0YWNrKHJvb3QsIE5vTGFuZXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBFdmVuIHRob3VnaCB3ZSBjYW4ndCByZXN0YXJ0IHJpZ2h0IG5vdywgd2UgbWlnaHQgZ2V0IGFuXG4gICAgICAvLyBvcHBvcnR1bml0eSBsYXRlci4gU28gd2UgbWFyayB0aGlzIHJlbmRlciBhcyBoYXZpbmcgYSBwaW5nLlxuICAgICAgd29ya0luUHJvZ3Jlc3NSb290UGluZ2VkTGFuZXMgPSBtZXJnZUxhbmVzKHdvcmtJblByb2dyZXNzUm9vdFBpbmdlZExhbmVzLCBwaW5nZWRMYW5lcyk7XG4gICAgfVxuICB9XG5cbiAgZW5zdXJlUm9vdElzU2NoZWR1bGVkKHJvb3QsIGV2ZW50VGltZSk7XG4gIHNjaGVkdWxlUGVuZGluZ0ludGVyYWN0aW9ucyhyb290LCBwaW5nZWRMYW5lcyk7XG59XG5cbmZ1bmN0aW9uIHJldHJ5VGltZWRPdXRCb3VuZGFyeShib3VuZGFyeUZpYmVyLCByZXRyeUxhbmUpIHtcbiAgLy8gVGhlIGJvdW5kYXJ5IGZpYmVyIChhIFN1c3BlbnNlIGNvbXBvbmVudCBvciBTdXNwZW5zZUxpc3QgY29tcG9uZW50KVxuICAvLyBwcmV2aW91c2x5IHdhcyByZW5kZXJlZCBpbiBpdHMgZmFsbGJhY2sgc3RhdGUuIE9uZSBvZiB0aGUgcHJvbWlzZXMgdGhhdFxuICAvLyBzdXNwZW5kZWQgaXQgaGFzIHJlc29sdmVkLCB3aGljaCBtZWFucyBhdCBsZWFzdCBwYXJ0IG9mIHRoZSB0cmVlIHdhc1xuICAvLyBsaWtlbHkgdW5ibG9ja2VkLiBUcnkgcmVuZGVyaW5nIGFnYWluLCBhdCBhIG5ldyBleHBpcmF0aW9uIHRpbWUuXG4gIGlmIChyZXRyeUxhbmUgPT09IE5vTGFuZSkge1xuICAgIHJldHJ5TGFuZSA9IHJlcXVlc3RSZXRyeUxhbmUoYm91bmRhcnlGaWJlcik7XG4gIH0gLy8gVE9ETzogU3BlY2lhbCBjYXNlIGlkbGUgcHJpb3JpdHk/XG5cblxuICB2YXIgZXZlbnRUaW1lID0gcmVxdWVzdEV2ZW50VGltZSgpO1xuICB2YXIgcm9vdCA9IG1hcmtVcGRhdGVMYW5lRnJvbUZpYmVyVG9Sb290KGJvdW5kYXJ5RmliZXIsIHJldHJ5TGFuZSk7XG5cbiAgaWYgKHJvb3QgIT09IG51bGwpIHtcbiAgICBtYXJrUm9vdFVwZGF0ZWQocm9vdCwgcmV0cnlMYW5lLCBldmVudFRpbWUpO1xuICAgIGVuc3VyZVJvb3RJc1NjaGVkdWxlZChyb290LCBldmVudFRpbWUpO1xuICAgIHNjaGVkdWxlUGVuZGluZ0ludGVyYWN0aW9ucyhyb290LCByZXRyeUxhbmUpO1xuICB9XG59XG5mdW5jdGlvbiByZXNvbHZlUmV0cnlXYWtlYWJsZShib3VuZGFyeUZpYmVyLCB3YWtlYWJsZSkge1xuICB2YXIgcmV0cnlMYW5lID0gTm9MYW5lOyAvLyBEZWZhdWx0XG5cbiAgdmFyIHJldHJ5Q2FjaGU7XG5cbiAge1xuICAgIHJldHJ5Q2FjaGUgPSBib3VuZGFyeUZpYmVyLnN0YXRlTm9kZTtcbiAgfVxuXG4gIGlmIChyZXRyeUNhY2hlICE9PSBudWxsKSB7XG4gICAgLy8gVGhlIHdha2VhYmxlIHJlc29sdmVkLCBzbyB3ZSBubyBsb25nZXIgbmVlZCB0byBtZW1vaXplLCBiZWNhdXNlIGl0IHdpbGxcbiAgICAvLyBuZXZlciBiZSB0aHJvd24gYWdhaW4uXG4gICAgcmV0cnlDYWNoZS5kZWxldGUod2FrZWFibGUpO1xuICB9XG5cbiAgcmV0cnlUaW1lZE91dEJvdW5kYXJ5KGJvdW5kYXJ5RmliZXIsIHJldHJ5TGFuZSk7XG59IC8vIENvbXB1dGVzIHRoZSBuZXh0IEp1c3QgTm90aWNlYWJsZSBEaWZmZXJlbmNlIChKTkQpIGJvdW5kYXJ5LlxuLy8gVGhlIHRoZW9yeSBpcyB0aGF0IGEgcGVyc29uIGNhbid0IHRlbGwgdGhlIGRpZmZlcmVuY2UgYmV0d2VlbiBzbWFsbCBkaWZmZXJlbmNlcyBpbiB0aW1lLlxuLy8gVGhlcmVmb3JlLCBpZiB3ZSB3YWl0IGEgYml0IGxvbmdlciB0aGFuIG5lY2Vzc2FyeSB0aGF0IHdvbid0IHRyYW5zbGF0ZSB0byBhIG5vdGljZWFibGVcbi8vIGRpZmZlcmVuY2UgaW4gdGhlIGV4cGVyaWVuY2UuIEhvd2V2ZXIsIHdhaXRpbmcgZm9yIGxvbmdlciBtaWdodCBtZWFuIHRoYXQgd2UgY2FuIGF2b2lkXG4vLyBzaG93aW5nIGFuIGludGVybWVkaWF0ZSBsb2FkaW5nIHN0YXRlLiBUaGUgbG9uZ2VyIHdlIGhhdmUgYWxyZWFkeSB3YWl0ZWQsIHRoZSBoYXJkZXIgaXRcbi8vIGlzIHRvIHRlbGwgc21hbGwgZGlmZmVyZW5jZXMgaW4gdGltZS4gVGhlcmVmb3JlLCB0aGUgbG9uZ2VyIHdlJ3ZlIGFscmVhZHkgd2FpdGVkLFxuLy8gdGhlIGxvbmdlciB3ZSBjYW4gd2FpdCBhZGRpdGlvbmFsbHkuIEF0IHNvbWUgcG9pbnQgd2UgaGF2ZSB0byBnaXZlIHVwIHRob3VnaC5cbi8vIFdlIHBpY2sgYSB0cmFpbiBtb2RlbCB3aGVyZSB0aGUgbmV4dCBib3VuZGFyeSBjb21taXRzIGF0IGEgY29uc2lzdGVudCBzY2hlZHVsZS5cbi8vIFRoZXNlIHBhcnRpY3VsYXIgbnVtYmVycyBhcmUgdmFndWUgZXN0aW1hdGVzLiBXZSBleHBlY3QgdG8gYWRqdXN0IHRoZW0gYmFzZWQgb24gcmVzZWFyY2guXG5cbmZ1bmN0aW9uIGpuZCh0aW1lRWxhcHNlZCkge1xuICByZXR1cm4gdGltZUVsYXBzZWQgPCAxMjAgPyAxMjAgOiB0aW1lRWxhcHNlZCA8IDQ4MCA/IDQ4MCA6IHRpbWVFbGFwc2VkIDwgMTA4MCA/IDEwODAgOiB0aW1lRWxhcHNlZCA8IDE5MjAgPyAxOTIwIDogdGltZUVsYXBzZWQgPCAzMDAwID8gMzAwMCA6IHRpbWVFbGFwc2VkIDwgNDMyMCA/IDQzMjAgOiBjZWlsKHRpbWVFbGFwc2VkIC8gMTk2MCkgKiAxOTYwO1xufVxuXG5mdW5jdGlvbiBjaGVja0Zvck5lc3RlZFVwZGF0ZXMoKSB7XG4gIGlmIChuZXN0ZWRVcGRhdGVDb3VudCA+IE5FU1RFRF9VUERBVEVfTElNSVQpIHtcbiAgICBuZXN0ZWRVcGRhdGVDb3VudCA9IDA7XG4gICAgcm9vdFdpdGhOZXN0ZWRVcGRhdGVzID0gbnVsbDtcblxuICAgIHtcbiAgICAgIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoIFwiTWF4aW11bSB1cGRhdGUgZGVwdGggZXhjZWVkZWQuIFRoaXMgY2FuIGhhcHBlbiB3aGVuIGEgY29tcG9uZW50IHJlcGVhdGVkbHkgY2FsbHMgc2V0U3RhdGUgaW5zaWRlIGNvbXBvbmVudFdpbGxVcGRhdGUgb3IgY29tcG9uZW50RGlkVXBkYXRlLiBSZWFjdCBsaW1pdHMgdGhlIG51bWJlciBvZiBuZXN0ZWQgdXBkYXRlcyB0byBwcmV2ZW50IGluZmluaXRlIGxvb3BzLlwiICk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAge1xuICAgIGlmIChuZXN0ZWRQYXNzaXZlVXBkYXRlQ291bnQgPiBORVNURURfUEFTU0lWRV9VUERBVEVfTElNSVQpIHtcbiAgICAgIG5lc3RlZFBhc3NpdmVVcGRhdGVDb3VudCA9IDA7XG5cbiAgICAgIGVycm9yKCdNYXhpbXVtIHVwZGF0ZSBkZXB0aCBleGNlZWRlZC4gVGhpcyBjYW4gaGFwcGVuIHdoZW4gYSBjb21wb25lbnQgJyArIFwiY2FsbHMgc2V0U3RhdGUgaW5zaWRlIHVzZUVmZmVjdCwgYnV0IHVzZUVmZmVjdCBlaXRoZXIgZG9lc24ndCBcIiArICdoYXZlIGEgZGVwZW5kZW5jeSBhcnJheSwgb3Igb25lIG9mIHRoZSBkZXBlbmRlbmNpZXMgY2hhbmdlcyBvbiAnICsgJ2V2ZXJ5IHJlbmRlci4nKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZmx1c2hSZW5kZXJQaGFzZVN0cmljdE1vZGVXYXJuaW5nc0luREVWKCkge1xuICB7XG4gICAgUmVhY3RTdHJpY3RNb2RlV2FybmluZ3MuZmx1c2hMZWdhY3lDb250ZXh0V2FybmluZygpO1xuXG4gICAge1xuICAgICAgUmVhY3RTdHJpY3RNb2RlV2FybmluZ3MuZmx1c2hQZW5kaW5nVW5zYWZlTGlmZWN5Y2xlV2FybmluZ3MoKTtcbiAgICB9XG4gIH1cbn1cblxudmFyIGRpZFdhcm5TdGF0ZVVwZGF0ZUZvck5vdFlldE1vdW50ZWRDb21wb25lbnQgPSBudWxsO1xuXG5mdW5jdGlvbiB3YXJuQWJvdXRVcGRhdGVPbk5vdFlldE1vdW50ZWRGaWJlckluREVWKGZpYmVyKSB7XG4gIHtcbiAgICBpZiAoKGV4ZWN1dGlvbkNvbnRleHQgJiBSZW5kZXJDb250ZXh0KSAhPT0gTm9Db250ZXh0KSB7XG4gICAgICAvLyBXZSBsZXQgdGhlIG90aGVyIHdhcm5pbmcgYWJvdXQgcmVuZGVyIHBoYXNlIHVwZGF0ZXMgZGVhbCB3aXRoIHRoaXMgb25lLlxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICghKGZpYmVyLm1vZGUgJiAoQmxvY2tpbmdNb2RlIHwgQ29uY3VycmVudE1vZGUpKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciB0YWcgPSBmaWJlci50YWc7XG5cbiAgICBpZiAodGFnICE9PSBJbmRldGVybWluYXRlQ29tcG9uZW50ICYmIHRhZyAhPT0gSG9zdFJvb3QgJiYgdGFnICE9PSBDbGFzc0NvbXBvbmVudCAmJiB0YWcgIT09IEZ1bmN0aW9uQ29tcG9uZW50ICYmIHRhZyAhPT0gRm9yd2FyZFJlZiAmJiB0YWcgIT09IE1lbW9Db21wb25lbnQgJiYgdGFnICE9PSBTaW1wbGVNZW1vQ29tcG9uZW50ICYmIHRhZyAhPT0gQmxvY2spIHtcbiAgICAgIC8vIE9ubHkgd2FybiBmb3IgdXNlci1kZWZpbmVkIGNvbXBvbmVudHMsIG5vdCBpbnRlcm5hbCBvbmVzIGxpa2UgU3VzcGVuc2UuXG4gICAgICByZXR1cm47XG4gICAgfSAvLyBXZSBzaG93IHRoZSB3aG9sZSBzdGFjayBidXQgZGVkdXBlIG9uIHRoZSB0b3AgY29tcG9uZW50J3MgbmFtZSBiZWNhdXNlXG4gICAgLy8gdGhlIHByb2JsZW1hdGljIGNvZGUgYWxtb3N0IGFsd2F5cyBsaWVzIGluc2lkZSB0aGF0IGNvbXBvbmVudC5cblxuXG4gICAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lKGZpYmVyLnR5cGUpIHx8ICdSZWFjdENvbXBvbmVudCc7XG5cbiAgICBpZiAoZGlkV2FyblN0YXRlVXBkYXRlRm9yTm90WWV0TW91bnRlZENvbXBvbmVudCAhPT0gbnVsbCkge1xuICAgICAgaWYgKGRpZFdhcm5TdGF0ZVVwZGF0ZUZvck5vdFlldE1vdW50ZWRDb21wb25lbnQuaGFzKGNvbXBvbmVudE5hbWUpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgZGlkV2FyblN0YXRlVXBkYXRlRm9yTm90WWV0TW91bnRlZENvbXBvbmVudC5hZGQoY29tcG9uZW50TmFtZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRpZFdhcm5TdGF0ZVVwZGF0ZUZvck5vdFlldE1vdW50ZWRDb21wb25lbnQgPSBuZXcgU2V0KFtjb21wb25lbnROYW1lXSk7XG4gICAgfVxuXG4gICAgdmFyIHByZXZpb3VzRmliZXIgPSBjdXJyZW50O1xuXG4gICAgdHJ5IHtcbiAgICAgIHNldEN1cnJlbnRGaWJlcihmaWJlcik7XG5cbiAgICAgIGVycm9yKFwiQ2FuJ3QgcGVyZm9ybSBhIFJlYWN0IHN0YXRlIHVwZGF0ZSBvbiBhIGNvbXBvbmVudCB0aGF0IGhhc24ndCBtb3VudGVkIHlldC4gXCIgKyAnVGhpcyBpbmRpY2F0ZXMgdGhhdCB5b3UgaGF2ZSBhIHNpZGUtZWZmZWN0IGluIHlvdXIgcmVuZGVyIGZ1bmN0aW9uIHRoYXQgJyArICdhc3luY2hyb25vdXNseSBsYXRlciBjYWxscyB0cmllcyB0byB1cGRhdGUgdGhlIGNvbXBvbmVudC4gTW92ZSB0aGlzIHdvcmsgdG8gJyArICd1c2VFZmZlY3QgaW5zdGVhZC4nKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgaWYgKHByZXZpb3VzRmliZXIpIHtcbiAgICAgICAgc2V0Q3VycmVudEZpYmVyKGZpYmVyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc2V0Q3VycmVudEZpYmVyKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbnZhciBkaWRXYXJuU3RhdGVVcGRhdGVGb3JVbm1vdW50ZWRDb21wb25lbnQgPSBudWxsO1xuXG5mdW5jdGlvbiB3YXJuQWJvdXRVcGRhdGVPblVubW91bnRlZEZpYmVySW5ERVYoZmliZXIpIHtcbiAge1xuICAgIHZhciB0YWcgPSBmaWJlci50YWc7XG5cbiAgICBpZiAodGFnICE9PSBIb3N0Um9vdCAmJiB0YWcgIT09IENsYXNzQ29tcG9uZW50ICYmIHRhZyAhPT0gRnVuY3Rpb25Db21wb25lbnQgJiYgdGFnICE9PSBGb3J3YXJkUmVmICYmIHRhZyAhPT0gTWVtb0NvbXBvbmVudCAmJiB0YWcgIT09IFNpbXBsZU1lbW9Db21wb25lbnQgJiYgdGFnICE9PSBCbG9jaykge1xuICAgICAgLy8gT25seSB3YXJuIGZvciB1c2VyLWRlZmluZWQgY29tcG9uZW50cywgbm90IGludGVybmFsIG9uZXMgbGlrZSBTdXNwZW5zZS5cbiAgICAgIHJldHVybjtcbiAgICB9IC8vIElmIHRoZXJlIGFyZSBwZW5kaW5nIHBhc3NpdmUgZWZmZWN0cyB1bm1vdW50cyBmb3IgdGhpcyBGaWJlcixcbiAgICAvLyB3ZSBjYW4gYXNzdW1lIHRoYXQgdGhleSB3b3VsZCBoYXZlIHByZXZlbnRlZCB0aGlzIHVwZGF0ZS5cblxuXG4gICAgaWYgKChmaWJlci5mbGFncyAmIFBhc3NpdmVVbm1vdW50UGVuZGluZ0RldikgIT09IE5vRmxhZ3MpIHtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIFdlIHNob3cgdGhlIHdob2xlIHN0YWNrIGJ1dCBkZWR1cGUgb24gdGhlIHRvcCBjb21wb25lbnQncyBuYW1lIGJlY2F1c2VcbiAgICAvLyB0aGUgcHJvYmxlbWF0aWMgY29kZSBhbG1vc3QgYWx3YXlzIGxpZXMgaW5zaWRlIHRoYXQgY29tcG9uZW50LlxuXG5cbiAgICB2YXIgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWUoZmliZXIudHlwZSkgfHwgJ1JlYWN0Q29tcG9uZW50JztcblxuICAgIGlmIChkaWRXYXJuU3RhdGVVcGRhdGVGb3JVbm1vdW50ZWRDb21wb25lbnQgIT09IG51bGwpIHtcbiAgICAgIGlmIChkaWRXYXJuU3RhdGVVcGRhdGVGb3JVbm1vdW50ZWRDb21wb25lbnQuaGFzKGNvbXBvbmVudE5hbWUpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgZGlkV2FyblN0YXRlVXBkYXRlRm9yVW5tb3VudGVkQ29tcG9uZW50LmFkZChjb21wb25lbnROYW1lKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGlkV2FyblN0YXRlVXBkYXRlRm9yVW5tb3VudGVkQ29tcG9uZW50ID0gbmV3IFNldChbY29tcG9uZW50TmFtZV0pO1xuICAgIH1cblxuICAgIGlmIChpc0ZsdXNoaW5nUGFzc2l2ZUVmZmVjdHMpIDsgZWxzZSB7XG4gICAgICB2YXIgcHJldmlvdXNGaWJlciA9IGN1cnJlbnQ7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHNldEN1cnJlbnRGaWJlcihmaWJlcik7XG5cbiAgICAgICAgZXJyb3IoXCJDYW4ndCBwZXJmb3JtIGEgUmVhY3Qgc3RhdGUgdXBkYXRlIG9uIGFuIHVubW91bnRlZCBjb21wb25lbnQuIFRoaXMgXCIgKyAnaXMgYSBuby1vcCwgYnV0IGl0IGluZGljYXRlcyBhIG1lbW9yeSBsZWFrIGluIHlvdXIgYXBwbGljYXRpb24uIFRvICcgKyAnZml4LCBjYW5jZWwgYWxsIHN1YnNjcmlwdGlvbnMgYW5kIGFzeW5jaHJvbm91cyB0YXNrcyBpbiAlcy4nLCB0YWcgPT09IENsYXNzQ29tcG9uZW50ID8gJ3RoZSBjb21wb25lbnRXaWxsVW5tb3VudCBtZXRob2QnIDogJ2EgdXNlRWZmZWN0IGNsZWFudXAgZnVuY3Rpb24nKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGlmIChwcmV2aW91c0ZpYmVyKSB7XG4gICAgICAgICAgc2V0Q3VycmVudEZpYmVyKGZpYmVyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXNldEN1cnJlbnRGaWJlcigpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbnZhciBiZWdpbldvcmskMTtcblxue1xuICB2YXIgZHVtbXlGaWJlciA9IG51bGw7XG5cbiAgYmVnaW5Xb3JrJDEgPSBmdW5jdGlvbiAoY3VycmVudCwgdW5pdE9mV29yaywgbGFuZXMpIHtcbiAgICAvLyBJZiBhIGNvbXBvbmVudCB0aHJvd3MgYW4gZXJyb3IsIHdlIHJlcGxheSBpdCBhZ2FpbiBpbiBhIHN5bmNocm9ub3VzbHlcbiAgICAvLyBkaXNwYXRjaGVkIGV2ZW50LCBzbyB0aGF0IHRoZSBkZWJ1Z2dlciB3aWxsIHRyZWF0IGl0IGFzIGFuIHVuY2F1Z2h0XG4gICAgLy8gZXJyb3IgU2VlIFJlYWN0RXJyb3JVdGlscyBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cbiAgICAvLyBCZWZvcmUgZW50ZXJpbmcgdGhlIGJlZ2luIHBoYXNlLCBjb3B5IHRoZSB3b3JrLWluLXByb2dyZXNzIG9udG8gYSBkdW1teVxuICAgIC8vIGZpYmVyLiBJZiBiZWdpbldvcmsgdGhyb3dzLCB3ZSdsbCB1c2UgdGhpcyB0byByZXNldCB0aGUgc3RhdGUuXG4gICAgdmFyIG9yaWdpbmFsV29ya0luUHJvZ3Jlc3NDb3B5ID0gYXNzaWduRmliZXJQcm9wZXJ0aWVzSW5ERVYoZHVtbXlGaWJlciwgdW5pdE9mV29yayk7XG5cbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGJlZ2luV29yayhjdXJyZW50LCB1bml0T2ZXb3JrLCBsYW5lcyk7XG4gICAgfSBjYXRjaCAob3JpZ2luYWxFcnJvcikge1xuICAgICAgaWYgKG9yaWdpbmFsRXJyb3IgIT09IG51bGwgJiYgdHlwZW9mIG9yaWdpbmFsRXJyb3IgPT09ICdvYmplY3QnICYmIHR5cGVvZiBvcmlnaW5hbEVycm9yLnRoZW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgLy8gRG9uJ3QgcmVwbGF5IHByb21pc2VzLiBUcmVhdCBldmVyeXRoaW5nIGVsc2UgbGlrZSBhbiBlcnJvci5cbiAgICAgICAgdGhyb3cgb3JpZ2luYWxFcnJvcjtcbiAgICAgIH0gLy8gS2VlcCB0aGlzIGNvZGUgaW4gc3luYyB3aXRoIGhhbmRsZUVycm9yOyBhbnkgY2hhbmdlcyBoZXJlIG11c3QgaGF2ZVxuICAgICAgLy8gY29ycmVzcG9uZGluZyBjaGFuZ2VzIHRoZXJlLlxuXG5cbiAgICAgIHJlc2V0Q29udGV4dERlcGVuZGVuY2llcygpO1xuICAgICAgcmVzZXRIb29rc0FmdGVyVGhyb3coKTsgLy8gRG9uJ3QgcmVzZXQgY3VycmVudCBkZWJ1ZyBmaWJlciwgc2luY2Ugd2UncmUgYWJvdXQgdG8gd29yayBvbiB0aGVcbiAgICAgIC8vIHNhbWUgZmliZXIgYWdhaW4uXG4gICAgICAvLyBVbndpbmQgdGhlIGZhaWxlZCBzdGFjayBmcmFtZVxuXG4gICAgICB1bndpbmRJbnRlcnJ1cHRlZFdvcmsodW5pdE9mV29yayk7IC8vIFJlc3RvcmUgdGhlIG9yaWdpbmFsIHByb3BlcnRpZXMgb2YgdGhlIGZpYmVyLlxuXG4gICAgICBhc3NpZ25GaWJlclByb3BlcnRpZXNJbkRFVih1bml0T2ZXb3JrLCBvcmlnaW5hbFdvcmtJblByb2dyZXNzQ29weSk7XG5cbiAgICAgIGlmICggdW5pdE9mV29yay5tb2RlICYgUHJvZmlsZU1vZGUpIHtcbiAgICAgICAgLy8gUmVzZXQgdGhlIHByb2ZpbGVyIHRpbWVyLlxuICAgICAgICBzdGFydFByb2ZpbGVyVGltZXIodW5pdE9mV29yayk7XG4gICAgICB9IC8vIFJ1biBiZWdpbldvcmsgYWdhaW4uXG5cblxuICAgICAgaW52b2tlR3VhcmRlZENhbGxiYWNrKG51bGwsIGJlZ2luV29yaywgbnVsbCwgY3VycmVudCwgdW5pdE9mV29yaywgbGFuZXMpO1xuXG4gICAgICBpZiAoaGFzQ2F1Z2h0RXJyb3IoKSkge1xuICAgICAgICB2YXIgcmVwbGF5RXJyb3IgPSBjbGVhckNhdWdodEVycm9yKCk7IC8vIGBpbnZva2VHdWFyZGVkQ2FsbGJhY2tgIHNvbWV0aW1lcyBzZXRzIGFuIGV4cGFuZG8gYF9zdXBwcmVzc0xvZ2dpbmdgLlxuICAgICAgICAvLyBSZXRocm93IHRoaXMgZXJyb3IgaW5zdGVhZCBvZiB0aGUgb3JpZ2luYWwgb25lLlxuXG4gICAgICAgIHRocm93IHJlcGxheUVycm9yO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gVGhpcyBicmFuY2ggaXMgcmVhY2hhYmxlIGlmIHRoZSByZW5kZXIgcGhhc2UgaXMgaW1wdXJlLlxuICAgICAgICB0aHJvdyBvcmlnaW5hbEVycm9yO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbn1cblxudmFyIGRpZFdhcm5BYm91dFVwZGF0ZUluUmVuZGVyID0gZmFsc2U7XG52YXIgZGlkV2FybkFib3V0VXBkYXRlSW5SZW5kZXJGb3JBbm90aGVyQ29tcG9uZW50O1xuXG57XG4gIGRpZFdhcm5BYm91dFVwZGF0ZUluUmVuZGVyRm9yQW5vdGhlckNvbXBvbmVudCA9IG5ldyBTZXQoKTtcbn1cblxuZnVuY3Rpb24gd2FybkFib3V0UmVuZGVyUGhhc2VVcGRhdGVzSW5ERVYoZmliZXIpIHtcbiAge1xuICAgIGlmIChpc1JlbmRlcmluZyAmJiAoZXhlY3V0aW9uQ29udGV4dCAmIFJlbmRlckNvbnRleHQpICE9PSBOb0NvbnRleHQgJiYgIWdldElzVXBkYXRpbmdPcGFxdWVWYWx1ZUluUmVuZGVyUGhhc2VJbkRFVigpKSB7XG4gICAgICBzd2l0Y2ggKGZpYmVyLnRhZykge1xuICAgICAgICBjYXNlIEZ1bmN0aW9uQ29tcG9uZW50OlxuICAgICAgICBjYXNlIEZvcndhcmRSZWY6XG4gICAgICAgIGNhc2UgU2ltcGxlTWVtb0NvbXBvbmVudDpcbiAgICAgICAgICB7XG4gICAgICAgICAgICB2YXIgcmVuZGVyaW5nQ29tcG9uZW50TmFtZSA9IHdvcmtJblByb2dyZXNzICYmIGdldENvbXBvbmVudE5hbWUod29ya0luUHJvZ3Jlc3MudHlwZSkgfHwgJ1Vua25vd24nOyAvLyBEZWR1cGUgYnkgdGhlIHJlbmRlcmluZyBjb21wb25lbnQgYmVjYXVzZSBpdCdzIHRoZSBvbmUgdGhhdCBuZWVkcyB0byBiZSBmaXhlZC5cblxuICAgICAgICAgICAgdmFyIGRlZHVwZUtleSA9IHJlbmRlcmluZ0NvbXBvbmVudE5hbWU7XG5cbiAgICAgICAgICAgIGlmICghZGlkV2FybkFib3V0VXBkYXRlSW5SZW5kZXJGb3JBbm90aGVyQ29tcG9uZW50LmhhcyhkZWR1cGVLZXkpKSB7XG4gICAgICAgICAgICAgIGRpZFdhcm5BYm91dFVwZGF0ZUluUmVuZGVyRm9yQW5vdGhlckNvbXBvbmVudC5hZGQoZGVkdXBlS2V5KTtcbiAgICAgICAgICAgICAgdmFyIHNldFN0YXRlQ29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWUoZmliZXIudHlwZSkgfHwgJ1Vua25vd24nO1xuXG4gICAgICAgICAgICAgIGVycm9yKCdDYW5ub3QgdXBkYXRlIGEgY29tcG9uZW50IChgJXNgKSB3aGlsZSByZW5kZXJpbmcgYSAnICsgJ2RpZmZlcmVudCBjb21wb25lbnQgKGAlc2ApLiBUbyBsb2NhdGUgdGhlIGJhZCBzZXRTdGF0ZSgpIGNhbGwgaW5zaWRlIGAlc2AsICcgKyAnZm9sbG93IHRoZSBzdGFjayB0cmFjZSBhcyBkZXNjcmliZWQgaW4gaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3NldHN0YXRlLWluLXJlbmRlcicsIHNldFN0YXRlQ29tcG9uZW50TmFtZSwgcmVuZGVyaW5nQ29tcG9uZW50TmFtZSwgcmVuZGVyaW5nQ29tcG9uZW50TmFtZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlIENsYXNzQ29tcG9uZW50OlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlmICghZGlkV2FybkFib3V0VXBkYXRlSW5SZW5kZXIpIHtcbiAgICAgICAgICAgICAgZXJyb3IoJ0Nhbm5vdCB1cGRhdGUgZHVyaW5nIGFuIGV4aXN0aW5nIHN0YXRlIHRyYW5zaXRpb24gKHN1Y2ggYXMgJyArICd3aXRoaW4gYHJlbmRlcmApLiBSZW5kZXIgbWV0aG9kcyBzaG91bGQgYmUgYSBwdXJlICcgKyAnZnVuY3Rpb24gb2YgcHJvcHMgYW5kIHN0YXRlLicpO1xuXG4gICAgICAgICAgICAgIGRpZFdhcm5BYm91dFVwZGF0ZUluUmVuZGVyID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufSAvLyBhICdzaGFyZWQnIHZhcmlhYmxlIHRoYXQgY2hhbmdlcyB3aGVuIGFjdCgpIG9wZW5zL2Nsb3NlcyBpbiB0ZXN0cy5cblxuXG52YXIgSXNUaGlzUmVuZGVyZXJBY3RpbmcgPSB7XG4gIGN1cnJlbnQ6IGZhbHNlXG59O1xuZnVuY3Rpb24gd2FybklmTm90U2NvcGVkV2l0aE1hdGNoaW5nQWN0KGZpYmVyKSB7XG4gIHtcbiAgICBpZiAoIElzU29tZVJlbmRlcmVyQWN0aW5nLmN1cnJlbnQgPT09IHRydWUgJiYgSXNUaGlzUmVuZGVyZXJBY3RpbmcuY3VycmVudCAhPT0gdHJ1ZSkge1xuICAgICAgdmFyIHByZXZpb3VzRmliZXIgPSBjdXJyZW50O1xuXG4gICAgICB0cnkge1xuICAgICAgICBzZXRDdXJyZW50RmliZXIoZmliZXIpO1xuXG4gICAgICAgIGVycm9yKFwiSXQgbG9va3MgbGlrZSB5b3UncmUgdXNpbmcgdGhlIHdyb25nIGFjdCgpIGFyb3VuZCB5b3VyIHRlc3QgaW50ZXJhY3Rpb25zLlxcblwiICsgJ0JlIHN1cmUgdG8gdXNlIHRoZSBtYXRjaGluZyB2ZXJzaW9uIG9mIGFjdCgpIGNvcnJlc3BvbmRpbmcgdG8geW91ciByZW5kZXJlcjpcXG5cXG4nICsgJy8vIGZvciByZWFjdC1kb206XFxuJyArIC8vIEJyZWFrIHVwIGltcG9ydHMgdG8gYXZvaWQgYWNjaWRlbnRhbGx5IHBhcnNpbmcgdGhlbSBhcyBkZXBlbmRlbmNpZXMuXG4gICAgICAgICdpbXBvcnQge2FjdH0gZnInICsgXCJvbSAncmVhY3QtZG9tL3Rlc3QtdXRpbHMnO1xcblwiICsgJy8vIC4uLlxcbicgKyAnYWN0KCgpID0+IC4uLik7XFxuXFxuJyArICcvLyBmb3IgcmVhY3QtdGVzdC1yZW5kZXJlcjpcXG4nICsgLy8gQnJlYWsgdXAgaW1wb3J0cyB0byBhdm9pZCBhY2NpZGVudGFsbHkgcGFyc2luZyB0aGVtIGFzIGRlcGVuZGVuY2llcy5cbiAgICAgICAgJ2ltcG9ydCBUZXN0UmVuZGVyZXIgZnInICsgXCJvbSByZWFjdC10ZXN0LXJlbmRlcmVyJztcXG5cIiArICdjb25zdCB7YWN0fSA9IFRlc3RSZW5kZXJlcjtcXG4nICsgJy8vIC4uLlxcbicgKyAnYWN0KCgpID0+IC4uLik7Jyk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBpZiAocHJldmlvdXNGaWJlcikge1xuICAgICAgICAgIHNldEN1cnJlbnRGaWJlcihmaWJlcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzZXRDdXJyZW50RmliZXIoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gd2FybklmTm90Q3VycmVudGx5QWN0aW5nRWZmZWN0c0luREVWKGZpYmVyKSB7XG4gIHtcbiAgICBpZiAoIChmaWJlci5tb2RlICYgU3RyaWN0TW9kZSkgIT09IE5vTW9kZSAmJiBJc1NvbWVSZW5kZXJlckFjdGluZy5jdXJyZW50ID09PSBmYWxzZSAmJiBJc1RoaXNSZW5kZXJlckFjdGluZy5jdXJyZW50ID09PSBmYWxzZSkge1xuICAgICAgZXJyb3IoJ0FuIHVwZGF0ZSB0byAlcyByYW4gYW4gZWZmZWN0LCBidXQgd2FzIG5vdCB3cmFwcGVkIGluIGFjdCguLi4pLlxcblxcbicgKyAnV2hlbiB0ZXN0aW5nLCBjb2RlIHRoYXQgY2F1c2VzIFJlYWN0IHN0YXRlIHVwZGF0ZXMgc2hvdWxkIGJlICcgKyAnd3JhcHBlZCBpbnRvIGFjdCguLi4pOlxcblxcbicgKyAnYWN0KCgpID0+IHtcXG4nICsgJyAgLyogZmlyZSBldmVudHMgdGhhdCB1cGRhdGUgc3RhdGUgKi9cXG4nICsgJ30pO1xcbicgKyAnLyogYXNzZXJ0IG9uIHRoZSBvdXRwdXQgKi9cXG5cXG4nICsgXCJUaGlzIGVuc3VyZXMgdGhhdCB5b3UncmUgdGVzdGluZyB0aGUgYmVoYXZpb3IgdGhlIHVzZXIgd291bGQgc2VlIFwiICsgJ2luIHRoZSBicm93c2VyLicgKyAnIExlYXJuIG1vcmUgYXQgaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3dyYXAtdGVzdHMtd2l0aC1hY3QnLCBnZXRDb21wb25lbnROYW1lKGZpYmVyLnR5cGUpKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gd2FybklmTm90Q3VycmVudGx5QWN0aW5nVXBkYXRlc0luREVWKGZpYmVyKSB7XG4gIHtcbiAgICBpZiAoIGV4ZWN1dGlvbkNvbnRleHQgPT09IE5vQ29udGV4dCAmJiBJc1NvbWVSZW5kZXJlckFjdGluZy5jdXJyZW50ID09PSBmYWxzZSAmJiBJc1RoaXNSZW5kZXJlckFjdGluZy5jdXJyZW50ID09PSBmYWxzZSkge1xuICAgICAgdmFyIHByZXZpb3VzRmliZXIgPSBjdXJyZW50O1xuXG4gICAgICB0cnkge1xuICAgICAgICBzZXRDdXJyZW50RmliZXIoZmliZXIpO1xuXG4gICAgICAgIGVycm9yKCdBbiB1cGRhdGUgdG8gJXMgaW5zaWRlIGEgdGVzdCB3YXMgbm90IHdyYXBwZWQgaW4gYWN0KC4uLikuXFxuXFxuJyArICdXaGVuIHRlc3RpbmcsIGNvZGUgdGhhdCBjYXVzZXMgUmVhY3Qgc3RhdGUgdXBkYXRlcyBzaG91bGQgYmUgJyArICd3cmFwcGVkIGludG8gYWN0KC4uLik6XFxuXFxuJyArICdhY3QoKCkgPT4ge1xcbicgKyAnICAvKiBmaXJlIGV2ZW50cyB0aGF0IHVwZGF0ZSBzdGF0ZSAqL1xcbicgKyAnfSk7XFxuJyArICcvKiBhc3NlcnQgb24gdGhlIG91dHB1dCAqL1xcblxcbicgKyBcIlRoaXMgZW5zdXJlcyB0aGF0IHlvdSdyZSB0ZXN0aW5nIHRoZSBiZWhhdmlvciB0aGUgdXNlciB3b3VsZCBzZWUgXCIgKyAnaW4gdGhlIGJyb3dzZXIuJyArICcgTGVhcm4gbW9yZSBhdCBodHRwczovL3JlYWN0anMub3JnL2xpbmsvd3JhcC10ZXN0cy13aXRoLWFjdCcsIGdldENvbXBvbmVudE5hbWUoZmliZXIudHlwZSkpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgaWYgKHByZXZpb3VzRmliZXIpIHtcbiAgICAgICAgICBzZXRDdXJyZW50RmliZXIoZmliZXIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc2V0Q3VycmVudEZpYmVyKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxudmFyIHdhcm5JZk5vdEN1cnJlbnRseUFjdGluZ1VwZGF0ZXNJbkRldiA9IHdhcm5JZk5vdEN1cnJlbnRseUFjdGluZ1VwZGF0ZXNJbkRFVjsgLy8gSW4gdGVzdHMsIHdlIHdhbnQgdG8gZW5mb3JjZSBhIG1vY2tlZCBzY2hlZHVsZXIuXG5cbnZhciBkaWRXYXJuQWJvdXRVbm1vY2tlZFNjaGVkdWxlciA9IGZhbHNlOyAvLyBUT0RPIEJlZm9yZSB3ZSByZWxlYXNlIGNvbmN1cnJlbnQgbW9kZSwgcmV2aXNpdCB0aGlzIGFuZCBkZWNpZGUgd2hldGhlciBhIG1vY2tlZFxuLy8gc2NoZWR1bGVyIGlzIHRoZSBhY3R1YWwgcmVjb21tZW5kYXRpb24uIFRoZSBhbHRlcm5hdGl2ZSBjb3VsZCBiZSBhIHRlc3RpbmcgYnVpbGQsXG4vLyBhIG5ldyBsaWIsIG9yIHdoYXRldmVyOyB3ZSBkdW5ubyBqdXN0IHlldC4gVGhpcyBtZXNzYWdlIGlzIGZvciBlYXJseSBhZG9wdGVyc1xuLy8gdG8gZ2V0IHRoZWlyIHRlc3RzIHJpZ2h0LlxuXG5mdW5jdGlvbiB3YXJuSWZVbm1vY2tlZFNjaGVkdWxlcihmaWJlcikge1xuICB7XG4gICAgaWYgKGRpZFdhcm5BYm91dFVubW9ja2VkU2NoZWR1bGVyID09PSBmYWxzZSAmJiBTY2hlZHVsZXIudW5zdGFibGVfZmx1c2hBbGxXaXRob3V0QXNzZXJ0aW5nID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmIChmaWJlci5tb2RlICYgQmxvY2tpbmdNb2RlIHx8IGZpYmVyLm1vZGUgJiBDb25jdXJyZW50TW9kZSkge1xuICAgICAgICBkaWRXYXJuQWJvdXRVbm1vY2tlZFNjaGVkdWxlciA9IHRydWU7XG5cbiAgICAgICAgZXJyb3IoJ0luIENvbmN1cnJlbnQgb3IgU3luYyBtb2RlcywgdGhlIFwic2NoZWR1bGVyXCIgbW9kdWxlIG5lZWRzIHRvIGJlIG1vY2tlZCAnICsgJ3RvIGd1YXJhbnRlZSBjb25zaXN0ZW50IGJlaGF2aW91ciBhY3Jvc3MgdGVzdHMgYW5kIGJyb3dzZXJzLiAnICsgJ0ZvciBleGFtcGxlLCB3aXRoIGplc3Q6IFxcbicgKyAvLyBCcmVhayB1cCByZXF1aXJlcyB0byBhdm9pZCBhY2NpZGVudGFsbHkgcGFyc2luZyB0aGVtIGFzIGRlcGVuZGVuY2llcy5cbiAgICAgICAgXCJqZXN0Lm1vY2soJ3NjaGVkdWxlcicsICgpID0+IHJlcXVpcmVcIiArIFwiKCdzY2hlZHVsZXIvdW5zdGFibGVfbW9jaycpKTtcXG5cXG5cIiArICdGb3IgbW9yZSBpbmZvLCB2aXNpdCBodHRwczovL3JlYWN0anMub3JnL2xpbmsvbW9jay1zY2hlZHVsZXInKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY29tcHV0ZVRocmVhZElEKHJvb3QsIGxhbmUpIHtcbiAgLy8gSW50ZXJhY3Rpb24gdGhyZWFkcyBhcmUgdW5pcXVlIHBlciByb290IGFuZCBleHBpcmF0aW9uIHRpbWUuXG4gIC8vIE5PVEU6IEludGVudGlvbmFsbHkgdW5zb3VuZCBjYXN0LiBBbGwgdGhhdCBtYXR0ZXJzIGlzIHRoYXQgaXQncyBhIG51bWJlclxuICAvLyBhbmQgaXQgcmVwcmVzZW50cyBhIGJhdGNoIG9mIHdvcmsuIENvdWxkIG1ha2UgYSBoZWxwZXIgZnVuY3Rpb24gaW5zdGVhZCxcbiAgLy8gYnV0IG1laCB0aGlzIGlzIGZpbmUgZm9yIG5vdy5cbiAgcmV0dXJuIGxhbmUgKiAxMDAwICsgcm9vdC5pbnRlcmFjdGlvblRocmVhZElEO1xufVxuXG5mdW5jdGlvbiBtYXJrU3Bhd25lZFdvcmsobGFuZSkge1xuXG4gIGlmIChzcGF3bmVkV29ya0R1cmluZ1JlbmRlciA9PT0gbnVsbCkge1xuICAgIHNwYXduZWRXb3JrRHVyaW5nUmVuZGVyID0gW2xhbmVdO1xuICB9IGVsc2Uge1xuICAgIHNwYXduZWRXb3JrRHVyaW5nUmVuZGVyLnB1c2gobGFuZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gc2NoZWR1bGVJbnRlcmFjdGlvbnMocm9vdCwgbGFuZSwgaW50ZXJhY3Rpb25zKSB7XG5cbiAgaWYgKGludGVyYWN0aW9ucy5zaXplID4gMCkge1xuICAgIHZhciBwZW5kaW5nSW50ZXJhY3Rpb25NYXAgPSByb290LnBlbmRpbmdJbnRlcmFjdGlvbk1hcDtcbiAgICB2YXIgcGVuZGluZ0ludGVyYWN0aW9ucyA9IHBlbmRpbmdJbnRlcmFjdGlvbk1hcC5nZXQobGFuZSk7XG5cbiAgICBpZiAocGVuZGluZ0ludGVyYWN0aW9ucyAhPSBudWxsKSB7XG4gICAgICBpbnRlcmFjdGlvbnMuZm9yRWFjaChmdW5jdGlvbiAoaW50ZXJhY3Rpb24pIHtcbiAgICAgICAgaWYgKCFwZW5kaW5nSW50ZXJhY3Rpb25zLmhhcyhpbnRlcmFjdGlvbikpIHtcbiAgICAgICAgICAvLyBVcGRhdGUgdGhlIHBlbmRpbmcgYXN5bmMgd29yayBjb3VudCBmb3IgcHJldmlvdXNseSB1bnNjaGVkdWxlZCBpbnRlcmFjdGlvbi5cbiAgICAgICAgICBpbnRlcmFjdGlvbi5fX2NvdW50Kys7XG4gICAgICAgIH1cblxuICAgICAgICBwZW5kaW5nSW50ZXJhY3Rpb25zLmFkZChpbnRlcmFjdGlvbik7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcGVuZGluZ0ludGVyYWN0aW9uTWFwLnNldChsYW5lLCBuZXcgU2V0KGludGVyYWN0aW9ucykpOyAvLyBVcGRhdGUgdGhlIHBlbmRpbmcgYXN5bmMgd29yayBjb3VudCBmb3IgdGhlIGN1cnJlbnQgaW50ZXJhY3Rpb25zLlxuXG4gICAgICBpbnRlcmFjdGlvbnMuZm9yRWFjaChmdW5jdGlvbiAoaW50ZXJhY3Rpb24pIHtcbiAgICAgICAgaW50ZXJhY3Rpb24uX19jb3VudCsrO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgdmFyIHN1YnNjcmliZXIgPSB0cmFjaW5nLl9fc3Vic2NyaWJlclJlZi5jdXJyZW50O1xuXG4gICAgaWYgKHN1YnNjcmliZXIgIT09IG51bGwpIHtcbiAgICAgIHZhciB0aHJlYWRJRCA9IGNvbXB1dGVUaHJlYWRJRChyb290LCBsYW5lKTtcbiAgICAgIHN1YnNjcmliZXIub25Xb3JrU2NoZWR1bGVkKGludGVyYWN0aW9ucywgdGhyZWFkSUQpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBzY2hlZHVsZVBlbmRpbmdJbnRlcmFjdGlvbnMocm9vdCwgbGFuZSkge1xuXG4gIHNjaGVkdWxlSW50ZXJhY3Rpb25zKHJvb3QsIGxhbmUsIHRyYWNpbmcuX19pbnRlcmFjdGlvbnNSZWYuY3VycmVudCk7XG59XG5cbmZ1bmN0aW9uIHN0YXJ0V29ya09uUGVuZGluZ0ludGVyYWN0aW9ucyhyb290LCBsYW5lcykge1xuICAvLyB3ZSBjYW4gYWNjdXJhdGVseSBhdHRyaWJ1dGUgdGltZSBzcGVudCB3b3JraW5nIG9uIGl0LCBBbmQgc28gdGhhdCBjYXNjYWRpbmdcbiAgLy8gd29yayB0cmlnZ2VyZWQgZHVyaW5nIHRoZSByZW5kZXIgcGhhc2Ugd2lsbCBiZSBhc3NvY2lhdGVkIHdpdGggaXQuXG5cblxuICB2YXIgaW50ZXJhY3Rpb25zID0gbmV3IFNldCgpO1xuICByb290LnBlbmRpbmdJbnRlcmFjdGlvbk1hcC5mb3JFYWNoKGZ1bmN0aW9uIChzY2hlZHVsZWRJbnRlcmFjdGlvbnMsIHNjaGVkdWxlZExhbmUpIHtcbiAgICBpZiAoaW5jbHVkZXNTb21lTGFuZShsYW5lcywgc2NoZWR1bGVkTGFuZSkpIHtcbiAgICAgIHNjaGVkdWxlZEludGVyYWN0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChpbnRlcmFjdGlvbikge1xuICAgICAgICByZXR1cm4gaW50ZXJhY3Rpb25zLmFkZChpbnRlcmFjdGlvbik7XG4gICAgICB9KTtcbiAgICB9XG4gIH0pOyAvLyBTdG9yZSB0aGUgY3VycmVudCBzZXQgb2YgaW50ZXJhY3Rpb25zIG9uIHRoZSBGaWJlclJvb3QgZm9yIGEgZmV3IHJlYXNvbnM6XG4gIC8vIFdlIGNhbiByZS11c2UgaXQgaW4gaG90IGZ1bmN0aW9ucyBsaWtlIHBlcmZvcm1Db25jdXJyZW50V29ya09uUm9vdCgpXG4gIC8vIHdpdGhvdXQgaGF2aW5nIHRvIHJlY2FsY3VsYXRlIGl0LiBXZSB3aWxsIGFsc28gdXNlIGl0IGluIGNvbW1pdFdvcmsoKSB0b1xuICAvLyBwYXNzIHRvIGFueSBQcm9maWxlciBvblJlbmRlcigpIGhvb2tzLiBUaGlzIGFsc28gcHJvdmlkZXMgRGV2VG9vbHMgd2l0aCBhXG4gIC8vIHdheSB0byBhY2Nlc3MgaXQgd2hlbiB0aGUgb25Db21taXRSb290KCkgaG9vayBpcyBjYWxsZWQuXG5cbiAgcm9vdC5tZW1vaXplZEludGVyYWN0aW9ucyA9IGludGVyYWN0aW9ucztcblxuICBpZiAoaW50ZXJhY3Rpb25zLnNpemUgPiAwKSB7XG4gICAgdmFyIHN1YnNjcmliZXIgPSB0cmFjaW5nLl9fc3Vic2NyaWJlclJlZi5jdXJyZW50O1xuXG4gICAgaWYgKHN1YnNjcmliZXIgIT09IG51bGwpIHtcbiAgICAgIHZhciB0aHJlYWRJRCA9IGNvbXB1dGVUaHJlYWRJRChyb290LCBsYW5lcyk7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHN1YnNjcmliZXIub25Xb3JrU3RhcnRlZChpbnRlcmFjdGlvbnMsIHRocmVhZElEKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIC8vIElmIHRoZSBzdWJzY3JpYmVyIHRocm93cywgcmV0aHJvdyBpdCBpbiBhIHNlcGFyYXRlIHRhc2tcbiAgICAgICAgc2NoZWR1bGVDYWxsYmFjayhJbW1lZGlhdGVQcmlvcml0eSQxLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBmaW5pc2hQZW5kaW5nSW50ZXJhY3Rpb25zKHJvb3QsIGNvbW1pdHRlZExhbmVzKSB7XG5cbiAgdmFyIHJlbWFpbmluZ0xhbmVzQWZ0ZXJDb21taXQgPSByb290LnBlbmRpbmdMYW5lcztcbiAgdmFyIHN1YnNjcmliZXI7XG5cbiAgdHJ5IHtcbiAgICBzdWJzY3JpYmVyID0gdHJhY2luZy5fX3N1YnNjcmliZXJSZWYuY3VycmVudDtcblxuICAgIGlmIChzdWJzY3JpYmVyICE9PSBudWxsICYmIHJvb3QubWVtb2l6ZWRJbnRlcmFjdGlvbnMuc2l6ZSA+IDApIHtcbiAgICAgIC8vIEZJWE1FOiBNb3JlIHRoYW4gb25lIGxhbmUgY2FuIGZpbmlzaCBpbiBhIHNpbmdsZSBjb21taXQuXG4gICAgICB2YXIgdGhyZWFkSUQgPSBjb21wdXRlVGhyZWFkSUQocm9vdCwgY29tbWl0dGVkTGFuZXMpO1xuICAgICAgc3Vic2NyaWJlci5vbldvcmtTdG9wcGVkKHJvb3QubWVtb2l6ZWRJbnRlcmFjdGlvbnMsIHRocmVhZElEKTtcbiAgICB9XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgLy8gSWYgdGhlIHN1YnNjcmliZXIgdGhyb3dzLCByZXRocm93IGl0IGluIGEgc2VwYXJhdGUgdGFza1xuICAgIHNjaGVkdWxlQ2FsbGJhY2soSW1tZWRpYXRlUHJpb3JpdHkkMSwgZnVuY3Rpb24gKCkge1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfSk7XG4gIH0gZmluYWxseSB7XG4gICAgLy8gQ2xlYXIgY29tcGxldGVkIGludGVyYWN0aW9ucyBmcm9tIHRoZSBwZW5kaW5nIE1hcC5cbiAgICAvLyBVbmxlc3MgdGhlIHJlbmRlciB3YXMgc3VzcGVuZGVkIG9yIGNhc2NhZGluZyB3b3JrIHdhcyBzY2hlZHVsZWQsXG4gICAgLy8gSW4gd2hpY2ggY2FzZeKAkyBsZWF2ZSBwZW5kaW5nIGludGVyYWN0aW9ucyB1bnRpbCB0aGUgc3Vic2VxdWVudCByZW5kZXIuXG4gICAgdmFyIHBlbmRpbmdJbnRlcmFjdGlvbk1hcCA9IHJvb3QucGVuZGluZ0ludGVyYWN0aW9uTWFwO1xuICAgIHBlbmRpbmdJbnRlcmFjdGlvbk1hcC5mb3JFYWNoKGZ1bmN0aW9uIChzY2hlZHVsZWRJbnRlcmFjdGlvbnMsIGxhbmUpIHtcbiAgICAgIC8vIE9ubHkgZGVjcmVtZW50IHRoZSBwZW5kaW5nIGludGVyYWN0aW9uIGNvdW50IGlmIHdlJ3JlIGRvbmUuXG4gICAgICAvLyBJZiB0aGVyZSdzIHN0aWxsIHdvcmsgYXQgdGhlIGN1cnJlbnQgcHJpb3JpdHksXG4gICAgICAvLyBUaGF0IGluZGljYXRlcyB0aGF0IHdlIGFyZSB3YWl0aW5nIGZvciBzdXNwZW5zZSBkYXRhLlxuICAgICAgaWYgKCFpbmNsdWRlc1NvbWVMYW5lKHJlbWFpbmluZ0xhbmVzQWZ0ZXJDb21taXQsIGxhbmUpKSB7XG4gICAgICAgIHBlbmRpbmdJbnRlcmFjdGlvbk1hcC5kZWxldGUobGFuZSk7XG4gICAgICAgIHNjaGVkdWxlZEludGVyYWN0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChpbnRlcmFjdGlvbikge1xuICAgICAgICAgIGludGVyYWN0aW9uLl9fY291bnQtLTtcblxuICAgICAgICAgIGlmIChzdWJzY3JpYmVyICE9PSBudWxsICYmIGludGVyYWN0aW9uLl9fY291bnQgPT09IDApIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHN1YnNjcmliZXIub25JbnRlcmFjdGlvblNjaGVkdWxlZFdvcmtDb21wbGV0ZWQoaW50ZXJhY3Rpb24pO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgLy8gSWYgdGhlIHN1YnNjcmliZXIgdGhyb3dzLCByZXRocm93IGl0IGluIGEgc2VwYXJhdGUgdGFza1xuICAgICAgICAgICAgICBzY2hlZHVsZUNhbGxiYWNrKEltbWVkaWF0ZVByaW9yaXR5JDEsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufSAvLyBgYWN0YCB0ZXN0aW5nIEFQSVxuXG5mdW5jdGlvbiBzaG91bGRGb3JjZUZsdXNoRmFsbGJhY2tzSW5ERVYoKSB7XG4gIC8vIE5ldmVyIGZvcmNlIGZsdXNoIGluIHByb2R1Y3Rpb24uIFRoaXMgZnVuY3Rpb24gc2hvdWxkIGdldCBzdHJpcHBlZCBvdXQuXG4gIHJldHVybiAgYWN0aW5nVXBkYXRlc1Njb3BlRGVwdGggPiAwO1xufVxuLy8gc28gd2UgY2FuIHRlbGwgaWYgYW55IGFzeW5jIGFjdCgpIGNhbGxzIHRyeSB0byBydW4gaW4gcGFyYWxsZWwuXG5cblxudmFyIGFjdGluZ1VwZGF0ZXNTY29wZURlcHRoID0gMDtcblxuZnVuY3Rpb24gZGV0YWNoRmliZXJBZnRlckVmZmVjdHMoZmliZXIpIHtcbiAgZmliZXIuc2libGluZyA9IG51bGw7XG4gIGZpYmVyLnN0YXRlTm9kZSA9IG51bGw7XG59XG5cbnZhciByZXNvbHZlRmFtaWx5ID0gbnVsbDsgLy8gJEZsb3dGaXhNZSBGbG93IGdldHMgY29uZnVzZWQgYnkgYSBXZWFrU2V0IGZlYXR1cmUgY2hlY2sgYmVsb3cuXG5cbnZhciBmYWlsZWRCb3VuZGFyaWVzID0gbnVsbDtcbnZhciBzZXRSZWZyZXNoSGFuZGxlciA9IGZ1bmN0aW9uIChoYW5kbGVyKSB7XG4gIHtcbiAgICByZXNvbHZlRmFtaWx5ID0gaGFuZGxlcjtcbiAgfVxufTtcbmZ1bmN0aW9uIHJlc29sdmVGdW5jdGlvbkZvckhvdFJlbG9hZGluZyh0eXBlKSB7XG4gIHtcbiAgICBpZiAocmVzb2x2ZUZhbWlseSA9PT0gbnVsbCkge1xuICAgICAgLy8gSG90IHJlbG9hZGluZyBpcyBkaXNhYmxlZC5cbiAgICAgIHJldHVybiB0eXBlO1xuICAgIH1cblxuICAgIHZhciBmYW1pbHkgPSByZXNvbHZlRmFtaWx5KHR5cGUpO1xuXG4gICAgaWYgKGZhbWlseSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gdHlwZTtcbiAgICB9IC8vIFVzZSB0aGUgbGF0ZXN0IGtub3duIGltcGxlbWVudGF0aW9uLlxuXG5cbiAgICByZXR1cm4gZmFtaWx5LmN1cnJlbnQ7XG4gIH1cbn1cbmZ1bmN0aW9uIHJlc29sdmVDbGFzc0ZvckhvdFJlbG9hZGluZyh0eXBlKSB7XG4gIC8vIE5vIGltcGxlbWVudGF0aW9uIGRpZmZlcmVuY2VzLlxuICByZXR1cm4gcmVzb2x2ZUZ1bmN0aW9uRm9ySG90UmVsb2FkaW5nKHR5cGUpO1xufVxuZnVuY3Rpb24gcmVzb2x2ZUZvcndhcmRSZWZGb3JIb3RSZWxvYWRpbmcodHlwZSkge1xuICB7XG4gICAgaWYgKHJlc29sdmVGYW1pbHkgPT09IG51bGwpIHtcbiAgICAgIC8vIEhvdCByZWxvYWRpbmcgaXMgZGlzYWJsZWQuXG4gICAgICByZXR1cm4gdHlwZTtcbiAgICB9XG5cbiAgICB2YXIgZmFtaWx5ID0gcmVzb2x2ZUZhbWlseSh0eXBlKTtcblxuICAgIGlmIChmYW1pbHkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gQ2hlY2sgaWYgd2UncmUgZGVhbGluZyB3aXRoIGEgcmVhbCBmb3J3YXJkUmVmLiBEb24ndCB3YW50IHRvIGNyYXNoIGVhcmx5LlxuICAgICAgaWYgKHR5cGUgIT09IG51bGwgJiYgdHlwZSAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiB0eXBlLnJlbmRlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAvLyBGb3J3YXJkUmVmIGlzIHNwZWNpYWwgYmVjYXVzZSBpdHMgcmVzb2x2ZWQgLnR5cGUgaXMgYW4gb2JqZWN0LFxuICAgICAgICAvLyBidXQgaXQncyBwb3NzaWJsZSB0aGF0IHdlIG9ubHkgaGF2ZSBpdHMgaW5uZXIgcmVuZGVyIGZ1bmN0aW9uIGluIHRoZSBtYXAuXG4gICAgICAgIC8vIElmIHRoYXQgaW5uZXIgcmVuZGVyIGZ1bmN0aW9uIGlzIGRpZmZlcmVudCwgd2UnbGwgYnVpbGQgYSBuZXcgZm9yd2FyZFJlZiB0eXBlLlxuICAgICAgICB2YXIgY3VycmVudFJlbmRlciA9IHJlc29sdmVGdW5jdGlvbkZvckhvdFJlbG9hZGluZyh0eXBlLnJlbmRlcik7XG5cbiAgICAgICAgaWYgKHR5cGUucmVuZGVyICE9PSBjdXJyZW50UmVuZGVyKSB7XG4gICAgICAgICAgdmFyIHN5bnRoZXRpY1R5cGUgPSB7XG4gICAgICAgICAgICAkJHR5cGVvZjogUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSxcbiAgICAgICAgICAgIHJlbmRlcjogY3VycmVudFJlbmRlclxuICAgICAgICAgIH07XG5cbiAgICAgICAgICBpZiAodHlwZS5kaXNwbGF5TmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBzeW50aGV0aWNUeXBlLmRpc3BsYXlOYW1lID0gdHlwZS5kaXNwbGF5TmFtZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gc3ludGhldGljVHlwZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdHlwZTtcbiAgICB9IC8vIFVzZSB0aGUgbGF0ZXN0IGtub3duIGltcGxlbWVudGF0aW9uLlxuXG5cbiAgICByZXR1cm4gZmFtaWx5LmN1cnJlbnQ7XG4gIH1cbn1cbmZ1bmN0aW9uIGlzQ29tcGF0aWJsZUZhbWlseUZvckhvdFJlbG9hZGluZyhmaWJlciwgZWxlbWVudCkge1xuICB7XG4gICAgaWYgKHJlc29sdmVGYW1pbHkgPT09IG51bGwpIHtcbiAgICAgIC8vIEhvdCByZWxvYWRpbmcgaXMgZGlzYWJsZWQuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIHByZXZUeXBlID0gZmliZXIuZWxlbWVudFR5cGU7XG4gICAgdmFyIG5leHRUeXBlID0gZWxlbWVudC50eXBlOyAvLyBJZiB3ZSBnb3QgaGVyZSwgd2Uga25vdyB0eXBlcyBhcmVuJ3QgPT09IGVxdWFsLlxuXG4gICAgdmFyIG5lZWRzQ29tcGFyZUZhbWlsaWVzID0gZmFsc2U7XG4gICAgdmFyICQkdHlwZW9mTmV4dFR5cGUgPSB0eXBlb2YgbmV4dFR5cGUgPT09ICdvYmplY3QnICYmIG5leHRUeXBlICE9PSBudWxsID8gbmV4dFR5cGUuJCR0eXBlb2YgOiBudWxsO1xuXG4gICAgc3dpdGNoIChmaWJlci50YWcpIHtcbiAgICAgIGNhc2UgQ2xhc3NDb21wb25lbnQ6XG4gICAgICAgIHtcbiAgICAgICAgICBpZiAodHlwZW9mIG5leHRUeXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBuZWVkc0NvbXBhcmVGYW1pbGllcyA9IHRydWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBGdW5jdGlvbkNvbXBvbmVudDpcbiAgICAgICAge1xuICAgICAgICAgIGlmICh0eXBlb2YgbmV4dFR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIG5lZWRzQ29tcGFyZUZhbWlsaWVzID0gdHJ1ZTtcbiAgICAgICAgICB9IGVsc2UgaWYgKCQkdHlwZW9mTmV4dFR5cGUgPT09IFJFQUNUX0xBWllfVFlQRSkge1xuICAgICAgICAgICAgLy8gV2UgZG9uJ3Qga25vdyB0aGUgaW5uZXIgdHlwZSB5ZXQuXG4gICAgICAgICAgICAvLyBXZSdyZSBnb2luZyB0byBhc3N1bWUgdGhhdCB0aGUgbGF6eSBpbm5lciB0eXBlIGlzIHN0YWJsZSxcbiAgICAgICAgICAgIC8vIGFuZCBzbyBpdCBpcyBzdWZmaWNpZW50IHRvIGF2b2lkIHJlY29uY2lsaW5nIGl0IGF3YXkuXG4gICAgICAgICAgICAvLyBXZSdyZSBub3QgZ29pbmcgdG8gdW53cmFwIG9yIGFjdHVhbGx5IHVzZSB0aGUgbmV3IGxhenkgdHlwZS5cbiAgICAgICAgICAgIG5lZWRzQ29tcGFyZUZhbWlsaWVzID0gdHJ1ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIEZvcndhcmRSZWY6XG4gICAgICAgIHtcbiAgICAgICAgICBpZiAoJCR0eXBlb2ZOZXh0VHlwZSA9PT0gUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSkge1xuICAgICAgICAgICAgbmVlZHNDb21wYXJlRmFtaWxpZXMgPSB0cnVlO1xuICAgICAgICAgIH0gZWxzZSBpZiAoJCR0eXBlb2ZOZXh0VHlwZSA9PT0gUkVBQ1RfTEFaWV9UWVBFKSB7XG4gICAgICAgICAgICBuZWVkc0NvbXBhcmVGYW1pbGllcyA9IHRydWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBNZW1vQ29tcG9uZW50OlxuICAgICAgY2FzZSBTaW1wbGVNZW1vQ29tcG9uZW50OlxuICAgICAgICB7XG4gICAgICAgICAgaWYgKCQkdHlwZW9mTmV4dFR5cGUgPT09IFJFQUNUX01FTU9fVFlQRSkge1xuICAgICAgICAgICAgLy8gVE9ETzogaWYgaXQgd2FzIGJ1dCBjYW4gbm8gbG9uZ2VyIGJlIHNpbXBsZSxcbiAgICAgICAgICAgIC8vIHdlIHNob3VsZG4ndCBzZXQgdGhpcy5cbiAgICAgICAgICAgIG5lZWRzQ29tcGFyZUZhbWlsaWVzID0gdHJ1ZTtcbiAgICAgICAgICB9IGVsc2UgaWYgKCQkdHlwZW9mTmV4dFR5cGUgPT09IFJFQUNUX0xBWllfVFlQRSkge1xuICAgICAgICAgICAgbmVlZHNDb21wYXJlRmFtaWxpZXMgPSB0cnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IC8vIENoZWNrIGlmIGJvdGggdHlwZXMgaGF2ZSBhIGZhbWlseSBhbmQgaXQncyB0aGUgc2FtZSBvbmUuXG5cblxuICAgIGlmIChuZWVkc0NvbXBhcmVGYW1pbGllcykge1xuICAgICAgLy8gTm90ZTogbWVtbygpIGFuZCBmb3J3YXJkUmVmKCkgd2UnbGwgY29tcGFyZSBvdXRlciByYXRoZXIgdGhhbiBpbm5lciB0eXBlLlxuICAgICAgLy8gVGhpcyBtZWFucyBib3RoIG9mIHRoZW0gbmVlZCB0byBiZSByZWdpc3RlcmVkIHRvIHByZXNlcnZlIHN0YXRlLlxuICAgICAgLy8gSWYgd2UgdW53cmFwcGVkIGFuZCBjb21wYXJlZCB0aGUgaW5uZXIgdHlwZXMgZm9yIHdyYXBwZXJzIGluc3RlYWQsXG4gICAgICAvLyB0aGVuIHdlIHdvdWxkIHJpc2sgZmFsc2VseSBzYXlpbmcgdHdvIHNlcGFyYXRlIG1lbW8oRm9vKVxuICAgICAgLy8gY2FsbHMgYXJlIGVxdWl2YWxlbnQgYmVjYXVzZSB0aGV5IHdyYXAgdGhlIHNhbWUgRm9vIGZ1bmN0aW9uLlxuICAgICAgdmFyIHByZXZGYW1pbHkgPSByZXNvbHZlRmFtaWx5KHByZXZUeXBlKTtcblxuICAgICAgaWYgKHByZXZGYW1pbHkgIT09IHVuZGVmaW5lZCAmJiBwcmV2RmFtaWx5ID09PSByZXNvbHZlRmFtaWx5KG5leHRUeXBlKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cbmZ1bmN0aW9uIG1hcmtGYWlsZWRFcnJvckJvdW5kYXJ5Rm9ySG90UmVsb2FkaW5nKGZpYmVyKSB7XG4gIHtcbiAgICBpZiAocmVzb2x2ZUZhbWlseSA9PT0gbnVsbCkge1xuICAgICAgLy8gSG90IHJlbG9hZGluZyBpcyBkaXNhYmxlZC5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIFdlYWtTZXQgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoZmFpbGVkQm91bmRhcmllcyA9PT0gbnVsbCkge1xuICAgICAgZmFpbGVkQm91bmRhcmllcyA9IG5ldyBXZWFrU2V0KCk7XG4gICAgfVxuXG4gICAgZmFpbGVkQm91bmRhcmllcy5hZGQoZmliZXIpO1xuICB9XG59XG52YXIgc2NoZWR1bGVSZWZyZXNoID0gZnVuY3Rpb24gKHJvb3QsIHVwZGF0ZSkge1xuICB7XG4gICAgaWYgKHJlc29sdmVGYW1pbHkgPT09IG51bGwpIHtcbiAgICAgIC8vIEhvdCByZWxvYWRpbmcgaXMgZGlzYWJsZWQuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHN0YWxlRmFtaWxpZXMgPSB1cGRhdGUuc3RhbGVGYW1pbGllcyxcbiAgICAgICAgdXBkYXRlZEZhbWlsaWVzID0gdXBkYXRlLnVwZGF0ZWRGYW1pbGllcztcbiAgICBmbHVzaFBhc3NpdmVFZmZlY3RzKCk7XG4gICAgZmx1c2hTeW5jKGZ1bmN0aW9uICgpIHtcbiAgICAgIHNjaGVkdWxlRmliZXJzV2l0aEZhbWlsaWVzUmVjdXJzaXZlbHkocm9vdC5jdXJyZW50LCB1cGRhdGVkRmFtaWxpZXMsIHN0YWxlRmFtaWxpZXMpO1xuICAgIH0pO1xuICB9XG59O1xudmFyIHNjaGVkdWxlUm9vdCA9IGZ1bmN0aW9uIChyb290LCBlbGVtZW50KSB7XG4gIHtcbiAgICBpZiAocm9vdC5jb250ZXh0ICE9PSBlbXB0eUNvbnRleHRPYmplY3QpIHtcbiAgICAgIC8vIFN1cGVyIGVkZ2UgY2FzZTogcm9vdCBoYXMgYSBsZWdhY3kgX3JlbmRlclN1YnRyZWUgY29udGV4dFxuICAgICAgLy8gYnV0IHdlIGRvbid0IGtub3cgdGhlIHBhcmVudENvbXBvbmVudCBzbyB3ZSBjYW4ndCBwYXNzIGl0LlxuICAgICAgLy8gSnVzdCBpZ25vcmUuIFdlJ2xsIGRlbGV0ZSB0aGlzIHdpdGggX3JlbmRlclN1YnRyZWUgY29kZSBwYXRoIGxhdGVyLlxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGZsdXNoUGFzc2l2ZUVmZmVjdHMoKTtcbiAgICBmbHVzaFN5bmMoZnVuY3Rpb24gKCkge1xuICAgICAgdXBkYXRlQ29udGFpbmVyKGVsZW1lbnQsIHJvb3QsIG51bGwsIG51bGwpO1xuICAgIH0pO1xuICB9XG59O1xuXG5mdW5jdGlvbiBzY2hlZHVsZUZpYmVyc1dpdGhGYW1pbGllc1JlY3Vyc2l2ZWx5KGZpYmVyLCB1cGRhdGVkRmFtaWxpZXMsIHN0YWxlRmFtaWxpZXMpIHtcbiAge1xuICAgIHZhciBhbHRlcm5hdGUgPSBmaWJlci5hbHRlcm5hdGUsXG4gICAgICAgIGNoaWxkID0gZmliZXIuY2hpbGQsXG4gICAgICAgIHNpYmxpbmcgPSBmaWJlci5zaWJsaW5nLFxuICAgICAgICB0YWcgPSBmaWJlci50YWcsXG4gICAgICAgIHR5cGUgPSBmaWJlci50eXBlO1xuICAgIHZhciBjYW5kaWRhdGVUeXBlID0gbnVsbDtcblxuICAgIHN3aXRjaCAodGFnKSB7XG4gICAgICBjYXNlIEZ1bmN0aW9uQ29tcG9uZW50OlxuICAgICAgY2FzZSBTaW1wbGVNZW1vQ29tcG9uZW50OlxuICAgICAgY2FzZSBDbGFzc0NvbXBvbmVudDpcbiAgICAgICAgY2FuZGlkYXRlVHlwZSA9IHR5cGU7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIEZvcndhcmRSZWY6XG4gICAgICAgIGNhbmRpZGF0ZVR5cGUgPSB0eXBlLnJlbmRlcjtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgaWYgKHJlc29sdmVGYW1pbHkgPT09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgcmVzb2x2ZUZhbWlseSB0byBiZSBzZXQgZHVyaW5nIGhvdCByZWxvYWQuJyk7XG4gICAgfVxuXG4gICAgdmFyIG5lZWRzUmVuZGVyID0gZmFsc2U7XG4gICAgdmFyIG5lZWRzUmVtb3VudCA9IGZhbHNlO1xuXG4gICAgaWYgKGNhbmRpZGF0ZVR5cGUgIT09IG51bGwpIHtcbiAgICAgIHZhciBmYW1pbHkgPSByZXNvbHZlRmFtaWx5KGNhbmRpZGF0ZVR5cGUpO1xuXG4gICAgICBpZiAoZmFtaWx5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKHN0YWxlRmFtaWxpZXMuaGFzKGZhbWlseSkpIHtcbiAgICAgICAgICBuZWVkc1JlbW91bnQgPSB0cnVlO1xuICAgICAgICB9IGVsc2UgaWYgKHVwZGF0ZWRGYW1pbGllcy5oYXMoZmFtaWx5KSkge1xuICAgICAgICAgIGlmICh0YWcgPT09IENsYXNzQ29tcG9uZW50KSB7XG4gICAgICAgICAgICBuZWVkc1JlbW91bnQgPSB0cnVlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBuZWVkc1JlbmRlciA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGZhaWxlZEJvdW5kYXJpZXMgIT09IG51bGwpIHtcbiAgICAgIGlmIChmYWlsZWRCb3VuZGFyaWVzLmhhcyhmaWJlcikgfHwgYWx0ZXJuYXRlICE9PSBudWxsICYmIGZhaWxlZEJvdW5kYXJpZXMuaGFzKGFsdGVybmF0ZSkpIHtcbiAgICAgICAgbmVlZHNSZW1vdW50ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAobmVlZHNSZW1vdW50KSB7XG4gICAgICBmaWJlci5fZGVidWdOZWVkc1JlbW91bnQgPSB0cnVlO1xuICAgIH1cblxuICAgIGlmIChuZWVkc1JlbW91bnQgfHwgbmVlZHNSZW5kZXIpIHtcbiAgICAgIHNjaGVkdWxlVXBkYXRlT25GaWJlcihmaWJlciwgU3luY0xhbmUsIE5vVGltZXN0YW1wKTtcbiAgICB9XG5cbiAgICBpZiAoY2hpbGQgIT09IG51bGwgJiYgIW5lZWRzUmVtb3VudCkge1xuICAgICAgc2NoZWR1bGVGaWJlcnNXaXRoRmFtaWxpZXNSZWN1cnNpdmVseShjaGlsZCwgdXBkYXRlZEZhbWlsaWVzLCBzdGFsZUZhbWlsaWVzKTtcbiAgICB9XG5cbiAgICBpZiAoc2libGluZyAhPT0gbnVsbCkge1xuICAgICAgc2NoZWR1bGVGaWJlcnNXaXRoRmFtaWxpZXNSZWN1cnNpdmVseShzaWJsaW5nLCB1cGRhdGVkRmFtaWxpZXMsIHN0YWxlRmFtaWxpZXMpO1xuICAgIH1cbiAgfVxufVxuXG52YXIgZmluZEhvc3RJbnN0YW5jZXNGb3JSZWZyZXNoID0gZnVuY3Rpb24gKHJvb3QsIGZhbWlsaWVzKSB7XG4gIHtcbiAgICB2YXIgaG9zdEluc3RhbmNlcyA9IG5ldyBTZXQoKTtcbiAgICB2YXIgdHlwZXMgPSBuZXcgU2V0KGZhbWlsaWVzLm1hcChmdW5jdGlvbiAoZmFtaWx5KSB7XG4gICAgICByZXR1cm4gZmFtaWx5LmN1cnJlbnQ7XG4gICAgfSkpO1xuICAgIGZpbmRIb3N0SW5zdGFuY2VzRm9yTWF0Y2hpbmdGaWJlcnNSZWN1cnNpdmVseShyb290LmN1cnJlbnQsIHR5cGVzLCBob3N0SW5zdGFuY2VzKTtcbiAgICByZXR1cm4gaG9zdEluc3RhbmNlcztcbiAgfVxufTtcblxuZnVuY3Rpb24gZmluZEhvc3RJbnN0YW5jZXNGb3JNYXRjaGluZ0ZpYmVyc1JlY3Vyc2l2ZWx5KGZpYmVyLCB0eXBlcywgaG9zdEluc3RhbmNlcykge1xuICB7XG4gICAgdmFyIGNoaWxkID0gZmliZXIuY2hpbGQsXG4gICAgICAgIHNpYmxpbmcgPSBmaWJlci5zaWJsaW5nLFxuICAgICAgICB0YWcgPSBmaWJlci50YWcsXG4gICAgICAgIHR5cGUgPSBmaWJlci50eXBlO1xuICAgIHZhciBjYW5kaWRhdGVUeXBlID0gbnVsbDtcblxuICAgIHN3aXRjaCAodGFnKSB7XG4gICAgICBjYXNlIEZ1bmN0aW9uQ29tcG9uZW50OlxuICAgICAgY2FzZSBTaW1wbGVNZW1vQ29tcG9uZW50OlxuICAgICAgY2FzZSBDbGFzc0NvbXBvbmVudDpcbiAgICAgICAgY2FuZGlkYXRlVHlwZSA9IHR5cGU7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIEZvcndhcmRSZWY6XG4gICAgICAgIGNhbmRpZGF0ZVR5cGUgPSB0eXBlLnJlbmRlcjtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgdmFyIGRpZE1hdGNoID0gZmFsc2U7XG5cbiAgICBpZiAoY2FuZGlkYXRlVHlwZSAhPT0gbnVsbCkge1xuICAgICAgaWYgKHR5cGVzLmhhcyhjYW5kaWRhdGVUeXBlKSkge1xuICAgICAgICBkaWRNYXRjaCA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGRpZE1hdGNoKSB7XG4gICAgICAvLyBXZSBoYXZlIGEgbWF0Y2guIFRoaXMgb25seSBkcmlsbHMgZG93biB0byB0aGUgY2xvc2VzdCBob3N0IGNvbXBvbmVudHMuXG4gICAgICAvLyBUaGVyZSdzIG5vIG5lZWQgdG8gc2VhcmNoIGRlZXBlciBiZWNhdXNlIGZvciB0aGUgcHVycG9zZSBvZiBnaXZpbmdcbiAgICAgIC8vIHZpc3VhbCBmZWVkYmFjaywgXCJmbGFzaGluZ1wiIG91dGVybW9zdCBwYXJlbnQgcmVjdGFuZ2xlcyBpcyBzdWZmaWNpZW50LlxuICAgICAgZmluZEhvc3RJbnN0YW5jZXNGb3JGaWJlclNoYWxsb3dseShmaWJlciwgaG9zdEluc3RhbmNlcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIElmIHRoZXJlJ3Mgbm8gbWF0Y2gsIG1heWJlIHRoZXJlIHdpbGwgYmUgb25lIGZ1cnRoZXIgZG93biBpbiB0aGUgY2hpbGQgdHJlZS5cbiAgICAgIGlmIChjaGlsZCAhPT0gbnVsbCkge1xuICAgICAgICBmaW5kSG9zdEluc3RhbmNlc0Zvck1hdGNoaW5nRmliZXJzUmVjdXJzaXZlbHkoY2hpbGQsIHR5cGVzLCBob3N0SW5zdGFuY2VzKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoc2libGluZyAhPT0gbnVsbCkge1xuICAgICAgZmluZEhvc3RJbnN0YW5jZXNGb3JNYXRjaGluZ0ZpYmVyc1JlY3Vyc2l2ZWx5KHNpYmxpbmcsIHR5cGVzLCBob3N0SW5zdGFuY2VzKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZmluZEhvc3RJbnN0YW5jZXNGb3JGaWJlclNoYWxsb3dseShmaWJlciwgaG9zdEluc3RhbmNlcykge1xuICB7XG4gICAgdmFyIGZvdW5kSG9zdEluc3RhbmNlcyA9IGZpbmRDaGlsZEhvc3RJbnN0YW5jZXNGb3JGaWJlclNoYWxsb3dseShmaWJlciwgaG9zdEluc3RhbmNlcyk7XG5cbiAgICBpZiAoZm91bmRIb3N0SW5zdGFuY2VzKSB7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyBJZiB3ZSBkaWRuJ3QgZmluZCBhbnkgaG9zdCBjaGlsZHJlbiwgZmFsbGJhY2sgdG8gY2xvc2VzdCBob3N0IHBhcmVudC5cblxuXG4gICAgdmFyIG5vZGUgPSBmaWJlcjtcblxuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICBzd2l0Y2ggKG5vZGUudGFnKSB7XG4gICAgICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICAgICAgICBob3N0SW5zdGFuY2VzLmFkZChub2RlLnN0YXRlTm9kZSk7XG4gICAgICAgICAgcmV0dXJuO1xuXG4gICAgICAgIGNhc2UgSG9zdFBvcnRhbDpcbiAgICAgICAgICBob3N0SW5zdGFuY2VzLmFkZChub2RlLnN0YXRlTm9kZS5jb250YWluZXJJbmZvKTtcbiAgICAgICAgICByZXR1cm47XG5cbiAgICAgICAgY2FzZSBIb3N0Um9vdDpcbiAgICAgICAgICBob3N0SW5zdGFuY2VzLmFkZChub2RlLnN0YXRlTm9kZS5jb250YWluZXJJbmZvKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChub2RlLnJldHVybiA9PT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIHRvIHJlYWNoIHJvb3QgZmlyc3QuJyk7XG4gICAgICB9XG5cbiAgICAgIG5vZGUgPSBub2RlLnJldHVybjtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZmluZENoaWxkSG9zdEluc3RhbmNlc0ZvckZpYmVyU2hhbGxvd2x5KGZpYmVyLCBob3N0SW5zdGFuY2VzKSB7XG4gIHtcbiAgICB2YXIgbm9kZSA9IGZpYmVyO1xuICAgIHZhciBmb3VuZEhvc3RJbnN0YW5jZXMgPSBmYWxzZTtcblxuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICBpZiAobm9kZS50YWcgPT09IEhvc3RDb21wb25lbnQpIHtcbiAgICAgICAgLy8gV2UgZ290IGEgbWF0Y2guXG4gICAgICAgIGZvdW5kSG9zdEluc3RhbmNlcyA9IHRydWU7XG4gICAgICAgIGhvc3RJbnN0YW5jZXMuYWRkKG5vZGUuc3RhdGVOb2RlKTsgLy8gVGhlcmUgbWF5IHN0aWxsIGJlIG1vcmUsIHNvIGtlZXAgc2VhcmNoaW5nLlxuICAgICAgfSBlbHNlIGlmIChub2RlLmNoaWxkICE9PSBudWxsKSB7XG4gICAgICAgIG5vZGUuY2hpbGQucmV0dXJuID0gbm9kZTtcbiAgICAgICAgbm9kZSA9IG5vZGUuY2hpbGQ7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAobm9kZSA9PT0gZmliZXIpIHtcbiAgICAgICAgcmV0dXJuIGZvdW5kSG9zdEluc3RhbmNlcztcbiAgICAgIH1cblxuICAgICAgd2hpbGUgKG5vZGUuc2libGluZyA9PT0gbnVsbCkge1xuICAgICAgICBpZiAobm9kZS5yZXR1cm4gPT09IG51bGwgfHwgbm9kZS5yZXR1cm4gPT09IGZpYmVyKSB7XG4gICAgICAgICAgcmV0dXJuIGZvdW5kSG9zdEluc3RhbmNlcztcbiAgICAgICAgfVxuXG4gICAgICAgIG5vZGUgPSBub2RlLnJldHVybjtcbiAgICAgIH1cblxuICAgICAgbm9kZS5zaWJsaW5nLnJldHVybiA9IG5vZGUucmV0dXJuO1xuICAgICAgbm9kZSA9IG5vZGUuc2libGluZztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbnZhciBoYXNCYWRNYXBQb2x5ZmlsbDtcblxue1xuICBoYXNCYWRNYXBQb2x5ZmlsbCA9IGZhbHNlO1xuXG4gIHRyeSB7XG4gICAgdmFyIG5vbkV4dGVuc2libGVPYmplY3QgPSBPYmplY3QucHJldmVudEV4dGVuc2lvbnMoe30pO1xuICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLW5ldyAqL1xuXG4gICAgbmV3IE1hcChbW25vbkV4dGVuc2libGVPYmplY3QsIG51bGxdXSk7XG4gICAgbmV3IFNldChbbm9uRXh0ZW5zaWJsZU9iamVjdF0pO1xuICAgIC8qIGVzbGludC1lbmFibGUgbm8tbmV3ICovXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICAvLyBUT0RPOiBDb25zaWRlciB3YXJuaW5nIGFib3V0IGJhZCBwb2x5ZmlsbHNcbiAgICBoYXNCYWRNYXBQb2x5ZmlsbCA9IHRydWU7XG4gIH1cbn1cblxudmFyIGRlYnVnQ291bnRlciA9IDE7XG5cbmZ1bmN0aW9uIEZpYmVyTm9kZSh0YWcsIHBlbmRpbmdQcm9wcywga2V5LCBtb2RlKSB7XG4gIC8vIEluc3RhbmNlXG4gIHRoaXMudGFnID0gdGFnO1xuICB0aGlzLmtleSA9IGtleTtcbiAgdGhpcy5lbGVtZW50VHlwZSA9IG51bGw7XG4gIHRoaXMudHlwZSA9IG51bGw7XG4gIHRoaXMuc3RhdGVOb2RlID0gbnVsbDsgLy8gRmliZXJcblxuICB0aGlzLnJldHVybiA9IG51bGw7XG4gIHRoaXMuY2hpbGQgPSBudWxsO1xuICB0aGlzLnNpYmxpbmcgPSBudWxsO1xuICB0aGlzLmluZGV4ID0gMDtcbiAgdGhpcy5yZWYgPSBudWxsO1xuICB0aGlzLnBlbmRpbmdQcm9wcyA9IHBlbmRpbmdQcm9wcztcbiAgdGhpcy5tZW1vaXplZFByb3BzID0gbnVsbDtcbiAgdGhpcy51cGRhdGVRdWV1ZSA9IG51bGw7XG4gIHRoaXMubWVtb2l6ZWRTdGF0ZSA9IG51bGw7XG4gIHRoaXMuZGVwZW5kZW5jaWVzID0gbnVsbDtcbiAgdGhpcy5tb2RlID0gbW9kZTsgLy8gRWZmZWN0c1xuXG4gIHRoaXMuZmxhZ3MgPSBOb0ZsYWdzO1xuICB0aGlzLm5leHRFZmZlY3QgPSBudWxsO1xuICB0aGlzLmZpcnN0RWZmZWN0ID0gbnVsbDtcbiAgdGhpcy5sYXN0RWZmZWN0ID0gbnVsbDtcbiAgdGhpcy5sYW5lcyA9IE5vTGFuZXM7XG4gIHRoaXMuY2hpbGRMYW5lcyA9IE5vTGFuZXM7XG4gIHRoaXMuYWx0ZXJuYXRlID0gbnVsbDtcblxuICB7XG4gICAgLy8gTm90ZTogVGhlIGZvbGxvd2luZyBpcyBkb25lIHRvIGF2b2lkIGEgdjggcGVyZm9ybWFuY2UgY2xpZmYuXG4gICAgLy9cbiAgICAvLyBJbml0aWFsaXppbmcgdGhlIGZpZWxkcyBiZWxvdyB0byBzbWlzIGFuZCBsYXRlciB1cGRhdGluZyB0aGVtIHdpdGhcbiAgICAvLyBkb3VibGUgdmFsdWVzIHdpbGwgY2F1c2UgRmliZXJzIHRvIGVuZCB1cCBoYXZpbmcgc2VwYXJhdGUgc2hhcGVzLlxuICAgIC8vIFRoaXMgYmVoYXZpb3IvYnVnIGhhcyBzb21ldGhpbmcgdG8gZG8gd2l0aCBPYmplY3QucHJldmVudEV4dGVuc2lvbigpLlxuICAgIC8vIEZvcnR1bmF0ZWx5IHRoaXMgb25seSBpbXBhY3RzIERFViBidWlsZHMuXG4gICAgLy8gVW5mb3J0dW5hdGVseSBpdCBtYWtlcyBSZWFjdCB1bnVzYWJseSBzbG93IGZvciBzb21lIGFwcGxpY2F0aW9ucy5cbiAgICAvLyBUbyB3b3JrIGFyb3VuZCB0aGlzLCBpbml0aWFsaXplIHRoZSBmaWVsZHMgYmVsb3cgd2l0aCBkb3VibGVzLlxuICAgIC8vXG4gICAgLy8gTGVhcm4gbW9yZSBhYm91dCB0aGlzIGhlcmU6XG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xNDM2NVxuICAgIC8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTg1MzhcbiAgICB0aGlzLmFjdHVhbER1cmF0aW9uID0gTnVtYmVyLk5hTjtcbiAgICB0aGlzLmFjdHVhbFN0YXJ0VGltZSA9IE51bWJlci5OYU47XG4gICAgdGhpcy5zZWxmQmFzZUR1cmF0aW9uID0gTnVtYmVyLk5hTjtcbiAgICB0aGlzLnRyZWVCYXNlRHVyYXRpb24gPSBOdW1iZXIuTmFOOyAvLyBJdCdzIG9rYXkgdG8gcmVwbGFjZSB0aGUgaW5pdGlhbCBkb3VibGVzIHdpdGggc21pcyBhZnRlciBpbml0aWFsaXphdGlvbi5cbiAgICAvLyBUaGlzIHdvbid0IHRyaWdnZXIgdGhlIHBlcmZvcm1hbmNlIGNsaWZmIG1lbnRpb25lZCBhYm92ZSxcbiAgICAvLyBhbmQgaXQgc2ltcGxpZmllcyBvdGhlciBwcm9maWxlciBjb2RlIChpbmNsdWRpbmcgRGV2VG9vbHMpLlxuXG4gICAgdGhpcy5hY3R1YWxEdXJhdGlvbiA9IDA7XG4gICAgdGhpcy5hY3R1YWxTdGFydFRpbWUgPSAtMTtcbiAgICB0aGlzLnNlbGZCYXNlRHVyYXRpb24gPSAwO1xuICAgIHRoaXMudHJlZUJhc2VEdXJhdGlvbiA9IDA7XG4gIH1cblxuICB7XG4gICAgLy8gVGhpcyBpc24ndCBkaXJlY3RseSB1c2VkIGJ1dCBpcyBoYW5keSBmb3IgZGVidWdnaW5nIGludGVybmFsczpcbiAgICB0aGlzLl9kZWJ1Z0lEID0gZGVidWdDb3VudGVyKys7XG4gICAgdGhpcy5fZGVidWdTb3VyY2UgPSBudWxsO1xuICAgIHRoaXMuX2RlYnVnT3duZXIgPSBudWxsO1xuICAgIHRoaXMuX2RlYnVnTmVlZHNSZW1vdW50ID0gZmFsc2U7XG4gICAgdGhpcy5fZGVidWdIb29rVHlwZXMgPSBudWxsO1xuXG4gICAgaWYgKCFoYXNCYWRNYXBQb2x5ZmlsbCAmJiB0eXBlb2YgT2JqZWN0LnByZXZlbnRFeHRlbnNpb25zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBPYmplY3QucHJldmVudEV4dGVuc2lvbnModGhpcyk7XG4gICAgfVxuICB9XG59IC8vIFRoaXMgaXMgYSBjb25zdHJ1Y3RvciBmdW5jdGlvbiwgcmF0aGVyIHRoYW4gYSBQT0pPIGNvbnN0cnVjdG9yLCBzdGlsbFxuLy8gcGxlYXNlIGVuc3VyZSB3ZSBkbyB0aGUgZm9sbG93aW5nOlxuLy8gMSkgTm9ib2R5IHNob3VsZCBhZGQgYW55IGluc3RhbmNlIG1ldGhvZHMgb24gdGhpcy4gSW5zdGFuY2UgbWV0aG9kcyBjYW4gYmVcbi8vICAgIG1vcmUgZGlmZmljdWx0IHRvIHByZWRpY3Qgd2hlbiB0aGV5IGdldCBvcHRpbWl6ZWQgYW5kIHRoZXkgYXJlIGFsbW9zdFxuLy8gICAgbmV2ZXIgaW5saW5lZCBwcm9wZXJseSBpbiBzdGF0aWMgY29tcGlsZXJzLlxuLy8gMikgTm9ib2R5IHNob3VsZCByZWx5IG9uIGBpbnN0YW5jZW9mIEZpYmVyYCBmb3IgdHlwZSB0ZXN0aW5nLiBXZSBzaG91bGRcbi8vICAgIGFsd2F5cyBrbm93IHdoZW4gaXQgaXMgYSBmaWJlci5cbi8vIDMpIFdlIG1pZ2h0IHdhbnQgdG8gZXhwZXJpbWVudCB3aXRoIHVzaW5nIG51bWVyaWMga2V5cyBzaW5jZSB0aGV5IGFyZSBlYXNpZXJcbi8vICAgIHRvIG9wdGltaXplIGluIGEgbm9uLUpJVCBlbnZpcm9ubWVudC5cbi8vIDQpIFdlIGNhbiBlYXNpbHkgZ28gZnJvbSBhIGNvbnN0cnVjdG9yIHRvIGEgY3JlYXRlRmliZXIgb2JqZWN0IGxpdGVyYWwgaWYgdGhhdFxuLy8gICAgaXMgZmFzdGVyLlxuLy8gNSkgSXQgc2hvdWxkIGJlIGVhc3kgdG8gcG9ydCB0aGlzIHRvIGEgQyBzdHJ1Y3QgYW5kIGtlZXAgYSBDIGltcGxlbWVudGF0aW9uXG4vLyAgICBjb21wYXRpYmxlLlxuXG5cbnZhciBjcmVhdGVGaWJlciA9IGZ1bmN0aW9uICh0YWcsIHBlbmRpbmdQcm9wcywga2V5LCBtb2RlKSB7XG4gIC8vICRGbG93Rml4TWU6IHRoZSBzaGFwZXMgYXJlIGV4YWN0IGhlcmUgYnV0IEZsb3cgZG9lc24ndCBsaWtlIGNvbnN0cnVjdG9yc1xuICByZXR1cm4gbmV3IEZpYmVyTm9kZSh0YWcsIHBlbmRpbmdQcm9wcywga2V5LCBtb2RlKTtcbn07XG5cbmZ1bmN0aW9uIHNob3VsZENvbnN0cnVjdCQxKENvbXBvbmVudCkge1xuICB2YXIgcHJvdG90eXBlID0gQ29tcG9uZW50LnByb3RvdHlwZTtcbiAgcmV0dXJuICEhKHByb3RvdHlwZSAmJiBwcm90b3R5cGUuaXNSZWFjdENvbXBvbmVudCk7XG59XG5cbmZ1bmN0aW9uIGlzU2ltcGxlRnVuY3Rpb25Db21wb25lbnQodHlwZSkge1xuICByZXR1cm4gdHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicgJiYgIXNob3VsZENvbnN0cnVjdCQxKHR5cGUpICYmIHR5cGUuZGVmYXVsdFByb3BzID09PSB1bmRlZmluZWQ7XG59XG5mdW5jdGlvbiByZXNvbHZlTGF6eUNvbXBvbmVudFRhZyhDb21wb25lbnQpIHtcbiAgaWYgKHR5cGVvZiBDb21wb25lbnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gc2hvdWxkQ29uc3RydWN0JDEoQ29tcG9uZW50KSA/IENsYXNzQ29tcG9uZW50IDogRnVuY3Rpb25Db21wb25lbnQ7XG4gIH0gZWxzZSBpZiAoQ29tcG9uZW50ICE9PSB1bmRlZmluZWQgJiYgQ29tcG9uZW50ICE9PSBudWxsKSB7XG4gICAgdmFyICQkdHlwZW9mID0gQ29tcG9uZW50LiQkdHlwZW9mO1xuXG4gICAgaWYgKCQkdHlwZW9mID09PSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFKSB7XG4gICAgICByZXR1cm4gRm9yd2FyZFJlZjtcbiAgICB9XG5cbiAgICBpZiAoJCR0eXBlb2YgPT09IFJFQUNUX01FTU9fVFlQRSkge1xuICAgICAgcmV0dXJuIE1lbW9Db21wb25lbnQ7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIEluZGV0ZXJtaW5hdGVDb21wb25lbnQ7XG59IC8vIFRoaXMgaXMgdXNlZCB0byBjcmVhdGUgYW4gYWx0ZXJuYXRlIGZpYmVyIHRvIGRvIHdvcmsgb24uXG5cbmZ1bmN0aW9uIGNyZWF0ZVdvcmtJblByb2dyZXNzKGN1cnJlbnQsIHBlbmRpbmdQcm9wcykge1xuICB2YXIgd29ya0luUHJvZ3Jlc3MgPSBjdXJyZW50LmFsdGVybmF0ZTtcblxuICBpZiAod29ya0luUHJvZ3Jlc3MgPT09IG51bGwpIHtcbiAgICAvLyBXZSB1c2UgYSBkb3VibGUgYnVmZmVyaW5nIHBvb2xpbmcgdGVjaG5pcXVlIGJlY2F1c2Ugd2Uga25vdyB0aGF0IHdlJ2xsXG4gICAgLy8gb25seSBldmVyIG5lZWQgYXQgbW9zdCB0d28gdmVyc2lvbnMgb2YgYSB0cmVlLiBXZSBwb29sIHRoZSBcIm90aGVyXCIgdW51c2VkXG4gICAgLy8gbm9kZSB0aGF0IHdlJ3JlIGZyZWUgdG8gcmV1c2UuIFRoaXMgaXMgbGF6aWx5IGNyZWF0ZWQgdG8gYXZvaWQgYWxsb2NhdGluZ1xuICAgIC8vIGV4dHJhIG9iamVjdHMgZm9yIHRoaW5ncyB0aGF0IGFyZSBuZXZlciB1cGRhdGVkLiBJdCBhbHNvIGFsbG93IHVzIHRvXG4gICAgLy8gcmVjbGFpbSB0aGUgZXh0cmEgbWVtb3J5IGlmIG5lZWRlZC5cbiAgICB3b3JrSW5Qcm9ncmVzcyA9IGNyZWF0ZUZpYmVyKGN1cnJlbnQudGFnLCBwZW5kaW5nUHJvcHMsIGN1cnJlbnQua2V5LCBjdXJyZW50Lm1vZGUpO1xuICAgIHdvcmtJblByb2dyZXNzLmVsZW1lbnRUeXBlID0gY3VycmVudC5lbGVtZW50VHlwZTtcbiAgICB3b3JrSW5Qcm9ncmVzcy50eXBlID0gY3VycmVudC50eXBlO1xuICAgIHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSA9IGN1cnJlbnQuc3RhdGVOb2RlO1xuXG4gICAge1xuICAgICAgLy8gREVWLW9ubHkgZmllbGRzXG4gICAgICB3b3JrSW5Qcm9ncmVzcy5fZGVidWdJRCA9IGN1cnJlbnQuX2RlYnVnSUQ7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5fZGVidWdTb3VyY2UgPSBjdXJyZW50Ll9kZWJ1Z1NvdXJjZTtcbiAgICAgIHdvcmtJblByb2dyZXNzLl9kZWJ1Z093bmVyID0gY3VycmVudC5fZGVidWdPd25lcjtcbiAgICAgIHdvcmtJblByb2dyZXNzLl9kZWJ1Z0hvb2tUeXBlcyA9IGN1cnJlbnQuX2RlYnVnSG9va1R5cGVzO1xuICAgIH1cblxuICAgIHdvcmtJblByb2dyZXNzLmFsdGVybmF0ZSA9IGN1cnJlbnQ7XG4gICAgY3VycmVudC5hbHRlcm5hdGUgPSB3b3JrSW5Qcm9ncmVzcztcbiAgfSBlbHNlIHtcbiAgICB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHMgPSBwZW5kaW5nUHJvcHM7IC8vIE5lZWRlZCBiZWNhdXNlIEJsb2NrcyBzdG9yZSBkYXRhIG9uIHR5cGUuXG5cbiAgICB3b3JrSW5Qcm9ncmVzcy50eXBlID0gY3VycmVudC50eXBlOyAvLyBXZSBhbHJlYWR5IGhhdmUgYW4gYWx0ZXJuYXRlLlxuICAgIC8vIFJlc2V0IHRoZSBlZmZlY3QgdGFnLlxuXG4gICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgPSBOb0ZsYWdzOyAvLyBUaGUgZWZmZWN0IGxpc3QgaXMgbm8gbG9uZ2VyIHZhbGlkLlxuXG4gICAgd29ya0luUHJvZ3Jlc3MubmV4dEVmZmVjdCA9IG51bGw7XG4gICAgd29ya0luUHJvZ3Jlc3MuZmlyc3RFZmZlY3QgPSBudWxsO1xuICAgIHdvcmtJblByb2dyZXNzLmxhc3RFZmZlY3QgPSBudWxsO1xuXG4gICAge1xuICAgICAgLy8gV2UgaW50ZW50aW9uYWxseSByZXNldCwgcmF0aGVyIHRoYW4gY29weSwgYWN0dWFsRHVyYXRpb24gJiBhY3R1YWxTdGFydFRpbWUuXG4gICAgICAvLyBUaGlzIHByZXZlbnRzIHRpbWUgZnJvbSBlbmRsZXNzbHkgYWNjdW11bGF0aW5nIGluIG5ldyBjb21taXRzLlxuICAgICAgLy8gVGhpcyBoYXMgdGhlIGRvd25zaWRlIG9mIHJlc2V0dGluZyB2YWx1ZXMgZm9yIGRpZmZlcmVudCBwcmlvcml0eSByZW5kZXJzLFxuICAgICAgLy8gQnV0IHdvcmtzIGZvciB5aWVsZGluZyAodGhlIGNvbW1vbiBjYXNlKSBhbmQgc2hvdWxkIHN1cHBvcnQgcmVzdW1pbmcuXG4gICAgICB3b3JrSW5Qcm9ncmVzcy5hY3R1YWxEdXJhdGlvbiA9IDA7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5hY3R1YWxTdGFydFRpbWUgPSAtMTtcbiAgICB9XG4gIH1cblxuICB3b3JrSW5Qcm9ncmVzcy5jaGlsZExhbmVzID0gY3VycmVudC5jaGlsZExhbmVzO1xuICB3b3JrSW5Qcm9ncmVzcy5sYW5lcyA9IGN1cnJlbnQubGFuZXM7XG4gIHdvcmtJblByb2dyZXNzLmNoaWxkID0gY3VycmVudC5jaGlsZDtcbiAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcyA9IGN1cnJlbnQubWVtb2l6ZWRQcm9wcztcbiAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZTtcbiAgd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWUgPSBjdXJyZW50LnVwZGF0ZVF1ZXVlOyAvLyBDbG9uZSB0aGUgZGVwZW5kZW5jaWVzIG9iamVjdC4gVGhpcyBpcyBtdXRhdGVkIGR1cmluZyB0aGUgcmVuZGVyIHBoYXNlLCBzb1xuICAvLyBpdCBjYW5ub3QgYmUgc2hhcmVkIHdpdGggdGhlIGN1cnJlbnQgZmliZXIuXG5cbiAgdmFyIGN1cnJlbnREZXBlbmRlbmNpZXMgPSBjdXJyZW50LmRlcGVuZGVuY2llcztcbiAgd29ya0luUHJvZ3Jlc3MuZGVwZW5kZW5jaWVzID0gY3VycmVudERlcGVuZGVuY2llcyA9PT0gbnVsbCA/IG51bGwgOiB7XG4gICAgbGFuZXM6IGN1cnJlbnREZXBlbmRlbmNpZXMubGFuZXMsXG4gICAgZmlyc3RDb250ZXh0OiBjdXJyZW50RGVwZW5kZW5jaWVzLmZpcnN0Q29udGV4dFxuICB9OyAvLyBUaGVzZSB3aWxsIGJlIG92ZXJyaWRkZW4gZHVyaW5nIHRoZSBwYXJlbnQncyByZWNvbmNpbGlhdGlvblxuXG4gIHdvcmtJblByb2dyZXNzLnNpYmxpbmcgPSBjdXJyZW50LnNpYmxpbmc7XG4gIHdvcmtJblByb2dyZXNzLmluZGV4ID0gY3VycmVudC5pbmRleDtcbiAgd29ya0luUHJvZ3Jlc3MucmVmID0gY3VycmVudC5yZWY7XG5cbiAge1xuICAgIHdvcmtJblByb2dyZXNzLnNlbGZCYXNlRHVyYXRpb24gPSBjdXJyZW50LnNlbGZCYXNlRHVyYXRpb247XG4gICAgd29ya0luUHJvZ3Jlc3MudHJlZUJhc2VEdXJhdGlvbiA9IGN1cnJlbnQudHJlZUJhc2VEdXJhdGlvbjtcbiAgfVxuXG4gIHtcbiAgICB3b3JrSW5Qcm9ncmVzcy5fZGVidWdOZWVkc1JlbW91bnQgPSBjdXJyZW50Ll9kZWJ1Z05lZWRzUmVtb3VudDtcblxuICAgIHN3aXRjaCAod29ya0luUHJvZ3Jlc3MudGFnKSB7XG4gICAgICBjYXNlIEluZGV0ZXJtaW5hdGVDb21wb25lbnQ6XG4gICAgICBjYXNlIEZ1bmN0aW9uQ29tcG9uZW50OlxuICAgICAgY2FzZSBTaW1wbGVNZW1vQ29tcG9uZW50OlxuICAgICAgICB3b3JrSW5Qcm9ncmVzcy50eXBlID0gcmVzb2x2ZUZ1bmN0aW9uRm9ySG90UmVsb2FkaW5nKGN1cnJlbnQudHlwZSk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIENsYXNzQ29tcG9uZW50OlxuICAgICAgICB3b3JrSW5Qcm9ncmVzcy50eXBlID0gcmVzb2x2ZUNsYXNzRm9ySG90UmVsb2FkaW5nKGN1cnJlbnQudHlwZSk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIEZvcndhcmRSZWY6XG4gICAgICAgIHdvcmtJblByb2dyZXNzLnR5cGUgPSByZXNvbHZlRm9yd2FyZFJlZkZvckhvdFJlbG9hZGluZyhjdXJyZW50LnR5cGUpO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gd29ya0luUHJvZ3Jlc3M7XG59IC8vIFVzZWQgdG8gcmV1c2UgYSBGaWJlciBmb3IgYSBzZWNvbmQgcGFzcy5cblxuZnVuY3Rpb24gcmVzZXRXb3JrSW5Qcm9ncmVzcyh3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpIHtcbiAgLy8gVGhpcyByZXNldHMgdGhlIEZpYmVyIHRvIHdoYXQgY3JlYXRlRmliZXIgb3IgY3JlYXRlV29ya0luUHJvZ3Jlc3Mgd291bGRcbiAgLy8gaGF2ZSBzZXQgdGhlIHZhbHVlcyB0byBiZWZvcmUgZHVyaW5nIHRoZSBmaXJzdCBwYXNzLiBJZGVhbGx5IHRoaXMgd291bGRuJ3RcbiAgLy8gYmUgbmVjZXNzYXJ5IGJ1dCB1bmZvcnR1bmF0ZWx5IG1hbnkgY29kZSBwYXRocyByZWFkcyBmcm9tIHRoZSB3b3JrSW5Qcm9ncmVzc1xuICAvLyB3aGVuIHRoZXkgc2hvdWxkIGJlIHJlYWRpbmcgZnJvbSBjdXJyZW50IGFuZCB3cml0aW5nIHRvIHdvcmtJblByb2dyZXNzLlxuICAvLyBXZSBhc3N1bWUgcGVuZGluZ1Byb3BzLCBpbmRleCwga2V5LCByZWYsIHJldHVybiBhcmUgc3RpbGwgdW50b3VjaGVkIHRvXG4gIC8vIGF2b2lkIGRvaW5nIGFub3RoZXIgcmVjb25jaWxpYXRpb24uXG4gIC8vIFJlc2V0IHRoZSBlZmZlY3QgdGFnIGJ1dCBrZWVwIGFueSBQbGFjZW1lbnQgdGFncywgc2luY2UgdGhhdCdzIHNvbWV0aGluZ1xuICAvLyB0aGF0IGNoaWxkIGZpYmVyIGlzIHNldHRpbmcsIG5vdCB0aGUgcmVjb25jaWxpYXRpb24uXG4gIHdvcmtJblByb2dyZXNzLmZsYWdzICY9IFBsYWNlbWVudDsgLy8gVGhlIGVmZmVjdCBsaXN0IGlzIG5vIGxvbmdlciB2YWxpZC5cblxuICB3b3JrSW5Qcm9ncmVzcy5uZXh0RWZmZWN0ID0gbnVsbDtcbiAgd29ya0luUHJvZ3Jlc3MuZmlyc3RFZmZlY3QgPSBudWxsO1xuICB3b3JrSW5Qcm9ncmVzcy5sYXN0RWZmZWN0ID0gbnVsbDtcbiAgdmFyIGN1cnJlbnQgPSB3b3JrSW5Qcm9ncmVzcy5hbHRlcm5hdGU7XG5cbiAgaWYgKGN1cnJlbnQgPT09IG51bGwpIHtcbiAgICAvLyBSZXNldCB0byBjcmVhdGVGaWJlcidzIGluaXRpYWwgdmFsdWVzLlxuICAgIHdvcmtJblByb2dyZXNzLmNoaWxkTGFuZXMgPSBOb0xhbmVzO1xuICAgIHdvcmtJblByb2dyZXNzLmxhbmVzID0gcmVuZGVyTGFuZXM7XG4gICAgd29ya0luUHJvZ3Jlc3MuY2hpbGQgPSBudWxsO1xuICAgIHdvcmtJblByb2dyZXNzLm1lbW9pemVkUHJvcHMgPSBudWxsO1xuICAgIHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSBudWxsO1xuICAgIHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlID0gbnVsbDtcbiAgICB3b3JrSW5Qcm9ncmVzcy5kZXBlbmRlbmNpZXMgPSBudWxsO1xuICAgIHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSA9IG51bGw7XG5cbiAgICB7XG4gICAgICAvLyBOb3RlOiBXZSBkb24ndCByZXNldCB0aGUgYWN0dWFsVGltZSBjb3VudHMuIEl0J3MgdXNlZnVsIHRvIGFjY3VtdWxhdGVcbiAgICAgIC8vIGFjdHVhbCB0aW1lIGFjcm9zcyBtdWx0aXBsZSByZW5kZXIgcGFzc2VzLlxuICAgICAgd29ya0luUHJvZ3Jlc3Muc2VsZkJhc2VEdXJhdGlvbiA9IDA7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy50cmVlQmFzZUR1cmF0aW9uID0gMDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gUmVzZXQgdG8gdGhlIGNsb25lZCB2YWx1ZXMgdGhhdCBjcmVhdGVXb3JrSW5Qcm9ncmVzcyB3b3VsZCd2ZS5cbiAgICB3b3JrSW5Qcm9ncmVzcy5jaGlsZExhbmVzID0gY3VycmVudC5jaGlsZExhbmVzO1xuICAgIHdvcmtJblByb2dyZXNzLmxhbmVzID0gY3VycmVudC5sYW5lcztcbiAgICB3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IGN1cnJlbnQuY2hpbGQ7XG4gICAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcyA9IGN1cnJlbnQubWVtb2l6ZWRQcm9wcztcbiAgICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID0gY3VycmVudC5tZW1vaXplZFN0YXRlO1xuICAgIHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlID0gY3VycmVudC51cGRhdGVRdWV1ZTsgLy8gTmVlZGVkIGJlY2F1c2UgQmxvY2tzIHN0b3JlIGRhdGEgb24gdHlwZS5cblxuICAgIHdvcmtJblByb2dyZXNzLnR5cGUgPSBjdXJyZW50LnR5cGU7IC8vIENsb25lIHRoZSBkZXBlbmRlbmNpZXMgb2JqZWN0LiBUaGlzIGlzIG11dGF0ZWQgZHVyaW5nIHRoZSByZW5kZXIgcGhhc2UsIHNvXG4gICAgLy8gaXQgY2Fubm90IGJlIHNoYXJlZCB3aXRoIHRoZSBjdXJyZW50IGZpYmVyLlxuXG4gICAgdmFyIGN1cnJlbnREZXBlbmRlbmNpZXMgPSBjdXJyZW50LmRlcGVuZGVuY2llcztcbiAgICB3b3JrSW5Qcm9ncmVzcy5kZXBlbmRlbmNpZXMgPSBjdXJyZW50RGVwZW5kZW5jaWVzID09PSBudWxsID8gbnVsbCA6IHtcbiAgICAgIGxhbmVzOiBjdXJyZW50RGVwZW5kZW5jaWVzLmxhbmVzLFxuICAgICAgZmlyc3RDb250ZXh0OiBjdXJyZW50RGVwZW5kZW5jaWVzLmZpcnN0Q29udGV4dFxuICAgIH07XG5cbiAgICB7XG4gICAgICAvLyBOb3RlOiBXZSBkb24ndCByZXNldCB0aGUgYWN0dWFsVGltZSBjb3VudHMuIEl0J3MgdXNlZnVsIHRvIGFjY3VtdWxhdGVcbiAgICAgIC8vIGFjdHVhbCB0aW1lIGFjcm9zcyBtdWx0aXBsZSByZW5kZXIgcGFzc2VzLlxuICAgICAgd29ya0luUHJvZ3Jlc3Muc2VsZkJhc2VEdXJhdGlvbiA9IGN1cnJlbnQuc2VsZkJhc2VEdXJhdGlvbjtcbiAgICAgIHdvcmtJblByb2dyZXNzLnRyZWVCYXNlRHVyYXRpb24gPSBjdXJyZW50LnRyZWVCYXNlRHVyYXRpb247XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHdvcmtJblByb2dyZXNzO1xufVxuZnVuY3Rpb24gY3JlYXRlSG9zdFJvb3RGaWJlcih0YWcpIHtcbiAgdmFyIG1vZGU7XG5cbiAgaWYgKHRhZyA9PT0gQ29uY3VycmVudFJvb3QpIHtcbiAgICBtb2RlID0gQ29uY3VycmVudE1vZGUgfCBCbG9ja2luZ01vZGUgfCBTdHJpY3RNb2RlO1xuICB9IGVsc2UgaWYgKHRhZyA9PT0gQmxvY2tpbmdSb290KSB7XG4gICAgbW9kZSA9IEJsb2NraW5nTW9kZSB8IFN0cmljdE1vZGU7XG4gIH0gZWxzZSB7XG4gICAgbW9kZSA9IE5vTW9kZTtcbiAgfVxuXG4gIGlmICggaXNEZXZUb29sc1ByZXNlbnQpIHtcbiAgICAvLyBBbHdheXMgY29sbGVjdCBwcm9maWxlIHRpbWluZ3Mgd2hlbiBEZXZUb29scyBhcmUgcHJlc2VudC5cbiAgICAvLyBUaGlzIGVuYWJsZXMgRGV2VG9vbHMgdG8gc3RhcnQgY2FwdHVyaW5nIHRpbWluZyBhdCBhbnkgcG9pbnTigJNcbiAgICAvLyBXaXRob3V0IHNvbWUgbm9kZXMgaW4gdGhlIHRyZWUgaGF2aW5nIGVtcHR5IGJhc2UgdGltZXMuXG4gICAgbW9kZSB8PSBQcm9maWxlTW9kZTtcbiAgfVxuXG4gIHJldHVybiBjcmVhdGVGaWJlcihIb3N0Um9vdCwgbnVsbCwgbnVsbCwgbW9kZSk7XG59XG5mdW5jdGlvbiBjcmVhdGVGaWJlckZyb21UeXBlQW5kUHJvcHModHlwZSwgLy8gUmVhY3QkRWxlbWVudFR5cGVcbmtleSwgcGVuZGluZ1Byb3BzLCBvd25lciwgbW9kZSwgbGFuZXMpIHtcbiAgdmFyIGZpYmVyVGFnID0gSW5kZXRlcm1pbmF0ZUNvbXBvbmVudDsgLy8gVGhlIHJlc29sdmVkIHR5cGUgaXMgc2V0IGlmIHdlIGtub3cgd2hhdCB0aGUgZmluYWwgdHlwZSB3aWxsIGJlLiBJLmUuIGl0J3Mgbm90IGxhenkuXG5cbiAgdmFyIHJlc29sdmVkVHlwZSA9IHR5cGU7XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgaWYgKHNob3VsZENvbnN0cnVjdCQxKHR5cGUpKSB7XG4gICAgICBmaWJlclRhZyA9IENsYXNzQ29tcG9uZW50O1xuXG4gICAgICB7XG4gICAgICAgIHJlc29sdmVkVHlwZSA9IHJlc29sdmVDbGFzc0ZvckhvdFJlbG9hZGluZyhyZXNvbHZlZFR5cGUpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB7XG4gICAgICAgIHJlc29sdmVkVHlwZSA9IHJlc29sdmVGdW5jdGlvbkZvckhvdFJlbG9hZGluZyhyZXNvbHZlZFR5cGUpO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmICh0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICBmaWJlclRhZyA9IEhvc3RDb21wb25lbnQ7XG4gIH0gZWxzZSB7XG4gICAgZ2V0VGFnOiBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgIGNhc2UgUkVBQ1RfRlJBR01FTlRfVFlQRTpcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUZpYmVyRnJvbUZyYWdtZW50KHBlbmRpbmdQcm9wcy5jaGlsZHJlbiwgbW9kZSwgbGFuZXMsIGtleSk7XG5cbiAgICAgIGNhc2UgUkVBQ1RfREVCVUdfVFJBQ0lOR19NT0RFX1RZUEU6XG4gICAgICAgIGZpYmVyVGFnID0gTW9kZTtcbiAgICAgICAgbW9kZSB8PSBEZWJ1Z1RyYWNpbmdNb2RlO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFOlxuICAgICAgICBmaWJlclRhZyA9IE1vZGU7XG4gICAgICAgIG1vZGUgfD0gU3RyaWN0TW9kZTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgUkVBQ1RfUFJPRklMRVJfVFlQRTpcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUZpYmVyRnJvbVByb2ZpbGVyKHBlbmRpbmdQcm9wcywgbW9kZSwgbGFuZXMsIGtleSk7XG5cbiAgICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfVFlQRTpcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUZpYmVyRnJvbVN1c3BlbnNlKHBlbmRpbmdQcm9wcywgbW9kZSwgbGFuZXMsIGtleSk7XG5cbiAgICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFOlxuICAgICAgICByZXR1cm4gY3JlYXRlRmliZXJGcm9tU3VzcGVuc2VMaXN0KHBlbmRpbmdQcm9wcywgbW9kZSwgbGFuZXMsIGtleSk7XG5cbiAgICAgIGNhc2UgUkVBQ1RfT0ZGU0NSRUVOX1RZUEU6XG4gICAgICAgIHJldHVybiBjcmVhdGVGaWJlckZyb21PZmZzY3JlZW4ocGVuZGluZ1Byb3BzLCBtb2RlLCBsYW5lcywga2V5KTtcblxuICAgICAgY2FzZSBSRUFDVF9MRUdBQ1lfSElEREVOX1RZUEU6XG4gICAgICAgIHJldHVybiBjcmVhdGVGaWJlckZyb21MZWdhY3lIaWRkZW4ocGVuZGluZ1Byb3BzLCBtb2RlLCBsYW5lcywga2V5KTtcblxuICAgICAgY2FzZSBSRUFDVF9TQ09QRV9UWVBFOlxuXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZmFsbHRocm91Z2hcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAge1xuICAgICAgICAgIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcgJiYgdHlwZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgc3dpdGNoICh0eXBlLiQkdHlwZW9mKSB7XG4gICAgICAgICAgICAgIGNhc2UgUkVBQ1RfUFJPVklERVJfVFlQRTpcbiAgICAgICAgICAgICAgICBmaWJlclRhZyA9IENvbnRleHRQcm92aWRlcjtcbiAgICAgICAgICAgICAgICBicmVhayBnZXRUYWc7XG5cbiAgICAgICAgICAgICAgY2FzZSBSRUFDVF9DT05URVhUX1RZUEU6XG4gICAgICAgICAgICAgICAgLy8gVGhpcyBpcyBhIGNvbnN1bWVyXG4gICAgICAgICAgICAgICAgZmliZXJUYWcgPSBDb250ZXh0Q29uc3VtZXI7XG4gICAgICAgICAgICAgICAgYnJlYWsgZ2V0VGFnO1xuXG4gICAgICAgICAgICAgIGNhc2UgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRTpcbiAgICAgICAgICAgICAgICBmaWJlclRhZyA9IEZvcndhcmRSZWY7XG5cbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICByZXNvbHZlZFR5cGUgPSByZXNvbHZlRm9yd2FyZFJlZkZvckhvdFJlbG9hZGluZyhyZXNvbHZlZFR5cGUpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGJyZWFrIGdldFRhZztcblxuICAgICAgICAgICAgICBjYXNlIFJFQUNUX01FTU9fVFlQRTpcbiAgICAgICAgICAgICAgICBmaWJlclRhZyA9IE1lbW9Db21wb25lbnQ7XG4gICAgICAgICAgICAgICAgYnJlYWsgZ2V0VGFnO1xuXG4gICAgICAgICAgICAgIGNhc2UgUkVBQ1RfTEFaWV9UWVBFOlxuICAgICAgICAgICAgICAgIGZpYmVyVGFnID0gTGF6eUNvbXBvbmVudDtcbiAgICAgICAgICAgICAgICByZXNvbHZlZFR5cGUgPSBudWxsO1xuICAgICAgICAgICAgICAgIGJyZWFrIGdldFRhZztcblxuICAgICAgICAgICAgICBjYXNlIFJFQUNUX0JMT0NLX1RZUEU6XG4gICAgICAgICAgICAgICAgZmliZXJUYWcgPSBCbG9jaztcbiAgICAgICAgICAgICAgICBicmVhayBnZXRUYWc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIGluZm8gPSAnJztcblxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlmICh0eXBlID09PSB1bmRlZmluZWQgfHwgdHlwZW9mIHR5cGUgPT09ICdvYmplY3QnICYmIHR5cGUgIT09IG51bGwgJiYgT2JqZWN0LmtleXModHlwZSkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgIGluZm8gKz0gJyBZb3UgbGlrZWx5IGZvcmdvdCB0byBleHBvcnQgeW91ciBjb21wb25lbnQgZnJvbSB0aGUgZmlsZSAnICsgXCJpdCdzIGRlZmluZWQgaW4sIG9yIHlvdSBtaWdodCBoYXZlIG1peGVkIHVwIGRlZmF1bHQgYW5kIFwiICsgJ25hbWVkIGltcG9ydHMuJztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIG93bmVyTmFtZSA9IG93bmVyID8gZ2V0Q29tcG9uZW50TmFtZShvd25lci50eXBlKSA6IG51bGw7XG5cbiAgICAgICAgICAgIGlmIChvd25lck5hbWUpIHtcbiAgICAgICAgICAgICAgaW5mbyArPSAnXFxuXFxuQ2hlY2sgdGhlIHJlbmRlciBtZXRob2Qgb2YgYCcgKyBvd25lck5hbWUgKyAnYC4nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoIFwiRWxlbWVudCB0eXBlIGlzIGludmFsaWQ6IGV4cGVjdGVkIGEgc3RyaW5nIChmb3IgYnVpbHQtaW4gY29tcG9uZW50cykgb3IgYSBjbGFzcy9mdW5jdGlvbiAoZm9yIGNvbXBvc2l0ZSBjb21wb25lbnRzKSBidXQgZ290OiBcIiArICh0eXBlID09IG51bGwgPyB0eXBlIDogdHlwZW9mIHR5cGUpICsgXCIuXCIgKyBpbmZvICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICB9XG5cbiAgdmFyIGZpYmVyID0gY3JlYXRlRmliZXIoZmliZXJUYWcsIHBlbmRpbmdQcm9wcywga2V5LCBtb2RlKTtcbiAgZmliZXIuZWxlbWVudFR5cGUgPSB0eXBlO1xuICBmaWJlci50eXBlID0gcmVzb2x2ZWRUeXBlO1xuICBmaWJlci5sYW5lcyA9IGxhbmVzO1xuXG4gIHtcbiAgICBmaWJlci5fZGVidWdPd25lciA9IG93bmVyO1xuICB9XG5cbiAgcmV0dXJuIGZpYmVyO1xufVxuZnVuY3Rpb24gY3JlYXRlRmliZXJGcm9tRWxlbWVudChlbGVtZW50LCBtb2RlLCBsYW5lcykge1xuICB2YXIgb3duZXIgPSBudWxsO1xuXG4gIHtcbiAgICBvd25lciA9IGVsZW1lbnQuX293bmVyO1xuICB9XG5cbiAgdmFyIHR5cGUgPSBlbGVtZW50LnR5cGU7XG4gIHZhciBrZXkgPSBlbGVtZW50LmtleTtcbiAgdmFyIHBlbmRpbmdQcm9wcyA9IGVsZW1lbnQucHJvcHM7XG4gIHZhciBmaWJlciA9IGNyZWF0ZUZpYmVyRnJvbVR5cGVBbmRQcm9wcyh0eXBlLCBrZXksIHBlbmRpbmdQcm9wcywgb3duZXIsIG1vZGUsIGxhbmVzKTtcblxuICB7XG4gICAgZmliZXIuX2RlYnVnU291cmNlID0gZWxlbWVudC5fc291cmNlO1xuICAgIGZpYmVyLl9kZWJ1Z093bmVyID0gZWxlbWVudC5fb3duZXI7XG4gIH1cblxuICByZXR1cm4gZmliZXI7XG59XG5mdW5jdGlvbiBjcmVhdGVGaWJlckZyb21GcmFnbWVudChlbGVtZW50cywgbW9kZSwgbGFuZXMsIGtleSkge1xuICB2YXIgZmliZXIgPSBjcmVhdGVGaWJlcihGcmFnbWVudCwgZWxlbWVudHMsIGtleSwgbW9kZSk7XG4gIGZpYmVyLmxhbmVzID0gbGFuZXM7XG4gIHJldHVybiBmaWJlcjtcbn1cblxuZnVuY3Rpb24gY3JlYXRlRmliZXJGcm9tUHJvZmlsZXIocGVuZGluZ1Byb3BzLCBtb2RlLCBsYW5lcywga2V5KSB7XG4gIHtcbiAgICBpZiAodHlwZW9mIHBlbmRpbmdQcm9wcy5pZCAhPT0gJ3N0cmluZycpIHtcbiAgICAgIGVycm9yKCdQcm9maWxlciBtdXN0IHNwZWNpZnkgYW4gXCJpZFwiIGFzIGEgcHJvcCcpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBmaWJlciA9IGNyZWF0ZUZpYmVyKFByb2ZpbGVyLCBwZW5kaW5nUHJvcHMsIGtleSwgbW9kZSB8IFByb2ZpbGVNb2RlKTsgLy8gVE9ETzogVGhlIFByb2ZpbGVyIGZpYmVyIHNob3VsZG4ndCBoYXZlIGEgdHlwZS4gSXQgaGFzIGEgdGFnLlxuXG4gIGZpYmVyLmVsZW1lbnRUeXBlID0gUkVBQ1RfUFJPRklMRVJfVFlQRTtcbiAgZmliZXIudHlwZSA9IFJFQUNUX1BST0ZJTEVSX1RZUEU7XG4gIGZpYmVyLmxhbmVzID0gbGFuZXM7XG5cbiAge1xuICAgIGZpYmVyLnN0YXRlTm9kZSA9IHtcbiAgICAgIGVmZmVjdER1cmF0aW9uOiAwLFxuICAgICAgcGFzc2l2ZUVmZmVjdER1cmF0aW9uOiAwXG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiBmaWJlcjtcbn1cblxuZnVuY3Rpb24gY3JlYXRlRmliZXJGcm9tU3VzcGVuc2UocGVuZGluZ1Byb3BzLCBtb2RlLCBsYW5lcywga2V5KSB7XG4gIHZhciBmaWJlciA9IGNyZWF0ZUZpYmVyKFN1c3BlbnNlQ29tcG9uZW50LCBwZW5kaW5nUHJvcHMsIGtleSwgbW9kZSk7IC8vIFRPRE86IFRoZSBTdXNwZW5zZUNvbXBvbmVudCBmaWJlciBzaG91bGRuJ3QgaGF2ZSBhIHR5cGUuIEl0IGhhcyBhIHRhZy5cbiAgLy8gVGhpcyBuZWVkcyB0byBiZSBmaXhlZCBpbiBnZXRDb21wb25lbnROYW1lIHNvIHRoYXQgaXQgcmVsaWVzIG9uIHRoZSB0YWdcbiAgLy8gaW5zdGVhZC5cblxuICBmaWJlci50eXBlID0gUkVBQ1RfU1VTUEVOU0VfVFlQRTtcbiAgZmliZXIuZWxlbWVudFR5cGUgPSBSRUFDVF9TVVNQRU5TRV9UWVBFO1xuICBmaWJlci5sYW5lcyA9IGxhbmVzO1xuICByZXR1cm4gZmliZXI7XG59XG5mdW5jdGlvbiBjcmVhdGVGaWJlckZyb21TdXNwZW5zZUxpc3QocGVuZGluZ1Byb3BzLCBtb2RlLCBsYW5lcywga2V5KSB7XG4gIHZhciBmaWJlciA9IGNyZWF0ZUZpYmVyKFN1c3BlbnNlTGlzdENvbXBvbmVudCwgcGVuZGluZ1Byb3BzLCBrZXksIG1vZGUpO1xuXG4gIHtcbiAgICAvLyBUT0RPOiBUaGUgU3VzcGVuc2VMaXN0Q29tcG9uZW50IGZpYmVyIHNob3VsZG4ndCBoYXZlIGEgdHlwZS4gSXQgaGFzIGEgdGFnLlxuICAgIC8vIFRoaXMgbmVlZHMgdG8gYmUgZml4ZWQgaW4gZ2V0Q29tcG9uZW50TmFtZSBzbyB0aGF0IGl0IHJlbGllcyBvbiB0aGUgdGFnXG4gICAgLy8gaW5zdGVhZC5cbiAgICBmaWJlci50eXBlID0gUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFO1xuICB9XG5cbiAgZmliZXIuZWxlbWVudFR5cGUgPSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEU7XG4gIGZpYmVyLmxhbmVzID0gbGFuZXM7XG4gIHJldHVybiBmaWJlcjtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUZpYmVyRnJvbU9mZnNjcmVlbihwZW5kaW5nUHJvcHMsIG1vZGUsIGxhbmVzLCBrZXkpIHtcbiAgdmFyIGZpYmVyID0gY3JlYXRlRmliZXIoT2Zmc2NyZWVuQ29tcG9uZW50LCBwZW5kaW5nUHJvcHMsIGtleSwgbW9kZSk7IC8vIFRPRE86IFRoZSBPZmZzY3JlZW5Db21wb25lbnQgZmliZXIgc2hvdWxkbid0IGhhdmUgYSB0eXBlLiBJdCBoYXMgYSB0YWcuXG4gIC8vIFRoaXMgbmVlZHMgdG8gYmUgZml4ZWQgaW4gZ2V0Q29tcG9uZW50TmFtZSBzbyB0aGF0IGl0IHJlbGllcyBvbiB0aGUgdGFnXG4gIC8vIGluc3RlYWQuXG5cbiAge1xuICAgIGZpYmVyLnR5cGUgPSBSRUFDVF9PRkZTQ1JFRU5fVFlQRTtcbiAgfVxuXG4gIGZpYmVyLmVsZW1lbnRUeXBlID0gUkVBQ1RfT0ZGU0NSRUVOX1RZUEU7XG4gIGZpYmVyLmxhbmVzID0gbGFuZXM7XG4gIHJldHVybiBmaWJlcjtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUZpYmVyRnJvbUxlZ2FjeUhpZGRlbihwZW5kaW5nUHJvcHMsIG1vZGUsIGxhbmVzLCBrZXkpIHtcbiAgdmFyIGZpYmVyID0gY3JlYXRlRmliZXIoTGVnYWN5SGlkZGVuQ29tcG9uZW50LCBwZW5kaW5nUHJvcHMsIGtleSwgbW9kZSk7IC8vIFRPRE86IFRoZSBMZWdhY3lIaWRkZW4gZmliZXIgc2hvdWxkbid0IGhhdmUgYSB0eXBlLiBJdCBoYXMgYSB0YWcuXG4gIC8vIFRoaXMgbmVlZHMgdG8gYmUgZml4ZWQgaW4gZ2V0Q29tcG9uZW50TmFtZSBzbyB0aGF0IGl0IHJlbGllcyBvbiB0aGUgdGFnXG4gIC8vIGluc3RlYWQuXG5cbiAge1xuICAgIGZpYmVyLnR5cGUgPSBSRUFDVF9MRUdBQ1lfSElEREVOX1RZUEU7XG4gIH1cblxuICBmaWJlci5lbGVtZW50VHlwZSA9IFJFQUNUX0xFR0FDWV9ISURERU5fVFlQRTtcbiAgZmliZXIubGFuZXMgPSBsYW5lcztcbiAgcmV0dXJuIGZpYmVyO1xufVxuZnVuY3Rpb24gY3JlYXRlRmliZXJGcm9tVGV4dChjb250ZW50LCBtb2RlLCBsYW5lcykge1xuICB2YXIgZmliZXIgPSBjcmVhdGVGaWJlcihIb3N0VGV4dCwgY29udGVudCwgbnVsbCwgbW9kZSk7XG4gIGZpYmVyLmxhbmVzID0gbGFuZXM7XG4gIHJldHVybiBmaWJlcjtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUZpYmVyRnJvbUhvc3RJbnN0YW5jZUZvckRlbGV0aW9uKCkge1xuICB2YXIgZmliZXIgPSBjcmVhdGVGaWJlcihIb3N0Q29tcG9uZW50LCBudWxsLCBudWxsLCBOb01vZGUpOyAvLyBUT0RPOiBUaGVzZSBzaG91bGQgbm90IG5lZWQgYSB0eXBlLlxuXG4gIGZpYmVyLmVsZW1lbnRUeXBlID0gJ0RFTEVURUQnO1xuICBmaWJlci50eXBlID0gJ0RFTEVURUQnO1xuICByZXR1cm4gZmliZXI7XG59XG5mdW5jdGlvbiBjcmVhdGVGaWJlckZyb21Qb3J0YWwocG9ydGFsLCBtb2RlLCBsYW5lcykge1xuICB2YXIgcGVuZGluZ1Byb3BzID0gcG9ydGFsLmNoaWxkcmVuICE9PSBudWxsID8gcG9ydGFsLmNoaWxkcmVuIDogW107XG4gIHZhciBmaWJlciA9IGNyZWF0ZUZpYmVyKEhvc3RQb3J0YWwsIHBlbmRpbmdQcm9wcywgcG9ydGFsLmtleSwgbW9kZSk7XG4gIGZpYmVyLmxhbmVzID0gbGFuZXM7XG4gIGZpYmVyLnN0YXRlTm9kZSA9IHtcbiAgICBjb250YWluZXJJbmZvOiBwb3J0YWwuY29udGFpbmVySW5mbyxcbiAgICBwZW5kaW5nQ2hpbGRyZW46IG51bGwsXG4gICAgLy8gVXNlZCBieSBwZXJzaXN0ZW50IHVwZGF0ZXNcbiAgICBpbXBsZW1lbnRhdGlvbjogcG9ydGFsLmltcGxlbWVudGF0aW9uXG4gIH07XG4gIHJldHVybiBmaWJlcjtcbn0gLy8gVXNlZCBmb3Igc3Rhc2hpbmcgV0lQIHByb3BlcnRpZXMgdG8gcmVwbGF5IGZhaWxlZCB3b3JrIGluIERFVi5cblxuZnVuY3Rpb24gYXNzaWduRmliZXJQcm9wZXJ0aWVzSW5ERVYodGFyZ2V0LCBzb3VyY2UpIHtcbiAgaWYgKHRhcmdldCA9PT0gbnVsbCkge1xuICAgIC8vIFRoaXMgRmliZXIncyBpbml0aWFsIHByb3BlcnRpZXMgd2lsbCBhbHdheXMgYmUgb3ZlcndyaXR0ZW4uXG4gICAgLy8gV2Ugb25seSB1c2UgYSBGaWJlciB0byBlbnN1cmUgdGhlIHNhbWUgaGlkZGVuIGNsYXNzIHNvIERFViBpc24ndCBzbG93LlxuICAgIHRhcmdldCA9IGNyZWF0ZUZpYmVyKEluZGV0ZXJtaW5hdGVDb21wb25lbnQsIG51bGwsIG51bGwsIE5vTW9kZSk7XG4gIH0gLy8gVGhpcyBpcyBpbnRlbnRpb25hbGx5IHdyaXR0ZW4gYXMgYSBsaXN0IG9mIGFsbCBwcm9wZXJ0aWVzLlxuICAvLyBXZSB0cmllZCB0byB1c2UgT2JqZWN0LmFzc2lnbigpIGluc3RlYWQgYnV0IHRoaXMgaXMgY2FsbGVkIGluXG4gIC8vIHRoZSBob3R0ZXN0IHBhdGgsIGFuZCBPYmplY3QuYXNzaWduKCkgd2FzIHRvbyBzbG93OlxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzEyNTAyXG4gIC8vIFRoaXMgY29kZSBpcyBERVYtb25seSBzbyBzaXplIGlzIG5vdCBhIGNvbmNlcm4uXG5cblxuICB0YXJnZXQudGFnID0gc291cmNlLnRhZztcbiAgdGFyZ2V0LmtleSA9IHNvdXJjZS5rZXk7XG4gIHRhcmdldC5lbGVtZW50VHlwZSA9IHNvdXJjZS5lbGVtZW50VHlwZTtcbiAgdGFyZ2V0LnR5cGUgPSBzb3VyY2UudHlwZTtcbiAgdGFyZ2V0LnN0YXRlTm9kZSA9IHNvdXJjZS5zdGF0ZU5vZGU7XG4gIHRhcmdldC5yZXR1cm4gPSBzb3VyY2UucmV0dXJuO1xuICB0YXJnZXQuY2hpbGQgPSBzb3VyY2UuY2hpbGQ7XG4gIHRhcmdldC5zaWJsaW5nID0gc291cmNlLnNpYmxpbmc7XG4gIHRhcmdldC5pbmRleCA9IHNvdXJjZS5pbmRleDtcbiAgdGFyZ2V0LnJlZiA9IHNvdXJjZS5yZWY7XG4gIHRhcmdldC5wZW5kaW5nUHJvcHMgPSBzb3VyY2UucGVuZGluZ1Byb3BzO1xuICB0YXJnZXQubWVtb2l6ZWRQcm9wcyA9IHNvdXJjZS5tZW1vaXplZFByb3BzO1xuICB0YXJnZXQudXBkYXRlUXVldWUgPSBzb3VyY2UudXBkYXRlUXVldWU7XG4gIHRhcmdldC5tZW1vaXplZFN0YXRlID0gc291cmNlLm1lbW9pemVkU3RhdGU7XG4gIHRhcmdldC5kZXBlbmRlbmNpZXMgPSBzb3VyY2UuZGVwZW5kZW5jaWVzO1xuICB0YXJnZXQubW9kZSA9IHNvdXJjZS5tb2RlO1xuICB0YXJnZXQuZmxhZ3MgPSBzb3VyY2UuZmxhZ3M7XG4gIHRhcmdldC5uZXh0RWZmZWN0ID0gc291cmNlLm5leHRFZmZlY3Q7XG4gIHRhcmdldC5maXJzdEVmZmVjdCA9IHNvdXJjZS5maXJzdEVmZmVjdDtcbiAgdGFyZ2V0Lmxhc3RFZmZlY3QgPSBzb3VyY2UubGFzdEVmZmVjdDtcbiAgdGFyZ2V0LmxhbmVzID0gc291cmNlLmxhbmVzO1xuICB0YXJnZXQuY2hpbGRMYW5lcyA9IHNvdXJjZS5jaGlsZExhbmVzO1xuICB0YXJnZXQuYWx0ZXJuYXRlID0gc291cmNlLmFsdGVybmF0ZTtcblxuICB7XG4gICAgdGFyZ2V0LmFjdHVhbER1cmF0aW9uID0gc291cmNlLmFjdHVhbER1cmF0aW9uO1xuICAgIHRhcmdldC5hY3R1YWxTdGFydFRpbWUgPSBzb3VyY2UuYWN0dWFsU3RhcnRUaW1lO1xuICAgIHRhcmdldC5zZWxmQmFzZUR1cmF0aW9uID0gc291cmNlLnNlbGZCYXNlRHVyYXRpb247XG4gICAgdGFyZ2V0LnRyZWVCYXNlRHVyYXRpb24gPSBzb3VyY2UudHJlZUJhc2VEdXJhdGlvbjtcbiAgfVxuXG4gIHRhcmdldC5fZGVidWdJRCA9IHNvdXJjZS5fZGVidWdJRDtcbiAgdGFyZ2V0Ll9kZWJ1Z1NvdXJjZSA9IHNvdXJjZS5fZGVidWdTb3VyY2U7XG4gIHRhcmdldC5fZGVidWdPd25lciA9IHNvdXJjZS5fZGVidWdPd25lcjtcbiAgdGFyZ2V0Ll9kZWJ1Z05lZWRzUmVtb3VudCA9IHNvdXJjZS5fZGVidWdOZWVkc1JlbW91bnQ7XG4gIHRhcmdldC5fZGVidWdIb29rVHlwZXMgPSBzb3VyY2UuX2RlYnVnSG9va1R5cGVzO1xuICByZXR1cm4gdGFyZ2V0O1xufVxuXG5mdW5jdGlvbiBGaWJlclJvb3ROb2RlKGNvbnRhaW5lckluZm8sIHRhZywgaHlkcmF0ZSkge1xuICB0aGlzLnRhZyA9IHRhZztcbiAgdGhpcy5jb250YWluZXJJbmZvID0gY29udGFpbmVySW5mbztcbiAgdGhpcy5wZW5kaW5nQ2hpbGRyZW4gPSBudWxsO1xuICB0aGlzLmN1cnJlbnQgPSBudWxsO1xuICB0aGlzLnBpbmdDYWNoZSA9IG51bGw7XG4gIHRoaXMuZmluaXNoZWRXb3JrID0gbnVsbDtcbiAgdGhpcy50aW1lb3V0SGFuZGxlID0gbm9UaW1lb3V0O1xuICB0aGlzLmNvbnRleHQgPSBudWxsO1xuICB0aGlzLnBlbmRpbmdDb250ZXh0ID0gbnVsbDtcbiAgdGhpcy5oeWRyYXRlID0gaHlkcmF0ZTtcbiAgdGhpcy5jYWxsYmFja05vZGUgPSBudWxsO1xuICB0aGlzLmNhbGxiYWNrUHJpb3JpdHkgPSBOb0xhbmVQcmlvcml0eTtcbiAgdGhpcy5ldmVudFRpbWVzID0gY3JlYXRlTGFuZU1hcChOb0xhbmVzKTtcbiAgdGhpcy5leHBpcmF0aW9uVGltZXMgPSBjcmVhdGVMYW5lTWFwKE5vVGltZXN0YW1wKTtcbiAgdGhpcy5wZW5kaW5nTGFuZXMgPSBOb0xhbmVzO1xuICB0aGlzLnN1c3BlbmRlZExhbmVzID0gTm9MYW5lcztcbiAgdGhpcy5waW5nZWRMYW5lcyA9IE5vTGFuZXM7XG4gIHRoaXMuZXhwaXJlZExhbmVzID0gTm9MYW5lcztcbiAgdGhpcy5tdXRhYmxlUmVhZExhbmVzID0gTm9MYW5lcztcbiAgdGhpcy5maW5pc2hlZExhbmVzID0gTm9MYW5lcztcbiAgdGhpcy5lbnRhbmdsZWRMYW5lcyA9IE5vTGFuZXM7XG4gIHRoaXMuZW50YW5nbGVtZW50cyA9IGNyZWF0ZUxhbmVNYXAoTm9MYW5lcyk7XG5cbiAge1xuICAgIHRoaXMubXV0YWJsZVNvdXJjZUVhZ2VySHlkcmF0aW9uRGF0YSA9IG51bGw7XG4gIH1cblxuICB7XG4gICAgdGhpcy5pbnRlcmFjdGlvblRocmVhZElEID0gdHJhY2luZy51bnN0YWJsZV9nZXRUaHJlYWRJRCgpO1xuICAgIHRoaXMubWVtb2l6ZWRJbnRlcmFjdGlvbnMgPSBuZXcgU2V0KCk7XG4gICAgdGhpcy5wZW5kaW5nSW50ZXJhY3Rpb25NYXAgPSBuZXcgTWFwKCk7XG4gIH1cblxuICB7XG4gICAgc3dpdGNoICh0YWcpIHtcbiAgICAgIGNhc2UgQmxvY2tpbmdSb290OlxuICAgICAgICB0aGlzLl9kZWJ1Z1Jvb3RUeXBlID0gJ2NyZWF0ZUJsb2NraW5nUm9vdCgpJztcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgQ29uY3VycmVudFJvb3Q6XG4gICAgICAgIHRoaXMuX2RlYnVnUm9vdFR5cGUgPSAnY3JlYXRlUm9vdCgpJztcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgTGVnYWN5Um9vdDpcbiAgICAgICAgdGhpcy5fZGVidWdSb290VHlwZSA9ICdjcmVhdGVMZWdhY3lSb290KCknO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlRmliZXJSb290KGNvbnRhaW5lckluZm8sIHRhZywgaHlkcmF0ZSwgaHlkcmF0aW9uQ2FsbGJhY2tzKSB7XG4gIHZhciByb290ID0gbmV3IEZpYmVyUm9vdE5vZGUoY29udGFpbmVySW5mbywgdGFnLCBoeWRyYXRlKTtcbiAgLy8gc3RhdGVOb2RlIGlzIGFueS5cblxuXG4gIHZhciB1bmluaXRpYWxpemVkRmliZXIgPSBjcmVhdGVIb3N0Um9vdEZpYmVyKHRhZyk7XG4gIHJvb3QuY3VycmVudCA9IHVuaW5pdGlhbGl6ZWRGaWJlcjtcbiAgdW5pbml0aWFsaXplZEZpYmVyLnN0YXRlTm9kZSA9IHJvb3Q7XG4gIGluaXRpYWxpemVVcGRhdGVRdWV1ZSh1bmluaXRpYWxpemVkRmliZXIpO1xuICByZXR1cm4gcm9vdDtcbn1cblxuLy8gVGhpcyBlbnN1cmVzIHRoYXQgdGhlIHZlcnNpb24gdXNlZCBmb3Igc2VydmVyIHJlbmRlcmluZyBtYXRjaGVzIHRoZSBvbmVcbi8vIHRoYXQgaXMgZXZlbnR1YWxseSByZWFkIGR1cmluZyBoeWRyYXRpb24uXG4vLyBJZiB0aGV5IGRvbid0IG1hdGNoIHRoZXJlJ3MgYSBwb3RlbnRpYWwgdGVhciBhbmQgYSBmdWxsIGRlb3B0IHJlbmRlciBpcyByZXF1aXJlZC5cblxuZnVuY3Rpb24gcmVnaXN0ZXJNdXRhYmxlU291cmNlRm9ySHlkcmF0aW9uKHJvb3QsIG11dGFibGVTb3VyY2UpIHtcbiAgdmFyIGdldFZlcnNpb24gPSBtdXRhYmxlU291cmNlLl9nZXRWZXJzaW9uO1xuICB2YXIgdmVyc2lvbiA9IGdldFZlcnNpb24obXV0YWJsZVNvdXJjZS5fc291cmNlKTsgLy8gVE9ETyBDbGVhciB0aGlzIGRhdGEgb25jZSBhbGwgcGVuZGluZyBoeWRyYXRpb24gd29yayBpcyBmaW5pc2hlZC5cbiAgLy8gUmV0YWluaW5nIGl0IGZvcmV2ZXIgbWF5IGludGVyZmVyZSB3aXRoIEdDLlxuXG4gIGlmIChyb290Lm11dGFibGVTb3VyY2VFYWdlckh5ZHJhdGlvbkRhdGEgPT0gbnVsbCkge1xuICAgIHJvb3QubXV0YWJsZVNvdXJjZUVhZ2VySHlkcmF0aW9uRGF0YSA9IFttdXRhYmxlU291cmNlLCB2ZXJzaW9uXTtcbiAgfSBlbHNlIHtcbiAgICByb290Lm11dGFibGVTb3VyY2VFYWdlckh5ZHJhdGlvbkRhdGEucHVzaChtdXRhYmxlU291cmNlLCB2ZXJzaW9uKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVQb3J0YWwoY2hpbGRyZW4sIGNvbnRhaW5lckluZm8sIC8vIFRPRE86IGZpZ3VyZSBvdXQgdGhlIEFQSSBmb3IgY3Jvc3MtcmVuZGVyZXIgaW1wbGVtZW50YXRpb24uXG5pbXBsZW1lbnRhdGlvbikge1xuICB2YXIga2V5ID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiBudWxsO1xuICByZXR1cm4ge1xuICAgIC8vIFRoaXMgdGFnIGFsbG93IHVzIHRvIHVuaXF1ZWx5IGlkZW50aWZ5IHRoaXMgYXMgYSBSZWFjdCBQb3J0YWxcbiAgICAkJHR5cGVvZjogUkVBQ1RfUE9SVEFMX1RZUEUsXG4gICAga2V5OiBrZXkgPT0gbnVsbCA/IG51bGwgOiAnJyArIGtleSxcbiAgICBjaGlsZHJlbjogY2hpbGRyZW4sXG4gICAgY29udGFpbmVySW5mbzogY29udGFpbmVySW5mbyxcbiAgICBpbXBsZW1lbnRhdGlvbjogaW1wbGVtZW50YXRpb25cbiAgfTtcbn1cblxudmFyIGRpZFdhcm5BYm91dE5lc3RlZFVwZGF0ZXM7XG52YXIgZGlkV2FybkFib3V0RmluZE5vZGVJblN0cmljdE1vZGU7XG5cbntcbiAgZGlkV2FybkFib3V0TmVzdGVkVXBkYXRlcyA9IGZhbHNlO1xuICBkaWRXYXJuQWJvdXRGaW5kTm9kZUluU3RyaWN0TW9kZSA9IHt9O1xufVxuXG5mdW5jdGlvbiBnZXRDb250ZXh0Rm9yU3VidHJlZShwYXJlbnRDb21wb25lbnQpIHtcbiAgaWYgKCFwYXJlbnRDb21wb25lbnQpIHtcbiAgICByZXR1cm4gZW1wdHlDb250ZXh0T2JqZWN0O1xuICB9XG5cbiAgdmFyIGZpYmVyID0gZ2V0KHBhcmVudENvbXBvbmVudCk7XG4gIHZhciBwYXJlbnRDb250ZXh0ID0gZmluZEN1cnJlbnRVbm1hc2tlZENvbnRleHQoZmliZXIpO1xuXG4gIGlmIChmaWJlci50YWcgPT09IENsYXNzQ29tcG9uZW50KSB7XG4gICAgdmFyIENvbXBvbmVudCA9IGZpYmVyLnR5cGU7XG5cbiAgICBpZiAoaXNDb250ZXh0UHJvdmlkZXIoQ29tcG9uZW50KSkge1xuICAgICAgcmV0dXJuIHByb2Nlc3NDaGlsZENvbnRleHQoZmliZXIsIENvbXBvbmVudCwgcGFyZW50Q29udGV4dCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHBhcmVudENvbnRleHQ7XG59XG5cbmZ1bmN0aW9uIGZpbmRIb3N0SW5zdGFuY2VXaXRoV2FybmluZyhjb21wb25lbnQsIG1ldGhvZE5hbWUpIHtcbiAge1xuICAgIHZhciBmaWJlciA9IGdldChjb21wb25lbnQpO1xuXG4gICAgaWYgKGZpYmVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmICh0eXBlb2YgY29tcG9uZW50LnJlbmRlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB7XG4gICAgICAgICAge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoIFwiVW5hYmxlIHRvIGZpbmQgbm9kZSBvbiBhbiB1bm1vdW50ZWQgY29tcG9uZW50LlwiICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB7XG4gICAgICAgICAge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoIFwiQXJndW1lbnQgYXBwZWFycyB0byBub3QgYmUgYSBSZWFjdENvbXBvbmVudC4gS2V5czogXCIgKyBPYmplY3Qua2V5cyhjb21wb25lbnQpICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGhvc3RGaWJlciA9IGZpbmRDdXJyZW50SG9zdEZpYmVyKGZpYmVyKTtcblxuICAgIGlmIChob3N0RmliZXIgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGlmIChob3N0RmliZXIubW9kZSAmIFN0cmljdE1vZGUpIHtcbiAgICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZShmaWJlci50eXBlKSB8fCAnQ29tcG9uZW50JztcblxuICAgICAgaWYgKCFkaWRXYXJuQWJvdXRGaW5kTm9kZUluU3RyaWN0TW9kZVtjb21wb25lbnROYW1lXSkge1xuICAgICAgICBkaWRXYXJuQWJvdXRGaW5kTm9kZUluU3RyaWN0TW9kZVtjb21wb25lbnROYW1lXSA9IHRydWU7XG4gICAgICAgIHZhciBwcmV2aW91c0ZpYmVyID0gY3VycmVudDtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgIHNldEN1cnJlbnRGaWJlcihob3N0RmliZXIpO1xuXG4gICAgICAgICAgaWYgKGZpYmVyLm1vZGUgJiBTdHJpY3RNb2RlKSB7XG4gICAgICAgICAgICBlcnJvcignJXMgaXMgZGVwcmVjYXRlZCBpbiBTdHJpY3RNb2RlLiAnICsgJyVzIHdhcyBwYXNzZWQgYW4gaW5zdGFuY2Ugb2YgJXMgd2hpY2ggaXMgaW5zaWRlIFN0cmljdE1vZGUuICcgKyAnSW5zdGVhZCwgYWRkIGEgcmVmIGRpcmVjdGx5IHRvIHRoZSBlbGVtZW50IHlvdSB3YW50IHRvIHJlZmVyZW5jZS4gJyArICdMZWFybiBtb3JlIGFib3V0IHVzaW5nIHJlZnMgc2FmZWx5IGhlcmU6ICcgKyAnaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3N0cmljdC1tb2RlLWZpbmQtbm9kZScsIG1ldGhvZE5hbWUsIG1ldGhvZE5hbWUsIGNvbXBvbmVudE5hbWUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlcnJvcignJXMgaXMgZGVwcmVjYXRlZCBpbiBTdHJpY3RNb2RlLiAnICsgJyVzIHdhcyBwYXNzZWQgYW4gaW5zdGFuY2Ugb2YgJXMgd2hpY2ggcmVuZGVycyBTdHJpY3RNb2RlIGNoaWxkcmVuLiAnICsgJ0luc3RlYWQsIGFkZCBhIHJlZiBkaXJlY3RseSB0byB0aGUgZWxlbWVudCB5b3Ugd2FudCB0byByZWZlcmVuY2UuICcgKyAnTGVhcm4gbW9yZSBhYm91dCB1c2luZyByZWZzIHNhZmVseSBoZXJlOiAnICsgJ2h0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9zdHJpY3QtbW9kZS1maW5kLW5vZGUnLCBtZXRob2ROYW1lLCBtZXRob2ROYW1lLCBjb21wb25lbnROYW1lKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgLy8gSWRlYWxseSB0aGlzIHNob3VsZCByZXNldCB0byBwcmV2aW91cyBidXQgdGhpcyBzaG91bGRuJ3QgYmUgY2FsbGVkIGluXG4gICAgICAgICAgLy8gcmVuZGVyIGFuZCB0aGVyZSdzIGFub3RoZXIgd2FybmluZyBmb3IgdGhhdCBhbnl3YXkuXG4gICAgICAgICAgaWYgKHByZXZpb3VzRmliZXIpIHtcbiAgICAgICAgICAgIHNldEN1cnJlbnRGaWJlcihwcmV2aW91c0ZpYmVyKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzZXRDdXJyZW50RmliZXIoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gaG9zdEZpYmVyLnN0YXRlTm9kZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVDb250YWluZXIoY29udGFpbmVySW5mbywgdGFnLCBoeWRyYXRlLCBoeWRyYXRpb25DYWxsYmFja3MpIHtcbiAgcmV0dXJuIGNyZWF0ZUZpYmVyUm9vdChjb250YWluZXJJbmZvLCB0YWcsIGh5ZHJhdGUpO1xufVxuZnVuY3Rpb24gdXBkYXRlQ29udGFpbmVyKGVsZW1lbnQsIGNvbnRhaW5lciwgcGFyZW50Q29tcG9uZW50LCBjYWxsYmFjaykge1xuICB7XG4gICAgb25TY2hlZHVsZVJvb3QoY29udGFpbmVyLCBlbGVtZW50KTtcbiAgfVxuXG4gIHZhciBjdXJyZW50JDEgPSBjb250YWluZXIuY3VycmVudDtcbiAgdmFyIGV2ZW50VGltZSA9IHJlcXVlc3RFdmVudFRpbWUoKTtcblxuICB7XG4gICAgLy8gJEZsb3dFeHBlY3RlZEVycm9yIC0gamVzdCBpc24ndCBhIGdsb2JhbCwgYW5kIGlzbid0IHJlY29nbml6ZWQgb3V0c2lkZSBvZiB0ZXN0c1xuICAgIGlmICgndW5kZWZpbmVkJyAhPT0gdHlwZW9mIGplc3QpIHtcbiAgICAgIHdhcm5JZlVubW9ja2VkU2NoZWR1bGVyKGN1cnJlbnQkMSk7XG4gICAgICB3YXJuSWZOb3RTY29wZWRXaXRoTWF0Y2hpbmdBY3QoY3VycmVudCQxKTtcbiAgICB9XG4gIH1cblxuICB2YXIgbGFuZSA9IHJlcXVlc3RVcGRhdGVMYW5lKGN1cnJlbnQkMSk7XG5cbiAgdmFyIGNvbnRleHQgPSBnZXRDb250ZXh0Rm9yU3VidHJlZShwYXJlbnRDb21wb25lbnQpO1xuXG4gIGlmIChjb250YWluZXIuY29udGV4dCA9PT0gbnVsbCkge1xuICAgIGNvbnRhaW5lci5jb250ZXh0ID0gY29udGV4dDtcbiAgfSBlbHNlIHtcbiAgICBjb250YWluZXIucGVuZGluZ0NvbnRleHQgPSBjb250ZXh0O1xuICB9XG5cbiAge1xuICAgIGlmIChpc1JlbmRlcmluZyAmJiBjdXJyZW50ICE9PSBudWxsICYmICFkaWRXYXJuQWJvdXROZXN0ZWRVcGRhdGVzKSB7XG4gICAgICBkaWRXYXJuQWJvdXROZXN0ZWRVcGRhdGVzID0gdHJ1ZTtcblxuICAgICAgZXJyb3IoJ1JlbmRlciBtZXRob2RzIHNob3VsZCBiZSBhIHB1cmUgZnVuY3Rpb24gb2YgcHJvcHMgYW5kIHN0YXRlOyAnICsgJ3RyaWdnZXJpbmcgbmVzdGVkIGNvbXBvbmVudCB1cGRhdGVzIGZyb20gcmVuZGVyIGlzIG5vdCBhbGxvd2VkLiAnICsgJ0lmIG5lY2Vzc2FyeSwgdHJpZ2dlciBuZXN0ZWQgdXBkYXRlcyBpbiBjb21wb25lbnREaWRVcGRhdGUuXFxuXFxuJyArICdDaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiAlcy4nLCBnZXRDb21wb25lbnROYW1lKGN1cnJlbnQudHlwZSkgfHwgJ1Vua25vd24nKTtcbiAgICB9XG4gIH1cblxuICB2YXIgdXBkYXRlID0gY3JlYXRlVXBkYXRlKGV2ZW50VGltZSwgbGFuZSk7IC8vIENhdXRpb246IFJlYWN0IERldlRvb2xzIGN1cnJlbnRseSBkZXBlbmRzIG9uIHRoaXMgcHJvcGVydHlcbiAgLy8gYmVpbmcgY2FsbGVkIFwiZWxlbWVudFwiLlxuXG4gIHVwZGF0ZS5wYXlsb2FkID0ge1xuICAgIGVsZW1lbnQ6IGVsZW1lbnRcbiAgfTtcbiAgY2FsbGJhY2sgPSBjYWxsYmFjayA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IGNhbGxiYWNrO1xuXG4gIGlmIChjYWxsYmFjayAhPT0gbnVsbCkge1xuICAgIHtcbiAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgZXJyb3IoJ3JlbmRlciguLi4pOiBFeHBlY3RlZCB0aGUgbGFzdCBvcHRpb25hbCBgY2FsbGJhY2tgIGFyZ3VtZW50IHRvIGJlIGEgJyArICdmdW5jdGlvbi4gSW5zdGVhZCByZWNlaXZlZDogJXMuJywgY2FsbGJhY2spO1xuICAgICAgfVxuICAgIH1cblxuICAgIHVwZGF0ZS5jYWxsYmFjayA9IGNhbGxiYWNrO1xuICB9XG5cbiAgZW5xdWV1ZVVwZGF0ZShjdXJyZW50JDEsIHVwZGF0ZSk7XG4gIHNjaGVkdWxlVXBkYXRlT25GaWJlcihjdXJyZW50JDEsIGxhbmUsIGV2ZW50VGltZSk7XG4gIHJldHVybiBsYW5lO1xufVxuZnVuY3Rpb24gZ2V0UHVibGljUm9vdEluc3RhbmNlKGNvbnRhaW5lcikge1xuICB2YXIgY29udGFpbmVyRmliZXIgPSBjb250YWluZXIuY3VycmVudDtcblxuICBpZiAoIWNvbnRhaW5lckZpYmVyLmNoaWxkKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBzd2l0Y2ggKGNvbnRhaW5lckZpYmVyLmNoaWxkLnRhZykge1xuICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICAgIHJldHVybiBnZXRQdWJsaWNJbnN0YW5jZShjb250YWluZXJGaWJlci5jaGlsZC5zdGF0ZU5vZGUpO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBjb250YWluZXJGaWJlci5jaGlsZC5zdGF0ZU5vZGU7XG4gIH1cbn1cblxuZnVuY3Rpb24gbWFya1JldHJ5TGFuZUltcGwoZmliZXIsIHJldHJ5TGFuZSkge1xuICB2YXIgc3VzcGVuc2VTdGF0ZSA9IGZpYmVyLm1lbW9pemVkU3RhdGU7XG5cbiAgaWYgKHN1c3BlbnNlU3RhdGUgIT09IG51bGwgJiYgc3VzcGVuc2VTdGF0ZS5kZWh5ZHJhdGVkICE9PSBudWxsKSB7XG4gICAgc3VzcGVuc2VTdGF0ZS5yZXRyeUxhbmUgPSBoaWdoZXJQcmlvcml0eUxhbmUoc3VzcGVuc2VTdGF0ZS5yZXRyeUxhbmUsIHJldHJ5TGFuZSk7XG4gIH1cbn0gLy8gSW5jcmVhc2VzIHRoZSBwcmlvcml0eSBvZiB0aGVubmFibGVzIHdoZW4gdGhleSByZXNvbHZlIHdpdGhpbiB0aGlzIGJvdW5kYXJ5LlxuXG5cbmZ1bmN0aW9uIG1hcmtSZXRyeUxhbmVJZk5vdEh5ZHJhdGVkKGZpYmVyLCByZXRyeUxhbmUpIHtcbiAgbWFya1JldHJ5TGFuZUltcGwoZmliZXIsIHJldHJ5TGFuZSk7XG4gIHZhciBhbHRlcm5hdGUgPSBmaWJlci5hbHRlcm5hdGU7XG5cbiAgaWYgKGFsdGVybmF0ZSkge1xuICAgIG1hcmtSZXRyeUxhbmVJbXBsKGFsdGVybmF0ZSwgcmV0cnlMYW5lKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBhdHRlbXB0VXNlckJsb2NraW5nSHlkcmF0aW9uJDEoZmliZXIpIHtcbiAgaWYgKGZpYmVyLnRhZyAhPT0gU3VzcGVuc2VDb21wb25lbnQpIHtcbiAgICAvLyBXZSBpZ25vcmUgSG9zdFJvb3RzIGhlcmUgYmVjYXVzZSB3ZSBjYW4ndCBpbmNyZWFzZVxuICAgIC8vIHRoZWlyIHByaW9yaXR5IGFuZCB0aGV5IHNob3VsZCBub3Qgc3VzcGVuZCBvbiBJL08sXG4gICAgLy8gc2luY2UgeW91IGhhdmUgdG8gd3JhcCBhbnl0aGluZyB0aGF0IG1pZ2h0IHN1c3BlbmQgaW5cbiAgICAvLyBTdXNwZW5zZS5cbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgZXZlbnRUaW1lID0gcmVxdWVzdEV2ZW50VGltZSgpO1xuICB2YXIgbGFuZSA9IElucHV0RGlzY3JldGVIeWRyYXRpb25MYW5lO1xuICBzY2hlZHVsZVVwZGF0ZU9uRmliZXIoZmliZXIsIGxhbmUsIGV2ZW50VGltZSk7XG4gIG1hcmtSZXRyeUxhbmVJZk5vdEh5ZHJhdGVkKGZpYmVyLCBsYW5lKTtcbn1cbmZ1bmN0aW9uIGF0dGVtcHRDb250aW51b3VzSHlkcmF0aW9uJDEoZmliZXIpIHtcbiAgaWYgKGZpYmVyLnRhZyAhPT0gU3VzcGVuc2VDb21wb25lbnQpIHtcbiAgICAvLyBXZSBpZ25vcmUgSG9zdFJvb3RzIGhlcmUgYmVjYXVzZSB3ZSBjYW4ndCBpbmNyZWFzZVxuICAgIC8vIHRoZWlyIHByaW9yaXR5IGFuZCB0aGV5IHNob3VsZCBub3Qgc3VzcGVuZCBvbiBJL08sXG4gICAgLy8gc2luY2UgeW91IGhhdmUgdG8gd3JhcCBhbnl0aGluZyB0aGF0IG1pZ2h0IHN1c3BlbmQgaW5cbiAgICAvLyBTdXNwZW5zZS5cbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgZXZlbnRUaW1lID0gcmVxdWVzdEV2ZW50VGltZSgpO1xuICB2YXIgbGFuZSA9IFNlbGVjdGl2ZUh5ZHJhdGlvbkxhbmU7XG4gIHNjaGVkdWxlVXBkYXRlT25GaWJlcihmaWJlciwgbGFuZSwgZXZlbnRUaW1lKTtcbiAgbWFya1JldHJ5TGFuZUlmTm90SHlkcmF0ZWQoZmliZXIsIGxhbmUpO1xufVxuZnVuY3Rpb24gYXR0ZW1wdEh5ZHJhdGlvbkF0Q3VycmVudFByaW9yaXR5JDEoZmliZXIpIHtcbiAgaWYgKGZpYmVyLnRhZyAhPT0gU3VzcGVuc2VDb21wb25lbnQpIHtcbiAgICAvLyBXZSBpZ25vcmUgSG9zdFJvb3RzIGhlcmUgYmVjYXVzZSB3ZSBjYW4ndCBpbmNyZWFzZVxuICAgIC8vIHRoZWlyIHByaW9yaXR5IG90aGVyIHRoYW4gc3luY2hyb25vdXNseSBmbHVzaCBpdC5cbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgZXZlbnRUaW1lID0gcmVxdWVzdEV2ZW50VGltZSgpO1xuICB2YXIgbGFuZSA9IHJlcXVlc3RVcGRhdGVMYW5lKGZpYmVyKTtcbiAgc2NoZWR1bGVVcGRhdGVPbkZpYmVyKGZpYmVyLCBsYW5lLCBldmVudFRpbWUpO1xuICBtYXJrUmV0cnlMYW5lSWZOb3RIeWRyYXRlZChmaWJlciwgbGFuZSk7XG59XG5mdW5jdGlvbiBydW5XaXRoUHJpb3JpdHkkMihwcmlvcml0eSwgZm4pIHtcblxuICB0cnkge1xuICAgIHNldEN1cnJlbnRVcGRhdGVMYW5lUHJpb3JpdHkocHJpb3JpdHkpO1xuICAgIHJldHVybiBmbigpO1xuICB9IGZpbmFsbHkge1xuICB9XG59XG5mdW5jdGlvbiBmaW5kSG9zdEluc3RhbmNlV2l0aE5vUG9ydGFscyhmaWJlcikge1xuICB2YXIgaG9zdEZpYmVyID0gZmluZEN1cnJlbnRIb3N0RmliZXJXaXRoTm9Qb3J0YWxzKGZpYmVyKTtcblxuICBpZiAoaG9zdEZpYmVyID09PSBudWxsKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBpZiAoaG9zdEZpYmVyLnRhZyA9PT0gRnVuZGFtZW50YWxDb21wb25lbnQpIHtcbiAgICByZXR1cm4gaG9zdEZpYmVyLnN0YXRlTm9kZS5pbnN0YW5jZTtcbiAgfVxuXG4gIHJldHVybiBob3N0RmliZXIuc3RhdGVOb2RlO1xufVxuXG52YXIgc2hvdWxkU3VzcGVuZEltcGwgPSBmdW5jdGlvbiAoZmliZXIpIHtcbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuZnVuY3Rpb24gc2hvdWxkU3VzcGVuZChmaWJlcikge1xuICByZXR1cm4gc2hvdWxkU3VzcGVuZEltcGwoZmliZXIpO1xufVxudmFyIG92ZXJyaWRlSG9va1N0YXRlID0gbnVsbDtcbnZhciBvdmVycmlkZUhvb2tTdGF0ZURlbGV0ZVBhdGggPSBudWxsO1xudmFyIG92ZXJyaWRlSG9va1N0YXRlUmVuYW1lUGF0aCA9IG51bGw7XG52YXIgb3ZlcnJpZGVQcm9wcyA9IG51bGw7XG52YXIgb3ZlcnJpZGVQcm9wc0RlbGV0ZVBhdGggPSBudWxsO1xudmFyIG92ZXJyaWRlUHJvcHNSZW5hbWVQYXRoID0gbnVsbDtcbnZhciBzY2hlZHVsZVVwZGF0ZSA9IG51bGw7XG52YXIgc2V0U3VzcGVuc2VIYW5kbGVyID0gbnVsbDtcblxue1xuICB2YXIgY29weVdpdGhEZWxldGVJbXBsID0gZnVuY3Rpb24gKG9iaiwgcGF0aCwgaW5kZXgpIHtcbiAgICB2YXIga2V5ID0gcGF0aFtpbmRleF07XG4gICAgdmFyIHVwZGF0ZWQgPSBBcnJheS5pc0FycmF5KG9iaikgPyBvYmouc2xpY2UoKSA6IF9hc3NpZ24oe30sIG9iaik7XG5cbiAgICBpZiAoaW5kZXggKyAxID09PSBwYXRoLmxlbmd0aCkge1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkodXBkYXRlZCkpIHtcbiAgICAgICAgdXBkYXRlZC5zcGxpY2Uoa2V5LCAxKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlbGV0ZSB1cGRhdGVkW2tleV07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB1cGRhdGVkO1xuICAgIH0gLy8gJEZsb3dGaXhNZSBudW1iZXIgb3Igc3RyaW5nIGlzIGZpbmUgaGVyZVxuXG5cbiAgICB1cGRhdGVkW2tleV0gPSBjb3B5V2l0aERlbGV0ZUltcGwob2JqW2tleV0sIHBhdGgsIGluZGV4ICsgMSk7XG4gICAgcmV0dXJuIHVwZGF0ZWQ7XG4gIH07XG5cbiAgdmFyIGNvcHlXaXRoRGVsZXRlID0gZnVuY3Rpb24gKG9iaiwgcGF0aCkge1xuICAgIHJldHVybiBjb3B5V2l0aERlbGV0ZUltcGwob2JqLCBwYXRoLCAwKTtcbiAgfTtcblxuICB2YXIgY29weVdpdGhSZW5hbWVJbXBsID0gZnVuY3Rpb24gKG9iaiwgb2xkUGF0aCwgbmV3UGF0aCwgaW5kZXgpIHtcbiAgICB2YXIgb2xkS2V5ID0gb2xkUGF0aFtpbmRleF07XG4gICAgdmFyIHVwZGF0ZWQgPSBBcnJheS5pc0FycmF5KG9iaikgPyBvYmouc2xpY2UoKSA6IF9hc3NpZ24oe30sIG9iaik7XG5cbiAgICBpZiAoaW5kZXggKyAxID09PSBvbGRQYXRoLmxlbmd0aCkge1xuICAgICAgdmFyIG5ld0tleSA9IG5ld1BhdGhbaW5kZXhdOyAvLyAkRmxvd0ZpeE1lIG51bWJlciBvciBzdHJpbmcgaXMgZmluZSBoZXJlXG5cbiAgICAgIHVwZGF0ZWRbbmV3S2V5XSA9IHVwZGF0ZWRbb2xkS2V5XTtcblxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkodXBkYXRlZCkpIHtcbiAgICAgICAgdXBkYXRlZC5zcGxpY2Uob2xkS2V5LCAxKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlbGV0ZSB1cGRhdGVkW29sZEtleV07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vICRGbG93Rml4TWUgbnVtYmVyIG9yIHN0cmluZyBpcyBmaW5lIGhlcmVcbiAgICAgIHVwZGF0ZWRbb2xkS2V5XSA9IGNvcHlXaXRoUmVuYW1lSW1wbCggLy8gJEZsb3dGaXhNZSBudW1iZXIgb3Igc3RyaW5nIGlzIGZpbmUgaGVyZVxuICAgICAgb2JqW29sZEtleV0sIG9sZFBhdGgsIG5ld1BhdGgsIGluZGV4ICsgMSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHVwZGF0ZWQ7XG4gIH07XG5cbiAgdmFyIGNvcHlXaXRoUmVuYW1lID0gZnVuY3Rpb24gKG9iaiwgb2xkUGF0aCwgbmV3UGF0aCkge1xuICAgIGlmIChvbGRQYXRoLmxlbmd0aCAhPT0gbmV3UGF0aC5sZW5ndGgpIHtcbiAgICAgIHdhcm4oJ2NvcHlXaXRoUmVuYW1lKCkgZXhwZWN0cyBwYXRocyBvZiB0aGUgc2FtZSBsZW5ndGgnKTtcblxuICAgICAgcmV0dXJuO1xuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5ld1BhdGgubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgIGlmIChvbGRQYXRoW2ldICE9PSBuZXdQYXRoW2ldKSB7XG4gICAgICAgICAgd2FybignY29weVdpdGhSZW5hbWUoKSBleHBlY3RzIHBhdGhzIHRvIGJlIHRoZSBzYW1lIGV4Y2VwdCBmb3IgdGhlIGRlZXBlc3Qga2V5Jyk7XG5cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gY29weVdpdGhSZW5hbWVJbXBsKG9iaiwgb2xkUGF0aCwgbmV3UGF0aCwgMCk7XG4gIH07XG5cbiAgdmFyIGNvcHlXaXRoU2V0SW1wbCA9IGZ1bmN0aW9uIChvYmosIHBhdGgsIGluZGV4LCB2YWx1ZSkge1xuICAgIGlmIChpbmRleCA+PSBwYXRoLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cblxuICAgIHZhciBrZXkgPSBwYXRoW2luZGV4XTtcbiAgICB2YXIgdXBkYXRlZCA9IEFycmF5LmlzQXJyYXkob2JqKSA/IG9iai5zbGljZSgpIDogX2Fzc2lnbih7fSwgb2JqKTsgLy8gJEZsb3dGaXhNZSBudW1iZXIgb3Igc3RyaW5nIGlzIGZpbmUgaGVyZVxuXG4gICAgdXBkYXRlZFtrZXldID0gY29weVdpdGhTZXRJbXBsKG9ialtrZXldLCBwYXRoLCBpbmRleCArIDEsIHZhbHVlKTtcbiAgICByZXR1cm4gdXBkYXRlZDtcbiAgfTtcblxuICB2YXIgY29weVdpdGhTZXQgPSBmdW5jdGlvbiAob2JqLCBwYXRoLCB2YWx1ZSkge1xuICAgIHJldHVybiBjb3B5V2l0aFNldEltcGwob2JqLCBwYXRoLCAwLCB2YWx1ZSk7XG4gIH07XG5cbiAgdmFyIGZpbmRIb29rID0gZnVuY3Rpb24gKGZpYmVyLCBpZCkge1xuICAgIC8vIEZvciBub3csIHRoZSBcImlkXCIgb2Ygc3RhdGVmdWwgaG9va3MgaXMganVzdCB0aGUgc3RhdGVmdWwgaG9vayBpbmRleC5cbiAgICAvLyBUaGlzIG1heSBjaGFuZ2UgaW4gdGhlIGZ1dHVyZSB3aXRoIGUuZy4gbmVzdGVkIGhvb2tzLlxuICAgIHZhciBjdXJyZW50SG9vayA9IGZpYmVyLm1lbW9pemVkU3RhdGU7XG5cbiAgICB3aGlsZSAoY3VycmVudEhvb2sgIT09IG51bGwgJiYgaWQgPiAwKSB7XG4gICAgICBjdXJyZW50SG9vayA9IGN1cnJlbnRIb29rLm5leHQ7XG4gICAgICBpZC0tO1xuICAgIH1cblxuICAgIHJldHVybiBjdXJyZW50SG9vaztcbiAgfTsgLy8gU3VwcG9ydCBEZXZUb29scyBlZGl0YWJsZSB2YWx1ZXMgZm9yIHVzZVN0YXRlIGFuZCB1c2VSZWR1Y2VyLlxuXG5cbiAgb3ZlcnJpZGVIb29rU3RhdGUgPSBmdW5jdGlvbiAoZmliZXIsIGlkLCBwYXRoLCB2YWx1ZSkge1xuICAgIHZhciBob29rID0gZmluZEhvb2soZmliZXIsIGlkKTtcblxuICAgIGlmIChob29rICE9PSBudWxsKSB7XG4gICAgICB2YXIgbmV3U3RhdGUgPSBjb3B5V2l0aFNldChob29rLm1lbW9pemVkU3RhdGUsIHBhdGgsIHZhbHVlKTtcbiAgICAgIGhvb2subWVtb2l6ZWRTdGF0ZSA9IG5ld1N0YXRlO1xuICAgICAgaG9vay5iYXNlU3RhdGUgPSBuZXdTdGF0ZTsgLy8gV2UgYXJlbid0IGFjdHVhbGx5IGFkZGluZyBhbiB1cGRhdGUgdG8gdGhlIHF1ZXVlLFxuICAgICAgLy8gYmVjYXVzZSB0aGVyZSBpcyBubyB1cGRhdGUgd2UgY2FuIGFkZCBmb3IgdXNlUmVkdWNlciBob29rcyB0aGF0IHdvbid0IHRyaWdnZXIgYW4gZXJyb3IuXG4gICAgICAvLyAoVGhlcmUncyBubyBhcHByb3ByaWF0ZSBhY3Rpb24gdHlwZSBmb3IgRGV2VG9vbHMgb3ZlcnJpZGVzLilcbiAgICAgIC8vIEFzIGEgcmVzdWx0IHRob3VnaCwgUmVhY3Qgd2lsbCBzZWUgdGhlIHNjaGVkdWxlZCB1cGRhdGUgYXMgYSBub29wIGFuZCBiYWlsb3V0LlxuICAgICAgLy8gU2hhbGxvdyBjbG9uaW5nIHByb3BzIHdvcmtzIGFzIGEgd29ya2Fyb3VuZCBmb3Igbm93IHRvIGJ5cGFzcyB0aGUgYmFpbG91dCBjaGVjay5cblxuICAgICAgZmliZXIubWVtb2l6ZWRQcm9wcyA9IF9hc3NpZ24oe30sIGZpYmVyLm1lbW9pemVkUHJvcHMpO1xuICAgICAgc2NoZWR1bGVVcGRhdGVPbkZpYmVyKGZpYmVyLCBTeW5jTGFuZSwgTm9UaW1lc3RhbXApO1xuICAgIH1cbiAgfTtcblxuICBvdmVycmlkZUhvb2tTdGF0ZURlbGV0ZVBhdGggPSBmdW5jdGlvbiAoZmliZXIsIGlkLCBwYXRoKSB7XG4gICAgdmFyIGhvb2sgPSBmaW5kSG9vayhmaWJlciwgaWQpO1xuXG4gICAgaWYgKGhvb2sgIT09IG51bGwpIHtcbiAgICAgIHZhciBuZXdTdGF0ZSA9IGNvcHlXaXRoRGVsZXRlKGhvb2subWVtb2l6ZWRTdGF0ZSwgcGF0aCk7XG4gICAgICBob29rLm1lbW9pemVkU3RhdGUgPSBuZXdTdGF0ZTtcbiAgICAgIGhvb2suYmFzZVN0YXRlID0gbmV3U3RhdGU7IC8vIFdlIGFyZW4ndCBhY3R1YWxseSBhZGRpbmcgYW4gdXBkYXRlIHRvIHRoZSBxdWV1ZSxcbiAgICAgIC8vIGJlY2F1c2UgdGhlcmUgaXMgbm8gdXBkYXRlIHdlIGNhbiBhZGQgZm9yIHVzZVJlZHVjZXIgaG9va3MgdGhhdCB3b24ndCB0cmlnZ2VyIGFuIGVycm9yLlxuICAgICAgLy8gKFRoZXJlJ3Mgbm8gYXBwcm9wcmlhdGUgYWN0aW9uIHR5cGUgZm9yIERldlRvb2xzIG92ZXJyaWRlcy4pXG4gICAgICAvLyBBcyBhIHJlc3VsdCB0aG91Z2gsIFJlYWN0IHdpbGwgc2VlIHRoZSBzY2hlZHVsZWQgdXBkYXRlIGFzIGEgbm9vcCBhbmQgYmFpbG91dC5cbiAgICAgIC8vIFNoYWxsb3cgY2xvbmluZyBwcm9wcyB3b3JrcyBhcyBhIHdvcmthcm91bmQgZm9yIG5vdyB0byBieXBhc3MgdGhlIGJhaWxvdXQgY2hlY2suXG5cbiAgICAgIGZpYmVyLm1lbW9pemVkUHJvcHMgPSBfYXNzaWduKHt9LCBmaWJlci5tZW1vaXplZFByb3BzKTtcbiAgICAgIHNjaGVkdWxlVXBkYXRlT25GaWJlcihmaWJlciwgU3luY0xhbmUsIE5vVGltZXN0YW1wKTtcbiAgICB9XG4gIH07XG5cbiAgb3ZlcnJpZGVIb29rU3RhdGVSZW5hbWVQYXRoID0gZnVuY3Rpb24gKGZpYmVyLCBpZCwgb2xkUGF0aCwgbmV3UGF0aCkge1xuICAgIHZhciBob29rID0gZmluZEhvb2soZmliZXIsIGlkKTtcblxuICAgIGlmIChob29rICE9PSBudWxsKSB7XG4gICAgICB2YXIgbmV3U3RhdGUgPSBjb3B5V2l0aFJlbmFtZShob29rLm1lbW9pemVkU3RhdGUsIG9sZFBhdGgsIG5ld1BhdGgpO1xuICAgICAgaG9vay5tZW1vaXplZFN0YXRlID0gbmV3U3RhdGU7XG4gICAgICBob29rLmJhc2VTdGF0ZSA9IG5ld1N0YXRlOyAvLyBXZSBhcmVuJ3QgYWN0dWFsbHkgYWRkaW5nIGFuIHVwZGF0ZSB0byB0aGUgcXVldWUsXG4gICAgICAvLyBiZWNhdXNlIHRoZXJlIGlzIG5vIHVwZGF0ZSB3ZSBjYW4gYWRkIGZvciB1c2VSZWR1Y2VyIGhvb2tzIHRoYXQgd29uJ3QgdHJpZ2dlciBhbiBlcnJvci5cbiAgICAgIC8vIChUaGVyZSdzIG5vIGFwcHJvcHJpYXRlIGFjdGlvbiB0eXBlIGZvciBEZXZUb29scyBvdmVycmlkZXMuKVxuICAgICAgLy8gQXMgYSByZXN1bHQgdGhvdWdoLCBSZWFjdCB3aWxsIHNlZSB0aGUgc2NoZWR1bGVkIHVwZGF0ZSBhcyBhIG5vb3AgYW5kIGJhaWxvdXQuXG4gICAgICAvLyBTaGFsbG93IGNsb25pbmcgcHJvcHMgd29ya3MgYXMgYSB3b3JrYXJvdW5kIGZvciBub3cgdG8gYnlwYXNzIHRoZSBiYWlsb3V0IGNoZWNrLlxuXG4gICAgICBmaWJlci5tZW1vaXplZFByb3BzID0gX2Fzc2lnbih7fSwgZmliZXIubWVtb2l6ZWRQcm9wcyk7XG4gICAgICBzY2hlZHVsZVVwZGF0ZU9uRmliZXIoZmliZXIsIFN5bmNMYW5lLCBOb1RpbWVzdGFtcCk7XG4gICAgfVxuICB9OyAvLyBTdXBwb3J0IERldlRvb2xzIHByb3BzIGZvciBmdW5jdGlvbiBjb21wb25lbnRzLCBmb3J3YXJkUmVmLCBtZW1vLCBob3N0IGNvbXBvbmVudHMsIGV0Yy5cblxuXG4gIG92ZXJyaWRlUHJvcHMgPSBmdW5jdGlvbiAoZmliZXIsIHBhdGgsIHZhbHVlKSB7XG4gICAgZmliZXIucGVuZGluZ1Byb3BzID0gY29weVdpdGhTZXQoZmliZXIubWVtb2l6ZWRQcm9wcywgcGF0aCwgdmFsdWUpO1xuXG4gICAgaWYgKGZpYmVyLmFsdGVybmF0ZSkge1xuICAgICAgZmliZXIuYWx0ZXJuYXRlLnBlbmRpbmdQcm9wcyA9IGZpYmVyLnBlbmRpbmdQcm9wcztcbiAgICB9XG5cbiAgICBzY2hlZHVsZVVwZGF0ZU9uRmliZXIoZmliZXIsIFN5bmNMYW5lLCBOb1RpbWVzdGFtcCk7XG4gIH07XG5cbiAgb3ZlcnJpZGVQcm9wc0RlbGV0ZVBhdGggPSBmdW5jdGlvbiAoZmliZXIsIHBhdGgpIHtcbiAgICBmaWJlci5wZW5kaW5nUHJvcHMgPSBjb3B5V2l0aERlbGV0ZShmaWJlci5tZW1vaXplZFByb3BzLCBwYXRoKTtcblxuICAgIGlmIChmaWJlci5hbHRlcm5hdGUpIHtcbiAgICAgIGZpYmVyLmFsdGVybmF0ZS5wZW5kaW5nUHJvcHMgPSBmaWJlci5wZW5kaW5nUHJvcHM7XG4gICAgfVxuXG4gICAgc2NoZWR1bGVVcGRhdGVPbkZpYmVyKGZpYmVyLCBTeW5jTGFuZSwgTm9UaW1lc3RhbXApO1xuICB9O1xuXG4gIG92ZXJyaWRlUHJvcHNSZW5hbWVQYXRoID0gZnVuY3Rpb24gKGZpYmVyLCBvbGRQYXRoLCBuZXdQYXRoKSB7XG4gICAgZmliZXIucGVuZGluZ1Byb3BzID0gY29weVdpdGhSZW5hbWUoZmliZXIubWVtb2l6ZWRQcm9wcywgb2xkUGF0aCwgbmV3UGF0aCk7XG5cbiAgICBpZiAoZmliZXIuYWx0ZXJuYXRlKSB7XG4gICAgICBmaWJlci5hbHRlcm5hdGUucGVuZGluZ1Byb3BzID0gZmliZXIucGVuZGluZ1Byb3BzO1xuICAgIH1cblxuICAgIHNjaGVkdWxlVXBkYXRlT25GaWJlcihmaWJlciwgU3luY0xhbmUsIE5vVGltZXN0YW1wKTtcbiAgfTtcblxuICBzY2hlZHVsZVVwZGF0ZSA9IGZ1bmN0aW9uIChmaWJlcikge1xuICAgIHNjaGVkdWxlVXBkYXRlT25GaWJlcihmaWJlciwgU3luY0xhbmUsIE5vVGltZXN0YW1wKTtcbiAgfTtcblxuICBzZXRTdXNwZW5zZUhhbmRsZXIgPSBmdW5jdGlvbiAobmV3U2hvdWxkU3VzcGVuZEltcGwpIHtcbiAgICBzaG91bGRTdXNwZW5kSW1wbCA9IG5ld1Nob3VsZFN1c3BlbmRJbXBsO1xuICB9O1xufVxuXG5mdW5jdGlvbiBmaW5kSG9zdEluc3RhbmNlQnlGaWJlcihmaWJlcikge1xuICB2YXIgaG9zdEZpYmVyID0gZmluZEN1cnJlbnRIb3N0RmliZXIoZmliZXIpO1xuXG4gIGlmIChob3N0RmliZXIgPT09IG51bGwpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHJldHVybiBob3N0RmliZXIuc3RhdGVOb2RlO1xufVxuXG5mdW5jdGlvbiBlbXB0eUZpbmRGaWJlckJ5SG9zdEluc3RhbmNlKGluc3RhbmNlKSB7XG4gIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiBnZXRDdXJyZW50RmliZXJGb3JEZXZUb29scygpIHtcbiAgcmV0dXJuIGN1cnJlbnQ7XG59XG5cbmZ1bmN0aW9uIGluamVjdEludG9EZXZUb29scyhkZXZUb29sc0NvbmZpZykge1xuICB2YXIgZmluZEZpYmVyQnlIb3N0SW5zdGFuY2UgPSBkZXZUb29sc0NvbmZpZy5maW5kRmliZXJCeUhvc3RJbnN0YW5jZTtcbiAgdmFyIFJlYWN0Q3VycmVudERpc3BhdGNoZXIgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdEN1cnJlbnREaXNwYXRjaGVyO1xuICByZXR1cm4gaW5qZWN0SW50ZXJuYWxzKHtcbiAgICBidW5kbGVUeXBlOiBkZXZUb29sc0NvbmZpZy5idW5kbGVUeXBlLFxuICAgIHZlcnNpb246IGRldlRvb2xzQ29uZmlnLnZlcnNpb24sXG4gICAgcmVuZGVyZXJQYWNrYWdlTmFtZTogZGV2VG9vbHNDb25maWcucmVuZGVyZXJQYWNrYWdlTmFtZSxcbiAgICByZW5kZXJlckNvbmZpZzogZGV2VG9vbHNDb25maWcucmVuZGVyZXJDb25maWcsXG4gICAgb3ZlcnJpZGVIb29rU3RhdGU6IG92ZXJyaWRlSG9va1N0YXRlLFxuICAgIG92ZXJyaWRlSG9va1N0YXRlRGVsZXRlUGF0aDogb3ZlcnJpZGVIb29rU3RhdGVEZWxldGVQYXRoLFxuICAgIG92ZXJyaWRlSG9va1N0YXRlUmVuYW1lUGF0aDogb3ZlcnJpZGVIb29rU3RhdGVSZW5hbWVQYXRoLFxuICAgIG92ZXJyaWRlUHJvcHM6IG92ZXJyaWRlUHJvcHMsXG4gICAgb3ZlcnJpZGVQcm9wc0RlbGV0ZVBhdGg6IG92ZXJyaWRlUHJvcHNEZWxldGVQYXRoLFxuICAgIG92ZXJyaWRlUHJvcHNSZW5hbWVQYXRoOiBvdmVycmlkZVByb3BzUmVuYW1lUGF0aCxcbiAgICBzZXRTdXNwZW5zZUhhbmRsZXI6IHNldFN1c3BlbnNlSGFuZGxlcixcbiAgICBzY2hlZHVsZVVwZGF0ZTogc2NoZWR1bGVVcGRhdGUsXG4gICAgY3VycmVudERpc3BhdGNoZXJSZWY6IFJlYWN0Q3VycmVudERpc3BhdGNoZXIsXG4gICAgZmluZEhvc3RJbnN0YW5jZUJ5RmliZXI6IGZpbmRIb3N0SW5zdGFuY2VCeUZpYmVyLFxuICAgIGZpbmRGaWJlckJ5SG9zdEluc3RhbmNlOiBmaW5kRmliZXJCeUhvc3RJbnN0YW5jZSB8fCBlbXB0eUZpbmRGaWJlckJ5SG9zdEluc3RhbmNlLFxuICAgIC8vIFJlYWN0IFJlZnJlc2hcbiAgICBmaW5kSG9zdEluc3RhbmNlc0ZvclJlZnJlc2g6ICBmaW5kSG9zdEluc3RhbmNlc0ZvclJlZnJlc2ggLFxuICAgIHNjaGVkdWxlUmVmcmVzaDogIHNjaGVkdWxlUmVmcmVzaCAsXG4gICAgc2NoZWR1bGVSb290OiAgc2NoZWR1bGVSb290ICxcbiAgICBzZXRSZWZyZXNoSGFuZGxlcjogIHNldFJlZnJlc2hIYW5kbGVyICxcbiAgICAvLyBFbmFibGVzIERldlRvb2xzIHRvIGFwcGVuZCBvd25lciBzdGFja3MgdG8gZXJyb3IgbWVzc2FnZXMgaW4gREVWIG1vZGUuXG4gICAgZ2V0Q3VycmVudEZpYmVyOiAgZ2V0Q3VycmVudEZpYmVyRm9yRGV2VG9vbHMgXG4gIH0pO1xufVxuXG5mdW5jdGlvbiBSZWFjdERPTVJvb3QoY29udGFpbmVyLCBvcHRpb25zKSB7XG4gIHRoaXMuX2ludGVybmFsUm9vdCA9IGNyZWF0ZVJvb3RJbXBsKGNvbnRhaW5lciwgQ29uY3VycmVudFJvb3QsIG9wdGlvbnMpO1xufVxuXG5mdW5jdGlvbiBSZWFjdERPTUJsb2NraW5nUm9vdChjb250YWluZXIsIHRhZywgb3B0aW9ucykge1xuICB0aGlzLl9pbnRlcm5hbFJvb3QgPSBjcmVhdGVSb290SW1wbChjb250YWluZXIsIHRhZywgb3B0aW9ucyk7XG59XG5cblJlYWN0RE9NUm9vdC5wcm90b3R5cGUucmVuZGVyID0gUmVhY3RET01CbG9ja2luZ1Jvb3QucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uIChjaGlsZHJlbikge1xuICB2YXIgcm9vdCA9IHRoaXMuX2ludGVybmFsUm9vdDtcblxuICB7XG4gICAgaWYgKHR5cGVvZiBhcmd1bWVudHNbMV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGVycm9yKCdyZW5kZXIoLi4uKTogZG9lcyBub3Qgc3VwcG9ydCB0aGUgc2Vjb25kIGNhbGxiYWNrIGFyZ3VtZW50LiAnICsgJ1RvIGV4ZWN1dGUgYSBzaWRlIGVmZmVjdCBhZnRlciByZW5kZXJpbmcsIGRlY2xhcmUgaXQgaW4gYSBjb21wb25lbnQgYm9keSB3aXRoIHVzZUVmZmVjdCgpLicpO1xuICAgIH1cblxuICAgIHZhciBjb250YWluZXIgPSByb290LmNvbnRhaW5lckluZm87XG5cbiAgICBpZiAoY29udGFpbmVyLm5vZGVUeXBlICE9PSBDT01NRU5UX05PREUpIHtcbiAgICAgIHZhciBob3N0SW5zdGFuY2UgPSBmaW5kSG9zdEluc3RhbmNlV2l0aE5vUG9ydGFscyhyb290LmN1cnJlbnQpO1xuXG4gICAgICBpZiAoaG9zdEluc3RhbmNlKSB7XG4gICAgICAgIGlmIChob3N0SW5zdGFuY2UucGFyZW50Tm9kZSAhPT0gY29udGFpbmVyKSB7XG4gICAgICAgICAgZXJyb3IoJ3JlbmRlciguLi4pOiBJdCBsb29rcyBsaWtlIHRoZSBSZWFjdC1yZW5kZXJlZCBjb250ZW50IG9mIHRoZSAnICsgJ3Jvb3QgY29udGFpbmVyIHdhcyByZW1vdmVkIHdpdGhvdXQgdXNpbmcgUmVhY3QuIFRoaXMgaXMgbm90ICcgKyAnc3VwcG9ydGVkIGFuZCB3aWxsIGNhdXNlIGVycm9ycy4gSW5zdGVhZCwgY2FsbCAnICsgXCJyb290LnVubW91bnQoKSB0byBlbXB0eSBhIHJvb3QncyBjb250YWluZXIuXCIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdXBkYXRlQ29udGFpbmVyKGNoaWxkcmVuLCByb290LCBudWxsLCBudWxsKTtcbn07XG5cblJlYWN0RE9NUm9vdC5wcm90b3R5cGUudW5tb3VudCA9IFJlYWN0RE9NQmxvY2tpbmdSb290LnByb3RvdHlwZS51bm1vdW50ID0gZnVuY3Rpb24gKCkge1xuICB7XG4gICAgaWYgKHR5cGVvZiBhcmd1bWVudHNbMF0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGVycm9yKCd1bm1vdW50KC4uLik6IGRvZXMgbm90IHN1cHBvcnQgYSBjYWxsYmFjayBhcmd1bWVudC4gJyArICdUbyBleGVjdXRlIGEgc2lkZSBlZmZlY3QgYWZ0ZXIgcmVuZGVyaW5nLCBkZWNsYXJlIGl0IGluIGEgY29tcG9uZW50IGJvZHkgd2l0aCB1c2VFZmZlY3QoKS4nKTtcbiAgICB9XG4gIH1cblxuICB2YXIgcm9vdCA9IHRoaXMuX2ludGVybmFsUm9vdDtcbiAgdmFyIGNvbnRhaW5lciA9IHJvb3QuY29udGFpbmVySW5mbztcbiAgdXBkYXRlQ29udGFpbmVyKG51bGwsIHJvb3QsIG51bGwsIGZ1bmN0aW9uICgpIHtcbiAgICB1bm1hcmtDb250YWluZXJBc1Jvb3QoY29udGFpbmVyKTtcbiAgfSk7XG59O1xuXG5mdW5jdGlvbiBjcmVhdGVSb290SW1wbChjb250YWluZXIsIHRhZywgb3B0aW9ucykge1xuICAvLyBUYWcgaXMgZWl0aGVyIExlZ2FjeVJvb3Qgb3IgQ29uY3VycmVudCBSb290XG4gIHZhciBoeWRyYXRlID0gb3B0aW9ucyAhPSBudWxsICYmIG9wdGlvbnMuaHlkcmF0ZSA9PT0gdHJ1ZTtcbiAgdmFyIGh5ZHJhdGlvbkNhbGxiYWNrcyA9IG9wdGlvbnMgIT0gbnVsbCAmJiBvcHRpb25zLmh5ZHJhdGlvbk9wdGlvbnMgfHwgbnVsbDtcbiAgdmFyIG11dGFibGVTb3VyY2VzID0gb3B0aW9ucyAhPSBudWxsICYmIG9wdGlvbnMuaHlkcmF0aW9uT3B0aW9ucyAhPSBudWxsICYmIG9wdGlvbnMuaHlkcmF0aW9uT3B0aW9ucy5tdXRhYmxlU291cmNlcyB8fCBudWxsO1xuICB2YXIgcm9vdCA9IGNyZWF0ZUNvbnRhaW5lcihjb250YWluZXIsIHRhZywgaHlkcmF0ZSk7XG4gIG1hcmtDb250YWluZXJBc1Jvb3Qocm9vdC5jdXJyZW50LCBjb250YWluZXIpO1xuICB2YXIgY29udGFpbmVyTm9kZVR5cGUgPSBjb250YWluZXIubm9kZVR5cGU7XG5cbiAge1xuICAgIHZhciByb290Q29udGFpbmVyRWxlbWVudCA9IGNvbnRhaW5lci5ub2RlVHlwZSA9PT0gQ09NTUVOVF9OT0RFID8gY29udGFpbmVyLnBhcmVudE5vZGUgOiBjb250YWluZXI7XG4gICAgbGlzdGVuVG9BbGxTdXBwb3J0ZWRFdmVudHMocm9vdENvbnRhaW5lckVsZW1lbnQpO1xuICB9XG5cbiAgaWYgKG11dGFibGVTb3VyY2VzKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtdXRhYmxlU291cmNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIG11dGFibGVTb3VyY2UgPSBtdXRhYmxlU291cmNlc1tpXTtcbiAgICAgIHJlZ2lzdGVyTXV0YWJsZVNvdXJjZUZvckh5ZHJhdGlvbihyb290LCBtdXRhYmxlU291cmNlKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcm9vdDtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUxlZ2FjeVJvb3QoY29udGFpbmVyLCBvcHRpb25zKSB7XG4gIHJldHVybiBuZXcgUmVhY3RET01CbG9ja2luZ1Jvb3QoY29udGFpbmVyLCBMZWdhY3lSb290LCBvcHRpb25zKTtcbn1cbmZ1bmN0aW9uIGlzVmFsaWRDb250YWluZXIobm9kZSkge1xuICByZXR1cm4gISEobm9kZSAmJiAobm9kZS5ub2RlVHlwZSA9PT0gRUxFTUVOVF9OT0RFIHx8IG5vZGUubm9kZVR5cGUgPT09IERPQ1VNRU5UX05PREUgfHwgbm9kZS5ub2RlVHlwZSA9PT0gRE9DVU1FTlRfRlJBR01FTlRfTk9ERSB8fCBub2RlLm5vZGVUeXBlID09PSBDT01NRU5UX05PREUgJiYgbm9kZS5ub2RlVmFsdWUgPT09ICcgcmVhY3QtbW91bnQtcG9pbnQtdW5zdGFibGUgJykpO1xufVxuXG52YXIgUmVhY3RDdXJyZW50T3duZXIkMyA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0Q3VycmVudE93bmVyO1xudmFyIHRvcExldmVsVXBkYXRlV2FybmluZ3M7XG52YXIgd2FybmVkQWJvdXRIeWRyYXRlQVBJID0gZmFsc2U7XG5cbntcbiAgdG9wTGV2ZWxVcGRhdGVXYXJuaW5ncyA9IGZ1bmN0aW9uIChjb250YWluZXIpIHtcbiAgICBpZiAoY29udGFpbmVyLl9yZWFjdFJvb3RDb250YWluZXIgJiYgY29udGFpbmVyLm5vZGVUeXBlICE9PSBDT01NRU5UX05PREUpIHtcbiAgICAgIHZhciBob3N0SW5zdGFuY2UgPSBmaW5kSG9zdEluc3RhbmNlV2l0aE5vUG9ydGFscyhjb250YWluZXIuX3JlYWN0Um9vdENvbnRhaW5lci5faW50ZXJuYWxSb290LmN1cnJlbnQpO1xuXG4gICAgICBpZiAoaG9zdEluc3RhbmNlKSB7XG4gICAgICAgIGlmIChob3N0SW5zdGFuY2UucGFyZW50Tm9kZSAhPT0gY29udGFpbmVyKSB7XG4gICAgICAgICAgZXJyb3IoJ3JlbmRlciguLi4pOiBJdCBsb29rcyBsaWtlIHRoZSBSZWFjdC1yZW5kZXJlZCBjb250ZW50IG9mIHRoaXMgJyArICdjb250YWluZXIgd2FzIHJlbW92ZWQgd2l0aG91dCB1c2luZyBSZWFjdC4gVGhpcyBpcyBub3QgJyArICdzdXBwb3J0ZWQgYW5kIHdpbGwgY2F1c2UgZXJyb3JzLiBJbnN0ZWFkLCBjYWxsICcgKyAnUmVhY3RET00udW5tb3VudENvbXBvbmVudEF0Tm9kZSB0byBlbXB0eSBhIGNvbnRhaW5lci4nKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBpc1Jvb3RSZW5kZXJlZEJ5U29tZVJlYWN0ID0gISFjb250YWluZXIuX3JlYWN0Um9vdENvbnRhaW5lcjtcbiAgICB2YXIgcm9vdEVsID0gZ2V0UmVhY3RSb290RWxlbWVudEluQ29udGFpbmVyKGNvbnRhaW5lcik7XG4gICAgdmFyIGhhc05vblJvb3RSZWFjdENoaWxkID0gISEocm9vdEVsICYmIGdldEluc3RhbmNlRnJvbU5vZGUocm9vdEVsKSk7XG5cbiAgICBpZiAoaGFzTm9uUm9vdFJlYWN0Q2hpbGQgJiYgIWlzUm9vdFJlbmRlcmVkQnlTb21lUmVhY3QpIHtcbiAgICAgIGVycm9yKCdyZW5kZXIoLi4uKTogUmVwbGFjaW5nIFJlYWN0LXJlbmRlcmVkIGNoaWxkcmVuIHdpdGggYSBuZXcgcm9vdCAnICsgJ2NvbXBvbmVudC4gSWYgeW91IGludGVuZGVkIHRvIHVwZGF0ZSB0aGUgY2hpbGRyZW4gb2YgdGhpcyBub2RlLCAnICsgJ3lvdSBzaG91bGQgaW5zdGVhZCBoYXZlIHRoZSBleGlzdGluZyBjaGlsZHJlbiB1cGRhdGUgdGhlaXIgc3RhdGUgJyArICdhbmQgcmVuZGVyIHRoZSBuZXcgY29tcG9uZW50cyBpbnN0ZWFkIG9mIGNhbGxpbmcgUmVhY3RET00ucmVuZGVyLicpO1xuICAgIH1cblxuICAgIGlmIChjb250YWluZXIubm9kZVR5cGUgPT09IEVMRU1FTlRfTk9ERSAmJiBjb250YWluZXIudGFnTmFtZSAmJiBjb250YWluZXIudGFnTmFtZS50b1VwcGVyQ2FzZSgpID09PSAnQk9EWScpIHtcbiAgICAgIGVycm9yKCdyZW5kZXIoKTogUmVuZGVyaW5nIGNvbXBvbmVudHMgZGlyZWN0bHkgaW50byBkb2N1bWVudC5ib2R5IGlzICcgKyAnZGlzY291cmFnZWQsIHNpbmNlIGl0cyBjaGlsZHJlbiBhcmUgb2Z0ZW4gbWFuaXB1bGF0ZWQgYnkgdGhpcmQtcGFydHkgJyArICdzY3JpcHRzIGFuZCBicm93c2VyIGV4dGVuc2lvbnMuIFRoaXMgbWF5IGxlYWQgdG8gc3VidGxlICcgKyAncmVjb25jaWxpYXRpb24gaXNzdWVzLiBUcnkgcmVuZGVyaW5nIGludG8gYSBjb250YWluZXIgZWxlbWVudCBjcmVhdGVkICcgKyAnZm9yIHlvdXIgYXBwLicpO1xuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gZ2V0UmVhY3RSb290RWxlbWVudEluQ29udGFpbmVyKGNvbnRhaW5lcikge1xuICBpZiAoIWNvbnRhaW5lcikge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgaWYgKGNvbnRhaW5lci5ub2RlVHlwZSA9PT0gRE9DVU1FTlRfTk9ERSkge1xuICAgIHJldHVybiBjb250YWluZXIuZG9jdW1lbnRFbGVtZW50O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBjb250YWluZXIuZmlyc3RDaGlsZDtcbiAgfVxufVxuXG5mdW5jdGlvbiBzaG91bGRIeWRyYXRlRHVlVG9MZWdhY3lIZXVyaXN0aWMoY29udGFpbmVyKSB7XG4gIHZhciByb290RWxlbWVudCA9IGdldFJlYWN0Um9vdEVsZW1lbnRJbkNvbnRhaW5lcihjb250YWluZXIpO1xuICByZXR1cm4gISEocm9vdEVsZW1lbnQgJiYgcm9vdEVsZW1lbnQubm9kZVR5cGUgPT09IEVMRU1FTlRfTk9ERSAmJiByb290RWxlbWVudC5oYXNBdHRyaWJ1dGUoUk9PVF9BVFRSSUJVVEVfTkFNRSkpO1xufVxuXG5mdW5jdGlvbiBsZWdhY3lDcmVhdGVSb290RnJvbURPTUNvbnRhaW5lcihjb250YWluZXIsIGZvcmNlSHlkcmF0ZSkge1xuICB2YXIgc2hvdWxkSHlkcmF0ZSA9IGZvcmNlSHlkcmF0ZSB8fCBzaG91bGRIeWRyYXRlRHVlVG9MZWdhY3lIZXVyaXN0aWMoY29udGFpbmVyKTsgLy8gRmlyc3QgY2xlYXIgYW55IGV4aXN0aW5nIGNvbnRlbnQuXG5cbiAgaWYgKCFzaG91bGRIeWRyYXRlKSB7XG4gICAgdmFyIHdhcm5lZCA9IGZhbHNlO1xuICAgIHZhciByb290U2libGluZztcblxuICAgIHdoaWxlIChyb290U2libGluZyA9IGNvbnRhaW5lci5sYXN0Q2hpbGQpIHtcbiAgICAgIHtcbiAgICAgICAgaWYgKCF3YXJuZWQgJiYgcm9vdFNpYmxpbmcubm9kZVR5cGUgPT09IEVMRU1FTlRfTk9ERSAmJiByb290U2libGluZy5oYXNBdHRyaWJ1dGUoUk9PVF9BVFRSSUJVVEVfTkFNRSkpIHtcbiAgICAgICAgICB3YXJuZWQgPSB0cnVlO1xuXG4gICAgICAgICAgZXJyb3IoJ3JlbmRlcigpOiBUYXJnZXQgbm9kZSBoYXMgbWFya3VwIHJlbmRlcmVkIGJ5IFJlYWN0LCBidXQgdGhlcmUgJyArICdhcmUgdW5yZWxhdGVkIG5vZGVzIGFzIHdlbGwuIFRoaXMgaXMgbW9zdCBjb21tb25seSBjYXVzZWQgYnkgJyArICd3aGl0ZS1zcGFjZSBpbnNlcnRlZCBhcm91bmQgc2VydmVyLXJlbmRlcmVkIG1hcmt1cC4nKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBjb250YWluZXIucmVtb3ZlQ2hpbGQocm9vdFNpYmxpbmcpO1xuICAgIH1cbiAgfVxuXG4gIHtcbiAgICBpZiAoc2hvdWxkSHlkcmF0ZSAmJiAhZm9yY2VIeWRyYXRlICYmICF3YXJuZWRBYm91dEh5ZHJhdGVBUEkpIHtcbiAgICAgIHdhcm5lZEFib3V0SHlkcmF0ZUFQSSA9IHRydWU7XG5cbiAgICAgIHdhcm4oJ3JlbmRlcigpOiBDYWxsaW5nIFJlYWN0RE9NLnJlbmRlcigpIHRvIGh5ZHJhdGUgc2VydmVyLXJlbmRlcmVkIG1hcmt1cCAnICsgJ3dpbGwgc3RvcCB3b3JraW5nIGluIFJlYWN0IHYxOC4gUmVwbGFjZSB0aGUgUmVhY3RET00ucmVuZGVyKCkgY2FsbCAnICsgJ3dpdGggUmVhY3RET00uaHlkcmF0ZSgpIGlmIHlvdSB3YW50IFJlYWN0IHRvIGF0dGFjaCB0byB0aGUgc2VydmVyIEhUTUwuJyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGNyZWF0ZUxlZ2FjeVJvb3QoY29udGFpbmVyLCBzaG91bGRIeWRyYXRlID8ge1xuICAgIGh5ZHJhdGU6IHRydWVcbiAgfSA6IHVuZGVmaW5lZCk7XG59XG5cbmZ1bmN0aW9uIHdhcm5PbkludmFsaWRDYWxsYmFjayQxKGNhbGxiYWNrLCBjYWxsZXJOYW1lKSB7XG4gIHtcbiAgICBpZiAoY2FsbGJhY2sgIT09IG51bGwgJiYgdHlwZW9mIGNhbGxiYWNrICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICBlcnJvcignJXMoLi4uKTogRXhwZWN0ZWQgdGhlIGxhc3Qgb3B0aW9uYWwgYGNhbGxiYWNrYCBhcmd1bWVudCB0byBiZSBhICcgKyAnZnVuY3Rpb24uIEluc3RlYWQgcmVjZWl2ZWQ6ICVzLicsIGNhbGxlck5hbWUsIGNhbGxiYWNrKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gbGVnYWN5UmVuZGVyU3VidHJlZUludG9Db250YWluZXIocGFyZW50Q29tcG9uZW50LCBjaGlsZHJlbiwgY29udGFpbmVyLCBmb3JjZUh5ZHJhdGUsIGNhbGxiYWNrKSB7XG4gIHtcbiAgICB0b3BMZXZlbFVwZGF0ZVdhcm5pbmdzKGNvbnRhaW5lcik7XG4gICAgd2Fybk9uSW52YWxpZENhbGxiYWNrJDEoY2FsbGJhY2sgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBjYWxsYmFjaywgJ3JlbmRlcicpO1xuICB9IC8vIFRPRE86IFdpdGhvdXQgYGFueWAgdHlwZSwgRmxvdyBzYXlzIFwiUHJvcGVydHkgY2Fubm90IGJlIGFjY2Vzc2VkIG9uIGFueVxuICAvLyBtZW1iZXIgb2YgaW50ZXJzZWN0aW9uIHR5cGUuXCIgV2h5eXl5eXkuXG5cblxuICB2YXIgcm9vdCA9IGNvbnRhaW5lci5fcmVhY3RSb290Q29udGFpbmVyO1xuICB2YXIgZmliZXJSb290O1xuXG4gIGlmICghcm9vdCkge1xuICAgIC8vIEluaXRpYWwgbW91bnRcbiAgICByb290ID0gY29udGFpbmVyLl9yZWFjdFJvb3RDb250YWluZXIgPSBsZWdhY3lDcmVhdGVSb290RnJvbURPTUNvbnRhaW5lcihjb250YWluZXIsIGZvcmNlSHlkcmF0ZSk7XG4gICAgZmliZXJSb290ID0gcm9vdC5faW50ZXJuYWxSb290O1xuXG4gICAgaWYgKHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdmFyIG9yaWdpbmFsQ2FsbGJhY2sgPSBjYWxsYmFjaztcblxuICAgICAgY2FsbGJhY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBpbnN0YW5jZSA9IGdldFB1YmxpY1Jvb3RJbnN0YW5jZShmaWJlclJvb3QpO1xuICAgICAgICBvcmlnaW5hbENhbGxiYWNrLmNhbGwoaW5zdGFuY2UpO1xuICAgICAgfTtcbiAgICB9IC8vIEluaXRpYWwgbW91bnQgc2hvdWxkIG5vdCBiZSBiYXRjaGVkLlxuXG5cbiAgICB1bmJhdGNoZWRVcGRhdGVzKGZ1bmN0aW9uICgpIHtcbiAgICAgIHVwZGF0ZUNvbnRhaW5lcihjaGlsZHJlbiwgZmliZXJSb290LCBwYXJlbnRDb21wb25lbnQsIGNhbGxiYWNrKTtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBmaWJlclJvb3QgPSByb290Ll9pbnRlcm5hbFJvb3Q7XG5cbiAgICBpZiAodHlwZW9mIGNhbGxiYWNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB2YXIgX29yaWdpbmFsQ2FsbGJhY2sgPSBjYWxsYmFjaztcblxuICAgICAgY2FsbGJhY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBpbnN0YW5jZSA9IGdldFB1YmxpY1Jvb3RJbnN0YW5jZShmaWJlclJvb3QpO1xuXG4gICAgICAgIF9vcmlnaW5hbENhbGxiYWNrLmNhbGwoaW5zdGFuY2UpO1xuICAgICAgfTtcbiAgICB9IC8vIFVwZGF0ZVxuXG5cbiAgICB1cGRhdGVDb250YWluZXIoY2hpbGRyZW4sIGZpYmVyUm9vdCwgcGFyZW50Q29tcG9uZW50LCBjYWxsYmFjayk7XG4gIH1cblxuICByZXR1cm4gZ2V0UHVibGljUm9vdEluc3RhbmNlKGZpYmVyUm9vdCk7XG59XG5cbmZ1bmN0aW9uIGZpbmRET01Ob2RlKGNvbXBvbmVudE9yRWxlbWVudCkge1xuICB7XG4gICAgdmFyIG93bmVyID0gUmVhY3RDdXJyZW50T3duZXIkMy5jdXJyZW50O1xuXG4gICAgaWYgKG93bmVyICE9PSBudWxsICYmIG93bmVyLnN0YXRlTm9kZSAhPT0gbnVsbCkge1xuICAgICAgdmFyIHdhcm5lZEFib3V0UmVmc0luUmVuZGVyID0gb3duZXIuc3RhdGVOb2RlLl93YXJuZWRBYm91dFJlZnNJblJlbmRlcjtcblxuICAgICAgaWYgKCF3YXJuZWRBYm91dFJlZnNJblJlbmRlcikge1xuICAgICAgICBlcnJvcignJXMgaXMgYWNjZXNzaW5nIGZpbmRET01Ob2RlIGluc2lkZSBpdHMgcmVuZGVyKCkuICcgKyAncmVuZGVyKCkgc2hvdWxkIGJlIGEgcHVyZSBmdW5jdGlvbiBvZiBwcm9wcyBhbmQgc3RhdGUuIEl0IHNob3VsZCAnICsgJ25ldmVyIGFjY2VzcyBzb21ldGhpbmcgdGhhdCByZXF1aXJlcyBzdGFsZSBkYXRhIGZyb20gdGhlIHByZXZpb3VzICcgKyAncmVuZGVyLCBzdWNoIGFzIHJlZnMuIE1vdmUgdGhpcyBsb2dpYyB0byBjb21wb25lbnREaWRNb3VudCBhbmQgJyArICdjb21wb25lbnREaWRVcGRhdGUgaW5zdGVhZC4nLCBnZXRDb21wb25lbnROYW1lKG93bmVyLnR5cGUpIHx8ICdBIGNvbXBvbmVudCcpO1xuICAgICAgfVxuXG4gICAgICBvd25lci5zdGF0ZU5vZGUuX3dhcm5lZEFib3V0UmVmc0luUmVuZGVyID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICBpZiAoY29tcG9uZW50T3JFbGVtZW50ID09IG51bGwpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGlmIChjb21wb25lbnRPckVsZW1lbnQubm9kZVR5cGUgPT09IEVMRU1FTlRfTk9ERSkge1xuICAgIHJldHVybiBjb21wb25lbnRPckVsZW1lbnQ7XG4gIH1cblxuICB7XG4gICAgcmV0dXJuIGZpbmRIb3N0SW5zdGFuY2VXaXRoV2FybmluZyhjb21wb25lbnRPckVsZW1lbnQsICdmaW5kRE9NTm9kZScpO1xuICB9XG59XG5mdW5jdGlvbiBoeWRyYXRlKGVsZW1lbnQsIGNvbnRhaW5lciwgY2FsbGJhY2spIHtcbiAgaWYgKCFpc1ZhbGlkQ29udGFpbmVyKGNvbnRhaW5lcikpIHtcbiAgICB7XG4gICAgICB0aHJvdyBFcnJvciggXCJUYXJnZXQgY29udGFpbmVyIGlzIG5vdCBhIERPTSBlbGVtZW50LlwiICk7XG4gICAgfVxuICB9XG5cbiAge1xuICAgIHZhciBpc01vZGVyblJvb3QgPSBpc0NvbnRhaW5lck1hcmtlZEFzUm9vdChjb250YWluZXIpICYmIGNvbnRhaW5lci5fcmVhY3RSb290Q29udGFpbmVyID09PSB1bmRlZmluZWQ7XG5cbiAgICBpZiAoaXNNb2Rlcm5Sb290KSB7XG4gICAgICBlcnJvcignWW91IGFyZSBjYWxsaW5nIFJlYWN0RE9NLmh5ZHJhdGUoKSBvbiBhIGNvbnRhaW5lciB0aGF0IHdhcyBwcmV2aW91c2x5ICcgKyAncGFzc2VkIHRvIFJlYWN0RE9NLmNyZWF0ZVJvb3QoKS4gVGhpcyBpcyBub3Qgc3VwcG9ydGVkLiAnICsgJ0RpZCB5b3UgbWVhbiB0byBjYWxsIGNyZWF0ZVJvb3QoY29udGFpbmVyLCB7aHlkcmF0ZTogdHJ1ZX0pLnJlbmRlcihlbGVtZW50KT8nKTtcbiAgICB9XG4gIH0gLy8gVE9ETzogdGhyb3cgb3Igd2FybiBpZiB3ZSBjb3VsZG4ndCBoeWRyYXRlP1xuXG5cbiAgcmV0dXJuIGxlZ2FjeVJlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyKG51bGwsIGVsZW1lbnQsIGNvbnRhaW5lciwgdHJ1ZSwgY2FsbGJhY2spO1xufVxuZnVuY3Rpb24gcmVuZGVyKGVsZW1lbnQsIGNvbnRhaW5lciwgY2FsbGJhY2spIHtcbiAgaWYgKCFpc1ZhbGlkQ29udGFpbmVyKGNvbnRhaW5lcikpIHtcbiAgICB7XG4gICAgICB0aHJvdyBFcnJvciggXCJUYXJnZXQgY29udGFpbmVyIGlzIG5vdCBhIERPTSBlbGVtZW50LlwiICk7XG4gICAgfVxuICB9XG5cbiAge1xuICAgIHZhciBpc01vZGVyblJvb3QgPSBpc0NvbnRhaW5lck1hcmtlZEFzUm9vdChjb250YWluZXIpICYmIGNvbnRhaW5lci5fcmVhY3RSb290Q29udGFpbmVyID09PSB1bmRlZmluZWQ7XG5cbiAgICBpZiAoaXNNb2Rlcm5Sb290KSB7XG4gICAgICBlcnJvcignWW91IGFyZSBjYWxsaW5nIFJlYWN0RE9NLnJlbmRlcigpIG9uIGEgY29udGFpbmVyIHRoYXQgd2FzIHByZXZpb3VzbHkgJyArICdwYXNzZWQgdG8gUmVhY3RET00uY3JlYXRlUm9vdCgpLiBUaGlzIGlzIG5vdCBzdXBwb3J0ZWQuICcgKyAnRGlkIHlvdSBtZWFuIHRvIGNhbGwgcm9vdC5yZW5kZXIoZWxlbWVudCk/Jyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGxlZ2FjeVJlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyKG51bGwsIGVsZW1lbnQsIGNvbnRhaW5lciwgZmFsc2UsIGNhbGxiYWNrKTtcbn1cbmZ1bmN0aW9uIHVuc3RhYmxlX3JlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyKHBhcmVudENvbXBvbmVudCwgZWxlbWVudCwgY29udGFpbmVyTm9kZSwgY2FsbGJhY2spIHtcbiAgaWYgKCFpc1ZhbGlkQ29udGFpbmVyKGNvbnRhaW5lck5vZGUpKSB7XG4gICAge1xuICAgICAgdGhyb3cgRXJyb3IoIFwiVGFyZ2V0IGNvbnRhaW5lciBpcyBub3QgYSBET00gZWxlbWVudC5cIiApO1xuICAgIH1cbiAgfVxuXG4gIGlmICghKHBhcmVudENvbXBvbmVudCAhPSBudWxsICYmIGhhcyhwYXJlbnRDb21wb25lbnQpKSkge1xuICAgIHtcbiAgICAgIHRocm93IEVycm9yKCBcInBhcmVudENvbXBvbmVudCBtdXN0IGJlIGEgdmFsaWQgUmVhY3QgQ29tcG9uZW50XCIgKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbGVnYWN5UmVuZGVyU3VidHJlZUludG9Db250YWluZXIocGFyZW50Q29tcG9uZW50LCBlbGVtZW50LCBjb250YWluZXJOb2RlLCBmYWxzZSwgY2FsbGJhY2spO1xufVxuZnVuY3Rpb24gdW5tb3VudENvbXBvbmVudEF0Tm9kZShjb250YWluZXIpIHtcbiAgaWYgKCFpc1ZhbGlkQ29udGFpbmVyKGNvbnRhaW5lcikpIHtcbiAgICB7XG4gICAgICB0aHJvdyBFcnJvciggXCJ1bm1vdW50Q29tcG9uZW50QXROb2RlKC4uLik6IFRhcmdldCBjb250YWluZXIgaXMgbm90IGEgRE9NIGVsZW1lbnQuXCIgKTtcbiAgICB9XG4gIH1cblxuICB7XG4gICAgdmFyIGlzTW9kZXJuUm9vdCA9IGlzQ29udGFpbmVyTWFya2VkQXNSb290KGNvbnRhaW5lcikgJiYgY29udGFpbmVyLl9yZWFjdFJvb3RDb250YWluZXIgPT09IHVuZGVmaW5lZDtcblxuICAgIGlmIChpc01vZGVyblJvb3QpIHtcbiAgICAgIGVycm9yKCdZb3UgYXJlIGNhbGxpbmcgUmVhY3RET00udW5tb3VudENvbXBvbmVudEF0Tm9kZSgpIG9uIGEgY29udGFpbmVyIHRoYXQgd2FzIHByZXZpb3VzbHkgJyArICdwYXNzZWQgdG8gUmVhY3RET00uY3JlYXRlUm9vdCgpLiBUaGlzIGlzIG5vdCBzdXBwb3J0ZWQuIERpZCB5b3UgbWVhbiB0byBjYWxsIHJvb3QudW5tb3VudCgpPycpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChjb250YWluZXIuX3JlYWN0Um9vdENvbnRhaW5lcikge1xuICAgIHtcbiAgICAgIHZhciByb290RWwgPSBnZXRSZWFjdFJvb3RFbGVtZW50SW5Db250YWluZXIoY29udGFpbmVyKTtcbiAgICAgIHZhciByZW5kZXJlZEJ5RGlmZmVyZW50UmVhY3QgPSByb290RWwgJiYgIWdldEluc3RhbmNlRnJvbU5vZGUocm9vdEVsKTtcblxuICAgICAgaWYgKHJlbmRlcmVkQnlEaWZmZXJlbnRSZWFjdCkge1xuICAgICAgICBlcnJvcihcInVubW91bnRDb21wb25lbnRBdE5vZGUoKTogVGhlIG5vZGUgeW91J3JlIGF0dGVtcHRpbmcgdG8gdW5tb3VudCBcIiArICd3YXMgcmVuZGVyZWQgYnkgYW5vdGhlciBjb3B5IG9mIFJlYWN0LicpO1xuICAgICAgfVxuICAgIH0gLy8gVW5tb3VudCBzaG91bGQgbm90IGJlIGJhdGNoZWQuXG5cblxuICAgIHVuYmF0Y2hlZFVwZGF0ZXMoZnVuY3Rpb24gKCkge1xuICAgICAgbGVnYWN5UmVuZGVyU3VidHJlZUludG9Db250YWluZXIobnVsbCwgbnVsbCwgY29udGFpbmVyLCBmYWxzZSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyAkRmxvd0ZpeE1lIFRoaXMgc2hvdWxkIHByb2JhYmx5IHVzZSBgZGVsZXRlIGNvbnRhaW5lci5fcmVhY3RSb290Q29udGFpbmVyYFxuICAgICAgICBjb250YWluZXIuX3JlYWN0Um9vdENvbnRhaW5lciA9IG51bGw7XG4gICAgICAgIHVubWFya0NvbnRhaW5lckFzUm9vdChjb250YWluZXIpO1xuICAgICAgfSk7XG4gICAgfSk7IC8vIElmIHlvdSBjYWxsIHVubW91bnRDb21wb25lbnRBdE5vZGUgdHdpY2UgaW4gcXVpY2sgc3VjY2Vzc2lvbiwgeW91J2xsXG4gICAgLy8gZ2V0IGB0cnVlYCB0d2ljZS4gVGhhdCdzIHByb2JhYmx5IGZpbmU/XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBlbHNlIHtcbiAgICB7XG4gICAgICB2YXIgX3Jvb3RFbCA9IGdldFJlYWN0Um9vdEVsZW1lbnRJbkNvbnRhaW5lcihjb250YWluZXIpO1xuXG4gICAgICB2YXIgaGFzTm9uUm9vdFJlYWN0Q2hpbGQgPSAhIShfcm9vdEVsICYmIGdldEluc3RhbmNlRnJvbU5vZGUoX3Jvb3RFbCkpOyAvLyBDaGVjayBpZiB0aGUgY29udGFpbmVyIGl0c2VsZiBpcyBhIFJlYWN0IHJvb3Qgbm9kZS5cblxuICAgICAgdmFyIGlzQ29udGFpbmVyUmVhY3RSb290ID0gY29udGFpbmVyLm5vZGVUeXBlID09PSBFTEVNRU5UX05PREUgJiYgaXNWYWxpZENvbnRhaW5lcihjb250YWluZXIucGFyZW50Tm9kZSkgJiYgISFjb250YWluZXIucGFyZW50Tm9kZS5fcmVhY3RSb290Q29udGFpbmVyO1xuXG4gICAgICBpZiAoaGFzTm9uUm9vdFJlYWN0Q2hpbGQpIHtcbiAgICAgICAgZXJyb3IoXCJ1bm1vdW50Q29tcG9uZW50QXROb2RlKCk6IFRoZSBub2RlIHlvdSdyZSBhdHRlbXB0aW5nIHRvIHVubW91bnQgXCIgKyAnd2FzIHJlbmRlcmVkIGJ5IFJlYWN0IGFuZCBpcyBub3QgYSB0b3AtbGV2ZWwgY29udGFpbmVyLiAlcycsIGlzQ29udGFpbmVyUmVhY3RSb290ID8gJ1lvdSBtYXkgaGF2ZSBhY2NpZGVudGFsbHkgcGFzc2VkIGluIGEgUmVhY3Qgcm9vdCBub2RlIGluc3RlYWQgJyArICdvZiBpdHMgY29udGFpbmVyLicgOiAnSW5zdGVhZCwgaGF2ZSB0aGUgcGFyZW50IGNvbXBvbmVudCB1cGRhdGUgaXRzIHN0YXRlIGFuZCAnICsgJ3JlcmVuZGVyIGluIG9yZGVyIHRvIHJlbW92ZSB0aGlzIGNvbXBvbmVudC4nKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuc2V0QXR0ZW1wdFVzZXJCbG9ja2luZ0h5ZHJhdGlvbihhdHRlbXB0VXNlckJsb2NraW5nSHlkcmF0aW9uJDEpO1xuc2V0QXR0ZW1wdENvbnRpbnVvdXNIeWRyYXRpb24oYXR0ZW1wdENvbnRpbnVvdXNIeWRyYXRpb24kMSk7XG5zZXRBdHRlbXB0SHlkcmF0aW9uQXRDdXJyZW50UHJpb3JpdHkoYXR0ZW1wdEh5ZHJhdGlvbkF0Q3VycmVudFByaW9yaXR5JDEpO1xuc2V0QXR0ZW1wdEh5ZHJhdGlvbkF0UHJpb3JpdHkocnVuV2l0aFByaW9yaXR5JDIpO1xudmFyIGRpZFdhcm5BYm91dFVuc3RhYmxlQ3JlYXRlUG9ydGFsID0gZmFsc2U7XG5cbntcbiAgaWYgKHR5cGVvZiBNYXAgIT09ICdmdW5jdGlvbicgfHwgLy8gJEZsb3dJc3N1ZSBGbG93IGluY29ycmVjdGx5IHRoaW5rcyBNYXAgaGFzIG5vIHByb3RvdHlwZVxuICBNYXAucHJvdG90eXBlID09IG51bGwgfHwgdHlwZW9mIE1hcC5wcm90b3R5cGUuZm9yRWFjaCAhPT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgU2V0ICE9PSAnZnVuY3Rpb24nIHx8IC8vICRGbG93SXNzdWUgRmxvdyBpbmNvcnJlY3RseSB0aGlua3MgU2V0IGhhcyBubyBwcm90b3R5cGVcbiAgU2V0LnByb3RvdHlwZSA9PSBudWxsIHx8IHR5cGVvZiBTZXQucHJvdG90eXBlLmNsZWFyICE9PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBTZXQucHJvdG90eXBlLmZvckVhY2ggIT09ICdmdW5jdGlvbicpIHtcbiAgICBlcnJvcignUmVhY3QgZGVwZW5kcyBvbiBNYXAgYW5kIFNldCBidWlsdC1pbiB0eXBlcy4gTWFrZSBzdXJlIHRoYXQgeW91IGxvYWQgYSAnICsgJ3BvbHlmaWxsIGluIG9sZGVyIGJyb3dzZXJzLiBodHRwczovL3JlYWN0anMub3JnL2xpbmsvcmVhY3QtcG9seWZpbGxzJyk7XG4gIH1cbn1cblxuc2V0UmVzdG9yZUltcGxlbWVudGF0aW9uKHJlc3RvcmVDb250cm9sbGVkU3RhdGUkMyk7XG5zZXRCYXRjaGluZ0ltcGxlbWVudGF0aW9uKGJhdGNoZWRVcGRhdGVzJDEsIGRpc2NyZXRlVXBkYXRlcyQxLCBmbHVzaERpc2NyZXRlVXBkYXRlcywgYmF0Y2hlZEV2ZW50VXBkYXRlcyQxKTtcblxuZnVuY3Rpb24gY3JlYXRlUG9ydGFsJDEoY2hpbGRyZW4sIGNvbnRhaW5lcikge1xuICB2YXIga2V5ID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBudWxsO1xuXG4gIGlmICghaXNWYWxpZENvbnRhaW5lcihjb250YWluZXIpKSB7XG4gICAge1xuICAgICAgdGhyb3cgRXJyb3IoIFwiVGFyZ2V0IGNvbnRhaW5lciBpcyBub3QgYSBET00gZWxlbWVudC5cIiApO1xuICAgIH1cbiAgfSAvLyBUT0RPOiBwYXNzIFJlYWN0RE9NIHBvcnRhbCBpbXBsZW1lbnRhdGlvbiBhcyB0aGlyZCBhcmd1bWVudFxuICAvLyAkRmxvd0ZpeE1lIFRoZSBGbG93IHR5cGUgaXMgb3BhcXVlIGJ1dCB0aGVyZSdzIG5vIHdheSB0byBhY3R1YWxseSBjcmVhdGUgaXQuXG5cblxuICByZXR1cm4gY3JlYXRlUG9ydGFsKGNoaWxkcmVuLCBjb250YWluZXIsIG51bGwsIGtleSk7XG59XG5cbmZ1bmN0aW9uIHJlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyKHBhcmVudENvbXBvbmVudCwgZWxlbWVudCwgY29udGFpbmVyTm9kZSwgY2FsbGJhY2spIHtcblxuICByZXR1cm4gdW5zdGFibGVfcmVuZGVyU3VidHJlZUludG9Db250YWluZXIocGFyZW50Q29tcG9uZW50LCBlbGVtZW50LCBjb250YWluZXJOb2RlLCBjYWxsYmFjayk7XG59XG5cbmZ1bmN0aW9uIHVuc3RhYmxlX2NyZWF0ZVBvcnRhbChjaGlsZHJlbiwgY29udGFpbmVyKSB7XG4gIHZhciBrZXkgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IG51bGw7XG5cbiAge1xuICAgIGlmICghZGlkV2FybkFib3V0VW5zdGFibGVDcmVhdGVQb3J0YWwpIHtcbiAgICAgIGRpZFdhcm5BYm91dFVuc3RhYmxlQ3JlYXRlUG9ydGFsID0gdHJ1ZTtcblxuICAgICAgd2FybignVGhlIFJlYWN0RE9NLnVuc3RhYmxlX2NyZWF0ZVBvcnRhbCgpIGFsaWFzIGhhcyBiZWVuIGRlcHJlY2F0ZWQsICcgKyAnYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiBSZWFjdCAxOCsuIFVwZGF0ZSB5b3VyIGNvZGUgdG8gdXNlICcgKyAnUmVhY3RET00uY3JlYXRlUG9ydGFsKCkgaW5zdGVhZC4gSXQgaGFzIHRoZSBleGFjdCBzYW1lIEFQSSwgJyArICdidXQgd2l0aG91dCB0aGUgXCJ1bnN0YWJsZV9cIiBwcmVmaXguJyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGNyZWF0ZVBvcnRhbCQxKGNoaWxkcmVuLCBjb250YWluZXIsIGtleSk7XG59XG5cbnZhciBJbnRlcm5hbHMgPSB7XG4gIC8vIEtlZXAgaW4gc3luYyB3aXRoIFJlYWN0VGVzdFV0aWxzLmpzLCBhbmQgUmVhY3RUZXN0VXRpbHNBY3QuanMuXG4gIC8vIFRoaXMgaXMgYW4gYXJyYXkgZm9yIGJldHRlciBtaW5pZmljYXRpb24uXG4gIEV2ZW50czogW2dldEluc3RhbmNlRnJvbU5vZGUsIGdldE5vZGVGcm9tSW5zdGFuY2UsIGdldEZpYmVyQ3VycmVudFByb3BzRnJvbU5vZGUsIGVucXVldWVTdGF0ZVJlc3RvcmUsIHJlc3RvcmVTdGF0ZUlmTmVlZGVkLCBmbHVzaFBhc3NpdmVFZmZlY3RzLCAvLyBUT0RPOiBUaGlzIGlzIHJlbGF0ZWQgdG8gYGFjdGAsIG5vdCBldmVudHMuIE1vdmUgdG8gc2VwYXJhdGUga2V5P1xuICBJc1RoaXNSZW5kZXJlckFjdGluZ11cbn07XG52YXIgZm91bmREZXZUb29scyA9IGluamVjdEludG9EZXZUb29scyh7XG4gIGZpbmRGaWJlckJ5SG9zdEluc3RhbmNlOiBnZXRDbG9zZXN0SW5zdGFuY2VGcm9tTm9kZSxcbiAgYnVuZGxlVHlwZTogIDEgLFxuICB2ZXJzaW9uOiBSZWFjdFZlcnNpb24sXG4gIHJlbmRlcmVyUGFja2FnZU5hbWU6ICdyZWFjdC1kb20nXG59KTtcblxue1xuICBpZiAoIWZvdW5kRGV2VG9vbHMgJiYgY2FuVXNlRE9NICYmIHdpbmRvdy50b3AgPT09IHdpbmRvdy5zZWxmKSB7XG4gICAgLy8gSWYgd2UncmUgaW4gQ2hyb21lIG9yIEZpcmVmb3gsIHByb3ZpZGUgYSBkb3dubG9hZCBsaW5rIGlmIG5vdCBpbnN0YWxsZWQuXG4gICAgaWYgKG5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZignQ2hyb21lJykgPiAtMSAmJiBuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoJ0VkZ2UnKSA9PT0gLTEgfHwgbmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKCdGaXJlZm94JykgPiAtMSkge1xuICAgICAgdmFyIHByb3RvY29sID0gd2luZG93LmxvY2F0aW9uLnByb3RvY29sOyAvLyBEb24ndCB3YXJuIGluIGV4b3RpYyBjYXNlcyBsaWtlIGNocm9tZS1leHRlbnNpb246Ly8uXG5cbiAgICAgIGlmICgvXihodHRwcz98ZmlsZSk6JC8udGVzdChwcm90b2NvbCkpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZ1xuICAgICAgICBjb25zb2xlLmluZm8oJyVjRG93bmxvYWQgdGhlIFJlYWN0IERldlRvb2xzICcgKyAnZm9yIGEgYmV0dGVyIGRldmVsb3BtZW50IGV4cGVyaWVuY2U6ICcgKyAnaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3JlYWN0LWRldnRvb2xzJyArIChwcm90b2NvbCA9PT0gJ2ZpbGU6JyA/ICdcXG5Zb3UgbWlnaHQgbmVlZCB0byB1c2UgYSBsb2NhbCBIVFRQIHNlcnZlciAoaW5zdGVhZCBvZiBmaWxlOi8vKTogJyArICdodHRwczovL3JlYWN0anMub3JnL2xpbmsvcmVhY3QtZGV2dG9vbHMtZmFxJyA6ICcnKSwgJ2ZvbnQtd2VpZ2h0OmJvbGQnKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0cy5fX1NFQ1JFVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRCA9IEludGVybmFscztcbmV4cG9ydHMuY3JlYXRlUG9ydGFsID0gY3JlYXRlUG9ydGFsJDE7XG5leHBvcnRzLmZpbmRET01Ob2RlID0gZmluZERPTU5vZGU7XG5leHBvcnRzLmZsdXNoU3luYyA9IGZsdXNoU3luYztcbmV4cG9ydHMuaHlkcmF0ZSA9IGh5ZHJhdGU7XG5leHBvcnRzLnJlbmRlciA9IHJlbmRlcjtcbmV4cG9ydHMudW5tb3VudENvbXBvbmVudEF0Tm9kZSA9IHVubW91bnRDb21wb25lbnRBdE5vZGU7XG5leHBvcnRzLnVuc3RhYmxlX2JhdGNoZWRVcGRhdGVzID0gYmF0Y2hlZFVwZGF0ZXMkMTtcbmV4cG9ydHMudW5zdGFibGVfY3JlYXRlUG9ydGFsID0gdW5zdGFibGVfY3JlYXRlUG9ydGFsO1xuZXhwb3J0cy51bnN0YWJsZV9yZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lciA9IHJlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyO1xuZXhwb3J0cy52ZXJzaW9uID0gUmVhY3RWZXJzaW9uO1xuICB9KSgpO1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBjaGVja0RDRSgpIHtcbiAgLyogZ2xvYmFsIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXyAqL1xuICBpZiAoXG4gICAgdHlwZW9mIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXyA9PT0gJ3VuZGVmaW5lZCcgfHxcbiAgICB0eXBlb2YgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fLmNoZWNrRENFICE9PSAnZnVuY3Rpb24nXG4gICkge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIC8vIFRoaXMgYnJhbmNoIGlzIHVucmVhY2hhYmxlIGJlY2F1c2UgdGhpcyBmdW5jdGlvbiBpcyBvbmx5IGNhbGxlZFxuICAgIC8vIGluIHByb2R1Y3Rpb24sIGJ1dCB0aGUgY29uZGl0aW9uIGlzIHRydWUgb25seSBpbiBkZXZlbG9wbWVudC5cbiAgICAvLyBUaGVyZWZvcmUgaWYgdGhlIGJyYW5jaCBpcyBzdGlsbCBoZXJlLCBkZWFkIGNvZGUgZWxpbWluYXRpb24gd2Fzbid0XG4gICAgLy8gcHJvcGVybHkgYXBwbGllZC5cbiAgICAvLyBEb24ndCBjaGFuZ2UgdGhlIG1lc3NhZ2UuIFJlYWN0IERldlRvb2xzIHJlbGllcyBvbiBpdC4gQWxzbyBtYWtlIHN1cmVcbiAgICAvLyB0aGlzIG1lc3NhZ2UgZG9lc24ndCBvY2N1ciBlbHNld2hlcmUgaW4gdGhpcyBmdW5jdGlvbiwgb3IgaXQgd2lsbCBjYXVzZVxuICAgIC8vIGEgZmFsc2UgcG9zaXRpdmUuXG4gICAgdGhyb3cgbmV3IEVycm9yKCdeX14nKTtcbiAgfVxuICB0cnkge1xuICAgIC8vIFZlcmlmeSB0aGF0IHRoZSBjb2RlIGFib3ZlIGhhcyBiZWVuIGRlYWQgY29kZSBlbGltaW5hdGVkIChEQ0UnZCkuXG4gICAgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fLmNoZWNrRENFKGNoZWNrRENFKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgLy8gRGV2VG9vbHMgc2hvdWxkbid0IGNyYXNoIFJlYWN0LCBubyBtYXR0ZXIgd2hhdC5cbiAgICAvLyBXZSBzaG91bGQgc3RpbGwgcmVwb3J0IGluIGNhc2Ugd2UgYnJlYWsgdGhpcyBjb2RlLlxuICAgIGNvbnNvbGUuZXJyb3IoZXJyKTtcbiAgfVxufVxuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJykge1xuICAvLyBEQ0UgY2hlY2sgc2hvdWxkIGhhcHBlbiBiZWZvcmUgUmVhY3RET00gYnVuZGxlIGV4ZWN1dGVzIHNvIHRoYXRcbiAgLy8gRGV2VG9vbHMgY2FuIHJlcG9ydCBiYWQgbWluaWZpY2F0aW9uIGR1cmluZyBpbmplY3Rpb24uXG4gIGNoZWNrRENFKCk7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtZG9tLnByb2R1Y3Rpb24ubWluLmpzJyk7XG59IGVsc2Uge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3JlYWN0LWRvbS5kZXZlbG9wbWVudC5qcycpO1xufVxuIiwiLyoqIEBsaWNlbnNlIFJlYWN0IHYxNy4wLjJcbiAqIHJlYWN0LmRldmVsb3BtZW50LmpzXG4gKlxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gIChmdW5jdGlvbigpIHtcbid1c2Ugc3RyaWN0JztcblxudmFyIF9hc3NpZ24gPSByZXF1aXJlKCdvYmplY3QtYXNzaWduJyk7XG5cbi8vIFRPRE86IHRoaXMgaXMgc3BlY2lhbCBiZWNhdXNlIGl0IGdldHMgaW1wb3J0ZWQgZHVyaW5nIGJ1aWxkLlxudmFyIFJlYWN0VmVyc2lvbiA9ICcxNy4wLjInO1xuXG4vLyBBVFRFTlRJT05cbi8vIFdoZW4gYWRkaW5nIG5ldyBzeW1ib2xzIHRvIHRoaXMgZmlsZSxcbi8vIFBsZWFzZSBjb25zaWRlciBhbHNvIGFkZGluZyB0byAncmVhY3QtZGV2dG9vbHMtc2hhcmVkL3NyYy9iYWNrZW5kL1JlYWN0U3ltYm9scydcbi8vIFRoZSBTeW1ib2wgdXNlZCB0byB0YWcgdGhlIFJlYWN0RWxlbWVudC1saWtlIHR5cGVzLiBJZiB0aGVyZSBpcyBubyBuYXRpdmUgU3ltYm9sXG4vLyBub3IgcG9seWZpbGwsIHRoZW4gYSBwbGFpbiBudW1iZXIgaXMgdXNlZCBmb3IgcGVyZm9ybWFuY2UuXG52YXIgUkVBQ1RfRUxFTUVOVF9UWVBFID0gMHhlYWM3O1xudmFyIFJFQUNUX1BPUlRBTF9UWVBFID0gMHhlYWNhO1xuZXhwb3J0cy5GcmFnbWVudCA9IDB4ZWFjYjtcbmV4cG9ydHMuU3RyaWN0TW9kZSA9IDB4ZWFjYztcbmV4cG9ydHMuUHJvZmlsZXIgPSAweGVhZDI7XG52YXIgUkVBQ1RfUFJPVklERVJfVFlQRSA9IDB4ZWFjZDtcbnZhciBSRUFDVF9DT05URVhUX1RZUEUgPSAweGVhY2U7XG52YXIgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSA9IDB4ZWFkMDtcbmV4cG9ydHMuU3VzcGVuc2UgPSAweGVhZDE7XG52YXIgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFID0gMHhlYWQ4O1xudmFyIFJFQUNUX01FTU9fVFlQRSA9IDB4ZWFkMztcbnZhciBSRUFDVF9MQVpZX1RZUEUgPSAweGVhZDQ7XG52YXIgUkVBQ1RfQkxPQ0tfVFlQRSA9IDB4ZWFkOTtcbnZhciBSRUFDVF9TRVJWRVJfQkxPQ0tfVFlQRSA9IDB4ZWFkYTtcbnZhciBSRUFDVF9GVU5EQU1FTlRBTF9UWVBFID0gMHhlYWQ1O1xudmFyIFJFQUNUX1NDT1BFX1RZUEUgPSAweGVhZDc7XG52YXIgUkVBQ1RfT1BBUVVFX0lEX1RZUEUgPSAweGVhZTA7XG52YXIgUkVBQ1RfREVCVUdfVFJBQ0lOR19NT0RFX1RZUEUgPSAweGVhZTE7XG52YXIgUkVBQ1RfT0ZGU0NSRUVOX1RZUEUgPSAweGVhZTI7XG52YXIgUkVBQ1RfTEVHQUNZX0hJRERFTl9UWVBFID0gMHhlYWUzO1xuXG5pZiAodHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2wuZm9yKSB7XG4gIHZhciBzeW1ib2xGb3IgPSBTeW1ib2wuZm9yO1xuICBSRUFDVF9FTEVNRU5UX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LmVsZW1lbnQnKTtcbiAgUkVBQ1RfUE9SVEFMX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LnBvcnRhbCcpO1xuICBleHBvcnRzLkZyYWdtZW50ID0gc3ltYm9sRm9yKCdyZWFjdC5mcmFnbWVudCcpO1xuICBleHBvcnRzLlN0cmljdE1vZGUgPSBzeW1ib2xGb3IoJ3JlYWN0LnN0cmljdF9tb2RlJyk7XG4gIGV4cG9ydHMuUHJvZmlsZXIgPSBzeW1ib2xGb3IoJ3JlYWN0LnByb2ZpbGVyJyk7XG4gIFJFQUNUX1BST1ZJREVSX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LnByb3ZpZGVyJyk7XG4gIFJFQUNUX0NPTlRFWFRfVFlQRSA9IHN5bWJvbEZvcigncmVhY3QuY29udGV4dCcpO1xuICBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5mb3J3YXJkX3JlZicpO1xuICBleHBvcnRzLlN1c3BlbnNlID0gc3ltYm9sRm9yKCdyZWFjdC5zdXNwZW5zZScpO1xuICBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LnN1c3BlbnNlX2xpc3QnKTtcbiAgUkVBQ1RfTUVNT19UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5tZW1vJyk7XG4gIFJFQUNUX0xBWllfVFlQRSA9IHN5bWJvbEZvcigncmVhY3QubGF6eScpO1xuICBSRUFDVF9CTE9DS19UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5ibG9jaycpO1xuICBSRUFDVF9TRVJWRVJfQkxPQ0tfVFlQRSA9IHN5bWJvbEZvcigncmVhY3Quc2VydmVyLmJsb2NrJyk7XG4gIFJFQUNUX0ZVTkRBTUVOVEFMX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LmZ1bmRhbWVudGFsJyk7XG4gIFJFQUNUX1NDT1BFX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LnNjb3BlJyk7XG4gIFJFQUNUX09QQVFVRV9JRF9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5vcGFxdWUuaWQnKTtcbiAgUkVBQ1RfREVCVUdfVFJBQ0lOR19NT0RFX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LmRlYnVnX3RyYWNlX21vZGUnKTtcbiAgUkVBQ1RfT0ZGU0NSRUVOX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0Lm9mZnNjcmVlbicpO1xuICBSRUFDVF9MRUdBQ1lfSElEREVOX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LmxlZ2FjeV9oaWRkZW4nKTtcbn1cblxudmFyIE1BWUJFX0lURVJBVE9SX1NZTUJPTCA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLml0ZXJhdG9yO1xudmFyIEZBVVhfSVRFUkFUT1JfU1lNQk9MID0gJ0BAaXRlcmF0b3InO1xuZnVuY3Rpb24gZ2V0SXRlcmF0b3JGbihtYXliZUl0ZXJhYmxlKSB7XG4gIGlmIChtYXliZUl0ZXJhYmxlID09PSBudWxsIHx8IHR5cGVvZiBtYXliZUl0ZXJhYmxlICE9PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIG1heWJlSXRlcmF0b3IgPSBNQVlCRV9JVEVSQVRPUl9TWU1CT0wgJiYgbWF5YmVJdGVyYWJsZVtNQVlCRV9JVEVSQVRPUl9TWU1CT0xdIHx8IG1heWJlSXRlcmFibGVbRkFVWF9JVEVSQVRPUl9TWU1CT0xdO1xuXG4gIGlmICh0eXBlb2YgbWF5YmVJdGVyYXRvciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBtYXliZUl0ZXJhdG9yO1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbi8qKlxuICogS2VlcHMgdHJhY2sgb2YgdGhlIGN1cnJlbnQgZGlzcGF0Y2hlci5cbiAqL1xudmFyIFJlYWN0Q3VycmVudERpc3BhdGNoZXIgPSB7XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICogQHR5cGUge1JlYWN0Q29tcG9uZW50fVxuICAgKi9cbiAgY3VycmVudDogbnVsbFxufTtcblxuLyoqXG4gKiBLZWVwcyB0cmFjayBvZiB0aGUgY3VycmVudCBiYXRjaCdzIGNvbmZpZ3VyYXRpb24gc3VjaCBhcyBob3cgbG9uZyBhbiB1cGRhdGVcbiAqIHNob3VsZCBzdXNwZW5kIGZvciBpZiBpdCBuZWVkcyB0by5cbiAqL1xudmFyIFJlYWN0Q3VycmVudEJhdGNoQ29uZmlnID0ge1xuICB0cmFuc2l0aW9uOiAwXG59O1xuXG4vKipcbiAqIEtlZXBzIHRyYWNrIG9mIHRoZSBjdXJyZW50IG93bmVyLlxuICpcbiAqIFRoZSBjdXJyZW50IG93bmVyIGlzIHRoZSBjb21wb25lbnQgd2hvIHNob3VsZCBvd24gYW55IGNvbXBvbmVudHMgdGhhdCBhcmVcbiAqIGN1cnJlbnRseSBiZWluZyBjb25zdHJ1Y3RlZC5cbiAqL1xudmFyIFJlYWN0Q3VycmVudE93bmVyID0ge1xuICAvKipcbiAgICogQGludGVybmFsXG4gICAqIEB0eXBlIHtSZWFjdENvbXBvbmVudH1cbiAgICovXG4gIGN1cnJlbnQ6IG51bGxcbn07XG5cbnZhciBSZWFjdERlYnVnQ3VycmVudEZyYW1lID0ge307XG52YXIgY3VycmVudEV4dHJhU3RhY2tGcmFtZSA9IG51bGw7XG5mdW5jdGlvbiBzZXRFeHRyYVN0YWNrRnJhbWUoc3RhY2spIHtcbiAge1xuICAgIGN1cnJlbnRFeHRyYVN0YWNrRnJhbWUgPSBzdGFjaztcbiAgfVxufVxuXG57XG4gIFJlYWN0RGVidWdDdXJyZW50RnJhbWUuc2V0RXh0cmFTdGFja0ZyYW1lID0gZnVuY3Rpb24gKHN0YWNrKSB7XG4gICAge1xuICAgICAgY3VycmVudEV4dHJhU3RhY2tGcmFtZSA9IHN0YWNrO1xuICAgIH1cbiAgfTsgLy8gU3RhY2sgaW1wbGVtZW50YXRpb24gaW5qZWN0ZWQgYnkgdGhlIGN1cnJlbnQgcmVuZGVyZXIuXG5cblxuICBSZWFjdERlYnVnQ3VycmVudEZyYW1lLmdldEN1cnJlbnRTdGFjayA9IG51bGw7XG5cbiAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5nZXRTdGFja0FkZGVuZHVtID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBzdGFjayA9ICcnOyAvLyBBZGQgYW4gZXh0cmEgdG9wIGZyYW1lIHdoaWxlIGFuIGVsZW1lbnQgaXMgYmVpbmcgdmFsaWRhdGVkXG5cbiAgICBpZiAoY3VycmVudEV4dHJhU3RhY2tGcmFtZSkge1xuICAgICAgc3RhY2sgKz0gY3VycmVudEV4dHJhU3RhY2tGcmFtZTtcbiAgICB9IC8vIERlbGVnYXRlIHRvIHRoZSBpbmplY3RlZCByZW5kZXJlci1zcGVjaWZpYyBpbXBsZW1lbnRhdGlvblxuXG5cbiAgICB2YXIgaW1wbCA9IFJlYWN0RGVidWdDdXJyZW50RnJhbWUuZ2V0Q3VycmVudFN0YWNrO1xuXG4gICAgaWYgKGltcGwpIHtcbiAgICAgIHN0YWNrICs9IGltcGwoKSB8fCAnJztcbiAgICB9XG5cbiAgICByZXR1cm4gc3RhY2s7XG4gIH07XG59XG5cbi8qKlxuICogVXNlZCBieSBhY3QoKSB0byB0cmFjayB3aGV0aGVyIHlvdSdyZSBpbnNpZGUgYW4gYWN0KCkgc2NvcGUuXG4gKi9cbnZhciBJc1NvbWVSZW5kZXJlckFjdGluZyA9IHtcbiAgY3VycmVudDogZmFsc2Vcbn07XG5cbnZhciBSZWFjdFNoYXJlZEludGVybmFscyA9IHtcbiAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlcjogUmVhY3RDdXJyZW50RGlzcGF0Y2hlcixcbiAgUmVhY3RDdXJyZW50QmF0Y2hDb25maWc6IFJlYWN0Q3VycmVudEJhdGNoQ29uZmlnLFxuICBSZWFjdEN1cnJlbnRPd25lcjogUmVhY3RDdXJyZW50T3duZXIsXG4gIElzU29tZVJlbmRlcmVyQWN0aW5nOiBJc1NvbWVSZW5kZXJlckFjdGluZyxcbiAgLy8gVXNlZCBieSByZW5kZXJlcnMgdG8gYXZvaWQgYnVuZGxpbmcgb2JqZWN0LWFzc2lnbiB0d2ljZSBpbiBVTUQgYnVuZGxlczpcbiAgYXNzaWduOiBfYXNzaWduXG59O1xuXG57XG4gIFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0RGVidWdDdXJyZW50RnJhbWUgPSBSZWFjdERlYnVnQ3VycmVudEZyYW1lO1xufVxuXG4vLyBieSBjYWxscyB0byB0aGVzZSBtZXRob2RzIGJ5IGEgQmFiZWwgcGx1Z2luLlxuLy9cbi8vIEluIFBST0QgKG9yIGluIHBhY2thZ2VzIHdpdGhvdXQgYWNjZXNzIHRvIFJlYWN0IGludGVybmFscyksXG4vLyB0aGV5IGFyZSBsZWZ0IGFzIHRoZXkgYXJlIGluc3RlYWQuXG5cbmZ1bmN0aW9uIHdhcm4oZm9ybWF0KSB7XG4gIHtcbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICBwcmludFdhcm5pbmcoJ3dhcm4nLCBmb3JtYXQsIGFyZ3MpO1xuICB9XG59XG5mdW5jdGlvbiBlcnJvcihmb3JtYXQpIHtcbiAge1xuICAgIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMiA+IDEgPyBfbGVuMiAtIDEgOiAwKSwgX2tleTIgPSAxOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICBhcmdzW19rZXkyIC0gMV0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgIH1cblxuICAgIHByaW50V2FybmluZygnZXJyb3InLCBmb3JtYXQsIGFyZ3MpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHByaW50V2FybmluZyhsZXZlbCwgZm9ybWF0LCBhcmdzKSB7XG4gIC8vIFdoZW4gY2hhbmdpbmcgdGhpcyBsb2dpYywgeW91IG1pZ2h0IHdhbnQgdG8gYWxzb1xuICAvLyB1cGRhdGUgY29uc29sZVdpdGhTdGFja0Rldi53d3cuanMgYXMgd2VsbC5cbiAge1xuICAgIHZhciBSZWFjdERlYnVnQ3VycmVudEZyYW1lID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZTtcbiAgICB2YXIgc3RhY2sgPSBSZWFjdERlYnVnQ3VycmVudEZyYW1lLmdldFN0YWNrQWRkZW5kdW0oKTtcblxuICAgIGlmIChzdGFjayAhPT0gJycpIHtcbiAgICAgIGZvcm1hdCArPSAnJXMnO1xuICAgICAgYXJncyA9IGFyZ3MuY29uY2F0KFtzdGFja10pO1xuICAgIH1cblxuICAgIHZhciBhcmdzV2l0aEZvcm1hdCA9IGFyZ3MubWFwKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICByZXR1cm4gJycgKyBpdGVtO1xuICAgIH0pOyAvLyBDYXJlZnVsOiBSTiBjdXJyZW50bHkgZGVwZW5kcyBvbiB0aGlzIHByZWZpeFxuXG4gICAgYXJnc1dpdGhGb3JtYXQudW5zaGlmdCgnV2FybmluZzogJyArIGZvcm1hdCk7IC8vIFdlIGludGVudGlvbmFsbHkgZG9uJ3QgdXNlIHNwcmVhZCAob3IgLmFwcGx5KSBkaXJlY3RseSBiZWNhdXNlIGl0XG4gICAgLy8gYnJlYWtzIElFOTogaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xMzYxMFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9uby1wcm9kdWN0aW9uLWxvZ2dpbmdcblxuICAgIEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseS5jYWxsKGNvbnNvbGVbbGV2ZWxdLCBjb25zb2xlLCBhcmdzV2l0aEZvcm1hdCk7XG4gIH1cbn1cblxudmFyIGRpZFdhcm5TdGF0ZVVwZGF0ZUZvclVubW91bnRlZENvbXBvbmVudCA9IHt9O1xuXG5mdW5jdGlvbiB3YXJuTm9vcChwdWJsaWNJbnN0YW5jZSwgY2FsbGVyTmFtZSkge1xuICB7XG4gICAgdmFyIF9jb25zdHJ1Y3RvciA9IHB1YmxpY0luc3RhbmNlLmNvbnN0cnVjdG9yO1xuICAgIHZhciBjb21wb25lbnROYW1lID0gX2NvbnN0cnVjdG9yICYmIChfY29uc3RydWN0b3IuZGlzcGxheU5hbWUgfHwgX2NvbnN0cnVjdG9yLm5hbWUpIHx8ICdSZWFjdENsYXNzJztcbiAgICB2YXIgd2FybmluZ0tleSA9IGNvbXBvbmVudE5hbWUgKyBcIi5cIiArIGNhbGxlck5hbWU7XG5cbiAgICBpZiAoZGlkV2FyblN0YXRlVXBkYXRlRm9yVW5tb3VudGVkQ29tcG9uZW50W3dhcm5pbmdLZXldKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZXJyb3IoXCJDYW4ndCBjYWxsICVzIG9uIGEgY29tcG9uZW50IHRoYXQgaXMgbm90IHlldCBtb3VudGVkLiBcIiArICdUaGlzIGlzIGEgbm8tb3AsIGJ1dCBpdCBtaWdodCBpbmRpY2F0ZSBhIGJ1ZyBpbiB5b3VyIGFwcGxpY2F0aW9uLiAnICsgJ0luc3RlYWQsIGFzc2lnbiB0byBgdGhpcy5zdGF0ZWAgZGlyZWN0bHkgb3IgZGVmaW5lIGEgYHN0YXRlID0ge307YCAnICsgJ2NsYXNzIHByb3BlcnR5IHdpdGggdGhlIGRlc2lyZWQgc3RhdGUgaW4gdGhlICVzIGNvbXBvbmVudC4nLCBjYWxsZXJOYW1lLCBjb21wb25lbnROYW1lKTtcblxuICAgIGRpZFdhcm5TdGF0ZVVwZGF0ZUZvclVubW91bnRlZENvbXBvbmVudFt3YXJuaW5nS2V5XSA9IHRydWU7XG4gIH1cbn1cbi8qKlxuICogVGhpcyBpcyB0aGUgYWJzdHJhY3QgQVBJIGZvciBhbiB1cGRhdGUgcXVldWUuXG4gKi9cblxuXG52YXIgUmVhY3ROb29wVXBkYXRlUXVldWUgPSB7XG4gIC8qKlxuICAgKiBDaGVja3Mgd2hldGhlciBvciBub3QgdGhpcyBjb21wb3NpdGUgY29tcG9uZW50IGlzIG1vdW50ZWQuXG4gICAqIEBwYXJhbSB7UmVhY3RDbGFzc30gcHVibGljSW5zdGFuY2UgVGhlIGluc3RhbmNlIHdlIHdhbnQgdG8gdGVzdC5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBtb3VudGVkLCBmYWxzZSBvdGhlcndpc2UuXG4gICAqIEBwcm90ZWN0ZWRcbiAgICogQGZpbmFsXG4gICAqL1xuICBpc01vdW50ZWQ6IGZ1bmN0aW9uIChwdWJsaWNJbnN0YW5jZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSxcblxuICAvKipcbiAgICogRm9yY2VzIGFuIHVwZGF0ZS4gVGhpcyBzaG91bGQgb25seSBiZSBpbnZva2VkIHdoZW4gaXQgaXMga25vd24gd2l0aFxuICAgKiBjZXJ0YWludHkgdGhhdCB3ZSBhcmUgKipub3QqKiBpbiBhIERPTSB0cmFuc2FjdGlvbi5cbiAgICpcbiAgICogWW91IG1heSB3YW50IHRvIGNhbGwgdGhpcyB3aGVuIHlvdSBrbm93IHRoYXQgc29tZSBkZWVwZXIgYXNwZWN0IG9mIHRoZVxuICAgKiBjb21wb25lbnQncyBzdGF0ZSBoYXMgY2hhbmdlZCBidXQgYHNldFN0YXRlYCB3YXMgbm90IGNhbGxlZC5cbiAgICpcbiAgICogVGhpcyB3aWxsIG5vdCBpbnZva2UgYHNob3VsZENvbXBvbmVudFVwZGF0ZWAsIGJ1dCBpdCB3aWxsIGludm9rZVxuICAgKiBgY29tcG9uZW50V2lsbFVwZGF0ZWAgYW5kIGBjb21wb25lbnREaWRVcGRhdGVgLlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0Q2xhc3N9IHB1YmxpY0luc3RhbmNlIFRoZSBpbnN0YW5jZSB0aGF0IHNob3VsZCByZXJlbmRlci5cbiAgICogQHBhcmFtIHs/ZnVuY3Rpb259IGNhbGxiYWNrIENhbGxlZCBhZnRlciBjb21wb25lbnQgaXMgdXBkYXRlZC5cbiAgICogQHBhcmFtIHs/c3RyaW5nfSBjYWxsZXJOYW1lIG5hbWUgb2YgdGhlIGNhbGxpbmcgZnVuY3Rpb24gaW4gdGhlIHB1YmxpYyBBUEkuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZW5xdWV1ZUZvcmNlVXBkYXRlOiBmdW5jdGlvbiAocHVibGljSW5zdGFuY2UsIGNhbGxiYWNrLCBjYWxsZXJOYW1lKSB7XG4gICAgd2Fybk5vb3AocHVibGljSW5zdGFuY2UsICdmb3JjZVVwZGF0ZScpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZXBsYWNlcyBhbGwgb2YgdGhlIHN0YXRlLiBBbHdheXMgdXNlIHRoaXMgb3IgYHNldFN0YXRlYCB0byBtdXRhdGUgc3RhdGUuXG4gICAqIFlvdSBzaG91bGQgdHJlYXQgYHRoaXMuc3RhdGVgIGFzIGltbXV0YWJsZS5cbiAgICpcbiAgICogVGhlcmUgaXMgbm8gZ3VhcmFudGVlIHRoYXQgYHRoaXMuc3RhdGVgIHdpbGwgYmUgaW1tZWRpYXRlbHkgdXBkYXRlZCwgc29cbiAgICogYWNjZXNzaW5nIGB0aGlzLnN0YXRlYCBhZnRlciBjYWxsaW5nIHRoaXMgbWV0aG9kIG1heSByZXR1cm4gdGhlIG9sZCB2YWx1ZS5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdENsYXNzfSBwdWJsaWNJbnN0YW5jZSBUaGUgaW5zdGFuY2UgdGhhdCBzaG91bGQgcmVyZW5kZXIuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBjb21wbGV0ZVN0YXRlIE5leHQgc3RhdGUuXG4gICAqIEBwYXJhbSB7P2Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsZWQgYWZ0ZXIgY29tcG9uZW50IGlzIHVwZGF0ZWQuXG4gICAqIEBwYXJhbSB7P3N0cmluZ30gY2FsbGVyTmFtZSBuYW1lIG9mIHRoZSBjYWxsaW5nIGZ1bmN0aW9uIGluIHRoZSBwdWJsaWMgQVBJLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGVucXVldWVSZXBsYWNlU3RhdGU6IGZ1bmN0aW9uIChwdWJsaWNJbnN0YW5jZSwgY29tcGxldGVTdGF0ZSwgY2FsbGJhY2ssIGNhbGxlck5hbWUpIHtcbiAgICB3YXJuTm9vcChwdWJsaWNJbnN0YW5jZSwgJ3JlcGxhY2VTdGF0ZScpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBTZXRzIGEgc3Vic2V0IG9mIHRoZSBzdGF0ZS4gVGhpcyBvbmx5IGV4aXN0cyBiZWNhdXNlIF9wZW5kaW5nU3RhdGUgaXNcbiAgICogaW50ZXJuYWwuIFRoaXMgcHJvdmlkZXMgYSBtZXJnaW5nIHN0cmF0ZWd5IHRoYXQgaXMgbm90IGF2YWlsYWJsZSB0byBkZWVwXG4gICAqIHByb3BlcnRpZXMgd2hpY2ggaXMgY29uZnVzaW5nLiBUT0RPOiBFeHBvc2UgcGVuZGluZ1N0YXRlIG9yIGRvbid0IHVzZSBpdFxuICAgKiBkdXJpbmcgdGhlIG1lcmdlLlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0Q2xhc3N9IHB1YmxpY0luc3RhbmNlIFRoZSBpbnN0YW5jZSB0aGF0IHNob3VsZCByZXJlbmRlci5cbiAgICogQHBhcmFtIHtvYmplY3R9IHBhcnRpYWxTdGF0ZSBOZXh0IHBhcnRpYWwgc3RhdGUgdG8gYmUgbWVyZ2VkIHdpdGggc3RhdGUuXG4gICAqIEBwYXJhbSB7P2Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsZWQgYWZ0ZXIgY29tcG9uZW50IGlzIHVwZGF0ZWQuXG4gICAqIEBwYXJhbSB7P3N0cmluZ30gTmFtZSBvZiB0aGUgY2FsbGluZyBmdW5jdGlvbiBpbiB0aGUgcHVibGljIEFQSS5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBlbnF1ZXVlU2V0U3RhdGU6IGZ1bmN0aW9uIChwdWJsaWNJbnN0YW5jZSwgcGFydGlhbFN0YXRlLCBjYWxsYmFjaywgY2FsbGVyTmFtZSkge1xuICAgIHdhcm5Ob29wKHB1YmxpY0luc3RhbmNlLCAnc2V0U3RhdGUnKTtcbiAgfVxufTtcblxudmFyIGVtcHR5T2JqZWN0ID0ge307XG5cbntcbiAgT2JqZWN0LmZyZWV6ZShlbXB0eU9iamVjdCk7XG59XG4vKipcbiAqIEJhc2UgY2xhc3MgaGVscGVycyBmb3IgdGhlIHVwZGF0aW5nIHN0YXRlIG9mIGEgY29tcG9uZW50LlxuICovXG5cblxuZnVuY3Rpb24gQ29tcG9uZW50KHByb3BzLCBjb250ZXh0LCB1cGRhdGVyKSB7XG4gIHRoaXMucHJvcHMgPSBwcm9wcztcbiAgdGhpcy5jb250ZXh0ID0gY29udGV4dDsgLy8gSWYgYSBjb21wb25lbnQgaGFzIHN0cmluZyByZWZzLCB3ZSB3aWxsIGFzc2lnbiBhIGRpZmZlcmVudCBvYmplY3QgbGF0ZXIuXG5cbiAgdGhpcy5yZWZzID0gZW1wdHlPYmplY3Q7IC8vIFdlIGluaXRpYWxpemUgdGhlIGRlZmF1bHQgdXBkYXRlciBidXQgdGhlIHJlYWwgb25lIGdldHMgaW5qZWN0ZWQgYnkgdGhlXG4gIC8vIHJlbmRlcmVyLlxuXG4gIHRoaXMudXBkYXRlciA9IHVwZGF0ZXIgfHwgUmVhY3ROb29wVXBkYXRlUXVldWU7XG59XG5cbkNvbXBvbmVudC5wcm90b3R5cGUuaXNSZWFjdENvbXBvbmVudCA9IHt9O1xuLyoqXG4gKiBTZXRzIGEgc3Vic2V0IG9mIHRoZSBzdGF0ZS4gQWx3YXlzIHVzZSB0aGlzIHRvIG11dGF0ZVxuICogc3RhdGUuIFlvdSBzaG91bGQgdHJlYXQgYHRoaXMuc3RhdGVgIGFzIGltbXV0YWJsZS5cbiAqXG4gKiBUaGVyZSBpcyBubyBndWFyYW50ZWUgdGhhdCBgdGhpcy5zdGF0ZWAgd2lsbCBiZSBpbW1lZGlhdGVseSB1cGRhdGVkLCBzb1xuICogYWNjZXNzaW5nIGB0aGlzLnN0YXRlYCBhZnRlciBjYWxsaW5nIHRoaXMgbWV0aG9kIG1heSByZXR1cm4gdGhlIG9sZCB2YWx1ZS5cbiAqXG4gKiBUaGVyZSBpcyBubyBndWFyYW50ZWUgdGhhdCBjYWxscyB0byBgc2V0U3RhdGVgIHdpbGwgcnVuIHN5bmNocm9ub3VzbHksXG4gKiBhcyB0aGV5IG1heSBldmVudHVhbGx5IGJlIGJhdGNoZWQgdG9nZXRoZXIuICBZb3UgY2FuIHByb3ZpZGUgYW4gb3B0aW9uYWxcbiAqIGNhbGxiYWNrIHRoYXQgd2lsbCBiZSBleGVjdXRlZCB3aGVuIHRoZSBjYWxsIHRvIHNldFN0YXRlIGlzIGFjdHVhbGx5XG4gKiBjb21wbGV0ZWQuXG4gKlxuICogV2hlbiBhIGZ1bmN0aW9uIGlzIHByb3ZpZGVkIHRvIHNldFN0YXRlLCBpdCB3aWxsIGJlIGNhbGxlZCBhdCBzb21lIHBvaW50IGluXG4gKiB0aGUgZnV0dXJlIChub3Qgc3luY2hyb25vdXNseSkuIEl0IHdpbGwgYmUgY2FsbGVkIHdpdGggdGhlIHVwIHRvIGRhdGVcbiAqIGNvbXBvbmVudCBhcmd1bWVudHMgKHN0YXRlLCBwcm9wcywgY29udGV4dCkuIFRoZXNlIHZhbHVlcyBjYW4gYmUgZGlmZmVyZW50XG4gKiBmcm9tIHRoaXMuKiBiZWNhdXNlIHlvdXIgZnVuY3Rpb24gbWF5IGJlIGNhbGxlZCBhZnRlciByZWNlaXZlUHJvcHMgYnV0IGJlZm9yZVxuICogc2hvdWxkQ29tcG9uZW50VXBkYXRlLCBhbmQgdGhpcyBuZXcgc3RhdGUsIHByb3BzLCBhbmQgY29udGV4dCB3aWxsIG5vdCB5ZXQgYmVcbiAqIGFzc2lnbmVkIHRvIHRoaXMuXG4gKlxuICogQHBhcmFtIHtvYmplY3R8ZnVuY3Rpb259IHBhcnRpYWxTdGF0ZSBOZXh0IHBhcnRpYWwgc3RhdGUgb3IgZnVuY3Rpb24gdG9cbiAqICAgICAgICBwcm9kdWNlIG5leHQgcGFydGlhbCBzdGF0ZSB0byBiZSBtZXJnZWQgd2l0aCBjdXJyZW50IHN0YXRlLlxuICogQHBhcmFtIHs/ZnVuY3Rpb259IGNhbGxiYWNrIENhbGxlZCBhZnRlciBzdGF0ZSBpcyB1cGRhdGVkLlxuICogQGZpbmFsXG4gKiBAcHJvdGVjdGVkXG4gKi9cblxuQ29tcG9uZW50LnByb3RvdHlwZS5zZXRTdGF0ZSA9IGZ1bmN0aW9uIChwYXJ0aWFsU3RhdGUsIGNhbGxiYWNrKSB7XG4gIGlmICghKHR5cGVvZiBwYXJ0aWFsU3RhdGUgPT09ICdvYmplY3QnIHx8IHR5cGVvZiBwYXJ0aWFsU3RhdGUgPT09ICdmdW5jdGlvbicgfHwgcGFydGlhbFN0YXRlID09IG51bGwpKSB7XG4gICAge1xuICAgICAgdGhyb3cgRXJyb3IoIFwic2V0U3RhdGUoLi4uKTogdGFrZXMgYW4gb2JqZWN0IG9mIHN0YXRlIHZhcmlhYmxlcyB0byB1cGRhdGUgb3IgYSBmdW5jdGlvbiB3aGljaCByZXR1cm5zIGFuIG9iamVjdCBvZiBzdGF0ZSB2YXJpYWJsZXMuXCIgKTtcbiAgICB9XG4gIH1cblxuICB0aGlzLnVwZGF0ZXIuZW5xdWV1ZVNldFN0YXRlKHRoaXMsIHBhcnRpYWxTdGF0ZSwgY2FsbGJhY2ssICdzZXRTdGF0ZScpO1xufTtcbi8qKlxuICogRm9yY2VzIGFuIHVwZGF0ZS4gVGhpcyBzaG91bGQgb25seSBiZSBpbnZva2VkIHdoZW4gaXQgaXMga25vd24gd2l0aFxuICogY2VydGFpbnR5IHRoYXQgd2UgYXJlICoqbm90KiogaW4gYSBET00gdHJhbnNhY3Rpb24uXG4gKlxuICogWW91IG1heSB3YW50IHRvIGNhbGwgdGhpcyB3aGVuIHlvdSBrbm93IHRoYXQgc29tZSBkZWVwZXIgYXNwZWN0IG9mIHRoZVxuICogY29tcG9uZW50J3Mgc3RhdGUgaGFzIGNoYW5nZWQgYnV0IGBzZXRTdGF0ZWAgd2FzIG5vdCBjYWxsZWQuXG4gKlxuICogVGhpcyB3aWxsIG5vdCBpbnZva2UgYHNob3VsZENvbXBvbmVudFVwZGF0ZWAsIGJ1dCBpdCB3aWxsIGludm9rZVxuICogYGNvbXBvbmVudFdpbGxVcGRhdGVgIGFuZCBgY29tcG9uZW50RGlkVXBkYXRlYC5cbiAqXG4gKiBAcGFyYW0gez9mdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGVkIGFmdGVyIHVwZGF0ZSBpcyBjb21wbGV0ZS5cbiAqIEBmaW5hbFxuICogQHByb3RlY3RlZFxuICovXG5cblxuQ29tcG9uZW50LnByb3RvdHlwZS5mb3JjZVVwZGF0ZSA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICB0aGlzLnVwZGF0ZXIuZW5xdWV1ZUZvcmNlVXBkYXRlKHRoaXMsIGNhbGxiYWNrLCAnZm9yY2VVcGRhdGUnKTtcbn07XG4vKipcbiAqIERlcHJlY2F0ZWQgQVBJcy4gVGhlc2UgQVBJcyB1c2VkIHRvIGV4aXN0IG9uIGNsYXNzaWMgUmVhY3QgY2xhc3NlcyBidXQgc2luY2VcbiAqIHdlIHdvdWxkIGxpa2UgdG8gZGVwcmVjYXRlIHRoZW0sIHdlJ3JlIG5vdCBnb2luZyB0byBtb3ZlIHRoZW0gb3ZlciB0byB0aGlzXG4gKiBtb2Rlcm4gYmFzZSBjbGFzcy4gSW5zdGVhZCwgd2UgZGVmaW5lIGEgZ2V0dGVyIHRoYXQgd2FybnMgaWYgaXQncyBhY2Nlc3NlZC5cbiAqL1xuXG5cbntcbiAgdmFyIGRlcHJlY2F0ZWRBUElzID0ge1xuICAgIGlzTW91bnRlZDogWydpc01vdW50ZWQnLCAnSW5zdGVhZCwgbWFrZSBzdXJlIHRvIGNsZWFuIHVwIHN1YnNjcmlwdGlvbnMgYW5kIHBlbmRpbmcgcmVxdWVzdHMgaW4gJyArICdjb21wb25lbnRXaWxsVW5tb3VudCB0byBwcmV2ZW50IG1lbW9yeSBsZWFrcy4nXSxcbiAgICByZXBsYWNlU3RhdGU6IFsncmVwbGFjZVN0YXRlJywgJ1JlZmFjdG9yIHlvdXIgY29kZSB0byB1c2Ugc2V0U3RhdGUgaW5zdGVhZCAoc2VlICcgKyAnaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8zMjM2KS4nXVxuICB9O1xuXG4gIHZhciBkZWZpbmVEZXByZWNhdGlvbldhcm5pbmcgPSBmdW5jdGlvbiAobWV0aG9kTmFtZSwgaW5mbykge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb21wb25lbnQucHJvdG90eXBlLCBtZXRob2ROYW1lLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgd2FybignJXMoLi4uKSBpcyBkZXByZWNhdGVkIGluIHBsYWluIEphdmFTY3JpcHQgUmVhY3QgY2xhc3Nlcy4gJXMnLCBpbmZvWzBdLCBpbmZvWzFdKTtcblxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xuXG4gIGZvciAodmFyIGZuTmFtZSBpbiBkZXByZWNhdGVkQVBJcykge1xuICAgIGlmIChkZXByZWNhdGVkQVBJcy5oYXNPd25Qcm9wZXJ0eShmbk5hbWUpKSB7XG4gICAgICBkZWZpbmVEZXByZWNhdGlvbldhcm5pbmcoZm5OYW1lLCBkZXByZWNhdGVkQVBJc1tmbk5hbWVdKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gQ29tcG9uZW50RHVtbXkoKSB7fVxuXG5Db21wb25lbnREdW1teS5wcm90b3R5cGUgPSBDb21wb25lbnQucHJvdG90eXBlO1xuLyoqXG4gKiBDb252ZW5pZW5jZSBjb21wb25lbnQgd2l0aCBkZWZhdWx0IHNoYWxsb3cgZXF1YWxpdHkgY2hlY2sgZm9yIHNDVS5cbiAqL1xuXG5mdW5jdGlvbiBQdXJlQ29tcG9uZW50KHByb3BzLCBjb250ZXh0LCB1cGRhdGVyKSB7XG4gIHRoaXMucHJvcHMgPSBwcm9wcztcbiAgdGhpcy5jb250ZXh0ID0gY29udGV4dDsgLy8gSWYgYSBjb21wb25lbnQgaGFzIHN0cmluZyByZWZzLCB3ZSB3aWxsIGFzc2lnbiBhIGRpZmZlcmVudCBvYmplY3QgbGF0ZXIuXG5cbiAgdGhpcy5yZWZzID0gZW1wdHlPYmplY3Q7XG4gIHRoaXMudXBkYXRlciA9IHVwZGF0ZXIgfHwgUmVhY3ROb29wVXBkYXRlUXVldWU7XG59XG5cbnZhciBwdXJlQ29tcG9uZW50UHJvdG90eXBlID0gUHVyZUNvbXBvbmVudC5wcm90b3R5cGUgPSBuZXcgQ29tcG9uZW50RHVtbXkoKTtcbnB1cmVDb21wb25lbnRQcm90b3R5cGUuY29uc3RydWN0b3IgPSBQdXJlQ29tcG9uZW50OyAvLyBBdm9pZCBhbiBleHRyYSBwcm90b3R5cGUganVtcCBmb3IgdGhlc2UgbWV0aG9kcy5cblxuX2Fzc2lnbihwdXJlQ29tcG9uZW50UHJvdG90eXBlLCBDb21wb25lbnQucHJvdG90eXBlKTtcblxucHVyZUNvbXBvbmVudFByb3RvdHlwZS5pc1B1cmVSZWFjdENvbXBvbmVudCA9IHRydWU7XG5cbi8vIGFuIGltbXV0YWJsZSBvYmplY3Qgd2l0aCBhIHNpbmdsZSBtdXRhYmxlIHZhbHVlXG5mdW5jdGlvbiBjcmVhdGVSZWYoKSB7XG4gIHZhciByZWZPYmplY3QgPSB7XG4gICAgY3VycmVudDogbnVsbFxuICB9O1xuXG4gIHtcbiAgICBPYmplY3Quc2VhbChyZWZPYmplY3QpO1xuICB9XG5cbiAgcmV0dXJuIHJlZk9iamVjdDtcbn1cblxuZnVuY3Rpb24gZ2V0V3JhcHBlZE5hbWUob3V0ZXJUeXBlLCBpbm5lclR5cGUsIHdyYXBwZXJOYW1lKSB7XG4gIHZhciBmdW5jdGlvbk5hbWUgPSBpbm5lclR5cGUuZGlzcGxheU5hbWUgfHwgaW5uZXJUeXBlLm5hbWUgfHwgJyc7XG4gIHJldHVybiBvdXRlclR5cGUuZGlzcGxheU5hbWUgfHwgKGZ1bmN0aW9uTmFtZSAhPT0gJycgPyB3cmFwcGVyTmFtZSArIFwiKFwiICsgZnVuY3Rpb25OYW1lICsgXCIpXCIgOiB3cmFwcGVyTmFtZSk7XG59XG5cbmZ1bmN0aW9uIGdldENvbnRleHROYW1lKHR5cGUpIHtcbiAgcmV0dXJuIHR5cGUuZGlzcGxheU5hbWUgfHwgJ0NvbnRleHQnO1xufVxuXG5mdW5jdGlvbiBnZXRDb21wb25lbnROYW1lKHR5cGUpIHtcbiAgaWYgKHR5cGUgPT0gbnVsbCkge1xuICAgIC8vIEhvc3Qgcm9vdCwgdGV4dCBub2RlIG9yIGp1c3QgaW52YWxpZCB0eXBlLlxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAge1xuICAgIGlmICh0eXBlb2YgdHlwZS50YWcgPT09ICdudW1iZXInKSB7XG4gICAgICBlcnJvcignUmVjZWl2ZWQgYW4gdW5leHBlY3RlZCBvYmplY3QgaW4gZ2V0Q29tcG9uZW50TmFtZSgpLiAnICsgJ1RoaXMgaXMgbGlrZWx5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgICB9XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gdHlwZS5kaXNwbGF5TmFtZSB8fCB0eXBlLm5hbWUgfHwgbnVsbDtcbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gdHlwZTtcbiAgfVxuXG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgZXhwb3J0cy5GcmFnbWVudDpcbiAgICAgIHJldHVybiAnRnJhZ21lbnQnO1xuXG4gICAgY2FzZSBSRUFDVF9QT1JUQUxfVFlQRTpcbiAgICAgIHJldHVybiAnUG9ydGFsJztcblxuICAgIGNhc2UgZXhwb3J0cy5Qcm9maWxlcjpcbiAgICAgIHJldHVybiAnUHJvZmlsZXInO1xuXG4gICAgY2FzZSBleHBvcnRzLlN0cmljdE1vZGU6XG4gICAgICByZXR1cm4gJ1N0cmljdE1vZGUnO1xuXG4gICAgY2FzZSBleHBvcnRzLlN1c3BlbnNlOlxuICAgICAgcmV0dXJuICdTdXNwZW5zZSc7XG5cbiAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRTpcbiAgICAgIHJldHVybiAnU3VzcGVuc2VMaXN0JztcbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICBzd2l0Y2ggKHR5cGUuJCR0eXBlb2YpIHtcbiAgICAgIGNhc2UgUkVBQ1RfQ09OVEVYVF9UWVBFOlxuICAgICAgICB2YXIgY29udGV4dCA9IHR5cGU7XG4gICAgICAgIHJldHVybiBnZXRDb250ZXh0TmFtZShjb250ZXh0KSArICcuQ29uc3VtZXInO1xuXG4gICAgICBjYXNlIFJFQUNUX1BST1ZJREVSX1RZUEU6XG4gICAgICAgIHZhciBwcm92aWRlciA9IHR5cGU7XG4gICAgICAgIHJldHVybiBnZXRDb250ZXh0TmFtZShwcm92aWRlci5fY29udGV4dCkgKyAnLlByb3ZpZGVyJztcblxuICAgICAgY2FzZSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFOlxuICAgICAgICByZXR1cm4gZ2V0V3JhcHBlZE5hbWUodHlwZSwgdHlwZS5yZW5kZXIsICdGb3J3YXJkUmVmJyk7XG5cbiAgICAgIGNhc2UgUkVBQ1RfTUVNT19UWVBFOlxuICAgICAgICByZXR1cm4gZ2V0Q29tcG9uZW50TmFtZSh0eXBlLnR5cGUpO1xuXG4gICAgICBjYXNlIFJFQUNUX0JMT0NLX1RZUEU6XG4gICAgICAgIHJldHVybiBnZXRDb21wb25lbnROYW1lKHR5cGUuX3JlbmRlcik7XG5cbiAgICAgIGNhc2UgUkVBQ1RfTEFaWV9UWVBFOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIGxhenlDb21wb25lbnQgPSB0eXBlO1xuICAgICAgICAgIHZhciBwYXlsb2FkID0gbGF6eUNvbXBvbmVudC5fcGF5bG9hZDtcbiAgICAgICAgICB2YXIgaW5pdCA9IGxhenlDb21wb25lbnQuX2luaXQ7XG5cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIGdldENvbXBvbmVudE5hbWUoaW5pdChwYXlsb2FkKSk7XG4gICAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgUkVTRVJWRURfUFJPUFMgPSB7XG4gIGtleTogdHJ1ZSxcbiAgcmVmOiB0cnVlLFxuICBfX3NlbGY6IHRydWUsXG4gIF9fc291cmNlOiB0cnVlXG59O1xudmFyIHNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duLCBzcGVjaWFsUHJvcFJlZldhcm5pbmdTaG93biwgZGlkV2FybkFib3V0U3RyaW5nUmVmcztcblxue1xuICBkaWRXYXJuQWJvdXRTdHJpbmdSZWZzID0ge307XG59XG5cbmZ1bmN0aW9uIGhhc1ZhbGlkUmVmKGNvbmZpZykge1xuICB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCAncmVmJykpIHtcbiAgICAgIHZhciBnZXR0ZXIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGNvbmZpZywgJ3JlZicpLmdldDtcblxuICAgICAgaWYgKGdldHRlciAmJiBnZXR0ZXIuaXNSZWFjdFdhcm5pbmcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjb25maWcucmVmICE9PSB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIGhhc1ZhbGlkS2V5KGNvbmZpZykge1xuICB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCAna2V5JykpIHtcbiAgICAgIHZhciBnZXR0ZXIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGNvbmZpZywgJ2tleScpLmdldDtcblxuICAgICAgaWYgKGdldHRlciAmJiBnZXR0ZXIuaXNSZWFjdFdhcm5pbmcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjb25maWcua2V5ICE9PSB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIGRlZmluZUtleVByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSkge1xuICB2YXIgd2FybkFib3V0QWNjZXNzaW5nS2V5ID0gZnVuY3Rpb24gKCkge1xuICAgIHtcbiAgICAgIGlmICghc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd24pIHtcbiAgICAgICAgc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd24gPSB0cnVlO1xuXG4gICAgICAgIGVycm9yKCclczogYGtleWAgaXMgbm90IGEgcHJvcC4gVHJ5aW5nIHRvIGFjY2VzcyBpdCB3aWxsIHJlc3VsdCAnICsgJ2luIGB1bmRlZmluZWRgIGJlaW5nIHJldHVybmVkLiBJZiB5b3UgbmVlZCB0byBhY2Nlc3MgdGhlIHNhbWUgJyArICd2YWx1ZSB3aXRoaW4gdGhlIGNoaWxkIGNvbXBvbmVudCwgeW91IHNob3VsZCBwYXNzIGl0IGFzIGEgZGlmZmVyZW50ICcgKyAncHJvcC4gKGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9zcGVjaWFsLXByb3BzKScsIGRpc3BsYXlOYW1lKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgd2FybkFib3V0QWNjZXNzaW5nS2V5LmlzUmVhY3RXYXJuaW5nID0gdHJ1ZTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3BzLCAna2V5Jywge1xuICAgIGdldDogd2FybkFib3V0QWNjZXNzaW5nS2V5LFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbn1cblxuZnVuY3Rpb24gZGVmaW5lUmVmUHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKSB7XG4gIHZhciB3YXJuQWJvdXRBY2Nlc3NpbmdSZWYgPSBmdW5jdGlvbiAoKSB7XG4gICAge1xuICAgICAgaWYgKCFzcGVjaWFsUHJvcFJlZldhcm5pbmdTaG93bikge1xuICAgICAgICBzcGVjaWFsUHJvcFJlZldhcm5pbmdTaG93biA9IHRydWU7XG5cbiAgICAgICAgZXJyb3IoJyVzOiBgcmVmYCBpcyBub3QgYSBwcm9wLiBUcnlpbmcgdG8gYWNjZXNzIGl0IHdpbGwgcmVzdWx0ICcgKyAnaW4gYHVuZGVmaW5lZGAgYmVpbmcgcmV0dXJuZWQuIElmIHlvdSBuZWVkIHRvIGFjY2VzcyB0aGUgc2FtZSAnICsgJ3ZhbHVlIHdpdGhpbiB0aGUgY2hpbGQgY29tcG9uZW50LCB5b3Ugc2hvdWxkIHBhc3MgaXQgYXMgYSBkaWZmZXJlbnQgJyArICdwcm9wLiAoaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3NwZWNpYWwtcHJvcHMpJywgZGlzcGxheU5hbWUpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICB3YXJuQWJvdXRBY2Nlc3NpbmdSZWYuaXNSZWFjdFdhcm5pbmcgPSB0cnVlO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvcHMsICdyZWYnLCB7XG4gICAgZ2V0OiB3YXJuQWJvdXRBY2Nlc3NpbmdSZWYsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xufVxuXG5mdW5jdGlvbiB3YXJuSWZTdHJpbmdSZWZDYW5ub3RCZUF1dG9Db252ZXJ0ZWQoY29uZmlnKSB7XG4gIHtcbiAgICBpZiAodHlwZW9mIGNvbmZpZy5yZWYgPT09ICdzdHJpbmcnICYmIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQgJiYgY29uZmlnLl9fc2VsZiAmJiBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50LnN0YXRlTm9kZSAhPT0gY29uZmlnLl9fc2VsZikge1xuICAgICAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lKFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQudHlwZSk7XG5cbiAgICAgIGlmICghZGlkV2FybkFib3V0U3RyaW5nUmVmc1tjb21wb25lbnROYW1lXSkge1xuICAgICAgICBlcnJvcignQ29tcG9uZW50IFwiJXNcIiBjb250YWlucyB0aGUgc3RyaW5nIHJlZiBcIiVzXCIuICcgKyAnU3VwcG9ydCBmb3Igc3RyaW5nIHJlZnMgd2lsbCBiZSByZW1vdmVkIGluIGEgZnV0dXJlIG1ham9yIHJlbGVhc2UuICcgKyAnVGhpcyBjYXNlIGNhbm5vdCBiZSBhdXRvbWF0aWNhbGx5IGNvbnZlcnRlZCB0byBhbiBhcnJvdyBmdW5jdGlvbi4gJyArICdXZSBhc2sgeW91IHRvIG1hbnVhbGx5IGZpeCB0aGlzIGNhc2UgYnkgdXNpbmcgdXNlUmVmKCkgb3IgY3JlYXRlUmVmKCkgaW5zdGVhZC4gJyArICdMZWFybiBtb3JlIGFib3V0IHVzaW5nIHJlZnMgc2FmZWx5IGhlcmU6ICcgKyAnaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3N0cmljdC1tb2RlLXN0cmluZy1yZWYnLCBjb21wb25lbnROYW1lLCBjb25maWcucmVmKTtcblxuICAgICAgICBkaWRXYXJuQWJvdXRTdHJpbmdSZWZzW2NvbXBvbmVudE5hbWVdID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbi8qKlxuICogRmFjdG9yeSBtZXRob2QgdG8gY3JlYXRlIGEgbmV3IFJlYWN0IGVsZW1lbnQuIFRoaXMgbm8gbG9uZ2VyIGFkaGVyZXMgdG9cbiAqIHRoZSBjbGFzcyBwYXR0ZXJuLCBzbyBkbyBub3QgdXNlIG5ldyB0byBjYWxsIGl0LiBBbHNvLCBpbnN0YW5jZW9mIGNoZWNrXG4gKiB3aWxsIG5vdCB3b3JrLiBJbnN0ZWFkIHRlc3QgJCR0eXBlb2YgZmllbGQgYWdhaW5zdCBTeW1ib2wuZm9yKCdyZWFjdC5lbGVtZW50JykgdG8gY2hlY2tcbiAqIGlmIHNvbWV0aGluZyBpcyBhIFJlYWN0IEVsZW1lbnQuXG4gKlxuICogQHBhcmFtIHsqfSB0eXBlXG4gKiBAcGFyYW0geyp9IHByb3BzXG4gKiBAcGFyYW0geyp9IGtleVxuICogQHBhcmFtIHtzdHJpbmd8b2JqZWN0fSByZWZcbiAqIEBwYXJhbSB7Kn0gb3duZXJcbiAqIEBwYXJhbSB7Kn0gc2VsZiBBICp0ZW1wb3JhcnkqIGhlbHBlciB0byBkZXRlY3QgcGxhY2VzIHdoZXJlIGB0aGlzYCBpc1xuICogZGlmZmVyZW50IGZyb20gdGhlIGBvd25lcmAgd2hlbiBSZWFjdC5jcmVhdGVFbGVtZW50IGlzIGNhbGxlZCwgc28gdGhhdCB3ZVxuICogY2FuIHdhcm4uIFdlIHdhbnQgdG8gZ2V0IHJpZCBvZiBvd25lciBhbmQgcmVwbGFjZSBzdHJpbmcgYHJlZmBzIHdpdGggYXJyb3dcbiAqIGZ1bmN0aW9ucywgYW5kIGFzIGxvbmcgYXMgYHRoaXNgIGFuZCBvd25lciBhcmUgdGhlIHNhbWUsIHRoZXJlIHdpbGwgYmUgbm9cbiAqIGNoYW5nZSBpbiBiZWhhdmlvci5cbiAqIEBwYXJhbSB7Kn0gc291cmNlIEFuIGFubm90YXRpb24gb2JqZWN0IChhZGRlZCBieSBhIHRyYW5zcGlsZXIgb3Igb3RoZXJ3aXNlKVxuICogaW5kaWNhdGluZyBmaWxlbmFtZSwgbGluZSBudW1iZXIsIGFuZC9vciBvdGhlciBpbmZvcm1hdGlvbi5cbiAqIEBpbnRlcm5hbFxuICovXG5cblxudmFyIFJlYWN0RWxlbWVudCA9IGZ1bmN0aW9uICh0eXBlLCBrZXksIHJlZiwgc2VsZiwgc291cmNlLCBvd25lciwgcHJvcHMpIHtcbiAgdmFyIGVsZW1lbnQgPSB7XG4gICAgLy8gVGhpcyB0YWcgYWxsb3dzIHVzIHRvIHVuaXF1ZWx5IGlkZW50aWZ5IHRoaXMgYXMgYSBSZWFjdCBFbGVtZW50XG4gICAgJCR0eXBlb2Y6IFJFQUNUX0VMRU1FTlRfVFlQRSxcbiAgICAvLyBCdWlsdC1pbiBwcm9wZXJ0aWVzIHRoYXQgYmVsb25nIG9uIHRoZSBlbGVtZW50XG4gICAgdHlwZTogdHlwZSxcbiAgICBrZXk6IGtleSxcbiAgICByZWY6IHJlZixcbiAgICBwcm9wczogcHJvcHMsXG4gICAgLy8gUmVjb3JkIHRoZSBjb21wb25lbnQgcmVzcG9uc2libGUgZm9yIGNyZWF0aW5nIHRoaXMgZWxlbWVudC5cbiAgICBfb3duZXI6IG93bmVyXG4gIH07XG5cbiAge1xuICAgIC8vIFRoZSB2YWxpZGF0aW9uIGZsYWcgaXMgY3VycmVudGx5IG11dGF0aXZlLiBXZSBwdXQgaXQgb25cbiAgICAvLyBhbiBleHRlcm5hbCBiYWNraW5nIHN0b3JlIHNvIHRoYXQgd2UgY2FuIGZyZWV6ZSB0aGUgd2hvbGUgb2JqZWN0LlxuICAgIC8vIFRoaXMgY2FuIGJlIHJlcGxhY2VkIHdpdGggYSBXZWFrTWFwIG9uY2UgdGhleSBhcmUgaW1wbGVtZW50ZWQgaW5cbiAgICAvLyBjb21tb25seSB1c2VkIGRldmVsb3BtZW50IGVudmlyb25tZW50cy5cbiAgICBlbGVtZW50Ll9zdG9yZSA9IHt9OyAvLyBUbyBtYWtlIGNvbXBhcmluZyBSZWFjdEVsZW1lbnRzIGVhc2llciBmb3IgdGVzdGluZyBwdXJwb3Nlcywgd2UgbWFrZVxuICAgIC8vIHRoZSB2YWxpZGF0aW9uIGZsYWcgbm9uLWVudW1lcmFibGUgKHdoZXJlIHBvc3NpYmxlLCB3aGljaCBzaG91bGRcbiAgICAvLyBpbmNsdWRlIGV2ZXJ5IGVudmlyb25tZW50IHdlIHJ1biB0ZXN0cyBpbiksIHNvIHRoZSB0ZXN0IGZyYW1ld29ya1xuICAgIC8vIGlnbm9yZXMgaXQuXG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudC5fc3RvcmUsICd2YWxpZGF0ZWQnLCB7XG4gICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIHZhbHVlOiBmYWxzZVxuICAgIH0pOyAvLyBzZWxmIGFuZCBzb3VyY2UgYXJlIERFViBvbmx5IHByb3BlcnRpZXMuXG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudCwgJ19zZWxmJywge1xuICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgdmFsdWU6IHNlbGZcbiAgICB9KTsgLy8gVHdvIGVsZW1lbnRzIGNyZWF0ZWQgaW4gdHdvIGRpZmZlcmVudCBwbGFjZXMgc2hvdWxkIGJlIGNvbnNpZGVyZWRcbiAgICAvLyBlcXVhbCBmb3IgdGVzdGluZyBwdXJwb3NlcyBhbmQgdGhlcmVmb3JlIHdlIGhpZGUgaXQgZnJvbSBlbnVtZXJhdGlvbi5cblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbGVtZW50LCAnX3NvdXJjZScsIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgIHZhbHVlOiBzb3VyY2VcbiAgICB9KTtcblxuICAgIGlmIChPYmplY3QuZnJlZXplKSB7XG4gICAgICBPYmplY3QuZnJlZXplKGVsZW1lbnQucHJvcHMpO1xuICAgICAgT2JqZWN0LmZyZWV6ZShlbGVtZW50KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZWxlbWVudDtcbn07XG4vKipcbiAqIENyZWF0ZSBhbmQgcmV0dXJuIGEgbmV3IFJlYWN0RWxlbWVudCBvZiB0aGUgZ2l2ZW4gdHlwZS5cbiAqIFNlZSBodHRwczovL3JlYWN0anMub3JnL2RvY3MvcmVhY3QtYXBpLmh0bWwjY3JlYXRlZWxlbWVudFxuICovXG5cbmZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnQodHlwZSwgY29uZmlnLCBjaGlsZHJlbikge1xuICB2YXIgcHJvcE5hbWU7IC8vIFJlc2VydmVkIG5hbWVzIGFyZSBleHRyYWN0ZWRcblxuICB2YXIgcHJvcHMgPSB7fTtcbiAgdmFyIGtleSA9IG51bGw7XG4gIHZhciByZWYgPSBudWxsO1xuICB2YXIgc2VsZiA9IG51bGw7XG4gIHZhciBzb3VyY2UgPSBudWxsO1xuXG4gIGlmIChjb25maWcgIT0gbnVsbCkge1xuICAgIGlmIChoYXNWYWxpZFJlZihjb25maWcpKSB7XG4gICAgICByZWYgPSBjb25maWcucmVmO1xuXG4gICAgICB7XG4gICAgICAgIHdhcm5JZlN0cmluZ1JlZkNhbm5vdEJlQXV0b0NvbnZlcnRlZChjb25maWcpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChoYXNWYWxpZEtleShjb25maWcpKSB7XG4gICAgICBrZXkgPSAnJyArIGNvbmZpZy5rZXk7XG4gICAgfVxuXG4gICAgc2VsZiA9IGNvbmZpZy5fX3NlbGYgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBjb25maWcuX19zZWxmO1xuICAgIHNvdXJjZSA9IGNvbmZpZy5fX3NvdXJjZSA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IGNvbmZpZy5fX3NvdXJjZTsgLy8gUmVtYWluaW5nIHByb3BlcnRpZXMgYXJlIGFkZGVkIHRvIGEgbmV3IHByb3BzIG9iamVjdFxuXG4gICAgZm9yIChwcm9wTmFtZSBpbiBjb25maWcpIHtcbiAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgcHJvcE5hbWUpICYmICFSRVNFUlZFRF9QUk9QUy5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkpIHtcbiAgICAgICAgcHJvcHNbcHJvcE5hbWVdID0gY29uZmlnW3Byb3BOYW1lXTtcbiAgICAgIH1cbiAgICB9XG4gIH0gLy8gQ2hpbGRyZW4gY2FuIGJlIG1vcmUgdGhhbiBvbmUgYXJndW1lbnQsIGFuZCB0aG9zZSBhcmUgdHJhbnNmZXJyZWQgb250b1xuICAvLyB0aGUgbmV3bHkgYWxsb2NhdGVkIHByb3BzIG9iamVjdC5cblxuXG4gIHZhciBjaGlsZHJlbkxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGggLSAyO1xuXG4gIGlmIChjaGlsZHJlbkxlbmd0aCA9PT0gMSkge1xuICAgIHByb3BzLmNoaWxkcmVuID0gY2hpbGRyZW47XG4gIH0gZWxzZSBpZiAoY2hpbGRyZW5MZW5ndGggPiAxKSB7XG4gICAgdmFyIGNoaWxkQXJyYXkgPSBBcnJheShjaGlsZHJlbkxlbmd0aCk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuTGVuZ3RoOyBpKyspIHtcbiAgICAgIGNoaWxkQXJyYXlbaV0gPSBhcmd1bWVudHNbaSArIDJdO1xuICAgIH1cblxuICAgIHtcbiAgICAgIGlmIChPYmplY3QuZnJlZXplKSB7XG4gICAgICAgIE9iamVjdC5mcmVlemUoY2hpbGRBcnJheSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcHJvcHMuY2hpbGRyZW4gPSBjaGlsZEFycmF5O1xuICB9IC8vIFJlc29sdmUgZGVmYXVsdCBwcm9wc1xuXG5cbiAgaWYgKHR5cGUgJiYgdHlwZS5kZWZhdWx0UHJvcHMpIHtcbiAgICB2YXIgZGVmYXVsdFByb3BzID0gdHlwZS5kZWZhdWx0UHJvcHM7XG5cbiAgICBmb3IgKHByb3BOYW1lIGluIGRlZmF1bHRQcm9wcykge1xuICAgICAgaWYgKHByb3BzW3Byb3BOYW1lXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHByb3BzW3Byb3BOYW1lXSA9IGRlZmF1bHRQcm9wc1twcm9wTmFtZV07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAge1xuICAgIGlmIChrZXkgfHwgcmVmKSB7XG4gICAgICB2YXIgZGlzcGxheU5hbWUgPSB0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJyA/IHR5cGUuZGlzcGxheU5hbWUgfHwgdHlwZS5uYW1lIHx8ICdVbmtub3duJyA6IHR5cGU7XG5cbiAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgZGVmaW5lS2V5UHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHJlZikge1xuICAgICAgICBkZWZpbmVSZWZQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBSZWFjdEVsZW1lbnQodHlwZSwga2V5LCByZWYsIHNlbGYsIHNvdXJjZSwgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCwgcHJvcHMpO1xufVxuZnVuY3Rpb24gY2xvbmVBbmRSZXBsYWNlS2V5KG9sZEVsZW1lbnQsIG5ld0tleSkge1xuICB2YXIgbmV3RWxlbWVudCA9IFJlYWN0RWxlbWVudChvbGRFbGVtZW50LnR5cGUsIG5ld0tleSwgb2xkRWxlbWVudC5yZWYsIG9sZEVsZW1lbnQuX3NlbGYsIG9sZEVsZW1lbnQuX3NvdXJjZSwgb2xkRWxlbWVudC5fb3duZXIsIG9sZEVsZW1lbnQucHJvcHMpO1xuICByZXR1cm4gbmV3RWxlbWVudDtcbn1cbi8qKlxuICogQ2xvbmUgYW5kIHJldHVybiBhIG5ldyBSZWFjdEVsZW1lbnQgdXNpbmcgZWxlbWVudCBhcyB0aGUgc3RhcnRpbmcgcG9pbnQuXG4gKiBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL3JlYWN0LWFwaS5odG1sI2Nsb25lZWxlbWVudFxuICovXG5cbmZ1bmN0aW9uIGNsb25lRWxlbWVudChlbGVtZW50LCBjb25maWcsIGNoaWxkcmVuKSB7XG4gIGlmICghIShlbGVtZW50ID09PSBudWxsIHx8IGVsZW1lbnQgPT09IHVuZGVmaW5lZCkpIHtcbiAgICB7XG4gICAgICB0aHJvdyBFcnJvciggXCJSZWFjdC5jbG9uZUVsZW1lbnQoLi4uKTogVGhlIGFyZ3VtZW50IG11c3QgYmUgYSBSZWFjdCBlbGVtZW50LCBidXQgeW91IHBhc3NlZCBcIiArIGVsZW1lbnQgKyBcIi5cIiApO1xuICAgIH1cbiAgfVxuXG4gIHZhciBwcm9wTmFtZTsgLy8gT3JpZ2luYWwgcHJvcHMgYXJlIGNvcGllZFxuXG4gIHZhciBwcm9wcyA9IF9hc3NpZ24oe30sIGVsZW1lbnQucHJvcHMpOyAvLyBSZXNlcnZlZCBuYW1lcyBhcmUgZXh0cmFjdGVkXG5cblxuICB2YXIga2V5ID0gZWxlbWVudC5rZXk7XG4gIHZhciByZWYgPSBlbGVtZW50LnJlZjsgLy8gU2VsZiBpcyBwcmVzZXJ2ZWQgc2luY2UgdGhlIG93bmVyIGlzIHByZXNlcnZlZC5cblxuICB2YXIgc2VsZiA9IGVsZW1lbnQuX3NlbGY7IC8vIFNvdXJjZSBpcyBwcmVzZXJ2ZWQgc2luY2UgY2xvbmVFbGVtZW50IGlzIHVubGlrZWx5IHRvIGJlIHRhcmdldGVkIGJ5IGFcbiAgLy8gdHJhbnNwaWxlciwgYW5kIHRoZSBvcmlnaW5hbCBzb3VyY2UgaXMgcHJvYmFibHkgYSBiZXR0ZXIgaW5kaWNhdG9yIG9mIHRoZVxuICAvLyB0cnVlIG93bmVyLlxuXG4gIHZhciBzb3VyY2UgPSBlbGVtZW50Ll9zb3VyY2U7IC8vIE93bmVyIHdpbGwgYmUgcHJlc2VydmVkLCB1bmxlc3MgcmVmIGlzIG92ZXJyaWRkZW5cblxuICB2YXIgb3duZXIgPSBlbGVtZW50Ll9vd25lcjtcblxuICBpZiAoY29uZmlnICE9IG51bGwpIHtcbiAgICBpZiAoaGFzVmFsaWRSZWYoY29uZmlnKSkge1xuICAgICAgLy8gU2lsZW50bHkgc3RlYWwgdGhlIHJlZiBmcm9tIHRoZSBwYXJlbnQuXG4gICAgICByZWYgPSBjb25maWcucmVmO1xuICAgICAgb3duZXIgPSBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50O1xuICAgIH1cblxuICAgIGlmIChoYXNWYWxpZEtleShjb25maWcpKSB7XG4gICAgICBrZXkgPSAnJyArIGNvbmZpZy5rZXk7XG4gICAgfSAvLyBSZW1haW5pbmcgcHJvcGVydGllcyBvdmVycmlkZSBleGlzdGluZyBwcm9wc1xuXG5cbiAgICB2YXIgZGVmYXVsdFByb3BzO1xuXG4gICAgaWYgKGVsZW1lbnQudHlwZSAmJiBlbGVtZW50LnR5cGUuZGVmYXVsdFByb3BzKSB7XG4gICAgICBkZWZhdWx0UHJvcHMgPSBlbGVtZW50LnR5cGUuZGVmYXVsdFByb3BzO1xuICAgIH1cblxuICAgIGZvciAocHJvcE5hbWUgaW4gY29uZmlnKSB7XG4gICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChjb25maWcsIHByb3BOYW1lKSAmJiAhUkVTRVJWRURfUFJPUFMuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpKSB7XG4gICAgICAgIGlmIChjb25maWdbcHJvcE5hbWVdID09PSB1bmRlZmluZWQgJiYgZGVmYXVsdFByb3BzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAvLyBSZXNvbHZlIGRlZmF1bHQgcHJvcHNcbiAgICAgICAgICBwcm9wc1twcm9wTmFtZV0gPSBkZWZhdWx0UHJvcHNbcHJvcE5hbWVdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHByb3BzW3Byb3BOYW1lXSA9IGNvbmZpZ1twcm9wTmFtZV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0gLy8gQ2hpbGRyZW4gY2FuIGJlIG1vcmUgdGhhbiBvbmUgYXJndW1lbnQsIGFuZCB0aG9zZSBhcmUgdHJhbnNmZXJyZWQgb250b1xuICAvLyB0aGUgbmV3bHkgYWxsb2NhdGVkIHByb3BzIG9iamVjdC5cblxuXG4gIHZhciBjaGlsZHJlbkxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGggLSAyO1xuXG4gIGlmIChjaGlsZHJlbkxlbmd0aCA9PT0gMSkge1xuICAgIHByb3BzLmNoaWxkcmVuID0gY2hpbGRyZW47XG4gIH0gZWxzZSBpZiAoY2hpbGRyZW5MZW5ndGggPiAxKSB7XG4gICAgdmFyIGNoaWxkQXJyYXkgPSBBcnJheShjaGlsZHJlbkxlbmd0aCk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuTGVuZ3RoOyBpKyspIHtcbiAgICAgIGNoaWxkQXJyYXlbaV0gPSBhcmd1bWVudHNbaSArIDJdO1xuICAgIH1cblxuICAgIHByb3BzLmNoaWxkcmVuID0gY2hpbGRBcnJheTtcbiAgfVxuXG4gIHJldHVybiBSZWFjdEVsZW1lbnQoZWxlbWVudC50eXBlLCBrZXksIHJlZiwgc2VsZiwgc291cmNlLCBvd25lciwgcHJvcHMpO1xufVxuLyoqXG4gKiBWZXJpZmllcyB0aGUgb2JqZWN0IGlzIGEgUmVhY3RFbGVtZW50LlxuICogU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9yZWFjdC1hcGkuaHRtbCNpc3ZhbGlkZWxlbWVudFxuICogQHBhcmFtIHs/b2JqZWN0fSBvYmplY3RcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgYG9iamVjdGAgaXMgYSBSZWFjdEVsZW1lbnQuXG4gKiBAZmluYWxcbiAqL1xuXG5mdW5jdGlvbiBpc1ZhbGlkRWxlbWVudChvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVvZiBvYmplY3QgPT09ICdvYmplY3QnICYmIG9iamVjdCAhPT0gbnVsbCAmJiBvYmplY3QuJCR0eXBlb2YgPT09IFJFQUNUX0VMRU1FTlRfVFlQRTtcbn1cblxudmFyIFNFUEFSQVRPUiA9ICcuJztcbnZhciBTVUJTRVBBUkFUT1IgPSAnOic7XG4vKipcbiAqIEVzY2FwZSBhbmQgd3JhcCBrZXkgc28gaXQgaXMgc2FmZSB0byB1c2UgYXMgYSByZWFjdGlkXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSB0byBiZSBlc2NhcGVkLlxuICogQHJldHVybiB7c3RyaW5nfSB0aGUgZXNjYXBlZCBrZXkuXG4gKi9cblxuZnVuY3Rpb24gZXNjYXBlKGtleSkge1xuICB2YXIgZXNjYXBlUmVnZXggPSAvWz06XS9nO1xuICB2YXIgZXNjYXBlckxvb2t1cCA9IHtcbiAgICAnPSc6ICc9MCcsXG4gICAgJzonOiAnPTInXG4gIH07XG4gIHZhciBlc2NhcGVkU3RyaW5nID0ga2V5LnJlcGxhY2UoZXNjYXBlUmVnZXgsIGZ1bmN0aW9uIChtYXRjaCkge1xuICAgIHJldHVybiBlc2NhcGVyTG9va3VwW21hdGNoXTtcbiAgfSk7XG4gIHJldHVybiAnJCcgKyBlc2NhcGVkU3RyaW5nO1xufVxuLyoqXG4gKiBUT0RPOiBUZXN0IHRoYXQgYSBzaW5nbGUgY2hpbGQgYW5kIGFuIGFycmF5IHdpdGggb25lIGl0ZW0gaGF2ZSB0aGUgc2FtZSBrZXlcbiAqIHBhdHRlcm4uXG4gKi9cblxuXG52YXIgZGlkV2FybkFib3V0TWFwcyA9IGZhbHNlO1xudmFyIHVzZXJQcm92aWRlZEtleUVzY2FwZVJlZ2V4ID0gL1xcLysvZztcblxuZnVuY3Rpb24gZXNjYXBlVXNlclByb3ZpZGVkS2V5KHRleHQpIHtcbiAgcmV0dXJuIHRleHQucmVwbGFjZSh1c2VyUHJvdmlkZWRLZXlFc2NhcGVSZWdleCwgJyQmLycpO1xufVxuLyoqXG4gKiBHZW5lcmF0ZSBhIGtleSBzdHJpbmcgdGhhdCBpZGVudGlmaWVzIGEgZWxlbWVudCB3aXRoaW4gYSBzZXQuXG4gKlxuICogQHBhcmFtIHsqfSBlbGVtZW50IEEgZWxlbWVudCB0aGF0IGNvdWxkIGNvbnRhaW4gYSBtYW51YWwga2V5LlxuICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IEluZGV4IHRoYXQgaXMgdXNlZCBpZiBhIG1hbnVhbCBrZXkgaXMgbm90IHByb3ZpZGVkLlxuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5cblxuZnVuY3Rpb24gZ2V0RWxlbWVudEtleShlbGVtZW50LCBpbmRleCkge1xuICAvLyBEbyBzb21lIHR5cGVjaGVja2luZyBoZXJlIHNpbmNlIHdlIGNhbGwgdGhpcyBibGluZGx5LiBXZSB3YW50IHRvIGVuc3VyZVxuICAvLyB0aGF0IHdlIGRvbid0IGJsb2NrIHBvdGVudGlhbCBmdXR1cmUgRVMgQVBJcy5cbiAgaWYgKHR5cGVvZiBlbGVtZW50ID09PSAnb2JqZWN0JyAmJiBlbGVtZW50ICE9PSBudWxsICYmIGVsZW1lbnQua2V5ICE9IG51bGwpIHtcbiAgICAvLyBFeHBsaWNpdCBrZXlcbiAgICByZXR1cm4gZXNjYXBlKCcnICsgZWxlbWVudC5rZXkpO1xuICB9IC8vIEltcGxpY2l0IGtleSBkZXRlcm1pbmVkIGJ5IHRoZSBpbmRleCBpbiB0aGUgc2V0XG5cblxuICByZXR1cm4gaW5kZXgudG9TdHJpbmcoMzYpO1xufVxuXG5mdW5jdGlvbiBtYXBJbnRvQXJyYXkoY2hpbGRyZW4sIGFycmF5LCBlc2NhcGVkUHJlZml4LCBuYW1lU29GYXIsIGNhbGxiYWNrKSB7XG4gIHZhciB0eXBlID0gdHlwZW9mIGNoaWxkcmVuO1xuXG4gIGlmICh0eXBlID09PSAndW5kZWZpbmVkJyB8fCB0eXBlID09PSAnYm9vbGVhbicpIHtcbiAgICAvLyBBbGwgb2YgdGhlIGFib3ZlIGFyZSBwZXJjZWl2ZWQgYXMgbnVsbC5cbiAgICBjaGlsZHJlbiA9IG51bGw7XG4gIH1cblxuICB2YXIgaW52b2tlQ2FsbGJhY2sgPSBmYWxzZTtcblxuICBpZiAoY2hpbGRyZW4gPT09IG51bGwpIHtcbiAgICBpbnZva2VDYWxsYmFjayA9IHRydWU7XG4gIH0gZWxzZSB7XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgaW52b2tlQ2FsbGJhY2sgPSB0cnVlO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgc3dpdGNoIChjaGlsZHJlbi4kJHR5cGVvZikge1xuICAgICAgICAgIGNhc2UgUkVBQ1RfRUxFTUVOVF9UWVBFOlxuICAgICAgICAgIGNhc2UgUkVBQ1RfUE9SVEFMX1RZUEU6XG4gICAgICAgICAgICBpbnZva2VDYWxsYmFjayA9IHRydWU7XG4gICAgICAgIH1cblxuICAgIH1cbiAgfVxuXG4gIGlmIChpbnZva2VDYWxsYmFjaykge1xuICAgIHZhciBfY2hpbGQgPSBjaGlsZHJlbjtcbiAgICB2YXIgbWFwcGVkQ2hpbGQgPSBjYWxsYmFjayhfY2hpbGQpOyAvLyBJZiBpdCdzIHRoZSBvbmx5IGNoaWxkLCB0cmVhdCB0aGUgbmFtZSBhcyBpZiBpdCB3YXMgd3JhcHBlZCBpbiBhbiBhcnJheVxuICAgIC8vIHNvIHRoYXQgaXQncyBjb25zaXN0ZW50IGlmIHRoZSBudW1iZXIgb2YgY2hpbGRyZW4gZ3Jvd3M6XG5cbiAgICB2YXIgY2hpbGRLZXkgPSBuYW1lU29GYXIgPT09ICcnID8gU0VQQVJBVE9SICsgZ2V0RWxlbWVudEtleShfY2hpbGQsIDApIDogbmFtZVNvRmFyO1xuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkobWFwcGVkQ2hpbGQpKSB7XG4gICAgICB2YXIgZXNjYXBlZENoaWxkS2V5ID0gJyc7XG5cbiAgICAgIGlmIChjaGlsZEtleSAhPSBudWxsKSB7XG4gICAgICAgIGVzY2FwZWRDaGlsZEtleSA9IGVzY2FwZVVzZXJQcm92aWRlZEtleShjaGlsZEtleSkgKyAnLyc7XG4gICAgICB9XG5cbiAgICAgIG1hcEludG9BcnJheShtYXBwZWRDaGlsZCwgYXJyYXksIGVzY2FwZWRDaGlsZEtleSwgJycsIGZ1bmN0aW9uIChjKSB7XG4gICAgICAgIHJldHVybiBjO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChtYXBwZWRDaGlsZCAhPSBudWxsKSB7XG4gICAgICBpZiAoaXNWYWxpZEVsZW1lbnQobWFwcGVkQ2hpbGQpKSB7XG4gICAgICAgIG1hcHBlZENoaWxkID0gY2xvbmVBbmRSZXBsYWNlS2V5KG1hcHBlZENoaWxkLCAvLyBLZWVwIGJvdGggdGhlIChtYXBwZWQpIGFuZCBvbGQga2V5cyBpZiB0aGV5IGRpZmZlciwganVzdCBhc1xuICAgICAgICAvLyB0cmF2ZXJzZUFsbENoaWxkcmVuIHVzZWQgdG8gZG8gZm9yIG9iamVjdHMgYXMgY2hpbGRyZW5cbiAgICAgICAgZXNjYXBlZFByZWZpeCArICggLy8gJEZsb3dGaXhNZSBGbG93IGluY29ycmVjdGx5IHRoaW5rcyBSZWFjdC5Qb3J0YWwgZG9lc24ndCBoYXZlIGEga2V5XG4gICAgICAgIG1hcHBlZENoaWxkLmtleSAmJiAoIV9jaGlsZCB8fCBfY2hpbGQua2V5ICE9PSBtYXBwZWRDaGlsZC5rZXkpID8gLy8gJEZsb3dGaXhNZSBGbG93IGluY29ycmVjdGx5IHRoaW5rcyBleGlzdGluZyBlbGVtZW50J3Mga2V5IGNhbiBiZSBhIG51bWJlclxuICAgICAgICBlc2NhcGVVc2VyUHJvdmlkZWRLZXkoJycgKyBtYXBwZWRDaGlsZC5rZXkpICsgJy8nIDogJycpICsgY2hpbGRLZXkpO1xuICAgICAgfVxuXG4gICAgICBhcnJheS5wdXNoKG1hcHBlZENoaWxkKTtcbiAgICB9XG5cbiAgICByZXR1cm4gMTtcbiAgfVxuXG4gIHZhciBjaGlsZDtcbiAgdmFyIG5leHROYW1lO1xuICB2YXIgc3VidHJlZUNvdW50ID0gMDsgLy8gQ291bnQgb2YgY2hpbGRyZW4gZm91bmQgaW4gdGhlIGN1cnJlbnQgc3VidHJlZS5cblxuICB2YXIgbmV4dE5hbWVQcmVmaXggPSBuYW1lU29GYXIgPT09ICcnID8gU0VQQVJBVE9SIDogbmFtZVNvRmFyICsgU1VCU0VQQVJBVE9SO1xuXG4gIGlmIChBcnJheS5pc0FycmF5KGNoaWxkcmVuKSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNoaWxkID0gY2hpbGRyZW5baV07XG4gICAgICBuZXh0TmFtZSA9IG5leHROYW1lUHJlZml4ICsgZ2V0RWxlbWVudEtleShjaGlsZCwgaSk7XG4gICAgICBzdWJ0cmVlQ291bnQgKz0gbWFwSW50b0FycmF5KGNoaWxkLCBhcnJheSwgZXNjYXBlZFByZWZpeCwgbmV4dE5hbWUsIGNhbGxiYWNrKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIGl0ZXJhdG9yRm4gPSBnZXRJdGVyYXRvckZuKGNoaWxkcmVuKTtcblxuICAgIGlmICh0eXBlb2YgaXRlcmF0b3JGbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdmFyIGl0ZXJhYmxlQ2hpbGRyZW4gPSBjaGlsZHJlbjtcblxuICAgICAge1xuICAgICAgICAvLyBXYXJuIGFib3V0IHVzaW5nIE1hcHMgYXMgY2hpbGRyZW5cbiAgICAgICAgaWYgKGl0ZXJhdG9yRm4gPT09IGl0ZXJhYmxlQ2hpbGRyZW4uZW50cmllcykge1xuICAgICAgICAgIGlmICghZGlkV2FybkFib3V0TWFwcykge1xuICAgICAgICAgICAgd2FybignVXNpbmcgTWFwcyBhcyBjaGlsZHJlbiBpcyBub3Qgc3VwcG9ydGVkLiAnICsgJ1VzZSBhbiBhcnJheSBvZiBrZXllZCBSZWFjdEVsZW1lbnRzIGluc3RlYWQuJyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZGlkV2FybkFib3V0TWFwcyA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIGl0ZXJhdG9yID0gaXRlcmF0b3JGbi5jYWxsKGl0ZXJhYmxlQ2hpbGRyZW4pO1xuICAgICAgdmFyIHN0ZXA7XG4gICAgICB2YXIgaWkgPSAwO1xuXG4gICAgICB3aGlsZSAoIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lKSB7XG4gICAgICAgIGNoaWxkID0gc3RlcC52YWx1ZTtcbiAgICAgICAgbmV4dE5hbWUgPSBuZXh0TmFtZVByZWZpeCArIGdldEVsZW1lbnRLZXkoY2hpbGQsIGlpKyspO1xuICAgICAgICBzdWJ0cmVlQ291bnQgKz0gbWFwSW50b0FycmF5KGNoaWxkLCBhcnJheSwgZXNjYXBlZFByZWZpeCwgbmV4dE5hbWUsIGNhbGxiYWNrKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgICB2YXIgY2hpbGRyZW5TdHJpbmcgPSAnJyArIGNoaWxkcmVuO1xuXG4gICAgICB7XG4gICAgICAgIHtcbiAgICAgICAgICB0aHJvdyBFcnJvciggXCJPYmplY3RzIGFyZSBub3QgdmFsaWQgYXMgYSBSZWFjdCBjaGlsZCAoZm91bmQ6IFwiICsgKGNoaWxkcmVuU3RyaW5nID09PSAnW29iamVjdCBPYmplY3RdJyA/ICdvYmplY3Qgd2l0aCBrZXlzIHsnICsgT2JqZWN0LmtleXMoY2hpbGRyZW4pLmpvaW4oJywgJykgKyAnfScgOiBjaGlsZHJlblN0cmluZykgKyBcIikuIElmIHlvdSBtZWFudCB0byByZW5kZXIgYSBjb2xsZWN0aW9uIG9mIGNoaWxkcmVuLCB1c2UgYW4gYXJyYXkgaW5zdGVhZC5cIiApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHN1YnRyZWVDb3VudDtcbn1cblxuLyoqXG4gKiBNYXBzIGNoaWxkcmVuIHRoYXQgYXJlIHR5cGljYWxseSBzcGVjaWZpZWQgYXMgYHByb3BzLmNoaWxkcmVuYC5cbiAqXG4gKiBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL3JlYWN0LWFwaS5odG1sI3JlYWN0Y2hpbGRyZW5tYXBcbiAqXG4gKiBUaGUgcHJvdmlkZWQgbWFwRnVuY3Rpb24oY2hpbGQsIGluZGV4KSB3aWxsIGJlIGNhbGxlZCBmb3IgZWFjaFxuICogbGVhZiBjaGlsZC5cbiAqXG4gKiBAcGFyYW0gez8qfSBjaGlsZHJlbiBDaGlsZHJlbiB0cmVlIGNvbnRhaW5lci5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oKiwgaW50KX0gZnVuYyBUaGUgbWFwIGZ1bmN0aW9uLlxuICogQHBhcmFtIHsqfSBjb250ZXh0IENvbnRleHQgZm9yIG1hcEZ1bmN0aW9uLlxuICogQHJldHVybiB7b2JqZWN0fSBPYmplY3QgY29udGFpbmluZyB0aGUgb3JkZXJlZCBtYXAgb2YgcmVzdWx0cy5cbiAqL1xuZnVuY3Rpb24gbWFwQ2hpbGRyZW4oY2hpbGRyZW4sIGZ1bmMsIGNvbnRleHQpIHtcbiAgaWYgKGNoaWxkcmVuID09IG51bGwpIHtcbiAgICByZXR1cm4gY2hpbGRyZW47XG4gIH1cblxuICB2YXIgcmVzdWx0ID0gW107XG4gIHZhciBjb3VudCA9IDA7XG4gIG1hcEludG9BcnJheShjaGlsZHJlbiwgcmVzdWx0LCAnJywgJycsIGZ1bmN0aW9uIChjaGlsZCkge1xuICAgIHJldHVybiBmdW5jLmNhbGwoY29udGV4dCwgY2hpbGQsIGNvdW50KyspO1xuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cbi8qKlxuICogQ291bnQgdGhlIG51bWJlciBvZiBjaGlsZHJlbiB0aGF0IGFyZSB0eXBpY2FsbHkgc3BlY2lmaWVkIGFzXG4gKiBgcHJvcHMuY2hpbGRyZW5gLlxuICpcbiAqIFNlZSBodHRwczovL3JlYWN0anMub3JnL2RvY3MvcmVhY3QtYXBpLmh0bWwjcmVhY3RjaGlsZHJlbmNvdW50XG4gKlxuICogQHBhcmFtIHs/Kn0gY2hpbGRyZW4gQ2hpbGRyZW4gdHJlZSBjb250YWluZXIuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBudW1iZXIgb2YgY2hpbGRyZW4uXG4gKi9cblxuXG5mdW5jdGlvbiBjb3VudENoaWxkcmVuKGNoaWxkcmVuKSB7XG4gIHZhciBuID0gMDtcbiAgbWFwQ2hpbGRyZW4oY2hpbGRyZW4sIGZ1bmN0aW9uICgpIHtcbiAgICBuKys7IC8vIERvbid0IHJldHVybiBhbnl0aGluZ1xuICB9KTtcbiAgcmV0dXJuIG47XG59XG5cbi8qKlxuICogSXRlcmF0ZXMgdGhyb3VnaCBjaGlsZHJlbiB0aGF0IGFyZSB0eXBpY2FsbHkgc3BlY2lmaWVkIGFzIGBwcm9wcy5jaGlsZHJlbmAuXG4gKlxuICogU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9yZWFjdC1hcGkuaHRtbCNyZWFjdGNoaWxkcmVuZm9yZWFjaFxuICpcbiAqIFRoZSBwcm92aWRlZCBmb3JFYWNoRnVuYyhjaGlsZCwgaW5kZXgpIHdpbGwgYmUgY2FsbGVkIGZvciBlYWNoXG4gKiBsZWFmIGNoaWxkLlxuICpcbiAqIEBwYXJhbSB7Pyp9IGNoaWxkcmVuIENoaWxkcmVuIHRyZWUgY29udGFpbmVyLlxuICogQHBhcmFtIHtmdW5jdGlvbigqLCBpbnQpfSBmb3JFYWNoRnVuY1xuICogQHBhcmFtIHsqfSBmb3JFYWNoQ29udGV4dCBDb250ZXh0IGZvciBmb3JFYWNoQ29udGV4dC5cbiAqL1xuZnVuY3Rpb24gZm9yRWFjaENoaWxkcmVuKGNoaWxkcmVuLCBmb3JFYWNoRnVuYywgZm9yRWFjaENvbnRleHQpIHtcbiAgbWFwQ2hpbGRyZW4oY2hpbGRyZW4sIGZ1bmN0aW9uICgpIHtcbiAgICBmb3JFYWNoRnVuYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyAvLyBEb24ndCByZXR1cm4gYW55dGhpbmcuXG4gIH0sIGZvckVhY2hDb250ZXh0KTtcbn1cbi8qKlxuICogRmxhdHRlbiBhIGNoaWxkcmVuIG9iamVjdCAodHlwaWNhbGx5IHNwZWNpZmllZCBhcyBgcHJvcHMuY2hpbGRyZW5gKSBhbmRcbiAqIHJldHVybiBhbiBhcnJheSB3aXRoIGFwcHJvcHJpYXRlbHkgcmUta2V5ZWQgY2hpbGRyZW4uXG4gKlxuICogU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9yZWFjdC1hcGkuaHRtbCNyZWFjdGNoaWxkcmVudG9hcnJheVxuICovXG5cblxuZnVuY3Rpb24gdG9BcnJheShjaGlsZHJlbikge1xuICByZXR1cm4gbWFwQ2hpbGRyZW4oY2hpbGRyZW4sIGZ1bmN0aW9uIChjaGlsZCkge1xuICAgIHJldHVybiBjaGlsZDtcbiAgfSkgfHwgW107XG59XG4vKipcbiAqIFJldHVybnMgdGhlIGZpcnN0IGNoaWxkIGluIGEgY29sbGVjdGlvbiBvZiBjaGlsZHJlbiBhbmQgdmVyaWZpZXMgdGhhdCB0aGVyZVxuICogaXMgb25seSBvbmUgY2hpbGQgaW4gdGhlIGNvbGxlY3Rpb24uXG4gKlxuICogU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9yZWFjdC1hcGkuaHRtbCNyZWFjdGNoaWxkcmVub25seVxuICpcbiAqIFRoZSBjdXJyZW50IGltcGxlbWVudGF0aW9uIG9mIHRoaXMgZnVuY3Rpb24gYXNzdW1lcyB0aGF0IGEgc2luZ2xlIGNoaWxkIGdldHNcbiAqIHBhc3NlZCB3aXRob3V0IGEgd3JhcHBlciwgYnV0IHRoZSBwdXJwb3NlIG9mIHRoaXMgaGVscGVyIGZ1bmN0aW9uIGlzIHRvXG4gKiBhYnN0cmFjdCBhd2F5IHRoZSBwYXJ0aWN1bGFyIHN0cnVjdHVyZSBvZiBjaGlsZHJlbi5cbiAqXG4gKiBAcGFyYW0gez9vYmplY3R9IGNoaWxkcmVuIENoaWxkIGNvbGxlY3Rpb24gc3RydWN0dXJlLlxuICogQHJldHVybiB7UmVhY3RFbGVtZW50fSBUaGUgZmlyc3QgYW5kIG9ubHkgYFJlYWN0RWxlbWVudGAgY29udGFpbmVkIGluIHRoZVxuICogc3RydWN0dXJlLlxuICovXG5cblxuZnVuY3Rpb24gb25seUNoaWxkKGNoaWxkcmVuKSB7XG4gIGlmICghaXNWYWxpZEVsZW1lbnQoY2hpbGRyZW4pKSB7XG4gICAge1xuICAgICAgdGhyb3cgRXJyb3IoIFwiUmVhY3QuQ2hpbGRyZW4ub25seSBleHBlY3RlZCB0byByZWNlaXZlIGEgc2luZ2xlIFJlYWN0IGVsZW1lbnQgY2hpbGQuXCIgKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gY2hpbGRyZW47XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUNvbnRleHQoZGVmYXVsdFZhbHVlLCBjYWxjdWxhdGVDaGFuZ2VkQml0cykge1xuICBpZiAoY2FsY3VsYXRlQ2hhbmdlZEJpdHMgPT09IHVuZGVmaW5lZCkge1xuICAgIGNhbGN1bGF0ZUNoYW5nZWRCaXRzID0gbnVsbDtcbiAgfSBlbHNlIHtcbiAgICB7XG4gICAgICBpZiAoY2FsY3VsYXRlQ2hhbmdlZEJpdHMgIT09IG51bGwgJiYgdHlwZW9mIGNhbGN1bGF0ZUNoYW5nZWRCaXRzICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGVycm9yKCdjcmVhdGVDb250ZXh0OiBFeHBlY3RlZCB0aGUgb3B0aW9uYWwgc2Vjb25kIGFyZ3VtZW50IHRvIGJlIGEgJyArICdmdW5jdGlvbi4gSW5zdGVhZCByZWNlaXZlZDogJXMnLCBjYWxjdWxhdGVDaGFuZ2VkQml0cyk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdmFyIGNvbnRleHQgPSB7XG4gICAgJCR0eXBlb2Y6IFJFQUNUX0NPTlRFWFRfVFlQRSxcbiAgICBfY2FsY3VsYXRlQ2hhbmdlZEJpdHM6IGNhbGN1bGF0ZUNoYW5nZWRCaXRzLFxuICAgIC8vIEFzIGEgd29ya2Fyb3VuZCB0byBzdXBwb3J0IG11bHRpcGxlIGNvbmN1cnJlbnQgcmVuZGVyZXJzLCB3ZSBjYXRlZ29yaXplXG4gICAgLy8gc29tZSByZW5kZXJlcnMgYXMgcHJpbWFyeSBhbmQgb3RoZXJzIGFzIHNlY29uZGFyeS4gV2Ugb25seSBleHBlY3RcbiAgICAvLyB0aGVyZSB0byBiZSB0d28gY29uY3VycmVudCByZW5kZXJlcnMgYXQgbW9zdDogUmVhY3QgTmF0aXZlIChwcmltYXJ5KSBhbmRcbiAgICAvLyBGYWJyaWMgKHNlY29uZGFyeSk7IFJlYWN0IERPTSAocHJpbWFyeSkgYW5kIFJlYWN0IEFSVCAoc2Vjb25kYXJ5KS5cbiAgICAvLyBTZWNvbmRhcnkgcmVuZGVyZXJzIHN0b3JlIHRoZWlyIGNvbnRleHQgdmFsdWVzIG9uIHNlcGFyYXRlIGZpZWxkcy5cbiAgICBfY3VycmVudFZhbHVlOiBkZWZhdWx0VmFsdWUsXG4gICAgX2N1cnJlbnRWYWx1ZTI6IGRlZmF1bHRWYWx1ZSxcbiAgICAvLyBVc2VkIHRvIHRyYWNrIGhvdyBtYW55IGNvbmN1cnJlbnQgcmVuZGVyZXJzIHRoaXMgY29udGV4dCBjdXJyZW50bHlcbiAgICAvLyBzdXBwb3J0cyB3aXRoaW4gaW4gYSBzaW5nbGUgcmVuZGVyZXIuIFN1Y2ggYXMgcGFyYWxsZWwgc2VydmVyIHJlbmRlcmluZy5cbiAgICBfdGhyZWFkQ291bnQ6IDAsXG4gICAgLy8gVGhlc2UgYXJlIGNpcmN1bGFyXG4gICAgUHJvdmlkZXI6IG51bGwsXG4gICAgQ29uc3VtZXI6IG51bGxcbiAgfTtcbiAgY29udGV4dC5Qcm92aWRlciA9IHtcbiAgICAkJHR5cGVvZjogUkVBQ1RfUFJPVklERVJfVFlQRSxcbiAgICBfY29udGV4dDogY29udGV4dFxuICB9O1xuICB2YXIgaGFzV2FybmVkQWJvdXRVc2luZ05lc3RlZENvbnRleHRDb25zdW1lcnMgPSBmYWxzZTtcbiAgdmFyIGhhc1dhcm5lZEFib3V0VXNpbmdDb25zdW1lclByb3ZpZGVyID0gZmFsc2U7XG4gIHZhciBoYXNXYXJuZWRBYm91dERpc3BsYXlOYW1lT25Db25zdW1lciA9IGZhbHNlO1xuXG4gIHtcbiAgICAvLyBBIHNlcGFyYXRlIG9iamVjdCwgYnV0IHByb3hpZXMgYmFjayB0byB0aGUgb3JpZ2luYWwgY29udGV4dCBvYmplY3QgZm9yXG4gICAgLy8gYmFja3dhcmRzIGNvbXBhdGliaWxpdHkuIEl0IGhhcyBhIGRpZmZlcmVudCAkJHR5cGVvZiwgc28gd2UgY2FuIHByb3Blcmx5XG4gICAgLy8gd2FybiBmb3IgdGhlIGluY29ycmVjdCB1c2FnZSBvZiBDb250ZXh0IGFzIGEgQ29uc3VtZXIuXG4gICAgdmFyIENvbnN1bWVyID0ge1xuICAgICAgJCR0eXBlb2Y6IFJFQUNUX0NPTlRFWFRfVFlQRSxcbiAgICAgIF9jb250ZXh0OiBjb250ZXh0LFxuICAgICAgX2NhbGN1bGF0ZUNoYW5nZWRCaXRzOiBjb250ZXh0Ll9jYWxjdWxhdGVDaGFuZ2VkQml0c1xuICAgIH07IC8vICRGbG93Rml4TWU6IEZsb3cgY29tcGxhaW5zIGFib3V0IG5vdCBzZXR0aW5nIGEgdmFsdWUsIHdoaWNoIGlzIGludGVudGlvbmFsIGhlcmVcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKENvbnN1bWVyLCB7XG4gICAgICBQcm92aWRlcjoge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpZiAoIWhhc1dhcm5lZEFib3V0VXNpbmdDb25zdW1lclByb3ZpZGVyKSB7XG4gICAgICAgICAgICBoYXNXYXJuZWRBYm91dFVzaW5nQ29uc3VtZXJQcm92aWRlciA9IHRydWU7XG5cbiAgICAgICAgICAgIGVycm9yKCdSZW5kZXJpbmcgPENvbnRleHQuQ29uc3VtZXIuUHJvdmlkZXI+IGlzIG5vdCBzdXBwb3J0ZWQgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiAnICsgJ2EgZnV0dXJlIG1ham9yIHJlbGVhc2UuIERpZCB5b3UgbWVhbiB0byByZW5kZXIgPENvbnRleHQuUHJvdmlkZXI+IGluc3RlYWQ/Jyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIGNvbnRleHQuUHJvdmlkZXI7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKF9Qcm92aWRlcikge1xuICAgICAgICAgIGNvbnRleHQuUHJvdmlkZXIgPSBfUHJvdmlkZXI7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBfY3VycmVudFZhbHVlOiB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBjb250ZXh0Ll9jdXJyZW50VmFsdWU7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKF9jdXJyZW50VmFsdWUpIHtcbiAgICAgICAgICBjb250ZXh0Ll9jdXJyZW50VmFsdWUgPSBfY3VycmVudFZhbHVlO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgX2N1cnJlbnRWYWx1ZTI6IHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIGNvbnRleHQuX2N1cnJlbnRWYWx1ZTI7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKF9jdXJyZW50VmFsdWUyKSB7XG4gICAgICAgICAgY29udGV4dC5fY3VycmVudFZhbHVlMiA9IF9jdXJyZW50VmFsdWUyO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgX3RocmVhZENvdW50OiB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBjb250ZXh0Ll90aHJlYWRDb3VudDtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAoX3RocmVhZENvdW50KSB7XG4gICAgICAgICAgY29udGV4dC5fdGhyZWFkQ291bnQgPSBfdGhyZWFkQ291bnQ7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBDb25zdW1lcjoge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpZiAoIWhhc1dhcm5lZEFib3V0VXNpbmdOZXN0ZWRDb250ZXh0Q29uc3VtZXJzKSB7XG4gICAgICAgICAgICBoYXNXYXJuZWRBYm91dFVzaW5nTmVzdGVkQ29udGV4dENvbnN1bWVycyA9IHRydWU7XG5cbiAgICAgICAgICAgIGVycm9yKCdSZW5kZXJpbmcgPENvbnRleHQuQ29uc3VtZXIuQ29uc3VtZXI+IGlzIG5vdCBzdXBwb3J0ZWQgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiAnICsgJ2EgZnV0dXJlIG1ham9yIHJlbGVhc2UuIERpZCB5b3UgbWVhbiB0byByZW5kZXIgPENvbnRleHQuQ29uc3VtZXI+IGluc3RlYWQ/Jyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIGNvbnRleHQuQ29uc3VtZXI7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBkaXNwbGF5TmFtZToge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gY29udGV4dC5kaXNwbGF5TmFtZTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAoZGlzcGxheU5hbWUpIHtcbiAgICAgICAgICBpZiAoIWhhc1dhcm5lZEFib3V0RGlzcGxheU5hbWVPbkNvbnN1bWVyKSB7XG4gICAgICAgICAgICB3YXJuKCdTZXR0aW5nIGBkaXNwbGF5TmFtZWAgb24gQ29udGV4dC5Db25zdW1lciBoYXMgbm8gZWZmZWN0LiAnICsgXCJZb3Ugc2hvdWxkIHNldCBpdCBkaXJlY3RseSBvbiB0aGUgY29udGV4dCB3aXRoIENvbnRleHQuZGlzcGxheU5hbWUgPSAnJXMnLlwiLCBkaXNwbGF5TmFtZSk7XG5cbiAgICAgICAgICAgIGhhc1dhcm5lZEFib3V0RGlzcGxheU5hbWVPbkNvbnN1bWVyID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTsgLy8gJEZsb3dGaXhNZTogRmxvdyBjb21wbGFpbnMgYWJvdXQgbWlzc2luZyBwcm9wZXJ0aWVzIGJlY2F1c2UgaXQgZG9lc24ndCB1bmRlcnN0YW5kIGRlZmluZVByb3BlcnR5XG5cbiAgICBjb250ZXh0LkNvbnN1bWVyID0gQ29uc3VtZXI7XG4gIH1cblxuICB7XG4gICAgY29udGV4dC5fY3VycmVudFJlbmRlcmVyID0gbnVsbDtcbiAgICBjb250ZXh0Ll9jdXJyZW50UmVuZGVyZXIyID0gbnVsbDtcbiAgfVxuXG4gIHJldHVybiBjb250ZXh0O1xufVxuXG52YXIgVW5pbml0aWFsaXplZCA9IC0xO1xudmFyIFBlbmRpbmcgPSAwO1xudmFyIFJlc29sdmVkID0gMTtcbnZhciBSZWplY3RlZCA9IDI7XG5cbmZ1bmN0aW9uIGxhenlJbml0aWFsaXplcihwYXlsb2FkKSB7XG4gIGlmIChwYXlsb2FkLl9zdGF0dXMgPT09IFVuaW5pdGlhbGl6ZWQpIHtcbiAgICB2YXIgY3RvciA9IHBheWxvYWQuX3Jlc3VsdDtcbiAgICB2YXIgdGhlbmFibGUgPSBjdG9yKCk7IC8vIFRyYW5zaXRpb24gdG8gdGhlIG5leHQgc3RhdGUuXG5cbiAgICB2YXIgcGVuZGluZyA9IHBheWxvYWQ7XG4gICAgcGVuZGluZy5fc3RhdHVzID0gUGVuZGluZztcbiAgICBwZW5kaW5nLl9yZXN1bHQgPSB0aGVuYWJsZTtcbiAgICB0aGVuYWJsZS50aGVuKGZ1bmN0aW9uIChtb2R1bGVPYmplY3QpIHtcbiAgICAgIGlmIChwYXlsb2FkLl9zdGF0dXMgPT09IFBlbmRpbmcpIHtcbiAgICAgICAgdmFyIGRlZmF1bHRFeHBvcnQgPSBtb2R1bGVPYmplY3QuZGVmYXVsdDtcblxuICAgICAgICB7XG4gICAgICAgICAgaWYgKGRlZmF1bHRFeHBvcnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZXJyb3IoJ2xhenk6IEV4cGVjdGVkIHRoZSByZXN1bHQgb2YgYSBkeW5hbWljIGltcG9ydCgpIGNhbGwuICcgKyAnSW5zdGVhZCByZWNlaXZlZDogJXNcXG5cXG5Zb3VyIGNvZGUgc2hvdWxkIGxvb2sgbGlrZTogXFxuICAnICsgLy8gQnJlYWsgdXAgaW1wb3J0cyB0byBhdm9pZCBhY2NpZGVudGFsbHkgcGFyc2luZyB0aGVtIGFzIGRlcGVuZGVuY2llcy5cbiAgICAgICAgICAgICdjb25zdCBNeUNvbXBvbmVudCA9IGxhenkoKCkgPT4gaW1wJyArIFwib3J0KCcuL015Q29tcG9uZW50JykpXCIsIG1vZHVsZU9iamVjdCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IC8vIFRyYW5zaXRpb24gdG8gdGhlIG5leHQgc3RhdGUuXG5cblxuICAgICAgICB2YXIgcmVzb2x2ZWQgPSBwYXlsb2FkO1xuICAgICAgICByZXNvbHZlZC5fc3RhdHVzID0gUmVzb2x2ZWQ7XG4gICAgICAgIHJlc29sdmVkLl9yZXN1bHQgPSBkZWZhdWx0RXhwb3J0O1xuICAgICAgfVxuICAgIH0sIGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgaWYgKHBheWxvYWQuX3N0YXR1cyA9PT0gUGVuZGluZykge1xuICAgICAgICAvLyBUcmFuc2l0aW9uIHRvIHRoZSBuZXh0IHN0YXRlLlxuICAgICAgICB2YXIgcmVqZWN0ZWQgPSBwYXlsb2FkO1xuICAgICAgICByZWplY3RlZC5fc3RhdHVzID0gUmVqZWN0ZWQ7XG4gICAgICAgIHJlamVjdGVkLl9yZXN1bHQgPSBlcnJvcjtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGlmIChwYXlsb2FkLl9zdGF0dXMgPT09IFJlc29sdmVkKSB7XG4gICAgcmV0dXJuIHBheWxvYWQuX3Jlc3VsdDtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBwYXlsb2FkLl9yZXN1bHQ7XG4gIH1cbn1cblxuZnVuY3Rpb24gbGF6eShjdG9yKSB7XG4gIHZhciBwYXlsb2FkID0ge1xuICAgIC8vIFdlIHVzZSB0aGVzZSBmaWVsZHMgdG8gc3RvcmUgdGhlIHJlc3VsdC5cbiAgICBfc3RhdHVzOiAtMSxcbiAgICBfcmVzdWx0OiBjdG9yXG4gIH07XG4gIHZhciBsYXp5VHlwZSA9IHtcbiAgICAkJHR5cGVvZjogUkVBQ1RfTEFaWV9UWVBFLFxuICAgIF9wYXlsb2FkOiBwYXlsb2FkLFxuICAgIF9pbml0OiBsYXp5SW5pdGlhbGl6ZXJcbiAgfTtcblxuICB7XG4gICAgLy8gSW4gcHJvZHVjdGlvbiwgdGhpcyB3b3VsZCBqdXN0IHNldCBpdCBvbiB0aGUgb2JqZWN0LlxuICAgIHZhciBkZWZhdWx0UHJvcHM7XG4gICAgdmFyIHByb3BUeXBlczsgLy8gJEZsb3dGaXhNZVxuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMobGF6eVR5cGUsIHtcbiAgICAgIGRlZmF1bHRQcm9wczoge1xuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBkZWZhdWx0UHJvcHM7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKG5ld0RlZmF1bHRQcm9wcykge1xuICAgICAgICAgIGVycm9yKCdSZWFjdC5sYXp5KC4uLik6IEl0IGlzIG5vdCBzdXBwb3J0ZWQgdG8gYXNzaWduIGBkZWZhdWx0UHJvcHNgIHRvICcgKyAnYSBsYXp5IGNvbXBvbmVudCBpbXBvcnQuIEVpdGhlciBzcGVjaWZ5IHRoZW0gd2hlcmUgdGhlIGNvbXBvbmVudCAnICsgJ2lzIGRlZmluZWQsIG9yIGNyZWF0ZSBhIHdyYXBwaW5nIGNvbXBvbmVudCBhcm91bmQgaXQuJyk7XG5cbiAgICAgICAgICBkZWZhdWx0UHJvcHMgPSBuZXdEZWZhdWx0UHJvcHM7IC8vIE1hdGNoIHByb2R1Y3Rpb24gYmVoYXZpb3IgbW9yZSBjbG9zZWx5OlxuICAgICAgICAgIC8vICRGbG93Rml4TWVcblxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShsYXp5VHlwZSwgJ2RlZmF1bHRQcm9wcycsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHByb3BUeXBlczoge1xuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBwcm9wVHlwZXM7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKG5ld1Byb3BUeXBlcykge1xuICAgICAgICAgIGVycm9yKCdSZWFjdC5sYXp5KC4uLik6IEl0IGlzIG5vdCBzdXBwb3J0ZWQgdG8gYXNzaWduIGBwcm9wVHlwZXNgIHRvICcgKyAnYSBsYXp5IGNvbXBvbmVudCBpbXBvcnQuIEVpdGhlciBzcGVjaWZ5IHRoZW0gd2hlcmUgdGhlIGNvbXBvbmVudCAnICsgJ2lzIGRlZmluZWQsIG9yIGNyZWF0ZSBhIHdyYXBwaW5nIGNvbXBvbmVudCBhcm91bmQgaXQuJyk7XG5cbiAgICAgICAgICBwcm9wVHlwZXMgPSBuZXdQcm9wVHlwZXM7IC8vIE1hdGNoIHByb2R1Y3Rpb24gYmVoYXZpb3IgbW9yZSBjbG9zZWx5OlxuICAgICAgICAgIC8vICRGbG93Rml4TWVcblxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShsYXp5VHlwZSwgJ3Byb3BUeXBlcycsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIGxhenlUeXBlO1xufVxuXG5mdW5jdGlvbiBmb3J3YXJkUmVmKHJlbmRlcikge1xuICB7XG4gICAgaWYgKHJlbmRlciAhPSBudWxsICYmIHJlbmRlci4kJHR5cGVvZiA9PT0gUkVBQ1RfTUVNT19UWVBFKSB7XG4gICAgICBlcnJvcignZm9yd2FyZFJlZiByZXF1aXJlcyBhIHJlbmRlciBmdW5jdGlvbiBidXQgcmVjZWl2ZWQgYSBgbWVtb2AgJyArICdjb21wb25lbnQuIEluc3RlYWQgb2YgZm9yd2FyZFJlZihtZW1vKC4uLikpLCB1c2UgJyArICdtZW1vKGZvcndhcmRSZWYoLi4uKSkuJyk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgcmVuZGVyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICBlcnJvcignZm9yd2FyZFJlZiByZXF1aXJlcyBhIHJlbmRlciBmdW5jdGlvbiBidXQgd2FzIGdpdmVuICVzLicsIHJlbmRlciA9PT0gbnVsbCA/ICdudWxsJyA6IHR5cGVvZiByZW5kZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAocmVuZGVyLmxlbmd0aCAhPT0gMCAmJiByZW5kZXIubGVuZ3RoICE9PSAyKSB7XG4gICAgICAgIGVycm9yKCdmb3J3YXJkUmVmIHJlbmRlciBmdW5jdGlvbnMgYWNjZXB0IGV4YWN0bHkgdHdvIHBhcmFtZXRlcnM6IHByb3BzIGFuZCByZWYuICVzJywgcmVuZGVyLmxlbmd0aCA9PT0gMSA/ICdEaWQgeW91IGZvcmdldCB0byB1c2UgdGhlIHJlZiBwYXJhbWV0ZXI/JyA6ICdBbnkgYWRkaXRpb25hbCBwYXJhbWV0ZXIgd2lsbCBiZSB1bmRlZmluZWQuJyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHJlbmRlciAhPSBudWxsKSB7XG4gICAgICBpZiAocmVuZGVyLmRlZmF1bHRQcm9wcyAhPSBudWxsIHx8IHJlbmRlci5wcm9wVHlwZXMgIT0gbnVsbCkge1xuICAgICAgICBlcnJvcignZm9yd2FyZFJlZiByZW5kZXIgZnVuY3Rpb25zIGRvIG5vdCBzdXBwb3J0IHByb3BUeXBlcyBvciBkZWZhdWx0UHJvcHMuICcgKyAnRGlkIHlvdSBhY2NpZGVudGFsbHkgcGFzcyBhIFJlYWN0IGNvbXBvbmVudD8nKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB2YXIgZWxlbWVudFR5cGUgPSB7XG4gICAgJCR0eXBlb2Y6IFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUsXG4gICAgcmVuZGVyOiByZW5kZXJcbiAgfTtcblxuICB7XG4gICAgdmFyIG93bk5hbWU7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVsZW1lbnRUeXBlLCAnZGlzcGxheU5hbWUnLCB7XG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gb3duTmFtZTtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIG93bk5hbWUgPSBuYW1lO1xuXG4gICAgICAgIGlmIChyZW5kZXIuZGlzcGxheU5hbWUgPT0gbnVsbCkge1xuICAgICAgICAgIHJlbmRlci5kaXNwbGF5TmFtZSA9IG5hbWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiBlbGVtZW50VHlwZTtcbn1cblxuLy8gRmlsdGVyIGNlcnRhaW4gRE9NIGF0dHJpYnV0ZXMgKGUuZy4gc3JjLCBocmVmKSBpZiB0aGVpciB2YWx1ZXMgYXJlIGVtcHR5IHN0cmluZ3MuXG5cbnZhciBlbmFibGVTY29wZUFQSSA9IGZhbHNlOyAvLyBFeHBlcmltZW50YWwgQ3JlYXRlIEV2ZW50IEhhbmRsZSBBUEkuXG5cbmZ1bmN0aW9uIGlzVmFsaWRFbGVtZW50VHlwZSh0eXBlKSB7XG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSAvLyBOb3RlOiB0eXBlb2YgbWlnaHQgYmUgb3RoZXIgdGhhbiAnc3ltYm9sJyBvciAnbnVtYmVyJyAoZS5nLiBpZiBpdCdzIGEgcG9seWZpbGwpLlxuXG5cbiAgaWYgKHR5cGUgPT09IGV4cG9ydHMuRnJhZ21lbnQgfHwgdHlwZSA9PT0gZXhwb3J0cy5Qcm9maWxlciB8fCB0eXBlID09PSBSRUFDVF9ERUJVR19UUkFDSU5HX01PREVfVFlQRSB8fCB0eXBlID09PSBleHBvcnRzLlN0cmljdE1vZGUgfHwgdHlwZSA9PT0gZXhwb3J0cy5TdXNwZW5zZSB8fCB0eXBlID09PSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfTEVHQUNZX0hJRERFTl9UWVBFIHx8IGVuYWJsZVNjb3BlQVBJICkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0JyAmJiB0eXBlICE9PSBudWxsKSB7XG4gICAgaWYgKHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0xBWllfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9NRU1PX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfUFJPVklERVJfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9DT05URVhUX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9GVU5EQU1FTlRBTF9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0JMT0NLX1RZUEUgfHwgdHlwZVswXSA9PT0gUkVBQ1RfU0VSVkVSX0JMT0NLX1RZUEUpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gbWVtbyh0eXBlLCBjb21wYXJlKSB7XG4gIHtcbiAgICBpZiAoIWlzVmFsaWRFbGVtZW50VHlwZSh0eXBlKSkge1xuICAgICAgZXJyb3IoJ21lbW86IFRoZSBmaXJzdCBhcmd1bWVudCBtdXN0IGJlIGEgY29tcG9uZW50LiBJbnN0ZWFkICcgKyAncmVjZWl2ZWQ6ICVzJywgdHlwZSA9PT0gbnVsbCA/ICdudWxsJyA6IHR5cGVvZiB0eXBlKTtcbiAgICB9XG4gIH1cblxuICB2YXIgZWxlbWVudFR5cGUgPSB7XG4gICAgJCR0eXBlb2Y6IFJFQUNUX01FTU9fVFlQRSxcbiAgICB0eXBlOiB0eXBlLFxuICAgIGNvbXBhcmU6IGNvbXBhcmUgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBjb21wYXJlXG4gIH07XG5cbiAge1xuICAgIHZhciBvd25OYW1lO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbGVtZW50VHlwZSwgJ2Rpc3BsYXlOYW1lJywge1xuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG93bk5hbWU7XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICBvd25OYW1lID0gbmFtZTtcblxuICAgICAgICBpZiAodHlwZS5kaXNwbGF5TmFtZSA9PSBudWxsKSB7XG4gICAgICAgICAgdHlwZS5kaXNwbGF5TmFtZSA9IG5hbWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiBlbGVtZW50VHlwZTtcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZURpc3BhdGNoZXIoKSB7XG4gIHZhciBkaXNwYXRjaGVyID0gUmVhY3RDdXJyZW50RGlzcGF0Y2hlci5jdXJyZW50O1xuXG4gIGlmICghKGRpc3BhdGNoZXIgIT09IG51bGwpKSB7XG4gICAge1xuICAgICAgdGhyb3cgRXJyb3IoIFwiSW52YWxpZCBob29rIGNhbGwuIEhvb2tzIGNhbiBvbmx5IGJlIGNhbGxlZCBpbnNpZGUgb2YgdGhlIGJvZHkgb2YgYSBmdW5jdGlvbiBjb21wb25lbnQuIFRoaXMgY291bGQgaGFwcGVuIGZvciBvbmUgb2YgdGhlIGZvbGxvd2luZyByZWFzb25zOlxcbjEuIFlvdSBtaWdodCBoYXZlIG1pc21hdGNoaW5nIHZlcnNpb25zIG9mIFJlYWN0IGFuZCB0aGUgcmVuZGVyZXIgKHN1Y2ggYXMgUmVhY3QgRE9NKVxcbjIuIFlvdSBtaWdodCBiZSBicmVha2luZyB0aGUgUnVsZXMgb2YgSG9va3NcXG4zLiBZb3UgbWlnaHQgaGF2ZSBtb3JlIHRoYW4gb25lIGNvcHkgb2YgUmVhY3QgaW4gdGhlIHNhbWUgYXBwXFxuU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9pbnZhbGlkLWhvb2stY2FsbCBmb3IgdGlwcyBhYm91dCBob3cgdG8gZGVidWcgYW5kIGZpeCB0aGlzIHByb2JsZW0uXCIgKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZGlzcGF0Y2hlcjtcbn1cblxuZnVuY3Rpb24gdXNlQ29udGV4dChDb250ZXh0LCB1bnN0YWJsZV9vYnNlcnZlZEJpdHMpIHtcbiAgdmFyIGRpc3BhdGNoZXIgPSByZXNvbHZlRGlzcGF0Y2hlcigpO1xuXG4gIHtcbiAgICBpZiAodW5zdGFibGVfb2JzZXJ2ZWRCaXRzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGVycm9yKCd1c2VDb250ZXh0KCkgc2Vjb25kIGFyZ3VtZW50IGlzIHJlc2VydmVkIGZvciBmdXR1cmUgJyArICd1c2UgaW4gUmVhY3QuIFBhc3NpbmcgaXQgaXMgbm90IHN1cHBvcnRlZC4gJyArICdZb3UgcGFzc2VkOiAlcy4lcycsIHVuc3RhYmxlX29ic2VydmVkQml0cywgdHlwZW9mIHVuc3RhYmxlX29ic2VydmVkQml0cyA9PT0gJ251bWJlcicgJiYgQXJyYXkuaXNBcnJheShhcmd1bWVudHNbMl0pID8gJ1xcblxcbkRpZCB5b3UgY2FsbCBhcnJheS5tYXAodXNlQ29udGV4dCk/ICcgKyAnQ2FsbGluZyBIb29rcyBpbnNpZGUgYSBsb29wIGlzIG5vdCBzdXBwb3J0ZWQuICcgKyAnTGVhcm4gbW9yZSBhdCBodHRwczovL3JlYWN0anMub3JnL2xpbmsvcnVsZXMtb2YtaG9va3MnIDogJycpO1xuICAgIH0gLy8gVE9ETzogYWRkIGEgbW9yZSBnZW5lcmljIHdhcm5pbmcgZm9yIGludmFsaWQgdmFsdWVzLlxuXG5cbiAgICBpZiAoQ29udGV4dC5fY29udGV4dCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB2YXIgcmVhbENvbnRleHQgPSBDb250ZXh0Ll9jb250ZXh0OyAvLyBEb24ndCBkZWR1cGxpY2F0ZSBiZWNhdXNlIHRoaXMgbGVnaXRpbWF0ZWx5IGNhdXNlcyBidWdzXG4gICAgICAvLyBhbmQgbm9ib2R5IHNob3VsZCBiZSB1c2luZyB0aGlzIGluIGV4aXN0aW5nIGNvZGUuXG5cbiAgICAgIGlmIChyZWFsQ29udGV4dC5Db25zdW1lciA9PT0gQ29udGV4dCkge1xuICAgICAgICBlcnJvcignQ2FsbGluZyB1c2VDb250ZXh0KENvbnRleHQuQ29uc3VtZXIpIGlzIG5vdCBzdXBwb3J0ZWQsIG1heSBjYXVzZSBidWdzLCBhbmQgd2lsbCBiZSAnICsgJ3JlbW92ZWQgaW4gYSBmdXR1cmUgbWFqb3IgcmVsZWFzZS4gRGlkIHlvdSBtZWFuIHRvIGNhbGwgdXNlQ29udGV4dChDb250ZXh0KSBpbnN0ZWFkPycpO1xuICAgICAgfSBlbHNlIGlmIChyZWFsQ29udGV4dC5Qcm92aWRlciA9PT0gQ29udGV4dCkge1xuICAgICAgICBlcnJvcignQ2FsbGluZyB1c2VDb250ZXh0KENvbnRleHQuUHJvdmlkZXIpIGlzIG5vdCBzdXBwb3J0ZWQuICcgKyAnRGlkIHlvdSBtZWFuIHRvIGNhbGwgdXNlQ29udGV4dChDb250ZXh0KSBpbnN0ZWFkPycpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBkaXNwYXRjaGVyLnVzZUNvbnRleHQoQ29udGV4dCwgdW5zdGFibGVfb2JzZXJ2ZWRCaXRzKTtcbn1cbmZ1bmN0aW9uIHVzZVN0YXRlKGluaXRpYWxTdGF0ZSkge1xuICB2YXIgZGlzcGF0Y2hlciA9IHJlc29sdmVEaXNwYXRjaGVyKCk7XG4gIHJldHVybiBkaXNwYXRjaGVyLnVzZVN0YXRlKGluaXRpYWxTdGF0ZSk7XG59XG5mdW5jdGlvbiB1c2VSZWR1Y2VyKHJlZHVjZXIsIGluaXRpYWxBcmcsIGluaXQpIHtcbiAgdmFyIGRpc3BhdGNoZXIgPSByZXNvbHZlRGlzcGF0Y2hlcigpO1xuICByZXR1cm4gZGlzcGF0Y2hlci51c2VSZWR1Y2VyKHJlZHVjZXIsIGluaXRpYWxBcmcsIGluaXQpO1xufVxuZnVuY3Rpb24gdXNlUmVmKGluaXRpYWxWYWx1ZSkge1xuICB2YXIgZGlzcGF0Y2hlciA9IHJlc29sdmVEaXNwYXRjaGVyKCk7XG4gIHJldHVybiBkaXNwYXRjaGVyLnVzZVJlZihpbml0aWFsVmFsdWUpO1xufVxuZnVuY3Rpb24gdXNlRWZmZWN0KGNyZWF0ZSwgZGVwcykge1xuICB2YXIgZGlzcGF0Y2hlciA9IHJlc29sdmVEaXNwYXRjaGVyKCk7XG4gIHJldHVybiBkaXNwYXRjaGVyLnVzZUVmZmVjdChjcmVhdGUsIGRlcHMpO1xufVxuZnVuY3Rpb24gdXNlTGF5b3V0RWZmZWN0KGNyZWF0ZSwgZGVwcykge1xuICB2YXIgZGlzcGF0Y2hlciA9IHJlc29sdmVEaXNwYXRjaGVyKCk7XG4gIHJldHVybiBkaXNwYXRjaGVyLnVzZUxheW91dEVmZmVjdChjcmVhdGUsIGRlcHMpO1xufVxuZnVuY3Rpb24gdXNlQ2FsbGJhY2soY2FsbGJhY2ssIGRlcHMpIHtcbiAgdmFyIGRpc3BhdGNoZXIgPSByZXNvbHZlRGlzcGF0Y2hlcigpO1xuICByZXR1cm4gZGlzcGF0Y2hlci51c2VDYWxsYmFjayhjYWxsYmFjaywgZGVwcyk7XG59XG5mdW5jdGlvbiB1c2VNZW1vKGNyZWF0ZSwgZGVwcykge1xuICB2YXIgZGlzcGF0Y2hlciA9IHJlc29sdmVEaXNwYXRjaGVyKCk7XG4gIHJldHVybiBkaXNwYXRjaGVyLnVzZU1lbW8oY3JlYXRlLCBkZXBzKTtcbn1cbmZ1bmN0aW9uIHVzZUltcGVyYXRpdmVIYW5kbGUocmVmLCBjcmVhdGUsIGRlcHMpIHtcbiAgdmFyIGRpc3BhdGNoZXIgPSByZXNvbHZlRGlzcGF0Y2hlcigpO1xuICByZXR1cm4gZGlzcGF0Y2hlci51c2VJbXBlcmF0aXZlSGFuZGxlKHJlZiwgY3JlYXRlLCBkZXBzKTtcbn1cbmZ1bmN0aW9uIHVzZURlYnVnVmFsdWUodmFsdWUsIGZvcm1hdHRlckZuKSB7XG4gIHtcbiAgICB2YXIgZGlzcGF0Y2hlciA9IHJlc29sdmVEaXNwYXRjaGVyKCk7XG4gICAgcmV0dXJuIGRpc3BhdGNoZXIudXNlRGVidWdWYWx1ZSh2YWx1ZSwgZm9ybWF0dGVyRm4pO1xuICB9XG59XG5cbi8vIEhlbHBlcnMgdG8gcGF0Y2ggY29uc29sZS5sb2dzIHRvIGF2b2lkIGxvZ2dpbmcgZHVyaW5nIHNpZGUtZWZmZWN0IGZyZWVcbi8vIHJlcGxheWluZyBvbiByZW5kZXIgZnVuY3Rpb24uIFRoaXMgY3VycmVudGx5IG9ubHkgcGF0Y2hlcyB0aGUgb2JqZWN0XG4vLyBsYXppbHkgd2hpY2ggd29uJ3QgY292ZXIgaWYgdGhlIGxvZyBmdW5jdGlvbiB3YXMgZXh0cmFjdGVkIGVhZ2VybHkuXG4vLyBXZSBjb3VsZCBhbHNvIGVhZ2VybHkgcGF0Y2ggdGhlIG1ldGhvZC5cbnZhciBkaXNhYmxlZERlcHRoID0gMDtcbnZhciBwcmV2TG9nO1xudmFyIHByZXZJbmZvO1xudmFyIHByZXZXYXJuO1xudmFyIHByZXZFcnJvcjtcbnZhciBwcmV2R3JvdXA7XG52YXIgcHJldkdyb3VwQ29sbGFwc2VkO1xudmFyIHByZXZHcm91cEVuZDtcblxuZnVuY3Rpb24gZGlzYWJsZWRMb2coKSB7fVxuXG5kaXNhYmxlZExvZy5fX3JlYWN0RGlzYWJsZWRMb2cgPSB0cnVlO1xuZnVuY3Rpb24gZGlzYWJsZUxvZ3MoKSB7XG4gIHtcbiAgICBpZiAoZGlzYWJsZWREZXB0aCA9PT0gMCkge1xuICAgICAgLyogZXNsaW50LWRpc2FibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgICBwcmV2TG9nID0gY29uc29sZS5sb2c7XG4gICAgICBwcmV2SW5mbyA9IGNvbnNvbGUuaW5mbztcbiAgICAgIHByZXZXYXJuID0gY29uc29sZS53YXJuO1xuICAgICAgcHJldkVycm9yID0gY29uc29sZS5lcnJvcjtcbiAgICAgIHByZXZHcm91cCA9IGNvbnNvbGUuZ3JvdXA7XG4gICAgICBwcmV2R3JvdXBDb2xsYXBzZWQgPSBjb25zb2xlLmdyb3VwQ29sbGFwc2VkO1xuICAgICAgcHJldkdyb3VwRW5kID0gY29uc29sZS5ncm91cEVuZDsgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xOTA5OVxuXG4gICAgICB2YXIgcHJvcHMgPSB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IGRpc2FibGVkTG9nLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgfTsgLy8gJEZsb3dGaXhNZSBGbG93IHRoaW5rcyBjb25zb2xlIGlzIGltbXV0YWJsZS5cblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoY29uc29sZSwge1xuICAgICAgICBpbmZvOiBwcm9wcyxcbiAgICAgICAgbG9nOiBwcm9wcyxcbiAgICAgICAgd2FybjogcHJvcHMsXG4gICAgICAgIGVycm9yOiBwcm9wcyxcbiAgICAgICAgZ3JvdXA6IHByb3BzLFxuICAgICAgICBncm91cENvbGxhcHNlZDogcHJvcHMsXG4gICAgICAgIGdyb3VwRW5kOiBwcm9wc1xuICAgICAgfSk7XG4gICAgICAvKiBlc2xpbnQtZW5hYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgIH1cblxuICAgIGRpc2FibGVkRGVwdGgrKztcbiAgfVxufVxuZnVuY3Rpb24gcmVlbmFibGVMb2dzKCkge1xuICB7XG4gICAgZGlzYWJsZWREZXB0aC0tO1xuXG4gICAgaWYgKGRpc2FibGVkRGVwdGggPT09IDApIHtcbiAgICAgIC8qIGVzbGludC1kaXNhYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgICAgdmFyIHByb3BzID0ge1xuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICB9OyAvLyAkRmxvd0ZpeE1lIEZsb3cgdGhpbmtzIGNvbnNvbGUgaXMgaW1tdXRhYmxlLlxuXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhjb25zb2xlLCB7XG4gICAgICAgIGxvZzogX2Fzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkxvZ1xuICAgICAgICB9KSxcbiAgICAgICAgaW5mbzogX2Fzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkluZm9cbiAgICAgICAgfSksXG4gICAgICAgIHdhcm46IF9hc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZXYXJuXG4gICAgICAgIH0pLFxuICAgICAgICBlcnJvcjogX2Fzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkVycm9yXG4gICAgICAgIH0pLFxuICAgICAgICBncm91cDogX2Fzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkdyb3VwXG4gICAgICAgIH0pLFxuICAgICAgICBncm91cENvbGxhcHNlZDogX2Fzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkdyb3VwQ29sbGFwc2VkXG4gICAgICAgIH0pLFxuICAgICAgICBncm91cEVuZDogX2Fzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkdyb3VwRW5kXG4gICAgICAgIH0pXG4gICAgICB9KTtcbiAgICAgIC8qIGVzbGludC1lbmFibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgfVxuXG4gICAgaWYgKGRpc2FibGVkRGVwdGggPCAwKSB7XG4gICAgICBlcnJvcignZGlzYWJsZWREZXB0aCBmZWxsIGJlbG93IHplcm8uICcgKyAnVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gICAgfVxuICB9XG59XG5cbnZhciBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdEN1cnJlbnREaXNwYXRjaGVyO1xudmFyIHByZWZpeDtcbmZ1bmN0aW9uIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKG5hbWUsIHNvdXJjZSwgb3duZXJGbikge1xuICB7XG4gICAgaWYgKHByZWZpeCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBFeHRyYWN0IHRoZSBWTSBzcGVjaWZpYyBwcmVmaXggdXNlZCBieSBlYWNoIGxpbmUuXG4gICAgICB0cnkge1xuICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICB2YXIgbWF0Y2ggPSB4LnN0YWNrLnRyaW0oKS5tYXRjaCgvXFxuKCAqKGF0ICk/KS8pO1xuICAgICAgICBwcmVmaXggPSBtYXRjaCAmJiBtYXRjaFsxXSB8fCAnJztcbiAgICAgIH1cbiAgICB9IC8vIFdlIHVzZSB0aGUgcHJlZml4IHRvIGVuc3VyZSBvdXIgc3RhY2tzIGxpbmUgdXAgd2l0aCBuYXRpdmUgc3RhY2sgZnJhbWVzLlxuXG5cbiAgICByZXR1cm4gJ1xcbicgKyBwcmVmaXggKyBuYW1lO1xuICB9XG59XG52YXIgcmVlbnRyeSA9IGZhbHNlO1xudmFyIGNvbXBvbmVudEZyYW1lQ2FjaGU7XG5cbntcbiAgdmFyIFBvc3NpYmx5V2Vha01hcCA9IHR5cGVvZiBXZWFrTWFwID09PSAnZnVuY3Rpb24nID8gV2Vha01hcCA6IE1hcDtcbiAgY29tcG9uZW50RnJhbWVDYWNoZSA9IG5ldyBQb3NzaWJseVdlYWtNYXAoKTtcbn1cblxuZnVuY3Rpb24gZGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZShmbiwgY29uc3RydWN0KSB7XG4gIC8vIElmIHNvbWV0aGluZyBhc2tlZCBmb3IgYSBzdGFjayBpbnNpZGUgYSBmYWtlIHJlbmRlciwgaXQgc2hvdWxkIGdldCBpZ25vcmVkLlxuICBpZiAoIWZuIHx8IHJlZW50cnkpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICB7XG4gICAgdmFyIGZyYW1lID0gY29tcG9uZW50RnJhbWVDYWNoZS5nZXQoZm4pO1xuXG4gICAgaWYgKGZyYW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBmcmFtZTtcbiAgICB9XG4gIH1cblxuICB2YXIgY29udHJvbDtcbiAgcmVlbnRyeSA9IHRydWU7XG4gIHZhciBwcmV2aW91c1ByZXBhcmVTdGFja1RyYWNlID0gRXJyb3IucHJlcGFyZVN0YWNrVHJhY2U7IC8vICRGbG93Rml4TWUgSXQgZG9lcyBhY2NlcHQgdW5kZWZpbmVkLlxuXG4gIEVycm9yLnByZXBhcmVTdGFja1RyYWNlID0gdW5kZWZpbmVkO1xuICB2YXIgcHJldmlvdXNEaXNwYXRjaGVyO1xuXG4gIHtcbiAgICBwcmV2aW91c0Rpc3BhdGNoZXIgPSBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudDsgLy8gU2V0IHRoZSBkaXNwYXRjaGVyIGluIERFViBiZWNhdXNlIHRoaXMgbWlnaHQgYmUgY2FsbCBpbiB0aGUgcmVuZGVyIGZ1bmN0aW9uXG4gICAgLy8gZm9yIHdhcm5pbmdzLlxuXG4gICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQgPSBudWxsO1xuICAgIGRpc2FibGVMb2dzKCk7XG4gIH1cblxuICB0cnkge1xuICAgIC8vIFRoaXMgc2hvdWxkIHRocm93LlxuICAgIGlmIChjb25zdHJ1Y3QpIHtcbiAgICAgIC8vIFNvbWV0aGluZyBzaG91bGQgYmUgc2V0dGluZyB0aGUgcHJvcHMgaW4gdGhlIGNvbnN0cnVjdG9yLlxuICAgICAgdmFyIEZha2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICB9OyAvLyAkRmxvd0ZpeE1lXG5cblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEZha2UucHJvdG90eXBlLCAncHJvcHMnLCB7XG4gICAgICAgIHNldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIC8vIFdlIHVzZSBhIHRocm93aW5nIHNldHRlciBpbnN0ZWFkIG9mIGZyb3plbiBvciBub24td3JpdGFibGUgcHJvcHNcbiAgICAgICAgICAvLyBiZWNhdXNlIHRoYXQgd29uJ3QgdGhyb3cgaW4gYSBub24tc3RyaWN0IG1vZGUgZnVuY3Rpb24uXG4gICAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gJ29iamVjdCcgJiYgUmVmbGVjdC5jb25zdHJ1Y3QpIHtcbiAgICAgICAgLy8gV2UgY29uc3RydWN0IGEgZGlmZmVyZW50IGNvbnRyb2wgZm9yIHRoaXMgY2FzZSB0byBpbmNsdWRlIGFueSBleHRyYVxuICAgICAgICAvLyBmcmFtZXMgYWRkZWQgYnkgdGhlIGNvbnN0cnVjdCBjYWxsLlxuICAgICAgICB0cnkge1xuICAgICAgICAgIFJlZmxlY3QuY29uc3RydWN0KEZha2UsIFtdKTtcbiAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgIGNvbnRyb2wgPSB4O1xuICAgICAgICB9XG5cbiAgICAgICAgUmVmbGVjdC5jb25zdHJ1Y3QoZm4sIFtdLCBGYWtlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgRmFrZS5jYWxsKCk7XG4gICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICBjb250cm9sID0geDtcbiAgICAgICAgfVxuXG4gICAgICAgIGZuLmNhbGwoRmFrZS5wcm90b3R5cGUpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0cnkge1xuICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICBjb250cm9sID0geDtcbiAgICAgIH1cblxuICAgICAgZm4oKTtcbiAgICB9XG4gIH0gY2F0Y2ggKHNhbXBsZSkge1xuICAgIC8vIFRoaXMgaXMgaW5saW5lZCBtYW51YWxseSBiZWNhdXNlIGNsb3N1cmUgZG9lc24ndCBkbyBpdCBmb3IgdXMuXG4gICAgaWYgKHNhbXBsZSAmJiBjb250cm9sICYmIHR5cGVvZiBzYW1wbGUuc3RhY2sgPT09ICdzdHJpbmcnKSB7XG4gICAgICAvLyBUaGlzIGV4dHJhY3RzIHRoZSBmaXJzdCBmcmFtZSBmcm9tIHRoZSBzYW1wbGUgdGhhdCBpc24ndCBhbHNvIGluIHRoZSBjb250cm9sLlxuICAgICAgLy8gU2tpcHBpbmcgb25lIGZyYW1lIHRoYXQgd2UgYXNzdW1lIGlzIHRoZSBmcmFtZSB0aGF0IGNhbGxzIHRoZSB0d28uXG4gICAgICB2YXIgc2FtcGxlTGluZXMgPSBzYW1wbGUuc3RhY2suc3BsaXQoJ1xcbicpO1xuICAgICAgdmFyIGNvbnRyb2xMaW5lcyA9IGNvbnRyb2wuc3RhY2suc3BsaXQoJ1xcbicpO1xuICAgICAgdmFyIHMgPSBzYW1wbGVMaW5lcy5sZW5ndGggLSAxO1xuICAgICAgdmFyIGMgPSBjb250cm9sTGluZXMubGVuZ3RoIC0gMTtcblxuICAgICAgd2hpbGUgKHMgPj0gMSAmJiBjID49IDAgJiYgc2FtcGxlTGluZXNbc10gIT09IGNvbnRyb2xMaW5lc1tjXSkge1xuICAgICAgICAvLyBXZSBleHBlY3QgYXQgbGVhc3Qgb25lIHN0YWNrIGZyYW1lIHRvIGJlIHNoYXJlZC5cbiAgICAgICAgLy8gVHlwaWNhbGx5IHRoaXMgd2lsbCBiZSB0aGUgcm9vdCBtb3N0IG9uZS4gSG93ZXZlciwgc3RhY2sgZnJhbWVzIG1heSBiZVxuICAgICAgICAvLyBjdXQgb2ZmIGR1ZSB0byBtYXhpbXVtIHN0YWNrIGxpbWl0cy4gSW4gdGhpcyBjYXNlLCBvbmUgbWF5YmUgY3V0IG9mZlxuICAgICAgICAvLyBlYXJsaWVyIHRoYW4gdGhlIG90aGVyLiBXZSBhc3N1bWUgdGhhdCB0aGUgc2FtcGxlIGlzIGxvbmdlciBvciB0aGUgc2FtZVxuICAgICAgICAvLyBhbmQgdGhlcmUgZm9yIGN1dCBvZmYgZWFybGllci4gU28gd2Ugc2hvdWxkIGZpbmQgdGhlIHJvb3QgbW9zdCBmcmFtZSBpblxuICAgICAgICAvLyB0aGUgc2FtcGxlIHNvbWV3aGVyZSBpbiB0aGUgY29udHJvbC5cbiAgICAgICAgYy0tO1xuICAgICAgfVxuXG4gICAgICBmb3IgKDsgcyA+PSAxICYmIGMgPj0gMDsgcy0tLCBjLS0pIHtcbiAgICAgICAgLy8gTmV4dCB3ZSBmaW5kIHRoZSBmaXJzdCBvbmUgdGhhdCBpc24ndCB0aGUgc2FtZSB3aGljaCBzaG91bGQgYmUgdGhlXG4gICAgICAgIC8vIGZyYW1lIHRoYXQgY2FsbGVkIG91ciBzYW1wbGUgZnVuY3Rpb24gYW5kIHRoZSBjb250cm9sLlxuICAgICAgICBpZiAoc2FtcGxlTGluZXNbc10gIT09IGNvbnRyb2xMaW5lc1tjXSkge1xuICAgICAgICAgIC8vIEluIFY4LCB0aGUgZmlyc3QgbGluZSBpcyBkZXNjcmliaW5nIHRoZSBtZXNzYWdlIGJ1dCBvdGhlciBWTXMgZG9uJ3QuXG4gICAgICAgICAgLy8gSWYgd2UncmUgYWJvdXQgdG8gcmV0dXJuIHRoZSBmaXJzdCBsaW5lLCBhbmQgdGhlIGNvbnRyb2wgaXMgYWxzbyBvbiB0aGUgc2FtZVxuICAgICAgICAgIC8vIGxpbmUsIHRoYXQncyBhIHByZXR0eSBnb29kIGluZGljYXRvciB0aGF0IG91ciBzYW1wbGUgdGhyZXcgYXQgc2FtZSBsaW5lIGFzXG4gICAgICAgICAgLy8gdGhlIGNvbnRyb2wuIEkuZS4gYmVmb3JlIHdlIGVudGVyZWQgdGhlIHNhbXBsZSBmcmFtZS4gU28gd2UgaWdub3JlIHRoaXMgcmVzdWx0LlxuICAgICAgICAgIC8vIFRoaXMgY2FuIGhhcHBlbiBpZiB5b3UgcGFzc2VkIGEgY2xhc3MgdG8gZnVuY3Rpb24gY29tcG9uZW50LCBvciBub24tZnVuY3Rpb24uXG4gICAgICAgICAgaWYgKHMgIT09IDEgfHwgYyAhPT0gMSkge1xuICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICBzLS07XG4gICAgICAgICAgICAgIGMtLTsgLy8gV2UgbWF5IHN0aWxsIGhhdmUgc2ltaWxhciBpbnRlcm1lZGlhdGUgZnJhbWVzIGZyb20gdGhlIGNvbnN0cnVjdCBjYWxsLlxuICAgICAgICAgICAgICAvLyBUaGUgbmV4dCBvbmUgdGhhdCBpc24ndCB0aGUgc2FtZSBzaG91bGQgYmUgb3VyIG1hdGNoIHRob3VnaC5cblxuICAgICAgICAgICAgICBpZiAoYyA8IDAgfHwgc2FtcGxlTGluZXNbc10gIT09IGNvbnRyb2xMaW5lc1tjXSkge1xuICAgICAgICAgICAgICAgIC8vIFY4IGFkZHMgYSBcIm5ld1wiIHByZWZpeCBmb3IgbmF0aXZlIGNsYXNzZXMuIExldCdzIHJlbW92ZSBpdCB0byBtYWtlIGl0IHByZXR0aWVyLlxuICAgICAgICAgICAgICAgIHZhciBfZnJhbWUgPSAnXFxuJyArIHNhbXBsZUxpbmVzW3NdLnJlcGxhY2UoJyBhdCBuZXcgJywgJyBhdCAnKTtcblxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50RnJhbWVDYWNoZS5zZXQoZm4sIF9mcmFtZSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSAvLyBSZXR1cm4gdGhlIGxpbmUgd2UgZm91bmQuXG5cblxuICAgICAgICAgICAgICAgIHJldHVybiBfZnJhbWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gd2hpbGUgKHMgPj0gMSAmJiBjID49IDApO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9IGZpbmFsbHkge1xuICAgIHJlZW50cnkgPSBmYWxzZTtcblxuICAgIHtcbiAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50ID0gcHJldmlvdXNEaXNwYXRjaGVyO1xuICAgICAgcmVlbmFibGVMb2dzKCk7XG4gICAgfVxuXG4gICAgRXJyb3IucHJlcGFyZVN0YWNrVHJhY2UgPSBwcmV2aW91c1ByZXBhcmVTdGFja1RyYWNlO1xuICB9IC8vIEZhbGxiYWNrIHRvIGp1c3QgdXNpbmcgdGhlIG5hbWUgaWYgd2UgY291bGRuJ3QgbWFrZSBpdCB0aHJvdy5cblxuXG4gIHZhciBuYW1lID0gZm4gPyBmbi5kaXNwbGF5TmFtZSB8fCBmbi5uYW1lIDogJyc7XG4gIHZhciBzeW50aGV0aWNGcmFtZSA9IG5hbWUgPyBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZShuYW1lKSA6ICcnO1xuXG4gIHtcbiAgICBpZiAodHlwZW9mIGZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjb21wb25lbnRGcmFtZUNhY2hlLnNldChmbiwgc3ludGhldGljRnJhbWUpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzeW50aGV0aWNGcmFtZTtcbn1cbmZ1bmN0aW9uIGRlc2NyaWJlRnVuY3Rpb25Db21wb25lbnRGcmFtZShmbiwgc291cmNlLCBvd25lckZuKSB7XG4gIHtcbiAgICByZXR1cm4gZGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZShmbiwgZmFsc2UpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHNob3VsZENvbnN0cnVjdChDb21wb25lbnQpIHtcbiAgdmFyIHByb3RvdHlwZSA9IENvbXBvbmVudC5wcm90b3R5cGU7XG4gIHJldHVybiAhIShwcm90b3R5cGUgJiYgcHJvdG90eXBlLmlzUmVhY3RDb21wb25lbnQpO1xufVxuXG5mdW5jdGlvbiBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYodHlwZSwgc291cmNlLCBvd25lckZuKSB7XG5cbiAgaWYgKHR5cGUgPT0gbnVsbCkge1xuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHtcbiAgICAgIHJldHVybiBkZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lKHR5cGUsIHNob3VsZENvbnN0cnVjdCh0eXBlKSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZSh0eXBlKTtcbiAgfVxuXG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgZXhwb3J0cy5TdXNwZW5zZTpcbiAgICAgIHJldHVybiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZSgnU3VzcGVuc2UnKTtcblxuICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFOlxuICAgICAgcmV0dXJuIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKCdTdXNwZW5zZUxpc3QnKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICBzd2l0Y2ggKHR5cGUuJCR0eXBlb2YpIHtcbiAgICAgIGNhc2UgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRTpcbiAgICAgICAgcmV0dXJuIGRlc2NyaWJlRnVuY3Rpb25Db21wb25lbnRGcmFtZSh0eXBlLnJlbmRlcik7XG5cbiAgICAgIGNhc2UgUkVBQ1RfTUVNT19UWVBFOlxuICAgICAgICAvLyBNZW1vIG1heSBjb250YWluIGFueSBjb21wb25lbnQgdHlwZSBzbyB3ZSByZWN1cnNpdmVseSByZXNvbHZlIGl0LlxuICAgICAgICByZXR1cm4gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKHR5cGUudHlwZSwgc291cmNlLCBvd25lckZuKTtcblxuICAgICAgY2FzZSBSRUFDVF9CTE9DS19UWVBFOlxuICAgICAgICByZXR1cm4gZGVzY3JpYmVGdW5jdGlvbkNvbXBvbmVudEZyYW1lKHR5cGUuX3JlbmRlcik7XG5cbiAgICAgIGNhc2UgUkVBQ1RfTEFaWV9UWVBFOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIGxhenlDb21wb25lbnQgPSB0eXBlO1xuICAgICAgICAgIHZhciBwYXlsb2FkID0gbGF6eUNvbXBvbmVudC5fcGF5bG9hZDtcbiAgICAgICAgICB2YXIgaW5pdCA9IGxhenlDb21wb25lbnQuX2luaXQ7XG5cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gTGF6eSBtYXkgY29udGFpbiBhbnkgY29tcG9uZW50IHR5cGUgc28gd2UgcmVjdXJzaXZlbHkgcmVzb2x2ZSBpdC5cbiAgICAgICAgICAgIHJldHVybiBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYoaW5pdChwYXlsb2FkKSwgc291cmNlLCBvd25lckZuKTtcbiAgICAgICAgICB9IGNhdGNoICh4KSB7fVxuICAgICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuICcnO1xufVxuXG52YXIgbG9nZ2VkVHlwZUZhaWx1cmVzID0ge307XG52YXIgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSQxID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZTtcblxuZnVuY3Rpb24gc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQoZWxlbWVudCkge1xuICB7XG4gICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgIHZhciBvd25lciA9IGVsZW1lbnQuX293bmVyO1xuICAgICAgdmFyIHN0YWNrID0gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKGVsZW1lbnQudHlwZSwgZWxlbWVudC5fc291cmNlLCBvd25lciA/IG93bmVyLnR5cGUgOiBudWxsKTtcbiAgICAgIFJlYWN0RGVidWdDdXJyZW50RnJhbWUkMS5zZXRFeHRyYVN0YWNrRnJhbWUoc3RhY2spO1xuICAgIH0gZWxzZSB7XG4gICAgICBSZWFjdERlYnVnQ3VycmVudEZyYW1lJDEuc2V0RXh0cmFTdGFja0ZyYW1lKG51bGwpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjaGVja1Byb3BUeXBlcyh0eXBlU3BlY3MsIHZhbHVlcywgbG9jYXRpb24sIGNvbXBvbmVudE5hbWUsIGVsZW1lbnQpIHtcbiAge1xuICAgIC8vICRGbG93Rml4TWUgVGhpcyBpcyBva2F5IGJ1dCBGbG93IGRvZXNuJ3Qga25vdyBpdC5cbiAgICB2YXIgaGFzID0gRnVuY3Rpb24uY2FsbC5iaW5kKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkpO1xuXG4gICAgZm9yICh2YXIgdHlwZVNwZWNOYW1lIGluIHR5cGVTcGVjcykge1xuICAgICAgaWYgKGhhcyh0eXBlU3BlY3MsIHR5cGVTcGVjTmFtZSkpIHtcbiAgICAgICAgdmFyIGVycm9yJDEgPSB2b2lkIDA7IC8vIFByb3AgdHlwZSB2YWxpZGF0aW9uIG1heSB0aHJvdy4gSW4gY2FzZSB0aGV5IGRvLCB3ZSBkb24ndCB3YW50IHRvXG4gICAgICAgIC8vIGZhaWwgdGhlIHJlbmRlciBwaGFzZSB3aGVyZSBpdCBkaWRuJ3QgZmFpbCBiZWZvcmUuIFNvIHdlIGxvZyBpdC5cbiAgICAgICAgLy8gQWZ0ZXIgdGhlc2UgaGF2ZSBiZWVuIGNsZWFuZWQgdXAsIHdlJ2xsIGxldCB0aGVtIHRocm93LlxuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgLy8gVGhpcyBpcyBpbnRlbnRpb25hbGx5IGFuIGludmFyaWFudCB0aGF0IGdldHMgY2F1Z2h0LiBJdCdzIHRoZSBzYW1lXG4gICAgICAgICAgLy8gYmVoYXZpb3IgYXMgd2l0aG91dCB0aGlzIHN0YXRlbWVudCBleGNlcHQgd2l0aCBhIGJldHRlciBtZXNzYWdlLlxuICAgICAgICAgIGlmICh0eXBlb2YgdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHZhciBlcnIgPSBFcnJvcigoY29tcG9uZW50TmFtZSB8fCAnUmVhY3QgY2xhc3MnKSArICc6ICcgKyBsb2NhdGlvbiArICcgdHlwZSBgJyArIHR5cGVTcGVjTmFtZSArICdgIGlzIGludmFsaWQ7ICcgKyAnaXQgbXVzdCBiZSBhIGZ1bmN0aW9uLCB1c3VhbGx5IGZyb20gdGhlIGBwcm9wLXR5cGVzYCBwYWNrYWdlLCBidXQgcmVjZWl2ZWQgYCcgKyB0eXBlb2YgdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0gKyAnYC4nICsgJ1RoaXMgb2Z0ZW4gaGFwcGVucyBiZWNhdXNlIG9mIHR5cG9zIHN1Y2ggYXMgYFByb3BUeXBlcy5mdW5jdGlvbmAgaW5zdGVhZCBvZiBgUHJvcFR5cGVzLmZ1bmNgLicpO1xuICAgICAgICAgICAgZXJyLm5hbWUgPSAnSW52YXJpYW50IFZpb2xhdGlvbic7XG4gICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZXJyb3IkMSA9IHR5cGVTcGVjc1t0eXBlU3BlY05hbWVdKHZhbHVlcywgdHlwZVNwZWNOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgbnVsbCwgJ1NFQ1JFVF9ET19OT1RfUEFTU19USElTX09SX1lPVV9XSUxMX0JFX0ZJUkVEJyk7XG4gICAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgICAgZXJyb3IkMSA9IGV4O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVycm9yJDEgJiYgIShlcnJvciQxIGluc3RhbmNlb2YgRXJyb3IpKSB7XG4gICAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQoZWxlbWVudCk7XG5cbiAgICAgICAgICBlcnJvcignJXM6IHR5cGUgc3BlY2lmaWNhdGlvbiBvZiAlcycgKyAnIGAlc2AgaXMgaW52YWxpZDsgdGhlIHR5cGUgY2hlY2tlciAnICsgJ2Z1bmN0aW9uIG11c3QgcmV0dXJuIGBudWxsYCBvciBhbiBgRXJyb3JgIGJ1dCByZXR1cm5lZCBhICVzLiAnICsgJ1lvdSBtYXkgaGF2ZSBmb3Jnb3R0ZW4gdG8gcGFzcyBhbiBhcmd1bWVudCB0byB0aGUgdHlwZSBjaGVja2VyICcgKyAnY3JlYXRvciAoYXJyYXlPZiwgaW5zdGFuY2VPZiwgb2JqZWN0T2YsIG9uZU9mLCBvbmVPZlR5cGUsIGFuZCAnICsgJ3NoYXBlIGFsbCByZXF1aXJlIGFuIGFyZ3VtZW50KS4nLCBjb21wb25lbnROYW1lIHx8ICdSZWFjdCBjbGFzcycsIGxvY2F0aW9uLCB0eXBlU3BlY05hbWUsIHR5cGVvZiBlcnJvciQxKTtcblxuICAgICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KG51bGwpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVycm9yJDEgaW5zdGFuY2VvZiBFcnJvciAmJiAhKGVycm9yJDEubWVzc2FnZSBpbiBsb2dnZWRUeXBlRmFpbHVyZXMpKSB7XG4gICAgICAgICAgLy8gT25seSBtb25pdG9yIHRoaXMgZmFpbHVyZSBvbmNlIGJlY2F1c2UgdGhlcmUgdGVuZHMgdG8gYmUgYSBsb3Qgb2YgdGhlXG4gICAgICAgICAgLy8gc2FtZSBlcnJvci5cbiAgICAgICAgICBsb2dnZWRUeXBlRmFpbHVyZXNbZXJyb3IkMS5tZXNzYWdlXSA9IHRydWU7XG4gICAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQoZWxlbWVudCk7XG5cbiAgICAgICAgICBlcnJvcignRmFpbGVkICVzIHR5cGU6ICVzJywgbG9jYXRpb24sIGVycm9yJDEubWVzc2FnZSk7XG5cbiAgICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChudWxsKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKGVsZW1lbnQpIHtcbiAge1xuICAgIGlmIChlbGVtZW50KSB7XG4gICAgICB2YXIgb3duZXIgPSBlbGVtZW50Ll9vd25lcjtcbiAgICAgIHZhciBzdGFjayA9IGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVihlbGVtZW50LnR5cGUsIGVsZW1lbnQuX3NvdXJjZSwgb3duZXIgPyBvd25lci50eXBlIDogbnVsbCk7XG4gICAgICBzZXRFeHRyYVN0YWNrRnJhbWUoc3RhY2spO1xuICAgIH0gZWxzZSB7XG4gICAgICBzZXRFeHRyYVN0YWNrRnJhbWUobnVsbCk7XG4gICAgfVxuICB9XG59XG5cbnZhciBwcm9wVHlwZXNNaXNzcGVsbFdhcm5pbmdTaG93bjtcblxue1xuICBwcm9wVHlwZXNNaXNzcGVsbFdhcm5pbmdTaG93biA9IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKSB7XG4gIGlmIChSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50KSB7XG4gICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lKFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQudHlwZSk7XG5cbiAgICBpZiAobmFtZSkge1xuICAgICAgcmV0dXJuICdcXG5cXG5DaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiBgJyArIG5hbWUgKyAnYC4nO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiAnJztcbn1cblxuZnVuY3Rpb24gZ2V0U291cmNlSW5mb0Vycm9yQWRkZW5kdW0oc291cmNlKSB7XG4gIGlmIChzb3VyY2UgIT09IHVuZGVmaW5lZCkge1xuICAgIHZhciBmaWxlTmFtZSA9IHNvdXJjZS5maWxlTmFtZS5yZXBsYWNlKC9eLipbXFxcXFxcL10vLCAnJyk7XG4gICAgdmFyIGxpbmVOdW1iZXIgPSBzb3VyY2UubGluZU51bWJlcjtcbiAgICByZXR1cm4gJ1xcblxcbkNoZWNrIHlvdXIgY29kZSBhdCAnICsgZmlsZU5hbWUgKyAnOicgKyBsaW5lTnVtYmVyICsgJy4nO1xuICB9XG5cbiAgcmV0dXJuICcnO1xufVxuXG5mdW5jdGlvbiBnZXRTb3VyY2VJbmZvRXJyb3JBZGRlbmR1bUZvclByb3BzKGVsZW1lbnRQcm9wcykge1xuICBpZiAoZWxlbWVudFByb3BzICE9PSBudWxsICYmIGVsZW1lbnRQcm9wcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIGdldFNvdXJjZUluZm9FcnJvckFkZGVuZHVtKGVsZW1lbnRQcm9wcy5fX3NvdXJjZSk7XG4gIH1cblxuICByZXR1cm4gJyc7XG59XG4vKipcbiAqIFdhcm4gaWYgdGhlcmUncyBubyBrZXkgZXhwbGljaXRseSBzZXQgb24gZHluYW1pYyBhcnJheXMgb2YgY2hpbGRyZW4gb3JcbiAqIG9iamVjdCBrZXlzIGFyZSBub3QgdmFsaWQuIFRoaXMgYWxsb3dzIHVzIHRvIGtlZXAgdHJhY2sgb2YgY2hpbGRyZW4gYmV0d2VlblxuICogdXBkYXRlcy5cbiAqL1xuXG5cbnZhciBvd25lckhhc0tleVVzZVdhcm5pbmcgPSB7fTtcblxuZnVuY3Rpb24gZ2V0Q3VycmVudENvbXBvbmVudEVycm9ySW5mbyhwYXJlbnRUeXBlKSB7XG4gIHZhciBpbmZvID0gZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKCk7XG5cbiAgaWYgKCFpbmZvKSB7XG4gICAgdmFyIHBhcmVudE5hbWUgPSB0eXBlb2YgcGFyZW50VHlwZSA9PT0gJ3N0cmluZycgPyBwYXJlbnRUeXBlIDogcGFyZW50VHlwZS5kaXNwbGF5TmFtZSB8fCBwYXJlbnRUeXBlLm5hbWU7XG5cbiAgICBpZiAocGFyZW50TmFtZSkge1xuICAgICAgaW5mbyA9IFwiXFxuXFxuQ2hlY2sgdGhlIHRvcC1sZXZlbCByZW5kZXIgY2FsbCB1c2luZyA8XCIgKyBwYXJlbnROYW1lICsgXCI+LlwiO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBpbmZvO1xufVxuLyoqXG4gKiBXYXJuIGlmIHRoZSBlbGVtZW50IGRvZXNuJ3QgaGF2ZSBhbiBleHBsaWNpdCBrZXkgYXNzaWduZWQgdG8gaXQuXG4gKiBUaGlzIGVsZW1lbnQgaXMgaW4gYW4gYXJyYXkuIFRoZSBhcnJheSBjb3VsZCBncm93IGFuZCBzaHJpbmsgb3IgYmVcbiAqIHJlb3JkZXJlZC4gQWxsIGNoaWxkcmVuIHRoYXQgaGF2ZW4ndCBhbHJlYWR5IGJlZW4gdmFsaWRhdGVkIGFyZSByZXF1aXJlZCB0b1xuICogaGF2ZSBhIFwia2V5XCIgcHJvcGVydHkgYXNzaWduZWQgdG8gaXQuIEVycm9yIHN0YXR1c2VzIGFyZSBjYWNoZWQgc28gYSB3YXJuaW5nXG4gKiB3aWxsIG9ubHkgYmUgc2hvd24gb25jZS5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBlbGVtZW50IEVsZW1lbnQgdGhhdCByZXF1aXJlcyBhIGtleS5cbiAqIEBwYXJhbSB7Kn0gcGFyZW50VHlwZSBlbGVtZW50J3MgcGFyZW50J3MgdHlwZS5cbiAqL1xuXG5cbmZ1bmN0aW9uIHZhbGlkYXRlRXhwbGljaXRLZXkoZWxlbWVudCwgcGFyZW50VHlwZSkge1xuICBpZiAoIWVsZW1lbnQuX3N0b3JlIHx8IGVsZW1lbnQuX3N0b3JlLnZhbGlkYXRlZCB8fCBlbGVtZW50LmtleSAhPSBudWxsKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgZWxlbWVudC5fc3RvcmUudmFsaWRhdGVkID0gdHJ1ZTtcbiAgdmFyIGN1cnJlbnRDb21wb25lbnRFcnJvckluZm8gPSBnZXRDdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvKHBhcmVudFR5cGUpO1xuXG4gIGlmIChvd25lckhhc0tleVVzZVdhcm5pbmdbY3VycmVudENvbXBvbmVudEVycm9ySW5mb10pIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBvd25lckhhc0tleVVzZVdhcm5pbmdbY3VycmVudENvbXBvbmVudEVycm9ySW5mb10gPSB0cnVlOyAvLyBVc3VhbGx5IHRoZSBjdXJyZW50IG93bmVyIGlzIHRoZSBvZmZlbmRlciwgYnV0IGlmIGl0IGFjY2VwdHMgY2hpbGRyZW4gYXMgYVxuICAvLyBwcm9wZXJ0eSwgaXQgbWF5IGJlIHRoZSBjcmVhdG9yIG9mIHRoZSBjaGlsZCB0aGF0J3MgcmVzcG9uc2libGUgZm9yXG4gIC8vIGFzc2lnbmluZyBpdCBhIGtleS5cblxuICB2YXIgY2hpbGRPd25lciA9ICcnO1xuXG4gIGlmIChlbGVtZW50ICYmIGVsZW1lbnQuX293bmVyICYmIGVsZW1lbnQuX293bmVyICE9PSBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50KSB7XG4gICAgLy8gR2l2ZSB0aGUgY29tcG9uZW50IHRoYXQgb3JpZ2luYWxseSBjcmVhdGVkIHRoaXMgY2hpbGQuXG4gICAgY2hpbGRPd25lciA9IFwiIEl0IHdhcyBwYXNzZWQgYSBjaGlsZCBmcm9tIFwiICsgZ2V0Q29tcG9uZW50TmFtZShlbGVtZW50Ll9vd25lci50eXBlKSArIFwiLlwiO1xuICB9XG5cbiAge1xuICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEoZWxlbWVudCk7XG5cbiAgICBlcnJvcignRWFjaCBjaGlsZCBpbiBhIGxpc3Qgc2hvdWxkIGhhdmUgYSB1bmlxdWUgXCJrZXlcIiBwcm9wLicgKyAnJXMlcyBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3dhcm5pbmcta2V5cyBmb3IgbW9yZSBpbmZvcm1hdGlvbi4nLCBjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvLCBjaGlsZE93bmVyKTtcblxuICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEobnVsbCk7XG4gIH1cbn1cbi8qKlxuICogRW5zdXJlIHRoYXQgZXZlcnkgZWxlbWVudCBlaXRoZXIgaXMgcGFzc2VkIGluIGEgc3RhdGljIGxvY2F0aW9uLCBpbiBhblxuICogYXJyYXkgd2l0aCBhbiBleHBsaWNpdCBrZXlzIHByb3BlcnR5IGRlZmluZWQsIG9yIGluIGFuIG9iamVjdCBsaXRlcmFsXG4gKiB3aXRoIHZhbGlkIGtleSBwcm9wZXJ0eS5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqIEBwYXJhbSB7UmVhY3ROb2RlfSBub2RlIFN0YXRpY2FsbHkgcGFzc2VkIGNoaWxkIG9mIGFueSB0eXBlLlxuICogQHBhcmFtIHsqfSBwYXJlbnRUeXBlIG5vZGUncyBwYXJlbnQncyB0eXBlLlxuICovXG5cblxuZnVuY3Rpb24gdmFsaWRhdGVDaGlsZEtleXMobm9kZSwgcGFyZW50VHlwZSkge1xuICBpZiAodHlwZW9mIG5vZGUgIT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkobm9kZSkpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGUubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBjaGlsZCA9IG5vZGVbaV07XG5cbiAgICAgIGlmIChpc1ZhbGlkRWxlbWVudChjaGlsZCkpIHtcbiAgICAgICAgdmFsaWRhdGVFeHBsaWNpdEtleShjaGlsZCwgcGFyZW50VHlwZSk7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzVmFsaWRFbGVtZW50KG5vZGUpKSB7XG4gICAgLy8gVGhpcyBlbGVtZW50IHdhcyBwYXNzZWQgaW4gYSB2YWxpZCBsb2NhdGlvbi5cbiAgICBpZiAobm9kZS5fc3RvcmUpIHtcbiAgICAgIG5vZGUuX3N0b3JlLnZhbGlkYXRlZCA9IHRydWU7XG4gICAgfVxuICB9IGVsc2UgaWYgKG5vZGUpIHtcbiAgICB2YXIgaXRlcmF0b3JGbiA9IGdldEl0ZXJhdG9yRm4obm9kZSk7XG5cbiAgICBpZiAodHlwZW9mIGl0ZXJhdG9yRm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIC8vIEVudHJ5IGl0ZXJhdG9ycyB1c2VkIHRvIHByb3ZpZGUgaW1wbGljaXQga2V5cyxcbiAgICAgIC8vIGJ1dCBub3cgd2UgcHJpbnQgYSBzZXBhcmF0ZSB3YXJuaW5nIGZvciB0aGVtIGxhdGVyLlxuICAgICAgaWYgKGl0ZXJhdG9yRm4gIT09IG5vZGUuZW50cmllcykge1xuICAgICAgICB2YXIgaXRlcmF0b3IgPSBpdGVyYXRvckZuLmNhbGwobm9kZSk7XG4gICAgICAgIHZhciBzdGVwO1xuXG4gICAgICAgIHdoaWxlICghKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmUpIHtcbiAgICAgICAgICBpZiAoaXNWYWxpZEVsZW1lbnQoc3RlcC52YWx1ZSkpIHtcbiAgICAgICAgICAgIHZhbGlkYXRlRXhwbGljaXRLZXkoc3RlcC52YWx1ZSwgcGFyZW50VHlwZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG4vKipcbiAqIEdpdmVuIGFuIGVsZW1lbnQsIHZhbGlkYXRlIHRoYXQgaXRzIHByb3BzIGZvbGxvdyB0aGUgcHJvcFR5cGVzIGRlZmluaXRpb24sXG4gKiBwcm92aWRlZCBieSB0aGUgdHlwZS5cbiAqXG4gKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gZWxlbWVudFxuICovXG5cblxuZnVuY3Rpb24gdmFsaWRhdGVQcm9wVHlwZXMoZWxlbWVudCkge1xuICB7XG4gICAgdmFyIHR5cGUgPSBlbGVtZW50LnR5cGU7XG5cbiAgICBpZiAodHlwZSA9PT0gbnVsbCB8fCB0eXBlID09PSB1bmRlZmluZWQgfHwgdHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHByb3BUeXBlcztcblxuICAgIGlmICh0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcHJvcFR5cGVzID0gdHlwZS5wcm9wVHlwZXM7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcgJiYgKHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgfHwgLy8gTm90ZTogTWVtbyBvbmx5IGNoZWNrcyBvdXRlciBwcm9wcyBoZXJlLlxuICAgIC8vIElubmVyIHByb3BzIGFyZSBjaGVja2VkIGluIHRoZSByZWNvbmNpbGVyLlxuICAgIHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX01FTU9fVFlQRSkpIHtcbiAgICAgIHByb3BUeXBlcyA9IHR5cGUucHJvcFR5cGVzO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHByb3BUeXBlcykge1xuICAgICAgLy8gSW50ZW50aW9uYWxseSBpbnNpZGUgdG8gYXZvaWQgdHJpZ2dlcmluZyBsYXp5IGluaXRpYWxpemVyczpcbiAgICAgIHZhciBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZSh0eXBlKTtcbiAgICAgIGNoZWNrUHJvcFR5cGVzKHByb3BUeXBlcywgZWxlbWVudC5wcm9wcywgJ3Byb3AnLCBuYW1lLCBlbGVtZW50KTtcbiAgICB9IGVsc2UgaWYgKHR5cGUuUHJvcFR5cGVzICE9PSB1bmRlZmluZWQgJiYgIXByb3BUeXBlc01pc3NwZWxsV2FybmluZ1Nob3duKSB7XG4gICAgICBwcm9wVHlwZXNNaXNzcGVsbFdhcm5pbmdTaG93biA9IHRydWU7IC8vIEludGVudGlvbmFsbHkgaW5zaWRlIHRvIGF2b2lkIHRyaWdnZXJpbmcgbGF6eSBpbml0aWFsaXplcnM6XG5cbiAgICAgIHZhciBfbmFtZSA9IGdldENvbXBvbmVudE5hbWUodHlwZSk7XG5cbiAgICAgIGVycm9yKCdDb21wb25lbnQgJXMgZGVjbGFyZWQgYFByb3BUeXBlc2AgaW5zdGVhZCBvZiBgcHJvcFR5cGVzYC4gRGlkIHlvdSBtaXNzcGVsbCB0aGUgcHJvcGVydHkgYXNzaWdubWVudD8nLCBfbmFtZSB8fCAnVW5rbm93bicpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgdHlwZS5nZXREZWZhdWx0UHJvcHMgPT09ICdmdW5jdGlvbicgJiYgIXR5cGUuZ2V0RGVmYXVsdFByb3BzLmlzUmVhY3RDbGFzc0FwcHJvdmVkKSB7XG4gICAgICBlcnJvcignZ2V0RGVmYXVsdFByb3BzIGlzIG9ubHkgdXNlZCBvbiBjbGFzc2ljIFJlYWN0LmNyZWF0ZUNsYXNzICcgKyAnZGVmaW5pdGlvbnMuIFVzZSBhIHN0YXRpYyBwcm9wZXJ0eSBuYW1lZCBgZGVmYXVsdFByb3BzYCBpbnN0ZWFkLicpO1xuICAgIH1cbiAgfVxufVxuLyoqXG4gKiBHaXZlbiBhIGZyYWdtZW50LCB2YWxpZGF0ZSB0aGF0IGl0IGNhbiBvbmx5IGJlIHByb3ZpZGVkIHdpdGggZnJhZ21lbnQgcHJvcHNcbiAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBmcmFnbWVudFxuICovXG5cblxuZnVuY3Rpb24gdmFsaWRhdGVGcmFnbWVudFByb3BzKGZyYWdtZW50KSB7XG4gIHtcbiAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGZyYWdtZW50LnByb3BzKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGtleSA9IGtleXNbaV07XG5cbiAgICAgIGlmIChrZXkgIT09ICdjaGlsZHJlbicgJiYga2V5ICE9PSAna2V5Jykge1xuICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKGZyYWdtZW50KTtcblxuICAgICAgICBlcnJvcignSW52YWxpZCBwcm9wIGAlc2Agc3VwcGxpZWQgdG8gYFJlYWN0LkZyYWdtZW50YC4gJyArICdSZWFjdC5GcmFnbWVudCBjYW4gb25seSBoYXZlIGBrZXlgIGFuZCBgY2hpbGRyZW5gIHByb3BzLicsIGtleSk7XG5cbiAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShudWxsKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGZyYWdtZW50LnJlZiAhPT0gbnVsbCkge1xuICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShmcmFnbWVudCk7XG5cbiAgICAgIGVycm9yKCdJbnZhbGlkIGF0dHJpYnV0ZSBgcmVmYCBzdXBwbGllZCB0byBgUmVhY3QuRnJhZ21lbnRgLicpO1xuXG4gICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKG51bGwpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gY3JlYXRlRWxlbWVudFdpdGhWYWxpZGF0aW9uKHR5cGUsIHByb3BzLCBjaGlsZHJlbikge1xuICB2YXIgdmFsaWRUeXBlID0gaXNWYWxpZEVsZW1lbnRUeXBlKHR5cGUpOyAvLyBXZSB3YXJuIGluIHRoaXMgY2FzZSBidXQgZG9uJ3QgdGhyb3cuIFdlIGV4cGVjdCB0aGUgZWxlbWVudCBjcmVhdGlvbiB0b1xuICAvLyBzdWNjZWVkIGFuZCB0aGVyZSB3aWxsIGxpa2VseSBiZSBlcnJvcnMgaW4gcmVuZGVyLlxuXG4gIGlmICghdmFsaWRUeXBlKSB7XG4gICAgdmFyIGluZm8gPSAnJztcblxuICAgIGlmICh0eXBlID09PSB1bmRlZmluZWQgfHwgdHlwZW9mIHR5cGUgPT09ICdvYmplY3QnICYmIHR5cGUgIT09IG51bGwgJiYgT2JqZWN0LmtleXModHlwZSkubGVuZ3RoID09PSAwKSB7XG4gICAgICBpbmZvICs9ICcgWW91IGxpa2VseSBmb3Jnb3QgdG8gZXhwb3J0IHlvdXIgY29tcG9uZW50IGZyb20gdGhlIGZpbGUgJyArIFwiaXQncyBkZWZpbmVkIGluLCBvciB5b3UgbWlnaHQgaGF2ZSBtaXhlZCB1cCBkZWZhdWx0IGFuZCBuYW1lZCBpbXBvcnRzLlwiO1xuICAgIH1cblxuICAgIHZhciBzb3VyY2VJbmZvID0gZ2V0U291cmNlSW5mb0Vycm9yQWRkZW5kdW1Gb3JQcm9wcyhwcm9wcyk7XG5cbiAgICBpZiAoc291cmNlSW5mbykge1xuICAgICAgaW5mbyArPSBzb3VyY2VJbmZvO1xuICAgIH0gZWxzZSB7XG4gICAgICBpbmZvICs9IGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bSgpO1xuICAgIH1cblxuICAgIHZhciB0eXBlU3RyaW5nO1xuXG4gICAgaWYgKHR5cGUgPT09IG51bGwpIHtcbiAgICAgIHR5cGVTdHJpbmcgPSAnbnVsbCc7XG4gICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHR5cGUpKSB7XG4gICAgICB0eXBlU3RyaW5nID0gJ2FycmF5JztcbiAgICB9IGVsc2UgaWYgKHR5cGUgIT09IHVuZGVmaW5lZCAmJiB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEUpIHtcbiAgICAgIHR5cGVTdHJpbmcgPSBcIjxcIiArIChnZXRDb21wb25lbnROYW1lKHR5cGUudHlwZSkgfHwgJ1Vua25vd24nKSArIFwiIC8+XCI7XG4gICAgICBpbmZvID0gJyBEaWQgeW91IGFjY2lkZW50YWxseSBleHBvcnQgYSBKU1ggbGl0ZXJhbCBpbnN0ZWFkIG9mIGEgY29tcG9uZW50Pyc7XG4gICAgfSBlbHNlIHtcbiAgICAgIHR5cGVTdHJpbmcgPSB0eXBlb2YgdHlwZTtcbiAgICB9XG5cbiAgICB7XG4gICAgICBlcnJvcignUmVhY3QuY3JlYXRlRWxlbWVudDogdHlwZSBpcyBpbnZhbGlkIC0tIGV4cGVjdGVkIGEgc3RyaW5nIChmb3IgJyArICdidWlsdC1pbiBjb21wb25lbnRzKSBvciBhIGNsYXNzL2Z1bmN0aW9uIChmb3IgY29tcG9zaXRlICcgKyAnY29tcG9uZW50cykgYnV0IGdvdDogJXMuJXMnLCB0eXBlU3RyaW5nLCBpbmZvKTtcbiAgICB9XG4gIH1cblxuICB2YXIgZWxlbWVudCA9IGNyZWF0ZUVsZW1lbnQuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgLy8gVGhlIHJlc3VsdCBjYW4gYmUgbnVsbGlzaCBpZiBhIG1vY2sgb3IgYSBjdXN0b20gZnVuY3Rpb24gaXMgdXNlZC5cbiAgLy8gVE9ETzogRHJvcCB0aGlzIHdoZW4gdGhlc2UgYXJlIG5vIGxvbmdlciBhbGxvd2VkIGFzIHRoZSB0eXBlIGFyZ3VtZW50LlxuXG4gIGlmIChlbGVtZW50ID09IG51bGwpIHtcbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfSAvLyBTa2lwIGtleSB3YXJuaW5nIGlmIHRoZSB0eXBlIGlzbid0IHZhbGlkIHNpbmNlIG91ciBrZXkgdmFsaWRhdGlvbiBsb2dpY1xuICAvLyBkb2Vzbid0IGV4cGVjdCBhIG5vbi1zdHJpbmcvZnVuY3Rpb24gdHlwZSBhbmQgY2FuIHRocm93IGNvbmZ1c2luZyBlcnJvcnMuXG4gIC8vIFdlIGRvbid0IHdhbnQgZXhjZXB0aW9uIGJlaGF2aW9yIHRvIGRpZmZlciBiZXR3ZWVuIGRldiBhbmQgcHJvZC5cbiAgLy8gKFJlbmRlcmluZyB3aWxsIHRocm93IHdpdGggYSBoZWxwZnVsIG1lc3NhZ2UgYW5kIGFzIHNvb24gYXMgdGhlIHR5cGUgaXNcbiAgLy8gZml4ZWQsIHRoZSBrZXkgd2FybmluZ3Mgd2lsbCBhcHBlYXIuKVxuXG5cbiAgaWYgKHZhbGlkVHlwZSkge1xuICAgIGZvciAodmFyIGkgPSAyOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YWxpZGF0ZUNoaWxkS2V5cyhhcmd1bWVudHNbaV0sIHR5cGUpO1xuICAgIH1cbiAgfVxuXG4gIGlmICh0eXBlID09PSBleHBvcnRzLkZyYWdtZW50KSB7XG4gICAgdmFsaWRhdGVGcmFnbWVudFByb3BzKGVsZW1lbnQpO1xuICB9IGVsc2Uge1xuICAgIHZhbGlkYXRlUHJvcFR5cGVzKGVsZW1lbnQpO1xuICB9XG5cbiAgcmV0dXJuIGVsZW1lbnQ7XG59XG52YXIgZGlkV2FybkFib3V0RGVwcmVjYXRlZENyZWF0ZUZhY3RvcnkgPSBmYWxzZTtcbmZ1bmN0aW9uIGNyZWF0ZUZhY3RvcnlXaXRoVmFsaWRhdGlvbih0eXBlKSB7XG4gIHZhciB2YWxpZGF0ZWRGYWN0b3J5ID0gY3JlYXRlRWxlbWVudFdpdGhWYWxpZGF0aW9uLmJpbmQobnVsbCwgdHlwZSk7XG4gIHZhbGlkYXRlZEZhY3RvcnkudHlwZSA9IHR5cGU7XG5cbiAge1xuICAgIGlmICghZGlkV2FybkFib3V0RGVwcmVjYXRlZENyZWF0ZUZhY3RvcnkpIHtcbiAgICAgIGRpZFdhcm5BYm91dERlcHJlY2F0ZWRDcmVhdGVGYWN0b3J5ID0gdHJ1ZTtcblxuICAgICAgd2FybignUmVhY3QuY3JlYXRlRmFjdG9yeSgpIGlzIGRlcHJlY2F0ZWQgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiAnICsgJ2EgZnV0dXJlIG1ham9yIHJlbGVhc2UuIENvbnNpZGVyIHVzaW5nIEpTWCAnICsgJ29yIHVzZSBSZWFjdC5jcmVhdGVFbGVtZW50KCkgZGlyZWN0bHkgaW5zdGVhZC4nKTtcbiAgICB9IC8vIExlZ2FjeSBob29rOiByZW1vdmUgaXRcblxuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHZhbGlkYXRlZEZhY3RvcnksICd0eXBlJywge1xuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgd2FybignRmFjdG9yeS50eXBlIGlzIGRlcHJlY2F0ZWQuIEFjY2VzcyB0aGUgY2xhc3MgZGlyZWN0bHkgJyArICdiZWZvcmUgcGFzc2luZyBpdCB0byBjcmVhdGVGYWN0b3J5LicpO1xuXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAndHlwZScsIHtcbiAgICAgICAgICB2YWx1ZTogdHlwZVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHR5cGU7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gdmFsaWRhdGVkRmFjdG9yeTtcbn1cbmZ1bmN0aW9uIGNsb25lRWxlbWVudFdpdGhWYWxpZGF0aW9uKGVsZW1lbnQsIHByb3BzLCBjaGlsZHJlbikge1xuICB2YXIgbmV3RWxlbWVudCA9IGNsb25lRWxlbWVudC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG4gIGZvciAodmFyIGkgPSAyOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFsaWRhdGVDaGlsZEtleXMoYXJndW1lbnRzW2ldLCBuZXdFbGVtZW50LnR5cGUpO1xuICB9XG5cbiAgdmFsaWRhdGVQcm9wVHlwZXMobmV3RWxlbWVudCk7XG4gIHJldHVybiBuZXdFbGVtZW50O1xufVxuXG57XG5cbiAgdHJ5IHtcbiAgICB2YXIgZnJvemVuT2JqZWN0ID0gT2JqZWN0LmZyZWV6ZSh7fSk7XG4gICAgLyogZXNsaW50LWRpc2FibGUgbm8tbmV3ICovXG5cbiAgICBuZXcgTWFwKFtbZnJvemVuT2JqZWN0LCBudWxsXV0pO1xuICAgIG5ldyBTZXQoW2Zyb3plbk9iamVjdF0pO1xuICAgIC8qIGVzbGludC1lbmFibGUgbm8tbmV3ICovXG4gIH0gY2F0Y2ggKGUpIHtcbiAgfVxufVxuXG52YXIgY3JlYXRlRWxlbWVudCQxID0gIGNyZWF0ZUVsZW1lbnRXaXRoVmFsaWRhdGlvbiA7XG52YXIgY2xvbmVFbGVtZW50JDEgPSAgY2xvbmVFbGVtZW50V2l0aFZhbGlkYXRpb24gO1xudmFyIGNyZWF0ZUZhY3RvcnkgPSAgY3JlYXRlRmFjdG9yeVdpdGhWYWxpZGF0aW9uIDtcbnZhciBDaGlsZHJlbiA9IHtcbiAgbWFwOiBtYXBDaGlsZHJlbixcbiAgZm9yRWFjaDogZm9yRWFjaENoaWxkcmVuLFxuICBjb3VudDogY291bnRDaGlsZHJlbixcbiAgdG9BcnJheTogdG9BcnJheSxcbiAgb25seTogb25seUNoaWxkXG59O1xuXG5leHBvcnRzLkNoaWxkcmVuID0gQ2hpbGRyZW47XG5leHBvcnRzLkNvbXBvbmVudCA9IENvbXBvbmVudDtcbmV4cG9ydHMuUHVyZUNvbXBvbmVudCA9IFB1cmVDb21wb25lbnQ7XG5leHBvcnRzLl9fU0VDUkVUX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVEID0gUmVhY3RTaGFyZWRJbnRlcm5hbHM7XG5leHBvcnRzLmNsb25lRWxlbWVudCA9IGNsb25lRWxlbWVudCQxO1xuZXhwb3J0cy5jcmVhdGVDb250ZXh0ID0gY3JlYXRlQ29udGV4dDtcbmV4cG9ydHMuY3JlYXRlRWxlbWVudCA9IGNyZWF0ZUVsZW1lbnQkMTtcbmV4cG9ydHMuY3JlYXRlRmFjdG9yeSA9IGNyZWF0ZUZhY3Rvcnk7XG5leHBvcnRzLmNyZWF0ZVJlZiA9IGNyZWF0ZVJlZjtcbmV4cG9ydHMuZm9yd2FyZFJlZiA9IGZvcndhcmRSZWY7XG5leHBvcnRzLmlzVmFsaWRFbGVtZW50ID0gaXNWYWxpZEVsZW1lbnQ7XG5leHBvcnRzLmxhenkgPSBsYXp5O1xuZXhwb3J0cy5tZW1vID0gbWVtbztcbmV4cG9ydHMudXNlQ2FsbGJhY2sgPSB1c2VDYWxsYmFjaztcbmV4cG9ydHMudXNlQ29udGV4dCA9IHVzZUNvbnRleHQ7XG5leHBvcnRzLnVzZURlYnVnVmFsdWUgPSB1c2VEZWJ1Z1ZhbHVlO1xuZXhwb3J0cy51c2VFZmZlY3QgPSB1c2VFZmZlY3Q7XG5leHBvcnRzLnVzZUltcGVyYXRpdmVIYW5kbGUgPSB1c2VJbXBlcmF0aXZlSGFuZGxlO1xuZXhwb3J0cy51c2VMYXlvdXRFZmZlY3QgPSB1c2VMYXlvdXRFZmZlY3Q7XG5leHBvcnRzLnVzZU1lbW8gPSB1c2VNZW1vO1xuZXhwb3J0cy51c2VSZWR1Y2VyID0gdXNlUmVkdWNlcjtcbmV4cG9ydHMudXNlUmVmID0gdXNlUmVmO1xuZXhwb3J0cy51c2VTdGF0ZSA9IHVzZVN0YXRlO1xuZXhwb3J0cy52ZXJzaW9uID0gUmVhY3RWZXJzaW9uO1xuICB9KSgpO1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJykge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3JlYWN0LnByb2R1Y3Rpb24ubWluLmpzJyk7XG59IGVsc2Uge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3JlYWN0LmRldmVsb3BtZW50LmpzJyk7XG59XG4iLCIvKiogQGxpY2Vuc2UgUmVhY3QgdjAuMjAuMlxuICogc2NoZWR1bGVyLXRyYWNpbmcuZGV2ZWxvcG1lbnQuanNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgKGZ1bmN0aW9uKCkge1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgREVGQVVMVF9USFJFQURfSUQgPSAwOyAvLyBDb3VudGVycyB1c2VkIHRvIGdlbmVyYXRlIHVuaXF1ZSBJRHMuXG5cbnZhciBpbnRlcmFjdGlvbklEQ291bnRlciA9IDA7XG52YXIgdGhyZWFkSURDb3VudGVyID0gMDsgLy8gU2V0IG9mIGN1cnJlbnRseSB0cmFjZWQgaW50ZXJhY3Rpb25zLlxuLy8gSW50ZXJhY3Rpb25zIFwic3RhY2tcIuKAk1xuLy8gTWVhbmluZyB0aGF0IG5ld2x5IHRyYWNlZCBpbnRlcmFjdGlvbnMgYXJlIGFwcGVuZGVkIHRvIHRoZSBwcmV2aW91c2x5IGFjdGl2ZSBzZXQuXG4vLyBXaGVuIGFuIGludGVyYWN0aW9uIGdvZXMgb3V0IG9mIHNjb3BlLCB0aGUgcHJldmlvdXMgc2V0IChpZiBhbnkpIGlzIHJlc3RvcmVkLlxuXG5leHBvcnRzLl9faW50ZXJhY3Rpb25zUmVmID0gbnVsbDsgLy8gTGlzdGVuZXIocykgdG8gbm90aWZ5IHdoZW4gaW50ZXJhY3Rpb25zIGJlZ2luIGFuZCBlbmQuXG5cbmV4cG9ydHMuX19zdWJzY3JpYmVyUmVmID0gbnVsbDtcblxue1xuICBleHBvcnRzLl9faW50ZXJhY3Rpb25zUmVmID0ge1xuICAgIGN1cnJlbnQ6IG5ldyBTZXQoKVxuICB9O1xuICBleHBvcnRzLl9fc3Vic2NyaWJlclJlZiA9IHtcbiAgICBjdXJyZW50OiBudWxsXG4gIH07XG59XG5mdW5jdGlvbiB1bnN0YWJsZV9jbGVhcihjYWxsYmFjaykge1xuXG4gIHZhciBwcmV2SW50ZXJhY3Rpb25zID0gZXhwb3J0cy5fX2ludGVyYWN0aW9uc1JlZi5jdXJyZW50O1xuICBleHBvcnRzLl9faW50ZXJhY3Rpb25zUmVmLmN1cnJlbnQgPSBuZXcgU2V0KCk7XG5cbiAgdHJ5IHtcbiAgICByZXR1cm4gY2FsbGJhY2soKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBleHBvcnRzLl9faW50ZXJhY3Rpb25zUmVmLmN1cnJlbnQgPSBwcmV2SW50ZXJhY3Rpb25zO1xuICB9XG59XG5mdW5jdGlvbiB1bnN0YWJsZV9nZXRDdXJyZW50KCkge1xuICB7XG4gICAgcmV0dXJuIGV4cG9ydHMuX19pbnRlcmFjdGlvbnNSZWYuY3VycmVudDtcbiAgfVxufVxuZnVuY3Rpb24gdW5zdGFibGVfZ2V0VGhyZWFkSUQoKSB7XG4gIHJldHVybiArK3RocmVhZElEQ291bnRlcjtcbn1cbmZ1bmN0aW9uIHVuc3RhYmxlX3RyYWNlKG5hbWUsIHRpbWVzdGFtcCwgY2FsbGJhY2spIHtcbiAgdmFyIHRocmVhZElEID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiBERUZBVUxUX1RIUkVBRF9JRDtcblxuICB2YXIgaW50ZXJhY3Rpb24gPSB7XG4gICAgX19jb3VudDogMSxcbiAgICBpZDogaW50ZXJhY3Rpb25JRENvdW50ZXIrKyxcbiAgICBuYW1lOiBuYW1lLFxuICAgIHRpbWVzdGFtcDogdGltZXN0YW1wXG4gIH07XG4gIHZhciBwcmV2SW50ZXJhY3Rpb25zID0gZXhwb3J0cy5fX2ludGVyYWN0aW9uc1JlZi5jdXJyZW50OyAvLyBUcmFjZWQgaW50ZXJhY3Rpb25zIHNob3VsZCBzdGFjay9hY2N1bXVsYXRlLlxuICAvLyBUbyBkbyB0aGF0LCBjbG9uZSB0aGUgY3VycmVudCBpbnRlcmFjdGlvbnMuXG4gIC8vIFRoZSBwcmV2aW91cyBzZXQgd2lsbCBiZSByZXN0b3JlZCB1cG9uIGNvbXBsZXRpb24uXG5cbiAgdmFyIGludGVyYWN0aW9ucyA9IG5ldyBTZXQocHJldkludGVyYWN0aW9ucyk7XG4gIGludGVyYWN0aW9ucy5hZGQoaW50ZXJhY3Rpb24pO1xuICBleHBvcnRzLl9faW50ZXJhY3Rpb25zUmVmLmN1cnJlbnQgPSBpbnRlcmFjdGlvbnM7XG4gIHZhciBzdWJzY3JpYmVyID0gZXhwb3J0cy5fX3N1YnNjcmliZXJSZWYuY3VycmVudDtcbiAgdmFyIHJldHVyblZhbHVlO1xuXG4gIHRyeSB7XG4gICAgaWYgKHN1YnNjcmliZXIgIT09IG51bGwpIHtcbiAgICAgIHN1YnNjcmliZXIub25JbnRlcmFjdGlvblRyYWNlZChpbnRlcmFjdGlvbik7XG4gICAgfVxuICB9IGZpbmFsbHkge1xuICAgIHRyeSB7XG4gICAgICBpZiAoc3Vic2NyaWJlciAhPT0gbnVsbCkge1xuICAgICAgICBzdWJzY3JpYmVyLm9uV29ya1N0YXJ0ZWQoaW50ZXJhY3Rpb25zLCB0aHJlYWRJRCk7XG4gICAgICB9XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVyblZhbHVlID0gY2FsbGJhY2soKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGV4cG9ydHMuX19pbnRlcmFjdGlvbnNSZWYuY3VycmVudCA9IHByZXZJbnRlcmFjdGlvbnM7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBpZiAoc3Vic2NyaWJlciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgc3Vic2NyaWJlci5vbldvcmtTdG9wcGVkKGludGVyYWN0aW9ucywgdGhyZWFkSUQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBpbnRlcmFjdGlvbi5fX2NvdW50LS07IC8vIElmIG5vIGFzeW5jIHdvcmsgd2FzIHNjaGVkdWxlZCBmb3IgdGhpcyBpbnRlcmFjdGlvbixcbiAgICAgICAgICAvLyBOb3RpZnkgc3Vic2NyaWJlcnMgdGhhdCBpdCdzIGNvbXBsZXRlZC5cblxuICAgICAgICAgIGlmIChzdWJzY3JpYmVyICE9PSBudWxsICYmIGludGVyYWN0aW9uLl9fY291bnQgPT09IDApIHtcbiAgICAgICAgICAgIHN1YnNjcmliZXIub25JbnRlcmFjdGlvblNjaGVkdWxlZFdvcmtDb21wbGV0ZWQoaW50ZXJhY3Rpb24pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXR1cm5WYWx1ZTtcbn1cbmZ1bmN0aW9uIHVuc3RhYmxlX3dyYXAoY2FsbGJhY2spIHtcbiAgdmFyIHRocmVhZElEID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBERUZBVUxUX1RIUkVBRF9JRDtcblxuICB2YXIgd3JhcHBlZEludGVyYWN0aW9ucyA9IGV4cG9ydHMuX19pbnRlcmFjdGlvbnNSZWYuY3VycmVudDtcbiAgdmFyIHN1YnNjcmliZXIgPSBleHBvcnRzLl9fc3Vic2NyaWJlclJlZi5jdXJyZW50O1xuXG4gIGlmIChzdWJzY3JpYmVyICE9PSBudWxsKSB7XG4gICAgc3Vic2NyaWJlci5vbldvcmtTY2hlZHVsZWQod3JhcHBlZEludGVyYWN0aW9ucywgdGhyZWFkSUQpO1xuICB9IC8vIFVwZGF0ZSB0aGUgcGVuZGluZyBhc3luYyB3b3JrIGNvdW50IGZvciB0aGUgY3VycmVudCBpbnRlcmFjdGlvbnMuXG4gIC8vIFVwZGF0ZSBhZnRlciBjYWxsaW5nIHN1YnNjcmliZXJzIGluIGNhc2Ugb2YgZXJyb3IuXG5cblxuICB3cmFwcGVkSW50ZXJhY3Rpb25zLmZvckVhY2goZnVuY3Rpb24gKGludGVyYWN0aW9uKSB7XG4gICAgaW50ZXJhY3Rpb24uX19jb3VudCsrO1xuICB9KTtcbiAgdmFyIGhhc1J1biA9IGZhbHNlO1xuXG4gIGZ1bmN0aW9uIHdyYXBwZWQoKSB7XG4gICAgdmFyIHByZXZJbnRlcmFjdGlvbnMgPSBleHBvcnRzLl9faW50ZXJhY3Rpb25zUmVmLmN1cnJlbnQ7XG4gICAgZXhwb3J0cy5fX2ludGVyYWN0aW9uc1JlZi5jdXJyZW50ID0gd3JhcHBlZEludGVyYWN0aW9ucztcbiAgICBzdWJzY3JpYmVyID0gZXhwb3J0cy5fX3N1YnNjcmliZXJSZWYuY3VycmVudDtcblxuICAgIHRyeSB7XG4gICAgICB2YXIgcmV0dXJuVmFsdWU7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGlmIChzdWJzY3JpYmVyICE9PSBudWxsKSB7XG4gICAgICAgICAgc3Vic2NyaWJlci5vbldvcmtTdGFydGVkKHdyYXBwZWRJbnRlcmFjdGlvbnMsIHRocmVhZElEKTtcbiAgICAgICAgfVxuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXR1cm5WYWx1ZSA9IGNhbGxiYWNrLmFwcGx5KHVuZGVmaW5lZCwgYXJndW1lbnRzKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBleHBvcnRzLl9faW50ZXJhY3Rpb25zUmVmLmN1cnJlbnQgPSBwcmV2SW50ZXJhY3Rpb25zO1xuXG4gICAgICAgICAgaWYgKHN1YnNjcmliZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHN1YnNjcmliZXIub25Xb3JrU3RvcHBlZCh3cmFwcGVkSW50ZXJhY3Rpb25zLCB0aHJlYWRJRCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXR1cm5WYWx1ZTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgaWYgKCFoYXNSdW4pIHtcbiAgICAgICAgLy8gV2Ugb25seSBleHBlY3QgYSB3cmFwcGVkIGZ1bmN0aW9uIHRvIGJlIGV4ZWN1dGVkIG9uY2UsXG4gICAgICAgIC8vIEJ1dCBpbiB0aGUgZXZlbnQgdGhhdCBpdCdzIGV4ZWN1dGVkIG1vcmUgdGhhbiBvbmNl4oCTXG4gICAgICAgIC8vIE9ubHkgZGVjcmVtZW50IHRoZSBvdXRzdGFuZGluZyBpbnRlcmFjdGlvbiBjb3VudHMgb25jZS5cbiAgICAgICAgaGFzUnVuID0gdHJ1ZTsgLy8gVXBkYXRlIHBlbmRpbmcgYXN5bmMgY291bnRzIGZvciBhbGwgd3JhcHBlZCBpbnRlcmFjdGlvbnMuXG4gICAgICAgIC8vIElmIHRoaXMgd2FzIHRoZSBsYXN0IHNjaGVkdWxlZCBhc3luYyB3b3JrIGZvciBhbnkgb2YgdGhlbSxcbiAgICAgICAgLy8gTWFyayB0aGVtIGFzIGNvbXBsZXRlZC5cblxuICAgICAgICB3cmFwcGVkSW50ZXJhY3Rpb25zLmZvckVhY2goZnVuY3Rpb24gKGludGVyYWN0aW9uKSB7XG4gICAgICAgICAgaW50ZXJhY3Rpb24uX19jb3VudC0tO1xuXG4gICAgICAgICAgaWYgKHN1YnNjcmliZXIgIT09IG51bGwgJiYgaW50ZXJhY3Rpb24uX19jb3VudCA9PT0gMCkge1xuICAgICAgICAgICAgc3Vic2NyaWJlci5vbkludGVyYWN0aW9uU2NoZWR1bGVkV29ya0NvbXBsZXRlZChpbnRlcmFjdGlvbik7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB3cmFwcGVkLmNhbmNlbCA9IGZ1bmN0aW9uIGNhbmNlbCgpIHtcbiAgICBzdWJzY3JpYmVyID0gZXhwb3J0cy5fX3N1YnNjcmliZXJSZWYuY3VycmVudDtcblxuICAgIHRyeSB7XG4gICAgICBpZiAoc3Vic2NyaWJlciAhPT0gbnVsbCkge1xuICAgICAgICBzdWJzY3JpYmVyLm9uV29ya0NhbmNlbGVkKHdyYXBwZWRJbnRlcmFjdGlvbnMsIHRocmVhZElEKTtcbiAgICAgIH1cbiAgICB9IGZpbmFsbHkge1xuICAgICAgLy8gVXBkYXRlIHBlbmRpbmcgYXN5bmMgY291bnRzIGZvciBhbGwgd3JhcHBlZCBpbnRlcmFjdGlvbnMuXG4gICAgICAvLyBJZiB0aGlzIHdhcyB0aGUgbGFzdCBzY2hlZHVsZWQgYXN5bmMgd29yayBmb3IgYW55IG9mIHRoZW0sXG4gICAgICAvLyBNYXJrIHRoZW0gYXMgY29tcGxldGVkLlxuICAgICAgd3JhcHBlZEludGVyYWN0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChpbnRlcmFjdGlvbikge1xuICAgICAgICBpbnRlcmFjdGlvbi5fX2NvdW50LS07XG5cbiAgICAgICAgaWYgKHN1YnNjcmliZXIgJiYgaW50ZXJhY3Rpb24uX19jb3VudCA9PT0gMCkge1xuICAgICAgICAgIHN1YnNjcmliZXIub25JbnRlcmFjdGlvblNjaGVkdWxlZFdvcmtDb21wbGV0ZWQoaW50ZXJhY3Rpb24pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIHdyYXBwZWQ7XG59XG5cbnZhciBzdWJzY3JpYmVycyA9IG51bGw7XG5cbntcbiAgc3Vic2NyaWJlcnMgPSBuZXcgU2V0KCk7XG59XG5cbmZ1bmN0aW9uIHVuc3RhYmxlX3N1YnNjcmliZShzdWJzY3JpYmVyKSB7XG4gIHtcbiAgICBzdWJzY3JpYmVycy5hZGQoc3Vic2NyaWJlcik7XG5cbiAgICBpZiAoc3Vic2NyaWJlcnMuc2l6ZSA9PT0gMSkge1xuICAgICAgZXhwb3J0cy5fX3N1YnNjcmliZXJSZWYuY3VycmVudCA9IHtcbiAgICAgICAgb25JbnRlcmFjdGlvblNjaGVkdWxlZFdvcmtDb21wbGV0ZWQ6IG9uSW50ZXJhY3Rpb25TY2hlZHVsZWRXb3JrQ29tcGxldGVkLFxuICAgICAgICBvbkludGVyYWN0aW9uVHJhY2VkOiBvbkludGVyYWN0aW9uVHJhY2VkLFxuICAgICAgICBvbldvcmtDYW5jZWxlZDogb25Xb3JrQ2FuY2VsZWQsXG4gICAgICAgIG9uV29ya1NjaGVkdWxlZDogb25Xb3JrU2NoZWR1bGVkLFxuICAgICAgICBvbldvcmtTdGFydGVkOiBvbldvcmtTdGFydGVkLFxuICAgICAgICBvbldvcmtTdG9wcGVkOiBvbldvcmtTdG9wcGVkXG4gICAgICB9O1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gdW5zdGFibGVfdW5zdWJzY3JpYmUoc3Vic2NyaWJlcikge1xuICB7XG4gICAgc3Vic2NyaWJlcnMuZGVsZXRlKHN1YnNjcmliZXIpO1xuXG4gICAgaWYgKHN1YnNjcmliZXJzLnNpemUgPT09IDApIHtcbiAgICAgIGV4cG9ydHMuX19zdWJzY3JpYmVyUmVmLmN1cnJlbnQgPSBudWxsO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBvbkludGVyYWN0aW9uVHJhY2VkKGludGVyYWN0aW9uKSB7XG4gIHZhciBkaWRDYXRjaEVycm9yID0gZmFsc2U7XG4gIHZhciBjYXVnaHRFcnJvciA9IG51bGw7XG4gIHN1YnNjcmliZXJzLmZvckVhY2goZnVuY3Rpb24gKHN1YnNjcmliZXIpIHtcbiAgICB0cnkge1xuICAgICAgc3Vic2NyaWJlci5vbkludGVyYWN0aW9uVHJhY2VkKGludGVyYWN0aW9uKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaWYgKCFkaWRDYXRjaEVycm9yKSB7XG4gICAgICAgIGRpZENhdGNoRXJyb3IgPSB0cnVlO1xuICAgICAgICBjYXVnaHRFcnJvciA9IGVycm9yO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG5cbiAgaWYgKGRpZENhdGNoRXJyb3IpIHtcbiAgICB0aHJvdyBjYXVnaHRFcnJvcjtcbiAgfVxufVxuXG5mdW5jdGlvbiBvbkludGVyYWN0aW9uU2NoZWR1bGVkV29ya0NvbXBsZXRlZChpbnRlcmFjdGlvbikge1xuICB2YXIgZGlkQ2F0Y2hFcnJvciA9IGZhbHNlO1xuICB2YXIgY2F1Z2h0RXJyb3IgPSBudWxsO1xuICBzdWJzY3JpYmVycy5mb3JFYWNoKGZ1bmN0aW9uIChzdWJzY3JpYmVyKSB7XG4gICAgdHJ5IHtcbiAgICAgIHN1YnNjcmliZXIub25JbnRlcmFjdGlvblNjaGVkdWxlZFdvcmtDb21wbGV0ZWQoaW50ZXJhY3Rpb24pO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBpZiAoIWRpZENhdGNoRXJyb3IpIHtcbiAgICAgICAgZGlkQ2F0Y2hFcnJvciA9IHRydWU7XG4gICAgICAgIGNhdWdodEVycm9yID0gZXJyb3I7XG4gICAgICB9XG4gICAgfVxuICB9KTtcblxuICBpZiAoZGlkQ2F0Y2hFcnJvcikge1xuICAgIHRocm93IGNhdWdodEVycm9yO1xuICB9XG59XG5cbmZ1bmN0aW9uIG9uV29ya1NjaGVkdWxlZChpbnRlcmFjdGlvbnMsIHRocmVhZElEKSB7XG4gIHZhciBkaWRDYXRjaEVycm9yID0gZmFsc2U7XG4gIHZhciBjYXVnaHRFcnJvciA9IG51bGw7XG4gIHN1YnNjcmliZXJzLmZvckVhY2goZnVuY3Rpb24gKHN1YnNjcmliZXIpIHtcbiAgICB0cnkge1xuICAgICAgc3Vic2NyaWJlci5vbldvcmtTY2hlZHVsZWQoaW50ZXJhY3Rpb25zLCB0aHJlYWRJRCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmICghZGlkQ2F0Y2hFcnJvcikge1xuICAgICAgICBkaWRDYXRjaEVycm9yID0gdHJ1ZTtcbiAgICAgICAgY2F1Z2h0RXJyb3IgPSBlcnJvcjtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuXG4gIGlmIChkaWRDYXRjaEVycm9yKSB7XG4gICAgdGhyb3cgY2F1Z2h0RXJyb3I7XG4gIH1cbn1cblxuZnVuY3Rpb24gb25Xb3JrU3RhcnRlZChpbnRlcmFjdGlvbnMsIHRocmVhZElEKSB7XG4gIHZhciBkaWRDYXRjaEVycm9yID0gZmFsc2U7XG4gIHZhciBjYXVnaHRFcnJvciA9IG51bGw7XG4gIHN1YnNjcmliZXJzLmZvckVhY2goZnVuY3Rpb24gKHN1YnNjcmliZXIpIHtcbiAgICB0cnkge1xuICAgICAgc3Vic2NyaWJlci5vbldvcmtTdGFydGVkKGludGVyYWN0aW9ucywgdGhyZWFkSUQpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBpZiAoIWRpZENhdGNoRXJyb3IpIHtcbiAgICAgICAgZGlkQ2F0Y2hFcnJvciA9IHRydWU7XG4gICAgICAgIGNhdWdodEVycm9yID0gZXJyb3I7XG4gICAgICB9XG4gICAgfVxuICB9KTtcblxuICBpZiAoZGlkQ2F0Y2hFcnJvcikge1xuICAgIHRocm93IGNhdWdodEVycm9yO1xuICB9XG59XG5cbmZ1bmN0aW9uIG9uV29ya1N0b3BwZWQoaW50ZXJhY3Rpb25zLCB0aHJlYWRJRCkge1xuICB2YXIgZGlkQ2F0Y2hFcnJvciA9IGZhbHNlO1xuICB2YXIgY2F1Z2h0RXJyb3IgPSBudWxsO1xuICBzdWJzY3JpYmVycy5mb3JFYWNoKGZ1bmN0aW9uIChzdWJzY3JpYmVyKSB7XG4gICAgdHJ5IHtcbiAgICAgIHN1YnNjcmliZXIub25Xb3JrU3RvcHBlZChpbnRlcmFjdGlvbnMsIHRocmVhZElEKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaWYgKCFkaWRDYXRjaEVycm9yKSB7XG4gICAgICAgIGRpZENhdGNoRXJyb3IgPSB0cnVlO1xuICAgICAgICBjYXVnaHRFcnJvciA9IGVycm9yO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG5cbiAgaWYgKGRpZENhdGNoRXJyb3IpIHtcbiAgICB0aHJvdyBjYXVnaHRFcnJvcjtcbiAgfVxufVxuXG5mdW5jdGlvbiBvbldvcmtDYW5jZWxlZChpbnRlcmFjdGlvbnMsIHRocmVhZElEKSB7XG4gIHZhciBkaWRDYXRjaEVycm9yID0gZmFsc2U7XG4gIHZhciBjYXVnaHRFcnJvciA9IG51bGw7XG4gIHN1YnNjcmliZXJzLmZvckVhY2goZnVuY3Rpb24gKHN1YnNjcmliZXIpIHtcbiAgICB0cnkge1xuICAgICAgc3Vic2NyaWJlci5vbldvcmtDYW5jZWxlZChpbnRlcmFjdGlvbnMsIHRocmVhZElEKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaWYgKCFkaWRDYXRjaEVycm9yKSB7XG4gICAgICAgIGRpZENhdGNoRXJyb3IgPSB0cnVlO1xuICAgICAgICBjYXVnaHRFcnJvciA9IGVycm9yO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG5cbiAgaWYgKGRpZENhdGNoRXJyb3IpIHtcbiAgICB0aHJvdyBjYXVnaHRFcnJvcjtcbiAgfVxufVxuXG5leHBvcnRzLnVuc3RhYmxlX2NsZWFyID0gdW5zdGFibGVfY2xlYXI7XG5leHBvcnRzLnVuc3RhYmxlX2dldEN1cnJlbnQgPSB1bnN0YWJsZV9nZXRDdXJyZW50O1xuZXhwb3J0cy51bnN0YWJsZV9nZXRUaHJlYWRJRCA9IHVuc3RhYmxlX2dldFRocmVhZElEO1xuZXhwb3J0cy51bnN0YWJsZV9zdWJzY3JpYmUgPSB1bnN0YWJsZV9zdWJzY3JpYmU7XG5leHBvcnRzLnVuc3RhYmxlX3RyYWNlID0gdW5zdGFibGVfdHJhY2U7XG5leHBvcnRzLnVuc3RhYmxlX3Vuc3Vic2NyaWJlID0gdW5zdGFibGVfdW5zdWJzY3JpYmU7XG5leHBvcnRzLnVuc3RhYmxlX3dyYXAgPSB1bnN0YWJsZV93cmFwO1xuICB9KSgpO1xufVxuIiwiLyoqIEBsaWNlbnNlIFJlYWN0IHYwLjIwLjJcbiAqIHNjaGVkdWxlci5kZXZlbG9wbWVudC5qc1xuICpcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAoZnVuY3Rpb24oKSB7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBlbmFibGVTY2hlZHVsZXJEZWJ1Z2dpbmcgPSBmYWxzZTtcbnZhciBlbmFibGVQcm9maWxpbmcgPSBmYWxzZTtcblxudmFyIHJlcXVlc3RIb3N0Q2FsbGJhY2s7XG52YXIgcmVxdWVzdEhvc3RUaW1lb3V0O1xudmFyIGNhbmNlbEhvc3RUaW1lb3V0O1xudmFyIHJlcXVlc3RQYWludDtcbnZhciBoYXNQZXJmb3JtYW5jZU5vdyA9IHR5cGVvZiBwZXJmb3JtYW5jZSA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIHBlcmZvcm1hbmNlLm5vdyA9PT0gJ2Z1bmN0aW9uJztcblxuaWYgKGhhc1BlcmZvcm1hbmNlTm93KSB7XG4gIHZhciBsb2NhbFBlcmZvcm1hbmNlID0gcGVyZm9ybWFuY2U7XG5cbiAgZXhwb3J0cy51bnN0YWJsZV9ub3cgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGxvY2FsUGVyZm9ybWFuY2Uubm93KCk7XG4gIH07XG59IGVsc2Uge1xuICB2YXIgbG9jYWxEYXRlID0gRGF0ZTtcbiAgdmFyIGluaXRpYWxUaW1lID0gbG9jYWxEYXRlLm5vdygpO1xuXG4gIGV4cG9ydHMudW5zdGFibGVfbm93ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBsb2NhbERhdGUubm93KCkgLSBpbml0aWFsVGltZTtcbiAgfTtcbn1cblxuaWYgKCAvLyBJZiBTY2hlZHVsZXIgcnVucyBpbiBhIG5vbi1ET00gZW52aXJvbm1lbnQsIGl0IGZhbGxzIGJhY2sgdG8gYSBuYWl2ZVxuLy8gaW1wbGVtZW50YXRpb24gdXNpbmcgc2V0VGltZW91dC5cbnR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnIHx8IC8vIENoZWNrIGlmIE1lc3NhZ2VDaGFubmVsIGlzIHN1cHBvcnRlZCwgdG9vLlxudHlwZW9mIE1lc3NhZ2VDaGFubmVsICE9PSAnZnVuY3Rpb24nKSB7XG4gIC8vIElmIHRoaXMgYWNjaWRlbnRhbGx5IGdldHMgaW1wb3J0ZWQgaW4gYSBub24tYnJvd3NlciBlbnZpcm9ubWVudCwgZS5nLiBKYXZhU2NyaXB0Q29yZSxcbiAgLy8gZmFsbGJhY2sgdG8gYSBuYWl2ZSBpbXBsZW1lbnRhdGlvbi5cbiAgdmFyIF9jYWxsYmFjayA9IG51bGw7XG4gIHZhciBfdGltZW91dElEID0gbnVsbDtcblxuICB2YXIgX2ZsdXNoQ2FsbGJhY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKF9jYWxsYmFjayAhPT0gbnVsbCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIGN1cnJlbnRUaW1lID0gZXhwb3J0cy51bnN0YWJsZV9ub3coKTtcbiAgICAgICAgdmFyIGhhc1JlbWFpbmluZ1RpbWUgPSB0cnVlO1xuXG4gICAgICAgIF9jYWxsYmFjayhoYXNSZW1haW5pbmdUaW1lLCBjdXJyZW50VGltZSk7XG5cbiAgICAgICAgX2NhbGxiYWNrID0gbnVsbDtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgc2V0VGltZW91dChfZmx1c2hDYWxsYmFjaywgMCk7XG4gICAgICAgIHRocm93IGU7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIHJlcXVlc3RIb3N0Q2FsbGJhY2sgPSBmdW5jdGlvbiAoY2IpIHtcbiAgICBpZiAoX2NhbGxiYWNrICE9PSBudWxsKSB7XG4gICAgICAvLyBQcm90ZWN0IGFnYWluc3QgcmUtZW50cmFuY3kuXG4gICAgICBzZXRUaW1lb3V0KHJlcXVlc3RIb3N0Q2FsbGJhY2ssIDAsIGNiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgX2NhbGxiYWNrID0gY2I7XG4gICAgICBzZXRUaW1lb3V0KF9mbHVzaENhbGxiYWNrLCAwKTtcbiAgICB9XG4gIH07XG5cbiAgcmVxdWVzdEhvc3RUaW1lb3V0ID0gZnVuY3Rpb24gKGNiLCBtcykge1xuICAgIF90aW1lb3V0SUQgPSBzZXRUaW1lb3V0KGNiLCBtcyk7XG4gIH07XG5cbiAgY2FuY2VsSG9zdFRpbWVvdXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgY2xlYXJUaW1lb3V0KF90aW1lb3V0SUQpO1xuICB9O1xuXG4gIGV4cG9ydHMudW5zdGFibGVfc2hvdWxkWWllbGQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xuXG4gIHJlcXVlc3RQYWludCA9IGV4cG9ydHMudW5zdGFibGVfZm9yY2VGcmFtZVJhdGUgPSBmdW5jdGlvbiAoKSB7fTtcbn0gZWxzZSB7XG4gIC8vIENhcHR1cmUgbG9jYWwgcmVmZXJlbmNlcyB0byBuYXRpdmUgQVBJcywgaW4gY2FzZSBhIHBvbHlmaWxsIG92ZXJyaWRlcyB0aGVtLlxuICB2YXIgX3NldFRpbWVvdXQgPSB3aW5kb3cuc2V0VGltZW91dDtcbiAgdmFyIF9jbGVhclRpbWVvdXQgPSB3aW5kb3cuY2xlYXJUaW1lb3V0O1xuXG4gIGlmICh0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAvLyBUT0RPOiBTY2hlZHVsZXIgbm8gbG9uZ2VyIHJlcXVpcmVzIHRoZXNlIG1ldGhvZHMgdG8gYmUgcG9seWZpbGxlZC4gQnV0XG4gICAgLy8gbWF5YmUgd2Ugd2FudCB0byBjb250aW51ZSB3YXJuaW5nIGlmIHRoZXkgZG9uJ3QgZXhpc3QsIHRvIHByZXNlcnZlIHRoZVxuICAgIC8vIG9wdGlvbiB0byByZWx5IG9uIGl0IGluIHRoZSBmdXR1cmU/XG4gICAgdmFyIHJlcXVlc3RBbmltYXRpb25GcmFtZSA9IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWU7XG4gICAgdmFyIGNhbmNlbEFuaW1hdGlvbkZyYW1lID0gd2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lO1xuXG4gICAgaWYgKHR5cGVvZiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIC8vIFVzaW5nIGNvbnNvbGVbJ2Vycm9yJ10gdG8gZXZhZGUgQmFiZWwgYW5kIEVTTGludFxuICAgICAgY29uc29sZVsnZXJyb3InXShcIlRoaXMgYnJvd3NlciBkb2Vzbid0IHN1cHBvcnQgcmVxdWVzdEFuaW1hdGlvbkZyYW1lLiBcIiArICdNYWtlIHN1cmUgdGhhdCB5b3UgbG9hZCBhICcgKyAncG9seWZpbGwgaW4gb2xkZXIgYnJvd3NlcnMuIGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9yZWFjdC1wb2x5ZmlsbHMnKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGNhbmNlbEFuaW1hdGlvbkZyYW1lICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAvLyBVc2luZyBjb25zb2xlWydlcnJvciddIHRvIGV2YWRlIEJhYmVsIGFuZCBFU0xpbnRcbiAgICAgIGNvbnNvbGVbJ2Vycm9yJ10oXCJUaGlzIGJyb3dzZXIgZG9lc24ndCBzdXBwb3J0IGNhbmNlbEFuaW1hdGlvbkZyYW1lLiBcIiArICdNYWtlIHN1cmUgdGhhdCB5b3UgbG9hZCBhICcgKyAncG9seWZpbGwgaW4gb2xkZXIgYnJvd3NlcnMuIGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9yZWFjdC1wb2x5ZmlsbHMnKTtcbiAgICB9XG4gIH1cblxuICB2YXIgaXNNZXNzYWdlTG9vcFJ1bm5pbmcgPSBmYWxzZTtcbiAgdmFyIHNjaGVkdWxlZEhvc3RDYWxsYmFjayA9IG51bGw7XG4gIHZhciB0YXNrVGltZW91dElEID0gLTE7IC8vIFNjaGVkdWxlciBwZXJpb2RpY2FsbHkgeWllbGRzIGluIGNhc2UgdGhlcmUgaXMgb3RoZXIgd29yayBvbiB0aGUgbWFpblxuICAvLyB0aHJlYWQsIGxpa2UgdXNlciBldmVudHMuIEJ5IGRlZmF1bHQsIGl0IHlpZWxkcyBtdWx0aXBsZSB0aW1lcyBwZXIgZnJhbWUuXG4gIC8vIEl0IGRvZXMgbm90IGF0dGVtcHQgdG8gYWxpZ24gd2l0aCBmcmFtZSBib3VuZGFyaWVzLCBzaW5jZSBtb3N0IHRhc2tzIGRvbid0XG4gIC8vIG5lZWQgdG8gYmUgZnJhbWUgYWxpZ25lZDsgZm9yIHRob3NlIHRoYXQgZG8sIHVzZSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUuXG5cbiAgdmFyIHlpZWxkSW50ZXJ2YWwgPSA1O1xuICB2YXIgZGVhZGxpbmUgPSAwOyAvLyBUT0RPOiBNYWtlIHRoaXMgY29uZmlndXJhYmxlXG5cbiAge1xuICAgIC8vIGBpc0lucHV0UGVuZGluZ2AgaXMgbm90IGF2YWlsYWJsZS4gU2luY2Ugd2UgaGF2ZSBubyB3YXkgb2Yga25vd2luZyBpZlxuICAgIC8vIHRoZXJlJ3MgcGVuZGluZyBpbnB1dCwgYWx3YXlzIHlpZWxkIGF0IHRoZSBlbmQgb2YgdGhlIGZyYW1lLlxuICAgIGV4cG9ydHMudW5zdGFibGVfc2hvdWxkWWllbGQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gZXhwb3J0cy51bnN0YWJsZV9ub3coKSA+PSBkZWFkbGluZTtcbiAgICB9OyAvLyBTaW5jZSB3ZSB5aWVsZCBldmVyeSBmcmFtZSByZWdhcmRsZXNzLCBgcmVxdWVzdFBhaW50YCBoYXMgbm8gZWZmZWN0LlxuXG5cbiAgICByZXF1ZXN0UGFpbnQgPSBmdW5jdGlvbiAoKSB7fTtcbiAgfVxuXG4gIGV4cG9ydHMudW5zdGFibGVfZm9yY2VGcmFtZVJhdGUgPSBmdW5jdGlvbiAoZnBzKSB7XG4gICAgaWYgKGZwcyA8IDAgfHwgZnBzID4gMTI1KSB7XG4gICAgICAvLyBVc2luZyBjb25zb2xlWydlcnJvciddIHRvIGV2YWRlIEJhYmVsIGFuZCBFU0xpbnRcbiAgICAgIGNvbnNvbGVbJ2Vycm9yJ10oJ2ZvcmNlRnJhbWVSYXRlIHRha2VzIGEgcG9zaXRpdmUgaW50IGJldHdlZW4gMCBhbmQgMTI1LCAnICsgJ2ZvcmNpbmcgZnJhbWUgcmF0ZXMgaGlnaGVyIHRoYW4gMTI1IGZwcyBpcyBub3Qgc3VwcG9ydGVkJyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGZwcyA+IDApIHtcbiAgICAgIHlpZWxkSW50ZXJ2YWwgPSBNYXRoLmZsb29yKDEwMDAgLyBmcHMpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyByZXNldCB0aGUgZnJhbWVyYXRlXG4gICAgICB5aWVsZEludGVydmFsID0gNTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIHBlcmZvcm1Xb3JrVW50aWxEZWFkbGluZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoc2NoZWR1bGVkSG9zdENhbGxiYWNrICE9PSBudWxsKSB7XG4gICAgICB2YXIgY3VycmVudFRpbWUgPSBleHBvcnRzLnVuc3RhYmxlX25vdygpOyAvLyBZaWVsZCBhZnRlciBgeWllbGRJbnRlcnZhbGAgbXMsIHJlZ2FyZGxlc3Mgb2Ygd2hlcmUgd2UgYXJlIGluIHRoZSB2c3luY1xuICAgICAgLy8gY3ljbGUuIFRoaXMgbWVhbnMgdGhlcmUncyBhbHdheXMgdGltZSByZW1haW5pbmcgYXQgdGhlIGJlZ2lubmluZyBvZlxuICAgICAgLy8gdGhlIG1lc3NhZ2UgZXZlbnQuXG5cbiAgICAgIGRlYWRsaW5lID0gY3VycmVudFRpbWUgKyB5aWVsZEludGVydmFsO1xuICAgICAgdmFyIGhhc1RpbWVSZW1haW5pbmcgPSB0cnVlO1xuXG4gICAgICB0cnkge1xuICAgICAgICB2YXIgaGFzTW9yZVdvcmsgPSBzY2hlZHVsZWRIb3N0Q2FsbGJhY2soaGFzVGltZVJlbWFpbmluZywgY3VycmVudFRpbWUpO1xuXG4gICAgICAgIGlmICghaGFzTW9yZVdvcmspIHtcbiAgICAgICAgICBpc01lc3NhZ2VMb29wUnVubmluZyA9IGZhbHNlO1xuICAgICAgICAgIHNjaGVkdWxlZEhvc3RDYWxsYmFjayA9IG51bGw7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gSWYgdGhlcmUncyBtb3JlIHdvcmssIHNjaGVkdWxlIHRoZSBuZXh0IG1lc3NhZ2UgZXZlbnQgYXQgdGhlIGVuZFxuICAgICAgICAgIC8vIG9mIHRoZSBwcmVjZWRpbmcgb25lLlxuICAgICAgICAgIHBvcnQucG9zdE1lc3NhZ2UobnVsbCk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIC8vIElmIGEgc2NoZWR1bGVyIHRhc2sgdGhyb3dzLCBleGl0IHRoZSBjdXJyZW50IGJyb3dzZXIgdGFzayBzbyB0aGVcbiAgICAgICAgLy8gZXJyb3IgY2FuIGJlIG9ic2VydmVkLlxuICAgICAgICBwb3J0LnBvc3RNZXNzYWdlKG51bGwpO1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaXNNZXNzYWdlTG9vcFJ1bm5pbmcgPSBmYWxzZTtcbiAgICB9IC8vIFlpZWxkaW5nIHRvIHRoZSBicm93c2VyIHdpbGwgZ2l2ZSBpdCBhIGNoYW5jZSB0byBwYWludCwgc28gd2UgY2FuXG4gIH07XG5cbiAgdmFyIGNoYW5uZWwgPSBuZXcgTWVzc2FnZUNoYW5uZWwoKTtcbiAgdmFyIHBvcnQgPSBjaGFubmVsLnBvcnQyO1xuICBjaGFubmVsLnBvcnQxLm9ubWVzc2FnZSA9IHBlcmZvcm1Xb3JrVW50aWxEZWFkbGluZTtcblxuICByZXF1ZXN0SG9zdENhbGxiYWNrID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgc2NoZWR1bGVkSG9zdENhbGxiYWNrID0gY2FsbGJhY2s7XG5cbiAgICBpZiAoIWlzTWVzc2FnZUxvb3BSdW5uaW5nKSB7XG4gICAgICBpc01lc3NhZ2VMb29wUnVubmluZyA9IHRydWU7XG4gICAgICBwb3J0LnBvc3RNZXNzYWdlKG51bGwpO1xuICAgIH1cbiAgfTtcblxuICByZXF1ZXN0SG9zdFRpbWVvdXQgPSBmdW5jdGlvbiAoY2FsbGJhY2ssIG1zKSB7XG4gICAgdGFza1RpbWVvdXRJRCA9IF9zZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIGNhbGxiYWNrKGV4cG9ydHMudW5zdGFibGVfbm93KCkpO1xuICAgIH0sIG1zKTtcbiAgfTtcblxuICBjYW5jZWxIb3N0VGltZW91dCA9IGZ1bmN0aW9uICgpIHtcbiAgICBfY2xlYXJUaW1lb3V0KHRhc2tUaW1lb3V0SUQpO1xuXG4gICAgdGFza1RpbWVvdXRJRCA9IC0xO1xuICB9O1xufVxuXG5mdW5jdGlvbiBwdXNoKGhlYXAsIG5vZGUpIHtcbiAgdmFyIGluZGV4ID0gaGVhcC5sZW5ndGg7XG4gIGhlYXAucHVzaChub2RlKTtcbiAgc2lmdFVwKGhlYXAsIG5vZGUsIGluZGV4KTtcbn1cbmZ1bmN0aW9uIHBlZWsoaGVhcCkge1xuICB2YXIgZmlyc3QgPSBoZWFwWzBdO1xuICByZXR1cm4gZmlyc3QgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBmaXJzdDtcbn1cbmZ1bmN0aW9uIHBvcChoZWFwKSB7XG4gIHZhciBmaXJzdCA9IGhlYXBbMF07XG5cbiAgaWYgKGZpcnN0ICE9PSB1bmRlZmluZWQpIHtcbiAgICB2YXIgbGFzdCA9IGhlYXAucG9wKCk7XG5cbiAgICBpZiAobGFzdCAhPT0gZmlyc3QpIHtcbiAgICAgIGhlYXBbMF0gPSBsYXN0O1xuICAgICAgc2lmdERvd24oaGVhcCwgbGFzdCwgMCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZpcnN0O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBudWxsO1xuICB9XG59XG5cbmZ1bmN0aW9uIHNpZnRVcChoZWFwLCBub2RlLCBpKSB7XG4gIHZhciBpbmRleCA9IGk7XG5cbiAgd2hpbGUgKHRydWUpIHtcbiAgICB2YXIgcGFyZW50SW5kZXggPSBpbmRleCAtIDEgPj4+IDE7XG4gICAgdmFyIHBhcmVudCA9IGhlYXBbcGFyZW50SW5kZXhdO1xuXG4gICAgaWYgKHBhcmVudCAhPT0gdW5kZWZpbmVkICYmIGNvbXBhcmUocGFyZW50LCBub2RlKSA+IDApIHtcbiAgICAgIC8vIFRoZSBwYXJlbnQgaXMgbGFyZ2VyLiBTd2FwIHBvc2l0aW9ucy5cbiAgICAgIGhlYXBbcGFyZW50SW5kZXhdID0gbm9kZTtcbiAgICAgIGhlYXBbaW5kZXhdID0gcGFyZW50O1xuICAgICAgaW5kZXggPSBwYXJlbnRJbmRleDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVGhlIHBhcmVudCBpcyBzbWFsbGVyLiBFeGl0LlxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBzaWZ0RG93bihoZWFwLCBub2RlLCBpKSB7XG4gIHZhciBpbmRleCA9IGk7XG4gIHZhciBsZW5ndGggPSBoZWFwLmxlbmd0aDtcblxuICB3aGlsZSAoaW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgbGVmdEluZGV4ID0gKGluZGV4ICsgMSkgKiAyIC0gMTtcbiAgICB2YXIgbGVmdCA9IGhlYXBbbGVmdEluZGV4XTtcbiAgICB2YXIgcmlnaHRJbmRleCA9IGxlZnRJbmRleCArIDE7XG4gICAgdmFyIHJpZ2h0ID0gaGVhcFtyaWdodEluZGV4XTsgLy8gSWYgdGhlIGxlZnQgb3IgcmlnaHQgbm9kZSBpcyBzbWFsbGVyLCBzd2FwIHdpdGggdGhlIHNtYWxsZXIgb2YgdGhvc2UuXG5cbiAgICBpZiAobGVmdCAhPT0gdW5kZWZpbmVkICYmIGNvbXBhcmUobGVmdCwgbm9kZSkgPCAwKSB7XG4gICAgICBpZiAocmlnaHQgIT09IHVuZGVmaW5lZCAmJiBjb21wYXJlKHJpZ2h0LCBsZWZ0KSA8IDApIHtcbiAgICAgICAgaGVhcFtpbmRleF0gPSByaWdodDtcbiAgICAgICAgaGVhcFtyaWdodEluZGV4XSA9IG5vZGU7XG4gICAgICAgIGluZGV4ID0gcmlnaHRJbmRleDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGhlYXBbaW5kZXhdID0gbGVmdDtcbiAgICAgICAgaGVhcFtsZWZ0SW5kZXhdID0gbm9kZTtcbiAgICAgICAgaW5kZXggPSBsZWZ0SW5kZXg7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChyaWdodCAhPT0gdW5kZWZpbmVkICYmIGNvbXBhcmUocmlnaHQsIG5vZGUpIDwgMCkge1xuICAgICAgaGVhcFtpbmRleF0gPSByaWdodDtcbiAgICAgIGhlYXBbcmlnaHRJbmRleF0gPSBub2RlO1xuICAgICAgaW5kZXggPSByaWdodEluZGV4O1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBOZWl0aGVyIGNoaWxkIGlzIHNtYWxsZXIuIEV4aXQuXG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNvbXBhcmUoYSwgYikge1xuICAvLyBDb21wYXJlIHNvcnQgaW5kZXggZmlyc3QsIHRoZW4gdGFzayBpZC5cbiAgdmFyIGRpZmYgPSBhLnNvcnRJbmRleCAtIGIuc29ydEluZGV4O1xuICByZXR1cm4gZGlmZiAhPT0gMCA/IGRpZmYgOiBhLmlkIC0gYi5pZDtcbn1cblxuLy8gVE9ETzogVXNlIHN5bWJvbHM/XG52YXIgSW1tZWRpYXRlUHJpb3JpdHkgPSAxO1xudmFyIFVzZXJCbG9ja2luZ1ByaW9yaXR5ID0gMjtcbnZhciBOb3JtYWxQcmlvcml0eSA9IDM7XG52YXIgTG93UHJpb3JpdHkgPSA0O1xudmFyIElkbGVQcmlvcml0eSA9IDU7XG5cbmZ1bmN0aW9uIG1hcmtUYXNrRXJyb3JlZCh0YXNrLCBtcykge1xufVxuXG4vKiBlc2xpbnQtZGlzYWJsZSBuby12YXIgKi9cbi8vIE1hdGgucG93KDIsIDMwKSAtIDFcbi8vIDBiMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExXG5cbnZhciBtYXhTaWduZWQzMUJpdEludCA9IDEwNzM3NDE4MjM7IC8vIFRpbWVzIG91dCBpbW1lZGlhdGVseVxuXG52YXIgSU1NRURJQVRFX1BSSU9SSVRZX1RJTUVPVVQgPSAtMTsgLy8gRXZlbnR1YWxseSB0aW1lcyBvdXRcblxudmFyIFVTRVJfQkxPQ0tJTkdfUFJJT1JJVFlfVElNRU9VVCA9IDI1MDtcbnZhciBOT1JNQUxfUFJJT1JJVFlfVElNRU9VVCA9IDUwMDA7XG52YXIgTE9XX1BSSU9SSVRZX1RJTUVPVVQgPSAxMDAwMDsgLy8gTmV2ZXIgdGltZXMgb3V0XG5cbnZhciBJRExFX1BSSU9SSVRZX1RJTUVPVVQgPSBtYXhTaWduZWQzMUJpdEludDsgLy8gVGFza3MgYXJlIHN0b3JlZCBvbiBhIG1pbiBoZWFwXG5cbnZhciB0YXNrUXVldWUgPSBbXTtcbnZhciB0aW1lclF1ZXVlID0gW107IC8vIEluY3JlbWVudGluZyBpZCBjb3VudGVyLiBVc2VkIHRvIG1haW50YWluIGluc2VydGlvbiBvcmRlci5cblxudmFyIHRhc2tJZENvdW50ZXIgPSAxOyAvLyBQYXVzaW5nIHRoZSBzY2hlZHVsZXIgaXMgdXNlZnVsIGZvciBkZWJ1Z2dpbmcuXG52YXIgY3VycmVudFRhc2sgPSBudWxsO1xudmFyIGN1cnJlbnRQcmlvcml0eUxldmVsID0gTm9ybWFsUHJpb3JpdHk7IC8vIFRoaXMgaXMgc2V0IHdoaWxlIHBlcmZvcm1pbmcgd29yaywgdG8gcHJldmVudCByZS1lbnRyYW5jeS5cblxudmFyIGlzUGVyZm9ybWluZ1dvcmsgPSBmYWxzZTtcbnZhciBpc0hvc3RDYWxsYmFja1NjaGVkdWxlZCA9IGZhbHNlO1xudmFyIGlzSG9zdFRpbWVvdXRTY2hlZHVsZWQgPSBmYWxzZTtcblxuZnVuY3Rpb24gYWR2YW5jZVRpbWVycyhjdXJyZW50VGltZSkge1xuICAvLyBDaGVjayBmb3IgdGFza3MgdGhhdCBhcmUgbm8gbG9uZ2VyIGRlbGF5ZWQgYW5kIGFkZCB0aGVtIHRvIHRoZSBxdWV1ZS5cbiAgdmFyIHRpbWVyID0gcGVlayh0aW1lclF1ZXVlKTtcblxuICB3aGlsZSAodGltZXIgIT09IG51bGwpIHtcbiAgICBpZiAodGltZXIuY2FsbGJhY2sgPT09IG51bGwpIHtcbiAgICAgIC8vIFRpbWVyIHdhcyBjYW5jZWxsZWQuXG4gICAgICBwb3AodGltZXJRdWV1ZSk7XG4gICAgfSBlbHNlIGlmICh0aW1lci5zdGFydFRpbWUgPD0gY3VycmVudFRpbWUpIHtcbiAgICAgIC8vIFRpbWVyIGZpcmVkLiBUcmFuc2ZlciB0byB0aGUgdGFzayBxdWV1ZS5cbiAgICAgIHBvcCh0aW1lclF1ZXVlKTtcbiAgICAgIHRpbWVyLnNvcnRJbmRleCA9IHRpbWVyLmV4cGlyYXRpb25UaW1lO1xuICAgICAgcHVzaCh0YXNrUXVldWUsIHRpbWVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gUmVtYWluaW5nIHRpbWVycyBhcmUgcGVuZGluZy5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aW1lciA9IHBlZWsodGltZXJRdWV1ZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaGFuZGxlVGltZW91dChjdXJyZW50VGltZSkge1xuICBpc0hvc3RUaW1lb3V0U2NoZWR1bGVkID0gZmFsc2U7XG4gIGFkdmFuY2VUaW1lcnMoY3VycmVudFRpbWUpO1xuXG4gIGlmICghaXNIb3N0Q2FsbGJhY2tTY2hlZHVsZWQpIHtcbiAgICBpZiAocGVlayh0YXNrUXVldWUpICE9PSBudWxsKSB7XG4gICAgICBpc0hvc3RDYWxsYmFja1NjaGVkdWxlZCA9IHRydWU7XG4gICAgICByZXF1ZXN0SG9zdENhbGxiYWNrKGZsdXNoV29yayk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBmaXJzdFRpbWVyID0gcGVlayh0aW1lclF1ZXVlKTtcblxuICAgICAgaWYgKGZpcnN0VGltZXIgIT09IG51bGwpIHtcbiAgICAgICAgcmVxdWVzdEhvc3RUaW1lb3V0KGhhbmRsZVRpbWVvdXQsIGZpcnN0VGltZXIuc3RhcnRUaW1lIC0gY3VycmVudFRpbWUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBmbHVzaFdvcmsoaGFzVGltZVJlbWFpbmluZywgaW5pdGlhbFRpbWUpIHtcblxuXG4gIGlzSG9zdENhbGxiYWNrU2NoZWR1bGVkID0gZmFsc2U7XG5cbiAgaWYgKGlzSG9zdFRpbWVvdXRTY2hlZHVsZWQpIHtcbiAgICAvLyBXZSBzY2hlZHVsZWQgYSB0aW1lb3V0IGJ1dCBpdCdzIG5vIGxvbmdlciBuZWVkZWQuIENhbmNlbCBpdC5cbiAgICBpc0hvc3RUaW1lb3V0U2NoZWR1bGVkID0gZmFsc2U7XG4gICAgY2FuY2VsSG9zdFRpbWVvdXQoKTtcbiAgfVxuXG4gIGlzUGVyZm9ybWluZ1dvcmsgPSB0cnVlO1xuICB2YXIgcHJldmlvdXNQcmlvcml0eUxldmVsID0gY3VycmVudFByaW9yaXR5TGV2ZWw7XG5cbiAgdHJ5IHtcbiAgICBpZiAoZW5hYmxlUHJvZmlsaW5nKSB7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gd29ya0xvb3AoaGFzVGltZVJlbWFpbmluZywgaW5pdGlhbFRpbWUpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgaWYgKGN1cnJlbnRUYXNrICE9PSBudWxsKSB7XG4gICAgICAgICAgdmFyIGN1cnJlbnRUaW1lID0gZXhwb3J0cy51bnN0YWJsZV9ub3coKTtcbiAgICAgICAgICBtYXJrVGFza0Vycm9yZWQoY3VycmVudFRhc2ssIGN1cnJlbnRUaW1lKTtcbiAgICAgICAgICBjdXJyZW50VGFzay5pc1F1ZXVlZCA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIE5vIGNhdGNoIGluIHByb2QgY29kZSBwYXRoLlxuICAgICAgcmV0dXJuIHdvcmtMb29wKGhhc1RpbWVSZW1haW5pbmcsIGluaXRpYWxUaW1lKTtcbiAgICB9XG4gIH0gZmluYWxseSB7XG4gICAgY3VycmVudFRhc2sgPSBudWxsO1xuICAgIGN1cnJlbnRQcmlvcml0eUxldmVsID0gcHJldmlvdXNQcmlvcml0eUxldmVsO1xuICAgIGlzUGVyZm9ybWluZ1dvcmsgPSBmYWxzZTtcbiAgfVxufVxuXG5mdW5jdGlvbiB3b3JrTG9vcChoYXNUaW1lUmVtYWluaW5nLCBpbml0aWFsVGltZSkge1xuICB2YXIgY3VycmVudFRpbWUgPSBpbml0aWFsVGltZTtcbiAgYWR2YW5jZVRpbWVycyhjdXJyZW50VGltZSk7XG4gIGN1cnJlbnRUYXNrID0gcGVlayh0YXNrUXVldWUpO1xuXG4gIHdoaWxlIChjdXJyZW50VGFzayAhPT0gbnVsbCAmJiAhKGVuYWJsZVNjaGVkdWxlckRlYnVnZ2luZyApKSB7XG4gICAgaWYgKGN1cnJlbnRUYXNrLmV4cGlyYXRpb25UaW1lID4gY3VycmVudFRpbWUgJiYgKCFoYXNUaW1lUmVtYWluaW5nIHx8IGV4cG9ydHMudW5zdGFibGVfc2hvdWxkWWllbGQoKSkpIHtcbiAgICAgIC8vIFRoaXMgY3VycmVudFRhc2sgaGFzbid0IGV4cGlyZWQsIGFuZCB3ZSd2ZSByZWFjaGVkIHRoZSBkZWFkbGluZS5cbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIHZhciBjYWxsYmFjayA9IGN1cnJlbnRUYXNrLmNhbGxiYWNrO1xuXG4gICAgaWYgKHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY3VycmVudFRhc2suY2FsbGJhY2sgPSBudWxsO1xuICAgICAgY3VycmVudFByaW9yaXR5TGV2ZWwgPSBjdXJyZW50VGFzay5wcmlvcml0eUxldmVsO1xuICAgICAgdmFyIGRpZFVzZXJDYWxsYmFja1RpbWVvdXQgPSBjdXJyZW50VGFzay5leHBpcmF0aW9uVGltZSA8PSBjdXJyZW50VGltZTtcblxuICAgICAgdmFyIGNvbnRpbnVhdGlvbkNhbGxiYWNrID0gY2FsbGJhY2soZGlkVXNlckNhbGxiYWNrVGltZW91dCk7XG4gICAgICBjdXJyZW50VGltZSA9IGV4cG9ydHMudW5zdGFibGVfbm93KCk7XG5cbiAgICAgIGlmICh0eXBlb2YgY29udGludWF0aW9uQ2FsbGJhY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgY3VycmVudFRhc2suY2FsbGJhY2sgPSBjb250aW51YXRpb25DYWxsYmFjaztcbiAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgaWYgKGN1cnJlbnRUYXNrID09PSBwZWVrKHRhc2tRdWV1ZSkpIHtcbiAgICAgICAgICBwb3AodGFza1F1ZXVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBhZHZhbmNlVGltZXJzKGN1cnJlbnRUaW1lKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcG9wKHRhc2tRdWV1ZSk7XG4gICAgfVxuXG4gICAgY3VycmVudFRhc2sgPSBwZWVrKHRhc2tRdWV1ZSk7XG4gIH0gLy8gUmV0dXJuIHdoZXRoZXIgdGhlcmUncyBhZGRpdGlvbmFsIHdvcmtcblxuXG4gIGlmIChjdXJyZW50VGFzayAhPT0gbnVsbCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9IGVsc2Uge1xuICAgIHZhciBmaXJzdFRpbWVyID0gcGVlayh0aW1lclF1ZXVlKTtcblxuICAgIGlmIChmaXJzdFRpbWVyICE9PSBudWxsKSB7XG4gICAgICByZXF1ZXN0SG9zdFRpbWVvdXQoaGFuZGxlVGltZW91dCwgZmlyc3RUaW1lci5zdGFydFRpbWUgLSBjdXJyZW50VGltZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbmZ1bmN0aW9uIHVuc3RhYmxlX3J1bldpdGhQcmlvcml0eShwcmlvcml0eUxldmVsLCBldmVudEhhbmRsZXIpIHtcbiAgc3dpdGNoIChwcmlvcml0eUxldmVsKSB7XG4gICAgY2FzZSBJbW1lZGlhdGVQcmlvcml0eTpcbiAgICBjYXNlIFVzZXJCbG9ja2luZ1ByaW9yaXR5OlxuICAgIGNhc2UgTm9ybWFsUHJpb3JpdHk6XG4gICAgY2FzZSBMb3dQcmlvcml0eTpcbiAgICBjYXNlIElkbGVQcmlvcml0eTpcbiAgICAgIGJyZWFrO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHByaW9yaXR5TGV2ZWwgPSBOb3JtYWxQcmlvcml0eTtcbiAgfVxuXG4gIHZhciBwcmV2aW91c1ByaW9yaXR5TGV2ZWwgPSBjdXJyZW50UHJpb3JpdHlMZXZlbDtcbiAgY3VycmVudFByaW9yaXR5TGV2ZWwgPSBwcmlvcml0eUxldmVsO1xuXG4gIHRyeSB7XG4gICAgcmV0dXJuIGV2ZW50SGFuZGxlcigpO1xuICB9IGZpbmFsbHkge1xuICAgIGN1cnJlbnRQcmlvcml0eUxldmVsID0gcHJldmlvdXNQcmlvcml0eUxldmVsO1xuICB9XG59XG5cbmZ1bmN0aW9uIHVuc3RhYmxlX25leHQoZXZlbnRIYW5kbGVyKSB7XG4gIHZhciBwcmlvcml0eUxldmVsO1xuXG4gIHN3aXRjaCAoY3VycmVudFByaW9yaXR5TGV2ZWwpIHtcbiAgICBjYXNlIEltbWVkaWF0ZVByaW9yaXR5OlxuICAgIGNhc2UgVXNlckJsb2NraW5nUHJpb3JpdHk6XG4gICAgY2FzZSBOb3JtYWxQcmlvcml0eTpcbiAgICAgIC8vIFNoaWZ0IGRvd24gdG8gbm9ybWFsIHByaW9yaXR5XG4gICAgICBwcmlvcml0eUxldmVsID0gTm9ybWFsUHJpb3JpdHk7XG4gICAgICBicmVhaztcblxuICAgIGRlZmF1bHQ6XG4gICAgICAvLyBBbnl0aGluZyBsb3dlciB0aGFuIG5vcm1hbCBwcmlvcml0eSBzaG91bGQgcmVtYWluIGF0IHRoZSBjdXJyZW50IGxldmVsLlxuICAgICAgcHJpb3JpdHlMZXZlbCA9IGN1cnJlbnRQcmlvcml0eUxldmVsO1xuICAgICAgYnJlYWs7XG4gIH1cblxuICB2YXIgcHJldmlvdXNQcmlvcml0eUxldmVsID0gY3VycmVudFByaW9yaXR5TGV2ZWw7XG4gIGN1cnJlbnRQcmlvcml0eUxldmVsID0gcHJpb3JpdHlMZXZlbDtcblxuICB0cnkge1xuICAgIHJldHVybiBldmVudEhhbmRsZXIoKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBjdXJyZW50UHJpb3JpdHlMZXZlbCA9IHByZXZpb3VzUHJpb3JpdHlMZXZlbDtcbiAgfVxufVxuXG5mdW5jdGlvbiB1bnN0YWJsZV93cmFwQ2FsbGJhY2soY2FsbGJhY2spIHtcbiAgdmFyIHBhcmVudFByaW9yaXR5TGV2ZWwgPSBjdXJyZW50UHJpb3JpdHlMZXZlbDtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAvLyBUaGlzIGlzIGEgZm9yayBvZiBydW5XaXRoUHJpb3JpdHksIGlubGluZWQgZm9yIHBlcmZvcm1hbmNlLlxuICAgIHZhciBwcmV2aW91c1ByaW9yaXR5TGV2ZWwgPSBjdXJyZW50UHJpb3JpdHlMZXZlbDtcbiAgICBjdXJyZW50UHJpb3JpdHlMZXZlbCA9IHBhcmVudFByaW9yaXR5TGV2ZWw7XG5cbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGNhbGxiYWNrLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGN1cnJlbnRQcmlvcml0eUxldmVsID0gcHJldmlvdXNQcmlvcml0eUxldmVsO1xuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gdW5zdGFibGVfc2NoZWR1bGVDYWxsYmFjayhwcmlvcml0eUxldmVsLCBjYWxsYmFjaywgb3B0aW9ucykge1xuICB2YXIgY3VycmVudFRpbWUgPSBleHBvcnRzLnVuc3RhYmxlX25vdygpO1xuICB2YXIgc3RhcnRUaW1lO1xuXG4gIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ29iamVjdCcgJiYgb3B0aW9ucyAhPT0gbnVsbCkge1xuICAgIHZhciBkZWxheSA9IG9wdGlvbnMuZGVsYXk7XG5cbiAgICBpZiAodHlwZW9mIGRlbGF5ID09PSAnbnVtYmVyJyAmJiBkZWxheSA+IDApIHtcbiAgICAgIHN0YXJ0VGltZSA9IGN1cnJlbnRUaW1lICsgZGVsYXk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXJ0VGltZSA9IGN1cnJlbnRUaW1lO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBzdGFydFRpbWUgPSBjdXJyZW50VGltZTtcbiAgfVxuXG4gIHZhciB0aW1lb3V0O1xuXG4gIHN3aXRjaCAocHJpb3JpdHlMZXZlbCkge1xuICAgIGNhc2UgSW1tZWRpYXRlUHJpb3JpdHk6XG4gICAgICB0aW1lb3V0ID0gSU1NRURJQVRFX1BSSU9SSVRZX1RJTUVPVVQ7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgVXNlckJsb2NraW5nUHJpb3JpdHk6XG4gICAgICB0aW1lb3V0ID0gVVNFUl9CTE9DS0lOR19QUklPUklUWV9USU1FT1VUO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIElkbGVQcmlvcml0eTpcbiAgICAgIHRpbWVvdXQgPSBJRExFX1BSSU9SSVRZX1RJTUVPVVQ7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgTG93UHJpb3JpdHk6XG4gICAgICB0aW1lb3V0ID0gTE9XX1BSSU9SSVRZX1RJTUVPVVQ7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgTm9ybWFsUHJpb3JpdHk6XG4gICAgZGVmYXVsdDpcbiAgICAgIHRpbWVvdXQgPSBOT1JNQUxfUFJJT1JJVFlfVElNRU9VVDtcbiAgICAgIGJyZWFrO1xuICB9XG5cbiAgdmFyIGV4cGlyYXRpb25UaW1lID0gc3RhcnRUaW1lICsgdGltZW91dDtcbiAgdmFyIG5ld1Rhc2sgPSB7XG4gICAgaWQ6IHRhc2tJZENvdW50ZXIrKyxcbiAgICBjYWxsYmFjazogY2FsbGJhY2ssXG4gICAgcHJpb3JpdHlMZXZlbDogcHJpb3JpdHlMZXZlbCxcbiAgICBzdGFydFRpbWU6IHN0YXJ0VGltZSxcbiAgICBleHBpcmF0aW9uVGltZTogZXhwaXJhdGlvblRpbWUsXG4gICAgc29ydEluZGV4OiAtMVxuICB9O1xuXG4gIGlmIChzdGFydFRpbWUgPiBjdXJyZW50VGltZSkge1xuICAgIC8vIFRoaXMgaXMgYSBkZWxheWVkIHRhc2suXG4gICAgbmV3VGFzay5zb3J0SW5kZXggPSBzdGFydFRpbWU7XG4gICAgcHVzaCh0aW1lclF1ZXVlLCBuZXdUYXNrKTtcblxuICAgIGlmIChwZWVrKHRhc2tRdWV1ZSkgPT09IG51bGwgJiYgbmV3VGFzayA9PT0gcGVlayh0aW1lclF1ZXVlKSkge1xuICAgICAgLy8gQWxsIHRhc2tzIGFyZSBkZWxheWVkLCBhbmQgdGhpcyBpcyB0aGUgdGFzayB3aXRoIHRoZSBlYXJsaWVzdCBkZWxheS5cbiAgICAgIGlmIChpc0hvc3RUaW1lb3V0U2NoZWR1bGVkKSB7XG4gICAgICAgIC8vIENhbmNlbCBhbiBleGlzdGluZyB0aW1lb3V0LlxuICAgICAgICBjYW5jZWxIb3N0VGltZW91dCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaXNIb3N0VGltZW91dFNjaGVkdWxlZCA9IHRydWU7XG4gICAgICB9IC8vIFNjaGVkdWxlIGEgdGltZW91dC5cblxuXG4gICAgICByZXF1ZXN0SG9zdFRpbWVvdXQoaGFuZGxlVGltZW91dCwgc3RhcnRUaW1lIC0gY3VycmVudFRpbWUpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBuZXdUYXNrLnNvcnRJbmRleCA9IGV4cGlyYXRpb25UaW1lO1xuICAgIHB1c2godGFza1F1ZXVlLCBuZXdUYXNrKTtcbiAgICAvLyB3YWl0IHVudGlsIHRoZSBuZXh0IHRpbWUgd2UgeWllbGQuXG5cblxuICAgIGlmICghaXNIb3N0Q2FsbGJhY2tTY2hlZHVsZWQgJiYgIWlzUGVyZm9ybWluZ1dvcmspIHtcbiAgICAgIGlzSG9zdENhbGxiYWNrU2NoZWR1bGVkID0gdHJ1ZTtcbiAgICAgIHJlcXVlc3RIb3N0Q2FsbGJhY2soZmx1c2hXb3JrKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmV3VGFzaztcbn1cblxuZnVuY3Rpb24gdW5zdGFibGVfcGF1c2VFeGVjdXRpb24oKSB7XG59XG5cbmZ1bmN0aW9uIHVuc3RhYmxlX2NvbnRpbnVlRXhlY3V0aW9uKCkge1xuXG4gIGlmICghaXNIb3N0Q2FsbGJhY2tTY2hlZHVsZWQgJiYgIWlzUGVyZm9ybWluZ1dvcmspIHtcbiAgICBpc0hvc3RDYWxsYmFja1NjaGVkdWxlZCA9IHRydWU7XG4gICAgcmVxdWVzdEhvc3RDYWxsYmFjayhmbHVzaFdvcmspO1xuICB9XG59XG5cbmZ1bmN0aW9uIHVuc3RhYmxlX2dldEZpcnN0Q2FsbGJhY2tOb2RlKCkge1xuICByZXR1cm4gcGVlayh0YXNrUXVldWUpO1xufVxuXG5mdW5jdGlvbiB1bnN0YWJsZV9jYW5jZWxDYWxsYmFjayh0YXNrKSB7XG4gIC8vIHJlbW92ZSBmcm9tIHRoZSBxdWV1ZSBiZWNhdXNlIHlvdSBjYW4ndCByZW1vdmUgYXJiaXRyYXJ5IG5vZGVzIGZyb20gYW5cbiAgLy8gYXJyYXkgYmFzZWQgaGVhcCwgb25seSB0aGUgZmlyc3Qgb25lLilcblxuXG4gIHRhc2suY2FsbGJhY2sgPSBudWxsO1xufVxuXG5mdW5jdGlvbiB1bnN0YWJsZV9nZXRDdXJyZW50UHJpb3JpdHlMZXZlbCgpIHtcbiAgcmV0dXJuIGN1cnJlbnRQcmlvcml0eUxldmVsO1xufVxuXG52YXIgdW5zdGFibGVfcmVxdWVzdFBhaW50ID0gcmVxdWVzdFBhaW50O1xudmFyIHVuc3RhYmxlX1Byb2ZpbGluZyA9ICBudWxsO1xuXG5leHBvcnRzLnVuc3RhYmxlX0lkbGVQcmlvcml0eSA9IElkbGVQcmlvcml0eTtcbmV4cG9ydHMudW5zdGFibGVfSW1tZWRpYXRlUHJpb3JpdHkgPSBJbW1lZGlhdGVQcmlvcml0eTtcbmV4cG9ydHMudW5zdGFibGVfTG93UHJpb3JpdHkgPSBMb3dQcmlvcml0eTtcbmV4cG9ydHMudW5zdGFibGVfTm9ybWFsUHJpb3JpdHkgPSBOb3JtYWxQcmlvcml0eTtcbmV4cG9ydHMudW5zdGFibGVfUHJvZmlsaW5nID0gdW5zdGFibGVfUHJvZmlsaW5nO1xuZXhwb3J0cy51bnN0YWJsZV9Vc2VyQmxvY2tpbmdQcmlvcml0eSA9IFVzZXJCbG9ja2luZ1ByaW9yaXR5O1xuZXhwb3J0cy51bnN0YWJsZV9jYW5jZWxDYWxsYmFjayA9IHVuc3RhYmxlX2NhbmNlbENhbGxiYWNrO1xuZXhwb3J0cy51bnN0YWJsZV9jb250aW51ZUV4ZWN1dGlvbiA9IHVuc3RhYmxlX2NvbnRpbnVlRXhlY3V0aW9uO1xuZXhwb3J0cy51bnN0YWJsZV9nZXRDdXJyZW50UHJpb3JpdHlMZXZlbCA9IHVuc3RhYmxlX2dldEN1cnJlbnRQcmlvcml0eUxldmVsO1xuZXhwb3J0cy51bnN0YWJsZV9nZXRGaXJzdENhbGxiYWNrTm9kZSA9IHVuc3RhYmxlX2dldEZpcnN0Q2FsbGJhY2tOb2RlO1xuZXhwb3J0cy51bnN0YWJsZV9uZXh0ID0gdW5zdGFibGVfbmV4dDtcbmV4cG9ydHMudW5zdGFibGVfcGF1c2VFeGVjdXRpb24gPSB1bnN0YWJsZV9wYXVzZUV4ZWN1dGlvbjtcbmV4cG9ydHMudW5zdGFibGVfcmVxdWVzdFBhaW50ID0gdW5zdGFibGVfcmVxdWVzdFBhaW50O1xuZXhwb3J0cy51bnN0YWJsZV9ydW5XaXRoUHJpb3JpdHkgPSB1bnN0YWJsZV9ydW5XaXRoUHJpb3JpdHk7XG5leHBvcnRzLnVuc3RhYmxlX3NjaGVkdWxlQ2FsbGJhY2sgPSB1bnN0YWJsZV9zY2hlZHVsZUNhbGxiYWNrO1xuZXhwb3J0cy51bnN0YWJsZV93cmFwQ2FsbGJhY2sgPSB1bnN0YWJsZV93cmFwQ2FsbGJhY2s7XG4gIH0pKCk7XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvc2NoZWR1bGVyLnByb2R1Y3Rpb24ubWluLmpzJyk7XG59IGVsc2Uge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3NjaGVkdWxlci5kZXZlbG9wbWVudC5qcycpO1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJykge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3NjaGVkdWxlci10cmFjaW5nLnByb2R1Y3Rpb24ubWluLmpzJyk7XG59IGVsc2Uge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3NjaGVkdWxlci10cmFjaW5nLmRldmVsb3BtZW50LmpzJyk7XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIGlzT2xkSUUgPSBmdW5jdGlvbiBpc09sZElFKCkge1xuICB2YXIgbWVtbztcbiAgcmV0dXJuIGZ1bmN0aW9uIG1lbW9yaXplKCkge1xuICAgIGlmICh0eXBlb2YgbWVtbyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIC8vIFRlc3QgZm9yIElFIDw9IDkgYXMgcHJvcG9zZWQgYnkgQnJvd3NlcmhhY2tzXG4gICAgICAvLyBAc2VlIGh0dHA6Ly9icm93c2VyaGFja3MuY29tLyNoYWNrLWU3MWQ4NjkyZjY1MzM0MTczZmVlNzE1YzIyMmNiODA1XG4gICAgICAvLyBUZXN0cyBmb3IgZXhpc3RlbmNlIG9mIHN0YW5kYXJkIGdsb2JhbHMgaXMgdG8gYWxsb3cgc3R5bGUtbG9hZGVyXG4gICAgICAvLyB0byBvcGVyYXRlIGNvcnJlY3RseSBpbnRvIG5vbi1zdGFuZGFyZCBlbnZpcm9ubWVudHNcbiAgICAgIC8vIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3dlYnBhY2stY29udHJpYi9zdHlsZS1sb2FkZXIvaXNzdWVzLzE3N1xuICAgICAgbWVtbyA9IEJvb2xlYW4od2luZG93ICYmIGRvY3VtZW50ICYmIGRvY3VtZW50LmFsbCAmJiAhd2luZG93LmF0b2IpO1xuICAgIH1cblxuICAgIHJldHVybiBtZW1vO1xuICB9O1xufSgpO1xuXG52YXIgZ2V0VGFyZ2V0ID0gZnVuY3Rpb24gZ2V0VGFyZ2V0KCkge1xuICB2YXIgbWVtbyA9IHt9O1xuICByZXR1cm4gZnVuY3Rpb24gbWVtb3JpemUodGFyZ2V0KSB7XG4gICAgaWYgKHR5cGVvZiBtZW1vW3RhcmdldF0gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB2YXIgc3R5bGVUYXJnZXQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHRhcmdldCk7IC8vIFNwZWNpYWwgY2FzZSB0byByZXR1cm4gaGVhZCBvZiBpZnJhbWUgaW5zdGVhZCBvZiBpZnJhbWUgaXRzZWxmXG5cbiAgICAgIGlmICh3aW5kb3cuSFRNTElGcmFtZUVsZW1lbnQgJiYgc3R5bGVUYXJnZXQgaW5zdGFuY2VvZiB3aW5kb3cuSFRNTElGcmFtZUVsZW1lbnQpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAvLyBUaGlzIHdpbGwgdGhyb3cgYW4gZXhjZXB0aW9uIGlmIGFjY2VzcyB0byBpZnJhbWUgaXMgYmxvY2tlZFxuICAgICAgICAgIC8vIGR1ZSB0byBjcm9zcy1vcmlnaW4gcmVzdHJpY3Rpb25zXG4gICAgICAgICAgc3R5bGVUYXJnZXQgPSBzdHlsZVRhcmdldC5jb250ZW50RG9jdW1lbnQuaGVhZDtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIC8vIGlzdGFuYnVsIGlnbm9yZSBuZXh0XG4gICAgICAgICAgc3R5bGVUYXJnZXQgPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIG1lbW9bdGFyZ2V0XSA9IHN0eWxlVGFyZ2V0O1xuICAgIH1cblxuICAgIHJldHVybiBtZW1vW3RhcmdldF07XG4gIH07XG59KCk7XG5cbnZhciBzdHlsZXNJbkRvbSA9IFtdO1xuXG5mdW5jdGlvbiBnZXRJbmRleEJ5SWRlbnRpZmllcihpZGVudGlmaWVyKSB7XG4gIHZhciByZXN1bHQgPSAtMTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0eWxlc0luRG9tLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKHN0eWxlc0luRG9tW2ldLmlkZW50aWZpZXIgPT09IGlkZW50aWZpZXIpIHtcbiAgICAgIHJlc3VsdCA9IGk7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBtb2R1bGVzVG9Eb20obGlzdCwgb3B0aW9ucykge1xuICB2YXIgaWRDb3VudE1hcCA9IHt9O1xuICB2YXIgaWRlbnRpZmllcnMgPSBbXTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgaXRlbSA9IGxpc3RbaV07XG4gICAgdmFyIGlkID0gb3B0aW9ucy5iYXNlID8gaXRlbVswXSArIG9wdGlvbnMuYmFzZSA6IGl0ZW1bMF07XG4gICAgdmFyIGNvdW50ID0gaWRDb3VudE1hcFtpZF0gfHwgMDtcbiAgICB2YXIgaWRlbnRpZmllciA9IFwiXCIuY29uY2F0KGlkLCBcIiBcIikuY29uY2F0KGNvdW50KTtcbiAgICBpZENvdW50TWFwW2lkXSA9IGNvdW50ICsgMTtcbiAgICB2YXIgaW5kZXggPSBnZXRJbmRleEJ5SWRlbnRpZmllcihpZGVudGlmaWVyKTtcbiAgICB2YXIgb2JqID0ge1xuICAgICAgY3NzOiBpdGVtWzFdLFxuICAgICAgbWVkaWE6IGl0ZW1bMl0sXG4gICAgICBzb3VyY2VNYXA6IGl0ZW1bM11cbiAgICB9O1xuXG4gICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgc3R5bGVzSW5Eb21baW5kZXhdLnJlZmVyZW5jZXMrKztcbiAgICAgIHN0eWxlc0luRG9tW2luZGV4XS51cGRhdGVyKG9iaik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0eWxlc0luRG9tLnB1c2goe1xuICAgICAgICBpZGVudGlmaWVyOiBpZGVudGlmaWVyLFxuICAgICAgICB1cGRhdGVyOiBhZGRTdHlsZShvYmosIG9wdGlvbnMpLFxuICAgICAgICByZWZlcmVuY2VzOiAxXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZGVudGlmaWVycy5wdXNoKGlkZW50aWZpZXIpO1xuICB9XG5cbiAgcmV0dXJuIGlkZW50aWZpZXJzO1xufVxuXG5mdW5jdGlvbiBpbnNlcnRTdHlsZUVsZW1lbnQob3B0aW9ucykge1xuICB2YXIgc3R5bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdHlsZScpO1xuICB2YXIgYXR0cmlidXRlcyA9IG9wdGlvbnMuYXR0cmlidXRlcyB8fCB7fTtcblxuICBpZiAodHlwZW9mIGF0dHJpYnV0ZXMubm9uY2UgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgdmFyIG5vbmNlID0gdHlwZW9mIF9fd2VicGFja19ub25jZV9fICE9PSAndW5kZWZpbmVkJyA/IF9fd2VicGFja19ub25jZV9fIDogbnVsbDtcblxuICAgIGlmIChub25jZSkge1xuICAgICAgYXR0cmlidXRlcy5ub25jZSA9IG5vbmNlO1xuICAgIH1cbiAgfVxuXG4gIE9iamVjdC5rZXlzKGF0dHJpYnV0ZXMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgIHN0eWxlLnNldEF0dHJpYnV0ZShrZXksIGF0dHJpYnV0ZXNba2V5XSk7XG4gIH0pO1xuXG4gIGlmICh0eXBlb2Ygb3B0aW9ucy5pbnNlcnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICBvcHRpb25zLmluc2VydChzdHlsZSk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIHRhcmdldCA9IGdldFRhcmdldChvcHRpb25zLmluc2VydCB8fCAnaGVhZCcpO1xuXG4gICAgaWYgKCF0YXJnZXQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvdWxkbid0IGZpbmQgYSBzdHlsZSB0YXJnZXQuIFRoaXMgcHJvYmFibHkgbWVhbnMgdGhhdCB0aGUgdmFsdWUgZm9yIHRoZSAnaW5zZXJ0JyBwYXJhbWV0ZXIgaXMgaW52YWxpZC5cIik7XG4gICAgfVxuXG4gICAgdGFyZ2V0LmFwcGVuZENoaWxkKHN0eWxlKTtcbiAgfVxuXG4gIHJldHVybiBzdHlsZTtcbn1cblxuZnVuY3Rpb24gcmVtb3ZlU3R5bGVFbGVtZW50KHN0eWxlKSB7XG4gIC8vIGlzdGFuYnVsIGlnbm9yZSBpZlxuICBpZiAoc3R5bGUucGFyZW50Tm9kZSA9PT0gbnVsbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHN0eWxlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc3R5bGUpO1xufVxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgICovXG5cblxudmFyIHJlcGxhY2VUZXh0ID0gZnVuY3Rpb24gcmVwbGFjZVRleHQoKSB7XG4gIHZhciB0ZXh0U3RvcmUgPSBbXTtcbiAgcmV0dXJuIGZ1bmN0aW9uIHJlcGxhY2UoaW5kZXgsIHJlcGxhY2VtZW50KSB7XG4gICAgdGV4dFN0b3JlW2luZGV4XSA9IHJlcGxhY2VtZW50O1xuICAgIHJldHVybiB0ZXh0U3RvcmUuZmlsdGVyKEJvb2xlYW4pLmpvaW4oJ1xcbicpO1xuICB9O1xufSgpO1xuXG5mdW5jdGlvbiBhcHBseVRvU2luZ2xldG9uVGFnKHN0eWxlLCBpbmRleCwgcmVtb3ZlLCBvYmopIHtcbiAgdmFyIGNzcyA9IHJlbW92ZSA/ICcnIDogb2JqLm1lZGlhID8gXCJAbWVkaWEgXCIuY29uY2F0KG9iai5tZWRpYSwgXCIge1wiKS5jb25jYXQob2JqLmNzcywgXCJ9XCIpIDogb2JqLmNzczsgLy8gRm9yIG9sZCBJRVxuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAgKi9cblxuICBpZiAoc3R5bGUuc3R5bGVTaGVldCkge1xuICAgIHN0eWxlLnN0eWxlU2hlZXQuY3NzVGV4dCA9IHJlcGxhY2VUZXh0KGluZGV4LCBjc3MpO1xuICB9IGVsc2Uge1xuICAgIHZhciBjc3NOb2RlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY3NzKTtcbiAgICB2YXIgY2hpbGROb2RlcyA9IHN0eWxlLmNoaWxkTm9kZXM7XG5cbiAgICBpZiAoY2hpbGROb2Rlc1tpbmRleF0pIHtcbiAgICAgIHN0eWxlLnJlbW92ZUNoaWxkKGNoaWxkTm9kZXNbaW5kZXhdKTtcbiAgICB9XG5cbiAgICBpZiAoY2hpbGROb2Rlcy5sZW5ndGgpIHtcbiAgICAgIHN0eWxlLmluc2VydEJlZm9yZShjc3NOb2RlLCBjaGlsZE5vZGVzW2luZGV4XSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0eWxlLmFwcGVuZENoaWxkKGNzc05vZGUpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBhcHBseVRvVGFnKHN0eWxlLCBvcHRpb25zLCBvYmopIHtcbiAgdmFyIGNzcyA9IG9iai5jc3M7XG4gIHZhciBtZWRpYSA9IG9iai5tZWRpYTtcbiAgdmFyIHNvdXJjZU1hcCA9IG9iai5zb3VyY2VNYXA7XG5cbiAgaWYgKG1lZGlhKSB7XG4gICAgc3R5bGUuc2V0QXR0cmlidXRlKCdtZWRpYScsIG1lZGlhKTtcbiAgfSBlbHNlIHtcbiAgICBzdHlsZS5yZW1vdmVBdHRyaWJ1dGUoJ21lZGlhJyk7XG4gIH1cblxuICBpZiAoc291cmNlTWFwICYmIHR5cGVvZiBidG9hICE9PSAndW5kZWZpbmVkJykge1xuICAgIGNzcyArPSBcIlxcbi8qIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsXCIuY29uY2F0KGJ0b2EodW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KEpTT04uc3RyaW5naWZ5KHNvdXJjZU1hcCkpKSksIFwiICovXCIpO1xuICB9IC8vIEZvciBvbGQgSUVcblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgICovXG5cblxuICBpZiAoc3R5bGUuc3R5bGVTaGVldCkge1xuICAgIHN0eWxlLnN0eWxlU2hlZXQuY3NzVGV4dCA9IGNzcztcbiAgfSBlbHNlIHtcbiAgICB3aGlsZSAoc3R5bGUuZmlyc3RDaGlsZCkge1xuICAgICAgc3R5bGUucmVtb3ZlQ2hpbGQoc3R5bGUuZmlyc3RDaGlsZCk7XG4gICAgfVxuXG4gICAgc3R5bGUuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY3NzKSk7XG4gIH1cbn1cblxudmFyIHNpbmdsZXRvbiA9IG51bGw7XG52YXIgc2luZ2xldG9uQ291bnRlciA9IDA7XG5cbmZ1bmN0aW9uIGFkZFN0eWxlKG9iaiwgb3B0aW9ucykge1xuICB2YXIgc3R5bGU7XG4gIHZhciB1cGRhdGU7XG4gIHZhciByZW1vdmU7XG5cbiAgaWYgKG9wdGlvbnMuc2luZ2xldG9uKSB7XG4gICAgdmFyIHN0eWxlSW5kZXggPSBzaW5nbGV0b25Db3VudGVyKys7XG4gICAgc3R5bGUgPSBzaW5nbGV0b24gfHwgKHNpbmdsZXRvbiA9IGluc2VydFN0eWxlRWxlbWVudChvcHRpb25zKSk7XG4gICAgdXBkYXRlID0gYXBwbHlUb1NpbmdsZXRvblRhZy5iaW5kKG51bGwsIHN0eWxlLCBzdHlsZUluZGV4LCBmYWxzZSk7XG4gICAgcmVtb3ZlID0gYXBwbHlUb1NpbmdsZXRvblRhZy5iaW5kKG51bGwsIHN0eWxlLCBzdHlsZUluZGV4LCB0cnVlKTtcbiAgfSBlbHNlIHtcbiAgICBzdHlsZSA9IGluc2VydFN0eWxlRWxlbWVudChvcHRpb25zKTtcbiAgICB1cGRhdGUgPSBhcHBseVRvVGFnLmJpbmQobnVsbCwgc3R5bGUsIG9wdGlvbnMpO1xuXG4gICAgcmVtb3ZlID0gZnVuY3Rpb24gcmVtb3ZlKCkge1xuICAgICAgcmVtb3ZlU3R5bGVFbGVtZW50KHN0eWxlKTtcbiAgICB9O1xuICB9XG5cbiAgdXBkYXRlKG9iaik7XG4gIHJldHVybiBmdW5jdGlvbiB1cGRhdGVTdHlsZShuZXdPYmopIHtcbiAgICBpZiAobmV3T2JqKSB7XG4gICAgICBpZiAobmV3T2JqLmNzcyA9PT0gb2JqLmNzcyAmJiBuZXdPYmoubWVkaWEgPT09IG9iai5tZWRpYSAmJiBuZXdPYmouc291cmNlTWFwID09PSBvYmouc291cmNlTWFwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdXBkYXRlKG9iaiA9IG5ld09iaik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlbW92ZSgpO1xuICAgIH1cbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAobGlzdCwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTsgLy8gRm9yY2Ugc2luZ2xlLXRhZyBzb2x1dGlvbiBvbiBJRTYtOSwgd2hpY2ggaGFzIGEgaGFyZCBsaW1pdCBvbiB0aGUgIyBvZiA8c3R5bGU+XG4gIC8vIHRhZ3MgaXQgd2lsbCBhbGxvdyBvbiBhIHBhZ2VcblxuICBpZiAoIW9wdGlvbnMuc2luZ2xldG9uICYmIHR5cGVvZiBvcHRpb25zLnNpbmdsZXRvbiAhPT0gJ2Jvb2xlYW4nKSB7XG4gICAgb3B0aW9ucy5zaW5nbGV0b24gPSBpc09sZElFKCk7XG4gIH1cblxuICBsaXN0ID0gbGlzdCB8fCBbXTtcbiAgdmFyIGxhc3RJZGVudGlmaWVycyA9IG1vZHVsZXNUb0RvbShsaXN0LCBvcHRpb25zKTtcbiAgcmV0dXJuIGZ1bmN0aW9uIHVwZGF0ZShuZXdMaXN0KSB7XG4gICAgbmV3TGlzdCA9IG5ld0xpc3QgfHwgW107XG5cbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG5ld0xpc3QpICE9PSAnW29iamVjdCBBcnJheV0nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsYXN0SWRlbnRpZmllcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBpZGVudGlmaWVyID0gbGFzdElkZW50aWZpZXJzW2ldO1xuICAgICAgdmFyIGluZGV4ID0gZ2V0SW5kZXhCeUlkZW50aWZpZXIoaWRlbnRpZmllcik7XG4gICAgICBzdHlsZXNJbkRvbVtpbmRleF0ucmVmZXJlbmNlcy0tO1xuICAgIH1cblxuICAgIHZhciBuZXdMYXN0SWRlbnRpZmllcnMgPSBtb2R1bGVzVG9Eb20obmV3TGlzdCwgb3B0aW9ucyk7XG5cbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgbGFzdElkZW50aWZpZXJzLmxlbmd0aDsgX2krKykge1xuICAgICAgdmFyIF9pZGVudGlmaWVyID0gbGFzdElkZW50aWZpZXJzW19pXTtcblxuICAgICAgdmFyIF9pbmRleCA9IGdldEluZGV4QnlJZGVudGlmaWVyKF9pZGVudGlmaWVyKTtcblxuICAgICAgaWYgKHN0eWxlc0luRG9tW19pbmRleF0ucmVmZXJlbmNlcyA9PT0gMCkge1xuICAgICAgICBzdHlsZXNJbkRvbVtfaW5kZXhdLnVwZGF0ZXIoKTtcblxuICAgICAgICBzdHlsZXNJbkRvbS5zcGxpY2UoX2luZGV4LCAxKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBsYXN0SWRlbnRpZmllcnMgPSBuZXdMYXN0SWRlbnRpZmllcnM7XG4gIH07XG59OyIsIid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcblxuZnVuY3Rpb24gdXNlQXN5bmNFZmZlY3QoZWZmZWN0LCBkZXN0cm95LCBpbnB1dHMpIHtcbiAgdmFyIGhhc0Rlc3Ryb3kgPSB0eXBlb2YgZGVzdHJveSA9PT0gJ2Z1bmN0aW9uJztcblxuICBSZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgIHZhciByZXN1bHQ7XG4gICAgdmFyIG1vdW50ZWQgPSB0cnVlO1xuICAgIHZhciBtYXliZVByb21pc2UgPSBlZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIG1vdW50ZWQ7XG4gICAgfSk7XG5cbiAgICBQcm9taXNlLnJlc29sdmUobWF5YmVQcm9taXNlKS50aGVuKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgcmVzdWx0ID0gdmFsdWU7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgbW91bnRlZCA9IGZhbHNlO1xuXG4gICAgICBpZiAoaGFzRGVzdHJveSkge1xuICAgICAgICBkZXN0cm95KHJlc3VsdCk7XG4gICAgICB9XG4gICAgfTtcbiAgfSwgaGFzRGVzdHJveSA/IGlucHV0cyA6IGRlc3Ryb3kpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHVzZUFzeW5jRWZmZWN0O1xubW9kdWxlLmV4cG9ydHMudXNlQXN5bmNFZmZlY3QgPSB1c2VBc3luY0VmZmVjdDtcbiIsInZhciBhcGkgPSByZXF1aXJlKFwiIS4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL2luamVjdFN0eWxlc0ludG9TdHlsZVRhZy5qc1wiKTtcbiAgICAgICAgICAgIHZhciBjb250ZW50ID0gcmVxdWlyZShcIiEhLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9janMuanM/P3J1bGVTZXRbMV0ucnVsZXNbMl0udXNlWzFdIS4uL25vZGVfbW9kdWxlcy9wb3N0Y3NzLWxvYWRlci9zcmMvaW5kZXguanM/P3J1bGVTZXRbMV0ucnVsZXNbMl0udXNlWzJdIS4vc3R5bGUuY3NzXCIpO1xuXG4gICAgICAgICAgICBjb250ZW50ID0gY29udGVudC5fX2VzTW9kdWxlID8gY29udGVudC5kZWZhdWx0IDogY29udGVudDtcblxuICAgICAgICAgICAgaWYgKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG4gICAgICAgICAgICB9XG5cbnZhciBvcHRpb25zID0ge307XG5cbm9wdGlvbnMuaW5zZXJ0ID0gXCJoZWFkXCI7XG5vcHRpb25zLnNpbmdsZXRvbiA9IGZhbHNlO1xuXG52YXIgdXBkYXRlID0gYXBpKGNvbnRlbnQsIG9wdGlvbnMpO1xuXG5cblxubW9kdWxlLmV4cG9ydHMgPSBjb250ZW50LmxvY2FscyB8fCB7fTsiLCIvLyBUaGUgbW9kdWxlIGNhY2hlXG52YXIgX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fID0ge307XG5cbi8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG5mdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuXHR2YXIgY2FjaGVkTW9kdWxlID0gX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXTtcblx0aWYgKGNhY2hlZE1vZHVsZSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0cmV0dXJuIGNhY2hlZE1vZHVsZS5leHBvcnRzO1xuXHR9XG5cdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG5cdHZhciBtb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdID0ge1xuXHRcdGlkOiBtb2R1bGVJZCxcblx0XHQvLyBubyBtb2R1bGUubG9hZGVkIG5lZWRlZFxuXHRcdGV4cG9ydHM6IHt9XG5cdH07XG5cblx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG5cdF9fd2VicGFja19tb2R1bGVzX19bbW9kdWxlSWRdKG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG5cdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG5cdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbn1cblxuIiwiLy8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbl9fd2VicGFja19yZXF1aXJlX18ubiA9IChtb2R1bGUpID0+IHtcblx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG5cdFx0KCkgPT4gKG1vZHVsZVsnZGVmYXVsdCddKSA6XG5cdFx0KCkgPT4gKG1vZHVsZSk7XG5cdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsIHsgYTogZ2V0dGVyIH0pO1xuXHRyZXR1cm4gZ2V0dGVyO1xufTsiLCIvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9ucyBmb3IgaGFybW9ueSBleHBvcnRzXG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSAoZXhwb3J0cywgZGVmaW5pdGlvbikgPT4ge1xuXHRmb3IodmFyIGtleSBpbiBkZWZpbml0aW9uKSB7XG5cdFx0aWYoX193ZWJwYWNrX3JlcXVpcmVfXy5vKGRlZmluaXRpb24sIGtleSkgJiYgIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBrZXkpKSB7XG5cdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZGVmaW5pdGlvbltrZXldIH0pO1xuXHRcdH1cblx0fVxufTsiLCJfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSAob2JqLCBwcm9wKSA9PiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCkpIiwiLy8gZGVmaW5lIF9fZXNNb2R1bGUgb24gZXhwb3J0c1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yID0gKGV4cG9ydHMpID0+IHtcblx0aWYodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnRvU3RyaW5nVGFnKSB7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogJ01vZHVsZScgfSk7XG5cdH1cblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbn07IiwiaW1wb3J0IHsgUmFpbndheVJ1bnRpbWUgfSBmcm9tIFwicmFpbndheS1zZGtcIjtcbmltcG9ydCBSZWFjdCwgeyB1c2VFZmZlY3QsIHVzZVJlZiwgdXNlU3RhdGUgfSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCBSZWFjdERPTSBmcm9tIFwicmVhY3QtZG9tXCI7XG5pbXBvcnQgXCIuLi9zdHlsZS5jc3NcIjtcbmltcG9ydCB1c2VBc3luY0VmZmVjdCBmcm9tIFwidXNlLWFzeW5jLWVmZmVjdFwiO1xuXG5jb25zdCBRdWlja0RlbW8gPSAoKSA9PiB7XG4gIGNvbnN0IFtydW50aW1lLCBzZXRSdW50aW1lXSA9IHVzZVN0YXRlPFJhaW53YXlSdW50aW1lIHwgdW5kZWZpbmVkPigpO1xuICBjb25zdCBbZXJyb3IsIHNldEVycm9yXSA9IHVzZVN0YXRlPHN0cmluZz4oXCJcIik7XG4gIHVzZUFzeW5jRWZmZWN0KGFzeW5jIChpc0FsaXZlKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJ0ID0gYXdhaXQgUmFpbndheVJ1bnRpbWUuaW5pdGlhbGl6ZSh7XG4gICAgICAgIGFwaUtleTpcbiAgICAgICAgICBuZXcgVVJMU2VhcmNoUGFyYW1zKHdpbmRvdy5sb2NhdGlvbi5zZWFyY2gpLmdldChcImFwaV9rZXlcIikgPz8gXCJcIixcbiAgICAgICAgZXh0ZXJuYWxJZDogXCJ3ZWItZGVtby1xdWlja1wiLFxuICAgICAgICBvblJ1bnRpbWVDb25uZWN0aW9uTG9zdDogKHJ0LCBlcnJvcikgPT4ge1xuICAgICAgICAgIHNldFJ1bnRpbWUodW5kZWZpbmVkKTtcbiAgICAgICAgfSxcbiAgICAgICAgb25Db25uZWN0aW9uUmVxdWVzdDogKHJ0LCByZXF1ZXN0KSA9PiB7XG4gICAgICAgICAgcmVxdWVzdC5hY2NlcHQoKTtcbiAgICAgICAgfSxcbiAgICAgICAgb25QZWVyTWVzc2FnZTogKCkgPT4ge30sXG4gICAgICAgIG9uUGVlckRhdGFDaGFubmVsOiAoKSA9PiB7fSxcbiAgICAgICAgb25QZWVyRXJyb3I6IChydCwgcGVlciwgZXJyb3IpID0+IHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oXCJvblBlZXJFcnJvclwiLCBwZWVyLCBlcnJvcik7XG4gICAgICAgIH0sXG4gICAgICAgIG9uUGVlclN0YXRlQ2hhbmdlOiAocnQsIHBlZXIsIHN0YXRlKSA9PiB7XG4gICAgICAgICAgY29uc29sZS5sb2coYFBlZXIgJHtwZWVyLnBlZXJJZH0gY2hhbmdlZCBzdGF0ZXMgdG8gJHtzdGF0ZX1gKTtcbiAgICAgICAgfSxcbiAgICAgICAgb25TdHJlYW1Bbm5vdW5jZW1lbnQ6ICgpID0+IHt9LFxuICAgICAgICBvblN0cmVhbVN0b3A6ICgpID0+IHt9LFxuICAgICAgICBsb2dTaW5rOiAoKSA9PiB7fSxcbiAgICAgIH0pO1xuICAgICAgaWYgKCFpc0FsaXZlKCkpIHJldHVybjtcbiAgICAgIHNldFJ1bnRpbWUocnQpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHNldEVycm9yKChlIGFzIEVycm9yKS5tZXNzYWdlKTtcbiAgICAgIGNvbnNvbGUubG9nKGUpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiAoXG4gICAgPG1haW4gY2xhc3NOYW1lPVwibS10LTggbS1sLTggbS1yLTggbS1iLThcIj5cbiAgICAgIHtlcnJvciA/IGVycm9yIDogcnVudGltZSA/IFwiQ29ubmVjdGVkLlwiIDogXCJDb25uZWN0aW5n4oCmXCJ9XG4gICAgPC9tYWluPlxuICApO1xufTtcblxuUmVhY3RET00ucmVuZGVyKFxuICA8UmVhY3QuU3RyaWN0TW9kZT5cbiAgICA8UXVpY2tEZW1vIC8+XG4gIDwvUmVhY3QuU3RyaWN0TW9kZT4sXG4gIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwicmVhY3Qtcm9vdFwiKSxcbik7XG4iXSwic291cmNlUm9vdCI6IiJ9