/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[2].use[1]!./node_modules/postcss-loader/src/index.js??ruleSet[1].rules[2].use[2]!./src/style.css":
/*!****************************************************************************************************************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[2].use[1]!./node_modules/postcss-loader/src/index.js??ruleSet[1].rules[2].use[2]!./src/style.css ***!
  \****************************************************************************************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

// Imports
var ___CSS_LOADER_API_IMPORT___ = __webpack_require__(/*! ../node_modules/css-loader/dist/runtime/api.js */ "./node_modules/css-loader/dist/runtime/api.js");
exports = ___CSS_LOADER_API_IMPORT___(false);
exports.push([module.id, "@import url(https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=Questrial&family=Poppins:wght@400;500;600&family=Barlow:wght@400;500;600;700&display=swap);"]);
// Module
exports.push([module.id, ":root {\n  --logo-font-family: \"Poppins\", sans-serif;\n  --body-font-family: \"Inter\", sans-serif;\n  --heading-font-family: \"Poppins\", sans-serif;\n  --header-font-family: \"Questrial\", sans-serif;\n\n  /* Slate Blue */\n  --clr-primary-100: #e0e2f4;\n  --clr-primary-200: #bfc3ec;\n  --clr-primary-300: #9fa7e2;\n  --clr-primary-400: #7e89d8;\n  --clr-primary-500: #616acb;\n  --clr-primary-600: #4854bb;\n  --clr-primary-700: #3943a2;\n  --clr-primary-800: #2f3885;\n  --clr-primary-900: #242b67;\n  --clr-primary-950: #191e4d;\n  --clr-primary-975: #0f122e;\n  --clr-primary-999: #05060f;\n\n  /* Mantis */\n  --clr-green-100: #f4fbf0;\n  --clr-green-200: #dff1d2;\n  --clr-green-300: #bfe2a6;\n  --clr-green-400: #a0d57b;\n  --clr-green-500: #8ccc61;\n  --clr-green-600: #6fad45;\n  --clr-green-700: #5b8d38;\n  --clr-green-800: #33571c;\n  --clr-green-900: #1e2f12;\n\n  /* Dandelion */\n  --clr-yellow-100: #fffdf1;\n  --clr-yellow-200: #fdf7db;\n  --clr-yellow-300: #faedb7;\n  --clr-yellow-400: #f7e695;\n  --clr-yellow-500: #f9dc5c;\n  --clr-yellow-600: #e5c343;\n  --clr-yellow-700: #9f8004;\n  --clr-yellow-800: #504102;\n  --clr-yellow-900: #282001;\n\n  /* Tomato */\n  --clr-red-100: #fff5f3;\n  --clr-red-200: #fbded8;\n  --clr-red-300: #f0b5a9;\n  --clr-red-400: #fa927b;\n  --clr-red-500: #fc6948;\n  --clr-red-600: #e9502f;\n  --clr-red-700: #cb3413;\n  --clr-red-800: #a30303;\n  --clr-red-900: #5c1111;\n\n  /* Neutrals */\n  --clr-neutral-0: #ffffff;\n  --clr-neutral-50: #f4f4f6;\n  --clr-neutral-100: #e9e9ec;\n  --clr-neutral-200: #d3d3d9;\n  --clr-neutral-300: #b3b3bc;\n  --clr-neutral-400: #9d9da9;\n  --clr-neutral-450: #868695;\n  --clr-neutral-500: #686877;\n  --clr-neutral-600: #5f5f6c;\n  --clr-neutral-700: #4c4c56;\n  --clr-neutral-800: #393941;\n  --clr-neutral-850: #2c2c33;\n  --clr-neutral-900: #26262c;\n  --clr-neutral-925: #1e1e23;\n  --clr-neutral-950: #131316;\n  --clr-neutral-975: #09090b;\n  --clr-neutral-990: #040405;\n  --clr-neutral-1000: #000000;\n}\n\n.spacer {\n  flex-grow: 1;\n}\n\n/** Margin and Padding helpers */\n.m-t-0 {\n  margin-top: 0px !important;\n}\n.p-t-0 {\n  padding-top: 0px !important;\n}\n.m-b-0 {\n  margin-bottom: 0px !important;\n}\n.p-b-0 {\n  padding-bottom: 0px !important;\n}\n.m-l-0 {\n  margin-left: 0px !important;\n}\n.p-l-0 {\n  padding-left: 0px !important;\n}\n.m-r-0 {\n  margin-right: 0px !important;\n}\n.p-r-0 {\n  padding-right: 0px !important;\n}\n.m-t-4 {\n  margin-top: 4px !important;\n}\n.p-t-4 {\n  padding-top: 4px !important;\n}\n.m-b-4 {\n  margin-bottom: 4px !important;\n}\n.p-b-4 {\n  padding-bottom: 4px !important;\n}\n.m-l-4 {\n  margin-left: 4px !important;\n}\n.p-l-4 {\n  padding-left: 4px !important;\n}\n.m-r-4 {\n  margin-right: 4px !important;\n}\n.p-r-4 {\n  padding-right: 4px !important;\n}\n.m-t-8 {\n  margin-top: 8px !important;\n}\n.p-t-8 {\n  padding-top: 8px !important;\n}\n.m-b-8 {\n  margin-bottom: 8px !important;\n}\n.p-b-8 {\n  padding-bottom: 8px !important;\n}\n.m-l-8 {\n  margin-left: 8px !important;\n}\n.p-l-8 {\n  padding-left: 8px !important;\n}\n.m-r-8 {\n  margin-right: 8px !important;\n}\n.p-r-8 {\n  padding-right: 8px !important;\n}\n.m-t-16 {\n  margin-top: 16px !important;\n}\n.p-t-16 {\n  padding-top: 16px !important;\n}\n.m-b-16 {\n  margin-bottom: 16px !important;\n}\n.p-b-16 {\n  padding-bottom: 16px !important;\n}\n.m-l-16 {\n  margin-left: 16px !important;\n}\n.p-l-16 {\n  padding-left: 16px !important;\n}\n.m-r-16 {\n  margin-right: 16px !important;\n}\n.p-r-16 {\n  padding-right: 16px !important;\n}\n.m-t-24 {\n  margin-top: 24px !important;\n}\n.p-t-24 {\n  padding-top: 24px !important;\n}\n.m-b-24 {\n  margin-bottom: 24px !important;\n}\n.p-b-24 {\n  padding-bottom: 24px !important;\n}\n.m-l-24 {\n  margin-left: 24px !important;\n}\n.p-l-24 {\n  padding-left: 24px !important;\n}\n.m-r-24 {\n  margin-right: 24px !important;\n}\n.p-r-24 {\n  padding-right: 24px !important;\n}\n.m-t-32 {\n  margin-top: 32px !important;\n}\n.p-t-32 {\n  padding-top: 32px !important;\n}\n.m-b-32 {\n  margin-bottom: 32px !important;\n}\n.p-b-32 {\n  padding-bottom: 32px !important;\n}\n.m-l-32 {\n  margin-left: 32px !important;\n}\n.p-l-32 {\n  padding-left: 32px !important;\n}\n.m-r-32 {\n  margin-right: 32px !important;\n}\n.p-r-32 {\n  padding-right: 32px !important;\n}\n.m-t-40 {\n  margin-top: 40px !important;\n}\n.p-t-40 {\n  padding-top: 40px !important;\n}\n.m-b-40 {\n  margin-bottom: 40px !important;\n}\n.p-b-40 {\n  padding-bottom: 40px !important;\n}\n.m-l-40 {\n  margin-left: 40px !important;\n}\n.p-l-40 {\n  padding-left: 40px !important;\n}\n.m-r-40 {\n  margin-right: 40px !important;\n}\n.p-r-40 {\n  padding-right: 40px !important;\n}\n.m-t-48 {\n  margin-top: 48px !important;\n}\n.p-t-48 {\n  padding-top: 48px !important;\n}\n.m-b-48 {\n  margin-bottom: 48px !important;\n}\n.p-b-48 {\n  padding-bottom: 48px !important;\n}\n.m-l-48 {\n  margin-left: 48px !important;\n}\n.p-l-48 {\n  padding-left: 48px !important;\n}\n.m-r-48 {\n  margin-right: 48px !important;\n}\n.p-r-48 {\n  padding-right: 48px !important;\n}\n.m-t-56 {\n  margin-top: 56px !important;\n}\n.p-t-56 {\n  padding-top: 56px !important;\n}\n.m-b-56 {\n  margin-bottom: 56px !important;\n}\n.p-b-56 {\n  padding-bottom: 56px !important;\n}\n.m-l-56 {\n  margin-left: 56px !important;\n}\n.p-l-56 {\n  padding-left: 56px !important;\n}\n.m-r-56 {\n  margin-right: 56px !important;\n}\n.p-r-56 {\n  padding-right: 56px !important;\n}\n.m-t-64 {\n  margin-top: 64px !important;\n}\n.p-t-64 {\n  padding-top: 64px !important;\n}\n.m-b-64 {\n  margin-bottom: 64px !important;\n}\n.p-b-64 {\n  padding-bottom: 64px !important;\n}\n.m-l-64 {\n  margin-left: 64px !important;\n}\n.p-l-64 {\n  padding-left: 64px !important;\n}\n.m-r-64 {\n  margin-right: 64px !important;\n}\n.p-r-64 {\n  padding-right: 64px !important;\n}\n.m-t-72 {\n  margin-top: 72px !important;\n}\n.p-t-72 {\n  padding-top: 72px !important;\n}\n.m-b-72 {\n  margin-bottom: 72px !important;\n}\n.p-b-72 {\n  padding-bottom: 72px !important;\n}\n.m-l-72 {\n  margin-left: 72px !important;\n}\n.p-l-72 {\n  padding-left: 72px !important;\n}\n.m-r-72 {\n  margin-right: 72px !important;\n}\n.p-r-72 {\n  padding-right: 72px !important;\n}\n.m-t-80 {\n  margin-top: 80px !important;\n}\n.p-t-80 {\n  padding-top: 80px !important;\n}\n.m-b-80 {\n  margin-bottom: 80px !important;\n}\n.p-b-80 {\n  padding-bottom: 80px !important;\n}\n.m-l-80 {\n  margin-left: 80px !important;\n}\n.p-l-80 {\n  padding-left: 80px !important;\n}\n.m-r-80 {\n  margin-right: 80px !important;\n}\n.p-r-80 {\n  padding-right: 80px !important;\n}\n.m-t-120 {\n  margin-top: 120px !important;\n}\n.p-t-120 {\n  padding-top: 120px !important;\n}\n.m-b-120 {\n  margin-bottom: 120px !important;\n}\n.p-b-120 {\n  padding-bottom: 120px !important;\n}\n.m-l-120 {\n  margin-left: 120px !important;\n}\n.p-l-120 {\n  padding-left: 120px !important;\n}\n.m-r-120 {\n  margin-right: 120px !important;\n}\n.p-r-120 {\n  padding-right: 120px !important;\n}\n.m-t-160 {\n  margin-top: 160px !important;\n}\n.p-t-160 {\n  padding-top: 160px !important;\n}\n.m-b-160 {\n  margin-bottom: 160px !important;\n}\n.p-b-160 {\n  padding-bottom: 160px !important;\n}\n.m-l-160 {\n  margin-left: 160px !important;\n}\n.p-l-160 {\n  padding-left: 160px !important;\n}\n.m-r-160 {\n  margin-right: 160px !important;\n}\n.p-r-160 {\n  padding-right: 160px !important;\n}\n\n* {\n  margin: 0;\n  padding: 0;\n  box-sizing: border-box;\n}\n\nhtml {\n  background: #131316;\n  scroll-behavior: smooth;\n  color-scheme: dark;\n}\n\nbody {\n  font-family: var(--body-font-family);\n  font-size: 14px;\n  color: var(--clr-neutral-300);\n}\n\nheader {\n  padding: 24px 32px;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  background: #000000;\n  box-shadow: 0px 1px 0px rgba(255, 255, 255, 0.15);\n}\n\n.header-inner {\n  flex: 1;\n  display: flex;\n  align-items: center;\n  max-width: 1100px;\n}\n\n.build-notes {\n  flex: 1;\n  display: flex;\n  justify-content: flex-end;\n  align-items: center;\n}\n\n.build-note {\n  line-height: 1;\n  display: flex;\n  align-items: center;\n  color: var(--clr-neutral-450);\n}\n\n.build-note + .build-note {\n  margin-left: 16px;\n}\n\n.build-note > svg {\n  margin-right: 8px;\n}\n\nh1 {\n  font-family: var(--heading-font-family);\n  font-size: 20px;\n  font-weight: bold;\n  color: var(--clr-neutral-0);\n}\n\nh2 {\n  font-family: var(--heading-font-family);\n  font-size: 16px;\n  font-weight: 600;\n  color: var(--clr-neutral-50);\n}\n\nh3 {\n  font-family: var(--heading-font-family);\n  font-size: 16px;\n  font-weight: 500;\n  color: var(--clr-neutral-100);\n}\n\nbutton {\n  border: none;\n  color: var(--clr-neutral-50);\n  background: linear-gradient(90deg, #616acb 0%, #4854bb 100%);\n  border-radius: 4px;\n  font-family: var(--body-font-family);\n  font-size: 14px;\n  padding: 12px 18px;\n  cursor: pointer;\n}\n\nbutton.secondary {\n  border: 1px solid var(--clr-primary-500);\n  background: transparent;\n}\n\nbutton:disabled {\n  color: var(--clr-neutral-400);\n  background: var(--clr-neutral-850);\n  cursor: inherit;\n}\n\ninput {\n  font-size: 14px;\n}\n\ninput[type=\"text\"] {\n  font-family: var(--body-font-family);\n  background: var(--clr-neutral-950);\n  border: 1px solid var(--clr-neutral-850);\n  border-radius: 5px;\n  padding: 12px 16px;\n}\n\n.badge {\n  display: flex;\n  flex-direction: row;\n  justify-content: center;\n  align-items: center;\n  padding: 4px 8px;\n  font-size: 12px;\n  font-weight: 500;\n  border-radius: 24px;\n  background: var(--clr-neutral-900);\n  color: var(--clr-neutral-300);\n}\n\n.badge.ok {\n  background: var(--clr-primary-900);\n  color: var(--clr-primary-300);\n}\n\n.backdrop {\n  width: 100%;\n  height: 180px;\n  position: absolute;\n  z-index: -5;\n  pointer-events: none;\n  background: #000000;\n}\n\n.demo {\n  padding: 32px;\n  max-width: 1100px;\n  margin: auto;\n}\n\n.flex {\n  display: flex;\n  align-items: center;\n}\n\nsvg {\n  flex-shrink: 0;\n}\n\n.card {\n  background: var(--clr-neutral-925);\n  box-shadow: 0px 8px 50px rgba(0, 0, 0, 0.25);\n  border-radius: 8px;\n  padding: 24px;\n  margin: 24px 0;\n}\n\n.card-top {\n  display: flex;\n  align-items: center;\n  margin-bottom: 8px;\n}\n\n.card-top > * + * {\n  margin-left: 8px;\n}\n\n.widget-body {\n  display: flex;\n}\n\n.stream-column {\n  flex: 2;\n}\n\n.chat-column {\n  flex: 1;\n  display: flex;\n  flex-direction: column;\n}\n\n.chat-history {\n  flex: 1;\n}\n\n.chat-bottom {\n  display: flex;\n  position: relative;\n  align-items: center;\n}\n\n.chat-input {\n  flex: 1;\n}\n\nbutton.chat-send-button {\n  cursor: pointer;\n  background: none;\n  padding: 0;\n  margin: 0;\n  position: absolute;\n  right: 16px;\n  margin-top: auto;\n}\n\nbutton.chat-send-button:disabled {\n  cursor: inherit;\n  filter: grayscale();\n}\n.stream-selector {\n  display: flex;\n}\n\n.stream-selector > select {\n  margin-right: 8px;\n}\n\n.stream-wrapper {\n  border: 1px solid rgba(0, 0, 0, 0.4);\n  background-image: /* url(\"https://rainway.com/images/logo.svg\"), */\n    linear-gradient(-45deg, #141625, #241635);\n  background-repeat: no-repeat;\n  background-position: center;\n  width: 100%;\n  height: 393px;\n}\n\na {\n  color: var(--clr-primary-400);\n  font-weight: 600;\n  text-decoration: none;\n  transition: color 0.2s ease;\n}\n\na:hover {\n  color: var(--clr-neutral-50);\n}\n", ""]);
// Exports
module.exports = exports;


/***/ }),

/***/ "./node_modules/@rainway/web/dist/esm/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/@rainway/web/dist/esm/index.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AudioCodec": () => (/* binding */ hA),
/* harmony export */   "AudioContainer": () => (/* binding */ dA),
/* harmony export */   "ButtonAction": () => (/* binding */ K),
/* harmony export */   "DataChannelMode": () => (/* binding */ nI),
/* harmony export */   "InputLevel": () => (/* binding */ yA),
/* harmony export */   "InputType": () => (/* binding */ UI),
/* harmony export */   "LogLevel": () => (/* binding */ e),
/* harmony export */   "MouseButton": () => (/* binding */ q),
/* harmony export */   "PeerState": () => (/* binding */ i),
/* harmony export */   "PenFlags": () => (/* binding */ O),
/* harmony export */   "PenMask": () => (/* binding */ T),
/* harmony export */   "ScrollAxis": () => (/* binding */ Y),
/* harmony export */   "StreamFit": () => (/* binding */ dg),
/* harmony export */   "StreamType": () => (/* binding */ FA),
/* harmony export */   "TouchMask": () => (/* binding */ W),
/* harmony export */   "VideoCodecType": () => (/* binding */ tA),
/* harmony export */   "VideoContainer": () => (/* binding */ cA),
/* harmony export */   "VideoReadyState": () => (/* binding */ NI),
/* harmony export */   "VirtualKey": () => (/* binding */ b),
/* harmony export */   "WindowsPointerFlags": () => (/* binding */ P),
/* harmony export */   "XInputButtons": () => (/* binding */ J),
/* harmony export */   "default": () => (/* binding */ Pg)
/* harmony export */ });
/* harmony import */ var bebop__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! bebop */ "./node_modules/bebop/dist/index.js");
function g(A,I,g,B){if("a"===g&&!B)throw new TypeError("Private accessor was defined without a getter");if("function"==typeof I?A!==I||!B:!I.has(A))throw new TypeError("Cannot read private member from an object whose class did not declare it");return"m"===g?B:"a"===g?B.call(A):B?B.value:I.get(A)}function B(A,I,g,B,Q){if("m"===B)throw new TypeError("Private method is not writable");if("a"===B&&!Q)throw new TypeError("Private accessor was defined without a setter");if("function"==typeof I?A!==I||!Q:!I.has(A))throw new TypeError("Cannot write private member to an object whose class did not declare it");return"a"===B?Q.call(A,g):Q?Q.value=g:I.set(A,g),g}class Q extends Error{constructor(A){super(`Rainway SDK Error: ${A}`),this.name=this.constructor.name,"function"==typeof Error.captureStackTrace?Error.captureStackTrace(this,this.constructor):this.stack=new Error(`Rainway SDK Error: ${A}`).stack,Object.setPrototypeOf(this,Q.prototype)}}async function C(A,I){let g;try{g=await fetch("https://api.rainway.network/v1"+A,I)}catch{throw new Q("Could not connect to the Rainway API.")}if(!g.ok){let I;try{I=await g.json()}catch{I=void 0}if(422===g.status&&!1===I?.is_valid)throw new Q("The Rainway API key is invalid.");throw new Q(`Rainway API error: ${A} returned ${g.status}`)}return g}var e,i,t,E,o,a;!function(A){A[A.Silent=0]="Silent",A[A.Error=1]="Error",A[A.Warning=2]="Warning",A[A.Info=3]="Info",A[A.Debug=4]="Debug",A[A.Trace=5]="Trace"}(e||(e={})),function(A){A[A.New=0]="New",A[A.Connecting=1]="Connecting",A[A.Connected=2]="Connected",A[A.Disconnected=3]="Disconnected",A[A.Failed=4]="Failed"}(i||(i={})),function(A){A[A.Unknown=0]="Unknown",A[A.Warning=1]="Warning",A[A.Fatal=2]="Fatal"}(t||(t={})),function(A){A[A.CloseNotify=0]="CloseNotify",A[A.UnexpectedMessage=10]="UnexpectedMessage",A[A.RecordOverflow=20]="RecordOverflow",A[A.TicketValidationError=30]="TicketValidationError",A[A.AccessDenied=49]="AccessDenied",A[A.DecodeError=50]="DecodeError",A[A.DecryptError=51]="DecryptError",A[A.ProtocolVersion=70]="ProtocolVersion",A[A.InternalError=80]="InternalError",A[A.PeerGoneAway=90]="PeerGoneAway",A[A.CommitFailure=100]="CommitFailure",A[A.ResourceExpired=200]="ResourceExpired"}(E||(E={})),function(A){A[A.Invalid=0]="Invalid",A[A.SCTP=1]="SCTP",A[A.GUDP=2]="GUDP",A[A.Reserved=3]="Reserved"}(o||(o={})),function(A){A[A.Invalid=0]="Invalid",A[A.Offer=1]="Offer",A[A.Answer=2]="Answer",A[A.Candidate=3]="Candidate"}(a||(a={}));const s={encode(I){const g=bebop__WEBPACK_IMPORTED_MODULE_0__.BebopView.getInstance();return g.startWriting(),this.encodeInto(I,g),g.toArray()},encodeInto(A,I){const g=I.length;I.writeString(A.apiKey),I.writeInt64(A.id),I.writeString(A.externalId);return I.length-g},decode(I){const g=bebop__WEBPACK_IMPORTED_MODULE_0__.BebopView.getInstance();return g.startReading(I),this.readFrom(g)},readFrom(A){let I,g,B;return I=A.readString(),g=A.readInt64(),B=A.readString(),{apiKey:I,id:g,externalId:B}}},n={encode(I){const g=bebop__WEBPACK_IMPORTED_MODULE_0__.BebopView.getInstance();return g.startWriting(),this.encodeInto(I,g),g.toArray()},encodeInto(A,I){const g=I.length;I.writeUint32(A.syncKey);return I.length-g},decode(I){const g=bebop__WEBPACK_IMPORTED_MODULE_0__.BebopView.getInstance();return g.startReading(I),this.readFrom(g)},readFrom(A){let I;return I=A.readUint32(),{syncKey:I}}},r={encode(I){const g=bebop__WEBPACK_IMPORTED_MODULE_0__.BebopView.getInstance();return g.startWriting(),this.encodeInto(I,g),g.toArray()},encodeInto(A,I){const g=I.length;n.encodeInto(A.header,I),w.encodeInto(A.body,I);return I.length-g},decode(I){const g=bebop__WEBPACK_IMPORTED_MODULE_0__.BebopView.getInstance();return g.startReading(I),this.readFrom(g)},readFrom(A){let I,g;return I=n.readFrom(A),g=w.readFrom(A),{header:I,body:g}}},h={discriminator:1,encode(I){const g=bebop__WEBPACK_IMPORTED_MODULE_0__.BebopView.getInstance();return g.startWriting(),this.encodeInto(I,g),g.toArray()},encodeInto(A,I){const g=I.length;S.encodeInto(A.body,I);return I.length-g},decode(I){const g=bebop__WEBPACK_IMPORTED_MODULE_0__.BebopView.getInstance();return g.startReading(I),this.readFrom(g)},readFrom(A){let I;return I=S.readFrom(A),{body:I}}},d={discriminator:2,encode(I){const g=bebop__WEBPACK_IMPORTED_MODULE_0__.BebopView.getInstance();return g.startWriting(),this.encodeInto(I,g),g.toArray()},encodeInto(A,I){const g=I.length;G.encodeInto(A.body,I);return I.length-g},decode(I){const g=bebop__WEBPACK_IMPORTED_MODULE_0__.BebopView.getInstance();return g.startReading(I),this.readFrom(g)},readFrom(A){let I;return I=G.readFrom(A),{body:I}}},c={discriminator:3,encode(I){const g=bebop__WEBPACK_IMPORTED_MODULE_0__.BebopView.getInstance();return g.startWriting(),this.encodeInto(I,g),g.toArray()},encodeInto(A,I){const g=I.length;I.writeUint32(A.level),I.writeUint32(A.description);return I.length-g},decode(I){const g=bebop__WEBPACK_IMPORTED_MODULE_0__.BebopView.getInstance();return g.startReading(I),this.readFrom(g)},readFrom(A){let I,g;return I=A.readUint32(),g=A.readUint32(),{level:I,description:g}}},D={discriminator:4,encode(I){const g=bebop__WEBPACK_IMPORTED_MODULE_0__.BebopView.getInstance();return g.startWriting(),this.encodeInto(I,g),g.toArray()},encodeInto(A,I){const g=I.length;I.writeInt64(A.targetPeerId),U.encodeInto(A.body,I);return I.length-g},decode(I){const g=bebop__WEBPACK_IMPORTED_MODULE_0__.BebopView.getInstance();return g.startReading(I),this.readFrom(g)},readFrom(A){let I,g;return I=A.readInt64(),g=U.readFrom(A),{targetPeerId:I,body:g}}},w={encode(I){const g=bebop__WEBPACK_IMPORTED_MODULE_0__.BebopView.getInstance();return g.startWriting(),this.encodeInto(I,g),g.toArray()},encodeInto(A,I){const g=I.length,B=I.reserveMessageLength(),Q=I.length+1;switch(I.writeByte(A.discriminator),A.discriminator){case 1:h.encodeInto(A.value,I);break;case 2:d.encodeInto(A.value,I);break;case 3:c.encodeInto(A.value,I);break;case 4:D.encodeInto(A.value,I)}const C=I.length;I.fillMessageLength(B,C-Q);return I.length-g},decode(I){const g=bebop__WEBPACK_IMPORTED_MODULE_0__.BebopView.getInstance();return g.startReading(I),this.readFrom(g)},readFrom(A){const g=A.readMessageLength(),B=A.index+1+g;switch(A.readByte()){case 1:return{discriminator:1,value:h.readFrom(A)};case 2:return{discriminator:2,value:d.readFrom(A)};case 3:return{discriminator:3,value:c.readFrom(A)};case 4:return{discriminator:4,value:D.readFrom(A)};default:throw A.index=B,new bebop__WEBPACK_IMPORTED_MODULE_0__.BebopRuntimeError("Unrecognized discriminator while decoding GatewayBody")}}},F={discriminator:1,encode(I){const g=bebop__WEBPACK_IMPORTED_MODULE_0__.BebopView.getInstance();return g.startWriting(),this.encodeInto(I,g),g.toArray()},encodeInto(A,I){const g=I.length;I.writeInt64(A.targetPeerId),I.writeUint32(A.desiredTransport);return I.length-g},decode(I){const g=bebop__WEBPACK_IMPORTED_MODULE_0__.BebopView.getInstance();return g.startReading(I),this.readFrom(g)},readFrom(A){let I,g;return I=A.readInt64(),g=A.readUint32(),{targetPeerId:I,desiredTransport:g}}},S={encode(I){const g=bebop__WEBPACK_IMPORTED_MODULE_0__.BebopView.getInstance();return g.startWriting(),this.encodeInto(I,g),g.toArray()},encodeInto(A,I){const g=I.length,B=I.reserveMessageLength(),Q=I.length+1;if(I.writeByte(A.discriminator),1===A.discriminator)F.encodeInto(A.value,I);const C=I.length;I.fillMessageLength(B,C-Q);return I.length-g},decode(I){const g=bebop__WEBPACK_IMPORTED_MODULE_0__.BebopView.getInstance();return g.startReading(I),this.readFrom(g)},readFrom(A){const g=A.readMessageLength(),B=A.index+1+g;if(1===A.readByte())return{discriminator:1,value:F.readFrom(A)};throw A.index=B,new bebop__WEBPACK_IMPORTED_MODULE_0__.BebopRuntimeError("Unrecognized discriminator while decoding GatewayRequestBody")}},y={discriminator:1,encode(I){const g=bebop__WEBPACK_IMPORTED_MODULE_0__.BebopView.getInstance();return g.startWriting(),this.encodeInto(I,g),g.toArray()},encodeInto(A,I){const g=I.length;return I.length-g},decode(I){const g=bebop__WEBPACK_IMPORTED_MODULE_0__.BebopView.getInstance();return g.startReading(I),this.readFrom(g)},readFrom:A=>({})},G={encode(I){const g=bebop__WEBPACK_IMPORTED_MODULE_0__.BebopView.getInstance();return g.startWriting(),this.encodeInto(I,g),g.toArray()},encodeInto(A,I){const g=I.length,B=I.reserveMessageLength(),Q=I.length+1;if(I.writeByte(A.discriminator),1===A.discriminator)y.encodeInto(A.value,I);const C=I.length;I.fillMessageLength(B,C-Q);return I.length-g},decode(I){const g=bebop__WEBPACK_IMPORTED_MODULE_0__.BebopView.getInstance();return g.startReading(I),this.readFrom(g)},readFrom(A){const g=A.readMessageLength(),B=A.index+1+g;if(1===A.readByte())return{discriminator:1,value:y.readFrom(A)};throw A.index=B,new bebop__WEBPACK_IMPORTED_MODULE_0__.BebopRuntimeError("Unrecognized discriminator while decoding GatewayResponseBody")}},R={discriminator:1,encode(I){const g=bebop__WEBPACK_IMPORTED_MODULE_0__.BebopView.getInstance();return g.startWriting(),this.encodeInto(I,g),g.toArray()},encodeInto(A,I){const g=I.length;I.writeInt64(A.sourcePeerId),I.writeString(A.sourceExternalId),I.writeUint32(A.desiredTransport),I.writeGuid(A.id),I.writeDate(A.expirationDate);return I.length-g},decode(I){const g=bebop__WEBPACK_IMPORTED_MODULE_0__.BebopView.getInstance();return g.startReading(I),this.readFrom(g)},readFrom(A){let I,g,B,Q,C;return I=A.readInt64(),g=A.readString(),B=A.readUint32(),Q=A.readGuid(),C=A.readDate(),{sourcePeerId:I,sourceExternalId:g,desiredTransport:B,id:Q,expirationDate:C}}},u={discriminator:2,encode(I){const g=bebop__WEBPACK_IMPORTED_MODULE_0__.BebopView.getInstance();return g.startWriting(),this.encodeInto(I,g),g.toArray()},encodeInto(A,I){const g=I.length;I.writeInt64(A.sourcePeerId),I.writeString(A.sourceExternalId),I.writeGuid(A.id);return I.length-g},decode(I){const g=bebop__WEBPACK_IMPORTED_MODULE_0__.BebopView.getInstance();return g.startReading(I),this.readFrom(g)},readFrom(A){let I,g,B;return I=A.readInt64(),g=A.readString(),B=A.readGuid(),{sourcePeerId:I,sourceExternalId:g,id:B}}},l={discriminator:3,encode(I){const g=bebop__WEBPACK_IMPORTED_MODULE_0__.BebopView.getInstance();return g.startWriting(),this.encodeInto(I,g),g.toArray()},encodeInto(A,I){const g=I.length;I.writeInt64(A.sourcePeerId),I.writeString(A.sourceExternalId),I.writeGuid(A.id),I.writeString(A.reason);return I.length-g},decode(I){const g=bebop__WEBPACK_IMPORTED_MODULE_0__.BebopView.getInstance();return g.startReading(I),this.readFrom(g)},readFrom(A){let I,g,B,Q;return I=A.readInt64(),g=A.readString(),B=A.readGuid(),Q=A.readString(),{sourcePeerId:I,sourceExternalId:g,id:B,reason:Q}}},k={discriminator:4,encode(I){const g=bebop__WEBPACK_IMPORTED_MODULE_0__.BebopView.getInstance();return g.startWriting(),this.encodeInto(I,g),g.toArray()},encodeInto(A,I){const g=I.length;I.writeGuid(A.id),I.writeUint32(A.type),I.writeString(A.data);return I.length-g},decode(I){const g=bebop__WEBPACK_IMPORTED_MODULE_0__.BebopView.getInstance();return g.startReading(I),this.readFrom(g)},readFrom(A){let I,g,B;return I=A.readGuid(),g=A.readUint32(),B=A.readString(),{id:I,type:g,data:B}}},U={encode(I){const g=bebop__WEBPACK_IMPORTED_MODULE_0__.BebopView.getInstance();return g.startWriting(),this.encodeInto(I,g),g.toArray()},encodeInto(A,I){const g=I.length,B=I.reserveMessageLength(),Q=I.length+1;switch(I.writeByte(A.discriminator),A.discriminator){case 1:R.encodeInto(A.value,I);break;case 2:u.encodeInto(A.value,I);break;case 3:l.encodeInto(A.value,I);break;case 4:k.encodeInto(A.value,I)}const C=I.length;I.fillMessageLength(B,C-Q);return I.length-g},decode(I){const g=bebop__WEBPACK_IMPORTED_MODULE_0__.BebopView.getInstance();return g.startReading(I),this.readFrom(g)},readFrom(A){const g=A.readMessageLength(),B=A.index+1+g;switch(A.readByte()){case 1:return{discriminator:1,value:R.readFrom(A)};case 2:return{discriminator:2,value:u.readFrom(A)};case 3:return{discriminator:3,value:l.readFrom(A)};case 4:return{discriminator:4,value:k.readFrom(A)};default:throw A.index=B,new bebop__WEBPACK_IMPORTED_MODULE_0__.BebopRuntimeError("Unrecognized discriminator while decoding GatewayForwardableBody")}}};var N;!function(A){A[A.Double=0]="Double",A[A.BigInt=1]="BigInt",A[A.VarChar=2]="VarChar",A[A.Bool=3]="Bool"}(N||(N={}));const m={encode(I){const g=bebop__WEBPACK_IMPORTED_MODULE_0__.BebopView.getInstance();return g.startWriting(),this.encodeInto(I,g),g.toArray()},encodeInto(A,I){const g=I.length;I.writeUint32(A.magicNumber),I.writeUint32(A.syncKey),I.writeInt64(A.sourcePeerId),I.writeInt64(A.targetPeerId);return I.length-g},decode(I){const g=bebop__WEBPACK_IMPORTED_MODULE_0__.BebopView.getInstance();return g.startReading(I),this.readFrom(g)},readFrom(A){let I,g,B,Q;return I=A.readUint32(),g=A.readUint32(),B=A.readInt64(),Q=A.readInt64(),{magicNumber:I,syncKey:g,sourcePeerId:B,targetPeerId:Q}}},M={encode(I){const g=bebop__WEBPACK_IMPORTED_MODULE_0__.BebopView.getInstance();return g.startWriting(),this.encodeInto(I,g),g.toArray()},encodeInto(A,I){const g=I.length;I.writeUint16(A.groupId),I.writeByte(A.index),I.writeByte(A.chunksInGroup),I.writeBytes(A.data);return I.length-g},decode(I){const g=bebop__WEBPACK_IMPORTED_MODULE_0__.BebopView.getInstance();return g.startReading(I),this.readFrom(g)},readFrom(A){let I,g,B,Q;return I=A.readUint16(),g=A.readByte(),B=A.readByte(),Q=A.readBytes(),{groupId:I,index:g,chunksInGroup:B,data:Q}}},L={encode(I){const g=bebop__WEBPACK_IMPORTED_MODULE_0__.BebopView.getInstance();return g.startWriting(),this.encodeInto(I,g),g.toArray()},encodeInto(A,I){const g=I.length;m.encodeInto(A.header,I),iA.encodeInto(A.body,I);return I.length-g},decode(I){const g=bebop__WEBPACK_IMPORTED_MODULE_0__.BebopView.getInstance();return g.startReading(I),this.readFrom(g)},readFrom(A){let I,g;return I=m.readFrom(A),g=iA.readFrom(A),{header:I,body:g}}},f={encode(I){const g=bebop__WEBPACK_IMPORTED_MODULE_0__.BebopView.getInstance();return g.startWriting(),this.encodeInto(I,g),g.toArray()},encodeInto(A,I){const g=I.length;m.encodeInto(A.header,I),xA.encodeInto(A.body,I);return I.length-g},decode(I){const g=bebop__WEBPACK_IMPORTED_MODULE_0__.BebopView.getInstance();return g.startReading(I),this.readFrom(g)},readFrom(A){let I,g;return I=m.readFrom(A),g=xA.readFrom(A),{header:I,body:g}}},p={encode(I){const g=bebop__WEBPACK_IMPORTED_MODULE_0__.BebopView.getInstance();return g.startWriting(),this.encodeInto(I,g),g.toArray()},encodeInto(A,I){const g=I.length;m.encodeInto(A.header,I),zA.encodeInto(A.body,I);return I.length-g},decode(I){const g=bebop__WEBPACK_IMPORTED_MODULE_0__.BebopView.getInstance();return g.startReading(I),this.readFrom(g)},readFrom(A){let I,g;return I=m.readFrom(A),g=zA.readFrom(A),{header:I,body:g}}},H={encode(I){const g=bebop__WEBPACK_IMPORTED_MODULE_0__.BebopView.getInstance();return g.startWriting(),this.encodeInto(I,g),g.toArray()},encodeInto(A,I){const g=I.length;m.encodeInto(A.header,I),M.encodeInto(A.body,I);return I.length-g},decode(I){const g=bebop__WEBPACK_IMPORTED_MODULE_0__.BebopView.getInstance();return g.startReading(I),this.readFrom(g)},readFrom(A){let I,g;return I=m.readFrom(A),g=M.readFrom(A),{header:I,body:g}}};var J,K,q,Y,v,b,P;!function(A){A[A.None=0]="None",A[A.DpadUp=1]="DpadUp",A[A.DpadDown=2]="DpadDown",A[A.DpadLeft=4]="DpadLeft",A[A.DpadRight=8]="DpadRight",A[A.Start=16]="Start",A[A.Back=32]="Back",A[A.LeftStick=64]="LeftStick",A[A.RightStick=128]="RightStick",A[A.LeftBumper=256]="LeftBumper",A[A.RightBumper=512]="RightBumper",A[A.Guide=1024]="Guide",A[A.A=4096]="A",A[A.B=8192]="B",A[A.X=16384]="X",A[A.Y=32768]="Y"}(J||(J={})),function(A){A[A.ButtonDown=0]="ButtonDown",A[A.ButtonUp=1]="ButtonUp"}(K||(K={})),function(A){A[A.Left=0]="Left",A[A.Right=1]="Right",A[A.Middle=2]="Middle",A[A.X1=3]="X1",A[A.X2=4]="X2"}(q||(q={})),function(A){A[A.Horizontal=0]="Horizontal",A[A.Vertical=1]="Vertical"}(Y||(Y={})),function(A){A[A.KeyDown=0]="KeyDown",A[A.KeyUp=1]="KeyUp"}(v||(v={})),function(A){A[A.None=0]="None",A[A.Cancel=1]="Cancel",A[A.Back=2]="Back",A[A.Tab=3]="Tab",A[A.LineFeed=4]="LineFeed",A[A.Clear=5]="Clear",A[A.Enter=6]="Enter",A[A.Pause=7]="Pause",A[A.CapsLock=8]="CapsLock",A[A.HangulMode=9]="HangulMode",A[A.JunjaMode=10]="JunjaMode",A[A.FinalMode=11]="FinalMode",A[A.HanjaMode=12]="HanjaMode",A[A.Escape=13]="Escape",A[A.ImeConvert=14]="ImeConvert",A[A.ImeNonConvert=15]="ImeNonConvert",A[A.ImeAccept=16]="ImeAccept",A[A.ImeModeChange=17]="ImeModeChange",A[A.Space=18]="Space",A[A.PageUp=19]="PageUp",A[A.PageDown=20]="PageDown",A[A.End=21]="End",A[A.Home=22]="Home",A[A.Left=23]="Left",A[A.Up=24]="Up",A[A.Right=25]="Right",A[A.Down=26]="Down",A[A.Select=27]="Select",A[A.Print=28]="Print",A[A.Execute=29]="Execute",A[A.PrintScreen=30]="PrintScreen",A[A.Insert=31]="Insert",A[A.Delete=32]="Delete",A[A.Help=33]="Help",A[A.D0=34]="D0",A[A.D1=35]="D1",A[A.D2=36]="D2",A[A.D3=37]="D3",A[A.D4=38]="D4",A[A.D5=39]="D5",A[A.D6=40]="D6",A[A.D7=41]="D7",A[A.D8=42]="D8",A[A.D9=43]="D9",A[A.A=44]="A",A[A.B=45]="B",A[A.C=46]="C",A[A.D=47]="D",A[A.E=48]="E",A[A.F=49]="F",A[A.G=50]="G",A[A.H=51]="H",A[A.I=52]="I",A[A.J=53]="J",A[A.K=54]="K",A[A.L=55]="L",A[A.M=56]="M",A[A.N=57]="N",A[A.O=58]="O",A[A.P=59]="P",A[A.Q=60]="Q",A[A.R=61]="R",A[A.S=62]="S",A[A.T=63]="T",A[A.U=64]="U",A[A.V=65]="V",A[A.W=66]="W",A[A.X=67]="X",A[A.Y=68]="Y",A[A.Z=69]="Z",A[A.LWin=70]="LWin",A[A.RWin=71]="RWin",A[A.Apps=72]="Apps",A[A.Sleep=73]="Sleep",A[A.NumPad0=74]="NumPad0",A[A.NumPad1=75]="NumPad1",A[A.NumPad2=76]="NumPad2",A[A.NumPad3=77]="NumPad3",A[A.NumPad4=78]="NumPad4",A[A.NumPad5=79]="NumPad5",A[A.NumPad6=80]="NumPad6",A[A.NumPad7=81]="NumPad7",A[A.NumPad8=82]="NumPad8",A[A.NumPad9=83]="NumPad9",A[A.Multiply=84]="Multiply",A[A.Add=85]="Add",A[A.Separator=86]="Separator",A[A.Subtract=87]="Subtract",A[A.Decimal=88]="Decimal",A[A.Divide=89]="Divide",A[A.F1=90]="F1",A[A.F2=91]="F2",A[A.F3=92]="F3",A[A.F4=93]="F4",A[A.F5=94]="F5",A[A.F6=95]="F6",A[A.F7=96]="F7",A[A.F8=97]="F8",A[A.F9=98]="F9",A[A.F10=99]="F10",A[A.F11=100]="F11",A[A.F12=101]="F12",A[A.F13=102]="F13",A[A.F14=103]="F14",A[A.F15=104]="F15",A[A.F16=105]="F16",A[A.F17=106]="F17",A[A.F18=107]="F18",A[A.F19=108]="F19",A[A.F20=109]="F20",A[A.F21=110]="F21",A[A.F22=111]="F22",A[A.F23=112]="F23",A[A.F24=113]="F24",A[A.NumLock=114]="NumLock",A[A.Scroll=115]="Scroll",A[A.LeftShift=116]="LeftShift",A[A.RightShift=117]="RightShift",A[A.LeftCtrl=118]="LeftCtrl",A[A.RightCtrl=119]="RightCtrl",A[A.LeftAlt=120]="LeftAlt",A[A.RightAlt=121]="RightAlt",A[A.BrowserBack=122]="BrowserBack",A[A.BrowserForward=123]="BrowserForward",A[A.BrowserRefresh=124]="BrowserRefresh",A[A.BrowserStop=125]="BrowserStop",A[A.BrowserSearch=126]="BrowserSearch",A[A.BrowserFavorites=127]="BrowserFavorites",A[A.BrowserHome=128]="BrowserHome",A[A.VolumeMute=129]="VolumeMute",A[A.VolumeDown=130]="VolumeDown",A[A.VolumeUp=131]="VolumeUp",A[A.MediaNextTrack=132]="MediaNextTrack",A[A.MediaPreviousTrack=133]="MediaPreviousTrack",A[A.MediaStop=134]="MediaStop",A[A.MediaPlayPause=135]="MediaPlayPause",A[A.LaunchMail=136]="LaunchMail",A[A.SelectMedia=137]="SelectMedia",A[A.LaunchApplication1=138]="LaunchApplication1",A[A.LaunchApplication2=139]="LaunchApplication2",A[A.Oem1=140]="Oem1",A[A.OemPlus=141]="OemPlus",A[A.OemComma=142]="OemComma",A[A.OemMinus=143]="OemMinus",A[A.OemPeriod=144]="OemPeriod",A[A.Oem2=145]="Oem2",A[A.Oem3=146]="Oem3",A[A.AbntC1=147]="AbntC1",A[A.AbntC2=148]="AbntC2",A[A.Oem4=149]="Oem4",A[A.Oem5=150]="Oem5",A[A.Oem6=151]="Oem6",A[A.Oem7=152]="Oem7",A[A.Oem8=153]="Oem8",A[A.Oem102=154]="Oem102",A[A.ImeProcessed=155]="ImeProcessed",A[A.System=156]="System",A[A.OemAttn=157]="OemAttn",A[A.OemFinish=158]="OemFinish",A[A.OemCopy=159]="OemCopy",A[A.OemAuto=160]="OemAuto",A[A.OemEnlw=161]="OemEnlw",A[A.OemBackTab=162]="OemBackTab",A[A.Attn=163]="Attn",A[A.CrSel=164]="CrSel",A[A.ExSel=165]="ExSel",A[A.EraseEof=166]="EraseEof",A[A.Play=167]="Play",A[A.Zoom=168]="Zoom",A[A.NoName=169]="NoName",A[A.Pa1=170]="Pa1",A[A.OemClear=171]="OemClear",A[A.DeadCharProcessed=172]="DeadCharProcessed"}(b||(b={})),function(A){A[A.New=1]="New",A[A.InRange=2]="InRange",A[A.InContact=4]="InContact",A[A.FirstButton=16]="FirstButton",A[A.SecondButton=32]="SecondButton",A[A.ThirdButton=64]="ThirdButton",A[A.FourthButton=128]="FourthButton",A[A.FifthButton=256]="FifthButton",A[A.Primary=8192]="Primary",A[A.Confidence=16384]="Confidence",A[A.Canceled=32768]="Canceled",A[A.Down=65536]="Down",A[A.Update=131072]="Update",A[A.Up=262144]="Up",A[A.Wheel=524288]="Wheel",A[A.HWheel=1048576]="HWheel",A[A.CaptureChanged=2097152]="CaptureChanged",A[A.HasTransform=4194304]="HasTransform"}(P||(P={}));const x={encode(I){const g=bebop__WEBPACK_IMPORTED_MODULE_0__.BebopView.getInstance();return g.startWriting(),this.encodeInto(I,g),g.toArray()},encodeInto(A,I){const g=I.length;I.writeUint32(A.pointerId),I.writeUint32(A.frameId),I.writeUint32(A.pointerFlags),I.writeInt32(A.x),I.writeInt32(A.y);return I.length-g},decode(I){const g=bebop__WEBPACK_IMPORTED_MODULE_0__.BebopView.getInstance();return g.startReading(I),this.readFrom(g)},readFrom(A){let I,g,B,Q,C;return I=A.readUint32(),g=A.readUint32(),B=A.readUint32(),Q=A.readInt32(),C=A.readInt32(),{pointerId:I,frameId:g,pointerFlags:B,x:Q,y:C}}};var W,T,O;!function(A){A[A.ContactArea=1]="ContactArea",A[A.Orientation=2]="Orientation",A[A.Pressure=4]="Pressure"}(W||(W={})),function(A){A[A.Pressure=1]="Pressure",A[A.Rotation=2]="Rotation",A[A.TiltX=4]="TiltX",A[A.TiltY=8]="TiltY"}(T||(T={})),function(A){A[A.Barrel=1]="Barrel",A[A.Inverted=2]="Inverted",A[A.Eraser=4]="Eraser"}(O||(O={}));const X={encode(I){const g=bebop__WEBPACK_IMPORTED_MODULE_0__.BebopView.getInstance();return g.startWriting(),this.encodeInto(I,g),g.toArray()},encodeInto(A,I){const g=I.length;x.encodeInto(A.pointerInfo,I),I.writeUint32(A.touchMask),I.writeInt32(A.contactLeft),I.writeInt32(A.contactTop),I.writeInt32(A.contactRight),I.writeInt32(A.contactBottom),I.writeUint32(A.orientation),I.writeUint32(A.pressure);return I.length-g},decode(I){const g=bebop__WEBPACK_IMPORTED_MODULE_0__.BebopView.getInstance();return g.startReading(I),this.readFrom(g)},readFrom(A){let I,g,B,Q,C,e,i,t;return I=x.readFrom(A),g=A.readUint32(),B=A.readInt32(),Q=A.readInt32(),C=A.readInt32(),e=A.readInt32(),i=A.readUint32(),t=A.readUint32(),{pointerInfo:I,touchMask:g,contactLeft:B,contactTop:Q,contactRight:C,contactBottom:e,orientation:i,pressure:t}}},V={discriminator:1,encode(I){const g=bebop__WEBPACK_IMPORTED_MODULE_0__.BebopView.getInstance();return g.startWriting(),this.encodeInto(I,g),g.toArray()},encodeInto(A,I){const g=I.length;I.writeUint32(A.buttons),I.writeByte(A.leftTrigger),I.writeByte(A.rightTrigger),I.writeInt16(A.leftThumbX),I.writeInt16(A.leftThumbY),I.writeInt16(A.rightThumbX),I.writeInt16(A.rightThumbY),I.writeByte(A.slot);return I.length-g},decode(I){const g=bebop__WEBPACK_IMPORTED_MODULE_0__.BebopView.getInstance();return g.startReading(I),this.readFrom(g)},readFrom(A){let I,g,B,Q,C,e,i,t;return I=A.readUint32(),g=A.readByte(),B=A.readByte(),Q=A.readInt16(),C=A.readInt16(),e=A.readInt16(),i=A.readInt16(),t=A.readByte(),{buttons:I,leftTrigger:g,rightTrigger:B,leftThumbX:Q,leftThumbY:C,rightThumbX:e,rightThumbY:i,slot:t}}},j={discriminator:2,encode(I){const g=bebop__WEBPACK_IMPORTED_MODULE_0__.BebopView.getInstance();return g.startWriting(),this.encodeInto(I,g),g.toArray()},encodeInto(A,I){const g=I.length;I.writeByte(A.port),I.writeUint16(A.leftMotorSpeed),I.writeUint16(A.rightMotorSpeed);return I.length-g},decode(I){const g=bebop__WEBPACK_IMPORTED_MODULE_0__.BebopView.getInstance();return g.startReading(I),this.readFrom(g)},readFrom(A){let I,g,B;return I=A.readByte(),g=A.readUint16(),B=A.readUint16(),{port:I,leftMotorSpeed:g,rightMotorSpeed:B}}},Z={discriminator:3,encode(I){const g=bebop__WEBPACK_IMPORTED_MODULE_0__.BebopView.getInstance();return g.startWriting(),this.encodeInto(I,g),g.toArray()},encodeInto(A,I){const g=I.length;I.writeInt32(A.x),I.writeInt32(A.y);return I.length-g},decode(I){const g=bebop__WEBPACK_IMPORTED_MODULE_0__.BebopView.getInstance();return g.startReading(I),this.readFrom(g)},readFrom(A){let I,g;return I=A.readInt32(),g=A.readInt32(),{x:I,y:g}}},z={discriminator:4,encode(I){const g=bebop__WEBPACK_IMPORTED_MODULE_0__.BebopView.getInstance();return g.startWriting(),this.encodeInto(I,g),g.toArray()},encodeInto(A,I){const g=I.length;I.writeInt32(A.dx),I.writeInt32(A.dy);return I.length-g},decode(I){const g=bebop__WEBPACK_IMPORTED_MODULE_0__.BebopView.getInstance();return g.startReading(I),this.readFrom(g)},readFrom(A){let I,g;return I=A.readInt32(),g=A.readInt32(),{dx:I,dy:g}}},_={discriminator:5,encode(I){const g=bebop__WEBPACK_IMPORTED_MODULE_0__.BebopView.getInstance();return g.startWriting(),this.encodeInto(I,g),g.toArray()},encodeInto(A,I){const g=I.length;I.writeUint32(A.action),I.writeUint32(A.button);return I.length-g},decode(I){const g=bebop__WEBPACK_IMPORTED_MODULE_0__.BebopView.getInstance();return g.startReading(I),this.readFrom(g)},readFrom(A){let I,g;return I=A.readUint32(),g=A.readUint32(),{action:I,button:g}}},$={discriminator:6,encode(I){const g=bebop__WEBPACK_IMPORTED_MODULE_0__.BebopView.getInstance();return g.startWriting(),this.encodeInto(I,g),g.toArray()},encodeInto(A,I){const g=I.length;I.writeUint32(A.axis),I.writeInt32(A.delta);return I.length-g},decode(I){const g=bebop__WEBPACK_IMPORTED_MODULE_0__.BebopView.getInstance();return g.startReading(I),this.readFrom(g)},readFrom(A){let I,g;return I=A.readUint32(),g=A.readInt32(),{axis:I,delta:g}}},AA={discriminator:7,encode(I){const g=bebop__WEBPACK_IMPORTED_MODULE_0__.BebopView.getInstance();return g.startWriting(),this.encodeInto(I,g),g.toArray()},encodeInto(A,I){const g=I.length;I.writeUint32(A.action),I.writeUint32(A.keycode);return I.length-g},decode(I){const g=bebop__WEBPACK_IMPORTED_MODULE_0__.BebopView.getInstance();return g.startReading(I),this.readFrom(g)},readFrom(A){let I,g;return I=A.readUint32(),g=A.readUint32(),{action:I,keycode:g}}},IA={discriminator:8,encode(I){const g=bebop__WEBPACK_IMPORTED_MODULE_0__.BebopView.getInstance();return g.startWriting(),this.encodeInto(I,g),g.toArray()},encodeInto(A,I){const g=I.length;I.writeString(A.inputString);return I.length-g},decode(I){const g=bebop__WEBPACK_IMPORTED_MODULE_0__.BebopView.getInstance();return g.startReading(I),this.readFrom(g)},readFrom(A){let I;return I=A.readString(),{inputString:I}}},gA={discriminator:9,encode(I){const g=bebop__WEBPACK_IMPORTED_MODULE_0__.BebopView.getInstance();return g.startWriting(),this.encodeInto(I,g),g.toArray()},encodeInto(A,I){const g=I.length;{const g=A.touches.length;I.writeUint32(g);for(let B=0;B<g;B++)X.encodeInto(A.touches[B],I)}return I.length-g},decode(I){const g=bebop__WEBPACK_IMPORTED_MODULE_0__.BebopView.getInstance();return g.startReading(I),this.readFrom(g)},readFrom(A){let I;{let g=A.readUint32();I=new Array(g);for(let B=0;B<g;B++){let g;g=X.readFrom(A),I[B]=g}}return{touches:I}}},BA={discriminator:10,encode(I){const g=bebop__WEBPACK_IMPORTED_MODULE_0__.BebopView.getInstance();return g.startWriting(),this.encodeInto(I,g),g.toArray()},encodeInto(A,I){const g=I.length;x.encodeInto(A.pointerInfo,I),I.writeUint32(A.penFlags),I.writeUint32(A.penMask),I.writeUint32(A.pressure),I.writeUint32(A.rotation),I.writeInt32(A.tiltX),I.writeInt32(A.tiltY);return I.length-g},decode(I){const g=bebop__WEBPACK_IMPORTED_MODULE_0__.BebopView.getInstance();return g.startReading(I),this.readFrom(g)},readFrom(A){let I,g,B,Q,C,e,i;return I=x.readFrom(A),g=A.readUint32(),B=A.readUint32(),Q=A.readUint32(),C=A.readUint32(),e=A.readInt32(),i=A.readInt32(),{pointerInfo:I,penFlags:g,penMask:B,pressure:Q,rotation:C,tiltX:e,tiltY:i}}},QA={discriminator:11,encode(I){const g=bebop__WEBPACK_IMPORTED_MODULE_0__.BebopView.getInstance();return g.startWriting(),this.encodeInto(I,g),g.toArray()},encodeInto(A,I){const g=I.length;I.writeUint32(A.width),I.writeUint32(A.height);return I.length-g},decode(I){const g=bebop__WEBPACK_IMPORTED_MODULE_0__.BebopView.getInstance();return g.startReading(I),this.readFrom(g)},readFrom(A){let I,g;return I=A.readUint32(),g=A.readUint32(),{width:I,height:g}}},CA={discriminator:12,encode(I){const g=bebop__WEBPACK_IMPORTED_MODULE_0__.BebopView.getInstance();return g.startWriting(),this.encodeInto(I,g),g.toArray()},encodeInto(A,I){const g=I.length;I.writeString(A.text);return I.length-g},decode(I){const g=bebop__WEBPACK_IMPORTED_MODULE_0__.BebopView.getInstance();return g.startReading(I),this.readFrom(g)},readFrom(A){let I;return I=A.readString(),{text:I}}},eA={encode(I){const g=bebop__WEBPACK_IMPORTED_MODULE_0__.BebopView.getInstance();return g.startWriting(),this.encodeInto(I,g),g.toArray()},encodeInto(A,I){const g=I.length,B=I.reserveMessageLength(),Q=I.length+1;switch(I.writeByte(A.discriminator),A.discriminator){case 1:V.encodeInto(A.value,I);break;case 2:j.encodeInto(A.value,I);break;case 3:Z.encodeInto(A.value,I);break;case 4:z.encodeInto(A.value,I);break;case 5:_.encodeInto(A.value,I);break;case 6:$.encodeInto(A.value,I);break;case 7:AA.encodeInto(A.value,I);break;case 8:IA.encodeInto(A.value,I);break;case 9:gA.encodeInto(A.value,I);break;case 10:BA.encodeInto(A.value,I);break;case 11:QA.encodeInto(A.value,I);break;case 12:CA.encodeInto(A.value,I)}const C=I.length;I.fillMessageLength(B,C-Q);return I.length-g},decode(I){const g=bebop__WEBPACK_IMPORTED_MODULE_0__.BebopView.getInstance();return g.startReading(I),this.readFrom(g)},readFrom(A){const g=A.readMessageLength(),B=A.index+1+g;switch(A.readByte()){case 1:return{discriminator:1,value:V.readFrom(A)};case 2:return{discriminator:2,value:j.readFrom(A)};case 3:return{discriminator:3,value:Z.readFrom(A)};case 4:return{discriminator:4,value:z.readFrom(A)};case 5:return{discriminator:5,value:_.readFrom(A)};case 6:return{discriminator:6,value:$.readFrom(A)};case 7:return{discriminator:7,value:AA.readFrom(A)};case 8:return{discriminator:8,value:IA.readFrom(A)};case 9:return{discriminator:9,value:gA.readFrom(A)};case 10:return{discriminator:10,value:BA.readFrom(A)};case 11:return{discriminator:11,value:QA.readFrom(A)};case 12:return{discriminator:12,value:CA.readFrom(A)};default:throw A.index=B,new bebop__WEBPACK_IMPORTED_MODULE_0__.BebopRuntimeError("Unrecognized discriminator while decoding InputBodyInner")}}},iA={encode(I){const g=bebop__WEBPACK_IMPORTED_MODULE_0__.BebopView.getInstance();return g.startWriting(),this.encodeInto(I,g),g.toArray()},encodeInto(A,I){const g=I.length;I.writeByte(A.streamId),eA.encodeInto(A.inner,I);return I.length-g},decode(I){const g=bebop__WEBPACK_IMPORTED_MODULE_0__.BebopView.getInstance();return g.startReading(I),this.readFrom(g)},readFrom(A){let I,g;return I=A.readByte(),g=eA.readFrom(A),{streamId:I,inner:g}}};var tA,EA;!function(A){A[A.Baseline=1]="Baseline",A[A.Main=2]="Main",A[A.High=4]="High",A[A.H264=7]="H264",A[A.H265=8]="H265"}(tA||(tA={})),function(A){A[A.Unknown=0]="Unknown",A[A.Amd=4098]="Amd",A[A.Nvidia=4318]="Nvidia",A[A.Intel=32902]="Intel"}(EA||(EA={}));const oA={encode(I){const g=bebop__WEBPACK_IMPORTED_MODULE_0__.BebopView.getInstance();return g.startWriting(),this.encodeInto(I,g),g.toArray()},encodeInto(A,I){const g=I.length;I.writeString(A.friendlyName),I.writeUint32(A.width),I.writeUint32(A.height),I.writeUint32(A.refreshRate),I.writeBytes(A.data),I.writeUint32(A.type);return I.length-g},decode(I){const g=bebop__WEBPACK_IMPORTED_MODULE_0__.BebopView.getInstance();return g.startReading(I),this.readFrom(g)},readFrom(A){let I,g,B,Q,C,e;return I=A.readString(),g=A.readUint32(),B=A.readUint32(),Q=A.readUint32(),C=A.readBytes(),e=A.readUint32(),{friendlyName:I,width:g,height:B,refreshRate:Q,data:C,type:e}}};var aA,sA,nA,rA,hA,dA,cA,DA;!function(A){A[A.Unknown=0]="Unknown",A[A.Phone=1]="Phone",A[A.Tablet=2]="Tablet",A[A.Computer=3]="Computer",A[A.Console=4]="Console",A[A.Tv=5]="Tv"}(aA||(aA={})),function(A){A[A.Other=0]="Other",A[A.IOS=1]="IOS",A[A.TvOS=2]="TvOS",A[A.Android=3]="Android",A[A.Windows=4]="Windows",A[A.MacOS=5]="MacOS",A[A.Linux=6]="Linux",A[A.Roku=7]="Roku"}(sA||(sA={})),function(A){A[A.WebRTC=0]="WebRTC",A[A.Geyser=1]="Geyser"}(nA||(nA={})),function(A){A[A.Mono=0]="Mono",A[A.Stereo=1]="Stereo",A[A.Surround51=2]="Surround51",A[A.Surround71=3]="Surround71"}(rA||(rA={})),function(A){A[A.Opus=0]="Opus",A[A.Aac=1]="Aac"}(hA||(hA={})),function(A){A[A.Raw=0]="Raw",A[A.WebM=1]="WebM",A[A.IsoBMFF=2]="IsoBMFF"}(dA||(dA={})),function(A){A[A.Raw=0]="Raw",A[A.IsoBMFF=1]="IsoBMFF"}(cA||(cA={})),function(A){A[A.UnknownError=0]="UnknownError",A[A.DisplaysMissing=1]="DisplaysMissing",A[A.NoAvailableEncoder=2]="NoAvailableEncoder",A[A.InvalidEncodingConfig=3]="InvalidEncodingConfig",A[A.NoCodecsExchanged=4]="NoCodecsExchanged",A[A.NoCapabilities=5]="NoCapabilities",A[A.NoSuchStream=6]="NoSuchStream",A[A.ForceSegmentFailed=7]="ForceSegmentFailed",A[A.NotCapableOfAppIsolation=8]="NotCapableOfAppIsolation",A[A.AlreadyStreaming=9]="AlreadyStreaming"}(DA||(DA={}));const wA={encode(I){const g=bebop__WEBPACK_IMPORTED_MODULE_0__.BebopView.getInstance();return g.startWriting(),this.encodeInto(I,g),g.toArray()},encodeInto(A,I){const g=I.length;I.writeUint32(A.codec),I.writeUint32(A.container);return I.length-g},decode(I){const g=bebop__WEBPACK_IMPORTED_MODULE_0__.BebopView.getInstance();return g.startReading(I),this.readFrom(g)},readFrom(A){let I,g;return I=A.readUint32(),g=A.readUint32(),{codec:I,container:g}}};var FA;!function(A){A[A.Unknown=0]="Unknown",A[A.FullDesktop=1]="FullDesktop",A[A.AppIsolation=2]="AppIsolation",A[A.Byofb=3]="Byofb"}(FA||(FA={}));const SA={encode(I){const g=bebop__WEBPACK_IMPORTED_MODULE_0__.BebopView.getInstance();return g.startWriting(),this.encodeInto(I,g),g.toArray()},encodeInto(A,I){const g=I.length;oA.encodeInto(A.codec,I),I.writeUint32(A.container);return I.length-g},decode(I){const g=bebop__WEBPACK_IMPORTED_MODULE_0__.BebopView.getInstance();return g.startReading(I),this.readFrom(g)},readFrom(A){let I,g;return I=oA.readFrom(A),g=A.readUint32(),{codec:I,container:g}}};var yA;!function(A){A[A.None=0]="None",A[A.GamepadPort1=1]="GamepadPort1",A[A.GamepadPort2=2]="GamepadPort2",A[A.GamepadPort3=4]="GamepadPort3",A[A.GamepadPort4=8]="GamepadPort4",A[A.Gamepad=15]="Gamepad",A[A.Mouse=16]="Mouse",A[A.Keyboard=32]="Keyboard",A[A.Clipboard=64]="Clipboard",A[A.All=63]="All"}(yA||(yA={}));const GA={encode(I){const g=bebop__WEBPACK_IMPORTED_MODULE_0__.BebopView.getInstance();return g.startWriting(),this.encodeInto(I,g),g.toArray()},encodeInto(A,I){const g=I.length;I.writeByte(A.streamId),I.writeUint32(A.streamType),I.writeUint32(A.defaultInputLevel),I.writeFloat32(A.temporalScaleFactor),wA.encodeInto(A.chosenAudioConfig,I),SA.encodeInto(A.chosenVideoConfig,I);return I.length-g},decode(I){const g=bebop__WEBPACK_IMPORTED_MODULE_0__.BebopView.getInstance();return g.startReading(I),this.readFrom(g)},readFrom(A){let I,g,B,Q,C,e;return I=A.readByte(),g=A.readUint32(),B=A.readUint32(),Q=A.readFloat32(),C=wA.readFrom(A),e=SA.readFrom(A),{streamId:I,streamType:g,defaultInputLevel:B,temporalScaleFactor:Q,chosenAudioConfig:C,chosenVideoConfig:e}}},RA={discriminator:1,encode(I){const g=bebop__WEBPACK_IMPORTED_MODULE_0__.BebopView.getInstance();return g.startWriting(),this.encodeInto(I,g),g.toArray()},encodeInto(A,I){const g=I.length;I.writeUint32(A.formFactor),I.writeString(A.deviceName),I.writeUint32(A.deviceOs),I.writeString(A.deviceOsVersion),I.writeString(A.deviceModel),I.writeString(A.userAgent),I.writeString(A.deviceId),I.writeByte(Number(A.isWeb));return I.length-g},decode(I){const g=bebop__WEBPACK_IMPORTED_MODULE_0__.BebopView.getInstance();return g.startReading(I),this.readFrom(g)},readFrom(A){let I,g,B,Q,C,e,i,t;return I=A.readUint32(),g=A.readString(),B=A.readUint32(),Q=A.readString(),C=A.readString(),e=A.readString(),i=A.readString(),t=!!A.readByte(),{formFactor:I,deviceName:g,deviceOs:B,deviceOsVersion:Q,deviceModel:C,userAgent:e,deviceId:i,isWeb:t}}},uA={discriminator:2,encode(I){const g=bebop__WEBPACK_IMPORTED_MODULE_0__.BebopView.getInstance();return g.startWriting(),this.encodeInto(I,g),g.toArray()},encodeInto(A,I){const g=I.length;return I.length-g},decode(I){const g=bebop__WEBPACK_IMPORTED_MODULE_0__.BebopView.getInstance();return g.startReading(I),this.readFrom(g)},readFrom:A=>({})},lA={discriminator:3,encode(I){const g=bebop__WEBPACK_IMPORTED_MODULE_0__.BebopView.getInstance();return g.startWriting(),this.encodeInto(I,g),g.toArray()},encodeInto(A,I){const g=I.length;{const g=A.videoCodecs.length;I.writeUint32(g);for(let B=0;B<g;B++)oA.encodeInto(A.videoCodecs[B],I)}return I.length-g},decode(I){const g=bebop__WEBPACK_IMPORTED_MODULE_0__.BebopView.getInstance();return g.startReading(I),this.readFrom(g)},readFrom(A){let I;{let g=A.readUint32();I=new Array(g);for(let B=0;B<g;B++){let g;g=oA.readFrom(A),I[B]=g}}return{videoCodecs:I}}},kA={discriminator:4,encode(I){const g=bebop__WEBPACK_IMPORTED_MODULE_0__.BebopView.getInstance();return g.startWriting(),this.encodeInto(I,g),g.toArray()},encodeInto(A,I){const g=I.length;I.writeUint32(A.preferredWidth),I.writeUint32(A.preferredHeight),I.writeUint32(A.preferredFps),I.writeUint32(A.preferredAudioBitrate),I.writeUint32(A.preferredVideoBitrate),I.writeUint32(A.preferredAudioChannels),wA.encodeInto(A.preferredAudioConfig,I),SA.encodeInto(A.preferredVideoConfig,I);{const g=A.supportedAudioChannels.length;I.writeUint32(g);for(let B=0;B<g;B++)I.writeUint32(A.supportedAudioChannels[B])}{const g=A.supportedAudioConfigs.length;I.writeUint32(g);for(let B=0;B<g;B++)wA.encodeInto(A.supportedAudioConfigs[B],I)}{const g=A.supportedVideoConfigs.length;I.writeUint32(g);for(let B=0;B<g;B++)SA.encodeInto(A.supportedVideoConfigs[B],I)}I.writeByte(Number(A.supportsOver1080P)),I.writeByte(Number(A.supportsTemporalScaling)),I.writeByte(Number(A.supportsAppIsolation));return I.length-g},decode(I){const g=bebop__WEBPACK_IMPORTED_MODULE_0__.BebopView.getInstance();return g.startReading(I),this.readFrom(g)},readFrom(A){let I,g,B,Q,C,e,i,t,E,o,a,s,n,r;I=A.readUint32(),g=A.readUint32(),B=A.readUint32(),Q=A.readUint32(),C=A.readUint32(),e=A.readUint32(),i=wA.readFrom(A),t=SA.readFrom(A);{let I=A.readUint32();E=new Array(I);for(let g=0;g<I;g++){let I;I=A.readUint32(),E[g]=I}}{let I=A.readUint32();o=new Array(I);for(let g=0;g<I;g++){let I;I=wA.readFrom(A),o[g]=I}}{let I=A.readUint32();a=new Array(I);for(let g=0;g<I;g++){let I;I=SA.readFrom(A),a[g]=I}}return s=!!A.readByte(),n=!!A.readByte(),r=!!A.readByte(),{preferredWidth:I,preferredHeight:g,preferredFps:B,preferredAudioBitrate:Q,preferredVideoBitrate:C,preferredAudioChannels:e,preferredAudioConfig:i,preferredVideoConfig:t,supportedAudioChannels:E,supportedAudioConfigs:o,supportedVideoConfigs:a,supportsOver1080P:s,supportsTemporalScaling:n,supportsAppIsolation:r}}},UA={discriminator:5,encode(I){const g=bebop__WEBPACK_IMPORTED_MODULE_0__.BebopView.getInstance();return g.startWriting(),this.encodeInto(I,g),g.toArray()},encodeInto(A,I){const g=I.length;I.writeUint32(A.error);return I.length-g},decode(I){const g=bebop__WEBPACK_IMPORTED_MODULE_0__.BebopView.getInstance();return g.startReading(I),this.readFrom(g)},readFrom(A){let I;return I=A.readUint32(),{error:I}}},NA={discriminator:6,encode(I){const g=bebop__WEBPACK_IMPORTED_MODULE_0__.BebopView.getInstance();return g.startWriting(),this.encodeInto(I,g),g.toArray()},encodeInto(A,I){const g=I.length;I.writeUint32(A.inputLevel);return I.length-g},decode(I){const g=bebop__WEBPACK_IMPORTED_MODULE_0__.BebopView.getInstance();return g.startReading(I),this.readFrom(g)},readFrom(A){let I;return I=A.readUint32(),{inputLevel:I}}},mA={discriminator:8,encode(I){const g=bebop__WEBPACK_IMPORTED_MODULE_0__.BebopView.getInstance();return g.startWriting(),this.encodeInto(I,g),g.toArray()},encodeInto(A,I){const g=I.length;I.writeByte(A.streamId);return I.length-g},decode(I){const g=bebop__WEBPACK_IMPORTED_MODULE_0__.BebopView.getInstance();return g.startReading(I),this.readFrom(g)},readFrom(A){let I;return I=A.readByte(),{streamId:I}}},MA={discriminator:9,encode(I){const g=bebop__WEBPACK_IMPORTED_MODULE_0__.BebopView.getInstance();return g.startWriting(),this.encodeInto(I,g),g.toArray()},encodeInto(A,I){const g=I.length;I.writeByte(A.streamId);return I.length-g},decode(I){const g=bebop__WEBPACK_IMPORTED_MODULE_0__.BebopView.getInstance();return g.startReading(I),this.readFrom(g)},readFrom(A){let I;return I=A.readByte(),{streamId:I}}},LA={discriminator:10,encode(I){const g=bebop__WEBPACK_IMPORTED_MODULE_0__.BebopView.getInstance();return g.startWriting(),this.encodeInto(I,g),g.toArray()},encodeInto(A,I){const g=I.length;I.writeByte(A.streamId);return I.length-g},decode(I){const g=bebop__WEBPACK_IMPORTED_MODULE_0__.BebopView.getInstance();return g.startReading(I),this.readFrom(g)},readFrom(A){let I;return I=A.readByte(),{streamId:I}}},fA={discriminator:11,encode(I){const g=bebop__WEBPACK_IMPORTED_MODULE_0__.BebopView.getInstance();return g.startWriting(),this.encodeInto(I,g),g.toArray()},encodeInto(A,I){const g=I.length;I.writeByte(A.streamId),I.writeUint32(A.bitsPerSecond);return I.length-g},decode(I){const g=bebop__WEBPACK_IMPORTED_MODULE_0__.BebopView.getInstance();return g.startReading(I),this.readFrom(g)},readFrom(A){let I,g;return I=A.readByte(),g=A.readUint32(),{streamId:I,bitsPerSecond:g}}},pA={discriminator:12,encode(I){const g=bebop__WEBPACK_IMPORTED_MODULE_0__.BebopView.getInstance();return g.startWriting(),this.encodeInto(I,g),g.toArray()},encodeInto(A,I){const g=I.length;I.writeByte(A.streamId);return I.length-g},decode(I){const g=bebop__WEBPACK_IMPORTED_MODULE_0__.BebopView.getInstance();return g.startReading(I),this.readFrom(g)},readFrom(A){let I;return I=A.readByte(),{streamId:I}}},HA={discriminator:13,encode(I){const g=bebop__WEBPACK_IMPORTED_MODULE_0__.BebopView.getInstance();return g.startWriting(),this.encodeInto(I,g),g.toArray()},encodeInto(A,I){const g=I.length;I.writeByte(A.streamId);return I.length-g},decode(I){const g=bebop__WEBPACK_IMPORTED_MODULE_0__.BebopView.getInstance();return g.startReading(I),this.readFrom(g)},readFrom(A){let I;return I=A.readByte(),{streamId:I}}},JA={discriminator:14,encode(I){const g=bebop__WEBPACK_IMPORTED_MODULE_0__.BebopView.getInstance();return g.startWriting(),this.encodeInto(I,g),g.toArray()},encodeInto(A,I){const g=I.length;I.writeString(A.reason);return I.length-g},decode(I){const g=bebop__WEBPACK_IMPORTED_MODULE_0__.BebopView.getInstance();return g.startReading(I),this.readFrom(g)},readFrom(A){let I;return I=A.readString(),{reason:I}}},KA={discriminator:15,encode(I){const g=bebop__WEBPACK_IMPORTED_MODULE_0__.BebopView.getInstance();return g.startWriting(),this.encodeInto(I,g),g.toArray()},encodeInto(A,I){const g=I.length;I.writeByte(A.streamId),I.writeUint32(A.inputLevel);return I.length-g},decode(I){const g=bebop__WEBPACK_IMPORTED_MODULE_0__.BebopView.getInstance();return g.startReading(I),this.readFrom(g)},readFrom(A){let I,g;return I=A.readByte(),g=A.readUint32(),{streamId:I,inputLevel:g}}},qA={discriminator:16,encode(I){const g=bebop__WEBPACK_IMPORTED_MODULE_0__.BebopView.getInstance();return g.startWriting(),this.encodeInto(I,g),g.toArray()},encodeInto(A,I){const g=I.length;I.writeByte(A.streamId),I.writeUint32(A.inputLevel);return I.length-g},decode(I){const g=bebop__WEBPACK_IMPORTED_MODULE_0__.BebopView.getInstance();return g.startReading(I),this.readFrom(g)},readFrom(A){let I,g;return I=A.readByte(),g=A.readUint32(),{streamId:I,inputLevel:g}}},YA={discriminator:17,encode(I){const g=bebop__WEBPACK_IMPORTED_MODULE_0__.BebopView.getInstance();return g.startWriting(),this.encodeInto(I,g),g.toArray()},encodeInto(A,I){const g=I.length;GA.encodeInto(A.streamInfo,I);return I.length-g},decode(I){const g=bebop__WEBPACK_IMPORTED_MODULE_0__.BebopView.getInstance();return g.startReading(I),this.readFrom(g)},readFrom(A){let I;return I=GA.readFrom(A),{streamInfo:I}}},vA={discriminator:18,encode(I){const g=bebop__WEBPACK_IMPORTED_MODULE_0__.BebopView.getInstance();return g.startWriting(),this.encodeInto(I,g),g.toArray()},encodeInto(A,I){const g=I.length;return I.length-g},decode(I){const g=bebop__WEBPACK_IMPORTED_MODULE_0__.BebopView.getInstance();return g.startReading(I),this.readFrom(g)},readFrom:A=>({})},bA={discriminator:19,encode(I){const g=bebop__WEBPACK_IMPORTED_MODULE_0__.BebopView.getInstance();return g.startWriting(),this.encodeInto(I,g),g.toArray()},encodeInto(A,I){const g=I.length;return I.length-g},decode(I){const g=bebop__WEBPACK_IMPORTED_MODULE_0__.BebopView.getInstance();return g.startReading(I),this.readFrom(g)},readFrom:A=>({})},PA={discriminator:20,encode(I){const g=bebop__WEBPACK_IMPORTED_MODULE_0__.BebopView.getInstance();return g.startWriting(),this.encodeInto(I,g),g.toArray()},encodeInto(A,I){const g=I.length;return I.length-g},decode(I){const g=bebop__WEBPACK_IMPORTED_MODULE_0__.BebopView.getInstance();return g.startReading(I),this.readFrom(g)},readFrom:A=>({})},xA={encode(I){const g=bebop__WEBPACK_IMPORTED_MODULE_0__.BebopView.getInstance();return g.startWriting(),this.encodeInto(I,g),g.toArray()},encodeInto(A,I){const g=I.length,B=I.reserveMessageLength(),Q=I.length+1;switch(I.writeByte(A.discriminator),A.discriminator){case 1:RA.encodeInto(A.value,I);break;case 2:uA.encodeInto(A.value,I);break;case 3:lA.encodeInto(A.value,I);break;case 4:kA.encodeInto(A.value,I);break;case 5:UA.encodeInto(A.value,I);break;case 6:NA.encodeInto(A.value,I);break;case 8:mA.encodeInto(A.value,I);break;case 9:MA.encodeInto(A.value,I);break;case 10:LA.encodeInto(A.value,I);break;case 11:fA.encodeInto(A.value,I);break;case 12:pA.encodeInto(A.value,I);break;case 13:HA.encodeInto(A.value,I);break;case 14:JA.encodeInto(A.value,I);break;case 15:KA.encodeInto(A.value,I);break;case 16:qA.encodeInto(A.value,I);break;case 17:YA.encodeInto(A.value,I);break;case 18:vA.encodeInto(A.value,I);break;case 19:bA.encodeInto(A.value,I);break;case 20:PA.encodeInto(A.value,I)}const C=I.length;I.fillMessageLength(B,C-Q);return I.length-g},decode(I){const g=bebop__WEBPACK_IMPORTED_MODULE_0__.BebopView.getInstance();return g.startReading(I),this.readFrom(g)},readFrom(A){const g=A.readMessageLength(),B=A.index+1+g;switch(A.readByte()){case 1:return{discriminator:1,value:RA.readFrom(A)};case 2:return{discriminator:2,value:uA.readFrom(A)};case 3:return{discriminator:3,value:lA.readFrom(A)};case 4:return{discriminator:4,value:kA.readFrom(A)};case 5:return{discriminator:5,value:UA.readFrom(A)};case 6:return{discriminator:6,value:NA.readFrom(A)};case 8:return{discriminator:8,value:mA.readFrom(A)};case 9:return{discriminator:9,value:MA.readFrom(A)};case 10:return{discriminator:10,value:LA.readFrom(A)};case 11:return{discriminator:11,value:fA.readFrom(A)};case 12:return{discriminator:12,value:pA.readFrom(A)};case 13:return{discriminator:13,value:HA.readFrom(A)};case 14:return{discriminator:14,value:JA.readFrom(A)};case 15:return{discriminator:15,value:KA.readFrom(A)};case 16:return{discriminator:16,value:qA.readFrom(A)};case 17:return{discriminator:17,value:YA.readFrom(A)};case 18:return{discriminator:18,value:vA.readFrom(A)};case 19:return{discriminator:19,value:bA.readFrom(A)};case 20:return{discriminator:20,value:PA.readFrom(A)};default:throw A.index=B,new bebop__WEBPACK_IMPORTED_MODULE_0__.BebopRuntimeError("Unrecognized discriminator while decoding LogicBody")}}};var WA,TA;!function(A){A[A.Metadata=0]="Metadata",A[A.CleanPointFrame=1]="CleanPointFrame",A[A.FrameDiff=2]="FrameDiff"}(WA||(WA={})),function(A){A[A.Metadata=0]="Metadata",A[A.Frame=1]="Frame"}(TA||(TA={}));const OA={encode(I){const g=bebop__WEBPACK_IMPORTED_MODULE_0__.BebopView.getInstance();return g.startWriting(),this.encodeInto(I,g),g.toArray()},encodeInto(A,I){const g=I.length;I.writeInt32(A.left),I.writeInt32(A.top),I.writeUint32(A.width),I.writeUint32(A.height);return I.length-g},decode(I){const g=bebop__WEBPACK_IMPORTED_MODULE_0__.BebopView.getInstance();return g.startReading(I),this.readFrom(g)},readFrom(A){let I,g,B,Q;return I=A.readInt32(),g=A.readInt32(),B=A.readUint32(),Q=A.readUint32(),{left:I,top:g,width:B,height:Q}}},XA={discriminator:1,encode(I){const g=bebop__WEBPACK_IMPORTED_MODULE_0__.BebopView.getInstance();return g.startWriting(),this.encodeInto(I,g),g.toArray()},encodeInto(A,I){const g=I.length;I.writeBytes(A.data),I.writeUint64(A.segmentTime),I.writeUint32(A.type),I.writeByte(A.streamId),OA.encodeInto(A.desktopRect,I);{const g=A.mask.length;I.writeUint32(g);for(let B=0;B<g;B++)OA.encodeInto(A.mask[B],I)}return I.length-g},decode(I){const g=bebop__WEBPACK_IMPORTED_MODULE_0__.BebopView.getInstance();return g.startReading(I),this.readFrom(g)},readFrom(A){let I,g,B,Q,C,e;I=A.readBytes(),g=A.readUint64(),B=A.readUint32(),Q=A.readByte(),C=OA.readFrom(A);{let I=A.readUint32();e=new Array(I);for(let g=0;g<I;g++){let I;I=OA.readFrom(A),e[g]=I}}return{data:I,segmentTime:g,type:B,streamId:Q,desktopRect:C,mask:e}}},VA={discriminator:2,encode(I){const g=bebop__WEBPACK_IMPORTED_MODULE_0__.BebopView.getInstance();return g.startWriting(),this.encodeInto(I,g),g.toArray()},encodeInto(A,I){const g=I.length;I.writeBytes(A.data),I.writeUint32(A.monitorWidth),I.writeUint32(A.monitorHeight),I.writeUint32(A.shapeWidth),I.writeUint32(A.shapeHeight),I.writeInt32(A.spotX),I.writeInt32(A.spotY),I.writeByte(Number(A.visible)),I.writeInt32(A.positionX),I.writeInt32(A.positionY),I.writeByte(A.streamId);return I.length-g},decode(I){const g=bebop__WEBPACK_IMPORTED_MODULE_0__.BebopView.getInstance();return g.startReading(I),this.readFrom(g)},readFrom(A){let I,g,B,Q,C,e,i,t,E,o,a;return I=A.readBytes(),g=A.readUint32(),B=A.readUint32(),Q=A.readUint32(),C=A.readUint32(),e=A.readInt32(),i=A.readInt32(),t=!!A.readByte(),E=A.readInt32(),o=A.readInt32(),a=A.readByte(),{data:I,monitorWidth:g,monitorHeight:B,shapeWidth:Q,shapeHeight:C,spotX:e,spotY:i,visible:t,positionX:E,positionY:o,streamId:a}}},jA={discriminator:3,encode(I){const g=bebop__WEBPACK_IMPORTED_MODULE_0__.BebopView.getInstance();return g.startWriting(),this.encodeInto(I,g),g.toArray()},encodeInto(A,I){const g=I.length;I.writeBytes(A.data),I.writeUint32(A.type),I.writeByte(A.streamId);return I.length-g},decode(I){const g=bebop__WEBPACK_IMPORTED_MODULE_0__.BebopView.getInstance();return g.startReading(I),this.readFrom(g)},readFrom(A){let I,g,B;return I=A.readBytes(),g=A.readUint32(),B=A.readByte(),{data:I,type:g,streamId:B}}},ZA={discriminator:4,encode(I){const g=bebop__WEBPACK_IMPORTED_MODULE_0__.BebopView.getInstance();return g.startWriting(),this.encodeInto(I,g),g.toArray()},encodeInto(A,I){const g=I.length;M.encodeInto(A.chunk,I);return I.length-g},decode(I){const g=bebop__WEBPACK_IMPORTED_MODULE_0__.BebopView.getInstance();return g.startReading(I),this.readFrom(g)},readFrom(A){let I;return I=M.readFrom(A),{chunk:I}}},zA={encode(I){const g=bebop__WEBPACK_IMPORTED_MODULE_0__.BebopView.getInstance();return g.startWriting(),this.encodeInto(I,g),g.toArray()},encodeInto(A,I){const g=I.length,B=I.reserveMessageLength(),Q=I.length+1;switch(I.writeByte(A.discriminator),A.discriminator){case 1:XA.encodeInto(A.value,I);break;case 2:VA.encodeInto(A.value,I);break;case 3:jA.encodeInto(A.value,I);break;case 4:ZA.encodeInto(A.value,I)}const C=I.length;I.fillMessageLength(B,C-Q);return I.length-g},decode(I){const g=bebop__WEBPACK_IMPORTED_MODULE_0__.BebopView.getInstance();return g.startReading(I),this.readFrom(g)},readFrom(A){const g=A.readMessageLength(),B=A.index+1+g;switch(A.readByte()){case 1:return{discriminator:1,value:XA.readFrom(A)};case 2:return{discriminator:2,value:VA.readFrom(A)};case 3:return{discriminator:3,value:jA.readFrom(A)};case 4:return{discriminator:4,value:ZA.readFrom(A)};default:throw A.index=B,new bebop__WEBPACK_IMPORTED_MODULE_0__.BebopRuntimeError("Unrecognized discriminator while decoding MediaBody")}}};class _A{constructor(){this.handlers=[]}addHandler(A){this.handlers.push(A)}removeHandler(A){this.handlers=this.handlers.filter((I=>I!==A))}invoke(A){for(let I=0;I<this.handlers.length;I++)this.handlers[I](A)}}let $A;function AI(A,I,g){$A&&$A.onLog(A,I,g)}function II(A,I){AI(e.Error,A,I)}function gI(A,I){AI(e.Warning,A,I)}function BI(A,I){AI(e.Info,A,I)}function QI(A,I){AI(e.Debug,A,I)}var CI,eI,iI;async function tI(A){const I=await async function(A){const I=await C("/keys/validate",{headers:{Authorization:`Bearer ${A}`,Accept:"application/json"}}),g=await I.json();return{universeFlag:g.universe,organizationId:g.org_id}}(A),g=`rainway-hostname-${I.organizationId.toString(16).padStart(8,"0")}-${I.universeFlag}`,B=BigInt(localStorage.getItem(g)??await async function(){const A=await C("/druid/next",{headers:{Accept:"application/json"}});return BigInt(await A.text())}());return localStorage.setItem(g,B.toString()),B}function EI(A,I,g){const B=s.encode({id:A,apiKey:I,externalId:g});return btoa(String.fromCharCode(...B)).replace(/=*$/,"").replace(/\+/g,"-").replace(/\//g,"_")}!function(A){A[A.Open=0]="Open",A[A.Closed=1]="Closed"}(eI||(eI={}));class oI{constructor(A,I,g,B,Q,C,e="wss://gateway.rainway.network"){this.ownPeerId=A,this.apiKey=I,this.externalId=g,this.handlePeerInfo=B,this.connectionRequestHandler=Q,this.addAcceptedPeer=C,this.connections=new Map,this.connectionLostEvent=new _A,CI.set(this,eI.Closed),this.syncKey=0,this.peerIdToExternalId=new Map,this.onMessage=async A=>{if(void 0!==this.socket&&"[object ArrayBuffer]"===A.data.toString()){const I=r.decode(new Uint8Array(A.data)),{header:{syncKey:g},body:B}=I;switch(B.discriminator){case h.discriminator:this.warn("got GatewayRequest?! i am not a gateway. ignoring");break;case d.discriminator:{const A=B.value.body.value;this.trace("got GatewayHello"),this.resolveConnectToGatewayPromise?.(A);break}case c.discriminator:{const{level:A,description:I}=B.value;A===t.Fatal?(II(oI.name,"Fatal GatewayAlert: "+E[I]),this.die(I,"The connection to the Rainway server encountered a fatal error.")):this.onNonFatalAlert(g,I);break}case D.discriminator:this.onForwardable(g,B.value)}}},this.onClose=A=>{this.die(A,"The connection to the Rainway server was closed.")},this.onError=A=>{this.die(A,"The connection to the Rainway server was lost.")},this.url=e}get status(){return g(this,CI,"f")}async connect(){return this.connectToGatewayPromise??(this.connectToGatewayPromise=new Promise(((A,I)=>{this.resolveConnectToGatewayPromise=A,this.rejectConnectToGatewayPromise=I,this.open()})))}async open(){this.socket=await this.makeWebSocket(this.url),this.debug("connected WebSocket"),this.socket.addEventListener("message",this.onMessage),this.socket.addEventListener("close",this.onClose),B(this,CI,eI.Open,"f")}makeWebSocket(A){return new Promise(((I,g)=>{const B=new WebSocket(A,["handshake",EI(this.ownPeerId,this.apiKey,this.externalId)]);B.binaryType="arraybuffer",B.onopen=()=>{I(B)},B.onerror=A=>{this.onError(A),g(A),this.connectToGatewayPromise=void 0}}))}disconnect(){if(this.debug("disconnect()"),void 0!==this.socket){this.socket.close(3e3,"Signaling websocket closed.");const A=this.socket;window.setTimeout((()=>{A.removeEventListener("close",this.onClose),A.removeEventListener("message",this.onMessage)}),0)}this.rejectConnectToGatewayPromise?.(void 0),B(this,CI,eI.Closed,"f"),this.connectToGatewayPromise=void 0,this.resolveConnectToGatewayPromise=void 0,this.rejectConnectToGatewayPromise=void 0,this.socket=void 0,this.connections.clear()}makeDatagram(A){return{header:{syncKey:++this.syncKey},body:A}}makeForwardable(A,I){return this.makeDatagram({discriminator:D.discriminator,value:{targetPeerId:A,body:I}})}connectToHost(A,I){const g=this.connections.get(A);if(void 0!==g){if(g.owned)throw new Q("already connected in other direction");return g.promise}if(void 0===this.socket)throw new Q("socket undefined in sendInitConnectionRequest");if(this.status!==eI.Open)throw new Q("signaling channel not open in sendInitConnectionRequest");const B=this.socket,C={pending:!0};return C.promise=new Promise(((g,Q)=>{C.resolve=g,C.reject=Q,this.trace(`Adding ${A} to pendingConnections`);const e=this.makeDatagram({discriminator:h.discriminator,value:{body:{discriminator:F.discriminator,value:{desiredTransport:I,targetPeerId:A}}}});C.syncKey=e.header.syncKey,this.connections.set(A,C),B.send(r.encode(e))})),C.promise}cancelConnectionAttempt(A){const I=this.connections.get(A);void 0!==I&&I.pending&&(I.resolve({canceled:!0}),this.connections.delete(A))}deleteConnection(A){this.connections.delete(A)}sendPeerInfo(A,I,g){if(void 0===this.socket)throw new Q("socket unset in Gateway.sendPeerInfo");const B=this.connections.get(A);if(void 0===B)throw new Q(`can't send peer info to unknown peerId ${A}`);if(B.pending)throw new Q(`can't send peer info to pending peerId ${A}`);const C=this.makeForwardable(A,{discriminator:k.discriminator,value:{id:B.connectionRequestId,type:I,data:g}}),e=r.encode(C);this.socket.send(e)}sendOffer(A,I){this.debug("sending offer: "+I),this.sendPeerInfo(A,a.Offer,I)}sendAnswer(A,I){this.debug("sending offer: "+I),this.sendPeerInfo(A,a.Answer,I)}sendCandidate(A,I){this.debug("sending candidate"+I.candidate),this.sendPeerInfo(A,a.Candidate,I.candidate)}onNonFatalAlert(A,I){if(I===E.PeerGoneAway)for(const[I,g]of this.connections.entries())g.pending&&g.syncKey===A&&(g.reject("The target peer is not connected to Rainway."),this.connections.delete(I))}onForwardable(A,I){const{body:g}=I;switch(g.discriminator){case R.discriminator:{const{sourcePeerId:I,sourceExternalId:B,id:C}=g.value,e=C;this.peerIdToExternalId.set(I,B),this.connectionRequestHandler({id:I,externalId:g.value.sourceExternalId,accept:()=>{if(void 0===this.socket)throw new Q("Couldn't send accept message because the connection to Rainway was lost.");const g=r.encode({header:{syncKey:A},body:{discriminator:D.discriminator,value:{targetPeerId:I,body:{discriminator:u.discriminator,value:{sourcePeerId:this.ownPeerId,sourceExternalId:this.externalId,id:C}}}}});return this.socket.send(g),this.connections.set(I,{pending:!1,owned:!0,connectionRequestId:e}),this.addAcceptedPeer(I,B,e)},reject:g=>{if(void 0===this.socket)throw new Q("Couldn't send reject message because the connection to Rainway was lost.");const B=r.encode({header:{syncKey:A},body:{discriminator:D.discriminator,value:{targetPeerId:I,body:{discriminator:l.discriminator,value:{sourcePeerId:this.ownPeerId,sourceExternalId:this.externalId,id:C,reason:g}}}}});this.socket.send(B)}});break}case u.discriminator:{const{id:A,sourcePeerId:I,sourceExternalId:B}=g.value,Q=A,C=this.connections.get(I);if(void 0===C)return void this.warn("Ignoring AcceptedConnectionRequest from unexpected hostname: "+I);if(!C.pending)return void this.warn("Ignoring AcceptedConnectionRequest from already-connected hostname: "+I);C.resolve({canceled:!1,accepted:!0,connectionRequestId:Q,hostExternalId:B,transportProtocol:o.SCTP}),this.connections.set(I,{pending:!1,owned:!1,promise:C.promise,connectionRequestId:Q});break}case l.discriminator:{const{id:A,sourcePeerId:I,sourceExternalId:B}=g.value,Q=A,C=this.connections.get(I);if(void 0===C)return void this.warn("Ignoring RejectedConnectionRequest from unexpected hostname: "+I);if(!C.pending)return void this.warn("Ignoring RejectedConnectionRequest from already-connected hostname: "+I);C.resolve({canceled:!1,accepted:!1,connectionRequestId:Q,hostExternalId:B,transportProtocol:o.SCTP,reason:g.value.reason}),this.connections.delete(I);break}case k.discriminator:this.trace("Got peer info:\n"+JSON.stringify(g.value)),this.handlePeerInfo(g.value)}}die(A,I){this.rejectConnectToGatewayPromise?.(A),this.connectToGatewayPromise=void 0,this.resolveConnectToGatewayPromise=void 0,this.rejectConnectToGatewayPromise=void 0;for(const A of this.connections.values())A.pending&&A.reject(I);this.connections.clear(),this.connectionLostEvent?.invoke(new Q(I))}unsetConnectToGatewayPromise(){this.connectToGatewayPromise=void 0,this.resolveConnectToGatewayPromise=void 0,this.rejectConnectToGatewayPromise=void 0}trace(A){var I,g;I=oI.name,g=String(A),AI(e.Trace,I,g)}debug(A){QI(oI.name,String(A))}warn(A){gI(oI.name,String(A))}}CI=new WeakMap,function(A){A[A.Disconnected=0]="Disconnected",A[A.Connecting=1]="Connecting",A[A.Connected=2]="Connected"}(iI||(iI={}));let aI=0;class sI{constructor(){this.listeners={}}addEventListener(A,I){var g;(g=this.listeners)[A]??(g[A]=[]),this.listeners[A].push(I)}removeEventListener(A,I){this.listeners[A]=I?this.listeners[A]?.filter((A=>A!==I))??[]:[]}removeAllEventListeners(){this.listeners={}}emit(A,...I){for(const g of this.listeners[A]??[])g(...I)}}var nI,rI,hI;!function(A){A[A.Unreliable=0]="Unreliable",A[A.Reliable=1]="Reliable"}(nI||(nI={}));class dI extends sI{constructor(A,I){super(),this.peer=I,this.id=A.id,this.mode=A.mode}send(A){this.peer.send(this.id,A)}_emit(A){this.emit("message",A)}}const cI={iceServers:[{urls:"stun:stun.rainway.com:3478"}]};class DI extends class{}{constructor(A,I,g,C,e,t){super(),this.ownPeerId=A,this.targetPeerId=I,this.sendLocalOfferSdp=g,this.sendLocalAnswerSdp=C,this.sendLocalIceCandidate=e,this.reportStateChange=t,rI.set(this,iI.Disconnected),this.rtcConfiguration=cI,this.dataChannelsConfig={},this.syncKey=0,this.onRainwayMessage=()=>{},this.onApplicationMessage=()=>{},this.onClose=()=>{},hI.set(this,new Map),this.handlePeerInfo=A=>{if(A.type===a.Answer)this.debug("Got Answer in CRID "+A.id+"\n"+A.data),this.peerConnection?.setRemoteDescription({type:"answer",sdp:A.data});else if(A.type===a.Offer)this.debug("Got Offer in CRID "+A.id+"\n"+A.data),this.peerConnection?.setRemoteDescription({type:"offer",sdp:A.data}),this.sendAnswer();else{if(A.type!==a.Candidate){const I=a[A.type];throw new Q(`unexpected PeerInformationType ${I} in handlePeerInfo`)}this.debug("Got Candidate in CRID "+A.id+"\n"+A.data),this.peerConnection?.addIceCandidate(new RTCIceCandidate({candidate:A.data,sdpMid:"",sdpMLineIndex:0}))}},this.handleLocalIceCandidate=A=>{if(A.candidate){"1"===A.candidate.candidate.split(" ")[1]&&this.sendLocalIceCandidate(A.candidate)}},this.handleIceConnectionStateChange=()=>{if(!this.peerConnection)return;const A=this.peerConnection.iceConnectionState;this.info(`ICE connection state changed to ${A}`)},this.handleConnectionStateChange=()=>{if(!this.peerConnection)return;const A=this.peerConnection.connectionState;this.info(`Connection state changed to ${A}`),"closed"===A||"failed"===A?(this.reportStateChange(i.Failed),this.openReject?.(),this.onClose(),B(this,rI,iI.Disconnected,"f"),this.dispose()):"disconnected"===A?this.reportStateChange(i.Disconnected):"connecting"===A?this.reportStateChange(i.Connecting):"connected"===A?this.reportStateChange(i.Connected):"new"===A&&this.reportStateChange(i.New)},this.handleDataChannelMessage=A=>{const I=A.target.label;this.handleLabelAndData(I,new Uint8Array(A.data))},this.handleDataChannelClose=A=>{const I=A.target.label;this.warn("RTC channel closed: "+I)},this.handleDataChannelError=A=>{const I=A.target.label;this.warn("RTC channel errored: "+I)},this.chunkedMessages=new Map,this.highestChunkGroup=0;const E={protocol:"sctp",negotiated:!1},o={ordered:!1,maxRetransmits:0};this.dataChannelsConfig={RW_Logic:{id:0,...E,ordered:!0},RW_Video:{id:1,...E,...o},RW_Audio:{id:2,...E,...o},RW_Input:{id:3,...E,...o}}}async createDataChannel(A,I){const g={protocol:"sctp",negotiated:!1},B=this.peerConnection?.createDataChannel(A,I===nI.Reliable?{...g,ordered:!0}:{...g,ordered:!1,maxRetransmits:0});if(!B)throw new Q("Couldn't create Data Channel: "+A);return B.addEventListener("close",this.handleDataChannelClose),B.addEventListener("error",this.handleDataChannelError),B.addEventListener("message",this.handleDataChannelMessage),this.dataChannels??(this.dataChannels={}),this.dataChannels[A]=B,new Promise((A=>{const I=()=>{A(),B.removeEventListener("open",I)};B.addEventListener("open",I)}))}sendMessage(A,I){if(!A)throw new Q("sendMessage: no label");if(!this.dataChannels)throw new Q("sendMessage: dataChannels not initialized");const g=this.dataChannels?.[A];if(!g)throw new Q(`sendMessage: channel "${A}" does not exist`);if("open"!==g.readyState)throw new Q(`sendMessage: channel "${A}" is not open`);g.send(I)}get status(){return g(this,rI,"f")}get maxMessageSize(){return this.peerConnection?.sctp?.maxMessageSize??262144}async getStats(){if(!this.peerConnection)throw new Q("getStats() but no peerConnection");const[A,I]=await Promise.all([this.peerConnection.getStats(void 0),this.measureLatencyMs()]),g={channels:{},raw:A,latencyMs:I};return A.forEach((A=>{"data-channel"===A.type&&(g.channels[A.label]=A)})),g}checkHeader(A){if(2036430674!==A.magicNumber)throw new Q("Invalid magicNumber in checkHeader.");if(A.targetPeerId!==this.ownPeerId)throw new Q("Invalid destination host name (not ours) in checkHeader.")}handleLabelAndData(A,I){if("RW_Logic"===A){const{header:A,body:B}=f.decode(I);if(this.checkHeader(A),B.discriminator===PA.discriminator){const I=g(this,hI,"f").get(A.syncKey);I&&I.resolve()}else B.discriminator===bA.discriminator?this.sendLogicDatagram({discriminator:PA.discriminator,value:{}},A.syncKey):this.onRainwayMessage({kind:"Logic",body:B})}else if("RW_Input"===A){const{header:A,body:g}=L.decode(I);this.checkHeader(A),this.onRainwayMessage({kind:"Input",body:g})}else if("RW_Audio"===A||"RW_Video"==A){const{header:g,body:B}=p.decode(I);this.checkHeader(g),B.discriminator===ZA.discriminator?this.handleChunk(A,B.value.chunk):this.onRainwayMessage({kind:"Media",body:B})}else if(/^RW_/.test(A))this.warn(`Unknown Rainway-reserved RTC label? ${A}`);else{const g=H.decode(I);this.checkHeader(g.header),this.handleChunk(A,g.body)}}getDatagramHeader(A,I){return{magicNumber:2036430674,syncKey:A?I??++this.syncKey:0,sourcePeerId:this.ownPeerId,targetPeerId:this.targetPeerId}}sendArbitraryDatagram(A,I){!function(A,I,g=16e3){const B=Math.ceil(A.length/g),Q=++aI;for(let C=0;C<B;C++){const e=C*g,i=Math.min((C+1)*g,A.length);I({chunksInGroup:B,groupId:Q,index:C,data:A.slice(e,i)})}}(I,(I=>{this.sendMessage(A,H.encode({header:this.getDatagramHeader(!0),body:I}))}))}sendLogicDatagram(A,I){const g=this.getDatagramHeader(!0,I);return this.sendMessage("RW_Logic",f.encode({header:g,body:A})),g.syncKey}sendInputDatagram(A){this.sendMessage("RW_Input",L.encode({header:this.getDatagramHeader(!1),body:A}))}async open(A){await new Promise((async(I,g)=>{this.openResolve=I,this.openReject=g,B(this,rI,iI.Connecting,"f"),this.peerConnection=new RTCPeerConnection(this.rtcConfiguration),this.peerConnection.addEventListener("iceconnectionstatechange",this.handleIceConnectionStateChange),this.peerConnection.addEventListener("connectionstatechange",this.handleConnectionStateChange),this.handleConnectionStateChange(),this.dataChannels??(this.dataChannels={});const Q=Object.keys(this.dataChannelsConfig).length;let C=0;const e=(A,g)=>{const e=()=>{++C,C===Q&&(this.peerConnection?.removeEventListener("icecandidate",this.handleLocalIceCandidate),B(this,rI,iI.Connected,"f"),I()),g.removeEventListener("open",e)};g.addEventListener("open",e),g.addEventListener("close",this.handleDataChannelClose),g.addEventListener("error",this.handleDataChannelError),g.addEventListener("message",this.handleDataChannelMessage)};if("offer"===A)for(const[A,I]of Object.entries(this.dataChannelsConfig)){const g=this.peerConnection.createDataChannel(A,I);this.dataChannels[A]=g,g.binaryType="arraybuffer",e(0,g)}else this.peerConnection.addEventListener("datachannel",(A=>{const I=A.channel.label;this.dataChannels??(this.dataChannels={}),this.dataChannels[I]=A.channel,e(A.channel.label,A.channel)}));this.peerConnection.addEventListener("icecandidate",this.handleLocalIceCandidate),"offer"===A&&await this.sendOffer()}))}async sendOffer(){if(void 0===this.peerConnection)throw new Q("sendOffer(): no peer connection");const A=await this.peerConnection.createOffer();if(await this.peerConnection.setLocalDescription(A),!A.sdp)throw new Q("Created offer contained no sdp?");this.sendLocalOfferSdp(A.sdp)}async sendAnswer(){if(void 0===this.peerConnection)throw new Q("sendOffer(): no peer connection");const A=await this.peerConnection.createAnswer();if(await this.peerConnection.setLocalDescription(A),!A.sdp)throw new Q("Created answer contained no sdp?");this.sendLocalAnswerSdp(A.sdp)}close(){this.status!==iI.Disconnected&&(this.debug("rtc-transport close()."),this.peerConnection?.close(),this.onClose(),this.dispose())}dispose(){if(this.peerConnection?.removeEventListener("iceconnectionstatechange",this.handleIceConnectionStateChange),this.peerConnection?.removeEventListener("connectionstatechange",this.handleConnectionStateChange),this.peerConnection?.removeEventListener("icecandidate",this.handleLocalIceCandidate),this.dataChannels)for(const A of Object.values(this.dataChannels))A.removeEventListener("message",this.handleDataChannelMessage);this.dataChannels=void 0,this.peerConnection=void 0,this.openResolve=void 0,this.openReject=void 0}handleChunk(A,I){I.groupId<this.highestChunkGroup&&(this.chunkedMessages=new Map,this.highestChunkGroup=0);let g=this.chunkedMessages.get(I.groupId);if(g||(g={receivedChunkCount:0,chunks:[]},this.chunkedMessages.set(I.groupId,g)),g.chunks[I.index]=I.data,g.receivedChunkCount++,g.receivedChunkCount===I.chunksInGroup){this.highestChunkGroup=I.groupId,this.chunkedMessages.delete(I.groupId);const B=function(A){let I=0;const g=A.chunks.length;for(let B=0;B<g;B++)I+=A.chunks[B].byteLength;const B=new Uint8Array(I);let Q=0;for(let I=0;I<g;I++){const g=A.chunks[I];B.set(g,Q),Q+=g.byteLength}return B}(g);/^RW_(Logic|Input|Audio|Video)$/.test(A)?this.handleLabelAndData(A,B):this.onApplicationMessage(A,B)}}info(A){BI(DI.name,String(A))}debug(A){QI(DI.name,String(A))}warn(A){gI(DI.name,String(A))}ping(A){const I=this.sendLogicDatagram({discriminator:bA.discriminator,value:{}});return new Promise((B=>{setTimeout((()=>{g(this,hI,"f").delete(I)&&B(!1)}),A),g(this,hI,"f").set(I,{resolve:()=>{g(this,hI,"f").delete(I)&&B(!0)}})}))}async measureLatencyMs(){const A=Date.now();return await this.ping(2e3),(Date.now()-A)/2}}rI=new WeakMap,hI=new WeakMap;const wI={Unidentified:b.None,Cancel:b.Cancel,Backspace:b.Back,Tab:b.Tab,Enter:b.Enter,Pause:b.Pause,CapsLock:b.CapsLock,HangulMode:b.HangulMode,KanaMode:b.HangulMode,Lang1:b.HangulMode,Hanja:b.HanjaMode,Lang2:b.HanjaMode,Escape:b.Escape,Convert:b.ImeConvert,NonConvert:b.ImeNonConvert,Space:b.Space," ":b.Space,Spacebar:b.Space,PageUp:b.PageUp,PageDown:b.PageDown,End:b.End,Home:b.Home,ArrowLeft:b.Left,ArrowUp:b.Up,ArrowRight:b.Right,ArrowDown:b.Down,Select:b.Select,PrintScreen:b.PrintScreen,Insert:b.Insert,Delete:b.Delete,Help:b.Help,Digit0:b.D0,Digit1:b.D1,Digit2:b.D2,Digit3:b.D3,Digit4:b.D4,Digit5:b.D5,Digit6:b.D6,Digit7:b.D7,Digit8:b.D8,Digit9:b.D9,KeyA:b.A,KeyB:b.B,KeyC:b.C,KeyD:b.D,KeyE:b.E,KeyF:b.F,KeyG:b.G,KeyH:b.H,KeyI:b.I,KeyJ:b.J,KeyK:b.K,KeyL:b.L,KeyM:b.M,KeyN:b.N,KeyO:b.O,KeyP:b.P,KeyQ:b.Q,KeyR:b.R,KeyS:b.S,KeyT:b.T,KeyU:b.U,KeyV:b.V,KeyW:b.W,KeyX:b.X,KeyY:b.Y,KeyZ:b.Z,MetaLeft:b.LWin,OSLeft:b.LWin,MetaRight:b.RWin,OSRight:b.RWin,ContextMenu:b.Apps,Sleep:b.Sleep,Numpad0:b.NumPad0,Numpad1:b.NumPad1,Numpad2:b.NumPad2,Numpad3:b.NumPad3,Numpad4:b.NumPad4,Numpad5:b.NumPad5,Numpad6:b.NumPad6,Numpad7:b.NumPad7,Numpad8:b.NumPad8,Numpad9:b.NumPad9,NumpadMultiply:b.Multiply,NumpadAdd:b.Add,NumpadComma:b.Separator,NumpadSubtract:b.Subtract,NumpadDecimal:b.Decimal,NumpadDivide:b.Divide,F1:b.F1,F2:b.F2,F3:b.F3,F4:b.F4,F5:b.F5,F6:b.F6,F7:b.F7,F8:b.F8,F9:b.F9,F10:b.F10,F11:b.F11,F12:b.F12,F13:b.F13,F14:b.F14,F15:b.F15,F16:b.F16,F17:b.F17,F18:b.F18,F19:b.F19,F20:b.F20,F21:b.F21,F22:b.F22,F23:b.F23,F24:b.F24,NumLock:b.NumLock,ScrollLock:b.Scroll,ShiftLeft:b.LeftShift,ShiftRight:b.RightShift,ControlLeft:b.LeftCtrl,ControlRight:b.RightCtrl,AltLeft:b.LeftAlt,AltRight:b.RightAlt,BrowserBack:b.BrowserBack,BrowserForward:b.BrowserForward,BrowserRefresh:b.BrowserRefresh,BrowserStop:b.BrowserStop,BrowserSearch:b.BrowserSearch,BrowserFavorites:b.BrowserFavorites,BrowserHome:b.BrowserHome,AudioVolumeMute:b.VolumeMute,AudioVolumeDown:b.VolumeDown,AudioVolumeUp:b.VolumeUp,MediaTrackNext:b.MediaNextTrack,MediaTrackPrevious:b.MediaPreviousTrack,MediaStop:b.MediaStop,MediaPlayPause:b.MediaPlayPause,LaunchMail:b.LaunchMail,LaunchMediaPlayer:b.SelectMedia,MediaSelect:b.SelectMedia,LaunchApp1:b.LaunchApplication1,LaunchApp2:b.LaunchApplication2,Semicolon:b.Oem1,Equal:b.OemPlus,Comma:b.OemComma,Minus:b.OemMinus,Period:b.OemPeriod,Slash:b.Oem2,Backquote:b.Oem3,BracketLeft:b.Oem4,Backslash:b.Oem5,BracketRight:b.Oem6,Quote:b.Oem7,IntlBackslash:b.Oem102},FI={clickDurationMs:60,dragDelayMs:300,rightClickDelayMs:500,touchSlopRadius:8,doubleTapWindowMs:400,doubleTapRadius:12,scrollGestureThresholdPixels:20,scrollEpsilonPixels:5,scrollSensitivity:4};var SI,yI,GI;function RI(A){return A==yI.left?1:A==yI.middle?4:A==yI.right?2:0}!function(A){A[A.idle=0]="idle",A[A.oneFingerDeciding=1]="oneFingerDeciding",A[A.twoFingersDeciding=2]="twoFingersDeciding",A[A.moving=3]="moving",A[A.dragging=4]="dragging",A[A.holdingRightMouseButton=5]="holdingRightMouseButton",A[A.zooming=6]="zooming",A[A.scrolling=7]="scrolling"}(SI||(SI={})),function(A){A[A.left=0]="left",A[A.middle=1]="middle",A[A.right=2]="right"}(yI||(yI={})),function(A){A[A.pixels=0]="pixels",A[A.lines=1]="lines",A[A.pages=2]="pages"}(GI||(GI={}));class uI{constructor(A,I,g=FI){this.reportPointerEvent=A,this.reportWheelEvent=I,this.parameters=g,this.state=SI.idle,this.primary=void 0,this.secondary=void 0,this.centroidY=0,this.lastTapTime=new Date,this.rightClickTimer=void 0,this.rightClick=()=>{this.reportMouseDown(yI.right),this.toState(SI.holdingRightMouseButton),this.rightClickTimer=void 0},this.tapReleaseTimer=void 0,this.tapRelease=()=>{this.reportMouseUp(yI.left),this.toState(SI.idle),this.rightClickTimer=void 0},this.onPointerDown=A=>{const I={pointerId:A.pointerId,homeOffsetX:A.offsetX,homeOffsetY:A.offsetY,currentOffsetX:A.offsetX,currentOffsetY:A.offsetY,downTime:new Date,awake:!1};void 0===this.primary?(this.toState(SI.oneFingerDeciding),this.primary=I,window.clearTimeout(this.rightClickTimer),this.rightClickTimer=window.setTimeout(this.rightClick,this.parameters.rightClickDelayMs)):void 0===this.secondary&&(this.toState(SI.twoFingersDeciding),this.secondary=I,window.clearTimeout(this.rightClickTimer))},this.onPointerUp=A=>{window.clearTimeout(this.rightClickTimer);const I=A.pointerId===this.primary?.pointerId;if(this.state===SI.oneFingerDeciding&&I){this.log("pointer up from deciding, tapping"),window.clearTimeout(this.rightClickTimer);const I={...A,offsetX:A.offsetX,offsetY:A.offsetY,pointerType:"touch",type:"pointermove"};this.reportPointerEvent(I),this.reportMouseDown(yI.left),this.primary=void 0,this.lastTapTime=new Date,this.tapReleaseTimer=window.setTimeout(this.tapRelease,this.parameters.clickDurationMs)}else this.primary&&this.secondary?(this.log("stopping two finger gesture"),this.primary=void 0,this.secondary=void 0,this.toState(SI.idle)):this.state===SI.moving&&I?(this.log("stop moving"),this.primary=void 0,this.toState(SI.idle)):this.state===SI.dragging&&I?(this.log("stop dragging"),this.reportMouseUp(yI.left),this.primary=void 0,this.toState(SI.idle)):this.state===SI.holdingRightMouseButton&&I&&(this.log("stop right click"),this.reportMouseUp(yI.right),this.primary=void 0,this.toState(SI.idle))},this.onPointerMove=A=>{const I=A.pointerId===this.primary?.pointerId,g=A.pointerId===this.secondary?.pointerId;if(this.primary&&I?(this.primary.currentOffsetX=A.offsetX,this.primary.currentOffsetY=A.offsetY):this.secondary&&g&&(this.secondary.currentOffsetX=A.offsetX,this.secondary.currentOffsetY=A.offsetY),this.primary&&I&&!this.secondary)if(this.state===SI.oneFingerDeciding&&function(A,I){const g=A.currentOffsetX-A.homeOffsetX,B=A.currentOffsetY-A.homeOffsetY;return g*g+B*B>I*I}(this.primary,this.parameters.touchSlopRadius)){this.log("left touch slop radius"),window.clearTimeout(this.rightClickTimer),this.primary.awake=!0;(new Date).valueOf()-this.lastTapTime.valueOf()<this.parameters.dragDelayMs?(this.reportMouseDown(yI.left),this.toState(SI.dragging)):this.toState(SI.moving)}else this.state!==SI.dragging&&this.state!==SI.moving&&this.state!==SI.holdingRightMouseButton||this.reportPointerEvent(A);else if(this.primary&&this.secondary)if(this.state===SI.twoFingersDeciding){const A=this.primary.currentOffsetY-this.primary.homeOffsetY,I=this.secondary.currentOffsetY-this.secondary.homeOffsetY,g=this.parameters.scrollGestureThresholdPixels;(A>g&&I>g||A<g&&I<g)&&(this.toState(SI.scrolling),this.centroidY=(A+I)/2)}else if(this.state===SI.scrolling){const A=this.parameters.scrollEpsilonPixels,I=(this.primary.currentOffsetY-this.primary.homeOffsetY+(this.secondary.currentOffsetY-this.secondary.homeOffsetY))/2;I>this.centroidY+A?(this.reportScroll(this.parameters.scrollSensitivity*A),this.centroidY=I):I<this.centroidY-A&&(this.reportScroll(this.parameters.scrollSensitivity*-A),this.centroidY=I)}}}log(...A){}reportMouseUp(A){this.log("--\x3e report pointerup",A);const I=new PointerEvent("pointerup",{pointerType:"mouse",buttons:0,button:A});this.reportPointerEvent(I)}reportMouseDown(A){this.log("--\x3e report pointerdown",A);const I=new PointerEvent("pointerdown",{pointerType:"mouse",buttons:RI(A),button:A});this.reportPointerEvent(I)}reportScroll(A){const I=new WheelEvent("syntheticWheel",{deltaY:A,deltaMode:GI.pixels});this.reportWheelEvent(I)}toState(A){this.log(["idle","oneFingerDeciding","twoFingersDeciding","moving","dragging","holdingRightMouseButton","zooming","scrolling"][A]),this.state=A}processPointerEvent(A){if("touch"===A.pointerType)switch(A.type){case"pointerdown":this.onPointerDown(A);break;case"pointerup":this.onPointerUp(A);break;case"pointerrawupdate":case"pointermove":this.onPointerMove(A)}else this.reportPointerEvent(A)}}class lI{constructor(A,I,g,B=100){this.correctRemoteCursor=A,this.transformPointerOffsetToRemote=I,this.getCurrentFrameSize=g,this.cursorSyncInterval=B,this.container=void 0,this.video=void 0,this.canvas=void 0,this.cursorDiv=void 0,this.cursorImg=void 0,this.cursorState={visible:!1,x:0,y:0,spotX:0,spotY:0,extentWidth:0,extentHeight:0},this.wantsRemotePosition=!0,this.videoRect=new DOMRect(0,0,0,0),this.windowWidth=void 0,this.windowHeight=void 0,this.drawDebugDot=!1,this.debugDot=void 0,this.canControlMouse=!1,this.setVideoDimensions=()=>{for(const A of[this.video,this.canvas]){if(!A)continue;const I=A.getBoundingClientRect();if(I.width>0&&I.height>0)return this.videoRect=I,void this.applyCursorDivTransform()}},this.cursorSyncCounter=this.cursorSyncInterval,this.videoResizeObserver=new ResizeObserver((()=>{this.setVideoDimensions()})),["webkitfullscreenchange","mozfullscreenchange","fullscreenchange","MSFullscreenChange"].forEach((A=>{document.addEventListener(A,this.setVideoDimensions,!1)})),window.addEventListener("resize",this.setWindowDimensions)}detach(){["webkitfullscreenchange","mozfullscreenchange","fullscreenchange","MSFullscreenChange"].forEach((A=>{document.removeEventListener(A,this.setVideoDimensions,!1)})),window.removeEventListener("resize",this.setWindowDimensions),this.videoResizeObserver.disconnect()}setCanControlMouse(A){this.canControlMouse=A}setWindowDimensions(){this.windowWidth=window.innerWidth,this.windowHeight=window.innerHeight}setContainer(A){this.container=A,A.style.overflow="hidden",this.video&&this.videoResizeObserver.unobserve(this.video),this.canvas&&this.videoResizeObserver.unobserve(this.canvas),this.cursorDiv=void 0;const I=A.childNodes;for(let A=0;A<I.length;A++){const g=I[A];g instanceof HTMLVideoElement?(this.video=g,this.setVideoDimensions(),this.videoResizeObserver.observe(this.video)):g instanceof HTMLCanvasElement&&(g.classList.contains("rainway-canvas")||g.classList.contains("rainway-isolation-canvas"))?(this.canvas=g,this.setVideoDimensions(),this.videoResizeObserver.observe(this.canvas)):g instanceof HTMLDivElement&&(g.className.includes("rainway-cursor")?this.cursorDiv=g:g.className.includes("rainway-debug-dot")&&(this.debugDot=g))}this.cursorDiv||(this.cursorDiv=document.createElement("div"),this.cursorDiv.className="rainway-cursor",this.cursorDiv.style.position="absolute",this.cursorDiv.style.top="0px",this.cursorDiv.style.left="0px",this.cursorDiv.style.zIndex="1",this.cursorDiv.style.pointerEvents="none",this.cursorDiv.style.willChange="transform",this.cursorDiv.style.transformOrigin="top left",this.applyCursorDivTransform(),this.cursorImg=document.createElement("img"),this.cursorDiv.appendChild(this.cursorImg),A.appendChild(this.cursorDiv)),this.drawDebugDot&&!this.debugDot&&(this.debugDot=document.createElement("div"),this.debugDot.className="rainway-debug-dot",this.debugDot.style.position="absolute",this.debugDot.style.top="0px",this.debugDot.style.left="0px",this.debugDot.style.zIndex="1",this.debugDot.style.pointerEvents="none",this.debugDot.style.willChange="transform",this.debugDot.style.transformOrigin="top left",this.debugDot.style.width="3px",this.debugDot.style.height="3px",this.debugDot.style.backgroundColor="#ff0000",A.appendChild(this.debugDot))}unsetContainer(){this.detach(),this.cursorDiv?.remove(),this.debugDot?.remove(),this.container=void 0}computeTransform(A){const{x:I,y:g,spotX:B,spotY:Q}=A,C={left:0,top:0,width:A.extentWidth,height:A.extentHeight},{width:e,height:i}=this.videoRect,t=this.getCurrentFrameSize(),E=t.codecWidth,o=t.codecHeight,a=t.streamBounds??C,s=t.fullDesktopBounds??C,{left:n,top:r,width:h,height:d}=s,{left:c,top:D,width:w,height:F}=a,S=w*E/h,y=F*o/d,G=Math.min(e/S,i/y),R=Math.round(I-B-(c-n)),u=Math.round(g-Q-(D-r)),l=G*E/h,k=G*o/d;return`translate(${Math.round((e-G*S)/2)}px,${Math.round((i-G*y)/2)}px) scale(${l},${k}) translate(${R}px,${u}px)`}applyCursorDivTransform(){this.cursorDiv&&(this.cursorState.visible?(this.cursorDiv.style.visibility="visible",this.cursorDiv.style.transform=this.computeTransform(this.cursorState)):this.cursorDiv.style.visibility="hidden")}moveDebugDotTo(A){this.debugDot&&(this.debugDot.style.transform=this.computeTransform(A))}processCursor(A){if(!this.cursorDiv)return;const I=this.canControlMouse&&("onpointerlockchange"in document?document.pointerLockElement:document.activeElement)===this.container;if(!A.visible||this.cursorState.visible&&I||(this.wantsRemotePosition=!0),this.cursorState.visible=A.visible,this.cursorState.spotX=A.spotX,this.cursorState.spotY=A.spotY,this.cursorState.extentWidth=A.extentWidth,this.cursorState.extentHeight=A.extentHeight,this.drawDebugDot&&this.moveDebugDotTo(A),this.cursorState.visible){if(this.wantsRemotePosition?(this.cursorState.x=A.x,this.cursorState.y=A.y,this.wantsRemotePosition=!1,this.cursorSyncCounter=this.cursorSyncInterval):0==--this.cursorSyncCounter&&(this.correctRemoteCursor(this.cursorState.x,this.cursorState.y),this.cursorSyncCounter=this.cursorSyncInterval),this.cursorDiv.style.width=`${A.shapeWidth}px`,this.cursorDiv.style.height=`${A.shapeHeight}px`,A.hasPointerImage&&this.cursorImg){const I=function(A){let I="";const g=new Uint8Array(A),B=g.byteLength;for(let A=0;A<B;A++)I+=String.fromCharCode(g[A]);return window.btoa(I)}(A.pointerImage);this.cursorImg.src=`data:image/png;base64,${I}`}this.applyCursorDivTransform()}else this.cursorDiv.style.visibility="hidden"}update(A,I,g){if(!this.cursorDiv)return;if("pointermove"!==A.type&&"mousemove"!==A.type)return;if("mouse"!==(A.pointerType??"mouse")){const A=this.transformPointerOffsetToRemote(I,g);A&&(this.cursorState.x=A.x,this.cursorState.y=A.y)}else{const I=this.cursorState,g=A.movementX,B=A.movementY,Q=this.getCurrentFrameSize();if(Q.streamBounds){const{top:A,left:C,height:e,width:i}=Q.streamBounds;this.cursorState.x=Math.max(C,Math.min(I.x+g,C+i)),this.cursorState.y=Math.max(A,Math.min(I.y+B,A+e))}else console.warn("Don't have streamBounds in CursorPainter.update?"),this.cursorState.x=Math.max(0,Math.min(I.x+g,I.extentWidth)),this.cursorState.y=Math.max(0,Math.min(I.y+B,I.extentHeight))}this.applyCursorDivTransform()}}const kI=/Macintosh;.*Safari/.test(navigator.userAgent)&&!/Chrome|Android/i.test(navigator.userAgent);var UI,NI,mI;!function(A){A[A.Gamepad=0]="Gamepad",A[A.MouseAbsolute=1]="MouseAbsolute",A[A.MouseRelative=2]="MouseRelative",A[A.MouseClick=3]="MouseClick",A[A.MouseScroll=4]="MouseScroll",A[A.Keyboard=5]="Keyboard",A[A.PasteText=6]="PasteText",A[A.TouchesAbsolute=7]="TouchesAbsolute",A[A.PenAbsolute=8]="PenAbsolute",A[A.ViewportResize=9]="ViewportResize",A[A.SetClipboardText=10]="SetClipboardText"}(UI||(UI={}));class MI{constructor(A){this.heldKeys=A}get keys(){return this.heldKeys}has(A){return this.heldKeys.has(A)}get ctrl(){return this.heldKeys.has(b.LeftCtrl)||this.heldKeys.has(b.RightCtrl)}get alt(){return this.heldKeys.has(b.LeftAlt)||this.heldKeys.has(b.RightAlt)}get win(){return this.heldKeys.has(b.LWin)||this.heldKeys.has(b.RWin)}get shift(){return this.heldKeys.has(b.LeftShift)||this.heldKeys.has(b.RightShift)}}function LI(A){return A.axes.length>=4&&A.buttons.length>=16}function fI(A,I){if(A===I)return!0;if(A.length!==I.length)return!1;for(let g=0;g<A.length;++g)if(A[g]!==I[g])return!1;return!0}class pI{constructor(A,I={touchGestures:!1,unlockedMousePointer:!1,embraceMouseAcceleration:!1}){this.rainwayStream=A,this.options=I,this.level=yA.None,this.container=void 0,this.heldKeys=new Set,this.alwaysReportGamepadPoll=!0,this.lockPointer=()=>{if(this.options.unlockedMousePointer)return;if(!this.container)return;if(!this.container.requestPointerLock)return;const A=!this.options.embraceMouseAcceleration,I=A?this.container.requestPointerLock({unadjustedMovement:!0}):this.container.requestPointerLock();I instanceof Promise?I.catch((I=>{"NotSupportedError"===I.name&&A&&this.container?.requestPointerLock()})):this.container.onpointerlockerror=()=>{A&&this.container?.requestPointerLock()},this.container.focus()},this.focusContainer=()=>this.container?.focus(),this.onPointerEventWithGestureProcessing=A=>{(A.pointerType&&"mouse"!==A.pointerType||document.pointerLockElement===this.container)&&(this.options.touchGestures&&"touch"===A.pointerType?(A.preventDefault(),this.gestureRecognizer.processPointerEvent(A)):this.onPointerEvent(A))},this.onPointerEventFromGestureRecognizer=A=>{this.onPointerEvent(A)},this.onPointerEvent=A=>{this.cursorPainter.update(A,this.rememberedOffsetX,this.rememberedOffsetY),this.reportPointerEvent(A)},this.scrolledAmount=0,this.onWheelEvent=A=>{this.scrolledAmount+=.05*A.deltaY,this.scrolledAmount>=1?(this.sendVerticalScroll(Math.floor(this.scrolledAmount)),this.scrolledAmount%=1):this.scrolledAmount<=-1&&(this.sendVerticalScroll(Math.ceil(this.scrolledAmount)),this.scrolledAmount%=-1)},this.onKeyboardEvent=A=>{A.preventDefault();const I=wI[A.code],g="keydown"===A.type;I&&(g?this.heldKeys.add(I):this.heldKeys.delete(I),this.sendInputDatagram({discriminator:AA.discriminator,value:{action:g?v.KeyDown:v.KeyUp,keycode:I}}))},this.onGamepadConnectedEvent=A=>{},this.onGamepadDisconnectedEvent=A=>{},this.onDeviceMotion=A=>{},this.onDeviceOrientation=A=>{},this.gamepadCache=new Map,this.pollGamepads=A=>{if(navigator.getGamepads){if(this.container===document.activeElement){const A=[];for(const I of navigator.getGamepads()){if(!I||!LI(I))continue;const g=I.buttons.map((A=>A.value)),B=this.gamepadCache.get(I.index);B&&fI(B.axes,I.axes)&&fI(B.buttonValues,g)||(A.push(this.makeGamepadInputEvent(I)),this.gamepadCache.set(I.index,{axes:[...I.axes],buttonValues:g}))}(this.alwaysReportGamepadPoll||A.length>0)&&this.reportGamepadEvents(A)}this.level&yA.Gamepad&&(this.gamepadFrameHandle=window.requestAnimationFrame(this.pollGamepads))}},this.reportGamepadEvents=A=>{for(const I of A){let A=0;I.buttons.dpadUp&&(A|=1),I.buttons.dpadDown&&(A|=2),I.buttons.dpadLeft&&(A|=4),I.buttons.dpadRight&&(A|=8),I.buttons.start&&(A|=16),I.buttons.select&&(A|=32),I.buttons.leftStickPressed&&(A|=64),I.buttons.rightStickPressed&&(A|=128),I.buttons.leftShoulder&&(A|=256),I.buttons.rightShoulder&&(A|=512),I.buttons.a&&(A|=4096),I.buttons.b&&(A|=8192),I.buttons.x&&(A|=16384),I.buttons.y&&(A|=32768);const g={buttons:A,leftTrigger:Math.round(255*I.buttons.leftTrigger),rightTrigger:Math.round(255*I.buttons.rightTrigger),leftThumbX:Math.round(32767*I.sticks.left.x),leftThumbY:Math.round(32767*-I.sticks.left.y),rightThumbX:Math.round(32767*I.sticks.right.x),rightThumbY:Math.round(32767*-I.sticks.right.y),slot:1};this.sendInputDatagram({discriminator:V.discriminator,value:g})}},this.moveMouseRelativeXY=(A,I)=>{this.sendMouseMove("relative",A,I)},this.moveMouseAbsoluteXY=(A,I)=>{this.sendMouseMove("absolute",A,I)},this.pointerFrameId=0,this.rememberedOffsetX=0,this.rememberedOffsetY=0,this.touches=new Map,this.reportPointerEvent=A=>{if("touch"===A.pointerType||"pen"===A.pointerType){if(document.pointerLockElement===this.container){const I=this.container.clientWidth,g=this.container.clientHeight,B=A.movementX,Q=A.movementY;this.rememberedOffsetX=Math.max(0,Math.min(I,this.rememberedOffsetX+B)),this.rememberedOffsetY=Math.max(0,Math.min(g,this.rememberedOffsetY+Q))}else this.rememberedOffsetX=A.offsetX,this.rememberedOffsetY=A.offsetY;const I=this.rainwayStream.transformPointerOffsetToRemote(this.rememberedOffsetX,this.rememberedOffsetY);if(!I)return;const{x:g,y:B}=I,Q=Math.ceil(A.width/2),C=Math.ceil(A.height/2),{pointerId:e,buttons:i}=A,t="pointercancel"===A.type||"pointerout"===A.type||"pointerleave"===A.type,E=i>0,o=("pointerover"===A.type?P.New:0)|(E?P.InContact:0)|(1==(3&i)?P.FirstButton:0)|(3==(3&i)?P.SecondButton:0)|(A.isPrimary?P.Primary:0)|("pointercancel"===A.type?P.Canceled:0)|("pointerdown"===A.type?P.Down:"pointerup"===A.type?P.Up:P.Update)|(t?E?P.Up:P.Update:P.InRange),a={pointerId:e,frameId:++this.pointerFrameId,pointerFlags:o,x:g,y:B},s=Math.round(A.twist)%360,n=Math.round(1024*A.pressure);if("touch"===A.pointerType){const A={pointerInfo:a,touchMask:W.ContactArea|W.Orientation|W.Pressure,contactLeft:g-Q,contactTop:B-C,contactRight:g+Q,contactBottom:B+C,orientation:s,pressure:n};this.touches.set(e,A),this.sendInputDatagram({discriminator:gA.discriminator,value:{touches:[...this.touches.values()]}}),t&&this.touches.delete(e)}else{const I=(2&i?O.Barrel:0)|(32&i?O.Eraser:0);this.sendInputDatagram({discriminator:BA.discriminator,value:{pointerInfo:a,penMask:T.Pressure|T.Rotation|T.TiltX|T.TiltY,penFlags:I,rotation:s,pressure:n,tiltX:Math.round(A.tiltX),tiltY:Math.round(A.tiltY)}})}}else{if((A.movementX||A.movementY)&&this.sendMouseMove("relative",A.movementX,A.movementY),A.button>-1){const I=function(A){let I,g;switch(A.button){default:case 0:I=0!=(1&A.buttons),g=q.Left;break;case 1:I=0!=(4&A.buttons),g=q.Middle;break;case 2:I=0!=(2&A.buttons),g=q.Right;break;case 3:I=0!=(8&A.buttons),g=q.X1;break;case 4:I=0!=(16&A.buttons),g=q.X2}return{button:g,action:I?K.ButtonDown:K.ButtonUp}}(A);this.sendMouseClick(I)}}},this.cursorPainter=new lI(this.moveMouseAbsoluteXY,((A,I)=>this.rainwayStream.transformPointerOffsetToRemote(A,I)),(()=>this.rainwayStream.currentFrameSize)),this.gestureRecognizer=new uI(this.onPointerEventFromGestureRecognizer,this.onWheelEvent),this.outgoingInputFilter=()=>!0}setContainer(A){if(this.cursorPainter.setContainer(A),this.container){const I=this.level;this.setInputLevel(yA.None,!1),this.container=A,this.setInputLevel(I,!1)}else this.container=A}unsetContainer(){this.setInputLevel(yA.None,!1),this.cursorPainter.unsetContainer(),this.container=void 0}setInputLevel(A,I=!0,g=!0){this.alwaysReportGamepadPoll=g;const B=A&~this.level,Q=this.level&~A;this.level=A,B&yA.Gamepad&&this.startGamepad(I),Q&yA.Gamepad&&this.stopGamepad(),B&yA.Mouse&&this.startMouse(),Q&yA.Mouse&&this.stopMouse(),B&yA.Keyboard&&this.startKeyboard(),Q&yA.Keyboard&&this.stopKeyboard(),this.cursorPainter.setCanControlMouse(0!=(A&yA.Mouse))}getInputLevel(){return this.level}startGamepad(A){window.addEventListener("gamepadconnected",this.onGamepadConnectedEvent),window.addEventListener("gamepaddisconnected",this.onGamepadDisconnectedEvent),this.gamepadFrameHandle=window.requestAnimationFrame(this.pollGamepads),A&&this.reportConnectedGamepads()}reportConnectedGamepads(){for(const A of navigator.getGamepads())A&&this.onGamepadConnectedEvent(new GamepadEvent("gamepadconnected",{gamepad:A}))}stopGamepad(){window.removeEventListener("gamepadconnected",this.onGamepadConnectedEvent),window.removeEventListener("gamepaddisconnected",this.onGamepadDisconnectedEvent),this.gamepadFrameHandle&&window.cancelAnimationFrame(this.gamepadFrameHandle),this.gamepadFrameHandle=void 0}pointerEventListeners(A){if(!window.PointerEvent)throw new Error("browser does not support PointerEvent");A(kI&&navigator.maxTouchPoints<1?"mousemove":window.onpointerrawupdate?"pointerrawupdate":"pointermove",this.onPointerEventWithGestureProcessing),A("pointerdown",this.onPointerEventWithGestureProcessing),A("pointerup",this.onPointerEventWithGestureProcessing),A("pointerover",this.onPointerEventWithGestureProcessing),A("pointerenter",this.onPointerEventWithGestureProcessing),A("pointercancel",this.onPointerEventWithGestureProcessing),A("pointerout",this.onPointerEventWithGestureProcessing),A("pointerleave",this.onPointerEventWithGestureProcessing);A("wheel",this.onWheelEvent),A("mouseup",this.lockPointer)}startMouse(){if(!this.container)throw new Q("Rainway tried to add an event listener to its container to handle mouse input, but no container element is set. Try calling setContainer() first.");this.pointerEventListeners(this.container.addEventListener.bind(this.container))}stopMouse(){this.container&&this.pointerEventListeners(this.container.removeEventListener.bind(this.container))}startKeyboard(){if(!this.container)throw new Q("Rainway tried to add an event listener to its container to handle keyboard input, but no container element is set. Try calling setContainer() first.");this.container.addEventListener("keydown",this.onKeyboardEvent),this.container.addEventListener("keyup",this.onKeyboardEvent),this.container.addEventListener("click",this.focusContainer),this.container.focus()}stopKeyboard(){this.container&&(this.releaseKeys(),this.container.removeEventListener("keydown",this.onKeyboardEvent),this.container.removeEventListener("keyup",this.onKeyboardEvent),this.container.removeEventListener("click",this.focusContainer))}startDeviceMotionEvents(){window.addEventListener("devicemotion",this.onDeviceMotion)}stopDeviceMotionEvents(){window.removeEventListener("devicemotion",this.onDeviceMotion)}startDeviceOrientationEvents(){window.addEventListener("deviceorientation",this.onDeviceOrientation)}stopDeviceOrientationEvents(){window.removeEventListener("deviceorientation",this.onDeviceOrientation)}sendVerticalScroll(A){this.sendInputDatagram({discriminator:$.discriminator,value:{axis:Y.Vertical,delta:A}})}makeGamepadInputEvent(A){return{id:A.id,index:A.index,buttons:{a:A.buttons[0]?.value??0,b:A.buttons[1]?.value??0,x:A.buttons[2]?.value??0,y:A.buttons[3]?.value??0,leftShoulder:A.buttons[4]?.value??0,rightShoulder:A.buttons[5]?.value??0,leftTrigger:A.buttons[6]?.value??0,rightTrigger:A.buttons[7]?.value??0,select:A.buttons[8]?.value??0,start:A.buttons[9]?.value??0,leftStickPressed:A.buttons[10]?.value??0,rightStickPressed:A.buttons[11]?.value??0,dpadUp:A.buttons[12]?.value??0,dpadDown:A.buttons[13]?.value??0,dpadLeft:A.buttons[14]?.value??0,dpadRight:A.buttons[15]?.value??0,home:A.buttons[16]?.value??0},sticks:{left:{x:A.axes[0]??0,y:A.axes[1]??0},right:{x:A.axes[2]??0,y:A.axes[3]??0}}}}feedGamepadInputEvent(A){this.reportGamepadEvents(A)}static vibrateGamepad(A,I){const g=navigator.getGamepads()[A];if(g?.vibrationActuator)g.vibrationActuator.playEffect?.("dual-rumble",I);else if(g?.hapticActuators){const A=g?.hapticActuators;setTimeout((()=>{for(const g of A)if("pulse"in g){const A=Math.max(I.strongMagnitude??0,I.weakMagnitude??0);g.pulse(A,I.duration??0)}}),I.startDelay)}}feedKeyboardEvent(A){this.onKeyboardEvent(A)}releaseKeys(){for(const A of this.heldKeys)this.sendInputDatagram({discriminator:AA.discriminator,value:{action:v.KeyUp,keycode:A}});this.heldKeys.clear()}feedPointerEvent(A){this.onPointerEvent(A)}feedWheelEvent(A){this.onWheelEvent(A)}processCursor(A){this.cursorPainter.processCursor(A)}enableGestures(){this.options.touchGestures=!0}disableGestures(){this.options.touchGestures=!1}sendMouseMove(A,I,g){"absolute"===A?this.sendInputDatagram({discriminator:Z.discriminator,value:{x:I,y:g}}):this.sendInputDatagram({discriminator:z.discriminator,value:{dx:I,dy:g}})}sendMouseClick(A){this.sendInputDatagram({discriminator:_.discriminator,value:A})}sendInputDatagram(A){this.rainwayStream.handleOutgoingInput(A,new MI(this.heldKeys))}dispose(){this.unsetContainer()}}class HI{constructor(A,I){this.sizeMs=A,this.averageOperation=I,this.cachedAverage=void 0,this.buffer=[]}get values(){return this.trim(),this.buffer.map((A=>A.value))}get measurements(){return this.trim(),this.buffer}trim(){const A=performance.now(),I=this.buffer.findIndex((I=>I.time>A-this.sizeMs));I>0?(this.buffer.splice(0,I),this.cachedAverage=void 0):-1===I&&(this.buffer.splice(0,this.buffer.length),this.cachedAverage=void 0)}feed(A){const I=performance.now();this.buffer.push({time:I,value:A}),this.buffer.length>=500&&this.trim(),this.cachedAverage=void 0}average(){if(this.trim(),this.cachedAverage)return this.cachedAverage;const A=this.buffer.map((A=>A.value));return this.cachedAverage=this.averageOperation(A)}}function JI(A){if(0===A.length)return NaN;const I=A.length,g=A.reduce(((A,I)=>A+I),0)/I;return Math.sqrt(A.map((A=>Math.pow(A-g,2))).reduce(((A,I)=>A+I),0)/I)}function KI(A){if(0===A.length)return NaN;let I=0;for(const g of A)I+=g;return I/A.length}function qI(A){return 0===A.length?0:KI(A)}function YI(A){const I=A.data;return`video/mp4; codecs="avc1.${(I[5]<<16|I[6]<<8|I[7]).toString(16).padStart(6,"0")}"`}function vI(A){if(!("MediaSource"in window))return!1;const I=A.data;if(I.length<8||7!=(31&I[4]))return!1;const g=YI(A);return MediaSource.isTypeSupported(g)}function bI(A){const I=A.data;if(I.length<8||7!=(31&I[4]))return tA.Baseline;const g=I[5];I[6];return 116==g||122==g||110==g||100==g?tA.High:88==g||77==g?tA.Main:tA.Baseline}!function(A){A[A.Detached=0]="Detached",A[A.Initializing=1]="Initializing",A[A.WaitingForKeyframe=2]="WaitingForKeyframe",A[A.Playing=3]="Playing",A[A.Paused=4]="Paused",A[A.Disposed=5]="Disposed"}(NI||(NI={})),function(A){A[A.Up=0]="Up",A[A.Down=1]="Down"}(mI||(mI={}));const PI={beatMs:2500,windowMs:4500,badBeats:2,goodBeats:4,backoffFactor:2,latenessThresholdMs:200,latenessSmoothingFactor:.9375,badLateFrameRatio:.75,initialBitrateKbps:Number(new URLSearchParams(window.location.search).get("initial-bitrate")??5e3),qualityStepFactor:1.1875};class xI{constructor(A=PI,I,g,B){this.chosenVideoConfig=I,this.suggestBitrateKbps=g,this.performanceMonitor=B,this.badBeatCount=0,this.goodBeatCount=0,this.lastAdjustment=void 0,this.history=[],this.lowestDelta=void 0,this.smoothLateness=0,this.framesThisBeat=0,this.lateFramesThisBeat=0,this.debugLatenessSmoothing=!1,this.badCpuPerfThisBeat=!1,this.badDecoderPerfThisBeat=!1,this.badCpuPerfHandler=()=>{this.badCpuPerfThisBeat=!0},this.badDecoderPerfHandler=()=>{this.badDecoderPerfThisBeat=!0},this.handleVideoReadyState=A=>{A===NI.Detached||A===NI.Paused||A===NI.WaitingForKeyframe?this.stop():this.start()},this.check=async()=>{0!==this.framesThisBeat&&(await this.beatIsBad()?this.badBeat():this.goodBeat(),this.framesThisBeat=0,this.lateFramesThisBeat=0,this.badCpuPerfThisBeat=!1,this.badDecoderPerfThisBeat=!1)},this.ownMaximumKbps=1/0,this.chosenVideoConfigMimeType=YI(I.codec),this.parameters={...PI,...A},this.currentBitrateKbps=this.parameters.initialBitrateKbps,this.frameVarianceMs=new HI(this.parameters.windowMs,JI)}getStats(){return{videoBitrateKbps:this.currentBitrateKbps,latenessMs:this.smoothLateness}}format(A){return`[${this.currentBitrateKbps.toFixed(0)+"kbps"}, +${this.smoothLateness.toFixed(0)}ms] ${A}`}debug(A){QI(xI.name,this.format(A))}info(A){BI(xI.name,this.format(A))}start(){this.checkInterval||(this.info("Starting rate control!"),this.checkInterval=window.setInterval(this.check,this.parameters.beatMs),this.performanceMonitor?.cpuStarvationEvent.addHandler(this.badCpuPerfHandler),this.performanceMonitor?.decoderStrugglingEvent.addHandler(this.badDecoderPerfHandler))}stop(){this.checkInterval&&(this.info("Stopping rate control!"),window.clearInterval(this.checkInterval),this.checkInterval=void 0,this.performanceMonitor?.cpuStarvationEvent.removeHandler(this.badCpuPerfHandler),this.performanceMonitor?.decoderStrugglingEvent.removeHandler(this.badDecoderPerfHandler))}feedFrameTimestamp(A){const I=performance.now()-A;(void 0===this.lowestDelta||I<this.lowestDelta||Math.abs(this.lowestDelta-I)>5e4)&&(this.lowestDelta=I);const g=I-this.lowestDelta,B=this.parameters.latenessSmoothingFactor;if(this.smoothLateness=B*this.smoothLateness+(1-B)*g,this.framesThisBeat++,this.smoothLateness>=this.parameters.latenessThresholdMs&&this.lateFramesThisBeat++,this.debugLatenessSmoothing){const A=new Array(100);A.fill("-");const I=g,B=this.smoothLateness;A[50]=".",A[Math.max(0,Math.min(Math.round(I/10+50),99))]="L",A[Math.max(0,Math.min(Math.round(B/10+50),99))]="S",this.beatIsBad().then((g=>this.debug(`${A.join("")} L=${I} S=${B} bad=${g} ld=${this.lowestDelta}`)))}}decodingInfoAtBitrate(A){return navigator.mediaCapabilities.decodingInfo({type:"media-source",video:{width:this.chosenVideoConfig.codec.width,height:this.chosenVideoConfig.codec.height,framerate:this.chosenVideoConfig.codec.refreshRate,bitrate:1e3*A,contentType:YI(this.chosenVideoConfig.codec)}})}async capabilitiesBad(){if(!("MediaSource"in window))return!1;if(!("mediaCapabilities"in navigator))return!1;const A=await this.decodingInfoAtBitrate(this.currentBitrateKbps),I=await this.decodingInfoAtBitrate(this.bitrateOneStepDownKbps());return I.smooth&&!A.smooth||I.powerEfficient&&!A.powerEfficient}lateFrameRatioBad(){return this.lateFramesThisBeat/this.framesThisBeat>=this.parameters.badLateFrameRatio}async beatIsBad(){return this.badDecoderPerfThisBeat||this.badCpuPerfThisBeat||this.lateFrameRatioBad()||await this.capabilitiesBad()}badBeat(){if(this.currentBitrateKbps<=this.lowestSupportedBitrateKbps())return void this.debug(`crashed at ${this.currentBitrateKbps.toFixed(0)}kbps, ignoring bad beat`);this.badBeatCount++,this.goodBeatCount=0;const A=this.parameters.badBeats;if(this.debug(`bad beat: ${this.badBeatCount}/${A}`),this.badBeatCount>=this.parameters.badBeats){this.goodBeatCount=this.badBeatCount=0;const A=this.lastAdjustment===mI.Up;this.qualityDown(),this.debug("went down in quality"),A&&this.currentBitrateKbps<this.ownMaximumKbps&&(this.ownMaximumKbps=this.currentBitrateKbps,this.info(`setting a new maximum at ${this.ownMaximumKbps.toFixed(0)}kbps`))}}goodBeat(){if(this.currentBitrateKbps>=this.ownMaximumKbps||this.currentBitrateKbps>=this.highestSupportedBitrateKbps())return this.debug(`maxed at ${this.currentBitrateKbps.toFixed(0)}kbps, ignoring good beat`),void(this.badBeatCount=0);this.goodBeatCount++,this.badBeatCount=0;const A=this.parameters.goodBeats;this.debug(`good beat: ${this.goodBeatCount}/${A}`),this.goodBeatCount>=A&&(this.goodBeatCount=this.badBeatCount=0,this.qualityUp(),this.debug("went up in quality"))}bitrateOneStepUpKbps(){return Math.min(this.highestSupportedBitrateKbps(),this.currentBitrateKbps*this.parameters.qualityStepFactor)}bitrateOneStepDownKbps(){return Math.max(this.lowestSupportedBitrateKbps(),this.currentBitrateKbps/this.parameters.qualityStepFactor)}qualityUp(){const A=this.bitrateOneStepUpKbps();this.suggestBitrateKbps(A,this.currentBitrateKbps),this.currentBitrateKbps=A,this.lastAdjustment=mI.Up,this.history.push({time:performance.now(),bitrate:this.currentBitrateKbps})}qualityDown(){const A=this.bitrateOneStepDownKbps();this.suggestBitrateKbps(A,this.currentBitrateKbps),this.currentBitrateKbps=A,this.lastAdjustment=mI.Down,this.history.push({time:performance.now(),bitrate:this.currentBitrateKbps}),this.lowestDelta=void 0}lowestSupportedBitrateKbps(){return Number(new URLSearchParams(window.location.search).get("lowest-bitrate")??5e3)}highestSupportedBitrateKbps(){return Number(new URLSearchParams(window.location.search).get("max-bitrate")??1e4)}}function WI(A){const{filtered:I,preferred:g}=function(A){if(0===A.length)throw new Error("Host supplied an empty CodecPack");let I=A.filter(vI);if(0===I.length&&(console.warn("Found no browser-confirmed working codec, falling back to baseline"),I=A.filter((A=>bI(A)<=tA.Baseline))),0===I.length)throw new Error("Host supplied an unsupported CodecPack");const g=I.reduce(((A,I)=>bI(A)>bI(I)?A:I));return{filtered:I,preferred:g}}(A),B={codec:hA.Opus,container:dA.Raw},Q="MediaSource"in window?cA.IsoBMFF:cA.Raw,C=!!window.chrome;return{preferredWidth:screen.availWidth,preferredHeight:screen.availHeight,preferredFps:60,preferredAudioBitrate:96e3,preferredVideoBitrate:1e3*PI.initialBitrateKbps,preferredAudioChannels:rA.Stereo,preferredAudioConfig:B,preferredVideoConfig:{codec:g,container:Q},supportedAudioChannels:[rA.Mono,rA.Stereo],supportedAudioConfigs:[B],supportedVideoConfigs:I.map((A=>({codec:A,container:Q}))),supportsOver1080P:!1,supportsTemporalScaling:!0,supportsAppIsolation:C}}var TI;class OI extends Error{}async function XI(A,I){if(!window.MediaSource)throw new OI("Browser does not support MSE.");const g=new MediaSource,B=window.URL.createObjectURL(g);A.src=void 0,A.src=B,A.load();const Q=await async function(A,I){return new Promise(((g,B)=>{let Q=!1;const C=()=>{A.removeEventListener("sourceopen",e),I?.removeHandler(E),window.clearInterval(t),Q=!0},e=()=>{C(),g(!0)},i=()=>{Q||"open"===A.readyState&&(C(),g(!0))},t=window.setInterval(i,500);i(),window.setTimeout((()=>{Q||(C(),B(new Error("MediaSource open timed out.")))}),1e4),A.addEventListener("sourceopen",e);const E=()=>{C(),g(!1)};I?.addHandler(E)}))}(g,I);if(Q)return g.duration=Number.POSITIVE_INFINITY,g}function VI(A){return 0===A.length?0:A.reduce(((A,I)=>A+I),0)/A.length}class jI{constructor(A){this.maxLength=A,this.nextIndex=0,this.list=Array(this.maxLength),TI.set(this,0)}get length(){return g(this,TI,"f")}push(A){this.list[this.nextIndex++]=A,B(this,TI,Math.max(g(this,TI,"f"),this.nextIndex),"f"),this.nextIndex%=this.maxLength}values(){return this.list.slice(0,g(this,TI,"f"))}}TI=new WeakMap;class ZI{constructor(){this.processingDurations=new Map,this.dataIntervals=new jI(60),this.dataSizes=new jI(60),this.totalFrames=0,this.presentedFrames=0}pushFrameMetadata(A){this.presentedFrames+=1;const{processingDuration:I}=A,g=(new Date).getTime();this.processingDurations.set(g,I);for(const[A]of this.processingDurations.entries())A<g-1e3&&this.processingDurations.delete(A)}reportFrameSubmitted(){this.totalFrames+=1}resetFrameCounts(){this.totalFrames=0,this.presentedFrames=0}pushData(A){this.dataSizes.push(A.byteLength);const I=(new Date).getTime();this.lastDataTimestamp&&this.dataIntervals.push(I-this.lastDataTimestamp),this.lastDataTimestamp=I}setElement(A){this.element=A}getReportMSE(A){if(!this.element)throw new Q("getReport() has no video element");const I=VI(Array.from(this.processingDurations.values())),g=this.element.buffered,B=g.length>0?g.end(g.length-1):0,C=this.element.seekable,e=C.length>0?C.end(C.length-1):0;return{processingDuration:I,droppedFrames:this.totalFrames-this.presentedFrames,totalFrames:this.totalFrames,dataInterval:VI(this.dataIntervals.values()),dataSize:VI(this.dataSizes.values()),currentTime:this.element.currentTime,endOfBuffered:B,endOfSeekable:e,videoReadyState:A}}getReportSoftwareDecoder(A,I,g){return{processingDuration:VI(Array.from(this.processingDurations.values())),droppedFrames:A??0,totalFrames:I??0,dataInterval:VI(this.dataIntervals.values()),dataSize:VI(this.dataSizes.values()),currentTime:0,endOfBuffered:0,endOfSeekable:0,videoReadyState:g}}}function zI(A){return 102===A[4]&&116===A[5]&&121===A[6]&&112===A[7]}class _I{constructor(A){this.codecString=A,this.readyState=NI.Detached,this.needsRestartEvent=new _A,this.sourceOpenEvent=new _A,this.readyStateChangeEvent=new _A,this.videoFrameEvent=new _A,this.videoFrameProcessingDurationEvent=new _A,this.cancelInitializeEvent=new _A,this.dataQueue=[],this.stats=new ZI,this.justClearedBuffer=!1,this.lastBufferEnd=0,this.framesFrozenFor=0,this.ensureBuffer=()=>{if(this.readyState!==NI.Paused&&this.readyState!==NI.Detached&&this.element&&0===this.element.buffered.length){if(this.sourceBuffer&&!this.sourceBuffer.updating&&this.sourceBuffer.timestampOffset<=0){const A=this.sourceBuffer.timestampOffset.toFixed(2);this.sourceBuffer.timestampOffset=1;const I=this.sourceBuffer.timestampOffset.toFixed(2);this.warn(`Poked timestampOffset from ${A} to ${I}`)}this.restart("ensureBuffer")}},this.videoFrameHandler=(A,I)=>{I?.processingDuration&&this.videoFrameProcessingDurationEvent.invoke(I.processingDuration),I&&this.stats.pushFrameMetadata(I),this.videoFrameEvent.invoke([A,I]),this.requestNextFrameCallback()},this.fallbackVideoFrameHandler=A=>{this.videoFrameHandler(A,void 0)},this.sourceBufferUpdateHandler=()=>{this.submitData()}}info(A){BI(_I.name,String(A))}debug(A){QI(_I.name,String(A))}warn(A){gI(_I.name,String(A))}get dataQueueLength(){return this.dataQueue.length}attachToElement(A){this.info("Attaching to element: "+A),this.cancelInitializeEvent.invoke(),this.element=A,this.stats.setElement(this.element),this.stats.resetFrameCounts(),this.restart("attachToElement"),this.info("Attached to element.")}detachFromElement(){this.destroyMedia(),this.element=void 0,this.setReadyState(NI.Detached),this.info("Detached from element.")}pause(){this.setReadyState(NI.Paused)}play(){this.readyState===NI.Paused&&this.restart("play")}pushData(A){if(this.dataQueue.length>8)return void this.restart("pushData.dataQueue too long");const I=new Uint8Array(A.data);return this.stats.pushData(I),this.readyState!==NI.Paused?zI(I)&&this.readyState===NI.WaitingForKeyframe&&this.element?(this.debug(`Got requested keyframe (${I.length} bytes)`),this.getStats(),this.dataQueue.push(I),this.submitData(),void this.initializeMedia()):void(this.readyState!==NI.WaitingForKeyframe&&this.element?(this.dataQueue.push(I),this.submitData()):this.startEnsuringBuffer()):void 0}getStats(){return this.stats.getReportMSE(this.readyState)}setReadyState(A){this.info(`ReadyState changed: ${NI[this.readyState]} => ${NI[A]}`),this.readyState=A,this.readyStateChangeEvent.invoke(A)}submitData(){if(0!==this.dataQueue.length)if(void 0!==this.mediaSource)if(this.sourceBuffer){if(!this.sourceBuffer.updating)if(this.element){if(this.sourceBuffer.buffered.length>=1){const A=this.sourceBuffer.buffered.end(this.sourceBuffer.buffered.length-1);this.justClearedBuffer&&(this.element.currentTime=A,this.justClearedBuffer=!1),A===this.lastBufferEnd?(this.framesFrozenFor++,this.debug(`Frozen for ${this.framesFrozenFor} frames...`)):this.framesFrozenFor=0,this.lastBufferEnd=A}if(this.framesFrozenFor>=4)return this.restart("sourceBuffer FrozenFrames"),void(this.framesFrozenFor=0);try{const A=this.dataQueue[0];if(zI(A)&&!this.justClearedBuffer)return this.debug("Got keyframe. Clearing sourcebuffer."),this.getStats(),this.sourceBuffer.remove(0,1/0),void(this.justClearedBuffer=!0);this.dataQueue.shift(),this.sourceBuffer.appendBuffer(A),this.stats.reportFrameSubmitted()}catch(A){II(_I.name,String(A)),this.restart("submitData, sourceBuffer.appendBuffer error.")}}else this.debug("Idling because !element")}else this.debug("Idling because !sourceBuffer");else this.debug("Idling because mediaSource === undefined")}async initializeMedia(){if(this.setReadyState(NI.Initializing),this.cancelInitializeEvent.invoke(),void 0!==this.mediaSource)return this.setReadyState(NI.Playing),void this.element?.play();if(!this.element)throw new Error("Stream not attached to element.");try{const A=await XI(this.element,this.cancelInitializeEvent);if(!A)return void this.setReadyState(NI.WaitingForKeyframe);this.mediaSource=A,this.sourceBuffer=function(A,I){const g=A.addSourceBuffer(I);return g.mode="sequence",g}(this.mediaSource,this.codecString),this.sourceBuffer.addEventListener("updateend",this.sourceBufferUpdateHandler),this.sourceBuffer.addEventListener("error",(A=>this.debug(`sourceBuffer error: ${A}`))),this.startEnsuringBuffer(),this.setReadyState(NI.Playing),this.requestNextFrameCallback(),this.submitData(),this.element?.play()}catch(A){this.setReadyState(NI.WaitingForKeyframe)}}startEnsuringBuffer(){void 0===this.ensureBufferInterval&&(this.debug("Starting ensureBuffer loop"),this.ensureBufferInterval=window.setInterval(this.ensureBuffer,1e3))}destroyMedia(){if(this.debug("destroyMedia() called"),void 0!==this.mediaSource){if(this.cancelFrameCallback(),this.element?.pause(),this.sourceBuffer?.removeEventListener("updateend",this.sourceBufferUpdateHandler),this.mediaSource){if(this.sourceBuffer){try{this.mediaSource.removeSourceBuffer(this.sourceBuffer)}catch(A){}this.sourceBuffer=void 0}if("open"===this.mediaSource.readyState)try{this.mediaSource.endOfStream()}catch(A){}this.mediaSource=void 0,this.element&&window.URL.revokeObjectURL(this.element.src)}window.clearInterval(this.ensureBufferInterval),this.ensureBufferInterval=void 0,this.setReadyState(NI.WaitingForKeyframe)}}restart(A=""){const I=A?`Restarting Video Stream... Reason: '${A}'.`:"Restarting Video Stream.";this.warn(I),this.dataQueue=[],this.setReadyState(NI.WaitingForKeyframe),this.needsRestartEvent.invoke()}requestNextFrameCallback(){"requestVideoFrameCallback"in HTMLVideoElement.prototype?(this.frameHandle&&(this.element?.cancelVideoFrameCallback?.(this.frameHandle),this.frameHandle=void 0),this.frameHandle=this.element?.requestVideoFrameCallback?.(this.videoFrameHandler)):(this.frameHandle&&(window.cancelAnimationFrame(this.frameHandle),this.frameHandle=void 0),this.frameHandle=window.requestAnimationFrame(this.fallbackVideoFrameHandler))}cancelFrameCallback(){"requestVideoFrameCallback"in HTMLVideoElement.prototype?this.frameHandle&&(this.element?.cancelVideoFrameCallback?.(this.frameHandle),this.frameHandle=void 0):this.frameHandle&&(window.cancelAnimationFrame(this.frameHandle),this.frameHandle=void 0)}dispose(){this.cancelFrameCallback(),this.destroyMedia(),window.clearInterval(this.ensureBufferInterval),this.setReadyState(NI.Disposed)}}function $I(A){return A&&A.__esModule&&Object.prototype.hasOwnProperty.call(A,"default")?A.default:A}var Ag={exports:{}};self;var Ig=$I(Ag.exports=(()=>{var A={114:function(A,I,g){var B=this&&this.__importDefault||function(A){return A&&A.__esModule?A:{default:A}};Object.defineProperty(I,"__esModule",{value:!0});const Q=B(g(289));I.default=class{initialize(){return new Promise(((A,I)=>{this.worker=new Q.default,this.worker.addEventListener("message",(I=>{var g;const B=I.data;"decoderReady"===B.type?A(0):"decodeDone"===B.type&&(null===(g=this.onDecode)||void 0===g||g.call(this,B))}))}))}startStream(A,I,g){this.worker&&this.worker.postMessage({type:"startStream",sampleRateHz:A,channelCount:I,decodedSamplesPerFrame:g})}stopStream(){this.worker&&this.worker.postMessage({type:"stopStream"})}decode(A,I){this.worker&&this.worker.postMessage({type:"decode",startTimestamp:A,inputData:I},[I])}release(){this.worker&&this.worker.postMessage({type:"release"})}dispose(){this.worker&&(this.worker.terminate(),this.worker=void 0)}}},289:(A,I,g)=>{g.r(I),g.d(I,{default:()=>C});var B=g(614),Q=g.n(B);function C(){return Q()('(()=>{var A={305:A=>{var I,g=(I="undefined"!=typeof document&&document.currentScript?document.currentScript.src:void 0,function(A){var g,B;(A=void 0!==(A=A||{})?A:{}).ready=new Promise((function(A,I){g=A,B=I}));var Q,C={};for(Q in A)A.hasOwnProperty(Q)&&(C[Q]=A[Q]);var E=[],i="./this.program",D=function(A,I){throw I},o="";"undefined"!=typeof document&&document.currentScript&&(o=document.currentScript.src),I&&(o=I),o=0!==o.indexOf("blob:")?o.substr(0,o.lastIndexOf("/")+1):"";var w,F,G=A.print||console.log.bind(console),R=A.printErr||console.warn.bind(console);for(Q in C)C.hasOwnProperty(Q)&&(A[Q]=C[Q]);C=null,A.arguments&&(E=A.arguments),A.thisProgram&&(i=A.thisProgram),A.quit&&(D=A.quit),A.wasmBinary&&(w=A.wasmBinary),A.noExitRuntime&&(F=A.noExitRuntime),"object"!=typeof WebAssembly&&n("no native wasm support detected");var S=!1;function U(I){var g,B=A["_"+I];return g="Cannot call unknown function "+I+", make sure it is exported",B||n("Assertion failed: "+g),B}function a(A,I,g,B,Q){var C={string:function(A){var I=0;if(null!=A&&0!==A){var g=1+(A.length<<2);!function(A,I,g){J(A,k,I,g)}(A,I=V(g),g)}return I},array:function(A){var I,g,B=V(A.length);return I=A,g=B,s.set(I,g),B}},E=U(A),i=[],D=0;if(B)for(var o=0;o<B.length;o++){var w=C[g[o]];w?(0===D&&(D=X()),i[o]=w(B[o])):i[o]=B[o]}var F=E.apply(null,i);return F=function(A){return"string"===I?H(A):"boolean"===I?Boolean(A):A}(F),0!==D&&Z(D),F}var s,k,h,N="undefined"!=typeof TextDecoder?new TextDecoder("utf8"):void 0;function y(A,I,g){for(var B=I+g,Q=I;A[Q]&&!(Q>=B);)++Q;if(Q-I>16&&A.subarray&&N)return N.decode(A.subarray(I,Q));for(var C="";I<Q;){var E=A[I++];if(128&E){var i=63&A[I++];if(192!=(224&E)){var D=63&A[I++];if((E=224==(240&E)?(15&E)<<12|i<<6|D:(7&E)<<18|i<<12|D<<6|63&A[I++])<65536)C+=String.fromCharCode(E);else{var o=E-65536;C+=String.fromCharCode(55296|o>>10,56320|1023&o)}}else C+=String.fromCharCode((31&E)<<6|i)}else C+=String.fromCharCode(E)}return C}function H(A,I){return A?y(k,A,I):""}function J(A,I,g,B){if(!(B>0))return 0;for(var Q=g,C=g+B-1,E=0;E<A.length;++E){var i=A.charCodeAt(E);if(i>=55296&&i<=57343&&(i=65536+((1023&i)<<10)|1023&A.charCodeAt(++E)),i<=127){if(g>=C)break;I[g++]=i}else if(i<=2047){if(g+1>=C)break;I[g++]=192|i>>6,I[g++]=128|63&i}else if(i<=65535){if(g+2>=C)break;I[g++]=224|i>>12,I[g++]=128|i>>6&63,I[g++]=128|63&i}else{if(g+3>=C)break;I[g++]=240|i>>18,I[g++]=128|i>>12&63,I[g++]=128|i>>6&63,I[g++]=128|63&i}}return I[g]=0,g-Q}function L(A){var I=function(A){for(var I=0,g=0;g<A.length;++g){var B=A.charCodeAt(g);B>=55296&&B<=57343&&(B=65536+((1023&B)<<10)|1023&A.charCodeAt(++g)),B<=127?++I:I+=B<=2047?2:B<=65535?3:4}return I}(A)+1,g=V(I);return J(A,s,g,I),g}A.INITIAL_MEMORY;var q,M=[],K=[],c=[],Y=[];K.push({func:function(){l()}});var d=0,P=null,t=null;function n(I){A.onAbort&&A.onAbort(I),R(I+=""),S=!0,I="abort("+I+"). Build with -s ASSERTIONS=1 for more info.";var g=new WebAssembly.RuntimeError(I);throw B(g),g}A.preloadedImages={},A.preloadedAudios={};var r="data:application/octet-stream;base64,";function f(A){return I=A,g=r,String.prototype.startsWith?I.startsWith(g):0===I.indexOf(g);var I,g}var W,b="data:application/octet-stream;base64,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AXgB2AEEAGQAxAAkAYQBJACEAOQARAGkAUQApAAEAWQBxAEMAGwAzAAsAYwBLACMAOwATAGsAUwArAAMAWwBzAEUAHQA1AA0AZQBNACUAPQAVAG0AVQAtAAUAXQB1AEcAHwA3AA8AZwBPACcAPwAXAG8AVwAvAAcAXwB3AEBAGEAwQAhAYEBIQCBAOEAQQGhAUEAoQABAWEBwQEJAGkAyQApAYkBKQCJAOkASQGpAUkAqQAJAWkByQERAHEA0QAxAZEBMQCRAPEAUQGxAVEAsQARAXEB0QEZAHkA2QA5AZkBOQCZAPkAWQG5AVkAuQAZAXkB2QEFAGUAxQAlAYUBJQCFAOUARQGlAUUApQAFAWUBxQENAG0AzQAtAY0BLQCNAO0ATQGtAU0ArQANAW0BzQEVAHUA1QA1AZUBNQCVAPUAVQG1AVUAtQAVAXUB1QEdAH0A3QA9AZ0BPQCdAP0AXQG9AV0AvQAdAX0B3QECAGIAwgAiAYIBIgCCAOIAQgGiAUIAogACAWIBwgEKAGoAygAqAYoBKgCKAOoASgGqAUoAqgAKAWoBygESAHIA0gAyAZIBMgCSAPIAUgGyAVIAsgASAXIB0gEaAHoA2gA6AZoBOgCaAPoAWgG6AVoAugAaAXoB2gEGAGYAxgAmAYYBJgCGAOYARgGmAUYApgAGAWYBxgEOAG4AzgAuAY4BLgCOAO4ATgGuAU4ArgAOAW4BzgEWAHYA1gA2AZYBNgCWAPYAVgG2AVYAtgAWAXYB1gEeAH4A3gA+AZ4BPgCeAP4AXgG+AV4AvgAeAX4B3gEDAGMAwwAjAYMBIwCDAOMAQwGjAUMAowADAWMBwwELAGsAywArAYsBKwCLAOsASwGrAUsAqwALAWsBywETAHMA0wAzAZMBMwCTAPMAUwGzAVMAswATAXMB0wEbAHsA2wA7AZsBOwCbAPsAWwG7AVsAuwAbAXsB2wEHAGcAxwAnAYcBJwCHAOcARwGnAUcApwAHAWcBxwEPAG8AzwAvAY8BLwCPAO8ATwGvAU8ArwAPAW8BzwEXAHcA1wA3AZcBNwCXAPcAVwG3AVcAtwAXAXcB1wEfAH8A3wA/AZ8BPwCfAP8AXwG/AV8AvwAfAX8B3wEAAIA/AAAAgGP6fz+/dVa8i+l/Pwpx1rx5zX8/584gvS+mfz86Xla9r3N/PxPyhb35NX8/Kq+g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PjB8dD9M1Jc+NnV1P3VqkT53Y3Y/PvqKPupGdz/ug4Q+hB94P5wPfD487Xg/TQxvPgmweT+C/mE+4md6P83mVD6+FHs/wsVHPpi2ez/zmzo+Z018P/VpLT4l2Xw/XDAgPstZfT+77xI+Vc99P6ioBT68OX4/c7fwPf2Yfj8EE9Y9Eu1+PzNluz35NX8/Kq+gPa9zfz8T8oU9L6Z/PzpeVj15zX8/584gPYvpfz8KcdY8Y/p/P791VjwAADAAYACQAMAAEABAAHAAoADQACAAUACAALAA4AAEADQAZACUAMQAFABEAHQApADUACQAVACEALQA5AAIADgAaACYAMgAGABIAHgAqADYACgAWACIALgA6AAMADwAbACcAMwAHABMAHwArADcACwAXACMALwA7AABADEAYQCRAMEAEQBBAHEAoQDRACEAUQCBALEA4QAFADUAZQCVAMUAFQBFAHUApQDVACUAVQCFALUA5QAJADkAaQCZAMkAGQBJAHkAqQDZACkAWQCJALkA6QANAD0AbQCdAM0AHQBNAH0ArQDdAC0AXQCNAL0A7QACADIAYgCSAMIAEgBCAHIAogDSACIAUgCCALIA4gAGADYAZgCWAMYAFgBGAHYApgDWACYAVgCGALYA5gAKADoAagCaAMoAGgBKAHoAqgDaACoAWgCKALoA6gAOAD4AbgCeAM4AHgBOAH4ArgDeAC4AXgCOAL4A7gADADMAYwCTAMMAEwBDAHMAowDTACMAUwCDALMA4wAHADcAZwCXAMcAFwBHAHcApwDXACcAVwCHALcA5wALADsAawCbAMsAGwBLAHsAqwDbACsAWwCLALsA6wAPAD8AbwCfAM8AHwBPAH8ArwDfAC8AXwCPAL8A7wDwAAAAiYiIOwEAAAAFADAAAwAQAAQABAAEAAEAQYytAQsGgFQAAIBFAEGirQELiQIYADAASABgAAgAIAA4AFAAaAAQACgAQABYAHAABAAcADQATABkAAwAJAA8AFQAbAAUACwARABcAHQAAQAZADEASQBhAAkAIQA5AFEAaQARACkAQQBZAHEABQAdADUATQBlAA0AJQA9AFUAbQAVAC0ARQBdAHUAAgAaADIASgBiAAoAIgA6AFIAagASACoAQgBaAHIABgAeADYATgBmAA4AJgA+AFYAbgAWAC4ARgBeAHYAAwAbADMASwBjAAsAIwA7AFMAawATACsAQwBbAHMABwAfADcATwBnAA8AJwA/AFcAbwAXAC8ARwBfAHcAeAAAAIiICDwCAAAABQAYAAMACAACAAQABAABAEG8rwELBqBWAACARQBB0q8BC40BDAAYACQAMAAEABAAHAAoADQACAAUACAALAA4AAEADQAZACUAMQAFABEAHQApADUACQAVACEALQA5AAIADgAaACYAMgAGABIAHgAqADYACgAWACIALgA6AAMADwAbACcAMwAHABMAHwArADcACwAXACMALwA7ADwAAACJiIg8AwAAAAUADAADAAQABAABAEH0sAELTdBXAACARQAAAAAAAMBYAACAWwAAPF4AAPRgAACoYwAAWGYAAARpAABsagAAKGsAAJxrAADoawAAIGwAAEBsAABYbAAAZGwAAAAAAAABAEGEtwELoCMBAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAA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";function e(A){try{if(A==b&&w)return new Uint8Array(w);var I=function(A){if(f(A))return function(A){try{for(var I=p(A),g=new Uint8Array(I.length),B=0;B<I.length;++B)g[B]=I.charCodeAt(B);return g}catch(A){throw new Error("Converting base64 string to bytes failed.")}}(A.slice(r.length))}(A);if(I)return I;throw"both async and sync fetching of the wasm failed"}catch(A){n(A)}}function x(I){for(;I.length>0;){var g=I.shift();if("function"!=typeof g){var B=g.func;"number"==typeof B?void 0===g.arg?q.get(B)():q.get(B)(g.arg):B(void 0===g.arg?null:g.arg)}else g(A)}}f(b)||(W=b,b=A.locateFile?A.locateFile(W,o):o+W);var v={mappings:{},buffers:[null,[],[]],printChar:function(A,I){var g=v.buffers[A];0===I||10===I?((1===A?G:R)(y(g,0)),g.length=0):g.push(I)},varargs:void 0,get:function(){return v.varargs+=4,h[v.varargs-4>>2]},getStr:function(A){return H(A)},get64:function(A,I){return A}},p="function"==typeof atob?atob:function(A){var I,g,B,Q,C,E,i="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",D="",o=0;A=A.replace(/[^A-Za-z0-9\\+\\/\\=]/g,"");do{I=i.indexOf(A.charAt(o++))<<2|(Q=i.indexOf(A.charAt(o++)))>>4,g=(15&Q)<<4|(C=i.indexOf(A.charAt(o++)))>>2,B=(3&C)<<6|(E=i.indexOf(A.charAt(o++))),D+=String.fromCharCode(I),64!==C&&(D+=String.fromCharCode(g)),64!==E&&(D+=String.fromCharCode(B))}while(o<A.length);return D};var T,O={b:function(A,I,g){k.copyWithin(A,I,I+g)},c:function(A){n("OOM")},a:function(A,I,g,B){for(var Q=0,C=0;C<g;C++){for(var E=h[I+8*C>>2],i=h[I+(8*C+4)>>2],D=0;D<i;D++)v.printChar(A,k[E+D]);Q+=i}return h[B>>2]=Q,0}},l=(function(){var I={a:O};function g(I,g){var B,Q=I.exports;A.asm=Q,B=A.asm.d.buffer,A.HEAP8=s=new Int8Array(B),A.HEAP16=new Int16Array(B),A.HEAP32=h=new Int32Array(B),A.HEAPU8=k=new Uint8Array(B),A.HEAPU16=new Uint16Array(B),A.HEAPU32=new Uint32Array(B),A.HEAPF32=new Float32Array(B),A.HEAPF64=new Float64Array(B),q=A.asm.e,function(I){if(d--,A.monitorRunDependencies&&A.monitorRunDependencies(d),0==d&&(null!==P&&(clearInterval(P),P=null),t)){var g=t;t=null,g()}}()}function Q(A){g(A.instance)}function C(A){return(w||"function"!=typeof fetch?Promise.resolve().then((function(){return e(b)})):fetch(b,{credentials:"same-origin"}).then((function(A){if(!A.ok)throw"failed to load wasm binary file at \'"+b+"\'";return A.arrayBuffer()})).catch((function(){return e(b)}))).then((function(A){return WebAssembly.instantiate(A,I)})).then(A,(function(A){R("failed to asynchronously prepare wasm: "+A),n(A)}))}if(d++,A.monitorRunDependencies&&A.monitorRunDependencies(d),A.instantiateWasm)try{return A.instantiateWasm(I,g)}catch(A){return R("Module.instantiateWasm callback failed with error: "+A),!1}(w||"function"!=typeof WebAssembly.instantiateStreaming||f(b)||"function"!=typeof fetch?C(Q):fetch(b,{credentials:"same-origin"}).then((function(A){return WebAssembly.instantiateStreaming(A,I).then(Q,(function(A){return R("wasm streaming compile failed: "+A),R("falling back to ArrayBuffer instantiation"),C(Q)}))}))).catch(B)}(),A.___wasm_call_ctors=function(){return(l=A.___wasm_call_ctors=A.asm.f).apply(null,arguments)}),X=(A._stopStream=function(){return(A._stopStream=A.asm.g).apply(null,arguments)},A._startStream=function(){return(A._startStream=A.asm.h).apply(null,arguments)},A._decode=function(){return(A._decode=A.asm.i).apply(null,arguments)},A._createBuffer=function(){return(A._createBuffer=A.asm.j).apply(null,arguments)},A._freeBuffer=function(){return(A._freeBuffer=A.asm.k).apply(null,arguments)},A._main=function(){return(A._main=A.asm.l).apply(null,arguments)},A.stackSave=function(){return(X=A.stackSave=A.asm.m).apply(null,arguments)}),Z=A.stackRestore=function(){return(Z=A.stackRestore=A.asm.n).apply(null,arguments)},V=A.stackAlloc=function(){return(V=A.stackAlloc=A.asm.o).apply(null,arguments)};function z(A){this.name="ExitStatus",this.message="Program terminated with exit("+A+")",this.status=A}function j(I){function B(){T||(T=!0,A.calledRun=!0,S||(x(K),x(c),g(A),A.onRuntimeInitialized&&A.onRuntimeInitialized(),u&&function(I){var g,B=A._main,Q=(I=I||[]).length+1,C=V(4*(Q+1));h[C>>2]=L(i);for(var E=1;E<Q;E++)h[(C>>2)+E]=L(I[E-1]);h[(C>>2)+Q]=0;try{g=B(Q,C),F&&0===g||(F||(A.onExit&&A.onExit(g),S=!0),D(g,new z(g)))}catch(A){if(A instanceof z)return;if("unwind"==A)return void(F=!0);var o=A;A&&"object"==typeof A&&A.stack&&(o=[A,A.stack]),R("exception thrown: "+o),D(1,A)}}(I),function(){if(A.postRun)for("function"==typeof A.postRun&&(A.postRun=[A.postRun]);A.postRun.length;)I=A.postRun.shift(),Y.unshift(I);var I;x(Y)}()))}I=I||E,d>0||(function(){if(A.preRun)for("function"==typeof A.preRun&&(A.preRun=[A.preRun]);A.preRun.length;)I=A.preRun.shift(),M.unshift(I);var I;x(M)}(),d>0||(A.setStatus?(A.setStatus("Running..."),setTimeout((function(){setTimeout((function(){A.setStatus("")}),1),B()}),1)):B()))}if(A.cwrap=function(A,I,g,B){var Q=(g=g||[]).every((function(A){return"number"===A}));return"string"!==I&&Q&&!B?U(A):function(){return a(A,I,g,arguments)}},t=function A(){T||j(),T||(t=A)},A.run=j,A.preInit)for("function"==typeof A.preInit&&(A.preInit=[A.preInit]);A.preInit.length>0;)A.preInit.pop()();var u=!0;return A.noInitialRun&&(u=!1),F=!0,j(),A.ready});A.exports=g}},I={};function g(B){var Q=I[B];if(void 0!==Q)return Q.exports;var C=I[B]={exports:{}};return A[B](C,C.exports,g),C.exports}g.n=A=>{var I=A&&A.__esModule?()=>A.default:()=>A;return g.d(I,{a:I}),I},g.d=(A,I)=>{for(var B in I)g.o(I,B)&&!g.o(A,B)&&Object.defineProperty(A,B,{enumerable:!0,get:I[B]})},g.o=(A,I)=>Object.prototype.hasOwnProperty.call(A,I),(()=>{"use strict";var A,I=g(305),B=g.n(I),Q=0,C=0,E=0,i=0,D=0,o=0;!async function(){A=await B()(),self.addEventListener("message",(async function(I){var g=I.data;switch(g.type){case"startStream":o=g.decodedSamplesPerFrame,D=o*g.channelCount,A._startStream(g.sampleRateHz,g.channelCount);break;case"stopStream":A._stopStream();break;case"decode":{const I=g.startTimestamp,B=function(I){const g=I.byteLength;return 0!=Q&&C<g&&(A._freeBuffer(Q),Q=0,C=0),0==Q&&(Q=A._createBuffer(I.BYTES_PER_ELEMENT*g),C=g),A.HEAPU8.set(I,Q),Q}(new Uint8Array(g.inputData)),w=(0!=E&&i<D&&(A._freeBuffer(E),E=0,i=0),0==E&&(E=A._createBuffer(Float32Array.BYTES_PER_ELEMENT*D),i=D),E),F=new Float32Array(A.HEAPF32.buffer,w,D),G=A._decode(B,g.inputData.byteLength,w,o),R=F.buffer.slice(w,w+D*F.BYTES_PER_ELEMENT);postMessage({type:"decodeDone",startTimestamp:I,outputData:R,samplesDecoded:G},[R]);break}case"release":0!=Q&&(A._freeBuffer(Q),Q=0,C=0),0!=E&&(A._freeBuffer(E),E=0,i=0),A._stopStream()}})),postMessage({type:"decoderReady"})}()})()})();',"Worker",void 0,void 0)}},614:A=>{A.exports=function(A,I,g,B){var Q=self||window;try{try{var C;try{C=new Q.Blob([A])}catch(I){(C=new(Q.BlobBuilder||Q.WebKitBlobBuilder||Q.MozBlobBuilder||Q.MSBlobBuilder)).append(A),C=C.getBlob()}var e=Q.URL||Q.webkitURL,i=e.createObjectURL(C),t=new Q[I](i,g);return e.revokeObjectURL(i),t}catch(B){return new Q[I]("data:application/javascript,".concat(encodeURIComponent(A)),g)}}catch(A){if(!B)throw Error("Inline worker is not supported");return new Q[I](B,g)}}}},I={};function g(B){var Q=I[B];if(void 0!==Q)return Q.exports;var C=I[B]={exports:{}};return A[B].call(C.exports,C,C.exports,g),C.exports}return g.n=A=>{var I=A&&A.__esModule?()=>A.default:()=>A;return g.d(I,{a:I}),I},g.d=(A,I)=>{for(var B in I)g.o(I,B)&&!g.o(A,B)&&Object.defineProperty(A,B,{enumerable:!0,get:I[B]})},g.o=(A,I)=>Object.prototype.hasOwnProperty.call(A,I),g.r=A=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(A,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(A,"__esModule",{value:!0})},g(114)})());class gg{constructor(){this.sampleRateHz=48e3,this.sampleRateKhz=48,this.channelCount=2,this.decodedCount=0,this.totalSamplesDecoded=0,this.waitingToDecodeQueue=[],this.decodeQueueSize=0,this.logPerformance=!1,this.maxDecodingTimeMs=0,this.totalDecodingTimeMs=0,this.totalQueuedSize=0,this.maxQueuedSize=0,this.startStreamTimeMs=0,this.outputBuffers=[],this.currentOutputBuffer=void 0,this.currentBufferReadIndex=0,this.nextStartTime=void 0,this.playing=!1,this.dataDurationMs=10,this.minLatencyMs=60,this.maxLatencyMs=100,this.prevDroppedFrameTimeMs=void 0,this.decodedSamplesPerFrame=0,this.audioBufferSize=0,this.audioBufferPool=[],this.maxAudioBufferPoolCount=5,this.resampledAudioBufferSize=0,this.onDecode=({startTimestamp:A,outputData:I,samplesDecoded:g})=>{--this.decodeQueueSize;const B=new Float32Array(I);this.outputBuffers.push(B);try{if(g>0&&(++this.decodedCount,this.totalSamplesDecoded+=g,this.logPerformance&&this.logPerfTiming(A),this.totalSamplesDecoded>=this.audioBufferSize&&(this.nextStartTime&&this.nextStartTime<this.audioContext.currentTime&&(this.nextStartTime=void 0),this.nextStartTime||this.totalSamplesDecoded>=2*this.audioBufferSize))){const A=Math.floor(this.totalSamplesDecoded/this.audioBufferSize);for(let I=0;I<A;++I){const A=this.nextStartTime?1e3*(this.nextStartTime-this.audioContext.currentTime):0;if(A>this.maxLatencyMs){let I=0;const g=Date.now(),B=this.prevDroppedFrameTimeMs?g-this.prevDroppedFrameTimeMs:void 0,Q=1e4;if(B&&B<Q)I=this.dropDecodedSamples(this.totalSamplesDecoded);else{const g=A-this.maxLatencyMs+this.dataDurationMs,B=Math.floor(this.sampleRateKhz*g);I=this.dropDecodedSamples(B)}this.prevDroppedFrameTimeMs=g,this.totalSamplesDecoded-=I}if(!(this.totalSamplesDecoded>=this.audioBufferSize))break;{const A=this.copyDecodedSamplesToAudioBuffer();this.scheduleBufferForPlaybackFunc(A),this.totalSamplesDecoded-=A.length}}}}catch(A){gI(gg.name,"Caught exception in AudioStream onDecode: "+A+" "+A.stack),this.stop(),this.play()}this.sendDecoderWaitingToDecodeFrames()}}async initialize(){this.opusDecoderWorker=new Ig,await this.opusDecoderWorker.initialize(),this.opusDecoderWorker.onDecode=this.onDecode.bind(this)}dispose(){this.opusDecoderWorker?.dispose(),this.opusDecoderWorker=void 0}configure({audioContext:A,sampleRateHz:I,channelCount:g,dataDurationMs:B,minLatencyMs:C,maxLatencyMs:e}){if(this.sampleRateHz=I??this.sampleRateHz,8e3!=this.sampleRateHz&&12e3!=this.sampleRateHz&&16e3!=this.sampleRateHz&&24e3!=this.sampleRateHz&&48e3!=this.sampleRateHz)throw new Q(`invalid audio sample rate: ${this.sampleRateHz} (must be 8000, 12000, 16000, 24000, or 48000)`);if(this.sampleRateKhz=this.sampleRateHz/1e3,this.channelCount=g??this.channelCount,1!=this.channelCount&&2!=this.channelCount&&6!=this.channelCount)throw new Q(`invalid channel count: ${this.channelCount} (must be 1, 2, or 6)`);if(this.dataDurationMs=B??this.dataDurationMs,this.minLatencyMs=C??this.minLatencyMs,this.maxLatencyMs=e??this.maxLatencyMs,this.dataDurationMs<=0)throw new Q(`dataDurationMs must be positive, but is ${this.dataDurationMs}`);if(this.dataDurationMs>this.minLatencyMs)throw new Q("dataDurationMs may not exceed minLatencyMs");if(this.maxLatencyMs<=this.minLatencyMs)throw new Q("maxLatencyMs must be greater than minLatencyMs");this.decodedSamplesPerFrame=this.dataDurationMs*this.sampleRateKhz,this.currentOutputBuffer=void 0,this.currentBufferReadIndex=0;const i=this.sampleRateKhz*this.minLatencyMs;this.audioBufferSize=Math.floor(i/2),null==A?(this.audioContext=new(window.AudioContext||window.webkitAudioContext)({latencyHint:"interactive",sampleRate:this.sampleRateHz}),this.audioContext.createBufferSource()):this.audioContext=A,this.volumeNode=this.audioContext.createGain(),this.volumeNode.connect(this.audioContext.destination),this.audioContext.resume(),"suspended"==this.audioContext.state&&BI(gg.name,"AudioContext is suspended. Note, on Safari, must be created directly from user interaction (i.e. no 'await'))."),this.audioContext.sampleRate!=this.sampleRateHz?(gI(gg.name,"Configured sample rate: "+this.sampleRateHz+" does not match AudioContext: "+this.audioContext.sampleRate+". Resampling is required!"),this.resampledAudioBufferSize=Math.floor(this.audioContext.sampleRate/1e3*this.minLatencyMs/2),this.scheduleBufferForPlaybackFunc=this.resampleBufferThenScheduleForPlayback.bind(this)):this.scheduleBufferForPlaybackFunc=this.scheduleBufferForPlayback.bind(this),this.audioBufferPool=[];let t=!1;this.playing&&(t=!0,this.stop()),t&&this.play()}play(){if(!this.opusDecoderWorker)throw new Q("play() has no opusDecoderWorker");if(!this.sampleRateHz)throw new Q("play() has no sampleRateHz");if(!this.channelCount)throw new Q("play() has no channelCount");if(!this.audioContext)throw new Q("play() has no audioContext");this.playing||(this.maxDecodingTimeMs=0,this.totalDecodingTimeMs=0,this.totalQueuedSize=0,this.maxQueuedSize=0,this.startStreamTimeMs=Date.now(),this.opusDecoderWorker.startStream(this.sampleRateHz,this.channelCount,this.decodedSamplesPerFrame),this.playing=!0)}stop(){if(!this.opusDecoderWorker)throw new Q("stop() has no opusDecoderWorker");this.waitingToDecodeQueue=[],this.outputBuffers=[],this.nextStartTime=void 0,this.totalSamplesDecoded=0,this.currentOutputBuffer=void 0,this.currentBufferReadIndex=0,this.prevDroppedFrameTimeMs=void 0,this.opusDecoderWorker.stopStream(),this.playing=!1}pushData(A){this.playing&&this.audioContext&&this.opusDecoderWorker&&(0==this.decodeQueueSize?(0!=this.waitingToDecodeQueue.length&&(II(gg.name,"empty decoder queue, but waiting to decode queue not empty!"),this.waitingToDecodeQueue=[]),this.sendToDecoder({startTimestamp:Date.now(),inputData:A})):(this.waitingToDecodeQueue.push({startTimestamp:Date.now(),inputData:A}),this.decodeQueueSize<3&&this.sendDecoderWaitingToDecodeFrames()))}sendDecoderWaitingToDecodeFrames(){const A=(this.decodeQueueSize+this.waitingToDecodeQueue.length)*this.dataDurationMs;if(A>this.maxLatencyMs){const I=A-this.maxLatencyMs,g=Math.floor(I/this.dataDurationMs),B=Math.max(Math.max(this.waitingToDecodeQueue.length-g,3-this.decodeQueueSize),1),Q=this.waitingToDecodeQueue.length-B;this.waitingToDecodeQueue=this.waitingToDecodeQueue.slice(Q)}for(;this.decodeQueueSize<3&&this.waitingToDecodeQueue.length>0;){const A=this.waitingToDecodeQueue.shift();this.sendToDecoder(A)}}sendToDecoder(A){++this.decodeQueueSize,this.opusDecoderWorker.decode(A.startTimestamp,A.inputData)}dropDecodedSamples(A){let I=0;for(this.currentOutputBuffer&&(I+=this.dropCurrentOutputBufferSamples(A),A-=I);A>0&&this.outputBuffers.length>0;)if(A<this.decodedSamplesPerFrame){this.currentOutputBuffer=this.outputBuffers.shift(),this.currentBufferReadIndex=0;const g=this.dropCurrentOutputBufferSamples(A);I+=g,A-=g}else this.outputBuffers.shift(),I+=this.decodedSamplesPerFrame,A-=this.decodedSamplesPerFrame;return I}dropCurrentOutputBufferSamples(A){const I=Math.floor((this.currentOutputBuffer.length-this.currentBufferReadIndex)/this.channelCount),g=Math.min(I,A);return this.currentBufferReadIndex+=g*this.channelCount,this.currentBufferReadIndex>=this.currentOutputBuffer.length&&(this.currentOutputBuffer=void 0),g}copyDecodedSamplesToAudioBuffer(){const A=this.getOrCreateAudioBuffer();for(let I=0;I<this.audioBufferSize;){this.currentOutputBuffer||(this.currentOutputBuffer=this.outputBuffers.shift(),this.currentBufferReadIndex=0);const g=this.currentOutputBuffer;if(1==this.channelCount){const B=A.getChannelData(0);for(;this.currentBufferReadIndex<g.length&&(B[I]=g[this.currentBufferReadIndex],this.currentBufferReadIndex+=this.channelCount,++I,!(I>=this.audioBufferSize)););}else if(2==this.channelCount){const B=A.getChannelData(0),Q=A.getChannelData(1);for(;this.currentBufferReadIndex<g.length&&(B[I]=g[this.currentBufferReadIndex],Q[I]=g[this.currentBufferReadIndex+1],this.currentBufferReadIndex+=this.channelCount,++I,!(I>=this.audioBufferSize)););}else{const B=A.getChannelData(0),Q=A.getChannelData(1),C=A.getChannelData(2),e=A.getChannelData(3),i=A.getChannelData(4),t=A.getChannelData(5);for(;this.currentBufferReadIndex<g.length&&(B[I]=g[this.currentBufferReadIndex],Q[I]=g[this.currentBufferReadIndex+1],i[I]=g[this.currentBufferReadIndex+2],t[I]=g[this.currentBufferReadIndex+3],C[I]=g[this.currentBufferReadIndex+4],e[I]=g[this.currentBufferReadIndex+5],this.currentBufferReadIndex+=this.channelCount,++I,!(I>=this.audioBufferSize)););}this.currentBufferReadIndex>=this.currentOutputBuffer.length&&(this.currentOutputBuffer=void 0)}return A}getOrCreateAudioBuffer(){return 0==this.audioBufferPool.length?this.audioContext.createBuffer(this.channelCount,this.audioBufferSize,this.sampleRateHz):this.audioBufferPool.pop()}returnAudioBufferToPool(A,I){this.audioBufferPool.length<this.maxAudioBufferPoolCount&&this.audioBufferPool.push(A)}logPerfTiming(A){const I=Date.now(),g=I-A;this.totalDecodingTimeMs+=g,g>this.maxDecodingTimeMs&&(this.maxDecodingTimeMs=g);const B=this.waitingToDecodeQueue.length+this.decodeQueueSize;this.totalQueuedSize+=B,B>this.maxQueuedSize&&(this.maxQueuedSize=B),1500==this.decodedCount&&(BI(gg.name,"Avg queue: "+this.totalQueuedSize/this.decodedCount+", Max: "+this.maxQueuedSize+" Avg FPS: "+this.decodedCount/((I-this.startStreamTimeMs)/1e3)+" Avg decode: "+this.totalDecodingTimeMs/this.decodedCount+"ms, Max: "+this.maxDecodingTimeMs+"ms"),this.totalDecodingTimeMs=0,this.maxDecodingTimeMs=0,this.totalQueuedSize=0,this.maxQueuedSize=0,this.decodedCount=0,this.startStreamTimeMs=I)}resampleBufferThenScheduleForPlayback(A){const I=new(window.OfflineAudioContext||window.webkitOfflineAudioContext)(this.channelCount,this.resampledAudioBufferSize,this.audioContext.sampleRate),g=I.createBufferSource();g.buffer=A,g.connect(I.destination),g.start(),I.startRendering(),I.oncomplete=this.scheduleResampledBufferPlayback.bind(this,A)}scheduleResampledBufferPlayback(A,I){this.schedulePlaybackWithOnEnded(I.renderedBuffer),this.returnAudioBufferToPool(A,I)}scheduleBufferForPlayback(A){this.schedulePlaybackWithOnEnded(A,this.returnAudioBufferToPool.bind(this,A))}schedulePlaybackWithOnEnded(A,I=null){const g=this.audioContext.createBufferSource();g.buffer=A,this.nextStartTime||(this.nextStartTime=this.audioContext.currentTime),g.playbackRate.value=1,g.connect(this.volumeNode),g.start(this.nextStartTime),g.onended=I,this.nextStartTime+=A.duration}setVolume(A){this.volumeNode.gain.value=A}}const Bg={targetFramerate:60,bufferLimitMs:500,cpuStarvationThreshold:1,decoderStrugglingThreshold:1,checkInterval:1500,windowMs:500};class Qg{constructor(A,I={}){this.videoStream=A,this.decoderStrugglingEvent=new _A,this.cpuStarvationEvent=new _A,this.cpuStarvationCounter=0,this.decoderStrugglingCounter=0,this.readyStateChangeHandler=A=>{A===NI.Detached?this.stopChecking():this.lastVideoReadyState===NI.Detached&&this.startChecking(),this.lastVideoReadyState=A},this.videoFrameMetadataHandler=A=>{this.processingDurationTrack.feed(A)},this.checkPerformance=()=>{if(this.videoStream.readyState===NI.Playing){const A=1/this.config.targetFramerate,I=1e3*A,g=Math.floor(this.config.bufferLimitMs/I),B=this.videoStream.getStats();(B.endOfBuffered>B.currentTime+this.config.bufferLimitMs/1e3||this.videoStream.dataQueueLength>g)&&this.videoStream.restart("checkPerformance"),this.videoStream.dataQueueLength>g?this.cpuStarvationCounter+=1:this.cpuStarvationCounter=Math.max(0,this.cpuStarvationCounter-1);this.processingDurationTrack.average()>A?(this.decoderStrugglingCounter+=1,this.cpuStarvationCounter=Math.max(0,this.cpuStarvationCounter-1)):this.decoderStrugglingCounter=Math.max(0,this.decoderStrugglingCounter-1),this.cpuStarvationCounter,this.config.cpuStarvationThreshold,this.decoderStrugglingCounter,this.config.decoderStrugglingThreshold}},this.config={...Bg,...I},this.processingDurationTrack=new HI(this.config.windowMs,qI),this.videoStream.readyStateChangeEvent.addHandler(this.readyStateChangeHandler),this.videoStream.videoFrameProcessingDurationEvent.addHandler(this.videoFrameMetadataHandler),this.lastVideoReadyState=this.videoStream.readyState,this.videoStream.readyState!==NI.Detached&&this.startChecking()}dispose(){this.stopChecking(),this.videoStream.readyStateChangeEvent.removeHandler(this.readyStateChangeHandler),this.videoStream.videoFrameProcessingDurationEvent.removeHandler(this.videoFrameMetadataHandler)}startChecking(){this.processingDurationTrack=new HI(this.config.windowMs,qI),this.checkPerformanceInterval=window.setInterval(this.checkPerformance,this.config.checkInterval)}stopChecking(){this.checkPerformanceInterval&&(window.clearInterval(this.checkPerformanceInterval),this.checkPerformanceInterval=void 0)}}var Cg;!function(A){A[A.AnnexB=0]="AnnexB",A[A.LengthPrefixed=1]="LengthPrefixed"}(Cg||(Cg={}));var eg={exports:{}};self;var ig=$I(eg.exports=(()=>{var A={114:function(A,I,g){var B=this&&this.__importDefault||function(A){return A&&A.__esModule?A:{default:A}};Object.defineProperty(I,"__esModule",{value:!0});const Q=B(g(170));class C{initialize(){return this.id=C.uniqueIdCounter++,new Promise(((A,I)=>{this.worker=new Q.default,this.worker.addEventListener("message",(I=>{var g;const B=I.data;"decoderReady"===B.type?A(0):"pictureReady"===B.type&&(null===(g=this.onDecode)||void 0===g||g.call(this,B))}))}))}decode(A){this.worker&&this.worker.postMessage({type:"decode",data:A.buffer,offset:A.byteOffset,length:A.byteLength,renderStateId:this.id},[A.buffer])}release(){this.worker&&this.worker.postMessage({type:"release",renderStateId:this.id})}dispose(){this.worker&&(this.worker.terminate(),this.worker=void 0)}}I.default=C,C.uniqueIdCounter=1},170:(A,I,g)=>{g.r(I),g.d(I,{default:()=>C});var B=g(614),Q=g.n(B);function C(){return Q()('/*! For license information please see index.worker.js.LICENSE.txt */\n(()=>{var A={719:A=>{var I,g=(I="undefined"!=typeof document&&document.currentScript?document.currentScript.src:void 0,function(A){(A=A||{})||(A=void 0!==A?A:{});var g,B={};for(g in A)A.hasOwnProperty(g)&&(B[g]=A[g]);var Q,C=[],E="";E=self.location.href,I&&(E=I),E=0!==E.indexOf("blob:")?E.substr(0,E.lastIndexOf("/")+1):"",Q=function(A){var I=new XMLHttpRequest;return I.open("GET",A,!1),I.responseType="arraybuffer",I.send(null),new Uint8Array(I.response)};var i,D,o=A.print||console.log.bind(console),a=A.printErr||console.warn.bind(console);for(g in B)B.hasOwnProperty(g)&&(A[g]=B[g]);B=null,A.arguments&&(C=A.arguments),A.thisProgram&&A.thisProgram,A.quit&&A.quit,A.wasmBinary&&(i=A.wasmBinary),A.noExitRuntime&&A.noExitRuntime,"object"!=typeof WebAssembly&&a("no native wasm support detected");var G,S,F,N,w,y,R,h=new WebAssembly.Table({initial:1,maximum:1,element:"anyfunc"}),s=!1;function k(I){G=I,A.HEAP8=S=new Int8Array(I),A.HEAP16=N=new Int16Array(I),A.HEAP32=w=new Int32Array(I),A.HEAPU8=F=new Uint8Array(I),A.HEAPU16=new Uint16Array(I),A.HEAPU32=new Uint32Array(I),A.HEAPF32=y=new Float32Array(I),A.HEAPF64=R=new Float64Array(I)}var L=A.INITIAL_MEMORY||16777216;function M(I){for(;I.length>0;){var g=I.shift();if("function"!=typeof g){var B=g.func;"number"==typeof B?void 0===g.arg?A.dynCall_v(B):A.dynCall_vi(B,g.arg):B(void 0===g.arg?null:g.arg)}else g(A)}}(D=A.wasmMemory?A.wasmMemory:new WebAssembly.Memory({initial:L/65536,maximum:32768}))&&(G=D.buffer),L=G.byteLength,k(G),w[2188]=5251792;var U=[],Y=[],J=[],q=[],K=0,H=null,t=null;function c(I){throw A.onAbort&&A.onAbort(I),o(I+=""),a(I),s=!0,I="abort("+I+"). Build with -s ASSERTIONS=1 for more info.",new WebAssembly.RuntimeError(I)}function d(A){return I=A,g="data:application/octet-stream;base64,",String.prototype.startsWith?I.startsWith(g):0===I.indexOf(g);var I,g}A.preloadedImages={},A.preloadedAudios={};var n,p="TinyH264.wasm";function f(){try{if(i)return new Uint8Array(i);if(Q)return Q(p);throw"both async and sync fetching of the wasm failed"}catch(A){c(A)}}function r(A){try{return D.grow(A-G.byteLength+65535>>>16),k(D.buffer),1}catch(A){}}d(p)||(n=p,p=A.locateFile?A.locateFile(n,E):E+n),Y.push({func:function(){x()}});var e={a:function(A,I,g){F.copyWithin(A,I,I+g)},b:function(A){A>>>=0;var I=F.length,g=2147483648;if(A>g)return!1;for(var B,Q=1;Q<=4;Q*=2){var C=I*(1+.2/Q);if(C=Math.min(C,A+100663296),r(Math.min(g,((B=Math.max(16777216,A,C))%65536>0&&(B+=65536-B%65536),B))))return!0}return!1},memory:D,table:h},m=function(){var I={a:e};function g(I,g){var B=I.exports;A.asm=B,function(I){if(K--,A.monitorRunDependencies&&A.monitorRunDependencies(K),0==K&&(null!==H&&(clearInterval(H),H=null),t)){var g=t;t=null,g()}}()}function B(A){g(A.instance)}function Q(A){return(i||"function"!=typeof fetch?new Promise((function(A,I){A(f())})):fetch(p,{credentials:"same-origin"}).then((function(A){if(!A.ok)throw"failed to load wasm binary file at \'"+p+"\'";return A.arrayBuffer()})).catch((function(){return f()}))).then((function(A){return WebAssembly.instantiate(A,I)})).then(A,(function(A){a("failed to asynchronously prepare wasm: "+A),c(A)}))}if(K++,A.monitorRunDependencies&&A.monitorRunDependencies(K),A.instantiateWasm)try{return A.instantiateWasm(I,g)}catch(A){return a("Module.instantiateWasm callback failed with error: "+A),!1}return function(){if(i||"function"!=typeof WebAssembly.instantiateStreaming||d(p)||"function"!=typeof fetch)return Q(B);fetch(p,{credentials:"same-origin"}).then((function(A){return WebAssembly.instantiateStreaming(A,I).then(B,(function(A){a("wasm streaming compile failed: "+A),a("falling back to ArrayBuffer instantiation"),Q(B)}))}))}(),{}}();A.asm=m;var W,x=A.___wasm_call_ctors=function(){return(x=A.___wasm_call_ctors=A.asm.c).apply(null,arguments)};function X(I){function g(){W||(W=!0,A.calledRun=!0,s||(M(Y),M(J),A.onRuntimeInitialized&&A.onRuntimeInitialized(),function(){if(A.postRun)for("function"==typeof A.postRun&&(A.postRun=[A.postRun]);A.postRun.length;)I=A.postRun.shift(),q.unshift(I);var I;M(q)}()))}I=I||C,K>0||(function(){if(A.preRun)for("function"==typeof A.preRun&&(A.preRun=[A.preRun]);A.preRun.length;)I=A.preRun.shift(),U.unshift(I);var I;M(U)}(),K>0||(A.setStatus?(A.setStatus("Running..."),setTimeout((function(){setTimeout((function(){A.setStatus("")}),1),g()}),1)):g()))}if(A._h264bsdInit=function(){return(A._h264bsdInit=A.asm.d).apply(null,arguments)},A._malloc=function(){return(A._malloc=A.asm.e).apply(null,arguments)},A._free=function(){return(A._free=A.asm.f).apply(null,arguments)},A._h264bsdDecode=function(){return(A._h264bsdDecode=A.asm.g).apply(null,arguments)},A._h264bsdShutdown=function(){return(A._h264bsdShutdown=A.asm.h).apply(null,arguments)},A._h264bsdAlloc=function(){return(A._h264bsdAlloc=A.asm.i).apply(null,arguments)},A._h264bsdFree=function(){return(A._h264bsdFree=A.asm.j).apply(null,arguments)},A.asm=m,A.getValue=function(A,I,g){switch("*"===(I=I||"i8").charAt(I.length-1)&&(I="i32"),I){case"i1":case"i8":return S[A>>0];case"i16":return N[A>>1];case"i32":case"i64":return w[A>>2];case"float":return y[A>>2];case"double":return R[A>>3];default:c("invalid type for getValue: "+I)}return null},A.then=function(I){if(W)I(A);else{var g=A.onRuntimeInitialized;A.onRuntimeInitialized=function(){g&&g(),I(A)}}return A},t=function A(){W||X(),W||(t=A)},A.run=X,A.preInit)for("function"==typeof A.preInit&&(A.preInit=[A.preInit]);A.preInit.length>0;)A.preInit.pop()();return X(),A});A.exports=g},340:(A,I,g)=>{"use strict";g.r(I),g.d(I,{init:()=>o});var B=function(){function A(A,I){this.tinyH264Module=A,this.onPictureReady=I,this.pStorage=this.tinyH264Module._h264bsdAlloc(),this.pWidth=this.tinyH264Module._malloc(4),this.pHeight=this.tinyH264Module._malloc(4),this.pPicture=this.tinyH264Module._malloc(4),this._decBuffer=this.tinyH264Module._malloc(1048576),this.tinyH264Module._h264bsdInit(this.pStorage,0)}var I=A.prototype;return I.release=function(){var A=this.pStorage;0!==A&&(this.tinyH264Module._h264bsdShutdown(A),this.tinyH264Module._h264bsdFree(A)),this.tinyH264Module._free(this.pWidth),this.tinyH264Module._free(this.pHeight),this.tinyH264Module._free(this.pPicture),this.pStorage=0,this.pWidth=0,this.pHeight=0},I.decode=function(I){if(I instanceof ArrayBuffer&&(I=new Uint8Array(I)),this.tinyH264Module.HEAPU8.set(I,this._decBuffer),this.tinyH264Module._h264bsdDecode(this.pStorage,this._decBuffer,I.byteLength,this.pPicture,this.pWidth,this.pHeight)===A.PIC_RDY){var g=this.tinyH264Module.getValue(this.pWidth,"i32"),B=this.tinyH264Module.getValue(this.pHeight,"i32"),Q=this.tinyH264Module.getValue(this.pPicture,"i8*"),C=new Uint8Array(this.tinyH264Module.HEAPU8.subarray(Q,Q+g*B*3/2));this.onPictureReady(C,g,B)}},A}();B.RDY=0,B.PIC_RDY=1,B.HDRS_RDY=2,B.ERROR=3,B.PARAM_SET_ERROR=4,B.MEMALLOC_ERROR=5;const Q=B;var C=g(719),E=g.n(C),i={"TinyH264.wasm":"data:;base64,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ZGogATYCACAEIANBBHFBGHIiBGsiAkEgSQ0AIAGtIgVCIIYgBYQhBSADIARqIQEDQCABIAU3AxggASAFNwMQIAEgBTcDCCABIAU3AwAgAUEgaiEBIAJBYGoiAkEfSw0ACwsgAAvyAwEDfyABKAIAIgNB////B0cEQCABKAIEIQQgACACIAJBA3EgAkEQSSICG0ECdCIFQfApaigCAEEQQQggAhsiAmxqIAVBsClqKAIAaiIAIAMgAC0AAGpBsC5qLQAAOgAAIAEoAgghAyAAIAQgAC0AAWpBsC5qLQAAOgABIAEoAgwhBCAAIAMgAC0AAmpBsC5qLQAAOgACIAAgBCAALQADakGwLmotAAA6AAMgASgCFCEDIAAgAmoiACABKAIQIAAtAABqQbAuai0AADoAACABKAIYIQQgACADIAAtAAFqQbAuai0AADoAASABKAIcIQMgACAEIAAtAAJqQbAuai0AADoAAiAAIAMgAC0AA2pBsC5qLQAAOgADIAEoAiQhAyAAIAJqIgAgASgCICAALQAAakGwLmotAAA6AAAgASgCKCEEIAAgAyAALQABakGwLmotAAA6AAEgASgCLCEDIAAgBCAALQACakGwLmotAAA6AAIgACADIAAtAANqQbAuai0AADoAAyABKAI0IQMgACACaiIAIAEoAjAgAC0AAGpBsC5qLQAAOgAAIAEoAjghAiAAIAMgAC0AAWpBsC5qLQAAOgABIAEoAjwhASAAIAIgAC0AAmpBsC5qLQAAOgACIAAgASAALQADakGwLmotAAA6AAMLC9MQAQx/IwBBgAFrIgokACAAEA8hBEEBIQUCQAJAAn8gAkEBTQRAIARBAEgNAiAEQRl2Qf4AcUGACGogBEGAgIDgAE8NARogBEEVdkH+D3FBwAhqIARBgICACE8NARogBEERdkH+/wFxQZAJaiAEQYCAgAFPDQEaIARBEHZBAXRBkApqDAELIAJBA00EQCAEQX9MBEBBAkGiECAEQYCAgIAEcRshBQwDCyAEQRl2Qf4AcUHQCmogBEGAgICAAU8NARogBEEWdkH+B3FBkAtqIARBgICAEE8NARogBEERdkH+/wFxQdALagwBCyACQQdNBEAgBEEadiICQXhqQThJBEAgAkEBdEHQDWoMAgsgBEEVdkH+D3FB0A5qDAELIARBGXZB/gBxQdAQaiACQRBNDQAaIARBHXYiAgRAIAJBAXRB0BFqDAELIARBF3ZB/gNxQeARagsvAQAiBQ0AQQEhCwwBC0EBIQsgBUELdiIJIANLDQBBICAFQR9xIgZrIQICQCAJRQRADAELIAQgBnQhBAJAIAVBBXZBP3EiDEUEQAwBCyACIAxJBEAgACAGEAtBf0YNAyAAEA8hBEEgIQILIAQgDHQhBkEBIAxBf2p0IQcgBEEgIAxrdiEEA0AgCkFAayAIQQJ0akF/QQEgBCAHcRs2AgAgCEEBaiEIIAdBAXYiBw0ACyACIAxrIQIgBiEECyAIIAlJBEAgDEEDSSIPIAVB/68BS3EhBQNAIAJBD00EQCAAQSAgAmsQC0F/RgRADAULIAAQDyEEQSAhAgtBACEGAkACQAJ/AkAgBEEASA0AQQEhBiAEQf////8DSw0AQQIhBiAEQf////8BSw0AQQMhBiAEQf////8ASw0AQQQhBiAEQf///z9LDQBBBSEGIARB////H0sNAEEGIQYgBEH///8PSw0AQQchBiAEQf///wdLDQBBCCEGIARB////A0sNAEEJIQYgBEH///8BSw0AQQohBiAEQf///wBLDQBBCyEGIARB//8/Sw0AQQwhBiAEQf//H0sNAEENIQYgBEH//w9LDQACfwJAIARB//8HTQRAIARBgIB8cUGAgARGDQEMCgsgBUEEIAUbIQYgBEEPdCEEQQ4hByACQXFqDAELIAVBASAFGyEFIARBEHQhBEEMIQZBDyEHIAJBcGoLIQIgByAFdCEHIAVFDAELIAYgBXQhB0EBIQ4gAiAGQQFqIgZrIQIgBCAGdCEEIAVFDQEgBSEGQQALIQ4gAiAGTwR/IAQFIABBICACaxALQX9GBEAMBwtBICECIAAQDwshDSACIAZrIQIgDSAGdCEEIA1BICAGa3YgB2ohBwwBC0EAIQULIApBQGsgCEECdGpBACAHQQJqIAcgCCAMRhsgByAPGyINQQJqQQF2IgZrIAYgDUEBcRs2AgBBASAFIA4bIgUgBUEGSSAGQQMgBUF/anRKcWohBSAIQQFqIgggCUcNAAsLQQAhBwJAIAkgA08EQEEAIQgMAQsCQCACQQhLBEAgAiEFDAELQSAhBSAAQSAgAmsQC0F/Rg0DIAAQDyEECwJAAkACfwJAIANBBEcEQCAJQX9qIgJBDUsNAwJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIAJBAWsODQABAgMEBQYHCAkKCwwOCyAEQRp2QeASagwOCyAEQRp2QaATagwNCyAEQRt2QeATagwMCyAEQRt2QYAUagwLCyAEQRp2QaAUagwKCyAEQRp2QeAUagwJCyAEQRp2QaAVagwICyAEQRp2QeAVagwHCyAEQRt2QaAWagwGCyAEQRx2QcAWagwFCyAEQRx2QdAWagwECyAEQR12QeAWagwDCyAEQR52QegWagwCCyAEQQBIBEBBASECDAQLQREhAiAJQQNGDQNBEiECIARB/////wNLDQNBIiECIAlBAkYNA0EjQTMgBEH/////AUsbIQIMAwsgBEEbdkGgEmogBEEXdkHAEmogBEH/////AEsbCy0AACICDQEMBAtBEUEBIARBAEgbIQILIAJBBHYhCCAFIAJBD3EiA2shAiAEIAN0IQQLIAlBf2oiAwRAA0ACfyAIBEAgAkEKTQRAIABBICACaxALQX9GBEAMBwsgABAPIQRBICECCwJAAn8CQCAIQX9qIgVBBU0EQAJAAkACQAJAAkAgBUEBaw4FAAECAwQGCyAEQR52Qe4WagwGCyAEQR52QfIWagwFCyAEQR12QfYWagwECyAEQR12Qf4WagwDCyAEQR12QYYXagwCCwJ/QfMAIARBGXZB8ABxayAEQYCAgIACTw0AGkH0ACAEQf////8ASw0AGkGFASAEQf///z9LDQAaQZYBIARB////H0sNABpBpwEgBEH///8PSw0AGkG4ASAEQf///wdLDQAaQckBIARB////A0sNABpB2gEgBEH///8BSw0AGkEAQesBIARBgICAAUkbCyIFQQR2IAhNDQIMCAsgBEEfdkHsFmoLLQAAIQULIAVFBEAMBgsgCiAHQQJ0aiAFQQR2IgZBAWo2AgAgAiAFQQ9xIgVrIQIgBCAFdCEEIAggBmsMAQsgCiAHQQJ0akEBNgIAQQALIQggB0EBaiIHIANHDQALIAEgCEECdGogCkFAayADQQJ0aigCADYCACAJQX5qIQVBASAIdCEHA0AgASAKIAUiA0ECdCIFaigCACAIaiIIQQJ0aiAKQUBrIAVqKAIANgIAIANBf2ohBUEBIAh0IAdyIQcgAw0ACwwBCyABIAhBAnRqIApBQGsgA0ECdGooAgA2AgBBASAIdCEHCyAA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ASAAKALMASADQQF0ai4BHGpBAWpBAXUPCyAFQQRGBEAgAiADQQF0ai4BACEBAn8gACgCyAEiAgRAIAAoAgQgAigCBEYMAQtBAAtFDQEgASAAKALIASAEQQF0ai4BHGpBAWpBAXUPCwJ/An8gACgCyAEiAQRAIAAoAgQgASgCBEYMAQtBAAtFBEBBACECQQAMAQtBASECIAAoAsgBIARBAXRqLgEcCyEBAn8gACgCzAEiBARAIAAoAgQgBCgCBEYMAQtBAAtFDQAgACgCzAEgA0EBdGouARwhACACRQRAIAAPCyAAIAFqQQFqQQF1IQELIAELiQcBB38gAyAFaiINIAEuAQAiDEECdWohAyAEIAZqIg4gAS4BAiIPQQJ1aiEEIAIoAghBBHQhCSACKAIEQQR0IQogACAGQQR0aiAFaiELAkAgDEEDcUEEdCAPQQNxQQJ0ckHQO2ooAgAiDEEOTQRAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIAxBAWsODgECAwQFBgcICQoLDA0OAAsgAigCACALIAMgBCAKIAkgByAIQRAQDAwPCyACKAIAIAsgAyAEQX5qIAogCSAHIAhBABAkDA4LIAIoAgAgCyADIARBfmogCiAJIAcgCBBHDA0LIAIoAgAgCyADIARBfmogCiAJIAcgCEEBECQMDAsgAigCACALIANBfmogBCAKIAkgByAIQQAQIwwLCyACKAIAIAsgA0F+aiAEQX5qIAogCSAHIAhBABAaDAoLIAIoAgAgCyADQX5qIARBfmogCiAJIAcgCEEAECEMCQsgAigCACALIANBfmogBEF+aiAKIAkgByAIQQIQGgwICyACKAIAIAsgA0F+aiAEIAogCSAHIAgQRgwHCyACKAIAIAsgA0F+aiAEQX5qIAogCSAHIAhBABAiDAYLIAIoAgAgCyADQX5qIARBfmogCiAJIAcgCBBFDAULIAIoAgAgCyADQX5qIARBfmogCiAJIAcgCEEBECIMBAsgAigCACALIANBfmogBCAKIAkgByAIQQEQIwwDCyACKAIAIAsgA0F+aiAEQX5qIAogCSAHIAhBARAaDAILIAIoAgAgCyADQX5qIARBfmogCiAJIAcgCEEBECEMAQsgAigCACALIANBfmogBEF+aiAKIAkgByAIQQMQGgsgDUEBdiABLgEAIglBA3VqIQMgDkEBdiABLgECIgFBA3VqIQQgAigCACACKAIEIgogAigCCCILbEEIdGohAiAAIAZBAnRBeHFqIAVBAXZqQYACaiEFIAhBAXYhBiAHQQF2IQcgAUEHcSEIIAtBA3QhACAKQQN0IQECQCAJQQdxIglFDQAgCEUNACACIAUgAyAEIAEgACAJIAggByAGEEgPCyAJBEAgAiAFIAMgBCABIAAgCSAHIAYQSw8LIAgEQCACIAUgAyAEIAEgACAIIAcgBhBKDwsgAiAFIAMgBCABIAAgByAGQQgQDCACIAAgAWxqIAVBQGsgAyAEIAEgACAHIAZBCBAMC8cBAQR/IAAoAgQhAgJAIAAoAgxBA3QgACgCEGsiA0EgTgRAIAIoAAAiAUEYdCABQQh0QYCA/AdxciABQQh2QYD+A3EgAUEYdnJyIQEgACgCCCIARQ0BIAEgAHQgAi0ABEEIIABrdnIPCyADQQFIBEBBAA8LIAItAAAgACgCCCIAQRhqIgR0IQEgACADakF4aiIAQQFIDQADQCACLQABIARBeGoiBHQgAXIhASAAQQhKIQMgAkEBaiECIABBeGohACADDQALCyABC4wEAQd/AkAgAEF/aiIILQAAIgUgAC0AACIGayIEIARBH3UiBGogBHMgAigCBE8NACAAQX5qLQAAIgQgBWsiByAHQR91IgdqIAdzIAIoAggiCU8NACAALQABIgcgBmsiCiAKQR91IgpqIApzIAlPDQAgAUEDTQRAIAggBSABIAIoAgBqQX9qLQAAIghBf3MiCSAIQQFqIgggBiAFa0ECdCAHayAEakEEakEDdSIFIAUgCEobIAUgCUgbIgVqQbAuai0AADoAACAAIAYgBWtBsC5qLQAAOgAADAELIAggBSAHaiAEQQF0akECakECdjoAACAAIAYgB0EBdGogBGpBAmpBAnY6AAALAkAgACADaiIAQX9qIgctAAAiAyAALQAAIgVrIgYgBkEfdSIGaiAGcyACKAIETw0AIABBfmotAAAiBiADayIEIARBH3UiBGogBHMgAigCCCIITw0AIAAtAAEiBCAFayIJIAlBH3UiCWogCXMgCE8NACABQQNNBEAgByABIAIoAgBqQX9qLQAAIgFBf3MiAiABQQFqIgcgBSADa0ECdCAEayAGakEEakEDdSIBIAEgB0obIAEgAkgbIgEg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QRBqIQELIAdBAnYiBEUNAEHAACAGayEQIAlBAXQhCiAJQQJ0IAZrIQtBACAJayIMQQF0IRIgASAHQQR0ayECIAkgE2ogCEEBcWpBAmoiACAJQQVsaiEBA0AgBiIDBEADQCACIAAgCmotAAAiBSABIApqLQAAIAEgCWotAAAiDiABIBJqLQAAIgdqIghrIAhBAnRraiABLQAAIg0gASAMai0AACIIakEUbGpBEGpBBXVBsC5qLQAAIAItADBqQQFqQQF2OgAwIAIgACAJai0AACIPIA4gByAIakEUbGogBSANaiIOayAOQQJ0a2pBEGpBBXVBsC5qLQAAIAItACBqQQFqQQF2OgAgIAIgAC0AACIOIA0gBSAHakEUbGogCCAPaiINayANQQJ0a2pBEGpBBXVBsC5qLQAAIAItABBqQQFqQQF2OgAQIAIgACAMai0AACAIIAUgD2pBFGxqIAcgDmoiBWsgBUECdGtqQRBqQQV1QbAuai0AACACLQAAakEBakEBdjoAACAAQQFqIQAgAkEBaiECIAFBAWohASADQX9qIgMNAAsLIAIgEGohAiABIAtqIQEgACALaiEAIARBf2oiBA0ACwsgEUHAA2okAAu1BQEEfyAAKAIUIQMgACgCECEEIAAoAgQhBSAAKAIMIgIgASkCADcCACACIAEpAgg3AgggAiAFQQR0IgBqIgIgASkCEDcCACACIAEpAhg3AgggACACaiICIAEpAiA3AgAgAiABKQIoNwIIIAAgAmoiAiABKQIwNwIAIAIgASkCODcCCCAAIAJqIgIgASkCQDcCACACIAEpAkg3AgggACACaiICIAEpAlA3AgAgAiABKQJYNwIIIAAgAmoiAiABKQJgNwIAIAIgASkCaDcCCCAAIAJqIgIgASkCcDcCACACIAEpAng3AgggACACaiICIAEpAoABNwIAIAIgASkCiAE3AgggACACaiICIAEpApABNwIAIAIgASkCmAE3AgggACACaiICIAEpAqABNwIAIAIgASkCqAE3AgggACACaiICIAEpArABNwIAIAIgASkCuAE3AgggACACaiICIAEpAsABNwIAIAIgASkCyAE3AgggACACaiICIAEpAtABNwIAIAIgASkC2AE3AgggACACaiICIAEpAuABNwIAIAIgASkC6AE3AgggACACaiIAIAEpAvABNwIAIAAgASkC+AE3AgggBCABKQKAAjcCACAEIAVBA3QiAGoiBCABKQKIAjcCACAAIARqIgQgASkCkAI3AgAgACAEaiIEIAEpApgCNwIAIAAgBGoiBCABKQKgAjcCACAAIARqIgQgASkCqAI3AgAgACAEaiIEIAEpArACNwIAIAAgBGogASkCuAI3AgAgAyABKQLAAjcCACAAIANqIgMgASkCyAI3AgAgACADaiIDIAEpAtACNwIAIAAgA2oiAyABKQLYAjcCACAAIANqIgMgASkC4AI3AgAgACADaiIDIAEpAugCNwIAIAAgA2oiAyABKQLwAjcCACAAIANqIAEpAvgCNwIAC+gCAQV/AkAgACABEAIiAw0AQQEhAyABIAEoAgBBAWoiAjYCACACQSBLDQAgAEEEEAMiAkF/Rg0AIAEgAjYCBCAAQQQQAyICQX9GDQAgASACNgIIIAEoAgAEQANAIAAgASAFQQJ0aiICIgRBDGoQAiIDDQJBASEDIAQoAgwiBkF/Rg0CIAQgBkEBaiIDNgIMIAQgAyABKAIEQQZqdDYCDCAAIAJBjAFqEAIiAw0CQQEhAyACKAKMASIEQX9GDQIgAiAEQQFqIgQ2AowBIAIgBCABKAIIQQRqdDYCjAEgAEEBEAMiBEF/Rg0CIAIgBEEBRjYCjAIgBUEBaiIFIAEoAgBJDQALCyAAQQUQAyICQX9GDQAgASACQQFqNgKMAyAAQQUQAyICQX9GDQAgASACQQFqNgKQAyAAQQUQAyICQX9GDQAgASACQQFqNgKUAyAAQQUQAyIAQX9GDQAgASAANgKYA0EAIQMLIAMLWwEDfyAAIAAoAgAiBCABIAAoAgQiAnAiA0EEdGogASADayIBQQh0ajYCDCAAIAQgAiAAKAIIbCICQQh0aiABQQZ0aiADQQN0aiIBNgIQIAAgASACQQZ0ajYCFAtVAQJ/IAEgAkEBaiIDIAMgAUkbIQMgACACQQJ0aigCACEEA0ACQCACQQFqIgIgAU8EQCADIQIMAQsgACACQQJ0aigCACAERw0BCwtBACACIAEgAkYbCycAIABBCCAAKAIIIgBrEANBf0YEQA8LQQAgAGtBAnRBzD9qKAIAGgt6AQJ/IwBBIGsiAiQAIAIgACgCEDYCECACIAApAgg3AwggAiAAKQIANwMAAkAgAiACQRxqEAIiAA0AIAIgAkEcahACIgANACACIAJBHGoQAiIADQBBASEAIAIoAhwiA0H/AUsNACABIAM2AgBBACEACyACQSBqJAAgAAvnBwESfyMAQYAOayIMJAAgBkEFaiEJAkACQCACQQBIDQAgA0EASA0AIAIgCWogBEsNACADIAdqQQVqIAVLDQAgAyEKDAELIAAgDEHACmogAiADIAQgBSAJIAdBBWogCRAMIAxBwApqIQAgCSEEQQAhAgsCQCAHQQJ2IhRFDQAgCUUNACAEQQF0IRVBACAEayIWQQF0IRogBEECdCAGa0F7aiEXIAAgBCAKbCACamogBGoiACAEQQVsaiECIAwgCUECdCIQaiEDIAlBA3QhDUEAIAlrQQJ0IQ4gCUEDbEECdCEPA0AgCSEFA0AgAyANaiAAIBVqLQAAIhEgAiAVai0AACACIARqLQAAIgsgAiAaai0AACISaiIKayAKQQJ0a2ogAi0AACIYIAIgFmotAAAiE2pBFGxqNgIAIAMgEGogACAEai0AACIZIAsgEiATakEUbGogESAYaiIKayAKQQJ0a2o2AgAgAyAALQAAIgsgGCARIBJqQRRsaiATIBlqIgprIApBAnRrajYCACADIA5qIAAgFmotAAAgEyARIBlqQRRsaiALIBJqIgprIApBAnRrajYCACAAQQFqIQAgA0EEaiEDIAJBAWohAiAFQX9qIgUNAAsgAiAXaiECIAAgF2ohACADIA9qIQMgFEF/aiIUDQALCyAHBEBBECAGayEQIAZBAnYhCiAMIAhBAnRqQQhqIQAgDEEUaiECA0AgCgRAIAJBbGooAgAhBCACQXBqKAIAIQ8gAkF0aigCACENIAJBeGooAgAhBSACQXxqKAIAIQMgCiEJA0AgASACKAIAIg4gBCADIA9qIgRrIAUgDWpBFGxqIARBAnRrakGABGpBCnVBsC5qLQAAIAAoAgBBEGpBBXVBsC5qLQAAakEBakEBdjoAACABIAIoAgQiCyAPIAMgBWpBFGxqIA0gDmoiBGsgBEECdGtqQYAEakEKdUGwLmotAAAgACgCBEEQakEFdUGwLmotAABqQQFqQQF2OgABIAEgAigCCCIIIA0gAyAOakEUbGogBSALaiIEayAEQQJ0a2pBgARqQQp1QbAuai0AACAAKAIIQRBqQQV1QbAuai0AAGpBAWpBAXY6AAIgASACKAIM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KAIABEAgAyAAQewMaiABIABB5ApqKAIAIAIgACgC0ApBBUYgACgCuAkgACgCtAkQKQwBCyADQQAgASAAQeQKaigCACACIAAoAtAKQQVGIAAoArgJIAAoArQJECkLIABCADcCoAlBASEFCyAEQZABaiQAIAULqAwBC38CQCABQQRPBEBBACADayINQQF0IQoCQCAAIANrIgUtAAAiBiAALQAAIghrIgEgAUEfdSIBaiABcyACKAIEIgFPDQAgACAKai0AACIHIAZrIgQgBEEfdSIEaiAEcyACKAIIIgxPDQAgACADai0AACIEIAhrIgsgC0EfdSILaiALcyAMTw0AIAUgBCAGaiAHQQF0akECakECdjoAACAAIAggBEEBdGogB2pBAmpBAnY6AAAgAigCBCEBCwJAIABBAWoiBiANaiIMLQAAIgggAC0AASIHayIEIARBH3UiBGogBHMgAU8NACAGIApqLQAAIgQgCGsiBSAFQR91IgVqIAVzIAIoAggiC08NACADIAZqLQAAIgUgB2siCSAJQR91IglqIAlzIAtPDQAgDCAFIAhqIARBAXRqQQJqQQJ2OgAAIAYgByAFQQF0aiAEakECakECdjoAACACKAIEIQELAkAgAEECaiIGIA1qIgwtAAAiCCAALQACIgdrIgQgBEEfdSIEaiAEcyABTw0AIAYgCmotAAAiBCAIayIFIAVBH3UiBWogBXMgAigCCCILTw0AIAMgBmotAAAiBSAHayIJIAlBH3UiCWogCXMgC08NACAMIAUgCGogBEEBdGpBAmpBAnY6AAAgBiAHIAVBAXRqIARqQQJqQQJ2OgAAIAIoAgQhAQsCQCAAQQNqIgYgDWoiDC0AACIIIAAtAAMiB2siBCAEQR91IgRqIARzIAFPDQAgBiAKai0AACIEIAhrIgUgBUEfdSIFaiAFcyACKAIIIgtPDQAgAyAGai0AACIFIAdrIgkgCUEfdSIJaiAJcyALTw0AIAwgBSAIaiAEQQF0akECakECdjoAACAGIAcgBUEBdGogBGpBAmpBAnY6AAAgAigCBCEBCwJAIABBBGoiBiANaiIMLQAAIgggAC0ABCIHayIEIARBH3UiBGogBHMgAU8NACAGIApqLQAAIgQgCGsiBSAFQR91IgVqIAVzIAIoAggiC08NACADIAZqLQAAIgUgB2siCSAJQR91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ayISNgI8IAAgAiANayICIAMgDmsiA2siDTYCOCAAIAIgA2oiDjYCNCAAIBMgFGoiEzYCMCABQZA8ai0AACECIAFBoD1qLQAAQQxsQdA8aigCACEDIAFBDE8EQCAAIAMgAkF+anQiASAFIAtqIgMgCCATaiICa2w2AjAgACALIAVrIgUgCCATayIIayABbDYCICAAIAUgCGogAWw2AhAgACACIANqIAFsNgIAIAAgBCAJaiIDIAcgDmoiAmsgAWw2AjQgACAJIARrIgQgByAOayIFayABbDYCJCAAIAQgBWogAWw2AhQgACACIANqIAFsNgIEIAAgBiAPaiIDIAogDWoiAmsgAWw2AjggACAPIAZrIgYgCiANayIEayABbDYCKCAAIAQgBmogAWw2AhggACACIANqIAFsNgIIIAAgDCARayIDIBAgEmsiAmsgAWw2AiwgACACIANqIAFsNgIcIAAgECASaiIDIAwgEWoiAmogAWw2AgwgACACIANrIAFsNgI8DwsgAEEBQQIgAUF6akEGSRsiASAFIAtqIhQgCCATaiIVayADbGpBAiACayICdTYCMCAAIAsgBWsiBSAIIBNrIghrIANsIAFqIAJ1NgIgIAAgBSAIaiADbCABaiACdTYCECAAIBQgFWogA2wgAWogAnU2AgAgACAEIAlqIgUgByAOaiIIayADbCABaiACdTYCNCAAIAkgBGsiBCAHIA5rIgdrIANsIAFqIAJ1NgIkIAAgBCAHaiADbCABaiACdTYCFCAAIAUgCGogA2wgAWogAnU2AgQgACAGIA9qIgQgCiANaiIFayADbCABaiACdTYCOCAAIA8gBmsiBiAKIA1rIgprIANsIAFqIAJ1NgIoIAAgBiAKaiADbCABaiACdTYCGCAAIAQgBWogA2wgAWogAnU2AgggACAMIBFrIgYgECASayIEayADbCABaiACdTYCLCAAIAQgBmogA2wgAWogAnU2AhwgACAQIBJqIgYgDCARaiIRaiADbCABaiACdTYCDCAAIBEgBmsgA2wgAWogAnU2AjwLvQUBBn8jAEEgayIFJAAgA0EANgIAAkAgASgCACIGQRJLDQBBASAGdCIGQcDfH3FFBEAgBkEicUUNASACQbQKaigCAARAIANBATYCACACQQA2ArQKCyAAIAVBHGoQICIEDQFB8P8DIQQgAiAFKAIcQQJ0aigClAEiCEUNASACIAgoAgQiBkECdGooAhQiB0UNAQJAIAIoAggiCUEgRg0AIAYgCUYNACABKAIAQQVHDQILAkAgAkGYCmooAgAiBCABKAIEIgZGDQAgBEEAIAYbDQAgA0EBNgIACyABKAIAIQQCQAJAIAIoApQKQQVGBEAgBEEFRw0BDAILIARBBUcNAQsgA0EBNgIAC0EBIQQgACAHKAIMIAVBGGoQPQ0BIAUoAhgiBiACQZwKaigCAEcEQCACIAY2ApwKIANBATYCAAsgASgCAEEFRgRAIAAgBygCDCAFQRRqEDwNAgJAIAIoApQKQQVHBEAgBSgCFCEEDAELIAJBoApqKAIAIgQgBSgCFCIGRg0AIANBATYCACAGIQQLIAJBoApqIAQ2AgALAkAgBygCECIEQQFLDQAgBEEBawRAQQEhBCAAIAcgASgCACAFQQhqEDsNAyAFKAIIIgQgAkGkCmooAgBHBEAgAiAENgKkCiADQQE2AgALIAgoAghFDQEgACAHIAEoAgAgBUEQahA6IgQNAyAFKAIQIgAgAkGoCmooAgBGDQEgAiAANgKoCiADQQE2AgAMAQsgBygCGA0AIAAgByABKAIAIAgoAgggBUEIahA5IgQNAiAFKAIIIgAgAkGsCmooAgBHBEAgAiAANgKsCiADQQE2AgALIAgoAghFDQAgBSgCDCIAIAJBsApqKAIARg0AIAIgADYCsAogA0EBNgIACyACIAEpAgA3ApQKQQAhBAwBCyADQQE2AgALIAVBIGokACAEC38BA38CQAJAAkAgAEH8CmooAgAEQCAAKAKYCSIDDQFBAQ8LQQEhASAAQawJaigCACAAKAKYCUcNAQwCCyAAKAK8CSEBQQAhAANAIAIgASAAQdgBbGooAsQBQQBHaiECIABBAWoiACADRw0AC0EBIQEgAiADRg0BC0EAIQELIAELSgEDfyAAQgA3AqgJIAAoApgJIgEEQCAAKAK8CSECQQAhAANAIAIgAEHYAWxqIgNBADYCxAEgA0EANgIEIABBAWoiACABRw0ACwsLgwYBDH9BASEGAkAgACABQQJ0aigClAEiBEUNACAAIAQoAgQiCUECdGoiCkEUaigCACIDRQ0AAkAgBCgCDCIFQQJJDQAgAygCNCIHIAMoAjhsIQgCQCAEKAIQIgNBAksNAAJAAkACQCADQQFrDgIDAAELIAVBf2ohCyAEKAIcIQwgBCgCGCENQQAhAwwBCyAEKAIUIQdBACEDA0AgByADQQJ0aigCACAITQRAIAUgA0EBaiIDRw0BDAQLC0EBDwsDQCANIANBAnQiBWooAgAiDiAFIAxqKAIAIgVLDQMgBSAITw0DIA4gB3AgBSAHcE0EQCADQQFqIgMgC0YNAwwBCwtBAQ8LIANBfWpBAk0EQCAEKAIkIAhNDQEMAgsgA0EGRw0AIAQoAiggCEkNAQsCQCAAKAIEIgNBgAJGBEAgACAENgIMIAAgATYCBCAAIAk2AgggACAKKAIUIgE2AhAgASgCNCECIAEoAjghASAAQQE2ArQaIABBwApqIAE2AgAgAEG8CmogAjYCACAAIAEgAmw2ApgJDAELIAAoArQaBEAgAEEANgK0GiAAKAK8CRAEIABBADYCvAkgACgClAkQBCAAIAAoApgJIgFB2AFsIgQQCiICNgK8CSAAIAFBAnQQCiIDNgKUCUH//wMhBiACRQ0CIANFDQIgAkEAIAQQByAAKAIQKAI0IAEQTiAAKAIQIQFBASECAkAgACgCwAkNACABKAIQQQJGDQACQCABKAJQRQ0AIAEoAlQiBCgCmAdFDQAgBCgCsAdFDQELQQAhAgsgAEHECWogASgCOCABKAI0bCABKAJYIAEoAiwgASgCDCACEFwiBkUNAQwCCyABIANGDQAgACgCCCAJRwRAIAJFDQIgACAENgIMIAAgATYCBCAAIAk2AgggACAKKAIUIgE2AhAgASgCNCECIAEoAjghASAAQQE2ArQaIABBwApqIAE2AgAgAEG8CmogAjYCACAAIAEgAmw2ApgJDAELIAAgBDYCDCAAIAE2AgQLQQAhBgsgBgu2AQEDfwJAIAAgASgCACIDQQJ0aiICKAKUASIERQRAIAJByAAQCiIANgKUASAADQEPCwJAIAMgACgCBEcNACABKAIEIAAoAghGDQAgAEGBAjYCBAsgBCgCFBAEIAIoApQBQQA2AhQgAigClAEoAhgQBCACKAKUAUEANgIYIAIoApQBKAIcEAQgAigClAFBADYCHCACKAKUASgCLBAEIAIoApQBQQA2AiwLIAIoApQBIAFByAAQFRoL1gEBA38CQCAAIAEoAggiA0ECdGoiAigCFCIERQRAIAJB3AAQCiIANgIUIAANAQ8LIAAoAgggA0YEQCABIAAoAhAQQgRAIAIoAhQoAigQBCACKAIUQQA2AiggAigCFCgCVBAEIAIoAhRBADYCVCAAQQA2AhAgAEGBAjYCBCAAQiE3AggMAgsgASgCKBAEIAFBADYCKCABKAJUEAQgAUEANgJUDwsgBCgCKBAEIAIoAhRBADYCKCACKAIUKAJUEAQgAigCFEEANgJUCyACKAIUIAFB3AAQFRoL0gIBA38jAEEgayIEJAAgBCABKAIQNgIQIAQgASkCCDcDCCAEIAEpAgA3AwACQCAEIARBHGoQAiIBDQAgBCAEQRxqEAIiAQ0AIAQgBEEcahACIgENACACKAIMIQZBACEBA0AgASIFQQFqIQEgBiAFdg0ACyAEIAVBf2oQA0F/RgRAQQEhAQwBCyAEIARBHGoQAiIBDQACQCACKAIQIgEEfyABBSACKAIUIQZBACEBA0AgASIFQQFqIQEgBiAFdg0ACyAEIAVBf2oQA0F/RgRAQQEhAQwDCyADKAIIBEAgBCAEQRhqEAUiAQ0DCyACKAIQC0EBRw0AIAIoAhgNACAEIARBGGoQBSIBDQEgAygCCEUNACAEIARBGGoQBSIBDQELIAMoAkQEQCAEIARBHGoQAiIBDQELIAAgBEEBEAMiADYCACAAQX9GIQELIARBIGokACABC8YBAQJ/IwBBIGsiBSQAIAUgACgCEDYCECAFIAApAgg3AwggBSAAKQIANwMAAkAgBSAFQRxqEAIiAA0AIAUgBUEcahACIgANACAFIAVBHGoQAiIADQAgASgCDCEGQQAhAANAIAAiAUEBaiEAIAYgAXYNAAsgBSABQX9qEANBf0YEQEEBIQAMAQsgAkEFRgRAIAUgBUEcahACIgANAQsgBSAEEAUiAA0AIAMEQCAFIARBBGoQBSIADQELQQAhAAsgBUEgaiQAIAAL4QEBA38jAEEgayIEJAAgBCAAKAIQNgIQIAQgACkCCDcDCCAEIAApAgA3AwACQCAEIARBHGoQAiIADQAgBCAEQRxqEAIiAA0AIAQgBEEcahACIgANACABKAIMIQZBACEAA0AgACIFQQFqIQAgBiAFdg0ACyAEIAVBf2oQA0F/RgRAQQEhAAwBCyACQQVGBEAgBCAEQRxqEAIiAA0BCyABKAIUIQJBACEAA0AgACIBQQFqIQAgAiABdg0ACyAEIAFBf2oQA0F/RgRAQQEhAAwBCyAEIAMQBSEACyAEQSBqJAAgAAvmAQEDfyMAQSBrIgQkACAEIAAoAhA2AhAgBCAAKQIINwMIIAQgACkCADcDAAJAIAQgBEEcahACIgANACAEIARBHGoQAiIADQAgBCAEQRxqEAIiAA0AIAEoAgwhBkEAIQADQCAAIgVBAWohACAGIAV2DQALIAQgBUF/ahADQX9GBEBBASEADAELIAJBBUYEQCAEIARBHGoQAiIADQELIAEoAhQhAkEAIQADQCAAIgFBAWohACACIAF2DQALIAQgAUF/ahADIgBBf0YEQEEBIQAMAQsgAyAANgIAQQAhAAsgBEEgaiQAIAALkgEBAn8jAEEgayIDJAAgAyAAKAIQNgIQIAMgACkCADcDACADIAApAgg3AwgCQCADIANBHGoQAiIADQAgAyADQRxqEAIiAA0AIAMgA0EcahACIgANAEEAIQADQCAAIgRBAWohACABIAR2DQALIAMgBEF/ahADQX9GBEBBASEADAELIAMgAhACIQALIANBIGokACAAC5cBAQJ/IwBBIGsiAyQAIAMgACgCEDYCECADIAApAgg3AwggAyAAKQIANwMAAkAgAyADQRxqEAIiAA0AIAMgA0EcahACIgANACADIANBHGoQAiIADQBBACEAA0AgACIEQQFqIQAgASAEdg0ACyADIARBf2oQAyIAQX9GBEBBASEADAELIAIgADYCAEEAIQALIANBIGokACAAC68OAQp/IwBBEGsiBSQAIAFBAEHcBxAHIQcgAigCNCEGIAIoAjghCAJAIAAgBUEEahACIgENACAHIAUoAgQiATYCACABIAYgCGwiC08EQEEBIQEMAQsgACAFQQRqEAIiAQ0AIAcgBSgCBCIGNgIEIAZBB0sEQEEBIQEMAQtBASEBAkACQCAGQQFrDgcCAQICAAIBAAsgBCgCAEEFRgRADAILIAIoAiwNAAwBCyAAIAVBBGoQAiIBDQAgByAFKAIEIgY2AghBASEBIAYgAygCAEcNACACKAIMIQhBACEBA0AgASIGQQFqIQEgCCAGdg0AC0EBIQEgACAGQX9qEAMiBkF/Rg0AIAZBACAEKAIAIghBBUYbDQAgByAGNgIMIAhBBUYEQCAAIAVBBGoQAiIBDQEgByAFKAIEIgY2AhBBASEBIAZB//8DSw0B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IgMgAiANai0AACACIARqLQAAIgkgAiASai0AACIFaiIIayAIQQJ0a2ogAi0AACIKIAIgD2otAAAiCGpBFGxqQRBqQQV1QbAuai0AADoAMCABIAQgB2otAAAiECAJIAUgCGpBFGxqIAMgCmoiCWsgCUECdGtqQRBqQQV1QbAuai0AADoAICABIActAAAiCSAKIAMgBWpBFGxqIAggEGoiCmsgCkECdGtqQRBqQQV1QbAuai0AADoAECABIAcgD2otAAAgCCADIBBqQRRsaiAFIAlqIgNrIANBAnRrakEQakEFdUGwLmotAAA6AAAgB0EBaiEHIAFBAWohASACQQFqIQIgAEF/aiIADQALIAEgEWohASACIA5qIQIgByAOaiEHIAxBf2oiDA0ACwsgC0HAA2okAAuqBgENfyMAQbABayIRJAAgCEEBaiEKAkACQCACQQBIDQAgA0EASA0AIAIgCmogBEsNACADIAlqQQFqIAVLDQAgBSEMIAQhCiADIQ8MAQsgACARIAIgAyAEIAUgCiAJQQFqIgwgChAMIAAgBCAFbGogESAKIAxsaiACIAMgBCAFIAogDCAKEAwgESEAQQAhAgsCQCAJQQF2IgVFDQAgCEEBdiIERQ0AQRAgCGshE0EIIAdrIQtBCCAGayENIApBAXQiDiAIayEUIAAgAmoiFiAKIA9saiECIAEhACAFIRUDQCACIA5qLQAAIAdsIAsgAiAKai0AACIDbGohCCADIAdsIAsgAi0AAGxqIQkgBCEDA0AgAkEBaiIQIA5qLQAAIRIgACAJIA1sIAogEGotAAAiCSAHbCALIAItAAFsaiIQIAZsakEgakEGdjoAACAAIAggDWwgByASbCAJIAtsaiIIIAZsakEgakEGdjoACCACLQACIQkgAkECaiICIA5qLQAAIRIgACANIBBsIAIgCmotAAAiECAHbCAJIAtsaiIJIAZsakEgakEGdjoAASAAIAggDWwgByASbCALIBBsaiIIIAZsakEgakEGdjoACSAAQQJqIQAgA0F/aiIDDQALIAIgFGohAiAAIBNqIQAgFUF/aiIVDQALIAFBQGshACAWIAwgD2ogCmxqIQIDQCACIA5qLQAAIAdsIAsgAiAKai0AACIBbGohCCABIAdsIAsgAi0AAGxqIQkgBCEDA0AgAkEBaiIBIA5qLQAAIQwgACAJ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AmogAnNBA0shCgsgAyAKNgJoIAEuAaYBIR5BAiEbQQIhEwJAIC8gAS8BLCI0cg0AQQEhEyABLgGkASABLgGMAWsiAiACQR91IgJqIAJzQQNLDQAgHiAEayICIAJBH3UiAmogAnNBA0sNACABKAJ8IAEoAnRHIRMLIAMgEzYCcCABLgGqASEOAkAgECABLwEuIhhyDQBBASEbIAEuAagBIAEuAZABayICIAJBH3UiAmogAnNBA0sNACAOIAZrIgIgAkEfdSICaiACc0EDSw0AIAEoAnwgASgCdEchGwsgAyAbNgJ4IAEuAbYBIRlBAiESQQIhFQJAIBcgAS8BNCIgcg0AQQEhFSABLgG0ASABLgGcAWsiAiACQR91IgJqIAJzQQNLDQAgGSAHayICIAJBH3UiAmogAnNBA0sNACABKAKAASABKAJ4RyEVCyADIBU2AoABIAEuAboBISECQCAzIAEvATYiNXINAEEBIRIgAS4BuAEgAS4BoAFrIgIgAkEfdSICaiACc0EDSw0AICEgC2siAiACQR91IgJqIAJzQQNLDQAgASgCgAEgASgCeEchEgsgAyASNgKIASABLgGuASE2QQIhDSADAn9BAiA0IAEvATAiQXINABpBASABLgGsASABLgGkAWsiAiACQR91IgJqIAJzQQNLDQAaIDYgHmsiAiACQR91IgJqIAJzQQNLCyIdNgKQASABLgGyASEkAkAgGCABLwEyIjdyDQBBASENIAEuAbABIAEuAagBayICIAJBH3UiAmogAnNBA0sNACAkIA5rIgIgAkEfdSICaiACc0EDSyENCyADIA02ApgBIAEuAb4BISlBAiEcIAMCf0ECICAgAS8BOCI4cg0AGkEBIAEuAbwBIAEuAbQBayICIAJBH3UiAmogAnNBA0sNABogKSAZayICIAJBH3UiAmogAnNBA0sLIiY2AqABIAEuAcIBITkCQCA1IAEvAToiQnINAEEBIRwgAS4BwAEgAS4BuAFrIgIgAkEfdSICaiACc0EDSw0AIDkgIWsiAiACQR91IgJqIAJzQQNLIRwLIAMgHDYCqAFBAiECIAMCf0ECIBEgMHINABpBASABLgGIASABLgGEAWsiESARQR91IhFqIBFzQQNLDQAaIAggFGsiFCAUQR91IhRqIBRzQQNLCyIRNgI8AkAgMCAxcg0AQQEhAiAB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BSADLQAGampqQQJqQQJ2DAELIAcEQCADLQAEIAMtAAMgAy0AASADLQACampqQQJqQQJ2IQYgAy0ACCADLQAHIAMtAAUgAy0ABmpqakECakECdgwBCyAKRQRAQYABIQZBgAEMAQsgBC0AAyAELQACIAQtAAAgBC0AAWpqakECakECdiIGC0H/AXFBgYKECGwiADYAHCABIAZB/wFxQYGChAhsIgY2ABggASAANgAUIAEgBjYAECABIAA2AAwgASAGNgAIIAEgADYABCABIAY2AAACfyAKBEAgBC0AByAELQAGIAQtAAUgBC0ABGpqaiIGQQJqQQJ2IgAgB0UNARogAy0ACCADLQAHIAMtAAYgBiADLQAFampqakEEakEDdgwBCyAHRQRAQYABIQBBgAEMAQsgAy0ABCADLQADIAMtAAEgAy0AAmpqakECakECdiEAIAMtAAggAy0AByADLQAFIAMtAAZqampBAmpBAnYLIQYgASAAQf8BcUGBgoQIbCIANgAgIAEgBkH/AXFBgYKECGwiBjYAPCABIAA2ADggASAGNgA0IAEgADYAMCABIAY2ACwgASAANgAoIAEgBjYAJAwDCyAKRQRAQQEPCyABIAQtAAA6AAAgASAELQAAOgABIAEgBC0AADoAAiABIAQtAAA6AAMgASAELQAAOgAEIAEgBC0AADoABSABIAQtAAA6AAYgASAELQAAOgAHIAEgBC0AAToACCABIAQtAAE6AAkgASAELQABOgAKIAEgBC0AAToACyABIAQtAAE6AAwgASAELQABOgANIAEgBC0AAToADiABIAQtAAE6AA8gASAELQACOgAQIAEgBC0AAjoAESABIAQtAAI6ABIgASAELQACOgATIAEgBC0AAjoAFCABIAQtAAI6ABUgASAELQACOgAWIAEgBC0AAjoAFyABIAQtAAM6ABggASAELQADOgAZIAEgBC0AAzoAGiABIAQtAAM6ABsgASAELQADOgAcIAEgBC0AAzoAHSABIAQtAAM6AB4gASAELQADOgAfIAEgBC0ABDoAICABIAQtAAQ6ACEgASAELQAEOgAiIAEgBC0ABDoAIyABIAQtAAQ6ACQgASAELQAEOgAlIAEgBC0ABDoAJiABIAQtAAQ6ACcgASAELQAFOgAoIAEgBC0ABToAKSABIAQtAAU6ACogASAELQAFOgArIAEgBC0ABToALCABIAQtAAU6AC0gASAELQAFOgAuIAEgBC0ABToALyABIAQtAAY6ADAgASAELQAGOgAxIAEgBC0ABjoAMiABIAQtAAY6ADMgASAELQAGOgA0IAEgBC0ABjoANSABIAQtAAY6ADYgASAELQAGOgA3IAEgBC0ABzoAOCABIAQtAAc6ADkgASAELQAHOgA6IAEgBC0ABzoAOyABIAQtAAc6ADwgASAELQAHOgA9IAEgBC0ABzoAPiABIAQtAAc6AD8MAgsgB0UEQEEBDwsgASADLQABOgAAIAEgAy0AAToACCABIAMtAAE6ABAgASADLQABOgAYIAEgAy0AAToAICABIAMtAAE6ACggASADLQABOgAwIAEgAy0AAToAOCABIAMtAAI6AAEgASADLQACOgAJIAEgAy0AAjoAESABIAMtAAI6ABkgASADLQACOgAhIAEgAy0AAjoAKSABIAMtAAI6ADEgASADLQACOgA5IAEgAy0AAzoAAiABIAMtAAM6AAogASADLQADOgASIAEgAy0AAzoAGiABIAMtAAM6ACIgASADLQADOgAqIAEgAy0AAzoAMiABIAMtAAM6ADogASADLQAEOgADIAEgAy0ABDoACyABIAMtAAQ6ABMgASADLQAEOgAbIAEgAy0ABDoAIyABIAMtAAQ6ACsgASADLQAEOgAzIAEgAy0ABDoAOyABIAMtAAU6AAQgASADLQAFOgAMIAEgAy0ABToAFCABIAMtAAU6ABwgASADLQAFOgAkIAEgAy0ABToALCABIAMtAAU6ADQgASADLQAFOgA8IAEgAy0ABjoABSABIAMtAAY6AA0gASADLQAGOgAVIAEgAy0ABjoAHSABIAMtAAY6ACUgASADLQAGOgAtIAEgAy0ABjoANSABIAMtAAY6AD0gASADLQAHOgAGIAEgAy0ABzoADiABIAMtAAc6ABYgASADLQAHOgAeIAEgAy0ABzoAJiABIAMtAAc6AC4gASADLQAHOgA2IAEgAy0ABzoAPiABIAMtAAg6AAcgASADLQAIOgAPIAEgAy0ACDoAFyABIAMtAAg6AB8gASADLQAIOgAnIAEgAy0ACDoALyABIAMtAAg6ADcgASADLQAIOgA/DAELIA5FBEBBAQ8LIAMtAAUgAy0AA2sgAy0ABiADLQACa0EBdGogAy0AByADLQAB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ABA6AA8gAEEQaiEAIAVBAWoiBUEQRw0ACwwDCyAHRQRAQQEPC0EAIQUgASEAA0AgACAEIAVqIgMtAAA6AAAgACADLQAAOgABIAAgAy0AADoAAiAAIAMtAAA6AAMgACADLQAAOgAEIAAgAy0AADoABSAAIAMtAAA6AAYgACADLQAAOgAHIAAgAy0AADoACCAAIAMtAAA6AAkgACADLQAAOgAKIAAgAy0AADoACyAAIAMtAAA6AAwgACADLQAAOgANIAAgAy0AADoADiAAIAMtAAA6AA8gAEEQaiEAIAVBAWoiBUEQRw0ACwwCCyABAn8CQCAHRQ0AIAhFDQAgBC0ADyADLQAQIAQtAA4gAy0ADyAELQANIAMtAA4gBC0ADCADLQANIAQtAAsgAy0ADCAELQAKIAMtAAsgBC0ACSADLQAKIAQtAAggAy0ACSAELQAHIAMtAAggBC0ABiADLQAHIAQtAAUgAy0ABiAELQAEIAMtAAUgBC0AAyADLQAEIAQtAAIgAy0AAyAELQABIAMtAAIgAy0AASAELQAAampqampqampqampqampqampqampqampqampqampqakEQakEFdgwBCyAHBEAgBC0ADyAELQAOIAQtAA0gBC0ADCAELQALIAQtAAogBC0ACSAELQAIIAQtAAcgBC0ABiAELQAFIAQtAAQgBC0AAyAELQACIAQtAAAgBC0AAWpqampqampqampqampqakEIakEEdgwBC0GAASAIRQ0AGiADLQAQIAMtAA8gAy0ADiADLQANIAMtAAwgAy0ACyADLQAKIAMtAAkgAy0ACCADLQAHIAMtAAYgAy0ABSADLQAEIAMtAAMgAy0AASADLQACampqampqampqampqampqQQhqQQR2C0GAAhAHGgwBC0EBIQAgB0UNASAIRQ0BIAlFDQEgBC0ACCAELQAGayAELQAPIgAgAy0AACIFa0EDdGogBC0ACSAELQAFa0EBdGogBC0ACiAELQAEa0EDbGogBC0ACyAELQADa0ECdGogBC0ADCAELQACa0EFbGogBC0ADSAELQABa0EGbGogBC0ADiAELQAAa0EHbGpBBWxBIGpBBnUhByADLQAJIAMtAAdrIAMtAAogAy0ABmtBAXRqIAMtAAsgAy0ABWtBA2xqIAMtAAwgAy0ABGtBAnRqIAMtAA0gAy0AA2tBBWxqIAMtAA4gAy0AAmtBBmxqIAMtAA8gAy0AAWtBB2xqIAMtABAiAyAFa0EDdGpBBWxBIGpBBnUiBEEDdCEIIARBB2whCSAEQQZsIQogBEEFbCELIARBA2whDCAEQX1sIQ0gBEF7bCEOIARBemwhDyAEQXlsIRBBACAEQQF0IhFrIRJBACAEQQJ0IhNrIRQgACADakEEdEEQaiEVQQAhBQNAIAEgBUEEdCIAaiAVIAVBeWogB2xqIgMgEGpBBXUiBkH/ASAGQf8BSBsiBkEAIAZBAEobOgAAIAEgAEEBcmogAyAPakEFdSIGQf8BIAZB/wFIGyIGQQAgBkEAShs6AAAgASAAQQJyaiADIA5qQQV1IgZB/wEgBkH/AUgbIgZBACAGQQBKGzoAACABIABBA3JqIAMgFGpBBXUiBkH/ASAGQf8BSBsiBkEAIAZBAEobOgAAIAEgAEEEcmogAyANakEFdSIGQf8BIAZB/wFIGyIGQQAgBkEAShs6AAAgASAAQQVyaiADIBJqQQV1IgZB/wEgBkH/AUgbIgZBACAGQQBKGzoAACABIABBBnJqIAMgBGtBBXUiBkH/ASAGQf8BSBsiBkEAIAZBAEobOgAAIAEgAEEHcmogA0EFdSIGQf8BIAZB/wFIGyIGQQAgBkEAShs6AAAgASAAQQhyaiADIARqQQV1IgZB/wEgBkH/AUgbIgZBACAGQQBKGzoAACABIABBCXJqIAMgEWpBBXUiBkH/ASAGQf8BSBsiBkEAIAZBAEobOgAAIAEgAEEKcmogAyAMakEFdSIGQf8BIAZB/wFIGyIGQQAgBkEAShs6AAAgASAAQQtyaiADIBNqQQV1IgZB/wEgBkH/AUgbIgZBACAGQQBKGzoAACABIABBDHJqIAMgC2pBBXUiBkH/ASAGQf8BSBsiBkEAIAZBAEobOgAAIAEgAEENcmogAyAKakEFdSIGQf8BIAZB/wFIGyIGQQAgBkEAShs6AAAgASAAQQ5yaiADIAlqQQV1IgZB/wEgBkH/AUgbIgZBACAGQQBKGzoAACABIABBD3JqIAMgCGpBBXUiAEH/ASAAQf8BSBsiAEEAIABBAEobOgAAIAVBAWoiBUEQRw0ACwtBACEAIAEgAkEAEAggASACQUBrQQEQCCABIAJBgAFqQQIQCCABIAJBwAFqQQMQCCABIAJBgAJqQQQQCCABIAJBwAJqQQUQCCABIAJBgANqQQYQCCABIAJBwANqQQcQCCABIAJBgARqQQgQCCABIAJBwARqQQkQCCABIAJBgAVqQQoQCCABIAJBwAVqQQsQCCABIAJBgAZqQQwQCCABIAJBwAZqQQ0QCCABIAJBgAdqQQ4QCCABIAJBwAdqQQ8QCAsgAAvBCAEHfwJAIANFDQAgACgCACADIAAoAgQiBW4iCCAFbCIEQQh0aiADIARrIgdBBHRqIQYgBUEEdCEEIAAoAgghCSAFIANLIgpFBEAgASAGIARBf3NqIgMtAAA6AAAgASAGIARrLQAAOgABIAEgAy0AAjoAAiABIAMtAAM6AAMgASADLQAEOgAEIAEgAy0ABToABSABIAMtAAY6AAYgASADLQAHOgAHIAEgAy0ACDoACCABIAMtAAk6AAkgASADLQAKOgAKIAEgAy0ACzoACyABIAMtAAw6AAwgASADLQANOgANIAEgAy0ADjoADiABIAMtAA86AA8gASADLQAQOgAQIAEgAy0AEToAESABIAMtABI6ABIgASADLQATOgATIAEgAy0AFDoAFCABQRVqIQELIAcEQCACIAZBf2oiAy0AADoAACACIAMgBGoiAy0AADoAASACIAMgBGoiAy0AADoAAiACIAMgBGoiAy0AADoAAyACIAMgBGoiAy0AADoABCACIAMgBGoiAy0AADoABSACIAMgBGoiAy0AADoABiACIAMgBGoiAy0AADoAByACIAMgBGoiAy0AADoACCACIAMgBGoiAy0AADoACSACIAMgBGoiAy0AADoACiACIAMgBGoiAy0AADoACyACIAMgBGoiAy0AADoADCACIAMgBGoiAy0AADoADSACIAMgBGoiAy0AADoADiACIAMgBGotAAA6AA8gAkEQaiECCyAAKAIAIAUgCWwiBkEIdGogCCAFQQN0IgBsQQN0aiAHQQN0aiEEIABB+P///wdxIQAgCkUEQCABIAQgAEF/c2oiAy0AADoAACABIAQgAGstAAA6AAEgASADLQACOgACIAEgAy0AAzoAAyABIAMtAAQ6AAQgASADLQAFOgAFIAEgAy0ABjoABiABIAMtAAc6AAcgASADQQhqIgMtAAA6AAggASAGQQZ0IANqIgNBeGotAAA6AAkgASADQXlqLQAAOgAKIAEgA0F6ai0AADoACyABIANBe2otAAA6AAwgASADQXxqLQAAOgANIAEgA0F9ai0AADoADiABIANBfmotAAA6AA8gASADQX9qLQAAOgAQIAEgAy0AADoAEQsgB0UNACACIARBf2oiAS0AADoAACACIAAgAWoiAS0AADoAASACIAAgAWoiAS0AADoAAiACIAAgAWoiAS0AADoAAyACIAAgAWoiAS0AADoABCACIAAgAWoiAS0AADoABSACIAAgAWoiAS0AADoABiACIAAgAWoiAS0AADoAByACIAAgAWogBiAFa0EGdGoiAS0AADoACCACIAAgAWoiAS0AADoACSACIAAgAWoiAS0AADoACiACIAAgAWoiAS0AADoACyACIAAgAWoiAS0AADoADCACIAAgAWoiAS0AADoADSACIAAgAWoiAS0AADoADiACIAAgAWotAAA6AA8LC68BAQF/IwBB0ABrIgYkACACIAZBIGogBiADEFUCQAJAQQIgACgCACIDQQZHIANBBkkbQQFGBEAgACAFIAFByAJqIAZBIGogBiAEEFQiA0UNAQwCCyAAIAUgASAGQSBqIAYgBBBTIgMNAQsgACAFQYACaiABQcgKaiAGQTVqIAZBEGogASgCjAEgBBBSIgMNAEEAIQMgACgCxAFBAUsNACACIAUQGwsgBkHQAGokACADC6MqASR/IwBBIGsiECQAIBAgBCgCBCIINgIMIBAgBCgCCDYCECADIAhuIgZBBHQhFCADIAYgCGxrQQR0IRUCQAJAAkACQAJAAkACQAJAIAAoAgAiBkEDTQRAAkACQAJAIAZBAmsOAgECAAsgASgCkAEhEyAAKAIEIQ5BfyEPAn8gACgCyAEiCUUEQEEAIQhBfwwBC0EAIQhBfyAJKAIEIA5HDQAaQQEhEkF/IAkoAgBBBUsNABogCSgCmAEiCEEQdiEHIAkoAmgLIQ0gACgCzAEiCUUNCCAJKAIEIA5HDQhBASEWIAkoAgBBBUsNCCAJKAKsASIRQRB2IQogCSgCbCEPDAgLIAEoApABIRMgAS8BogEhDSABLwGgASEMIAAoAgQhC0F/IQcCQCAAKALMASIGRQ0AIAsgBigCBEcEQAwBC0EBIRIgBigCAEEFSw0AIAYoAqwBIglBEHYhCiAGKAJsIQcLIAcgE0YEQCAKIQcgCSEGDAcLQX8hDwJAAkACQCAAKALIASIIRQRAQQAh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AAAJAAAABAAAAAwAAAD/AAAAAAAAAP8AAAAAAAAABAAAAAkAAAAEAAAADAAAAAQAAAALAAAABAAAAA4AAAABAAAACgAAAP8AAAAAAAAA/wAAAAAAAAD/AAAAAAAAAAEAAAAKAAAABAAAAAAAAAD/AAAAAAAAAP8AAAAAAAAAAQAAAAoAAAABAAAACwAAAP8AAAAAAAAA/wAAAAAAAAABAAAACgAAAAEAAAALAAAABAAAAAAAAAAEAAAAAQAAAAEAAAAOAAAA/wAAAAAAAAD/AAAAAAAAAP8AAAAAAAAAAQAAAA4AAAAEAAAABAAAAP8AAAAAAAAA/wAAAAAAAAABAAAADgAAAAEAAAAPAAAA/wAAAAAAAAD/AAAAAAAAAAEAAAAOAAAAAQAAAA8AAAAEAAAABAAAAAQAAAAFAAAABAAAAAIAAAD/AAAAAAAAAP8AAAAAAAAA/wAAAAAAAAAEAAAAAgAAAAQAAAAIAAAA/wAAAAAAAAD/AAAAAAAAAAQAAAACAAAABAAAAAMAAAD/AAAAAAAAAP8AAAAAAAAABAAAAAIAAAAEAAAAAwAAAAQAAAAIAAAABAAAAAkAAAAEAAAABgAAAP8AAAAAAAAA/wAAAAAAAAD/AAAAAAAAAAQAAAAGAAAABAAAAAwAAAD/AAAAAAAAAP8AAAAAAAAABAAAAAYAAAAEAAAABwAAAP8AAAAAAAAA/wAAAAAAAAAEAAAABgAAAAQAAAAHAAAABAAAAAwAAAAEAAAADQAAAAEAAAAOAAAA/wAAAAAAAAD/AAAAAAAAAP8AAAAAAAAAAQAAAA4AAAD/AAAABAAAAP8AAAAAAAAA/wAAAAAAAAABAAAACwAAAAEAAAAOAAAA/wAAAAAAAAD/AAAAAAAAAAEAAAALAAAAAQAAAA4AAAAEAAAAAQAAAP8AAAAEAAAAAgAAAAoAAAD/AAAAAAAAAP8AAAAAAAAA/wAAAAAAAAACAAAACgAAAP8AAAAAAAAA/wAAAAAAAAD/AAAAAAAAAAEAAAAPAAAAAgAAAAoAAAD/AAAAAAAAAP8AAAAAAAAAAQAAAA8AAAACAAAACgAAAAQAAAAFAAAA/wAAAAAAAAAEAAAABgAAAP8AAAAAAAAA/wAAAAAAAAD/AAAAAAAAAAQAAAAGAAAA/wAAAAwAAAD/AAAAAAAAAP8AAAAAAAAABAAAAAMAAAAEAAAABgAAAP8AAAAAAAAA/wAAAAAAAAAEAAAAAwAAAAQAAAAGAAAABAAAAAkAAAD/AAAADAAAAP8AAAACAAAA/wAAAAAAAAD/AAAAAAAAAP8AAAAAAAAA/wAAAAIAAAD/AAAACAAAAP8AAAAAAAAA/wAAAAAAAAAEAAAABwAAAP8AAAACAAAA/wAAAAAAAAD/AAAAAAAAAAQAAAAHAAAA/wAAAAIAAAAEAAAADQAAAP8AAAAIAAAAAwAAAA8AAAD/AAAAAAAAAP8AAAAAAAAA/wAAAAAAAAADAAAADwAAAAAAAAAFAAAA/wAAAAAAAAD/AAAAAAAAAAMAAAAPAAAAAQAAAAoAAAD/AAAAAAAAAP8AAAAAAAAAAwAAAA8AAAABAAAACgAAAAAAAAAFAAAABAAAAAAAAAABAAAACwAAAP8AAAAAAAAA/wAAAAAAAAD/AAAAAAAAAAEAAAALAAAABAAAAAEAAAD/AAAAAAAAAP8AAAAAAAAAAQAAAAsAAAABAAAADgAAAP8AAAAAAAAA/wAAAAAAAAABAAAACwAAAAEAAAAOAAAABAAAAAEAAAAEAAAABAAAAAAAAAAHAAAA/wAAAAAAAAD/AAAAAAAAAP8AQdQnCxUHAAAAAAAAAA0AAAD/AAAAAAAAAP8AQfQnCxUHAAAABAAAAAIAAAD/AAAAAAAAAP8AQZQoC9kBBwAAAAQAAAACAAAAAAAAAA0AAAAEAAAACAAAAAQAAAADAAAA/wAAAAAAAAD/AAAAAAAAAP8AAAAAAAAABAAAAAMAAAAEAAAACQAAAP8AAAAAAAAA/wAAAAAAAAAEAAAAAwAAAAQAAAAGAAAA/wAAAAAAAAD/AAAAAAAAAAQAAAADAAAABAAAAAYAAAAEAAAACQAAAAQAAAAMAAAAAAAAAAQAAAAAAAAABAAAAAgAAAAMAAAACAAAAAwAAAAAAAAABAAAAAAAAAAEAAAACAAAAAwAAAAIAAAADABB+CkLBQQAAAAEAEGIKgslBAAAAAQAAAAIAAAACAAAAAwAAAAMAAAACAAAAAgAAAAMAAAADABBsS4LyAYBAgMEBQYHCAkKCwwNDg8QERITFBUWFxgZGhscHR4fICEiIyQlJicoKSorLC0uLzAxMjM0NTY3ODk6Ozw9Pj9AQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVpbXF1eX2BhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ent8fX5/gIGCg4SFhoeIiYqLjI2Oj5CRkpOUlZaXmJmam5ydnp+goaKjpKWmp6ipqqusra6vsLGys7S1tre4ubq7vL2+v8DBwsPExcbHyMnKy8zNzs/Q0dLT1NXW19jZ2tvc3d7f4OHi4+Tl5ufo6err7O3u7/Dx8vP09fb3+Pn6+/z9/v///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////wAAAAABAAAABAAAAAUAAAACAAAAAwAAAAYAAAAHAAAACAAAAAkAAAAMAAAADQAAAAoAAAALAAAADgAAAA8AAAAAAAAAAQAAAAEAQYQ1CyEBAAAAAQAAAAEAAAABAAAAAgAAAAIAAAABAAAAAgAAAAIAQbQ1CwUFAAAABABBxDULyQYHAAAABAAAAAIAAAAEAAAAAQAAAAQAAAAEAAAABAAAAAMAAAAEAAAABgAAAAAAAAANAAAABAAAAAgAAAAAAAAADwAAAAQAAAAKAAAABAAAAAkAAAAEAAAADAAAAAQAAAALAAAABAAAAA4AAAAAAAAAEQAAAAQAAAAQAAAAAAAAABMAAAAEAAAAEgAAAAAAAAAVAAAABAAAABQAAAAAAAAAFwAAAAQAAAAWAAAAAQAAAAoAAAABAAAACwAAAAQAAAAAAAAABAAAAAEAAAABAAAADgAAAAEAAAAPAAAABAAAAAQAAAAEAAAABQAAAAQAAAACAAAABAAAAAMAAAAEAAAACAAAAAQAAAAJAAAABAAAAAYAAAAEAAAABwAAAAQAAAAMAAAABAAAAA0AAAABAAAAEgAAAAEAAAATAAAABAAAABAAAAAEAAAAEQAAAAEAAAAWAAAAAQAAABcAAAAEAAAAFAAAAAQAAAAVAAAAAQAAAAsAAAABAAAADgAAAAQAAAABAAAA/wAAAAQAAAABAAAADwAAAAIAAAAKAAAABAAAAAUAAAD/AAAAAAAAAAQAAAADAAAABAAAAAYAAAAEAAAACQAAAP8AAAAMAAAABAAAAAcAAAD/AAAAAgAAAAQAAAANAAAA/wAAAAgAAAABAAAAEwAAAAIAAAASAAAABAAAABEAAAD/AAAAEAAAAAEAAAAXAAAAAgAAABYAAAAEAAAAFQAAAP8AAAAUAAAAAwAAAA8AAAABAAAACgAAAAAAAAAFAAAABAAAAAAAAAABAAAACwAAAAEAAAAOAAAABAAAAAEAAAAEAAAABAAAAAAAAAAHAAAABAAAAAIAAAAAAAAADQAAAAQAAAAIAAAABAAAAAMAAAAEAAAABgAAAAQAAAAJAAAABAAAAAwAAAADAAAAEwAAAAEAAAASAAAAAAAAABEAAAAEAAAAEAAAAAMAAAAXAAAAAQAAABYAAAAAAAAAFQAAAAQAAAAUAAAAAQAAAAEAAAACAAAAAgAAAAMAAAADAAAAAwAAAAMAAAAAAAAAAQAAAAIAAAADAAAABAAAAAUAAAAGAAAABwAAAAgAAAAJAAAACgAAAAsAAAAMAAAADQAAAA4AAAAPAEGWPAsuAQEBAQEBAgICAgICAwMDAwMDBAQEBAQEBQUFBQUFBgYGBgYGBwcHBwcHCAgICABB0DwLRQoAAAANAAAAEAAAAAsAAAAOAAAAEgAAAA0AAAAQAAAAFAAAAA4AAAASAAAAFwAAABAAAAAUAAAAGQAAABIAAAAXAAAAHQBBoT0LMwECAwQFAAECAwQFAAECAwQFAAECAwQFAAECAwQFAAECAwQFAAECAwQFAAECAwQFAAECAwBB5D0LzAIBAAAAAgAAAAMAAAAEAAAABQAAAAYAAAAHAAAACAAAAAkAAAAKAAAACwAAAAwAAAANAAAADgAAAA8AAAAQAAAAEQAAABIAAAATAAAAFAAAABUAAAAWAAAAFwAAABgAAAAZAAAAGgAAABsAAAAcAAAAHQAAAB0AAAAeAAAAHwAAACAAAAAgAAAAIQAAACIAAAAiAAAAIwAAACMAAAAkAAAAJAAAACUAAAAlAAAAJQAAACYAAAAmAAAAJgAAACcAAAAnAAAAJwAAACcAAAABAAAAAgAAAAQAAAAIAAAAEAAAACAAAABAAAAAgAAAAC8fDwAXGx0eBwsNDicrLS4QAwUKDBMVGhwjJSosAQIECBESFBgGCRYZICEiJCgmKQAQAQIECCADBQoMDy8HCw0OBgkfIyUqLCEiJCgnKy0uERIUGBMVGhwXGx0eFhkmKQ=="},D={};function o(){var A,I=E()({locateFile:function(A){return i[A]}});return(A=I,new Promise((function(I){A.calledRun?I():A.onRuntimeInitialized=function(){return I()}}))).then((function(){self.addEventListener("message",(function(A){var g=A.data,B=g.renderStateId;switch(g.type){case"decode":var C=D[B];C||(C=new Q(I,(function(A,I,g){postMessage({type:"pictureReady",width:I,height:g,renderStateId:B,data:A.buffer},[A.buffer])})),D[B]=C),C.decode(new Uint8Array(g.data,g.offset,g.length));break;case"release":var E=D[B];E&&(E.release(),delete D[B])}})),self.postMessage({type:"decoderReady"})}))}}},I={};function g(B){var Q=I[B];if(void 0!==Q)return Q.exports;var C=I[B]={exports:{}};return A[B](C,C.exports,g),C.exports}g.n=A=>{var I=A&&A.__esModule?()=>A.default:()=>A;return g.d(I,{a:I}),I},g.d=(A,I)=>{for(var B in I)g.o(I,B)&&!g.o(A,B)&&Object.defineProperty(A,B,{enumerable:!0,get:I[B]})},g.o=(A,I)=>Object.prototype.hasOwnProperty.call(A,I),g.r=A=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(A,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(A,"__esModule",{value:!0})},(()=>{"use strict";g(340).init()})()})();',"Worker",void 0,void 0)}},614:A=>{A.exports=function(A,I,g,B){var Q=self||window;try{try{var C;try{C=new Q.Blob([A])}catch(I){(C=new(Q.BlobBuilder||Q.WebKitBlobBuilder||Q.MozBlobBuilder||Q.MSBlobBuilder)).append(A),C=C.getBlob()}var e=Q.URL||Q.webkitURL,i=e.createObjectURL(C),t=new Q[I](i,g);return e.revokeObjectURL(i),t}catch(B){return new Q[I]("data:application/javascript,".concat(encodeURIComponent(A)),g)}}catch(A){if(!B)throw Error("Inline worker is not supported");return new Q[I](B,g)}}}},I={};function g(B){var Q=I[B];if(void 0!==Q)return Q.exports;var C=I[B]={exports:{}};return A[B].call(C.exports,C,C.exports,g),C.exports}return g.n=A=>{var I=A&&A.__esModule?()=>A.default:()=>A;return g.d(I,{a:I}),I},g.d=(A,I)=>{for(var B in I)g.o(I,B)&&!g.o(A,B)&&Object.defineProperty(A,B,{enumerable:!0,get:I[B]})},g.o=(A,I)=>Object.prototype.hasOwnProperty.call(A,I),g.r=A=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(A,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(A,"__esModule",{value:!0})},g(114)})());class tg{constructor(A,I,g){this.glCtx=void 0,this.program=void 0,this.glCtx=A,this.program=this.glCtx.createProgram(),this.glCtx.attachShader(this.program,I),this.glCtx.attachShader(this.program,g),this.glCtx.linkProgram(this.program),this.glCtx.getProgramParameter(this.program,this.glCtx.LINK_STATUS)||II(tg.name,"Shader link failed.")}static compile(A,I,g){let B;B="vertex"===I?A.createShader(A.VERTEX_SHADER):A.createShader(A.FRAGMENT_SHADER),A.shaderSource(B,g),A.compileShader(B);return 0==A.getShaderParameter(B,A.COMPILE_STATUS)&&II(tg.name,"Shader compile failed, log: "+A.getShaderInfoLog(B)),B}static create(A,I,g){const B=tg.compile(A,"vertex",I),Q=tg.compile(A,"fragment",g);return new tg(A,B,Q)}use(){this.glCtx.useProgram(this.program)}getAttributeLocation(A){return this.glCtx.getAttribLocation(this.program,A)}getUniformLocation(A){const I=this.glCtx.getUniformLocation(this.program,A);if(I)return I}setMatrixUniform(A,I){this.glCtx.uniformMatrix4fv(A,!1,I)}}class Eg{constructor(A,I,g,B,Q,C,e,i,t){this.glCtx=A,this.program=I,this.projectionMtxLoc=g,this.positionAttr=B,this.texCoordAttr=Q,this.vertexBuffer=C,this.yTextureLoc=e,this.uTextureLoc=i,this.vTextureLoc=t}static create(A){const I=tg.create(A,"\n    precision mediump float;\n\n    uniform mat4 uProjection;\n    attribute vec2 aPosition;\n    attribute vec2 aTexCoord;\n\n    varying vec2 vTexCoord;\n    void main(){\n        vTexCoord = aTexCoord;\n        gl_Position = uProjection * vec4(aPosition, 0.0, 1.0);\n    }\n","\n    precision lowp float;\n\n    varying vec2 vTexCoord;\n\n    uniform sampler2D yTexture;\n    uniform sampler2D uTexture;\n    uniform sampler2D vTexture;\n    const mat3 conversion = mat3(\n        1.164, 0.000,  1.596,\n        1.164, -0.391, -0.813,\n        1.164, 2.018,  0.000\n    );\n\n    const vec3 offset = vec3(0.0625, 0.5, 0.5);\n\n    void main(void) {\n        float y = texture2D(yTexture, vTexCoord).x;\n        float u = texture2D(uTexture, vTexCoord).x;\n        float v = texture2D(vTexture, vTexCoord).x;\n        vec3 yuv = vec3(y, u, v) - offset;\n\n        vec3 rgb = (yuv * conversion);\n\n        gl_FragColor = vec4(rgb, 1.0);\n    }\n");I.use();const g=I.getUniformLocation("uProjection"),B=I.getAttributeLocation("aPosition");A.enableVertexAttribArray(B);const Q=I.getAttributeLocation("aTexCoord");A.enableVertexAttribArray(Q);const C=A.createBuffer(),e=I.getUniformLocation("yTexture"),i=I.getUniformLocation("uTexture"),t=I.getUniformLocation("vTexture");return new Eg(A,I,g,B,Q,C,e,i,t)}bindInputTextures(A,I,g){const B=this.glCtx;B.uniform1i(this.yTextureLoc,0),B.activeTexture(B.TEXTURE0),B.bindTexture(B.TEXTURE_2D,A.textureId),B.uniform1i(this.uTextureLoc,1),B.activeTexture(B.TEXTURE1),B.bindTexture(B.TEXTURE_2D,I.textureId),B.uniform1i(this.vTextureLoc,2),B.activeTexture(B.TEXTURE2),B.bindTexture(B.TEXTURE_2D,g.textureId)}use(){this.program.use()}drop(){this.glCtx.useProgram(0)}update(A,I,g,B){this.glCtx.viewport(0,0,A,I),this.program.setMatrixUniform(this.projectionMtxLoc,[2/A,0,0,0,0,2/-I,0,0,0,0,1,0,-1,1,0,1]),this.glCtx.bindBuffer(this.glCtx.ARRAY_BUFFER,this.vertexBuffer),this.glCtx.bufferData(this.glCtx.ARRAY_BUFFER,new Float32Array([0,0,0,0,A,0,g,0,A,I,g,B,A,I,g,B,0,I,0,B,0,0,0,0]),this.glCtx.DYNAMIC_DRAW),this.glCtx.vertexAttribPointer(this.positionAttr,2,this.glCtx.FLOAT,!1,16,0),this.glCtx.vertexAttribPointer(this.texCoordAttr,2,this.glCtx.FLOAT,!1,16,8)}draw(){const A=this.glCtx;A.clear(A.COLOR_BUFFER_BIT|A.DEPTH_BUFFER_BIT|A.STENCIL_BUFFER_BIT),A.drawArrays(A.TRIANGLE_STRIP,0,6),A.bindTexture(A.TEXTURE_2D,null)}}class og{constructor(A,I){this.glCtx=void 0,this.textureId=void 0,this.glCtx=A,this.textureId=I}static create(A){const I=A.createTexture();return A.bindTexture(A.TEXTURE_2D,I),A.texParameteri(A.TEXTURE_2D,A.TEXTURE_MAG_FILTER,A.NEAREST),A.texParameteri(A.TEXTURE_2D,A.TEXTURE_MIN_FILTER,A.NEAREST),A.texParameteri(A.TEXTURE_2D,A.TEXTURE_WRAP_S,A.CLAMP_TO_EDGE),A.texParameteri(A.TEXTURE_2D,A.TEXTURE_WRAP_T,A.CLAMP_TO_EDGE),A.bindTexture(A.TEXTURE_2D,null),new og(A,I)}uploadBuffer(A,I,g){const B=this.glCtx;B.bindTexture(B.TEXTURE_2D,this.textureId),B.texImage2D(B.TEXTURE_2D,0,B.LUMINANCE,I,g,0,B.LUMINANCE,B.UNSIGNED_BYTE,A),B.bindTexture(B.TEXTURE_2D,null)}delete(){null!=this.glCtx&&0!=this.textureId&&(this.glCtx.deleteTexture(this.textureId),this.textureId=0)}}class ag{constructor(A,I){this.codecString=A,this.format=I,this.readyState=NI.Detached,this.needsRestartEvent=new _A,this.readyStateChangeEvent=new _A,this.videoFrameProcessingDurationEvent=new _A,this.videoFrameEvent=new _A,this.currentFrameInfo={containsSPS:!1,containsPPS:!1,containsFrameData:!0},this.paused=!1,this.stats=new ZI,this.totalFrames=0,this.waitingToDecodeQueue=[],this.decodeQueue=[],this.maxDecodeQueueSize=3,this.maxLatencyFrameCount=7,this.maxConsecutiveFramesDrops=3,this.framesDroppedSinceLastRender=0,this.totalFramesDropped=0,this.canvas=void 0,this.shader=void 0,this.yTexture=void 0,this.uTexture=void 0,this.vTexture=void 0,this.onDecode=({width:A,height:I,data:g})=>{if(0==this.decodeQueue.length)return II(ag.name,"onDecode called with empty decoder queue!"),void this.sendDecoderWaitingToDecodeFrames();++this.totalFrames;const B=this.decodeQueue.shift();if(!this.paused){const Q=Date.now();if(B.processingDuration=(Q-B.mediaTime)/1e3,this.videoFrameProcessingDurationEvent.invoke(B.processingDuration),this.dataQueueLength>this.maxLatencyFrameCount&&this.framesDroppedSinceLastRender<this.maxConsecutiveFramesDrops)++this.framesDroppedSinceLastRender,++this.totalFramesDropped;else{this.framesDroppedSinceLastRender=0;const Q=B.width,C=B.height;B.width=A,B.height=I,this.stats.pushFrameMetadata(B),this.renderFrame(Q,C,g,A,I),this.videoFrameEvent.invoke([performance.now(),B])}}this.sendDecoderWaitingToDecodeFrames()},this.ensureBuffer=()=>{this.readyState===NI.WaitingForKeyframe&&0===this.dataQueueLength&&(QI(ag.name,"Sending another request for a keyframe."),this.restart())},this.videoFormat=I,this.decoderWorker=new ig,this.decoderWorker.initialize(),this.decoderWorker.onDecode=this.onDecode.bind(this),this.ensureBufferInterval=window.setInterval(this.ensureBuffer,1e3)}get dataQueueLength(){return this.waitingToDecodeQueue.length+this.decodeQueue.length}configure(A,I,g){this.maxDecodeQueueSize=A,this.maxLatencyFrameCount=I,this.maxConsecutiveFramesDrops=g}attachToElement(A){this.stats.resetFrameCounts(),this.readyState!=NI.WaitingForKeyframe&&this.restart()}attachToCanvas(A){this.readyState!=NI.WaitingForKeyframe&&this.restart(),this.canvas&&this.detachFromCanvas(),this.canvas=A;const I=A.getContext("webgl");this.shader=Eg.create(I),this.yTexture=og.create(I),this.uTexture=og.create(I),this.vTexture=og.create(I)}detachFromElement(){this.setReadyState(NI.Detached)}detachFromCanvas(){this.decoderWorker.release(),this.yTexture&&this.yTexture.delete(),this.uTexture&&this.uTexture.delete(),this.vTexture&&this.vTexture.delete(),this.canvas=void 0}pause(){this.paused=!0,this.setReadyState(NI.Paused)}play(){this.paused&&(this.paused=!1,this.restart())}restart(){this.totalFrames=0,this.totalFramesDropped=0,this.framesDroppedSinceLastRender=0,this.waitingToDecodeQueue=[],this.setReadyState(NI.WaitingForKeyframe),this.needsRestartEvent.invoke()}pushData(A){if(this.stats.pushData(A.data),this.paused)return;const I=new Uint8Array(A.data);let g=!1;if(this.videoFormat==Cg.LengthPrefixed?g=this.convertToAnnexbFormat(I):this.readyState==NI.WaitingForKeyframe&&(g=this.parseAnnexbFrameInfo(I)),this.readyState==NI.WaitingForKeyframe)if(g)this.setReadyState(NI.Playing);else if(!this.currentFrameInfo?.containsFrameData)return(this.currentFrameInfo?.containsSPS||this.currentFrameInfo?.containsPPS)&&this.decoderWorker.decode(I),this.currentFrameInfo.containsSPS=!1,this.currentFrameInfo.containsPPS=!1,void(this.currentFrameInfo.containsFrameData=!0);if(this.readyState!=NI.WaitingForKeyframe&&this.currentFrameInfo.containsFrameData){const g={width:A.header.width,height:A.header.height,mediaTime:Date.now(),processingDuration:0,expectedDisplayTime:0,presentationTime:0,presentedFrames:0};this.decode(g,I)}}convertToAnnexbFormat(A){let I=!1;this.currentFrameInfo.containsFrameData=!1;for(let g=0;g<A.length;){const B=this.ntohl(A,g);A[g]=0,A[++g]=0,A[++g]=0,A[++g]=1,++g;const Q=31&A[g];Q<=5&&Q>=1?(I=5==Q,this.currentFrameInfo.containsFrameData=!0):7==Q?this.currentFrameInfo.containsSPS=!0:8==Q&&(this.currentFrameInfo.containsPPS=!0),g+=B}return I}ntohl(A,I){return(255&A[I])<<24|(255&A[I+1])<<16|(255&A[I+2])<<8|255&A[I+3]}parseAnnexbFrameInfo(A){let I=!1;this.currentFrameInfo.containsFrameData=!1;for(let g=0;g<A.length;)if(0==A[g]&&0==A[g+1]){let B=0;if(1==A[g+2]?(g+=3,B=31&A[g]):0==A[g+2]&&1==A[g+3]?(g+=4,B=31&A[g]):++g,B<=5&&B>=1){if(this.currentFrameInfo.containsFrameData=!0,5==B){I=!0;break}}else 7==B?this.currentFrameInfo.containsSPS=!0:8==B&&(this.currentFrameInfo.containsPPS=!0)}else++g;return I}decode(A,I){0==this.decodeQueue.length?(0!=this.waitingToDecodeQueue.length&&(II(ag.name,"empty decoder queue, but waiting to decode queue not empty!"),this.waitingToDecodeQueue=[]),this.sendToDecoder(A,I)):(this.waitingToDecodeQueue.push({metadata:A,data:I}),this.decodeQueue.length<this.maxDecodeQueueSize&&this.sendDecoderWaitingToDecodeFrames())}sendDecoderWaitingToDecodeFrames(){for(;this.decodeQueue.length<this.maxDecodeQueueSize&&this.waitingToDecodeQueue.length>0;){const A=this.waitingToDecodeQueue.shift();this.sendToDecoder(A.metadata,A.data)}}sendToDecoder(A,I){this.stats.reportFrameSubmitted(),this.decodeQueue.push(A),this.decoderWorker.decode(I)}renderFrame(A,I,g,B,Q){this.canvas.width=A,this.canvas.height=I;const C=new Uint8Array(g),e=B*Q,i=C.subarray(0,e),t=e>>2,E=C.subarray(e,e+t),o=C.subarray(e+t,e+2*t);this.yTexture.uploadBuffer(i,B,Q);const a=B>>1,s=Q>>1;this.uTexture.uploadBuffer(E,a,s),this.vTexture.uploadBuffer(o,a,s),this.shader.bindInputTextures(this.yTexture,this.uTexture,this.vTexture);const n=A/B,r=I/Q;this.shader.update(B,Q,n,r),this.shader.draw()}getStats(){return this.stats.getReportSoftwareDecoder(this.totalFramesDropped,this.totalFrames,this.readyState)}setReadyState(A){this.readyState=A,this.readyStateChangeEvent.invoke(A)}dispose(){QI(ag.name,"Disposing"),this.readyState=NI.Disposed,this.decoderWorker.release(),this.decoderWorker.dispose(),window.clearInterval(this.ensureBufferInterval)}}const sg={droppedFrames:"Dropped frames",totalFrames:"Total frames",currentTime:"Current video time",endOfBuffered:"End of video buffer",endOfSeekable:"End of video seekable",dataInterval:"Video data interval",dataSize:"Video frame size",processingDuration:"Frame processing duration"};class ng{constructor(A,I,g){this.videoStream=A,this.usingOutputCanvas=I,this.getStats=g,this.compositingTimeTrack=new HI(5e3,KI),this.processingDurationTrack=new HI(5e3,KI),this.frameTrack=new HI(5e3,KI),this.drawIntervalTrack=new HI(5e3,KI),this.displayTimeIntervalTrack=new HI(5e3,KI),this.frameCounter=0,this.throughput=[],this.fetchStats=async()=>{this.videoStream.readyState===NI.Playing&&(this.stats=this.videoStream.getStats(),this.lastTransportStats=this.transportStats,this.transportStats=await this.getStats(),this.throughput=this.getThroughput())},this.animationFrameHandler=()=>{this.frameTrack.feed(this.frameCounter),this.frameCounter=0,this.animationFrameHandle=window.requestAnimationFrame(this.animationFrameHandler)},this.drawStatsOnlyOnAnimationFrame=()=>{if(this.drawStatsOnlyHandle=window.requestAnimationFrame(this.drawStatsOnlyOnAnimationFrame),!this.canvasContext||this.videoStream.readyState!==NI.Playing)return;const A=this.canvasContext;this.usingOutputCanvas||(A.canvas.width!==A.canvas.clientWidth&&(A.canvas.width=A.canvas.clientWidth),A.canvas.height!==A.canvas.clientHeight&&(A.canvas.height=A.canvas.clientHeight),A.clearRect(0,0,A.canvas.width,A.canvas.height)),this.drawStats()},this.drawStatsAndGraphsOnVideoFrame=([A,I])=>{if(this.frameCounter++,!this.canvasContext||this.videoStream.readyState!==NI.Playing||!I)return;const g=this.canvasContext;this.usingOutputCanvas||(g.canvas.width!==g.canvas.clientWidth&&(g.canvas.width=g.canvas.clientWidth),g.canvas.height!==g.canvas.clientHeight&&(g.canvas.height=g.canvas.clientHeight),g.clearRect(0,0,g.canvas.width,g.canvas.height));const B=performance.now();this.lastCanvasDrawTime&&this.drawIntervalTrack.feed(B-this.lastCanvasDrawTime),this.lastCanvasDrawTime=B;const Q=I.expectedDisplayTime;this.lastDisplayTime&&this.displayTimeIntervalTrack.feed(Q-this.lastDisplayTime),this.lastDisplayTime=Q,this.compositingTimeTrack.feed(I.expectedDisplayTime-A),this.processingDurationTrack.feed(I.processingDuration);const C=g.canvas;C.width,C.clientWidth,C.height,C.clientHeight,this.drawStats(I)}}setElements({video:A,canvas:I,usingOutputCanvas:g=!1}){this.usingOutputCanvas=g,this.canvas=I,this.video=A,this.canvas&&(this.canvasContext=this.canvas.getContext("2d",{alpha:!this.usingOutputCanvas}))}enable(){this.animationFrameHandle&&window.cancelAnimationFrame(this.animationFrameHandle),this.drawStatsOnlyHandle&&window.cancelAnimationFrame(this.drawStatsOnlyHandle),this.videoStream instanceof ag||"requestVideoFrameCallback"in HTMLVideoElement.prototype?(this.animationFrameHandle=window.requestAnimationFrame(this.animationFrameHandler),this.videoStream.videoFrameEvent.addHandler(this.drawStatsAndGraphsOnVideoFrame)):this.drawStatsOnlyHandle=window.requestAnimationFrame(this.drawStatsOnlyOnAnimationFrame),this.statsInterval=window.setInterval(this.fetchStats,1e3)}disable(){this.animationFrameHandle&&window.cancelAnimationFrame(this.animationFrameHandle),this.drawStatsOnlyHandle&&window.cancelAnimationFrame(this.drawStatsOnlyHandle),this.videoStream.videoFrameEvent.removeHandler(this.drawStatsAndGraphsOnVideoFrame),window.clearInterval(this.statsInterval)}getThroughput(){return this.transportStats&&this.lastTransportStats?Object.entries(this.transportStats?.channels).map((([A,I])=>this.lastTransportStats?[A,I.bytesSent-this.lastTransportStats.channels[A].bytesSent,I.bytesReceived-this.lastTransportStats.channels[A].bytesReceived]:[A,0,0])):[]}drawStats(A){if(!this.canvasContext||this.videoStream.readyState!==NI.Playing)return;const I=this.canvasContext,g=I.canvas,B=g.width/g.clientWidth,Q=g.height/g.clientHeight,C=this.throughput;if(this.stats){const e=Object.entries(this.stats),i=e.length+C.length,t=I.measureText("M").width;I.fillStyle="rgba(0, 0, 0, 0.5)";const E=(i+2)*t+2*(t+2*Q)+15*Q;I.fillRect(10*B,g.height-(E+10*Q),300*B,E),I.fillStyle="white",I.font=`${(12*B).toFixed(0)}px sans-serif`,I.textBaseline="top";let o=0;const a=g.height-(E+15*Q)+15*B;A?I.fillText(`Resolution: ${A.width}x${A.height}`,15*B,a):I.fillText(`Resolution: ${this.video?.videoWidth}x${this.video?.videoHeight}`,15*B,a),I.fillText(`Element size: ${g.clientWidth}x${g.clientHeight}`,15*B,a+t);for(const[A,g]of e){let C,e="";"processingDuration"===A?(e="ms",C=1e3*g):C=g,"endOfBuffered"===A||"endOfSeekable"===A||"currentTime"===A?e="s":"dataInterval"===A?e="ms":"dataSize"===A&&(e="bytes"),I.fillText(`${sg[A]}: ${C.toFixed(2)} ${e}`,15*B,o*(t+2*Q)+2*(t+2*Q)+a),o++}for(const[A,g,e]of C)I.fillText(`${A} throughput - up: ${(g/1e3).toFixed(0)} kb/s, down: ${(e/1e3).toFixed(0)} kb/s`,15*B,o*(t+2*Q)+2*(t+2*Q)+a),o++}}}var rg,hg,dg,cg,Dg,wg,Fg,Sg,yg,Gg,Rg,ug,lg,kg,Ug,Ng,mg,Mg,Lg,fg,pg,Hg,Jg;!function(A){A[A.MSE=0]="MSE",A[A.Software=1]="Software"}(hg||(hg={})),function(A){A[A.IsolatedApps=0]="IsolatedApps",A[A.FullDesktop=1]="FullDesktop"}(dg||(dg={}));class Kg{constructor(A,I,Q,C){this.streamType=A,this.chosenVideoConfig=I,rg.set(this,void 0),this.overlayEnabled=!1,this.streamFit=dg.IsolatedApps,B(this,rg,{video:{codecString:'video/mp4; codecs="avc1.42c020"',...this.autodetectVideoConfiguration(),...Q.video},videoPerformance:Q.videoPerformance??{},audio:{...Q.audio}},"f"),g(this,rg,"f").video.decoder===hg.Software?this.videoStream=new ag(g(this,rg,"f").video.codecString,Cg.LengthPrefixed):this.videoStream=new _I(g(this,rg,"f").video.codecString),this.audioStream=new gg,this.audioStream.configure(g(this,rg,"f").audio),this.videoPerformanceMonitor=new Qg(this.videoStream,g(this,rg,"f").videoPerformance),this.videoStatsOverlay=new ng(this.videoStream,g(this,rg,"f").video.decoder===hg.Software,C)}get videoReadyStateChangeEvent(){return this.videoStream.readyStateChangeEvent}get videoNeedsRestartEvent(){return this.videoStream.needsRestartEvent}get audioContext(){return this.audioStream.audioContext}get currentStreamBounds(){return this.streamBounds}get currentFullDesktopBounds(){return this.fullDesktopBounds}async initialize(){await this.audioStream.initialize(),this.audioStream.play()}get config(){return g(this,rg,"f")}autodetectVideoConfiguration(){return{decoder:window.MediaSource?hg.MSE:hg.Software}}setContainer(A){if(this.unsetContainer(),this.container=A,this.streamType===FA.AppIsolation){const A=this.createIsolationCanvasElement();this.showStreamElement(A),g(this,rg,"f").video.decoder===hg.MSE?this.setIsolationSource(this.createVideoElement()):this.setIsolationSource(this.createCanvasElement())}else g(this,rg,"f").video.decoder===hg.MSE?this.showStreamElement(this.createVideoElement()):this.showStreamElement(this.createCanvasElement());this.overlayEnabled&&this.createAndShowStatsOverlay()}setIsolationSource(A){this.isolationSource=A}createAndShowStatsOverlay(){const A=this.createOverlayCanvasElement();this.showOverlayElement(A),g(this,rg,"f").video.decoder===hg.MSE?this.videoStatsOverlay.setElements({video:this.videoElement,canvas:A,usingOutputCanvas:!1}):this.videoStatsOverlay.setElements({canvas:A,usingOutputCanvas:!1})}unsetContainer(){this.disposeVideoElement(),this.disposeCanvasElement(),this.disposeOverlayCanvasElement(),this.disposeIsolationCanvasElement(),this.container?.querySelector(".rainway-video")?.remove(),this.container?.querySelector(".rainway-canvas")?.remove(),this.container?.querySelector(".rainway-overlay-canvas")?.remove(),this.container?.querySelector(".rainway-isolation-canvas")?.remove(),this.container=void 0}showOverlayElement(A){Object.assign(A.style,{position:"absolute",top:"0",bottom:"0",left:"0",right:"0",width:"100%",height:"100%",pointerEvents:"none"})}createVideoElement(){this.container?.querySelector(".rainway-video")?.remove(),this.videoElement=document.createElement("video");const A=this.videoElement;return A.oncontextmenu=()=>!1,A.className="rainway-video",A.autoplay=!0,A.muted=!0,A.style.display="none",this.container.appendChild(A),this.videoStream.attachToElement(A),this.videoElement}disposeVideoElement(){this.videoElement&&(this.videoStream.detachFromElement(),this.videoElement.remove(),this.videoElement=void 0)}createOverlayCanvasElement(){this.container?.querySelector(".rainway-overlay-canvas")?.remove(),this.canvasElement=document.createElement("canvas");const A=this.canvasElement;return A.oncontextmenu=()=>!1,A.className="rainway-overlay-canvas",this.container.appendChild(A),A.getContext("2d")?.clearRect(0,0,A.width,A.height),A}disposeOverlayCanvasElement(){this.container?.querySelector(".rainway-overlay-canvas")?.remove(),this.overlayCanvasElement&&(this.overlayCanvasElement.remove(),this.overlayCanvasElement=void 0)}createCanvasElement(){this.container?.querySelector(".rainway-canvas")?.remove(),this.canvasElement=document.createElement("canvas");const A=this.canvasElement;return A.oncontextmenu=()=>!1,A.className="rainway-canvas",A.style.display="none",this.container.appendChild(A),this.videoStream instanceof ag&&this.videoStream.attachToCanvas(A),A.getContext("2d")?.clearRect(0,0,A.width,A.height),A}disposeCanvasElement(){this.canvasElement&&(this.videoStream instanceof ag&&this.videoStream.detachFromCanvas(),this.canvasElement.remove(),this.canvasElement=void 0)}createIsolationCanvasElement(){this.container?.querySelector(".rainway-isolation-canvas")?.remove(),this.isolationCanvasElement=document.createElement("canvas");const A=this.isolationCanvasElement;return A.oncontextmenu=()=>!1,A.className="rainway-isolation-canvas",this.container.appendChild(A),A.getContext("2d")?.clearRect(0,0,A.width,A.height),A}disposeIsolationCanvasElement(){this.isolationCanvasElement&&(this.isolationCanvasElement.remove(),this.isolationCanvasElement=void 0)}hideStreamElement(A){A.style.width="0",A.style.height="0"}showStreamElement(A){this.container&&(this.streamElement=A,A.style.width="100%",A.style.height="100%",A.style.display="block",A.style.objectFit="contain")}pause(){this.videoStream.pause(),this.audioStream.stop()}play(){this.videoStream.play(),this.audioStream.play()}renderVideoFrame(A){this.videoStream.pushData(A);const{header:I}=A;this.fullDesktopBounds={left:I.x,top:I.y,width:I.width,height:I.height},this.streamType===FA.AppIsolation?(I.mask.length>0&&(this.mask=I.mask),I.width>0&&(this.frameWidth=I.width),I.height>0&&(this.frameHeight=I.height),this.renderIsolatedApp()):this.streamBounds=this.fullDesktopBounds}renderIsolatedApp(){if(!this.mask)return;if(!this.frameWidth)return;if(!this.frameHeight)return;const A=this.isolationSource;if(!A)return;const I=this.isolationCanvasElement;if(!I)return;const g=I.getContext("2d");if(!g)return;const B=this.streamFit==dg.IsolatedApps?function(A){const I=A.length;if(0===I)throw new Error("boundingRectangle() of 0 rectangles");const g=A[0];let{left:B,top:Q}=g,C=B+g.width,e=Q+g.height;for(let g=1;g<I;g++){const I=A[g];B=Math.min(B,I.left),Q=Math.min(Q,I.top),C=Math.max(C,I.left+I.width),e=Math.max(e,I.top+I.height)}return{left:B,top:Q,width:C-B,height:e-Q}}(this.mask):this.fullDesktopBounds;this.streamBounds=B;const Q=this.chosenVideoConfig.codec.width/this.frameWidth,C=this.chosenVideoConfig.codec.height/this.frameHeight;I.width=B.width*Q,I.height=B.height*C;for(const{left:I,top:e,width:i,height:t}of this.mask){const E=I*Q,o=e*C,a=i*Q,s=t*C,n=(I-B.left)*Q,r=(e-B.top)*C;g.drawImage(A,E,o,a,s,n,r,a,s)}}processAudio(A){this.audioStream.pushData(A)}getVideoStats(){return this.videoStream.getStats()}async configureAudio(A){g(this,rg,"f").audio={...g(this,rg,"f").audio,...A},this.audioStream.configure(A)}enableStatsOverlay(){this.overlayEnabled=!0,this.videoStatsOverlay.enable(),this.disposeOverlayCanvasElement(),this.createAndShowStatsOverlay()}disableStatsOverlay(){this.disposeOverlayCanvasElement(),this.overlayEnabled=!1,this.videoStatsOverlay.disable()}dispose(){this.pause(),this.unsetContainer(),this.audioStream.dispose(),this.videoStream.dispose()}setVolume(A){this.audioStream.setVolume(A)}}rg=new WeakMap;class qg extends sI{constructor(A,I,g,Q=5e3){super(),this.getTransportStats=A,this.getVideoStats=I,this.getRateControlStats=g,this.statsSummaryIntervalMs=Q,cg.set(this,{entries:[]}),Dg.set(this,void 0),wg.set(this,0),Fg.set(this,0),Sg.set(this,0),yg.set(this,0),Gg.set(this,0),Rg.set(this,void 0),B(this,Dg,window.setInterval(this.pushStatsSummary.bind(this),Q),"f"),B(this,Rg,Date.now(),"f")}get report(){return g(this,cg,"f")}dispose(){this.removeAllEventListeners(),window.clearInterval(g(this,Dg,"f"))}async pushStatsSummary(){const A=await this.getTransportStats(),I=A.channels,Q=I.RW_Audio?.bytesReceived||0,C=I.RW_Video?.bytesReceived||0,e=this.statsSummaryIntervalMs/1e3,i=(Q-g(this,wg,"f"))/1e3,t=(C-g(this,Fg,"f"))/1e3,{videoBitrateKbps:E}=this.getRateControlStats(),o=Date.now(),a={audioThroughputKbps:i/e,videoThroughputKbps:t/e,videoReceivedFps:g(this,Gg,"f")/e,videoBitrateKbps:E,inputEvents:g(this,Sg,"f"),cursorEvents:g(this,yg,"f"),seconds:(o-g(this,Rg,"f"))/1e3,latencyMs:A.latencyMs};this.push({type:"stats",stats:a}),this.emit("stats",a),B(this,Sg,0,"f"),B(this,yg,0,"f"),B(this,Gg,0,"f"),B(this,wg,Q,"f"),B(this,Fg,C,"f"),B(this,Rg,Date.now(),"f")}push(A){g(this,cg,"f").entries.push({...A,timeUnixMs:Date.now()})}log(A){this.push({type:A})}logStart(A,I,g,B,Q){this.push({type:"started",localPeerId:A.toString(),hostPeerId:I.toString(),streamId:g,videoCodec:B,streamType:Q===FA.FullDesktop?"fullDesktop":Q===FA.AppIsolation?"appIsolation":"byofb"})}logVideoReadyState(A){this.push({type:"videoReadyState",state:NI[A]})}logVideoBitrateChange(A,I){A!==I&&this.push({type:"videoBitrateChange",newKbps:A,oldKbps:I,direction:A>I?"up":"down"})}countInputEvent(){var A;B(this,Sg,(A=g(this,Sg,"f"),++A),"f")}countCursorEvent(){var A;B(this,yg,(A=g(this,yg,"f"),++A),"f")}countVideoFrame(){var A;B(this,Gg,(A=g(this,Gg,"f"),++A),"f")}}cg=new WeakMap,Dg=new WeakMap,wg=new WeakMap,Fg=new WeakMap,Sg=new WeakMap,yg=new WeakMap,Gg=new WeakMap,Rg=new WeakMap;class Yg extends sI{constructor(A,I,Q,C,e,i,t,E,o,a,s){super(),this.peer=A,this.id=I,this.chosenAudioConfig=C,this.chosenVideoConfig=e,this.streamType=i,this.sendBebopInput=E,this.sendLogic=o,this.discardInParent=s,this.resizeDebounceHandle=void 0,ug.set(this,!1),lg.set(this,void 0),this.sendKeyframeRequest=()=>{this.sendLogic({discriminator:LA.discriminator,value:{streamId:this.id}})},this.feedVideoStateIntoRateController=A=>{g(this,lg,"f")?.logVideoReadyState(A),this.rateController.handleVideoReadyState(A)},this.setRemoteClipboard=()=>{"function"!=typeof navigator?.clipboard?.readText||kI||navigator.clipboard.readText().then((A=>{this.sendBebopInput({discriminator:CA.discriminator,value:{text:A}})}))};const n=document.createElement("div");n.tabIndex=0,n.style.touchAction="none",n.style.userSelect="none",n.style.webkitUserSelect="none",n.style.position="relative",n.style.width="100%",n.style.height="100%",n.className="rainway-inner-container",n.addEventListener("focus",this.setRemoteClipboard),this.innerContainer=n,this.inputManager=new pI(this),this.mediaManager=new Kg(i,e,{video:{codecString:YI(e.codec)}},a),this.mediaManager.streamFit=t.streamFit??dg.FullDesktop,this.rateController=new xI(void 0,e,((A,B)=>{this.sendLogic({discriminator:fA.discriminator,value:{streamId:I,bitsPerSecond:1e3*A}}),g(this,lg,"f")?.logVideoBitrateChange(A,B)}),this.mediaManager.videoPerformanceMonitor),n.addEventListener("click",(()=>{this.resumeAudio()})),this.mediaManager.setContainer(n),this.mediaManager.videoNeedsRestartEvent.addHandler(this.sendKeyframeRequest),this.mediaManager.videoReadyStateChangeEvent.addHandler(this.feedVideoStateIntoRateController),this.inputManager.setContainer(n),this.inputManager.setInputLevel(Q),this.containerResizeObserver=new ResizeObserver((()=>{this.resizeDebounceHandle&&window.clearTimeout(this.resizeDebounceHandle),this.resizeDebounceHandle=window.setTimeout((()=>{this.sendBebopInput({discriminator:QA.discriminator,value:{width:this.innerContainer.clientWidth,height:this.innerContainer.clientHeight}}),this.resizeDebounceHandle=void 0}),100)})),this.containerResizeObserver.observe(n),t.metrics&&(B(this,lg,new qg(a,(()=>this.mediaManager.getVideoStats()),(()=>this.rateController.getStats())),"f"),g(this,lg,"f").logStart(A.connection.id,A.id,I,e.codec.friendlyName,i),g(this,lg,"f").addEventListener("stats",(A=>{this.emit("stats",A)})))}get ended(){return g(this,ug,"f")}get container(){return this.innerContainer}get permissions(){return this.inputManager.getInputLevel()}get currentFrameSize(){const{codec:A}=this.chosenVideoConfig;return{codecWidth:A.width,codecHeight:A.height,streamBounds:this.mediaManager.currentStreamBounds,fullDesktopBounds:this.mediaManager.currentFullDesktopBounds}}get streamFit(){return this.mediaManager.streamFit}async initialize(){await this.mediaManager.initialize()}processAudio(A){this.mediaManager.processAudio(A)}processCursor(A){g(this,lg,"f")?.countCursorEvent(),this.inputManager.processCursor(A)}renderVideoFrame(A){this.rateController.feedFrameTimestamp(A.header.timestamp),this.mediaManager.renderVideoFrame(A)}transformPointerOffsetToRemote(A,I){const g=this.mediaManager.currentStreamBounds;if(!g)return;const B=this.mediaManager.currentFullDesktopBounds;if(!B)return;const{left:Q,top:C,width:e,height:i}=B,{left:t,top:E,width:o,height:a}=g,s=this.chosenVideoConfig.codec.width,n=this.chosenVideoConfig.codec.height,r=this.innerContainer.clientWidth,h=this.innerContainer.clientHeight,d=o*s/e,c=a*n/i,D=Math.min(r/d,h/c);return{x:(A-(r-D*d)/2)/(D*s/e)+t-Q,y:(I-(h-D*c)/2)/(D*n/i)+E-C}}releaseKeys(){this.inputManager.releaseKeys()}enableVideoStatsOverlay(){this.mediaManager?.enableStatsOverlay()}disableVideoStatsOverlay(){this.mediaManager?.disableStatsOverlay()}requestFullscreen(A){const I=A?.lockKeyboard??!0,g=A?.lockPointer??!0;if(this.innerContainer.requestFullscreen?this.innerContainer.requestFullscreen({navigationUI:"hide"}):this.innerContainer.webkitRequestFullscreen({navigationUI:"hide"}),I&&"keyboard"in navigator)try{navigator.keyboard.lock()}catch(A){}g&&this.inputManager?.lockPointer()}play(){if(g(this,ug,"f"))throw new Q("Attempted to play a dead stream");g(this,lg,"f")?.log("resumed"),this.mediaManager.play(),this.rateController.start()}pause(){if(g(this,ug,"f"))throw new Q("Attempted to pause a dead stream");g(this,lg,"f")?.log("paused"),this.mediaManager.pause(),this.rateController.stop()}close(){g(this,lg,"f")?.log("stopped"),g(this,ug,"f")?gI(Yg.name,"Attempted to leave a dead stream"):(this.sendLogic({discriminator:mA.discriminator,value:{streamId:this.id}}),this.discardInParent(),this.resizeDebounceHandle&&clearTimeout(this.resizeDebounceHandle),this.innerContainer.removeEventListener("focus",this.setRemoteClipboard),this.containerResizeObserver.disconnect(),this.mediaManager.videoNeedsRestartEvent.removeHandler(this.sendKeyframeRequest),this.mediaManager.videoReadyStateChangeEvent.removeHandler(this.feedVideoStateIntoRateController),this.inputManager.dispose(),this.mediaManager.dispose(),g(this,lg,"f")?.dispose(),this.rateController.stop(),this.removeAllEventListeners(),B(this,ug,!0,"f"))}emitClose(){this.emit("close")}resumeAudio(){this.mediaManager?.audioContext?.resume()}enableGestures(){this.inputManager?.enableGestures()}disableGestures(){this.inputManager?.disableGestures()}handleOutgoingInput(A,I){const B=function(A){switch(A.discriminator){case V.discriminator:return{type:UI.Gamepad,...A.value};case j.discriminator:return;case Z.discriminator:return{type:UI.MouseAbsolute,...A.value};case z.discriminator:return{type:UI.MouseRelative,...A.value};case _.discriminator:return{type:UI.MouseClick,...A.value};case $.discriminator:return{type:UI.MouseScroll,...A.value};case AA.discriminator:return{type:UI.Keyboard,action:A.value.action,key:A.value.keycode};case IA.discriminator:return{type:UI.PasteText,...A.value};case gA.discriminator:return{type:UI.TouchesAbsolute,...A.value};case BA.discriminator:return{type:UI.PenAbsolute,...A.value};case QA.discriminator:return{type:UI.ViewportResize,...A.value};case CA.discriminator:return{type:UI.SetClipboardText,...A.value}}}(A);if(!B)return;let Q=!1;this.emit("before-input",{input:B,heldKeys:I,preventDefault:()=>{Q=!0}}),Q||(g(this,lg,"f")?.countInputEvent(),this.sendBebopInput(A))}sendInput(A){this.sendBebopInput(function(A){switch(A.type){case UI.Gamepad:return{discriminator:V.discriminator,value:A};case UI.MouseAbsolute:return{discriminator:Z.discriminator,value:A};case UI.MouseRelative:return{discriminator:z.discriminator,value:A};case UI.MouseClick:return{discriminator:_.discriminator,value:A};case UI.MouseScroll:return{discriminator:$.discriminator,value:A};case UI.Keyboard:return{discriminator:AA.discriminator,value:{action:A.action,keycode:A.key}};case UI.PasteText:return{discriminator:IA.discriminator,value:A};case UI.TouchesAbsolute:return{discriminator:gA.discriminator,value:A};case UI.PenAbsolute:return{discriminator:BA.discriminator,value:A};case UI.ViewportResize:return{discriminator:QA.discriminator,value:A};case UI.SetClipboardText:return{discriminator:CA.discriminator,value:A};default:throw new Q("unhandled input.type")}}(A))}getReport(){return g(this,lg,"f")?.report}}ug=new WeakMap,lg=new WeakMap;class vg extends sI{constructor(A,I,g,Q){super(),this.transport=Q,kg.set(this,void 0),Ug.set(this,i.New),Ng.set(this,new Map),mg.set(this,new Map),Mg.set(this,void 0),Lg.set(this,void 0),this.lastTimestamp=void 0,B(this,kg,A,"f"),B(this,Mg,I,"f"),B(this,Lg,g,"f"),Q.onRainwayMessage=this.handleTransportMessage.bind(this),Q.onClose=this.onTransportClose.bind(this)}get state(){return g(this,Ug,"f")}get connection(){if(g(this,kg,"f"))return g(this,kg,"f");throw new Q("Peer's RainwayConnection was disposed.")}get disconnected(){return this.state===i.Disconnected||this.state===i.Failed}get streams(){return g(this,Ng,"f")}get dataChannels(){return g(this,mg,"f")}get id(){return g(this,Mg,"f")}get externalId(){return g(this,Lg,"f")}onTransportClose(){this.applyStateChange(i.Failed)}applyStateChange(A){if(B(this,Ug,A,"f"),this.emit("connection-state-change",A),A===i.Failed){for(const A of g(this,Ng,"f").values())A.emitClose();this.dispose(),this.emit("close")}}async sendDeviceInfoAndExchangeCodecs(){if(this.disconnected)throw new Q("Couldn't send device info and exchange codecs: peer is disconnected");this.sendDeviceInfo();const A=await this.exchangeCodecs();if(0==A.length)throw new Q("Unable to find a codec pair that both peers can use");this.transport.sendLogicDatagram({discriminator:kA.discriminator,value:WI(A)})}handleTransportMessage(A){"Logic"===A.kind?this.handleLogicMessage(A.body):"Input"===A.kind?this.handleInputMessage(A.body):"Media"===A.kind&&this.handleMediaMessage(A.body)}sendDeviceInfo(){if(this.disconnected)throw new Q("Couldn't send device info: peer is disconnected");this.transport.sendLogicDatagram({discriminator:RA.discriminator,value:{isWeb:!0,formFactor:aA.Computer,deviceName:"deviceName",deviceId:"deviceId",deviceModel:"",deviceOs:sA.Other,deviceOsVersion:"",userAgent:navigator.userAgent}})}send(A,I){if(A.startsWith("RW_"))throw new Q("Data channel names starting with RW_ are reserved for Rainway");if(this.disconnected)throw new Q("Couldn't send message: peer is disconnected");const g="string"==typeof I?(new TextEncoder).encode(I):I;this.transport.sendArbitraryDatagram(A,g)}close(){this.dispose(),this.transport.close()}dispose(){for(const A of g(this,Ng,"f").values())A.close();B(this,kg,void 0,"f"),g(this,Ng,"f").clear(),g(this,mg,"f").clear()}async createStream(A){if(this.disconnected)throw new Q("Couldn't request stream: peer is disconnected");const I=await this.exchangeCodecs();if(0==I.length)throw new Error("Unable to re-negotiate codecs");return this.transport.sendLogicDatagram({discriminator:kA.discriminator,value:WI(I)}),this.transport.sendLogicDatagram({discriminator:NA.discriminator,value:{inputLevel:A.permissions}}),new Promise(((I,g)=>{this.requestedOptions=A,this.resolveStream=I,this.rejectStream=g}))}async handleLogicMessage(A){if(A.discriminator===RA.discriminator)this.debug("Got remote DeviceInfo:\n"+JSON.stringify(A.value));else if(A.discriminator===uA.discriminator)this.transport.sendLogicDatagram({discriminator:lA.discriminator,value:{videoCodecs:[]}});else if(A.discriminator===lA.discriminator)this.codecsResolve?.(A.value.videoCodecs);else if(A.discriminator===kA.discriminator)this.debug("Got remote ClientCapabilities:\n"+JSON.stringify(A.value));else if(A.discriminator===NA.discriminator)this.warn("Got remote StreamRequest?\n"+JSON.stringify(A.value));else if(A.discriminator===YA.discriminator)if(void 0!==this.resolveStream){const I=await this.createStreamInternal(A.value.streamInfo,this.requestedOptions);g(this,Ng,"f").set(I.id,I),this.transport.sendLogicDatagram({discriminator:pA.discriminator,value:{streamId:A.value.streamInfo.streamId}}),this.resolveStream(I),this.resolveStream=void 0,this.rejectStream=void 0,this.requestedOptions=void 0}else this.emit("stream-announcement",{info:A.value.streamInfo,join:async I=>{this.debug("Joining stream");const B=await this.createStreamInternal(A.value.streamInfo,I??{});return g(this,Ng,"f").set(B.id,B),this.transport.sendLogicDatagram({discriminator:pA.discriminator,value:{streamId:A.value.streamInfo.streamId}}),this.resolveStream=void 0,this.rejectStream=void 0,B}});else A.discriminator===JA.discriminator?void 0!==this.rejectStream?(this.rejectStream(A.value.reason),this.resolveStream=void 0,this.rejectStream=void 0):this.warn("Got RejectStreamRequest, but didn't ask for a stream."):A.discriminator===mA.discriminator?this.warn("Got remote LeaveStream?\n"+JSON.stringify(A.value)):A.discriminator===MA.discriminator?(this.debug("Got remote StreamStopping:\n"+JSON.stringify(A.value)),this.discardStream(A.value.streamId)):A.discriminator===bA.discriminator||(A.discriminator,PA.discriminator)}async createStreamInternal(A,I){const{streamId:g}=A,B=new Yg(this,g,A.defaultInputLevel,A.chosenAudioConfig,A.chosenVideoConfig,A.streamType,I,(A=>this.transport.sendInputDatagram({streamId:g,inner:A})),(A=>this.transport.sendLogicDatagram(A)),(()=>this.transport.getStats()),(()=>this.discardStream(g)));return await B.initialize(),B}discardStream(A){g(this,Ng,"f").delete(A)}handleInputMessage(A){const I=A.inner;if(I.discriminator===j.discriminator){const A=I.value.leftMotorSpeed,g=I.value.rightMotorSpeed;pI.vibrateGamepad(I.value.port,{duration:100,startDelay:0,strongMagnitude:Math.max(A,g)/65535,weakMagnitude:0})}else if(I.discriminator===CA.discriminator){const A=I.value.text;"function"==typeof navigator?.clipboard?.writeText&&navigator.clipboard.writeText(A).then((()=>{}))}else this.warn(`Ignoring unrecognized Input discriminator ${I.discriminator}`)}handleMediaMessage(A){if(A.discriminator===XA.discriminator){const{data:I,segmentTime:B,type:Q,desktopRect:C,mask:e,streamId:i}=A.value,t=g(this,Ng,"f").get(i);if(!t)return;const E=I.buffer.slice(I.byteOffset,I.byteOffset+I.length),o=1e-4*Number(B);Q===WA.FrameDiff&&void 0!==this.lastTimestamp&&o-this.lastTimestamp<3&&this.warn(`Difference between successive timestamps was ${(o-this.lastTimestamp).toFixed(1)}`),Q!==WA.Metadata&&(this.lastTimestamp=o),t.renderVideoFrame({header:{timestamp:o,x:C.left,y:C.top,width:C.width,height:C.height,mask:e},data:E})}else if(A.discriminator===VA.discriminator){const I=g(this,Ng,"f").get(A.value.streamId);if(!I)return;I.processCursor({x:A.value.positionX,y:A.value.positionY,spotX:A.value.spotX,spotY:A.value.spotY,shapeWidth:A.value.shapeWidth,shapeHeight:A.value.shapeHeight,extentWidth:A.value.monitorWidth,extentHeight:A.value.monitorHeight,visible:A.value.visible,hasPointerImage:A.value.data.length>0,pointerImage:A.value.data})}else if(A.discriminator===jA.discriminator){const I=g(this,Ng,"f").get(A.value.streamId);if(!I)return;const{data:B}=A.value,Q=B.buffer.slice(B.byteOffset,B.byteOffset+B.length);I.processAudio(Q)}}async exchangeCodecs(){if(this.disconnected)throw new Q("Couldn't exchange codecs: peer is disconnected");const A=await new Promise((A=>{this.transport.sendLogicDatagram({discriminator:uA.discriminator,value:{}}),this.codecsResolve=A}));return this.codecsResolve=void 0,A}async createDataChannel(A){if(A.id.startsWith("RW_"))throw new Q("Data channel names starting with RW_ are reserved for Rainway");await this.transport.createDataChannel(A.id,A.mode);const I=new dI(A,this);return g(this,mg,"f").set(A.id,I),I}async forceStreamAnnouncements(){if(this.disconnected)throw new Q("Couldn't forceStreamAnnouncements. Peer disconnected.");this.transport.sendLogicDatagram({discriminator:vA.discriminator,value:{}})}debug(A){QI(vg.name,A)}warn(A){gI(vg.name,A)}}kg=new WeakMap,Ug=new WeakMap,Ng=new WeakMap,mg=new WeakMap,Mg=new WeakMap,Lg=new WeakMap;class bg extends sI{constructor(A,I){super(),fg.set(this,void 0),pg.set(this,new Map),this.connectionTransports=new Map,this.documentVisibilityChangeHandler=()=>{if(document.hidden)for(const A of this.peers.values())for(const I of A.streams.values())I.releaseKeys(),I.pause();else for(const A of this.peers.values())for(const I of A.streams.values())I.play()},this.windowBlurHandler=()=>{for(const A of this.peers.values())for(const I of A.streams.values())I.releaseKeys()},B(this,fg,A,"f"),this.config=I,this.gateway=new oI(g(this,fg,"f"),this.config.apiKey,this.config.externalId??"",(A=>this.handlePeerInfo(A)),(A=>this.emit("peer-request",A)),((A,I,g)=>this.addPeer(A,I,g,"answer"))),this.gateway.connectionLostEvent.addHandler((A=>{this.emit("close",A),this.disconnectAllPeers()}))}get peers(){return[...g(this,pg,"f").values()]}async initialize(){await this.gateway.connect(),this.addListeners()}get id(){return g(this,fg,"f")}get externalId(){return this.config.externalId}async connect(A){if(await this.gateway.connect(),g(this,pg,"f").has(A))throw new Q(`Already connected to ${A}`);const I=await this.gateway.connectToHost(A,o.SCTP);if(I.canceled)throw new Q("The connection attempt was canceled.");if(!I.accepted)throw new Q(`The peer at ${A} rejected the connection, with reason: ${I.reason}`);return await this.addPeer(A,I.hostExternalId,I.connectionRequestId,"offer")}async addPeer(A,I,B,Q){const C=new DI(g(this,fg,"f"),A,(I=>this.gateway.sendOffer(A,I)),(I=>this.gateway.sendAnswer(A,I)),(I=>this.gateway.sendCandidate(A,I)),(A=>{e.applyStateChange(A)})),e=new vg(this,A,I,C);e.addEventListener("close",(()=>{this.gateway.deleteConnection(A),g(this,pg,"f").delete(A)})),this.connectionTransports.set(B,C),C.onApplicationMessage=(A,I)=>e.dataChannels.get(A)?._emit(I);try{await C.open(Q)}finally{this.connectionTransports.delete(B)}return await e.sendDeviceInfoAndExchangeCodecs(),g(this,pg,"f").set(A,e),e}cancelConnectionAttempt(A){this.gateway.cancelConnectionAttempt(A)}handlePeerInfo(A){const I=this.connectionTransports.get(A.id);void 0!==I?I.handlePeerInfo(A):A.type!==a.Candidate&&gI(bg.name,"Got peer info for unexpected CRID? "+A.id)}disconnectAllPeers(){for(const A of g(this,pg,"f").values())A.close();g(this,pg,"f").clear()}addListeners(){window.addEventListener("blur",this.windowBlurHandler),document.addEventListener("visibilitychange",this.documentVisibilityChangeHandler)}removeListeners(){window.removeEventListener("blur",this.windowBlurHandler),document.removeEventListener("visibilitychange",this.documentVisibilityChangeHandler)}close(){this.disconnectAllPeers(),this.connectionTransports.clear(),this.gateway.disconnect(),this.removeListeners()}}fg=new WeakMap,pg=new WeakMap,(Hg=DataView.prototype).setBigUint64??(Hg.setBigUint64=function(A,I,g){const B=BigInt(4294967295),Q=Number(I>>BigInt(32)&B),C=Number(I&B),[e,i]=g?[4,0]:[0,4];this.setUint32(A+e,Q,g),this.setUint32(A+i,C,g)}),(Jg=DataView.prototype).getBigUint64??(Jg.getBigUint64=function(A,I){const[g,B]=I?[4,0]:[0,4],Q=BigInt(this.getUint32(A+g,I)),C=BigInt(this.getUint32(A+B,I));return Q<<BigInt(32)|C});const Pg=new class extends sI{constructor(){super(...arguments),this.version="0.3.0-beta.1"}getMediaCapabilities(A){return navigator.mediaCapabilities.decodingInfo(A)}async connect(A){const I=await tI(A.apiKey),g=new bg(I,A);return await g.initialize(),g}};$A={onLog:(A,I,g)=>{Pg.emit("log",A,I,g)}};


/***/ }),

/***/ "./node_modules/bebop/dist/index.js":
/*!******************************************!*\
  !*** ./node_modules/bebop/dist/index.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BebopView = exports.BebopRuntimeError = void 0;
const hexDigits = "0123456789abcdef";
const asciiToHex = [
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 0, 0, 0, 0, 0,
    0, 10, 11, 12, 13, 14, 15, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 10, 11, 12, 13, 14, 15, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
];
const emptyByteArray = new Uint8Array(0);
const emptyString = "";
const byteToHex = []; // A lookup table: ['00', '01', ..., 'ff']
for (const x of hexDigits) {
    for (const y of hexDigits) {
        byteToHex.push(x + y);
    }
}
if (true) {
    if (typeof TextDecoder === 'undefined')
        __webpack_require__.g.TextDecoder = __webpack_require__(/*! util */ "?2ce1").TextDecoder;
}
class BebopRuntimeError extends Error {
    constructor(message) {
        super(message);
        this.name = "BebopRuntimeError";
    }
}
exports.BebopRuntimeError = BebopRuntimeError;
class BebopView {
    static textDecoder = new TextDecoder();
    static writeBuffer = new Uint8Array(256);
    static writeBufferView = new DataView(BebopView.writeBuffer.buffer);
    static instance;
    static getInstance() {
        if (!BebopView.instance) {
            BebopView.instance = new BebopView();
        }
        return BebopView.instance;
    }
    minimumTextDecoderLength = 300;
    buffer;
    view;
    index; // read pointer
    length; // write pointer
    constructor() {
        this.buffer = BebopView.writeBuffer;
        this.view = BebopView.writeBufferView;
        this.index = 0;
        this.length = 0;
    }
    startReading(buffer) {
        this.buffer = buffer;
        this.view = new DataView(this.buffer.buffer, this.buffer.byteOffset, this.buffer.byteLength);
        this.index = 0;
        this.length = buffer.length;
    }
    startWriting() {
        this.buffer = BebopView.writeBuffer;
        this.view = BebopView.writeBufferView;
        this.index = 0;
        this.length = 0;
    }
    guaranteeBufferLength(length) {
        if (length > this.buffer.length) {
            const data = new Uint8Array(length << 1);
            data.set(this.buffer);
            this.buffer = data;
            this.view = new DataView(data.buffer);
        }
    }
    growBy(amount) {
        this.length += amount;
        this.guaranteeBufferLength(this.length);
    }
    skip(amount) {
        this.index += amount;
    }
    toArray() {
        return this.buffer.subarray(0, this.length);
    }
    readByte() { return this.buffer[this.index++]; }
    readUint16() { const result = this.view.getUint16(this.index, true); this.index += 2; return result; }
    readInt16() { const result = this.view.getInt16(this.index, true); this.index += 2; return result; }
    readUint32() { const result = this.view.getUint32(this.index, true); this.index += 4; return result; }
    readInt32() { const result = this.view.getInt32(this.index, true); this.index += 4; return result; }
    readUint64() { const result = this.view.getBigUint64(this.index, true); this.index += 8; return result; }
    readInt64() { const result = this.view.getBigInt64(this.index, true); this.index += 8; return result; }
    readFloat32() { const result = this.view.getFloat32(this.index, true); this.index += 4; return result; }
    readFloat64() { const result = this.view.getFloat64(this.index, true); this.index += 8; return result; }
    writeByte(value) { const index = this.length; this.growBy(1); this.buffer[index] = value; }
    writeUint16(value) { const index = this.length; this.growBy(2); this.view.setUint16(index, value, true); }
    writeInt16(value) { const index = this.length; this.growBy(2); this.view.setInt16(index, value, true); }
    writeUint32(value) { const index = this.length; this.growBy(4); this.view.setUint32(index, value, true); }
    writeInt32(value) { const index = this.length; this.growBy(4); this.view.setInt32(index, value, true); }
    writeUint64(value) { const index = this.length; this.growBy(8); this.view.setBigUint64(index, value, true); }
    writeInt64(value) { const index = this.length; this.growBy(8); this.view.setBigInt64(index, value, true); }
    writeFloat32(value) { const index = this.length; this.growBy(4); this.view.setFloat32(index, value, true); }
    writeFloat64(value) { const index = this.length; this.growBy(8); this.view.setFloat64(index, value, true); }
    readBytes() {
        const length = this.readUint32();
        if (length === 0) {
            return emptyByteArray;
        }
        const start = this.index, end = start + length;
        this.index = end;
        return this.buffer.subarray(start, end);
    }
    writeBytes(value) {
        const byteCount = value.length;
        this.writeUint32(byteCount);
        if (byteCount === 0) {
            return;
        }
        const index = this.length;
        this.growBy(byteCount);
        this.buffer.set(value, index);
    }
    /**
     * Reads a length-prefixed UTF-8-encoded string.
     */
    readString() {
        const lengthBytes = this.readUint32();
        // bail out early on an empty string
        if (lengthBytes === 0) {
            return emptyString;
        }
        if (lengthBytes >= this.minimumTextDecoderLength) {
            return BebopView.textDecoder.decode(this.buffer.subarray(this.index, this.index += lengthBytes));
        }
        const end = this.index + lengthBytes;
        let result = "";
        let codePoint;
        while (this.index < end) {
            // decode UTF-8
            const a = this.buffer[this.index++];
            if (a < 0xC0) {
                codePoint = a;
            }
            else {
                const b = this.buffer[this.index++];
                if (a < 0xE0) {
                    codePoint = ((a & 0x1F) << 6) | (b & 0x3F);
                }
                else {
                    const c = this.buffer[this.index++];
                    if (a < 0xF0) {
                        codePoint = ((a & 0x0F) << 12) | ((b & 0x3F) << 6) | (c & 0x3F);
                    }
                    else {
                        const d = this.buffer[this.index++];
                        codePoint = ((a & 0x07) << 18) | ((b & 0x3F) << 12) | ((c & 0x3F) << 6) | (d & 0x3F);
                    }
                }
            }
            // encode UTF-16
            if (codePoint < 0x10000) {
                result += String.fromCharCode(codePoint);
            }
            else {
                codePoint -= 0x10000;
                result += String.fromCharCode((codePoint >> 10) + 0xD800, (codePoint & ((1 << 10) - 1)) + 0xDC00);
            }
        }
        // Damage control, if the input is malformed UTF-8.
        this.index = end;
        return result;
    }
    /**
     * Writes a length-prefixed UTF-8-encoded string.
     */
    writeString(value) {
        // The number of characters in the string
        const stringLength = value.length;
        // If the string is empty avoid unnecessary allocations by writing the zero length and returning.
        if (stringLength === 0) {
            this.writeUint32(0);
            return;
        }
        // value.length * 3 is an upper limit for the space taken up by the string:
        // https://developer.mozilla.org/en-US/docs/Web/API/TextEncoder/encodeInto#Buffer_Sizing
        // We add 4 for our length prefix.
        const maxBytes = 4 + stringLength * 3;
        // Reallocate if necessary, then write to this.length + 4.
        this.guaranteeBufferLength(this.length + maxBytes);
        // Start writing the string from here:
        let w = this.length + 4;
        const start = w;
        let codePoint;
        for (let i = 0; i < stringLength; i++) {
            // decode UTF-16
            const a = value.charCodeAt(i);
            if (i + 1 === stringLength || a < 0xD800 || a >= 0xDC00) {
                codePoint = a;
            }
            else {
                const b = value.charCodeAt(++i);
                codePoint = (a << 10) + b + (0x10000 - (0xD800 << 10) - 0xDC00);
            }
            // encode UTF-8
            if (codePoint < 0x80) {
                this.buffer[w++] = codePoint;
            }
            else {
                if (codePoint < 0x800) {
                    this.buffer[w++] = ((codePoint >> 6) & 0x1F) | 0xC0;
                }
                else {
                    if (codePoint < 0x10000) {
                        this.buffer[w++] = ((codePoint >> 12) & 0x0F) | 0xE0;
                    }
                    else {
                        this.buffer[w++] = ((codePoint >> 18) & 0x07) | 0xF0;
                        this.buffer[w++] = ((codePoint >> 12) & 0x3F) | 0x80;
                    }
                    this.buffer[w++] = ((codePoint >> 6) & 0x3F) | 0x80;
                }
                this.buffer[w++] = (codePoint & 0x3F) | 0x80;
            }
        }
        // Count how many bytes we wrote.
        const written = w - start;
        // Write the length prefix, then skip over it and the written string.
        this.view.setUint32(this.length, written, true);
        this.length += 4 + written;
    }
    readGuid() {
        // Order: 3 2 1 0 - 5 4 - 7 6 - 8 9 - a b c d e f
        const b = byteToHex, a = this.buffer, i = this.index, d = '-';
        var s = b[a[i + 3]];
        s += b[a[i + 2]];
        s += b[a[i + 1]];
        s += b[a[i]];
        s += d;
        s += b[a[i + 5]];
        s += b[a[i + 4]];
        s += d;
        s += b[a[i + 7]];
        s += b[a[i + 6]];
        s += d;
        s += b[a[i + 8]];
        s += b[a[i + 9]];
        s += d;
        s += b[a[i + 10]];
        s += b[a[i + 11]];
        s += b[a[i + 12]];
        s += b[a[i + 13]];
        s += b[a[i + 14]];
        s += b[a[i + 15]];
        this.index += 16;
        return s;
    }
    writeGuid(value) {
        const v = this.view, i = this.length;
        this.growBy(16);
        var p = 0, a = 0;
        a = a << 4 | asciiToHex[value.charCodeAt(p++)];
        a = a << 4 | asciiToHex[value.charCodeAt(p++)];
        a = a << 4 | asciiToHex[value.charCodeAt(p++)];
        a = a << 4 | asciiToHex[value.charCodeAt(p++)];
        a = a << 4 | asciiToHex[value.charCodeAt(p++)];
        a = a << 4 | asciiToHex[value.charCodeAt(p++)];
        a = a << 4 | asciiToHex[value.charCodeAt(p++)];
        a = a << 4 | asciiToHex[value.charCodeAt(p++)];
        p += (value.charCodeAt(p) === 45);
        v.setUint32(i, a, true);
        a = a << 4 | asciiToHex[value.charCodeAt(p++)];
        a = a << 4 | asciiToHex[value.charCodeAt(p++)];
        a = a << 4 | asciiToHex[value.charCodeAt(p++)];
        a = a << 4 | asciiToHex[value.charCodeAt(p++)];
        p += (value.charCodeAt(p) === 45);
        v.setUint16(i + 4, a, true);
        a = a << 4 | asciiToHex[value.charCodeAt(p++)];
        a = a << 4 | asciiToHex[value.charCodeAt(p++)];
        a = a << 4 | asciiToHex[value.charCodeAt(p++)];
        a = a << 4 | asciiToHex[value.charCodeAt(p++)];
        p += (value.charCodeAt(p) === 45);
        v.setUint16(i + 6, a, true);
        a = a << 4 | asciiToHex[value.charCodeAt(p++)];
        a = a << 4 | asciiToHex[value.charCodeAt(p++)];
        a = a << 4 | asciiToHex[value.charCodeAt(p++)];
        a = a << 4 | asciiToHex[value.charCodeAt(p++)];
        p += (value.charCodeAt(p) === 45);
        a = a << 4 | asciiToHex[value.charCodeAt(p++)];
        a = a << 4 | asciiToHex[value.charCodeAt(p++)];
        a = a << 4 | asciiToHex[value.charCodeAt(p++)];
        a = a << 4 | asciiToHex[value.charCodeAt(p++)];
        v.setUint32(i + 8, a, false);
        a = a << 4 | asciiToHex[value.charCodeAt(p++)];
        a = a << 4 | asciiToHex[value.charCodeAt(p++)];
        a = a << 4 | asciiToHex[value.charCodeAt(p++)];
        a = a << 4 | asciiToHex[value.charCodeAt(p++)];
        a = a << 4 | asciiToHex[value.charCodeAt(p++)];
        a = a << 4 | asciiToHex[value.charCodeAt(p++)];
        a = a << 4 | asciiToHex[value.charCodeAt(p++)];
        a = a << 4 | asciiToHex[value.charCodeAt(p++)];
        v.setUint32(i + 12, a, false);
    }
    // A note on these numbers:
    // 62135596800000 ms is the difference between the C# epoch (0001-01-01) and the Unix epoch (1970-01-01).
    // 0.0001 is the number of milliseconds per "tick" (a tick is 100 ns).
    // 429496.7296 is the number of milliseconds in 2^32 ticks.
    // 0x3fffffff is a mask to ignore the "Kind" bits of the Date.ToBinary value.
    // 0x40000000 is a mask to set the "Kind" bits to "DateTimeKind.Utc".
    readDate() {
        const low = this.readUint32();
        const high = this.readUint32() & 0x3fffffff;
        const msSince1AD = 429496.7296 * high + 0.0001 * low;
        return new Date(msSince1AD - 62135596800000);
    }
    writeDate(date) {
        const ms = date.getTime();
        const msSince1AD = ms + 62135596800000;
        const low = msSince1AD % 429496.7296 * 10000 | 0;
        const high = msSince1AD / 429496.7296 | 0x40000000;
        this.writeUint32(low);
        this.writeUint32(high);
    }
    /**
     * Reserve some space to write a message's length prefix, and return its index.
     * The length is stored as a little-endian fixed-width unsigned 32-bit integer, so 4 bytes are reserved.
     */
    reserveMessageLength() {
        const i = this.length;
        this.growBy(4);
        return i;
    }
    /**
     * Fill in a message's length prefix.
     */
    fillMessageLength(position, messageLength) {
        this.view.setUint32(position, messageLength, true);
    }
    /**
     * Read out a message's length prefix.
     */
    readMessageLength() {
        const result = this.view.getUint32(this.index, true);
        this.index += 4;
        return result;
    }
}
exports.BebopView = BebopView;


/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/api.js":
/*!*****************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/api.js ***!
  \*****************************************************/
/***/ ((module) => {

"use strict";


/*
  MIT License http://www.opensource.org/licenses/mit-license.php
  Author Tobias Koppers @sokra
*/
// css base code, injected by the css-loader
// eslint-disable-next-line func-names
module.exports = function (useSourceMap) {
  var list = []; // return the list of modules as css string

  list.toString = function toString() {
    return this.map(function (item) {
      var content = cssWithMappingToString(item, useSourceMap);

      if (item[2]) {
        return "@media ".concat(item[2], " {").concat(content, "}");
      }

      return content;
    }).join('');
  }; // import a list of modules into the list
  // eslint-disable-next-line func-names


  list.i = function (modules, mediaQuery, dedupe) {
    if (typeof modules === 'string') {
      // eslint-disable-next-line no-param-reassign
      modules = [[null, modules, '']];
    }

    var alreadyImportedModules = {};

    if (dedupe) {
      for (var i = 0; i < this.length; i++) {
        // eslint-disable-next-line prefer-destructuring
        var id = this[i][0];

        if (id != null) {
          alreadyImportedModules[id] = true;
        }
      }
    }

    for (var _i = 0; _i < modules.length; _i++) {
      var item = [].concat(modules[_i]);

      if (dedupe && alreadyImportedModules[item[0]]) {
        // eslint-disable-next-line no-continue
        continue;
      }

      if (mediaQuery) {
        if (!item[2]) {
          item[2] = mediaQuery;
        } else {
          item[2] = "".concat(mediaQuery, " and ").concat(item[2]);
        }
      }

      list.push(item);
    }
  };

  return list;
};

function cssWithMappingToString(item, useSourceMap) {
  var content = item[1] || ''; // eslint-disable-next-line prefer-destructuring

  var cssMapping = item[3];

  if (!cssMapping) {
    return content;
  }

  if (useSourceMap && typeof btoa === 'function') {
    var sourceMapping = toComment(cssMapping);
    var sourceURLs = cssMapping.sources.map(function (source) {
      return "/*# sourceURL=".concat(cssMapping.sourceRoot || '').concat(source, " */");
    });
    return [content].concat(sourceURLs).concat([sourceMapping]).join('\n');
  }

  return [content].join('\n');
} // Adapted from convert-source-map (MIT)


function toComment(sourceMap) {
  // eslint-disable-next-line no-undef
  var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));
  var data = "sourceMappingURL=data:application/json;charset=utf-8;base64,".concat(base64);
  return "/*# ".concat(data, " */");
}

/***/ }),

/***/ "./node_modules/object-assign/index.js":
/*!*********************************************!*\
  !*** ./node_modules/object-assign/index.js ***!
  \*********************************************/
/***/ ((module) => {

"use strict";
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/


/* eslint-disable no-unused-vars */
var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var hasOwnProperty = Object.prototype.hasOwnProperty;
var propIsEnumerable = Object.prototype.propertyIsEnumerable;

function toObject(val) {
	if (val === null || val === undefined) {
		throw new TypeError('Object.assign cannot be called with null or undefined');
	}

	return Object(val);
}

function shouldUseNative() {
	try {
		if (!Object.assign) {
			return false;
		}

		// Detect buggy property enumeration order in older V8 versions.

		// https://bugs.chromium.org/p/v8/issues/detail?id=4118
		var test1 = new String('abc');  // eslint-disable-line no-new-wrappers
		test1[5] = 'de';
		if (Object.getOwnPropertyNames(test1)[0] === '5') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test2 = {};
		for (var i = 0; i < 10; i++) {
			test2['_' + String.fromCharCode(i)] = i;
		}
		var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
			return test2[n];
		});
		if (order2.join('') !== '0123456789') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test3 = {};
		'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
			test3[letter] = letter;
		});
		if (Object.keys(Object.assign({}, test3)).join('') !==
				'abcdefghijklmnopqrst') {
			return false;
		}

		return true;
	} catch (err) {
		// We don't expect any of the above to throw, but better to be safe.
		return false;
	}
}

module.exports = shouldUseNative() ? Object.assign : function (target, source) {
	var from;
	var to = toObject(target);
	var symbols;

	for (var s = 1; s < arguments.length; s++) {
		from = Object(arguments[s]);

		for (var key in from) {
			if (hasOwnProperty.call(from, key)) {
				to[key] = from[key];
			}
		}

		if (getOwnPropertySymbols) {
			symbols = getOwnPropertySymbols(from);
			for (var i = 0; i < symbols.length; i++) {
				if (propIsEnumerable.call(from, symbols[i])) {
					to[symbols[i]] = from[symbols[i]];
				}
			}
		}
	}

	return to;
};


/***/ }),

/***/ "./node_modules/react-dom/cjs/react-dom.development.js":
/*!*************************************************************!*\
  !*** ./node_modules/react-dom/cjs/react-dom.development.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/** @license React v17.0.2
 * react-dom.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



if (true) {
  (function() {
'use strict';

var React = __webpack_require__(/*! react */ "./node_modules/react/index.js");
var _assign = __webpack_require__(/*! object-assign */ "./node_modules/object-assign/index.js");
var Scheduler = __webpack_require__(/*! scheduler */ "./node_modules/scheduler/index.js");
var tracing = __webpack_require__(/*! scheduler/tracing */ "./node_modules/scheduler/tracing.js");

var ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;

// by calls to these methods by a Babel plugin.
//
// In PROD (or in packages without access to React internals),
// they are left as they are instead.

function warn(format) {
  {
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }

    printWarning('warn', format, args);
  }
}
function error(format) {
  {
    for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
      args[_key2 - 1] = arguments[_key2];
    }

    printWarning('error', format, args);
  }
}

function printWarning(level, format, args) {
  // When changing this logic, you might want to also
  // update consoleWithStackDev.www.js as well.
  {
    var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
    var stack = ReactDebugCurrentFrame.getStackAddendum();

    if (stack !== '') {
      format += '%s';
      args = args.concat([stack]);
    }

    var argsWithFormat = args.map(function (item) {
      return '' + item;
    }); // Careful: RN currently depends on this prefix

    argsWithFormat.unshift('Warning: ' + format); // We intentionally don't use spread (or .apply) directly because it
    // breaks IE9: https://github.com/facebook/react/issues/13610
    // eslint-disable-next-line react-internal/no-production-logging

    Function.prototype.apply.call(console[level], console, argsWithFormat);
  }
}

if (!React) {
  {
    throw Error( "ReactDOM was loaded before React. Make sure you load the React package before loading ReactDOM." );
  }
}

var FunctionComponent = 0;
var ClassComponent = 1;
var IndeterminateComponent = 2; // Before we know whether it is function or class

var HostRoot = 3; // Root of a host tree. Could be nested inside another node.

var HostPortal = 4; // A subtree. Could be an entry point to a different renderer.

var HostComponent = 5;
var HostText = 6;
var Fragment = 7;
var Mode = 8;
var ContextConsumer = 9;
var ContextProvider = 10;
var ForwardRef = 11;
var Profiler = 12;
var SuspenseComponent = 13;
var MemoComponent = 14;
var SimpleMemoComponent = 15;
var LazyComponent = 16;
var IncompleteClassComponent = 17;
var DehydratedFragment = 18;
var SuspenseListComponent = 19;
var FundamentalComponent = 20;
var ScopeComponent = 21;
var Block = 22;
var OffscreenComponent = 23;
var LegacyHiddenComponent = 24;

// Filter certain DOM attributes (e.g. src, href) if their values are empty strings.

var enableProfilerTimer = true; // Record durations for commit and passive effects phases.

var enableFundamentalAPI = false; // Experimental Scope support.
var enableNewReconciler = false; // Errors that are thrown while unmounting (or after in the case of passive effects)
var warnAboutStringRefs = false;

var allNativeEvents = new Set();
/**
 * Mapping from registration name to event name
 */


var registrationNameDependencies = {};
/**
 * Mapping from lowercase registration names to the properly cased version,
 * used to warn in the case of missing event handlers. Available
 * only in true.
 * @type {Object}
 */

var possibleRegistrationNames =  {} ; // Trust the developer to only use possibleRegistrationNames in true

function registerTwoPhaseEvent(registrationName, dependencies) {
  registerDirectEvent(registrationName, dependencies);
  registerDirectEvent(registrationName + 'Capture', dependencies);
}
function registerDirectEvent(registrationName, dependencies) {
  {
    if (registrationNameDependencies[registrationName]) {
      error('EventRegistry: More than one plugin attempted to publish the same ' + 'registration name, `%s`.', registrationName);
    }
  }

  registrationNameDependencies[registrationName] = dependencies;

  {
    var lowerCasedName = registrationName.toLowerCase();
    possibleRegistrationNames[lowerCasedName] = registrationName;

    if (registrationName === 'onDoubleClick') {
      possibleRegistrationNames.ondblclick = registrationName;
    }
  }

  for (var i = 0; i < dependencies.length; i++) {
    allNativeEvents.add(dependencies[i]);
  }
}

var canUseDOM = !!(typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined');

// A reserved attribute.
// It is handled by React separately and shouldn't be written to the DOM.
var RESERVED = 0; // A simple string attribute.
// Attributes that aren't in the filter are presumed to have this type.

var STRING = 1; // A string attribute that accepts booleans in React. In HTML, these are called
// "enumerated" attributes with "true" and "false" as possible values.
// When true, it should be set to a "true" string.
// When false, it should be set to a "false" string.

var BOOLEANISH_STRING = 2; // A real boolean attribute.
// When true, it should be present (set either to an empty string or its name).
// When false, it should be omitted.

var BOOLEAN = 3; // An attribute that can be used as a flag as well as with a value.
// When true, it should be present (set either to an empty string or its name).
// When false, it should be omitted.
// For any other value, should be present with that value.

var OVERLOADED_BOOLEAN = 4; // An attribute that must be numeric or parse as a numeric.
// When falsy, it should be removed.

var NUMERIC = 5; // An attribute that must be positive numeric or parse as a positive numeric.
// When falsy, it should be removed.

var POSITIVE_NUMERIC = 6;

/* eslint-disable max-len */
var ATTRIBUTE_NAME_START_CHAR = ":A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD";
/* eslint-enable max-len */

var ATTRIBUTE_NAME_CHAR = ATTRIBUTE_NAME_START_CHAR + "\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040";
var ROOT_ATTRIBUTE_NAME = 'data-reactroot';
var VALID_ATTRIBUTE_NAME_REGEX = new RegExp('^[' + ATTRIBUTE_NAME_START_CHAR + '][' + ATTRIBUTE_NAME_CHAR + ']*$');
var hasOwnProperty = Object.prototype.hasOwnProperty;
var illegalAttributeNameCache = {};
var validatedAttributeNameCache = {};
function isAttributeNameSafe(attributeName) {
  if (hasOwnProperty.call(validatedAttributeNameCache, attributeName)) {
    return true;
  }

  if (hasOwnProperty.call(illegalAttributeNameCache, attributeName)) {
    return false;
  }

  if (VALID_ATTRIBUTE_NAME_REGEX.test(attributeName)) {
    validatedAttributeNameCache[attributeName] = true;
    return true;
  }

  illegalAttributeNameCache[attributeName] = true;

  {
    error('Invalid attribute name: `%s`', attributeName);
  }

  return false;
}
function shouldIgnoreAttribute(name, propertyInfo, isCustomComponentTag) {
  if (propertyInfo !== null) {
    return propertyInfo.type === RESERVED;
  }

  if (isCustomComponentTag) {
    return false;
  }

  if (name.length > 2 && (name[0] === 'o' || name[0] === 'O') && (name[1] === 'n' || name[1] === 'N')) {
    return true;
  }

  return false;
}
function shouldRemoveAttributeWithWarning(name, value, propertyInfo, isCustomComponentTag) {
  if (propertyInfo !== null && propertyInfo.type === RESERVED) {
    return false;
  }

  switch (typeof value) {
    case 'function': // $FlowIssue symbol is perfectly valid here

    case 'symbol':
      // eslint-disable-line
      return true;

    case 'boolean':
      {
        if (isCustomComponentTag) {
          return false;
        }

        if (propertyInfo !== null) {
          return !propertyInfo.acceptsBooleans;
        } else {
          var prefix = name.toLowerCase().slice(0, 5);
          return prefix !== 'data-' && prefix !== 'aria-';
        }
      }

    default:
      return false;
  }
}
function shouldRemoveAttribute(name, value, propertyInfo, isCustomComponentTag) {
  if (value === null || typeof value === 'undefined') {
    return true;
  }

  if (shouldRemoveAttributeWithWarning(name, value, propertyInfo, isCustomComponentTag)) {
    return true;
  }

  if (isCustomComponentTag) {
    return false;
  }

  if (propertyInfo !== null) {

    switch (propertyInfo.type) {
      case BOOLEAN:
        return !value;

      case OVERLOADED_BOOLEAN:
        return value === false;

      case NUMERIC:
        return isNaN(value);

      case POSITIVE_NUMERIC:
        return isNaN(value) || value < 1;
    }
  }

  return false;
}
function getPropertyInfo(name) {
  return properties.hasOwnProperty(name) ? properties[name] : null;
}

function PropertyInfoRecord(name, type, mustUseProperty, attributeName, attributeNamespace, sanitizeURL, removeEmptyString) {
  this.acceptsBooleans = type === BOOLEANISH_STRING || type === BOOLEAN || type === OVERLOADED_BOOLEAN;
  this.attributeName = attributeName;
  this.attributeNamespace = attributeNamespace;
  this.mustUseProperty = mustUseProperty;
  this.propertyName = name;
  this.type = type;
  this.sanitizeURL = sanitizeURL;
  this.removeEmptyString = removeEmptyString;
} // When adding attributes to this list, be sure to also add them to
// the `possibleStandardNames` module to ensure casing and incorrect
// name warnings.


var properties = {}; // These props are reserved by React. They shouldn't be written to the DOM.

var reservedProps = ['children', 'dangerouslySetInnerHTML', // TODO: This prevents the assignment of defaultValue to regular
// elements (not just inputs). Now that ReactDOMInput assigns to the
// defaultValue property -- do we need this?
'defaultValue', 'defaultChecked', 'innerHTML', 'suppressContentEditableWarning', 'suppressHydrationWarning', 'style'];
reservedProps.forEach(function (name) {
  properties[name] = new PropertyInfoRecord(name, RESERVED, false, // mustUseProperty
  name, // attributeName
  null, // attributeNamespace
  false, // sanitizeURL
  false);
}); // A few React string attributes have a different name.
// This is a mapping from React prop names to the attribute names.

[['acceptCharset', 'accept-charset'], ['className', 'class'], ['htmlFor', 'for'], ['httpEquiv', 'http-equiv']].forEach(function (_ref) {
  var name = _ref[0],
      attributeName = _ref[1];
  properties[name] = new PropertyInfoRecord(name, STRING, false, // mustUseProperty
  attributeName, // attributeName
  null, // attributeNamespace
  false, // sanitizeURL
  false);
}); // These are "enumerated" HTML attributes that accept "true" and "false".
// In React, we let users pass `true` and `false` even though technically
// these aren't boolean attributes (they are coerced to strings).

['contentEditable', 'draggable', 'spellCheck', 'value'].forEach(function (name) {
  properties[name] = new PropertyInfoRecord(name, BOOLEANISH_STRING, false, // mustUseProperty
  name.toLowerCase(), // attributeName
  null, // attributeNamespace
  false, // sanitizeURL
  false);
}); // These are "enumerated" SVG attributes that accept "true" and "false".
// In React, we let users pass `true` and `false` even though technically
// these aren't boolean attributes (they are coerced to strings).
// Since these are SVG attributes, their attribute names are case-sensitive.

['autoReverse', 'externalResourcesRequired', 'focusable', 'preserveAlpha'].forEach(function (name) {
  properties[name] = new PropertyInfoRecord(name, BOOLEANISH_STRING, false, // mustUseProperty
  name, // attributeName
  null, // attributeNamespace
  false, // sanitizeURL
  false);
}); // These are HTML boolean attributes.

['allowFullScreen', 'async', // Note: there is a special case that prevents it from being written to the DOM
// on the client side because the browsers are inconsistent. Instead we call focus().
'autoFocus', 'autoPlay', 'controls', 'default', 'defer', 'disabled', 'disablePictureInPicture', 'disableRemotePlayback', 'formNoValidate', 'hidden', 'loop', 'noModule', 'noValidate', 'open', 'playsInline', 'readOnly', 'required', 'reversed', 'scoped', 'seamless', // Microdata
'itemScope'].forEach(function (name) {
  properties[name] = new PropertyInfoRecord(name, BOOLEAN, false, // mustUseProperty
  name.toLowerCase(), // attributeName
  null, // attributeNamespace
  false, // sanitizeURL
  false);
}); // These are the few React props that we set as DOM properties
// rather than attributes. These are all booleans.

['checked', // Note: `option.selected` is not updated if `select.multiple` is
// disabled with `removeAttribute`. We have special logic for handling this.
'multiple', 'muted', 'selected' // NOTE: if you add a camelCased prop to this list,
// you'll need to set attributeName to name.toLowerCase()
// instead in the assignment below.
].forEach(function (name) {
  properties[name] = new PropertyInfoRecord(name, BOOLEAN, true, // mustUseProperty
  name, // attributeName
  null, // attributeNamespace
  false, // sanitizeURL
  false);
}); // These are HTML attributes that are "overloaded booleans": they behave like
// booleans, but can also accept a string value.

['capture', 'download' // NOTE: if you add a camelCased prop to this list,
// you'll need to set attributeName to name.toLowerCase()
// instead in the assignment below.
].forEach(function (name) {
  properties[name] = new PropertyInfoRecord(name, OVERLOADED_BOOLEAN, false, // mustUseProperty
  name, // attributeName
  null, // attributeNamespace
  false, // sanitizeURL
  false);
}); // These are HTML attributes that must be positive numbers.

['cols', 'rows', 'size', 'span' // NOTE: if you add a camelCased prop to this list,
// you'll need to set attributeName to name.toLowerCase()
// instead in the assignment below.
].forEach(function (name) {
  properties[name] = new PropertyInfoRecord(name, POSITIVE_NUMERIC, false, // mustUseProperty
  name, // attributeName
  null, // attributeNamespace
  false, // sanitizeURL
  false);
}); // These are HTML attributes that must be numbers.

['rowSpan', 'start'].forEach(function (name) {
  properties[name] = new PropertyInfoRecord(name, NUMERIC, false, // mustUseProperty
  name.toLowerCase(), // attributeName
  null, // attributeNamespace
  false, // sanitizeURL
  false);
});
var CAMELIZE = /[\-\:]([a-z])/g;

var capitalize = function (token) {
  return token[1].toUpperCase();
}; // This is a list of all SVG attributes that need special casing, namespacing,
// or boolean value assignment. Regular attributes that just accept strings
// and have the same names are omitted, just like in the HTML attribute filter.
// Some of these attributes can be hard to find. This list was created by
// scraping the MDN documentation.


['accent-height', 'alignment-baseline', 'arabic-form', 'baseline-shift', 'cap-height', 'clip-path', 'clip-rule', 'color-interpolation', 'color-interpolation-filters', 'color-profile', 'color-rendering', 'dominant-baseline', 'enable-background', 'fill-opacity', 'fill-rule', 'flood-color', 'flood-opacity', 'font-family', 'font-size', 'font-size-adjust', 'font-stretch', 'font-style', 'font-variant', 'font-weight', 'glyph-name', 'glyph-orientation-horizontal', 'glyph-orientation-vertical', 'horiz-adv-x', 'horiz-origin-x', 'image-rendering', 'letter-spacing', 'lighting-color', 'marker-end', 'marker-mid', 'marker-start', 'overline-position', 'overline-thickness', 'paint-order', 'panose-1', 'pointer-events', 'rendering-intent', 'shape-rendering', 'stop-color', 'stop-opacity', 'strikethrough-position', 'strikethrough-thickness', 'stroke-dasharray', 'stroke-dashoffset', 'stroke-linecap', 'stroke-linejoin', 'stroke-miterlimit', 'stroke-opacity', 'stroke-width', 'text-anchor', 'text-decoration', 'text-rendering', 'underline-position', 'underline-thickness', 'unicode-bidi', 'unicode-range', 'units-per-em', 'v-alphabetic', 'v-hanging', 'v-ideographic', 'v-mathematical', 'vector-effect', 'vert-adv-y', 'vert-origin-x', 'vert-origin-y', 'word-spacing', 'writing-mode', 'xmlns:xlink', 'x-height' // NOTE: if you add a camelCased prop to this list,
// you'll need to set attributeName to name.toLowerCase()
// instead in the assignment below.
].forEach(function (attributeName) {
  var name = attributeName.replace(CAMELIZE, capitalize);
  properties[name] = new PropertyInfoRecord(name, STRING, false, // mustUseProperty
  attributeName, null, // attributeNamespace
  false, // sanitizeURL
  false);
}); // String SVG attributes with the xlink namespace.

['xlink:actuate', 'xlink:arcrole', 'xlink:role', 'xlink:show', 'xlink:title', 'xlink:type' // NOTE: if you add a camelCased prop to this list,
// you'll need to set attributeName to name.toLowerCase()
// instead in the assignment below.
].forEach(function (attributeName) {
  var name = attributeName.replace(CAMELIZE, capitalize);
  properties[name] = new PropertyInfoRecord(name, STRING, false, // mustUseProperty
  attributeName, 'http://www.w3.org/1999/xlink', false, // sanitizeURL
  false);
}); // String SVG attributes with the xml namespace.

['xml:base', 'xml:lang', 'xml:space' // NOTE: if you add a camelCased prop to this list,
// you'll need to set attributeName to name.toLowerCase()
// instead in the assignment below.
].forEach(function (attributeName) {
  var name = attributeName.replace(CAMELIZE, capitalize);
  properties[name] = new PropertyInfoRecord(name, STRING, false, // mustUseProperty
  attributeName, 'http://www.w3.org/XML/1998/namespace', false, // sanitizeURL
  false);
}); // These attribute exists both in HTML and SVG.
// The attribute name is case-sensitive in SVG so we can't just use
// the React name like we do for attributes that exist only in HTML.

['tabIndex', 'crossOrigin'].forEach(function (attributeName) {
  properties[attributeName] = new PropertyInfoRecord(attributeName, STRING, false, // mustUseProperty
  attributeName.toLowerCase(), // attributeName
  null, // attributeNamespace
  false, // sanitizeURL
  false);
}); // These attributes accept URLs. These must not allow javascript: URLS.
// These will also need to accept Trusted Types object in the future.

var xlinkHref = 'xlinkHref';
properties[xlinkHref] = new PropertyInfoRecord('xlinkHref', STRING, false, // mustUseProperty
'xlink:href', 'http://www.w3.org/1999/xlink', true, // sanitizeURL
false);
['src', 'href', 'action', 'formAction'].forEach(function (attributeName) {
  properties[attributeName] = new PropertyInfoRecord(attributeName, STRING, false, // mustUseProperty
  attributeName.toLowerCase(), // attributeName
  null, // attributeNamespace
  true, // sanitizeURL
  true);
});

// and any newline or tab are filtered out as if they're not part of the URL.
// https://url.spec.whatwg.org/#url-parsing
// Tab or newline are defined as \r\n\t:
// https://infra.spec.whatwg.org/#ascii-tab-or-newline
// A C0 control is a code point in the range \u0000 NULL to \u001F
// INFORMATION SEPARATOR ONE, inclusive:
// https://infra.spec.whatwg.org/#c0-control-or-space

/* eslint-disable max-len */

var isJavaScriptProtocol = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*\:/i;
var didWarn = false;

function sanitizeURL(url) {
  {
    if (!didWarn && isJavaScriptProtocol.test(url)) {
      didWarn = true;

      error('A future version of React will block javascript: URLs as a security precaution. ' + 'Use event handlers instead if you can. If you need to generate unsafe HTML try ' + 'using dangerouslySetInnerHTML instead. React was passed %s.', JSON.stringify(url));
    }
  }
}

/**
 * Get the value for a property on a node. Only used in DEV for SSR validation.
 * The "expected" argument is used as a hint of what the expected value is.
 * Some properties have multiple equivalent values.
 */
function getValueForProperty(node, name, expected, propertyInfo) {
  {
    if (propertyInfo.mustUseProperty) {
      var propertyName = propertyInfo.propertyName;
      return node[propertyName];
    } else {
      if ( propertyInfo.sanitizeURL) {
        // If we haven't fully disabled javascript: URLs, and if
        // the hydration is successful of a javascript: URL, we
        // still want to warn on the client.
        sanitizeURL('' + expected);
      }

      var attributeName = propertyInfo.attributeName;
      var stringValue = null;

      if (propertyInfo.type === OVERLOADED_BOOLEAN) {
        if (node.hasAttribute(attributeName)) {
          var value = node.getAttribute(attributeName);

          if (value === '') {
            return true;
          }

          if (shouldRemoveAttribute(name, expected, propertyInfo, false)) {
            return value;
          }

          if (value === '' + expected) {
            return expected;
          }

          return value;
        }
      } else if (node.hasAttribute(attributeName)) {
        if (shouldRemoveAttribute(name, expected, propertyInfo, false)) {
          // We had an attribute but shouldn't have had one, so read it
          // for the error message.
          return node.getAttribute(attributeName);
        }

        if (propertyInfo.type === BOOLEAN) {
          // If this was a boolean, it doesn't matter what the value is
          // the fact that we have it is the same as the expected.
          return expected;
        } // Even if this property uses a namespace we use getAttribute
        // because we assume its namespaced name is the same as our config.
        // To use getAttributeNS we need the local name which we don't have
        // in our config atm.


        stringValue = node.getAttribute(attributeName);
      }

      if (shouldRemoveAttribute(name, expected, propertyInfo, false)) {
        return stringValue === null ? expected : stringValue;
      } else if (stringValue === '' + expected) {
        return expected;
      } else {
        return stringValue;
      }
    }
  }
}
/**
 * Get the value for a attribute on a node. Only used in DEV for SSR validation.
 * The third argument is used as a hint of what the expected value is. Some
 * attributes have multiple equivalent values.
 */

function getValueForAttribute(node, name, expected) {
  {
    if (!isAttributeNameSafe(name)) {
      return;
    } // If the object is an opaque reference ID, it's expected that
    // the next prop is different than the server value, so just return
    // expected


    if (isOpaqueHydratingObject(expected)) {
      return expected;
    }

    if (!node.hasAttribute(name)) {
      return expected === undefined ? undefined : null;
    }

    var value = node.getAttribute(name);

    if (value === '' + expected) {
      return expected;
    }

    return value;
  }
}
/**
 * Sets the value for a property on a node.
 *
 * @param {DOMElement} node
 * @param {string} name
 * @param {*} value
 */

function setValueForProperty(node, name, value, isCustomComponentTag) {
  var propertyInfo = getPropertyInfo(name);

  if (shouldIgnoreAttribute(name, propertyInfo, isCustomComponentTag)) {
    return;
  }

  if (shouldRemoveAttribute(name, value, propertyInfo, isCustomComponentTag)) {
    value = null;
  } // If the prop isn't in the special list, treat it as a simple attribute.


  if (isCustomComponentTag || propertyInfo === null) {
    if (isAttributeNameSafe(name)) {
      var _attributeName = name;

      if (value === null) {
        node.removeAttribute(_attributeName);
      } else {
        node.setAttribute(_attributeName,  '' + value);
      }
    }

    return;
  }

  var mustUseProperty = propertyInfo.mustUseProperty;

  if (mustUseProperty) {
    var propertyName = propertyInfo.propertyName;

    if (value === null) {
      var type = propertyInfo.type;
      node[propertyName] = type === BOOLEAN ? false : '';
    } else {
      // Contrary to `setAttribute`, object properties are properly
      // `toString`ed by IE8/9.
      node[propertyName] = value;
    }

    return;
  } // The rest are treated as attributes with special cases.


  var attributeName = propertyInfo.attributeName,
      attributeNamespace = propertyInfo.attributeNamespace;

  if (value === null) {
    node.removeAttribute(attributeName);
  } else {
    var _type = propertyInfo.type;
    var attributeValue;

    if (_type === BOOLEAN || _type === OVERLOADED_BOOLEAN && value === true) {
      // If attribute type is boolean, we know for sure it won't be an execution sink
      // and we won't require Trusted Type here.
      attributeValue = '';
    } else {
      // `setAttribute` with objects becomes only `[object]` in IE8/9,
      // ('' + value) makes it output the correct toString()-value.
      {
        attributeValue = '' + value;
      }

      if (propertyInfo.sanitizeURL) {
        sanitizeURL(attributeValue.toString());
      }
    }

    if (attributeNamespace) {
      node.setAttributeNS(attributeNamespace, attributeName, attributeValue);
    } else {
      node.setAttribute(attributeName, attributeValue);
    }
  }
}

// ATTENTION
// When adding new symbols to this file,
// Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'
// The Symbol used to tag the ReactElement-like types. If there is no native Symbol
// nor polyfill, then a plain number is used for performance.
var REACT_ELEMENT_TYPE = 0xeac7;
var REACT_PORTAL_TYPE = 0xeaca;
var REACT_FRAGMENT_TYPE = 0xeacb;
var REACT_STRICT_MODE_TYPE = 0xeacc;
var REACT_PROFILER_TYPE = 0xead2;
var REACT_PROVIDER_TYPE = 0xeacd;
var REACT_CONTEXT_TYPE = 0xeace;
var REACT_FORWARD_REF_TYPE = 0xead0;
var REACT_SUSPENSE_TYPE = 0xead1;
var REACT_SUSPENSE_LIST_TYPE = 0xead8;
var REACT_MEMO_TYPE = 0xead3;
var REACT_LAZY_TYPE = 0xead4;
var REACT_BLOCK_TYPE = 0xead9;
var REACT_SERVER_BLOCK_TYPE = 0xeada;
var REACT_FUNDAMENTAL_TYPE = 0xead5;
var REACT_SCOPE_TYPE = 0xead7;
var REACT_OPAQUE_ID_TYPE = 0xeae0;
var REACT_DEBUG_TRACING_MODE_TYPE = 0xeae1;
var REACT_OFFSCREEN_TYPE = 0xeae2;
var REACT_LEGACY_HIDDEN_TYPE = 0xeae3;

if (typeof Symbol === 'function' && Symbol.for) {
  var symbolFor = Symbol.for;
  REACT_ELEMENT_TYPE = symbolFor('react.element');
  REACT_PORTAL_TYPE = symbolFor('react.portal');
  REACT_FRAGMENT_TYPE = symbolFor('react.fragment');
  REACT_STRICT_MODE_TYPE = symbolFor('react.strict_mode');
  REACT_PROFILER_TYPE = symbolFor('react.profiler');
  REACT_PROVIDER_TYPE = symbolFor('react.provider');
  REACT_CONTEXT_TYPE = symbolFor('react.context');
  REACT_FORWARD_REF_TYPE = symbolFor('react.forward_ref');
  REACT_SUSPENSE_TYPE = symbolFor('react.suspense');
  REACT_SUSPENSE_LIST_TYPE = symbolFor('react.suspense_list');
  REACT_MEMO_TYPE = symbolFor('react.memo');
  REACT_LAZY_TYPE = symbolFor('react.lazy');
  REACT_BLOCK_TYPE = symbolFor('react.block');
  REACT_SERVER_BLOCK_TYPE = symbolFor('react.server.block');
  REACT_FUNDAMENTAL_TYPE = symbolFor('react.fundamental');
  REACT_SCOPE_TYPE = symbolFor('react.scope');
  REACT_OPAQUE_ID_TYPE = symbolFor('react.opaque.id');
  REACT_DEBUG_TRACING_MODE_TYPE = symbolFor('react.debug_trace_mode');
  REACT_OFFSCREEN_TYPE = symbolFor('react.offscreen');
  REACT_LEGACY_HIDDEN_TYPE = symbolFor('react.legacy_hidden');
}

var MAYBE_ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
var FAUX_ITERATOR_SYMBOL = '@@iterator';
function getIteratorFn(maybeIterable) {
  if (maybeIterable === null || typeof maybeIterable !== 'object') {
    return null;
  }

  var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];

  if (typeof maybeIterator === 'function') {
    return maybeIterator;
  }

  return null;
}

// Helpers to patch console.logs to avoid logging during side-effect free
// replaying on render function. This currently only patches the object
// lazily which won't cover if the log function was extracted eagerly.
// We could also eagerly patch the method.
var disabledDepth = 0;
var prevLog;
var prevInfo;
var prevWarn;
var prevError;
var prevGroup;
var prevGroupCollapsed;
var prevGroupEnd;

function disabledLog() {}

disabledLog.__reactDisabledLog = true;
function disableLogs() {
  {
    if (disabledDepth === 0) {
      /* eslint-disable react-internal/no-production-logging */
      prevLog = console.log;
      prevInfo = console.info;
      prevWarn = console.warn;
      prevError = console.error;
      prevGroup = console.group;
      prevGroupCollapsed = console.groupCollapsed;
      prevGroupEnd = console.groupEnd; // https://github.com/facebook/react/issues/19099

      var props = {
        configurable: true,
        enumerable: true,
        value: disabledLog,
        writable: true
      }; // $FlowFixMe Flow thinks console is immutable.

      Object.defineProperties(console, {
        info: props,
        log: props,
        warn: props,
        error: props,
        group: props,
        groupCollapsed: props,
        groupEnd: props
      });
      /* eslint-enable react-internal/no-production-logging */
    }

    disabledDepth++;
  }
}
function reenableLogs() {
  {
    disabledDepth--;

    if (disabledDepth === 0) {
      /* eslint-disable react-internal/no-production-logging */
      var props = {
        configurable: true,
        enumerable: true,
        writable: true
      }; // $FlowFixMe Flow thinks console is immutable.

      Object.defineProperties(console, {
        log: _assign({}, props, {
          value: prevLog
        }),
        info: _assign({}, props, {
          value: prevInfo
        }),
        warn: _assign({}, props, {
          value: prevWarn
        }),
        error: _assign({}, props, {
          value: prevError
        }),
        group: _assign({}, props, {
          value: prevGroup
        }),
        groupCollapsed: _assign({}, props, {
          value: prevGroupCollapsed
        }),
        groupEnd: _assign({}, props, {
          value: prevGroupEnd
        })
      });
      /* eslint-enable react-internal/no-production-logging */
    }

    if (disabledDepth < 0) {
      error('disabledDepth fell below zero. ' + 'This is a bug in React. Please file an issue.');
    }
  }
}

var ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;
var prefix;
function describeBuiltInComponentFrame(name, source, ownerFn) {
  {
    if (prefix === undefined) {
      // Extract the VM specific prefix used by each line.
      try {
        throw Error();
      } catch (x) {
        var match = x.stack.trim().match(/\n( *(at )?)/);
        prefix = match && match[1] || '';
      }
    } // We use the prefix to ensure our stacks line up with native stack frames.


    return '\n' + prefix + name;
  }
}
var reentry = false;
var componentFrameCache;

{
  var PossiblyWeakMap = typeof WeakMap === 'function' ? WeakMap : Map;
  componentFrameCache = new PossiblyWeakMap();
}

function describeNativeComponentFrame(fn, construct) {
  // If something asked for a stack inside a fake render, it should get ignored.
  if (!fn || reentry) {
    return '';
  }

  {
    var frame = componentFrameCache.get(fn);

    if (frame !== undefined) {
      return frame;
    }
  }

  var control;
  reentry = true;
  var previousPrepareStackTrace = Error.prepareStackTrace; // $FlowFixMe It does accept undefined.

  Error.prepareStackTrace = undefined;
  var previousDispatcher;

  {
    previousDispatcher = ReactCurrentDispatcher.current; // Set the dispatcher in DEV because this might be call in the render function
    // for warnings.

    ReactCurrentDispatcher.current = null;
    disableLogs();
  }

  try {
    // This should throw.
    if (construct) {
      // Something should be setting the props in the constructor.
      var Fake = function () {
        throw Error();
      }; // $FlowFixMe


      Object.defineProperty(Fake.prototype, 'props', {
        set: function () {
          // We use a throwing setter instead of frozen or non-writable props
          // because that won't throw in a non-strict mode function.
          throw Error();
        }
      });

      if (typeof Reflect === 'object' && Reflect.construct) {
        // We construct a different control for this case to include any extra
        // frames added by the construct call.
        try {
          Reflect.construct(Fake, []);
        } catch (x) {
          control = x;
        }

        Reflect.construct(fn, [], Fake);
      } else {
        try {
          Fake.call();
        } catch (x) {
          control = x;
        }

        fn.call(Fake.prototype);
      }
    } else {
      try {
        throw Error();
      } catch (x) {
        control = x;
      }

      fn();
    }
  } catch (sample) {
    // This is inlined manually because closure doesn't do it for us.
    if (sample && control && typeof sample.stack === 'string') {
      // This extracts the first frame from the sample that isn't also in the control.
      // Skipping one frame that we assume is the frame that calls the two.
      var sampleLines = sample.stack.split('\n');
      var controlLines = control.stack.split('\n');
      var s = sampleLines.length - 1;
      var c = controlLines.length - 1;

      while (s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]) {
        // We expect at least one stack frame to be shared.
        // Typically this will be the root most one. However, stack frames may be
        // cut off due to maximum stack limits. In this case, one maybe cut off
        // earlier than the other. We assume that the sample is longer or the same
        // and there for cut off earlier. So we should find the root most frame in
        // the sample somewhere in the control.
        c--;
      }

      for (; s >= 1 && c >= 0; s--, c--) {
        // Next we find the first one that isn't the same which should be the
        // frame that called our sample function and the control.
        if (sampleLines[s] !== controlLines[c]) {
          // In V8, the first line is describing the message but other VMs don't.
          // If we're about to return the first line, and the control is also on the same
          // line, that's a pretty good indicator that our sample threw at same line as
          // the control. I.e. before we entered the sample frame. So we ignore this result.
          // This can happen if you passed a class to function component, or non-function.
          if (s !== 1 || c !== 1) {
            do {
              s--;
              c--; // We may still have similar intermediate frames from the construct call.
              // The next one that isn't the same should be our match though.

              if (c < 0 || sampleLines[s] !== controlLines[c]) {
                // V8 adds a "new" prefix for native classes. Let's remove it to make it prettier.
                var _frame = '\n' + sampleLines[s].replace(' at new ', ' at ');

                {
                  if (typeof fn === 'function') {
                    componentFrameCache.set(fn, _frame);
                  }
                } // Return the line we found.


                return _frame;
              }
            } while (s >= 1 && c >= 0);
          }

          break;
        }
      }
    }
  } finally {
    reentry = false;

    {
      ReactCurrentDispatcher.current = previousDispatcher;
      reenableLogs();
    }

    Error.prepareStackTrace = previousPrepareStackTrace;
  } // Fallback to just using the name if we couldn't make it throw.


  var name = fn ? fn.displayName || fn.name : '';
  var syntheticFrame = name ? describeBuiltInComponentFrame(name) : '';

  {
    if (typeof fn === 'function') {
      componentFrameCache.set(fn, syntheticFrame);
    }
  }

  return syntheticFrame;
}

function describeClassComponentFrame(ctor, source, ownerFn) {
  {
    return describeNativeComponentFrame(ctor, true);
  }
}
function describeFunctionComponentFrame(fn, source, ownerFn) {
  {
    return describeNativeComponentFrame(fn, false);
  }
}

function shouldConstruct(Component) {
  var prototype = Component.prototype;
  return !!(prototype && prototype.isReactComponent);
}

function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {

  if (type == null) {
    return '';
  }

  if (typeof type === 'function') {
    {
      return describeNativeComponentFrame(type, shouldConstruct(type));
    }
  }

  if (typeof type === 'string') {
    return describeBuiltInComponentFrame(type);
  }

  switch (type) {
    case REACT_SUSPENSE_TYPE:
      return describeBuiltInComponentFrame('Suspense');

    case REACT_SUSPENSE_LIST_TYPE:
      return describeBuiltInComponentFrame('SuspenseList');
  }

  if (typeof type === 'object') {
    switch (type.$$typeof) {
      case REACT_FORWARD_REF_TYPE:
        return describeFunctionComponentFrame(type.render);

      case REACT_MEMO_TYPE:
        // Memo may contain any component type so we recursively resolve it.
        return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);

      case REACT_BLOCK_TYPE:
        return describeFunctionComponentFrame(type._render);

      case REACT_LAZY_TYPE:
        {
          var lazyComponent = type;
          var payload = lazyComponent._payload;
          var init = lazyComponent._init;

          try {
            // Lazy may contain any component type so we recursively resolve it.
            return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);
          } catch (x) {}
        }
    }
  }

  return '';
}

function describeFiber(fiber) {
  var owner =  fiber._debugOwner ? fiber._debugOwner.type : null ;
  var source =  fiber._debugSource ;

  switch (fiber.tag) {
    case HostComponent:
      return describeBuiltInComponentFrame(fiber.type);

    case LazyComponent:
      return describeBuiltInComponentFrame('Lazy');

    case SuspenseComponent:
      return describeBuiltInComponentFrame('Suspense');

    case SuspenseListComponent:
      return describeBuiltInComponentFrame('SuspenseList');

    case FunctionComponent:
    case IndeterminateComponent:
    case SimpleMemoComponent:
      return describeFunctionComponentFrame(fiber.type);

    case ForwardRef:
      return describeFunctionComponentFrame(fiber.type.render);

    case Block:
      return describeFunctionComponentFrame(fiber.type._render);

    case ClassComponent:
      return describeClassComponentFrame(fiber.type);

    default:
      return '';
  }
}

function getStackByFiberInDevAndProd(workInProgress) {
  try {
    var info = '';
    var node = workInProgress;

    do {
      info += describeFiber(node);
      node = node.return;
    } while (node);

    return info;
  } catch (x) {
    return '\nError generating stack: ' + x.message + '\n' + x.stack;
  }
}

function getWrappedName(outerType, innerType, wrapperName) {
  var functionName = innerType.displayName || innerType.name || '';
  return outerType.displayName || (functionName !== '' ? wrapperName + "(" + functionName + ")" : wrapperName);
}

function getContextName(type) {
  return type.displayName || 'Context';
}

function getComponentName(type) {
  if (type == null) {
    // Host root, text node or just invalid type.
    return null;
  }

  {
    if (typeof type.tag === 'number') {
      error('Received an unexpected object in getComponentName(). ' + 'This is likely a bug in React. Please file an issue.');
    }
  }

  if (typeof type === 'function') {
    return type.displayName || type.name || null;
  }

  if (typeof type === 'string') {
    return type;
  }

  switch (type) {
    case REACT_FRAGMENT_TYPE:
      return 'Fragment';

    case REACT_PORTAL_TYPE:
      return 'Portal';

    case REACT_PROFILER_TYPE:
      return 'Profiler';

    case REACT_STRICT_MODE_TYPE:
      return 'StrictMode';

    case REACT_SUSPENSE_TYPE:
      return 'Suspense';

    case REACT_SUSPENSE_LIST_TYPE:
      return 'SuspenseList';
  }

  if (typeof type === 'object') {
    switch (type.$$typeof) {
      case REACT_CONTEXT_TYPE:
        var context = type;
        return getContextName(context) + '.Consumer';

      case REACT_PROVIDER_TYPE:
        var provider = type;
        return getContextName(provider._context) + '.Provider';

      case REACT_FORWARD_REF_TYPE:
        return getWrappedName(type, type.render, 'ForwardRef');

      case REACT_MEMO_TYPE:
        return getComponentName(type.type);

      case REACT_BLOCK_TYPE:
        return getComponentName(type._render);

      case REACT_LAZY_TYPE:
        {
          var lazyComponent = type;
          var payload = lazyComponent._payload;
          var init = lazyComponent._init;

          try {
            return getComponentName(init(payload));
          } catch (x) {
            return null;
          }
        }
    }
  }

  return null;
}

var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
var current = null;
var isRendering = false;
function getCurrentFiberOwnerNameInDevOrNull() {
  {
    if (current === null) {
      return null;
    }

    var owner = current._debugOwner;

    if (owner !== null && typeof owner !== 'undefined') {
      return getComponentName(owner.type);
    }
  }

  return null;
}

function getCurrentFiberStackInDev() {
  {
    if (current === null) {
      return '';
    } // Safe because if current fiber exists, we are reconciling,
    // and it is guaranteed to be the work-in-progress version.


    return getStackByFiberInDevAndProd(current);
  }
}

function resetCurrentFiber() {
  {
    ReactDebugCurrentFrame.getCurrentStack = null;
    current = null;
    isRendering = false;
  }
}
function setCurrentFiber(fiber) {
  {
    ReactDebugCurrentFrame.getCurrentStack = getCurrentFiberStackInDev;
    current = fiber;
    isRendering = false;
  }
}
function setIsRendering(rendering) {
  {
    isRendering = rendering;
  }
}
function getIsRendering() {
  {
    return isRendering;
  }
}

// Flow does not allow string concatenation of most non-string types. To work
// around this limitation, we use an opaque type that can only be obtained by
// passing the value through getToStringValue first.
function toString(value) {
  return '' + value;
}
function getToStringValue(value) {
  switch (typeof value) {
    case 'boolean':
    case 'number':
    case 'object':
    case 'string':
    case 'undefined':
      return value;

    default:
      // function, symbol are assigned as empty strings
      return '';
  }
}

var hasReadOnlyValue = {
  button: true,
  checkbox: true,
  image: true,
  hidden: true,
  radio: true,
  reset: true,
  submit: true
};
function checkControlledValueProps(tagName, props) {
  {
    if (!(hasReadOnlyValue[props.type] || props.onChange || props.onInput || props.readOnly || props.disabled || props.value == null)) {
      error('You provided a `value` prop to a form field without an ' + '`onChange` handler. This will render a read-only field. If ' + 'the field should be mutable use `defaultValue`. Otherwise, ' + 'set either `onChange` or `readOnly`.');
    }

    if (!(props.onChange || props.readOnly || props.disabled || props.checked == null)) {
      error('You provided a `checked` prop to a form field without an ' + '`onChange` handler. This will render a read-only field. If ' + 'the field should be mutable use `defaultChecked`. Otherwise, ' + 'set either `onChange` or `readOnly`.');
    }
  }
}

function isCheckable(elem) {
  var type = elem.type;
  var nodeName = elem.nodeName;
  return nodeName && nodeName.toLowerCase() === 'input' && (type === 'checkbox' || type === 'radio');
}

function getTracker(node) {
  return node._valueTracker;
}

function detachTracker(node) {
  node._valueTracker = null;
}

function getValueFromNode(node) {
  var value = '';

  if (!node) {
    return value;
  }

  if (isCheckable(node)) {
    value = node.checked ? 'true' : 'false';
  } else {
    value = node.value;
  }

  return value;
}

function trackValueOnNode(node) {
  var valueField = isCheckable(node) ? 'checked' : 'value';
  var descriptor = Object.getOwnPropertyDescriptor(node.constructor.prototype, valueField);
  var currentValue = '' + node[valueField]; // if someone has already defined a value or Safari, then bail
  // and don't track value will cause over reporting of changes,
  // but it's better then a hard failure
  // (needed for certain tests that spyOn input values and Safari)

  if (node.hasOwnProperty(valueField) || typeof descriptor === 'undefined' || typeof descriptor.get !== 'function' || typeof descriptor.set !== 'function') {
    return;
  }

  var get = descriptor.get,
      set = descriptor.set;
  Object.defineProperty(node, valueField, {
    configurable: true,
    get: function () {
      return get.call(this);
    },
    set: function (value) {
      currentValue = '' + value;
      set.call(this, value);
    }
  }); // We could've passed this the first time
  // but it triggers a bug in IE11 and Edge 14/15.
  // Calling defineProperty() again should be equivalent.
  // https://github.com/facebook/react/issues/11768

  Object.defineProperty(node, valueField, {
    enumerable: descriptor.enumerable
  });
  var tracker = {
    getValue: function () {
      return currentValue;
    },
    setValue: function (value) {
      currentValue = '' + value;
    },
    stopTracking: function () {
      detachTracker(node);
      delete node[valueField];
    }
  };
  return tracker;
}

function track(node) {
  if (getTracker(node)) {
    return;
  } // TODO: Once it's just Fiber we can move this to node._wrapperState


  node._valueTracker = trackValueOnNode(node);
}
function updateValueIfChanged(node) {
  if (!node) {
    return false;
  }

  var tracker = getTracker(node); // if there is no tracker at this point it's unlikely
  // that trying again will succeed

  if (!tracker) {
    return true;
  }

  var lastValue = tracker.getValue();
  var nextValue = getValueFromNode(node);

  if (nextValue !== lastValue) {
    tracker.setValue(nextValue);
    return true;
  }

  return false;
}

function getActiveElement(doc) {
  doc = doc || (typeof document !== 'undefined' ? document : undefined);

  if (typeof doc === 'undefined') {
    return null;
  }

  try {
    return doc.activeElement || doc.body;
  } catch (e) {
    return doc.body;
  }
}

var didWarnValueDefaultValue = false;
var didWarnCheckedDefaultChecked = false;
var didWarnControlledToUncontrolled = false;
var didWarnUncontrolledToControlled = false;

function isControlled(props) {
  var usesChecked = props.type === 'checkbox' || props.type === 'radio';
  return usesChecked ? props.checked != null : props.value != null;
}
/**
 * Implements an <input> host component that allows setting these optional
 * props: `checked`, `value`, `defaultChecked`, and `defaultValue`.
 *
 * If `checked` or `value` are not supplied (or null/undefined), user actions
 * that affect the checked state or value will trigger updates to the element.
 *
 * If they are supplied (and not null/undefined), the rendered element will not
 * trigger updates to the element. Instead, the props must change in order for
 * the rendered element to be updated.
 *
 * The rendered element will be initialized as unchecked (or `defaultChecked`)
 * with an empty value (or `defaultValue`).
 *
 * See http://www.w3.org/TR/2012/WD-html5-20121025/the-input-element.html
 */


function getHostProps(element, props) {
  var node = element;
  var checked = props.checked;

  var hostProps = _assign({}, props, {
    defaultChecked: undefined,
    defaultValue: undefined,
    value: undefined,
    checked: checked != null ? checked : node._wrapperState.initialChecked
  });

  return hostProps;
}
function initWrapperState(element, props) {
  {
    checkControlledValueProps('input', props);

    if (props.checked !== undefined && props.defaultChecked !== undefined && !didWarnCheckedDefaultChecked) {
      error('%s contains an input of type %s with both checked and defaultChecked props. ' + 'Input elements must be either controlled or uncontrolled ' + '(specify either the checked prop, or the defaultChecked prop, but not ' + 'both). Decide between using a controlled or uncontrolled input ' + 'element and remove one of these props. More info: ' + 'https://reactjs.org/link/controlled-components', getCurrentFiberOwnerNameInDevOrNull() || 'A component', props.type);

      didWarnCheckedDefaultChecked = true;
    }

    if (props.value !== undefined && props.defaultValue !== undefined && !didWarnValueDefaultValue) {
      error('%s contains an input of type %s with both value and defaultValue props. ' + 'Input elements must be either controlled or uncontrolled ' + '(specify either the value prop, or the defaultValue prop, but not ' + 'both). Decide between using a controlled or uncontrolled input ' + 'element and remove one of these props. More info: ' + 'https://reactjs.org/link/controlled-components', getCurrentFiberOwnerNameInDevOrNull() || 'A component', props.type);

      didWarnValueDefaultValue = true;
    }
  }

  var node = element;
  var defaultValue = props.defaultValue == null ? '' : props.defaultValue;
  node._wrapperState = {
    initialChecked: props.checked != null ? props.checked : props.defaultChecked,
    initialValue: getToStringValue(props.value != null ? props.value : defaultValue),
    controlled: isControlled(props)
  };
}
function updateChecked(element, props) {
  var node = element;
  var checked = props.checked;

  if (checked != null) {
    setValueForProperty(node, 'checked', checked, false);
  }
}
function updateWrapper(element, props) {
  var node = element;

  {
    var controlled = isControlled(props);

    if (!node._wrapperState.controlled && controlled && !didWarnUncontrolledToControlled) {
      error('A component is changing an uncontrolled input to be controlled. ' + 'This is likely caused by the value changing from undefined to ' + 'a defined value, which should not happen. ' + 'Decide between using a controlled or uncontrolled input ' + 'element for the lifetime of the component. More info: https://reactjs.org/link/controlled-components');

      didWarnUncontrolledToControlled = true;
    }

    if (node._wrapperState.controlled && !controlled && !didWarnControlledToUncontrolled) {
      error('A component is changing a controlled input to be uncontrolled. ' + 'This is likely caused by the value changing from a defined to ' + 'undefined, which should not happen. ' + 'Decide between using a controlled or uncontrolled input ' + 'element for the lifetime of the component. More info: https://reactjs.org/link/controlled-components');

      didWarnControlledToUncontrolled = true;
    }
  }

  updateChecked(element, props);
  var value = getToStringValue(props.value);
  var type = props.type;

  if (value != null) {
    if (type === 'number') {
      if (value === 0 && node.value === '' || // We explicitly want to coerce to number here if possible.
      // eslint-disable-next-line
      node.value != value) {
        node.value = toString(value);
      }
    } else if (node.value !== toString(value)) {
      node.value = toString(value);
    }
  } else if (type === 'submit' || type === 'reset') {
    // Submit/reset inputs need the attribute removed completely to avoid
    // blank-text buttons.
    node.removeAttribute('value');
    return;
  }

  {
    // When syncing the value attribute, the value comes from a cascade of
    // properties:
    //  1. The value React property
    //  2. The defaultValue React property
    //  3. Otherwise there should be no change
    if (props.hasOwnProperty('value')) {
      setDefaultValue(node, props.type, value);
    } else if (props.hasOwnProperty('defaultValue')) {
      setDefaultValue(node, props.type, getToStringValue(props.defaultValue));
    }
  }

  {
    // When syncing the checked attribute, it only changes when it needs
    // to be removed, such as transitioning from a checkbox into a text input
    if (props.checked == null && props.defaultChecked != null) {
      node.defaultChecked = !!props.defaultChecked;
    }
  }
}
function postMountWrapper(element, props, isHydrating) {
  var node = element; // Do not assign value if it is already set. This prevents user text input
  // from being lost during SSR hydration.

  if (props.hasOwnProperty('value') || props.hasOwnProperty('defaultValue')) {
    var type = props.type;
    var isButton = type === 'submit' || type === 'reset'; // Avoid setting value attribute on submit/reset inputs as it overrides the
    // default value provided by the browser. See: #12872

    if (isButton && (props.value === undefined || props.value === null)) {
      return;
    }

    var initialValue = toString(node._wrapperState.initialValue); // Do not assign value if it is already set. This prevents user text input
    // from being lost during SSR hydration.

    if (!isHydrating) {
      {
        // When syncing the value attribute, the value property should use
        // the wrapperState._initialValue property. This uses:
        //
        //   1. The value React property when present
        //   2. The defaultValue React property when present
        //   3. An empty string
        if (initialValue !== node.value) {
          node.value = initialValue;
        }
      }
    }

    {
      // Otherwise, the value attribute is synchronized to the property,
      // so we assign defaultValue to the same thing as the value property
      // assignment step above.
      node.defaultValue = initialValue;
    }
  } // Normally, we'd just do `node.checked = node.checked` upon initial mount, less this bug
  // this is needed to work around a chrome bug where setting defaultChecked
  // will sometimes influence the value of checked (even after detachment).
  // Reference: https://bugs.chromium.org/p/chromium/issues/detail?id=608416
  // We need to temporarily unset name to avoid disrupting radio button groups.


  var name = node.name;

  if (name !== '') {
    node.name = '';
  }

  {
    // When syncing the checked attribute, both the checked property and
    // attribute are assigned at the same time using defaultChecked. This uses:
    //
    //   1. The checked React property when present
    //   2. The defaultChecked React property when present
    //   3. Otherwise, false
    node.defaultChecked = !node.defaultChecked;
    node.defaultChecked = !!node._wrapperState.initialChecked;
  }

  if (name !== '') {
    node.name = name;
  }
}
function restoreControlledState(element, props) {
  var node = element;
  updateWrapper(node, props);
  updateNamedCousins(node, props);
}

function updateNamedCousins(rootNode, props) {
  var name = props.name;

  if (props.type === 'radio' && name != null) {
    var queryRoot = rootNode;

    while (queryRoot.parentNode) {
      queryRoot = queryRoot.parentNode;
    } // If `rootNode.form` was non-null, then we could try `form.elements`,
    // but that sometimes behaves strangely in IE8. We could also try using
    // `form.getElementsByName`, but that will only return direct children
    // and won't include inputs that use the HTML5 `form=` attribute. Since
    // the input might not even be in a form. It might not even be in the
    // document. Let's just use the local `querySelectorAll` to ensure we don't
    // miss anything.


    var group = queryRoot.querySelectorAll('input[name=' + JSON.stringify('' + name) + '][type="radio"]');

    for (var i = 0; i < group.length; i++) {
      var otherNode = group[i];

      if (otherNode === rootNode || otherNode.form !== rootNode.form) {
        continue;
      } // This will throw if radio buttons rendered by different copies of React
      // and the same name are rendered into the same form (same as #1939).
      // That's probably okay; we don't support it just as we don't support
      // mixing React radio buttons with non-React ones.


      var otherProps = getFiberCurrentPropsFromNode(otherNode);

      if (!otherProps) {
        {
          throw Error( "ReactDOMInput: Mixing React and non-React radio inputs with the same `name` is not supported." );
        }
      } // We need update the tracked value on the named cousin since the value
      // was changed but the input saw no event or value set


      updateValueIfChanged(otherNode); // If this is a controlled radio button group, forcing the input that
      // was previously checked to update will cause it to be come re-checked
      // as appropriate.

      updateWrapper(otherNode, otherProps);
    }
  }
} // In Chrome, assigning defaultValue to certain input types triggers input validation.
// For number inputs, the display value loses trailing decimal points. For email inputs,
// Chrome raises "The specified value <x> is not a valid email address".
//
// Here we check to see if the defaultValue has actually changed, avoiding these problems
// when the user is inputting text
//
// https://github.com/facebook/react/issues/7253


function setDefaultValue(node, type, value) {
  if ( // Focused number inputs synchronize on blur. See ChangeEventPlugin.js
  type !== 'number' || getActiveElement(node.ownerDocument) !== node) {
    if (value == null) {
      node.defaultValue = toString(node._wrapperState.initialValue);
    } else if (node.defaultValue !== toString(value)) {
      node.defaultValue = toString(value);
    }
  }
}

var didWarnSelectedSetOnOption = false;
var didWarnInvalidChild = false;

function flattenChildren(children) {
  var content = ''; // Flatten children. We'll warn if they are invalid
  // during validateProps() which runs for hydration too.
  // Note that this would throw on non-element objects.
  // Elements are stringified (which is normally irrelevant
  // but matters for <fbt>).

  React.Children.forEach(children, function (child) {
    if (child == null) {
      return;
    }

    content += child; // Note: we don't warn about invalid children here.
    // Instead, this is done separately below so that
    // it happens during the hydration code path too.
  });
  return content;
}
/**
 * Implements an <option> host component that warns when `selected` is set.
 */


function validateProps(element, props) {
  {
    // This mirrors the code path above, but runs for hydration too.
    // Warn about invalid children here so that client and hydration are consistent.
    // TODO: this seems like it could cause a DEV-only throw for hydration
    // if children contains a non-element object. We should try to avoid that.
    if (typeof props.children === 'object' && props.children !== null) {
      React.Children.forEach(props.children, function (child) {
        if (child == null) {
          return;
        }

        if (typeof child === 'string' || typeof child === 'number') {
          return;
        }

        if (typeof child.type !== 'string') {
          return;
        }

        if (!didWarnInvalidChild) {
          didWarnInvalidChild = true;

          error('Only strings and numbers are supported as <option> children.');
        }
      });
    } // TODO: Remove support for `selected` in <option>.


    if (props.selected != null && !didWarnSelectedSetOnOption) {
      error('Use the `defaultValue` or `value` props on <select> instead of ' + 'setting `selected` on <option>.');

      didWarnSelectedSetOnOption = true;
    }
  }
}
function postMountWrapper$1(element, props) {
  // value="" should make a value attribute (#6219)
  if (props.value != null) {
    element.setAttribute('value', toString(getToStringValue(props.value)));
  }
}
function getHostProps$1(element, props) {
  var hostProps = _assign({
    children: undefined
  }, props);

  var content = flattenChildren(props.children);

  if (content) {
    hostProps.children = content;
  }

  return hostProps;
}

var didWarnValueDefaultValue$1;

{
  didWarnValueDefaultValue$1 = false;
}

function getDeclarationErrorAddendum() {
  var ownerName = getCurrentFiberOwnerNameInDevOrNull();

  if (ownerName) {
    return '\n\nCheck the render method of `' + ownerName + '`.';
  }

  return '';
}

var valuePropNames = ['value', 'defaultValue'];
/**
 * Validation function for `value` and `defaultValue`.
 */

function checkSelectPropTypes(props) {
  {
    checkControlledValueProps('select', props);

    for (var i = 0; i < valuePropNames.length; i++) {
      var propName = valuePropNames[i];

      if (props[propName] == null) {
        continue;
      }

      var isArray = Array.isArray(props[propName]);

      if (props.multiple && !isArray) {
        error('The `%s` prop supplied to <select> must be an array if ' + '`multiple` is true.%s', propName, getDeclarationErrorAddendum());
      } else if (!props.multiple && isArray) {
        error('The `%s` prop supplied to <select> must be a scalar ' + 'value if `multiple` is false.%s', propName, getDeclarationErrorAddendum());
      }
    }
  }
}

function updateOptions(node, multiple, propValue, setDefaultSelected) {
  var options = node.options;

  if (multiple) {
    var selectedValues = propValue;
    var selectedValue = {};

    for (var i = 0; i < selectedValues.length; i++) {
      // Prefix to avoid chaos with special keys.
      selectedValue['$' + selectedValues[i]] = true;
    }

    for (var _i = 0; _i < options.length; _i++) {
      var selected = selectedValue.hasOwnProperty('$' + options[_i].value);

      if (options[_i].selected !== selected) {
        options[_i].selected = selected;
      }

      if (selected && setDefaultSelected) {
        options[_i].defaultSelected = true;
      }
    }
  } else {
    // Do not set `select.value` as exact behavior isn't consistent across all
    // browsers for all cases.
    var _selectedValue = toString(getToStringValue(propValue));

    var defaultSelected = null;

    for (var _i2 = 0; _i2 < options.length; _i2++) {
      if (options[_i2].value === _selectedValue) {
        options[_i2].selected = true;

        if (setDefaultSelected) {
          options[_i2].defaultSelected = true;
        }

        return;
      }

      if (defaultSelected === null && !options[_i2].disabled) {
        defaultSelected = options[_i2];
      }
    }

    if (defaultSelected !== null) {
      defaultSelected.selected = true;
    }
  }
}
/**
 * Implements a <select> host component that allows optionally setting the
 * props `value` and `defaultValue`. If `multiple` is false, the prop must be a
 * stringable. If `multiple` is true, the prop must be an array of stringables.
 *
 * If `value` is not supplied (or null/undefined), user actions that change the
 * selected option will trigger updates to the rendered options.
 *
 * If it is supplied (and not null/undefined), the rendered options will not
 * update in response to user actions. Instead, the `value` prop must change in
 * order for the rendered options to update.
 *
 * If `defaultValue` is provided, any options with the supplied values will be
 * selected.
 */


function getHostProps$2(element, props) {
  return _assign({}, props, {
    value: undefined
  });
}
function initWrapperState$1(element, props) {
  var node = element;

  {
    checkSelectPropTypes(props);
  }

  node._wrapperState = {
    wasMultiple: !!props.multiple
  };

  {
    if (props.value !== undefined && props.defaultValue !== undefined && !didWarnValueDefaultValue$1) {
      error('Select elements must be either controlled or uncontrolled ' + '(specify either the value prop, or the defaultValue prop, but not ' + 'both). Decide between using a controlled or uncontrolled select ' + 'element and remove one of these props. More info: ' + 'https://reactjs.org/link/controlled-components');

      didWarnValueDefaultValue$1 = true;
    }
  }
}
function postMountWrapper$2(element, props) {
  var node = element;
  node.multiple = !!props.multiple;
  var value = props.value;

  if (value != null) {
    updateOptions(node, !!props.multiple, value, false);
  } else if (props.defaultValue != null) {
    updateOptions(node, !!props.multiple, props.defaultValue, true);
  }
}
function postUpdateWrapper(element, props) {
  var node = element;
  var wasMultiple = node._wrapperState.wasMultiple;
  node._wrapperState.wasMultiple = !!props.multiple;
  var value = props.value;

  if (value != null) {
    updateOptions(node, !!props.multiple, value, false);
  } else if (wasMultiple !== !!props.multiple) {
    // For simplicity, reapply `defaultValue` if `multiple` is toggled.
    if (props.defaultValue != null) {
      updateOptions(node, !!props.multiple, props.defaultValue, true);
    } else {
      // Revert the select back to its default unselected state.
      updateOptions(node, !!props.multiple, props.multiple ? [] : '', false);
    }
  }
}
function restoreControlledState$1(element, props) {
  var node = element;
  var value = props.value;

  if (value != null) {
    updateOptions(node, !!props.multiple, value, false);
  }
}

var didWarnValDefaultVal = false;

/**
 * Implements a <textarea> host component that allows setting `value`, and
 * `defaultValue`. This differs from the traditional DOM API because value is
 * usually set as PCDATA children.
 *
 * If `value` is not supplied (or null/undefined), user actions that affect the
 * value will trigger updates to the element.
 *
 * If `value` is supplied (and not null/undefined), the rendered element will
 * not trigger updates to the element. Instead, the `value` prop must change in
 * order for the rendered element to be updated.
 *
 * The rendered element will be initialized with an empty value, the prop
 * `defaultValue` if specified, or the children content (deprecated).
 */
function getHostProps$3(element, props) {
  var node = element;

  if (!(props.dangerouslySetInnerHTML == null)) {
    {
      throw Error( "`dangerouslySetInnerHTML` does not make sense on <textarea>." );
    }
  } // Always set children to the same thing. In IE9, the selection range will
  // get reset if `textContent` is mutated.  We could add a check in setTextContent
  // to only set the value if/when the value differs from the node value (which would
  // completely solve this IE9 bug), but Sebastian+Sophie seemed to like this
  // solution. The value can be a boolean or object so that's why it's forced
  // to be a string.


  var hostProps = _assign({}, props, {
    value: undefined,
    defaultValue: undefined,
    children: toString(node._wrapperState.initialValue)
  });

  return hostProps;
}
function initWrapperState$2(element, props) {
  var node = element;

  {
    checkControlledValueProps('textarea', props);

    if (props.value !== undefined && props.defaultValue !== undefined && !didWarnValDefaultVal) {
      error('%s contains a textarea with both value and defaultValue props. ' + 'Textarea elements must be either controlled or uncontrolled ' + '(specify either the value prop, or the defaultValue prop, but not ' + 'both). Decide between using a controlled or uncontrolled textarea ' + 'and remove one of these props. More info: ' + 'https://reactjs.org/link/controlled-components', getCurrentFiberOwnerNameInDevOrNull() || 'A component');

      didWarnValDefaultVal = true;
    }
  }

  var initialValue = props.value; // Only bother fetching default value if we're going to use it

  if (initialValue == null) {
    var children = props.children,
        defaultValue = props.defaultValue;

    if (children != null) {
      {
        error('Use the `defaultValue` or `value` props instead of setting ' + 'children on <textarea>.');
      }

      {
        if (!(defaultValue == null)) {
          {
            throw Error( "If you supply `defaultValue` on a <textarea>, do not pass children." );
          }
        }

        if (Array.isArray(children)) {
          if (!(children.length <= 1)) {
            {
              throw Error( "<textarea> can only have at most one child." );
            }
          }

          children = children[0];
        }

        defaultValue = children;
      }
    }

    if (defaultValue == null) {
      defaultValue = '';
    }

    initialValue = defaultValue;
  }

  node._wrapperState = {
    initialValue: getToStringValue(initialValue)
  };
}
function updateWrapper$1(element, props) {
  var node = element;
  var value = getToStringValue(props.value);
  var defaultValue = getToStringValue(props.defaultValue);

  if (value != null) {
    // Cast `value` to a string to ensure the value is set correctly. While
    // browsers typically do this as necessary, jsdom doesn't.
    var newValue = toString(value); // To avoid side effects (such as losing text selection), only set value if changed

    if (newValue !== node.value) {
      node.value = newValue;
    }

    if (props.defaultValue == null && node.defaultValue !== newValue) {
      node.defaultValue = newValue;
    }
  }

  if (defaultValue != null) {
    node.defaultValue = toString(defaultValue);
  }
}
function postMountWrapper$3(element, props) {
  var node = element; // This is in postMount because we need access to the DOM node, which is not
  // available until after the component has mounted.

  var textContent = node.textContent; // Only set node.value if textContent is equal to the expected
  // initial value. In IE10/IE11 there is a bug where the placeholder attribute
  // will populate textContent as well.
  // https://developer.microsoft.com/microsoft-edge/platform/issues/101525/

  if (textContent === node._wrapperState.initialValue) {
    if (textContent !== '' && textContent !== null) {
      node.value = textContent;
    }
  }
}
function restoreControlledState$2(element, props) {
  // DOM component is still mounted; update
  updateWrapper$1(element, props);
}

var HTML_NAMESPACE = 'http://www.w3.org/1999/xhtml';
var MATH_NAMESPACE = 'http://www.w3.org/1998/Math/MathML';
var SVG_NAMESPACE = 'http://www.w3.org/2000/svg';
var Namespaces = {
  html: HTML_NAMESPACE,
  mathml: MATH_NAMESPACE,
  svg: SVG_NAMESPACE
}; // Assumes there is no parent namespace.

function getIntrinsicNamespace(type) {
  switch (type) {
    case 'svg':
      return SVG_NAMESPACE;

    case 'math':
      return MATH_NAMESPACE;

    default:
      return HTML_NAMESPACE;
  }
}
function getChildNamespace(parentNamespace, type) {
  if (parentNamespace == null || parentNamespace === HTML_NAMESPACE) {
    // No (or default) parent namespace: potential entry point.
    return getIntrinsicNamespace(type);
  }

  if (parentNamespace === SVG_NAMESPACE && type === 'foreignObject') {
    // We're leaving SVG.
    return HTML_NAMESPACE;
  } // By default, pass namespace below.


  return parentNamespace;
}

/* globals MSApp */

/**
 * Create a function which has 'unsafe' privileges (required by windows8 apps)
 */
var createMicrosoftUnsafeLocalFunction = function (func) {
  if (typeof MSApp !== 'undefined' && MSApp.execUnsafeLocalFunction) {
    return function (arg0, arg1, arg2, arg3) {
      MSApp.execUnsafeLocalFunction(function () {
        return func(arg0, arg1, arg2, arg3);
      });
    };
  } else {
    return func;
  }
};

var reusableSVGContainer;
/**
 * Set the innerHTML property of a node
 *
 * @param {DOMElement} node
 * @param {string} html
 * @internal
 */

var setInnerHTML = createMicrosoftUnsafeLocalFunction(function (node, html) {
  if (node.namespaceURI === Namespaces.svg) {

    if (!('innerHTML' in node)) {
      // IE does not have innerHTML for SVG nodes, so instead we inject the
      // new markup in a temp node and then move the child nodes across into
      // the target node
      reusableSVGContainer = reusableSVGContainer || document.createElement('div');
      reusableSVGContainer.innerHTML = '<svg>' + html.valueOf().toString() + '</svg>';
      var svgNode = reusableSVGContainer.firstChild;

      while (node.firstChild) {
        node.removeChild(node.firstChild);
      }

      while (svgNode.firstChild) {
        node.appendChild(svgNode.firstChild);
      }

      return;
    }
  }

  node.innerHTML = html;
});

/**
 * HTML nodeType values that represent the type of the node
 */
var ELEMENT_NODE = 1;
var TEXT_NODE = 3;
var COMMENT_NODE = 8;
var DOCUMENT_NODE = 9;
var DOCUMENT_FRAGMENT_NODE = 11;

/**
 * Set the textContent property of a node. For text updates, it's faster
 * to set the `nodeValue` of the Text node directly instead of using
 * `.textContent` which will remove the existing node and create a new one.
 *
 * @param {DOMElement} node
 * @param {string} text
 * @internal
 */

var setTextContent = function (node, text) {
  if (text) {
    var firstChild = node.firstChild;

    if (firstChild && firstChild === node.lastChild && firstChild.nodeType === TEXT_NODE) {
      firstChild.nodeValue = text;
      return;
    }
  }

  node.textContent = text;
};

// List derived from Gecko source code:
// https://github.com/mozilla/gecko-dev/blob/4e638efc71/layout/style/test/property_database.js
var shorthandToLonghand = {
  animation: ['animationDelay', 'animationDirection', 'animationDuration', 'animationFillMode', 'animationIterationCount', 'animationName', 'animationPlayState', 'animationTimingFunction'],
  background: ['backgroundAttachment', 'backgroundClip', 'backgroundColor', 'backgroundImage', 'backgroundOrigin', 'backgroundPositionX', 'backgroundPositionY', 'backgroundRepeat', 'backgroundSize'],
  backgroundPosition: ['backgroundPositionX', 'backgroundPositionY'],
  border: ['borderBottomColor', 'borderBottomStyle', 'borderBottomWidth', 'borderImageOutset', 'borderImageRepeat', 'borderImageSlice', 'borderImageSource', 'borderImageWidth', 'borderLeftColor', 'borderLeftStyle', 'borderLeftWidth', 'borderRightColor', 'borderRightStyle', 'borderRightWidth', 'borderTopColor', 'borderTopStyle', 'borderTopWidth'],
  borderBlockEnd: ['borderBlockEndColor', 'borderBlockEndStyle', 'borderBlockEndWidth'],
  borderBlockStart: ['borderBlockStartColor', 'borderBlockStartStyle', 'borderBlockStartWidth'],
  borderBottom: ['borderBottomColor', 'borderBottomStyle', 'borderBottomWidth'],
  borderColor: ['borderBottomColor', 'borderLeftColor', 'borderRightColor', 'borderTopColor'],
  borderImage: ['borderImageOutset', 'borderImageRepeat', 'borderImageSlice', 'borderImageSource', 'borderImageWidth'],
  borderInlineEnd: ['borderInlineEndColor', 'borderInlineEndStyle', 'borderInlineEndWidth'],
  borderInlineStart: ['borderInlineStartColor', 'borderInlineStartStyle', 'borderInlineStartWidth'],
  borderLeft: ['borderLeftColor', 'borderLeftStyle', 'borderLeftWidth'],
  borderRadius: ['borderBottomLeftRadius', 'borderBottomRightRadius', 'borderTopLeftRadius', 'borderTopRightRadius'],
  borderRight: ['borderRightColor', 'borderRightStyle', 'borderRightWidth'],
  borderStyle: ['borderBottomStyle', 'borderLeftStyle', 'borderRightStyle', 'borderTopStyle'],
  borderTop: ['borderTopColor', 'borderTopStyle', 'borderTopWidth'],
  borderWidth: ['borderBottomWidth', 'borderLeftWidth', 'borderRightWidth', 'borderTopWidth'],
  columnRule: ['columnRuleColor', 'columnRuleStyle', 'columnRuleWidth'],
  columns: ['columnCount', 'columnWidth'],
  flex: ['flexBasis', 'flexGrow', 'flexShrink'],
  flexFlow: ['flexDirection', 'flexWrap'],
  font: ['fontFamily', 'fontFeatureSettings', 'fontKerning', 'fontLanguageOverride', 'fontSize', 'fontSizeAdjust', 'fontStretch', 'fontStyle', 'fontVariant', 'fontVariantAlternates', 'fontVariantCaps', 'fontVariantEastAsian', 'fontVariantLigatures', 'fontVariantNumeric', 'fontVariantPosition', 'fontWeight', 'lineHeight'],
  fontVariant: ['fontVariantAlternates', 'fontVariantCaps', 'fontVariantEastAsian', 'fontVariantLigatures', 'fontVariantNumeric', 'fontVariantPosition'],
  gap: ['columnGap', 'rowGap'],
  grid: ['gridAutoColumns', 'gridAutoFlow', 'gridAutoRows', 'gridTemplateAreas', 'gridTemplateColumns', 'gridTemplateRows'],
  gridArea: ['gridColumnEnd', 'gridColumnStart', 'gridRowEnd', 'gridRowStart'],
  gridColumn: ['gridColumnEnd', 'gridColumnStart'],
  gridColumnGap: ['columnGap'],
  gridGap: ['columnGap', 'rowGap'],
  gridRow: ['gridRowEnd', 'gridRowStart'],
  gridRowGap: ['rowGap'],
  gridTemplate: ['gridTemplateAreas', 'gridTemplateColumns', 'gridTemplateRows'],
  listStyle: ['listStyleImage', 'listStylePosition', 'listStyleType'],
  margin: ['marginBottom', 'marginLeft', 'marginRight', 'marginTop'],
  marker: ['markerEnd', 'markerMid', 'markerStart'],
  mask: ['maskClip', 'maskComposite', 'maskImage', 'maskMode', 'maskOrigin', 'maskPositionX', 'maskPositionY', 'maskRepeat', 'maskSize'],
  maskPosition: ['maskPositionX', 'maskPositionY'],
  outline: ['outlineColor', 'outlineStyle', 'outlineWidth'],
  overflow: ['overflowX', 'overflowY'],
  padding: ['paddingBottom', 'paddingLeft', 'paddingRight', 'paddingTop'],
  placeContent: ['alignContent', 'justifyContent'],
  placeItems: ['alignItems', 'justifyItems'],
  placeSelf: ['alignSelf', 'justifySelf'],
  textDecoration: ['textDecorationColor', 'textDecorationLine', 'textDecorationStyle'],
  textEmphasis: ['textEmphasisColor', 'textEmphasisStyle'],
  transition: ['transitionDelay', 'transitionDuration', 'transitionProperty', 'transitionTimingFunction'],
  wordWrap: ['overflowWrap']
};

/**
 * CSS properties which accept numbers but are not in units of "px".
 */
var isUnitlessNumber = {
  animationIterationCount: true,
  borderImageOutset: true,
  borderImageSlice: true,
  borderImageWidth: true,
  boxFlex: true,
  boxFlexGroup: true,
  boxOrdinalGroup: true,
  columnCount: true,
  columns: true,
  flex: true,
  flexGrow: true,
  flexPositive: true,
  flexShrink: true,
  flexNegative: true,
  flexOrder: true,
  gridArea: true,
  gridRow: true,
  gridRowEnd: true,
  gridRowSpan: true,
  gridRowStart: true,
  gridColumn: true,
  gridColumnEnd: true,
  gridColumnSpan: true,
  gridColumnStart: true,
  fontWeight: true,
  lineClamp: true,
  lineHeight: true,
  opacity: true,
  order: true,
  orphans: true,
  tabSize: true,
  widows: true,
  zIndex: true,
  zoom: true,
  // SVG-related properties
  fillOpacity: true,
  floodOpacity: true,
  stopOpacity: true,
  strokeDasharray: true,
  strokeDashoffset: true,
  strokeMiterlimit: true,
  strokeOpacity: true,
  strokeWidth: true
};
/**
 * @param {string} prefix vendor-specific prefix, eg: Webkit
 * @param {string} key style name, eg: transitionDuration
 * @return {string} style name prefixed with `prefix`, properly camelCased, eg:
 * WebkitTransitionDuration
 */

function prefixKey(prefix, key) {
  return prefix + key.charAt(0).toUpperCase() + key.substring(1);
}
/**
 * Support style names that may come passed in prefixed by adding permutations
 * of vendor prefixes.
 */


var prefixes = ['Webkit', 'ms', 'Moz', 'O']; // Using Object.keys here, or else the vanilla for-in loop makes IE8 go into an
// infinite loop, because it iterates over the newly added props too.

Object.keys(isUnitlessNumber).forEach(function (prop) {
  prefixes.forEach(function (prefix) {
    isUnitlessNumber[prefixKey(prefix, prop)] = isUnitlessNumber[prop];
  });
});

/**
 * Convert a value into the proper css writable value. The style name `name`
 * should be logical (no hyphens), as specified
 * in `CSSProperty.isUnitlessNumber`.
 *
 * @param {string} name CSS property name such as `topMargin`.
 * @param {*} value CSS property value such as `10px`.
 * @return {string} Normalized style value with dimensions applied.
 */

function dangerousStyleValue(name, value, isCustomProperty) {
  // Note that we've removed escapeTextForBrowser() calls here since the
  // whole string will be escaped when the attribute is injected into
  // the markup. If you provide unsafe user data here they can inject
  // arbitrary CSS which may be problematic (I couldn't repro this):
  // https://www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet
  // http://www.thespanner.co.uk/2007/11/26/ultimate-xss-css-injection/
  // This is not an XSS hole but instead a potential CSS injection issue
  // which has lead to a greater discussion about how we're going to
  // trust URLs moving forward. See #2115901
  var isEmpty = value == null || typeof value === 'boolean' || value === '';

  if (isEmpty) {
    return '';
  }

  if (!isCustomProperty && typeof value === 'number' && value !== 0 && !(isUnitlessNumber.hasOwnProperty(name) && isUnitlessNumber[name])) {
    return value + 'px'; // Presumes implicit 'px' suffix for unitless numbers
  }

  return ('' + value).trim();
}

var uppercasePattern = /([A-Z])/g;
var msPattern = /^ms-/;
/**
 * Hyphenates a camelcased CSS property name, for example:
 *
 *   > hyphenateStyleName('backgroundColor')
 *   < "background-color"
 *   > hyphenateStyleName('MozTransition')
 *   < "-moz-transition"
 *   > hyphenateStyleName('msTransition')
 *   < "-ms-transition"
 *
 * As Modernizr suggests (http://modernizr.com/docs/#prefixed), an `ms` prefix
 * is converted to `-ms-`.
 */

function hyphenateStyleName(name) {
  return name.replace(uppercasePattern, '-$1').toLowerCase().replace(msPattern, '-ms-');
}

var warnValidStyle = function () {};

{
  // 'msTransform' is correct, but the other prefixes should be capitalized
  var badVendoredStyleNamePattern = /^(?:webkit|moz|o)[A-Z]/;
  var msPattern$1 = /^-ms-/;
  var hyphenPattern = /-(.)/g; // style values shouldn't contain a semicolon

  var badStyleValueWithSemicolonPattern = /;\s*$/;
  var warnedStyleNames = {};
  var warnedStyleValues = {};
  var warnedForNaNValue = false;
  var warnedForInfinityValue = false;

  var camelize = function (string) {
    return string.replace(hyphenPattern, function (_, character) {
      return character.toUpperCase();
    });
  };

  var warnHyphenatedStyleName = function (name) {
    if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {
      return;
    }

    warnedStyleNames[name] = true;

    error('Unsupported style property %s. Did you mean %s?', name, // As Andi Smith suggests
    // (http://www.andismith.com/blog/2012/02/modernizr-prefixed/), an `-ms` prefix
    // is converted to lowercase `ms`.
    camelize(name.replace(msPattern$1, 'ms-')));
  };

  var warnBadVendoredStyleName = function (name) {
    if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {
      return;
    }

    warnedStyleNames[name] = true;

    error('Unsupported vendor-prefixed style property %s. Did you mean %s?', name, name.charAt(0).toUpperCase() + name.slice(1));
  };

  var warnStyleValueWithSemicolon = function (name, value) {
    if (warnedStyleValues.hasOwnProperty(value) && warnedStyleValues[value]) {
      return;
    }

    warnedStyleValues[value] = true;

    error("Style property values shouldn't contain a semicolon. " + 'Try "%s: %s" instead.', name, value.replace(badStyleValueWithSemicolonPattern, ''));
  };

  var warnStyleValueIsNaN = function (name, value) {
    if (warnedForNaNValue) {
      return;
    }

    warnedForNaNValue = true;

    error('`NaN` is an invalid value for the `%s` css style property.', name);
  };

  var warnStyleValueIsInfinity = function (name, value) {
    if (warnedForInfinityValue) {
      return;
    }

    warnedForInfinityValue = true;

    error('`Infinity` is an invalid value for the `%s` css style property.', name);
  };

  warnValidStyle = function (name, value) {
    if (name.indexOf('-') > -1) {
      warnHyphenatedStyleName(name);
    } else if (badVendoredStyleNamePattern.test(name)) {
      warnBadVendoredStyleName(name);
    } else if (badStyleValueWithSemicolonPattern.test(value)) {
      warnStyleValueWithSemicolon(name, value);
    }

    if (typeof value === 'number') {
      if (isNaN(value)) {
        warnStyleValueIsNaN(name, value);
      } else if (!isFinite(value)) {
        warnStyleValueIsInfinity(name, value);
      }
    }
  };
}

var warnValidStyle$1 = warnValidStyle;

/**
 * Operations for dealing with CSS properties.
 */

/**
 * This creates a string that is expected to be equivalent to the style
 * attribute generated by server-side rendering. It by-passes warnings and
 * security checks so it's not safe to use this value for anything other than
 * comparison. It is only used in DEV for SSR validation.
 */

function createDangerousStringForStyles(styles) {
  {
    var serialized = '';
    var delimiter = '';

    for (var styleName in styles) {
      if (!styles.hasOwnProperty(styleName)) {
        continue;
      }

      var styleValue = styles[styleName];

      if (styleValue != null) {
        var isCustomProperty = styleName.indexOf('--') === 0;
        serialized += delimiter + (isCustomProperty ? styleName : hyphenateStyleName(styleName)) + ':';
        serialized += dangerousStyleValue(styleName, styleValue, isCustomProperty);
        delimiter = ';';
      }
    }

    return serialized || null;
  }
}
/**
 * Sets the value for multiple styles on a node.  If a value is specified as
 * '' (empty string), the corresponding style property will be unset.
 *
 * @param {DOMElement} node
 * @param {object} styles
 */

function setValueForStyles(node, styles) {
  var style = node.style;

  for (var styleName in styles) {
    if (!styles.hasOwnProperty(styleName)) {
      continue;
    }

    var isCustomProperty = styleName.indexOf('--') === 0;

    {
      if (!isCustomProperty) {
        warnValidStyle$1(styleName, styles[styleName]);
      }
    }

    var styleValue = dangerousStyleValue(styleName, styles[styleName], isCustomProperty);

    if (styleName === 'float') {
      styleName = 'cssFloat';
    }

    if (isCustomProperty) {
      style.setProperty(styleName, styleValue);
    } else {
      style[styleName] = styleValue;
    }
  }
}

function isValueEmpty(value) {
  return value == null || typeof value === 'boolean' || value === '';
}
/**
 * Given {color: 'red', overflow: 'hidden'} returns {
 *   color: 'color',
 *   overflowX: 'overflow',
 *   overflowY: 'overflow',
 * }. This can be read as "the overflowY property was set by the overflow
 * shorthand". That is, the values are the property that each was derived from.
 */


function expandShorthandMap(styles) {
  var expanded = {};

  for (var key in styles) {
    var longhands = shorthandToLonghand[key] || [key];

    for (var i = 0; i < longhands.length; i++) {
      expanded[longhands[i]] = key;
    }
  }

  return expanded;
}
/**
 * When mixing shorthand and longhand property names, we warn during updates if
 * we expect an incorrect result to occur. In particular, we warn for:
 *
 * Updating a shorthand property (longhand gets overwritten):
 *   {font: 'foo', fontVariant: 'bar'} -> {font: 'baz', fontVariant: 'bar'}
 *   becomes .style.font = 'baz'
 * Removing a shorthand property (longhand gets lost too):
 *   {font: 'foo', fontVariant: 'bar'} -> {fontVariant: 'bar'}
 *   becomes .style.font = ''
 * Removing a longhand property (should revert to shorthand; doesn't):
 *   {font: 'foo', fontVariant: 'bar'} -> {font: 'foo'}
 *   becomes .style.fontVariant = ''
 */


function validateShorthandPropertyCollisionInDev(styleUpdates, nextStyles) {
  {
    if (!nextStyles) {
      return;
    }

    var expandedUpdates = expandShorthandMap(styleUpdates);
    var expandedStyles = expandShorthandMap(nextStyles);
    var warnedAbout = {};

    for (var key in expandedUpdates) {
      var originalKey = expandedUpdates[key];
      var correctOriginalKey = expandedStyles[key];

      if (correctOriginalKey && originalKey !== correctOriginalKey) {
        var warningKey = originalKey + ',' + correctOriginalKey;

        if (warnedAbout[warningKey]) {
          continue;
        }

        warnedAbout[warningKey] = true;

        error('%s a style property during rerender (%s) when a ' + 'conflicting property is set (%s) can lead to styling bugs. To ' + "avoid this, don't mix shorthand and non-shorthand properties " + 'for the same value; instead, replace the shorthand with ' + 'separate values.', isValueEmpty(styleUpdates[originalKey]) ? 'Removing' : 'Updating', originalKey, correctOriginalKey);
      }
    }
  }
}

// For HTML, certain tags should omit their close tag. We keep a list for
// those special-case tags.
var omittedCloseTags = {
  area: true,
  base: true,
  br: true,
  col: true,
  embed: true,
  hr: true,
  img: true,
  input: true,
  keygen: true,
  link: true,
  meta: true,
  param: true,
  source: true,
  track: true,
  wbr: true // NOTE: menuitem's close tag should be omitted, but that causes problems.

};

// `omittedCloseTags` except that `menuitem` should still have its closing tag.

var voidElementTags = _assign({
  menuitem: true
}, omittedCloseTags);

var HTML = '__html';

function assertValidProps(tag, props) {
  if (!props) {
    return;
  } // Note the use of `==` which checks for null or undefined.


  if (voidElementTags[tag]) {
    if (!(props.children == null && props.dangerouslySetInnerHTML == null)) {
      {
        throw Error( tag + " is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`." );
      }
    }
  }

  if (props.dangerouslySetInnerHTML != null) {
    if (!(props.children == null)) {
      {
        throw Error( "Can only set one of `children` or `props.dangerouslySetInnerHTML`." );
      }
    }

    if (!(typeof props.dangerouslySetInnerHTML === 'object' && HTML in props.dangerouslySetInnerHTML)) {
      {
        throw Error( "`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://reactjs.org/link/dangerously-set-inner-html for more information." );
      }
    }
  }

  {
    if (!props.suppressContentEditableWarning && props.contentEditable && props.children != null) {
      error('A component is `contentEditable` and contains `children` managed by ' + 'React. It is now your responsibility to guarantee that none of ' + 'those nodes are unexpectedly modified or duplicated. This is ' + 'probably not intentional.');
    }
  }

  if (!(props.style == null || typeof props.style === 'object')) {
    {
      throw Error( "The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + 'em'}} when using JSX." );
    }
  }
}

function isCustomComponent(tagName, props) {
  if (tagName.indexOf('-') === -1) {
    return typeof props.is === 'string';
  }

  switch (tagName) {
    // These are reserved SVG and MathML elements.
    // We don't mind this list too much because we expect it to never grow.
    // The alternative is to track the namespace in a few places which is convoluted.
    // https://w3c.github.io/webcomponents/spec/custom/#custom-elements-core-concepts
    case 'annotation-xml':
    case 'color-profile':
    case 'font-face':
    case 'font-face-src':
    case 'font-face-uri':
    case 'font-face-format':
    case 'font-face-name':
    case 'missing-glyph':
      return false;

    default:
      return true;
  }
}

// When adding attributes to the HTML or SVG allowed attribute list, be sure to
// also add them to this module to ensure casing and incorrect name
// warnings.
var possibleStandardNames = {
  // HTML
  accept: 'accept',
  acceptcharset: 'acceptCharset',
  'accept-charset': 'acceptCharset',
  accesskey: 'accessKey',
  action: 'action',
  allowfullscreen: 'allowFullScreen',
  alt: 'alt',
  as: 'as',
  async: 'async',
  autocapitalize: 'autoCapitalize',
  autocomplete: 'autoComplete',
  autocorrect: 'autoCorrect',
  autofocus: 'autoFocus',
  autoplay: 'autoPlay',
  autosave: 'autoSave',
  capture: 'capture',
  cellpadding: 'cellPadding',
  cellspacing: 'cellSpacing',
  challenge: 'challenge',
  charset: 'charSet',
  checked: 'checked',
  children: 'children',
  cite: 'cite',
  class: 'className',
  classid: 'classID',
  classname: 'className',
  cols: 'cols',
  colspan: 'colSpan',
  content: 'content',
  contenteditable: 'contentEditable',
  contextmenu: 'contextMenu',
  controls: 'controls',
  controlslist: 'controlsList',
  coords: 'coords',
  crossorigin: 'crossOrigin',
  dangerouslysetinnerhtml: 'dangerouslySetInnerHTML',
  data: 'data',
  datetime: 'dateTime',
  default: 'default',
  defaultchecked: 'defaultChecked',
  defaultvalue: 'defaultValue',
  defer: 'defer',
  dir: 'dir',
  disabled: 'disabled',
  disablepictureinpicture: 'disablePictureInPicture',
  disableremoteplayback: 'disableRemotePlayback',
  download: 'download',
  draggable: 'draggable',
  enctype: 'encType',
  enterkeyhint: 'enterKeyHint',
  for: 'htmlFor',
  form: 'form',
  formmethod: 'formMethod',
  formaction: 'formAction',
  formenctype: 'formEncType',
  formnovalidate: 'formNoValidate',
  formtarget: 'formTarget',
  frameborder: 'frameBorder',
  headers: 'headers',
  height: 'height',
  hidden: 'hidden',
  high: 'high',
  href: 'href',
  hreflang: 'hrefLang',
  htmlfor: 'htmlFor',
  httpequiv: 'httpEquiv',
  'http-equiv': 'httpEquiv',
  icon: 'icon',
  id: 'id',
  innerhtml: 'innerHTML',
  inputmode: 'inputMode',
  integrity: 'integrity',
  is: 'is',
  itemid: 'itemID',
  itemprop: 'itemProp',
  itemref: 'itemRef',
  itemscope: 'itemScope',
  itemtype: 'itemType',
  keyparams: 'keyParams',
  keytype: 'keyType',
  kind: 'kind',
  label: 'label',
  lang: 'lang',
  list: 'list',
  loop: 'loop',
  low: 'low',
  manifest: 'manifest',
  marginwidth: 'marginWidth',
  marginheight: 'marginHeight',
  max: 'max',
  maxlength: 'maxLength',
  media: 'media',
  mediagroup: 'mediaGroup',
  method: 'method',
  min: 'min',
  minlength: 'minLength',
  multiple: 'multiple',
  muted: 'muted',
  name: 'name',
  nomodule: 'noModule',
  nonce: 'nonce',
  novalidate: 'noValidate',
  open: 'open',
  optimum: 'optimum',
  pattern: 'pattern',
  placeholder: 'placeholder',
  playsinline: 'playsInline',
  poster: 'poster',
  preload: 'preload',
  profile: 'profile',
  radiogroup: 'radioGroup',
  readonly: 'readOnly',
  referrerpolicy: 'referrerPolicy',
  rel: 'rel',
  required: 'required',
  reversed: 'reversed',
  role: 'role',
  rows: 'rows',
  rowspan: 'rowSpan',
  sandbox: 'sandbox',
  scope: 'scope',
  scoped: 'scoped',
  scrolling: 'scrolling',
  seamless: 'seamless',
  selected: 'selected',
  shape: 'shape',
  size: 'size',
  sizes: 'sizes',
  span: 'span',
  spellcheck: 'spellCheck',
  src: 'src',
  srcdoc: 'srcDoc',
  srclang: 'srcLang',
  srcset: 'srcSet',
  start: 'start',
  step: 'step',
  style: 'style',
  summary: 'summary',
  tabindex: 'tabIndex',
  target: 'target',
  title: 'title',
  type: 'type',
  usemap: 'useMap',
  value: 'value',
  width: 'width',
  wmode: 'wmode',
  wrap: 'wrap',
  // SVG
  about: 'about',
  accentheight: 'accentHeight',
  'accent-height': 'accentHeight',
  accumulate: 'accumulate',
  additive: 'additive',
  alignmentbaseline: 'alignmentBaseline',
  'alignment-baseline': 'alignmentBaseline',
  allowreorder: 'allowReorder',
  alphabetic: 'alphabetic',
  amplitude: 'amplitude',
  arabicform: 'arabicForm',
  'arabic-form': 'arabicForm',
  ascent: 'ascent',
  attributename: 'attributeName',
  attributetype: 'attributeType',
  autoreverse: 'autoReverse',
  azimuth: 'azimuth',
  basefrequency: 'baseFrequency',
  baselineshift: 'baselineShift',
  'baseline-shift': 'baselineShift',
  baseprofile: 'baseProfile',
  bbox: 'bbox',
  begin: 'begin',
  bias: 'bias',
  by: 'by',
  calcmode: 'calcMode',
  capheight: 'capHeight',
  'cap-height': 'capHeight',
  clip: 'clip',
  clippath: 'clipPath',
  'clip-path': 'clipPath',
  clippathunits: 'clipPathUnits',
  cliprule: 'clipRule',
  'clip-rule': 'clipRule',
  color: 'color',
  colorinterpolation: 'colorInterpolation',
  'color-interpolation': 'colorInterpolation',
  colorinterpolationfilters: 'colorInterpolationFilters',
  'color-interpolation-filters': 'colorInterpolationFilters',
  colorprofile: 'colorProfile',
  'color-profile': 'colorProfile',
  colorrendering: 'colorRendering',
  'color-rendering': 'colorRendering',
  contentscripttype: 'contentScriptType',
  contentstyletype: 'contentStyleType',
  cursor: 'cursor',
  cx: 'cx',
  cy: 'cy',
  d: 'd',
  datatype: 'datatype',
  decelerate: 'decelerate',
  descent: 'descent',
  diffuseconstant: 'diffuseConstant',
  direction: 'direction',
  display: 'display',
  divisor: 'divisor',
  dominantbaseline: 'dominantBaseline',
  'dominant-baseline': 'dominantBaseline',
  dur: 'dur',
  dx: 'dx',
  dy: 'dy',
  edgemode: 'edgeMode',
  elevation: 'elevation',
  enablebackground: 'enableBackground',
  'enable-background': 'enableBackground',
  end: 'end',
  exponent: 'exponent',
  externalresourcesrequired: 'externalResourcesRequired',
  fill: 'fill',
  fillopacity: 'fillOpacity',
  'fill-opacity': 'fillOpacity',
  fillrule: 'fillRule',
  'fill-rule': 'fillRule',
  filter: 'filter',
  filterres: 'filterRes',
  filterunits: 'filterUnits',
  floodopacity: 'floodOpacity',
  'flood-opacity': 'floodOpacity',
  floodcolor: 'floodColor',
  'flood-color': 'floodColor',
  focusable: 'focusable',
  fontfamily: 'fontFamily',
  'font-family': 'fontFamily',
  fontsize: 'fontSize',
  'font-size': 'fontSize',
  fontsizeadjust: 'fontSizeAdjust',
  'font-size-adjust': 'fontSizeAdjust',
  fontstretch: 'fontStretch',
  'font-stretch': 'fontStretch',
  fontstyle: 'fontStyle',
  'font-style': 'fontStyle',
  fontvariant: 'fontVariant',
  'font-variant': 'fontVariant',
  fontweight: 'fontWeight',
  'font-weight': 'fontWeight',
  format: 'format',
  from: 'from',
  fx: 'fx',
  fy: 'fy',
  g1: 'g1',
  g2: 'g2',
  glyphname: 'glyphName',
  'glyph-name': 'glyphName',
  glyphorientationhorizontal: 'glyphOrientationHorizontal',
  'glyph-orientation-horizontal': 'glyphOrientationHorizontal',
  glyphorientationvertical: 'glyphOrientationVertical',
  'glyph-orientation-vertical': 'glyphOrientationVertical',
  glyphref: 'glyphRef',
  gradienttransform: 'gradientTransform',
  gradientunits: 'gradientUnits',
  hanging: 'hanging',
  horizadvx: 'horizAdvX',
  'horiz-adv-x': 'horizAdvX',
  horizoriginx: 'horizOriginX',
  'horiz-origin-x': 'horizOriginX',
  ideographic: 'ideographic',
  imagerendering: 'imageRendering',
  'image-rendering': 'imageRendering',
  in2: 'in2',
  in: 'in',
  inlist: 'inlist',
  intercept: 'intercept',
  k1: 'k1',
  k2: 'k2',
  k3: 'k3',
  k4: 'k4',
  k: 'k',
  kernelmatrix: 'kernelMatrix',
  kernelunitlength: 'kernelUnitLength',
  kerning: 'kerning',
  keypoints: 'keyPoints',
  keysplines: 'keySplines',
  keytimes: 'keyTimes',
  lengthadjust: 'lengthAdjust',
  letterspacing: 'letterSpacing',
  'letter-spacing': 'letterSpacing',
  lightingcolor: 'lightingColor',
  'lighting-color': 'lightingColor',
  limitingconeangle: 'limitingConeAngle',
  local: 'local',
  markerend: 'markerEnd',
  'marker-end': 'markerEnd',
  markerheight: 'markerHeight',
  markermid: 'markerMid',
  'marker-mid': 'markerMid',
  markerstart: 'markerStart',
  'marker-start': 'markerStart',
  markerunits: 'markerUnits',
  markerwidth: 'markerWidth',
  mask: 'mask',
  maskcontentunits: 'maskContentUnits',
  maskunits: 'maskUnits',
  mathematical: 'mathematical',
  mode: 'mode',
  numoctaves: 'numOctaves',
  offset: 'offset',
  opacity: 'opacity',
  operator: 'operator',
  order: 'order',
  orient: 'orient',
  orientation: 'orientation',
  origin: 'origin',
  overflow: 'overflow',
  overlineposition: 'overlinePosition',
  'overline-position': 'overlinePosition',
  overlinethickness: 'overlineThickness',
  'overline-thickness': 'overlineThickness',
  paintorder: 'paintOrder',
  'paint-order': 'paintOrder',
  panose1: 'panose1',
  'panose-1': 'panose1',
  pathlength: 'pathLength',
  patterncontentunits: 'patternContentUnits',
  patterntransform: 'patternTransform',
  patternunits: 'patternUnits',
  pointerevents: 'pointerEvents',
  'pointer-events': 'pointerEvents',
  points: 'points',
  pointsatx: 'pointsAtX',
  pointsaty: 'pointsAtY',
  pointsatz: 'pointsAtZ',
  prefix: 'prefix',
  preservealpha: 'preserveAlpha',
  preserveaspectratio: 'preserveAspectRatio',
  primitiveunits: 'primitiveUnits',
  property: 'property',
  r: 'r',
  radius: 'radius',
  refx: 'refX',
  refy: 'refY',
  renderingintent: 'renderingIntent',
  'rendering-intent': 'renderingIntent',
  repeatcount: 'repeatCount',
  repeatdur: 'repeatDur',
  requiredextensions: 'requiredExtensions',
  requiredfeatures: 'requiredFeatures',
  resource: 'resource',
  restart: 'restart',
  result: 'result',
  results: 'results',
  rotate: 'rotate',
  rx: 'rx',
  ry: 'ry',
  scale: 'scale',
  security: 'security',
  seed: 'seed',
  shaperendering: 'shapeRendering',
  'shape-rendering': 'shapeRendering',
  slope: 'slope',
  spacing: 'spacing',
  specularconstant: 'specularConstant',
  specularexponent: 'specularExponent',
  speed: 'speed',
  spreadmethod: 'spreadMethod',
  startoffset: 'startOffset',
  stddeviation: 'stdDeviation',
  stemh: 'stemh',
  stemv: 'stemv',
  stitchtiles: 'stitchTiles',
  stopcolor: 'stopColor',
  'stop-color': 'stopColor',
  stopopacity: 'stopOpacity',
  'stop-opacity': 'stopOpacity',
  strikethroughposition: 'strikethroughPosition',
  'strikethrough-position': 'strikethroughPosition',
  strikethroughthickness: 'strikethroughThickness',
  'strikethrough-thickness': 'strikethroughThickness',
  string: 'string',
  stroke: 'stroke',
  strokedasharray: 'strokeDasharray',
  'stroke-dasharray': 'strokeDasharray',
  strokedashoffset: 'strokeDashoffset',
  'stroke-dashoffset': 'strokeDashoffset',
  strokelinecap: 'strokeLinecap',
  'stroke-linecap': 'strokeLinecap',
  strokelinejoin: 'strokeLinejoin',
  'stroke-linejoin': 'strokeLinejoin',
  strokemiterlimit: 'strokeMiterlimit',
  'stroke-miterlimit': 'strokeMiterlimit',
  strokewidth: 'strokeWidth',
  'stroke-width': 'strokeWidth',
  strokeopacity: 'strokeOpacity',
  'stroke-opacity': 'strokeOpacity',
  suppresscontenteditablewarning: 'suppressContentEditableWarning',
  suppresshydrationwarning: 'suppressHydrationWarning',
  surfacescale: 'surfaceScale',
  systemlanguage: 'systemLanguage',
  tablevalues: 'tableValues',
  targetx: 'targetX',
  targety: 'targetY',
  textanchor: 'textAnchor',
  'text-anchor': 'textAnchor',
  textdecoration: 'textDecoration',
  'text-decoration': 'textDecoration',
  textlength: 'textLength',
  textrendering: 'textRendering',
  'text-rendering': 'textRendering',
  to: 'to',
  transform: 'transform',
  typeof: 'typeof',
  u1: 'u1',
  u2: 'u2',
  underlineposition: 'underlinePosition',
  'underline-position': 'underlinePosition',
  underlinethickness: 'underlineThickness',
  'underline-thickness': 'underlineThickness',
  unicode: 'unicode',
  unicodebidi: 'unicodeBidi',
  'unicode-bidi': 'unicodeBidi',
  unicoderange: 'unicodeRange',
  'unicode-range': 'unicodeRange',
  unitsperem: 'unitsPerEm',
  'units-per-em': 'unitsPerEm',
  unselectable: 'unselectable',
  valphabetic: 'vAlphabetic',
  'v-alphabetic': 'vAlphabetic',
  values: 'values',
  vectoreffect: 'vectorEffect',
  'vector-effect': 'vectorEffect',
  version: 'version',
  vertadvy: 'vertAdvY',
  'vert-adv-y': 'vertAdvY',
  vertoriginx: 'vertOriginX',
  'vert-origin-x': 'vertOriginX',
  vertoriginy: 'vertOriginY',
  'vert-origin-y': 'vertOriginY',
  vhanging: 'vHanging',
  'v-hanging': 'vHanging',
  videographic: 'vIdeographic',
  'v-ideographic': 'vIdeographic',
  viewbox: 'viewBox',
  viewtarget: 'viewTarget',
  visibility: 'visibility',
  vmathematical: 'vMathematical',
  'v-mathematical': 'vMathematical',
  vocab: 'vocab',
  widths: 'widths',
  wordspacing: 'wordSpacing',
  'word-spacing': 'wordSpacing',
  writingmode: 'writingMode',
  'writing-mode': 'writingMode',
  x1: 'x1',
  x2: 'x2',
  x: 'x',
  xchannelselector: 'xChannelSelector',
  xheight: 'xHeight',
  'x-height': 'xHeight',
  xlinkactuate: 'xlinkActuate',
  'xlink:actuate': 'xlinkActuate',
  xlinkarcrole: 'xlinkArcrole',
  'xlink:arcrole': 'xlinkArcrole',
  xlinkhref: 'xlinkHref',
  'xlink:href': 'xlinkHref',
  xlinkrole: 'xlinkRole',
  'xlink:role': 'xlinkRole',
  xlinkshow: 'xlinkShow',
  'xlink:show': 'xlinkShow',
  xlinktitle: 'xlinkTitle',
  'xlink:title': 'xlinkTitle',
  xlinktype: 'xlinkType',
  'xlink:type': 'xlinkType',
  xmlbase: 'xmlBase',
  'xml:base': 'xmlBase',
  xmllang: 'xmlLang',
  'xml:lang': 'xmlLang',
  xmlns: 'xmlns',
  'xml:space': 'xmlSpace',
  xmlnsxlink: 'xmlnsXlink',
  'xmlns:xlink': 'xmlnsXlink',
  xmlspace: 'xmlSpace',
  y1: 'y1',
  y2: 'y2',
  y: 'y',
  ychannelselector: 'yChannelSelector',
  z: 'z',
  zoomandpan: 'zoomAndPan'
};

var ariaProperties = {
  'aria-current': 0,
  // state
  'aria-details': 0,
  'aria-disabled': 0,
  // state
  'aria-hidden': 0,
  // state
  'aria-invalid': 0,
  // state
  'aria-keyshortcuts': 0,
  'aria-label': 0,
  'aria-roledescription': 0,
  // Widget Attributes
  'aria-autocomplete': 0,
  'aria-checked': 0,
  'aria-expanded': 0,
  'aria-haspopup': 0,
  'aria-level': 0,
  'aria-modal': 0,
  'aria-multiline': 0,
  'aria-multiselectable': 0,
  'aria-orientation': 0,
  'aria-placeholder': 0,
  'aria-pressed': 0,
  'aria-readonly': 0,
  'aria-required': 0,
  'aria-selected': 0,
  'aria-sort': 0,
  'aria-valuemax': 0,
  'aria-valuemin': 0,
  'aria-valuenow': 0,
  'aria-valuetext': 0,
  // Live Region Attributes
  'aria-atomic': 0,
  'aria-busy': 0,
  'aria-live': 0,
  'aria-relevant': 0,
  // Drag-and-Drop Attributes
  'aria-dropeffect': 0,
  'aria-grabbed': 0,
  // Relationship Attributes
  'aria-activedescendant': 0,
  'aria-colcount': 0,
  'aria-colindex': 0,
  'aria-colspan': 0,
  'aria-controls': 0,
  'aria-describedby': 0,
  'aria-errormessage': 0,
  'aria-flowto': 0,
  'aria-labelledby': 0,
  'aria-owns': 0,
  'aria-posinset': 0,
  'aria-rowcount': 0,
  'aria-rowindex': 0,
  'aria-rowspan': 0,
  'aria-setsize': 0
};

var warnedProperties = {};
var rARIA = new RegExp('^(aria)-[' + ATTRIBUTE_NAME_CHAR + ']*$');
var rARIACamel = new RegExp('^(aria)[A-Z][' + ATTRIBUTE_NAME_CHAR + ']*$');
var hasOwnProperty$1 = Object.prototype.hasOwnProperty;

function validateProperty(tagName, name) {
  {
    if (hasOwnProperty$1.call(warnedProperties, name) && warnedProperties[name]) {
      return true;
    }

    if (rARIACamel.test(name)) {
      var ariaName = 'aria-' + name.slice(4).toLowerCase();
      var correctName = ariaProperties.hasOwnProperty(ariaName) ? ariaName : null; // If this is an aria-* attribute, but is not listed in the known DOM
      // DOM properties, then it is an invalid aria-* attribute.

      if (correctName == null) {
        error('Invalid ARIA attribute `%s`. ARIA attributes follow the pattern aria-* and must be lowercase.', name);

        warnedProperties[name] = true;
        return true;
      } // aria-* attributes should be lowercase; suggest the lowercase version.


      if (name !== correctName) {
        error('Invalid ARIA attribute `%s`. Did you mean `%s`?', name, correctName);

        warnedProperties[name] = true;
        return true;
      }
    }

    if (rARIA.test(name)) {
      var lowerCasedName = name.toLowerCase();
      var standardName = ariaProperties.hasOwnProperty(lowerCasedName) ? lowerCasedName : null; // If this is an aria-* attribute, but is not listed in the known DOM
      // DOM properties, then it is an invalid aria-* attribute.

      if (standardName == null) {
        warnedProperties[name] = true;
        return false;
      } // aria-* attributes should be lowercase; suggest the lowercase version.


      if (name !== standardName) {
        error('Unknown ARIA attribute `%s`. Did you mean `%s`?', name, standardName);

        warnedProperties[name] = true;
        return true;
      }
    }
  }

  return true;
}

function warnInvalidARIAProps(type, props) {
  {
    var invalidProps = [];

    for (var key in props) {
      var isValid = validateProperty(type, key);

      if (!isValid) {
        invalidProps.push(key);
      }
    }

    var unknownPropString = invalidProps.map(function (prop) {
      return '`' + prop + '`';
    }).join(', ');

    if (invalidProps.length === 1) {
      error('Invalid aria prop %s on <%s> tag. ' + 'For details, see https://reactjs.org/link/invalid-aria-props', unknownPropString, type);
    } else if (invalidProps.length > 1) {
      error('Invalid aria props %s on <%s> tag. ' + 'For details, see https://reactjs.org/link/invalid-aria-props', unknownPropString, type);
    }
  }
}

function validateProperties(type, props) {
  if (isCustomComponent(type, props)) {
    return;
  }

  warnInvalidARIAProps(type, props);
}

var didWarnValueNull = false;
function validateProperties$1(type, props) {
  {
    if (type !== 'input' && type !== 'textarea' && type !== 'select') {
      return;
    }

    if (props != null && props.value === null && !didWarnValueNull) {
      didWarnValueNull = true;

      if (type === 'select' && props.multiple) {
        error('`value` prop on `%s` should not be null. ' + 'Consider using an empty array when `multiple` is set to `true` ' + 'to clear the component or `undefined` for uncontrolled components.', type);
      } else {
        error('`value` prop on `%s` should not be null. ' + 'Consider using an empty string to clear the component or `undefined` ' + 'for uncontrolled components.', type);
      }
    }
  }
}

var validateProperty$1 = function () {};

{
  var warnedProperties$1 = {};
  var _hasOwnProperty = Object.prototype.hasOwnProperty;
  var EVENT_NAME_REGEX = /^on./;
  var INVALID_EVENT_NAME_REGEX = /^on[^A-Z]/;
  var rARIA$1 = new RegExp('^(aria)-[' + ATTRIBUTE_NAME_CHAR + ']*$');
  var rARIACamel$1 = new RegExp('^(aria)[A-Z][' + ATTRIBUTE_NAME_CHAR + ']*$');

  validateProperty$1 = function (tagName, name, value, eventRegistry) {
    if (_hasOwnProperty.call(warnedProperties$1, name) && warnedProperties$1[name]) {
      return true;
    }

    var lowerCasedName = name.toLowerCase();

    if (lowerCasedName === 'onfocusin' || lowerCasedName === 'onfocusout') {
      error('React uses onFocus and onBlur instead of onFocusIn and onFocusOut. ' + 'All React events are normalized to bubble, so onFocusIn and onFocusOut ' + 'are not needed/supported by React.');

      warnedProperties$1[name] = true;
      return true;
    } // We can't rely on the event system being injected on the server.


    if (eventRegistry != null) {
      var registrationNameDependencies = eventRegistry.registrationNameDependencies,
          possibleRegistrationNames = eventRegistry.possibleRegistrationNames;

      if (registrationNameDependencies.hasOwnProperty(name)) {
        return true;
      }

      var registrationName = possibleRegistrationNames.hasOwnProperty(lowerCasedName) ? possibleRegistrationNames[lowerCasedName] : null;

      if (registrationName != null) {
        error('Invalid event handler property `%s`. Did you mean `%s`?', name, registrationName);

        warnedProperties$1[name] = true;
        return true;
      }

      if (EVENT_NAME_REGEX.test(name)) {
        error('Unknown event handler property `%s`. It will be ignored.', name);

        warnedProperties$1[name] = true;
        return true;
      }
    } else if (EVENT_NAME_REGEX.test(name)) {
      // If no event plugins have been injected, we are in a server environment.
      // So we can't tell if the event name is correct for sure, but we can filter
      // out known bad ones like `onclick`. We can't suggest a specific replacement though.
      if (INVALID_EVENT_NAME_REGEX.test(name)) {
        error('Invalid event handler property `%s`. ' + 'React events use the camelCase naming convention, for example `onClick`.', name);
      }

      warnedProperties$1[name] = true;
      return true;
    } // Let the ARIA attribute hook validate ARIA attributes


    if (rARIA$1.test(name) || rARIACamel$1.test(name)) {
      return true;
    }

    if (lowerCasedName === 'innerhtml') {
      error('Directly setting property `innerHTML` is not permitted. ' + 'For more information, lookup documentation on `dangerouslySetInnerHTML`.');

      warnedProperties$1[name] = true;
      return true;
    }

    if (lowerCasedName === 'aria') {
      error('The `aria` attribute is reserved for future use in React. ' + 'Pass individual `aria-` attributes instead.');

      warnedProperties$1[name] = true;
      return true;
    }

    if (lowerCasedName === 'is' && value !== null && value !== undefined && typeof value !== 'string') {
      error('Received a `%s` for a string attribute `is`. If this is expected, cast ' + 'the value to a string.', typeof value);

      warnedProperties$1[name] = true;
      return true;
    }

    if (typeof value === 'number' && isNaN(value)) {
      error('Received NaN for the `%s` attribute. If this is expected, cast ' + 'the value to a string.', name);

      warnedProperties$1[name] = true;
      return true;
    }

    var propertyInfo = getPropertyInfo(name);
    var isReserved = propertyInfo !== null && propertyInfo.type === RESERVED; // Known attributes should match the casing specified in the property config.

    if (possibleStandardNames.hasOwnProperty(lowerCasedName)) {
      var standardName = possibleStandardNames[lowerCasedName];

      if (standardName !== name) {
        error('Invalid DOM property `%s`. Did you mean `%s`?', name, standardName);

        warnedProperties$1[name] = true;
        return true;
      }
    } else if (!isReserved && name !== lowerCasedName) {
      // Unknown attributes should have lowercase casing since that's how they
      // will be cased anyway with server rendering.
      error('React does not recognize the `%s` prop on a DOM element. If you ' + 'intentionally want it to appear in the DOM as a custom ' + 'attribute, spell it as lowercase `%s` instead. ' + 'If you accidentally passed it from a parent component, remove ' + 'it from the DOM element.', name, lowerCasedName);

      warnedProperties$1[name] = true;
      return true;
    }

    if (typeof value === 'boolean' && shouldRemoveAttributeWithWarning(name, value, propertyInfo, false)) {
      if (value) {
        error('Received `%s` for a non-boolean attribute `%s`.\n\n' + 'If you want to write it to the DOM, pass a string instead: ' + '%s="%s" or %s={value.toString()}.', value, name, name, value, name);
      } else {
        error('Received `%s` for a non-boolean attribute `%s`.\n\n' + 'If you want to write it to the DOM, pass a string instead: ' + '%s="%s" or %s={value.toString()}.\n\n' + 'If you used to conditionally omit it with %s={condition && value}, ' + 'pass %s={condition ? value : undefined} instead.', value, name, name, value, name, name, name);
      }

      warnedProperties$1[name] = true;
      return true;
    } // Now that we've validated casing, do not validate
    // data types for reserved props


    if (isReserved) {
      return true;
    } // Warn when a known attribute is a bad type


    if (shouldRemoveAttributeWithWarning(name, value, propertyInfo, false)) {
      warnedProperties$1[name] = true;
      return false;
    } // Warn when passing the strings 'false' or 'true' into a boolean prop


    if ((value === 'false' || value === 'true') && propertyInfo !== null && propertyInfo.type === BOOLEAN) {
      error('Received the string `%s` for the boolean attribute `%s`. ' + '%s ' + 'Did you mean %s={%s}?', value, name, value === 'false' ? 'The browser will interpret it as a truthy value.' : 'Although this works, it will not work as expected if you pass the string "false".', name, value);

      warnedProperties$1[name] = true;
      return true;
    }

    return true;
  };
}

var warnUnknownProperties = function (type, props, eventRegistry) {
  {
    var unknownProps = [];

    for (var key in props) {
      var isValid = validateProperty$1(type, key, props[key], eventRegistry);

      if (!isValid) {
        unknownProps.push(key);
      }
    }

    var unknownPropString = unknownProps.map(function (prop) {
      return '`' + prop + '`';
    }).join(', ');

    if (unknownProps.length === 1) {
      error('Invalid value for prop %s on <%s> tag. Either remove it from the element, ' + 'or pass a string or number value to keep it in the DOM. ' + 'For details, see https://reactjs.org/link/attribute-behavior ', unknownPropString, type);
    } else if (unknownProps.length > 1) {
      error('Invalid values for props %s on <%s> tag. Either remove them from the element, ' + 'or pass a string or number value to keep them in the DOM. ' + 'For details, see https://reactjs.org/link/attribute-behavior ', unknownPropString, type);
    }
  }
};

function validateProperties$2(type, props, eventRegistry) {
  if (isCustomComponent(type, props)) {
    return;
  }

  warnUnknownProperties(type, props, eventRegistry);
}

var IS_EVENT_HANDLE_NON_MANAGED_NODE = 1;
var IS_NON_DELEGATED = 1 << 1;
var IS_CAPTURE_PHASE = 1 << 2;
var IS_REPLAYED = 1 << 4;
// set to LEGACY_FB_SUPPORT. LEGACY_FB_SUPPORT only gets set when
// we call willDeferLaterForLegacyFBSupport, thus not bailing out
// will result in endless cycles like an infinite loop.
// We also don't want to defer during event replaying.

var SHOULD_NOT_PROCESS_POLYFILL_EVENT_PLUGINS = IS_EVENT_HANDLE_NON_MANAGED_NODE | IS_NON_DELEGATED | IS_CAPTURE_PHASE;

/**
 * Gets the target node from a native browser event by accounting for
 * inconsistencies in browser DOM APIs.
 *
 * @param {object} nativeEvent Native browser event.
 * @return {DOMEventTarget} Target node.
 */

function getEventTarget(nativeEvent) {
  // Fallback to nativeEvent.srcElement for IE9
  // https://github.com/facebook/react/issues/12506
  var target = nativeEvent.target || nativeEvent.srcElement || window; // Normalize SVG <use> element events #4963

  if (target.correspondingUseElement) {
    target = target.correspondingUseElement;
  } // Safari may fire events on text nodes (Node.TEXT_NODE is 3).
  // @see http://www.quirksmode.org/js/events_properties.html


  return target.nodeType === TEXT_NODE ? target.parentNode : target;
}

var restoreImpl = null;
var restoreTarget = null;
var restoreQueue = null;

function restoreStateOfTarget(target) {
  // We perform this translation at the end of the event loop so that we
  // always receive the correct fiber here
  var internalInstance = getInstanceFromNode(target);

  if (!internalInstance) {
    // Unmounted
    return;
  }

  if (!(typeof restoreImpl === 'function')) {
    {
      throw Error( "setRestoreImplementation() needs to be called to handle a target for controlled events. This error is likely caused by a bug in React. Please file an issue." );
    }
  }

  var stateNode = internalInstance.stateNode; // Guard against Fiber being unmounted.

  if (stateNode) {
    var _props = getFiberCurrentPropsFromNode(stateNode);

    restoreImpl(internalInstance.stateNode, internalInstance.type, _props);
  }
}

function setRestoreImplementation(impl) {
  restoreImpl = impl;
}
function enqueueStateRestore(target) {
  if (restoreTarget) {
    if (restoreQueue) {
      restoreQueue.push(target);
    } else {
      restoreQueue = [target];
    }
  } else {
    restoreTarget = target;
  }
}
function needsStateRestore() {
  return restoreTarget !== null || restoreQueue !== null;
}
function restoreStateIfNeeded() {
  if (!restoreTarget) {
    return;
  }

  var target = restoreTarget;
  var queuedTargets = restoreQueue;
  restoreTarget = null;
  restoreQueue = null;
  restoreStateOfTarget(target);

  if (queuedTargets) {
    for (var i = 0; i < queuedTargets.length; i++) {
      restoreStateOfTarget(queuedTargets[i]);
    }
  }
}

// the renderer. Such as when we're dispatching events or if third party
// libraries need to call batchedUpdates. Eventually, this API will go away when
// everything is batched by default. We'll then have a similar API to opt-out of
// scheduled work and instead do synchronous work.
// Defaults

var batchedUpdatesImpl = function (fn, bookkeeping) {
  return fn(bookkeeping);
};

var discreteUpdatesImpl = function (fn, a, b, c, d) {
  return fn(a, b, c, d);
};

var flushDiscreteUpdatesImpl = function () {};

var batchedEventUpdatesImpl = batchedUpdatesImpl;
var isInsideEventHandler = false;
var isBatchingEventUpdates = false;

function finishEventHandler() {
  // Here we wait until all updates have propagated, which is important
  // when using controlled components within layers:
  // https://github.com/facebook/react/issues/1698
  // Then we restore state of any controlled component.
  var controlledComponentsHavePendingUpdates = needsStateRestore();

  if (controlledComponentsHavePendingUpdates) {
    // If a controlled event was fired, we may need to restore the state of
    // the DOM node back to the controlled value. This is necessary when React
    // bails out of the update without touching the DOM.
    flushDiscreteUpdatesImpl();
    restoreStateIfNeeded();
  }
}

function batchedUpdates(fn, bookkeeping) {
  if (isInsideEventHandler) {
    // If we are currently inside another batch, we need to wait until it
    // fully completes before restoring state.
    return fn(bookkeeping);
  }

  isInsideEventHandler = true;

  try {
    return batchedUpdatesImpl(fn, bookkeeping);
  } finally {
    isInsideEventHandler = false;
    finishEventHandler();
  }
}
function batchedEventUpdates(fn, a, b) {
  if (isBatchingEventUpdates) {
    // If we are currently inside another batch, we need to wait until it
    // fully completes before restoring state.
    return fn(a, b);
  }

  isBatchingEventUpdates = true;

  try {
    return batchedEventUpdatesImpl(fn, a, b);
  } finally {
    isBatchingEventUpdates = false;
    finishEventHandler();
  }
}
function discreteUpdates(fn, a, b, c, d) {
  var prevIsInsideEventHandler = isInsideEventHandler;
  isInsideEventHandler = true;

  try {
    return discreteUpdatesImpl(fn, a, b, c, d);
  } finally {
    isInsideEventHandler = prevIsInsideEventHandler;

    if (!isInsideEventHandler) {
      finishEventHandler();
    }
  }
}
function flushDiscreteUpdatesIfNeeded(timeStamp) {
  {
    if (!isInsideEventHandler) {
      flushDiscreteUpdatesImpl();
    }
  }
}
function setBatchingImplementation(_batchedUpdatesImpl, _discreteUpdatesImpl, _flushDiscreteUpdatesImpl, _batchedEventUpdatesImpl) {
  batchedUpdatesImpl = _batchedUpdatesImpl;
  discreteUpdatesImpl = _discreteUpdatesImpl;
  flushDiscreteUpdatesImpl = _flushDiscreteUpdatesImpl;
  batchedEventUpdatesImpl = _batchedEventUpdatesImpl;
}

function isInteractive(tag) {
  return tag === 'button' || tag === 'input' || tag === 'select' || tag === 'textarea';
}

function shouldPreventMouseEvent(name, type, props) {
  switch (name) {
    case 'onClick':
    case 'onClickCapture':
    case 'onDoubleClick':
    case 'onDoubleClickCapture':
    case 'onMouseDown':
    case 'onMouseDownCapture':
    case 'onMouseMove':
    case 'onMouseMoveCapture':
    case 'onMouseUp':
    case 'onMouseUpCapture':
    case 'onMouseEnter':
      return !!(props.disabled && isInteractive(type));

    default:
      return false;
  }
}
/**
 * @param {object} inst The instance, which is the source of events.
 * @param {string} registrationName Name of listener (e.g. `onClick`).
 * @return {?function} The stored callback.
 */


function getListener(inst, registrationName) {
  var stateNode = inst.stateNode;

  if (stateNode === null) {
    // Work in progress (ex: onload events in incremental mode).
    return null;
  }

  var props = getFiberCurrentPropsFromNode(stateNode);

  if (props === null) {
    // Work in progress.
    return null;
  }

  var listener = props[registrationName];

  if (shouldPreventMouseEvent(registrationName, inst.type, props)) {
    return null;
  }

  if (!(!listener || typeof listener === 'function')) {
    {
      throw Error( "Expected `" + registrationName + "` listener to be a function, instead got a value of `" + typeof listener + "` type." );
    }
  }

  return listener;
}

var passiveBrowserEventsSupported = false; // Check if browser support events with passive listeners
// https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener#Safely_detecting_option_support

if (canUseDOM) {
  try {
    var options = {}; // $FlowFixMe: Ignore Flow complaining about needing a value

    Object.defineProperty(options, 'passive', {
      get: function () {
        passiveBrowserEventsSupported = true;
      }
    });
    window.addEventListener('test', options, options);
    window.removeEventListener('test', options, options);
  } catch (e) {
    passiveBrowserEventsSupported = false;
  }
}

function invokeGuardedCallbackProd(name, func, context, a, b, c, d, e, f) {
  var funcArgs = Array.prototype.slice.call(arguments, 3);

  try {
    func.apply(context, funcArgs);
  } catch (error) {
    this.onError(error);
  }
}

var invokeGuardedCallbackImpl = invokeGuardedCallbackProd;

{
  // In DEV mode, we swap out invokeGuardedCallback for a special version
  // that plays more nicely with the browser's DevTools. The idea is to preserve
  // "Pause on exceptions" behavior. Because React wraps all user-provided
  // functions in invokeGuardedCallback, and the production version of
  // invokeGuardedCallback uses a try-catch, all user exceptions are treated
  // like caught exceptions, and the DevTools won't pause unless the developer
  // takes the extra step of enabling pause on caught exceptions. This is
  // unintuitive, though, because even though React has caught the error, from
  // the developer's perspective, the error is uncaught.
  //
  // To preserve the expected "Pause on exceptions" behavior, we don't use a
  // try-catch in DEV. Instead, we synchronously dispatch a fake event to a fake
  // DOM node, and call the user-provided callback from inside an event handler
  // for that fake event. If the callback throws, the error is "captured" using
  // a global event handler. But because the error happens in a different
  // event loop context, it does not interrupt the normal program flow.
  // Effectively, this gives us try-catch behavior without actually using
  // try-catch. Neat!
  // Check that the browser supports the APIs we need to implement our special
  // DEV version of invokeGuardedCallback
  if (typeof window !== 'undefined' && typeof window.dispatchEvent === 'function' && typeof document !== 'undefined' && typeof document.createEvent === 'function') {
    var fakeNode = document.createElement('react');

    invokeGuardedCallbackImpl = function invokeGuardedCallbackDev(name, func, context, a, b, c, d, e, f) {
      // If document doesn't exist we know for sure we will crash in this method
      // when we call document.createEvent(). However this can cause confusing
      // errors: https://github.com/facebookincubator/create-react-app/issues/3482
      // So we preemptively throw with a better message instead.
      if (!(typeof document !== 'undefined')) {
        {
          throw Error( "The `document` global was defined when React was initialized, but is not defined anymore. This can happen in a test environment if a component schedules an update from an asynchronous callback, but the test has already finished running. To solve this, you can either unmount the component at the end of your test (and ensure that any asynchronous operations get canceled in `componentWillUnmount`), or you can change the test itself to be asynchronous." );
        }
      }

      var evt = document.createEvent('Event');
      var didCall = false; // Keeps track of whether the user-provided callback threw an error. We
      // set this to true at the beginning, then set it to false right after
      // calling the function. If the function errors, `didError` will never be
      // set to false. This strategy works even if the browser is flaky and
      // fails to call our global error handler, because it doesn't rely on
      // the error event at all.

      var didError = true; // Keeps track of the value of window.event so that we can reset it
      // during the callback to let user code access window.event in the
      // browsers that support it.

      var windowEvent = window.event; // Keeps track of the descriptor of window.event to restore it after event
      // dispatching: https://github.com/facebook/react/issues/13688

      var windowEventDescriptor = Object.getOwnPropertyDescriptor(window, 'event');

      function restoreAfterDispatch() {
        // We immediately remove the callback from event listeners so that
        // nested `invokeGuardedCallback` calls do not clash. Otherwise, a
        // nested call would trigger the fake event handlers of any call higher
        // in the stack.
        fakeNode.removeEventListener(evtType, callCallback, false); // We check for window.hasOwnProperty('event') to prevent the
        // window.event assignment in both IE <= 10 as they throw an error
        // "Member not found" in strict mode, and in Firefox which does not
        // support window.event.

        if (typeof window.event !== 'undefined' && window.hasOwnProperty('event')) {
          window.event = windowEvent;
        }
      } // Create an event handler for our fake event. We will synchronously
      // dispatch our fake event using `dispatchEvent`. Inside the handler, we
      // call the user-provided callback.


      var funcArgs = Array.prototype.slice.call(arguments, 3);

      function callCallback() {
        didCall = true;
        restoreAfterDispatch();
        func.apply(context, funcArgs);
        didError = false;
      } // Create a global error event handler. We use this to capture the value
      // that was thrown. It's possible that this error handler will fire more
      // than once; for example, if non-React code also calls `dispatchEvent`
      // and a handler for that event throws. We should be resilient to most of
      // those cases. Even if our error event handler fires more than once, the
      // last error event is always used. If the callback actually does error,
      // we know that the last error event is the correct one, because it's not
      // possible for anything else to have happened in between our callback
      // erroring and the code that follows the `dispatchEvent` call below. If
      // the callback doesn't error, but the error event was fired, we know to
      // ignore it because `didError` will be false, as described above.


      var error; // Use this to track whether the error event is ever called.

      var didSetError = false;
      var isCrossOriginError = false;

      function handleWindowError(event) {
        error = event.error;
        didSetError = true;

        if (error === null && event.colno === 0 && event.lineno === 0) {
          isCrossOriginError = true;
        }

        if (event.defaultPrevented) {
          // Some other error handler has prevented default.
          // Browsers silence the error report if this happens.
          // We'll remember this to later decide whether to log it or not.
          if (error != null && typeof error === 'object') {
            try {
              error._suppressLogging = true;
            } catch (inner) {// Ignore.
            }
          }
        }
      } // Create a fake event type.


      var evtType = "react-" + (name ? name : 'invokeguardedcallback'); // Attach our event handlers

      window.addEventListener('error', handleWindowError);
      fakeNode.addEventListener(evtType, callCallback, false); // Synchronously dispatch our fake event. If the user-provided function
      // errors, it will trigger our global error handler.

      evt.initEvent(evtType, false, false);
      fakeNode.dispatchEvent(evt);

      if (windowEventDescriptor) {
        Object.defineProperty(window, 'event', windowEventDescriptor);
      }

      if (didCall && didError) {
        if (!didSetError) {
          // The callback errored, but the error event never fired.
          error = new Error('An error was thrown inside one of your components, but React ' + "doesn't know what it was. This is likely due to browser " + 'flakiness. React does its best to preserve the "Pause on ' + 'exceptions" behavior of the DevTools, which requires some ' + "DEV-mode only tricks. It's possible that these don't work in " + 'your browser. Try triggering the error in production mode, ' + 'or switching to a modern browser. If you suspect that this is ' + 'actually an issue with React, please file an issue.');
        } else if (isCrossOriginError) {
          error = new Error("A cross-origin error was thrown. React doesn't have access to " + 'the actual error object in development. ' + 'See https://reactjs.org/link/crossorigin-error for more information.');
        }

        this.onError(error);
      } // Remove our event listeners


      window.removeEventListener('error', handleWindowError);

      if (!didCall) {
        // Something went really wrong, and our event was not dispatched.
        // https://github.com/facebook/react/issues/16734
        // https://github.com/facebook/react/issues/16585
        // Fall back to the production implementation.
        restoreAfterDispatch();
        return invokeGuardedCallbackProd.apply(this, arguments);
      }
    };
  }
}

var invokeGuardedCallbackImpl$1 = invokeGuardedCallbackImpl;

var hasError = false;
var caughtError = null; // Used by event system to capture/rethrow the first error.

var hasRethrowError = false;
var rethrowError = null;
var reporter = {
  onError: function (error) {
    hasError = true;
    caughtError = error;
  }
};
/**
 * Call a function while guarding against errors that happens within it.
 * Returns an error if it throws, otherwise null.
 *
 * In production, this is implemented using a try-catch. The reason we don't
 * use a try-catch directly is so that we can swap out a different
 * implementation in DEV mode.
 *
 * @param {String} name of the guard to use for logging or debugging
 * @param {Function} func The function to invoke
 * @param {*} context The context to use when calling the function
 * @param {...*} args Arguments for function
 */

function invokeGuardedCallback(name, func, context, a, b, c, d, e, f) {
  hasError = false;
  caughtError = null;
  invokeGuardedCallbackImpl$1.apply(reporter, arguments);
}
/**
 * Same as invokeGuardedCallback, but instead of returning an error, it stores
 * it in a global so it can be rethrown by `rethrowCaughtError` later.
 * TODO: See if caughtError and rethrowError can be unified.
 *
 * @param {String} name of the guard to use for logging or debugging
 * @param {Function} func The function to invoke
 * @param {*} context The context to use when calling the function
 * @param {...*} args Arguments for function
 */

function invokeGuardedCallbackAndCatchFirstError(name, func, context, a, b, c, d, e, f) {
  invokeGuardedCallback.apply(this, arguments);

  if (hasError) {
    var error = clearCaughtError();

    if (!hasRethrowError) {
      hasRethrowError = true;
      rethrowError = error;
    }
  }
}
/**
 * During execution of guarded functions we will capture the first error which
 * we will rethrow to be handled by the top level error handler.
 */

function rethrowCaughtError() {
  if (hasRethrowError) {
    var error = rethrowError;
    hasRethrowError = false;
    rethrowError = null;
    throw error;
  }
}
function hasCaughtError() {
  return hasError;
}
function clearCaughtError() {
  if (hasError) {
    var error = caughtError;
    hasError = false;
    caughtError = null;
    return error;
  } else {
    {
      {
        throw Error( "clearCaughtError was called but no error was captured. This error is likely caused by a bug in React. Please file an issue." );
      }
    }
  }
}

/**
 * `ReactInstanceMap` maintains a mapping from a public facing stateful
 * instance (key) and the internal representation (value). This allows public
 * methods to accept the user facing instance as an argument and map them back
 * to internal methods.
 *
 * Note that this module is currently shared and assumed to be stateless.
 * If this becomes an actual Map, that will break.
 */
function get(key) {
  return key._reactInternals;
}
function has(key) {
  return key._reactInternals !== undefined;
}
function set(key, value) {
  key._reactInternals = value;
}

// Don't change these two values. They're used by React Dev Tools.
var NoFlags =
/*                      */
0;
var PerformedWork =
/*                */
1; // You can change the rest (and add more).

var Placement =
/*                    */
2;
var Update =
/*                       */
4;
var PlacementAndUpdate =
/*           */
6;
var Deletion =
/*                     */
8;
var ContentReset =
/*                 */
16;
var Callback =
/*                     */
32;
var DidCapture =
/*                   */
64;
var Ref =
/*                          */
128;
var Snapshot =
/*                     */
256;
var Passive =
/*                      */
512; // TODO (effects) Remove this bit once the new reconciler is synced to the old.

var PassiveUnmountPendingDev =
/*     */
8192;
var Hydrating =
/*                    */
1024;
var HydratingAndUpdate =
/*           */
1028; // Passive & Update & Callback & Ref & Snapshot

var LifecycleEffectMask =
/*          */
932; // Union of all host effects

var HostEffectMask =
/*               */
2047; // These are not really side effects, but we still reuse this field.

var Incomplete =
/*                   */
2048;
var ShouldCapture =
/*                */
4096;
var ForceUpdateForLegacySuspense =
/* */
16384; // Static tags describe aspects of a fiber that are not specific to a render,

var ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;
function getNearestMountedFiber(fiber) {
  var node = fiber;
  var nearestMounted = fiber;

  if (!fiber.alternate) {
    // If there is no alternate, this might be a new tree that isn't inserted
    // yet. If it is, then it will have a pending insertion effect on it.
    var nextNode = node;

    do {
      node = nextNode;

      if ((node.flags & (Placement | Hydrating)) !== NoFlags) {
        // This is an insertion or in-progress hydration. The nearest possible
        // mounted fiber is the parent but we need to continue to figure out
        // if that one is still mounted.
        nearestMounted = node.return;
      }

      nextNode = node.return;
    } while (nextNode);
  } else {
    while (node.return) {
      node = node.return;
    }
  }

  if (node.tag === HostRoot) {
    // TODO: Check if this was a nested HostRoot when used with
    // renderContainerIntoSubtree.
    return nearestMounted;
  } // If we didn't hit the root, that means that we're in an disconnected tree
  // that has been unmounted.


  return null;
}
function getSuspenseInstanceFromFiber(fiber) {
  if (fiber.tag === SuspenseComponent) {
    var suspenseState = fiber.memoizedState;

    if (suspenseState === null) {
      var current = fiber.alternate;

      if (current !== null) {
        suspenseState = current.memoizedState;
      }
    }

    if (suspenseState !== null) {
      return suspenseState.dehydrated;
    }
  }

  return null;
}
function getContainerFromFiber(fiber) {
  return fiber.tag === HostRoot ? fiber.stateNode.containerInfo : null;
}
function isFiberMounted(fiber) {
  return getNearestMountedFiber(fiber) === fiber;
}
function isMounted(component) {
  {
    var owner = ReactCurrentOwner.current;

    if (owner !== null && owner.tag === ClassComponent) {
      var ownerFiber = owner;
      var instance = ownerFiber.stateNode;

      if (!instance._warnedAboutRefsInRender) {
        error('%s is accessing isMounted inside its render() function. ' + 'render() should be a pure function of props and state. It should ' + 'never access something that requires stale data from the previous ' + 'render, such as refs. Move this logic to componentDidMount and ' + 'componentDidUpdate instead.', getComponentName(ownerFiber.type) || 'A component');
      }

      instance._warnedAboutRefsInRender = true;
    }
  }

  var fiber = get(component);

  if (!fiber) {
    return false;
  }

  return getNearestMountedFiber(fiber) === fiber;
}

function assertIsMounted(fiber) {
  if (!(getNearestMountedFiber(fiber) === fiber)) {
    {
      throw Error( "Unable to find node on an unmounted component." );
    }
  }
}

function findCurrentFiberUsingSlowPath(fiber) {
  var alternate = fiber.alternate;

  if (!alternate) {
    // If there is no alternate, then we only need to check if it is mounted.
    var nearestMounted = getNearestMountedFiber(fiber);

    if (!(nearestMounted !== null)) {
      {
        throw Error( "Unable to find node on an unmounted component." );
      }
    }

    if (nearestMounted !== fiber) {
      return null;
    }

    return fiber;
  } // If we have two possible branches, we'll walk backwards up to the root
  // to see what path the root points to. On the way we may hit one of the
  // special cases and we'll deal with them.


  var a = fiber;
  var b = alternate;

  while (true) {
    var parentA = a.return;

    if (parentA === null) {
      // We're at the root.
      break;
    }

    var parentB = parentA.alternate;

    if (parentB === null) {
      // There is no alternate. This is an unusual case. Currently, it only
      // happens when a Suspense component is hidden. An extra fragment fiber
      // is inserted in between the Suspense fiber and its children. Skip
      // over this extra fragment fiber and proceed to the next parent.
      var nextParent = parentA.return;

      if (nextParent !== null) {
        a = b = nextParent;
        continue;
      } // If there's no parent, we're at the root.


      break;
    } // If both copies of the parent fiber point to the same child, we can
    // assume that the child is current. This happens when we bailout on low
    // priority: the bailed out fiber's child reuses the current child.


    if (parentA.child === parentB.child) {
      var child = parentA.child;

      while (child) {
        if (child === a) {
          // We've determined that A is the current branch.
          assertIsMounted(parentA);
          return fiber;
        }

        if (child === b) {
          // We've determined that B is the current branch.
          assertIsMounted(parentA);
          return alternate;
        }

        child = child.sibling;
      } // We should never have an alternate for any mounting node. So the only
      // way this could possibly happen is if this was unmounted, if at all.


      {
        {
          throw Error( "Unable to find node on an unmounted component." );
        }
      }
    }

    if (a.return !== b.return) {
      // The return pointer of A and the return pointer of B point to different
      // fibers. We assume that return pointers never criss-cross, so A must
      // belong to the child set of A.return, and B must belong to the child
      // set of B.return.
      a = parentA;
      b = parentB;
    } else {
      // The return pointers point to the same fiber. We'll have to use the
      // default, slow path: scan the child sets of each parent alternate to see
      // which child belongs to which set.
      //
      // Search parent A's child set
      var didFindChild = false;
      var _child = parentA.child;

      while (_child) {
        if (_child === a) {
          didFindChild = true;
          a = parentA;
          b = parentB;
          break;
        }

        if (_child === b) {
          didFindChild = true;
          b = parentA;
          a = parentB;
          break;
        }

        _child = _child.sibling;
      }

      if (!didFindChild) {
        // Search parent B's child set
        _child = parentB.child;

        while (_child) {
          if (_child === a) {
            didFindChild = true;
            a = parentB;
            b = parentA;
            break;
          }

          if (_child === b) {
            didFindChild = true;
            b = parentB;
            a = parentA;
            break;
          }

          _child = _child.sibling;
        }

        if (!didFindChild) {
          {
            throw Error( "Child was not found in either parent set. This indicates a bug in React related to the return pointer. Please file an issue." );
          }
        }
      }
    }

    if (!(a.alternate === b)) {
      {
        throw Error( "Return fibers should always be each others' alternates. This error is likely caused by a bug in React. Please file an issue." );
      }
    }
  } // If the root is not a host container, we're in a disconnected tree. I.e.
  // unmounted.


  if (!(a.tag === HostRoot)) {
    {
      throw Error( "Unable to find node on an unmounted component." );
    }
  }

  if (a.stateNode.current === a) {
    // We've determined that A is the current branch.
    return fiber;
  } // Otherwise B has to be current branch.


  return alternate;
}
function findCurrentHostFiber(parent) {
  var currentParent = findCurrentFiberUsingSlowPath(parent);

  if (!currentParent) {
    return null;
  } // Next we'll drill down this component to find the first HostComponent/Text.


  var node = currentParent;

  while (true) {
    if (node.tag === HostComponent || node.tag === HostText) {
      return node;
    } else if (node.child) {
      node.child.return = node;
      node = node.child;
      continue;
    }

    if (node === currentParent) {
      return null;
    }

    while (!node.sibling) {
      if (!node.return || node.return === currentParent) {
        return null;
      }

      node = node.return;
    }

    node.sibling.return = node.return;
    node = node.sibling;
  } // Flow needs the return null here, but ESLint complains about it.
  // eslint-disable-next-line no-unreachable


  return null;
}
function findCurrentHostFiberWithNoPortals(parent) {
  var currentParent = findCurrentFiberUsingSlowPath(parent);

  if (!currentParent) {
    return null;
  } // Next we'll drill down this component to find the first HostComponent/Text.


  var node = currentParent;

  while (true) {
    if (node.tag === HostComponent || node.tag === HostText || enableFundamentalAPI ) {
      return node;
    } else if (node.child && node.tag !== HostPortal) {
      node.child.return = node;
      node = node.child;
      continue;
    }

    if (node === currentParent) {
      return null;
    }

    while (!node.sibling) {
      if (!node.return || node.return === currentParent) {
        return null;
      }

      node = node.return;
    }

    node.sibling.return = node.return;
    node = node.sibling;
  } // Flow needs the return null here, but ESLint complains about it.
  // eslint-disable-next-line no-unreachable


  return null;
}
function doesFiberContain(parentFiber, childFiber) {
  var node = childFiber;
  var parentFiberAlternate = parentFiber.alternate;

  while (node !== null) {
    if (node === parentFiber || node === parentFiberAlternate) {
      return true;
    }

    node = node.return;
  }

  return false;
}

var attemptUserBlockingHydration;
function setAttemptUserBlockingHydration(fn) {
  attemptUserBlockingHydration = fn;
}
var attemptContinuousHydration;
function setAttemptContinuousHydration(fn) {
  attemptContinuousHydration = fn;
}
var attemptHydrationAtCurrentPriority;
function setAttemptHydrationAtCurrentPriority(fn) {
  attemptHydrationAtCurrentPriority = fn;
}
var attemptHydrationAtPriority;
function setAttemptHydrationAtPriority(fn) {
  attemptHydrationAtPriority = fn;
} // TODO: Upgrade this definition once we're on a newer version of Flow that
var hasScheduledReplayAttempt = false; // The queue of discrete events to be replayed.

var queuedDiscreteEvents = []; // Indicates if any continuous event targets are non-null for early bailout.
// if the last target was dehydrated.

var queuedFocus = null;
var queuedDrag = null;
var queuedMouse = null; // For pointer events there can be one latest event per pointerId.

var queuedPointers = new Map();
var queuedPointerCaptures = new Map(); // We could consider replaying selectionchange and touchmoves too.

var queuedExplicitHydrationTargets = [];
function hasQueuedDiscreteEvents() {
  return queuedDiscreteEvents.length > 0;
}
var discreteReplayableEvents = ['mousedown', 'mouseup', 'touchcancel', 'touchend', 'touchstart', 'auxclick', 'dblclick', 'pointercancel', 'pointerdown', 'pointerup', 'dragend', 'dragstart', 'drop', 'compositionend', 'compositionstart', 'keydown', 'keypress', 'keyup', 'input', 'textInput', // Intentionally camelCase
'copy', 'cut', 'paste', 'click', 'change', 'contextmenu', 'reset', 'submit'];
function isReplayableDiscreteEvent(eventType) {
  return discreteReplayableEvents.indexOf(eventType) > -1;
}

function createQueuedReplayableEvent(blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent) {
  return {
    blockedOn: blockedOn,
    domEventName: domEventName,
    eventSystemFlags: eventSystemFlags | IS_REPLAYED,
    nativeEvent: nativeEvent,
    targetContainers: [targetContainer]
  };
}

function queueDiscreteEvent(blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent) {
  var queuedEvent = createQueuedReplayableEvent(blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent);
  queuedDiscreteEvents.push(queuedEvent);
} // Resets the replaying for this type of continuous event to no event.

function clearIfContinuousEvent(domEventName, nativeEvent) {
  switch (domEventName) {
    case 'focusin':
    case 'focusout':
      queuedFocus = null;
      break;

    case 'dragenter':
    case 'dragleave':
      queuedDrag = null;
      break;

    case 'mouseover':
    case 'mouseout':
      queuedMouse = null;
      break;

    case 'pointerover':
    case 'pointerout':
      {
        var pointerId = nativeEvent.pointerId;
        queuedPointers.delete(pointerId);
        break;
      }

    case 'gotpointercapture':
    case 'lostpointercapture':
      {
        var _pointerId = nativeEvent.pointerId;
        queuedPointerCaptures.delete(_pointerId);
        break;
      }
  }
}

function accumulateOrCreateContinuousQueuedReplayableEvent(existingQueuedEvent, blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent) {
  if (existingQueuedEvent === null || existingQueuedEvent.nativeEvent !== nativeEvent) {
    var queuedEvent = createQueuedReplayableEvent(blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent);

    if (blockedOn !== null) {
      var _fiber2 = getInstanceFromNode(blockedOn);

      if (_fiber2 !== null) {
        // Attempt to increase the priority of this target.
        attemptContinuousHydration(_fiber2);
      }
    }

    return queuedEvent;
  } // If we have already queued this exact event, then it's because
  // the different event systems have different DOM event listeners.
  // We can accumulate the flags, and the targetContainers, and
  // store a single event to be replayed.


  existingQueuedEvent.eventSystemFlags |= eventSystemFlags;
  var targetContainers = existingQueuedEvent.targetContainers;

  if (targetContainer !== null && targetContainers.indexOf(targetContainer) === -1) {
    targetContainers.push(targetContainer);
  }

  return existingQueuedEvent;
}

function queueIfContinuousEvent(blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent) {
  // These set relatedTarget to null because the replayed event will be treated as if we
  // moved from outside the window (no target) onto the target once it hydrates.
  // Instead of mutating we could clone the event.
  switch (domEventName) {
    case 'focusin':
      {
        var focusEvent = nativeEvent;
        queuedFocus = accumulateOrCreateContinuousQueuedReplayableEvent(queuedFocus, blockedOn, domEventName, eventSystemFlags, targetContainer, focusEvent);
        return true;
      }

    case 'dragenter':
      {
        var dragEvent = nativeEvent;
        queuedDrag = accumulateOrCreateContinuousQueuedReplayableEvent(queuedDrag, blockedOn, domEventName, eventSystemFlags, targetContainer, dragEvent);
        return true;
      }

    case 'mouseover':
      {
        var mouseEvent = nativeEvent;
        queuedMouse = accumulateOrCreateContinuousQueuedReplayableEvent(queuedMouse, blockedOn, domEventName, eventSystemFlags, targetContainer, mouseEvent);
        return true;
      }

    case 'pointerover':
      {
        var pointerEvent = nativeEvent;
        var pointerId = pointerEvent.pointerId;
        queuedPointers.set(pointerId, accumulateOrCreateContinuousQueuedReplayableEvent(queuedPointers.get(pointerId) || null, blockedOn, domEventName, eventSystemFlags, targetContainer, pointerEvent));
        return true;
      }

    case 'gotpointercapture':
      {
        var _pointerEvent = nativeEvent;
        var _pointerId2 = _pointerEvent.pointerId;
        queuedPointerCaptures.set(_pointerId2, accumulateOrCreateContinuousQueuedReplayableEvent(queuedPointerCaptures.get(_pointerId2) || null, blockedOn, domEventName, eventSystemFlags, targetContainer, _pointerEvent));
        return true;
      }
  }

  return false;
} // Check if this target is unblocked. Returns true if it's unblocked.

function attemptExplicitHydrationTarget(queuedTarget) {
  // TODO: This function shares a lot of logic with attemptToDispatchEvent.
  // Try to unify them. It's a bit tricky since it would require two return
  // values.
  var targetInst = getClosestInstanceFromNode(queuedTarget.target);

  if (targetInst !== null) {
    var nearestMounted = getNearestMountedFiber(targetInst);

    if (nearestMounted !== null) {
      var tag = nearestMounted.tag;

      if (tag === SuspenseComponent) {
        var instance = getSuspenseInstanceFromFiber(nearestMounted);

        if (instance !== null) {
          // We're blocked on hydrating this boundary.
          // Increase its priority.
          queuedTarget.blockedOn = instance;
          attemptHydrationAtPriority(queuedTarget.lanePriority, function () {
            Scheduler.unstable_runWithPriority(queuedTarget.priority, function () {
              attemptHydrationAtCurrentPriority(nearestMounted);
            });
          });
          return;
        }
      } else if (tag === HostRoot) {
        var root = nearestMounted.stateNode;

        if (root.hydrate) {
          queuedTarget.blockedOn = getContainerFromFiber(nearestMounted); // We don't currently have a way to increase the priority of
          // a root other than sync.

          return;
        }
      }
    }
  }

  queuedTarget.blockedOn = null;
}

function attemptReplayContinuousQueuedEvent(queuedEvent) {
  if (queuedEvent.blockedOn !== null) {
    return false;
  }

  var targetContainers = queuedEvent.targetContainers;

  while (targetContainers.length > 0) {
    var targetContainer = targetContainers[0];
    var nextBlockedOn = attemptToDispatchEvent(queuedEvent.domEventName, queuedEvent.eventSystemFlags, targetContainer, queuedEvent.nativeEvent);

    if (nextBlockedOn !== null) {
      // We're still blocked. Try again later.
      var _fiber3 = getInstanceFromNode(nextBlockedOn);

      if (_fiber3 !== null) {
        attemptContinuousHydration(_fiber3);
      }

      queuedEvent.blockedOn = nextBlockedOn;
      return false;
    } // This target container was successfully dispatched. Try the next.


    targetContainers.shift();
  }

  return true;
}

function attemptReplayContinuousQueuedEventInMap(queuedEvent, key, map) {
  if (attemptReplayContinuousQueuedEvent(queuedEvent)) {
    map.delete(key);
  }
}

function replayUnblockedEvents() {
  hasScheduledReplayAttempt = false; // First replay discrete events.

  while (queuedDiscreteEvents.length > 0) {
    var nextDiscreteEvent = queuedDiscreteEvents[0];

    if (nextDiscreteEvent.blockedOn !== null) {
      // We're still blocked.
      // Increase the priority of this boundary to unblock
      // the next discrete event.
      var _fiber4 = getInstanceFromNode(nextDiscreteEvent.blockedOn);

      if (_fiber4 !== null) {
        attemptUserBlockingHydration(_fiber4);
      }

      break;
    }

    var targetContainers = nextDiscreteEvent.targetContainers;

    while (targetContainers.length > 0) {
      var targetContainer = targetContainers[0];
      var nextBlockedOn = attemptToDispatchEvent(nextDiscreteEvent.domEventName, nextDiscreteEvent.eventSystemFlags, targetContainer, nextDiscreteEvent.nativeEvent);

      if (nextBlockedOn !== null) {
        // We're still blocked. Try again later.
        nextDiscreteEvent.blockedOn = nextBlockedOn;
        break;
      } // This target container was successfully dispatched. Try the next.


      targetContainers.shift();
    }

    if (nextDiscreteEvent.blockedOn === null) {
      // We've successfully replayed the first event. Let's try the next one.
      queuedDiscreteEvents.shift();
    }
  } // Next replay any continuous events.


  if (queuedFocus !== null && attemptReplayContinuousQueuedEvent(queuedFocus)) {
    queuedFocus = null;
  }

  if (queuedDrag !== null && attemptReplayContinuousQueuedEvent(queuedDrag)) {
    queuedDrag = null;
  }

  if (queuedMouse !== null && attemptReplayContinuousQueuedEvent(queuedMouse)) {
    queuedMouse = null;
  }

  queuedPointers.forEach(attemptReplayContinuousQueuedEventInMap);
  queuedPointerCaptures.forEach(attemptReplayContinuousQueuedEventInMap);
}

function scheduleCallbackIfUnblocked(queuedEvent, unblocked) {
  if (queuedEvent.blockedOn === unblocked) {
    queuedEvent.blockedOn = null;

    if (!hasScheduledReplayAttempt) {
      hasScheduledReplayAttempt = true; // Schedule a callback to attempt replaying as many events as are
      // now unblocked. This first might not actually be unblocked yet.
      // We could check it early to avoid scheduling an unnecessary callback.

      Scheduler.unstable_scheduleCallback(Scheduler.unstable_NormalPriority, replayUnblockedEvents);
    }
  }
}

function retryIfBlockedOn(unblocked) {
  // Mark anything that was blocked on this as no longer blocked
  // and eligible for a replay.
  if (queuedDiscreteEvents.length > 0) {
    scheduleCallbackIfUnblocked(queuedDiscreteEvents[0], unblocked); // This is a exponential search for each boundary that commits. I think it's
    // worth it because we expect very few discrete events to queue up and once
    // we are actually fully unblocked it will be fast to replay them.

    for (var i = 1; i < queuedDiscreteEvents.length; i++) {
      var queuedEvent = queuedDiscreteEvents[i];

      if (queuedEvent.blockedOn === unblocked) {
        queuedEvent.blockedOn = null;
      }
    }
  }

  if (queuedFocus !== null) {
    scheduleCallbackIfUnblocked(queuedFocus, unblocked);
  }

  if (queuedDrag !== null) {
    scheduleCallbackIfUnblocked(queuedDrag, unblocked);
  }

  if (queuedMouse !== null) {
    scheduleCallbackIfUnblocked(queuedMouse, unblocked);
  }

  var unblock = function (queuedEvent) {
    return scheduleCallbackIfUnblocked(queuedEvent, unblocked);
  };

  queuedPointers.forEach(unblock);
  queuedPointerCaptures.forEach(unblock);

  for (var _i = 0; _i < queuedExplicitHydrationTargets.length; _i++) {
    var queuedTarget = queuedExplicitHydrationTargets[_i];

    if (queuedTarget.blockedOn === unblocked) {
      queuedTarget.blockedOn = null;
    }
  }

  while (queuedExplicitHydrationTargets.length > 0) {
    var nextExplicitTarget = queuedExplicitHydrationTargets[0];

    if (nextExplicitTarget.blockedOn !== null) {
      // We're still blocked.
      break;
    } else {
      attemptExplicitHydrationTarget(nextExplicitTarget);

      if (nextExplicitTarget.blockedOn === null) {
        // We're unblocked.
        queuedExplicitHydrationTargets.shift();
      }
    }
  }
}

var DiscreteEvent = 0;
var UserBlockingEvent = 1;
var ContinuousEvent = 2;

/**
 * Generate a mapping of standard vendor prefixes using the defined style property and event name.
 *
 * @param {string} styleProp
 * @param {string} eventName
 * @returns {object}
 */

function makePrefixMap(styleProp, eventName) {
  var prefixes = {};
  prefixes[styleProp.toLowerCase()] = eventName.toLowerCase();
  prefixes['Webkit' + styleProp] = 'webkit' + eventName;
  prefixes['Moz' + styleProp] = 'moz' + eventName;
  return prefixes;
}
/**
 * A list of event names to a configurable list of vendor prefixes.
 */


var vendorPrefixes = {
  animationend: makePrefixMap('Animation', 'AnimationEnd'),
  animationiteration: makePrefixMap('Animation', 'AnimationIteration'),
  animationstart: makePrefixMap('Animation', 'AnimationStart'),
  transitionend: makePrefixMap('Transition', 'TransitionEnd')
};
/**
 * Event names that have already been detected and prefixed (if applicable).
 */

var prefixedEventNames = {};
/**
 * Element to check for prefixes on.
 */

var style = {};
/**
 * Bootstrap if a DOM exists.
 */

if (canUseDOM) {
  style = document.createElement('div').style; // On some platforms, in particular some releases of Android 4.x,
  // the un-prefixed "animation" and "transition" properties are defined on the
  // style object but the events that fire will still be prefixed, so we need
  // to check if the un-prefixed events are usable, and if not remove them from the map.

  if (!('AnimationEvent' in window)) {
    delete vendorPrefixes.animationend.animation;
    delete vendorPrefixes.animationiteration.animation;
    delete vendorPrefixes.animationstart.animation;
  } // Same as above


  if (!('TransitionEvent' in window)) {
    delete vendorPrefixes.transitionend.transition;
  }
}
/**
 * Attempts to determine the correct vendor prefixed event name.
 *
 * @param {string} eventName
 * @returns {string}
 */


function getVendorPrefixedEventName(eventName) {
  if (prefixedEventNames[eventName]) {
    return prefixedEventNames[eventName];
  } else if (!vendorPrefixes[eventName]) {
    return eventName;
  }

  var prefixMap = vendorPrefixes[eventName];

  for (var styleProp in prefixMap) {
    if (prefixMap.hasOwnProperty(styleProp) && styleProp in style) {
      return prefixedEventNames[eventName] = prefixMap[styleProp];
    }
  }

  return eventName;
}

var ANIMATION_END = getVendorPrefixedEventName('animationend');
var ANIMATION_ITERATION = getVendorPrefixedEventName('animationiteration');
var ANIMATION_START = getVendorPrefixedEventName('animationstart');
var TRANSITION_END = getVendorPrefixedEventName('transitionend');

var topLevelEventsToReactNames = new Map();
var eventPriorities = new Map(); // We store most of the events in this module in pairs of two strings so we can re-use
// the code required to apply the same logic for event prioritization and that of the
// SimpleEventPlugin. This complicates things slightly, but the aim is to reduce code
// duplication (for which there would be quite a bit). For the events that are not needed
// for the SimpleEventPlugin (otherDiscreteEvents) we process them separately as an
// array of top level events.
// Lastly, we ignore prettier so we can keep the formatting sane.
// prettier-ignore

var discreteEventPairsForSimpleEventPlugin = ['cancel', 'cancel', 'click', 'click', 'close', 'close', 'contextmenu', 'contextMenu', 'copy', 'copy', 'cut', 'cut', 'auxclick', 'auxClick', 'dblclick', 'doubleClick', // Careful!
'dragend', 'dragEnd', 'dragstart', 'dragStart', 'drop', 'drop', 'focusin', 'focus', // Careful!
'focusout', 'blur', // Careful!
'input', 'input', 'invalid', 'invalid', 'keydown', 'keyDown', 'keypress', 'keyPress', 'keyup', 'keyUp', 'mousedown', 'mouseDown', 'mouseup', 'mouseUp', 'paste', 'paste', 'pause', 'pause', 'play', 'play', 'pointercancel', 'pointerCancel', 'pointerdown', 'pointerDown', 'pointerup', 'pointerUp', 'ratechange', 'rateChange', 'reset', 'reset', 'seeked', 'seeked', 'submit', 'submit', 'touchcancel', 'touchCancel', 'touchend', 'touchEnd', 'touchstart', 'touchStart', 'volumechange', 'volumeChange'];
var otherDiscreteEvents = ['change', 'selectionchange', 'textInput', 'compositionstart', 'compositionend', 'compositionupdate'];


var userBlockingPairsForSimpleEventPlugin = ['drag', 'drag', 'dragenter', 'dragEnter', 'dragexit', 'dragExit', 'dragleave', 'dragLeave', 'dragover', 'dragOver', 'mousemove', 'mouseMove', 'mouseout', 'mouseOut', 'mouseover', 'mouseOver', 'pointermove', 'pointerMove', 'pointerout', 'pointerOut', 'pointerover', 'pointerOver', 'scroll', 'scroll', 'toggle', 'toggle', 'touchmove', 'touchMove', 'wheel', 'wheel']; // prettier-ignore

var continuousPairsForSimpleEventPlugin = ['abort', 'abort', ANIMATION_END, 'animationEnd', ANIMATION_ITERATION, 'animationIteration', ANIMATION_START, 'animationStart', 'canplay', 'canPlay', 'canplaythrough', 'canPlayThrough', 'durationchange', 'durationChange', 'emptied', 'emptied', 'encrypted', 'encrypted', 'ended', 'ended', 'error', 'error', 'gotpointercapture', 'gotPointerCapture', 'load', 'load', 'loadeddata', 'loadedData', 'loadedmetadata', 'loadedMetadata', 'loadstart', 'loadStart', 'lostpointercapture', 'lostPointerCapture', 'playing', 'playing', 'progress', 'progress', 'seeking', 'seeking', 'stalled', 'stalled', 'suspend', 'suspend', 'timeupdate', 'timeUpdate', TRANSITION_END, 'transitionEnd', 'waiting', 'waiting'];
/**
 * Turns
 * ['abort', ...]
 *
 * into
 *
 * topLevelEventsToReactNames = new Map([
 *   ['abort', 'onAbort'],
 * ]);
 *
 * and registers them.
 */

function registerSimplePluginEventsAndSetTheirPriorities(eventTypes, priority) {
  // As the event types are in pairs of two, we need to iterate
  // through in twos. The events are in pairs of two to save code
  // and improve init perf of processing this array, as it will
  // result in far fewer object allocations and property accesses
  // if we only use three arrays to process all the categories of
  // instead of tuples.
  for (var i = 0; i < eventTypes.length; i += 2) {
    var topEvent = eventTypes[i];
    var event = eventTypes[i + 1];
    var capitalizedEvent = event[0].toUpperCase() + event.slice(1);
    var reactName = 'on' + capitalizedEvent;
    eventPriorities.set(topEvent, priority);
    topLevelEventsToReactNames.set(topEvent, reactName);
    registerTwoPhaseEvent(reactName, [topEvent]);
  }
}

function setEventPriorities(eventTypes, priority) {
  for (var i = 0; i < eventTypes.length; i++) {
    eventPriorities.set(eventTypes[i], priority);
  }
}

function getEventPriorityForPluginSystem(domEventName) {
  var priority = eventPriorities.get(domEventName); // Default to a ContinuousEvent. Note: we might
  // want to warn if we can't detect the priority
  // for the event.

  return priority === undefined ? ContinuousEvent : priority;
}
function registerSimpleEvents() {
  registerSimplePluginEventsAndSetTheirPriorities(discreteEventPairsForSimpleEventPlugin, DiscreteEvent);
  registerSimplePluginEventsAndSetTheirPriorities(userBlockingPairsForSimpleEventPlugin, UserBlockingEvent);
  registerSimplePluginEventsAndSetTheirPriorities(continuousPairsForSimpleEventPlugin, ContinuousEvent);
  setEventPriorities(otherDiscreteEvents, DiscreteEvent);
}

var Scheduler_now = Scheduler.unstable_now;

{
  // Provide explicit error message when production+profiling bundle of e.g.
  // react-dom is used with production (non-profiling) bundle of
  // scheduler/tracing
  if (!(tracing.__interactionsRef != null && tracing.__interactionsRef.current != null)) {
    {
      throw Error( "It is not supported to run the profiling version of a renderer (for example, `react-dom/profiling`) without also replacing the `scheduler/tracing` module with `scheduler/tracing-profiling`. Your bundler might have a setting for aliasing both modules. Learn more at https://reactjs.org/link/profiling" );
    }
  }
}
// ascending numbers so we can compare them like numbers. They start at 90 to
// avoid clashing with Scheduler's priorities.

var ImmediatePriority = 99;
var UserBlockingPriority = 98;
var NormalPriority = 97;
var LowPriority = 96;
var IdlePriority = 95; // NoPriority is the absence of priority. Also React-only.

var NoPriority = 90;
var initialTimeMs = Scheduler_now(); // If the initial timestamp is reasonably small, use Scheduler's `now` directly.

var SyncLanePriority = 15;
var SyncBatchedLanePriority = 14;
var InputDiscreteHydrationLanePriority = 13;
var InputDiscreteLanePriority = 12;
var InputContinuousHydrationLanePriority = 11;
var InputContinuousLanePriority = 10;
var DefaultHydrationLanePriority = 9;
var DefaultLanePriority = 8;
var TransitionHydrationPriority = 7;
var TransitionPriority = 6;
var RetryLanePriority = 5;
var SelectiveHydrationLanePriority = 4;
var IdleHydrationLanePriority = 3;
var IdleLanePriority = 2;
var OffscreenLanePriority = 1;
var NoLanePriority = 0;
var TotalLanes = 31;
var NoLanes =
/*                        */
0;
var NoLane =
/*                          */
0;
var SyncLane =
/*                        */
1;
var SyncBatchedLane =
/*                 */
2;
var InputDiscreteHydrationLane =
/*      */
4;
var InputDiscreteLanes =
/*                    */
24;
var InputContinuousHydrationLane =
/*           */
32;
var InputContinuousLanes =
/*                  */
192;
var DefaultHydrationLane =
/*            */
256;
var DefaultLanes =
/*                   */
3584;
var TransitionHydrationLane =
/*                */
4096;
var TransitionLanes =
/*                       */
4186112;
var RetryLanes =
/*                            */
62914560;
var SomeRetryLane =
/*                  */
33554432;
var SelectiveHydrationLane =
/*          */
67108864;
var NonIdleLanes =
/*                                 */
134217727;
var IdleHydrationLane =
/*               */
134217728;
var IdleLanes =
/*                             */
805306368;
var OffscreenLane =
/*                   */
1073741824;
var NoTimestamp = -1;
function setCurrentUpdateLanePriority(newLanePriority) {
} // "Registers" used to "return" multiple values
// Used by getHighestPriorityLanes and getNextLanes:

var return_highestLanePriority = DefaultLanePriority;

function getHighestPriorityLanes(lanes) {
  if ((SyncLane & lanes) !== NoLanes) {
    return_highestLanePriority = SyncLanePriority;
    return SyncLane;
  }

  if ((SyncBatchedLane & lanes) !== NoLanes) {
    return_highestLanePriority = SyncBatchedLanePriority;
    return SyncBatchedLane;
  }

  if ((InputDiscreteHydrationLane & lanes) !== NoLanes) {
    return_highestLanePriority = InputDiscreteHydrationLanePriority;
    return InputDiscreteHydrationLane;
  }

  var inputDiscreteLanes = InputDiscreteLanes & lanes;

  if (inputDiscreteLanes !== NoLanes) {
    return_highestLanePriority = InputDiscreteLanePriority;
    return inputDiscreteLanes;
  }

  if ((lanes & InputContinuousHydrationLane) !== NoLanes) {
    return_highestLanePriority = InputContinuousHydrationLanePriority;
    return InputContinuousHydrationLane;
  }

  var inputContinuousLanes = InputContinuousLanes & lanes;

  if (inputContinuousLanes !== NoLanes) {
    return_highestLanePriority = InputContinuousLanePriority;
    return inputContinuousLanes;
  }

  if ((lanes & DefaultHydrationLane) !== NoLanes) {
    return_highestLanePriority = DefaultHydrationLanePriority;
    return DefaultHydrationLane;
  }

  var defaultLanes = DefaultLanes & lanes;

  if (defaultLanes !== NoLanes) {
    return_highestLanePriority = DefaultLanePriority;
    return defaultLanes;
  }

  if ((lanes & TransitionHydrationLane) !== NoLanes) {
    return_highestLanePriority = TransitionHydrationPriority;
    return TransitionHydrationLane;
  }

  var transitionLanes = TransitionLanes & lanes;

  if (transitionLanes !== NoLanes) {
    return_highestLanePriority = TransitionPriority;
    return transitionLanes;
  }

  var retryLanes = RetryLanes & lanes;

  if (retryLanes !== NoLanes) {
    return_highestLanePriority = RetryLanePriority;
    return retryLanes;
  }

  if (lanes & SelectiveHydrationLane) {
    return_highestLanePriority = SelectiveHydrationLanePriority;
    return SelectiveHydrationLane;
  }

  if ((lanes & IdleHydrationLane) !== NoLanes) {
    return_highestLanePriority = IdleHydrationLanePriority;
    return IdleHydrationLane;
  }

  var idleLanes = IdleLanes & lanes;

  if (idleLanes !== NoLanes) {
    return_highestLanePriority = IdleLanePriority;
    return idleLanes;
  }

  if ((OffscreenLane & lanes) !== NoLanes) {
    return_highestLanePriority = OffscreenLanePriority;
    return OffscreenLane;
  }

  {
    error('Should have found matching lanes. This is a bug in React.');
  } // This shouldn't be reachable, but as a fallback, return the entire bitmask.


  return_highestLanePriority = DefaultLanePriority;
  return lanes;
}

function schedulerPriorityToLanePriority(schedulerPriorityLevel) {
  switch (schedulerPriorityLevel) {
    case ImmediatePriority:
      return SyncLanePriority;

    case UserBlockingPriority:
      return InputContinuousLanePriority;

    case NormalPriority:
    case LowPriority:
      // TODO: Handle LowSchedulerPriority, somehow. Maybe the same lane as hydration.
      return DefaultLanePriority;

    case IdlePriority:
      return IdleLanePriority;

    default:
      return NoLanePriority;
  }
}
function lanePriorityToSchedulerPriority(lanePriority) {
  switch (lanePriority) {
    case SyncLanePriority:
    case SyncBatchedLanePriority:
      return ImmediatePriority;

    case InputDiscreteHydrationLanePriority:
    case InputDiscreteLanePriority:
    case InputContinuousHydrationLanePriority:
    case InputContinuousLanePriority:
      return UserBlockingPriority;

    case DefaultHydrationLanePriority:
    case DefaultLanePriority:
    case TransitionHydrationPriority:
    case TransitionPriority:
    case SelectiveHydrationLanePriority:
    case RetryLanePriority:
      return NormalPriority;

    case IdleHydrationLanePriority:
    case IdleLanePriority:
    case OffscreenLanePriority:
      return IdlePriority;

    case NoLanePriority:
      return NoPriority;

    default:
      {
        {
          throw Error( "Invalid update priority: " + lanePriority + ". This is a bug in React." );
        }
      }

  }
}
function getNextLanes(root, wipLanes) {
  // Early bailout if there's no pending work left.
  var pendingLanes = root.pendingLanes;

  if (pendingLanes === NoLanes) {
    return_highestLanePriority = NoLanePriority;
    return NoLanes;
  }

  var nextLanes = NoLanes;
  var nextLanePriority = NoLanePriority;
  var expiredLanes = root.expiredLanes;
  var suspendedLanes = root.suspendedLanes;
  var pingedLanes = root.pingedLanes; // Check if any work has expired.

  if (expiredLanes !== NoLanes) {
    nextLanes = expiredLanes;
    nextLanePriority = return_highestLanePriority = SyncLanePriority;
  } else {
    // Do not work on any idle work until all the non-idle work has finished,
    // even if the work is suspended.
    var nonIdlePendingLanes = pendingLanes & NonIdleLanes;

    if (nonIdlePendingLanes !== NoLanes) {
      var nonIdleUnblockedLanes = nonIdlePendingLanes & ~suspendedLanes;

      if (nonIdleUnblockedLanes !== NoLanes) {
        nextLanes = getHighestPriorityLanes(nonIdleUnblockedLanes);
        nextLanePriority = return_highestLanePriority;
      } else {
        var nonIdlePingedLanes = nonIdlePendingLanes & pingedLanes;

        if (nonIdlePingedLanes !== NoLanes) {
          nextLanes = getHighestPriorityLanes(nonIdlePingedLanes);
          nextLanePriority = return_highestLanePriority;
        }
      }
    } else {
      // The only remaining work is Idle.
      var unblockedLanes = pendingLanes & ~suspendedLanes;

      if (unblockedLanes !== NoLanes) {
        nextLanes = getHighestPriorityLanes(unblockedLanes);
        nextLanePriority = return_highestLanePriority;
      } else {
        if (pingedLanes !== NoLanes) {
          nextLanes = getHighestPriorityLanes(pingedLanes);
          nextLanePriority = return_highestLanePriority;
        }
      }
    }
  }

  if (nextLanes === NoLanes) {
    // This should only be reachable if we're suspended
    // TODO: Consider warning in this path if a fallback timer is not scheduled.
    return NoLanes;
  } // If there are higher priority lanes, we'll include them even if they
  // are suspended.


  nextLanes = pendingLanes & getEqualOrHigherPriorityLanes(nextLanes); // If we're already in the middle of a render, switching lanes will interrupt
  // it and we'll lose our progress. We should only do this if the new lanes are
  // higher priority.

  if (wipLanes !== NoLanes && wipLanes !== nextLanes && // If we already suspended with a delay, then interrupting is fine. Don't
  // bother waiting until the root is complete.
  (wipLanes & suspendedLanes) === NoLanes) {
    getHighestPriorityLanes(wipLanes);
    var wipLanePriority = return_highestLanePriority;

    if (nextLanePriority <= wipLanePriority) {
      return wipLanes;
    } else {
      return_highestLanePriority = nextLanePriority;
    }
  } // Check for entangled lanes and add them to the batch.
  //
  // A lane is said to be entangled with another when it's not allowed to render
  // in a batch that does not also include the other lane. Typically we do this
  // when multiple updates have the same source, and we only want to respond to
  // the most recent event from that source.
  //
  // Note that we apply entanglements *after* checking for partial work above.
  // This means that if a lane is entangled during an interleaved event while
  // it's already rendering, we won't interrupt it. This is intentional, since
  // entanglement is usually "best effort": we'll try our best to render the
  // lanes in the same batch, but it's not worth throwing out partially
  // completed work in order to do it.
  //
  // For those exceptions where entanglement is semantically important, like
  // useMutableSource, we should ensure that there is no partial work at the
  // time we apply the entanglement.


  var entangledLanes = root.entangledLanes;

  if (entangledLanes !== NoLanes) {
    var entanglements = root.entanglements;
    var lanes = nextLanes & entangledLanes;

    while (lanes > 0) {
      var index = pickArbitraryLaneIndex(lanes);
      var lane = 1 << index;
      nextLanes |= entanglements[index];
      lanes &= ~lane;
    }
  }

  return nextLanes;
}
function getMostRecentEventTime(root, lanes) {
  var eventTimes = root.eventTimes;
  var mostRecentEventTime = NoTimestamp;

  while (lanes > 0) {
    var index = pickArbitraryLaneIndex(lanes);
    var lane = 1 << index;
    var eventTime = eventTimes[index];

    if (eventTime > mostRecentEventTime) {
      mostRecentEventTime = eventTime;
    }

    lanes &= ~lane;
  }

  return mostRecentEventTime;
}

function computeExpirationTime(lane, currentTime) {
  // TODO: Expiration heuristic is constant per lane, so could use a map.
  getHighestPriorityLanes(lane);
  var priority = return_highestLanePriority;

  if (priority >= InputContinuousLanePriority) {
    // User interactions should expire slightly more quickly.
    //
    // NOTE: This is set to the corresponding constant as in Scheduler.js. When
    // we made it larger, a product metric in www regressed, suggesting there's
    // a user interaction that's being starved by a series of synchronous
    // updates. If that theory is correct, the proper solution is to fix the
    // starvation. However, this scenario supports the idea that expiration
    // times are an important safeguard when starvation does happen.
    //
    // Also note that, in the case of user input specifically, this will soon no
    // longer be an issue because we plan to make user input synchronous by
    // default (until you enter `startTransition`, of course.)
    //
    // If weren't planning to make these updates synchronous soon anyway, I
    // would probably make this number a configurable parameter.
    return currentTime + 250;
  } else if (priority >= TransitionPriority) {
    return currentTime + 5000;
  } else {
    // Anything idle priority or lower should never expire.
    return NoTimestamp;
  }
}

function markStarvedLanesAsExpired(root, currentTime) {
  // TODO: This gets called every time we yield. We can optimize by storing
  // the earliest expiration time on the root. Then use that to quickly bail out
  // of this function.
  var pendingLanes = root.pendingLanes;
  var suspendedLanes = root.suspendedLanes;
  var pingedLanes = root.pingedLanes;
  var expirationTimes = root.expirationTimes; // Iterate through the pending lanes and check if we've reached their
  // expiration time. If so, we'll assume the update is being starved and mark
  // it as expired to force it to finish.

  var lanes = pendingLanes;

  while (lanes > 0) {
    var index = pickArbitraryLaneIndex(lanes);
    var lane = 1 << index;
    var expirationTime = expirationTimes[index];

    if (expirationTime === NoTimestamp) {
      // Found a pending lane with no expiration time. If it's not suspended, or
      // if it's pinged, assume it's CPU-bound. Compute a new expiration time
      // using the current time.
      if ((lane & suspendedLanes) === NoLanes || (lane & pingedLanes) !== NoLanes) {
        // Assumes timestamps are monotonically increasing.
        expirationTimes[index] = computeExpirationTime(lane, currentTime);
      }
    } else if (expirationTime <= currentTime) {
      // This lane expired
      root.expiredLanes |= lane;
    }

    lanes &= ~lane;
  }
} // This returns the highest priority pending lanes regardless of whether they
function getLanesToRetrySynchronouslyOnError(root) {
  var everythingButOffscreen = root.pendingLanes & ~OffscreenLane;

  if (everythingButOffscreen !== NoLanes) {
    return everythingButOffscreen;
  }

  if (everythingButOffscreen & OffscreenLane) {
    return OffscreenLane;
  }

  return NoLanes;
}
function returnNextLanesPriority() {
  return return_highestLanePriority;
}
function includesNonIdleWork(lanes) {
  return (lanes & NonIdleLanes) !== NoLanes;
}
function includesOnlyRetries(lanes) {
  return (lanes & RetryLanes) === lanes;
}
function includesOnlyTransitions(lanes) {
  return (lanes & TransitionLanes) === lanes;
} // To ensure consistency across multiple updates in the same event, this should
// be a pure function, so that it always returns the same lane for given inputs.

function findUpdateLane(lanePriority, wipLanes) {
  switch (lanePriority) {
    case NoLanePriority:
      break;

    case SyncLanePriority:
      return SyncLane;

    case SyncBatchedLanePriority:
      return SyncBatchedLane;

    case InputDiscreteLanePriority:
      {
        var _lane = pickArbitraryLane(InputDiscreteLanes & ~wipLanes);

        if (_lane === NoLane) {
          // Shift to the next priority level
          return findUpdateLane(InputContinuousLanePriority, wipLanes);
        }

        return _lane;
      }

    case InputContinuousLanePriority:
      {
        var _lane2 = pickArbitraryLane(InputContinuousLanes & ~wipLanes);

        if (_lane2 === NoLane) {
          // Shift to the next priority level
          return findUpdateLane(DefaultLanePriority, wipLanes);
        }

        return _lane2;
      }

    case DefaultLanePriority:
      {
        var _lane3 = pickArbitraryLane(DefaultLanes & ~wipLanes);

        if (_lane3 === NoLane) {
          // If all the default lanes are already being worked on, look for a
          // lane in the transition range.
          _lane3 = pickArbitraryLane(TransitionLanes & ~wipLanes);

          if (_lane3 === NoLane) {
            // All the transition lanes are taken, too. This should be very
            // rare, but as a last resort, pick a default lane. This will have
            // the effect of interrupting the current work-in-progress render.
            _lane3 = pickArbitraryLane(DefaultLanes);
          }
        }

        return _lane3;
      }

    case TransitionPriority: // Should be handled by findTransitionLane instead

    case RetryLanePriority:
      // Should be handled by findRetryLane instead
      break;

    case IdleLanePriority:
      var lane = pickArbitraryLane(IdleLanes & ~wipLanes);

      if (lane === NoLane) {
        lane = pickArbitraryLane(IdleLanes);
      }

      return lane;
  }

  {
    {
      throw Error( "Invalid update priority: " + lanePriority + ". This is a bug in React." );
    }
  }
} // To ensure consistency across multiple updates in the same event, this should
// be pure function, so that it always returns the same lane for given inputs.

function findTransitionLane(wipLanes, pendingLanes) {
  // First look for lanes that are completely unclaimed, i.e. have no
  // pending work.
  var lane = pickArbitraryLane(TransitionLanes & ~pendingLanes);

  if (lane === NoLane) {
    // If all lanes have pending work, look for a lane that isn't currently
    // being worked on.
    lane = pickArbitraryLane(TransitionLanes & ~wipLanes);

    if (lane === NoLane) {
      // If everything is being worked on, pick any lane. This has the
      // effect of interrupting the current work-in-progress.
      lane = pickArbitraryLane(TransitionLanes);
    }
  }

  return lane;
} // To ensure consistency across multiple updates in the same event, this should
// be pure function, so that it always returns the same lane for given inputs.

function findRetryLane(wipLanes) {
  // This is a fork of `findUpdateLane` designed specifically for Suspense
  // "retries"  a special update that attempts to flip a Suspense boundary
  // from its placeholder state to its primary/resolved state.
  var lane = pickArbitraryLane(RetryLanes & ~wipLanes);

  if (lane === NoLane) {
    lane = pickArbitraryLane(RetryLanes);
  }

  return lane;
}

function getHighestPriorityLane(lanes) {
  return lanes & -lanes;
}

function getLowestPriorityLane(lanes) {
  // This finds the most significant non-zero bit.
  var index = 31 - clz32(lanes);
  return index < 0 ? NoLanes : 1 << index;
}

function getEqualOrHigherPriorityLanes(lanes) {
  return (getLowestPriorityLane(lanes) << 1) - 1;
}

function pickArbitraryLane(lanes) {
  // This wrapper function gets inlined. Only exists so to communicate that it
  // doesn't matter which bit is selected; you can pick any bit without
  // affecting the algorithms where its used. Here I'm using
  // getHighestPriorityLane because it requires the fewest operations.
  return getHighestPriorityLane(lanes);
}

function pickArbitraryLaneIndex(lanes) {
  return 31 - clz32(lanes);
}

function laneToIndex(lane) {
  return pickArbitraryLaneIndex(lane);
}

function includesSomeLane(a, b) {
  return (a & b) !== NoLanes;
}
function isSubsetOfLanes(set, subset) {
  return (set & subset) === subset;
}
function mergeLanes(a, b) {
  return a | b;
}
function removeLanes(set, subset) {
  return set & ~subset;
} // Seems redundant, but it changes the type from a single lane (used for
// updates) to a group of lanes (used for flushing work).

function laneToLanes(lane) {
  return lane;
}
function higherPriorityLane(a, b) {
  // This works because the bit ranges decrease in priority as you go left.
  return a !== NoLane && a < b ? a : b;
}
function createLaneMap(initial) {
  // Intentionally pushing one by one.
  // https://v8.dev/blog/elements-kinds#avoid-creating-holes
  var laneMap = [];

  for (var i = 0; i < TotalLanes; i++) {
    laneMap.push(initial);
  }

  return laneMap;
}
function markRootUpdated(root, updateLane, eventTime) {
  root.pendingLanes |= updateLane; // TODO: Theoretically, any update to any lane can unblock any other lane. But
  // it's not practical to try every single possible combination. We need a
  // heuristic to decide which lanes to attempt to render, and in which batches.
  // For now, we use the same heuristic as in the old ExpirationTimes model:
  // retry any lane at equal or lower priority, but don't try updates at higher
  // priority without also including the lower priority updates. This works well
  // when considering updates across different priority levels, but isn't
  // sufficient for updates within the same priority, since we want to treat
  // those updates as parallel.
  // Unsuspend any update at equal or lower priority.

  var higherPriorityLanes = updateLane - 1; // Turns 0b1000 into 0b0111

  root.suspendedLanes &= higherPriorityLanes;
  root.pingedLanes &= higherPriorityLanes;
  var eventTimes = root.eventTimes;
  var index = laneToIndex(updateLane); // We can always overwrite an existing timestamp because we prefer the most
  // recent event, and we assume time is monotonically increasing.

  eventTimes[index] = eventTime;
}
function markRootSuspended(root, suspendedLanes) {
  root.suspendedLanes |= suspendedLanes;
  root.pingedLanes &= ~suspendedLanes; // The suspended lanes are no longer CPU-bound. Clear their expiration times.

  var expirationTimes = root.expirationTimes;
  var lanes = suspendedLanes;

  while (lanes > 0) {
    var index = pickArbitraryLaneIndex(lanes);
    var lane = 1 << index;
    expirationTimes[index] = NoTimestamp;
    lanes &= ~lane;
  }
}
function markRootPinged(root, pingedLanes, eventTime) {
  root.pingedLanes |= root.suspendedLanes & pingedLanes;
}
function markDiscreteUpdatesExpired(root) {
  root.expiredLanes |= InputDiscreteLanes & root.pendingLanes;
}
function hasDiscreteLanes(lanes) {
  return (lanes & InputDiscreteLanes) !== NoLanes;
}
function markRootMutableRead(root, updateLane) {
  root.mutableReadLanes |= updateLane & root.pendingLanes;
}
function markRootFinished(root, remainingLanes) {
  var noLongerPendingLanes = root.pendingLanes & ~remainingLanes;
  root.pendingLanes = remainingLanes; // Let's try everything again

  root.suspendedLanes = 0;
  root.pingedLanes = 0;
  root.expiredLanes &= remainingLanes;
  root.mutableReadLanes &= remainingLanes;
  root.entangledLanes &= remainingLanes;
  var entanglements = root.entanglements;
  var eventTimes = root.eventTimes;
  var expirationTimes = root.expirationTimes; // Clear the lanes that no longer have pending work

  var lanes = noLongerPendingLanes;

  while (lanes > 0) {
    var index = pickArbitraryLaneIndex(lanes);
    var lane = 1 << index;
    entanglements[index] = NoLanes;
    eventTimes[index] = NoTimestamp;
    expirationTimes[index] = NoTimestamp;
    lanes &= ~lane;
  }
}
function markRootEntangled(root, entangledLanes) {
  root.entangledLanes |= entangledLanes;
  var entanglements = root.entanglements;
  var lanes = entangledLanes;

  while (lanes > 0) {
    var index = pickArbitraryLaneIndex(lanes);
    var lane = 1 << index;
    entanglements[index] |= entangledLanes;
    lanes &= ~lane;
  }
}
var clz32 = Math.clz32 ? Math.clz32 : clz32Fallback; // Count leading zeros. Only used on lanes, so assume input is an integer.
// Based on:
// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/clz32

var log = Math.log;
var LN2 = Math.LN2;

function clz32Fallback(lanes) {
  if (lanes === 0) {
    return 32;
  }

  return 31 - (log(lanes) / LN2 | 0) | 0;
}

// Intentionally not named imports because Rollup would use dynamic dispatch for
var UserBlockingPriority$1 = Scheduler.unstable_UserBlockingPriority,
    runWithPriority = Scheduler.unstable_runWithPriority; // TODO: can we stop exporting these?

var _enabled = true; // This is exported in FB builds for use by legacy FB layer infra.
// We'd like to remove this but it's not clear if this is safe.

function setEnabled(enabled) {
  _enabled = !!enabled;
}
function isEnabled() {
  return _enabled;
}
function createEventListenerWrapperWithPriority(targetContainer, domEventName, eventSystemFlags) {
  var eventPriority = getEventPriorityForPluginSystem(domEventName);
  var listenerWrapper;

  switch (eventPriority) {
    case DiscreteEvent:
      listenerWrapper = dispatchDiscreteEvent;
      break;

    case UserBlockingEvent:
      listenerWrapper = dispatchUserBlockingUpdate;
      break;

    case ContinuousEvent:
    default:
      listenerWrapper = dispatchEvent;
      break;
  }

  return listenerWrapper.bind(null, domEventName, eventSystemFlags, targetContainer);
}

function dispatchDiscreteEvent(domEventName, eventSystemFlags, container, nativeEvent) {
  {
    flushDiscreteUpdatesIfNeeded(nativeEvent.timeStamp);
  }

  discreteUpdates(dispatchEvent, domEventName, eventSystemFlags, container, nativeEvent);
}

function dispatchUserBlockingUpdate(domEventName, eventSystemFlags, container, nativeEvent) {
  {
    runWithPriority(UserBlockingPriority$1, dispatchEvent.bind(null, domEventName, eventSystemFlags, container, nativeEvent));
  }
}

function dispatchEvent(domEventName, eventSystemFlags, targetContainer, nativeEvent) {
  if (!_enabled) {
    return;
  }

  var allowReplay = true;

  {
    // TODO: replaying capture phase events is currently broken
    // because we used to do it during top-level native bubble handlers
    // but now we use different bubble and capture handlers.
    // In eager mode, we attach capture listeners early, so we need
    // to filter them out until we fix the logic to handle them correctly.
    // This could've been outside the flag but I put it inside to reduce risk.
    allowReplay = (eventSystemFlags & IS_CAPTURE_PHASE) === 0;
  }

  if (allowReplay && hasQueuedDiscreteEvents() && isReplayableDiscreteEvent(domEventName)) {
    // If we already have a queue of discrete events, and this is another discrete
    // event, then we can't dispatch it regardless of its target, since they
    // need to dispatch in order.
    queueDiscreteEvent(null, // Flags that we're not actually blocked on anything as far as we know.
    domEventName, eventSystemFlags, targetContainer, nativeEvent);
    return;
  }

  var blockedOn = attemptToDispatchEvent(domEventName, eventSystemFlags, targetContainer, nativeEvent);

  if (blockedOn === null) {
    // We successfully dispatched this event.
    if (allowReplay) {
      clearIfContinuousEvent(domEventName, nativeEvent);
    }

    return;
  }

  if (allowReplay) {
    if (isReplayableDiscreteEvent(domEventName)) {
      // This this to be replayed later once the target is available.
      queueDiscreteEvent(blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent);
      return;
    }

    if (queueIfContinuousEvent(blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent)) {
      return;
    } // We need to clear only if we didn't queue because
    // queueing is accummulative.


    clearIfContinuousEvent(domEventName, nativeEvent);
  } // This is not replayable so we'll invoke it but without a target,
  // in case the event system needs to trace it.


  dispatchEventForPluginEventSystem(domEventName, eventSystemFlags, nativeEvent, null, targetContainer);
} // Attempt dispatching an event. Returns a SuspenseInstance or Container if it's blocked.

function attemptToDispatchEvent(domEventName, eventSystemFlags, targetContainer, nativeEvent) {
  // TODO: Warn if _enabled is false.
  var nativeEventTarget = getEventTarget(nativeEvent);
  var targetInst = getClosestInstanceFromNode(nativeEventTarget);

  if (targetInst !== null) {
    var nearestMounted = getNearestMountedFiber(targetInst);

    if (nearestMounted === null) {
      // This tree has been unmounted already. Dispatch without a target.
      targetInst = null;
    } else {
      var tag = nearestMounted.tag;

      if (tag === SuspenseComponent) {
        var instance = getSuspenseInstanceFromFiber(nearestMounted);

        if (instance !== null) {
          // Queue the event to be replayed later. Abort dispatching since we
          // don't want this event dispatched twice through the event system.
          // TODO: If this is the first discrete event in the queue. Schedule an increased
          // priority for this boundary.
          return instance;
        } // This shouldn't happen, something went wrong but to avoid blocking
        // the whole system, dispatch the event without a target.
        // TODO: Warn.


        targetInst = null;
      } else if (tag === HostRoot) {
        var root = nearestMounted.stateNode;

        if (root.hydrate) {
          // If this happens during a replay something went wrong and it might block
          // the whole system.
          return getContainerFromFiber(nearestMounted);
        }

        targetInst = null;
      } else if (nearestMounted !== targetInst) {
        // If we get an event (ex: img onload) before committing that
        // component's mount, ignore it for now (that is, treat it as if it was an
        // event on a non-React tree). We might also consider queueing events and
        // dispatching them after the mount.
        targetInst = null;
      }
    }
  }

  dispatchEventForPluginEventSystem(domEventName, eventSystemFlags, nativeEvent, targetInst, targetContainer); // We're not blocked on anything.

  return null;
}

function addEventBubbleListener(target, eventType, listener) {
  target.addEventListener(eventType, listener, false);
  return listener;
}
function addEventCaptureListener(target, eventType, listener) {
  target.addEventListener(eventType, listener, true);
  return listener;
}
function addEventCaptureListenerWithPassiveFlag(target, eventType, listener, passive) {
  target.addEventListener(eventType, listener, {
    capture: true,
    passive: passive
  });
  return listener;
}
function addEventBubbleListenerWithPassiveFlag(target, eventType, listener, passive) {
  target.addEventListener(eventType, listener, {
    passive: passive
  });
  return listener;
}

/**
 * These variables store information about text content of a target node,
 * allowing comparison of content before and after a given event.
 *
 * Identify the node where selection currently begins, then observe
 * both its text content and its current position in the DOM. Since the
 * browser may natively replace the target node during composition, we can
 * use its position to find its replacement.
 *
 *
 */
var root = null;
var startText = null;
var fallbackText = null;
function initialize(nativeEventTarget) {
  root = nativeEventTarget;
  startText = getText();
  return true;
}
function reset() {
  root = null;
  startText = null;
  fallbackText = null;
}
function getData() {
  if (fallbackText) {
    return fallbackText;
  }

  var start;
  var startValue = startText;
  var startLength = startValue.length;
  var end;
  var endValue = getText();
  var endLength = endValue.length;

  for (start = 0; start < startLength; start++) {
    if (startValue[start] !== endValue[start]) {
      break;
    }
  }

  var minEnd = startLength - start;

  for (end = 1; end <= minEnd; end++) {
    if (startValue[startLength - end] !== endValue[endLength - end]) {
      break;
    }
  }

  var sliceTail = end > 1 ? 1 - end : undefined;
  fallbackText = endValue.slice(start, sliceTail);
  return fallbackText;
}
function getText() {
  if ('value' in root) {
    return root.value;
  }

  return root.textContent;
}

/**
 * `charCode` represents the actual "character code" and is safe to use with
 * `String.fromCharCode`. As such, only keys that correspond to printable
 * characters produce a valid `charCode`, the only exception to this is Enter.
 * The Tab-key is considered non-printable and does not have a `charCode`,
 * presumably because it does not produce a tab-character in browsers.
 *
 * @param {object} nativeEvent Native browser event.
 * @return {number} Normalized `charCode` property.
 */
function getEventCharCode(nativeEvent) {
  var charCode;
  var keyCode = nativeEvent.keyCode;

  if ('charCode' in nativeEvent) {
    charCode = nativeEvent.charCode; // FF does not set `charCode` for the Enter-key, check against `keyCode`.

    if (charCode === 0 && keyCode === 13) {
      charCode = 13;
    }
  } else {
    // IE8 does not implement `charCode`, but `keyCode` has the correct value.
    charCode = keyCode;
  } // IE and Edge (on Windows) and Chrome / Safari (on Windows and Linux)
  // report Enter as charCode 10 when ctrl is pressed.


  if (charCode === 10) {
    charCode = 13;
  } // Some non-printable keys are reported in `charCode`/`keyCode`, discard them.
  // Must not discard the (non-)printable Enter-key.


  if (charCode >= 32 || charCode === 13) {
    return charCode;
  }

  return 0;
}

function functionThatReturnsTrue() {
  return true;
}

function functionThatReturnsFalse() {
  return false;
} // This is intentionally a factory so that we have different returned constructors.
// If we had a single constructor, it would be megamorphic and engines would deopt.


function createSyntheticEvent(Interface) {
  /**
   * Synthetic events are dispatched by event plugins, typically in response to a
   * top-level event delegation handler.
   *
   * These systems should generally use pooling to reduce the frequency of garbage
   * collection. The system should check `isPersistent` to determine whether the
   * event should be released into the pool after being dispatched. Users that
   * need a persisted event should invoke `persist`.
   *
   * Synthetic events (and subclasses) implement the DOM Level 3 Events API by
   * normalizing browser quirks. Subclasses do not necessarily have to implement a
   * DOM interface; custom application-specific events can also subclass this.
   */
  function SyntheticBaseEvent(reactName, reactEventType, targetInst, nativeEvent, nativeEventTarget) {
    this._reactName = reactName;
    this._targetInst = targetInst;
    this.type = reactEventType;
    this.nativeEvent = nativeEvent;
    this.target = nativeEventTarget;
    this.currentTarget = null;

    for (var _propName in Interface) {
      if (!Interface.hasOwnProperty(_propName)) {
        continue;
      }

      var normalize = Interface[_propName];

      if (normalize) {
        this[_propName] = normalize(nativeEvent);
      } else {
        this[_propName] = nativeEvent[_propName];
      }
    }

    var defaultPrevented = nativeEvent.defaultPrevented != null ? nativeEvent.defaultPrevented : nativeEvent.returnValue === false;

    if (defaultPrevented) {
      this.isDefaultPrevented = functionThatReturnsTrue;
    } else {
      this.isDefaultPrevented = functionThatReturnsFalse;
    }

    this.isPropagationStopped = functionThatReturnsFalse;
    return this;
  }

  _assign(SyntheticBaseEvent.prototype, {
    preventDefault: function () {
      this.defaultPrevented = true;
      var event = this.nativeEvent;

      if (!event) {
        return;
      }

      if (event.preventDefault) {
        event.preventDefault(); // $FlowFixMe - flow is not aware of `unknown` in IE
      } else if (typeof event.returnValue !== 'unknown') {
        event.returnValue = false;
      }

      this.isDefaultPrevented = functionThatReturnsTrue;
    },
    stopPropagation: function () {
      var event = this.nativeEvent;

      if (!event) {
        return;
      }

      if (event.stopPropagation) {
        event.stopPropagation(); // $FlowFixMe - flow is not aware of `unknown` in IE
      } else if (typeof event.cancelBubble !== 'unknown') {
        // The ChangeEventPlugin registers a "propertychange" event for
        // IE. This event does not support bubbling or cancelling, and
        // any references to cancelBubble throw "Member not found".  A
        // typeof check of "unknown" circumvents this issue (and is also
        // IE specific).
        event.cancelBubble = true;
      }

      this.isPropagationStopped = functionThatReturnsTrue;
    },

    /**
     * We release all dispatched `SyntheticEvent`s after each event loop, adding
     * them back into the pool. This allows a way to hold onto a reference that
     * won't be added back into the pool.
     */
    persist: function () {// Modern event system doesn't use pooling.
    },

    /**
     * Checks if this event should be released back into the pool.
     *
     * @return {boolean} True if this should not be released, false otherwise.
     */
    isPersistent: functionThatReturnsTrue
  });

  return SyntheticBaseEvent;
}
/**
 * @interface Event
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */


var EventInterface = {
  eventPhase: 0,
  bubbles: 0,
  cancelable: 0,
  timeStamp: function (event) {
    return event.timeStamp || Date.now();
  },
  defaultPrevented: 0,
  isTrusted: 0
};
var SyntheticEvent = createSyntheticEvent(EventInterface);

var UIEventInterface = _assign({}, EventInterface, {
  view: 0,
  detail: 0
});

var SyntheticUIEvent = createSyntheticEvent(UIEventInterface);
var lastMovementX;
var lastMovementY;
var lastMouseEvent;

function updateMouseMovementPolyfillState(event) {
  if (event !== lastMouseEvent) {
    if (lastMouseEvent && event.type === 'mousemove') {
      lastMovementX = event.screenX - lastMouseEvent.screenX;
      lastMovementY = event.screenY - lastMouseEvent.screenY;
    } else {
      lastMovementX = 0;
      lastMovementY = 0;
    }

    lastMouseEvent = event;
  }
}
/**
 * @interface MouseEvent
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */


var MouseEventInterface = _assign({}, UIEventInterface, {
  screenX: 0,
  screenY: 0,
  clientX: 0,
  clientY: 0,
  pageX: 0,
  pageY: 0,
  ctrlKey: 0,
  shiftKey: 0,
  altKey: 0,
  metaKey: 0,
  getModifierState: getEventModifierState,
  button: 0,
  buttons: 0,
  relatedTarget: function (event) {
    if (event.relatedTarget === undefined) return event.fromElement === event.srcElement ? event.toElement : event.fromElement;
    return event.relatedTarget;
  },
  movementX: function (event) {
    if ('movementX' in event) {
      return event.movementX;
    }

    updateMouseMovementPolyfillState(event);
    return lastMovementX;
  },
  movementY: function (event) {
    if ('movementY' in event) {
      return event.movementY;
    } // Don't need to call updateMouseMovementPolyfillState() here
    // because it's guaranteed to have already run when movementX
    // was copied.


    return lastMovementY;
  }
});

var SyntheticMouseEvent = createSyntheticEvent(MouseEventInterface);
/**
 * @interface DragEvent
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */

var DragEventInterface = _assign({}, MouseEventInterface, {
  dataTransfer: 0
});

var SyntheticDragEvent = createSyntheticEvent(DragEventInterface);
/**
 * @interface FocusEvent
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */

var FocusEventInterface = _assign({}, UIEventInterface, {
  relatedTarget: 0
});

var SyntheticFocusEvent = createSyntheticEvent(FocusEventInterface);
/**
 * @interface Event
 * @see http://www.w3.org/TR/css3-animations/#AnimationEvent-interface
 * @see https://developer.mozilla.org/en-US/docs/Web/API/AnimationEvent
 */

var AnimationEventInterface = _assign({}, EventInterface, {
  animationName: 0,
  elapsedTime: 0,
  pseudoElement: 0
});

var SyntheticAnimationEvent = createSyntheticEvent(AnimationEventInterface);
/**
 * @interface Event
 * @see http://www.w3.org/TR/clipboard-apis/
 */

var ClipboardEventInterface = _assign({}, EventInterface, {
  clipboardData: function (event) {
    return 'clipboardData' in event ? event.clipboardData : window.clipboardData;
  }
});

var SyntheticClipboardEvent = createSyntheticEvent(ClipboardEventInterface);
/**
 * @interface Event
 * @see http://www.w3.org/TR/DOM-Level-3-Events/#events-compositionevents
 */

var CompositionEventInterface = _assign({}, EventInterface, {
  data: 0
});

var SyntheticCompositionEvent = createSyntheticEvent(CompositionEventInterface);
/**
 * @interface Event
 * @see http://www.w3.org/TR/2013/WD-DOM-Level-3-Events-20131105
 *      /#events-inputevents
 */
// Happens to share the same list for now.

var SyntheticInputEvent = SyntheticCompositionEvent;
/**
 * Normalization of deprecated HTML5 `key` values
 * @see https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent#Key_names
 */

var normalizeKey = {
  Esc: 'Escape',
  Spacebar: ' ',
  Left: 'ArrowLeft',
  Up: 'ArrowUp',
  Right: 'ArrowRight',
  Down: 'ArrowDown',
  Del: 'Delete',
  Win: 'OS',
  Menu: 'ContextMenu',
  Apps: 'ContextMenu',
  Scroll: 'ScrollLock',
  MozPrintableKey: 'Unidentified'
};
/**
 * Translation from legacy `keyCode` to HTML5 `key`
 * Only special keys supported, all others depend on keyboard layout or browser
 * @see https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent#Key_names
 */

var translateToKey = {
  '8': 'Backspace',
  '9': 'Tab',
  '12': 'Clear',
  '13': 'Enter',
  '16': 'Shift',
  '17': 'Control',
  '18': 'Alt',
  '19': 'Pause',
  '20': 'CapsLock',
  '27': 'Escape',
  '32': ' ',
  '33': 'PageUp',
  '34': 'PageDown',
  '35': 'End',
  '36': 'Home',
  '37': 'ArrowLeft',
  '38': 'ArrowUp',
  '39': 'ArrowRight',
  '40': 'ArrowDown',
  '45': 'Insert',
  '46': 'Delete',
  '112': 'F1',
  '113': 'F2',
  '114': 'F3',
  '115': 'F4',
  '116': 'F5',
  '117': 'F6',
  '118': 'F7',
  '119': 'F8',
  '120': 'F9',
  '121': 'F10',
  '122': 'F11',
  '123': 'F12',
  '144': 'NumLock',
  '145': 'ScrollLock',
  '224': 'Meta'
};
/**
 * @param {object} nativeEvent Native browser event.
 * @return {string} Normalized `key` property.
 */

function getEventKey(nativeEvent) {
  if (nativeEvent.key) {
    // Normalize inconsistent values reported by browsers due to
    // implementations of a working draft specification.
    // FireFox implements `key` but returns `MozPrintableKey` for all
    // printable characters (normalized to `Unidentified`), ignore it.
    var key = normalizeKey[nativeEvent.key] || nativeEvent.key;

    if (key !== 'Unidentified') {
      return key;
    }
  } // Browser does not implement `key`, polyfill as much of it as we can.


  if (nativeEvent.type === 'keypress') {
    var charCode = getEventCharCode(nativeEvent); // The enter-key is technically both printable and non-printable and can
    // thus be captured by `keypress`, no other non-printable key should.

    return charCode === 13 ? 'Enter' : String.fromCharCode(charCode);
  }

  if (nativeEvent.type === 'keydown' || nativeEvent.type === 'keyup') {
    // While user keyboard layout determines the actual meaning of each
    // `keyCode` value, almost all function keys have a universal value.
    return translateToKey[nativeEvent.keyCode] || 'Unidentified';
  }

  return '';
}
/**
 * Translation from modifier key to the associated property in the event.
 * @see http://www.w3.org/TR/DOM-Level-3-Events/#keys-Modifiers
 */


var modifierKeyToProp = {
  Alt: 'altKey',
  Control: 'ctrlKey',
  Meta: 'metaKey',
  Shift: 'shiftKey'
}; // Older browsers (Safari <= 10, iOS Safari <= 10.2) do not support
// getModifierState. If getModifierState is not supported, we map it to a set of
// modifier keys exposed by the event. In this case, Lock-keys are not supported.

function modifierStateGetter(keyArg) {
  var syntheticEvent = this;
  var nativeEvent = syntheticEvent.nativeEvent;

  if (nativeEvent.getModifierState) {
    return nativeEvent.getModifierState(keyArg);
  }

  var keyProp = modifierKeyToProp[keyArg];
  return keyProp ? !!nativeEvent[keyProp] : false;
}

function getEventModifierState(nativeEvent) {
  return modifierStateGetter;
}
/**
 * @interface KeyboardEvent
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */


var KeyboardEventInterface = _assign({}, UIEventInterface, {
  key: getEventKey,
  code: 0,
  location: 0,
  ctrlKey: 0,
  shiftKey: 0,
  altKey: 0,
  metaKey: 0,
  repeat: 0,
  locale: 0,
  getModifierState: getEventModifierState,
  // Legacy Interface
  charCode: function (event) {
    // `charCode` is the result of a KeyPress event and represents the value of
    // the actual printable character.
    // KeyPress is deprecated, but its replacement is not yet final and not
    // implemented in any major browser. Only KeyPress has charCode.
    if (event.type === 'keypress') {
      return getEventCharCode(event);
    }

    return 0;
  },
  keyCode: function (event) {
    // `keyCode` is the result of a KeyDown/Up event and represents the value of
    // physical keyboard key.
    // The actual meaning of the value depends on the users' keyboard layout
    // which cannot be detected. Assuming that it is a US keyboard layout
    // provides a surprisingly accurate mapping for US and European users.
    // Due to this, it is left to the user to implement at this time.
    if (event.type === 'keydown' || event.type === 'keyup') {
      return event.keyCode;
    }

    return 0;
  },
  which: function (event) {
    // `which` is an alias for either `keyCode` or `charCode` depending on the
    // type of the event.
    if (event.type === 'keypress') {
      return getEventCharCode(event);
    }

    if (event.type === 'keydown' || event.type === 'keyup') {
      return event.keyCode;
    }

    return 0;
  }
});

var SyntheticKeyboardEvent = createSyntheticEvent(KeyboardEventInterface);
/**
 * @interface PointerEvent
 * @see http://www.w3.org/TR/pointerevents/
 */

var PointerEventInterface = _assign({}, MouseEventInterface, {
  pointerId: 0,
  width: 0,
  height: 0,
  pressure: 0,
  tangentialPressure: 0,
  tiltX: 0,
  tiltY: 0,
  twist: 0,
  pointerType: 0,
  isPrimary: 0
});

var SyntheticPointerEvent = createSyntheticEvent(PointerEventInterface);
/**
 * @interface TouchEvent
 * @see http://www.w3.org/TR/touch-events/
 */

var TouchEventInterface = _assign({}, UIEventInterface, {
  touches: 0,
  targetTouches: 0,
  changedTouches: 0,
  altKey: 0,
  metaKey: 0,
  ctrlKey: 0,
  shiftKey: 0,
  getModifierState: getEventModifierState
});

var SyntheticTouchEvent = createSyntheticEvent(TouchEventInterface);
/**
 * @interface Event
 * @see http://www.w3.org/TR/2009/WD-css3-transitions-20090320/#transition-events-
 * @see https://developer.mozilla.org/en-US/docs/Web/API/TransitionEvent
 */

var TransitionEventInterface = _assign({}, EventInterface, {
  propertyName: 0,
  elapsedTime: 0,
  pseudoElement: 0
});

var SyntheticTransitionEvent = createSyntheticEvent(TransitionEventInterface);
/**
 * @interface WheelEvent
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */

var WheelEventInterface = _assign({}, MouseEventInterface, {
  deltaX: function (event) {
    return 'deltaX' in event ? event.deltaX : // Fallback to `wheelDeltaX` for Webkit and normalize (right is positive).
    'wheelDeltaX' in event ? -event.wheelDeltaX : 0;
  },
  deltaY: function (event) {
    return 'deltaY' in event ? event.deltaY : // Fallback to `wheelDeltaY` for Webkit and normalize (down is positive).
    'wheelDeltaY' in event ? -event.wheelDeltaY : // Fallback to `wheelDelta` for IE<9 and normalize (down is positive).
    'wheelDelta' in event ? -event.wheelDelta : 0;
  },
  deltaZ: 0,
  // Browsers without "deltaMode" is reporting in raw wheel delta where one
  // notch on the scroll is always +/- 120, roughly equivalent to pixels.
  // A good approximation of DOM_DELTA_LINE (1) is 5% of viewport size or
  // ~40 pixels, for DOM_DELTA_SCREEN (2) it is 87.5% of viewport size.
  deltaMode: 0
});

var SyntheticWheelEvent = createSyntheticEvent(WheelEventInterface);

var END_KEYCODES = [9, 13, 27, 32]; // Tab, Return, Esc, Space

var START_KEYCODE = 229;
var canUseCompositionEvent = canUseDOM && 'CompositionEvent' in window;
var documentMode = null;

if (canUseDOM && 'documentMode' in document) {
  documentMode = document.documentMode;
} // Webkit offers a very useful `textInput` event that can be used to
// directly represent `beforeInput`. The IE `textinput` event is not as
// useful, so we don't use it.


var canUseTextInputEvent = canUseDOM && 'TextEvent' in window && !documentMode; // In IE9+, we have access to composition events, but the data supplied
// by the native compositionend event may be incorrect. Japanese ideographic
// spaces, for instance (\u3000) are not recorded correctly.

var useFallbackCompositionData = canUseDOM && (!canUseCompositionEvent || documentMode && documentMode > 8 && documentMode <= 11);
var SPACEBAR_CODE = 32;
var SPACEBAR_CHAR = String.fromCharCode(SPACEBAR_CODE);

function registerEvents() {
  registerTwoPhaseEvent('onBeforeInput', ['compositionend', 'keypress', 'textInput', 'paste']);
  registerTwoPhaseEvent('onCompositionEnd', ['compositionend', 'focusout', 'keydown', 'keypress', 'keyup', 'mousedown']);
  registerTwoPhaseEvent('onCompositionStart', ['compositionstart', 'focusout', 'keydown', 'keypress', 'keyup', 'mousedown']);
  registerTwoPhaseEvent('onCompositionUpdate', ['compositionupdate', 'focusout', 'keydown', 'keypress', 'keyup', 'mousedown']);
} // Track whether we've ever handled a keypress on the space key.


var hasSpaceKeypress = false;
/**
 * Return whether a native keypress event is assumed to be a command.
 * This is required because Firefox fires `keypress` events for key commands
 * (cut, copy, select-all, etc.) even though no character is inserted.
 */

function isKeypressCommand(nativeEvent) {
  return (nativeEvent.ctrlKey || nativeEvent.altKey || nativeEvent.metaKey) && // ctrlKey && altKey is equivalent to AltGr, and is not a command.
  !(nativeEvent.ctrlKey && nativeEvent.altKey);
}
/**
 * Translate native top level events into event types.
 */


function getCompositionEventType(domEventName) {
  switch (domEventName) {
    case 'compositionstart':
      return 'onCompositionStart';

    case 'compositionend':
      return 'onCompositionEnd';

    case 'compositionupdate':
      return 'onCompositionUpdate';
  }
}
/**
 * Does our fallback best-guess model think this event signifies that
 * composition has begun?
 */


function isFallbackCompositionStart(domEventName, nativeEvent) {
  return domEventName === 'keydown' && nativeEvent.keyCode === START_KEYCODE;
}
/**
 * Does our fallback mode think that this event is the end of composition?
 */


function isFallbackCompositionEnd(domEventName, nativeEvent) {
  switch (domEventName) {
    case 'keyup':
      // Command keys insert or clear IME input.
      return END_KEYCODES.indexOf(nativeEvent.keyCode) !== -1;

    case 'keydown':
      // Expect IME keyCode on each keydown. If we get any other
      // code we must have exited earlier.
      return nativeEvent.keyCode !== START_KEYCODE;

    case 'keypress':
    case 'mousedown':
    case 'focusout':
      // Events are not possible without cancelling IME.
      return true;

    default:
      return false;
  }
}
/**
 * Google Input Tools provides composition data via a CustomEvent,
 * with the `data` property populated in the `detail` object. If this
 * is available on the event object, use it. If not, this is a plain
 * composition event and we have nothing special to extract.
 *
 * @param {object} nativeEvent
 * @return {?string}
 */


function getDataFromCustomEvent(nativeEvent) {
  var detail = nativeEvent.detail;

  if (typeof detail === 'object' && 'data' in detail) {
    return detail.data;
  }

  return null;
}
/**
 * Check if a composition event was triggered by Korean IME.
 * Our fallback mode does not work well with IE's Korean IME,
 * so just use native composition events when Korean IME is used.
 * Although CompositionEvent.locale property is deprecated,
 * it is available in IE, where our fallback mode is enabled.
 *
 * @param {object} nativeEvent
 * @return {boolean}
 */


function isUsingKoreanIME(nativeEvent) {
  return nativeEvent.locale === 'ko';
} // Track the current IME composition status, if any.


var isComposing = false;
/**
 * @return {?object} A SyntheticCompositionEvent.
 */

function extractCompositionEvent(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget) {
  var eventType;
  var fallbackData;

  if (canUseCompositionEvent) {
    eventType = getCompositionEventType(domEventName);
  } else if (!isComposing) {
    if (isFallbackCompositionStart(domEventName, nativeEvent)) {
      eventType = 'onCompositionStart';
    }
  } else if (isFallbackCompositionEnd(domEventName, nativeEvent)) {
    eventType = 'onCompositionEnd';
  }

  if (!eventType) {
    return null;
  }

  if (useFallbackCompositionData && !isUsingKoreanIME(nativeEvent)) {
    // The current composition is stored statically and must not be
    // overwritten while composition continues.
    if (!isComposing && eventType === 'onCompositionStart') {
      isComposing = initialize(nativeEventTarget);
    } else if (eventType === 'onCompositionEnd') {
      if (isComposing) {
        fallbackData = getData();
      }
    }
  }

  var listeners = accumulateTwoPhaseListeners(targetInst, eventType);

  if (listeners.length > 0) {
    var event = new SyntheticCompositionEvent(eventType, domEventName, null, nativeEvent, nativeEventTarget);
    dispatchQueue.push({
      event: event,
      listeners: listeners
    });

    if (fallbackData) {
      // Inject data generated from fallback path into the synthetic event.
      // This matches the property of native CompositionEventInterface.
      event.data = fallbackData;
    } else {
      var customData = getDataFromCustomEvent(nativeEvent);

      if (customData !== null) {
        event.data = customData;
      }
    }
  }
}

function getNativeBeforeInputChars(domEventName, nativeEvent) {
  switch (domEventName) {
    case 'compositionend':
      return getDataFromCustomEvent(nativeEvent);

    case 'keypress':
      /**
       * If native `textInput` events are available, our goal is to make
       * use of them. However, there is a special case: the spacebar key.
       * In Webkit, preventing default on a spacebar `textInput` event
       * cancels character insertion, but it *also* causes the browser
       * to fall back to its default spacebar behavior of scrolling the
       * page.
       *
       * Tracking at:
       * https://code.google.com/p/chromium/issues/detail?id=355103
       *
       * To avoid this issue, use the keypress event as if no `textInput`
       * event is available.
       */
      var which = nativeEvent.which;

      if (which !== SPACEBAR_CODE) {
        return null;
      }

      hasSpaceKeypress = true;
      return SPACEBAR_CHAR;

    case 'textInput':
      // Record the characters to be added to the DOM.
      var chars = nativeEvent.data; // If it's a spacebar character, assume that we have already handled
      // it at the keypress level and bail immediately. Android Chrome
      // doesn't give us keycodes, so we need to ignore it.

      if (chars === SPACEBAR_CHAR && hasSpaceKeypress) {
        return null;
      }

      return chars;

    default:
      // For other native event types, do nothing.
      return null;
  }
}
/**
 * For browsers that do not provide the `textInput` event, extract the
 * appropriate string to use for SyntheticInputEvent.
 */


function getFallbackBeforeInputChars(domEventName, nativeEvent) {
  // If we are currently composing (IME) and using a fallback to do so,
  // try to extract the composed characters from the fallback object.
  // If composition event is available, we extract a string only at
  // compositionevent, otherwise extract it at fallback events.
  if (isComposing) {
    if (domEventName === 'compositionend' || !canUseCompositionEvent && isFallbackCompositionEnd(domEventName, nativeEvent)) {
      var chars = getData();
      reset();
      isComposing = false;
      return chars;
    }

    return null;
  }

  switch (domEventName) {
    case 'paste':
      // If a paste event occurs after a keypress, throw out the input
      // chars. Paste events should not lead to BeforeInput events.
      return null;

    case 'keypress':
      /**
       * As of v27, Firefox may fire keypress events even when no character
       * will be inserted. A few possibilities:
       *
       * - `which` is `0`. Arrow keys, Esc key, etc.
       *
       * - `which` is the pressed key code, but no char is available.
       *   Ex: 'AltGr + d` in Polish. There is no modified character for
       *   this key combination and no character is inserted into the
       *   document, but FF fires the keypress for char code `100` anyway.
       *   No `input` event will occur.
       *
       * - `which` is the pressed key code, but a command combination is
       *   being used. Ex: `Cmd+C`. No character is inserted, and no
       *   `input` event will occur.
       */
      if (!isKeypressCommand(nativeEvent)) {
        // IE fires the `keypress` event when a user types an emoji via
        // Touch keyboard of Windows.  In such a case, the `char` property
        // holds an emoji character like `\uD83D\uDE0A`.  Because its length
        // is 2, the property `which` does not represent an emoji correctly.
        // In such a case, we directly return the `char` property instead of
        // using `which`.
        if (nativeEvent.char && nativeEvent.char.length > 1) {
          return nativeEvent.char;
        } else if (nativeEvent.which) {
          return String.fromCharCode(nativeEvent.which);
        }
      }

      return null;

    case 'compositionend':
      return useFallbackCompositionData && !isUsingKoreanIME(nativeEvent) ? null : nativeEvent.data;

    default:
      return null;
  }
}
/**
 * Extract a SyntheticInputEvent for `beforeInput`, based on either native
 * `textInput` or fallback behavior.
 *
 * @return {?object} A SyntheticInputEvent.
 */


function extractBeforeInputEvent(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget) {
  var chars;

  if (canUseTextInputEvent) {
    chars = getNativeBeforeInputChars(domEventName, nativeEvent);
  } else {
    chars = getFallbackBeforeInputChars(domEventName, nativeEvent);
  } // If no characters are being inserted, no BeforeInput event should
  // be fired.


  if (!chars) {
    return null;
  }

  var listeners = accumulateTwoPhaseListeners(targetInst, 'onBeforeInput');

  if (listeners.length > 0) {
    var event = new SyntheticInputEvent('onBeforeInput', 'beforeinput', null, nativeEvent, nativeEventTarget);
    dispatchQueue.push({
      event: event,
      listeners: listeners
    });
    event.data = chars;
  }
}
/**
 * Create an `onBeforeInput` event to match
 * http://www.w3.org/TR/2013/WD-DOM-Level-3-Events-20131105/#events-inputevents.
 *
 * This event plugin is based on the native `textInput` event
 * available in Chrome, Safari, Opera, and IE. This event fires after
 * `onKeyPress` and `onCompositionEnd`, but before `onInput`.
 *
 * `beforeInput` is spec'd but not implemented in any browsers, and
 * the `input` event does not provide any useful information about what has
 * actually been added, contrary to the spec. Thus, `textInput` is the best
 * available event to identify the characters that have actually been inserted
 * into the target node.
 *
 * This plugin is also responsible for emitting `composition` events, thus
 * allowing us to share composition fallback code for both `beforeInput` and
 * `composition` event types.
 */


function extractEvents(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags, targetContainer) {
  extractCompositionEvent(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget);
  extractBeforeInputEvent(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget);
}

/**
 * @see http://www.whatwg.org/specs/web-apps/current-work/multipage/the-input-element.html#input-type-attr-summary
 */
var supportedInputTypes = {
  color: true,
  date: true,
  datetime: true,
  'datetime-local': true,
  email: true,
  month: true,
  number: true,
  password: true,
  range: true,
  search: true,
  tel: true,
  text: true,
  time: true,
  url: true,
  week: true
};

function isTextInputElement(elem) {
  var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();

  if (nodeName === 'input') {
    return !!supportedInputTypes[elem.type];
  }

  if (nodeName === 'textarea') {
    return true;
  }

  return false;
}

/**
 * Checks if an event is supported in the current execution environment.
 *
 * NOTE: This will not work correctly for non-generic events such as `change`,
 * `reset`, `load`, `error`, and `select`.
 *
 * Borrows from Modernizr.
 *
 * @param {string} eventNameSuffix Event name, e.g. "click".
 * @return {boolean} True if the event is supported.
 * @internal
 * @license Modernizr 3.0.0pre (Custom Build) | MIT
 */

function isEventSupported(eventNameSuffix) {
  if (!canUseDOM) {
    return false;
  }

  var eventName = 'on' + eventNameSuffix;
  var isSupported = (eventName in document);

  if (!isSupported) {
    var element = document.createElement('div');
    element.setAttribute(eventName, 'return;');
    isSupported = typeof element[eventName] === 'function';
  }

  return isSupported;
}

function registerEvents$1() {
  registerTwoPhaseEvent('onChange', ['change', 'click', 'focusin', 'focusout', 'input', 'keydown', 'keyup', 'selectionchange']);
}

function createAndAccumulateChangeEvent(dispatchQueue, inst, nativeEvent, target) {
  // Flag this event loop as needing state restore.
  enqueueStateRestore(target);
  var listeners = accumulateTwoPhaseListeners(inst, 'onChange');

  if (listeners.length > 0) {
    var event = new SyntheticEvent('onChange', 'change', null, nativeEvent, target);
    dispatchQueue.push({
      event: event,
      listeners: listeners
    });
  }
}
/**
 * For IE shims
 */


var activeElement = null;
var activeElementInst = null;
/**
 * SECTION: handle `change` event
 */

function shouldUseChangeEvent(elem) {
  var nodeName = elem.nodeName && elem.nodeName.toLowerCase();
  return nodeName === 'select' || nodeName === 'input' && elem.type === 'file';
}

function manualDispatchChangeEvent(nativeEvent) {
  var dispatchQueue = [];
  createAndAccumulateChangeEvent(dispatchQueue, activeElementInst, nativeEvent, getEventTarget(nativeEvent)); // If change and propertychange bubbled, we'd just bind to it like all the
  // other events and have it go through ReactBrowserEventEmitter. Since it
  // doesn't, we manually listen for the events and so we have to enqueue and
  // process the abstract event manually.
  //
  // Batching is necessary here in order to ensure that all event handlers run
  // before the next rerender (including event handlers attached to ancestor
  // elements instead of directly on the input). Without this, controlled
  // components don't work properly in conjunction with event bubbling because
  // the component is rerendered and the value reverted before all the event
  // handlers can run. See https://github.com/facebook/react/issues/708.

  batchedUpdates(runEventInBatch, dispatchQueue);
}

function runEventInBatch(dispatchQueue) {
  processDispatchQueue(dispatchQueue, 0);
}

function getInstIfValueChanged(targetInst) {
  var targetNode = getNodeFromInstance(targetInst);

  if (updateValueIfChanged(targetNode)) {
    return targetInst;
  }
}

function getTargetInstForChangeEvent(domEventName, targetInst) {
  if (domEventName === 'change') {
    return targetInst;
  }
}
/**
 * SECTION: handle `input` event
 */


var isInputEventSupported = false;

if (canUseDOM) {
  // IE9 claims to support the input event but fails to trigger it when
  // deleting text, so we ignore its input events.
  isInputEventSupported = isEventSupported('input') && (!document.documentMode || document.documentMode > 9);
}
/**
 * (For IE <=9) Starts tracking propertychange events on the passed-in element
 * and override the value property so that we can distinguish user events from
 * value changes in JS.
 */


function startWatchingForValueChange(target, targetInst) {
  activeElement = target;
  activeElementInst = targetInst;
  activeElement.attachEvent('onpropertychange', handlePropertyChange);
}
/**
 * (For IE <=9) Removes the event listeners from the currently-tracked element,
 * if any exists.
 */


function stopWatchingForValueChange() {
  if (!activeElement) {
    return;
  }

  activeElement.detachEvent('onpropertychange', handlePropertyChange);
  activeElement = null;
  activeElementInst = null;
}
/**
 * (For IE <=9) Handles a propertychange event, sending a `change` event if
 * the value of the active element has changed.
 */


function handlePropertyChange(nativeEvent) {
  if (nativeEvent.propertyName !== 'value') {
    return;
  }

  if (getInstIfValueChanged(activeElementInst)) {
    manualDispatchChangeEvent(nativeEvent);
  }
}

function handleEventsForInputEventPolyfill(domEventName, target, targetInst) {
  if (domEventName === 'focusin') {
    // In IE9, propertychange fires for most input events but is buggy and
    // doesn't fire when text is deleted, but conveniently, selectionchange
    // appears to fire in all of the remaining cases so we catch those and
    // forward the event if the value has changed
    // In either case, we don't want to call the event handler if the value
    // is changed from JS so we redefine a setter for `.value` that updates
    // our activeElementValue variable, allowing us to ignore those changes
    //
    // stopWatching() should be a noop here but we call it just in case we
    // missed a blur event somehow.
    stopWatchingForValueChange();
    startWatchingForValueChange(target, targetInst);
  } else if (domEventName === 'focusout') {
    stopWatchingForValueChange();
  }
} // For IE8 and IE9.


function getTargetInstForInputEventPolyfill(domEventName, targetInst) {
  if (domEventName === 'selectionchange' || domEventName === 'keyup' || domEventName === 'keydown') {
    // On the selectionchange event, the target is just document which isn't
    // helpful for us so just check activeElement instead.
    //
    // 99% of the time, keydown and keyup aren't necessary. IE8 fails to fire
    // propertychange on the first input event after setting `value` from a
    // script and fires only keydown, keypress, keyup. Catching keyup usually
    // gets it and catching keydown lets us fire an event for the first
    // keystroke if user does a key repeat (it'll be a little delayed: right
    // before the second keystroke). Other input methods (e.g., paste) seem to
    // fire selectionchange normally.
    return getInstIfValueChanged(activeElementInst);
  }
}
/**
 * SECTION: handle `click` event
 */


function shouldUseClickEvent(elem) {
  // Use the `click` event to detect changes to checkbox and radio inputs.
  // This approach works across all browsers, whereas `change` does not fire
  // until `blur` in IE8.
  var nodeName = elem.nodeName;
  return nodeName && nodeName.toLowerCase() === 'input' && (elem.type === 'checkbox' || elem.type === 'radio');
}

function getTargetInstForClickEvent(domEventName, targetInst) {
  if (domEventName === 'click') {
    return getInstIfValueChanged(targetInst);
  }
}

function getTargetInstForInputOrChangeEvent(domEventName, targetInst) {
  if (domEventName === 'input' || domEventName === 'change') {
    return getInstIfValueChanged(targetInst);
  }
}

function handleControlledInputBlur(node) {
  var state = node._wrapperState;

  if (!state || !state.controlled || node.type !== 'number') {
    return;
  }

  {
    // If controlled, assign the value attribute to the current value on blur
    setDefaultValue(node, 'number', node.value);
  }
}
/**
 * This plugin creates an `onChange` event that normalizes change events
 * across form elements. This event fires at a time when it's possible to
 * change the element's value without seeing a flicker.
 *
 * Supported elements are:
 * - input (see `isTextInputElement`)
 * - textarea
 * - select
 */


function extractEvents$1(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags, targetContainer) {
  var targetNode = targetInst ? getNodeFromInstance(targetInst) : window;
  var getTargetInstFunc, handleEventFunc;

  if (shouldUseChangeEvent(targetNode)) {
    getTargetInstFunc = getTargetInstForChangeEvent;
  } else if (isTextInputElement(targetNode)) {
    if (isInputEventSupported) {
      getTargetInstFunc = getTargetInstForInputOrChangeEvent;
    } else {
      getTargetInstFunc = getTargetInstForInputEventPolyfill;
      handleEventFunc = handleEventsForInputEventPolyfill;
    }
  } else if (shouldUseClickEvent(targetNode)) {
    getTargetInstFunc = getTargetInstForClickEvent;
  }

  if (getTargetInstFunc) {
    var inst = getTargetInstFunc(domEventName, targetInst);

    if (inst) {
      createAndAccumulateChangeEvent(dispatchQueue, inst, nativeEvent, nativeEventTarget);
      return;
    }
  }

  if (handleEventFunc) {
    handleEventFunc(domEventName, targetNode, targetInst);
  } // When blurring, set the value attribute for number inputs


  if (domEventName === 'focusout') {
    handleControlledInputBlur(targetNode);
  }
}

function registerEvents$2() {
  registerDirectEvent('onMouseEnter', ['mouseout', 'mouseover']);
  registerDirectEvent('onMouseLeave', ['mouseout', 'mouseover']);
  registerDirectEvent('onPointerEnter', ['pointerout', 'pointerover']);
  registerDirectEvent('onPointerLeave', ['pointerout', 'pointerover']);
}
/**
 * For almost every interaction we care about, there will be both a top-level
 * `mouseover` and `mouseout` event that occurs. Only use `mouseout` so that
 * we do not extract duplicate events. However, moving the mouse into the
 * browser from outside will not fire a `mouseout` event. In this case, we use
 * the `mouseover` top-level event.
 */


function extractEvents$2(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags, targetContainer) {
  var isOverEvent = domEventName === 'mouseover' || domEventName === 'pointerover';
  var isOutEvent = domEventName === 'mouseout' || domEventName === 'pointerout';

  if (isOverEvent && (eventSystemFlags & IS_REPLAYED) === 0) {
    // If this is an over event with a target, we might have already dispatched
    // the event in the out event of the other target. If this is replayed,
    // then it's because we couldn't dispatch against this target previously
    // so we have to do it now instead.
    var related = nativeEvent.relatedTarget || nativeEvent.fromElement;

    if (related) {
      // If the related node is managed by React, we can assume that we have
      // already dispatched the corresponding events during its mouseout.
      if (getClosestInstanceFromNode(related) || isContainerMarkedAsRoot(related)) {
        return;
      }
    }
  }

  if (!isOutEvent && !isOverEvent) {
    // Must not be a mouse or pointer in or out - ignoring.
    return;
  }

  var win; // TODO: why is this nullable in the types but we read from it?

  if (nativeEventTarget.window === nativeEventTarget) {
    // `nativeEventTarget` is probably a window object.
    win = nativeEventTarget;
  } else {
    // TODO: Figure out why `ownerDocument` is sometimes undefined in IE8.
    var doc = nativeEventTarget.ownerDocument;

    if (doc) {
      win = doc.defaultView || doc.parentWindow;
    } else {
      win = window;
    }
  }

  var from;
  var to;

  if (isOutEvent) {
    var _related = nativeEvent.relatedTarget || nativeEvent.toElement;

    from = targetInst;
    to = _related ? getClosestInstanceFromNode(_related) : null;

    if (to !== null) {
      var nearestMounted = getNearestMountedFiber(to);

      if (to !== nearestMounted || to.tag !== HostComponent && to.tag !== HostText) {
        to = null;
      }
    }
  } else {
    // Moving to a node from outside the window.
    from = null;
    to = targetInst;
  }

  if (from === to) {
    // Nothing pertains to our managed components.
    return;
  }

  var SyntheticEventCtor = SyntheticMouseEvent;
  var leaveEventType = 'onMouseLeave';
  var enterEventType = 'onMouseEnter';
  var eventTypePrefix = 'mouse';

  if (domEventName === 'pointerout' || domEventName === 'pointerover') {
    SyntheticEventCtor = SyntheticPointerEvent;
    leaveEventType = 'onPointerLeave';
    enterEventType = 'onPointerEnter';
    eventTypePrefix = 'pointer';
  }

  var fromNode = from == null ? win : getNodeFromInstance(from);
  var toNode = to == null ? win : getNodeFromInstance(to);
  var leave = new SyntheticEventCtor(leaveEventType, eventTypePrefix + 'leave', from, nativeEvent, nativeEventTarget);
  leave.target = fromNode;
  leave.relatedTarget = toNode;
  var enter = null; // We should only process this nativeEvent if we are processing
  // the first ancestor. Next time, we will ignore the event.

  var nativeTargetInst = getClosestInstanceFromNode(nativeEventTarget);

  if (nativeTargetInst === targetInst) {
    var enterEvent = new SyntheticEventCtor(enterEventType, eventTypePrefix + 'enter', to, nativeEvent, nativeEventTarget);
    enterEvent.target = toNode;
    enterEvent.relatedTarget = fromNode;
    enter = enterEvent;
  }

  accumulateEnterLeaveTwoPhaseListeners(dispatchQueue, leave, enter, from, to);
}

/**
 * inlined Object.is polyfill to avoid requiring consumers ship their own
 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
 */
function is(x, y) {
  return x === y && (x !== 0 || 1 / x === 1 / y) || x !== x && y !== y // eslint-disable-line no-self-compare
  ;
}

var objectIs = typeof Object.is === 'function' ? Object.is : is;

var hasOwnProperty$2 = Object.prototype.hasOwnProperty;
/**
 * Performs equality by iterating through keys on an object and returning false
 * when any key has values which are not strictly equal between the arguments.
 * Returns true when the values of all keys are strictly equal.
 */

function shallowEqual(objA, objB) {
  if (objectIs(objA, objB)) {
    return true;
  }

  if (typeof objA !== 'object' || objA === null || typeof objB !== 'object' || objB === null) {
    return false;
  }

  var keysA = Object.keys(objA);
  var keysB = Object.keys(objB);

  if (keysA.length !== keysB.length) {
    return false;
  } // Test for A's keys different from B.


  for (var i = 0; i < keysA.length; i++) {
    if (!hasOwnProperty$2.call(objB, keysA[i]) || !objectIs(objA[keysA[i]], objB[keysA[i]])) {
      return false;
    }
  }

  return true;
}

/**
 * Given any node return the first leaf node without children.
 *
 * @param {DOMElement|DOMTextNode} node
 * @return {DOMElement|DOMTextNode}
 */

function getLeafNode(node) {
  while (node && node.firstChild) {
    node = node.firstChild;
  }

  return node;
}
/**
 * Get the next sibling within a container. This will walk up the
 * DOM if a node's siblings have been exhausted.
 *
 * @param {DOMElement|DOMTextNode} node
 * @return {?DOMElement|DOMTextNode}
 */


function getSiblingNode(node) {
  while (node) {
    if (node.nextSibling) {
      return node.nextSibling;
    }

    node = node.parentNode;
  }
}
/**
 * Get object describing the nodes which contain characters at offset.
 *
 * @param {DOMElement|DOMTextNode} root
 * @param {number} offset
 * @return {?object}
 */


function getNodeForCharacterOffset(root, offset) {
  var node = getLeafNode(root);
  var nodeStart = 0;
  var nodeEnd = 0;

  while (node) {
    if (node.nodeType === TEXT_NODE) {
      nodeEnd = nodeStart + node.textContent.length;

      if (nodeStart <= offset && nodeEnd >= offset) {
        return {
          node: node,
          offset: offset - nodeStart
        };
      }

      nodeStart = nodeEnd;
    }

    node = getLeafNode(getSiblingNode(node));
  }
}

/**
 * @param {DOMElement} outerNode
 * @return {?object}
 */

function getOffsets(outerNode) {
  var ownerDocument = outerNode.ownerDocument;
  var win = ownerDocument && ownerDocument.defaultView || window;
  var selection = win.getSelection && win.getSelection();

  if (!selection || selection.rangeCount === 0) {
    return null;
  }

  var anchorNode = selection.anchorNode,
      anchorOffset = selection.anchorOffset,
      focusNode = selection.focusNode,
      focusOffset = selection.focusOffset; // In Firefox, anchorNode and focusNode can be "anonymous divs", e.g. the
  // up/down buttons on an <input type="number">. Anonymous divs do not seem to
  // expose properties, triggering a "Permission denied error" if any of its
  // properties are accessed. The only seemingly possible way to avoid erroring
  // is to access a property that typically works for non-anonymous divs and
  // catch any error that may otherwise arise. See
  // https://bugzilla.mozilla.org/show_bug.cgi?id=208427

  try {
    /* eslint-disable no-unused-expressions */
    anchorNode.nodeType;
    focusNode.nodeType;
    /* eslint-enable no-unused-expressions */
  } catch (e) {
    return null;
  }

  return getModernOffsetsFromPoints(outerNode, anchorNode, anchorOffset, focusNode, focusOffset);
}
/**
 * Returns {start, end} where `start` is the character/codepoint index of
 * (anchorNode, anchorOffset) within the textContent of `outerNode`, and
 * `end` is the index of (focusNode, focusOffset).
 *
 * Returns null if you pass in garbage input but we should probably just crash.
 *
 * Exported only for testing.
 */

function getModernOffsetsFromPoints(outerNode, anchorNode, anchorOffset, focusNode, focusOffset) {
  var length = 0;
  var start = -1;
  var end = -1;
  var indexWithinAnchor = 0;
  var indexWithinFocus = 0;
  var node = outerNode;
  var parentNode = null;

  outer: while (true) {
    var next = null;

    while (true) {
      if (node === anchorNode && (anchorOffset === 0 || node.nodeType === TEXT_NODE)) {
        start = length + anchorOffset;
      }

      if (node === focusNode && (focusOffset === 0 || node.nodeType === TEXT_NODE)) {
        end = length + focusOffset;
      }

      if (node.nodeType === TEXT_NODE) {
        length += node.nodeValue.length;
      }

      if ((next = node.firstChild) === null) {
        break;
      } // Moving from `node` to its first child `next`.


      parentNode = node;
      node = next;
    }

    while (true) {
      if (node === outerNode) {
        // If `outerNode` has children, this is always the second time visiting
        // it. If it has no children, this is still the first loop, and the only
        // valid selection is anchorNode and focusNode both equal to this node
        // and both offsets 0, in which case we will have handled above.
        break outer;
      }

      if (parentNode === anchorNode && ++indexWithinAnchor === anchorOffset) {
        start = length;
      }

      if (parentNode === focusNode && ++indexWithinFocus === focusOffset) {
        end = length;
      }

      if ((next = node.nextSibling) !== null) {
        break;
      }

      node = parentNode;
      parentNode = node.parentNode;
    } // Moving from `node` to its next sibling `next`.


    node = next;
  }

  if (start === -1 || end === -1) {
    // This should never happen. (Would happen if the anchor/focus nodes aren't
    // actually inside the passed-in node.)
    return null;
  }

  return {
    start: start,
    end: end
  };
}
/**
 * In modern non-IE browsers, we can support both forward and backward
 * selections.
 *
 * Note: IE10+ supports the Selection object, but it does not support
 * the `extend` method, which means that even in modern IE, it's not possible
 * to programmatically create a backward selection. Thus, for all IE
 * versions, we use the old IE API to create our selections.
 *
 * @param {DOMElement|DOMTextNode} node
 * @param {object} offsets
 */

function setOffsets(node, offsets) {
  var doc = node.ownerDocument || document;
  var win = doc && doc.defaultView || window; // Edge fails with "Object expected" in some scenarios.
  // (For instance: TinyMCE editor used in a list component that supports pasting to add more,
  // fails when pasting 100+ items)

  if (!win.getSelection) {
    return;
  }

  var selection = win.getSelection();
  var length = node.textContent.length;
  var start = Math.min(offsets.start, length);
  var end = offsets.end === undefined ? start : Math.min(offsets.end, length); // IE 11 uses modern selection, but doesn't support the extend method.
  // Flip backward selections, so we can set with a single range.

  if (!selection.extend && start > end) {
    var temp = end;
    end = start;
    start = temp;
  }

  var startMarker = getNodeForCharacterOffset(node, start);
  var endMarker = getNodeForCharacterOffset(node, end);

  if (startMarker && endMarker) {
    if (selection.rangeCount === 1 && selection.anchorNode === startMarker.node && selection.anchorOffset === startMarker.offset && selection.focusNode === endMarker.node && selection.focusOffset === endMarker.offset) {
      return;
    }

    var range = doc.createRange();
    range.setStart(startMarker.node, startMarker.offset);
    selection.removeAllRanges();

    if (start > end) {
      selection.addRange(range);
      selection.extend(endMarker.node, endMarker.offset);
    } else {
      range.setEnd(endMarker.node, endMarker.offset);
      selection.addRange(range);
    }
  }
}

function isTextNode(node) {
  return node && node.nodeType === TEXT_NODE;
}

function containsNode(outerNode, innerNode) {
  if (!outerNode || !innerNode) {
    return false;
  } else if (outerNode === innerNode) {
    return true;
  } else if (isTextNode(outerNode)) {
    return false;
  } else if (isTextNode(innerNode)) {
    return containsNode(outerNode, innerNode.parentNode);
  } else if ('contains' in outerNode) {
    return outerNode.contains(innerNode);
  } else if (outerNode.compareDocumentPosition) {
    return !!(outerNode.compareDocumentPosition(innerNode) & 16);
  } else {
    return false;
  }
}

function isInDocument(node) {
  return node && node.ownerDocument && containsNode(node.ownerDocument.documentElement, node);
}

function isSameOriginFrame(iframe) {
  try {
    // Accessing the contentDocument of a HTMLIframeElement can cause the browser
    // to throw, e.g. if it has a cross-origin src attribute.
    // Safari will show an error in the console when the access results in "Blocked a frame with origin". e.g:
    // iframe.contentDocument.defaultView;
    // A safety way is to access one of the cross origin properties: Window or Location
    // Which might result in "SecurityError" DOM Exception and it is compatible to Safari.
    // https://html.spec.whatwg.org/multipage/browsers.html#integration-with-idl
    return typeof iframe.contentWindow.location.href === 'string';
  } catch (err) {
    return false;
  }
}

function getActiveElementDeep() {
  var win = window;
  var element = getActiveElement();

  while (element instanceof win.HTMLIFrameElement) {
    if (isSameOriginFrame(element)) {
      win = element.contentWindow;
    } else {
      return element;
    }

    element = getActiveElement(win.document);
  }

  return element;
}
/**
 * @ReactInputSelection: React input selection module. Based on Selection.js,
 * but modified to be suitable for react and has a couple of bug fixes (doesn't
 * assume buttons have range selections allowed).
 * Input selection module for React.
 */

/**
 * @hasSelectionCapabilities: we get the element types that support selection
 * from https://html.spec.whatwg.org/#do-not-apply, looking at `selectionStart`
 * and `selectionEnd` rows.
 */


function hasSelectionCapabilities(elem) {
  var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
  return nodeName && (nodeName === 'input' && (elem.type === 'text' || elem.type === 'search' || elem.type === 'tel' || elem.type === 'url' || elem.type === 'password') || nodeName === 'textarea' || elem.contentEditable === 'true');
}
function getSelectionInformation() {
  var focusedElem = getActiveElementDeep();
  return {
    focusedElem: focusedElem,
    selectionRange: hasSelectionCapabilities(focusedElem) ? getSelection(focusedElem) : null
  };
}
/**
 * @restoreSelection: If any selection information was potentially lost,
 * restore it. This is useful when performing operations that could remove dom
 * nodes and place them back in, resulting in focus being lost.
 */

function restoreSelection(priorSelectionInformation) {
  var curFocusedElem = getActiveElementDeep();
  var priorFocusedElem = priorSelectionInformation.focusedElem;
  var priorSelectionRange = priorSelectionInformation.selectionRange;

  if (curFocusedElem !== priorFocusedElem && isInDocument(priorFocusedElem)) {
    if (priorSelectionRange !== null && hasSelectionCapabilities(priorFocusedElem)) {
      setSelection(priorFocusedElem, priorSelectionRange);
    } // Focusing a node can change the scroll position, which is undesirable


    var ancestors = [];
    var ancestor = priorFocusedElem;

    while (ancestor = ancestor.parentNode) {
      if (ancestor.nodeType === ELEMENT_NODE) {
        ancestors.push({
          element: ancestor,
          left: ancestor.scrollLeft,
          top: ancestor.scrollTop
        });
      }
    }

    if (typeof priorFocusedElem.focus === 'function') {
      priorFocusedElem.focus();
    }

    for (var i = 0; i < ancestors.length; i++) {
      var info = ancestors[i];
      info.element.scrollLeft = info.left;
      info.element.scrollTop = info.top;
    }
  }
}
/**
 * @getSelection: Gets the selection bounds of a focused textarea, input or
 * contentEditable node.
 * -@input: Look up selection bounds of this input
 * -@return {start: selectionStart, end: selectionEnd}
 */

function getSelection(input) {
  var selection;

  if ('selectionStart' in input) {
    // Modern browser with input or textarea.
    selection = {
      start: input.selectionStart,
      end: input.selectionEnd
    };
  } else {
    // Content editable or old IE textarea.
    selection = getOffsets(input);
  }

  return selection || {
    start: 0,
    end: 0
  };
}
/**
 * @setSelection: Sets the selection bounds of a textarea or input and focuses
 * the input.
 * -@input     Set selection bounds of this input or textarea
 * -@offsets   Object of same form that is returned from get*
 */

function setSelection(input, offsets) {
  var start = offsets.start;
  var end = offsets.end;

  if (end === undefined) {
    end = start;
  }

  if ('selectionStart' in input) {
    input.selectionStart = start;
    input.selectionEnd = Math.min(end, input.value.length);
  } else {
    setOffsets(input, offsets);
  }
}

var skipSelectionChangeEvent = canUseDOM && 'documentMode' in document && document.documentMode <= 11;

function registerEvents$3() {
  registerTwoPhaseEvent('onSelect', ['focusout', 'contextmenu', 'dragend', 'focusin', 'keydown', 'keyup', 'mousedown', 'mouseup', 'selectionchange']);
}

var activeElement$1 = null;
var activeElementInst$1 = null;
var lastSelection = null;
var mouseDown = false;
/**
 * Get an object which is a unique representation of the current selection.
 *
 * The return value will not be consistent across nodes or browsers, but
 * two identical selections on the same node will return identical objects.
 */

function getSelection$1(node) {
  if ('selectionStart' in node && hasSelectionCapabilities(node)) {
    return {
      start: node.selectionStart,
      end: node.selectionEnd
    };
  } else {
    var win = node.ownerDocument && node.ownerDocument.defaultView || window;
    var selection = win.getSelection();
    return {
      anchorNode: selection.anchorNode,
      anchorOffset: selection.anchorOffset,
      focusNode: selection.focusNode,
      focusOffset: selection.focusOffset
    };
  }
}
/**
 * Get document associated with the event target.
 */


function getEventTargetDocument(eventTarget) {
  return eventTarget.window === eventTarget ? eventTarget.document : eventTarget.nodeType === DOCUMENT_NODE ? eventTarget : eventTarget.ownerDocument;
}
/**
 * Poll selection to see whether it's changed.
 *
 * @param {object} nativeEvent
 * @param {object} nativeEventTarget
 * @return {?SyntheticEvent}
 */


function constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget) {
  // Ensure we have the right element, and that the user is not dragging a
  // selection (this matches native `select` event behavior). In HTML5, select
  // fires only on input and textarea thus if there's no focused element we
  // won't dispatch.
  var doc = getEventTargetDocument(nativeEventTarget);

  if (mouseDown || activeElement$1 == null || activeElement$1 !== getActiveElement(doc)) {
    return;
  } // Only fire when selection has actually changed.


  var currentSelection = getSelection$1(activeElement$1);

  if (!lastSelection || !shallowEqual(lastSelection, currentSelection)) {
    lastSelection = currentSelection;
    var listeners = accumulateTwoPhaseListeners(activeElementInst$1, 'onSelect');

    if (listeners.length > 0) {
      var event = new SyntheticEvent('onSelect', 'select', null, nativeEvent, nativeEventTarget);
      dispatchQueue.push({
        event: event,
        listeners: listeners
      });
      event.target = activeElement$1;
    }
  }
}
/**
 * This plugin creates an `onSelect` event that normalizes select events
 * across form elements.
 *
 * Supported elements are:
 * - input (see `isTextInputElement`)
 * - textarea
 * - contentEditable
 *
 * This differs from native browser implementations in the following ways:
 * - Fires on contentEditable fields as well as inputs.
 * - Fires for collapsed selection.
 * - Fires after user input.
 */


function extractEvents$3(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags, targetContainer) {

  var targetNode = targetInst ? getNodeFromInstance(targetInst) : window;

  switch (domEventName) {
    // Track the input node that has focus.
    case 'focusin':
      if (isTextInputElement(targetNode) || targetNode.contentEditable === 'true') {
        activeElement$1 = targetNode;
        activeElementInst$1 = targetInst;
        lastSelection = null;
      }

      break;

    case 'focusout':
      activeElement$1 = null;
      activeElementInst$1 = null;
      lastSelection = null;
      break;
    // Don't fire the event while the user is dragging. This matches the
    // semantics of the native select event.

    case 'mousedown':
      mouseDown = true;
      break;

    case 'contextmenu':
    case 'mouseup':
    case 'dragend':
      mouseDown = false;
      constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget);
      break;
    // Chrome and IE fire non-standard event when selection is changed (and
    // sometimes when it hasn't). IE's event fires out of order with respect
    // to key and input events on deletion, so we discard it.
    //
    // Firefox doesn't support selectionchange, so check selection status
    // after each key entry. The selection changes after keydown and before
    // keyup, but we check on keydown as well in the case of holding down a
    // key, when multiple keydown events are fired but only one keyup is.
    // This is also our approach for IE handling, for the reason above.

    case 'selectionchange':
      if (skipSelectionChangeEvent) {
        break;
      }

    // falls through

    case 'keydown':
    case 'keyup':
      constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget);
  }
}

function extractEvents$4(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags, targetContainer) {
  var reactName = topLevelEventsToReactNames.get(domEventName);

  if (reactName === undefined) {
    return;
  }

  var SyntheticEventCtor = SyntheticEvent;
  var reactEventType = domEventName;

  switch (domEventName) {
    case 'keypress':
      // Firefox creates a keypress event for function keys too. This removes
      // the unwanted keypress events. Enter is however both printable and
      // non-printable. One would expect Tab to be as well (but it isn't).
      if (getEventCharCode(nativeEvent) === 0) {
        return;
      }

    /* falls through */

    case 'keydown':
    case 'keyup':
      SyntheticEventCtor = SyntheticKeyboardEvent;
      break;

    case 'focusin':
      reactEventType = 'focus';
      SyntheticEventCtor = SyntheticFocusEvent;
      break;

    case 'focusout':
      reactEventType = 'blur';
      SyntheticEventCtor = SyntheticFocusEvent;
      break;

    case 'beforeblur':
    case 'afterblur':
      SyntheticEventCtor = SyntheticFocusEvent;
      break;

    case 'click':
      // Firefox creates a click event on right mouse clicks. This removes the
      // unwanted click events.
      if (nativeEvent.button === 2) {
        return;
      }

    /* falls through */

    case 'auxclick':
    case 'dblclick':
    case 'mousedown':
    case 'mousemove':
    case 'mouseup': // TODO: Disabled elements should not respond to mouse events

    /* falls through */

    case 'mouseout':
    case 'mouseover':
    case 'contextmenu':
      SyntheticEventCtor = SyntheticMouseEvent;
      break;

    case 'drag':
    case 'dragend':
    case 'dragenter':
    case 'dragexit':
    case 'dragleave':
    case 'dragover':
    case 'dragstart':
    case 'drop':
      SyntheticEventCtor = SyntheticDragEvent;
      break;

    case 'touchcancel':
    case 'touchend':
    case 'touchmove':
    case 'touchstart':
      SyntheticEventCtor = SyntheticTouchEvent;
      break;

    case ANIMATION_END:
    case ANIMATION_ITERATION:
    case ANIMATION_START:
      SyntheticEventCtor = SyntheticAnimationEvent;
      break;

    case TRANSITION_END:
      SyntheticEventCtor = SyntheticTransitionEvent;
      break;

    case 'scroll':
      SyntheticEventCtor = SyntheticUIEvent;
      break;

    case 'wheel':
      SyntheticEventCtor = SyntheticWheelEvent;
      break;

    case 'copy':
    case 'cut':
    case 'paste':
      SyntheticEventCtor = SyntheticClipboardEvent;
      break;

    case 'gotpointercapture':
    case 'lostpointercapture':
    case 'pointercancel':
    case 'pointerdown':
    case 'pointermove':
    case 'pointerout':
    case 'pointerover':
    case 'pointerup':
      SyntheticEventCtor = SyntheticPointerEvent;
      break;
  }

  var inCapturePhase = (eventSystemFlags & IS_CAPTURE_PHASE) !== 0;

  {
    // Some events don't bubble in the browser.
    // In the past, React has always bubbled them, but this can be surprising.
    // We're going to try aligning closer to the browser behavior by not bubbling
    // them in React either. We'll start by not bubbling onScroll, and then expand.
    var accumulateTargetOnly = !inCapturePhase && // TODO: ideally, we'd eventually add all events from
    // nonDelegatedEvents list in DOMPluginEventSystem.
    // Then we can remove this special list.
    // This is a breaking change that can wait until React 18.
    domEventName === 'scroll';

    var _listeners = accumulateSinglePhaseListeners(targetInst, reactName, nativeEvent.type, inCapturePhase, accumulateTargetOnly);

    if (_listeners.length > 0) {
      // Intentionally create event lazily.
      var _event = new SyntheticEventCtor(reactName, reactEventType, null, nativeEvent, nativeEventTarget);

      dispatchQueue.push({
        event: _event,
        listeners: _listeners
      });
    }
  }
}

// TODO: remove top-level side effect.
registerSimpleEvents();
registerEvents$2();
registerEvents$1();
registerEvents$3();
registerEvents();

function extractEvents$5(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags, targetContainer) {
  // TODO: we should remove the concept of a "SimpleEventPlugin".
  // This is the basic functionality of the event system. All
  // the other plugins are essentially polyfills. So the plugin
  // should probably be inlined somewhere and have its logic
  // be core the to event system. This would potentially allow
  // us to ship builds of React without the polyfilled plugins below.
  extractEvents$4(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags);
  var shouldProcessPolyfillPlugins = (eventSystemFlags & SHOULD_NOT_PROCESS_POLYFILL_EVENT_PLUGINS) === 0; // We don't process these events unless we are in the
  // event's native "bubble" phase, which means that we're
  // not in the capture phase. That's because we emulate
  // the capture phase here still. This is a trade-off,
  // because in an ideal world we would not emulate and use
  // the phases properly, like we do with the SimpleEvent
  // plugin. However, the plugins below either expect
  // emulation (EnterLeave) or use state localized to that
  // plugin (BeforeInput, Change, Select). The state in
  // these modules complicates things, as you'll essentially
  // get the case where the capture phase event might change
  // state, only for the following bubble event to come in
  // later and not trigger anything as the state now
  // invalidates the heuristics of the event plugin. We
  // could alter all these plugins to work in such ways, but
  // that might cause other unknown side-effects that we
  // can't forsee right now.

  if (shouldProcessPolyfillPlugins) {
    extractEvents$2(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags);
    extractEvents$1(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget);
    extractEvents$3(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget);
    extractEvents(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget);
  }
} // List of events that need to be individually attached to media elements.


var mediaEventTypes = ['abort', 'canplay', 'canplaythrough', 'durationchange', 'emptied', 'encrypted', 'ended', 'error', 'loadeddata', 'loadedmetadata', 'loadstart', 'pause', 'play', 'playing', 'progress', 'ratechange', 'seeked', 'seeking', 'stalled', 'suspend', 'timeupdate', 'volumechange', 'waiting']; // We should not delegate these events to the container, but rather
// set them on the actual target element itself. This is primarily
// because these events do not consistently bubble in the DOM.

var nonDelegatedEvents = new Set(['cancel', 'close', 'invalid', 'load', 'scroll', 'toggle'].concat(mediaEventTypes));

function executeDispatch(event, listener, currentTarget) {
  var type = event.type || 'unknown-event';
  event.currentTarget = currentTarget;
  invokeGuardedCallbackAndCatchFirstError(type, listener, undefined, event);
  event.currentTarget = null;
}

function processDispatchQueueItemsInOrder(event, dispatchListeners, inCapturePhase) {
  var previousInstance;

  if (inCapturePhase) {
    for (var i = dispatchListeners.length - 1; i >= 0; i--) {
      var _dispatchListeners$i = dispatchListeners[i],
          instance = _dispatchListeners$i.instance,
          currentTarget = _dispatchListeners$i.currentTarget,
          listener = _dispatchListeners$i.listener;

      if (instance !== previousInstance && event.isPropagationStopped()) {
        return;
      }

      executeDispatch(event, listener, currentTarget);
      previousInstance = instance;
    }
  } else {
    for (var _i = 0; _i < dispatchListeners.length; _i++) {
      var _dispatchListeners$_i = dispatchListeners[_i],
          _instance = _dispatchListeners$_i.instance,
          _currentTarget = _dispatchListeners$_i.currentTarget,
          _listener = _dispatchListeners$_i.listener;

      if (_instance !== previousInstance && event.isPropagationStopped()) {
        return;
      }

      executeDispatch(event, _listener, _currentTarget);
      previousInstance = _instance;
    }
  }
}

function processDispatchQueue(dispatchQueue, eventSystemFlags) {
  var inCapturePhase = (eventSystemFlags & IS_CAPTURE_PHASE) !== 0;

  for (var i = 0; i < dispatchQueue.length; i++) {
    var _dispatchQueue$i = dispatchQueue[i],
        event = _dispatchQueue$i.event,
        listeners = _dispatchQueue$i.listeners;
    processDispatchQueueItemsInOrder(event, listeners, inCapturePhase); //  event system doesn't use pooling.
  } // This would be a good time to rethrow if any of the event handlers threw.


  rethrowCaughtError();
}

function dispatchEventsForPlugins(domEventName, eventSystemFlags, nativeEvent, targetInst, targetContainer) {
  var nativeEventTarget = getEventTarget(nativeEvent);
  var dispatchQueue = [];
  extractEvents$5(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags);
  processDispatchQueue(dispatchQueue, eventSystemFlags);
}

function listenToNonDelegatedEvent(domEventName, targetElement) {
  var isCapturePhaseListener = false;
  var listenerSet = getEventListenerSet(targetElement);
  var listenerSetKey = getListenerSetKey(domEventName, isCapturePhaseListener);

  if (!listenerSet.has(listenerSetKey)) {
    addTrappedEventListener(targetElement, domEventName, IS_NON_DELEGATED, isCapturePhaseListener);
    listenerSet.add(listenerSetKey);
  }
}
var listeningMarker = '_reactListening' + Math.random().toString(36).slice(2);
function listenToAllSupportedEvents(rootContainerElement) {
  {
    if (rootContainerElement[listeningMarker]) {
      // Performance optimization: don't iterate through events
      // for the same portal container or root node more than once.
      // TODO: once we remove the flag, we may be able to also
      // remove some of the bookkeeping maps used for laziness.
      return;
    }

    rootContainerElement[listeningMarker] = true;
    allNativeEvents.forEach(function (domEventName) {
      if (!nonDelegatedEvents.has(domEventName)) {
        listenToNativeEvent(domEventName, false, rootContainerElement, null);
      }

      listenToNativeEvent(domEventName, true, rootContainerElement, null);
    });
  }
}
function listenToNativeEvent(domEventName, isCapturePhaseListener, rootContainerElement, targetElement) {
  var eventSystemFlags = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;
  var target = rootContainerElement; // selectionchange needs to be attached to the document
  // otherwise it won't capture incoming events that are only
  // triggered on the document directly.

  if (domEventName === 'selectionchange' && rootContainerElement.nodeType !== DOCUMENT_NODE) {
    target = rootContainerElement.ownerDocument;
  } // If the event can be delegated (or is capture phase), we can
  // register it to the root container. Otherwise, we should
  // register the event to the target element and mark it as
  // a non-delegated event.


  if (targetElement !== null && !isCapturePhaseListener && nonDelegatedEvents.has(domEventName)) {
    // For all non-delegated events, apart from scroll, we attach
    // their event listeners to the respective elements that their
    // events fire on. That means we can skip this step, as event
    // listener has already been added previously. However, we
    // special case the scroll event because the reality is that any
    // element can scroll.
    // TODO: ideally, we'd eventually apply the same logic to all
    // events from the nonDelegatedEvents list. Then we can remove
    // this special case and use the same logic for all events.
    if (domEventName !== 'scroll') {
      return;
    }

    eventSystemFlags |= IS_NON_DELEGATED;
    target = targetElement;
  }

  var listenerSet = getEventListenerSet(target);
  var listenerSetKey = getListenerSetKey(domEventName, isCapturePhaseListener); // If the listener entry is empty or we should upgrade, then
  // we need to trap an event listener onto the target.

  if (!listenerSet.has(listenerSetKey)) {
    if (isCapturePhaseListener) {
      eventSystemFlags |= IS_CAPTURE_PHASE;
    }

    addTrappedEventListener(target, domEventName, eventSystemFlags, isCapturePhaseListener);
    listenerSet.add(listenerSetKey);
  }
}

function addTrappedEventListener(targetContainer, domEventName, eventSystemFlags, isCapturePhaseListener, isDeferredListenerForLegacyFBSupport) {
  var listener = createEventListenerWrapperWithPriority(targetContainer, domEventName, eventSystemFlags); // If passive option is not supported, then the event will be
  // active and not passive.

  var isPassiveListener = undefined;

  if (passiveBrowserEventsSupported) {
    // Browsers introduced an intervention, making these events
    // passive by default on document. React doesn't bind them
    // to document anymore, but changing this now would undo
    // the performance wins from the change. So we emulate
    // the existing behavior manually on the roots now.
    // https://github.com/facebook/react/issues/19651
    if (domEventName === 'touchstart' || domEventName === 'touchmove' || domEventName === 'wheel') {
      isPassiveListener = true;
    }
  }

  targetContainer =  targetContainer;
  var unsubscribeListener; // When legacyFBSupport is enabled, it's for when we


  if (isCapturePhaseListener) {
    if (isPassiveListener !== undefined) {
      unsubscribeListener = addEventCaptureListenerWithPassiveFlag(targetContainer, domEventName, listener, isPassiveListener);
    } else {
      unsubscribeListener = addEventCaptureListener(targetContainer, domEventName, listener);
    }
  } else {
    if (isPassiveListener !== undefined) {
      unsubscribeListener = addEventBubbleListenerWithPassiveFlag(targetContainer, domEventName, listener, isPassiveListener);
    } else {
      unsubscribeListener = addEventBubbleListener(targetContainer, domEventName, listener);
    }
  }
}

function isMatchingRootContainer(grandContainer, targetContainer) {
  return grandContainer === targetContainer || grandContainer.nodeType === COMMENT_NODE && grandContainer.parentNode === targetContainer;
}

function dispatchEventForPluginEventSystem(domEventName, eventSystemFlags, nativeEvent, targetInst, targetContainer) {
  var ancestorInst = targetInst;

  if ((eventSystemFlags & IS_EVENT_HANDLE_NON_MANAGED_NODE) === 0 && (eventSystemFlags & IS_NON_DELEGATED) === 0) {
    var targetContainerNode = targetContainer; // If we are using the legacy FB support flag, we

    if (targetInst !== null) {
      // The below logic attempts to work out if we need to change
      // the target fiber to a different ancestor. We had similar logic
      // in the legacy event system, except the big difference between
      // systems is that the modern event system now has an event listener
      // attached to each React Root and React Portal Root. Together,
      // the DOM nodes representing these roots are the "rootContainer".
      // To figure out which ancestor instance we should use, we traverse
      // up the fiber tree from the target instance and attempt to find
      // root boundaries that match that of our current "rootContainer".
      // If we find that "rootContainer", we find the parent fiber
      // sub-tree for that root and make that our ancestor instance.
      var node = targetInst;

      mainLoop: while (true) {
        if (node === null) {
          return;
        }

        var nodeTag = node.tag;

        if (nodeTag === HostRoot || nodeTag === HostPortal) {
          var container = node.stateNode.containerInfo;

          if (isMatchingRootContainer(container, targetContainerNode)) {
            break;
          }

          if (nodeTag === HostPortal) {
            // The target is a portal, but it's not the rootContainer we're looking for.
            // Normally portals handle their own events all the way down to the root.
            // So we should be able to stop now. However, we don't know if this portal
            // was part of *our* root.
            var grandNode = node.return;

            while (grandNode !== null) {
              var grandTag = grandNode.tag;

              if (grandTag === HostRoot || grandTag === HostPortal) {
                var grandContainer = grandNode.stateNode.containerInfo;

                if (isMatchingRootContainer(grandContainer, targetContainerNode)) {
                  // This is the rootContainer we're looking for and we found it as
                  // a parent of the Portal. That means we can ignore it because the
                  // Portal will bubble through to us.
                  return;
                }
              }

              grandNode = grandNode.return;
            }
          } // Now we need to find it's corresponding host fiber in the other
          // tree. To do this we can use getClosestInstanceFromNode, but we
          // need to validate that the fiber is a host instance, otherwise
          // we need to traverse up through the DOM till we find the correct
          // node that is from the other tree.


          while (container !== null) {
            var parentNode = getClosestInstanceFromNode(container);

            if (parentNode === null) {
              return;
            }

            var parentTag = parentNode.tag;

            if (parentTag === HostComponent || parentTag === HostText) {
              node = ancestorInst = parentNode;
              continue mainLoop;
            }

            container = container.parentNode;
          }
        }

        node = node.return;
      }
    }
  }

  batchedEventUpdates(function () {
    return dispatchEventsForPlugins(domEventName, eventSystemFlags, nativeEvent, ancestorInst);
  });
}

function createDispatchListener(instance, listener, currentTarget) {
  return {
    instance: instance,
    listener: listener,
    currentTarget: currentTarget
  };
}

function accumulateSinglePhaseListeners(targetFiber, reactName, nativeEventType, inCapturePhase, accumulateTargetOnly) {
  var captureName = reactName !== null ? reactName + 'Capture' : null;
  var reactEventName = inCapturePhase ? captureName : reactName;
  var listeners = [];
  var instance = targetFiber;
  var lastHostComponent = null; // Accumulate all instances and listeners via the target -> root path.

  while (instance !== null) {
    var _instance2 = instance,
        stateNode = _instance2.stateNode,
        tag = _instance2.tag; // Handle listeners that are on HostComponents (i.e. <div>)

    if (tag === HostComponent && stateNode !== null) {
      lastHostComponent = stateNode; // createEventHandle listeners


      if (reactEventName !== null) {
        var listener = getListener(instance, reactEventName);

        if (listener != null) {
          listeners.push(createDispatchListener(instance, listener, lastHostComponent));
        }
      }
    } // If we are only accumulating events for the target, then we don't
    // continue to propagate through the React fiber tree to find other
    // listeners.


    if (accumulateTargetOnly) {
      break;
    }

    instance = instance.return;
  }

  return listeners;
} // We should only use this function for:
// - BeforeInputEventPlugin
// - ChangeEventPlugin
// - SelectEventPlugin
// This is because we only process these plugins
// in the bubble phase, so we need to accumulate two
// phase event listeners (via emulation).

function accumulateTwoPhaseListeners(targetFiber, reactName) {
  var captureName = reactName + 'Capture';
  var listeners = [];
  var instance = targetFiber; // Accumulate all instances and listeners via the target -> root path.

  while (instance !== null) {
    var _instance3 = instance,
        stateNode = _instance3.stateNode,
        tag = _instance3.tag; // Handle listeners that are on HostComponents (i.e. <div>)

    if (tag === HostComponent && stateNode !== null) {
      var currentTarget = stateNode;
      var captureListener = getListener(instance, captureName);

      if (captureListener != null) {
        listeners.unshift(createDispatchListener(instance, captureListener, currentTarget));
      }

      var bubbleListener = getListener(instance, reactName);

      if (bubbleListener != null) {
        listeners.push(createDispatchListener(instance, bubbleListener, currentTarget));
      }
    }

    instance = instance.return;
  }

  return listeners;
}

function getParent(inst) {
  if (inst === null) {
    return null;
  }

  do {
    inst = inst.return; // TODO: If this is a HostRoot we might want to bail out.
    // That is depending on if we want nested subtrees (layers) to bubble
    // events to their parent. We could also go through parentNode on the
    // host node but that wouldn't work for React Native and doesn't let us
    // do the portal feature.
  } while (inst && inst.tag !== HostComponent);

  if (inst) {
    return inst;
  }

  return null;
}
/**
 * Return the lowest common ancestor of A and B, or null if they are in
 * different trees.
 */


function getLowestCommonAncestor(instA, instB) {
  var nodeA = instA;
  var nodeB = instB;
  var depthA = 0;

  for (var tempA = nodeA; tempA; tempA = getParent(tempA)) {
    depthA++;
  }

  var depthB = 0;

  for (var tempB = nodeB; tempB; tempB = getParent(tempB)) {
    depthB++;
  } // If A is deeper, crawl up.


  while (depthA - depthB > 0) {
    nodeA = getParent(nodeA);
    depthA--;
  } // If B is deeper, crawl up.


  while (depthB - depthA > 0) {
    nodeB = getParent(nodeB);
    depthB--;
  } // Walk in lockstep until we find a match.


  var depth = depthA;

  while (depth--) {
    if (nodeA === nodeB || nodeB !== null && nodeA === nodeB.alternate) {
      return nodeA;
    }

    nodeA = getParent(nodeA);
    nodeB = getParent(nodeB);
  }

  return null;
}

function accumulateEnterLeaveListenersForEvent(dispatchQueue, event, target, common, inCapturePhase) {
  var registrationName = event._reactName;
  var listeners = [];
  var instance = target;

  while (instance !== null) {
    if (instance === common) {
      break;
    }

    var _instance4 = instance,
        alternate = _instance4.alternate,
        stateNode = _instance4.stateNode,
        tag = _instance4.tag;

    if (alternate !== null && alternate === common) {
      break;
    }

    if (tag === HostComponent && stateNode !== null) {
      var currentTarget = stateNode;

      if (inCapturePhase) {
        var captureListener = getListener(instance, registrationName);

        if (captureListener != null) {
          listeners.unshift(createDispatchListener(instance, captureListener, currentTarget));
        }
      } else if (!inCapturePhase) {
        var bubbleListener = getListener(instance, registrationName);

        if (bubbleListener != null) {
          listeners.push(createDispatchListener(instance, bubbleListener, currentTarget));
        }
      }
    }

    instance = instance.return;
  }

  if (listeners.length !== 0) {
    dispatchQueue.push({
      event: event,
      listeners: listeners
    });
  }
} // We should only use this function for:
// - EnterLeaveEventPlugin
// This is because we only process this plugin
// in the bubble phase, so we need to accumulate two
// phase event listeners.


function accumulateEnterLeaveTwoPhaseListeners(dispatchQueue, leaveEvent, enterEvent, from, to) {
  var common = from && to ? getLowestCommonAncestor(from, to) : null;

  if (from !== null) {
    accumulateEnterLeaveListenersForEvent(dispatchQueue, leaveEvent, from, common, false);
  }

  if (to !== null && enterEvent !== null) {
    accumulateEnterLeaveListenersForEvent(dispatchQueue, enterEvent, to, common, true);
  }
}
function getListenerSetKey(domEventName, capture) {
  return domEventName + "__" + (capture ? 'capture' : 'bubble');
}

var didWarnInvalidHydration = false;
var DANGEROUSLY_SET_INNER_HTML = 'dangerouslySetInnerHTML';
var SUPPRESS_CONTENT_EDITABLE_WARNING = 'suppressContentEditableWarning';
var SUPPRESS_HYDRATION_WARNING = 'suppressHydrationWarning';
var AUTOFOCUS = 'autoFocus';
var CHILDREN = 'children';
var STYLE = 'style';
var HTML$1 = '__html';
var HTML_NAMESPACE$1 = Namespaces.html;
var warnedUnknownTags;
var suppressHydrationWarning;
var validatePropertiesInDevelopment;
var warnForTextDifference;
var warnForPropDifference;
var warnForExtraAttributes;
var warnForInvalidEventListener;
var canDiffStyleForHydrationWarning;
var normalizeMarkupForTextOrAttribute;
var normalizeHTML;

{
  warnedUnknownTags = {
    // There are working polyfills for <dialog>. Let people use it.
    dialog: true,
    // Electron ships a custom <webview> tag to display external web content in
    // an isolated frame and process.
    // This tag is not present in non Electron environments such as JSDom which
    // is often used for testing purposes.
    // @see https://electronjs.org/docs/api/webview-tag
    webview: true
  };

  validatePropertiesInDevelopment = function (type, props) {
    validateProperties(type, props);
    validateProperties$1(type, props);
    validateProperties$2(type, props, {
      registrationNameDependencies: registrationNameDependencies,
      possibleRegistrationNames: possibleRegistrationNames
    });
  }; // IE 11 parses & normalizes the style attribute as opposed to other
  // browsers. It adds spaces and sorts the properties in some
  // non-alphabetical order. Handling that would require sorting CSS
  // properties in the client & server versions or applying
  // `expectedStyle` to a temporary DOM node to read its `style` attribute
  // normalized. Since it only affects IE, we're skipping style warnings
  // in that browser completely in favor of doing all that work.
  // See https://github.com/facebook/react/issues/11807


  canDiffStyleForHydrationWarning = canUseDOM && !document.documentMode; // HTML parsing normalizes CR and CRLF to LF.
  // It also can turn \u0000 into \uFFFD inside attributes.
  // https://www.w3.org/TR/html5/single-page.html#preprocessing-the-input-stream
  // If we have a mismatch, it might be caused by that.
  // We will still patch up in this case but not fire the warning.

  var NORMALIZE_NEWLINES_REGEX = /\r\n?/g;
  var NORMALIZE_NULL_AND_REPLACEMENT_REGEX = /\u0000|\uFFFD/g;

  normalizeMarkupForTextOrAttribute = function (markup) {
    var markupString = typeof markup === 'string' ? markup : '' + markup;
    return markupString.replace(NORMALIZE_NEWLINES_REGEX, '\n').replace(NORMALIZE_NULL_AND_REPLACEMENT_REGEX, '');
  };

  warnForTextDifference = function (serverText, clientText) {
    if (didWarnInvalidHydration) {
      return;
    }

    var normalizedClientText = normalizeMarkupForTextOrAttribute(clientText);
    var normalizedServerText = normalizeMarkupForTextOrAttribute(serverText);

    if (normalizedServerText === normalizedClientText) {
      return;
    }

    didWarnInvalidHydration = true;

    error('Text content did not match. Server: "%s" Client: "%s"', normalizedServerText, normalizedClientText);
  };

  warnForPropDifference = function (propName, serverValue, clientValue) {
    if (didWarnInvalidHydration) {
      return;
    }

    var normalizedClientValue = normalizeMarkupForTextOrAttribute(clientValue);
    var normalizedServerValue = normalizeMarkupForTextOrAttribute(serverValue);

    if (normalizedServerValue === normalizedClientValue) {
      return;
    }

    didWarnInvalidHydration = true;

    error('Prop `%s` did not match. Server: %s Client: %s', propName, JSON.stringify(normalizedServerValue), JSON.stringify(normalizedClientValue));
  };

  warnForExtraAttributes = function (attributeNames) {
    if (didWarnInvalidHydration) {
      return;
    }

    didWarnInvalidHydration = true;
    var names = [];
    attributeNames.forEach(function (name) {
      names.push(name);
    });

    error('Extra attributes from the server: %s', names);
  };

  warnForInvalidEventListener = function (registrationName, listener) {
    if (listener === false) {
      error('Expected `%s` listener to be a function, instead got `false`.\n\n' + 'If you used to conditionally omit it with %s={condition && value}, ' + 'pass %s={condition ? value : undefined} instead.', registrationName, registrationName, registrationName);
    } else {
      error('Expected `%s` listener to be a function, instead got a value of `%s` type.', registrationName, typeof listener);
    }
  }; // Parse the HTML and read it back to normalize the HTML string so that it
  // can be used for comparison.


  normalizeHTML = function (parent, html) {
    // We could have created a separate document here to avoid
    // re-initializing custom elements if they exist. But this breaks
    // how <noscript> is being handled. So we use the same document.
    // See the discussion in https://github.com/facebook/react/pull/11157.
    var testElement = parent.namespaceURI === HTML_NAMESPACE$1 ? parent.ownerDocument.createElement(parent.tagName) : parent.ownerDocument.createElementNS(parent.namespaceURI, parent.tagName);
    testElement.innerHTML = html;
    return testElement.innerHTML;
  };
}

function getOwnerDocumentFromRootContainer(rootContainerElement) {
  return rootContainerElement.nodeType === DOCUMENT_NODE ? rootContainerElement : rootContainerElement.ownerDocument;
}

function noop() {}

function trapClickOnNonInteractiveElement(node) {
  // Mobile Safari does not fire properly bubble click events on
  // non-interactive elements, which means delegated click listeners do not
  // fire. The workaround for this bug involves attaching an empty click
  // listener on the target node.
  // https://www.quirksmode.org/blog/archives/2010/09/click_event_del.html
  // Just set it using the onclick property so that we don't have to manage any
  // bookkeeping for it. Not sure if we need to clear it when the listener is
  // removed.
  // TODO: Only do this for the relevant Safaris maybe?
  node.onclick = noop;
}

function setInitialDOMProperties(tag, domElement, rootContainerElement, nextProps, isCustomComponentTag) {
  for (var propKey in nextProps) {
    if (!nextProps.hasOwnProperty(propKey)) {
      continue;
    }

    var nextProp = nextProps[propKey];

    if (propKey === STYLE) {
      {
        if (nextProp) {
          // Freeze the next style object so that we can assume it won't be
          // mutated. We have already warned for this in the past.
          Object.freeze(nextProp);
        }
      } // Relies on `updateStylesByID` not mutating `styleUpdates`.


      setValueForStyles(domElement, nextProp);
    } else if (propKey === DANGEROUSLY_SET_INNER_HTML) {
      var nextHtml = nextProp ? nextProp[HTML$1] : undefined;

      if (nextHtml != null) {
        setInnerHTML(domElement, nextHtml);
      }
    } else if (propKey === CHILDREN) {
      if (typeof nextProp === 'string') {
        // Avoid setting initial textContent when the text is empty. In IE11 setting
        // textContent on a <textarea> will cause the placeholder to not
        // show within the <textarea> until it has been focused and blurred again.
        // https://github.com/facebook/react/issues/6731#issuecomment-254874553
        var canSetTextContent = tag !== 'textarea' || nextProp !== '';

        if (canSetTextContent) {
          setTextContent(domElement, nextProp);
        }
      } else if (typeof nextProp === 'number') {
        setTextContent(domElement, '' + nextProp);
      }
    } else if (propKey === SUPPRESS_CONTENT_EDITABLE_WARNING || propKey === SUPPRESS_HYDRATION_WARNING) ; else if (propKey === AUTOFOCUS) ; else if (registrationNameDependencies.hasOwnProperty(propKey)) {
      if (nextProp != null) {
        if ( typeof nextProp !== 'function') {
          warnForInvalidEventListener(propKey, nextProp);
        }

        if (propKey === 'onScroll') {
          listenToNonDelegatedEvent('scroll', domElement);
        }
      }
    } else if (nextProp != null) {
      setValueForProperty(domElement, propKey, nextProp, isCustomComponentTag);
    }
  }
}

function updateDOMProperties(domElement, updatePayload, wasCustomComponentTag, isCustomComponentTag) {
  // TODO: Handle wasCustomComponentTag
  for (var i = 0; i < updatePayload.length; i += 2) {
    var propKey = updatePayload[i];
    var propValue = updatePayload[i + 1];

    if (propKey === STYLE) {
      setValueForStyles(domElement, propValue);
    } else if (propKey === DANGEROUSLY_SET_INNER_HTML) {
      setInnerHTML(domElement, propValue);
    } else if (propKey === CHILDREN) {
      setTextContent(domElement, propValue);
    } else {
      setValueForProperty(domElement, propKey, propValue, isCustomComponentTag);
    }
  }
}

function createElement(type, props, rootContainerElement, parentNamespace) {
  var isCustomComponentTag; // We create tags in the namespace of their parent container, except HTML
  // tags get no namespace.

  var ownerDocument = getOwnerDocumentFromRootContainer(rootContainerElement);
  var domElement;
  var namespaceURI = parentNamespace;

  if (namespaceURI === HTML_NAMESPACE$1) {
    namespaceURI = getIntrinsicNamespace(type);
  }

  if (namespaceURI === HTML_NAMESPACE$1) {
    {
      isCustomComponentTag = isCustomComponent(type, props); // Should this check be gated by parent namespace? Not sure we want to
      // allow <SVG> or <mATH>.

      if (!isCustomComponentTag && type !== type.toLowerCase()) {
        error('<%s /> is using incorrect casing. ' + 'Use PascalCase for React components, ' + 'or lowercase for HTML elements.', type);
      }
    }

    if (type === 'script') {
      // Create the script via .innerHTML so its "parser-inserted" flag is
      // set to true and it does not execute
      var div = ownerDocument.createElement('div');

      div.innerHTML = '<script><' + '/script>'; // eslint-disable-line
      // This is guaranteed to yield a script element.

      var firstChild = div.firstChild;
      domElement = div.removeChild(firstChild);
    } else if (typeof props.is === 'string') {
      // $FlowIssue `createElement` should be updated for Web Components
      domElement = ownerDocument.createElement(type, {
        is: props.is
      });
    } else {
      // Separate else branch instead of using `props.is || undefined` above because of a Firefox bug.
      // See discussion in https://github.com/facebook/react/pull/6896
      // and discussion in https://bugzilla.mozilla.org/show_bug.cgi?id=1276240
      domElement = ownerDocument.createElement(type); // Normally attributes are assigned in `setInitialDOMProperties`, however the `multiple` and `size`
      // attributes on `select`s needs to be added before `option`s are inserted.
      // This prevents:
      // - a bug where the `select` does not scroll to the correct option because singular
      //  `select` elements automatically pick the first item #13222
      // - a bug where the `select` set the first item as selected despite the `size` attribute #14239
      // See https://github.com/facebook/react/issues/13222
      // and https://github.com/facebook/react/issues/14239

      if (type === 'select') {
        var node = domElement;

        if (props.multiple) {
          node.multiple = true;
        } else if (props.size) {
          // Setting a size greater than 1 causes a select to behave like `multiple=true`, where
          // it is possible that no option is selected.
          //
          // This is only necessary when a select in "single selection mode".
          node.size = props.size;
        }
      }
    }
  } else {
    domElement = ownerDocument.createElementNS(namespaceURI, type);
  }

  {
    if (namespaceURI === HTML_NAMESPACE$1) {
      if (!isCustomComponentTag && Object.prototype.toString.call(domElement) === '[object HTMLUnknownElement]' && !Object.prototype.hasOwnProperty.call(warnedUnknownTags, type)) {
        warnedUnknownTags[type] = true;

        error('The tag <%s> is unrecognized in this browser. ' + 'If you meant to render a React component, start its name with ' + 'an uppercase letter.', type);
      }
    }
  }

  return domElement;
}
function createTextNode(text, rootContainerElement) {
  return getOwnerDocumentFromRootContainer(rootContainerElement).createTextNode(text);
}
function setInitialProperties(domElement, tag, rawProps, rootContainerElement) {
  var isCustomComponentTag = isCustomComponent(tag, rawProps);

  {
    validatePropertiesInDevelopment(tag, rawProps);
  } // TODO: Make sure that we check isMounted before firing any of these events.


  var props;

  switch (tag) {
    case 'dialog':
      listenToNonDelegatedEvent('cancel', domElement);
      listenToNonDelegatedEvent('close', domElement);
      props = rawProps;
      break;

    case 'iframe':
    case 'object':
    case 'embed':
      // We listen to this event in case to ensure emulated bubble
      // listeners still fire for the load event.
      listenToNonDelegatedEvent('load', domElement);
      props = rawProps;
      break;

    case 'video':
    case 'audio':
      // We listen to these events in case to ensure emulated bubble
      // listeners still fire for all the media events.
      for (var i = 0; i < mediaEventTypes.length; i++) {
        listenToNonDelegatedEvent(mediaEventTypes[i], domElement);
      }

      props = rawProps;
      break;

    case 'source':
      // We listen to this event in case to ensure emulated bubble
      // listeners still fire for the error event.
      listenToNonDelegatedEvent('error', domElement);
      props = rawProps;
      break;

    case 'img':
    case 'image':
    case 'link':
      // We listen to these events in case to ensure emulated bubble
      // listeners still fire for error and load events.
      listenToNonDelegatedEvent('error', domElement);
      listenToNonDelegatedEvent('load', domElement);
      props = rawProps;
      break;

    case 'details':
      // We listen to this event in case to ensure emulated bubble
      // listeners still fire for the toggle event.
      listenToNonDelegatedEvent('toggle', domElement);
      props = rawProps;
      break;

    case 'input':
      initWrapperState(domElement, rawProps);
      props = getHostProps(domElement, rawProps); // We listen to this event in case to ensure emulated bubble
      // listeners still fire for the invalid event.

      listenToNonDelegatedEvent('invalid', domElement);

      break;

    case 'option':
      validateProps(domElement, rawProps);
      props = getHostProps$1(domElement, rawProps);
      break;

    case 'select':
      initWrapperState$1(domElement, rawProps);
      props = getHostProps$2(domElement, rawProps); // We listen to this event in case to ensure emulated bubble
      // listeners still fire for the invalid event.

      listenToNonDelegatedEvent('invalid', domElement);

      break;

    case 'textarea':
      initWrapperState$2(domElement, rawProps);
      props = getHostProps$3(domElement, rawProps); // We listen to this event in case to ensure emulated bubble
      // listeners still fire for the invalid event.

      listenToNonDelegatedEvent('invalid', domElement);

      break;

    default:
      props = rawProps;
  }

  assertValidProps(tag, props);
  setInitialDOMProperties(tag, domElement, rootContainerElement, props, isCustomComponentTag);

  switch (tag) {
    case 'input':
      // TODO: Make sure we check if this is still unmounted or do any clean
      // up necessary since we never stop tracking anymore.
      track(domElement);
      postMountWrapper(domElement, rawProps, false);
      break;

    case 'textarea':
      // TODO: Make sure we check if this is still unmounted or do any clean
      // up necessary since we never stop tracking anymore.
      track(domElement);
      postMountWrapper$3(domElement);
      break;

    case 'option':
      postMountWrapper$1(domElement, rawProps);
      break;

    case 'select':
      postMountWrapper$2(domElement, rawProps);
      break;

    default:
      if (typeof props.onClick === 'function') {
        // TODO: This cast may not be sound for SVG, MathML or custom elements.
        trapClickOnNonInteractiveElement(domElement);
      }

      break;
  }
} // Calculate the diff between the two objects.

function diffProperties(domElement, tag, lastRawProps, nextRawProps, rootContainerElement) {
  {
    validatePropertiesInDevelopment(tag, nextRawProps);
  }

  var updatePayload = null;
  var lastProps;
  var nextProps;

  switch (tag) {
    case 'input':
      lastProps = getHostProps(domElement, lastRawProps);
      nextProps = getHostProps(domElement, nextRawProps);
      updatePayload = [];
      break;

    case 'option':
      lastProps = getHostProps$1(domElement, lastRawProps);
      nextProps = getHostProps$1(domElement, nextRawProps);
      updatePayload = [];
      break;

    case 'select':
      lastProps = getHostProps$2(domElement, lastRawProps);
      nextProps = getHostProps$2(domElement, nextRawProps);
      updatePayload = [];
      break;

    case 'textarea':
      lastProps = getHostProps$3(domElement, lastRawProps);
      nextProps = getHostProps$3(domElement, nextRawProps);
      updatePayload = [];
      break;

    default:
      lastProps = lastRawProps;
      nextProps = nextRawProps;

      if (typeof lastProps.onClick !== 'function' && typeof nextProps.onClick === 'function') {
        // TODO: This cast may not be sound for SVG, MathML or custom elements.
        trapClickOnNonInteractiveElement(domElement);
      }

      break;
  }

  assertValidProps(tag, nextProps);
  var propKey;
  var styleName;
  var styleUpdates = null;

  for (propKey in lastProps) {
    if (nextProps.hasOwnProperty(propKey) || !lastProps.hasOwnProperty(propKey) || lastProps[propKey] == null) {
      continue;
    }

    if (propKey === STYLE) {
      var lastStyle = lastProps[propKey];

      for (styleName in lastStyle) {
        if (lastStyle.hasOwnProperty(styleName)) {
          if (!styleUpdates) {
            styleUpdates = {};
          }

          styleUpdates[styleName] = '';
        }
      }
    } else if (propKey === DANGEROUSLY_SET_INNER_HTML || propKey === CHILDREN) ; else if (propKey === SUPPRESS_CONTENT_EDITABLE_WARNING || propKey === SUPPRESS_HYDRATION_WARNING) ; else if (propKey === AUTOFOCUS) ; else if (registrationNameDependencies.hasOwnProperty(propKey)) {
      // This is a special case. If any listener updates we need to ensure
      // that the "current" fiber pointer gets updated so we need a commit
      // to update this element.
      if (!updatePayload) {
        updatePayload = [];
      }
    } else {
      // For all other deleted properties we add it to the queue. We use
      // the allowed property list in the commit phase instead.
      (updatePayload = updatePayload || []).push(propKey, null);
    }
  }

  for (propKey in nextProps) {
    var nextProp = nextProps[propKey];
    var lastProp = lastProps != null ? lastProps[propKey] : undefined;

    if (!nextProps.hasOwnProperty(propKey) || nextProp === lastProp || nextProp == null && lastProp == null) {
      continue;
    }

    if (propKey === STYLE) {
      {
        if (nextProp) {
          // Freeze the next style object so that we can assume it won't be
          // mutated. We have already warned for this in the past.
          Object.freeze(nextProp);
        }
      }

      if (lastProp) {
        // Unset styles on `lastProp` but not on `nextProp`.
        for (styleName in lastProp) {
          if (lastProp.hasOwnProperty(styleName) && (!nextProp || !nextProp.hasOwnProperty(styleName))) {
            if (!styleUpdates) {
              styleUpdates = {};
            }

            styleUpdates[styleName] = '';
          }
        } // Update styles that changed since `lastProp`.


        for (styleName in nextProp) {
          if (nextProp.hasOwnProperty(styleName) && lastProp[styleName] !== nextProp[styleName]) {
            if (!styleUpdates) {
              styleUpdates = {};
            }

            styleUpdates[styleName] = nextProp[styleName];
          }
        }
      } else {
        // Relies on `updateStylesByID` not mutating `styleUpdates`.
        if (!styleUpdates) {
          if (!updatePayload) {
            updatePayload = [];
          }

          updatePayload.push(propKey, styleUpdates);
        }

        styleUpdates = nextProp;
      }
    } else if (propKey === DANGEROUSLY_SET_INNER_HTML) {
      var nextHtml = nextProp ? nextProp[HTML$1] : undefined;
      var lastHtml = lastProp ? lastProp[HTML$1] : undefined;

      if (nextHtml != null) {
        if (lastHtml !== nextHtml) {
          (updatePayload = updatePayload || []).push(propKey, nextHtml);
        }
      }
    } else if (propKey === CHILDREN) {
      if (typeof nextProp === 'string' || typeof nextProp === 'number') {
        (updatePayload = updatePayload || []).push(propKey, '' + nextProp);
      }
    } else if (propKey === SUPPRESS_CONTENT_EDITABLE_WARNING || propKey === SUPPRESS_HYDRATION_WARNING) ; else if (registrationNameDependencies.hasOwnProperty(propKey)) {
      if (nextProp != null) {
        // We eagerly listen to this even though we haven't committed yet.
        if ( typeof nextProp !== 'function') {
          warnForInvalidEventListener(propKey, nextProp);
        }

        if (propKey === 'onScroll') {
          listenToNonDelegatedEvent('scroll', domElement);
        }
      }

      if (!updatePayload && lastProp !== nextProp) {
        // This is a special case. If any listener updates we need to ensure
        // that the "current" props pointer gets updated so we need a commit
        // to update this element.
        updatePayload = [];
      }
    } else if (typeof nextProp === 'object' && nextProp !== null && nextProp.$$typeof === REACT_OPAQUE_ID_TYPE) {
      // If we encounter useOpaqueReference's opaque object, this means we are hydrating.
      // In this case, call the opaque object's toString function which generates a new client
      // ID so client and server IDs match and throws to rerender.
      nextProp.toString();
    } else {
      // For any other property we always add it to the queue and then we
      // filter it out using the allowed property list during the commit.
      (updatePayload = updatePayload || []).push(propKey, nextProp);
    }
  }

  if (styleUpdates) {
    {
      validateShorthandPropertyCollisionInDev(styleUpdates, nextProps[STYLE]);
    }

    (updatePayload = updatePayload || []).push(STYLE, styleUpdates);
  }

  return updatePayload;
} // Apply the diff.

function updateProperties(domElement, updatePayload, tag, lastRawProps, nextRawProps) {
  // Update checked *before* name.
  // In the middle of an update, it is possible to have multiple checked.
  // When a checked radio tries to change name, browser makes another radio's checked false.
  if (tag === 'input' && nextRawProps.type === 'radio' && nextRawProps.name != null) {
    updateChecked(domElement, nextRawProps);
  }

  var wasCustomComponentTag = isCustomComponent(tag, lastRawProps);
  var isCustomComponentTag = isCustomComponent(tag, nextRawProps); // Apply the diff.

  updateDOMProperties(domElement, updatePayload, wasCustomComponentTag, isCustomComponentTag); // TODO: Ensure that an update gets scheduled if any of the special props
  // changed.

  switch (tag) {
    case 'input':
      // Update the wrapper around inputs *after* updating props. This has to
      // happen after `updateDOMProperties`. Otherwise HTML5 input validations
      // raise warnings and prevent the new value from being assigned.
      updateWrapper(domElement, nextRawProps);
      break;

    case 'textarea':
      updateWrapper$1(domElement, nextRawProps);
      break;

    case 'select':
      // <select> value update needs to occur after <option> children
      // reconciliation
      postUpdateWrapper(domElement, nextRawProps);
      break;
  }
}

function getPossibleStandardName(propName) {
  {
    var lowerCasedName = propName.toLowerCase();

    if (!possibleStandardNames.hasOwnProperty(lowerCasedName)) {
      return null;
    }

    return possibleStandardNames[lowerCasedName] || null;
  }
}

function diffHydratedProperties(domElement, tag, rawProps, parentNamespace, rootContainerElement) {
  var isCustomComponentTag;
  var extraAttributeNames;

  {
    suppressHydrationWarning = rawProps[SUPPRESS_HYDRATION_WARNING] === true;
    isCustomComponentTag = isCustomComponent(tag, rawProps);
    validatePropertiesInDevelopment(tag, rawProps);
  } // TODO: Make sure that we check isMounted before firing any of these events.


  switch (tag) {
    case 'dialog':
      listenToNonDelegatedEvent('cancel', domElement);
      listenToNonDelegatedEvent('close', domElement);
      break;

    case 'iframe':
    case 'object':
    case 'embed':
      // We listen to this event in case to ensure emulated bubble
      // listeners still fire for the load event.
      listenToNonDelegatedEvent('load', domElement);
      break;

    case 'video':
    case 'audio':
      // We listen to these events in case to ensure emulated bubble
      // listeners still fire for all the media events.
      for (var i = 0; i < mediaEventTypes.length; i++) {
        listenToNonDelegatedEvent(mediaEventTypes[i], domElement);
      }

      break;

    case 'source':
      // We listen to this event in case to ensure emulated bubble
      // listeners still fire for the error event.
      listenToNonDelegatedEvent('error', domElement);
      break;

    case 'img':
    case 'image':
    case 'link':
      // We listen to these events in case to ensure emulated bubble
      // listeners still fire for error and load events.
      listenToNonDelegatedEvent('error', domElement);
      listenToNonDelegatedEvent('load', domElement);
      break;

    case 'details':
      // We listen to this event in case to ensure emulated bubble
      // listeners still fire for the toggle event.
      listenToNonDelegatedEvent('toggle', domElement);
      break;

    case 'input':
      initWrapperState(domElement, rawProps); // We listen to this event in case to ensure emulated bubble
      // listeners still fire for the invalid event.

      listenToNonDelegatedEvent('invalid', domElement);

      break;

    case 'option':
      validateProps(domElement, rawProps);
      break;

    case 'select':
      initWrapperState$1(domElement, rawProps); // We listen to this event in case to ensure emulated bubble
      // listeners still fire for the invalid event.

      listenToNonDelegatedEvent('invalid', domElement);

      break;

    case 'textarea':
      initWrapperState$2(domElement, rawProps); // We listen to this event in case to ensure emulated bubble
      // listeners still fire for the invalid event.

      listenToNonDelegatedEvent('invalid', domElement);

      break;
  }

  assertValidProps(tag, rawProps);

  {
    extraAttributeNames = new Set();
    var attributes = domElement.attributes;

    for (var _i = 0; _i < attributes.length; _i++) {
      var name = attributes[_i].name.toLowerCase();

      switch (name) {
        // Built-in SSR attribute is allowed
        case 'data-reactroot':
          break;
        // Controlled attributes are not validated
        // TODO: Only ignore them on controlled tags.

        case 'value':
          break;

        case 'checked':
          break;

        case 'selected':
          break;

        default:
          // Intentionally use the original name.
          // See discussion in https://github.com/facebook/react/pull/10676.
          extraAttributeNames.add(attributes[_i].name);
      }
    }
  }

  var updatePayload = null;

  for (var propKey in rawProps) {
    if (!rawProps.hasOwnProperty(propKey)) {
      continue;
    }

    var nextProp = rawProps[propKey];

    if (propKey === CHILDREN) {
      // For text content children we compare against textContent. This
      // might match additional HTML that is hidden when we read it using
      // textContent. E.g. "foo" will match "f<span>oo</span>" but that still
      // satisfies our requirement. Our requirement is not to produce perfect
      // HTML and attributes. Ideally we should preserve structure but it's
      // ok not to if the visible content is still enough to indicate what
      // even listeners these nodes might be wired up to.
      // TODO: Warn if there is more than a single textNode as a child.
      // TODO: Should we use domElement.firstChild.nodeValue to compare?
      if (typeof nextProp === 'string') {
        if (domElement.textContent !== nextProp) {
          if ( !suppressHydrationWarning) {
            warnForTextDifference(domElement.textContent, nextProp);
          }

          updatePayload = [CHILDREN, nextProp];
        }
      } else if (typeof nextProp === 'number') {
        if (domElement.textContent !== '' + nextProp) {
          if ( !suppressHydrationWarning) {
            warnForTextDifference(domElement.textContent, nextProp);
          }

          updatePayload = [CHILDREN, '' + nextProp];
        }
      }
    } else if (registrationNameDependencies.hasOwnProperty(propKey)) {
      if (nextProp != null) {
        if ( typeof nextProp !== 'function') {
          warnForInvalidEventListener(propKey, nextProp);
        }

        if (propKey === 'onScroll') {
          listenToNonDelegatedEvent('scroll', domElement);
        }
      }
    } else if ( // Convince Flow we've calculated it (it's DEV-only in this method.)
    typeof isCustomComponentTag === 'boolean') {
      // Validate that the properties correspond to their expected values.
      var serverValue = void 0;
      var propertyInfo = getPropertyInfo(propKey);

      if (suppressHydrationWarning) ; else if (propKey === SUPPRESS_CONTENT_EDITABLE_WARNING || propKey === SUPPRESS_HYDRATION_WARNING || // Controlled attributes are not validated
      // TODO: Only ignore them on controlled tags.
      propKey === 'value' || propKey === 'checked' || propKey === 'selected') ; else if (propKey === DANGEROUSLY_SET_INNER_HTML) {
        var serverHTML = domElement.innerHTML;
        var nextHtml = nextProp ? nextProp[HTML$1] : undefined;

        if (nextHtml != null) {
          var expectedHTML = normalizeHTML(domElement, nextHtml);

          if (expectedHTML !== serverHTML) {
            warnForPropDifference(propKey, serverHTML, expectedHTML);
          }
        }
      } else if (propKey === STYLE) {
        // $FlowFixMe - Should be inferred as not undefined.
        extraAttributeNames.delete(propKey);

        if (canDiffStyleForHydrationWarning) {
          var expectedStyle = createDangerousStringForStyles(nextProp);
          serverValue = domElement.getAttribute('style');

          if (expectedStyle !== serverValue) {
            warnForPropDifference(propKey, serverValue, expectedStyle);
          }
        }
      } else if (isCustomComponentTag) {
        // $FlowFixMe - Should be inferred as not undefined.
        extraAttributeNames.delete(propKey.toLowerCase());
        serverValue = getValueForAttribute(domElement, propKey, nextProp);

        if (nextProp !== serverValue) {
          warnForPropDifference(propKey, serverValue, nextProp);
        }
      } else if (!shouldIgnoreAttribute(propKey, propertyInfo, isCustomComponentTag) && !shouldRemoveAttribute(propKey, nextProp, propertyInfo, isCustomComponentTag)) {
        var isMismatchDueToBadCasing = false;

        if (propertyInfo !== null) {
          // $FlowFixMe - Should be inferred as not undefined.
          extraAttributeNames.delete(propertyInfo.attributeName);
          serverValue = getValueForProperty(domElement, propKey, nextProp, propertyInfo);
        } else {
          var ownNamespace = parentNamespace;

          if (ownNamespace === HTML_NAMESPACE$1) {
            ownNamespace = getIntrinsicNamespace(tag);
          }

          if (ownNamespace === HTML_NAMESPACE$1) {
            // $FlowFixMe - Should be inferred as not undefined.
            extraAttributeNames.delete(propKey.toLowerCase());
          } else {
            var standardName = getPossibleStandardName(propKey);

            if (standardName !== null && standardName !== propKey) {
              // If an SVG prop is supplied with bad casing, it will
              // be successfully parsed from HTML, but will produce a mismatch
              // (and would be incorrectly rendered on the client).
              // However, we already warn about bad casing elsewhere.
              // So we'll skip the misleading extra mismatch warning in this case.
              isMismatchDueToBadCasing = true; // $FlowFixMe - Should be inferred as not undefined.

              extraAttributeNames.delete(standardName);
            } // $FlowFixMe - Should be inferred as not undefined.


            extraAttributeNames.delete(propKey);
          }

          serverValue = getValueForAttribute(domElement, propKey, nextProp);
        }

        if (nextProp !== serverValue && !isMismatchDueToBadCasing) {
          warnForPropDifference(propKey, serverValue, nextProp);
        }
      }
    }
  }

  {
    // $FlowFixMe - Should be inferred as not undefined.
    if (extraAttributeNames.size > 0 && !suppressHydrationWarning) {
      // $FlowFixMe - Should be inferred as not undefined.
      warnForExtraAttributes(extraAttributeNames);
    }
  }

  switch (tag) {
    case 'input':
      // TODO: Make sure we check if this is still unmounted or do any clean
      // up necessary since we never stop tracking anymore.
      track(domElement);
      postMountWrapper(domElement, rawProps, true);
      break;

    case 'textarea':
      // TODO: Make sure we check if this is still unmounted or do any clean
      // up necessary since we never stop tracking anymore.
      track(domElement);
      postMountWrapper$3(domElement);
      break;

    case 'select':
    case 'option':
      // For input and textarea we current always set the value property at
      // post mount to force it to diverge from attributes. However, for
      // option and select we don't quite do the same thing and select
      // is not resilient to the DOM state changing so we don't do that here.
      // TODO: Consider not doing this for input and textarea.
      break;

    default:
      if (typeof rawProps.onClick === 'function') {
        // TODO: This cast may not be sound for SVG, MathML or custom elements.
        trapClickOnNonInteractiveElement(domElement);
      }

      break;
  }

  return updatePayload;
}
function diffHydratedText(textNode, text) {
  var isDifferent = textNode.nodeValue !== text;
  return isDifferent;
}
function warnForUnmatchedText(textNode, text) {
  {
    warnForTextDifference(textNode.nodeValue, text);
  }
}
function warnForDeletedHydratableElement(parentNode, child) {
  {
    if (didWarnInvalidHydration) {
      return;
    }

    didWarnInvalidHydration = true;

    error('Did not expect server HTML to contain a <%s> in <%s>.', child.nodeName.toLowerCase(), parentNode.nodeName.toLowerCase());
  }
}
function warnForDeletedHydratableText(parentNode, child) {
  {
    if (didWarnInvalidHydration) {
      return;
    }

    didWarnInvalidHydration = true;

    error('Did not expect server HTML to contain the text node "%s" in <%s>.', child.nodeValue, parentNode.nodeName.toLowerCase());
  }
}
function warnForInsertedHydratedElement(parentNode, tag, props) {
  {
    if (didWarnInvalidHydration) {
      return;
    }

    didWarnInvalidHydration = true;

    error('Expected server HTML to contain a matching <%s> in <%s>.', tag, parentNode.nodeName.toLowerCase());
  }
}
function warnForInsertedHydratedText(parentNode, text) {
  {
    if (text === '') {
      // We expect to insert empty text nodes since they're not represented in
      // the HTML.
      // TODO: Remove this special case if we can just avoid inserting empty
      // text nodes.
      return;
    }

    if (didWarnInvalidHydration) {
      return;
    }

    didWarnInvalidHydration = true;

    error('Expected server HTML to contain a matching text node for "%s" in <%s>.', text, parentNode.nodeName.toLowerCase());
  }
}
function restoreControlledState$3(domElement, tag, props) {
  switch (tag) {
    case 'input':
      restoreControlledState(domElement, props);
      return;

    case 'textarea':
      restoreControlledState$2(domElement, props);
      return;

    case 'select':
      restoreControlledState$1(domElement, props);
      return;
  }
}

var validateDOMNesting = function () {};

var updatedAncestorInfo = function () {};

{
  // This validation code was written based on the HTML5 parsing spec:
  // https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-scope
  //
  // Note: this does not catch all invalid nesting, nor does it try to (as it's
  // not clear what practical benefit doing so provides); instead, we warn only
  // for cases where the parser will give a parse tree differing from what React
  // intended. For example, <b><div></div></b> is invalid but we don't warn
  // because it still parses correctly; we do warn for other cases like nested
  // <p> tags where the beginning of the second element implicitly closes the
  // first, causing a confusing mess.
  // https://html.spec.whatwg.org/multipage/syntax.html#special
  var specialTags = ['address', 'applet', 'area', 'article', 'aside', 'base', 'basefont', 'bgsound', 'blockquote', 'body', 'br', 'button', 'caption', 'center', 'col', 'colgroup', 'dd', 'details', 'dir', 'div', 'dl', 'dt', 'embed', 'fieldset', 'figcaption', 'figure', 'footer', 'form', 'frame', 'frameset', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'head', 'header', 'hgroup', 'hr', 'html', 'iframe', 'img', 'input', 'isindex', 'li', 'link', 'listing', 'main', 'marquee', 'menu', 'menuitem', 'meta', 'nav', 'noembed', 'noframes', 'noscript', 'object', 'ol', 'p', 'param', 'plaintext', 'pre', 'script', 'section', 'select', 'source', 'style', 'summary', 'table', 'tbody', 'td', 'template', 'textarea', 'tfoot', 'th', 'thead', 'title', 'tr', 'track', 'ul', 'wbr', 'xmp']; // https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-scope

  var inScopeTags = ['applet', 'caption', 'html', 'table', 'td', 'th', 'marquee', 'object', 'template', // https://html.spec.whatwg.org/multipage/syntax.html#html-integration-point
  // TODO: Distinguish by namespace here -- for <title>, including it here
  // errs on the side of fewer warnings
  'foreignObject', 'desc', 'title']; // https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-button-scope

  var buttonScopeTags = inScopeTags.concat(['button']); // https://html.spec.whatwg.org/multipage/syntax.html#generate-implied-end-tags

  var impliedEndTags = ['dd', 'dt', 'li', 'option', 'optgroup', 'p', 'rp', 'rt'];
  var emptyAncestorInfo = {
    current: null,
    formTag: null,
    aTagInScope: null,
    buttonTagInScope: null,
    nobrTagInScope: null,
    pTagInButtonScope: null,
    listItemTagAutoclosing: null,
    dlItemTagAutoclosing: null
  };

  updatedAncestorInfo = function (oldInfo, tag) {
    var ancestorInfo = _assign({}, oldInfo || emptyAncestorInfo);

    var info = {
      tag: tag
    };

    if (inScopeTags.indexOf(tag) !== -1) {
      ancestorInfo.aTagInScope = null;
      ancestorInfo.buttonTagInScope = null;
      ancestorInfo.nobrTagInScope = null;
    }

    if (buttonScopeTags.indexOf(tag) !== -1) {
      ancestorInfo.pTagInButtonScope = null;
    } // See rules for 'li', 'dd', 'dt' start tags in
    // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inbody


    if (specialTags.indexOf(tag) !== -1 && tag !== 'address' && tag !== 'div' && tag !== 'p') {
      ancestorInfo.listItemTagAutoclosing = null;
      ancestorInfo.dlItemTagAutoclosing = null;
    }

    ancestorInfo.current = info;

    if (tag === 'form') {
      ancestorInfo.formTag = info;
    }

    if (tag === 'a') {
      ancestorInfo.aTagInScope = info;
    }

    if (tag === 'button') {
      ancestorInfo.buttonTagInScope = info;
    }

    if (tag === 'nobr') {
      ancestorInfo.nobrTagInScope = info;
    }

    if (tag === 'p') {
      ancestorInfo.pTagInButtonScope = info;
    }

    if (tag === 'li') {
      ancestorInfo.listItemTagAutoclosing = info;
    }

    if (tag === 'dd' || tag === 'dt') {
      ancestorInfo.dlItemTagAutoclosing = info;
    }

    return ancestorInfo;
  };
  /**
   * Returns whether
   */


  var isTagValidWithParent = function (tag, parentTag) {
    // First, let's check if we're in an unusual parsing mode...
    switch (parentTag) {
      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inselect
      case 'select':
        return tag === 'option' || tag === 'optgroup' || tag === '#text';

      case 'optgroup':
        return tag === 'option' || tag === '#text';
      // Strictly speaking, seeing an <option> doesn't mean we're in a <select>
      // but

      case 'option':
        return tag === '#text';
      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intd
      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-incaption
      // No special behavior since these rules fall back to "in body" mode for
      // all except special table nodes which cause bad parsing behavior anyway.
      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intr

      case 'tr':
        return tag === 'th' || tag === 'td' || tag === 'style' || tag === 'script' || tag === 'template';
      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intbody

      case 'tbody':
      case 'thead':
      case 'tfoot':
        return tag === 'tr' || tag === 'style' || tag === 'script' || tag === 'template';
      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-incolgroup

      case 'colgroup':
        return tag === 'col' || tag === 'template';
      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intable

      case 'table':
        return tag === 'caption' || tag === 'colgroup' || tag === 'tbody' || tag === 'tfoot' || tag === 'thead' || tag === 'style' || tag === 'script' || tag === 'template';
      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inhead

      case 'head':
        return tag === 'base' || tag === 'basefont' || tag === 'bgsound' || tag === 'link' || tag === 'meta' || tag === 'title' || tag === 'noscript' || tag === 'noframes' || tag === 'style' || tag === 'script' || tag === 'template';
      // https://html.spec.whatwg.org/multipage/semantics.html#the-html-element

      case 'html':
        return tag === 'head' || tag === 'body' || tag === 'frameset';

      case 'frameset':
        return tag === 'frame';

      case '#document':
        return tag === 'html';
    } // Probably in the "in body" parsing mode, so we outlaw only tag combos
    // where the parsing rules cause implicit opens or closes to be added.
    // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inbody


    switch (tag) {
      case 'h1':
      case 'h2':
      case 'h3':
      case 'h4':
      case 'h5':
      case 'h6':
        return parentTag !== 'h1' && parentTag !== 'h2' && parentTag !== 'h3' && parentTag !== 'h4' && parentTag !== 'h5' && parentTag !== 'h6';

      case 'rp':
      case 'rt':
        return impliedEndTags.indexOf(parentTag) === -1;

      case 'body':
      case 'caption':
      case 'col':
      case 'colgroup':
      case 'frameset':
      case 'frame':
      case 'head':
      case 'html':
      case 'tbody':
      case 'td':
      case 'tfoot':
      case 'th':
      case 'thead':
      case 'tr':
        // These tags are only valid with a few parents that have special child
        // parsing rules -- if we're down here, then none of those matched and
        // so we allow it only if we don't know what the parent is, as all other
        // cases are invalid.
        return parentTag == null;
    }

    return true;
  };
  /**
   * Returns whether
   */


  var findInvalidAncestorForTag = function (tag, ancestorInfo) {
    switch (tag) {
      case 'address':
      case 'article':
      case 'aside':
      case 'blockquote':
      case 'center':
      case 'details':
      case 'dialog':
      case 'dir':
      case 'div':
      case 'dl':
      case 'fieldset':
      case 'figcaption':
      case 'figure':
      case 'footer':
      case 'header':
      case 'hgroup':
      case 'main':
      case 'menu':
      case 'nav':
      case 'ol':
      case 'p':
      case 'section':
      case 'summary':
      case 'ul':
      case 'pre':
      case 'listing':
      case 'table':
      case 'hr':
      case 'xmp':
      case 'h1':
      case 'h2':
      case 'h3':
      case 'h4':
      case 'h5':
      case 'h6':
        return ancestorInfo.pTagInButtonScope;

      case 'form':
        return ancestorInfo.formTag || ancestorInfo.pTagInButtonScope;

      case 'li':
        return ancestorInfo.listItemTagAutoclosing;

      case 'dd':
      case 'dt':
        return ancestorInfo.dlItemTagAutoclosing;

      case 'button':
        return ancestorInfo.buttonTagInScope;

      case 'a':
        // Spec says something about storing a list of markers, but it sounds
        // equivalent to this check.
        return ancestorInfo.aTagInScope;

      case 'nobr':
        return ancestorInfo.nobrTagInScope;
    }

    return null;
  };

  var didWarn$1 = {};

  validateDOMNesting = function (childTag, childText, ancestorInfo) {
    ancestorInfo = ancestorInfo || emptyAncestorInfo;
    var parentInfo = ancestorInfo.current;
    var parentTag = parentInfo && parentInfo.tag;

    if (childText != null) {
      if (childTag != null) {
        error('validateDOMNesting: when childText is passed, childTag should be null');
      }

      childTag = '#text';
    }

    var invalidParent = isTagValidWithParent(childTag, parentTag) ? null : parentInfo;
    var invalidAncestor = invalidParent ? null : findInvalidAncestorForTag(childTag, ancestorInfo);
    var invalidParentOrAncestor = invalidParent || invalidAncestor;

    if (!invalidParentOrAncestor) {
      return;
    }

    var ancestorTag = invalidParentOrAncestor.tag;
    var warnKey = !!invalidParent + '|' + childTag + '|' + ancestorTag;

    if (didWarn$1[warnKey]) {
      return;
    }

    didWarn$1[warnKey] = true;
    var tagDisplayName = childTag;
    var whitespaceInfo = '';

    if (childTag === '#text') {
      if (/\S/.test(childText)) {
        tagDisplayName = 'Text nodes';
      } else {
        tagDisplayName = 'Whitespace text nodes';
        whitespaceInfo = " Make sure you don't have any extra whitespace between tags on " + 'each line of your source code.';
      }
    } else {
      tagDisplayName = '<' + childTag + '>';
    }

    if (invalidParent) {
      var info = '';

      if (ancestorTag === 'table' && childTag === 'tr') {
        info += ' Add a <tbody>, <thead> or <tfoot> to your code to match the DOM tree generated by ' + 'the browser.';
      }

      error('validateDOMNesting(...): %s cannot appear as a child of <%s>.%s%s', tagDisplayName, ancestorTag, whitespaceInfo, info);
    } else {
      error('validateDOMNesting(...): %s cannot appear as a descendant of ' + '<%s>.', tagDisplayName, ancestorTag);
    }
  };
}

var SUPPRESS_HYDRATION_WARNING$1;

{
  SUPPRESS_HYDRATION_WARNING$1 = 'suppressHydrationWarning';
}

var SUSPENSE_START_DATA = '$';
var SUSPENSE_END_DATA = '/$';
var SUSPENSE_PENDING_START_DATA = '$?';
var SUSPENSE_FALLBACK_START_DATA = '$!';
var STYLE$1 = 'style';
var eventsEnabled = null;
var selectionInformation = null;

function shouldAutoFocusHostComponent(type, props) {
  switch (type) {
    case 'button':
    case 'input':
    case 'select':
    case 'textarea':
      return !!props.autoFocus;
  }

  return false;
}
function getRootHostContext(rootContainerInstance) {
  var type;
  var namespace;
  var nodeType = rootContainerInstance.nodeType;

  switch (nodeType) {
    case DOCUMENT_NODE:
    case DOCUMENT_FRAGMENT_NODE:
      {
        type = nodeType === DOCUMENT_NODE ? '#document' : '#fragment';
        var root = rootContainerInstance.documentElement;
        namespace = root ? root.namespaceURI : getChildNamespace(null, '');
        break;
      }

    default:
      {
        var container = nodeType === COMMENT_NODE ? rootContainerInstance.parentNode : rootContainerInstance;
        var ownNamespace = container.namespaceURI || null;
        type = container.tagName;
        namespace = getChildNamespace(ownNamespace, type);
        break;
      }
  }

  {
    var validatedTag = type.toLowerCase();
    var ancestorInfo = updatedAncestorInfo(null, validatedTag);
    return {
      namespace: namespace,
      ancestorInfo: ancestorInfo
    };
  }
}
function getChildHostContext(parentHostContext, type, rootContainerInstance) {
  {
    var parentHostContextDev = parentHostContext;
    var namespace = getChildNamespace(parentHostContextDev.namespace, type);
    var ancestorInfo = updatedAncestorInfo(parentHostContextDev.ancestorInfo, type);
    return {
      namespace: namespace,
      ancestorInfo: ancestorInfo
    };
  }
}
function getPublicInstance(instance) {
  return instance;
}
function prepareForCommit(containerInfo) {
  eventsEnabled = isEnabled();
  selectionInformation = getSelectionInformation();
  var activeInstance = null;

  setEnabled(false);
  return activeInstance;
}
function resetAfterCommit(containerInfo) {
  restoreSelection(selectionInformation);
  setEnabled(eventsEnabled);
  eventsEnabled = null;
  selectionInformation = null;
}
function createInstance(type, props, rootContainerInstance, hostContext, internalInstanceHandle) {
  var parentNamespace;

  {
    // TODO: take namespace into account when validating.
    var hostContextDev = hostContext;
    validateDOMNesting(type, null, hostContextDev.ancestorInfo);

    if (typeof props.children === 'string' || typeof props.children === 'number') {
      var string = '' + props.children;
      var ownAncestorInfo = updatedAncestorInfo(hostContextDev.ancestorInfo, type);
      validateDOMNesting(null, string, ownAncestorInfo);
    }

    parentNamespace = hostContextDev.namespace;
  }

  var domElement = createElement(type, props, rootContainerInstance, parentNamespace);
  precacheFiberNode(internalInstanceHandle, domElement);
  updateFiberProps(domElement, props);
  return domElement;
}
function appendInitialChild(parentInstance, child) {
  parentInstance.appendChild(child);
}
function finalizeInitialChildren(domElement, type, props, rootContainerInstance, hostContext) {
  setInitialProperties(domElement, type, props, rootContainerInstance);
  return shouldAutoFocusHostComponent(type, props);
}
function prepareUpdate(domElement, type, oldProps, newProps, rootContainerInstance, hostContext) {
  {
    var hostContextDev = hostContext;

    if (typeof newProps.children !== typeof oldProps.children && (typeof newProps.children === 'string' || typeof newProps.children === 'number')) {
      var string = '' + newProps.children;
      var ownAncestorInfo = updatedAncestorInfo(hostContextDev.ancestorInfo, type);
      validateDOMNesting(null, string, ownAncestorInfo);
    }
  }

  return diffProperties(domElement, type, oldProps, newProps);
}
function shouldSetTextContent(type, props) {
  return type === 'textarea' || type === 'option' || type === 'noscript' || typeof props.children === 'string' || typeof props.children === 'number' || typeof props.dangerouslySetInnerHTML === 'object' && props.dangerouslySetInnerHTML !== null && props.dangerouslySetInnerHTML.__html != null;
}
function createTextInstance(text, rootContainerInstance, hostContext, internalInstanceHandle) {
  {
    var hostContextDev = hostContext;
    validateDOMNesting(null, text, hostContextDev.ancestorInfo);
  }

  var textNode = createTextNode(text, rootContainerInstance);
  precacheFiberNode(internalInstanceHandle, textNode);
  return textNode;
}
// if a component just imports ReactDOM (e.g. for findDOMNode).
// Some environments might not have setTimeout or clearTimeout.

var scheduleTimeout = typeof setTimeout === 'function' ? setTimeout : undefined;
var cancelTimeout = typeof clearTimeout === 'function' ? clearTimeout : undefined;
var noTimeout = -1; // -------------------
function commitMount(domElement, type, newProps, internalInstanceHandle) {
  // Despite the naming that might imply otherwise, this method only
  // fires if there is an `Update` effect scheduled during mounting.
  // This happens if `finalizeInitialChildren` returns `true` (which it
  // does to implement the `autoFocus` attribute on the client). But
  // there are also other cases when this might happen (such as patching
  // up text content during hydration mismatch). So we'll check this again.
  if (shouldAutoFocusHostComponent(type, newProps)) {
    domElement.focus();
  }
}
function commitUpdate(domElement, updatePayload, type, oldProps, newProps, internalInstanceHandle) {
  // Update the props handle so that we know which props are the ones with
  // with current event handlers.
  updateFiberProps(domElement, newProps); // Apply the diff to the DOM node.

  updateProperties(domElement, updatePayload, type, oldProps, newProps);
}
function resetTextContent(domElement) {
  setTextContent(domElement, '');
}
function commitTextUpdate(textInstance, oldText, newText) {
  textInstance.nodeValue = newText;
}
function appendChild(parentInstance, child) {
  parentInstance.appendChild(child);
}
function appendChildToContainer(container, child) {
  var parentNode;

  if (container.nodeType === COMMENT_NODE) {
    parentNode = container.parentNode;
    parentNode.insertBefore(child, container);
  } else {
    parentNode = container;
    parentNode.appendChild(child);
  } // This container might be used for a portal.
  // If something inside a portal is clicked, that click should bubble
  // through the React tree. However, on Mobile Safari the click would
  // never bubble through the *DOM* tree unless an ancestor with onclick
  // event exists. So we wouldn't see it and dispatch it.
  // This is why we ensure that non React root containers have inline onclick
  // defined.
  // https://github.com/facebook/react/issues/11918


  var reactRootContainer = container._reactRootContainer;

  if ((reactRootContainer === null || reactRootContainer === undefined) && parentNode.onclick === null) {
    // TODO: This cast may not be sound for SVG, MathML or custom elements.
    trapClickOnNonInteractiveElement(parentNode);
  }
}
function insertBefore(parentInstance, child, beforeChild) {
  parentInstance.insertBefore(child, beforeChild);
}
function insertInContainerBefore(container, child, beforeChild) {
  if (container.nodeType === COMMENT_NODE) {
    container.parentNode.insertBefore(child, beforeChild);
  } else {
    container.insertBefore(child, beforeChild);
  }
}

function removeChild(parentInstance, child) {
  parentInstance.removeChild(child);
}
function removeChildFromContainer(container, child) {
  if (container.nodeType === COMMENT_NODE) {
    container.parentNode.removeChild(child);
  } else {
    container.removeChild(child);
  }
}
function hideInstance(instance) {
  // TODO: Does this work for all element types? What about MathML? Should we
  // pass host context to this method?
  instance = instance;
  var style = instance.style;

  if (typeof style.setProperty === 'function') {
    style.setProperty('display', 'none', 'important');
  } else {
    style.display = 'none';
  }
}
function hideTextInstance(textInstance) {
  textInstance.nodeValue = '';
}
function unhideInstance(instance, props) {
  instance = instance;
  var styleProp = props[STYLE$1];
  var display = styleProp !== undefined && styleProp !== null && styleProp.hasOwnProperty('display') ? styleProp.display : null;
  instance.style.display = dangerousStyleValue('display', display);
}
function unhideTextInstance(textInstance, text) {
  textInstance.nodeValue = text;
}
function clearContainer(container) {
  if (container.nodeType === ELEMENT_NODE) {
    container.textContent = '';
  } else if (container.nodeType === DOCUMENT_NODE) {
    var body = container.body;

    if (body != null) {
      body.textContent = '';
    }
  }
} // -------------------
function canHydrateInstance(instance, type, props) {
  if (instance.nodeType !== ELEMENT_NODE || type.toLowerCase() !== instance.nodeName.toLowerCase()) {
    return null;
  } // This has now been refined to an element node.


  return instance;
}
function canHydrateTextInstance(instance, text) {
  if (text === '' || instance.nodeType !== TEXT_NODE) {
    // Empty strings are not parsed by HTML so there won't be a correct match here.
    return null;
  } // This has now been refined to a text node.


  return instance;
}
function isSuspenseInstancePending(instance) {
  return instance.data === SUSPENSE_PENDING_START_DATA;
}
function isSuspenseInstanceFallback(instance) {
  return instance.data === SUSPENSE_FALLBACK_START_DATA;
}

function getNextHydratable(node) {
  // Skip non-hydratable nodes.
  for (; node != null; node = node.nextSibling) {
    var nodeType = node.nodeType;

    if (nodeType === ELEMENT_NODE || nodeType === TEXT_NODE) {
      break;
    }
  }

  return node;
}

function getNextHydratableSibling(instance) {
  return getNextHydratable(instance.nextSibling);
}
function getFirstHydratableChild(parentInstance) {
  return getNextHydratable(parentInstance.firstChild);
}
function hydrateInstance(instance, type, props, rootContainerInstance, hostContext, internalInstanceHandle) {
  precacheFiberNode(internalInstanceHandle, instance); // TODO: Possibly defer this until the commit phase where all the events
  // get attached.

  updateFiberProps(instance, props);
  var parentNamespace;

  {
    var hostContextDev = hostContext;
    parentNamespace = hostContextDev.namespace;
  }

  return diffHydratedProperties(instance, type, props, parentNamespace);
}
function hydrateTextInstance(textInstance, text, internalInstanceHandle) {
  precacheFiberNode(internalInstanceHandle, textInstance);
  return diffHydratedText(textInstance, text);
}
function getNextHydratableInstanceAfterSuspenseInstance(suspenseInstance) {
  var node = suspenseInstance.nextSibling; // Skip past all nodes within this suspense boundary.
  // There might be nested nodes so we need to keep track of how
  // deep we are and only break out when we're back on top.

  var depth = 0;

  while (node) {
    if (node.nodeType === COMMENT_NODE) {
      var data = node.data;

      if (data === SUSPENSE_END_DATA) {
        if (depth === 0) {
          return getNextHydratableSibling(node);
        } else {
          depth--;
        }
      } else if (data === SUSPENSE_START_DATA || data === SUSPENSE_FALLBACK_START_DATA || data === SUSPENSE_PENDING_START_DATA) {
        depth++;
      }
    }

    node = node.nextSibling;
  } // TODO: Warn, we didn't find the end comment boundary.


  return null;
} // Returns the SuspenseInstance if this node is a direct child of a
// SuspenseInstance. I.e. if its previous sibling is a Comment with
// SUSPENSE_x_START_DATA. Otherwise, null.

function getParentSuspenseInstance(targetInstance) {
  var node = targetInstance.previousSibling; // Skip past all nodes within this suspense boundary.
  // There might be nested nodes so we need to keep track of how
  // deep we are and only break out when we're back on top.

  var depth = 0;

  while (node) {
    if (node.nodeType === COMMENT_NODE) {
      var data = node.data;

      if (data === SUSPENSE_START_DATA || data === SUSPENSE_FALLBACK_START_DATA || data === SUSPENSE_PENDING_START_DATA) {
        if (depth === 0) {
          return node;
        } else {
          depth--;
        }
      } else if (data === SUSPENSE_END_DATA) {
        depth++;
      }
    }

    node = node.previousSibling;
  }

  return null;
}
function commitHydratedContainer(container) {
  // Retry if any event replaying was blocked on this.
  retryIfBlockedOn(container);
}
function commitHydratedSuspenseInstance(suspenseInstance) {
  // Retry if any event replaying was blocked on this.
  retryIfBlockedOn(suspenseInstance);
}
function didNotMatchHydratedContainerTextInstance(parentContainer, textInstance, text) {
  {
    warnForUnmatchedText(textInstance, text);
  }
}
function didNotMatchHydratedTextInstance(parentType, parentProps, parentInstance, textInstance, text) {
  if ( parentProps[SUPPRESS_HYDRATION_WARNING$1] !== true) {
    warnForUnmatchedText(textInstance, text);
  }
}
function didNotHydrateContainerInstance(parentContainer, instance) {
  {
    if (instance.nodeType === ELEMENT_NODE) {
      warnForDeletedHydratableElement(parentContainer, instance);
    } else if (instance.nodeType === COMMENT_NODE) ; else {
      warnForDeletedHydratableText(parentContainer, instance);
    }
  }
}
function didNotHydrateInstance(parentType, parentProps, parentInstance, instance) {
  if ( parentProps[SUPPRESS_HYDRATION_WARNING$1] !== true) {
    if (instance.nodeType === ELEMENT_NODE) {
      warnForDeletedHydratableElement(parentInstance, instance);
    } else if (instance.nodeType === COMMENT_NODE) ; else {
      warnForDeletedHydratableText(parentInstance, instance);
    }
  }
}
function didNotFindHydratableContainerInstance(parentContainer, type, props) {
  {
    warnForInsertedHydratedElement(parentContainer, type);
  }
}
function didNotFindHydratableContainerTextInstance(parentContainer, text) {
  {
    warnForInsertedHydratedText(parentContainer, text);
  }
}
function didNotFindHydratableInstance(parentType, parentProps, parentInstance, type, props) {
  if ( parentProps[SUPPRESS_HYDRATION_WARNING$1] !== true) {
    warnForInsertedHydratedElement(parentInstance, type);
  }
}
function didNotFindHydratableTextInstance(parentType, parentProps, parentInstance, text) {
  if ( parentProps[SUPPRESS_HYDRATION_WARNING$1] !== true) {
    warnForInsertedHydratedText(parentInstance, text);
  }
}
function didNotFindHydratableSuspenseInstance(parentType, parentProps, parentInstance) {
  if ( parentProps[SUPPRESS_HYDRATION_WARNING$1] !== true) ;
}
var clientId = 0;
function makeClientIdInDEV(warnOnAccessInDEV) {
  var id = 'r:' + (clientId++).toString(36);
  return {
    toString: function () {
      warnOnAccessInDEV();
      return id;
    },
    valueOf: function () {
      warnOnAccessInDEV();
      return id;
    }
  };
}
function isOpaqueHydratingObject(value) {
  return value !== null && typeof value === 'object' && value.$$typeof === REACT_OPAQUE_ID_TYPE;
}
function makeOpaqueHydratingObject(attemptToReadValue) {
  return {
    $$typeof: REACT_OPAQUE_ID_TYPE,
    toString: attemptToReadValue,
    valueOf: attemptToReadValue
  };
}
function preparePortalMount(portalInstance) {
  {
    listenToAllSupportedEvents(portalInstance);
  }
}

var randomKey = Math.random().toString(36).slice(2);
var internalInstanceKey = '__reactFiber$' + randomKey;
var internalPropsKey = '__reactProps$' + randomKey;
var internalContainerInstanceKey = '__reactContainer$' + randomKey;
var internalEventHandlersKey = '__reactEvents$' + randomKey;
function precacheFiberNode(hostInst, node) {
  node[internalInstanceKey] = hostInst;
}
function markContainerAsRoot(hostRoot, node) {
  node[internalContainerInstanceKey] = hostRoot;
}
function unmarkContainerAsRoot(node) {
  node[internalContainerInstanceKey] = null;
}
function isContainerMarkedAsRoot(node) {
  return !!node[internalContainerInstanceKey];
} // Given a DOM node, return the closest HostComponent or HostText fiber ancestor.
// If the target node is part of a hydrated or not yet rendered subtree, then
// this may also return a SuspenseComponent or HostRoot to indicate that.
// Conceptually the HostRoot fiber is a child of the Container node. So if you
// pass the Container node as the targetNode, you will not actually get the
// HostRoot back. To get to the HostRoot, you need to pass a child of it.
// The same thing applies to Suspense boundaries.

function getClosestInstanceFromNode(targetNode) {
  var targetInst = targetNode[internalInstanceKey];

  if (targetInst) {
    // Don't return HostRoot or SuspenseComponent here.
    return targetInst;
  } // If the direct event target isn't a React owned DOM node, we need to look
  // to see if one of its parents is a React owned DOM node.


  var parentNode = targetNode.parentNode;

  while (parentNode) {
    // We'll check if this is a container root that could include
    // React nodes in the future. We need to check this first because
    // if we're a child of a dehydrated container, we need to first
    // find that inner container before moving on to finding the parent
    // instance. Note that we don't check this field on  the targetNode
    // itself because the fibers are conceptually between the container
    // node and the first child. It isn't surrounding the container node.
    // If it's not a container, we check if it's an instance.
    targetInst = parentNode[internalContainerInstanceKey] || parentNode[internalInstanceKey];

    if (targetInst) {
      // Since this wasn't the direct target of the event, we might have
      // stepped past dehydrated DOM nodes to get here. However they could
      // also have been non-React nodes. We need to answer which one.
      // If we the instance doesn't have any children, then there can't be
      // a nested suspense boundary within it. So we can use this as a fast
      // bailout. Most of the time, when people add non-React children to
      // the tree, it is using a ref to a child-less DOM node.
      // Normally we'd only need to check one of the fibers because if it
      // has ever gone from having children to deleting them or vice versa
      // it would have deleted the dehydrated boundary nested inside already.
      // However, since the HostRoot starts out with an alternate it might
      // have one on the alternate so we need to check in case this was a
      // root.
      var alternate = targetInst.alternate;

      if (targetInst.child !== null || alternate !== null && alternate.child !== null) {
        // Next we need to figure out if the node that skipped past is
        // nested within a dehydrated boundary and if so, which one.
        var suspenseInstance = getParentSuspenseInstance(targetNode);

        while (suspenseInstance !== null) {
          // We found a suspense instance. That means that we haven't
          // hydrated it yet. Even though we leave the comments in the
          // DOM after hydrating, and there are boundaries in the DOM
          // that could already be hydrated, we wouldn't have found them
          // through this pass since if the target is hydrated it would
          // have had an internalInstanceKey on it.
          // Let's get the fiber associated with the SuspenseComponent
          // as the deepest instance.
          var targetSuspenseInst = suspenseInstance[internalInstanceKey];

          if (targetSuspenseInst) {
            return targetSuspenseInst;
          } // If we don't find a Fiber on the comment, it might be because
          // we haven't gotten to hydrate it yet. There might still be a
          // parent boundary that hasn't above this one so we need to find
          // the outer most that is known.


          suspenseInstance = getParentSuspenseInstance(suspenseInstance); // If we don't find one, then that should mean that the parent
          // host component also hasn't hydrated yet. We can return it
          // below since it will bail out on the isMounted check later.
        }
      }

      return targetInst;
    }

    targetNode = parentNode;
    parentNode = targetNode.parentNode;
  }

  return null;
}
/**
 * Given a DOM node, return the ReactDOMComponent or ReactDOMTextComponent
 * instance, or null if the node was not rendered by this React.
 */

function getInstanceFromNode(node) {
  var inst = node[internalInstanceKey] || node[internalContainerInstanceKey];

  if (inst) {
    if (inst.tag === HostComponent || inst.tag === HostText || inst.tag === SuspenseComponent || inst.tag === HostRoot) {
      return inst;
    } else {
      return null;
    }
  }

  return null;
}
/**
 * Given a ReactDOMComponent or ReactDOMTextComponent, return the corresponding
 * DOM node.
 */

function getNodeFromInstance(inst) {
  if (inst.tag === HostComponent || inst.tag === HostText) {
    // In Fiber this, is just the state node right now. We assume it will be
    // a host component or host text.
    return inst.stateNode;
  } // Without this first invariant, passing a non-DOM-component triggers the next
  // invariant for a missing parent, which is super confusing.


  {
    {
      throw Error( "getNodeFromInstance: Invalid argument." );
    }
  }
}
function getFiberCurrentPropsFromNode(node) {
  return node[internalPropsKey] || null;
}
function updateFiberProps(node, props) {
  node[internalPropsKey] = props;
}
function getEventListenerSet(node) {
  var elementListenerSet = node[internalEventHandlersKey];

  if (elementListenerSet === undefined) {
    elementListenerSet = node[internalEventHandlersKey] = new Set();
  }

  return elementListenerSet;
}

var loggedTypeFailures = {};
var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;

function setCurrentlyValidatingElement(element) {
  {
    if (element) {
      var owner = element._owner;
      var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
      ReactDebugCurrentFrame$1.setExtraStackFrame(stack);
    } else {
      ReactDebugCurrentFrame$1.setExtraStackFrame(null);
    }
  }
}

function checkPropTypes(typeSpecs, values, location, componentName, element) {
  {
    // $FlowFixMe This is okay but Flow doesn't know it.
    var has = Function.call.bind(Object.prototype.hasOwnProperty);

    for (var typeSpecName in typeSpecs) {
      if (has(typeSpecs, typeSpecName)) {
        var error$1 = void 0; // Prop type validation may throw. In case they do, we don't want to
        // fail the render phase where it didn't fail before. So we log it.
        // After these have been cleaned up, we'll let them throw.

        try {
          // This is intentionally an invariant that gets caught. It's the same
          // behavior as without this statement except with a better message.
          if (typeof typeSpecs[typeSpecName] !== 'function') {
            var err = Error((componentName || 'React class') + ': ' + location + ' type `' + typeSpecName + '` is invalid; ' + 'it must be a function, usually from the `prop-types` package, but received `' + typeof typeSpecs[typeSpecName] + '`.' + 'This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.');
            err.name = 'Invariant Violation';
            throw err;
          }

          error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED');
        } catch (ex) {
          error$1 = ex;
        }

        if (error$1 && !(error$1 instanceof Error)) {
          setCurrentlyValidatingElement(element);

          error('%s: type specification of %s' + ' `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', location, typeSpecName, typeof error$1);

          setCurrentlyValidatingElement(null);
        }

        if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {
          // Only monitor this failure once because there tends to be a lot of the
          // same error.
          loggedTypeFailures[error$1.message] = true;
          setCurrentlyValidatingElement(element);

          error('Failed %s type: %s', location, error$1.message);

          setCurrentlyValidatingElement(null);
        }
      }
    }
  }
}

var valueStack = [];
var fiberStack;

{
  fiberStack = [];
}

var index = -1;

function createCursor(defaultValue) {
  return {
    current: defaultValue
  };
}

function pop(cursor, fiber) {
  if (index < 0) {
    {
      error('Unexpected pop.');
    }

    return;
  }

  {
    if (fiber !== fiberStack[index]) {
      error('Unexpected Fiber popped.');
    }
  }

  cursor.current = valueStack[index];
  valueStack[index] = null;

  {
    fiberStack[index] = null;
  }

  index--;
}

function push(cursor, value, fiber) {
  index++;
  valueStack[index] = cursor.current;

  {
    fiberStack[index] = fiber;
  }

  cursor.current = value;
}

var warnedAboutMissingGetChildContext;

{
  warnedAboutMissingGetChildContext = {};
}

var emptyContextObject = {};

{
  Object.freeze(emptyContextObject);
} // A cursor to the current merged context object on the stack.


var contextStackCursor = createCursor(emptyContextObject); // A cursor to a boolean indicating whether the context has changed.

var didPerformWorkStackCursor = createCursor(false); // Keep track of the previous context object that was on the stack.
// We use this to get access to the parent context after we have already
// pushed the next context provider, and now need to merge their contexts.

var previousContext = emptyContextObject;

function getUnmaskedContext(workInProgress, Component, didPushOwnContextIfProvider) {
  {
    if (didPushOwnContextIfProvider && isContextProvider(Component)) {
      // If the fiber is a context provider itself, when we read its context
      // we may have already pushed its own child context on the stack. A context
      // provider should not "see" its own child context. Therefore we read the
      // previous (parent) context instead for a context provider.
      return previousContext;
    }

    return contextStackCursor.current;
  }
}

function cacheContext(workInProgress, unmaskedContext, maskedContext) {
  {
    var instance = workInProgress.stateNode;
    instance.__reactInternalMemoizedUnmaskedChildContext = unmaskedContext;
    instance.__reactInternalMemoizedMaskedChildContext = maskedContext;
  }
}

function getMaskedContext(workInProgress, unmaskedContext) {
  {
    var type = workInProgress.type;
    var contextTypes = type.contextTypes;

    if (!contextTypes) {
      return emptyContextObject;
    } // Avoid recreating masked context unless unmasked context has changed.
    // Failing to do this will result in unnecessary calls to componentWillReceiveProps.
    // This may trigger infinite loops if componentWillReceiveProps calls setState.


    var instance = workInProgress.stateNode;

    if (instance && instance.__reactInternalMemoizedUnmaskedChildContext === unmaskedContext) {
      return instance.__reactInternalMemoizedMaskedChildContext;
    }

    var context = {};

    for (var key in contextTypes) {
      context[key] = unmaskedContext[key];
    }

    {
      var name = getComponentName(type) || 'Unknown';
      checkPropTypes(contextTypes, context, 'context', name);
    } // Cache unmasked context so we can avoid recreating masked context unless necessary.
    // Context is created before the class component is instantiated so check for instance.


    if (instance) {
      cacheContext(workInProgress, unmaskedContext, context);
    }

    return context;
  }
}

function hasContextChanged() {
  {
    return didPerformWorkStackCursor.current;
  }
}

function isContextProvider(type) {
  {
    var childContextTypes = type.childContextTypes;
    return childContextTypes !== null && childContextTypes !== undefined;
  }
}

function popContext(fiber) {
  {
    pop(didPerformWorkStackCursor, fiber);
    pop(contextStackCursor, fiber);
  }
}

function popTopLevelContextObject(fiber) {
  {
    pop(didPerformWorkStackCursor, fiber);
    pop(contextStackCursor, fiber);
  }
}

function pushTopLevelContextObject(fiber, context, didChange) {
  {
    if (!(contextStackCursor.current === emptyContextObject)) {
      {
        throw Error( "Unexpected context found on stack. This error is likely caused by a bug in React. Please file an issue." );
      }
    }

    push(contextStackCursor, context, fiber);
    push(didPerformWorkStackCursor, didChange, fiber);
  }
}

function processChildContext(fiber, type, parentContext) {
  {
    var instance = fiber.stateNode;
    var childContextTypes = type.childContextTypes; // TODO (bvaughn) Replace this behavior with an invariant() in the future.
    // It has only been added in Fiber to match the (unintentional) behavior in Stack.

    if (typeof instance.getChildContext !== 'function') {
      {
        var componentName = getComponentName(type) || 'Unknown';

        if (!warnedAboutMissingGetChildContext[componentName]) {
          warnedAboutMissingGetChildContext[componentName] = true;

          error('%s.childContextTypes is specified but there is no getChildContext() method ' + 'on the instance. You can either define getChildContext() on %s or remove ' + 'childContextTypes from it.', componentName, componentName);
        }
      }

      return parentContext;
    }

    var childContext = instance.getChildContext();

    for (var contextKey in childContext) {
      if (!(contextKey in childContextTypes)) {
        {
          throw Error( (getComponentName(type) || 'Unknown') + ".getChildContext(): key \"" + contextKey + "\" is not defined in childContextTypes." );
        }
      }
    }

    {
      var name = getComponentName(type) || 'Unknown';
      checkPropTypes(childContextTypes, childContext, 'child context', name);
    }

    return _assign({}, parentContext, childContext);
  }
}

function pushContextProvider(workInProgress) {
  {
    var instance = workInProgress.stateNode; // We push the context as early as possible to ensure stack integrity.
    // If the instance does not exist yet, we will push null at first,
    // and replace it on the stack later when invalidating the context.

    var memoizedMergedChildContext = instance && instance.__reactInternalMemoizedMergedChildContext || emptyContextObject; // Remember the parent context so we can merge with it later.
    // Inherit the parent's did-perform-work value to avoid inadvertently blocking updates.

    previousContext = contextStackCursor.current;
    push(contextStackCursor, memoizedMergedChildContext, workInProgress);
    push(didPerformWorkStackCursor, didPerformWorkStackCursor.current, workInProgress);
    return true;
  }
}

function invalidateContextProvider(workInProgress, type, didChange) {
  {
    var instance = workInProgress.stateNode;

    if (!instance) {
      {
        throw Error( "Expected to have an instance by this point. This error is likely caused by a bug in React. Please file an issue." );
      }
    }

    if (didChange) {
      // Merge parent and own context.
      // Skip this if we're not updating due to sCU.
      // This avoids unnecessarily recomputing memoized values.
      var mergedContext = processChildContext(workInProgress, type, previousContext);
      instance.__reactInternalMemoizedMergedChildContext = mergedContext; // Replace the old (or empty) context with the new one.
      // It is important to unwind the context in the reverse order.

      pop(didPerformWorkStackCursor, workInProgress);
      pop(contextStackCursor, workInProgress); // Now push the new context and mark that it has changed.

      push(contextStackCursor, mergedContext, workInProgress);
      push(didPerformWorkStackCursor, didChange, workInProgress);
    } else {
      pop(didPerformWorkStackCursor, workInProgress);
      push(didPerformWorkStackCursor, didChange, workInProgress);
    }
  }
}

function findCurrentUnmaskedContext(fiber) {
  {
    // Currently this is only used with renderSubtreeIntoContainer; not sure if it
    // makes sense elsewhere
    if (!(isFiberMounted(fiber) && fiber.tag === ClassComponent)) {
      {
        throw Error( "Expected subtree parent to be a mounted class component. This error is likely caused by a bug in React. Please file an issue." );
      }
    }

    var node = fiber;

    do {
      switch (node.tag) {
        case HostRoot:
          return node.stateNode.context;

        case ClassComponent:
          {
            var Component = node.type;

            if (isContextProvider(Component)) {
              return node.stateNode.__reactInternalMemoizedMergedChildContext;
            }

            break;
          }
      }

      node = node.return;
    } while (node !== null);

    {
      {
        throw Error( "Found unexpected detached subtree parent. This error is likely caused by a bug in React. Please file an issue." );
      }
    }
  }
}

var LegacyRoot = 0;
var BlockingRoot = 1;
var ConcurrentRoot = 2;

var rendererID = null;
var injectedHook = null;
var hasLoggedError = false;
var isDevToolsPresent = typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined';
function injectInternals(internals) {
  if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === 'undefined') {
    // No DevTools
    return false;
  }

  var hook = __REACT_DEVTOOLS_GLOBAL_HOOK__;

  if (hook.isDisabled) {
    // This isn't a real property on the hook, but it can be set to opt out
    // of DevTools integration and associated warnings and logs.
    // https://github.com/facebook/react/issues/3877
    return true;
  }

  if (!hook.supportsFiber) {
    {
      error('The installed version of React DevTools is too old and will not work ' + 'with the current version of React. Please update React DevTools. ' + 'https://reactjs.org/link/react-devtools');
    } // DevTools exists, even though it doesn't support Fiber.


    return true;
  }

  try {
    rendererID = hook.inject(internals); // We have successfully injected, so now it is safe to set up hooks.

    injectedHook = hook;
  } catch (err) {
    // Catch all errors because it is unsafe to throw during initialization.
    {
      error('React instrumentation encountered an error: %s.', err);
    }
  } // DevTools exists


  return true;
}
function onScheduleRoot(root, children) {
  {
    if (injectedHook && typeof injectedHook.onScheduleFiberRoot === 'function') {
      try {
        injectedHook.onScheduleFiberRoot(rendererID, root, children);
      } catch (err) {
        if ( !hasLoggedError) {
          hasLoggedError = true;

          error('React instrumentation encountered an error: %s', err);
        }
      }
    }
  }
}
function onCommitRoot(root, priorityLevel) {
  if (injectedHook && typeof injectedHook.onCommitFiberRoot === 'function') {
    try {
      var didError = (root.current.flags & DidCapture) === DidCapture;

      if (enableProfilerTimer) {
        injectedHook.onCommitFiberRoot(rendererID, root, priorityLevel, didError);
      } else {
        injectedHook.onCommitFiberRoot(rendererID, root, undefined, didError);
      }
    } catch (err) {
      {
        if (!hasLoggedError) {
          hasLoggedError = true;

          error('React instrumentation encountered an error: %s', err);
        }
      }
    }
  }
}
function onCommitUnmount(fiber) {
  if (injectedHook && typeof injectedHook.onCommitFiberUnmount === 'function') {
    try {
      injectedHook.onCommitFiberUnmount(rendererID, fiber);
    } catch (err) {
      {
        if (!hasLoggedError) {
          hasLoggedError = true;

          error('React instrumentation encountered an error: %s', err);
        }
      }
    }
  }
}

var Scheduler_runWithPriority = Scheduler.unstable_runWithPriority,
    Scheduler_scheduleCallback = Scheduler.unstable_scheduleCallback,
    Scheduler_cancelCallback = Scheduler.unstable_cancelCallback,
    Scheduler_shouldYield = Scheduler.unstable_shouldYield,
    Scheduler_requestPaint = Scheduler.unstable_requestPaint,
    Scheduler_now$1 = Scheduler.unstable_now,
    Scheduler_getCurrentPriorityLevel = Scheduler.unstable_getCurrentPriorityLevel,
    Scheduler_ImmediatePriority = Scheduler.unstable_ImmediatePriority,
    Scheduler_UserBlockingPriority = Scheduler.unstable_UserBlockingPriority,
    Scheduler_NormalPriority = Scheduler.unstable_NormalPriority,
    Scheduler_LowPriority = Scheduler.unstable_LowPriority,
    Scheduler_IdlePriority = Scheduler.unstable_IdlePriority;

{
  // Provide explicit error message when production+profiling bundle of e.g.
  // react-dom is used with production (non-profiling) bundle of
  // scheduler/tracing
  if (!(tracing.__interactionsRef != null && tracing.__interactionsRef.current != null)) {
    {
      throw Error( "It is not supported to run the profiling version of a renderer (for example, `react-dom/profiling`) without also replacing the `scheduler/tracing` module with `scheduler/tracing-profiling`. Your bundler might have a setting for aliasing both modules. Learn more at https://reactjs.org/link/profiling" );
    }
  }
}

var fakeCallbackNode = {}; // Except for NoPriority, these correspond to Scheduler priorities. We use
// ascending numbers so we can compare them like numbers. They start at 90 to
// avoid clashing with Scheduler's priorities.

var ImmediatePriority$1 = 99;
var UserBlockingPriority$2 = 98;
var NormalPriority$1 = 97;
var LowPriority$1 = 96;
var IdlePriority$1 = 95; // NoPriority is the absence of priority. Also React-only.

var NoPriority$1 = 90;
var shouldYield = Scheduler_shouldYield;
var requestPaint = // Fall back gracefully if we're running an older version of Scheduler.
Scheduler_requestPaint !== undefined ? Scheduler_requestPaint : function () {};
var syncQueue = null;
var immediateQueueCallbackNode = null;
var isFlushingSyncQueue = false;
var initialTimeMs$1 = Scheduler_now$1(); // If the initial timestamp is reasonably small, use Scheduler's `now` directly.
// This will be the case for modern browsers that support `performance.now`. In
// older browsers, Scheduler falls back to `Date.now`, which returns a Unix
// timestamp. In that case, subtract the module initialization time to simulate
// the behavior of performance.now and keep our times small enough to fit
// within 32 bits.
// TODO: Consider lifting this into Scheduler.

var now = initialTimeMs$1 < 10000 ? Scheduler_now$1 : function () {
  return Scheduler_now$1() - initialTimeMs$1;
};
function getCurrentPriorityLevel() {
  switch (Scheduler_getCurrentPriorityLevel()) {
    case Scheduler_ImmediatePriority:
      return ImmediatePriority$1;

    case Scheduler_UserBlockingPriority:
      return UserBlockingPriority$2;

    case Scheduler_NormalPriority:
      return NormalPriority$1;

    case Scheduler_LowPriority:
      return LowPriority$1;

    case Scheduler_IdlePriority:
      return IdlePriority$1;

    default:
      {
        {
          throw Error( "Unknown priority level." );
        }
      }

  }
}

function reactPriorityToSchedulerPriority(reactPriorityLevel) {
  switch (reactPriorityLevel) {
    case ImmediatePriority$1:
      return Scheduler_ImmediatePriority;

    case UserBlockingPriority$2:
      return Scheduler_UserBlockingPriority;

    case NormalPriority$1:
      return Scheduler_NormalPriority;

    case LowPriority$1:
      return Scheduler_LowPriority;

    case IdlePriority$1:
      return Scheduler_IdlePriority;

    default:
      {
        {
          throw Error( "Unknown priority level." );
        }
      }

  }
}

function runWithPriority$1(reactPriorityLevel, fn) {
  var priorityLevel = reactPriorityToSchedulerPriority(reactPriorityLevel);
  return Scheduler_runWithPriority(priorityLevel, fn);
}
function scheduleCallback(reactPriorityLevel, callback, options) {
  var priorityLevel = reactPriorityToSchedulerPriority(reactPriorityLevel);
  return Scheduler_scheduleCallback(priorityLevel, callback, options);
}
function scheduleSyncCallback(callback) {
  // Push this callback into an internal queue. We'll flush these either in
  // the next tick, or earlier if something calls `flushSyncCallbackQueue`.
  if (syncQueue === null) {
    syncQueue = [callback]; // Flush the queue in the next tick, at the earliest.

    immediateQueueCallbackNode = Scheduler_scheduleCallback(Scheduler_ImmediatePriority, flushSyncCallbackQueueImpl);
  } else {
    // Push onto existing queue. Don't need to schedule a callback because
    // we already scheduled one when we created the queue.
    syncQueue.push(callback);
  }

  return fakeCallbackNode;
}
function cancelCallback(callbackNode) {
  if (callbackNode !== fakeCallbackNode) {
    Scheduler_cancelCallback(callbackNode);
  }
}
function flushSyncCallbackQueue() {
  if (immediateQueueCallbackNode !== null) {
    var node = immediateQueueCallbackNode;
    immediateQueueCallbackNode = null;
    Scheduler_cancelCallback(node);
  }

  flushSyncCallbackQueueImpl();
}

function flushSyncCallbackQueueImpl() {
  if (!isFlushingSyncQueue && syncQueue !== null) {
    // Prevent re-entrancy.
    isFlushingSyncQueue = true;
    var i = 0;

    {
      try {
        var _isSync2 = true;
        var _queue = syncQueue;
        runWithPriority$1(ImmediatePriority$1, function () {
          for (; i < _queue.length; i++) {
            var callback = _queue[i];

            do {
              callback = callback(_isSync2);
            } while (callback !== null);
          }
        });
        syncQueue = null;
      } catch (error) {
        // If something throws, leave the remaining callbacks on the queue.
        if (syncQueue !== null) {
          syncQueue = syncQueue.slice(i + 1);
        } // Resume flushing in the next tick


        Scheduler_scheduleCallback(Scheduler_ImmediatePriority, flushSyncCallbackQueue);
        throw error;
      } finally {
        isFlushingSyncQueue = false;
      }
    }
  }
}

// TODO: this is special because it gets imported during build.
var ReactVersion = '17.0.2';

var NoMode = 0;
var StrictMode = 1; // TODO: Remove BlockingMode and ConcurrentMode by reading from the root
// tag instead

var BlockingMode = 2;
var ConcurrentMode = 4;
var ProfileMode = 8;
var DebugTracingMode = 16;

var ReactCurrentBatchConfig = ReactSharedInternals.ReactCurrentBatchConfig;
var NoTransition = 0;
function requestCurrentTransition() {
  return ReactCurrentBatchConfig.transition;
}

var ReactStrictModeWarnings = {
  recordUnsafeLifecycleWarnings: function (fiber, instance) {},
  flushPendingUnsafeLifecycleWarnings: function () {},
  recordLegacyContextWarning: function (fiber, instance) {},
  flushLegacyContextWarning: function () {},
  discardPendingWarnings: function () {}
};

{
  var findStrictRoot = function (fiber) {
    var maybeStrictRoot = null;
    var node = fiber;

    while (node !== null) {
      if (node.mode & StrictMode) {
        maybeStrictRoot = node;
      }

      node = node.return;
    }

    return maybeStrictRoot;
  };

  var setToSortedString = function (set) {
    var array = [];
    set.forEach(function (value) {
      array.push(value);
    });
    return array.sort().join(', ');
  };

  var pendingComponentWillMountWarnings = [];
  var pendingUNSAFE_ComponentWillMountWarnings = [];
  var pendingComponentWillReceivePropsWarnings = [];
  var pendingUNSAFE_ComponentWillReceivePropsWarnings = [];
  var pendingComponentWillUpdateWarnings = [];
  var pendingUNSAFE_ComponentWillUpdateWarnings = []; // Tracks components we have already warned about.

  var didWarnAboutUnsafeLifecycles = new Set();

  ReactStrictModeWarnings.recordUnsafeLifecycleWarnings = function (fiber, instance) {
    // Dedup strategy: Warn once per component.
    if (didWarnAboutUnsafeLifecycles.has(fiber.type)) {
      return;
    }

    if (typeof instance.componentWillMount === 'function' && // Don't warn about react-lifecycles-compat polyfilled components.
    instance.componentWillMount.__suppressDeprecationWarning !== true) {
      pendingComponentWillMountWarnings.push(fiber);
    }

    if (fiber.mode & StrictMode && typeof instance.UNSAFE_componentWillMount === 'function') {
      pendingUNSAFE_ComponentWillMountWarnings.push(fiber);
    }

    if (typeof instance.componentWillReceiveProps === 'function' && instance.componentWillReceiveProps.__suppressDeprecationWarning !== true) {
      pendingComponentWillReceivePropsWarnings.push(fiber);
    }

    if (fiber.mode & StrictMode && typeof instance.UNSAFE_componentWillReceiveProps === 'function') {
      pendingUNSAFE_ComponentWillReceivePropsWarnings.push(fiber);
    }

    if (typeof instance.componentWillUpdate === 'function' && instance.componentWillUpdate.__suppressDeprecationWarning !== true) {
      pendingComponentWillUpdateWarnings.push(fiber);
    }

    if (fiber.mode & StrictMode && typeof instance.UNSAFE_componentWillUpdate === 'function') {
      pendingUNSAFE_ComponentWillUpdateWarnings.push(fiber);
    }
  };

  ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings = function () {
    // We do an initial pass to gather component names
    var componentWillMountUniqueNames = new Set();

    if (pendingComponentWillMountWarnings.length > 0) {
      pendingComponentWillMountWarnings.forEach(function (fiber) {
        componentWillMountUniqueNames.add(getComponentName(fiber.type) || 'Component');
        didWarnAboutUnsafeLifecycles.add(fiber.type);
      });
      pendingComponentWillMountWarnings = [];
    }

    var UNSAFE_componentWillMountUniqueNames = new Set();

    if (pendingUNSAFE_ComponentWillMountWarnings.length > 0) {
      pendingUNSAFE_ComponentWillMountWarnings.forEach(function (fiber) {
        UNSAFE_componentWillMountUniqueNames.add(getComponentName(fiber.type) || 'Component');
        didWarnAboutUnsafeLifecycles.add(fiber.type);
      });
      pendingUNSAFE_ComponentWillMountWarnings = [];
    }

    var componentWillReceivePropsUniqueNames = new Set();

    if (pendingComponentWillReceivePropsWarnings.length > 0) {
      pendingComponentWillReceivePropsWarnings.forEach(function (fiber) {
        componentWillReceivePropsUniqueNames.add(getComponentName(fiber.type) || 'Component');
        didWarnAboutUnsafeLifecycles.add(fiber.type);
      });
      pendingComponentWillReceivePropsWarnings = [];
    }

    var UNSAFE_componentWillReceivePropsUniqueNames = new Set();

    if (pendingUNSAFE_ComponentWillReceivePropsWarnings.length > 0) {
      pendingUNSAFE_ComponentWillReceivePropsWarnings.forEach(function (fiber) {
        UNSAFE_componentWillReceivePropsUniqueNames.add(getComponentName(fiber.type) || 'Component');
        didWarnAboutUnsafeLifecycles.add(fiber.type);
      });
      pendingUNSAFE_ComponentWillReceivePropsWarnings = [];
    }

    var componentWillUpdateUniqueNames = new Set();

    if (pendingComponentWillUpdateWarnings.length > 0) {
      pendingComponentWillUpdateWarnings.forEach(function (fiber) {
        componentWillUpdateUniqueNames.add(getComponentName(fiber.type) || 'Component');
        didWarnAboutUnsafeLifecycles.add(fiber.type);
      });
      pendingComponentWillUpdateWarnings = [];
    }

    var UNSAFE_componentWillUpdateUniqueNames = new Set();

    if (pendingUNSAFE_ComponentWillUpdateWarnings.length > 0) {
      pendingUNSAFE_ComponentWillUpdateWarnings.forEach(function (fiber) {
        UNSAFE_componentWillUpdateUniqueNames.add(getComponentName(fiber.type) || 'Component');
        didWarnAboutUnsafeLifecycles.add(fiber.type);
      });
      pendingUNSAFE_ComponentWillUpdateWarnings = [];
    } // Finally, we flush all the warnings
    // UNSAFE_ ones before the deprecated ones, since they'll be 'louder'


    if (UNSAFE_componentWillMountUniqueNames.size > 0) {
      var sortedNames = setToSortedString(UNSAFE_componentWillMountUniqueNames);

      error('Using UNSAFE_componentWillMount in strict mode is not recommended and may indicate bugs in your code. ' + 'See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n' + '* Move code with side effects to componentDidMount, and set initial state in the constructor.\n' + '\nPlease update the following components: %s', sortedNames);
    }

    if (UNSAFE_componentWillReceivePropsUniqueNames.size > 0) {
      var _sortedNames = setToSortedString(UNSAFE_componentWillReceivePropsUniqueNames);

      error('Using UNSAFE_componentWillReceiveProps in strict mode is not recommended ' + 'and may indicate bugs in your code. ' + 'See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n' + '* Move data fetching code or side effects to componentDidUpdate.\n' + "* If you're updating state whenever props change, " + 'refactor your code to use memoization techniques or move it to ' + 'static getDerivedStateFromProps. Learn more at: https://reactjs.org/link/derived-state\n' + '\nPlease update the following components: %s', _sortedNames);
    }

    if (UNSAFE_componentWillUpdateUniqueNames.size > 0) {
      var _sortedNames2 = setToSortedString(UNSAFE_componentWillUpdateUniqueNames);

      error('Using UNSAFE_componentWillUpdate in strict mode is not recommended ' + 'and may indicate bugs in your code. ' + 'See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n' + '* Move data fetching code or side effects to componentDidUpdate.\n' + '\nPlease update the following components: %s', _sortedNames2);
    }

    if (componentWillMountUniqueNames.size > 0) {
      var _sortedNames3 = setToSortedString(componentWillMountUniqueNames);

      warn('componentWillMount has been renamed, and is not recommended for use. ' + 'See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n' + '* Move code with side effects to componentDidMount, and set initial state in the constructor.\n' + '* Rename componentWillMount to UNSAFE_componentWillMount to suppress ' + 'this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. ' + 'To rename all deprecated lifecycles to their new names, you can run ' + '`npx react-codemod rename-unsafe-lifecycles` in your project source folder.\n' + '\nPlease update the following components: %s', _sortedNames3);
    }

    if (componentWillReceivePropsUniqueNames.size > 0) {
      var _sortedNames4 = setToSortedString(componentWillReceivePropsUniqueNames);

      warn('componentWillReceiveProps has been renamed, and is not recommended for use. ' + 'See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n' + '* Move data fetching code or side effects to componentDidUpdate.\n' + "* If you're updating state whenever props change, refactor your " + 'code to use memoization techniques or move it to ' + 'static getDerivedStateFromProps. Learn more at: https://reactjs.org/link/derived-state\n' + '* Rename componentWillReceiveProps to UNSAFE_componentWillReceiveProps to suppress ' + 'this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. ' + 'To rename all deprecated lifecycles to their new names, you can run ' + '`npx react-codemod rename-unsafe-lifecycles` in your project source folder.\n' + '\nPlease update the following components: %s', _sortedNames4);
    }

    if (componentWillUpdateUniqueNames.size > 0) {
      var _sortedNames5 = setToSortedString(componentWillUpdateUniqueNames);

      warn('componentWillUpdate has been renamed, and is not recommended for use. ' + 'See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n' + '* Move data fetching code or side effects to componentDidUpdate.\n' + '* Rename componentWillUpdate to UNSAFE_componentWillUpdate to suppress ' + 'this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. ' + 'To rename all deprecated lifecycles to their new names, you can run ' + '`npx react-codemod rename-unsafe-lifecycles` in your project source folder.\n' + '\nPlease update the following components: %s', _sortedNames5);
    }
  };

  var pendingLegacyContextWarning = new Map(); // Tracks components we have already warned about.

  var didWarnAboutLegacyContext = new Set();

  ReactStrictModeWarnings.recordLegacyContextWarning = function (fiber, instance) {
    var strictRoot = findStrictRoot(fiber);

    if (strictRoot === null) {
      error('Expected to find a StrictMode component in a strict mode tree. ' + 'This error is likely caused by a bug in React. Please file an issue.');

      return;
    } // Dedup strategy: Warn once per component.


    if (didWarnAboutLegacyContext.has(fiber.type)) {
      return;
    }

    var warningsForRoot = pendingLegacyContextWarning.get(strictRoot);

    if (fiber.type.contextTypes != null || fiber.type.childContextTypes != null || instance !== null && typeof instance.getChildContext === 'function') {
      if (warningsForRoot === undefined) {
        warningsForRoot = [];
        pendingLegacyContextWarning.set(strictRoot, warningsForRoot);
      }

      warningsForRoot.push(fiber);
    }
  };

  ReactStrictModeWarnings.flushLegacyContextWarning = function () {
    pendingLegacyContextWarning.forEach(function (fiberArray, strictRoot) {
      if (fiberArray.length === 0) {
        return;
      }

      var firstFiber = fiberArray[0];
      var uniqueNames = new Set();
      fiberArray.forEach(function (fiber) {
        uniqueNames.add(getComponentName(fiber.type) || 'Component');
        didWarnAboutLegacyContext.add(fiber.type);
      });
      var sortedNames = setToSortedString(uniqueNames);

      try {
        setCurrentFiber(firstFiber);

        error('Legacy context API has been detected within a strict-mode tree.' + '\n\nThe old API will be supported in all 16.x releases, but applications ' + 'using it should migrate to the new version.' + '\n\nPlease update the following components: %s' + '\n\nLearn more about this warning here: https://reactjs.org/link/legacy-context', sortedNames);
      } finally {
        resetCurrentFiber();
      }
    });
  };

  ReactStrictModeWarnings.discardPendingWarnings = function () {
    pendingComponentWillMountWarnings = [];
    pendingUNSAFE_ComponentWillMountWarnings = [];
    pendingComponentWillReceivePropsWarnings = [];
    pendingUNSAFE_ComponentWillReceivePropsWarnings = [];
    pendingComponentWillUpdateWarnings = [];
    pendingUNSAFE_ComponentWillUpdateWarnings = [];
    pendingLegacyContextWarning = new Map();
  };
}

function resolveDefaultProps(Component, baseProps) {
  if (Component && Component.defaultProps) {
    // Resolve default props. Taken from ReactElement
    var props = _assign({}, baseProps);

    var defaultProps = Component.defaultProps;

    for (var propName in defaultProps) {
      if (props[propName] === undefined) {
        props[propName] = defaultProps[propName];
      }
    }

    return props;
  }

  return baseProps;
}

// Max 31 bit integer. The max integer size in V8 for 32-bit systems.
// Math.pow(2, 30) - 1
// 0b111111111111111111111111111111
var MAX_SIGNED_31_BIT_INT = 1073741823;

var valueCursor = createCursor(null);
var rendererSigil;

{
  // Use this to detect multiple renderers using the same context
  rendererSigil = {};
}

var currentlyRenderingFiber = null;
var lastContextDependency = null;
var lastContextWithAllBitsObserved = null;
var isDisallowedContextReadInDEV = false;
function resetContextDependencies() {
  // This is called right before React yields execution, to ensure `readContext`
  // cannot be called outside the render phase.
  currentlyRenderingFiber = null;
  lastContextDependency = null;
  lastContextWithAllBitsObserved = null;

  {
    isDisallowedContextReadInDEV = false;
  }
}
function enterDisallowedContextReadInDEV() {
  {
    isDisallowedContextReadInDEV = true;
  }
}
function exitDisallowedContextReadInDEV() {
  {
    isDisallowedContextReadInDEV = false;
  }
}
function pushProvider(providerFiber, nextValue) {
  var context = providerFiber.type._context;

  {
    push(valueCursor, context._currentValue, providerFiber);
    context._currentValue = nextValue;

    {
      if (context._currentRenderer !== undefined && context._currentRenderer !== null && context._currentRenderer !== rendererSigil) {
        error('Detected multiple renderers concurrently rendering the ' + 'same context provider. This is currently unsupported.');
      }

      context._currentRenderer = rendererSigil;
    }
  }
}
function popProvider(providerFiber) {
  var currentValue = valueCursor.current;
  pop(valueCursor, providerFiber);
  var context = providerFiber.type._context;

  {
    context._currentValue = currentValue;
  }
}
function calculateChangedBits(context, newValue, oldValue) {
  if (objectIs(oldValue, newValue)) {
    // No change
    return 0;
  } else {
    var changedBits = typeof context._calculateChangedBits === 'function' ? context._calculateChangedBits(oldValue, newValue) : MAX_SIGNED_31_BIT_INT;

    {
      if ((changedBits & MAX_SIGNED_31_BIT_INT) !== changedBits) {
        error('calculateChangedBits: Expected the return value to be a ' + '31-bit integer. Instead received: %s', changedBits);
      }
    }

    return changedBits | 0;
  }
}
function scheduleWorkOnParentPath(parent, renderLanes) {
  // Update the child lanes of all the ancestors, including the alternates.
  var node = parent;

  while (node !== null) {
    var alternate = node.alternate;

    if (!isSubsetOfLanes(node.childLanes, renderLanes)) {
      node.childLanes = mergeLanes(node.childLanes, renderLanes);

      if (alternate !== null) {
        alternate.childLanes = mergeLanes(alternate.childLanes, renderLanes);
      }
    } else if (alternate !== null && !isSubsetOfLanes(alternate.childLanes, renderLanes)) {
      alternate.childLanes = mergeLanes(alternate.childLanes, renderLanes);
    } else {
      // Neither alternate was updated, which means the rest of the
      // ancestor path already has sufficient priority.
      break;
    }

    node = node.return;
  }
}
function propagateContextChange(workInProgress, context, changedBits, renderLanes) {
  var fiber = workInProgress.child;

  if (fiber !== null) {
    // Set the return pointer of the child to the work-in-progress fiber.
    fiber.return = workInProgress;
  }

  while (fiber !== null) {
    var nextFiber = void 0; // Visit this fiber.

    var list = fiber.dependencies;

    if (list !== null) {
      nextFiber = fiber.child;
      var dependency = list.firstContext;

      while (dependency !== null) {
        // Check if the context matches.
        if (dependency.context === context && (dependency.observedBits & changedBits) !== 0) {
          // Match! Schedule an update on this fiber.
          if (fiber.tag === ClassComponent) {
            // Schedule a force update on the work-in-progress.
            var update = createUpdate(NoTimestamp, pickArbitraryLane(renderLanes));
            update.tag = ForceUpdate; // TODO: Because we don't have a work-in-progress, this will add the
            // update to the current fiber, too, which means it will persist even if
            // this render is thrown away. Since it's a race condition, not sure it's
            // worth fixing.

            enqueueUpdate(fiber, update);
          }

          fiber.lanes = mergeLanes(fiber.lanes, renderLanes);
          var alternate = fiber.alternate;

          if (alternate !== null) {
            alternate.lanes = mergeLanes(alternate.lanes, renderLanes);
          }

          scheduleWorkOnParentPath(fiber.return, renderLanes); // Mark the updated lanes on the list, too.

          list.lanes = mergeLanes(list.lanes, renderLanes); // Since we already found a match, we can stop traversing the
          // dependency list.

          break;
        }

        dependency = dependency.next;
      }
    } else if (fiber.tag === ContextProvider) {
      // Don't scan deeper if this is a matching provider
      nextFiber = fiber.type === workInProgress.type ? null : fiber.child;
    } else {
      // Traverse down.
      nextFiber = fiber.child;
    }

    if (nextFiber !== null) {
      // Set the return pointer of the child to the work-in-progress fiber.
      nextFiber.return = fiber;
    } else {
      // No child. Traverse to next sibling.
      nextFiber = fiber;

      while (nextFiber !== null) {
        if (nextFiber === workInProgress) {
          // We're back to the root of this subtree. Exit.
          nextFiber = null;
          break;
        }

        var sibling = nextFiber.sibling;

        if (sibling !== null) {
          // Set the return pointer of the sibling to the work-in-progress fiber.
          sibling.return = nextFiber.return;
          nextFiber = sibling;
          break;
        } // No more siblings. Traverse up.


        nextFiber = nextFiber.return;
      }
    }

    fiber = nextFiber;
  }
}
function prepareToReadContext(workInProgress, renderLanes) {
  currentlyRenderingFiber = workInProgress;
  lastContextDependency = null;
  lastContextWithAllBitsObserved = null;
  var dependencies = workInProgress.dependencies;

  if (dependencies !== null) {
    var firstContext = dependencies.firstContext;

    if (firstContext !== null) {
      if (includesSomeLane(dependencies.lanes, renderLanes)) {
        // Context list has a pending update. Mark that this fiber performed work.
        markWorkInProgressReceivedUpdate();
      } // Reset the work-in-progress list


      dependencies.firstContext = null;
    }
  }
}
function readContext(context, observedBits) {
  {
    // This warning would fire if you read context inside a Hook like useMemo.
    // Unlike the class check below, it's not enforced in production for perf.
    if (isDisallowedContextReadInDEV) {
      error('Context can only be read while React is rendering. ' + 'In classes, you can read it in the render method or getDerivedStateFromProps. ' + 'In function components, you can read it directly in the function body, but not ' + 'inside Hooks like useReducer() or useMemo().');
    }
  }

  if (lastContextWithAllBitsObserved === context) ; else if (observedBits === false || observedBits === 0) ; else {
    var resolvedObservedBits; // Avoid deopting on observable arguments or heterogeneous types.

    if (typeof observedBits !== 'number' || observedBits === MAX_SIGNED_31_BIT_INT) {
      // Observe all updates.
      lastContextWithAllBitsObserved = context;
      resolvedObservedBits = MAX_SIGNED_31_BIT_INT;
    } else {
      resolvedObservedBits = observedBits;
    }

    var contextItem = {
      context: context,
      observedBits: resolvedObservedBits,
      next: null
    };

    if (lastContextDependency === null) {
      if (!(currentlyRenderingFiber !== null)) {
        {
          throw Error( "Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo()." );
        }
      } // This is the first dependency for this component. Create a new list.


      lastContextDependency = contextItem;
      currentlyRenderingFiber.dependencies = {
        lanes: NoLanes,
        firstContext: contextItem,
        responders: null
      };
    } else {
      // Append a new context item.
      lastContextDependency = lastContextDependency.next = contextItem;
    }
  }

  return  context._currentValue ;
}

var UpdateState = 0;
var ReplaceState = 1;
var ForceUpdate = 2;
var CaptureUpdate = 3; // Global state that is reset at the beginning of calling `processUpdateQueue`.
// It should only be read right after calling `processUpdateQueue`, via
// `checkHasForceUpdateAfterProcessing`.

var hasForceUpdate = false;
var didWarnUpdateInsideUpdate;
var currentlyProcessingQueue;

{
  didWarnUpdateInsideUpdate = false;
  currentlyProcessingQueue = null;
}

function initializeUpdateQueue(fiber) {
  var queue = {
    baseState: fiber.memoizedState,
    firstBaseUpdate: null,
    lastBaseUpdate: null,
    shared: {
      pending: null
    },
    effects: null
  };
  fiber.updateQueue = queue;
}
function cloneUpdateQueue(current, workInProgress) {
  // Clone the update queue from current. Unless it's already a clone.
  var queue = workInProgress.updateQueue;
  var currentQueue = current.updateQueue;

  if (queue === currentQueue) {
    var clone = {
      baseState: currentQueue.baseState,
      firstBaseUpdate: currentQueue.firstBaseUpdate,
      lastBaseUpdate: currentQueue.lastBaseUpdate,
      shared: currentQueue.shared,
      effects: currentQueue.effects
    };
    workInProgress.updateQueue = clone;
  }
}
function createUpdate(eventTime, lane) {
  var update = {
    eventTime: eventTime,
    lane: lane,
    tag: UpdateState,
    payload: null,
    callback: null,
    next: null
  };
  return update;
}
function enqueueUpdate(fiber, update) {
  var updateQueue = fiber.updateQueue;

  if (updateQueue === null) {
    // Only occurs if the fiber has been unmounted.
    return;
  }

  var sharedQueue = updateQueue.shared;
  var pending = sharedQueue.pending;

  if (pending === null) {
    // This is the first update. Create a circular list.
    update.next = update;
  } else {
    update.next = pending.next;
    pending.next = update;
  }

  sharedQueue.pending = update;

  {
    if (currentlyProcessingQueue === sharedQueue && !didWarnUpdateInsideUpdate) {
      error('An update (setState, replaceState, or forceUpdate) was scheduled ' + 'from inside an update function. Update functions should be pure, ' + 'with zero side-effects. Consider using componentDidUpdate or a ' + 'callback.');

      didWarnUpdateInsideUpdate = true;
    }
  }
}
function enqueueCapturedUpdate(workInProgress, capturedUpdate) {
  // Captured updates are updates that are thrown by a child during the render
  // phase. They should be discarded if the render is aborted. Therefore,
  // we should only put them on the work-in-progress queue, not the current one.
  var queue = workInProgress.updateQueue; // Check if the work-in-progress queue is a clone.

  var current = workInProgress.alternate;

  if (current !== null) {
    var currentQueue = current.updateQueue;

    if (queue === currentQueue) {
      // The work-in-progress queue is the same as current. This happens when
      // we bail out on a parent fiber that then captures an error thrown by
      // a child. Since we want to append the update only to the work-in
      // -progress queue, we need to clone the updates. We usually clone during
      // processUpdateQueue, but that didn't happen in this case because we
      // skipped over the parent when we bailed out.
      var newFirst = null;
      var newLast = null;
      var firstBaseUpdate = queue.firstBaseUpdate;

      if (firstBaseUpdate !== null) {
        // Loop through the updates and clone them.
        var update = firstBaseUpdate;

        do {
          var clone = {
            eventTime: update.eventTime,
            lane: update.lane,
            tag: update.tag,
            payload: update.payload,
            callback: update.callback,
            next: null
          };

          if (newLast === null) {
            newFirst = newLast = clone;
          } else {
            newLast.next = clone;
            newLast = clone;
          }

          update = update.next;
        } while (update !== null); // Append the captured update the end of the cloned list.


        if (newLast === null) {
          newFirst = newLast = capturedUpdate;
        } else {
          newLast.next = capturedUpdate;
          newLast = capturedUpdate;
        }
      } else {
        // There are no base updates.
        newFirst = newLast = capturedUpdate;
      }

      queue = {
        baseState: currentQueue.baseState,
        firstBaseUpdate: newFirst,
        lastBaseUpdate: newLast,
        shared: currentQueue.shared,
        effects: currentQueue.effects
      };
      workInProgress.updateQueue = queue;
      return;
    }
  } // Append the update to the end of the list.


  var lastBaseUpdate = queue.lastBaseUpdate;

  if (lastBaseUpdate === null) {
    queue.firstBaseUpdate = capturedUpdate;
  } else {
    lastBaseUpdate.next = capturedUpdate;
  }

  queue.lastBaseUpdate = capturedUpdate;
}

function getStateFromUpdate(workInProgress, queue, update, prevState, nextProps, instance) {
  switch (update.tag) {
    case ReplaceState:
      {
        var payload = update.payload;

        if (typeof payload === 'function') {
          // Updater function
          {
            enterDisallowedContextReadInDEV();
          }

          var nextState = payload.call(instance, prevState, nextProps);

          {
            if ( workInProgress.mode & StrictMode) {
              disableLogs();

              try {
                payload.call(instance, prevState, nextProps);
              } finally {
                reenableLogs();
              }
            }

            exitDisallowedContextReadInDEV();
          }

          return nextState;
        } // State object


        return payload;
      }

    case CaptureUpdate:
      {
        workInProgress.flags = workInProgress.flags & ~ShouldCapture | DidCapture;
      }
    // Intentional fallthrough

    case UpdateState:
      {
        var _payload = update.payload;
        var partialState;

        if (typeof _payload === 'function') {
          // Updater function
          {
            enterDisallowedContextReadInDEV();
          }

          partialState = _payload.call(instance, prevState, nextProps);

          {
            if ( workInProgress.mode & StrictMode) {
              disableLogs();

              try {
                _payload.call(instance, prevState, nextProps);
              } finally {
                reenableLogs();
              }
            }

            exitDisallowedContextReadInDEV();
          }
        } else {
          // Partial state object
          partialState = _payload;
        }

        if (partialState === null || partialState === undefined) {
          // Null and undefined are treated as no-ops.
          return prevState;
        } // Merge the partial state and the previous state.


        return _assign({}, prevState, partialState);
      }

    case ForceUpdate:
      {
        hasForceUpdate = true;
        return prevState;
      }
  }

  return prevState;
}

function processUpdateQueue(workInProgress, props, instance, renderLanes) {
  // This is always non-null on a ClassComponent or HostRoot
  var queue = workInProgress.updateQueue;
  hasForceUpdate = false;

  {
    currentlyProcessingQueue = queue.shared;
  }

  var firstBaseUpdate = queue.firstBaseUpdate;
  var lastBaseUpdate = queue.lastBaseUpdate; // Check if there are pending updates. If so, transfer them to the base queue.

  var pendingQueue = queue.shared.pending;

  if (pendingQueue !== null) {
    queue.shared.pending = null; // The pending queue is circular. Disconnect the pointer between first
    // and last so that it's non-circular.

    var lastPendingUpdate = pendingQueue;
    var firstPendingUpdate = lastPendingUpdate.next;
    lastPendingUpdate.next = null; // Append pending updates to base queue

    if (lastBaseUpdate === null) {
      firstBaseUpdate = firstPendingUpdate;
    } else {
      lastBaseUpdate.next = firstPendingUpdate;
    }

    lastBaseUpdate = lastPendingUpdate; // If there's a current queue, and it's different from the base queue, then
    // we need to transfer the updates to that queue, too. Because the base
    // queue is a singly-linked list with no cycles, we can append to both
    // lists and take advantage of structural sharing.
    // TODO: Pass `current` as argument

    var current = workInProgress.alternate;

    if (current !== null) {
      // This is always non-null on a ClassComponent or HostRoot
      var currentQueue = current.updateQueue;
      var currentLastBaseUpdate = currentQueue.lastBaseUpdate;

      if (currentLastBaseUpdate !== lastBaseUpdate) {
        if (currentLastBaseUpdate === null) {
          currentQueue.firstBaseUpdate = firstPendingUpdate;
        } else {
          currentLastBaseUpdate.next = firstPendingUpdate;
        }

        currentQueue.lastBaseUpdate = lastPendingUpdate;
      }
    }
  } // These values may change as we process the queue.


  if (firstBaseUpdate !== null) {
    // Iterate through the list of updates to compute the result.
    var newState = queue.baseState; // TODO: Don't need to accumulate this. Instead, we can remove renderLanes
    // from the original lanes.

    var newLanes = NoLanes;
    var newBaseState = null;
    var newFirstBaseUpdate = null;
    var newLastBaseUpdate = null;
    var update = firstBaseUpdate;

    do {
      var updateLane = update.lane;
      var updateEventTime = update.eventTime;

      if (!isSubsetOfLanes(renderLanes, updateLane)) {
        // Priority is insufficient. Skip this update. If this is the first
        // skipped update, the previous update/state is the new base
        // update/state.
        var clone = {
          eventTime: updateEventTime,
          lane: updateLane,
          tag: update.tag,
          payload: update.payload,
          callback: update.callback,
          next: null
        };

        if (newLastBaseUpdate === null) {
          newFirstBaseUpdate = newLastBaseUpdate = clone;
          newBaseState = newState;
        } else {
          newLastBaseUpdate = newLastBaseUpdate.next = clone;
        } // Update the remaining priority in the queue.


        newLanes = mergeLanes(newLanes, updateLane);
      } else {
        // This update does have sufficient priority.
        if (newLastBaseUpdate !== null) {
          var _clone = {
            eventTime: updateEventTime,
            // This update is going to be committed so we never want uncommit
            // it. Using NoLane works because 0 is a subset of all bitmasks, so
            // this will never be skipped by the check above.
            lane: NoLane,
            tag: update.tag,
            payload: update.payload,
            callback: update.callback,
            next: null
          };
          newLastBaseUpdate = newLastBaseUpdate.next = _clone;
        } // Process this update.


        newState = getStateFromUpdate(workInProgress, queue, update, newState, props, instance);
        var callback = update.callback;

        if (callback !== null) {
          workInProgress.flags |= Callback;
          var effects = queue.effects;

          if (effects === null) {
            queue.effects = [update];
          } else {
            effects.push(update);
          }
        }
      }

      update = update.next;

      if (update === null) {
        pendingQueue = queue.shared.pending;

        if (pendingQueue === null) {
          break;
        } else {
          // An update was scheduled from inside a reducer. Add the new
          // pending updates to the end of the list and keep processing.
          var _lastPendingUpdate = pendingQueue; // Intentionally unsound. Pending updates form a circular list, but we
          // unravel them when transferring them to the base queue.

          var _firstPendingUpdate = _lastPendingUpdate.next;
          _lastPendingUpdate.next = null;
          update = _firstPendingUpdate;
          queue.lastBaseUpdate = _lastPendingUpdate;
          queue.shared.pending = null;
        }
      }
    } while (true);

    if (newLastBaseUpdate === null) {
      newBaseState = newState;
    }

    queue.baseState = newBaseState;
    queue.firstBaseUpdate = newFirstBaseUpdate;
    queue.lastBaseUpdate = newLastBaseUpdate; // Set the remaining expiration time to be whatever is remaining in the queue.
    // This should be fine because the only two other things that contribute to
    // expiration time are props and context. We're already in the middle of the
    // begin phase by the time we start processing the queue, so we've already
    // dealt with the props. Context in components that specify
    // shouldComponentUpdate is tricky; but we'll have to account for
    // that regardless.

    markSkippedUpdateLanes(newLanes);
    workInProgress.lanes = newLanes;
    workInProgress.memoizedState = newState;
  }

  {
    currentlyProcessingQueue = null;
  }
}

function callCallback(callback, context) {
  if (!(typeof callback === 'function')) {
    {
      throw Error( "Invalid argument passed as callback. Expected a function. Instead received: " + callback );
    }
  }

  callback.call(context);
}

function resetHasForceUpdateBeforeProcessing() {
  hasForceUpdate = false;
}
function checkHasForceUpdateAfterProcessing() {
  return hasForceUpdate;
}
function commitUpdateQueue(finishedWork, finishedQueue, instance) {
  // Commit the effects
  var effects = finishedQueue.effects;
  finishedQueue.effects = null;

  if (effects !== null) {
    for (var i = 0; i < effects.length; i++) {
      var effect = effects[i];
      var callback = effect.callback;

      if (callback !== null) {
        effect.callback = null;
        callCallback(callback, instance);
      }
    }
  }
}

var fakeInternalInstance = {};
var isArray = Array.isArray; // React.Component uses a shared frozen object by default.
// We'll use it to determine whether we need to initialize legacy refs.

var emptyRefsObject = new React.Component().refs;
var didWarnAboutStateAssignmentForComponent;
var didWarnAboutUninitializedState;
var didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate;
var didWarnAboutLegacyLifecyclesAndDerivedState;
var didWarnAboutUndefinedDerivedState;
var warnOnUndefinedDerivedState;
var warnOnInvalidCallback;
var didWarnAboutDirectlyAssigningPropsToState;
var didWarnAboutContextTypeAndContextTypes;
var didWarnAboutInvalidateContextType;

{
  didWarnAboutStateAssignmentForComponent = new Set();
  didWarnAboutUninitializedState = new Set();
  didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate = new Set();
  didWarnAboutLegacyLifecyclesAndDerivedState = new Set();
  didWarnAboutDirectlyAssigningPropsToState = new Set();
  didWarnAboutUndefinedDerivedState = new Set();
  didWarnAboutContextTypeAndContextTypes = new Set();
  didWarnAboutInvalidateContextType = new Set();
  var didWarnOnInvalidCallback = new Set();

  warnOnInvalidCallback = function (callback, callerName) {
    if (callback === null || typeof callback === 'function') {
      return;
    }

    var key = callerName + '_' + callback;

    if (!didWarnOnInvalidCallback.has(key)) {
      didWarnOnInvalidCallback.add(key);

      error('%s(...): Expected the last optional `callback` argument to be a ' + 'function. Instead received: %s.', callerName, callback);
    }
  };

  warnOnUndefinedDerivedState = function (type, partialState) {
    if (partialState === undefined) {
      var componentName = getComponentName(type) || 'Component';

      if (!didWarnAboutUndefinedDerivedState.has(componentName)) {
        didWarnAboutUndefinedDerivedState.add(componentName);

        error('%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. ' + 'You have returned undefined.', componentName);
      }
    }
  }; // This is so gross but it's at least non-critical and can be removed if
  // it causes problems. This is meant to give a nicer error message for
  // ReactDOM15.unstable_renderSubtreeIntoContainer(reactDOM16Component,
  // ...)) which otherwise throws a "_processChildContext is not a function"
  // exception.


  Object.defineProperty(fakeInternalInstance, '_processChildContext', {
    enumerable: false,
    value: function () {
      {
        {
          throw Error( "_processChildContext is not available in React 16+. This likely means you have multiple copies of React and are attempting to nest a React 15 tree inside a React 16 tree using unstable_renderSubtreeIntoContainer, which isn't supported. Try to make sure you have only one copy of React (and ideally, switch to ReactDOM.createPortal)." );
        }
      }
    }
  });
  Object.freeze(fakeInternalInstance);
}

function applyDerivedStateFromProps(workInProgress, ctor, getDerivedStateFromProps, nextProps) {
  var prevState = workInProgress.memoizedState;

  {
    if ( workInProgress.mode & StrictMode) {
      disableLogs();

      try {
        // Invoke the function an extra time to help detect side-effects.
        getDerivedStateFromProps(nextProps, prevState);
      } finally {
        reenableLogs();
      }
    }
  }

  var partialState = getDerivedStateFromProps(nextProps, prevState);

  {
    warnOnUndefinedDerivedState(ctor, partialState);
  } // Merge the partial state and the previous state.


  var memoizedState = partialState === null || partialState === undefined ? prevState : _assign({}, prevState, partialState);
  workInProgress.memoizedState = memoizedState; // Once the update queue is empty, persist the derived state onto the
  // base state.

  if (workInProgress.lanes === NoLanes) {
    // Queue is always non-null for classes
    var updateQueue = workInProgress.updateQueue;
    updateQueue.baseState = memoizedState;
  }
}
var classComponentUpdater = {
  isMounted: isMounted,
  enqueueSetState: function (inst, payload, callback) {
    var fiber = get(inst);
    var eventTime = requestEventTime();
    var lane = requestUpdateLane(fiber);
    var update = createUpdate(eventTime, lane);
    update.payload = payload;

    if (callback !== undefined && callback !== null) {
      {
        warnOnInvalidCallback(callback, 'setState');
      }

      update.callback = callback;
    }

    enqueueUpdate(fiber, update);
    scheduleUpdateOnFiber(fiber, lane, eventTime);
  },
  enqueueReplaceState: function (inst, payload, callback) {
    var fiber = get(inst);
    var eventTime = requestEventTime();
    var lane = requestUpdateLane(fiber);
    var update = createUpdate(eventTime, lane);
    update.tag = ReplaceState;
    update.payload = payload;

    if (callback !== undefined && callback !== null) {
      {
        warnOnInvalidCallback(callback, 'replaceState');
      }

      update.callback = callback;
    }

    enqueueUpdate(fiber, update);
    scheduleUpdateOnFiber(fiber, lane, eventTime);
  },
  enqueueForceUpdate: function (inst, callback) {
    var fiber = get(inst);
    var eventTime = requestEventTime();
    var lane = requestUpdateLane(fiber);
    var update = createUpdate(eventTime, lane);
    update.tag = ForceUpdate;

    if (callback !== undefined && callback !== null) {
      {
        warnOnInvalidCallback(callback, 'forceUpdate');
      }

      update.callback = callback;
    }

    enqueueUpdate(fiber, update);
    scheduleUpdateOnFiber(fiber, lane, eventTime);
  }
};

function checkShouldComponentUpdate(workInProgress, ctor, oldProps, newProps, oldState, newState, nextContext) {
  var instance = workInProgress.stateNode;

  if (typeof instance.shouldComponentUpdate === 'function') {
    {
      if ( workInProgress.mode & StrictMode) {
        disableLogs();

        try {
          // Invoke the function an extra time to help detect side-effects.
          instance.shouldComponentUpdate(newProps, newState, nextContext);
        } finally {
          reenableLogs();
        }
      }
    }

    var shouldUpdate = instance.shouldComponentUpdate(newProps, newState, nextContext);

    {
      if (shouldUpdate === undefined) {
        error('%s.shouldComponentUpdate(): Returned undefined instead of a ' + 'boolean value. Make sure to return true or false.', getComponentName(ctor) || 'Component');
      }
    }

    return shouldUpdate;
  }

  if (ctor.prototype && ctor.prototype.isPureReactComponent) {
    return !shallowEqual(oldProps, newProps) || !shallowEqual(oldState, newState);
  }

  return true;
}

function checkClassInstance(workInProgress, ctor, newProps) {
  var instance = workInProgress.stateNode;

  {
    var name = getComponentName(ctor) || 'Component';
    var renderPresent = instance.render;

    if (!renderPresent) {
      if (ctor.prototype && typeof ctor.prototype.render === 'function') {
        error('%s(...): No `render` method found on the returned component ' + 'instance: did you accidentally return an object from the constructor?', name);
      } else {
        error('%s(...): No `render` method found on the returned component ' + 'instance: you may have forgotten to define `render`.', name);
      }
    }

    if (instance.getInitialState && !instance.getInitialState.isReactClassApproved && !instance.state) {
      error('getInitialState was defined on %s, a plain JavaScript class. ' + 'This is only supported for classes created using React.createClass. ' + 'Did you mean to define a state property instead?', name);
    }

    if (instance.getDefaultProps && !instance.getDefaultProps.isReactClassApproved) {
      error('getDefaultProps was defined on %s, a plain JavaScript class. ' + 'This is only supported for classes created using React.createClass. ' + 'Use a static property to define defaultProps instead.', name);
    }

    if (instance.propTypes) {
      error('propTypes was defined as an instance property on %s. Use a static ' + 'property to define propTypes instead.', name);
    }

    if (instance.contextType) {
      error('contextType was defined as an instance property on %s. Use a static ' + 'property to define contextType instead.', name);
    }

    {
      if (instance.contextTypes) {
        error('contextTypes was defined as an instance property on %s. Use a static ' + 'property to define contextTypes instead.', name);
      }

      if (ctor.contextType && ctor.contextTypes && !didWarnAboutContextTypeAndContextTypes.has(ctor)) {
        didWarnAboutContextTypeAndContextTypes.add(ctor);

        error('%s declares both contextTypes and contextType static properties. ' + 'The legacy contextTypes property will be ignored.', name);
      }
    }

    if (typeof instance.componentShouldUpdate === 'function') {
      error('%s has a method called ' + 'componentShouldUpdate(). Did you mean shouldComponentUpdate()? ' + 'The name is phrased as a question because the function is ' + 'expected to return a value.', name);
    }

    if (ctor.prototype && ctor.prototype.isPureReactComponent && typeof instance.shouldComponentUpdate !== 'undefined') {
      error('%s has a method called shouldComponentUpdate(). ' + 'shouldComponentUpdate should not be used when extending React.PureComponent. ' + 'Please extend React.Component if shouldComponentUpdate is used.', getComponentName(ctor) || 'A pure component');
    }

    if (typeof instance.componentDidUnmount === 'function') {
      error('%s has a method called ' + 'componentDidUnmount(). But there is no such lifecycle method. ' + 'Did you mean componentWillUnmount()?', name);
    }

    if (typeof instance.componentDidReceiveProps === 'function') {
      error('%s has a method called ' + 'componentDidReceiveProps(). But there is no such lifecycle method. ' + 'If you meant to update the state in response to changing props, ' + 'use componentWillReceiveProps(). If you meant to fetch data or ' + 'run side-effects or mutations after React has updated the UI, use componentDidUpdate().', name);
    }

    if (typeof instance.componentWillRecieveProps === 'function') {
      error('%s has a method called ' + 'componentWillRecieveProps(). Did you mean componentWillReceiveProps()?', name);
    }

    if (typeof instance.UNSAFE_componentWillRecieveProps === 'function') {
      error('%s has a method called ' + 'UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?', name);
    }

    var hasMutatedProps = instance.props !== newProps;

    if (instance.props !== undefined && hasMutatedProps) {
      error('%s(...): When calling super() in `%s`, make sure to pass ' + "up the same props that your component's constructor was passed.", name, name);
    }

    if (instance.defaultProps) {
      error('Setting defaultProps as an instance property on %s is not supported and will be ignored.' + ' Instead, define defaultProps as a static property on %s.', name, name);
    }

    if (typeof instance.getSnapshotBeforeUpdate === 'function' && typeof instance.componentDidUpdate !== 'function' && !didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.has(ctor)) {
      didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.add(ctor);

      error('%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). ' + 'This component defines getSnapshotBeforeUpdate() only.', getComponentName(ctor));
    }

    if (typeof instance.getDerivedStateFromProps === 'function') {
      error('%s: getDerivedStateFromProps() is defined as an instance method ' + 'and will be ignored. Instead, declare it as a static method.', name);
    }

    if (typeof instance.getDerivedStateFromError === 'function') {
      error('%s: getDerivedStateFromError() is defined as an instance method ' + 'and will be ignored. Instead, declare it as a static method.', name);
    }

    if (typeof ctor.getSnapshotBeforeUpdate === 'function') {
      error('%s: getSnapshotBeforeUpdate() is defined as a static method ' + 'and will be ignored. Instead, declare it as an instance method.', name);
    }

    var _state = instance.state;

    if (_state && (typeof _state !== 'object' || isArray(_state))) {
      error('%s.state: must be set to an object or null', name);
    }

    if (typeof instance.getChildContext === 'function' && typeof ctor.childContextTypes !== 'object') {
      error('%s.getChildContext(): childContextTypes must be defined in order to ' + 'use getChildContext().', name);
    }
  }
}

function adoptClassInstance(workInProgress, instance) {
  instance.updater = classComponentUpdater;
  workInProgress.stateNode = instance; // The instance needs access to the fiber so that it can schedule updates

  set(instance, workInProgress);

  {
    instance._reactInternalInstance = fakeInternalInstance;
  }
}

function constructClassInstance(workInProgress, ctor, props) {
  var isLegacyContextConsumer = false;
  var unmaskedContext = emptyContextObject;
  var context = emptyContextObject;
  var contextType = ctor.contextType;

  {
    if ('contextType' in ctor) {
      var isValid = // Allow null for conditional declaration
      contextType === null || contextType !== undefined && contextType.$$typeof === REACT_CONTEXT_TYPE && contextType._context === undefined; // Not a <Context.Consumer>

      if (!isValid && !didWarnAboutInvalidateContextType.has(ctor)) {
        didWarnAboutInvalidateContextType.add(ctor);
        var addendum = '';

        if (contextType === undefined) {
          addendum = ' However, it is set to undefined. ' + 'This can be caused by a typo or by mixing up named and default imports. ' + 'This can also happen due to a circular dependency, so ' + 'try moving the createContext() call to a separate file.';
        } else if (typeof contextType !== 'object') {
          addendum = ' However, it is set to a ' + typeof contextType + '.';
        } else if (contextType.$$typeof === REACT_PROVIDER_TYPE) {
          addendum = ' Did you accidentally pass the Context.Provider instead?';
        } else if (contextType._context !== undefined) {
          // <Context.Consumer>
          addendum = ' Did you accidentally pass the Context.Consumer instead?';
        } else {
          addendum = ' However, it is set to an object with keys {' + Object.keys(contextType).join(', ') + '}.';
        }

        error('%s defines an invalid contextType. ' + 'contextType should point to the Context object returned by React.createContext().%s', getComponentName(ctor) || 'Component', addendum);
      }
    }
  }

  if (typeof contextType === 'object' && contextType !== null) {
    context = readContext(contextType);
  } else {
    unmaskedContext = getUnmaskedContext(workInProgress, ctor, true);
    var contextTypes = ctor.contextTypes;
    isLegacyContextConsumer = contextTypes !== null && contextTypes !== undefined;
    context = isLegacyContextConsumer ? getMaskedContext(workInProgress, unmaskedContext) : emptyContextObject;
  } // Instantiate twice to help detect side-effects.


  {
    if ( workInProgress.mode & StrictMode) {
      disableLogs();

      try {
        new ctor(props, context); // eslint-disable-line no-new
      } finally {
        reenableLogs();
      }
    }
  }

  var instance = new ctor(props, context);
  var state = workInProgress.memoizedState = instance.state !== null && instance.state !== undefined ? instance.state : null;
  adoptClassInstance(workInProgress, instance);

  {
    if (typeof ctor.getDerivedStateFromProps === 'function' && state === null) {
      var componentName = getComponentName(ctor) || 'Component';

      if (!didWarnAboutUninitializedState.has(componentName)) {
        didWarnAboutUninitializedState.add(componentName);

        error('`%s` uses `getDerivedStateFromProps` but its initial state is ' + '%s. This is not recommended. Instead, define the initial state by ' + 'assigning an object to `this.state` in the constructor of `%s`. ' + 'This ensures that `getDerivedStateFromProps` arguments have a consistent shape.', componentName, instance.state === null ? 'null' : 'undefined', componentName);
      }
    } // If new component APIs are defined, "unsafe" lifecycles won't be called.
    // Warn about these lifecycles if they are present.
    // Don't warn about react-lifecycles-compat polyfilled methods though.


    if (typeof ctor.getDerivedStateFromProps === 'function' || typeof instance.getSnapshotBeforeUpdate === 'function') {
      var foundWillMountName = null;
      var foundWillReceivePropsName = null;
      var foundWillUpdateName = null;

      if (typeof instance.componentWillMount === 'function' && instance.componentWillMount.__suppressDeprecationWarning !== true) {
        foundWillMountName = 'componentWillMount';
      } else if (typeof instance.UNSAFE_componentWillMount === 'function') {
        foundWillMountName = 'UNSAFE_componentWillMount';
      }

      if (typeof instance.componentWillReceiveProps === 'function' && instance.componentWillReceiveProps.__suppressDeprecationWarning !== true) {
        foundWillReceivePropsName = 'componentWillReceiveProps';
      } else if (typeof instance.UNSAFE_componentWillReceiveProps === 'function') {
        foundWillReceivePropsName = 'UNSAFE_componentWillReceiveProps';
      }

      if (typeof instance.componentWillUpdate === 'function' && instance.componentWillUpdate.__suppressDeprecationWarning !== true) {
        foundWillUpdateName = 'componentWillUpdate';
      } else if (typeof instance.UNSAFE_componentWillUpdate === 'function') {
        foundWillUpdateName = 'UNSAFE_componentWillUpdate';
      }

      if (foundWillMountName !== null || foundWillReceivePropsName !== null || foundWillUpdateName !== null) {
        var _componentName = getComponentName(ctor) || 'Component';

        var newApiName = typeof ctor.getDerivedStateFromProps === 'function' ? 'getDerivedStateFromProps()' : 'getSnapshotBeforeUpdate()';

        if (!didWarnAboutLegacyLifecyclesAndDerivedState.has(_componentName)) {
          didWarnAboutLegacyLifecyclesAndDerivedState.add(_componentName);

          error('Unsafe legacy lifecycles will not be called for components using new component APIs.\n\n' + '%s uses %s but also contains the following legacy lifecycles:%s%s%s\n\n' + 'The above lifecycles should be removed. Learn more about this warning here:\n' + 'https://reactjs.org/link/unsafe-component-lifecycles', _componentName, newApiName, foundWillMountName !== null ? "\n  " + foundWillMountName : '', foundWillReceivePropsName !== null ? "\n  " + foundWillReceivePropsName : '', foundWillUpdateName !== null ? "\n  " + foundWillUpdateName : '');
        }
      }
    }
  } // Cache unmasked context so we can avoid recreating masked context unless necessary.
  // ReactFiberContext usually updates this cache but can't for newly-created instances.


  if (isLegacyContextConsumer) {
    cacheContext(workInProgress, unmaskedContext, context);
  }

  return instance;
}

function callComponentWillMount(workInProgress, instance) {
  var oldState = instance.state;

  if (typeof instance.componentWillMount === 'function') {
    instance.componentWillMount();
  }

  if (typeof instance.UNSAFE_componentWillMount === 'function') {
    instance.UNSAFE_componentWillMount();
  }

  if (oldState !== instance.state) {
    {
      error('%s.componentWillMount(): Assigning directly to this.state is ' + "deprecated (except inside a component's " + 'constructor). Use setState instead.', getComponentName(workInProgress.type) || 'Component');
    }

    classComponentUpdater.enqueueReplaceState(instance, instance.state, null);
  }
}

function callComponentWillReceiveProps(workInProgress, instance, newProps, nextContext) {
  var oldState = instance.state;

  if (typeof instance.componentWillReceiveProps === 'function') {
    instance.componentWillReceiveProps(newProps, nextContext);
  }

  if (typeof instance.UNSAFE_componentWillReceiveProps === 'function') {
    instance.UNSAFE_componentWillReceiveProps(newProps, nextContext);
  }

  if (instance.state !== oldState) {
    {
      var componentName = getComponentName(workInProgress.type) || 'Component';

      if (!didWarnAboutStateAssignmentForComponent.has(componentName)) {
        didWarnAboutStateAssignmentForComponent.add(componentName);

        error('%s.componentWillReceiveProps(): Assigning directly to ' + "this.state is deprecated (except inside a component's " + 'constructor). Use setState instead.', componentName);
      }
    }

    classComponentUpdater.enqueueReplaceState(instance, instance.state, null);
  }
} // Invokes the mount life-cycles on a previously never rendered instance.


function mountClassInstance(workInProgress, ctor, newProps, renderLanes) {
  {
    checkClassInstance(workInProgress, ctor, newProps);
  }

  var instance = workInProgress.stateNode;
  instance.props = newProps;
  instance.state = workInProgress.memoizedState;
  instance.refs = emptyRefsObject;
  initializeUpdateQueue(workInProgress);
  var contextType = ctor.contextType;

  if (typeof contextType === 'object' && contextType !== null) {
    instance.context = readContext(contextType);
  } else {
    var unmaskedContext = getUnmaskedContext(workInProgress, ctor, true);
    instance.context = getMaskedContext(workInProgress, unmaskedContext);
  }

  {
    if (instance.state === newProps) {
      var componentName = getComponentName(ctor) || 'Component';

      if (!didWarnAboutDirectlyAssigningPropsToState.has(componentName)) {
        didWarnAboutDirectlyAssigningPropsToState.add(componentName);

        error('%s: It is not recommended to assign props directly to state ' + "because updates to props won't be reflected in state. " + 'In most cases, it is better to use props directly.', componentName);
      }
    }

    if (workInProgress.mode & StrictMode) {
      ReactStrictModeWarnings.recordLegacyContextWarning(workInProgress, instance);
    }

    {
      ReactStrictModeWarnings.recordUnsafeLifecycleWarnings(workInProgress, instance);
    }
  }

  processUpdateQueue(workInProgress, newProps, instance, renderLanes);
  instance.state = workInProgress.memoizedState;
  var getDerivedStateFromProps = ctor.getDerivedStateFromProps;

  if (typeof getDerivedStateFromProps === 'function') {
    applyDerivedStateFromProps(workInProgress, ctor, getDerivedStateFromProps, newProps);
    instance.state = workInProgress.memoizedState;
  } // In order to support react-lifecycles-compat polyfilled components,
  // Unsafe lifecycles should not be invoked for components using the new APIs.


  if (typeof ctor.getDerivedStateFromProps !== 'function' && typeof instance.getSnapshotBeforeUpdate !== 'function' && (typeof instance.UNSAFE_componentWillMount === 'function' || typeof instance.componentWillMount === 'function')) {
    callComponentWillMount(workInProgress, instance); // If we had additional state updates during this life-cycle, let's
    // process them now.

    processUpdateQueue(workInProgress, newProps, instance, renderLanes);
    instance.state = workInProgress.memoizedState;
  }

  if (typeof instance.componentDidMount === 'function') {
    workInProgress.flags |= Update;
  }
}

function resumeMountClassInstance(workInProgress, ctor, newProps, renderLanes) {
  var instance = workInProgress.stateNode;
  var oldProps = workInProgress.memoizedProps;
  instance.props = oldProps;
  var oldContext = instance.context;
  var contextType = ctor.contextType;
  var nextContext = emptyContextObject;

  if (typeof contextType === 'object' && contextType !== null) {
    nextContext = readContext(contextType);
  } else {
    var nextLegacyUnmaskedContext = getUnmaskedContext(workInProgress, ctor, true);
    nextContext = getMaskedContext(workInProgress, nextLegacyUnmaskedContext);
  }

  var getDerivedStateFromProps = ctor.getDerivedStateFromProps;
  var hasNewLifecycles = typeof getDerivedStateFromProps === 'function' || typeof instance.getSnapshotBeforeUpdate === 'function'; // Note: During these life-cycles, instance.props/instance.state are what
  // ever the previously attempted to render - not the "current". However,
  // during componentDidUpdate we pass the "current" props.
  // In order to support react-lifecycles-compat polyfilled components,
  // Unsafe lifecycles should not be invoked for components using the new APIs.

  if (!hasNewLifecycles && (typeof instance.UNSAFE_componentWillReceiveProps === 'function' || typeof instance.componentWillReceiveProps === 'function')) {
    if (oldProps !== newProps || oldContext !== nextContext) {
      callComponentWillReceiveProps(workInProgress, instance, newProps, nextContext);
    }
  }

  resetHasForceUpdateBeforeProcessing();
  var oldState = workInProgress.memoizedState;
  var newState = instance.state = oldState;
  processUpdateQueue(workInProgress, newProps, instance, renderLanes);
  newState = workInProgress.memoizedState;

  if (oldProps === newProps && oldState === newState && !hasContextChanged() && !checkHasForceUpdateAfterProcessing()) {
    // If an update was already in progress, we should schedule an Update
    // effect even though we're bailing out, so that cWU/cDU are called.
    if (typeof instance.componentDidMount === 'function') {
      workInProgress.flags |= Update;
    }

    return false;
  }

  if (typeof getDerivedStateFromProps === 'function') {
    applyDerivedStateFromProps(workInProgress, ctor, getDerivedStateFromProps, newProps);
    newState = workInProgress.memoizedState;
  }

  var shouldUpdate = checkHasForceUpdateAfterProcessing() || checkShouldComponentUpdate(workInProgress, ctor, oldProps, newProps, oldState, newState, nextContext);

  if (shouldUpdate) {
    // In order to support react-lifecycles-compat polyfilled components,
    // Unsafe lifecycles should not be invoked for components using the new APIs.
    if (!hasNewLifecycles && (typeof instance.UNSAFE_componentWillMount === 'function' || typeof instance.componentWillMount === 'function')) {
      if (typeof instance.componentWillMount === 'function') {
        instance.componentWillMount();
      }

      if (typeof instance.UNSAFE_componentWillMount === 'function') {
        instance.UNSAFE_componentWillMount();
      }
    }

    if (typeof instance.componentDidMount === 'function') {
      workInProgress.flags |= Update;
    }
  } else {
    // If an update was already in progress, we should schedule an Update
    // effect even though we're bailing out, so that cWU/cDU are called.
    if (typeof instance.componentDidMount === 'function') {
      workInProgress.flags |= Update;
    } // If shouldComponentUpdate returned false, we should still update the
    // memoized state to indicate that this work can be reused.


    workInProgress.memoizedProps = newProps;
    workInProgress.memoizedState = newState;
  } // Update the existing instance's state, props, and context pointers even
  // if shouldComponentUpdate returns false.


  instance.props = newProps;
  instance.state = newState;
  instance.context = nextContext;
  return shouldUpdate;
} // Invokes the update life-cycles and returns false if it shouldn't rerender.


function updateClassInstance(current, workInProgress, ctor, newProps, renderLanes) {
  var instance = workInProgress.stateNode;
  cloneUpdateQueue(current, workInProgress);
  var unresolvedOldProps = workInProgress.memoizedProps;
  var oldProps = workInProgress.type === workInProgress.elementType ? unresolvedOldProps : resolveDefaultProps(workInProgress.type, unresolvedOldProps);
  instance.props = oldProps;
  var unresolvedNewProps = workInProgress.pendingProps;
  var oldContext = instance.context;
  var contextType = ctor.contextType;
  var nextContext = emptyContextObject;

  if (typeof contextType === 'object' && contextType !== null) {
    nextContext = readContext(contextType);
  } else {
    var nextUnmaskedContext = getUnmaskedContext(workInProgress, ctor, true);
    nextContext = getMaskedContext(workInProgress, nextUnmaskedContext);
  }

  var getDerivedStateFromProps = ctor.getDerivedStateFromProps;
  var hasNewLifecycles = typeof getDerivedStateFromProps === 'function' || typeof instance.getSnapshotBeforeUpdate === 'function'; // Note: During these life-cycles, instance.props/instance.state are what
  // ever the previously attempted to render - not the "current". However,
  // during componentDidUpdate we pass the "current" props.
  // In order to support react-lifecycles-compat polyfilled components,
  // Unsafe lifecycles should not be invoked for components using the new APIs.

  if (!hasNewLifecycles && (typeof instance.UNSAFE_componentWillReceiveProps === 'function' || typeof instance.componentWillReceiveProps === 'function')) {
    if (unresolvedOldProps !== unresolvedNewProps || oldContext !== nextContext) {
      callComponentWillReceiveProps(workInProgress, instance, newProps, nextContext);
    }
  }

  resetHasForceUpdateBeforeProcessing();
  var oldState = workInProgress.memoizedState;
  var newState = instance.state = oldState;
  processUpdateQueue(workInProgress, newProps, instance, renderLanes);
  newState = workInProgress.memoizedState;

  if (unresolvedOldProps === unresolvedNewProps && oldState === newState && !hasContextChanged() && !checkHasForceUpdateAfterProcessing()) {
    // If an update was already in progress, we should schedule an Update
    // effect even though we're bailing out, so that cWU/cDU are called.
    if (typeof instance.componentDidUpdate === 'function') {
      if (unresolvedOldProps !== current.memoizedProps || oldState !== current.memoizedState) {
        workInProgress.flags |= Update;
      }
    }

    if (typeof instance.getSnapshotBeforeUpdate === 'function') {
      if (unresolvedOldProps !== current.memoizedProps || oldState !== current.memoizedState) {
        workInProgress.flags |= Snapshot;
      }
    }

    return false;
  }

  if (typeof getDerivedStateFromProps === 'function') {
    applyDerivedStateFromProps(workInProgress, ctor, getDerivedStateFromProps, newProps);
    newState = workInProgress.memoizedState;
  }

  var shouldUpdate = checkHasForceUpdateAfterProcessing() || checkShouldComponentUpdate(workInProgress, ctor, oldProps, newProps, oldState, newState, nextContext);

  if (shouldUpdate) {
    // In order to support react-lifecycles-compat polyfilled components,
    // Unsafe lifecycles should not be invoked for components using the new APIs.
    if (!hasNewLifecycles && (typeof instance.UNSAFE_componentWillUpdate === 'function' || typeof instance.componentWillUpdate === 'function')) {
      if (typeof instance.componentWillUpdate === 'function') {
        instance.componentWillUpdate(newProps, newState, nextContext);
      }

      if (typeof instance.UNSAFE_componentWillUpdate === 'function') {
        instance.UNSAFE_componentWillUpdate(newProps, newState, nextContext);
      }
    }

    if (typeof instance.componentDidUpdate === 'function') {
      workInProgress.flags |= Update;
    }

    if (typeof instance.getSnapshotBeforeUpdate === 'function') {
      workInProgress.flags |= Snapshot;
    }
  } else {
    // If an update was already in progress, we should schedule an Update
    // effect even though we're bailing out, so that cWU/cDU are called.
    if (typeof instance.componentDidUpdate === 'function') {
      if (unresolvedOldProps !== current.memoizedProps || oldState !== current.memoizedState) {
        workInProgress.flags |= Update;
      }
    }

    if (typeof instance.getSnapshotBeforeUpdate === 'function') {
      if (unresolvedOldProps !== current.memoizedProps || oldState !== current.memoizedState) {
        workInProgress.flags |= Snapshot;
      }
    } // If shouldComponentUpdate returned false, we should still update the
    // memoized props/state to indicate that this work can be reused.


    workInProgress.memoizedProps = newProps;
    workInProgress.memoizedState = newState;
  } // Update the existing instance's state, props, and context pointers even
  // if shouldComponentUpdate returns false.


  instance.props = newProps;
  instance.state = newState;
  instance.context = nextContext;
  return shouldUpdate;
}

var didWarnAboutMaps;
var didWarnAboutGenerators;
var didWarnAboutStringRefs;
var ownerHasKeyUseWarning;
var ownerHasFunctionTypeWarning;

var warnForMissingKey = function (child, returnFiber) {};

{
  didWarnAboutMaps = false;
  didWarnAboutGenerators = false;
  didWarnAboutStringRefs = {};
  /**
   * Warn if there's no key explicitly set on dynamic arrays of children or
   * object keys are not valid. This allows us to keep track of children between
   * updates.
   */

  ownerHasKeyUseWarning = {};
  ownerHasFunctionTypeWarning = {};

  warnForMissingKey = function (child, returnFiber) {
    if (child === null || typeof child !== 'object') {
      return;
    }

    if (!child._store || child._store.validated || child.key != null) {
      return;
    }

    if (!(typeof child._store === 'object')) {
      {
        throw Error( "React Component in warnForMissingKey should have a _store. This error is likely caused by a bug in React. Please file an issue." );
      }
    }

    child._store.validated = true;
    var componentName = getComponentName(returnFiber.type) || 'Component';

    if (ownerHasKeyUseWarning[componentName]) {
      return;
    }

    ownerHasKeyUseWarning[componentName] = true;

    error('Each child in a list should have a unique ' + '"key" prop. See https://reactjs.org/link/warning-keys for ' + 'more information.');
  };
}

var isArray$1 = Array.isArray;

function coerceRef(returnFiber, current, element) {
  var mixedRef = element.ref;

  if (mixedRef !== null && typeof mixedRef !== 'function' && typeof mixedRef !== 'object') {
    {
      // TODO: Clean this up once we turn on the string ref warning for
      // everyone, because the strict mode case will no longer be relevant
      if ((returnFiber.mode & StrictMode || warnAboutStringRefs) && // We warn in ReactElement.js if owner and self are equal for string refs
      // because these cannot be automatically converted to an arrow function
      // using a codemod. Therefore, we don't have to warn about string refs again.
      !(element._owner && element._self && element._owner.stateNode !== element._self)) {
        var componentName = getComponentName(returnFiber.type) || 'Component';

        if (!didWarnAboutStringRefs[componentName]) {
          {
            error('A string ref, "%s", has been found within a strict mode tree. ' + 'String refs are a source of potential bugs and should be avoided. ' + 'We recommend using useRef() or createRef() instead. ' + 'Learn more about using refs safely here: ' + 'https://reactjs.org/link/strict-mode-string-ref', mixedRef);
          }

          didWarnAboutStringRefs[componentName] = true;
        }
      }
    }

    if (element._owner) {
      var owner = element._owner;
      var inst;

      if (owner) {
        var ownerFiber = owner;

        if (!(ownerFiber.tag === ClassComponent)) {
          {
            throw Error( "Function components cannot have string refs. We recommend using useRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref" );
          }
        }

        inst = ownerFiber.stateNode;
      }

      if (!inst) {
        {
          throw Error( "Missing owner for string ref " + mixedRef + ". This error is likely caused by a bug in React. Please file an issue." );
        }
      }

      var stringRef = '' + mixedRef; // Check if previous string ref matches new string ref

      if (current !== null && current.ref !== null && typeof current.ref === 'function' && current.ref._stringRef === stringRef) {
        return current.ref;
      }

      var ref = function (value) {
        var refs = inst.refs;

        if (refs === emptyRefsObject) {
          // This is a lazy pooled frozen object, so we need to initialize.
          refs = inst.refs = {};
        }

        if (value === null) {
          delete refs[stringRef];
        } else {
          refs[stringRef] = value;
        }
      };

      ref._stringRef = stringRef;
      return ref;
    } else {
      if (!(typeof mixedRef === 'string')) {
        {
          throw Error( "Expected ref to be a function, a string, an object returned by React.createRef(), or null." );
        }
      }

      if (!element._owner) {
        {
          throw Error( "Element ref was specified as a string (" + mixedRef + ") but no owner was set. This could happen for one of the following reasons:\n1. You may be adding a ref to a function component\n2. You may be adding a ref to a component that was not created inside a component's render method\n3. You have multiple copies of React loaded\nSee https://reactjs.org/link/refs-must-have-owner for more information." );
        }
      }
    }
  }

  return mixedRef;
}

function throwOnInvalidObjectType(returnFiber, newChild) {
  if (returnFiber.type !== 'textarea') {
    {
      {
        throw Error( "Objects are not valid as a React child (found: " + (Object.prototype.toString.call(newChild) === '[object Object]' ? 'object with keys {' + Object.keys(newChild).join(', ') + '}' : newChild) + "). If you meant to render a collection of children, use an array instead." );
      }
    }
  }
}

function warnOnFunctionType(returnFiber) {
  {
    var componentName = getComponentName(returnFiber.type) || 'Component';

    if (ownerHasFunctionTypeWarning[componentName]) {
      return;
    }

    ownerHasFunctionTypeWarning[componentName] = true;

    error('Functions are not valid as a React child. This may happen if ' + 'you return a Component instead of <Component /> from render. ' + 'Or maybe you meant to call this function rather than return it.');
  }
} // We avoid inlining this to avoid potential deopts from using try/catch.
// to be able to optimize each path individually by branching early. This needs
// a compiler or we can do it manually. Helpers that don't need this branching
// live outside of this function.


function ChildReconciler(shouldTrackSideEffects) {
  function deleteChild(returnFiber, childToDelete) {
    if (!shouldTrackSideEffects) {
      // Noop.
      return;
    } // Deletions are added in reversed order so we add it to the front.
    // At this point, the return fiber's effect list is empty except for
    // deletions, so we can just append the deletion to the list. The remaining
    // effects aren't added until the complete phase. Once we implement
    // resuming, this may not be true.


    var last = returnFiber.lastEffect;

    if (last !== null) {
      last.nextEffect = childToDelete;
      returnFiber.lastEffect = childToDelete;
    } else {
      returnFiber.firstEffect = returnFiber.lastEffect = childToDelete;
    }

    childToDelete.nextEffect = null;
    childToDelete.flags = Deletion;
  }

  function deleteRemainingChildren(returnFiber, currentFirstChild) {
    if (!shouldTrackSideEffects) {
      // Noop.
      return null;
    } // TODO: For the shouldClone case, this could be micro-optimized a bit by
    // assuming that after the first child we've already added everything.


    var childToDelete = currentFirstChild;

    while (childToDelete !== null) {
      deleteChild(returnFiber, childToDelete);
      childToDelete = childToDelete.sibling;
    }

    return null;
  }

  function mapRemainingChildren(returnFiber, currentFirstChild) {
    // Add the remaining children to a temporary map so that we can find them by
    // keys quickly. Implicit (null) keys get added to this set with their index
    // instead.
    var existingChildren = new Map();
    var existingChild = currentFirstChild;

    while (existingChild !== null) {
      if (existingChild.key !== null) {
        existingChildren.set(existingChild.key, existingChild);
      } else {
        existingChildren.set(existingChild.index, existingChild);
      }

      existingChild = existingChild.sibling;
    }

    return existingChildren;
  }

  function useFiber(fiber, pendingProps) {
    // We currently set sibling to null and index to 0 here because it is easy
    // to forget to do before returning it. E.g. for the single child case.
    var clone = createWorkInProgress(fiber, pendingProps);
    clone.index = 0;
    clone.sibling = null;
    return clone;
  }

  function placeChild(newFiber, lastPlacedIndex, newIndex) {
    newFiber.index = newIndex;

    if (!shouldTrackSideEffects) {
      // Noop.
      return lastPlacedIndex;
    }

    var current = newFiber.alternate;

    if (current !== null) {
      var oldIndex = current.index;

      if (oldIndex < lastPlacedIndex) {
        // This is a move.
        newFiber.flags = Placement;
        return lastPlacedIndex;
      } else {
        // This item can stay in place.
        return oldIndex;
      }
    } else {
      // This is an insertion.
      newFiber.flags = Placement;
      return lastPlacedIndex;
    }
  }

  function placeSingleChild(newFiber) {
    // This is simpler for the single child case. We only need to do a
    // placement for inserting new children.
    if (shouldTrackSideEffects && newFiber.alternate === null) {
      newFiber.flags = Placement;
    }

    return newFiber;
  }

  function updateTextNode(returnFiber, current, textContent, lanes) {
    if (current === null || current.tag !== HostText) {
      // Insert
      var created = createFiberFromText(textContent, returnFiber.mode, lanes);
      created.return = returnFiber;
      return created;
    } else {
      // Update
      var existing = useFiber(current, textContent);
      existing.return = returnFiber;
      return existing;
    }
  }

  function updateElement(returnFiber, current, element, lanes) {
    if (current !== null) {
      if (current.elementType === element.type || ( // Keep this check inline so it only runs on the false path:
       isCompatibleFamilyForHotReloading(current, element) )) {
        // Move based on index
        var existing = useFiber(current, element.props);
        existing.ref = coerceRef(returnFiber, current, element);
        existing.return = returnFiber;

        {
          existing._debugSource = element._source;
          existing._debugOwner = element._owner;
        }

        return existing;
      }
    } // Insert


    var created = createFiberFromElement(element, returnFiber.mode, lanes);
    created.ref = coerceRef(returnFiber, current, element);
    created.return = returnFiber;
    return created;
  }

  function updatePortal(returnFiber, current, portal, lanes) {
    if (current === null || current.tag !== HostPortal || current.stateNode.containerInfo !== portal.containerInfo || current.stateNode.implementation !== portal.implementation) {
      // Insert
      var created = createFiberFromPortal(portal, returnFiber.mode, lanes);
      created.return = returnFiber;
      return created;
    } else {
      // Update
      var existing = useFiber(current, portal.children || []);
      existing.return = returnFiber;
      return existing;
    }
  }

  function updateFragment(returnFiber, current, fragment, lanes, key) {
    if (current === null || current.tag !== Fragment) {
      // Insert
      var created = createFiberFromFragment(fragment, returnFiber.mode, lanes, key);
      created.return = returnFiber;
      return created;
    } else {
      // Update
      var existing = useFiber(current, fragment);
      existing.return = returnFiber;
      return existing;
    }
  }

  function createChild(returnFiber, newChild, lanes) {
    if (typeof newChild === 'string' || typeof newChild === 'number') {
      // Text nodes don't have keys. If the previous node is implicitly keyed
      // we can continue to replace it without aborting even if it is not a text
      // node.
      var created = createFiberFromText('' + newChild, returnFiber.mode, lanes);
      created.return = returnFiber;
      return created;
    }

    if (typeof newChild === 'object' && newChild !== null) {
      switch (newChild.$$typeof) {
        case REACT_ELEMENT_TYPE:
          {
            var _created = createFiberFromElement(newChild, returnFiber.mode, lanes);

            _created.ref = coerceRef(returnFiber, null, newChild);
            _created.return = returnFiber;
            return _created;
          }

        case REACT_PORTAL_TYPE:
          {
            var _created2 = createFiberFromPortal(newChild, returnFiber.mode, lanes);

            _created2.return = returnFiber;
            return _created2;
          }
      }

      if (isArray$1(newChild) || getIteratorFn(newChild)) {
        var _created3 = createFiberFromFragment(newChild, returnFiber.mode, lanes, null);

        _created3.return = returnFiber;
        return _created3;
      }

      throwOnInvalidObjectType(returnFiber, newChild);
    }

    {
      if (typeof newChild === 'function') {
        warnOnFunctionType(returnFiber);
      }
    }

    return null;
  }

  function updateSlot(returnFiber, oldFiber, newChild, lanes) {
    // Update the fiber if the keys match, otherwise return null.
    var key = oldFiber !== null ? oldFiber.key : null;

    if (typeof newChild === 'string' || typeof newChild === 'number') {
      // Text nodes don't have keys. If the previous node is implicitly keyed
      // we can continue to replace it without aborting even if it is not a text
      // node.
      if (key !== null) {
        return null;
      }

      return updateTextNode(returnFiber, oldFiber, '' + newChild, lanes);
    }

    if (typeof newChild === 'object' && newChild !== null) {
      switch (newChild.$$typeof) {
        case REACT_ELEMENT_TYPE:
          {
            if (newChild.key === key) {
              if (newChild.type === REACT_FRAGMENT_TYPE) {
                return updateFragment(returnFiber, oldFiber, newChild.props.children, lanes, key);
              }

              return updateElement(returnFiber, oldFiber, newChild, lanes);
            } else {
              return null;
            }
          }

        case REACT_PORTAL_TYPE:
          {
            if (newChild.key === key) {
              return updatePortal(returnFiber, oldFiber, newChild, lanes);
            } else {
              return null;
            }
          }
      }

      if (isArray$1(newChild) || getIteratorFn(newChild)) {
        if (key !== null) {
          return null;
        }

        return updateFragment(returnFiber, oldFiber, newChild, lanes, null);
      }

      throwOnInvalidObjectType(returnFiber, newChild);
    }

    {
      if (typeof newChild === 'function') {
        warnOnFunctionType(returnFiber);
      }
    }

    return null;
  }

  function updateFromMap(existingChildren, returnFiber, newIdx, newChild, lanes) {
    if (typeof newChild === 'string' || typeof newChild === 'number') {
      // Text nodes don't have keys, so we neither have to check the old nor
      // new node for the key. If both are text nodes, they match.
      var matchedFiber = existingChildren.get(newIdx) || null;
      return updateTextNode(returnFiber, matchedFiber, '' + newChild, lanes);
    }

    if (typeof newChild === 'object' && newChild !== null) {
      switch (newChild.$$typeof) {
        case REACT_ELEMENT_TYPE:
          {
            var _matchedFiber = existingChildren.get(newChild.key === null ? newIdx : newChild.key) || null;

            if (newChild.type === REACT_FRAGMENT_TYPE) {
              return updateFragment(returnFiber, _matchedFiber, newChild.props.children, lanes, newChild.key);
            }

            return updateElement(returnFiber, _matchedFiber, newChild, lanes);
          }

        case REACT_PORTAL_TYPE:
          {
            var _matchedFiber2 = existingChildren.get(newChild.key === null ? newIdx : newChild.key) || null;

            return updatePortal(returnFiber, _matchedFiber2, newChild, lanes);
          }

      }

      if (isArray$1(newChild) || getIteratorFn(newChild)) {
        var _matchedFiber3 = existingChildren.get(newIdx) || null;

        return updateFragment(returnFiber, _matchedFiber3, newChild, lanes, null);
      }

      throwOnInvalidObjectType(returnFiber, newChild);
    }

    {
      if (typeof newChild === 'function') {
        warnOnFunctionType(returnFiber);
      }
    }

    return null;
  }
  /**
   * Warns if there is a duplicate or missing key
   */


  function warnOnInvalidKey(child, knownKeys, returnFiber) {
    {
      if (typeof child !== 'object' || child === null) {
        return knownKeys;
      }

      switch (child.$$typeof) {
        case REACT_ELEMENT_TYPE:
        case REACT_PORTAL_TYPE:
          warnForMissingKey(child, returnFiber);
          var key = child.key;

          if (typeof key !== 'string') {
            break;
          }

          if (knownKeys === null) {
            knownKeys = new Set();
            knownKeys.add(key);
            break;
          }

          if (!knownKeys.has(key)) {
            knownKeys.add(key);
            break;
          }

          error('Encountered two children with the same key, `%s`. ' + 'Keys should be unique so that components maintain their identity ' + 'across updates. Non-unique keys may cause children to be ' + 'duplicated and/or omitted  the behavior is unsupported and ' + 'could change in a future version.', key);

          break;
      }
    }

    return knownKeys;
  }

  function reconcileChildrenArray(returnFiber, currentFirstChild, newChildren, lanes) {
    // This algorithm can't optimize by searching from both ends since we
    // don't have backpointers on fibers. I'm trying to see how far we can get
    // with that model. If it ends up not being worth the tradeoffs, we can
    // add it later.
    // Even with a two ended optimization, we'd want to optimize for the case
    // where there are few changes and brute force the comparison instead of
    // going for the Map. It'd like to explore hitting that path first in
    // forward-only mode and only go for the Map once we notice that we need
    // lots of look ahead. This doesn't handle reversal as well as two ended
    // search but that's unusual. Besides, for the two ended optimization to
    // work on Iterables, we'd need to copy the whole set.
    // In this first iteration, we'll just live with hitting the bad case
    // (adding everything to a Map) in for every insert/move.
    // If you change this code, also update reconcileChildrenIterator() which
    // uses the same algorithm.
    {
      // First, validate keys.
      var knownKeys = null;

      for (var i = 0; i < newChildren.length; i++) {
        var child = newChildren[i];
        knownKeys = warnOnInvalidKey(child, knownKeys, returnFiber);
      }
    }

    var resultingFirstChild = null;
    var previousNewFiber = null;
    var oldFiber = currentFirstChild;
    var lastPlacedIndex = 0;
    var newIdx = 0;
    var nextOldFiber = null;

    for (; oldFiber !== null && newIdx < newChildren.length; newIdx++) {
      if (oldFiber.index > newIdx) {
        nextOldFiber = oldFiber;
        oldFiber = null;
      } else {
        nextOldFiber = oldFiber.sibling;
      }

      var newFiber = updateSlot(returnFiber, oldFiber, newChildren[newIdx], lanes);

      if (newFiber === null) {
        // TODO: This breaks on empty slots like null children. That's
        // unfortunate because it triggers the slow path all the time. We need
        // a better way to communicate whether this was a miss or null,
        // boolean, undefined, etc.
        if (oldFiber === null) {
          oldFiber = nextOldFiber;
        }

        break;
      }

      if (shouldTrackSideEffects) {
        if (oldFiber && newFiber.alternate === null) {
          // We matched the slot, but we didn't reuse the existing fiber, so we
          // need to delete the existing child.
          deleteChild(returnFiber, oldFiber);
        }
      }

      lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);

      if (previousNewFiber === null) {
        // TODO: Move out of the loop. This only happens for the first run.
        resultingFirstChild = newFiber;
      } else {
        // TODO: Defer siblings if we're not at the right index for this slot.
        // I.e. if we had null values before, then we want to defer this
        // for each null value. However, we also don't want to call updateSlot
        // with the previous one.
        previousNewFiber.sibling = newFiber;
      }

      previousNewFiber = newFiber;
      oldFiber = nextOldFiber;
    }

    if (newIdx === newChildren.length) {
      // We've reached the end of the new children. We can delete the rest.
      deleteRemainingChildren(returnFiber, oldFiber);
      return resultingFirstChild;
    }

    if (oldFiber === null) {
      // If we don't have any more existing children we can choose a fast path
      // since the rest will all be insertions.
      for (; newIdx < newChildren.length; newIdx++) {
        var _newFiber = createChild(returnFiber, newChildren[newIdx], lanes);

        if (_newFiber === null) {
          continue;
        }

        lastPlacedIndex = placeChild(_newFiber, lastPlacedIndex, newIdx);

        if (previousNewFiber === null) {
          // TODO: Move out of the loop. This only happens for the first run.
          resultingFirstChild = _newFiber;
        } else {
          previousNewFiber.sibling = _newFiber;
        }

        previousNewFiber = _newFiber;
      }

      return resultingFirstChild;
    } // Add all children to a key map for quick lookups.


    var existingChildren = mapRemainingChildren(returnFiber, oldFiber); // Keep scanning and use the map to restore deleted items as moves.

    for (; newIdx < newChildren.length; newIdx++) {
      var _newFiber2 = updateFromMap(existingChildren, returnFiber, newIdx, newChildren[newIdx], lanes);

      if (_newFiber2 !== null) {
        if (shouldTrackSideEffects) {
          if (_newFiber2.alternate !== null) {
            // The new fiber is a work in progress, but if there exists a
            // current, that means that we reused the fiber. We need to delete
            // it from the child list so that we don't add it to the deletion
            // list.
            existingChildren.delete(_newFiber2.key === null ? newIdx : _newFiber2.key);
          }
        }

        lastPlacedIndex = placeChild(_newFiber2, lastPlacedIndex, newIdx);

        if (previousNewFiber === null) {
          resultingFirstChild = _newFiber2;
        } else {
          previousNewFiber.sibling = _newFiber2;
        }

        previousNewFiber = _newFiber2;
      }
    }

    if (shouldTrackSideEffects) {
      // Any existing children that weren't consumed above were deleted. We need
      // to add them to the deletion list.
      existingChildren.forEach(function (child) {
        return deleteChild(returnFiber, child);
      });
    }

    return resultingFirstChild;
  }

  function reconcileChildrenIterator(returnFiber, currentFirstChild, newChildrenIterable, lanes) {
    // This is the same implementation as reconcileChildrenArray(),
    // but using the iterator instead.
    var iteratorFn = getIteratorFn(newChildrenIterable);

    if (!(typeof iteratorFn === 'function')) {
      {
        throw Error( "An object is not an iterable. This error is likely caused by a bug in React. Please file an issue." );
      }
    }

    {
      // We don't support rendering Generators because it's a mutation.
      // See https://github.com/facebook/react/issues/12995
      if (typeof Symbol === 'function' && // $FlowFixMe Flow doesn't know about toStringTag
      newChildrenIterable[Symbol.toStringTag] === 'Generator') {
        if (!didWarnAboutGenerators) {
          error('Using Generators as children is unsupported and will likely yield ' + 'unexpected results because enumerating a generator mutates it. ' + 'You may convert it to an array with `Array.from()` or the ' + '`[...spread]` operator before rendering. Keep in mind ' + 'you might need to polyfill these features for older browsers.');
        }

        didWarnAboutGenerators = true;
      } // Warn about using Maps as children


      if (newChildrenIterable.entries === iteratorFn) {
        if (!didWarnAboutMaps) {
          error('Using Maps as children is not supported. ' + 'Use an array of keyed ReactElements instead.');
        }

        didWarnAboutMaps = true;
      } // First, validate keys.
      // We'll get a different iterator later for the main pass.


      var _newChildren = iteratorFn.call(newChildrenIterable);

      if (_newChildren) {
        var knownKeys = null;

        var _step = _newChildren.next();

        for (; !_step.done; _step = _newChildren.next()) {
          var child = _step.value;
          knownKeys = warnOnInvalidKey(child, knownKeys, returnFiber);
        }
      }
    }

    var newChildren = iteratorFn.call(newChildrenIterable);

    if (!(newChildren != null)) {
      {
        throw Error( "An iterable object provided no iterator." );
      }
    }

    var resultingFirstChild = null;
    var previousNewFiber = null;
    var oldFiber = currentFirstChild;
    var lastPlacedIndex = 0;
    var newIdx = 0;
    var nextOldFiber = null;
    var step = newChildren.next();

    for (; oldFiber !== null && !step.done; newIdx++, step = newChildren.next()) {
      if (oldFiber.index > newIdx) {
        nextOldFiber = oldFiber;
        oldFiber = null;
      } else {
        nextOldFiber = oldFiber.sibling;
      }

      var newFiber = updateSlot(returnFiber, oldFiber, step.value, lanes);

      if (newFiber === null) {
        // TODO: This breaks on empty slots like null children. That's
        // unfortunate because it triggers the slow path all the time. We need
        // a better way to communicate whether this was a miss or null,
        // boolean, undefined, etc.
        if (oldFiber === null) {
          oldFiber = nextOldFiber;
        }

        break;
      }

      if (shouldTrackSideEffects) {
        if (oldFiber && newFiber.alternate === null) {
          // We matched the slot, but we didn't reuse the existing fiber, so we
          // need to delete the existing child.
          deleteChild(returnFiber, oldFiber);
        }
      }

      lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);

      if (previousNewFiber === null) {
        // TODO: Move out of the loop. This only happens for the first run.
        resultingFirstChild = newFiber;
      } else {
        // TODO: Defer siblings if we're not at the right index for this slot.
        // I.e. if we had null values before, then we want to defer this
        // for each null value. However, we also don't want to call updateSlot
        // with the previous one.
        previousNewFiber.sibling = newFiber;
      }

      previousNewFiber = newFiber;
      oldFiber = nextOldFiber;
    }

    if (step.done) {
      // We've reached the end of the new children. We can delete the rest.
      deleteRemainingChildren(returnFiber, oldFiber);
      return resultingFirstChild;
    }

    if (oldFiber === null) {
      // If we don't have any more existing children we can choose a fast path
      // since the rest will all be insertions.
      for (; !step.done; newIdx++, step = newChildren.next()) {
        var _newFiber3 = createChild(returnFiber, step.value, lanes);

        if (_newFiber3 === null) {
          continue;
        }

        lastPlacedIndex = placeChild(_newFiber3, lastPlacedIndex, newIdx);

        if (previousNewFiber === null) {
          // TODO: Move out of the loop. This only happens for the first run.
          resultingFirstChild = _newFiber3;
        } else {
          previousNewFiber.sibling = _newFiber3;
        }

        previousNewFiber = _newFiber3;
      }

      return resultingFirstChild;
    } // Add all children to a key map for quick lookups.


    var existingChildren = mapRemainingChildren(returnFiber, oldFiber); // Keep scanning and use the map to restore deleted items as moves.

    for (; !step.done; newIdx++, step = newChildren.next()) {
      var _newFiber4 = updateFromMap(existingChildren, returnFiber, newIdx, step.value, lanes);

      if (_newFiber4 !== null) {
        if (shouldTrackSideEffects) {
          if (_newFiber4.alternate !== null) {
            // The new fiber is a work in progress, but if there exists a
            // current, that means that we reused the fiber. We need to delete
            // it from the child list so that we don't add it to the deletion
            // list.
            existingChildren.delete(_newFiber4.key === null ? newIdx : _newFiber4.key);
          }
        }

        lastPlacedIndex = placeChild(_newFiber4, lastPlacedIndex, newIdx);

        if (previousNewFiber === null) {
          resultingFirstChild = _newFiber4;
        } else {
          previousNewFiber.sibling = _newFiber4;
        }

        previousNewFiber = _newFiber4;
      }
    }

    if (shouldTrackSideEffects) {
      // Any existing children that weren't consumed above were deleted. We need
      // to add them to the deletion list.
      existingChildren.forEach(function (child) {
        return deleteChild(returnFiber, child);
      });
    }

    return resultingFirstChild;
  }

  function reconcileSingleTextNode(returnFiber, currentFirstChild, textContent, lanes) {
    // There's no need to check for keys on text nodes since we don't have a
    // way to define them.
    if (currentFirstChild !== null && currentFirstChild.tag === HostText) {
      // We already have an existing node so let's just update it and delete
      // the rest.
      deleteRemainingChildren(returnFiber, currentFirstChild.sibling);
      var existing = useFiber(currentFirstChild, textContent);
      existing.return = returnFiber;
      return existing;
    } // The existing first child is not a text node so we need to create one
    // and delete the existing ones.


    deleteRemainingChildren(returnFiber, currentFirstChild);
    var created = createFiberFromText(textContent, returnFiber.mode, lanes);
    created.return = returnFiber;
    return created;
  }

  function reconcileSingleElement(returnFiber, currentFirstChild, element, lanes) {
    var key = element.key;
    var child = currentFirstChild;

    while (child !== null) {
      // TODO: If key === null and child.key === null, then this only applies to
      // the first item in the list.
      if (child.key === key) {
        switch (child.tag) {
          case Fragment:
            {
              if (element.type === REACT_FRAGMENT_TYPE) {
                deleteRemainingChildren(returnFiber, child.sibling);
                var existing = useFiber(child, element.props.children);
                existing.return = returnFiber;

                {
                  existing._debugSource = element._source;
                  existing._debugOwner = element._owner;
                }

                return existing;
              }

              break;
            }

          case Block:

          // We intentionally fallthrough here if enableBlocksAPI is not on.
          // eslint-disable-next-lined no-fallthrough

          default:
            {
              if (child.elementType === element.type || ( // Keep this check inline so it only runs on the false path:
               isCompatibleFamilyForHotReloading(child, element) )) {
                deleteRemainingChildren(returnFiber, child.sibling);

                var _existing3 = useFiber(child, element.props);

                _existing3.ref = coerceRef(returnFiber, child, element);
                _existing3.return = returnFiber;

                {
                  _existing3._debugSource = element._source;
                  _existing3._debugOwner = element._owner;
                }

                return _existing3;
              }

              break;
            }
        } // Didn't match.


        deleteRemainingChildren(returnFiber, child);
        break;
      } else {
        deleteChild(returnFiber, child);
      }

      child = child.sibling;
    }

    if (element.type === REACT_FRAGMENT_TYPE) {
      var created = createFiberFromFragment(element.props.children, returnFiber.mode, lanes, element.key);
      created.return = returnFiber;
      return created;
    } else {
      var _created4 = createFiberFromElement(element, returnFiber.mode, lanes);

      _created4.ref = coerceRef(returnFiber, currentFirstChild, element);
      _created4.return = returnFiber;
      return _created4;
    }
  }

  function reconcileSinglePortal(returnFiber, currentFirstChild, portal, lanes) {
    var key = portal.key;
    var child = currentFirstChild;

    while (child !== null) {
      // TODO: If key === null and child.key === null, then this only applies to
      // the first item in the list.
      if (child.key === key) {
        if (child.tag === HostPortal && child.stateNode.containerInfo === portal.containerInfo && child.stateNode.implementation === portal.implementation) {
          deleteRemainingChildren(returnFiber, child.sibling);
          var existing = useFiber(child, portal.children || []);
          existing.return = returnFiber;
          return existing;
        } else {
          deleteRemainingChildren(returnFiber, child);
          break;
        }
      } else {
        deleteChild(returnFiber, child);
      }

      child = child.sibling;
    }

    var created = createFiberFromPortal(portal, returnFiber.mode, lanes);
    created.return = returnFiber;
    return created;
  } // This API will tag the children with the side-effect of the reconciliation
  // itself. They will be added to the side-effect list as we pass through the
  // children and the parent.


  function reconcileChildFibers(returnFiber, currentFirstChild, newChild, lanes) {
    // This function is not recursive.
    // If the top level item is an array, we treat it as a set of children,
    // not as a fragment. Nested arrays on the other hand will be treated as
    // fragment nodes. Recursion happens at the normal flow.
    // Handle top level unkeyed fragments as if they were arrays.
    // This leads to an ambiguity between <>{[...]}</> and <>...</>.
    // We treat the ambiguous cases above the same.
    var isUnkeyedTopLevelFragment = typeof newChild === 'object' && newChild !== null && newChild.type === REACT_FRAGMENT_TYPE && newChild.key === null;

    if (isUnkeyedTopLevelFragment) {
      newChild = newChild.props.children;
    } // Handle object types


    var isObject = typeof newChild === 'object' && newChild !== null;

    if (isObject) {
      switch (newChild.$$typeof) {
        case REACT_ELEMENT_TYPE:
          return placeSingleChild(reconcileSingleElement(returnFiber, currentFirstChild, newChild, lanes));

        case REACT_PORTAL_TYPE:
          return placeSingleChild(reconcileSinglePortal(returnFiber, currentFirstChild, newChild, lanes));

      }
    }

    if (typeof newChild === 'string' || typeof newChild === 'number') {
      return placeSingleChild(reconcileSingleTextNode(returnFiber, currentFirstChild, '' + newChild, lanes));
    }

    if (isArray$1(newChild)) {
      return reconcileChildrenArray(returnFiber, currentFirstChild, newChild, lanes);
    }

    if (getIteratorFn(newChild)) {
      return reconcileChildrenIterator(returnFiber, currentFirstChild, newChild, lanes);
    }

    if (isObject) {
      throwOnInvalidObjectType(returnFiber, newChild);
    }

    {
      if (typeof newChild === 'function') {
        warnOnFunctionType(returnFiber);
      }
    }

    if (typeof newChild === 'undefined' && !isUnkeyedTopLevelFragment) {
      // If the new child is undefined, and the return fiber is a composite
      // component, throw an error. If Fiber return types are disabled,
      // we already threw above.
      switch (returnFiber.tag) {
        case ClassComponent:
          {
            {
              var instance = returnFiber.stateNode;

              if (instance.render._isMockFunction) {
                // We allow auto-mocks to proceed as if they're returning null.
                break;
              }
            }
          }
        // Intentionally fall through to the next case, which handles both
        // functions and classes
        // eslint-disable-next-lined no-fallthrough

        case Block:
        case FunctionComponent:
        case ForwardRef:
        case SimpleMemoComponent:
          {
            {
              {
                throw Error( (getComponentName(returnFiber.type) || 'Component') + "(...): Nothing was returned from render. This usually means a return statement is missing. Or, to render nothing, return null." );
              }
            }
          }
      }
    } // Remaining cases are all treated as empty.


    return deleteRemainingChildren(returnFiber, currentFirstChild);
  }

  return reconcileChildFibers;
}

var reconcileChildFibers = ChildReconciler(true);
var mountChildFibers = ChildReconciler(false);
function cloneChildFibers(current, workInProgress) {
  if (!(current === null || workInProgress.child === current.child)) {
    {
      throw Error( "Resuming work not yet implemented." );
    }
  }

  if (workInProgress.child === null) {
    return;
  }

  var currentChild = workInProgress.child;
  var newChild = createWorkInProgress(currentChild, currentChild.pendingProps);
  workInProgress.child = newChild;
  newChild.return = workInProgress;

  while (currentChild.sibling !== null) {
    currentChild = currentChild.sibling;
    newChild = newChild.sibling = createWorkInProgress(currentChild, currentChild.pendingProps);
    newChild.return = workInProgress;
  }

  newChild.sibling = null;
} // Reset a workInProgress child set to prepare it for a second pass.

function resetChildFibers(workInProgress, lanes) {
  var child = workInProgress.child;

  while (child !== null) {
    resetWorkInProgress(child, lanes);
    child = child.sibling;
  }
}

var NO_CONTEXT = {};
var contextStackCursor$1 = createCursor(NO_CONTEXT);
var contextFiberStackCursor = createCursor(NO_CONTEXT);
var rootInstanceStackCursor = createCursor(NO_CONTEXT);

function requiredContext(c) {
  if (!(c !== NO_CONTEXT)) {
    {
      throw Error( "Expected host context to exist. This error is likely caused by a bug in React. Please file an issue." );
    }
  }

  return c;
}

function getRootHostContainer() {
  var rootInstance = requiredContext(rootInstanceStackCursor.current);
  return rootInstance;
}

function pushHostContainer(fiber, nextRootInstance) {
  // Push current root instance onto the stack;
  // This allows us to reset root when portals are popped.
  push(rootInstanceStackCursor, nextRootInstance, fiber); // Track the context and the Fiber that provided it.
  // This enables us to pop only Fibers that provide unique contexts.

  push(contextFiberStackCursor, fiber, fiber); // Finally, we need to push the host context to the stack.
  // However, we can't just call getRootHostContext() and push it because
  // we'd have a different number of entries on the stack depending on
  // whether getRootHostContext() throws somewhere in renderer code or not.
  // So we push an empty value first. This lets us safely unwind on errors.

  push(contextStackCursor$1, NO_CONTEXT, fiber);
  var nextRootContext = getRootHostContext(nextRootInstance); // Now that we know this function doesn't throw, replace it.

  pop(contextStackCursor$1, fiber);
  push(contextStackCursor$1, nextRootContext, fiber);
}

function popHostContainer(fiber) {
  pop(contextStackCursor$1, fiber);
  pop(contextFiberStackCursor, fiber);
  pop(rootInstanceStackCursor, fiber);
}

function getHostContext() {
  var context = requiredContext(contextStackCursor$1.current);
  return context;
}

function pushHostContext(fiber) {
  var rootInstance = requiredContext(rootInstanceStackCursor.current);
  var context = requiredContext(contextStackCursor$1.current);
  var nextContext = getChildHostContext(context, fiber.type); // Don't push this Fiber's context unless it's unique.

  if (context === nextContext) {
    return;
  } // Track the context and the Fiber that provided it.
  // This enables us to pop only Fibers that provide unique contexts.


  push(contextFiberStackCursor, fiber, fiber);
  push(contextStackCursor$1, nextContext, fiber);
}

function popHostContext(fiber) {
  // Do not pop unless this Fiber provided the current context.
  // pushHostContext() only pushes Fibers that provide unique contexts.
  if (contextFiberStackCursor.current !== fiber) {
    return;
  }

  pop(contextStackCursor$1, fiber);
  pop(contextFiberStackCursor, fiber);
}

var DefaultSuspenseContext = 0; // The Suspense Context is split into two parts. The lower bits is
// inherited deeply down the subtree. The upper bits only affect
// this immediate suspense boundary and gets reset each new
// boundary or suspense list.

var SubtreeSuspenseContextMask = 1; // Subtree Flags:
// InvisibleParentSuspenseContext indicates that one of our parent Suspense
// boundaries is not currently showing visible main content.
// Either because it is already showing a fallback or is not mounted at all.
// We can use this to determine if it is desirable to trigger a fallback at
// the parent. If not, then we might need to trigger undesirable boundaries
// and/or suspend the commit to avoid hiding the parent content.

var InvisibleParentSuspenseContext = 1; // Shallow Flags:
// ForceSuspenseFallback can be used by SuspenseList to force newly added
// items into their fallback state during one of the render passes.

var ForceSuspenseFallback = 2;
var suspenseStackCursor = createCursor(DefaultSuspenseContext);
function hasSuspenseContext(parentContext, flag) {
  return (parentContext & flag) !== 0;
}
function setDefaultShallowSuspenseContext(parentContext) {
  return parentContext & SubtreeSuspenseContextMask;
}
function setShallowSuspenseContext(parentContext, shallowContext) {
  return parentContext & SubtreeSuspenseContextMask | shallowContext;
}
function addSubtreeSuspenseContext(parentContext, subtreeContext) {
  return parentContext | subtreeContext;
}
function pushSuspenseContext(fiber, newContext) {
  push(suspenseStackCursor, newContext, fiber);
}
function popSuspenseContext(fiber) {
  pop(suspenseStackCursor, fiber);
}

function shouldCaptureSuspense(workInProgress, hasInvisibleParent) {
  // If it was the primary children that just suspended, capture and render the
  // fallback. Otherwise, don't capture and bubble to the next boundary.
  var nextState = workInProgress.memoizedState;

  if (nextState !== null) {
    if (nextState.dehydrated !== null) {
      // A dehydrated boundary always captures.
      return true;
    }

    return false;
  }

  var props = workInProgress.memoizedProps; // In order to capture, the Suspense component must have a fallback prop.

  if (props.fallback === undefined) {
    return false;
  } // Regular boundaries always capture.


  if (props.unstable_avoidThisFallback !== true) {
    return true;
  } // If it's a boundary we should avoid, then we prefer to bubble up to the
  // parent boundary if it is currently invisible.


  if (hasInvisibleParent) {
    return false;
  } // If the parent is not able to handle it, we must handle it.


  return true;
}
function findFirstSuspended(row) {
  var node = row;

  while (node !== null) {
    if (node.tag === SuspenseComponent) {
      var state = node.memoizedState;

      if (state !== null) {
        var dehydrated = state.dehydrated;

        if (dehydrated === null || isSuspenseInstancePending(dehydrated) || isSuspenseInstanceFallback(dehydrated)) {
          return node;
        }
      }
    } else if (node.tag === SuspenseListComponent && // revealOrder undefined can't be trusted because it don't
    // keep track of whether it suspended or not.
    node.memoizedProps.revealOrder !== undefined) {
      var didSuspend = (node.flags & DidCapture) !== NoFlags;

      if (didSuspend) {
        return node;
      }
    } else if (node.child !== null) {
      node.child.return = node;
      node = node.child;
      continue;
    }

    if (node === row) {
      return null;
    }

    while (node.sibling === null) {
      if (node.return === null || node.return === row) {
        return null;
      }

      node = node.return;
    }

    node.sibling.return = node.return;
    node = node.sibling;
  }

  return null;
}

var NoFlags$1 =
/*  */
0; // Represents whether effect should fire.

var HasEffect =
/* */
1; // Represents the phase in which the effect (not the clean-up) fires.

var Layout =
/*    */
2;
var Passive$1 =
/*   */
4;

// This may have been an insertion or a hydration.

var hydrationParentFiber = null;
var nextHydratableInstance = null;
var isHydrating = false;

function enterHydrationState(fiber) {

  var parentInstance = fiber.stateNode.containerInfo;
  nextHydratableInstance = getFirstHydratableChild(parentInstance);
  hydrationParentFiber = fiber;
  isHydrating = true;
  return true;
}

function deleteHydratableInstance(returnFiber, instance) {
  {
    switch (returnFiber.tag) {
      case HostRoot:
        didNotHydrateContainerInstance(returnFiber.stateNode.containerInfo, instance);
        break;

      case HostComponent:
        didNotHydrateInstance(returnFiber.type, returnFiber.memoizedProps, returnFiber.stateNode, instance);
        break;
    }
  }

  var childToDelete = createFiberFromHostInstanceForDeletion();
  childToDelete.stateNode = instance;
  childToDelete.return = returnFiber;
  childToDelete.flags = Deletion; // This might seem like it belongs on progressedFirstDeletion. However,
  // these children are not part of the reconciliation list of children.
  // Even if we abort and rereconcile the children, that will try to hydrate
  // again and the nodes are still in the host tree so these will be
  // recreated.

  if (returnFiber.lastEffect !== null) {
    returnFiber.lastEffect.nextEffect = childToDelete;
    returnFiber.lastEffect = childToDelete;
  } else {
    returnFiber.firstEffect = returnFiber.lastEffect = childToDelete;
  }
}

function insertNonHydratedInstance(returnFiber, fiber) {
  fiber.flags = fiber.flags & ~Hydrating | Placement;

  {
    switch (returnFiber.tag) {
      case HostRoot:
        {
          var parentContainer = returnFiber.stateNode.containerInfo;

          switch (fiber.tag) {
            case HostComponent:
              var type = fiber.type;
              var props = fiber.pendingProps;
              didNotFindHydratableContainerInstance(parentContainer, type);
              break;

            case HostText:
              var text = fiber.pendingProps;
              didNotFindHydratableContainerTextInstance(parentContainer, text);
              break;
          }

          break;
        }

      case HostComponent:
        {
          var parentType = returnFiber.type;
          var parentProps = returnFiber.memoizedProps;
          var parentInstance = returnFiber.stateNode;

          switch (fiber.tag) {
            case HostComponent:
              var _type = fiber.type;
              var _props = fiber.pendingProps;
              didNotFindHydratableInstance(parentType, parentProps, parentInstance, _type);
              break;

            case HostText:
              var _text = fiber.pendingProps;
              didNotFindHydratableTextInstance(parentType, parentProps, parentInstance, _text);
              break;

            case SuspenseComponent:
              didNotFindHydratableSuspenseInstance(parentType, parentProps);
              break;
          }

          break;
        }

      default:
        return;
    }
  }
}

function tryHydrate(fiber, nextInstance) {
  switch (fiber.tag) {
    case HostComponent:
      {
        var type = fiber.type;
        var props = fiber.pendingProps;
        var instance = canHydrateInstance(nextInstance, type);

        if (instance !== null) {
          fiber.stateNode = instance;
          return true;
        }

        return false;
      }

    case HostText:
      {
        var text = fiber.pendingProps;
        var textInstance = canHydrateTextInstance(nextInstance, text);

        if (textInstance !== null) {
          fiber.stateNode = textInstance;
          return true;
        }

        return false;
      }

    case SuspenseComponent:
      {

        return false;
      }

    default:
      return false;
  }
}

function tryToClaimNextHydratableInstance(fiber) {
  if (!isHydrating) {
    return;
  }

  var nextInstance = nextHydratableInstance;

  if (!nextInstance) {
    // Nothing to hydrate. Make it an insertion.
    insertNonHydratedInstance(hydrationParentFiber, fiber);
    isHydrating = false;
    hydrationParentFiber = fiber;
    return;
  }

  var firstAttemptedInstance = nextInstance;

  if (!tryHydrate(fiber, nextInstance)) {
    // If we can't hydrate this instance let's try the next one.
    // We use this as a heuristic. It's based on intuition and not data so it
    // might be flawed or unnecessary.
    nextInstance = getNextHydratableSibling(firstAttemptedInstance);

    if (!nextInstance || !tryHydrate(fiber, nextInstance)) {
      // Nothing to hydrate. Make it an insertion.
      insertNonHydratedInstance(hydrationParentFiber, fiber);
      isHydrating = false;
      hydrationParentFiber = fiber;
      return;
    } // We matched the next one, we'll now assume that the first one was
    // superfluous and we'll delete it. Since we can't eagerly delete it
    // we'll have to schedule a deletion. To do that, this node needs a dummy
    // fiber associated with it.


    deleteHydratableInstance(hydrationParentFiber, firstAttemptedInstance);
  }

  hydrationParentFiber = fiber;
  nextHydratableInstance = getFirstHydratableChild(nextInstance);
}

function prepareToHydrateHostInstance(fiber, rootContainerInstance, hostContext) {

  var instance = fiber.stateNode;
  var updatePayload = hydrateInstance(instance, fiber.type, fiber.memoizedProps, rootContainerInstance, hostContext, fiber); // TODO: Type this specific to this type of component.

  fiber.updateQueue = updatePayload; // If the update payload indicates that there is a change or if there
  // is a new ref we mark this as an update.

  if (updatePayload !== null) {
    return true;
  }

  return false;
}

function prepareToHydrateHostTextInstance(fiber) {

  var textInstance = fiber.stateNode;
  var textContent = fiber.memoizedProps;
  var shouldUpdate = hydrateTextInstance(textInstance, textContent, fiber);

  {
    if (shouldUpdate) {
      // We assume that prepareToHydrateHostTextInstance is called in a context where the
      // hydration parent is the parent host component of this host text.
      var returnFiber = hydrationParentFiber;

      if (returnFiber !== null) {
        switch (returnFiber.tag) {
          case HostRoot:
            {
              var parentContainer = returnFiber.stateNode.containerInfo;
              didNotMatchHydratedContainerTextInstance(parentContainer, textInstance, textContent);
              break;
            }

          case HostComponent:
            {
              var parentType = returnFiber.type;
              var parentProps = returnFiber.memoizedProps;
              var parentInstance = returnFiber.stateNode;
              didNotMatchHydratedTextInstance(parentType, parentProps, parentInstance, textInstance, textContent);
              break;
            }
        }
      }
    }
  }

  return shouldUpdate;
}

function skipPastDehydratedSuspenseInstance(fiber) {

  var suspenseState = fiber.memoizedState;
  var suspenseInstance = suspenseState !== null ? suspenseState.dehydrated : null;

  if (!suspenseInstance) {
    {
      throw Error( "Expected to have a hydrated suspense instance. This error is likely caused by a bug in React. Please file an issue." );
    }
  }

  return getNextHydratableInstanceAfterSuspenseInstance(suspenseInstance);
}

function popToNextHostParent(fiber) {
  var parent = fiber.return;

  while (parent !== null && parent.tag !== HostComponent && parent.tag !== HostRoot && parent.tag !== SuspenseComponent) {
    parent = parent.return;
  }

  hydrationParentFiber = parent;
}

function popHydrationState(fiber) {

  if (fiber !== hydrationParentFiber) {
    // We're deeper than the current hydration context, inside an inserted
    // tree.
    return false;
  }

  if (!isHydrating) {
    // If we're not currently hydrating but we're in a hydration context, then
    // we were an insertion and now need to pop up reenter hydration of our
    // siblings.
    popToNextHostParent(fiber);
    isHydrating = true;
    return false;
  }

  var type = fiber.type; // If we have any remaining hydratable nodes, we need to delete them now.
  // We only do this deeper than head and body since they tend to have random
  // other nodes in them. We also ignore components with pure text content in
  // side of them.
  // TODO: Better heuristic.

  if (fiber.tag !== HostComponent || type !== 'head' && type !== 'body' && !shouldSetTextContent(type, fiber.memoizedProps)) {
    var nextInstance = nextHydratableInstance;

    while (nextInstance) {
      deleteHydratableInstance(fiber, nextInstance);
      nextInstance = getNextHydratableSibling(nextInstance);
    }
  }

  popToNextHostParent(fiber);

  if (fiber.tag === SuspenseComponent) {
    nextHydratableInstance = skipPastDehydratedSuspenseInstance(fiber);
  } else {
    nextHydratableInstance = hydrationParentFiber ? getNextHydratableSibling(fiber.stateNode) : null;
  }

  return true;
}

function resetHydrationState() {

  hydrationParentFiber = null;
  nextHydratableInstance = null;
  isHydrating = false;
}

function getIsHydrating() {
  return isHydrating;
}

// and should be reset before starting a new render.
// This tracks which mutable sources need to be reset after a render.

var workInProgressSources = [];
var rendererSigil$1;

{
  // Used to detect multiple renderers using the same mutable source.
  rendererSigil$1 = {};
}

function markSourceAsDirty(mutableSource) {
  workInProgressSources.push(mutableSource);
}
function resetWorkInProgressVersions() {
  for (var i = 0; i < workInProgressSources.length; i++) {
    var mutableSource = workInProgressSources[i];

    {
      mutableSource._workInProgressVersionPrimary = null;
    }
  }

  workInProgressSources.length = 0;
}
function getWorkInProgressVersion(mutableSource) {
  {
    return mutableSource._workInProgressVersionPrimary;
  }
}
function setWorkInProgressVersion(mutableSource, version) {
  {
    mutableSource._workInProgressVersionPrimary = version;
  }

  workInProgressSources.push(mutableSource);
}
function warnAboutMultipleRenderersDEV(mutableSource) {
  {
    {
      if (mutableSource._currentPrimaryRenderer == null) {
        mutableSource._currentPrimaryRenderer = rendererSigil$1;
      } else if (mutableSource._currentPrimaryRenderer !== rendererSigil$1) {
        error('Detected multiple renderers concurrently rendering the ' + 'same mutable source. This is currently unsupported.');
      }
    }
  }
} // Eager reads the version of a mutable source and stores it on the root.

var ReactCurrentDispatcher$1 = ReactSharedInternals.ReactCurrentDispatcher,
    ReactCurrentBatchConfig$1 = ReactSharedInternals.ReactCurrentBatchConfig;
var didWarnAboutMismatchedHooksForComponent;
var didWarnAboutUseOpaqueIdentifier;

{
  didWarnAboutUseOpaqueIdentifier = {};
  didWarnAboutMismatchedHooksForComponent = new Set();
}

// These are set right before calling the component.
var renderLanes = NoLanes; // The work-in-progress fiber. I've named it differently to distinguish it from
// the work-in-progress hook.

var currentlyRenderingFiber$1 = null; // Hooks are stored as a linked list on the fiber's memoizedState field. The
// current hook list is the list that belongs to the current fiber. The
// work-in-progress hook list is a new list that will be added to the
// work-in-progress fiber.

var currentHook = null;
var workInProgressHook = null; // Whether an update was scheduled at any point during the render phase. This
// does not get reset if we do another render pass; only when we're completely
// finished evaluating this component. This is an optimization so we know
// whether we need to clear render phase updates after a throw.

var didScheduleRenderPhaseUpdate = false; // Where an update was scheduled only during the current render pass. This
// gets reset after each attempt.
// TODO: Maybe there's some way to consolidate this with
// `didScheduleRenderPhaseUpdate`. Or with `numberOfReRenders`.

var didScheduleRenderPhaseUpdateDuringThisPass = false;
var RE_RENDER_LIMIT = 25; // In DEV, this is the name of the currently executing primitive hook

var currentHookNameInDev = null; // In DEV, this list ensures that hooks are called in the same order between renders.
// The list stores the order of hooks used during the initial render (mount).
// Subsequent renders (updates) reference this list.

var hookTypesDev = null;
var hookTypesUpdateIndexDev = -1; // In DEV, this tracks whether currently rendering component needs to ignore
// the dependencies for Hooks that need them (e.g. useEffect or useMemo).
// When true, such Hooks will always be "remounted". Only used during hot reload.

var ignorePreviousDependencies = false;

function mountHookTypesDev() {
  {
    var hookName = currentHookNameInDev;

    if (hookTypesDev === null) {
      hookTypesDev = [hookName];
    } else {
      hookTypesDev.push(hookName);
    }
  }
}

function updateHookTypesDev() {
  {
    var hookName = currentHookNameInDev;

    if (hookTypesDev !== null) {
      hookTypesUpdateIndexDev++;

      if (hookTypesDev[hookTypesUpdateIndexDev] !== hookName) {
        warnOnHookMismatchInDev(hookName);
      }
    }
  }
}

function checkDepsAreArrayDev(deps) {
  {
    if (deps !== undefined && deps !== null && !Array.isArray(deps)) {
      // Verify deps, but only on mount to avoid extra checks.
      // It's unlikely their type would change as usually you define them inline.
      error('%s received a final argument that is not an array (instead, received `%s`). When ' + 'specified, the final argument must be an array.', currentHookNameInDev, typeof deps);
    }
  }
}

function warnOnHookMismatchInDev(currentHookName) {
  {
    var componentName = getComponentName(currentlyRenderingFiber$1.type);

    if (!didWarnAboutMismatchedHooksForComponent.has(componentName)) {
      didWarnAboutMismatchedHooksForComponent.add(componentName);

      if (hookTypesDev !== null) {
        var table = '';
        var secondColumnStart = 30;

        for (var i = 0; i <= hookTypesUpdateIndexDev; i++) {
          var oldHookName = hookTypesDev[i];
          var newHookName = i === hookTypesUpdateIndexDev ? currentHookName : oldHookName;
          var row = i + 1 + ". " + oldHookName; // Extra space so second column lines up
          // lol @ IE not supporting String#repeat

          while (row.length < secondColumnStart) {
            row += ' ';
          }

          row += newHookName + '\n';
          table += row;
        }

        error('React has detected a change in the order of Hooks called by %s. ' + 'This will lead to bugs and errors if not fixed. ' + 'For more information, read the Rules of Hooks: https://reactjs.org/link/rules-of-hooks\n\n' + '   Previous render            Next render\n' + '   ------------------------------------------------------\n' + '%s' + '   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n', componentName, table);
      }
    }
  }
}

function throwInvalidHookError() {
  {
    {
      throw Error( "Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem." );
    }
  }
}

function areHookInputsEqual(nextDeps, prevDeps) {
  {
    if (ignorePreviousDependencies) {
      // Only true when this component is being hot reloaded.
      return false;
    }
  }

  if (prevDeps === null) {
    {
      error('%s received a final argument during this render, but not during ' + 'the previous render. Even though the final argument is optional, ' + 'its type cannot change between renders.', currentHookNameInDev);
    }

    return false;
  }

  {
    // Don't bother comparing lengths in prod because these arrays should be
    // passed inline.
    if (nextDeps.length !== prevDeps.length) {
      error('The final argument passed to %s changed size between renders. The ' + 'order and size of this array must remain constant.\n\n' + 'Previous: %s\n' + 'Incoming: %s', currentHookNameInDev, "[" + prevDeps.join(', ') + "]", "[" + nextDeps.join(', ') + "]");
    }
  }

  for (var i = 0; i < prevDeps.length && i < nextDeps.length; i++) {
    if (objectIs(nextDeps[i], prevDeps[i])) {
      continue;
    }

    return false;
  }

  return true;
}

function renderWithHooks(current, workInProgress, Component, props, secondArg, nextRenderLanes) {
  renderLanes = nextRenderLanes;
  currentlyRenderingFiber$1 = workInProgress;

  {
    hookTypesDev = current !== null ? current._debugHookTypes : null;
    hookTypesUpdateIndexDev = -1; // Used for hot reloading:

    ignorePreviousDependencies = current !== null && current.type !== workInProgress.type;
  }

  workInProgress.memoizedState = null;
  workInProgress.updateQueue = null;
  workInProgress.lanes = NoLanes; // The following should have already been reset
  // currentHook = null;
  // workInProgressHook = null;
  // didScheduleRenderPhaseUpdate = false;
  // TODO Warn if no hooks are used at all during mount, then some are used during update.
  // Currently we will identify the update render as a mount because memoizedState === null.
  // This is tricky because it's valid for certain types of components (e.g. React.lazy)
  // Using memoizedState to differentiate between mount/update only works if at least one stateful hook is used.
  // Non-stateful hooks (e.g. context) don't get added to memoizedState,
  // so memoizedState would be null during updates and mounts.

  {
    if (current !== null && current.memoizedState !== null) {
      ReactCurrentDispatcher$1.current = HooksDispatcherOnUpdateInDEV;
    } else if (hookTypesDev !== null) {
      // This dispatcher handles an edge case where a component is updating,
      // but no stateful hooks have been used.
      // We want to match the production code behavior (which will use HooksDispatcherOnMount),
      // but with the extra DEV validation to ensure hooks ordering hasn't changed.
      // This dispatcher does that.
      ReactCurrentDispatcher$1.current = HooksDispatcherOnMountWithHookTypesInDEV;
    } else {
      ReactCurrentDispatcher$1.current = HooksDispatcherOnMountInDEV;
    }
  }

  var children = Component(props, secondArg); // Check if there was a render phase update

  if (didScheduleRenderPhaseUpdateDuringThisPass) {
    // Keep rendering in a loop for as long as render phase updates continue to
    // be scheduled. Use a counter to prevent infinite loops.
    var numberOfReRenders = 0;

    do {
      didScheduleRenderPhaseUpdateDuringThisPass = false;

      if (!(numberOfReRenders < RE_RENDER_LIMIT)) {
        {
          throw Error( "Too many re-renders. React limits the number of renders to prevent an infinite loop." );
        }
      }

      numberOfReRenders += 1;

      {
        // Even when hot reloading, allow dependencies to stabilize
        // after first render to prevent infinite render phase updates.
        ignorePreviousDependencies = false;
      } // Start over from the beginning of the list


      currentHook = null;
      workInProgressHook = null;
      workInProgress.updateQueue = null;

      {
        // Also validate hook order for cascading updates.
        hookTypesUpdateIndexDev = -1;
      }

      ReactCurrentDispatcher$1.current =  HooksDispatcherOnRerenderInDEV ;
      children = Component(props, secondArg);
    } while (didScheduleRenderPhaseUpdateDuringThisPass);
  } // We can assume the previous dispatcher is always this one, since we set it
  // at the beginning of the render phase and there's no re-entrancy.


  ReactCurrentDispatcher$1.current = ContextOnlyDispatcher;

  {
    workInProgress._debugHookTypes = hookTypesDev;
  } // This check uses currentHook so that it works the same in DEV and prod bundles.
  // hookTypesDev could catch more cases (e.g. context) but only in DEV bundles.


  var didRenderTooFewHooks = currentHook !== null && currentHook.next !== null;
  renderLanes = NoLanes;
  currentlyRenderingFiber$1 = null;
  currentHook = null;
  workInProgressHook = null;

  {
    currentHookNameInDev = null;
    hookTypesDev = null;
    hookTypesUpdateIndexDev = -1;
  }

  didScheduleRenderPhaseUpdate = false;

  if (!!didRenderTooFewHooks) {
    {
      throw Error( "Rendered fewer hooks than expected. This may be caused by an accidental early return statement." );
    }
  }

  return children;
}
function bailoutHooks(current, workInProgress, lanes) {
  workInProgress.updateQueue = current.updateQueue;
  workInProgress.flags &= ~(Passive | Update);
  current.lanes = removeLanes(current.lanes, lanes);
}
function resetHooksAfterThrow() {
  // We can assume the previous dispatcher is always this one, since we set it
  // at the beginning of the render phase and there's no re-entrancy.
  ReactCurrentDispatcher$1.current = ContextOnlyDispatcher;

  if (didScheduleRenderPhaseUpdate) {
    // There were render phase updates. These are only valid for this render
    // phase, which we are now aborting. Remove the updates from the queues so
    // they do not persist to the next render. Do not remove updates from hooks
    // that weren't processed.
    //
    // Only reset the updates from the queue if it has a clone. If it does
    // not have a clone, that means it wasn't processed, and the updates were
    // scheduled before we entered the render phase.
    var hook = currentlyRenderingFiber$1.memoizedState;

    while (hook !== null) {
      var queue = hook.queue;

      if (queue !== null) {
        queue.pending = null;
      }

      hook = hook.next;
    }

    didScheduleRenderPhaseUpdate = false;
  }

  renderLanes = NoLanes;
  currentlyRenderingFiber$1 = null;
  currentHook = null;
  workInProgressHook = null;

  {
    hookTypesDev = null;
    hookTypesUpdateIndexDev = -1;
    currentHookNameInDev = null;
    isUpdatingOpaqueValueInRenderPhase = false;
  }

  didScheduleRenderPhaseUpdateDuringThisPass = false;
}

function mountWorkInProgressHook() {
  var hook = {
    memoizedState: null,
    baseState: null,
    baseQueue: null,
    queue: null,
    next: null
  };

  if (workInProgressHook === null) {
    // This is the first hook in the list
    currentlyRenderingFiber$1.memoizedState = workInProgressHook = hook;
  } else {
    // Append to the end of the list
    workInProgressHook = workInProgressHook.next = hook;
  }

  return workInProgressHook;
}

function updateWorkInProgressHook() {
  // This function is used both for updates and for re-renders triggered by a
  // render phase update. It assumes there is either a current hook we can
  // clone, or a work-in-progress hook from a previous render pass that we can
  // use as a base. When we reach the end of the base list, we must switch to
  // the dispatcher used for mounts.
  var nextCurrentHook;

  if (currentHook === null) {
    var current = currentlyRenderingFiber$1.alternate;

    if (current !== null) {
      nextCurrentHook = current.memoizedState;
    } else {
      nextCurrentHook = null;
    }
  } else {
    nextCurrentHook = currentHook.next;
  }

  var nextWorkInProgressHook;

  if (workInProgressHook === null) {
    nextWorkInProgressHook = currentlyRenderingFiber$1.memoizedState;
  } else {
    nextWorkInProgressHook = workInProgressHook.next;
  }

  if (nextWorkInProgressHook !== null) {
    // There's already a work-in-progress. Reuse it.
    workInProgressHook = nextWorkInProgressHook;
    nextWorkInProgressHook = workInProgressHook.next;
    currentHook = nextCurrentHook;
  } else {
    // Clone from the current hook.
    if (!(nextCurrentHook !== null)) {
      {
        throw Error( "Rendered more hooks than during the previous render." );
      }
    }

    currentHook = nextCurrentHook;
    var newHook = {
      memoizedState: currentHook.memoizedState,
      baseState: currentHook.baseState,
      baseQueue: currentHook.baseQueue,
      queue: currentHook.queue,
      next: null
    };

    if (workInProgressHook === null) {
      // This is the first hook in the list.
      currentlyRenderingFiber$1.memoizedState = workInProgressHook = newHook;
    } else {
      // Append to the end of the list.
      workInProgressHook = workInProgressHook.next = newHook;
    }
  }

  return workInProgressHook;
}

function createFunctionComponentUpdateQueue() {
  return {
    lastEffect: null
  };
}

function basicStateReducer(state, action) {
  // $FlowFixMe: Flow doesn't like mixed types
  return typeof action === 'function' ? action(state) : action;
}

function mountReducer(reducer, initialArg, init) {
  var hook = mountWorkInProgressHook();
  var initialState;

  if (init !== undefined) {
    initialState = init(initialArg);
  } else {
    initialState = initialArg;
  }

  hook.memoizedState = hook.baseState = initialState;
  var queue = hook.queue = {
    pending: null,
    dispatch: null,
    lastRenderedReducer: reducer,
    lastRenderedState: initialState
  };
  var dispatch = queue.dispatch = dispatchAction.bind(null, currentlyRenderingFiber$1, queue);
  return [hook.memoizedState, dispatch];
}

function updateReducer(reducer, initialArg, init) {
  var hook = updateWorkInProgressHook();
  var queue = hook.queue;

  if (!(queue !== null)) {
    {
      throw Error( "Should have a queue. This is likely a bug in React. Please file an issue." );
    }
  }

  queue.lastRenderedReducer = reducer;
  var current = currentHook; // The last rebase update that is NOT part of the base state.

  var baseQueue = current.baseQueue; // The last pending update that hasn't been processed yet.

  var pendingQueue = queue.pending;

  if (pendingQueue !== null) {
    // We have new updates that haven't been processed yet.
    // We'll add them to the base queue.
    if (baseQueue !== null) {
      // Merge the pending queue and the base queue.
      var baseFirst = baseQueue.next;
      var pendingFirst = pendingQueue.next;
      baseQueue.next = pendingFirst;
      pendingQueue.next = baseFirst;
    }

    {
      if (current.baseQueue !== baseQueue) {
        // Internal invariant that should never happen, but feasibly could in
        // the future if we implement resuming, or some form of that.
        error('Internal error: Expected work-in-progress queue to be a clone. ' + 'This is a bug in React.');
      }
    }

    current.baseQueue = baseQueue = pendingQueue;
    queue.pending = null;
  }

  if (baseQueue !== null) {
    // We have a queue to process.
    var first = baseQueue.next;
    var newState = current.baseState;
    var newBaseState = null;
    var newBaseQueueFirst = null;
    var newBaseQueueLast = null;
    var update = first;

    do {
      var updateLane = update.lane;

      if (!isSubsetOfLanes(renderLanes, updateLane)) {
        // Priority is insufficient. Skip this update. If this is the first
        // skipped update, the previous update/state is the new base
        // update/state.
        var clone = {
          lane: updateLane,
          action: update.action,
          eagerReducer: update.eagerReducer,
          eagerState: update.eagerState,
          next: null
        };

        if (newBaseQueueLast === null) {
          newBaseQueueFirst = newBaseQueueLast = clone;
          newBaseState = newState;
        } else {
          newBaseQueueLast = newBaseQueueLast.next = clone;
        } // Update the remaining priority in the queue.
        // TODO: Don't need to accumulate this. Instead, we can remove
        // renderLanes from the original lanes.


        currentlyRenderingFiber$1.lanes = mergeLanes(currentlyRenderingFiber$1.lanes, updateLane);
        markSkippedUpdateLanes(updateLane);
      } else {
        // This update does have sufficient priority.
        if (newBaseQueueLast !== null) {
          var _clone = {
            // This update is going to be committed so we never want uncommit
            // it. Using NoLane works because 0 is a subset of all bitmasks, so
            // this will never be skipped by the check above.
            lane: NoLane,
            action: update.action,
            eagerReducer: update.eagerReducer,
            eagerState: update.eagerState,
            next: null
          };
          newBaseQueueLast = newBaseQueueLast.next = _clone;
        } // Process this update.


        if (update.eagerReducer === reducer) {
          // If this update was processed eagerly, and its reducer matches the
          // current reducer, we can use the eagerly computed state.
          newState = update.eagerState;
        } else {
          var action = update.action;
          newState = reducer(newState, action);
        }
      }

      update = update.next;
    } while (update !== null && update !== first);

    if (newBaseQueueLast === null) {
      newBaseState = newState;
    } else {
      newBaseQueueLast.next = newBaseQueueFirst;
    } // Mark that the fiber performed work, but only if the new state is
    // different from the current state.


    if (!objectIs(newState, hook.memoizedState)) {
      markWorkInProgressReceivedUpdate();
    }

    hook.memoizedState = newState;
    hook.baseState = newBaseState;
    hook.baseQueue = newBaseQueueLast;
    queue.lastRenderedState = newState;
  }

  var dispatch = queue.dispatch;
  return [hook.memoizedState, dispatch];
}

function rerenderReducer(reducer, initialArg, init) {
  var hook = updateWorkInProgressHook();
  var queue = hook.queue;

  if (!(queue !== null)) {
    {
      throw Error( "Should have a queue. This is likely a bug in React. Please file an issue." );
    }
  }

  queue.lastRenderedReducer = reducer; // This is a re-render. Apply the new render phase updates to the previous
  // work-in-progress hook.

  var dispatch = queue.dispatch;
  var lastRenderPhaseUpdate = queue.pending;
  var newState = hook.memoizedState;

  if (lastRenderPhaseUpdate !== null) {
    // The queue doesn't persist past this render pass.
    queue.pending = null;
    var firstRenderPhaseUpdate = lastRenderPhaseUpdate.next;
    var update = firstRenderPhaseUpdate;

    do {
      // Process this render phase update. We don't have to check the
      // priority because it will always be the same as the current
      // render's.
      var action = update.action;
      newState = reducer(newState, action);
      update = update.next;
    } while (update !== firstRenderPhaseUpdate); // Mark that the fiber performed work, but only if the new state is
    // different from the current state.


    if (!objectIs(newState, hook.memoizedState)) {
      markWorkInProgressReceivedUpdate();
    }

    hook.memoizedState = newState; // Don't persist the state accumulated from the render phase updates to
    // the base state unless the queue is empty.
    // TODO: Not sure if this is the desired semantics, but it's what we
    // do for gDSFP. I can't remember why.

    if (hook.baseQueue === null) {
      hook.baseState = newState;
    }

    queue.lastRenderedState = newState;
  }

  return [newState, dispatch];
}

function readFromUnsubcribedMutableSource(root, source, getSnapshot) {
  {
    warnAboutMultipleRenderersDEV(source);
  }

  var getVersion = source._getVersion;
  var version = getVersion(source._source); // Is it safe for this component to read from this source during the current render?

  var isSafeToReadFromSource = false; // Check the version first.
  // If this render has already been started with a specific version,
  // we can use it alone to determine if we can safely read from the source.

  var currentRenderVersion = getWorkInProgressVersion(source);

  if (currentRenderVersion !== null) {
    // It's safe to read if the store hasn't been mutated since the last time
    // we read something.
    isSafeToReadFromSource = currentRenderVersion === version;
  } else {
    // If there's no version, then this is the first time we've read from the
    // source during the current render pass, so we need to do a bit more work.
    // What we need to determine is if there are any hooks that already
    // subscribed to the source, and if so, whether there are any pending
    // mutations that haven't been synchronized yet.
    //
    // If there are no pending mutations, then `root.mutableReadLanes` will be
    // empty, and we know we can safely read.
    //
    // If there *are* pending mutations, we may still be able to safely read
    // if the currently rendering lanes are inclusive of the pending mutation
    // lanes, since that guarantees that the value we're about to read from
    // the source is consistent with the values that we read during the most
    // recent mutation.
    isSafeToReadFromSource = isSubsetOfLanes(renderLanes, root.mutableReadLanes);

    if (isSafeToReadFromSource) {
      // If it's safe to read from this source during the current render,
      // store the version in case other components read from it.
      // A changed version number will let those components know to throw and restart the render.
      setWorkInProgressVersion(source, version);
    }
  }

  if (isSafeToReadFromSource) {
    var snapshot = getSnapshot(source._source);

    {
      if (typeof snapshot === 'function') {
        error('Mutable source should not return a function as the snapshot value. ' + 'Functions may close over mutable values and cause tearing.');
      }
    }

    return snapshot;
  } else {
    // This handles the special case of a mutable source being shared between renderers.
    // In that case, if the source is mutated between the first and second renderer,
    // The second renderer don't know that it needs to reset the WIP version during unwind,
    // (because the hook only marks sources as dirty if it's written to their WIP version).
    // That would cause this tear check to throw again and eventually be visible to the user.
    // We can avoid this infinite loop by explicitly marking the source as dirty.
    //
    // This can lead to tearing in the first renderer when it resumes,
    // but there's nothing we can do about that (short of throwing here and refusing to continue the render).
    markSourceAsDirty(source);

    {
      {
        throw Error( "Cannot read from mutable source during the current render without tearing. This is a bug in React. Please file an issue." );
      }
    }
  }
}

function useMutableSource(hook, source, getSnapshot, subscribe) {
  var root = getWorkInProgressRoot();

  if (!(root !== null)) {
    {
      throw Error( "Expected a work-in-progress root. This is a bug in React. Please file an issue." );
    }
  }

  var getVersion = source._getVersion;
  var version = getVersion(source._source);
  var dispatcher = ReactCurrentDispatcher$1.current; // eslint-disable-next-line prefer-const

  var _dispatcher$useState = dispatcher.useState(function () {
    return readFromUnsubcribedMutableSource(root, source, getSnapshot);
  }),
      currentSnapshot = _dispatcher$useState[0],
      setSnapshot = _dispatcher$useState[1];

  var snapshot = currentSnapshot; // Grab a handle to the state hook as well.
  // We use it to clear the pending update queue if we have a new source.

  var stateHook = workInProgressHook;
  var memoizedState = hook.memoizedState;
  var refs = memoizedState.refs;
  var prevGetSnapshot = refs.getSnapshot;
  var prevSource = memoizedState.source;
  var prevSubscribe = memoizedState.subscribe;
  var fiber = currentlyRenderingFiber$1;
  hook.memoizedState = {
    refs: refs,
    source: source,
    subscribe: subscribe
  }; // Sync the values needed by our subscription handler after each commit.

  dispatcher.useEffect(function () {
    refs.getSnapshot = getSnapshot; // Normally the dispatch function for a state hook never changes,
    // but this hook recreates the queue in certain cases  to avoid updates from stale sources.
    // handleChange() below needs to reference the dispatch function without re-subscribing,
    // so we use a ref to ensure that it always has the latest version.

    refs.setSnapshot = setSnapshot; // Check for a possible change between when we last rendered now.

    var maybeNewVersion = getVersion(source._source);

    if (!objectIs(version, maybeNewVersion)) {
      var maybeNewSnapshot = getSnapshot(source._source);

      {
        if (typeof maybeNewSnapshot === 'function') {
          error('Mutable source should not return a function as the snapshot value. ' + 'Functions may close over mutable values and cause tearing.');
        }
      }

      if (!objectIs(snapshot, maybeNewSnapshot)) {
        setSnapshot(maybeNewSnapshot);
        var lane = requestUpdateLane(fiber);
        markRootMutableRead(root, lane);
      } // If the source mutated between render and now,
      // there may be state updates already scheduled from the old source.
      // Entangle the updates so that they render in the same batch.


      markRootEntangled(root, root.mutableReadLanes);
    }
  }, [getSnapshot, source, subscribe]); // If we got a new source or subscribe function, re-subscribe in a passive effect.

  dispatcher.useEffect(function () {
    var handleChange = function () {
      var latestGetSnapshot = refs.getSnapshot;
      var latestSetSnapshot = refs.setSnapshot;

      try {
        latestSetSnapshot(latestGetSnapshot(source._source)); // Record a pending mutable source update with the same expiration time.

        var lane = requestUpdateLane(fiber);
        markRootMutableRead(root, lane);
      } catch (error) {
        // A selector might throw after a source mutation.
        // e.g. it might try to read from a part of the store that no longer exists.
        // In this case we should still schedule an update with React.
        // Worst case the selector will throw again and then an error boundary will handle it.
        latestSetSnapshot(function () {
          throw error;
        });
      }
    };

    var unsubscribe = subscribe(source._source, handleChange);

    {
      if (typeof unsubscribe !== 'function') {
        error('Mutable source subscribe function must return an unsubscribe function.');
      }
    }

    return unsubscribe;
  }, [source, subscribe]); // If any of the inputs to useMutableSource change, reading is potentially unsafe.
  //
  // If either the source or the subscription have changed we can't can't trust the update queue.
  // Maybe the source changed in a way that the old subscription ignored but the new one depends on.
  //
  // If the getSnapshot function changed, we also shouldn't rely on the update queue.
  // It's possible that the underlying source was mutated between the when the last "change" event fired,
  // and when the current render (with the new getSnapshot function) is processed.
  //
  // In both cases, we need to throw away pending updates (since they are no longer relevant)
  // and treat reading from the source as we do in the mount case.

  if (!objectIs(prevGetSnapshot, getSnapshot) || !objectIs(prevSource, source) || !objectIs(prevSubscribe, subscribe)) {
    // Create a new queue and setState method,
    // So if there are interleaved updates, they get pushed to the older queue.
    // When this becomes current, the previous queue and dispatch method will be discarded,
    // including any interleaving updates that occur.
    var newQueue = {
      pending: null,
      dispatch: null,
      lastRenderedReducer: basicStateReducer,
      lastRenderedState: snapshot
    };
    newQueue.dispatch = setSnapshot = dispatchAction.bind(null, currentlyRenderingFiber$1, newQueue);
    stateHook.queue = newQueue;
    stateHook.baseQueue = null;
    snapshot = readFromUnsubcribedMutableSource(root, source, getSnapshot);
    stateHook.memoizedState = stateHook.baseState = snapshot;
  }

  return snapshot;
}

function mountMutableSource(source, getSnapshot, subscribe) {
  var hook = mountWorkInProgressHook();
  hook.memoizedState = {
    refs: {
      getSnapshot: getSnapshot,
      setSnapshot: null
    },
    source: source,
    subscribe: subscribe
  };
  return useMutableSource(hook, source, getSnapshot, subscribe);
}

function updateMutableSource(source, getSnapshot, subscribe) {
  var hook = updateWorkInProgressHook();
  return useMutableSource(hook, source, getSnapshot, subscribe);
}

function mountState(initialState) {
  var hook = mountWorkInProgressHook();

  if (typeof initialState === 'function') {
    // $FlowFixMe: Flow doesn't like mixed types
    initialState = initialState();
  }

  hook.memoizedState = hook.baseState = initialState;
  var queue = hook.queue = {
    pending: null,
    dispatch: null,
    lastRenderedReducer: basicStateReducer,
    lastRenderedState: initialState
  };
  var dispatch = queue.dispatch = dispatchAction.bind(null, currentlyRenderingFiber$1, queue);
  return [hook.memoizedState, dispatch];
}

function updateState(initialState) {
  return updateReducer(basicStateReducer);
}

function rerenderState(initialState) {
  return rerenderReducer(basicStateReducer);
}

function pushEffect(tag, create, destroy, deps) {
  var effect = {
    tag: tag,
    create: create,
    destroy: destroy,
    deps: deps,
    // Circular
    next: null
  };
  var componentUpdateQueue = currentlyRenderingFiber$1.updateQueue;

  if (componentUpdateQueue === null) {
    componentUpdateQueue = createFunctionComponentUpdateQueue();
    currentlyRenderingFiber$1.updateQueue = componentUpdateQueue;
    componentUpdateQueue.lastEffect = effect.next = effect;
  } else {
    var lastEffect = componentUpdateQueue.lastEffect;

    if (lastEffect === null) {
      componentUpdateQueue.lastEffect = effect.next = effect;
    } else {
      var firstEffect = lastEffect.next;
      lastEffect.next = effect;
      effect.next = firstEffect;
      componentUpdateQueue.lastEffect = effect;
    }
  }

  return effect;
}

function mountRef(initialValue) {
  var hook = mountWorkInProgressHook();
  var ref = {
    current: initialValue
  };

  {
    Object.seal(ref);
  }

  hook.memoizedState = ref;
  return ref;
}

function updateRef(initialValue) {
  var hook = updateWorkInProgressHook();
  return hook.memoizedState;
}

function mountEffectImpl(fiberFlags, hookFlags, create, deps) {
  var hook = mountWorkInProgressHook();
  var nextDeps = deps === undefined ? null : deps;
  currentlyRenderingFiber$1.flags |= fiberFlags;
  hook.memoizedState = pushEffect(HasEffect | hookFlags, create, undefined, nextDeps);
}

function updateEffectImpl(fiberFlags, hookFlags, create, deps) {
  var hook = updateWorkInProgressHook();
  var nextDeps = deps === undefined ? null : deps;
  var destroy = undefined;

  if (currentHook !== null) {
    var prevEffect = currentHook.memoizedState;
    destroy = prevEffect.destroy;

    if (nextDeps !== null) {
      var prevDeps = prevEffect.deps;

      if (areHookInputsEqual(nextDeps, prevDeps)) {
        pushEffect(hookFlags, create, destroy, nextDeps);
        return;
      }
    }
  }

  currentlyRenderingFiber$1.flags |= fiberFlags;
  hook.memoizedState = pushEffect(HasEffect | hookFlags, create, destroy, nextDeps);
}

function mountEffect(create, deps) {
  {
    // $FlowExpectedError - jest isn't a global, and isn't recognized outside of tests
    if ('undefined' !== typeof jest) {
      warnIfNotCurrentlyActingEffectsInDEV(currentlyRenderingFiber$1);
    }
  }

  return mountEffectImpl(Update | Passive, Passive$1, create, deps);
}

function updateEffect(create, deps) {
  {
    // $FlowExpectedError - jest isn't a global, and isn't recognized outside of tests
    if ('undefined' !== typeof jest) {
      warnIfNotCurrentlyActingEffectsInDEV(currentlyRenderingFiber$1);
    }
  }

  return updateEffectImpl(Update | Passive, Passive$1, create, deps);
}

function mountLayoutEffect(create, deps) {
  return mountEffectImpl(Update, Layout, create, deps);
}

function updateLayoutEffect(create, deps) {
  return updateEffectImpl(Update, Layout, create, deps);
}

function imperativeHandleEffect(create, ref) {
  if (typeof ref === 'function') {
    var refCallback = ref;

    var _inst = create();

    refCallback(_inst);
    return function () {
      refCallback(null);
    };
  } else if (ref !== null && ref !== undefined) {
    var refObject = ref;

    {
      if (!refObject.hasOwnProperty('current')) {
        error('Expected useImperativeHandle() first argument to either be a ' + 'ref callback or React.createRef() object. Instead received: %s.', 'an object with keys {' + Object.keys(refObject).join(', ') + '}');
      }
    }

    var _inst2 = create();

    refObject.current = _inst2;
    return function () {
      refObject.current = null;
    };
  }
}

function mountImperativeHandle(ref, create, deps) {
  {
    if (typeof create !== 'function') {
      error('Expected useImperativeHandle() second argument to be a function ' + 'that creates a handle. Instead received: %s.', create !== null ? typeof create : 'null');
    }
  } // TODO: If deps are provided, should we skip comparing the ref itself?


  var effectDeps = deps !== null && deps !== undefined ? deps.concat([ref]) : null;
  return mountEffectImpl(Update, Layout, imperativeHandleEffect.bind(null, create, ref), effectDeps);
}

function updateImperativeHandle(ref, create, deps) {
  {
    if (typeof create !== 'function') {
      error('Expected useImperativeHandle() second argument to be a function ' + 'that creates a handle. Instead received: %s.', create !== null ? typeof create : 'null');
    }
  } // TODO: If deps are provided, should we skip comparing the ref itself?


  var effectDeps = deps !== null && deps !== undefined ? deps.concat([ref]) : null;
  return updateEffectImpl(Update, Layout, imperativeHandleEffect.bind(null, create, ref), effectDeps);
}

function mountDebugValue(value, formatterFn) {// This hook is normally a no-op.
  // The react-debug-hooks package injects its own implementation
  // so that e.g. DevTools can display custom hook values.
}

var updateDebugValue = mountDebugValue;

function mountCallback(callback, deps) {
  var hook = mountWorkInProgressHook();
  var nextDeps = deps === undefined ? null : deps;
  hook.memoizedState = [callback, nextDeps];
  return callback;
}

function updateCallback(callback, deps) {
  var hook = updateWorkInProgressHook();
  var nextDeps = deps === undefined ? null : deps;
  var prevState = hook.memoizedState;

  if (prevState !== null) {
    if (nextDeps !== null) {
      var prevDeps = prevState[1];

      if (areHookInputsEqual(nextDeps, prevDeps)) {
        return prevState[0];
      }
    }
  }

  hook.memoizedState = [callback, nextDeps];
  return callback;
}

function mountMemo(nextCreate, deps) {
  var hook = mountWorkInProgressHook();
  var nextDeps = deps === undefined ? null : deps;
  var nextValue = nextCreate();
  hook.memoizedState = [nextValue, nextDeps];
  return nextValue;
}

function updateMemo(nextCreate, deps) {
  var hook = updateWorkInProgressHook();
  var nextDeps = deps === undefined ? null : deps;
  var prevState = hook.memoizedState;

  if (prevState !== null) {
    // Assume these are defined. If they're not, areHookInputsEqual will warn.
    if (nextDeps !== null) {
      var prevDeps = prevState[1];

      if (areHookInputsEqual(nextDeps, prevDeps)) {
        return prevState[0];
      }
    }
  }

  var nextValue = nextCreate();
  hook.memoizedState = [nextValue, nextDeps];
  return nextValue;
}

function mountDeferredValue(value) {
  var _mountState = mountState(value),
      prevValue = _mountState[0],
      setValue = _mountState[1];

  mountEffect(function () {
    var prevTransition = ReactCurrentBatchConfig$1.transition;
    ReactCurrentBatchConfig$1.transition = 1;

    try {
      setValue(value);
    } finally {
      ReactCurrentBatchConfig$1.transition = prevTransition;
    }
  }, [value]);
  return prevValue;
}

function updateDeferredValue(value) {
  var _updateState = updateState(),
      prevValue = _updateState[0],
      setValue = _updateState[1];

  updateEffect(function () {
    var prevTransition = ReactCurrentBatchConfig$1.transition;
    ReactCurrentBatchConfig$1.transition = 1;

    try {
      setValue(value);
    } finally {
      ReactCurrentBatchConfig$1.transition = prevTransition;
    }
  }, [value]);
  return prevValue;
}

function rerenderDeferredValue(value) {
  var _rerenderState = rerenderState(),
      prevValue = _rerenderState[0],
      setValue = _rerenderState[1];

  updateEffect(function () {
    var prevTransition = ReactCurrentBatchConfig$1.transition;
    ReactCurrentBatchConfig$1.transition = 1;

    try {
      setValue(value);
    } finally {
      ReactCurrentBatchConfig$1.transition = prevTransition;
    }
  }, [value]);
  return prevValue;
}

function startTransition(setPending, callback) {
  var priorityLevel = getCurrentPriorityLevel();

  {
    runWithPriority$1(priorityLevel < UserBlockingPriority$2 ? UserBlockingPriority$2 : priorityLevel, function () {
      setPending(true);
    });
    runWithPriority$1(priorityLevel > NormalPriority$1 ? NormalPriority$1 : priorityLevel, function () {
      var prevTransition = ReactCurrentBatchConfig$1.transition;
      ReactCurrentBatchConfig$1.transition = 1;

      try {
        setPending(false);
        callback();
      } finally {
        ReactCurrentBatchConfig$1.transition = prevTransition;
      }
    });
  }
}

function mountTransition() {
  var _mountState2 = mountState(false),
      isPending = _mountState2[0],
      setPending = _mountState2[1]; // The `start` method can be stored on a ref, since `setPending`
  // never changes.


  var start = startTransition.bind(null, setPending);
  mountRef(start);
  return [start, isPending];
}

function updateTransition() {
  var _updateState2 = updateState(),
      isPending = _updateState2[0];

  var startRef = updateRef();
  var start = startRef.current;
  return [start, isPending];
}

function rerenderTransition() {
  var _rerenderState2 = rerenderState(),
      isPending = _rerenderState2[0];

  var startRef = updateRef();
  var start = startRef.current;
  return [start, isPending];
}

var isUpdatingOpaqueValueInRenderPhase = false;
function getIsUpdatingOpaqueValueInRenderPhaseInDEV() {
  {
    return isUpdatingOpaqueValueInRenderPhase;
  }
}

function warnOnOpaqueIdentifierAccessInDEV(fiber) {
  {
    // TODO: Should warn in effects and callbacks, too
    var name = getComponentName(fiber.type) || 'Unknown';

    if (getIsRendering() && !didWarnAboutUseOpaqueIdentifier[name]) {
      error('The object passed back from useOpaqueIdentifier is meant to be ' + 'passed through to attributes only. Do not read the ' + 'value directly.');

      didWarnAboutUseOpaqueIdentifier[name] = true;
    }
  }
}

function mountOpaqueIdentifier() {
  var makeId =  makeClientIdInDEV.bind(null, warnOnOpaqueIdentifierAccessInDEV.bind(null, currentlyRenderingFiber$1)) ;

  if (getIsHydrating()) {
    var didUpgrade = false;
    var fiber = currentlyRenderingFiber$1;

    var readValue = function () {
      if (!didUpgrade) {
        // Only upgrade once. This works even inside the render phase because
        // the update is added to a shared queue, which outlasts the
        // in-progress render.
        didUpgrade = true;

        {
          isUpdatingOpaqueValueInRenderPhase = true;
          setId(makeId());
          isUpdatingOpaqueValueInRenderPhase = false;
          warnOnOpaqueIdentifierAccessInDEV(fiber);
        }
      }

      {
        {
          throw Error( "The object passed back from useOpaqueIdentifier is meant to be passed through to attributes only. Do not read the value directly." );
        }
      }
    };

    var id = makeOpaqueHydratingObject(readValue);
    var setId = mountState(id)[1];

    if ((currentlyRenderingFiber$1.mode & BlockingMode) === NoMode) {
      currentlyRenderingFiber$1.flags |= Update | Passive;
      pushEffect(HasEffect | Passive$1, function () {
        setId(makeId());
      }, undefined, null);
    }

    return id;
  } else {
    var _id = makeId();

    mountState(_id);
    return _id;
  }
}

function updateOpaqueIdentifier() {
  var id = updateState()[0];
  return id;
}

function rerenderOpaqueIdentifier() {
  var id = rerenderState()[0];
  return id;
}

function dispatchAction(fiber, queue, action) {
  {
    if (typeof arguments[3] === 'function') {
      error("State updates from the useState() and useReducer() Hooks don't support the " + 'second callback argument. To execute a side effect after ' + 'rendering, declare it in the component body with useEffect().');
    }
  }

  var eventTime = requestEventTime();
  var lane = requestUpdateLane(fiber);
  var update = {
    lane: lane,
    action: action,
    eagerReducer: null,
    eagerState: null,
    next: null
  }; // Append the update to the end of the list.

  var pending = queue.pending;

  if (pending === null) {
    // This is the first update. Create a circular list.
    update.next = update;
  } else {
    update.next = pending.next;
    pending.next = update;
  }

  queue.pending = update;
  var alternate = fiber.alternate;

  if (fiber === currentlyRenderingFiber$1 || alternate !== null && alternate === currentlyRenderingFiber$1) {
    // This is a render phase update. Stash it in a lazily-created map of
    // queue -> linked list of updates. After this render pass, we'll restart
    // and apply the stashed updates on top of the work-in-progress hook.
    didScheduleRenderPhaseUpdateDuringThisPass = didScheduleRenderPhaseUpdate = true;
  } else {
    if (fiber.lanes === NoLanes && (alternate === null || alternate.lanes === NoLanes)) {
      // The queue is currently empty, which means we can eagerly compute the
      // next state before entering the render phase. If the new state is the
      // same as the current state, we may be able to bail out entirely.
      var lastRenderedReducer = queue.lastRenderedReducer;

      if (lastRenderedReducer !== null) {
        var prevDispatcher;

        {
          prevDispatcher = ReactCurrentDispatcher$1.current;
          ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
        }

        try {
          var currentState = queue.lastRenderedState;
          var eagerState = lastRenderedReducer(currentState, action); // Stash the eagerly computed state, and the reducer used to compute
          // it, on the update object. If the reducer hasn't changed by the
          // time we enter the render phase, then the eager state can be used
          // without calling the reducer again.

          update.eagerReducer = lastRenderedReducer;
          update.eagerState = eagerState;

          if (objectIs(eagerState, currentState)) {
            // Fast path. We can bail out without scheduling React to re-render.
            // It's still possible that we'll need to rebase this update later,
            // if the component re-renders for a different reason and by that
            // time the reducer has changed.
            return;
          }
        } catch (error) {// Suppress the error. It will throw again in the render phase.
        } finally {
          {
            ReactCurrentDispatcher$1.current = prevDispatcher;
          }
        }
      }
    }

    {
      // $FlowExpectedError - jest isn't a global, and isn't recognized outside of tests
      if ('undefined' !== typeof jest) {
        warnIfNotScopedWithMatchingAct(fiber);
        warnIfNotCurrentlyActingUpdatesInDev(fiber);
      }
    }

    scheduleUpdateOnFiber(fiber, lane, eventTime);
  }
}

var ContextOnlyDispatcher = {
  readContext: readContext,
  useCallback: throwInvalidHookError,
  useContext: throwInvalidHookError,
  useEffect: throwInvalidHookError,
  useImperativeHandle: throwInvalidHookError,
  useLayoutEffect: throwInvalidHookError,
  useMemo: throwInvalidHookError,
  useReducer: throwInvalidHookError,
  useRef: throwInvalidHookError,
  useState: throwInvalidHookError,
  useDebugValue: throwInvalidHookError,
  useDeferredValue: throwInvalidHookError,
  useTransition: throwInvalidHookError,
  useMutableSource: throwInvalidHookError,
  useOpaqueIdentifier: throwInvalidHookError,
  unstable_isNewReconciler: enableNewReconciler
};
var HooksDispatcherOnMountInDEV = null;
var HooksDispatcherOnMountWithHookTypesInDEV = null;
var HooksDispatcherOnUpdateInDEV = null;
var HooksDispatcherOnRerenderInDEV = null;
var InvalidNestedHooksDispatcherOnMountInDEV = null;
var InvalidNestedHooksDispatcherOnUpdateInDEV = null;
var InvalidNestedHooksDispatcherOnRerenderInDEV = null;

{
  var warnInvalidContextAccess = function () {
    error('Context can only be read while React is rendering. ' + 'In classes, you can read it in the render method or getDerivedStateFromProps. ' + 'In function components, you can read it directly in the function body, but not ' + 'inside Hooks like useReducer() or useMemo().');
  };

  var warnInvalidHookAccess = function () {
    error('Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. ' + 'You can only call Hooks at the top level of your React function. ' + 'For more information, see ' + 'https://reactjs.org/link/rules-of-hooks');
  };

  HooksDispatcherOnMountInDEV = {
    readContext: function (context, observedBits) {
      return readContext(context, observedBits);
    },
    useCallback: function (callback, deps) {
      currentHookNameInDev = 'useCallback';
      mountHookTypesDev();
      checkDepsAreArrayDev(deps);
      return mountCallback(callback, deps);
    },
    useContext: function (context, observedBits) {
      currentHookNameInDev = 'useContext';
      mountHookTypesDev();
      return readContext(context, observedBits);
    },
    useEffect: function (create, deps) {
      currentHookNameInDev = 'useEffect';
      mountHookTypesDev();
      checkDepsAreArrayDev(deps);
      return mountEffect(create, deps);
    },
    useImperativeHandle: function (ref, create, deps) {
      currentHookNameInDev = 'useImperativeHandle';
      mountHookTypesDev();
      checkDepsAreArrayDev(deps);
      return mountImperativeHandle(ref, create, deps);
    },
    useLayoutEffect: function (create, deps) {
      currentHookNameInDev = 'useLayoutEffect';
      mountHookTypesDev();
      checkDepsAreArrayDev(deps);
      return mountLayoutEffect(create, deps);
    },
    useMemo: function (create, deps) {
      currentHookNameInDev = 'useMemo';
      mountHookTypesDev();
      checkDepsAreArrayDev(deps);
      var prevDispatcher = ReactCurrentDispatcher$1.current;
      ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;

      try {
        return mountMemo(create, deps);
      } finally {
        ReactCurrentDispatcher$1.current = prevDispatcher;
      }
    },
    useReducer: function (reducer, initialArg, init) {
      currentHookNameInDev = 'useReducer';
      mountHookTypesDev();
      var prevDispatcher = ReactCurrentDispatcher$1.current;
      ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;

      try {
        return mountReducer(reducer, initialArg, init);
      } finally {
        ReactCurrentDispatcher$1.current = prevDispatcher;
      }
    },
    useRef: function (initialValue) {
      currentHookNameInDev = 'useRef';
      mountHookTypesDev();
      return mountRef(initialValue);
    },
    useState: function (initialState) {
      currentHookNameInDev = 'useState';
      mountHookTypesDev();
      var prevDispatcher = ReactCurrentDispatcher$1.current;
      ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;

      try {
        return mountState(initialState);
      } finally {
        ReactCurrentDispatcher$1.current = prevDispatcher;
      }
    },
    useDebugValue: function (value, formatterFn) {
      currentHookNameInDev = 'useDebugValue';
      mountHookTypesDev();
      return mountDebugValue();
    },
    useDeferredValue: function (value) {
      currentHookNameInDev = 'useDeferredValue';
      mountHookTypesDev();
      return mountDeferredValue(value);
    },
    useTransition: function () {
      currentHookNameInDev = 'useTransition';
      mountHookTypesDev();
      return mountTransition();
    },
    useMutableSource: function (source, getSnapshot, subscribe) {
      currentHookNameInDev = 'useMutableSource';
      mountHookTypesDev();
      return mountMutableSource(source, getSnapshot, subscribe);
    },
    useOpaqueIdentifier: function () {
      currentHookNameInDev = 'useOpaqueIdentifier';
      mountHookTypesDev();
      return mountOpaqueIdentifier();
    },
    unstable_isNewReconciler: enableNewReconciler
  };
  HooksDispatcherOnMountWithHookTypesInDEV = {
    readContext: function (context, observedBits) {
      return readContext(context, observedBits);
    },
    useCallback: function (callback, deps) {
      currentHookNameInDev = 'useCallback';
      updateHookTypesDev();
      return mountCallback(callback, deps);
    },
    useContext: function (context, observedBits) {
      currentHookNameInDev = 'useContext';
      updateHookTypesDev();
      return readContext(context, observedBits);
    },
    useEffect: function (create, deps) {
      currentHookNameInDev = 'useEffect';
      updateHookTypesDev();
      return mountEffect(create, deps);
    },
    useImperativeHandle: function (ref, create, deps) {
      currentHookNameInDev = 'useImperativeHandle';
      updateHookTypesDev();
      return mountImperativeHandle(ref, create, deps);
    },
    useLayoutEffect: function (create, deps) {
      currentHookNameInDev = 'useLayoutEffect';
      updateHookTypesDev();
      return mountLayoutEffect(create, deps);
    },
    useMemo: function (create, deps) {
      currentHookNameInDev = 'useMemo';
      updateHookTypesDev();
      var prevDispatcher = ReactCurrentDispatcher$1.current;
      ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;

      try {
        return mountMemo(create, deps);
      } finally {
        ReactCurrentDispatcher$1.current = prevDispatcher;
      }
    },
    useReducer: function (reducer, initialArg, init) {
      currentHookNameInDev = 'useReducer';
      updateHookTypesDev();
      var prevDispatcher = ReactCurrentDispatcher$1.current;
      ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;

      try {
        return mountReducer(reducer, initialArg, init);
      } finally {
        ReactCurrentDispatcher$1.current = prevDispatcher;
      }
    },
    useRef: function (initialValue) {
      currentHookNameInDev = 'useRef';
      updateHookTypesDev();
      return mountRef(initialValue);
    },
    useState: function (initialState) {
      currentHookNameInDev = 'useState';
      updateHookTypesDev();
      var prevDispatcher = ReactCurrentDispatcher$1.current;
      ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;

      try {
        return mountState(initialState);
      } finally {
        ReactCurrentDispatcher$1.current = prevDispatcher;
      }
    },
    useDebugValue: function (value, formatterFn) {
      currentHookNameInDev = 'useDebugValue';
      updateHookTypesDev();
      return mountDebugValue();
    },
    useDeferredValue: function (value) {
      currentHookNameInDev = 'useDeferredValue';
      updateHookTypesDev();
      return mountDeferredValue(value);
    },
    useTransition: function () {
      currentHookNameInDev = 'useTransition';
      updateHookTypesDev();
      return mountTransition();
    },
    useMutableSource: function (source, getSnapshot, subscribe) {
      currentHookNameInDev = 'useMutableSource';
      updateHookTypesDev();
      return mountMutableSource(source, getSnapshot, subscribe);
    },
    useOpaqueIdentifier: function () {
      currentHookNameInDev = 'useOpaqueIdentifier';
      updateHookTypesDev();
      return mountOpaqueIdentifier();
    },
    unstable_isNewReconciler: enableNewReconciler
  };
  HooksDispatcherOnUpdateInDEV = {
    readContext: function (context, observedBits) {
      return readContext(context, observedBits);
    },
    useCallback: function (callback, deps) {
      currentHookNameInDev = 'useCallback';
      updateHookTypesDev();
      return updateCallback(callback, deps);
    },
    useContext: function (context, observedBits) {
      currentHookNameInDev = 'useContext';
      updateHookTypesDev();
      return readContext(context, observedBits);
    },
    useEffect: function (create, deps) {
      currentHookNameInDev = 'useEffect';
      updateHookTypesDev();
      return updateEffect(create, deps);
    },
    useImperativeHandle: function (ref, create, deps) {
      currentHookNameInDev = 'useImperativeHandle';
      updateHookTypesDev();
      return updateImperativeHandle(ref, create, deps);
    },
    useLayoutEffect: function (create, deps) {
      currentHookNameInDev = 'useLayoutEffect';
      updateHookTypesDev();
      return updateLayoutEffect(create, deps);
    },
    useMemo: function (create, deps) {
      currentHookNameInDev = 'useMemo';
      updateHookTypesDev();
      var prevDispatcher = ReactCurrentDispatcher$1.current;
      ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;

      try {
        return updateMemo(create, deps);
      } finally {
        ReactCurrentDispatcher$1.current = prevDispatcher;
      }
    },
    useReducer: function (reducer, initialArg, init) {
      currentHookNameInDev = 'useReducer';
      updateHookTypesDev();
      var prevDispatcher = ReactCurrentDispatcher$1.current;
      ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;

      try {
        return updateReducer(reducer, initialArg, init);
      } finally {
        ReactCurrentDispatcher$1.current = prevDispatcher;
      }
    },
    useRef: function (initialValue) {
      currentHookNameInDev = 'useRef';
      updateHookTypesDev();
      return updateRef();
    },
    useState: function (initialState) {
      currentHookNameInDev = 'useState';
      updateHookTypesDev();
      var prevDispatcher = ReactCurrentDispatcher$1.current;
      ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;

      try {
        return updateState(initialState);
      } finally {
        ReactCurrentDispatcher$1.current = prevDispatcher;
      }
    },
    useDebugValue: function (value, formatterFn) {
      currentHookNameInDev = 'useDebugValue';
      updateHookTypesDev();
      return updateDebugValue();
    },
    useDeferredValue: function (value) {
      currentHookNameInDev = 'useDeferredValue';
      updateHookTypesDev();
      return updateDeferredValue(value);
    },
    useTransition: function () {
      currentHookNameInDev = 'useTransition';
      updateHookTypesDev();
      return updateTransition();
    },
    useMutableSource: function (source, getSnapshot, subscribe) {
      currentHookNameInDev = 'useMutableSource';
      updateHookTypesDev();
      return updateMutableSource(source, getSnapshot, subscribe);
    },
    useOpaqueIdentifier: function () {
      currentHookNameInDev = 'useOpaqueIdentifier';
      updateHookTypesDev();
      return updateOpaqueIdentifier();
    },
    unstable_isNewReconciler: enableNewReconciler
  };
  HooksDispatcherOnRerenderInDEV = {
    readContext: function (context, observedBits) {
      return readContext(context, observedBits);
    },
    useCallback: function (callback, deps) {
      currentHookNameInDev = 'useCallback';
      updateHookTypesDev();
      return updateCallback(callback, deps);
    },
    useContext: function (context, observedBits) {
      currentHookNameInDev = 'useContext';
      updateHookTypesDev();
      return readContext(context, observedBits);
    },
    useEffect: function (create, deps) {
      currentHookNameInDev = 'useEffect';
      updateHookTypesDev();
      return updateEffect(create, deps);
    },
    useImperativeHandle: function (ref, create, deps) {
      currentHookNameInDev = 'useImperativeHandle';
      updateHookTypesDev();
      return updateImperativeHandle(ref, create, deps);
    },
    useLayoutEffect: function (create, deps) {
      currentHookNameInDev = 'useLayoutEffect';
      updateHookTypesDev();
      return updateLayoutEffect(create, deps);
    },
    useMemo: function (create, deps) {
      currentHookNameInDev = 'useMemo';
      updateHookTypesDev();
      var prevDispatcher = ReactCurrentDispatcher$1.current;
      ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnRerenderInDEV;

      try {
        return updateMemo(create, deps);
      } finally {
        ReactCurrentDispatcher$1.current = prevDispatcher;
      }
    },
    useReducer: function (reducer, initialArg, init) {
      currentHookNameInDev = 'useReducer';
      updateHookTypesDev();
      var prevDispatcher = ReactCurrentDispatcher$1.current;
      ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnRerenderInDEV;

      try {
        return rerenderReducer(reducer, initialArg, init);
      } finally {
        ReactCurrentDispatcher$1.current = prevDispatcher;
      }
    },
    useRef: function (initialValue) {
      currentHookNameInDev = 'useRef';
      updateHookTypesDev();
      return updateRef();
    },
    useState: function (initialState) {
      currentHookNameInDev = 'useState';
      updateHookTypesDev();
      var prevDispatcher = ReactCurrentDispatcher$1.current;
      ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnRerenderInDEV;

      try {
        return rerenderState(initialState);
      } finally {
        ReactCurrentDispatcher$1.current = prevDispatcher;
      }
    },
    useDebugValue: function (value, formatterFn) {
      currentHookNameInDev = 'useDebugValue';
      updateHookTypesDev();
      return updateDebugValue();
    },
    useDeferredValue: function (value) {
      currentHookNameInDev = 'useDeferredValue';
      updateHookTypesDev();
      return rerenderDeferredValue(value);
    },
    useTransition: function () {
      currentHookNameInDev = 'useTransition';
      updateHookTypesDev();
      return rerenderTransition();
    },
    useMutableSource: function (source, getSnapshot, subscribe) {
      currentHookNameInDev = 'useMutableSource';
      updateHookTypesDev();
      return updateMutableSource(source, getSnapshot, subscribe);
    },
    useOpaqueIdentifier: function () {
      currentHookNameInDev = 'useOpaqueIdentifier';
      updateHookTypesDev();
      return rerenderOpaqueIdentifier();
    },
    unstable_isNewReconciler: enableNewReconciler
  };
  InvalidNestedHooksDispatcherOnMountInDEV = {
    readContext: function (context, observedBits) {
      warnInvalidContextAccess();
      return readContext(context, observedBits);
    },
    useCallback: function (callback, deps) {
      currentHookNameInDev = 'useCallback';
      warnInvalidHookAccess();
      mountHookTypesDev();
      return mountCallback(callback, deps);
    },
    useContext: function (context, observedBits) {
      currentHookNameInDev = 'useContext';
      warnInvalidHookAccess();
      mountHookTypesDev();
      return readContext(context, observedBits);
    },
    useEffect: function (create, deps) {
      currentHookNameInDev = 'useEffect';
      warnInvalidHookAccess();
      mountHookTypesDev();
      return mountEffect(create, deps);
    },
    useImperativeHandle: function (ref, create, deps) {
      currentHookNameInDev = 'useImperativeHandle';
      warnInvalidHookAccess();
      mountHookTypesDev();
      return mountImperativeHandle(ref, create, deps);
    },
    useLayoutEffect: function (create, deps) {
      currentHookNameInDev = 'useLayoutEffect';
      warnInvalidHookAccess();
      mountHookTypesDev();
      return mountLayoutEffect(create, deps);
    },
    useMemo: function (create, deps) {
      currentHookNameInDev = 'useMemo';
      warnInvalidHookAccess();
      mountHookTypesDev();
      var prevDispatcher = ReactCurrentDispatcher$1.current;
      ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;

      try {
        return mountMemo(create, deps);
      } finally {
        ReactCurrentDispatcher$1.current = prevDispatcher;
      }
    },
    useReducer: function (reducer, initialArg, init) {
      currentHookNameInDev = 'useReducer';
      warnInvalidHookAccess();
      mountHookTypesDev();
      var prevDispatcher = ReactCurrentDispatcher$1.current;
      ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;

      try {
        return mountReducer(reducer, initialArg, init);
      } finally {
        ReactCurrentDispatcher$1.current = prevDispatcher;
      }
    },
    useRef: function (initialValue) {
      currentHookNameInDev = 'useRef';
      warnInvalidHookAccess();
      mountHookTypesDev();
      return mountRef(initialValue);
    },
    useState: function (initialState) {
      currentHookNameInDev = 'useState';
      warnInvalidHookAccess();
      mountHookTypesDev();
      var prevDispatcher = ReactCurrentDispatcher$1.current;
      ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;

      try {
        return mountState(initialState);
      } finally {
        ReactCurrentDispatcher$1.current = prevDispatcher;
      }
    },
    useDebugValue: function (value, formatterFn) {
      currentHookNameInDev = 'useDebugValue';
      warnInvalidHookAccess();
      mountHookTypesDev();
      return mountDebugValue();
    },
    useDeferredValue: function (value) {
      currentHookNameInDev = 'useDeferredValue';
      warnInvalidHookAccess();
      mountHookTypesDev();
      return mountDeferredValue(value);
    },
    useTransition: function () {
      currentHookNameInDev = 'useTransition';
      warnInvalidHookAccess();
      mountHookTypesDev();
      return mountTransition();
    },
    useMutableSource: function (source, getSnapshot, subscribe) {
      currentHookNameInDev = 'useMutableSource';
      warnInvalidHookAccess();
      mountHookTypesDev();
      return mountMutableSource(source, getSnapshot, subscribe);
    },
    useOpaqueIdentifier: function () {
      currentHookNameInDev = 'useOpaqueIdentifier';
      warnInvalidHookAccess();
      mountHookTypesDev();
      return mountOpaqueIdentifier();
    },
    unstable_isNewReconciler: enableNewReconciler
  };
  InvalidNestedHooksDispatcherOnUpdateInDEV = {
    readContext: function (context, observedBits) {
      warnInvalidContextAccess();
      return readContext(context, observedBits);
    },
    useCallback: function (callback, deps) {
      currentHookNameInDev = 'useCallback';
      warnInvalidHookAccess();
      updateHookTypesDev();
      return updateCallback(callback, deps);
    },
    useContext: function (context, observedBits) {
      currentHookNameInDev = 'useContext';
      warnInvalidHookAccess();
      updateHookTypesDev();
      return readContext(context, observedBits);
    },
    useEffect: function (create, deps) {
      currentHookNameInDev = 'useEffect';
      warnInvalidHookAccess();
      updateHookTypesDev();
      return updateEffect(create, deps);
    },
    useImperativeHandle: function (ref, create, deps) {
      currentHookNameInDev = 'useImperativeHandle';
      warnInvalidHookAccess();
      updateHookTypesDev();
      return updateImperativeHandle(ref, create, deps);
    },
    useLayoutEffect: function (create, deps) {
      currentHookNameInDev = 'useLayoutEffect';
      warnInvalidHookAccess();
      updateHookTypesDev();
      return updateLayoutEffect(create, deps);
    },
    useMemo: function (create, deps) {
      currentHookNameInDev = 'useMemo';
      warnInvalidHookAccess();
      updateHookTypesDev();
      var prevDispatcher = ReactCurrentDispatcher$1.current;
      ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;

      try {
        return updateMemo(create, deps);
      } finally {
        ReactCurrentDispatcher$1.current = prevDispatcher;
      }
    },
    useReducer: function (reducer, initialArg, init) {
      currentHookNameInDev = 'useReducer';
      warnInvalidHookAccess();
      updateHookTypesDev();
      var prevDispatcher = ReactCurrentDispatcher$1.current;
      ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;

      try {
        return updateReducer(reducer, initialArg, init);
      } finally {
        ReactCurrentDispatcher$1.current = prevDispatcher;
      }
    },
    useRef: function (initialValue) {
      currentHookNameInDev = 'useRef';
      warnInvalidHookAccess();
      updateHookTypesDev();
      return updateRef();
    },
    useState: function (initialState) {
      currentHookNameInDev = 'useState';
      warnInvalidHookAccess();
      updateHookTypesDev();
      var prevDispatcher = ReactCurrentDispatcher$1.current;
      ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;

      try {
        return updateState(initialState);
      } finally {
        ReactCurrentDispatcher$1.current = prevDispatcher;
      }
    },
    useDebugValue: function (value, formatterFn) {
      currentHookNameInDev = 'useDebugValue';
      warnInvalidHookAccess();
      updateHookTypesDev();
      return updateDebugValue();
    },
    useDeferredValue: function (value) {
      currentHookNameInDev = 'useDeferredValue';
      warnInvalidHookAccess();
      updateHookTypesDev();
      return updateDeferredValue(value);
    },
    useTransition: function () {
      currentHookNameInDev = 'useTransition';
      warnInvalidHookAccess();
      updateHookTypesDev();
      return updateTransition();
    },
    useMutableSource: function (source, getSnapshot, subscribe) {
      currentHookNameInDev = 'useMutableSource';
      warnInvalidHookAccess();
      updateHookTypesDev();
      return updateMutableSource(source, getSnapshot, subscribe);
    },
    useOpaqueIdentifier: function () {
      currentHookNameInDev = 'useOpaqueIdentifier';
      warnInvalidHookAccess();
      updateHookTypesDev();
      return updateOpaqueIdentifier();
    },
    unstable_isNewReconciler: enableNewReconciler
  };
  InvalidNestedHooksDispatcherOnRerenderInDEV = {
    readContext: function (context, observedBits) {
      warnInvalidContextAccess();
      return readContext(context, observedBits);
    },
    useCallback: function (callback, deps) {
      currentHookNameInDev = 'useCallback';
      warnInvalidHookAccess();
      updateHookTypesDev();
      return updateCallback(callback, deps);
    },
    useContext: function (context, observedBits) {
      currentHookNameInDev = 'useContext';
      warnInvalidHookAccess();
      updateHookTypesDev();
      return readContext(context, observedBits);
    },
    useEffect: function (create, deps) {
      currentHookNameInDev = 'useEffect';
      warnInvalidHookAccess();
      updateHookTypesDev();
      return updateEffect(create, deps);
    },
    useImperativeHandle: function (ref, create, deps) {
      currentHookNameInDev = 'useImperativeHandle';
      warnInvalidHookAccess();
      updateHookTypesDev();
      return updateImperativeHandle(ref, create, deps);
    },
    useLayoutEffect: function (create, deps) {
      currentHookNameInDev = 'useLayoutEffect';
      warnInvalidHookAccess();
      updateHookTypesDev();
      return updateLayoutEffect(create, deps);
    },
    useMemo: function (create, deps) {
      currentHookNameInDev = 'useMemo';
      warnInvalidHookAccess();
      updateHookTypesDev();
      var prevDispatcher = ReactCurrentDispatcher$1.current;
      ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;

      try {
        return updateMemo(create, deps);
      } finally {
        ReactCurrentDispatcher$1.current = prevDispatcher;
      }
    },
    useReducer: function (reducer, initialArg, init) {
      currentHookNameInDev = 'useReducer';
      warnInvalidHookAccess();
      updateHookTypesDev();
      var prevDispatcher = ReactCurrentDispatcher$1.current;
      ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;

      try {
        return rerenderReducer(reducer, initialArg, init);
      } finally {
        ReactCurrentDispatcher$1.current = prevDispatcher;
      }
    },
    useRef: function (initialValue) {
      currentHookNameInDev = 'useRef';
      warnInvalidHookAccess();
      updateHookTypesDev();
      return updateRef();
    },
    useState: function (initialState) {
      currentHookNameInDev = 'useState';
      warnInvalidHookAccess();
      updateHookTypesDev();
      var prevDispatcher = ReactCurrentDispatcher$1.current;
      ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;

      try {
        return rerenderState(initialState);
      } finally {
        ReactCurrentDispatcher$1.current = prevDispatcher;
      }
    },
    useDebugValue: function (value, formatterFn) {
      currentHookNameInDev = 'useDebugValue';
      warnInvalidHookAccess();
      updateHookTypesDev();
      return updateDebugValue();
    },
    useDeferredValue: function (value) {
      currentHookNameInDev = 'useDeferredValue';
      warnInvalidHookAccess();
      updateHookTypesDev();
      return rerenderDeferredValue(value);
    },
    useTransition: function () {
      currentHookNameInDev = 'useTransition';
      warnInvalidHookAccess();
      updateHookTypesDev();
      return rerenderTransition();
    },
    useMutableSource: function (source, getSnapshot, subscribe) {
      currentHookNameInDev = 'useMutableSource';
      warnInvalidHookAccess();
      updateHookTypesDev();
      return updateMutableSource(source, getSnapshot, subscribe);
    },
    useOpaqueIdentifier: function () {
      currentHookNameInDev = 'useOpaqueIdentifier';
      warnInvalidHookAccess();
      updateHookTypesDev();
      return rerenderOpaqueIdentifier();
    },
    unstable_isNewReconciler: enableNewReconciler
  };
}

var now$1 = Scheduler.unstable_now;
var commitTime = 0;
var profilerStartTime = -1;

function getCommitTime() {
  return commitTime;
}

function recordCommitTime() {

  commitTime = now$1();
}

function startProfilerTimer(fiber) {

  profilerStartTime = now$1();

  if (fiber.actualStartTime < 0) {
    fiber.actualStartTime = now$1();
  }
}

function stopProfilerTimerIfRunning(fiber) {

  profilerStartTime = -1;
}

function stopProfilerTimerIfRunningAndRecordDelta(fiber, overrideBaseTime) {

  if (profilerStartTime >= 0) {
    var elapsedTime = now$1() - profilerStartTime;
    fiber.actualDuration += elapsedTime;

    if (overrideBaseTime) {
      fiber.selfBaseDuration = elapsedTime;
    }

    profilerStartTime = -1;
  }
}

function transferActualDuration(fiber) {
  // Transfer time spent rendering these children so we don't lose it
  // after we rerender. This is used as a helper in special cases
  // where we should count the work of multiple passes.
  var child = fiber.child;

  while (child) {
    fiber.actualDuration += child.actualDuration;
    child = child.sibling;
  }
}

var ReactCurrentOwner$1 = ReactSharedInternals.ReactCurrentOwner;
var didReceiveUpdate = false;
var didWarnAboutBadClass;
var didWarnAboutModulePatternComponent;
var didWarnAboutContextTypeOnFunctionComponent;
var didWarnAboutGetDerivedStateOnFunctionComponent;
var didWarnAboutFunctionRefs;
var didWarnAboutReassigningProps;
var didWarnAboutRevealOrder;
var didWarnAboutTailOptions;

{
  didWarnAboutBadClass = {};
  didWarnAboutModulePatternComponent = {};
  didWarnAboutContextTypeOnFunctionComponent = {};
  didWarnAboutGetDerivedStateOnFunctionComponent = {};
  didWarnAboutFunctionRefs = {};
  didWarnAboutReassigningProps = false;
  didWarnAboutRevealOrder = {};
  didWarnAboutTailOptions = {};
}

function reconcileChildren(current, workInProgress, nextChildren, renderLanes) {
  if (current === null) {
    // If this is a fresh new component that hasn't been rendered yet, we
    // won't update its child set by applying minimal side-effects. Instead,
    // we will add them all to the child before it gets rendered. That means
    // we can optimize this reconciliation pass by not tracking side-effects.
    workInProgress.child = mountChildFibers(workInProgress, null, nextChildren, renderLanes);
  } else {
    // If the current child is the same as the work in progress, it means that
    // we haven't yet started any work on these children. Therefore, we use
    // the clone algorithm to create a copy of all the current children.
    // If we had any progressed work already, that is invalid at this point so
    // let's throw it out.
    workInProgress.child = reconcileChildFibers(workInProgress, current.child, nextChildren, renderLanes);
  }
}

function forceUnmountCurrentAndReconcile(current, workInProgress, nextChildren, renderLanes) {
  // This function is fork of reconcileChildren. It's used in cases where we
  // want to reconcile without matching against the existing set. This has the
  // effect of all current children being unmounted; even if the type and key
  // are the same, the old child is unmounted and a new child is created.
  //
  // To do this, we're going to go through the reconcile algorithm twice. In
  // the first pass, we schedule a deletion for all the current children by
  // passing null.
  workInProgress.child = reconcileChildFibers(workInProgress, current.child, null, renderLanes); // In the second pass, we mount the new children. The trick here is that we
  // pass null in place of where we usually pass the current child set. This has
  // the effect of remounting all children regardless of whether their
  // identities match.

  workInProgress.child = reconcileChildFibers(workInProgress, null, nextChildren, renderLanes);
}

function updateForwardRef(current, workInProgress, Component, nextProps, renderLanes) {
  // TODO: current can be non-null here even if the component
  // hasn't yet mounted. This happens after the first render suspends.
  // We'll need to figure out if this is fine or can cause issues.
  {
    if (workInProgress.type !== workInProgress.elementType) {
      // Lazy component props can't be validated in createElement
      // because they're only guaranteed to be resolved here.
      var innerPropTypes = Component.propTypes;

      if (innerPropTypes) {
        checkPropTypes(innerPropTypes, nextProps, // Resolved props
        'prop', getComponentName(Component));
      }
    }
  }

  var render = Component.render;
  var ref = workInProgress.ref; // The rest is a fork of updateFunctionComponent

  var nextChildren;
  prepareToReadContext(workInProgress, renderLanes);

  {
    ReactCurrentOwner$1.current = workInProgress;
    setIsRendering(true);
    nextChildren = renderWithHooks(current, workInProgress, render, nextProps, ref, renderLanes);

    if ( workInProgress.mode & StrictMode) {
      disableLogs();

      try {
        nextChildren = renderWithHooks(current, workInProgress, render, nextProps, ref, renderLanes);
      } finally {
        reenableLogs();
      }
    }

    setIsRendering(false);
  }

  if (current !== null && !didReceiveUpdate) {
    bailoutHooks(current, workInProgress, renderLanes);
    return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);
  } // React DevTools reads this flag.


  workInProgress.flags |= PerformedWork;
  reconcileChildren(current, workInProgress, nextChildren, renderLanes);
  return workInProgress.child;
}

function updateMemoComponent(current, workInProgress, Component, nextProps, updateLanes, renderLanes) {
  if (current === null) {
    var type = Component.type;

    if (isSimpleFunctionComponent(type) && Component.compare === null && // SimpleMemoComponent codepath doesn't resolve outer props either.
    Component.defaultProps === undefined) {
      var resolvedType = type;

      {
        resolvedType = resolveFunctionForHotReloading(type);
      } // If this is a plain function component without default props,
      // and with only the default shallow comparison, we upgrade it
      // to a SimpleMemoComponent to allow fast path updates.


      workInProgress.tag = SimpleMemoComponent;
      workInProgress.type = resolvedType;

      {
        validateFunctionComponentInDev(workInProgress, type);
      }

      return updateSimpleMemoComponent(current, workInProgress, resolvedType, nextProps, updateLanes, renderLanes);
    }

    {
      var innerPropTypes = type.propTypes;

      if (innerPropTypes) {
        // Inner memo component props aren't currently validated in createElement.
        // We could move it there, but we'd still need this for lazy code path.
        checkPropTypes(innerPropTypes, nextProps, // Resolved props
        'prop', getComponentName(type));
      }
    }

    var child = createFiberFromTypeAndProps(Component.type, null, nextProps, workInProgress, workInProgress.mode, renderLanes);
    child.ref = workInProgress.ref;
    child.return = workInProgress;
    workInProgress.child = child;
    return child;
  }

  {
    var _type = Component.type;
    var _innerPropTypes = _type.propTypes;

    if (_innerPropTypes) {
      // Inner memo component props aren't currently validated in createElement.
      // We could move it there, but we'd still need this for lazy code path.
      checkPropTypes(_innerPropTypes, nextProps, // Resolved props
      'prop', getComponentName(_type));
    }
  }

  var currentChild = current.child; // This is always exactly one child

  if (!includesSomeLane(updateLanes, renderLanes)) {
    // This will be the props with resolved defaultProps,
    // unlike current.memoizedProps which will be the unresolved ones.
    var prevProps = currentChild.memoizedProps; // Default to shallow comparison

    var compare = Component.compare;
    compare = compare !== null ? compare : shallowEqual;

    if (compare(prevProps, nextProps) && current.ref === workInProgress.ref) {
      return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);
    }
  } // React DevTools reads this flag.


  workInProgress.flags |= PerformedWork;
  var newChild = createWorkInProgress(currentChild, nextProps);
  newChild.ref = workInProgress.ref;
  newChild.return = workInProgress;
  workInProgress.child = newChild;
  return newChild;
}

function updateSimpleMemoComponent(current, workInProgress, Component, nextProps, updateLanes, renderLanes) {
  // TODO: current can be non-null here even if the component
  // hasn't yet mounted. This happens when the inner render suspends.
  // We'll need to figure out if this is fine or can cause issues.
  {
    if (workInProgress.type !== workInProgress.elementType) {
      // Lazy component props can't be validated in createElement
      // because they're only guaranteed to be resolved here.
      var outerMemoType = workInProgress.elementType;

      if (outerMemoType.$$typeof === REACT_LAZY_TYPE) {
        // We warn when you define propTypes on lazy()
        // so let's just skip over it to find memo() outer wrapper.
        // Inner props for memo are validated later.
        var lazyComponent = outerMemoType;
        var payload = lazyComponent._payload;
        var init = lazyComponent._init;

        try {
          outerMemoType = init(payload);
        } catch (x) {
          outerMemoType = null;
        } // Inner propTypes will be validated in the function component path.


        var outerPropTypes = outerMemoType && outerMemoType.propTypes;

        if (outerPropTypes) {
          checkPropTypes(outerPropTypes, nextProps, // Resolved (SimpleMemoComponent has no defaultProps)
          'prop', getComponentName(outerMemoType));
        }
      }
    }
  }

  if (current !== null) {
    var prevProps = current.memoizedProps;

    if (shallowEqual(prevProps, nextProps) && current.ref === workInProgress.ref && ( // Prevent bailout if the implementation changed due to hot reload.
     workInProgress.type === current.type )) {
      didReceiveUpdate = false;

      if (!includesSomeLane(renderLanes, updateLanes)) {
        // The pending lanes were cleared at the beginning of beginWork. We're
        // about to bail out, but there might be other lanes that weren't
        // included in the current render. Usually, the priority level of the
        // remaining updates is accumlated during the evaluation of the
        // component (i.e. when processing the update queue). But since since
        // we're bailing out early *without* evaluating the component, we need
        // to account for it here, too. Reset to the value of the current fiber.
        // NOTE: This only applies to SimpleMemoComponent, not MemoComponent,
        // because a MemoComponent fiber does not have hooks or an update queue;
        // rather, it wraps around an inner component, which may or may not
        // contains hooks.
        // TODO: Move the reset at in beginWork out of the common path so that
        // this is no longer necessary.
        workInProgress.lanes = current.lanes;
        return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);
      } else if ((current.flags & ForceUpdateForLegacySuspense) !== NoFlags) {
        // This is a special case that only exists for legacy mode.
        // See https://github.com/facebook/react/pull/19216.
        didReceiveUpdate = true;
      }
    }
  }

  return updateFunctionComponent(current, workInProgress, Component, nextProps, renderLanes);
}

function updateOffscreenComponent(current, workInProgress, renderLanes) {
  var nextProps = workInProgress.pendingProps;
  var nextChildren = nextProps.children;
  var prevState = current !== null ? current.memoizedState : null;

  if (nextProps.mode === 'hidden' || nextProps.mode === 'unstable-defer-without-hiding') {
    if ((workInProgress.mode & ConcurrentMode) === NoMode) {
      // In legacy sync mode, don't defer the subtree. Render it now.
      // TODO: Figure out what we should do in Blocking mode.
      var nextState = {
        baseLanes: NoLanes
      };
      workInProgress.memoizedState = nextState;
      pushRenderLanes(workInProgress, renderLanes);
    } else if (!includesSomeLane(renderLanes, OffscreenLane)) {
      var nextBaseLanes;

      if (prevState !== null) {
        var prevBaseLanes = prevState.baseLanes;
        nextBaseLanes = mergeLanes(prevBaseLanes, renderLanes);
      } else {
        nextBaseLanes = renderLanes;
      } // Schedule this fiber to re-render at offscreen priority. Then bailout.


      {
        markSpawnedWork(OffscreenLane);
      }

      workInProgress.lanes = workInProgress.childLanes = laneToLanes(OffscreenLane);
      var _nextState = {
        baseLanes: nextBaseLanes
      };
      workInProgress.memoizedState = _nextState; // We're about to bail out, but we need to push this to the stack anyway
      // to avoid a push/pop misalignment.

      pushRenderLanes(workInProgress, nextBaseLanes);
      return null;
    } else {
      // Rendering at offscreen, so we can clear the base lanes.
      var _nextState2 = {
        baseLanes: NoLanes
      };
      workInProgress.memoizedState = _nextState2; // Push the lanes that were skipped when we bailed out.

      var subtreeRenderLanes = prevState !== null ? prevState.baseLanes : renderLanes;
      pushRenderLanes(workInProgress, subtreeRenderLanes);
    }
  } else {
    var _subtreeRenderLanes;

    if (prevState !== null) {
      _subtreeRenderLanes = mergeLanes(prevState.baseLanes, renderLanes); // Since we're not hidden anymore, reset the state

      workInProgress.memoizedState = null;
    } else {
      // We weren't previously hidden, and we still aren't, so there's nothing
      // special to do. Need to push to the stack regardless, though, to avoid
      // a push/pop misalignment.
      _subtreeRenderLanes = renderLanes;
    }

    pushRenderLanes(workInProgress, _subtreeRenderLanes);
  }

  reconcileChildren(current, workInProgress, nextChildren, renderLanes);
  return workInProgress.child;
} // Note: These happen to have identical begin phases, for now. We shouldn't hold
// ourselves to this constraint, though. If the behavior diverges, we should
// fork the function.


var updateLegacyHiddenComponent = updateOffscreenComponent;

function updateFragment(current, workInProgress, renderLanes) {
  var nextChildren = workInProgress.pendingProps;
  reconcileChildren(current, workInProgress, nextChildren, renderLanes);
  return workInProgress.child;
}

function updateMode(current, workInProgress, renderLanes) {
  var nextChildren = workInProgress.pendingProps.children;
  reconcileChildren(current, workInProgress, nextChildren, renderLanes);
  return workInProgress.child;
}

function updateProfiler(current, workInProgress, renderLanes) {
  {
    workInProgress.flags |= Update; // Reset effect durations for the next eventual effect phase.
    // These are reset during render to allow the DevTools commit hook a chance to read them,

    var stateNode = workInProgress.stateNode;
    stateNode.effectDuration = 0;
    stateNode.passiveEffectDuration = 0;
  }

  var nextProps = workInProgress.pendingProps;
  var nextChildren = nextProps.children;
  reconcileChildren(current, workInProgress, nextChildren, renderLanes);
  return workInProgress.child;
}

function markRef(current, workInProgress) {
  var ref = workInProgress.ref;

  if (current === null && ref !== null || current !== null && current.ref !== ref) {
    // Schedule a Ref effect
    workInProgress.flags |= Ref;
  }
}

function updateFunctionComponent(current, workInProgress, Component, nextProps, renderLanes) {
  {
    if (workInProgress.type !== workInProgress.elementType) {
      // Lazy component props can't be validated in createElement
      // because they're only guaranteed to be resolved here.
      var innerPropTypes = Component.propTypes;

      if (innerPropTypes) {
        checkPropTypes(innerPropTypes, nextProps, // Resolved props
        'prop', getComponentName(Component));
      }
    }
  }

  var context;

  {
    var unmaskedContext = getUnmaskedContext(workInProgress, Component, true);
    context = getMaskedContext(workInProgress, unmaskedContext);
  }

  var nextChildren;
  prepareToReadContext(workInProgress, renderLanes);

  {
    ReactCurrentOwner$1.current = workInProgress;
    setIsRendering(true);
    nextChildren = renderWithHooks(current, workInProgress, Component, nextProps, context, renderLanes);

    if ( workInProgress.mode & StrictMode) {
      disableLogs();

      try {
        nextChildren = renderWithHooks(current, workInProgress, Component, nextProps, context, renderLanes);
      } finally {
        reenableLogs();
      }
    }

    setIsRendering(false);
  }

  if (current !== null && !didReceiveUpdate) {
    bailoutHooks(current, workInProgress, renderLanes);
    return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);
  } // React DevTools reads this flag.


  workInProgress.flags |= PerformedWork;
  reconcileChildren(current, workInProgress, nextChildren, renderLanes);
  return workInProgress.child;
}

function updateClassComponent(current, workInProgress, Component, nextProps, renderLanes) {
  {
    if (workInProgress.type !== workInProgress.elementType) {
      // Lazy component props can't be validated in createElement
      // because they're only guaranteed to be resolved here.
      var innerPropTypes = Component.propTypes;

      if (innerPropTypes) {
        checkPropTypes(innerPropTypes, nextProps, // Resolved props
        'prop', getComponentName(Component));
      }
    }
  } // Push context providers early to prevent context stack mismatches.
  // During mounting we don't know the child context yet as the instance doesn't exist.
  // We will invalidate the child context in finishClassComponent() right after rendering.


  var hasContext;

  if (isContextProvider(Component)) {
    hasContext = true;
    pushContextProvider(workInProgress);
  } else {
    hasContext = false;
  }

  prepareToReadContext(workInProgress, renderLanes);
  var instance = workInProgress.stateNode;
  var shouldUpdate;

  if (instance === null) {
    if (current !== null) {
      // A class component without an instance only mounts if it suspended
      // inside a non-concurrent tree, in an inconsistent state. We want to
      // treat it like a new mount, even though an empty version of it already
      // committed. Disconnect the alternate pointers.
      current.alternate = null;
      workInProgress.alternate = null; // Since this is conceptually a new fiber, schedule a Placement effect

      workInProgress.flags |= Placement;
    } // In the initial pass we might need to construct the instance.


    constructClassInstance(workInProgress, Component, nextProps);
    mountClassInstance(workInProgress, Component, nextProps, renderLanes);
    shouldUpdate = true;
  } else if (current === null) {
    // In a resume, we'll already have an instance we can reuse.
    shouldUpdate = resumeMountClassInstance(workInProgress, Component, nextProps, renderLanes);
  } else {
    shouldUpdate = updateClassInstance(current, workInProgress, Component, nextProps, renderLanes);
  }

  var nextUnitOfWork = finishClassComponent(current, workInProgress, Component, shouldUpdate, hasContext, renderLanes);

  {
    var inst = workInProgress.stateNode;

    if (shouldUpdate && inst.props !== nextProps) {
      if (!didWarnAboutReassigningProps) {
        error('It looks like %s is reassigning its own `this.props` while rendering. ' + 'This is not supported and can lead to confusing bugs.', getComponentName(workInProgress.type) || 'a component');
      }

      didWarnAboutReassigningProps = true;
    }
  }

  return nextUnitOfWork;
}

function finishClassComponent(current, workInProgress, Component, shouldUpdate, hasContext, renderLanes) {
  // Refs should update even if shouldComponentUpdate returns false
  markRef(current, workInProgress);
  var didCaptureError = (workInProgress.flags & DidCapture) !== NoFlags;

  if (!shouldUpdate && !didCaptureError) {
    // Context providers should defer to sCU for rendering
    if (hasContext) {
      invalidateContextProvider(workInProgress, Component, false);
    }

    return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);
  }

  var instance = workInProgress.stateNode; // Rerender

  ReactCurrentOwner$1.current = workInProgress;
  var nextChildren;

  if (didCaptureError && typeof Component.getDerivedStateFromError !== 'function') {
    // If we captured an error, but getDerivedStateFromError is not defined,
    // unmount all the children. componentDidCatch will schedule an update to
    // re-render a fallback. This is temporary until we migrate everyone to
    // the new API.
    // TODO: Warn in a future release.
    nextChildren = null;

    {
      stopProfilerTimerIfRunning();
    }
  } else {
    {
      setIsRendering(true);
      nextChildren = instance.render();

      if ( workInProgress.mode & StrictMode) {
        disableLogs();

        try {
          instance.render();
        } finally {
          reenableLogs();
        }
      }

      setIsRendering(false);
    }
  } // React DevTools reads this flag.


  workInProgress.flags |= PerformedWork;

  if (current !== null && didCaptureError) {
    // If we're recovering from an error, reconcile without reusing any of
    // the existing children. Conceptually, the normal children and the children
    // that are shown on error are two different sets, so we shouldn't reuse
    // normal children even if their identities match.
    forceUnmountCurrentAndReconcile(current, workInProgress, nextChildren, renderLanes);
  } else {
    reconcileChildren(current, workInProgress, nextChildren, renderLanes);
  } // Memoize state using the values we just used to render.
  // TODO: Restructure so we never read values from the instance.


  workInProgress.memoizedState = instance.state; // The context might have changed so we need to recalculate it.

  if (hasContext) {
    invalidateContextProvider(workInProgress, Component, true);
  }

  return workInProgress.child;
}

function pushHostRootContext(workInProgress) {
  var root = workInProgress.stateNode;

  if (root.pendingContext) {
    pushTopLevelContextObject(workInProgress, root.pendingContext, root.pendingContext !== root.context);
  } else if (root.context) {
    // Should always be set
    pushTopLevelContextObject(workInProgress, root.context, false);
  }

  pushHostContainer(workInProgress, root.containerInfo);
}

function updateHostRoot(current, workInProgress, renderLanes) {
  pushHostRootContext(workInProgress);
  var updateQueue = workInProgress.updateQueue;

  if (!(current !== null && updateQueue !== null)) {
    {
      throw Error( "If the root does not have an updateQueue, we should have already bailed out. This error is likely caused by a bug in React. Please file an issue." );
    }
  }

  var nextProps = workInProgress.pendingProps;
  var prevState = workInProgress.memoizedState;
  var prevChildren = prevState !== null ? prevState.element : null;
  cloneUpdateQueue(current, workInProgress);
  processUpdateQueue(workInProgress, nextProps, null, renderLanes);
  var nextState = workInProgress.memoizedState; // Caution: React DevTools currently depends on this property
  // being called "element".

  var nextChildren = nextState.element;

  if (nextChildren === prevChildren) {
    resetHydrationState();
    return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);
  }

  var root = workInProgress.stateNode;

  if (root.hydrate && enterHydrationState(workInProgress)) {
    // If we don't have any current children this might be the first pass.
    // We always try to hydrate. If this isn't a hydration pass there won't
    // be any children to hydrate which is effectively the same thing as
    // not hydrating.
    {
      var mutableSourceEagerHydrationData = root.mutableSourceEagerHydrationData;

      if (mutableSourceEagerHydrationData != null) {
        for (var i = 0; i < mutableSourceEagerHydrationData.length; i += 2) {
          var mutableSource = mutableSourceEagerHydrationData[i];
          var version = mutableSourceEagerHydrationData[i + 1];
          setWorkInProgressVersion(mutableSource, version);
        }
      }
    }

    var child = mountChildFibers(workInProgress, null, nextChildren, renderLanes);
    workInProgress.child = child;
    var node = child;

    while (node) {
      // Mark each child as hydrating. This is a fast path to know whether this
      // tree is part of a hydrating tree. This is used to determine if a child
      // node has fully mounted yet, and for scheduling event replaying.
      // Conceptually this is similar to Placement in that a new subtree is
      // inserted into the React tree here. It just happens to not need DOM
      // mutations because it already exists.
      node.flags = node.flags & ~Placement | Hydrating;
      node = node.sibling;
    }
  } else {
    // Otherwise reset hydration state in case we aborted and resumed another
    // root.
    reconcileChildren(current, workInProgress, nextChildren, renderLanes);
    resetHydrationState();
  }

  return workInProgress.child;
}

function updateHostComponent(current, workInProgress, renderLanes) {
  pushHostContext(workInProgress);

  if (current === null) {
    tryToClaimNextHydratableInstance(workInProgress);
  }

  var type = workInProgress.type;
  var nextProps = workInProgress.pendingProps;
  var prevProps = current !== null ? current.memoizedProps : null;
  var nextChildren = nextProps.children;
  var isDirectTextChild = shouldSetTextContent(type, nextProps);

  if (isDirectTextChild) {
    // We special case a direct text child of a host node. This is a common
    // case. We won't handle it as a reified child. We will instead handle
    // this in the host environment that also has access to this prop. That
    // avoids allocating another HostText fiber and traversing it.
    nextChildren = null;
  } else if (prevProps !== null && shouldSetTextContent(type, prevProps)) {
    // If we're switching from a direct text child to a normal child, or to
    // empty, we need to schedule the text content to be reset.
    workInProgress.flags |= ContentReset;
  }

  markRef(current, workInProgress);
  reconcileChildren(current, workInProgress, nextChildren, renderLanes);
  return workInProgress.child;
}

function updateHostText(current, workInProgress) {
  if (current === null) {
    tryToClaimNextHydratableInstance(workInProgress);
  } // Nothing to do here. This is terminal. We'll do the completion step
  // immediately after.


  return null;
}

function mountLazyComponent(_current, workInProgress, elementType, updateLanes, renderLanes) {
  if (_current !== null) {
    // A lazy component only mounts if it suspended inside a non-
    // concurrent tree, in an inconsistent state. We want to treat it like
    // a new mount, even though an empty version of it already committed.
    // Disconnect the alternate pointers.
    _current.alternate = null;
    workInProgress.alternate = null; // Since this is conceptually a new fiber, schedule a Placement effect

    workInProgress.flags |= Placement;
  }

  var props = workInProgress.pendingProps;
  var lazyComponent = elementType;
  var payload = lazyComponent._payload;
  var init = lazyComponent._init;
  var Component = init(payload); // Store the unwrapped component in the type.

  workInProgress.type = Component;
  var resolvedTag = workInProgress.tag = resolveLazyComponentTag(Component);
  var resolvedProps = resolveDefaultProps(Component, props);
  var child;

  switch (resolvedTag) {
    case FunctionComponent:
      {
        {
          validateFunctionComponentInDev(workInProgress, Component);
          workInProgress.type = Component = resolveFunctionForHotReloading(Component);
        }

        child = updateFunctionComponent(null, workInProgress, Component, resolvedProps, renderLanes);
        return child;
      }

    case ClassComponent:
      {
        {
          workInProgress.type = Component = resolveClassForHotReloading(Component);
        }

        child = updateClassComponent(null, workInProgress, Component, resolvedProps, renderLanes);
        return child;
      }

    case ForwardRef:
      {
        {
          workInProgress.type = Component = resolveForwardRefForHotReloading(Component);
        }

        child = updateForwardRef(null, workInProgress, Component, resolvedProps, renderLanes);
        return child;
      }

    case MemoComponent:
      {
        {
          if (workInProgress.type !== workInProgress.elementType) {
            var outerPropTypes = Component.propTypes;

            if (outerPropTypes) {
              checkPropTypes(outerPropTypes, resolvedProps, // Resolved for outer only
              'prop', getComponentName(Component));
            }
          }
        }

        child = updateMemoComponent(null, workInProgress, Component, resolveDefaultProps(Component.type, resolvedProps), // The inner type can have defaults too
        updateLanes, renderLanes);
        return child;
      }
  }

  var hint = '';

  {
    if (Component !== null && typeof Component === 'object' && Component.$$typeof === REACT_LAZY_TYPE) {
      hint = ' Did you wrap a component in React.lazy() more than once?';
    }
  } // This message intentionally doesn't mention ForwardRef or MemoComponent
  // because the fact that it's a separate type of work is an
  // implementation detail.


  {
    {
      throw Error( "Element type is invalid. Received a promise that resolves to: " + Component + ". Lazy element type must resolve to a class or function." + hint );
    }
  }
}

function mountIncompleteClassComponent(_current, workInProgress, Component, nextProps, renderLanes) {
  if (_current !== null) {
    // An incomplete component only mounts if it suspended inside a non-
    // concurrent tree, in an inconsistent state. We want to treat it like
    // a new mount, even though an empty version of it already committed.
    // Disconnect the alternate pointers.
    _current.alternate = null;
    workInProgress.alternate = null; // Since this is conceptually a new fiber, schedule a Placement effect

    workInProgress.flags |= Placement;
  } // Promote the fiber to a class and try rendering again.


  workInProgress.tag = ClassComponent; // The rest of this function is a fork of `updateClassComponent`
  // Push context providers early to prevent context stack mismatches.
  // During mounting we don't know the child context yet as the instance doesn't exist.
  // We will invalidate the child context in finishClassComponent() right after rendering.

  var hasContext;

  if (isContextProvider(Component)) {
    hasContext = true;
    pushContextProvider(workInProgress);
  } else {
    hasContext = false;
  }

  prepareToReadContext(workInProgress, renderLanes);
  constructClassInstance(workInProgress, Component, nextProps);
  mountClassInstance(workInProgress, Component, nextProps, renderLanes);
  return finishClassComponent(null, workInProgress, Component, true, hasContext, renderLanes);
}

function mountIndeterminateComponent(_current, workInProgress, Component, renderLanes) {
  if (_current !== null) {
    // An indeterminate component only mounts if it suspended inside a non-
    // concurrent tree, in an inconsistent state. We want to treat it like
    // a new mount, even though an empty version of it already committed.
    // Disconnect the alternate pointers.
    _current.alternate = null;
    workInProgress.alternate = null; // Since this is conceptually a new fiber, schedule a Placement effect

    workInProgress.flags |= Placement;
  }

  var props = workInProgress.pendingProps;
  var context;

  {
    var unmaskedContext = getUnmaskedContext(workInProgress, Component, false);
    context = getMaskedContext(workInProgress, unmaskedContext);
  }

  prepareToReadContext(workInProgress, renderLanes);
  var value;

  {
    if (Component.prototype && typeof Component.prototype.render === 'function') {
      var componentName = getComponentName(Component) || 'Unknown';

      if (!didWarnAboutBadClass[componentName]) {
        error("The <%s /> component appears to have a render method, but doesn't extend React.Component. " + 'This is likely to cause errors. Change %s to extend React.Component instead.', componentName, componentName);

        didWarnAboutBadClass[componentName] = true;
      }
    }

    if (workInProgress.mode & StrictMode) {
      ReactStrictModeWarnings.recordLegacyContextWarning(workInProgress, null);
    }

    setIsRendering(true);
    ReactCurrentOwner$1.current = workInProgress;
    value = renderWithHooks(null, workInProgress, Component, props, context, renderLanes);
    setIsRendering(false);
  } // React DevTools reads this flag.


  workInProgress.flags |= PerformedWork;

  {
    // Support for module components is deprecated and is removed behind a flag.
    // Whether or not it would crash later, we want to show a good message in DEV first.
    if (typeof value === 'object' && value !== null && typeof value.render === 'function' && value.$$typeof === undefined) {
      var _componentName = getComponentName(Component) || 'Unknown';

      if (!didWarnAboutModulePatternComponent[_componentName]) {
        error('The <%s /> component appears to be a function component that returns a class instance. ' + 'Change %s to a class that extends React.Component instead. ' + "If you can't use a class try assigning the prototype on the function as a workaround. " + "`%s.prototype = React.Component.prototype`. Don't use an arrow function since it " + 'cannot be called with `new` by React.', _componentName, _componentName, _componentName);

        didWarnAboutModulePatternComponent[_componentName] = true;
      }
    }
  }

  if ( // Run these checks in production only if the flag is off.
  // Eventually we'll delete this branch altogether.
   typeof value === 'object' && value !== null && typeof value.render === 'function' && value.$$typeof === undefined) {
    {
      var _componentName2 = getComponentName(Component) || 'Unknown';

      if (!didWarnAboutModulePatternComponent[_componentName2]) {
        error('The <%s /> component appears to be a function component that returns a class instance. ' + 'Change %s to a class that extends React.Component instead. ' + "If you can't use a class try assigning the prototype on the function as a workaround. " + "`%s.prototype = React.Component.prototype`. Don't use an arrow function since it " + 'cannot be called with `new` by React.', _componentName2, _componentName2, _componentName2);

        didWarnAboutModulePatternComponent[_componentName2] = true;
      }
    } // Proceed under the assumption that this is a class instance


    workInProgress.tag = ClassComponent; // Throw out any hooks that were used.

    workInProgress.memoizedState = null;
    workInProgress.updateQueue = null; // Push context providers early to prevent context stack mismatches.
    // During mounting we don't know the child context yet as the instance doesn't exist.
    // We will invalidate the child context in finishClassComponent() right after rendering.

    var hasContext = false;

    if (isContextProvider(Component)) {
      hasContext = true;
      pushContextProvider(workInProgress);
    } else {
      hasContext = false;
    }

    workInProgress.memoizedState = value.state !== null && value.state !== undefined ? value.state : null;
    initializeUpdateQueue(workInProgress);
    var getDerivedStateFromProps = Component.getDerivedStateFromProps;

    if (typeof getDerivedStateFromProps === 'function') {
      applyDerivedStateFromProps(workInProgress, Component, getDerivedStateFromProps, props);
    }

    adoptClassInstance(workInProgress, value);
    mountClassInstance(workInProgress, Component, props, renderLanes);
    return finishClassComponent(null, workInProgress, Component, true, hasContext, renderLanes);
  } else {
    // Proceed under the assumption that this is a function component
    workInProgress.tag = FunctionComponent;

    {

      if ( workInProgress.mode & StrictMode) {
        disableLogs();

        try {
          value = renderWithHooks(null, workInProgress, Component, props, context, renderLanes);
        } finally {
          reenableLogs();
        }
      }
    }

    reconcileChildren(null, workInProgress, value, renderLanes);

    {
      validateFunctionComponentInDev(workInProgress, Component);
    }

    return workInProgress.child;
  }
}

function validateFunctionComponentInDev(workInProgress, Component) {
  {
    if (Component) {
      if (Component.childContextTypes) {
        error('%s(...): childContextTypes cannot be defined on a function component.', Component.displayName || Component.name || 'Component');
      }
    }

    if (workInProgress.ref !== null) {
      var info = '';
      var ownerName = getCurrentFiberOwnerNameInDevOrNull();

      if (ownerName) {
        info += '\n\nCheck the render method of `' + ownerName + '`.';
      }

      var warningKey = ownerName || workInProgress._debugID || '';
      var debugSource = workInProgress._debugSource;

      if (debugSource) {
        warningKey = debugSource.fileName + ':' + debugSource.lineNumber;
      }

      if (!didWarnAboutFunctionRefs[warningKey]) {
        didWarnAboutFunctionRefs[warningKey] = true;

        error('Function components cannot be given refs. ' + 'Attempts to access this ref will fail. ' + 'Did you mean to use React.forwardRef()?%s', info);
      }
    }

    if (typeof Component.getDerivedStateFromProps === 'function') {
      var _componentName3 = getComponentName(Component) || 'Unknown';

      if (!didWarnAboutGetDerivedStateOnFunctionComponent[_componentName3]) {
        error('%s: Function components do not support getDerivedStateFromProps.', _componentName3);

        didWarnAboutGetDerivedStateOnFunctionComponent[_componentName3] = true;
      }
    }

    if (typeof Component.contextType === 'object' && Component.contextType !== null) {
      var _componentName4 = getComponentName(Component) || 'Unknown';

      if (!didWarnAboutContextTypeOnFunctionComponent[_componentName4]) {
        error('%s: Function components do not support contextType.', _componentName4);

        didWarnAboutContextTypeOnFunctionComponent[_componentName4] = true;
      }
    }
  }
}

var SUSPENDED_MARKER = {
  dehydrated: null,
  retryLane: NoLane
};

function mountSuspenseOffscreenState(renderLanes) {
  return {
    baseLanes: renderLanes
  };
}

function updateSuspenseOffscreenState(prevOffscreenState, renderLanes) {
  return {
    baseLanes: mergeLanes(prevOffscreenState.baseLanes, renderLanes)
  };
} // TODO: Probably should inline this back


function shouldRemainOnFallback(suspenseContext, current, workInProgress, renderLanes) {
  // If we're already showing a fallback, there are cases where we need to
  // remain on that fallback regardless of whether the content has resolved.
  // For example, SuspenseList coordinates when nested content appears.
  if (current !== null) {
    var suspenseState = current.memoizedState;

    if (suspenseState === null) {
      // Currently showing content. Don't hide it, even if ForceSuspenseFallack
      // is true. More precise name might be "ForceRemainSuspenseFallback".
      // Note: This is a factoring smell. Can't remain on a fallback if there's
      // no fallback to remain on.
      return false;
    }
  } // Not currently showing content. Consult the Suspense context.


  return hasSuspenseContext(suspenseContext, ForceSuspenseFallback);
}

function getRemainingWorkInPrimaryTree(current, renderLanes) {
  // TODO: Should not remove render lanes that were pinged during this render
  return removeLanes(current.childLanes, renderLanes);
}

function updateSuspenseComponent(current, workInProgress, renderLanes) {
  var nextProps = workInProgress.pendingProps; // This is used by DevTools to force a boundary to suspend.

  {
    if (shouldSuspend(workInProgress)) {
      workInProgress.flags |= DidCapture;
    }
  }

  var suspenseContext = suspenseStackCursor.current;
  var showFallback = false;
  var didSuspend = (workInProgress.flags & DidCapture) !== NoFlags;

  if (didSuspend || shouldRemainOnFallback(suspenseContext, current)) {
    // Something in this boundary's subtree already suspended. Switch to
    // rendering the fallback children.
    showFallback = true;
    workInProgress.flags &= ~DidCapture;
  } else {
    // Attempting the main content
    if (current === null || current.memoizedState !== null) {
      // This is a new mount or this boundary is already showing a fallback state.
      // Mark this subtree context as having at least one invisible parent that could
      // handle the fallback state.
      // Boundaries without fallbacks or should be avoided are not considered since
      // they cannot handle preferred fallback states.
      if (nextProps.fallback !== undefined && nextProps.unstable_avoidThisFallback !== true) {
        suspenseContext = addSubtreeSuspenseContext(suspenseContext, InvisibleParentSuspenseContext);
      }
    }
  }

  suspenseContext = setDefaultShallowSuspenseContext(suspenseContext);
  pushSuspenseContext(workInProgress, suspenseContext); // OK, the next part is confusing. We're about to reconcile the Suspense
  // boundary's children. This involves some custom reconcilation logic. Two
  // main reasons this is so complicated.
  //
  // First, Legacy Mode has different semantics for backwards compatibility. The
  // primary tree will commit in an inconsistent state, so when we do the
  // second pass to render the fallback, we do some exceedingly, uh, clever
  // hacks to make that not totally break. Like transferring effects and
  // deletions from hidden tree. In Concurrent Mode, it's much simpler,
  // because we bailout on the primary tree completely and leave it in its old
  // state, no effects. Same as what we do for Offscreen (except that
  // Offscreen doesn't have the first render pass).
  //
  // Second is hydration. During hydration, the Suspense fiber has a slightly
  // different layout, where the child points to a dehydrated fragment, which
  // contains the DOM rendered by the server.
  //
  // Third, even if you set all that aside, Suspense is like error boundaries in
  // that we first we try to render one tree, and if that fails, we render again
  // and switch to a different tree. Like a try/catch block. So we have to track
  // which branch we're currently rendering. Ideally we would model this using
  // a stack.

  if (current === null) {
    // Initial mount
    // If we're currently hydrating, try to hydrate this boundary.
    // But only if this has a fallback.
    if (nextProps.fallback !== undefined) {
      tryToClaimNextHydratableInstance(workInProgress); // This could've been a dehydrated suspense component.
    }

    var nextPrimaryChildren = nextProps.children;
    var nextFallbackChildren = nextProps.fallback;

    if (showFallback) {
      var fallbackFragment = mountSuspenseFallbackChildren(workInProgress, nextPrimaryChildren, nextFallbackChildren, renderLanes);
      var primaryChildFragment = workInProgress.child;
      primaryChildFragment.memoizedState = mountSuspenseOffscreenState(renderLanes);
      workInProgress.memoizedState = SUSPENDED_MARKER;
      return fallbackFragment;
    } else if (typeof nextProps.unstable_expectedLoadTime === 'number') {
      // This is a CPU-bound tree. Skip this tree and show a placeholder to
      // unblock the surrounding content. Then immediately retry after the
      // initial commit.
      var _fallbackFragment = mountSuspenseFallbackChildren(workInProgress, nextPrimaryChildren, nextFallbackChildren, renderLanes);

      var _primaryChildFragment = workInProgress.child;
      _primaryChildFragment.memoizedState = mountSuspenseOffscreenState(renderLanes);
      workInProgress.memoizedState = SUSPENDED_MARKER; // Since nothing actually suspended, there will nothing to ping this to
      // get it started back up to attempt the next item. While in terms of
      // priority this work has the same priority as this current render, it's
      // not part of the same transition once the transition has committed. If
      // it's sync, we still want to yield so that it can be painted.
      // Conceptually, this is really the same as pinging. We can use any
      // RetryLane even if it's the one currently rendering since we're leaving
      // it behind on this node.

      workInProgress.lanes = SomeRetryLane;

      {
        markSpawnedWork(SomeRetryLane);
      }

      return _fallbackFragment;
    } else {
      return mountSuspensePrimaryChildren(workInProgress, nextPrimaryChildren, renderLanes);
    }
  } else {
    // This is an update.
    // If the current fiber has a SuspenseState, that means it's already showing
    // a fallback.
    var prevState = current.memoizedState;

    if (prevState !== null) {

      if (showFallback) {
        var _nextFallbackChildren2 = nextProps.fallback;
        var _nextPrimaryChildren2 = nextProps.children;

        var _fallbackChildFragment = updateSuspenseFallbackChildren(current, workInProgress, _nextPrimaryChildren2, _nextFallbackChildren2, renderLanes);

        var _primaryChildFragment3 = workInProgress.child;
        var prevOffscreenState = current.child.memoizedState;
        _primaryChildFragment3.memoizedState = prevOffscreenState === null ? mountSuspenseOffscreenState(renderLanes) : updateSuspenseOffscreenState(prevOffscreenState, renderLanes);
        _primaryChildFragment3.childLanes = getRemainingWorkInPrimaryTree(current, renderLanes);
        workInProgress.memoizedState = SUSPENDED_MARKER;
        return _fallbackChildFragment;
      } else {
        var _nextPrimaryChildren3 = nextProps.children;

        var _primaryChildFragment4 = updateSuspensePrimaryChildren(current, workInProgress, _nextPrimaryChildren3, renderLanes);

        workInProgress.memoizedState = null;
        return _primaryChildFragment4;
      }
    } else {
      // The current tree is not already showing a fallback.
      if (showFallback) {
        // Timed out.
        var _nextFallbackChildren3 = nextProps.fallback;
        var _nextPrimaryChildren4 = nextProps.children;

        var _fallbackChildFragment2 = updateSuspenseFallbackChildren(current, workInProgress, _nextPrimaryChildren4, _nextFallbackChildren3, renderLanes);

        var _primaryChildFragment5 = workInProgress.child;
        var _prevOffscreenState = current.child.memoizedState;
        _primaryChildFragment5.memoizedState = _prevOffscreenState === null ? mountSuspenseOffscreenState(renderLanes) : updateSuspenseOffscreenState(_prevOffscreenState, renderLanes);
        _primaryChildFragment5.childLanes = getRemainingWorkInPrimaryTree(current, renderLanes); // Skip the primary children, and continue working on the
        // fallback children.

        workInProgress.memoizedState = SUSPENDED_MARKER;
        return _fallbackChildFragment2;
      } else {
        // Still haven't timed out. Continue rendering the children, like we
        // normally do.
        var _nextPrimaryChildren5 = nextProps.children;

        var _primaryChildFragment6 = updateSuspensePrimaryChildren(current, workInProgress, _nextPrimaryChildren5, renderLanes);

        workInProgress.memoizedState = null;
        return _primaryChildFragment6;
      }
    }
  }
}

function mountSuspensePrimaryChildren(workInProgress, primaryChildren, renderLanes) {
  var mode = workInProgress.mode;
  var primaryChildProps = {
    mode: 'visible',
    children: primaryChildren
  };
  var primaryChildFragment = createFiberFromOffscreen(primaryChildProps, mode, renderLanes, null);
  primaryChildFragment.return = workInProgress;
  workInProgress.child = primaryChildFragment;
  return primaryChildFragment;
}

function mountSuspenseFallbackChildren(workInProgress, primaryChildren, fallbackChildren, renderLanes) {
  var mode = workInProgress.mode;
  var progressedPrimaryFragment = workInProgress.child;
  var primaryChildProps = {
    mode: 'hidden',
    children: primaryChildren
  };
  var primaryChildFragment;
  var fallbackChildFragment;

  if ((mode & BlockingMode) === NoMode && progressedPrimaryFragment !== null) {
    // In legacy mode, we commit the primary tree as if it successfully
    // completed, even though it's in an inconsistent state.
    primaryChildFragment = progressedPrimaryFragment;
    primaryChildFragment.childLanes = NoLanes;
    primaryChildFragment.pendingProps = primaryChildProps;

    if ( workInProgress.mode & ProfileMode) {
      // Reset the durations from the first pass so they aren't included in the
      // final amounts. This seems counterintuitive, since we're intentionally
      // not measuring part of the render phase, but this makes it match what we
      // do in Concurrent Mode.
      primaryChildFragment.actualDuration = 0;
      primaryChildFragment.actualStartTime = -1;
      primaryChildFragment.selfBaseDuration = 0;
      primaryChildFragment.treeBaseDuration = 0;
    }

    fallbackChildFragment = createFiberFromFragment(fallbackChildren, mode, renderLanes, null);
  } else {
    primaryChildFragment = createFiberFromOffscreen(primaryChildProps, mode, NoLanes, null);
    fallbackChildFragment = createFiberFromFragment(fallbackChildren, mode, renderLanes, null);
  }

  primaryChildFragment.return = workInProgress;
  fallbackChildFragment.return = workInProgress;
  primaryChildFragment.sibling = fallbackChildFragment;
  workInProgress.child = primaryChildFragment;
  return fallbackChildFragment;
}

function createWorkInProgressOffscreenFiber(current, offscreenProps) {
  // The props argument to `createWorkInProgress` is `any` typed, so we use this
  // wrapper function to constrain it.
  return createWorkInProgress(current, offscreenProps);
}

function updateSuspensePrimaryChildren(current, workInProgress, primaryChildren, renderLanes) {
  var currentPrimaryChildFragment = current.child;
  var currentFallbackChildFragment = currentPrimaryChildFragment.sibling;
  var primaryChildFragment = createWorkInProgressOffscreenFiber(currentPrimaryChildFragment, {
    mode: 'visible',
    children: primaryChildren
  });

  if ((workInProgress.mode & BlockingMode) === NoMode) {
    primaryChildFragment.lanes = renderLanes;
  }

  primaryChildFragment.return = workInProgress;
  primaryChildFragment.sibling = null;

  if (currentFallbackChildFragment !== null) {
    // Delete the fallback child fragment
    currentFallbackChildFragment.nextEffect = null;
    currentFallbackChildFragment.flags = Deletion;
    workInProgress.firstEffect = workInProgress.lastEffect = currentFallbackChildFragment;
  }

  workInProgress.child = primaryChildFragment;
  return primaryChildFragment;
}

function updateSuspenseFallbackChildren(current, workInProgress, primaryChildren, fallbackChildren, renderLanes) {
  var mode = workInProgress.mode;
  var currentPrimaryChildFragment = current.child;
  var currentFallbackChildFragment = currentPrimaryChildFragment.sibling;
  var primaryChildProps = {
    mode: 'hidden',
    children: primaryChildren
  };
  var primaryChildFragment;

  if ( // In legacy mode, we commit the primary tree as if it successfully
  // completed, even though it's in an inconsistent state.
  (mode & BlockingMode) === NoMode && // Make sure we're on the second pass, i.e. the primary child fragment was
  // already cloned. In legacy mode, the only case where this isn't true is
  // when DevTools forces us to display a fallback; we skip the first render
  // pass entirely and go straight to rendering the fallback. (In Concurrent
  // Mode, SuspenseList can also trigger this scenario, but this is a legacy-
  // only codepath.)
  workInProgress.child !== currentPrimaryChildFragment) {
    var progressedPrimaryFragment = workInProgress.child;
    primaryChildFragment = progressedPrimaryFragment;
    primaryChildFragment.childLanes = NoLanes;
    primaryChildFragment.pendingProps = primaryChildProps;

    if ( workInProgress.mode & ProfileMode) {
      // Reset the durations from the first pass so they aren't included in the
      // final amounts. This seems counterintuitive, since we're intentionally
      // not measuring part of the render phase, but this makes it match what we
      // do in Concurrent Mode.
      primaryChildFragment.actualDuration = 0;
      primaryChildFragment.actualStartTime = -1;
      primaryChildFragment.selfBaseDuration = currentPrimaryChildFragment.selfBaseDuration;
      primaryChildFragment.treeBaseDuration = currentPrimaryChildFragment.treeBaseDuration;
    } // The fallback fiber was added as a deletion effect during the first pass.
    // However, since we're going to remain on the fallback, we no longer want
    // to delete it. So we need to remove it from the list. Deletions are stored
    // on the same list as effects. We want to keep the effects from the primary
    // tree. So we copy the primary child fragment's effect list, which does not
    // include the fallback deletion effect.


    var progressedLastEffect = primaryChildFragment.lastEffect;

    if (progressedLastEffect !== null) {
      workInProgress.firstEffect = primaryChildFragment.firstEffect;
      workInProgress.lastEffect = progressedLastEffect;
      progressedLastEffect.nextEffect = null;
    } else {
      // TODO: Reset this somewhere else? Lol legacy mode is so weird.
      workInProgress.firstEffect = workInProgress.lastEffect = null;
    }
  } else {
    primaryChildFragment = createWorkInProgressOffscreenFiber(currentPrimaryChildFragment, primaryChildProps);
  }

  var fallbackChildFragment;

  if (currentFallbackChildFragment !== null) {
    fallbackChildFragment = createWorkInProgress(currentFallbackChildFragment, fallbackChildren);
  } else {
    fallbackChildFragment = createFiberFromFragment(fallbackChildren, mode, renderLanes, null); // Needs a placement effect because the parent (the Suspense boundary) already
    // mounted but this is a new fiber.

    fallbackChildFragment.flags |= Placement;
  }

  fallbackChildFragment.return = workInProgress;
  primaryChildFragment.return = workInProgress;
  primaryChildFragment.sibling = fallbackChildFragment;
  workInProgress.child = primaryChildFragment;
  return fallbackChildFragment;
}

function scheduleWorkOnFiber(fiber, renderLanes) {
  fiber.lanes = mergeLanes(fiber.lanes, renderLanes);
  var alternate = fiber.alternate;

  if (alternate !== null) {
    alternate.lanes = mergeLanes(alternate.lanes, renderLanes);
  }

  scheduleWorkOnParentPath(fiber.return, renderLanes);
}

function propagateSuspenseContextChange(workInProgress, firstChild, renderLanes) {
  // Mark any Suspense boundaries with fallbacks as having work to do.
  // If they were previously forced into fallbacks, they may now be able
  // to unblock.
  var node = firstChild;

  while (node !== null) {
    if (node.tag === SuspenseComponent) {
      var state = node.memoizedState;

      if (state !== null) {
        scheduleWorkOnFiber(node, renderLanes);
      }
    } else if (node.tag === SuspenseListComponent) {
      // If the tail is hidden there might not be an Suspense boundaries
      // to schedule work on. In this case we have to schedule it on the
      // list itself.
      // We don't have to traverse to the children of the list since
      // the list will propagate the change when it rerenders.
      scheduleWorkOnFiber(node, renderLanes);
    } else if (node.child !== null) {
      node.child.return = node;
      node = node.child;
      continue;
    }

    if (node === workInProgress) {
      return;
    }

    while (node.sibling === null) {
      if (node.return === null || node.return === workInProgress) {
        return;
      }

      node = node.return;
    }

    node.sibling.return = node.return;
    node = node.sibling;
  }
}

function findLastContentRow(firstChild) {
  // This is going to find the last row among these children that is already
  // showing content on the screen, as opposed to being in fallback state or
  // new. If a row has multiple Suspense boundaries, any of them being in the
  // fallback state, counts as the whole row being in a fallback state.
  // Note that the "rows" will be workInProgress, but any nested children
  // will still be current since we haven't rendered them yet. The mounted
  // order may not be the same as the new order. We use the new order.
  var row = firstChild;
  var lastContentRow = null;

  while (row !== null) {
    var currentRow = row.alternate; // New rows can't be content rows.

    if (currentRow !== null && findFirstSuspended(currentRow) === null) {
      lastContentRow = row;
    }

    row = row.sibling;
  }

  return lastContentRow;
}

function validateRevealOrder(revealOrder) {
  {
    if (revealOrder !== undefined && revealOrder !== 'forwards' && revealOrder !== 'backwards' && revealOrder !== 'together' && !didWarnAboutRevealOrder[revealOrder]) {
      didWarnAboutRevealOrder[revealOrder] = true;

      if (typeof revealOrder === 'string') {
        switch (revealOrder.toLowerCase()) {
          case 'together':
          case 'forwards':
          case 'backwards':
            {
              error('"%s" is not a valid value for revealOrder on <SuspenseList />. ' + 'Use lowercase "%s" instead.', revealOrder, revealOrder.toLowerCase());

              break;
            }

          case 'forward':
          case 'backward':
            {
              error('"%s" is not a valid value for revealOrder on <SuspenseList />. ' + 'React uses the -s suffix in the spelling. Use "%ss" instead.', revealOrder, revealOrder.toLowerCase());

              break;
            }

          default:
            error('"%s" is not a supported revealOrder on <SuspenseList />. ' + 'Did you mean "together", "forwards" or "backwards"?', revealOrder);

            break;
        }
      } else {
        error('%s is not a supported value for revealOrder on <SuspenseList />. ' + 'Did you mean "together", "forwards" or "backwards"?', revealOrder);
      }
    }
  }
}

function validateTailOptions(tailMode, revealOrder) {
  {
    if (tailMode !== undefined && !didWarnAboutTailOptions[tailMode]) {
      if (tailMode !== 'collapsed' && tailMode !== 'hidden') {
        didWarnAboutTailOptions[tailMode] = true;

        error('"%s" is not a supported value for tail on <SuspenseList />. ' + 'Did you mean "collapsed" or "hidden"?', tailMode);
      } else if (revealOrder !== 'forwards' && revealOrder !== 'backwards') {
        didWarnAboutTailOptions[tailMode] = true;

        error('<SuspenseList tail="%s" /> is only valid if revealOrder is ' + '"forwards" or "backwards". ' + 'Did you mean to specify revealOrder="forwards"?', tailMode);
      }
    }
  }
}

function validateSuspenseListNestedChild(childSlot, index) {
  {
    var isArray = Array.isArray(childSlot);
    var isIterable = !isArray && typeof getIteratorFn(childSlot) === 'function';

    if (isArray || isIterable) {
      var type = isArray ? 'array' : 'iterable';

      error('A nested %s was passed to row #%s in <SuspenseList />. Wrap it in ' + 'an additional SuspenseList to configure its revealOrder: ' + '<SuspenseList revealOrder=...> ... ' + '<SuspenseList revealOrder=...>{%s}</SuspenseList> ... ' + '</SuspenseList>', type, index, type);

      return false;
    }
  }

  return true;
}

function validateSuspenseListChildren(children, revealOrder) {
  {
    if ((revealOrder === 'forwards' || revealOrder === 'backwards') && children !== undefined && children !== null && children !== false) {
      if (Array.isArray(children)) {
        for (var i = 0; i < children.length; i++) {
          if (!validateSuspenseListNestedChild(children[i], i)) {
            return;
          }
        }
      } else {
        var iteratorFn = getIteratorFn(children);

        if (typeof iteratorFn === 'function') {
          var childrenIterator = iteratorFn.call(children);

          if (childrenIterator) {
            var step = childrenIterator.next();
            var _i = 0;

            for (; !step.done; step = childrenIterator.next()) {
              if (!validateSuspenseListNestedChild(step.value, _i)) {
                return;
              }

              _i++;
            }
          }
        } else {
          error('A single row was passed to a <SuspenseList revealOrder="%s" />. ' + 'This is not useful since it needs multiple rows. ' + 'Did you mean to pass multiple children or an array?', revealOrder);
        }
      }
    }
  }
}

function initSuspenseListRenderState(workInProgress, isBackwards, tail, lastContentRow, tailMode, lastEffectBeforeRendering) {
  var renderState = workInProgress.memoizedState;

  if (renderState === null) {
    workInProgress.memoizedState = {
      isBackwards: isBackwards,
      rendering: null,
      renderingStartTime: 0,
      last: lastContentRow,
      tail: tail,
      tailMode: tailMode,
      lastEffect: lastEffectBeforeRendering
    };
  } else {
    // We can reuse the existing object from previous renders.
    renderState.isBackwards = isBackwards;
    renderState.rendering = null;
    renderState.renderingStartTime = 0;
    renderState.last = lastContentRow;
    renderState.tail = tail;
    renderState.tailMode = tailMode;
    renderState.lastEffect = lastEffectBeforeRendering;
  }
} // This can end up rendering this component multiple passes.
// The first pass splits the children fibers into two sets. A head and tail.
// We first render the head. If anything is in fallback state, we do another
// pass through beginWork to rerender all children (including the tail) with
// the force suspend context. If the first render didn't have anything in
// in fallback state. Then we render each row in the tail one-by-one.
// That happens in the completeWork phase without going back to beginWork.


function updateSuspenseListComponent(current, workInProgress, renderLanes) {
  var nextProps = workInProgress.pendingProps;
  var revealOrder = nextProps.revealOrder;
  var tailMode = nextProps.tail;
  var newChildren = nextProps.children;
  validateRevealOrder(revealOrder);
  validateTailOptions(tailMode, revealOrder);
  validateSuspenseListChildren(newChildren, revealOrder);
  reconcileChildren(current, workInProgress, newChildren, renderLanes);
  var suspenseContext = suspenseStackCursor.current;
  var shouldForceFallback = hasSuspenseContext(suspenseContext, ForceSuspenseFallback);

  if (shouldForceFallback) {
    suspenseContext = setShallowSuspenseContext(suspenseContext, ForceSuspenseFallback);
    workInProgress.flags |= DidCapture;
  } else {
    var didSuspendBefore = current !== null && (current.flags & DidCapture) !== NoFlags;

    if (didSuspendBefore) {
      // If we previously forced a fallback, we need to schedule work
      // on any nested boundaries to let them know to try to render
      // again. This is the same as context updating.
      propagateSuspenseContextChange(workInProgress, workInProgress.child, renderLanes);
    }

    suspenseContext = setDefaultShallowSuspenseContext(suspenseContext);
  }

  pushSuspenseContext(workInProgress, suspenseContext);

  if ((workInProgress.mode & BlockingMode) === NoMode) {
    // In legacy mode, SuspenseList doesn't work so we just
    // use make it a noop by treating it as the default revealOrder.
    workInProgress.memoizedState = null;
  } else {
    switch (revealOrder) {
      case 'forwards':
        {
          var lastContentRow = findLastContentRow(workInProgress.child);
          var tail;

          if (lastContentRow === null) {
            // The whole list is part of the tail.
            // TODO: We could fast path by just rendering the tail now.
            tail = workInProgress.child;
            workInProgress.child = null;
          } else {
            // Disconnect the tail rows after the content row.
            // We're going to render them separately later.
            tail = lastContentRow.sibling;
            lastContentRow.sibling = null;
          }

          initSuspenseListRenderState(workInProgress, false, // isBackwards
          tail, lastContentRow, tailMode, workInProgress.lastEffect);
          break;
        }

      case 'backwards':
        {
          // We're going to find the first row that has existing content.
          // At the same time we're going to reverse the list of everything
          // we pass in the meantime. That's going to be our tail in reverse
          // order.
          var _tail = null;
          var row = workInProgress.child;
          workInProgress.child = null;

          while (row !== null) {
            var currentRow = row.alternate; // New rows can't be content rows.

            if (currentRow !== null && findFirstSuspended(currentRow) === null) {
              // This is the beginning of the main content.
              workInProgress.child = row;
              break;
            }

            var nextRow = row.sibling;
            row.sibling = _tail;
            _tail = row;
            row = nextRow;
          } // TODO: If workInProgress.child is null, we can continue on the tail immediately.


          initSuspenseListRenderState(workInProgress, true, // isBackwards
          _tail, null, // last
          tailMode, workInProgress.lastEffect);
          break;
        }

      case 'together':
        {
          initSuspenseListRenderState(workInProgress, false, // isBackwards
          null, // tail
          null, // last
          undefined, workInProgress.lastEffect);
          break;
        }

      default:
        {
          // The default reveal order is the same as not having
          // a boundary.
          workInProgress.memoizedState = null;
        }
    }
  }

  return workInProgress.child;
}

function updatePortalComponent(current, workInProgress, renderLanes) {
  pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo);
  var nextChildren = workInProgress.pendingProps;

  if (current === null) {
    // Portals are special because we don't append the children during mount
    // but at commit. Therefore we need to track insertions which the normal
    // flow doesn't do during mount. This doesn't happen at the root because
    // the root always starts with a "current" with a null child.
    // TODO: Consider unifying this with how the root works.
    workInProgress.child = reconcileChildFibers(workInProgress, null, nextChildren, renderLanes);
  } else {
    reconcileChildren(current, workInProgress, nextChildren, renderLanes);
  }

  return workInProgress.child;
}

var hasWarnedAboutUsingNoValuePropOnContextProvider = false;

function updateContextProvider(current, workInProgress, renderLanes) {
  var providerType = workInProgress.type;
  var context = providerType._context;
  var newProps = workInProgress.pendingProps;
  var oldProps = workInProgress.memoizedProps;
  var newValue = newProps.value;

  {
    if (!('value' in newProps)) {
      if (!hasWarnedAboutUsingNoValuePropOnContextProvider) {
        hasWarnedAboutUsingNoValuePropOnContextProvider = true;

        error('The `value` prop is required for the `<Context.Provider>`. Did you misspell it or forget to pass it?');
      }
    }

    var providerPropTypes = workInProgress.type.propTypes;

    if (providerPropTypes) {
      checkPropTypes(providerPropTypes, newProps, 'prop', 'Context.Provider');
    }
  }

  pushProvider(workInProgress, newValue);

  if (oldProps !== null) {
    var oldValue = oldProps.value;
    var changedBits = calculateChangedBits(context, newValue, oldValue);

    if (changedBits === 0) {
      // No change. Bailout early if children are the same.
      if (oldProps.children === newProps.children && !hasContextChanged()) {
        return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);
      }
    } else {
      // The context value changed. Search for matching consumers and schedule
      // them to update.
      propagateContextChange(workInProgress, context, changedBits, renderLanes);
    }
  }

  var newChildren = newProps.children;
  reconcileChildren(current, workInProgress, newChildren, renderLanes);
  return workInProgress.child;
}

var hasWarnedAboutUsingContextAsConsumer = false;

function updateContextConsumer(current, workInProgress, renderLanes) {
  var context = workInProgress.type; // The logic below for Context differs depending on PROD or DEV mode. In
  // DEV mode, we create a separate object for Context.Consumer that acts
  // like a proxy to Context. This proxy object adds unnecessary code in PROD
  // so we use the old behaviour (Context.Consumer references Context) to
  // reduce size and overhead. The separate object references context via
  // a property called "_context", which also gives us the ability to check
  // in DEV mode if this property exists or not and warn if it does not.

  {
    if (context._context === undefined) {
      // This may be because it's a Context (rather than a Consumer).
      // Or it may be because it's older React where they're the same thing.
      // We only want to warn if we're sure it's a new React.
      if (context !== context.Consumer) {
        if (!hasWarnedAboutUsingContextAsConsumer) {
          hasWarnedAboutUsingContextAsConsumer = true;

          error('Rendering <Context> directly is not supported and will be removed in ' + 'a future major release. Did you mean to render <Context.Consumer> instead?');
        }
      }
    } else {
      context = context._context;
    }
  }

  var newProps = workInProgress.pendingProps;
  var render = newProps.children;

  {
    if (typeof render !== 'function') {
      error('A context consumer was rendered with multiple children, or a child ' + "that isn't a function. A context consumer expects a single child " + 'that is a function. If you did pass a function, make sure there ' + 'is no trailing or leading whitespace around it.');
    }
  }

  prepareToReadContext(workInProgress, renderLanes);
  var newValue = readContext(context, newProps.unstable_observedBits);
  var newChildren;

  {
    ReactCurrentOwner$1.current = workInProgress;
    setIsRendering(true);
    newChildren = render(newValue);
    setIsRendering(false);
  } // React DevTools reads this flag.


  workInProgress.flags |= PerformedWork;
  reconcileChildren(current, workInProgress, newChildren, renderLanes);
  return workInProgress.child;
}

function markWorkInProgressReceivedUpdate() {
  didReceiveUpdate = true;
}

function bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes) {
  if (current !== null) {
    // Reuse previous dependencies
    workInProgress.dependencies = current.dependencies;
  }

  {
    // Don't update "base" render times for bailouts.
    stopProfilerTimerIfRunning();
  }

  markSkippedUpdateLanes(workInProgress.lanes); // Check if the children have any pending work.

  if (!includesSomeLane(renderLanes, workInProgress.childLanes)) {
    // The children don't have any work either. We can skip them.
    // TODO: Once we add back resuming, we should check if the children are
    // a work-in-progress set. If so, we need to transfer their effects.
    return null;
  } else {
    // This fiber doesn't have work, but its subtree does. Clone the child
    // fibers and continue.
    cloneChildFibers(current, workInProgress);
    return workInProgress.child;
  }
}

function remountFiber(current, oldWorkInProgress, newWorkInProgress) {
  {
    var returnFiber = oldWorkInProgress.return;

    if (returnFiber === null) {
      throw new Error('Cannot swap the root fiber.');
    } // Disconnect from the old current.
    // It will get deleted.


    current.alternate = null;
    oldWorkInProgress.alternate = null; // Connect to the new tree.

    newWorkInProgress.index = oldWorkInProgress.index;
    newWorkInProgress.sibling = oldWorkInProgress.sibling;
    newWorkInProgress.return = oldWorkInProgress.return;
    newWorkInProgress.ref = oldWorkInProgress.ref; // Replace the child/sibling pointers above it.

    if (oldWorkInProgress === returnFiber.child) {
      returnFiber.child = newWorkInProgress;
    } else {
      var prevSibling = returnFiber.child;

      if (prevSibling === null) {
        throw new Error('Expected parent to have a child.');
      }

      while (prevSibling.sibling !== oldWorkInProgress) {
        prevSibling = prevSibling.sibling;

        if (prevSibling === null) {
          throw new Error('Expected to find the previous sibling.');
        }
      }

      prevSibling.sibling = newWorkInProgress;
    } // Delete the old fiber and place the new one.
    // Since the old fiber is disconnected, we have to schedule it manually.


    var last = returnFiber.lastEffect;

    if (last !== null) {
      last.nextEffect = current;
      returnFiber.lastEffect = current;
    } else {
      returnFiber.firstEffect = returnFiber.lastEffect = current;
    }

    current.nextEffect = null;
    current.flags = Deletion;
    newWorkInProgress.flags |= Placement; // Restart work from the new fiber.

    return newWorkInProgress;
  }
}

function beginWork(current, workInProgress, renderLanes) {
  var updateLanes = workInProgress.lanes;

  {
    if (workInProgress._debugNeedsRemount && current !== null) {
      // This will restart the begin phase with a new fiber.
      return remountFiber(current, workInProgress, createFiberFromTypeAndProps(workInProgress.type, workInProgress.key, workInProgress.pendingProps, workInProgress._debugOwner || null, workInProgress.mode, workInProgress.lanes));
    }
  }

  if (current !== null) {
    var oldProps = current.memoizedProps;
    var newProps = workInProgress.pendingProps;

    if (oldProps !== newProps || hasContextChanged() || ( // Force a re-render if the implementation changed due to hot reload:
     workInProgress.type !== current.type )) {
      // If props or context changed, mark the fiber as having performed work.
      // This may be unset if the props are determined to be equal later (memo).
      didReceiveUpdate = true;
    } else if (!includesSomeLane(renderLanes, updateLanes)) {
      didReceiveUpdate = false; // This fiber does not have any pending work. Bailout without entering
      // the begin phase. There's still some bookkeeping we that needs to be done
      // in this optimized path, mostly pushing stuff onto the stack.

      switch (workInProgress.tag) {
        case HostRoot:
          pushHostRootContext(workInProgress);
          resetHydrationState();
          break;

        case HostComponent:
          pushHostContext(workInProgress);
          break;

        case ClassComponent:
          {
            var Component = workInProgress.type;

            if (isContextProvider(Component)) {
              pushContextProvider(workInProgress);
            }

            break;
          }

        case HostPortal:
          pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo);
          break;

        case ContextProvider:
          {
            var newValue = workInProgress.memoizedProps.value;
            pushProvider(workInProgress, newValue);
            break;
          }

        case Profiler:
          {
            // Profiler should only call onRender when one of its descendants actually rendered.
            var hasChildWork = includesSomeLane(renderLanes, workInProgress.childLanes);

            if (hasChildWork) {
              workInProgress.flags |= Update;
            } // Reset effect durations for the next eventual effect phase.
            // These are reset during render to allow the DevTools commit hook a chance to read them,


            var stateNode = workInProgress.stateNode;
            stateNode.effectDuration = 0;
            stateNode.passiveEffectDuration = 0;
          }

          break;

        case SuspenseComponent:
          {
            var state = workInProgress.memoizedState;

            if (state !== null) {
              // whether to retry the primary children, or to skip over it and
              // go straight to the fallback. Check the priority of the primary
              // child fragment.


              var primaryChildFragment = workInProgress.child;
              var primaryChildLanes = primaryChildFragment.childLanes;

              if (includesSomeLane(renderLanes, primaryChildLanes)) {
                // The primary children have pending work. Use the normal path
                // to attempt to render the primary children again.
                return updateSuspenseComponent(current, workInProgress, renderLanes);
              } else {
                // The primary child fragment does not have pending work marked
                // on it
                pushSuspenseContext(workInProgress, setDefaultShallowSuspenseContext(suspenseStackCursor.current)); // The primary children do not have pending work with sufficient
                // priority. Bailout.

                var child = bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);

                if (child !== null) {
                  // The fallback children have pending work. Skip over the
                  // primary children and work on the fallback.
                  return child.sibling;
                } else {
                  return null;
                }
              }
            } else {
              pushSuspenseContext(workInProgress, setDefaultShallowSuspenseContext(suspenseStackCursor.current));
            }

            break;
          }

        case SuspenseListComponent:
          {
            var didSuspendBefore = (current.flags & DidCapture) !== NoFlags;

            var _hasChildWork = includesSomeLane(renderLanes, workInProgress.childLanes);

            if (didSuspendBefore) {
              if (_hasChildWork) {
                // If something was in fallback state last time, and we have all the
                // same children then we're still in progressive loading state.
                // Something might get unblocked by state updates or retries in the
                // tree which will affect the tail. So we need to use the normal
                // path to compute the correct tail.
                return updateSuspenseListComponent(current, workInProgress, renderLanes);
              } // If none of the children had any work, that means that none of
              // them got retried so they'll still be blocked in the same way
              // as before. We can fast bail out.


              workInProgress.flags |= DidCapture;
            } // If nothing suspended before and we're rendering the same children,
            // then the tail doesn't matter. Anything new that suspends will work
            // in the "together" mode, so we can continue from the state we had.


            var renderState = workInProgress.memoizedState;

            if (renderState !== null) {
              // Reset to the "together" mode in case we've started a different
              // update in the past but didn't complete it.
              renderState.rendering = null;
              renderState.tail = null;
              renderState.lastEffect = null;
            }

            pushSuspenseContext(workInProgress, suspenseStackCursor.current);

            if (_hasChildWork) {
              break;
            } else {
              // If none of the children had any work, that means that none of
              // them got retried so they'll still be blocked in the same way
              // as before. We can fast bail out.
              return null;
            }
          }

        case OffscreenComponent:
        case LegacyHiddenComponent:
          {
            // Need to check if the tree still needs to be deferred. This is
            // almost identical to the logic used in the normal update path,
            // so we'll just enter that. The only difference is we'll bail out
            // at the next level instead of this one, because the child props
            // have not changed. Which is fine.
            // TODO: Probably should refactor `beginWork` to split the bailout
            // path from the normal path. I'm tempted to do a labeled break here
            // but I won't :)
            workInProgress.lanes = NoLanes;
            return updateOffscreenComponent(current, workInProgress, renderLanes);
          }
      }

      return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);
    } else {
      if ((current.flags & ForceUpdateForLegacySuspense) !== NoFlags) {
        // This is a special case that only exists for legacy mode.
        // See https://github.com/facebook/react/pull/19216.
        didReceiveUpdate = true;
      } else {
        // An update was scheduled on this fiber, but there are no new props
        // nor legacy context. Set this to false. If an update queue or context
        // consumer produces a changed value, it will set this to true. Otherwise,
        // the component will assume the children have not changed and bail out.
        didReceiveUpdate = false;
      }
    }
  } else {
    didReceiveUpdate = false;
  } // Before entering the begin phase, clear pending update priority.
  // TODO: This assumes that we're about to evaluate the component and process
  // the update queue. However, there's an exception: SimpleMemoComponent
  // sometimes bails out later in the begin phase. This indicates that we should
  // move this assignment out of the common path and into each branch.


  workInProgress.lanes = NoLanes;

  switch (workInProgress.tag) {
    case IndeterminateComponent:
      {
        return mountIndeterminateComponent(current, workInProgress, workInProgress.type, renderLanes);
      }

    case LazyComponent:
      {
        var elementType = workInProgress.elementType;
        return mountLazyComponent(current, workInProgress, elementType, updateLanes, renderLanes);
      }

    case FunctionComponent:
      {
        var _Component = workInProgress.type;
        var unresolvedProps = workInProgress.pendingProps;
        var resolvedProps = workInProgress.elementType === _Component ? unresolvedProps : resolveDefaultProps(_Component, unresolvedProps);
        return updateFunctionComponent(current, workInProgress, _Component, resolvedProps, renderLanes);
      }

    case ClassComponent:
      {
        var _Component2 = workInProgress.type;
        var _unresolvedProps = workInProgress.pendingProps;

        var _resolvedProps = workInProgress.elementType === _Component2 ? _unresolvedProps : resolveDefaultProps(_Component2, _unresolvedProps);

        return updateClassComponent(current, workInProgress, _Component2, _resolvedProps, renderLanes);
      }

    case HostRoot:
      return updateHostRoot(current, workInProgress, renderLanes);

    case HostComponent:
      return updateHostComponent(current, workInProgress, renderLanes);

    case HostText:
      return updateHostText(current, workInProgress);

    case SuspenseComponent:
      return updateSuspenseComponent(current, workInProgress, renderLanes);

    case HostPortal:
      return updatePortalComponent(current, workInProgress, renderLanes);

    case ForwardRef:
      {
        var type = workInProgress.type;
        var _unresolvedProps2 = workInProgress.pendingProps;

        var _resolvedProps2 = workInProgress.elementType === type ? _unresolvedProps2 : resolveDefaultProps(type, _unresolvedProps2);

        return updateForwardRef(current, workInProgress, type, _resolvedProps2, renderLanes);
      }

    case Fragment:
      return updateFragment(current, workInProgress, renderLanes);

    case Mode:
      return updateMode(current, workInProgress, renderLanes);

    case Profiler:
      return updateProfiler(current, workInProgress, renderLanes);

    case ContextProvider:
      return updateContextProvider(current, workInProgress, renderLanes);

    case ContextConsumer:
      return updateContextConsumer(current, workInProgress, renderLanes);

    case MemoComponent:
      {
        var _type2 = workInProgress.type;
        var _unresolvedProps3 = workInProgress.pendingProps; // Resolve outer props first, then resolve inner props.

        var _resolvedProps3 = resolveDefaultProps(_type2, _unresolvedProps3);

        {
          if (workInProgress.type !== workInProgress.elementType) {
            var outerPropTypes = _type2.propTypes;

            if (outerPropTypes) {
              checkPropTypes(outerPropTypes, _resolvedProps3, // Resolved for outer only
              'prop', getComponentName(_type2));
            }
          }
        }

        _resolvedProps3 = resolveDefaultProps(_type2.type, _resolvedProps3);
        return updateMemoComponent(current, workInProgress, _type2, _resolvedProps3, updateLanes, renderLanes);
      }

    case SimpleMemoComponent:
      {
        return updateSimpleMemoComponent(current, workInProgress, workInProgress.type, workInProgress.pendingProps, updateLanes, renderLanes);
      }

    case IncompleteClassComponent:
      {
        var _Component3 = workInProgress.type;
        var _unresolvedProps4 = workInProgress.pendingProps;

        var _resolvedProps4 = workInProgress.elementType === _Component3 ? _unresolvedProps4 : resolveDefaultProps(_Component3, _unresolvedProps4);

        return mountIncompleteClassComponent(current, workInProgress, _Component3, _resolvedProps4, renderLanes);
      }

    case SuspenseListComponent:
      {
        return updateSuspenseListComponent(current, workInProgress, renderLanes);
      }

    case FundamentalComponent:
      {

        break;
      }

    case ScopeComponent:
      {

        break;
      }

    case Block:
      {

        break;
      }

    case OffscreenComponent:
      {
        return updateOffscreenComponent(current, workInProgress, renderLanes);
      }

    case LegacyHiddenComponent:
      {
        return updateLegacyHiddenComponent(current, workInProgress, renderLanes);
      }
  }

  {
    {
      throw Error( "Unknown unit of work tag (" + workInProgress.tag + "). This error is likely caused by a bug in React. Please file an issue." );
    }
  }
}

function markUpdate(workInProgress) {
  // Tag the fiber with an update effect. This turns a Placement into
  // a PlacementAndUpdate.
  workInProgress.flags |= Update;
}

function markRef$1(workInProgress) {
  workInProgress.flags |= Ref;
}

var appendAllChildren;
var updateHostContainer;
var updateHostComponent$1;
var updateHostText$1;

{
  // Mutation mode
  appendAllChildren = function (parent, workInProgress, needsVisibilityToggle, isHidden) {
    // We only have the top Fiber that was created but we need recurse down its
    // children to find all the terminal nodes.
    var node = workInProgress.child;

    while (node !== null) {
      if (node.tag === HostComponent || node.tag === HostText) {
        appendInitialChild(parent, node.stateNode);
      } else if (node.tag === HostPortal) ; else if (node.child !== null) {
        node.child.return = node;
        node = node.child;
        continue;
      }

      if (node === workInProgress) {
        return;
      }

      while (node.sibling === null) {
        if (node.return === null || node.return === workInProgress) {
          return;
        }

        node = node.return;
      }

      node.sibling.return = node.return;
      node = node.sibling;
    }
  };

  updateHostContainer = function (workInProgress) {// Noop
  };

  updateHostComponent$1 = function (current, workInProgress, type, newProps, rootContainerInstance) {
    // If we have an alternate, that means this is an update and we need to
    // schedule a side-effect to do the updates.
    var oldProps = current.memoizedProps;

    if (oldProps === newProps) {
      // In mutation mode, this is sufficient for a bailout because
      // we won't touch this node even if children changed.
      return;
    } // If we get updated because one of our children updated, we don't
    // have newProps so we'll have to reuse them.
    // TODO: Split the update API as separate for the props vs. children.
    // Even better would be if children weren't special cased at all tho.


    var instance = workInProgress.stateNode;
    var currentHostContext = getHostContext(); // TODO: Experiencing an error where oldProps is null. Suggests a host
    // component is hitting the resume path. Figure out why. Possibly
    // related to `hidden`.

    var updatePayload = prepareUpdate(instance, type, oldProps, newProps, rootContainerInstance, currentHostContext); // TODO: Type this specific to this type of component.

    workInProgress.updateQueue = updatePayload; // If the update payload indicates that there is a change or if there
    // is a new ref we mark this as an update. All the work is done in commitWork.

    if (updatePayload) {
      markUpdate(workInProgress);
    }
  };

  updateHostText$1 = function (current, workInProgress, oldText, newText) {
    // If the text differs, mark it as an update. All the work in done in commitWork.
    if (oldText !== newText) {
      markUpdate(workInProgress);
    }
  };
}

function cutOffTailIfNeeded(renderState, hasRenderedATailFallback) {
  if (getIsHydrating()) {
    // If we're hydrating, we should consume as many items as we can
    // so we don't leave any behind.
    return;
  }

  switch (renderState.tailMode) {
    case 'hidden':
      {
        // Any insertions at the end of the tail list after this point
        // should be invisible. If there are already mounted boundaries
        // anything before them are not considered for collapsing.
        // Therefore we need to go through the whole tail to find if
        // there are any.
        var tailNode = renderState.tail;
        var lastTailNode = null;

        while (tailNode !== null) {
          if (tailNode.alternate !== null) {
            lastTailNode = tailNode;
          }

          tailNode = tailNode.sibling;
        } // Next we're simply going to delete all insertions after the
        // last rendered item.


        if (lastTailNode === null) {
          // All remaining items in the tail are insertions.
          renderState.tail = null;
        } else {
          // Detach the insertion after the last node that was already
          // inserted.
          lastTailNode.sibling = null;
        }

        break;
      }

    case 'collapsed':
      {
        // Any insertions at the end of the tail list after this point
        // should be invisible. If there are already mounted boundaries
        // anything before them are not considered for collapsing.
        // Therefore we need to go through the whole tail to find if
        // there are any.
        var _tailNode = renderState.tail;
        var _lastTailNode = null;

        while (_tailNode !== null) {
          if (_tailNode.alternate !== null) {
            _lastTailNode = _tailNode;
          }

          _tailNode = _tailNode.sibling;
        } // Next we're simply going to delete all insertions after the
        // last rendered item.


        if (_lastTailNode === null) {
          // All remaining items in the tail are insertions.
          if (!hasRenderedATailFallback && renderState.tail !== null) {
            // We suspended during the head. We want to show at least one
            // row at the tail. So we'll keep on and cut off the rest.
            renderState.tail.sibling = null;
          } else {
            renderState.tail = null;
          }
        } else {
          // Detach the insertion after the last node that was already
          // inserted.
          _lastTailNode.sibling = null;
        }

        break;
      }
  }
}

function completeWork(current, workInProgress, renderLanes) {
  var newProps = workInProgress.pendingProps;

  switch (workInProgress.tag) {
    case IndeterminateComponent:
    case LazyComponent:
    case SimpleMemoComponent:
    case FunctionComponent:
    case ForwardRef:
    case Fragment:
    case Mode:
    case Profiler:
    case ContextConsumer:
    case MemoComponent:
      return null;

    case ClassComponent:
      {
        var Component = workInProgress.type;

        if (isContextProvider(Component)) {
          popContext(workInProgress);
        }

        return null;
      }

    case HostRoot:
      {
        popHostContainer(workInProgress);
        popTopLevelContextObject(workInProgress);
        resetWorkInProgressVersions();
        var fiberRoot = workInProgress.stateNode;

        if (fiberRoot.pendingContext) {
          fiberRoot.context = fiberRoot.pendingContext;
          fiberRoot.pendingContext = null;
        }

        if (current === null || current.child === null) {
          // If we hydrated, pop so that we can delete any remaining children
          // that weren't hydrated.
          var wasHydrated = popHydrationState(workInProgress);

          if (wasHydrated) {
            // If we hydrated, then we'll need to schedule an update for
            // the commit side-effects on the root.
            markUpdate(workInProgress);
          } else if (!fiberRoot.hydrate) {
            // Schedule an effect to clear this container at the start of the next commit.
            // This handles the case of React rendering into a container with previous children.
            // It's also safe to do for updates too, because current.child would only be null
            // if the previous render was null (so the the container would already be empty).
            workInProgress.flags |= Snapshot;
          }
        }

        updateHostContainer(workInProgress);
        return null;
      }

    case HostComponent:
      {
        popHostContext(workInProgress);
        var rootContainerInstance = getRootHostContainer();
        var type = workInProgress.type;

        if (current !== null && workInProgress.stateNode != null) {
          updateHostComponent$1(current, workInProgress, type, newProps, rootContainerInstance);

          if (current.ref !== workInProgress.ref) {
            markRef$1(workInProgress);
          }
        } else {
          if (!newProps) {
            if (!(workInProgress.stateNode !== null)) {
              {
                throw Error( "We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue." );
              }
            } // This can happen when we abort work.


            return null;
          }

          var currentHostContext = getHostContext(); // TODO: Move createInstance to beginWork and keep it on a context
          // "stack" as the parent. Then append children as we go in beginWork
          // or completeWork depending on whether we want to add them top->down or
          // bottom->up. Top->down is faster in IE11.

          var _wasHydrated = popHydrationState(workInProgress);

          if (_wasHydrated) {
            // TODO: Move this and createInstance step into the beginPhase
            // to consolidate.
            if (prepareToHydrateHostInstance(workInProgress, rootContainerInstance, currentHostContext)) {
              // If changes to the hydrated node need to be applied at the
              // commit-phase we mark this as such.
              markUpdate(workInProgress);
            }
          } else {
            var instance = createInstance(type, newProps, rootContainerInstance, currentHostContext, workInProgress);
            appendAllChildren(instance, workInProgress, false, false);
            workInProgress.stateNode = instance; // Certain renderers require commit-time effects for initial mount.
            // (eg DOM renderer supports auto-focus for certain elements).
            // Make sure such renderers get scheduled for later work.

            if (finalizeInitialChildren(instance, type, newProps, rootContainerInstance)) {
              markUpdate(workInProgress);
            }
          }

          if (workInProgress.ref !== null) {
            // If there is a ref on a host node we need to schedule a callback
            markRef$1(workInProgress);
          }
        }

        return null;
      }

    case HostText:
      {
        var newText = newProps;

        if (current && workInProgress.stateNode != null) {
          var oldText = current.memoizedProps; // If we have an alternate, that means this is an update and we need
          // to schedule a side-effect to do the updates.

          updateHostText$1(current, workInProgress, oldText, newText);
        } else {
          if (typeof newText !== 'string') {
            if (!(workInProgress.stateNode !== null)) {
              {
                throw Error( "We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue." );
              }
            } // This can happen when we abort work.

          }

          var _rootContainerInstance = getRootHostContainer();

          var _currentHostContext = getHostContext();

          var _wasHydrated2 = popHydrationState(workInProgress);

          if (_wasHydrated2) {
            if (prepareToHydrateHostTextInstance(workInProgress)) {
              markUpdate(workInProgress);
            }
          } else {
            workInProgress.stateNode = createTextInstance(newText, _rootContainerInstance, _currentHostContext, workInProgress);
          }
        }

        return null;
      }

    case SuspenseComponent:
      {
        popSuspenseContext(workInProgress);
        var nextState = workInProgress.memoizedState;

        if ((workInProgress.flags & DidCapture) !== NoFlags) {
          // Something suspended. Re-render with the fallback children.
          workInProgress.lanes = renderLanes; // Do not reset the effect list.

          if ( (workInProgress.mode & ProfileMode) !== NoMode) {
            transferActualDuration(workInProgress);
          }

          return workInProgress;
        }

        var nextDidTimeout = nextState !== null;
        var prevDidTimeout = false;

        if (current === null) {
          if (workInProgress.memoizedProps.fallback !== undefined) {
            popHydrationState(workInProgress);
          }
        } else {
          var prevState = current.memoizedState;
          prevDidTimeout = prevState !== null;
        }

        if (nextDidTimeout && !prevDidTimeout) {
          // If this subtreee is running in blocking mode we can suspend,
          // otherwise we won't suspend.
          // TODO: This will still suspend a synchronous tree if anything
          // in the concurrent tree already suspended during this render.
          // This is a known bug.
          if ((workInProgress.mode & BlockingMode) !== NoMode) {
            // TODO: Move this back to throwException because this is too late
            // if this is a large tree which is common for initial loads. We
            // don't know if we should restart a render or not until we get
            // this marker, and this is too late.
            // If this render already had a ping or lower pri updates,
            // and this is the first time we know we're going to suspend we
            // should be able to immediately restart from within throwException.
            var hasInvisibleChildContext = current === null && workInProgress.memoizedProps.unstable_avoidThisFallback !== true;

            if (hasInvisibleChildContext || hasSuspenseContext(suspenseStackCursor.current, InvisibleParentSuspenseContext)) {
              // If this was in an invisible tree or a new render, then showing
              // this boundary is ok.
              renderDidSuspend();
            } else {
              // Otherwise, we're going to have to hide content so we should
              // suspend for longer if possible.
              renderDidSuspendDelayIfPossible();
            }
          }
        }

        {
          // TODO: Only schedule updates if these values are non equal, i.e. it changed.
          if (nextDidTimeout || prevDidTimeout) {
            // If this boundary just timed out, schedule an effect to attach a
            // retry listener to the promise. This flag is also used to hide the
            // primary children. In mutation mode, we also need the flag to
            // *unhide* children that were previously hidden, so check if this
            // is currently timed out, too.
            workInProgress.flags |= Update;
          }
        }

        return null;
      }

    case HostPortal:
      popHostContainer(workInProgress);
      updateHostContainer(workInProgress);

      if (current === null) {
        preparePortalMount(workInProgress.stateNode.containerInfo);
      }

      return null;

    case ContextProvider:
      // Pop provider fiber
      popProvider(workInProgress);
      return null;

    case IncompleteClassComponent:
      {
        // Same as class component case. I put it down here so that the tags are
        // sequential to ensure this switch is compiled to a jump table.
        var _Component = workInProgress.type;

        if (isContextProvider(_Component)) {
          popContext(workInProgress);
        }

        return null;
      }

    case SuspenseListComponent:
      {
        popSuspenseContext(workInProgress);
        var renderState = workInProgress.memoizedState;

        if (renderState === null) {
          // We're running in the default, "independent" mode.
          // We don't do anything in this mode.
          return null;
        }

        var didSuspendAlready = (workInProgress.flags & DidCapture) !== NoFlags;
        var renderedTail = renderState.rendering;

        if (renderedTail === null) {
          // We just rendered the head.
          if (!didSuspendAlready) {
            // This is the first pass. We need to figure out if anything is still
            // suspended in the rendered set.
            // If new content unsuspended, but there's still some content that
            // didn't. Then we need to do a second pass that forces everything
            // to keep showing their fallbacks.
            // We might be suspended if something in this render pass suspended, or
            // something in the previous committed pass suspended. Otherwise,
            // there's no chance so we can skip the expensive call to
            // findFirstSuspended.
            var cannotBeSuspended = renderHasNotSuspendedYet() && (current === null || (current.flags & DidCapture) === NoFlags);

            if (!cannotBeSuspended) {
              var row = workInProgress.child;

              while (row !== null) {
                var suspended = findFirstSuspended(row);

                if (suspended !== null) {
                  didSuspendAlready = true;
                  workInProgress.flags |= DidCapture;
                  cutOffTailIfNeeded(renderState, false); // If this is a newly suspended tree, it might not get committed as
                  // part of the second pass. In that case nothing will subscribe to
                  // its thennables. Instead, we'll transfer its thennables to the
                  // SuspenseList so that it can retry if they resolve.
                  // There might be multiple of these in the list but since we're
                  // going to wait for all of them anyway, it doesn't really matter
                  // which ones gets to ping. In theory we could get clever and keep
                  // track of how many dependencies remain but it gets tricky because
                  // in the meantime, we can add/remove/change items and dependencies.
                  // We might bail out of the loop before finding any but that
                  // doesn't matter since that means that the other boundaries that
                  // we did find already has their listeners attached.

                  var newThennables = suspended.updateQueue;

                  if (newThennables !== null) {
                    workInProgress.updateQueue = newThennables;
                    workInProgress.flags |= Update;
                  } // Rerender the whole list, but this time, we'll force fallbacks
                  // to stay in place.
                  // Reset the effect list before doing the second pass since that's now invalid.


                  if (renderState.lastEffect === null) {
                    workInProgress.firstEffect = null;
                  }

                  workInProgress.lastEffect = renderState.lastEffect; // Reset the child fibers to their original state.

                  resetChildFibers(workInProgress, renderLanes); // Set up the Suspense Context to force suspense and immediately
                  // rerender the children.

                  pushSuspenseContext(workInProgress, setShallowSuspenseContext(suspenseStackCursor.current, ForceSuspenseFallback));
                  return workInProgress.child;
                }

                row = row.sibling;
              }
            }

            if (renderState.tail !== null && now() > getRenderTargetTime()) {
              // We have already passed our CPU deadline but we still have rows
              // left in the tail. We'll just give up further attempts to render
              // the main content and only render fallbacks.
              workInProgress.flags |= DidCapture;
              didSuspendAlready = true;
              cutOffTailIfNeeded(renderState, false); // Since nothing actually suspended, there will nothing to ping this
              // to get it started back up to attempt the next item. While in terms
              // of priority this work has the same priority as this current render,
              // it's not part of the same transition once the transition has
              // committed. If it's sync, we still want to yield so that it can be
              // painted. Conceptually, this is really the same as pinging.
              // We can use any RetryLane even if it's the one currently rendering
              // since we're leaving it behind on this node.

              workInProgress.lanes = SomeRetryLane;

              {
                markSpawnedWork(SomeRetryLane);
              }
            }
          } else {
            cutOffTailIfNeeded(renderState, false);
          } // Next we're going to render the tail.

        } else {
          // Append the rendered row to the child list.
          if (!didSuspendAlready) {
            var _suspended = findFirstSuspended(renderedTail);

            if (_suspended !== null) {
              workInProgress.flags |= DidCapture;
              didSuspendAlready = true; // Ensure we transfer the update queue to the parent so that it doesn't
              // get lost if this row ends up dropped during a second pass.

              var _newThennables = _suspended.updateQueue;

              if (_newThennables !== null) {
                workInProgress.updateQueue = _newThennables;
                workInProgress.flags |= Update;
              }

              cutOffTailIfNeeded(renderState, true); // This might have been modified.

              if (renderState.tail === null && renderState.tailMode === 'hidden' && !renderedTail.alternate && !getIsHydrating() // We don't cut it if we're hydrating.
              ) {
                  // We need to delete the row we just rendered.
                  // Reset the effect list to what it was before we rendered this
                  // child. The nested children have already appended themselves.
                  var lastEffect = workInProgress.lastEffect = renderState.lastEffect; // Remove any effects that were appended after this point.

                  if (lastEffect !== null) {
                    lastEffect.nextEffect = null;
                  } // We're done.


                  return null;
                }
            } else if ( // The time it took to render last row is greater than the remaining
            // time we have to render. So rendering one more row would likely
            // exceed it.
            now() * 2 - renderState.renderingStartTime > getRenderTargetTime() && renderLanes !== OffscreenLane) {
              // We have now passed our CPU deadline and we'll just give up further
              // attempts to render the main content and only render fallbacks.
              // The assumption is that this is usually faster.
              workInProgress.flags |= DidCapture;
              didSuspendAlready = true;
              cutOffTailIfNeeded(renderState, false); // Since nothing actually suspended, there will nothing to ping this
              // to get it started back up to attempt the next item. While in terms
              // of priority this work has the same priority as this current render,
              // it's not part of the same transition once the transition has
              // committed. If it's sync, we still want to yield so that it can be
              // painted. Conceptually, this is really the same as pinging.
              // We can use any RetryLane even if it's the one currently rendering
              // since we're leaving it behind on this node.

              workInProgress.lanes = SomeRetryLane;

              {
                markSpawnedWork(SomeRetryLane);
              }
            }
          }

          if (renderState.isBackwards) {
            // The effect list of the backwards tail will have been added
            // to the end. This breaks the guarantee that life-cycles fire in
            // sibling order but that isn't a strong guarantee promised by React.
            // Especially since these might also just pop in during future commits.
            // Append to the beginning of the list.
            renderedTail.sibling = workInProgress.child;
            workInProgress.child = renderedTail;
          } else {
            var previousSibling = renderState.last;

            if (previousSibling !== null) {
              previousSibling.sibling = renderedTail;
            } else {
              workInProgress.child = renderedTail;
            }

            renderState.last = renderedTail;
          }
        }

        if (renderState.tail !== null) {
          // We still have tail rows to render.
          // Pop a row.
          var next = renderState.tail;
          renderState.rendering = next;
          renderState.tail = next.sibling;
          renderState.lastEffect = workInProgress.lastEffect;
          renderState.renderingStartTime = now();
          next.sibling = null; // Restore the context.
          // TODO: We can probably just avoid popping it instead and only
          // setting it the first time we go from not suspended to suspended.

          var suspenseContext = suspenseStackCursor.current;

          if (didSuspendAlready) {
            suspenseContext = setShallowSuspenseContext(suspenseContext, ForceSuspenseFallback);
          } else {
            suspenseContext = setDefaultShallowSuspenseContext(suspenseContext);
          }

          pushSuspenseContext(workInProgress, suspenseContext); // Do a pass over the next row.

          return next;
        }

        return null;
      }

    case FundamentalComponent:
      {

        break;
      }

    case ScopeComponent:
      {

        break;
      }

    case Block:

      break;

    case OffscreenComponent:
    case LegacyHiddenComponent:
      {
        popRenderLanes(workInProgress);

        if (current !== null) {
          var _nextState = workInProgress.memoizedState;
          var _prevState = current.memoizedState;
          var prevIsHidden = _prevState !== null;
          var nextIsHidden = _nextState !== null;

          if (prevIsHidden !== nextIsHidden && newProps.mode !== 'unstable-defer-without-hiding') {
            workInProgress.flags |= Update;
          }
        }

        return null;
      }
  }

  {
    {
      throw Error( "Unknown unit of work tag (" + workInProgress.tag + "). This error is likely caused by a bug in React. Please file an issue." );
    }
  }
}

function unwindWork(workInProgress, renderLanes) {
  switch (workInProgress.tag) {
    case ClassComponent:
      {
        var Component = workInProgress.type;

        if (isContextProvider(Component)) {
          popContext(workInProgress);
        }

        var flags = workInProgress.flags;

        if (flags & ShouldCapture) {
          workInProgress.flags = flags & ~ShouldCapture | DidCapture;

          if ( (workInProgress.mode & ProfileMode) !== NoMode) {
            transferActualDuration(workInProgress);
          }

          return workInProgress;
        }

        return null;
      }

    case HostRoot:
      {
        popHostContainer(workInProgress);
        popTopLevelContextObject(workInProgress);
        resetWorkInProgressVersions();
        var _flags = workInProgress.flags;

        if (!((_flags & DidCapture) === NoFlags)) {
          {
            throw Error( "The root failed to unmount after an error. This is likely a bug in React. Please file an issue." );
          }
        }

        workInProgress.flags = _flags & ~ShouldCapture | DidCapture;
        return workInProgress;
      }

    case HostComponent:
      {
        // TODO: popHydrationState
        popHostContext(workInProgress);
        return null;
      }

    case SuspenseComponent:
      {
        popSuspenseContext(workInProgress);

        var _flags2 = workInProgress.flags;

        if (_flags2 & ShouldCapture) {
          workInProgress.flags = _flags2 & ~ShouldCapture | DidCapture; // Captured a suspense effect. Re-render the boundary.

          if ( (workInProgress.mode & ProfileMode) !== NoMode) {
            transferActualDuration(workInProgress);
          }

          return workInProgress;
        }

        return null;
      }

    case SuspenseListComponent:
      {
        popSuspenseContext(workInProgress); // SuspenseList doesn't actually catch anything. It should've been
        // caught by a nested boundary. If not, it should bubble through.

        return null;
      }

    case HostPortal:
      popHostContainer(workInProgress);
      return null;

    case ContextProvider:
      popProvider(workInProgress);
      return null;

    case OffscreenComponent:
    case LegacyHiddenComponent:
      popRenderLanes(workInProgress);
      return null;

    default:
      return null;
  }
}

function unwindInterruptedWork(interruptedWork) {
  switch (interruptedWork.tag) {
    case ClassComponent:
      {
        var childContextTypes = interruptedWork.type.childContextTypes;

        if (childContextTypes !== null && childContextTypes !== undefined) {
          popContext(interruptedWork);
        }

        break;
      }

    case HostRoot:
      {
        popHostContainer(interruptedWork);
        popTopLevelContextObject(interruptedWork);
        resetWorkInProgressVersions();
        break;
      }

    case HostComponent:
      {
        popHostContext(interruptedWork);
        break;
      }

    case HostPortal:
      popHostContainer(interruptedWork);
      break;

    case SuspenseComponent:
      popSuspenseContext(interruptedWork);
      break;

    case SuspenseListComponent:
      popSuspenseContext(interruptedWork);
      break;

    case ContextProvider:
      popProvider(interruptedWork);
      break;

    case OffscreenComponent:
    case LegacyHiddenComponent:
      popRenderLanes(interruptedWork);
      break;
  }
}

function createCapturedValue(value, source) {
  // If the value is an error, call this function immediately after it is thrown
  // so the stack is accurate.
  return {
    value: value,
    source: source,
    stack: getStackByFiberInDevAndProd(source)
  };
}

// This module is forked in different environments.
// By default, return `true` to log errors to the console.
// Forks can return `false` if this isn't desirable.
function showErrorDialog(boundary, errorInfo) {
  return true;
}

function logCapturedError(boundary, errorInfo) {
  try {
    var logError = showErrorDialog(boundary, errorInfo); // Allow injected showErrorDialog() to prevent default console.error logging.
    // This enables renderers like ReactNative to better manage redbox behavior.

    if (logError === false) {
      return;
    }

    var error = errorInfo.value;

    if (true) {
      var source = errorInfo.source;
      var stack = errorInfo.stack;
      var componentStack = stack !== null ? stack : ''; // Browsers support silencing uncaught errors by calling
      // `preventDefault()` in window `error` handler.
      // We record this information as an expando on the error.

      if (error != null && error._suppressLogging) {
        if (boundary.tag === ClassComponent) {
          // The error is recoverable and was silenced.
          // Ignore it and don't print the stack addendum.
          // This is handy for testing error boundaries without noise.
          return;
        } // The error is fatal. Since the silencing might have
        // been accidental, we'll surface it anyway.
        // However, the browser would have silenced the original error
        // so we'll print it first, and then print the stack addendum.


        console['error'](error); // Don't transform to our wrapper
        // For a more detailed description of this block, see:
        // https://github.com/facebook/react/pull/13384
      }

      var componentName = source ? getComponentName(source.type) : null;
      var componentNameMessage = componentName ? "The above error occurred in the <" + componentName + "> component:" : 'The above error occurred in one of your React components:';
      var errorBoundaryMessage;
      var errorBoundaryName = getComponentName(boundary.type);

      if (errorBoundaryName) {
        errorBoundaryMessage = "React will try to recreate this component tree from scratch " + ("using the error boundary you provided, " + errorBoundaryName + ".");
      } else {
        errorBoundaryMessage = 'Consider adding an error boundary to your tree to customize error handling behavior.\n' + 'Visit https://reactjs.org/link/error-boundaries to learn more about error boundaries.';
      }

      var combinedMessage = componentNameMessage + "\n" + componentStack + "\n\n" + ("" + errorBoundaryMessage); // In development, we provide our own message with just the component stack.
      // We don't include the original error message and JS stack because the browser
      // has already printed it. Even if the application swallows the error, it is still
      // displayed by the browser thanks to the DEV-only fake event trick in ReactErrorUtils.

      console['error'](combinedMessage); // Don't transform to our wrapper
    } else {}
  } catch (e) {
    // This method must not throw, or React internal state will get messed up.
    // If console.error is overridden, or logCapturedError() shows a dialog that throws,
    // we want to report this error outside of the normal stack as a last resort.
    // https://github.com/facebook/react/issues/13188
    setTimeout(function () {
      throw e;
    });
  }
}

var PossiblyWeakMap$1 = typeof WeakMap === 'function' ? WeakMap : Map;

function createRootErrorUpdate(fiber, errorInfo, lane) {
  var update = createUpdate(NoTimestamp, lane); // Unmount the root by rendering null.

  update.tag = CaptureUpdate; // Caution: React DevTools currently depends on this property
  // being called "element".

  update.payload = {
    element: null
  };
  var error = errorInfo.value;

  update.callback = function () {
    onUncaughtError(error);
    logCapturedError(fiber, errorInfo);
  };

  return update;
}

function createClassErrorUpdate(fiber, errorInfo, lane) {
  var update = createUpdate(NoTimestamp, lane);
  update.tag = CaptureUpdate;
  var getDerivedStateFromError = fiber.type.getDerivedStateFromError;

  if (typeof getDerivedStateFromError === 'function') {
    var error$1 = errorInfo.value;

    update.payload = function () {
      logCapturedError(fiber, errorInfo);
      return getDerivedStateFromError(error$1);
    };
  }

  var inst = fiber.stateNode;

  if (inst !== null && typeof inst.componentDidCatch === 'function') {
    update.callback = function callback() {
      {
        markFailedErrorBoundaryForHotReloading(fiber);
      }

      if (typeof getDerivedStateFromError !== 'function') {
        // To preserve the preexisting retry behavior of error boundaries,
        // we keep track of which ones already failed during this batch.
        // This gets reset before we yield back to the browser.
        // TODO: Warn in strict mode if getDerivedStateFromError is
        // not defined.
        markLegacyErrorBoundaryAsFailed(this); // Only log here if componentDidCatch is the only error boundary method defined

        logCapturedError(fiber, errorInfo);
      }

      var error$1 = errorInfo.value;
      var stack = errorInfo.stack;
      this.componentDidCatch(error$1, {
        componentStack: stack !== null ? stack : ''
      });

      {
        if (typeof getDerivedStateFromError !== 'function') {
          // If componentDidCatch is the only error boundary method defined,
          // then it needs to call setState to recover from errors.
          // If no state update is scheduled then the boundary will swallow the error.
          if (!includesSomeLane(fiber.lanes, SyncLane)) {
            error('%s: Error boundaries should implement getDerivedStateFromError(). ' + 'In that method, return a state update to display an error message or fallback UI.', getComponentName(fiber.type) || 'Unknown');
          }
        }
      }
    };
  } else {
    update.callback = function () {
      markFailedErrorBoundaryForHotReloading(fiber);
    };
  }

  return update;
}

function attachPingListener(root, wakeable, lanes) {
  // Attach a listener to the promise to "ping" the root and retry. But only if
  // one does not already exist for the lanes we're currently rendering (which
  // acts like a "thread ID" here).
  var pingCache = root.pingCache;
  var threadIDs;

  if (pingCache === null) {
    pingCache = root.pingCache = new PossiblyWeakMap$1();
    threadIDs = new Set();
    pingCache.set(wakeable, threadIDs);
  } else {
    threadIDs = pingCache.get(wakeable);

    if (threadIDs === undefined) {
      threadIDs = new Set();
      pingCache.set(wakeable, threadIDs);
    }
  }

  if (!threadIDs.has(lanes)) {
    // Memoize using the thread ID to prevent redundant listeners.
    threadIDs.add(lanes);
    var ping = pingSuspendedRoot.bind(null, root, wakeable, lanes);
    wakeable.then(ping, ping);
  }
}

function throwException(root, returnFiber, sourceFiber, value, rootRenderLanes) {
  // The source fiber did not complete.
  sourceFiber.flags |= Incomplete; // Its effect list is no longer valid.

  sourceFiber.firstEffect = sourceFiber.lastEffect = null;

  if (value !== null && typeof value === 'object' && typeof value.then === 'function') {
    // This is a wakeable.
    var wakeable = value;

    if ((sourceFiber.mode & BlockingMode) === NoMode) {
      // Reset the memoizedState to what it was before we attempted
      // to render it.
      var currentSource = sourceFiber.alternate;

      if (currentSource) {
        sourceFiber.updateQueue = currentSource.updateQueue;
        sourceFiber.memoizedState = currentSource.memoizedState;
        sourceFiber.lanes = currentSource.lanes;
      } else {
        sourceFiber.updateQueue = null;
        sourceFiber.memoizedState = null;
      }
    }

    var hasInvisibleParentBoundary = hasSuspenseContext(suspenseStackCursor.current, InvisibleParentSuspenseContext); // Schedule the nearest Suspense to re-render the timed out view.

    var _workInProgress = returnFiber;

    do {
      if (_workInProgress.tag === SuspenseComponent && shouldCaptureSuspense(_workInProgress, hasInvisibleParentBoundary)) {
        // Found the nearest boundary.
        // Stash the promise on the boundary fiber. If the boundary times out, we'll
        // attach another listener to flip the boundary back to its normal state.
        var wakeables = _workInProgress.updateQueue;

        if (wakeables === null) {
          var updateQueue = new Set();
          updateQueue.add(wakeable);
          _workInProgress.updateQueue = updateQueue;
        } else {
          wakeables.add(wakeable);
        } // If the boundary is outside of blocking mode, we should *not*
        // suspend the commit. Pretend as if the suspended component rendered
        // null and keep rendering. In the commit phase, we'll schedule a
        // subsequent synchronous update to re-render the Suspense.
        //
        // Note: It doesn't matter whether the component that suspended was
        // inside a blocking mode tree. If the Suspense is outside of it, we
        // should *not* suspend the commit.


        if ((_workInProgress.mode & BlockingMode) === NoMode) {
          _workInProgress.flags |= DidCapture;
          sourceFiber.flags |= ForceUpdateForLegacySuspense; // We're going to commit this fiber even though it didn't complete.
          // But we shouldn't call any lifecycle methods or callbacks. Remove
          // all lifecycle effect tags.

          sourceFiber.flags &= ~(LifecycleEffectMask | Incomplete);

          if (sourceFiber.tag === ClassComponent) {
            var currentSourceFiber = sourceFiber.alternate;

            if (currentSourceFiber === null) {
              // This is a new mount. Change the tag so it's not mistaken for a
              // completed class component. For example, we should not call
              // componentWillUnmount if it is deleted.
              sourceFiber.tag = IncompleteClassComponent;
            } else {
              // When we try rendering again, we should not reuse the current fiber,
              // since it's known to be in an inconsistent state. Use a force update to
              // prevent a bail out.
              var update = createUpdate(NoTimestamp, SyncLane);
              update.tag = ForceUpdate;
              enqueueUpdate(sourceFiber, update);
            }
          } // The source fiber did not complete. Mark it with Sync priority to
          // indicate that it still has pending work.


          sourceFiber.lanes = mergeLanes(sourceFiber.lanes, SyncLane); // Exit without suspending.

          return;
        } // Confirmed that the boundary is in a concurrent mode tree. Continue
        // with the normal suspend path.
        //
        // After this we'll use a set of heuristics to determine whether this
        // render pass will run to completion or restart or "suspend" the commit.
        // The actual logic for this is spread out in different places.
        //
        // This first principle is that if we're going to suspend when we complete
        // a root, then we should also restart if we get an update or ping that
        // might unsuspend it, and vice versa. The only reason to suspend is
        // because you think you might want to restart before committing. However,
        // it doesn't make sense to restart only while in the period we're suspended.
        //
        // Restarting too aggressively is also not good because it starves out any
        // intermediate loading state. So we use heuristics to determine when.
        // Suspense Heuristics
        //
        // If nothing threw a Promise or all the same fallbacks are already showing,
        // then don't suspend/restart.
        //
        // If this is an initial render of a new tree of Suspense boundaries and
        // those trigger a fallback, then don't suspend/restart. We want to ensure
        // that we can show the initial loading state as quickly as possible.
        //
        // If we hit a "Delayed" case, such as when we'd switch from content back into
        // a fallback, then we should always suspend/restart. Transitions apply
        // to this case. If none is defined, JND is used instead.
        //
        // If we're already showing a fallback and it gets "retried", allowing us to show
        // another level, but there's still an inner boundary that would show a fallback,
        // then we suspend/restart for 500ms since the last time we showed a fallback
        // anywhere in the tree. This effectively throttles progressive loading into a
        // consistent train of commits. This also gives us an opportunity to restart to
        // get to the completed state slightly earlier.
        //
        // If there's ambiguity due to batching it's resolved in preference of:
        // 1) "delayed", 2) "initial render", 3) "retry".
        //
        // We want to ensure that a "busy" state doesn't get force committed. We want to
        // ensure that new initial loading states can commit as soon as possible.


        attachPingListener(root, wakeable, rootRenderLanes);
        _workInProgress.flags |= ShouldCapture;
        _workInProgress.lanes = rootRenderLanes;
        return;
      } // This boundary already captured during this render. Continue to the next
      // boundary.


      _workInProgress = _workInProgress.return;
    } while (_workInProgress !== null); // No boundary was found. Fallthrough to error mode.
    // TODO: Use invariant so the message is stripped in prod?


    value = new Error((getComponentName(sourceFiber.type) || 'A React component') + ' suspended while rendering, but no fallback UI was specified.\n' + '\n' + 'Add a <Suspense fallback=...> component higher in the tree to ' + 'provide a loading indicator or placeholder to display.');
  } // We didn't find a boundary that could handle this type of exception. Start
  // over and traverse parent path again, this time treating the exception
  // as an error.


  renderDidError();
  value = createCapturedValue(value, sourceFiber);
  var workInProgress = returnFiber;

  do {
    switch (workInProgress.tag) {
      case HostRoot:
        {
          var _errorInfo = value;
          workInProgress.flags |= ShouldCapture;
          var lane = pickArbitraryLane(rootRenderLanes);
          workInProgress.lanes = mergeLanes(workInProgress.lanes, lane);

          var _update = createRootErrorUpdate(workInProgress, _errorInfo, lane);

          enqueueCapturedUpdate(workInProgress, _update);
          return;
        }

      case ClassComponent:
        // Capture and retry
        var errorInfo = value;
        var ctor = workInProgress.type;
        var instance = workInProgress.stateNode;

        if ((workInProgress.flags & DidCapture) === NoFlags && (typeof ctor.getDerivedStateFromError === 'function' || instance !== null && typeof instance.componentDidCatch === 'function' && !isAlreadyFailedLegacyErrorBoundary(instance))) {
          workInProgress.flags |= ShouldCapture;

          var _lane = pickArbitraryLane(rootRenderLanes);

          workInProgress.lanes = mergeLanes(workInProgress.lanes, _lane); // Schedule the error boundary to re-render using updated state

          var _update2 = createClassErrorUpdate(workInProgress, errorInfo, _lane);

          enqueueCapturedUpdate(workInProgress, _update2);
          return;
        }

        break;
    }

    workInProgress = workInProgress.return;
  } while (workInProgress !== null);
}

var didWarnAboutUndefinedSnapshotBeforeUpdate = null;

{
  didWarnAboutUndefinedSnapshotBeforeUpdate = new Set();
}

var PossiblyWeakSet = typeof WeakSet === 'function' ? WeakSet : Set;

var callComponentWillUnmountWithTimer = function (current, instance) {
  instance.props = current.memoizedProps;
  instance.state = current.memoizedState;

  {
    instance.componentWillUnmount();
  }
}; // Capture errors so they don't interrupt unmounting.


function safelyCallComponentWillUnmount(current, instance) {
  {
    invokeGuardedCallback(null, callComponentWillUnmountWithTimer, null, current, instance);

    if (hasCaughtError()) {
      var unmountError = clearCaughtError();
      captureCommitPhaseError(current, unmountError);
    }
  }
}

function safelyDetachRef(current) {
  var ref = current.ref;

  if (ref !== null) {
    if (typeof ref === 'function') {
      {
        invokeGuardedCallback(null, ref, null, null);

        if (hasCaughtError()) {
          var refError = clearCaughtError();
          captureCommitPhaseError(current, refError);
        }
      }
    } else {
      ref.current = null;
    }
  }
}

function safelyCallDestroy(current, destroy) {
  {
    invokeGuardedCallback(null, destroy, null);

    if (hasCaughtError()) {
      var error = clearCaughtError();
      captureCommitPhaseError(current, error);
    }
  }
}

function commitBeforeMutationLifeCycles(current, finishedWork) {
  switch (finishedWork.tag) {
    case FunctionComponent:
    case ForwardRef:
    case SimpleMemoComponent:
    case Block:
      {
        return;
      }

    case ClassComponent:
      {
        if (finishedWork.flags & Snapshot) {
          if (current !== null) {
            var prevProps = current.memoizedProps;
            var prevState = current.memoizedState;
            var instance = finishedWork.stateNode; // We could update instance props and state here,
            // but instead we rely on them being set during last render.
            // TODO: revisit this when we implement resuming.

            {
              if (finishedWork.type === finishedWork.elementType && !didWarnAboutReassigningProps) {
                if (instance.props !== finishedWork.memoizedProps) {
                  error('Expected %s props to match memoized props before ' + 'getSnapshotBeforeUpdate. ' + 'This might either be because of a bug in React, or because ' + 'a component reassigns its own `this.props`. ' + 'Please file an issue.', getComponentName(finishedWork.type) || 'instance');
                }

                if (instance.state !== finishedWork.memoizedState) {
                  error('Expected %s state to match memoized state before ' + 'getSnapshotBeforeUpdate. ' + 'This might either be because of a bug in React, or because ' + 'a component reassigns its own `this.state`. ' + 'Please file an issue.', getComponentName(finishedWork.type) || 'instance');
                }
              }
            }

            var snapshot = instance.getSnapshotBeforeUpdate(finishedWork.elementType === finishedWork.type ? prevProps : resolveDefaultProps(finishedWork.type, prevProps), prevState);

            {
              var didWarnSet = didWarnAboutUndefinedSnapshotBeforeUpdate;

              if (snapshot === undefined && !didWarnSet.has(finishedWork.type)) {
                didWarnSet.add(finishedWork.type);

                error('%s.getSnapshotBeforeUpdate(): A snapshot value (or null) ' + 'must be returned. You have returned undefined.', getComponentName(finishedWork.type));
              }
            }

            instance.__reactInternalSnapshotBeforeUpdate = snapshot;
          }
        }

        return;
      }

    case HostRoot:
      {
        {
          if (finishedWork.flags & Snapshot) {
            var root = finishedWork.stateNode;
            clearContainer(root.containerInfo);
          }
        }

        return;
      }

    case HostComponent:
    case HostText:
    case HostPortal:
    case IncompleteClassComponent:
      // Nothing to do for these component types
      return;
  }

  {
    {
      throw Error( "This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue." );
    }
  }
}

function commitHookEffectListUnmount(tag, finishedWork) {
  var updateQueue = finishedWork.updateQueue;
  var lastEffect = updateQueue !== null ? updateQueue.lastEffect : null;

  if (lastEffect !== null) {
    var firstEffect = lastEffect.next;
    var effect = firstEffect;

    do {
      if ((effect.tag & tag) === tag) {
        // Unmount
        var destroy = effect.destroy;
        effect.destroy = undefined;

        if (destroy !== undefined) {
          destroy();
        }
      }

      effect = effect.next;
    } while (effect !== firstEffect);
  }
}

function commitHookEffectListMount(tag, finishedWork) {
  var updateQueue = finishedWork.updateQueue;
  var lastEffect = updateQueue !== null ? updateQueue.lastEffect : null;

  if (lastEffect !== null) {
    var firstEffect = lastEffect.next;
    var effect = firstEffect;

    do {
      if ((effect.tag & tag) === tag) {
        // Mount
        var create = effect.create;
        effect.destroy = create();

        {
          var destroy = effect.destroy;

          if (destroy !== undefined && typeof destroy !== 'function') {
            var addendum = void 0;

            if (destroy === null) {
              addendum = ' You returned null. If your effect does not require clean ' + 'up, return undefined (or nothing).';
            } else if (typeof destroy.then === 'function') {
              addendum = '\n\nIt looks like you wrote useEffect(async () => ...) or returned a Promise. ' + 'Instead, write the async function inside your effect ' + 'and call it immediately:\n\n' + 'useEffect(() => {\n' + '  async function fetchData() {\n' + '    // You can await here\n' + '    const response = await MyAPI.getData(someId);\n' + '    // ...\n' + '  }\n' + '  fetchData();\n' + "}, [someId]); // Or [] if effect doesn't need props or state\n\n" + 'Learn more about data fetching with Hooks: https://reactjs.org/link/hooks-data-fetching';
            } else {
              addendum = ' You returned: ' + destroy;
            }

            error('An effect function must not return anything besides a function, ' + 'which is used for clean-up.%s', addendum);
          }
        }
      }

      effect = effect.next;
    } while (effect !== firstEffect);
  }
}

function schedulePassiveEffects(finishedWork) {
  var updateQueue = finishedWork.updateQueue;
  var lastEffect = updateQueue !== null ? updateQueue.lastEffect : null;

  if (lastEffect !== null) {
    var firstEffect = lastEffect.next;
    var effect = firstEffect;

    do {
      var _effect = effect,
          next = _effect.next,
          tag = _effect.tag;

      if ((tag & Passive$1) !== NoFlags$1 && (tag & HasEffect) !== NoFlags$1) {
        enqueuePendingPassiveHookEffectUnmount(finishedWork, effect);
        enqueuePendingPassiveHookEffectMount(finishedWork, effect);
      }

      effect = next;
    } while (effect !== firstEffect);
  }
}

function commitLifeCycles(finishedRoot, current, finishedWork, committedLanes) {
  switch (finishedWork.tag) {
    case FunctionComponent:
    case ForwardRef:
    case SimpleMemoComponent:
    case Block:
      {
        // At this point layout effects have already been destroyed (during mutation phase).
        // This is done to prevent sibling component effects from interfering with each other,
        // e.g. a destroy function in one component should never override a ref set
        // by a create function in another component during the same commit.
        {
          commitHookEffectListMount(Layout | HasEffect, finishedWork);
        }

        schedulePassiveEffects(finishedWork);
        return;
      }

    case ClassComponent:
      {
        var instance = finishedWork.stateNode;

        if (finishedWork.flags & Update) {
          if (current === null) {
            // We could update instance props and state here,
            // but instead we rely on them being set during last render.
            // TODO: revisit this when we implement resuming.
            {
              if (finishedWork.type === finishedWork.elementType && !didWarnAboutReassigningProps) {
                if (instance.props !== finishedWork.memoizedProps) {
                  error('Expected %s props to match memoized props before ' + 'componentDidMount. ' + 'This might either be because of a bug in React, or because ' + 'a component reassigns its own `this.props`. ' + 'Please file an issue.', getComponentName(finishedWork.type) || 'instance');
                }

                if (instance.state !== finishedWork.memoizedState) {
                  error('Expected %s state to match memoized state before ' + 'componentDidMount. ' + 'This might either be because of a bug in React, or because ' + 'a component reassigns its own `this.state`. ' + 'Please file an issue.', getComponentName(finishedWork.type) || 'instance');
                }
              }
            }

            {
              instance.componentDidMount();
            }
          } else {
            var prevProps = finishedWork.elementType === finishedWork.type ? current.memoizedProps : resolveDefaultProps(finishedWork.type, current.memoizedProps);
            var prevState = current.memoizedState; // We could update instance props and state here,
            // but instead we rely on them being set during last render.
            // TODO: revisit this when we implement resuming.

            {
              if (finishedWork.type === finishedWork.elementType && !didWarnAboutReassigningProps) {
                if (instance.props !== finishedWork.memoizedProps) {
                  error('Expected %s props to match memoized props before ' + 'componentDidUpdate. ' + 'This might either be because of a bug in React, or because ' + 'a component reassigns its own `this.props`. ' + 'Please file an issue.', getComponentName(finishedWork.type) || 'instance');
                }

                if (instance.state !== finishedWork.memoizedState) {
                  error('Expected %s state to match memoized state before ' + 'componentDidUpdate. ' + 'This might either be because of a bug in React, or because ' + 'a component reassigns its own `this.state`. ' + 'Please file an issue.', getComponentName(finishedWork.type) || 'instance');
                }
              }
            }

            {
              instance.componentDidUpdate(prevProps, prevState, instance.__reactInternalSnapshotBeforeUpdate);
            }
          }
        } // TODO: I think this is now always non-null by the time it reaches the
        // commit phase. Consider removing the type check.


        var updateQueue = finishedWork.updateQueue;

        if (updateQueue !== null) {
          {
            if (finishedWork.type === finishedWork.elementType && !didWarnAboutReassigningProps) {
              if (instance.props !== finishedWork.memoizedProps) {
                error('Expected %s props to match memoized props before ' + 'processing the update queue. ' + 'This might either be because of a bug in React, or because ' + 'a component reassigns its own `this.props`. ' + 'Please file an issue.', getComponentName(finishedWork.type) || 'instance');
              }

              if (instance.state !== finishedWork.memoizedState) {
                error('Expected %s state to match memoized state before ' + 'processing the update queue. ' + 'This might either be because of a bug in React, or because ' + 'a component reassigns its own `this.state`. ' + 'Please file an issue.', getComponentName(finishedWork.type) || 'instance');
              }
            }
          } // We could update instance props and state here,
          // but instead we rely on them being set during last render.
          // TODO: revisit this when we implement resuming.


          commitUpdateQueue(finishedWork, updateQueue, instance);
        }

        return;
      }

    case HostRoot:
      {
        // TODO: I think this is now always non-null by the time it reaches the
        // commit phase. Consider removing the type check.
        var _updateQueue = finishedWork.updateQueue;

        if (_updateQueue !== null) {
          var _instance = null;

          if (finishedWork.child !== null) {
            switch (finishedWork.child.tag) {
              case HostComponent:
                _instance = getPublicInstance(finishedWork.child.stateNode);
                break;

              case ClassComponent:
                _instance = finishedWork.child.stateNode;
                break;
            }
          }

          commitUpdateQueue(finishedWork, _updateQueue, _instance);
        }

        return;
      }

    case HostComponent:
      {
        var _instance2 = finishedWork.stateNode; // Renderers may schedule work to be done after host components are mounted
        // (eg DOM renderer may schedule auto-focus for inputs and form controls).
        // These effects should only be committed when components are first mounted,
        // aka when there is no current/alternate.

        if (current === null && finishedWork.flags & Update) {
          var type = finishedWork.type;
          var props = finishedWork.memoizedProps;
          commitMount(_instance2, type, props);
        }

        return;
      }

    case HostText:
      {
        // We have no life-cycles associated with text.
        return;
      }

    case HostPortal:
      {
        // We have no life-cycles associated with portals.
        return;
      }

    case Profiler:
      {
        {
          var _finishedWork$memoize2 = finishedWork.memoizedProps,
              onCommit = _finishedWork$memoize2.onCommit,
              onRender = _finishedWork$memoize2.onRender;
          var effectDuration = finishedWork.stateNode.effectDuration;
          var commitTime = getCommitTime();

          if (typeof onRender === 'function') {
            {
              onRender(finishedWork.memoizedProps.id, current === null ? 'mount' : 'update', finishedWork.actualDuration, finishedWork.treeBaseDuration, finishedWork.actualStartTime, commitTime, finishedRoot.memoizedInteractions);
            }
          }
        }

        return;
      }

    case SuspenseComponent:
      {
        commitSuspenseHydrationCallbacks(finishedRoot, finishedWork);
        return;
      }

    case SuspenseListComponent:
    case IncompleteClassComponent:
    case FundamentalComponent:
    case ScopeComponent:
    case OffscreenComponent:
    case LegacyHiddenComponent:
      return;
  }

  {
    {
      throw Error( "This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue." );
    }
  }
}

function hideOrUnhideAllChildren(finishedWork, isHidden) {
  {
    // We only have the top Fiber that was inserted but we need to recurse down its
    // children to find all the terminal nodes.
    var node = finishedWork;

    while (true) {
      if (node.tag === HostComponent) {
        var instance = node.stateNode;

        if (isHidden) {
          hideInstance(instance);
        } else {
          unhideInstance(node.stateNode, node.memoizedProps);
        }
      } else if (node.tag === HostText) {
        var _instance3 = node.stateNode;

        if (isHidden) {
          hideTextInstance(_instance3);
        } else {
          unhideTextInstance(_instance3, node.memoizedProps);
        }
      } else if ((node.tag === OffscreenComponent || node.tag === LegacyHiddenComponent) && node.memoizedState !== null && node !== finishedWork) ; else if (node.child !== null) {
        node.child.return = node;
        node = node.child;
        continue;
      }

      if (node === finishedWork) {
        return;
      }

      while (node.sibling === null) {
        if (node.return === null || node.return === finishedWork) {
          return;
        }

        node = node.return;
      }

      node.sibling.return = node.return;
      node = node.sibling;
    }
  }
}

function commitAttachRef(finishedWork) {
  var ref = finishedWork.ref;

  if (ref !== null) {
    var instance = finishedWork.stateNode;
    var instanceToUse;

    switch (finishedWork.tag) {
      case HostComponent:
        instanceToUse = getPublicInstance(instance);
        break;

      default:
        instanceToUse = instance;
    } // Moved outside to ensure DCE works with this flag

    if (typeof ref === 'function') {
      ref(instanceToUse);
    } else {
      {
        if (!ref.hasOwnProperty('current')) {
          error('Unexpected ref object provided for %s. ' + 'Use either a ref-setter function or React.createRef().', getComponentName(finishedWork.type));
        }
      }

      ref.current = instanceToUse;
    }
  }
}

function commitDetachRef(current) {
  var currentRef = current.ref;

  if (currentRef !== null) {
    if (typeof currentRef === 'function') {
      currentRef(null);
    } else {
      currentRef.current = null;
    }
  }
} // User-originating errors (lifecycles and refs) should not interrupt
// deletion, so don't let them throw. Host-originating errors should
// interrupt deletion, so it's okay


function commitUnmount(finishedRoot, current, renderPriorityLevel) {
  onCommitUnmount(current);

  switch (current.tag) {
    case FunctionComponent:
    case ForwardRef:
    case MemoComponent:
    case SimpleMemoComponent:
    case Block:
      {
        var updateQueue = current.updateQueue;

        if (updateQueue !== null) {
          var lastEffect = updateQueue.lastEffect;

          if (lastEffect !== null) {
            var firstEffect = lastEffect.next;
            var effect = firstEffect;

            do {
              var _effect2 = effect,
                  destroy = _effect2.destroy,
                  tag = _effect2.tag;

              if (destroy !== undefined) {
                if ((tag & Passive$1) !== NoFlags$1) {
                  enqueuePendingPassiveHookEffectUnmount(current, effect);
                } else {
                  {
                    safelyCallDestroy(current, destroy);
                  }
                }
              }

              effect = effect.next;
            } while (effect !== firstEffect);
          }
        }

        return;
      }

    case ClassComponent:
      {
        safelyDetachRef(current);
        var instance = current.stateNode;

        if (typeof instance.componentWillUnmount === 'function') {
          safelyCallComponentWillUnmount(current, instance);
        }

        return;
      }

    case HostComponent:
      {
        safelyDetachRef(current);
        return;
      }

    case HostPortal:
      {
        // TODO: this is recursive.
        // We are also not using this parent because
        // the portal will get pushed immediately.
        {
          unmountHostComponents(finishedRoot, current);
        }

        return;
      }

    case FundamentalComponent:
      {

        return;
      }

    case DehydratedFragment:
      {

        return;
      }

    case ScopeComponent:
      {

        return;
      }
  }
}

function commitNestedUnmounts(finishedRoot, root, renderPriorityLevel) {
  // While we're inside a removed host node we don't want to call
  // removeChild on the inner nodes because they're removed by the top
  // call anyway. We also want to call componentWillUnmount on all
  // composites before this host node is removed from the tree. Therefore
  // we do an inner loop while we're still inside the host node.
  var node = root;

  while (true) {
    commitUnmount(finishedRoot, node); // Visit children because they may contain more composite or host nodes.
    // Skip portals because commitUnmount() currently visits them recursively.

    if (node.child !== null && ( // If we use mutation we drill down into portals using commitUnmount above.
    // If we don't use mutation we drill down into portals here instead.
     node.tag !== HostPortal)) {
      node.child.return = node;
      node = node.child;
      continue;
    }

    if (node === root) {
      return;
    }

    while (node.sibling === null) {
      if (node.return === null || node.return === root) {
        return;
      }

      node = node.return;
    }

    node.sibling.return = node.return;
    node = node.sibling;
  }
}

function detachFiberMutation(fiber) {
  // Cut off the return pointers to disconnect it from the tree. Ideally, we
  // should clear the child pointer of the parent alternate to let this
  // get GC:ed but we don't know which for sure which parent is the current
  // one so we'll settle for GC:ing the subtree of this child. This child
  // itself will be GC:ed when the parent updates the next time.
  // Note: we cannot null out sibling here, otherwise it can cause issues
  // with findDOMNode and how it requires the sibling field to carry out
  // traversal in a later effect. See PR #16820. We now clear the sibling
  // field after effects, see: detachFiberAfterEffects.
  //
  // Don't disconnect stateNode now; it will be detached in detachFiberAfterEffects.
  // It may be required if the current component is an error boundary,
  // and one of its descendants throws while unmounting a passive effect.
  fiber.alternate = null;
  fiber.child = null;
  fiber.dependencies = null;
  fiber.firstEffect = null;
  fiber.lastEffect = null;
  fiber.memoizedProps = null;
  fiber.memoizedState = null;
  fiber.pendingProps = null;
  fiber.return = null;
  fiber.updateQueue = null;

  {
    fiber._debugOwner = null;
  }
}

function getHostParentFiber(fiber) {
  var parent = fiber.return;

  while (parent !== null) {
    if (isHostParent(parent)) {
      return parent;
    }

    parent = parent.return;
  }

  {
    {
      throw Error( "Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue." );
    }
  }
}

function isHostParent(fiber) {
  return fiber.tag === HostComponent || fiber.tag === HostRoot || fiber.tag === HostPortal;
}

function getHostSibling(fiber) {
  // We're going to search forward into the tree until we find a sibling host
  // node. Unfortunately, if multiple insertions are done in a row we have to
  // search past them. This leads to exponential search for the next sibling.
  // TODO: Find a more efficient way to do this.
  var node = fiber;

  siblings: while (true) {
    // If we didn't find anything, let's try the next sibling.
    while (node.sibling === null) {
      if (node.return === null || isHostParent(node.return)) {
        // If we pop out of the root or hit the parent the fiber we are the
        // last sibling.
        return null;
      }

      node = node.return;
    }

    node.sibling.return = node.return;
    node = node.sibling;

    while (node.tag !== HostComponent && node.tag !== HostText && node.tag !== DehydratedFragment) {
      // If it is not host node and, we might have a host node inside it.
      // Try to search down until we find one.
      if (node.flags & Placement) {
        // If we don't have a child, try the siblings instead.
        continue siblings;
      } // If we don't have a child, try the siblings instead.
      // We also skip portals because they are not part of this host tree.


      if (node.child === null || node.tag === HostPortal) {
        continue siblings;
      } else {
        node.child.return = node;
        node = node.child;
      }
    } // Check if this host node is stable or about to be placed.


    if (!(node.flags & Placement)) {
      // Found it!
      return node.stateNode;
    }
  }
}

function commitPlacement(finishedWork) {


  var parentFiber = getHostParentFiber(finishedWork); // Note: these two variables *must* always be updated together.

  var parent;
  var isContainer;
  var parentStateNode = parentFiber.stateNode;

  switch (parentFiber.tag) {
    case HostComponent:
      parent = parentStateNode;
      isContainer = false;
      break;

    case HostRoot:
      parent = parentStateNode.containerInfo;
      isContainer = true;
      break;

    case HostPortal:
      parent = parentStateNode.containerInfo;
      isContainer = true;
      break;

    case FundamentalComponent:

    // eslint-disable-next-line-no-fallthrough

    default:
      {
        {
          throw Error( "Invalid host parent fiber. This error is likely caused by a bug in React. Please file an issue." );
        }
      }

  }

  if (parentFiber.flags & ContentReset) {
    // Reset the text content of the parent before doing any insertions
    resetTextContent(parent); // Clear ContentReset from the effect tag

    parentFiber.flags &= ~ContentReset;
  }

  var before = getHostSibling(finishedWork); // We only have the top Fiber that was inserted but we need to recurse down its
  // children to find all the terminal nodes.

  if (isContainer) {
    insertOrAppendPlacementNodeIntoContainer(finishedWork, before, parent);
  } else {
    insertOrAppendPlacementNode(finishedWork, before, parent);
  }
}

function insertOrAppendPlacementNodeIntoContainer(node, before, parent) {
  var tag = node.tag;
  var isHost = tag === HostComponent || tag === HostText;

  if (isHost || enableFundamentalAPI ) {
    var stateNode = isHost ? node.stateNode : node.stateNode.instance;

    if (before) {
      insertInContainerBefore(parent, stateNode, before);
    } else {
      appendChildToContainer(parent, stateNode);
    }
  } else if (tag === HostPortal) ; else {
    var child = node.child;

    if (child !== null) {
      insertOrAppendPlacementNodeIntoContainer(child, before, parent);
      var sibling = child.sibling;

      while (sibling !== null) {
        insertOrAppendPlacementNodeIntoContainer(sibling, before, parent);
        sibling = sibling.sibling;
      }
    }
  }
}

function insertOrAppendPlacementNode(node, before, parent) {
  var tag = node.tag;
  var isHost = tag === HostComponent || tag === HostText;

  if (isHost || enableFundamentalAPI ) {
    var stateNode = isHost ? node.stateNode : node.stateNode.instance;

    if (before) {
      insertBefore(parent, stateNode, before);
    } else {
      appendChild(parent, stateNode);
    }
  } else if (tag === HostPortal) ; else {
    var child = node.child;

    if (child !== null) {
      insertOrAppendPlacementNode(child, before, parent);
      var sibling = child.sibling;

      while (sibling !== null) {
        insertOrAppendPlacementNode(sibling, before, parent);
        sibling = sibling.sibling;
      }
    }
  }
}

function unmountHostComponents(finishedRoot, current, renderPriorityLevel) {
  // We only have the top Fiber that was deleted but we need to recurse down its
  // children to find all the terminal nodes.
  var node = current; // Each iteration, currentParent is populated with node's host parent if not
  // currentParentIsValid.

  var currentParentIsValid = false; // Note: these two variables *must* always be updated together.

  var currentParent;
  var currentParentIsContainer;

  while (true) {
    if (!currentParentIsValid) {
      var parent = node.return;

      findParent: while (true) {
        if (!(parent !== null)) {
          {
            throw Error( "Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue." );
          }
        }

        var parentStateNode = parent.stateNode;

        switch (parent.tag) {
          case HostComponent:
            currentParent = parentStateNode;
            currentParentIsContainer = false;
            break findParent;

          case HostRoot:
            currentParent = parentStateNode.containerInfo;
            currentParentIsContainer = true;
            break findParent;

          case HostPortal:
            currentParent = parentStateNode.containerInfo;
            currentParentIsContainer = true;
            break findParent;

        }

        parent = parent.return;
      }

      currentParentIsValid = true;
    }

    if (node.tag === HostComponent || node.tag === HostText) {
      commitNestedUnmounts(finishedRoot, node); // After all the children have unmounted, it is now safe to remove the
      // node from the tree.

      if (currentParentIsContainer) {
        removeChildFromContainer(currentParent, node.stateNode);
      } else {
        removeChild(currentParent, node.stateNode);
      } // Don't visit children because we already visited them.

    } else if (node.tag === HostPortal) {
      if (node.child !== null) {
        // When we go into a portal, it becomes the parent to remove from.
        // We will reassign it back when we pop the portal on the way up.
        currentParent = node.stateNode.containerInfo;
        currentParentIsContainer = true; // Visit children because portals might contain host components.

        node.child.return = node;
        node = node.child;
        continue;
      }
    } else {
      commitUnmount(finishedRoot, node); // Visit children because we may find more host components below.

      if (node.child !== null) {
        node.child.return = node;
        node = node.child;
        continue;
      }
    }

    if (node === current) {
      return;
    }

    while (node.sibling === null) {
      if (node.return === null || node.return === current) {
        return;
      }

      node = node.return;

      if (node.tag === HostPortal) {
        // When we go out of the portal, we need to restore the parent.
        // Since we don't keep a stack of them, we will search for it.
        currentParentIsValid = false;
      }
    }

    node.sibling.return = node.return;
    node = node.sibling;
  }
}

function commitDeletion(finishedRoot, current, renderPriorityLevel) {
  {
    // Recursively delete all host nodes from the parent.
    // Detach refs and call componentWillUnmount() on the whole subtree.
    unmountHostComponents(finishedRoot, current);
  }

  var alternate = current.alternate;
  detachFiberMutation(current);

  if (alternate !== null) {
    detachFiberMutation(alternate);
  }
}

function commitWork(current, finishedWork) {

  switch (finishedWork.tag) {
    case FunctionComponent:
    case ForwardRef:
    case MemoComponent:
    case SimpleMemoComponent:
    case Block:
      {
        // Layout effects are destroyed during the mutation phase so that all
        // destroy functions for all fibers are called before any create functions.
        // This prevents sibling component effects from interfering with each other,
        // e.g. a destroy function in one component should never override a ref set
        // by a create function in another component during the same commit.
        {
          commitHookEffectListUnmount(Layout | HasEffect, finishedWork);
        }

        return;
      }

    case ClassComponent:
      {
        return;
      }

    case HostComponent:
      {
        var instance = finishedWork.stateNode;

        if (instance != null) {
          // Commit the work prepared earlier.
          var newProps = finishedWork.memoizedProps; // For hydration we reuse the update path but we treat the oldProps
          // as the newProps. The updatePayload will contain the real change in
          // this case.

          var oldProps = current !== null ? current.memoizedProps : newProps;
          var type = finishedWork.type; // TODO: Type the updateQueue to be specific to host components.

          var updatePayload = finishedWork.updateQueue;
          finishedWork.updateQueue = null;

          if (updatePayload !== null) {
            commitUpdate(instance, updatePayload, type, oldProps, newProps);
          }
        }

        return;
      }

    case HostText:
      {
        if (!(finishedWork.stateNode !== null)) {
          {
            throw Error( "This should have a text node initialized. This error is likely caused by a bug in React. Please file an issue." );
          }
        }

        var textInstance = finishedWork.stateNode;
        var newText = finishedWork.memoizedProps; // For hydration we reuse the update path but we treat the oldProps
        // as the newProps. The updatePayload will contain the real change in
        // this case.

        var oldText = current !== null ? current.memoizedProps : newText;
        commitTextUpdate(textInstance, oldText, newText);
        return;
      }

    case HostRoot:
      {
        {
          var _root = finishedWork.stateNode;

          if (_root.hydrate) {
            // We've just hydrated. No need to hydrate again.
            _root.hydrate = false;
            commitHydratedContainer(_root.containerInfo);
          }
        }

        return;
      }

    case Profiler:
      {
        return;
      }

    case SuspenseComponent:
      {
        commitSuspenseComponent(finishedWork);
        attachSuspenseRetryListeners(finishedWork);
        return;
      }

    case SuspenseListComponent:
      {
        attachSuspenseRetryListeners(finishedWork);
        return;
      }

    case IncompleteClassComponent:
      {
        return;
      }

    case FundamentalComponent:
      {

        break;
      }

    case ScopeComponent:
      {

        break;
      }

    case OffscreenComponent:
    case LegacyHiddenComponent:
      {
        var newState = finishedWork.memoizedState;
        var isHidden = newState !== null;
        hideOrUnhideAllChildren(finishedWork, isHidden);
        return;
      }
  }

  {
    {
      throw Error( "This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue." );
    }
  }
}

function commitSuspenseComponent(finishedWork) {
  var newState = finishedWork.memoizedState;

  if (newState !== null) {
    markCommitTimeOfFallback();

    {
      // Hide the Offscreen component that contains the primary children. TODO:
      // Ideally, this effect would have been scheduled on the Offscreen fiber
      // itself. That's how unhiding works: the Offscreen component schedules an
      // effect on itself. However, in this case, the component didn't complete,
      // so the fiber was never added to the effect list in the normal path. We
      // could have appended it to the effect list in the Suspense component's
      // second pass, but doing it this way is less complicated. This would be
      // simpler if we got rid of the effect list and traversed the tree, like
      // we're planning to do.
      var primaryChildParent = finishedWork.child;
      hideOrUnhideAllChildren(primaryChildParent, true);
    }
  }
}

function commitSuspenseHydrationCallbacks(finishedRoot, finishedWork) {

  var newState = finishedWork.memoizedState;

  if (newState === null) {
    var current = finishedWork.alternate;

    if (current !== null) {
      var prevState = current.memoizedState;

      if (prevState !== null) {
        var suspenseInstance = prevState.dehydrated;

        if (suspenseInstance !== null) {
          commitHydratedSuspenseInstance(suspenseInstance);
        }
      }
    }
  }
}

function attachSuspenseRetryListeners(finishedWork) {
  // If this boundary just timed out, then it will have a set of wakeables.
  // For each wakeable, attach a listener so that when it resolves, React
  // attempts to re-render the boundary in the primary (pre-timeout) state.
  var wakeables = finishedWork.updateQueue;

  if (wakeables !== null) {
    finishedWork.updateQueue = null;
    var retryCache = finishedWork.stateNode;

    if (retryCache === null) {
      retryCache = finishedWork.stateNode = new PossiblyWeakSet();
    }

    wakeables.forEach(function (wakeable) {
      // Memoize using the boundary fiber to prevent redundant listeners.
      var retry = resolveRetryWakeable.bind(null, finishedWork, wakeable);

      if (!retryCache.has(wakeable)) {
        {
          if (wakeable.__reactDoNotTraceInteractions !== true) {
            retry = tracing.unstable_wrap(retry);
          }
        }

        retryCache.add(wakeable);
        wakeable.then(retry, retry);
      }
    });
  }
} // This function detects when a Suspense boundary goes from visible to hidden.
// It returns false if the boundary is already hidden.
// TODO: Use an effect tag.


function isSuspenseBoundaryBeingHidden(current, finishedWork) {
  if (current !== null) {
    var oldState = current.memoizedState;

    if (oldState === null || oldState.dehydrated !== null) {
      var newState = finishedWork.memoizedState;
      return newState !== null && newState.dehydrated === null;
    }
  }

  return false;
}

function commitResetTextContent(current) {

  resetTextContent(current.stateNode);
}

var COMPONENT_TYPE = 0;
var HAS_PSEUDO_CLASS_TYPE = 1;
var ROLE_TYPE = 2;
var TEST_NAME_TYPE = 3;
var TEXT_TYPE = 4;

if (typeof Symbol === 'function' && Symbol.for) {
  var symbolFor$1 = Symbol.for;
  COMPONENT_TYPE = symbolFor$1('selector.component');
  HAS_PSEUDO_CLASS_TYPE = symbolFor$1('selector.has_pseudo_class');
  ROLE_TYPE = symbolFor$1('selector.role');
  TEST_NAME_TYPE = symbolFor$1('selector.test_id');
  TEXT_TYPE = symbolFor$1('selector.text');
}
var commitHooks = [];
function onCommitRoot$1() {
  {
    commitHooks.forEach(function (commitHook) {
      return commitHook();
    });
  }
}

var ceil = Math.ceil;
var ReactCurrentDispatcher$2 = ReactSharedInternals.ReactCurrentDispatcher,
    ReactCurrentOwner$2 = ReactSharedInternals.ReactCurrentOwner,
    IsSomeRendererActing = ReactSharedInternals.IsSomeRendererActing;
var NoContext =
/*             */
0;
var BatchedContext =
/*               */
1;
var EventContext =
/*                 */
2;
var DiscreteEventContext =
/*         */
4;
var LegacyUnbatchedContext =
/*       */
8;
var RenderContext =
/*                */
16;
var CommitContext =
/*                */
32;
var RetryAfterError =
/*       */
64;
var RootIncomplete = 0;
var RootFatalErrored = 1;
var RootErrored = 2;
var RootSuspended = 3;
var RootSuspendedWithDelay = 4;
var RootCompleted = 5; // Describes where we are in the React execution stack

var executionContext = NoContext; // The root we're working on

var workInProgressRoot = null; // The fiber we're working on

var workInProgress = null; // The lanes we're rendering

var workInProgressRootRenderLanes = NoLanes; // Stack that allows components to change the render lanes for its subtree
// This is a superset of the lanes we started working on at the root. The only
// case where it's different from `workInProgressRootRenderLanes` is when we
// enter a subtree that is hidden and needs to be unhidden: Suspense and
// Offscreen component.
//
// Most things in the work loop should deal with workInProgressRootRenderLanes.
// Most things in begin/complete phases should deal with subtreeRenderLanes.

var subtreeRenderLanes = NoLanes;
var subtreeRenderLanesCursor = createCursor(NoLanes); // Whether to root completed, errored, suspended, etc.

var workInProgressRootExitStatus = RootIncomplete; // A fatal error, if one is thrown

var workInProgressRootFatalError = null; // "Included" lanes refer to lanes that were worked on during this render. It's
// slightly different than `renderLanes` because `renderLanes` can change as you
// enter and exit an Offscreen tree. This value is the combination of all render
// lanes for the entire render phase.

var workInProgressRootIncludedLanes = NoLanes; // The work left over by components that were visited during this render. Only
// includes unprocessed updates, not work in bailed out children.

var workInProgressRootSkippedLanes = NoLanes; // Lanes that were updated (in an interleaved event) during this render.

var workInProgressRootUpdatedLanes = NoLanes; // Lanes that were pinged (in an interleaved event) during this render.

var workInProgressRootPingedLanes = NoLanes;
var mostRecentlyUpdatedRoot = null; // The most recent time we committed a fallback. This lets us ensure a train
// model where we don't commit new loading states in too quick succession.

var globalMostRecentFallbackTime = 0;
var FALLBACK_THROTTLE_MS = 500; // The absolute time for when we should start giving up on rendering
// more and prefer CPU suspense heuristics instead.

var workInProgressRootRenderTargetTime = Infinity; // How long a render is supposed to take before we start following CPU
// suspense heuristics and opt out of rendering more content.

var RENDER_TIMEOUT_MS = 500;

function resetRenderTimer() {
  workInProgressRootRenderTargetTime = now() + RENDER_TIMEOUT_MS;
}

function getRenderTargetTime() {
  return workInProgressRootRenderTargetTime;
}
var nextEffect = null;
var hasUncaughtError = false;
var firstUncaughtError = null;
var legacyErrorBoundariesThatAlreadyFailed = null;
var rootDoesHavePassiveEffects = false;
var rootWithPendingPassiveEffects = null;
var pendingPassiveEffectsRenderPriority = NoPriority$1;
var pendingPassiveEffectsLanes = NoLanes;
var pendingPassiveHookEffectsMount = [];
var pendingPassiveHookEffectsUnmount = [];
var rootsWithPendingDiscreteUpdates = null; // Use these to prevent an infinite loop of nested updates

var NESTED_UPDATE_LIMIT = 50;
var nestedUpdateCount = 0;
var rootWithNestedUpdates = null;
var NESTED_PASSIVE_UPDATE_LIMIT = 50;
var nestedPassiveUpdateCount = 0; // Marks the need to reschedule pending interactions at these lanes
// during the commit phase. This enables them to be traced across components
// that spawn new work during render. E.g. hidden boundaries, suspended SSR
// hydration or SuspenseList.
// TODO: Can use a bitmask instead of an array

var spawnedWorkDuringRender = null; // If two updates are scheduled within the same event, we should treat their
// event times as simultaneous, even if the actual clock time has advanced
// between the first and second call.

var currentEventTime = NoTimestamp;
var currentEventWipLanes = NoLanes;
var currentEventPendingLanes = NoLanes; // Dev only flag that tracks if passive effects are currently being flushed.
// We warn about state updates for unmounted components differently in this case.

var isFlushingPassiveEffects = false;
var focusedInstanceHandle = null;
var shouldFireAfterActiveInstanceBlur = false;
function getWorkInProgressRoot() {
  return workInProgressRoot;
}
function requestEventTime() {
  if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {
    // We're inside React, so it's fine to read the actual time.
    return now();
  } // We're not inside React, so we may be in the middle of a browser event.


  if (currentEventTime !== NoTimestamp) {
    // Use the same start time for all updates until we enter React again.
    return currentEventTime;
  } // This is the first update since React yielded. Compute a new start time.


  currentEventTime = now();
  return currentEventTime;
}
function requestUpdateLane(fiber) {
  // Special cases
  var mode = fiber.mode;

  if ((mode & BlockingMode) === NoMode) {
    return SyncLane;
  } else if ((mode & ConcurrentMode) === NoMode) {
    return getCurrentPriorityLevel() === ImmediatePriority$1 ? SyncLane : SyncBatchedLane;
  } // The algorithm for assigning an update to a lane should be stable for all
  // updates at the same priority within the same event. To do this, the inputs
  // to the algorithm must be the same. For example, we use the `renderLanes`
  // to avoid choosing a lane that is already in the middle of rendering.
  //
  // However, the "included" lanes could be mutated in between updates in the
  // same event, like if you perform an update inside `flushSync`. Or any other
  // code path that might call `prepareFreshStack`.
  //
  // The trick we use is to cache the first of each of these inputs within an
  // event. Then reset the cached values once we can be sure the event is over.
  // Our heuristic for that is whenever we enter a concurrent work loop.
  //
  // We'll do the same for `currentEventPendingLanes` below.


  if (currentEventWipLanes === NoLanes) {
    currentEventWipLanes = workInProgressRootIncludedLanes;
  }

  var isTransition = requestCurrentTransition() !== NoTransition;

  if (isTransition) {
    if (currentEventPendingLanes !== NoLanes) {
      currentEventPendingLanes = mostRecentlyUpdatedRoot !== null ? mostRecentlyUpdatedRoot.pendingLanes : NoLanes;
    }

    return findTransitionLane(currentEventWipLanes, currentEventPendingLanes);
  } // TODO: Remove this dependency on the Scheduler priority.
  // To do that, we're replacing it with an update lane priority.


  var schedulerPriority = getCurrentPriorityLevel(); // The old behavior was using the priority level of the Scheduler.
  // This couples React to the Scheduler internals, so we're replacing it
  // with the currentUpdateLanePriority above. As an example of how this
  // could be problematic, if we're not inside `Scheduler.runWithPriority`,
  // then we'll get the priority of the current running Scheduler task,
  // which is probably not what we want.

  var lane;

  if ( // TODO: Temporary. We're removing the concept of discrete updates.
  (executionContext & DiscreteEventContext) !== NoContext && schedulerPriority === UserBlockingPriority$2) {
    lane = findUpdateLane(InputDiscreteLanePriority, currentEventWipLanes);
  } else {
    var schedulerLanePriority = schedulerPriorityToLanePriority(schedulerPriority);

    lane = findUpdateLane(schedulerLanePriority, currentEventWipLanes);
  }

  return lane;
}

function requestRetryLane(fiber) {
  // This is a fork of `requestUpdateLane` designed specifically for Suspense
  // "retries"  a special update that attempts to flip a Suspense boundary
  // from its placeholder state to its primary/resolved state.
  // Special cases
  var mode = fiber.mode;

  if ((mode & BlockingMode) === NoMode) {
    return SyncLane;
  } else if ((mode & ConcurrentMode) === NoMode) {
    return getCurrentPriorityLevel() === ImmediatePriority$1 ? SyncLane : SyncBatchedLane;
  } // See `requestUpdateLane` for explanation of `currentEventWipLanes`


  if (currentEventWipLanes === NoLanes) {
    currentEventWipLanes = workInProgressRootIncludedLanes;
  }

  return findRetryLane(currentEventWipLanes);
}

function scheduleUpdateOnFiber(fiber, lane, eventTime) {
  checkForNestedUpdates();
  warnAboutRenderPhaseUpdatesInDEV(fiber);
  var root = markUpdateLaneFromFiberToRoot(fiber, lane);

  if (root === null) {
    warnAboutUpdateOnUnmountedFiberInDEV(fiber);
    return null;
  } // Mark that the root has a pending update.


  markRootUpdated(root, lane, eventTime);

  if (root === workInProgressRoot) {
    // Received an update to a tree that's in the middle of rendering. Mark
    // that there was an interleaved update work on this root. Unless the
    // `deferRenderPhaseUpdateToNextBatch` flag is off and this is a render
    // phase update. In that case, we don't treat render phase updates as if
    // they were interleaved, for backwards compat reasons.
    {
      workInProgressRootUpdatedLanes = mergeLanes(workInProgressRootUpdatedLanes, lane);
    }

    if (workInProgressRootExitStatus === RootSuspendedWithDelay) {
      // The root already suspended with a delay, which means this render
      // definitely won't finish. Since we have a new update, let's mark it as
      // suspended now, right before marking the incoming update. This has the
      // effect of interrupting the current render and switching to the update.
      // TODO: Make sure this doesn't override pings that happen while we've
      // already started rendering.
      markRootSuspended$1(root, workInProgressRootRenderLanes);
    }
  } // TODO: requestUpdateLanePriority also reads the priority. Pass the
  // priority as an argument to that function and this one.


  var priorityLevel = getCurrentPriorityLevel();

  if (lane === SyncLane) {
    if ( // Check if we're inside unbatchedUpdates
    (executionContext & LegacyUnbatchedContext) !== NoContext && // Check if we're not already rendering
    (executionContext & (RenderContext | CommitContext)) === NoContext) {
      // Register pending interactions on the root to avoid losing traced interaction data.
      schedulePendingInteractions(root, lane); // This is a legacy edge case. The initial mount of a ReactDOM.render-ed
      // root inside of batchedUpdates should be synchronous, but layout updates
      // should be deferred until the end of the batch.

      performSyncWorkOnRoot(root);
    } else {
      ensureRootIsScheduled(root, eventTime);
      schedulePendingInteractions(root, lane);

      if (executionContext === NoContext) {
        // Flush the synchronous work now, unless we're already working or inside
        // a batch. This is intentionally inside scheduleUpdateOnFiber instead of
        // scheduleCallbackForFiber to preserve the ability to schedule a callback
        // without immediately flushing it. We only do this for user-initiated
        // updates, to preserve historical behavior of legacy mode.
        resetRenderTimer();
        flushSyncCallbackQueue();
      }
    }
  } else {
    // Schedule a discrete update but only if it's not Sync.
    if ((executionContext & DiscreteEventContext) !== NoContext && ( // Only updates at user-blocking priority or greater are considered
    // discrete, even inside a discrete event.
    priorityLevel === UserBlockingPriority$2 || priorityLevel === ImmediatePriority$1)) {
      // This is the result of a discrete event. Track the lowest priority
      // discrete update per root so we can flush them early, if needed.
      if (rootsWithPendingDiscreteUpdates === null) {
        rootsWithPendingDiscreteUpdates = new Set([root]);
      } else {
        rootsWithPendingDiscreteUpdates.add(root);
      }
    } // Schedule other updates after in case the callback is sync.


    ensureRootIsScheduled(root, eventTime);
    schedulePendingInteractions(root, lane);
  } // We use this when assigning a lane for a transition inside
  // `requestUpdateLane`. We assume it's the same as the root being updated,
  // since in the common case of a single root app it probably is. If it's not
  // the same root, then it's not a huge deal, we just might batch more stuff
  // together more than necessary.


  mostRecentlyUpdatedRoot = root;
} // This is split into a separate function so we can mark a fiber with pending
// work without treating it as a typical update that originates from an event;
// e.g. retrying a Suspense boundary isn't an update, but it does schedule work
// on a fiber.

function markUpdateLaneFromFiberToRoot(sourceFiber, lane) {
  // Update the source fiber's lanes
  sourceFiber.lanes = mergeLanes(sourceFiber.lanes, lane);
  var alternate = sourceFiber.alternate;

  if (alternate !== null) {
    alternate.lanes = mergeLanes(alternate.lanes, lane);
  }

  {
    if (alternate === null && (sourceFiber.flags & (Placement | Hydrating)) !== NoFlags) {
      warnAboutUpdateOnNotYetMountedFiberInDEV(sourceFiber);
    }
  } // Walk the parent path to the root and update the child expiration time.


  var node = sourceFiber;
  var parent = sourceFiber.return;

  while (parent !== null) {
    parent.childLanes = mergeLanes(parent.childLanes, lane);
    alternate = parent.alternate;

    if (alternate !== null) {
      alternate.childLanes = mergeLanes(alternate.childLanes, lane);
    } else {
      {
        if ((parent.flags & (Placement | Hydrating)) !== NoFlags) {
          warnAboutUpdateOnNotYetMountedFiberInDEV(sourceFiber);
        }
      }
    }

    node = parent;
    parent = parent.return;
  }

  if (node.tag === HostRoot) {
    var root = node.stateNode;
    return root;
  } else {
    return null;
  }
} // Use this function to schedule a task for a root. There's only one task per
// root; if a task was already scheduled, we'll check to make sure the priority
// of the existing task is the same as the priority of the next level that the
// root has work on. This function is called on every update, and right before
// exiting a task.


function ensureRootIsScheduled(root, currentTime) {
  var existingCallbackNode = root.callbackNode; // Check if any lanes are being starved by other work. If so, mark them as
  // expired so we know to work on those next.

  markStarvedLanesAsExpired(root, currentTime); // Determine the next lanes to work on, and their priority.

  var nextLanes = getNextLanes(root, root === workInProgressRoot ? workInProgressRootRenderLanes : NoLanes); // This returns the priority level computed during the `getNextLanes` call.

  var newCallbackPriority = returnNextLanesPriority();

  if (nextLanes === NoLanes) {
    // Special case: There's nothing to work on.
    if (existingCallbackNode !== null) {
      cancelCallback(existingCallbackNode);
      root.callbackNode = null;
      root.callbackPriority = NoLanePriority;
    }

    return;
  } // Check if there's an existing task. We may be able to reuse it.


  if (existingCallbackNode !== null) {
    var existingCallbackPriority = root.callbackPriority;

    if (existingCallbackPriority === newCallbackPriority) {
      // The priority hasn't changed. We can reuse the existing task. Exit.
      return;
    } // The priority changed. Cancel the existing callback. We'll schedule a new
    // one below.


    cancelCallback(existingCallbackNode);
  } // Schedule a new callback.


  var newCallbackNode;

  if (newCallbackPriority === SyncLanePriority) {
    // Special case: Sync React callbacks are scheduled on a special
    // internal queue
    newCallbackNode = scheduleSyncCallback(performSyncWorkOnRoot.bind(null, root));
  } else if (newCallbackPriority === SyncBatchedLanePriority) {
    newCallbackNode = scheduleCallback(ImmediatePriority$1, performSyncWorkOnRoot.bind(null, root));
  } else {
    var schedulerPriorityLevel = lanePriorityToSchedulerPriority(newCallbackPriority);
    newCallbackNode = scheduleCallback(schedulerPriorityLevel, performConcurrentWorkOnRoot.bind(null, root));
  }

  root.callbackPriority = newCallbackPriority;
  root.callbackNode = newCallbackNode;
} // This is the entry point for every concurrent task, i.e. anything that
// goes through Scheduler.


function performConcurrentWorkOnRoot(root) {
  // Since we know we're in a React event, we can clear the current
  // event time. The next update will compute a new event time.
  currentEventTime = NoTimestamp;
  currentEventWipLanes = NoLanes;
  currentEventPendingLanes = NoLanes;

  if (!((executionContext & (RenderContext | CommitContext)) === NoContext)) {
    {
      throw Error( "Should not already be working." );
    }
  } // Flush any pending passive effects before deciding which lanes to work on,
  // in case they schedule additional work.


  var originalCallbackNode = root.callbackNode;
  var didFlushPassiveEffects = flushPassiveEffects();

  if (didFlushPassiveEffects) {
    // Something in the passive effect phase may have canceled the current task.
    // Check if the task node for this root was changed.
    if (root.callbackNode !== originalCallbackNode) {
      // The current task was canceled. Exit. We don't need to call
      // `ensureRootIsScheduled` because the check above implies either that
      // there's a new task, or that there's no remaining work on this root.
      return null;
    }
  } // Determine the next expiration time to work on, using the fields stored
  // on the root.


  var lanes = getNextLanes(root, root === workInProgressRoot ? workInProgressRootRenderLanes : NoLanes);

  if (lanes === NoLanes) {
    // Defensive coding. This is never expected to happen.
    return null;
  }

  var exitStatus = renderRootConcurrent(root, lanes);

  if (includesSomeLane(workInProgressRootIncludedLanes, workInProgressRootUpdatedLanes)) {
    // The render included lanes that were updated during the render phase.
    // For example, when unhiding a hidden tree, we include all the lanes
    // that were previously skipped when the tree was hidden. That set of
    // lanes is a superset of the lanes we started rendering with.
    //
    // So we'll throw out the current work and restart.
    prepareFreshStack(root, NoLanes);
  } else if (exitStatus !== RootIncomplete) {
    if (exitStatus === RootErrored) {
      executionContext |= RetryAfterError; // If an error occurred during hydration,
      // discard server response and fall back to client side render.

      if (root.hydrate) {
        root.hydrate = false;
        clearContainer(root.containerInfo);
      } // If something threw an error, try rendering one more time. We'll render
      // synchronously to block concurrent data mutations, and we'll includes
      // all pending updates are included. If it still fails after the second
      // attempt, we'll give up and commit the resulting tree.


      lanes = getLanesToRetrySynchronouslyOnError(root);

      if (lanes !== NoLanes) {
        exitStatus = renderRootSync(root, lanes);
      }
    }

    if (exitStatus === RootFatalErrored) {
      var fatalError = workInProgressRootFatalError;
      prepareFreshStack(root, NoLanes);
      markRootSuspended$1(root, lanes);
      ensureRootIsScheduled(root, now());
      throw fatalError;
    } // We now have a consistent tree. The next step is either to commit it,
    // or, if something suspended, wait to commit it after a timeout.


    var finishedWork = root.current.alternate;
    root.finishedWork = finishedWork;
    root.finishedLanes = lanes;
    finishConcurrentRender(root, exitStatus, lanes);
  }

  ensureRootIsScheduled(root, now());

  if (root.callbackNode === originalCallbackNode) {
    // The task node scheduled for this root is the same one that's
    // currently executed. Need to return a continuation.
    return performConcurrentWorkOnRoot.bind(null, root);
  }

  return null;
}

function finishConcurrentRender(root, exitStatus, lanes) {
  switch (exitStatus) {
    case RootIncomplete:
    case RootFatalErrored:
      {
        {
          {
            throw Error( "Root did not complete. This is a bug in React." );
          }
        }
      }
    // Flow knows about invariant, so it complains if I add a break
    // statement, but eslint doesn't know about invariant, so it complains
    // if I do. eslint-disable-next-line no-fallthrough

    case RootErrored:
      {
        // We should have already attempted to retry this tree. If we reached
        // this point, it errored again. Commit it.
        commitRoot(root);
        break;
      }

    case RootSuspended:
      {
        markRootSuspended$1(root, lanes); // We have an acceptable loading state. We need to figure out if we
        // should immediately commit it or wait a bit.

        if (includesOnlyRetries(lanes) && // do not delay if we're inside an act() scope
        !shouldForceFlushFallbacksInDEV()) {
          // This render only included retries, no updates. Throttle committing
          // retries so that we don't show too many loading states too quickly.
          var msUntilTimeout = globalMostRecentFallbackTime + FALLBACK_THROTTLE_MS - now(); // Don't bother with a very short suspense time.

          if (msUntilTimeout > 10) {
            var nextLanes = getNextLanes(root, NoLanes);

            if (nextLanes !== NoLanes) {
              // There's additional work on this root.
              break;
            }

            var suspendedLanes = root.suspendedLanes;

            if (!isSubsetOfLanes(suspendedLanes, lanes)) {
              // We should prefer to render the fallback of at the last
              // suspended level. Ping the last suspended level to try
              // rendering it again.
              // FIXME: What if the suspended lanes are Idle? Should not restart.
              var eventTime = requestEventTime();
              markRootPinged(root, suspendedLanes);
              break;
            } // The render is suspended, it hasn't timed out, and there's no
            // lower priority work to do. Instead of committing the fallback
            // immediately, wait for more data to arrive.


            root.timeoutHandle = scheduleTimeout(commitRoot.bind(null, root), msUntilTimeout);
            break;
          }
        } // The work expired. Commit immediately.


        commitRoot(root);
        break;
      }

    case RootSuspendedWithDelay:
      {
        markRootSuspended$1(root, lanes);

        if (includesOnlyTransitions(lanes)) {
          // This is a transition, so we should exit without committing a
          // placeholder and without scheduling a timeout. Delay indefinitely
          // until we receive more data.
          break;
        }

        if (!shouldForceFlushFallbacksInDEV()) {
          // This is not a transition, but we did trigger an avoided state.
          // Schedule a placeholder to display after a short delay, using the Just
          // Noticeable Difference.
          // TODO: Is the JND optimization worth the added complexity? If this is
          // the only reason we track the event time, then probably not.
          // Consider removing.
          var mostRecentEventTime = getMostRecentEventTime(root, lanes);
          var eventTimeMs = mostRecentEventTime;
          var timeElapsedMs = now() - eventTimeMs;

          var _msUntilTimeout = jnd(timeElapsedMs) - timeElapsedMs; // Don't bother with a very short suspense time.


          if (_msUntilTimeout > 10) {
            // Instead of committing the fallback immediately, wait for more data
            // to arrive.
            root.timeoutHandle = scheduleTimeout(commitRoot.bind(null, root), _msUntilTimeout);
            break;
          }
        } // Commit the placeholder.


        commitRoot(root);
        break;
      }

    case RootCompleted:
      {
        // The work completed. Ready to commit.
        commitRoot(root);
        break;
      }

    default:
      {
        {
          {
            throw Error( "Unknown root exit status." );
          }
        }
      }
  }
}

function markRootSuspended$1(root, suspendedLanes) {
  // When suspending, we should always exclude lanes that were pinged or (more
  // rarely, since we try to avoid it) updated during the render phase.
  // TODO: Lol maybe there's a better way to factor this besides this
  // obnoxiously named function :)
  suspendedLanes = removeLanes(suspendedLanes, workInProgressRootPingedLanes);
  suspendedLanes = removeLanes(suspendedLanes, workInProgressRootUpdatedLanes);
  markRootSuspended(root, suspendedLanes);
} // This is the entry point for synchronous tasks that don't go
// through Scheduler


function performSyncWorkOnRoot(root) {
  if (!((executionContext & (RenderContext | CommitContext)) === NoContext)) {
    {
      throw Error( "Should not already be working." );
    }
  }

  flushPassiveEffects();
  var lanes;
  var exitStatus;

  if (root === workInProgressRoot && includesSomeLane(root.expiredLanes, workInProgressRootRenderLanes)) {
    // There's a partial tree, and at least one of its lanes has expired. Finish
    // rendering it before rendering the rest of the expired work.
    lanes = workInProgressRootRenderLanes;
    exitStatus = renderRootSync(root, lanes);

    if (includesSomeLane(workInProgressRootIncludedLanes, workInProgressRootUpdatedLanes)) {
      // The render included lanes that were updated during the render phase.
      // For example, when unhiding a hidden tree, we include all the lanes
      // that were previously skipped when the tree was hidden. That set of
      // lanes is a superset of the lanes we started rendering with.
      //
      // Note that this only happens when part of the tree is rendered
      // concurrently. If the whole tree is rendered synchronously, then there
      // are no interleaved events.
      lanes = getNextLanes(root, lanes);
      exitStatus = renderRootSync(root, lanes);
    }
  } else {
    lanes = getNextLanes(root, NoLanes);
    exitStatus = renderRootSync(root, lanes);
  }

  if (root.tag !== LegacyRoot && exitStatus === RootErrored) {
    executionContext |= RetryAfterError; // If an error occurred during hydration,
    // discard server response and fall back to client side render.

    if (root.hydrate) {
      root.hydrate = false;
      clearContainer(root.containerInfo);
    } // If something threw an error, try rendering one more time. We'll render
    // synchronously to block concurrent data mutations, and we'll includes
    // all pending updates are included. If it still fails after the second
    // attempt, we'll give up and commit the resulting tree.


    lanes = getLanesToRetrySynchronouslyOnError(root);

    if (lanes !== NoLanes) {
      exitStatus = renderRootSync(root, lanes);
    }
  }

  if (exitStatus === RootFatalErrored) {
    var fatalError = workInProgressRootFatalError;
    prepareFreshStack(root, NoLanes);
    markRootSuspended$1(root, lanes);
    ensureRootIsScheduled(root, now());
    throw fatalError;
  } // We now have a consistent tree. Because this is a sync render, we
  // will commit it even if something suspended.


  var finishedWork = root.current.alternate;
  root.finishedWork = finishedWork;
  root.finishedLanes = lanes;
  commitRoot(root); // Before exiting, make sure there's a callback scheduled for the next
  // pending level.

  ensureRootIsScheduled(root, now());
  return null;
}
function flushDiscreteUpdates() {
  // TODO: Should be able to flush inside batchedUpdates, but not inside `act`.
  // However, `act` uses `batchedUpdates`, so there's no way to distinguish
  // those two cases. Need to fix this before exposing flushDiscreteUpdates
  // as a public API.
  if ((executionContext & (BatchedContext | RenderContext | CommitContext)) !== NoContext) {
    {
      if ((executionContext & RenderContext) !== NoContext) {
        error('unstable_flushDiscreteUpdates: Cannot flush updates when React is ' + 'already rendering.');
      }
    } // We're already rendering, so we can't synchronously flush pending work.
    // This is probably a nested event dispatch triggered by a lifecycle/effect,
    // like `el.focus()`. Exit.


    return;
  }

  flushPendingDiscreteUpdates(); // If the discrete updates scheduled passive effects, flush them now so that
  // they fire before the next serial event.

  flushPassiveEffects();
}

function flushPendingDiscreteUpdates() {
  if (rootsWithPendingDiscreteUpdates !== null) {
    // For each root with pending discrete updates, schedule a callback to
    // immediately flush them.
    var roots = rootsWithPendingDiscreteUpdates;
    rootsWithPendingDiscreteUpdates = null;
    roots.forEach(function (root) {
      markDiscreteUpdatesExpired(root);
      ensureRootIsScheduled(root, now());
    });
  } // Now flush the immediate queue.


  flushSyncCallbackQueue();
}

function batchedUpdates$1(fn, a) {
  var prevExecutionContext = executionContext;
  executionContext |= BatchedContext;

  try {
    return fn(a);
  } finally {
    executionContext = prevExecutionContext;

    if (executionContext === NoContext) {
      // Flush the immediate callbacks that were scheduled during this batch
      resetRenderTimer();
      flushSyncCallbackQueue();
    }
  }
}
function batchedEventUpdates$1(fn, a) {
  var prevExecutionContext = executionContext;
  executionContext |= EventContext;

  try {
    return fn(a);
  } finally {
    executionContext = prevExecutionContext;

    if (executionContext === NoContext) {
      // Flush the immediate callbacks that were scheduled during this batch
      resetRenderTimer();
      flushSyncCallbackQueue();
    }
  }
}
function discreteUpdates$1(fn, a, b, c, d) {
  var prevExecutionContext = executionContext;
  executionContext |= DiscreteEventContext;

  {
    try {
      return runWithPriority$1(UserBlockingPriority$2, fn.bind(null, a, b, c, d));
    } finally {
      executionContext = prevExecutionContext;

      if (executionContext === NoContext) {
        // Flush the immediate callbacks that were scheduled during this batch
        resetRenderTimer();
        flushSyncCallbackQueue();
      }
    }
  }
}
function unbatchedUpdates(fn, a) {
  var prevExecutionContext = executionContext;
  executionContext &= ~BatchedContext;
  executionContext |= LegacyUnbatchedContext;

  try {
    return fn(a);
  } finally {
    executionContext = prevExecutionContext;

    if (executionContext === NoContext) {
      // Flush the immediate callbacks that were scheduled during this batch
      resetRenderTimer();
      flushSyncCallbackQueue();
    }
  }
}
function flushSync(fn, a) {
  var prevExecutionContext = executionContext;

  if ((prevExecutionContext & (RenderContext | CommitContext)) !== NoContext) {
    {
      error('flushSync was called from inside a lifecycle method. React cannot ' + 'flush when React is already rendering. Consider moving this call to ' + 'a scheduler task or micro task.');
    }

    return fn(a);
  }

  executionContext |= BatchedContext;

  {
    try {
      if (fn) {
        return runWithPriority$1(ImmediatePriority$1, fn.bind(null, a));
      } else {
        return undefined;
      }
    } finally {
      executionContext = prevExecutionContext; // Flush the immediate callbacks that were scheduled during this batch.
      // Note that this will happen even if batchedUpdates is higher up
      // the stack.

      flushSyncCallbackQueue();
    }
  }
}
function pushRenderLanes(fiber, lanes) {
  push(subtreeRenderLanesCursor, subtreeRenderLanes, fiber);
  subtreeRenderLanes = mergeLanes(subtreeRenderLanes, lanes);
  workInProgressRootIncludedLanes = mergeLanes(workInProgressRootIncludedLanes, lanes);
}
function popRenderLanes(fiber) {
  subtreeRenderLanes = subtreeRenderLanesCursor.current;
  pop(subtreeRenderLanesCursor, fiber);
}

function prepareFreshStack(root, lanes) {
  root.finishedWork = null;
  root.finishedLanes = NoLanes;
  var timeoutHandle = root.timeoutHandle;

  if (timeoutHandle !== noTimeout) {
    // The root previous suspended and scheduled a timeout to commit a fallback
    // state. Now that we have additional work, cancel the timeout.
    root.timeoutHandle = noTimeout; // $FlowFixMe Complains noTimeout is not a TimeoutID, despite the check above

    cancelTimeout(timeoutHandle);
  }

  if (workInProgress !== null) {
    var interruptedWork = workInProgress.return;

    while (interruptedWork !== null) {
      unwindInterruptedWork(interruptedWork);
      interruptedWork = interruptedWork.return;
    }
  }

  workInProgressRoot = root;
  workInProgress = createWorkInProgress(root.current, null);
  workInProgressRootRenderLanes = subtreeRenderLanes = workInProgressRootIncludedLanes = lanes;
  workInProgressRootExitStatus = RootIncomplete;
  workInProgressRootFatalError = null;
  workInProgressRootSkippedLanes = NoLanes;
  workInProgressRootUpdatedLanes = NoLanes;
  workInProgressRootPingedLanes = NoLanes;

  {
    spawnedWorkDuringRender = null;
  }

  {
    ReactStrictModeWarnings.discardPendingWarnings();
  }
}

function handleError(root, thrownValue) {
  do {
    var erroredWork = workInProgress;

    try {
      // Reset module-level state that was set during the render phase.
      resetContextDependencies();
      resetHooksAfterThrow();
      resetCurrentFiber(); // TODO: I found and added this missing line while investigating a
      // separate issue. Write a regression test using string refs.

      ReactCurrentOwner$2.current = null;

      if (erroredWork === null || erroredWork.return === null) {
        // Expected to be working on a non-root fiber. This is a fatal error
        // because there's no ancestor that can handle it; the root is
        // supposed to capture all errors that weren't caught by an error
        // boundary.
        workInProgressRootExitStatus = RootFatalErrored;
        workInProgressRootFatalError = thrownValue; // Set `workInProgress` to null. This represents advancing to the next
        // sibling, or the parent if there are no siblings. But since the root
        // has no siblings nor a parent, we set it to null. Usually this is
        // handled by `completeUnitOfWork` or `unwindWork`, but since we're
        // intentionally not calling those, we need set it here.
        // TODO: Consider calling `unwindWork` to pop the contexts.

        workInProgress = null;
        return;
      }

      if (enableProfilerTimer && erroredWork.mode & ProfileMode) {
        // Record the time spent rendering before an error was thrown. This
        // avoids inaccurate Profiler durations in the case of a
        // suspended render.
        stopProfilerTimerIfRunningAndRecordDelta(erroredWork, true);
      }

      throwException(root, erroredWork.return, erroredWork, thrownValue, workInProgressRootRenderLanes);
      completeUnitOfWork(erroredWork);
    } catch (yetAnotherThrownValue) {
      // Something in the return path also threw.
      thrownValue = yetAnotherThrownValue;

      if (workInProgress === erroredWork && erroredWork !== null) {
        // If this boundary has already errored, then we had trouble processing
        // the error. Bubble it to the next boundary.
        erroredWork = erroredWork.return;
        workInProgress = erroredWork;
      } else {
        erroredWork = workInProgress;
      }

      continue;
    } // Return to the normal work loop.


    return;
  } while (true);
}

function pushDispatcher() {
  var prevDispatcher = ReactCurrentDispatcher$2.current;
  ReactCurrentDispatcher$2.current = ContextOnlyDispatcher;

  if (prevDispatcher === null) {
    // The React isomorphic package does not include a default dispatcher.
    // Instead the first renderer will lazily attach one, in order to give
    // nicer error messages.
    return ContextOnlyDispatcher;
  } else {
    return prevDispatcher;
  }
}

function popDispatcher(prevDispatcher) {
  ReactCurrentDispatcher$2.current = prevDispatcher;
}

function pushInteractions(root) {
  {
    var prevInteractions = tracing.__interactionsRef.current;
    tracing.__interactionsRef.current = root.memoizedInteractions;
    return prevInteractions;
  }
}

function popInteractions(prevInteractions) {
  {
    tracing.__interactionsRef.current = prevInteractions;
  }
}

function markCommitTimeOfFallback() {
  globalMostRecentFallbackTime = now();
}
function markSkippedUpdateLanes(lane) {
  workInProgressRootSkippedLanes = mergeLanes(lane, workInProgressRootSkippedLanes);
}
function renderDidSuspend() {
  if (workInProgressRootExitStatus === RootIncomplete) {
    workInProgressRootExitStatus = RootSuspended;
  }
}
function renderDidSuspendDelayIfPossible() {
  if (workInProgressRootExitStatus === RootIncomplete || workInProgressRootExitStatus === RootSuspended) {
    workInProgressRootExitStatus = RootSuspendedWithDelay;
  } // Check if there are updates that we skipped tree that might have unblocked
  // this render.


  if (workInProgressRoot !== null && (includesNonIdleWork(workInProgressRootSkippedLanes) || includesNonIdleWork(workInProgressRootUpdatedLanes))) {
    // Mark the current render as suspended so that we switch to working on
    // the updates that were skipped. Usually we only suspend at the end of
    // the render phase.
    // TODO: We should probably always mark the root as suspended immediately
    // (inside this function), since by suspending at the end of the render
    // phase introduces a potential mistake where we suspend lanes that were
    // pinged or updated while we were rendering.
    markRootSuspended$1(workInProgressRoot, workInProgressRootRenderLanes);
  }
}
function renderDidError() {
  if (workInProgressRootExitStatus !== RootCompleted) {
    workInProgressRootExitStatus = RootErrored;
  }
} // Called during render to determine if anything has suspended.
// Returns false if we're not sure.

function renderHasNotSuspendedYet() {
  // If something errored or completed, we can't really be sure,
  // so those are false.
  return workInProgressRootExitStatus === RootIncomplete;
}

function renderRootSync(root, lanes) {
  var prevExecutionContext = executionContext;
  executionContext |= RenderContext;
  var prevDispatcher = pushDispatcher(); // If the root or lanes have changed, throw out the existing stack
  // and prepare a fresh one. Otherwise we'll continue where we left off.

  if (workInProgressRoot !== root || workInProgressRootRenderLanes !== lanes) {
    prepareFreshStack(root, lanes);
    startWorkOnPendingInteractions(root, lanes);
  }

  var prevInteractions = pushInteractions(root);

  do {
    try {
      workLoopSync();
      break;
    } catch (thrownValue) {
      handleError(root, thrownValue);
    }
  } while (true);

  resetContextDependencies();

  {
    popInteractions(prevInteractions);
  }

  executionContext = prevExecutionContext;
  popDispatcher(prevDispatcher);

  if (workInProgress !== null) {
    // This is a sync render, so we should have finished the whole tree.
    {
      {
        throw Error( "Cannot commit an incomplete root. This error is likely caused by a bug in React. Please file an issue." );
      }
    }
  }


  workInProgressRoot = null;
  workInProgressRootRenderLanes = NoLanes;
  return workInProgressRootExitStatus;
} // The work loop is an extremely hot path. Tell Closure not to inline it.

/** @noinline */


function workLoopSync() {
  // Already timed out, so perform work without checking if we need to yield.
  while (workInProgress !== null) {
    performUnitOfWork(workInProgress);
  }
}

function renderRootConcurrent(root, lanes) {
  var prevExecutionContext = executionContext;
  executionContext |= RenderContext;
  var prevDispatcher = pushDispatcher(); // If the root or lanes have changed, throw out the existing stack
  // and prepare a fresh one. Otherwise we'll continue where we left off.

  if (workInProgressRoot !== root || workInProgressRootRenderLanes !== lanes) {
    resetRenderTimer();
    prepareFreshStack(root, lanes);
    startWorkOnPendingInteractions(root, lanes);
  }

  var prevInteractions = pushInteractions(root);

  do {
    try {
      workLoopConcurrent();
      break;
    } catch (thrownValue) {
      handleError(root, thrownValue);
    }
  } while (true);

  resetContextDependencies();

  {
    popInteractions(prevInteractions);
  }

  popDispatcher(prevDispatcher);
  executionContext = prevExecutionContext;


  if (workInProgress !== null) {

    return RootIncomplete;
  } else {


    workInProgressRoot = null;
    workInProgressRootRenderLanes = NoLanes; // Return the final exit status.

    return workInProgressRootExitStatus;
  }
}
/** @noinline */


function workLoopConcurrent() {
  // Perform work until Scheduler asks us to yield
  while (workInProgress !== null && !shouldYield()) {
    performUnitOfWork(workInProgress);
  }
}

function performUnitOfWork(unitOfWork) {
  // The current, flushed, state of this fiber is the alternate. Ideally
  // nothing should rely on this, but relying on it here means that we don't
  // need an additional field on the work in progress.
  var current = unitOfWork.alternate;
  setCurrentFiber(unitOfWork);
  var next;

  if ( (unitOfWork.mode & ProfileMode) !== NoMode) {
    startProfilerTimer(unitOfWork);
    next = beginWork$1(current, unitOfWork, subtreeRenderLanes);
    stopProfilerTimerIfRunningAndRecordDelta(unitOfWork, true);
  } else {
    next = beginWork$1(current, unitOfWork, subtreeRenderLanes);
  }

  resetCurrentFiber();
  unitOfWork.memoizedProps = unitOfWork.pendingProps;

  if (next === null) {
    // If this doesn't spawn new work, complete the current work.
    completeUnitOfWork(unitOfWork);
  } else {
    workInProgress = next;
  }

  ReactCurrentOwner$2.current = null;
}

function completeUnitOfWork(unitOfWork) {
  // Attempt to complete the current unit of work, then move to the next
  // sibling. If there are no more siblings, return to the parent fiber.
  var completedWork = unitOfWork;

  do {
    // The current, flushed, state of this fiber is the alternate. Ideally
    // nothing should rely on this, but relying on it here means that we don't
    // need an additional field on the work in progress.
    var current = completedWork.alternate;
    var returnFiber = completedWork.return; // Check if the work completed or if something threw.

    if ((completedWork.flags & Incomplete) === NoFlags) {
      setCurrentFiber(completedWork);
      var next = void 0;

      if ( (completedWork.mode & ProfileMode) === NoMode) {
        next = completeWork(current, completedWork, subtreeRenderLanes);
      } else {
        startProfilerTimer(completedWork);
        next = completeWork(current, completedWork, subtreeRenderLanes); // Update render duration assuming we didn't error.

        stopProfilerTimerIfRunningAndRecordDelta(completedWork, false);
      }

      resetCurrentFiber();

      if (next !== null) {
        // Completing this fiber spawned new work. Work on that next.
        workInProgress = next;
        return;
      }

      resetChildLanes(completedWork);

      if (returnFiber !== null && // Do not append effects to parents if a sibling failed to complete
      (returnFiber.flags & Incomplete) === NoFlags) {
        // Append all the effects of the subtree and this fiber onto the effect
        // list of the parent. The completion order of the children affects the
        // side-effect order.
        if (returnFiber.firstEffect === null) {
          returnFiber.firstEffect = completedWork.firstEffect;
        }

        if (completedWork.lastEffect !== null) {
          if (returnFiber.lastEffect !== null) {
            returnFiber.lastEffect.nextEffect = completedWork.firstEffect;
          }

          returnFiber.lastEffect = completedWork.lastEffect;
        } // If this fiber had side-effects, we append it AFTER the children's
        // side-effects. We can perform certain side-effects earlier if needed,
        // by doing multiple passes over the effect list. We don't want to
        // schedule our own side-effect on our own list because if end up
        // reusing children we'll schedule this effect onto itself since we're
        // at the end.


        var flags = completedWork.flags; // Skip both NoWork and PerformedWork tags when creating the effect
        // list. PerformedWork effect is read by React DevTools but shouldn't be
        // committed.

        if (flags > PerformedWork) {
          if (returnFiber.lastEffect !== null) {
            returnFiber.lastEffect.nextEffect = completedWork;
          } else {
            returnFiber.firstEffect = completedWork;
          }

          returnFiber.lastEffect = completedWork;
        }
      }
    } else {
      // This fiber did not complete because something threw. Pop values off
      // the stack without entering the complete phase. If this is a boundary,
      // capture values if possible.
      var _next = unwindWork(completedWork); // Because this fiber did not complete, don't reset its expiration time.


      if (_next !== null) {
        // If completing this work spawned new work, do that next. We'll come
        // back here again.
        // Since we're restarting, remove anything that is not a host effect
        // from the effect tag.
        _next.flags &= HostEffectMask;
        workInProgress = _next;
        return;
      }

      if ( (completedWork.mode & ProfileMode) !== NoMode) {
        // Record the render duration for the fiber that errored.
        stopProfilerTimerIfRunningAndRecordDelta(completedWork, false); // Include the time spent working on failed children before continuing.

        var actualDuration = completedWork.actualDuration;
        var child = completedWork.child;

        while (child !== null) {
          actualDuration += child.actualDuration;
          child = child.sibling;
        }

        completedWork.actualDuration = actualDuration;
      }

      if (returnFiber !== null) {
        // Mark the parent fiber as incomplete and clear its effect list.
        returnFiber.firstEffect = returnFiber.lastEffect = null;
        returnFiber.flags |= Incomplete;
      }
    }

    var siblingFiber = completedWork.sibling;

    if (siblingFiber !== null) {
      // If there is more work to do in this returnFiber, do that next.
      workInProgress = siblingFiber;
      return;
    } // Otherwise, return to the parent


    completedWork = returnFiber; // Update the next thing we're working on in case something throws.

    workInProgress = completedWork;
  } while (completedWork !== null); // We've reached the root.


  if (workInProgressRootExitStatus === RootIncomplete) {
    workInProgressRootExitStatus = RootCompleted;
  }
}

function resetChildLanes(completedWork) {
  if ( // TODO: Move this check out of the hot path by moving `resetChildLanes`
  // to switch statement in `completeWork`.
  (completedWork.tag === LegacyHiddenComponent || completedWork.tag === OffscreenComponent) && completedWork.memoizedState !== null && !includesSomeLane(subtreeRenderLanes, OffscreenLane) && (completedWork.mode & ConcurrentMode) !== NoLanes) {
    // The children of this component are hidden. Don't bubble their
    // expiration times.
    return;
  }

  var newChildLanes = NoLanes; // Bubble up the earliest expiration time.

  if ( (completedWork.mode & ProfileMode) !== NoMode) {
    // In profiling mode, resetChildExpirationTime is also used to reset
    // profiler durations.
    var actualDuration = completedWork.actualDuration;
    var treeBaseDuration = completedWork.selfBaseDuration; // When a fiber is cloned, its actualDuration is reset to 0. This value will
    // only be updated if work is done on the fiber (i.e. it doesn't bailout).
    // When work is done, it should bubble to the parent's actualDuration. If
    // the fiber has not been cloned though, (meaning no work was done), then
    // this value will reflect the amount of time spent working on a previous
    // render. In that case it should not bubble. We determine whether it was
    // cloned by comparing the child pointer.

    var shouldBubbleActualDurations = completedWork.alternate === null || completedWork.child !== completedWork.alternate.child;
    var child = completedWork.child;

    while (child !== null) {
      newChildLanes = mergeLanes(newChildLanes, mergeLanes(child.lanes, child.childLanes));

      if (shouldBubbleActualDurations) {
        actualDuration += child.actualDuration;
      }

      treeBaseDuration += child.treeBaseDuration;
      child = child.sibling;
    }

    var isTimedOutSuspense = completedWork.tag === SuspenseComponent && completedWork.memoizedState !== null;

    if (isTimedOutSuspense) {
      // Don't count time spent in a timed out Suspense subtree as part of the base duration.
      var primaryChildFragment = completedWork.child;

      if (primaryChildFragment !== null) {
        treeBaseDuration -= primaryChildFragment.treeBaseDuration;
      }
    }

    completedWork.actualDuration = actualDuration;
    completedWork.treeBaseDuration = treeBaseDuration;
  } else {
    var _child = completedWork.child;

    while (_child !== null) {
      newChildLanes = mergeLanes(newChildLanes, mergeLanes(_child.lanes, _child.childLanes));
      _child = _child.sibling;
    }
  }

  completedWork.childLanes = newChildLanes;
}

function commitRoot(root) {
  var renderPriorityLevel = getCurrentPriorityLevel();
  runWithPriority$1(ImmediatePriority$1, commitRootImpl.bind(null, root, renderPriorityLevel));
  return null;
}

function commitRootImpl(root, renderPriorityLevel) {
  do {
    // `flushPassiveEffects` will call `flushSyncUpdateQueue` at the end, which
    // means `flushPassiveEffects` will sometimes result in additional
    // passive effects. So we need to keep flushing in a loop until there are
    // no more pending effects.
    // TODO: Might be better if `flushPassiveEffects` did not automatically
    // flush synchronous work at the end, to avoid factoring hazards like this.
    flushPassiveEffects();
  } while (rootWithPendingPassiveEffects !== null);

  flushRenderPhaseStrictModeWarningsInDEV();

  if (!((executionContext & (RenderContext | CommitContext)) === NoContext)) {
    {
      throw Error( "Should not already be working." );
    }
  }

  var finishedWork = root.finishedWork;
  var lanes = root.finishedLanes;

  if (finishedWork === null) {

    return null;
  }

  root.finishedWork = null;
  root.finishedLanes = NoLanes;

  if (!(finishedWork !== root.current)) {
    {
      throw Error( "Cannot commit the same tree as before. This error is likely caused by a bug in React. Please file an issue." );
    }
  } // commitRoot never returns a continuation; it always finishes synchronously.
  // So we can clear these now to allow a new callback to be scheduled.


  root.callbackNode = null; // Update the first and last pending times on this root. The new first
  // pending time is whatever is left on the root fiber.

  var remainingLanes = mergeLanes(finishedWork.lanes, finishedWork.childLanes);
  markRootFinished(root, remainingLanes); // Clear already finished discrete updates in case that a later call of
  // `flushDiscreteUpdates` starts a useless render pass which may cancels
  // a scheduled timeout.

  if (rootsWithPendingDiscreteUpdates !== null) {
    if (!hasDiscreteLanes(remainingLanes) && rootsWithPendingDiscreteUpdates.has(root)) {
      rootsWithPendingDiscreteUpdates.delete(root);
    }
  }

  if (root === workInProgressRoot) {
    // We can reset these now that they are finished.
    workInProgressRoot = null;
    workInProgress = null;
    workInProgressRootRenderLanes = NoLanes;
  } // Get the list of effects.


  var firstEffect;

  if (finishedWork.flags > PerformedWork) {
    // A fiber's effect list consists only of its children, not itself. So if
    // the root has an effect, we need to add it to the end of the list. The
    // resulting list is the set that would belong to the root's parent, if it
    // had one; that is, all the effects in the tree including the root.
    if (finishedWork.lastEffect !== null) {
      finishedWork.lastEffect.nextEffect = finishedWork;
      firstEffect = finishedWork.firstEffect;
    } else {
      firstEffect = finishedWork;
    }
  } else {
    // There is no effect on the root.
    firstEffect = finishedWork.firstEffect;
  }

  if (firstEffect !== null) {

    var prevExecutionContext = executionContext;
    executionContext |= CommitContext;
    var prevInteractions = pushInteractions(root); // Reset this to null before calling lifecycles

    ReactCurrentOwner$2.current = null; // The commit phase is broken into several sub-phases. We do a separate pass
    // of the effect list for each phase: all mutation effects come before all
    // layout effects, and so on.
    // The first phase a "before mutation" phase. We use this phase to read the
    // state of the host tree right before we mutate it. This is where
    // getSnapshotBeforeUpdate is called.

    focusedInstanceHandle = prepareForCommit(root.containerInfo);
    shouldFireAfterActiveInstanceBlur = false;
    nextEffect = firstEffect;

    do {
      {
        invokeGuardedCallback(null, commitBeforeMutationEffects, null);

        if (hasCaughtError()) {
          if (!(nextEffect !== null)) {
            {
              throw Error( "Should be working on an effect." );
            }
          }

          var error = clearCaughtError();
          captureCommitPhaseError(nextEffect, error);
          nextEffect = nextEffect.nextEffect;
        }
      }
    } while (nextEffect !== null); // We no longer need to track the active instance fiber


    focusedInstanceHandle = null;

    {
      // Mark the current commit time to be shared by all Profilers in this
      // batch. This enables them to be grouped later.
      recordCommitTime();
    } // The next phase is the mutation phase, where we mutate the host tree.


    nextEffect = firstEffect;

    do {
      {
        invokeGuardedCallback(null, commitMutationEffects, null, root, renderPriorityLevel);

        if (hasCaughtError()) {
          if (!(nextEffect !== null)) {
            {
              throw Error( "Should be working on an effect." );
            }
          }

          var _error = clearCaughtError();

          captureCommitPhaseError(nextEffect, _error);
          nextEffect = nextEffect.nextEffect;
        }
      }
    } while (nextEffect !== null);

    resetAfterCommit(root.containerInfo); // The work-in-progress tree is now the current tree. This must come after
    // the mutation phase, so that the previous tree is still current during
    // componentWillUnmount, but before the layout phase, so that the finished
    // work is current during componentDidMount/Update.

    root.current = finishedWork; // The next phase is the layout phase, where we call effects that read
    // the host tree after it's been mutated. The idiomatic use case for this is
    // layout, but class component lifecycles also fire here for legacy reasons.

    nextEffect = firstEffect;

    do {
      {
        invokeGuardedCallback(null, commitLayoutEffects, null, root, lanes);

        if (hasCaughtError()) {
          if (!(nextEffect !== null)) {
            {
              throw Error( "Should be working on an effect." );
            }
          }

          var _error2 = clearCaughtError();

          captureCommitPhaseError(nextEffect, _error2);
          nextEffect = nextEffect.nextEffect;
        }
      }
    } while (nextEffect !== null);

    nextEffect = null; // Tell Scheduler to yield at the end of the frame, so the browser has an
    // opportunity to paint.

    requestPaint();

    {
      popInteractions(prevInteractions);
    }

    executionContext = prevExecutionContext;
  } else {
    // No effects.
    root.current = finishedWork; // Measure these anyway so the flamegraph explicitly shows that there were
    // no effects.
    // TODO: Maybe there's a better way to report this.

    {
      recordCommitTime();
    }
  }

  var rootDidHavePassiveEffects = rootDoesHavePassiveEffects;

  if (rootDoesHavePassiveEffects) {
    // This commit has passive effects. Stash a reference to them. But don't
    // schedule a callback until after flushing layout work.
    rootDoesHavePassiveEffects = false;
    rootWithPendingPassiveEffects = root;
    pendingPassiveEffectsLanes = lanes;
    pendingPassiveEffectsRenderPriority = renderPriorityLevel;
  } else {
    // We are done with the effect chain at this point so let's clear the
    // nextEffect pointers to assist with GC. If we have passive effects, we'll
    // clear this in flushPassiveEffects.
    nextEffect = firstEffect;

    while (nextEffect !== null) {
      var nextNextEffect = nextEffect.nextEffect;
      nextEffect.nextEffect = null;

      if (nextEffect.flags & Deletion) {
        detachFiberAfterEffects(nextEffect);
      }

      nextEffect = nextNextEffect;
    }
  } // Read this again, since an effect might have updated it


  remainingLanes = root.pendingLanes; // Check if there's remaining work on this root

  if (remainingLanes !== NoLanes) {
    {
      if (spawnedWorkDuringRender !== null) {
        var expirationTimes = spawnedWorkDuringRender;
        spawnedWorkDuringRender = null;

        for (var i = 0; i < expirationTimes.length; i++) {
          scheduleInteractions(root, expirationTimes[i], root.memoizedInteractions);
        }
      }

      schedulePendingInteractions(root, remainingLanes);
    }
  } else {
    // If there's no remaining work, we can clear the set of already failed
    // error boundaries.
    legacyErrorBoundariesThatAlreadyFailed = null;
  }

  {
    if (!rootDidHavePassiveEffects) {
      // If there are no passive effects, then we can complete the pending interactions.
      // Otherwise, we'll wait until after the passive effects are flushed.
      // Wait to do this until after remaining work has been scheduled,
      // so that we don't prematurely signal complete for interactions when there's e.g. hidden work.
      finishPendingInteractions(root, lanes);
    }
  }

  if (remainingLanes === SyncLane) {
    // Count the number of times the root synchronously re-renders without
    // finishing. If there are too many, it indicates an infinite update loop.
    if (root === rootWithNestedUpdates) {
      nestedUpdateCount++;
    } else {
      nestedUpdateCount = 0;
      rootWithNestedUpdates = root;
    }
  } else {
    nestedUpdateCount = 0;
  }

  onCommitRoot(finishedWork.stateNode, renderPriorityLevel);

  {
    onCommitRoot$1();
  } // Always call this before exiting `commitRoot`, to ensure that any
  // additional work on this root is scheduled.


  ensureRootIsScheduled(root, now());

  if (hasUncaughtError) {
    hasUncaughtError = false;
    var _error3 = firstUncaughtError;
    firstUncaughtError = null;
    throw _error3;
  }

  if ((executionContext & LegacyUnbatchedContext) !== NoContext) {
    // a ReactDOM.render-ed root inside of batchedUpdates. The commit fired
    // synchronously, but layout updates should be deferred until the end
    // of the batch.


    return null;
  } // If layout work was scheduled, flush it now.


  flushSyncCallbackQueue();

  return null;
}

function commitBeforeMutationEffects() {
  while (nextEffect !== null) {
    var current = nextEffect.alternate;

    if (!shouldFireAfterActiveInstanceBlur && focusedInstanceHandle !== null) {
      if ((nextEffect.flags & Deletion) !== NoFlags) {
        if (doesFiberContain(nextEffect, focusedInstanceHandle)) {
          shouldFireAfterActiveInstanceBlur = true;
        }
      } else {
        // TODO: Move this out of the hot path using a dedicated effect tag.
        if (nextEffect.tag === SuspenseComponent && isSuspenseBoundaryBeingHidden(current, nextEffect) && doesFiberContain(nextEffect, focusedInstanceHandle)) {
          shouldFireAfterActiveInstanceBlur = true;
        }
      }
    }

    var flags = nextEffect.flags;

    if ((flags & Snapshot) !== NoFlags) {
      setCurrentFiber(nextEffect);
      commitBeforeMutationLifeCycles(current, nextEffect);
      resetCurrentFiber();
    }

    if ((flags & Passive) !== NoFlags) {
      // If there are passive effects, schedule a callback to flush at
      // the earliest opportunity.
      if (!rootDoesHavePassiveEffects) {
        rootDoesHavePassiveEffects = true;
        scheduleCallback(NormalPriority$1, function () {
          flushPassiveEffects();
          return null;
        });
      }
    }

    nextEffect = nextEffect.nextEffect;
  }
}

function commitMutationEffects(root, renderPriorityLevel) {
  // TODO: Should probably move the bulk of this function to commitWork.
  while (nextEffect !== null) {
    setCurrentFiber(nextEffect);
    var flags = nextEffect.flags;

    if (flags & ContentReset) {
      commitResetTextContent(nextEffect);
    }

    if (flags & Ref) {
      var current = nextEffect.alternate;

      if (current !== null) {
        commitDetachRef(current);
      }
    } // The following switch statement is only concerned about placement,
    // updates, and deletions. To avoid needing to add a case for every possible
    // bitmap value, we remove the secondary effects from the effect tag and
    // switch on that value.


    var primaryFlags = flags & (Placement | Update | Deletion | Hydrating);

    switch (primaryFlags) {
      case Placement:
        {
          commitPlacement(nextEffect); // Clear the "placement" from effect tag so that we know that this is
          // inserted, before any life-cycles like componentDidMount gets called.
          // TODO: findDOMNode doesn't rely on this any more but isMounted does
          // and isMounted is deprecated anyway so we should be able to kill this.

          nextEffect.flags &= ~Placement;
          break;
        }

      case PlacementAndUpdate:
        {
          // Placement
          commitPlacement(nextEffect); // Clear the "placement" from effect tag so that we know that this is
          // inserted, before any life-cycles like componentDidMount gets called.

          nextEffect.flags &= ~Placement; // Update

          var _current = nextEffect.alternate;
          commitWork(_current, nextEffect);
          break;
        }

      case Hydrating:
        {
          nextEffect.flags &= ~Hydrating;
          break;
        }

      case HydratingAndUpdate:
        {
          nextEffect.flags &= ~Hydrating; // Update

          var _current2 = nextEffect.alternate;
          commitWork(_current2, nextEffect);
          break;
        }

      case Update:
        {
          var _current3 = nextEffect.alternate;
          commitWork(_current3, nextEffect);
          break;
        }

      case Deletion:
        {
          commitDeletion(root, nextEffect);
          break;
        }
    }

    resetCurrentFiber();
    nextEffect = nextEffect.nextEffect;
  }
}

function commitLayoutEffects(root, committedLanes) {


  while (nextEffect !== null) {
    setCurrentFiber(nextEffect);
    var flags = nextEffect.flags;

    if (flags & (Update | Callback)) {
      var current = nextEffect.alternate;
      commitLifeCycles(root, current, nextEffect);
    }

    {
      if (flags & Ref) {
        commitAttachRef(nextEffect);
      }
    }

    resetCurrentFiber();
    nextEffect = nextEffect.nextEffect;
  }
}

function flushPassiveEffects() {
  // Returns whether passive effects were flushed.
  if (pendingPassiveEffectsRenderPriority !== NoPriority$1) {
    var priorityLevel = pendingPassiveEffectsRenderPriority > NormalPriority$1 ? NormalPriority$1 : pendingPassiveEffectsRenderPriority;
    pendingPassiveEffectsRenderPriority = NoPriority$1;

    {
      return runWithPriority$1(priorityLevel, flushPassiveEffectsImpl);
    }
  }

  return false;
}
function enqueuePendingPassiveHookEffectMount(fiber, effect) {
  pendingPassiveHookEffectsMount.push(effect, fiber);

  if (!rootDoesHavePassiveEffects) {
    rootDoesHavePassiveEffects = true;
    scheduleCallback(NormalPriority$1, function () {
      flushPassiveEffects();
      return null;
    });
  }
}
function enqueuePendingPassiveHookEffectUnmount(fiber, effect) {
  pendingPassiveHookEffectsUnmount.push(effect, fiber);

  {
    fiber.flags |= PassiveUnmountPendingDev;
    var alternate = fiber.alternate;

    if (alternate !== null) {
      alternate.flags |= PassiveUnmountPendingDev;
    }
  }

  if (!rootDoesHavePassiveEffects) {
    rootDoesHavePassiveEffects = true;
    scheduleCallback(NormalPriority$1, function () {
      flushPassiveEffects();
      return null;
    });
  }
}

function invokePassiveEffectCreate(effect) {
  var create = effect.create;
  effect.destroy = create();
}

function flushPassiveEffectsImpl() {
  if (rootWithPendingPassiveEffects === null) {
    return false;
  }

  var root = rootWithPendingPassiveEffects;
  var lanes = pendingPassiveEffectsLanes;
  rootWithPendingPassiveEffects = null;
  pendingPassiveEffectsLanes = NoLanes;

  if (!((executionContext & (RenderContext | CommitContext)) === NoContext)) {
    {
      throw Error( "Cannot flush passive effects while already rendering." );
    }
  }

  {
    isFlushingPassiveEffects = true;
  }

  var prevExecutionContext = executionContext;
  executionContext |= CommitContext;
  var prevInteractions = pushInteractions(root); // It's important that ALL pending passive effect destroy functions are called
  // before ANY passive effect create functions are called.
  // Otherwise effects in sibling components might interfere with each other.
  // e.g. a destroy function in one component may unintentionally override a ref
  // value set by a create function in another component.
  // Layout effects have the same constraint.
  // First pass: Destroy stale passive effects.

  var unmountEffects = pendingPassiveHookEffectsUnmount;
  pendingPassiveHookEffectsUnmount = [];

  for (var i = 0; i < unmountEffects.length; i += 2) {
    var _effect = unmountEffects[i];
    var fiber = unmountEffects[i + 1];
    var destroy = _effect.destroy;
    _effect.destroy = undefined;

    {
      fiber.flags &= ~PassiveUnmountPendingDev;
      var alternate = fiber.alternate;

      if (alternate !== null) {
        alternate.flags &= ~PassiveUnmountPendingDev;
      }
    }

    if (typeof destroy === 'function') {
      {
        setCurrentFiber(fiber);

        {
          invokeGuardedCallback(null, destroy, null);
        }

        if (hasCaughtError()) {
          if (!(fiber !== null)) {
            {
              throw Error( "Should be working on an effect." );
            }
          }

          var error = clearCaughtError();
          captureCommitPhaseError(fiber, error);
        }

        resetCurrentFiber();
      }
    }
  } // Second pass: Create new passive effects.


  var mountEffects = pendingPassiveHookEffectsMount;
  pendingPassiveHookEffectsMount = [];

  for (var _i = 0; _i < mountEffects.length; _i += 2) {
    var _effect2 = mountEffects[_i];
    var _fiber = mountEffects[_i + 1];

    {
      setCurrentFiber(_fiber);

      {
        invokeGuardedCallback(null, invokePassiveEffectCreate, null, _effect2);
      }

      if (hasCaughtError()) {
        if (!(_fiber !== null)) {
          {
            throw Error( "Should be working on an effect." );
          }
        }

        var _error4 = clearCaughtError();

        captureCommitPhaseError(_fiber, _error4);
      }

      resetCurrentFiber();
    }
  } // Note: This currently assumes there are no passive effects on the root fiber
  // because the root is not part of its own effect list.
  // This could change in the future.


  var effect = root.current.firstEffect;

  while (effect !== null) {
    var nextNextEffect = effect.nextEffect; // Remove nextEffect pointer to assist GC

    effect.nextEffect = null;

    if (effect.flags & Deletion) {
      detachFiberAfterEffects(effect);
    }

    effect = nextNextEffect;
  }

  {
    popInteractions(prevInteractions);
    finishPendingInteractions(root, lanes);
  }

  {
    isFlushingPassiveEffects = false;
  }

  executionContext = prevExecutionContext;
  flushSyncCallbackQueue(); // If additional passive effects were scheduled, increment a counter. If this
  // exceeds the limit, we'll fire a warning.

  nestedPassiveUpdateCount = rootWithPendingPassiveEffects === null ? 0 : nestedPassiveUpdateCount + 1;
  return true;
}

function isAlreadyFailedLegacyErrorBoundary(instance) {
  return legacyErrorBoundariesThatAlreadyFailed !== null && legacyErrorBoundariesThatAlreadyFailed.has(instance);
}
function markLegacyErrorBoundaryAsFailed(instance) {
  if (legacyErrorBoundariesThatAlreadyFailed === null) {
    legacyErrorBoundariesThatAlreadyFailed = new Set([instance]);
  } else {
    legacyErrorBoundariesThatAlreadyFailed.add(instance);
  }
}

function prepareToThrowUncaughtError(error) {
  if (!hasUncaughtError) {
    hasUncaughtError = true;
    firstUncaughtError = error;
  }
}

var onUncaughtError = prepareToThrowUncaughtError;

function captureCommitPhaseErrorOnRoot(rootFiber, sourceFiber, error) {
  var errorInfo = createCapturedValue(error, sourceFiber);
  var update = createRootErrorUpdate(rootFiber, errorInfo, SyncLane);
  enqueueUpdate(rootFiber, update);
  var eventTime = requestEventTime();
  var root = markUpdateLaneFromFiberToRoot(rootFiber, SyncLane);

  if (root !== null) {
    markRootUpdated(root, SyncLane, eventTime);
    ensureRootIsScheduled(root, eventTime);
    schedulePendingInteractions(root, SyncLane);
  }
}

function captureCommitPhaseError(sourceFiber, error) {
  if (sourceFiber.tag === HostRoot) {
    // Error was thrown at the root. There is no parent, so the root
    // itself should capture it.
    captureCommitPhaseErrorOnRoot(sourceFiber, sourceFiber, error);
    return;
  }

  var fiber = sourceFiber.return;

  while (fiber !== null) {
    if (fiber.tag === HostRoot) {
      captureCommitPhaseErrorOnRoot(fiber, sourceFiber, error);
      return;
    } else if (fiber.tag === ClassComponent) {
      var ctor = fiber.type;
      var instance = fiber.stateNode;

      if (typeof ctor.getDerivedStateFromError === 'function' || typeof instance.componentDidCatch === 'function' && !isAlreadyFailedLegacyErrorBoundary(instance)) {
        var errorInfo = createCapturedValue(error, sourceFiber);
        var update = createClassErrorUpdate(fiber, errorInfo, SyncLane);
        enqueueUpdate(fiber, update);
        var eventTime = requestEventTime();
        var root = markUpdateLaneFromFiberToRoot(fiber, SyncLane);

        if (root !== null) {
          markRootUpdated(root, SyncLane, eventTime);
          ensureRootIsScheduled(root, eventTime);
          schedulePendingInteractions(root, SyncLane);
        } else {
          // This component has already been unmounted.
          // We can't schedule any follow up work for the root because the fiber is already unmounted,
          // but we can still call the log-only boundary so the error isn't swallowed.
          //
          // TODO This is only a temporary bandaid for the old reconciler fork.
          // We can delete this special case once the new fork is merged.
          if (typeof instance.componentDidCatch === 'function' && !isAlreadyFailedLegacyErrorBoundary(instance)) {
            try {
              instance.componentDidCatch(error, errorInfo);
            } catch (errorToIgnore) {// TODO Ignore this error? Rethrow it?
              // This is kind of an edge case.
            }
          }
        }

        return;
      }
    }

    fiber = fiber.return;
  }
}
function pingSuspendedRoot(root, wakeable, pingedLanes) {
  var pingCache = root.pingCache;

  if (pingCache !== null) {
    // The wakeable resolved, so we no longer need to memoize, because it will
    // never be thrown again.
    pingCache.delete(wakeable);
  }

  var eventTime = requestEventTime();
  markRootPinged(root, pingedLanes);

  if (workInProgressRoot === root && isSubsetOfLanes(workInProgressRootRenderLanes, pingedLanes)) {
    // Received a ping at the same priority level at which we're currently
    // rendering. We might want to restart this render. This should mirror
    // the logic of whether or not a root suspends once it completes.
    // TODO: If we're rendering sync either due to Sync, Batched or expired,
    // we should probably never restart.
    // If we're suspended with delay, or if it's a retry, we'll always suspend
    // so we can always restart.
    if (workInProgressRootExitStatus === RootSuspendedWithDelay || workInProgressRootExitStatus === RootSuspended && includesOnlyRetries(workInProgressRootRenderLanes) && now() - globalMostRecentFallbackTime < FALLBACK_THROTTLE_MS) {
      // Restart from the root.
      prepareFreshStack(root, NoLanes);
    } else {
      // Even though we can't restart right now, we might get an
      // opportunity later. So we mark this render as having a ping.
      workInProgressRootPingedLanes = mergeLanes(workInProgressRootPingedLanes, pingedLanes);
    }
  }

  ensureRootIsScheduled(root, eventTime);
  schedulePendingInteractions(root, pingedLanes);
}

function retryTimedOutBoundary(boundaryFiber, retryLane) {
  // The boundary fiber (a Suspense component or SuspenseList component)
  // previously was rendered in its fallback state. One of the promises that
  // suspended it has resolved, which means at least part of the tree was
  // likely unblocked. Try rendering again, at a new expiration time.
  if (retryLane === NoLane) {
    retryLane = requestRetryLane(boundaryFiber);
  } // TODO: Special case idle priority?


  var eventTime = requestEventTime();
  var root = markUpdateLaneFromFiberToRoot(boundaryFiber, retryLane);

  if (root !== null) {
    markRootUpdated(root, retryLane, eventTime);
    ensureRootIsScheduled(root, eventTime);
    schedulePendingInteractions(root, retryLane);
  }
}
function resolveRetryWakeable(boundaryFiber, wakeable) {
  var retryLane = NoLane; // Default

  var retryCache;

  {
    retryCache = boundaryFiber.stateNode;
  }

  if (retryCache !== null) {
    // The wakeable resolved, so we no longer need to memoize, because it will
    // never be thrown again.
    retryCache.delete(wakeable);
  }

  retryTimedOutBoundary(boundaryFiber, retryLane);
} // Computes the next Just Noticeable Difference (JND) boundary.
// The theory is that a person can't tell the difference between small differences in time.
// Therefore, if we wait a bit longer than necessary that won't translate to a noticeable
// difference in the experience. However, waiting for longer might mean that we can avoid
// showing an intermediate loading state. The longer we have already waited, the harder it
// is to tell small differences in time. Therefore, the longer we've already waited,
// the longer we can wait additionally. At some point we have to give up though.
// We pick a train model where the next boundary commits at a consistent schedule.
// These particular numbers are vague estimates. We expect to adjust them based on research.

function jnd(timeElapsed) {
  return timeElapsed < 120 ? 120 : timeElapsed < 480 ? 480 : timeElapsed < 1080 ? 1080 : timeElapsed < 1920 ? 1920 : timeElapsed < 3000 ? 3000 : timeElapsed < 4320 ? 4320 : ceil(timeElapsed / 1960) * 1960;
}

function checkForNestedUpdates() {
  if (nestedUpdateCount > NESTED_UPDATE_LIMIT) {
    nestedUpdateCount = 0;
    rootWithNestedUpdates = null;

    {
      {
        throw Error( "Maximum update depth exceeded. This can happen when a component repeatedly calls setState inside componentWillUpdate or componentDidUpdate. React limits the number of nested updates to prevent infinite loops." );
      }
    }
  }

  {
    if (nestedPassiveUpdateCount > NESTED_PASSIVE_UPDATE_LIMIT) {
      nestedPassiveUpdateCount = 0;

      error('Maximum update depth exceeded. This can happen when a component ' + "calls setState inside useEffect, but useEffect either doesn't " + 'have a dependency array, or one of the dependencies changes on ' + 'every render.');
    }
  }
}

function flushRenderPhaseStrictModeWarningsInDEV() {
  {
    ReactStrictModeWarnings.flushLegacyContextWarning();

    {
      ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings();
    }
  }
}

var didWarnStateUpdateForNotYetMountedComponent = null;

function warnAboutUpdateOnNotYetMountedFiberInDEV(fiber) {
  {
    if ((executionContext & RenderContext) !== NoContext) {
      // We let the other warning about render phase updates deal with this one.
      return;
    }

    if (!(fiber.mode & (BlockingMode | ConcurrentMode))) {
      return;
    }

    var tag = fiber.tag;

    if (tag !== IndeterminateComponent && tag !== HostRoot && tag !== ClassComponent && tag !== FunctionComponent && tag !== ForwardRef && tag !== MemoComponent && tag !== SimpleMemoComponent && tag !== Block) {
      // Only warn for user-defined components, not internal ones like Suspense.
      return;
    } // We show the whole stack but dedupe on the top component's name because
    // the problematic code almost always lies inside that component.


    var componentName = getComponentName(fiber.type) || 'ReactComponent';

    if (didWarnStateUpdateForNotYetMountedComponent !== null) {
      if (didWarnStateUpdateForNotYetMountedComponent.has(componentName)) {
        return;
      }

      didWarnStateUpdateForNotYetMountedComponent.add(componentName);
    } else {
      didWarnStateUpdateForNotYetMountedComponent = new Set([componentName]);
    }

    var previousFiber = current;

    try {
      setCurrentFiber(fiber);

      error("Can't perform a React state update on a component that hasn't mounted yet. " + 'This indicates that you have a side-effect in your render function that ' + 'asynchronously later calls tries to update the component. Move this work to ' + 'useEffect instead.');
    } finally {
      if (previousFiber) {
        setCurrentFiber(fiber);
      } else {
        resetCurrentFiber();
      }
    }
  }
}

var didWarnStateUpdateForUnmountedComponent = null;

function warnAboutUpdateOnUnmountedFiberInDEV(fiber) {
  {
    var tag = fiber.tag;

    if (tag !== HostRoot && tag !== ClassComponent && tag !== FunctionComponent && tag !== ForwardRef && tag !== MemoComponent && tag !== SimpleMemoComponent && tag !== Block) {
      // Only warn for user-defined components, not internal ones like Suspense.
      return;
    } // If there are pending passive effects unmounts for this Fiber,
    // we can assume that they would have prevented this update.


    if ((fiber.flags & PassiveUnmountPendingDev) !== NoFlags) {
      return;
    } // We show the whole stack but dedupe on the top component's name because
    // the problematic code almost always lies inside that component.


    var componentName = getComponentName(fiber.type) || 'ReactComponent';

    if (didWarnStateUpdateForUnmountedComponent !== null) {
      if (didWarnStateUpdateForUnmountedComponent.has(componentName)) {
        return;
      }

      didWarnStateUpdateForUnmountedComponent.add(componentName);
    } else {
      didWarnStateUpdateForUnmountedComponent = new Set([componentName]);
    }

    if (isFlushingPassiveEffects) ; else {
      var previousFiber = current;

      try {
        setCurrentFiber(fiber);

        error("Can't perform a React state update on an unmounted component. This " + 'is a no-op, but it indicates a memory leak in your application. To ' + 'fix, cancel all subscriptions and asynchronous tasks in %s.', tag === ClassComponent ? 'the componentWillUnmount method' : 'a useEffect cleanup function');
      } finally {
        if (previousFiber) {
          setCurrentFiber(fiber);
        } else {
          resetCurrentFiber();
        }
      }
    }
  }
}

var beginWork$1;

{
  var dummyFiber = null;

  beginWork$1 = function (current, unitOfWork, lanes) {
    // If a component throws an error, we replay it again in a synchronously
    // dispatched event, so that the debugger will treat it as an uncaught
    // error See ReactErrorUtils for more information.
    // Before entering the begin phase, copy the work-in-progress onto a dummy
    // fiber. If beginWork throws, we'll use this to reset the state.
    var originalWorkInProgressCopy = assignFiberPropertiesInDEV(dummyFiber, unitOfWork);

    try {
      return beginWork(current, unitOfWork, lanes);
    } catch (originalError) {
      if (originalError !== null && typeof originalError === 'object' && typeof originalError.then === 'function') {
        // Don't replay promises. Treat everything else like an error.
        throw originalError;
      } // Keep this code in sync with handleError; any changes here must have
      // corresponding changes there.


      resetContextDependencies();
      resetHooksAfterThrow(); // Don't reset current debug fiber, since we're about to work on the
      // same fiber again.
      // Unwind the failed stack frame

      unwindInterruptedWork(unitOfWork); // Restore the original properties of the fiber.

      assignFiberPropertiesInDEV(unitOfWork, originalWorkInProgressCopy);

      if ( unitOfWork.mode & ProfileMode) {
        // Reset the profiler timer.
        startProfilerTimer(unitOfWork);
      } // Run beginWork again.


      invokeGuardedCallback(null, beginWork, null, current, unitOfWork, lanes);

      if (hasCaughtError()) {
        var replayError = clearCaughtError(); // `invokeGuardedCallback` sometimes sets an expando `_suppressLogging`.
        // Rethrow this error instead of the original one.

        throw replayError;
      } else {
        // This branch is reachable if the render phase is impure.
        throw originalError;
      }
    }
  };
}

var didWarnAboutUpdateInRender = false;
var didWarnAboutUpdateInRenderForAnotherComponent;

{
  didWarnAboutUpdateInRenderForAnotherComponent = new Set();
}

function warnAboutRenderPhaseUpdatesInDEV(fiber) {
  {
    if (isRendering && (executionContext & RenderContext) !== NoContext && !getIsUpdatingOpaqueValueInRenderPhaseInDEV()) {
      switch (fiber.tag) {
        case FunctionComponent:
        case ForwardRef:
        case SimpleMemoComponent:
          {
            var renderingComponentName = workInProgress && getComponentName(workInProgress.type) || 'Unknown'; // Dedupe by the rendering component because it's the one that needs to be fixed.

            var dedupeKey = renderingComponentName;

            if (!didWarnAboutUpdateInRenderForAnotherComponent.has(dedupeKey)) {
              didWarnAboutUpdateInRenderForAnotherComponent.add(dedupeKey);
              var setStateComponentName = getComponentName(fiber.type) || 'Unknown';

              error('Cannot update a component (`%s`) while rendering a ' + 'different component (`%s`). To locate the bad setState() call inside `%s`, ' + 'follow the stack trace as described in https://reactjs.org/link/setstate-in-render', setStateComponentName, renderingComponentName, renderingComponentName);
            }

            break;
          }

        case ClassComponent:
          {
            if (!didWarnAboutUpdateInRender) {
              error('Cannot update during an existing state transition (such as ' + 'within `render`). Render methods should be a pure ' + 'function of props and state.');

              didWarnAboutUpdateInRender = true;
            }

            break;
          }
      }
    }
  }
} // a 'shared' variable that changes when act() opens/closes in tests.


var IsThisRendererActing = {
  current: false
};
function warnIfNotScopedWithMatchingAct(fiber) {
  {
    if ( IsSomeRendererActing.current === true && IsThisRendererActing.current !== true) {
      var previousFiber = current;

      try {
        setCurrentFiber(fiber);

        error("It looks like you're using the wrong act() around your test interactions.\n" + 'Be sure to use the matching version of act() corresponding to your renderer:\n\n' + '// for react-dom:\n' + // Break up imports to avoid accidentally parsing them as dependencies.
        'import {act} fr' + "om 'react-dom/test-utils';\n" + '// ...\n' + 'act(() => ...);\n\n' + '// for react-test-renderer:\n' + // Break up imports to avoid accidentally parsing them as dependencies.
        'import TestRenderer fr' + "om react-test-renderer';\n" + 'const {act} = TestRenderer;\n' + '// ...\n' + 'act(() => ...);');
      } finally {
        if (previousFiber) {
          setCurrentFiber(fiber);
        } else {
          resetCurrentFiber();
        }
      }
    }
  }
}
function warnIfNotCurrentlyActingEffectsInDEV(fiber) {
  {
    if ( (fiber.mode & StrictMode) !== NoMode && IsSomeRendererActing.current === false && IsThisRendererActing.current === false) {
      error('An update to %s ran an effect, but was not wrapped in act(...).\n\n' + 'When testing, code that causes React state updates should be ' + 'wrapped into act(...):\n\n' + 'act(() => {\n' + '  /* fire events that update state */\n' + '});\n' + '/* assert on the output */\n\n' + "This ensures that you're testing the behavior the user would see " + 'in the browser.' + ' Learn more at https://reactjs.org/link/wrap-tests-with-act', getComponentName(fiber.type));
    }
  }
}

function warnIfNotCurrentlyActingUpdatesInDEV(fiber) {
  {
    if ( executionContext === NoContext && IsSomeRendererActing.current === false && IsThisRendererActing.current === false) {
      var previousFiber = current;

      try {
        setCurrentFiber(fiber);

        error('An update to %s inside a test was not wrapped in act(...).\n\n' + 'When testing, code that causes React state updates should be ' + 'wrapped into act(...):\n\n' + 'act(() => {\n' + '  /* fire events that update state */\n' + '});\n' + '/* assert on the output */\n\n' + "This ensures that you're testing the behavior the user would see " + 'in the browser.' + ' Learn more at https://reactjs.org/link/wrap-tests-with-act', getComponentName(fiber.type));
      } finally {
        if (previousFiber) {
          setCurrentFiber(fiber);
        } else {
          resetCurrentFiber();
        }
      }
    }
  }
}

var warnIfNotCurrentlyActingUpdatesInDev = warnIfNotCurrentlyActingUpdatesInDEV; // In tests, we want to enforce a mocked scheduler.

var didWarnAboutUnmockedScheduler = false; // TODO Before we release concurrent mode, revisit this and decide whether a mocked
// scheduler is the actual recommendation. The alternative could be a testing build,
// a new lib, or whatever; we dunno just yet. This message is for early adopters
// to get their tests right.

function warnIfUnmockedScheduler(fiber) {
  {
    if (didWarnAboutUnmockedScheduler === false && Scheduler.unstable_flushAllWithoutAsserting === undefined) {
      if (fiber.mode & BlockingMode || fiber.mode & ConcurrentMode) {
        didWarnAboutUnmockedScheduler = true;

        error('In Concurrent or Sync modes, the "scheduler" module needs to be mocked ' + 'to guarantee consistent behaviour across tests and browsers. ' + 'For example, with jest: \n' + // Break up requires to avoid accidentally parsing them as dependencies.
        "jest.mock('scheduler', () => require" + "('scheduler/unstable_mock'));\n\n" + 'For more info, visit https://reactjs.org/link/mock-scheduler');
      }
    }
  }
}

function computeThreadID(root, lane) {
  // Interaction threads are unique per root and expiration time.
  // NOTE: Intentionally unsound cast. All that matters is that it's a number
  // and it represents a batch of work. Could make a helper function instead,
  // but meh this is fine for now.
  return lane * 1000 + root.interactionThreadID;
}

function markSpawnedWork(lane) {

  if (spawnedWorkDuringRender === null) {
    spawnedWorkDuringRender = [lane];
  } else {
    spawnedWorkDuringRender.push(lane);
  }
}

function scheduleInteractions(root, lane, interactions) {

  if (interactions.size > 0) {
    var pendingInteractionMap = root.pendingInteractionMap;
    var pendingInteractions = pendingInteractionMap.get(lane);

    if (pendingInteractions != null) {
      interactions.forEach(function (interaction) {
        if (!pendingInteractions.has(interaction)) {
          // Update the pending async work count for previously unscheduled interaction.
          interaction.__count++;
        }

        pendingInteractions.add(interaction);
      });
    } else {
      pendingInteractionMap.set(lane, new Set(interactions)); // Update the pending async work count for the current interactions.

      interactions.forEach(function (interaction) {
        interaction.__count++;
      });
    }

    var subscriber = tracing.__subscriberRef.current;

    if (subscriber !== null) {
      var threadID = computeThreadID(root, lane);
      subscriber.onWorkScheduled(interactions, threadID);
    }
  }
}

function schedulePendingInteractions(root, lane) {

  scheduleInteractions(root, lane, tracing.__interactionsRef.current);
}

function startWorkOnPendingInteractions(root, lanes) {
  // we can accurately attribute time spent working on it, And so that cascading
  // work triggered during the render phase will be associated with it.


  var interactions = new Set();
  root.pendingInteractionMap.forEach(function (scheduledInteractions, scheduledLane) {
    if (includesSomeLane(lanes, scheduledLane)) {
      scheduledInteractions.forEach(function (interaction) {
        return interactions.add(interaction);
      });
    }
  }); // Store the current set of interactions on the FiberRoot for a few reasons:
  // We can re-use it in hot functions like performConcurrentWorkOnRoot()
  // without having to recalculate it. We will also use it in commitWork() to
  // pass to any Profiler onRender() hooks. This also provides DevTools with a
  // way to access it when the onCommitRoot() hook is called.

  root.memoizedInteractions = interactions;

  if (interactions.size > 0) {
    var subscriber = tracing.__subscriberRef.current;

    if (subscriber !== null) {
      var threadID = computeThreadID(root, lanes);

      try {
        subscriber.onWorkStarted(interactions, threadID);
      } catch (error) {
        // If the subscriber throws, rethrow it in a separate task
        scheduleCallback(ImmediatePriority$1, function () {
          throw error;
        });
      }
    }
  }
}

function finishPendingInteractions(root, committedLanes) {

  var remainingLanesAfterCommit = root.pendingLanes;
  var subscriber;

  try {
    subscriber = tracing.__subscriberRef.current;

    if (subscriber !== null && root.memoizedInteractions.size > 0) {
      // FIXME: More than one lane can finish in a single commit.
      var threadID = computeThreadID(root, committedLanes);
      subscriber.onWorkStopped(root.memoizedInteractions, threadID);
    }
  } catch (error) {
    // If the subscriber throws, rethrow it in a separate task
    scheduleCallback(ImmediatePriority$1, function () {
      throw error;
    });
  } finally {
    // Clear completed interactions from the pending Map.
    // Unless the render was suspended or cascading work was scheduled,
    // In which case leave pending interactions until the subsequent render.
    var pendingInteractionMap = root.pendingInteractionMap;
    pendingInteractionMap.forEach(function (scheduledInteractions, lane) {
      // Only decrement the pending interaction count if we're done.
      // If there's still work at the current priority,
      // That indicates that we are waiting for suspense data.
      if (!includesSomeLane(remainingLanesAfterCommit, lane)) {
        pendingInteractionMap.delete(lane);
        scheduledInteractions.forEach(function (interaction) {
          interaction.__count--;

          if (subscriber !== null && interaction.__count === 0) {
            try {
              subscriber.onInteractionScheduledWorkCompleted(interaction);
            } catch (error) {
              // If the subscriber throws, rethrow it in a separate task
              scheduleCallback(ImmediatePriority$1, function () {
                throw error;
              });
            }
          }
        });
      }
    });
  }
} // `act` testing API

function shouldForceFlushFallbacksInDEV() {
  // Never force flush in production. This function should get stripped out.
  return  actingUpdatesScopeDepth > 0;
}
// so we can tell if any async act() calls try to run in parallel.


var actingUpdatesScopeDepth = 0;

function detachFiberAfterEffects(fiber) {
  fiber.sibling = null;
  fiber.stateNode = null;
}

var resolveFamily = null; // $FlowFixMe Flow gets confused by a WeakSet feature check below.

var failedBoundaries = null;
var setRefreshHandler = function (handler) {
  {
    resolveFamily = handler;
  }
};
function resolveFunctionForHotReloading(type) {
  {
    if (resolveFamily === null) {
      // Hot reloading is disabled.
      return type;
    }

    var family = resolveFamily(type);

    if (family === undefined) {
      return type;
    } // Use the latest known implementation.


    return family.current;
  }
}
function resolveClassForHotReloading(type) {
  // No implementation differences.
  return resolveFunctionForHotReloading(type);
}
function resolveForwardRefForHotReloading(type) {
  {
    if (resolveFamily === null) {
      // Hot reloading is disabled.
      return type;
    }

    var family = resolveFamily(type);

    if (family === undefined) {
      // Check if we're dealing with a real forwardRef. Don't want to crash early.
      if (type !== null && type !== undefined && typeof type.render === 'function') {
        // ForwardRef is special because its resolved .type is an object,
        // but it's possible that we only have its inner render function in the map.
        // If that inner render function is different, we'll build a new forwardRef type.
        var currentRender = resolveFunctionForHotReloading(type.render);

        if (type.render !== currentRender) {
          var syntheticType = {
            $$typeof: REACT_FORWARD_REF_TYPE,
            render: currentRender
          };

          if (type.displayName !== undefined) {
            syntheticType.displayName = type.displayName;
          }

          return syntheticType;
        }
      }

      return type;
    } // Use the latest known implementation.


    return family.current;
  }
}
function isCompatibleFamilyForHotReloading(fiber, element) {
  {
    if (resolveFamily === null) {
      // Hot reloading is disabled.
      return false;
    }

    var prevType = fiber.elementType;
    var nextType = element.type; // If we got here, we know types aren't === equal.

    var needsCompareFamilies = false;
    var $$typeofNextType = typeof nextType === 'object' && nextType !== null ? nextType.$$typeof : null;

    switch (fiber.tag) {
      case ClassComponent:
        {
          if (typeof nextType === 'function') {
            needsCompareFamilies = true;
          }

          break;
        }

      case FunctionComponent:
        {
          if (typeof nextType === 'function') {
            needsCompareFamilies = true;
          } else if ($$typeofNextType === REACT_LAZY_TYPE) {
            // We don't know the inner type yet.
            // We're going to assume that the lazy inner type is stable,
            // and so it is sufficient to avoid reconciling it away.
            // We're not going to unwrap or actually use the new lazy type.
            needsCompareFamilies = true;
          }

          break;
        }

      case ForwardRef:
        {
          if ($$typeofNextType === REACT_FORWARD_REF_TYPE) {
            needsCompareFamilies = true;
          } else if ($$typeofNextType === REACT_LAZY_TYPE) {
            needsCompareFamilies = true;
          }

          break;
        }

      case MemoComponent:
      case SimpleMemoComponent:
        {
          if ($$typeofNextType === REACT_MEMO_TYPE) {
            // TODO: if it was but can no longer be simple,
            // we shouldn't set this.
            needsCompareFamilies = true;
          } else if ($$typeofNextType === REACT_LAZY_TYPE) {
            needsCompareFamilies = true;
          }

          break;
        }

      default:
        return false;
    } // Check if both types have a family and it's the same one.


    if (needsCompareFamilies) {
      // Note: memo() and forwardRef() we'll compare outer rather than inner type.
      // This means both of them need to be registered to preserve state.
      // If we unwrapped and compared the inner types for wrappers instead,
      // then we would risk falsely saying two separate memo(Foo)
      // calls are equivalent because they wrap the same Foo function.
      var prevFamily = resolveFamily(prevType);

      if (prevFamily !== undefined && prevFamily === resolveFamily(nextType)) {
        return true;
      }
    }

    return false;
  }
}
function markFailedErrorBoundaryForHotReloading(fiber) {
  {
    if (resolveFamily === null) {
      // Hot reloading is disabled.
      return;
    }

    if (typeof WeakSet !== 'function') {
      return;
    }

    if (failedBoundaries === null) {
      failedBoundaries = new WeakSet();
    }

    failedBoundaries.add(fiber);
  }
}
var scheduleRefresh = function (root, update) {
  {
    if (resolveFamily === null) {
      // Hot reloading is disabled.
      return;
    }

    var staleFamilies = update.staleFamilies,
        updatedFamilies = update.updatedFamilies;
    flushPassiveEffects();
    flushSync(function () {
      scheduleFibersWithFamiliesRecursively(root.current, updatedFamilies, staleFamilies);
    });
  }
};
var scheduleRoot = function (root, element) {
  {
    if (root.context !== emptyContextObject) {
      // Super edge case: root has a legacy _renderSubtree context
      // but we don't know the parentComponent so we can't pass it.
      // Just ignore. We'll delete this with _renderSubtree code path later.
      return;
    }

    flushPassiveEffects();
    flushSync(function () {
      updateContainer(element, root, null, null);
    });
  }
};

function scheduleFibersWithFamiliesRecursively(fiber, updatedFamilies, staleFamilies) {
  {
    var alternate = fiber.alternate,
        child = fiber.child,
        sibling = fiber.sibling,
        tag = fiber.tag,
        type = fiber.type;
    var candidateType = null;

    switch (tag) {
      case FunctionComponent:
      case SimpleMemoComponent:
      case ClassComponent:
        candidateType = type;
        break;

      case ForwardRef:
        candidateType = type.render;
        break;
    }

    if (resolveFamily === null) {
      throw new Error('Expected resolveFamily to be set during hot reload.');
    }

    var needsRender = false;
    var needsRemount = false;

    if (candidateType !== null) {
      var family = resolveFamily(candidateType);

      if (family !== undefined) {
        if (staleFamilies.has(family)) {
          needsRemount = true;
        } else if (updatedFamilies.has(family)) {
          if (tag === ClassComponent) {
            needsRemount = true;
          } else {
            needsRender = true;
          }
        }
      }
    }

    if (failedBoundaries !== null) {
      if (failedBoundaries.has(fiber) || alternate !== null && failedBoundaries.has(alternate)) {
        needsRemount = true;
      }
    }

    if (needsRemount) {
      fiber._debugNeedsRemount = true;
    }

    if (needsRemount || needsRender) {
      scheduleUpdateOnFiber(fiber, SyncLane, NoTimestamp);
    }

    if (child !== null && !needsRemount) {
      scheduleFibersWithFamiliesRecursively(child, updatedFamilies, staleFamilies);
    }

    if (sibling !== null) {
      scheduleFibersWithFamiliesRecursively(sibling, updatedFamilies, staleFamilies);
    }
  }
}

var findHostInstancesForRefresh = function (root, families) {
  {
    var hostInstances = new Set();
    var types = new Set(families.map(function (family) {
      return family.current;
    }));
    findHostInstancesForMatchingFibersRecursively(root.current, types, hostInstances);
    return hostInstances;
  }
};

function findHostInstancesForMatchingFibersRecursively(fiber, types, hostInstances) {
  {
    var child = fiber.child,
        sibling = fiber.sibling,
        tag = fiber.tag,
        type = fiber.type;
    var candidateType = null;

    switch (tag) {
      case FunctionComponent:
      case SimpleMemoComponent:
      case ClassComponent:
        candidateType = type;
        break;

      case ForwardRef:
        candidateType = type.render;
        break;
    }

    var didMatch = false;

    if (candidateType !== null) {
      if (types.has(candidateType)) {
        didMatch = true;
      }
    }

    if (didMatch) {
      // We have a match. This only drills down to the closest host components.
      // There's no need to search deeper because for the purpose of giving
      // visual feedback, "flashing" outermost parent rectangles is sufficient.
      findHostInstancesForFiberShallowly(fiber, hostInstances);
    } else {
      // If there's no match, maybe there will be one further down in the child tree.
      if (child !== null) {
        findHostInstancesForMatchingFibersRecursively(child, types, hostInstances);
      }
    }

    if (sibling !== null) {
      findHostInstancesForMatchingFibersRecursively(sibling, types, hostInstances);
    }
  }
}

function findHostInstancesForFiberShallowly(fiber, hostInstances) {
  {
    var foundHostInstances = findChildHostInstancesForFiberShallowly(fiber, hostInstances);

    if (foundHostInstances) {
      return;
    } // If we didn't find any host children, fallback to closest host parent.


    var node = fiber;

    while (true) {
      switch (node.tag) {
        case HostComponent:
          hostInstances.add(node.stateNode);
          return;

        case HostPortal:
          hostInstances.add(node.stateNode.containerInfo);
          return;

        case HostRoot:
          hostInstances.add(node.stateNode.containerInfo);
          return;
      }

      if (node.return === null) {
        throw new Error('Expected to reach root first.');
      }

      node = node.return;
    }
  }
}

function findChildHostInstancesForFiberShallowly(fiber, hostInstances) {
  {
    var node = fiber;
    var foundHostInstances = false;

    while (true) {
      if (node.tag === HostComponent) {
        // We got a match.
        foundHostInstances = true;
        hostInstances.add(node.stateNode); // There may still be more, so keep searching.
      } else if (node.child !== null) {
        node.child.return = node;
        node = node.child;
        continue;
      }

      if (node === fiber) {
        return foundHostInstances;
      }

      while (node.sibling === null) {
        if (node.return === null || node.return === fiber) {
          return foundHostInstances;
        }

        node = node.return;
      }

      node.sibling.return = node.return;
      node = node.sibling;
    }
  }

  return false;
}

var hasBadMapPolyfill;

{
  hasBadMapPolyfill = false;

  try {
    var nonExtensibleObject = Object.preventExtensions({});
    /* eslint-disable no-new */

    new Map([[nonExtensibleObject, null]]);
    new Set([nonExtensibleObject]);
    /* eslint-enable no-new */
  } catch (e) {
    // TODO: Consider warning about bad polyfills
    hasBadMapPolyfill = true;
  }
}

var debugCounter = 1;

function FiberNode(tag, pendingProps, key, mode) {
  // Instance
  this.tag = tag;
  this.key = key;
  this.elementType = null;
  this.type = null;
  this.stateNode = null; // Fiber

  this.return = null;
  this.child = null;
  this.sibling = null;
  this.index = 0;
  this.ref = null;
  this.pendingProps = pendingProps;
  this.memoizedProps = null;
  this.updateQueue = null;
  this.memoizedState = null;
  this.dependencies = null;
  this.mode = mode; // Effects

  this.flags = NoFlags;
  this.nextEffect = null;
  this.firstEffect = null;
  this.lastEffect = null;
  this.lanes = NoLanes;
  this.childLanes = NoLanes;
  this.alternate = null;

  {
    // Note: The following is done to avoid a v8 performance cliff.
    //
    // Initializing the fields below to smis and later updating them with
    // double values will cause Fibers to end up having separate shapes.
    // This behavior/bug has something to do with Object.preventExtension().
    // Fortunately this only impacts DEV builds.
    // Unfortunately it makes React unusably slow for some applications.
    // To work around this, initialize the fields below with doubles.
    //
    // Learn more about this here:
    // https://github.com/facebook/react/issues/14365
    // https://bugs.chromium.org/p/v8/issues/detail?id=8538
    this.actualDuration = Number.NaN;
    this.actualStartTime = Number.NaN;
    this.selfBaseDuration = Number.NaN;
    this.treeBaseDuration = Number.NaN; // It's okay to replace the initial doubles with smis after initialization.
    // This won't trigger the performance cliff mentioned above,
    // and it simplifies other profiler code (including DevTools).

    this.actualDuration = 0;
    this.actualStartTime = -1;
    this.selfBaseDuration = 0;
    this.treeBaseDuration = 0;
  }

  {
    // This isn't directly used but is handy for debugging internals:
    this._debugID = debugCounter++;
    this._debugSource = null;
    this._debugOwner = null;
    this._debugNeedsRemount = false;
    this._debugHookTypes = null;

    if (!hasBadMapPolyfill && typeof Object.preventExtensions === 'function') {
      Object.preventExtensions(this);
    }
  }
} // This is a constructor function, rather than a POJO constructor, still
// please ensure we do the following:
// 1) Nobody should add any instance methods on this. Instance methods can be
//    more difficult to predict when they get optimized and they are almost
//    never inlined properly in static compilers.
// 2) Nobody should rely on `instanceof Fiber` for type testing. We should
//    always know when it is a fiber.
// 3) We might want to experiment with using numeric keys since they are easier
//    to optimize in a non-JIT environment.
// 4) We can easily go from a constructor to a createFiber object literal if that
//    is faster.
// 5) It should be easy to port this to a C struct and keep a C implementation
//    compatible.


var createFiber = function (tag, pendingProps, key, mode) {
  // $FlowFixMe: the shapes are exact here but Flow doesn't like constructors
  return new FiberNode(tag, pendingProps, key, mode);
};

function shouldConstruct$1(Component) {
  var prototype = Component.prototype;
  return !!(prototype && prototype.isReactComponent);
}

function isSimpleFunctionComponent(type) {
  return typeof type === 'function' && !shouldConstruct$1(type) && type.defaultProps === undefined;
}
function resolveLazyComponentTag(Component) {
  if (typeof Component === 'function') {
    return shouldConstruct$1(Component) ? ClassComponent : FunctionComponent;
  } else if (Component !== undefined && Component !== null) {
    var $$typeof = Component.$$typeof;

    if ($$typeof === REACT_FORWARD_REF_TYPE) {
      return ForwardRef;
    }

    if ($$typeof === REACT_MEMO_TYPE) {
      return MemoComponent;
    }
  }

  return IndeterminateComponent;
} // This is used to create an alternate fiber to do work on.

function createWorkInProgress(current, pendingProps) {
  var workInProgress = current.alternate;

  if (workInProgress === null) {
    // We use a double buffering pooling technique because we know that we'll
    // only ever need at most two versions of a tree. We pool the "other" unused
    // node that we're free to reuse. This is lazily created to avoid allocating
    // extra objects for things that are never updated. It also allow us to
    // reclaim the extra memory if needed.
    workInProgress = createFiber(current.tag, pendingProps, current.key, current.mode);
    workInProgress.elementType = current.elementType;
    workInProgress.type = current.type;
    workInProgress.stateNode = current.stateNode;

    {
      // DEV-only fields
      workInProgress._debugID = current._debugID;
      workInProgress._debugSource = current._debugSource;
      workInProgress._debugOwner = current._debugOwner;
      workInProgress._debugHookTypes = current._debugHookTypes;
    }

    workInProgress.alternate = current;
    current.alternate = workInProgress;
  } else {
    workInProgress.pendingProps = pendingProps; // Needed because Blocks store data on type.

    workInProgress.type = current.type; // We already have an alternate.
    // Reset the effect tag.

    workInProgress.flags = NoFlags; // The effect list is no longer valid.

    workInProgress.nextEffect = null;
    workInProgress.firstEffect = null;
    workInProgress.lastEffect = null;

    {
      // We intentionally reset, rather than copy, actualDuration & actualStartTime.
      // This prevents time from endlessly accumulating in new commits.
      // This has the downside of resetting values for different priority renders,
      // But works for yielding (the common case) and should support resuming.
      workInProgress.actualDuration = 0;
      workInProgress.actualStartTime = -1;
    }
  }

  workInProgress.childLanes = current.childLanes;
  workInProgress.lanes = current.lanes;
  workInProgress.child = current.child;
  workInProgress.memoizedProps = current.memoizedProps;
  workInProgress.memoizedState = current.memoizedState;
  workInProgress.updateQueue = current.updateQueue; // Clone the dependencies object. This is mutated during the render phase, so
  // it cannot be shared with the current fiber.

  var currentDependencies = current.dependencies;
  workInProgress.dependencies = currentDependencies === null ? null : {
    lanes: currentDependencies.lanes,
    firstContext: currentDependencies.firstContext
  }; // These will be overridden during the parent's reconciliation

  workInProgress.sibling = current.sibling;
  workInProgress.index = current.index;
  workInProgress.ref = current.ref;

  {
    workInProgress.selfBaseDuration = current.selfBaseDuration;
    workInProgress.treeBaseDuration = current.treeBaseDuration;
  }

  {
    workInProgress._debugNeedsRemount = current._debugNeedsRemount;

    switch (workInProgress.tag) {
      case IndeterminateComponent:
      case FunctionComponent:
      case SimpleMemoComponent:
        workInProgress.type = resolveFunctionForHotReloading(current.type);
        break;

      case ClassComponent:
        workInProgress.type = resolveClassForHotReloading(current.type);
        break;

      case ForwardRef:
        workInProgress.type = resolveForwardRefForHotReloading(current.type);
        break;
    }
  }

  return workInProgress;
} // Used to reuse a Fiber for a second pass.

function resetWorkInProgress(workInProgress, renderLanes) {
  // This resets the Fiber to what createFiber or createWorkInProgress would
  // have set the values to before during the first pass. Ideally this wouldn't
  // be necessary but unfortunately many code paths reads from the workInProgress
  // when they should be reading from current and writing to workInProgress.
  // We assume pendingProps, index, key, ref, return are still untouched to
  // avoid doing another reconciliation.
  // Reset the effect tag but keep any Placement tags, since that's something
  // that child fiber is setting, not the reconciliation.
  workInProgress.flags &= Placement; // The effect list is no longer valid.

  workInProgress.nextEffect = null;
  workInProgress.firstEffect = null;
  workInProgress.lastEffect = null;
  var current = workInProgress.alternate;

  if (current === null) {
    // Reset to createFiber's initial values.
    workInProgress.childLanes = NoLanes;
    workInProgress.lanes = renderLanes;
    workInProgress.child = null;
    workInProgress.memoizedProps = null;
    workInProgress.memoizedState = null;
    workInProgress.updateQueue = null;
    workInProgress.dependencies = null;
    workInProgress.stateNode = null;

    {
      // Note: We don't reset the actualTime counts. It's useful to accumulate
      // actual time across multiple render passes.
      workInProgress.selfBaseDuration = 0;
      workInProgress.treeBaseDuration = 0;
    }
  } else {
    // Reset to the cloned values that createWorkInProgress would've.
    workInProgress.childLanes = current.childLanes;
    workInProgress.lanes = current.lanes;
    workInProgress.child = current.child;
    workInProgress.memoizedProps = current.memoizedProps;
    workInProgress.memoizedState = current.memoizedState;
    workInProgress.updateQueue = current.updateQueue; // Needed because Blocks store data on type.

    workInProgress.type = current.type; // Clone the dependencies object. This is mutated during the render phase, so
    // it cannot be shared with the current fiber.

    var currentDependencies = current.dependencies;
    workInProgress.dependencies = currentDependencies === null ? null : {
      lanes: currentDependencies.lanes,
      firstContext: currentDependencies.firstContext
    };

    {
      // Note: We don't reset the actualTime counts. It's useful to accumulate
      // actual time across multiple render passes.
      workInProgress.selfBaseDuration = current.selfBaseDuration;
      workInProgress.treeBaseDuration = current.treeBaseDuration;
    }
  }

  return workInProgress;
}
function createHostRootFiber(tag) {
  var mode;

  if (tag === ConcurrentRoot) {
    mode = ConcurrentMode | BlockingMode | StrictMode;
  } else if (tag === BlockingRoot) {
    mode = BlockingMode | StrictMode;
  } else {
    mode = NoMode;
  }

  if ( isDevToolsPresent) {
    // Always collect profile timings when DevTools are present.
    // This enables DevTools to start capturing timing at any point
    // Without some nodes in the tree having empty base times.
    mode |= ProfileMode;
  }

  return createFiber(HostRoot, null, null, mode);
}
function createFiberFromTypeAndProps(type, // React$ElementType
key, pendingProps, owner, mode, lanes) {
  var fiberTag = IndeterminateComponent; // The resolved type is set if we know what the final type will be. I.e. it's not lazy.

  var resolvedType = type;

  if (typeof type === 'function') {
    if (shouldConstruct$1(type)) {
      fiberTag = ClassComponent;

      {
        resolvedType = resolveClassForHotReloading(resolvedType);
      }
    } else {
      {
        resolvedType = resolveFunctionForHotReloading(resolvedType);
      }
    }
  } else if (typeof type === 'string') {
    fiberTag = HostComponent;
  } else {
    getTag: switch (type) {
      case REACT_FRAGMENT_TYPE:
        return createFiberFromFragment(pendingProps.children, mode, lanes, key);

      case REACT_DEBUG_TRACING_MODE_TYPE:
        fiberTag = Mode;
        mode |= DebugTracingMode;
        break;

      case REACT_STRICT_MODE_TYPE:
        fiberTag = Mode;
        mode |= StrictMode;
        break;

      case REACT_PROFILER_TYPE:
        return createFiberFromProfiler(pendingProps, mode, lanes, key);

      case REACT_SUSPENSE_TYPE:
        return createFiberFromSuspense(pendingProps, mode, lanes, key);

      case REACT_SUSPENSE_LIST_TYPE:
        return createFiberFromSuspenseList(pendingProps, mode, lanes, key);

      case REACT_OFFSCREEN_TYPE:
        return createFiberFromOffscreen(pendingProps, mode, lanes, key);

      case REACT_LEGACY_HIDDEN_TYPE:
        return createFiberFromLegacyHidden(pendingProps, mode, lanes, key);

      case REACT_SCOPE_TYPE:

      // eslint-disable-next-line no-fallthrough

      default:
        {
          if (typeof type === 'object' && type !== null) {
            switch (type.$$typeof) {
              case REACT_PROVIDER_TYPE:
                fiberTag = ContextProvider;
                break getTag;

              case REACT_CONTEXT_TYPE:
                // This is a consumer
                fiberTag = ContextConsumer;
                break getTag;

              case REACT_FORWARD_REF_TYPE:
                fiberTag = ForwardRef;

                {
                  resolvedType = resolveForwardRefForHotReloading(resolvedType);
                }

                break getTag;

              case REACT_MEMO_TYPE:
                fiberTag = MemoComponent;
                break getTag;

              case REACT_LAZY_TYPE:
                fiberTag = LazyComponent;
                resolvedType = null;
                break getTag;

              case REACT_BLOCK_TYPE:
                fiberTag = Block;
                break getTag;
            }
          }

          var info = '';

          {
            if (type === undefined || typeof type === 'object' && type !== null && Object.keys(type).length === 0) {
              info += ' You likely forgot to export your component from the file ' + "it's defined in, or you might have mixed up default and " + 'named imports.';
            }

            var ownerName = owner ? getComponentName(owner.type) : null;

            if (ownerName) {
              info += '\n\nCheck the render method of `' + ownerName + '`.';
            }
          }

          {
            {
              throw Error( "Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) but got: " + (type == null ? type : typeof type) + "." + info );
            }
          }
        }
    }
  }

  var fiber = createFiber(fiberTag, pendingProps, key, mode);
  fiber.elementType = type;
  fiber.type = resolvedType;
  fiber.lanes = lanes;

  {
    fiber._debugOwner = owner;
  }

  return fiber;
}
function createFiberFromElement(element, mode, lanes) {
  var owner = null;

  {
    owner = element._owner;
  }

  var type = element.type;
  var key = element.key;
  var pendingProps = element.props;
  var fiber = createFiberFromTypeAndProps(type, key, pendingProps, owner, mode, lanes);

  {
    fiber._debugSource = element._source;
    fiber._debugOwner = element._owner;
  }

  return fiber;
}
function createFiberFromFragment(elements, mode, lanes, key) {
  var fiber = createFiber(Fragment, elements, key, mode);
  fiber.lanes = lanes;
  return fiber;
}

function createFiberFromProfiler(pendingProps, mode, lanes, key) {
  {
    if (typeof pendingProps.id !== 'string') {
      error('Profiler must specify an "id" as a prop');
    }
  }

  var fiber = createFiber(Profiler, pendingProps, key, mode | ProfileMode); // TODO: The Profiler fiber shouldn't have a type. It has a tag.

  fiber.elementType = REACT_PROFILER_TYPE;
  fiber.type = REACT_PROFILER_TYPE;
  fiber.lanes = lanes;

  {
    fiber.stateNode = {
      effectDuration: 0,
      passiveEffectDuration: 0
    };
  }

  return fiber;
}

function createFiberFromSuspense(pendingProps, mode, lanes, key) {
  var fiber = createFiber(SuspenseComponent, pendingProps, key, mode); // TODO: The SuspenseComponent fiber shouldn't have a type. It has a tag.
  // This needs to be fixed in getComponentName so that it relies on the tag
  // instead.

  fiber.type = REACT_SUSPENSE_TYPE;
  fiber.elementType = REACT_SUSPENSE_TYPE;
  fiber.lanes = lanes;
  return fiber;
}
function createFiberFromSuspenseList(pendingProps, mode, lanes, key) {
  var fiber = createFiber(SuspenseListComponent, pendingProps, key, mode);

  {
    // TODO: The SuspenseListComponent fiber shouldn't have a type. It has a tag.
    // This needs to be fixed in getComponentName so that it relies on the tag
    // instead.
    fiber.type = REACT_SUSPENSE_LIST_TYPE;
  }

  fiber.elementType = REACT_SUSPENSE_LIST_TYPE;
  fiber.lanes = lanes;
  return fiber;
}
function createFiberFromOffscreen(pendingProps, mode, lanes, key) {
  var fiber = createFiber(OffscreenComponent, pendingProps, key, mode); // TODO: The OffscreenComponent fiber shouldn't have a type. It has a tag.
  // This needs to be fixed in getComponentName so that it relies on the tag
  // instead.

  {
    fiber.type = REACT_OFFSCREEN_TYPE;
  }

  fiber.elementType = REACT_OFFSCREEN_TYPE;
  fiber.lanes = lanes;
  return fiber;
}
function createFiberFromLegacyHidden(pendingProps, mode, lanes, key) {
  var fiber = createFiber(LegacyHiddenComponent, pendingProps, key, mode); // TODO: The LegacyHidden fiber shouldn't have a type. It has a tag.
  // This needs to be fixed in getComponentName so that it relies on the tag
  // instead.

  {
    fiber.type = REACT_LEGACY_HIDDEN_TYPE;
  }

  fiber.elementType = REACT_LEGACY_HIDDEN_TYPE;
  fiber.lanes = lanes;
  return fiber;
}
function createFiberFromText(content, mode, lanes) {
  var fiber = createFiber(HostText, content, null, mode);
  fiber.lanes = lanes;
  return fiber;
}
function createFiberFromHostInstanceForDeletion() {
  var fiber = createFiber(HostComponent, null, null, NoMode); // TODO: These should not need a type.

  fiber.elementType = 'DELETED';
  fiber.type = 'DELETED';
  return fiber;
}
function createFiberFromPortal(portal, mode, lanes) {
  var pendingProps = portal.children !== null ? portal.children : [];
  var fiber = createFiber(HostPortal, pendingProps, portal.key, mode);
  fiber.lanes = lanes;
  fiber.stateNode = {
    containerInfo: portal.containerInfo,
    pendingChildren: null,
    // Used by persistent updates
    implementation: portal.implementation
  };
  return fiber;
} // Used for stashing WIP properties to replay failed work in DEV.

function assignFiberPropertiesInDEV(target, source) {
  if (target === null) {
    // This Fiber's initial properties will always be overwritten.
    // We only use a Fiber to ensure the same hidden class so DEV isn't slow.
    target = createFiber(IndeterminateComponent, null, null, NoMode);
  } // This is intentionally written as a list of all properties.
  // We tried to use Object.assign() instead but this is called in
  // the hottest path, and Object.assign() was too slow:
  // https://github.com/facebook/react/issues/12502
  // This code is DEV-only so size is not a concern.


  target.tag = source.tag;
  target.key = source.key;
  target.elementType = source.elementType;
  target.type = source.type;
  target.stateNode = source.stateNode;
  target.return = source.return;
  target.child = source.child;
  target.sibling = source.sibling;
  target.index = source.index;
  target.ref = source.ref;
  target.pendingProps = source.pendingProps;
  target.memoizedProps = source.memoizedProps;
  target.updateQueue = source.updateQueue;
  target.memoizedState = source.memoizedState;
  target.dependencies = source.dependencies;
  target.mode = source.mode;
  target.flags = source.flags;
  target.nextEffect = source.nextEffect;
  target.firstEffect = source.firstEffect;
  target.lastEffect = source.lastEffect;
  target.lanes = source.lanes;
  target.childLanes = source.childLanes;
  target.alternate = source.alternate;

  {
    target.actualDuration = source.actualDuration;
    target.actualStartTime = source.actualStartTime;
    target.selfBaseDuration = source.selfBaseDuration;
    target.treeBaseDuration = source.treeBaseDuration;
  }

  target._debugID = source._debugID;
  target._debugSource = source._debugSource;
  target._debugOwner = source._debugOwner;
  target._debugNeedsRemount = source._debugNeedsRemount;
  target._debugHookTypes = source._debugHookTypes;
  return target;
}

function FiberRootNode(containerInfo, tag, hydrate) {
  this.tag = tag;
  this.containerInfo = containerInfo;
  this.pendingChildren = null;
  this.current = null;
  this.pingCache = null;
  this.finishedWork = null;
  this.timeoutHandle = noTimeout;
  this.context = null;
  this.pendingContext = null;
  this.hydrate = hydrate;
  this.callbackNode = null;
  this.callbackPriority = NoLanePriority;
  this.eventTimes = createLaneMap(NoLanes);
  this.expirationTimes = createLaneMap(NoTimestamp);
  this.pendingLanes = NoLanes;
  this.suspendedLanes = NoLanes;
  this.pingedLanes = NoLanes;
  this.expiredLanes = NoLanes;
  this.mutableReadLanes = NoLanes;
  this.finishedLanes = NoLanes;
  this.entangledLanes = NoLanes;
  this.entanglements = createLaneMap(NoLanes);

  {
    this.mutableSourceEagerHydrationData = null;
  }

  {
    this.interactionThreadID = tracing.unstable_getThreadID();
    this.memoizedInteractions = new Set();
    this.pendingInteractionMap = new Map();
  }

  {
    switch (tag) {
      case BlockingRoot:
        this._debugRootType = 'createBlockingRoot()';
        break;

      case ConcurrentRoot:
        this._debugRootType = 'createRoot()';
        break;

      case LegacyRoot:
        this._debugRootType = 'createLegacyRoot()';
        break;
    }
  }
}

function createFiberRoot(containerInfo, tag, hydrate, hydrationCallbacks) {
  var root = new FiberRootNode(containerInfo, tag, hydrate);
  // stateNode is any.


  var uninitializedFiber = createHostRootFiber(tag);
  root.current = uninitializedFiber;
  uninitializedFiber.stateNode = root;
  initializeUpdateQueue(uninitializedFiber);
  return root;
}

// This ensures that the version used for server rendering matches the one
// that is eventually read during hydration.
// If they don't match there's a potential tear and a full deopt render is required.

function registerMutableSourceForHydration(root, mutableSource) {
  var getVersion = mutableSource._getVersion;
  var version = getVersion(mutableSource._source); // TODO Clear this data once all pending hydration work is finished.
  // Retaining it forever may interfere with GC.

  if (root.mutableSourceEagerHydrationData == null) {
    root.mutableSourceEagerHydrationData = [mutableSource, version];
  } else {
    root.mutableSourceEagerHydrationData.push(mutableSource, version);
  }
}

function createPortal(children, containerInfo, // TODO: figure out the API for cross-renderer implementation.
implementation) {
  var key = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
  return {
    // This tag allow us to uniquely identify this as a React Portal
    $$typeof: REACT_PORTAL_TYPE,
    key: key == null ? null : '' + key,
    children: children,
    containerInfo: containerInfo,
    implementation: implementation
  };
}

var didWarnAboutNestedUpdates;
var didWarnAboutFindNodeInStrictMode;

{
  didWarnAboutNestedUpdates = false;
  didWarnAboutFindNodeInStrictMode = {};
}

function getContextForSubtree(parentComponent) {
  if (!parentComponent) {
    return emptyContextObject;
  }

  var fiber = get(parentComponent);
  var parentContext = findCurrentUnmaskedContext(fiber);

  if (fiber.tag === ClassComponent) {
    var Component = fiber.type;

    if (isContextProvider(Component)) {
      return processChildContext(fiber, Component, parentContext);
    }
  }

  return parentContext;
}

function findHostInstanceWithWarning(component, methodName) {
  {
    var fiber = get(component);

    if (fiber === undefined) {
      if (typeof component.render === 'function') {
        {
          {
            throw Error( "Unable to find node on an unmounted component." );
          }
        }
      } else {
        {
          {
            throw Error( "Argument appears to not be a ReactComponent. Keys: " + Object.keys(component) );
          }
        }
      }
    }

    var hostFiber = findCurrentHostFiber(fiber);

    if (hostFiber === null) {
      return null;
    }

    if (hostFiber.mode & StrictMode) {
      var componentName = getComponentName(fiber.type) || 'Component';

      if (!didWarnAboutFindNodeInStrictMode[componentName]) {
        didWarnAboutFindNodeInStrictMode[componentName] = true;
        var previousFiber = current;

        try {
          setCurrentFiber(hostFiber);

          if (fiber.mode & StrictMode) {
            error('%s is deprecated in StrictMode. ' + '%s was passed an instance of %s which is inside StrictMode. ' + 'Instead, add a ref directly to the element you want to reference. ' + 'Learn more about using refs safely here: ' + 'https://reactjs.org/link/strict-mode-find-node', methodName, methodName, componentName);
          } else {
            error('%s is deprecated in StrictMode. ' + '%s was passed an instance of %s which renders StrictMode children. ' + 'Instead, add a ref directly to the element you want to reference. ' + 'Learn more about using refs safely here: ' + 'https://reactjs.org/link/strict-mode-find-node', methodName, methodName, componentName);
          }
        } finally {
          // Ideally this should reset to previous but this shouldn't be called in
          // render and there's another warning for that anyway.
          if (previousFiber) {
            setCurrentFiber(previousFiber);
          } else {
            resetCurrentFiber();
          }
        }
      }
    }

    return hostFiber.stateNode;
  }
}

function createContainer(containerInfo, tag, hydrate, hydrationCallbacks) {
  return createFiberRoot(containerInfo, tag, hydrate);
}
function updateContainer(element, container, parentComponent, callback) {
  {
    onScheduleRoot(container, element);
  }

  var current$1 = container.current;
  var eventTime = requestEventTime();

  {
    // $FlowExpectedError - jest isn't a global, and isn't recognized outside of tests
    if ('undefined' !== typeof jest) {
      warnIfUnmockedScheduler(current$1);
      warnIfNotScopedWithMatchingAct(current$1);
    }
  }

  var lane = requestUpdateLane(current$1);

  var context = getContextForSubtree(parentComponent);

  if (container.context === null) {
    container.context = context;
  } else {
    container.pendingContext = context;
  }

  {
    if (isRendering && current !== null && !didWarnAboutNestedUpdates) {
      didWarnAboutNestedUpdates = true;

      error('Render methods should be a pure function of props and state; ' + 'triggering nested component updates from render is not allowed. ' + 'If necessary, trigger nested updates in componentDidUpdate.\n\n' + 'Check the render method of %s.', getComponentName(current.type) || 'Unknown');
    }
  }

  var update = createUpdate(eventTime, lane); // Caution: React DevTools currently depends on this property
  // being called "element".

  update.payload = {
    element: element
  };
  callback = callback === undefined ? null : callback;

  if (callback !== null) {
    {
      if (typeof callback !== 'function') {
        error('render(...): Expected the last optional `callback` argument to be a ' + 'function. Instead received: %s.', callback);
      }
    }

    update.callback = callback;
  }

  enqueueUpdate(current$1, update);
  scheduleUpdateOnFiber(current$1, lane, eventTime);
  return lane;
}
function getPublicRootInstance(container) {
  var containerFiber = container.current;

  if (!containerFiber.child) {
    return null;
  }

  switch (containerFiber.child.tag) {
    case HostComponent:
      return getPublicInstance(containerFiber.child.stateNode);

    default:
      return containerFiber.child.stateNode;
  }
}

function markRetryLaneImpl(fiber, retryLane) {
  var suspenseState = fiber.memoizedState;

  if (suspenseState !== null && suspenseState.dehydrated !== null) {
    suspenseState.retryLane = higherPriorityLane(suspenseState.retryLane, retryLane);
  }
} // Increases the priority of thennables when they resolve within this boundary.


function markRetryLaneIfNotHydrated(fiber, retryLane) {
  markRetryLaneImpl(fiber, retryLane);
  var alternate = fiber.alternate;

  if (alternate) {
    markRetryLaneImpl(alternate, retryLane);
  }
}

function attemptUserBlockingHydration$1(fiber) {
  if (fiber.tag !== SuspenseComponent) {
    // We ignore HostRoots here because we can't increase
    // their priority and they should not suspend on I/O,
    // since you have to wrap anything that might suspend in
    // Suspense.
    return;
  }

  var eventTime = requestEventTime();
  var lane = InputDiscreteHydrationLane;
  scheduleUpdateOnFiber(fiber, lane, eventTime);
  markRetryLaneIfNotHydrated(fiber, lane);
}
function attemptContinuousHydration$1(fiber) {
  if (fiber.tag !== SuspenseComponent) {
    // We ignore HostRoots here because we can't increase
    // their priority and they should not suspend on I/O,
    // since you have to wrap anything that might suspend in
    // Suspense.
    return;
  }

  var eventTime = requestEventTime();
  var lane = SelectiveHydrationLane;
  scheduleUpdateOnFiber(fiber, lane, eventTime);
  markRetryLaneIfNotHydrated(fiber, lane);
}
function attemptHydrationAtCurrentPriority$1(fiber) {
  if (fiber.tag !== SuspenseComponent) {
    // We ignore HostRoots here because we can't increase
    // their priority other than synchronously flush it.
    return;
  }

  var eventTime = requestEventTime();
  var lane = requestUpdateLane(fiber);
  scheduleUpdateOnFiber(fiber, lane, eventTime);
  markRetryLaneIfNotHydrated(fiber, lane);
}
function runWithPriority$2(priority, fn) {

  try {
    setCurrentUpdateLanePriority(priority);
    return fn();
  } finally {
  }
}
function findHostInstanceWithNoPortals(fiber) {
  var hostFiber = findCurrentHostFiberWithNoPortals(fiber);

  if (hostFiber === null) {
    return null;
  }

  if (hostFiber.tag === FundamentalComponent) {
    return hostFiber.stateNode.instance;
  }

  return hostFiber.stateNode;
}

var shouldSuspendImpl = function (fiber) {
  return false;
};

function shouldSuspend(fiber) {
  return shouldSuspendImpl(fiber);
}
var overrideHookState = null;
var overrideHookStateDeletePath = null;
var overrideHookStateRenamePath = null;
var overrideProps = null;
var overridePropsDeletePath = null;
var overridePropsRenamePath = null;
var scheduleUpdate = null;
var setSuspenseHandler = null;

{
  var copyWithDeleteImpl = function (obj, path, index) {
    var key = path[index];
    var updated = Array.isArray(obj) ? obj.slice() : _assign({}, obj);

    if (index + 1 === path.length) {
      if (Array.isArray(updated)) {
        updated.splice(key, 1);
      } else {
        delete updated[key];
      }

      return updated;
    } // $FlowFixMe number or string is fine here


    updated[key] = copyWithDeleteImpl(obj[key], path, index + 1);
    return updated;
  };

  var copyWithDelete = function (obj, path) {
    return copyWithDeleteImpl(obj, path, 0);
  };

  var copyWithRenameImpl = function (obj, oldPath, newPath, index) {
    var oldKey = oldPath[index];
    var updated = Array.isArray(obj) ? obj.slice() : _assign({}, obj);

    if (index + 1 === oldPath.length) {
      var newKey = newPath[index]; // $FlowFixMe number or string is fine here

      updated[newKey] = updated[oldKey];

      if (Array.isArray(updated)) {
        updated.splice(oldKey, 1);
      } else {
        delete updated[oldKey];
      }
    } else {
      // $FlowFixMe number or string is fine here
      updated[oldKey] = copyWithRenameImpl( // $FlowFixMe number or string is fine here
      obj[oldKey], oldPath, newPath, index + 1);
    }

    return updated;
  };

  var copyWithRename = function (obj, oldPath, newPath) {
    if (oldPath.length !== newPath.length) {
      warn('copyWithRename() expects paths of the same length');

      return;
    } else {
      for (var i = 0; i < newPath.length - 1; i++) {
        if (oldPath[i] !== newPath[i]) {
          warn('copyWithRename() expects paths to be the same except for the deepest key');

          return;
        }
      }
    }

    return copyWithRenameImpl(obj, oldPath, newPath, 0);
  };

  var copyWithSetImpl = function (obj, path, index, value) {
    if (index >= path.length) {
      return value;
    }

    var key = path[index];
    var updated = Array.isArray(obj) ? obj.slice() : _assign({}, obj); // $FlowFixMe number or string is fine here

    updated[key] = copyWithSetImpl(obj[key], path, index + 1, value);
    return updated;
  };

  var copyWithSet = function (obj, path, value) {
    return copyWithSetImpl(obj, path, 0, value);
  };

  var findHook = function (fiber, id) {
    // For now, the "id" of stateful hooks is just the stateful hook index.
    // This may change in the future with e.g. nested hooks.
    var currentHook = fiber.memoizedState;

    while (currentHook !== null && id > 0) {
      currentHook = currentHook.next;
      id--;
    }

    return currentHook;
  }; // Support DevTools editable values for useState and useReducer.


  overrideHookState = function (fiber, id, path, value) {
    var hook = findHook(fiber, id);

    if (hook !== null) {
      var newState = copyWithSet(hook.memoizedState, path, value);
      hook.memoizedState = newState;
      hook.baseState = newState; // We aren't actually adding an update to the queue,
      // because there is no update we can add for useReducer hooks that won't trigger an error.
      // (There's no appropriate action type for DevTools overrides.)
      // As a result though, React will see the scheduled update as a noop and bailout.
      // Shallow cloning props works as a workaround for now to bypass the bailout check.

      fiber.memoizedProps = _assign({}, fiber.memoizedProps);
      scheduleUpdateOnFiber(fiber, SyncLane, NoTimestamp);
    }
  };

  overrideHookStateDeletePath = function (fiber, id, path) {
    var hook = findHook(fiber, id);

    if (hook !== null) {
      var newState = copyWithDelete(hook.memoizedState, path);
      hook.memoizedState = newState;
      hook.baseState = newState; // We aren't actually adding an update to the queue,
      // because there is no update we can add for useReducer hooks that won't trigger an error.
      // (There's no appropriate action type for DevTools overrides.)
      // As a result though, React will see the scheduled update as a noop and bailout.
      // Shallow cloning props works as a workaround for now to bypass the bailout check.

      fiber.memoizedProps = _assign({}, fiber.memoizedProps);
      scheduleUpdateOnFiber(fiber, SyncLane, NoTimestamp);
    }
  };

  overrideHookStateRenamePath = function (fiber, id, oldPath, newPath) {
    var hook = findHook(fiber, id);

    if (hook !== null) {
      var newState = copyWithRename(hook.memoizedState, oldPath, newPath);
      hook.memoizedState = newState;
      hook.baseState = newState; // We aren't actually adding an update to the queue,
      // because there is no update we can add for useReducer hooks that won't trigger an error.
      // (There's no appropriate action type for DevTools overrides.)
      // As a result though, React will see the scheduled update as a noop and bailout.
      // Shallow cloning props works as a workaround for now to bypass the bailout check.

      fiber.memoizedProps = _assign({}, fiber.memoizedProps);
      scheduleUpdateOnFiber(fiber, SyncLane, NoTimestamp);
    }
  }; // Support DevTools props for function components, forwardRef, memo, host components, etc.


  overrideProps = function (fiber, path, value) {
    fiber.pendingProps = copyWithSet(fiber.memoizedProps, path, value);

    if (fiber.alternate) {
      fiber.alternate.pendingProps = fiber.pendingProps;
    }

    scheduleUpdateOnFiber(fiber, SyncLane, NoTimestamp);
  };

  overridePropsDeletePath = function (fiber, path) {
    fiber.pendingProps = copyWithDelete(fiber.memoizedProps, path);

    if (fiber.alternate) {
      fiber.alternate.pendingProps = fiber.pendingProps;
    }

    scheduleUpdateOnFiber(fiber, SyncLane, NoTimestamp);
  };

  overridePropsRenamePath = function (fiber, oldPath, newPath) {
    fiber.pendingProps = copyWithRename(fiber.memoizedProps, oldPath, newPath);

    if (fiber.alternate) {
      fiber.alternate.pendingProps = fiber.pendingProps;
    }

    scheduleUpdateOnFiber(fiber, SyncLane, NoTimestamp);
  };

  scheduleUpdate = function (fiber) {
    scheduleUpdateOnFiber(fiber, SyncLane, NoTimestamp);
  };

  setSuspenseHandler = function (newShouldSuspendImpl) {
    shouldSuspendImpl = newShouldSuspendImpl;
  };
}

function findHostInstanceByFiber(fiber) {
  var hostFiber = findCurrentHostFiber(fiber);

  if (hostFiber === null) {
    return null;
  }

  return hostFiber.stateNode;
}

function emptyFindFiberByHostInstance(instance) {
  return null;
}

function getCurrentFiberForDevTools() {
  return current;
}

function injectIntoDevTools(devToolsConfig) {
  var findFiberByHostInstance = devToolsConfig.findFiberByHostInstance;
  var ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;
  return injectInternals({
    bundleType: devToolsConfig.bundleType,
    version: devToolsConfig.version,
    rendererPackageName: devToolsConfig.rendererPackageName,
    rendererConfig: devToolsConfig.rendererConfig,
    overrideHookState: overrideHookState,
    overrideHookStateDeletePath: overrideHookStateDeletePath,
    overrideHookStateRenamePath: overrideHookStateRenamePath,
    overrideProps: overrideProps,
    overridePropsDeletePath: overridePropsDeletePath,
    overridePropsRenamePath: overridePropsRenamePath,
    setSuspenseHandler: setSuspenseHandler,
    scheduleUpdate: scheduleUpdate,
    currentDispatcherRef: ReactCurrentDispatcher,
    findHostInstanceByFiber: findHostInstanceByFiber,
    findFiberByHostInstance: findFiberByHostInstance || emptyFindFiberByHostInstance,
    // React Refresh
    findHostInstancesForRefresh:  findHostInstancesForRefresh ,
    scheduleRefresh:  scheduleRefresh ,
    scheduleRoot:  scheduleRoot ,
    setRefreshHandler:  setRefreshHandler ,
    // Enables DevTools to append owner stacks to error messages in DEV mode.
    getCurrentFiber:  getCurrentFiberForDevTools 
  });
}

function ReactDOMRoot(container, options) {
  this._internalRoot = createRootImpl(container, ConcurrentRoot, options);
}

function ReactDOMBlockingRoot(container, tag, options) {
  this._internalRoot = createRootImpl(container, tag, options);
}

ReactDOMRoot.prototype.render = ReactDOMBlockingRoot.prototype.render = function (children) {
  var root = this._internalRoot;

  {
    if (typeof arguments[1] === 'function') {
      error('render(...): does not support the second callback argument. ' + 'To execute a side effect after rendering, declare it in a component body with useEffect().');
    }

    var container = root.containerInfo;

    if (container.nodeType !== COMMENT_NODE) {
      var hostInstance = findHostInstanceWithNoPortals(root.current);

      if (hostInstance) {
        if (hostInstance.parentNode !== container) {
          error('render(...): It looks like the React-rendered content of the ' + 'root container was removed without using React. This is not ' + 'supported and will cause errors. Instead, call ' + "root.unmount() to empty a root's container.");
        }
      }
    }
  }

  updateContainer(children, root, null, null);
};

ReactDOMRoot.prototype.unmount = ReactDOMBlockingRoot.prototype.unmount = function () {
  {
    if (typeof arguments[0] === 'function') {
      error('unmount(...): does not support a callback argument. ' + 'To execute a side effect after rendering, declare it in a component body with useEffect().');
    }
  }

  var root = this._internalRoot;
  var container = root.containerInfo;
  updateContainer(null, root, null, function () {
    unmarkContainerAsRoot(container);
  });
};

function createRootImpl(container, tag, options) {
  // Tag is either LegacyRoot or Concurrent Root
  var hydrate = options != null && options.hydrate === true;
  var hydrationCallbacks = options != null && options.hydrationOptions || null;
  var mutableSources = options != null && options.hydrationOptions != null && options.hydrationOptions.mutableSources || null;
  var root = createContainer(container, tag, hydrate);
  markContainerAsRoot(root.current, container);
  var containerNodeType = container.nodeType;

  {
    var rootContainerElement = container.nodeType === COMMENT_NODE ? container.parentNode : container;
    listenToAllSupportedEvents(rootContainerElement);
  }

  if (mutableSources) {
    for (var i = 0; i < mutableSources.length; i++) {
      var mutableSource = mutableSources[i];
      registerMutableSourceForHydration(root, mutableSource);
    }
  }

  return root;
}
function createLegacyRoot(container, options) {
  return new ReactDOMBlockingRoot(container, LegacyRoot, options);
}
function isValidContainer(node) {
  return !!(node && (node.nodeType === ELEMENT_NODE || node.nodeType === DOCUMENT_NODE || node.nodeType === DOCUMENT_FRAGMENT_NODE || node.nodeType === COMMENT_NODE && node.nodeValue === ' react-mount-point-unstable '));
}

var ReactCurrentOwner$3 = ReactSharedInternals.ReactCurrentOwner;
var topLevelUpdateWarnings;
var warnedAboutHydrateAPI = false;

{
  topLevelUpdateWarnings = function (container) {
    if (container._reactRootContainer && container.nodeType !== COMMENT_NODE) {
      var hostInstance = findHostInstanceWithNoPortals(container._reactRootContainer._internalRoot.current);

      if (hostInstance) {
        if (hostInstance.parentNode !== container) {
          error('render(...): It looks like the React-rendered content of this ' + 'container was removed without using React. This is not ' + 'supported and will cause errors. Instead, call ' + 'ReactDOM.unmountComponentAtNode to empty a container.');
        }
      }
    }

    var isRootRenderedBySomeReact = !!container._reactRootContainer;
    var rootEl = getReactRootElementInContainer(container);
    var hasNonRootReactChild = !!(rootEl && getInstanceFromNode(rootEl));

    if (hasNonRootReactChild && !isRootRenderedBySomeReact) {
      error('render(...): Replacing React-rendered children with a new root ' + 'component. If you intended to update the children of this node, ' + 'you should instead have the existing children update their state ' + 'and render the new components instead of calling ReactDOM.render.');
    }

    if (container.nodeType === ELEMENT_NODE && container.tagName && container.tagName.toUpperCase() === 'BODY') {
      error('render(): Rendering components directly into document.body is ' + 'discouraged, since its children are often manipulated by third-party ' + 'scripts and browser extensions. This may lead to subtle ' + 'reconciliation issues. Try rendering into a container element created ' + 'for your app.');
    }
  };
}

function getReactRootElementInContainer(container) {
  if (!container) {
    return null;
  }

  if (container.nodeType === DOCUMENT_NODE) {
    return container.documentElement;
  } else {
    return container.firstChild;
  }
}

function shouldHydrateDueToLegacyHeuristic(container) {
  var rootElement = getReactRootElementInContainer(container);
  return !!(rootElement && rootElement.nodeType === ELEMENT_NODE && rootElement.hasAttribute(ROOT_ATTRIBUTE_NAME));
}

function legacyCreateRootFromDOMContainer(container, forceHydrate) {
  var shouldHydrate = forceHydrate || shouldHydrateDueToLegacyHeuristic(container); // First clear any existing content.

  if (!shouldHydrate) {
    var warned = false;
    var rootSibling;

    while (rootSibling = container.lastChild) {
      {
        if (!warned && rootSibling.nodeType === ELEMENT_NODE && rootSibling.hasAttribute(ROOT_ATTRIBUTE_NAME)) {
          warned = true;

          error('render(): Target node has markup rendered by React, but there ' + 'are unrelated nodes as well. This is most commonly caused by ' + 'white-space inserted around server-rendered markup.');
        }
      }

      container.removeChild(rootSibling);
    }
  }

  {
    if (shouldHydrate && !forceHydrate && !warnedAboutHydrateAPI) {
      warnedAboutHydrateAPI = true;

      warn('render(): Calling ReactDOM.render() to hydrate server-rendered markup ' + 'will stop working in React v18. Replace the ReactDOM.render() call ' + 'with ReactDOM.hydrate() if you want React to attach to the server HTML.');
    }
  }

  return createLegacyRoot(container, shouldHydrate ? {
    hydrate: true
  } : undefined);
}

function warnOnInvalidCallback$1(callback, callerName) {
  {
    if (callback !== null && typeof callback !== 'function') {
      error('%s(...): Expected the last optional `callback` argument to be a ' + 'function. Instead received: %s.', callerName, callback);
    }
  }
}

function legacyRenderSubtreeIntoContainer(parentComponent, children, container, forceHydrate, callback) {
  {
    topLevelUpdateWarnings(container);
    warnOnInvalidCallback$1(callback === undefined ? null : callback, 'render');
  } // TODO: Without `any` type, Flow says "Property cannot be accessed on any
  // member of intersection type." Whyyyyyy.


  var root = container._reactRootContainer;
  var fiberRoot;

  if (!root) {
    // Initial mount
    root = container._reactRootContainer = legacyCreateRootFromDOMContainer(container, forceHydrate);
    fiberRoot = root._internalRoot;

    if (typeof callback === 'function') {
      var originalCallback = callback;

      callback = function () {
        var instance = getPublicRootInstance(fiberRoot);
        originalCallback.call(instance);
      };
    } // Initial mount should not be batched.


    unbatchedUpdates(function () {
      updateContainer(children, fiberRoot, parentComponent, callback);
    });
  } else {
    fiberRoot = root._internalRoot;

    if (typeof callback === 'function') {
      var _originalCallback = callback;

      callback = function () {
        var instance = getPublicRootInstance(fiberRoot);

        _originalCallback.call(instance);
      };
    } // Update


    updateContainer(children, fiberRoot, parentComponent, callback);
  }

  return getPublicRootInstance(fiberRoot);
}

function findDOMNode(componentOrElement) {
  {
    var owner = ReactCurrentOwner$3.current;

    if (owner !== null && owner.stateNode !== null) {
      var warnedAboutRefsInRender = owner.stateNode._warnedAboutRefsInRender;

      if (!warnedAboutRefsInRender) {
        error('%s is accessing findDOMNode inside its render(). ' + 'render() should be a pure function of props and state. It should ' + 'never access something that requires stale data from the previous ' + 'render, such as refs. Move this logic to componentDidMount and ' + 'componentDidUpdate instead.', getComponentName(owner.type) || 'A component');
      }

      owner.stateNode._warnedAboutRefsInRender = true;
    }
  }

  if (componentOrElement == null) {
    return null;
  }

  if (componentOrElement.nodeType === ELEMENT_NODE) {
    return componentOrElement;
  }

  {
    return findHostInstanceWithWarning(componentOrElement, 'findDOMNode');
  }
}
function hydrate(element, container, callback) {
  if (!isValidContainer(container)) {
    {
      throw Error( "Target container is not a DOM element." );
    }
  }

  {
    var isModernRoot = isContainerMarkedAsRoot(container) && container._reactRootContainer === undefined;

    if (isModernRoot) {
      error('You are calling ReactDOM.hydrate() on a container that was previously ' + 'passed to ReactDOM.createRoot(). This is not supported. ' + 'Did you mean to call createRoot(container, {hydrate: true}).render(element)?');
    }
  } // TODO: throw or warn if we couldn't hydrate?


  return legacyRenderSubtreeIntoContainer(null, element, container, true, callback);
}
function render(element, container, callback) {
  if (!isValidContainer(container)) {
    {
      throw Error( "Target container is not a DOM element." );
    }
  }

  {
    var isModernRoot = isContainerMarkedAsRoot(container) && container._reactRootContainer === undefined;

    if (isModernRoot) {
      error('You are calling ReactDOM.render() on a container that was previously ' + 'passed to ReactDOM.createRoot(). This is not supported. ' + 'Did you mean to call root.render(element)?');
    }
  }

  return legacyRenderSubtreeIntoContainer(null, element, container, false, callback);
}
function unstable_renderSubtreeIntoContainer(parentComponent, element, containerNode, callback) {
  if (!isValidContainer(containerNode)) {
    {
      throw Error( "Target container is not a DOM element." );
    }
  }

  if (!(parentComponent != null && has(parentComponent))) {
    {
      throw Error( "parentComponent must be a valid React Component" );
    }
  }

  return legacyRenderSubtreeIntoContainer(parentComponent, element, containerNode, false, callback);
}
function unmountComponentAtNode(container) {
  if (!isValidContainer(container)) {
    {
      throw Error( "unmountComponentAtNode(...): Target container is not a DOM element." );
    }
  }

  {
    var isModernRoot = isContainerMarkedAsRoot(container) && container._reactRootContainer === undefined;

    if (isModernRoot) {
      error('You are calling ReactDOM.unmountComponentAtNode() on a container that was previously ' + 'passed to ReactDOM.createRoot(). This is not supported. Did you mean to call root.unmount()?');
    }
  }

  if (container._reactRootContainer) {
    {
      var rootEl = getReactRootElementInContainer(container);
      var renderedByDifferentReact = rootEl && !getInstanceFromNode(rootEl);

      if (renderedByDifferentReact) {
        error("unmountComponentAtNode(): The node you're attempting to unmount " + 'was rendered by another copy of React.');
      }
    } // Unmount should not be batched.


    unbatchedUpdates(function () {
      legacyRenderSubtreeIntoContainer(null, null, container, false, function () {
        // $FlowFixMe This should probably use `delete container._reactRootContainer`
        container._reactRootContainer = null;
        unmarkContainerAsRoot(container);
      });
    }); // If you call unmountComponentAtNode twice in quick succession, you'll
    // get `true` twice. That's probably fine?

    return true;
  } else {
    {
      var _rootEl = getReactRootElementInContainer(container);

      var hasNonRootReactChild = !!(_rootEl && getInstanceFromNode(_rootEl)); // Check if the container itself is a React root node.

      var isContainerReactRoot = container.nodeType === ELEMENT_NODE && isValidContainer(container.parentNode) && !!container.parentNode._reactRootContainer;

      if (hasNonRootReactChild) {
        error("unmountComponentAtNode(): The node you're attempting to unmount " + 'was rendered by React and is not a top-level container. %s', isContainerReactRoot ? 'You may have accidentally passed in a React root node instead ' + 'of its container.' : 'Instead, have the parent component update its state and ' + 'rerender in order to remove this component.');
      }
    }

    return false;
  }
}

setAttemptUserBlockingHydration(attemptUserBlockingHydration$1);
setAttemptContinuousHydration(attemptContinuousHydration$1);
setAttemptHydrationAtCurrentPriority(attemptHydrationAtCurrentPriority$1);
setAttemptHydrationAtPriority(runWithPriority$2);
var didWarnAboutUnstableCreatePortal = false;

{
  if (typeof Map !== 'function' || // $FlowIssue Flow incorrectly thinks Map has no prototype
  Map.prototype == null || typeof Map.prototype.forEach !== 'function' || typeof Set !== 'function' || // $FlowIssue Flow incorrectly thinks Set has no prototype
  Set.prototype == null || typeof Set.prototype.clear !== 'function' || typeof Set.prototype.forEach !== 'function') {
    error('React depends on Map and Set built-in types. Make sure that you load a ' + 'polyfill in older browsers. https://reactjs.org/link/react-polyfills');
  }
}

setRestoreImplementation(restoreControlledState$3);
setBatchingImplementation(batchedUpdates$1, discreteUpdates$1, flushDiscreteUpdates, batchedEventUpdates$1);

function createPortal$1(children, container) {
  var key = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

  if (!isValidContainer(container)) {
    {
      throw Error( "Target container is not a DOM element." );
    }
  } // TODO: pass ReactDOM portal implementation as third argument
  // $FlowFixMe The Flow type is opaque but there's no way to actually create it.


  return createPortal(children, container, null, key);
}

function renderSubtreeIntoContainer(parentComponent, element, containerNode, callback) {

  return unstable_renderSubtreeIntoContainer(parentComponent, element, containerNode, callback);
}

function unstable_createPortal(children, container) {
  var key = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

  {
    if (!didWarnAboutUnstableCreatePortal) {
      didWarnAboutUnstableCreatePortal = true;

      warn('The ReactDOM.unstable_createPortal() alias has been deprecated, ' + 'and will be removed in React 18+. Update your code to use ' + 'ReactDOM.createPortal() instead. It has the exact same API, ' + 'but without the "unstable_" prefix.');
    }
  }

  return createPortal$1(children, container, key);
}

var Internals = {
  // Keep in sync with ReactTestUtils.js, and ReactTestUtilsAct.js.
  // This is an array for better minification.
  Events: [getInstanceFromNode, getNodeFromInstance, getFiberCurrentPropsFromNode, enqueueStateRestore, restoreStateIfNeeded, flushPassiveEffects, // TODO: This is related to `act`, not events. Move to separate key?
  IsThisRendererActing]
};
var foundDevTools = injectIntoDevTools({
  findFiberByHostInstance: getClosestInstanceFromNode,
  bundleType:  1 ,
  version: ReactVersion,
  rendererPackageName: 'react-dom'
});

{
  if (!foundDevTools && canUseDOM && window.top === window.self) {
    // If we're in Chrome or Firefox, provide a download link if not installed.
    if (navigator.userAgent.indexOf('Chrome') > -1 && navigator.userAgent.indexOf('Edge') === -1 || navigator.userAgent.indexOf('Firefox') > -1) {
      var protocol = window.location.protocol; // Don't warn in exotic cases like chrome-extension://.

      if (/^(https?|file):$/.test(protocol)) {
        // eslint-disable-next-line react-internal/no-production-logging
        console.info('%cDownload the React DevTools ' + 'for a better development experience: ' + 'https://reactjs.org/link/react-devtools' + (protocol === 'file:' ? '\nYou might need to use a local HTTP server (instead of file://): ' + 'https://reactjs.org/link/react-devtools-faq' : ''), 'font-weight:bold');
      }
    }
  }
}

exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = Internals;
exports.createPortal = createPortal$1;
exports.findDOMNode = findDOMNode;
exports.flushSync = flushSync;
exports.hydrate = hydrate;
exports.render = render;
exports.unmountComponentAtNode = unmountComponentAtNode;
exports.unstable_batchedUpdates = batchedUpdates$1;
exports.unstable_createPortal = unstable_createPortal;
exports.unstable_renderSubtreeIntoContainer = renderSubtreeIntoContainer;
exports.version = ReactVersion;
  })();
}


/***/ }),

/***/ "./node_modules/react-dom/index.js":
/*!*****************************************!*\
  !*** ./node_modules/react-dom/index.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


function checkDCE() {
  /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */
  if (
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === 'undefined' ||
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== 'function'
  ) {
    return;
  }
  if (true) {
    // This branch is unreachable because this function is only called
    // in production, but the condition is true only in development.
    // Therefore if the branch is still here, dead code elimination wasn't
    // properly applied.
    // Don't change the message. React DevTools relies on it. Also make sure
    // this message doesn't occur elsewhere in this function, or it will cause
    // a false positive.
    throw new Error('^_^');
  }
  try {
    // Verify that the code above has been dead code eliminated (DCE'd).
    __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
  } catch (err) {
    // DevTools shouldn't crash React, no matter what.
    // We should still report in case we break this code.
    console.error(err);
  }
}

if (false) {} else {
  module.exports = __webpack_require__(/*! ./cjs/react-dom.development.js */ "./node_modules/react-dom/cjs/react-dom.development.js");
}


/***/ }),

/***/ "./node_modules/react/cjs/react.development.js":
/*!*****************************************************!*\
  !*** ./node_modules/react/cjs/react.development.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/** @license React v17.0.2
 * react.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



if (true) {
  (function() {
'use strict';

var _assign = __webpack_require__(/*! object-assign */ "./node_modules/object-assign/index.js");

// TODO: this is special because it gets imported during build.
var ReactVersion = '17.0.2';

// ATTENTION
// When adding new symbols to this file,
// Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'
// The Symbol used to tag the ReactElement-like types. If there is no native Symbol
// nor polyfill, then a plain number is used for performance.
var REACT_ELEMENT_TYPE = 0xeac7;
var REACT_PORTAL_TYPE = 0xeaca;
exports.Fragment = 0xeacb;
exports.StrictMode = 0xeacc;
exports.Profiler = 0xead2;
var REACT_PROVIDER_TYPE = 0xeacd;
var REACT_CONTEXT_TYPE = 0xeace;
var REACT_FORWARD_REF_TYPE = 0xead0;
exports.Suspense = 0xead1;
var REACT_SUSPENSE_LIST_TYPE = 0xead8;
var REACT_MEMO_TYPE = 0xead3;
var REACT_LAZY_TYPE = 0xead4;
var REACT_BLOCK_TYPE = 0xead9;
var REACT_SERVER_BLOCK_TYPE = 0xeada;
var REACT_FUNDAMENTAL_TYPE = 0xead5;
var REACT_SCOPE_TYPE = 0xead7;
var REACT_OPAQUE_ID_TYPE = 0xeae0;
var REACT_DEBUG_TRACING_MODE_TYPE = 0xeae1;
var REACT_OFFSCREEN_TYPE = 0xeae2;
var REACT_LEGACY_HIDDEN_TYPE = 0xeae3;

if (typeof Symbol === 'function' && Symbol.for) {
  var symbolFor = Symbol.for;
  REACT_ELEMENT_TYPE = symbolFor('react.element');
  REACT_PORTAL_TYPE = symbolFor('react.portal');
  exports.Fragment = symbolFor('react.fragment');
  exports.StrictMode = symbolFor('react.strict_mode');
  exports.Profiler = symbolFor('react.profiler');
  REACT_PROVIDER_TYPE = symbolFor('react.provider');
  REACT_CONTEXT_TYPE = symbolFor('react.context');
  REACT_FORWARD_REF_TYPE = symbolFor('react.forward_ref');
  exports.Suspense = symbolFor('react.suspense');
  REACT_SUSPENSE_LIST_TYPE = symbolFor('react.suspense_list');
  REACT_MEMO_TYPE = symbolFor('react.memo');
  REACT_LAZY_TYPE = symbolFor('react.lazy');
  REACT_BLOCK_TYPE = symbolFor('react.block');
  REACT_SERVER_BLOCK_TYPE = symbolFor('react.server.block');
  REACT_FUNDAMENTAL_TYPE = symbolFor('react.fundamental');
  REACT_SCOPE_TYPE = symbolFor('react.scope');
  REACT_OPAQUE_ID_TYPE = symbolFor('react.opaque.id');
  REACT_DEBUG_TRACING_MODE_TYPE = symbolFor('react.debug_trace_mode');
  REACT_OFFSCREEN_TYPE = symbolFor('react.offscreen');
  REACT_LEGACY_HIDDEN_TYPE = symbolFor('react.legacy_hidden');
}

var MAYBE_ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
var FAUX_ITERATOR_SYMBOL = '@@iterator';
function getIteratorFn(maybeIterable) {
  if (maybeIterable === null || typeof maybeIterable !== 'object') {
    return null;
  }

  var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];

  if (typeof maybeIterator === 'function') {
    return maybeIterator;
  }

  return null;
}

/**
 * Keeps track of the current dispatcher.
 */
var ReactCurrentDispatcher = {
  /**
   * @internal
   * @type {ReactComponent}
   */
  current: null
};

/**
 * Keeps track of the current batch's configuration such as how long an update
 * should suspend for if it needs to.
 */
var ReactCurrentBatchConfig = {
  transition: 0
};

/**
 * Keeps track of the current owner.
 *
 * The current owner is the component who should own any components that are
 * currently being constructed.
 */
var ReactCurrentOwner = {
  /**
   * @internal
   * @type {ReactComponent}
   */
  current: null
};

var ReactDebugCurrentFrame = {};
var currentExtraStackFrame = null;
function setExtraStackFrame(stack) {
  {
    currentExtraStackFrame = stack;
  }
}

{
  ReactDebugCurrentFrame.setExtraStackFrame = function (stack) {
    {
      currentExtraStackFrame = stack;
    }
  }; // Stack implementation injected by the current renderer.


  ReactDebugCurrentFrame.getCurrentStack = null;

  ReactDebugCurrentFrame.getStackAddendum = function () {
    var stack = ''; // Add an extra top frame while an element is being validated

    if (currentExtraStackFrame) {
      stack += currentExtraStackFrame;
    } // Delegate to the injected renderer-specific implementation


    var impl = ReactDebugCurrentFrame.getCurrentStack;

    if (impl) {
      stack += impl() || '';
    }

    return stack;
  };
}

/**
 * Used by act() to track whether you're inside an act() scope.
 */
var IsSomeRendererActing = {
  current: false
};

var ReactSharedInternals = {
  ReactCurrentDispatcher: ReactCurrentDispatcher,
  ReactCurrentBatchConfig: ReactCurrentBatchConfig,
  ReactCurrentOwner: ReactCurrentOwner,
  IsSomeRendererActing: IsSomeRendererActing,
  // Used by renderers to avoid bundling object-assign twice in UMD bundles:
  assign: _assign
};

{
  ReactSharedInternals.ReactDebugCurrentFrame = ReactDebugCurrentFrame;
}

// by calls to these methods by a Babel plugin.
//
// In PROD (or in packages without access to React internals),
// they are left as they are instead.

function warn(format) {
  {
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }

    printWarning('warn', format, args);
  }
}
function error(format) {
  {
    for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
      args[_key2 - 1] = arguments[_key2];
    }

    printWarning('error', format, args);
  }
}

function printWarning(level, format, args) {
  // When changing this logic, you might want to also
  // update consoleWithStackDev.www.js as well.
  {
    var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
    var stack = ReactDebugCurrentFrame.getStackAddendum();

    if (stack !== '') {
      format += '%s';
      args = args.concat([stack]);
    }

    var argsWithFormat = args.map(function (item) {
      return '' + item;
    }); // Careful: RN currently depends on this prefix

    argsWithFormat.unshift('Warning: ' + format); // We intentionally don't use spread (or .apply) directly because it
    // breaks IE9: https://github.com/facebook/react/issues/13610
    // eslint-disable-next-line react-internal/no-production-logging

    Function.prototype.apply.call(console[level], console, argsWithFormat);
  }
}

var didWarnStateUpdateForUnmountedComponent = {};

function warnNoop(publicInstance, callerName) {
  {
    var _constructor = publicInstance.constructor;
    var componentName = _constructor && (_constructor.displayName || _constructor.name) || 'ReactClass';
    var warningKey = componentName + "." + callerName;

    if (didWarnStateUpdateForUnmountedComponent[warningKey]) {
      return;
    }

    error("Can't call %s on a component that is not yet mounted. " + 'This is a no-op, but it might indicate a bug in your application. ' + 'Instead, assign to `this.state` directly or define a `state = {};` ' + 'class property with the desired state in the %s component.', callerName, componentName);

    didWarnStateUpdateForUnmountedComponent[warningKey] = true;
  }
}
/**
 * This is the abstract API for an update queue.
 */


var ReactNoopUpdateQueue = {
  /**
   * Checks whether or not this composite component is mounted.
   * @param {ReactClass} publicInstance The instance we want to test.
   * @return {boolean} True if mounted, false otherwise.
   * @protected
   * @final
   */
  isMounted: function (publicInstance) {
    return false;
  },

  /**
   * Forces an update. This should only be invoked when it is known with
   * certainty that we are **not** in a DOM transaction.
   *
   * You may want to call this when you know that some deeper aspect of the
   * component's state has changed but `setState` was not called.
   *
   * This will not invoke `shouldComponentUpdate`, but it will invoke
   * `componentWillUpdate` and `componentDidUpdate`.
   *
   * @param {ReactClass} publicInstance The instance that should rerender.
   * @param {?function} callback Called after component is updated.
   * @param {?string} callerName name of the calling function in the public API.
   * @internal
   */
  enqueueForceUpdate: function (publicInstance, callback, callerName) {
    warnNoop(publicInstance, 'forceUpdate');
  },

  /**
   * Replaces all of the state. Always use this or `setState` to mutate state.
   * You should treat `this.state` as immutable.
   *
   * There is no guarantee that `this.state` will be immediately updated, so
   * accessing `this.state` after calling this method may return the old value.
   *
   * @param {ReactClass} publicInstance The instance that should rerender.
   * @param {object} completeState Next state.
   * @param {?function} callback Called after component is updated.
   * @param {?string} callerName name of the calling function in the public API.
   * @internal
   */
  enqueueReplaceState: function (publicInstance, completeState, callback, callerName) {
    warnNoop(publicInstance, 'replaceState');
  },

  /**
   * Sets a subset of the state. This only exists because _pendingState is
   * internal. This provides a merging strategy that is not available to deep
   * properties which is confusing. TODO: Expose pendingState or don't use it
   * during the merge.
   *
   * @param {ReactClass} publicInstance The instance that should rerender.
   * @param {object} partialState Next partial state to be merged with state.
   * @param {?function} callback Called after component is updated.
   * @param {?string} Name of the calling function in the public API.
   * @internal
   */
  enqueueSetState: function (publicInstance, partialState, callback, callerName) {
    warnNoop(publicInstance, 'setState');
  }
};

var emptyObject = {};

{
  Object.freeze(emptyObject);
}
/**
 * Base class helpers for the updating state of a component.
 */


function Component(props, context, updater) {
  this.props = props;
  this.context = context; // If a component has string refs, we will assign a different object later.

  this.refs = emptyObject; // We initialize the default updater but the real one gets injected by the
  // renderer.

  this.updater = updater || ReactNoopUpdateQueue;
}

Component.prototype.isReactComponent = {};
/**
 * Sets a subset of the state. Always use this to mutate
 * state. You should treat `this.state` as immutable.
 *
 * There is no guarantee that `this.state` will be immediately updated, so
 * accessing `this.state` after calling this method may return the old value.
 *
 * There is no guarantee that calls to `setState` will run synchronously,
 * as they may eventually be batched together.  You can provide an optional
 * callback that will be executed when the call to setState is actually
 * completed.
 *
 * When a function is provided to setState, it will be called at some point in
 * the future (not synchronously). It will be called with the up to date
 * component arguments (state, props, context). These values can be different
 * from this.* because your function may be called after receiveProps but before
 * shouldComponentUpdate, and this new state, props, and context will not yet be
 * assigned to this.
 *
 * @param {object|function} partialState Next partial state or function to
 *        produce next partial state to be merged with current state.
 * @param {?function} callback Called after state is updated.
 * @final
 * @protected
 */

Component.prototype.setState = function (partialState, callback) {
  if (!(typeof partialState === 'object' || typeof partialState === 'function' || partialState == null)) {
    {
      throw Error( "setState(...): takes an object of state variables to update or a function which returns an object of state variables." );
    }
  }

  this.updater.enqueueSetState(this, partialState, callback, 'setState');
};
/**
 * Forces an update. This should only be invoked when it is known with
 * certainty that we are **not** in a DOM transaction.
 *
 * You may want to call this when you know that some deeper aspect of the
 * component's state has changed but `setState` was not called.
 *
 * This will not invoke `shouldComponentUpdate`, but it will invoke
 * `componentWillUpdate` and `componentDidUpdate`.
 *
 * @param {?function} callback Called after update is complete.
 * @final
 * @protected
 */


Component.prototype.forceUpdate = function (callback) {
  this.updater.enqueueForceUpdate(this, callback, 'forceUpdate');
};
/**
 * Deprecated APIs. These APIs used to exist on classic React classes but since
 * we would like to deprecate them, we're not going to move them over to this
 * modern base class. Instead, we define a getter that warns if it's accessed.
 */


{
  var deprecatedAPIs = {
    isMounted: ['isMounted', 'Instead, make sure to clean up subscriptions and pending requests in ' + 'componentWillUnmount to prevent memory leaks.'],
    replaceState: ['replaceState', 'Refactor your code to use setState instead (see ' + 'https://github.com/facebook/react/issues/3236).']
  };

  var defineDeprecationWarning = function (methodName, info) {
    Object.defineProperty(Component.prototype, methodName, {
      get: function () {
        warn('%s(...) is deprecated in plain JavaScript React classes. %s', info[0], info[1]);

        return undefined;
      }
    });
  };

  for (var fnName in deprecatedAPIs) {
    if (deprecatedAPIs.hasOwnProperty(fnName)) {
      defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);
    }
  }
}

function ComponentDummy() {}

ComponentDummy.prototype = Component.prototype;
/**
 * Convenience component with default shallow equality check for sCU.
 */

function PureComponent(props, context, updater) {
  this.props = props;
  this.context = context; // If a component has string refs, we will assign a different object later.

  this.refs = emptyObject;
  this.updater = updater || ReactNoopUpdateQueue;
}

var pureComponentPrototype = PureComponent.prototype = new ComponentDummy();
pureComponentPrototype.constructor = PureComponent; // Avoid an extra prototype jump for these methods.

_assign(pureComponentPrototype, Component.prototype);

pureComponentPrototype.isPureReactComponent = true;

// an immutable object with a single mutable value
function createRef() {
  var refObject = {
    current: null
  };

  {
    Object.seal(refObject);
  }

  return refObject;
}

function getWrappedName(outerType, innerType, wrapperName) {
  var functionName = innerType.displayName || innerType.name || '';
  return outerType.displayName || (functionName !== '' ? wrapperName + "(" + functionName + ")" : wrapperName);
}

function getContextName(type) {
  return type.displayName || 'Context';
}

function getComponentName(type) {
  if (type == null) {
    // Host root, text node or just invalid type.
    return null;
  }

  {
    if (typeof type.tag === 'number') {
      error('Received an unexpected object in getComponentName(). ' + 'This is likely a bug in React. Please file an issue.');
    }
  }

  if (typeof type === 'function') {
    return type.displayName || type.name || null;
  }

  if (typeof type === 'string') {
    return type;
  }

  switch (type) {
    case exports.Fragment:
      return 'Fragment';

    case REACT_PORTAL_TYPE:
      return 'Portal';

    case exports.Profiler:
      return 'Profiler';

    case exports.StrictMode:
      return 'StrictMode';

    case exports.Suspense:
      return 'Suspense';

    case REACT_SUSPENSE_LIST_TYPE:
      return 'SuspenseList';
  }

  if (typeof type === 'object') {
    switch (type.$$typeof) {
      case REACT_CONTEXT_TYPE:
        var context = type;
        return getContextName(context) + '.Consumer';

      case REACT_PROVIDER_TYPE:
        var provider = type;
        return getContextName(provider._context) + '.Provider';

      case REACT_FORWARD_REF_TYPE:
        return getWrappedName(type, type.render, 'ForwardRef');

      case REACT_MEMO_TYPE:
        return getComponentName(type.type);

      case REACT_BLOCK_TYPE:
        return getComponentName(type._render);

      case REACT_LAZY_TYPE:
        {
          var lazyComponent = type;
          var payload = lazyComponent._payload;
          var init = lazyComponent._init;

          try {
            return getComponentName(init(payload));
          } catch (x) {
            return null;
          }
        }
    }
  }

  return null;
}

var hasOwnProperty = Object.prototype.hasOwnProperty;
var RESERVED_PROPS = {
  key: true,
  ref: true,
  __self: true,
  __source: true
};
var specialPropKeyWarningShown, specialPropRefWarningShown, didWarnAboutStringRefs;

{
  didWarnAboutStringRefs = {};
}

function hasValidRef(config) {
  {
    if (hasOwnProperty.call(config, 'ref')) {
      var getter = Object.getOwnPropertyDescriptor(config, 'ref').get;

      if (getter && getter.isReactWarning) {
        return false;
      }
    }
  }

  return config.ref !== undefined;
}

function hasValidKey(config) {
  {
    if (hasOwnProperty.call(config, 'key')) {
      var getter = Object.getOwnPropertyDescriptor(config, 'key').get;

      if (getter && getter.isReactWarning) {
        return false;
      }
    }
  }

  return config.key !== undefined;
}

function defineKeyPropWarningGetter(props, displayName) {
  var warnAboutAccessingKey = function () {
    {
      if (!specialPropKeyWarningShown) {
        specialPropKeyWarningShown = true;

        error('%s: `key` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);
      }
    }
  };

  warnAboutAccessingKey.isReactWarning = true;
  Object.defineProperty(props, 'key', {
    get: warnAboutAccessingKey,
    configurable: true
  });
}

function defineRefPropWarningGetter(props, displayName) {
  var warnAboutAccessingRef = function () {
    {
      if (!specialPropRefWarningShown) {
        specialPropRefWarningShown = true;

        error('%s: `ref` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);
      }
    }
  };

  warnAboutAccessingRef.isReactWarning = true;
  Object.defineProperty(props, 'ref', {
    get: warnAboutAccessingRef,
    configurable: true
  });
}

function warnIfStringRefCannotBeAutoConverted(config) {
  {
    if (typeof config.ref === 'string' && ReactCurrentOwner.current && config.__self && ReactCurrentOwner.current.stateNode !== config.__self) {
      var componentName = getComponentName(ReactCurrentOwner.current.type);

      if (!didWarnAboutStringRefs[componentName]) {
        error('Component "%s" contains the string ref "%s". ' + 'Support for string refs will be removed in a future major release. ' + 'This case cannot be automatically converted to an arrow function. ' + 'We ask you to manually fix this case by using useRef() or createRef() instead. ' + 'Learn more about using refs safely here: ' + 'https://reactjs.org/link/strict-mode-string-ref', componentName, config.ref);

        didWarnAboutStringRefs[componentName] = true;
      }
    }
  }
}
/**
 * Factory method to create a new React element. This no longer adheres to
 * the class pattern, so do not use new to call it. Also, instanceof check
 * will not work. Instead test $$typeof field against Symbol.for('react.element') to check
 * if something is a React Element.
 *
 * @param {*} type
 * @param {*} props
 * @param {*} key
 * @param {string|object} ref
 * @param {*} owner
 * @param {*} self A *temporary* helper to detect places where `this` is
 * different from the `owner` when React.createElement is called, so that we
 * can warn. We want to get rid of owner and replace string `ref`s with arrow
 * functions, and as long as `this` and owner are the same, there will be no
 * change in behavior.
 * @param {*} source An annotation object (added by a transpiler or otherwise)
 * indicating filename, line number, and/or other information.
 * @internal
 */


var ReactElement = function (type, key, ref, self, source, owner, props) {
  var element = {
    // This tag allows us to uniquely identify this as a React Element
    $$typeof: REACT_ELEMENT_TYPE,
    // Built-in properties that belong on the element
    type: type,
    key: key,
    ref: ref,
    props: props,
    // Record the component responsible for creating this element.
    _owner: owner
  };

  {
    // The validation flag is currently mutative. We put it on
    // an external backing store so that we can freeze the whole object.
    // This can be replaced with a WeakMap once they are implemented in
    // commonly used development environments.
    element._store = {}; // To make comparing ReactElements easier for testing purposes, we make
    // the validation flag non-enumerable (where possible, which should
    // include every environment we run tests in), so the test framework
    // ignores it.

    Object.defineProperty(element._store, 'validated', {
      configurable: false,
      enumerable: false,
      writable: true,
      value: false
    }); // self and source are DEV only properties.

    Object.defineProperty(element, '_self', {
      configurable: false,
      enumerable: false,
      writable: false,
      value: self
    }); // Two elements created in two different places should be considered
    // equal for testing purposes and therefore we hide it from enumeration.

    Object.defineProperty(element, '_source', {
      configurable: false,
      enumerable: false,
      writable: false,
      value: source
    });

    if (Object.freeze) {
      Object.freeze(element.props);
      Object.freeze(element);
    }
  }

  return element;
};
/**
 * Create and return a new ReactElement of the given type.
 * See https://reactjs.org/docs/react-api.html#createelement
 */

function createElement(type, config, children) {
  var propName; // Reserved names are extracted

  var props = {};
  var key = null;
  var ref = null;
  var self = null;
  var source = null;

  if (config != null) {
    if (hasValidRef(config)) {
      ref = config.ref;

      {
        warnIfStringRefCannotBeAutoConverted(config);
      }
    }

    if (hasValidKey(config)) {
      key = '' + config.key;
    }

    self = config.__self === undefined ? null : config.__self;
    source = config.__source === undefined ? null : config.__source; // Remaining properties are added to a new props object

    for (propName in config) {
      if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
        props[propName] = config[propName];
      }
    }
  } // Children can be more than one argument, and those are transferred onto
  // the newly allocated props object.


  var childrenLength = arguments.length - 2;

  if (childrenLength === 1) {
    props.children = children;
  } else if (childrenLength > 1) {
    var childArray = Array(childrenLength);

    for (var i = 0; i < childrenLength; i++) {
      childArray[i] = arguments[i + 2];
    }

    {
      if (Object.freeze) {
        Object.freeze(childArray);
      }
    }

    props.children = childArray;
  } // Resolve default props


  if (type && type.defaultProps) {
    var defaultProps = type.defaultProps;

    for (propName in defaultProps) {
      if (props[propName] === undefined) {
        props[propName] = defaultProps[propName];
      }
    }
  }

  {
    if (key || ref) {
      var displayName = typeof type === 'function' ? type.displayName || type.name || 'Unknown' : type;

      if (key) {
        defineKeyPropWarningGetter(props, displayName);
      }

      if (ref) {
        defineRefPropWarningGetter(props, displayName);
      }
    }
  }

  return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);
}
function cloneAndReplaceKey(oldElement, newKey) {
  var newElement = ReactElement(oldElement.type, newKey, oldElement.ref, oldElement._self, oldElement._source, oldElement._owner, oldElement.props);
  return newElement;
}
/**
 * Clone and return a new ReactElement using element as the starting point.
 * See https://reactjs.org/docs/react-api.html#cloneelement
 */

function cloneElement(element, config, children) {
  if (!!(element === null || element === undefined)) {
    {
      throw Error( "React.cloneElement(...): The argument must be a React element, but you passed " + element + "." );
    }
  }

  var propName; // Original props are copied

  var props = _assign({}, element.props); // Reserved names are extracted


  var key = element.key;
  var ref = element.ref; // Self is preserved since the owner is preserved.

  var self = element._self; // Source is preserved since cloneElement is unlikely to be targeted by a
  // transpiler, and the original source is probably a better indicator of the
  // true owner.

  var source = element._source; // Owner will be preserved, unless ref is overridden

  var owner = element._owner;

  if (config != null) {
    if (hasValidRef(config)) {
      // Silently steal the ref from the parent.
      ref = config.ref;
      owner = ReactCurrentOwner.current;
    }

    if (hasValidKey(config)) {
      key = '' + config.key;
    } // Remaining properties override existing props


    var defaultProps;

    if (element.type && element.type.defaultProps) {
      defaultProps = element.type.defaultProps;
    }

    for (propName in config) {
      if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
        if (config[propName] === undefined && defaultProps !== undefined) {
          // Resolve default props
          props[propName] = defaultProps[propName];
        } else {
          props[propName] = config[propName];
        }
      }
    }
  } // Children can be more than one argument, and those are transferred onto
  // the newly allocated props object.


  var childrenLength = arguments.length - 2;

  if (childrenLength === 1) {
    props.children = children;
  } else if (childrenLength > 1) {
    var childArray = Array(childrenLength);

    for (var i = 0; i < childrenLength; i++) {
      childArray[i] = arguments[i + 2];
    }

    props.children = childArray;
  }

  return ReactElement(element.type, key, ref, self, source, owner, props);
}
/**
 * Verifies the object is a ReactElement.
 * See https://reactjs.org/docs/react-api.html#isvalidelement
 * @param {?object} object
 * @return {boolean} True if `object` is a ReactElement.
 * @final
 */

function isValidElement(object) {
  return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
}

var SEPARATOR = '.';
var SUBSEPARATOR = ':';
/**
 * Escape and wrap key so it is safe to use as a reactid
 *
 * @param {string} key to be escaped.
 * @return {string} the escaped key.
 */

function escape(key) {
  var escapeRegex = /[=:]/g;
  var escaperLookup = {
    '=': '=0',
    ':': '=2'
  };
  var escapedString = key.replace(escapeRegex, function (match) {
    return escaperLookup[match];
  });
  return '$' + escapedString;
}
/**
 * TODO: Test that a single child and an array with one item have the same key
 * pattern.
 */


var didWarnAboutMaps = false;
var userProvidedKeyEscapeRegex = /\/+/g;

function escapeUserProvidedKey(text) {
  return text.replace(userProvidedKeyEscapeRegex, '$&/');
}
/**
 * Generate a key string that identifies a element within a set.
 *
 * @param {*} element A element that could contain a manual key.
 * @param {number} index Index that is used if a manual key is not provided.
 * @return {string}
 */


function getElementKey(element, index) {
  // Do some typechecking here since we call this blindly. We want to ensure
  // that we don't block potential future ES APIs.
  if (typeof element === 'object' && element !== null && element.key != null) {
    // Explicit key
    return escape('' + element.key);
  } // Implicit key determined by the index in the set


  return index.toString(36);
}

function mapIntoArray(children, array, escapedPrefix, nameSoFar, callback) {
  var type = typeof children;

  if (type === 'undefined' || type === 'boolean') {
    // All of the above are perceived as null.
    children = null;
  }

  var invokeCallback = false;

  if (children === null) {
    invokeCallback = true;
  } else {
    switch (type) {
      case 'string':
      case 'number':
        invokeCallback = true;
        break;

      case 'object':
        switch (children.$$typeof) {
          case REACT_ELEMENT_TYPE:
          case REACT_PORTAL_TYPE:
            invokeCallback = true;
        }

    }
  }

  if (invokeCallback) {
    var _child = children;
    var mappedChild = callback(_child); // If it's the only child, treat the name as if it was wrapped in an array
    // so that it's consistent if the number of children grows:

    var childKey = nameSoFar === '' ? SEPARATOR + getElementKey(_child, 0) : nameSoFar;

    if (Array.isArray(mappedChild)) {
      var escapedChildKey = '';

      if (childKey != null) {
        escapedChildKey = escapeUserProvidedKey(childKey) + '/';
      }

      mapIntoArray(mappedChild, array, escapedChildKey, '', function (c) {
        return c;
      });
    } else if (mappedChild != null) {
      if (isValidElement(mappedChild)) {
        mappedChild = cloneAndReplaceKey(mappedChild, // Keep both the (mapped) and old keys if they differ, just as
        // traverseAllChildren used to do for objects as children
        escapedPrefix + ( // $FlowFixMe Flow incorrectly thinks React.Portal doesn't have a key
        mappedChild.key && (!_child || _child.key !== mappedChild.key) ? // $FlowFixMe Flow incorrectly thinks existing element's key can be a number
        escapeUserProvidedKey('' + mappedChild.key) + '/' : '') + childKey);
      }

      array.push(mappedChild);
    }

    return 1;
  }

  var child;
  var nextName;
  var subtreeCount = 0; // Count of children found in the current subtree.

  var nextNamePrefix = nameSoFar === '' ? SEPARATOR : nameSoFar + SUBSEPARATOR;

  if (Array.isArray(children)) {
    for (var i = 0; i < children.length; i++) {
      child = children[i];
      nextName = nextNamePrefix + getElementKey(child, i);
      subtreeCount += mapIntoArray(child, array, escapedPrefix, nextName, callback);
    }
  } else {
    var iteratorFn = getIteratorFn(children);

    if (typeof iteratorFn === 'function') {
      var iterableChildren = children;

      {
        // Warn about using Maps as children
        if (iteratorFn === iterableChildren.entries) {
          if (!didWarnAboutMaps) {
            warn('Using Maps as children is not supported. ' + 'Use an array of keyed ReactElements instead.');
          }

          didWarnAboutMaps = true;
        }
      }

      var iterator = iteratorFn.call(iterableChildren);
      var step;
      var ii = 0;

      while (!(step = iterator.next()).done) {
        child = step.value;
        nextName = nextNamePrefix + getElementKey(child, ii++);
        subtreeCount += mapIntoArray(child, array, escapedPrefix, nextName, callback);
      }
    } else if (type === 'object') {
      var childrenString = '' + children;

      {
        {
          throw Error( "Objects are not valid as a React child (found: " + (childrenString === '[object Object]' ? 'object with keys {' + Object.keys(children).join(', ') + '}' : childrenString) + "). If you meant to render a collection of children, use an array instead." );
        }
      }
    }
  }

  return subtreeCount;
}

/**
 * Maps children that are typically specified as `props.children`.
 *
 * See https://reactjs.org/docs/react-api.html#reactchildrenmap
 *
 * The provided mapFunction(child, index) will be called for each
 * leaf child.
 *
 * @param {?*} children Children tree container.
 * @param {function(*, int)} func The map function.
 * @param {*} context Context for mapFunction.
 * @return {object} Object containing the ordered map of results.
 */
function mapChildren(children, func, context) {
  if (children == null) {
    return children;
  }

  var result = [];
  var count = 0;
  mapIntoArray(children, result, '', '', function (child) {
    return func.call(context, child, count++);
  });
  return result;
}
/**
 * Count the number of children that are typically specified as
 * `props.children`.
 *
 * See https://reactjs.org/docs/react-api.html#reactchildrencount
 *
 * @param {?*} children Children tree container.
 * @return {number} The number of children.
 */


function countChildren(children) {
  var n = 0;
  mapChildren(children, function () {
    n++; // Don't return anything
  });
  return n;
}

/**
 * Iterates through children that are typically specified as `props.children`.
 *
 * See https://reactjs.org/docs/react-api.html#reactchildrenforeach
 *
 * The provided forEachFunc(child, index) will be called for each
 * leaf child.
 *
 * @param {?*} children Children tree container.
 * @param {function(*, int)} forEachFunc
 * @param {*} forEachContext Context for forEachContext.
 */
function forEachChildren(children, forEachFunc, forEachContext) {
  mapChildren(children, function () {
    forEachFunc.apply(this, arguments); // Don't return anything.
  }, forEachContext);
}
/**
 * Flatten a children object (typically specified as `props.children`) and
 * return an array with appropriately re-keyed children.
 *
 * See https://reactjs.org/docs/react-api.html#reactchildrentoarray
 */


function toArray(children) {
  return mapChildren(children, function (child) {
    return child;
  }) || [];
}
/**
 * Returns the first child in a collection of children and verifies that there
 * is only one child in the collection.
 *
 * See https://reactjs.org/docs/react-api.html#reactchildrenonly
 *
 * The current implementation of this function assumes that a single child gets
 * passed without a wrapper, but the purpose of this helper function is to
 * abstract away the particular structure of children.
 *
 * @param {?object} children Child collection structure.
 * @return {ReactElement} The first and only `ReactElement` contained in the
 * structure.
 */


function onlyChild(children) {
  if (!isValidElement(children)) {
    {
      throw Error( "React.Children.only expected to receive a single React element child." );
    }
  }

  return children;
}

function createContext(defaultValue, calculateChangedBits) {
  if (calculateChangedBits === undefined) {
    calculateChangedBits = null;
  } else {
    {
      if (calculateChangedBits !== null && typeof calculateChangedBits !== 'function') {
        error('createContext: Expected the optional second argument to be a ' + 'function. Instead received: %s', calculateChangedBits);
      }
    }
  }

  var context = {
    $$typeof: REACT_CONTEXT_TYPE,
    _calculateChangedBits: calculateChangedBits,
    // As a workaround to support multiple concurrent renderers, we categorize
    // some renderers as primary and others as secondary. We only expect
    // there to be two concurrent renderers at most: React Native (primary) and
    // Fabric (secondary); React DOM (primary) and React ART (secondary).
    // Secondary renderers store their context values on separate fields.
    _currentValue: defaultValue,
    _currentValue2: defaultValue,
    // Used to track how many concurrent renderers this context currently
    // supports within in a single renderer. Such as parallel server rendering.
    _threadCount: 0,
    // These are circular
    Provider: null,
    Consumer: null
  };
  context.Provider = {
    $$typeof: REACT_PROVIDER_TYPE,
    _context: context
  };
  var hasWarnedAboutUsingNestedContextConsumers = false;
  var hasWarnedAboutUsingConsumerProvider = false;
  var hasWarnedAboutDisplayNameOnConsumer = false;

  {
    // A separate object, but proxies back to the original context object for
    // backwards compatibility. It has a different $$typeof, so we can properly
    // warn for the incorrect usage of Context as a Consumer.
    var Consumer = {
      $$typeof: REACT_CONTEXT_TYPE,
      _context: context,
      _calculateChangedBits: context._calculateChangedBits
    }; // $FlowFixMe: Flow complains about not setting a value, which is intentional here

    Object.defineProperties(Consumer, {
      Provider: {
        get: function () {
          if (!hasWarnedAboutUsingConsumerProvider) {
            hasWarnedAboutUsingConsumerProvider = true;

            error('Rendering <Context.Consumer.Provider> is not supported and will be removed in ' + 'a future major release. Did you mean to render <Context.Provider> instead?');
          }

          return context.Provider;
        },
        set: function (_Provider) {
          context.Provider = _Provider;
        }
      },
      _currentValue: {
        get: function () {
          return context._currentValue;
        },
        set: function (_currentValue) {
          context._currentValue = _currentValue;
        }
      },
      _currentValue2: {
        get: function () {
          return context._currentValue2;
        },
        set: function (_currentValue2) {
          context._currentValue2 = _currentValue2;
        }
      },
      _threadCount: {
        get: function () {
          return context._threadCount;
        },
        set: function (_threadCount) {
          context._threadCount = _threadCount;
        }
      },
      Consumer: {
        get: function () {
          if (!hasWarnedAboutUsingNestedContextConsumers) {
            hasWarnedAboutUsingNestedContextConsumers = true;

            error('Rendering <Context.Consumer.Consumer> is not supported and will be removed in ' + 'a future major release. Did you mean to render <Context.Consumer> instead?');
          }

          return context.Consumer;
        }
      },
      displayName: {
        get: function () {
          return context.displayName;
        },
        set: function (displayName) {
          if (!hasWarnedAboutDisplayNameOnConsumer) {
            warn('Setting `displayName` on Context.Consumer has no effect. ' + "You should set it directly on the context with Context.displayName = '%s'.", displayName);

            hasWarnedAboutDisplayNameOnConsumer = true;
          }
        }
      }
    }); // $FlowFixMe: Flow complains about missing properties because it doesn't understand defineProperty

    context.Consumer = Consumer;
  }

  {
    context._currentRenderer = null;
    context._currentRenderer2 = null;
  }

  return context;
}

var Uninitialized = -1;
var Pending = 0;
var Resolved = 1;
var Rejected = 2;

function lazyInitializer(payload) {
  if (payload._status === Uninitialized) {
    var ctor = payload._result;
    var thenable = ctor(); // Transition to the next state.

    var pending = payload;
    pending._status = Pending;
    pending._result = thenable;
    thenable.then(function (moduleObject) {
      if (payload._status === Pending) {
        var defaultExport = moduleObject.default;

        {
          if (defaultExport === undefined) {
            error('lazy: Expected the result of a dynamic import() call. ' + 'Instead received: %s\n\nYour code should look like: \n  ' + // Break up imports to avoid accidentally parsing them as dependencies.
            'const MyComponent = lazy(() => imp' + "ort('./MyComponent'))", moduleObject);
          }
        } // Transition to the next state.


        var resolved = payload;
        resolved._status = Resolved;
        resolved._result = defaultExport;
      }
    }, function (error) {
      if (payload._status === Pending) {
        // Transition to the next state.
        var rejected = payload;
        rejected._status = Rejected;
        rejected._result = error;
      }
    });
  }

  if (payload._status === Resolved) {
    return payload._result;
  } else {
    throw payload._result;
  }
}

function lazy(ctor) {
  var payload = {
    // We use these fields to store the result.
    _status: -1,
    _result: ctor
  };
  var lazyType = {
    $$typeof: REACT_LAZY_TYPE,
    _payload: payload,
    _init: lazyInitializer
  };

  {
    // In production, this would just set it on the object.
    var defaultProps;
    var propTypes; // $FlowFixMe

    Object.defineProperties(lazyType, {
      defaultProps: {
        configurable: true,
        get: function () {
          return defaultProps;
        },
        set: function (newDefaultProps) {
          error('React.lazy(...): It is not supported to assign `defaultProps` to ' + 'a lazy component import. Either specify them where the component ' + 'is defined, or create a wrapping component around it.');

          defaultProps = newDefaultProps; // Match production behavior more closely:
          // $FlowFixMe

          Object.defineProperty(lazyType, 'defaultProps', {
            enumerable: true
          });
        }
      },
      propTypes: {
        configurable: true,
        get: function () {
          return propTypes;
        },
        set: function (newPropTypes) {
          error('React.lazy(...): It is not supported to assign `propTypes` to ' + 'a lazy component import. Either specify them where the component ' + 'is defined, or create a wrapping component around it.');

          propTypes = newPropTypes; // Match production behavior more closely:
          // $FlowFixMe

          Object.defineProperty(lazyType, 'propTypes', {
            enumerable: true
          });
        }
      }
    });
  }

  return lazyType;
}

function forwardRef(render) {
  {
    if (render != null && render.$$typeof === REACT_MEMO_TYPE) {
      error('forwardRef requires a render function but received a `memo` ' + 'component. Instead of forwardRef(memo(...)), use ' + 'memo(forwardRef(...)).');
    } else if (typeof render !== 'function') {
      error('forwardRef requires a render function but was given %s.', render === null ? 'null' : typeof render);
    } else {
      if (render.length !== 0 && render.length !== 2) {
        error('forwardRef render functions accept exactly two parameters: props and ref. %s', render.length === 1 ? 'Did you forget to use the ref parameter?' : 'Any additional parameter will be undefined.');
      }
    }

    if (render != null) {
      if (render.defaultProps != null || render.propTypes != null) {
        error('forwardRef render functions do not support propTypes or defaultProps. ' + 'Did you accidentally pass a React component?');
      }
    }
  }

  var elementType = {
    $$typeof: REACT_FORWARD_REF_TYPE,
    render: render
  };

  {
    var ownName;
    Object.defineProperty(elementType, 'displayName', {
      enumerable: false,
      configurable: true,
      get: function () {
        return ownName;
      },
      set: function (name) {
        ownName = name;

        if (render.displayName == null) {
          render.displayName = name;
        }
      }
    });
  }

  return elementType;
}

// Filter certain DOM attributes (e.g. src, href) if their values are empty strings.

var enableScopeAPI = false; // Experimental Create Event Handle API.

function isValidElementType(type) {
  if (typeof type === 'string' || typeof type === 'function') {
    return true;
  } // Note: typeof might be other than 'symbol' or 'number' (e.g. if it's a polyfill).


  if (type === exports.Fragment || type === exports.Profiler || type === REACT_DEBUG_TRACING_MODE_TYPE || type === exports.StrictMode || type === exports.Suspense || type === REACT_SUSPENSE_LIST_TYPE || type === REACT_LEGACY_HIDDEN_TYPE || enableScopeAPI ) {
    return true;
  }

  if (typeof type === 'object' && type !== null) {
    if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_BLOCK_TYPE || type[0] === REACT_SERVER_BLOCK_TYPE) {
      return true;
    }
  }

  return false;
}

function memo(type, compare) {
  {
    if (!isValidElementType(type)) {
      error('memo: The first argument must be a component. Instead ' + 'received: %s', type === null ? 'null' : typeof type);
    }
  }

  var elementType = {
    $$typeof: REACT_MEMO_TYPE,
    type: type,
    compare: compare === undefined ? null : compare
  };

  {
    var ownName;
    Object.defineProperty(elementType, 'displayName', {
      enumerable: false,
      configurable: true,
      get: function () {
        return ownName;
      },
      set: function (name) {
        ownName = name;

        if (type.displayName == null) {
          type.displayName = name;
        }
      }
    });
  }

  return elementType;
}

function resolveDispatcher() {
  var dispatcher = ReactCurrentDispatcher.current;

  if (!(dispatcher !== null)) {
    {
      throw Error( "Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem." );
    }
  }

  return dispatcher;
}

function useContext(Context, unstable_observedBits) {
  var dispatcher = resolveDispatcher();

  {
    if (unstable_observedBits !== undefined) {
      error('useContext() second argument is reserved for future ' + 'use in React. Passing it is not supported. ' + 'You passed: %s.%s', unstable_observedBits, typeof unstable_observedBits === 'number' && Array.isArray(arguments[2]) ? '\n\nDid you call array.map(useContext)? ' + 'Calling Hooks inside a loop is not supported. ' + 'Learn more at https://reactjs.org/link/rules-of-hooks' : '');
    } // TODO: add a more generic warning for invalid values.


    if (Context._context !== undefined) {
      var realContext = Context._context; // Don't deduplicate because this legitimately causes bugs
      // and nobody should be using this in existing code.

      if (realContext.Consumer === Context) {
        error('Calling useContext(Context.Consumer) is not supported, may cause bugs, and will be ' + 'removed in a future major release. Did you mean to call useContext(Context) instead?');
      } else if (realContext.Provider === Context) {
        error('Calling useContext(Context.Provider) is not supported. ' + 'Did you mean to call useContext(Context) instead?');
      }
    }
  }

  return dispatcher.useContext(Context, unstable_observedBits);
}
function useState(initialState) {
  var dispatcher = resolveDispatcher();
  return dispatcher.useState(initialState);
}
function useReducer(reducer, initialArg, init) {
  var dispatcher = resolveDispatcher();
  return dispatcher.useReducer(reducer, initialArg, init);
}
function useRef(initialValue) {
  var dispatcher = resolveDispatcher();
  return dispatcher.useRef(initialValue);
}
function useEffect(create, deps) {
  var dispatcher = resolveDispatcher();
  return dispatcher.useEffect(create, deps);
}
function useLayoutEffect(create, deps) {
  var dispatcher = resolveDispatcher();
  return dispatcher.useLayoutEffect(create, deps);
}
function useCallback(callback, deps) {
  var dispatcher = resolveDispatcher();
  return dispatcher.useCallback(callback, deps);
}
function useMemo(create, deps) {
  var dispatcher = resolveDispatcher();
  return dispatcher.useMemo(create, deps);
}
function useImperativeHandle(ref, create, deps) {
  var dispatcher = resolveDispatcher();
  return dispatcher.useImperativeHandle(ref, create, deps);
}
function useDebugValue(value, formatterFn) {
  {
    var dispatcher = resolveDispatcher();
    return dispatcher.useDebugValue(value, formatterFn);
  }
}

// Helpers to patch console.logs to avoid logging during side-effect free
// replaying on render function. This currently only patches the object
// lazily which won't cover if the log function was extracted eagerly.
// We could also eagerly patch the method.
var disabledDepth = 0;
var prevLog;
var prevInfo;
var prevWarn;
var prevError;
var prevGroup;
var prevGroupCollapsed;
var prevGroupEnd;

function disabledLog() {}

disabledLog.__reactDisabledLog = true;
function disableLogs() {
  {
    if (disabledDepth === 0) {
      /* eslint-disable react-internal/no-production-logging */
      prevLog = console.log;
      prevInfo = console.info;
      prevWarn = console.warn;
      prevError = console.error;
      prevGroup = console.group;
      prevGroupCollapsed = console.groupCollapsed;
      prevGroupEnd = console.groupEnd; // https://github.com/facebook/react/issues/19099

      var props = {
        configurable: true,
        enumerable: true,
        value: disabledLog,
        writable: true
      }; // $FlowFixMe Flow thinks console is immutable.

      Object.defineProperties(console, {
        info: props,
        log: props,
        warn: props,
        error: props,
        group: props,
        groupCollapsed: props,
        groupEnd: props
      });
      /* eslint-enable react-internal/no-production-logging */
    }

    disabledDepth++;
  }
}
function reenableLogs() {
  {
    disabledDepth--;

    if (disabledDepth === 0) {
      /* eslint-disable react-internal/no-production-logging */
      var props = {
        configurable: true,
        enumerable: true,
        writable: true
      }; // $FlowFixMe Flow thinks console is immutable.

      Object.defineProperties(console, {
        log: _assign({}, props, {
          value: prevLog
        }),
        info: _assign({}, props, {
          value: prevInfo
        }),
        warn: _assign({}, props, {
          value: prevWarn
        }),
        error: _assign({}, props, {
          value: prevError
        }),
        group: _assign({}, props, {
          value: prevGroup
        }),
        groupCollapsed: _assign({}, props, {
          value: prevGroupCollapsed
        }),
        groupEnd: _assign({}, props, {
          value: prevGroupEnd
        })
      });
      /* eslint-enable react-internal/no-production-logging */
    }

    if (disabledDepth < 0) {
      error('disabledDepth fell below zero. ' + 'This is a bug in React. Please file an issue.');
    }
  }
}

var ReactCurrentDispatcher$1 = ReactSharedInternals.ReactCurrentDispatcher;
var prefix;
function describeBuiltInComponentFrame(name, source, ownerFn) {
  {
    if (prefix === undefined) {
      // Extract the VM specific prefix used by each line.
      try {
        throw Error();
      } catch (x) {
        var match = x.stack.trim().match(/\n( *(at )?)/);
        prefix = match && match[1] || '';
      }
    } // We use the prefix to ensure our stacks line up with native stack frames.


    return '\n' + prefix + name;
  }
}
var reentry = false;
var componentFrameCache;

{
  var PossiblyWeakMap = typeof WeakMap === 'function' ? WeakMap : Map;
  componentFrameCache = new PossiblyWeakMap();
}

function describeNativeComponentFrame(fn, construct) {
  // If something asked for a stack inside a fake render, it should get ignored.
  if (!fn || reentry) {
    return '';
  }

  {
    var frame = componentFrameCache.get(fn);

    if (frame !== undefined) {
      return frame;
    }
  }

  var control;
  reentry = true;
  var previousPrepareStackTrace = Error.prepareStackTrace; // $FlowFixMe It does accept undefined.

  Error.prepareStackTrace = undefined;
  var previousDispatcher;

  {
    previousDispatcher = ReactCurrentDispatcher$1.current; // Set the dispatcher in DEV because this might be call in the render function
    // for warnings.

    ReactCurrentDispatcher$1.current = null;
    disableLogs();
  }

  try {
    // This should throw.
    if (construct) {
      // Something should be setting the props in the constructor.
      var Fake = function () {
        throw Error();
      }; // $FlowFixMe


      Object.defineProperty(Fake.prototype, 'props', {
        set: function () {
          // We use a throwing setter instead of frozen or non-writable props
          // because that won't throw in a non-strict mode function.
          throw Error();
        }
      });

      if (typeof Reflect === 'object' && Reflect.construct) {
        // We construct a different control for this case to include any extra
        // frames added by the construct call.
        try {
          Reflect.construct(Fake, []);
        } catch (x) {
          control = x;
        }

        Reflect.construct(fn, [], Fake);
      } else {
        try {
          Fake.call();
        } catch (x) {
          control = x;
        }

        fn.call(Fake.prototype);
      }
    } else {
      try {
        throw Error();
      } catch (x) {
        control = x;
      }

      fn();
    }
  } catch (sample) {
    // This is inlined manually because closure doesn't do it for us.
    if (sample && control && typeof sample.stack === 'string') {
      // This extracts the first frame from the sample that isn't also in the control.
      // Skipping one frame that we assume is the frame that calls the two.
      var sampleLines = sample.stack.split('\n');
      var controlLines = control.stack.split('\n');
      var s = sampleLines.length - 1;
      var c = controlLines.length - 1;

      while (s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]) {
        // We expect at least one stack frame to be shared.
        // Typically this will be the root most one. However, stack frames may be
        // cut off due to maximum stack limits. In this case, one maybe cut off
        // earlier than the other. We assume that the sample is longer or the same
        // and there for cut off earlier. So we should find the root most frame in
        // the sample somewhere in the control.
        c--;
      }

      for (; s >= 1 && c >= 0; s--, c--) {
        // Next we find the first one that isn't the same which should be the
        // frame that called our sample function and the control.
        if (sampleLines[s] !== controlLines[c]) {
          // In V8, the first line is describing the message but other VMs don't.
          // If we're about to return the first line, and the control is also on the same
          // line, that's a pretty good indicator that our sample threw at same line as
          // the control. I.e. before we entered the sample frame. So we ignore this result.
          // This can happen if you passed a class to function component, or non-function.
          if (s !== 1 || c !== 1) {
            do {
              s--;
              c--; // We may still have similar intermediate frames from the construct call.
              // The next one that isn't the same should be our match though.

              if (c < 0 || sampleLines[s] !== controlLines[c]) {
                // V8 adds a "new" prefix for native classes. Let's remove it to make it prettier.
                var _frame = '\n' + sampleLines[s].replace(' at new ', ' at ');

                {
                  if (typeof fn === 'function') {
                    componentFrameCache.set(fn, _frame);
                  }
                } // Return the line we found.


                return _frame;
              }
            } while (s >= 1 && c >= 0);
          }

          break;
        }
      }
    }
  } finally {
    reentry = false;

    {
      ReactCurrentDispatcher$1.current = previousDispatcher;
      reenableLogs();
    }

    Error.prepareStackTrace = previousPrepareStackTrace;
  } // Fallback to just using the name if we couldn't make it throw.


  var name = fn ? fn.displayName || fn.name : '';
  var syntheticFrame = name ? describeBuiltInComponentFrame(name) : '';

  {
    if (typeof fn === 'function') {
      componentFrameCache.set(fn, syntheticFrame);
    }
  }

  return syntheticFrame;
}
function describeFunctionComponentFrame(fn, source, ownerFn) {
  {
    return describeNativeComponentFrame(fn, false);
  }
}

function shouldConstruct(Component) {
  var prototype = Component.prototype;
  return !!(prototype && prototype.isReactComponent);
}

function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {

  if (type == null) {
    return '';
  }

  if (typeof type === 'function') {
    {
      return describeNativeComponentFrame(type, shouldConstruct(type));
    }
  }

  if (typeof type === 'string') {
    return describeBuiltInComponentFrame(type);
  }

  switch (type) {
    case exports.Suspense:
      return describeBuiltInComponentFrame('Suspense');

    case REACT_SUSPENSE_LIST_TYPE:
      return describeBuiltInComponentFrame('SuspenseList');
  }

  if (typeof type === 'object') {
    switch (type.$$typeof) {
      case REACT_FORWARD_REF_TYPE:
        return describeFunctionComponentFrame(type.render);

      case REACT_MEMO_TYPE:
        // Memo may contain any component type so we recursively resolve it.
        return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);

      case REACT_BLOCK_TYPE:
        return describeFunctionComponentFrame(type._render);

      case REACT_LAZY_TYPE:
        {
          var lazyComponent = type;
          var payload = lazyComponent._payload;
          var init = lazyComponent._init;

          try {
            // Lazy may contain any component type so we recursively resolve it.
            return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);
          } catch (x) {}
        }
    }
  }

  return '';
}

var loggedTypeFailures = {};
var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;

function setCurrentlyValidatingElement(element) {
  {
    if (element) {
      var owner = element._owner;
      var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
      ReactDebugCurrentFrame$1.setExtraStackFrame(stack);
    } else {
      ReactDebugCurrentFrame$1.setExtraStackFrame(null);
    }
  }
}

function checkPropTypes(typeSpecs, values, location, componentName, element) {
  {
    // $FlowFixMe This is okay but Flow doesn't know it.
    var has = Function.call.bind(Object.prototype.hasOwnProperty);

    for (var typeSpecName in typeSpecs) {
      if (has(typeSpecs, typeSpecName)) {
        var error$1 = void 0; // Prop type validation may throw. In case they do, we don't want to
        // fail the render phase where it didn't fail before. So we log it.
        // After these have been cleaned up, we'll let them throw.

        try {
          // This is intentionally an invariant that gets caught. It's the same
          // behavior as without this statement except with a better message.
          if (typeof typeSpecs[typeSpecName] !== 'function') {
            var err = Error((componentName || 'React class') + ': ' + location + ' type `' + typeSpecName + '` is invalid; ' + 'it must be a function, usually from the `prop-types` package, but received `' + typeof typeSpecs[typeSpecName] + '`.' + 'This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.');
            err.name = 'Invariant Violation';
            throw err;
          }

          error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED');
        } catch (ex) {
          error$1 = ex;
        }

        if (error$1 && !(error$1 instanceof Error)) {
          setCurrentlyValidatingElement(element);

          error('%s: type specification of %s' + ' `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', location, typeSpecName, typeof error$1);

          setCurrentlyValidatingElement(null);
        }

        if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {
          // Only monitor this failure once because there tends to be a lot of the
          // same error.
          loggedTypeFailures[error$1.message] = true;
          setCurrentlyValidatingElement(element);

          error('Failed %s type: %s', location, error$1.message);

          setCurrentlyValidatingElement(null);
        }
      }
    }
  }
}

function setCurrentlyValidatingElement$1(element) {
  {
    if (element) {
      var owner = element._owner;
      var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
      setExtraStackFrame(stack);
    } else {
      setExtraStackFrame(null);
    }
  }
}

var propTypesMisspellWarningShown;

{
  propTypesMisspellWarningShown = false;
}

function getDeclarationErrorAddendum() {
  if (ReactCurrentOwner.current) {
    var name = getComponentName(ReactCurrentOwner.current.type);

    if (name) {
      return '\n\nCheck the render method of `' + name + '`.';
    }
  }

  return '';
}

function getSourceInfoErrorAddendum(source) {
  if (source !== undefined) {
    var fileName = source.fileName.replace(/^.*[\\\/]/, '');
    var lineNumber = source.lineNumber;
    return '\n\nCheck your code at ' + fileName + ':' + lineNumber + '.';
  }

  return '';
}

function getSourceInfoErrorAddendumForProps(elementProps) {
  if (elementProps !== null && elementProps !== undefined) {
    return getSourceInfoErrorAddendum(elementProps.__source);
  }

  return '';
}
/**
 * Warn if there's no key explicitly set on dynamic arrays of children or
 * object keys are not valid. This allows us to keep track of children between
 * updates.
 */


var ownerHasKeyUseWarning = {};

function getCurrentComponentErrorInfo(parentType) {
  var info = getDeclarationErrorAddendum();

  if (!info) {
    var parentName = typeof parentType === 'string' ? parentType : parentType.displayName || parentType.name;

    if (parentName) {
      info = "\n\nCheck the top-level render call using <" + parentName + ">.";
    }
  }

  return info;
}
/**
 * Warn if the element doesn't have an explicit key assigned to it.
 * This element is in an array. The array could grow and shrink or be
 * reordered. All children that haven't already been validated are required to
 * have a "key" property assigned to it. Error statuses are cached so a warning
 * will only be shown once.
 *
 * @internal
 * @param {ReactElement} element Element that requires a key.
 * @param {*} parentType element's parent's type.
 */


function validateExplicitKey(element, parentType) {
  if (!element._store || element._store.validated || element.key != null) {
    return;
  }

  element._store.validated = true;
  var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);

  if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {
    return;
  }

  ownerHasKeyUseWarning[currentComponentErrorInfo] = true; // Usually the current owner is the offender, but if it accepts children as a
  // property, it may be the creator of the child that's responsible for
  // assigning it a key.

  var childOwner = '';

  if (element && element._owner && element._owner !== ReactCurrentOwner.current) {
    // Give the component that originally created this child.
    childOwner = " It was passed a child from " + getComponentName(element._owner.type) + ".";
  }

  {
    setCurrentlyValidatingElement$1(element);

    error('Each child in a list should have a unique "key" prop.' + '%s%s See https://reactjs.org/link/warning-keys for more information.', currentComponentErrorInfo, childOwner);

    setCurrentlyValidatingElement$1(null);
  }
}
/**
 * Ensure that every element either is passed in a static location, in an
 * array with an explicit keys property defined, or in an object literal
 * with valid key property.
 *
 * @internal
 * @param {ReactNode} node Statically passed child of any type.
 * @param {*} parentType node's parent's type.
 */


function validateChildKeys(node, parentType) {
  if (typeof node !== 'object') {
    return;
  }

  if (Array.isArray(node)) {
    for (var i = 0; i < node.length; i++) {
      var child = node[i];

      if (isValidElement(child)) {
        validateExplicitKey(child, parentType);
      }
    }
  } else if (isValidElement(node)) {
    // This element was passed in a valid location.
    if (node._store) {
      node._store.validated = true;
    }
  } else if (node) {
    var iteratorFn = getIteratorFn(node);

    if (typeof iteratorFn === 'function') {
      // Entry iterators used to provide implicit keys,
      // but now we print a separate warning for them later.
      if (iteratorFn !== node.entries) {
        var iterator = iteratorFn.call(node);
        var step;

        while (!(step = iterator.next()).done) {
          if (isValidElement(step.value)) {
            validateExplicitKey(step.value, parentType);
          }
        }
      }
    }
  }
}
/**
 * Given an element, validate that its props follow the propTypes definition,
 * provided by the type.
 *
 * @param {ReactElement} element
 */


function validatePropTypes(element) {
  {
    var type = element.type;

    if (type === null || type === undefined || typeof type === 'string') {
      return;
    }

    var propTypes;

    if (typeof type === 'function') {
      propTypes = type.propTypes;
    } else if (typeof type === 'object' && (type.$$typeof === REACT_FORWARD_REF_TYPE || // Note: Memo only checks outer props here.
    // Inner props are checked in the reconciler.
    type.$$typeof === REACT_MEMO_TYPE)) {
      propTypes = type.propTypes;
    } else {
      return;
    }

    if (propTypes) {
      // Intentionally inside to avoid triggering lazy initializers:
      var name = getComponentName(type);
      checkPropTypes(propTypes, element.props, 'prop', name, element);
    } else if (type.PropTypes !== undefined && !propTypesMisspellWarningShown) {
      propTypesMisspellWarningShown = true; // Intentionally inside to avoid triggering lazy initializers:

      var _name = getComponentName(type);

      error('Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?', _name || 'Unknown');
    }

    if (typeof type.getDefaultProps === 'function' && !type.getDefaultProps.isReactClassApproved) {
      error('getDefaultProps is only used on classic React.createClass ' + 'definitions. Use a static property named `defaultProps` instead.');
    }
  }
}
/**
 * Given a fragment, validate that it can only be provided with fragment props
 * @param {ReactElement} fragment
 */


function validateFragmentProps(fragment) {
  {
    var keys = Object.keys(fragment.props);

    for (var i = 0; i < keys.length; i++) {
      var key = keys[i];

      if (key !== 'children' && key !== 'key') {
        setCurrentlyValidatingElement$1(fragment);

        error('Invalid prop `%s` supplied to `React.Fragment`. ' + 'React.Fragment can only have `key` and `children` props.', key);

        setCurrentlyValidatingElement$1(null);
        break;
      }
    }

    if (fragment.ref !== null) {
      setCurrentlyValidatingElement$1(fragment);

      error('Invalid attribute `ref` supplied to `React.Fragment`.');

      setCurrentlyValidatingElement$1(null);
    }
  }
}
function createElementWithValidation(type, props, children) {
  var validType = isValidElementType(type); // We warn in this case but don't throw. We expect the element creation to
  // succeed and there will likely be errors in render.

  if (!validType) {
    var info = '';

    if (type === undefined || typeof type === 'object' && type !== null && Object.keys(type).length === 0) {
      info += ' You likely forgot to export your component from the file ' + "it's defined in, or you might have mixed up default and named imports.";
    }

    var sourceInfo = getSourceInfoErrorAddendumForProps(props);

    if (sourceInfo) {
      info += sourceInfo;
    } else {
      info += getDeclarationErrorAddendum();
    }

    var typeString;

    if (type === null) {
      typeString = 'null';
    } else if (Array.isArray(type)) {
      typeString = 'array';
    } else if (type !== undefined && type.$$typeof === REACT_ELEMENT_TYPE) {
      typeString = "<" + (getComponentName(type.type) || 'Unknown') + " />";
      info = ' Did you accidentally export a JSX literal instead of a component?';
    } else {
      typeString = typeof type;
    }

    {
      error('React.createElement: type is invalid -- expected a string (for ' + 'built-in components) or a class/function (for composite ' + 'components) but got: %s.%s', typeString, info);
    }
  }

  var element = createElement.apply(this, arguments); // The result can be nullish if a mock or a custom function is used.
  // TODO: Drop this when these are no longer allowed as the type argument.

  if (element == null) {
    return element;
  } // Skip key warning if the type isn't valid since our key validation logic
  // doesn't expect a non-string/function type and can throw confusing errors.
  // We don't want exception behavior to differ between dev and prod.
  // (Rendering will throw with a helpful message and as soon as the type is
  // fixed, the key warnings will appear.)


  if (validType) {
    for (var i = 2; i < arguments.length; i++) {
      validateChildKeys(arguments[i], type);
    }
  }

  if (type === exports.Fragment) {
    validateFragmentProps(element);
  } else {
    validatePropTypes(element);
  }

  return element;
}
var didWarnAboutDeprecatedCreateFactory = false;
function createFactoryWithValidation(type) {
  var validatedFactory = createElementWithValidation.bind(null, type);
  validatedFactory.type = type;

  {
    if (!didWarnAboutDeprecatedCreateFactory) {
      didWarnAboutDeprecatedCreateFactory = true;

      warn('React.createFactory() is deprecated and will be removed in ' + 'a future major release. Consider using JSX ' + 'or use React.createElement() directly instead.');
    } // Legacy hook: remove it


    Object.defineProperty(validatedFactory, 'type', {
      enumerable: false,
      get: function () {
        warn('Factory.type is deprecated. Access the class directly ' + 'before passing it to createFactory.');

        Object.defineProperty(this, 'type', {
          value: type
        });
        return type;
      }
    });
  }

  return validatedFactory;
}
function cloneElementWithValidation(element, props, children) {
  var newElement = cloneElement.apply(this, arguments);

  for (var i = 2; i < arguments.length; i++) {
    validateChildKeys(arguments[i], newElement.type);
  }

  validatePropTypes(newElement);
  return newElement;
}

{

  try {
    var frozenObject = Object.freeze({});
    /* eslint-disable no-new */

    new Map([[frozenObject, null]]);
    new Set([frozenObject]);
    /* eslint-enable no-new */
  } catch (e) {
  }
}

var createElement$1 =  createElementWithValidation ;
var cloneElement$1 =  cloneElementWithValidation ;
var createFactory =  createFactoryWithValidation ;
var Children = {
  map: mapChildren,
  forEach: forEachChildren,
  count: countChildren,
  toArray: toArray,
  only: onlyChild
};

exports.Children = Children;
exports.Component = Component;
exports.PureComponent = PureComponent;
exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = ReactSharedInternals;
exports.cloneElement = cloneElement$1;
exports.createContext = createContext;
exports.createElement = createElement$1;
exports.createFactory = createFactory;
exports.createRef = createRef;
exports.forwardRef = forwardRef;
exports.isValidElement = isValidElement;
exports.lazy = lazy;
exports.memo = memo;
exports.useCallback = useCallback;
exports.useContext = useContext;
exports.useDebugValue = useDebugValue;
exports.useEffect = useEffect;
exports.useImperativeHandle = useImperativeHandle;
exports.useLayoutEffect = useLayoutEffect;
exports.useMemo = useMemo;
exports.useReducer = useReducer;
exports.useRef = useRef;
exports.useState = useState;
exports.version = ReactVersion;
  })();
}


/***/ }),

/***/ "./node_modules/react/index.js":
/*!*************************************!*\
  !*** ./node_modules/react/index.js ***!
  \*************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


if (false) {} else {
  module.exports = __webpack_require__(/*! ./cjs/react.development.js */ "./node_modules/react/cjs/react.development.js");
}


/***/ }),

/***/ "./node_modules/scheduler/cjs/scheduler-tracing.development.js":
/*!*********************************************************************!*\
  !*** ./node_modules/scheduler/cjs/scheduler-tracing.development.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
/** @license React v0.20.2
 * scheduler-tracing.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



if (true) {
  (function() {
'use strict';

var DEFAULT_THREAD_ID = 0; // Counters used to generate unique IDs.

var interactionIDCounter = 0;
var threadIDCounter = 0; // Set of currently traced interactions.
// Interactions "stack"
// Meaning that newly traced interactions are appended to the previously active set.
// When an interaction goes out of scope, the previous set (if any) is restored.

exports.__interactionsRef = null; // Listener(s) to notify when interactions begin and end.

exports.__subscriberRef = null;

{
  exports.__interactionsRef = {
    current: new Set()
  };
  exports.__subscriberRef = {
    current: null
  };
}
function unstable_clear(callback) {

  var prevInteractions = exports.__interactionsRef.current;
  exports.__interactionsRef.current = new Set();

  try {
    return callback();
  } finally {
    exports.__interactionsRef.current = prevInteractions;
  }
}
function unstable_getCurrent() {
  {
    return exports.__interactionsRef.current;
  }
}
function unstable_getThreadID() {
  return ++threadIDCounter;
}
function unstable_trace(name, timestamp, callback) {
  var threadID = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : DEFAULT_THREAD_ID;

  var interaction = {
    __count: 1,
    id: interactionIDCounter++,
    name: name,
    timestamp: timestamp
  };
  var prevInteractions = exports.__interactionsRef.current; // Traced interactions should stack/accumulate.
  // To do that, clone the current interactions.
  // The previous set will be restored upon completion.

  var interactions = new Set(prevInteractions);
  interactions.add(interaction);
  exports.__interactionsRef.current = interactions;
  var subscriber = exports.__subscriberRef.current;
  var returnValue;

  try {
    if (subscriber !== null) {
      subscriber.onInteractionTraced(interaction);
    }
  } finally {
    try {
      if (subscriber !== null) {
        subscriber.onWorkStarted(interactions, threadID);
      }
    } finally {
      try {
        returnValue = callback();
      } finally {
        exports.__interactionsRef.current = prevInteractions;

        try {
          if (subscriber !== null) {
            subscriber.onWorkStopped(interactions, threadID);
          }
        } finally {
          interaction.__count--; // If no async work was scheduled for this interaction,
          // Notify subscribers that it's completed.

          if (subscriber !== null && interaction.__count === 0) {
            subscriber.onInteractionScheduledWorkCompleted(interaction);
          }
        }
      }
    }
  }

  return returnValue;
}
function unstable_wrap(callback) {
  var threadID = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DEFAULT_THREAD_ID;

  var wrappedInteractions = exports.__interactionsRef.current;
  var subscriber = exports.__subscriberRef.current;

  if (subscriber !== null) {
    subscriber.onWorkScheduled(wrappedInteractions, threadID);
  } // Update the pending async work count for the current interactions.
  // Update after calling subscribers in case of error.


  wrappedInteractions.forEach(function (interaction) {
    interaction.__count++;
  });
  var hasRun = false;

  function wrapped() {
    var prevInteractions = exports.__interactionsRef.current;
    exports.__interactionsRef.current = wrappedInteractions;
    subscriber = exports.__subscriberRef.current;

    try {
      var returnValue;

      try {
        if (subscriber !== null) {
          subscriber.onWorkStarted(wrappedInteractions, threadID);
        }
      } finally {
        try {
          returnValue = callback.apply(undefined, arguments);
        } finally {
          exports.__interactionsRef.current = prevInteractions;

          if (subscriber !== null) {
            subscriber.onWorkStopped(wrappedInteractions, threadID);
          }
        }
      }

      return returnValue;
    } finally {
      if (!hasRun) {
        // We only expect a wrapped function to be executed once,
        // But in the event that it's executed more than once
        // Only decrement the outstanding interaction counts once.
        hasRun = true; // Update pending async counts for all wrapped interactions.
        // If this was the last scheduled async work for any of them,
        // Mark them as completed.

        wrappedInteractions.forEach(function (interaction) {
          interaction.__count--;

          if (subscriber !== null && interaction.__count === 0) {
            subscriber.onInteractionScheduledWorkCompleted(interaction);
          }
        });
      }
    }
  }

  wrapped.cancel = function cancel() {
    subscriber = exports.__subscriberRef.current;

    try {
      if (subscriber !== null) {
        subscriber.onWorkCanceled(wrappedInteractions, threadID);
      }
    } finally {
      // Update pending async counts for all wrapped interactions.
      // If this was the last scheduled async work for any of them,
      // Mark them as completed.
      wrappedInteractions.forEach(function (interaction) {
        interaction.__count--;

        if (subscriber && interaction.__count === 0) {
          subscriber.onInteractionScheduledWorkCompleted(interaction);
        }
      });
    }
  };

  return wrapped;
}

var subscribers = null;

{
  subscribers = new Set();
}

function unstable_subscribe(subscriber) {
  {
    subscribers.add(subscriber);

    if (subscribers.size === 1) {
      exports.__subscriberRef.current = {
        onInteractionScheduledWorkCompleted: onInteractionScheduledWorkCompleted,
        onInteractionTraced: onInteractionTraced,
        onWorkCanceled: onWorkCanceled,
        onWorkScheduled: onWorkScheduled,
        onWorkStarted: onWorkStarted,
        onWorkStopped: onWorkStopped
      };
    }
  }
}
function unstable_unsubscribe(subscriber) {
  {
    subscribers.delete(subscriber);

    if (subscribers.size === 0) {
      exports.__subscriberRef.current = null;
    }
  }
}

function onInteractionTraced(interaction) {
  var didCatchError = false;
  var caughtError = null;
  subscribers.forEach(function (subscriber) {
    try {
      subscriber.onInteractionTraced(interaction);
    } catch (error) {
      if (!didCatchError) {
        didCatchError = true;
        caughtError = error;
      }
    }
  });

  if (didCatchError) {
    throw caughtError;
  }
}

function onInteractionScheduledWorkCompleted(interaction) {
  var didCatchError = false;
  var caughtError = null;
  subscribers.forEach(function (subscriber) {
    try {
      subscriber.onInteractionScheduledWorkCompleted(interaction);
    } catch (error) {
      if (!didCatchError) {
        didCatchError = true;
        caughtError = error;
      }
    }
  });

  if (didCatchError) {
    throw caughtError;
  }
}

function onWorkScheduled(interactions, threadID) {
  var didCatchError = false;
  var caughtError = null;
  subscribers.forEach(function (subscriber) {
    try {
      subscriber.onWorkScheduled(interactions, threadID);
    } catch (error) {
      if (!didCatchError) {
        didCatchError = true;
        caughtError = error;
      }
    }
  });

  if (didCatchError) {
    throw caughtError;
  }
}

function onWorkStarted(interactions, threadID) {
  var didCatchError = false;
  var caughtError = null;
  subscribers.forEach(function (subscriber) {
    try {
      subscriber.onWorkStarted(interactions, threadID);
    } catch (error) {
      if (!didCatchError) {
        didCatchError = true;
        caughtError = error;
      }
    }
  });

  if (didCatchError) {
    throw caughtError;
  }
}

function onWorkStopped(interactions, threadID) {
  var didCatchError = false;
  var caughtError = null;
  subscribers.forEach(function (subscriber) {
    try {
      subscriber.onWorkStopped(interactions, threadID);
    } catch (error) {
      if (!didCatchError) {
        didCatchError = true;
        caughtError = error;
      }
    }
  });

  if (didCatchError) {
    throw caughtError;
  }
}

function onWorkCanceled(interactions, threadID) {
  var didCatchError = false;
  var caughtError = null;
  subscribers.forEach(function (subscriber) {
    try {
      subscriber.onWorkCanceled(interactions, threadID);
    } catch (error) {
      if (!didCatchError) {
        didCatchError = true;
        caughtError = error;
      }
    }
  });

  if (didCatchError) {
    throw caughtError;
  }
}

exports.unstable_clear = unstable_clear;
exports.unstable_getCurrent = unstable_getCurrent;
exports.unstable_getThreadID = unstable_getThreadID;
exports.unstable_subscribe = unstable_subscribe;
exports.unstable_trace = unstable_trace;
exports.unstable_unsubscribe = unstable_unsubscribe;
exports.unstable_wrap = unstable_wrap;
  })();
}


/***/ }),

/***/ "./node_modules/scheduler/cjs/scheduler.development.js":
/*!*************************************************************!*\
  !*** ./node_modules/scheduler/cjs/scheduler.development.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
/** @license React v0.20.2
 * scheduler.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



if (true) {
  (function() {
'use strict';

var enableSchedulerDebugging = false;
var enableProfiling = false;

var requestHostCallback;
var requestHostTimeout;
var cancelHostTimeout;
var requestPaint;
var hasPerformanceNow = typeof performance === 'object' && typeof performance.now === 'function';

if (hasPerformanceNow) {
  var localPerformance = performance;

  exports.unstable_now = function () {
    return localPerformance.now();
  };
} else {
  var localDate = Date;
  var initialTime = localDate.now();

  exports.unstable_now = function () {
    return localDate.now() - initialTime;
  };
}

if ( // If Scheduler runs in a non-DOM environment, it falls back to a naive
// implementation using setTimeout.
typeof window === 'undefined' || // Check if MessageChannel is supported, too.
typeof MessageChannel !== 'function') {
  // If this accidentally gets imported in a non-browser environment, e.g. JavaScriptCore,
  // fallback to a naive implementation.
  var _callback = null;
  var _timeoutID = null;

  var _flushCallback = function () {
    if (_callback !== null) {
      try {
        var currentTime = exports.unstable_now();
        var hasRemainingTime = true;

        _callback(hasRemainingTime, currentTime);

        _callback = null;
      } catch (e) {
        setTimeout(_flushCallback, 0);
        throw e;
      }
    }
  };

  requestHostCallback = function (cb) {
    if (_callback !== null) {
      // Protect against re-entrancy.
      setTimeout(requestHostCallback, 0, cb);
    } else {
      _callback = cb;
      setTimeout(_flushCallback, 0);
    }
  };

  requestHostTimeout = function (cb, ms) {
    _timeoutID = setTimeout(cb, ms);
  };

  cancelHostTimeout = function () {
    clearTimeout(_timeoutID);
  };

  exports.unstable_shouldYield = function () {
    return false;
  };

  requestPaint = exports.unstable_forceFrameRate = function () {};
} else {
  // Capture local references to native APIs, in case a polyfill overrides them.
  var _setTimeout = window.setTimeout;
  var _clearTimeout = window.clearTimeout;

  if (typeof console !== 'undefined') {
    // TODO: Scheduler no longer requires these methods to be polyfilled. But
    // maybe we want to continue warning if they don't exist, to preserve the
    // option to rely on it in the future?
    var requestAnimationFrame = window.requestAnimationFrame;
    var cancelAnimationFrame = window.cancelAnimationFrame;

    if (typeof requestAnimationFrame !== 'function') {
      // Using console['error'] to evade Babel and ESLint
      console['error']("This browser doesn't support requestAnimationFrame. " + 'Make sure that you load a ' + 'polyfill in older browsers. https://reactjs.org/link/react-polyfills');
    }

    if (typeof cancelAnimationFrame !== 'function') {
      // Using console['error'] to evade Babel and ESLint
      console['error']("This browser doesn't support cancelAnimationFrame. " + 'Make sure that you load a ' + 'polyfill in older browsers. https://reactjs.org/link/react-polyfills');
    }
  }

  var isMessageLoopRunning = false;
  var scheduledHostCallback = null;
  var taskTimeoutID = -1; // Scheduler periodically yields in case there is other work on the main
  // thread, like user events. By default, it yields multiple times per frame.
  // It does not attempt to align with frame boundaries, since most tasks don't
  // need to be frame aligned; for those that do, use requestAnimationFrame.

  var yieldInterval = 5;
  var deadline = 0; // TODO: Make this configurable

  {
    // `isInputPending` is not available. Since we have no way of knowing if
    // there's pending input, always yield at the end of the frame.
    exports.unstable_shouldYield = function () {
      return exports.unstable_now() >= deadline;
    }; // Since we yield every frame regardless, `requestPaint` has no effect.


    requestPaint = function () {};
  }

  exports.unstable_forceFrameRate = function (fps) {
    if (fps < 0 || fps > 125) {
      // Using console['error'] to evade Babel and ESLint
      console['error']('forceFrameRate takes a positive int between 0 and 125, ' + 'forcing frame rates higher than 125 fps is not supported');
      return;
    }

    if (fps > 0) {
      yieldInterval = Math.floor(1000 / fps);
    } else {
      // reset the framerate
      yieldInterval = 5;
    }
  };

  var performWorkUntilDeadline = function () {
    if (scheduledHostCallback !== null) {
      var currentTime = exports.unstable_now(); // Yield after `yieldInterval` ms, regardless of where we are in the vsync
      // cycle. This means there's always time remaining at the beginning of
      // the message event.

      deadline = currentTime + yieldInterval;
      var hasTimeRemaining = true;

      try {
        var hasMoreWork = scheduledHostCallback(hasTimeRemaining, currentTime);

        if (!hasMoreWork) {
          isMessageLoopRunning = false;
          scheduledHostCallback = null;
        } else {
          // If there's more work, schedule the next message event at the end
          // of the preceding one.
          port.postMessage(null);
        }
      } catch (error) {
        // If a scheduler task throws, exit the current browser task so the
        // error can be observed.
        port.postMessage(null);
        throw error;
      }
    } else {
      isMessageLoopRunning = false;
    } // Yielding to the browser will give it a chance to paint, so we can
  };

  var channel = new MessageChannel();
  var port = channel.port2;
  channel.port1.onmessage = performWorkUntilDeadline;

  requestHostCallback = function (callback) {
    scheduledHostCallback = callback;

    if (!isMessageLoopRunning) {
      isMessageLoopRunning = true;
      port.postMessage(null);
    }
  };

  requestHostTimeout = function (callback, ms) {
    taskTimeoutID = _setTimeout(function () {
      callback(exports.unstable_now());
    }, ms);
  };

  cancelHostTimeout = function () {
    _clearTimeout(taskTimeoutID);

    taskTimeoutID = -1;
  };
}

function push(heap, node) {
  var index = heap.length;
  heap.push(node);
  siftUp(heap, node, index);
}
function peek(heap) {
  var first = heap[0];
  return first === undefined ? null : first;
}
function pop(heap) {
  var first = heap[0];

  if (first !== undefined) {
    var last = heap.pop();

    if (last !== first) {
      heap[0] = last;
      siftDown(heap, last, 0);
    }

    return first;
  } else {
    return null;
  }
}

function siftUp(heap, node, i) {
  var index = i;

  while (true) {
    var parentIndex = index - 1 >>> 1;
    var parent = heap[parentIndex];

    if (parent !== undefined && compare(parent, node) > 0) {
      // The parent is larger. Swap positions.
      heap[parentIndex] = node;
      heap[index] = parent;
      index = parentIndex;
    } else {
      // The parent is smaller. Exit.
      return;
    }
  }
}

function siftDown(heap, node, i) {
  var index = i;
  var length = heap.length;

  while (index < length) {
    var leftIndex = (index + 1) * 2 - 1;
    var left = heap[leftIndex];
    var rightIndex = leftIndex + 1;
    var right = heap[rightIndex]; // If the left or right node is smaller, swap with the smaller of those.

    if (left !== undefined && compare(left, node) < 0) {
      if (right !== undefined && compare(right, left) < 0) {
        heap[index] = right;
        heap[rightIndex] = node;
        index = rightIndex;
      } else {
        heap[index] = left;
        heap[leftIndex] = node;
        index = leftIndex;
      }
    } else if (right !== undefined && compare(right, node) < 0) {
      heap[index] = right;
      heap[rightIndex] = node;
      index = rightIndex;
    } else {
      // Neither child is smaller. Exit.
      return;
    }
  }
}

function compare(a, b) {
  // Compare sort index first, then task id.
  var diff = a.sortIndex - b.sortIndex;
  return diff !== 0 ? diff : a.id - b.id;
}

// TODO: Use symbols?
var ImmediatePriority = 1;
var UserBlockingPriority = 2;
var NormalPriority = 3;
var LowPriority = 4;
var IdlePriority = 5;

function markTaskErrored(task, ms) {
}

/* eslint-disable no-var */
// Math.pow(2, 30) - 1
// 0b111111111111111111111111111111

var maxSigned31BitInt = 1073741823; // Times out immediately

var IMMEDIATE_PRIORITY_TIMEOUT = -1; // Eventually times out

var USER_BLOCKING_PRIORITY_TIMEOUT = 250;
var NORMAL_PRIORITY_TIMEOUT = 5000;
var LOW_PRIORITY_TIMEOUT = 10000; // Never times out

var IDLE_PRIORITY_TIMEOUT = maxSigned31BitInt; // Tasks are stored on a min heap

var taskQueue = [];
var timerQueue = []; // Incrementing id counter. Used to maintain insertion order.

var taskIdCounter = 1; // Pausing the scheduler is useful for debugging.
var currentTask = null;
var currentPriorityLevel = NormalPriority; // This is set while performing work, to prevent re-entrancy.

var isPerformingWork = false;
var isHostCallbackScheduled = false;
var isHostTimeoutScheduled = false;

function advanceTimers(currentTime) {
  // Check for tasks that are no longer delayed and add them to the queue.
  var timer = peek(timerQueue);

  while (timer !== null) {
    if (timer.callback === null) {
      // Timer was cancelled.
      pop(timerQueue);
    } else if (timer.startTime <= currentTime) {
      // Timer fired. Transfer to the task queue.
      pop(timerQueue);
      timer.sortIndex = timer.expirationTime;
      push(taskQueue, timer);
    } else {
      // Remaining timers are pending.
      return;
    }

    timer = peek(timerQueue);
  }
}

function handleTimeout(currentTime) {
  isHostTimeoutScheduled = false;
  advanceTimers(currentTime);

  if (!isHostCallbackScheduled) {
    if (peek(taskQueue) !== null) {
      isHostCallbackScheduled = true;
      requestHostCallback(flushWork);
    } else {
      var firstTimer = peek(timerQueue);

      if (firstTimer !== null) {
        requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);
      }
    }
  }
}

function flushWork(hasTimeRemaining, initialTime) {


  isHostCallbackScheduled = false;

  if (isHostTimeoutScheduled) {
    // We scheduled a timeout but it's no longer needed. Cancel it.
    isHostTimeoutScheduled = false;
    cancelHostTimeout();
  }

  isPerformingWork = true;
  var previousPriorityLevel = currentPriorityLevel;

  try {
    if (enableProfiling) {
      try {
        return workLoop(hasTimeRemaining, initialTime);
      } catch (error) {
        if (currentTask !== null) {
          var currentTime = exports.unstable_now();
          markTaskErrored(currentTask, currentTime);
          currentTask.isQueued = false;
        }

        throw error;
      }
    } else {
      // No catch in prod code path.
      return workLoop(hasTimeRemaining, initialTime);
    }
  } finally {
    currentTask = null;
    currentPriorityLevel = previousPriorityLevel;
    isPerformingWork = false;
  }
}

function workLoop(hasTimeRemaining, initialTime) {
  var currentTime = initialTime;
  advanceTimers(currentTime);
  currentTask = peek(taskQueue);

  while (currentTask !== null && !(enableSchedulerDebugging )) {
    if (currentTask.expirationTime > currentTime && (!hasTimeRemaining || exports.unstable_shouldYield())) {
      // This currentTask hasn't expired, and we've reached the deadline.
      break;
    }

    var callback = currentTask.callback;

    if (typeof callback === 'function') {
      currentTask.callback = null;
      currentPriorityLevel = currentTask.priorityLevel;
      var didUserCallbackTimeout = currentTask.expirationTime <= currentTime;

      var continuationCallback = callback(didUserCallbackTimeout);
      currentTime = exports.unstable_now();

      if (typeof continuationCallback === 'function') {
        currentTask.callback = continuationCallback;
      } else {

        if (currentTask === peek(taskQueue)) {
          pop(taskQueue);
        }
      }

      advanceTimers(currentTime);
    } else {
      pop(taskQueue);
    }

    currentTask = peek(taskQueue);
  } // Return whether there's additional work


  if (currentTask !== null) {
    return true;
  } else {
    var firstTimer = peek(timerQueue);

    if (firstTimer !== null) {
      requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);
    }

    return false;
  }
}

function unstable_runWithPriority(priorityLevel, eventHandler) {
  switch (priorityLevel) {
    case ImmediatePriority:
    case UserBlockingPriority:
    case NormalPriority:
    case LowPriority:
    case IdlePriority:
      break;

    default:
      priorityLevel = NormalPriority;
  }

  var previousPriorityLevel = currentPriorityLevel;
  currentPriorityLevel = priorityLevel;

  try {
    return eventHandler();
  } finally {
    currentPriorityLevel = previousPriorityLevel;
  }
}

function unstable_next(eventHandler) {
  var priorityLevel;

  switch (currentPriorityLevel) {
    case ImmediatePriority:
    case UserBlockingPriority:
    case NormalPriority:
      // Shift down to normal priority
      priorityLevel = NormalPriority;
      break;

    default:
      // Anything lower than normal priority should remain at the current level.
      priorityLevel = currentPriorityLevel;
      break;
  }

  var previousPriorityLevel = currentPriorityLevel;
  currentPriorityLevel = priorityLevel;

  try {
    return eventHandler();
  } finally {
    currentPriorityLevel = previousPriorityLevel;
  }
}

function unstable_wrapCallback(callback) {
  var parentPriorityLevel = currentPriorityLevel;
  return function () {
    // This is a fork of runWithPriority, inlined for performance.
    var previousPriorityLevel = currentPriorityLevel;
    currentPriorityLevel = parentPriorityLevel;

    try {
      return callback.apply(this, arguments);
    } finally {
      currentPriorityLevel = previousPriorityLevel;
    }
  };
}

function unstable_scheduleCallback(priorityLevel, callback, options) {
  var currentTime = exports.unstable_now();
  var startTime;

  if (typeof options === 'object' && options !== null) {
    var delay = options.delay;

    if (typeof delay === 'number' && delay > 0) {
      startTime = currentTime + delay;
    } else {
      startTime = currentTime;
    }
  } else {
    startTime = currentTime;
  }

  var timeout;

  switch (priorityLevel) {
    case ImmediatePriority:
      timeout = IMMEDIATE_PRIORITY_TIMEOUT;
      break;

    case UserBlockingPriority:
      timeout = USER_BLOCKING_PRIORITY_TIMEOUT;
      break;

    case IdlePriority:
      timeout = IDLE_PRIORITY_TIMEOUT;
      break;

    case LowPriority:
      timeout = LOW_PRIORITY_TIMEOUT;
      break;

    case NormalPriority:
    default:
      timeout = NORMAL_PRIORITY_TIMEOUT;
      break;
  }

  var expirationTime = startTime + timeout;
  var newTask = {
    id: taskIdCounter++,
    callback: callback,
    priorityLevel: priorityLevel,
    startTime: startTime,
    expirationTime: expirationTime,
    sortIndex: -1
  };

  if (startTime > currentTime) {
    // This is a delayed task.
    newTask.sortIndex = startTime;
    push(timerQueue, newTask);

    if (peek(taskQueue) === null && newTask === peek(timerQueue)) {
      // All tasks are delayed, and this is the task with the earliest delay.
      if (isHostTimeoutScheduled) {
        // Cancel an existing timeout.
        cancelHostTimeout();
      } else {
        isHostTimeoutScheduled = true;
      } // Schedule a timeout.


      requestHostTimeout(handleTimeout, startTime - currentTime);
    }
  } else {
    newTask.sortIndex = expirationTime;
    push(taskQueue, newTask);
    // wait until the next time we yield.


    if (!isHostCallbackScheduled && !isPerformingWork) {
      isHostCallbackScheduled = true;
      requestHostCallback(flushWork);
    }
  }

  return newTask;
}

function unstable_pauseExecution() {
}

function unstable_continueExecution() {

  if (!isHostCallbackScheduled && !isPerformingWork) {
    isHostCallbackScheduled = true;
    requestHostCallback(flushWork);
  }
}

function unstable_getFirstCallbackNode() {
  return peek(taskQueue);
}

function unstable_cancelCallback(task) {
  // remove from the queue because you can't remove arbitrary nodes from an
  // array based heap, only the first one.)


  task.callback = null;
}

function unstable_getCurrentPriorityLevel() {
  return currentPriorityLevel;
}

var unstable_requestPaint = requestPaint;
var unstable_Profiling =  null;

exports.unstable_IdlePriority = IdlePriority;
exports.unstable_ImmediatePriority = ImmediatePriority;
exports.unstable_LowPriority = LowPriority;
exports.unstable_NormalPriority = NormalPriority;
exports.unstable_Profiling = unstable_Profiling;
exports.unstable_UserBlockingPriority = UserBlockingPriority;
exports.unstable_cancelCallback = unstable_cancelCallback;
exports.unstable_continueExecution = unstable_continueExecution;
exports.unstable_getCurrentPriorityLevel = unstable_getCurrentPriorityLevel;
exports.unstable_getFirstCallbackNode = unstable_getFirstCallbackNode;
exports.unstable_next = unstable_next;
exports.unstable_pauseExecution = unstable_pauseExecution;
exports.unstable_requestPaint = unstable_requestPaint;
exports.unstable_runWithPriority = unstable_runWithPriority;
exports.unstable_scheduleCallback = unstable_scheduleCallback;
exports.unstable_wrapCallback = unstable_wrapCallback;
  })();
}


/***/ }),

/***/ "./node_modules/scheduler/index.js":
/*!*****************************************!*\
  !*** ./node_modules/scheduler/index.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


if (false) {} else {
  module.exports = __webpack_require__(/*! ./cjs/scheduler.development.js */ "./node_modules/scheduler/cjs/scheduler.development.js");
}


/***/ }),

/***/ "./node_modules/scheduler/tracing.js":
/*!*******************************************!*\
  !*** ./node_modules/scheduler/tracing.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


if (false) {} else {
  module.exports = __webpack_require__(/*! ./cjs/scheduler-tracing.development.js */ "./node_modules/scheduler/cjs/scheduler-tracing.development.js");
}


/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js":
/*!****************************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js ***!
  \****************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var isOldIE = function isOldIE() {
  var memo;
  return function memorize() {
    if (typeof memo === 'undefined') {
      // Test for IE <= 9 as proposed by Browserhacks
      // @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805
      // Tests for existence of standard globals is to allow style-loader
      // to operate correctly into non-standard environments
      // @see https://github.com/webpack-contrib/style-loader/issues/177
      memo = Boolean(window && document && document.all && !window.atob);
    }

    return memo;
  };
}();

var getTarget = function getTarget() {
  var memo = {};
  return function memorize(target) {
    if (typeof memo[target] === 'undefined') {
      var styleTarget = document.querySelector(target); // Special case to return head of iframe instead of iframe itself

      if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {
        try {
          // This will throw an exception if access to iframe is blocked
          // due to cross-origin restrictions
          styleTarget = styleTarget.contentDocument.head;
        } catch (e) {
          // istanbul ignore next
          styleTarget = null;
        }
      }

      memo[target] = styleTarget;
    }

    return memo[target];
  };
}();

var stylesInDom = [];

function getIndexByIdentifier(identifier) {
  var result = -1;

  for (var i = 0; i < stylesInDom.length; i++) {
    if (stylesInDom[i].identifier === identifier) {
      result = i;
      break;
    }
  }

  return result;
}

function modulesToDom(list, options) {
  var idCountMap = {};
  var identifiers = [];

  for (var i = 0; i < list.length; i++) {
    var item = list[i];
    var id = options.base ? item[0] + options.base : item[0];
    var count = idCountMap[id] || 0;
    var identifier = "".concat(id, " ").concat(count);
    idCountMap[id] = count + 1;
    var index = getIndexByIdentifier(identifier);
    var obj = {
      css: item[1],
      media: item[2],
      sourceMap: item[3]
    };

    if (index !== -1) {
      stylesInDom[index].references++;
      stylesInDom[index].updater(obj);
    } else {
      stylesInDom.push({
        identifier: identifier,
        updater: addStyle(obj, options),
        references: 1
      });
    }

    identifiers.push(identifier);
  }

  return identifiers;
}

function insertStyleElement(options) {
  var style = document.createElement('style');
  var attributes = options.attributes || {};

  if (typeof attributes.nonce === 'undefined') {
    var nonce =  true ? __webpack_require__.nc : 0;

    if (nonce) {
      attributes.nonce = nonce;
    }
  }

  Object.keys(attributes).forEach(function (key) {
    style.setAttribute(key, attributes[key]);
  });

  if (typeof options.insert === 'function') {
    options.insert(style);
  } else {
    var target = getTarget(options.insert || 'head');

    if (!target) {
      throw new Error("Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.");
    }

    target.appendChild(style);
  }

  return style;
}

function removeStyleElement(style) {
  // istanbul ignore if
  if (style.parentNode === null) {
    return false;
  }

  style.parentNode.removeChild(style);
}
/* istanbul ignore next  */


var replaceText = function replaceText() {
  var textStore = [];
  return function replace(index, replacement) {
    textStore[index] = replacement;
    return textStore.filter(Boolean).join('\n');
  };
}();

function applyToSingletonTag(style, index, remove, obj) {
  var css = remove ? '' : obj.media ? "@media ".concat(obj.media, " {").concat(obj.css, "}") : obj.css; // For old IE

  /* istanbul ignore if  */

  if (style.styleSheet) {
    style.styleSheet.cssText = replaceText(index, css);
  } else {
    var cssNode = document.createTextNode(css);
    var childNodes = style.childNodes;

    if (childNodes[index]) {
      style.removeChild(childNodes[index]);
    }

    if (childNodes.length) {
      style.insertBefore(cssNode, childNodes[index]);
    } else {
      style.appendChild(cssNode);
    }
  }
}

function applyToTag(style, options, obj) {
  var css = obj.css;
  var media = obj.media;
  var sourceMap = obj.sourceMap;

  if (media) {
    style.setAttribute('media', media);
  } else {
    style.removeAttribute('media');
  }

  if (sourceMap && typeof btoa !== 'undefined') {
    css += "\n/*# sourceMappingURL=data:application/json;base64,".concat(btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))), " */");
  } // For old IE

  /* istanbul ignore if  */


  if (style.styleSheet) {
    style.styleSheet.cssText = css;
  } else {
    while (style.firstChild) {
      style.removeChild(style.firstChild);
    }

    style.appendChild(document.createTextNode(css));
  }
}

var singleton = null;
var singletonCounter = 0;

function addStyle(obj, options) {
  var style;
  var update;
  var remove;

  if (options.singleton) {
    var styleIndex = singletonCounter++;
    style = singleton || (singleton = insertStyleElement(options));
    update = applyToSingletonTag.bind(null, style, styleIndex, false);
    remove = applyToSingletonTag.bind(null, style, styleIndex, true);
  } else {
    style = insertStyleElement(options);
    update = applyToTag.bind(null, style, options);

    remove = function remove() {
      removeStyleElement(style);
    };
  }

  update(obj);
  return function updateStyle(newObj) {
    if (newObj) {
      if (newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap) {
        return;
      }

      update(obj = newObj);
    } else {
      remove();
    }
  };
}

module.exports = function (list, options) {
  options = options || {}; // Force single-tag solution on IE6-9, which has a hard limit on the # of <style>
  // tags it will allow on a page

  if (!options.singleton && typeof options.singleton !== 'boolean') {
    options.singleton = isOldIE();
  }

  list = list || [];
  var lastIdentifiers = modulesToDom(list, options);
  return function update(newList) {
    newList = newList || [];

    if (Object.prototype.toString.call(newList) !== '[object Array]') {
      return;
    }

    for (var i = 0; i < lastIdentifiers.length; i++) {
      var identifier = lastIdentifiers[i];
      var index = getIndexByIdentifier(identifier);
      stylesInDom[index].references--;
    }

    var newLastIdentifiers = modulesToDom(newList, options);

    for (var _i = 0; _i < lastIdentifiers.length; _i++) {
      var _identifier = lastIdentifiers[_i];

      var _index = getIndexByIdentifier(_identifier);

      if (stylesInDom[_index].references === 0) {
        stylesInDom[_index].updater();

        stylesInDom.splice(_index, 1);
      }
    }

    lastIdentifiers = newLastIdentifiers;
  };
};

/***/ }),

/***/ "./node_modules/use-async-effect/index.js":
/*!************************************************!*\
  !*** ./node_modules/use-async-effect/index.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var React = __webpack_require__(/*! react */ "./node_modules/react/index.js");

function useAsyncEffect(effect, destroy, inputs) {
  var hasDestroy = typeof destroy === 'function';

  React.useEffect(function () {
    var result;
    var mounted = true;
    var maybePromise = effect(function () {
      return mounted;
    });

    Promise.resolve(maybePromise).then(function (value) {
      result = value;
    });

    return function () {
      mounted = false;

      if (hasDestroy) {
        destroy(result);
      }
    };
  }, hasDestroy ? inputs : destroy);
}

module.exports = useAsyncEffect;
module.exports.useAsyncEffect = useAsyncEffect;


/***/ }),

/***/ "./src/style.css":
/*!***********************!*\
  !*** ./src/style.css ***!
  \***********************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var api = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js");
            var content = __webpack_require__(/*! !!../node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[2].use[1]!../node_modules/postcss-loader/src/index.js??ruleSet[1].rules[2].use[2]!./style.css */ "./node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[2].use[1]!./node_modules/postcss-loader/src/index.js??ruleSet[1].rules[2].use[2]!./src/style.css");

            content = content.__esModule ? content.default : content;

            if (typeof content === 'string') {
              content = [[module.id, content, '']];
            }

var options = {};

options.insert = "head";
options.singleton = false;

var update = api(content, options);



module.exports = content.locals || {};

/***/ }),

/***/ "?2ce1":
/*!**********************!*\
  !*** util (ignored) ***!
  \**********************/
/***/ (() => {

/* (ignored) */

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be in strict mode.
(() => {
"use strict";
/*!**********************************!*\
  !*** ./src/quick-demo/index.tsx ***!
  \**********************************/
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _rainway_web__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @rainway/web */ "./node_modules/@rainway/web/dist/esm/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react-dom */ "./node_modules/react-dom/index.js");
/* harmony import */ var _style_css__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../style.css */ "./src/style.css");
/* harmony import */ var _style_css__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_style_css__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var use_async_effect__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! use-async-effect */ "./node_modules/use-async-effect/index.js");
/* harmony import */ var use_async_effect__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(use_async_effect__WEBPACK_IMPORTED_MODULE_4__);
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};





const QuickDemo = () => {
    const [runtime, setRuntime] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)();
    const [error, setError] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)("");
    use_async_effect__WEBPACK_IMPORTED_MODULE_4___default()(() => __awaiter(void 0, void 0, void 0, function* () {
        var _a;
        try {
            let rt = yield _rainway_web__WEBPACK_IMPORTED_MODULE_0__.default.connect({
                apiKey: (_a = new URLSearchParams(window.location.search).get("api_key")) !== null && _a !== void 0 ? _a : "",
                externalId: "web-demo-react",
            });
            rt.addEventListener("close", (err) => {
                // if the rainway connection closes, something is wrong
                console.error(`Lost connection to Rainway: ${err}`);
            });
            rt.addEventListener("peer-request", (req) => __awaiter(void 0, void 0, void 0, function* () {
                // Accept all requests to connect to us, since we're a demo app
                const peer = yield req.accept();
                peer.addEventListener("connection-state-change", (state) => {
                    // log all peer state changes
                    console.log(`Peer ${peer.id} changed state to ${_rainway_web__WEBPACK_IMPORTED_MODULE_0__.PeerState[state]}`);
                });
            }));
        }
        catch (e) {
            setError(e.message);
            console.log(e);
        }
    }));
    return (react__WEBPACK_IMPORTED_MODULE_1__.createElement("main", { className: "m-t-8 m-l-8 m-r-8 m-b-8" }, error ? error : runtime ? "Connected." : "Connecting"));
};
react_dom__WEBPACK_IMPORTED_MODULE_2__.render(react__WEBPACK_IMPORTED_MODULE_1__.createElement(react__WEBPACK_IMPORTED_MODULE_1__.StrictMode, null,
    react__WEBPACK_IMPORTED_MODULE_1__.createElement(QuickDemo, null)), document.getElementById("react-root"));

})();

/******/ })()
;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yYWlud2F5LXNkay13ZWItZGVtby8uL3NyYy9zdHlsZS5jc3MiLCJ3ZWJwYWNrOi8vcmFpbndheS1zZGstd2ViLWRlbW8vLi9ub2RlX21vZHVsZXMvQHJhaW53YXkvd2ViL2Rpc3QvZXNtL2luZGV4LmpzIiwid2VicGFjazovL3JhaW53YXktc2RrLXdlYi1kZW1vLy4vbm9kZV9tb2R1bGVzL2JlYm9wL2Rpc3QvaW5kZXguanMiLCJ3ZWJwYWNrOi8vcmFpbndheS1zZGstd2ViLWRlbW8vLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvYXBpLmpzIiwid2VicGFjazovL3JhaW53YXktc2RrLXdlYi1kZW1vLy4vbm9kZV9tb2R1bGVzL29iamVjdC1hc3NpZ24vaW5kZXguanMiLCJ3ZWJwYWNrOi8vcmFpbndheS1zZGstd2ViLWRlbW8vLi9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2Nqcy9yZWFjdC1kb20uZGV2ZWxvcG1lbnQuanMiLCJ3ZWJwYWNrOi8vcmFpbndheS1zZGstd2ViLWRlbW8vLi9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2luZGV4LmpzIiwid2VicGFjazovL3JhaW53YXktc2RrLXdlYi1kZW1vLy4vbm9kZV9tb2R1bGVzL3JlYWN0L2Nqcy9yZWFjdC5kZXZlbG9wbWVudC5qcyIsIndlYnBhY2s6Ly9yYWlud2F5LXNkay13ZWItZGVtby8uL25vZGVfbW9kdWxlcy9yZWFjdC9pbmRleC5qcyIsIndlYnBhY2s6Ly9yYWlud2F5LXNkay13ZWItZGVtby8uL25vZGVfbW9kdWxlcy9zY2hlZHVsZXIvY2pzL3NjaGVkdWxlci10cmFjaW5nLmRldmVsb3BtZW50LmpzIiwid2VicGFjazovL3JhaW53YXktc2RrLXdlYi1kZW1vLy4vbm9kZV9tb2R1bGVzL3NjaGVkdWxlci9janMvc2NoZWR1bGVyLmRldmVsb3BtZW50LmpzIiwid2VicGFjazovL3JhaW53YXktc2RrLXdlYi1kZW1vLy4vbm9kZV9tb2R1bGVzL3NjaGVkdWxlci9pbmRleC5qcyIsIndlYnBhY2s6Ly9yYWlud2F5LXNkay13ZWItZGVtby8uL25vZGVfbW9kdWxlcy9zY2hlZHVsZXIvdHJhY2luZy5qcyIsIndlYnBhY2s6Ly9yYWlud2F5LXNkay13ZWItZGVtby8uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL2luamVjdFN0eWxlc0ludG9TdHlsZVRhZy5qcyIsIndlYnBhY2s6Ly9yYWlud2F5LXNkay13ZWItZGVtby8uL25vZGVfbW9kdWxlcy91c2UtYXN5bmMtZWZmZWN0L2luZGV4LmpzIiwid2VicGFjazovL3JhaW53YXktc2RrLXdlYi1kZW1vLy4vc3JjL3N0eWxlLmNzcz85ZWZkIiwid2VicGFjazovL3JhaW53YXktc2RrLXdlYi1kZW1vL2lnbm9yZWR8L2hvbWUvcnVubmVyL3dvcmsvcmFpbndheS1zZGstd2ViLWRlbW8vcmFpbndheS1zZGstd2ViLWRlbW8vbm9kZV9tb2R1bGVzL2JlYm9wL2Rpc3R8dXRpbCIsIndlYnBhY2s6Ly9yYWlud2F5LXNkay13ZWItZGVtby93ZWJwYWNrL2Jvb3RzdHJhcCIsIndlYnBhY2s6Ly9yYWlud2F5LXNkay13ZWItZGVtby93ZWJwYWNrL3J1bnRpbWUvY29tcGF0IGdldCBkZWZhdWx0IGV4cG9ydCIsIndlYnBhY2s6Ly9yYWlud2F5LXNkay13ZWItZGVtby93ZWJwYWNrL3J1bnRpbWUvZGVmaW5lIHByb3BlcnR5IGdldHRlcnMiLCJ3ZWJwYWNrOi8vcmFpbndheS1zZGstd2ViLWRlbW8vd2VicGFjay9ydW50aW1lL2dsb2JhbCIsIndlYnBhY2s6Ly9yYWlud2F5LXNkay13ZWItZGVtby93ZWJwYWNrL3J1bnRpbWUvaGFzT3duUHJvcGVydHkgc2hvcnRoYW5kIiwid2VicGFjazovL3JhaW53YXktc2RrLXdlYi1kZW1vL3dlYnBhY2svcnVudGltZS9tYWtlIG5hbWVzcGFjZSBvYmplY3QiLCJ3ZWJwYWNrOi8vcmFpbndheS1zZGstd2ViLWRlbW8vLi9zcmMvcXVpY2stZGVtby9pbmRleC50c3giXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUE7QUFDQSxrQ0FBa0MsbUJBQU8sQ0FBQyxxR0FBZ0Q7QUFDMUY7QUFDQSw4RkFBOEYsSUFBSSxJQUFJLDZDQUE2QyxJQUFJLDJCQUEyQixJQUFJLElBQUksa0JBQWtCO0FBQzVNO0FBQ0EsaUNBQWlDLGdEQUFnRCw4Q0FBOEMsbURBQW1ELG9EQUFvRCxxREFBcUQsK0JBQStCLCtCQUErQiwrQkFBK0IsK0JBQStCLCtCQUErQiwrQkFBK0IsK0JBQStCLCtCQUErQiwrQkFBK0IsK0JBQStCLCtCQUErQiwrQ0FBK0MsNkJBQTZCLDZCQUE2Qiw2QkFBNkIsNkJBQTZCLDZCQUE2Qiw2QkFBNkIsNkJBQTZCLDZCQUE2QixtREFBbUQsOEJBQThCLDhCQUE4Qiw4QkFBOEIsOEJBQThCLDhCQUE4Qiw4QkFBOEIsOEJBQThCLDhCQUE4Qiw2Q0FBNkMsMkJBQTJCLDJCQUEyQiwyQkFBMkIsMkJBQTJCLDJCQUEyQiwyQkFBMkIsMkJBQTJCLDJCQUEyQixpREFBaUQsOEJBQThCLCtCQUErQiwrQkFBK0IsK0JBQStCLCtCQUErQiwrQkFBK0IsK0JBQStCLCtCQUErQiwrQkFBK0IsK0JBQStCLCtCQUErQiwrQkFBK0IsK0JBQStCLCtCQUErQiwrQkFBK0IsK0JBQStCLGdDQUFnQyxHQUFHLGFBQWEsaUJBQWlCLEdBQUcsK0NBQStDLCtCQUErQixHQUFHLFVBQVUsZ0NBQWdDLEdBQUcsVUFBVSxrQ0FBa0MsR0FBRyxVQUFVLG1DQUFtQyxHQUFHLFVBQVUsZ0NBQWdDLEdBQUcsVUFBVSxpQ0FBaUMsR0FBRyxVQUFVLGlDQUFpQyxHQUFHLFVBQVUsa0NBQWtDLEdBQUcsVUFBVSwrQkFBK0IsR0FBRyxVQUFVLGdDQUFnQyxHQUFHLFVBQVUsa0NBQWtDLEdBQUcsVUFBVSxtQ0FBbUMsR0FBRyxVQUFVLGdDQUFnQyxHQUFHLFVBQVUsaUNBQWlDLEdBQUcsVUFBVSxpQ0FBaUMsR0FBRyxVQUFVLGtDQUFrQyxHQUFHLFVBQVUsK0JBQStCLEdBQUcsVUFBVSxnQ0FBZ0MsR0FBRyxVQUFVLGtDQUFrQyxHQUFHLFVBQVUsbUNBQW1DLEdBQUcsVUFBVSxnQ0FBZ0MsR0FBRyxVQUFVLGlDQUFpQyxHQUFHLFVBQVUsaUNBQWlDLEdBQUcsVUFBVSxrQ0FBa0MsR0FBRyxXQUFXLGdDQUFnQyxHQUFHLFdBQVcsaUNBQWlDLEdBQUcsV0FBVyxtQ0FBbUMsR0FBRyxXQUFXLG9DQUFvQyxHQUFHLFdBQVcsaUNBQWlDLEdBQUcsV0FBVyxrQ0FBa0MsR0FBRyxXQUFXLGtDQUFrQyxHQUFHLFdBQVcsbUNBQW1DLEdBQUcsV0FBVyxnQ0FBZ0MsR0FBRyxXQUFXLGlDQUFpQyxHQUFHLFdBQVcsbUNBQW1DLEdBQUcsV0FBVyxvQ0FBb0MsR0FBRyxXQUFXLGlDQUFpQyxHQUFHLFdBQVcsa0NBQWtDLEdBQUcsV0FBVyxrQ0FBa0MsR0FBRyxXQUFXLG1DQUFtQyxHQUFHLFdBQVcsZ0NBQWdDLEdBQUcsV0FBVyxpQ0FBaUMsR0FBRyxXQUFXLG1DQUFtQyxHQUFHLFdBQVcsb0NBQW9DLEdBQUcsV0FBVyxpQ0FBaUMsR0FBRyxXQUFXLGtDQUFrQyxHQUFHLFdBQVcsa0NBQWtDLEdBQUcsV0FBVyxtQ0FBbUMsR0FBRyxXQUFXLGdDQUFnQyxHQUFHLFdBQVcsaUNBQWlDLEdBQUcsV0FBVyxtQ0FBbUMsR0FBRyxXQUFXLG9DQUFvQyxHQUFHLFdBQVcsaUNBQWlDLEdBQUcsV0FBVyxrQ0FBa0MsR0FBRyxXQUFXLGtDQUFrQyxHQUFHLFdBQVcsbUNBQW1DLEdBQUcsV0FBVyxnQ0FBZ0MsR0FBRyxXQUFXLGlDQUFpQyxHQUFHLFdBQVcsbUNBQW1DLEdBQUcsV0FBVyxvQ0FBb0MsR0FBRyxXQUFXLGlDQUFpQyxHQUFHLFdBQVcsa0NBQWtDLEdBQUcsV0FBVyxrQ0FBa0MsR0FBRyxXQUFXLG1DQUFtQyxHQUFHLFdBQVcsZ0NBQWdDLEdBQUcsV0FBVyxpQ0FBaUMsR0FBRyxXQUFXLG1DQUFtQyxHQUFHLFdBQVcsb0NBQW9DLEdBQUcsV0FBVyxpQ0FBaUMsR0FBRyxXQUFXLGtDQUFrQyxHQUFHLFdBQVcs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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGtCQUFrQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJB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QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFFO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLEVBQUU7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFFOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsRUFBRTtBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLEVBQUU7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLEVBQUU7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFFOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDs7QUFFQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLEVBQUU7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsRUFBRTs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFFO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLEVBQUU7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsV0FBVztBQUN0QixXQUFXLE9BQU87QUFDbEIsV0FBVyxFQUFFO0FBQ2I7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7OztBQUdIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7O0FBR0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLEVBQUU7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOzs7QUFHSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUNBQWlDO0FBQ2pDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7O0FBRUE7QUFDQTtBQUNBLHlEQUF5RDtBQUN6RDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsaUVBQWlFO0FBQ2pFOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxXQUFXO0FBQ3RCLFdBQVcsT0FBTztBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixZQUFZLE9BQU87QUFDbkI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0EsNENBQTRDO0FBQzVDOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxFQUFFO0FBQ2IsWUFBWSxPQUFPO0FBQ25COztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0Esd0JBQXdCO0FBQ3hCOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4Qjs7QUFFOUIsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxXQUFXO0FBQ3RCLFdBQVcsT0FBTztBQUNsQjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLGlDQUFpQztBQUMzQztBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLG1CQUFtQixzQkFBc0I7QUFDekM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxnQ0FBZ0MsS0FBSztBQUMzQztBQUNBO0FBQ0EsTUFBTSxnQ0FBZ0MsS0FBSztBQUMzQztBQUNBLDREQUE0RDtBQUM1RCxNQUFNLGdDQUFnQyxLQUFLO0FBQzNDO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSw0TkFBNE47QUFDNU47QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7OztBQUdIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNEVBQTRFLFlBQVk7QUFDeEY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDJIQUEySCw2QkFBNkI7QUFDeEo7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0ZBQWtGO0FBQ2xGOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU8sMENBQTBDOzs7QUFHakQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsK0ZBQStGO0FBQy9GOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU8sMENBQTBDOzs7QUFHakQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOzs7QUFHTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7O0FBR0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNkVBQTZFOztBQUU3RTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHNKQUFzSixpQkFBaUI7QUFDdkssT0FBTztBQUNQLHNKQUFzSixpQkFBaUIsd0RBQXdELG1CQUFtQixnQkFBZ0IsOEJBQThCO0FBQ2hTOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7OztBQUdBO0FBQ0E7QUFDQSxLQUFLOzs7QUFHTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOzs7QUFHTDtBQUNBLG9HQUFvRyxHQUFHOztBQUV2RztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFlBQVksZUFBZTtBQUMzQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxzRUFBc0U7O0FBRXRFO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNkNBQTZDOztBQUU3QztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtQkFBbUIsMEJBQTBCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixZQUFZLFVBQVU7QUFDdEI7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSwwQ0FBMEM7QUFDMUM7O0FBRUE7QUFDQTtBQUNBLHFCQUFxQjs7QUFFckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMEJBQTBCO0FBQzFCO0FBQ0E7O0FBRUEscUNBQXFDO0FBQ3JDOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRUFBbUU7QUFDbkU7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBLGdCQUFnQjs7QUFFaEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxnQkFBZ0I7QUFDN0I7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7O0FBR1AsdUVBQXVFOztBQUV2RTtBQUNBLDhEQUE4RDtBQUM5RDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0EsT0FBTzs7O0FBR1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLHVCQUF1Qjs7QUFFdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsRUFBRTtBQUNiLFdBQVcsS0FBSztBQUNoQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLFNBQVM7QUFDcEIsV0FBVyxFQUFFO0FBQ2IsV0FBVyxLQUFLO0FBQ2hCOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOzs7QUFHUDtBQUNBLEtBQUs7QUFDTDtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTztBQUNQOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7O0FBR0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7OztBQUdIOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7O0FBR0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxzQ0FBc0M7O0FBRXRDLDhCQUE4QjtBQUM5Qjs7QUFFQTtBQUNBO0FBQ0EsdUJBQXVCOztBQUV2QjtBQUNBLHNDQUFzQzs7QUFFdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsV0FBVztBQUNYO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQSx5RUFBeUU7QUFDekU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOzs7QUFHTDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9DQUFvQzs7QUFFcEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87OztBQUdQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOzs7QUFHSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRUFBb0U7QUFDcEU7QUFDQTs7QUFFQSxtQkFBbUIsaUNBQWlDO0FBQ3BEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsa0JBQWtCLDRDQUE0QztBQUM5RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixhQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhDQUE4QztBQUM5QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOzs7QUFHSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixhQUFhO0FBQ2I7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQSx5WkFBeVo7O0FBRXpaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLHVCQUF1QjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsdUJBQXVCO0FBQ3hDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1EQUFtRDtBQUNuRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCOztBQUV0QjtBQUNBLG9DQUFvQzs7QUFFcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7O0FBR0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDOztBQUVyQztBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7OztBQUdBLHNFQUFzRTtBQUN0RTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDO0FBQ0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUIsZ0JBQWdCO0FBQ2pDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwyQ0FBMkM7O0FBRTNDO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQzs7QUFFdEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7O0FBRXJDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDOztBQUU3Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRDtBQUNwRDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EseURBQXlEOztBQUV6RCxvQkFBb0I7QUFDcEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDs7O0FBR0E7QUFDQSxHQUFHO0FBQ0g7OztBQUdBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOzs7QUFHQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsOEdBQThHOztBQUU5RztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlCQUFpQixxQkFBcUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsZUFBZSxlQUFlO0FBQzlCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQ0FBb0M7O0FBRXBDO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIOzs7QUFHQTtBQUNBO0FBQ0EsR0FBRztBQUNIOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7QUFDRDs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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R0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFlBQVk7QUFDWjs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFlBQVk7QUFDWjs7O0FBR0E7QUFDQTtBQUNBLENBQUM7OztBQUdEO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw2R0FBNkc7QUFDN0c7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxDQUFDOzs7QUFHRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOzs7QUFHSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFVBQVU7O0FBRVY7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7O0FBR0gsaUJBQWlCLGtCQUFrQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsdUJBQXVCO0FBQ2xDLFlBQVk7QUFDWjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHVCQUF1QjtBQUNsQyxZQUFZO0FBQ1o7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyx1QkFBdUI7QUFDbEMsV0FBVyxPQUFPO0FBQ2xCLFlBQVk7QUFDWjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsV0FBVztBQUN0QixZQUFZO0FBQ1o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksV0FBVztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTzs7O0FBR1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7OztBQUdMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyx1QkFBdUI7QUFDbEMsV0FBVyxPQUFPO0FBQ2xCOztBQUVBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsOEVBQThFO0FBQzlFOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7OztBQUdMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLG1CQUFtQixzQkFBc0I7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsWUFBWTtBQUNaOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7OztBQUdIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEdBQTBHO0FBQzFHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7OztBQUdELGdUQUFnVDtBQUNoVDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsOENBQThDLFFBQVE7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxvQkFBb0IsK0JBQStCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsaUJBQWlCLDBCQUEwQjtBQUMzQztBQUNBO0FBQ0E7QUFDQSx1RUFBdUU7QUFDdkUsR0FBRzs7O0FBR0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsK0VBQStFO0FBQy9FOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EseUdBQXlHO0FBQ3pHOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwwQkFBMEI7OztBQUcxQjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsOENBQThDOztBQUU5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7O0FBRS9CO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qjs7QUFFN0I7QUFDQSxvQ0FBb0M7OztBQUdwQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7O0FBRTdCO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qjs7QUFFN0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx1QkFBdUI7QUFD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QUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSywyRUFBMkUsb0dBQW9HLGtDQUFrQztBQUN0TjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7OztBQUdUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLLG9HQUFvRztBQUN6RztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0VBQWtFOztBQUVsRSw4RkFBOEY7QUFDOUY7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7OztBQUdIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsNEJBQTRCO0FBQ2pEO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw2Q0FBNkM7QUFDN0M7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsK0NBQStDO0FBQy9DOztBQUVBOztBQUVBOztBQUVBO0FBQ0EsK0NBQStDO0FBQy9DOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBLG9CQUFvQix3QkFBd0I7QUFDNUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxxQ0FBcUM7QUFDckM7QUFDQSwrRUFBK0U7QUFDL0U7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEM7O0FBRTlDO0FBQ0EsYUFBYTs7O0FBR2I7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlEO0FBQ3pEO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0EsMHZCQUEwdkI7O0FBRTF2QjtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7O0FBRXBDLHVEQUF1RDs7QUFFdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlDQUFpQzs7QUFFakM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7O0FBRXpDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxHQUFHOzs7QUFHSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOzs7QUFHSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRLGNBQWM7QUFDdEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRDtBQUN0RDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7OztBQUdIO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7O0FBRUE7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSywrQ0FBK0M7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssK0NBQStDO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTs7O0FBR0EseUVBQXlFO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEhBQTBIO0FBQzFIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsbUVBQW1FOztBQUVuRTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOzs7QUFHRCwwREFBMEQ7O0FBRTFELG9EQUFvRDtBQUNwRDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRDtBQUNuRDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxxQkFBcUI7QUFDckI7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0E7O0FBRUEsMEhBQTBIO0FBQzFIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUVBQXlFO0FBQ3pFOztBQUVBO0FBQ0EsOENBQThDOztBQUU5QztBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1FQUFtRTtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7OztBQUdMO0FBQ0E7O0FBRUE7QUFDQSx3Q0FBd0M7O0FBRXhDO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7O0FBR0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDBCQUEwQjtBQUMxQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCOztBQUV4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjs7QUFFM0I7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsbUJBQW1CO0FBQ25DOztBQUVBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7O0FBR1Q7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxtQkFBbUI7QUFDbkI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhEQUE4RDtBQUM5RCxxREFBcUQ7QUFDckQsMkRBQTJEO0FBQzNELDJDQUEyQztBQUMzQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQ7O0FBRXJEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0w7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsOENBQThDOztBQUU5Qzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOzs7QUFHTDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7O0FBRTFCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwyQkFBMkI7O0FBRTNCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSw4REFBOEQ7O0FBRTlELDJEQUEyRDtBQUMzRDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOzs7QUFHVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7O0FBR1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1EQUFtRCx5REFBeUQ7QUFDNUcsNkJBQTZCOztBQUU3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87OztBQUdQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7O0FBRXpDOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVMseUJBQXlCOzs7QUFHbEM7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7O0FBR0g7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFD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LEdBQUc7OztBQUdILGtHQUFrRztBQUNsRywrQ0FBK0M7QUFDL0M7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esc0NBQXNDOztBQUV0Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDZJQUE2STs7QUFFN0k7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVCxrRUFBa0UsNENBQTRDO0FBQzlHOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOzs7QUFHSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQ0FBaUM7QUFDakMsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOzs7QUFHRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOzs7QUFHQTtBQUNBLHFEQUFxRDtBQUNyRDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrSUFBa0k7QUFDbEk7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7O0FBR0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7QUFHRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtJQUFrSTtBQUNsSTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7O0FBR0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQ0FBb0M7O0FBRXBDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEpBQThKLHlDQUF5QztBQUN2TTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7OztBQUdMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEscUJBQXFCLHdCQUF3QjtBQUM3QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsVUFBVSxrREFBa0Q7QUFDNUQ7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWSw2QkFBNkI7QUFDekM7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOzs7QUFHTCx1RUFBdUU7O0FBRXZFLFVBQVUsNkJBQTZCO0FBQ3ZDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE9BQU87OztBQUdQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTztBQUNQOzs7QUFHQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLGNBQWMsYUFBYTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsVUFBVSxpQ0FBaUM7QUFDM0M7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWSxZQUFZO0FBQ3hCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7O0FBR0wsdUVBQXVFOztBQUV2RSxVQUFVLFlBQVk7QUFDdEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7OztBQUdUO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsTUFBTTtBQUNuRDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOzs7QUFHTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOzs7QUFHTDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RDtBQUN6RDs7QUFFQSw4Q0FBOEM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw2REFBNkQ7O0FBRTdEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RDs7QUFFN0Q7QUFDQTtBQUNBLEdBQUc7QUFDSDs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTs7QUFFQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHVDQUF1QztBQUN2QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLDJDQUEyQzs7QUFFM0M7QUFDQTtBQUNBLEdBQUc7OztBQUdIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7OztBQUdBO0FBQ0E7QUFDQSxHQUFHOzs7QUFHSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSw0SEFBNEg7O0FBRTVILG9DQUFvQztBQUNwQzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7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Q0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7OztBQUdBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNEJBQTRCOztBQUU1QixvQ0FBb0M7O0FBRXBDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7OztBQUdUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsc0NBQXNDO0FBQ3RDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSywyQ0FBMkM7QUFDaEQ7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwyQ0FBMkM7O0FBRTNDLHFDQUFxQztBQUNyQztBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvREFBb0Q7O0FBRXBEO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQSxpQ0FBaUM7QUFDakM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBOztBQUVBLG1DQUFtQzs7QUFFbkM7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSxHQUFHLG9DQUFvQzs7QUFFdkM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw2REFBNkQ7O0FBRTdEO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUcsdUJBQXVCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQSx5S0FBeUssMENBQTBDO0FBQ25OO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOzs7QUFHSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7OztBQUdIO0FBQ0E7QUFDQTs7QUFFQSw4Q0FBOEM7QUFDOUM7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHFFQUFxRTtBQUNyRTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsZ0JBQWdCO0FBQ3pCLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0Q7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdHQUFnRztBQUNoRztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsK0JBQStCOztBQUUvQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOzs7QUFHSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUNBQW1DOztBQUVuQztBQUNBO0FBQ0E7QUFDQSwrQ0FBK0M7O0FBRS9DO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7O0FBR0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTOzs7QUFHVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTzs7O0FBR1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdEO0FBQ2hEOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQ7O0FBRWpEO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBLHlFQUF5RTs7QUFFekU7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOzs7QUFHSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7O0FBRXRDO0FBQ0EsS0FBSzs7O0FBR0w7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSwwQ0FBMEM7O0FBRTFDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOzs7QUFHSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7OztBQUdBLGdEQUFnRDs7QUFFaEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0M7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx1QkFBdUIsNENBQTRDO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQzs7QUFFcEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQzs7QUFFaEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DOztBQUVwQztBQUNBLEdBQUc7OztBQUdILHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQzs7QUFFcEM7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7OztBQUdIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7OztBQUdMLHdDQUF3Qzs7QUFFeEM7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7O0FBR0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7O0FBR0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhDQUE4Qzs7QUFFOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx1REFBdUQ7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQ7QUFDdkQ7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHNEQUFzRDtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdHQUFnRztBQUNoRzs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1EO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsK0ZBQStGO0FBQy9GOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUNBQW1DOztBQUVuQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSx5TkFBeU4sR0FBRzs7QUFFNU47QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIscUJBQXFCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGtCQUFrQixZQUFZO0FBQzlCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMkNBQTJDOztBQUUzQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVzs7O0FBR1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7OztBQUdIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLCtDQUErQzs7QUFFL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7OztBQUdBO0FBQ0EsdUNBQXVDOztBQUV2QztBQUNBO0FBQ0E7QUFDQSxrREFBa0Q7O0FBRWxEO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQSx5Q0FBeUM7O0FBRXpDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCwrQkFBK0I7QUFDL0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYTtBQUNiOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBLG1IQUFtSDtBQUNuSDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7OztBQUdBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RDs7QUFFNUQ7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTyxvQ0FBb0M7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbURBQW1EO0FBQ25EOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQSw4Q0FBOEM7QUFDOUM7QUFDQTs7QUFFQSxxSEFBcUg7O0FBRXJILCtDQUErQztBQUMvQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTO0FBQ1Q7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVM7QUFDVDs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7O0FBR2I7QUFDQTs7QUFFQSxvREFBb0Q7QUFDcEQ7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLGdEQUFnRDtBQUNoRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4Q0FBOEM7QUFDOUM7O0FBRUE7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNB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O0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDOztBQUU5QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtDQUFrQzs7QUFFbEM7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFIQUFxSDs7QUFFckg7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0EsNERBQTREO0FBQzVEO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYOzs7QUFHQSxzRUFBc0U7O0FBRXRFO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7OztBQUdBO0FBQ0EsS0FBSyxrQ0FBa0M7QUFDdkM7OztBQUdBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEseUVBQXlFOztBQUV6RTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRDtBQUNsRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLHlOQUF5TixxQ0FBcUMsd0ZBQXdGLDJCQUEyQixxQkFBcUIsUUFBUSxZQUFZO0FBQzFaLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLGtEQUFrRDtBQUNsRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0RBQWdEO0FBQ2hEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsT0FBTyw0SUFBNEk7QUFDbko7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esc0NBQXNDO0FBQ3RDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7OztBQUdBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7O0FBR0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7QUFHQSxxREFBcUQ7O0FBRXJEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsNkJBQTZCOztBQUU3QjtBQUNBOztBQUVBLDRDQUE0QztBQUM1Qzs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHLCtCQUErQjtBQUNsQzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRywrQkFBK0I7QUFDbEM7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjs7QUFFQSxtQ0FBbUM7O0FBRW5DO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLCtDQUErQztBQUMvQzs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTzs7QUFFUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7O0FBRXhDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLHdDQUF3Qzs7QUFFeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvREFBb0Q7QUFDcEQ7QUFDQTs7QUFFQTtBQUNBLHVDQUF1Qzs7QUFFdkM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaURBQWlEO0FBQ2pEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QztBQUM5QztBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSzs7O0FBR0w7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7OztBQUdIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLENBQUM7QUFDRCxRQUFRO0FBQ1I7QUFDQTtBQUNBOzs7QUFHQTtBQUNBLCtDQUErQztBQUMvQzs7QUFFQSwrQ0FBK0M7O0FBRS9DLDRHQUE0Rzs7QUFFNUc7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOzs7QUFHSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7O0FBR0E7QUFDQSxHQUFHOzs7QUFHSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7QUFDRDs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLDBDQUEwQztBQUMxQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHlDQUF5QztBQUN6Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJGQUEyRjs7QUFFM0Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7OztBQUdUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1FQUFtRTs7O0FBR25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7OztBQUdUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx3Q0FBd0M7QUFDeEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQSxnQ0FBZ0M7QUFDaEM7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRzs7O0FBR0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSztBQUNMLDhDQUE4QztBQUM5QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQzs7QUFFbkM7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCOztBQUVBOztBQUVBO0FBQ0E7QUFDQSwwREFBMEQ7QUFDMUQ7QUFDQTtBQUNBO0FBQ0EsbURBQW1EO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7O0FBR0w7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0EsR0FBRzs7O0FBR0g7QUFDQSw0Q0FBNEM7O0FBRTVDO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQzs7QUFFM0M7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSx3RUFBd0U7O0FB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QUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7OztBQUdILHFDQUFxQzs7QUFFckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx1QkFBdUIsNEJBQTRCO0FBQ25EO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQSxHQUFHOzs7QUFHSDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7O0FBRUEseUNBQXlDOztBQUV6QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx5Q0FBeUM7O0FBRXpDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnREFBZ0Q7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsaUJBQWlCLDJCQUEyQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7OztBQUdIO0FBQ0E7O0FBRUEsa0JBQWtCLDBCQUEwQjtBQUM1QztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQSwyQ0FBMkM7O0FBRTNDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDJCQUEyQjtBQUMzQjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLHdCQUF3QjtBQUNyQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7OztBQUdIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7O0FBRXpCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7O0FBR0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQSxtQ0FBbUM7QUFDbkM7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsT0FBTyw0Q0FBNEM7QUFDbkQ7OztBQUdBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7O0FBRUEsd0NBQXdDOztBQUV4Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOzs7QUFHUDs7QUFFQTtBQUNBLDZDQUE2QztBQUM3Qzs7QUFFQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7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RUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOzs7QUFHTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOzs7QUFHTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUMsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHlEQUF5RDtBQUN6RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCOztBQUV4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjs7QUFFbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNILCtDQUErQzs7QUFFL0MsdUNBQXVDO0FBQ3ZDOztBQUVBLG1DQUFtQzs7QUFFbkM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1EO0FBQ25EOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQzs7QUFFcEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRDs7QUFFckQsdUNBQXVDO0FBQ3ZDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3Qzs7QUFFeEM7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMkVBQTJFOztBQUUzRTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxzRUFBc0U7QUFDdEU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVFQUF1RTtBQUN2RTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEVBQTBFO0FBQzFFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZEOztBQUU3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0RBQWtEO0FBQ2xEOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHlFQUF5RTtBQUN6RTtBQUNBOztBQUVBLDZDQUE2QztBQUM3Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7OztBQUdEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsK0RBQStEOztBQUUvRDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBLEtBQUs7OztBQUdMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLCtEQUErRDs7QUFFL0Q7QUFDQSxrQ0FBa0M7O0FBRWxDOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTCxxQkFBcUIsd0JBQXdCO0FBQzdDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLCtEQUErRCxPQUFPOztBQUV0RTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTs7QUFFQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtQkFBbUIsMkJBQTJCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtRkFBbUY7O0FBRW5GO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7O0FBR0w7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOzs7QUFHTDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxpTUFBaU0sY0FBYztBQUMvTTtBQUNBLEdBQUc7OztBQUdIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNB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O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxFQUFFO0FBQ2IsV0FBVyxFQUFFO0FBQ2IsV0FBVyxFQUFFO0FBQ2IsV0FBVyxjQUFjO0FBQ3pCLFdBQVcsRUFBRTtBQUNiLFdBQVcsRUFBRTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxFQUFFO0FBQ2I7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7O0FBRUE7QUFD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O0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSwyQkFBMkI7O0FBRTNCO0FBQ0E7QUFDQTtBQUNBLEdBQUc7OztBQUdIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7O0FBR0w7QUFDQSx5Q0FBeUM7QUFDekM7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGFBQWE7QUFDeEI7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCwyQ0FBMkM7O0FBRTNDOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGFBQWE7QUFDeEI7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUIsaUJBQWlCO0FBQ3BDOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxxREFBcUQ7QUFDckQ7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQSxtQkFBbUIsc0JBQXNCO0FBQ3pDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7OztBQUdMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUIsc0JBQXNCO0FBQ3ZDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsdUNBQXVDO0FBQ3ZDOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdCQUFnQjtBQUNoQixpQkFBaUI7QUFDakIscUJBQXFCO0FBQ3JCLDBEQUEwRDtBQUMxRCxvQkFBb0I7QUFDcEIscUJBQXFCO0FBQ3JCLHFCQUFxQjtBQUNyQixxQkFBcUI7QUFDckIsaUJBQWlCO0FBQ2pCLGtCQUFrQjtBQUNsQixzQkFBc0I7QUFDdEIsWUFBWTtBQUNaLFlBQVk7QUFDWixtQkFBbUI7QUFDbkIsa0JBQWtCO0FBQ2xCLHFCQUFxQjtBQUNyQixpQkFBaUI7QUFDakIsMkJBQTJCO0FBQzNCLHVCQUF1QjtBQUN2QixlQUFlO0FBQ2Ysa0JBQWtCO0FBQ2xCLGNBQWM7QUFDZCxnQkFBZ0I7QUFDaEIsZUFBZTtBQUNmLEdBQUc7QUFDSDs7Ozs7Ozs7Ozs7O0FDNXhFYTs7QUFFYixJQUFJLEtBQXFDLEVBQUUsRUFFMUM7QUFDRCxFQUFFLHVIQUFzRDtBQUN4RDs7Ozs7Ozs7Ozs7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFYTs7QUFFYixJQUFJLElBQXFDO0FBQ3pDO0FBQ0E7O0FBRUEsMEJBQTBCOztBQUUxQjtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7O0FBRUEseUJBQXlCLFFBQVE7O0FBRWpDLHVCQUF1Qjs7QUFFdkI7QUFDQSxFQUFFLHlCQUF5QjtBQUMzQjtBQUNBO0FBQ0EsRUFBRSx1QkFBdUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFLGlDQUFpQzs7QUFFbkM7QUFDQTtBQUNBLEdBQUc7QUFDSCxJQUFJLGlDQUFpQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJEO0FBQzNEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUUsaUNBQWlDO0FBQ25DO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLE9BQU87QUFDUCxRQUFRLGlDQUFpQzs7QUFFekM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsZ0NBQWdDO0FBQ2hDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDs7O0FBR0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0EsSUFBSSxpQ0FBaUM7QUFDckM7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsU0FBUztBQUNULFVBQVUsaUNBQWlDOztBQUUzQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxNQUFNLCtCQUErQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQU0sK0JBQStCO0FBQ3JDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxzQkFBc0I7QUFDdEIsMkJBQTJCO0FBQzNCLDRCQUE0QjtBQUM1QiwwQkFBMEI7QUFDMUIsc0JBQXNCO0FBQ3RCLDRCQUE0QjtBQUM1QixxQkFBcUI7QUFDckIsR0FBRztBQUNIOzs7Ozs7Ozs7Ozs7QUMxVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFYTs7QUFFYixJQUFJLElBQXFDO0FBQ3pDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsRUFBRSxvQkFBb0I7QUFDdEI7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBOztBQUVBLEVBQUUsb0JBQW9CO0FBQ3RCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLEVBQUUsNEJBQTRCO0FBQzlCO0FBQ0E7O0FBRUEsaUJBQWlCLCtCQUErQjtBQUNoRCxDQUFDO0FBQ0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBLDhCQUE4Qjs7QUFFOUI7QUFDQSxtQkFBbUI7O0FBRW5CO0FBQ0E7QUFDQTtBQUNBLElBQUksNEJBQTRCO0FBQ2hDO0FBQ0EsTUFBTTs7O0FBR047QUFDQTs7QUFFQSxFQUFFLCtCQUErQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLCtDQUErQztBQUMvQztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7O0FBRWpDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsbUNBQW1DOztBQUVuQyxvQ0FBb0M7O0FBRXBDO0FBQ0E7QUFDQSxpQ0FBaUM7O0FBRWpDLDhDQUE4Qzs7QUFFOUM7QUFDQSxvQkFBb0I7O0FBRXBCLHNCQUFzQjtBQUN0QjtBQUNBLDBDQUEwQzs7QUFFMUM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOzs7QUFHSDtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTzs7O0FBR1A7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNB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LENBQUMsQ0FBQyxZQUFZLENBQUMsQ0FBQyxDQUFDLGFBQWEsQ0FDbEQsQ0FDUixDQUFDO0FBQ0osQ0FBQyxDQUFDO0FBRUYsNkNBQWUsQ0FDYixpREFBQyw2Q0FBZ0I7SUFDZixpREFBQyxTQUFTLE9BQUcsQ0FDSSxFQUNuQixRQUFRLENBQUMsY0FBYyxDQUFDLFlBQVksQ0FBQyxDQUN0QyxDQUFDIiwiZmlsZSI6ImJ1bmRsZS5xdWljay44MWUzNjQ3MGVjM2FmZGVkY2I3OC5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIEltcG9ydHNcbnZhciBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18gPSByZXF1aXJlKFwiLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9ydW50aW1lL2FwaS5qc1wiKTtcbmV4cG9ydHMgPSBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18oZmFsc2UpO1xuZXhwb3J0cy5wdXNoKFttb2R1bGUuaWQsIFwiQGltcG9ydCB1cmwoaHR0cHM6Ly9mb250cy5nb29nbGVhcGlzLmNvbS9jc3MyP2ZhbWlseT1JbnRlcjp3Z2h0QDQwMDs1MDA7NjAwOzcwMCZmYW1pbHk9UXVlc3RyaWFsJmZhbWlseT1Qb3BwaW5zOndnaHRANDAwOzUwMDs2MDAmZmFtaWx5PUJhcmxvdzp3Z2h0QDQwMDs1MDA7NjAwOzcwMCZkaXNwbGF5PXN3YXApO1wiXSk7XG4vLyBNb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcIjpyb290IHtcXG4gIC0tbG9nby1mb250LWZhbWlseTogXFxcIlBvcHBpbnNcXFwiLCBzYW5zLXNlcmlmO1xcbiAgLS1ib2R5LWZvbnQtZmFtaWx5OiBcXFwiSW50ZXJcXFwiLCBzYW5zLXNlcmlmO1xcbiAgLS1oZWFkaW5nLWZvbnQtZmFtaWx5OiBcXFwiUG9wcGluc1xcXCIsIHNhbnMtc2VyaWY7XFxuICAtLWhlYWRlci1mb250LWZhbWlseTogXFxcIlF1ZXN0cmlhbFxcXCIsIHNhbnMtc2VyaWY7XFxuXFxuICAvKiBTbGF0ZSBCbHVlICovXFxuICAtLWNsci1wcmltYXJ5LTEwMDogI2UwZTJmNDtcXG4gIC0tY2xyLXByaW1hcnktMjAwOiAjYmZjM2VjO1xcbiAgLS1jbHItcHJpbWFyeS0zMDA6ICM5ZmE3ZTI7XFxuICAtLWNsci1wcmltYXJ5LTQwMDogIzdlODlkODtcXG4gIC0tY2xyLXByaW1hcnktNTAwOiAjNjE2YWNiO1xcbiAgLS1jbHItcHJpbWFyeS02MDA6ICM0ODU0YmI7XFxuICAtLWNsci1wcmltYXJ5LTcwMDogIzM5NDNhMjtcXG4gIC0tY2xyLXByaW1hcnktODAwOiAjMmYzODg1O1xcbiAgLS1jbHItcHJpbWFyeS05MDA6ICMyNDJiNjc7XFxuICAtLWNsci1wcmltYXJ5LTk1MDogIzE5MWU0ZDtcXG4gIC0tY2xyLXByaW1hcnktOTc1OiAjMGYxMjJlO1xcbiAgLS1jbHItcHJpbWFyeS05OTk6ICMwNTA2MGY7XFxuXFxuICAvKiBNYW50aXMgKi9cXG4gIC0tY2xyLWdyZWVuLTEwMDogI2Y0ZmJmMDtcXG4gIC0tY2xyLWdyZWVuLTIwMDogI2RmZjFkMjtcXG4gIC0tY2xyLWdyZWVuLTMwMDogI2JmZTJhNjtcXG4gIC0tY2xyLWdyZWVuLTQwMDogI2EwZDU3YjtcXG4gIC0tY2xyLWdyZWVuLTUwMDogIzhjY2M2MTtcXG4gIC0tY2xyLWdyZWVuLTYwMDogIzZmYWQ0NTtcXG4gIC0tY2xyLWdyZWVuLTcwMDogIzViOGQzODtcXG4gIC0tY2xyLWdyZWVuLTgwMDogIzMzNTcxYztcXG4gIC0tY2xyLWdyZWVuLTkwMDogIzFlMmYxMjtcXG5cXG4gIC8qIERhbmRlbGlvbiAqL1xcbiAgLS1jbHIteWVsbG93LTEwMDogI2ZmZmRmMTtcXG4gIC0tY2xyLXllbGxvdy0yMDA6ICNmZGY3ZGI7XFxuICAtLWNsci15ZWxsb3ctMzAwOiAjZmFlZGI3O1xcbiAgLS1jbHIteWVsbG93LTQwMDogI2Y3ZTY5NTtcXG4gIC0tY2xyLXllbGxvdy01MDA6ICNmOWRjNWM7XFxuICAtLWNsci15ZWxsb3ctNjAwOiAjZTVjMzQzO1xcbiAgLS1jbHIteWVsbG93LTcwMDogIzlmODAwNDtcXG4gIC0tY2xyLXllbGxvdy04MDA6ICM1MDQxMDI7XFxuICAtLWNsci15ZWxsb3ctOTAwOiAjMjgyMDAxO1xcblxcbiAgLyogVG9tYXRvICovXFxuICAtLWNsci1yZWQtMTAwOiAjZmZmNWYzO1xcbiAgLS1jbHItcmVkLTIwMDogI2ZiZGVkODtcXG4gIC0tY2xyLXJlZC0zMDA6ICNmMGI1YTk7XFxuICAtLWNsci1yZWQtNDAwOiAjZmE5MjdiO1xcbiAgLS1jbHItcmVkLTUwMDogI2ZjNjk0ODtcXG4gIC0tY2xyLXJlZC02MDA6ICNlOTUwMmY7XFxuICAtLWNsci1yZWQtNzAwOiAjY2IzNDEzO1xcbiAgLS1jbHItcmVkLTgwMDogI2EzMDMwMztcXG4gIC0tY2xyLXJlZC05MDA6ICM1YzExMTE7XFxuXFxuICAvKiBOZXV0cmFscyAqL1xcbiAgLS1jbHItbmV1dHJhbC0wOiAjZmZmZmZmO1xcbiAgLS1jbHItbmV1dHJhbC01MDogI2Y0ZjRmNjtcXG4gIC0tY2xyLW5ldXRyYWwtMTAwOiAjZTllOWVjO1xcbiAgLS1jbHItbmV1dHJhbC0yMDA6ICNkM2QzZDk7XFxuICAtLWNsci1uZXV0cmFsLTMwMDogI2IzYjNiYztcXG4gIC0tY2xyLW5ldXRyYWwtNDAwOiAjOWQ5ZGE5O1xcbiAgLS1jbHItbmV1dHJhbC00NTA6ICM4Njg2OTU7XFxuICAtLWNsci1uZXV0cmFsLTUwMDogIzY4Njg3NztcXG4gIC0tY2xyLW5ldXRyYWwtNjAwOiAjNWY1ZjZjO1xcbiAgLS1jbHItbmV1dHJhbC03MDA6ICM0YzRjNTY7XFxuICAtLWNsci1uZXV0cmFsLTgwMDogIzM5Mzk0MTtcXG4gIC0tY2xyLW5ldXRyYWwtODUwOiAjMmMyYzMzO1xcbiAgLS1jbHItbmV1dHJhbC05MDA6ICMyNjI2MmM7XFxuICAtLWNsci1uZXV0cmFsLTkyNTogIzFlMWUyMztcXG4gIC0tY2xyLW5ldXRyYWwtOTUwOiAjMTMxMzE2O1xcbiAgLS1jbHItbmV1dHJhbC05NzU6ICMwOTA5MGI7XFxuICAtLWNsci1uZXV0cmFsLTk5MDogIzA0MDQwNTtcXG4gIC0tY2xyLW5ldXRyYWwtMTAwMDogIzAwMDAwMDtcXG59XFxuXFxuLnNwYWNlciB7XFxuICBmbGV4LWdyb3c6IDE7XFxufVxcblxcbi8qKiBNYXJnaW4gYW5kIFBhZGRpbmcgaGVscGVycyAqL1xcbi5tLXQtMCB7XFxuICBtYXJnaW4tdG9wOiAwcHggIWltcG9ydGFudDtcXG59XFxuLnAtdC0wIHtcXG4gIHBhZGRpbmctdG9wOiAwcHggIWltcG9ydGFudDtcXG59XFxuLm0tYi0wIHtcXG4gIG1hcmdpbi1ib3R0b206IDBweCAhaW1wb3J0YW50O1xcbn1cXG4ucC1iLTAge1xcbiAgcGFkZGluZy1ib3R0b206IDBweCAhaW1wb3J0YW50O1xcbn1cXG4ubS1sLTAge1xcbiAgbWFyZ2luLWxlZnQ6IDBweCAhaW1wb3J0YW50O1xcbn1cXG4ucC1sLTAge1xcbiAgcGFkZGluZy1sZWZ0OiAwcHggIWltcG9ydGFudDtcXG59XFxuLm0tci0wIHtcXG4gIG1hcmdpbi1yaWdodDogMHB4ICFpbXBvcnRhbnQ7XFxufVxcbi5wLXItMCB7XFxuICBwYWRkaW5nLXJpZ2h0OiAwcHggIWltcG9ydGFudDtcXG59XFxuLm0tdC00IHtcXG4gIG1hcmdpbi10b3A6IDRweCAhaW1wb3J0YW50O1xcbn1cXG4ucC10LTQge1xcbiAgcGFkZGluZy10b3A6IDRweCAhaW1wb3J0YW50O1xcbn1cXG4ubS1iLTQge1xcbiAgbWFyZ2luLWJvdHRvbTogNHB4ICFpbXBvcnRhbnQ7XFxufVxcbi5wLWItNCB7XFxuICBwYWRkaW5nLWJvdHRvbTogNHB4ICFpbXBvcnRhbnQ7XFxufVxcbi5tLWwtNCB7XFxuICBtYXJnaW4tbGVmdDogNHB4ICFpbXBvcnRhbnQ7XFxufVxcbi5wLWwtNCB7XFxuICBwYWRkaW5nLWxlZnQ6IDRweCAhaW1wb3J0YW50O1xcbn1cXG4ubS1yLTQge1xcbiAgbWFyZ2luLXJpZ2h0OiA0cHggIWltcG9ydGFudDtcXG59XFxuLnAtci00IHtcXG4gIHBhZGRpbmctcmlnaHQ6IDRweCAhaW1wb3J0YW50O1xcbn1cXG4ubS10LTgge1xcbiAgbWFyZ2luLXRvcDogOHB4ICFpbXBvcnRhbnQ7XFxufVxcbi5wLXQtOCB7XFxuICBwYWRkaW5nLXRvcDogOHB4ICFpbXBvcnRhbnQ7XFxufVxcbi5tLWItOCB7XFxuICBtYXJnaW4tYm90dG9tOiA4cHggIWltcG9ydGFudDtcXG59XFxuLnAtYi04IHtcXG4gIHBhZGRpbmctYm90dG9tOiA4cHggIWltcG9ydGFudDtcXG59XFxuLm0tbC04IHtcXG4gIG1hcmdpbi1sZWZ0OiA4cHggIWltcG9ydGFudDtcXG59XFxuLnAtbC04IHtcXG4gIHBhZGRpbmctbGVmdDogOHB4ICFpbXBvcnRhbnQ7XFxufVxcbi5tLXItOCB7XFxuICBtYXJnaW4tcmlnaHQ6IDhweCAhaW1wb3J0YW50O1xcbn1cXG4ucC1yLTgge1xcbiAgcGFkZGluZy1yaWdodDogOHB4ICFpbXBvcnRhbnQ7XFxufVxcbi5tLXQtMTYge1xcbiAgbWFyZ2luLXRvcDogMTZweCAhaW1wb3J0YW50O1xcbn1cXG4ucC10LTE2IHtcXG4gIHBhZGRpbmctdG9wOiAxNnB4ICFpbXBvcnRhbnQ7XFxufVxcbi5tLWItMTYge1xcbiAgbWFyZ2luLWJvdHRvbTogMTZweCAhaW1wb3J0YW50O1xcbn1cXG4ucC1iLTE2IHtcXG4gIHBhZGRpbmctYm90dG9tOiAxNnB4ICFpbXBvcnRhbnQ7XFxufVxcbi5tLWwtMTYge1xcbiAgbWFyZ2luLWxlZnQ6IDE2cHggIWltcG9ydGFudDtcXG59XFxuLnAtbC0xNiB7XFxuICBwYWRkaW5nLWxlZnQ6IDE2cHggIWltcG9ydGFudDtcXG59XFxuLm0tci0xNiB7XFxuICBtYXJnaW4tcmlnaHQ6IDE2cHggIWltcG9ydGFudDtcXG59XFxuLnAtci0xNiB7XFxuICBwYWRkaW5nLXJpZ2h0OiAxNnB4ICFpbXBvcnRhbnQ7XFxufVxcbi5tLXQtMjQge1xcbiAgbWFyZ2luLXRvcDogMjRweCAhaW1wb3J0YW50O1xcbn1cXG4ucC10LTI0IHtcXG4gIHBhZGRpbmctdG9wOiAyNHB4ICFpbXBvcnRhbnQ7XFxufVxcbi5tLWItMjQge1xcbiAgbWFyZ2luLWJvdHRvbTogMjRweCAhaW1wb3J0YW50O1xcbn1cXG4ucC1iLTI0IHtcXG4gIHBhZGRpbmctYm90dG9tOiAyNHB4ICFpbXBvcnRhbnQ7XFxufVxcbi5tLWwtMjQge1xcbiAgbWFyZ2luLWxlZnQ6IDI0cHggIWltcG9ydGFudDtcXG59XFxuLnAtbC0yNCB7XFxuICBwYWRkaW5nLWxlZnQ6IDI0cHggIWltcG9ydGFudDtcXG59XFxuLm0tci0yNCB7XFxuICBtYXJnaW4tcmlnaHQ6IDI0cHggIWltcG9ydGFudDtcXG59XFxuLnAtci0yNCB7XFxuICBwYWRkaW5nLXJpZ2h0OiAyNHB4ICFpbXBvcnRhbnQ7XFxufVxcbi5tLXQtMzIge1xcbiAgbWFyZ2luLXRvcDogMzJweCAhaW1wb3J0YW50O1xcbn1cXG4ucC10LTMyIHtcXG4gIHBhZGRpbmctdG9wOiAzMnB4ICFpbXBvcnRhbnQ7XFxufVxcbi5tLWItMzIge1xcbiAgbWFyZ2luLWJvdHRvbTogMzJweCAhaW1wb3J0YW50O1xcbn1cXG4ucC1iLTMyIHtcXG4gIHBhZGRpbmctYm90dG9tOiAzMnB4ICFpbXBvcnRhbnQ7XFxufVxcbi5tLWwtMzIge1xcbiAgbWFyZ2luLWxlZnQ6IDMycHggIWltcG9ydGFudDtcXG59XFxuLnAtbC0zMiB7XFxuICBwYWRkaW5nLWxlZnQ6IDMycHggIWltcG9ydGFudDtcXG59XFxuLm0tci0zMiB7XFxuICBtYXJnaW4tcmlnaHQ6IDMycHggIWltcG9ydGFudDtcXG59XFxuLnAtci0zMiB7XFxuICBwYWRkaW5nLXJpZ2h0OiAzMnB4ICFpbXBvcnRhbnQ7XFxufVxcbi5tLXQtNDAge1xcbiAgbWFyZ2luLXRvcDogNDBweCAhaW1wb3J0YW50O1xcbn1cXG4ucC10LTQwIHtcXG4gIHBhZGRpbmctdG9wOiA0MHB4ICFpbXBvcnRhbnQ7XFxufVxcbi5tLWItNDAge1xcbiAgbWFyZ2luLWJvdHRvbTogNDBweCAhaW1wb3J0YW50O1xcbn1cXG4ucC1iLTQwIHtcXG4gIHBhZGRpbmctYm90dG9tOiA0MHB4ICFpbXBvcnRhbnQ7XFxufVxcbi5tLWwtNDAge1xcbiAgbWFyZ2luLWxlZnQ6IDQwcHggIWltcG9ydGFudDtcXG59XFxuLnAtbC00MCB7XFxuICBwYWRkaW5nLWxlZnQ6IDQwcHggIWltcG9ydGFudDtcXG59XFxuLm0tci00MCB7XFxuICBtYXJnaW4tcmlnaHQ6IDQwcHggIWltcG9ydGFudDtcXG59XFxuLnAtci00MCB7XFxuICBwYWRkaW5nLXJpZ2h0OiA0MHB4ICFpbXBvcnRhbnQ7XFxufVxcbi5tLXQtNDgge1xcbiAgbWFyZ2luLXRvcDogNDhweCAhaW1wb3J0YW50O1xcbn1cXG4ucC10LTQ4IHtcXG4gIHBhZGRpbmctdG9wOiA0OHB4ICFpbXBvcnRhbnQ7XFxufVxcbi5tLWItNDgge1xcbiAgbWFyZ2luLWJvdHRvbTogNDhweCAhaW1wb3J0YW50O1xcbn1cXG4ucC1iLTQ4IHtcXG4gIHBhZGRpbmctYm90dG9tOiA0OHB4ICFpbXBvcnRhbnQ7XFxufVxcbi5tLWwtNDgge1xcbiAgbWFyZ2luLWxlZnQ6IDQ4cHggIWltcG9ydGFudDtcXG59XFxuLnAtbC00OCB7XFxuICBwYWRkaW5nLWxlZnQ6IDQ4cHggIWltcG9ydGFudDtcXG59XFxuLm0tci00OCB7XFxuICBtYXJnaW4tcmlnaHQ6IDQ4cHggIWltcG9ydGFudDtcXG59XFxuLnAtci00OCB7XFxuICBwYWRkaW5nLXJpZ2h0OiA0OHB4ICFpbXBvcnRhbnQ7XFxufVxcbi5tLXQtNTYge1xcbiAgbWFyZ2luLXRvcDogNTZweCAhaW1wb3J0YW50O1xcbn1cXG4ucC10LTU2IHtcXG4gIHBhZGRpbmctdG9wOiA1NnB4ICFpbXBvcnRhbnQ7XFxufVxcbi5tLWItNTYge1xcbiAgbWFyZ2luLWJvdHRvbTogNTZweCAhaW1wb3J0YW50O1xcbn1cXG4ucC1iLTU2IHtcXG4gIHBhZGRpbmctYm90dG9tOiA1NnB4ICFpbXBvcnRhbnQ7XFxufVxcbi5tLWwtNTYge1xcbiAgbWFyZ2luLWxlZnQ6IDU2cHggIWltcG9ydGFudDtcXG59XFxuLnAtbC01NiB7XFxuICBwYWRkaW5nLWxlZnQ6IDU2cHggIWltcG9ydGFudDtcXG59XFxuLm0tci01NiB7XFxuICBtYXJnaW4tcmlnaHQ6IDU2cHggIWltcG9ydGFudDtcXG59XFxuLnAtci01NiB7XFxuICBwYWRkaW5nLXJpZ2h0OiA1NnB4ICFpbXBvcnRhbnQ7XFxufVxcbi5tLXQtNjQge1xcbiAgbWFyZ2luLXRvcDogNjRweCAhaW1wb3J0YW50O1xcbn1cXG4ucC10LTY0IHtcXG4gIHBhZGRpbmctdG9wOiA2NHB4ICFpbXBvcnRhbnQ7XFxufVxcbi5tLWItNjQge1xcbiAgbWFyZ2luLWJvdHRvbTogNjRweCAhaW1wb3J0YW50O1xcbn1cXG4ucC1iLTY0IHtcXG4gIHBhZGRpbmctYm90dG9tOiA2NHB4ICFpbXBvcnRhbnQ7XFxufVxcbi5tLWwtNjQge1xcbiAgbWFyZ2luLWxlZnQ6IDY0cHggIWltcG9ydGFudDtcXG59XFxuLnAtbC02NCB7XFxuICBwYWRkaW5nLWxlZnQ6IDY0cHggIWltcG9ydGFudDtcXG59XFxuLm0tci02NCB7XFxuICBtYXJnaW4tcmlnaHQ6IDY0cHggIWltcG9ydGFudDtcXG59XFxuLnAtci02NCB7XFxuICBwYWRkaW5nLXJpZ2h0OiA2NHB4ICFpbXBvcnRhbnQ7XFxufVxcbi5tLXQtNzIge1xcbiAgbWFyZ2luLXRvcDogNzJweCAhaW1wb3J0YW50O1xcbn1cXG4ucC10LTcyIHtcXG4gIHBhZGRpbmctdG9wOiA3MnB4ICFpbXBvcnRhbnQ7XFxufVxcbi5tLWItNzIge1xcbiAgbWFyZ2luLWJvdHRvbTogNzJweCAhaW1wb3J0YW50O1xcbn1cXG4ucC1iLTcyIHtcXG4gIHBhZGRpbmctYm90dG9tOiA3MnB4ICFpbXBvcnRhbnQ7XFxufVxcbi5tLWwtNzIge1xcbiAgbWFyZ2luLWxlZnQ6IDcycHggIWltcG9ydGFudDtcXG59XFxuLnAtbC03MiB7XFxuICBwYWRkaW5nLWxlZnQ6IDcycHggIWltcG9ydGFudDtcXG59XFxuLm0tci03MiB7XFxuICBtYXJnaW4tcmlnaHQ6IDcycHggIWltcG9ydGFudDtcXG59XFxuLnAtci03MiB7XFxuICBwYWRkaW5nLXJpZ2h0OiA3MnB4ICFpbXBvcnRhbnQ7XFxufVxcbi5tLXQtODAge1xcbiAgbWFyZ2luLXRvcDogODBweCAhaW1wb3J0YW50O1xcbn1cXG4ucC10LTgwIHtcXG4gIHBhZGRpbmctdG9wOiA4MHB4ICFpbXBvcnRhbnQ7XFxufVxcbi5tLWItODAge1xcbiAgbWFyZ2luLWJvdHRvbTogODBweCAhaW1wb3J0YW50O1xcbn1cXG4ucC1iLTgwIHtcXG4gIHBhZGRpbmctYm90dG9tOiA4MHB4ICFpbXBvcnRhbnQ7XFxufVxcbi5tLWwtODAge1xcbiAgbWFyZ2luLWxlZnQ6IDgwcHggIWltcG9ydGFudDtcXG59XFxuLnAtbC04MCB7XFxuICBwYWRkaW5nLWxlZnQ6IDgwcHggIWltcG9ydGFudDtcXG59XFxuLm0tci04MCB7XFxuICBtYXJnaW4tcmlnaHQ6IDgwcHggIWltcG9ydGFudDtcXG59XFxuLnAtci04MCB7XFxuICBwYWRkaW5nLXJpZ2h0OiA4MHB4ICFpbXBvcnRhbnQ7XFxufVxcbi5tLXQtMTIwIHtcXG4gIG1hcmdpbi10b3A6IDEyMHB4ICFpbXBvcnRhbnQ7XFxufVxcbi5wLXQtMTIwIHtcXG4gIHBhZGRpbmctdG9wOiAxMjBweCAhaW1wb3J0YW50O1xcbn1cXG4ubS1iLTEyMCB7XFxuICBtYXJnaW4tYm90dG9tOiAxMjBweCAhaW1wb3J0YW50O1xcbn1cXG4ucC1iLTEyMCB7XFxuICBwYWRkaW5nLWJvdHRvbTogMTIwcHggIWltcG9ydGFudDtcXG59XFxuLm0tbC0xMjAge1xcbiAgbWFyZ2luLWxlZnQ6IDEyMHB4ICFpbXBvcnRhbnQ7XFxufVxcbi5wLWwtMTIwIHtcXG4gIHBhZGRpbmctbGVmdDogMTIwcHggIWltcG9ydGFudDtcXG59XFxuLm0tci0xMjAge1xcbiAgbWFyZ2luLXJpZ2h0OiAxMjBweCAhaW1wb3J0YW50O1xcbn1cXG4ucC1yLTEyMCB7XFxuICBwYWRkaW5nLXJpZ2h0OiAxMjBweCAhaW1wb3J0YW50O1xcbn1cXG4ubS10LTE2MCB7XFxuICBtYXJnaW4tdG9wOiAxNjBweCAhaW1wb3J0YW50O1xcbn1cXG4ucC10LTE2MCB7XFxuICBwYWRkaW5nLXRvcDogMTYwcHggIWltcG9ydGFudDtcXG59XFxuLm0tYi0xNjAge1xcbiAgbWFyZ2luLWJvdHRvbTogMTYwcHggIWltcG9ydGFudDtcXG59XFxuLnAtYi0xNjAge1xcbiAgcGFkZGluZy1ib3R0b206IDE2MHB4ICFpbXBvcnRhbnQ7XFxufVxcbi5tLWwtMTYwIHtcXG4gIG1hcmdpbi1sZWZ0OiAxNjBweCAhaW1wb3J0YW50O1xcbn1cXG4ucC1sLTE2MCB7XFxuICBwYWRkaW5nLWxlZnQ6IDE2MHB4ICFpbXBvcnRhbnQ7XFxufVxcbi5tLXItMTYwIHtcXG4gIG1hcmdpbi1yaWdodDogMTYwcHggIWltcG9ydGFudDtcXG59XFxuLnAtci0xNjAge1xcbiAgcGFkZGluZy1yaWdodDogMTYwcHggIWltcG9ydGFudDtcXG59XFxuXFxuKiB7XFxuICBtYXJnaW46IDA7XFxuICBwYWRkaW5nOiAwO1xcbiAgYm94LXNpemluZzogYm9yZGVyLWJveDtcXG59XFxuXFxuaHRtbCB7XFxuICBiYWNrZ3JvdW5kOiAjMTMxMzE2O1xcbiAgc2Nyb2xsLWJlaGF2aW9yOiBzbW9vdGg7XFxuICBjb2xvci1zY2hlbWU6IGRhcms7XFxufVxcblxcbmJvZHkge1xcbiAgZm9udC1mYW1pbHk6IHZhcigtLWJvZHktZm9udC1mYW1pbHkpO1xcbiAgZm9udC1zaXplOiAxNHB4O1xcbiAgY29sb3I6IHZhcigtLWNsci1uZXV0cmFsLTMwMCk7XFxufVxcblxcbmhlYWRlciB7XFxuICBwYWRkaW5nOiAyNHB4IDMycHg7XFxuICBkaXNwbGF5OiBmbGV4O1xcbiAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXG4gIGp1c3RpZnktY29udGVudDogY2VudGVyO1xcbiAgYmFja2dyb3VuZDogIzAwMDAwMDtcXG4gIGJveC1zaGFkb3c6IDBweCAxcHggMHB4IHJnYmEoMjU1LCAyNTUsIDI1NSwgMC4xNSk7XFxufVxcblxcbi5oZWFkZXItaW5uZXIge1xcbiAgZmxleDogMTtcXG4gIGRpc3BsYXk6IGZsZXg7XFxuICBhbGlnbi1pdGVtczogY2VudGVyO1xcbiAgbWF4LXdpZHRoOiAxMTAwcHg7XFxufVxcblxcbi5idWlsZC1ub3RlcyB7XFxuICBmbGV4OiAxO1xcbiAgZGlzcGxheTogZmxleDtcXG4gIGp1c3RpZnktY29udGVudDogZmxleC1lbmQ7XFxuICBhbGlnbi1pdGVtczogY2VudGVyO1xcbn1cXG5cXG4uYnVpbGQtbm90ZSB7XFxuICBsaW5lLWhlaWdodDogMTtcXG4gIGRpc3BsYXk6IGZsZXg7XFxuICBhbGlnbi1pdGVtczogY2VudGVyO1xcbiAgY29sb3I6IHZhcigtLWNsci1uZXV0cmFsLTQ1MCk7XFxufVxcblxcbi5idWlsZC1ub3RlICsgLmJ1aWxkLW5vdGUge1xcbiAgbWFyZ2luLWxlZnQ6IDE2cHg7XFxufVxcblxcbi5idWlsZC1ub3RlID4gc3ZnIHtcXG4gIG1hcmdpbi1yaWdodDogOHB4O1xcbn1cXG5cXG5oMSB7XFxuICBmb250LWZhbWlseTogdmFyKC0taGVhZGluZy1mb250LWZhbWlseSk7XFxuICBmb250LXNpemU6IDIwcHg7XFxuICBmb250LXdlaWdodDogYm9sZDtcXG4gIGNvbG9yOiB2YXIoLS1jbHItbmV1dHJhbC0wKTtcXG59XFxuXFxuaDIge1xcbiAgZm9udC1mYW1pbHk6IHZhcigtLWhlYWRpbmctZm9udC1mYW1pbHkpO1xcbiAgZm9udC1zaXplOiAxNnB4O1xcbiAgZm9udC13ZWlnaHQ6IDYwMDtcXG4gIGNvbG9yOiB2YXIoLS1jbHItbmV1dHJhbC01MCk7XFxufVxcblxcbmgzIHtcXG4gIGZvbnQtZmFtaWx5OiB2YXIoLS1oZWFkaW5nLWZvbnQtZmFtaWx5KTtcXG4gIGZvbnQtc2l6ZTogMTZweDtcXG4gIGZvbnQtd2VpZ2h0OiA1MDA7XFxuICBjb2xvcjogdmFyKC0tY2xyLW5ldXRyYWwtMTAwKTtcXG59XFxuXFxuYnV0dG9uIHtcXG4gIGJvcmRlcjogbm9uZTtcXG4gIGNvbG9yOiB2YXIoLS1jbHItbmV1dHJhbC01MCk7XFxuICBiYWNrZ3JvdW5kOiBsaW5lYXItZ3JhZGllbnQoOTBkZWcsICM2MTZhY2IgMCUsICM0ODU0YmIgMTAwJSk7XFxuICBib3JkZXItcmFkaXVzOiA0cHg7XFxuICBmb250LWZhbWlseTogdmFyKC0tYm9keS1mb250LWZhbWlseSk7XFxuICBmb250LXNpemU6IDE0cHg7XFxuICBwYWRkaW5nOiAxMnB4IDE4cHg7XFxuICBjdXJzb3I6IHBvaW50ZXI7XFxufVxcblxcbmJ1dHRvbi5zZWNvbmRhcnkge1xcbiAgYm9yZGVyOiAxcHggc29saWQgdmFyKC0tY2xyLXByaW1hcnktNTAwKTtcXG4gIGJhY2tncm91bmQ6IHRyYW5zcGFyZW50O1xcbn1cXG5cXG5idXR0b246ZGlzYWJsZWQge1xcbiAgY29sb3I6IHZhcigtLWNsci1uZXV0cmFsLTQwMCk7XFxuICBiYWNrZ3JvdW5kOiB2YXIoLS1jbHItbmV1dHJhbC04NTApO1xcbiAgY3Vyc29yOiBpbmhlcml0O1xcbn1cXG5cXG5pbnB1dCB7XFxuICBmb250LXNpemU6IDE0cHg7XFxufVxcblxcbmlucHV0W3R5cGU9XFxcInRleHRcXFwiXSB7XFxuICBmb250LWZhbWlseTogdmFyKC0tYm9keS1mb250LWZhbWlseSk7XFxuICBiYWNrZ3JvdW5kOiB2YXIoLS1jbHItbmV1dHJhbC05NTApO1xcbiAgYm9yZGVyOiAxcHggc29saWQgdmFyKC0tY2xyLW5ldXRyYWwtODUwKTtcXG4gIGJvcmRlci1yYWRpdXM6IDVweDtcXG4gIHBhZGRpbmc6IDEycHggMTZweDtcXG59XFxuXFxuLmJhZGdlIHtcXG4gIGRpc3BsYXk6IGZsZXg7XFxuICBmbGV4LWRpcmVjdGlvbjogcm93O1xcbiAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XFxuICBhbGlnbi1pdGVtczogY2VudGVyO1xcbiAgcGFkZGluZzogNHB4IDhweDtcXG4gIGZvbnQtc2l6ZTogMTJweDtcXG4gIGZvbnQtd2VpZ2h0OiA1MDA7XFxuICBib3JkZXItcmFkaXVzOiAyNHB4O1xcbiAgYmFja2dyb3VuZDogdmFyKC0tY2xyLW5ldXRyYWwtOTAwKTtcXG4gIGNvbG9yOiB2YXIoLS1jbHItbmV1dHJhbC0zMDApO1xcbn1cXG5cXG4uYmFkZ2Uub2sge1xcbiAgYmFja2dyb3VuZDogdmFyKC0tY2xyLXByaW1hcnktOTAwKTtcXG4gIGNvbG9yOiB2YXIoLS1jbHItcHJpbWFyeS0zMDApO1xcbn1cXG5cXG4uYmFja2Ryb3Age1xcbiAgd2lkdGg6IDEwMCU7XFxuICBoZWlnaHQ6IDE4MHB4O1xcbiAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgei1pbmRleDogLTU7XFxuICBwb2ludGVyLWV2ZW50czogbm9uZTtcXG4gIGJhY2tncm91bmQ6ICMwMDAwMDA7XFxufVxcblxcbi5kZW1vIHtcXG4gIHBhZGRpbmc6IDMycHg7XFxuICBtYXgtd2lkdGg6IDExMDBweDtcXG4gIG1hcmdpbjogYXV0bztcXG59XFxuXFxuLmZsZXgge1xcbiAgZGlzcGxheTogZmxleDtcXG4gIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxufVxcblxcbnN2ZyB7XFxuICBmbGV4LXNocmluazogMDtcXG59XFxuXFxuLmNhcmQge1xcbiAgYmFja2dyb3VuZDogdmFyKC0tY2xyLW5ldXRyYWwtOTI1KTtcXG4gIGJveC1zaGFkb3c6IDBweCA4cHggNTBweCByZ2JhKDAsIDAsIDAsIDAuMjUpO1xcbiAgYm9yZGVyLXJhZGl1czogOHB4O1xcbiAgcGFkZGluZzogMjRweDtcXG4gIG1hcmdpbjogMjRweCAwO1xcbn1cXG5cXG4uY2FyZC10b3Age1xcbiAgZGlzcGxheTogZmxleDtcXG4gIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxuICBtYXJnaW4tYm90dG9tOiA4cHg7XFxufVxcblxcbi5jYXJkLXRvcCA+ICogKyAqIHtcXG4gIG1hcmdpbi1sZWZ0OiA4cHg7XFxufVxcblxcbi53aWRnZXQtYm9keSB7XFxuICBkaXNwbGF5OiBmbGV4O1xcbn1cXG5cXG4uc3RyZWFtLWNvbHVtbiB7XFxuICBmbGV4OiAyO1xcbn1cXG5cXG4uY2hhdC1jb2x1bW4ge1xcbiAgZmxleDogMTtcXG4gIGRpc3BsYXk6IGZsZXg7XFxuICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xcbn1cXG5cXG4uY2hhdC1oaXN0b3J5IHtcXG4gIGZsZXg6IDE7XFxufVxcblxcbi5jaGF0LWJvdHRvbSB7XFxuICBkaXNwbGF5OiBmbGV4O1xcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXG59XFxuXFxuLmNoYXQtaW5wdXQge1xcbiAgZmxleDogMTtcXG59XFxuXFxuYnV0dG9uLmNoYXQtc2VuZC1idXR0b24ge1xcbiAgY3Vyc29yOiBwb2ludGVyO1xcbiAgYmFja2dyb3VuZDogbm9uZTtcXG4gIHBhZGRpbmc6IDA7XFxuICBtYXJnaW46IDA7XFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICByaWdodDogMTZweDtcXG4gIG1hcmdpbi10b3A6IGF1dG87XFxufVxcblxcbmJ1dHRvbi5jaGF0LXNlbmQtYnV0dG9uOmRpc2FibGVkIHtcXG4gIGN1cnNvcjogaW5oZXJpdDtcXG4gIGZpbHRlcjogZ3JheXNjYWxlKCk7XFxufVxcbi5zdHJlYW0tc2VsZWN0b3Ige1xcbiAgZGlzcGxheTogZmxleDtcXG59XFxuXFxuLnN0cmVhbS1zZWxlY3RvciA+IHNlbGVjdCB7XFxuICBtYXJnaW4tcmlnaHQ6IDhweDtcXG59XFxuXFxuLnN0cmVhbS13cmFwcGVyIHtcXG4gIGJvcmRlcjogMXB4IHNvbGlkIHJnYmEoMCwgMCwgMCwgMC40KTtcXG4gIGJhY2tncm91bmQtaW1hZ2U6IC8qIHVybChcXFwiaHR0cHM6Ly9yYWlud2F5LmNvbS9pbWFnZXMvbG9nby5zdmdcXFwiKSwgKi9cXG4gICAgbGluZWFyLWdyYWRpZW50KC00NWRlZywgIzE0MTYyNSwgIzI0MTYzNSk7XFxuICBiYWNrZ3JvdW5kLXJlcGVhdDogbm8tcmVwZWF0O1xcbiAgYmFja2dyb3VuZC1wb3NpdGlvbjogY2VudGVyO1xcbiAgd2lkdGg6IDEwMCU7XFxuICBoZWlnaHQ6IDM5M3B4O1xcbn1cXG5cXG5hIHtcXG4gIGNvbG9yOiB2YXIoLS1jbHItcHJpbWFyeS00MDApO1xcbiAgZm9udC13ZWlnaHQ6IDYwMDtcXG4gIHRleHQtZGVjb3JhdGlvbjogbm9uZTtcXG4gIHRyYW5zaXRpb246IGNvbG9yIDAuMnMgZWFzZTtcXG59XFxuXFxuYTpob3ZlciB7XFxuICBjb2xvcjogdmFyKC0tY2xyLW5ldXRyYWwtNTApO1xcbn1cXG5cIiwgXCJcIl0pO1xuLy8gRXhwb3J0c1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzO1xuIiwiaW1wb3J0e0JlYm9wVmlldyBhcyBBLEJlYm9wUnVudGltZUVycm9yIGFzIEl9ZnJvbVwiYmVib3BcIjtmdW5jdGlvbiBnKEEsSSxnLEIpe2lmKFwiYVwiPT09ZyYmIUIpdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgYWNjZXNzb3Igd2FzIGRlZmluZWQgd2l0aG91dCBhIGdldHRlclwiKTtpZihcImZ1bmN0aW9uXCI9PXR5cGVvZiBJP0EhPT1JfHwhQjohSS5oYXMoQSkpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCByZWFkIHByaXZhdGUgbWVtYmVyIGZyb20gYW4gb2JqZWN0IHdob3NlIGNsYXNzIGRpZCBub3QgZGVjbGFyZSBpdFwiKTtyZXR1cm5cIm1cIj09PWc/QjpcImFcIj09PWc/Qi5jYWxsKEEpOkI/Qi52YWx1ZTpJLmdldChBKX1mdW5jdGlvbiBCKEEsSSxnLEIsUSl7aWYoXCJtXCI9PT1CKXRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIG1ldGhvZCBpcyBub3Qgd3JpdGFibGVcIik7aWYoXCJhXCI9PT1CJiYhUSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBhY2Nlc3NvciB3YXMgZGVmaW5lZCB3aXRob3V0IGEgc2V0dGVyXCIpO2lmKFwiZnVuY3Rpb25cIj09dHlwZW9mIEk/QSE9PUl8fCFROiFJLmhhcyhBKSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IHdyaXRlIHByaXZhdGUgbWVtYmVyIHRvIGFuIG9iamVjdCB3aG9zZSBjbGFzcyBkaWQgbm90IGRlY2xhcmUgaXRcIik7cmV0dXJuXCJhXCI9PT1CP1EuY2FsbChBLGcpOlE/US52YWx1ZT1nOkkuc2V0KEEsZyksZ31jbGFzcyBRIGV4dGVuZHMgRXJyb3J7Y29uc3RydWN0b3IoQSl7c3VwZXIoYFJhaW53YXkgU0RLIEVycm9yOiAke0F9YCksdGhpcy5uYW1lPXRoaXMuY29uc3RydWN0b3IubmFtZSxcImZ1bmN0aW9uXCI9PXR5cGVvZiBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZT9FcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLHRoaXMuY29uc3RydWN0b3IpOnRoaXMuc3RhY2s9bmV3IEVycm9yKGBSYWlud2F5IFNESyBFcnJvcjogJHtBfWApLnN0YWNrLE9iamVjdC5zZXRQcm90b3R5cGVPZih0aGlzLFEucHJvdG90eXBlKX19YXN5bmMgZnVuY3Rpb24gQyhBLEkpe2xldCBnO3RyeXtnPWF3YWl0IGZldGNoKFwiaHR0cHM6Ly9hcGkucmFpbndheS5uZXR3b3JrL3YxXCIrQSxJKX1jYXRjaHt0aHJvdyBuZXcgUShcIkNvdWxkIG5vdCBjb25uZWN0IHRvIHRoZSBSYWlud2F5IEFQSS5cIil9aWYoIWcub2spe2xldCBJO3RyeXtJPWF3YWl0IGcuanNvbigpfWNhdGNoe0k9dm9pZCAwfWlmKDQyMj09PWcuc3RhdHVzJiYhMT09PUk/LmlzX3ZhbGlkKXRocm93IG5ldyBRKFwiVGhlIFJhaW53YXkgQVBJIGtleSBpcyBpbnZhbGlkLlwiKTt0aHJvdyBuZXcgUShgUmFpbndheSBBUEkgZXJyb3I6ICR7QX0gcmV0dXJuZWQgJHtnLnN0YXR1c31gKX1yZXR1cm4gZ312YXIgZSxpLHQsRSxvLGE7IWZ1bmN0aW9uKEEpe0FbQS5TaWxlbnQ9MF09XCJTaWxlbnRcIixBW0EuRXJyb3I9MV09XCJFcnJvclwiLEFbQS5XYXJuaW5nPTJdPVwiV2FybmluZ1wiLEFbQS5JbmZvPTNdPVwiSW5mb1wiLEFbQS5EZWJ1Zz00XT1cIkRlYnVnXCIsQVtBLlRyYWNlPTVdPVwiVHJhY2VcIn0oZXx8KGU9e30pKSxmdW5jdGlvbihBKXtBW0EuTmV3PTBdPVwiTmV3XCIsQVtBLkNvbm5lY3Rpbmc9MV09XCJDb25uZWN0aW5nXCIsQVtBLkNvbm5lY3RlZD0yXT1cIkNvbm5lY3RlZFwiLEFbQS5EaXNjb25uZWN0ZWQ9M109XCJEaXNjb25uZWN0ZWRcIixBW0EuRmFpbGVkPTRdPVwiRmFpbGVkXCJ9KGl8fChpPXt9KSksZnVuY3Rpb24oQSl7QVtBLlVua25vd249MF09XCJVbmtub3duXCIsQVtBLldhcm5pbmc9MV09XCJXYXJuaW5nXCIsQVtBLkZhdGFsPTJdPVwiRmF0YWxcIn0odHx8KHQ9e30pKSxmdW5jdGlvbihBKXtBW0EuQ2xvc2VOb3RpZnk9MF09XCJDbG9zZU5vdGlmeVwiLEFbQS5VbmV4cGVjdGVkTWVzc2FnZT0xMF09XCJVbmV4cGVjdGVkTWVzc2FnZVwiLEFbQS5SZWNvcmRPdmVyZmxvdz0yMF09XCJSZWNvcmRPdmVyZmxvd1wiLEFbQS5UaWNrZXRWYWxpZGF0aW9uRXJyb3I9MzBdPVwiVGlja2V0VmFsaWRhdGlvbkVycm9yXCIsQVtBLkFjY2Vzc0RlbmllZD00OV09XCJBY2Nlc3NEZW5pZWRcIixBW0EuRGVjb2RlRXJyb3I9NTBdPVwiRGVjb2RlRXJyb3JcIixBW0EuRGVjcnlwdEVycm9yPTUxXT1cIkRlY3J5cHRFcnJvclwiLEFbQS5Qcm90b2NvbFZlcnNpb249NzBdPVwiUHJvdG9jb2xWZXJzaW9uXCIsQVtBLkludGVybmFsRXJyb3I9ODBdPVwiSW50ZXJuYWxFcnJvclwiLEFbQS5QZWVyR29uZUF3YXk9OTBdPVwiUGVlckdvbmVBd2F5XCIsQVtBLkNvbW1pdEZhaWx1cmU9MTAwXT1cIkNvbW1pdEZhaWx1cmVcIixBW0EuUmVzb3VyY2VFeHBpcmVkPTIwMF09XCJSZXNvdXJjZUV4cGlyZWRcIn0oRXx8KEU9e30pKSxmdW5jdGlvbihBKXtBW0EuSW52YWxpZD0wXT1cIkludmFsaWRcIixBW0EuU0NUUD0xXT1cIlNDVFBcIixBW0EuR1VEUD0yXT1cIkdVRFBcIixBW0EuUmVzZXJ2ZWQ9M109XCJSZXNlcnZlZFwifShvfHwobz17fSkpLGZ1bmN0aW9uKEEpe0FbQS5JbnZhbGlkPTBdPVwiSW52YWxpZFwiLEFbQS5PZmZlcj0xXT1cIk9mZmVyXCIsQVtBLkFuc3dlcj0yXT1cIkFuc3dlclwiLEFbQS5DYW5kaWRhdGU9M109XCJDYW5kaWRhdGVcIn0oYXx8KGE9e30pKTtjb25zdCBzPXtlbmNvZGUoSSl7Y29uc3QgZz1BLmdldEluc3RhbmNlKCk7cmV0dXJuIGcuc3RhcnRXcml0aW5nKCksdGhpcy5lbmNvZGVJbnRvKEksZyksZy50b0FycmF5KCl9LGVuY29kZUludG8oQSxJKXtjb25zdCBnPUkubGVuZ3RoO0kud3JpdGVTdHJpbmcoQS5hcGlLZXkpLEkud3JpdGVJbnQ2NChBLmlkKSxJLndyaXRlU3RyaW5nKEEuZXh0ZXJuYWxJZCk7cmV0dXJuIEkubGVuZ3RoLWd9LGRlY29kZShJKXtjb25zdCBnPUEuZ2V0SW5zdGFuY2UoKTtyZXR1cm4gZy5zdGFydFJlYWRpbmcoSSksdGhpcy5yZWFkRnJvbShnKX0scmVhZEZyb20oQSl7bGV0IEksZyxCO3JldHVybiBJPUEucmVhZFN0cmluZygpLGc9QS5yZWFkSW50NjQoKSxCPUEucmVhZFN0cmluZygpLHthcGlLZXk6SSxpZDpnLGV4dGVybmFsSWQ6Qn19fSxuPXtlbmNvZGUoSSl7Y29uc3QgZz1BLmdldEluc3RhbmNlKCk7cmV0dXJuIGcuc3RhcnRXcml0aW5nKCksdGhpcy5lbmNvZGVJbnRvKEksZyksZy50b0FycmF5KCl9LGVuY29kZUludG8oQSxJKXtjb25zdCBnPUkubGVuZ3RoO0kud3JpdGVVaW50MzIoQS5zeW5jS2V5KTtyZXR1cm4gSS5sZW5ndGgtZ30sZGVjb2RlKEkpe2NvbnN0IGc9QS5nZXRJbnN0YW5jZSgpO3JldHVybiBnLnN0YXJ0UmVhZGluZyhJKSx0aGlzLnJlYWRGcm9tKGcpfSxyZWFkRnJvbShBKXtsZXQgSTtyZXR1cm4gST1BLnJlYWRVaW50MzIoKSx7c3luY0tleTpJfX19LHI9e2VuY29kZShJKXtjb25zdCBnPUEuZ2V0SW5zdGFuY2UoKTtyZXR1cm4gZy5zdGFydFdyaXRpbmcoKSx0aGlzLmVuY29kZUludG8oSSxnKSxnLnRvQXJyYXkoKX0sZW5jb2RlSW50byhBLEkpe2NvbnN0IGc9SS5sZW5ndGg7bi5lbmNvZGVJbnRvKEEuaGVhZGVyLEkpLHcuZW5jb2RlSW50byhBLmJvZHksSSk7cmV0dXJuIEkubGVuZ3RoLWd9LGRlY29kZShJKXtjb25zdCBnPUEuZ2V0SW5zdGFuY2UoKTtyZXR1cm4gZy5zdGFydFJlYWRpbmcoSSksdGhpcy5yZWFkRnJvbShnKX0scmVhZEZyb20oQSl7bGV0IEksZztyZXR1cm4gST1uLnJlYWRGcm9tKEEpLGc9dy5yZWFkRnJvbShBKSx7aGVhZGVyOkksYm9keTpnfX19LGg9e2Rpc2NyaW1pbmF0b3I6MSxlbmNvZGUoSSl7Y29uc3QgZz1BLmdldEluc3RhbmNlKCk7cmV0dXJuIGcuc3RhcnRXcml0aW5nKCksdGhpcy5lbmNvZGVJbnRvKEksZyksZy50b0FycmF5KCl9LGVuY29kZUludG8oQSxJKXtjb25zdCBnPUkubGVuZ3RoO1MuZW5jb2RlSW50byhBLmJvZHksSSk7cmV0dXJuIEkubGVuZ3RoLWd9LGRlY29kZShJKXtjb25zdCBnPUEuZ2V0SW5zdGFuY2UoKTtyZXR1cm4gZy5zdGFydFJlYWRpbmcoSSksdGhpcy5yZWFkRnJvbShnKX0scmVhZEZyb20oQSl7bGV0IEk7cmV0dXJuIEk9Uy5yZWFkRnJvbShBKSx7Ym9keTpJfX19LGQ9e2Rpc2NyaW1pbmF0b3I6MixlbmNvZGUoSSl7Y29uc3QgZz1BLmdldEluc3RhbmNlKCk7cmV0dXJuIGcuc3RhcnRXcml0aW5nKCksdGhpcy5lbmNvZGVJbnRvKEksZyksZy50b0FycmF5KCl9LGVuY29kZUludG8oQSxJKXtjb25zdCBnPUkubGVuZ3RoO0cuZW5jb2RlSW50byhBLmJvZHksSSk7cmV0dXJuIEkubGVuZ3RoLWd9LGRlY29kZShJKXtjb25zdCBnPUEuZ2V0SW5zdGFuY2UoKTtyZXR1cm4gZy5zdGFydFJlYWRpbmcoSSksdGhpcy5yZWFkRnJvbShnKX0scmVhZEZyb20oQSl7bGV0IEk7cmV0dXJuIEk9Ry5yZWFkRnJvbShBKSx7Ym9keTpJfX19LGM9e2Rpc2NyaW1pbmF0b3I6MyxlbmNvZGUoSSl7Y29uc3QgZz1BLmdldEluc3RhbmNlKCk7cmV0dXJuIGcuc3RhcnRXcml0aW5nKCksdGhpcy5lbmNvZGVJbnRvKEksZyksZy50b0FycmF5KCl9LGVuY29kZUludG8oQSxJKXtjb25zdCBnPUkubGVuZ3RoO0kud3JpdGVVaW50MzIoQS5sZXZlbCksSS53cml0ZVVpbnQzMihBLmRlc2NyaXB0aW9uKTtyZXR1cm4gSS5sZW5ndGgtZ30sZGVjb2RlKEkpe2NvbnN0IGc9QS5nZXRJbnN0YW5jZSgpO3JldHVybiBnLnN0YXJ0UmVhZGluZyhJKSx0aGlzLnJlYWRGcm9tKGcpfSxyZWFkRnJvbShBKXtsZXQgSSxnO3JldHVybiBJPUEucmVhZFVpbnQzMigpLGc9QS5yZWFkVWludDMyKCkse2xldmVsOkksZGVzY3JpcHRpb246Z319fSxEPXtkaXNjcmltaW5hdG9yOjQsZW5jb2RlKEkpe2NvbnN0IGc9QS5nZXRJbnN0YW5jZSgpO3JldHVybiBnLnN0YXJ0V3JpdGluZygpLHRoaXMuZW5jb2RlSW50byhJLGcpLGcudG9BcnJheSgpfSxlbmNvZGVJbnRvKEEsSSl7Y29uc3QgZz1JLmxlbmd0aDtJLndyaXRlSW50NjQoQS50YXJnZXRQZWVySWQpLFUuZW5jb2RlSW50byhBLmJvZHksSSk7cmV0dXJuIEkubGVuZ3RoLWd9LGRlY29kZShJKXtjb25zdCBnPUEuZ2V0SW5zdGFuY2UoKTtyZXR1cm4gZy5zdGFydFJlYWRpbmcoSSksdGhpcy5yZWFkRnJvbShnKX0scmVhZEZyb20oQSl7bGV0IEksZztyZXR1cm4gST1BLnJlYWRJbnQ2NCgpLGc9VS5yZWFkRnJvbShBKSx7dGFyZ2V0UGVlcklkOkksYm9keTpnfX19LHc9e2VuY29kZShJKXtjb25zdCBnPUEuZ2V0SW5zdGFuY2UoKTtyZXR1cm4gZy5zdGFydFdyaXRpbmcoKSx0aGlzLmVuY29kZUludG8oSSxnKSxnLnRvQXJyYXkoKX0sZW5jb2RlSW50byhBLEkpe2NvbnN0IGc9SS5sZW5ndGgsQj1JLnJlc2VydmVNZXNzYWdlTGVuZ3RoKCksUT1JLmxlbmd0aCsxO3N3aXRjaChJLndyaXRlQnl0ZShBLmRpc2NyaW1pbmF0b3IpLEEuZGlzY3JpbWluYXRvcil7Y2FzZSAxOmguZW5jb2RlSW50byhBLnZhbHVlLEkpO2JyZWFrO2Nhc2UgMjpkLmVuY29kZUludG8oQS52YWx1ZSxJKTticmVhaztjYXNlIDM6Yy5lbmNvZGVJbnRvKEEudmFsdWUsSSk7YnJlYWs7Y2FzZSA0OkQuZW5jb2RlSW50byhBLnZhbHVlLEkpfWNvbnN0IEM9SS5sZW5ndGg7SS5maWxsTWVzc2FnZUxlbmd0aChCLEMtUSk7cmV0dXJuIEkubGVuZ3RoLWd9LGRlY29kZShJKXtjb25zdCBnPUEuZ2V0SW5zdGFuY2UoKTtyZXR1cm4gZy5zdGFydFJlYWRpbmcoSSksdGhpcy5yZWFkRnJvbShnKX0scmVhZEZyb20oQSl7Y29uc3QgZz1BLnJlYWRNZXNzYWdlTGVuZ3RoKCksQj1BLmluZGV4KzErZztzd2l0Y2goQS5yZWFkQnl0ZSgpKXtjYXNlIDE6cmV0dXJue2Rpc2NyaW1pbmF0b3I6MSx2YWx1ZTpoLnJlYWRGcm9tKEEpfTtjYXNlIDI6cmV0dXJue2Rpc2NyaW1pbmF0b3I6Mix2YWx1ZTpkLnJlYWRGcm9tKEEpfTtjYXNlIDM6cmV0dXJue2Rpc2NyaW1pbmF0b3I6Myx2YWx1ZTpjLnJlYWRGcm9tKEEpfTtjYXNlIDQ6cmV0dXJue2Rpc2NyaW1pbmF0b3I6NCx2YWx1ZTpELnJlYWRGcm9tKEEpfTtkZWZhdWx0OnRocm93IEEuaW5kZXg9QixuZXcgSShcIlVucmVjb2duaXplZCBkaXNjcmltaW5hdG9yIHdoaWxlIGRlY29kaW5nIEdhdGV3YXlCb2R5XCIpfX19LEY9e2Rpc2NyaW1pbmF0b3I6MSxlbmNvZGUoSSl7Y29uc3QgZz1BLmdldEluc3RhbmNlKCk7cmV0dXJuIGcuc3RhcnRXcml0aW5nKCksdGhpcy5lbmNvZGVJbnRvKEksZyksZy50b0FycmF5KCl9LGVuY29kZUludG8oQSxJKXtjb25zdCBnPUkubGVuZ3RoO0kud3JpdGVJbnQ2NChBLnRhcmdldFBlZXJJZCksSS53cml0ZVVpbnQzMihBLmRlc2lyZWRUcmFuc3BvcnQpO3JldHVybiBJLmxlbmd0aC1nfSxkZWNvZGUoSSl7Y29uc3QgZz1BLmdldEluc3RhbmNlKCk7cmV0dXJuIGcuc3RhcnRSZWFkaW5nKEkpLHRoaXMucmVhZEZyb20oZyl9LHJlYWRGcm9tKEEpe2xldCBJLGc7cmV0dXJuIEk9QS5yZWFkSW50NjQoKSxnPUEucmVhZFVpbnQzMigpLHt0YXJnZXRQZWVySWQ6SSxkZXNpcmVkVHJhbnNwb3J0Omd9fX0sUz17ZW5jb2RlKEkpe2NvbnN0IGc9QS5nZXRJbnN0YW5jZSgpO3JldHVybiBnLnN0YXJ0V3JpdGluZygpLHRoaXMuZW5jb2RlSW50byhJLGcpLGcudG9BcnJheSgpfSxlbmNvZGVJbnRvKEEsSSl7Y29uc3QgZz1JLmxlbmd0aCxCPUkucmVzZXJ2ZU1lc3NhZ2VMZW5ndGgoKSxRPUkubGVuZ3RoKzE7aWYoSS53cml0ZUJ5dGUoQS5kaXNjcmltaW5hdG9yKSwxPT09QS5kaXNjcmltaW5hdG9yKUYuZW5jb2RlSW50byhBLnZhbHVlLEkpO2NvbnN0IEM9SS5sZW5ndGg7SS5maWxsTWVzc2FnZUxlbmd0aChCLEMtUSk7cmV0dXJuIEkubGVuZ3RoLWd9LGRlY29kZShJKXtjb25zdCBnPUEuZ2V0SW5zdGFuY2UoKTtyZXR1cm4gZy5zdGFydFJlYWRpbmcoSSksdGhpcy5yZWFkRnJvbShnKX0scmVhZEZyb20oQSl7Y29uc3QgZz1BLnJlYWRNZXNzYWdlTGVuZ3RoKCksQj1BLmluZGV4KzErZztpZigxPT09QS5yZWFkQnl0ZSgpKXJldHVybntkaXNjcmltaW5hdG9yOjEsdmFsdWU6Ri5yZWFkRnJvbShBKX07dGhyb3cgQS5pbmRleD1CLG5ldyBJKFwiVW5yZWNvZ25pemVkIGRpc2NyaW1pbmF0b3Igd2hpbGUgZGVjb2RpbmcgR2F0ZXdheVJlcXVlc3RCb2R5XCIpfX0seT17ZGlzY3JpbWluYXRvcjoxLGVuY29kZShJKXtjb25zdCBnPUEuZ2V0SW5zdGFuY2UoKTtyZXR1cm4gZy5zdGFydFdyaXRpbmcoKSx0aGlzLmVuY29kZUludG8oSSxnKSxnLnRvQXJyYXkoKX0sZW5jb2RlSW50byhBLEkpe2NvbnN0IGc9SS5sZW5ndGg7cmV0dXJuIEkubGVuZ3RoLWd9LGRlY29kZShJKXtjb25zdCBnPUEuZ2V0SW5zdGFuY2UoKTtyZXR1cm4gZy5zdGFydFJlYWRpbmcoSSksdGhpcy5yZWFkRnJvbShnKX0scmVhZEZyb206QT0+KHt9KX0sRz17ZW5jb2RlKEkpe2NvbnN0IGc9QS5nZXRJbnN0YW5jZSgpO3JldHVybiBnLnN0YXJ0V3JpdGluZygpLHRoaXMuZW5jb2RlSW50byhJLGcpLGcudG9BcnJheSgpfSxlbmNvZGVJbnRvKEEsSSl7Y29uc3QgZz1JLmxlbmd0aCxCPUkucmVzZXJ2ZU1lc3NhZ2VMZW5ndGgoKSxRPUkubGVuZ3RoKzE7aWYoSS53cml0ZUJ5dGUoQS5kaXNjcmltaW5hdG9yKSwxPT09QS5kaXNjcmltaW5hdG9yKXkuZW5jb2RlSW50byhBLnZhbHVlLEkpO2NvbnN0IEM9SS5sZW5ndGg7SS5maWxsTWVzc2FnZUxlbmd0aChCLEMtUSk7cmV0dXJuIEkubGVuZ3RoLWd9LGRlY29kZShJKXtjb25zdCBnPUEuZ2V0SW5zdGFuY2UoKTtyZXR1cm4gZy5zdGFydFJlYWRpbmcoSSksdGhpcy5yZWFkRnJvbShnKX0scmVhZEZyb20oQSl7Y29uc3QgZz1BLnJlYWRNZXNzYWdlTGVuZ3RoKCksQj1BLmluZGV4KzErZztpZigxPT09QS5yZWFkQnl0ZSgpKXJldHVybntkaXNjcmltaW5hdG9yOjEsdmFsdWU6eS5yZWFkRnJvbShBKX07dGhyb3cgQS5pbmRleD1CLG5ldyBJKFwiVW5yZWNvZ25pemVkIGRpc2NyaW1pbmF0b3Igd2hpbGUgZGVjb2RpbmcgR2F0ZXdheVJlc3BvbnNlQm9keVwiKX19LFI9e2Rpc2NyaW1pbmF0b3I6MSxlbmNvZGUoSSl7Y29uc3QgZz1BLmdldEluc3RhbmNlKCk7cmV0dXJuIGcuc3RhcnRXcml0aW5nKCksdGhpcy5lbmNvZGVJbnRvKEksZyksZy50b0FycmF5KCl9LGVuY29kZUludG8oQSxJKXtjb25zdCBnPUkubGVuZ3RoO0kud3JpdGVJbnQ2NChBLnNvdXJjZVBlZXJJZCksSS53cml0ZVN0cmluZyhBLnNvdXJjZUV4dGVybmFsSWQpLEkud3JpdGVVaW50MzIoQS5kZXNpcmVkVHJhbnNwb3J0KSxJLndyaXRlR3VpZChBLmlkKSxJLndyaXRlRGF0ZShBLmV4cGlyYXRpb25EYXRlKTtyZXR1cm4gSS5sZW5ndGgtZ30sZGVjb2RlKEkpe2NvbnN0IGc9QS5nZXRJbnN0YW5jZSgpO3JldHVybiBnLnN0YXJ0UmVhZGluZyhJKSx0aGlzLnJlYWRGcm9tKGcpfSxyZWFkRnJvbShBKXtsZXQgSSxnLEIsUSxDO3JldHVybiBJPUEucmVhZEludDY0KCksZz1BLnJlYWRTdHJpbmcoKSxCPUEucmVhZFVpbnQzMigpLFE9QS5yZWFkR3VpZCgpLEM9QS5yZWFkRGF0ZSgpLHtzb3VyY2VQZWVySWQ6SSxzb3VyY2VFeHRlcm5hbElkOmcsZGVzaXJlZFRyYW5zcG9ydDpCLGlkOlEsZXhwaXJhdGlvbkRhdGU6Q319fSx1PXtkaXNjcmltaW5hdG9yOjIsZW5jb2RlKEkpe2NvbnN0IGc9QS5nZXRJbnN0YW5jZSgpO3JldHVybiBnLnN0YXJ0V3JpdGluZygpLHRoaXMuZW5jb2RlSW50byhJLGcpLGcudG9BcnJheSgpfSxlbmNvZGVJbnRvKEEsSSl7Y29uc3QgZz1JLmxlbmd0aDtJLndyaXRlSW50NjQoQS5zb3VyY2VQZWVySWQpLEkud3JpdGVTdHJpbmcoQS5zb3VyY2VFeHRlcm5hbElkKSxJLndyaXRlR3VpZChBLmlkKTtyZXR1cm4gSS5sZW5ndGgtZ30sZGVjb2RlKEkpe2NvbnN0IGc9QS5nZXRJbnN0YW5jZSgpO3JldHVybiBnLnN0YXJ0UmVhZGluZyhJKSx0aGlzLnJlYWRGcm9tKGcpfSxyZWFkRnJvbShBKXtsZXQgSSxnLEI7cmV0dXJuIEk9QS5yZWFkSW50NjQoKSxnPUEucmVhZFN0cmluZygpLEI9QS5yZWFkR3VpZCgpLHtzb3VyY2VQZWVySWQ6SSxzb3VyY2VFeHRlcm5hbElkOmcsaWQ6Qn19fSxsPXtkaXNjcmltaW5hdG9yOjMsZW5jb2RlKEkpe2NvbnN0IGc9QS5nZXRJbnN0YW5jZSgpO3JldHVybiBnLnN0YXJ0V3JpdGluZygpLHRoaXMuZW5jb2RlSW50byhJLGcpLGcudG9BcnJheSgpfSxlbmNvZGVJbnRvKEEsSSl7Y29uc3QgZz1JLmxlbmd0aDtJLndyaXRlSW50NjQoQS5zb3VyY2VQZWVySWQpLEkud3JpdGVTdHJpbmcoQS5zb3VyY2VFeHRlcm5hbElkKSxJLndyaXRlR3VpZChBLmlkKSxJLndyaXRlU3RyaW5nKEEucmVhc29uKTtyZXR1cm4gSS5sZW5ndGgtZ30sZGVjb2RlKEkpe2NvbnN0IGc9QS5nZXRJbnN0YW5jZSgpO3JldHVybiBnLnN0YXJ0UmVhZGluZyhJKSx0aGlzLnJlYWRGcm9tKGcpfSxyZWFkRnJvbShBKXtsZXQgSSxnLEIsUTtyZXR1cm4gST1BLnJlYWRJbnQ2NCgpLGc9QS5yZWFkU3RyaW5nKCksQj1BLnJlYWRHdWlkKCksUT1BLnJlYWRTdHJpbmcoKSx7c291cmNlUGVlcklkOkksc291cmNlRXh0ZXJuYWxJZDpnLGlkOkIscmVhc29uOlF9fX0saz17ZGlzY3JpbWluYXRvcjo0LGVuY29kZShJKXtjb25zdCBnPUEuZ2V0SW5zdGFuY2UoKTtyZXR1cm4gZy5zdGFydFdyaXRpbmcoKSx0aGlzLmVuY29kZUludG8oSSxnKSxnLnRvQXJyYXkoKX0sZW5jb2RlSW50byhBLEkpe2NvbnN0IGc9SS5sZW5ndGg7SS53cml0ZUd1aWQoQS5pZCksSS53cml0ZVVpbnQzMihBLnR5cGUpLEkud3JpdGVTdHJpbmcoQS5kYXRhKTtyZXR1cm4gSS5sZW5ndGgtZ30sZGVjb2RlKEkpe2NvbnN0IGc9QS5nZXRJbnN0YW5jZSgpO3JldHVybiBnLnN0YXJ0UmVhZGluZyhJKSx0aGlzLnJlYWRGcm9tKGcpfSxyZWFkRnJvbShBKXtsZXQgSSxnLEI7cmV0dXJuIEk9QS5yZWFkR3VpZCgpLGc9QS5yZWFkVWludDMyKCksQj1BLnJlYWRTdHJpbmcoKSx7aWQ6SSx0eXBlOmcsZGF0YTpCfX19LFU9e2VuY29kZShJKXtjb25zdCBnPUEuZ2V0SW5zdGFuY2UoKTtyZXR1cm4gZy5zdGFydFdyaXRpbmcoKSx0aGlzLmVuY29kZUludG8oSSxnKSxnLnRvQXJyYXkoKX0sZW5jb2RlSW50byhBLEkpe2NvbnN0IGc9SS5sZW5ndGgsQj1JLnJlc2VydmVNZXNzYWdlTGVuZ3RoKCksUT1JLmxlbmd0aCsxO3N3aXRjaChJLndyaXRlQnl0ZShBLmRpc2NyaW1pbmF0b3IpLEEuZGlzY3JpbWluYXRvcil7Y2FzZSAxOlIuZW5jb2RlSW50byhBLnZhbHVlLEkpO2JyZWFrO2Nhc2UgMjp1LmVuY29kZUludG8oQS52YWx1ZSxJKTticmVhaztjYXNlIDM6bC5lbmNvZGVJbnRvKEEudmFsdWUsSSk7YnJlYWs7Y2FzZSA0OmsuZW5jb2RlSW50byhBLnZhbHVlLEkpfWNvbnN0IEM9SS5sZW5ndGg7SS5maWxsTWVzc2FnZUxlbmd0aChCLEMtUSk7cmV0dXJuIEkubGVuZ3RoLWd9LGRlY29kZShJKXtjb25zdCBnPUEuZ2V0SW5zdGFuY2UoKTtyZXR1cm4gZy5zdGFydFJlYWRpbmcoSSksdGhpcy5yZWFkRnJvbShnKX0scmVhZEZyb20oQSl7Y29uc3QgZz1BLnJlYWRNZXNzYWdlTGVuZ3RoKCksQj1BLmluZGV4KzErZztzd2l0Y2goQS5yZWFkQnl0ZSgpKXtjYXNlIDE6cmV0dXJue2Rpc2NyaW1pbmF0b3I6MSx2YWx1ZTpSLnJlYWRGcm9tKEEpfTtjYXNlIDI6cmV0dXJue2Rpc2NyaW1pbmF0b3I6Mix2YWx1ZTp1LnJlYWRGcm9tKEEpfTtjYXNlIDM6cmV0dXJue2Rpc2NyaW1pbmF0b3I6Myx2YWx1ZTpsLnJlYWRGcm9tKEEpfTtjYXNlIDQ6cmV0dXJue2Rpc2NyaW1pbmF0b3I6NCx2YWx1ZTprLnJlYWRGcm9tKEEpfTtkZWZhdWx0OnRocm93IEEuaW5kZXg9QixuZXcgSShcIlVucmVjb2duaXplZCBkaXNjcmltaW5hdG9yIHdoaWxlIGRlY29kaW5nIEdhdGV3YXlGb3J3YXJkYWJsZUJvZHlcIil9fX07dmFyIE47IWZ1bmN0aW9uKEEpe0FbQS5Eb3VibGU9MF09XCJEb3VibGVcIixBW0EuQmlnSW50PTFdPVwiQmlnSW50XCIsQVtBLlZhckNoYXI9Ml09XCJWYXJDaGFyXCIsQVtBLkJvb2w9M109XCJCb29sXCJ9KE58fChOPXt9KSk7Y29uc3QgbT17ZW5jb2RlKEkpe2NvbnN0IGc9QS5nZXRJbnN0YW5jZSgpO3JldHVybiBnLnN0YXJ0V3JpdGluZygpLHRoaXMuZW5jb2RlSW50byhJLGcpLGcudG9BcnJheSgpfSxlbmNvZGVJbnRvKEEsSSl7Y29uc3QgZz1JLmxlbmd0aDtJLndyaXRlVWludDMyKEEubWFnaWNOdW1iZXIpLEkud3JpdGVVaW50MzIoQS5zeW5jS2V5KSxJLndyaXRlSW50NjQoQS5zb3VyY2VQZWVySWQpLEkud3JpdGVJbnQ2NChBLnRhcmdldFBlZXJJZCk7cmV0dXJuIEkubGVuZ3RoLWd9LGRlY29kZShJKXtjb25zdCBnPUEuZ2V0SW5zdGFuY2UoKTtyZXR1cm4gZy5zdGFydFJlYWRpbmcoSSksdGhpcy5yZWFkRnJvbShnKX0scmVhZEZyb20oQSl7bGV0IEksZyxCLFE7cmV0dXJuIEk9QS5yZWFkVWludDMyKCksZz1BLnJlYWRVaW50MzIoKSxCPUEucmVhZEludDY0KCksUT1BLnJlYWRJbnQ2NCgpLHttYWdpY051bWJlcjpJLHN5bmNLZXk6Zyxzb3VyY2VQZWVySWQ6Qix0YXJnZXRQZWVySWQ6UX19fSxNPXtlbmNvZGUoSSl7Y29uc3QgZz1BLmdldEluc3RhbmNlKCk7cmV0dXJuIGcuc3RhcnRXcml0aW5nKCksdGhpcy5lbmNvZGVJbnRvKEksZyksZy50b0FycmF5KCl9LGVuY29kZUludG8oQSxJKXtjb25zdCBnPUkubGVuZ3RoO0kud3JpdGVVaW50MTYoQS5ncm91cElkKSxJLndyaXRlQnl0ZShBLmluZGV4KSxJLndyaXRlQnl0ZShBLmNodW5rc0luR3JvdXApLEkud3JpdGVCeXRlcyhBLmRhdGEpO3JldHVybiBJLmxlbmd0aC1nfSxkZWNvZGUoSSl7Y29uc3QgZz1BLmdldEluc3RhbmNlKCk7cmV0dXJuIGcuc3RhcnRSZWFkaW5nKEkpLHRoaXMucmVhZEZyb20oZyl9LHJlYWRGcm9tKEEpe2xldCBJLGcsQixRO3JldHVybiBJPUEucmVhZFVpbnQxNigpLGc9QS5yZWFkQnl0ZSgpLEI9QS5yZWFkQnl0ZSgpLFE9QS5yZWFkQnl0ZXMoKSx7Z3JvdXBJZDpJLGluZGV4OmcsY2h1bmtzSW5Hcm91cDpCLGRhdGE6UX19fSxMPXtlbmNvZGUoSSl7Y29uc3QgZz1BLmdldEluc3RhbmNlKCk7cmV0dXJuIGcuc3RhcnRXcml0aW5nKCksdGhpcy5lbmNvZGVJbnRvKEksZyksZy50b0FycmF5KCl9LGVuY29kZUludG8oQSxJKXtjb25zdCBnPUkubGVuZ3RoO20uZW5jb2RlSW50byhBLmhlYWRlcixJKSxpQS5lbmNvZGVJbnRvKEEuYm9keSxJKTtyZXR1cm4gSS5sZW5ndGgtZ30sZGVjb2RlKEkpe2NvbnN0IGc9QS5nZXRJbnN0YW5jZSgpO3JldHVybiBnLnN0YXJ0UmVhZGluZyhJKSx0aGlzLnJlYWRGcm9tKGcpfSxyZWFkRnJvbShBKXtsZXQgSSxnO3JldHVybiBJPW0ucmVhZEZyb20oQSksZz1pQS5yZWFkRnJvbShBKSx7aGVhZGVyOkksYm9keTpnfX19LGY9e2VuY29kZShJKXtjb25zdCBnPUEuZ2V0SW5zdGFuY2UoKTtyZXR1cm4gZy5zdGFydFdyaXRpbmcoKSx0aGlzLmVuY29kZUludG8oSSxnKSxnLnRvQXJyYXkoKX0sZW5jb2RlSW50byhBLEkpe2NvbnN0IGc9SS5sZW5ndGg7bS5lbmNvZGVJbnRvKEEuaGVhZGVyLEkpLHhBLmVuY29kZUludG8oQS5ib2R5LEkpO3JldHVybiBJLmxlbmd0aC1nfSxkZWNvZGUoSSl7Y29uc3QgZz1BLmdldEluc3RhbmNlKCk7cmV0dXJuIGcuc3RhcnRSZWFkaW5nKEkpLHRoaXMucmVhZEZyb20oZyl9LHJlYWRGcm9tKEEpe2xldCBJLGc7cmV0dXJuIEk9bS5yZWFkRnJvbShBKSxnPXhBLnJlYWRGcm9tKEEpLHtoZWFkZXI6SSxib2R5Omd9fX0scD17ZW5jb2RlKEkpe2NvbnN0IGc9QS5nZXRJbnN0YW5jZSgpO3JldHVybiBnLnN0YXJ0V3JpdGluZygpLHRoaXMuZW5jb2RlSW50byhJLGcpLGcudG9BcnJheSgpfSxlbmNvZGVJbnRvKEEsSSl7Y29uc3QgZz1JLmxlbmd0aDttLmVuY29kZUludG8oQS5oZWFkZXIsSSksekEuZW5jb2RlSW50byhBLmJvZHksSSk7cmV0dXJuIEkubGVuZ3RoLWd9LGRlY29kZShJKXtjb25zdCBnPUEuZ2V0SW5zdGFuY2UoKTtyZXR1cm4gZy5zdGFydFJlYWRpbmcoSSksdGhpcy5yZWFkRnJvbShnKX0scmVhZEZyb20oQSl7bGV0IEksZztyZXR1cm4gST1tLnJlYWRGcm9tKEEpLGc9ekEucmVhZEZyb20oQSkse2hlYWRlcjpJLGJvZHk6Z319fSxIPXtlbmNvZGUoSSl7Y29uc3QgZz1BLmdldEluc3RhbmNlKCk7cmV0dXJuIGcuc3RhcnRXcml0aW5nKCksdGhpcy5lbmNvZGVJbnRvKEksZyksZy50b0FycmF5KCl9LGVuY29kZUludG8oQSxJKXtjb25zdCBnPUkubGVuZ3RoO20uZW5jb2RlSW50byhBLmhlYWRlcixJKSxNLmVuY29kZUludG8oQS5ib2R5LEkpO3JldHVybiBJLmxlbmd0aC1nfSxkZWNvZGUoSSl7Y29uc3QgZz1BLmdldEluc3RhbmNlKCk7cmV0dXJuIGcuc3RhcnRSZWFkaW5nKEkpLHRoaXMucmVhZEZyb20oZyl9LHJlYWRGcm9tKEEpe2xldCBJLGc7cmV0dXJuIEk9bS5yZWFkRnJvbShBKSxnPU0ucmVhZEZyb20oQSkse2hlYWRlcjpJLGJvZHk6Z319fTt2YXIgSixLLHEsWSx2LGIsUDshZnVuY3Rpb24oQSl7QVtBLk5vbmU9MF09XCJOb25lXCIsQVtBLkRwYWRVcD0xXT1cIkRwYWRVcFwiLEFbQS5EcGFkRG93bj0yXT1cIkRwYWREb3duXCIsQVtBLkRwYWRMZWZ0PTRdPVwiRHBhZExlZnRcIixBW0EuRHBhZFJpZ2h0PThdPVwiRHBhZFJpZ2h0XCIsQVtBLlN0YXJ0PTE2XT1cIlN0YXJ0XCIsQVtBLkJhY2s9MzJdPVwiQmFja1wiLEFbQS5MZWZ0U3RpY2s9NjRdPVwiTGVmdFN0aWNrXCIsQVtBLlJpZ2h0U3RpY2s9MTI4XT1cIlJpZ2h0U3RpY2tcIixBW0EuTGVmdEJ1bXBlcj0yNTZdPVwiTGVmdEJ1bXBlclwiLEFbQS5SaWdodEJ1bXBlcj01MTJdPVwiUmlnaHRCdW1wZXJcIixBW0EuR3VpZGU9MTAyNF09XCJHdWlkZVwiLEFbQS5BPTQwOTZdPVwiQVwiLEFbQS5CPTgxOTJdPVwiQlwiLEFbQS5YPTE2Mzg0XT1cIlhcIixBW0EuWT0zMjc2OF09XCJZXCJ9KEp8fChKPXt9KSksZnVuY3Rpb24oQSl7QVtBLkJ1dHRvbkRvd249MF09XCJCdXR0b25Eb3duXCIsQVtBLkJ1dHRvblVwPTFdPVwiQnV0dG9uVXBcIn0oS3x8KEs9e30pKSxmdW5jdGlvbihBKXtBW0EuTGVmdD0wXT1cIkxlZnRcIixBW0EuUmlnaHQ9MV09XCJSaWdodFwiLEFbQS5NaWRkbGU9Ml09XCJNaWRkbGVcIixBW0EuWDE9M109XCJYMVwiLEFbQS5YMj00XT1cIlgyXCJ9KHF8fChxPXt9KSksZnVuY3Rpb24oQSl7QVtBLkhvcml6b250YWw9MF09XCJIb3Jpem9udGFsXCIsQVtBLlZlcnRpY2FsPTFdPVwiVmVydGljYWxcIn0oWXx8KFk9e30pKSxmdW5jdGlvbihBKXtBW0EuS2V5RG93bj0wXT1cIktleURvd25cIixBW0EuS2V5VXA9MV09XCJLZXlVcFwifSh2fHwodj17fSkpLGZ1bmN0aW9uKEEpe0FbQS5Ob25lPTBdPVwiTm9uZVwiLEFbQS5DYW5jZWw9MV09XCJDYW5jZWxcIixBW0EuQmFjaz0yXT1cIkJhY2tcIixBW0EuVGFiPTNdPVwiVGFiXCIsQVtBLkxpbmVGZWVkPTRdPVwiTGluZUZlZWRcIixBW0EuQ2xlYXI9NV09XCJDbGVhclwiLEFbQS5FbnRlcj02XT1cIkVudGVyXCIsQVtBLlBhdXNlPTddPVwiUGF1c2VcIixBW0EuQ2Fwc0xvY2s9OF09XCJDYXBzTG9ja1wiLEFbQS5IYW5ndWxNb2RlPTldPVwiSGFuZ3VsTW9kZVwiLEFbQS5KdW5qYU1vZGU9MTBdPVwiSnVuamFNb2RlXCIsQVtBLkZpbmFsTW9kZT0xMV09XCJGaW5hbE1vZGVcIixBW0EuSGFuamFNb2RlPTEyXT1cIkhhbmphTW9kZVwiLEFbQS5Fc2NhcGU9MTNdPVwiRXNjYXBlXCIsQVtBLkltZUNvbnZlcnQ9MTRdPVwiSW1lQ29udmVydFwiLEFbQS5JbWVOb25Db252ZXJ0PTE1XT1cIkltZU5vbkNvbnZlcnRcIixBW0EuSW1lQWNjZXB0PTE2XT1cIkltZUFjY2VwdFwiLEFbQS5JbWVNb2RlQ2hhbmdlPTE3XT1cIkltZU1vZGVDaGFuZ2VcIixBW0EuU3BhY2U9MThdPVwiU3BhY2VcIixBW0EuUGFnZVVwPTE5XT1cIlBhZ2VVcFwiLEFbQS5QYWdlRG93bj0yMF09XCJQYWdlRG93blwiLEFbQS5FbmQ9MjFdPVwiRW5kXCIsQVtBLkhvbWU9MjJdPVwiSG9tZVwiLEFbQS5MZWZ0PTIzXT1cIkxlZnRcIixBW0EuVXA9MjRdPVwiVXBcIixBW0EuUmlnaHQ9MjVdPVwiUmlnaHRcIixBW0EuRG93bj0yNl09XCJEb3duXCIsQVtBLlNlbGVjdD0yN109XCJTZWxlY3RcIixBW0EuUHJpbnQ9MjhdPVwiUHJpbnRcIixBW0EuRXhlY3V0ZT0yOV09XCJFeGVjdXRlXCIsQVtBLlByaW50U2NyZWVuPTMwXT1cIlByaW50U2NyZWVuXCIsQVtBLkluc2VydD0zMV09XCJJbnNlcnRcIixBW0EuRGVsZXRlPTMyXT1cIkRlbGV0ZVwiLEFbQS5IZWxwPTMzXT1cIkhlbHBcIixBW0EuRDA9MzRdPVwiRDBcIixBW0EuRDE9MzVdPVwiRDFcIixBW0EuRDI9MzZdPVwiRDJcIixBW0EuRDM9MzddPVwiRDNcIixBW0EuRDQ9MzhdPVwiRDRcIixBW0EuRDU9MzldPVwiRDVcIixBW0EuRDY9NDBdPVwiRDZcIixBW0EuRDc9NDFdPVwiRDdcIixBW0EuRDg9NDJdPVwiRDhcIixBW0EuRDk9NDNdPVwiRDlcIixBW0EuQT00NF09XCJBXCIsQVtBLkI9NDVdPVwiQlwiLEFbQS5DPTQ2XT1cIkNcIixBW0EuRD00N109XCJEXCIsQVtBLkU9NDhdPVwiRVwiLEFbQS5GPTQ5XT1cIkZcIixBW0EuRz01MF09XCJHXCIsQVtBLkg9NTFdPVwiSFwiLEFbQS5JPTUyXT1cIklcIixBW0EuSj01M109XCJKXCIsQVtBLks9NTRdPVwiS1wiLEFbQS5MPTU1XT1cIkxcIixBW0EuTT01Nl09XCJNXCIsQVtBLk49NTddPVwiTlwiLEFbQS5PPTU4XT1cIk9cIixBW0EuUD01OV09XCJQXCIsQVtBLlE9NjBdPVwiUVwiLEFbQS5SPTYxXT1cIlJcIixBW0EuUz02Ml09XCJTXCIsQVtBLlQ9NjNdPVwiVFwiLEFbQS5VPTY0XT1cIlVcIixBW0EuVj02NV09XCJWXCIsQVtBLlc9NjZdPVwiV1wiLEFbQS5YPTY3XT1cIlhcIixBW0EuWT02OF09XCJZXCIsQVtBLlo9NjldPVwiWlwiLEFbQS5MV2luPTcwXT1cIkxXaW5cIixBW0EuUldpbj03MV09XCJSV2luXCIsQVtBLkFwcHM9NzJdPVwiQXBwc1wiLEFbQS5TbGVlcD03M109XCJTbGVlcFwiLEFbQS5OdW1QYWQwPTc0XT1cIk51bVBhZDBcIixBW0EuTnVtUGFkMT03NV09XCJOdW1QYWQxXCIsQVtBLk51bVBhZDI9NzZdPVwiTnVtUGFkMlwiLEFbQS5OdW1QYWQzPTc3XT1cIk51bVBhZDNcIixBW0EuTnVtUGFkND03OF09XCJOdW1QYWQ0XCIsQVtBLk51bVBhZDU9NzldPVwiTnVtUGFkNVwiLEFbQS5OdW1QYWQ2PTgwXT1cIk51bVBhZDZcIixBW0EuTnVtUGFkNz04MV09XCJOdW1QYWQ3XCIsQVtBLk51bVBhZDg9ODJdPVwiTnVtUGFkOFwiLEFbQS5OdW1QYWQ5PTgzXT1cIk51bVBhZDlcIixBW0EuTXVsdGlwbHk9ODRdPVwiTXVsdGlwbHlcIixBW0EuQWRkPTg1XT1cIkFkZFwiLEFbQS5TZXBhcmF0b3I9ODZdPVwiU2VwYXJhdG9yXCIsQVtBLlN1YnRyYWN0PTg3XT1cIlN1YnRyYWN0XCIsQVtBLkRlY2ltYWw9ODhdPVwiRGVjaW1hbFwiLEFbQS5EaXZpZGU9ODldPVwiRGl2aWRlXCIsQVtBLkYxPTkwXT1cIkYxXCIsQVtBLkYyPTkxXT1cIkYyXCIsQVtBLkYzPTkyXT1cIkYzXCIsQVtBLkY0PTkzXT1cIkY0XCIsQVtBLkY1PTk0XT1cIkY1XCIsQVtBLkY2PTk1XT1cIkY2XCIsQVtBLkY3PTk2XT1cIkY3XCIsQVtBLkY4PTk3XT1cIkY4XCIsQVtBLkY5PTk4XT1cIkY5XCIsQVtBLkYxMD05OV09XCJGMTBcIixBW0EuRjExPTEwMF09XCJGMTFcIixBW0EuRjEyPTEwMV09XCJGMTJcIixBW0EuRjEzPTEwMl09XCJGMTNcIixBW0EuRjE0PTEwM109XCJGMTRcIixBW0EuRjE1PTEwNF09XCJGMTVcIixBW0EuRjE2PTEwNV09XCJGMTZcIixBW0EuRjE3PTEwNl09XCJGMTdcIixBW0EuRjE4PTEwN109XCJGMThcIixBW0EuRjE5PTEwOF09XCJGMTlcIixBW0EuRjIwPTEwOV09XCJGMjBcIixBW0EuRjIxPTExMF09XCJGMjFcIixBW0EuRjIyPTExMV09XCJGMjJcIixBW0EuRjIzPTExMl09XCJGMjNcIixBW0EuRjI0PTExM109XCJGMjRcIixBW0EuTnVtTG9jaz0xMTRdPVwiTnVtTG9ja1wiLEFbQS5TY3JvbGw9MTE1XT1cIlNjcm9sbFwiLEFbQS5MZWZ0U2hpZnQ9MTE2XT1cIkxlZnRTaGlmdFwiLEFbQS5SaWdodFNoaWZ0PTExN109XCJSaWdodFNoaWZ0XCIsQVtBLkxlZnRDdHJsPTExOF09XCJMZWZ0Q3RybFwiLEFbQS5SaWdodEN0cmw9MTE5XT1cIlJpZ2h0Q3RybFwiLEFbQS5MZWZ0QWx0PTEyMF09XCJMZWZ0QWx0XCIsQVtBLlJpZ2h0QWx0PTEyMV09XCJSaWdodEFsdFwiLEFbQS5Ccm93c2VyQmFjaz0xMjJdPVwiQnJvd3NlckJhY2tcIixBW0EuQnJvd3NlckZvcndhcmQ9MTIzXT1cIkJyb3dzZXJGb3J3YXJkXCIsQVtBLkJyb3dzZXJSZWZyZXNoPTEyNF09XCJCcm93c2VyUmVmcmVzaFwiLEFbQS5Ccm93c2VyU3RvcD0xMjVdPVwiQnJvd3NlclN0b3BcIixBW0EuQnJvd3NlclNlYXJjaD0xMjZdPVwiQnJvd3NlclNlYXJjaFwiLEFbQS5Ccm93c2VyRmF2b3JpdGVzPTEyN109XCJCcm93c2VyRmF2b3JpdGVzXCIsQVtBLkJyb3dzZXJIb21lPTEyOF09XCJCcm93c2VySG9tZVwiLEFbQS5Wb2x1bWVNdXRlPTEyOV09XCJWb2x1bWVNdXRlXCIsQVtBLlZvbHVtZURvd249MTMwXT1cIlZvbHVtZURvd25cIixBW0EuVm9sdW1lVXA9MTMxXT1cIlZvbHVtZVVwXCIsQVtBLk1lZGlhTmV4dFRyYWNrPTEzMl09XCJNZWRpYU5leHRUcmFja1wiLEFbQS5NZWRpYVByZXZpb3VzVHJhY2s9MTMzXT1cIk1lZGlhUHJldmlvdXNUcmFja1wiLEFbQS5NZWRpYVN0b3A9MTM0XT1cIk1lZGlhU3RvcFwiLEFbQS5NZWRpYVBsYXlQYXVzZT0xMzVdPVwiTWVkaWFQbGF5UGF1c2VcIixBW0EuTGF1bmNoTWFpbD0xMzZdPVwiTGF1bmNoTWFpbFwiLEFbQS5TZWxlY3RNZWRpYT0xMzddPVwiU2VsZWN0TWVkaWFcIixBW0EuTGF1bmNoQXBwbGljYXRpb24xPTEzOF09XCJMYXVuY2hBcHBsaWNhdGlvbjFcIixBW0EuTGF1bmNoQXBwbGljYXRpb24yPTEzOV09XCJMYXVuY2hBcHBsaWNhdGlvbjJcIixBW0EuT2VtMT0xNDBdPVwiT2VtMVwiLEFbQS5PZW1QbHVzPTE0MV09XCJPZW1QbHVzXCIsQVtBLk9lbUNvbW1hPTE0Ml09XCJPZW1Db21tYVwiLEFbQS5PZW1NaW51cz0xNDNdPVwiT2VtTWludXNcIixBW0EuT2VtUGVyaW9kPTE0NF09XCJPZW1QZXJpb2RcIixBW0EuT2VtMj0xNDVdPVwiT2VtMlwiLEFbQS5PZW0zPTE0Nl09XCJPZW0zXCIsQVtBLkFibnRDMT0xNDddPVwiQWJudEMxXCIsQVtBLkFibnRDMj0xNDhdPVwiQWJudEMyXCIsQVtBLk9lbTQ9MTQ5XT1cIk9lbTRcIixBW0EuT2VtNT0xNTBdPVwiT2VtNVwiLEFbQS5PZW02PTE1MV09XCJPZW02XCIsQVtBLk9lbTc9MTUyXT1cIk9lbTdcIixBW0EuT2VtOD0xNTNdPVwiT2VtOFwiLEFbQS5PZW0xMDI9MTU0XT1cIk9lbTEwMlwiLEFbQS5JbWVQcm9jZXNzZWQ9MTU1XT1cIkltZVByb2Nlc3NlZFwiLEFbQS5TeXN0ZW09MTU2XT1cIlN5c3RlbVwiLEFbQS5PZW1BdHRuPTE1N109XCJPZW1BdHRuXCIsQVtBLk9lbUZpbmlzaD0xNThdPVwiT2VtRmluaXNoXCIsQVtBLk9lbUNvcHk9MTU5XT1cIk9lbUNvcHlcIixBW0EuT2VtQXV0bz0xNjBdPVwiT2VtQXV0b1wiLEFbQS5PZW1Fbmx3PTE2MV09XCJPZW1Fbmx3XCIsQVtBLk9lbUJhY2tUYWI9MTYyXT1cIk9lbUJhY2tUYWJcIixBW0EuQXR0bj0xNjNdPVwiQXR0blwiLEFbQS5DclNlbD0xNjRdPVwiQ3JTZWxcIixBW0EuRXhTZWw9MTY1XT1cIkV4U2VsXCIsQVtBLkVyYXNlRW9mPTE2Nl09XCJFcmFzZUVvZlwiLEFbQS5QbGF5PTE2N109XCJQbGF5XCIsQVtBLlpvb209MTY4XT1cIlpvb21cIixBW0EuTm9OYW1lPTE2OV09XCJOb05hbWVcIixBW0EuUGExPTE3MF09XCJQYTFcIixBW0EuT2VtQ2xlYXI9MTcxXT1cIk9lbUNsZWFyXCIsQVtBLkRlYWRDaGFyUHJvY2Vzc2VkPTE3Ml09XCJEZWFkQ2hhclByb2Nlc3NlZFwifShifHwoYj17fSkpLGZ1bmN0aW9uKEEpe0FbQS5OZXc9MV09XCJOZXdcIixBW0EuSW5SYW5nZT0yXT1cIkluUmFuZ2VcIixBW0EuSW5Db250YWN0PTRdPVwiSW5Db250YWN0XCIsQVtBLkZpcnN0QnV0dG9uPTE2XT1cIkZpcnN0QnV0dG9uXCIsQVtBLlNlY29uZEJ1dHRvbj0zMl09XCJTZWNvbmRCdXR0b25cIixBW0EuVGhpcmRCdXR0b249NjRdPVwiVGhpcmRCdXR0b25cIixBW0EuRm91cnRoQnV0dG9uPTEyOF09XCJGb3VydGhCdXR0b25cIixBW0EuRmlmdGhCdXR0b249MjU2XT1cIkZpZnRoQnV0dG9uXCIsQVtBLlByaW1hcnk9ODE5Ml09XCJQcmltYXJ5XCIsQVtBLkNvbmZpZGVuY2U9MTYzODRdPVwiQ29uZmlkZW5jZVwiLEFbQS5DYW5jZWxlZD0zMjc2OF09XCJDYW5jZWxlZFwiLEFbQS5Eb3duPTY1NTM2XT1cIkRvd25cIixBW0EuVXBkYXRlPTEzMTA3Ml09XCJVcGRhdGVcIixBW0EuVXA9MjYyMTQ0XT1cIlVwXCIsQVtBLldoZWVsPTUyNDI4OF09XCJXaGVlbFwiLEFbQS5IV2hlZWw9MTA0ODU3Nl09XCJIV2hlZWxcIixBW0EuQ2FwdHVyZUNoYW5nZWQ9MjA5NzE1Ml09XCJDYXB0dXJlQ2hhbmdlZFwiLEFbQS5IYXNUcmFuc2Zvcm09NDE5NDMwNF09XCJIYXNUcmFuc2Zvcm1cIn0oUHx8KFA9e30pKTtjb25zdCB4PXtlbmNvZGUoSSl7Y29uc3QgZz1BLmdldEluc3RhbmNlKCk7cmV0dXJuIGcuc3RhcnRXcml0aW5nKCksdGhpcy5lbmNvZGVJbnRvKEksZyksZy50b0FycmF5KCl9LGVuY29kZUludG8oQSxJKXtjb25zdCBnPUkubGVuZ3RoO0kud3JpdGVVaW50MzIoQS5wb2ludGVySWQpLEkud3JpdGVVaW50MzIoQS5mcmFtZUlkKSxJLndyaXRlVWludDMyKEEucG9pbnRlckZsYWdzKSxJLndyaXRlSW50MzIoQS54KSxJLndyaXRlSW50MzIoQS55KTtyZXR1cm4gSS5sZW5ndGgtZ30sZGVjb2RlKEkpe2NvbnN0IGc9QS5nZXRJbnN0YW5jZSgpO3JldHVybiBnLnN0YXJ0UmVhZGluZyhJKSx0aGlzLnJlYWRGcm9tKGcpfSxyZWFkRnJvbShBKXtsZXQgSSxnLEIsUSxDO3JldHVybiBJPUEucmVhZFVpbnQzMigpLGc9QS5yZWFkVWludDMyKCksQj1BLnJlYWRVaW50MzIoKSxRPUEucmVhZEludDMyKCksQz1BLnJlYWRJbnQzMigpLHtwb2ludGVySWQ6SSxmcmFtZUlkOmcscG9pbnRlckZsYWdzOkIseDpRLHk6Q319fTt2YXIgVyxULE87IWZ1bmN0aW9uKEEpe0FbQS5Db250YWN0QXJlYT0xXT1cIkNvbnRhY3RBcmVhXCIsQVtBLk9yaWVudGF0aW9uPTJdPVwiT3JpZW50YXRpb25cIixBW0EuUHJlc3N1cmU9NF09XCJQcmVzc3VyZVwifShXfHwoVz17fSkpLGZ1bmN0aW9uKEEpe0FbQS5QcmVzc3VyZT0xXT1cIlByZXNzdXJlXCIsQVtBLlJvdGF0aW9uPTJdPVwiUm90YXRpb25cIixBW0EuVGlsdFg9NF09XCJUaWx0WFwiLEFbQS5UaWx0WT04XT1cIlRpbHRZXCJ9KFR8fChUPXt9KSksZnVuY3Rpb24oQSl7QVtBLkJhcnJlbD0xXT1cIkJhcnJlbFwiLEFbQS5JbnZlcnRlZD0yXT1cIkludmVydGVkXCIsQVtBLkVyYXNlcj00XT1cIkVyYXNlclwifShPfHwoTz17fSkpO2NvbnN0IFg9e2VuY29kZShJKXtjb25zdCBnPUEuZ2V0SW5zdGFuY2UoKTtyZXR1cm4gZy5zdGFydFdyaXRpbmcoKSx0aGlzLmVuY29kZUludG8oSSxnKSxnLnRvQXJyYXkoKX0sZW5jb2RlSW50byhBLEkpe2NvbnN0IGc9SS5sZW5ndGg7eC5lbmNvZGVJbnRvKEEucG9pbnRlckluZm8sSSksSS53cml0ZVVpbnQzMihBLnRvdWNoTWFzayksSS53cml0ZUludDMyKEEuY29udGFjdExlZnQpLEkud3JpdGVJbnQzMihBLmNvbnRhY3RUb3ApLEkud3JpdGVJbnQzMihBLmNvbnRhY3RSaWdodCksSS53cml0ZUludDMyKEEuY29udGFjdEJvdHRvbSksSS53cml0ZVVpbnQzMihBLm9yaWVudGF0aW9uKSxJLndyaXRlVWludDMyKEEucHJlc3N1cmUpO3JldHVybiBJLmxlbmd0aC1nfSxkZWNvZGUoSSl7Y29uc3QgZz1BLmdldEluc3RhbmNlKCk7cmV0dXJuIGcuc3RhcnRSZWFkaW5nKEkpLHRoaXMucmVhZEZyb20oZyl9LHJlYWRGcm9tKEEpe2xldCBJLGcsQixRLEMsZSxpLHQ7cmV0dXJuIEk9eC5yZWFkRnJvbShBKSxnPUEucmVhZFVpbnQzMigpLEI9QS5yZWFkSW50MzIoKSxRPUEucmVhZEludDMyKCksQz1BLnJlYWRJbnQzMigpLGU9QS5yZWFkSW50MzIoKSxpPUEucmVhZFVpbnQzMigpLHQ9QS5yZWFkVWludDMyKCkse3BvaW50ZXJJbmZvOkksdG91Y2hNYXNrOmcsY29udGFjdExlZnQ6Qixjb250YWN0VG9wOlEsY29udGFjdFJpZ2h0OkMsY29udGFjdEJvdHRvbTplLG9yaWVudGF0aW9uOmkscHJlc3N1cmU6dH19fSxWPXtkaXNjcmltaW5hdG9yOjEsZW5jb2RlKEkpe2NvbnN0IGc9QS5nZXRJbnN0YW5jZSgpO3JldHVybiBnLnN0YXJ0V3JpdGluZygpLHRoaXMuZW5jb2RlSW50byhJLGcpLGcudG9BcnJheSgpfSxlbmNvZGVJbnRvKEEsSSl7Y29uc3QgZz1JLmxlbmd0aDtJLndyaXRlVWludDMyKEEuYnV0dG9ucyksSS53cml0ZUJ5dGUoQS5sZWZ0VHJpZ2dlciksSS53cml0ZUJ5dGUoQS5yaWdodFRyaWdnZXIpLEkud3JpdGVJbnQxNihBLmxlZnRUaHVtYlgpLEkud3JpdGVJbnQxNihBLmxlZnRUaHVtYlkpLEkud3JpdGVJbnQxNihBLnJpZ2h0VGh1bWJYKSxJLndyaXRlSW50MTYoQS5yaWdodFRodW1iWSksSS53cml0ZUJ5dGUoQS5zbG90KTtyZXR1cm4gSS5sZW5ndGgtZ30sZGVjb2RlKEkpe2NvbnN0IGc9QS5nZXRJbnN0YW5jZSgpO3JldHVybiBnLnN0YXJ0UmVhZGluZyhJKSx0aGlzLnJlYWRGcm9tKGcpfSxyZWFkRnJvbShBKXtsZXQgSSxnLEIsUSxDLGUsaSx0O3JldHVybiBJPUEucmVhZFVpbnQzMigpLGc9QS5yZWFkQnl0ZSgpLEI9QS5yZWFkQnl0ZSgpLFE9QS5yZWFkSW50MTYoKSxDPUEucmVhZEludDE2KCksZT1BLnJlYWRJbnQxNigpLGk9QS5yZWFkSW50MTYoKSx0PUEucmVhZEJ5dGUoKSx7YnV0dG9uczpJLGxlZnRUcmlnZ2VyOmcscmlnaHRUcmlnZ2VyOkIsbGVmdFRodW1iWDpRLGxlZnRUaHVtYlk6QyxyaWdodFRodW1iWDplLHJpZ2h0VGh1bWJZOmksc2xvdDp0fX19LGo9e2Rpc2NyaW1pbmF0b3I6MixlbmNvZGUoSSl7Y29uc3QgZz1BLmdldEluc3RhbmNlKCk7cmV0dXJuIGcuc3RhcnRXcml0aW5nKCksdGhpcy5lbmNvZGVJbnRvKEksZyksZy50b0FycmF5KCl9LGVuY29kZUludG8oQSxJKXtjb25zdCBnPUkubGVuZ3RoO0kud3JpdGVCeXRlKEEucG9ydCksSS53cml0ZVVpbnQxNihBLmxlZnRNb3RvclNwZWVkKSxJLndyaXRlVWludDE2KEEucmlnaHRNb3RvclNwZWVkKTtyZXR1cm4gSS5sZW5ndGgtZ30sZGVjb2RlKEkpe2NvbnN0IGc9QS5nZXRJbnN0YW5jZSgpO3JldHVybiBnLnN0YXJ0UmVhZGluZyhJKSx0aGlzLnJlYWRGcm9tKGcpfSxyZWFkRnJvbShBKXtsZXQgSSxnLEI7cmV0dXJuIEk9QS5yZWFkQnl0ZSgpLGc9QS5yZWFkVWludDE2KCksQj1BLnJlYWRVaW50MTYoKSx7cG9ydDpJLGxlZnRNb3RvclNwZWVkOmcscmlnaHRNb3RvclNwZWVkOkJ9fX0sWj17ZGlzY3JpbWluYXRvcjozLGVuY29kZShJKXtjb25zdCBnPUEuZ2V0SW5zdGFuY2UoKTtyZXR1cm4gZy5zdGFydFdyaXRpbmcoKSx0aGlzLmVuY29kZUludG8oSSxnKSxnLnRvQXJyYXkoKX0sZW5jb2RlSW50byhBLEkpe2NvbnN0IGc9SS5sZW5ndGg7SS53cml0ZUludDMyKEEueCksSS53cml0ZUludDMyKEEueSk7cmV0dXJuIEkubGVuZ3RoLWd9LGRlY29kZShJKXtjb25zdCBnPUEuZ2V0SW5zdGFuY2UoKTtyZXR1cm4gZy5zdGFydFJlYWRpbmcoSSksdGhpcy5yZWFkRnJvbShnKX0scmVhZEZyb20oQSl7bGV0IEksZztyZXR1cm4gST1BLnJlYWRJbnQzMigpLGc9QS5yZWFkSW50MzIoKSx7eDpJLHk6Z319fSx6PXtkaXNjcmltaW5hdG9yOjQsZW5jb2RlKEkpe2NvbnN0IGc9QS5nZXRJbnN0YW5jZSgpO3JldHVybiBnLnN0YXJ0V3JpdGluZygpLHRoaXMuZW5jb2RlSW50byhJLGcpLGcudG9BcnJheSgpfSxlbmNvZGVJbnRvKEEsSSl7Y29uc3QgZz1JLmxlbmd0aDtJLndyaXRlSW50MzIoQS5keCksSS53cml0ZUludDMyKEEuZHkpO3JldHVybiBJLmxlbmd0aC1nfSxkZWNvZGUoSSl7Y29uc3QgZz1BLmdldEluc3RhbmNlKCk7cmV0dXJuIGcuc3RhcnRSZWFkaW5nKEkpLHRoaXMucmVhZEZyb20oZyl9LHJlYWRGcm9tKEEpe2xldCBJLGc7cmV0dXJuIEk9QS5yZWFkSW50MzIoKSxnPUEucmVhZEludDMyKCkse2R4OkksZHk6Z319fSxfPXtkaXNjcmltaW5hdG9yOjUsZW5jb2RlKEkpe2NvbnN0IGc9QS5nZXRJbnN0YW5jZSgpO3JldHVybiBnLnN0YXJ0V3JpdGluZygpLHRoaXMuZW5jb2RlSW50byhJLGcpLGcudG9BcnJheSgpfSxlbmNvZGVJbnRvKEEsSSl7Y29uc3QgZz1JLmxlbmd0aDtJLndyaXRlVWludDMyKEEuYWN0aW9uKSxJLndyaXRlVWludDMyKEEuYnV0dG9uKTtyZXR1cm4gSS5sZW5ndGgtZ30sZGVjb2RlKEkpe2NvbnN0IGc9QS5nZXRJbnN0YW5jZSgpO3JldHVybiBnLnN0YXJ0UmVhZGluZyhJKSx0aGlzLnJlYWRGcm9tKGcpfSxyZWFkRnJvbShBKXtsZXQgSSxnO3JldHVybiBJPUEucmVhZFVpbnQzMigpLGc9QS5yZWFkVWludDMyKCkse2FjdGlvbjpJLGJ1dHRvbjpnfX19LCQ9e2Rpc2NyaW1pbmF0b3I6NixlbmNvZGUoSSl7Y29uc3QgZz1BLmdldEluc3RhbmNlKCk7cmV0dXJuIGcuc3RhcnRXcml0aW5nKCksdGhpcy5lbmNvZGVJbnRvKEksZyksZy50b0FycmF5KCl9LGVuY29kZUludG8oQSxJKXtjb25zdCBnPUkubGVuZ3RoO0kud3JpdGVVaW50MzIoQS5heGlzKSxJLndyaXRlSW50MzIoQS5kZWx0YSk7cmV0dXJuIEkubGVuZ3RoLWd9LGRlY29kZShJKXtjb25zdCBnPUEuZ2V0SW5zdGFuY2UoKTtyZXR1cm4gZy5zdGFydFJlYWRpbmcoSSksdGhpcy5yZWFkRnJvbShnKX0scmVhZEZyb20oQSl7bGV0IEksZztyZXR1cm4gST1BLnJlYWRVaW50MzIoKSxnPUEucmVhZEludDMyKCkse2F4aXM6SSxkZWx0YTpnfX19LEFBPXtkaXNjcmltaW5hdG9yOjcsZW5jb2RlKEkpe2NvbnN0IGc9QS5nZXRJbnN0YW5jZSgpO3JldHVybiBnLnN0YXJ0V3JpdGluZygpLHRoaXMuZW5jb2RlSW50byhJLGcpLGcudG9BcnJheSgpfSxlbmNvZGVJbnRvKEEsSSl7Y29uc3QgZz1JLmxlbmd0aDtJLndyaXRlVWludDMyKEEuYWN0aW9uKSxJLndyaXRlVWludDMyKEEua2V5Y29kZSk7cmV0dXJuIEkubGVuZ3RoLWd9LGRlY29kZShJKXtjb25zdCBnPUEuZ2V0SW5zdGFuY2UoKTtyZXR1cm4gZy5zdGFydFJlYWRpbmcoSSksdGhpcy5yZWFkRnJvbShnKX0scmVhZEZyb20oQSl7bGV0IEksZztyZXR1cm4gST1BLnJlYWRVaW50MzIoKSxnPUEucmVhZFVpbnQzMigpLHthY3Rpb246SSxrZXljb2RlOmd9fX0sSUE9e2Rpc2NyaW1pbmF0b3I6OCxlbmNvZGUoSSl7Y29uc3QgZz1BLmdldEluc3RhbmNlKCk7cmV0dXJuIGcuc3RhcnRXcml0aW5nKCksdGhpcy5lbmNvZGVJbnRvKEksZyksZy50b0FycmF5KCl9LGVuY29kZUludG8oQSxJKXtjb25zdCBnPUkubGVuZ3RoO0kud3JpdGVTdHJpbmcoQS5pbnB1dFN0cmluZyk7cmV0dXJuIEkubGVuZ3RoLWd9LGRlY29kZShJKXtjb25zdCBnPUEuZ2V0SW5zdGFuY2UoKTtyZXR1cm4gZy5zdGFydFJlYWRpbmcoSSksdGhpcy5yZWFkRnJvbShnKX0scmVhZEZyb20oQSl7bGV0IEk7cmV0dXJuIEk9QS5yZWFkU3RyaW5nKCkse2lucHV0U3RyaW5nOkl9fX0sZ0E9e2Rpc2NyaW1pbmF0b3I6OSxlbmNvZGUoSSl7Y29uc3QgZz1BLmdldEluc3RhbmNlKCk7cmV0dXJuIGcuc3RhcnRXcml0aW5nKCksdGhpcy5lbmNvZGVJbnRvKEksZyksZy50b0FycmF5KCl9LGVuY29kZUludG8oQSxJKXtjb25zdCBnPUkubGVuZ3RoO3tjb25zdCBnPUEudG91Y2hlcy5sZW5ndGg7SS53cml0ZVVpbnQzMihnKTtmb3IobGV0IEI9MDtCPGc7QisrKVguZW5jb2RlSW50byhBLnRvdWNoZXNbQl0sSSl9cmV0dXJuIEkubGVuZ3RoLWd9LGRlY29kZShJKXtjb25zdCBnPUEuZ2V0SW5zdGFuY2UoKTtyZXR1cm4gZy5zdGFydFJlYWRpbmcoSSksdGhpcy5yZWFkRnJvbShnKX0scmVhZEZyb20oQSl7bGV0IEk7e2xldCBnPUEucmVhZFVpbnQzMigpO0k9bmV3IEFycmF5KGcpO2ZvcihsZXQgQj0wO0I8ZztCKyspe2xldCBnO2c9WC5yZWFkRnJvbShBKSxJW0JdPWd9fXJldHVybnt0b3VjaGVzOkl9fX0sQkE9e2Rpc2NyaW1pbmF0b3I6MTAsZW5jb2RlKEkpe2NvbnN0IGc9QS5nZXRJbnN0YW5jZSgpO3JldHVybiBnLnN0YXJ0V3JpdGluZygpLHRoaXMuZW5jb2RlSW50byhJLGcpLGcudG9BcnJheSgpfSxlbmNvZGVJbnRvKEEsSSl7Y29uc3QgZz1JLmxlbmd0aDt4LmVuY29kZUludG8oQS5wb2ludGVySW5mbyxJKSxJLndyaXRlVWludDMyKEEucGVuRmxhZ3MpLEkud3JpdGVVaW50MzIoQS5wZW5NYXNrKSxJLndyaXRlVWludDMyKEEucHJlc3N1cmUpLEkud3JpdGVVaW50MzIoQS5yb3RhdGlvbiksSS53cml0ZUludDMyKEEudGlsdFgpLEkud3JpdGVJbnQzMihBLnRpbHRZKTtyZXR1cm4gSS5sZW5ndGgtZ30sZGVjb2RlKEkpe2NvbnN0IGc9QS5nZXRJbnN0YW5jZSgpO3JldHVybiBnLnN0YXJ0UmVhZGluZyhJKSx0aGlzLnJlYWRGcm9tKGcpfSxyZWFkRnJvbShBKXtsZXQgSSxnLEIsUSxDLGUsaTtyZXR1cm4gST14LnJlYWRGcm9tKEEpLGc9QS5yZWFkVWludDMyKCksQj1BLnJlYWRVaW50MzIoKSxRPUEucmVhZFVpbnQzMigpLEM9QS5yZWFkVWludDMyKCksZT1BLnJlYWRJbnQzMigpLGk9QS5yZWFkSW50MzIoKSx7cG9pbnRlckluZm86SSxwZW5GbGFnczpnLHBlbk1hc2s6QixwcmVzc3VyZTpRLHJvdGF0aW9uOkMsdGlsdFg6ZSx0aWx0WTppfX19LFFBPXtkaXNjcmltaW5hdG9yOjExLGVuY29kZShJKXtjb25zdCBnPUEuZ2V0SW5zdGFuY2UoKTtyZXR1cm4gZy5zdGFydFdyaXRpbmcoKSx0aGlzLmVuY29kZUludG8oSSxnKSxnLnRvQXJyYXkoKX0sZW5jb2RlSW50byhBLEkpe2NvbnN0IGc9SS5sZW5ndGg7SS53cml0ZVVpbnQzMihBLndpZHRoKSxJLndyaXRlVWludDMyKEEuaGVpZ2h0KTtyZXR1cm4gSS5sZW5ndGgtZ30sZGVjb2RlKEkpe2NvbnN0IGc9QS5nZXRJbnN0YW5jZSgpO3JldHVybiBnLnN0YXJ0UmVhZGluZyhJKSx0aGlzLnJlYWRGcm9tKGcpfSxyZWFkRnJvbShBKXtsZXQgSSxnO3JldHVybiBJPUEucmVhZFVpbnQzMigpLGc9QS5yZWFkVWludDMyKCkse3dpZHRoOkksaGVpZ2h0Omd9fX0sQ0E9e2Rpc2NyaW1pbmF0b3I6MTIsZW5jb2RlKEkpe2NvbnN0IGc9QS5nZXRJbnN0YW5jZSgpO3JldHVybiBnLnN0YXJ0V3JpdGluZygpLHRoaXMuZW5jb2RlSW50byhJLGcpLGcudG9BcnJheSgpfSxlbmNvZGVJbnRvKEEsSSl7Y29uc3QgZz1JLmxlbmd0aDtJLndyaXRlU3RyaW5nKEEudGV4dCk7cmV0dXJuIEkubGVuZ3RoLWd9LGRlY29kZShJKXtjb25zdCBnPUEuZ2V0SW5zdGFuY2UoKTtyZXR1cm4gZy5zdGFydFJlYWRpbmcoSSksdGhpcy5yZWFkRnJvbShnKX0scmVhZEZyb20oQSl7bGV0IEk7cmV0dXJuIEk9QS5yZWFkU3RyaW5nKCkse3RleHQ6SX19fSxlQT17ZW5jb2RlKEkpe2NvbnN0IGc9QS5nZXRJbnN0YW5jZSgpO3JldHVybiBnLnN0YXJ0V3JpdGluZygpLHRoaXMuZW5jb2RlSW50byhJLGcpLGcudG9BcnJheSgpfSxlbmNvZGVJbnRvKEEsSSl7Y29uc3QgZz1JLmxlbmd0aCxCPUkucmVzZXJ2ZU1lc3NhZ2VMZW5ndGgoKSxRPUkubGVuZ3RoKzE7c3dpdGNoKEkud3JpdGVCeXRlKEEuZGlzY3JpbWluYXRvciksQS5kaXNjcmltaW5hdG9yKXtjYXNlIDE6Vi5lbmNvZGVJbnRvKEEudmFsdWUsSSk7YnJlYWs7Y2FzZSAyOmouZW5jb2RlSW50byhBLnZhbHVlLEkpO2JyZWFrO2Nhc2UgMzpaLmVuY29kZUludG8oQS52YWx1ZSxJKTticmVhaztjYXNlIDQ6ei5lbmNvZGVJbnRvKEEudmFsdWUsSSk7YnJlYWs7Y2FzZSA1Ol8uZW5jb2RlSW50byhBLnZhbHVlLEkpO2JyZWFrO2Nhc2UgNjokLmVuY29kZUludG8oQS52YWx1ZSxJKTticmVhaztjYXNlIDc6QUEuZW5jb2RlSW50byhBLnZhbHVlLEkpO2JyZWFrO2Nhc2UgODpJQS5lbmNvZGVJbnRvKEEudmFsdWUsSSk7YnJlYWs7Y2FzZSA5OmdBLmVuY29kZUludG8oQS52YWx1ZSxJKTticmVhaztjYXNlIDEwOkJBLmVuY29kZUludG8oQS52YWx1ZSxJKTticmVhaztjYXNlIDExOlFBLmVuY29kZUludG8oQS52YWx1ZSxJKTticmVhaztjYXNlIDEyOkNBLmVuY29kZUludG8oQS52YWx1ZSxJKX1jb25zdCBDPUkubGVuZ3RoO0kuZmlsbE1lc3NhZ2VMZW5ndGgoQixDLVEpO3JldHVybiBJLmxlbmd0aC1nfSxkZWNvZGUoSSl7Y29uc3QgZz1BLmdldEluc3RhbmNlKCk7cmV0dXJuIGcuc3RhcnRSZWFkaW5nKEkpLHRoaXMucmVhZEZyb20oZyl9LHJlYWRGcm9tKEEpe2NvbnN0IGc9QS5yZWFkTWVzc2FnZUxlbmd0aCgpLEI9QS5pbmRleCsxK2c7c3dpdGNoKEEucmVhZEJ5dGUoKSl7Y2FzZSAxOnJldHVybntkaXNjcmltaW5hdG9yOjEsdmFsdWU6Vi5yZWFkRnJvbShBKX07Y2FzZSAyOnJldHVybntkaXNjcmltaW5hdG9yOjIsdmFsdWU6ai5yZWFkRnJvbShBKX07Y2FzZSAzOnJldHVybntkaXNjcmltaW5hdG9yOjMsdmFsdWU6Wi5yZWFkRnJvbShBKX07Y2FzZSA0OnJldHVybntkaXNjcmltaW5hdG9yOjQsdmFsdWU6ei5yZWFkRnJvbShBKX07Y2FzZSA1OnJldHVybntkaXNjcmltaW5hdG9yOjUsdmFsdWU6Xy5yZWFkRnJvbShBKX07Y2FzZSA2OnJldHVybntkaXNjcmltaW5hdG9yOjYsdmFsdWU6JC5yZWFkRnJvbShBKX07Y2FzZSA3OnJldHVybntkaXNjcmltaW5hdG9yOjcsdmFsdWU6QUEucmVhZEZyb20oQSl9O2Nhc2UgODpyZXR1cm57ZGlzY3JpbWluYXRvcjo4LHZhbHVlOklBLnJlYWRGcm9tKEEpfTtjYXNlIDk6cmV0dXJue2Rpc2NyaW1pbmF0b3I6OSx2YWx1ZTpnQS5yZWFkRnJvbShBKX07Y2FzZSAxMDpyZXR1cm57ZGlzY3JpbWluYXRvcjoxMCx2YWx1ZTpCQS5yZWFkRnJvbShBKX07Y2FzZSAxMTpyZXR1cm57ZGlzY3JpbWluYXRvcjoxMSx2YWx1ZTpRQS5yZWFkRnJvbShBKX07Y2FzZSAxMjpyZXR1cm57ZGlzY3JpbWluYXRvcjoxMix2YWx1ZTpDQS5yZWFkRnJvbShBKX07ZGVmYXVsdDp0aHJvdyBBLmluZGV4PUIsbmV3IEkoXCJVbnJlY29nbml6ZWQgZGlzY3JpbWluYXRvciB3aGlsZSBkZWNvZGluZyBJbnB1dEJvZHlJbm5lclwiKX19fSxpQT17ZW5jb2RlKEkpe2NvbnN0IGc9QS5nZXRJbnN0YW5jZSgpO3JldHVybiBnLnN0YXJ0V3JpdGluZygpLHRoaXMuZW5jb2RlSW50byhJLGcpLGcudG9BcnJheSgpfSxlbmNvZGVJbnRvKEEsSSl7Y29uc3QgZz1JLmxlbmd0aDtJLndyaXRlQnl0ZShBLnN0cmVhbUlkKSxlQS5lbmNvZGVJbnRvKEEuaW5uZXIsSSk7cmV0dXJuIEkubGVuZ3RoLWd9LGRlY29kZShJKXtjb25zdCBnPUEuZ2V0SW5zdGFuY2UoKTtyZXR1cm4gZy5zdGFydFJlYWRpbmcoSSksdGhpcy5yZWFkRnJvbShnKX0scmVhZEZyb20oQSl7bGV0IEksZztyZXR1cm4gST1BLnJlYWRCeXRlKCksZz1lQS5yZWFkRnJvbShBKSx7c3RyZWFtSWQ6SSxpbm5lcjpnfX19O3ZhciB0QSxFQTshZnVuY3Rpb24oQSl7QVtBLkJhc2VsaW5lPTFdPVwiQmFzZWxpbmVcIixBW0EuTWFpbj0yXT1cIk1haW5cIixBW0EuSGlnaD00XT1cIkhpZ2hcIixBW0EuSDI2ND03XT1cIkgyNjRcIixBW0EuSDI2NT04XT1cIkgyNjVcIn0odEF8fCh0QT17fSkpLGZ1bmN0aW9uKEEpe0FbQS5Vbmtub3duPTBdPVwiVW5rbm93blwiLEFbQS5BbWQ9NDA5OF09XCJBbWRcIixBW0EuTnZpZGlhPTQzMThdPVwiTnZpZGlhXCIsQVtBLkludGVsPTMyOTAyXT1cIkludGVsXCJ9KEVBfHwoRUE9e30pKTtjb25zdCBvQT17ZW5jb2RlKEkpe2NvbnN0IGc9QS5nZXRJbnN0YW5jZSgpO3JldHVybiBnLnN0YXJ0V3JpdGluZygpLHRoaXMuZW5jb2RlSW50byhJLGcpLGcudG9BcnJheSgpfSxlbmNvZGVJbnRvKEEsSSl7Y29uc3QgZz1JLmxlbmd0aDtJLndyaXRlU3RyaW5nKEEuZnJpZW5kbHlOYW1lKSxJLndyaXRlVWludDMyKEEud2lkdGgpLEkud3JpdGVVaW50MzIoQS5oZWlnaHQpLEkud3JpdGVVaW50MzIoQS5yZWZyZXNoUmF0ZSksSS53cml0ZUJ5dGVzKEEuZGF0YSksSS53cml0ZVVpbnQzMihBLnR5cGUpO3JldHVybiBJLmxlbmd0aC1nfSxkZWNvZGUoSSl7Y29uc3QgZz1BLmdldEluc3RhbmNlKCk7cmV0dXJuIGcuc3RhcnRSZWFkaW5nKEkpLHRoaXMucmVhZEZyb20oZyl9LHJlYWRGcm9tKEEpe2xldCBJLGcsQixRLEMsZTtyZXR1cm4gST1BLnJlYWRTdHJpbmcoKSxnPUEucmVhZFVpbnQzMigpLEI9QS5yZWFkVWludDMyKCksUT1BLnJlYWRVaW50MzIoKSxDPUEucmVhZEJ5dGVzKCksZT1BLnJlYWRVaW50MzIoKSx7ZnJpZW5kbHlOYW1lOkksd2lkdGg6ZyxoZWlnaHQ6QixyZWZyZXNoUmF0ZTpRLGRhdGE6Qyx0eXBlOmV9fX07dmFyIGFBLHNBLG5BLHJBLGhBLGRBLGNBLERBOyFmdW5jdGlvbihBKXtBW0EuVW5rbm93bj0wXT1cIlVua25vd25cIixBW0EuUGhvbmU9MV09XCJQaG9uZVwiLEFbQS5UYWJsZXQ9Ml09XCJUYWJsZXRcIixBW0EuQ29tcHV0ZXI9M109XCJDb21wdXRlclwiLEFbQS5Db25zb2xlPTRdPVwiQ29uc29sZVwiLEFbQS5Udj01XT1cIlR2XCJ9KGFBfHwoYUE9e30pKSxmdW5jdGlvbihBKXtBW0EuT3RoZXI9MF09XCJPdGhlclwiLEFbQS5JT1M9MV09XCJJT1NcIixBW0EuVHZPUz0yXT1cIlR2T1NcIixBW0EuQW5kcm9pZD0zXT1cIkFuZHJvaWRcIixBW0EuV2luZG93cz00XT1cIldpbmRvd3NcIixBW0EuTWFjT1M9NV09XCJNYWNPU1wiLEFbQS5MaW51eD02XT1cIkxpbnV4XCIsQVtBLlJva3U9N109XCJSb2t1XCJ9KHNBfHwoc0E9e30pKSxmdW5jdGlvbihBKXtBW0EuV2ViUlRDPTBdPVwiV2ViUlRDXCIsQVtBLkdleXNlcj0xXT1cIkdleXNlclwifShuQXx8KG5BPXt9KSksZnVuY3Rpb24oQSl7QVtBLk1vbm89MF09XCJNb25vXCIsQVtBLlN0ZXJlbz0xXT1cIlN0ZXJlb1wiLEFbQS5TdXJyb3VuZDUxPTJdPVwiU3Vycm91bmQ1MVwiLEFbQS5TdXJyb3VuZDcxPTNdPVwiU3Vycm91bmQ3MVwifShyQXx8KHJBPXt9KSksZnVuY3Rpb24oQSl7QVtBLk9wdXM9MF09XCJPcHVzXCIsQVtBLkFhYz0xXT1cIkFhY1wifShoQXx8KGhBPXt9KSksZnVuY3Rpb24oQSl7QVtBLlJhdz0wXT1cIlJhd1wiLEFbQS5XZWJNPTFdPVwiV2ViTVwiLEFbQS5Jc29CTUZGPTJdPVwiSXNvQk1GRlwifShkQXx8KGRBPXt9KSksZnVuY3Rpb24oQSl7QVtBLlJhdz0wXT1cIlJhd1wiLEFbQS5Jc29CTUZGPTFdPVwiSXNvQk1GRlwifShjQXx8KGNBPXt9KSksZnVuY3Rpb24oQSl7QVtBLlVua25vd25FcnJvcj0wXT1cIlVua25vd25FcnJvclwiLEFbQS5EaXNwbGF5c01pc3Npbmc9MV09XCJEaXNwbGF5c01pc3NpbmdcIixBW0EuTm9BdmFpbGFibGVFbmNvZGVyPTJdPVwiTm9BdmFpbGFibGVFbmNvZGVyXCIsQVtBLkludmFsaWRFbmNvZGluZ0NvbmZpZz0zXT1cIkludmFsaWRFbmNvZGluZ0NvbmZpZ1wiLEFbQS5Ob0NvZGVjc0V4Y2hhbmdlZD00XT1cIk5vQ29kZWNzRXhjaGFuZ2VkXCIsQVtBLk5vQ2FwYWJpbGl0aWVzPTVdPVwiTm9DYXBhYmlsaXRpZXNcIixBW0EuTm9TdWNoU3RyZWFtPTZdPVwiTm9TdWNoU3RyZWFtXCIsQVtBLkZvcmNlU2VnbWVudEZhaWxlZD03XT1cIkZvcmNlU2VnbWVudEZhaWxlZFwiLEFbQS5Ob3RDYXBhYmxlT2ZBcHBJc29sYXRpb249OF09XCJOb3RDYXBhYmxlT2ZBcHBJc29sYXRpb25cIixBW0EuQWxyZWFkeVN0cmVhbWluZz05XT1cIkFscmVhZHlTdHJlYW1pbmdcIn0oREF8fChEQT17fSkpO2NvbnN0IHdBPXtlbmNvZGUoSSl7Y29uc3QgZz1BLmdldEluc3RhbmNlKCk7cmV0dXJuIGcuc3RhcnRXcml0aW5nKCksdGhpcy5lbmNvZGVJbnRvKEksZyksZy50b0FycmF5KCl9LGVuY29kZUludG8oQSxJKXtjb25zdCBnPUkubGVuZ3RoO0kud3JpdGVVaW50MzIoQS5jb2RlYyksSS53cml0ZVVpbnQzMihBLmNvbnRhaW5lcik7cmV0dXJuIEkubGVuZ3RoLWd9LGRlY29kZShJKXtjb25zdCBnPUEuZ2V0SW5zdGFuY2UoKTtyZXR1cm4gZy5zdGFydFJlYWRpbmcoSSksdGhpcy5yZWFkRnJvbShnKX0scmVhZEZyb20oQSl7bGV0IEksZztyZXR1cm4gST1BLnJlYWRVaW50MzIoKSxnPUEucmVhZFVpbnQzMigpLHtjb2RlYzpJLGNvbnRhaW5lcjpnfX19O3ZhciBGQTshZnVuY3Rpb24oQSl7QVtBLlVua25vd249MF09XCJVbmtub3duXCIsQVtBLkZ1bGxEZXNrdG9wPTFdPVwiRnVsbERlc2t0b3BcIixBW0EuQXBwSXNvbGF0aW9uPTJdPVwiQXBwSXNvbGF0aW9uXCIsQVtBLkJ5b2ZiPTNdPVwiQnlvZmJcIn0oRkF8fChGQT17fSkpO2NvbnN0IFNBPXtlbmNvZGUoSSl7Y29uc3QgZz1BLmdldEluc3RhbmNlKCk7cmV0dXJuIGcuc3RhcnRXcml0aW5nKCksdGhpcy5lbmNvZGVJbnRvKEksZyksZy50b0FycmF5KCl9LGVuY29kZUludG8oQSxJKXtjb25zdCBnPUkubGVuZ3RoO29BLmVuY29kZUludG8oQS5jb2RlYyxJKSxJLndyaXRlVWludDMyKEEuY29udGFpbmVyKTtyZXR1cm4gSS5sZW5ndGgtZ30sZGVjb2RlKEkpe2NvbnN0IGc9QS5nZXRJbnN0YW5jZSgpO3JldHVybiBnLnN0YXJ0UmVhZGluZyhJKSx0aGlzLnJlYWRGcm9tKGcpfSxyZWFkRnJvbShBKXtsZXQgSSxnO3JldHVybiBJPW9BLnJlYWRGcm9tKEEpLGc9QS5yZWFkVWludDMyKCkse2NvZGVjOkksY29udGFpbmVyOmd9fX07dmFyIHlBOyFmdW5jdGlvbihBKXtBW0EuTm9uZT0wXT1cIk5vbmVcIixBW0EuR2FtZXBhZFBvcnQxPTFdPVwiR2FtZXBhZFBvcnQxXCIsQVtBLkdhbWVwYWRQb3J0Mj0yXT1cIkdhbWVwYWRQb3J0MlwiLEFbQS5HYW1lcGFkUG9ydDM9NF09XCJHYW1lcGFkUG9ydDNcIixBW0EuR2FtZXBhZFBvcnQ0PThdPVwiR2FtZXBhZFBvcnQ0XCIsQVtBLkdhbWVwYWQ9MTVdPVwiR2FtZXBhZFwiLEFbQS5Nb3VzZT0xNl09XCJNb3VzZVwiLEFbQS5LZXlib2FyZD0zMl09XCJLZXlib2FyZFwiLEFbQS5DbGlwYm9hcmQ9NjRdPVwiQ2xpcGJvYXJkXCIsQVtBLkFsbD02M109XCJBbGxcIn0oeUF8fCh5QT17fSkpO2NvbnN0IEdBPXtlbmNvZGUoSSl7Y29uc3QgZz1BLmdldEluc3RhbmNlKCk7cmV0dXJuIGcuc3RhcnRXcml0aW5nKCksdGhpcy5lbmNvZGVJbnRvKEksZyksZy50b0FycmF5KCl9LGVuY29kZUludG8oQSxJKXtjb25zdCBnPUkubGVuZ3RoO0kud3JpdGVCeXRlKEEuc3RyZWFtSWQpLEkud3JpdGVVaW50MzIoQS5zdHJlYW1UeXBlKSxJLndyaXRlVWludDMyKEEuZGVmYXVsdElucHV0TGV2ZWwpLEkud3JpdGVGbG9hdDMyKEEudGVtcG9yYWxTY2FsZUZhY3Rvciksd0EuZW5jb2RlSW50byhBLmNob3NlbkF1ZGlvQ29uZmlnLEkpLFNBLmVuY29kZUludG8oQS5jaG9zZW5WaWRlb0NvbmZpZyxJKTtyZXR1cm4gSS5sZW5ndGgtZ30sZGVjb2RlKEkpe2NvbnN0IGc9QS5nZXRJbnN0YW5jZSgpO3JldHVybiBnLnN0YXJ0UmVhZGluZyhJKSx0aGlzLnJlYWRGcm9tKGcpfSxyZWFkRnJvbShBKXtsZXQgSSxnLEIsUSxDLGU7cmV0dXJuIEk9QS5yZWFkQnl0ZSgpLGc9QS5yZWFkVWludDMyKCksQj1BLnJlYWRVaW50MzIoKSxRPUEucmVhZEZsb2F0MzIoKSxDPXdBLnJlYWRGcm9tKEEpLGU9U0EucmVhZEZyb20oQSkse3N0cmVhbUlkOkksc3RyZWFtVHlwZTpnLGRlZmF1bHRJbnB1dExldmVsOkIsdGVtcG9yYWxTY2FsZUZhY3RvcjpRLGNob3NlbkF1ZGlvQ29uZmlnOkMsY2hvc2VuVmlkZW9Db25maWc6ZX19fSxSQT17ZGlzY3JpbWluYXRvcjoxLGVuY29kZShJKXtjb25zdCBnPUEuZ2V0SW5zdGFuY2UoKTtyZXR1cm4gZy5zdGFydFdyaXRpbmcoKSx0aGlzLmVuY29kZUludG8oSSxnKSxnLnRvQXJyYXkoKX0sZW5jb2RlSW50byhBLEkpe2NvbnN0IGc9SS5sZW5ndGg7SS53cml0ZVVpbnQzMihBLmZvcm1GYWN0b3IpLEkud3JpdGVTdHJpbmcoQS5kZXZpY2VOYW1lKSxJLndyaXRlVWludDMyKEEuZGV2aWNlT3MpLEkud3JpdGVTdHJpbmcoQS5kZXZpY2VPc1ZlcnNpb24pLEkud3JpdGVTdHJpbmcoQS5kZXZpY2VNb2RlbCksSS53cml0ZVN0cmluZyhBLnVzZXJBZ2VudCksSS53cml0ZVN0cmluZyhBLmRldmljZUlkKSxJLndyaXRlQnl0ZShOdW1iZXIoQS5pc1dlYikpO3JldHVybiBJLmxlbmd0aC1nfSxkZWNvZGUoSSl7Y29uc3QgZz1BLmdldEluc3RhbmNlKCk7cmV0dXJuIGcuc3RhcnRSZWFkaW5nKEkpLHRoaXMucmVhZEZyb20oZyl9LHJlYWRGcm9tKEEpe2xldCBJLGcsQixRLEMsZSxpLHQ7cmV0dXJuIEk9QS5yZWFkVWludDMyKCksZz1BLnJlYWRTdHJpbmcoKSxCPUEucmVhZFVpbnQzMigpLFE9QS5yZWFkU3RyaW5nKCksQz1BLnJlYWRTdHJpbmcoKSxlPUEucmVhZFN0cmluZygpLGk9QS5yZWFkU3RyaW5nKCksdD0hIUEucmVhZEJ5dGUoKSx7Zm9ybUZhY3RvcjpJLGRldmljZU5hbWU6ZyxkZXZpY2VPczpCLGRldmljZU9zVmVyc2lvbjpRLGRldmljZU1vZGVsOkMsdXNlckFnZW50OmUsZGV2aWNlSWQ6aSxpc1dlYjp0fX19LHVBPXtkaXNjcmltaW5hdG9yOjIsZW5jb2RlKEkpe2NvbnN0IGc9QS5nZXRJbnN0YW5jZSgpO3JldHVybiBnLnN0YXJ0V3JpdGluZygpLHRoaXMuZW5jb2RlSW50byhJLGcpLGcudG9BcnJheSgpfSxlbmNvZGVJbnRvKEEsSSl7Y29uc3QgZz1JLmxlbmd0aDtyZXR1cm4gSS5sZW5ndGgtZ30sZGVjb2RlKEkpe2NvbnN0IGc9QS5nZXRJbnN0YW5jZSgpO3JldHVybiBnLnN0YXJ0UmVhZGluZyhJKSx0aGlzLnJlYWRGcm9tKGcpfSxyZWFkRnJvbTpBPT4oe30pfSxsQT17ZGlzY3JpbWluYXRvcjozLGVuY29kZShJKXtjb25zdCBnPUEuZ2V0SW5zdGFuY2UoKTtyZXR1cm4gZy5zdGFydFdyaXRpbmcoKSx0aGlzLmVuY29kZUludG8oSSxnKSxnLnRvQXJyYXkoKX0sZW5jb2RlSW50byhBLEkpe2NvbnN0IGc9SS5sZW5ndGg7e2NvbnN0IGc9QS52aWRlb0NvZGVjcy5sZW5ndGg7SS53cml0ZVVpbnQzMihnKTtmb3IobGV0IEI9MDtCPGc7QisrKW9BLmVuY29kZUludG8oQS52aWRlb0NvZGVjc1tCXSxJKX1yZXR1cm4gSS5sZW5ndGgtZ30sZGVjb2RlKEkpe2NvbnN0IGc9QS5nZXRJbnN0YW5jZSgpO3JldHVybiBnLnN0YXJ0UmVhZGluZyhJKSx0aGlzLnJlYWRGcm9tKGcpfSxyZWFkRnJvbShBKXtsZXQgSTt7bGV0IGc9QS5yZWFkVWludDMyKCk7ST1uZXcgQXJyYXkoZyk7Zm9yKGxldCBCPTA7QjxnO0IrKyl7bGV0IGc7Zz1vQS5yZWFkRnJvbShBKSxJW0JdPWd9fXJldHVybnt2aWRlb0NvZGVjczpJfX19LGtBPXtkaXNjcmltaW5hdG9yOjQsZW5jb2RlKEkpe2NvbnN0IGc9QS5nZXRJbnN0YW5jZSgpO3JldHVybiBnLnN0YXJ0V3JpdGluZygpLHRoaXMuZW5jb2RlSW50byhJLGcpLGcudG9BcnJheSgpfSxlbmNvZGVJbnRvKEEsSSl7Y29uc3QgZz1JLmxlbmd0aDtJLndyaXRlVWludDMyKEEucHJlZmVycmVkV2lkdGgpLEkud3JpdGVVaW50MzIoQS5wcmVmZXJyZWRIZWlnaHQpLEkud3JpdGVVaW50MzIoQS5wcmVmZXJyZWRGcHMpLEkud3JpdGVVaW50MzIoQS5wcmVmZXJyZWRBdWRpb0JpdHJhdGUpLEkud3JpdGVVaW50MzIoQS5wcmVmZXJyZWRWaWRlb0JpdHJhdGUpLEkud3JpdGVVaW50MzIoQS5wcmVmZXJyZWRBdWRpb0NoYW5uZWxzKSx3QS5lbmNvZGVJbnRvKEEucHJlZmVycmVkQXVkaW9Db25maWcsSSksU0EuZW5jb2RlSW50byhBLnByZWZlcnJlZFZpZGVvQ29uZmlnLEkpO3tjb25zdCBnPUEuc3VwcG9ydGVkQXVkaW9DaGFubmVscy5sZW5ndGg7SS53cml0ZVVpbnQzMihnKTtmb3IobGV0IEI9MDtCPGc7QisrKUkud3JpdGVVaW50MzIoQS5zdXBwb3J0ZWRBdWRpb0NoYW5uZWxzW0JdKX17Y29uc3QgZz1BLnN1cHBvcnRlZEF1ZGlvQ29uZmlncy5sZW5ndGg7SS53cml0ZVVpbnQzMihnKTtmb3IobGV0IEI9MDtCPGc7QisrKXdBLmVuY29kZUludG8oQS5zdXBwb3J0ZWRBdWRpb0NvbmZpZ3NbQl0sSSl9e2NvbnN0IGc9QS5zdXBwb3J0ZWRWaWRlb0NvbmZpZ3MubGVuZ3RoO0kud3JpdGVVaW50MzIoZyk7Zm9yKGxldCBCPTA7QjxnO0IrKylTQS5lbmNvZGVJbnRvKEEuc3VwcG9ydGVkVmlkZW9Db25maWdzW0JdLEkpfUkud3JpdGVCeXRlKE51bWJlcihBLnN1cHBvcnRzT3ZlcjEwODBQKSksSS53cml0ZUJ5dGUoTnVtYmVyKEEuc3VwcG9ydHNUZW1wb3JhbFNjYWxpbmcpKSxJLndyaXRlQnl0ZShOdW1iZXIoQS5zdXBwb3J0c0FwcElzb2xhdGlvbikpO3JldHVybiBJLmxlbmd0aC1nfSxkZWNvZGUoSSl7Y29uc3QgZz1BLmdldEluc3RhbmNlKCk7cmV0dXJuIGcuc3RhcnRSZWFkaW5nKEkpLHRoaXMucmVhZEZyb20oZyl9LHJlYWRGcm9tKEEpe2xldCBJLGcsQixRLEMsZSxpLHQsRSxvLGEscyxuLHI7ST1BLnJlYWRVaW50MzIoKSxnPUEucmVhZFVpbnQzMigpLEI9QS5yZWFkVWludDMyKCksUT1BLnJlYWRVaW50MzIoKSxDPUEucmVhZFVpbnQzMigpLGU9QS5yZWFkVWludDMyKCksaT13QS5yZWFkRnJvbShBKSx0PVNBLnJlYWRGcm9tKEEpO3tsZXQgST1BLnJlYWRVaW50MzIoKTtFPW5ldyBBcnJheShJKTtmb3IobGV0IGc9MDtnPEk7ZysrKXtsZXQgSTtJPUEucmVhZFVpbnQzMigpLEVbZ109SX19e2xldCBJPUEucmVhZFVpbnQzMigpO289bmV3IEFycmF5KEkpO2ZvcihsZXQgZz0wO2c8STtnKyspe2xldCBJO0k9d0EucmVhZEZyb20oQSksb1tnXT1JfX17bGV0IEk9QS5yZWFkVWludDMyKCk7YT1uZXcgQXJyYXkoSSk7Zm9yKGxldCBnPTA7ZzxJO2crKyl7bGV0IEk7ST1TQS5yZWFkRnJvbShBKSxhW2ddPUl9fXJldHVybiBzPSEhQS5yZWFkQnl0ZSgpLG49ISFBLnJlYWRCeXRlKCkscj0hIUEucmVhZEJ5dGUoKSx7cHJlZmVycmVkV2lkdGg6SSxwcmVmZXJyZWRIZWlnaHQ6ZyxwcmVmZXJyZWRGcHM6QixwcmVmZXJyZWRBdWRpb0JpdHJhdGU6USxwcmVmZXJyZWRWaWRlb0JpdHJhdGU6QyxwcmVmZXJyZWRBdWRpb0NoYW5uZWxzOmUscHJlZmVycmVkQXVkaW9Db25maWc6aSxwcmVmZXJyZWRWaWRlb0NvbmZpZzp0LHN1cHBvcnRlZEF1ZGlvQ2hhbm5lbHM6RSxzdXBwb3J0ZWRBdWRpb0NvbmZpZ3M6byxzdXBwb3J0ZWRWaWRlb0NvbmZpZ3M6YSxzdXBwb3J0c092ZXIxMDgwUDpzLHN1cHBvcnRzVGVtcG9yYWxTY2FsaW5nOm4sc3VwcG9ydHNBcHBJc29sYXRpb246cn19fSxVQT17ZGlzY3JpbWluYXRvcjo1LGVuY29kZShJKXtjb25zdCBnPUEuZ2V0SW5zdGFuY2UoKTtyZXR1cm4gZy5zdGFydFdyaXRpbmcoKSx0aGlzLmVuY29kZUludG8oSSxnKSxnLnRvQXJyYXkoKX0sZW5jb2RlSW50byhBLEkpe2NvbnN0IGc9SS5sZW5ndGg7SS53cml0ZVVpbnQzMihBLmVycm9yKTtyZXR1cm4gSS5sZW5ndGgtZ30sZGVjb2RlKEkpe2NvbnN0IGc9QS5nZXRJbnN0YW5jZSgpO3JldHVybiBnLnN0YXJ0UmVhZGluZyhJKSx0aGlzLnJlYWRGcm9tKGcpfSxyZWFkRnJvbShBKXtsZXQgSTtyZXR1cm4gST1BLnJlYWRVaW50MzIoKSx7ZXJyb3I6SX19fSxOQT17ZGlzY3JpbWluYXRvcjo2LGVuY29kZShJKXtjb25zdCBnPUEuZ2V0SW5zdGFuY2UoKTtyZXR1cm4gZy5zdGFydFdyaXRpbmcoKSx0aGlzLmVuY29kZUludG8oSSxnKSxnLnRvQXJyYXkoKX0sZW5jb2RlSW50byhBLEkpe2NvbnN0IGc9SS5sZW5ndGg7SS53cml0ZVVpbnQzMihBLmlucHV0TGV2ZWwpO3JldHVybiBJLmxlbmd0aC1nfSxkZWNvZGUoSSl7Y29uc3QgZz1BLmdldEluc3RhbmNlKCk7cmV0dXJuIGcuc3RhcnRSZWFkaW5nKEkpLHRoaXMucmVhZEZyb20oZyl9LHJlYWRGcm9tKEEpe2xldCBJO3JldHVybiBJPUEucmVhZFVpbnQzMigpLHtpbnB1dExldmVsOkl9fX0sbUE9e2Rpc2NyaW1pbmF0b3I6OCxlbmNvZGUoSSl7Y29uc3QgZz1BLmdldEluc3RhbmNlKCk7cmV0dXJuIGcuc3RhcnRXcml0aW5nKCksdGhpcy5lbmNvZGVJbnRvKEksZyksZy50b0FycmF5KCl9LGVuY29kZUludG8oQSxJKXtjb25zdCBnPUkubGVuZ3RoO0kud3JpdGVCeXRlKEEuc3RyZWFtSWQpO3JldHVybiBJLmxlbmd0aC1nfSxkZWNvZGUoSSl7Y29uc3QgZz1BLmdldEluc3RhbmNlKCk7cmV0dXJuIGcuc3RhcnRSZWFkaW5nKEkpLHRoaXMucmVhZEZyb20oZyl9LHJlYWRGcm9tKEEpe2xldCBJO3JldHVybiBJPUEucmVhZEJ5dGUoKSx7c3RyZWFtSWQ6SX19fSxNQT17ZGlzY3JpbWluYXRvcjo5LGVuY29kZShJKXtjb25zdCBnPUEuZ2V0SW5zdGFuY2UoKTtyZXR1cm4gZy5zdGFydFdyaXRpbmcoKSx0aGlzLmVuY29kZUludG8oSSxnKSxnLnRvQXJyYXkoKX0sZW5jb2RlSW50byhBLEkpe2NvbnN0IGc9SS5sZW5ndGg7SS53cml0ZUJ5dGUoQS5zdHJlYW1JZCk7cmV0dXJuIEkubGVuZ3RoLWd9LGRlY29kZShJKXtjb25zdCBnPUEuZ2V0SW5zdGFuY2UoKTtyZXR1cm4gZy5zdGFydFJlYWRpbmcoSSksdGhpcy5yZWFkRnJvbShnKX0scmVhZEZyb20oQSl7bGV0IEk7cmV0dXJuIEk9QS5yZWFkQnl0ZSgpLHtzdHJlYW1JZDpJfX19LExBPXtkaXNjcmltaW5hdG9yOjEwLGVuY29kZShJKXtjb25zdCBnPUEuZ2V0SW5zdGFuY2UoKTtyZXR1cm4gZy5zdGFydFdyaXRpbmcoKSx0aGlzLmVuY29kZUludG8oSSxnKSxnLnRvQXJyYXkoKX0sZW5jb2RlSW50byhBLEkpe2NvbnN0IGc9SS5sZW5ndGg7SS53cml0ZUJ5dGUoQS5zdHJlYW1JZCk7cmV0dXJuIEkubGVuZ3RoLWd9LGRlY29kZShJKXtjb25zdCBnPUEuZ2V0SW5zdGFuY2UoKTtyZXR1cm4gZy5zdGFydFJlYWRpbmcoSSksdGhpcy5yZWFkRnJvbShnKX0scmVhZEZyb20oQSl7bGV0IEk7cmV0dXJuIEk9QS5yZWFkQnl0ZSgpLHtzdHJlYW1JZDpJfX19LGZBPXtkaXNjcmltaW5hdG9yOjExLGVuY29kZShJKXtjb25zdCBnPUEuZ2V0SW5zdGFuY2UoKTtyZXR1cm4gZy5zdGFydFdyaXRpbmcoKSx0aGlzLmVuY29kZUludG8oSSxnKSxnLnRvQXJyYXkoKX0sZW5jb2RlSW50byhBLEkpe2NvbnN0IGc9SS5sZW5ndGg7SS53cml0ZUJ5dGUoQS5zdHJlYW1JZCksSS53cml0ZVVpbnQzMihBLmJpdHNQZXJTZWNvbmQpO3JldHVybiBJLmxlbmd0aC1nfSxkZWNvZGUoSSl7Y29uc3QgZz1BLmdldEluc3RhbmNlKCk7cmV0dXJuIGcuc3RhcnRSZWFkaW5nKEkpLHRoaXMucmVhZEZyb20oZyl9LHJlYWRGcm9tKEEpe2xldCBJLGc7cmV0dXJuIEk9QS5yZWFkQnl0ZSgpLGc9QS5yZWFkVWludDMyKCkse3N0cmVhbUlkOkksYml0c1BlclNlY29uZDpnfX19LHBBPXtkaXNjcmltaW5hdG9yOjEyLGVuY29kZShJKXtjb25zdCBnPUEuZ2V0SW5zdGFuY2UoKTtyZXR1cm4gZy5zdGFydFdyaXRpbmcoKSx0aGlzLmVuY29kZUludG8oSSxnKSxnLnRvQXJyYXkoKX0sZW5jb2RlSW50byhBLEkpe2NvbnN0IGc9SS5sZW5ndGg7SS53cml0ZUJ5dGUoQS5zdHJlYW1JZCk7cmV0dXJuIEkubGVuZ3RoLWd9LGRlY29kZShJKXtjb25zdCBnPUEuZ2V0SW5zdGFuY2UoKTtyZXR1cm4gZy5zdGFydFJlYWRpbmcoSSksdGhpcy5yZWFkRnJvbShnKX0scmVhZEZyb20oQSl7bGV0IEk7cmV0dXJuIEk9QS5yZWFkQnl0ZSgpLHtzdHJlYW1JZDpJfX19LEhBPXtkaXNjcmltaW5hdG9yOjEzLGVuY29kZShJKXtjb25zdCBnPUEuZ2V0SW5zdGFuY2UoKTtyZXR1cm4gZy5zdGFydFdyaXRpbmcoKSx0aGlzLmVuY29kZUludG8oSSxnKSxnLnRvQXJyYXkoKX0sZW5jb2RlSW50byhBLEkpe2NvbnN0IGc9SS5sZW5ndGg7SS53cml0ZUJ5dGUoQS5zdHJlYW1JZCk7cmV0dXJuIEkubGVuZ3RoLWd9LGRlY29kZShJKXtjb25zdCBnPUEuZ2V0SW5zdGFuY2UoKTtyZXR1cm4gZy5zdGFydFJlYWRpbmcoSSksdGhpcy5yZWFkRnJvbShnKX0scmVhZEZyb20oQSl7bGV0IEk7cmV0dXJuIEk9QS5yZWFkQnl0ZSgpLHtzdHJlYW1JZDpJfX19LEpBPXtkaXNjcmltaW5hdG9yOjE0LGVuY29kZShJKXtjb25zdCBnPUEuZ2V0SW5zdGFuY2UoKTtyZXR1cm4gZy5zdGFydFdyaXRpbmcoKSx0aGlzLmVuY29kZUludG8oSSxnKSxnLnRvQXJyYXkoKX0sZW5jb2RlSW50byhBLEkpe2NvbnN0IGc9SS5sZW5ndGg7SS53cml0ZVN0cmluZyhBLnJlYXNvbik7cmV0dXJuIEkubGVuZ3RoLWd9LGRlY29kZShJKXtjb25zdCBnPUEuZ2V0SW5zdGFuY2UoKTtyZXR1cm4gZy5zdGFydFJlYWRpbmcoSSksdGhpcy5yZWFkRnJvbShnKX0scmVhZEZyb20oQSl7bGV0IEk7cmV0dXJuIEk9QS5yZWFkU3RyaW5nKCkse3JlYXNvbjpJfX19LEtBPXtkaXNjcmltaW5hdG9yOjE1LGVuY29kZShJKXtjb25zdCBnPUEuZ2V0SW5zdGFuY2UoKTtyZXR1cm4gZy5zdGFydFdyaXRpbmcoKSx0aGlzLmVuY29kZUludG8oSSxnKSxnLnRvQXJyYXkoKX0sZW5jb2RlSW50byhBLEkpe2NvbnN0IGc9SS5sZW5ndGg7SS53cml0ZUJ5dGUoQS5zdHJlYW1JZCksSS53cml0ZVVpbnQzMihBLmlucHV0TGV2ZWwpO3JldHVybiBJLmxlbmd0aC1nfSxkZWNvZGUoSSl7Y29uc3QgZz1BLmdldEluc3RhbmNlKCk7cmV0dXJuIGcuc3RhcnRSZWFkaW5nKEkpLHRoaXMucmVhZEZyb20oZyl9LHJlYWRGcm9tKEEpe2xldCBJLGc7cmV0dXJuIEk9QS5yZWFkQnl0ZSgpLGc9QS5yZWFkVWludDMyKCkse3N0cmVhbUlkOkksaW5wdXRMZXZlbDpnfX19LHFBPXtkaXNjcmltaW5hdG9yOjE2LGVuY29kZShJKXtjb25zdCBnPUEuZ2V0SW5zdGFuY2UoKTtyZXR1cm4gZy5zdGFydFdyaXRpbmcoKSx0aGlzLmVuY29kZUludG8oSSxnKSxnLnRvQXJyYXkoKX0sZW5jb2RlSW50byhBLEkpe2NvbnN0IGc9SS5sZW5ndGg7SS53cml0ZUJ5dGUoQS5zdHJlYW1JZCksSS53cml0ZVVpbnQzMihBLmlucHV0TGV2ZWwpO3JldHVybiBJLmxlbmd0aC1nfSxkZWNvZGUoSSl7Y29uc3QgZz1BLmdldEluc3RhbmNlKCk7cmV0dXJuIGcuc3RhcnRSZWFkaW5nKEkpLHRoaXMucmVhZEZyb20oZyl9LHJlYWRGcm9tKEEpe2xldCBJLGc7cmV0dXJuIEk9QS5yZWFkQnl0ZSgpLGc9QS5yZWFkVWludDMyKCkse3N0cmVhbUlkOkksaW5wdXRMZXZlbDpnfX19LFlBPXtkaXNjcmltaW5hdG9yOjE3LGVuY29kZShJKXtjb25zdCBnPUEuZ2V0SW5zdGFuY2UoKTtyZXR1cm4gZy5zdGFydFdyaXRpbmcoKSx0aGlzLmVuY29kZUludG8oSSxnKSxnLnRvQXJyYXkoKX0sZW5jb2RlSW50byhBLEkpe2NvbnN0IGc9SS5sZW5ndGg7R0EuZW5jb2RlSW50byhBLnN0cmVhbUluZm8sSSk7cmV0dXJuIEkubGVuZ3RoLWd9LGRlY29kZShJKXtjb25zdCBnPUEuZ2V0SW5zdGFuY2UoKTtyZXR1cm4gZy5zdGFydFJlYWRpbmcoSSksdGhpcy5yZWFkRnJvbShnKX0scmVhZEZyb20oQSl7bGV0IEk7cmV0dXJuIEk9R0EucmVhZEZyb20oQSkse3N0cmVhbUluZm86SX19fSx2QT17ZGlzY3JpbWluYXRvcjoxOCxlbmNvZGUoSSl7Y29uc3QgZz1BLmdldEluc3RhbmNlKCk7cmV0dXJuIGcuc3RhcnRXcml0aW5nKCksdGhpcy5lbmNvZGVJbnRvKEksZyksZy50b0FycmF5KCl9LGVuY29kZUludG8oQSxJKXtjb25zdCBnPUkubGVuZ3RoO3JldHVybiBJLmxlbmd0aC1nfSxkZWNvZGUoSSl7Y29uc3QgZz1BLmdldEluc3RhbmNlKCk7cmV0dXJuIGcuc3RhcnRSZWFkaW5nKEkpLHRoaXMucmVhZEZyb20oZyl9LHJlYWRGcm9tOkE9Pih7fSl9LGJBPXtkaXNjcmltaW5hdG9yOjE5LGVuY29kZShJKXtjb25zdCBnPUEuZ2V0SW5zdGFuY2UoKTtyZXR1cm4gZy5zdGFydFdyaXRpbmcoKSx0aGlzLmVuY29kZUludG8oSSxnKSxnLnRvQXJyYXkoKX0sZW5jb2RlSW50byhBLEkpe2NvbnN0IGc9SS5sZW5ndGg7cmV0dXJuIEkubGVuZ3RoLWd9LGRlY29kZShJKXtjb25zdCBnPUEuZ2V0SW5zdGFuY2UoKTtyZXR1cm4gZy5zdGFydFJlYWRpbmcoSSksdGhpcy5yZWFkRnJvbShnKX0scmVhZEZyb206QT0+KHt9KX0sUEE9e2Rpc2NyaW1pbmF0b3I6MjAsZW5jb2RlKEkpe2NvbnN0IGc9QS5nZXRJbnN0YW5jZSgpO3JldHVybiBnLnN0YXJ0V3JpdGluZygpLHRoaXMuZW5jb2RlSW50byhJLGcpLGcudG9BcnJheSgpfSxlbmNvZGVJbnRvKEEsSSl7Y29uc3QgZz1JLmxlbmd0aDtyZXR1cm4gSS5sZW5ndGgtZ30sZGVjb2RlKEkpe2NvbnN0IGc9QS5nZXRJbnN0YW5jZSgpO3JldHVybiBnLnN0YXJ0UmVhZGluZyhJKSx0aGlzLnJlYWRGcm9tKGcpfSxyZWFkRnJvbTpBPT4oe30pfSx4QT17ZW5jb2RlKEkpe2NvbnN0IGc9QS5nZXRJbnN0YW5jZSgpO3JldHVybiBnLnN0YXJ0V3JpdGluZygpLHRoaXMuZW5jb2RlSW50byhJLGcpLGcudG9BcnJheSgpfSxlbmNvZGVJbnRvKEEsSSl7Y29uc3QgZz1JLmxlbmd0aCxCPUkucmVzZXJ2ZU1lc3NhZ2VMZW5ndGgoKSxRPUkubGVuZ3RoKzE7c3dpdGNoKEkud3JpdGVCeXRlKEEuZGlzY3JpbWluYXRvciksQS5kaXNjcmltaW5hdG9yKXtjYXNlIDE6UkEuZW5jb2RlSW50byhBLnZhbHVlLEkpO2JyZWFrO2Nhc2UgMjp1QS5lbmNvZGVJbnRvKEEudmFsdWUsSSk7YnJlYWs7Y2FzZSAzOmxBLmVuY29kZUludG8oQS52YWx1ZSxJKTticmVhaztjYXNlIDQ6a0EuZW5jb2RlSW50byhBLnZhbHVlLEkpO2JyZWFrO2Nhc2UgNTpVQS5lbmNvZGVJbnRvKEEudmFsdWUsSSk7YnJlYWs7Y2FzZSA2Ok5BLmVuY29kZUludG8oQS52YWx1ZSxJKTticmVhaztjYXNlIDg6bUEuZW5jb2RlSW50byhBLnZhbHVlLEkpO2JyZWFrO2Nhc2UgOTpNQS5lbmNvZGVJbnRvKEEudmFsdWUsSSk7YnJlYWs7Y2FzZSAxMDpMQS5lbmNvZGVJbnRvKEEudmFsdWUsSSk7YnJlYWs7Y2FzZSAxMTpmQS5lbmNvZGVJbnRvKEEudmFsdWUsSSk7YnJlYWs7Y2FzZSAxMjpwQS5lbmNvZGVJbnRvKEEudmFsdWUsSSk7YnJlYWs7Y2FzZSAxMzpIQS5lbmNvZGVJbnRvKEEudmFsdWUsSSk7YnJlYWs7Y2FzZSAxNDpKQS5lbmNvZGVJbnRvKEEudmFsdWUsSSk7YnJlYWs7Y2FzZSAxNTpLQS5lbmNvZGVJbnRvKEEudmFsdWUsSSk7YnJlYWs7Y2FzZSAxNjpxQS5lbmNvZGVJbnRvKEEudmFsdWUsSSk7YnJlYWs7Y2FzZSAxNzpZQS5lbmNvZGVJbnRvKEEudmFsdWUsSSk7YnJlYWs7Y2FzZSAxODp2QS5lbmNvZGVJbnRvKEEudmFsdWUsSSk7YnJlYWs7Y2FzZSAxOTpiQS5lbmNvZGVJbnRvKEEudmFsdWUsSSk7YnJlYWs7Y2FzZSAyMDpQQS5lbmNvZGVJbnRvKEEudmFsdWUsSSl9Y29uc3QgQz1JLmxlbmd0aDtJLmZpbGxNZXNzYWdlTGVuZ3RoKEIsQy1RKTtyZXR1cm4gSS5sZW5ndGgtZ30sZGVjb2RlKEkpe2NvbnN0IGc9QS5nZXRJbnN0YW5jZSgpO3JldHVybiBnLnN0YXJ0UmVhZGluZyhJKSx0aGlzLnJlYWRGcm9tKGcpfSxyZWFkRnJvbShBKXtjb25zdCBnPUEucmVhZE1lc3NhZ2VMZW5ndGgoKSxCPUEuaW5kZXgrMStnO3N3aXRjaChBLnJlYWRCeXRlKCkpe2Nhc2UgMTpyZXR1cm57ZGlzY3JpbWluYXRvcjoxLHZhbHVlOlJBLnJlYWRGcm9tKEEpfTtjYXNlIDI6cmV0dXJue2Rpc2NyaW1pbmF0b3I6Mix2YWx1ZTp1QS5yZWFkRnJvbShBKX07Y2FzZSAzOnJldHVybntkaXNjcmltaW5hdG9yOjMsdmFsdWU6bEEucmVhZEZyb20oQSl9O2Nhc2UgNDpyZXR1cm57ZGlzY3JpbWluYXRvcjo0LHZhbHVlOmtBLnJlYWRGcm9tKEEpfTtjYXNlIDU6cmV0dXJue2Rpc2NyaW1pbmF0b3I6NSx2YWx1ZTpVQS5yZWFkRnJvbShBKX07Y2FzZSA2OnJldHVybntkaXNjcmltaW5hdG9yOjYsdmFsdWU6TkEucmVhZEZyb20oQSl9O2Nhc2UgODpyZXR1cm57ZGlzY3JpbWluYXRvcjo4LHZhbHVlOm1BLnJlYWRGcm9tKEEpfTtjYXNlIDk6cmV0dXJue2Rpc2NyaW1pbmF0b3I6OSx2YWx1ZTpNQS5yZWFkRnJvbShBKX07Y2FzZSAxMDpyZXR1cm57ZGlzY3JpbWluYXRvcjoxMCx2YWx1ZTpMQS5yZWFkRnJvbShBKX07Y2FzZSAxMTpyZXR1cm57ZGlzY3JpbWluYXRvcjoxMSx2YWx1ZTpmQS5yZWFkRnJvbShBKX07Y2FzZSAxMjpyZXR1cm57ZGlzY3JpbWluYXRvcjoxMix2YWx1ZTpwQS5yZWFkRnJvbShBKX07Y2FzZSAxMzpyZXR1cm57ZGlzY3JpbWluYXRvcjoxMyx2YWx1ZTpIQS5yZWFkRnJvbShBKX07Y2FzZSAxNDpyZXR1cm57ZGlzY3JpbWluYXRvcjoxNCx2YWx1ZTpKQS5yZWFkRnJvbShBKX07Y2FzZSAxNTpyZXR1cm57ZGlzY3JpbWluYXRvcjoxNSx2YWx1ZTpLQS5yZWFkRnJvbShBKX07Y2FzZSAxNjpyZXR1cm57ZGlzY3JpbWluYXRvcjoxNix2YWx1ZTpxQS5yZWFkRnJvbShBKX07Y2FzZSAxNzpyZXR1cm57ZGlzY3JpbWluYXRvcjoxNyx2YWx1ZTpZQS5yZWFkRnJvbShBKX07Y2FzZSAxODpyZXR1cm57ZGlzY3JpbWluYXRvcjoxOCx2YWx1ZTp2QS5yZWFkRnJvbShBKX07Y2FzZSAxOTpyZXR1cm57ZGlzY3JpbWluYXRvcjoxOSx2YWx1ZTpiQS5yZWFkRnJvbShBKX07Y2FzZSAyMDpyZXR1cm57ZGlzY3JpbWluYXRvcjoyMCx2YWx1ZTpQQS5yZWFkRnJvbShBKX07ZGVmYXVsdDp0aHJvdyBBLmluZGV4PUIsbmV3IEkoXCJVbnJlY29nbml6ZWQgZGlzY3JpbWluYXRvciB3aGlsZSBkZWNvZGluZyBMb2dpY0JvZHlcIil9fX07dmFyIFdBLFRBOyFmdW5jdGlvbihBKXtBW0EuTWV0YWRhdGE9MF09XCJNZXRhZGF0YVwiLEFbQS5DbGVhblBvaW50RnJhbWU9MV09XCJDbGVhblBvaW50RnJhbWVcIixBW0EuRnJhbWVEaWZmPTJdPVwiRnJhbWVEaWZmXCJ9KFdBfHwoV0E9e30pKSxmdW5jdGlvbihBKXtBW0EuTWV0YWRhdGE9MF09XCJNZXRhZGF0YVwiLEFbQS5GcmFtZT0xXT1cIkZyYW1lXCJ9KFRBfHwoVEE9e30pKTtjb25zdCBPQT17ZW5jb2RlKEkpe2NvbnN0IGc9QS5nZXRJbnN0YW5jZSgpO3JldHVybiBnLnN0YXJ0V3JpdGluZygpLHRoaXMuZW5jb2RlSW50byhJLGcpLGcudG9BcnJheSgpfSxlbmNvZGVJbnRvKEEsSSl7Y29uc3QgZz1JLmxlbmd0aDtJLndyaXRlSW50MzIoQS5sZWZ0KSxJLndyaXRlSW50MzIoQS50b3ApLEkud3JpdGVVaW50MzIoQS53aWR0aCksSS53cml0ZVVpbnQzMihBLmhlaWdodCk7cmV0dXJuIEkubGVuZ3RoLWd9LGRlY29kZShJKXtjb25zdCBnPUEuZ2V0SW5zdGFuY2UoKTtyZXR1cm4gZy5zdGFydFJlYWRpbmcoSSksdGhpcy5yZWFkRnJvbShnKX0scmVhZEZyb20oQSl7bGV0IEksZyxCLFE7cmV0dXJuIEk9QS5yZWFkSW50MzIoKSxnPUEucmVhZEludDMyKCksQj1BLnJlYWRVaW50MzIoKSxRPUEucmVhZFVpbnQzMigpLHtsZWZ0OkksdG9wOmcsd2lkdGg6QixoZWlnaHQ6UX19fSxYQT17ZGlzY3JpbWluYXRvcjoxLGVuY29kZShJKXtjb25zdCBnPUEuZ2V0SW5zdGFuY2UoKTtyZXR1cm4gZy5zdGFydFdyaXRpbmcoKSx0aGlzLmVuY29kZUludG8oSSxnKSxnLnRvQXJyYXkoKX0sZW5jb2RlSW50byhBLEkpe2NvbnN0IGc9SS5sZW5ndGg7SS53cml0ZUJ5dGVzKEEuZGF0YSksSS53cml0ZVVpbnQ2NChBLnNlZ21lbnRUaW1lKSxJLndyaXRlVWludDMyKEEudHlwZSksSS53cml0ZUJ5dGUoQS5zdHJlYW1JZCksT0EuZW5jb2RlSW50byhBLmRlc2t0b3BSZWN0LEkpO3tjb25zdCBnPUEubWFzay5sZW5ndGg7SS53cml0ZVVpbnQzMihnKTtmb3IobGV0IEI9MDtCPGc7QisrKU9BLmVuY29kZUludG8oQS5tYXNrW0JdLEkpfXJldHVybiBJLmxlbmd0aC1nfSxkZWNvZGUoSSl7Y29uc3QgZz1BLmdldEluc3RhbmNlKCk7cmV0dXJuIGcuc3RhcnRSZWFkaW5nKEkpLHRoaXMucmVhZEZyb20oZyl9LHJlYWRGcm9tKEEpe2xldCBJLGcsQixRLEMsZTtJPUEucmVhZEJ5dGVzKCksZz1BLnJlYWRVaW50NjQoKSxCPUEucmVhZFVpbnQzMigpLFE9QS5yZWFkQnl0ZSgpLEM9T0EucmVhZEZyb20oQSk7e2xldCBJPUEucmVhZFVpbnQzMigpO2U9bmV3IEFycmF5KEkpO2ZvcihsZXQgZz0wO2c8STtnKyspe2xldCBJO0k9T0EucmVhZEZyb20oQSksZVtnXT1JfX1yZXR1cm57ZGF0YTpJLHNlZ21lbnRUaW1lOmcsdHlwZTpCLHN0cmVhbUlkOlEsZGVza3RvcFJlY3Q6QyxtYXNrOmV9fX0sVkE9e2Rpc2NyaW1pbmF0b3I6MixlbmNvZGUoSSl7Y29uc3QgZz1BLmdldEluc3RhbmNlKCk7cmV0dXJuIGcuc3RhcnRXcml0aW5nKCksdGhpcy5lbmNvZGVJbnRvKEksZyksZy50b0FycmF5KCl9LGVuY29kZUludG8oQSxJKXtjb25zdCBnPUkubGVuZ3RoO0kud3JpdGVCeXRlcyhBLmRhdGEpLEkud3JpdGVVaW50MzIoQS5tb25pdG9yV2lkdGgpLEkud3JpdGVVaW50MzIoQS5tb25pdG9ySGVpZ2h0KSxJLndyaXRlVWludDMyKEEuc2hhcGVXaWR0aCksSS53cml0ZVVpbnQzMihBLnNoYXBlSGVpZ2h0KSxJLndyaXRlSW50MzIoQS5zcG90WCksSS53cml0ZUludDMyKEEuc3BvdFkpLEkud3JpdGVCeXRlKE51bWJlcihBLnZpc2libGUpKSxJLndyaXRlSW50MzIoQS5wb3NpdGlvblgpLEkud3JpdGVJbnQzMihBLnBvc2l0aW9uWSksSS53cml0ZUJ5dGUoQS5zdHJlYW1JZCk7cmV0dXJuIEkubGVuZ3RoLWd9LGRlY29kZShJKXtjb25zdCBnPUEuZ2V0SW5zdGFuY2UoKTtyZXR1cm4gZy5zdGFydFJlYWRpbmcoSSksdGhpcy5yZWFkRnJvbShnKX0scmVhZEZyb20oQSl7bGV0IEksZyxCLFEsQyxlLGksdCxFLG8sYTtyZXR1cm4gST1BLnJlYWRCeXRlcygpLGc9QS5yZWFkVWludDMyKCksQj1BLnJlYWRVaW50MzIoKSxRPUEucmVhZFVpbnQzMigpLEM9QS5yZWFkVWludDMyKCksZT1BLnJlYWRJbnQzMigpLGk9QS5yZWFkSW50MzIoKSx0PSEhQS5yZWFkQnl0ZSgpLEU9QS5yZWFkSW50MzIoKSxvPUEucmVhZEludDMyKCksYT1BLnJlYWRCeXRlKCkse2RhdGE6SSxtb25pdG9yV2lkdGg6Zyxtb25pdG9ySGVpZ2h0OkIsc2hhcGVXaWR0aDpRLHNoYXBlSGVpZ2h0OkMsc3BvdFg6ZSxzcG90WTppLHZpc2libGU6dCxwb3NpdGlvblg6RSxwb3NpdGlvblk6byxzdHJlYW1JZDphfX19LGpBPXtkaXNjcmltaW5hdG9yOjMsZW5jb2RlKEkpe2NvbnN0IGc9QS5nZXRJbnN0YW5jZSgpO3JldHVybiBnLnN0YXJ0V3JpdGluZygpLHRoaXMuZW5jb2RlSW50byhJLGcpLGcudG9BcnJheSgpfSxlbmNvZGVJbnRvKEEsSSl7Y29uc3QgZz1JLmxlbmd0aDtJLndyaXRlQnl0ZXMoQS5kYXRhKSxJLndyaXRlVWludDMyKEEudHlwZSksSS53cml0ZUJ5dGUoQS5zdHJlYW1JZCk7cmV0dXJuIEkubGVuZ3RoLWd9LGRlY29kZShJKXtjb25zdCBnPUEuZ2V0SW5zdGFuY2UoKTtyZXR1cm4gZy5zdGFydFJlYWRpbmcoSSksdGhpcy5yZWFkRnJvbShnKX0scmVhZEZyb20oQSl7bGV0IEksZyxCO3JldHVybiBJPUEucmVhZEJ5dGVzKCksZz1BLnJlYWRVaW50MzIoKSxCPUEucmVhZEJ5dGUoKSx7ZGF0YTpJLHR5cGU6ZyxzdHJlYW1JZDpCfX19LFpBPXtkaXNjcmltaW5hdG9yOjQsZW5jb2RlKEkpe2NvbnN0IGc9QS5nZXRJbnN0YW5jZSgpO3JldHVybiBnLnN0YXJ0V3JpdGluZygpLHRoaXMuZW5jb2RlSW50byhJLGcpLGcudG9BcnJheSgpfSxlbmNvZGVJbnRvKEEsSSl7Y29uc3QgZz1JLmxlbmd0aDtNLmVuY29kZUludG8oQS5jaHVuayxJKTtyZXR1cm4gSS5sZW5ndGgtZ30sZGVjb2RlKEkpe2NvbnN0IGc9QS5nZXRJbnN0YW5jZSgpO3JldHVybiBnLnN0YXJ0UmVhZGluZyhJKSx0aGlzLnJlYWRGcm9tKGcpfSxyZWFkRnJvbShBKXtsZXQgSTtyZXR1cm4gST1NLnJlYWRGcm9tKEEpLHtjaHVuazpJfX19LHpBPXtlbmNvZGUoSSl7Y29uc3QgZz1BLmdldEluc3RhbmNlKCk7cmV0dXJuIGcuc3RhcnRXcml0aW5nKCksdGhpcy5lbmNvZGVJbnRvKEksZyksZy50b0FycmF5KCl9LGVuY29kZUludG8oQSxJKXtjb25zdCBnPUkubGVuZ3RoLEI9SS5yZXNlcnZlTWVzc2FnZUxlbmd0aCgpLFE9SS5sZW5ndGgrMTtzd2l0Y2goSS53cml0ZUJ5dGUoQS5kaXNjcmltaW5hdG9yKSxBLmRpc2NyaW1pbmF0b3Ipe2Nhc2UgMTpYQS5lbmNvZGVJbnRvKEEudmFsdWUsSSk7YnJlYWs7Y2FzZSAyOlZBLmVuY29kZUludG8oQS52YWx1ZSxJKTticmVhaztjYXNlIDM6akEuZW5jb2RlSW50byhBLnZhbHVlLEkpO2JyZWFrO2Nhc2UgNDpaQS5lbmNvZGVJbnRvKEEudmFsdWUsSSl9Y29uc3QgQz1JLmxlbmd0aDtJLmZpbGxNZXNzYWdlTGVuZ3RoKEIsQy1RKTtyZXR1cm4gSS5sZW5ndGgtZ30sZGVjb2RlKEkpe2NvbnN0IGc9QS5nZXRJbnN0YW5jZSgpO3JldHVybiBnLnN0YXJ0UmVhZGluZyhJKSx0aGlzLnJlYWRGcm9tKGcpfSxyZWFkRnJvbShBKXtjb25zdCBnPUEucmVhZE1lc3NhZ2VMZW5ndGgoKSxCPUEuaW5kZXgrMStnO3N3aXRjaChBLnJlYWRCeXRlKCkpe2Nhc2UgMTpyZXR1cm57ZGlzY3JpbWluYXRvcjoxLHZhbHVlOlhBLnJlYWRGcm9tKEEpfTtjYXNlIDI6cmV0dXJue2Rpc2NyaW1pbmF0b3I6Mix2YWx1ZTpWQS5yZWFkRnJvbShBKX07Y2FzZSAzOnJldHVybntkaXNjcmltaW5hdG9yOjMsdmFsdWU6akEucmVhZEZyb20oQSl9O2Nhc2UgNDpyZXR1cm57ZGlzY3JpbWluYXRvcjo0LHZhbHVlOlpBLnJlYWRGcm9tKEEpfTtkZWZhdWx0OnRocm93IEEuaW5kZXg9QixuZXcgSShcIlVucmVjb2duaXplZCBkaXNjcmltaW5hdG9yIHdoaWxlIGRlY29kaW5nIE1lZGlhQm9keVwiKX19fTtjbGFzcyBfQXtjb25zdHJ1Y3Rvcigpe3RoaXMuaGFuZGxlcnM9W119YWRkSGFuZGxlcihBKXt0aGlzLmhhbmRsZXJzLnB1c2goQSl9cmVtb3ZlSGFuZGxlcihBKXt0aGlzLmhhbmRsZXJzPXRoaXMuaGFuZGxlcnMuZmlsdGVyKChJPT5JIT09QSkpfWludm9rZShBKXtmb3IobGV0IEk9MDtJPHRoaXMuaGFuZGxlcnMubGVuZ3RoO0krKyl0aGlzLmhhbmRsZXJzW0ldKEEpfX1sZXQgJEE7ZnVuY3Rpb24gQUkoQSxJLGcpeyRBJiYkQS5vbkxvZyhBLEksZyl9ZnVuY3Rpb24gSUkoQSxJKXtBSShlLkVycm9yLEEsSSl9ZnVuY3Rpb24gZ0koQSxJKXtBSShlLldhcm5pbmcsQSxJKX1mdW5jdGlvbiBCSShBLEkpe0FJKGUuSW5mbyxBLEkpfWZ1bmN0aW9uIFFJKEEsSSl7QUkoZS5EZWJ1ZyxBLEkpfXZhciBDSSxlSSxpSTthc3luYyBmdW5jdGlvbiB0SShBKXtjb25zdCBJPWF3YWl0IGFzeW5jIGZ1bmN0aW9uKEEpe2NvbnN0IEk9YXdhaXQgQyhcIi9rZXlzL3ZhbGlkYXRlXCIse2hlYWRlcnM6e0F1dGhvcml6YXRpb246YEJlYXJlciAke0F9YCxBY2NlcHQ6XCJhcHBsaWNhdGlvbi9qc29uXCJ9fSksZz1hd2FpdCBJLmpzb24oKTtyZXR1cm57dW5pdmVyc2VGbGFnOmcudW5pdmVyc2Usb3JnYW5pemF0aW9uSWQ6Zy5vcmdfaWR9fShBKSxnPWByYWlud2F5LWhvc3RuYW1lLSR7SS5vcmdhbml6YXRpb25JZC50b1N0cmluZygxNikucGFkU3RhcnQoOCxcIjBcIil9LSR7SS51bml2ZXJzZUZsYWd9YCxCPUJpZ0ludChsb2NhbFN0b3JhZ2UuZ2V0SXRlbShnKT8/YXdhaXQgYXN5bmMgZnVuY3Rpb24oKXtjb25zdCBBPWF3YWl0IEMoXCIvZHJ1aWQvbmV4dFwiLHtoZWFkZXJzOntBY2NlcHQ6XCJhcHBsaWNhdGlvbi9qc29uXCJ9fSk7cmV0dXJuIEJpZ0ludChhd2FpdCBBLnRleHQoKSl9KCkpO3JldHVybiBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShnLEIudG9TdHJpbmcoKSksQn1mdW5jdGlvbiBFSShBLEksZyl7Y29uc3QgQj1zLmVuY29kZSh7aWQ6QSxhcGlLZXk6SSxleHRlcm5hbElkOmd9KTtyZXR1cm4gYnRvYShTdHJpbmcuZnJvbUNoYXJDb2RlKC4uLkIpKS5yZXBsYWNlKC89KiQvLFwiXCIpLnJlcGxhY2UoL1xcKy9nLFwiLVwiKS5yZXBsYWNlKC9cXC8vZyxcIl9cIil9IWZ1bmN0aW9uKEEpe0FbQS5PcGVuPTBdPVwiT3BlblwiLEFbQS5DbG9zZWQ9MV09XCJDbG9zZWRcIn0oZUl8fChlST17fSkpO2NsYXNzIG9Je2NvbnN0cnVjdG9yKEEsSSxnLEIsUSxDLGU9XCJ3c3M6Ly9nYXRld2F5LnJhaW53YXkubmV0d29ya1wiKXt0aGlzLm93blBlZXJJZD1BLHRoaXMuYXBpS2V5PUksdGhpcy5leHRlcm5hbElkPWcsdGhpcy5oYW5kbGVQZWVySW5mbz1CLHRoaXMuY29ubmVjdGlvblJlcXVlc3RIYW5kbGVyPVEsdGhpcy5hZGRBY2NlcHRlZFBlZXI9Qyx0aGlzLmNvbm5lY3Rpb25zPW5ldyBNYXAsdGhpcy5jb25uZWN0aW9uTG9zdEV2ZW50PW5ldyBfQSxDSS5zZXQodGhpcyxlSS5DbG9zZWQpLHRoaXMuc3luY0tleT0wLHRoaXMucGVlcklkVG9FeHRlcm5hbElkPW5ldyBNYXAsdGhpcy5vbk1lc3NhZ2U9YXN5bmMgQT0+e2lmKHZvaWQgMCE9PXRoaXMuc29ja2V0JiZcIltvYmplY3QgQXJyYXlCdWZmZXJdXCI9PT1BLmRhdGEudG9TdHJpbmcoKSl7Y29uc3QgST1yLmRlY29kZShuZXcgVWludDhBcnJheShBLmRhdGEpKSx7aGVhZGVyOntzeW5jS2V5Omd9LGJvZHk6Qn09STtzd2l0Y2goQi5kaXNjcmltaW5hdG9yKXtjYXNlIGguZGlzY3JpbWluYXRvcjp0aGlzLndhcm4oXCJnb3QgR2F0ZXdheVJlcXVlc3Q/ISBpIGFtIG5vdCBhIGdhdGV3YXkuIGlnbm9yaW5nXCIpO2JyZWFrO2Nhc2UgZC5kaXNjcmltaW5hdG9yOntjb25zdCBBPUIudmFsdWUuYm9keS52YWx1ZTt0aGlzLnRyYWNlKFwiZ290IEdhdGV3YXlIZWxsb1wiKSx0aGlzLnJlc29sdmVDb25uZWN0VG9HYXRld2F5UHJvbWlzZT8uKEEpO2JyZWFrfWNhc2UgYy5kaXNjcmltaW5hdG9yOntjb25zdHtsZXZlbDpBLGRlc2NyaXB0aW9uOkl9PUIudmFsdWU7QT09PXQuRmF0YWw/KElJKG9JLm5hbWUsXCJGYXRhbCBHYXRld2F5QWxlcnQ6IFwiK0VbSV0pLHRoaXMuZGllKEksXCJUaGUgY29ubmVjdGlvbiB0byB0aGUgUmFpbndheSBzZXJ2ZXIgZW5jb3VudGVyZWQgYSBmYXRhbCBlcnJvci5cIikpOnRoaXMub25Ob25GYXRhbEFsZXJ0KGcsSSk7YnJlYWt9Y2FzZSBELmRpc2NyaW1pbmF0b3I6dGhpcy5vbkZvcndhcmRhYmxlKGcsQi52YWx1ZSl9fX0sdGhpcy5vbkNsb3NlPUE9Pnt0aGlzLmRpZShBLFwiVGhlIGNvbm5lY3Rpb24gdG8gdGhlIFJhaW53YXkgc2VydmVyIHdhcyBjbG9zZWQuXCIpfSx0aGlzLm9uRXJyb3I9QT0+e3RoaXMuZGllKEEsXCJUaGUgY29ubmVjdGlvbiB0byB0aGUgUmFpbndheSBzZXJ2ZXIgd2FzIGxvc3QuXCIpfSx0aGlzLnVybD1lfWdldCBzdGF0dXMoKXtyZXR1cm4gZyh0aGlzLENJLFwiZlwiKX1hc3luYyBjb25uZWN0KCl7cmV0dXJuIHRoaXMuY29ubmVjdFRvR2F0ZXdheVByb21pc2U/Pyh0aGlzLmNvbm5lY3RUb0dhdGV3YXlQcm9taXNlPW5ldyBQcm9taXNlKCgoQSxJKT0+e3RoaXMucmVzb2x2ZUNvbm5lY3RUb0dhdGV3YXlQcm9taXNlPUEsdGhpcy5yZWplY3RDb25uZWN0VG9HYXRld2F5UHJvbWlzZT1JLHRoaXMub3BlbigpfSkpKX1hc3luYyBvcGVuKCl7dGhpcy5zb2NrZXQ9YXdhaXQgdGhpcy5tYWtlV2ViU29ja2V0KHRoaXMudXJsKSx0aGlzLmRlYnVnKFwiY29ubmVjdGVkIFdlYlNvY2tldFwiKSx0aGlzLnNvY2tldC5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLHRoaXMub25NZXNzYWdlKSx0aGlzLnNvY2tldC5hZGRFdmVudExpc3RlbmVyKFwiY2xvc2VcIix0aGlzLm9uQ2xvc2UpLEIodGhpcyxDSSxlSS5PcGVuLFwiZlwiKX1tYWtlV2ViU29ja2V0KEEpe3JldHVybiBuZXcgUHJvbWlzZSgoKEksZyk9Pntjb25zdCBCPW5ldyBXZWJTb2NrZXQoQSxbXCJoYW5kc2hha2VcIixFSSh0aGlzLm93blBlZXJJZCx0aGlzLmFwaUtleSx0aGlzLmV4dGVybmFsSWQpXSk7Qi5iaW5hcnlUeXBlPVwiYXJyYXlidWZmZXJcIixCLm9ub3Blbj0oKT0+e0koQil9LEIub25lcnJvcj1BPT57dGhpcy5vbkVycm9yKEEpLGcoQSksdGhpcy5jb25uZWN0VG9HYXRld2F5UHJvbWlzZT12b2lkIDB9fSkpfWRpc2Nvbm5lY3QoKXtpZih0aGlzLmRlYnVnKFwiZGlzY29ubmVjdCgpXCIpLHZvaWQgMCE9PXRoaXMuc29ja2V0KXt0aGlzLnNvY2tldC5jbG9zZSgzZTMsXCJTaWduYWxpbmcgd2Vic29ja2V0IGNsb3NlZC5cIik7Y29uc3QgQT10aGlzLnNvY2tldDt3aW5kb3cuc2V0VGltZW91dCgoKCk9PntBLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjbG9zZVwiLHRoaXMub25DbG9zZSksQS5yZW1vdmVFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLHRoaXMub25NZXNzYWdlKX0pLDApfXRoaXMucmVqZWN0Q29ubmVjdFRvR2F0ZXdheVByb21pc2U/Lih2b2lkIDApLEIodGhpcyxDSSxlSS5DbG9zZWQsXCJmXCIpLHRoaXMuY29ubmVjdFRvR2F0ZXdheVByb21pc2U9dm9pZCAwLHRoaXMucmVzb2x2ZUNvbm5lY3RUb0dhdGV3YXlQcm9taXNlPXZvaWQgMCx0aGlzLnJlamVjdENvbm5lY3RUb0dhdGV3YXlQcm9taXNlPXZvaWQgMCx0aGlzLnNvY2tldD12b2lkIDAsdGhpcy5jb25uZWN0aW9ucy5jbGVhcigpfW1ha2VEYXRhZ3JhbShBKXtyZXR1cm57aGVhZGVyOntzeW5jS2V5OisrdGhpcy5zeW5jS2V5fSxib2R5OkF9fW1ha2VGb3J3YXJkYWJsZShBLEkpe3JldHVybiB0aGlzLm1ha2VEYXRhZ3JhbSh7ZGlzY3JpbWluYXRvcjpELmRpc2NyaW1pbmF0b3IsdmFsdWU6e3RhcmdldFBlZXJJZDpBLGJvZHk6SX19KX1jb25uZWN0VG9Ib3N0KEEsSSl7Y29uc3QgZz10aGlzLmNvbm5lY3Rpb25zLmdldChBKTtpZih2b2lkIDAhPT1nKXtpZihnLm93bmVkKXRocm93IG5ldyBRKFwiYWxyZWFkeSBjb25uZWN0ZWQgaW4gb3RoZXIgZGlyZWN0aW9uXCIpO3JldHVybiBnLnByb21pc2V9aWYodm9pZCAwPT09dGhpcy5zb2NrZXQpdGhyb3cgbmV3IFEoXCJzb2NrZXQgdW5kZWZpbmVkIGluIHNlbmRJbml0Q29ubmVjdGlvblJlcXVlc3RcIik7aWYodGhpcy5zdGF0dXMhPT1lSS5PcGVuKXRocm93IG5ldyBRKFwic2lnbmFsaW5nIGNoYW5uZWwgbm90IG9wZW4gaW4gc2VuZEluaXRDb25uZWN0aW9uUmVxdWVzdFwiKTtjb25zdCBCPXRoaXMuc29ja2V0LEM9e3BlbmRpbmc6ITB9O3JldHVybiBDLnByb21pc2U9bmV3IFByb21pc2UoKChnLFEpPT57Qy5yZXNvbHZlPWcsQy5yZWplY3Q9USx0aGlzLnRyYWNlKGBBZGRpbmcgJHtBfSB0byBwZW5kaW5nQ29ubmVjdGlvbnNgKTtjb25zdCBlPXRoaXMubWFrZURhdGFncmFtKHtkaXNjcmltaW5hdG9yOmguZGlzY3JpbWluYXRvcix2YWx1ZTp7Ym9keTp7ZGlzY3JpbWluYXRvcjpGLmRpc2NyaW1pbmF0b3IsdmFsdWU6e2Rlc2lyZWRUcmFuc3BvcnQ6SSx0YXJnZXRQZWVySWQ6QX19fX0pO0Muc3luY0tleT1lLmhlYWRlci5zeW5jS2V5LHRoaXMuY29ubmVjdGlvbnMuc2V0KEEsQyksQi5zZW5kKHIuZW5jb2RlKGUpKX0pKSxDLnByb21pc2V9Y2FuY2VsQ29ubmVjdGlvbkF0dGVtcHQoQSl7Y29uc3QgST10aGlzLmNvbm5lY3Rpb25zLmdldChBKTt2b2lkIDAhPT1JJiZJLnBlbmRpbmcmJihJLnJlc29sdmUoe2NhbmNlbGVkOiEwfSksdGhpcy5jb25uZWN0aW9ucy5kZWxldGUoQSkpfWRlbGV0ZUNvbm5lY3Rpb24oQSl7dGhpcy5jb25uZWN0aW9ucy5kZWxldGUoQSl9c2VuZFBlZXJJbmZvKEEsSSxnKXtpZih2b2lkIDA9PT10aGlzLnNvY2tldCl0aHJvdyBuZXcgUShcInNvY2tldCB1bnNldCBpbiBHYXRld2F5LnNlbmRQZWVySW5mb1wiKTtjb25zdCBCPXRoaXMuY29ubmVjdGlvbnMuZ2V0KEEpO2lmKHZvaWQgMD09PUIpdGhyb3cgbmV3IFEoYGNhbid0IHNlbmQgcGVlciBpbmZvIHRvIHVua25vd24gcGVlcklkICR7QX1gKTtpZihCLnBlbmRpbmcpdGhyb3cgbmV3IFEoYGNhbid0IHNlbmQgcGVlciBpbmZvIHRvIHBlbmRpbmcgcGVlcklkICR7QX1gKTtjb25zdCBDPXRoaXMubWFrZUZvcndhcmRhYmxlKEEse2Rpc2NyaW1pbmF0b3I6ay5kaXNjcmltaW5hdG9yLHZhbHVlOntpZDpCLmNvbm5lY3Rpb25SZXF1ZXN0SWQsdHlwZTpJLGRhdGE6Z319KSxlPXIuZW5jb2RlKEMpO3RoaXMuc29ja2V0LnNlbmQoZSl9c2VuZE9mZmVyKEEsSSl7dGhpcy5kZWJ1ZyhcInNlbmRpbmcgb2ZmZXI6IFwiK0kpLHRoaXMuc2VuZFBlZXJJbmZvKEEsYS5PZmZlcixJKX1zZW5kQW5zd2VyKEEsSSl7dGhpcy5kZWJ1ZyhcInNlbmRpbmcgb2ZmZXI6IFwiK0kpLHRoaXMuc2VuZFBlZXJJbmZvKEEsYS5BbnN3ZXIsSSl9c2VuZENhbmRpZGF0ZShBLEkpe3RoaXMuZGVidWcoXCJzZW5kaW5nIGNhbmRpZGF0ZVwiK0kuY2FuZGlkYXRlKSx0aGlzLnNlbmRQZWVySW5mbyhBLGEuQ2FuZGlkYXRlLEkuY2FuZGlkYXRlKX1vbk5vbkZhdGFsQWxlcnQoQSxJKXtpZihJPT09RS5QZWVyR29uZUF3YXkpZm9yKGNvbnN0W0ksZ11vZiB0aGlzLmNvbm5lY3Rpb25zLmVudHJpZXMoKSlnLnBlbmRpbmcmJmcuc3luY0tleT09PUEmJihnLnJlamVjdChcIlRoZSB0YXJnZXQgcGVlciBpcyBub3QgY29ubmVjdGVkIHRvIFJhaW53YXkuXCIpLHRoaXMuY29ubmVjdGlvbnMuZGVsZXRlKEkpKX1vbkZvcndhcmRhYmxlKEEsSSl7Y29uc3R7Ym9keTpnfT1JO3N3aXRjaChnLmRpc2NyaW1pbmF0b3Ipe2Nhc2UgUi5kaXNjcmltaW5hdG9yOntjb25zdHtzb3VyY2VQZWVySWQ6SSxzb3VyY2VFeHRlcm5hbElkOkIsaWQ6Q309Zy52YWx1ZSxlPUM7dGhpcy5wZWVySWRUb0V4dGVybmFsSWQuc2V0KEksQiksdGhpcy5jb25uZWN0aW9uUmVxdWVzdEhhbmRsZXIoe2lkOkksZXh0ZXJuYWxJZDpnLnZhbHVlLnNvdXJjZUV4dGVybmFsSWQsYWNjZXB0OigpPT57aWYodm9pZCAwPT09dGhpcy5zb2NrZXQpdGhyb3cgbmV3IFEoXCJDb3VsZG4ndCBzZW5kIGFjY2VwdCBtZXNzYWdlIGJlY2F1c2UgdGhlIGNvbm5lY3Rpb24gdG8gUmFpbndheSB3YXMgbG9zdC5cIik7Y29uc3QgZz1yLmVuY29kZSh7aGVhZGVyOntzeW5jS2V5OkF9LGJvZHk6e2Rpc2NyaW1pbmF0b3I6RC5kaXNjcmltaW5hdG9yLHZhbHVlOnt0YXJnZXRQZWVySWQ6SSxib2R5OntkaXNjcmltaW5hdG9yOnUuZGlzY3JpbWluYXRvcix2YWx1ZTp7c291cmNlUGVlcklkOnRoaXMub3duUGVlcklkLHNvdXJjZUV4dGVybmFsSWQ6dGhpcy5leHRlcm5hbElkLGlkOkN9fX19fSk7cmV0dXJuIHRoaXMuc29ja2V0LnNlbmQoZyksdGhpcy5jb25uZWN0aW9ucy5zZXQoSSx7cGVuZGluZzohMSxvd25lZDohMCxjb25uZWN0aW9uUmVxdWVzdElkOmV9KSx0aGlzLmFkZEFjY2VwdGVkUGVlcihJLEIsZSl9LHJlamVjdDpnPT57aWYodm9pZCAwPT09dGhpcy5zb2NrZXQpdGhyb3cgbmV3IFEoXCJDb3VsZG4ndCBzZW5kIHJlamVjdCBtZXNzYWdlIGJlY2F1c2UgdGhlIGNvbm5lY3Rpb24gdG8gUmFpbndheSB3YXMgbG9zdC5cIik7Y29uc3QgQj1yLmVuY29kZSh7aGVhZGVyOntzeW5jS2V5OkF9LGJvZHk6e2Rpc2NyaW1pbmF0b3I6RC5kaXNjcmltaW5hdG9yLHZhbHVlOnt0YXJnZXRQZWVySWQ6SSxib2R5OntkaXNjcmltaW5hdG9yOmwuZGlzY3JpbWluYXRvcix2YWx1ZTp7c291cmNlUGVlcklkOnRoaXMub3duUGVlcklkLHNvdXJjZUV4dGVybmFsSWQ6dGhpcy5leHRlcm5hbElkLGlkOkMscmVhc29uOmd9fX19fSk7dGhpcy5zb2NrZXQuc2VuZChCKX19KTticmVha31jYXNlIHUuZGlzY3JpbWluYXRvcjp7Y29uc3R7aWQ6QSxzb3VyY2VQZWVySWQ6SSxzb3VyY2VFeHRlcm5hbElkOkJ9PWcudmFsdWUsUT1BLEM9dGhpcy5jb25uZWN0aW9ucy5nZXQoSSk7aWYodm9pZCAwPT09QylyZXR1cm4gdm9pZCB0aGlzLndhcm4oXCJJZ25vcmluZyBBY2NlcHRlZENvbm5lY3Rpb25SZXF1ZXN0IGZyb20gdW5leHBlY3RlZCBob3N0bmFtZTogXCIrSSk7aWYoIUMucGVuZGluZylyZXR1cm4gdm9pZCB0aGlzLndhcm4oXCJJZ25vcmluZyBBY2NlcHRlZENvbm5lY3Rpb25SZXF1ZXN0IGZyb20gYWxyZWFkeS1jb25uZWN0ZWQgaG9zdG5hbWU6IFwiK0kpO0MucmVzb2x2ZSh7Y2FuY2VsZWQ6ITEsYWNjZXB0ZWQ6ITAsY29ubmVjdGlvblJlcXVlc3RJZDpRLGhvc3RFeHRlcm5hbElkOkIsdHJhbnNwb3J0UHJvdG9jb2w6by5TQ1RQfSksdGhpcy5jb25uZWN0aW9ucy5zZXQoSSx7cGVuZGluZzohMSxvd25lZDohMSxwcm9taXNlOkMucHJvbWlzZSxjb25uZWN0aW9uUmVxdWVzdElkOlF9KTticmVha31jYXNlIGwuZGlzY3JpbWluYXRvcjp7Y29uc3R7aWQ6QSxzb3VyY2VQZWVySWQ6SSxzb3VyY2VFeHRlcm5hbElkOkJ9PWcudmFsdWUsUT1BLEM9dGhpcy5jb25uZWN0aW9ucy5nZXQoSSk7aWYodm9pZCAwPT09QylyZXR1cm4gdm9pZCB0aGlzLndhcm4oXCJJZ25vcmluZyBSZWplY3RlZENvbm5lY3Rpb25SZXF1ZXN0IGZyb20gdW5leHBlY3RlZCBob3N0bmFtZTogXCIrSSk7aWYoIUMucGVuZGluZylyZXR1cm4gdm9pZCB0aGlzLndhcm4oXCJJZ25vcmluZyBSZWplY3RlZENvbm5lY3Rpb25SZXF1ZXN0IGZyb20gYWxyZWFkeS1jb25uZWN0ZWQgaG9zdG5hbWU6IFwiK0kpO0MucmVzb2x2ZSh7Y2FuY2VsZWQ6ITEsYWNjZXB0ZWQ6ITEsY29ubmVjdGlvblJlcXVlc3RJZDpRLGhvc3RFeHRlcm5hbElkOkIsdHJhbnNwb3J0UHJvdG9jb2w6by5TQ1RQLHJlYXNvbjpnLnZhbHVlLnJlYXNvbn0pLHRoaXMuY29ubmVjdGlvbnMuZGVsZXRlKEkpO2JyZWFrfWNhc2Ugay5kaXNjcmltaW5hdG9yOnRoaXMudHJhY2UoXCJHb3QgcGVlciBpbmZvOlxcblwiK0pTT04uc3RyaW5naWZ5KGcudmFsdWUpKSx0aGlzLmhhbmRsZVBlZXJJbmZvKGcudmFsdWUpfX1kaWUoQSxJKXt0aGlzLnJlamVjdENvbm5lY3RUb0dhdGV3YXlQcm9taXNlPy4oQSksdGhpcy5jb25uZWN0VG9HYXRld2F5UHJvbWlzZT12b2lkIDAsdGhpcy5yZXNvbHZlQ29ubmVjdFRvR2F0ZXdheVByb21pc2U9dm9pZCAwLHRoaXMucmVqZWN0Q29ubmVjdFRvR2F0ZXdheVByb21pc2U9dm9pZCAwO2Zvcihjb25zdCBBIG9mIHRoaXMuY29ubmVjdGlvbnMudmFsdWVzKCkpQS5wZW5kaW5nJiZBLnJlamVjdChJKTt0aGlzLmNvbm5lY3Rpb25zLmNsZWFyKCksdGhpcy5jb25uZWN0aW9uTG9zdEV2ZW50Py5pbnZva2UobmV3IFEoSSkpfXVuc2V0Q29ubmVjdFRvR2F0ZXdheVByb21pc2UoKXt0aGlzLmNvbm5lY3RUb0dhdGV3YXlQcm9taXNlPXZvaWQgMCx0aGlzLnJlc29sdmVDb25uZWN0VG9HYXRld2F5UHJvbWlzZT12b2lkIDAsdGhpcy5yZWplY3RDb25uZWN0VG9HYXRld2F5UHJvbWlzZT12b2lkIDB9dHJhY2UoQSl7dmFyIEksZztJPW9JLm5hbWUsZz1TdHJpbmcoQSksQUkoZS5UcmFjZSxJLGcpfWRlYnVnKEEpe1FJKG9JLm5hbWUsU3RyaW5nKEEpKX13YXJuKEEpe2dJKG9JLm5hbWUsU3RyaW5nKEEpKX19Q0k9bmV3IFdlYWtNYXAsZnVuY3Rpb24oQSl7QVtBLkRpc2Nvbm5lY3RlZD0wXT1cIkRpc2Nvbm5lY3RlZFwiLEFbQS5Db25uZWN0aW5nPTFdPVwiQ29ubmVjdGluZ1wiLEFbQS5Db25uZWN0ZWQ9Ml09XCJDb25uZWN0ZWRcIn0oaUl8fChpST17fSkpO2xldCBhST0wO2NsYXNzIHNJe2NvbnN0cnVjdG9yKCl7dGhpcy5saXN0ZW5lcnM9e319YWRkRXZlbnRMaXN0ZW5lcihBLEkpe3ZhciBnOyhnPXRoaXMubGlzdGVuZXJzKVtBXT8/KGdbQV09W10pLHRoaXMubGlzdGVuZXJzW0FdLnB1c2goSSl9cmVtb3ZlRXZlbnRMaXN0ZW5lcihBLEkpe3RoaXMubGlzdGVuZXJzW0FdPUk/dGhpcy5saXN0ZW5lcnNbQV0/LmZpbHRlcigoQT0+QSE9PUkpKT8/W106W119cmVtb3ZlQWxsRXZlbnRMaXN0ZW5lcnMoKXt0aGlzLmxpc3RlbmVycz17fX1lbWl0KEEsLi4uSSl7Zm9yKGNvbnN0IGcgb2YgdGhpcy5saXN0ZW5lcnNbQV0/P1tdKWcoLi4uSSl9fXZhciBuSSxySSxoSTshZnVuY3Rpb24oQSl7QVtBLlVucmVsaWFibGU9MF09XCJVbnJlbGlhYmxlXCIsQVtBLlJlbGlhYmxlPTFdPVwiUmVsaWFibGVcIn0obkl8fChuST17fSkpO2NsYXNzIGRJIGV4dGVuZHMgc0l7Y29uc3RydWN0b3IoQSxJKXtzdXBlcigpLHRoaXMucGVlcj1JLHRoaXMuaWQ9QS5pZCx0aGlzLm1vZGU9QS5tb2RlfXNlbmQoQSl7dGhpcy5wZWVyLnNlbmQodGhpcy5pZCxBKX1fZW1pdChBKXt0aGlzLmVtaXQoXCJtZXNzYWdlXCIsQSl9fWNvbnN0IGNJPXtpY2VTZXJ2ZXJzOlt7dXJsczpcInN0dW46c3R1bi5yYWlud2F5LmNvbTozNDc4XCJ9XX07Y2xhc3MgREkgZXh0ZW5kcyBjbGFzc3t9e2NvbnN0cnVjdG9yKEEsSSxnLEMsZSx0KXtzdXBlcigpLHRoaXMub3duUGVlcklkPUEsdGhpcy50YXJnZXRQZWVySWQ9SSx0aGlzLnNlbmRMb2NhbE9mZmVyU2RwPWcsdGhpcy5zZW5kTG9jYWxBbnN3ZXJTZHA9Qyx0aGlzLnNlbmRMb2NhbEljZUNhbmRpZGF0ZT1lLHRoaXMucmVwb3J0U3RhdGVDaGFuZ2U9dCxySS5zZXQodGhpcyxpSS5EaXNjb25uZWN0ZWQpLHRoaXMucnRjQ29uZmlndXJhdGlvbj1jSSx0aGlzLmRhdGFDaGFubmVsc0NvbmZpZz17fSx0aGlzLnN5bmNLZXk9MCx0aGlzLm9uUmFpbndheU1lc3NhZ2U9KCk9Pnt9LHRoaXMub25BcHBsaWNhdGlvbk1lc3NhZ2U9KCk9Pnt9LHRoaXMub25DbG9zZT0oKT0+e30saEkuc2V0KHRoaXMsbmV3IE1hcCksdGhpcy5oYW5kbGVQZWVySW5mbz1BPT57aWYoQS50eXBlPT09YS5BbnN3ZXIpdGhpcy5kZWJ1ZyhcIkdvdCBBbnN3ZXIgaW4gQ1JJRCBcIitBLmlkK1wiXFxuXCIrQS5kYXRhKSx0aGlzLnBlZXJDb25uZWN0aW9uPy5zZXRSZW1vdGVEZXNjcmlwdGlvbih7dHlwZTpcImFuc3dlclwiLHNkcDpBLmRhdGF9KTtlbHNlIGlmKEEudHlwZT09PWEuT2ZmZXIpdGhpcy5kZWJ1ZyhcIkdvdCBPZmZlciBpbiBDUklEIFwiK0EuaWQrXCJcXG5cIitBLmRhdGEpLHRoaXMucGVlckNvbm5lY3Rpb24/LnNldFJlbW90ZURlc2NyaXB0aW9uKHt0eXBlOlwib2ZmZXJcIixzZHA6QS5kYXRhfSksdGhpcy5zZW5kQW5zd2VyKCk7ZWxzZXtpZihBLnR5cGUhPT1hLkNhbmRpZGF0ZSl7Y29uc3QgST1hW0EudHlwZV07dGhyb3cgbmV3IFEoYHVuZXhwZWN0ZWQgUGVlckluZm9ybWF0aW9uVHlwZSAke0l9IGluIGhhbmRsZVBlZXJJbmZvYCl9dGhpcy5kZWJ1ZyhcIkdvdCBDYW5kaWRhdGUgaW4gQ1JJRCBcIitBLmlkK1wiXFxuXCIrQS5kYXRhKSx0aGlzLnBlZXJDb25uZWN0aW9uPy5hZGRJY2VDYW5kaWRhdGUobmV3IFJUQ0ljZUNhbmRpZGF0ZSh7Y2FuZGlkYXRlOkEuZGF0YSxzZHBNaWQ6XCJcIixzZHBNTGluZUluZGV4OjB9KSl9fSx0aGlzLmhhbmRsZUxvY2FsSWNlQ2FuZGlkYXRlPUE9PntpZihBLmNhbmRpZGF0ZSl7XCIxXCI9PT1BLmNhbmRpZGF0ZS5jYW5kaWRhdGUuc3BsaXQoXCIgXCIpWzFdJiZ0aGlzLnNlbmRMb2NhbEljZUNhbmRpZGF0ZShBLmNhbmRpZGF0ZSl9fSx0aGlzLmhhbmRsZUljZUNvbm5lY3Rpb25TdGF0ZUNoYW5nZT0oKT0+e2lmKCF0aGlzLnBlZXJDb25uZWN0aW9uKXJldHVybjtjb25zdCBBPXRoaXMucGVlckNvbm5lY3Rpb24uaWNlQ29ubmVjdGlvblN0YXRlO3RoaXMuaW5mbyhgSUNFIGNvbm5lY3Rpb24gc3RhdGUgY2hhbmdlZCB0byAke0F9YCl9LHRoaXMuaGFuZGxlQ29ubmVjdGlvblN0YXRlQ2hhbmdlPSgpPT57aWYoIXRoaXMucGVlckNvbm5lY3Rpb24pcmV0dXJuO2NvbnN0IEE9dGhpcy5wZWVyQ29ubmVjdGlvbi5jb25uZWN0aW9uU3RhdGU7dGhpcy5pbmZvKGBDb25uZWN0aW9uIHN0YXRlIGNoYW5nZWQgdG8gJHtBfWApLFwiY2xvc2VkXCI9PT1BfHxcImZhaWxlZFwiPT09QT8odGhpcy5yZXBvcnRTdGF0ZUNoYW5nZShpLkZhaWxlZCksdGhpcy5vcGVuUmVqZWN0Py4oKSx0aGlzLm9uQ2xvc2UoKSxCKHRoaXMsckksaUkuRGlzY29ubmVjdGVkLFwiZlwiKSx0aGlzLmRpc3Bvc2UoKSk6XCJkaXNjb25uZWN0ZWRcIj09PUE/dGhpcy5yZXBvcnRTdGF0ZUNoYW5nZShpLkRpc2Nvbm5lY3RlZCk6XCJjb25uZWN0aW5nXCI9PT1BP3RoaXMucmVwb3J0U3RhdGVDaGFuZ2UoaS5Db25uZWN0aW5nKTpcImNvbm5lY3RlZFwiPT09QT90aGlzLnJlcG9ydFN0YXRlQ2hhbmdlKGkuQ29ubmVjdGVkKTpcIm5ld1wiPT09QSYmdGhpcy5yZXBvcnRTdGF0ZUNoYW5nZShpLk5ldyl9LHRoaXMuaGFuZGxlRGF0YUNoYW5uZWxNZXNzYWdlPUE9Pntjb25zdCBJPUEudGFyZ2V0LmxhYmVsO3RoaXMuaGFuZGxlTGFiZWxBbmREYXRhKEksbmV3IFVpbnQ4QXJyYXkoQS5kYXRhKSl9LHRoaXMuaGFuZGxlRGF0YUNoYW5uZWxDbG9zZT1BPT57Y29uc3QgST1BLnRhcmdldC5sYWJlbDt0aGlzLndhcm4oXCJSVEMgY2hhbm5lbCBjbG9zZWQ6IFwiK0kpfSx0aGlzLmhhbmRsZURhdGFDaGFubmVsRXJyb3I9QT0+e2NvbnN0IEk9QS50YXJnZXQubGFiZWw7dGhpcy53YXJuKFwiUlRDIGNoYW5uZWwgZXJyb3JlZDogXCIrSSl9LHRoaXMuY2h1bmtlZE1lc3NhZ2VzPW5ldyBNYXAsdGhpcy5oaWdoZXN0Q2h1bmtHcm91cD0wO2NvbnN0IEU9e3Byb3RvY29sOlwic2N0cFwiLG5lZ290aWF0ZWQ6ITF9LG89e29yZGVyZWQ6ITEsbWF4UmV0cmFuc21pdHM6MH07dGhpcy5kYXRhQ2hhbm5lbHNDb25maWc9e1JXX0xvZ2ljOntpZDowLC4uLkUsb3JkZXJlZDohMH0sUldfVmlkZW86e2lkOjEsLi4uRSwuLi5vfSxSV19BdWRpbzp7aWQ6MiwuLi5FLC4uLm99LFJXX0lucHV0OntpZDozLC4uLkUsLi4ub319fWFzeW5jIGNyZWF0ZURhdGFDaGFubmVsKEEsSSl7Y29uc3QgZz17cHJvdG9jb2w6XCJzY3RwXCIsbmVnb3RpYXRlZDohMX0sQj10aGlzLnBlZXJDb25uZWN0aW9uPy5jcmVhdGVEYXRhQ2hhbm5lbChBLEk9PT1uSS5SZWxpYWJsZT97Li4uZyxvcmRlcmVkOiEwfTp7Li4uZyxvcmRlcmVkOiExLG1heFJldHJhbnNtaXRzOjB9KTtpZighQil0aHJvdyBuZXcgUShcIkNvdWxkbid0IGNyZWF0ZSBEYXRhIENoYW5uZWw6IFwiK0EpO3JldHVybiBCLmFkZEV2ZW50TGlzdGVuZXIoXCJjbG9zZVwiLHRoaXMuaGFuZGxlRGF0YUNoYW5uZWxDbG9zZSksQi5hZGRFdmVudExpc3RlbmVyKFwiZXJyb3JcIix0aGlzLmhhbmRsZURhdGFDaGFubmVsRXJyb3IpLEIuYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIix0aGlzLmhhbmRsZURhdGFDaGFubmVsTWVzc2FnZSksdGhpcy5kYXRhQ2hhbm5lbHM/Pyh0aGlzLmRhdGFDaGFubmVscz17fSksdGhpcy5kYXRhQ2hhbm5lbHNbQV09QixuZXcgUHJvbWlzZSgoQT0+e2NvbnN0IEk9KCk9PntBKCksQi5yZW1vdmVFdmVudExpc3RlbmVyKFwib3BlblwiLEkpfTtCLmFkZEV2ZW50TGlzdGVuZXIoXCJvcGVuXCIsSSl9KSl9c2VuZE1lc3NhZ2UoQSxJKXtpZighQSl0aHJvdyBuZXcgUShcInNlbmRNZXNzYWdlOiBubyBsYWJlbFwiKTtpZighdGhpcy5kYXRhQ2hhbm5lbHMpdGhyb3cgbmV3IFEoXCJzZW5kTWVzc2FnZTogZGF0YUNoYW5uZWxzIG5vdCBpbml0aWFsaXplZFwiKTtjb25zdCBnPXRoaXMuZGF0YUNoYW5uZWxzPy5bQV07aWYoIWcpdGhyb3cgbmV3IFEoYHNlbmRNZXNzYWdlOiBjaGFubmVsIFwiJHtBfVwiIGRvZXMgbm90IGV4aXN0YCk7aWYoXCJvcGVuXCIhPT1nLnJlYWR5U3RhdGUpdGhyb3cgbmV3IFEoYHNlbmRNZXNzYWdlOiBjaGFubmVsIFwiJHtBfVwiIGlzIG5vdCBvcGVuYCk7Zy5zZW5kKEkpfWdldCBzdGF0dXMoKXtyZXR1cm4gZyh0aGlzLHJJLFwiZlwiKX1nZXQgbWF4TWVzc2FnZVNpemUoKXtyZXR1cm4gdGhpcy5wZWVyQ29ubmVjdGlvbj8uc2N0cD8ubWF4TWVzc2FnZVNpemU/PzI2MjE0NH1hc3luYyBnZXRTdGF0cygpe2lmKCF0aGlzLnBlZXJDb25uZWN0aW9uKXRocm93IG5ldyBRKFwiZ2V0U3RhdHMoKSBidXQgbm8gcGVlckNvbm5lY3Rpb25cIik7Y29uc3RbQSxJXT1hd2FpdCBQcm9taXNlLmFsbChbdGhpcy5wZWVyQ29ubmVjdGlvbi5nZXRTdGF0cyh2b2lkIDApLHRoaXMubWVhc3VyZUxhdGVuY3lNcygpXSksZz17Y2hhbm5lbHM6e30scmF3OkEsbGF0ZW5jeU1zOkl9O3JldHVybiBBLmZvckVhY2goKEE9PntcImRhdGEtY2hhbm5lbFwiPT09QS50eXBlJiYoZy5jaGFubmVsc1tBLmxhYmVsXT1BKX0pKSxnfWNoZWNrSGVhZGVyKEEpe2lmKDIwMzY0MzA2NzQhPT1BLm1hZ2ljTnVtYmVyKXRocm93IG5ldyBRKFwiSW52YWxpZCBtYWdpY051bWJlciBpbiBjaGVja0hlYWRlci5cIik7aWYoQS50YXJnZXRQZWVySWQhPT10aGlzLm93blBlZXJJZCl0aHJvdyBuZXcgUShcIkludmFsaWQgZGVzdGluYXRpb24gaG9zdCBuYW1lIChub3Qgb3VycykgaW4gY2hlY2tIZWFkZXIuXCIpfWhhbmRsZUxhYmVsQW5kRGF0YShBLEkpe2lmKFwiUldfTG9naWNcIj09PUEpe2NvbnN0e2hlYWRlcjpBLGJvZHk6Qn09Zi5kZWNvZGUoSSk7aWYodGhpcy5jaGVja0hlYWRlcihBKSxCLmRpc2NyaW1pbmF0b3I9PT1QQS5kaXNjcmltaW5hdG9yKXtjb25zdCBJPWcodGhpcyxoSSxcImZcIikuZ2V0KEEuc3luY0tleSk7SSYmSS5yZXNvbHZlKCl9ZWxzZSBCLmRpc2NyaW1pbmF0b3I9PT1iQS5kaXNjcmltaW5hdG9yP3RoaXMuc2VuZExvZ2ljRGF0YWdyYW0oe2Rpc2NyaW1pbmF0b3I6UEEuZGlzY3JpbWluYXRvcix2YWx1ZTp7fX0sQS5zeW5jS2V5KTp0aGlzLm9uUmFpbndheU1lc3NhZ2Uoe2tpbmQ6XCJMb2dpY1wiLGJvZHk6Qn0pfWVsc2UgaWYoXCJSV19JbnB1dFwiPT09QSl7Y29uc3R7aGVhZGVyOkEsYm9keTpnfT1MLmRlY29kZShJKTt0aGlzLmNoZWNrSGVhZGVyKEEpLHRoaXMub25SYWlud2F5TWVzc2FnZSh7a2luZDpcIklucHV0XCIsYm9keTpnfSl9ZWxzZSBpZihcIlJXX0F1ZGlvXCI9PT1BfHxcIlJXX1ZpZGVvXCI9PUEpe2NvbnN0e2hlYWRlcjpnLGJvZHk6Qn09cC5kZWNvZGUoSSk7dGhpcy5jaGVja0hlYWRlcihnKSxCLmRpc2NyaW1pbmF0b3I9PT1aQS5kaXNjcmltaW5hdG9yP3RoaXMuaGFuZGxlQ2h1bmsoQSxCLnZhbHVlLmNodW5rKTp0aGlzLm9uUmFpbndheU1lc3NhZ2Uoe2tpbmQ6XCJNZWRpYVwiLGJvZHk6Qn0pfWVsc2UgaWYoL15SV18vLnRlc3QoQSkpdGhpcy53YXJuKGBVbmtub3duIFJhaW53YXktcmVzZXJ2ZWQgUlRDIGxhYmVsPyAke0F9YCk7ZWxzZXtjb25zdCBnPUguZGVjb2RlKEkpO3RoaXMuY2hlY2tIZWFkZXIoZy5oZWFkZXIpLHRoaXMuaGFuZGxlQ2h1bmsoQSxnLmJvZHkpfX1nZXREYXRhZ3JhbUhlYWRlcihBLEkpe3JldHVybnttYWdpY051bWJlcjoyMDM2NDMwNjc0LHN5bmNLZXk6QT9JPz8rK3RoaXMuc3luY0tleTowLHNvdXJjZVBlZXJJZDp0aGlzLm93blBlZXJJZCx0YXJnZXRQZWVySWQ6dGhpcy50YXJnZXRQZWVySWR9fXNlbmRBcmJpdHJhcnlEYXRhZ3JhbShBLEkpeyFmdW5jdGlvbihBLEksZz0xNmUzKXtjb25zdCBCPU1hdGguY2VpbChBLmxlbmd0aC9nKSxRPSsrYUk7Zm9yKGxldCBDPTA7QzxCO0MrKyl7Y29uc3QgZT1DKmcsaT1NYXRoLm1pbigoQysxKSpnLEEubGVuZ3RoKTtJKHtjaHVua3NJbkdyb3VwOkIsZ3JvdXBJZDpRLGluZGV4OkMsZGF0YTpBLnNsaWNlKGUsaSl9KX19KEksKEk9Pnt0aGlzLnNlbmRNZXNzYWdlKEEsSC5lbmNvZGUoe2hlYWRlcjp0aGlzLmdldERhdGFncmFtSGVhZGVyKCEwKSxib2R5Okl9KSl9KSl9c2VuZExvZ2ljRGF0YWdyYW0oQSxJKXtjb25zdCBnPXRoaXMuZ2V0RGF0YWdyYW1IZWFkZXIoITAsSSk7cmV0dXJuIHRoaXMuc2VuZE1lc3NhZ2UoXCJSV19Mb2dpY1wiLGYuZW5jb2RlKHtoZWFkZXI6Zyxib2R5OkF9KSksZy5zeW5jS2V5fXNlbmRJbnB1dERhdGFncmFtKEEpe3RoaXMuc2VuZE1lc3NhZ2UoXCJSV19JbnB1dFwiLEwuZW5jb2RlKHtoZWFkZXI6dGhpcy5nZXREYXRhZ3JhbUhlYWRlcighMSksYm9keTpBfSkpfWFzeW5jIG9wZW4oQSl7YXdhaXQgbmV3IFByb21pc2UoKGFzeW5jKEksZyk9Pnt0aGlzLm9wZW5SZXNvbHZlPUksdGhpcy5vcGVuUmVqZWN0PWcsQih0aGlzLHJJLGlJLkNvbm5lY3RpbmcsXCJmXCIpLHRoaXMucGVlckNvbm5lY3Rpb249bmV3IFJUQ1BlZXJDb25uZWN0aW9uKHRoaXMucnRjQ29uZmlndXJhdGlvbiksdGhpcy5wZWVyQ29ubmVjdGlvbi5hZGRFdmVudExpc3RlbmVyKFwiaWNlY29ubmVjdGlvbnN0YXRlY2hhbmdlXCIsdGhpcy5oYW5kbGVJY2VDb25uZWN0aW9uU3RhdGVDaGFuZ2UpLHRoaXMucGVlckNvbm5lY3Rpb24uYWRkRXZlbnRMaXN0ZW5lcihcImNvbm5lY3Rpb25zdGF0ZWNoYW5nZVwiLHRoaXMuaGFuZGxlQ29ubmVjdGlvblN0YXRlQ2hhbmdlKSx0aGlzLmhhbmRsZUNvbm5lY3Rpb25TdGF0ZUNoYW5nZSgpLHRoaXMuZGF0YUNoYW5uZWxzPz8odGhpcy5kYXRhQ2hhbm5lbHM9e30pO2NvbnN0IFE9T2JqZWN0LmtleXModGhpcy5kYXRhQ2hhbm5lbHNDb25maWcpLmxlbmd0aDtsZXQgQz0wO2NvbnN0IGU9KEEsZyk9Pntjb25zdCBlPSgpPT57KytDLEM9PT1RJiYodGhpcy5wZWVyQ29ubmVjdGlvbj8ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImljZWNhbmRpZGF0ZVwiLHRoaXMuaGFuZGxlTG9jYWxJY2VDYW5kaWRhdGUpLEIodGhpcyxySSxpSS5Db25uZWN0ZWQsXCJmXCIpLEkoKSksZy5yZW1vdmVFdmVudExpc3RlbmVyKFwib3BlblwiLGUpfTtnLmFkZEV2ZW50TGlzdGVuZXIoXCJvcGVuXCIsZSksZy5hZGRFdmVudExpc3RlbmVyKFwiY2xvc2VcIix0aGlzLmhhbmRsZURhdGFDaGFubmVsQ2xvc2UpLGcuYWRkRXZlbnRMaXN0ZW5lcihcImVycm9yXCIsdGhpcy5oYW5kbGVEYXRhQ2hhbm5lbEVycm9yKSxnLmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsdGhpcy5oYW5kbGVEYXRhQ2hhbm5lbE1lc3NhZ2UpfTtpZihcIm9mZmVyXCI9PT1BKWZvcihjb25zdFtBLEldb2YgT2JqZWN0LmVudHJpZXModGhpcy5kYXRhQ2hhbm5lbHNDb25maWcpKXtjb25zdCBnPXRoaXMucGVlckNvbm5lY3Rpb24uY3JlYXRlRGF0YUNoYW5uZWwoQSxJKTt0aGlzLmRhdGFDaGFubmVsc1tBXT1nLGcuYmluYXJ5VHlwZT1cImFycmF5YnVmZmVyXCIsZSgwLGcpfWVsc2UgdGhpcy5wZWVyQ29ubmVjdGlvbi5hZGRFdmVudExpc3RlbmVyKFwiZGF0YWNoYW5uZWxcIiwoQT0+e2NvbnN0IEk9QS5jaGFubmVsLmxhYmVsO3RoaXMuZGF0YUNoYW5uZWxzPz8odGhpcy5kYXRhQ2hhbm5lbHM9e30pLHRoaXMuZGF0YUNoYW5uZWxzW0ldPUEuY2hhbm5lbCxlKEEuY2hhbm5lbC5sYWJlbCxBLmNoYW5uZWwpfSkpO3RoaXMucGVlckNvbm5lY3Rpb24uYWRkRXZlbnRMaXN0ZW5lcihcImljZWNhbmRpZGF0ZVwiLHRoaXMuaGFuZGxlTG9jYWxJY2VDYW5kaWRhdGUpLFwib2ZmZXJcIj09PUEmJmF3YWl0IHRoaXMuc2VuZE9mZmVyKCl9KSl9YXN5bmMgc2VuZE9mZmVyKCl7aWYodm9pZCAwPT09dGhpcy5wZWVyQ29ubmVjdGlvbil0aHJvdyBuZXcgUShcInNlbmRPZmZlcigpOiBubyBwZWVyIGNvbm5lY3Rpb25cIik7Y29uc3QgQT1hd2FpdCB0aGlzLnBlZXJDb25uZWN0aW9uLmNyZWF0ZU9mZmVyKCk7aWYoYXdhaXQgdGhpcy5wZWVyQ29ubmVjdGlvbi5zZXRMb2NhbERlc2NyaXB0aW9uKEEpLCFBLnNkcCl0aHJvdyBuZXcgUShcIkNyZWF0ZWQgb2ZmZXIgY29udGFpbmVkIG5vIHNkcD9cIik7dGhpcy5zZW5kTG9jYWxPZmZlclNkcChBLnNkcCl9YXN5bmMgc2VuZEFuc3dlcigpe2lmKHZvaWQgMD09PXRoaXMucGVlckNvbm5lY3Rpb24pdGhyb3cgbmV3IFEoXCJzZW5kT2ZmZXIoKTogbm8gcGVlciBjb25uZWN0aW9uXCIpO2NvbnN0IEE9YXdhaXQgdGhpcy5wZWVyQ29ubmVjdGlvbi5jcmVhdGVBbnN3ZXIoKTtpZihhd2FpdCB0aGlzLnBlZXJDb25uZWN0aW9uLnNldExvY2FsRGVzY3JpcHRpb24oQSksIUEuc2RwKXRocm93IG5ldyBRKFwiQ3JlYXRlZCBhbnN3ZXIgY29udGFpbmVkIG5vIHNkcD9cIik7dGhpcy5zZW5kTG9jYWxBbnN3ZXJTZHAoQS5zZHApfWNsb3NlKCl7dGhpcy5zdGF0dXMhPT1pSS5EaXNjb25uZWN0ZWQmJih0aGlzLmRlYnVnKFwicnRjLXRyYW5zcG9ydCBjbG9zZSgpLlwiKSx0aGlzLnBlZXJDb25uZWN0aW9uPy5jbG9zZSgpLHRoaXMub25DbG9zZSgpLHRoaXMuZGlzcG9zZSgpKX1kaXNwb3NlKCl7aWYodGhpcy5wZWVyQ29ubmVjdGlvbj8ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImljZWNvbm5lY3Rpb25zdGF0ZWNoYW5nZVwiLHRoaXMuaGFuZGxlSWNlQ29ubmVjdGlvblN0YXRlQ2hhbmdlKSx0aGlzLnBlZXJDb25uZWN0aW9uPy5yZW1vdmVFdmVudExpc3RlbmVyKFwiY29ubmVjdGlvbnN0YXRlY2hhbmdlXCIsdGhpcy5oYW5kbGVDb25uZWN0aW9uU3RhdGVDaGFuZ2UpLHRoaXMucGVlckNvbm5lY3Rpb24/LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJpY2VjYW5kaWRhdGVcIix0aGlzLmhhbmRsZUxvY2FsSWNlQ2FuZGlkYXRlKSx0aGlzLmRhdGFDaGFubmVscylmb3IoY29uc3QgQSBvZiBPYmplY3QudmFsdWVzKHRoaXMuZGF0YUNoYW5uZWxzKSlBLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsdGhpcy5oYW5kbGVEYXRhQ2hhbm5lbE1lc3NhZ2UpO3RoaXMuZGF0YUNoYW5uZWxzPXZvaWQgMCx0aGlzLnBlZXJDb25uZWN0aW9uPXZvaWQgMCx0aGlzLm9wZW5SZXNvbHZlPXZvaWQgMCx0aGlzLm9wZW5SZWplY3Q9dm9pZCAwfWhhbmRsZUNodW5rKEEsSSl7SS5ncm91cElkPHRoaXMuaGlnaGVzdENodW5rR3JvdXAmJih0aGlzLmNodW5rZWRNZXNzYWdlcz1uZXcgTWFwLHRoaXMuaGlnaGVzdENodW5rR3JvdXA9MCk7bGV0IGc9dGhpcy5jaHVua2VkTWVzc2FnZXMuZ2V0KEkuZ3JvdXBJZCk7aWYoZ3x8KGc9e3JlY2VpdmVkQ2h1bmtDb3VudDowLGNodW5rczpbXX0sdGhpcy5jaHVua2VkTWVzc2FnZXMuc2V0KEkuZ3JvdXBJZCxnKSksZy5jaHVua3NbSS5pbmRleF09SS5kYXRhLGcucmVjZWl2ZWRDaHVua0NvdW50KyssZy5yZWNlaXZlZENodW5rQ291bnQ9PT1JLmNodW5rc0luR3JvdXApe3RoaXMuaGlnaGVzdENodW5rR3JvdXA9SS5ncm91cElkLHRoaXMuY2h1bmtlZE1lc3NhZ2VzLmRlbGV0ZShJLmdyb3VwSWQpO2NvbnN0IEI9ZnVuY3Rpb24oQSl7bGV0IEk9MDtjb25zdCBnPUEuY2h1bmtzLmxlbmd0aDtmb3IobGV0IEI9MDtCPGc7QisrKUkrPUEuY2h1bmtzW0JdLmJ5dGVMZW5ndGg7Y29uc3QgQj1uZXcgVWludDhBcnJheShJKTtsZXQgUT0wO2ZvcihsZXQgST0wO0k8ZztJKyspe2NvbnN0IGc9QS5jaHVua3NbSV07Qi5zZXQoZyxRKSxRKz1nLmJ5dGVMZW5ndGh9cmV0dXJuIEJ9KGcpOy9eUldfKExvZ2ljfElucHV0fEF1ZGlvfFZpZGVvKSQvLnRlc3QoQSk/dGhpcy5oYW5kbGVMYWJlbEFuZERhdGEoQSxCKTp0aGlzLm9uQXBwbGljYXRpb25NZXNzYWdlKEEsQil9fWluZm8oQSl7QkkoREkubmFtZSxTdHJpbmcoQSkpfWRlYnVnKEEpe1FJKERJLm5hbWUsU3RyaW5nKEEpKX13YXJuKEEpe2dJKERJLm5hbWUsU3RyaW5nKEEpKX1waW5nKEEpe2NvbnN0IEk9dGhpcy5zZW5kTG9naWNEYXRhZ3JhbSh7ZGlzY3JpbWluYXRvcjpiQS5kaXNjcmltaW5hdG9yLHZhbHVlOnt9fSk7cmV0dXJuIG5ldyBQcm9taXNlKChCPT57c2V0VGltZW91dCgoKCk9PntnKHRoaXMsaEksXCJmXCIpLmRlbGV0ZShJKSYmQighMSl9KSxBKSxnKHRoaXMsaEksXCJmXCIpLnNldChJLHtyZXNvbHZlOigpPT57Zyh0aGlzLGhJLFwiZlwiKS5kZWxldGUoSSkmJkIoITApfX0pfSkpfWFzeW5jIG1lYXN1cmVMYXRlbmN5TXMoKXtjb25zdCBBPURhdGUubm93KCk7cmV0dXJuIGF3YWl0IHRoaXMucGluZygyZTMpLChEYXRlLm5vdygpLUEpLzJ9fXJJPW5ldyBXZWFrTWFwLGhJPW5ldyBXZWFrTWFwO2NvbnN0IHdJPXtVbmlkZW50aWZpZWQ6Yi5Ob25lLENhbmNlbDpiLkNhbmNlbCxCYWNrc3BhY2U6Yi5CYWNrLFRhYjpiLlRhYixFbnRlcjpiLkVudGVyLFBhdXNlOmIuUGF1c2UsQ2Fwc0xvY2s6Yi5DYXBzTG9jayxIYW5ndWxNb2RlOmIuSGFuZ3VsTW9kZSxLYW5hTW9kZTpiLkhhbmd1bE1vZGUsTGFuZzE6Yi5IYW5ndWxNb2RlLEhhbmphOmIuSGFuamFNb2RlLExhbmcyOmIuSGFuamFNb2RlLEVzY2FwZTpiLkVzY2FwZSxDb252ZXJ0OmIuSW1lQ29udmVydCxOb25Db252ZXJ0OmIuSW1lTm9uQ29udmVydCxTcGFjZTpiLlNwYWNlLFwiIFwiOmIuU3BhY2UsU3BhY2ViYXI6Yi5TcGFjZSxQYWdlVXA6Yi5QYWdlVXAsUGFnZURvd246Yi5QYWdlRG93bixFbmQ6Yi5FbmQsSG9tZTpiLkhvbWUsQXJyb3dMZWZ0OmIuTGVmdCxBcnJvd1VwOmIuVXAsQXJyb3dSaWdodDpiLlJpZ2h0LEFycm93RG93bjpiLkRvd24sU2VsZWN0OmIuU2VsZWN0LFByaW50U2NyZWVuOmIuUHJpbnRTY3JlZW4sSW5zZXJ0OmIuSW5zZXJ0LERlbGV0ZTpiLkRlbGV0ZSxIZWxwOmIuSGVscCxEaWdpdDA6Yi5EMCxEaWdpdDE6Yi5EMSxEaWdpdDI6Yi5EMixEaWdpdDM6Yi5EMyxEaWdpdDQ6Yi5ENCxEaWdpdDU6Yi5ENSxEaWdpdDY6Yi5ENixEaWdpdDc6Yi5ENyxEaWdpdDg6Yi5EOCxEaWdpdDk6Yi5EOSxLZXlBOmIuQSxLZXlCOmIuQixLZXlDOmIuQyxLZXlEOmIuRCxLZXlFOmIuRSxLZXlGOmIuRixLZXlHOmIuRyxLZXlIOmIuSCxLZXlJOmIuSSxLZXlKOmIuSixLZXlLOmIuSyxLZXlMOmIuTCxLZXlNOmIuTSxLZXlOOmIuTixLZXlPOmIuTyxLZXlQOmIuUCxLZXlROmIuUSxLZXlSOmIuUixLZXlTOmIuUyxLZXlUOmIuVCxLZXlVOmIuVSxLZXlWOmIuVixLZXlXOmIuVyxLZXlYOmIuWCxLZXlZOmIuWSxLZXlaOmIuWixNZXRhTGVmdDpiLkxXaW4sT1NMZWZ0OmIuTFdpbixNZXRhUmlnaHQ6Yi5SV2luLE9TUmlnaHQ6Yi5SV2luLENvbnRleHRNZW51OmIuQXBwcyxTbGVlcDpiLlNsZWVwLE51bXBhZDA6Yi5OdW1QYWQwLE51bXBhZDE6Yi5OdW1QYWQxLE51bXBhZDI6Yi5OdW1QYWQyLE51bXBhZDM6Yi5OdW1QYWQzLE51bXBhZDQ6Yi5OdW1QYWQ0LE51bXBhZDU6Yi5OdW1QYWQ1LE51bXBhZDY6Yi5OdW1QYWQ2LE51bXBhZDc6Yi5OdW1QYWQ3LE51bXBhZDg6Yi5OdW1QYWQ4LE51bXBhZDk6Yi5OdW1QYWQ5LE51bXBhZE11bHRpcGx5OmIuTXVsdGlwbHksTnVtcGFkQWRkOmIuQWRkLE51bXBhZENvbW1hOmIuU2VwYXJhdG9yLE51bXBhZFN1YnRyYWN0OmIuU3VidHJhY3QsTnVtcGFkRGVjaW1hbDpiLkRlY2ltYWwsTnVtcGFkRGl2aWRlOmIuRGl2aWRlLEYxOmIuRjEsRjI6Yi5GMixGMzpiLkYzLEY0OmIuRjQsRjU6Yi5GNSxGNjpiLkY2LEY3OmIuRjcsRjg6Yi5GOCxGOTpiLkY5LEYxMDpiLkYxMCxGMTE6Yi5GMTEsRjEyOmIuRjEyLEYxMzpiLkYxMyxGMTQ6Yi5GMTQsRjE1OmIuRjE1LEYxNjpiLkYxNixGMTc6Yi5GMTcsRjE4OmIuRjE4LEYxOTpiLkYxOSxGMjA6Yi5GMjAsRjIxOmIuRjIxLEYyMjpiLkYyMixGMjM6Yi5GMjMsRjI0OmIuRjI0LE51bUxvY2s6Yi5OdW1Mb2NrLFNjcm9sbExvY2s6Yi5TY3JvbGwsU2hpZnRMZWZ0OmIuTGVmdFNoaWZ0LFNoaWZ0UmlnaHQ6Yi5SaWdodFNoaWZ0LENvbnRyb2xMZWZ0OmIuTGVmdEN0cmwsQ29udHJvbFJpZ2h0OmIuUmlnaHRDdHJsLEFsdExlZnQ6Yi5MZWZ0QWx0LEFsdFJpZ2h0OmIuUmlnaHRBbHQsQnJvd3NlckJhY2s6Yi5Ccm93c2VyQmFjayxCcm93c2VyRm9yd2FyZDpiLkJyb3dzZXJGb3J3YXJkLEJyb3dzZXJSZWZyZXNoOmIuQnJvd3NlclJlZnJlc2gsQnJvd3NlclN0b3A6Yi5Ccm93c2VyU3RvcCxCcm93c2VyU2VhcmNoOmIuQnJvd3NlclNlYXJjaCxCcm93c2VyRmF2b3JpdGVzOmIuQnJvd3NlckZhdm9yaXRlcyxCcm93c2VySG9tZTpiLkJyb3dzZXJIb21lLEF1ZGlvVm9sdW1lTXV0ZTpiLlZvbHVtZU11dGUsQXVkaW9Wb2x1bWVEb3duOmIuVm9sdW1lRG93bixBdWRpb1ZvbHVtZVVwOmIuVm9sdW1lVXAsTWVkaWFUcmFja05leHQ6Yi5NZWRpYU5leHRUcmFjayxNZWRpYVRyYWNrUHJldmlvdXM6Yi5NZWRpYVByZXZpb3VzVHJhY2ssTWVkaWFTdG9wOmIuTWVkaWFTdG9wLE1lZGlhUGxheVBhdXNlOmIuTWVkaWFQbGF5UGF1c2UsTGF1bmNoTWFpbDpiLkxhdW5jaE1haWwsTGF1bmNoTWVkaWFQbGF5ZXI6Yi5TZWxlY3RNZWRpYSxNZWRpYVNlbGVjdDpiLlNlbGVjdE1lZGlhLExhdW5jaEFwcDE6Yi5MYXVuY2hBcHBsaWNhdGlvbjEsTGF1bmNoQXBwMjpiLkxhdW5jaEFwcGxpY2F0aW9uMixTZW1pY29sb246Yi5PZW0xLEVxdWFsOmIuT2VtUGx1cyxDb21tYTpiLk9lbUNvbW1hLE1pbnVzOmIuT2VtTWludXMsUGVyaW9kOmIuT2VtUGVyaW9kLFNsYXNoOmIuT2VtMixCYWNrcXVvdGU6Yi5PZW0zLEJyYWNrZXRMZWZ0OmIuT2VtNCxCYWNrc2xhc2g6Yi5PZW01LEJyYWNrZXRSaWdodDpiLk9lbTYsUXVvdGU6Yi5PZW03LEludGxCYWNrc2xhc2g6Yi5PZW0xMDJ9LEZJPXtjbGlja0R1cmF0aW9uTXM6NjAsZHJhZ0RlbGF5TXM6MzAwLHJpZ2h0Q2xpY2tEZWxheU1zOjUwMCx0b3VjaFNsb3BSYWRpdXM6OCxkb3VibGVUYXBXaW5kb3dNczo0MDAsZG91YmxlVGFwUmFkaXVzOjEyLHNjcm9sbEdlc3R1cmVUaHJlc2hvbGRQaXhlbHM6MjAsc2Nyb2xsRXBzaWxvblBpeGVsczo1LHNjcm9sbFNlbnNpdGl2aXR5OjR9O3ZhciBTSSx5SSxHSTtmdW5jdGlvbiBSSShBKXtyZXR1cm4gQT09eUkubGVmdD8xOkE9PXlJLm1pZGRsZT80OkE9PXlJLnJpZ2h0PzI6MH0hZnVuY3Rpb24oQSl7QVtBLmlkbGU9MF09XCJpZGxlXCIsQVtBLm9uZUZpbmdlckRlY2lkaW5nPTFdPVwib25lRmluZ2VyRGVjaWRpbmdcIixBW0EudHdvRmluZ2Vyc0RlY2lkaW5nPTJdPVwidHdvRmluZ2Vyc0RlY2lkaW5nXCIsQVtBLm1vdmluZz0zXT1cIm1vdmluZ1wiLEFbQS5kcmFnZ2luZz00XT1cImRyYWdnaW5nXCIsQVtBLmhvbGRpbmdSaWdodE1vdXNlQnV0dG9uPTVdPVwiaG9sZGluZ1JpZ2h0TW91c2VCdXR0b25cIixBW0Euem9vbWluZz02XT1cInpvb21pbmdcIixBW0Euc2Nyb2xsaW5nPTddPVwic2Nyb2xsaW5nXCJ9KFNJfHwoU0k9e30pKSxmdW5jdGlvbihBKXtBW0EubGVmdD0wXT1cImxlZnRcIixBW0EubWlkZGxlPTFdPVwibWlkZGxlXCIsQVtBLnJpZ2h0PTJdPVwicmlnaHRcIn0oeUl8fCh5ST17fSkpLGZ1bmN0aW9uKEEpe0FbQS5waXhlbHM9MF09XCJwaXhlbHNcIixBW0EubGluZXM9MV09XCJsaW5lc1wiLEFbQS5wYWdlcz0yXT1cInBhZ2VzXCJ9KEdJfHwoR0k9e30pKTtjbGFzcyB1SXtjb25zdHJ1Y3RvcihBLEksZz1GSSl7dGhpcy5yZXBvcnRQb2ludGVyRXZlbnQ9QSx0aGlzLnJlcG9ydFdoZWVsRXZlbnQ9SSx0aGlzLnBhcmFtZXRlcnM9Zyx0aGlzLnN0YXRlPVNJLmlkbGUsdGhpcy5wcmltYXJ5PXZvaWQgMCx0aGlzLnNlY29uZGFyeT12b2lkIDAsdGhpcy5jZW50cm9pZFk9MCx0aGlzLmxhc3RUYXBUaW1lPW5ldyBEYXRlLHRoaXMucmlnaHRDbGlja1RpbWVyPXZvaWQgMCx0aGlzLnJpZ2h0Q2xpY2s9KCk9Pnt0aGlzLnJlcG9ydE1vdXNlRG93bih5SS5yaWdodCksdGhpcy50b1N0YXRlKFNJLmhvbGRpbmdSaWdodE1vdXNlQnV0dG9uKSx0aGlzLnJpZ2h0Q2xpY2tUaW1lcj12b2lkIDB9LHRoaXMudGFwUmVsZWFzZVRpbWVyPXZvaWQgMCx0aGlzLnRhcFJlbGVhc2U9KCk9Pnt0aGlzLnJlcG9ydE1vdXNlVXAoeUkubGVmdCksdGhpcy50b1N0YXRlKFNJLmlkbGUpLHRoaXMucmlnaHRDbGlja1RpbWVyPXZvaWQgMH0sdGhpcy5vblBvaW50ZXJEb3duPUE9Pntjb25zdCBJPXtwb2ludGVySWQ6QS5wb2ludGVySWQsaG9tZU9mZnNldFg6QS5vZmZzZXRYLGhvbWVPZmZzZXRZOkEub2Zmc2V0WSxjdXJyZW50T2Zmc2V0WDpBLm9mZnNldFgsY3VycmVudE9mZnNldFk6QS5vZmZzZXRZLGRvd25UaW1lOm5ldyBEYXRlLGF3YWtlOiExfTt2b2lkIDA9PT10aGlzLnByaW1hcnk/KHRoaXMudG9TdGF0ZShTSS5vbmVGaW5nZXJEZWNpZGluZyksdGhpcy5wcmltYXJ5PUksd2luZG93LmNsZWFyVGltZW91dCh0aGlzLnJpZ2h0Q2xpY2tUaW1lciksdGhpcy5yaWdodENsaWNrVGltZXI9d2luZG93LnNldFRpbWVvdXQodGhpcy5yaWdodENsaWNrLHRoaXMucGFyYW1ldGVycy5yaWdodENsaWNrRGVsYXlNcykpOnZvaWQgMD09PXRoaXMuc2Vjb25kYXJ5JiYodGhpcy50b1N0YXRlKFNJLnR3b0ZpbmdlcnNEZWNpZGluZyksdGhpcy5zZWNvbmRhcnk9SSx3aW5kb3cuY2xlYXJUaW1lb3V0KHRoaXMucmlnaHRDbGlja1RpbWVyKSl9LHRoaXMub25Qb2ludGVyVXA9QT0+e3dpbmRvdy5jbGVhclRpbWVvdXQodGhpcy5yaWdodENsaWNrVGltZXIpO2NvbnN0IEk9QS5wb2ludGVySWQ9PT10aGlzLnByaW1hcnk/LnBvaW50ZXJJZDtpZih0aGlzLnN0YXRlPT09U0kub25lRmluZ2VyRGVjaWRpbmcmJkkpe3RoaXMubG9nKFwicG9pbnRlciB1cCBmcm9tIGRlY2lkaW5nLCB0YXBwaW5nXCIpLHdpbmRvdy5jbGVhclRpbWVvdXQodGhpcy5yaWdodENsaWNrVGltZXIpO2NvbnN0IEk9ey4uLkEsb2Zmc2V0WDpBLm9mZnNldFgsb2Zmc2V0WTpBLm9mZnNldFkscG9pbnRlclR5cGU6XCJ0b3VjaFwiLHR5cGU6XCJwb2ludGVybW92ZVwifTt0aGlzLnJlcG9ydFBvaW50ZXJFdmVudChJKSx0aGlzLnJlcG9ydE1vdXNlRG93bih5SS5sZWZ0KSx0aGlzLnByaW1hcnk9dm9pZCAwLHRoaXMubGFzdFRhcFRpbWU9bmV3IERhdGUsdGhpcy50YXBSZWxlYXNlVGltZXI9d2luZG93LnNldFRpbWVvdXQodGhpcy50YXBSZWxlYXNlLHRoaXMucGFyYW1ldGVycy5jbGlja0R1cmF0aW9uTXMpfWVsc2UgdGhpcy5wcmltYXJ5JiZ0aGlzLnNlY29uZGFyeT8odGhpcy5sb2coXCJzdG9wcGluZyB0d28gZmluZ2VyIGdlc3R1cmVcIiksdGhpcy5wcmltYXJ5PXZvaWQgMCx0aGlzLnNlY29uZGFyeT12b2lkIDAsdGhpcy50b1N0YXRlKFNJLmlkbGUpKTp0aGlzLnN0YXRlPT09U0kubW92aW5nJiZJPyh0aGlzLmxvZyhcInN0b3AgbW92aW5nXCIpLHRoaXMucHJpbWFyeT12b2lkIDAsdGhpcy50b1N0YXRlKFNJLmlkbGUpKTp0aGlzLnN0YXRlPT09U0kuZHJhZ2dpbmcmJkk/KHRoaXMubG9nKFwic3RvcCBkcmFnZ2luZ1wiKSx0aGlzLnJlcG9ydE1vdXNlVXAoeUkubGVmdCksdGhpcy5wcmltYXJ5PXZvaWQgMCx0aGlzLnRvU3RhdGUoU0kuaWRsZSkpOnRoaXMuc3RhdGU9PT1TSS5ob2xkaW5nUmlnaHRNb3VzZUJ1dHRvbiYmSSYmKHRoaXMubG9nKFwic3RvcCByaWdodCBjbGlja1wiKSx0aGlzLnJlcG9ydE1vdXNlVXAoeUkucmlnaHQpLHRoaXMucHJpbWFyeT12b2lkIDAsdGhpcy50b1N0YXRlKFNJLmlkbGUpKX0sdGhpcy5vblBvaW50ZXJNb3ZlPUE9Pntjb25zdCBJPUEucG9pbnRlcklkPT09dGhpcy5wcmltYXJ5Py5wb2ludGVySWQsZz1BLnBvaW50ZXJJZD09PXRoaXMuc2Vjb25kYXJ5Py5wb2ludGVySWQ7aWYodGhpcy5wcmltYXJ5JiZJPyh0aGlzLnByaW1hcnkuY3VycmVudE9mZnNldFg9QS5vZmZzZXRYLHRoaXMucHJpbWFyeS5jdXJyZW50T2Zmc2V0WT1BLm9mZnNldFkpOnRoaXMuc2Vjb25kYXJ5JiZnJiYodGhpcy5zZWNvbmRhcnkuY3VycmVudE9mZnNldFg9QS5vZmZzZXRYLHRoaXMuc2Vjb25kYXJ5LmN1cnJlbnRPZmZzZXRZPUEub2Zmc2V0WSksdGhpcy5wcmltYXJ5JiZJJiYhdGhpcy5zZWNvbmRhcnkpaWYodGhpcy5zdGF0ZT09PVNJLm9uZUZpbmdlckRlY2lkaW5nJiZmdW5jdGlvbihBLEkpe2NvbnN0IGc9QS5jdXJyZW50T2Zmc2V0WC1BLmhvbWVPZmZzZXRYLEI9QS5jdXJyZW50T2Zmc2V0WS1BLmhvbWVPZmZzZXRZO3JldHVybiBnKmcrQipCPkkqSX0odGhpcy5wcmltYXJ5LHRoaXMucGFyYW1ldGVycy50b3VjaFNsb3BSYWRpdXMpKXt0aGlzLmxvZyhcImxlZnQgdG91Y2ggc2xvcCByYWRpdXNcIiksd2luZG93LmNsZWFyVGltZW91dCh0aGlzLnJpZ2h0Q2xpY2tUaW1lciksdGhpcy5wcmltYXJ5LmF3YWtlPSEwOyhuZXcgRGF0ZSkudmFsdWVPZigpLXRoaXMubGFzdFRhcFRpbWUudmFsdWVPZigpPHRoaXMucGFyYW1ldGVycy5kcmFnRGVsYXlNcz8odGhpcy5yZXBvcnRNb3VzZURvd24oeUkubGVmdCksdGhpcy50b1N0YXRlKFNJLmRyYWdnaW5nKSk6dGhpcy50b1N0YXRlKFNJLm1vdmluZyl9ZWxzZSB0aGlzLnN0YXRlIT09U0kuZHJhZ2dpbmcmJnRoaXMuc3RhdGUhPT1TSS5tb3ZpbmcmJnRoaXMuc3RhdGUhPT1TSS5ob2xkaW5nUmlnaHRNb3VzZUJ1dHRvbnx8dGhpcy5yZXBvcnRQb2ludGVyRXZlbnQoQSk7ZWxzZSBpZih0aGlzLnByaW1hcnkmJnRoaXMuc2Vjb25kYXJ5KWlmKHRoaXMuc3RhdGU9PT1TSS50d29GaW5nZXJzRGVjaWRpbmcpe2NvbnN0IEE9dGhpcy5wcmltYXJ5LmN1cnJlbnRPZmZzZXRZLXRoaXMucHJpbWFyeS5ob21lT2Zmc2V0WSxJPXRoaXMuc2Vjb25kYXJ5LmN1cnJlbnRPZmZzZXRZLXRoaXMuc2Vjb25kYXJ5LmhvbWVPZmZzZXRZLGc9dGhpcy5wYXJhbWV0ZXJzLnNjcm9sbEdlc3R1cmVUaHJlc2hvbGRQaXhlbHM7KEE+ZyYmST5nfHxBPGcmJkk8ZykmJih0aGlzLnRvU3RhdGUoU0kuc2Nyb2xsaW5nKSx0aGlzLmNlbnRyb2lkWT0oQStJKS8yKX1lbHNlIGlmKHRoaXMuc3RhdGU9PT1TSS5zY3JvbGxpbmcpe2NvbnN0IEE9dGhpcy5wYXJhbWV0ZXJzLnNjcm9sbEVwc2lsb25QaXhlbHMsST0odGhpcy5wcmltYXJ5LmN1cnJlbnRPZmZzZXRZLXRoaXMucHJpbWFyeS5ob21lT2Zmc2V0WSsodGhpcy5zZWNvbmRhcnkuY3VycmVudE9mZnNldFktdGhpcy5zZWNvbmRhcnkuaG9tZU9mZnNldFkpKS8yO0k+dGhpcy5jZW50cm9pZFkrQT8odGhpcy5yZXBvcnRTY3JvbGwodGhpcy5wYXJhbWV0ZXJzLnNjcm9sbFNlbnNpdGl2aXR5KkEpLHRoaXMuY2VudHJvaWRZPUkpOkk8dGhpcy5jZW50cm9pZFktQSYmKHRoaXMucmVwb3J0U2Nyb2xsKHRoaXMucGFyYW1ldGVycy5zY3JvbGxTZW5zaXRpdml0eSotQSksdGhpcy5jZW50cm9pZFk9SSl9fX1sb2coLi4uQSl7fXJlcG9ydE1vdXNlVXAoQSl7dGhpcy5sb2coXCItLVxceDNlIHJlcG9ydCBwb2ludGVydXBcIixBKTtjb25zdCBJPW5ldyBQb2ludGVyRXZlbnQoXCJwb2ludGVydXBcIix7cG9pbnRlclR5cGU6XCJtb3VzZVwiLGJ1dHRvbnM6MCxidXR0b246QX0pO3RoaXMucmVwb3J0UG9pbnRlckV2ZW50KEkpfXJlcG9ydE1vdXNlRG93bihBKXt0aGlzLmxvZyhcIi0tXFx4M2UgcmVwb3J0IHBvaW50ZXJkb3duXCIsQSk7Y29uc3QgST1uZXcgUG9pbnRlckV2ZW50KFwicG9pbnRlcmRvd25cIix7cG9pbnRlclR5cGU6XCJtb3VzZVwiLGJ1dHRvbnM6UkkoQSksYnV0dG9uOkF9KTt0aGlzLnJlcG9ydFBvaW50ZXJFdmVudChJKX1yZXBvcnRTY3JvbGwoQSl7Y29uc3QgST1uZXcgV2hlZWxFdmVudChcInN5bnRoZXRpY1doZWVsXCIse2RlbHRhWTpBLGRlbHRhTW9kZTpHSS5waXhlbHN9KTt0aGlzLnJlcG9ydFdoZWVsRXZlbnQoSSl9dG9TdGF0ZShBKXt0aGlzLmxvZyhbXCJpZGxlXCIsXCJvbmVGaW5nZXJEZWNpZGluZ1wiLFwidHdvRmluZ2Vyc0RlY2lkaW5nXCIsXCJtb3ZpbmdcIixcImRyYWdnaW5nXCIsXCJob2xkaW5nUmlnaHRNb3VzZUJ1dHRvblwiLFwiem9vbWluZ1wiLFwic2Nyb2xsaW5nXCJdW0FdKSx0aGlzLnN0YXRlPUF9cHJvY2Vzc1BvaW50ZXJFdmVudChBKXtpZihcInRvdWNoXCI9PT1BLnBvaW50ZXJUeXBlKXN3aXRjaChBLnR5cGUpe2Nhc2VcInBvaW50ZXJkb3duXCI6dGhpcy5vblBvaW50ZXJEb3duKEEpO2JyZWFrO2Nhc2VcInBvaW50ZXJ1cFwiOnRoaXMub25Qb2ludGVyVXAoQSk7YnJlYWs7Y2FzZVwicG9pbnRlcnJhd3VwZGF0ZVwiOmNhc2VcInBvaW50ZXJtb3ZlXCI6dGhpcy5vblBvaW50ZXJNb3ZlKEEpfWVsc2UgdGhpcy5yZXBvcnRQb2ludGVyRXZlbnQoQSl9fWNsYXNzIGxJe2NvbnN0cnVjdG9yKEEsSSxnLEI9MTAwKXt0aGlzLmNvcnJlY3RSZW1vdGVDdXJzb3I9QSx0aGlzLnRyYW5zZm9ybVBvaW50ZXJPZmZzZXRUb1JlbW90ZT1JLHRoaXMuZ2V0Q3VycmVudEZyYW1lU2l6ZT1nLHRoaXMuY3Vyc29yU3luY0ludGVydmFsPUIsdGhpcy5jb250YWluZXI9dm9pZCAwLHRoaXMudmlkZW89dm9pZCAwLHRoaXMuY2FudmFzPXZvaWQgMCx0aGlzLmN1cnNvckRpdj12b2lkIDAsdGhpcy5jdXJzb3JJbWc9dm9pZCAwLHRoaXMuY3Vyc29yU3RhdGU9e3Zpc2libGU6ITEseDowLHk6MCxzcG90WDowLHNwb3RZOjAsZXh0ZW50V2lkdGg6MCxleHRlbnRIZWlnaHQ6MH0sdGhpcy53YW50c1JlbW90ZVBvc2l0aW9uPSEwLHRoaXMudmlkZW9SZWN0PW5ldyBET01SZWN0KDAsMCwwLDApLHRoaXMud2luZG93V2lkdGg9dm9pZCAwLHRoaXMud2luZG93SGVpZ2h0PXZvaWQgMCx0aGlzLmRyYXdEZWJ1Z0RvdD0hMSx0aGlzLmRlYnVnRG90PXZvaWQgMCx0aGlzLmNhbkNvbnRyb2xNb3VzZT0hMSx0aGlzLnNldFZpZGVvRGltZW5zaW9ucz0oKT0+e2Zvcihjb25zdCBBIG9mW3RoaXMudmlkZW8sdGhpcy5jYW52YXNdKXtpZighQSljb250aW51ZTtjb25zdCBJPUEuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7aWYoSS53aWR0aD4wJiZJLmhlaWdodD4wKXJldHVybiB0aGlzLnZpZGVvUmVjdD1JLHZvaWQgdGhpcy5hcHBseUN1cnNvckRpdlRyYW5zZm9ybSgpfX0sdGhpcy5jdXJzb3JTeW5jQ291bnRlcj10aGlzLmN1cnNvclN5bmNJbnRlcnZhbCx0aGlzLnZpZGVvUmVzaXplT2JzZXJ2ZXI9bmV3IFJlc2l6ZU9ic2VydmVyKCgoKT0+e3RoaXMuc2V0VmlkZW9EaW1lbnNpb25zKCl9KSksW1wid2Via2l0ZnVsbHNjcmVlbmNoYW5nZVwiLFwibW96ZnVsbHNjcmVlbmNoYW5nZVwiLFwiZnVsbHNjcmVlbmNoYW5nZVwiLFwiTVNGdWxsc2NyZWVuQ2hhbmdlXCJdLmZvckVhY2goKEE9Pntkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKEEsdGhpcy5zZXRWaWRlb0RpbWVuc2lvbnMsITEpfSkpLHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwicmVzaXplXCIsdGhpcy5zZXRXaW5kb3dEaW1lbnNpb25zKX1kZXRhY2goKXtbXCJ3ZWJraXRmdWxsc2NyZWVuY2hhbmdlXCIsXCJtb3pmdWxsc2NyZWVuY2hhbmdlXCIsXCJmdWxsc2NyZWVuY2hhbmdlXCIsXCJNU0Z1bGxzY3JlZW5DaGFuZ2VcIl0uZm9yRWFjaCgoQT0+e2RvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoQSx0aGlzLnNldFZpZGVvRGltZW5zaW9ucywhMSl9KSksd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIix0aGlzLnNldFdpbmRvd0RpbWVuc2lvbnMpLHRoaXMudmlkZW9SZXNpemVPYnNlcnZlci5kaXNjb25uZWN0KCl9c2V0Q2FuQ29udHJvbE1vdXNlKEEpe3RoaXMuY2FuQ29udHJvbE1vdXNlPUF9c2V0V2luZG93RGltZW5zaW9ucygpe3RoaXMud2luZG93V2lkdGg9d2luZG93LmlubmVyV2lkdGgsdGhpcy53aW5kb3dIZWlnaHQ9d2luZG93LmlubmVySGVpZ2h0fXNldENvbnRhaW5lcihBKXt0aGlzLmNvbnRhaW5lcj1BLEEuc3R5bGUub3ZlcmZsb3c9XCJoaWRkZW5cIix0aGlzLnZpZGVvJiZ0aGlzLnZpZGVvUmVzaXplT2JzZXJ2ZXIudW5vYnNlcnZlKHRoaXMudmlkZW8pLHRoaXMuY2FudmFzJiZ0aGlzLnZpZGVvUmVzaXplT2JzZXJ2ZXIudW5vYnNlcnZlKHRoaXMuY2FudmFzKSx0aGlzLmN1cnNvckRpdj12b2lkIDA7Y29uc3QgST1BLmNoaWxkTm9kZXM7Zm9yKGxldCBBPTA7QTxJLmxlbmd0aDtBKyspe2NvbnN0IGc9SVtBXTtnIGluc3RhbmNlb2YgSFRNTFZpZGVvRWxlbWVudD8odGhpcy52aWRlbz1nLHRoaXMuc2V0VmlkZW9EaW1lbnNpb25zKCksdGhpcy52aWRlb1Jlc2l6ZU9ic2VydmVyLm9ic2VydmUodGhpcy52aWRlbykpOmcgaW5zdGFuY2VvZiBIVE1MQ2FudmFzRWxlbWVudCYmKGcuY2xhc3NMaXN0LmNvbnRhaW5zKFwicmFpbndheS1jYW52YXNcIil8fGcuY2xhc3NMaXN0LmNvbnRhaW5zKFwicmFpbndheS1pc29sYXRpb24tY2FudmFzXCIpKT8odGhpcy5jYW52YXM9Zyx0aGlzLnNldFZpZGVvRGltZW5zaW9ucygpLHRoaXMudmlkZW9SZXNpemVPYnNlcnZlci5vYnNlcnZlKHRoaXMuY2FudmFzKSk6ZyBpbnN0YW5jZW9mIEhUTUxEaXZFbGVtZW50JiYoZy5jbGFzc05hbWUuaW5jbHVkZXMoXCJyYWlud2F5LWN1cnNvclwiKT90aGlzLmN1cnNvckRpdj1nOmcuY2xhc3NOYW1lLmluY2x1ZGVzKFwicmFpbndheS1kZWJ1Zy1kb3RcIikmJih0aGlzLmRlYnVnRG90PWcpKX10aGlzLmN1cnNvckRpdnx8KHRoaXMuY3Vyc29yRGl2PWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiksdGhpcy5jdXJzb3JEaXYuY2xhc3NOYW1lPVwicmFpbndheS1jdXJzb3JcIix0aGlzLmN1cnNvckRpdi5zdHlsZS5wb3NpdGlvbj1cImFic29sdXRlXCIsdGhpcy5jdXJzb3JEaXYuc3R5bGUudG9wPVwiMHB4XCIsdGhpcy5jdXJzb3JEaXYuc3R5bGUubGVmdD1cIjBweFwiLHRoaXMuY3Vyc29yRGl2LnN0eWxlLnpJbmRleD1cIjFcIix0aGlzLmN1cnNvckRpdi5zdHlsZS5wb2ludGVyRXZlbnRzPVwibm9uZVwiLHRoaXMuY3Vyc29yRGl2LnN0eWxlLndpbGxDaGFuZ2U9XCJ0cmFuc2Zvcm1cIix0aGlzLmN1cnNvckRpdi5zdHlsZS50cmFuc2Zvcm1PcmlnaW49XCJ0b3AgbGVmdFwiLHRoaXMuYXBwbHlDdXJzb3JEaXZUcmFuc2Zvcm0oKSx0aGlzLmN1cnNvckltZz1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW1nXCIpLHRoaXMuY3Vyc29yRGl2LmFwcGVuZENoaWxkKHRoaXMuY3Vyc29ySW1nKSxBLmFwcGVuZENoaWxkKHRoaXMuY3Vyc29yRGl2KSksdGhpcy5kcmF3RGVidWdEb3QmJiF0aGlzLmRlYnVnRG90JiYodGhpcy5kZWJ1Z0RvdD1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpLHRoaXMuZGVidWdEb3QuY2xhc3NOYW1lPVwicmFpbndheS1kZWJ1Zy1kb3RcIix0aGlzLmRlYnVnRG90LnN0eWxlLnBvc2l0aW9uPVwiYWJzb2x1dGVcIix0aGlzLmRlYnVnRG90LnN0eWxlLnRvcD1cIjBweFwiLHRoaXMuZGVidWdEb3Quc3R5bGUubGVmdD1cIjBweFwiLHRoaXMuZGVidWdEb3Quc3R5bGUuekluZGV4PVwiMVwiLHRoaXMuZGVidWdEb3Quc3R5bGUucG9pbnRlckV2ZW50cz1cIm5vbmVcIix0aGlzLmRlYnVnRG90LnN0eWxlLndpbGxDaGFuZ2U9XCJ0cmFuc2Zvcm1cIix0aGlzLmRlYnVnRG90LnN0eWxlLnRyYW5zZm9ybU9yaWdpbj1cInRvcCBsZWZ0XCIsdGhpcy5kZWJ1Z0RvdC5zdHlsZS53aWR0aD1cIjNweFwiLHRoaXMuZGVidWdEb3Quc3R5bGUuaGVpZ2h0PVwiM3B4XCIsdGhpcy5kZWJ1Z0RvdC5zdHlsZS5iYWNrZ3JvdW5kQ29sb3I9XCIjZmYwMDAwXCIsQS5hcHBlbmRDaGlsZCh0aGlzLmRlYnVnRG90KSl9dW5zZXRDb250YWluZXIoKXt0aGlzLmRldGFjaCgpLHRoaXMuY3Vyc29yRGl2Py5yZW1vdmUoKSx0aGlzLmRlYnVnRG90Py5yZW1vdmUoKSx0aGlzLmNvbnRhaW5lcj12b2lkIDB9Y29tcHV0ZVRyYW5zZm9ybShBKXtjb25zdHt4OkkseTpnLHNwb3RYOkIsc3BvdFk6UX09QSxDPXtsZWZ0OjAsdG9wOjAsd2lkdGg6QS5leHRlbnRXaWR0aCxoZWlnaHQ6QS5leHRlbnRIZWlnaHR9LHt3aWR0aDplLGhlaWdodDppfT10aGlzLnZpZGVvUmVjdCx0PXRoaXMuZ2V0Q3VycmVudEZyYW1lU2l6ZSgpLEU9dC5jb2RlY1dpZHRoLG89dC5jb2RlY0hlaWdodCxhPXQuc3RyZWFtQm91bmRzPz9DLHM9dC5mdWxsRGVza3RvcEJvdW5kcz8/Qyx7bGVmdDpuLHRvcDpyLHdpZHRoOmgsaGVpZ2h0OmR9PXMse2xlZnQ6Yyx0b3A6RCx3aWR0aDp3LGhlaWdodDpGfT1hLFM9dypFL2gseT1GKm8vZCxHPU1hdGgubWluKGUvUyxpL3kpLFI9TWF0aC5yb3VuZChJLUItKGMtbikpLHU9TWF0aC5yb3VuZChnLVEtKEQtcikpLGw9RypFL2gsaz1HKm8vZDtyZXR1cm5gdHJhbnNsYXRlKCR7TWF0aC5yb3VuZCgoZS1HKlMpLzIpfXB4LCR7TWF0aC5yb3VuZCgoaS1HKnkpLzIpfXB4KSBzY2FsZSgke2x9LCR7a30pIHRyYW5zbGF0ZSgke1J9cHgsJHt1fXB4KWB9YXBwbHlDdXJzb3JEaXZUcmFuc2Zvcm0oKXt0aGlzLmN1cnNvckRpdiYmKHRoaXMuY3Vyc29yU3RhdGUudmlzaWJsZT8odGhpcy5jdXJzb3JEaXYuc3R5bGUudmlzaWJpbGl0eT1cInZpc2libGVcIix0aGlzLmN1cnNvckRpdi5zdHlsZS50cmFuc2Zvcm09dGhpcy5jb21wdXRlVHJhbnNmb3JtKHRoaXMuY3Vyc29yU3RhdGUpKTp0aGlzLmN1cnNvckRpdi5zdHlsZS52aXNpYmlsaXR5PVwiaGlkZGVuXCIpfW1vdmVEZWJ1Z0RvdFRvKEEpe3RoaXMuZGVidWdEb3QmJih0aGlzLmRlYnVnRG90LnN0eWxlLnRyYW5zZm9ybT10aGlzLmNvbXB1dGVUcmFuc2Zvcm0oQSkpfXByb2Nlc3NDdXJzb3IoQSl7aWYoIXRoaXMuY3Vyc29yRGl2KXJldHVybjtjb25zdCBJPXRoaXMuY2FuQ29udHJvbE1vdXNlJiYoXCJvbnBvaW50ZXJsb2NrY2hhbmdlXCJpbiBkb2N1bWVudD9kb2N1bWVudC5wb2ludGVyTG9ja0VsZW1lbnQ6ZG9jdW1lbnQuYWN0aXZlRWxlbWVudCk9PT10aGlzLmNvbnRhaW5lcjtpZighQS52aXNpYmxlfHx0aGlzLmN1cnNvclN0YXRlLnZpc2libGUmJkl8fCh0aGlzLndhbnRzUmVtb3RlUG9zaXRpb249ITApLHRoaXMuY3Vyc29yU3RhdGUudmlzaWJsZT1BLnZpc2libGUsdGhpcy5jdXJzb3JTdGF0ZS5zcG90WD1BLnNwb3RYLHRoaXMuY3Vyc29yU3RhdGUuc3BvdFk9QS5zcG90WSx0aGlzLmN1cnNvclN0YXRlLmV4dGVudFdpZHRoPUEuZXh0ZW50V2lkdGgsdGhpcy5jdXJzb3JTdGF0ZS5leHRlbnRIZWlnaHQ9QS5leHRlbnRIZWlnaHQsdGhpcy5kcmF3RGVidWdEb3QmJnRoaXMubW92ZURlYnVnRG90VG8oQSksdGhpcy5jdXJzb3JTdGF0ZS52aXNpYmxlKXtpZih0aGlzLndhbnRzUmVtb3RlUG9zaXRpb24/KHRoaXMuY3Vyc29yU3RhdGUueD1BLngsdGhpcy5jdXJzb3JTdGF0ZS55PUEueSx0aGlzLndhbnRzUmVtb3RlUG9zaXRpb249ITEsdGhpcy5jdXJzb3JTeW5jQ291bnRlcj10aGlzLmN1cnNvclN5bmNJbnRlcnZhbCk6MD09LS10aGlzLmN1cnNvclN5bmNDb3VudGVyJiYodGhpcy5jb3JyZWN0UmVtb3RlQ3Vyc29yKHRoaXMuY3Vyc29yU3RhdGUueCx0aGlzLmN1cnNvclN0YXRlLnkpLHRoaXMuY3Vyc29yU3luY0NvdW50ZXI9dGhpcy5jdXJzb3JTeW5jSW50ZXJ2YWwpLHRoaXMuY3Vyc29yRGl2LnN0eWxlLndpZHRoPWAke0Euc2hhcGVXaWR0aH1weGAsdGhpcy5jdXJzb3JEaXYuc3R5bGUuaGVpZ2h0PWAke0Euc2hhcGVIZWlnaHR9cHhgLEEuaGFzUG9pbnRlckltYWdlJiZ0aGlzLmN1cnNvckltZyl7Y29uc3QgST1mdW5jdGlvbihBKXtsZXQgST1cIlwiO2NvbnN0IGc9bmV3IFVpbnQ4QXJyYXkoQSksQj1nLmJ5dGVMZW5ndGg7Zm9yKGxldCBBPTA7QTxCO0ErKylJKz1TdHJpbmcuZnJvbUNoYXJDb2RlKGdbQV0pO3JldHVybiB3aW5kb3cuYnRvYShJKX0oQS5wb2ludGVySW1hZ2UpO3RoaXMuY3Vyc29ySW1nLnNyYz1gZGF0YTppbWFnZS9wbmc7YmFzZTY0LCR7SX1gfXRoaXMuYXBwbHlDdXJzb3JEaXZUcmFuc2Zvcm0oKX1lbHNlIHRoaXMuY3Vyc29yRGl2LnN0eWxlLnZpc2liaWxpdHk9XCJoaWRkZW5cIn11cGRhdGUoQSxJLGcpe2lmKCF0aGlzLmN1cnNvckRpdilyZXR1cm47aWYoXCJwb2ludGVybW92ZVwiIT09QS50eXBlJiZcIm1vdXNlbW92ZVwiIT09QS50eXBlKXJldHVybjtpZihcIm1vdXNlXCIhPT0oQS5wb2ludGVyVHlwZT8/XCJtb3VzZVwiKSl7Y29uc3QgQT10aGlzLnRyYW5zZm9ybVBvaW50ZXJPZmZzZXRUb1JlbW90ZShJLGcpO0EmJih0aGlzLmN1cnNvclN0YXRlLng9QS54LHRoaXMuY3Vyc29yU3RhdGUueT1BLnkpfWVsc2V7Y29uc3QgST10aGlzLmN1cnNvclN0YXRlLGc9QS5tb3ZlbWVudFgsQj1BLm1vdmVtZW50WSxRPXRoaXMuZ2V0Q3VycmVudEZyYW1lU2l6ZSgpO2lmKFEuc3RyZWFtQm91bmRzKXtjb25zdHt0b3A6QSxsZWZ0OkMsaGVpZ2h0OmUsd2lkdGg6aX09US5zdHJlYW1Cb3VuZHM7dGhpcy5jdXJzb3JTdGF0ZS54PU1hdGgubWF4KEMsTWF0aC5taW4oSS54K2csQytpKSksdGhpcy5jdXJzb3JTdGF0ZS55PU1hdGgubWF4KEEsTWF0aC5taW4oSS55K0IsQStlKSl9ZWxzZSBjb25zb2xlLndhcm4oXCJEb24ndCBoYXZlIHN0cmVhbUJvdW5kcyBpbiBDdXJzb3JQYWludGVyLnVwZGF0ZT9cIiksdGhpcy5jdXJzb3JTdGF0ZS54PU1hdGgubWF4KDAsTWF0aC5taW4oSS54K2csSS5leHRlbnRXaWR0aCkpLHRoaXMuY3Vyc29yU3RhdGUueT1NYXRoLm1heCgwLE1hdGgubWluKEkueStCLEkuZXh0ZW50SGVpZ2h0KSl9dGhpcy5hcHBseUN1cnNvckRpdlRyYW5zZm9ybSgpfX1jb25zdCBrST0vTWFjaW50b3NoOy4qU2FmYXJpLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpJiYhL0Nocm9tZXxBbmRyb2lkL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTt2YXIgVUksTkksbUk7IWZ1bmN0aW9uKEEpe0FbQS5HYW1lcGFkPTBdPVwiR2FtZXBhZFwiLEFbQS5Nb3VzZUFic29sdXRlPTFdPVwiTW91c2VBYnNvbHV0ZVwiLEFbQS5Nb3VzZVJlbGF0aXZlPTJdPVwiTW91c2VSZWxhdGl2ZVwiLEFbQS5Nb3VzZUNsaWNrPTNdPVwiTW91c2VDbGlja1wiLEFbQS5Nb3VzZVNjcm9sbD00XT1cIk1vdXNlU2Nyb2xsXCIsQVtBLktleWJvYXJkPTVdPVwiS2V5Ym9hcmRcIixBW0EuUGFzdGVUZXh0PTZdPVwiUGFzdGVUZXh0XCIsQVtBLlRvdWNoZXNBYnNvbHV0ZT03XT1cIlRvdWNoZXNBYnNvbHV0ZVwiLEFbQS5QZW5BYnNvbHV0ZT04XT1cIlBlbkFic29sdXRlXCIsQVtBLlZpZXdwb3J0UmVzaXplPTldPVwiVmlld3BvcnRSZXNpemVcIixBW0EuU2V0Q2xpcGJvYXJkVGV4dD0xMF09XCJTZXRDbGlwYm9hcmRUZXh0XCJ9KFVJfHwoVUk9e30pKTtjbGFzcyBNSXtjb25zdHJ1Y3RvcihBKXt0aGlzLmhlbGRLZXlzPUF9Z2V0IGtleXMoKXtyZXR1cm4gdGhpcy5oZWxkS2V5c31oYXMoQSl7cmV0dXJuIHRoaXMuaGVsZEtleXMuaGFzKEEpfWdldCBjdHJsKCl7cmV0dXJuIHRoaXMuaGVsZEtleXMuaGFzKGIuTGVmdEN0cmwpfHx0aGlzLmhlbGRLZXlzLmhhcyhiLlJpZ2h0Q3RybCl9Z2V0IGFsdCgpe3JldHVybiB0aGlzLmhlbGRLZXlzLmhhcyhiLkxlZnRBbHQpfHx0aGlzLmhlbGRLZXlzLmhhcyhiLlJpZ2h0QWx0KX1nZXQgd2luKCl7cmV0dXJuIHRoaXMuaGVsZEtleXMuaGFzKGIuTFdpbil8fHRoaXMuaGVsZEtleXMuaGFzKGIuUldpbil9Z2V0IHNoaWZ0KCl7cmV0dXJuIHRoaXMuaGVsZEtleXMuaGFzKGIuTGVmdFNoaWZ0KXx8dGhpcy5oZWxkS2V5cy5oYXMoYi5SaWdodFNoaWZ0KX19ZnVuY3Rpb24gTEkoQSl7cmV0dXJuIEEuYXhlcy5sZW5ndGg+PTQmJkEuYnV0dG9ucy5sZW5ndGg+PTE2fWZ1bmN0aW9uIGZJKEEsSSl7aWYoQT09PUkpcmV0dXJuITA7aWYoQS5sZW5ndGghPT1JLmxlbmd0aClyZXR1cm4hMTtmb3IobGV0IGc9MDtnPEEubGVuZ3RoOysrZylpZihBW2ddIT09SVtnXSlyZXR1cm4hMTtyZXR1cm4hMH1jbGFzcyBwSXtjb25zdHJ1Y3RvcihBLEk9e3RvdWNoR2VzdHVyZXM6ITEsdW5sb2NrZWRNb3VzZVBvaW50ZXI6ITEsZW1icmFjZU1vdXNlQWNjZWxlcmF0aW9uOiExfSl7dGhpcy5yYWlud2F5U3RyZWFtPUEsdGhpcy5vcHRpb25zPUksdGhpcy5sZXZlbD15QS5Ob25lLHRoaXMuY29udGFpbmVyPXZvaWQgMCx0aGlzLmhlbGRLZXlzPW5ldyBTZXQsdGhpcy5hbHdheXNSZXBvcnRHYW1lcGFkUG9sbD0hMCx0aGlzLmxvY2tQb2ludGVyPSgpPT57aWYodGhpcy5vcHRpb25zLnVubG9ja2VkTW91c2VQb2ludGVyKXJldHVybjtpZighdGhpcy5jb250YWluZXIpcmV0dXJuO2lmKCF0aGlzLmNvbnRhaW5lci5yZXF1ZXN0UG9pbnRlckxvY2spcmV0dXJuO2NvbnN0IEE9IXRoaXMub3B0aW9ucy5lbWJyYWNlTW91c2VBY2NlbGVyYXRpb24sST1BP3RoaXMuY29udGFpbmVyLnJlcXVlc3RQb2ludGVyTG9jayh7dW5hZGp1c3RlZE1vdmVtZW50OiEwfSk6dGhpcy5jb250YWluZXIucmVxdWVzdFBvaW50ZXJMb2NrKCk7SSBpbnN0YW5jZW9mIFByb21pc2U/SS5jYXRjaCgoST0+e1wiTm90U3VwcG9ydGVkRXJyb3JcIj09PUkubmFtZSYmQSYmdGhpcy5jb250YWluZXI/LnJlcXVlc3RQb2ludGVyTG9jaygpfSkpOnRoaXMuY29udGFpbmVyLm9ucG9pbnRlcmxvY2tlcnJvcj0oKT0+e0EmJnRoaXMuY29udGFpbmVyPy5yZXF1ZXN0UG9pbnRlckxvY2soKX0sdGhpcy5jb250YWluZXIuZm9jdXMoKX0sdGhpcy5mb2N1c0NvbnRhaW5lcj0oKT0+dGhpcy5jb250YWluZXI/LmZvY3VzKCksdGhpcy5vblBvaW50ZXJFdmVudFdpdGhHZXN0dXJlUHJvY2Vzc2luZz1BPT57KEEucG9pbnRlclR5cGUmJlwibW91c2VcIiE9PUEucG9pbnRlclR5cGV8fGRvY3VtZW50LnBvaW50ZXJMb2NrRWxlbWVudD09PXRoaXMuY29udGFpbmVyKSYmKHRoaXMub3B0aW9ucy50b3VjaEdlc3R1cmVzJiZcInRvdWNoXCI9PT1BLnBvaW50ZXJUeXBlPyhBLnByZXZlbnREZWZhdWx0KCksdGhpcy5nZXN0dXJlUmVjb2duaXplci5wcm9jZXNzUG9pbnRlckV2ZW50KEEpKTp0aGlzLm9uUG9pbnRlckV2ZW50KEEpKX0sdGhpcy5vblBvaW50ZXJFdmVudEZyb21HZXN0dXJlUmVjb2duaXplcj1BPT57dGhpcy5vblBvaW50ZXJFdmVudChBKX0sdGhpcy5vblBvaW50ZXJFdmVudD1BPT57dGhpcy5jdXJzb3JQYWludGVyLnVwZGF0ZShBLHRoaXMucmVtZW1iZXJlZE9mZnNldFgsdGhpcy5yZW1lbWJlcmVkT2Zmc2V0WSksdGhpcy5yZXBvcnRQb2ludGVyRXZlbnQoQSl9LHRoaXMuc2Nyb2xsZWRBbW91bnQ9MCx0aGlzLm9uV2hlZWxFdmVudD1BPT57dGhpcy5zY3JvbGxlZEFtb3VudCs9LjA1KkEuZGVsdGFZLHRoaXMuc2Nyb2xsZWRBbW91bnQ+PTE/KHRoaXMuc2VuZFZlcnRpY2FsU2Nyb2xsKE1hdGguZmxvb3IodGhpcy5zY3JvbGxlZEFtb3VudCkpLHRoaXMuc2Nyb2xsZWRBbW91bnQlPTEpOnRoaXMuc2Nyb2xsZWRBbW91bnQ8PS0xJiYodGhpcy5zZW5kVmVydGljYWxTY3JvbGwoTWF0aC5jZWlsKHRoaXMuc2Nyb2xsZWRBbW91bnQpKSx0aGlzLnNjcm9sbGVkQW1vdW50JT0tMSl9LHRoaXMub25LZXlib2FyZEV2ZW50PUE9PntBLnByZXZlbnREZWZhdWx0KCk7Y29uc3QgST13SVtBLmNvZGVdLGc9XCJrZXlkb3duXCI9PT1BLnR5cGU7SSYmKGc/dGhpcy5oZWxkS2V5cy5hZGQoSSk6dGhpcy5oZWxkS2V5cy5kZWxldGUoSSksdGhpcy5zZW5kSW5wdXREYXRhZ3JhbSh7ZGlzY3JpbWluYXRvcjpBQS5kaXNjcmltaW5hdG9yLHZhbHVlOnthY3Rpb246Zz92LktleURvd246di5LZXlVcCxrZXljb2RlOkl9fSkpfSx0aGlzLm9uR2FtZXBhZENvbm5lY3RlZEV2ZW50PUE9Pnt9LHRoaXMub25HYW1lcGFkRGlzY29ubmVjdGVkRXZlbnQ9QT0+e30sdGhpcy5vbkRldmljZU1vdGlvbj1BPT57fSx0aGlzLm9uRGV2aWNlT3JpZW50YXRpb249QT0+e30sdGhpcy5nYW1lcGFkQ2FjaGU9bmV3IE1hcCx0aGlzLnBvbGxHYW1lcGFkcz1BPT57aWYobmF2aWdhdG9yLmdldEdhbWVwYWRzKXtpZih0aGlzLmNvbnRhaW5lcj09PWRvY3VtZW50LmFjdGl2ZUVsZW1lbnQpe2NvbnN0IEE9W107Zm9yKGNvbnN0IEkgb2YgbmF2aWdhdG9yLmdldEdhbWVwYWRzKCkpe2lmKCFJfHwhTEkoSSkpY29udGludWU7Y29uc3QgZz1JLmJ1dHRvbnMubWFwKChBPT5BLnZhbHVlKSksQj10aGlzLmdhbWVwYWRDYWNoZS5nZXQoSS5pbmRleCk7QiYmZkkoQi5heGVzLEkuYXhlcykmJmZJKEIuYnV0dG9uVmFsdWVzLGcpfHwoQS5wdXNoKHRoaXMubWFrZUdhbWVwYWRJbnB1dEV2ZW50KEkpKSx0aGlzLmdhbWVwYWRDYWNoZS5zZXQoSS5pbmRleCx7YXhlczpbLi4uSS5heGVzXSxidXR0b25WYWx1ZXM6Z30pKX0odGhpcy5hbHdheXNSZXBvcnRHYW1lcGFkUG9sbHx8QS5sZW5ndGg+MCkmJnRoaXMucmVwb3J0R2FtZXBhZEV2ZW50cyhBKX10aGlzLmxldmVsJnlBLkdhbWVwYWQmJih0aGlzLmdhbWVwYWRGcmFtZUhhbmRsZT13aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRoaXMucG9sbEdhbWVwYWRzKSl9fSx0aGlzLnJlcG9ydEdhbWVwYWRFdmVudHM9QT0+e2Zvcihjb25zdCBJIG9mIEEpe2xldCBBPTA7SS5idXR0b25zLmRwYWRVcCYmKEF8PTEpLEkuYnV0dG9ucy5kcGFkRG93biYmKEF8PTIpLEkuYnV0dG9ucy5kcGFkTGVmdCYmKEF8PTQpLEkuYnV0dG9ucy5kcGFkUmlnaHQmJihBfD04KSxJLmJ1dHRvbnMuc3RhcnQmJihBfD0xNiksSS5idXR0b25zLnNlbGVjdCYmKEF8PTMyKSxJLmJ1dHRvbnMubGVmdFN0aWNrUHJlc3NlZCYmKEF8PTY0KSxJLmJ1dHRvbnMucmlnaHRTdGlja1ByZXNzZWQmJihBfD0xMjgpLEkuYnV0dG9ucy5sZWZ0U2hvdWxkZXImJihBfD0yNTYpLEkuYnV0dG9ucy5yaWdodFNob3VsZGVyJiYoQXw9NTEyKSxJLmJ1dHRvbnMuYSYmKEF8PTQwOTYpLEkuYnV0dG9ucy5iJiYoQXw9ODE5MiksSS5idXR0b25zLngmJihBfD0xNjM4NCksSS5idXR0b25zLnkmJihBfD0zMjc2OCk7Y29uc3QgZz17YnV0dG9uczpBLGxlZnRUcmlnZ2VyOk1hdGgucm91bmQoMjU1KkkuYnV0dG9ucy5sZWZ0VHJpZ2dlcikscmlnaHRUcmlnZ2VyOk1hdGgucm91bmQoMjU1KkkuYnV0dG9ucy5yaWdodFRyaWdnZXIpLGxlZnRUaHVtYlg6TWF0aC5yb3VuZCgzMjc2NypJLnN0aWNrcy5sZWZ0LngpLGxlZnRUaHVtYlk6TWF0aC5yb3VuZCgzMjc2NyotSS5zdGlja3MubGVmdC55KSxyaWdodFRodW1iWDpNYXRoLnJvdW5kKDMyNzY3Kkkuc3RpY2tzLnJpZ2h0LngpLHJpZ2h0VGh1bWJZOk1hdGgucm91bmQoMzI3NjcqLUkuc3RpY2tzLnJpZ2h0LnkpLHNsb3Q6MX07dGhpcy5zZW5kSW5wdXREYXRhZ3JhbSh7ZGlzY3JpbWluYXRvcjpWLmRpc2NyaW1pbmF0b3IsdmFsdWU6Z30pfX0sdGhpcy5tb3ZlTW91c2VSZWxhdGl2ZVhZPShBLEkpPT57dGhpcy5zZW5kTW91c2VNb3ZlKFwicmVsYXRpdmVcIixBLEkpfSx0aGlzLm1vdmVNb3VzZUFic29sdXRlWFk9KEEsSSk9Pnt0aGlzLnNlbmRNb3VzZU1vdmUoXCJhYnNvbHV0ZVwiLEEsSSl9LHRoaXMucG9pbnRlckZyYW1lSWQ9MCx0aGlzLnJlbWVtYmVyZWRPZmZzZXRYPTAsdGhpcy5yZW1lbWJlcmVkT2Zmc2V0WT0wLHRoaXMudG91Y2hlcz1uZXcgTWFwLHRoaXMucmVwb3J0UG9pbnRlckV2ZW50PUE9PntpZihcInRvdWNoXCI9PT1BLnBvaW50ZXJUeXBlfHxcInBlblwiPT09QS5wb2ludGVyVHlwZSl7aWYoZG9jdW1lbnQucG9pbnRlckxvY2tFbGVtZW50PT09dGhpcy5jb250YWluZXIpe2NvbnN0IEk9dGhpcy5jb250YWluZXIuY2xpZW50V2lkdGgsZz10aGlzLmNvbnRhaW5lci5jbGllbnRIZWlnaHQsQj1BLm1vdmVtZW50WCxRPUEubW92ZW1lbnRZO3RoaXMucmVtZW1iZXJlZE9mZnNldFg9TWF0aC5tYXgoMCxNYXRoLm1pbihJLHRoaXMucmVtZW1iZXJlZE9mZnNldFgrQikpLHRoaXMucmVtZW1iZXJlZE9mZnNldFk9TWF0aC5tYXgoMCxNYXRoLm1pbihnLHRoaXMucmVtZW1iZXJlZE9mZnNldFkrUSkpfWVsc2UgdGhpcy5yZW1lbWJlcmVkT2Zmc2V0WD1BLm9mZnNldFgsdGhpcy5yZW1lbWJlcmVkT2Zmc2V0WT1BLm9mZnNldFk7Y29uc3QgST10aGlzLnJhaW53YXlTdHJlYW0udHJhbnNmb3JtUG9pbnRlck9mZnNldFRvUmVtb3RlKHRoaXMucmVtZW1iZXJlZE9mZnNldFgsdGhpcy5yZW1lbWJlcmVkT2Zmc2V0WSk7aWYoIUkpcmV0dXJuO2NvbnN0e3g6Zyx5OkJ9PUksUT1NYXRoLmNlaWwoQS53aWR0aC8yKSxDPU1hdGguY2VpbChBLmhlaWdodC8yKSx7cG9pbnRlcklkOmUsYnV0dG9uczppfT1BLHQ9XCJwb2ludGVyY2FuY2VsXCI9PT1BLnR5cGV8fFwicG9pbnRlcm91dFwiPT09QS50eXBlfHxcInBvaW50ZXJsZWF2ZVwiPT09QS50eXBlLEU9aT4wLG89KFwicG9pbnRlcm92ZXJcIj09PUEudHlwZT9QLk5ldzowKXwoRT9QLkluQ29udGFjdDowKXwoMT09KDMmaSk/UC5GaXJzdEJ1dHRvbjowKXwoMz09KDMmaSk/UC5TZWNvbmRCdXR0b246MCl8KEEuaXNQcmltYXJ5P1AuUHJpbWFyeTowKXwoXCJwb2ludGVyY2FuY2VsXCI9PT1BLnR5cGU/UC5DYW5jZWxlZDowKXwoXCJwb2ludGVyZG93blwiPT09QS50eXBlP1AuRG93bjpcInBvaW50ZXJ1cFwiPT09QS50eXBlP1AuVXA6UC5VcGRhdGUpfCh0P0U/UC5VcDpQLlVwZGF0ZTpQLkluUmFuZ2UpLGE9e3BvaW50ZXJJZDplLGZyYW1lSWQ6Kyt0aGlzLnBvaW50ZXJGcmFtZUlkLHBvaW50ZXJGbGFnczpvLHg6Zyx5OkJ9LHM9TWF0aC5yb3VuZChBLnR3aXN0KSUzNjAsbj1NYXRoLnJvdW5kKDEwMjQqQS5wcmVzc3VyZSk7aWYoXCJ0b3VjaFwiPT09QS5wb2ludGVyVHlwZSl7Y29uc3QgQT17cG9pbnRlckluZm86YSx0b3VjaE1hc2s6Vy5Db250YWN0QXJlYXxXLk9yaWVudGF0aW9ufFcuUHJlc3N1cmUsY29udGFjdExlZnQ6Zy1RLGNvbnRhY3RUb3A6Qi1DLGNvbnRhY3RSaWdodDpnK1EsY29udGFjdEJvdHRvbTpCK0Msb3JpZW50YXRpb246cyxwcmVzc3VyZTpufTt0aGlzLnRvdWNoZXMuc2V0KGUsQSksdGhpcy5zZW5kSW5wdXREYXRhZ3JhbSh7ZGlzY3JpbWluYXRvcjpnQS5kaXNjcmltaW5hdG9yLHZhbHVlOnt0b3VjaGVzOlsuLi50aGlzLnRvdWNoZXMudmFsdWVzKCldfX0pLHQmJnRoaXMudG91Y2hlcy5kZWxldGUoZSl9ZWxzZXtjb25zdCBJPSgyJmk/Ty5CYXJyZWw6MCl8KDMyJmk/Ty5FcmFzZXI6MCk7dGhpcy5zZW5kSW5wdXREYXRhZ3JhbSh7ZGlzY3JpbWluYXRvcjpCQS5kaXNjcmltaW5hdG9yLHZhbHVlOntwb2ludGVySW5mbzphLHBlbk1hc2s6VC5QcmVzc3VyZXxULlJvdGF0aW9ufFQuVGlsdFh8VC5UaWx0WSxwZW5GbGFnczpJLHJvdGF0aW9uOnMscHJlc3N1cmU6bix0aWx0WDpNYXRoLnJvdW5kKEEudGlsdFgpLHRpbHRZOk1hdGgucm91bmQoQS50aWx0WSl9fSl9fWVsc2V7aWYoKEEubW92ZW1lbnRYfHxBLm1vdmVtZW50WSkmJnRoaXMuc2VuZE1vdXNlTW92ZShcInJlbGF0aXZlXCIsQS5tb3ZlbWVudFgsQS5tb3ZlbWVudFkpLEEuYnV0dG9uPi0xKXtjb25zdCBJPWZ1bmN0aW9uKEEpe2xldCBJLGc7c3dpdGNoKEEuYnV0dG9uKXtkZWZhdWx0OmNhc2UgMDpJPTAhPSgxJkEuYnV0dG9ucyksZz1xLkxlZnQ7YnJlYWs7Y2FzZSAxOkk9MCE9KDQmQS5idXR0b25zKSxnPXEuTWlkZGxlO2JyZWFrO2Nhc2UgMjpJPTAhPSgyJkEuYnV0dG9ucyksZz1xLlJpZ2h0O2JyZWFrO2Nhc2UgMzpJPTAhPSg4JkEuYnV0dG9ucyksZz1xLlgxO2JyZWFrO2Nhc2UgNDpJPTAhPSgxNiZBLmJ1dHRvbnMpLGc9cS5YMn1yZXR1cm57YnV0dG9uOmcsYWN0aW9uOkk/Sy5CdXR0b25Eb3duOksuQnV0dG9uVXB9fShBKTt0aGlzLnNlbmRNb3VzZUNsaWNrKEkpfX19LHRoaXMuY3Vyc29yUGFpbnRlcj1uZXcgbEkodGhpcy5tb3ZlTW91c2VBYnNvbHV0ZVhZLCgoQSxJKT0+dGhpcy5yYWlud2F5U3RyZWFtLnRyYW5zZm9ybVBvaW50ZXJPZmZzZXRUb1JlbW90ZShBLEkpKSwoKCk9PnRoaXMucmFpbndheVN0cmVhbS5jdXJyZW50RnJhbWVTaXplKSksdGhpcy5nZXN0dXJlUmVjb2duaXplcj1uZXcgdUkodGhpcy5vblBvaW50ZXJFdmVudEZyb21HZXN0dXJlUmVjb2duaXplcix0aGlzLm9uV2hlZWxFdmVudCksdGhpcy5vdXRnb2luZ0lucHV0RmlsdGVyPSgpPT4hMH1zZXRDb250YWluZXIoQSl7aWYodGhpcy5jdXJzb3JQYWludGVyLnNldENvbnRhaW5lcihBKSx0aGlzLmNvbnRhaW5lcil7Y29uc3QgST10aGlzLmxldmVsO3RoaXMuc2V0SW5wdXRMZXZlbCh5QS5Ob25lLCExKSx0aGlzLmNvbnRhaW5lcj1BLHRoaXMuc2V0SW5wdXRMZXZlbChJLCExKX1lbHNlIHRoaXMuY29udGFpbmVyPUF9dW5zZXRDb250YWluZXIoKXt0aGlzLnNldElucHV0TGV2ZWwoeUEuTm9uZSwhMSksdGhpcy5jdXJzb3JQYWludGVyLnVuc2V0Q29udGFpbmVyKCksdGhpcy5jb250YWluZXI9dm9pZCAwfXNldElucHV0TGV2ZWwoQSxJPSEwLGc9ITApe3RoaXMuYWx3YXlzUmVwb3J0R2FtZXBhZFBvbGw9Zztjb25zdCBCPUEmfnRoaXMubGV2ZWwsUT10aGlzLmxldmVsJn5BO3RoaXMubGV2ZWw9QSxCJnlBLkdhbWVwYWQmJnRoaXMuc3RhcnRHYW1lcGFkKEkpLFEmeUEuR2FtZXBhZCYmdGhpcy5zdG9wR2FtZXBhZCgpLEImeUEuTW91c2UmJnRoaXMuc3RhcnRNb3VzZSgpLFEmeUEuTW91c2UmJnRoaXMuc3RvcE1vdXNlKCksQiZ5QS5LZXlib2FyZCYmdGhpcy5zdGFydEtleWJvYXJkKCksUSZ5QS5LZXlib2FyZCYmdGhpcy5zdG9wS2V5Ym9hcmQoKSx0aGlzLmN1cnNvclBhaW50ZXIuc2V0Q2FuQ29udHJvbE1vdXNlKDAhPShBJnlBLk1vdXNlKSl9Z2V0SW5wdXRMZXZlbCgpe3JldHVybiB0aGlzLmxldmVsfXN0YXJ0R2FtZXBhZChBKXt3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcImdhbWVwYWRjb25uZWN0ZWRcIix0aGlzLm9uR2FtZXBhZENvbm5lY3RlZEV2ZW50KSx3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcImdhbWVwYWRkaXNjb25uZWN0ZWRcIix0aGlzLm9uR2FtZXBhZERpc2Nvbm5lY3RlZEV2ZW50KSx0aGlzLmdhbWVwYWRGcmFtZUhhbmRsZT13aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRoaXMucG9sbEdhbWVwYWRzKSxBJiZ0aGlzLnJlcG9ydENvbm5lY3RlZEdhbWVwYWRzKCl9cmVwb3J0Q29ubmVjdGVkR2FtZXBhZHMoKXtmb3IoY29uc3QgQSBvZiBuYXZpZ2F0b3IuZ2V0R2FtZXBhZHMoKSlBJiZ0aGlzLm9uR2FtZXBhZENvbm5lY3RlZEV2ZW50KG5ldyBHYW1lcGFkRXZlbnQoXCJnYW1lcGFkY29ubmVjdGVkXCIse2dhbWVwYWQ6QX0pKX1zdG9wR2FtZXBhZCgpe3dpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwiZ2FtZXBhZGNvbm5lY3RlZFwiLHRoaXMub25HYW1lcGFkQ29ubmVjdGVkRXZlbnQpLHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwiZ2FtZXBhZGRpc2Nvbm5lY3RlZFwiLHRoaXMub25HYW1lcGFkRGlzY29ubmVjdGVkRXZlbnQpLHRoaXMuZ2FtZXBhZEZyYW1lSGFuZGxlJiZ3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWUodGhpcy5nYW1lcGFkRnJhbWVIYW5kbGUpLHRoaXMuZ2FtZXBhZEZyYW1lSGFuZGxlPXZvaWQgMH1wb2ludGVyRXZlbnRMaXN0ZW5lcnMoQSl7aWYoIXdpbmRvdy5Qb2ludGVyRXZlbnQpdGhyb3cgbmV3IEVycm9yKFwiYnJvd3NlciBkb2VzIG5vdCBzdXBwb3J0IFBvaW50ZXJFdmVudFwiKTtBKGtJJiZuYXZpZ2F0b3IubWF4VG91Y2hQb2ludHM8MT9cIm1vdXNlbW92ZVwiOndpbmRvdy5vbnBvaW50ZXJyYXd1cGRhdGU/XCJwb2ludGVycmF3dXBkYXRlXCI6XCJwb2ludGVybW92ZVwiLHRoaXMub25Qb2ludGVyRXZlbnRXaXRoR2VzdHVyZVByb2Nlc3NpbmcpLEEoXCJwb2ludGVyZG93blwiLHRoaXMub25Qb2ludGVyRXZlbnRXaXRoR2VzdHVyZVByb2Nlc3NpbmcpLEEoXCJwb2ludGVydXBcIix0aGlzLm9uUG9pbnRlckV2ZW50V2l0aEdlc3R1cmVQcm9jZXNzaW5nKSxBKFwicG9pbnRlcm92ZXJcIix0aGlzLm9uUG9pbnRlckV2ZW50V2l0aEdlc3R1cmVQcm9jZXNzaW5nKSxBKFwicG9pbnRlcmVudGVyXCIsdGhpcy5vblBvaW50ZXJFdmVudFdpdGhHZXN0dXJlUHJvY2Vzc2luZyksQShcInBvaW50ZXJjYW5jZWxcIix0aGlzLm9uUG9pbnRlckV2ZW50V2l0aEdlc3R1cmVQcm9jZXNzaW5nKSxBKFwicG9pbnRlcm91dFwiLHRoaXMub25Qb2ludGVyRXZlbnRXaXRoR2VzdHVyZVByb2Nlc3NpbmcpLEEoXCJwb2ludGVybGVhdmVcIix0aGlzLm9uUG9pbnRlckV2ZW50V2l0aEdlc3R1cmVQcm9jZXNzaW5nKTtBKFwid2hlZWxcIix0aGlzLm9uV2hlZWxFdmVudCksQShcIm1vdXNldXBcIix0aGlzLmxvY2tQb2ludGVyKX1zdGFydE1vdXNlKCl7aWYoIXRoaXMuY29udGFpbmVyKXRocm93IG5ldyBRKFwiUmFpbndheSB0cmllZCB0byBhZGQgYW4gZXZlbnQgbGlzdGVuZXIgdG8gaXRzIGNvbnRhaW5lciB0byBoYW5kbGUgbW91c2UgaW5wdXQsIGJ1dCBubyBjb250YWluZXIgZWxlbWVudCBpcyBzZXQuIFRyeSBjYWxsaW5nIHNldENvbnRhaW5lcigpIGZpcnN0LlwiKTt0aGlzLnBvaW50ZXJFdmVudExpc3RlbmVycyh0aGlzLmNvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyLmJpbmQodGhpcy5jb250YWluZXIpKX1zdG9wTW91c2UoKXt0aGlzLmNvbnRhaW5lciYmdGhpcy5wb2ludGVyRXZlbnRMaXN0ZW5lcnModGhpcy5jb250YWluZXIucmVtb3ZlRXZlbnRMaXN0ZW5lci5iaW5kKHRoaXMuY29udGFpbmVyKSl9c3RhcnRLZXlib2FyZCgpe2lmKCF0aGlzLmNvbnRhaW5lcil0aHJvdyBuZXcgUShcIlJhaW53YXkgdHJpZWQgdG8gYWRkIGFuIGV2ZW50IGxpc3RlbmVyIHRvIGl0cyBjb250YWluZXIgdG8gaGFuZGxlIGtleWJvYXJkIGlucHV0LCBidXQgbm8gY29udGFpbmVyIGVsZW1lbnQgaXMgc2V0LiBUcnkgY2FsbGluZyBzZXRDb250YWluZXIoKSBmaXJzdC5cIik7dGhpcy5jb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIix0aGlzLm9uS2V5Ym9hcmRFdmVudCksdGhpcy5jb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcihcImtleXVwXCIsdGhpcy5vbktleWJvYXJkRXZlbnQpLHRoaXMuY29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLHRoaXMuZm9jdXNDb250YWluZXIpLHRoaXMuY29udGFpbmVyLmZvY3VzKCl9c3RvcEtleWJvYXJkKCl7dGhpcy5jb250YWluZXImJih0aGlzLnJlbGVhc2VLZXlzKCksdGhpcy5jb250YWluZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIix0aGlzLm9uS2V5Ym9hcmRFdmVudCksdGhpcy5jb250YWluZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImtleXVwXCIsdGhpcy5vbktleWJvYXJkRXZlbnQpLHRoaXMuY29udGFpbmVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLHRoaXMuZm9jdXNDb250YWluZXIpKX1zdGFydERldmljZU1vdGlvbkV2ZW50cygpe3dpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwiZGV2aWNlbW90aW9uXCIsdGhpcy5vbkRldmljZU1vdGlvbil9c3RvcERldmljZU1vdGlvbkV2ZW50cygpe3dpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwiZGV2aWNlbW90aW9uXCIsdGhpcy5vbkRldmljZU1vdGlvbil9c3RhcnREZXZpY2VPcmllbnRhdGlvbkV2ZW50cygpe3dpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwiZGV2aWNlb3JpZW50YXRpb25cIix0aGlzLm9uRGV2aWNlT3JpZW50YXRpb24pfXN0b3BEZXZpY2VPcmllbnRhdGlvbkV2ZW50cygpe3dpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwiZGV2aWNlb3JpZW50YXRpb25cIix0aGlzLm9uRGV2aWNlT3JpZW50YXRpb24pfXNlbmRWZXJ0aWNhbFNjcm9sbChBKXt0aGlzLnNlbmRJbnB1dERhdGFncmFtKHtkaXNjcmltaW5hdG9yOiQuZGlzY3JpbWluYXRvcix2YWx1ZTp7YXhpczpZLlZlcnRpY2FsLGRlbHRhOkF9fSl9bWFrZUdhbWVwYWRJbnB1dEV2ZW50KEEpe3JldHVybntpZDpBLmlkLGluZGV4OkEuaW5kZXgsYnV0dG9uczp7YTpBLmJ1dHRvbnNbMF0/LnZhbHVlPz8wLGI6QS5idXR0b25zWzFdPy52YWx1ZT8/MCx4OkEuYnV0dG9uc1syXT8udmFsdWU/PzAseTpBLmJ1dHRvbnNbM10/LnZhbHVlPz8wLGxlZnRTaG91bGRlcjpBLmJ1dHRvbnNbNF0/LnZhbHVlPz8wLHJpZ2h0U2hvdWxkZXI6QS5idXR0b25zWzVdPy52YWx1ZT8/MCxsZWZ0VHJpZ2dlcjpBLmJ1dHRvbnNbNl0/LnZhbHVlPz8wLHJpZ2h0VHJpZ2dlcjpBLmJ1dHRvbnNbN10/LnZhbHVlPz8wLHNlbGVjdDpBLmJ1dHRvbnNbOF0/LnZhbHVlPz8wLHN0YXJ0OkEuYnV0dG9uc1s5XT8udmFsdWU/PzAsbGVmdFN0aWNrUHJlc3NlZDpBLmJ1dHRvbnNbMTBdPy52YWx1ZT8/MCxyaWdodFN0aWNrUHJlc3NlZDpBLmJ1dHRvbnNbMTFdPy52YWx1ZT8/MCxkcGFkVXA6QS5idXR0b25zWzEyXT8udmFsdWU/PzAsZHBhZERvd246QS5idXR0b25zWzEzXT8udmFsdWU/PzAsZHBhZExlZnQ6QS5idXR0b25zWzE0XT8udmFsdWU/PzAsZHBhZFJpZ2h0OkEuYnV0dG9uc1sxNV0/LnZhbHVlPz8wLGhvbWU6QS5idXR0b25zWzE2XT8udmFsdWU/PzB9LHN0aWNrczp7bGVmdDp7eDpBLmF4ZXNbMF0/PzAseTpBLmF4ZXNbMV0/PzB9LHJpZ2h0Ont4OkEuYXhlc1syXT8/MCx5OkEuYXhlc1szXT8/MH19fX1mZWVkR2FtZXBhZElucHV0RXZlbnQoQSl7dGhpcy5yZXBvcnRHYW1lcGFkRXZlbnRzKEEpfXN0YXRpYyB2aWJyYXRlR2FtZXBhZChBLEkpe2NvbnN0IGc9bmF2aWdhdG9yLmdldEdhbWVwYWRzKClbQV07aWYoZz8udmlicmF0aW9uQWN0dWF0b3IpZy52aWJyYXRpb25BY3R1YXRvci5wbGF5RWZmZWN0Py4oXCJkdWFsLXJ1bWJsZVwiLEkpO2Vsc2UgaWYoZz8uaGFwdGljQWN0dWF0b3JzKXtjb25zdCBBPWc/LmhhcHRpY0FjdHVhdG9ycztzZXRUaW1lb3V0KCgoKT0+e2Zvcihjb25zdCBnIG9mIEEpaWYoXCJwdWxzZVwiaW4gZyl7Y29uc3QgQT1NYXRoLm1heChJLnN0cm9uZ01hZ25pdHVkZT8/MCxJLndlYWtNYWduaXR1ZGU/PzApO2cucHVsc2UoQSxJLmR1cmF0aW9uPz8wKX19KSxJLnN0YXJ0RGVsYXkpfX1mZWVkS2V5Ym9hcmRFdmVudChBKXt0aGlzLm9uS2V5Ym9hcmRFdmVudChBKX1yZWxlYXNlS2V5cygpe2Zvcihjb25zdCBBIG9mIHRoaXMuaGVsZEtleXMpdGhpcy5zZW5kSW5wdXREYXRhZ3JhbSh7ZGlzY3JpbWluYXRvcjpBQS5kaXNjcmltaW5hdG9yLHZhbHVlOnthY3Rpb246di5LZXlVcCxrZXljb2RlOkF9fSk7dGhpcy5oZWxkS2V5cy5jbGVhcigpfWZlZWRQb2ludGVyRXZlbnQoQSl7dGhpcy5vblBvaW50ZXJFdmVudChBKX1mZWVkV2hlZWxFdmVudChBKXt0aGlzLm9uV2hlZWxFdmVudChBKX1wcm9jZXNzQ3Vyc29yKEEpe3RoaXMuY3Vyc29yUGFpbnRlci5wcm9jZXNzQ3Vyc29yKEEpfWVuYWJsZUdlc3R1cmVzKCl7dGhpcy5vcHRpb25zLnRvdWNoR2VzdHVyZXM9ITB9ZGlzYWJsZUdlc3R1cmVzKCl7dGhpcy5vcHRpb25zLnRvdWNoR2VzdHVyZXM9ITF9c2VuZE1vdXNlTW92ZShBLEksZyl7XCJhYnNvbHV0ZVwiPT09QT90aGlzLnNlbmRJbnB1dERhdGFncmFtKHtkaXNjcmltaW5hdG9yOlouZGlzY3JpbWluYXRvcix2YWx1ZTp7eDpJLHk6Z319KTp0aGlzLnNlbmRJbnB1dERhdGFncmFtKHtkaXNjcmltaW5hdG9yOnouZGlzY3JpbWluYXRvcix2YWx1ZTp7ZHg6SSxkeTpnfX0pfXNlbmRNb3VzZUNsaWNrKEEpe3RoaXMuc2VuZElucHV0RGF0YWdyYW0oe2Rpc2NyaW1pbmF0b3I6Xy5kaXNjcmltaW5hdG9yLHZhbHVlOkF9KX1zZW5kSW5wdXREYXRhZ3JhbShBKXt0aGlzLnJhaW53YXlTdHJlYW0uaGFuZGxlT3V0Z29pbmdJbnB1dChBLG5ldyBNSSh0aGlzLmhlbGRLZXlzKSl9ZGlzcG9zZSgpe3RoaXMudW5zZXRDb250YWluZXIoKX19Y2xhc3MgSEl7Y29uc3RydWN0b3IoQSxJKXt0aGlzLnNpemVNcz1BLHRoaXMuYXZlcmFnZU9wZXJhdGlvbj1JLHRoaXMuY2FjaGVkQXZlcmFnZT12b2lkIDAsdGhpcy5idWZmZXI9W119Z2V0IHZhbHVlcygpe3JldHVybiB0aGlzLnRyaW0oKSx0aGlzLmJ1ZmZlci5tYXAoKEE9PkEudmFsdWUpKX1nZXQgbWVhc3VyZW1lbnRzKCl7cmV0dXJuIHRoaXMudHJpbSgpLHRoaXMuYnVmZmVyfXRyaW0oKXtjb25zdCBBPXBlcmZvcm1hbmNlLm5vdygpLEk9dGhpcy5idWZmZXIuZmluZEluZGV4KChJPT5JLnRpbWU+QS10aGlzLnNpemVNcykpO0k+MD8odGhpcy5idWZmZXIuc3BsaWNlKDAsSSksdGhpcy5jYWNoZWRBdmVyYWdlPXZvaWQgMCk6LTE9PT1JJiYodGhpcy5idWZmZXIuc3BsaWNlKDAsdGhpcy5idWZmZXIubGVuZ3RoKSx0aGlzLmNhY2hlZEF2ZXJhZ2U9dm9pZCAwKX1mZWVkKEEpe2NvbnN0IEk9cGVyZm9ybWFuY2Uubm93KCk7dGhpcy5idWZmZXIucHVzaCh7dGltZTpJLHZhbHVlOkF9KSx0aGlzLmJ1ZmZlci5sZW5ndGg+PTUwMCYmdGhpcy50cmltKCksdGhpcy5jYWNoZWRBdmVyYWdlPXZvaWQgMH1hdmVyYWdlKCl7aWYodGhpcy50cmltKCksdGhpcy5jYWNoZWRBdmVyYWdlKXJldHVybiB0aGlzLmNhY2hlZEF2ZXJhZ2U7Y29uc3QgQT10aGlzLmJ1ZmZlci5tYXAoKEE9PkEudmFsdWUpKTtyZXR1cm4gdGhpcy5jYWNoZWRBdmVyYWdlPXRoaXMuYXZlcmFnZU9wZXJhdGlvbihBKX19ZnVuY3Rpb24gSkkoQSl7aWYoMD09PUEubGVuZ3RoKXJldHVybiBOYU47Y29uc3QgST1BLmxlbmd0aCxnPUEucmVkdWNlKCgoQSxJKT0+QStJKSwwKS9JO3JldHVybiBNYXRoLnNxcnQoQS5tYXAoKEE9Pk1hdGgucG93KEEtZywyKSkpLnJlZHVjZSgoKEEsSSk9PkErSSksMCkvSSl9ZnVuY3Rpb24gS0koQSl7aWYoMD09PUEubGVuZ3RoKXJldHVybiBOYU47bGV0IEk9MDtmb3IoY29uc3QgZyBvZiBBKUkrPWc7cmV0dXJuIEkvQS5sZW5ndGh9ZnVuY3Rpb24gcUkoQSl7cmV0dXJuIDA9PT1BLmxlbmd0aD8wOktJKEEpfWZ1bmN0aW9uIFlJKEEpe2NvbnN0IEk9QS5kYXRhO3JldHVybmB2aWRlby9tcDQ7IGNvZGVjcz1cImF2YzEuJHsoSVs1XTw8MTZ8SVs2XTw8OHxJWzddKS50b1N0cmluZygxNikucGFkU3RhcnQoNixcIjBcIil9XCJgfWZ1bmN0aW9uIHZJKEEpe2lmKCEoXCJNZWRpYVNvdXJjZVwiaW4gd2luZG93KSlyZXR1cm4hMTtjb25zdCBJPUEuZGF0YTtpZihJLmxlbmd0aDw4fHw3IT0oMzEmSVs0XSkpcmV0dXJuITE7Y29uc3QgZz1ZSShBKTtyZXR1cm4gTWVkaWFTb3VyY2UuaXNUeXBlU3VwcG9ydGVkKGcpfWZ1bmN0aW9uIGJJKEEpe2NvbnN0IEk9QS5kYXRhO2lmKEkubGVuZ3RoPDh8fDchPSgzMSZJWzRdKSlyZXR1cm4gdEEuQmFzZWxpbmU7Y29uc3QgZz1JWzVdO0lbNl07cmV0dXJuIDExNj09Z3x8MTIyPT1nfHwxMTA9PWd8fDEwMD09Zz90QS5IaWdoOjg4PT1nfHw3Nz09Zz90QS5NYWluOnRBLkJhc2VsaW5lfSFmdW5jdGlvbihBKXtBW0EuRGV0YWNoZWQ9MF09XCJEZXRhY2hlZFwiLEFbQS5Jbml0aWFsaXppbmc9MV09XCJJbml0aWFsaXppbmdcIixBW0EuV2FpdGluZ0ZvcktleWZyYW1lPTJdPVwiV2FpdGluZ0ZvcktleWZyYW1lXCIsQVtBLlBsYXlpbmc9M109XCJQbGF5aW5nXCIsQVtBLlBhdXNlZD00XT1cIlBhdXNlZFwiLEFbQS5EaXNwb3NlZD01XT1cIkRpc3Bvc2VkXCJ9KE5JfHwoTkk9e30pKSxmdW5jdGlvbihBKXtBW0EuVXA9MF09XCJVcFwiLEFbQS5Eb3duPTFdPVwiRG93blwifShtSXx8KG1JPXt9KSk7Y29uc3QgUEk9e2JlYXRNczoyNTAwLHdpbmRvd01zOjQ1MDAsYmFkQmVhdHM6Mixnb29kQmVhdHM6NCxiYWNrb2ZmRmFjdG9yOjIsbGF0ZW5lc3NUaHJlc2hvbGRNczoyMDAsbGF0ZW5lc3NTbW9vdGhpbmdGYWN0b3I6LjkzNzUsYmFkTGF0ZUZyYW1lUmF0aW86Ljc1LGluaXRpYWxCaXRyYXRlS2JwczpOdW1iZXIobmV3IFVSTFNlYXJjaFBhcmFtcyh3aW5kb3cubG9jYXRpb24uc2VhcmNoKS5nZXQoXCJpbml0aWFsLWJpdHJhdGVcIik/PzVlMykscXVhbGl0eVN0ZXBGYWN0b3I6MS4xODc1fTtjbGFzcyB4SXtjb25zdHJ1Y3RvcihBPVBJLEksZyxCKXt0aGlzLmNob3NlblZpZGVvQ29uZmlnPUksdGhpcy5zdWdnZXN0Qml0cmF0ZUticHM9Zyx0aGlzLnBlcmZvcm1hbmNlTW9uaXRvcj1CLHRoaXMuYmFkQmVhdENvdW50PTAsdGhpcy5nb29kQmVhdENvdW50PTAsdGhpcy5sYXN0QWRqdXN0bWVudD12b2lkIDAsdGhpcy5oaXN0b3J5PVtdLHRoaXMubG93ZXN0RGVsdGE9dm9pZCAwLHRoaXMuc21vb3RoTGF0ZW5lc3M9MCx0aGlzLmZyYW1lc1RoaXNCZWF0PTAsdGhpcy5sYXRlRnJhbWVzVGhpc0JlYXQ9MCx0aGlzLmRlYnVnTGF0ZW5lc3NTbW9vdGhpbmc9ITEsdGhpcy5iYWRDcHVQZXJmVGhpc0JlYXQ9ITEsdGhpcy5iYWREZWNvZGVyUGVyZlRoaXNCZWF0PSExLHRoaXMuYmFkQ3B1UGVyZkhhbmRsZXI9KCk9Pnt0aGlzLmJhZENwdVBlcmZUaGlzQmVhdD0hMH0sdGhpcy5iYWREZWNvZGVyUGVyZkhhbmRsZXI9KCk9Pnt0aGlzLmJhZERlY29kZXJQZXJmVGhpc0JlYXQ9ITB9LHRoaXMuaGFuZGxlVmlkZW9SZWFkeVN0YXRlPUE9PntBPT09TkkuRGV0YWNoZWR8fEE9PT1OSS5QYXVzZWR8fEE9PT1OSS5XYWl0aW5nRm9yS2V5ZnJhbWU/dGhpcy5zdG9wKCk6dGhpcy5zdGFydCgpfSx0aGlzLmNoZWNrPWFzeW5jKCk9PnswIT09dGhpcy5mcmFtZXNUaGlzQmVhdCYmKGF3YWl0IHRoaXMuYmVhdElzQmFkKCk/dGhpcy5iYWRCZWF0KCk6dGhpcy5nb29kQmVhdCgpLHRoaXMuZnJhbWVzVGhpc0JlYXQ9MCx0aGlzLmxhdGVGcmFtZXNUaGlzQmVhdD0wLHRoaXMuYmFkQ3B1UGVyZlRoaXNCZWF0PSExLHRoaXMuYmFkRGVjb2RlclBlcmZUaGlzQmVhdD0hMSl9LHRoaXMub3duTWF4aW11bUticHM9MS8wLHRoaXMuY2hvc2VuVmlkZW9Db25maWdNaW1lVHlwZT1ZSShJLmNvZGVjKSx0aGlzLnBhcmFtZXRlcnM9ey4uLlBJLC4uLkF9LHRoaXMuY3VycmVudEJpdHJhdGVLYnBzPXRoaXMucGFyYW1ldGVycy5pbml0aWFsQml0cmF0ZUticHMsdGhpcy5mcmFtZVZhcmlhbmNlTXM9bmV3IEhJKHRoaXMucGFyYW1ldGVycy53aW5kb3dNcyxKSSl9Z2V0U3RhdHMoKXtyZXR1cm57dmlkZW9CaXRyYXRlS2Jwczp0aGlzLmN1cnJlbnRCaXRyYXRlS2JwcyxsYXRlbmVzc01zOnRoaXMuc21vb3RoTGF0ZW5lc3N9fWZvcm1hdChBKXtyZXR1cm5gWyR7dGhpcy5jdXJyZW50Qml0cmF0ZUticHMudG9GaXhlZCgwKStcImticHNcIn0sICske3RoaXMuc21vb3RoTGF0ZW5lc3MudG9GaXhlZCgwKX1tc10gJHtBfWB9ZGVidWcoQSl7UUkoeEkubmFtZSx0aGlzLmZvcm1hdChBKSl9aW5mbyhBKXtCSSh4SS5uYW1lLHRoaXMuZm9ybWF0KEEpKX1zdGFydCgpe3RoaXMuY2hlY2tJbnRlcnZhbHx8KHRoaXMuaW5mbyhcIlN0YXJ0aW5nIHJhdGUgY29udHJvbCFcIiksdGhpcy5jaGVja0ludGVydmFsPXdpbmRvdy5zZXRJbnRlcnZhbCh0aGlzLmNoZWNrLHRoaXMucGFyYW1ldGVycy5iZWF0TXMpLHRoaXMucGVyZm9ybWFuY2VNb25pdG9yPy5jcHVTdGFydmF0aW9uRXZlbnQuYWRkSGFuZGxlcih0aGlzLmJhZENwdVBlcmZIYW5kbGVyKSx0aGlzLnBlcmZvcm1hbmNlTW9uaXRvcj8uZGVjb2RlclN0cnVnZ2xpbmdFdmVudC5hZGRIYW5kbGVyKHRoaXMuYmFkRGVjb2RlclBlcmZIYW5kbGVyKSl9c3RvcCgpe3RoaXMuY2hlY2tJbnRlcnZhbCYmKHRoaXMuaW5mbyhcIlN0b3BwaW5nIHJhdGUgY29udHJvbCFcIiksd2luZG93LmNsZWFySW50ZXJ2YWwodGhpcy5jaGVja0ludGVydmFsKSx0aGlzLmNoZWNrSW50ZXJ2YWw9dm9pZCAwLHRoaXMucGVyZm9ybWFuY2VNb25pdG9yPy5jcHVTdGFydmF0aW9uRXZlbnQucmVtb3ZlSGFuZGxlcih0aGlzLmJhZENwdVBlcmZIYW5kbGVyKSx0aGlzLnBlcmZvcm1hbmNlTW9uaXRvcj8uZGVjb2RlclN0cnVnZ2xpbmdFdmVudC5yZW1vdmVIYW5kbGVyKHRoaXMuYmFkRGVjb2RlclBlcmZIYW5kbGVyKSl9ZmVlZEZyYW1lVGltZXN0YW1wKEEpe2NvbnN0IEk9cGVyZm9ybWFuY2Uubm93KCktQTsodm9pZCAwPT09dGhpcy5sb3dlc3REZWx0YXx8STx0aGlzLmxvd2VzdERlbHRhfHxNYXRoLmFicyh0aGlzLmxvd2VzdERlbHRhLUkpPjVlNCkmJih0aGlzLmxvd2VzdERlbHRhPUkpO2NvbnN0IGc9SS10aGlzLmxvd2VzdERlbHRhLEI9dGhpcy5wYXJhbWV0ZXJzLmxhdGVuZXNzU21vb3RoaW5nRmFjdG9yO2lmKHRoaXMuc21vb3RoTGF0ZW5lc3M9Qip0aGlzLnNtb290aExhdGVuZXNzKygxLUIpKmcsdGhpcy5mcmFtZXNUaGlzQmVhdCsrLHRoaXMuc21vb3RoTGF0ZW5lc3M+PXRoaXMucGFyYW1ldGVycy5sYXRlbmVzc1RocmVzaG9sZE1zJiZ0aGlzLmxhdGVGcmFtZXNUaGlzQmVhdCsrLHRoaXMuZGVidWdMYXRlbmVzc1Ntb290aGluZyl7Y29uc3QgQT1uZXcgQXJyYXkoMTAwKTtBLmZpbGwoXCItXCIpO2NvbnN0IEk9ZyxCPXRoaXMuc21vb3RoTGF0ZW5lc3M7QVs1MF09XCIuXCIsQVtNYXRoLm1heCgwLE1hdGgubWluKE1hdGgucm91bmQoSS8xMCs1MCksOTkpKV09XCJMXCIsQVtNYXRoLm1heCgwLE1hdGgubWluKE1hdGgucm91bmQoQi8xMCs1MCksOTkpKV09XCJTXCIsdGhpcy5iZWF0SXNCYWQoKS50aGVuKChnPT50aGlzLmRlYnVnKGAke0Euam9pbihcIlwiKX0gTD0ke0l9IFM9JHtCfSBiYWQ9JHtnfSBsZD0ke3RoaXMubG93ZXN0RGVsdGF9YCkpKX19ZGVjb2RpbmdJbmZvQXRCaXRyYXRlKEEpe3JldHVybiBuYXZpZ2F0b3IubWVkaWFDYXBhYmlsaXRpZXMuZGVjb2RpbmdJbmZvKHt0eXBlOlwibWVkaWEtc291cmNlXCIsdmlkZW86e3dpZHRoOnRoaXMuY2hvc2VuVmlkZW9Db25maWcuY29kZWMud2lkdGgsaGVpZ2h0OnRoaXMuY2hvc2VuVmlkZW9Db25maWcuY29kZWMuaGVpZ2h0LGZyYW1lcmF0ZTp0aGlzLmNob3NlblZpZGVvQ29uZmlnLmNvZGVjLnJlZnJlc2hSYXRlLGJpdHJhdGU6MWUzKkEsY29udGVudFR5cGU6WUkodGhpcy5jaG9zZW5WaWRlb0NvbmZpZy5jb2RlYyl9fSl9YXN5bmMgY2FwYWJpbGl0aWVzQmFkKCl7aWYoIShcIk1lZGlhU291cmNlXCJpbiB3aW5kb3cpKXJldHVybiExO2lmKCEoXCJtZWRpYUNhcGFiaWxpdGllc1wiaW4gbmF2aWdhdG9yKSlyZXR1cm4hMTtjb25zdCBBPWF3YWl0IHRoaXMuZGVjb2RpbmdJbmZvQXRCaXRyYXRlKHRoaXMuY3VycmVudEJpdHJhdGVLYnBzKSxJPWF3YWl0IHRoaXMuZGVjb2RpbmdJbmZvQXRCaXRyYXRlKHRoaXMuYml0cmF0ZU9uZVN0ZXBEb3duS2JwcygpKTtyZXR1cm4gSS5zbW9vdGgmJiFBLnNtb290aHx8SS5wb3dlckVmZmljaWVudCYmIUEucG93ZXJFZmZpY2llbnR9bGF0ZUZyYW1lUmF0aW9CYWQoKXtyZXR1cm4gdGhpcy5sYXRlRnJhbWVzVGhpc0JlYXQvdGhpcy5mcmFtZXNUaGlzQmVhdD49dGhpcy5wYXJhbWV0ZXJzLmJhZExhdGVGcmFtZVJhdGlvfWFzeW5jIGJlYXRJc0JhZCgpe3JldHVybiB0aGlzLmJhZERlY29kZXJQZXJmVGhpc0JlYXR8fHRoaXMuYmFkQ3B1UGVyZlRoaXNCZWF0fHx0aGlzLmxhdGVGcmFtZVJhdGlvQmFkKCl8fGF3YWl0IHRoaXMuY2FwYWJpbGl0aWVzQmFkKCl9YmFkQmVhdCgpe2lmKHRoaXMuY3VycmVudEJpdHJhdGVLYnBzPD10aGlzLmxvd2VzdFN1cHBvcnRlZEJpdHJhdGVLYnBzKCkpcmV0dXJuIHZvaWQgdGhpcy5kZWJ1ZyhgY3Jhc2hlZCBhdCAke3RoaXMuY3VycmVudEJpdHJhdGVLYnBzLnRvRml4ZWQoMCl9a2JwcywgaWdub3JpbmcgYmFkIGJlYXRgKTt0aGlzLmJhZEJlYXRDb3VudCsrLHRoaXMuZ29vZEJlYXRDb3VudD0wO2NvbnN0IEE9dGhpcy5wYXJhbWV0ZXJzLmJhZEJlYXRzO2lmKHRoaXMuZGVidWcoYGJhZCBiZWF0OiAke3RoaXMuYmFkQmVhdENvdW50fS8ke0F9YCksdGhpcy5iYWRCZWF0Q291bnQ+PXRoaXMucGFyYW1ldGVycy5iYWRCZWF0cyl7dGhpcy5nb29kQmVhdENvdW50PXRoaXMuYmFkQmVhdENvdW50PTA7Y29uc3QgQT10aGlzLmxhc3RBZGp1c3RtZW50PT09bUkuVXA7dGhpcy5xdWFsaXR5RG93bigpLHRoaXMuZGVidWcoXCJ3ZW50IGRvd24gaW4gcXVhbGl0eVwiKSxBJiZ0aGlzLmN1cnJlbnRCaXRyYXRlS2Jwczx0aGlzLm93bk1heGltdW1LYnBzJiYodGhpcy5vd25NYXhpbXVtS2Jwcz10aGlzLmN1cnJlbnRCaXRyYXRlS2Jwcyx0aGlzLmluZm8oYHNldHRpbmcgYSBuZXcgbWF4aW11bSBhdCAke3RoaXMub3duTWF4aW11bUticHMudG9GaXhlZCgwKX1rYnBzYCkpfX1nb29kQmVhdCgpe2lmKHRoaXMuY3VycmVudEJpdHJhdGVLYnBzPj10aGlzLm93bk1heGltdW1LYnBzfHx0aGlzLmN1cnJlbnRCaXRyYXRlS2Jwcz49dGhpcy5oaWdoZXN0U3VwcG9ydGVkQml0cmF0ZUticHMoKSlyZXR1cm4gdGhpcy5kZWJ1ZyhgbWF4ZWQgYXQgJHt0aGlzLmN1cnJlbnRCaXRyYXRlS2Jwcy50b0ZpeGVkKDApfWticHMsIGlnbm9yaW5nIGdvb2QgYmVhdGApLHZvaWQodGhpcy5iYWRCZWF0Q291bnQ9MCk7dGhpcy5nb29kQmVhdENvdW50KyssdGhpcy5iYWRCZWF0Q291bnQ9MDtjb25zdCBBPXRoaXMucGFyYW1ldGVycy5nb29kQmVhdHM7dGhpcy5kZWJ1ZyhgZ29vZCBiZWF0OiAke3RoaXMuZ29vZEJlYXRDb3VudH0vJHtBfWApLHRoaXMuZ29vZEJlYXRDb3VudD49QSYmKHRoaXMuZ29vZEJlYXRDb3VudD10aGlzLmJhZEJlYXRDb3VudD0wLHRoaXMucXVhbGl0eVVwKCksdGhpcy5kZWJ1ZyhcIndlbnQgdXAgaW4gcXVhbGl0eVwiKSl9Yml0cmF0ZU9uZVN0ZXBVcEticHMoKXtyZXR1cm4gTWF0aC5taW4odGhpcy5oaWdoZXN0U3VwcG9ydGVkQml0cmF0ZUticHMoKSx0aGlzLmN1cnJlbnRCaXRyYXRlS2Jwcyp0aGlzLnBhcmFtZXRlcnMucXVhbGl0eVN0ZXBGYWN0b3IpfWJpdHJhdGVPbmVTdGVwRG93bkticHMoKXtyZXR1cm4gTWF0aC5tYXgodGhpcy5sb3dlc3RTdXBwb3J0ZWRCaXRyYXRlS2JwcygpLHRoaXMuY3VycmVudEJpdHJhdGVLYnBzL3RoaXMucGFyYW1ldGVycy5xdWFsaXR5U3RlcEZhY3Rvcil9cXVhbGl0eVVwKCl7Y29uc3QgQT10aGlzLmJpdHJhdGVPbmVTdGVwVXBLYnBzKCk7dGhpcy5zdWdnZXN0Qml0cmF0ZUticHMoQSx0aGlzLmN1cnJlbnRCaXRyYXRlS2JwcyksdGhpcy5jdXJyZW50Qml0cmF0ZUticHM9QSx0aGlzLmxhc3RBZGp1c3RtZW50PW1JLlVwLHRoaXMuaGlzdG9yeS5wdXNoKHt0aW1lOnBlcmZvcm1hbmNlLm5vdygpLGJpdHJhdGU6dGhpcy5jdXJyZW50Qml0cmF0ZUticHN9KX1xdWFsaXR5RG93bigpe2NvbnN0IEE9dGhpcy5iaXRyYXRlT25lU3RlcERvd25LYnBzKCk7dGhpcy5zdWdnZXN0Qml0cmF0ZUticHMoQSx0aGlzLmN1cnJlbnRCaXRyYXRlS2JwcyksdGhpcy5jdXJyZW50Qml0cmF0ZUticHM9QSx0aGlzLmxhc3RBZGp1c3RtZW50PW1JLkRvd24sdGhpcy5oaXN0b3J5LnB1c2goe3RpbWU6cGVyZm9ybWFuY2Uubm93KCksYml0cmF0ZTp0aGlzLmN1cnJlbnRCaXRyYXRlS2Jwc30pLHRoaXMubG93ZXN0RGVsdGE9dm9pZCAwfWxvd2VzdFN1cHBvcnRlZEJpdHJhdGVLYnBzKCl7cmV0dXJuIE51bWJlcihuZXcgVVJMU2VhcmNoUGFyYW1zKHdpbmRvdy5sb2NhdGlvbi5zZWFyY2gpLmdldChcImxvd2VzdC1iaXRyYXRlXCIpPz81ZTMpfWhpZ2hlc3RTdXBwb3J0ZWRCaXRyYXRlS2Jwcygpe3JldHVybiBOdW1iZXIobmV3IFVSTFNlYXJjaFBhcmFtcyh3aW5kb3cubG9jYXRpb24uc2VhcmNoKS5nZXQoXCJtYXgtYml0cmF0ZVwiKT8/MWU0KX19ZnVuY3Rpb24gV0koQSl7Y29uc3R7ZmlsdGVyZWQ6SSxwcmVmZXJyZWQ6Z309ZnVuY3Rpb24oQSl7aWYoMD09PUEubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcIkhvc3Qgc3VwcGxpZWQgYW4gZW1wdHkgQ29kZWNQYWNrXCIpO2xldCBJPUEuZmlsdGVyKHZJKTtpZigwPT09SS5sZW5ndGgmJihjb25zb2xlLndhcm4oXCJGb3VuZCBubyBicm93c2VyLWNvbmZpcm1lZCB3b3JraW5nIGNvZGVjLCBmYWxsaW5nIGJhY2sgdG8gYmFzZWxpbmVcIiksST1BLmZpbHRlcigoQT0+YkkoQSk8PXRBLkJhc2VsaW5lKSkpLDA9PT1JLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJIb3N0IHN1cHBsaWVkIGFuIHVuc3VwcG9ydGVkIENvZGVjUGFja1wiKTtjb25zdCBnPUkucmVkdWNlKCgoQSxJKT0+YkkoQSk+YkkoSSk/QTpJKSk7cmV0dXJue2ZpbHRlcmVkOkkscHJlZmVycmVkOmd9fShBKSxCPXtjb2RlYzpoQS5PcHVzLGNvbnRhaW5lcjpkQS5SYXd9LFE9XCJNZWRpYVNvdXJjZVwiaW4gd2luZG93P2NBLklzb0JNRkY6Y0EuUmF3LEM9ISF3aW5kb3cuY2hyb21lO3JldHVybntwcmVmZXJyZWRXaWR0aDpzY3JlZW4uYXZhaWxXaWR0aCxwcmVmZXJyZWRIZWlnaHQ6c2NyZWVuLmF2YWlsSGVpZ2h0LHByZWZlcnJlZEZwczo2MCxwcmVmZXJyZWRBdWRpb0JpdHJhdGU6OTZlMyxwcmVmZXJyZWRWaWRlb0JpdHJhdGU6MWUzKlBJLmluaXRpYWxCaXRyYXRlS2JwcyxwcmVmZXJyZWRBdWRpb0NoYW5uZWxzOnJBLlN0ZXJlbyxwcmVmZXJyZWRBdWRpb0NvbmZpZzpCLHByZWZlcnJlZFZpZGVvQ29uZmlnOntjb2RlYzpnLGNvbnRhaW5lcjpRfSxzdXBwb3J0ZWRBdWRpb0NoYW5uZWxzOltyQS5Nb25vLHJBLlN0ZXJlb10sc3VwcG9ydGVkQXVkaW9Db25maWdzOltCXSxzdXBwb3J0ZWRWaWRlb0NvbmZpZ3M6SS5tYXAoKEE9Pih7Y29kZWM6QSxjb250YWluZXI6UX0pKSksc3VwcG9ydHNPdmVyMTA4MFA6ITEsc3VwcG9ydHNUZW1wb3JhbFNjYWxpbmc6ITAsc3VwcG9ydHNBcHBJc29sYXRpb246Q319dmFyIFRJO2NsYXNzIE9JIGV4dGVuZHMgRXJyb3J7fWFzeW5jIGZ1bmN0aW9uIFhJKEEsSSl7aWYoIXdpbmRvdy5NZWRpYVNvdXJjZSl0aHJvdyBuZXcgT0koXCJCcm93c2VyIGRvZXMgbm90IHN1cHBvcnQgTVNFLlwiKTtjb25zdCBnPW5ldyBNZWRpYVNvdXJjZSxCPXdpbmRvdy5VUkwuY3JlYXRlT2JqZWN0VVJMKGcpO0Euc3JjPXZvaWQgMCxBLnNyYz1CLEEubG9hZCgpO2NvbnN0IFE9YXdhaXQgYXN5bmMgZnVuY3Rpb24oQSxJKXtyZXR1cm4gbmV3IFByb21pc2UoKChnLEIpPT57bGV0IFE9ITE7Y29uc3QgQz0oKT0+e0EucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInNvdXJjZW9wZW5cIixlKSxJPy5yZW1vdmVIYW5kbGVyKEUpLHdpbmRvdy5jbGVhckludGVydmFsKHQpLFE9ITB9LGU9KCk9PntDKCksZyghMCl9LGk9KCk9PntRfHxcIm9wZW5cIj09PUEucmVhZHlTdGF0ZSYmKEMoKSxnKCEwKSl9LHQ9d2luZG93LnNldEludGVydmFsKGksNTAwKTtpKCksd2luZG93LnNldFRpbWVvdXQoKCgpPT57UXx8KEMoKSxCKG5ldyBFcnJvcihcIk1lZGlhU291cmNlIG9wZW4gdGltZWQgb3V0LlwiKSkpfSksMWU0KSxBLmFkZEV2ZW50TGlzdGVuZXIoXCJzb3VyY2VvcGVuXCIsZSk7Y29uc3QgRT0oKT0+e0MoKSxnKCExKX07ST8uYWRkSGFuZGxlcihFKX0pKX0oZyxJKTtpZihRKXJldHVybiBnLmR1cmF0aW9uPU51bWJlci5QT1NJVElWRV9JTkZJTklUWSxnfWZ1bmN0aW9uIFZJKEEpe3JldHVybiAwPT09QS5sZW5ndGg/MDpBLnJlZHVjZSgoKEEsSSk9PkErSSksMCkvQS5sZW5ndGh9Y2xhc3Mgakl7Y29uc3RydWN0b3IoQSl7dGhpcy5tYXhMZW5ndGg9QSx0aGlzLm5leHRJbmRleD0wLHRoaXMubGlzdD1BcnJheSh0aGlzLm1heExlbmd0aCksVEkuc2V0KHRoaXMsMCl9Z2V0IGxlbmd0aCgpe3JldHVybiBnKHRoaXMsVEksXCJmXCIpfXB1c2goQSl7dGhpcy5saXN0W3RoaXMubmV4dEluZGV4KytdPUEsQih0aGlzLFRJLE1hdGgubWF4KGcodGhpcyxUSSxcImZcIiksdGhpcy5uZXh0SW5kZXgpLFwiZlwiKSx0aGlzLm5leHRJbmRleCU9dGhpcy5tYXhMZW5ndGh9dmFsdWVzKCl7cmV0dXJuIHRoaXMubGlzdC5zbGljZSgwLGcodGhpcyxUSSxcImZcIikpfX1UST1uZXcgV2Vha01hcDtjbGFzcyBaSXtjb25zdHJ1Y3Rvcigpe3RoaXMucHJvY2Vzc2luZ0R1cmF0aW9ucz1uZXcgTWFwLHRoaXMuZGF0YUludGVydmFscz1uZXcgakkoNjApLHRoaXMuZGF0YVNpemVzPW5ldyBqSSg2MCksdGhpcy50b3RhbEZyYW1lcz0wLHRoaXMucHJlc2VudGVkRnJhbWVzPTB9cHVzaEZyYW1lTWV0YWRhdGEoQSl7dGhpcy5wcmVzZW50ZWRGcmFtZXMrPTE7Y29uc3R7cHJvY2Vzc2luZ0R1cmF0aW9uOkl9PUEsZz0obmV3IERhdGUpLmdldFRpbWUoKTt0aGlzLnByb2Nlc3NpbmdEdXJhdGlvbnMuc2V0KGcsSSk7Zm9yKGNvbnN0W0Fdb2YgdGhpcy5wcm9jZXNzaW5nRHVyYXRpb25zLmVudHJpZXMoKSlBPGctMWUzJiZ0aGlzLnByb2Nlc3NpbmdEdXJhdGlvbnMuZGVsZXRlKEEpfXJlcG9ydEZyYW1lU3VibWl0dGVkKCl7dGhpcy50b3RhbEZyYW1lcys9MX1yZXNldEZyYW1lQ291bnRzKCl7dGhpcy50b3RhbEZyYW1lcz0wLHRoaXMucHJlc2VudGVkRnJhbWVzPTB9cHVzaERhdGEoQSl7dGhpcy5kYXRhU2l6ZXMucHVzaChBLmJ5dGVMZW5ndGgpO2NvbnN0IEk9KG5ldyBEYXRlKS5nZXRUaW1lKCk7dGhpcy5sYXN0RGF0YVRpbWVzdGFtcCYmdGhpcy5kYXRhSW50ZXJ2YWxzLnB1c2goSS10aGlzLmxhc3REYXRhVGltZXN0YW1wKSx0aGlzLmxhc3REYXRhVGltZXN0YW1wPUl9c2V0RWxlbWVudChBKXt0aGlzLmVsZW1lbnQ9QX1nZXRSZXBvcnRNU0UoQSl7aWYoIXRoaXMuZWxlbWVudCl0aHJvdyBuZXcgUShcImdldFJlcG9ydCgpIGhhcyBubyB2aWRlbyBlbGVtZW50XCIpO2NvbnN0IEk9VkkoQXJyYXkuZnJvbSh0aGlzLnByb2Nlc3NpbmdEdXJhdGlvbnMudmFsdWVzKCkpKSxnPXRoaXMuZWxlbWVudC5idWZmZXJlZCxCPWcubGVuZ3RoPjA/Zy5lbmQoZy5sZW5ndGgtMSk6MCxDPXRoaXMuZWxlbWVudC5zZWVrYWJsZSxlPUMubGVuZ3RoPjA/Qy5lbmQoQy5sZW5ndGgtMSk6MDtyZXR1cm57cHJvY2Vzc2luZ0R1cmF0aW9uOkksZHJvcHBlZEZyYW1lczp0aGlzLnRvdGFsRnJhbWVzLXRoaXMucHJlc2VudGVkRnJhbWVzLHRvdGFsRnJhbWVzOnRoaXMudG90YWxGcmFtZXMsZGF0YUludGVydmFsOlZJKHRoaXMuZGF0YUludGVydmFscy52YWx1ZXMoKSksZGF0YVNpemU6VkkodGhpcy5kYXRhU2l6ZXMudmFsdWVzKCkpLGN1cnJlbnRUaW1lOnRoaXMuZWxlbWVudC5jdXJyZW50VGltZSxlbmRPZkJ1ZmZlcmVkOkIsZW5kT2ZTZWVrYWJsZTplLHZpZGVvUmVhZHlTdGF0ZTpBfX1nZXRSZXBvcnRTb2Z0d2FyZURlY29kZXIoQSxJLGcpe3JldHVybntwcm9jZXNzaW5nRHVyYXRpb246VkkoQXJyYXkuZnJvbSh0aGlzLnByb2Nlc3NpbmdEdXJhdGlvbnMudmFsdWVzKCkpKSxkcm9wcGVkRnJhbWVzOkE/PzAsdG90YWxGcmFtZXM6ST8/MCxkYXRhSW50ZXJ2YWw6VkkodGhpcy5kYXRhSW50ZXJ2YWxzLnZhbHVlcygpKSxkYXRhU2l6ZTpWSSh0aGlzLmRhdGFTaXplcy52YWx1ZXMoKSksY3VycmVudFRpbWU6MCxlbmRPZkJ1ZmZlcmVkOjAsZW5kT2ZTZWVrYWJsZTowLHZpZGVvUmVhZHlTdGF0ZTpnfX19ZnVuY3Rpb24gekkoQSl7cmV0dXJuIDEwMj09PUFbNF0mJjExNj09PUFbNV0mJjEyMT09PUFbNl0mJjExMj09PUFbN119Y2xhc3MgX0l7Y29uc3RydWN0b3IoQSl7dGhpcy5jb2RlY1N0cmluZz1BLHRoaXMucmVhZHlTdGF0ZT1OSS5EZXRhY2hlZCx0aGlzLm5lZWRzUmVzdGFydEV2ZW50PW5ldyBfQSx0aGlzLnNvdXJjZU9wZW5FdmVudD1uZXcgX0EsdGhpcy5yZWFkeVN0YXRlQ2hhbmdlRXZlbnQ9bmV3IF9BLHRoaXMudmlkZW9GcmFtZUV2ZW50PW5ldyBfQSx0aGlzLnZpZGVvRnJhbWVQcm9jZXNzaW5nRHVyYXRpb25FdmVudD1uZXcgX0EsdGhpcy5jYW5jZWxJbml0aWFsaXplRXZlbnQ9bmV3IF9BLHRoaXMuZGF0YVF1ZXVlPVtdLHRoaXMuc3RhdHM9bmV3IFpJLHRoaXMuanVzdENsZWFyZWRCdWZmZXI9ITEsdGhpcy5sYXN0QnVmZmVyRW5kPTAsdGhpcy5mcmFtZXNGcm96ZW5Gb3I9MCx0aGlzLmVuc3VyZUJ1ZmZlcj0oKT0+e2lmKHRoaXMucmVhZHlTdGF0ZSE9PU5JLlBhdXNlZCYmdGhpcy5yZWFkeVN0YXRlIT09TkkuRGV0YWNoZWQmJnRoaXMuZWxlbWVudCYmMD09PXRoaXMuZWxlbWVudC5idWZmZXJlZC5sZW5ndGgpe2lmKHRoaXMuc291cmNlQnVmZmVyJiYhdGhpcy5zb3VyY2VCdWZmZXIudXBkYXRpbmcmJnRoaXMuc291cmNlQnVmZmVyLnRpbWVzdGFtcE9mZnNldDw9MCl7Y29uc3QgQT10aGlzLnNvdXJjZUJ1ZmZlci50aW1lc3RhbXBPZmZzZXQudG9GaXhlZCgyKTt0aGlzLnNvdXJjZUJ1ZmZlci50aW1lc3RhbXBPZmZzZXQ9MTtjb25zdCBJPXRoaXMuc291cmNlQnVmZmVyLnRpbWVzdGFtcE9mZnNldC50b0ZpeGVkKDIpO3RoaXMud2FybihgUG9rZWQgdGltZXN0YW1wT2Zmc2V0IGZyb20gJHtBfSB0byAke0l9YCl9dGhpcy5yZXN0YXJ0KFwiZW5zdXJlQnVmZmVyXCIpfX0sdGhpcy52aWRlb0ZyYW1lSGFuZGxlcj0oQSxJKT0+e0k/LnByb2Nlc3NpbmdEdXJhdGlvbiYmdGhpcy52aWRlb0ZyYW1lUHJvY2Vzc2luZ0R1cmF0aW9uRXZlbnQuaW52b2tlKEkucHJvY2Vzc2luZ0R1cmF0aW9uKSxJJiZ0aGlzLnN0YXRzLnB1c2hGcmFtZU1ldGFkYXRhKEkpLHRoaXMudmlkZW9GcmFtZUV2ZW50Lmludm9rZShbQSxJXSksdGhpcy5yZXF1ZXN0TmV4dEZyYW1lQ2FsbGJhY2soKX0sdGhpcy5mYWxsYmFja1ZpZGVvRnJhbWVIYW5kbGVyPUE9Pnt0aGlzLnZpZGVvRnJhbWVIYW5kbGVyKEEsdm9pZCAwKX0sdGhpcy5zb3VyY2VCdWZmZXJVcGRhdGVIYW5kbGVyPSgpPT57dGhpcy5zdWJtaXREYXRhKCl9fWluZm8oQSl7QkkoX0kubmFtZSxTdHJpbmcoQSkpfWRlYnVnKEEpe1FJKF9JLm5hbWUsU3RyaW5nKEEpKX13YXJuKEEpe2dJKF9JLm5hbWUsU3RyaW5nKEEpKX1nZXQgZGF0YVF1ZXVlTGVuZ3RoKCl7cmV0dXJuIHRoaXMuZGF0YVF1ZXVlLmxlbmd0aH1hdHRhY2hUb0VsZW1lbnQoQSl7dGhpcy5pbmZvKFwiQXR0YWNoaW5nIHRvIGVsZW1lbnQ6IFwiK0EpLHRoaXMuY2FuY2VsSW5pdGlhbGl6ZUV2ZW50Lmludm9rZSgpLHRoaXMuZWxlbWVudD1BLHRoaXMuc3RhdHMuc2V0RWxlbWVudCh0aGlzLmVsZW1lbnQpLHRoaXMuc3RhdHMucmVzZXRGcmFtZUNvdW50cygpLHRoaXMucmVzdGFydChcImF0dGFjaFRvRWxlbWVudFwiKSx0aGlzLmluZm8oXCJBdHRhY2hlZCB0byBlbGVtZW50LlwiKX1kZXRhY2hGcm9tRWxlbWVudCgpe3RoaXMuZGVzdHJveU1lZGlhKCksdGhpcy5lbGVtZW50PXZvaWQgMCx0aGlzLnNldFJlYWR5U3RhdGUoTkkuRGV0YWNoZWQpLHRoaXMuaW5mbyhcIkRldGFjaGVkIGZyb20gZWxlbWVudC5cIil9cGF1c2UoKXt0aGlzLnNldFJlYWR5U3RhdGUoTkkuUGF1c2VkKX1wbGF5KCl7dGhpcy5yZWFkeVN0YXRlPT09TkkuUGF1c2VkJiZ0aGlzLnJlc3RhcnQoXCJwbGF5XCIpfXB1c2hEYXRhKEEpe2lmKHRoaXMuZGF0YVF1ZXVlLmxlbmd0aD44KXJldHVybiB2b2lkIHRoaXMucmVzdGFydChcInB1c2hEYXRhLmRhdGFRdWV1ZSB0b28gbG9uZ1wiKTtjb25zdCBJPW5ldyBVaW50OEFycmF5KEEuZGF0YSk7cmV0dXJuIHRoaXMuc3RhdHMucHVzaERhdGEoSSksdGhpcy5yZWFkeVN0YXRlIT09TkkuUGF1c2VkP3pJKEkpJiZ0aGlzLnJlYWR5U3RhdGU9PT1OSS5XYWl0aW5nRm9yS2V5ZnJhbWUmJnRoaXMuZWxlbWVudD8odGhpcy5kZWJ1ZyhgR290IHJlcXVlc3RlZCBrZXlmcmFtZSAoJHtJLmxlbmd0aH0gYnl0ZXMpYCksdGhpcy5nZXRTdGF0cygpLHRoaXMuZGF0YVF1ZXVlLnB1c2goSSksdGhpcy5zdWJtaXREYXRhKCksdm9pZCB0aGlzLmluaXRpYWxpemVNZWRpYSgpKTp2b2lkKHRoaXMucmVhZHlTdGF0ZSE9PU5JLldhaXRpbmdGb3JLZXlmcmFtZSYmdGhpcy5lbGVtZW50Pyh0aGlzLmRhdGFRdWV1ZS5wdXNoKEkpLHRoaXMuc3VibWl0RGF0YSgpKTp0aGlzLnN0YXJ0RW5zdXJpbmdCdWZmZXIoKSk6dm9pZCAwfWdldFN0YXRzKCl7cmV0dXJuIHRoaXMuc3RhdHMuZ2V0UmVwb3J0TVNFKHRoaXMucmVhZHlTdGF0ZSl9c2V0UmVhZHlTdGF0ZShBKXt0aGlzLmluZm8oYFJlYWR5U3RhdGUgY2hhbmdlZDogJHtOSVt0aGlzLnJlYWR5U3RhdGVdfSA9PiAke05JW0FdfWApLHRoaXMucmVhZHlTdGF0ZT1BLHRoaXMucmVhZHlTdGF0ZUNoYW5nZUV2ZW50Lmludm9rZShBKX1zdWJtaXREYXRhKCl7aWYoMCE9PXRoaXMuZGF0YVF1ZXVlLmxlbmd0aClpZih2b2lkIDAhPT10aGlzLm1lZGlhU291cmNlKWlmKHRoaXMuc291cmNlQnVmZmVyKXtpZighdGhpcy5zb3VyY2VCdWZmZXIudXBkYXRpbmcpaWYodGhpcy5lbGVtZW50KXtpZih0aGlzLnNvdXJjZUJ1ZmZlci5idWZmZXJlZC5sZW5ndGg+PTEpe2NvbnN0IEE9dGhpcy5zb3VyY2VCdWZmZXIuYnVmZmVyZWQuZW5kKHRoaXMuc291cmNlQnVmZmVyLmJ1ZmZlcmVkLmxlbmd0aC0xKTt0aGlzLmp1c3RDbGVhcmVkQnVmZmVyJiYodGhpcy5lbGVtZW50LmN1cnJlbnRUaW1lPUEsdGhpcy5qdXN0Q2xlYXJlZEJ1ZmZlcj0hMSksQT09PXRoaXMubGFzdEJ1ZmZlckVuZD8odGhpcy5mcmFtZXNGcm96ZW5Gb3IrKyx0aGlzLmRlYnVnKGBGcm96ZW4gZm9yICR7dGhpcy5mcmFtZXNGcm96ZW5Gb3J9IGZyYW1lcy4uLmApKTp0aGlzLmZyYW1lc0Zyb3plbkZvcj0wLHRoaXMubGFzdEJ1ZmZlckVuZD1BfWlmKHRoaXMuZnJhbWVzRnJvemVuRm9yPj00KXJldHVybiB0aGlzLnJlc3RhcnQoXCJzb3VyY2VCdWZmZXIgRnJvemVuRnJhbWVzXCIpLHZvaWQodGhpcy5mcmFtZXNGcm96ZW5Gb3I9MCk7dHJ5e2NvbnN0IEE9dGhpcy5kYXRhUXVldWVbMF07aWYoekkoQSkmJiF0aGlzLmp1c3RDbGVhcmVkQnVmZmVyKXJldHVybiB0aGlzLmRlYnVnKFwiR290IGtleWZyYW1lLiBDbGVhcmluZyBzb3VyY2VidWZmZXIuXCIpLHRoaXMuZ2V0U3RhdHMoKSx0aGlzLnNvdXJjZUJ1ZmZlci5yZW1vdmUoMCwxLzApLHZvaWQodGhpcy5qdXN0Q2xlYXJlZEJ1ZmZlcj0hMCk7dGhpcy5kYXRhUXVldWUuc2hpZnQoKSx0aGlzLnNvdXJjZUJ1ZmZlci5hcHBlbmRCdWZmZXIoQSksdGhpcy5zdGF0cy5yZXBvcnRGcmFtZVN1Ym1pdHRlZCgpfWNhdGNoKEEpe0lJKF9JLm5hbWUsU3RyaW5nKEEpKSx0aGlzLnJlc3RhcnQoXCJzdWJtaXREYXRhLCBzb3VyY2VCdWZmZXIuYXBwZW5kQnVmZmVyIGVycm9yLlwiKX19ZWxzZSB0aGlzLmRlYnVnKFwiSWRsaW5nIGJlY2F1c2UgIWVsZW1lbnRcIil9ZWxzZSB0aGlzLmRlYnVnKFwiSWRsaW5nIGJlY2F1c2UgIXNvdXJjZUJ1ZmZlclwiKTtlbHNlIHRoaXMuZGVidWcoXCJJZGxpbmcgYmVjYXVzZSBtZWRpYVNvdXJjZSA9PT0gdW5kZWZpbmVkXCIpfWFzeW5jIGluaXRpYWxpemVNZWRpYSgpe2lmKHRoaXMuc2V0UmVhZHlTdGF0ZShOSS5Jbml0aWFsaXppbmcpLHRoaXMuY2FuY2VsSW5pdGlhbGl6ZUV2ZW50Lmludm9rZSgpLHZvaWQgMCE9PXRoaXMubWVkaWFTb3VyY2UpcmV0dXJuIHRoaXMuc2V0UmVhZHlTdGF0ZShOSS5QbGF5aW5nKSx2b2lkIHRoaXMuZWxlbWVudD8ucGxheSgpO2lmKCF0aGlzLmVsZW1lbnQpdGhyb3cgbmV3IEVycm9yKFwiU3RyZWFtIG5vdCBhdHRhY2hlZCB0byBlbGVtZW50LlwiKTt0cnl7Y29uc3QgQT1hd2FpdCBYSSh0aGlzLmVsZW1lbnQsdGhpcy5jYW5jZWxJbml0aWFsaXplRXZlbnQpO2lmKCFBKXJldHVybiB2b2lkIHRoaXMuc2V0UmVhZHlTdGF0ZShOSS5XYWl0aW5nRm9yS2V5ZnJhbWUpO3RoaXMubWVkaWFTb3VyY2U9QSx0aGlzLnNvdXJjZUJ1ZmZlcj1mdW5jdGlvbihBLEkpe2NvbnN0IGc9QS5hZGRTb3VyY2VCdWZmZXIoSSk7cmV0dXJuIGcubW9kZT1cInNlcXVlbmNlXCIsZ30odGhpcy5tZWRpYVNvdXJjZSx0aGlzLmNvZGVjU3RyaW5nKSx0aGlzLnNvdXJjZUJ1ZmZlci5hZGRFdmVudExpc3RlbmVyKFwidXBkYXRlZW5kXCIsdGhpcy5zb3VyY2VCdWZmZXJVcGRhdGVIYW5kbGVyKSx0aGlzLnNvdXJjZUJ1ZmZlci5hZGRFdmVudExpc3RlbmVyKFwiZXJyb3JcIiwoQT0+dGhpcy5kZWJ1Zyhgc291cmNlQnVmZmVyIGVycm9yOiAke0F9YCkpKSx0aGlzLnN0YXJ0RW5zdXJpbmdCdWZmZXIoKSx0aGlzLnNldFJlYWR5U3RhdGUoTkkuUGxheWluZyksdGhpcy5yZXF1ZXN0TmV4dEZyYW1lQ2FsbGJhY2soKSx0aGlzLnN1Ym1pdERhdGEoKSx0aGlzLmVsZW1lbnQ/LnBsYXkoKX1jYXRjaChBKXt0aGlzLnNldFJlYWR5U3RhdGUoTkkuV2FpdGluZ0ZvcktleWZyYW1lKX19c3RhcnRFbnN1cmluZ0J1ZmZlcigpe3ZvaWQgMD09PXRoaXMuZW5zdXJlQnVmZmVySW50ZXJ2YWwmJih0aGlzLmRlYnVnKFwiU3RhcnRpbmcgZW5zdXJlQnVmZmVyIGxvb3BcIiksdGhpcy5lbnN1cmVCdWZmZXJJbnRlcnZhbD13aW5kb3cuc2V0SW50ZXJ2YWwodGhpcy5lbnN1cmVCdWZmZXIsMWUzKSl9ZGVzdHJveU1lZGlhKCl7aWYodGhpcy5kZWJ1ZyhcImRlc3Ryb3lNZWRpYSgpIGNhbGxlZFwiKSx2b2lkIDAhPT10aGlzLm1lZGlhU291cmNlKXtpZih0aGlzLmNhbmNlbEZyYW1lQ2FsbGJhY2soKSx0aGlzLmVsZW1lbnQ/LnBhdXNlKCksdGhpcy5zb3VyY2VCdWZmZXI/LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ1cGRhdGVlbmRcIix0aGlzLnNvdXJjZUJ1ZmZlclVwZGF0ZUhhbmRsZXIpLHRoaXMubWVkaWFTb3VyY2Upe2lmKHRoaXMuc291cmNlQnVmZmVyKXt0cnl7dGhpcy5tZWRpYVNvdXJjZS5yZW1vdmVTb3VyY2VCdWZmZXIodGhpcy5zb3VyY2VCdWZmZXIpfWNhdGNoKEEpe310aGlzLnNvdXJjZUJ1ZmZlcj12b2lkIDB9aWYoXCJvcGVuXCI9PT10aGlzLm1lZGlhU291cmNlLnJlYWR5U3RhdGUpdHJ5e3RoaXMubWVkaWFTb3VyY2UuZW5kT2ZTdHJlYW0oKX1jYXRjaChBKXt9dGhpcy5tZWRpYVNvdXJjZT12b2lkIDAsdGhpcy5lbGVtZW50JiZ3aW5kb3cuVVJMLnJldm9rZU9iamVjdFVSTCh0aGlzLmVsZW1lbnQuc3JjKX13aW5kb3cuY2xlYXJJbnRlcnZhbCh0aGlzLmVuc3VyZUJ1ZmZlckludGVydmFsKSx0aGlzLmVuc3VyZUJ1ZmZlckludGVydmFsPXZvaWQgMCx0aGlzLnNldFJlYWR5U3RhdGUoTkkuV2FpdGluZ0ZvcktleWZyYW1lKX19cmVzdGFydChBPVwiXCIpe2NvbnN0IEk9QT9gUmVzdGFydGluZyBWaWRlbyBTdHJlYW0uLi4gUmVhc29uOiAnJHtBfScuYDpcIlJlc3RhcnRpbmcgVmlkZW8gU3RyZWFtLlwiO3RoaXMud2FybihJKSx0aGlzLmRhdGFRdWV1ZT1bXSx0aGlzLnNldFJlYWR5U3RhdGUoTkkuV2FpdGluZ0ZvcktleWZyYW1lKSx0aGlzLm5lZWRzUmVzdGFydEV2ZW50Lmludm9rZSgpfXJlcXVlc3ROZXh0RnJhbWVDYWxsYmFjaygpe1wicmVxdWVzdFZpZGVvRnJhbWVDYWxsYmFja1wiaW4gSFRNTFZpZGVvRWxlbWVudC5wcm90b3R5cGU/KHRoaXMuZnJhbWVIYW5kbGUmJih0aGlzLmVsZW1lbnQ/LmNhbmNlbFZpZGVvRnJhbWVDYWxsYmFjaz8uKHRoaXMuZnJhbWVIYW5kbGUpLHRoaXMuZnJhbWVIYW5kbGU9dm9pZCAwKSx0aGlzLmZyYW1lSGFuZGxlPXRoaXMuZWxlbWVudD8ucmVxdWVzdFZpZGVvRnJhbWVDYWxsYmFjaz8uKHRoaXMudmlkZW9GcmFtZUhhbmRsZXIpKToodGhpcy5mcmFtZUhhbmRsZSYmKHdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZSh0aGlzLmZyYW1lSGFuZGxlKSx0aGlzLmZyYW1lSGFuZGxlPXZvaWQgMCksdGhpcy5mcmFtZUhhbmRsZT13aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRoaXMuZmFsbGJhY2tWaWRlb0ZyYW1lSGFuZGxlcikpfWNhbmNlbEZyYW1lQ2FsbGJhY2soKXtcInJlcXVlc3RWaWRlb0ZyYW1lQ2FsbGJhY2tcImluIEhUTUxWaWRlb0VsZW1lbnQucHJvdG90eXBlP3RoaXMuZnJhbWVIYW5kbGUmJih0aGlzLmVsZW1lbnQ/LmNhbmNlbFZpZGVvRnJhbWVDYWxsYmFjaz8uKHRoaXMuZnJhbWVIYW5kbGUpLHRoaXMuZnJhbWVIYW5kbGU9dm9pZCAwKTp0aGlzLmZyYW1lSGFuZGxlJiYod2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMuZnJhbWVIYW5kbGUpLHRoaXMuZnJhbWVIYW5kbGU9dm9pZCAwKX1kaXNwb3NlKCl7dGhpcy5jYW5jZWxGcmFtZUNhbGxiYWNrKCksdGhpcy5kZXN0cm95TWVkaWEoKSx3aW5kb3cuY2xlYXJJbnRlcnZhbCh0aGlzLmVuc3VyZUJ1ZmZlckludGVydmFsKSx0aGlzLnNldFJlYWR5U3RhdGUoTkkuRGlzcG9zZWQpfX1mdW5jdGlvbiAkSShBKXtyZXR1cm4gQSYmQS5fX2VzTW9kdWxlJiZPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoQSxcImRlZmF1bHRcIik/QS5kZWZhdWx0OkF9dmFyIEFnPXtleHBvcnRzOnt9fTtzZWxmO3ZhciBJZz0kSShBZy5leHBvcnRzPSgoKT0+e3ZhciBBPXsxMTQ6ZnVuY3Rpb24oQSxJLGcpe3ZhciBCPXRoaXMmJnRoaXMuX19pbXBvcnREZWZhdWx0fHxmdW5jdGlvbihBKXtyZXR1cm4gQSYmQS5fX2VzTW9kdWxlP0E6e2RlZmF1bHQ6QX19O09iamVjdC5kZWZpbmVQcm9wZXJ0eShJLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO2NvbnN0IFE9QihnKDI4OSkpO0kuZGVmYXVsdD1jbGFzc3tpbml0aWFsaXplKCl7cmV0dXJuIG5ldyBQcm9taXNlKCgoQSxJKT0+e3RoaXMud29ya2VyPW5ldyBRLmRlZmF1bHQsdGhpcy53b3JrZXIuYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwoST0+e3ZhciBnO2NvbnN0IEI9SS5kYXRhO1wiZGVjb2RlclJlYWR5XCI9PT1CLnR5cGU/QSgwKTpcImRlY29kZURvbmVcIj09PUIudHlwZSYmKG51bGw9PT0oZz10aGlzLm9uRGVjb2RlKXx8dm9pZCAwPT09Z3x8Zy5jYWxsKHRoaXMsQikpfSkpfSkpfXN0YXJ0U3RyZWFtKEEsSSxnKXt0aGlzLndvcmtlciYmdGhpcy53b3JrZXIucG9zdE1lc3NhZ2Uoe3R5cGU6XCJzdGFydFN0cmVhbVwiLHNhbXBsZVJhdGVIejpBLGNoYW5uZWxDb3VudDpJLGRlY29kZWRTYW1wbGVzUGVyRnJhbWU6Z30pfXN0b3BTdHJlYW0oKXt0aGlzLndvcmtlciYmdGhpcy53b3JrZXIucG9zdE1lc3NhZ2Uoe3R5cGU6XCJzdG9wU3RyZWFtXCJ9KX1kZWNvZGUoQSxJKXt0aGlzLndvcmtlciYmdGhpcy53b3JrZXIucG9zdE1lc3NhZ2Uoe3R5cGU6XCJkZWNvZGVcIixzdGFydFRpbWVzdGFtcDpBLGlucHV0RGF0YTpJfSxbSV0pfXJlbGVhc2UoKXt0aGlzLndvcmtlciYmdGhpcy53b3JrZXIucG9zdE1lc3NhZ2Uoe3R5cGU6XCJyZWxlYXNlXCJ9KX1kaXNwb3NlKCl7dGhpcy53b3JrZXImJih0aGlzLndvcmtlci50ZXJtaW5hdGUoKSx0aGlzLndvcmtlcj12b2lkIDApfX19LDI4OTooQSxJLGcpPT57Zy5yKEkpLGcuZChJLHtkZWZhdWx0OigpPT5DfSk7dmFyIEI9Zyg2MTQpLFE9Zy5uKEIpO2Z1bmN0aW9uIEMoKXtyZXR1cm4gUSgpKCcoKCk9Pnt2YXIgQT17MzA1OkE9Pnt2YXIgSSxnPShJPVwidW5kZWZpbmVkXCIhPXR5cGVvZiBkb2N1bWVudCYmZG9jdW1lbnQuY3VycmVudFNjcmlwdD9kb2N1bWVudC5jdXJyZW50U2NyaXB0LnNyYzp2b2lkIDAsZnVuY3Rpb24oQSl7dmFyIGcsQjsoQT12b2lkIDAhPT0oQT1BfHx7fSk/QTp7fSkucmVhZHk9bmV3IFByb21pc2UoKGZ1bmN0aW9uKEEsSSl7Zz1BLEI9SX0pKTt2YXIgUSxDPXt9O2ZvcihRIGluIEEpQS5oYXNPd25Qcm9wZXJ0eShRKSYmKENbUV09QVtRXSk7dmFyIEU9W10saT1cIi4vdGhpcy5wcm9ncmFtXCIsRD1mdW5jdGlvbihBLEkpe3Rocm93IEl9LG89XCJcIjtcInVuZGVmaW5lZFwiIT10eXBlb2YgZG9jdW1lbnQmJmRvY3VtZW50LmN1cnJlbnRTY3JpcHQmJihvPWRvY3VtZW50LmN1cnJlbnRTY3JpcHQuc3JjKSxJJiYobz1JKSxvPTAhPT1vLmluZGV4T2YoXCJibG9iOlwiKT9vLnN1YnN0cigwLG8ubGFzdEluZGV4T2YoXCIvXCIpKzEpOlwiXCI7dmFyIHcsRixHPUEucHJpbnR8fGNvbnNvbGUubG9nLmJpbmQoY29uc29sZSksUj1BLnByaW50RXJyfHxjb25zb2xlLndhcm4uYmluZChjb25zb2xlKTtmb3IoUSBpbiBDKUMuaGFzT3duUHJvcGVydHkoUSkmJihBW1FdPUNbUV0pO0M9bnVsbCxBLmFyZ3VtZW50cyYmKEU9QS5hcmd1bWVudHMpLEEudGhpc1Byb2dyYW0mJihpPUEudGhpc1Byb2dyYW0pLEEucXVpdCYmKEQ9QS5xdWl0KSxBLndhc21CaW5hcnkmJih3PUEud2FzbUJpbmFyeSksQS5ub0V4aXRSdW50aW1lJiYoRj1BLm5vRXhpdFJ1bnRpbWUpLFwib2JqZWN0XCIhPXR5cGVvZiBXZWJBc3NlbWJseSYmbihcIm5vIG5hdGl2ZSB3YXNtIHN1cHBvcnQgZGV0ZWN0ZWRcIik7dmFyIFM9ITE7ZnVuY3Rpb24gVShJKXt2YXIgZyxCPUFbXCJfXCIrSV07cmV0dXJuIGc9XCJDYW5ub3QgY2FsbCB1bmtub3duIGZ1bmN0aW9uIFwiK0krXCIsIG1ha2Ugc3VyZSBpdCBpcyBleHBvcnRlZFwiLEJ8fG4oXCJBc3NlcnRpb24gZmFpbGVkOiBcIitnKSxCfWZ1bmN0aW9uIGEoQSxJLGcsQixRKXt2YXIgQz17c3RyaW5nOmZ1bmN0aW9uKEEpe3ZhciBJPTA7aWYobnVsbCE9QSYmMCE9PUEpe3ZhciBnPTErKEEubGVuZ3RoPDwyKTshZnVuY3Rpb24oQSxJLGcpe0ooQSxrLEksZyl9KEEsST1WKGcpLGcpfXJldHVybiBJfSxhcnJheTpmdW5jdGlvbihBKXt2YXIgSSxnLEI9VihBLmxlbmd0aCk7cmV0dXJuIEk9QSxnPUIscy5zZXQoSSxnKSxCfX0sRT1VKEEpLGk9W10sRD0wO2lmKEIpZm9yKHZhciBvPTA7bzxCLmxlbmd0aDtvKyspe3ZhciB3PUNbZ1tvXV07dz8oMD09PUQmJihEPVgoKSksaVtvXT13KEJbb10pKTppW29dPUJbb119dmFyIEY9RS5hcHBseShudWxsLGkpO3JldHVybiBGPWZ1bmN0aW9uKEEpe3JldHVyblwic3RyaW5nXCI9PT1JP0goQSk6XCJib29sZWFuXCI9PT1JP0Jvb2xlYW4oQSk6QX0oRiksMCE9PUQmJlooRCksRn12YXIgcyxrLGgsTj1cInVuZGVmaW5lZFwiIT10eXBlb2YgVGV4dERlY29kZXI/bmV3IFRleHREZWNvZGVyKFwidXRmOFwiKTp2b2lkIDA7ZnVuY3Rpb24geShBLEksZyl7Zm9yKHZhciBCPUkrZyxRPUk7QVtRXSYmIShRPj1CKTspKytRO2lmKFEtST4xNiYmQS5zdWJhcnJheSYmTilyZXR1cm4gTi5kZWNvZGUoQS5zdWJhcnJheShJLFEpKTtmb3IodmFyIEM9XCJcIjtJPFE7KXt2YXIgRT1BW0krK107aWYoMTI4JkUpe3ZhciBpPTYzJkFbSSsrXTtpZigxOTIhPSgyMjQmRSkpe3ZhciBEPTYzJkFbSSsrXTtpZigoRT0yMjQ9PSgyNDAmRSk/KDE1JkUpPDwxMnxpPDw2fEQ6KDcmRSk8PDE4fGk8PDEyfEQ8PDZ8NjMmQVtJKytdKTw2NTUzNilDKz1TdHJpbmcuZnJvbUNoYXJDb2RlKEUpO2Vsc2V7dmFyIG89RS02NTUzNjtDKz1TdHJpbmcuZnJvbUNoYXJDb2RlKDU1Mjk2fG8+PjEwLDU2MzIwfDEwMjMmbyl9fWVsc2UgQys9U3RyaW5nLmZyb21DaGFyQ29kZSgoMzEmRSk8PDZ8aSl9ZWxzZSBDKz1TdHJpbmcuZnJvbUNoYXJDb2RlKEUpfXJldHVybiBDfWZ1bmN0aW9uIEgoQSxJKXtyZXR1cm4gQT95KGssQSxJKTpcIlwifWZ1bmN0aW9uIEooQSxJLGcsQil7aWYoIShCPjApKXJldHVybiAwO2Zvcih2YXIgUT1nLEM9ZytCLTEsRT0wO0U8QS5sZW5ndGg7KytFKXt2YXIgaT1BLmNoYXJDb2RlQXQoRSk7aWYoaT49NTUyOTYmJmk8PTU3MzQzJiYoaT02NTUzNisoKDEwMjMmaSk8PDEwKXwxMDIzJkEuY2hhckNvZGVBdCgrK0UpKSxpPD0xMjcpe2lmKGc+PUMpYnJlYWs7SVtnKytdPWl9ZWxzZSBpZihpPD0yMDQ3KXtpZihnKzE+PUMpYnJlYWs7SVtnKytdPTE5MnxpPj42LElbZysrXT0xMjh8NjMmaX1lbHNlIGlmKGk8PTY1NTM1KXtpZihnKzI+PUMpYnJlYWs7SVtnKytdPTIyNHxpPj4xMixJW2crK109MTI4fGk+PjYmNjMsSVtnKytdPTEyOHw2MyZpfWVsc2V7aWYoZyszPj1DKWJyZWFrO0lbZysrXT0yNDB8aT4+MTgsSVtnKytdPTEyOHxpPj4xMiY2MyxJW2crK109MTI4fGk+PjYmNjMsSVtnKytdPTEyOHw2MyZpfX1yZXR1cm4gSVtnXT0wLGctUX1mdW5jdGlvbiBMKEEpe3ZhciBJPWZ1bmN0aW9uKEEpe2Zvcih2YXIgST0wLGc9MDtnPEEubGVuZ3RoOysrZyl7dmFyIEI9QS5jaGFyQ29kZUF0KGcpO0I+PTU1Mjk2JiZCPD01NzM0MyYmKEI9NjU1MzYrKCgxMDIzJkIpPDwxMCl8MTAyMyZBLmNoYXJDb2RlQXQoKytnKSksQjw9MTI3PysrSTpJKz1CPD0yMDQ3PzI6Qjw9NjU1MzU/Mzo0fXJldHVybiBJfShBKSsxLGc9VihJKTtyZXR1cm4gSihBLHMsZyxJKSxnfUEuSU5JVElBTF9NRU1PUlk7dmFyIHEsTT1bXSxLPVtdLGM9W10sWT1bXTtLLnB1c2goe2Z1bmM6ZnVuY3Rpb24oKXtsKCl9fSk7dmFyIGQ9MCxQPW51bGwsdD1udWxsO2Z1bmN0aW9uIG4oSSl7QS5vbkFib3J0JiZBLm9uQWJvcnQoSSksUihJKz1cIlwiKSxTPSEwLEk9XCJhYm9ydChcIitJK1wiKS4gQnVpbGQgd2l0aCAtcyBBU1NFUlRJT05TPTEgZm9yIG1vcmUgaW5mby5cIjt2YXIgZz1uZXcgV2ViQXNzZW1ibHkuUnVudGltZUVycm9yKEkpO3Rocm93IEIoZyksZ31BLnByZWxvYWRlZEltYWdlcz17fSxBLnByZWxvYWRlZEF1ZGlvcz17fTt2YXIgcj1cImRhdGE6YXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtO2Jhc2U2NCxcIjtmdW5jdGlvbiBmKEEpe3JldHVybiBJPUEsZz1yLFN0cmluZy5wcm90b3R5cGUuc3RhcnRzV2l0aD9JLnN0YXJ0c1dpdGgoZyk6MD09PUkuaW5kZXhPZihnKTt2YXIgSSxnfXZhciBXLGI9XCJkYXRhOmFwcGxpY2F0aW9uL29jdGV0LXN0cmVhbTtiYXNlNjQsQUdGemJRRUFBQUFCaEFNb1lBTi9mMzhCZjJBRGYzOS9BR0FFZjM5L2Z3QmdBWDhCZjJBQ2YzOEJmMkFGZjM5L2YzOEFZQUovZndCZ0IzOS9mMzkvZjM4QVlBWi9mMzkvZjM4QVlBRi9BR0FFZjM5L2Z3Ri9ZQVYvZjM5L2Z3Ri9ZQUFBWUFoL2YzOS9mMzkvZndCZ0NYOS9mMzkvZjM5L2Z3QmdCbjkvZjM5L2Z3Ri9ZQWQvZjM5L2YzOS9BWDlnQW41L0FYOWdCSDkvZjM4QmZXQUJmQUY4WUFKOGZBRjhZQXQvZjM5L2YzOS9mMzkvZndCZ0RYOS9mMzkvZjM5L2YzOS9mMzhBWUE1L2YzOS9mMzkvZjM5L2YzOS9md0JnRkg5L2YzOS9mMzkvZjM5L2YzOS9mMzkvZjM5L0FHQU1mMzkvZjM5OWZYOS9mMzkvQUdBRWYzOTlmd0JnQUFGL1lBaC9mMzkvZjM5L2Z3Ri9ZQXQvZjM5L2YzOS9mMzkvZndGL1lCQi9mMzkvZjM5L2YzOS9mMzkvZjM5L0FYOWdDMzkvZjM5L2YzOS9mWDkvQVg5Z0NYOS9mMzkvZjM5OWZ3Ri9ZQWQvZjM5L2YzOTlBWDlnQ1g5L2YzOS9mMzEvZndGL1lBWi9mSDkvZjM4QmYyQURmbjkvQVg5Z0FueC9BWDlnQTM5K2Z3RitZQUo4ZndGOEFoTURBV0VCWVFBS0FXRUJZZ0FBQVdFQll3QURBNThCblFFQUFBQUVBQWtFSHdNREJRQURBU0FPQ3ljREJBY1BHUUlHRHdRR0V3WUNGaFVkQmdNRkJRRUJBZ3NVR2dnQUFnd0ZDQUVCRUFNSEJBWUNBZ0lFQWdJS0hBTUNBZ1VBQUFBQkF3UVFGQk1CQkFFT0FRSVNBZ2dGQVFBQUFnTUNHQVFYQ0FZQkJRQURCUUFKQlFFQ0NBTUJEUUVCQVFFS0Fna0hCQVFMQUFBRUF3QURDUnNSRVNRRUFRRURCQVFtQXdBS0pRc2hBQ0lTQmg0REJ3ME1CQVVCY0FFRkJRVUdBUUdBQW9BQ0Jna0Jmd0ZCNElmQ0Fnc0hOZ3dCWkFJQUFXVUJBQUZtQURJQlp3Q2ZBUUZvQUlFQkFXa0FlQUZxQUhFQmF3QnNBV3dBWWdGdEFJWUJBVzRBaFFFQmJ3Q0VBUWtOQVFCQkFRc0VlNUVCa2dHUUFRcWQ3Z1dkQVlFQ0FRaC9JQUFvQWh3aUF5QUNkaUVISUFBb0FpQWhCRUYvSVFJRFFDQURJUVVnQkNBSElBRWdBa0VCYWlJQ2FpMEFBR3dpQTBrTkFBc2dBQ0FGSUFOcklnRTJBaHdnQUNBRUlBTnJJZ2cyQWlBZ0FVR0FnSUFFVFFSQUlBQW9BaGdoQmlBQUtBSW9JUVFnQUNnQ0ZDRUpJQUFvQWdRaENnTkFJQUFnQVVFSWRDSUhOZ0ljSUFBZ0NVRUlhaUlKTmdJVVFRQWhBeUFHSUFwSkJFQWdBQ0FHUVFGcUlnVTJBaGdnQUNnQ0FDQUdhaTBBQUNFRElBVWhCZ3NnQUNBRE5nSW9JQUFnQ0VFSWRFR0Evdi8vQjNFZ0F5QUVRUWgwY2tFQmRrSC9BWEZ5UWY4QmN5SUlOZ0lnSUFGQmdZQUNTU0VGSUFNaEJDQUhJUUVnQlEwQUN3c2dBZ3VDQkFFRGZ5QUNRWUFFVHdSQUlBQWdBU0FDRUFFYUlBQVBDeUFBSUFKcUlRTUNRQ0FBSUFGelFRTnhSUVJBQWtBZ0FrRUJTQVJBSUFBaEFnd0JDeUFBUVFOeFJRUkFJQUFoQWd3QkN5QUFJUUlEUUNBQ0lBRXRBQUE2QUFBZ0FVRUJhaUVCSUFKQkFXb2lBaUFEVHcwQklBSkJBM0VOQUFzTEFrQWdBMEY4Y1NJRVFjQUFTUTBBSUFJZ0JFRkFhaUlGU3cwQUEwQWdBaUFCS0FJQU5nSUFJQUlnQVNnQ0JEWUNCQ0FDSUFFb0FnZzJBZ2dnQWlBQktBSU1OZ0lNSUFJZ0FTZ0NFRFlDRUNBQ0lBRW9BaFEyQWhRZ0FpQUJLQUlZTmdJWUlBSWdBU2dDSERZQ0hDQUNJQUVvQWlBMkFpQWdBaUFCS0FJa05nSWtJQUlnQVNnQ0tEWUNLQ0FDSUFFb0FpdzJBaXdnQWlBQktBSXdOZ0l3SUFJZ0FTZ0NORFlDTkNBQ0lBRW9BamcyQWpnZ0FpQUJLQUk4TmdJOElBRkJRR3NoQVNBQ1FVQnJJZ0lnQlUwTkFBc0xJQUlnQkU4TkFRTkFJQUlnQVNnQ0FEWUNBQ0FCUVFScUlRRWdBa0VFYWlJQ0lBUkpEUUFMREFFTElBTkJCRWtFUUNBQUlRSU1BUXNnQUNBRFFRUnJJZ1JMQkVBZ0FDRUNEQUVMSUFBaEFnTkFJQUlnQVMwQUFEb0FBQ0FDSUFFdEFBRTZBQUVnQWlBQkxRQUNPZ0FDSUFJZ0FTMEFBem9BQXlBQlFRUnFJUUVnQWtFRWFpSUNJQVJORFFBTEN5QUNJQU5KQkVBRFFDQUNJQUV0QUFBNkFBQWdBVUVCYWlFQklBSkJBV29pQWlBRFJ3MEFDd3NnQUF2ekFnSUNmd0YrQWtBZ0FrVU5BQ0FBSUFKcUlnTkJBV3NnQVRvQUFDQUFJQUU2QUFBZ0FrRURTUTBBSUFOQkFtc2dBVG9BQUNBQUlBRTZBQUVnQTBFRGF5QUJPZ0FBSUFBZ0FUb0FBaUFDUVFkSkRRQWdBMEVFYXlBQk9nQUFJQUFnQVRvQUF5QUNRUWxKRFFBZ0FFRUFJQUJyUVFOeElnUnFJZ01nQVVIL0FYRkJnWUtFQ0d3aUFUWUNBQ0FESUFJZ0JHdEJmSEVpQkdvaUFrRUVheUFCTmdJQUlBUkJDVWtOQUNBRElBRTJBZ2dnQXlBQk5nSUVJQUpCQ0dzZ0FUWUNBQ0FDUVF4cklBRTJBZ0FnQkVFWlNRMEFJQU1nQVRZQ0dDQURJQUUyQWhRZ0F5QUJOZ0lRSUFNZ0FUWUNEQ0FDUVJCcklBRTJBZ0FnQWtFVWF5QUJOZ0lBSUFKQkdHc2dBVFlDQUNBQ1FSeHJJQUUyQWdBZ0JDQURRUVJ4UVJoeUlnUnJJZ0pCSUVrTkFDQUJyU0lGUWlDR0lBV0VJUVVnQXlBRWFpRUJBMEFnQVNBRk53TVlJQUVnQlRjREVDQUJJQVUzQXdnZ0FTQUZOd01BSUFGQklHb2hBU0FDUVNCcklnSkJIMHNOQUFzTElBQUw2d0VCQ1g4Z0FDZ0NJQ0lFSUFBb0Fod2lBaUFCZGlJQlNTSUdSUVJBSUFBZ0JDQUJheUlFTmdJZ0N5QUFJQUVnQWlBQmF5QUdHeUlGTmdJY0lBVkJnSUNBQkUwRVFDQUFLQUlZSVFNZ0FDZ0NLQ0VISUFBb0FoUWhDQ0FBS0FJRUlRa0RRQ0FBSUFWQkNIUWlDallDSENBQUlBaEJDR29pQ0RZQ0ZFRUFJUUVnQXlBSlNRUkFJQUFnQTBFQmFpSUNOZ0lZSUFBb0FnQWdBMm90QUFBaEFTQUNJUU1MSUFBZ0FUWUNLQ0FBSUFSQkNIUkJnUDcvL3dkeElBRWdCMEVJZEhKQkFYWkIvd0Z4Y2tIL0FYTWlCRFlDSUNBRlFZR0FBa2toQWlBQklRY2dDaUVGSUFJTkFBc0xJQVlMcndZQkJYOGpBRUVRYXlJREpBQWdBeUFDTmdJTVFYc2hBZ0pBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBZ0FVRzdIMnNPRlFFQ0Nnb0dDZ01LQ2dvS0Nnb0tDZ29LQ2dvSENBQUxBa0FDUUFKQUFrQWdBVUdYemdCckRnb0RBZzBBRFFFTkRRY0lEUXNnQXlBREtBSU1JZ0ZCQkdvMkFneEJmeUVDSUFFb0FnQWlBVUVBU0EwTUlBRWdBQ2dDQUNnQ0NFNE5EQ0FBSUFFMkFoUU1Dd3NnQXlBREtBSU1JZ0ZCQkdvMkFneEJmeUVDSUFFb0FnQWlBVUVCU0EwTElBRWdBQ2dDQUNnQ0NFb05DeUFBSUFFMkFoZ01DZ3NnQXlBREtBSU1JZ0ZCQkdvMkFneEJmeUVDSUFFb0FnQWlBVUVCYTBFQlN3MEtJQUFnQVRZQ0RBd0pDeUFESUFNb0Fnd2lBVUVFYWpZQ0RDQUJLQUlBSWdGRkJFQkJmeUVDREFvTElBRWdBQ2dDTERZQ0FFRUFJUUlnQUVFQU5nSXNEQWtMSUFNZ0F5Z0NEQ0lCUVFScU5nSU1JQUVvQWdBaUFVVUVRRUYvSVFJTUNRc2dBU0FBS0FJRUlBQW9BaEJ0TmdJQURBY0xJQUFvQWdRaEJrRUFJUUlnQUVFb2FrRUFJQUFvQWdBaUJDZ0NDQ0lCUVFWMElBQW9BZ2dpQlNBRUtBSUVRUUowUWVEQUFHcHNha0UwYWhBRkdpQUJRUUZPQkVBZ0FVRURkQ0lFSUFBZ0JrR0FFR29nQld4QkFuUnFJQVZCNEFCc2FtcEIzQUJxSWdVZ0JHb2hCaUFCUVFGMElnRkJBU0FCUVFGS0d5RUVRUUFoQVFOQUlBWWdBVUVDZENJSGFrR0FnSUNQZkRZQ0FDQUZJQWRxUVlDQWdJOThOZ0lBSUFGQkFXb2lBU0FFUncwQUN3c2dBRUVCTmdJNERBY0xJQU1nQXlnQ0RDSUJRUVJxTmdJTUlBRW9BZ0FpQVVVRVFFRi9JUUlNQndzZ0FTQUFLQUk4TmdJQURBVUxJQU1nQXlnQ0RDSUJRUVJxTmdJTUlBRW9BZ0FpQVVVRVFFRi9JUUlNQmdzZ0FTQUFLQUlBTmdJQURBUUxJQU1nQXlnQ0RDSUJRUVJxTmdJTUlBQWdBU2dDQURZQ0hBd0RDeUFESUFNb0Fnd2lBVUVFYWpZQ0RDQUJLQUlBSWdGRkJFQkJmeUVDREFRTElBRWdBQ2dDS0RZQ0FBd0NDeUFESUFNb0Fnd2lBVUVFYWpZQ0RFRi9JUUlnQVNnQ0FDSUJRUUZMRFFJZ0FDQUJOZ0lnREFFTElBTWdBeWdDRENJQlFRUnFOZ0lNSUFFb0FnQWlBVVVFUUVGL0lRSU1BZ3NnQVNBQUtBSWdOZ0lBQzBFQUlRSUxJQU5CRUdva0FDQUNDNElOQVFkL0FrQWdBRVVOQUNBQVFRaHJJZ01nQUVFRWF5Z0NBQ0lCUVhoeElnQnFJUVVDUUNBQlFRRnhEUUFnQVVFRGNVVU5BU0FESUFNb0FnQWlBbXNpQTBHdyt3RW9BZ0FpQkVrTkFTQUFJQUpxSVFBZ0EwRzArd0VvQWdCSEJFQWdBa0gvQVUwRVFDQURLQUlJSWdRZ0FrRURkaUlDUVFOMFFjajdBV3BIR2lBRUlBTW9BZ3dpQVVZRVFFR2crd0ZCb1BzQktBSUFRWDRnQW5keE5nSUFEQU1MSUFRZ0FUWUNEQ0FCSUFRMkFnZ01BZ3NnQXlnQ0dDRUdBa0FnQXlBREtBSU1JZ0ZIQkVBZ0F5Z0NDQ0lDSUFSUEJFQWdBaWdDREJvTElBSWdBVFlDRENBQklBSTJBZ2dNQVFzQ1FDQURRUlJxSWdJb0FnQWlCQTBBSUFOQkVHb2lBaWdDQUNJRURRQkJBQ0VCREFFTEEwQWdBaUVISUFRaUFVRVVhaUlDS0FJQUlnUU5BQ0FCUVJCcUlRSWdBU2dDRUNJRURRQUxJQWRCQURZQ0FBc2dCa1VOQVFKQUlBTWdBeWdDSENJQ1FRSjBRZEQ5QVdvaUJDZ0NBRVlFUUNBRUlBRTJBZ0FnQVEwQlFhVDdBVUdrK3dFb0FnQkJmaUFDZDNFMkFnQU1Bd3NnQmtFUVFSUWdCaWdDRUNBRFJodHFJQUUyQWdBZ0FVVU5BZ3NnQVNBR05nSVlJQU1vQWhBaUFnUkFJQUVnQWpZQ0VDQUNJQUUyQWhnTElBTW9BaFFpQWtVTkFTQUJJQUkyQWhRZ0FpQUJOZ0lZREFFTElBVW9BZ1FpQVVFRGNVRURSdzBBUWFqN0FTQUFOZ0lBSUFVZ0FVRitjVFlDQkNBRElBQkJBWEkyQWdRZ0FDQURhaUFBTmdJQUR3c2dBeUFGVHcwQUlBVW9BZ1FpQVVFQmNVVU5BQUpBSUFGQkFuRkZCRUFnQlVHNCt3RW9BZ0JHQkVCQnVQc0JJQU0yQWdCQnJQc0JRYXo3QVNnQ0FDQUFhaUlBTmdJQUlBTWdBRUVCY2pZQ0JDQURRYlQ3QVNnQ0FFY05BMEdvK3dGQkFEWUNBRUcwK3dGQkFEWUNBQThMSUFWQnRQc0JLQUlBUmdSQVFiVDdBU0FETmdJQVFhajdBVUdvK3dFb0FnQWdBR29pQURZQ0FDQURJQUJCQVhJMkFnUWdBQ0FEYWlBQU5nSUFEd3NnQVVGNGNTQUFhaUVBQWtBZ0FVSC9BVTBFUUNBRktBSU1JUUlnQlNnQ0NDSUVJQUZCQTNZaUFVRURkRUhJK3dGcUlnZEhCRUJCc1BzQktBSUFHZ3NnQWlBRVJnUkFRYUQ3QVVHZyt3RW9BZ0JCZmlBQmQzRTJBZ0FNQWdzZ0FpQUhSd1JBUWJEN0FTZ0NBQm9MSUFRZ0FqWUNEQ0FDSUFRMkFnZ01BUXNnQlNnQ0dDRUdBa0FnQlNBRktBSU1JZ0ZIQkVBZ0JTZ0NDQ0lDUWJEN0FTZ0NBRThFUUNBQ0tBSU1HZ3NnQWlBQk5nSU1JQUVnQWpZQ0NBd0JDd0pBSUFWQkZHb2lBaWdDQUNJRURRQWdCVUVRYWlJQ0tBSUFJZ1FOQUVFQUlRRU1BUXNEUUNBQ0lRY2dCQ0lCUVJScUlnSW9BZ0FpQkEwQUlBRkJFR29oQWlBQktBSVFJZ1FOQUFzZ0IwRUFOZ0lBQ3lBR1JRMEFBa0FnQlNBRktBSWNJZ0pCQW5SQjBQMEJhaUlFS0FJQVJnUkFJQVFnQVRZQ0FDQUJEUUZCcFBzQlFhVDdBU2dDQUVGK0lBSjNjVFlDQUF3Q0N5QUdRUkJCRkNBR0tBSVFJQVZHRzJvZ0FUWUNBQ0FCUlEwQkN5QUJJQVkyQWhnZ0JTZ0NFQ0lDQkVBZ0FTQUNOZ0lRSUFJZ0FUWUNHQXNnQlNnQ0ZDSUNSUTBBSUFFZ0FqWUNGQ0FDSUFFMkFoZ0xJQU1nQUVFQmNqWUNCQ0FBSUFOcUlBQTJBZ0FnQTBHMCt3RW9BZ0JIRFFGQnFQc0JJQUEyQWdBUEN5QUZJQUZCZm5FMkFnUWdBeUFBUVFGeU5nSUVJQUFnQTJvZ0FEWUNBQXNnQUVIL0FVMEVRQ0FBUVFOMklnRkJBM1JCeVBzQmFpRUFBbjlCb1BzQktBSUFJZ0pCQVNBQmRDSUJjVVVFUUVHZyt3RWdBU0FDY2pZQ0FDQUFEQUVMSUFBb0FnZ0xJUUlnQUNBRE5nSUlJQUlnQXpZQ0RDQURJQUEyQWd3Z0F5QUNOZ0lJRHd0Qkh5RUNJQU5DQURjQ0VDQUFRZi8vL3dkTkJFQWdBRUVJZGlJQklBRkJnUDQvYWtFUWRrRUljU0lCZENJQ0lBSkJnT0FmYWtFUWRrRUVjU0lDZENJRUlBUkJnSUFQYWtFUWRrRUNjU0lFZEVFUGRpQUJJQUp5SUFSeWF5SUJRUUYwSUFBZ0FVRVZhblpCQVhGeVFSeHFJUUlMSUFNZ0FqWUNIQ0FDUVFKMFFkRDlBV29oQVFKQUFrQUNRRUdrK3dFb0FnQWlCRUVCSUFKMElnZHhSUVJBUWFUN0FTQUVJQWR5TmdJQUlBRWdBellDQUNBRElBRTJBaGdNQVFzZ0FFRUFRUmtnQWtFQmRtc2dBa0VmUmh0MElRSWdBU2dDQUNFQkEwQWdBU0lFS0FJRVFYaHhJQUJHRFFJZ0FrRWRkaUVCSUFKQkFYUWhBaUFFSUFGQkJIRnFJZ2RCRUdvb0FnQWlBUTBBQ3lBSElBTTJBaEFnQXlBRU5nSVlDeUFESUFNMkFnd2dBeUFETmdJSURBRUxJQVFvQWdnaUFDQUROZ0lNSUFRZ0F6WUNDQ0FEUVFBMkFoZ2dBeUFFTmdJTUlBTWdBRFlDQ0F0QndQc0JRY0Q3QVNnQ0FFRUJheUlBUVg4Z0FCczJBZ0FMQzZNQkFRWi9JQUFvQWd3aEF3SkFJQUVnQUNnQ0VDSUNUUVJBSUFJaEJBd0JDeUFBS0FJSUlRVWdBQ2dDQkNFR0EwQkJBQ0VFSUFVZ0Jra0VmeUFBSUFWQkFXb2lCVFlDQ0NBQUtBSUFJQVlnQld0cUxRQUFCVUVBQ3lBQ2RDQURjaUVESUFKQkVVZ2hCeUFDUVFocUlnUWhBaUFIRFFBTEN5QUFJQVFnQVdzMkFoQWdBQ0FESUFGMk5nSU1JQUFnQUNnQ0ZDQUJhallDRkNBRFFYOGdBWFJCZjNOeEM4RVFBZzUvQW4wZ0FpQUViaUVUSUFBb0FnQWhGd0pBSUFKQkFVWUVRQ0FBS0FJZ0lRTWdBQ2dDSENFQ0FrQWdGd1JBSUFOQkIwb0VRQ0FDSUFFcUFnQkRBQUFBQUYwaURSQWdJQUFnQUNnQ0lFRUlhellDSUFzZ0FDZ0NCRVVOQVNBQlF3QUFnTDlEQUFDQVB5QU5HemdDQUF3QkN5QURRUWhPQkVBZ0FrRUJFQWtoRFNBQUlBQW9BaUJCQ0dzMkFpQUxJQUFvQWdSRkRRQWdBVU1BQUlDL1F3QUFnRDhnRFJzNEFnQUxRUUVoQ2lBSFJRMEJJQWNnQVNvQ0FEZ0NBRUVCRHdzZ0FDZ0NHQ0lTUVFCS0lRc0NRQ0FGUlFSQUlBVWhDUXdCQ3lBSlJRUkFJQVVoQ1F3QkN3SkFJQkpCQUVvTkFDQUVRUUZLRFFBZ0UwRUJjVVVnRWtFQVIzRU5BQ0FGSVFrTUFRc2dDU0FGSUFKQkFuUVFCQm9MSUJKQkFDQUxHeUVRQWtBZ0VrRUJTQTBBSUJkRkJFQURRQUpBSUFsRkRRQWdERUVmUmcwQUlBSWdESFVpQlVFQ1NBMEFRUUVnREhRaUVVRUJkQ0VPSUFWQkFYVWlCVUVCSUFWQkFVb2JJUTlCQUNFTkEwQkJBQ0VGQTBBZ0NTQUZJQTVzSUExcVFRSjBhaUlMSUFzcUFnQkQ4d1ExUDVRaUdpQUpJQVZCQVhSQkFYSWdESFFnRFdwQkFuUnFJZ3NxQWdCRDh3UTFQNVFpR1pJNEFnQWdDeUFhSUJtVE9BSUFJQVZCQVdvaUJTQVBSdzBBQ3lBTlFRRnFJZzBnRVVjTkFBc0xJQXBCRDNGQjBEbHFMUUFBSUFwQkJIVkIwRGxxTFFBQVFRSjBjaUVLSUF4QkFXb2lEQ0FRUncwQURBSUxBQXNEUUFKQUlBeEJIMFlpRGcwQUlBSWdESFVpQlVFQ1NDSVBEUUJCQVNBTWRDSVZRUUYwSVJZZ0JVRUJkU0lGUVFFZ0JVRUJTaHNoRVVFQUlRMERRRUVBSVFVRFFDQUJJQVVnRm13Z0RXcEJBblJxSWdzZ0N5b0NBRVB6QkRVL2xDSWFJQUVnQlVFQmRFRUJjaUFNZENBTmFrRUNkR29pQ3lvQ0FFUHpCRFUvbENJWmtqZ0NBQ0FMSUJvZ0daTTRBZ0FnQlVFQmFpSUZJQkZIRFFBTElBMUJBV29pRFNBVlJ3MEFDeUFKUlEwQUlBNE5BQ0FQRFFCQkFDRU5BMEJCQUNFRkEwQWdDU0FGSUJac0lBMXFRUUowYWlJTElBc3FBZ0JEOHdRMVA1UWlHaUFKSUFWQkFYUkJBWElnREhRZ0RXcEJBblJxSWdzcUFnQkQ4d1ExUDVRaUdaSTRBZ0FnQ3lBYUlCbVRPQUlBSUFWQkFXb2lCU0FSUncwQUN5QU5RUUZxSWcwZ0ZVY05BQXNMSUFwQkQzRkIwRGxxTFFBQUlBcEJCSFZCMERscUxRQUFRUUowY2lFS0lBeEJBV29pRENBUVJ3MEFDd3NnQkNBUWRTRU1Ba0FDUUNBVElCQjBJZzlCQVhFTkFDQVNRWDlLRFFBZ0Z3UkFJQkloRVFOQUlBOUJBWFVoRGdKQUlBeEJBVWdpRlEwQUlBOUJBa2dpRmcwQUlBeEJBWFFoR0NBT1FRRWdEa0VCU2hzaEUwRUFJUTBEUUVFQUlRVURRQ0FCSUFVZ0dHd2dEV3BCQW5ScUlnc2dDeW9DQUVQekJEVS9sQ0lhSUFFZ0JVRUJkRUVCY2lBTWJDQU5ha0VDZEdvaUN5b0NBRVB6QkRVL2xDSVpramdDQUNBTElCb2dHWk00QWdBZ0JVRUJhaUlGSUJOSERRQUxJQTFCQVdvaURTQU1SdzBBQ3lBSlJRMEFJQlVOQUNBV0RRQkJBQ0VOQTBCQkFDRUZBMEFnQ1NBRklCaHNJQTFxUVFKMGFpSUxJQXNxQWdCRDh3UTFQNVFpR2lBSklBVkJBWFJCQVhJZ0RHd2dEV3BCQW5ScUlnc3FBZ0JEOHdRMVA1UWlHWkk0QWdBZ0N5QWFJQm1UT0FJQUlBVkJBV29pQlNBVFJ3MEFDeUFOUVFGcUlnMGdERWNOQUFzTElCUkJBV29oRkNBTVFRRjBJUXNnQ2lBTWRDQUtjaUVLSUE5QkFuRU5BeUFSUVg5SUlRVWdFVUVCYWlFUklBc2hEQ0FPSVE4Z0JRMEFDd3dDQ3lBSlFRQkhRUUZ6SVJNZ0VpRVJBMEFnRDBFQmRTRU9Ba0FnREVFQlNDQVRjZzBBSUE5QkFrZ05BQ0FNUVFGMElSVWdEa0VCSUE1QkFVb2JJUlpCQUNFTkEwQkJBQ0VGQTBBZ0NTQUZJQlZzSUExcVFRSjBhaUlMSUFzcUFnQkQ4d1ExUDVRaUdpQUpJQVZCQVhSQkFYSWdER3dnRFdwQkFuUnFJZ3NxQWdCRDh3UTFQNVFpR1pJNEFnQWdDeUFhSUJtVE9BSUFJQVZCQVdvaUJTQVdSdzBBQ3lBTlFRRnFJZzBnREVjTkFBc0xJQlJCQVdvaEZDQU1RUUYwSVFzZ0NpQU1kQ0FLY2lFS0lBOUJBbkVOQWlBUlFYOUlJUVVnRVVFQmFpRVJJQXNoRENBT0lROGdCUTBBQ3d3QkN5QVBJUTRnRENFTEN5QUVRUUZHSVFRQ1FDQUxRUUpJRFFBZ0Z3UkFJQUVnRGlBUWRTQUxJQkIwSUFRUVBBc2dDVVVOQUNBSklBNGdFSFVnQ3lBUWRDQUVFRHdMSUFBZ0FTQUNJQU1nQ3lBSklBWWdDQ0FLRUJFaENpQUFLQUlFUlEwQUlBdEJBazRFUUNBQklBNGdFSFVnQ3lBUWRDQUVFR0FMSUJRRVFFRUFJUThEUUNBT1FRRjBJUTRnQ2lBTElnQkJBWFVpQzNZaEJnSkFJQUJCQWtnTkFDQU9RUUpJRFFBZ0FFRitjU0VFSUE1QkFYVWlBRUVCSUFCQkFVb2JJUU5CQUNFSkEwQkJBQ0VGQTBBZ0FTQUVJQVZzSUFscVFRSjBhaUlBSUFBcUFnQkQ4d1ExUDVRaUdTQUJJQVZCQVhSQkFYSWdDMndnQ1dwQkFuUnFJZ0FxQWdCRDh3UTFQNVFpQ0pJNEFnQWdBQ0FaSUFpVE9BSUFJQVZCQVdvaUJTQURSdzBBQ3lBSlFRRnFJZ2tnQzBjTkFBc0xJQVlnQ25JaENpQVBRUUZxSWc4Z0ZFY05BQXNMUVFBaERDQVNRUUJLQkVBRFFDQUtRZUE1YWkwQUFDRUtBa0FnREVFZlJnMEFJQUlnREhVaUFFRUNTQTBBUVFFZ0RIUWlCa0VCZENFRUlBQkJBWFVpQUVFQklBQkJBVW9iSVFOQkFDRUpBMEJCQUNFRkEwQWdBU0FFSUFWc0lBbHFRUUowYWlJQUlBQXFBZ0JEOHdRMVA1UWlHU0FCSUFWQkFYUkJBWElnREhRZ0NXcEJBblJxSWdBcUFnQkQ4d1ExUDVRaUNKSTRBZ0FnQUNBWklBaVRPQUlBSUFWQkFXb2lCU0FEUncwQUN5QUpRUUZxSWdrZ0JrY05BQXNMSUF4QkFXb2lEQ0FRUncwQUN3c2dDeUFRZENFREFrQWdCMFVOQUNBQ1FRRklEUUFnQXJlZnRpRUlRUUFoQlFOQUlBY2dCVUVDZENJQWFpQUFJQUZxS2dJQUlBaVVPQUlBSUFWQkFXb2lCU0FDUncwQUN3c2dDa0YvSUFOMFFYOXpjU0VLQ3lBS0N6OEJBWDhnQUNnQ0ZFRURkQ0FBS0FJY0lnQm5JZ0ZCQTNScUlBQkJFQ0FCYTNZaUFDQUFRUXgySWdCQkFuUkJnTmtCYWlnQ0FFdHJJQUJyUWZnQmF3dGhBUUovSXdCQkVHc2lBU1FBSUFCQkFXdEJBVTBFUUNBQlFlakNBRFlDRENBQklBRW9BZ3hCQTJwQmZIRTJBZ3dnQVNnQ0RFR2dQU2dDQUVFQ2RFSGd3QUJxSUFCc1FhUTlLQUlBUVFWMGFtcEJ0QUZxSVFJTElBRkJFR29rQUNBQ0MyOEJBWDhqQUVHQUFtc2lCU1FBQWtBZ0FpQURUQTBBSUFSQmdNQUVjUTBBSUFVZ0FVSC9BWEVnQWlBRGF5SUNRWUFDSUFKQmdBSkpJZ0ViRUFVYUlBRkZCRUFEUUNBQUlBVkJnQUlRRUNBQ1FZQUNheUlDUWY4QlN3MEFDd3NnQUNBRklBSVFFQXNnQlVHQUFtb2tBQXZwQWdFQmZ3SkFJQUFnQVVZTkFDQUJJQUJySUFKclFRQWdBa0VCZEd0TkJFQWdBQ0FCSUFJUUJBOExJQUFnQVhOQkEzRWhBd0pBQWtBZ0FDQUJTUVJBSUFNRVFDQUFJUU1NQXdzZ0FFRURjVVVFUUNBQUlRTU1BZ3NnQUNFREEwQWdBa1VOQkNBRElBRXRBQUE2QUFBZ0FVRUJhaUVCSUFKQkFXc2hBaUFEUVFGcUlnTkJBM0VOQUFzTUFRc0NRQ0FERFFBZ0FDQUNha0VEY1FSQUEwQWdBa1VOQlNBQUlBSkJBV3NpQW1vaUF5QUJJQUpxTFFBQU9nQUFJQU5CQTNFTkFBc0xJQUpCQTAwTkFBTkFJQUFnQWtFRWF5SUNhaUFCSUFKcUtBSUFOZ0lBSUFKQkEwc05BQXNMSUFKRkRRSURRQ0FBSUFKQkFXc2lBbW9nQVNBQ2FpMEFBRG9BQUNBQ0RRQUxEQUlMSUFKQkEwME5BQU5BSUFNZ0FTZ0NBRFlDQUNBQlFRUnFJUUVnQTBFRWFpRURJQUpCQkdzaUFrRURTdzBBQ3dzZ0FrVU5BQU5BSUFNZ0FTMEFBRG9BQUNBRFFRRnFJUU1nQVVFQmFpRUJJQUpCQVdzaUFnMEFDd3NnQUF0VkFRSi9RWkQ0QVNnQ0FDSUJJQUJCQTJwQmZIRWlBbW9oQUFKQUlBSkJBVTVCQUNBQUlBRk5HdzBBUHdCQkVIUWdBRWtFUUNBQUVBSkZEUUVMUVpENEFTQUFOZ0lBSUFFUEMwR2Mrd0ZCTURZQ0FFRi9DeGNBSUFBdEFBQkJJSEZGQkVBZ0FTQUNJQUFRakFFTEM4NE5BZ3QvQW4wakFFRWdheUlOSkFBZ0RTQUlOZ0lZSUEwZ0F6WUNIQ0FBS0FJSUlna29BbVFpQ2lBSktBSmdJZ3NnQUNnQ0RDSVBJQWtvQWdnZ0JrRUJhbXhxUVFGMGFpNEJBR29oRGtGL0lRd2dBQ2dDSENFUklBQW9BaFFoRWlBQUtBSUFJUk1DUUFKQUFrQUNRQUpBQW44Z0JrRi9SZ1JBSUFvZ0N5QVBRUUYwYWk0QkFHb2lDUzBBQUNJR0lBWkJBV3BCQVhZaUNpQURRUUZySWdZZ0NTQUthaTBBQUVvaUF4c2lDeUFMSUFwQkFDQURHeUlLYWtFQmFrRUJkaUlESUFZZ0F5QUphaTBBQUVvaUN4c2lEeUFQSUFNZ0NpQUxHeUlLYWtFQmFrRUJkaUlESUFZZ0F5QUphaTBBQUVvaUN4c2lEeUFQSUFNZ0NpQUxHeUlLYWtFQmFrRUJkaUlESUFZZ0F5QUphaTBBQUVvaUN4c2lEeUFQSUFNZ0NpQUxHeUlLYWtFQmFrRUJkU0lESUFZZ0F5QUphaTBBQUVvaUN4c2lEeUFQSUFNZ0NpQUxHeUlMYWtFQmFrRUJkU0lESUFZZ0F5QUphaTBBQUVvaUR4c2hDaUFESUFzZ0R4c2lDd1JBSUFrZ0Myb3RBQUFoREF0QkFDQUtJQXNnQmlBTWF5QUpJQXBxTFFBQUlBWnJTaHNpQmtVTkFSb2dCaUFKYWkwQUFFRUJhaUVRSUFZTUFRc2dEaTBBQUNFSklBSkJBMDRFUUNBSklBNXFMUUFBUVF4cUlBTklEUUlMSUFrZ0NVRUJha0VCZGlJSklBTkJBV3NpQmlBSklBNXFMUUFBU2lJREd5SUtJQW9nQ1VFQUlBTWJJZ2xxUVFGcVFRRjJJZ01nQmlBRElBNXFMUUFBU2lJS0d5SUxJQXNnQXlBSklBb2JJZ2xxUVFGcVFRRjJJZ01nQmlBRElBNXFMUUFBU2lJS0d5SUxJQXNnQXlBSklBb2JJZ2xxUVFGcVFRRjJJZ01nQmlBRElBNXFMUUFBU2lJS0d5SUxJQXNnQXlBSklBb2JJZ2xxUVFGcVFRRjFJZ01nQmlBRElBNXFMUUFBU2lJS0d5SUxJQXNnQXlBSklBb2JJZ3BxUVFGcVFRRjFJZ01nQmlBRElBNXFMUUFBU2lJTEd5RUpJQU1nQ2lBTEd5SUtCRUFnQ2lBT2FpMEFBQ0VNQzBFQUlBa2dDaUFHSUF4cklBa2dEbW90QUFBZ0JtdEtHeUlHUlEwQUdpQUdJQTVxTFFBQVFRRnFJUkFnQmdzaEF5QUFJQUFvQWlBZ0VHc2lDVFlDSUNBSlFYOU1EUUVnQXlFR0RBSUxJQVpCQVdzaEEwRUJJUWtnQVNBQ1FRRjJJZ0pCQW5ScUlRNENRQ0FFUVFGSEJFQWdBQ0FOSUFFZ0RpQUNJQTFCSEdvZ0JFRUJha0VCZFNJSklBUWdBMEVBSUExQkdHb1FJd3dCQ3lBTklBaEJBWEVnQ0VFQmRISTJBaGdnQUNBTklBRWdEaUFDSUExQkhHcEJBVUVCSUFOQkFDQU5RUmhxRUNNTElBMG9BaEFoQ0NBTktBSUlzaUVVSUEwb0FnU3lJUlVnRFNnQ0ZDRVFJQTBvQWd3aERBSkFJQVJCQWtnTkFDQUlRZi8vQUhGRkRRQWdDRUdCd0FCT0JFQWdEQ0FNUVFVZ0JtdDFheUVNREFFTElBd2dBa0VEZEVFR0lBWnJkV29pQmtFZmRTQUdjU0VNQ3lBVVF3QUFBRGlVSVJRZ0ZVTUFBQUE0bENFVklBMG9BaHdoQmlBQUlBQW9BaUFnRUdzaUVEWUNJQ0FGSUFKQkFuUnFRUUFnQlJzaEVTQUdJQVlnREd0QkFtMGlEQ0FHSUF4SUd5SU1RUUFnREVFQVNoc2lEQ0FHSUF4cklnWk9CRUFnQUNBQklBSWdEQ0FKSUFVZ0F5QVZJQWVVSUEwb0FoZ2lBUkFSSUFBZ0RpQUNJQUFvQWlBZ0VHc2dER29pQUVFWWEwRUFJQUJCR0VvYlFRQWdDQnNnQm1vZ0NTQVJJQU1nRkNBSGxDQUJJQWwxRUJFZ0JFRUJkWFJ5SVFrTUJBc2dBQ0FPSUFJZ0JpQUpJQkVnQXlBVUlBZVVJQTBvQWhnaURpQUpkUkFSSVJFZ0FDQUJJQUlnQUNnQ0lDQVFheUFHYWlJQVFSaHJRUUFnQUVFWVNodEJBQ0FJUVlDQUFVY2JJQXhxSUFrZ0JTQURJQlVnQjVRZ0RoQVJJQkVnQkVFQmRYUnlJUWtNQXdzZ0EwRUJTQVJBSUFNaEJnd0JDd05BSUFBZ0NTQVFhaUlKTmdJZ0lBTkJBV3NpQmtVRVFDQUFJQWsyQWlBTUF3c2dBQ0FKSUFZZ0Rtb3RBQUJCQVdvaUVHc2lDVFlDSUNBSlFYOUtEUUVnQTBFQlNpRU1JQVloQXlBTURRQUxDeUFHUlEwQUlBWkJDRTRFUUNBR1FRZHhRUWh5SUFaQkEzWkJBV3QwSVFZTElCTUVRQ0FCSUFJZ0JpQVNJQVFnRVNBSElBQW9BZ1FnQUNnQ0xCQ1lBU0VKREFJTElBRWdBaUFHSUJJZ0JDQVJJQWNRbGdFaENRd0JDeUFBS0FJRVJRUkFRUUFoQ1F3QkN5QU5RWDhnQkhSQmYzTWlDU0FJY1NJRU5nSVlJQVJGQkVCQkFDRUpJQUZCQUNBQ1FRSjBFQVVhREFFTEFrQWdCUVJBSUFKQkFVNEVRQ0FBS0FJb0lRTkJBQ0VHQTBBZ0FTQUdRUUowSWdocUlBVWdDR29xQWdCREFBQ0FPME1BQUlDN0lBTkJqY3psQUd4QjMrYTc0d05xSWdOQmdJQUNjUnVTT0FJQUlBWkJBV29pQmlBQ1J3MEFDeUFBSUFNMkFpZ0xJQVFoQ1F3QkN5QUNRUUZJRFFBZ0FDZ0NLQ0VEUVFBaEJnTkFJQUVnQmtFQ2RHb2dBMEdOek9VQWJFSGY1cnZqQTJvaUEwRVVkYkk0QWdBZ0JrRUJhaUlHSUFKSERRQUxJQUFnQXpZQ0tBc2dBU0FDSUFjZ0FDZ0NMQkF1Q3lBTlFTQnFKQUFnQ1F1ckFnSUZmd0Y5SUFBb0Fpd2dCbXdoQ2lBQUtBSWdJZ3NnQlVFQmRHb3VBUUFnQm13aEFDQUhRUUZIQkVBZ0FDQUtJQWR0SWdjZ0FDQUhTQnNoQUF0QkFDQUZJQWdiSVF3Z0MwRUFJQVFnQ0JzaUJFRUJkR291QVFBaURTQUdiQ0lKUVFKMElRY2dBaUVGSUFsQkFVNEVRQ0FDUVFBZ0J4QUZJQWRxSVFVTFFRQWdBQ0FJR3lFSklBUWdERWdFUUNBQklBZHFJUWdEUUNBRElBUkJBblFpQUdvcUFnQWdBRUhBMlFGcUtnSUFra01BQUFCQ2xydEU3em42L2tJdTVqK2lFQisySVE0Z0JpQU5iQ0VBSUFzZ0JFRUJhaUlFUVFGMGFpNEJBQ0lOSUFac0lRRURRQ0FGSUFncUFnQWdEcFE0QWdBZ0JVRUVhaUVGSUFoQkJHb2hDQ0FBUVFGcUlnQWdBVWdOQUFzZ0JDQU1SdzBBQ3dzZ0FpQUpRUUowYWtFQUlBb2dDV3RCQW5RUUJSb0xneGdERjM4QmZRRjhJd0JCd0FGcklnWWtBQ0FHUVFBMkFvZ0JRWDRoQlFKQUlBQW9BZ3dpRlVFeWJTSVBRUU4xSWhBZ0JFb05BQ0FBS0FJQUlSb2dBQ2dDQkNFSUlBOUJBblVoRENBUFFRRjFJUXNnQkNBVlFSbHRRUU5zSWdVZ0JDQUZTQnNoQlFKQUFuOENRQUpBQWtBZ0JnSi9Ba0FDUUFKQUFrQUNRQUpBQWtBZ0FrRUJUQVJBSUFVZ0FDZ0NRQ0lCSUFFZ0JVb2JJUVVNQVFzZ0FRMEJDeUFBS0FJOElnUkZCRUFnQUNnQ0NDQUZiQ0lBUVFGSURRMGdBMEVBSUFCQkFuUVFCUm9NRFFzZ0JTQVBTZ1JBSUFVaEJBTkFJQUJCQUVFQUlBTWdCQ0FQSUFRZ0QwZ2JFQk1pQVVFQVNBUkFJQUVoQlF3UEN5QURJQUFvQWdnZ0FXeEJBblJxSVFNZ0JDQUJheUlFUVFCS0RRQUxEQTBMSUFVZ0QwNE5BVUVCSVJFZ0JTQUxTZ1JBSUFzaENRd0VDeUFFUWVnSFJnUkFRUUFoQVVIb0J5RUVJQVVoQ1F3R0N5QU1JQVVnQlNBTFNCc2dCU0FGSUF4S0d5RUpEQU1MSUFBb0FqUWhGQ0FBS0FJNElRUWdBQ2dDUUNFSklBWkJrQUZxSUFFZ0FoQlRRUUVoRFNBQUtBSThJZ3BCQVVnRVFFRUJJUkVNQkFzQ1FBSkFBa0FnQ2tIcUIwWU5BQ0FFUWVvSFJ3MEFJQUFvQWtSRkRRRUxJQVJCNmdkR0JFQkI2Z2NoQkVFQklSRU1CZ3NnQ2tIcUIwWU5BVUVCSVJFTUJRc2dCRUhxQjBZTkFnc2dBQ2dDQ0NBTWJDRVJRUUVoRnd3REN5QUVRZW9IUndSQVFRRWhFVUVBSVFFZ0JTRUpEQVFMSUFaQkVHc2lDeUlZSkFCQkFTRVJJQVVoQ1VFQUlRRkJBU0VTREFVTElBWWdBQ2dDQ0NBTWJFRUNkRUVQYWtGd2NXc2lDaUlFSkFBZ0FFRUFRUUFnQ2lBTUlBa2dDU0FNU2hzUUV4b2dCU0FKU0NFTFFYOGhCU0FMRFFnZ0JFRVFheUlMSWhna0FFRUJJUmRCQVNFUlFRRWhFZ3dFQzBFQUlRRUxJQVVnQ1VnaENrRi9JUVVnQ2cwR1Flb0hJUk5CQVNFU1FRRWdCRUhxQjBZTkFSb0xRUUFoRWlBRUlSTWdBQ2dDQ0NBTElBa2dDU0FMU0J0c0MwRUJkRUVQYWtGd2NXc2lDeUlZSkFCQkFDRUtJQk5CNmdkSElnNE5BUXRCNmdjaEUwRUFJUTRNQVFzZ0FDQUlhaUVLSUFBb0FqeEI2Z2RHQkVBZ0NoQkVHZ3NnQUNBSlFlZ0hiQ0FBS0FJTWJTSUVRUW9nQkVFS1NoczJBaUFnRFFSQUlBQWdBQ2dDTURZQ0ZFR0EvUUFoQkFKQUlCTkI2QWRIRFFBZ0ZFSE5DR3NpQlVFQ1N3MEFJQVZCb0I5c1FjQSthaUVFQ3lBQUlBUTJBaHdMSUFCQkVHb2hGa0VBSVFRQ1FDQUJSU0laUlFSQUlBc2hCUU5BSUFvZ0ZrRUFJQVJGSUFaQmtBRnFJQVVnQmtHTUFXb2dBQ2dDTEJCREJFQkJmU0VGREFZTElBVWdCaWdDakFFaUNDQUFLQUlJYkVFQmRHb2hCU0FFSUFocUlnUWdDVWdOQUFzTUFRc2dDeUVGQTBBQ1FDQUtJQllnR1NBRVJTQUdRWkFCYWlBRklBWkJqQUZxSUFBb0Fpd1FRMFVFUUNBR0tBS01BU0lJSUFBb0FnaHNJUWNNQVFzZ0JpQUpOZ0tNQVNBQUtBSUlJQWxzSWdkQkFVNEVRQ0FGUVFBZ0IwRUJkQkFGR2dzZ0NTRUlDeUFGSUFkQkFYUnFJUVVnQkNBSWFpSUVJQWxJRFFBTEMwRUFJUXBCRVNFWklBMUJBWEZGRFFBZ0JpZ0NwQUVnQmlnQ3JBRm5ha0VVUVFBZ0FDZ0NPRUhwQjBZYmFrRVBheUFDUVFOMFNnMEFBa0FnRTBIcEIwWUVRQ0FHUVpBQmFrRU1FQVlpQ0VVRVFFSHBCeUVUREFNTElBWkJrQUZxUVFFUUJpRUhJQVpCa0FGcVFZQUNFQlpCQW1vaEJDQUdLQUtzQVdjaEJTQUdLQUtrQVNFTkRBRUxRUUVoQ0NBR1FaQUJha0VCRUFZaEJ5QUNJQVlvQXFRQklnMGdCaWdDckFGbklnVnFRUmxyUVFOMWF5RUVDeUFHSUFZb0FwUUJRUUFnQkNBRklBMXFRU0JySUFJZ0JHc2lBa0VEZEVvaUJCc2lEV3MyQXBRQlFRQWdBaUFFR3lFQ1FRQWdDQ0FFR3d3QkMwRUFJUTFCQUNFSFFRQUxJaFpGSWhzZ0YzRWhGeUFZUVFFZ0VTQVdHMEVDZEVFUGFrRndjV3NpQkNJSUpBQUNRQ0FPUlEwQUlCZEZEUUFnQUVFQVFRQWdCQ0FNSUFrZ0NTQU1TaHNRRXhvZ0JDRUtDeUFBSUJwcUlRUUNRQUpBQWtBQ1FBSkFBa0FnRkVITkNHc09CQUFCQVFJREMwRU5JUVVNQXd0QkVTRUZEQUlMUVJNaEJRd0JDMEVWSVFVZ0ZFVU5BUXNnQmlBRk5nS0FBVUY5SVFVZ0JFR2N6Z0FnQmtHQUFXb1FCdzBCQ3lBR0lBQW9BakEyQW5CQmZTRUZJQVJCbU00QUlBWkI4QUJxRUFjTkFBSi9JQlpGQkVCQkFDRU9JQWhCRUdzaUNDUUFJQWRCQUVjTUFRc2dDQ0FBS0FJSUlBeHNRUUowUVE5cVFYQnhheUlJSkFBZ0IwVUVRRUVBSVE1QkFBd0JDeUFHUVFBMkFtQWdCRUdhemdBZ0JrSGdBR29RQncwQklBUWdBU0FDYWlBTklBZ2dERUVBRUJnYUlBWWdCa0dJQVdvMkFsQWdCRUcvSHlBR1FkQUFhaEFIRFFGQkFTRU9RUUVMSVJFZ0JpQVpOZ0pBSUFSQm1zNEFJQVpCUUdzUUJ3MEFBbjhnRTBIb0IwY0VRQUpBSUJNZ0FDZ0NQQ0lIUmcwQUlBZEJBVWdOQUNBQUtBSkVEUUFnQkVHOEgwRUFFQWNOQXdzZ0JDQUJJQUlnQXlBUElBa2dDU0FQU2hzZ0JrR1FBV29RR0F3QkN5QUdRZi8vQXpzQmhBRWdBQ2dDQ0NBSmJDSUhRUUZPQkVBZ0EwRUFJQWRCQW5RUUJSb0xBa0FnQUNnQ1BFSHBCMGNOQUNBT0JFQWdBQ2dDUkEwQkN5QUdRUUEyQWpBZ0JFR2F6Z0FnQmtFd2FoQUhEUUlnQkNBR1FZUUJha0VDSUFNZ0VFRUFFQmdhQzBFQUN5RVBBa0FnRWcwQUlBQW9BZ2dnQ1d3aUVrRUJTQTBBUVFBaEJ3TkFJQU1nQjBFQ2RHb2lGQ0FVS2dJQUlBc2dCMEVCZEdvdUFRQ3lRd0FBQURpVWtqZ0NBQ0FIUVFGcUlnY2dFa2NOQUFzTElBWWdCa0dFQVdvMkFpQWdCRUdmemdBZ0JrRWdhaEFIRFFBZ0JpZ0NoQUVvQWp3aEN3SkFJQkVnRzNJTkFDQUVRYndmUVFBUUJ3MEJJQVpCQURZQ0VDQUVRWnJPQUNBR1FSQnFFQWNOQVVFQUlRY2dCQ0FCSUFKcUlBMGdDQ0FNUVFBUUdCb2dCaUFHUVlnQmFqWUNBQ0FFUWI4ZklBWVFCdzBCUVlEM0FpQUFLQUlNYlNFRklCVkJrQU5JRFFBZ0FDZ0NDQ0lCUVFGSURRQWdDQ0FCSUJCc1FRSjBhaUVOSUFNZ0FTQUpJQkJyYkVFQ2RHb2hFZ05BUVFBaEJBTkFJQklnQVNBRWJDQUhha0VDZENJVWFpSVlJQXNnQkNBRmJFRUNkR29xQWdBaUhDQWNsQ0ljSUEwZ0ZHb3FBZ0NVUXdBQWdEOGdISk1nR0NvQ0FKU1NPQUlBSUFSQkFXb2lCQ0FRUncwQUN5QUhRUUZxSWdjZ0FVY05BQXNMQWtBZ0RrVU5BQUpBSUFBb0FnZ2lCVUVCU0EwQUlCVkJrQU5JRFFBZ0JVRUJJQVZCQVVvYklRY2dFRUVCSUJCQkFVb2JJUTVCQUNFQkEwQkJBQ0VFQTBBZ0F5QUVJQVZzSUFGcVFRSjBJZzFxSUFnZ0RXb3FBZ0E0QWdBZ0JFRUJhaUlFSUE1SERRQUxJQUZCQVdvaUFTQUhSdzBBQ3d0QmdQY0NJQUFvQWd4dElRY2dGVUdRQTBnTkFDQUZRUUZJRFFBZ0F5QUZJQkJzUVFKMElnRnFJUTRnQVNBSWFpRUlRUUFoQVFOQVFRQWhCQU5BSUE0Z0JDQUZiQ0FCYWtFQ2RDSU5haUlTSUFzZ0JDQUhiRUVDZEdvcUFnQWlIQ0FjbENJY0lCSXFBZ0NVUXdBQWdEOGdISk1nQ0NBTmFpb0NBSlNTT0FJQUlBUkJBV29pQkNBUVJ3MEFDeUFCUVFGcUlnRWdCVWNOQUFzTEFrQWdGMFVOQUNBQUtBSUlJUVVnQ1NBTVRnUkFJQVVnRUd3aUFVRUJUZ1JBUVFBaEJBTkFJQU1nQkVFQ2RDSUlhaUFJSUFwcUtnSUFPQUlBSUFSQkFXb2lCQ0FCUncwQUN3dEJnUGNDSUFBb0FneHRJUWdnRlVHUUEwZ05BU0FGUVFGSURRRWdBeUFCUVFKMElnRnFJUWNnQVNBS2FpRUJRUUFoQ2dOQVFRQWhCQU5BSUFjZ0JDQUZiQ0FLYWtFQ2RDSU1haUlPSUFzZ0JDQUliRUVDZEdvcUFnQWlIQ0FjbENJY0lBNHFBZ0NVUXdBQWdEOGdISk1nQVNBTWFpb0NBSlNTT0FJQUlBUkJBV29pQkNBUVJ3MEFDeUFLUVFGcUlnb2dCVWNOQUFzTUFRdEJnUGNDSUFBb0FneHRJUWdnRlVHUUEwZ05BQ0FGUVFGSURRQkJBQ0VCQTBCQkFDRUVBMEFnQXlBRUlBVnNJQUZxUVFKMElnZHFJZ3dnQ3lBRUlBaHNRUUowYWlvQ0FDSWNJQnlVSWh3Z0RDb0NBSlJEQUFDQVB5QWNreUFISUFwcUtnSUFsSkk0QWdBZ0JFRUJhaUlFSUJCSERRQUxJQUZCQVdvaUFTQUZSdzBBQ3dzQ1FDQUFLQUlvSWdGRkRRQWdBQ2dDQ0NFRUlBR3lReTBWS2pxVXUwVHZPZnIrUWk3bVA2SVFIeUVkSUFRZ0NXd2lBVUVCU0EwQUlCMjJJUnhCQUNFRUEwQWdBeUFFUVFKMGFpSUZJQVVxQWdBZ0hKUTRBZ0FnQkVFQmFpSUVJQUZIRFFBTEN5QUdLQUtJQVNFQklBWW9BcXdCSVFNZ0FDQVROZ0k4SUFBZ0VVRUJjeUFXUVFCSGNUWUNSQ0FBUVFBZ0FTQURjeUFDUVFKSUd6WUNWQ0FQSUFrZ0QwRUFTQnNoQlFzTElBWkJ3QUZxSkFBZ0JRdW9BUUFDUUNBQlFZQUlUZ1JBSUFCRUFBQUFBQUFBNEgraUlRQWdBVUgvRDBnRVFDQUJRZjhIYXlFQkRBSUxJQUJFQUFBQUFBQUE0SCtpSVFBZ0FVSDlGeUFCUWYwWFNCdEIvZzlySVFFTUFRc2dBVUdCZUVvTkFDQUFSQUFBQUFBQUFCQUFvaUVBSUFGQmczQktCRUFnQVVIK0Iyb2hBUXdCQ3lBQVJBQUFBQUFBQUJBQW9pRUFJQUZCaG1nZ0FVR0dhRW9iUWZ3UGFpRUJDeUFBSUFGQi93ZHFyVUkwaHIraUM5QXVBUXgvSXdCQkVHc2lEQ1FBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFJQUJCOUFGTkJFQkJvUHNCS0FJQUlnVkJFQ0FBUVF0cVFYaHhJQUJCQzBrYklnaEJBM1lpQW5ZaUFVRURjUVJBSUFGQmYzTkJBWEVnQW1vaUEwRURkQ0lCUWREN0FXb29BZ0FpQkVFSWFpRUFBa0FnQkNnQ0NDSUNJQUZCeVBzQmFpSUJSZ1JBUWFEN0FTQUZRWDRnQTNkeE5nSUFEQUVMUWJEN0FTZ0NBQm9nQWlBQk5nSU1JQUVnQWpZQ0NBc2dCQ0FEUVFOMElnRkJBM0kyQWdRZ0FTQUVhaUlCSUFFb0FnUkJBWEkyQWdRTURRc2dDRUdvK3dFb0FnQWlDazBOQVNBQkJFQUNRRUVDSUFKMElnQkJBQ0FBYTNJZ0FTQUNkSEVpQUVFQUlBQnJjVUVCYXlJQUlBQkJESFpCRUhFaUFuWWlBVUVGZGtFSWNTSUFJQUp5SUFFZ0FIWWlBVUVDZGtFRWNTSUFjaUFCSUFCMklnRkJBWFpCQW5FaUFISWdBU0FBZGlJQlFRRjJRUUZ4SWdCeUlBRWdBSFpxSWdOQkEzUWlBRUhRK3dGcUtBSUFJZ1FvQWdnaUFTQUFRY2o3QVdvaUFFWUVRRUdnK3dFZ0JVRitJQU4zY1NJRk5nSUFEQUVMUWJEN0FTZ0NBQm9nQVNBQU5nSU1JQUFnQVRZQ0NBc2dCRUVJYWlFQUlBUWdDRUVEY2pZQ0JDQUVJQWhxSWdJZ0EwRURkQ0lCSUFocklnTkJBWEkyQWdRZ0FTQUVhaUFETmdJQUlBb0VRQ0FLUVFOMklnRkJBM1JCeVBzQmFpRUhRYlQ3QVNnQ0FDRUVBbjhnQlVFQklBRjBJZ0Z4UlFSQVFhRDdBU0FCSUFWeU5nSUFJQWNNQVFzZ0J5Z0NDQXNoQVNBSElBUTJBZ2dnQVNBRU5nSU1JQVFnQnpZQ0RDQUVJQUUyQWdnTFFiVDdBU0FDTmdJQVFhajdBU0FETmdJQURBMExRYVQ3QVNnQ0FDSUdSUTBCSUFaQkFDQUdhM0ZCQVdzaUFDQUFRUXgyUVJCeElnSjJJZ0ZCQlhaQkNIRWlBQ0FDY2lBQklBQjJJZ0ZCQW5aQkJIRWlBSElnQVNBQWRpSUJRUUYyUVFKeElnQnlJQUVnQUhZaUFVRUJka0VCY1NJQWNpQUJJQUIyYWtFQ2RFSFEvUUZxS0FJQUlnRW9BZ1JCZUhFZ0NHc2hCQ0FCSVFJRFFBSkFJQUlvQWhBaUFFVUVRQ0FDS0FJVUlnQkZEUUVMSUFBb0FnUkJlSEVnQ0dzaUFpQUVJQUlnQkVraUFoc2hCQ0FBSUFFZ0Foc2hBU0FBSVFJTUFRc0xJQUVnQ0dvaUNTQUJUUTBDSUFFb0FoZ2hDeUFCSUFFb0Fnd2lBMGNFUUNBQktBSUlJZ0JCc1BzQktBSUFUd1JBSUFBb0Fnd2FDeUFBSUFNMkFnd2dBeUFBTmdJSURBd0xJQUZCRkdvaUFpZ0NBQ0lBUlFSQUlBRW9BaEFpQUVVTkJDQUJRUkJxSVFJTEEwQWdBaUVISUFBaUEwRVVhaUlDS0FJQUlnQU5BQ0FEUVJCcUlRSWdBeWdDRUNJQURRQUxJQWRCQURZQ0FBd0xDMEYvSVFnZ0FFRy9mMHNOQUNBQVFRdHFJZ0JCZUhFaENFR2srd0VvQWdBaUNVVU5BRUVmSVFWQkFDQUlheUVFQWtBQ1FBSkFBbjhnQ0VILy8vOEhUUVJBSUFCQkNIWWlBQ0FBUVlEK1AycEJFSFpCQ0hFaUFuUWlBQ0FBUVlEZ0gycEJFSFpCQkhFaUFYUWlBQ0FBUVlDQUQycEJFSFpCQW5FaUFIUkJEM1lnQVNBQ2NpQUFjbXNpQUVFQmRDQUlJQUJCRldwMlFRRnhja0VjYWlFRkN5QUZRUUowUWREOUFXb29BZ0FpQWtVTEJFQkJBQ0VBREFFTFFRQWhBQ0FJUVFCQkdTQUZRUUYyYXlBRlFSOUdHM1FoQVFOQUFrQWdBaWdDQkVGNGNTQUlheUlISUFSUERRQWdBaUVESUFjaUJBMEFRUUFoQkNBQ0lRQU1Bd3NnQUNBQ0tBSVVJZ2NnQnlBQ0lBRkJIWFpCQkhGcUtBSVFJZ0pHR3lBQUlBY2JJUUFnQVVFQmRDRUJJQUlOQUFzTElBQWdBM0pGQkVCQkFpQUZkQ0lBUVFBZ0FHdHlJQWx4SWdCRkRRTWdBRUVBSUFCcmNVRUJheUlBSUFCQkRIWkJFSEVpQW5ZaUFVRUZka0VJY1NJQUlBSnlJQUVnQUhZaUFVRUNka0VFY1NJQWNpQUJJQUIySWdGQkFYWkJBbkVpQUhJZ0FTQUFkaUlCUVFGMlFRRnhJZ0J5SUFFZ0FIWnFRUUowUWREOUFXb29BZ0FoQUFzZ0FFVU5BUXNEUUNBQUtBSUVRWGh4SUFocklnRWdCRWtoQWlBQklBUWdBaHNoQkNBQUlBTWdBaHNoQXlBQUtBSVFJZ0VFZnlBQkJTQUFLQUlVQ3lJQURRQUxDeUFEUlEwQUlBUkJxUHNCS0FJQUlBaHJUdzBBSUFNZ0NHb2lCaUFEVFEwQklBTW9BaGdoQlNBRElBTW9BZ3dpQVVjRVFDQURLQUlJSWdCQnNQc0JLQUlBVHdSQUlBQW9BZ3dhQ3lBQUlBRTJBZ3dnQVNBQU5nSUlEQW9MSUFOQkZHb2lBaWdDQUNJQVJRUkFJQU1vQWhBaUFFVU5CQ0FEUVJCcUlRSUxBMEFnQWlFSElBQWlBVUVVYWlJQ0tBSUFJZ0FOQUNBQlFSQnFJUUlnQVNnQ0VDSUFEUUFMSUFkQkFEWUNBQXdKQ3lBSVFhajdBU2dDQUNJQ1RRUkFRYlQ3QVNnQ0FDRURBa0FnQWlBSWF5SUJRUkJQQkVCQnFQc0JJQUUyQWdCQnRQc0JJQU1nQ0dvaUFEWUNBQ0FBSUFGQkFYSTJBZ1FnQWlBRGFpQUJOZ0lBSUFNZ0NFRURjallDQkF3QkMwRzArd0ZCQURZQ0FFR28rd0ZCQURZQ0FDQURJQUpCQTNJMkFnUWdBaUFEYWlJQUlBQW9BZ1JCQVhJMkFnUUxJQU5CQ0dvaEFBd0xDeUFJUWF6N0FTZ0NBQ0lHU1FSQVFhejdBU0FHSUFocklnRTJBZ0JCdVBzQlFiajdBU2dDQUNJQ0lBaHFJZ0EyQWdBZ0FDQUJRUUZ5TmdJRUlBSWdDRUVEY2pZQ0JDQUNRUWhxSVFBTUN3dEJBQ0VBSUFoQkwyb2lDUUovUWZqK0FTZ0NBQVJBUVlEL0FTZ0NBQXdCQzBHRS93RkNmemNDQUVIOC9nRkNnS0NBZ0lDQUJEY0NBRUg0L2dFZ0RFRU1ha0Z3Y1VIWXF0V3FCWE0yQWdCQmpQOEJRUUEyQWdCQjNQNEJRUUEyQWdCQmdDQUxJZ0ZxSWdWQkFDQUJheUlIY1NJQ0lBaE5EUXBCMlA0QktBSUFJZ1FFUUVIUS9nRW9BZ0FpQXlBQ2FpSUJJQU5ORFFzZ0FTQUVTdzBMQzBIYy9nRXRBQUJCQkhFTkJRSkFBa0JCdVBzQktBSUFJZ01FUUVIZy9nRWhBQU5BSUFNZ0FDZ0NBQ0lCVHdSQUlBRWdBQ2dDQkdvZ0Ewc05Bd3NnQUNnQ0NDSUFEUUFMQzBFQUVBOGlBVUYvUmcwR0lBSWhCVUg4L2dFb0FnQWlBMEVCYXlJQUlBRnhCRUFnQWlBQmF5QUFJQUZxUVFBZ0EydHhhaUVGQ3lBRklBaE5EUVlnQlVIKy8vLy9CMHNOQmtIWS9nRW9BZ0FpQkFSQVFkRCtBU2dDQUNJRElBVnFJZ0FnQTAwTkJ5QUFJQVJMRFFjTElBVVFEeUlBSUFGSERRRU1DQXNnQlNBR2F5QUhjU0lGUWY3Ly8vOEhTdzBGSUFVUUR5SUJJQUFvQWdBZ0FDZ0NCR3BHRFFRZ0FTRUFDd0pBSUFoQk1Hb2dCVTBOQUNBQVFYOUdEUUJCZ1A4QktBSUFJZ0VnQ1NBRmEycEJBQ0FCYTNFaUFVSCsvLy8vQjBzRVFDQUFJUUVNQ0FzZ0FSQVBRWDlIQkVBZ0FTQUZhaUVGSUFBaEFRd0lDMEVBSUFWckVBOGFEQVVMSUFBaUFVRi9SdzBHREFRTEFBdEJBQ0VEREFjTFFRQWhBUXdGQ3lBQlFYOUhEUUlMUWR6K0FVSGMvZ0VvQWdCQkJISTJBZ0FMSUFKQi92Ly8vd2RMRFFFZ0FoQVBJZ0ZCQUJBUElnQlBEUUVnQVVGL1JnMEJJQUJCZjBZTkFTQUFJQUZySWdVZ0NFRW9hazBOQVF0QjBQNEJRZEQrQVNnQ0FDQUZhaUlBTmdJQVFkVCtBU2dDQUNBQVNRUkFRZFQrQVNBQU5nSUFDd0pBQWtBQ1FFRzQrd0VvQWdBaUJ3UkFRZUQrQVNFQUEwQWdBU0FBS0FJQUlnTWdBQ2dDQkNJQ2FrWU5BaUFBS0FJSUlnQU5BQXNNQWd0QnNQc0JLQUlBSWdCQkFDQUFJQUZORzBVRVFFR3crd0VnQVRZQ0FBdEJBQ0VBUWVUK0FTQUZOZ0lBUWVEK0FTQUJOZ0lBUWNEN0FVRi9OZ0lBUWNUN0FVSDQvZ0VvQWdBMkFnQkI3UDRCUVFBMkFnQURRQ0FBUVFOMElnTkIwUHNCYWlBRFFjajdBV29pQWpZQ0FDQURRZFQ3QVdvZ0FqWUNBQ0FBUVFGcUlnQkJJRWNOQUF0QnJQc0JJQVZCS0dzaUEwRjRJQUZyUVFkeFFRQWdBVUVJYWtFSGNSc2lBR3NpQWpZQ0FFRzQrd0VnQUNBQmFpSUFOZ0lBSUFBZ0FrRUJjallDQkNBQklBTnFRU2cyQWdSQnZQc0JRWWovQVNnQ0FEWUNBQXdDQ3lBQUxRQU1RUWh4RFFBZ0FTQUhUUTBBSUFNZ0Iwc05BQ0FBSUFJZ0JXbzJBZ1JCdVBzQklBZEJlQ0FIYTBFSGNVRUFJQWRCQ0dwQkIzRWJJZ0JxSWdJMkFnQkJyUHNCUWF6N0FTZ0NBQ0FGYWlJQklBQnJJZ0EyQWdBZ0FpQUFRUUZ5TmdJRUlBRWdCMnBCS0RZQ0JFRzgrd0ZCaVA4QktBSUFOZ0lBREFFTFFiRDdBU2dDQUNJRElBRkxCRUJCc1BzQklBRTJBZ0FnQVNFREN5QUJJQVZxSVFKQjRQNEJJUUFDUUFKQUFrQUNRQUpBQWtBRFFDQUNJQUFvQWdCSEJFQWdBQ2dDQ0NJQURRRU1BZ3NMSUFBdEFBeEJDSEZGRFFFTFFlRCtBU0VBQTBBZ0J5QUFLQUlBSWdKUEJFQWdBaUFBS0FJRWFpSUVJQWRMRFFNTElBQW9BZ2doQUF3QUN3QUxJQUFnQVRZQ0FDQUFJQUFvQWdRZ0JXbzJBZ1FnQVVGNElBRnJRUWR4UVFBZ0FVRUlha0VIY1J0cUlna2dDRUVEY2pZQ0JDQUNRWGdnQW10QkIzRkJBQ0FDUVFocVFRZHhHMm9pQlNBSmF5QUlheUVDSUFnZ0NXb2hCaUFGSUFkR0JFQkJ1UHNCSUFZMkFnQkJyUHNCUWF6N0FTZ0NBQ0FDYWlJQU5nSUFJQVlnQUVFQmNqWUNCQXdEQ3lBRlFiVDdBU2dDQUVZRVFFRzArd0VnQmpZQ0FFR28rd0ZCcVBzQktBSUFJQUpxSWdBMkFnQWdCaUFBUVFGeU5nSUVJQUFnQm1vZ0FEWUNBQXdEQ3lBRktBSUVJZ0JCQTNGQkFVWUVRQ0FBUVhoeElRY0NRQ0FBUWY4QlRRUkFJQVVvQWdnaUF5QUFRUU4ySWdCQkEzUkJ5UHNCYWtjYUlBTWdCU2dDRENJQlJnUkFRYUQ3QVVHZyt3RW9BZ0JCZmlBQWQzRTJBZ0FNQWdzZ0F5QUJOZ0lNSUFFZ0F6WUNDQXdCQ3lBRktBSVlJUWdDUUNBRklBVW9BZ3dpQVVjRVFDQUZLQUlJSWdBZ0EwOEVRQ0FBS0FJTUdnc2dBQ0FCTmdJTUlBRWdBRFlDQ0F3QkN3SkFJQVZCRkdvaUFDZ0NBQ0lFRFFBZ0JVRVFhaUlBS0FJQUlnUU5BRUVBSVFFTUFRc0RRQ0FBSVFNZ0JDSUJRUlJxSWdBb0FnQWlCQTBBSUFGQkVHb2hBQ0FCS0FJUUlnUU5BQXNnQTBFQU5nSUFDeUFJUlEwQUFrQWdCU0FGS0FJY0lnTkJBblJCMFAwQmFpSUFLQUlBUmdSQUlBQWdBVFlDQUNBQkRRRkJwUHNCUWFUN0FTZ0NBRUYrSUFOM2NUWUNBQXdDQ3lBSVFSQkJGQ0FJS0FJUUlBVkdHMm9nQVRZQ0FDQUJSUTBCQ3lBQklBZzJBaGdnQlNnQ0VDSUFCRUFnQVNBQU5nSVFJQUFnQVRZQ0dBc2dCU2dDRkNJQVJRMEFJQUVnQURZQ0ZDQUFJQUUyQWhnTElBVWdCMm9oQlNBQ0lBZHFJUUlMSUFVZ0JTZ0NCRUYrY1RZQ0JDQUdJQUpCQVhJMkFnUWdBaUFHYWlBQ05nSUFJQUpCL3dGTkJFQWdBa0VEZGlJQVFRTjBRY2o3QVdvaEFnSi9RYUQ3QVNnQ0FDSUJRUUVnQUhRaUFIRkZCRUJCb1BzQklBQWdBWEkyQWdBZ0Fnd0JDeUFDS0FJSUN5RUFJQUlnQmpZQ0NDQUFJQVkyQWd3Z0JpQUNOZ0lNSUFZZ0FEWUNDQXdEQzBFZklRQWdBa0gvLy84SFRRUkFJQUpCQ0hZaUFDQUFRWUQrUDJwQkVIWkJDSEVpQTNRaUFDQUFRWURnSDJwQkVIWkJCSEVpQVhRaUFDQUFRWUNBRDJwQkVIWkJBbkVpQUhSQkQzWWdBU0FEY2lBQWNtc2lBRUVCZENBQ0lBQkJGV3AyUVFGeGNrRWNhaUVBQ3lBR0lBQTJBaHdnQmtJQU53SVFJQUJCQW5SQjBQMEJhaUVFQWtCQnBQc0JLQUlBSWdOQkFTQUFkQ0lCY1VVRVFFR2srd0VnQVNBRGNqWUNBQ0FFSUFZMkFnQWdCaUFFTmdJWURBRUxJQUpCQUVFWklBQkJBWFpySUFCQkgwWWJkQ0VBSUFRb0FnQWhBUU5BSUFFaUF5Z0NCRUY0Y1NBQ1JnMERJQUJCSFhZaEFTQUFRUUYwSVFBZ0F5QUJRUVJ4YWlJRUtBSVFJZ0VOQUFzZ0JDQUdOZ0lRSUFZZ0F6WUNHQXNnQmlBR05nSU1JQVlnQmpZQ0NBd0NDMEdzK3dFZ0JVRW9heUlEUVhnZ0FXdEJCM0ZCQUNBQlFRaHFRUWR4R3lJQWF5SUNOZ0lBUWJqN0FTQUFJQUZxSWdBMkFnQWdBQ0FDUVFGeU5nSUVJQUVnQTJwQktEWUNCRUc4K3dGQmlQOEJLQUlBTmdJQUlBY2dCRUVuSUFSclFRZHhRUUFnQkVFbmEwRUhjUnRxUVM5cklnQWdBQ0FIUVJCcVNSc2lBa0ViTmdJRUlBSkI2UDRCS1FJQU53SVFJQUpCNFA0QktRSUFOd0lJUWVqK0FTQUNRUWhxTmdJQVFlVCtBU0FGTmdJQVFlRCtBU0FCTmdJQVFleitBVUVBTmdJQUlBSkJHR29oQUFOQUlBQkJCellDQkNBQVFRaHFJUUVnQUVFRWFpRUFJQUVnQkVrTkFBc2dBaUFIUmcwRElBSWdBaWdDQkVGK2NUWUNCQ0FISUFJZ0Iyc2lCRUVCY2pZQ0JDQUNJQVEyQWdBZ0JFSC9BVTBFUUNBRVFRTjJJZ0JCQTNSQnlQc0JhaUVDQW45Qm9Qc0JLQUlBSWdGQkFTQUFkQ0lBY1VVRVFFR2crd0VnQUNBQmNqWUNBQ0FDREFFTElBSW9BZ2dMSVFBZ0FpQUhOZ0lJSUFBZ0J6WUNEQ0FISUFJMkFnd2dCeUFBTmdJSURBUUxRUjhoQUNBSFFnQTNBaEFnQkVILy8vOEhUUVJBSUFSQkNIWWlBQ0FBUVlEK1AycEJFSFpCQ0hFaUFuUWlBQ0FBUVlEZ0gycEJFSFpCQkhFaUFYUWlBQ0FBUVlDQUQycEJFSFpCQW5FaUFIUkJEM1lnQVNBQ2NpQUFjbXNpQUVFQmRDQUVJQUJCRldwMlFRRnhja0VjYWlFQUN5QUhJQUEyQWh3Z0FFRUNkRUhRL1FGcUlRTUNRRUdrK3dFb0FnQWlBa0VCSUFCMElnRnhSUVJBUWFUN0FTQUJJQUp5TmdJQUlBTWdCellDQUNBSElBTTJBaGdNQVFzZ0JFRUFRUmtnQUVFQmRtc2dBRUVmUmh0MElRQWdBeWdDQUNFQkEwQWdBU0lDS0FJRVFYaHhJQVJHRFFRZ0FFRWRkaUVCSUFCQkFYUWhBQ0FDSUFGQkJIRnFJZ01vQWhBaUFRMEFDeUFESUFjMkFoQWdCeUFDTmdJWUN5QUhJQWMyQWd3Z0J5QUhOZ0lJREFNTElBTW9BZ2dpQUNBR05nSU1JQU1nQmpZQ0NDQUdRUUEyQWhnZ0JpQUROZ0lNSUFZZ0FEWUNDQXNnQ1VFSWFpRUFEQVVMSUFJb0FnZ2lBQ0FITmdJTUlBSWdCellDQ0NBSFFRQTJBaGdnQnlBQ05nSU1JQWNnQURZQ0NBdEJyUHNCS0FJQUlnQWdDRTBOQUVHcyt3RWdBQ0FJYXlJQk5nSUFRYmo3QVVHNCt3RW9BZ0FpQWlBSWFpSUFOZ0lBSUFBZ0FVRUJjallDQkNBQ0lBaEJBM0kyQWdRZ0FrRUlhaUVBREFNTFFaejdBVUV3TmdJQVFRQWhBQXdDQ3dKQUlBVkZEUUFDUUNBREtBSWNJZ0pCQW5SQjBQMEJhaUlBS0FJQUlBTkdCRUFnQUNBQk5nSUFJQUVOQVVHayt3RWdDVUYrSUFKM2NTSUpOZ0lBREFJTElBVkJFRUVVSUFVb0FoQWdBMFliYWlBQk5nSUFJQUZGRFFFTElBRWdCVFlDR0NBREtBSVFJZ0FFUUNBQklBQTJBaEFnQUNBQk5nSVlDeUFES0FJVUlnQkZEUUFnQVNBQU5nSVVJQUFnQVRZQ0dBc0NRQ0FFUVE5TkJFQWdBeUFFSUFocUlnQkJBM0kyQWdRZ0FDQURhaUlBSUFBb0FnUkJBWEkyQWdRTUFRc2dBeUFJUVFOeU5nSUVJQVlnQkVFQmNqWUNCQ0FFSUFacUlBUTJBZ0FnQkVIL0FVMEVRQ0FFUVFOMklnQkJBM1JCeVBzQmFpRUNBbjlCb1BzQktBSUFJZ0ZCQVNBQWRDSUFjVVVFUUVHZyt3RWdBQ0FCY2pZQ0FDQUNEQUVMSUFJb0FnZ0xJUUFnQWlBR05nSUlJQUFnQmpZQ0RDQUdJQUkyQWd3Z0JpQUFOZ0lJREFFTFFSOGhBQ0FFUWYvLy93ZE5CRUFnQkVFSWRpSUFJQUJCZ1A0L2FrRVFka0VJY1NJQ2RDSUFJQUJCZ09BZmFrRVFka0VFY1NJQmRDSUFJQUJCZ0lBUGFrRVFka0VDY1NJQWRFRVBkaUFCSUFKeUlBQnlheUlBUVFGMElBUWdBRUVWYW5aQkFYRnlRUnhxSVFBTElBWWdBRFlDSENBR1FnQTNBaEFnQUVFQ2RFSFEvUUZxSVFJQ1FBSkFJQWxCQVNBQWRDSUJjVVVFUUVHayt3RWdBU0FKY2pZQ0FDQUNJQVkyQWdBZ0JpQUNOZ0lZREFFTElBUkJBRUVaSUFCQkFYWnJJQUJCSDBZYmRDRUFJQUlvQWdBaENBTkFJQWdpQVNnQ0JFRjRjU0FFUmcwQ0lBQkJIWFloQWlBQVFRRjBJUUFnQVNBQ1FRUnhhaUlDS0FJUUlnZ05BQXNnQWlBR05nSVFJQVlnQVRZQ0dBc2dCaUFHTmdJTUlBWWdCallDQ0F3QkN5QUJLQUlJSWdBZ0JqWUNEQ0FCSUFZMkFnZ2dCa0VBTmdJWUlBWWdBVFlDRENBR0lBQTJBZ2dMSUFOQkNHb2hBQXdCQ3dKQUlBdEZEUUFDUUNBQktBSWNJZ0pCQW5SQjBQMEJhaUlBS0FJQUlBRkdCRUFnQUNBRE5nSUFJQU1OQVVHayt3RWdCa0YrSUFKM2NUWUNBQXdDQ3lBTFFSQkJGQ0FMS0FJUUlBRkdHMm9nQXpZQ0FDQURSUTBCQ3lBRElBczJBaGdnQVNnQ0VDSUFCRUFnQXlBQU5nSVFJQUFnQXpZQ0dBc2dBU2dDRkNJQVJRMEFJQU1nQURZQ0ZDQUFJQU0yQWhnTEFrQWdCRUVQVFFSQUlBRWdCQ0FJYWlJQVFRTnlOZ0lFSUFBZ0FXb2lBQ0FBS0FJRVFRRnlOZ0lFREFFTElBRWdDRUVEY2pZQ0JDQUpJQVJCQVhJMkFnUWdCQ0FKYWlBRU5nSUFJQW9FUUNBS1FRTjJJZ0JCQTNSQnlQc0JhaUVEUWJUN0FTZ0NBQ0VDQW45QkFTQUFkQ0lBSUFWeFJRUkFRYUQ3QVNBQUlBVnlOZ0lBSUFNTUFRc2dBeWdDQ0FzaEFDQURJQUkyQWdnZ0FDQUNOZ0lNSUFJZ0F6WUNEQ0FDSUFBMkFnZ0xRYlQ3QVNBSk5nSUFRYWo3QVNBRU5nSUFDeUFCUVFocUlRQUxJQXhCRUdva0FDQUFDL1lGQVF0L0FrQWdBVUVCYXlJS1FZQUNUd1JBSUFBZ0FDZ0NIQ0lESUFwQkdDQUtaMnNpQm5ZaUFrRUJhaUlFYmlJQk5nSWtJQUFnQUNnQ0lDSUZJQUpCQUNBRklBRnVJZ1ZCQVdvaUNDQUVheUlFSUFRZ0NFc2JJQUlnQld0cUlndHJJQUZzSWdKcklnYzJBaUFnQUNBQklBTWdBbXNnQ3hzaUFqWUNIQ0FDUVlDQWdBUk5CRUFnQUNnQ0dDRURJQUFvQWlnaEJDQUFLQUlVSVFVZ0FDZ0NCQ0VNQTBBZ0FDQUNRUWgwSWdnMkFod2dBQ0FGUVFocUlnVTJBaFJCQUNFQklBTWdERWtFUUNBQUlBTkJBV29pQ1RZQ0dDQUFLQUlBSUFOcUxRQUFJUUVnQ1NFREN5QUFJQUUyQWlnZ0FDQUJJQVJCQ0hSeVFRRjJRZjhCY1NBSFFRaDBRWUQrLy84SGNYSkIvd0Z6SWdjMkFpQWdBa0dCZ0FKSklRa2dBU0VFSUFnaEFpQUpEUUFMQ3lBTElBWjBJUWdnQUNnQ0RDRUhBa0FnQmlBQUtBSVFJZ0ZOQkVBZ0FTRUZEQUVMSUFBb0FnZ2hBaUFBS0FJRUlRUURRRUVBSVFNZ0FpQUVTUVIvSUFBZ0FrRUJhaUlDTmdJSUlBQW9BZ0FnQkNBQ2Eyb3RBQUFGUVFBTElBRjBJQWR5SVFjZ0FVRVJTQ0VESUFGQkNHb2lCU0VCSUFNTkFBc0xJQUFnQlNBR2F6WUNFQ0FBSUFjZ0JuWTJBZ3dnQUNBQUtBSVVJQVpxTmdJVUlBZEJmeUFHZEVGL2MzRWdDSElpQmlBS1RRMEJJQUJCQVRZQ0xDQUtEd3NnQUNBQUtBSWNJZ01nQVc0aUFqWUNKQ0FBSUFBb0FpQWlCQ0FCSUFRZ0FtNGlCRUYvY3lBQmFrRUFJQVJCQVdvaUJDQUJheUlCSUFFZ0JFc2JhaUlHUVg5emFpQUNiQ0lCYXlJSE5nSWdJQUFnQWlBRElBRnJJQVliSWdJMkFod2dBa0dBZ0lBRVN3MEFJQUFvQWhnaEF5QUFLQUlvSVFRZ0FDZ0NGQ0VGSUFBb0FnUWhDZ05BSUFBZ0FrRUlkQ0lJTmdJY0lBQWdCVUVJYWlJRk5nSVVRUUFoQVNBRElBcEpCRUFnQUNBRFFRRnFJZ2syQWhnZ0FDZ0NBQ0FEYWkwQUFDRUJJQWtoQXdzZ0FDQUJOZ0lvSUFBZ0FTQUVRUWgwY2tFQmRrSC9BWEVnQjBFSWRFR0Evdi8vQjNGeVFmOEJjeUlITmdJZ0lBSkJnWUFDU1NFSklBRWhCQ0FJSVFJZ0NRMEFDd3NnQmd1RUJRSUtmd1o5SUFBb0FoZ2hDQ0FBS0FJQUlRa2dCVUVCVGdSQUEwQWdDQ0FKUVFGMUlnbEJBblJxSVFnZ0IwRUJhaUlISUFWSERRQUxDeUFDSUFSQkFYUkJmSEZxSVFjZ0FDQUZRUUowYWlnQ0NDRUxBa0FnQ1VFRFRBUkFJQXNnQnhBN0RBRUxJQWxCQW5VaUNrRUJJQXBCQVVvYklRNUJBQ0VGSUFFZ0NVRUJkU0lOUVFGcklBWnNRUUowYWlFQUlBc29BaXdoREVFQUlBWkJBWFFpQm10QkFuUWhEd05BSUFjZ0RDNEJBRUVEZENJUVFRUnlhaUFBS2dJQUloTWdDQ0FGUVFKMGFpb0NBQ0lVbENBQktnSUFJaEVnQ0NBRklBcHFRUUowYWlvQ0FDSVNsSkk0QWdBZ0J5QVFhaUFVSUJHVUlCTWdFcFNUT0FJQUlBeEJBbW9oRENBQUlBOXFJUUFnQVNBR1FRSjBhaUVCSUFWQkFXb2lCU0FPUncwQUN5QUxJQWNRT3lBSlFRUklEUUFnQ2tFQmFrRUJkU0lBUVFFZ0FFRUJTaHNoQUNBSElBMUJBblJxSVFGQkFDRUZBMEFnQVVFRWF5SUdLZ0lBSVJNZ0FVRUlheUlCS2dJQUlSUWdCeUFIS2dJRUloRWdDQ0FGUVFKMGFpb0NBQ0lTbENBSEtnSUFJaFVnQ0NBRklBcHFRUUowYWlvQ0FDSVdsSkk0QWdBZ0JpQVJJQmFVSUJVZ0VwU1RPQUlBSUFFZ0V5QUlJQW9nQlVGL2N5SUdha0VDZEdvcUFnQWlFWlFnRkNBSUlBWWdEV3BCQW5ScUtnSUFJaEtVa2pnQ0FDQUhJQk1nRXBRZ0ZDQVJsSk00QWdRZ0IwRUlhaUVISUFWQkFXb2lCU0FBUncwQUN3c2dCRUVDYlNFQUlBUkJBazRFUUNBQ0lBUkJBblFpQVdvaENDQUJJQU5xSVFkQkFDRUZBMEFnQWlBQ0tnSUFJaE1nQjBFRWF5SUhLZ0lBSWhTVUlBaEJCR3NpQ0NvQ0FDSVJJQU1xQWdBaUVwU1RPQUlBSUFnZ0VTQVVsQ0FUSUJLVWtqZ0NBQ0FEUVFScUlRTWdBa0VFYWlFQ0lBVkJBV29pQlNBQVJ3MEFDd3NMcVJvQ0puOERmU01BUWRBQWF5SU1KQUFnQUNnQ0NDRVlJQXhCQURZQ0RDQU1RUUEyQWdoQmZ5RUhBa0FnQUNnQ0FDSUtLQUlrSWdoQkFFZ05BQ0FBSUFvb0FnUWlIRUdBRUdvaUZpQVliRUVDZEdvZ0dFSGdBR3hxUWR3QWFpSU5JQW9vQWdnaUMwRURkQ0lHYWlJVUlBWnFJaGtnQm1vaEp5QUFLQUlRSUFSc0lSRWdBQ2dDR0NFSklBQW9BaFFoRHlBQUtBSU1JUkFnQ2lnQ0lDRWJJQW9vQWl3aEJBTkFJQkVnQkNBT2RFY0VRQ0FJSUE1S0lRWWdEa0VCYWlFT0lBWU5BUXdDQ3dzZ0FrSDdDVXNOQUNBRFJRMEFJQmhCQVNBWVFRRktHeUVkUVFBaEJrRUFJQkZyUVFKMElRUURRQ0FHUVFKMElnY2dERUVZYW1vZ0FDQUdJQlpzUVFKMGFrSGNBR29pQ0RZQ0FDQU1RUkJxSUFkcUlBUWdDR3BCZ0VCck5nSUFJQVpCQVdvaUJpQWRSdzBBQ3lBQlFRQWdBa0VCU2h0RkJFQWdBQ0FSSUE0UVd5QU1RUkJxSUFNZ0VTQVlJQUFvQWhBZ0NrRVFhaUFBUWRRQWFoQTVJQkVnQUNnQ0VHMGhCd3dCQ3lBS0tBSU1JUjVCQUNFR0lBQWdBQ2dDTkVFQVJ6WUNPQ0FGUlFSQUlBeEJJR29nQVNBQ0VGTWdERUVnYWlFRkMwRUJJU01DUUNBUVFRRkhEUUFnQzBFQlNBMEFBMEFnRFNBR1FRSjBhaUlCSUFFcUFnQWlMQ0FOSUFZZ0MycEJBblJxS2dJQUlpMGdMQ0F0WGhzNEFnQWdCa0VCYWlJR0lBdEhEUUFMQ3dKL0lBVW9BaFFpQ0NBRktBSWNaeUlFYWtFZ2F5SUdJQUpCQTNRaUZVZ0VRRUVBSVNOQkFTQUdRUUZIRFFFYUlBVkJEeEFHSWdGRkJFQkJBU0VHUVFFTUFnc2dCU2dDRkNFSUlBRWhJeUFGS0FJY1p5RUVDeUFGSUJVZ0NHc2dCR3NnQ0dwQklHbzJBaFFnRlNFR1FRQUxJU2hEQUFBQUFDRXNBa0FnRHcwQUlBWkJFR29nRlVvTkFBSjlRd0FBQUFBZ0JVRUJFQVpGRFFBYUlBVWdCVUVHRUJZaUFVRUVhaEFKUVJBZ0FYUnFJUUVnQlVFREVBa2hCQ0FWSUFVb0FoUWdCU2dDSEdkcVFSNXJUZ1JBSUFWQmh6MUJBaEFESVI4TElBRkJBV3NoSkNBRVFRRnFza01BQU1BOWxBc2hMQ0FGS0FJVUlBVW9BaHhuYWtFZ2F5RUdDeUFHUVFOcUlRWUNRQ0FPUlEwQUlBWWdGVW9OQUNBRlFRTVFCaUVYSUFVb0FoUWdCU2dDSEdkcVFSMXJJUVlMSUFvZ0R5QUpJQTBnQmlBVlRBUi9JQVZCQXhBR0JVRUFDeUFGSUJBZ0RoQ2VBU0FNSUF0QkFuUkJEMnBCY0hGcklpQWlFeVFBSUE1QkFFY2dCU2dDQkVFRGRDSUdJQVVvQWhRZ0JTZ0NIR2RxUVNCcklnUkJBa0VFSUJjYklnRkJBWEpxVDNFaEZrRUFJUWNDUUNBSklBOU1JaElOQUNBR0lCWnJJaG9nQVNBRWFrOEVRQ0FGSUFFUUJpRUhJQVVvQWhRZ0JTZ0NIR2RxUVNCcklRUUxJQ0FnRDBFQ2RHb2dCellDQUNBUFFRRnFJZ1lnQ1VZTkFFRUVRUVVnRnhzaEFTQUhJUWdEUUNBYUlBRWdCR3BQQkVBZ0JTQUJFQVlnQ0hNaUNDQUhjaUVISUFVb0FoUWdCU2dDSEdkcVFTQnJJUVFMSUNBZ0JrRUNkR29nQ0RZQ0FDQUdRUUZxSWdZZ0NVY05BQXNMUVFBaEJnSkFJQlpGRFFBZ0RrRURkRUd3TzJvaUFTQUhJQmRCQW5RaUJHcHFMUUFBSUFFZ0JFRUNjaUFIYW1vdEFBQkdEUUFnQlVFQkVBWkJBWFFoQmdzZ0VrVUVRQ0FHSUJkQkFuUnFJUUVnRGtFRGRFR3dPMm9oQkNBUElRWURRQ0FnSUFaQkFuUnFJZ2NnQkNBQklBY29BZ0JxYWl3QUFEWUNBQ0FHUVFGcUlnWWdDVWNOQUFzTFFRSWhKU0FWSUFVb0FoUWdCU2dDSEdkcVFSeHJUZ1JBSUFWQmlqMUJCUkFESVNVTElCTWdDMEVDZEVFUGFrRndjU0lCYXlJYUlnUWtBQ0FLSUJvZ0RpQVFFRjVCQmlFVElBSkJCblFoRmlBRUlBRnJJaUVpSmlRQUlBVVFDeUVDQWtBZ0VnUkFJQlloQkF3QkN5QVBJUVlnRmlFRUEwQWdHeUFHSWdGQkFXb2lCa0VCZEdvdUFRQWdHeUFCUVFGMGFpNEJBR3NnRUd3Z0RuUWlCMEVEZENJSUlBZEJNQ0FIUVRCS0d5SUhJQWNnQ0VvYklTSWdHaUFCUVFKMElpbHFJU29nQkNFQklCTWhDRUVBSVFjRFFBSkFJQWNoRWlBQklnUWdDRUVEZENBQ2Frd05BQ0FTSUNvb0FnQk9EUUFnQkNBaWF5RUJJQklnSW1vaEJ5QUZJQWdRQmlFcklBVVFDeUVDUVFFaENDQXJEUUVMQ3lBaElDbHFJQkkyQWdBZ0UwRUJhMEVDSUJOQkFrb2JJQk1nRWtFQVNoc2hFeUFHSUFsSERRQUxDeUFtSUF0QkFuUkJEMnBCY0hGcklnY2lBU1FBUVFVaENDQUVJQUpCTUdwT0JFQWdCVUdPUFVFSEVBTWhDQXNnQzBFQmRDRUVJQllnQlJBTFFYOXphaUVDUVFBaEJpQWVJQWtnQ1NBZVNoc2hHMEVCSUE1MEloNUJBQ0FYR3lFaUlBRWdDMEVDZEVFUGFrRndjU0lCYXlJVEloSWtBQ0FTSUFGckloSWlKaVFBSUFvZ0R5QUpJQ0VnR2lBSUlBeEJER29nREVFSWFpQUNBbjhnRGtFQ1NRUkFRUUFoQVVFQURBRUxRUUFoQVVFQUlCZEZEUUFhSUFJZ0RrRURkRUVRYWs0aUFVRURkQXNpR21zZ0RFRUVhaUFUSUFjZ0VpQVFJQTRnQlJDYkFTRWhJQW9nRHlBSklBMGdCeUFGSUJBUW5RRWdIRUVDYlNBUmEwRUNkRUdBUUdzaEFnTkFJQXhCR0dvZ0JrRUNkR29vQWdBaUNDQUlJQkZCQW5ScUlBSVFEaG9nQmtFQmFpSUdJQjFIRFFBTElDWWdDeUFRYkNJSVFROXFRWEJ4YXlJR0lnSWtBQ0FDSUJBZ0VXeEJBblJCRDJwQmNIRnJJZ0lrQUNBS0lBOGdDU0FDSUFJZ0VVRUNkR3BCQUNBUVFRSkdHeUFHSUJNZ0lpQWxJQXdvQWdnZ0RDZ0NEQ0FnSUJZZ0dtc2dEQ2dDQkNBRklBNGdJU0FBUVNocUlBQW9BaVFnQUNnQ0lCQmhBa0FnQVFSQUlBVkJBUkFKSVFFZ0NpQVBJQWtnRFNBSElCSWdGU0FGS0FJVWF5QUZLQUljWjJ0QklHb2dCU0FRRUZRZ0FVVU5BU0FLSUFJZ0JpQU9JQkFnRVNBUElBa2dEU0FVSUJrZ0V5QUFLQUlvSUFBb0FpUVFZd3dCQ3lBS0lBOGdDU0FOSUFjZ0VpQVZJQVVvQWhScklBVW9BaHhuYTBFZ2FpQUZJQkFRVkFzQ2Z5QW9SUVJBUVFBaEJpQUlRUUJLQkVBRFFDQU5JQVpCQW5ScVFZQ0FnSTk4TmdJQUlBWkJBV29pQmlBSVJ3MEFDd3NnQ2lBQ0lBeEJFR29nRFNBUElCc2dFQ0FZSUJjZ0RpQUFLQUlRSUNNZ0FDZ0NKQkFpSUF4QkVHb01BUXNnQ2lBQ0lBeEJFR29nRFNBUElCc2dFQ0FZSUJjZ0RpQUFLQUlRUVFBZ0FDZ0NKQkFpSUF4QkVHb0xJUUpCQUNFR0FrQWdEa1VFUUFOQUlBQWdBQ2dDUENJQlFROGdBVUVQU2hzaUFUWUNQQ0FBSUFBb0FrQWlCMEVQSUFkQkQwb2JJZ2MyQWtBZ0RFRVFhaUFHUVFKMGFpZ0NBQ0lJSUFnZ0J5QUJJQW9vQWl3Z0FDb0NTQ0FBS2dKRUlBQW9BbEFnQUNnQ1RDQUtLQUk4SUJ3Z0FDZ0NKQkFaSUFaQkFXb2lCaUFkUncwQURBSUxBQXNEUUNBQUlBQW9BandpQVVFUElBRkJEMG9iSWdjMkFqd2dBQ0FBS0FKQUlnRkJEeUFCUVE5S0d5SUlOZ0pBSUF4QkVHb2dCa0VDZEdvb0FnQWlBU0FCSUFnZ0J5QUtLQUlzSUFBcUFrZ2dBQ29DUkNBQUtBSlFJQUFvQWt3Z0NpZ0NQQ0FjSUFBb0FpUVFHU0FCSUFvb0Fpd2lCMEVDZEdvaUFTQUJJQUFvQWp3Z0pDQVJJQWRySUFBcUFrUWdMQ0FBS0FKTUlCOGdDaWdDUENBY0lBQW9BaVFRR1NBR1FRRnFJZ1lnSFVjTkFBc0xJQUFnQUNnQ1BEWUNRQ0FBS2dKRUlTMGdBQ0FzT0FKRUlBQWdMVGdDU0NBQUtBSk1JUUVnQUNBZk5nSk1JQUFnQVRZQ1VDQUFJQ1EyQWp3Z0RnUkFJQUFnSHpZQ1VDQUFJQ3c0QWtnZ0FDQWtOZ0pBQ3lBUVFRRkdCRUFnRFNBTFFRSjBJZ0ZxSUEwZ0FSQUVHZ3NDUUNBWEJFQWdDMEVCU0EwQklBUkJBU0FFUVFGS0d5RUJRUUFoQmdOQUlCUWdCa0VDZENJRWFpSUhJQWNxQWdBaUxDQUVJQTFxS2dJQUlpMGdMQ0F0WFJzNEFnQWdCa0VCYWlJR0lBRkhEUUFMREFFTElCa2dGQ0FMUVFOMElnRVFCQm9nRkNBTklBRVFCQm9nQzBFQlNBMEFJQjZ5UTI4U2d6cVVRd0FBZ0Q4Z0FDZ0NORUVLU0JzaExDQUVRUUVnQkVFQlNoc2hBVUVBSVFZRFFDQW5JQVpCQW5RaUJHb2lCeUFzSUFjcUFnQ1NJaTBnQkNBTmFpb0NBQ0l1SUMwZ0xsMGJPQUlBSUFaQkFXb2lCaUFCUncwQUN3dEJBQ0VHQWtBZ0QwRUFTZ1JBQTBBZ0RTQUdRUUowSWdGcVFRQTJBZ0FnQVNBWmFrR0FnSUNQZkRZQ0FDQUJJQlJxUVlDQWdJOThOZ0lBSUFaQkFXb2lCaUFQUncwQUN5QUpJQXRJQkVBZ0NTRUdBMEFnRFNBR1FRSjBJZ0ZxUVFBMkFnQWdBU0FaYWtHQWdJQ1BmRFlDQUNBQklCUnFRWUNBZ0k5OE5nSUFJQVpCQVdvaUJpQUxSdzBBQ3d0QkFDRUdBMEFnRFNBR0lBdHFRUUowSWdGcVFRQTJBZ0FnQVNBWmFrR0FnSUNQZkRZQ0FDQUJJQlJxUVlDQWdJOThOZ0lBSUFaQkFXb2lCaUFQUncwQUN5QUpJQXRPRFFFRFFDQU5JQWtnQzJwQkFuUWlBV3BCQURZQ0FDQUJJQmxxUVlDQWdJOThOZ0lBSUFFZ0ZHcEJnSUNBajN3MkFnQWdDVUVCYWlJSklBdEhEUUFMREFFTElBa2dDMDROQUNBSklRWURRQ0FOSUFaQkFuUWlBV3BCQURZQ0FDQUJJQmxxUVlDQWdJOThOZ0lBSUFFZ0ZHcEJnSUNBajN3MkFnQWdCa0VCYWlJR0lBdEhEUUFMQTBBZ0RTQUpJQXRxUVFKMElnRnFRUUEyQWdBZ0FTQVpha0dBZ0lDUGZEWUNBQ0FCSUJScVFZQ0FnSTk4TmdJQUlBbEJBV29pQ1NBTFJ3MEFDd3NnQUNBRktBSWNOZ0lvSUFJZ0F5QVJJQmdnQUNnQ0VDQUtRUkJxSUFCQjFBQnFFRGtnQUVFQU5nSTBRWDBoQnlBVklBVW9BaFFnQlNnQ0hHZHFRU0JyVGdSQUlBVW9BaXdFUUNBQVFRRTJBaXdMSUJFZ0FDZ0NFRzBoQndzTElBeEIwQUJxSkFBZ0J3dkhCUUlGZndwOUFrQUNRQ0FGUXdBQUFBQmNEUUFnQmtNQUFBQUFYQTBBSUFBZ0FVWU5BU0FBSUFFZ0JFRUNkQkFPR2c4TFFRQWhDMEYrSUFOQkR5QURRUTlLR3lJTWF5RU5JQXhCZjNNaERrRUJJQXhySVE5QkFDQU1heUVRSUFoQkRHd2lBMEdJTzJvcUFnQWdCcFFoRkNBRFFZUTdhaW9DQUNBR2xDRVZJQU5CZ0R0cUtnSUFJQWFVSVJaQkFDQUtJQWNnQ0VZYklBb2dCU0FHV3hzZ0NpQUNRUThnQWtFUFNoc2lDQ0FNUmhzaUFrRUJUZ1JBSUFkQkRHd2lBMEdJTzJvcUFnQWdCWlFoRnlBRFFZUTdhaW9DQUNBRmxDRVlJQU5CZ0R0cUtnSUFJQVdVSVJsQkFpQU1heUVESUFFZ0QwRUNkR29xQWdBaEVTQUJJQkJCQW5ScUtnSUFJUklnQVNBT1FRSjBhaW9DQUNFVElBRWdEVUVDZEdvcUFnQWhCVUVBSVFvRFFDQUFJQXBCQW5RaUIyb2dCU0FCSUFNZ0NtcEJBblJxS2dJQUlocVNJQlFnQnlBSmFpb0NBQ0lGSUFXVUlnV1VsQ0FSSUJPU0lCVWdCWlNVSUJJZ0ZpQUZsSlFnQVNBSGFpb0NBQ0FCSUFvZ0NHdEJBblJxSWdjcUFnQWdHVU1BQUlBL0lBV1RJZ1dVbEpJZ0dDQUZsQ0FIS2dJRUlBZEJCR3NxQWdDU2xKSWdGeUFGbENBSEtnSUlJQWRCQ0dzcUFnQ1NsSktTa3BJNEFnQWdFeUVGSUJJaEV5QVJJUklnR2lFUklBcEJBV29pQ2lBQ1J3MEFDeUFDSVFzTElBWkRBQUFBQUZzRVFDQUFJQUZHRFFFZ0FDQUNRUUowSWdOcUlBRWdBMm9nQkNBQ2EwRUNkQkFPR2c4TElBUWdDMnNpQjBFQlNBMEFJQUFnQzBFQ2RDSUVhaUVEUVFJZ0RHc2hBaUFCSUFScUlnRWdEVUVDZEdvcUFnQWhFeUFCSUE1QkFuUnFLZ0lBSVFVZ0FTQVFRUUowYWlvQ0FDRVJJQUVnRDBFQ2RHb3FBZ0FoRWtFQUlRb0RRQ0FESUFwQkFuUWlBR29nRkNBVElBRWdBaUFLYWtFQ2RHb3FBZ0FpQnBLVUlCVWdCU0FTa3BRZ0ZpQVJsQ0FBSUFGcUtnSUFrcEtTT0FJQUlBVWhFeUFSSVFVZ0VpRVJJQVloRWlBS1FRRnFJZ29nQjBjTkFBc0xDNkFDQVFaL0lBTkJBV3NoQ0VFZklBTm5JZ2RySVFVQ1FDQURRUUpJQkVBZ0F5RUVEQUVMSUFNaEJBTkFJQVFnQWlBR1FRRjBJZ1JCQW5KcUxnRUFJZ2tnQ1d3Z0FpQUVhaTRCQUNJRUlBUnNhaUFGZG1vaEJDQUdRUUpxSWdZZ0NFZ05BQXNnQTBGK2NTRUdDeUFESUFaS0JFQWdCQ0FDSUFaQkFYUnFMZ0VBSWdRZ0JHd2dCWFpxSVFRTFFRQWhCVUVpSUFjZ0JHZHFheUlFUVFBZ0JFRUFTaHNoQkNBRFFRSklCSDlCQUFWQkFDRUdBMEFnQlNBQ0lBWkJBWFFpQlVFQ2Ntb3VBUUFpQnlBSGJDQUNJQVZxTGdFQUlnVWdCV3hxSUFSMmFpRUZJQVpCQW1vaUJpQUlTQTBBQ3lBRFFYNXhDeUlHSUFOSUJFQWdBaUFHUVFGMGFpNEJBQ0lDSUFKc0lBUjJJQVZxSVFVTElBRWdCRFlDQUNBQUlBVTJBZ0FMMHdFQkJYOGdBRUd3TUVFSUVBTWhBaUFBUWY0d1FRZ1FBeUVESUFCQmhURkJDQkFESVFRZ0FTQUFRZjR3UVFnUUF5QUNJQUpCQlcwaUJVRjdiR3BCQTJ4cVFRRjBRWkF3YWlJQ0xnRUNJQUl1QVFBaUFtc2lCa0gvL3dOeFFab3piRUVRZGlBR1FSQjFRWm96YkdvZ0FFR0ZNVUVJRUFOQkVYUkJFSFZCQVhKc0lBSnFJZ0EyQWdRZ0FTQURJQVZCQTJ4cVFRRjBRWkF3YWlJQkxnRUNJQUV1QVFBaUFXc2lBa0gvL3dOeFFab3piRUVRZGlBQ1FSQjFRWm96YkdvZ0JFRVJkRUVRZFVFQmNtd2dBV29nQUdzMkFnQUx4UUlCQTM4akFFR1FBV3NpQmlRQUlBQW9BcGdTSVFjZ0JrRUFOZ0tJQVFKQUFrQUNRQUpBSUFRT0F3RUNBQUlMSUFBZ0FDZ0MxQkpCQW5ScVFmUVNhaWdDQUVFQlJ3MEJDeUFHSUFkQkQycEI4UC8vL3dkeFFRRjBheUlJSkFBZ0FDQUJJQUFvQXRRU0lBUWdCUkFvSUFFZ0NDQUFRYzBWYWlJQkxBQUFJQUJCemhWcUxBQUFJQUFvQXBnU0VDY2dBQ0FHSUFVUWJpQUFJQVlnQWlBSUVHOGdBQ0FHSUFKQkFCQkZJQUJCQURZQ3dDQWdBRUVBTmdMSUVpQUFJQUVzQUFBMkFzUWdEQUVMSUFBZ0JpQUNRUUVRUlFzZ0FFSEVDbW9pQVNBQklBQW9BcGdTSWdSQkFYUnFJQUFvQXFBU0lBUnJRUUYwSWdFUURpQUJhaUFDSUFBb0FwZ1NRUUYwRUFRYUlBQWdCaUFDSUFjUWVTQUFJQUlnQnhCeUlBQWdBQ2dDbEJKQkFuUWdCbXBCQkdzb0FnQTJBb1FTSUFNZ0J6WUNBQ0FHUVpBQmFpUUFRUUFMOVFZQ0NuOEVmaU1BUWVBQWF5RUdBbjhDUUNBQlFRQktCRUFEUUNBR0lBSkJBblJxSUFBZ0FrRUJkR291QVFBaUJVRU1kRFlDQUNBRUlBVnFJUVFnQWtFQmFpSUNJQUZIRFFBTElBUkIveDlLQkVCQkFBOExJQUZCQVdzaEFrS0FnSUNBQkNFTUlBRkJBa2dFUUNBQ0lRUU1BZ3NEUUNBR0lBSWlBRUVDZEdvb0FnQWlCRUdlMy84SGFrRzh2djhQU3dSQVFRQVBDMEVBSUF4QmdJQ0FnQVJCQUNBRVFRZDBhNndpRFNBTmZrSWdpS2RySWdXc2ZrSWVpS2RCZkhFaUNrSHV4Z1pJRFFNYVFRQWhCRUVBUWYvLy8vOEJJQVVnQlNBRlFSOTFJZ0pxSUFKelp5SUZRUUZyZENJRFFSQjFJZ2h0SWdkQkVIUWlDVUVRZFNJQ0lBTkIvLzhEY1d4QkVIVWdBaUFJYkdwQkEzUnJJZ01nQjBFUGRVRUJha0VCZFd3Z0NXb2dBMEVRZFNBQ2JHb2dBMEg0L3dOeElBSnNRUkIxYXF3aERpQUJRUUYySWdGQkFTQUJRUUZMR3lFSlFSOGdCV3V0SVE4RFFDQUdJQVJCQW5ScUlnTW9BZ0FpQWlBR0lBQWdCRUYvYzJwQkFuUnFJZ3NvQWdBaUFhd2dEWDVDSG9oQ0FYeENBWWluSWdocklnZEJnSUNBZ0hoQi8vLy8vd2NnQjBGL1NpSUhHeUFJSUFJZ0J4dEJmM01nQWlBSUlBY2JjVUYvU2h1c0lBNStJUXdDZmdKQUFrQWdCVUVmUmdSQUlBeENBWU1nREVJQmgzd2lERUtBZ0lDQUNIeEMvLy8vL3c5WURRRkJBQThMSUF3Z0Q0ZENBWHhDQVljaURFS0FnSUNBQ0h4Qy8vLy8vdzlZRFFGQkFBOExJQU1nREQ0Q0FDQUJJQUtzSUExK1FoNklRZ0Y4UWdHSXB5SUNheUlEUVlDQWdJQjRRZi8vLy84SElBTkJmMG9pQXhzZ0FpQUJJQU1iUVg5eklBRWdBaUFERzNGQmYwb2JyQ0FPZmlJTVFnR0RJQXhDQVlkOERBRUxJQU1nREQ0Q0FDQUJJQUtzSUExK1FoNklRZ0Y4UWdHSXB5SUNheUlEUVlDQWdJQjRRZi8vLy84SElBTkJmMG9pQXhzZ0FpQUJJQU1iUVg5eklBRWdBaUFERzNGQmYwb2JyQ0FPZmlBUGgwSUJmRUlCaHdzaURFS0FnSUNBQ0h4Qy8vLy8vdzlXQkVCQkFBOExJQXNnREQ0Q0FDQUVRUUZxSWdRZ0NVY05BQXNnQUVFQmF5RUNJQXFzSVF4QkFDRUVJQUFpQVVFQlNnMEFDd3dCQ3lBQlFRRnJJUVJDZ0lDQWdBUWhEQXRCQUNBR0lBUkJBblJxS0FJQVFaN2Yvd2RxUWJ5Ky93OUxEUUFhUVFBZ0RFS0FnSUNBZ0lDQWdNQUFRUUFnQmlnQ0FFRUhkR3VzSWd3Z0RINUNnSUNBZ1BELy8vLy9BSU45UWlDSGZrSWVpS2RCZkhFaUFDQUFRZTdHQmtnYkN3c3BBUUYvSXdCQkVHc2lBaVFBSUFJZ0FUWUNERUdROUFFb0FnQWdBQ0FCRUlzQklBSkJFR29rQUF1NUF3TUNmd0YrQW53Z0FMMGlBMEkvaUtjaEFRSkFBa0FDZkFKQUlBQUNmd0pBQWtBZ0EwSWdpS2RCLy8vLy93ZHhJZ0pCcThhWWhBUlBCRUFnQUwxQy8vLy8vLy8vLy8vL0FJTkNnSUNBZ0lDQWdQai9BRllFUUNBQUR3c2dBRVR2T2ZyK1FpNkdRR1JCQVhORkJFQWdBRVFBQUFBQUFBRGdmNklQQ3lBQVJOSzhldDBySTRiQVkwRUJjdzBCSUFCRVVUQXQxUkJKaDhCalJRMEJEQVlMSUFKQnc5elkvZ05KRFFNZ0FrR3l4Y0wvQTBrTkFRc2dBRVQrZ2l0bFJ4WDNQNklnQVVFRGRFSGczUUZxS3dNQW9DSUFtVVFBQUFBQUFBRGdRV01FUUNBQXFnd0NDMEdBZ0lDQWVBd0JDeUFCUVFGeklBRnJDeUlCdHlJRVJBQUE0UDVDTHVhL29xQWlBQ0FFUkhZOGVUWHZPZW85b2lJRm9Rd0JDeUFDUVlDQXdQRURUUTBDUVFBaEFTQUFDeUVFSUFBZ0JDQUVJQVFnQktJaUFDQUFJQUFnQUNBQVJOQ2t2bkpwTjJZK29rVHhhOUxGUWIyN3ZxQ2lSQ3plSmE5cVZoRS9vS0pFazcyK0ZtekJacitnb2tRK1ZWVlZWVlhGUDZDaW9TSUFva1FBQUFBQUFBQUFRQ0FBb2FNZ0JhR2dSQUFBQUFBQUFQQS9vQ0VFSUFGRkRRQWdCQ0FCRUJRaEJBc2dCQThMSUFCRUFBQUFBQUFBOEQrZ0M3QUJBUVIvSUFBb0Fnd2hCQUpBSUFBb0FoQWlCVUVCYWlJQ1FTRkpCRUFnQlNFRERBRUxBMEFnQUNBQUtBSUVJZ01nQUNnQ0NDSUNJQUFvQWhocVN3Ui9JQUFnQWtFQmFpSUNOZ0lJSUFBb0FnQWdBeUFDYTJvZ0JEb0FBRUVBQlVGL0N5QUFLQUlzY2pZQ0xDQUVRUWgySVFRZ0JVRVBTaUVDSUFWQkNHc2lBeUVGSUFJTkFBc2dBMEVCYWlFQ0N5QUFJQUkyQWhBZ0FDQUJJQU4wSUFSeU5nSU1JQUFnQUNnQ0ZFRUJhallDRkF1U0F3RUNmeUFBS0FJY0lnUWdBMjRoQlNBQUFuOGdBUVJBSUFBZ0FDZ0NJQ0FGSUFFZ0EydHNJQVJxYWpZQ0lDQUZJQUlnQVd0c0RBRUxJQVVnQWlBRGEyd2dCR29MSWdNMkFod2dBMEdBZ0lBRVRRUkFJQUFvQWlBaEFRTkFBa0FnQVVFWGRpSUZRZjhCUndSQUlBRkJIM1loQWlBQUtBSW9JZ1JCQUU0RVFFRi9JUUVnQUNBQUtBSUVJQUFvQWhnaUF5QUFLQUlJYWtzRWZ5QUFJQU5CQVdvMkFoZ2dBQ2dDQUNBRGFpQUNJQVJxT2dBQVFRQUZRWDhMSUFBb0FpeHlOZ0lzQ3lBQUtBSWtJZ0VFUUNBQ1FRRnJJUVFEUUVGL0lRTWdBQ0FBS0FJRUlBQW9BaGdpQWlBQUtBSUlha3NFZnlBQUlBSkJBV28yQWhnZ0FDZ0NBQ0FDYWlBRU9nQUFRUUFoQXlBQUtBSWtCU0FCQzBFQmF5SUJOZ0lrSUFBZ0FDZ0NMQ0FEY2pZQ0xDQUJEUUFMQ3lBQUlBVkIvd0Z4TmdJb0lBQW9BaHdoQXlBQUtBSWdJUUVNQVFzZ0FDQUFLQUlrUVFGcU5nSWtDeUFBSUFOQkNIUWlBellDSENBQUlBRkJDSFJCZ1A3Ly93ZHhJZ0UyQWlBZ0FDQUFLQUlVUVFocU5nSVVJQU5CZ1lDQUJFa05BQXNMQzk4RkFRcC9Jd0FpRFNFVklBQW9BZ2doRXlBQUtBSUVJUkFnRFNBQUtBSXNJaFFnQ1hRaUQwRUNkRUVQYWtGd2NXc2lEaVFBSUFBb0FpUkJBQ0FKSUFnYmF5RVNRUUVnQ1hRaUVVRUJJQWdiSVEwZ0ZDQVBJQWdiSVFnQ1FBSkFJQVpCQVVjTkFDQUhRUUpIRFFBZ0FDQUJJQTRnQXlBRUlBVWdFU0FLSUFzUUVpQUNLQUlFSUJCQkFtMUJBblJxSUE0Z0QwRUNkQkFFSVFFZ0RVRUJTQTBCSUFCQlFHc2hBMEVBSVFrRFFDQURJQUVnQ1VFQ2RHb2dBaWdDQUNBSUlBbHNRUUowYWlBQUtBSThJQkFnRWlBTkVCY2dDVUVCYWlJSklBMUhEUUFMSUExQkFVZ05BU0FBUVVCcklRRkJBQ0VKQTBBZ0FTQU9JQWxCQW5ScUlBSW9BZ1FnQ0NBSmJFRUNkR29nQUNnQ1BDQVFJQklnRFJBWElBbEJBV29pQ1NBTlJ3MEFDd3dCQ3dKQUlBWkJBa1pCQUNBSFFRRkdHMFVFUUNBSFFRRWdCMEVCU2hzaEIwRUFJUVlnRFVFQlNBMEJJQUJCUUdzaEZBTkFJQUFnQVNBR0lBOXNRUUowYWlBT0lBTWdCaUFUYkVFQ2RHb2dCQ0FGSUJFZ0NpQUxFQklnQWlBR1FRSjBhaUVXUVFBaENRTkFJQlFnRGlBSlFRSjBhaUFXS0FJQUlBZ2dDV3hCQW5ScUlBQW9BandnRUNBU0lBMFFGeUFKUVFGcUlna2dEVWNOQUFzZ0JrRUJhaUlHSUFkSERRQUxEQUlMSUFJb0FnQWhCaUFBSUFFZ0RpQURJQVFnQlNBUklBb2dDeEFTSUFBZ0FTQVBRUUowYWlBR0lCQkJBbTFCQW5ScUlnRWdBeUFUUVFKMGFpQUVJQVVnRVNBS0lBc1FFa0VBSVFrZ0QwRUFTZ1JBQTBBZ0RpQUpRUUowSWdOcUlnUWdCQ29DQUVNQUFBQS9sQ0FCSUFOcUtnSUFRd0FBQUQrVWtqZ0NBQ0FKUVFGcUlna2dEMGNOQUFzTElBMUJBVWdOQVNBQVFVQnJJUUZCQUNFSkEwQWdBU0FPSUFsQkFuUnFJQUlvQWdBZ0NDQUpiRUVDZEdvZ0FDZ0NQQ0FRSUJJZ0RSQVhJQWxCQVdvaUNTQU5SdzBBQ3d3QkN3TkFJQUFnQVNBR0lBOXNRUUowYWlBT0lBTWdCaUFUYkVFQ2RHb2dCQ0FGSUJFZ0NpQUxFQklnQmtFQmFpSUdJQWRIRFFBTEN5QVZKQUFMbXhJQ0NuOERmU0FBS0FJUUlSQWdBQ2dDQUNFTVFRRWhDeUFGS0FJQUlnMGdBQ2dDQ0NJVEtBSTRJQUFvQWd3aUQwRUJkR291QVFBZ0NFRURkR29pQ0d0QklHc2lFU0FJUVFGMVFYQkJmQ0FFUVFKR0lBbEJBRWR4SWdnYmFpQUVRUUYwUVg1QmZ5QUlHMm9pQ0d3Z0RXb2dDRzBpQ0NBSUlCRktHeUlJUWNBQUlBaEJ3QUJJR3lJSVFRUk9CRUFnQ0VFSGNVRUJkRUh3T21vdUFRQkJEaUFJUVFOMmEzVkJBV3BCZm5FaEN3c2dBQ2dDSENFTklBdEJBU0FMSUFrYklBOGdFRWdiSVFzQ2Z3SkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUlBd0VRQ0FBS0FJa0lSQWdBaUFESUFrZ0JDQUFLQUlzRUpVQklRZ2dEUkFMSVJFZ0MwRUJSZzBFQW44Q1FDQUpCRUFnQUNnQ01DSUFEUUVnQ0NBTGJFR0FRR3RCRG5VTUFnc0NRQ0FMSUFnZ0Myd2lERUdBUUdzaURrRU9kU0lJVEFSQUlBZ2hBQXdCQ3lBTVFZREFBRWdFUUNBSUlRQU1BUXNnQUNnQ09FVUVRQ0FJSVFBTUFRc2dEa0dBZ0g5eElBc2lBRzVCRUhRaURrRU5kU0FPUVJCMWJFR0FnQUpxUVJCMUlnd2dERUdPZTJ4QmdJQUJha0VQZFVIVndBQnFiRUVCZEVHQWdJcnZBV3RCRUhVZ0RHeEJnSUFCYWtFUGRpQU1hMEVRZEVHQWdJQ0FlR3RCRUhVaUVtY2lGRUdBZ0lDQUJDQU9heUlNUVExMUlBeEJFSFZzUVlDQUFtcEJFSFVpRENBTVFZNTdiRUdBZ0FGcVFROTFRZFhBQUdwc1FRRjBRWUNBaXU4QmEwRVFkU0FNYkVHQWdBRnFRUTkySUF4clFSQjBRWUNBZ0lCNGEwRVFkU0lNWnlJT2EwRUxkQ0FTSUJSQkVXdDBRUkIwUVJCMUloSkIyMnRzUVlDQUFXcEJEM1ZCL0QxcUlCSnNRWUNBQVdwQkQzWnJJQXdnRGtFUmEzUkJFSFJCRUhVaURFSGJhMnhCZ0lBQmFrRVBkVUg4UFdvZ0RHeEJnSUFCYWtFUGRtcEJFSFJCRUhVZ0JFRVhkRUdBZ0lBRWEwRVFkV3hCZ0lBQmFrRVBkU0lNSUFVb0FnQWlEa29OQUVFQUlBZ2dERUVBSUE1clNCc2hBQXNnQjBFQlRBMEREQWtMSUFCQmYzTkJIM1pCQUNBSUlBdHNRZi8vQVVHQmdINGdDRUdBd0FCS0d5QUxiV29pQUVFT2RTQUFRUUJJR3lJQUlBdEJBV3NnQUNBTFNCdHFDeUVBSUFSQkFrd05CeUFOSUF0QkFtMGlCMEVEYkVFRGFpSUlJQWRCZjNOcUlBQnFJQUJCQTJ3aUNTQUFJQWRLSWd3YklBZ2dCMnNnQUdvZ0NVRURhaUFNR3lBSElBaHFFQ0VnQUVFT2RDSUFJQXR1SVFnTUNBc2dEUkFMSVJFZ0MwRUJSZzBFQWtBZ0JFRURTQTBBSUFsRkRRQWdEUUovSUEwZ0MwRUNiU0lBUVFGcUlnZEJBMndpQWlBQWFpSUlFRklpQXlBQ1NBUkFJQU5CQTIwTUFRc2dBeUFIUVFGMGF3c2lDU0FDSUFCQmYzTnFhaUFKUVFOc0lnTWdBQ0FKU0NJSEd5QUNJQUJySUFscUlBTkJBMm9nQnhzZ0NCQXhEQU1MUVFBZ0IwRUJUQ0FKR3cwQklBMGdDMEVCYWhBV0lRa01BZ3NnQ3lBQWF5SURRUUZxSWdjZ0FFRUJhaUlJSUFBZ0MwRUJkU0lDU2lJSkd5RVBJQUpCQVdvaUFpQUNiQ0VDSUEwZ0NRUi9JQUlnQnlBRFFRSnFiRUVCZFdzRklBQWdDR3hCQVhVTElna2dDU0FQYWlBQ0VDRWdBRUVPZENBTGJpRUlEQWdMSUEwQ2Z5QU5JQXRCQVhVaUIwRUJhaUlBSUFCc0lnTVFVaUlDSUFBZ0IyeEJBWFZJQkVBZ0FrRURkRUVCY2hBNFFRRnJRUUYySWdsQkFXb2lBQ0FKYkVFQmRnd0JDeUFESUF0QkFXb2lBQ0FBUVFGMElBTWdBa0YvYzJwQkEzUkJBWElRT0d0QkFYWWlDV3NpQUNBTElBbHJRUUpxYkVFQmRXc0xJZ0lnQUNBQ2FpQURFREVMSUFsQkRuUWdDMjRoQ0F3R0N5QUpSUTBGUVFBaENVRUFJUWNDUUNBSVFZSEFBRWdOQUNBQUtBSTBEUUJCQVNFSElBUkJBVWdOQUVFQUlRc0RRQ0FESUF0QkFuUnFJZ2NnQnlvQ0FJdzRBZ0JCQVNFSElBdEJBV29pQ3lBRVJ3MEFDd3NnQkVFQlNBMEJJQkFnRXlnQ0NDQVBha0VDZEdvcUFnQWlGU0FRSUE5QkFuUnFLZ0lBSWhZZ0ZwUkRmUjJRSnBJZ0ZTQVZsSktSUTMwZGtDYVNJaFdWSVJjZ0ZpQVZsU0VWQTBBZ0FpQUpRUUowSWdocUlnc2dGU0FMS2dJQWxDQVhJQU1nQ0dvcUFnQ1VramdDQUNBSlFRRnFJZ2tnQkVjTkFBc01BUXRCQUNFSElBbEZEUU1MUVFBQ2YwRUFJQVVvQWdCQkVVZ05BQnBCQUNBQUtBSWdRUkZJRFFBYUlBd0VRQ0FOSUFjUW1nRWdCd3dCQ3lBTlFRSVFCZ3NnQUNnQ05Cc2hCd3dDQ3lBTklBQWdDMEVCYWhCUklBQkJEblFpQUNBTGJpRUlJQWxGRFFJTElBQWdDMGtFUUVFQUlRY2dCRUVCU0EwQklCQWdFeWdDQ0NBUGFrRUNkR29xQWdBaUZTQVFJQTlCQW5ScUtnSUFJaFlnRnBSRGZSMlFKcElnRlNBVmxKS1JRMzBka0NhU0loV1ZJUmNnRmlBVmxTRVZRUUFoQ1FOQUlBSWdDVUVDZENJQWFpSUlJQlVnQ0NvQ0FKUWdGeUFBSUFOcUtnSUFsSkk0QWdBZ0NVRUJhaUlKSUFSSERRQUxEQUVMSUFSQkFVZ05BVUVBSVFrRFFDQUNJQWxCQW5RaUFHb2lCeUFIS2dJQVEvTUVOVCtVSWhVZ0FDQURhaUlBS2dJQVEvTUVOVCtVSWhhU09BSUFJQUFnRmlBVmt6Z0NBQ0FKUVFGcUlna2dCRWNOQUFzTUFRc2dEUkFMSVFBZ0JTQUZLQUlBSUFBZ0VXc2lBR3MyQWdBTUFRc2dEUkFMSVFBZ0JTQUZLQUlBSUFBZ0VXc2lBR3MyQWdCQmdJQUJJUWtnQ0VHQWdBRkdEUUVnQ0EwQ0lBZ2hCd3NnQ2lBS0tBSUFRWDhnQm5SQmYzTnhOZ0lBUWYvL0FTRURRUUFoQ1VFQUlRSkJnSUIvREFJTElBb2dDaWdDQUVGL0lBWjBRWDl6SUFaMGNUWUNBRUgvL3dFaEFrRUFJUWRCQUNFRFFZQ0FBUXdCQzBFQUlRY2dDQ0VKSUFoQkVIUWlCVUVOZFNBRlFSQjFiRUdBZ0FKcVFSQjFJZ0lnQWtHT2UyeEJnSUFCYWtFUGRVSFZ3QUJxYkVFQmRFR0FnSXJ2QVd0QkVIVWdBbXhCZ0lBQmFrRVBkaUFDYTBFUWRFR0FnSUNBZUd0QkVIVWlBMmNpQmtHQWdJQ0FCQ0FGYXlJQ1FRMTFJQUpCRUhWc1FZQ0FBbXBCRUhVaUFpQUNRWTU3YkVHQWdBRnFRUTkxUWRYQUFHcHNRUUYwUVlDQWl1OEJhMEVRZFNBQ2JFR0FnQUZxUVE5MklBSnJRUkIwUVlDQWdJQjRhMEVRZFNJQ1p5SUZhMEVMZENBRElBWkJFV3QwUVJCMFFSQjFJZ1pCMjJ0c1FZQ0FBV3BCRDNWQi9EMXFJQVpzUVlDQUFXcEJEM1pySUFJZ0JVRVJhM1JCRUhSQkVIVWlCVUhiYTJ4QmdJQUJha0VQZFVIOFBXb2dCV3hCZ0lBQmFrRVBkbXBCRUhSQkVIVWdCRUVYZEVHQWdJQUVhMEVRZFd4QmdJQUJha0VQZFFzaEJDQUJJQUEyQWhRZ0FTQUpOZ0lRSUFFZ0JEWUNEQ0FCSUFJMkFnZ2dBU0FETmdJRUlBRWdCellDQUF1WkN3SUlmd1Y5SXdCQklHc2lEQ1FBSUF3Z0NqWUNHQ0FNSUFRMkFod2dBQ2dDSENFRUlBQW9BZ0FoRHdKQUlBTkJBVVlFUUVFQ1FRRWdBaHNpQTBFQklBTkJBVXNiSVFZZ0FDZ0NJQ0VEQWtBZ0R3UkFRUUFoQlNBRFFRaE9CRUFnQkNBQktnSUFRd0FBQUFCZElnVVFJQ0FBSUFBb0FpQkJDR3NpQXpZQ0lBc2dBQ2dDQkFSQUlBRkRBQUNBdjBNQUFJQS9JQVViT0FJQUN5QUNSUTBCUVFFaENnTkFRUUFoQlNBRFFRaE9CRUFnQkNBQ0tnSUFRd0FBQUFCZElnVVFJQ0FBSUFBb0FpQkJDR3NpQXpZQ0lBc2dBQ2dDQkFSQUlBSkRBQUNBdjBNQUFJQS9JQVViT0FJQUN5QUtRUUZxSWdvZ0JrY05BQXNNQVF0QkFDRUZJQU5CQ0U0RVFDQUVRUUVRQ1NFRklBQWdBQ2dDSUVFSWF5SUROZ0lnQ3lBQUtBSUVCRUFnQVVNQUFJQy9Rd0FBZ0Q4Z0JSczRBZ0FMSUFKRkRRQkJBU0VLQTBCQkFDRUZJQU5CQ0U0RVFDQUVRUUVRQ1NFRklBQWdBQ2dDSUVFSWF5SUROZ0lnQ3lBQUtBSUVCRUFnQWtNQUFJQy9Rd0FBZ0Q4Z0JSczRBZ0FMSUFwQkFXb2lDaUFHUncwQUN3dEJBU0VISUFoRkRRRWdDQ0FCS2dJQU9BSUFEQUVMSUFBZ0RDQUJJQUlnQXlBTVFSeHFJQVVnQlNBSFFRRWdERUVZYWhBaklBd29BZ2l5UXdBQUFEaVVJUk1nRENnQ0JMSkRBQUFBT0pRaEZTQU1LQUlVSVFzZ0RDZ0NFQ0VOSUF3b0FnQWhFUUpBSUFOQkFrWUVRQ0FNS0FJY0lRNGdBQ0FBS0FJZ0lBMUIvLzkrY1NJU1FRQkhRUU4wSWhBZ0MycHJOZ0lnSUFFZ0FpQU5RWURBQUVvaURSc2hDeUFDSUFFZ0RSc2hEU0FPSUJCcklSQkJBQ0VPQWtBZ0VrVU5BQ0FQQkVBZ0JDQU5LZ0lBSUFzcUFnU1VJQTBxQWdRZ0N5b0NBSlNUUXdBQUFBQmRJZzRRSUF3QkN5QUVRUUVRQ1NFT0N5QUFJQTFCQWlBUUlBVWdCaUFISUFoREFBQ0FQeUFKSUFvUUNpRUhJQXNnRFNvQ0JFRUFRUUVnRGtFQmRHc2lCR3V5bERnQ0FDQUxJQTBxQWdBZ0JMS1VPQUlFSUFBb0FnUkZEUUVnQVNBVklBRXFBZ0NVT0FJQUlBRWdGU0FCS2dJRWxEZ0NCQ0FDSUJNZ0Fpb0NBSlFpRkRnQ0FDQUNJQk1nQWlvQ0JKUTRBZ1FnQVNBQktnSUFJaE1nRkpNNEFnQWdBaUFUSUFJcUFnQ1NPQUlBSUFFZ0FTb0NCQ0lUSUFJcUFnU1RPQUlFSUFJZ0V5QUNLZ0lFa2pnQ0JBd0JDeUFNS0FJY0lRUWdEQ2dDRENFUElBQWdBQ2dDSUNBTGF5SU9OZ0lnSUF3b0FoZ2hDaUFFSUFRZ0QydEJBbTBpQ3lBRUlBdElHeUlMUVFBZ0MwRUFTaHNpQ3lBRUlBdHJJZ1JPQkVBZ0FDQUJJQU1nQ3lBRklBWWdCeUFJUXdBQWdEOGdDU0FLRUFvZ0FDQUNJQU1nQkNBQUtBSWdJQTVySUF0cUlnUkJHR3RCQUNBRVFSaEtHMEVBSUEwYmFpQUZRUUFnQjBFQUlCTkJBQ0FLSUFWMUVBcHlJUWNNQVFzZ0FDQUNJQU1nQkNBRlFRQWdCMEVBSUJOQkFDQUtJQVYxRUFvZ0FDQUJJQU1nQUNnQ0lDQU9heUFFYWlJRVFSaHJRUUFnQkVFWVNodEJBQ0FOUVlDQUFVY2JJQXRxSUFVZ0JpQUhJQWhEQUFDQVB5QUpJQW9RQ25JaEJ3c2dBQ2dDQkVVTkFBSkFJQU5CQWtZTkFFTUFBQUFBSVJRQ1FDQURRUUZJQkVCREFBQUFBQ0VUREFFTFFRQWhBRU1BQUFBQUlSTURRQ0FUSUFJZ0FFRUNkQ0lFYWlvQ0FDSVdJQUVnQkdvcUFnQ1VraUVUSUJRZ0ZpQVdsSkloRkNBQVFRRnFJZ0FnQTBjTkFBc0xBa0FnRlNBVmxDQVVraUlVSUJVZ0U1UWlFeUFUa2lJVGtpSVdRMUpKSFRwZFJRUkFJQlFnRTVNaUUwTlNTUjA2WFVFQmN3MEJDeUFDSUFFZ0EwRUNkQkFFR2d3QkN5QURRUUZJRFFGREFBQ0FQeUFXa1pVaEZFTUFBSUEvSUJPUmxTRVRRUUFoQUFOQUlBRWdBRUVDZENJRWFpSUZJQk1nRlNBRktnSUFsQ0lXSUFJZ0JHb2lCQ29DQUNJWGs1UTRBZ0FnQkNBVUlCWWdGNUtVT0FJQUlBQkJBV29pQUNBRFJ3MEFDd3NnRVVVTkFDQURRUUZJRFFCQkFDRUFBMEFnQWlBQVFRSjBhaUlCSUFFcUFnQ01PQUlBSUFCQkFXb2lBQ0FEUncwQUN3c2dERUVnYWlRQUlBY0xFQUFnQVNBQVFja3dRUWdRQXpZQ0FBdGZBQ0FBUVFScVFRQkJwQ0VRQlJvZ0FFRUFOZ0xJSUNBQVFZQ0FCRFlDQUNBQVFRRTJBc2dTSUFBUWVpQUFRWlFoYWtLQWdJU0FnSURBQURjQ0FDQUFRYUFoYWtLQ2dJQ0F3QUkzQWdBZ0FDQUFLQUtZRWtFSGREWUN6Q0JCQUF1cENRRUlmeU1BUWFBQmF5SUpKQUFnQUNBQ1FRRjFRUWxzUWVBemFrRUlFQU1oQlFKQUlBUkJCSFVnQkVGd2NTQUVTR29pQzBFQVRBMEFJQVZCRW14Qm9ESnFJUWNEUUVFQUlRVWdDU0FHUVFKMElnaHFJZ3BCQURZQ0FDQUpRZEFBYWlBSWFpSUlJQUFnQjBFSUVBTWlERFlDQUNBTVFSRkdCRUFEUUNBSUlBQWdCVUVCYWlJRlFRcEdRY0l6YWtFSUVBTWlERFlDQUNBTVFSRkdEUUFMSUFvZ0JUWUNBQXNnQmtFQmFpSUdJQXRIRFFBTFFRQWhCU0FMUVFCTURRQURRQ0FCSUFWQkVIUkJDM1ZxSVFZQ1FDQUpRZEFBYWlBRlFRSjBhaWdDQUNJSFFRRk9CRUFnQmlBQUlBY1FaZ3dCQ3lBR1FnQTNBUUFnQmtJQU53RVlJQVpDQURjQkVDQUdRZ0EzQVFnTElBVkJBV29pQlNBTFJ3MEFDMEVBSVFvZ0MwRUFUQTBBQTBBZ0NTQUtRUUowSWd4cUtBSUFJZ2hCQVU0RVFDQUJJQXBCRUhSQkMzVnFJZ2N2QVFBaEJVRUFJUVlEUUNBQVFlQXdRUWdRQXlBRlFRRjBhaUVGSUFaQkFXb2lCaUFJUncwQUN5QUhJQVU3QVFBZ0J5OEJBaUVGUVFBaEJnTkFJQUJCNERCQkNCQURJQVZCQVhScUlRVWdCa0VCYWlJR0lBaEhEUUFMSUFjZ0JUc0JBaUFITHdFRUlRVkJBQ0VHQTBBZ0FFSGdNRUVJRUFNZ0JVRUJkR29oQlNBR1FRRnFJZ1lnQ0VjTkFBc2dCeUFGT3dFRUlBY3ZBUVloQlVFQUlRWURRQ0FBUWVBd1FRZ1FBeUFGUVFGMGFpRUZJQVpCQVdvaUJpQUlSdzBBQ3lBSElBVTdBUVlnQnk4QkNDRUZRUUFoQmdOQUlBQkI0REJCQ0JBRElBVkJBWFJxSVFVZ0JrRUJhaUlHSUFoSERRQUxJQWNnQlRzQkNDQUhMd0VLSVFWQkFDRUdBMEFnQUVIZ01FRUlFQU1nQlVFQmRHb2hCU0FHUVFGcUlnWWdDRWNOQUFzZ0J5QUZPd0VLSUFjdkFRd2hCVUVBSVFZRFFDQUFRZUF3UVFnUUF5QUZRUUYwYWlFRklBWkJBV29pQmlBSVJ3MEFDeUFISUFVN0FRd2dCeThCRGlFRlFRQWhCZ05BSUFCQjREQkJDQkFESUFWQkFYUnFJUVVnQmtFQmFpSUdJQWhIRFFBTElBY2dCVHNCRGlBSEx3RVFJUVZCQUNFR0EwQWdBRUhnTUVFSUVBTWdCVUVCZEdvaEJTQUdRUUZxSWdZZ0NFY05BQXNnQnlBRk93RVFJQWN2QVJJaEJVRUFJUVlEUUNBQVFlQXdRUWdRQXlBRlFRRjBhaUVGSUFaQkFXb2lCaUFJUncwQUN5QUhJQVU3QVJJZ0J5OEJGQ0VGUVFBaEJnTkFJQUJCNERCQkNCQURJQVZCQVhScUlRVWdCa0VCYWlJR0lBaEhEUUFMSUFjZ0JUc0JGQ0FITHdFV0lRVkJBQ0VHQTBBZ0FFSGdNRUVJRUFNZ0JVRUJkR29oQlNBR1FRRnFJZ1lnQ0VjTkFBc2dCeUFGT3dFV0lBY3ZBUmdoQlVFQUlRWURRQ0FBUWVBd1FRZ1FBeUFGUVFGMGFpRUZJQVpCQVdvaUJpQUlSdzBBQ3lBSElBVTdBUmdnQnk4QkdpRUZRUUFoQmdOQUlBQkI0REJCQ0JBRElBVkJBWFJxSVFVZ0JrRUJhaUlHSUFoSERRQUxJQWNnQlRzQkdpQUhMd0VjSVFWQkFDRUdBMEFnQUVIZ01FRUlFQU1nQlVFQmRHb2hCU0FHUVFGcUlnWWdDRWNOQUFzZ0J5QUZPd0VjSUFjdkFSNGhCVUVBSVFZRFFDQUFRZUF3UVFnUUF5QUZRUUYwYWlFRklBWkJBV29pQmlBSVJ3MEFDeUFISUFVN0FSNGdDVUhRQUdvZ0RHb2lCU0FGS0FJQUlBaEJCWFJ5TmdJQUN5QUtRUUZxSWdvZ0MwY05BQXNMSUFBZ0FTQUVJQUlnQXlBSlFkQUFhaEJ3SUFsQm9BRnFKQUFMeFFZQkFYOGpBRUV3YXlJRkpBQWdBRUhPRldvQ2Z3SkFJQU5GQkVBZ0FDQUNRUUowYWtIa0Vtb29BZ0JGRFFFTElBRkI1VEJCQ0JBRFFRSnFEQUVMSUFGQjZUQkJDQkFEQ3lJRFFRRnhPZ0FBSUFCQnpSVnFJQU5CQVhZaUFqb0FBQUpBSUFSQkFrWUVRQ0FBSUFGQjRDOUJDQkFET2dDd0ZRd0JDeUFBSUFFZ0FrRVlkRUVWZFVIQUwycEJDQkFEUVFOME9nQ3dGU0FBSUFGQmtERkJDQkFESUFBdEFMQVZham9Bc0JVTElBQW9BcFFTUVFKT0JFQkJBU0VEQTBBZ0FDQURha0d3RldvZ0FVSGdMMEVJRUFNNkFBQWdBMEVCYWlJRElBQW9BcFFTU0EwQUN3c2dBRUc0RldvZ0FTQUFLQUtzRlNJQ0tBSVFJQUl1QVFBZ0FDd0F6UlZCQVhWc2FrRUlFQU1pQWpvQUFDQUZRUkJxSUFVZ0FDZ0NyQlVnQWtFWWRFRVlkUkJHSUFBb0Fxd1ZJZ0l1QVFKQkFVNEVRRUVBSVFNRFFBSkFBa0FDUUNBQklBSW9BaHdnQlVFUWFpQURRUUYwYWk0QkFHcEJDQkFESWdJT0NRQUNBZ0lDQWdJQ0FRSUxRUUFnQVVHWU1VRUlFQU5ySVFJTUFRc2dBVUdZTVVFSUVBTkJDR29oQWdzZ0FDQURRUUZxSWdOcVFiZ1ZhaUFDUVFSck9nQUFJQU1nQUNnQ3JCVWlBaTRCQWtnTkFBc0xRUVFoQXlBQVFjOFZhaUFBS0FLVUVrRUVSZ1IvSUFGQjZ6QkJDQkFEQlVFRUN6b0FBQ0FBTFFETkZVRUNSZ1JBQWtBQ1FDQUVRUUpIRFFBZ0FDZ0MzQkpCQWtjTkFDQUJRY0F4UVFnUUF5SUNRUkIwUVFGSURRQWdBRUhLRldvZ0FpQUFMd0hnRW1wQkNXc2lBanNCQUF3QkN5QUFRY29WYWlJQ0lBRkJvREZCQ0JBRElBQW9Bb3dTUVFGMmJEc0JBQ0FDSUFFZ0FDZ0N6QkpCQ0JBRElBSXZBUUJxSWdJN0FRQUxJQUFnQWpzQjRCSWdBRUhNRldvZ0FTQUFLQUxRRWtFSUVBTTZBQUFnQUVIUUZXb2dBVUhTRUVFSUVBTWlBam9BQUVFQklRTUNRQ0FBS0FLVUVrRUJTQTBBSUFCQnRCVnFJQUVnQWtFWWRFRVdkVUdRRVdvb0FnQkJDQkFET2dBQUlBQW9BcFFTUVFKSURRQURRQ0FBSUFOcVFiUVZhaUFCSUFBc0FOQVZRUUowUVpBUmFpZ0NBRUVJRUFNNkFBQWdBMEVCYWlJRElBQW9BcFFTU0EwQUN3dEJBQ0VESUFCQjBSVnFJQVFFZjBFQUJTQUJRZUl3UVFnUUF3czZBQUFMSUFBZ0FDd0F6UlUyQXR3U0lBQkIwaFZxSUFGQmdURkJDQkFET2dBQUlBVkJNR29rQUF2QUFRRUVmeUFCUVFGcklRUWdBVUVDVGdSQUlBSkJnSUFFYXlFRlFRQWhBUU5BSUFBZ0FVRUNkR29pQXlBREtBSUFJZ05CRUhSQkVIVWlCaUFDUWYvL0EzRnNRUkIxSUFZZ0FrRVFkV3hxSUFOQkQzVkJBV3BCQVhVZ0FteHFOZ0lBSUFJZ0JXeEJEM1ZCQVdwQkFYVWdBbW9oQWlBQlFRRnFJZ0VnQkVjTkFBc0xJQUFnQkVFQ2RHb2lBQ0FBS0FJQUlnQkJFSFJCRUhVaUFTQUNRZi8vQTNGc1FSQjFJQUVnQWtFUWRXeHFJQUJCRDNWQkFXcEJBWFVnQW14cU5nSUFDMzRCQTM4Z0FVRUJheUVESUFGQkFrNEVRQ0FDUVlDQUJHc2hCRUVBSVFFRFFDQUFJQUZCQVhScUlnVWdBaUFGTGdFQWJFRVBka0VCYWtFQmRqc0JBQ0FDSUFSc1FROTFRUUZxUVFGMUlBSnFJUUlnQVVFQmFpSUJJQU5IRFFBTEN5QUFJQU5CQVhScUlnQWdBaUFBTGdFQWJFRVBka0VCYWtFQmRqc0JBQXZKQ0FJS2Z3RitJd0JCd0FKcklnUWtBRUVCSVFNZ0FrRUJUZ1JBUVpBSlFhQUpJQUpCRUVZYklRa0RRQ0FFUWVBQmFpQUZJQWxxTFFBQVFRSjBhaUFCSUFWQkFYUnFMZ0VBSWdaQkNIVkJBWFJCMEE1cUlnY3VBUUlnQnk0QkFDSUhheUFHUWY4QmNXd2dCMEVJZEdwQkEzVkJBV3BCQVhVMkFnQWdCVUVCYWlJRklBSkhEUUFMSUFRb0F1QUJJUVVMUVlDQUJDRUdJQVJCZ0lBRU5nS2dBU0FFUVFBZ0JXc2lCVFlDcEFFZ0FrRUJkU0VIQWtBZ0FrRUVTQ0lMRFFBZ0JTRUJBMEFnQkVHZ0FXb2dBMEVCYWlJSlFRSjBhaUlNSUFaQkFYUWdCRUhnQVdvZ0EwRURkR29vQWdBaURhd2lEaUFCckg1Q0Q0aENBWHhDQVlpbmF6WUNBQ0FEUVFKMElnZ2dCRUdnQVdwcUlRb2dCQ0FEUVFKUEJIOGdDaUFFSUFocUtBS1lBU0lGSUFGcUlBYXNJQTUrUWcrSVFnRjhRZ0dJcDJzMkFnQWdBMEVDUndSQUEwQWdCRUdnQVdvZ0EwRUJheUlCUVFKMGFpSUlJQU5CQW5RZ0JHb29BcFFCSWdZZ0NDZ0NBR29nQmF3Z0RuNUNENGhDQVh4Q0FZaW5hellDQUNBRFFRTktJUWdnQVNFRElBWWhCU0FJRFFBTEN5QUVLQUtrQVFVZ0JRc2dEV3NpQlRZQ3BBRWdCeUFKUmcwQklBd29BZ0FoQVNBS0tBSUFJUVlnQ1NFRERBQUxBQXRCZ0lBRUlRWWdCRUdBZ0FRMkFtQWdCRUVBSUFRb0F1UUJheUlGTmdKa0FrQWdDdzBBSUFSQjRBRnFRUVJ5SVF0QkFTRURJQVVoQVFOQUlBUkI0QUJxSUFOQkFXb2lDVUVDZEdvaURDQUdRUUYwSUFzZ0EwRURkR29vQWdBaURhd2lEaUFCckg1Q0Q0aENBWHhDQVlpbmF6WUNBQ0FEUVFKMElnZ2dCRUhnQUdwcUlRb2dCQ0FEUVFKUEJIOGdDaUFFSUFocUtBSllJZ1VnQVdvZ0Jxd2dEbjVDRDRoQ0FYeENBWWluYXpZQ0FDQURRUUpIQkVBRFFDQUVRZUFBYWlBRFFRRnJJZ0ZCQW5ScUlnZ2dBMEVDZENBRWFpZ0NWQ0lHSUFnb0FnQnFJQVdzSUE1K1FnK0lRZ0Y4UWdHSXAyczJBZ0FnQTBFRFNpRUlJQUVoQXlBR0lRVWdDQTBBQ3dzZ0JDZ0NaQVVnQlFzZ0RXc2lCVFlDWkNBSElBbEdEUUVnRENnQ0FDRUJJQW9vQWdBaEJpQUpJUU1NQUFzQUN5QUNRUUpPQkVBZ0IwRUJJQWRCQVVvYklRb2dCQ2dDWUNFR0lBUW9BcUFCSVFGQkFDRURBMEFnQkNBRFFRSjBha0VBSUFOQkFXb2lCVUVDZENJSElBUkI0QUJxYWlnQ0FDSUpJQVpySWdZZ0FTQUVRYUFCYWlBSGFpZ0NBQ0lIYWlJQmFtczJBZ0FnQkNBRFFYOXpJQUpxUVFKMGFpQUdJQUZyTmdJQUlBa2hCaUFISVFFZ0JTSURJQXBIRFFBTEN5QUFJQVFnQWhCM0FrQWdBQ0FDRUIwTkFFRUFJUVVnQWtFQlRnUkFBMEFnQkNBQ1FYNGdCWFJCZ0lBRWFoQXBRUUFoQXdOQUlBQWdBMEVCZEdvZ0JDQURRUUowYWlnQ0FFRUVka0VCYWtFQmRqc0JBQ0FEUVFGcUlnTWdBa2NOQUFzZ0FDQUNFQjBoQVNBRlFRNUxEUUlnQlVFQmFpRUZJQUZGRFFBTUFnc0FDd05BSUFRZ0FrRitJQVYwUVlDQUJHb1FLU0FBSUFJUUhTRUJJQVZCRGtzTkFTQUZRUUZxSVFVZ0FVVU5BQXNMSUFSQndBSnFKQUFMbnhFQ0QzOEJmaU1BUWRBQWF5SUZKQUFnQlNBQk5nSk1JQVZCTjJvaEV5QUZRVGhxSVJGQkFDRUJBa0FEUUFKQUlBNUJBRWdOQUVILy8vLy9CeUFPYXlBQlNBUkFRWno3QVVFOU5nSUFRWDhoRGd3QkN5QUJJQTVxSVE0TElBVW9Ba3dpQ2lFQkFrQUNRQUpBSUFvdEFBQWlCZ1JBQTBBQ1FBSkFJQVpCL3dGeElnWkZCRUFnQVNFR0RBRUxJQVpCSlVjTkFTQUJJUVlEUUNBQkxRQUJRU1ZIRFFFZ0JTQUJRUUpxSWdnMkFrd2dCa0VCYWlFR0lBRXRBQUloQ1NBSUlRRWdDVUVsUmcwQUN3c2dCaUFLYXlFQklBQUVRQ0FBSUFvZ0FSQVFDeUFCRFFZZ0JTZ0NUQ0VCSUFVQ2Z3SkFJQVVvQWt3c0FBRkJNR3RCQ2s4TkFDQUJMUUFDUVNSSERRQWdBU3dBQVVFd2F5RVFRUUVoRWlBQlFRTnFEQUVMUVg4aEVDQUJRUUZxQ3lJQk5nSk1RUUFoRHdKQUlBRXNBQUFpQzBFZ2F5SUlRUjlMQkVBZ0FTRUdEQUVMSUFFaEJrRUJJQWgwSWdsQmlkRUVjVVVOQUFOQUlBVWdBVUVCYWlJR05nSk1JQWtnRDNJaER5QUJMQUFCSWd0QklHc2lDRUVnVHcwQklBWWhBVUVCSUFoMElnbEJpZEVFY1EwQUN3c0NRQ0FMUVNwR0JFQWdCUUovQWtBZ0Jpd0FBVUV3YTBFS1R3MEFJQVVvQWt3aUFTMEFBa0VrUncwQUlBRXNBQUZCQW5RZ0JHcEJ3QUZyUVFvMkFnQWdBU3dBQVVFRGRDQURha0dBQTJzb0FnQWhERUVCSVJJZ0FVRURhZ3dCQ3lBU0RRWkJBQ0VTUVFBaERDQUFCRUFnQWlBQ0tBSUFJZ0ZCQkdvMkFnQWdBU2dDQUNFTUN5QUZLQUpNUVFGcUN5SUJOZ0pNSUF4QmYwb05BVUVBSUF4cklRd2dEMEdBd0FCeUlROE1BUXNnQlVITUFHb1FUQ0lNUVFCSURRUWdCU2dDVENFQkMwRi9JUWNDUUNBQkxRQUFRUzVIRFFBZ0FTMEFBVUVxUmdSQUFrQWdBU3dBQWtFd2EwRUtUdzBBSUFVb0Frd2lBUzBBQTBFa1J3MEFJQUVzQUFKQkFuUWdCR3BCd0FGclFRbzJBZ0FnQVN3QUFrRURkQ0FEYWtHQUEyc29BZ0FoQnlBRklBRkJCR29pQVRZQ1RBd0NDeUFTRFFVZ0FBUi9JQUlnQWlnQ0FDSUJRUVJxTmdJQUlBRW9BZ0FGUVFBTElRY2dCU0FGS0FKTVFRSnFJZ0UyQWt3TUFRc2dCU0FCUVFGcU5nSk1JQVZCekFCcUVFd2hCeUFGS0FKTUlRRUxRUUFoQmdOQUlBWWhDVUYvSVEwZ0FTd0FBRUhCQUd0Qk9Vc05DQ0FGSUFGQkFXb2lDellDVENBQkxBQUFJUVlnQ3lFQklBWWdDVUU2YkdwQjcvTUJhaTBBQUNJR1FRRnJRUWhKRFFBTEFrQUNRQ0FHUVJOSEJFQWdCa1VOQ2lBUVFRQk9CRUFnQkNBUVFRSjBhaUFHTmdJQUlBVWdBeUFRUVFOMGFpa0RBRGNEUUF3Q0N5QUFSUTBJSUFWQlFHc2dCaUFDRUVzZ0JTZ0NUQ0VMREFJTElCQkJmMG9OQ1F0QkFDRUJJQUJGRFFjTElBOUIvLzk3Y1NJSUlBOGdEMEdBd0FCeEd5RUdRUUFoRFVHVTlBRWhFQ0FSSVE4Q1FBSkFBa0FDZndKQUFrQUNRQUpBQW44Q1FBSkFBa0FDUUFKQUFrQUNRQ0FMUVFGckxBQUFJZ0ZCWDNFZ0FTQUJRUTl4UVFOR0d5QUJJQWtiSWdGQjJBQnJEaUVFRkJRVUZCUVVGQlFPRkE4R0RnNE9GQVlVRkJRVUFnVURGQlFKRkFFVUZBUUFDd0pBSUFGQndRQnJEZ2NPRkFzVURnNE9BQXNnQVVIVEFFWU5DUXdUQ3lBRktRTkFJUlJCbFBRQkRBVUxRUUFoQVFKQUFrQUNRQUpBQWtBQ1FBSkFJQWxCL3dGeERnZ0FBUUlEQkJvRkJob0xJQVVvQWtBZ0RqWUNBQXdaQ3lBRktBSkFJQTQyQWdBTUdBc2dCU2dDUUNBT3JEY0RBQXdYQ3lBRktBSkFJQTQ3QVFBTUZnc2dCU2dDUUNBT09nQUFEQlVMSUFVb0FrQWdEallDQUF3VUN5QUZLQUpBSUE2c053TUFEQk1MSUFkQkNDQUhRUWhMR3lFSElBWkJDSEloQmtINEFDRUJDeUFGS1FOQUlCRWdBVUVnY1JDSkFTRUtJQVpCQ0hGRkRRTWdCU2tEUUZBTkF5QUJRUVIyUVpUMEFXb2hFRUVDSVEwTUF3c2dCU2tEUUNBUkVJZ0JJUW9nQmtFSWNVVU5BaUFISUJFZ0Ntc2lBVUVCYWlBQklBZElHeUVIREFJTElBVXBBMEFpRkVKL1Z3UkFJQVZDQUNBVWZTSVVOd05BUVFFaERVR1U5QUVNQVFzZ0JrR0FFSEVFUUVFQklRMUJsZlFCREFFTFFaYjBBVUdVOUFFZ0JrRUJjU0lOR3dzaEVDQVVJQkVRaHdFaENnc2dCa0gvLzN0eElBWWdCMEYvU2hzaEJpQUZLUU5BSVJRQ1FDQUhEUUFnRkZCRkRRQkJBQ0VISUJFaENnd01DeUFISUJSUUlCRWdDbXRxSWdFZ0FTQUhTQnNoQnd3TEN5QUZLQUpBSWdGQm52UUJJQUViSWdvZ0J4Q1BBU0lCSUFjZ0Ntb2dBUnNoRHlBSUlRWWdBU0FLYXlBSElBRWJJUWNNQ2dzZ0J3UkFJQVVvQWtBTUFndEJBQ0VCSUFCQklDQU1RUUFnQmhBTkRBSUxJQVZCQURZQ0RDQUZJQVVwQTBBK0FnZ2dCU0FGUVFocU5nSkFRWDhoQnlBRlFRaHFDeUVKUVFBaEFRSkFBMEFnQ1NnQ0FDSUlSUTBCQWtBZ0JVRUVhaUFJRUUwaUNrRUFTQ0lJRFFBZ0NpQUhJQUZyU3cwQUlBbEJCR29oQ1NBSElBRWdDbW9pQVVzTkFRd0NDd3RCZnlFTklBZ05Dd3NnQUVFZ0lBd2dBU0FHRUEwZ0FVVUVRRUVBSVFFTUFRdEJBQ0VKSUFVb0FrQWhDd05BSUFzb0FnQWlDRVVOQVNBRlFRUnFJQWdRVFNJSUlBbHFJZ2tnQVVvTkFTQUFJQVZCQkdvZ0NCQVFJQXRCQkdvaEN5QUJJQWxMRFFBTEN5QUFRU0FnRENBQklBWkJnTUFBY3hBTklBd2dBU0FCSUF4SUd5RUJEQWdMSUFBZ0JTc0RRQ0FNSUFjZ0JpQUJRUUFSSXdBaEFRd0hDeUFGSUFVcEEwQThBRGRCQVNFSElCTWhDaUFJSVFZTUJBc2dCU0FCUVFGcUlnZzJBa3dnQVMwQUFTRUdJQWdoQVF3QUN3QUxJQTRoRFNBQURRUWdFa1VOQWtFQklRRURRQ0FFSUFGQkFuUnFLQUlBSWdBRVFDQURJQUZCQTNScUlBQWdBaEJMUVFFaERTQUJRUUZxSWdGQkNrY05BUXdHQ3d0QkFTRU5JQUZCQ2s4TkJBTkFJQVFnQVVFQ2RHb29BZ0FOQVNBQlFRRnFJZ0ZCQ2tjTkFBc01CQXRCZnlFTkRBTUxJQUJCSUNBTklBOGdDbXNpQ1NBSElBY2dDVWdiSWdocUlnc2dEQ0FMSUF4S0d5SUJJQXNnQmhBTklBQWdFQ0FORUJBZ0FFRXdJQUVnQ3lBR1FZQ0FCSE1RRFNBQVFUQWdDQ0FKUVFBUURTQUFJQW9nQ1JBUUlBQkJJQ0FCSUFzZ0JrR0F3QUJ6RUEwTUFRc0xRUUFoRFFzZ0JVSFFBR29rQUNBTkM1SUJBUU44UkFBQUFBQUFBUEEvSUFBZ0FLSWlBa1FBQUFBQUFBRGdQNklpQTZFaUJFUUFBQUFBQUFEd1B5QUVvU0FEb1NBQ0lBSWdBaUFDUkpBVnl4bWdBZm8rb2tSM1VjRVdiTUZXdjZDaVJFeFZWVlZWVmFVL29LSWdBaUFDb2lJRElBT2lJQUlnQWtUVU9JaSs2ZnFvdmFKRXhMRzB2Wjd1SVQ2Z29rU3RVcHlBVDM2U3ZxQ2lvS0lnQUNBQm9xR2dvQXQ0QVFGOUFrQWdBVUVCU0EwQVFRQWhBd05BSUFRZ0FDQURRUUowYWlvQ0FDSUVJQVNVa2lFRUlBTkJBV29pQXlBQlJ3MEFDeUFCUVFGSURRQkRBQUNBUHlBRVEzMGRrQ2FTa1pVZ0FwUWhBa0VBSVFNRFFDQUFJQUlnQUNvQ0FKUTRBZ0FnQUVFRWFpRUFJQU5CQVdvaUF5QUJSdzBBQ3dzTDlRY0RDWDhFZlFKOEFrQWdCRUVCZENBQlRnMEFJQVZGRFFBZ0FiSWdCVUVDZEVIRTNRRnFLQUlBSUFSc0lBRnFzcFVpRHlBUGxFTUFBQUEvbENJUFE5c1B5VCtVdXhCUUlSTkRBQUNBUHlBUGswUGJEOGsvbExzUVVDRVVRUUFoQlNBQklBTkJBM1JPQkVBZ0EwRUNkU0VJUVFFaEJBTkFJQVFpQlVFQmFpRUVJQVVnQlNBRmJHb2dBMndnQ0dvZ0FVZ05BQXNMSUFFZ0EyNGhDaUFEUVFGSURRQWdFN1loRHlBVXRpRVJJQXBCQVdzaUN5QUZRUUYwYXlFSUlBb2dCV3NoRENBS1FRTnJJUWtnQWtGL1NpRU5RUUFoQWdOQUlBSWdDbXdoQmdKQUlBMUZCRUFDUUNBRlJRMEFRUUFoQVNBQUlBWkJBblJxSWdjaEJDQU1RUUZPQkVBRFFDQUVJQVZCQW5ScUlnNGdCQ29DQUNJUUlBK1VJQTRxQWdBaUVpQVJsSkk0QWdBZ0JDQVFJQkdVSUJJZ0Q1U1RPQUlBSUFSQkJHb2hCQ0FCUVFGcUlnRWdERWNOQUFzTElBaEJBRWdOQUNBSElBaEJBblJxSVFRZ0NDRUJBMEFnQkNBRlFRSjBhaUlISUFRcUFnQWlFQ0FQbENBSEtnSUFJaElnRVpTU09BSUFJQVFnRUNBUmxDQVNJQStVa3pnQ0FDQUVRUVJySVFRZ0FVRUFTaUVISUFGQkFXc2hBU0FIRFFBTEN5QUFJQVpCQW5ScUlRWWdDMEVCVGdSQUlBWXFBZ0FoRUVFQUlRRWdCaUVFQTBBZ0JDQVFJQStVSUFRcUFnUWlFaUFSbEpNNEFnQWdCQ0FRSUJHVUlCSWdENVNTSWhBNEFnUWdCRUVFYWlFRUlBRkJBV29pQVNBTFJ3MEFDd3NnQ1VFQVNBMEJJQVlnQ1VFQ2RHb2hCQ0FKSVFFRFFDQUVJQVFxQWdBaUVDQVJsQ0FFS2dJRUloSWdENVNTT0FJRUlBUWdFQ0FQbENBU0lCR1VremdDQUNBRVFRUnJJUVFnQVVFQVNpRUdJQUZCQVdzaEFTQUdEUUFMREFFTElBQWdCa0VDZEdvaEJpQUxRUUZPQkVBZ0Jpb0NBQ0VRUVFBaEFTQUdJUVFEUUNBRUlCQWdENVFnQkNvQ0JDSVNJQkdVa2pnQ0FDQUVJQklnRDVRZ0VDQVJsSk1pRURnQ0JDQUVRUVJxSVFRZ0FVRUJhaUlCSUF0SERRQUxDeUFKUVFCT0JFQWdCaUFKUVFKMGFpRUVJQWtoQVFOQUlBUWdCQ29DQkNJUUlBK1VJQVFxQWdBaUVpQVJsSk00QWdRZ0JDQVNJQStVSUJBZ0VaU1NPQUlBSUFSQkJHc2hCQ0FCUVFCS0lRY2dBVUVCYXlFQklBY05BQXNMSUFWRkRRQkJBQ0VCSUFZaEJDQU1RUUZPQkVBRFFDQUVJQVZCQW5ScUlnY2dCeW9DQUNJUUlCR1VJQVFxQWdBaUVpQVBsSk00QWdBZ0JDQVNJQkdVSUJBZ0Q1U1NPQUlBSUFSQkJHb2hCQ0FCUVFGcUlnRWdERWNOQUFzTElBaEJBRWdOQUNBR0lBaEJBblJxSVFRZ0NDRUJBMEFnQkNBRlFRSjBhaUlHSUFZcUFnQWlFQ0FSbENBRUtnSUFJaElnRDVTVE9BSUFJQVFnRWlBUmxDQVFJQStVa2pnQ0FDQUVRUVJySVFRZ0FVRUFTaUVHSUFGQkFXc2hBU0FHRFFBTEN5QUNRUUZxSWdJZ0EwY05BQXNMQzljQ0FRTi9Jd0JCRUdzaUF5UUFRWDhoQlFKQUFrQWdBVUgvL0FCTUJFQWdBVUhBUGtZTkFTQUJRZURkQUVZTkFRd0NDeUFCUVlEOUFFWU5BQ0FCUVlEM0FrWU5BQ0FCUWNDN0FVY05BUXNnQWtFQmEwRUJTdzBBSUFCQkFBSi9JQU5CNk1JQU5nSU1RUUFMQkg5QkFBVWdBeUFES0FJTVFRTnFRWHh4TmdJTUlBTW9BZ3hCb0Qwb0FnQkJBblJCNE1BQWFpQUNiRUdrUFNnQ0FFRUZkR3BxUWJRQmFnc1FCU0VBUVgwaEJTQURRZWpDQURZQ0NDQURJQU1vQWdoQkEycEJmSEVpQkRZQ0NDQUFJQUkyQWpBZ0FDQUNOZ0lJSUFCQjJBQTJBZ1FnQUNBQk5nSVlJQUFnQVRZQ0RDQUFJQUkyQWhBZ0FDQUVRZGdBYWlJRU5nSUFJQUJCMkFCcUVFUU5BQ0FBSUFScUlnUWdBU0FDRUZ3TkFFRUFJUVVnQTBFQU5nSUFJQVJCb000QUlBTVFCeG9nQUNBQlFmLy9BM0ZCa0FOdU5nSkFJQUJCQURZQ1BDQUFRUUEyQWl3TElBTkJFR29rQUNBRkMrc0JBUVovSUFBZ0FDZ0NJQ0FBS0FJa0lnUWdBeUFDYTJ3aUEyc2lCallDSUNBQUlBRUVmeUFFSUFJZ0FXdHNCU0FBS0FJY0lBTnJDeUlDTmdJY0lBSkJnSUNBQkUwRVFDQUFLQUlZSVFNZ0FDZ0NLQ0VFSUFBb0FoUWhCeUFBS0FJRUlRZ0RRQ0FBSUFKQkNIUWlDVFlDSENBQUlBZEJDR29pQnpZQ0ZFRUFJUUVnQXlBSVNRUkFJQUFnQTBFQmFpSUZOZ0lZSUFBb0FnQWdBMm90QUFBaEFTQUZJUU1MSUFBZ0FUWUNLQ0FBSUFaQkNIUkJnUDcvL3dkeElBRWdCRUVJZEhKQkFYWkIvd0Z4Y2tIL0FYTWlCallDSUNBQ1FZR0FBa2toQlNBQklRUWdDU0VDSUFVTkFBc0xDd01BQVF1YkJnSUtmdzk5SUFSQkJFNEVRQ0FFUVFOcklRd2dBMEY4Y1NFTElBTkJBMnNoRFNBRFFRUklJUTREUUNBQklBbEJBblFpQ21vaUJVRU1haUVISUFVcUFnZ2hFU0FGS2dJRUlSWWdCU29DQUNFWFF3QUFBQUFoRkVNQUFBQUFJUmhEQUFBQUFDRVpRd0FBQUFBaER5QUFJUVpCQUNFSVF3QUFBQUFoRUVNQUFBQUFJUkpEQUFBQUFDRVRRd0FBQUFBaEZVRUFJUVVnRGtVRVFBTkFJQlFnQmlvQ0FDSWFJQWNxQWdBaUZaU1NJQVlxQWdRaUd5QUhLZ0lFSWhDVWtpQUdLZ0lJSWh3Z0J5b0NDQ0lTbEpJZ0Jpb0NEQ0lkSUFjcUFnd2lFNVNTSVJRZ0dDQVJJQnFVa2lBVklCdVVraUFRSUJ5VWtpQVNJQjJVa2lFWUlCa2dGaUFhbEpJZ0VTQWJsSklnRlNBY2xKSWdFQ0FkbEpJaEdTQVBJQmNnR3BTU0lCWWdHNVNTSUJFZ0hKU1NJQlVnSFpTU0lROGdCMEVRYWlFSElBWkJFR29oQmlBUUlSY2dFeUVSSUJJaEZpQUlRUVJxSWdnZ0RVZ05BQXNnRHlFUUlCa2hFaUFZSVJNZ0N5RUZDeUFGUVFGeUlRZ0NmeUFESUFWTUJFQWdCaUVGSUFjTUFRc2dCa0VFYWlFRklCUWdCaW9DQUNJUElBY3FBZ0FpRlpTU0lSUWdFeUFSSUErVWtpRVRJQklnRmlBUGxKSWhFaUFRSUJjZ0Q1U1NJUkFnQjBFRWFnc2hCeUFJUVFGcUlRWUNmeUFESUFoTUJFQWdCU0VJSUFjTUFRc2dCVUVFYWlFSUlCUWdCU29DQUNJUElBY3FBZ0FpRjVTU0lSUWdFeUFWSUErVWtpRVRJQklnRVNBUGxKSWhFaUFRSUJZZ0Q1U1NJUkFnQjBFRWFnc2hCU0FESUFaS0JFQWdGQ0FJS2dJQUlnOGdCU29DQUpTU0lSUWdFaUFWSUErVWtpRVNJQkFnRVNBUGxKSWhFQ0FUSUJjZ0Q1U1NJUk1MSUFJZ0Ntb2dFRGdDQUNBQ0lBcEJCSEpxSUJJNEFnQWdBaUFLUVFoeWFpQVRPQUlBSUFJZ0NrRU1jbW9nRkRnQ0FDQUpRUVJxSWdrZ0RFZ05BQXNMQWtBZ0JDQUpUQTBBSUFOQkFFb0VRQU5BSUFFZ0NVRUNkQ0lJYWlFTFFRQWhCa01BQUFBQUlSRURRQ0FSSUFBZ0JrRUNkQ0lGYWlvQ0FDQUZJQXRxS2dJQWxKSWhFU0FHUVFGcUlnWWdBMGNOQUFzZ0FpQUlhaUFST0FJQUlBbEJBV29pQ1NBRVJ3MEFEQUlMQUFzZ0FpQUpRUUowYWtFQUlBUWdDV3RCQW5RUUJSb0xDNVVDQWdOL0FYMGpBQ0lGSVFnZ0JVR0FJR3NpQlNRQUFuOGdBd1JBSUFVZ0FFR0FJQkFFR2lBRFFRRk9CRUFEUUNBRklBWkJBblFpQjJvZ0FDQUhhaW9DQUNBQ0lBZHFLZ0lBSWdtVU9BSUFJQVVnQmtGL2MwR0FDR3BCQW5RaUIyb2dDU0FBSUFkcUtnSUFsRGdDQUNBR1FRRnFJZ1lnQTBjTkFBc0xJQVVoQUFzZ0FBc2dBQ0FCUVlBSUlBUnJJZ01nQkVFQmFoQXpRUUFoQWlBRVFRQk9CRUFEUUVNQUFBQUFJUWtnQWlBRGFpSUdRWUFJU0FSQUEwQWdDU0FBSUFaQkFuUnFLZ0lBSUFBZ0JpQUNhMEVDZEdvcUFnQ1VraUVKSUFaQkFXb2lCa0dBQ0VjTkFBc0xJQUVnQWtFQ2RHb2lCU0FKSUFVcUFnQ1NPQUlBSUFJZ0JFY2hCU0FDUVFGcUlRSWdCUTBBQ3dzZ0NDUUFDOWtEQWdGL0NYMGdBVUVNYWlFRElBRXFBZ2doQ3lBQktnSUVJUVlnQVNvQ0FDRUZBbjhnQWlvQ0RDRUhJQUlxQWdnaENDQUNLZ0lFSVFrZ0Fpb0NBQ0VLUVFBaEFRTkFJQUlnQUNvQ0FDSUVJQU1xQWdBaURKUWdCNUlpQnpnQ0RDQUNJQXNnQkpRZ0NKSWlDRGdDQ0NBQ0lBWWdCSlFnQ1pJaUNUZ0NCQ0FDSUFVZ0JKUWdDcElpQ2pnQ0FDQUNJQWNnQUNvQ0JDSUVJQU1xQWdRaUJaU1NJZ2M0QWd3Z0FpQUlJQXdnQkpTU0lnZzRBZ2dnQWlBSklBc2dCSlNTSWdrNEFnUWdBaUFLSUFZZ0JKU1NJZ280QWdBZ0FpQUhJQUFxQWdnaUJDQURLZ0lJSWdhVWtpSUhPQUlNSUFJZ0NDQUZJQVNVa2lJSU9BSUlJQUlnQ1NBTUlBU1VraUlKT0FJRUlBSWdDaUFMSUFTVWtpSUtPQUlBSUFJZ0J5QUFLZ0lNSWdRZ0F5b0NEQ0lMbEpJaUJ6Z0NEQ0FDSUFnZ0JpQUVsSklpQ0RnQ0NDQUNJQWtnQlNBRWxKSWlDVGdDQkNBQ0lBb2dEQ0FFbEpJaUNqZ0NBQ0FEUVJCcUlRTWdBRUVRYWlFQUlBRkJCR29pQVVFVlNBMEFDMEVBQ3dSQUlBTXFBZ0FoRENBQ0lBVWdBQ29DQUNJRmxDQUNLZ0lBa2pnQ0FDQUNJQVlnQlpRZ0Fpb0NCSkk0QWdRZ0FpQUxJQVdVSUFJcUFnaVNPQUlJSUFJZ0JTQU1sQ0FDS2dJTWtqZ0NEQ0FEUVFScUlRTWdBRUVFYWlFQUN3dW9BZ0lHZndSOUlBRXFBZ0FoQ2lBQVFRQWdBa0VDZEJBRklRUUNRQ0FCS2dJQVF3QUFBQUJiRFFBZ0FrRUFJQUpCQUVvYklRZEJBU0VGQTBBZ0F5QUhSZzBCUVFBaEFrTUFBQUFBSVFrZ0F3UkFBMEFnQ1NBRUlBSkJBblJxS2dJQUlBRWdBeUFDYTBFQ2RHb3FBZ0NVa2lFSklBSkJBV29pQWlBRFJ3MEFDd3NnQkNBRFFRSjBhaUFKSUFFZ0EwRUJhaUlBUVFKMGFpb0NBSktNSUFxVklnazRBZ0FnQXdSQUlBVkJBWFloQ0VFQUlRSURRQ0FFSUFKQkFuUnFJZ1lnQmlvQ0FDSUxJQWtnQkNBRElBSkJmM05xUVFKMGFpSUdLZ0lBSWd5VWtqZ0NBQ0FHSUF3Z0NTQUxsSkk0QWdBZ0FrRUJhaUlDSUFoSERRQUxDeUFGUVFGcUlRVWdBQ0VESUFvZ0NpQUpJQW1VbEpNaUNpQUJLZ0lBUTI4U2d6cVVYVUVCY3cwQUN3c0x6UWdCQzM5QmZ5RVBBa0FnQVVFQVNBMEFJQVJGRFFCQmZDRVBJQUZGRFFBQ2Z5QUFMUUFBSWc1QmdBRnhCRUJCZ1BjQ0lBNUJBM1pCQTNGMFFaQURiZ3dCQzBIQUIwSGdBeUFPUVFoeEd5QU9RZUFBY1VIZ0FFWU5BQnBCd0JZZ0RrRURka0VEY1NJSFFRTkdEUUFhUVlEM0FpQUhkRUhrQUc0TElRdEJBU0VJSUFCQkFXb2hDU0FCUVFGcklnY2hDZ0pBQWtBQ1FBSkFBa0FDUUFKQUlBNUJBM0VpREE0REF3QUJBZ3NnQWdSQVFRSWhDRUVCSVExQkFDRU1JQWNoQ2d3RUN5QUhRUUZ4RFFZZ0JDQUhRUUYySWdvN0FRQkJBaUVJUVFBaERBd0VDeUFCUVFGTUJFQWdCRUgvL3dNN0FRQkJmQThMSUFrdEFBQWlERUg4QVU4RVFFRUNJUWdnQVVFQ1RBUkFJQVJCLy84RE93RUFRWHdQQ3lBQUxRQUNRUUowSUF4cUlRd0xJQVFnRERzQkFDQUhJQWhySWdjZ0RFZ05CU0FISUF4cklRb2dDQ0FKYWlFSlFRSWhDRUVBSVF3TUFRc2dBVUVDU0EwRUlBQXRBQUVpRFVFL2NTSUlSUTBFSUFnZ0MyeEJnQzFMRFFRZ0FFRUNhaUVLSUFGQkFtc2hBVUVBSVF3Q1FDQU5RY0FBY1VVRVFDQUtJUWtNQVFzRFFDQUJRUUZJRFFZZ0RFRitJQW90QUFBaUNTQUpRZjhCUmlJTEcwSC9BWEVpQ1dvaERDQUJJQWxCZjNOcUlRRWdDa0VCYWlJSklRb2dDdzBBQ3lBQlFRQklEUVVMSUExQmdBRnhCRUJCQUNFTklBaEJBa2tFUUNBQklnY2hDZ3dDQ3lBSVFRRnJJUkVnQVNJS0lRY0RRQ0FFSUExQkFYUnFJUkFnQjBFQVRBUkFJQkJCLy84RE93RUFRWHdQQzBFQklRc2dDUzBBQUNJQlFmd0JUd1JBSUFkQkFVd0VRQ0FRUWYvL0F6c0JBRUY4RHd0QkFpRUxJQWt0QUFGQkFuUWdBV29oQVFzZ0VDQUJPd0VBSUFjZ0Myc2lCeUFCU0EwR0lBa2dDMm9oQ1NBS0lBdHJJQUZySVFvZ0RVRUJhaUlOSUJGSERRQUxRUUFoRFNBS1FRQk9EUUVNQlF0QkFTRU5JQUlFUUNBSElRb2dBU0VIREFJTElBRWdDRzBpQ2lBSWJDQUJSdzBFSUFoQkFra05BaUFJUVFGcklRdEJBQ0VIQTBBZ0JDQUhRUUYwYWlBS093RUFJQWRCQVdvaUJ5QUxSdzBBQ3lBQklRY0xJQUpGRFFFTElBUWdDRUVCZEdwQkFtc2hDMEgvL3dNaEFRSi9RWDhnQjBFQlNBMEFHaUFKTFFBQUlnSkIvQUZKQkVBZ0FpRUJRUUVNQVF0QmZ5QUhRUUpJRFFBYUlBa3RBQUZCQW5RZ0Ftb2hBVUVDQ3lFQ0lBc2dBVHNCQUNBQlFSQjBRUkIxSWd0QkFFZ05BaUFISUFKcklnY2dDMGdOQWlBQ0lBbHFJUWtnRFFSQUlBZ2dDMndnQjBvTkF5QUlRUUpKRFFJZ0JDQUJPd0VBUVFFaEFTQUlRUUZySWdKQkFVWU5BaUFFSUFKQkFYUnFJUWNEUUNBRUlBRkJBWFJxSUFjdkFRQTdBUUFnQVVFQmFpSUJJQUpIRFFBTERBSUxJQUlnQzJvZ0Nrb05BZ3dCQ3lBS1Fmc0pTZzBCSUFoQkFYUWdCR3BCQW1zZ0Nqc0JBQXNnQlFSQUlBVWdDU0FBYXpZQ0FBc2dDQVJBUVFBaEFRTkFJQWtnQkNBQlFRRjBhaTRCQUdvaENTQUJRUUZxSWdFZ0NFY05BQXNMSUFZRVFDQUdJQXdnQUdzZ0NXbzJBZ0FMSUFNRVFDQURJQTQ2QUFBTElBZ2hEd3NnRHd0YUFRUi9RUUZCSHlBQVoydEJBWFVpQW5RaEF3TkFJQUJCQUNBRVFRRjBJQU5xSUFKMElnRWdBQ0FCU1NJQkcyc2hBRUVBSUFNZ0FSc2dCR29oQkNBQ1FRQktJUUVnQTBFQmRpRURJQUpCQVdzaEFpQUJEUUFMSUFRTHhRUUNDSDhFZlNNQUlRY0NRQ0FEUVFKSERRQWdCRUVCUncwQUlBWXFBZ1FoRHlBR0tnSUFJUkFnQWtFQlRnUkFJQUFvQWdRaEF5QUFLQUlBSVFBZ0JTb0NBQ0VSUVFBaEJRTkFJQU1nQlVFQ2RDSUVhaW9DQUNFU0lBRWdCVUVEZENJSGFpQVFJQUFnQkdvcUFnQkRZRUtpRFpLU0loQkRBQUFBT0pRNEFnQWdBU0FIUVFSeWFpQVBJQkpEWUVLaURaS1NJZzlEQUFBQU9KUTRBZ0FnRVNBUGxDRVBJQkVnRUpRaEVDQUZRUUZxSWdVZ0FrY05BQXNMSUFZZ0R6Z0NCQ0FHSUJBNEFnQVBDeUFEUVFFZ0EwRUJTaHNoQ3lBQ0lBUnRJUWtnQnlBQ1FRSjBRUTlxUVhCeGF5RUtJQVVxQWdBaEVFRUFJUWNDUUNBRVFRSk9CRUFEUUVFQUlRVWdCaUFIUVFKMElnaHFJZ3dxQWdBaER5QUNRUUJLQkVBZ0FDQUlhaWdDQUNFTkEwQWdDaUFGUVFKMElnNXFJQThnRFNBT2Fpb0NBRU5nUXFJTmtwSWlEemdDQUNBUUlBK1VJUThnQlVFQmFpSUZJQUpIRFFBTEN5QU1JQTg0QWdBZ0NVRUJUZ1JBSUFFZ0NHb2hDRUVBSVFVRFFDQUlJQU1nQld4QkFuUnFJQW9nQkNBRmJFRUNkR29xQWdCREFBQUFPSlE0QWdBZ0JVRUJhaUlGSUFsSERRQUxDeUFIUVFGcUlnY2dDMGNOQUF3Q0N3QUxJQUpCQVVnaENRTkFJQVlnQjBFQ2RDSUVhaUlLS2dJQUlROGdDVVVFUUNBQklBUnFJUWdnQUNBRWFpZ0NBQ0VFUVFBaEJRTkFJQWdnQXlBRmJFRUNkR29nRHlBRUlBVkJBblJxS2dJQVEyQkNvZzJTa2lJUFF3QUFBRGlVT0FJQUlCQWdENVFoRHlBRlFRRnFJZ1VnQWtjTkFBc0xJQW9nRHpnQ0FDQUhRUUZxSWdjZ0MwY05BQXNMQzJVQUlBQXRBQUFpQUVHQUFYRUVRQ0FCSUFCQkEzWkJBM0YwUVpBRGJROExJQUJCNEFCeFFlQUFSZ1JBSUFCQkNIRUVRQ0FCUVRKdER3c2dBVUhrQUcwUEN5QUFRUU4yUVFOeElnQkJBMFlFUUNBQlFUeHNRZWdIYlE4TElBRWdBSFJCNUFCdEMvMFJBaFYvSEgwZ0FDZ0NDQ0VKSXdCQklHc2lFa0VCTmdJQUlBQkJER29oREVFQklRUURRQ0FNSUFNaUFrRUNkQ0lGUVFKeWFpOEJBQ0VHSUJJZ0FrRUJhaUlEUVFKMGFpQUVJQVVnREdvdUFRQnNJZ1EyQWdBZ0JrRUJSdzBBQ3lBSlFRQWdDVUVBU2hzaEZpQURRUUowSUFCcUxnRUtJUXdEUUNBTUlRVkJBQ0VEUVFFaERBSkFBa0FDUUFKQUFrQWdBQ0FDSWdrRWZ5QUpRUUowSUFCcUxnRUtJUXdnQ1VFQmRBVkJBQXRCQVhScUxnRU1RUUpyRGdRQUFnRURCQXNnQVNFQ0lCSWdDVUVDZEdvb0FnQWlCa0VCU0EwREEwQWdBaUFDS2dJQUloZ2dBaW9DSUNJWGt6Z0NJQ0FDSUJjZ0dKSTRBZ0FnQWlBQ1FTUnFLZ0lBSWhnZ0Fpb0NCQ0lYa2pnQ0JDQUNJQmNnR0pNNEFpUWdBaUFDS2dJSUloc2dBaW9DS0NJYUlBSkJMR29xQWdBaUY1SkQ4d1ExUDVRaUdaTTRBaWdnQWlBQ1FReHFLZ0lBSWhnZ0Z5QWFrMFB6QkRVL2xDSVhremdDTENBQ0lCc2dHWkk0QWdnZ0FpQVhJQmlTT0FJTUlBSXFBakFoR2lBQ0lBSXFBaEFpR1NBQ1FUUnFLZ0lBSWhpVE9BSXdJQUlnR2lBQ1FSUnFLZ0lBSWhlU09BSTBJQUlnRnlBYWt6Z0NGQ0FDSUJnZ0daSTRBaEFnQWlBQ0tnSVlJaHNnQWtFOGFpb0NBQ0lhSUFJcUFqZ2lGNU5EOHdRMVA1UWlHWk00QWpnZ0FpQUNRUnhxS2dJQUloZ2dHaUFYa2tQekJEVy9sQ0lYa3pnQ1BDQUNJQmNnR0pJNEFod2dBaUFiSUJtU09BSVlJQUpCUUdzaEFpQURRUUZxSWdNZ0JrY05BQXNNQXdzZ0VpQUpRUUowYWlnQ0FDRVRJQVZCQVVZRVFDQUJJUUlnRTBFQlNBMERBMEFnQWlBQ0tnSUFJaHdnQWlvQ0VDSWdraUlZSUFJcUFnZ2lJU0FDS2dJWUloMlNJaGVUT0FJUUlBSWdHQ0FYa2pnQ0FDQUNRUlJxSUFJcUFnUWlHU0FDS2dJVUloaVNJaDRnQWtFTWFpb0NBQ0lmSUFKQkhHb3FBZ0FpRjVJaUc1TTRBZ0FnQWlBWklCaVRJaG9nSVNBZGt5SVpramdDSENBQ0lCd2dJSk1pR0NBZklCZVRJaGVUT0FJWUlBSWdHaUFaa3pnQ0RDQUNJQmdnRjVJNEFnZ2dBaUFlSUJ1U09BSUVJQUpCSUdvaEFpQURRUUZxSWdNZ0UwY05BQXNNQXdzZ0UwRUJTQTBDSUFWQkFVZ05BaUFGUVFOc0lROGdCVUVCZENFUUlCTWdGblFpRFVFRGJDRVVJQTFCQVhRaEZTQUFLQUl3SVFaQkFDRUxBMEFnQVNBTElBeHNRUU4wYWlFQ1FRQWhFU0FHSWdNaENDQURJUVFEUUNBQ0tnSUFJU1FnQWlBUVFRTjBhaUlPSUFncUFnQWlLU0FPS2dJRUlpcVVJQTRxQWdBaUd5QUlLZ0lFSWhxVWtpSXJJQUlxQWdRaUxKSWlJaUFFS2dJQUlpMGdBaUFGUVFOMGFpSUhLZ0lFSWlPVUlBY3FBZ0FpSENBRUtnSUVJaG1Va2lJZ0lBTXFBZ0FpSVNBQ0lBOUJBM1JxSWdvcUFnUWlIWlFnQ2lvQ0FDSVlJQU1xQWdRaUY1U1NJaDZTSWgrVE9BSUVJQTRnSkNBYklDbVVJQ29nR3BTVElodVNJaG9nSENBdGxDQWpJQm1Va3lJWklCZ2dJWlFnSFNBWGxKTWlHSklpRjVNNEFnQWdBaUFmSUNLU09BSUVJQUlnR2lBWGtqZ0NBQ0FISUN3Z0s1TWlHaUFaSUJpVElobVRPQUlFSUFjZ0pDQWJreUlZSUNBZ0hwTWlGNUk0QWdBZ0NpQWFJQm1TT0FJRUlBb2dHQ0FYa3pnQ0FDQUNRUWhxSVFJZ0F5QVVRUU4wYWlFRElBZ2dGVUVEZEdvaENDQUVJQTFCQTNScUlRUWdFVUVCYWlJUklBVkhEUUFMSUF0QkFXb2lDeUFUUncwQUN3d0NDeUFTSUFsQkFuUnFLQUlBSWc5QkFVZ05BU0FBS0FJd0lnWWdEeUFXZENJUUlBVnNRUU4wYWlvQ0JDRWpJQVZCQVhRaEZDQVFRUUYwSVJWQkFDRUtBMEFnQVNBS0lBeHNRUU4wYWlFQ0lBWWlDQ0VFSUFVaEF3TkFJQUlnQlVFRGRHb2lCeUFDS2dJQUlBY3FBZ0FpSENBRUtnSUFJaUNVSUFjcUFnUWlJU0FFS2dJRUlobVVreUlkSUFJZ0ZFRURkR29pRFNvQ0FDSWVJQWdxQWdBaUg1UWdEU29DQkNJWUlBZ3FBZ1FpRjVTVElodVNJaHBEQUFBQVA1U1RPQUlBSUFjZ0Fpb0NCQ0FnSUNHVUlCd2dHWlNTSWhrZ0h5QVlsQ0FlSUJlVWtpSVlraUlYUXdBQUFEK1VremdDQkNBQ0lCb2dBaW9DQUpJNEFnQWdBaUFYSUFJcUFnU1NPQUlFSUEwZ0l5QVpJQmlUbENJWUlBY3FBZ0NTT0FJQUlBMGdCeW9DQkNBaklCMGdHNU9VSWhlVE9BSUVJQWNnQnlvQ0FDQVlremdDQUNBSElCY2dCeW9DQkpJNEFnUWdBa0VJYWlFQ0lBZ2dGVUVEZEdvaENDQUVJQkJCQTNScUlRUWdBMEVCYXlJRERRQUxJQXBCQVdvaUNpQVBSdzBBQ3d3QkN5QVNJQWxCQW5ScUtBSUFJZzFCQVVnTkFDQUFLQUl3SWc0Z0RTQVdkQ0lQSUFWc0lnWkJCSFJxSWdJcUFnUWhKU0FDS2dJQUlTWWdEaUFHUVFOMGFpSUNLZ0lFSVNjZ0Fpb0NBQ0VvSUFWQkFuUWhFQ0FGUVFOc0lSUWdCVUVCZENFVlFRQWhCd05BSUFWQkFVNEVRQ0FCSUFjZ0RHeEJBM1JxSWdJZ0JVRURkR29oQXlBQ0lCVkJBM1JxSVFnZ0FpQVVRUU4wYWlFRUlBSWdFRUVEZEdvaEMwRUFJUkVEUUNBQ0tnSUFJUzRnQWlBQ0tnSUVJaThnRGlBUElCRnNJZ3BCQkhScUlnWXFBZ0FpTWlBSUtnSUVJaVNVSUFncUFnQWlLU0FHS2dJRUlocVVraUlxSUE0Z0NrRVliR29pQmlvQ0FDSXJJQVFxQWdRaUxKUWdCQ29DQUNJaUlBWXFBZ1FpR1pTU0lpMlNJakFnRGlBS1FRTjBhaUlHS2dJQUlpTWdBeW9DQkNJY2xDQURLZ0lBSWgwZ0Jpb0NCQ0lZbEpJaUlDQU9JQXBCQlhScUlnWXFBZ0FpSGlBTEtnSUVJaCtVSUFzcUFnQWlHeUFHS2dJRUloZVVraUloa2lJeGtwSTRBZ1FnQWlBdUlDa2dNcFFnSkNBYWxKTWlHaUFpSUN1VUlDd2dHWlNUSWhtU0lpSWdIU0FqbENBY0lCaVVreUlZSUJzZ0hwUWdIeUFYbEpNaUY1SWlISktTT0FJQUlBTWdKU0FhSUJtVEloMlVJQ2NnR0NBWGt5SWVsSklpSHlBdklDWWdNSlFnS0NBeGxKS1NJaHFTT0FJRUlBTWdMaUFtSUNLVUlDZ2dISlNTa2lJWklDVWdLaUF0a3lJYmxDQW5JQ0FnSVpNaUdKU1NJaGVUT0FJQUlBc2dHaUFma3pnQ0JDQUxJQmNnR1pJNEFnQWdDQ0FsSUI2VUlDY2dIWlNUSWhvZ0x5QW9JRENVSUNZZ01aU1NraUlaa2pnQ0JDQUlJQ2NnRzVRZ0pTQVlsSk1pR0NBdUlDZ2dJcFFnSmlBY2xKS1NJaGVTT0FJQUlBUWdHU0Fha3pnQ0JDQUVJQmNnR0pNNEFnQWdDMEVJYWlFTElBUkJDR29oQkNBSVFRaHFJUWdnQTBFSWFpRURJQUpCQ0dvaEFpQVJRUUZxSWhFZ0JVY05BQXNMSUFkQkFXb2lCeUFOUncwQUN3c2dDVUVCYXlFQ0lBbEJBRW9OQUFzTGhBSUJCbjhqQUNJRUlRY2dCQ0FCSUFKc0lnaEJBblJCRDJwQmNIRnJJZ1VrQUFKQUlBTkZCRUFnQWtFQlNBMEJJQUZCQVVnTkFVRUFJUVFEUUNBQklBUnNJUVpCQUNFREEwQWdCU0FESUFacVFRSjBhaUFBSUFJZ0Eyd2dCR3BCQW5ScUtnSUFPQUlBSUFOQkFXb2lBeUFCUncwQUN5QUVRUUZxSWdRZ0FrY05BQXNNQVFzZ0FrRUJTQTBBSUFGQkFVZ05BQ0FDUVFKMFFlZzVhaUVHUVFBaEJBTkFJQVlnQkVFQ2RHb29BZ0FnQVd3aENVRUFJUU1EUUNBRklBTWdDV3BCQW5ScUlBQWdBaUFEYkNBRWFrRUNkR29xQWdBNEFnQWdBMEVCYWlJRElBRkhEUUFMSUFSQkFXb2lCQ0FDUncwQUN3c2dBQ0FGSUFoQkFuUVFCQm9nQnlRQUN3d0FJQUFnQVNBQ0lBTVFQZ3ZiQXdFT2Z5QURRUUZPQkVBZ0FDZ0NGQ0VJSUFBb0FoQWhCaUFBS0FJTUlRUWdBQ2dDQ0NFSklBQW9BZ1FoQnlBQUtBSUFJUVVEUUNBQklBcEJBblFpQzJwQi8vOEJJQWNnQlNBQ0lBcEJBWFJxTGdFQVFRcDBJZ3dnQldzaUJVSC8vd054UWRJTmJFRVFkaUFGUVJCMVFkSU5iR29pRFdvaURpQUhheUlIUWYvL0EzRkJpdlVBYkVFUWRpQUhRUkIxUVlyMUFHeHFJZzlxSWdVZ0NXc2lCMEgvL3dOeFFhdXhmbXhCRUhVZ0IwRVFkVUdyc1g1c2FpQUZhaUlGUVFsMVFRRnFRUUYxSWdsQmdJQitJQWxCZ0lCK1Noc2dCVUgvKy84UFNoczdBUUFnQVNBTFFRSnlha0gvL3dFZ0JpQUVJQXdnQkdzaUJFSC8vd054UWNZMWJFRVFkaUFFUVJCMVFjWTFiR29pQzJvaUVDQUdheUlHUWYvL0EzRkJxY2tCYkVFUWRpQUdRUkIxUWFuSkFXeHFJaEZxSWdRZ0NHc2lCa0gvL3dOeFFmYXhmMnhCRUhVZ0JrRVFkVUgyc1g5c2FpQUVhaUlFUVFsMVFRRnFRUUYxSWdoQmdJQitJQWhCZ0lCK1Noc2dCRUgvKy84UFNoczdBUUFnQkNBR2FpRUlJQVVnQjJvaENTQVFJQkZxSVFZZ0RpQVBhaUVISUFzZ0RHb2hCQ0FNSUExcUlRVWdDa0VCYWlJS0lBTkhEUUFMSUFBZ0NEWUNGQ0FBSUFZMkFoQWdBQ0FFTmdJTUlBQWdDVFlDQ0NBQUlBYzJBZ1FnQUNBRk5nSUFDd3RvQVFKL0l3QkJFR3NpQWlRQUFrQUNRQ0FCSUFBb0FnQkdCRUFnQVJBSUlBQW9BZ1FoQVNBQUVBZ01BUXNnQUNnQ0JDSUREUUVnQWlBQk5nSUFRZXNJSUFJUUhrRUFJUUVMSUFKQkVHb2tBQ0FCRHdzZ0FDQURJQUVRUHpZQ0JDQUNRUkJxSkFBZ0FBdWpFZ0VSZnlNQUlnY2hFaUFISUFBb0FwUUNJZ2dnQUNnQ2pBSWlCR3BCQW5SQkQycEJjSEZySWdja0FDQUhJQUJCR0dvaUV5QUlRUUowRUFRaERDQUFLQUtvQWlJSFFRUnFJUkFnQUNnQ2tBSWhEeUFISVFVRFFDQUFJQXdnQ0VFQ2RHb2dBaUFGSUFNZ0JDQURJQVJJR3lJT0VHY2dEa0VRZENFTkFrQUNRQUpBQWtBZ0FDZ0NsQUlpRVVFU2F3NFRBQU1EQXdNREFRTURBd01EQXdNREF3TURBZ01MSUExQkFVZ05BaUFBS0FLWUFpSUdRUkIwUVJCMUlSUkJBQ0VGQTBBZ0FVSC8vd0VnRUNBRlFmLy9BM0VnRkd4QkVIVWlDa0VTYkdvaUJDNEJBQ0lKSUF3Z0JVRVFkVUVDZEdvaUNDZ0NBQ0lMUWYvL0EzRnNRUkIxSUF0QkVIVWdDV3hxSUFRdUFRSWlDU0FJS0FJRUlndEJFSFZzYWlBTFFmLy9BM0VnQ1d4QkVIVnFJQVF1QVFRaUNTQUlLQUlJSWd0QkVIVnNhaUFMUWYvL0EzRWdDV3hCRUhWcUlBUXVBUVlpQ1NBSUtBSU1JZ3RCRUhWc2FpQUxRZi8vQTNFZ0NXeEJFSFZxSUFRdUFRZ2lDU0FJS0FJUUlndEJFSFZzYWlBTFFmLy9BM0VnQ1d4QkVIVnFJQVF1QVFvaUNTQUlLQUlVSWd0QkVIVnNhaUFMUWYvL0EzRWdDV3hCRUhWcUlBUXVBUXdpQ1NBSUtBSVlJZ3RCRUhWc2FpQUxRZi8vQTNFZ0NXeEJFSFZxSUFRdUFRNGlDU0FJS0FJY0lndEJFSFZzYWlBTFFmLy9BM0VnQ1d4QkVIVnFJQVF1QVJBaUJDQUlLQUlnSWdsQkVIVnNhaUFKUWYvL0EzRWdCR3hCRUhWcUlCQWdCaUFLUVg5emFrRVNiR29pQkM0QkFDSUtJQWdvQWtRaUNVRVFkV3hxSUFsQi8vOERjU0FLYkVFUWRXb2dCQzRCQWlJS0lBZ29Ba0FpQ1VFUWRXeHFJQWxCLy84RGNTQUtiRUVRZFdvZ0JDNEJCQ0lLSUFnb0Fqd2lDVUVRZFd4cUlBbEIvLzhEY1NBS2JFRVFkV29nQkM0QkJpSUtJQWdvQWpnaUNVRVFkV3hxSUFsQi8vOERjU0FLYkVFUWRXb2dCQzRCQ0NJS0lBZ29BalFpQ1VFUWRXeHFJQWxCLy84RGNTQUtiRUVRZFdvZ0JDNEJDaUlLSUFnb0FqQWlDVUVRZFd4cUlBbEIvLzhEY1NBS2JFRVFkV29nQkM0QkRDSUtJQWdvQWl3aUNVRVFkV3hxSUFsQi8vOERjU0FLYkVFUWRXb2dCQzRCRGlJS0lBZ29BaWdpQ1VFUWRXeHFJQWxCLy84RGNTQUtiRUVRZFdvZ0JDNEJFQ0lFSUFnb0FpUWlDRUVRZFd4cUlBaEIvLzhEY1NBRWJFRVFkV29pQ0VFRmRVRUJha0VCZFNJRVFZQ0FmaUFFUVlDQWZrb2JJQWhCMy8vL0FFb2JPd0VBSUFGQkFtb2hBU0FGSUE5cUlnVWdEVWdOQUFzTUFndEJBQ0VJSUExQkFFd05BUU5BSUFGQi8vOEJJQWN1QVFRaUJDQU1JQWhCRUhWQkFuUnFJZ1VvQWx3Z0JTZ0NBR29pQmtILy93TnhiRUVRZFNBR1FSQjFJQVJzYWlBSExnRUdJZ1FnQlNnQ1dDQUZLQUlFYWlJR1FSQjFiR29nQmtILy93TnhJQVJzUVJCMWFpQUhMZ0VJSWdRZ0JTZ0NWQ0FGS0FJSWFpSUdRUkIxYkdvZ0JrSC8vd054SUFSc1FSQjFhaUFITGdFS0lnUWdCU2dDVUNBRktBSU1haUlHUVJCMWJHb2dCa0gvL3dOeElBUnNRUkIxYWlBSExnRU1JZ1FnQlNnQ1RDQUZLQUlRYWlJR1FSQjFiR29nQmtILy93TnhJQVJzUVJCMWFpQUhMZ0VPSWdRZ0JTZ0NTQ0FGS0FJVWFpSUdRUkIxYkdvZ0JrSC8vd054SUFSc1FSQjFhaUFITGdFUUlnUWdCU2dDUkNBRktBSVlhaUlHUVJCMWJHb2dCa0gvL3dOeElBUnNRUkIxYWlBSExnRVNJZ1FnQlNnQ1FDQUZLQUljYWlJR1FSQjFiR29nQmtILy93TnhJQVJzUVJCMWFpQUhMZ0VVSWdRZ0JTZ0NQQ0FGS0FJZ2FpSUdRUkIxYkdvZ0JrSC8vd054SUFSc1FSQjFhaUFITGdFV0lnUWdCU2dDT0NBRktBSWthaUlHUVJCMWJHb2dCa0gvL3dOeElBUnNRUkIxYWlBSExnRVlJZ1FnQlNnQ05DQUZLQUlvYWlJR1FSQjFiR29nQmtILy93TnhJQVJzUVJCMWFpQUhMZ0VhSWdRZ0JTZ0NNQ0FGS0FJc2FpSUZRUkIxYkdvZ0JVSC8vd054SUFSc1FSQjFhaUlGUVFWMVFRRnFRUUYxSWdSQmdJQitJQVJCZ0lCK1Noc2dCVUhmLy84QVNoczdBUUFnQVVFQ2FpRUJJQWdnRDJvaUNDQU5TQTBBQ3d3QkMwRUFJUWdnRFVFQVRBMEFBMEFnQVVILy93RWdCeTRCQkNJRUlBd2dDRUVRZFVFQ2RHb2lCU2dDakFFZ0JTZ0NBR29pQmtILy93TnhiRUVRZFNBR1FSQjFJQVJzYWlBSExnRUdJZ1FnQlNnQ2lBRWdCU2dDQkdvaUJrRVFkV3hxSUFaQi8vOERjU0FFYkVFUWRXb2dCeTRCQ0NJRUlBVW9Bb1FCSUFVb0FnaHFJZ1pCRUhWc2FpQUdRZi8vQTNFZ0JHeEJFSFZxSUFjdUFRb2lCQ0FGS0FLQUFTQUZLQUlNYWlJR1FSQjFiR29nQmtILy93TnhJQVJzUVJCMWFpQUhMZ0VNSWdRZ0JTZ0NmQ0FGS0FJUWFpSUdRUkIxYkdvZ0JrSC8vd054SUFSc1FSQjFhaUFITGdFT0lnUWdCU2dDZUNBRktBSVVhaUlHUVJCMWJHb2dCa0gvL3dOeElBUnNRUkIxYWlBSExnRVFJZ1FnQlNnQ2RDQUZLQUlZYWlJR1FSQjFiR29nQmtILy93TnhJQVJzUVJCMWFpQUhMZ0VTSWdRZ0JTZ0NjQ0FGS0FJY2FpSUdRUkIxYkdvZ0JrSC8vd054SUFSc1FSQjFhaUFITGdFVUlnUWdCU2dDYkNBRktBSWdhaUlHUVJCMWJHb2dCa0gvL3dOeElBUnNRUkIxYWlBSExnRVdJZ1FnQlNnQ2FDQUZLQUlrYWlJR1FSQjFiR29nQmtILy93TnhJQVJzUVJCMWFpQUhMZ0VZSWdRZ0JTZ0NaQ0FGS0FJb2FpSUdRUkIxYkdvZ0JrSC8vd054SUFSc1FSQjFhaUFITGdFYUlnUWdCU2dDWUNBRktBSXNhaUlHUVJCMWJHb2dCa0gvL3dOeElBUnNRUkIxYWlBSExnRWNJZ1FnQlNnQ1hDQUZLQUl3YWlJR1FSQjFiR29nQmtILy93TnhJQVJzUVJCMWFpQUhMZ0VlSWdRZ0JTZ0NXQ0FGS0FJMGFpSUdRUkIxYkdvZ0JrSC8vd054SUFSc1FSQjFhaUFITGdFZ0lnUWdCU2dDVkNBRktBSTRhaUlHUVJCMWJHb2dCa0gvL3dOeElBUnNRUkIxYWlBSExnRWlJZ1FnQlNnQ1VDQUZLQUk4YWlJR1FSQjFiR29nQmtILy93TnhJQVJzUVJCMWFpQUhMZ0VrSWdRZ0JTZ0NUQ0FGS0FKQWFpSUdRUkIxYkdvZ0JrSC8vd054SUFSc1FSQjFhaUFITGdFbUlnUWdCU2dDU0NBRktBSkVhaUlGUVJCMWJHb2dCVUgvL3dOeElBUnNRUkIxYWlJRlFRVjFRUUZxUVFGMUlnUkJnSUIrSUFSQmdJQitTaHNnQlVIZi8vOEFTaHM3QVFBZ0FVRUNhaUVCSUFnZ0Qyb2lDQ0FOU0EwQUN3c2dBeUFPYXlJRFFRSk9CRUFnRENBTUlBNUJBblJxSUJGQkFuUVFCQm9nQWlBT1FRRjBhaUVDSUFBb0FxZ0NJUVVnQUNnQ2xBSWhDQ0FBS0FLTUFpRUVEQUVMQ3lBVElBd2dEa0VDZEdvZ0VVRUNkQkFFR2lBU0pBQUxtQU1CQ244akFDSUZJUWtnQlNBQUtBS01BaUlFUVFKMFFSOXFRWEJ4YXlJRkpBQWdCU0FBS1FJZ053SUlJQVVnQUNrQ0dEY0NBQ0FGUVJCcUlRb2dBQ2dDa0FJaEN3TkFJQUFnQ2lBQ0lBTWdCQ0FESUFSSUd5SUhFRDVCQUNFSUlBZEJFWFFpREVFQlRnUkFBMEFnQVVILy93RWdDRUgvL3dOeFFReHNRUkIySWcxQkEzUkI4QTFxSWdZdUFRSWdCU0FJUVJCMVFRRjBhaUlFTGdFQ2JDQUdMZ0VBSUFRdUFRQnNhaUFHTGdFRUlBUXVBUVJzYWlBR0xnRUdJQVF1QVFac2FrRUFJQTFyUVFOMFFjZ09haUlHTGdFR0lBUXVBUWhzYWlBR0xnRUVJQVF1QVFwc2FpQUdMZ0VDSUFRdUFReHNhaUFHTGdFQUlBUXVBUTVzYWlJRVFRNTFRUUZxUVFGMUlnWkJnSUIrSUFaQmdJQitTaHNnQkVILy8vNy9BMG9iT3dFQUlBRkJBbW9oQVNBSUlBdHFJZ2dnREVnTkFBc0xJQU1nQjJzaUEwRUJUZ1JBSUFVZ0JTQUhRUUowYWlJRUtRSUFOd0lBSUFVZ0JDa0NDRGNDQ0NBQ0lBZEJBWFJxSVFJZ0FDZ0NqQUloQkF3QkN3c2dBQ0FGSUFkQkFuUnFJZ0VwQWdBM0FoZ2dBQ0FCS1FJSU53SWdJQWtrQUF1ZEFnRUNmeUFBUWFnQmFpSUZJQUFvQXFRQ0lnUkJBWFJxSUFJZ0FDZ0NuQUlnQkd0QkFYUWlCQkFFR2dKQUFrQUNRQUpBQWtBZ0FDZ0NpQUpCQVdzT0F3QUJBZ01MSUFBZ0FTQUZJQUFvQXB3Q0VEMGdBQ0FCSUFBb0FxQUNRUUYwYWlBQ0lBUnFJQU1nQUNnQ25BSnJFRDBNQXdzZ0FDQUJJQVVnQUNnQ25BSVFRU0FBSUFFZ0FDZ0NvQUpCQVhScUlBSWdCR29nQXlBQUtBS2NBbXNRUVF3Q0N5QUFJQUVnQlNBQUtBS2NBaEJBSUFBZ0FTQUFLQUtnQWtFQmRHb2dBaUFFYWlBRElBQW9BcHdDYXhCQURBRUxJQUVnQlNBQUtBS2NBa0VCZEJBRUlBQW9BcUFDUVFGMGFpQUNJQVJxSUFNZ0FDZ0NuQUpyUVFGMEVBUWFDeUFGSUFJZ0F5QUFLQUtrQWlJQWEwRUJkR29nQUVFQmRCQUVHa0VBQzh3WEFRdC9Jd0JCa0FWcklnOGtBQ0FQSWdwQkFEWUNqQVVnQ2tJQU53T0FCU0FCS0FJRUlRZ0NRQ0FEUlEwQUlBaEJBVWdOQUFOQUlBQWdDVUdvSVd4cVFRQTJBdFFTSUFsQkFXb2lDU0FJUncwQUN3c2dBQ2dDNEVJZ0NFZ0VRQ0FBUWFnaGFoQW1JUTBnQVNnQ0JDRUlDd0pBSUFoQkFVY05BQ0FBS0FMZ1FrRUNSdzBBSUFFb0Fnd2dBQ2dDakJKQjZBZHNSaUVTQ3dKQUFrQWdBQ2dDMUJJTkFDQUlRUUZJRFFCQkFDRUpBMEJCQWlFRFFRRWhEa0cxZmlFTEFrQUNRQUpBQWtBZ0FTZ0NFQ0lNRGhVREJnWUdCZ1lHQmdZR0F3WUdCZ1lHQmdZR0JnRUFDeUFNUVNoR0RRRWdERUU4UncwRlFRUWhBMEVESVE0TUFndEJCQ0VEREFFTFFRUWhBMEVDSVE0TElBQWdDVUdvSVd4cUlnd2dBellDbEJJZ0RDQU9OZ0xZRWtHNGZpRUxJQUVvQWd4QkNuVWlBMEVQU3cwQ1FRRWdBM1JCZ0pFQ2NVVU5BaUFNSUFOQkFXb2dBU2dDQ0JCcklBMXFJUTBnQ1VFQmFpSUpJQUVvQWdRaUNFZ05BQXNMUVFJaENRSkFJQUVvQWdBaUEwRUNSd1JBSUFNaENRd0JDeUFJUVFKSERRQWdBQ2dDM0VKQkFVY0VRRUVDSVFnZ0FDZ0M0RUpCQVVjTkFRc2dBRUVBTmdMWVFpQUFRUUEyQXRCQ0lBQkJxRFJxSUFCQmdCTnFRYXdDRUFRYUlBRW9BZ1FoQ0NBQktBSUFJUWtMSUFBZ0NEWUM0RUlnQUNBSk5nTGNRa0c0ZmlFTElBRW9BZ2hCd0Q1clFjQzRBa3NOQUFKQUlBSkJBVVlOQUNBQUtBTFVFZzBBQWtBZ0NFRUJTQTBBUVFBaERnTkFRUUFoQ0NBQUlBNUJxQ0ZzYWlJTUtBTFlFa0VBU2dSQUlBeEIyQkpxSVFNRFFDQU1JQWhCQW5ScVFlUVNhaUFFUVFFUUJqWUNBQ0FJUVFGcUlnZ2dBeWdDQUVnTkFBc0xJQXdnQkVFQkVBWTJBdkFTSUE1QkFXb2lEaUFCS0FJRUlnaElEUUFMUVFBaEN5QUlRUUJNRFFBRFFDQUFJQXRCcUNGc2FpSUpRZ0EzQXZRU0lBbEIvQkpxUVFBMkFnQUNRQ0FKS0FMd0VrVU5BQ0FKS0FMWUVpSURRUUZHQkVBZ0NVSDBFbXBCQVRZQ0FBd0JDeUFFSUFOQkFuUkIwREJxS0FJQVFRZ1FBeUVESUFsQjJCSnFLQUlBSWd4QkFVZ05BQ0FEUVFGcUlRTkJBQ0VJQTBBZ0NTQUlRUUowYWtIMEVtb2dBeUFJZGtFQmNUWUNBQ0FJUVFGcUlnZ2dERWdOQUFzTElBdEJBV29pQ3lBQktBSUVJZ2hJRFFBTEN5QUNEUUFnQUNnQzJCSkJBVWdOQUNBQVFadzBhaUVPUVFBaEN3TkFBa0FnQ0VFQlNBMEFJQTRnQzBFQ2RDSU1haUVSUVFBaENTQUxCRUFnQzBFQmF5RURBMEFnQUNBSlFhZ2hiR29pRUNBTWFrSDBFbW9vQWdBRVFBSkFJQWtOQUNBSVFRSkhEUUFnQkNBS1FZQUZhaEFiSUJFb0FnQU5BQ0FFSUFwQmpBVnFFQ1VMSUJBZ0JDQUxRUUVnRUNBRFFRSjBha0gwRW1vb0FnQkJBRWRCQVhRUUtDQUVJQW9nRUVITkZXb3NBQUFnRUVIT0ZXb3NBQUFnRUNnQ21CSVFKeUFCS0FJRUlRZ0xJQWxCQVdvaUNTQUlTQTBBQ3d3QkN3TkFJQUFnQ1VHb0lXeHFJZ01vQXZRU0JFQUNRQ0FKRFFBZ0NFRUNSdzBBSUFRZ0NrR0FCV29RR3lBUktBSUFEUUFnQkNBS1FZd0ZhaEFsQ3lBRElBUkJBRUVCUVFBUUtDQUVJQW9nQTBITkZXb3NBQUFnQTBIT0ZXb3NBQUFnQXlnQ21CSVFKeUFCS0FJRUlRZ0xJQWxCQVdvaUNTQUlTQTBBQ3dzZ0MwRUJhaUlMSUFBb0F0Z1NTQTBBQ3dzQ1FDQUlRUUpIRFFBQ1FBSkFBa0FDUUFKQUFrQWdBZzREQUFJQkFnc2dCQ0FLUVlBRmFoQWJJQUFnQUNnQzFCSkJBblJxUVl3MGFpZ0NBRVVOQXd3RUN5QUFJQUFvQXRRU1FRSjBha0gwRW1vb0FnQkJBVVlOQVFzZ0NpQUFMZ0hRUWpZQ2dBVWdDaUFBTGdIU1FqWUNoQVVNQXdzZ0JDQUtRWUFGYWhBYklBQWdBQ2dDMUJKQkFuUnFRWncwYWlnQ0FBMEJDeUFFSUFwQmpBVnFFQ1VNQVFzZ0NrRUFOZ0tNQlFzQ1FDQUJLQUlFSWdoQkFrY05BQ0FLS0FLTUJRMEFRUUloQ0NBQUtBTGtRa0VCUncwQUlBQkJyQ3RxUVFCQmdBZ1FCUm9nQUVFQU5nTHNRU0FBUVFvNkFMQXpJQUJCNUFBMkFxd3pJQUJCQVRZQzhETWdBU2dDQkNFSUN3Si9JQWdnQVNnQ0RHd2dBU2dDQUNBQktBSUliRTRpRVVVRVFDQUZJUXdnQUVHWUVtb01BUXNnQ2lBQUtBS1lFa0VDYWlBSWJFRUJkRUVQYWtGd2NXc2lEQ0lQSkFBZ0FFR1lFbW9MS0FJQUlRTkJBU0VJSUFvZ0REWUNBQ0FLSUF3Z0EwRUJkR3BCQkdvaURqWUNCQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQWdBa1VFUUNBS0tBS01CVVVoQ0F3QkN5QUFLQUxrUWtVTkFDQUJLQUlFSVFNZ0FrRUNSdzBCSUFOQkFrY05BU0FBSUFBb0F2d3pRUUowYWtHY05Hb29BZ0JCQVVZaENBc2dBU2dDQkVFQVNnMEJEQVVMSUFOQkFVZ05CQ0FDUVFKSERRRU1BZ3NnQ0FSQVFRRWhDQ0FBS0FMVUVpSUxRUUJLUVFGMElRTUNRQ0FMUVFGSURRQWdBa0VDUncwQUlBdEJBblFnQUdwQjhCSnFLQUlBUVFCSFFRRjBJUU1MSUFBZ0JDQUtLQUlBUVFScUlBcEJpQVZxSUFJZ0F4QWNJUU1nQUNBQUtBTFVFa0VCYWpZQzFCSWdBeUFOYWlFTklBRW9BZ1FpQ1VFQ1NBMERBMEFDZjBFQUlBQW9BdFFTSUFocklndEJBVWdOQUJvZ0FrRUNSd1JBUVFGQkFpQUFLQUxrUWhzTUFRc2dBQ0FJUWFnaGJHb2dDMEVDZEdwQjhCSnFLQUlBUVFCSFFRRjBDeUVESUFBZ0NFR29JV3hxSWdzZ0JDQUtJQWhCQW5ScUtBSUFRUVJxSUFwQmlBVnFJQUlnQXhBY0lRTWdDeUFMS0FMVUVrRUJhallDMUJJZ0F5QU5haUVOSUFoQkFXb2lDQ0FCS0FJRUlnbElEUUFMREFNTElBSkJBa1lOQVFzZ0FDQUVJQXhCQkdvZ0NrR0lCV29nQWlBQUtBTFVFa0VBU2tFQmRCQWNJUU1nQUNBQUtBTFVFa0VCYWpZQzFCSWdBeUFOYWlFTklBRW9BZ1FpQ1VFQ1NBMEJJQW9vQW9nRlFRRjBJUVJCQVNFSUEwQWdDaUFJUVFKMGFpZ0NBRUVFYWtFQUlBUVFCUm9nQUNBSVFhZ2hiR29pQXlBREtBTFVFa0VCYWpZQzFCSWdDRUVCYWlJSUlBRW9BZ1FpQ1VnTkFBc01BUXNnQUNBRUlBeEJCR29nQ2tHSUJXcEJBZ0ovUVFBZ0FDZ0MxQklpQTBFQlNBMEFHaUFEUVFKMElBQnFRZkFTYWlnQ0FFRUFSMEVCZEFzUUhDRURJQUFnQUNnQzFCSkJBV28yQXRRU0lBTWdEV29oRFNBQktBSUVJZ2xCQWtnTkFDQUtLQUtJQlVFQmRDRUVRUUVoQ0FOQUlBb2dDRUVDZEdvb0FnQkJCR3BCQUNBRUVBVWFJQUFnQ0VHb0lXeHFJZ01nQXlnQzFCSkJBV28yQXRRU0lBaEJBV29pQ0NBQktBSUVJZ2xJRFFBTEN5QUpRUUpIRFFBZ0FTZ0NBRUVDUncwQUlBQkIwTUlBYWlBTUlBNGdDa0dBQldvZ0FDZ0NqQklnQ2lnQ2lBVVFaQ0FLS0FLSUJTRUVEQUVMSUF3Z0FDZ0MxRUkyQVFBZ0FDQU1JQW9vQW9nRklnUkJBWFJxS0FFQU5nTFVRZ3NnQmlBQktBSUlJQVJzSUFBdUFZd1NRZWdIYkcwaUF6WUNBQ0FQSUFOQkFTQUJLQUlBSWd0QkFrWWlDUnRCQVhSQkQycEJjSEZySWc4aUF5UUFJQUVvQWdRaENDQVJSUVJBSUFNZ0FDZ0NtQklpQjBFQ2FpQUliRUVCZENJRFFROXFRWEJ4YXlJTUpBQWdDaUFNSUFVZ0F4QUVJZ01nQjBFQmRHcEJCR28yQWdRZ0NpQUROZ0lBQ3lBUElBVWdDUnNoRHdKQUlBc2dDQ0FJSUF0S0cwRUJTQTBBUVFBaENTQU1JUWdEUUNBQUlBbEJxQ0ZzYWtHQUUyb2dEeUFJUVFKcUlBUVFRaUVIQWtBZ0FTZ0NBQ0lMUVFKSERRQkJBQ0VJSUFZb0FnQWlCRUVCU0EwQUEwQWdCU0FJUVFGMElnTWdDV3BCQVhScUlBTWdEMm92QVFBN0FRQWdDRUVCYWlJSUlBUkhEUUFMQ3lBSElBMXFJUTBnQ1VFQmFpSUpJQXNnQVNnQ0JDSUlJQWdnQzBvYlRnMEJJQW9nQ1VFQ2RHb29BZ0FoQ0NBS0tBS0lCU0VFREFBTEFBc0NRQUpBQWtBZ0MwRUNSdzBBSUFoQkFVY05BQ0FTRFFGQkFDRUlJQVlvQWdBaUJFRUFUQTBBQTBBZ0JTQUlRUUowSWdOQkFuSnFJQU1nQldvdkFRQTdBUUFnQ0VFQmFpSUlJQVJIRFFBTEN5QU5JUXNNQVFzZ0FFR29OR29nRHlBTVFRSnFJQW9vQW9nRkVFSWdEV29oQ3lBR0tBSUFJZ05CQVVnTkFFRUFJUWdEUUNBRklBaEJBblJCQW5KcUlBOGdDRUVCZEdvdkFRQTdBUUFnQ0VFQmFpSUlJQU5IRFFBTEMwRUFJUWdnQVNBQUtBTEVJRUVDUmdSL0lBQW9Bb3dTUVFoclFYeHhRYmdKYWlnQ0FDQUFLQUtFRW13RlFRQUxOZ0lVQWtBZ0FrRUJSZ1JBSUFBb0F1QkNJZ0ZCQVVnTkFRTkFJQUFnQ0VHb0lXeHFRUW82QUlnU0lBaEJBV29pQ0NBQlJ3MEFDd3dCQ3lBQUlBb29Bb3dGTmdMa1Fnc0xJQXBCa0FWcUpBQWdDd3N4QVFGL0lBQVFKaG9nQUVHb0lXb1FKaUVCSUFCQjJNSUFha0VBTmdJQUlBQkNBRGNDMEVJZ0FFRUFOZ0xrUWlBQkMvd0VBUWQvSUFBb0Fvd1NJZ1FnQUVHY0lXb29BZ0JIQkVBZ0FDQUVOZ0tjSVNBQVFaUWhha0tBZ0lTQWdJREFBRGNDQUNBQVFhQWhha0tDZ0lDQXdBSTNBZ0FnQUNBQUtBS1lFa0VIZERZQ3pDQUxJQU1FUUNBQUlBRWdBaEIwSUFBZ0FDZ0N3Q0JCQVdvMkFzQWdEd3NnQUNBQVFjMFZhaXdBQUNJQ05nTEVJQUpBSUFKQkFrWUVRRUVBSVFNQ1FDQUFLQUtVRWlJQ1JRMEFJQUpCQW5RZ0FXcEJCR3NpQ1NnQ0FDSUdRUUZJRFFBZ0FFSFFJR29oQnlBQUtBS2NFaUVLQTBBZ0F5QUJJQUlnQlVGL2Myb2lDRUVLYkdvaUJDNEJZaUFFTGdGZ2FpQUVMZ0ZrYWlBRUxnRm1haUFFTGdGb2FpSUVTQVJBSUFjZ0FTQUlRUkIwUVJCMVFRcHNhaUlETHdGb093RUlJQWNnQXlrQllEY0JBQ0FBSUFFZ0NFRUNkR29vQWdCQkNIUTJBc3dnSUFrb0FnQWhCaUFFSVFNTElBVkJBV29pQlNBQ1JnMEJJQVVnQ213Z0JrZ05BQXNMSUFCQjBDQnFJZ1JDQURjQ0FDQUFRZGdnYWtFQU93RUFJQUJCMUNCcUlBTTdBUUFnQTBITTJRQk1CRUFnQUVIV0lHcEJBRFlCQUNBRVFRQTJBUUFnQUVHQTZNd0ZJQU5CQVNBRFFRRktHMjVCRUhSQkVIVWdBMEVRZEVFUWRXeEJDblk3QWRRZ0RBSUxJQU5CenZrQVNBMEJJQUJCMWlCcVFRQTJBUUFnQUVIUUlHcEJBRFlCQUNBQVFZQ0F6ZmtBSUFOdUlBTkJFSFJCRUhWc1FRNTJPd0hVSUF3QkN5QUFRZEFnYWtJQU53SUFJQUJCMkNCcVFRQTdBUUFnQUNBRVFSQjBRUkIxUVlBa2JEWUN6Q0FnQUNnQ2xCSWhBZ3NnQUVIYUlHb2dBVUZBYXlBQUtBS2tFa0VCZEJBRUdpQUFRWkFoYWlBQktBS0lBVHNCQUNBQVFaUWhhaUFDUVFKMElBRnFLUUlJTndJQUlBQkJwQ0ZxSUFBb0Fwd1NOZ0lBSUFCQm9DRnFJQUkyQWdBTHZRRUJBMzhnQWk0QkFpSUVRUUZPQkVBZ0FpZ0NHQ0FFUWYvL0EzRWdBMnhCQW0xcUlRUkJBQ0VEQTBBZ0FDQURRUUYwYWlBRUxRQUFJZ1ZCQVhaQkIzRkJDV3c3QVFBZ0FTQURhaUFDS0FJVUlBSXVBUUpCQVdzZ0JVRUJjV3dnQTJwcUxRQUFPZ0FBSUFBZ0EwRUJjaUlHUVFGMGFpQUZRUVYyUVFsc093RUFJQUVnQm1vZ0FpZ0NGQ0FHSUFJdUFRSkJBV3NnQlVFRWRrRUJjV3hxYWkwQUFEb0FBQ0FFUVFGcUlRUWdBMEVDYWlJRElBSXVBUUpJRFFBTEN3dkxBd0VIZndKQUlBTWdCRXdOQUNBRVFRZE9CRUFnQkNFR0EwQWdBaTRCQWlBR1FRRjBJZ3NnQVdvaUJVRUVheTRCQUd3Z0FpNEJBQ0FGUVFKcklna3VBUUJzYWlBQ0xnRUVJQVZCQm1zdUFRQnNhaUFDTGdFR0lBVkJDR3N1QVFCc2FpQUNMZ0VJSUFWQkNtc3VBUUJzYWlBQ0xnRUtJQVZCREdzdUFRQnNhaUVJUVFZaEJ3TkFJQWdnQWlBSFFRRjBJZ3BxTGdFQUlBa2dDbXN1QVFCc2FpQUNJQXBCQW5KcUxnRUFJQWtnQjBGL2MwRUJkR291QVFCc2FpRUlJQWRCQW1vaUJ5QUVTQTBBQ3lBQUlBdHFJQVV1QVFCQkRIUWdDR3RCQzNWQkFXcEJBWFVpQlVHQWdINGdCVUdBZ0g1S0d5SUZRZi8vQVNBRlFmLy9BVWdiT3dFQUlBWkJBV29pQmlBRFJ3MEFDd3dCQ3lBRUlRWURRQ0FBSUFaQkFYUWlCV29nQVNBRmFpSUZMZ0VBUVF4MElBSXVBUUlnQlVFRWF5NEJBR3dnQWk0QkFDQUZRUUpyTGdFQWJHb2dBaTRCQkNBRlFRWnJMZ0VBYkdvZ0FpNEJCaUFGUVFockxnRUFiR29nQWk0QkNDQUZRUXByTGdFQWJHb2dBaTRCQ2lBRlFReHJMZ0VBYkdwclFRdDFRUUZxUVFGMUlnVkJnSUIrSUFWQmdJQitTaHNpQlVILy93RWdCVUgvL3dGSUd6c0JBQ0FHUVFGcUlnWWdBMGNOQUFzTElBQkJBQ0FFUVFGMEVBVWFDMG9CQVg5QkFDQUNRUUZxSUFKQkFFZ2JJZ0lnQUNnQ0FDSURTQVJBSUFBb0FnZ2dBV29oQVFOQUlBQWdBbW90QUF3Z0FVWUVRQ0FDRHdzZ0FrRUJhaUlDSUFOSURRQUxDMEYvQzBvQkFYOUJBQ0FDUVFGcUlBSkJBRWdiSWdJZ0FDZ0NBQ0lEU0FSQUlBRkJBWFJCQVhJaEFRTkFJQUFnQW1vdEFBd2dBVVlFUUNBQ0R3c2dBa0VCYWlJQ0lBTklEUUFMQzBGL0MwY0JBWDlCQUNBQ1FRRnFJQUpCQUVnYklnSWdBQ2dDQUNJRFNBUkFJQUZCQVhRaEFRTkFJQUFnQW1vdEFBd2dBVVlFUUNBQ0R3c2dBa0VCYWlJQ0lBTklEUUFMQzBGL0M3c0NBQUpBSUFGQkZFc05BQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBSUFGQkNXc09DZ0FCQWdNRUJRWUhDQWtLQ3lBQ0lBSW9BZ0FpQVVFRWFqWUNBQ0FBSUFFb0FnQTJBZ0FQQ3lBQ0lBSW9BZ0FpQVVFRWFqWUNBQ0FBSUFFMEFnQTNBd0FQQ3lBQ0lBSW9BZ0FpQVVFRWFqWUNBQ0FBSUFFMUFnQTNBd0FQQ3lBQ0lBSW9BZ0JCQjJwQmVIRWlBVUVJYWpZQ0FDQUFJQUVwQXdBM0F3QVBDeUFDSUFJb0FnQWlBVUVFYWpZQ0FDQUFJQUV5QVFBM0F3QVBDeUFDSUFJb0FnQWlBVUVFYWpZQ0FDQUFJQUV6QVFBM0F3QVBDeUFDSUFJb0FnQWlBVUVFYWpZQ0FDQUFJQUV3QUFBM0F3QVBDeUFDSUFJb0FnQWlBVUVFYWpZQ0FDQUFJQUV4QUFBM0F3QVBDeUFDSUFJb0FnQkJCMnBCZUhFaUFVRUlhallDQUNBQUlBRXJBd0E1QXdBUEN5QUFJQUpCQUJFR0FBc0xTZ0VEZnlBQUtBSUFMQUFBUVRCclFRcEpCRUFEUUNBQUtBSUFJZ0VzQUFBaEF5QUFJQUZCQVdvMkFnQWdBeUFDUVFwc2FrRXdheUVDSUFFc0FBRkJNR3RCQ2trTkFBc0xJQUlMRWdBZ0FFVUVRRUVBRHdzZ0FDQUJFSTRCQy9FREFRWi9Jd0JCOEFCcklnZ2tBRUYvSVFjQ1FBSkFBa0FnQVVVTkFDQUNSUTBBREFFTElBUWdBQ2dDREVHUUEyMXZEUUVMSUFGQkFDQUNHMFVFUUVFQUlRSURRQ0FBUVFCQkFDQURJQUFvQWdnZ0FteEJBblJxSUFRZ0Ftc1FFeUlIUVFCSUlnRU5BaUFDSUFJZ0Iyb2lCeUFCR3lFQklBY2hBaUFCSUFSSURRQUxJQUFnQVRZQ1NBd0JDeUFDUVFCSURRQUNRQ0FCTFFBQUlnZEJnQUZ4QkVBZ0IwRUZka0VEY1NJSFFjNElha0hOQ0NBSEd5RUtRZW9ISVFrTUFRc0NmeUFIUWVBQWNVSGdBRVlFUUVIcEJ5RUpRZEVJUWRBSUlBZEJFSEViREFFTFFlZ0hJUWtnQjBFRmRrRURjVUhOQ0dvTElRb0xJQUVnQUNnQ0RCQTZJUXNnQVMwQUFDRU1JQUVnQWlBRklBaEI2d0JxSUFnZ0NFSHNBR29nQmhBM0lnVkJBRWdFUUNBRklRY01BUXNnQVNBSUtBSnNhaUVCUVg0aEJ5QUZJQXRzSUFSS0RRQWdBQ0FMTmdKQUlBQWdDallDTkNBQUlBazJBamdnQUVFQ1FRRWdERUVFY1JzMkFqQUNRQ0FGUVFGSUJFQkJBQ0VIREFFTFFRQWhBa0VBSVFjRFFDQUFJQUVnQ0NBQ1FRRjBhaUlKTGdFQUlBTWdBQ2dDQ0NBSGJFRUNkR29nQkNBSGF4QVRJZ1pCQUVnRVFDQUdJUWNNQXdzZ0JpQUhhaUVISUFFZ0NTNEJBR29oQVNBQ1FRRnFJZ0lnQlVjTkFBc0xJQUFnQnpZQ1NDQUFRZ0EzQWt3TElBaEI4QUJxSkFBZ0J3dDdBUUo4SUFBZ0FLSWlBaUFDSUFLaW9pQUNSSHpWejFvNjJlVTlva1RybkN1SzV1VmF2cUNpSUFJZ0FrUjkvckZYNHgzSFBxSkUxV0hCR2FBQktyK2dva1NtK0JBUkVSR0JQNkNnSVFNZ0FDQUNJQUZFQUFBQUFBQUE0RCtpSUFJZ0FLSWlBQ0FEb3FHaUlBR2hJQUJFU1ZWVlZWVlZ4VCtpb0tFTHZnRUJBbjhqQUVFUWF5SUJKQUFDZkNBQXZVSWdpS2RCLy8vLy93ZHhJZ0pCKzhPay93Tk5CRUJFQUFBQUFBQUE4RDhnQWtHZXdacnlBMGtOQVJvZ0FFUUFBQUFBQUFBQUFCQXREQUVMSUFBZ0FLRWdBa0dBZ01EL0IwOE5BQm9DUUFKQUFrQUNRQ0FBSUFFUWxBRkJBM0VPQXdBQkFnTUxJQUVyQXdBZ0FTc0RDQkF0REFNTElBRXJBd0FnQVNzRENCQlBtZ3dDQ3lBQkt3TUFJQUVyQXdnUUxab01BUXNnQVNzREFDQUJLd01JRUU4TElRQWdBVUVRYWlRQUlBQUwrd0VCQlg4Z0FrRUJheUlEUVlBQ1R3UkFJQUFnQVVFWUlBTm5heUlGZGlJQ0lBSkJBV29nQXlBRmRrRUJhaEFoUVg4Z0JYUkJmM01nQVhFaEJpQUFLQUlNSVFJQ1FDQUFLQUlRSWdFZ0JXb2lCRUVoU1FSQUlBRWhBd3dCQ3dOQVFYOGhCQ0FBSUFBb0FnUWlBeUFBS0FJSUlnY2dBQ2dDR0dwTEJIOGdBQ0FIUVFGcUlnUTJBZ2dnQUNnQ0FDQURJQVJyYWlBQ09nQUFRUUFGUVg4TElBQW9BaXh5TmdJc0lBSkJDSFloQWlBQlFROUtJUVFnQVVFSWF5SURJUUVnQkEwQUN5QURJQVZxSVFRTElBQWdCRFlDRUNBQUlBWWdBM1FnQW5JMkFnd2dBQ0FBS0FJVUlBVnFOZ0lVRHdzZ0FDQUJJQUZCQVdvZ0FoQWhDemdCQVg4Z0FDQUFLQUljSUFGdUlnSTJBaVFnQUNnQ0lDQUNiaUlBUVg5eklBRnFRUUFnQUVFQmFpSUFJQUZySWdFZ0FDQUJTUnRxQy9vQ0FRWi9JQUJDZ0lDQWdJQVFOd0lZSUFCQ2dJQ0FnSkFCTndJUUlBQkNBRGNDQ0NBQUlBSTJBZ1FnQUNBQk5nSUFJQUlFUUNBQVFRRTJBaGdnQVMwQUFDRUVRUUVoQXdzZ0FFRUFOZ0lzSUFBZ0JEWUNLQ0FBUVlDQUFqWUNIQ0FBUVJFMkFoUWdBQ0FFUVFGMlFmOEFjeUlHTmdJZ0FrQWdBaUFEVFFSQUlBTWhCUXdCQ3lBQUlBTkJBV29pQlRZQ0dDQUJJQU5xTFFBQUlRY0xJQUFnQnpZQ0tDQUFRWUNBZ0FRMkFod2dBRUVaTmdJVUlBQWdCeUFFUVFoMGNrRUJka0gvQVhFZ0JrRUlkSEpCL3dGeklnZzJBaUJCQUNFRElBQUNmeUFDSUFWTkJFQWdCU0VHUVFBTUFRc2dBQ0FGUVFGcUlnWTJBaGdnQVNBRmFpMEFBQXNpQkRZQ0tDQUFRWUNBZ0lCNE5nSWNJQUJCSVRZQ0ZDQUFJQVFnQjBFSWRISkJBWFpCL3dGeElBaEJDSFJ5UWY4QmN5SUZOZ0lnSUFJZ0Jrc0VRQ0FBSUFaQkFXbzJBaGdnQVNBR2FpMEFBQ0VEQ3lBQUlBTTJBaWdnQUNBRElBUkJDSFJ5UVFGMlFmOEJjU0FGUVFoMGNrSC9BWE0yQWlBTDFBSUJCbjhDUUNBQklBSk9EUUFnQ0VFQklBaEJBVW9iSVFzQ1FDQUdJQWhJRFFBZ0FTRUtBMEFDUUNBRUlBcEJBblFpQ1dvaURDZ0NBRUVIU2cwQUlBVWdDV29vQWdBTkFFRUFJUWtEUUNBSFFRRVFDU0VOSUFNZ0FDZ0NDQ0FKYkNBS2FrRUNkR29pRGlBT0tnSUFJQTJ5UXdBQUFMK1NRUUZCRFNBTUtBSUFhM1N5bEVNQUFJQTRsSkk0QWdBZ0NVRUJhaUlKSUF0SERRQUxJQVlnQzJzaEJnc2dDa0VCYWlJS0lBSk9EUUVnQmlBSVRnMEFDd3NnQmlBSVNBMEFBMEFDUUNBRUlBRkJBblFpQ21vaURDZ0NBRUVIU2cwQVFRQWhDU0FGSUFwcUtBSUFRUUZIRFFBRFFDQUhRUUVRQ1NFS0lBTWdBQ2dDQ0NBSmJDQUJha0VDZEdvaURTQU5LZ0lBSUFxeVF3QUFBTCtTUVFGQkRTQU1LQUlBYTNTeWxFTUFBSUE0bEpJNEFnQWdDVUVCYWlJSklBdEhEUUFMSUFZZ0Myc2hCZ3NnQVVFQmFpSUJJQUpPRFFFZ0JpQUlUZzBBQ3dzTG5BY0NDWDhHZlNNQUlnTWhDaUFEUWJBS2F5SUVJZ01rQUNBRFFhQVBheUlHSWdNa0FDQURRZUFKYXlJSEpBQkJBQ0VEQTBBZ0JDQURRUUowYWlBQUlBTkJBM1JxS2dJQU9BSUFJQU5CQVdvaUEwSE1Ba2NOQUF0QkFDRURBMEFnQmlBRFFRSjBhaUFCSUFOQkEzUnFLZ0lBT0FJQUlBTkJBV29pQTBIbkEwY05BQXNnQkNBR0lBZEJ6QUpCbXdFUU0wTUFBSUEvSVF4QkFDRURBMEFnRENBR0lBTkJBblJxS2dJQUlnNGdEcFNTSVF3Z0EwRUJhaUlEUWN3Q1J3MEFDME1BQUlDL0lSRkJBU0VFUVFBaEEwTUFBSUMvSVE0RFFBSkFJQWNnQTBFQ2RDSUphaW9DQUNJTlF3QUFBQUJlUVFGekRRQWdFQ0FOUTh5OGpDdVVJZzBnRFpRaURaUWdEaUFNbEY1QkFYTU5BQ0FQSUEyVUlCRWdESlJlQkVBZ0JTRUVJQU1oQlNBUklRNGdEU0VSSUE4aEVDQU1JUThNQVFzZ0F5RUVJQTBoRGlBTUlSQUxJQXdnQmlBRFFjd0Nha0VDZEdvcUFnQWlEQ0FNbENBR0lBbHFLZ0lBSWd3Z0RKU1Rra01BQUlBL2x5RU1JQU5CQVdvaUEwR2JBVWNOQUF0QkFDQUVRUUYwYXlFTFFRQWdCVUVCZEdzaEJnTkFJQWNnQ0VFQ2RDSUVhaUlKUVFBMkFnQUNRQ0FHSUFocUlnTWdBMEVmZFNJRGFpQURjMEVEVHdSQUlBZ2dDMm9pQXlBRFFSOTFJZ05xSUFOelFRSkxEUUVMSUFFZ0JHb2hCVUVBSVFOREFBQUFBQ0VNQTBBZ0RDQUFJQU5CQW5RaUJHb3FBZ0FnQkNBRmFpb0NBSlNTSVF3Z0EwRUJhaUlEUVpnRlJ3MEFDeUFKSUF4REFBQ0F2NWM0QWdBTElBaEJBV29pQ0VHMkFrY05BQXREQUFDQVB5RU1RUUFoQXdOQUlBd2dBU0FEUVFKMGFpb0NBQ0lQSUErVWtpRU1JQU5CQVdvaUEwR1lCVWNOQUF0QkFDRUZRd0FBZ0w4aEVVTUFBQUFBSVE5QkFDRUFRUUFoQTBNQUFBQUFJUkJEQUFDQXZ5RU9BMEFDUUNBSElBTkJBblFpQkdvcUFnQWlEVU1BQUFBQVhrRUJjdzBBSUJBZ0RVUE12SXdybENJTklBMlVJZzJVSUE0Z0RKUmVRUUZ6RFFBZ0R5QU5sQ0FSSUF5VVhnUkFJQU1oQUNBUklRNGdEU0VSSUE4aEVDQU1JUThNQVFzZ0RTRU9JQXdoRUFzZ0RDQUJJQU5CbUFWcVFRSjBhaW9DQUNJTUlBeVVJQUVnQkdvcUFnQWlEQ0FNbEpPU1F3QUFnRCtYSVF3Z0EwRUJhaUlEUWJZQ1J3MEFDd0pBSUFCQkFVZ05BQ0FBUWJVQ1RnMEFJQWNnQUVFQ2RHb2lBU29DQkNJT0lBRkJCR3NxQWdBaUVKTWdBU29DQUNJUElCQ1RRek16TXorVVhnUkFRWDhoQlF3QkN5QVFJQTZUSUE4Z0RwTkRNek16UDVSZVJRMEFRUUVoQlFzZ0FpQUZJQUJCQVhScU5nSUFJQW9rQUF2MkJBSUZmd3Q5SXdCQk1Hc2lCQ1FBSUFBb0FnQWhCa0VCSVFVRFFDQUJJQVZCQW5ScUlBVkJBM1FpQnlBR2FpSUlLZ0lBSUFoQkJHc3FBZ0FnQmlBSFFRUnlhaW9DQUpKREFBQUFQNVNTUXdBQUFEK1VPQUlBSUFWQkFXb2lCVUdBQ0VjTkFBc2dBU0FHS2dJRVF3QUFBRCtVSUFZcUFnQ1NRd0FBQUQrVUlnazRBZ0FnQWtFQ1JnUkFJQUFvQWdRaEFFRUJJUVVEUUNBQklBVkJBblJxSWdJZ0Fpb0NBQ0FGUVFOMElnSWdBR29pQmlvQ0FDQUdRUVJyS2dJQUlBQWdBa0VFY21vcUFnQ1NRd0FBQUQrVWtrTUFBQUEvbEpJNEFnQWdCVUVCYWlJRlFZQUlSdzBBQ3lBQklBa2dBQ29DQkVNQUFBQS9sQ0FBS2dJQWtrTUFBQUEvbEpJNEFnQUxRUUFoQlNBQklBUkJFR3BCQUVFQVFRUWdBeEEwSUFRZ0JDb0NFRU5IQTRBL2xEZ0NFQ0FFSUFRcUFoUWlDU0FKUTI4U0F6eVVRMjhTQXp5VWt6Z0NGQ0FFSUFRcUFoZ2lDU0FKUTI4U2d6eVVRMjhTZ3p5VWt6Z0NHQ0FFSUFRcUFod2lDU0FKUTZhYnhEeVVRNmFieER5VWt6Z0NIQ0FFSUFRcUFpQWlDU0FKUTI4U0F6MlVRMjhTQXoyVWt6Z0NJQ0FFSUFSQkVHcEJCQkEySUFRcUFneERLdlluUDVRaUNTQUVLZ0lJUTcyZk9qK1VJZ3BEemN4TVA1U1NJUTBnQ2lBRUtnSUVReWhjVHorVUlncER6Y3hNUDVTU0lRNGdDaUFFS2dJQVEyWm1aaitVSWdwRHpjeE1QNVNTSVE4Z0NVUE56RXcvbENFUUlBcER6Y3hNUDVJaEVVTUFBQUFBSVFsREFBQUFBQ0VLQTBBZ0FTQUZRUUowYWlJQUlCQWdFcFFnRFNBTGxDQU9JQXlVSUE4Z0NaUWdFU0FLbENBQUtnSUFJaE9Ta3BLU2tqZ0NBQ0FMSVJJZ0RDRUxJQWtoRENBS0lRa2dFeUVLSUFWQkFXb2lCVUdBQ0VjTkFBc2dCRUV3YWlRQUMrMEVBZ1ovQVgwZ0F5QUNRUUZxSWdNZ0FTQUJJQUpLSWdVYlFRSjBRWUN4QVdvb0FnQWdBU0FESUFFZ0Ewb2JRUUowYWlnQ0FDQUJJQUlnQVNBQ1NCdEJBblJCZ0xFQmFpZ0NBQ0FCSUFJZ0JSdEJBblJxS0FJQWFoQVdJUVFnQVVFRFRnUkFBMEFDZnlBQklnVWdBa3dFUUNBQ0lRTUNRQ0FGUVFKMElnWkJnTEVCYWlnQ0FDSUlJQVpxS0FJQUlBUWdBa0VDZENBSWFpZ0NCQ0lIUVg5QkFDQUVJQWRQR3lJSGNXc2lCRXNFUUFOQUlBRkJBV3NpQVVFQ2RFR0FzUUZxS0FJQUlBWnFLQUlBSWdrZ0JFc05BQXdDQ3dBTEEwQWdBeUlCUVFGcklRTWdDQ0FCUVFKMGFpZ0NBQ0lKSUFSTERRQUxDeUFBSUFJZ0Iyb2dBV3NnQjNOQkVIUkJFSFVpQWpZQ0FDQUtJQUt5SWdvZ0NwU1NJUW9nQVNFQ0lBUWdDV3NNQVFzZ0JVRUNkQ0lESUFKQkFXb2lDRUVDZEVHQXNRRnFLQUlBYWlnQ0FDRUJBa0FnQkNBQ1FRSjBRWUN4QVdvb0FnQWdBMm9vQWdBaUJra05BQ0FCSUFSTkRRQWdBRUVBTmdJQUlBUWdCbXNNQVFzZ0JDQUJRWDlCQUNBQklBUk5HeUlFY1dzaEJnTkFJQVlnQWlJQlFRRnJJZ0pCQW5SQmdMRUJhaWdDQUNBRGFpZ0NBQ0lIU1EwQUN5QUFJQVFnQ0dvZ0FXc2dCSE5CRUhSQkVIVWlBVFlDQUNBS0lBR3lJZ29nQ3BTU0lRb2dCaUFIYXdzaEJDQUZRUUZySVFFZ0FFRUVhaUVBSUFWQkEwb05BQXNMSUFBZ0FpQUVJQUpCQVhSQkFYSWlBVThpQW1zZ0JDQUJRWDlCQUNBQ0d5SUNjV3NpQTBFQmFpSUZRUUYySWdGcklBSnpRUkIwUVJCMUlnSTJBZ0FnQUNBQklBTWdCVUYrY1VFQmEwRUFJQUViYXlJQWEwRUFJQUJyYzBFUWRFRVFkU0lBTmdJRUlBb2dBcklpQ2lBS2xKSWdBTElpQ2lBS2xKSUxuUUlCQm44Z0FDQUJRUUZySWdoQkFuUnFLQUlBSWdjZ0IwRWZkU0lFYWlBRWN5RUVJQWRCSDNZaEJRTkFJQUVnQ0VFQmF5SUhheUlHSUFRZ0JDQUdTaHRCQW5SQmdMRUJhaWdDQUNBR0lBUWdCQ0FHU0J0QkFuUnFLQUlBSUFWcUlRVWdCQ0FBSUFkQkFuUnFLQUlBSWdrZ0NVRWZkU0lFYWlBRWMyb2hCQ0FKUVg5TUJFQWdCU0FFUVFGcUlnVWdCaUFFSUFaSUcwRUNkRUdBc1FGcUtBSUFJQVlnQlNBRklBWklHMEVDZEdvb0FnQnFJUVVMSUFoQkFVb2hCaUFISVFnZ0JnMEFDeUFESUFVZ0FrRUJhaUlBSUFFZ0FTQUNTaUlERzBFQ2RFR0FzUUZxS0FJQUlBRWdBQ0FBSUFGSUcwRUNkR29vQWdBZ0FTQUNJQUVnQWtnYlFRSjBRWUN4QVdvb0FnQWdBU0FDSUFNYlFRSjBhaWdDQUdvUVVRdjdCQUlKZndOOUl3QkJFR3NpQlNFSElBVWtBQ0FGUWVBQWF5SUpJZ1VrQUNBRklBTkJHR29pQmtFQ2RFRVBha0Z3Y1dzaUNDUUFJQVlDZjBFQUlnVkJBQTBBR2dOQUlBa2dCVUVDZEdvZ0FTQUZRWDl6UVJocVFRSjBhaW9DQURnQ0FDQUZRUUZxSWdWQkdFY05BQXRCQUNJRlFRQU5BQm9EUUNBSUlBVkJBblJxSUFRZ0JVRi9jMEVZYWtFQ2RHb3FBZ0NNT0FJQUlBVkJBV29pQlVFWVJ3MEFDMEVZQ3lJRlNnUkFJQWdnQlVFQ2RHcEJBQ0FHSUFWclFRSjBFQVVhQzBFQUlRWWdBMEVFVGdSQUlBTkJBMnNoQ3dOQUlBY2dBQ0FHUVFKMElnVnFLZ0lBT0FJQUlBY2dBQ0FGUVFSeUlneHFLZ0lBT0FJRUlBY2dBQ0FGUVFoeUlnMXFLZ0lBT0FJSUlBY2dBQ0FGUVF4eUlnNXFLZ0lBT0FJTUlBa2dCU0FJYWlBSEVEVWdDQ0FHUVJocVFRSjBhaUlLSUFjcUFnQWlENHc0QWdBZ0FpQUZhaUFQT0FJQUlBb2dCeW9DQkNBUElBRXFBZ0NVa3lJUWpEZ0NCQ0FDSUF4cUlCQTRBZ0FnQ2lBSEtnSUlJQkFnQVNvQ0FKU1RJQThnQVNvQ0JKU1RJaEdNT0FJSUlBSWdEV29nRVRnQ0FDQUtJQWNxQWd3Z0VTQUJLZ0lBbEpNZ0VDQUJLZ0lFbEpNZ0R5QUJLZ0lJbEpNaUQ0dzRBZ3dnQWlBT2FpQVBPQUlBSUFaQkJHb2lCaUFMU0EwQUN3c2dBeUFHU2dSQUEwQWdBQ0FHUVFKMElnRnFLZ0lBSVE5QkFDRUZBMEFnRHlBSklBVkJBblJxS2dJQUlBZ2dCU0FHYWtFQ2RHb3FBZ0NVa3lFUElBVkJBV29pQlVFWVJ3MEFDeUFJSUFaQkdHcEJBblJxSUE4NEFnQWdBU0FDYWlBUE9BSUFJQVpCQVdvaUJpQURSdzBBQ3d0QkFDRUZBMEFnQkNBRlFRSjBhaUFDSUFWQmYzTWdBMnBCQW5ScUtnSUFPQUlBSUFWQkFXb2lCVUVZUncwQUN5QUhRUkJxSkFBTDZBSUNCMzhCZlNNQVFSQnJJZ1VoQkNBRkpBQWdCVUhnQUdzaUJpUUFRUUFoQlFOQUlBWWdCVUVDZEdvZ0FTQUZRWDl6UVJocVFRSjBhaW9DQURnQ0FDQUZRUUZxSWdWQkdFY05BQXRCQUNFQklBTkJCRTRFUUNBRFFRTnJJUWNEUUNBRUlBQWdBVUVDZENJRmFpSUlLZ0lBT0FJQUlBUWdBQ0FGUVFSeUlnbHFLZ0lBT0FJRUlBUWdBQ0FGUVFoeUlncHFLZ0lBT0FJSUlBUWdBQ0FGUVF4eUlndHFLZ0lBT0FJTUlBWWdDRUhnQUdzZ0JCQTFJQUlnQldvZ0JDb0NBRGdDQUNBQ0lBbHFJQVFxQWdRNEFnQWdBaUFLYWlBRUtnSUlPQUlBSUFJZ0Myb2dCQ29DRERnQ0FDQUJRUVJxSWdFZ0IwZ05BQXNMSUFFZ0EwZ0VRQU5BSUFGQkdHc2hCeUFBSUFGQkFuUWlDR29xQWdBaERFRUFJUVVEUUNBTUlBWWdCVUVDZEdvcUFnQWdBQ0FGSUFkcVFRSjBhaW9DQUpTU0lRd2dCVUVCYWlJRlFSaEhEUUFMSUFJZ0NHb2dERGdDQUNBQlFRRnFJZ0VnQTBjTkFBc0xJQVJCRUdva0FBdWZHUUkxZndWOUl3QkI0Q0ZySWdZaEF5QUdKQUFnQUNnQ0NDSUlRUUVnQ0VFQlNoc2hGVUVBSUFGcklSRWdBQ2dDQUNJS0tBSUVJZ2xCZ0JCcUlRUWdDaWdDSUNFU0lBb29BZ2doQ3dOQUlBVkJBblFpQnlBRFFkZ2hhbW9nQUNBRUlBVnNRUUowYWtIY0FHb2lFellDQUNBRFFkQWhhaUFIYWlBVElCRkJBblJxUVlCQWF6WUNBQ0FGUVFGcUlnVWdGVWNOQUFzZ0FDQUVJQWhzUVFKMGFrSGNBR29oRENBQUtBSVVJUVFDUUFKQUFrQWdBQ2dDTkNJVFFRUktEUUFnQkEwQUlBQW9BamhGRFFFTElBd2dDRUhnQUd4cUlRNGdCQ0FBS0FJWUlnY2dDaWdDRENJRklBVWdCMG9iSWd4S0lSRWdCaUFCSUFoc1FRSjBRUTlxUVhCeGF5SVBKQUFnQkNBSFNBUkFJQTRnQzBFRGRDSUZhaUFGYWlBRmFpRU5Rd0FBQUQ5REFBREFQeUFUR3lFNFFRQWhCZ05BSUFZZ0Myd2hGQ0FFSVFVRFFDQU9JQVVnRkdwQkFuUWlGbW9pRnlBTklCWnFLZ0lBSWprZ0Z5b0NBQ0E0a3lJNklEa2dPbDRiT0FJQUlBVkJBV29pQlNBSFJ3MEFDeUFHUVFGcUlnWWdGVWNOQUFzTElBUWdEQ0FSR3lFUklBQW9BaWdoQmdKQUlBaEJBVWdOQUNBRUlBeE9EUUJCQUNFTEEwQWdBU0FMYkNFVUlBUWhCd05BUVFBaEJTQVNJQWRCQVhScUxnRUFJZzBnQW5RZ0ZHb2hEQ0FTSUFkQkFXb2lCMEVCZEdvdUFRQWdEV3NnQW5RaURVRUFTZ1JBQTBBZ0R5QUZJQXhxUVFKMGFpQUdRWTNNNVFCc1FkL211K01EYWlJR1FSUjFzamdDQUNBRlFRRnFJZ1VnRFVjTkFBc0xJQThnREVFQ2RHb2dEVU1BQUlBL0lBQW9BaVFRTGlBSElCRkhEUUFMSUF0QkFXb2lDeUFJUncwQUN3c2dBQ0FHTmdJb0lBbEJBWFlnQVd0QkFuUkJnRUJySVFaQkFDRUZBMEFnQTBIWUlXb2dCVUVDZEdvb0FnQWlDU0FKSUFGQkFuUnFJQVlRRGhvZ0JVRUJhaUlGSUJWSERRQUxJQW9nRHlBRFFkQWhhaUFPSUFRZ0VTQUlJQWhCQUNBQ0lBQW9BaEJCQUNBQUtBSWtFQ0lNQVFzQ2ZTQVRSUVJBSUFOQjJDRnFJQU5COEFCcUlBZ2dBQ2dDSkJCV0lBTkJrQXhxSUFOQjhBQnFJQU1RVlNBQVFkQUZJQU1vQWdCcklnSTJBakJEQUFDQVB3d0JDeUFBS0FJd0lRSkR6Y3hNUHdzaFBDQUNRUUYwSWdSQmdBZ2dCRUdBQ0VnYklnZEJmeUFIUVg5S0d5SUVRUUVnQkVFQlNCc2dCMEVBSUFkcklnUWdCQ0FIU0J0QkFYWnNJZ1JCQVNBRVFRRktHeUVaSUFZZ0NVRUNkRUVQYWtGd2NXc2lFaUlFSkFCQmdBZ2dCMnNoR2tHQUNDQUhRUUYxYXlFYklBTWdCMEVDZENJTmEwSFFJV29oRkNBSlFRSnRJUnhCZ0FnZ0Ftc2hIU0FCSUFscUlnaEJBblFoSGtHQUVDQUJheUlPUVFKMElSWWdCQ0FOUVE5cVFYQnhheUlYSkFBZ0EwSFFBV29oRHlBS0tBSThJUXRCL3c4Z0FXdEJBblFoSDBIK0R5QUJhMEVDZENFZ1FmMFBJQUZyUVFKMElTRkIvQThnQVd0QkFuUWhJa0g3RHlBQmEwRUNkQ0VqUWZvUElBRnJRUUowSVNSQitROGdBV3RCQW5RaEpVSDREeUFCYTBFQ2RDRW1RZmNQSUFGclFRSjBJU2RCOWc4Z0FXdEJBblFoS0VIMUR5QUJhMEVDZENFcFFmUVBJQUZyUVFKMElTcEI4dzhnQVd0QkFuUWhLMEh5RHlBQmEwRUNkQ0VzUWZFUElBRnJRUUowSVMxQjhBOGdBV3RCQW5RaExrSHZEeUFCYTBFQ2RDRXZRZTRQSUFGclFRSjBJVEJCN1E4Z0FXdEJBblFoTVVIc0R5QUJhMEVDZENFeVFlc1BJQUZyUVFKMElUTkI2ZzhnQVd0QkFuUWhORUhwRHlBQmEwRUNkQ0UxUWVnUElBRnJRUUowSVRaQkFDRUtBMEFnQTBIWUlXb2dDa0VDZEdvb0FnQWhCRUVBSVFVRFFDQUZRUUowSWdZZ0EwSHdBR3BxSUFRZ0JtcEJvQjlxS2dJQU9BSUFJQVZCQVdvaUJVR1lDRWNOQUFzQ1FDQVRCRUFnQ2tFWWJDRUZEQUVMSUE4Z0F5QUxJQWxCR0NBQUtBSWtFRFFnQXlBREtnSUFRMGNEZ0QrVU9BSUFJQU1nQXlvQ0JDSTRJRGhEdmplR09KU1RPQUlFSUFNZ0F5b0NDQ0k0SURoRHZqZUdPSlFpT0NBNGtpSTRJRGlTa3pnQ0NDQURJQU1xQWd3aU9DQTRRNzQzaGppVVF3QUFRRUNVUXdBQVFFQ1VremdDRENBRElBTXFBaEFpT0NBNFE3NDNoamlVUXdBQWdFQ1VRd0FBZ0VDVWt6Z0NFQ0FESUFNcUFoUWlPQ0E0UTc0M2hqaVVRd0FBb0VDVVF3QUFvRUNVa3pnQ0ZDQURJQU1xQWhnaU9DQTRRNzQzaGppVVF3QUF3RUNVUXdBQXdFQ1VremdDR0NBRElBTXFBaHdpT0NBNFE3NDNoamlVUXdBQTRFQ1VRd0FBNEVDVWt6Z0NIQ0FESUFNcUFpQWlPQ0E0UTc0M2hqaVVRd0FBQUVHVVF3QUFBRUdVa3pnQ0lDQURJQU1xQWlRaU9DQTRRNzQzaGppVVF3QUFFRUdVUXdBQUVFR1VremdDSkNBRElBTXFBaWdpT0NBNFE3NDNoamlVUXdBQUlFR1VRd0FBSUVHVWt6Z0NLQ0FESUFNcUFpd2lPQ0E0UTc0M2hqaVVRd0FBTUVHVVF3QUFNRUdVa3pnQ0xDQURJQU1xQWpBaU9DQTRRNzQzaGppVVF3QUFRRUdVUXdBQVFFR1VremdDTUNBRElBTXFBalFpT0NBNFE3NDNoamlVUXdBQVVFR1VRd0FBVUVHVWt6Z0NOQ0FESUFNcUFqZ2lPQ0E0UTc0M2hqaVVRd0FBWUVHVVF3QUFZRUdVa3pnQ09DQURJQU1xQWp3aU9DQTRRNzQzaGppVVF3QUFjRUdVUXdBQWNFR1VremdDUENBRElBTXFBa0FpT0NBNFE3NDNoamlVUXdBQWdFR1VRd0FBZ0VHVWt6Z0NRQ0FESUFNcUFrUWlPQ0E0UTc0M2hqaVVRd0FBaUVHVVF3QUFpRUdVa3pnQ1JDQURJQU1xQWtnaU9DQTRRNzQzaGppVVF3QUFrRUdVUXdBQWtFR1VremdDU0NBRElBTXFBa3dpT0NBNFE3NDNoamlVUXdBQW1FR1VRd0FBbUVHVWt6Z0NUQ0FESUFNcUFsQWlPQ0E0UTc0M2hqaVVRd0FBb0VHVVF3QUFvRUdVa3pnQ1VDQURJQU1xQWxRaU9DQTRRNzQzaGppVVF3QUFxRUdVUXdBQXFFR1VremdDVkNBRElBTXFBbGdpT0NBNFE3NDNoamlVUXdBQXNFR1VRd0FBc0VHVWt6Z0NXQ0FESUFNcUFsd2lPQ0E0UTc0M2hqaVVRd0FBdUVHVVF3QUF1RUdVa3pnQ1hDQURJQU1xQW1BaU9DQTRRNzQzaGppVVF3QUF3RUdVUXdBQXdFR1VremdDWUNBTUlBcEJHR3dpQlVFQ2RHb2dBMEVZRURZTElCUWdEQ0FGUVFKMGFpSTNJQmNnQnlBQUtBSWtFRm9nRkNBWElBMFFCQnBEQUFDQVB5RTRRUUFoQlVNQUFJQS9JVHNnQWtFQlRnUkFBMEFnT0NBUElBVWdHbXBCQW5ScUtnSUFJamdnT0pTU0lUZ2dPeUFQSUFVZ0cycEJBblJxS2dJQUlqa2dPWlNTSVRzZ0JVRUJhaUlGSUJsSERRQUxDeUFFSUFRZ0FVRUNkR29nRmhBT0lRUkRBQUFBQUNFNlF3QUFBQUFoT1NBSVFRRklJaEJGQkVBZ1BDQTdJRGdnT0NBN1hoc2dPSldSSWp1VUlUaEJBQ0VHUVFBaEJRTkFJQVFnQmlBT2FrRUNkR29nT0NBN0lEaVVJQUlnQlVvaUdCc2lPQ0FQSUFWQkFDQUNJQmdiYXlJRklCMXFJaGhCQW5ScUtnSUFsRGdDQUNBRlFRRnFJUVVnT1NBWUlBRnJRUUowSUFScVFZQWdhaW9DQUNJNUlEbVVraUU1SUFaQkFXb2lCaUFJUncwQUN3c2dBeUFFSUI5cUtnSUFPQUlBSUFNZ0JDQWdhaW9DQURnQ0JDQURJQVFnSVdvcUFnQTRBZ2dnQXlBRUlDSnFLZ0lBT0FJTUlBTWdCQ0FqYWlvQ0FEZ0NFQ0FESUFRZ0pHb3FBZ0E0QWhRZ0F5QUVJQ1ZxS2dJQU9BSVlJQU1nQkNBbWFpb0NBRGdDSENBRElBUWdKMm9xQWdBNEFpQWdBeUFFSUNocUtnSUFPQUlrSUFNZ0JDQXBhaW9DQURnQ0tDQURJQVFnS21vcUFnQTRBaXdnQXlBRUlDdHFLZ0lBT0FJd0lBTWdCQ0FzYWlvQ0FEZ0NOQ0FESUFRZ0xXb3FBZ0E0QWpnZ0F5QUVJQzVxS2dJQU9BSThJQU1nQkNBdmFpb0NBRGdDUUNBRElBUWdNR29xQWdBNEFrUWdBeUFFSURGcUtnSUFPQUpJSUFNZ0JDQXlhaW9DQURnQ1RDQURJQVFnTTJvcUFnQTRBbEFnQXlBRUlEUnFLZ0lBT0FKVUlBTWdCQ0ExYWlvQ0FEZ0NXQ0FESUFRZ05tb3FBZ0E0QWx3Z0JFR0FRR3NpQlNBUlFRSjBhaUlHSURjZ0JpQUlJQU1nQUNnQ0pCQlpRUUFoQmdKQUFrQWdFRVVFUUFOQUlEb2dCQ0FHSUE1cVFRSjBhaW9DQUNJNElEaVVraUU2SUFaQkFXb2lCaUFJUncwQUN5QTVJRHBEemN4TVBwUmVEUUVnRUEwQ0lBUWdGbXBCQUNBZUVBVWFEQUlMSURsREFBQUFBRjVGRFFFTElEa2dPbDFCQVhNTkFDQTVRd0FBZ0QrU0lEcERBQUNBUDVLVmtTRTRJQWxCQVU0RVFFTUFBSUEvSURpVElUbEJBQ0VHQTBBZ0JDQUdJQTVxUVFKMGFpSVFJQkFxQWdCREFBQ0FQeUE1SUFzZ0JrRUNkR29xQWdDVWs1UTRBZ0FnQmtFQmFpSUdJQWxIRFFBTEN5QUpJUVlnQVVFQVRBMEFBMEFnQkNBR0lBNXFRUUowYWlJUUlEZ2dFQ29DQUpRNEFnQWdCa0VCYWlJR0lBaElEUUFMQzBFQUlRWWdFaUFGSUFBb0Fqd2lCU0FGSUFrZ0FDb0NSSXdpT0NBNElBQW9Ba3dpQlNBRlFRQkJBQ0FBS0FJa0VCa2dDVUVDVGdSQUEwQWdCa0VDZENJRklBUnFRWUJBYXlBRklBdHFLZ0lBSUJJZ0NTQUdRWDl6YWtFQ2RDSVFhaW9DQUpRZ0N5QVFhaW9DQUNBRklCSnFLZ0lBbEpJNEFnQWdCa0VCYWlJR0lCeEhEUUFMQ3lBS1FRRnFJZ29nRlVjTkFBc0xJQUFnRTBFQmFqWUNOQ0FEUWVBaGFpUUFDNjBCQVFGL0FrQWdBa0VDVFFSL0lBQU5BVUY1QlVGL0N3OExJQUJCQUVHZ1BTZ0NBRUVDZEVIZ3dBQnFJQUpzUWFROUtBSUFRUVYwYWtIY0FHb1FCU0lBUVp3OU5nSUFRYUE5S0FJQUlRTWdBRUlCTndJUUlBQWdBallDRENBQUlBSTJBZ2dnQUNBRE5nSUVRYWc5S0FJQUlRTWdBRUVCTmdJY0lBQWdBa0VCUmpZQ0lDQUFRUUEyQWlRZ0FDQUROZ0lZSUFCQnZCOUJBQkFIR2lBQUlBRVFYeUlBTmdJUVFRQkJmeUFBR3d2YkFRRUdmd0pBSUFFZ0FCQ2NBU0lIU3dSQUlBRWhCZ3dCQzBFQklRWUNRQUpBUVlDQUFTQUNhMEhnL3dFZ0FXdHNRUTkySWdWRkJFQWdBU0VFUVFFaEF3d0JDMEVCSVFNRFFDQUZRUUZxSWdWQkFYUWlDQ0FCYWlJRUlBZExCRUFnQlNFR0RBTUxJQU5CQVdvaEF5QUVJUUVnQ0VFQ2F5QUNiRUVQZGlJRkRRQUxDeUFISUFScklnSkJmbkVnQkdvaEFTQUNRUUYySUFOcUlRTUxRUUFnQTJzZ0F5QUhJQUVnQm1vaUFra2lCUnNoQkNBQklBSWdCUnNoQXdzZ0FDQURJQU1nQm1vaUFFR0FnQUlnQUVHQWdBSkpHMEdBZ0FJUU1TQUVDNFVCQVFkL0lBQW9BZ2dpQlVFQlRnUkFJQU1nQWtFQmRHcEJBV3NoQnlBQUtBSm9JUWdnQUNnQ0lDSUpMd0VBSVFZRFFDQUdRUkIwSVFvZ0FTQUVRUUowYWlBSUlBVWdCMndnQkdwcUxRQUFRVUJySUFrZ0JFRUJhaUlFUVFGMGFpNEJBQ0lHSUFwQkVIVnJJQUowSUFOc2JFRUNkVFlDQUNBRUlBQW9BZ2dpQlVnTkFBc0xDMU1BQW44Q1FBSkFJQUJCLy93QVRBUkFJQUJCd0Q1R0RRRWdBRUhnM1FCSERRSkJCQThMSUFCQmdQMEFSd1JBUVFFZ0FFR0E5d0pHRFFNYUlBQkJ3THNCUncwQ1FRSVBDMEVERHd0QkJnOExRUUFMQzRRQ0FRWi9Jd0FpQkNFSElBUWdBU0FDYkNJSVFRSjBRUTlxUVhCeGF5SUZKQUFDUUNBRFJRUkFJQUpCQVVnTkFTQUJRUUZJRFFGQkFDRUVBMEFnQVNBRWJDRUdRUUFoQXdOQUlBVWdBaUFEYkNBRWFrRUNkR29nQUNBRElBWnFRUUowYWlvQ0FEZ0NBQ0FEUVFGcUlnTWdBVWNOQUFzZ0JFRUJhaUlFSUFKSERRQUxEQUVMSUFKQkFVZ05BQ0FCUVFGSURRQWdBa0VDZEVIb09Xb2hCa0VBSVFRRFFDQUdJQVJCQW5ScUtBSUFJQUZzSVFsQkFDRURBMEFnQlNBQ0lBTnNJQVJxUVFKMGFpQUFJQU1nQ1dwQkFuUnFLZ0lBT0FJQUlBTkJBV29pQXlBQlJ3MEFDeUFFUVFGcUlnUWdBa2NOQUFzTElBQWdCU0FJUVFKMEVBUWFJQWNrQUF2Y0dBTk1md0YrQlgwakFFR2dER3NpRlNFVUlCVWtBQ0FWUVFKQkFTQUVHeUlwSUFBb0FpQWlJU0FBS0FJSVFRRjBha0VDYXk0QkFDQWhJQUZCQVhScUlqc3VBUUFpS21zZ0QzUnNRUUowUVE5cVFYQnhheUlhSWhZa0FDQWhJQUFvQWdoQkFYUnFRUUpyTGdFQUlBOTBRUUowSWhzZ0Eyb2hIQ0FXUVJCcklqd2lGU1FBSUJWQkVHc2lQU0lWSkFBZ0ZVRVFheUkrSWhVa0FDQVZRUkJySWo4aUZTUUFJQlZCRUdzaU1TUUFJQlFnRGpZQy9Bc2dGRUVBTmdLRURDQVVJQW8yQXZBTElCUkJBRFlDNEFzZ0ZDQUFOZ0xvQ3lBUktBSUFJUlVnRkNBVE5nS1VEQ0FVSUJJMkFvd01JQlFnQ0RZQzlBc2dGQ0FWTmdLSURDQVVRUUVnRDNSQkFTQUhHeUlmUVFGS0lnYzJBcGdNSUJSQkFEWUNrQXdnRkVFQk5nTGtDeUFSSUFFZ0FrZ0VmeUFhUVFBZ0JCc2hRQ0FJUVFOSElBZHlJVUVnS1VFQmF5RXlJQUZCQW1vaE15QUJRUUZxSVNnZ0FrRUJheUUwSUJvZ0cyb2dLaUFQZENJMVFRSjBheUlsUVFBZ05XdEJBblFpQjJvaFFpQUhJQnBxSVNKQmZ5QWZkRUYvY3lFVElBRWhDRUVBSVJ0QkFTRVNBMEFnRkNBSUloVTJBdXdMSUNFZ0ZVRUJkR29pSFM0QkFDRUhJQ0VnRlVFQmFpSUlRUUYwYWk0QkFDRVdJQlFnRENBT0VBc2lObXNpRVVFQmF6WUNnQXdnQnlBUGRDRVhJQTFCQUNBMklBRWdGVVliYXlFM0FuOUJBQ0FRSUJWTURRQWFRZi8vQUNBUklBWWdGVUVDZEdvb0FnQWdOeUFRSUJWcklnMUJBeUFOUVFOSUcyMXFJZzBnRFNBUlNoc2lEVUgvL3dCS0RRQWFJQTFCQUNBTlFRQktHd3NoSkNBWFFRSjBJUTBnRmlBSGF5RUhBa0FnRlNBb1J3UkFJQjB1QVFBZ0Iyc2dEM1FnT3k0QkFDQVBkRWdOQVFzZ0ZTQWJJQlVnR3hzZ0Voc2hHd3NnQkNBTmFpRVdBa0FnRlNBb1J5SkREUUFnR2lBQUtBSWdJaEVnS0VFQmRHb3VBUUFpRnlBUklBRkJBWFJxTGdFQWF5QVBkQ0lTUVFKMElobHFJQm9nRWtFQmRDQVJJRE5CQVhScUxnRUFJQmRySUE5MEloRnJRUUowSWhkcUlCRWdFbXRCQW5RaUVSQUVHaUFKUlEwQUlCa2dKV29nRnlBbGFpQVJFQVFhQ3lBV1FRQWdCQnNoSUNBRElBMXFJU01nQnlBUGRDRVhJQlFnQ3lBVlFRSjBJamhxS0FJQUloSTJBdmdMUVFBZ0hFRUFJQlVnQUNnQ0RFZ2lHQnNpSENBVklEUkdJaDRiSVNaQmZ5RVpBa0FnRzBVRVFDQVRJaEVoRFF3QkN5QVRJaEVoRFNCQklCSkJBRWh5UlEwQUlDRWdHMEVCZEdvdUFRQWdCeUFxYW1zZ0QzUWlCMEVBSUFkQkFFb2JJaGtnTldvaERTQWJJUWNEUUNBaElBY2lFa0VCYXlJSFFRRjBhaTRCQUNBUGRDQU5TZzBBQ3lBTklCZHFJU2NnRzBFQmF5RVdJQnNnRlNBVklCdElHMEVCYXlFUkEwQUNRQ0FSSUJZaURVWUVRQ0FSSVEwTUFRc2dJU0FOUVFGcUloWkJBWFJxTGdFQUlBOTBJQ2RJRFFFTEN5QUhJQTBnRFNBU1NCc2hFa0VBSVJGQkFDRU5BMEFnRVNBRklBY2dLV3dpRm1vdEFBQnlJUkVnRFNBRklCWWdNbXBxTFFBQWNpRU5JQWNnRWtjaEZpQUhRUUZxSVFjZ0ZnMEFDd3NnSmlFY0lDTWdHaUFZR3lFU0lDQWdRQ0FZR3lFWUFuOENRQ0FKUlEwQUlBb2dGVVlFUUVFQUlRY2dIUzRCQUNBcWF5QVBkQ0lKUVFGSURRRURRQ0FhSUFkQkFuUWlGbW9pSUNBZ0tnSUFJQllnSldvcUFnQ1NRd0FBQUQrVU9BSUFJQWRCQVdvaUJ5QUpSdzBBQ3d3QkN5QUtJQlZHRFFCQkFDQWFJQmxCQW5RaUIyb2dHVUYvUmlJV0d5RWVJQlJCNEF0cUlCZ2dGeUFrUVFGMkloZ2dId0ovSUJVZ05FWUVRRUVBSVJrZ0ZFSGdDMm9nRWlBWElCZ2dIeUFlSUE5QkFFTUFBSUEvSUJ3Z0VSQUtJUkZCQUNBSElDVnFJQlliREFFTElCUkI0QXRxSUJJZ0Z5QVlJQjhnSGlBUElDSWdIUzRCQUNBUGRFRUNkR3BEQUFDQVB5QWNJQkVRQ2lFUklFSWdIUzRCQUNBUGRFRUNkR29oR1VFQUlBY2dKV29nRmhzTElBOGdHVU1BQUlBL0lCd2dEUkFLREFFTEFrQWdHQVJBUVFGRkJFQWdPQ29DQUNGa0lBQW9BZ2dnRldwQkFuUXFBZ0FoWXlBT0tBSUVJVGtnRGlnQ0FDRTZJQlJCMkF0cUlrUWdEaWtDRURjREFDQVVJQTRwQWdnM0E5QUxJQTRvQWhnaEl5QVVRY2dMYWlKRklBNG9BaXcyQWdBZ0ZFSEFDMm9pUmlBT0tRSWtOd01BSUJRZ0Rpa0NIRGNEdUFzZ0ZFR0FDMm9pUnlBVVFaZ01haUltS0FJQU5nSUFJQlJCK0FwcUlrZ2dGRUdRREdvaUlDa0RBRGNEQUNBVVFmQUthaUpKSUJSQmlBeHFJaWNwQXdBM0F3QWdGRUhvQ21vaVNpQVVRWUFNYWlJcktRTUFOd01BSUJSQjRBcHFJa3NnRkVINEMyb2lMQ2tEQURjREFDQVVRZGdLYWlKTUlCUkI4QXRxSWkwcEF3QTNBd0FnRkVIUUNtb2lUU0FVUWVnTGFpSXVLUU1BTndNQUlCUWdGQ2tENEFzM0E4Z0tJRHdnRWlBWFFRSjBJaFlRQkNFdklEMGdHQ0FXRUFRaE1DQWdRWDgyQWdCQkFDRUhJQTBnRVhJaEVVTUFBQUFBSVdFZ0ZFSGdDMm9nRWlBWUlCY2dKQ0FmUVFBZ0dpQVpRUUowYWlBWlFYOUdHeUpPSUE4Z0hnUi9RUUFGSUNJZ0hTNEJBQ0FQZEVFQ2RHb0xJQndnRVJBa0lRbERBQUFBQUNGaUlCZEJBVWdpVDBVRVFBTkFJR0lnTHlBSFFRSjBJZzFxS2dJQUlBMGdFbW9xQWdDVWtpRmlJQWRCQVdvaUJ5QVhSdzBBQzBFQUlRY0RRQ0JoSURBZ0IwRUNkQ0lOYWlvQ0FDQU5JQmhxS2dJQWxKSWhZU0FIUVFGcUlnY2dGMGNOQUFzTElCUkJzQXRxSWxBZ0Rpa0NLRGNEQUNBVVFhZ0xhaUpSSUE0cEFpQTNBd0FnRkVHZ0Myb2lVaUFPS1FJWU53TUFJQlJCbUF0cUlsTWdEaWtDRURjREFDQVVRWkFMYWlKVUlBNHBBZ2czQXdBZ0Rpa0NBQ0ZnSUJSQmtBcHFJbFVnTGlrREFEY0RBQ0FVUVpnS2FpSldJQzBwQXdBM0F3QWdGRUdnQ21vaVZ5QXNLUU1BTndNQUlCUkJxQXBxSWxnZ0t5a0RBRGNEQUNBVVFiQUthaUpaSUNjcEF3QTNBd0FnRkVHNENtb2lXaUFnS1FNQU53TUFJQlJCd0FwcUlsc2dKaWdDQURZQ0FDQVVJR0EzQTRnTElCUWdGQ2tENEFzM0E0Z0tJRDRnRWlBV0VBUWhYQ0EvSUJnZ0ZoQUVJVjBnSGtVRVFDQXhJQ0lnSFM0QkFDQVBkRUVDZEdvZ0ZoQUVHZ3NnRkNBaklEcHFJbDRnT1NBamF5SmZFQVFoRFNBT0lEazJBZ1FnRGlBNk5nSUFJQTRnUkNrREFEY0NFQ0FPSUEwcEE5QUxOd0lJSUE0Z0l6WUNHQ0FPSUVVb0FnQTJBaXdnRGlCR0tRTUFOd0lrSUE0Z0RTa0R1QXMzQWh3Z0xpQk5LUU1BTndNQUlDMGdUQ2tEQURjREFDQXNJRXNwQXdBM0F3QWdLeUJLS1FNQU53TUFJQ2NnU1NrREFEY0RBQ0FnSUVncEF3QTNBd0FnSmlCSEtBSUFOZ0lBSUEwZ0RTa0R5QW8zQStBTElCSWdMeUFXRUFRaEVpQVlJREFnRmhBRUlSa2dRMFVFUUNBYUlBQW9BaUFpQnlBb1FRRjBhaTRCQUNJaklBY2dBVUVCZEdvdUFRQnJJQTkwSWhoQkFuUnFJQm9nR0VFQmRDQUhJRE5CQVhScUxnRUFJQ05ySUE5MElnZHJRUUowYWlBSElCaHJRUUowRUFRYUN5QU5RUUUyQXBBTVFRQWhCeUJqSUdRZ1l5QmpJR1JlRzBNQUFFQkFsU0psa2lGaklHUWdaWklpWkNCaWxDQmpJR0dVa2lGbFF3QUFBQUFoWVNBTlFlQUxhaUFTSUJrZ0Z5QWtJQjhnVGlBUElCNEVmMEVBQlNBaUlCMHVBUUFnRDNSQkFuUnFDeUFjSUJFUUpDRVJRd0FBQUFBaFlpQlBSUVJBQTBBZ1lpQXZJQWRCQW5RaUdHb3FBZ0FnRWlBWWFpb0NBSlNTSVdJZ0IwRUJhaUlISUJkSERRQUxRUUFoQndOQUlHRWdNQ0FIUVFKMEloaHFLZ0lBSUJnZ0dXb3FBZ0NVa2lGaElBZEJBV29pQnlBWFJ3MEFDd3NnWlNCa0lHS1VJR01nWVpTU1lFRUJjMFVFUUNBT0lBMHBBNGdMTndJQUlBNGdVQ2tEQURjQ0tDQU9JRkVwQXdBM0FpQWdEaUJTS1FNQU53SVlJQTRnVXlrREFEY0NFQ0FPSUZRcEF3QTNBZ2dnTGlCVktRTUFOd01BSUMwZ1Zpa0RBRGNEQUNBc0lGY3BBd0EzQXdBZ0t5QllLUU1BTndNQUlDY2dXU2tEQURjREFDQWdJRm9wQXdBM0F3QWdKaUJiS0FJQU5nSUFJQTBnRFNrRGlBbzNBK0FMSUJJZ1hDQVdFQVFhSUJrZ1hTQVdFQVFhSUI1RkJFQWdJaUFkTGdFQUlBOTBRUUowYWlBeElCWVFCQm9MSUY0Z0RTQmZFQVFhSUFraEVRdEJBQ0VKREFJTFFRQWhDU0FVUVFBMkFwQU1JQlJCNEF0cUlCSWdHQ0FYSUNRZ0gwRUFJQm9nR1VFQ2RHb2dHVUYvUmhzZ0R5QWVCSDlCQUFVZ0lpQWRMZ0VBSUE5MFFRSjBhZ3NnSENBTklCRnlFQ1FoRVF3QkMwRUFJUWtnRkVIZ0Myb2dFaUFYSUNRZ0gwRUFJQm9nR1VFQ2RHb2dHVUYvUmhzZ0R5QWVCSDlCQUFVZ0lpQWRMZ0VBSUE5MFFRSjBhZ3REQUFDQVB5QWNJQTBnRVhJUUNpRVJDeUFSQ3lFSElBVWdGU0FwYkNJTmFpQVJPZ0FBSUFVZ0RTQXlhbW9nQnpvQUFDQUdJRGhxS0FJQUlRY2dGRUVBTmdLWURDQUhJRFlnTjJwcUlRMGdKQ0FYUVFOMFNpRVNJQUlnQ0VjTkFBc2dGQ2dDaUF3RklCVUxOZ0lBSUJSQm9BeHFKQUFMQkFCQkFBdldCQU1QZndWOUFYd2dCaUFIU0FSQVFRRWdBM1FpRUVFQklCQkJBVW9iSVJRZ0JFRUJJQVJCQVVvYklSY2dBMEVEUmlFWUlBTkJIMFloR1FOQVF3QUFnRDhnQUNnQ0lDSU9JQVlpRUVFQmFpSUdRUUYwYWk0QkFDQU9JQkJCQVhRaUdtb3VBUUJySWhNZ0EzUWlHN2VmdHBVaElTQUxJQkJCQW5ScUtBSUFRUUZxSUJOdUlBTjJza01BQUFDK2xMdEU3em42L2tJdTVqK2lFQisyUXdBQUFEK1VJU0FnQkNBUWJDRWNRUUFoRWdOQUlBb2dBQ2dDQ0NJUElCSnNJQkJxUVFKMElnNXFLZ0lBSVIwZ0NTQU9haW9DQUNFZUlBZ2dEbW9xQWdBQ2ZTQUVRUUZHQkVBZ0hTQUtJQThnRUdwQkFuUWlEMm9xQWdBaUh5QWRJQjllR3lFZElCNGdDU0FQYWlvQ0FDSWZJQjRnSDE0YklSNExJQjRMSUIwZ0hTQWVYaHVUUXdBQUFBQ1h1MFR2T2ZyK1FpN212NklRSHlFaUFrQWdHUTBBSUFFZ0JTQVNiRUVDZEdvZ0FDZ0NJQ0FhYWk0QkFDQURkRUVDZEdvaEZTQUNJQklnSEdwcUlSWkJBQ0VQQWtBZ0UwRUFTZ1JBSUNFZ0lDQWl0aUlkSUIyU0loMUQ4d1MxUDVRZ0hTQVlHeUlkSUIwZ0lGNGJsQ0lkakNFZVFRQWhFUU5BUVFBaERpQVdMUUFBSUJGMlFRRnhSUVJBQTBBZ0ZTQU9JQU4wSUJGcVFRSjBhaUFkSUI0Z0RFR056T1VBYkVIZjVydmpBMm9pREVHQWdBSnhHemdDQUVFQklROGdEa0VCYWlJT0lCTkhEUUFMQ3lBUlFRRnFJaEVnRkVjTkFBc01BUXNnRmkwQUFDRVJRUUFoRGdOQUlBOUJBU0FSSUE1MlFRRnhHeUVQSUE1QkFXb2lEaUFVUncwQUN3c2dEMFVOQUNBVklCdERBQUNBUHlBTkVDNExJQkpCQVdvaUVpQVhSdzBBQ3lBR0lBZEhEUUFMQ3d1N0JRRUxmeUFCSUFBb0FRUTJBUUFnQWlBQUtBRUlOZ0VBSUFBZ0FTQUZRUUYwSWdacUtBRUFOZ0VFSUFBZ0FpQUdhaWdCQURZQkNFR0FnQVFnQkVFRGRDSUdiU0VISUFNb0FnUWhDaUFES0FJQUlRc2dCRUVCVGdSQUlBZEJFSFJCRUhVaUF5QUtJQUF2QVFJaUIydEJFSFJCRUhWc1FROTFRUUZxUVFGMUlRMGdBeUFMSUFBdkFRQWlDR3RCRUhSQkVIVnNRUTkxUVFGcVFRRjFJUTRnQmtFQklBWkJBVW9iSVE5QkFDRURBMEFnQWlBRFFRRnFJZ1JCQVhRaUNXb2lERUgvL3dFZ0J5QU5haUlIUVJCMFFSQjFJaEFnQVNBSmFpNEJBQ0lKUVFWMWJDQU1MZ0VBUVFoMGFpQUpRUXQwUVlEd0EzRWdFR3hCRUhWcUlBZ2dEbW9pQ0VFUWRFRVFkU0lNSUFFZ0EwRUJkR29pQXk0QkJDQURMZ0VBYWlBSlFRRjBhaUlEUVFkMWJHb2dBMEVKZEVHQS9BTnhJQXhzUVJCMWFpSURRUWQxUVFGcVFRRjFJZ2xCZ0lCK0lBbEJnSUIrU2hzZ0EwSC8vdjhEU2hzN0FRQWdCQ0lESUE5SERRQUxDeUFGSUFaS0JFQWdDa0VRZEVFUWRTRURJQXRCRUhSQkVIVWhCQU5BSUFaQkFYUWhDQ0FDSUFaQkFXb2lCa0VCZENJSGFpSUpRZi8vQVNBQklBZHFMZ0VBSWdkQkJYVWdBMndnQ1M0QkFFRUlkR29nQjBFTGRFR0E4QU54SUFOc1FSQjFhaUFCSUFocUlnZ3VBUVFnQ0M0QkFHb2dCMEVCZEdvaUIwRUhkU0FFYkdvZ0IwRUpkRUdBL0FOeElBUnNRUkIxYWlJSFFRZDFRUUZxUVFGMUlnaEJnSUIrSUFoQmdJQitTaHNnQjBILy92OERTaHM3QVFBZ0JTQUdSdzBBQ3dzZ0FDQUtPd0VDSUFBZ0N6c0JBQ0FGUVFGT0JFQkJBQ0VHQTBBZ0FTQUdRUUZxSWdaQkFYUWlBR29pQXlBRExnRUFJZ01nQUNBQ2FpSUFMZ0VBSWdScUlncEIvLzhCSUFwQi8vOEJTQnNpQ2tHQWdINGdDa0dBZ0g1S0d6c0JBQ0FBSUFNZ0JHc2lBRUgvL3dFZ0FFSC8vd0ZJR3lJQVFZQ0FmaUFBUVlDQWZrb2JPd0VBSUFVZ0JrY05BQXNMQzNvQkJYOGdBVUVDVGdSQVFRRWhBd05BSUFBZ0EwRUJkR291QVFBaEJTQURJUUlDUUFOQUlBVWdBQ0FDUVFGcklnWkJBWFJxTGdFQUlnUk9EUUVnQUNBQ1FRRjBhaUFFT3dFQUlBSkJBVW9oQkNBR0lRSWdCQTBBQzBFQUlRSUxJQUFnQWtFQmRHb2dCVHNCQUNBRFFRRnFJZ01nQVVjTkFBc0xDNGtIQVFSL0lBQUNmd0pBSUFKQkFVZ05BQ0FDSUFFZ0FrR0FPV290QUFCQjREZHFRUWdRQXlJQ2F5RUZJQUpCRUhRaUFrRUJTQVJBREFFTElBSkJFSFVpQWlBQklBSkJnRGxxTFFBQVFjQTJha0VJRUFNaUFtc2hBeUFDUVJCMElnSkJBRXdOQUNBQ1FSQjFJZ0lnQVNBQ1FZQTVhaTBBQUVHZ05XcEJDQkFESWdKcklRUWdBa0VRZEVFQlNBMEFJQUFnQVNBQ1FmLy9BM0ZCZ0RscUxRQUFRWUEwYWtFSUVBTWlCanNCQUNBQ0lBWnJEQUVMSUFCQkFEc0JBRUVBQ3pzQkFpQUFBbjhnQkVFUWRFRUJUZ1JBSUFBZ0FTQUVRZi8vQTNGQmdEbHFMUUFBUVlBMGFrRUlFQU1pQWpzQkJDQUVJQUpyREFFTElBQkJBRHNCQkVFQUN6c0JCa0VBSVFRZ0FBSi9Ba0FnQTBFUWRDSUNRUUJNQkVBZ0FFRUlhaUVEREFFTElBQkJDR29oQXlBQ1FSQjFJZ0lnQVNBQ1FZQTVhaTBBQUVHZ05XcEJDQkFESWdKcklRUWdBa0VRZEVFQlNBMEFJQUFnQVNBQ1FmLy9BM0ZCZ0RscUxRQUFRWUEwYWtFSUVBTWlBenNCQ0NBQ0lBTnJEQUVMSUFOQkFEc0JBRUVBQ3pzQkNpQUFBbjhnQkVFUWRFRUJUZ1JBSUFBZ0FTQUVRZi8vQTNGQmdEbHFMUUFBUVlBMGFrRUlFQU1pQWpzQkRDQUVJQUpyREFFTElBQkJBRHNCREVFQUN6c0JEa0VBSVFSQkFDRUNJQUFDZndKQUFrQWdCVUVRZENJRFFRRk9CRUFnQTBFUWRTSUNJQUVnQWtHQU9Xb3RBQUJCd0RacVFRZ1FBeUlEYXlFQ0lBTkJFSFFpQTBFQVNnMEJDeUFBUVJCcUlRVU1BUXNnQUVFUWFpRUZJQU5CRUhVaUJDQUJJQVJCZ0RscUxRQUFRYUExYWtFSUVBTWlBMnNoQkNBRFFSQjBRUUZJRFFBZ0FDQUJJQU5CLy84RGNVR0FPV290QUFCQmdEUnFRUWdRQXlJRk93RVFJQU1nQldzTUFRc2dCVUVBT3dFQVFRQUxPd0VTSUFBQ2Z5QUVRUkIwUVFGT0JFQWdBQ0FCSUFSQi8vOERjVUdBT1dvdEFBQkJnRFJxUVFnUUF5SURPd0VVSUFRZ0Eyc01BUXNnQUVFQU93RVVRUUFMT3dFV1FRQWhCQ0FBQW44Q1FDQUNRUkIwSWdKQkFFd0VRQ0FBUVJocUlRTU1BUXNnQUVFWWFpRURJQUpCRUhVaUFpQUJJQUpCZ0RscUxRQUFRYUExYWtFSUVBTWlBbXNoQkNBQ1FSQjBRUUZJRFFBZ0FDQUJJQUpCLy84RGNVR0FPV290QUFCQmdEUnFRUWdRQXlJRE93RVlJQUlnQTJzTUFRc2dBMEVBT3dFQVFRQUxPd0VhSUFSQkVIUkJBVTRFUUNBQUlBRWdCRUgvL3dOeFFZQTVhaTBBQUVHQU5HcEJDQkFESWdFN0FSd2dBQ0FFSUFGck93RWVEd3NnQUVFQU93RWNJQUJCQURzQkhndVZBUUVGZnlBRVFRRk9CRUFnQUNnQ0FDRUZJQU11QVFJaEJpQURMZ0VBSVFkQkFDRURBMEFnQVNBRFFRSjBhaUFDSUFOQkFYUnFMZ0VBUVFoMElBVnFJZ1UyQWdBZ0FDZ0NCQ0VJSUFBZ0JVRUNkQ0lGUWZ6L0EzRWlDU0FHYkVFUWRTQUZRUkIxSWdVZ0JteHFOZ0lFSUFBZ0NDQUZJQWRzYWlBSElBbHNRUkIxYWlJRk5nSUFJQU5CQVdvaUF5QUVSdzBBQ3dzTDZ3UUJCSDhDUUNBQVFRQkJyQUlRQlNJREFuOUJmeUVBQWtBZ0FVSEFQa1lOQUNBQlFZRDlBRVlOQUNBQlFlRGRBRWNOQWdzQ1FDQUNRZi84QUV3RVFDQUNRY0ErUmcwQklBSkI0TjBBUmcwQkRBTUxJQUpCZ1AwQVJnMEFJQUpCZ1BjQ1JnMEFJQUpCd0xzQlJ3MENDeUFCUVF4MlFRVnNJQUpCREhZZ0FrR0EvUUJLYXlBQ1FjQzdBVXAxYWtHeEMyb3NBQUFMTmdLa0FpQURJQUpCLy84RGNVSG9CMjQyQXFBQ0lBTWdBVUgvL3dOeFFlZ0hiaUlBTmdLY0FpQURJQUJCQ213MkFvd0NBa0FnQVNBQ1NBUkFRUUVoQUNBQ0lBRkJBWFJHQkVBZ0EwRUJOZ0tJQWtFQUlRQU1BZ3NnQTBFQ05nS0lBZ3dCQ3lBQklBSktCRUFnQTBFRE5nS0lBaUFDUVFKMElnQWdBVUVEYkVZRVFDQURRZEFMTmdLb0FpQURRcEtBZ0lBd053S1VBa0VBSVFBTUFnc2dBa0VEYkNJRUlBRkJBWFJHQkVBZ0EwR1FERFlDcUFJZ0EwS1NnSUNBSURjQ2xBSkJBQ0VBREFJTElBRWdBa0VCZEVZRVFDQURRY0FNTmdLb0FpQURRcGlBZ0lBUU53S1VBa0VBSVFBTUFnc2dBU0FFUmdSQUlBTkI0QXcyQXFnQ0lBTkNwSUNBZ0JBM0FwUUNRUUFoQUF3Q0N5QUFJQUZHQkVBZ0EwR1FEVFlDcUFJZ0EwS2tnSUNBRURjQ2xBSkJBQ0VBREFJTFFYOGhBQ0FDUVFac0lBRkhEUUlnQTBIQURUWUNxQUlnQTBLa2dJQ0FFRGNDbEFKQkFDRUFEQUVMUVFBaEFDQURRUUEyQW9nQ0N5QUJJQUIwSVFVZ0FrRVFkRUVRZFNFRUlBSkJEM1pCQVdwQkFYWWhCaUFCSUFCQkRuSjBJQUp0UVFKMElRSURRQ0FDSWdCQkFXb2hBaUFBUVJCMUlBUnNJQUFnQm14cUlBQkIvLzhEY1NBRWJFRVFkV29nQlVnTkFBc2dBeUFBTmdLUUFrRUFJUUFMSUFBTGN3RURmd0ovUVFBZ0FFRUFTQTBBR2tILy8vLy9CeUFBUWY0ZVNnMEFHaUFBUWY4QWNTRUJRUUVnQUVFSGRpSURkQ0VDSUFCQi93OU1CSDhnQVVHQUFTQUJhMnhCMG41c1FSQjFJQUZxSUFOMFFRZDFCU0FCUVlBQklBRnJiRUhTZm14QkVIVWdBV29nQWtFSGRtd0xJQUpxQ3d2SUFRRUVmeUFFUVFGT0JFQURRQ0FDQW44Z0F5QUdja1VFUUNBQkxBQUFJZ1VnQWl3QUFFRVFheUlISUFVZ0Iwb2JEQUVMSUFFZ0Jtb3NBQUJCQkdzaUJTQUNMQUFBSWdkQkNHb2lDRW9FUUNBSElBVkJBWFFnQ0d0cURBRUxJQVVnQjJvTElnVkJBQ0FGUVJoMFFSaDFRUUJLR3lJRlFUOGdCVUVZZEVFWWRVRS9TQnNpQlRvQUFDQUFJQVpCQW5ScUlBVkIvd0Z4SWdWQjhUaHNRUkIySUFWQkhXeHFJZ1ZCMVE0Z0JVSFZEa2tiUWFvUWFoQnBOZ0lBSUFaQkFXb2lCaUFFUncwQUN3c0wxQUlCQkg4Z0FDQUJRUkIwUVJCMUlnTkJCV3cyQXB3U0lBQXVBWlFTSUFOQmdJQVViRUVRZFd3aEJBSkFBa0FDUUNBQklBQW9Bb3dTUmdSQUlBQW9BcEFTSUFKR0RRRUxJQUJCZ0JOcUlBTkI2QWRzSUFJUWFDRUZJQUFnQWpZQ2tCSWdBQ2dDakJJZ0FVY05BUXRCQVNFR0lBUWdBQ2dDbUJKR0RRRUxJQUJCZ2pKQm1USWdBQ2dDbEJKQkJFWWlBaHRCNERGQmpUSWdBaHNnQVVFSVJoczJBdEFTSUFaRkJFQWdBQ0FEUVJSc05nS2dFaUFBUWNnZVFaUXZJQUZCZTNGQkNFWWlBaHMyQXF3VklBQkJDa0VRSUFJYk5nS2tFa0dRTVNFQ0FrQUNRQUpBQWtBZ0FVRU1hdzRGQUFFQkFRSUJDMEdLTVNFQ0RBRUxRWUV4SVFJZ0FVRUlSdzBCQ3lBQUlBSTJBc3dTQ3lBQVFRQTJBc1FnSUFCQkNqb0FpQklnQUVIa0FEWUNoQklnQUVFQk5nTElFaUFBUVlRS2FrRUFRWUFJRUFVYUN5QUFJQVEyQXBnU0lBQWdBVFlDakJJTElBVUxSZ0VDZnlNQVFSQnJJZ0VrQUFKQUlBQkZEUUJCbVBzQktBSUFJZ0pGQkVBZ0FTQUFOZ0lBUWVzSUlBRVFIZ3dCQzBHWSt3RWdBaUFBRUQ4MkFnQUxJQUZCRUdva0FBdmtBUUVGZndKQUlBUkJBVWdOQUVId0NVSEVDU0FFUVFSR0lnVWJRYUFLUWRBSklBVWJJQU5CQ0VZaUJ4c2hDRUVMUVFNZ0JSdEJJa0VNSUFVYklBY2JJUWNnQTBFUWRDSUZRUTkxSWdNZ0FHb2hDVUVBSVFBZ0JVRVFkVUVTYkNJRklBTklCRUFEUUNBQ0lBQkJBblJxSUFNZ0JTQUpJQWdnQUNBSGJDQUJhbW9zQUFCcUlnWWdCU0FHU2hzZ0F5QUdTQnMyQWdBZ0FFRUJhaUlBSUFSSERRQU1BZ3NBQ3dOQUlBSWdBRUVDZEdvZ0JTQURJQWtnQ0NBQUlBZHNJQUZxYWl3QUFHb2lCaUFESUFaS0d5QUZJQVpJR3pZQ0FDQUFRUUZxSWdBZ0JFY05BQXNMQzhnRUFRZC9Jd0JCUUdvaUJDUUFJQUZCRUdvZ0FFR3dGV29nQUVHSUVtb2dBa0VDUmlBQUtBS1VFaEJxSUFSQklHb2dBRUc0RldvZ0FDZ0NyQlVRZGlBQlFVQnJJZ1VnQkVFZ2FpQUFLQUtrRWlBQUtBTElJQkFySUFGQklHb2hBd0pBQWtBZ0FDZ0N5QkpCQVVZRVFDQUFRUVE2QU04VkRBRUxJQUFzQU04VklnaEJBMG9OQUNBQUtBS2tFaUlHUVFGT0JFQkJBQ0VDQTBBZ0JDQUNRUUYwSWdkcUlBQWdCMnBCcUJKcUxnRUFJZ2tnQkVFZ2FpQUhhaTRCQUNBSmF5QUliRUVDZG1vN0FRQWdBa0VCYWlJQ0lBWkhEUUFMQ3lBRElBUWdCaUFBS0FMSUlCQXJEQUVMSUFNZ0JTQUFLQUtrRWtFQmRCQUVHZ3NnQUVHb0Vtb2dCRUVnYWlBQUtBS2tFaUlDUVFGMEVBUWFJQUFvQXNBZ0JFQWdBeUFDUWRMd0F4QXFJQVVnQUNnQ3BCSkIwdkFERUNvTElBRUNmeUFBUWMwVmFpMEFBRUVDUmdSQUlBQkJ5aFZxTGdFQUlBQkJ6QlZxTEFBQUlBRWdBQ2dDakJJZ0FDZ0NsQklRYlNBQUtBS1VFaUlHUVFGT0JFQWdBRUhRRldvc0FBQkJBblJCd0JOcUtBSUFJUWRCQUNFQ0EwQWdBU0FDUVFwc2FpSURJQWNnQUNBQ2FrRzBGV29zQUFCQkJXeHFJZ1VzQUFCQkIzUTdBV0FnQXlBRkxBQUJRUWQwT3dGaUlBTWdCU3dBQWtFSGREc0JaQ0FESUFVc0FBTkJCM1E3QVdZZ0F5QUZMQUFFUVFkME93Rm9JQUpCQVdvaUFpQUdSdzBBQ3dzZ0FFSFJGV29zQUFCQkFYUkIrREJxTGdFQURBRUxJQUZCQUNBQUtBS1VFa0VDZEJBRlFlQUFha0VBSUFBb0FwUVNRUXBzRUFVYUlBQkIwQlZxUVFBNkFBQkJBQXMyQW9nQklBUkJRR3NrQUF2M0d3RW9meU1BUVNCcklnUWhGaUFFSkFBZ0JDQUFLQUtnRWtFQmRFRVBha0Z3Y1dzaUZ5SUVKQUFnQkNBQUtBS1lFaUlFSUFBb0FxQVNha0VDZEVFUGFrRndjV3NpRWlJS0pBQWdDaUFBS0FLY0VrRUNkQ0lLUVE5cVFYQnhheUlZSWdZa0FDQUdJQXBCendCcVFYQnhheUlGSkFBZ0FFSFBGV29zQUFBaEVTQUVRUUZPQkVBZ0FDd0F6UlZCQVhSQmZIRkI4REJxSUFCQnpoVnFMQUFBUVFGMGFpNEJBRUVFZENFTUlBQkIwaFZxTEFBQUlRWURRQ0FBSUFkQkFuUnFJZ29nQXlBSFFRRjBhaTRCQUNJRVFRNTBJZ2cyQWdRZ0JrRzFpTTdkQUd4QjY4YmxzQU5xSVFZQ1FDQUtJQVJCQVU0RWZ5QUlRWUFLYXdVZ0JFRi9TZzBCSUFoQmdBcHlDeUlJTmdJRUN5QUtRUUFnQ0NBTWFpSUtheUFLSUFaQkFFZ2JOZ0lFSUFRZ0Jtb2hCaUFIUVFGcUlnY2dBQ2dDbUJKSURRQUxDeUFGSUFBcEFvUUtOd0lBSUFVZ0FFRzhDbW9wQWdBM0FqZ2dCU0FBUWJRS2Fpa0NBRGNDTUNBRklBQkJyQXBxS1FJQU53SW9JQVVnQUVHa0Ntb3BBZ0EzQWlBZ0JTQUFRWndLYWlrQ0FEY0NHQ0FGSUFCQmxBcHFLUUlBTndJUUlBVWdBRUdNQ21vcEFnQTNBZ2dnQUNnQ2xCSkJBVTRFUUNBQVFRUnFJUk1nQUNnQ29CSWhFQ0FSUVFSSUlTWWdBaUVSQTBBZ0ZpQUJJQTVCQkhSQllIRnFRU0JxSWcwZ0FDZ0NwQkpCQVhRUUJDRU1RUUFnQVNBT1FRSjBhaUlJS0FJUUlnOGdEeUFQUVI5MUlnTnFJQU56SWdwbklnWkJBV3QwSWdsQi8vOERjVUgvLy8vL0FTQUpRUkIxSWdSdElnZEJFSFFpQzBFUWRTSURiRUVRZFNBRElBUnNha0VEZEdzaUJDQUhRUTkxUVFGcVFRRjFiQ0FMYWlBRVFSQjFJQU5zYWlBRVFmai9BM0VnQTJ4QkVIVnFJUVFDZnlBS1FmLy9CMDBFUUVILy8vLy9CeUFHUVE5cklncDJJZ2RCZ0lDQWdIZ2dDblVpQ3lBRUlBUWdDMGdiSUFRZ0Iwb2JJQXAwREFFTElBUkJEeUFHYTNVTElRb2dBQzBBelJVaEMwR0FnQVFoQnlBQUtBSUFJZ1FnRDBjRVFDQUVJQVFnQkVFZmRTSUhhaUFIYzJjaUIwRUJhM1FpQkNBRVFSQjFJQU5zSUFSQi8vOERjU0FEYkVFUWRXb2lCS3dnQ2F4K1FoMklwMEY0Y1dzaUNVRVFkU0FEYkNBRWFpQUpRZi8vQTNFZ0EyeEJFSFZxSVFNZ0JTQUZLQUlBSWdsQkVIUkJFSFVpRkFKL0lBY2dCbXRCSFdvaUJFRVBUQVJBUWYvLy8vOEhRUkFnQkdzaUJIWWlCa0dBZ0lDQWVDQUVkU0lISUFNZ0F5QUhTQnNnQXlBR1Noc2dCSFFNQVFzZ0F5QUVRUkJyZFVFQUlBUkJNRWdiQ3lJSFFmLy9BM0VpQTJ4QkVIVWdGQ0FIUVJCMUlnUnNhaUFKUVE5MVFRRnFRUUYxSUFkc2FqWUNBQ0FGSUFVb0FnUWlCa0VRZEVFUWRTSUpJQU5zUVJCMUlBUWdDV3hxSUFaQkQzVkJBV3BCQVhVZ0IyeHFOZ0lFSUFVZ0JTZ0NDQ0lHUVJCMFFSQjFJZ2tnQTJ4QkVIVWdCQ0FKYkdvZ0JrRVBkVUVCYWtFQmRTQUhiR28yQWdnZ0JTQUZLQUlNSWdaQkVIUkJFSFVpQ1NBRGJFRVFkU0FFSUFsc2FpQUdRUTkxUVFGcVFRRjFJQWRzYWpZQ0RDQUZJQVVvQWhBaUJrRVFkRUVRZFNJSklBTnNRUkIxSUFRZ0NXeHFJQVpCRDNWQkFXcEJBWFVnQjJ4cU5nSVFJQVVnQlNnQ0ZDSUdRUkIwUVJCMUlna2dBMnhCRUhVZ0JDQUpiR29nQmtFUGRVRUJha0VCZFNBSGJHbzJBaFFnQlNBRktBSVlJZ1pCRUhSQkVIVWlDU0FEYkVFUWRTQUVJQWxzYWlBR1FROTFRUUZxUVFGMUlBZHNhallDR0NBRklBVW9BaHdpQmtFUWRFRVFkU0lKSUFOc1FSQjFJQVFnQ1d4cUlBWkJEM1ZCQVdwQkFYVWdCMnhxTmdJY0lBVWdCU2dDSUNJR1FSQjBRUkIxSWdrZ0EyeEJFSFVnQkNBSmJHb2dCa0VQZFVFQmFrRUJkU0FIYkdvMkFpQWdCU0FGS0FJa0lnWkJFSFJCRUhVaUNTQURiRUVRZFNBRUlBbHNhaUFHUVE5MVFRRnFRUUYxSUFkc2FqWUNKQ0FGSUFVb0FpZ2lCa0VRZEVFUWRTSUpJQU5zUVJCMUlBUWdDV3hxSUFaQkQzVkJBV3BCQVhVZ0IyeHFOZ0lvSUFVZ0JTZ0NMQ0lHUVJCMFFSQjFJZ2tnQTJ4QkVIVWdCQ0FKYkdvZ0JrRVBkVUVCYWtFQmRTQUhiR28yQWl3Z0JTQUZLQUl3SWdaQkVIUkJFSFVpQ1NBRGJFRVFkU0FFSUFsc2FpQUdRUTkxUVFGcVFRRjFJQWRzYWpZQ01DQUZJQVVvQWpRaUJrRVFkRUVRZFNJSklBTnNRUkIxSUFRZ0NXeHFJQVpCRDNWQkFXcEJBWFVnQjJ4cU5nSTBJQVVnQlNnQ09DSUdRUkIwUVJCMUlna2dBMnhCRUhVZ0JDQUpiR29nQmtFUGRVRUJha0VCZFNBSGJHbzJBamdnQlNBRElBVW9BandpQmtFUWRFRVFkU0lKYkVFUWRTQUVJQWxzYWlBR1FROTFRUUZxUVFGMUlBZHNhallDUEFzZ0RrRUtiQ0FCYWlFRElBQWdEellDQUFKQUFuOENRQUpBSUFBb0FzQWdSUTBBSUFBb0FzUWdRUUpIRFFBZ0RrRUJTdzBBSUF0QkFrWU5BQ0FEUWdBM0FXQWdBMEVBT3dGb0lBTkJnQ0E3QVdRZ0NDQUFLQUtFRWlJR05nSUFEQUVMSUF0QkFrY0VRQ0FBS0FLY0VpRUpJQk1NQWdzZ0NDZ0NBQ0VHQ3dKQVFRQWdEaUFtSUE1QkFrWnhHMFVFUUNBQUtBS2dFaUlISUFZZ0FDZ0NwQklpQkdwclFRSnJJUWdnRGtFQ1JnUkFJQUFnQjBFQmRHcEJ4QXBxSUFJZ0FDZ0NuQkpCQW5RUUJCb2dBQ2dDb0JJaEJ5QUFLQUtrRWlFRUN5QVhJQWhCQVhScUlBQWdBQ2dDbkJJZ0Rtd2dDR3BCQVhScVFjUUthaUFOSUFjZ0NHc2dCQkJISUE1RkJFQWdBUzRCaUFFaUJDQUtRZi8vQTNGc1FSQjFJQVFnQ2tFUWRXeHFRUUowSVFvTElBWkJmMGdOQVNBR1FRRnFJUVFnQ2tILy93TnhJUWNnQ2tFUWRTRUtJQUFvQXFBU0lRbEJBQ0VJQTBBZ0VpQVFJQWhCZjNNaUMycEJBblJxSUFjZ0Z5QUpJQXRxUVFGMGFpNEJBQ0lMYkVFUWRTQUtJQXRzYWpZQ0FDQUVJQWhHSVFzZ0NFRUJhaUVJSUF0RkRRQUxEQUVMSUFkQmdJQUVSZzBBSUFaQmYwZ05BQ0FHUVFGcUlRUWdCMEgvL3dOeElRb2dCMEVRZFNFSlFRQWhDQU5BSUJJZ0VDQUlRWDl6YWtFQ2RHb2lDeUFMS0FJQUlndEJFSFJCRUhVaURTQUtiRUVRZFNBSklBMXNhaUFMUVE5MVFRRnFRUUYxSUFkc2FqWUNBQ0FFSUFoSElRc2dDRUVCYWlFSUlBc05BQXNMSUFBb0Fwd1NJZ2xCQVVnTkFTQVFJQVpyUVFKMElCSnFRUWhxSVFnZ0F5NEJhQ0VFSUFNdUFXWWhDaUFETGdGa0lRWWdBeTRCWWlFTElBTXVBV0FoQTBFQUlRY0RRQ0FZSUFkQkFuUWlEV29nRFNBVGFpZ0NBQ0FJS0FJQUlnMUJFSFVnQTJ3Z0RVSC8vd054SUFOc1FSQjFhaUFJUVFScktBSUFJZzFCRUhVZ0MyeHFJQTFCLy84RGNTQUxiRUVRZFdvZ0NFRUlheWdDQUNJTlFSQjFJQVpzYWlBTlFmLy9BM0VnQm14QkVIVnFJQWhCREdzb0FnQWlEVUVRZFNBS2JHb2dEVUgvL3dOeElBcHNRUkIxYWlBSVFSQnJLQUlBSWcxQkVIVWdCR3hxSUExQi8vOERjU0FFYkVFUWRXcEJBWFJxUVFScUlnMDJBZ0FnRWlBUVFRSjBhaUFOUVFGME5nSUFJQkJCQVdvaEVDQUlRUVJxSVFnZ0IwRUJhaUlISUFsSERRQUxJQmdMSVNjZ0NVRUJTQTBBSUE5QkNuUkJFSFVoQ3lBQUtBS2tFaUlvUVFGMUlTa2dEMEVWZFVFQmFrRUJkU0VxSUFVb0Fod2hCQ0FGS0FJa0lRWWdCU2dDTENFS0lBVW9BalFoQXlBRktBSThJUWhCQUNFSElBd3VBUjRoRHlBTUxnRWNJUTBnREM0QkdpRVVJQXd1QVJnaEdTQU1MZ0VXSVJvZ0RDNEJGQ0ViSUF3dUFSSWhIQ0FNTGdFUUlSMGdEQzRCRGlFZUlBd3VBUXdoSHlBTUxnRUtJU0FnREM0QkNDRWhJQXd1QVFZaElpQU1MZ0VFSVNNZ0RDNEJBaUVrSUF3dUFRQWhKUU5BSUFoQkVIVWdKV3dnS1dvZ0NFSC8vd054SUNWc1FSQjFhaUFIUVFKMEloVWdCV29pQ0NnQ09DSU1RUkIxSUNSc2FpQU1RZi8vQTNFZ0pHeEJFSFZxSUFOQkVIVWdJMnhxSUFOQi8vOERjU0FqYkVFUWRXb2dDQ2dDTUNJRFFSQjFJQ0pzYWlBRFFmLy9BM0VnSW14QkVIVnFJQXBCRUhVZ0lXeHFJQXBCLy84RGNTQWhiRUVRZFdvZ0NDZ0NLQ0lLUVJCMUlDQnNhaUFLUWYvL0EzRWdJR3hCRUhWcUlBWkJFSFVnSDJ4cUlBWkIvLzhEY1NBZmJFRVFkV29nQ0NnQ0lDSUdRUkIxSUI1c2FpQUdRZi8vQTNFZ0hteEJFSFZxSUFSQkVIVWdIV3hxSUFSQi8vOERjU0FkYkVFUWRXb2dDQ2dDR0NJRVFSQjFJQnhzYWlBRVFmLy9BM0VnSEd4QkVIVnFJUVFnQlNBSFFSQnFRUUowYWdKL0FuOGdLRUVRUmdSQUlBUWdDQ2dDRkNJclFSQjFJQnRzYWlBclFmLy9BM0VnRzJ4QkVIVnFJQWdvQWhBaUJFRVFkU0FhYkdvZ0JFSC8vd054SUJwc1FSQjFhaUFJS0FJTUlnUkJFSFVnR1d4cUlBUkIvLzhEY1NBWmJFRVFkV29nQ0NnQ0NDSUVRUkIxSUJSc2FpQUVRZi8vQTNFZ0ZHeEJFSFZxSUFnb0FnUWlCRUVRZFNBTmJHb2dCRUgvL3dOeElBMXNRUkIxYWlBSUtBSUFJZ1JCRUhVZ0QyeHFJQVJCLy84RGNTQVBiRUVRZFdvaEJBc2dCQXRCZ0lDQVFDQUVRWUNBZ0VCS0d5SUVRZi8vL3o4Z0JFSC8vLzgvU0J0QkJIUWlCQ0FWSUNkcUtBSUFJZ2hxSWhWQkFFNEVRQ0FWUVlDQWdJQjRJQVFnQ0hGQmYwb2JEQUVMUWYvLy8vOEhJQlVnQkNBSWNrRi9TaHNMSWdnMkFnQWdFU0FIUVFGMGFrSC8vd0ZCZ0lCK0lBaEJFSFVnQzJ3Z0NDQXFiR29nQ0VILy93TnhJQXRzUVJCMWFpSUVRUWQyUVFGcVFRRjJJQVJCZ1AvL2UwZ2JJQVJCLy83L0Ewb2JPd0VBSUFZaEJDQUtJUVlnQXlFS0lBd2hBeUFIUVFGcUlnY2dDVWNOQUFzTElBVWdCU0FKUVFKMElnUnFJZ01wQWdBM0FnQWdCU0FES1FJNE53STRJQVVnQXlrQ01EY0NNQ0FGSUFNcEFpZzNBaWdnQlNBREtRSWdOd0lnSUFVZ0F5a0NHRGNDR0NBRklBTXBBaEEzQWhBZ0JTQURLUUlJTndJSUlCRWdDVUVCZEdvaEVTQUVJQk5xSVJNZ0RrRUJhaUlPSUFBb0FwUVNTQTBBQ3dzZ0FFR0VDbW9pQUNBRktRSUFOd0lBSUFBZ0JTa0NPRGNDT0NBQUlBVXBBakEzQWpBZ0FDQUZLUUlvTndJb0lBQWdCU2tDSURjQ0lDQUFJQVVwQWhnM0FoZ2dBQ0FGS1FJUU53SVFJQUFnQlNrQ0NEY0NDQ0FXUVNCcUpBQUxoZ1lCQW44akFFRVFheUlHSkFBZ0JrRUFPZ0FQSUFKQkNFNEVRQ0FEUVFGMElBUnFRUkIwUVJCMVFRZHNRYUE1YWlFRElBSkJDR3BCQkhVaUFrRUJJQUpCQVVvYklRUkJBQ0VDQTBBQ1FDQUZJQUpCQW5ScUtBSUFJZ2RCQVVnTkFDQUdJQU1nQjBFZmNTSUhRUVlnQjBFR1NSdHFMUUFBT2dBT0lBRXVBUUJCQVU0RVFDQUJJQUFnQmtFT2FrRUlFQU5CQVhSQkFXc2dBUzhCQUd3N0FRQUxJQUV1QVFKQkFFb0VRQ0FCSUFBZ0JrRU9ha0VJRUFOQkFYUkJBV3NnQVM4QkFtdzdBUUlMSUFFdUFRUkJBVTRFUUNBQklBQWdCa0VPYWtFSUVBTkJBWFJCQVdzZ0FTOEJCR3c3QVFRTElBRXVBUVpCQVU0RVFDQUJJQUFnQmtFT2FrRUlFQU5CQVhSQkFXc2dBUzhCQm13N0FRWUxJQUV1QVFoQkFVNEVRQ0FCSUFBZ0JrRU9ha0VJRUFOQkFYUkJBV3NnQVM4QkNHdzdBUWdMSUFFdUFRcEJBVTRFUUNBQklBQWdCa0VPYWtFSUVBTkJBWFJCQVdzZ0FTOEJDbXc3QVFvTElBRXVBUXhCQVU0RVFDQUJJQUFnQmtFT2FrRUlFQU5CQVhSQkFXc2dBUzhCREd3N0FRd0xJQUV1QVE1QkFVNEVRQ0FCSUFBZ0JrRU9ha0VJRUFOQkFYUkJBV3NnQVM4QkRtdzdBUTRMSUFFdUFSQkJBVTRFUUNBQklBQWdCa0VPYWtFSUVBTkJBWFJCQVdzZ0FTOEJFR3c3QVJBTElBRXVBUkpCQVU0RVFDQUJJQUFnQmtFT2FrRUlFQU5CQVhSQkFXc2dBUzhCRW13N0FSSUxJQUV1QVJSQkFVNEVRQ0FCSUFBZ0JrRU9ha0VJRUFOQkFYUkJBV3NnQVM4QkZHdzdBUlFMSUFFdUFSWkJBVTRFUUNBQklBQWdCa0VPYWtFSUVBTkJBWFJCQVdzZ0FTOEJGbXc3QVJZTElBRXVBUmhCQVU0RVFDQUJJQUFnQmtFT2FrRUlFQU5CQVhSQkFXc2dBUzhCR0d3N0FSZ0xJQUV1QVJwQkFVNEVRQ0FCSUFBZ0JrRU9ha0VJRUFOQkFYUkJBV3NnQVM4QkdtdzdBUm9MSUFFdUFSeEJBVTRFUUNBQklBQWdCa0VPYWtFSUVBTkJBWFJCQVdzZ0FTOEJIR3c3QVJ3TElBRXVBUjVCQVVnTkFDQUJJQUFnQmtFT2FrRUlFQU5CQVhSQkFXc2dBUzhCSG13N0FSNExJQUZCSUdvaEFTQUNRUUZxSWdJZ0JFY05BQXNMSUFaQkVHb2tBQXRoQVFKL0lBQVFGU0lCQkVCQm1Qc0JLQUlBSWdCRkJFQkJDQkFWSWdCQkFEWUNCQ0FBSUFFMkFnQkJtUHNCSUFBMkFnQWdBUThMQTBBZ0FDSUNLQUlFSWdBTkFBdEJDQkFWSWdCQkFEWUNCQ0FBSUFFMkFnQWdBaUFBTmdJRUN5QUJDOU1EQVFaL0l3QkJFR3NpQlNRQUFrQWdBQ2dDd0NBRVFDQUFRWWdoYWlBQVFZd2hhaUFCSUFJUUdpQUFRZndnYWtFQk5nSUFEQUVMQWtBZ0FFSDhJR29vQWdCRkRRQWdCVUVJYWlBRlFReHFJQUVnQWhBYUFrQWdCU2dDRENJRElBQkJqQ0ZxS0FJQUlnUktCRUFnQUVHSUlXb2lCeUFIS0FJQUlBTWdCR3QxTmdJQURBRUxJQU1nQkU0TkFDQUZJQVVvQWdnZ0JDQURhM1UyQWdnTElBVW9BZ2dpQmlBQVFZZ2hhaWdDQUNJRFRBMEFJQUFnQXlBRFp5SURRUUZyZENJSU5nS0lJVUVBSVFkQkFDRUVJQWdnQmtFWklBTnJJZ05CQUNBRFFRQktHM1VpQTBFQklBTkJBVW9iYlNJRFFRRk9CRUFDUUVFWUlBTm5JZ1JySWdaRkRRQWdBMEgvQUUwRVFDQURJQVJCR0d0MElBTkJPQ0FFYTNaeUlRTU1BUXNnQXlBRVFRaHFkQ0FESUFaMmNpRURDMEdBZ0FKQmh1a0NJQVJCQVhFYklBUkJBWFoySWdRZ0EwSC9BSEZCZ0lEVUJteEJFSFpzUVJCMklBUnFRUVIwSVFRTFFZQ0FCQ0FFYXlBQ2JTRURJQUpCQVVnTkFDQURRUUowSVFNRFFDQUJJQWRCQVhScUlnWWdCaTRCQUNJR0lBUkIvUDhEY1d4QkVIWWdCRUVRZGlBR2JHbzdBUUFnQXlBRWFpSUVRWUNBQkVvTkFTQUhRUUZxSWdjZ0FrZ05BQXNMSUFCQkFEWUMvQ0FMSUFWQkVHb2tBQXZtQWdFSGZ5TUFJZ2doRFNBSUlBWkJBblJCRDJwQmNIRnJJZ29rQUNBR1FRRk9CRUFnQjBFQ2F5QUdiQ0VNSUFVb0FnQWlDRUVRZEVFUWRTRUxJQWhCRDNWQkFXcEJBWFVoRGtFQUlRZ0RRQ0FLSUFoQkFYUnFRZi8vQVVHQWdINGdDeUFFSUFnZ0RHcEJBblJxS0FJQUlnbEIvLzhEY1d4QkVIVWdDeUFKUVJCMWJHb2dDU0FPYkdvaUNVRUlkaUFKUVlDQWdIeElHeUFKUWYvLy93TktHenNCQUNBSVFRRnFJZ2dnQmtjTkFBc2dCMEVCYXlBR2JDRUxJQW9nQmtFQmRHb2hDU0FGS0FJRUlnZEJFSFJCRUhVaEJTQUhRUTkxUVFGcVFRRjFJUXhCQUNFSUEwQWdDU0FJUVFGMGFrSC8vd0ZCZ0lCK0lBVWdCQ0FJSUF0cVFRSjBhaWdDQUNJSFFmLy9BM0ZzUVJCMUlBVWdCMEVRZFd4cUlBY2dER3hxSWdkQkNIWWdCMEdBZ0lCOFNCc2dCMEgvLy84RFNoczdBUUFnQ0VFQmFpSUlJQVpIRFFBTEN5QUFJQUVnQ2lBR0VCb2dBaUFESUFvZ0JrRUJkR29nQmhBYUlBMGtBQXZ3RkFFZmZ5TUFRVUJxSWdja0FDQUhJQUFvQXBnU0lBQW9BcUFTYWtFQ2RFRVBha0Z3Y1dzaUR5SUVKQUFnQkNBQUtBS2dFa0VCZEVFUGFrRndjV3NpRENRQUlBY2dBRUdVSVdvb0FnQkJCblUyQWdnZ0J5QUFRWmdoYWlnQ0FDSVdRUVoxSWhjMkFnd2dBQ2dDeUJJRVFDQUFRZklnYWtJQU53RUFJQUJCNmlCcVFnQTNBUUFnQUVIaUlHcENBRGNCQUNBQVFkb2dha0lBTndFQUN5QUhRVFJxSUFkQlBHb2dCMEV3YWlBSFFUaHFJQUJCQkdvZ0IwRUlhaUFBS0FLY0VpQUFLQUtVRWhCeklBQkJvQ0ZxS0FJQUlRZ0NRQ0FIS0FJMElBY29BamgxSUFjb0FqQWdCeWdDUEhWSUJFQWdDRUVCYXlFTklBQkJwQ0ZxS0FJQUlRZ01BUXNnQUVHa0lXb29BZ0FoRFFzZ0FFR0VJV292QVFBaENTQUFLQUxBSUNFRUlBQW9Bc1FnSVFZZ0FFSGFJR29pQlNBQUtBS2tFa0h4K2dNUUtpQUhRUkJxSUFVZ0FDZ0NwQklpQTBFQmRCQUVHaUFFUVFFZ0JFRUJTQnRCQVhRaUMwR3VDV29nQzBHeUNXb2dCa0VDUmhzdUFRQWhEZ0pBSUFBb0FzQWdEUUFnQUNnQ3hDQkJBa1lFUUNBQVFaQWhhaTRCQUVHQWdBRWdBRUhZSUdvdkFRQWdBRUhXSUdvdkFRQWdBRUhVSUdvdkFRQWdBQzhCMENBZ0FFSFNJR292QVFCcWFtcHFheUlFUWMwWklBUkJFSFJCRUhWQnpSbEtHMEgvL3dOeGJFRU9kaUVKREFFTElBVWdBeEFkSWdSQmdJQ0F3QUFnQkVHQWdJREFBRWdiSWdSQmdJQ0FBaUFFUVlDQWdBSktHeUlFUVFOMFFmai9BM0VnRG14QkVIVWdCRUVOZGtILy93TnhJQTVzYWtFT2RTRU9JQUFvQXFRU0lRTkJnSUFCSVFrTElBQkJnQ0ZxS0FJQUlSd2dEQ0FBS0FLZ0VpSUVJQU5ySUFBb0Fzd2dRUWQxUVFGcVFRRjFJaE5yUVFKcklnWkJBWFFpQldvZ0FDQUZha0hFQ21vZ0IwRVFhaUFFSUFacklBTVFSMEVBSUFBb0FwZ2hJZ1VnQlNBRlFSOTFJZ05xSUFOekloQm5JZ05CQVd0MElnVkIvLzhEY1VILy8vLy9BU0FGUVJCMUlncHRJaEZCRUhRaUVrRVFkU0lGYkVFUWRTQUZJQXBzYWtFRGRHc2lDaUFSUVE5MVFRRnFRUUYxYkNBU2FpQUtRUkIxSUFWc2FpQUtRZmovQTNFZ0JXeEJFSFZxSVFVQ2Z5QVFRZi8vQTAwRVFFSC8vLy8vQnlBRFFSQnJJZ04ySWdwQmdJQ0FnSGdnQTNVaUVDQUZJQVVnRUVnYklBVWdDa29iSUFOMERBRUxJQVZCRUNBRGEzVUxJUVVnQUNnQ3BCSWlFQ0FHYWlJRElBQW9BcUFTSWhGSUJFQWdCVUgvLy8vL0F5QUZRZi8vLy84RFNCc2lCVUgvL3dOeElRWWdCVUVRZFNFRkEwQWdEeUFEUVFKMGFpQUdJQXdnQTBFQmRHb3VBUUFpQ214QkVIVWdCU0FLYkdvMkFnQWdBMEVCYWlJRElCRklEUUFMQ3lBQUtBS1VFaUlZUVFGT0JFQWdDQ0FOYkNJRlFZQUJJQVZCZ0FGS0cwRUNkQ0FBYWtIOEEyc2hHU0FMUWFvSmFpNEJBQ0VLSUFBdUFZd1NRWUFrYkNFU0lBNUJFSFJCRUhVaEdpQUFRZGdnYWk4QkFDRURJQUJCMWlCcUx3RUFJUXNnQUVIVUlHb3ZBUUFoQlNBQVFkSWdhaThCQUNFSUlBQXZBZEFnSVFZZ0FDZ0NuQkloRkFOQUFrQWdGRUVBVEFSQUlBbEJFSFJCRUhVaERTQURRUkIwUVJCMUlRd2dDMEVRZEVFUWRTRUxJQVZCRUhSQkVIVWhCU0FJUVJCMFFSQjFJUWdnQmtFUWRFRVFkU0VHREFFTElBbEJFSFJCRUhVaERTQURRUkIwUVJCMUlRd2dDMEVRZEVFUWRTRUxJQVZCRUhSQkVIVWhCU0FJUVJCMFFSQjFJUWdnQmtFUWRFRVFkU0VHSUFRZ0UydEJBblFnRDJwQkNHb2hBMEVBSVE0RFFDQVBJQVJCQW5ScUlBTW9BZ0FpQ1VFUWRTQUdiQ0FKUWYvL0EzRWdCbXhCRUhWcUlBTkJCR3NvQWdBaUNVRVFkU0FJYkdvZ0NVSC8vd054SUFoc1FSQjFhaUFEUVFocktBSUFJZ2xCRUhVZ0JXeHFJQWxCLy84RGNTQUZiRUVRZFdvZ0EwRU1heWdDQUNJSlFSQjFJQXRzYWlBSlFmLy9BM0VnQzJ4QkVIVnFJQU5CRUdzb0FnQWlDVUVRZFNBTWJHb2dDVUgvL3dOeElBeHNRUkIxYWlBWklCeEJ0WWpPM1FCc1Fldkc1YkFEYWlJY1FSZDJRZndEY1dvb0FnQWlDVUVRZFNBTmJHb2dDVUgvL3dOeElBMXNRUkIxYWtFQ2RFRUlhallDQUNBRVFRRnFJUVFnQTBFRWFpRURJQTVCQVdvaURpQVVSdzBBQ3dzZ0FDQUFLQUxNSUNJRFFSQjFRWThGYkNBRGFpQURRZi8vQTNGQmp3VnNRUkIyYWlJRElCSWdBeUFTU0JzaUF6WUN6Q0FnQTBFSGRVRUJha0VCZFNFVElBMGdHbXhCRDNZaENTQUtJQXhzUVE5MklRTWdDaUFMYkVFUGRpRUxJQVVnQ214QkQzWWhCU0FJSUFwc1FROTJJUWdnQmlBS2JFRVBkaUVHSUJ0QkFXb2lHeUFZUncwQUN5QUFJQU03QWRnZ0lBQWdDenNCMWlBZ0FDQUZPd0hVSUNBQUlBZzdBZElnSUFBZ0Jqc0IwQ0FMSUJGQkFuUWdEMnBCUUdvaUJpQUFLUUtFQ2pjQ0FDQUdJQUJCdkFwcUtRSUFOd0k0SUFZZ0FFRzBDbW9wQWdBM0FqQWdCaUFBUWF3S2Fpa0NBRGNDS0NBR0lBQkJwQXBxS1FJQU53SWdJQVlnQUVHY0Ntb3BBZ0EzQWhnZ0JpQUFRWlFLYWlrQ0FEY0NFQ0FHSUFCQmpBcHFLUUlBTndJSUlBQW9BcGdTSWc1QkFVNEVRQ0FRUVFGMUlSNGdGMEVRZEVFUWRTRUtJQlpCRlhWQkFXcEJBWFVoSHlBR0tBSWNJUVFnQmlnQ0pDRU5JQVlvQWl3aERDQUdLQUkwSVFVZ0JpZ0NQQ0VESUFjdUFTSWhEeUFITGdFZ0lSRWdCeTRCSGlFU0lBY3VBUndoRkNBSExnRWFJUllnQnk0QkdDRVhJQWN1QVJZaEdDQUhMZ0VVSVJrZ0J5NEJFaUVhSUFjdUFSQWhHeUFRUVF0SUlTQkJBQ0VJQTBBZ0EwRVFkU0FiYkNBZWFpQURRZi8vQTNFZ0cyeEJFSFZxSUFoQkFuUWdCbW9pQXlnQ09DSUxRUkIxSUJwc2FpQUxRZi8vQTNFZ0dteEJFSFZxSUFWQkVIVWdHV3hxSUFWQi8vOERjU0FaYkVFUWRXb2dBeWdDTUNJRlFSQjFJQmhzYWlBRlFmLy9BM0VnR0d4QkVIVnFJQXhCRUhVZ0YyeHFJQXhCLy84RGNTQVhiRUVRZFdvZ0F5Z0NLQ0lNUVJCMUlCWnNhaUFNUWYvL0EzRWdGbXhCRUhWcUlBMUJFSFVnRkd4cUlBMUIvLzhEY1NBVWJFRVFkV29nQXlnQ0lDSU5RUkIxSUJKc2FpQU5RZi8vQTNFZ0VteEJFSFZxSUFSQkVIVWdFV3hxSUFSQi8vOERjU0FSYkVFUWRXb2dBeWdDR0NJRVFSQjFJQTlzYWlBRVFmLy9BM0VnRDJ4QkVIVnFJUVFnQ0VFUWFpRVZRUW9oQXlBZ1JRUkFBMEFnQkNBSFFSQnFJQU5CQVhScUxnRUFJaDBnQmlBVklBTkJmM05xUVFKMGFpZ0NBQ0loUVJCMWJHb2dJVUgvL3dOeElCMXNRUkIxYWlFRUlBTkJBV29pQXlBUVJ3MEFDd3NDZnlBR0lCVkJBblJxSWgwb0FnQWlBeUFFUVlDQWdFQWdCRUdBZ0lCQVNoc2lCRUgvLy84L0lBUkIvLy8vUDBnYlFRUjBJZ1JxSWhWQkFFNEVRQ0FWUVlDQWdJQjRJQU1nQkhGQmYwb2JEQUVMUWYvLy8vOEhJQlVnQXlBRWNrRi9TaHNMSVFNZ0hTQUROZ0lBSUFJZ0NFRUJkR3BCLy84QlFZQ0FmaUFEUVJCMUlBcHNJQU1nSDJ4cUlBTkIvLzhEY1NBS2JFRVFkV29pQkVFSGRrRUJha0VCZGlBRVFZRC8vM3RJR3lBRVFmLysvd05LR3pzQkFDQU5JUVFnRENFTklBVWhEQ0FMSVFVZ0NFRUJhaUlJSUE1SERRQUxDeUFBUVlRS2FpSUNJQVlnRGtFQ2RHb2lCQ2tDQURjQ0FDQUNJQVFwQWpnM0FqZ2dBaUFFS1FJd053SXdJQUlnQkNrQ0tEY0NLQ0FDSUFRcEFpQTNBaUFnQWlBRUtRSVlOd0lZSUFJZ0JDa0NFRGNDRUNBQ0lBUXBBZ2czQWdnZ0FDQUpPd0dFSVNBQUlCdzJBb0FoSUFFZ0V6WUNEQ0FCSUJNMkFnZ2dBU0FUTmdJRUlBRWdFellDQUNBSFFVQnJKQUFMZ3dZQkRuOGdBU0FDUVFGMGFpRU1JQUFnQWtFQmF5SUxRUUYwYWlFSklBSkJBa2doRGdKQUEwQWdBQzRCQUNJRklBRXVBUUFpQ0dzaEJFRUJJUU5CQUNFR0lBNUZCRUFEUUNBRlFSQjBJUWNnQUNBRFFRRjBJZ3BxTGdFQUlnVWdCMEVRZFdzZ0FTQUthaTRCQUdzaUJ5QUVJQVFnQjBvaUJ4c2hCQ0FESUFZZ0J4c2hCaUFEUVFGcUlnTWdBa2NOQUFzTFFZQ0FBaUFNTGdFQUlnY2dDUzRCQUdwcklnTWdCQ0FESUFSSUlnTWJRWDlLRFFFQ1FDQUNJQVlnQXhzaUJVVUVRQ0FBSUFnN0FRQU1BUXNDUUFKQUlBSWdCVWNFUUNBRlFRRk9EUUZCQUNFSURBSUxJQWxCZ0lCK0lBZHJPd0VBREFJTFFRRWhBeUFGUVFGR0RRQURRQ0FJSUFFZ0EwRUJkR291QVFCcUlRZ2dBMEVCYWlJRElBVkhEUUFMQ3lBSUlBRWdCVUVCZENJUGFpSVFMZ0VBUVFGMUlncHFJUVJCZ0lBQ0lRWUNRQ0FDSUFWTURRQkJnSUFDSUFkcklRWWdCU0FMSWdOT0RRQURRQ0FHSUFFZ0EwRUJkR291QVFCcklRWWdBMEVCYXlJRElBVktEUUFMQ3lBQUlBOXFJZ2d1QVFBZ0FDQUZRUUZyUVFGMGFpSUhMZ0VBYWlJRFFRRjFJQU5CQVhGcUlRVUNRQ0FHSUFwcklnTWdCRWdFUUNBRklBUWlCa29OQVNBRElBVWdBeUFGU2hzaEJnd0JDeUFESWdZZ0JVZ05BQ0FFSUFVZ0JDQUZTaHNoQmdzZ0J5QUdJQXBySWdZN0FRQWdDQ0FHSUJBdkFRQnFPd0VBQ3lBTlFRRnFJZzFCRkVjTkFBc2dBQ0FDRUdVZ0FDQUFMZ0VBSWdZZ0FTNEJBQ0lESUFNZ0JrZ2JJZ1E3QVFBZ0FrRUNTQ0lHUlFSQVFRRWhBd05BSUFBZ0EwRUJkQ0lMYWlJRklBVXVBUUFpQlNBQklBdHFMZ0VBSUFSQkVIUkJFSFZxSWdSQi8vOEJJQVJCLy84QlNCc2lCRUdBZ0g0Z0JFR0FnSDVLR3lJRUlBUWdCVWdiSWdRN0FRQWdBMEVCYWlJRElBSkhEUUFMQ3lBSklBa3VBUUFpQTBHQWdBSWdEQzRCQUdzaUJDQURJQVJJR3lJRU93RUFJQVlOQUNBQ1FRSnJJUU1EUUNBQUlBTkJBWFFpQW1vaUJpQUdMZ0VBSWdZZ0JFRVFkRUVRZFNBQklBSnFMZ0VDYXlJQ0lBSWdCa29iSWdRN0FRQWdBMEVBU2lFQ0lBTkJBV3NoQXlBQ0RRQUxDd3ZNQWdFSmZ5TUFRZEFBYXlJRkpBQWdCVUVnYWlBRlFVQnJJQUlnQVN3QUFCQkdJQUl2QVFJaUEwRVFkRUVRZFNJSFFRRklJZ3RGQkVBZ0FpNEJCQ0VJQTBBZ0JTQURRUUZySWdaQkFYUnFJQUVnQTJvc0FBQWlDa0VLZENJRVFlWUFheUFFUWVZQWNpQUtRUjkxY1NBS1FRQktHeUlFUVJCMUlBaHNJQVZCUUdzZ0Jtb3RBQUFnQ1VFUWRFRVFkV3hCQ0hWcUlBUkIvdjhEY1NBSWJFRVFkV29pQ1RzQkFDQURRUUZLSVFRZ0JpRURJQVFOQUFzTElBdEZCRUFnQVN3QUFDQUhiQ0lCSUFJb0FnaHFJUVFnQWlnQ0RDQUJRUUYwYWlFR1FRQWhBd05BSUFBZ0EwRUJkQ0lCYWlBQklBVnFMZ0VBUVE1MElBRWdCbW91QVFCdElBTWdCR290QUFCQkIzUnFJZ0ZCQUNBQlFRQktHeUlCUWYvL0FTQUJRZi8vQVVnYk93RUFJQU5CQVdvaUF5QUNMZ0VDSWdkSURRQUxDeUFBSUFJb0FpUWdCeEIxSUFWQjBBQnFKQUFMMkFJQkJYOENRQ0FDUVFGSURRQUNRQU5BUVFBaEEwRUFJUVFEUUNBQklBTkJBblJxS0FJQUlnVWdCVUVmZFNJRmFpQUZjeUlGSUFRZ0JDQUZTQ0lGR3lFRUlBTWdCaUFGR3lFR0lBTkJBV29pQXlBQ1J3MEFDeUFFUVFSMlFRRnFRUUYySWdOQmdJQUNUd1JBSUFFZ0FrRysvd01nQTBIKy93a2dBMEgrL3dsSUd5SURRUTUwUVlDQS8vOEJheUFESUFaQkFXcHNRUUoxYldzUUtTQUhRUUZxSWdkQkNrY05BUXdDQ3dzZ0IwRUtSZzBBSUFKQkFVZ05BVUVBSVFNRFFDQUFJQU5CQVhScUlBRWdBMEVDZEdvb0FnQkJCSFZCQVdwQkFYWTdBUUFnQTBFQmFpSURJQUpIRFFBTERBRUxJQUpCQVVnTkFFRUFJUU1EUUNBQUlBTkJBWFJxQW45Qi8vOEJJQUVnQTBFQ2RHb2lCaWdDQUVFRWRTSUVRZjcvQTBvTkFCcEJnSUIrSUFSQi8vOTdTQTBBR2lBRVFRRnFRUUYxQ3lJRU93RUFJQVlnQkVFRmREWUNBQ0FEUVFGcUlnTWdBa2NOQUFzTEM0b0JBUU4vSXdCQkVHc2lCQ1FBQWtBQ1FBSi9RWkQ3QVNnQ0FDSUZCRUFnQTBFQlNBUi9RWDhGSUFVZ0FDQUJJQUlnQTBFQVFRQVFUZ3NNQVF0QmxQc0JLQUlBSWdWRkRRRWdCU0FBSUFFZ0FpQURFSDRMSWdaQkFFb05BUXNnQkNBRE5nSU1JQVFnQWpZQ0NDQUVJQUUyQWdRZ0JDQUFOZ0lBUWJRSUlBUVFIZ3NnQkVFUWFpUUFJQVlMa3hJQkhuOGpBRUVnYXlJS0lRZ2dDaVFBSUFBb0Fvd1NJZ2tnQUVHOElHb29BZ0JIQkVCQi8vOEJJQUFvQXFRU0lnWkJBV3B0SVFjZ0JrRUJUZ1JBQTBBZ0FDQUVRUUYwYWtIVUgyb2dCU0FIYWlJRk93RUFJQVJCQVdvaUJDQUdSdzBBQ3dzZ0FDQUpOZ0s4SUNBQVFiUWdha0tBZ0lDQWdKQ2VHRGNDQUFzQ1FBSkFJQUFvQXNBZ1JRUkFBa0FnQUNnQ3hDQU5BRUVBSVFRZ0FDZ0NwQklpQlVFQVNnUkFBMEFnQUNBRVFRRjBhaUlHUWRRZmFpSUpJQWt1QVFBaUNTQUdRYWdTYWk0QkFDQUpheUlHUWYvL0EzRkIzUDhBYkVFUWRpQUdRUkIyUWR6L0FHeHFhanNCQUNBRVFRRnFJZ1FnQlVjTkFBc0xJQUJCMUJWcUlRbEJBQ0VFQWtBZ0FDZ0NsQklpQjBFQVRBUkFRUUFoQmd3QkMwRUFJUVpCQUNFRkEwQWdBU0FFUVFKMGFpZ0NFQ0lMSUFVZ0JTQUxTQ0lMR3lFRklBUWdCaUFMR3lFR0lBUkJBV29pQkNBSFJ3MEFDd3NnQUNBQUtBS2NFaUlGUVFKMGFrSFVGV29nQ1NBSFFRSjBRUVJySUFWc0VBNGFJQWtnQUNBQUtBS2NFaUlGSUFac1FRSjBha0VFYWlBRlFRSjBFQVFhSUFBb0FwUVNJZ2xCQVVnTkFDQUFRYlFnYWlnQ0FDRUVRUUFoQlFOQUlBQWdCQ0FCSUFWQkFuUnFJZ1pCRUdvb0FnQWdCR3NpQkVFUWRVR2FKR3hxSUFSQi8vOERjVUdhSkd4QkVIWnFJZ1EyQXJRZ0lBWW9BaEFpQmlBRVFSQjFRYnpxZm13Z0JHb2dCRUgvL3dOeFFienFmbXhCRUhWcVNBUkFJQUFnQmpZQ3RDQWdCaUVFQ3lBRlFRRnFJZ1VnQ1VjTkFBc0xJQUFvQXNBZ1JRMEJDeUFLSUFOQkFuUkJ6d0JxUVhCeGF5SUhKQUFnQUVHWUlXb29BZ0FpQVVFUWRFRVFkU0lGSUFCQmhDRnFMd0VBSWdSc1FSQjFJQVVnQkVFUWRDSUVRUjkxYkdvZ0FVRVBkVUVCYWtFQmRTQUVRUkIxYkdvaUJVRVFkU0VFQW44Z0JVSC8vLzhBVEVFQUlBQkJ0Q0JxS0FJQUlnRkJnWUNBQkVnYlJRUkFRUUFnQVVFUWRTSUJJQUZzSUFRZ0JHeEJCWFJySWdSQkFVZ05BUm9DUUVFWUlBUm5JZ0ZySWdWRkRRQWdCRUgvQUUwRVFDQUVJQUZCR0d0MElBUkJPQ0FCYTNaeUlRUU1BUXNnQkNBQlFRaHFkQ0FFSUFWMmNpRUVDeUFFUWY4QWNVR0FnTlFHYkVFUWRrR0FnQVJ5UVlDQUFrR0c2UUlnQVVFQmNSc2dBVUVCZG5ac1FZQ0FmSEVNQVF0QkFDQUJRUkIwUVJCMUlnWWdBVUVRZFd3Z0JVRVFkRUVRZFNJS0lBVkIvLzhEY1d4QkVIVWdCQ0FLYkdvZ0JVRVBkVUVCYWtFQmRpQUZiR3BCQlhScklBWWdBVUgvL3dOeGJFRVFkV29nQVVFUGRVRUJha0VCZFNBQmJHb2lCRUVCU0EwQUdnSkFRUmdnQkdjaUFXc2lCVVVOQUNBRVFmOEFUUVJBSUFRZ0FVRVlhM1FnQkVFNElBRnJkbkloQkF3QkN5QUVJQUZCQ0dwMElBUWdCWFp5SVFRTFFZQ0FBa0dHNlFJZ0FVRUJjUnNnQVVFQmRuWWlBU0FFUWY4QWNVR0FnTlFHYkVFUWRteEJFSFlnQVdwQkNIUUxJUUVnQjBGQWF5RUtRZjhCSVFVRFFDQUZJZ1JCQVhVaEJTQURJQVJJRFFBTElBQkJ1Q0JxS0FJQUlRWWdBMEVCU0NJSlJRUkFRUUFoQlFOQUlBb2dCVUVDZEdvZ0FDQUdRYldJenQwQWJFSHJ4dVd3QTJvaUJrRVlkU0FFY1VFQ2RHcEIxQlZxS0FJQU5nSUFJQVZCQVdvaUJTQURSdzBBQ3dzZ0FDQUdOZ0s0SUNBSUlBQkIxQjlxSUFBb0FxUVNJQUFvQXNnZ0VDc2dCeUFBUWF3Z2Fpa0NBRGNDT0NBSElBQkJwQ0JxS1FJQU53SXdJQWNnQUVHY0lHb3BBZ0EzQWlnZ0J5QUFRWlFnYWlrQ0FEY0NJQ0FISUFCQmpDQnFLUUlBTndJWUlBY2dBRUdFSUdvcEFnQTNBaEFnQnlBQVFmd2ZhaWtDQURjQ0NDQUhJQUJCOUI5cUlnc3BBZ0EzQWdBZ0NVVUVRQ0FCUVFwMFFSQjFJUXdnQUNnQ3BCSWlIa0VCZFNFZklBRkJGWFZCQVdwQkFYVWhJQ0FIS0FJY0lRVWdCeWdDSkNFR0lBY29BaXdoQ2lBSEtBSTBJUUVnQnlnQ1BDRUVJQWd1QVI0aERTQUlMZ0VjSVE0Z0NDNEJHaUVQSUFndUFSZ2hFQ0FJTGdFV0lSRWdDQzRCRkNFU0lBZ3VBUkloRXlBSUxnRVFJUlFnQ0M0QkRpRVZJQWd1QVF3aEZpQUlMZ0VLSVJjZ0NDNEJDQ0VZSUFndUFRWWhHU0FJTGdFRUlSb2dDQzRCQWlFYklBZ3VBUUFoSEVFQUlRQURRQ0FFUVJCMUlCeHNJQjlxSUFSQi8vOERjU0FjYkVFUWRXb2dBRUVDZENBSGFpSUVLQUk0SWdsQkVIVWdHMnhxSUFsQi8vOERjU0FiYkVFUWRXb2dBVUVRZFNBYWJHb2dBVUgvL3dOeElCcHNRUkIxYWlBRUtBSXdJZ0ZCRUhVZ0dXeHFJQUZCLy84RGNTQVpiRUVRZFdvZ0NrRVFkU0FZYkdvZ0NrSC8vd054SUJoc1FSQjFhaUFFS0FJb0lncEJFSFVnRjJ4cUlBcEIvLzhEY1NBWGJFRVFkV29nQmtFUWRTQVdiR29nQmtILy93TnhJQlpzUVJCMWFpQUVLQUlnSWdaQkVIVWdGV3hxSUFaQi8vOERjU0FWYkVFUWRXb2dCVUVRZFNBVWJHb2dCVUgvL3dOeElCUnNRUkIxYWlBRUtBSVlJZ1ZCRUhVZ0UyeHFJQVZCLy84RGNTQVRiRUVRZFdvaEJRSi9BbjhnSGtFUVJnUkFJQVVnQkNnQ0ZDSUZRUkIxSUJKc2FpQUZRZi8vQTNFZ0VteEJFSFZxSUFRb0FoQWlCVUVRZFNBUmJHb2dCVUgvL3dOeElCRnNRUkIxYWlBRUtBSU1JZ1ZCRUhVZ0VHeHFJQVZCLy84RGNTQVFiRUVRZFdvZ0JDZ0NDQ0lGUVJCMUlBOXNhaUFGUWYvL0EzRWdEMnhCRUhWcUlBUW9BZ1FpQlVFUWRTQU9iR29nQlVILy93TnhJQTVzUVJCMWFpQUVLQUlBSWdWQkVIVWdEV3hxSUFWQi8vOERjU0FOYkVFUWRXb2hCUXNnQlF0QmdJQ0FRQ0FGUVlDQWdFQktHeUlGUWYvLy96OGdCVUgvLy84L1NCdEJCSFFpQlNBSElBQkJFR3BCQW5ScUlpRW9BZ0FpQkdvaUhVRUFUZ1JBSUIxQmdJQ0FnSGdnQkNBRmNVRi9TaHNNQVF0Qi8vLy8vd2NnSFNBRUlBVnlRWDlLR3dzaEJDQWhJQVEyQWdBZ0FpQUFRUUYwYWlJRklBVXVBUUJCLy84QlFZQ0FmaUFFUVJCMUlBeHNJQVFnSUd4cUlBUkIvLzhEY1NBTWJFRVFkV29pQlVFSGRVRUJha0VCZFNBRlFZRC8vM3RJR3lBRlFmLysvd05LRzJvaUJVR0FnSDRnQlVHQWdINUtHeUlGUWYvL0FTQUZRZi8vQVVnYk93RUFJQVloQlNBS0lRWWdBU0VLSUFraEFTQUFRUUZxSWdBZ0EwY05BQXNMSUFzZ0J5QURRUUowYWlJQUtRSUFOd0lBSUFzZ0FDa0NPRGNDT0NBTElBQXBBakEzQWpBZ0N5QUFLUUlvTndJb0lBc2dBQ2tDSURjQ0lDQUxJQUFwQWhnM0FoZ2dDeUFBS1FJUU53SVFJQXNnQUNrQ0NEY0NDQXdCQ3lBQVFmUWZha0VBSUFBb0FxUVNRUUowRUFVYUN5QUlRU0JxSkFBTFZRRUVmMEgvL3dFZ0FDZ0NwQklpQWtFQmFtMGhCQ0FDUVFGT0JFQURRQ0FBSUFGQkFYUnFRZFFmYWlBRElBUnFJZ003QVFBZ0FVRUJhaUlCSUFKSERRQUxDeUFBUWJRZ2FrS0FnSUNBZ0pDZUdEY0NBQXR5QUFKQUlBTUVRRUVBSVFZZ0JVRUFUQTBCQTBBZ0FDQUJJQVpzSUFKcVFRSjBhaUFESUFRZ0JteEJBblJxS2dJQU9BSUFJQVpCQVdvaUJpQUZSdzBBQ3d3QkMwRUFJUVlnQlVFQVRBMEFBMEFnQUNBQklBWnNJQUpxUVFKMGFrRUFOZ0lBSUFaQkFXb2lCaUFGUncwQUN3c0xOd0VCZnlNQVFUQnJJZ0lrQUVFQ0VBd2FRUUVRREJvZ0FpQUJLQUlBTmdJQUlBQkJqQUpxSUFJUWlnRWhBQ0FDUVRCcUpBQWdBQXNsQVFGL0l3QkJFR3NpQWlRQUlBSWdBVFlDRENBQUlBRVFmQ0VBSUFKQkVHb2tBQ0FBQzVzR0FRMS9Jd0JCZ0FGcklnZ2hCeUFJSkFBQ1FDQUVRUUZJQkVCQmZ5RUZEQUVMSUFjZ0IwRUlhallDQUVGOUlRVWdBQ0FIRUgwTkFDQUlJQVFnQnlnQ0NFRVpiVUVEYkNJRklBUWdCVWdiSWdSQkEzUkJEMnBCY0hGcklnd2tBRUVDRUF3aEVFRUJFQXdoRVFKQUlBSkJBRWdFUUVGL0lRVU1BUXNnQWdSQVFYd2hCU0FBS0FJRUlncEJBWFJCQVdzZ0Frb05BUUpBSUFwQkFVZ05BQ0FLUVFGcklRNGdCeWdDQ0NFUFFRQWhDQ0FCSVFzZ0FpRUZBMEJCZkNFR0lBVkJBVWdOQVNBTElBVWdDU0FPUnlBSFFmOEFhaUFIUVJCcVFRQWdCMEVNYWhBM0lnWkJBRWdOQVNBTElBY29BZ3dnRHhDREFTRU5JQWtFUUVGOElRWWdDQ0FOUncwQ0N5QUZJQWNvQWd3aUNHc2hCU0FJSUF0cUlRc2dEU0lJSVFZZ0NVRUJhaUlKSUFwSERRQUxDeUFHUVg0Z0JrRUFTQnNoQlNBRUlBWklEUUVnQmtFQVNBMEJDeUFBS0FJRUlnVkJBVTRFUUNBQ1FRQkhJUXNnQUVHTUFtb2hDQ0FNUVFScUlRMGdBaUVKUVFBaEJnTkFJQXNnQ1VFQlNIRUVRRUY5SVFVTUF3c2dBQ2dDQ0NFS0lBZEJBRFlDRUNBSUlBRWdDU0FNSUFRZ0JpQUZRUUZyUnlBSFFSQnFFRTRpQkVFQlNBUkFJQVFoQlF3REN5QVFJQkVnQmlBS1NCdEJBMnBCZkhFaENpQUhLQUlRSWdWQkFDQUNHeUVPSUFFZ0JXb2hEd0pBSUFBb0FnZ2dCa3dFUUNBQUlBWkJmeEJJSWdWQmYwWU5BUU5BSUFNZ0FDZ0NBQ0FGSUF4QkFTQUVRUUJCQVJFSEFDQUFJQVlnQlJCSUlnVkJmMGNOQUFzTUFRc2dBQ0FHUVg4UVNpSUZRWDlIQkVBRFFDQURJQUFvQWdBZ0JTQU1RUUlnQkVFQVFRRVJCd0FnQUNBR0lBVVFTaUlGUVg5SERRQUxDeUFBSUFaQmZ4QkpJZ1ZCZjBZTkFBTkFJQU1nQUNnQ0FDQUZJQTFCQWlBRVFRQkJBUkVIQUNBQUlBWWdCUkJKSWdWQmYwY05BQXNMSUFnZ0Ntb2hDQ0FKSUE1cklRa2dEeUFCSUFJYklRRWdCa0VCYWlJR0lBQW9BZ1FpQlVnTkFBc0xRUUFoQmlBQUtBSUFJZ1ZCQUVvRVFBTkFJQUFnQm1vdEFBeEIvd0ZHQkVBZ0F5QUZJQVpCQUVFQUlBUkJBRUVCRVFjQUlBQW9BZ0FoQlFzZ0JrRUJhaUlHSUFWSURRQUxDeUFFSVFVTEN5QUhRWUFCYWlRQUlBVUxnZ0VCQVg4Q1FDQUJRUUZyUWY0QlN3UkFJQUpGRFFFZ0FrRi9OZ0lBUVFBUEMwRUNFQXhCQTJwQmZIRkJBWFJCQVJBTVFRTnFRWHh4UVFGMGFrR01BbW9RRlNJRFJRUkFRUUFoQXlBQ1JRMEJJQUpCZVRZQ0FFRUFEd3NnQXlBQUlBRVFnQUVoQUNBQ0JFQWdBaUFBTmdJQUN5QUFSUTBBSUFNUUNFRUFJUU1MSUFNTDdnRUJCSDlCZnlFRUFrQWdBa0VCYTBIK0FVc05BQ0FBUVFJMkFnZ2dBRUVFTmdJRUlBQWdBallDQUFOQUlBQWdBMm9nQTBHQUNHb3RBQUE2QUF3Z0EwRUJhaUlESUFKSERRQUxJQUFRZ2dGRkRRQWdBRUdNQW1vaEEwRUNFQXdoQWtFQkVBd2hCUUpBSUFBb0FnaEJBVWdFUUVFQUlRSU1BUXNnQWtFRGFrRjhjU0VHUVFBaEFnTkFJQU1nQVVFQ0VEQWlCQTBDSUFNZ0Jtb2hBeUFDUVFGcUlnSWdBQ2dDQ0VnTkFBc0xJQUFvQWdRZ0Frb0VRQ0FGUVFOcVFYeHhJUVVEUUNBRElBRkJBUkF3SWdRTkFpQURJQVZxSVFNZ0FrRUJhaUlDSUFBb0FnUklEUUFMQzBFQUlRUUxJQVFMaUFJQkEzOGpBRUVRYXlJREpBQUNRRUVBUVpEN0FTZ0NBQ0lDUlVHVSt3RW9BZ0FpQkJzTkFBSkFJQUlFUUNBQ0VBaEJrUHNCUVFBMkFnQU1BUXNnQkVVTkFDQUVFQWhCbFBzQlFRQTJBZ0FMUVpqN0FTZ0NBQ0lDUlEwQUEwQWdBaWdDQUJBSUlBSW9BZ1FoQkNBQ0VBZ2dCQ0lDRFFBTFFaajdBVUVBTmdJQUN5QURRUUEyQWd3Q1FDQUJRUUZyUVFGTkJFQkJrUHNCSUFBZ0FTQURRUXhxRUpjQk5nSUFEQUVMUVpUN0FTQUFJQUVnQTBFTWFoQi9OZ0lBQ3lBREtBSU1JZ0pCZjB3RVFDQURJQUpCQjJwQkIwMEVmMEhRT3lBQ1FRSjBheWdDQUFWQitUd0xOZ0lFSUFNZ0FqWUNBRUdHQ0NBREVCNGdBeWdDRENFQ0N5QURRUkJxSkFBZ0FndFhBUVIvSUFBb0FnZ2dBQ2dDQkdvaUFrSC9BVXdFUUNBQUtBSUFJZ05CQUV3RVFFRUJEd3NDUUFOQUlBQWdBV290QUF3aUJFSC9BVWRCQUNBQ0lBUk1HdzBCSUFGQkFXb2lBU0FEU0EwQUMwRUJEd3NMUVFBTGFnRUJmMEVCSVFNQ1FDQUJRUUZJQkVCQmZ5RUREQUVMQWtBQ1FBSkFJQUF0QUFCQkEzRkJBV3NPQXdBQUFRSUxRUUloQXd3QkMwRjhJUU1nQVVFQ1NBMEJJQUF0QUFGQlAzRWhBd3RCZkNBQUlBSVFPaUFEYkNJQUlBQkJHV3dnQWtFRGJFb2JEd3NnQXdzUUFDTUFJQUJyUVhCeElnQWtBQ0FBQ3dZQUlBQWtBQXNFQUNNQUM0TUJBZ04vQVg0Q1FDQUFRb0NBZ0lBUVZBUkFJQUFoQlF3QkN3TkFJQUZCQVdzaUFTQUFJQUJDQ29BaUJVSUtmbjJuUVRCeU9nQUFJQUJDLy8vLy81OEJWaUVDSUFVaEFDQUNEUUFMQ3lBRnB5SUNCRUFEUUNBQlFRRnJJZ0VnQWlBQ1FRcHVJZ05CQ214clFUQnlPZ0FBSUFKQkNVc2hCQ0FESVFJZ0JBMEFDd3NnQVFzdEFDQUFVRVVFUUFOQUlBRkJBV3NpQVNBQXAwRUhjVUV3Y2pvQUFDQUFRZ09JSWdCQ0FGSU5BQXNMSUFFTE5RQWdBRkJGQkVBRFFDQUJRUUZySWdFZ0FLZEJEM0ZCZ1BnQmFpMEFBQ0FDY2pvQUFDQUFRZ1NJSWdCQ0FGSU5BQXNMSUFFTFZnRUJmeU1BUVRCcklnSWtBQ0FBS0FJRUdpQUFLQUlBR2lBQ0lBRTJBaXdDZnlBQ0lBSW9BaXdpQVVFRWFqWUNMRUYvSUFFb0FnQWlBVVVOQUJvZ0FTQUFLQUlNTmdJQVFRQUxJUUVnQWtFd2FpUUFJQUVMeHdJQkEzOGpBRUhRQVdzaUF5UUFJQU1nQWpZQ3pBRkJBQ0VDSUFOQm9BRnFRUUJCS0JBRkdpQURJQU1vQXN3Qk5nTElBUUpBUVFBZ0FTQURRY2dCYWlBRFFkQUFhaUFEUWFBQmFoQXNRUUJJRFFBZ0FDZ0NURUVBVGlFQ0lBQW9BZ0FoQkNBQUxBQktRUUJNQkVBZ0FDQUVRVjl4TmdJQUN5QUVRU0J4SVFVQ2Z5QUFLQUl3QkVBZ0FDQUJJQU5CeUFGcUlBTkIwQUJxSUFOQm9BRnFFQ3dNQVFzZ0FFSFFBRFlDTUNBQUlBTkIwQUJxTmdJUUlBQWdBellDSENBQUlBTTJBaFFnQUNnQ0xDRUVJQUFnQXpZQ0xDQUFJQUVnQTBISUFXb2dBMEhRQUdvZ0EwR2dBV29RTENBRVJRMEFHaUFBUVFCQkFDQUFLQUlrRVFBQUdpQUFRUUEyQWpBZ0FDQUVOZ0lzSUFCQkFEWUNIQ0FBUVFBMkFoQWdBQ2dDRkJvZ0FFRUFOZ0lVUVFBTEdpQUFJQUFvQWdBZ0JYSTJBZ0FnQWtVTkFBc2dBMEhRQVdva0FBdXBBUUVEZndKQUlBRWdBaWdDRUNJRUJIOGdCQVVnQWhDTkFRMEJJQUlvQWhBTElBSW9BaFFpQld0TEJFQWdBaUFBSUFFZ0FpZ0NKQkVBQUJvUEN3SkFJQUlzQUV0QkFFZ05BQ0FCSVFRRFFDQUVJZ05GRFFFZ0FDQURRUUZySWdScUxRQUFRUXBIRFFBTElBSWdBQ0FESUFJb0FpUVJBQUFnQTBrTkFTQUFJQU5xSVFBZ0FTQURheUVCSUFJb0FoUWhCUXNnQlNBQUlBRVFCQm9nQWlBQ0tBSVVJQUZxTmdJVUN3dFpBUUYvSUFBZ0FDMEFTaUlCUVFGcklBRnlPZ0JLSUFBb0FnQWlBVUVJY1FSQUlBQWdBVUVnY2pZQ0FFRi9Ed3NnQUVJQU53SUVJQUFnQUNnQ0xDSUJOZ0ljSUFBZ0FUWUNGQ0FBSUFFZ0FDZ0NNR28yQWhCQkFBdUxBZ0FDUUNBQUJIOGdBVUgvQUUwTkFRSkFRZFQ2QVNnQ0FDZ0NBRVVFUUNBQlFZQi9jVUdBdndOR0RRTU1BUXNnQVVIL0QwMEVRQ0FBSUFGQlAzRkJnQUZ5T2dBQklBQWdBVUVHZGtIQUFYSTZBQUJCQWc4TElBRkJnTEFEVDBFQUlBRkJnRUJ4UVlEQUEwY2JSUVJBSUFBZ0FVRS9jVUdBQVhJNkFBSWdBQ0FCUVF4MlFlQUJjam9BQUNBQUlBRkJCblpCUDNGQmdBRnlPZ0FCUVFNUEN5QUJRWUNBQkd0Qi8vOC9UUVJBSUFBZ0FVRS9jVUdBQVhJNkFBTWdBQ0FCUVJKMlFmQUJjam9BQUNBQUlBRkJCblpCUDNGQmdBRnlPZ0FDSUFBZ0FVRU1ka0UvY1VHQUFYSTZBQUZCQkE4TEMwR2Mrd0ZCR1RZQ0FFRi9CVUVCQ3c4TElBQWdBVG9BQUVFQkM3b0JBUUYvSUFGQkFFY2hBZ0pBQWtBQ1FDQUJSUTBBSUFCQkEzRkZEUUFEUUNBQUxRQUFSUTBDSUFCQkFXb2hBQ0FCUVFGcklnRkJBRWNoQWlBQlJRMEJJQUJCQTNFTkFBc0xJQUpGRFFFTEFrQWdBQzBBQUVVTkFDQUJRUVJKRFFBRFFDQUFLQUlBSWdKQmYzTWdBa0dCZ29RSWEzRkJnSUdDaEhoeERRRWdBRUVFYWlFQUlBRkJCR3NpQVVFRFN3MEFDd3NnQVVVTkFBTkFJQUF0QUFCRkJFQWdBQThMSUFCQkFXb2hBQ0FCUVFGcklnRU5BQXNMUVFBTEJBQkNBQXNFQUVFQUMvb0NBUWQvSXdCQklHc2lBeVFBSUFNZ0FDZ0NIQ0lGTmdJUUlBQW9BaFFoQkNBRElBSTJBaHdnQXlBQk5nSVlJQU1nQkNBRmF5SUJOZ0lVSUFFZ0Ftb2hCVUVDSVFjZ0EwRVFhaUVCQW44Q1FBSkFBbjlCQUNBQUtBSThJQU5CRUdwQkFpQURRUXhxRUFBaUJFVU5BQnBCblBzQklBUTJBZ0JCZnd0RkJFQURRQ0FGSUFNb0Fnd2lCRVlOQWlBRVFYOU1EUU1nQVNBRUlBRW9BZ1FpQ0VzaUJrRURkR29pQ1NBRUlBaEJBQ0FHRzJzaUNDQUpLQUlBYWpZQ0FDQUJRUXhCQkNBR0cyb2lDU0FKS0FJQUlBaHJOZ0lBSUFVZ0JHc2hCUUovUVFBZ0FDZ0NQQ0FCUVFocUlBRWdCaHNpQVNBSElBWnJJZ2NnQTBFTWFoQUFJZ1JGRFFBYVFaejdBU0FFTmdJQVFYOExSUTBBQ3dzZ0JVRi9SdzBCQ3lBQUlBQW9BaXdpQVRZQ0hDQUFJQUUyQWhRZ0FDQUJJQUFvQWpCcU5nSVFJQUlNQVFzZ0FFRUFOZ0ljSUFCQ0FEY0RFQ0FBSUFBb0FnQkJJSEkyQWdCQkFDQUhRUUpHRFFBYUlBSWdBU2dDQkdzTElRQWdBMEVnYWlRQUlBQUx1QTRDRUg4Q2ZDTUFRYkFFYXlJR0pBQWdBaUFDUVFOclFSaHRJZ1JCQUNBRVFRQktHeUlOUVdoc2FpRUlRZlRkQVNnQ0FDSUpJQU5CQVdzaUIycEJBRTRFUUNBRElBbHFJUVFnRFNBSGF5RUNBMEFnQmtIQUFtb2dCVUVEZEdvZ0FrRUFTQVI4UkFBQUFBQUFBQUFBQlNBQ1FRSjBRWURlQVdvb0FnQzNDemtEQUNBQ1FRRnFJUUlnQlVFQmFpSUZJQVJIRFFBTEN5QUlRUmhySVFwQkFDRUVJQWxCQUNBSlFRQktHeUVGSUFOQkFVZ2hDd05BQWtBZ0N3UkFSQUFBQUFBQUFBQUFJUlFNQVFzZ0JDQUhhaUVNUVFBaEFrUUFBQUFBQUFBQUFDRVVBMEFnRkNBQUlBSkJBM1JxS3dNQUlBWkJ3QUpxSUF3Z0FtdEJBM1JxS3dNQW9xQWhGQ0FDUVFGcUlnSWdBMGNOQUFzTElBWWdCRUVEZEdvZ0ZEa0RBQ0FFSUFWR0lRSWdCRUVCYWlFRUlBSkZEUUFMUVM4Z0NHc2hFRUV3SUFocklRNGdDRUVaYXlFUklBa2hCQUpBQTBBZ0JpQUVRUU4wYWlzREFDRVVRUUFoQWlBRUlRVWdCRUVCU0NJSFJRUkFBMEFnQmtIZ0Eyb2dBa0VDZEdvQ2Z5QVVBbjhnRkVRQUFBQUFBQUJ3UHFJaUZKbEVBQUFBQUFBQTRFRmpCRUFnRktvTUFRdEJnSUNBZ0hnTHR5SVVSQUFBQUFBQUFIREJvcUFpRlpsRUFBQUFBQUFBNEVGakJFQWdGYW9NQVF0QmdJQ0FnSGdMTmdJQUlBWWdCVUVCYXlJRlFRTjBhaXNEQUNBVW9DRVVJQUpCQVdvaUFpQUVSdzBBQ3dzQ2Z5QVVJQW9RRkNJVUlCUkVBQUFBQUFBQXdEK2luRVFBQUFBQUFBQWd3S0tnSWhTWlJBQUFBQUFBQU9CQll3UkFJQlNxREFFTFFZQ0FnSUI0Q3lFTElCUWdDN2VoSVJRQ1FBSkFBa0FDZnlBS1FRRklJaEpGQkVBZ0JFRUNkQ0FHYWlJQ0lBSW9BdHdESWdJZ0FpQU9kU0lDSUE1MGF5SUZOZ0xjQXlBQ0lBdHFJUXNnQlNBUWRRd0JDeUFLRFFFZ0JFRUNkQ0FHYWlnQzNBTkJGM1VMSWd4QkFVZ05BZ3dCQzBFQ0lRd2dGRVFBQUFBQUFBRGdQMlpCQVhORkRRQkJBQ0VNREFFTFFRQWhBa0VBSVFVZ0IwVUVRQU5BSUFaQjRBTnFJQUpCQW5ScUloTW9BZ0FoRDBILy8vOEhJUWNDZndKQUlBVU5BRUdBZ0lBSUlRY2dEdzBBUVFBTUFRc2dFeUFISUE5ck5nSUFRUUVMSVFVZ0FrRUJhaUlDSUFSSERRQUxDd0pBSUJJTkFBSkFBa0FnRVE0Q0FBRUNDeUFFUVFKMElBWnFJZ0lnQWlnQzNBTkIvLy8vQTNFMkF0d0REQUVMSUFSQkFuUWdCbW9pQWlBQ0tBTGNBMEgvLy84QmNUWUMzQU1MSUF0QkFXb2hDeUFNUVFKSERRQkVBQUFBQUFBQThEOGdGS0VoRkVFQ0lRd2dCVVVOQUNBVVJBQUFBQUFBQVBBL0lBb1FGS0VoRkFzZ0ZFUUFBQUFBQUFBQUFHRUVRRUVBSVFVQ1FDQUpJQVFpQWs0TkFBTkFJQVpCNEFOcUlBSkJBV3NpQWtFQ2RHb29BZ0FnQlhJaEJTQUNJQWxLRFFBTElBVkZEUUFnQ2lFSUEwQWdDRUVZYXlFSUlBWkI0QU5xSUFSQkFXc2lCRUVDZEdvb0FnQkZEUUFMREFNTFFRRWhBZ05BSUFJaUJVRUJhaUVDSUFaQjRBTnFJQWtnQld0QkFuUnFLQUlBUlEwQUN5QUVJQVZxSVFVRFFDQUdRY0FDYWlBRElBUnFJZ2RCQTNScUlBUkJBV29pQkNBTmFrRUNkRUdBM2dGcUtBSUF0emtEQUVFQUlRSkVBQUFBQUFBQUFBQWhGQ0FEUVFGT0JFQURRQ0FVSUFBZ0FrRURkR29yQXdBZ0JrSEFBbW9nQnlBQ2EwRURkR29yQXdDaW9DRVVJQUpCQVdvaUFpQURSdzBBQ3dzZ0JpQUVRUU4wYWlBVU9RTUFJQVFnQlVnTkFBc2dCU0VFREFFTEN3SkFJQlJCR0NBSWF4QVVJaFJFQUFBQUFBQUFjRUZtUVFGelJRUkFJQVpCNEFOcUlBUkJBblJxQW44Z0ZBSi9JQlJFQUFBQUFBQUFjRDZpSWhTWlJBQUFBQUFBQU9CQll3UkFJQlNxREFFTFFZQ0FnSUI0Q3lJQ3QwUUFBQUFBQUFCd3dhS2dJaFNaUkFBQUFBQUFBT0JCWXdSQUlCU3FEQUVMUVlDQWdJQjRDellDQUNBRVFRRnFJUVFNQVFzQ2Z5QVVtVVFBQUFBQUFBRGdRV01FUUNBVXFnd0JDMEdBZ0lDQWVBc2hBaUFLSVFnTElBWkI0QU5xSUFSQkFuUnFJQUkyQWdBTFJBQUFBQUFBQVBBL0lBZ1FGQ0VVQWtBZ0JFRi9UQTBBSUFRaEFnTkFJQVlnQWtFRGRHb2dGQ0FHUWVBRGFpQUNRUUowYWlnQ0FMZWlPUU1BSUJSRUFBQUFBQUFBY0Q2aUlSUWdBa0VBU2lFQUlBSkJBV3NoQWlBQURRQUxRUUFoQnlBRVFRQklEUUFnQ1VFQUlBbEJBRW9iSVFBZ0JDRUZBMEFnQUNBSElBQWdCMGtiSVFNZ0JDQUZheUVJUVFBaEFrUUFBQUFBQUFBQUFDRVVBMEFnRkNBQ1FRTjBRZER6QVdvckF3QWdCaUFDSUFWcVFRTjBhaXNEQUtLZ0lSUWdBaUFEUnlFS0lBSkJBV29oQWlBS0RRQUxJQVpCb0FGcUlBaEJBM1JxSUJRNUF3QWdCVUVCYXlFRklBUWdCMGNoQWlBSFFRRnFJUWNnQWcwQUN3dEVBQUFBQUFBQUFBQWhGQ0FFUVFCT0JFQWdCQ0VDQTBBZ0ZDQUdRYUFCYWlBQ1FRTjBhaXNEQUtBaEZDQUNRUUJLSVFBZ0FrRUJheUVDSUFBTkFBc0xJQUVnRkpvZ0ZDQU1HemtEQUNBR0t3T2dBU0FVb1NFVVFRRWhBaUFFUVFGT0JFQURRQ0FVSUFaQm9BRnFJQUpCQTNScUt3TUFvQ0VVSUFJZ0JFY2hBQ0FDUVFGcUlRSWdBQTBBQ3dzZ0FTQVVtaUFVSUF3Yk9RTUlJQVpCc0FScUpBQWdDMEVIY1F2TUNRTUZmd0YrQkh3akFFRXdheUlFSkFBQ1FBSkFBa0FnQUwwaUIwSWdpS2NpQWtILy8vLy9CM0VpQTBINjFMMkFCRTBFUUNBQ1FmLy9QM0ZCKzhNa1JnMEJJQU5CL0xLTGdBUk5CRUFnQjBJQVdRUkFJQUVnQUVRQUFFQlUreUg1djZBaUFFUXhZMklhWWJUUXZhQWlDRGtEQUNBQklBQWdDS0ZFTVdOaUdtRzAwTDJnT1FNSVFRRWhBZ3dGQ3lBQklBQkVBQUJBVlBzaCtUK2dJZ0JFTVdOaUdtRzAwRDJnSWdnNUF3QWdBU0FBSUFpaFJERmpZaHBodE5BOW9Ea0RDRUYvSVFJTUJBc2dCMElBV1FSQUlBRWdBRVFBQUVCVSt5RUp3S0FpQUVReFkySWFZYlRndmFBaUNEa0RBQ0FCSUFBZ0NLRkVNV05pR21HMDRMMmdPUU1JUVFJaEFnd0VDeUFCSUFCRUFBQkFWUHNoQ1VDZ0lnQkVNV05pR21HMDREMmdJZ2c1QXdBZ0FTQUFJQWloUkRGallocGh0T0E5b0RrRENFRitJUUlNQXdzZ0EwRzdqUEdBQkUwRVFDQURRYno3MTRBRVRRUkFJQU5CL0xMTGdBUkdEUUlnQjBJQVdRUkFJQUVnQUVRQUFEQi9mTmtTd0tBaUFFVEtsSk9ua1E3cHZhQWlDRGtEQUNBQklBQWdDS0ZFeXBTVHA1RU82YjJnT1FNSVFRTWhBZ3dGQ3lBQklBQkVBQUF3ZjN6WkVrQ2dJZ0JFeXBTVHA1RU82VDJnSWdnNUF3QWdBU0FBSUFpaFJNcVVrNmVSRHVrOW9Ea0RDRUY5SVFJTUJBc2dBMEg3dytTQUJFWU5BU0FIUWdCWkJFQWdBU0FBUkFBQVFGVDdJUm5Bb0NJQVJERmpZaHBodFBDOW9DSUlPUU1BSUFFZ0FDQUlvVVF4WTJJYVliVHd2YUE1QXdoQkJDRUNEQVFMSUFFZ0FFUUFBRUJVK3lFWlFLQWlBRVF4WTJJYVliVHdQYUFpQ0RrREFDQUJJQUFnQ0tGRU1XTmlHbUcwOEQyZ09RTUlRWHdoQWd3REN5QURRZnJENUlrRVN3MEJDeUFCSUFBZ0FFU0R5TWx0TUYva1A2SkVBQUFBQUFBQU9FT2dSQUFBQUFBQUFEakRvQ0lKUkFBQVFGVDdJZm0vb3FBaUNDQUpSREZqWWhwaHROQTlvaUlMb1NJQU9RTUFJQU5CRkhZaUJTQUF2VUkwaUtkQi93OXhhMEVSU0NFREFuOGdDWmxFQUFBQUFBQUE0RUZqQkVBZ0Nhb01BUXRCZ0lDQWdIZ0xJUUlDUUNBRERRQWdBU0FJSUFsRUFBQmdHbUcwMEQyaUlnQ2hJZ29nQ1VSemNBTXVpaG1qTzZJZ0NDQUtvU0FBb2FFaUM2RWlBRGtEQUNBRklBQzlRalNJcDBIL0QzRnJRVEpJQkVBZ0NpRUlEQUVMSUFFZ0NpQUpSQUFBQUM2S0dhTTdvaUlBb1NJSUlBbEV3VWtnSlpxRGV6bWlJQW9nQ0tFZ0FLR2hJZ3VoSWdBNUF3QUxJQUVnQ0NBQW9TQUxvVGtEQ0F3QkN5QURRWUNBd1A4SFR3UkFJQUVnQUNBQW9TSUFPUU1BSUFFZ0FEa0RDRUVBSVFJTUFRc2dCMEwvLy8vLy8vLy9CNE5DZ0lDQWdJQ0FnTERCQUlTL0lRQkJBQ0VDUVFFaEJRTkFJQVJCRUdvZ0FrRURkR29DZnlBQW1VUUFBQUFBQUFEZ1FXTUVRQ0FBcWd3QkMwR0FnSUNBZUF1M0lnZzVBd0FnQUNBSW9VUUFBQUFBQUFCd1FhSWhBRUVCSVFJZ0JVRUJjU0VHUVFBaEJTQUdEUUFMSUFRZ0FEa0RJQUpBSUFCRUFBQUFBQUFBQUFCaUJFQkJBaUVDREFFTFFRRWhCUU5BSUFVaUFrRUJheUVGSUFSQkVHb2dBa0VEZEdvckF3QkVBQUFBQUFBQUFBQmhEUUFMQ3lBRVFSQnFJQVFnQTBFVWRrR1dDR3NnQWtFQmFoQ1RBU0VDSUFRckF3QWhBQ0FIUW45WEJFQWdBU0FBbWprREFDQUJJQVFyQXdpYU9RTUlRUUFnQW1zaEFnd0JDeUFCSUFBNUF3QWdBU0FFS3dNSU9RTUlDeUFFUVRCcUpBQWdBZ3V2QXdFRWZRSkFJQUlFUUVOOUhaQW1JUVlnQTBFQlNBUkFRMzBka0NZaEJRd0NDMEVBSVFKRGZSMlFKaUVGQTBBZ0JTQUFJQUpCQW5RaUJHb3FBZ0FpQnlBQklBUnFLZ0lBSWdpVElnVWdCWlNTSVFVZ0JpQUhJQWlTSWdZZ0JwU1NJUVlnQWtFQmFpSUNJQU5IRFFBTERBRUxJQU5CQVVnRVFFTjlIWkFtSVFWRGZSMlFKaUVHREFFTFFRQWhBZ05BSUFZZ0FDQUNRUUowYWlvQ0FDSUZJQVdVa2lFR0lBSkJBV29pQWlBRFJ3MEFDeUFHUTMwZGtDYVNJUVpCQUNFQ1F3QUFBQUFoQlFOQUlBVWdBU0FDUVFKMGFpb0NBQ0lGSUFXVWtpRUZJQUpCQVdvaUFpQURSdzBBQ3lBRlEzMGRrQ2FTSVFVTEFuMURBQUFBQUNBRmtTSUlJQWlVSWdVZ0JwRWlCeUFIbENJR2trUHZrcE1oWFEwQUdrUGJEOGsvSUFnZ0I1UWdCU0FHUXdYNDNENlVrcFFnQlNBR1F5R3hMVCtVa2lBRklBWkRaUW13UFpTU2xKV1RJQVVnQmw1QkFYTkZEUUFhSUFnZ0I1UWdCaUFGUXdYNDNENlVrcFFnQmlBRlF5R3hMVCtVa2lBR0lBVkRaUW13UFpTU2xKVkQydy9KUDVKRDJ3L0p2NUlMUTRmNUlrYVVRd0FBQUQrU2ppSUZpME1BQUFCUFhRUkFJQVdvRHd0QmdJQ0FnSGdMOEFFQkJIOGpBQ0lISVFvZ0FVRUJJQUZCQVVvYklRZ2dCeUFCUVFKMFFROXFRWEJ4YXlJSEpBQkRBQUNBUHlBSElBRWdBaUFGRUZlUmxTQUdsQ0VHUVFBaEJRTkFJQUFnQlVFQ2RDSUphaUFHSUFjZ0NXb29BZ0N5bERnQ0FDQUZRUUZxSWdVZ0NFY05BQXNnQUNBQlFYOGdCQ0FDSUFNUUwwRUJJUUlnQkVFQ1RnUkFJQUVnQkc0aUEwRUJJQU5CQVVvYklRaEJBQ0VDUVFBaEFRTkFJQUVnQTJ3aENVRUFJUVZCQUNFQUEwQWdCeUFGSUFscVFRSjBhaWdDQUNBQWNpRUFJQVZCQVdvaUJTQUlSdzBBQ3lBQVFRQkhJQUYwSUFKeUlRSWdBVUVCYWlJQklBUkhEUUFMQ3lBS0pBQWdBZ3Y0QVFFQ2Z5TUFRUkJySWdNa0FBSkFBa0FDUUFKQUlBQkIvL3dBVEFSQUlBQkJ3RDVHRFFFZ0FFSGczUUJHRFFFTUFnc2dBRUdBL1FCR0RRQWdBRUdBOXdKR0RRQWdBRUhBdXdGSERRRUxJQUZCQVd0QkFra05BUXNnQWtVTkFTQUNRWDgyQWdBTUFRc0NmeUFEUWVqQ0FEWUNERUVBQ3dSL1FRQUZJQU1nQXlnQ0RFRURha0Y4Y1RZQ0RDQURLQUlNUWFBOUtBSUFRUUowUWVEQUFHb2dBV3hCcEQwb0FnQkJCWFJxYWtHMEFXb0xFQlVpQkVVRVFFRUFJUVFnQWtVTkFTQUNRWGsyQWdBTUFRc2dCQ0FBSUFFUU1DRUFJQUlFUUNBQ0lBQTJBZ0FMSUFCRkRRQWdCQkFJUVFBaEJBc2dBMEVRYWlRQUlBUUxsQUlDQTM4QmZTTUFJZ2doQ2lBSUlBRkJBblJCRzJwQmNIRnJJZ2drQUVFQklRa2dBQ0FCUVFFZ0JDQUNJQU1RTHlBQUlBZ2dBaUFCRUprQklRd2dDQ0FCSUFJZ0JSQllJQWNFUUNBQlFRRWdBVUVCU2hzaEJVTUFBSUEvSUF5UmxTQUdsQ0VHUVFBaEJ3TkFJQUFnQjBFQ2RDSUxhaUFHSUFnZ0Myb29BZ0N5bERnQ0FDQUhRUUZxSWdjZ0JVY05BQXNnQUNBQlFYOGdCQ0FDSUFNUUx3c2dCRUVDVGdSQUlBRWdCRzRpQUVFQklBQkJBVW9iSVFKQkFDRUpRUUFoQVFOQUlBQWdBV3doQTBFQUlRZEJBQ0VGQTBBZ0NDQURJQWRxUVFKMGFpZ0NBQ0FGY2lFRklBZEJBV29pQnlBQ1J3MEFDeUFGUVFCSElBRjBJQWx5SVFrZ0FVRUJhaUlCSUFSSERRQUxDeUFLSkFBZ0NRdnpCUUlJZndkOUl3QWlCQ0VLSUFRZ0EwRUNkRUVQYWtGd2NTSUVheUlGSWdja0FDQUhJQVJySWdra0FDQUZRUUFnQTBFQklBTkJBVW9iSWdoQkFuUVFCU0VIUVFBaEJBTkFJQWtnQkVFQ2RDSUZhaUFBSUFWcUlnWXFBZ0FpREVNQUFBQUFYVFlDQUNBR0lBeUxPQUlBSUFFZ0JXcEJBRFlDQUNBRVFRRnFJZ1FnQ0VjTkFBdERBQUFBQUNFTUlBTkJBWFVnQWtnRVFFRUFJUVFEUUNBTUlBQWdCRUVDZEdvcUFnQ1NJUXdnQkVFQmFpSUVJQWhIRFFBTElBS3lRODNNVEQrU1F3QUFnRDhnREVOOUhaQW1Ya0VCYzBWQkFDQU1Rd0FBZ0VKZEd3UjlJQXdGSUFCQmdJQ0EvQU0yQWdBZ0FFRUVha0VBSUFOQkFpQURRUUpLRzBFQ2RFRUVheEFGR2tNQUFJQS9DNVdVSVE5QkFDRUZRd0FBQUFBaERBTkFJQUVnQlVFQ2RDSUVhZ0ovSUE4Z0FDQUVhaW9DQUNJUWxJNGlEWXREQUFBQVQxMEVRQ0FOcUF3QkMwR0FnSUNBZUFzaUJqWUNBQ0FFSUFkcUlBYXlJZzBnRFpJNEFnQWdEaUFRSUEyVWtpRU9JQUlnQm1zaEFpQU1JQTBnRFpTU0lRd2dCVUVCYWlJRklBaEhEUUFMQ3dKQUlBTkJBMm9nQWtnRVFDQUhLZ0lBSVE0Z0FTQUJLQUlBSUFKcU5nSUFJQXdnQXJJaURDQU1sSklnRGlBTWxKSWhEQXdCQ3lBQ1FRRklEUUFnQTBFQ0lBTkJBa29iSVFzZ0FDb0NBQ0VRUVFBaEF3TkFJQXhEQUFDQVA1SWlEeUFIS2dJQWtpRU1JQTRnRUpJaURTQU5sQ0VOUVFFaEJFRUFJUVVEUUNBUElBY2dCRUVDZENJR2Fpb0NBSklpRVNBTUlBd2dEaUFBSUFacUtnSUFraUlNSUF5VUloS1VJQTBnRVpSZUlnWWJJUXdnRWlBTklBWWJJUTBnQkNBRklBWWJJUVVnQkVFQmFpSUVJQXRIRFFBTElBQWdCVUVDZENJRWFpb0NBQ0VOSUFRZ0Iyb2lCU0FGS2dJQUlneERBQUFBUUpJNEFnQWdBU0FFYWlJRUlBUW9BZ0JCQVdvMkFnQWdEeUFNa2lFTUlBNGdEWkloRGlBRFFRRnFJZ01nQWtjTkFBc0xRUUFoQkFOQUlBRWdCRUVDZENJQWFpSUNJQUlvQWdCQkFDQUFJQWxxS0FJQUlnQnJjeUFBYWpZQ0FDQUVRUUZxSWdRZ0NFY05BQXNnQ2lRQUlBd0wvQUlCQkg4Z0FDZ0NIQ0lESUFOQkFuWWlBbXNoQXdKQUlBRkZCRUFnQXlFQ0RBRUxJQUFnQUNnQ0lDQURhallDSUFzZ0FDQUNOZ0ljSUFKQmdJQ0FCRTBFUUNBQUtBSWdJUUVEUUFKQUlBRkJGM1lpQlVIL0FVY0VRQ0FCUVI5MklRSWdBQ2dDS0NJQlFRQk9CRUFnQUNBQUtBSUVJQUFvQWhnaUF5QUFLQUlJYWtzRWZ5QUFJQU5CQVdvMkFoZ2dBQ2dDQUNBRGFpQUJJQUpxT2dBQVFRQUZRWDhMSUFBb0FpeHlOZ0lzQ3lBQUtBSWtJZ0VFUUNBQ1FRRnJJUU1EUUVGL0lRSWdBQ0FBS0FJRUlBQW9BaGdpQkNBQUtBSUlha3NFZnlBQUlBUkJBV28yQWhnZ0FDZ0NBQ0FFYWlBRE9nQUFRUUFoQWlBQUtBSWtCU0FCQzBFQmF5SUJOZ0lrSUFBZ0FDZ0NMQ0FDY2pZQ0xDQUJEUUFMQ3lBQUlBVkIvd0Z4TmdJb0lBQW9BaHdoQWlBQUtBSWdJUUVNQVFzZ0FDQUFLQUlrUVFGcU5nSWtDeUFBSUFKQkNIUWlBallDSENBQUlBRkJDSFJCZ1A3Ly93ZHhJZ0UyQWlBZ0FDQUFLQUlVUVFocU5nSVVJQUpCZ1lDQUJFa05BQXNMQy9rYkFSbC9Jd0FpRUNFbUlBaEJBQ0FJUVFCS0d5SUlJQWhCQjBwQkEzUWlKR3NoRmlBQUtBSUlJUlFDUUNBTlFRSkhEUUFnQWlBQmEwR3czUUZxTFFBQUlod2dGa29FUUVFQUlSd01BUXNnRmlBY2F5SUlJQWhCQjBwQkEzUWlKV3NoRmdzZ0VDQVVRUUowUVE5cVFYQnhJZ2hySWhraUVDUUFJQkFnQ0dzaUdpSVFKQUFnRUNBSWF5SWJJaEFrQUNBTlFRTjBJUmNnRUNBSWF5SWRKQUFDUUFKQUFrQWdBU0FDU0NJVFJRUkFJQUJCTkdvaEhpQUFRU0JxSVNBZ0FDZ0NNQ0lpUVFGcklSRU1BUXNnRGtFRGFpRVJJQVVnRG10QkJXc2dEV3doRlNBQUtBSWdJaUFnQVVFQmRHb3ZBUUFoRWlBQklRZ0RRQ0FTUVJCMElSQWdHeUFJUVFKMEloaHFJQmNnSUNBSVFRRnFJZ1ZCQVhScUxnRUFJaElnRUVFUWRXc2lFRUVEYkNBT2RFRURkRUVFZFNJZUlCY2dIa29iTmdJQUlCZ2dIV29nRlNBSVFYOXpJQUpxYkNBUWJDQVJkRUVHZFNBWFFRQWdFQ0FPZEVFQlJodHJOZ0lBSUFVaUNDQUNSdzBBQ3lBQVFUUnFJUjRnQUVFZ2FpRWdJQUFvQWpBaUlrRUJheUVSSUJNTkFRc2dGa0VBU0NFRlFRRWhGUU5BSUJVZ0VTQVZha0VCZFNJSVFRRnFJQVViSWhVZ0NFRUJheUFSSUFVYkloRk1EUUFMREFFTElBQW9BaUFpSXlBQ1FRRjBhaThCQUNFRklBQW9BalFoSjBFQklSVURRQ0FSSUJWcVFRRjFJaUVnRkd3aEtDQUZJUkJCQUNFU1FRQWhFeUFDSVFnRFFDQVFRUkIwUVJCMUlDTWdDRUVCYXlJSVFRRjBhaTRCQUNJUWF5QU5iQ0FuSUFnZ0tHcHFMUUFBYkNBT2RDSWZRUUoxSVJnZ0gwRUVUZ1IvSUIwZ0NFRUNkR29vQWdBZ0dHb2lHRUVBSUJoQkFFb2JCU0FZQ3lBRElBaEJBblFpSDJvb0FnQnFJUmdDZndKQUlCTU5BQ0FZSUJzZ0gyb29BZ0JPRFFCQkFDRVRRUUFnRnlBWElCaEtHd3dCQzBFQklSTWdHQ0FFSUI5cUtBSUFJaDhnR0NBZlNCc0xJQkpxSVJJZ0FTQUlTQTBBQ3lBVklDRkJBV29nRWlBV1NpSUlHeUlWSUNGQkFXc2dFU0FJR3lJUlRBMEFDd3RCQUNFSUlBRWhCUUpBSUFFZ0FrNGlJdzBBSUJWQkFXc2dGR3doSVNBZ0tBSUFJaDhnQVVFQmRHb3ZBUUFoRUNBZUtBSUFJUmdDUUNBVklDSklCRUFnRkNBVmJDRWlJQUVpQ0NFRkEwQWdFRUVRZENFUklCOGdDRUVCYWlJU1FRRjBhaTRCQUNJUUlCRkJFSFZySUExc0loTWdHQ0FJSUNKcWFpMEFBR3dnRG5RaEVTQVRJQmdnQ0NBaGFtb3RBQUJzSUE1MEloUkJBblVoRXlBVVFRUk9CRUFnSFNBSVFRSjBhaWdDQUNBVGFpSVRRUUFnRTBFQVNoc2hFd3NnRVVFQ2RTRVVJQkZCQkU0RVFDQWRJQWhCQW5ScUtBSUFJQlJxSWhGQkFDQVJRUUJLR3lFVUN5QVpJQWhCQW5RaUVXb2dFeUFESUJGcUtBSUFJaDVCQUNBVlFRRktHMm9pRXpZQ0FDQVJJQnBxSUI0Z0ZDQVRhMm9pRVVFQUlCRkJBRW9iTmdJQUlBZ2dCU0FlUVFCS0d5RUZJQklpQ0NBQ1J3MEFDd3dCQ3lBQkloRWhCUU5BSUJCQkVIUWhFaUFZSUJFZ0lXcHFMUUFBSUI4Z0VVRUJhaUlJUVFGMGFpNEJBQ0lRSUJKQkVIVnJJQTFzYkNBT2RDSWVRUUoxSVJRZ0JDQVJRUUowSWhOcUtBSUFJUklnSGtFRVRnUkFJQk1nSFdvb0FnQWdGR29pRkVFQUlCUkJBRW9iSVJRTElCSkJBVTRFUUNBVElCMXFLQUlBSUJKcUloSkJBQ0FTUVFCS0d5RVNDeUFUSUJscUlCUWdBeUFUYWlnQ0FDSWVRUUFnRlVFQlNodHFJaFEyQWdBZ0V5QWFhaUFlSUJJZ0ZHdHFJaEpCQUNBU1FRQktHellDQUNBUklBVWdIa0VBU2hzaEJTQUlJaEVnQWtjTkFBc0xRUUFoQ0NBakRRQWdBaUVRUVFBaEV3TkFJQm9nRUVFQmF5SVFRUUowSWhKcUtBSUFRUUYxSUJJZ0dXb29BZ0JxSVFNQ2Z3SkFJQk1OQUNBRElCSWdHMm9vQWdCT0RRQkJBQ0VUUVFBZ0Z5QURJQmRJR3d3QkMwRUJJUk1nQXlBRUlCSnFLQUlBSWhJZ0F5QVNTQnNMSUFocUlRZ2dBU0FRU0EwQUMwRVFRVEFnQ0NBV1NpSURHeUVWUVNCQndBQWdBeHNoRkVFQUlSTWdBaUVRUVFBaEF3TkFJQm9nRUVFQmF5SVFRUUowSWhGcUtBSUFJQlZzUVFaMUlCRWdHV29vQWdCcUlSSUNmd0pBSUFNTkFDQVNJQkVnRzJvb0FnQk9EUUJCQUNBWElCSWdGMGdiSVJGQkFBd0JDeUFTSUFRZ0VXb29BZ0FpQXlBRElCSktHeUVSUVFFTElRTWdFU0FUYWlFVElBRWdFRWdOQUFzZ0NDQVdURUVGZENBVklCTWdGa29pQXhzaUhTQVZJQlFnQXhzaUZXcEJBWFloQ0VFQUlSQWdBaUVTUVFBaEV3TkFJQm9nRWtFQmF5SVNRUUowSWhGcUtBSUFJQWhzUVFaMUlCRWdHV29vQWdCcUlRTUNmd0pBSUJNTkFDQURJQkVnRzJvb0FnQk9EUUJCQUNFVFFRQWdGeUFESUJkSUd3d0JDMEVCSVJNZ0F5QUVJQkZxS0FJQUloRWdBeUFSU0JzTElCQnFJUkFnQVNBU1NBMEFDeUFkSUFnZ0VDQVdTaUlER3lJVUlBZ2dGU0FER3lJVmFrRUJkaUVJUVFBaEVDQUNJUkpCQUNFVEEwQWdHaUFTUVFGckloSkJBblFpRVdvb0FnQWdDR3hCQm5VZ0VTQVphaWdDQUdvaEF3Si9Ba0FnRXcwQUlBTWdFU0FiYWlnQ0FFNE5BRUVBSVJOQkFDQVhJQU1nRjBnYkRBRUxRUUVoRXlBRElBUWdFV29vQWdBaUVTQURJQkZJR3dzZ0VHb2hFQ0FCSUJKSURRQUxJQlFnQ0NBUUlCWktJZ01iSWhRZ0NDQVZJQU1iSWhWcVFRRjJJUWhCQUNFUUlBSWhFa0VBSVJNRFFDQWFJQkpCQVdzaUVrRUNkQ0lSYWlnQ0FDQUliRUVHZFNBUklCbHFLQUlBYWlFREFuOENRQ0FURFFBZ0F5QVJJQnRxS0FJQVRnMEFRUUFoRTBFQUlCY2dBeUFYU0JzTUFRdEJBU0VUSUFNZ0JDQVJhaWdDQUNJUklBTWdFVWdiQ3lBUWFpRVFJQUVnRWtnTkFBc2dGQ0FJSUJBZ0Zrb2lBeHNpRkNBSUlCVWdBeHRxUVFGMklSRkJBQ0VRSUFJaEVrRUFJUk1EUUNBYUlCSkJBV3NpRWtFQ2RDSUlhaWdDQUNBUmJFRUdkU0FJSUJscUtBSUFhaUVEQW44Q1FDQVREUUFnQXlBSUlCdHFLQUlBVGcwQVFRQWhFMEVBSUJjZ0F5QVhTQnNNQVF0QkFTRVRJQU1nQkNBSWFpZ0NBQ0lJSUFNZ0NFZ2JDeUFRYWlFUUlBRWdFa2dOQUFzZ0ZDQVJJQkFnRmtvYklSRWdBaUVRUVFBaENFRUFJUk1EUUNBS0lCQkJBV3NpRUVFQ2RDSURhaUFESUJscUtBSUFJQU1nR21vb0FnQWdFV3hCQm5WcUloSWdFa0VBSUJjZ0VpQVhTQnNnRWlBRElCdHFLQUlBVGlJU0d5QVRHeUlWSUFNZ0JHb29BZ0FpQXlBRElCVktHeUlETmdJQUlBTWdDR29oQ0NBU0lCTnlJUk1nQVNBUVNBMEFDd3NnQmdKL0FrQUNRQUovSUFVZ0FrRUJheUlUVGdSQUlBSWhFU0FjSVJBZ0ZpQWthZ3dCQ3lBWFFRaHFJUU1nQWlFU0FrQUNRQU5BSUNBb0FnQWlFQ0FTUVFGMGFpNEJBQ0lWSUJBZ0V5SVJRUUYwYWk0QkFDSVRheUFXSUFocklob2dGU0FRSUFGQkFYUnFMZ0VBSWhCcmJpSWRiQ0FLSUJGQkFuUWlHR29pR1NnQ0FDSVVhaUFRSUJWcklCMXNJQnBxSUJBZ0UydHFJaEJCQUNBUVFRQktHMm9pRXlBWUlCdHFLQUlBSWhBZ0F5QURJQkJJRzA0RVFDQVBRUUVRQmcwQ0lCTkJDR3NoRXlBWktBSUFJUlFnQ0VFSWFpRUlDeUFjSWhCQkFVNEVRQ0FSSUFGclFiRGRBV290QUFBaEVBc2dHVUVBSUJjZ0V5QVhTQnNpRWpZQ0FDQUlJQlFnSEdwcklCSnFJQkJxSVFnZ0VDRWNJQkVpRWtFQmF5SVRJQVZLRFFBTERBRUxJQnhCQUVvTkFnd0RDeUFXSUNScUN5RVdJQkJCQUV3RVFDQVJJUklNQWdzZ0VTRVNDeUFQSUJJZ0FXdEJBV29RRmlBQmFnd0JDMEVBQ3lJRE5nSUFRUUFnSlNBQklBTklHeUVGQWtBQ1FDQWxSUTBBSUFFZ0EwNE5BQ0FISUE5QkFSQUdOZ0lBREFFTElBZEJBRFlDQUFzZ0RVRUJTaUViSUJZZ0NHc2dCV29pQ0NBZ0tBSUFJaHdnRWtFQmRHb3VBUUFpRHlBY0lBRkJBWFJxTGdFQUloTnJiaUVGUVFBaEF5QUJJQkpJQkVBZ0RrRURkQ0VaSUJNZ0Qyc2dCV3dnQ0dvaENDQVRJUkFnQVNFUkEwQWdFRUVRZENFRElBb2dFVUVDZEdvaUR5QVBLQUlBSUJ3Z0VVRUJhaUlSUVFGMGFpNEJBQ0lRSUFOQkVIVnJJQVZzYWpZQ0FDQVJJQkpIRFFBTElCTWhFQ0FCSVJFRFFDQVFRUkIwSVFNZ0NpQVJRUUowYWlJRklBZ2dIQ0FSUVFGcUloRkJBWFJxTGdFQUloQWdBMEVRZFdzaUF5QURJQWhLR3lJRElBVW9BZ0JxTmdJQUlBZ2dBMnNoQ0NBUklCSkhEUUFMUVFSQkF5QU5RUUZLR3lFYVFRQWdEVUVEZEdzaEhVRUFJUU1EUUNBVFFSQjBJUkFnQ2lBQlFRSjBJZzlxSWhFb0FnQWdBMm9oQlFKQUlCd2dBVUVCYWlJSVFRRjBhaTRCQUNJVElCQkJFSFZySUE1MEloWkJBazRFUUVFQUlSVWdFU0FGSUFVZ0JDQVBhaWdDQUdzaUJVRUFJQVZCQUVvYklnVnJJaFEyQWdBZ0RTQVdiQ0VRQWtBZ0RVRUNSdzBBSUJaQkFrWU5BQ0FIS0FJQURRQWdBU0FHS0FJQVNDRVZDd0pBSUJBZ0ZXb2lFRUVEZENJVlFRSjFRUUFnRmtFQ1Joc2dFRUZyYkdvZ0dTQUFLQUk0SUFGQkFYUnFMZ0VBYWlBUWJDSVdRUUYxYWlJQklCUnFJaUFnRUVFRWRFZ0VRQ0FCSUJaQkFuVnFJUUVNQVFzZ0lDQVFRUmhzVGcwQUlBRWdGa0VEZFdvaEFRc2dDeUFQYWlJV0lCQkJBblFnRkdvZ0FXb2lGRUVBSUJSQkFFb2JJQkJ1UVFOMkloQTJBZ0FnRFNBUWJDQVJLQUlBSWhSQkEzVktCRUFnRmlBVUlCdDFRUU4xSWhBMkFnQUxJQllnRUVFSUlCQkJDRWdiSWhBMkFnQWdEQ0FQYWlBUktBSUFJQUZxSUJBZ0ZXeE1OZ0lBSUJFZ0VTZ0NBQ0FkSUJZb0FnQnNhallDQUF3QkN5QVJJQVVnQlNBWGF5SUJRUUFnQVVFQVNoc2lCV3MyQWdBZ0N5QVBha0VBTmdJQUlBd2dEMnBCQVRZQ0FBc2dCUVIvSUFzZ0Qyb2lBU0FGSUJwMkloQkJDQ0FCS0FJQUlnRnJJaEVnRUNBUlNCc2lFQ0FCYWpZQ0FDQU1JQTlxSUJBZ0Yyd2lBU0FGSUFOclRqWUNBQ0FGSUFGckJVRUFDeUVESUFnaUFTQVNSdzBBQ3lBU0lRRUxJQWtnQXpZQ0FDQUJJQUpJQkVBRFFDQUxJQUZCQW5RaUFHb2lBeUFBSUFwcUlnUW9BZ0FnRzNWQkEzVTJBZ0FnQkVFQU5nSUFJQUFnREdvZ0F5Z0NBRUVCU0RZQ0FDQUJRUUZxSWdFZ0FrY05BQXNMSUNZa0FDQVNDendCQVg4Z0FDQUFLQUljUVE5MklnRTJBaVFnQUNnQ0lDQUJiaUlBUVg5elFZQ0FBbXBCQUNBQVFRRnFJZ0JCZ0lBQ2F5SUJJQUFnQVVrYmFndVhBUUVFZnlBQklBSklCRUFnQmtFQklBWkJBVW9iSVFnRFFFRUFJUVlnQkNBQlFRSjBhaUlKS0FJQUlnZEJBVTRFUUFOQUlBVWdCeEFKSVFjZ0F5QUFLQUlJSUFac0lBRnFRUUowYWlJS0lBb3FBZ0FnQjdKREFBQUFQNUpCQVVFT0lBa29BZ0FpQjJ0MHNwUkRBQUNBT0pSREFBQUF2NUtTT0FJQUlBWkJBV29pQmlBSVJ3MEFDd3NnQVVFQmFpSUJJQUpIRFFBTEN3dnhBZ0lIZndSOUl3QkJFR3NpQ1NRQUlBbENBRGNEQ0FKOUlBUUVRRU1BbUJrK0RBRUxJQWRCQW5RaUNFR0EzUUZxS2dJQUlROGdDRUdRM1FGcUtnSUFDeUVSSUFFZ0FrZ0VRQ0FHUVFFZ0JrRUJTaHNoQ2lBRktBSUVRUU4wUVNCcUlRc2dCMEhVQUd3Z0JFRXFiR3BCc05vQmFpRUhBMEFnQnlBQlFSUWdBVUVVU0J0QkFYUWlCR29oRENBSElBUkJBWEpxSVExQkFDRUVBMEFDZnlBTElBVW9BaFJySUFVb0FoeG5heUlJUVE5T0JFQWdCU0FNTFFBQVFRZDBJQTB0QUFCQkJuUVFYUXdCQ3lBSVFRSk9CRUFnQlVHZzNRRkJBaEFESWdaQkFYVkJBQ0FHUVFGeGEzTU1BUXRCZnlBSVFRRkhEUUFhUVFBZ0JVRUJFQVpyQ3lFR0lBTWdBQ2dDQ0NBRWJDQUJha0VDZEdvaUNDQUpRUWhxSUFSQkFuUnFJZzRxQWdBaUVpQVBJQWdxQWdCREFBQVF3WmVVa2lBR3NpSVFramdDQUNBT0lCSWdFSklnRVNBUWxKTTRBZ0FnQkVFQmFpSUVJQXBIRFFBTElBRkJBV29pQVNBQ1J3MEFDd3NnQ1VFUWFpUUFDMnNCQW44Q1FFR1Erd0VvQWdBaUFBUkFJQUFRQ0VHUSt3RkJBRFlDQUF3QkMwR1Urd0VvQWdBaUFFVU5BQ0FBRUFoQmxQc0JRUUEyQWdBTFFaajdBU2dDQUNJQkJFQURRQ0FCS0FJQUVBZ2dBU2dDQkNFQUlBRVFDQ0FBSWdFTkFBdEJtUHNCUVFBMkFnQUxDd3VzNkFFM0FFR0JDQXZuQVFRQkFnTUZSbUZwYkdWa0lIUnZJR055WldGMFpTQlBVRlZUSUdSbFkyOWtaWElzSUdOdlpHVTZJQ1ZrSUNjbGN5Y3VBRVpoYVd4bFpDQjBieUJrWldOdlpHVWdUM0IxY3lCa1lYUmhMQ0JwYm5CMWRDQWxjQ0FsWkN3Z2IzVjBjSFYwSUNWd0lDVmtMZ0JEWVc0bmRDQm1jbVZsSUhWdWRISmhZMnRsWkNCaWRXWm1aWElnSlhBdUFBQUFBQUFBQUE4SUJ3UUxEQU1DRFFvRkJna09BUUFKQmdNRUJRZ0JBZ2U0ZnBwNW1ubG1acmgrTTNNQUFBWUFBQUFFQUFBQUF3QUFBQUFCQUFBQUFRQUFBQUFBQUFBQUFmOEIvd0wrQXY0RC9RQUJBQUgvQXY4Qy9nUCtBd0JCOFFrTDFRRUMvLy8vQUFBQkFRQUJBQUVBQUFBQUFBRUFBQUFBQUFFQUFBQUJBQUFBQUFEL0FnRUFBUUVBQVAvL0FBQUFBQUFBQWY4QUFmOEEvd0grQXY3K0F2MENBLzM4QS93RUJQc0YrdnNHK1FZRkNQY0FBQUVBQUFBQUFBQUEvd0VBQUFIL0FBSC8vd0gvQWdIL0F2NytBdjRDQWdQOUFBRUFBQUFBQUFBQkFBRUFBQUgvQVFBQUFnSC9Bdi8vQXY4Q0F2OEQvdjcrQXdBQkFBQUJBQUgvQXY4Qy93SUQvZ1ArL2dRRS9RWDkvQWI4QmdYN0NQcjcrUWtHQUFNQUJ3TUFBUW9BQWdZU0Nnd0VBQUlBQUFBSkJBY0VBQU1NQndjQVFkQUxDNUlRS3EvVnljLy9RQUFSQUdQL1lRRVEvcU1BSnl1OVZ0bi9CZ0JiQUZiL3VnQVhBSUQ4d0JqWVRlMy8zUDltQUtmLzZQOUlBVW44Q0FvbFBnQUFBQUFBQUlmSFBjbEFBSUFBaHY4a0FEWUJBUDFJQWpNa1JVVU1BSUFBRWdCeS95QUJpLytmL0JzUWV6Z0FBQUFBQUFBQUFHZ0NEY2oyL3ljQU9nRFMvNnovZUFDNEFNWCs0LzBFQlFRVlFDTUFBQUFBNWo3R3hQUC9BQUFVQUJvQUJRRGgvOVgvL1A5QkFGb0FCd0JqL3dqLzFQOVJBaThHTkFySERBQUFBQUFBQUFBQTVGY0Z4UU1BOHYvcy8vSC9BZ0FaQUNVQUdRRHcvN24vbGYreC96SUFKQUZ2QXRZRENBVzRCUUFBQUFBQUFBQUFsR3RueEJFQURBQUlBQUVBOXYvcS8rTC80UC9xL3dNQUxBQmtBS2dBOHdBOUFYMEJyUUhIQVFBQUFBQUFBQUFBdlFDby9Xa0NaM2QxQUdILzB2c0lkRFFBM1FDbzluUnUvUDhSQXVyeTVXYlEvL1lDalBDbFhiRC9pUU4xN3daVG5mL01BNEx2WmtlVi84Y0RpL0FuTzVuL2dBTmg4cTR1cGY4RkE4LzBYaUs1LzJNQ29mZVlGdEwvcVFHaCtyUUxBQ0QrSC9ZZjZoL1lIOElmcUIrSUgySWZPaDhLSDlnZW9CNWlIaUllM0IyUUhVSWQ3aHlXSERvYzJCdHlHd29ibkJvcUdyUVpPaG04R0R3WXRoY3VGNkFXRUJaK0ZlZ1VUaFN3RXhBVGJoTElFUjRSZEJER0R4WVBaQTZ1RGZnTVFBeUVDOGdLQ2dwS0NZb0l4Z2NDQno0R2VBV3lCT29ESWdOYUFwSUJ5Z0FBQURiL2J2Nm0vZDc4RnZ4Tys0ajZ3dm4rK0RyNGR2ZTI5dmIxT1BWODlNRHpDUE5TOHB6eDZ2QTY4SXp2NHU0NDdwTHQ4T3hRN0xMckdPdUM2dkRwWU9uUzZFcm94T2RFNThibVRPYlc1V1RsOXVTTzVDamt4dU5xNHhManZ1Snc0aVRpM3VHZTRXRGhLT0gyNE1iZ251QjQ0RmpnUHVBbzRCYmdDdUFDNEFEZ3MyTUFSemdySGhVTUJnQUFBQURIcFpCOGJXQlVSejB6S2lBWER3Z0E4ZUhUeDd1dnBKbU9oSHR5YVdCWVVFaEFPVElzSmlFZEdCUVFEQWtGQWdCVkNBQUFZQWdBQUhBSUFBQUFBQUFBQkFZWUJ3VUFBQUlBQUF3Y0tRMzg5dzhxR1E0Qi9qNHA5L1lsUWZ3RCtnUkNCL2dRRGliOUlRQUFBQUFBQUFBQURSWW5Gd3ovSkVBYit2a0tOeXNSQVFFSUFRRUc5VW8xOS9RM1RQUUkvUU5kRy93YUp6c0QrQUlBVFFzSitCWXMrZ2NvQ1JvRENma1VaZmtFQS9ncUdnRHhJVVFDRi80M0x2NFBBLzhWRUNuNkd6MG5CZlVxV0FRQi9qeEJCdnovKzBrNEFmY1RYaDMzQUF4akJnUUk3V1l1OHdNQ0RRTUNDZXRVU083MUxtanFDQkltTUJjQThFWlQ2d3NGOVhVVytQb1hkZlFEQS9oZkhBVDJEMDA4OGY4RWZBTDhBeVpVR09jQ0RTb05IeFg4T0M3Ly95TlA4eFA1UVZqMzhoUUVVVEhqRkFCTEErOEY5eXhjK0FIOUZrVWYrbDhwOUFVblF4RDhBUUQ2ZURmYzh5eDZCT2hSQlFzREJ3SUFDUXBZb0FnQUFOQUlBQUFnQ1FBQUFBQUFBQXdqUEZOc2hKMjB6dVFQSURkTlpYMlhyOG5oRXlwQ1dYS0pvcmpSNWd3Wk1raGhlSk9zeU44YUxFVmFjb2VmdE0zaERSWTFVR3FDbkxUTjVBOFpMRUJhYzQ2b3hONFRHRDVTWkhpUnFMN1dGaDh5VDJkNGw2ckw0eFVkTFVGcWZKYXJ4T0FlTVV0aGVZNmx1dEhsRXhrMFJsMTBqNmJBMnhvaVBrdGhkcEdud3RrWklUaEdXM0dQcGNUZkZTSXpTR0Yxa2F2RTNoUWRNa05hZFpDb3hkMFdIekJDWDNXU3FNVGVHQ0V6VFhTR25yVEk0QlVjUmxkcWZKV3F3dGthSVRWQVUzV1lyY3poR3lKQlgyeUJtNjdTNFJRYVNHTnhnNXF3eU5zaUt6MU9YWEtic2MzbEZ4MDJZWHlLbzdQUjVSNG1PRmwyZ1o2eXlPY1ZIVEUvVlcrT284SGVHekJOWjRXZXM4VFg2QjB2U21OOGw3REczTzBoS2oxTVhYbWJycy9oSFRWWGNJaWFxcnpRNHhnZU5GU0RscWE2eStVbE1FQlVhSGFjc2NubVVRc0tDUW9KQ2dudkNPOElDZ244Q0JjSjd3aElDeFFLV2drL0NRb0o0Z2ppQ09JSTRnaVNDTGNKSkFra0NRb0pDZ2tLQ1NRSkpBay9DVElKa0F6T0NpUUpKQWtLQ2VJSXJRaWZDTlVJa2dpY0Nhb0pQd2xhQ1ZvSldnbGFDVDhKWndrS0NaY044QXRQQ0o4STRnamlDT0lJN3dnS0NkVUkwZ3hGREJRS1dnbkhDSzBJbndpU0NKSUlRZ2dBRUFVUHJRZzhDandLWndrS0NWb0pQd2thQ0dvTXJBdy9DYTBJK1FtQ0NTUUpDZ2wzQ0swSUNnMmdEYVlLa2dqVkNKd0pNZ2svQ1o4SU5RZ3lDWFFKRndrL0NWb0pkQWwwQ1hRSm5Bay9DY01PTFE2Q0NkOEpQd25pQ09JSS9BaWZDQUFJdGd5WkRKa0tIZ3VQQ1JjSi9BajhDT0lJVHdpL0RPUU13UXIyQ284SjFRalZDTWNJVHdnMUNEa0xwUXRKQ2o4Slp3a3lDWklJeHdqSENFSUltUXg5REVrS0ZBcmlDSVVJeHdpdENLMElYUWhxRE80TXRBcG5DZUlJNGdqaUNPOElrZ2hDQ0VVTXlBeWNDUTBJN3dqRUNUOEp0d21DQ1lVSXN3M1NEQW9KakFwWENxb0pQd2xhQ1NRSlR3aGZEYzhOM2d2d0Mvd0luZ2V0Q09JSTRnamlDRXdOSmcwbkNIOEtPUXN5Q1hRSjRnaXFDZXdKc0E2Z0RaNEhaQXBSQzk4Sldnay9DWndKMVFqVUM4Z010QXBJQzdRS2FnaFBDTzhJdWdqSENHOE9TUTdwQjdFSFpBcU1DaFFLeEFrWENUOEpod3hWRFRJSkdnaElDMGdMSkFtM0NjY0lkd2dLRFNZTkhndmNDaGNKYWdqaUNPOElRZ2dOQ0JjSi9BaUZDSGNJaFFnL0NVa0tqQXFNQ3ZrSlp3bUNDYTBJMVFpdENLMElKQWwwQ1M4S2pBcmVDNndNOWdwSUM2b0pHZ2o4Q0FvSk1nbE1DYTBJYWdoUENPOEl4QW5wQ3VrS1BBb1VDajhKWEE2QkRyb0lMZ2VGQ01FS3BncHhDdEVKbndqcENsZ01wZ3I1Q1I0TDBRbUZDRm9KclFpRkNOU3lsSUZzWUZWU1QwMDlPems0TXpFd0xTb3BLQ1lrSWg4ZUZRd0tBd0VBLy9YMDdPbmgyY3Urc0sraGxZaDljbVpiVVVjOE5Dc2pIQlFURWd3TEJRQ3ppb3lVbDVXWmw2TjBRMUk3WEVoa1dWd0FRZkFiQytjQkVBQUFBQUJqUWlRa0lpUWlJaUlpVTBVa05DSjBaa1pFUkxCbVJFUWlRVlZFVkNSMGpaaUxxb1M3dU5pSmhQbW91WXRvWm1SRVJMTGF1Ym1xOU5pN3U2cjB1N3ZiaW1lYnVMbUpkTGVibUlpRTJiaTRxcVRacTV1TDlLbTR1YXFrMk4vYWl0YVB2TnFvOUkySW02cW9pdHpiaTZUYnl0aUpxTHIydVl0MHVkdTVpbVJraG1SbUlrUkVaRVNveTkzYXFLZWFpR2hHcFBhcmlZdUptOXJiaS8vKy9lNE9Bd0lCQVAvKy9Ob2pBd0lCQVAvKyt0QTdCQUlCQVAvKzlzSkhDZ0lCQVAvODdMZFNDQUlCQVAvODY3UmFFUUlCQVAvNDRLdGhIZ1FCQVAvKzdLMWZKUWNCQUVIZ0hRdnVEZi8vLzRNR2tmLy8vLy8vN0YwUFlQLy8vLy8vd2xNWlI5My8vLy8vb2traVFxTC8vLy9TZmtrck9hMy8vLy9KZlVjd09vTC8vLyttYmtrNVBtalMvLy83ZTBFM1JHU3Ivd0FBQUFBQUFBQUErZ0FEQUFZQUF3QURBQU1BQkFBREFBTUFBd0ROQVFBQUlBQUtBQlF1WkFIUUNRQUFFQXNBQUpBTkFBRFFEUUFBOEEwQUFKQU9BQURnRGdBQU1BOEFBQWNYSmpaRlZXUjBnNU9pc3NIUTMrOE5HU2szUlZOaWNIK09uYXU3eTl6c0R4VWlNejFPWEdwK2lKaW51YzNoOEFvVkpESS9UMTl1Zm8yZHJiM04zZTBSRkNVek8wNVphM3VHbHFTNHplRHdDZzhnTTBOUllIQ0JqcDZ0dmN6YzdBZ1ZKVE5CVDJKeGZvcWJxTFBBMGRvTUR5STNQMDVYYkhhRGxLZTV5OXZzRUJNZ0pEaFBXMngyaUpxcnVzemM3UXNjS3pwS1dXbDRoNWFsdE1UVDR2RUdFQ0V1UEV0Y2EzdUpuS201eDliaEN4TWVMRGxLV1dsNWg1aXB1c3JhNmd3VEhTNDVSMWhrZUlTVXBiYkgyT2tSRnlNdU9FMWNhbnVHbUtlNXpON3REaEV0TlQ5TFdXdHpoSmVydk03ZDhBa1FIU2c0UjFobmQ0bWFxNzNOM3UwUUV5UXdPVXhYYVhhRWxxZTV5dHJzREJFZE5rZFJYbWgraUpXa3RzbmQ3UThjTHo1UFlYT0JqcHVvdE1MUTMrNElEaDR0UGs1ZWIzK1BuNi9BejkvdkVSNHhQazljYTNlRWthQ3V2c3pjNnc0VEpDMDlURnRzZVlxYXJMM04zdTRNRWg4dFBFeGJhM3VLbXF1N3pOM3NEUkVmS3pWR1UyZHlnNVdudWN2YzdSRVdJeW82VGwxdWZZdWJxcnpPNFBBSUR5SXlRMU5qYzRPU29yTEIwZUR2RFJBcFFrbFdYMitBaVphanQ4N2g4UkVaSlRRL1MxeG1kNFNRb0srLzFPY1RIekZCVTJSMWhaT2hycnZJMWVQeUVoODBSRmhuZFg2S2xhT3h3TS9mN3hBZEx6MU1XbXAzaFpPaHNNSFI0UEFQRlNNeVBVbFdZVzUzZ1kydnh0cnRTUTV0QzIwTGJRdHRDMjBMYlF0dEMyMExiUXR0QzIwTGt3dVRDMjBMSGd1UURBME1uQXZ3Qy9BTHdndkNDOElMa3d1VEM4SUxuQXRJQ3g0TEhndW1DbEFQcmcrbEM0Y01od3gyQy9BTEhnc3lES3dNYlFzZUN6d0srUW5jQ20wTHZBMTlETUlMSHd6TEMwZ0xiUXR0QzIwTGJRdElDMGdMU0F0SUMwZ0x3UXErRTc0VGRndjFEVGtOOEFzTkRPa0tXQXhZREp3TEhndlJDZXdKd1FwSUMwd1JOUkNNQ3NFS25BdkNDMjBMSGd1bEM4c0xiUXR0QzIwTGJRdElDNllLSkE3TEM1d0w4QXZ3Q3prTDlncndDNUFNNXd1bEM5c00yd3lsQys0TXJ3dHJGSllUN0FrS0RjWU5PUTE5REJZTU1BMmxDNHdLVndwL0N1a0tIZ3R4Q3RrVE5oUUhFa3dSbkFsUkMrY0xod3hoREg4S3RBcElDeDRMNlFvZUM0d0tNZ3hJQzVNTGJRdHRDMjBMYlF1VEM1TUxrd3VUQzIwTGJRdVRDNU1Ma3d0cUVJY01wUXNmRE1JTFNBdElDMjBMbkFzNUMyUUx5d3VjQzhJTGZRdzVDN0FPc0E2c0RCOE1wUXRJQzIwTFNBdWNDM1lMNlFycENoNExTQXRJQzJRS0RnK3VENGNNTWd5c0RIWUw1d3VUQzVNTERRd2VDK2tLNlFycEN1a0tGQW9GRC9BUEhRMjhEUllNdEFyQ0MzWUxNZ3dOREI0TEhndFhDbGNLSGd2MkNoc1VIaE9aREFVUGNRMWhERkVMVlExN0RZd0tGQXB4Q3JRS0hndjJDc0VLRFJETkR0c01XQXh0QzBnTFNBdHRDK2tLdEFycENyUUs2UW9lQzBnTDlnclpFNzRUNXd2WkRhd004QXNORElBTEh3eFJDN1FLdEFxMENoNEw2UW84Q3RVUTFSQXNDOThKaHd3d0RUQU5Bd3dERERBTjhBc2VDMWNLRkFxbUNzRUs4QXRrQy9ZS1NBdTBDbjhLVVFzZkRFNE1UZ3lRREdFTThBdkNDNU1MSGdzWEVTb1BiUXRJQ3g0TFNBc2VDeDRMU0F0SUMwZ0xIZ3RJQzIwTFNBc2VDNlVMWkF0a0M2VUxwUXZ3Q3pJTWtBeE9EUEFMd2d1Y0M1d0xuQXR0QzdRS2hSQTFFTzRNRXcxdEM1TUxTQXVsQzZVTEhndnBDclFLSGdzZUN4NEw2UXJ3RDY0UEh3ekNDMjBMYlF0dEMwZ0xiUXR0Q3g0TEhnc2VDK2tLU0F2Y0NnY1MzeEZoREhFTmh3eWxDMUVMM2dzeURMUUtmd3AvQ244S3RBcnBDb3dLTlJDdEVNME9TUTZtQ3R3S1NBdElDOElMbkF0dEN4NExmd3AvQ3VrS1NBdDNFT0lOd1FvZUN4NExTQXRJQzBnTGJRdHRDMGdMYlF0dEMyMExrd3RJQ3pZVU9SUFZDR2dOelE2WERSTU5IZ3Z1REpjTlRneFJDNXdKdHduQkNtMExldzFsRGpJTWZRd2REZWNMaHd5SERLVUxrQXdOREcwTGJRdC9DdXdKZ2dtbEM4SUw2UXJwQ3JRSzZRb2VDNXdMOEFzZkRFNE1UZ3hPREI4TXdndkNDNEFMT1F0L0NxWUszQXJDQzJnTjJRMGREYXdNOEF2Q0M1TUxiUXRJQ3g0THl3dUFDMUVMd2d2Q0M1d0x5d3NmRFBBTDhBdkNDMGdMSGd0dEMyMExTQXRRRDM4UHdndDlEQjBOa0F6YkROc01sdzE0RG5FTnBncUZDSndKRkFvdkN1SE15YmkzcjU2YW1ZZDNjM0Z1YldOaVgwOUVOREl3TFNzZ0h4c1NDZ01BLy92cjV0VEp4TGFucHFPWGlueHVhRnBPVEVaRk9TMGlHQlVMQmdVRUF3Q3ZsS0N3c3EydXBMR3V4TGJHd0xaRVBrSThTSFZWV25hSWw0NmdqcHNBUWRjckM4QUNBV1JtWmtSRUpDSmdwR3VldWJTNWkyWkFRaVFpSWdBQklOQ0xqYitZdVp0b1lLdG9wbVptWm9RQkFBQUFBQkFRQUZCdFRtdTVpMmRsME5TTmk2MlplMmNrQUFBQUFBQUFBVEFBQUFBQUFBQWdSSWQ3ZDNkblJXSkVaM2gyZG1aSFlvYUluYmkybVl1RzBLajRTNzJQZVdzZ01TSWlJZ0FSQXRMcmkzdTVpV21HWW9kb3RtUzNxNFprUmtSR1FrSWlnMENtWmtRa0FnRUFocVptUkNJaVFvVFU5cDZMYTJ0WFptVGJmWHFKZG1lRWNvZUphYXRxTWlLazFvMlB1WmQ1WjhBaUFBQUFBQUFCMEcxS3U0YjVuNGxtYnBwMlYyVjNaUUFDQUNRa1FrUWpZS1JtWkNRQUFpR25pcTVtWkZRQ0FtUnJlSGNreFJnQS8vNzk5QXdEQWdFQS8vNzg0Q1lEQWdFQS8vNzcwVGtFQWdFQS8vNzB3MFVFQWdFQS8vdm91RlFIQWdFQS8vN3d1bFlPQWdFQS8vN3ZzbHNlQlFFQS8vampzV1FUQWdFQVFhQXVDN2NCLy8vL25BU2EvLy8vLy8valpnOWMvLy8vLy8vVlV4aEk3UC8vLy8rV1RDRS8xdi8vLzc1NVRTczN1Zi8vLy9XSlJ5czdpLy8vLy8rRFFqSkNhOEwvLzZaMFREYzFmZi8vQUFBQUFBQUFBQUJrQUFNQUtBQURBQU1BQXdBRkFBNEFEZ0FLQUFzQUF3QUlBQWtBQndBREFGc0JBQUFnQUJBQVppYXJBWEFQQUFCd0VRQUFjQlVBQUxBVkFBRFFGUUFBMEJZQUFDQVhBQUJ3RndBQUFBQUFBT0J3TEE4REFnRUEvdTNBaEVZWEJBRC8vT0tiUFFzQ0FFSGdMd3YwQWZyMTZzdEhNaW9tSXlFZkhSd2JHaGtZRnhZVkZCTVNFUkFQRGcwTUN3b0pDQWNHQlFRREFnRUFBQUFBQUFBQUFGekt2dGkyMzVyaW5PWjQ3SHIwelB3MEE0WUxpQk5rR1dZZFNpQkNKNlExK2ZmMjlmVHEwc3JKeU1XdVVqczROell1Rmd3TENna0hBRUFBeTVZQTE4T21mVzVTQUFBQUFFc1lBQUJPR0FBQWVBQ0FRQURvbmdvQTVnRHozY0MxQUdRQThBQWdBR1FBelR3QU1BQWdxMVVBd0lCQUFNMmFaak1BMWF1QVZTc0E0TUNnZ0dCQUlBQmtLQkFIQXdFQUFQMzY5T25VdHBhRGVHNWlWVWc4TVNnZ0dSTVBEUXNKQ0FjR0JRUURBZ0VBMHRET3k4ZkJ0NmlPYUVvMEpSc1VEZ29HQkFJQVFlQXhDL01CMzhtM3A1aUtmRzlpV0U5R1BqZ3lMQ2NqSHhzWUZSSVFEZ3dLQ0FZRUF3SUJBTHl3bTRwM1lVTXJHZ29BcFhkUVBTOGpHeFFPQ1FRQWNUOEFBQUFBQUgwekdoSVBEQXNLQ1FnSEJnVUVBd0lCQU1acExSWVBEQXNLQ1FnSEJnVUVBd0lCQU5XaWRGTTdLeUFZRWc4TUNRY0dCUU1DQU8rN2REc2NFQXNLQ1FnSEJnVUVBd0lCQVBybHZJZFdNeDRURFFvSUJnVUVBd0lCQVBucjFibWNnR2RUUWpVcUlSb1ZFUTBLQVA3NTY4NmtkazB1R3hBS0J3VUVBd0lCQVAvOStlL2N2NXgzVlRrbEZ3OEtCZ1FDQVAvOSsvYnQzOHV6bUh4aVN6Y29IUlVQQVAvKy9mZmNvbXBES2h3U0RBa0dCQU1DQUVIZ013c1I4YjZ5aEZkS0tRNEEzOEdkakdvNUp4SUFRWUEwQzVjQmdBRFdLZ0RyZ0JVQTlMaElDd0Q0MW9BcUJ3RDQ0YXBRR1FVQSsrekdmallTQXdENjd0T2ZVaU1QQlFENjU4dW9nRmcxR1FZQS9PN1l1WlJzUnlnU0JBRDk4K0hIcG9CYU9SOE5Bd0QrOXVuVXQ1TnRTU3dYQ2dJQS8vcnczOGFtZ0ZvNklSQUdBUUQvKy9UbjByV1Nia3N1R1F3RkFRRC8vZmp1M2NTa2dGdzhJeElJQXdFQS8vMzU4dVhRdEpKdVREQWJEZ2NEQVFCQm9EVUxsd0dCQU04eUFPeUJGQUQxdVVnS0FQblZnU29HQVByaXFWY2JCQUQ3NmNLQ1BoUUVBUHJzejZCakx4RURBUC93MmJhRFVTa0xBUUQvL3VuSm4yczlGQUlCQVAvNTZjNnFnRll5RndjQkFQLzY3dG02bEd4R0p4SUdBUUQvL1BQaXlLYUFXamdlRFFRQkFQLzg5ZWZSdEpKdVRDOFpDd1FCQVAvOStPM2J3cU9BWFQ0bEV3Z0RBUUQvL3ZyeDRzMnhrVzlQTXg0UEJnSUJBRUhBTmd1WEFZRUF5ellBNm9FWEFQVzRTUW9BK3RlQktRVUEvT2l0VmhnREFQM3d5SUU0RHdJQS9mVFpwRjRtQ2dFQS9mWGl2WVJIR3djQkFQMzI1OHVmYVRnWEJnRUEvL2pyMWJPRlZTOFRCUUVBLy83ejNjS2ZkVVlsREFJQkFQLysrT3JRcTRCVk1CWUlBZ0VBLy83NjhOeTlsV3RESkJBR0FnRUEvLzc3OCtQSnBvQmFOeDBOQlFJQkFQLysvUGJxMWJlVGJVa3JGZ29FQWdFQVFlQTNDNWNCZ2dESU9nRG5naG9BOUxoTURBRDUxb0lyQmdEODZLMVhHQU1BL2ZITGd6Z09BZ0QrOXQyblhpTUlBUUQrK2VqQmdrRVhCUUVBLy92djA2SmpMUThFQVFELysvUGZ1b05LSVFzREFRRC8vUFhteXA1cE9SZ0lBZ0VBLy8zMzY5YXpoRlFzRXdjQ0FRRC8vdnJ3MzhTZmNFVWtEd1lDQVFELy92MzE1OUd3aUYwM0d3c0RBZ0VBLy83OS9PL2R3cDUxVENvU0JBTUNBUUJCZ2prTER3SUZDUTRVR3lNc05rRk5XbWgzaHdCQm9Ea0x4UUgrTVVOTlVsMWp4Z3NTR0I4a0xmOHVRazVYWG1qUURoVWdLak5DLzE1b2JYQnpkdmcxUlZCWVgyWUFBQUFBQUFBQUFRRUJBZ01EQXdJREF3TUNBd01EQUFNTUR6QXpQRC9Bdzh6UDhQUDgvd0VBQUFBQUFBQUFBd0FBQUFBQUFBQUNBQUFBQVFBQUFBY0FBQUFBQUFBQUJBQUFBQU1BQUFBR0FBQUFBUUFBQUFVQUFBQUNBQUFBRHdBQUFBQUFBQUFJQUFBQUJ3QUFBQXdBQUFBREFBQUFDd0FBQUFRQUFBQU9BQUFBQVFBQUFBa0FBQUFHQUFBQURRQUFBQUlBQUFBS0FBQUFCUUJCOFRvTEwwREtSUnRNLzFLQ1dyTmlvbXRnZFFBQW5UNEFRRjQrQU1BRVBnQ0E3VDRBUUlrK0FBQUFBQURBVEQ4QUFNMDlBRUd4T3d2VkF2OEEvd0QvQVA4QS93RCtBUUFCL3dEK0FQMENBQUgvQVA0QS9RTUFBZi93SFFBQStCMEFBQWtlQUFBYUhnQUFLUjRBQURvZUFBQlNIZ0FBWUI0QUFITjFZMk5sYzNNQWFXNTJZV3hwWkNCaGNtZDFiV1Z1ZEFCaWRXWm1aWElnZEc5dklITnRZV3hzQUdsdWRHVnlibUZzSUdWeWNtOXlBR052Y25KMWNIUmxaQ0J6ZEhKbFlXMEFjbVZ4ZFdWemRDQnViM1FnYVcxd2JHVnRaVzUwWldRQWFXNTJZV3hwWkNCemRHRjBaUUJ0WlcxdmNua2dZV3hzYjJOaGRHbHZiaUJtWVdsc1pXUUFkVzVyYm05M2JpQmxjbkp2Y2dBQ0FRQVpGd0lBZm54M2JWY3BFd2tFQWdBQUFBQ0F1d0FBZUFBQUFCVUFBQUFWQUFBQUFKcFpQd0FBQUFBQUFJQS9BQUNBUHhBZkFBQURBQUFBQ0FBQUFIZ0FBQUFMQUFBQVFCOEFBREFnQUFCZ0lBQUFnQWNBQUFNQUFBQkFJZ0FBWUZZQUFKQlhBQUJJV0FBQWdDSUFBSWdCQUFDZ1BnQUFnRDhBQUJCQkFFR1NQZ3NwQVFBQ0FBTUFCQUFGQUFZQUJ3QUlBQW9BREFBT0FCQUFGQUFZQUJ3QUlnQW9BREFBUEFCT0FHUUFRZFUrQzlJQldsQkxSVDg0TVNnaUhSUVNDZ0FBQUFBQUFBQUFibVJhVkU1SFFUb3pMU2NnR2hRTUFBQUFBQUFBZG01blhWWlFTMFpCT3pVdktCOFhEd1FBQUFBQWZuZHdhRjlaVTA1SVFqdzJMeWNnR1JFTUFRQUFobjk0Y21kaFcxVk9TRUk4Tmk4cEl4MFhFQW9Ca0ltQ2ZIRnJaVjlZVWt4R1FEa3pMU2NoR2c4Qm1KR0toSHQxYjJsaVhGWlFTa005TnpFckpCUUJvcHVVam9WL2VYTnNabUJhVkUxSFFUczFMaDRCcktXZW1JK0pnMzEyY0dwa1hsZFJTMFUvT0MwVXlNakl5TWpJeU1qR3dieTNzcTJvbzU2WmxJRm9BRUhBd0FBTG53UUlBQWdBQ0FBSUFCQUFFQUFRQUJVQUZRQVlBQjBBSWdBa0FBQUFBQUFBQUdvY2pUaFN1eDQ2Q0duY09vTHRWenVKWTdJN0F5b0ZQRERjT1R5MFBuYzhIS09lUE5IeXhUeitodkU4bTZzUVBRV3RLajJFd2tZOVUrWmtQUkdKZ2oySG41TTl5N0tsUGRHK3VEMDZ2OHc5VksvaFBSU0s5ejBPSlFjKzJmUVNQbDh4SHo1bzF5cytpdU00UGpCU1JqNlVIMVErdjBkaVBvN0djRDZ3bDM4K1VsdUhQbUFQano2WTVaWStlZHVlUG5EdXBqN1lHNjgrKzJDM1BoRzd2ejVHSjhnK3Q2TFFQbmdxMlQ2VXUrRStERlBxUHQ3dDhqNEdpZnMrdmhBQ1B4OWFCajhrbndvL1VONE9QeXNXRXo5QlJSYy9KV29iUDNPREh6L09qeU0vNW8wblAzUjhLejgvV2k4L0dTWXpQK2ZlTmorWmd6by9NeE0rUDhXTVFUOTM3MFEvZnpwSVB5ZHRTei9PaGs0LzVZWlJQL0ZzVkQrT09GYy9hZWxaUDBWL1hELzYrVjQvYzFsaFA2K2RZei9CeG1VL3o5Um5QeEhJYVQvU29Hcy9ibDl0UDFBRWJ6LzBqM0EvNWdKeVA3MWRjejhmb1hRL3Y4MTFQMWZrZGordzVYYy9sOUo0UCtPcmVUOXpjbm8vSnlkN1ArZktleitkWG53L05lTjhQNXhaZlQrOXduMC9oaDkrUDk1d2ZqK3J0MzQvei9SK1B5WXBmeitHVlg4L3ZucC9QNWFaZnovTXNuOC9GTWQvUHh6WGZ6K0M0MzgvM2V4L1A3YnpmeitLK0g4L3lQdC9QOWI5Zno4SC8zOC9wZjkvUCtqL2Z6LzkvMzgvQUFDQVArQUJBQUNIaUFnNy8vLy8vd1VBWUFBREFDQUFCQUFJQUFJQUJBQUVBQUVBUWV6RUFBc0d3RUVBQUlCRkFFR0F4UUFMeVRqLy8zOC9qdjkvUDJyK2Z6K1QvSDgvQi9wL1A4ajJmei9XOG44L01PNS9QOWJvZnovSTRuOC9COXgvUDVQVWZ6OXJ6SDgvajhOL1B3QzZmeis5cjM4L3g2Ui9QeDJaZnovQWpIOC9zSDkvUCt4eGZ6OTJZMzgvUzFSL1AyNUVmei9lTTM4L21pSi9QNk1RZnovNi9YNC9uZXArUDQzV2ZqL0x3WDQvVnF4K1B5NldmajlUZjM0L3htZCtQNFpQZmorVU5uNC83eHgrUDVnQ2ZqK1A1MzAvMDh0OVAyYXZmVDlHa24wL2RIUjlQL0ZWZlQrOE5uMC8xUlo5UHp6MmZEL3kxSHcvOXJKOFAwbVFmRC9yYkh3LzIwaDhQeHNrZkQrcC9ucy9oOWg3UDdTeGV6OHdpbnMvL0dGN1B4YzVleitDRDNzL1BlVjZQMGk2ZWoraWpuby9UV0o2UDBnMWVqK1VCM28vTU5sNVB4MnFlVDlhZW5rLzZVbDVQOGdZZVQvNTVuZy9lN1I0UDA2QmVEOXpUWGcvNmhoNFA3TGpkei9OclhjL09uZDNQL2svZHo4S0NIYy9iczkyUHlXV2RqOHZYSFkvakNGMlB6em1kVDlBcW5VL2wyMTFQMEl3ZFQ5QjhuUS9sTE4wUHp0MGREODNOSFEvaC9OelB5eXljejhtY0hNL2RpMXpQeHJxY2o4VXBuSS9aR0Z5UHdvY2NqOEYxbkUvVjQ5eFB3QkljVC8vLzNBL1ZiZHdQd0p1Y0Q4R0pIQS9ZdGx2UHhXT2J6OGdRbTgvaFBWdVB6K29iajlUV200L3dBdHVQNGE4YlQrbGJHMC9IUnh0UCsvS2JEOGJlV3cvb1Nac1A0RFRheis3ZjJzL1VDdHJQMERXYWorTWdHby9NaXBxUHpYVGFUK1RlMmsvVFNOcFAyVEthRC9ZY0dnL3FCWm9QOVc3Wno5Z1lHYy9TQVJuUDQrblpqOHpTbVkvTnV4bFA1ZU5aVDlYTG1VL2Q4NWtQL1Z0WkQvVURHUS9FcXRqUDdGSVl6K3c1V0kvRUlKaVA5RWRZai96dUdFL2QxTmhQMXp0WUQra2htQS9UaDlnUDF1M1h6L0xUbDgvbnVWZVA5VjdYajl3RVY0L2JxWmRQOUk2WFQrYXpsdy94bUZjUDFuMFd6OVJobHMvcmhkYlAzS29XaitkT0ZvL0xzaFpQeWRYV1QrSDVWZy9UM05ZUDM4QVdEOFhqVmMvR0JsWFA0S2tWajlXTDFZL2s3bFZQenBEVlQ5THpGUS94MVJVUDY3Y1V6OEJaRk0vditwU1ArbHdVajkvOWxFL2dudFJQL0wvVUQvUGcxQS9HZ2RRUDlLSlR6LzZDMDgva0kxT1A1UU9UajhKajAwLzdRNU5QMEdPVEQ4RkRVdy9PNHRMUCtFSVN6LzVoVW8vZ3dKS1AzOStTVC91K1VnL3ozUklQeVR2UnovdGFFYy9LZUpHUDlwYVJqOEEwMFUvbTBwRlA2ekJSRDh5T0VRL0w2NURQNklqUXorTm1FSS83d3hDUDhpQVFUOGE5RUEvNVdaQVB5alpQei9sU2o4L0c3dytQOHdzUGovM25EMC9uUXc5UDc1N1BEOWM2anMvZFZnN1B3ckdPajhkTXpvL3JaODVQN3NMT1Q5SGR6Zy9VZUkzUDlwTU56L2p0alkvYXlBMlAzU0pOVC85OFRRL0IxbzBQNVBCTXorZ0tETS9NSTh5UDBMMU1UL1lXakUvOGI4d1A0NGtNRCt2aUM4L1Zld3VQNEZQTGo4eXNpMC9hUlF0UHlkMkxEOXIxeXMvTnpnclA0dVlLajluK0NrL3pGY3BQN3EyS0Q4eUZTZy9NM01uUDcvUUpqL1dMU1kvZVlvbFA2Zm1KRDloUWlRL3FaMGpQMzM0SWovZlVpSS96NndoUDAwR0lUOWJYeUEvK0xjZlB5VVFIei9pWng0L01MOGRQeEFXSFQrQmJCdy9oTUliUHhvWUd6OURiUm8vQU1JWlAxRVdHVDgyYWhnL3NiMFhQOEVRRno5bll4WS9vN1VWUDNZSEZUL2hXQlEvNUtrVFAzLzZFait6U2hJL2dKb1JQK2ZwRUQvb09CQS9oSWNQUDd2VkRqK09JdzQvL25BTlB3cStERCt6Q2d3LytsWUxQOStpQ2o5ajdnay9oamtKUDBtRUNEK3N6Z2MvcnhnSFAxUmlCaiticXdVL2cvUUVQdzg5QkQ4OWhRTS9EODBDUDRZVUFqK2hXd0UvWWFJQVA0L1IvejZuWGY0K0R1bjhQc0p6K3o3Ry9maytHNGY0UHNFUDl6NjZsL1UrQmgvMFBxaWw4ajZlSy9FKzdMRHZQcEUxN2o2UXVldys2RHpyUHBxLzZUNnBRZWcrRmNQbVB0OUQ1VDRJeE9NK2tVUGlQbnpDNEQ3SVFOOCtlTDdkUG93NzNENEd1Tm8rNWpQWlBpNnYxejdmS2RZKythUFVQbjBkMHo1dWx0RSt6QTdRUHBlR3pqN1MvY3crZlhUTFBwbnF5VDRuWU1nK0tOWEdQcDlKeFQ2S3ZjTSs3RERDUHNhandENFpGcjgrNW9lOVBpMzV1ejd4YWJvK010cTRQdkZKdHo0dnViVSs3aWUwUGkrV3NqN3lBN0UrT1hHdlBnVGVyVDVXU3F3K0w3YXFQcEFocVQ1NmpLYys3L2FsUHU5Z3BENTh5cUkrbHpPaFBrQ2NuejU2Qko0K1JHeWNQcUhUbWo2Uk9waytGcUdYUGpBSGxqN2hiSlErS2RLU1BnczNrVDZIbTQ4K252K05QbEZqakQ2aXhvbytrU21KUGlDTWh6NVE3b1UrSWxDRVBwZXhnajZ3RW9FKzN1WitQcW1uZXo3RFozZytMeWQxUHU3bGNUNEVwRzQrYzJGclBqd2VhRDVpMm1RKzZKVmhQczlRWGo0YUMxcyt6TVJYUHVaOVZENXJObEUrWGU1TlByK2xTajZTWEVjKzJoSkVQcGZJUUQ3T2ZUMCtnREk2UHE3bU5qNWRtak0ralUwd1BrSUFMVDU5c2lrK1FtUW1QcEVWSXo1dXhoOCsyM1ljUHRvbUdUNXQxaFUrbUlVU1BsczBEejY2NGdzK3Q1QUlQbFErQlQ2VTZ3RSs4REQ5UFFhSzlqMXg0dTg5TXpycFBVK1I0ajNQNTlzOXRUM1ZQUU9UemozQTU4Yzk4anZCUFp5UHVqM0Q0ck05YkRXdFBadUhwajFWMlo4OW55cVpQWDU3a2ozMnk0czlDeHlGUFlmWGZEMUdkbTg5WFJSaVBkYXhWRDI1VGtjOUVPczVQZVdHTEQxQUloODlMTDBSUGJKWEJEMjE0KzA4WUJmVFBIWkt1RHdMZlowOE1xK0NQUHJCVHp6K0pCbzhLZy9KTzVtbk96c3VmZGE1MGtaeHU2dmU0N3VtakNlOGdTbGR2T0ZpaWJ5Z01LUzg3UDIrdkxQSzJiemdsdlM4TWJFSHZaTVdGYjJNZXlLOUUrQXZ2UjVFUGIybHAwcTluUXBZdmY1c1piMit6bks5NmhlQXZSdklocjN0ZDQyOVhDZVV2V1BXbXIzOWhLRzlKak9vdmRuZ3JyMFJqclc5eWpxOHZmN213cjJxa3NtOXlEM1F2VlRvMXIxS2t0MjlwRHZrdlYzazZyMXlqUEc5M1RQNHZacmEvcjFTd0FLKy9CSUd2a2RsQ2I0eXR3eSt1Z2dRdnQxWkU3NllxaGErNnZvWnZ0QktIYjVIbWlDK1R1a2p2dUUzSjc0QWhpcStwdE10dnRNZ01iNkRiVFMrdGJrM3ZtVUZPNzZUVUQ2K09wdEJ2bHJsUkw3d0xraSsrWGRMdm5UQVRyNWRDRksrczA5VnZuT1dXTDZjM0Z1K0tpSmZ2aHRuWXI1dHEyVytIKzlvdml3eWJMNlVkRysrVkxaeXZtcjNkYjdUTjNtK2pYZDh2cGEyZjc1MWVvRytSUm1EdnJtM2hMN1FWWWEraVBPSHZ1R1FpYjdhTFl1K2NNcU12cVJtanI1MEFwQyszNTJSdnVRNGs3NkIwNVMrdG0yV3ZvRUhtTDdpb0ptKzF6bWJ2bC9Tbkw1NWFwNitJd0tndmw2Wm9iNG1NS08rZmNha3ZtQmNwcjdPOGFlK3hvYXB2a2NicTc1UXI2eSs0RUt1dnZYVnI3NlBhTEcrcmZxeXZrMk10TDV1SGJhK0VLNjN2akErdWI3UHpicSs2bHk4dm9McnZiNlVlYisrSHdmQnZpT1V3cjZmSU1TK2thekZ2dmczeDc3VHdzaStJazNLdnVMV3k3NFRZTTIrdGVqT3ZzVncwTDVDK05HK0xYL1R2b01GMWI1RGk5YStiUkRZdnYrVTJiNzVHTnUrV1p6Y3ZoMGYzcjVHb2QrKzB5TGh2c0dqNHI0UUpPUyt2cVBsdnN3aTU3NDRvZWkrQUIvcXZpU2M2NzZpR08yK2VwVHV2cXNQOEw0eml2RytFZ1R6dmtaOTlMN1A5ZlcrcW0zM3Z0bmsrTDVZVy9xK0tOSDd2a2RHL2I2MXV2NitPQmNBdjd2UUFML2tpUUcvc2tJQ3Z5WDdBcjg3c3dPLzltb0V2MU1pQmI5VDJRVy85WThHdnpoR0I3OGQvQWUvb3JFSXY4ZG1DYitNR3dxLzhNOEt2L09EQzcrVE53eS8wZW9NdjZ5ZERiOGtVQTYvT0FJUHYraXpENzh5WlJDL0dCWVJ2NWZHRWIrd2RoSy9ZeVlUdjY3VkU3K1JoQlMvRFRNVnZ4L2hGYi9JamhhL0NEd1h2OTNvRjc5SWxSaS9TRUVadjl6c0diOEVtQnEvd0VJYnZ3L3RHNy93bGh5L1kwQWR2MmpwSGIvK2tSNi9KVG9mdjl6aEg3OGppU0MvK2k4aHYxL1dJYjlTZkNLLzFDRWp2K1BHSTc5L2F5Uy9wdzhsdjF5ekpiK2RWaWEvYVBrbXY3K2JKNytnUFNpL0M5OG92LzkvS2I5OUlDcS9nOEFxdnhGZ0s3OG4veXUveEowc3YrZzdMYitTMlMyL3czWXV2M2tUTDcrMHJ5Ky9jMHN3djdmbU1MOS9nVEcveXhzeXY1bTFNci9xVGpPL3ZlY3p2eEtBTkwvb0Z6Vy9QNjgxdnhaR05yOXUzRGEvUlhJM3Y1d0hPTDl4bkRpL3hUQTV2NWJFT2IvbVZ6cS9zdW82di94OE83L0NEankvQTZBOHY4RXdQYi82d0QyL3JWQSt2OXZmUHIrRGJqKy9wZncvdjBDS1FMOVRGMEcvNEtOQnYrUXZRcjlndTBLL1UwWkR2NzdRUTcrZVdrUy85dU5FdjhKc1JiOEY5VVcvdkh4R3YrZ0RSNytKaWtlL25SQkl2eVdXU0w4Z0cwbS9qcDlKdjI4alNyL0Jwa3EvaGlsTHY3eXJTNzlqTFV5L2VxNU12d0l2VGIvNnJrMi9ZaTVPdnptdFRyOStLMCsvTTZsUHYxVW1VTC9tb2xDLzVCNVJ2MUNhVWI4b0ZWSy9iWTlTdng0SlU3ODdnbE8vdy9wVHY3ZHlWTDhXNmxTLzMyQlZ2eExYVmIrd1RGYS90OEZXdnljMlY3OEFxbGUvUWgxWXYreVBXTC8rQVZtL2VITlp2MW5rV2IraVZGcS9VY1JhdjJZelc3L2lvVnUvd3c5Y3Z3cDlYTCszNlZ5L3lGVmR2ejdCWGI4WUxGNi9WNVpldi9uL1hyLy9hRisvYU5GZnZ6TTVZTDlpb0dDLzh3Wmh2K1ZzWWI4NjBtRy84RFppdndpYllyK0EvbUsvV1dGanY1TERZNzhzSldTL0pZWmt2MzdtWkw4M1JtVy9UcVZsdjhVRFpyK2FZV2EvemI1bXYxNGJaNzlOZDJlL210Sm52MFF0YUw5TGgyaS9ydUJvdjI4NWFiK0xrV20vQk9scHY5ay9hcjhKbG1xL2xPdHF2M3RBYTcrOGxHdS9XZWhydjA4N2JMK2dqV3kvUzk5c3YwOHdiYit0Z0cyL1pkQnR2M1VmYnIvZmJXNi9vYnR1djdzSWI3OHVWVysvK0tCdnZ4dnNiNytWTm5DL1o0Qnd2NURKY0w4UEVuRy81bGx4dnhPaGNiK1g1M0cvY1MxeXY2QnljcjhtdDNLL0FmdHl2ekkrYzcrNGdITy9sTUp6djhRRGRMOUpSSFMvSW9SMHYxRERkTC9TQVhXL3FEOTF2OUo4ZGI5UXVYVy9JZlYxdjBVd2RyKzlhbmEvaUtSMnY2YmRkcjhXRm5lLzJVMTN2KytFZDc5WHUzZS9FZkYzdngwbWVMOTZXbmkvS281NHZ5dkJlTDk5ODNpL0lTVjV2eFpXZWI5Y2hubS84clY1djlya2ViOFNFM3EvbWtCNnYzTnRlcitkbVhxL0ZzVjZ2OS92ZXIvNEdYdS9ZVU43dnhwc2U3OGlsSHUvZXJ0N3Z5RGllNzhYQ0h5L1hDMTh2L0JSZkwvVGRYeS9CWmw4djRhN2ZMOVYzWHkvYy81OHY5OGVmYithUG4yL28xMTl2L3A3ZmIrZm1YMi9rclo5djlQU2ZiOWk3bjIvUHdsK3Yya2pmci9oUEg2L3AxVit2N3B0ZnI4YmhYNi95WnQrdjhTeGZyOE54MzYvb3R0K3Y0WHZmcisxQW4rL01oVi92L3dtZjc4VE9IKy9ka2gvdnlkWWY3OGtaMysvYm5WL3Z3V0RmNy9vajMrL0daeC92NVduZjc5ZnNuKy9kTHgvdjlmRmY3K0Z6bisvZ2RaL3Y4amRmNzlkNUgrL1BlcC92MnJ2ZjcvajgzKy9xZmQvdjd2NmY3OFovWCsveFA1L3Y3di9mNy82LzM4L09mNS9QNm41Zno5TDhuOC9IdWgvUHlQYmZ6OVp5Mzgvd2JoL1AxdWpmejhvaTM4L0ozQi9QMXBTZnorL01YOC9XQTUvUHlYb2ZqOG12MzQvWEpOK1A4aGtmajlwTTM0L1FmOTlQMC9JZlQrV2puMC9GRko5UDhzU2ZUKzgwSHcvNTR0OFAwMUVmRC92K1hzL3pheDdQK2xjZXo5RENucy8zYlI2UDdaY2VqL1JBWG8vTHFSNVA4NURlVCt5NEhnLzNIcDRQMHdTZUQ4RXAzYy9CRGwzUDAvSWRqL2tWSFkveHQ1MVAvWmxkVDkxNm5RL1JHeDBQMlhyY3ovYVozTS9vK0Z5UDhKWWNqODV6WEUvQ1Q5eFB6U3VjRCs3R25BL29JUnZQK1RyYmorS1VHNC9rN0p0UHdFU2JUL1ZibXcvRWNsclA3Y2dhei9KZFdvL1NjaHBQemtZYVQrYlpXZy9iN0JuUDdyNFpqOThQbVkvdUlGbFAyL0NaRCtrQUdRL1dqeGpQNUYxWWo5TXJHRS9qdUJnUDFrU1lEK3VRVjgva1c1ZVB3T1pYVDhJd1Z3L29PWmJQODhKV3orWUtsby8rMGhaUC8xa1dEK2ZmbGMvNVpWV1A5Q3FWVDlqdlZRL29jMVRQNHpiVWo4bjUxRS9kZkJRUDNuM1R6ODAvRTQvcS81TlA5LytURC9VL0VzL2pQaEtQd3J5U1Q5UzZVZy9aZDVIUDBmUlJqLzd3VVUvaExCRVArV2NRejhnaDBJL09tOUJQelJWUUQ4VE9UOC8yQm8rUDRqNlBEOG0yRHMvdExNNlB6YU5PVCt2WkRnL0lqbzNQNU1OTmo4RjN6US9mSzR6UC9sN01qK0NSekUvR1JFd1A4TFlMajkvbmkwL1ZtSXNQMGdrS3o5YTVDay9rS0lvUCt0ZUp6OXhHU1kvSmRJa1B3bUpJejhqUGlJL2RmRWdQd1NqSHovU1VoNC81QUFkUHoydEd6L2hWeG8vMHdBWlB4bW9GeiswVFJZL3F2RVVQLzJURXoreU5CSS96Tk1RUDFCeER6OUNEUTQvcEtjTVAzeEFDei9OMXdrL21tMElQK2tCQnorOWxBVS9HU1lFUHdPMkFqOStSQUUvSEtQL1BtNjYvRDc2enZrK3l1RDJQdVR2OHo1Ui9QQStHZ2J1UGtjTjZ6N2dFZWcrN1JQbFBuY1Q0ajZIRU44K0pBdmNQbGdEMlQ0cStkVStwT3pTUHMzZHp6NnZ6TXcrVXJuSlByK2p4ajcraThNK0dITEFQaFpXdlQ0QU9Mbys0QmUzUHIzMXN6NmgwYkErbGF1dFBxS0RxajdQV2FjK0p5NmtQcklBb1Q1NTBaMCtoYUNhUHQ5dGx6NlBPWlErb0FPUlBock1qVDRGazRvK2ExaUhQbFljaEQ3TjNvQSt0ajk3UGhDL2RENjdPMjQreWJWblBrMHRZVDVab2xvKy94UlVQbEdGVFQ1ajgwWStSbDlBUGczSk9UN0tNRE0ra0pZc1BuTDZKVDZDWEI4KzByd1lQblliRWo1L2VBcytBZFFFUGgxYy9EMXlEZTg5S2J6aFBXWm8xRDFPRXNjOUNMcTVQYmhmckQyRUE1ODlrcVdSUFFkR2hEMFN5bTA5ZWdWVFBaRStPRDJrZFIwOS9Lb0NQY3E5enp4V0k1bzhZUTVKUE1XbnV6czllbGE2Q1VieHV4TGRZN3hRaXFlOFFTVGR2T05kQ2IwaktDUzlsdkErdmZLMldiM3FlblM5R3A2SHZVTDlsTDNJV3FLOWhyYXZ2VmNRdmIwV2FNcTltNzNYdmNNUTViMXBZZks5WmEvL3ZVcDlCcjVvSVEyKytzTVR2dTFrR3I0dUJDRytyS0VudmxNOUxyNFExelMrMG00N3ZvWUVRcjRabUVpK2VTbFB2cFM0VmI1V1JWeStyczlpdm9sWGFiN1czRysrZ0Y5MnZuamZmTDVVcm9HK2dldUV2amduaUw1eVlZdStKSnFPdmtYUmtiN05CcFcrc3pxWXZ1NXNtNzUwblo2K1BjeWh2a0Q1cEw1ekpLaSt6MDJydmtsMXJyN2FtckcrZUw2MHZodmd0NzY2LzdxK1N4Mit2c2M0d2I0bFVzUytXMm5Idm1GK3lyNHdrYzIrdktIUXZnQ3cwNzd4dTlhK2g4WFp2cnJNM0w2QjBkKyswOVBpdnFuVDViNzYwT2krdmN2cnZ1ckQ3cjU0dWZHK1lLejB2cHFjOTc0Y2l2cSszM1Q5dm0wdUFMOERvUUcvTFJJRHYrYUJCTDhzOEFXLytsd0h2MHpJQ0w4ZU1ncS9iSm9MdnpJQkRiOXNaZzYvRjhvUHZ5MHNFYitzakJLL2tPc1R2OVZJRmI5MnBCYS9jZjRYdjhCV0diOWlyUnEvVVFJY3Y0cFZIYjhKcHg2L3kvWWZ2OHhFSWI4SmtTSy9mTnNqdnlRa0piLzlhaWEvQXJBbnZ6RHpLTCtFTkNxLytuTXJ2NCt4TEw4LzdTMi9CeWN2ditOZU1ML1FsREcveXNneXY4NzZNNy9hS2pXLzZGZzJ2L2VFTjc4Q3J6aS9COWM1dndQOU9yL3hJRHkvejBJOXY1cGlQcjlQZ0QrLzZadEF2MmkxUWIvR3pFSy9BZUpEdnhmMVJMOERCa2EveEJSSHYxWWhTTCsySzBtLzRUTkt2OVE1UzcrTlBVeS9DVDlOdjBRK1RyODlPMCsvOERWUXYxb3VVYjk1SkZLL1NoaFR2OG9KVkwvMytGUy96dVZWdjAzUVZyOXd1RmUvTjU1WXY1eUJXYitnWWxxL1BrRmJ2M1VkWEw5QjkxeS9vczVkdjVTalhyOFVkbCsvSWtaZ3Y3b1RZYi9aM21HL2Y2ZGl2Nmx0WTc5VU1XUy9mdkprdnlheFpiOUpiV2EvNVNabnYvamRaNytBa21pL2UwUnB2K2p6YWIvRG9HcS9ERXRydjhEeWE3L2VsMnkvWkRwdHYxRGFiYitnZDI2L1V4SnZ2MmFxYjcvWlAzQy9xZEp3djlWaWNiOWI4SEcvT250eXYzRURjNy85aUhPLzNndDB2eEdNZEwrV0NYVy9hNFIxdjQvOGRiOEFjbmEvdmVSMnY4WlVkNzhZd25lL3NpeDR2NU9VZUwrNytYaS9LRng1djltN2ViL05HSHEvQW5ONnYzbktlcjh2SDN1L0pIRjd2MWpBZTcvSkRIeS9kbFo4djErZGZMK0M0WHkvNENKOXYzZGhmYjlIblgyL1Q5Wjl2NDRNZnI4RVFINi9zSEIrdjVLZWZyK3B5WDYvOWZGK3YzVVhmNzhwT24rL0VGcC92eXQzZjc5NGtYKy8rS2gvdjZxOWY3K1B6MysvcGQ1L3YrM3FmNzltOUgrL0VmdC92KzMrZjcvcS8zOC81ZmgvUDZibWZ6OHR5WDgvZktCL1A1VnNmejk1TFg4L0xPTitQN0dOZmo4TExYNC9QOEY5UDFKS2ZUOUl5SHcvS0R0OFAvZWlleis5LzNvL2dGRjZQMGlZZVQ4ZTFIZy9DUVY0UHhNcmR6OUdSblkvckZaMVAwNWNkRDg0VjNNL2RrZHlQeE10Y1Q4Y0NIQS9udGh1UDZXZWJUOUFXbXcvZmd0clAydXlhVDhaVDJnL2x1Rm1QL0pwWlQ4KzZHTS9pMXhpUCtyR1lEOXRKMTgvSm41ZFB5akxXeitGRGxvL1UwaFlQNk40VmorTG4xUS9JTDFTUDNiUlVEK2ozRTQvdmQ1TVA5dlhTajhUeUVnL2ZLOUdQeTZPUkQ5QlpFSS96akZBUCt6MlBUKzBzenMvUW1nNVA2MFVOejhRdVRRL2hsVXlQeW5xTHo4VmR5MC9aZndxUHpWNktEK2g4Q1UveGw4alA4REhJRCtzS0I0L3FZSWJQOVRWR0Q5S0loWS9LbWdUUDVPbkVEK2s0QTAvZXhNTFB6bEFDRC85WmdVLzU0Y0NQeTFHL3o1YmNmaytsNUh6UGlTbjdUNUZzdWMrUExQaFBreXEyejY2bDlVK3lYdlBQcjVXeVQ3ZktNTStjUEs4UHJlenRqNzdiTEErZ1I2cVBwTElvejV6YTUwK2JBZVhQc1dja0Q3SEs0byt1YlNEUHNkdmVqNGhhMjArRVZ4Z1BpbERVejc5SUVZK0lQWTRQaWJES3o2a2lCNCtMVWNSUGxmL0F6NXVZKzA5d3IzU1Bkb091RDNlVjUwOSs1bUNQYnlzVHoxbEhCbzltUXJKUENxbk96ekJlTmE2TFVSeHZGZlg0N3hNZ1NlOWxBOWR2UlZLaWIxYUJxUzliYnUrdlNKbzJiMU9DL1M5NDFFSHZpK1lGTDczMXlHK3BSQXZ2cVpCUEw1a2FrbStUWXBXdnMyZ1k3NVFyWEMrUmE5OXZnMVRoYjZleUl1K0RUaVN2aEtobUw1bUE1Kyt2MTZsdnRpeXE3NXAvN0crSzBTNHZ0aUF2cjRxdGNTKzIrREt2cVVEMGI1RkhkZStkUzNkdnZFejQ3NTJNT20rd0NMdnZvMEs5YjZiNS9xKzAxd0F2emhBQTcvYkhRYS9tL1VJdjFySEM3LzNrZzYvVkZnUnYxQVhGTC9OenhhL3JJRVp2OUFzSEw4YTBSNi9iVzRodjZzRUpMKzNreWEvZEJzcHY4ZWJLNytURkM2L3U0VXd2eWJ2TXIrM1VEVy9WYW8zditQN09iOUtSVHkvYm9ZK3Z6ZS9RTCtMNzBLL1V4ZEZ2M1UyUjcvYVRFbS9hMXBMdnhCZlRiK3pXaysvUGsxUnY1bzJVNyt6RmxXL2N1MVd2OFc2V0wrVmZscS8wRGhjdjJMcFhiODRrRisvUUMxaHYyZkFZcitjU1dTL3pzaGx2K3M5WjcvanFHaS9wd2xxdnlkZ2E3OVVyR3kvSCs1dHYzb2xiNzlZVW5DL3EzUnh2MmVNY3I5L21YTy81NXQwdjVXVGRiOStnSGEvbG1KM3Y5UTVlTDh2Qm5tL25zZDV2eGQrZXIrVUtYdS9EY3A3djNwZmZML1Y2WHkvR0dsOXZ6N2RmYjlBUm42L0hLUit2OHoyZnI5TlBuKy9uSHAvdjdhcmY3K1owWCsvUSt4L3Y3VDdmNyttLzM4L2xPTi9QNXlhZnovTUpIOC9PSUorUC8yeWZUOC90M3cvS285N1AvTTZlai9VdW5nL0VROTNQL1kzZFQvVk5YTS9DQWx4UC9HeGJqLzVNR3cva0lacFB5K3paajlUdDJNL2hKTmdQMDVJWFQ5RjFsay9BejVXUHl1QVVqOWxuVTQvWHBaS1A4eHJSajlxSGtJLythNDlQMEFlT1Q4TmJUUS9NcHd2UDRlc0tqL3JuaVUvUDNRZ1AyMHRHejloeXhVL0RVOFFQMmk1Q2o5ckN3VS9Mb3orUHQzVThqN3g4dVkrZitqYVBxYTN6ajZJWXNJK1R1dTFQaXBVcVQ1Um41dysvYzZQUG0zbGdqN095V3MrWXA5UlBqQlFOejdUNEJ3KzhWVUNQbUpvenoxOEFKbzlKUHRJUFJ1a3V6enpkMWE3WkQzeHZMdkFZNzFuWGFlOUZMM2N2UVA3Q0w1emZ5TytOT2M5dnFRdFdMNG1UbksrRWlLR3Zva0ZrNzQwejUrKzFYeXN2ak1NdWI0YWU4VytXOGZSdnMzdTNiNVE3K20reDhiMXZwQzVBTDhtZVFhL0pDRU12NDJ3RWI5bUpoZS91b0VjdjVqQkliOFY1U2EvU3VzcnYxYlRNTDlibkRXL2cwVTZ2LzNOUHIvOE5FTy92SGxIdjMyYlM3K0VtVSsvSDNOVHY2RW5WNzlqdGxxL3hoNWV2ekJnWWI4UGVtUy8yR3RudndjMWFyOGYxV3kvcVV0dnZ6ZVljYjlpdW5PL3liRjF2eForZDcvMkhubS9JWlI2djFYZGU3OVorbnkvK3VwOXZ3NnZmcjkwUm4rL0Q3Ri92ODd1ZjcvLy8vLy8vLy8vLy8vLy8vLy8vLy8vQUFBQUFBQUFBQUFwQUNrQUtRQlNBRklBZXdDa0FNZ0EzZ0JCMnYwQUM1Z0JLUUFwQUNrQUtRQjdBSHNBZXdDa0FLUUE4QUFLQVJzQkp3RXBBQ2tBS1FBcEFDa0FLUUFwQUNrQWV3QjdBSHNBZXdEd0FQQUE4QUFLQVFvQk1RRStBVWdCVUFGN0FIc0Fld0I3QUhzQWV3QjdBSHNBOEFEd0FQQUE4QUF4QVRFQk1RRStBVDRCVndGZkFXWUJiQUh3QVBBQThBRHdBUEFBOEFEd0FQQUFNUUV4QVRFQk1RRlhBVmNCVndGZkFWOEJjZ0Y0QVg0Qmd3RUFRWUQvQUF1NEJDZ0hCd2NIQndjSEJ3Y0hCd2NIQndjSEJ3Y0hCd2NIQndjSEJ3Y0hCd2NIQndjSEJ3Y0hCd2NIS0E4WEhCOGlKQ1luS1NvckxDMHVMeTh4TWpNME5UWTNOems2T3p3OVBqOC9RVUpEUkVWR1IwY29GQ0VwTURVNVBVQkNSVWRKUzB4T1VGSlZWMWxiWEY1Z1ltVm5hV3RzYm5CeWRYZDVlM3grZ0NnWEp6TThRMGxQVTFkYlhtRmtabWxyYjNOMmVYeCtnWU9IaTQ2UmxKYVptNStqcHFtc3JyR3pJeHd4UVU1WlkydHllSDZFaUkyUmxabWZwYXV3dExtOXdNZk4wOWpjNGVYbzcvWDdGU0U2VDJGd2ZZbVVuYWF1dHIzRHljL1o0K3Z6K3hFalAxWnFlNHVZcGJHN3hjN1czdWJ0K2hrZk4wdGJhWFdBaXBLYW9haXV0TG0reU5EWDN1WHI4UFgvRUNSQldXNkFrSit0dWNUUDJlTHE4dm9MS1VwbmdKZXN2OUhoOGY4SkswOXVpcU82eitQMkRDZEhZM3VRcExiRzF1VHgvUWtzVVhHT3FNRFc2LzhITVZwL29ML2M5d1l6WDRhcXkrb0hMMWQ3bTdqVTdRWTBZWW11MFBBRk9XcVh3T2NGTzIrZXl2TUZOMmVUdStBRlBIR2h6dmdFUVhxdjRBUkRmN2JxQUFBQUFBQUFBQURnNE9EZzRPRGc0S0Nnb0tDNXVibXlzcWlHUFNYZzRPRGc0T0RnNFBEdzhQRFB6OC9HeHJlUVFpaWdvS0Nnb0tDZ29MbTV1Ym5Cd2NHM3Q2eUtRQ2J3OFBEdzhQRHc4TS9QejgvTXpNekJ3YlNQUWlpNXVibTV1Ym01dWNIQndjSEJ3Y0czdDZ5S1FTZlB6OC9QejgvUHo4ek16TXpKeWNtOHZMQ05RaWpCd2NIQndjSEJ3Y0hCd2NIQ3dzSzR1SzJMUVNmTXpNek16TXpNek1uSnljbkd4c2E3dTYrTVFpZ0FRY0tEQVF1NUtXQUF3QUFnQVlBQklBQ0FBT0FBUUFHZ0FVQUFvQUFBQVdBQndBRUlBR2dBeUFBb0FZZ0JLQUNJQU9nQVNBR29BVWdBcUFBSUFXZ0J5QUVRQUhBQTBBQXdBWkFCTUFDUUFQQUFVQUd3QVZBQXNBQVFBWEFCMEFFWUFIZ0EyQUE0QVpnQk9BQ1lBUGdBV0FHNEFWZ0F1QUFZQVhnQjJBRUVBR1FBeEFBa0FZUUJKQUNFQU9RQVJBR2tBVVFBcEFBRUFXUUJ4QUVNQUd3QXpBQXNBWXdCTEFDTUFPd0FUQUdzQVV3QXJBQU1BV3dCekFFVUFIUUExQUEwQVpRQk5BQ1VBUFFBVkFHMEFWUUF0QUFVQVhRQjFBRWNBSHdBM0FBOEFad0JQQUNjQVB3QVhBRzhBVndBdkFBY0FYd0IzQUVCQUdFQXdRQWhBWUVCSVFDQkFPRUFRUUdoQVVFQW9RQUJBV0VCd1FFSkFHa0F5UUFwQVlrQktRQ0pBT2tBU1FHcEFVa0FxUUFKQVdrQnlRRVJBSEVBMFFBeEFaRUJNUUNSQVBFQVVRR3hBVkVBc1FBUkFYRUIwUUVaQUhrQTJRQTVBWmtCT1FDWkFQa0FXUUc1QVZrQXVRQVpBWGtCMlFFRkFHVUF4UUFsQVlVQkpRQ0ZBT1VBUlFHbEFVVUFwUUFGQVdVQnhRRU5BRzBBelFBdEFZMEJMUUNOQU8wQVRRR3RBVTBBclFBTkFXMEJ6UUVWQUhVQTFRQTFBWlVCTlFDVkFQVUFWUUcxQVZVQXRRQVZBWFVCMVFFZEFIMEEzUUE5QVowQlBRQ2RBUDBBWFFHOUFWMEF2UUFkQVgwQjNRRUNBR0lBd2dBaUFZSUJJZ0NDQU9JQVFnR2lBVUlBb2dBQ0FXSUJ3Z0VLQUdvQXlnQXFBWW9CS2dDS0FPb0FTZ0dxQVVvQXFnQUtBV29CeWdFU0FISUEwZ0F5QVpJQk1nQ1NBUElBVWdHeUFWSUFzZ0FTQVhJQjBnRWFBSG9BMmdBNkFab0JPZ0NhQVBvQVdnRzZBVm9BdWdBYUFYb0IyZ0VHQUdZQXhnQW1BWVlCSmdDR0FPWUFSZ0dtQVVZQXBnQUdBV1lCeGdFT0FHNEF6Z0F1QVk0QkxnQ09BTzRBVGdHdUFVNEFyZ0FPQVc0QnpnRVdBSFlBMWdBMkFaWUJOZ0NXQVBZQVZnRzJBVllBdGdBV0FYWUIxZ0VlQUg0QTNnQStBWjRCUGdDZUFQNEFYZ0crQVY0QXZnQWVBWDRCM2dFREFHTUF3d0FqQVlNQkl3Q0RBT01BUXdHakFVTUFvd0FEQVdNQnd3RUxBR3NBeXdBckFZc0JLd0NMQU9zQVN3R3JBVXNBcXdBTEFXc0J5d0VUQUhNQTB3QXpBWk1CTXdDVEFQTUFVd0d6QVZNQXN3QVRBWE1CMHdFYkFIc0Eyd0E3QVpzQk93Q2JBUHNBV3dHN0FWc0F1d0FiQVhzQjJ3RUhBR2NBeHdBbkFZY0JKd0NIQU9jQVJ3R25BVWNBcHdBSEFXY0J4d0VQQUc4QXp3QXZBWThCTHdDUEFPOEFUd0d2QVU4QXJ3QVBBVzhCendFWEFIY0Exd0EzQVpjQk53Q1hBUGNBVndHM0FWY0F0d0FYQVhjQjF3RWZBSDhBM3dBL0FaOEJQd0NmQVA4QVh3Ry9BVjhBdndBZkFYOEIzd0VBQUlBL0FBQUFnR1A2ZnorL2RWYThpK2wvUHdweDFyeDV6WDgvNTg0Z3ZTK21mejg2WGxhOXIzTi9QeFB5aGIzNU5YOC9LcStndlJMdGZqOHpaYnU5L1poK1B3UVQxcjI4T1g0L2M3Znd2VlhQZlQrb3FBVyt5MWw5UDd2dkVyNGwyWHcvWERBZ3ZtZE5mRC8xYVMyK21MWjdQL09iT3I2K0ZIcy93c1ZIdnVKbmVqL041bFMrQ2JCNVA0TCtZYjQ4N1hnL1RReHZ2b1FmZUQrY0QzeSs2a1ozUCs2RGhMNTNZM1kvUHZxS3ZqWjFkVDkxYXBHK01IeDBQMHpVbDc1eGVITS9lamVldmdOcWNqKzNrNlMrOUZCeFA3em9xcjVQTFhBL1FUYXh2aUgvYmo4QmZMZStkc1p0UDdTNXZiNWVnMncvRmUvRHZ1YzFhei9lRzhxK0h0NXBQOGsvMEw0U2ZHZy9rbHJXdnRRUFp6L3phOXkrZEpsbFA2cHo0cjRCR1dRL2NYSG92bzJPWWo4SFplNitLUHBnUHlkTzlMN21XMTgva0N6NnZ0ZXpYVDhBQUFDL0R3SmNQeHZrQXIrZ1Jsby9kOElGdjU2QldELzJtZ2kvSGJOV1AzZHRDNzh4MjFRLzJqa092Ky81VWo4QUFCRy9iQTlSUDhxL0U3KzlHMDgvR0hrV3YvZ2VUVC9OS3htL05CbExQOHJYRzcrSUNray84WHdldndyelJqOGtHeUcvMGRKRVAwYXlJNy8zcVVJL09rSW12NU40UUQvanlpaS92VDQrUHlWTUs3K1AvRHMvNDhVdHZ5S3lPVDhCT0RDL2tGODNQMldpTXIvekJEVS84d1ExdjJXaU1qK1FYemUvQVRnd1B5S3lPYi9qeFMwL2ovdzd2eVZNS3orOVBqNi80OG9vUDVONFFMODZRaVkvOTZsQ3YwYXlJei9SMGtTL0pCc2hQd3J6UnIveGZCNC9pQXBKdjhyWEd6ODBHVXUvelNzWlAvZ2VUYjhZZVJZL3ZSdFB2OHEvRXo5c0QxRy9BQUFSUCsvNVVyL2FPUTQvTWR0VXYzZHRDejhkczFhLzlwb0lQNTZCV0w5M3dnVS9vRVphdnh2a0FqOFBBbHkvQUFBQVA5ZXpYYitRTFBvKzVsdGZ2eWRPOUQ0byttQy9CMlh1UG8yT1lyOXhjZWcrQVJsa3Y2cHo0ajUwbVdXLzgydmNQdFFQWjcrU1d0WStFbnhvdjhrLzBENGUzbW0vM2h2S1B1YzFhNzhWNzhNK1hvTnN2N1M1dlQ1MnhtMi9BWHkzUGlIL2JyOUJOckUrVHkxd3Y3em9xajcwVUhHL3Q1T2tQZ05xY3I5Nk41NCtjWGh6djB6VWx6NHdmSFMvZFdxUlBqWjFkYjgrK29vK2QyTjJ2KzZEaEQ3cVJuZS9uQTk4UG9RZmVMOU5ERzgrUE8xNHY0TCtZVDRKc0htL3plWlVQdUpuZXIvQ3hVYyt2aFI3di9PYk9qNll0bnUvOVdrdFBtZE5mTDljTUNBK0pkbDh2N3Z2RWo3TFdYMi9xS2dGUGxYUGZiOXp0L0E5dkRsK3Z3UVQxajM5bUg2L00yVzdQUkx0ZnI4cXI2QTkrVFYvdnhQeWhUMnZjMysvT2w1V1BTK21mNy9uemlBOWVjMS92d3B4MWp5TDZYKy92M1ZXUEdQNmY3OEFNSTBrQUFDQXY3OTFWcnhqK24rL0NuSFd2SXZwZjcvbnppQzllYzEvdnpwZVZyMHZwbisvRS9LRnZhOXpmNzhxcjZDOStUVi92ek5sdTcwUzdYNi9CQlBXdmYyWWZyOXp0L0M5dkRsK3Y2aW9CYjVWejMyL3UrOFN2c3RaZmI5Y01DQytKZGw4di9WcExiNW5UWHkvODVzNnZwaTJlNy9DeFVlK3ZoUjd2ODNtVkw3aVozcS9ndjVodmdtd2ViOU5ERysrUE8xNHY1d1BmTDZFSDNpLzdvT0V2dXBHZDc4KytvcStkMk4ydjNWcWtiNDJkWFcvVE5TWHZqQjhkTDk2TjU2K2NYaHp2N2VUcEw0RGFuSy92T2lxdnZSUWNiOUJOckcrVHkxd3Z3Rjh0NzRoLzI2L3RMbTl2bmJHYmI4Vjc4TytYb05zdjk0YnlyN25OV3UveVQvUXZoN2VhYitTV3RhK0VueG92L05yM0w3VUQyZS9xblBpdm5TWlpiOXhjZWkrQVJsa3Z3ZGw3cjZOam1LL0owNzB2aWo2WUwrUUxQcSs1bHRmdndBQUFML1hzMTIvRytRQ3Z3OENYTDkzd2dXL29FWmF2L2FhQ0wrZWdWaS9kMjBMdngyelZyL2FPUTYvTWR0VXZ3QUFFYi92K1ZLL3lyOFR2MndQVWI4WWVSYS92UnRQdjgwckdiLzRIazIveXRjYnZ6UVpTNy94ZkI2L2lBcEp2eVFiSWI4SzgwYS9ScklqdjlIU1JMODZRaWEvOTZsQ3YrUEtLTCtUZUVDL0pVd3J2NzArUHIvanhTMi9qL3c3dndFNE1MOGlzam0vWmFJeXY1QmZONy96QkRXLzh3UTF2NUJmTjc5bG9qSy9Jckk1dndFNE1MK1AvRHUvNDhVdHY3MCtQcjhsVEN1L2szaEF2K1BLS0wvM3FVSy9Pa0ltdjlIU1JMOUdzaU8vQ3ZOR3Z5UWJJYitJQ2ttLzhYd2V2elFaUzcvSzF4dS8rQjVOdjgwckdiKzlHMCsvR0hrV3Yyd1BVYi9LdnhPLzcvbFN2d0FBRWI4eDIxUy8yamtPdngyelZyOTNiUXUvbm9GWXYvYWFDTCtnUmxxL2Q4SUZ2dzhDWEw4YjVBSy8xN05kdndBQUFML21XMSsva0N6NnZpajZZTDhuVHZTK2pZNWl2d2RsN3I0QkdXUy9jWEhvdm5TWlpiK3FjK0srMUE5bnYvTnIzTDRTZkdpL2tscld2aDdlYWIvSlA5Qys1elZydjk0YnlyNWVnMnkvRmUvRHZuYkdiYiswdWIyK0lmOXV2d0Y4dDc1UExYQy9RVGF4dnZSUWNiKzg2S3ErQTJweXY3ZVRwTDV4ZUhPL2VqZWV2akI4ZEw5TTFKZStOblYxdjNWcWtiNTNZM2EvUHZxS3Z1cEdkNy91ZzRTK2hCOTR2NXdQZkw0ODdYaS9UUXh2dmdtd2ViK0MvbUcrNG1kNnY4M21WTDYrRkh1L3dzVkh2cGkyZTcvem16cStaMDE4di9WcExiNGwyWHkvWERBZ3ZzdFpmYis3N3hLK1ZjOTl2NmlvQmI2OE9YNi9jN2Z3dmYyWWZyOEVFOWE5RXUxK3Z6Tmx1NzM1TlgrL0txK2d2YTl6Zjc4VDhvVzlMNlovdnpwZVZyMTV6WCsvNTg0Z3ZZdnBmNzhLY2RhOFkvcC92NzkxVnJ3QUFJQy9BREFOcFdQNmY3Ky9kVlk4aStsL3Z3cHgxang1elgrLzU4NGdQUyttZjc4NlhsWTlyM04vdnhQeWhUMzVOWCsvS3ErZ1BSTHRmcjh6WmJzOS9aaCt2d1FUMWoyOE9YNi9jN2Z3UFZYUGZiK29xQVUreTFsOXY3dnZFajRsMlh5L1hEQWdQbWROZkwvMWFTMCttTFo3di9PYk9qNitGSHUvd3NWSFB1Sm5lci9ONWxRK0NiQjV2NEwrWVQ0ODdYaS9UUXh2UG9RZmVMK2NEM3crNmtaM3YrNkRoRDUzWTNhL1B2cUtQaloxZGI5MWFwRStNSHgwdjB6VWx6NXhlSE8vZWplZVBnTnFjciszazZRKzlGQnh2N3pvcWo1UExYQy9RVGF4UGlIL2JyOEJmTGMrZHNadHY3UzV2VDVlZzJ5L0ZlL0RQdWMxYTcvZUc4bytIdDVwdjhrLzBENFNmR2kva2xyV1B0UVBaNy96YTl3K2RKbGx2NnB6NGo0QkdXUy9jWEhvUG8yT1lyOEhaZTQrS1BwZ3Z5ZE85RDdtVzErL2tDejZQdGV6WGI4QUFBQS9Ed0pjdnh2a0FqK2dSbHEvZDhJRlA1NkJXTC8ybWdnL0hiTld2M2R0Q3o4eDIxUy8yamtPUCsvNVVyOEFBQkUvYkE5UnY4cS9Feis5RzArL0dIa1dQL2dlVGIvTkt4ay9OQmxMdjhyWEd6K0lDa20vOFh3ZVB3cnpScjhrR3lFLzBkSkV2MGF5SXovM3FVSy9Pa0ltUDVONFFML2p5aWcvdlQ0K3Z5Vk1LeitQL0R1LzQ4VXRQeUt5T2I4Qk9EQS9rRjgzdjJXaU1qL3pCRFcvOHdRMVAyV2lNcitRWHpjL0FUZ3d2eUt5T1QvanhTMi9qL3c3UHlWTUs3KzlQajQvNDhvb3Y1TjRRRDg2UWlhLzk2bENQMGF5STcvUjBrUS9KQnNodndyelJqL3hmQjYvaUFwSlA4clhHNzgwR1VzL3pTc1p2L2dlVFQ4WWVSYS92UnRQUDhxL0U3OXNEMUUvQUFBUnYrLzVVai9hT1E2L01kdFVQM2R0Qzc4ZHMxWS85cG9JdjU2QldEOTN3Z1cvb0VaYVB4dmtBcjhQQWx3L0FBQUF2OWV6WFQrUUxQcSs1bHRmUHlkTzlMNG8rbUEvQjJYdXZvMk9Zajl4Y2VpK0FSbGtQNnB6NHI1MG1XVS84MnZjdnRRUFp6K1NXdGErRW54b1A4ay8wTDRlM21rLzNodkt2dWMxYXo4Vjc4TytYb05zUDdTNXZiNTJ4bTAvQVh5M3ZpSC9iajlCTnJHK1R5MXdQN3pvcXI3MFVIRS90NU9rdmdOcWNqOTZONTYrY1hoelAwelVsNzR3ZkhRL2RXcVJ2aloxZFQ4KytvcStkMk4yUCs2RGhMN3FSbmMvbkE5OHZvUWZlRDlOREcrK1BPMTRQNEwrWWI0SnNIay96ZVpVdnVKbmVqL0N4VWUrdmhSN1AvT2JPcjZZdG5zLzlXa3R2bWROZkQ5Y01DQytKZGw4UDd2dkVyN0xXWDAvcUtnRnZsWFBmVDl6dC9DOXZEbCtQd1FUMXIzOW1INC9NMlc3dlJMdGZqOHFyNkM5K1RWL1B4UHloYjJ2YzM4L09sNVd2UyttZnovbnppQzllYzEvUHdweDFyeUw2WDgvdjNWV3ZHUDZmejhBeUZPbEFBQ0FQNzkxVmp4aituOC9DbkhXUEl2cGZ6L256aUE5ZWMxL1B6cGVWajB2cG44L0UvS0ZQYTl6Zno4cXI2QTkrVFYvUHpObHV6MFM3WDQvQkJQV1BmMllmajl6dC9BOXZEbCtQNmlvQlQ1VnozMC91KzhTUHN0WmZUOWNNQ0ErSmRsOFAvVnBMVDVuVFh3Lzg1czZQcGkyZXovQ3hVYyt2aFI3UDgzbVZEN2laM28vZ3Y1aFBnbXdlVDlOREc4K1BPMTRQNXdQZkQ2RUgzZy83b09FUHVwR2R6OCsrb28rZDJOMlAzVnFrVDQyZFhVL1ROU1hQakI4ZEQ5Nk41NCtjWGh6UDdlVHBENERhbkkvdk9pcVB2UlFjVDlCTnJFK1R5MXdQd0Y4dHo0aC8yNC90TG05UG5iR2JUOFY3OE0rWG9Oc1A5NGJ5ajduTldzL3lUL1FQaDdlYVQrU1d0WStFbnhvUC9OcjNEN1VEMmMvcW5QaVBuU1paVDl4Y2VnK0FSbGtQd2RsN2o2TmptSS9KMDcwUGlqNllEK1FMUG8rNWx0ZlB3QUFBRC9YczEwL0crUUNQdzhDWEQ5M3dnVS9vRVphUC9hYUNEK2VnVmcvZDIwTFB4MnpWai9hT1E0L01kdFVQd0FBRVQvditWSS95cjhUUDJ3UFVUOFllUlkvdlJ0UFA4MHJHVC80SGswL3l0Y2JQelFaU3oveGZCNC9pQXBKUHlRYklUOEs4MFkvUnJJalA5SFNSRDg2UWlZLzk2bENQK1BLS0QrVGVFQS9KVXdyUDcwK1BqL2p4UzAvai93N1B3RTRNRDhpc2prL1phSXlQNUJmTnovekJEVS84d1ExUDVCZk56OWxvakkvSXJJNVB3RTRNRCtQL0RzLzQ4VXRQNzArUGo4bFRDcy9rM2hBUCtQS0tELzNxVUkvT2tJbVA5SFNSRDlHc2lNL0N2TkdQeVFiSVQrSUNray84WHdlUHpRWlN6L0sxeHMvK0I1TlA4MHJHVCs5RzA4L0dIa1dQMndQVVQvS3Z4TS83L2xTUHdBQUVUOHgyMVEvMmprT1B4MnpWajkzYlFzL25vRllQL2FhQ0QrZ1Jsby9kOElGUHc4Q1hEOGI1QUkvMTdOZFB3QUFBRC9tVzE4L2tDejZQaWo2WUQ4blR2UStqWTVpUHdkbDdqNEJHV1EvY1hIb1BuU1paVCtxYytJKzFBOW5QL05yM0Q0U2ZHZy9rbHJXUGg3ZWFUL0pQOUErNXpWclA5NGJ5ajVlZzJ3L0ZlL0RQbmJHYlQrMHViMCtJZjl1UHdGOHR6NVBMWEEvUVRheFB2UlFjVCs4NktvK0EycHlQN2VUcEQ1eGVITS9lamVlUGpCOGREOU0xSmMrTm5WMVAzVnFrVDUzWTNZL1B2cUtQdXBHZHovdWc0UStoQjk0UDV3UGZENDg3WGcvVFF4dlBnbXdlVCtDL21FKzRtZDZQODNtVkQ2K0ZIcy93c1ZIUHBpMmV6L3ptem8rWjAxOFAvVnBMVDRsMlh3L1hEQWdQc3RaZlQrNzd4SStWYzk5UDZpb0JUNjhPWDQvYzdmd1BmMllmajhFRTlZOUV1MStQek5sdXozNU5YOC9LcStnUGE5emZ6OFQ4b1U5TDZaL1B6cGVWajE1elg4LzU4NGdQWXZwZno4S2NkWThZL3AvUDc5MVZqd0FBREFBWUFDUUFNQUFFQUJBQUhBQW9BRFFBQ0FBVUFDQUFMQUE0QUFFQURRQVpBQ1VBTVFBRkFCRUFIUUFwQURVQUNRQVZBQ0VBTFFBNUFBSUFEZ0FhQUNZQU1nQUdBQklBSGdBcUFEWUFDZ0FXQUNJQUxnQTZBQU1BRHdBYkFDY0FNd0FIQUJNQUh3QXJBRGNBQ3dBWEFDTUFMd0E3QUFCQURFQVlRQ1JBTUVBRVFCQkFIRUFvUURSQUNFQVVRQ0JBTEVBNFFBRkFEVUFaUUNWQU1VQUZRQkZBSFVBcFFEVkFDVUFWUUNGQUxVQTVRQUpBRGtBYVFDWkFNa0FHUUJKQUhrQXFRRFpBQ2tBV1FDSkFMa0E2UUFOQUQwQWJRQ2RBTTBBSFFCTkFIMEFyUURkQUMwQVhRQ05BTDBBN1FBQ0FESUFZZ0NTQU1JQUVnQkNBSElBb2dEU0FDSUFVZ0NDQUxJQTRnQUdBRFlBWmdDV0FNWUFGZ0JHQUhZQXBnRFdBQ1lBVmdDR0FMWUE1Z0FLQURvQWFnQ2FBTW9BR2dCS0FIb0FxZ0RhQUNvQVdnQ0tBTG9BNmdBT0FENEFiZ0NlQU00QUhnQk9BSDRBcmdEZUFDNEFYZ0NPQUw0QTdnQURBRE1BWXdDVEFNTUFFd0JEQUhNQW93RFRBQ01BVXdDREFMTUE0d0FIQURjQVp3Q1hBTWNBRndCSEFIY0Fwd0RYQUNjQVZ3Q0hBTGNBNXdBTEFEc0Fhd0NiQU1zQUd3QkxBSHNBcXdEYkFDc0FXd0NMQUxzQTZ3QVBBRDhBYndDZkFNOEFId0JQQUg4QXJ3RGZBQzhBWHdDUEFMOEE3d0R3QUFBQWlZaUlPd0VBQUFBRkFEQUFBd0FRQUFRQUJBQUVBQUVBUVl5dEFRc0dnRlFBQUlCRkFFR2lyUUVMaVFJWUFEQUFTQUJnQUFnQUlBQTRBRkFBYUFBUUFDZ0FRQUJZQUhBQUJBQWNBRFFBVEFCa0FBd0FKQUE4QUZRQWJBQVVBQ3dBUkFCY0FIUUFBUUFaQURFQVNRQmhBQWtBSVFBNUFGRUFhUUFSQUNrQVFRQlpBSEVBQlFBZEFEVUFUUUJsQUEwQUpRQTlBRlVBYlFBVkFDMEFSUUJkQUhVQUFnQWFBRElBU2dCaUFBb0FJZ0E2QUZJQWFnQVNBQ29BUWdCYUFISUFCZ0FlQURZQVRnQm1BQTRBSmdBK0FGWUFiZ0FXQUM0QVJnQmVBSFlBQXdBYkFETUFTd0JqQUFzQUl3QTdBRk1BYXdBVEFDc0FRd0JiQUhNQUJ3QWZBRGNBVHdCbkFBOEFKd0EvQUZjQWJ3QVhBQzhBUndCZkFIY0FlQUFBQUlpSUNEd0NBQUFBQlFBWUFBTUFDQUFDQUFRQUJBQUJBRUc4cndFTEJxQldBQUNBUlFCQjBxOEJDNDBCREFBWUFDUUFNQUFFQUJBQUhBQW9BRFFBQ0FBVUFDQUFMQUE0QUFFQURRQVpBQ1VBTVFBRkFCRUFIUUFwQURVQUNRQVZBQ0VBTFFBNUFBSUFEZ0FhQUNZQU1nQUdBQklBSGdBcUFEWUFDZ0FXQUNJQUxnQTZBQU1BRHdBYkFDY0FNd0FIQUJNQUh3QXJBRGNBQ3dBWEFDTUFMd0E3QUR3QUFBQ0ppSWc4QXdBQUFBVUFEQUFEQUFRQUJBQUJBRUgwc0FFTFRkQlhBQUNBUlFBQUFBQUFBTUJZQUFDQVd3QUFQRjRBQVBSZ0FBQ29Zd0FBV0dZQUFBUnBBQUJzYWdBQUtHc0FBSnhyQUFEb2F3QUFJR3dBQUVCc0FBQlliQUFBWkd3QUFBQUFBQUFCQUVHRXR3RUxvQ01CQUFBQUFRQUFBQUVBQUFBQkFBQUFBUUFBQUFFQUFBQUJBQUFBQVFBQUFBRUFBQUFCQUFBQUFRQUFBQUVBQUFBQkFBQUFBUUFBQUFFQUFBQUJBQUFBQVFBQUFBRUFBQUFCQUFBQUFRQUFBQUVBQUFBQkFBQUFBUUFBQUFFQUFBQUJBQUFBQVFBQUFBRUFBQUFCQUFBQUFRQUFBQUVBQUFBQkFBQUFBUUFBQUFFQUFBQUJBQUFBQVFBQUFBRUFBQUFCQUFBQUFRQUFBQUVBQUFBQkFBQUFBUUFBQUFFQUFBQUJBQUFBQVFBQUFBRUFBQUFCQUFBQUFRQUFBQUVBQUFBQkFBQUFBUUFBQUFFQUFBQUJBQUFBQVFBQUFBRUFBQUFCQUFBQUFRQUFBQUVBQUFBQkFBQUFBUUFBQUFFQUFBQUJBQUFBQVFBQUFBRUFBQUFCQUFBQUFRQUFBQUVBQUFBQkFBQUFBUUFBQUFFQUFBQUJBQUFBQVFBQUFBRUFBQUFCQUFBQUFRQUFBQUVBQUFBQkFBQUFBUUFBQUFFQUFBQUJBQUFBQVFBQUFBRUFBQUFCQUFBQUFRQUFBQUVBQUFBQkFBQUFBUUFBQUFFQUFBQUJBQUFBQVFBQUFBRUFBQUFCQUFBQUFRQUFBQUVBQUFBQkFBQUFBUUFBQUFFQUFBQUJBQUFBQVFBQUFBRUFBQUFCQUFBQUFRQUFBQUVBQUFBQkFBQUFBUUFBQUFFQUFBQUJBQUFBQVFBQUFBRUFBQUFCQUFBQUFRQUFBQUVBQUFBQkFBQUFBUUFBQUFFQUFBQUJBQUFBQVFBQUFBRUFBQUFCQUFBQUFRQUFBQUVBQUFBQkFBQUFBUUFBQUFFQUFBQUJBQUFBQVFBQUFBRUFBQUFCQUFBQUFRQUFBQUVBQUFBQkFBQUFBUUFBQUFFQUFBQUJBQUFBQVFBQUFBRUFBQUFCQUFBQUFRQUFBQUVBQUFBQkFBQUFBUUFBQUFFQUFBQUJBQUFBQVFBQUFBRUFBQUFCQUFBQUFRQUFBQUVBQUFBQkFBQUFBUUFBQUFFQUFBQUJBQUFBQVFBQUFBRUFBQUFCQUFBQUFRQUFBQUVBQUFBQkFBQUFBUUFBQUFFQUFBQUJBQUFBQVFBQUFBRUFBQUFCQUFBQUFRQUFBQUVBQUFBQkFBQUFBUUFBQUFFQUFBQUJBQUFBQVFBQUFBRUFBQUFCQUFBQUFRQUFBQUVBQUFBQkFBQUFBUUFBQUFNQUFBQUZBQUFBQndBQUFBa0FBQUFMQUFBQURRQUFBQThBQUFBUkFBQUFFd0FBQUJVQUFBQVhBQUFBR1FBQUFCc0FBQUFkQUFBQUh3QUFBQ0VBQUFBakFBQUFKUUFBQUNjQUFBQXBBQUFBS3dBQUFDMEFBQUF2QUFBQU1RQUFBRE1BQUFBMUFBQUFOd0FBQURrQUFBQTdBQUFBUFFBQUFEOEFBQUJCQUFBQVF3QUFBRVVBQUFCSEFBQUFTUUFBQUVzQUFBQk5BQUFBVHdBQUFGRUFBQUJUQUFBQVZRQUFBRmNBQUFCWkFBQUFXd0FBQUYwQUFBQmZBQUFBWVFBQUFHTUFBQUJsQUFBQVp3QUFBR2tBQUFCckFBQUFiUUFBQUc4QUFBQnhBQUFBY3dBQUFIVUFBQUIzQUFBQWVRQUFBSHNBQUFCOUFBQUFmd0FBQUlFQUFBQ0RBQUFBaFFBQUFJY0FBQUNKQUFBQWl3QUFBSTBBQUFDUEFBQUFrUUFBQUpNQUFBQ1ZBQUFBbHdBQUFKa0FBQUNiQUFBQW5RQUFBSjhBQUFDaEFBQUFvd0FBQUtVQUFBQ25BQUFBcVFBQUFLc0FBQUN0QUFBQXJ3QUFBTEVBQUFDekFBQUF0UUFBQUxjQUFBQzVBQUFBdXdBQUFMMEFBQUMvQUFBQXdRQUFBTU1BQUFERkFBQUF4d0FBQU1rQUFBRExBQUFBelFBQUFNOEFBQURSQUFBQTB3QUFBTlVBQUFEWEFBQUEyUUFBQU5zQUFBRGRBQUFBM3dBQUFPRUFBQURqQUFBQTVRQUFBT2NBQUFEcEFBQUE2d0FBQU8wQUFBRHZBQUFBOFFBQUFQTUFBQUQxQUFBQTl3QUFBUGtBQUFEN0FBQUEvUUFBQVA4QUFBQUJBUUFBQXdFQUFBVUJBQUFIQVFBQUNRRUFBQXNCQUFBTkFRQUFEd0VBQUJFQkFBQVRBUUFBRlFFQUFCY0JBQUFaQVFBQUd3RUFBQjBCQUFBZkFRQUFJUUVBQUNNQkFBQWxBUUFBSndFQUFDa0JBQUFyQVFBQUxRRUFBQzhCQUFBeEFRQUFNd0VBQURVQkFBQTNBUUFBT1FFQUFEc0JBQUE5QVFBQVB3RUFBRUVCQUFCREFRQUFSUUVBQUVjQkFBQkpBUUFBU3dFQUFFMEJBQUJQQVFBQVVRRUFBRk1CQUFCVkFRQUFWd0VBQUZrQkFBQmJBUUFBWFFFQUFGOEJBQUFOQUFBQUdRQUFBQ2tBQUFBOUFBQUFWUUFBQUhFQUFBQ1JBQUFBdFFBQUFOMEFBQUFKQVFBQU9RRUFBRzBCQUFDbEFRQUE0UUVBQUNFQ0FBQmxBZ0FBclFJQUFQa0NBQUJKQXdBQW5RTUFBUFVEQUFCUkJBQUFzUVFBQUJVRkFBQjlCUUFBNlFVQUFGa0dBQUROQmdBQVJRY0FBTUVIQUFCQkNBQUF4UWdBQUUwSkFBRFpDUUFBYVFvQUFQMEtBQUNWQ3dBQU1Rd0FBTkVNQUFCMURRQUFIUTRBQU1rT0FBQjVEd0FBTFJBQUFPVVFBQUNoRVFBQVlSSUFBQ1VUQUFEdEV3QUF1UlFBQUlrVkFBQmRGZ0FBTlJjQUFCRVlBQUR4R0FBQTFSa0FBTDBhQUFDcEd3QUFtUndBQUkwZEFBQ0ZIZ0FBZ1I4QUFJRWdBQUNGSVFBQWpTSUFBSmtqQUFDcEpBQUF2U1VBQU5VbUFBRHhKd0FBRVNrQUFEVXFBQUJkS3dBQWlTd0FBTGt0QUFEdExnQUFKVEFBQUdFeEFBQ2hNZ0FBNVRNQUFDMDFBQUI1TmdBQXlUY0FBQjA1QUFCMU9nQUEwVHNBQURFOUFBQ1ZQZ0FBL1Q4QUFHbEJBQURaUWdBQVRVUUFBTVZGQUFCQlJ3QUF3VWdBQUVWS0FBRE5Td0FBV1UwQUFPbE9BQUI5VUFBQUZWSUFBTEZUQUFCUlZRQUE5VllBQUoxWUFBQkpXZ0FBK1ZzQUFLMWRBQUJsWHdBQUlXRUFBT0ZpQUFDbFpBQUFiV1lBQURsb0FBQUphZ0FBM1dzQUFMVnRBQUNSYndBQWNYRUFBRlZ6QUFBOWRRQUFLWGNBQUJsNUFBQU5ld0FBQlgwQUFBRi9BQUFCZ1FBQUJZTUFBQTJGQUFBWmh3QUFLWWtBQUQyTEFBQlZqUUFBY1k4QUFKR1JBQUMxa3dBQTNaVUFBQW1ZQUFBNW1nQUFiWndBQUtXZUFBRGhvQUFBSWFNQUFHV2xBQUN0cHdBQStha0FBRW1zQUFDZHJnQUE5YkFBQUZHekFBQ3h0UUFBRmJnQUFIMjZBQURwdkFBQVdiOEFBTTNCQUFCRnhBQUF3Y1lBQUVISkFBREZ5d0FBVGM0QUFOblFBQUJwMHdBQS9kVUFBSlhZQUFBeDJ3QUEwZDBBQUhYZ0FBQWQ0d0FBeWVVQUFIbm9BQUF0NndBQTVlMEFBS0h3QUFBL0FBQUFnUUFBQU9jQUFBQjVBUUFBUHdJQUFFRURBQUNIQkFBQUdRWUFBUDhIQUFCQkNnQUE1d3dBQVBrUEFBQi9Fd0FBZ1JjQUFBY2NBQUFaSVFBQXZ5WUFBQUV0QUFEbk13QUFlVHNBQUw5REFBREJUQUFBaDFZQUFCbGhBQUIvYkFBQXdYZ0FBT2VGQUFENWt3QUEvNklBQUFHekFBQUh4QUFBR2RZQUFEL3BBQUNCL1FBQTV4SUJBSGtwQVFBL1FRRUFRVm9CQUlkMEFRQVprQUVBLzZ3QkFFSExBUURuNmdFQStRc0NBSDh1QWdDQlVnSUFCM2dDQUJtZkFnQy94d0lBQWZJQ0FPY2RBd0I1U3dNQXYzb0RBTUdyQXdDSDNnTUFHUk1FQUg5SkJBREJnUVFBNTdzRUFQbjNCQUQvTlFVQUFYWUZBQWU0QlFBWi9BVUFQMElHQUlHS0JnRG4xQVlBZVNFSEFEOXdCd0JCd1FjQWh4UUlBQmxxQ0FEL3dRZ0FRUndKQU9kNENRRDUxd2tBZnprS0FJR2RDZ0FIQkFzQUdXMExBTC9ZQ3dBQlJ3d0E1N2NNQUhrckRRQy9vUTBBd1JvT0FJZVdEZ0FaRlE4QWY1WVBBTUVhRUFEbm9SQUErU3NSQVArNEVRQUJTUklBQjl3U0FCbHlFd0EvQ3hRQWdhY1VBT2RHRlFCNTZSVUFQNDhXQUVFNEZ3Q0g1QmNBR1pRWUFQOUdHUUJCL1JrQTU3WWFBUGx6R3dCL05Cd0FnZmdjQUFmQUhRQVppeDRBdjFrZkFBRXNJQURuQVNFQWVkc2hBTCs0SWdEQm1TTUFoMzRrQUJsbkpRQi9VeVlBd1VNbkFPYzNLQUQ1THlrQS95c3FBQUVzS3dBSE1Dd0FHVGd0QUQ5RUxnQ0JWQzhBNTJnd0FIbUJNUUEvbmpJQVFiOHpBSWZrTkFBWkRqWUEvenMzQUVGdU9BRG5wRGtBK2Q4NkFIOGZQQUNCWXowQUI2dytBQm41UHdDL1NrRUFBYUZDQU9mN1F3QjVXMFVBdjc5R0FNRW9TQUNIbGtrQUdRbExBSCtBVEFEQi9FMEE1MzFQQVBrRFVRRC9qbElBQVI5VUFBZTBWUUFaVGxjQVArMVlBSUdSV2dEbk9sd0FlZWxkQUQrZFh3QkJWbUVBaHhSakFCbllaQUQvb0dZQVFXOW9BT2RDYWdENUcyd0FmL3B0QUVFQkFBQ3BBZ0FBQ1FVQUFNRUlBQUJCRGdBQUNSWUFBS2tnQUFEQkxnQUFBVUVBQUNsWUFBQUpkUUFBZ1pnQUFJSERBQUFKOXdBQUtUUUJBQUY4QVFEQnp3RUFxVEFDQUFtZ0FnQkJId01Bd2E4REFBbFRCQUNwQ2dVQVFkZ0ZBSUc5QmdBcHZBY0FDZFlJQUFFTkNnQUJZd3NBQ2RvTUFDbDBEZ0NCTXhBQVFSb1NBS2txRkFBSlp4WUF3ZEVZQUVGdEd3QUpQQjRBcVVBaEFNRjlKQUFCOWljQUthd3JBQW1qTHdDQjNUTUFnVjQ0QUFrcFBRQXBRRUlBQWFkSEFNRmdUUUNwY0ZNQUNkcFpBRUdnWUFEQnhtY0FDVkZ2QUtsQ2R3QkJuMzhBZ1dxSUFDbW9rUUFKWEpzQUFZcWxBQUUyc0FBSlpMc0FLUmpIQUlGVzB3QkJJK0FBcVlMdEFBbDUrd0RCQ2dvQlFUd1pBUWtTS1FHcGtEa0J3YnhLQVFHYlhBRXBNRzhCQ1lHQ0FZR1NsZ0dCYWFzQkNRdkJBU2w4MXdFQnd1NEJ3ZUVHQXFuZ0h3SUp4RGtDUVpGVUFzRk5jQUlKLzR3Q3FhcXFBa0ZXeVFLQkIra0NLY1FKQXdtU0t3TUJkMDREQVhseUF3bWVsd01wN0wwRGdXbmxBMEVjRGdTcENqZ0VDVHRqQk1Hemp3UkJlNzBFQ1pqc0JLa1FIUVhCNjA0RkFUQ0NCU25rdGdVSkQrMEZnYmNrQm9Ia1hRWUpuWmdHS2VqVUJnSE5FZ2ZCVWxJSHFZQ1RCd2xlMWdkQjhob0l3VVJoQ0FsZHFRaXBRdk1JUWYwK0NZR1VqQWtwRU53SkNYZ3RDZ0hVZ0FvQkxOWUtDWWd0Q3lud2hndUJiT0lMUVFWQURLbkNud3dKclFFTndjeGxEVUVxekEwSnpqUU9xY0NmRHNFS0RROEJ0WHdQS2NqdUR3bE5ZeENCVE5vUWdjOVRFUW5menhFcGhFNFNBY2pQRXNHelV4T3BVTm9UQ2FoakZFSEQ3eFRCcTM0VkNXc1FGcWtLcFJaQmxEd1hnUkhYRnltTWRCZ0pEaFVaQWFHNEdRRlBYeG9KSWdrYktTUzJHNEZmWmh4QjNoa2RxYXJRSFFuUGloN0JWVWdmUVVrSklBbTB6U0Nwb0pVaHdSbGhJZ0VxTUNNcDNBSWtDVHZaSklGUnN5V1RCZ0FBUlE0QUFBOGNBQUFSTXdBQVcxY0FBQTJPQUFCMzNRQUFPVTBCQUdQbUFRQ1Zzd0lBSDhFREFDRWRCUUNyMXdZQTNRSUpBQWV6Q3dESi9nNEFNLzhTQU9YUEZ3QXZqeDBBTVY0a0FQdGdMQUN0dmpVQWw2RkFBRmszVFFBRHNWc0FOVU5zQUQ4bWZ3QkJscFFBUzlPc0FIMGh5QUFueWVZQTZSWUpBZE5iTHdHRjdWa0JUeWFKQVZGbHZRR2JEdmNCVFlzMkFyZEpmQUo1dmNnQ28xOGNBOVd1ZHdOZkw5c0RZV3RIQk92eXZBUWRYRHdGUjBQR0JRbExXd1p6SFB3R0pXZXBCMi9oWXdoeFNDd0pPMkFEQ3UzejZRclgxZUFMbWQvb0RFUHlBZzUxOWk4UGY5eHdFSUdjeGhHTE5qSVR2YkswRkdjaFR4WXBtd0lZRTBIUUdjVTh1UnVQd0w0ZGtRZmlIOXRWSkNLTitJWWs5MFVMSjdtZHNpbmphSDRzRlJwd0w1OHRpVEtoS2NzMUs1NDNPVjBsMER5SFk1WkFTUWVNUkxQSnNraGxiZ3hOcjhPYVViR2lYMVo3NzF4YkxabVVZQmVhQ0diWjk3cHJnOE90Y2JVWjQzZS9JbDErSFNNQUFIRk5BQUNSbkFBQS9TWUJBR1VNQWdEcGR3TUFtYUlGQURYV0NBQXRjQTBBNGVRVEFDSERIQUR0dHlnQWRaSTRBRmxJVFFBcCttY0FKZmlKQUQzSHRBQlJKdW9Bc1JNc0FkM1NmQUdGOHQ0QnlWSlZBcmtyNHdJVkZJd0RUUWhVQk1GeFB3VkJMbE1HelplVUI1V01DUWs1ZDdnS1NWZW9EQVhLNEE1ZEUyb1JNU2RORk5HeWt4ZTlKa2dicGNCMUg2bVZLQ1RabkcwcDlibFNMMjNJNWpXaHBqazlZVUZjUmEyZllFNjE3bGxZR1k1Y1kya2NmbS9sZzlWOC83MEFBQUdvQVFDUGF3TUE4WjRHQUQ4akRBREJQUlVBajdZakFQSDhPUUQvVVZzQUFmcUxBQTkxMFFCeHZ6SUJQNXE0QWNIY2JRSVB6MThEY1k2ZUJQOTdQUVlCdGxNSWo1ejhDdkZoV0E0L3A0d1N3U1hGRjQ5bE5CN3hnUlFtLy91bkx3R2NPanNQWWlKSmNZYkFXVCtLZ20zQldPT0VBUTRFQUpFaENRQVJMQk1BUWU0bEFFRlBSd0NSUTRBQUVmZmRBQUZHY3dFQmtsb0NFUUc0QTVFMXZBVkJqNmNJUVFiT0RCR3lteEtSRDVvYUFScDJKUUZNQnpTUm5sZEhFWjJzWUVHbWtZRWpVUllBeFo0eUFCZTVhd0NaOXRnQWE0bWdBUTNFL2dJZkFWQUZJZGtkQ1ROc01BL1ZvcVFZcDJjSUp5bjlmVHg3dGVkYkhYY2RpYStnTGNtdGpuc0FpZVlaQVRtV1hnSTlGdGdFdFdOM0NlRW94aEVoQXpRZ2RVaUNPSDFYVjJDL1c2OENnZGduQnZlRVhnM3AvcTBiZjR2ck5vRzM1V2dYQTV6QndRei9EamxxaFNJWjdwRkxnWGdybmpQaENWU1Zpd0FBTjVnQUFQK2xBQUFFdFFBQVo4VUFBRVhYQUFEQjZnQUEvLzhBQUFBQXprQUFBTWhBQUFDNFFBQUFxa0FBQUtKQUFBQ2FRQUFBa0VBQUFJeEFBQUNjUUFBQWxrQUFBSkpBQUFDT1FBQUFuRUFBQUpSQUFBQ0tRQUFBa0VBQUFJeEFBQUNVUUFBQW1FQUFBSTVBQUFCd1FBQUFjRUFBQUhCQUFBQndRQUFBY0VBQVFiRGFBUXZ5QWtoL1FZRkNnRUdBUUlBK2dFQ0FRSUJjVGx4UFhFNWFUM1FwY3loeUtJUWFoQnFSRWFFTXNBcXhDeGl6TUlvMmh6YUVOWVk0aFRlRU40UTlja1pnU2xoTFdGZEtXVUpiUTJRN2JESjRLSG9sWVN0T01sTk9WRkZZUzFaS1YwZGFTVjFLWFVwdEtISWtkU0oxSW84UmtSS1NFNklNcFFxeUI3MEd2Z2l4Q1JleU5uTS9aa0ppUldOS1dVZGJTVnRPV1ZaUVhFSmRRR1k3Wnp4b1BIVTBleXlLSTRVZllTWk5MVDFhWFR4cEttc3BiaTEwSm5FbWNDWjhHb1FiaUJPTUZKc09ueENlRXFvTnNRcTdDTUFHcndtZkNoV3lPMjVIVmt0VlZGTmJRbGhKVjBoY1MySklhVHByTm5NMGNqZHdPSUV6aENpV0lZd2RZaU5OS2lwNVlFSnNLMjhvZFN4N0lIZ2tkeUYvSVlZaWl4V1RGNWdVbmhtYUdxWVZyUkM0RGJnS2xnMkxEeGF5UDNKS1VsUlRYRkpuUG1CSVlFTmxTV3RJY1RkMk5IMDBkalIxTjRjeGlTZWRJSkVkWVNGTktBQUFaajhBQUV3L0FBQW1Qd0FBQUQ4QWhtcy9BQlF1UHdCd3ZUNEEwRXcrQWdFQVFiSGRBUXNnQ0EwUUV4VVhHQm9iSEIwZUh5QWdJU0lpSXlRa0pTVVBBQUFBQ2dBQUFBVUFRZWJkQVF2aEZlQS9BQUFBQUFBQTRMOERBQUFBQkFBQUFBUUFBQUFHQUFBQWcvbWlBRVJPYmdEOEtSVUEwVmNuQU4wMDlRQmkyOEFBUEptVkFFR1FRd0JqVWY0QXU5NnJBTGRoeFFBNmJpUUEwazFDQUVrRzRBQUo2aTRBSEpMUkFPc2QvZ0Fwc1J3QTZENm5BUFUxZ2dCRXV5NEFuT21FQUxRbWNBQkJmbDhBMXBFNUFGT0RPUUNjOURrQWkxK0VBQ2o1dlFENEh6c0EzditYQUErWUJRQVJMKzhBQ2xxTEFHMGZiUURQZmpZQUNjc25BRVpQdHdDZVpqOEFMZXBmQUxvbmRRRGw2OGNBUFh2eEFQYzVCd0NTVW9vQSsydnFBQit4WHdBSVhZMEFNQU5XQUh2OFJnRHdxMnNBSUx6UEFEYjBtZ0RqcVIwQVhtR1JBQWdiNWdDRm1XVUFvQlJmQUkxQWFBQ0EyUDhBSjNOTkFBWUdNUURLVmhVQXlhaHpBSHZpWUFCcmpNQUFHY1JIQU0xbnd3QUo2TndBV1lNcUFJdDJ4QUNtSEpZQVJLL2RBQmxYMFFDbFBnVUFCUWYvQUROK1B3RENNdWdBbUUvZUFMdDlNZ0FtUGNNQUhtdnZBSi80WGdBMUh6b0FmL0xLQVBHSEhRQjhrQ0VBYWlSOEFOVnUrZ0F3TFhjQUZUdERBTFVVeGdEREdaMEFyY1RDQUN4TlFRQU1BRjBBaG4xR0FPTnhMUUNieHBvQU0ySUFBTFRTZkFDMHA1Y0FOMVhWQU5jKzlnQ2pFQmdBVFhiOEFHU2RLZ0J3MTZzQVkzejRBSHF3VndBWEZlY0F3RWxXQUR2VzJRQ25oRGdBSkNQTEFOYUtkd0JhVkNNQUFCKzVBUEVLR3dBWnp0OEFuekgvQUdZZWFnQ1pWMkVBclB0SEFINS8yQUFpWmJjQU11aUpBT2EvWUFEdnhNMEFiRFlKQUYwLzFBQVczdGNBV0R2ZUFONmJrZ0RTSWlnQUtJYm9BT0pZVFFER3lqSUFDT01XQU9COXl3QVh3RkFBOHgybkFCamdXd0F1RXpRQWd4SmlBSU5JQVFEMWpsc0FyYkIvQUI3cDhnQklTa01BRUdmVEFLcmQyQUN1WDBJQWFtSE9BQW9vcEFEVG1iUUFCcWJ5QUZ4M2Z3Q2p3b01BWVR5SUFJcHplQUN2akZvQWI5ZTlBQzJtWXdEMHY4c0FqWUh2QUNiQlp3QlZ5a1VBeXRrMkFDaW8wZ0RDWVkwQUVzbDNBQVFtRkFBU1Jwc0F4Rm5FQU1qRlJBQk5zcEVBQUJmekFOUkRyUUFwU2VVQS9kVVFBQUMrL0FBZWxNd0FjTTd1QUJNKzlRRHM4WUFBcytmREFNZjRLQUNUQlpRQXdYRStBQzRKc3dBTFJmTUFpQktjQUtzZ2V3QXV0WjhBUjVMQ0FIc3lMd0FNVlcwQWNxZVFBR3ZuSHdBeHk1WUFlUlpLQUVGNTRnRDAzNGtBNkpTWEFPTG1oQUNaTVpjQWlPMXJBRjlmTmdDNy9RNEFTSnEwQUdla2JBQnhja0lBalYweUFKOFZ1QUM4NVFrQWpURWxBUGQwT1FBd0JSd0FEUXdCQUVzSWFBQXM3bGdBUjZxUUFIVG5BZ0M5MWlRQTkzMm1BRzVJY2dDZkZ1OEFqcFNtQUxTUjlnRFJVMUVBendyeUFDQ1lNd0QxUzM0QXNtTm9BTjArWHdCQVhRTUFoWWwvQUZWU0tRQTNaTUFBYmRnUUFESklNZ0JiVEhVQVRuSFVBRVZVYmdBTENjRUFLdlZwQUJSbTFRQW5CNTBBWFFSUUFMUTcyd0RxZHNVQWgva1hBRWxyZlFBZEo3b0FsbWtwQU1iTXJBQ3RGRlFBa09KcUFJalppUUFzY2xBQUJLUytBSGNIbEFEek1IQUFBUHduQU9weHFBQm13a2tBWk9BOUFKZmRnd0NqUDVjQVE1VDlBQTJHakFBeFFkNEFram1kQU4xd2pBQVh0K2NBQ044N0FCVTNLd0JjZ0tBQVdvQ1RBQkFSa2dBUDZOZ0FiSUN2QU52L1N3QTRrQThBV1JoMkFHS2xGUUJoeTdzQXg0bTVBQkJBdlFEUzhnUUFTWFVuQU91MjlnRGJJcnNBQ2hTcUFJa21Md0JrZzNZQUNUc3pBQTZVR2dCUk9xb0FIYVBDQUsvdHJnQmNKaElBYmNKTkFDMTZuQURBVnBjQUF6K0RBQW53OWdBclFJd0FiVEdaQURtMEJ3QU1JQlVBMk1OYkFQV1N4QURHclVzQVRzcWxBS2MzelFEbXFUWUFxNUtVQU4xQ2FBQVpZOTRBZG96dkFHaUxVZ0Q4MnpjQXJxR3JBTjhWTVFBQXJxRUFEUHZhQUdSTlpnRHRCYmNBS1dVd0FGZFd2d0JIL3pvQWF2bTVBSFcrOHdBb2s5OEFxNEF3QUdhTTlnQUV5eFVBK2lJR0FObmtIUUE5czZRQVZ4dVBBRGJOQ1FCT1F1a0FFNzZrQURNanRRRHdxaG9BVDJXb0FOTEJwUUFMUHc4QVczak5BQ1A1ZGdCN2l3UUFpUmR5QU1hbVV3QnZidUlBNytzQUFKdEtXQURFMnJjQXFtYTZBSGJQendEUkFoMEFzZkV0QUl5WndRRERyWGNBaGtqYUFQZGRvQURHZ1BRQXJQQXZBTjNzbWdBL1hMd0EwTjV0QUpESEh3QXEyN1lBb3lVNkFBQ3ZtZ0N0VTVNQXRsY0VBQ2t0dEFCTGdINEEyZ2VuQUhhcURnQjdXYUVBRmhJcUFOeTNMUUQ2NWYwQWlkditBSW0rL1FEa2Rtd0FCcW44QUQ2QWNBQ0ZiaFVBL1lmL0FDZytCd0JoWnpNQUtoaUdBRTI5NmdDejU2OEFqMjF1QUpWbk9RQXh2MXNBaE5kSUFERGZGZ0RITFVNQUpXRTFBTWx3emdBd3k3Z0F2Mno5QUtRQW9nQUZiT1FBV3QyZ0FDRnZSd0JpRXRJQXVWeUVBSEJoU1FCclZ1QUFtVklCQUZCVk53QWUxYmNBTS9IRUFCTnVYd0JkTU9RQWhTNnBBQjJ5d3dDaE1qWUFDTGVrQU9xeDFBQVc5eUVBajJua0FDZi9kd0FNQTRBQWpVQXRBRS9Ob0FBZ3Baa0FzNkxUQUM5ZENnQzArVUlBRWRyTEFIMiswQUNiMjhFQXF4ZTlBTXFpZ1FBSWFsd0FMbFVYQUNjQVZRQi9GUEFBNFFlR0FCUUxaQUNXUVkwQWg3N2VBTnI5S2dCckpiWUFlNGswQUFYei9nQzV2NTRBYUdwUEFFb3FxQUJQeEZvQUxmaThBTmRhbUFEMHg1VUFEVTJOQUNBNnBnQ2tWMThBRkQreEFJQTRsUURNSUFFQWNkMkdBTW5ldGdDL1lQVUFUV1VSQUFFSGF3Q01zS3dBc3NEUUFGRlZTQUFlK3c0QWxYTERBS01HT3dEQVFEVUFCdHg3QU9CRnpBQk9LZm9BMXNySUFPanpRUUI4Wk40QW0yVFlBTm0rTVFDa2w4TUFkMWpVQUduanhRRHcyaE1BdWpvOEFFWVlSZ0JWZFY4QTByMzFBRzZTeGdDc0xsMEFEa1R0QUJ3K1FnQmh4SWNBS2YzcEFPZlc4d0FpZk1vQWI1RTFBQWpneFFELzE0MEFibXJpQUxEOXhnQ1RDTUVBZkYxMEFHdXRzZ0ROYnAwQVBuSjdBTVlSYWdEM3o2a0FLWFBmQUxYSnVnQzNBRkVBNHJJTkFIUzZKQURsZldBQWROaUtBQTBWTEFDQkdBd0FmbWFVQUFFcEZnQ2ZlbllBL2YyK0FGWkY3d0RaZmpZQTdOa1RBSXU2dVFERWwvd0FNYWduQVBGdXd3Q1V4VFlBMktoV0FMU290UURQekE0QUVva3RBRzlYTkFBc1Zva0FtYzdqQU5ZZ3VRQnJYcW9BUGlxY0FCRmZ6QUQ5QzBvQTRmVDdBSTQ3YlFEaWhpd0E2ZFNFQVB5MHFRRHY3dEVBTGpYSkFDODVZUUE0SVVRQUc5bklBSUg4Q2dEN1Ntb0FMeHpZQUZPMGhBQk9tWXdBVkNMTUFDcFYzQURBeHRZQUN4bVdBQnB3dUFCcGxXUUFKbHBnQUQ5UzdnQi9FUThBOUxVUkFQekw5UUEwdkMwQU5MenVBT2hkekFEZFhtQUFaNDZiQUpJejd3REpGN2dBWVZpYkFPRlh2QUJSZzhZQTJENFFBTjF4U0FBdEhOMEFyeGloQUNFc1JnQlo4OWNBMlhxWUFKNVV3QUJQaHZvQVZnYjhBT1Y1cmdDSklqWUFPSzBpQUdlVDNBQlY2S29BZ2lZNEFNcm5td0JSRGFRQW1UT3hBS25YRGdCcEJVZ0FaYkx3QUgrSXB3Q0lUSmNBK2RFMkFDR1Nzd0I3Z2tvQW1NOGhBRUNmM0FEY1IxVUE0WFE2QUdmclFnRCtuZDhBWHRSZkFIdG5wQUM2ckhvQVZmYWlBQ3VJSXdCQnVsVUFXVzRJQUNFcWhnQTVSNE1BaWVQbUFPV2UxQUJKKzBBQS8xYnBBQndQeWdERldZb0FsUG9yQU5QQnhRQVB4YzhBMjFxdUFFZkZoZ0NGUTJJQUlZWTdBQ3g1bEFBUVlZY0FLa3g3QUlBc0dnQkR2eElBaUNhUUFIZzhpUUNveE9RQTVkdDdBTVE2d2dBbTlPb0E5MmVLQUEyU3Z3QmxveXNBUFpPeEFMMThDd0NrVWR3QUo5MWpBR25oM1FDYWxCa0FxQ21WQUdqT0tBQUo3YlFBUko4Z0FFNll5Z0J3Z21NQWZud2pBQSs1TWdDbjlZNEFGRmJuQUNIeENBQzFuU29BYjM1TkFLVVpVUUMxK2FzQWd0L1dBSmJkWVFBV05nSUF4RHFmQUlPaW9RQnk3VzBBT1kxNkFJSzRxUUJyTWx3QVJpZGJBQUEwN1FEU0FIY0EvUFJWQUFGWlRRRGdjWUFBUWRQekFRdFJRUHNoK1Q4QUFBQUFMVVIwUGdBQUFJQ1lSdmc4QUFBQVlGSE1lRHNBQUFDQWd4dndPUUFBQUVBZ0pYbzRBQUFBZ0NLQzR6WUFBQUFBSGZOcE5SaDhBQUF0S3lBZ0lEQllNSGdBS0c1MWJHd3BBRUd3OUFFTFFSRUFDZ0FSRVJFQUFBQUFCUUFBQUFBQUFBa0FBQUFBQ3dBQUFBQUFBQUFBRVFBUENoRVJFUU1LQndBQkFBa0xDd0FBQ1FZTEFBQUxBQVlSQUFBQUVSRVJBRUdCOVFFTElRc0FBQUFBQUFBQUFCRUFDZ29SRVJFQUNnQUFBZ0FKQ3dBQUFBa0FDd0FBQ3dCQnUvVUJDd0VNQUVISDlRRUxGUXdBQUFBQURBQUFBQUFKREFBQUFBQUFEQUFBREFCQjlmVUJDd0VPQUVHQjlnRUxGUTBBQUFBRURRQUFBQUFKRGdBQUFBQUFEZ0FBRGdCQnIvWUJDd0VRQUVHNzlnRUxIZzhBQUFBQUR3QUFBQUFKRUFBQUFBQUFFQUFBRUFBQUVnQUFBQklTRWdCQjh2WUJDdzRTQUFBQUVoSVNBQUFBQUFBQUNRQkJvL2NCQ3dFTEFFR3Y5d0VMRlFvQUFBQUFDZ0FBQUFBSkN3QUFBQUFBQ3dBQUN3QkIzZmNCQ3dFTUFFSHA5d0VMSnd3QUFBQUFEQUFBQUFBSkRBQUFBQUFBREFBQURBQUFNREV5TXpRMU5qYzRPVUZDUTBSRlJnQkJrUGdCQ3duZ2cxQUFBQUFBQUFVQVFhVDRBUXNCQWdCQnZQZ0JDdzREQUFBQUJBQUFBSmgvQUFBQUJBQkIxUGdCQ3dFQkFFSGorQUVMQlFyLy8vLy9BRUhVK2dFTEFzQ0RcIjtmdW5jdGlvbiBlKEEpe3RyeXtpZihBPT1iJiZ3KXJldHVybiBuZXcgVWludDhBcnJheSh3KTt2YXIgST1mdW5jdGlvbihBKXtpZihmKEEpKXJldHVybiBmdW5jdGlvbihBKXt0cnl7Zm9yKHZhciBJPXAoQSksZz1uZXcgVWludDhBcnJheShJLmxlbmd0aCksQj0wO0I8SS5sZW5ndGg7KytCKWdbQl09SS5jaGFyQ29kZUF0KEIpO3JldHVybiBnfWNhdGNoKEEpe3Rocm93IG5ldyBFcnJvcihcIkNvbnZlcnRpbmcgYmFzZTY0IHN0cmluZyB0byBieXRlcyBmYWlsZWQuXCIpfX0oQS5zbGljZShyLmxlbmd0aCkpfShBKTtpZihJKXJldHVybiBJO3Rocm93XCJib3RoIGFzeW5jIGFuZCBzeW5jIGZldGNoaW5nIG9mIHRoZSB3YXNtIGZhaWxlZFwifWNhdGNoKEEpe24oQSl9fWZ1bmN0aW9uIHgoSSl7Zm9yKDtJLmxlbmd0aD4wOyl7dmFyIGc9SS5zaGlmdCgpO2lmKFwiZnVuY3Rpb25cIiE9dHlwZW9mIGcpe3ZhciBCPWcuZnVuYztcIm51bWJlclwiPT10eXBlb2YgQj92b2lkIDA9PT1nLmFyZz9xLmdldChCKSgpOnEuZ2V0KEIpKGcuYXJnKTpCKHZvaWQgMD09PWcuYXJnP251bGw6Zy5hcmcpfWVsc2UgZyhBKX19ZihiKXx8KFc9YixiPUEubG9jYXRlRmlsZT9BLmxvY2F0ZUZpbGUoVyxvKTpvK1cpO3ZhciB2PXttYXBwaW5nczp7fSxidWZmZXJzOltudWxsLFtdLFtdXSxwcmludENoYXI6ZnVuY3Rpb24oQSxJKXt2YXIgZz12LmJ1ZmZlcnNbQV07MD09PUl8fDEwPT09ST8oKDE9PT1BP0c6UikoeShnLDApKSxnLmxlbmd0aD0wKTpnLnB1c2goSSl9LHZhcmFyZ3M6dm9pZCAwLGdldDpmdW5jdGlvbigpe3JldHVybiB2LnZhcmFyZ3MrPTQsaFt2LnZhcmFyZ3MtND4+Ml19LGdldFN0cjpmdW5jdGlvbihBKXtyZXR1cm4gSChBKX0sZ2V0NjQ6ZnVuY3Rpb24oQSxJKXtyZXR1cm4gQX19LHA9XCJmdW5jdGlvblwiPT10eXBlb2YgYXRvYj9hdG9iOmZ1bmN0aW9uKEEpe3ZhciBJLGcsQixRLEMsRSxpPVwiQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLz1cIixEPVwiXCIsbz0wO0E9QS5yZXBsYWNlKC9bXkEtWmEtejAtOVxcXFwrXFxcXC9cXFxcPV0vZyxcIlwiKTtkb3tJPWkuaW5kZXhPZihBLmNoYXJBdChvKyspKTw8MnwoUT1pLmluZGV4T2YoQS5jaGFyQXQobysrKSkpPj40LGc9KDE1JlEpPDw0fChDPWkuaW5kZXhPZihBLmNoYXJBdChvKyspKSk+PjIsQj0oMyZDKTw8NnwoRT1pLmluZGV4T2YoQS5jaGFyQXQobysrKSkpLEQrPVN0cmluZy5mcm9tQ2hhckNvZGUoSSksNjQhPT1DJiYoRCs9U3RyaW5nLmZyb21DaGFyQ29kZShnKSksNjQhPT1FJiYoRCs9U3RyaW5nLmZyb21DaGFyQ29kZShCKSl9d2hpbGUobzxBLmxlbmd0aCk7cmV0dXJuIER9O3ZhciBULE89e2I6ZnVuY3Rpb24oQSxJLGcpe2suY29weVdpdGhpbihBLEksSStnKX0sYzpmdW5jdGlvbihBKXtuKFwiT09NXCIpfSxhOmZ1bmN0aW9uKEEsSSxnLEIpe2Zvcih2YXIgUT0wLEM9MDtDPGc7QysrKXtmb3IodmFyIEU9aFtJKzgqQz4+Ml0saT1oW0krKDgqQys0KT4+Ml0sRD0wO0Q8aTtEKyspdi5wcmludENoYXIoQSxrW0UrRF0pO1ErPWl9cmV0dXJuIGhbQj4+Ml09USwwfX0sbD0oZnVuY3Rpb24oKXt2YXIgST17YTpPfTtmdW5jdGlvbiBnKEksZyl7dmFyIEIsUT1JLmV4cG9ydHM7QS5hc209USxCPUEuYXNtLmQuYnVmZmVyLEEuSEVBUDg9cz1uZXcgSW50OEFycmF5KEIpLEEuSEVBUDE2PW5ldyBJbnQxNkFycmF5KEIpLEEuSEVBUDMyPWg9bmV3IEludDMyQXJyYXkoQiksQS5IRUFQVTg9az1uZXcgVWludDhBcnJheShCKSxBLkhFQVBVMTY9bmV3IFVpbnQxNkFycmF5KEIpLEEuSEVBUFUzMj1uZXcgVWludDMyQXJyYXkoQiksQS5IRUFQRjMyPW5ldyBGbG9hdDMyQXJyYXkoQiksQS5IRUFQRjY0PW5ldyBGbG9hdDY0QXJyYXkoQikscT1BLmFzbS5lLGZ1bmN0aW9uKEkpe2lmKGQtLSxBLm1vbml0b3JSdW5EZXBlbmRlbmNpZXMmJkEubW9uaXRvclJ1bkRlcGVuZGVuY2llcyhkKSwwPT1kJiYobnVsbCE9PVAmJihjbGVhckludGVydmFsKFApLFA9bnVsbCksdCkpe3ZhciBnPXQ7dD1udWxsLGcoKX19KCl9ZnVuY3Rpb24gUShBKXtnKEEuaW5zdGFuY2UpfWZ1bmN0aW9uIEMoQSl7cmV0dXJuKHd8fFwiZnVuY3Rpb25cIiE9dHlwZW9mIGZldGNoP1Byb21pc2UucmVzb2x2ZSgpLnRoZW4oKGZ1bmN0aW9uKCl7cmV0dXJuIGUoYil9KSk6ZmV0Y2goYix7Y3JlZGVudGlhbHM6XCJzYW1lLW9yaWdpblwifSkudGhlbigoZnVuY3Rpb24oQSl7aWYoIUEub2spdGhyb3dcImZhaWxlZCB0byBsb2FkIHdhc20gYmluYXJ5IGZpbGUgYXQgXFwnXCIrYitcIlxcJ1wiO3JldHVybiBBLmFycmF5QnVmZmVyKCl9KSkuY2F0Y2goKGZ1bmN0aW9uKCl7cmV0dXJuIGUoYil9KSkpLnRoZW4oKGZ1bmN0aW9uKEEpe3JldHVybiBXZWJBc3NlbWJseS5pbnN0YW50aWF0ZShBLEkpfSkpLnRoZW4oQSwoZnVuY3Rpb24oQSl7UihcImZhaWxlZCB0byBhc3luY2hyb25vdXNseSBwcmVwYXJlIHdhc206IFwiK0EpLG4oQSl9KSl9aWYoZCsrLEEubW9uaXRvclJ1bkRlcGVuZGVuY2llcyYmQS5tb25pdG9yUnVuRGVwZW5kZW5jaWVzKGQpLEEuaW5zdGFudGlhdGVXYXNtKXRyeXtyZXR1cm4gQS5pbnN0YW50aWF0ZVdhc20oSSxnKX1jYXRjaChBKXtyZXR1cm4gUihcIk1vZHVsZS5pbnN0YW50aWF0ZVdhc20gY2FsbGJhY2sgZmFpbGVkIHdpdGggZXJyb3I6IFwiK0EpLCExfSh3fHxcImZ1bmN0aW9uXCIhPXR5cGVvZiBXZWJBc3NlbWJseS5pbnN0YW50aWF0ZVN0cmVhbWluZ3x8ZihiKXx8XCJmdW5jdGlvblwiIT10eXBlb2YgZmV0Y2g/QyhRKTpmZXRjaChiLHtjcmVkZW50aWFsczpcInNhbWUtb3JpZ2luXCJ9KS50aGVuKChmdW5jdGlvbihBKXtyZXR1cm4gV2ViQXNzZW1ibHkuaW5zdGFudGlhdGVTdHJlYW1pbmcoQSxJKS50aGVuKFEsKGZ1bmN0aW9uKEEpe3JldHVybiBSKFwid2FzbSBzdHJlYW1pbmcgY29tcGlsZSBmYWlsZWQ6IFwiK0EpLFIoXCJmYWxsaW5nIGJhY2sgdG8gQXJyYXlCdWZmZXIgaW5zdGFudGlhdGlvblwiKSxDKFEpfSkpfSkpKS5jYXRjaChCKX0oKSxBLl9fX3dhc21fY2FsbF9jdG9ycz1mdW5jdGlvbigpe3JldHVybihsPUEuX19fd2FzbV9jYWxsX2N0b3JzPUEuYXNtLmYpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0pLFg9KEEuX3N0b3BTdHJlYW09ZnVuY3Rpb24oKXtyZXR1cm4oQS5fc3RvcFN0cmVhbT1BLmFzbS5nKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LEEuX3N0YXJ0U3RyZWFtPWZ1bmN0aW9uKCl7cmV0dXJuKEEuX3N0YXJ0U3RyZWFtPUEuYXNtLmgpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sQS5fZGVjb2RlPWZ1bmN0aW9uKCl7cmV0dXJuKEEuX2RlY29kZT1BLmFzbS5pKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LEEuX2NyZWF0ZUJ1ZmZlcj1mdW5jdGlvbigpe3JldHVybihBLl9jcmVhdGVCdWZmZXI9QS5hc20uaikuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxBLl9mcmVlQnVmZmVyPWZ1bmN0aW9uKCl7cmV0dXJuKEEuX2ZyZWVCdWZmZXI9QS5hc20uaykuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxBLl9tYWluPWZ1bmN0aW9uKCl7cmV0dXJuKEEuX21haW49QS5hc20ubCkuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxBLnN0YWNrU2F2ZT1mdW5jdGlvbigpe3JldHVybihYPUEuc3RhY2tTYXZlPUEuYXNtLm0pLmFwcGx5KG51bGwsYXJndW1lbnRzKX0pLFo9QS5zdGFja1Jlc3RvcmU9ZnVuY3Rpb24oKXtyZXR1cm4oWj1BLnN0YWNrUmVzdG9yZT1BLmFzbS5uKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LFY9QS5zdGFja0FsbG9jPWZ1bmN0aW9uKCl7cmV0dXJuKFY9QS5zdGFja0FsbG9jPUEuYXNtLm8pLmFwcGx5KG51bGwsYXJndW1lbnRzKX07ZnVuY3Rpb24geihBKXt0aGlzLm5hbWU9XCJFeGl0U3RhdHVzXCIsdGhpcy5tZXNzYWdlPVwiUHJvZ3JhbSB0ZXJtaW5hdGVkIHdpdGggZXhpdChcIitBK1wiKVwiLHRoaXMuc3RhdHVzPUF9ZnVuY3Rpb24gaihJKXtmdW5jdGlvbiBCKCl7VHx8KFQ9ITAsQS5jYWxsZWRSdW49ITAsU3x8KHgoSykseChjKSxnKEEpLEEub25SdW50aW1lSW5pdGlhbGl6ZWQmJkEub25SdW50aW1lSW5pdGlhbGl6ZWQoKSx1JiZmdW5jdGlvbihJKXt2YXIgZyxCPUEuX21haW4sUT0oST1JfHxbXSkubGVuZ3RoKzEsQz1WKDQqKFErMSkpO2hbQz4+Ml09TChpKTtmb3IodmFyIEU9MTtFPFE7RSsrKWhbKEM+PjIpK0VdPUwoSVtFLTFdKTtoWyhDPj4yKStRXT0wO3RyeXtnPUIoUSxDKSxGJiYwPT09Z3x8KEZ8fChBLm9uRXhpdCYmQS5vbkV4aXQoZyksUz0hMCksRChnLG5ldyB6KGcpKSl9Y2F0Y2goQSl7aWYoQSBpbnN0YW5jZW9mIHopcmV0dXJuO2lmKFwidW53aW5kXCI9PUEpcmV0dXJuIHZvaWQoRj0hMCk7dmFyIG89QTtBJiZcIm9iamVjdFwiPT10eXBlb2YgQSYmQS5zdGFjayYmKG89W0EsQS5zdGFja10pLFIoXCJleGNlcHRpb24gdGhyb3duOiBcIitvKSxEKDEsQSl9fShJKSxmdW5jdGlvbigpe2lmKEEucG9zdFJ1bilmb3IoXCJmdW5jdGlvblwiPT10eXBlb2YgQS5wb3N0UnVuJiYoQS5wb3N0UnVuPVtBLnBvc3RSdW5dKTtBLnBvc3RSdW4ubGVuZ3RoOylJPUEucG9zdFJ1bi5zaGlmdCgpLFkudW5zaGlmdChJKTt2YXIgSTt4KFkpfSgpKSl9ST1JfHxFLGQ+MHx8KGZ1bmN0aW9uKCl7aWYoQS5wcmVSdW4pZm9yKFwiZnVuY3Rpb25cIj09dHlwZW9mIEEucHJlUnVuJiYoQS5wcmVSdW49W0EucHJlUnVuXSk7QS5wcmVSdW4ubGVuZ3RoOylJPUEucHJlUnVuLnNoaWZ0KCksTS51bnNoaWZ0KEkpO3ZhciBJO3goTSl9KCksZD4wfHwoQS5zZXRTdGF0dXM/KEEuc2V0U3RhdHVzKFwiUnVubmluZy4uLlwiKSxzZXRUaW1lb3V0KChmdW5jdGlvbigpe3NldFRpbWVvdXQoKGZ1bmN0aW9uKCl7QS5zZXRTdGF0dXMoXCJcIil9KSwxKSxCKCl9KSwxKSk6QigpKSl9aWYoQS5jd3JhcD1mdW5jdGlvbihBLEksZyxCKXt2YXIgUT0oZz1nfHxbXSkuZXZlcnkoKGZ1bmN0aW9uKEEpe3JldHVyblwibnVtYmVyXCI9PT1BfSkpO3JldHVyblwic3RyaW5nXCIhPT1JJiZRJiYhQj9VKEEpOmZ1bmN0aW9uKCl7cmV0dXJuIGEoQSxJLGcsYXJndW1lbnRzKX19LHQ9ZnVuY3Rpb24gQSgpe1R8fGooKSxUfHwodD1BKX0sQS5ydW49aixBLnByZUluaXQpZm9yKFwiZnVuY3Rpb25cIj09dHlwZW9mIEEucHJlSW5pdCYmKEEucHJlSW5pdD1bQS5wcmVJbml0XSk7QS5wcmVJbml0Lmxlbmd0aD4wOylBLnByZUluaXQucG9wKCkoKTt2YXIgdT0hMDtyZXR1cm4gQS5ub0luaXRpYWxSdW4mJih1PSExKSxGPSEwLGooKSxBLnJlYWR5fSk7QS5leHBvcnRzPWd9fSxJPXt9O2Z1bmN0aW9uIGcoQil7dmFyIFE9SVtCXTtpZih2b2lkIDAhPT1RKXJldHVybiBRLmV4cG9ydHM7dmFyIEM9SVtCXT17ZXhwb3J0czp7fX07cmV0dXJuIEFbQl0oQyxDLmV4cG9ydHMsZyksQy5leHBvcnRzfWcubj1BPT57dmFyIEk9QSYmQS5fX2VzTW9kdWxlPygpPT5BLmRlZmF1bHQ6KCk9PkE7cmV0dXJuIGcuZChJLHthOkl9KSxJfSxnLmQ9KEEsSSk9Pntmb3IodmFyIEIgaW4gSSlnLm8oSSxCKSYmIWcubyhBLEIpJiZPYmplY3QuZGVmaW5lUHJvcGVydHkoQSxCLHtlbnVtZXJhYmxlOiEwLGdldDpJW0JdfSl9LGcubz0oQSxJKT0+T2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKEEsSSksKCgpPT57XCJ1c2Ugc3RyaWN0XCI7dmFyIEEsST1nKDMwNSksQj1nLm4oSSksUT0wLEM9MCxFPTAsaT0wLEQ9MCxvPTA7IWFzeW5jIGZ1bmN0aW9uKCl7QT1hd2FpdCBCKCkoKSxzZWxmLmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsKGFzeW5jIGZ1bmN0aW9uKEkpe3ZhciBnPUkuZGF0YTtzd2l0Y2goZy50eXBlKXtjYXNlXCJzdGFydFN0cmVhbVwiOm89Zy5kZWNvZGVkU2FtcGxlc1BlckZyYW1lLEQ9bypnLmNoYW5uZWxDb3VudCxBLl9zdGFydFN0cmVhbShnLnNhbXBsZVJhdGVIeixnLmNoYW5uZWxDb3VudCk7YnJlYWs7Y2FzZVwic3RvcFN0cmVhbVwiOkEuX3N0b3BTdHJlYW0oKTticmVhaztjYXNlXCJkZWNvZGVcIjp7Y29uc3QgST1nLnN0YXJ0VGltZXN0YW1wLEI9ZnVuY3Rpb24oSSl7Y29uc3QgZz1JLmJ5dGVMZW5ndGg7cmV0dXJuIDAhPVEmJkM8ZyYmKEEuX2ZyZWVCdWZmZXIoUSksUT0wLEM9MCksMD09USYmKFE9QS5fY3JlYXRlQnVmZmVyKEkuQllURVNfUEVSX0VMRU1FTlQqZyksQz1nKSxBLkhFQVBVOC5zZXQoSSxRKSxRfShuZXcgVWludDhBcnJheShnLmlucHV0RGF0YSkpLHc9KDAhPUUmJmk8RCYmKEEuX2ZyZWVCdWZmZXIoRSksRT0wLGk9MCksMD09RSYmKEU9QS5fY3JlYXRlQnVmZmVyKEZsb2F0MzJBcnJheS5CWVRFU19QRVJfRUxFTUVOVCpEKSxpPUQpLEUpLEY9bmV3IEZsb2F0MzJBcnJheShBLkhFQVBGMzIuYnVmZmVyLHcsRCksRz1BLl9kZWNvZGUoQixnLmlucHV0RGF0YS5ieXRlTGVuZ3RoLHcsbyksUj1GLmJ1ZmZlci5zbGljZSh3LHcrRCpGLkJZVEVTX1BFUl9FTEVNRU5UKTtwb3N0TWVzc2FnZSh7dHlwZTpcImRlY29kZURvbmVcIixzdGFydFRpbWVzdGFtcDpJLG91dHB1dERhdGE6UixzYW1wbGVzRGVjb2RlZDpHfSxbUl0pO2JyZWFrfWNhc2VcInJlbGVhc2VcIjowIT1RJiYoQS5fZnJlZUJ1ZmZlcihRKSxRPTAsQz0wKSwwIT1FJiYoQS5fZnJlZUJ1ZmZlcihFKSxFPTAsaT0wKSxBLl9zdG9wU3RyZWFtKCl9fSkpLHBvc3RNZXNzYWdlKHt0eXBlOlwiZGVjb2RlclJlYWR5XCJ9KX0oKX0pKCl9KSgpOycsXCJXb3JrZXJcIix2b2lkIDAsdm9pZCAwKX19LDYxNDpBPT57QS5leHBvcnRzPWZ1bmN0aW9uKEEsSSxnLEIpe3ZhciBRPXNlbGZ8fHdpbmRvdzt0cnl7dHJ5e3ZhciBDO3RyeXtDPW5ldyBRLkJsb2IoW0FdKX1jYXRjaChJKXsoQz1uZXcoUS5CbG9iQnVpbGRlcnx8US5XZWJLaXRCbG9iQnVpbGRlcnx8US5Nb3pCbG9iQnVpbGRlcnx8US5NU0Jsb2JCdWlsZGVyKSkuYXBwZW5kKEEpLEM9Qy5nZXRCbG9iKCl9dmFyIGU9US5VUkx8fFEud2Via2l0VVJMLGk9ZS5jcmVhdGVPYmplY3RVUkwoQyksdD1uZXcgUVtJXShpLGcpO3JldHVybiBlLnJldm9rZU9iamVjdFVSTChpKSx0fWNhdGNoKEIpe3JldHVybiBuZXcgUVtJXShcImRhdGE6YXBwbGljYXRpb24vamF2YXNjcmlwdCxcIi5jb25jYXQoZW5jb2RlVVJJQ29tcG9uZW50KEEpKSxnKX19Y2F0Y2goQSl7aWYoIUIpdGhyb3cgRXJyb3IoXCJJbmxpbmUgd29ya2VyIGlzIG5vdCBzdXBwb3J0ZWRcIik7cmV0dXJuIG5ldyBRW0ldKEIsZyl9fX19LEk9e307ZnVuY3Rpb24gZyhCKXt2YXIgUT1JW0JdO2lmKHZvaWQgMCE9PVEpcmV0dXJuIFEuZXhwb3J0czt2YXIgQz1JW0JdPXtleHBvcnRzOnt9fTtyZXR1cm4gQVtCXS5jYWxsKEMuZXhwb3J0cyxDLEMuZXhwb3J0cyxnKSxDLmV4cG9ydHN9cmV0dXJuIGcubj1BPT57dmFyIEk9QSYmQS5fX2VzTW9kdWxlPygpPT5BLmRlZmF1bHQ6KCk9PkE7cmV0dXJuIGcuZChJLHthOkl9KSxJfSxnLmQ9KEEsSSk9Pntmb3IodmFyIEIgaW4gSSlnLm8oSSxCKSYmIWcubyhBLEIpJiZPYmplY3QuZGVmaW5lUHJvcGVydHkoQSxCLHtlbnVtZXJhYmxlOiEwLGdldDpJW0JdfSl9LGcubz0oQSxJKT0+T2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKEEsSSksZy5yPUE9PntcInVuZGVmaW5lZFwiIT10eXBlb2YgU3ltYm9sJiZTeW1ib2wudG9TdHJpbmdUYWcmJk9iamVjdC5kZWZpbmVQcm9wZXJ0eShBLFN5bWJvbC50b1N0cmluZ1RhZyx7dmFsdWU6XCJNb2R1bGVcIn0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pfSxnKDExNCl9KSgpKTtjbGFzcyBnZ3tjb25zdHJ1Y3Rvcigpe3RoaXMuc2FtcGxlUmF0ZUh6PTQ4ZTMsdGhpcy5zYW1wbGVSYXRlS2h6PTQ4LHRoaXMuY2hhbm5lbENvdW50PTIsdGhpcy5kZWNvZGVkQ291bnQ9MCx0aGlzLnRvdGFsU2FtcGxlc0RlY29kZWQ9MCx0aGlzLndhaXRpbmdUb0RlY29kZVF1ZXVlPVtdLHRoaXMuZGVjb2RlUXVldWVTaXplPTAsdGhpcy5sb2dQZXJmb3JtYW5jZT0hMSx0aGlzLm1heERlY29kaW5nVGltZU1zPTAsdGhpcy50b3RhbERlY29kaW5nVGltZU1zPTAsdGhpcy50b3RhbFF1ZXVlZFNpemU9MCx0aGlzLm1heFF1ZXVlZFNpemU9MCx0aGlzLnN0YXJ0U3RyZWFtVGltZU1zPTAsdGhpcy5vdXRwdXRCdWZmZXJzPVtdLHRoaXMuY3VycmVudE91dHB1dEJ1ZmZlcj12b2lkIDAsdGhpcy5jdXJyZW50QnVmZmVyUmVhZEluZGV4PTAsdGhpcy5uZXh0U3RhcnRUaW1lPXZvaWQgMCx0aGlzLnBsYXlpbmc9ITEsdGhpcy5kYXRhRHVyYXRpb25Ncz0xMCx0aGlzLm1pbkxhdGVuY3lNcz02MCx0aGlzLm1heExhdGVuY3lNcz0xMDAsdGhpcy5wcmV2RHJvcHBlZEZyYW1lVGltZU1zPXZvaWQgMCx0aGlzLmRlY29kZWRTYW1wbGVzUGVyRnJhbWU9MCx0aGlzLmF1ZGlvQnVmZmVyU2l6ZT0wLHRoaXMuYXVkaW9CdWZmZXJQb29sPVtdLHRoaXMubWF4QXVkaW9CdWZmZXJQb29sQ291bnQ9NSx0aGlzLnJlc2FtcGxlZEF1ZGlvQnVmZmVyU2l6ZT0wLHRoaXMub25EZWNvZGU9KHtzdGFydFRpbWVzdGFtcDpBLG91dHB1dERhdGE6SSxzYW1wbGVzRGVjb2RlZDpnfSk9PnstLXRoaXMuZGVjb2RlUXVldWVTaXplO2NvbnN0IEI9bmV3IEZsb2F0MzJBcnJheShJKTt0aGlzLm91dHB1dEJ1ZmZlcnMucHVzaChCKTt0cnl7aWYoZz4wJiYoKyt0aGlzLmRlY29kZWRDb3VudCx0aGlzLnRvdGFsU2FtcGxlc0RlY29kZWQrPWcsdGhpcy5sb2dQZXJmb3JtYW5jZSYmdGhpcy5sb2dQZXJmVGltaW5nKEEpLHRoaXMudG90YWxTYW1wbGVzRGVjb2RlZD49dGhpcy5hdWRpb0J1ZmZlclNpemUmJih0aGlzLm5leHRTdGFydFRpbWUmJnRoaXMubmV4dFN0YXJ0VGltZTx0aGlzLmF1ZGlvQ29udGV4dC5jdXJyZW50VGltZSYmKHRoaXMubmV4dFN0YXJ0VGltZT12b2lkIDApLHRoaXMubmV4dFN0YXJ0VGltZXx8dGhpcy50b3RhbFNhbXBsZXNEZWNvZGVkPj0yKnRoaXMuYXVkaW9CdWZmZXJTaXplKSkpe2NvbnN0IEE9TWF0aC5mbG9vcih0aGlzLnRvdGFsU2FtcGxlc0RlY29kZWQvdGhpcy5hdWRpb0J1ZmZlclNpemUpO2ZvcihsZXQgST0wO0k8QTsrK0kpe2NvbnN0IEE9dGhpcy5uZXh0U3RhcnRUaW1lPzFlMyoodGhpcy5uZXh0U3RhcnRUaW1lLXRoaXMuYXVkaW9Db250ZXh0LmN1cnJlbnRUaW1lKTowO2lmKEE+dGhpcy5tYXhMYXRlbmN5TXMpe2xldCBJPTA7Y29uc3QgZz1EYXRlLm5vdygpLEI9dGhpcy5wcmV2RHJvcHBlZEZyYW1lVGltZU1zP2ctdGhpcy5wcmV2RHJvcHBlZEZyYW1lVGltZU1zOnZvaWQgMCxRPTFlNDtpZihCJiZCPFEpST10aGlzLmRyb3BEZWNvZGVkU2FtcGxlcyh0aGlzLnRvdGFsU2FtcGxlc0RlY29kZWQpO2Vsc2V7Y29uc3QgZz1BLXRoaXMubWF4TGF0ZW5jeU1zK3RoaXMuZGF0YUR1cmF0aW9uTXMsQj1NYXRoLmZsb29yKHRoaXMuc2FtcGxlUmF0ZUtoeipnKTtJPXRoaXMuZHJvcERlY29kZWRTYW1wbGVzKEIpfXRoaXMucHJldkRyb3BwZWRGcmFtZVRpbWVNcz1nLHRoaXMudG90YWxTYW1wbGVzRGVjb2RlZC09SX1pZighKHRoaXMudG90YWxTYW1wbGVzRGVjb2RlZD49dGhpcy5hdWRpb0J1ZmZlclNpemUpKWJyZWFrO3tjb25zdCBBPXRoaXMuY29weURlY29kZWRTYW1wbGVzVG9BdWRpb0J1ZmZlcigpO3RoaXMuc2NoZWR1bGVCdWZmZXJGb3JQbGF5YmFja0Z1bmMoQSksdGhpcy50b3RhbFNhbXBsZXNEZWNvZGVkLT1BLmxlbmd0aH19fX1jYXRjaChBKXtnSShnZy5uYW1lLFwiQ2F1Z2h0IGV4Y2VwdGlvbiBpbiBBdWRpb1N0cmVhbSBvbkRlY29kZTogXCIrQStcIiBcIitBLnN0YWNrKSx0aGlzLnN0b3AoKSx0aGlzLnBsYXkoKX10aGlzLnNlbmREZWNvZGVyV2FpdGluZ1RvRGVjb2RlRnJhbWVzKCl9fWFzeW5jIGluaXRpYWxpemUoKXt0aGlzLm9wdXNEZWNvZGVyV29ya2VyPW5ldyBJZyxhd2FpdCB0aGlzLm9wdXNEZWNvZGVyV29ya2VyLmluaXRpYWxpemUoKSx0aGlzLm9wdXNEZWNvZGVyV29ya2VyLm9uRGVjb2RlPXRoaXMub25EZWNvZGUuYmluZCh0aGlzKX1kaXNwb3NlKCl7dGhpcy5vcHVzRGVjb2Rlcldvcmtlcj8uZGlzcG9zZSgpLHRoaXMub3B1c0RlY29kZXJXb3JrZXI9dm9pZCAwfWNvbmZpZ3VyZSh7YXVkaW9Db250ZXh0OkEsc2FtcGxlUmF0ZUh6OkksY2hhbm5lbENvdW50OmcsZGF0YUR1cmF0aW9uTXM6QixtaW5MYXRlbmN5TXM6QyxtYXhMYXRlbmN5TXM6ZX0pe2lmKHRoaXMuc2FtcGxlUmF0ZUh6PUk/P3RoaXMuc2FtcGxlUmF0ZUh6LDhlMyE9dGhpcy5zYW1wbGVSYXRlSHomJjEyZTMhPXRoaXMuc2FtcGxlUmF0ZUh6JiYxNmUzIT10aGlzLnNhbXBsZVJhdGVIeiYmMjRlMyE9dGhpcy5zYW1wbGVSYXRlSHomJjQ4ZTMhPXRoaXMuc2FtcGxlUmF0ZUh6KXRocm93IG5ldyBRKGBpbnZhbGlkIGF1ZGlvIHNhbXBsZSByYXRlOiAke3RoaXMuc2FtcGxlUmF0ZUh6fSAobXVzdCBiZSA4MDAwLCAxMjAwMCwgMTYwMDAsIDI0MDAwLCBvciA0ODAwMClgKTtpZih0aGlzLnNhbXBsZVJhdGVLaHo9dGhpcy5zYW1wbGVSYXRlSHovMWUzLHRoaXMuY2hhbm5lbENvdW50PWc/P3RoaXMuY2hhbm5lbENvdW50LDEhPXRoaXMuY2hhbm5lbENvdW50JiYyIT10aGlzLmNoYW5uZWxDb3VudCYmNiE9dGhpcy5jaGFubmVsQ291bnQpdGhyb3cgbmV3IFEoYGludmFsaWQgY2hhbm5lbCBjb3VudDogJHt0aGlzLmNoYW5uZWxDb3VudH0gKG11c3QgYmUgMSwgMiwgb3IgNilgKTtpZih0aGlzLmRhdGFEdXJhdGlvbk1zPUI/P3RoaXMuZGF0YUR1cmF0aW9uTXMsdGhpcy5taW5MYXRlbmN5TXM9Qz8/dGhpcy5taW5MYXRlbmN5TXMsdGhpcy5tYXhMYXRlbmN5TXM9ZT8/dGhpcy5tYXhMYXRlbmN5TXMsdGhpcy5kYXRhRHVyYXRpb25Nczw9MCl0aHJvdyBuZXcgUShgZGF0YUR1cmF0aW9uTXMgbXVzdCBiZSBwb3NpdGl2ZSwgYnV0IGlzICR7dGhpcy5kYXRhRHVyYXRpb25Nc31gKTtpZih0aGlzLmRhdGFEdXJhdGlvbk1zPnRoaXMubWluTGF0ZW5jeU1zKXRocm93IG5ldyBRKFwiZGF0YUR1cmF0aW9uTXMgbWF5IG5vdCBleGNlZWQgbWluTGF0ZW5jeU1zXCIpO2lmKHRoaXMubWF4TGF0ZW5jeU1zPD10aGlzLm1pbkxhdGVuY3lNcyl0aHJvdyBuZXcgUShcIm1heExhdGVuY3lNcyBtdXN0IGJlIGdyZWF0ZXIgdGhhbiBtaW5MYXRlbmN5TXNcIik7dGhpcy5kZWNvZGVkU2FtcGxlc1BlckZyYW1lPXRoaXMuZGF0YUR1cmF0aW9uTXMqdGhpcy5zYW1wbGVSYXRlS2h6LHRoaXMuY3VycmVudE91dHB1dEJ1ZmZlcj12b2lkIDAsdGhpcy5jdXJyZW50QnVmZmVyUmVhZEluZGV4PTA7Y29uc3QgaT10aGlzLnNhbXBsZVJhdGVLaHoqdGhpcy5taW5MYXRlbmN5TXM7dGhpcy5hdWRpb0J1ZmZlclNpemU9TWF0aC5mbG9vcihpLzIpLG51bGw9PUE/KHRoaXMuYXVkaW9Db250ZXh0PW5ldyh3aW5kb3cuQXVkaW9Db250ZXh0fHx3aW5kb3cud2Via2l0QXVkaW9Db250ZXh0KSh7bGF0ZW5jeUhpbnQ6XCJpbnRlcmFjdGl2ZVwiLHNhbXBsZVJhdGU6dGhpcy5zYW1wbGVSYXRlSHp9KSx0aGlzLmF1ZGlvQ29udGV4dC5jcmVhdGVCdWZmZXJTb3VyY2UoKSk6dGhpcy5hdWRpb0NvbnRleHQ9QSx0aGlzLnZvbHVtZU5vZGU9dGhpcy5hdWRpb0NvbnRleHQuY3JlYXRlR2FpbigpLHRoaXMudm9sdW1lTm9kZS5jb25uZWN0KHRoaXMuYXVkaW9Db250ZXh0LmRlc3RpbmF0aW9uKSx0aGlzLmF1ZGlvQ29udGV4dC5yZXN1bWUoKSxcInN1c3BlbmRlZFwiPT10aGlzLmF1ZGlvQ29udGV4dC5zdGF0ZSYmQkkoZ2cubmFtZSxcIkF1ZGlvQ29udGV4dCBpcyBzdXNwZW5kZWQuIE5vdGUsIG9uIFNhZmFyaSwgbXVzdCBiZSBjcmVhdGVkIGRpcmVjdGx5IGZyb20gdXNlciBpbnRlcmFjdGlvbiAoaS5lLiBubyAnYXdhaXQnKSkuXCIpLHRoaXMuYXVkaW9Db250ZXh0LnNhbXBsZVJhdGUhPXRoaXMuc2FtcGxlUmF0ZUh6PyhnSShnZy5uYW1lLFwiQ29uZmlndXJlZCBzYW1wbGUgcmF0ZTogXCIrdGhpcy5zYW1wbGVSYXRlSHorXCIgZG9lcyBub3QgbWF0Y2ggQXVkaW9Db250ZXh0OiBcIit0aGlzLmF1ZGlvQ29udGV4dC5zYW1wbGVSYXRlK1wiLiBSZXNhbXBsaW5nIGlzIHJlcXVpcmVkIVwiKSx0aGlzLnJlc2FtcGxlZEF1ZGlvQnVmZmVyU2l6ZT1NYXRoLmZsb29yKHRoaXMuYXVkaW9Db250ZXh0LnNhbXBsZVJhdGUvMWUzKnRoaXMubWluTGF0ZW5jeU1zLzIpLHRoaXMuc2NoZWR1bGVCdWZmZXJGb3JQbGF5YmFja0Z1bmM9dGhpcy5yZXNhbXBsZUJ1ZmZlclRoZW5TY2hlZHVsZUZvclBsYXliYWNrLmJpbmQodGhpcykpOnRoaXMuc2NoZWR1bGVCdWZmZXJGb3JQbGF5YmFja0Z1bmM9dGhpcy5zY2hlZHVsZUJ1ZmZlckZvclBsYXliYWNrLmJpbmQodGhpcyksdGhpcy5hdWRpb0J1ZmZlclBvb2w9W107bGV0IHQ9ITE7dGhpcy5wbGF5aW5nJiYodD0hMCx0aGlzLnN0b3AoKSksdCYmdGhpcy5wbGF5KCl9cGxheSgpe2lmKCF0aGlzLm9wdXNEZWNvZGVyV29ya2VyKXRocm93IG5ldyBRKFwicGxheSgpIGhhcyBubyBvcHVzRGVjb2RlcldvcmtlclwiKTtpZighdGhpcy5zYW1wbGVSYXRlSHopdGhyb3cgbmV3IFEoXCJwbGF5KCkgaGFzIG5vIHNhbXBsZVJhdGVIelwiKTtpZighdGhpcy5jaGFubmVsQ291bnQpdGhyb3cgbmV3IFEoXCJwbGF5KCkgaGFzIG5vIGNoYW5uZWxDb3VudFwiKTtpZighdGhpcy5hdWRpb0NvbnRleHQpdGhyb3cgbmV3IFEoXCJwbGF5KCkgaGFzIG5vIGF1ZGlvQ29udGV4dFwiKTt0aGlzLnBsYXlpbmd8fCh0aGlzLm1heERlY29kaW5nVGltZU1zPTAsdGhpcy50b3RhbERlY29kaW5nVGltZU1zPTAsdGhpcy50b3RhbFF1ZXVlZFNpemU9MCx0aGlzLm1heFF1ZXVlZFNpemU9MCx0aGlzLnN0YXJ0U3RyZWFtVGltZU1zPURhdGUubm93KCksdGhpcy5vcHVzRGVjb2Rlcldvcmtlci5zdGFydFN0cmVhbSh0aGlzLnNhbXBsZVJhdGVIeix0aGlzLmNoYW5uZWxDb3VudCx0aGlzLmRlY29kZWRTYW1wbGVzUGVyRnJhbWUpLHRoaXMucGxheWluZz0hMCl9c3RvcCgpe2lmKCF0aGlzLm9wdXNEZWNvZGVyV29ya2VyKXRocm93IG5ldyBRKFwic3RvcCgpIGhhcyBubyBvcHVzRGVjb2RlcldvcmtlclwiKTt0aGlzLndhaXRpbmdUb0RlY29kZVF1ZXVlPVtdLHRoaXMub3V0cHV0QnVmZmVycz1bXSx0aGlzLm5leHRTdGFydFRpbWU9dm9pZCAwLHRoaXMudG90YWxTYW1wbGVzRGVjb2RlZD0wLHRoaXMuY3VycmVudE91dHB1dEJ1ZmZlcj12b2lkIDAsdGhpcy5jdXJyZW50QnVmZmVyUmVhZEluZGV4PTAsdGhpcy5wcmV2RHJvcHBlZEZyYW1lVGltZU1zPXZvaWQgMCx0aGlzLm9wdXNEZWNvZGVyV29ya2VyLnN0b3BTdHJlYW0oKSx0aGlzLnBsYXlpbmc9ITF9cHVzaERhdGEoQSl7dGhpcy5wbGF5aW5nJiZ0aGlzLmF1ZGlvQ29udGV4dCYmdGhpcy5vcHVzRGVjb2RlcldvcmtlciYmKDA9PXRoaXMuZGVjb2RlUXVldWVTaXplPygwIT10aGlzLndhaXRpbmdUb0RlY29kZVF1ZXVlLmxlbmd0aCYmKElJKGdnLm5hbWUsXCJlbXB0eSBkZWNvZGVyIHF1ZXVlLCBidXQgd2FpdGluZyB0byBkZWNvZGUgcXVldWUgbm90IGVtcHR5IVwiKSx0aGlzLndhaXRpbmdUb0RlY29kZVF1ZXVlPVtdKSx0aGlzLnNlbmRUb0RlY29kZXIoe3N0YXJ0VGltZXN0YW1wOkRhdGUubm93KCksaW5wdXREYXRhOkF9KSk6KHRoaXMud2FpdGluZ1RvRGVjb2RlUXVldWUucHVzaCh7c3RhcnRUaW1lc3RhbXA6RGF0ZS5ub3coKSxpbnB1dERhdGE6QX0pLHRoaXMuZGVjb2RlUXVldWVTaXplPDMmJnRoaXMuc2VuZERlY29kZXJXYWl0aW5nVG9EZWNvZGVGcmFtZXMoKSkpfXNlbmREZWNvZGVyV2FpdGluZ1RvRGVjb2RlRnJhbWVzKCl7Y29uc3QgQT0odGhpcy5kZWNvZGVRdWV1ZVNpemUrdGhpcy53YWl0aW5nVG9EZWNvZGVRdWV1ZS5sZW5ndGgpKnRoaXMuZGF0YUR1cmF0aW9uTXM7aWYoQT50aGlzLm1heExhdGVuY3lNcyl7Y29uc3QgST1BLXRoaXMubWF4TGF0ZW5jeU1zLGc9TWF0aC5mbG9vcihJL3RoaXMuZGF0YUR1cmF0aW9uTXMpLEI9TWF0aC5tYXgoTWF0aC5tYXgodGhpcy53YWl0aW5nVG9EZWNvZGVRdWV1ZS5sZW5ndGgtZywzLXRoaXMuZGVjb2RlUXVldWVTaXplKSwxKSxRPXRoaXMud2FpdGluZ1RvRGVjb2RlUXVldWUubGVuZ3RoLUI7dGhpcy53YWl0aW5nVG9EZWNvZGVRdWV1ZT10aGlzLndhaXRpbmdUb0RlY29kZVF1ZXVlLnNsaWNlKFEpfWZvcig7dGhpcy5kZWNvZGVRdWV1ZVNpemU8MyYmdGhpcy53YWl0aW5nVG9EZWNvZGVRdWV1ZS5sZW5ndGg+MDspe2NvbnN0IEE9dGhpcy53YWl0aW5nVG9EZWNvZGVRdWV1ZS5zaGlmdCgpO3RoaXMuc2VuZFRvRGVjb2RlcihBKX19c2VuZFRvRGVjb2RlcihBKXsrK3RoaXMuZGVjb2RlUXVldWVTaXplLHRoaXMub3B1c0RlY29kZXJXb3JrZXIuZGVjb2RlKEEuc3RhcnRUaW1lc3RhbXAsQS5pbnB1dERhdGEpfWRyb3BEZWNvZGVkU2FtcGxlcyhBKXtsZXQgST0wO2Zvcih0aGlzLmN1cnJlbnRPdXRwdXRCdWZmZXImJihJKz10aGlzLmRyb3BDdXJyZW50T3V0cHV0QnVmZmVyU2FtcGxlcyhBKSxBLT1JKTtBPjAmJnRoaXMub3V0cHV0QnVmZmVycy5sZW5ndGg+MDspaWYoQTx0aGlzLmRlY29kZWRTYW1wbGVzUGVyRnJhbWUpe3RoaXMuY3VycmVudE91dHB1dEJ1ZmZlcj10aGlzLm91dHB1dEJ1ZmZlcnMuc2hpZnQoKSx0aGlzLmN1cnJlbnRCdWZmZXJSZWFkSW5kZXg9MDtjb25zdCBnPXRoaXMuZHJvcEN1cnJlbnRPdXRwdXRCdWZmZXJTYW1wbGVzKEEpO0krPWcsQS09Z31lbHNlIHRoaXMub3V0cHV0QnVmZmVycy5zaGlmdCgpLEkrPXRoaXMuZGVjb2RlZFNhbXBsZXNQZXJGcmFtZSxBLT10aGlzLmRlY29kZWRTYW1wbGVzUGVyRnJhbWU7cmV0dXJuIEl9ZHJvcEN1cnJlbnRPdXRwdXRCdWZmZXJTYW1wbGVzKEEpe2NvbnN0IEk9TWF0aC5mbG9vcigodGhpcy5jdXJyZW50T3V0cHV0QnVmZmVyLmxlbmd0aC10aGlzLmN1cnJlbnRCdWZmZXJSZWFkSW5kZXgpL3RoaXMuY2hhbm5lbENvdW50KSxnPU1hdGgubWluKEksQSk7cmV0dXJuIHRoaXMuY3VycmVudEJ1ZmZlclJlYWRJbmRleCs9Zyp0aGlzLmNoYW5uZWxDb3VudCx0aGlzLmN1cnJlbnRCdWZmZXJSZWFkSW5kZXg+PXRoaXMuY3VycmVudE91dHB1dEJ1ZmZlci5sZW5ndGgmJih0aGlzLmN1cnJlbnRPdXRwdXRCdWZmZXI9dm9pZCAwKSxnfWNvcHlEZWNvZGVkU2FtcGxlc1RvQXVkaW9CdWZmZXIoKXtjb25zdCBBPXRoaXMuZ2V0T3JDcmVhdGVBdWRpb0J1ZmZlcigpO2ZvcihsZXQgST0wO0k8dGhpcy5hdWRpb0J1ZmZlclNpemU7KXt0aGlzLmN1cnJlbnRPdXRwdXRCdWZmZXJ8fCh0aGlzLmN1cnJlbnRPdXRwdXRCdWZmZXI9dGhpcy5vdXRwdXRCdWZmZXJzLnNoaWZ0KCksdGhpcy5jdXJyZW50QnVmZmVyUmVhZEluZGV4PTApO2NvbnN0IGc9dGhpcy5jdXJyZW50T3V0cHV0QnVmZmVyO2lmKDE9PXRoaXMuY2hhbm5lbENvdW50KXtjb25zdCBCPUEuZ2V0Q2hhbm5lbERhdGEoMCk7Zm9yKDt0aGlzLmN1cnJlbnRCdWZmZXJSZWFkSW5kZXg8Zy5sZW5ndGgmJihCW0ldPWdbdGhpcy5jdXJyZW50QnVmZmVyUmVhZEluZGV4XSx0aGlzLmN1cnJlbnRCdWZmZXJSZWFkSW5kZXgrPXRoaXMuY2hhbm5lbENvdW50LCsrSSwhKEk+PXRoaXMuYXVkaW9CdWZmZXJTaXplKSk7KTt9ZWxzZSBpZigyPT10aGlzLmNoYW5uZWxDb3VudCl7Y29uc3QgQj1BLmdldENoYW5uZWxEYXRhKDApLFE9QS5nZXRDaGFubmVsRGF0YSgxKTtmb3IoO3RoaXMuY3VycmVudEJ1ZmZlclJlYWRJbmRleDxnLmxlbmd0aCYmKEJbSV09Z1t0aGlzLmN1cnJlbnRCdWZmZXJSZWFkSW5kZXhdLFFbSV09Z1t0aGlzLmN1cnJlbnRCdWZmZXJSZWFkSW5kZXgrMV0sdGhpcy5jdXJyZW50QnVmZmVyUmVhZEluZGV4Kz10aGlzLmNoYW5uZWxDb3VudCwrK0ksIShJPj10aGlzLmF1ZGlvQnVmZmVyU2l6ZSkpOyk7fWVsc2V7Y29uc3QgQj1BLmdldENoYW5uZWxEYXRhKDApLFE9QS5nZXRDaGFubmVsRGF0YSgxKSxDPUEuZ2V0Q2hhbm5lbERhdGEoMiksZT1BLmdldENoYW5uZWxEYXRhKDMpLGk9QS5nZXRDaGFubmVsRGF0YSg0KSx0PUEuZ2V0Q2hhbm5lbERhdGEoNSk7Zm9yKDt0aGlzLmN1cnJlbnRCdWZmZXJSZWFkSW5kZXg8Zy5sZW5ndGgmJihCW0ldPWdbdGhpcy5jdXJyZW50QnVmZmVyUmVhZEluZGV4XSxRW0ldPWdbdGhpcy5jdXJyZW50QnVmZmVyUmVhZEluZGV4KzFdLGlbSV09Z1t0aGlzLmN1cnJlbnRCdWZmZXJSZWFkSW5kZXgrMl0sdFtJXT1nW3RoaXMuY3VycmVudEJ1ZmZlclJlYWRJbmRleCszXSxDW0ldPWdbdGhpcy5jdXJyZW50QnVmZmVyUmVhZEluZGV4KzRdLGVbSV09Z1t0aGlzLmN1cnJlbnRCdWZmZXJSZWFkSW5kZXgrNV0sdGhpcy5jdXJyZW50QnVmZmVyUmVhZEluZGV4Kz10aGlzLmNoYW5uZWxDb3VudCwrK0ksIShJPj10aGlzLmF1ZGlvQnVmZmVyU2l6ZSkpOyk7fXRoaXMuY3VycmVudEJ1ZmZlclJlYWRJbmRleD49dGhpcy5jdXJyZW50T3V0cHV0QnVmZmVyLmxlbmd0aCYmKHRoaXMuY3VycmVudE91dHB1dEJ1ZmZlcj12b2lkIDApfXJldHVybiBBfWdldE9yQ3JlYXRlQXVkaW9CdWZmZXIoKXtyZXR1cm4gMD09dGhpcy5hdWRpb0J1ZmZlclBvb2wubGVuZ3RoP3RoaXMuYXVkaW9Db250ZXh0LmNyZWF0ZUJ1ZmZlcih0aGlzLmNoYW5uZWxDb3VudCx0aGlzLmF1ZGlvQnVmZmVyU2l6ZSx0aGlzLnNhbXBsZVJhdGVIeik6dGhpcy5hdWRpb0J1ZmZlclBvb2wucG9wKCl9cmV0dXJuQXVkaW9CdWZmZXJUb1Bvb2woQSxJKXt0aGlzLmF1ZGlvQnVmZmVyUG9vbC5sZW5ndGg8dGhpcy5tYXhBdWRpb0J1ZmZlclBvb2xDb3VudCYmdGhpcy5hdWRpb0J1ZmZlclBvb2wucHVzaChBKX1sb2dQZXJmVGltaW5nKEEpe2NvbnN0IEk9RGF0ZS5ub3coKSxnPUktQTt0aGlzLnRvdGFsRGVjb2RpbmdUaW1lTXMrPWcsZz50aGlzLm1heERlY29kaW5nVGltZU1zJiYodGhpcy5tYXhEZWNvZGluZ1RpbWVNcz1nKTtjb25zdCBCPXRoaXMud2FpdGluZ1RvRGVjb2RlUXVldWUubGVuZ3RoK3RoaXMuZGVjb2RlUXVldWVTaXplO3RoaXMudG90YWxRdWV1ZWRTaXplKz1CLEI+dGhpcy5tYXhRdWV1ZWRTaXplJiYodGhpcy5tYXhRdWV1ZWRTaXplPUIpLDE1MDA9PXRoaXMuZGVjb2RlZENvdW50JiYoQkkoZ2cubmFtZSxcIkF2ZyBxdWV1ZTogXCIrdGhpcy50b3RhbFF1ZXVlZFNpemUvdGhpcy5kZWNvZGVkQ291bnQrXCIsIE1heDogXCIrdGhpcy5tYXhRdWV1ZWRTaXplK1wiIEF2ZyBGUFM6IFwiK3RoaXMuZGVjb2RlZENvdW50LygoSS10aGlzLnN0YXJ0U3RyZWFtVGltZU1zKS8xZTMpK1wiIEF2ZyBkZWNvZGU6IFwiK3RoaXMudG90YWxEZWNvZGluZ1RpbWVNcy90aGlzLmRlY29kZWRDb3VudCtcIm1zLCBNYXg6IFwiK3RoaXMubWF4RGVjb2RpbmdUaW1lTXMrXCJtc1wiKSx0aGlzLnRvdGFsRGVjb2RpbmdUaW1lTXM9MCx0aGlzLm1heERlY29kaW5nVGltZU1zPTAsdGhpcy50b3RhbFF1ZXVlZFNpemU9MCx0aGlzLm1heFF1ZXVlZFNpemU9MCx0aGlzLmRlY29kZWRDb3VudD0wLHRoaXMuc3RhcnRTdHJlYW1UaW1lTXM9SSl9cmVzYW1wbGVCdWZmZXJUaGVuU2NoZWR1bGVGb3JQbGF5YmFjayhBKXtjb25zdCBJPW5ldyh3aW5kb3cuT2ZmbGluZUF1ZGlvQ29udGV4dHx8d2luZG93LndlYmtpdE9mZmxpbmVBdWRpb0NvbnRleHQpKHRoaXMuY2hhbm5lbENvdW50LHRoaXMucmVzYW1wbGVkQXVkaW9CdWZmZXJTaXplLHRoaXMuYXVkaW9Db250ZXh0LnNhbXBsZVJhdGUpLGc9SS5jcmVhdGVCdWZmZXJTb3VyY2UoKTtnLmJ1ZmZlcj1BLGcuY29ubmVjdChJLmRlc3RpbmF0aW9uKSxnLnN0YXJ0KCksSS5zdGFydFJlbmRlcmluZygpLEkub25jb21wbGV0ZT10aGlzLnNjaGVkdWxlUmVzYW1wbGVkQnVmZmVyUGxheWJhY2suYmluZCh0aGlzLEEpfXNjaGVkdWxlUmVzYW1wbGVkQnVmZmVyUGxheWJhY2soQSxJKXt0aGlzLnNjaGVkdWxlUGxheWJhY2tXaXRoT25FbmRlZChJLnJlbmRlcmVkQnVmZmVyKSx0aGlzLnJldHVybkF1ZGlvQnVmZmVyVG9Qb29sKEEsSSl9c2NoZWR1bGVCdWZmZXJGb3JQbGF5YmFjayhBKXt0aGlzLnNjaGVkdWxlUGxheWJhY2tXaXRoT25FbmRlZChBLHRoaXMucmV0dXJuQXVkaW9CdWZmZXJUb1Bvb2wuYmluZCh0aGlzLEEpKX1zY2hlZHVsZVBsYXliYWNrV2l0aE9uRW5kZWQoQSxJPW51bGwpe2NvbnN0IGc9dGhpcy5hdWRpb0NvbnRleHQuY3JlYXRlQnVmZmVyU291cmNlKCk7Zy5idWZmZXI9QSx0aGlzLm5leHRTdGFydFRpbWV8fCh0aGlzLm5leHRTdGFydFRpbWU9dGhpcy5hdWRpb0NvbnRleHQuY3VycmVudFRpbWUpLGcucGxheWJhY2tSYXRlLnZhbHVlPTEsZy5jb25uZWN0KHRoaXMudm9sdW1lTm9kZSksZy5zdGFydCh0aGlzLm5leHRTdGFydFRpbWUpLGcub25lbmRlZD1JLHRoaXMubmV4dFN0YXJ0VGltZSs9QS5kdXJhdGlvbn1zZXRWb2x1bWUoQSl7dGhpcy52b2x1bWVOb2RlLmdhaW4udmFsdWU9QX19Y29uc3QgQmc9e3RhcmdldEZyYW1lcmF0ZTo2MCxidWZmZXJMaW1pdE1zOjUwMCxjcHVTdGFydmF0aW9uVGhyZXNob2xkOjEsZGVjb2RlclN0cnVnZ2xpbmdUaHJlc2hvbGQ6MSxjaGVja0ludGVydmFsOjE1MDAsd2luZG93TXM6NTAwfTtjbGFzcyBRZ3tjb25zdHJ1Y3RvcihBLEk9e30pe3RoaXMudmlkZW9TdHJlYW09QSx0aGlzLmRlY29kZXJTdHJ1Z2dsaW5nRXZlbnQ9bmV3IF9BLHRoaXMuY3B1U3RhcnZhdGlvbkV2ZW50PW5ldyBfQSx0aGlzLmNwdVN0YXJ2YXRpb25Db3VudGVyPTAsdGhpcy5kZWNvZGVyU3RydWdnbGluZ0NvdW50ZXI9MCx0aGlzLnJlYWR5U3RhdGVDaGFuZ2VIYW5kbGVyPUE9PntBPT09TkkuRGV0YWNoZWQ/dGhpcy5zdG9wQ2hlY2tpbmcoKTp0aGlzLmxhc3RWaWRlb1JlYWR5U3RhdGU9PT1OSS5EZXRhY2hlZCYmdGhpcy5zdGFydENoZWNraW5nKCksdGhpcy5sYXN0VmlkZW9SZWFkeVN0YXRlPUF9LHRoaXMudmlkZW9GcmFtZU1ldGFkYXRhSGFuZGxlcj1BPT57dGhpcy5wcm9jZXNzaW5nRHVyYXRpb25UcmFjay5mZWVkKEEpfSx0aGlzLmNoZWNrUGVyZm9ybWFuY2U9KCk9PntpZih0aGlzLnZpZGVvU3RyZWFtLnJlYWR5U3RhdGU9PT1OSS5QbGF5aW5nKXtjb25zdCBBPTEvdGhpcy5jb25maWcudGFyZ2V0RnJhbWVyYXRlLEk9MWUzKkEsZz1NYXRoLmZsb29yKHRoaXMuY29uZmlnLmJ1ZmZlckxpbWl0TXMvSSksQj10aGlzLnZpZGVvU3RyZWFtLmdldFN0YXRzKCk7KEIuZW5kT2ZCdWZmZXJlZD5CLmN1cnJlbnRUaW1lK3RoaXMuY29uZmlnLmJ1ZmZlckxpbWl0TXMvMWUzfHx0aGlzLnZpZGVvU3RyZWFtLmRhdGFRdWV1ZUxlbmd0aD5nKSYmdGhpcy52aWRlb1N0cmVhbS5yZXN0YXJ0KFwiY2hlY2tQZXJmb3JtYW5jZVwiKSx0aGlzLnZpZGVvU3RyZWFtLmRhdGFRdWV1ZUxlbmd0aD5nP3RoaXMuY3B1U3RhcnZhdGlvbkNvdW50ZXIrPTE6dGhpcy5jcHVTdGFydmF0aW9uQ291bnRlcj1NYXRoLm1heCgwLHRoaXMuY3B1U3RhcnZhdGlvbkNvdW50ZXItMSk7dGhpcy5wcm9jZXNzaW5nRHVyYXRpb25UcmFjay5hdmVyYWdlKCk+QT8odGhpcy5kZWNvZGVyU3RydWdnbGluZ0NvdW50ZXIrPTEsdGhpcy5jcHVTdGFydmF0aW9uQ291bnRlcj1NYXRoLm1heCgwLHRoaXMuY3B1U3RhcnZhdGlvbkNvdW50ZXItMSkpOnRoaXMuZGVjb2RlclN0cnVnZ2xpbmdDb3VudGVyPU1hdGgubWF4KDAsdGhpcy5kZWNvZGVyU3RydWdnbGluZ0NvdW50ZXItMSksdGhpcy5jcHVTdGFydmF0aW9uQ291bnRlcix0aGlzLmNvbmZpZy5jcHVTdGFydmF0aW9uVGhyZXNob2xkLHRoaXMuZGVjb2RlclN0cnVnZ2xpbmdDb3VudGVyLHRoaXMuY29uZmlnLmRlY29kZXJTdHJ1Z2dsaW5nVGhyZXNob2xkfX0sdGhpcy5jb25maWc9ey4uLkJnLC4uLkl9LHRoaXMucHJvY2Vzc2luZ0R1cmF0aW9uVHJhY2s9bmV3IEhJKHRoaXMuY29uZmlnLndpbmRvd01zLHFJKSx0aGlzLnZpZGVvU3RyZWFtLnJlYWR5U3RhdGVDaGFuZ2VFdmVudC5hZGRIYW5kbGVyKHRoaXMucmVhZHlTdGF0ZUNoYW5nZUhhbmRsZXIpLHRoaXMudmlkZW9TdHJlYW0udmlkZW9GcmFtZVByb2Nlc3NpbmdEdXJhdGlvbkV2ZW50LmFkZEhhbmRsZXIodGhpcy52aWRlb0ZyYW1lTWV0YWRhdGFIYW5kbGVyKSx0aGlzLmxhc3RWaWRlb1JlYWR5U3RhdGU9dGhpcy52aWRlb1N0cmVhbS5yZWFkeVN0YXRlLHRoaXMudmlkZW9TdHJlYW0ucmVhZHlTdGF0ZSE9PU5JLkRldGFjaGVkJiZ0aGlzLnN0YXJ0Q2hlY2tpbmcoKX1kaXNwb3NlKCl7dGhpcy5zdG9wQ2hlY2tpbmcoKSx0aGlzLnZpZGVvU3RyZWFtLnJlYWR5U3RhdGVDaGFuZ2VFdmVudC5yZW1vdmVIYW5kbGVyKHRoaXMucmVhZHlTdGF0ZUNoYW5nZUhhbmRsZXIpLHRoaXMudmlkZW9TdHJlYW0udmlkZW9GcmFtZVByb2Nlc3NpbmdEdXJhdGlvbkV2ZW50LnJlbW92ZUhhbmRsZXIodGhpcy52aWRlb0ZyYW1lTWV0YWRhdGFIYW5kbGVyKX1zdGFydENoZWNraW5nKCl7dGhpcy5wcm9jZXNzaW5nRHVyYXRpb25UcmFjaz1uZXcgSEkodGhpcy5jb25maWcud2luZG93TXMscUkpLHRoaXMuY2hlY2tQZXJmb3JtYW5jZUludGVydmFsPXdpbmRvdy5zZXRJbnRlcnZhbCh0aGlzLmNoZWNrUGVyZm9ybWFuY2UsdGhpcy5jb25maWcuY2hlY2tJbnRlcnZhbCl9c3RvcENoZWNraW5nKCl7dGhpcy5jaGVja1BlcmZvcm1hbmNlSW50ZXJ2YWwmJih3aW5kb3cuY2xlYXJJbnRlcnZhbCh0aGlzLmNoZWNrUGVyZm9ybWFuY2VJbnRlcnZhbCksdGhpcy5jaGVja1BlcmZvcm1hbmNlSW50ZXJ2YWw9dm9pZCAwKX19dmFyIENnOyFmdW5jdGlvbihBKXtBW0EuQW5uZXhCPTBdPVwiQW5uZXhCXCIsQVtBLkxlbmd0aFByZWZpeGVkPTFdPVwiTGVuZ3RoUHJlZml4ZWRcIn0oQ2d8fChDZz17fSkpO3ZhciBlZz17ZXhwb3J0czp7fX07c2VsZjt2YXIgaWc9JEkoZWcuZXhwb3J0cz0oKCk9Pnt2YXIgQT17MTE0OmZ1bmN0aW9uKEEsSSxnKXt2YXIgQj10aGlzJiZ0aGlzLl9faW1wb3J0RGVmYXVsdHx8ZnVuY3Rpb24oQSl7cmV0dXJuIEEmJkEuX19lc01vZHVsZT9BOntkZWZhdWx0OkF9fTtPYmplY3QuZGVmaW5lUHJvcGVydHkoSSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTtjb25zdCBRPUIoZygxNzApKTtjbGFzcyBDe2luaXRpYWxpemUoKXtyZXR1cm4gdGhpcy5pZD1DLnVuaXF1ZUlkQ291bnRlcisrLG5ldyBQcm9taXNlKCgoQSxJKT0+e3RoaXMud29ya2VyPW5ldyBRLmRlZmF1bHQsdGhpcy53b3JrZXIuYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwoST0+e3ZhciBnO2NvbnN0IEI9SS5kYXRhO1wiZGVjb2RlclJlYWR5XCI9PT1CLnR5cGU/QSgwKTpcInBpY3R1cmVSZWFkeVwiPT09Qi50eXBlJiYobnVsbD09PShnPXRoaXMub25EZWNvZGUpfHx2b2lkIDA9PT1nfHxnLmNhbGwodGhpcyxCKSl9KSl9KSl9ZGVjb2RlKEEpe3RoaXMud29ya2VyJiZ0aGlzLndvcmtlci5wb3N0TWVzc2FnZSh7dHlwZTpcImRlY29kZVwiLGRhdGE6QS5idWZmZXIsb2Zmc2V0OkEuYnl0ZU9mZnNldCxsZW5ndGg6QS5ieXRlTGVuZ3RoLHJlbmRlclN0YXRlSWQ6dGhpcy5pZH0sW0EuYnVmZmVyXSl9cmVsZWFzZSgpe3RoaXMud29ya2VyJiZ0aGlzLndvcmtlci5wb3N0TWVzc2FnZSh7dHlwZTpcInJlbGVhc2VcIixyZW5kZXJTdGF0ZUlkOnRoaXMuaWR9KX1kaXNwb3NlKCl7dGhpcy53b3JrZXImJih0aGlzLndvcmtlci50ZXJtaW5hdGUoKSx0aGlzLndvcmtlcj12b2lkIDApfX1JLmRlZmF1bHQ9QyxDLnVuaXF1ZUlkQ291bnRlcj0xfSwxNzA6KEEsSSxnKT0+e2cucihJKSxnLmQoSSx7ZGVmYXVsdDooKT0+Q30pO3ZhciBCPWcoNjE0KSxRPWcubihCKTtmdW5jdGlvbiBDKCl7cmV0dXJuIFEoKSgnLyohIEZvciBsaWNlbnNlIGluZm9ybWF0aW9uIHBsZWFzZSBzZWUgaW5kZXgud29ya2VyLmpzLkxJQ0VOU0UudHh0ICovXFxuKCgpPT57dmFyIEE9ezcxOTpBPT57dmFyIEksZz0oST1cInVuZGVmaW5lZFwiIT10eXBlb2YgZG9jdW1lbnQmJmRvY3VtZW50LmN1cnJlbnRTY3JpcHQ/ZG9jdW1lbnQuY3VycmVudFNjcmlwdC5zcmM6dm9pZCAwLGZ1bmN0aW9uKEEpeyhBPUF8fHt9KXx8KEE9dm9pZCAwIT09QT9BOnt9KTt2YXIgZyxCPXt9O2ZvcihnIGluIEEpQS5oYXNPd25Qcm9wZXJ0eShnKSYmKEJbZ109QVtnXSk7dmFyIFEsQz1bXSxFPVwiXCI7RT1zZWxmLmxvY2F0aW9uLmhyZWYsSSYmKEU9SSksRT0wIT09RS5pbmRleE9mKFwiYmxvYjpcIik/RS5zdWJzdHIoMCxFLmxhc3RJbmRleE9mKFwiL1wiKSsxKTpcIlwiLFE9ZnVuY3Rpb24oQSl7dmFyIEk9bmV3IFhNTEh0dHBSZXF1ZXN0O3JldHVybiBJLm9wZW4oXCJHRVRcIixBLCExKSxJLnJlc3BvbnNlVHlwZT1cImFycmF5YnVmZmVyXCIsSS5zZW5kKG51bGwpLG5ldyBVaW50OEFycmF5KEkucmVzcG9uc2UpfTt2YXIgaSxELG89QS5wcmludHx8Y29uc29sZS5sb2cuYmluZChjb25zb2xlKSxhPUEucHJpbnRFcnJ8fGNvbnNvbGUud2Fybi5iaW5kKGNvbnNvbGUpO2ZvcihnIGluIEIpQi5oYXNPd25Qcm9wZXJ0eShnKSYmKEFbZ109QltnXSk7Qj1udWxsLEEuYXJndW1lbnRzJiYoQz1BLmFyZ3VtZW50cyksQS50aGlzUHJvZ3JhbSYmQS50aGlzUHJvZ3JhbSxBLnF1aXQmJkEucXVpdCxBLndhc21CaW5hcnkmJihpPUEud2FzbUJpbmFyeSksQS5ub0V4aXRSdW50aW1lJiZBLm5vRXhpdFJ1bnRpbWUsXCJvYmplY3RcIiE9dHlwZW9mIFdlYkFzc2VtYmx5JiZhKFwibm8gbmF0aXZlIHdhc20gc3VwcG9ydCBkZXRlY3RlZFwiKTt2YXIgRyxTLEYsTix3LHksUixoPW5ldyBXZWJBc3NlbWJseS5UYWJsZSh7aW5pdGlhbDoxLG1heGltdW06MSxlbGVtZW50OlwiYW55ZnVuY1wifSkscz0hMTtmdW5jdGlvbiBrKEkpe0c9SSxBLkhFQVA4PVM9bmV3IEludDhBcnJheShJKSxBLkhFQVAxNj1OPW5ldyBJbnQxNkFycmF5KEkpLEEuSEVBUDMyPXc9bmV3IEludDMyQXJyYXkoSSksQS5IRUFQVTg9Rj1uZXcgVWludDhBcnJheShJKSxBLkhFQVBVMTY9bmV3IFVpbnQxNkFycmF5KEkpLEEuSEVBUFUzMj1uZXcgVWludDMyQXJyYXkoSSksQS5IRUFQRjMyPXk9bmV3IEZsb2F0MzJBcnJheShJKSxBLkhFQVBGNjQ9Uj1uZXcgRmxvYXQ2NEFycmF5KEkpfXZhciBMPUEuSU5JVElBTF9NRU1PUll8fDE2Nzc3MjE2O2Z1bmN0aW9uIE0oSSl7Zm9yKDtJLmxlbmd0aD4wOyl7dmFyIGc9SS5zaGlmdCgpO2lmKFwiZnVuY3Rpb25cIiE9dHlwZW9mIGcpe3ZhciBCPWcuZnVuYztcIm51bWJlclwiPT10eXBlb2YgQj92b2lkIDA9PT1nLmFyZz9BLmR5bkNhbGxfdihCKTpBLmR5bkNhbGxfdmkoQixnLmFyZyk6Qih2b2lkIDA9PT1nLmFyZz9udWxsOmcuYXJnKX1lbHNlIGcoQSl9fShEPUEud2FzbU1lbW9yeT9BLndhc21NZW1vcnk6bmV3IFdlYkFzc2VtYmx5Lk1lbW9yeSh7aW5pdGlhbDpMLzY1NTM2LG1heGltdW06MzI3Njh9KSkmJihHPUQuYnVmZmVyKSxMPUcuYnl0ZUxlbmd0aCxrKEcpLHdbMjE4OF09NTI1MTc5Mjt2YXIgVT1bXSxZPVtdLEo9W10scT1bXSxLPTAsSD1udWxsLHQ9bnVsbDtmdW5jdGlvbiBjKEkpe3Rocm93IEEub25BYm9ydCYmQS5vbkFib3J0KEkpLG8oSSs9XCJcIiksYShJKSxzPSEwLEk9XCJhYm9ydChcIitJK1wiKS4gQnVpbGQgd2l0aCAtcyBBU1NFUlRJT05TPTEgZm9yIG1vcmUgaW5mby5cIixuZXcgV2ViQXNzZW1ibHkuUnVudGltZUVycm9yKEkpfWZ1bmN0aW9uIGQoQSl7cmV0dXJuIEk9QSxnPVwiZGF0YTphcHBsaWNhdGlvbi9vY3RldC1zdHJlYW07YmFzZTY0LFwiLFN0cmluZy5wcm90b3R5cGUuc3RhcnRzV2l0aD9JLnN0YXJ0c1dpdGgoZyk6MD09PUkuaW5kZXhPZihnKTt2YXIgSSxnfUEucHJlbG9hZGVkSW1hZ2VzPXt9LEEucHJlbG9hZGVkQXVkaW9zPXt9O3ZhciBuLHA9XCJUaW55SDI2NC53YXNtXCI7ZnVuY3Rpb24gZigpe3RyeXtpZihpKXJldHVybiBuZXcgVWludDhBcnJheShpKTtpZihRKXJldHVybiBRKHApO3Rocm93XCJib3RoIGFzeW5jIGFuZCBzeW5jIGZldGNoaW5nIG9mIHRoZSB3YXNtIGZhaWxlZFwifWNhdGNoKEEpe2MoQSl9fWZ1bmN0aW9uIHIoQSl7dHJ5e3JldHVybiBELmdyb3coQS1HLmJ5dGVMZW5ndGgrNjU1MzU+Pj4xNiksayhELmJ1ZmZlciksMX1jYXRjaChBKXt9fWQocCl8fChuPXAscD1BLmxvY2F0ZUZpbGU/QS5sb2NhdGVGaWxlKG4sRSk6RStuKSxZLnB1c2goe2Z1bmM6ZnVuY3Rpb24oKXt4KCl9fSk7dmFyIGU9e2E6ZnVuY3Rpb24oQSxJLGcpe0YuY29weVdpdGhpbihBLEksSStnKX0sYjpmdW5jdGlvbihBKXtBPj4+PTA7dmFyIEk9Ri5sZW5ndGgsZz0yMTQ3NDgzNjQ4O2lmKEE+ZylyZXR1cm4hMTtmb3IodmFyIEIsUT0xO1E8PTQ7USo9Mil7dmFyIEM9SSooMSsuMi9RKTtpZihDPU1hdGgubWluKEMsQSsxMDA2NjMyOTYpLHIoTWF0aC5taW4oZywoKEI9TWF0aC5tYXgoMTY3NzcyMTYsQSxDKSklNjU1MzY+MCYmKEIrPTY1NTM2LUIlNjU1MzYpLEIpKSkpcmV0dXJuITB9cmV0dXJuITF9LG1lbW9yeTpELHRhYmxlOmh9LG09ZnVuY3Rpb24oKXt2YXIgST17YTplfTtmdW5jdGlvbiBnKEksZyl7dmFyIEI9SS5leHBvcnRzO0EuYXNtPUIsZnVuY3Rpb24oSSl7aWYoSy0tLEEubW9uaXRvclJ1bkRlcGVuZGVuY2llcyYmQS5tb25pdG9yUnVuRGVwZW5kZW5jaWVzKEspLDA9PUsmJihudWxsIT09SCYmKGNsZWFySW50ZXJ2YWwoSCksSD1udWxsKSx0KSl7dmFyIGc9dDt0PW51bGwsZygpfX0oKX1mdW5jdGlvbiBCKEEpe2coQS5pbnN0YW5jZSl9ZnVuY3Rpb24gUShBKXtyZXR1cm4oaXx8XCJmdW5jdGlvblwiIT10eXBlb2YgZmV0Y2g/bmV3IFByb21pc2UoKGZ1bmN0aW9uKEEsSSl7QShmKCkpfSkpOmZldGNoKHAse2NyZWRlbnRpYWxzOlwic2FtZS1vcmlnaW5cIn0pLnRoZW4oKGZ1bmN0aW9uKEEpe2lmKCFBLm9rKXRocm93XCJmYWlsZWQgdG8gbG9hZCB3YXNtIGJpbmFyeSBmaWxlIGF0IFxcJ1wiK3ArXCJcXCdcIjtyZXR1cm4gQS5hcnJheUJ1ZmZlcigpfSkpLmNhdGNoKChmdW5jdGlvbigpe3JldHVybiBmKCl9KSkpLnRoZW4oKGZ1bmN0aW9uKEEpe3JldHVybiBXZWJBc3NlbWJseS5pbnN0YW50aWF0ZShBLEkpfSkpLnRoZW4oQSwoZnVuY3Rpb24oQSl7YShcImZhaWxlZCB0byBhc3luY2hyb25vdXNseSBwcmVwYXJlIHdhc206IFwiK0EpLGMoQSl9KSl9aWYoSysrLEEubW9uaXRvclJ1bkRlcGVuZGVuY2llcyYmQS5tb25pdG9yUnVuRGVwZW5kZW5jaWVzKEspLEEuaW5zdGFudGlhdGVXYXNtKXRyeXtyZXR1cm4gQS5pbnN0YW50aWF0ZVdhc20oSSxnKX1jYXRjaChBKXtyZXR1cm4gYShcIk1vZHVsZS5pbnN0YW50aWF0ZVdhc20gY2FsbGJhY2sgZmFpbGVkIHdpdGggZXJyb3I6IFwiK0EpLCExfXJldHVybiBmdW5jdGlvbigpe2lmKGl8fFwiZnVuY3Rpb25cIiE9dHlwZW9mIFdlYkFzc2VtYmx5Lmluc3RhbnRpYXRlU3RyZWFtaW5nfHxkKHApfHxcImZ1bmN0aW9uXCIhPXR5cGVvZiBmZXRjaClyZXR1cm4gUShCKTtmZXRjaChwLHtjcmVkZW50aWFsczpcInNhbWUtb3JpZ2luXCJ9KS50aGVuKChmdW5jdGlvbihBKXtyZXR1cm4gV2ViQXNzZW1ibHkuaW5zdGFudGlhdGVTdHJlYW1pbmcoQSxJKS50aGVuKEIsKGZ1bmN0aW9uKEEpe2EoXCJ3YXNtIHN0cmVhbWluZyBjb21waWxlIGZhaWxlZDogXCIrQSksYShcImZhbGxpbmcgYmFjayB0byBBcnJheUJ1ZmZlciBpbnN0YW50aWF0aW9uXCIpLFEoQil9KSl9KSl9KCkse319KCk7QS5hc209bTt2YXIgVyx4PUEuX19fd2FzbV9jYWxsX2N0b3JzPWZ1bmN0aW9uKCl7cmV0dXJuKHg9QS5fX193YXNtX2NhbGxfY3RvcnM9QS5hc20uYykuYXBwbHkobnVsbCxhcmd1bWVudHMpfTtmdW5jdGlvbiBYKEkpe2Z1bmN0aW9uIGcoKXtXfHwoVz0hMCxBLmNhbGxlZFJ1bj0hMCxzfHwoTShZKSxNKEopLEEub25SdW50aW1lSW5pdGlhbGl6ZWQmJkEub25SdW50aW1lSW5pdGlhbGl6ZWQoKSxmdW5jdGlvbigpe2lmKEEucG9zdFJ1bilmb3IoXCJmdW5jdGlvblwiPT10eXBlb2YgQS5wb3N0UnVuJiYoQS5wb3N0UnVuPVtBLnBvc3RSdW5dKTtBLnBvc3RSdW4ubGVuZ3RoOylJPUEucG9zdFJ1bi5zaGlmdCgpLHEudW5zaGlmdChJKTt2YXIgSTtNKHEpfSgpKSl9ST1JfHxDLEs+MHx8KGZ1bmN0aW9uKCl7aWYoQS5wcmVSdW4pZm9yKFwiZnVuY3Rpb25cIj09dHlwZW9mIEEucHJlUnVuJiYoQS5wcmVSdW49W0EucHJlUnVuXSk7QS5wcmVSdW4ubGVuZ3RoOylJPUEucHJlUnVuLnNoaWZ0KCksVS51bnNoaWZ0KEkpO3ZhciBJO00oVSl9KCksSz4wfHwoQS5zZXRTdGF0dXM/KEEuc2V0U3RhdHVzKFwiUnVubmluZy4uLlwiKSxzZXRUaW1lb3V0KChmdW5jdGlvbigpe3NldFRpbWVvdXQoKGZ1bmN0aW9uKCl7QS5zZXRTdGF0dXMoXCJcIil9KSwxKSxnKCl9KSwxKSk6ZygpKSl9aWYoQS5faDI2NGJzZEluaXQ9ZnVuY3Rpb24oKXtyZXR1cm4oQS5faDI2NGJzZEluaXQ9QS5hc20uZCkuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxBLl9tYWxsb2M9ZnVuY3Rpb24oKXtyZXR1cm4oQS5fbWFsbG9jPUEuYXNtLmUpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sQS5fZnJlZT1mdW5jdGlvbigpe3JldHVybihBLl9mcmVlPUEuYXNtLmYpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sQS5faDI2NGJzZERlY29kZT1mdW5jdGlvbigpe3JldHVybihBLl9oMjY0YnNkRGVjb2RlPUEuYXNtLmcpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sQS5faDI2NGJzZFNodXRkb3duPWZ1bmN0aW9uKCl7cmV0dXJuKEEuX2gyNjRic2RTaHV0ZG93bj1BLmFzbS5oKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LEEuX2gyNjRic2RBbGxvYz1mdW5jdGlvbigpe3JldHVybihBLl9oMjY0YnNkQWxsb2M9QS5hc20uaSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxBLl9oMjY0YnNkRnJlZT1mdW5jdGlvbigpe3JldHVybihBLl9oMjY0YnNkRnJlZT1BLmFzbS5qKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LEEuYXNtPW0sQS5nZXRWYWx1ZT1mdW5jdGlvbihBLEksZyl7c3dpdGNoKFwiKlwiPT09KEk9SXx8XCJpOFwiKS5jaGFyQXQoSS5sZW5ndGgtMSkmJihJPVwiaTMyXCIpLEkpe2Nhc2VcImkxXCI6Y2FzZVwiaThcIjpyZXR1cm4gU1tBPj4wXTtjYXNlXCJpMTZcIjpyZXR1cm4gTltBPj4xXTtjYXNlXCJpMzJcIjpjYXNlXCJpNjRcIjpyZXR1cm4gd1tBPj4yXTtjYXNlXCJmbG9hdFwiOnJldHVybiB5W0E+PjJdO2Nhc2VcImRvdWJsZVwiOnJldHVybiBSW0E+PjNdO2RlZmF1bHQ6YyhcImludmFsaWQgdHlwZSBmb3IgZ2V0VmFsdWU6IFwiK0kpfXJldHVybiBudWxsfSxBLnRoZW49ZnVuY3Rpb24oSSl7aWYoVylJKEEpO2Vsc2V7dmFyIGc9QS5vblJ1bnRpbWVJbml0aWFsaXplZDtBLm9uUnVudGltZUluaXRpYWxpemVkPWZ1bmN0aW9uKCl7ZyYmZygpLEkoQSl9fXJldHVybiBBfSx0PWZ1bmN0aW9uIEEoKXtXfHxYKCksV3x8KHQ9QSl9LEEucnVuPVgsQS5wcmVJbml0KWZvcihcImZ1bmN0aW9uXCI9PXR5cGVvZiBBLnByZUluaXQmJihBLnByZUluaXQ9W0EucHJlSW5pdF0pO0EucHJlSW5pdC5sZW5ndGg+MDspQS5wcmVJbml0LnBvcCgpKCk7cmV0dXJuIFgoKSxBfSk7QS5leHBvcnRzPWd9LDM0MDooQSxJLGcpPT57XCJ1c2Ugc3RyaWN0XCI7Zy5yKEkpLGcuZChJLHtpbml0OigpPT5vfSk7dmFyIEI9ZnVuY3Rpb24oKXtmdW5jdGlvbiBBKEEsSSl7dGhpcy50aW55SDI2NE1vZHVsZT1BLHRoaXMub25QaWN0dXJlUmVhZHk9SSx0aGlzLnBTdG9yYWdlPXRoaXMudGlueUgyNjRNb2R1bGUuX2gyNjRic2RBbGxvYygpLHRoaXMucFdpZHRoPXRoaXMudGlueUgyNjRNb2R1bGUuX21hbGxvYyg0KSx0aGlzLnBIZWlnaHQ9dGhpcy50aW55SDI2NE1vZHVsZS5fbWFsbG9jKDQpLHRoaXMucFBpY3R1cmU9dGhpcy50aW55SDI2NE1vZHVsZS5fbWFsbG9jKDQpLHRoaXMuX2RlY0J1ZmZlcj10aGlzLnRpbnlIMjY0TW9kdWxlLl9tYWxsb2MoMTA0ODU3NiksdGhpcy50aW55SDI2NE1vZHVsZS5faDI2NGJzZEluaXQodGhpcy5wU3RvcmFnZSwwKX12YXIgST1BLnByb3RvdHlwZTtyZXR1cm4gSS5yZWxlYXNlPWZ1bmN0aW9uKCl7dmFyIEE9dGhpcy5wU3RvcmFnZTswIT09QSYmKHRoaXMudGlueUgyNjRNb2R1bGUuX2gyNjRic2RTaHV0ZG93bihBKSx0aGlzLnRpbnlIMjY0TW9kdWxlLl9oMjY0YnNkRnJlZShBKSksdGhpcy50aW55SDI2NE1vZHVsZS5fZnJlZSh0aGlzLnBXaWR0aCksdGhpcy50aW55SDI2NE1vZHVsZS5fZnJlZSh0aGlzLnBIZWlnaHQpLHRoaXMudGlueUgyNjRNb2R1bGUuX2ZyZWUodGhpcy5wUGljdHVyZSksdGhpcy5wU3RvcmFnZT0wLHRoaXMucFdpZHRoPTAsdGhpcy5wSGVpZ2h0PTB9LEkuZGVjb2RlPWZ1bmN0aW9uKEkpe2lmKEkgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlciYmKEk9bmV3IFVpbnQ4QXJyYXkoSSkpLHRoaXMudGlueUgyNjRNb2R1bGUuSEVBUFU4LnNldChJLHRoaXMuX2RlY0J1ZmZlciksdGhpcy50aW55SDI2NE1vZHVsZS5faDI2NGJzZERlY29kZSh0aGlzLnBTdG9yYWdlLHRoaXMuX2RlY0J1ZmZlcixJLmJ5dGVMZW5ndGgsdGhpcy5wUGljdHVyZSx0aGlzLnBXaWR0aCx0aGlzLnBIZWlnaHQpPT09QS5QSUNfUkRZKXt2YXIgZz10aGlzLnRpbnlIMjY0TW9kdWxlLmdldFZhbHVlKHRoaXMucFdpZHRoLFwiaTMyXCIpLEI9dGhpcy50aW55SDI2NE1vZHVsZS5nZXRWYWx1ZSh0aGlzLnBIZWlnaHQsXCJpMzJcIiksUT10aGlzLnRpbnlIMjY0TW9kdWxlLmdldFZhbHVlKHRoaXMucFBpY3R1cmUsXCJpOCpcIiksQz1uZXcgVWludDhBcnJheSh0aGlzLnRpbnlIMjY0TW9kdWxlLkhFQVBVOC5zdWJhcnJheShRLFErZypCKjMvMikpO3RoaXMub25QaWN0dXJlUmVhZHkoQyxnLEIpfX0sQX0oKTtCLlJEWT0wLEIuUElDX1JEWT0xLEIuSERSU19SRFk9MixCLkVSUk9SPTMsQi5QQVJBTV9TRVRfRVJST1I9NCxCLk1FTUFMTE9DX0VSUk9SPTU7Y29uc3QgUT1CO3ZhciBDPWcoNzE5KSxFPWcubihDKSxpPXtcIlRpbnlIMjY0Lndhc21cIjpcImRhdGE6O2Jhc2U2NCxBR0Z6YlFFQUFBQUJsd0VUWUFKL2Z3Ri9ZQVIvZjM5L0FYOWdBbjkvQUdBRGYzOS9BWDlnQVg4QVlBbC9mMzkvZjM5L2YzOEFZQUYvQVg5Z0JIOS9mMzhBWUFaL2YzOS9mMzhCZjJBSWYzOS9mMzkvZjM4QVlBTi9mMzhBWUFWL2YzOS9md0YvWUFBQVlBVi9mMzkvZndCZ0JuOS9mMzkvZndCZ0NuOS9mMzkvZjM5L2YzOEFZQUFCZjJBSGYzOS9mMzkvZndGL1lBaC9mMzkvZjM5L2Z3Ri9BaDBEQVdFQllRQURBV0VCWWdBR0FXRUdiV1Z0YjNKNUFnR0FBb0NBQWdObVpRQUFCQUFCQXdvQkJnQUZBd1VHQndBSEJnQUREZ01IQndVQ0FBSURCQUFGQlFVRkNnUUNCQWtCQndBREJnWUNBZ0VHQkFNQ0FnRUxBUUVEQXdzTkFnRUFBQUlKQ1FrUEFnVUZBQUVLQUJJTEVRZ0lCd2dJQndRQkJBZ0lCZ0VFRUFRSUFBRU1CZ2tCZndGQjBNWEFBZ3NISVFnQll3Qm1BV1FBWkFGbEFBb0JaZ0FFQVdjQVl3Rm9BR0lCYVFCaEFXb0FZQXJFcUFWbHdBSUJBbjhnQUJBUElnSkJmMHdFUUNBQVFRRVFDeG9nQVVFQU5nSUFRUUFQQ3dKQUFrQWdBa0dBZ0lDQUJFOEVRQ0FBUVFNUUMwRi9SZ1JBUVFFUEN5QUJJQUpCSFhaQkFYRkJBV28yQWdBTUFRc2dBa0dBZ0lDQUFrOEVRQ0FBUVFVUUMwRi9SZ1JBUVFFUEN5QUJJQUpCRzNaQkEzRkJBMm8yQWdBTUFRc2dBa0dBZ0lDQUFVOEVRQ0FBUVFjUUMwRi9SZ1JBUVFFUEN5QUJJQUpCR1haQkIzRkJCMm8yQWdBTUFRc2dBaEF2SWdOQkJHb2lBa0VnUmdSQUlBRkJBRFlDQUNBQVFTQVFDeHBCQVNFQ0lBQkJBUkFEUVFGSERRSWdBQkFQSVFNZ0FFRWdFQXRCZjBZTkFpQURRUUZMRFFJZ0EwRUJhd1JBSUFGQmZ6WUNBQXdDQ3lBQlFYODJBZ0JCQVE4TElBQWdBMEVGYWhBTEdpQUFJQUlRQXlJQVFYOUdCRUJCQVE4TElBRWdBRUYvSUFKMFFYOXphallDQUF0QkFDRUNDeUFDQzRnQ0FRZC9JQUFvQWdRaEJBSkFJQUFvQWd4QkEzUWlCeUFBS0FJUUlnaHJJZ0pCSUU0RVFDQUVLQUFBSWdOQkdIUWdBMEVJZEVHQWdQd0hjWElnQTBFSWRrR0EvZ054SUFOQkdIWnljaUVESUFBb0FnZ2lBa1VOQVNBRElBSjBJQVF0QUFSQkNDQUNhM1p5SVFNTUFRc2dBa0VCU0FSQURBRUxJQVF0QUFBZ0FDZ0NDQ0lGUVJocUlnWjBJUU1nQWlBRmFrRjRhaUlDUVFGSURRQURRQ0FFTFFBQklBWkJlR29pQm5RZ0EzSWhBeUFDUVFoS0lRVWdCRUVCYWlFRUlBSkJlR29oQWlBRkRRQUxDeUFBSUFFZ0NHb2lCRFlDRUNBQUlBUkJCM0UyQWdoQmZ5RUNJQVFnQjAwRWZ5QUFJQUFvQWdBZ0JFRURkbW8yQWdRZ0EwRWdJQUZyZGdWQmZ3c0xxZzBCQjM4Q1FDQUFSUTBBSUFCQmVHb2lBeUFBUVh4cUtBSUFJZ0ZCZUhFaUFHb2hCUUpBSUFGQkFYRU5BQ0FCUVFOeFJRMEJJQU1nQXlnQ0FDSUNheUlEUWNUQUFDZ0NBQ0lFU1EwQklBQWdBbW9oQUNBRFFjakFBQ2dDQUVjRVFDQUNRZjhCVFFSQUlBTW9BZ2dpQkNBQ1FRTjJJZ0pCQTNSQjNNQUFha2NhSUFRZ0F5Z0NEQ0lCUmdSQVFiVEFBRUcwd0FBb0FnQkJmaUFDZDNFMkFnQU1Bd3NnQkNBQk5nSU1JQUVnQkRZQ0NBd0NDeUFES0FJWUlRWUNRQ0FESUFNb0Fnd2lBVWNFUUNBRUlBTW9BZ2dpQWswRVFDQUNLQUlNR2dzZ0FpQUJOZ0lNSUFFZ0FqWUNDQXdCQ3dKQUlBTkJGR29pQWlnQ0FDSUVEUUFnQTBFUWFpSUNLQUlBSWdRTkFFRUFJUUVNQVFzRFFDQUNJUWNnQkNJQlFSUnFJZ0lvQWdBaUJBMEFJQUZCRUdvaEFpQUJLQUlRSWdRTkFBc2dCMEVBTmdJQUN5QUdSUTBCQWtBZ0F5QURLQUljSWdKQkFuUkI1TUlBYWlJRUtBSUFSZ1JBSUFRZ0FUWUNBQ0FCRFFGQnVNQUFRYmpBQUNnQ0FFRitJQUozY1RZQ0FBd0RDeUFHUVJCQkZDQUdLQUlRSUFOR0cyb2dBVFlDQUNBQlJRMENDeUFCSUFZMkFoZ2dBeWdDRUNJQ0JFQWdBU0FDTmdJUUlBSWdBVFlDR0FzZ0F5Z0NGQ0lDUlEwQklBRWdBallDRkNBQ0lBRTJBaGdNQVFzZ0JTZ0NCQ0lCUVFOeFFRTkhEUUJCdk1BQUlBQTJBZ0FnQlNBQlFYNXhOZ0lFSUFNZ0FFRUJjallDQkNBQUlBTnFJQUEyQWdBUEN5QUZJQU5ORFFBZ0JTZ0NCQ0lCUVFGeFJRMEFBa0FnQVVFQ2NVVUVRQ0FGUWN6QUFDZ0NBRVlFUUVITXdBQWdBellDQUVIQXdBQkJ3TUFBS0FJQUlBQnFJZ0EyQWdBZ0F5QUFRUUZ5TmdJRUlBTkJ5TUFBS0FJQVJ3MERRYnpBQUVFQU5nSUFRY2pBQUVFQU5nSUFEd3NnQlVISXdBQW9BZ0JHQkVCQnlNQUFJQU0yQWdCQnZNQUFRYnpBQUNnQ0FDQUFhaUlBTmdJQUlBTWdBRUVCY2pZQ0JDQUFJQU5xSUFBMkFnQVBDeUFCUVhoeElBQnFJUUFDUUNBQlFmOEJUUVJBSUFVb0Fnd2hBaUFGS0FJSUlnUWdBVUVEZGlJQlFRTjBRZHpBQUdvaUIwY0VRRUhFd0FBb0FnQWFDeUFDSUFSR0JFQkJ0TUFBUWJUQUFDZ0NBRUYrSUFGM2NUWUNBQXdDQ3lBQ0lBZEhCRUJCeE1BQUtBSUFHZ3NnQkNBQ05nSU1JQUlnQkRZQ0NBd0JDeUFGS0FJWUlRWUNRQ0FGSUFVb0Fnd2lBVWNFUUVIRXdBQW9BZ0FnQlNnQ0NDSUNUUVJBSUFJb0Fnd2FDeUFDSUFFMkFnd2dBU0FDTmdJSURBRUxBa0FnQlVFVWFpSUNLQUlBSWdRTkFDQUZRUkJxSWdJb0FnQWlCQTBBUVFBaEFRd0JDd05BSUFJaEJ5QUVJZ0ZCRkdvaUFpZ0NBQ0lFRFFBZ0FVRVFhaUVDSUFFb0FoQWlCQTBBQ3lBSFFRQTJBZ0FMSUFaRkRRQUNRQ0FGSUFVb0Fod2lBa0VDZEVIa3dnQnFJZ1FvQWdCR0JFQWdCQ0FCTmdJQUlBRU5BVUc0d0FCQnVNQUFLQUlBUVg0Z0FuZHhOZ0lBREFJTElBWkJFRUVVSUFZb0FoQWdCVVliYWlBQk5nSUFJQUZGRFFFTElBRWdCallDR0NBRktBSVFJZ0lFUUNBQklBSTJBaEFnQWlBQk5nSVlDeUFGS0FJVUlnSkZEUUFnQVNBQ05nSVVJQUlnQVRZQ0dBc2dBeUFBUVFGeU5nSUVJQUFnQTJvZ0FEWUNBQ0FEUWNqQUFDZ0NBRWNOQVVHOHdBQWdBRFlDQUE4TElBVWdBVUYrY1RZQ0JDQURJQUJCQVhJMkFnUWdBQ0FEYWlBQU5nSUFDeUFBUWY4QlRRUkFJQUJCQTNZaUFVRURkRUhjd0FCcUlRQUNmMEcwd0FBb0FnQWlBa0VCSUFGMElnRnhSUVJBUWJUQUFDQUJJQUp5TmdJQUlBQU1BUXNnQUNnQ0NBc2hBaUFBSUFNMkFnZ2dBaUFETmdJTUlBTWdBRFlDRENBRElBSTJBZ2dQQ3lBRFFnQTNBaEFnQXdKL1FRQWdBRUVJZGlJQlJRMEFHa0VmSUFCQi8vLy9CMHNOQUJvZ0FTQUJRWUQrUDJwQkVIWkJDSEVpQVhRaUFpQUNRWURnSDJwQkVIWkJCSEVpQW5RaUJDQUVRWUNBRDJwQkVIWkJBbkVpQkhSQkQzWWdBU0FDY2lBRWNtc2lBVUVCZENBQUlBRkJGV3AyUVFGeGNrRWNhZ3NpQWpZQ0hDQUNRUUowUWVUQ0FHb2hBUUpBQWtBQ1FFRzR3QUFvQWdBaUJFRUJJQUowSWdkeFJRUkFRYmpBQUNBRUlBZHlOZ0lBSUFFZ0F6WUNBQ0FESUFFMkFoZ01BUXNnQUVFQVFSa2dBa0VCZG1zZ0FrRWZSaHQwSVFJZ0FTZ0NBQ0VCQTBBZ0FTSUVLQUlFUVhoeElBQkdEUUlnQWtFZGRpRUJJQUpCQVhRaEFpQUVJQUZCQkhGcUlnZEJFR29vQWdBaUFRMEFDeUFISUFNMkFoQWdBeUFFTmdJWUN5QURJQU0yQWd3Z0F5QUROZ0lJREFFTElBUW9BZ2dpQUNBRE5nSU1JQVFnQXpZQ0NDQURRUUEyQWhnZ0F5QUVOZ0lNSUFNZ0FEWUNDQXRCMU1BQVFkVEFBQ2dDQUVGL2FpSUFOZ0lBSUFBTkFFSDh3d0FoQXdOQUlBTW9BZ0FpQUVFSWFpRURJQUFOQUF0QjFNQUFRWDgyQWdBTEMzUUJBbjhqQUVFUWF5SUNKQUFnQWtFQU5nSU1JQUFnQWtFTWFoQUNJUUFDZnlBQ0tBSU1JZ05CZjBZRVFFRUJJQUJGRFFFYUlBRkJnSUNBZ0hnMkFnQkJBQXdCQzBFQklBQU5BQm9nQVNBRFFRRnFRUUYySWdGQkFDQUJheUFEUVFGeEd6WUNBRUVBQ3lFQUlBSkJFR29rQUNBQUM3a0xBUlIvSUFGQm9EMXFMUUFBUVF4c0lnWkIxRHhxS0FJQUlRUWdCa0hRUEdvb0FnQWdBVUdRUEdvdEFBQWlCM1FoQlNBQ1JRUkFJQUFnQUNnQ0FDQUZiRFlDQUFzZ0JDQUhkQ0VCQWtBQ1FDQURRWnovQTNFRVFDQUFJQVpCMkR4cUtBSUFJQWQwSWdNZ0FDZ0NQR3cyQWp3Z0FDQUFLQUk0SUFGc05nSTRRUUVoQWlBQUlBQW9BaXdnQld3aUJ5QUFLQUlNSUFWc0lnUnFJZ3dnQUNnQ0lDQUJiQ0lOSUFBb0FqUWdBV3dpRGtFQmRXb2lFR3NpQmpZQ0xDQUFLQUlvSVJFZ0FDQUVJQWRySWdRZ0RVRUJkU0FPYXlJTmF5SUhOZ0lvSUFBb0FpUWhDQ0FBSUFRZ0RXb2lCRFlDSkNBQUlBQW9BaHdnQVd3aURpQUFLQUlJSUFGc0lncHFJaElnQUNnQ0VDQURiQ0lQSUFBb0FqQWdBMndpQzBFQmRXb2lFMnNpRFRZQ0hDQUFLQUlZSVFrZ0FDQUtJQTVySWdvZ0QwRUJkU0FMYXlJUGF5SU9OZ0lZSUFBb0FoUWhDeUFBSUFvZ0Qyb2lDallDRkNBQUlBVWdDMndpRHlBQUtBSUFJZ3RxSWhRZ0FDZ0NCQ0FCYkNJVklBRWdDV3dpQ1VFQmRXb2lGbXNpQlRZQ0RDQUFJQXNnRDJzaUN5QVZRUUYxSUFscklnbHJJZzgyQWdnZ0FDQUpJQXRxSWdzMkFnUWdBQ0FCSUFoc0lnZ2dBQ2dDT0NJSmF5SVZJQU1nRVd3aUVVRUJkU0FBS0FJOEloZHJJZ05ySWdFMkFqZ2dBQ0FESUJWcUlnTTJBalFnQUNBSUlBbHFJZ2dnRjBFQmRTQVJhaUlKYXlJUk5nSThJQUFnRkNBV2FpSVVJQXdnRUdvaURHdEJJR29pRUNBU0lCTnFJaEpCQVhVZ0NDQUphaUlJYXlJVGEwRUdkU0lKTmdJZ0lBQWdFQ0FUYWtFR2RTSVFOZ0lRSUFBZ0RDQVVha0VnYWlJTUlBaEJBWFVnRW1vaUNHdEJCblVpRWpZQ01DQUFJQWdnREdwQkJuVWlERFlDQUNBTVFZQUVhaUFRUVlBRWFuSkIvd2RMRFFJZ0VrR0FCR29nQ1VHQUJHcHlRZjhIU3cwQ0lBQWdCQ0FMYWtFZ2FpSU1JQU5CQVhVZ0Ntb2lFR3RCQm5VaUNEWUNOQ0FBSUFzZ0JHdEJJR29pQkNBS1FRRjFJQU5ySWdOclFRWjFJZ28yQWlRZ0FDQURJQVJxUVFaMUlnTTJBaFFnQUNBTUlCQnFRUVoxSWdRMkFnUWdCRUdBQkdvZ0EwR0FCR3B5UWY4SFN3MENJQWhCZ0FScUlBcEJnQVJxY2tIL0Iwc05BaUFBSUFjZ0QycEJJR29pQXlBQlFRRjFJQTVxSWdSclFRWjFJZ28yQWpnZ0FDQVBJQWRyUVNCcUlnY2dEa0VCZFNBQmF5SUJhMEVHZFNJT05nSW9JQUFnQVNBSGFrRUdkU0lCTmdJWUlBQWdBeUFFYWtFR2RTSUROZ0lJSUFOQmdBUnFJQUZCZ0FScWNrSC9CMHNOQWlBS1FZQUVhaUFPUVlBRWFuSkIvd2RMRFFJZ0FDQUZJQVpxUVNCcUlnRWdFVUVCZFNBTmFpSURhMEVHZFNJSE5nSThJQUFnQlNBR2EwRWdhaUlGSUExQkFYVWdFV3NpQm10QkJuVWlCRFlDTENBQUlBVWdCbXBCQm5VaUJUWUNIQ0FBSUFFZ0EycEJCblVpQURZQ0RDQUFRWUFFYWlBRlFZQUVhbkpCL3dkTERRSWdCMEdBQkdvZ0JFR0FCR3B5UWY4SFRRMEJEQUlMSUFOQjRnQnhSUVJBUVFFaEFpQUFLQUlBUVNCcVFRWjFJZ0ZCZ0FScVFmOEhTdzBDSUFBZ0FUWUNPQ0FBSUFFMkFqd2dBQ0FCTmdJMElBQWdBVFlDTUNBQUlBRTJBaXdnQUNBQk5nSW9JQUFnQVRZQ0pDQUFJQUUyQWlBZ0FDQUJOZ0ljSUFBZ0FUWUNHQ0FBSUFFMkFoUWdBQ0FCTmdJUUlBQWdBVFlDRENBQUlBRTJBZ2dnQUNBQk5nSUVJQUFnQVRZQ0FBd0JDMEVCSVFJZ0FDQUFLQUlFSUFGc0lnUWdBQ2dDR0NBQmJDSU5RUUYxYWlJRElBQW9BZ0FpQmlBQUtBSVVJQVZzSWdkcUlnVnFRU0JxUVFaMUlnRTJBakFnQUNBRklBTnJRU0JxUVFaMUlnTTJBZ3dnQUNBRVFRRjFJQTFySWdRZ0JpQUhhMnBCSUdwQkJuVWlCVFlDQkNBQUlBRTJBZ0FnQUNBQk5nSWdJQUFnQlRZQ05DQUFJQUUyQWhBZ0FDQUZOZ0lrSUFBZ0JUWUNGQ0FBSUFNMkFqd2dBQ0FHSUFRZ0IycHJRU0JxUVFaMUlnWTJBZ2dnQUNBR05nSTRJQUFnQmpZQ0tDQUFJQVkyQWhnZ0FDQUROZ0lzSUFBZ0F6WUNIQ0FEUVlBRWFpQUJRWUFFYWlBR1FZQUVhaUFGUVlBRWFuSnlja0gvQjBzTkFRdEJBQ0VDQ3lBQ0MvTUNBZ0ovQVg0Q1FDQUNSUTBBSUFBZ0Ftb2lBMEYvYWlBQk9nQUFJQUFnQVRvQUFDQUNRUU5KRFFBZ0EwRithaUFCT2dBQUlBQWdBVG9BQVNBRFFYMXFJQUU2QUFBZ0FDQUJPZ0FDSUFKQkIwa05BQ0FEUVh4cUlBRTZBQUFnQUNBQk9nQURJQUpCQ1VrTkFDQUFRUUFnQUd0QkEzRWlCR29pQXlBQlFmOEJjVUdCZ29RSWJDSUJOZ0lBSUFNZ0FpQUVhMEY4Y1NJRWFpSUNRWHhxSUFFMkFnQWdCRUVKU1EwQUlBTWdBVFlDQ0NBRElBRTJBZ1FnQWtGNGFpQUJOZ0lBSUFKQmRHb2dBVFlDQUNBRVFSbEpEUUFnQXlBQk5nSVlJQU1nQVRZQ0ZDQURJQUUyQWhBZ0F5QUJOZ0lNSUFKQmNHb2dBVFlDQUNBQ1FXeHFJQUUyQWdBZ0FrRm9haUFCTmdJQUlBSkJaR29nQVRZQ0FDQUVJQU5CQkhGQkdISWlCR3NpQWtFZ1NRMEFJQUd0SWdWQ0lJWWdCWVFoQlNBRElBUnFJUUVEUUNBQklBVTNBeGdnQVNBRk53TVFJQUVnQlRjRENDQUJJQVUzQXdBZ0FVRWdhaUVCSUFKQllHb2lBa0VmU3cwQUN3c2dBQXZ5QXdFRGZ5QUJLQUlBSWdOQi8vLy9CMGNFUUNBQktBSUVJUVFnQUNBQ0lBSkJBM0VnQWtFUVNTSUNHMEVDZENJRlFmQXBhaWdDQUVFUVFRZ2dBaHNpQW14cUlBVkJzQ2xxS0FJQWFpSUFJQU1nQUMwQUFHcEJzQzVxTFFBQU9nQUFJQUVvQWdnaEF5QUFJQVFnQUMwQUFXcEJzQzVxTFFBQU9nQUJJQUVvQWd3aEJDQUFJQU1nQUMwQUFtcEJzQzVxTFFBQU9nQUNJQUFnQkNBQUxRQURha0d3TG1vdEFBQTZBQU1nQVNnQ0ZDRURJQUFnQW1vaUFDQUJLQUlRSUFBdEFBQnFRYkF1YWkwQUFEb0FBQ0FCS0FJWUlRUWdBQ0FESUFBdEFBRnFRYkF1YWkwQUFEb0FBU0FCS0FJY0lRTWdBQ0FFSUFBdEFBSnFRYkF1YWkwQUFEb0FBaUFBSUFNZ0FDMEFBMnBCc0M1cUxRQUFPZ0FESUFFb0FpUWhBeUFBSUFKcUlnQWdBU2dDSUNBQUxRQUFha0d3TG1vdEFBQTZBQUFnQVNnQ0tDRUVJQUFnQXlBQUxRQUJha0d3TG1vdEFBQTZBQUVnQVNnQ0xDRURJQUFnQkNBQUxRQUNha0d3TG1vdEFBQTZBQUlnQUNBRElBQXRBQU5xUWJBdWFpMEFBRG9BQXlBQktBSTBJUU1nQUNBQ2FpSUFJQUVvQWpBZ0FDMEFBR3BCc0M1cUxRQUFPZ0FBSUFFb0FqZ2hBaUFBSUFNZ0FDMEFBV3BCc0M1cUxRQUFPZ0FCSUFFb0Fqd2hBU0FBSUFJZ0FDMEFBbXBCc0M1cUxRQUFPZ0FDSUFBZ0FTQUFMUUFEYWtHd0xtb3RBQUE2QUFNTEM5TVFBUXgvSXdCQmdBRnJJZ29rQUNBQUVBOGhCRUVCSVFVQ1FBSkFBbjhnQWtFQlRRUkFJQVJCQUVnTkFpQUVRUmwyUWY0QWNVR0FDR29nQkVHQWdJRGdBRThOQVJvZ0JFRVZka0grRDNGQndBaHFJQVJCZ0lDQUNFOE5BUm9nQkVFUmRrSCsvd0Z4UVpBSmFpQUVRWUNBZ0FGUERRRWFJQVJCRUhaQkFYUkJrQXBxREFFTElBSkJBMDBFUUNBRVFYOU1CRUJCQWtHaUVDQUVRWUNBZ0lBRWNSc2hCUXdEQ3lBRVFSbDJRZjRBY1VIUUNtb2dCRUdBZ0lDQUFVOE5BUm9nQkVFV2RrSCtCM0ZCa0F0cUlBUkJnSUNBRUU4TkFSb2dCRUVSZGtIKy93RnhRZEFMYWd3QkN5QUNRUWROQkVBZ0JFRWFkaUlDUVhocVFUaEpCRUFnQWtFQmRFSFFEV29NQWdzZ0JFRVZka0grRDNGQjBBNXFEQUVMSUFSQkdYWkIvZ0J4UWRBUWFpQUNRUkJORFFBYUlBUkJIWFlpQWdSQUlBSkJBWFJCMEJGcURBRUxJQVJCRjNaQi9nTnhRZUFSYWdzdkFRQWlCUTBBUVFFaEN3d0JDMEVCSVFzZ0JVRUxkaUlKSUFOTERRQkJJQ0FGUVI5eElnWnJJUUlDUUNBSlJRUkFEQUVMSUFRZ0JuUWhCQUpBSUFWQkJYWkJQM0VpREVVRVFBd0JDeUFDSUF4SkJFQWdBQ0FHRUF0QmYwWU5BeUFBRUE4aEJFRWdJUUlMSUFRZ0RIUWhCa0VCSUF4QmYycDBJUWNnQkVFZ0lBeHJkaUVFQTBBZ0NrRkFheUFJUVFKMGFrRi9RUUVnQkNBSGNSczJBZ0FnQ0VFQmFpRUlJQWRCQVhZaUJ3MEFDeUFDSUF4cklRSWdCaUVFQ3lBSUlBbEpCRUFnREVFRFNTSVBJQVZCLzY4QlMzRWhCUU5BSUFKQkQwMEVRQ0FBUVNBZ0Ftc1FDMEYvUmdSQURBVUxJQUFRRHlFRVFTQWhBZ3RCQUNFR0FrQUNRQUovQWtBZ0JFRUFTQTBBUVFFaEJpQUVRZi8vLy84RFN3MEFRUUloQmlBRVFmLy8vLzhCU3cwQVFRTWhCaUFFUWYvLy8vOEFTdzBBUVFRaEJpQUVRZi8vL3o5TERRQkJCU0VHSUFSQi8vLy9IMHNOQUVFR0lRWWdCRUgvLy84UFN3MEFRUWNoQmlBRVFmLy8vd2RMRFFCQkNDRUdJQVJCLy8vL0Ewc05BRUVKSVFZZ0JFSC8vLzhCU3cwQVFRb2hCaUFFUWYvLy93QkxEUUJCQ3lFR0lBUkIvLzgvU3cwQVFRd2hCaUFFUWYvL0gwc05BRUVOSVFZZ0JFSC8vdzlMRFFBQ2Z3SkFJQVJCLy84SFRRUkFJQVJCZ0lCOGNVR0FnQVJHRFFFTUNnc2dCVUVFSUFVYklRWWdCRUVQZENFRVFRNGhCeUFDUVhGcURBRUxJQVZCQVNBRkd5RUZJQVJCRUhRaEJFRU1JUVpCRHlFSElBSkJjR29MSVFJZ0J5QUZkQ0VISUFWRkRBRUxJQVlnQlhRaEIwRUJJUTRnQWlBR1FRRnFJZ1pySVFJZ0JDQUdkQ0VFSUFWRkRRRWdCU0VHUVFBTElRNGdBaUFHVHdSL0lBUUZJQUJCSUNBQ2F4QUxRWDlHQkVBTUJ3dEJJQ0VDSUFBUUR3c2hEU0FDSUFacklRSWdEU0FHZENFRUlBMUJJQ0FHYTNZZ0Iyb2hCd3dCQzBFQUlRVUxJQXBCUUdzZ0NFRUNkR3BCQUNBSFFRSnFJQWNnQ0NBTVJoc2dCeUFQR3lJTlFRSnFRUUYySWdacklBWWdEVUVCY1JzMkFnQkJBU0FGSUE0YklnVWdCVUVHU1NBR1FRTWdCVUYvYW5SS2NXb2hCU0FJUVFGcUlnZ2dDVWNOQUFzTFFRQWhCd0pBSUFrZ0EwOEVRRUVBSVFnTUFRc0NRQ0FDUVFoTEJFQWdBaUVGREFFTFFTQWhCU0FBUVNBZ0Ftc1FDMEYvUmcwRElBQVFEeUVFQ3dKQUFrQUNmd0pBSUFOQkJFY0VRQ0FKUVg5cUlnSkJEVXNOQXdKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBSUFKQkFXc09EUUFCQWdNRUJRWUhDQWtLQ3d3T0N5QUVRUnAyUWVBU2Fnd09DeUFFUVJwMlFhQVRhZ3dOQ3lBRVFSdDJRZUFUYWd3TUN5QUVRUnQyUVlBVWFnd0xDeUFFUVJwMlFhQVVhZ3dLQ3lBRVFScDJRZUFVYWd3SkN5QUVRUnAyUWFBVmFnd0lDeUFFUVJwMlFlQVZhZ3dIQ3lBRVFSdDJRYUFXYWd3R0N5QUVRUngyUWNBV2Fnd0ZDeUFFUVJ4MlFkQVdhZ3dFQ3lBRVFSMTJRZUFXYWd3REN5QUVRUjUyUWVnV2Fnd0NDeUFFUVFCSUJFQkJBU0VDREFRTFFSRWhBaUFKUVFOR0RRTkJFaUVDSUFSQi8vLy8vd05MRFFOQklpRUNJQWxCQWtZTkEwRWpRVE1nQkVILy8vLy9BVXNiSVFJTUF3c2dCRUViZGtHZ0Vtb2dCRUVYZGtIQUVtb2dCRUgvLy8vL0FFc2JDeTBBQUNJQ0RRRU1CQXRCRVVFQklBUkJBRWdiSVFJTElBSkJCSFloQ0NBRklBSkJEM0VpQTJzaEFpQUVJQU4wSVFRTElBbEJmMm9pQXdSQUEwQUNmeUFJQkVBZ0FrRUtUUVJBSUFCQklDQUNheEFMUVg5R0JFQU1Cd3NnQUJBUElRUkJJQ0VDQ3dKQUFuOENRQ0FJUVg5cUlnVkJCVTBFUUFKQUFrQUNRQUpBQWtBZ0JVRUJhdzRGQUFFQ0F3UUdDeUFFUVI1MlFlNFdhZ3dHQ3lBRVFSNTJRZklXYWd3RkN5QUVRUjEyUWZZV2Fnd0VDeUFFUVIxMlFmNFdhZ3dEQ3lBRVFSMTJRWVlYYWd3Q0N3Si9RZk1BSUFSQkdYWkI4QUJ4YXlBRVFZQ0FnSUFDVHcwQUdrSDBBQ0FFUWYvLy8vOEFTdzBBR2tHRkFTQUVRZi8vL3o5TERRQWFRWllCSUFSQi8vLy9IMHNOQUJwQnB3RWdCRUgvLy84UFN3MEFHa0c0QVNBRVFmLy8vd2RMRFFBYVFja0JJQVJCLy8vL0Ewc05BQnBCMmdFZ0JFSC8vLzhCU3cwQUdrRUFRZXNCSUFSQmdJQ0FBVWtiQ3lJRlFRUjJJQWhORFFJTUNBc2dCRUVmZGtIc0Ztb0xMUUFBSVFVTElBVkZCRUFNQmdzZ0NpQUhRUUowYWlBRlFRUjJJZ1pCQVdvMkFnQWdBaUFGUVE5eElnVnJJUUlnQkNBRmRDRUVJQWdnQm1zTUFRc2dDaUFIUVFKMGFrRUJOZ0lBUVFBTElRZ2dCMEVCYWlJSElBTkhEUUFMSUFFZ0NFRUNkR29nQ2tGQWF5QURRUUowYWlnQ0FEWUNBQ0FKUVg1cUlRVkJBU0FJZENFSEEwQWdBU0FLSUFVaUEwRUNkQ0lGYWlnQ0FDQUlhaUlJUVFKMGFpQUtRVUJySUFWcUtBSUFOZ0lBSUFOQmYyb2hCVUVCSUFoMElBZHlJUWNnQXcwQUN3d0JDeUFCSUFoQkFuUnFJQXBCUUdzZ0EwRUNkR29vQWdBMkFnQkJBU0FJZENFSEN5QUFRU0FnQW1zUUN3MEFJQWRCRUhRZ0NVRUVkSEloQ3dzZ0NrR0FBV29rQUNBTEM4MHVBUXQvSXdCQkVHc2lDeVFBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FDQUFRZlFCVFFSQVFiVEFBQ2dDQUNJR1FSQWdBRUVMYWtGNGNTQUFRUXRKR3lJRlFRTjJJZ0IySWdGQkEzRUVRQ0FCUVg5elFRRnhJQUJxSWdKQkEzUWlCRUhrd0FCcUtBSUFJZ0ZCQ0dvaEFBSkFJQUVvQWdnaUF5QUVRZHpBQUdvaUJFWUVRRUcwd0FBZ0JrRitJQUozY1RZQ0FBd0JDMEhFd0FBb0FnQWFJQU1nQkRZQ0RDQUVJQU0yQWdnTElBRWdBa0VEZENJQ1FRTnlOZ0lFSUFFZ0Ftb2lBU0FCS0FJRVFRRnlOZ0lFREF3TElBVkJ2TUFBS0FJQUlnaE5EUUVnQVFSQUFrQkJBaUFBZENJQ1FRQWdBbXR5SUFFZ0FIUnhJZ0JCQUNBQWEzRkJmMm9pQUNBQVFReDJRUkJ4SWdCMklnRkJCWFpCQ0hFaUFpQUFjaUFCSUFKMklnQkJBblpCQkhFaUFYSWdBQ0FCZGlJQVFRRjJRUUp4SWdGeUlBQWdBWFlpQUVFQmRrRUJjU0lCY2lBQUlBRjJhaUlDUVFOMElnTkI1TUFBYWlnQ0FDSUJLQUlJSWdBZ0EwSGN3QUJxSWdOR0JFQkJ0TUFBSUFaQmZpQUNkM0VpQmpZQ0FBd0JDMEhFd0FBb0FnQWFJQUFnQXpZQ0RDQURJQUEyQWdnTElBRkJDR29oQUNBQklBVkJBM0kyQWdRZ0FTQUZhaUlISUFKQkEzUWlBaUFGYXlJRFFRRnlOZ0lFSUFFZ0Ftb2dBellDQUNBSUJFQWdDRUVEZGlJRVFRTjBRZHpBQUdvaEFVSEl3QUFvQWdBaEFnSi9JQVpCQVNBRWRDSUVjVVVFUUVHMHdBQWdCQ0FHY2pZQ0FDQUJEQUVMSUFFb0FnZ0xJUVFnQVNBQ05nSUlJQVFnQWpZQ0RDQUNJQUUyQWd3Z0FpQUVOZ0lJQzBISXdBQWdCellDQUVHOHdBQWdBellDQUF3TUMwRzR3QUFvQWdBaUNrVU5BU0FLUVFBZ0NtdHhRWDlxSWdBZ0FFRU1ka0VRY1NJQWRpSUJRUVYyUVFoeElnSWdBSElnQVNBQ2RpSUFRUUoyUVFSeElnRnlJQUFnQVhZaUFFRUJka0VDY1NJQmNpQUFJQUYySWdCQkFYWkJBWEVpQVhJZ0FDQUJkbXBCQW5SQjVNSUFhaWdDQUNJQktBSUVRWGh4SUFWcklRTWdBU0VDQTBBQ1FDQUNLQUlRSWdCRkJFQWdBaWdDRkNJQVJRMEJDeUFBS0FJRVFYaHhJQVZySWdJZ0F5QUNJQU5KSWdJYklRTWdBQ0FCSUFJYklRRWdBQ0VDREFFTEN5QUJLQUlZSVFrZ0FTQUJLQUlNSWdSSEJFQkJ4TUFBS0FJQUlBRW9BZ2dpQUUwRVFDQUFLQUlNR2dzZ0FDQUVOZ0lNSUFRZ0FEWUNDQXdMQ3lBQlFSUnFJZ0lvQWdBaUFFVUVRQ0FCS0FJUUlnQkZEUU1nQVVFUWFpRUNDd05BSUFJaEJ5QUFJZ1JCRkdvaUFpZ0NBQ0lBRFFBZ0JFRVFhaUVDSUFRb0FoQWlBQTBBQ3lBSFFRQTJBZ0FNQ2d0QmZ5RUZJQUJCdjM5TERRQWdBRUVMYWlJQVFYaHhJUVZCdU1BQUtBSUFJZ2RGRFFCQkFDQUZheUVDQWtBQ1FBSkFBbjlCQUNBQVFRaDJJZ0JGRFFBYVFSOGdCVUgvLy84SFN3MEFHaUFBSUFCQmdQNC9ha0VRZGtFSWNTSUFkQ0lCSUFGQmdPQWZha0VRZGtFRWNTSUJkQ0lESUFOQmdJQVBha0VRZGtFQ2NTSURkRUVQZGlBQUlBRnlJQU55YXlJQVFRRjBJQVVnQUVFVmFuWkJBWEZ5UVJ4cUN5SUlRUUowUWVUQ0FHb29BZ0FpQTBVRVFFRUFJUUFNQVFzZ0JVRUFRUmtnQ0VFQmRtc2dDRUVmUmh0MElRRkJBQ0VBQTBBQ1FDQURLQUlFUVhoeElBVnJJZ1lnQWs4TkFDQURJUVFnQmlJQ0RRQkJBQ0VDSUFNaEFBd0RDeUFBSUFNb0FoUWlCaUFHSUFNZ0FVRWRka0VFY1dvb0FoQWlBMFliSUFBZ0Joc2hBQ0FCSUFOQkFFZDBJUUVnQXcwQUN3c2dBQ0FFY2tVRVFFRUNJQWgwSWdCQkFDQUFhM0lnQjNFaUFFVU5BeUFBUVFBZ0FHdHhRWDlxSWdBZ0FFRU1ka0VRY1NJQWRpSUJRUVYyUVFoeElnTWdBSElnQVNBRGRpSUFRUUoyUVFSeElnRnlJQUFnQVhZaUFFRUJka0VDY1NJQmNpQUFJQUYySWdCQkFYWkJBWEVpQVhJZ0FDQUJkbXBCQW5SQjVNSUFhaWdDQUNFQUN5QUFSUTBCQ3dOQUlBQW9BZ1JCZUhFZ0JXc2lBeUFDU1NFQklBTWdBaUFCR3lFQ0lBQWdCQ0FCR3lFRUlBQW9BaEFpQVFSL0lBRUZJQUFvQWhRTElnQU5BQXNMSUFSRkRRQWdBa0c4d0FBb0FnQWdCV3RQRFFBZ0JDZ0NHQ0VJSUFRZ0JDZ0NEQ0lCUndSQVFjVEFBQ2dDQUNBRUtBSUlJZ0JOQkVBZ0FDZ0NEQm9MSUFBZ0FUWUNEQ0FCSUFBMkFnZ01DUXNnQkVFVWFpSURLQUlBSWdCRkJFQWdCQ2dDRUNJQVJRMERJQVJCRUdvaEF3c0RRQ0FESVFZZ0FDSUJRUlJxSWdNb0FnQWlBQTBBSUFGQkVHb2hBeUFCS0FJUUlnQU5BQXNnQmtFQU5nSUFEQWdMUWJ6QUFDZ0NBQ0lCSUFWUEJFQkJ5TUFBS0FJQUlRQUNRQ0FCSUFWcklnSkJFRThFUUVHOHdBQWdBallDQUVISXdBQWdBQ0FGYWlJRE5nSUFJQU1nQWtFQmNqWUNCQ0FBSUFGcUlBSTJBZ0FnQUNBRlFRTnlOZ0lFREFFTFFjakFBRUVBTmdJQVFiekFBRUVBTmdJQUlBQWdBVUVEY2pZQ0JDQUFJQUZxSWdFZ0FTZ0NCRUVCY2pZQ0JBc2dBRUVJYWlFQURBb0xRY0RBQUNnQ0FDSUJJQVZMQkVCQndNQUFJQUVnQldzaUFUWUNBRUhNd0FCQnpNQUFLQUlBSWdBZ0JXb2lBallDQUNBQ0lBRkJBWEkyQWdRZ0FDQUZRUU55TmdJRUlBQkJDR29oQUF3S0MwRUFJUUFnQlVFdmFpSUVBbjlCak1RQUtBSUFCRUJCbE1RQUtBSUFEQUVMUVpqRUFFSi9Od0lBUVpERUFFS0FvSUNBZ0lBRU53SUFRWXpFQUNBTFFReHFRWEJ4UWRpcTFhb0ZjellDQUVHZ3hBQkJBRFlDQUVId3d3QkJBRFlDQUVHQUlBc2lBbW9pQmtFQUlBSnJJZ2R4SWdJZ0JVME5DVUhzd3dBb0FnQWlBd1JBUWVUREFDZ0NBQ0lJSUFKcUlna2dDRTBOQ2lBSklBTkxEUW9MUWZEREFDMEFBRUVFY1EwRUFrQUNRRUhNd0FBb0FnQWlBd1JBUWZUREFDRUFBMEFnQUNnQ0FDSUlJQU5OQkVBZ0NDQUFLQUlFYWlBRFN3MERDeUFBS0FJSUlnQU5BQXNMUVFBUUV5SUJRWDlHRFFVZ0FpRUdRWkRFQUNnQ0FDSUFRWDlxSWdNZ0FYRUVRQ0FDSUFGcklBRWdBMnBCQUNBQWEzRnFJUVlMSUFZZ0JVME5CU0FHUWY3Ly8vOEhTdzBGUWV6REFDZ0NBQ0lBQkVCQjVNTUFLQUlBSWdNZ0Jtb2lCeUFEVFEwR0lBY2dBRXNOQmdzZ0JoQVRJZ0FnQVVjTkFRd0hDeUFHSUFGcklBZHhJZ1pCL3YvLy93ZExEUVFnQmhBVElnRWdBQ2dDQUNBQUtBSUVha1lOQXlBQklRQUxBa0FnQlVFd2FpQUdUUTBBSUFCQmYwWU5BRUdVeEFBb0FnQWlBU0FFSUFacmFrRUFJQUZyY1NJQlFmNy8vLzhIU3dSQUlBQWhBUXdIQ3lBQkVCTkJmMGNFUUNBQklBWnFJUVlnQUNFQkRBY0xRUUFnQm1zUUV4b01CQXNnQUNJQlFYOUhEUVVNQXd0QkFDRUVEQWNMUVFBaEFRd0ZDeUFCUVg5SERRSUxRZkREQUVId3d3QW9BZ0JCQkhJMkFnQUxJQUpCL3YvLy93ZExEUUVnQWhBVElnRkJBQkFUSWdCUERRRWdBVUYvUmcwQklBQkJmMFlOQVNBQUlBRnJJZ1lnQlVFb2FrME5BUXRCNU1NQVFlVERBQ2dDQUNBR2FpSUFOZ0lBSUFCQjZNTUFLQUlBU3dSQVFlakRBQ0FBTmdJQUN3SkFBa0FDUUVITXdBQW9BZ0FpQXdSQVFmVERBQ0VBQTBBZ0FTQUFLQUlBSWdJZ0FDZ0NCQ0lFYWtZTkFpQUFLQUlJSWdBTkFBc01BZ3RCeE1BQUtBSUFJZ0JCQUNBQklBQlBHMFVFUUVIRXdBQWdBVFlDQUF0QkFDRUFRZmpEQUNBR05nSUFRZlREQUNBQk5nSUFRZFRBQUVGL05nSUFRZGpBQUVHTXhBQW9BZ0EyQWdCQmdNUUFRUUEyQWdBRFFDQUFRUU4wSWdKQjVNQUFhaUFDUWR6QUFHb2lBellDQUNBQ1FlakFBR29nQXpZQ0FDQUFRUUZxSWdCQklFY05BQXRCd01BQUlBWkJXR29pQUVGNElBRnJRUWR4UVFBZ0FVRUlha0VIY1JzaUFtc2lBellDQUVITXdBQWdBU0FDYWlJQ05nSUFJQUlnQTBFQmNqWUNCQ0FBSUFGcVFTZzJBZ1JCME1BQVFaekVBQ2dDQURZQ0FBd0NDeUFBTFFBTVFRaHhEUUFnQVNBRFRRMEFJQUlnQTBzTkFDQUFJQVFnQm1vMkFnUkJ6TUFBSUFOQmVDQURhMEVIY1VFQUlBTkJDR3BCQjNFYklnQnFJZ0UyQWdCQndNQUFRY0RBQUNnQ0FDQUdhaUlDSUFCcklnQTJBZ0FnQVNBQVFRRnlOZ0lFSUFJZ0EycEJLRFlDQkVIUXdBQkJuTVFBS0FJQU5nSUFEQUVMSUFGQnhNQUFLQUlBSWdSSkJFQkJ4TUFBSUFFMkFnQWdBU0VFQ3lBQklBWnFJUUpCOU1NQUlRQUNRQUpBQWtBQ1FBSkFBa0FEUUNBQ0lBQW9BZ0JIQkVBZ0FDZ0NDQ0lBRFFFTUFnc0xJQUF0QUF4QkNIRkZEUUVMUWZUREFDRUFBMEFnQUNnQ0FDSUNJQU5OQkVBZ0FpQUFLQUlFYWlJRUlBTkxEUU1MSUFBb0FnZ2hBQXdBQUFzQUN5QUFJQUUyQWdBZ0FDQUFLQUlFSUFacU5nSUVJQUZCZUNBQmEwRUhjVUVBSUFGQkNHcEJCM0ViYWlJSklBVkJBM0kyQWdRZ0FrRjRJQUpyUVFkeFFRQWdBa0VJYWtFSGNSdHFJZ0VnQ1dzZ0JXc2hBQ0FGSUFscUlRY2dBU0FEUmdSQVFjekFBQ0FITmdJQVFjREFBRUhBd0FBb0FnQWdBR29pQURZQ0FDQUhJQUJCQVhJMkFnUU1Bd3NnQVVISXdBQW9BZ0JHQkVCQnlNQUFJQWMyQWdCQnZNQUFRYnpBQUNnQ0FDQUFhaUlBTmdJQUlBY2dBRUVCY2pZQ0JDQUFJQWRxSUFBMkFnQU1Bd3NnQVNnQ0JDSUNRUU54UVFGR0JFQWdBa0Y0Y1NFS0FrQWdBa0gvQVUwRVFDQUJLQUlJSWdNZ0FrRURkaUlFUVFOMFFkekFBR3BIR2lBRElBRW9BZ3dpQWtZRVFFRzB3QUJCdE1BQUtBSUFRWDRnQkhkeE5nSUFEQUlMSUFNZ0FqWUNEQ0FDSUFNMkFnZ01BUXNnQVNnQ0dDRUlBa0FnQVNBQktBSU1JZ1pIQkVBZ0JDQUJLQUlJSWdKTkJFQWdBaWdDREJvTElBSWdCallDRENBR0lBSTJBZ2dNQVFzQ1FDQUJRUlJxSWdNb0FnQWlCUTBBSUFGQkVHb2lBeWdDQUNJRkRRQkJBQ0VHREFFTEEwQWdBeUVDSUFVaUJrRVVhaUlES0FJQUlnVU5BQ0FHUVJCcUlRTWdCaWdDRUNJRkRRQUxJQUpCQURZQ0FBc2dDRVVOQUFKQUlBRWdBU2dDSENJQ1FRSjBRZVRDQUdvaUF5Z0NBRVlFUUNBRElBWTJBZ0FnQmcwQlFiakFBRUc0d0FBb0FnQkJmaUFDZDNFMkFnQU1BZ3NnQ0VFUVFSUWdDQ2dDRUNBQlJodHFJQVkyQWdBZ0JrVU5BUXNnQmlBSU5nSVlJQUVvQWhBaUFnUkFJQVlnQWpZQ0VDQUNJQVkyQWhnTElBRW9BaFFpQWtVTkFDQUdJQUkyQWhRZ0FpQUdOZ0lZQ3lBQklBcHFJUUVnQUNBS2FpRUFDeUFCSUFFb0FnUkJmbkUyQWdRZ0J5QUFRUUZ5TmdJRUlBQWdCMm9nQURZQ0FDQUFRZjhCVFFSQUlBQkJBM1lpQVVFRGRFSGN3QUJxSVFBQ2YwRzB3QUFvQWdBaUFrRUJJQUYwSWdGeFJRUkFRYlRBQUNBQklBSnlOZ0lBSUFBTUFRc2dBQ2dDQ0FzaEFTQUFJQWMyQWdnZ0FTQUhOZ0lNSUFjZ0FEWUNEQ0FISUFFMkFnZ01Bd3NnQndKL1FRQWdBRUVJZGlJQlJRMEFHa0VmSUFCQi8vLy9CMHNOQUJvZ0FTQUJRWUQrUDJwQkVIWkJDSEVpQVhRaUFpQUNRWURnSDJwQkVIWkJCSEVpQW5RaUF5QURRWUNBRDJwQkVIWkJBbkVpQTNSQkQzWWdBU0FDY2lBRGNtc2lBVUVCZENBQUlBRkJGV3AyUVFGeGNrRWNhZ3NpQVRZQ0hDQUhRZ0EzQWhBZ0FVRUNkRUhrd2dCcUlRSUNRRUc0d0FBb0FnQWlBMEVCSUFGMElnUnhSUVJBUWJqQUFDQURJQVJ5TmdJQUlBSWdCellDQUF3QkN5QUFRUUJCR1NBQlFRRjJheUFCUVI5R0czUWhBeUFDS0FJQUlRRURRQ0FCSWdJb0FnUkJlSEVnQUVZTkF5QURRUjEySVFFZ0EwRUJkQ0VESUFJZ0FVRUVjV29pQkNnQ0VDSUJEUUFMSUFRZ0J6WUNFQXNnQnlBQ05nSVlJQWNnQnpZQ0RDQUhJQWMyQWdnTUFndEJ3TUFBSUFaQldHb2lBRUY0SUFGclFRZHhRUUFnQVVFSWFrRUhjUnNpQW1zaUJ6WUNBRUhNd0FBZ0FTQUNhaUlDTmdJQUlBSWdCMEVCY2pZQ0JDQUFJQUZxUVNnMkFnUkIwTUFBUVp6RUFDZ0NBRFlDQUNBRElBUkJKeUFFYTBFSGNVRUFJQVJCV1dwQkIzRWJha0ZSYWlJQUlBQWdBMEVRYWtrYklnSkJHellDQkNBQ1FmekRBQ2tDQURjQ0VDQUNRZlREQUNrQ0FEY0NDRUg4d3dBZ0FrRUlhallDQUVINHd3QWdCallDQUVIMHd3QWdBVFlDQUVHQXhBQkJBRFlDQUNBQ1FSaHFJUUFEUUNBQVFRYzJBZ1FnQUVFSWFpRUJJQUJCQkdvaEFDQUVJQUZMRFFBTElBSWdBMFlOQXlBQ0lBSW9BZ1JCZm5FMkFnUWdBeUFDSUFOcklnUkJBWEkyQWdRZ0FpQUVOZ0lBSUFSQi93Rk5CRUFnQkVFRGRpSUJRUU4wUWR6QUFHb2hBQUovUWJUQUFDZ0NBQ0lDUVFFZ0FYUWlBWEZGQkVCQnRNQUFJQUVnQW5JMkFnQWdBQXdCQ3lBQUtBSUlDeUVCSUFBZ0F6WUNDQ0FCSUFNMkFnd2dBeUFBTmdJTUlBTWdBVFlDQ0F3RUN5QURRZ0EzQWhBZ0F3Si9RUUFnQkVFSWRpSUFSUTBBR2tFZklBUkIvLy8vQjBzTkFCb2dBQ0FBUVlEK1AycEJFSFpCQ0hFaUFIUWlBU0FCUVlEZ0gycEJFSFpCQkhFaUFYUWlBaUFDUVlDQUQycEJFSFpCQW5FaUFuUkJEM1lnQUNBQmNpQUNjbXNpQUVFQmRDQUVJQUJCRldwMlFRRnhja0VjYWdzaUFEWUNIQ0FBUVFKMFFlVENBR29oQVFKQVFiakFBQ2dDQUNJQ1FRRWdBSFFpQm5GRkJFQkJ1TUFBSUFJZ0JuSTJBZ0FnQVNBRE5nSUFJQU1nQVRZQ0dBd0JDeUFFUVFCQkdTQUFRUUYyYXlBQVFSOUdHM1FoQUNBQktBSUFJUUVEUUNBQklnSW9BZ1JCZUhFZ0JFWU5CQ0FBUVIxMklRRWdBRUVCZENFQUlBSWdBVUVFY1dvaUJpZ0NFQ0lCRFFBTElBWWdBellDRUNBRElBSTJBaGdMSUFNZ0F6WUNEQ0FESUFNMkFnZ01Bd3NnQWlnQ0NDSUFJQWMyQWd3Z0FpQUhOZ0lJSUFkQkFEWUNHQ0FISUFJMkFnd2dCeUFBTmdJSUN5QUpRUWhxSVFBTUJRc2dBaWdDQ0NJQUlBTTJBZ3dnQWlBRE5nSUlJQU5CQURZQ0dDQURJQUkyQWd3Z0F5QUFOZ0lJQzBIQXdBQW9BZ0FpQUNBRlRRMEFRY0RBQUNBQUlBVnJJZ0UyQWdCQnpNQUFRY3pBQUNnQ0FDSUFJQVZxSWdJMkFnQWdBaUFCUVFGeU5nSUVJQUFnQlVFRGNqWUNCQ0FBUVFocUlRQU1Bd3RCc01BQVFUQTJBZ0JCQUNFQURBSUxBa0FnQ0VVTkFBSkFJQVFvQWh3aUFFRUNkRUhrd2dCcUlnTW9BZ0FnQkVZRVFDQURJQUUyQWdBZ0FRMEJRYmpBQUNBSFFYNGdBSGR4SWdjMkFnQU1BZ3NnQ0VFUVFSUWdDQ2dDRUNBRVJodHFJQUUyQWdBZ0FVVU5BUXNnQVNBSU5nSVlJQVFvQWhBaUFBUkFJQUVnQURZQ0VDQUFJQUUyQWhnTElBUW9BaFFpQUVVTkFDQUJJQUEyQWhRZ0FDQUJOZ0lZQ3dKQUlBSkJEMDBFUUNBRUlBSWdCV29pQUVFRGNqWUNCQ0FBSUFScUlnQWdBQ2dDQkVFQmNqWUNCQXdCQ3lBRUlBVkJBM0kyQWdRZ0JDQUZhaUlESUFKQkFYSTJBZ1FnQWlBRGFpQUNOZ0lBSUFKQi93Rk5CRUFnQWtFRGRpSUJRUU4wUWR6QUFHb2hBQUovUWJUQUFDZ0NBQ0lDUVFFZ0FYUWlBWEZGQkVCQnRNQUFJQUVnQW5JMkFnQWdBQXdCQ3lBQUtBSUlDeUVCSUFBZ0F6WUNDQ0FCSUFNMkFnd2dBeUFBTmdJTUlBTWdBVFlDQ0F3QkN5QURBbjlCQUNBQ1FRaDJJZ0JGRFFBYVFSOGdBa0gvLy84SFN3MEFHaUFBSUFCQmdQNC9ha0VRZGtFSWNTSUFkQ0lCSUFGQmdPQWZha0VRZGtFRWNTSUJkQ0lGSUFWQmdJQVBha0VRZGtFQ2NTSUZkRUVQZGlBQUlBRnlJQVZ5YXlJQVFRRjBJQUlnQUVFVmFuWkJBWEZ5UVJ4cUN5SUFOZ0ljSUFOQ0FEY0NFQ0FBUVFKMFFlVENBR29oQVFKQUFrQWdCMEVCSUFCMElnVnhSUVJBUWJqQUFDQUZJQWR5TmdJQUlBRWdBellDQUF3QkN5QUNRUUJCR1NBQVFRRjJheUFBUVI5R0czUWhBQ0FCS0FJQUlRVURRQ0FGSWdFb0FnUkJlSEVnQWtZTkFpQUFRUjEySVFVZ0FFRUJkQ0VBSUFFZ0JVRUVjV29pQmlnQ0VDSUZEUUFMSUFZZ0F6WUNFQXNnQXlBQk5nSVlJQU1nQXpZQ0RDQURJQU0yQWdnTUFRc2dBU2dDQ0NJQUlBTTJBZ3dnQVNBRE5nSUlJQU5CQURZQ0dDQURJQUUyQWd3Z0F5QUFOZ0lJQ3lBRVFRaHFJUUFNQVFzQ1FDQUpSUTBBQWtBZ0FTZ0NIQ0lBUVFKMFFlVENBR29pQWlnQ0FDQUJSZ1JBSUFJZ0JEWUNBQ0FFRFFGQnVNQUFJQXBCZmlBQWQzRTJBZ0FNQWdzZ0NVRVFRUlFnQ1NnQ0VDQUJSaHRxSUFRMkFnQWdCRVVOQVFzZ0JDQUpOZ0lZSUFFb0FoQWlBQVJBSUFRZ0FEWUNFQ0FBSUFRMkFoZ0xJQUVvQWhRaUFFVU5BQ0FFSUFBMkFoUWdBQ0FFTmdJWUN3SkFJQU5CRDAwRVFDQUJJQU1nQldvaUFFRURjallDQkNBQUlBRnFJZ0FnQUNnQ0JFRUJjallDQkF3QkN5QUJJQVZCQTNJMkFnUWdBU0FGYWlJRUlBTkJBWEkyQWdRZ0F5QUVhaUFETmdJQUlBZ0VRQ0FJUVFOMklnVkJBM1JCM01BQWFpRUFRY2pBQUNnQ0FDRUNBbjlCQVNBRmRDSUZJQVp4UlFSQVFiVEFBQ0FGSUFaeU5nSUFJQUFNQVFzZ0FDZ0NDQXNoQlNBQUlBSTJBZ2dnQlNBQ05nSU1JQUlnQURZQ0RDQUNJQVUyQWdnTFFjakFBQ0FFTmdJQVFiekFBQ0FETmdJQUN5QUJRUWhxSVFBTElBdEJFR29rQUNBQUMwUUJBWDhnQUNBQUtBSVFJQUZxSWdFMkFoQWdBQ0FCUVFkeE5nSUlRWDhoQWlBQklBQW9BZ3hCQTNSTkJIOGdBQ0FBS0FJQUlBRkJBM1pxTmdJRVFRQUZRWDhMQytVSEFRaC9JQUFnQkVFQUlBWnJJQUlnQWlBR2FrRUFTQnNpQWlBQ0lBUktHeUlDYWlBQUlBSkJBRW9iSWdrZ0JVRUFJQWRySUFNZ0F5QUhha0VBU0JzaUFDQUFJQVZLR3lJQUlBUnNhaUFKSUFCQkFFb2JJUU1nQjBFQUlBQnJJQUJCSDNWeElnbHJJQUFnQjJvaUFDQUZheUlNUVFBZ0FDQUZTaHNpRDJzaEN5QUdRUUFnQW1zaURpQUNRUjkxY1NJTmF5QUNJQVpxSWdBZ0JHdEJBQ0FBSUFSS0lnVWJJZ3BySVFBQ1FDQUNRUUJJSUFWeUloQkZCRUFnQ1FSQUEwQWdBU0FESUFBUUZTQUlhaUVCSUFsQmYyb2lDUTBBQ3dzZ0MwVU5BUU5BSUFFZ0F5QUFFQlVnQ0dvaEFTQURJQVJxSVFNZ0MwRi9haUlMRFFBTERBRUxBa0FnQ1VVTkFDQU5SUVJBQTBBZ0FDRUhJQUVoQWlBRElRVWdBQVJBQTBBZ0FpQUZMUUFBT2dBQUlBSkJBV29oQWlBRlFRRnFJUVVnQjBGL2FpSUhEUUFMQ3lBS0JFQWdBaUFGUVg5cUxRQUFJQW9RQnhvTElBRWdDR29oQVNBSlFYOXFJZ2tOQUF3Q0FBc0FDeUFCSUE1cUlRWURRQ0FCSUFNdEFBQWdEUkFISVFFZ0FDRUhJQVloQWlBRElRVWdBQVJBQTBBZ0FpQUZMUUFBT2dBQUlBSkJBV29oQWlBRlFRRnFJUVVnQjBGL2FpSUhEUUFMQ3lBS0JFQWdBaUFGUVg5cUxRQUFJQW9RQnhvTElBWWdDR29oQmlBQklBaHFJUUVnQ1VGL2FpSUpEUUFMQ3lBTFJRMEFJQTFGQkVBRFFDQUFJUWNnQVNFQ0lBTWhCU0FBQkVBRFFDQUNJQVV0QUFBNkFBQWdBa0VCYWlFQ0lBVkJBV29oQlNBSFFYOXFJZ2NOQUFzTElBb0VRQ0FDSUFWQmYyb3RBQUFnQ2hBSEdnc2dBU0FJYWlFQklBTWdCR29oQXlBTFFYOXFJZ3NOQUF3Q0FBc0FDeUFCSUE1cUlRa0RRQ0FCSUFNdEFBQWdEUkFISVFFZ0FDRUhJQWtoQWlBRElRVWdBQVJBQTBBZ0FpQUZMUUFBT2dBQUlBSkJBV29oQWlBRlFRRnFJUVVnQjBGL2FpSUhEUUFMQ3lBS0JFQWdBaUFGUVg5cUxRQUFJQW9RQnhvTElBZ2dDV29oQ1NBQklBaHFJUUVnQXlBRWFpRURJQXRCZjJvaUN3MEFDd3NDUUNBUFJRMEFJQU1nQkdzaEF5QVFSUVJBQTBBZ0FTQURJQUFRRlNBSWFpRUJJQXhCZjJvaURBMEFEQUlBQ3dBTElBMUZCRUFEUUNBRElRSWdBU0VGSUFBaEJ5QUFCRUFEUUNBRklBSXRBQUE2QUFBZ0JVRUJhaUVGSUFKQkFXb2hBaUFIUVg5cUlnY05BQXNMSUFvRVFDQUZJQUpCZjJvdEFBQWdDaEFIR2dzZ0FTQUlhaUVCSUF4QmYyb2lEQTBBREFJQUN3QUxJQUVnRG1vaENRTkFJQUVnQXkwQUFDQU5FQWNoQVNBQUlRY2dDU0VDSUFNaEJTQUFCRUFEUUNBQ0lBVXRBQUE2QUFBZ0FrRUJhaUVDSUFWQkFXb2hCU0FIUVg5cUlnY05BQXNMSUFvRVFDQUNJQVZCZjJvdEFBQWdDaEFIR2dzZ0NDQUphaUVKSUFFZ0NHb2hBU0FNUVg5cUlnd05BQXNMQy9RQ0FRTi9JQUZCQTNSQjhEWnFJZ01vQWdBaEJTQURMUUFFSVFNZ0FVRURkRUd3TldvaUFTMEFCQ0VFQWtBZ0FTZ0NBRUVFUmdSQUlBSWdCRUVCZEdvdUFRQWhBU0FGUVFSR0JFQWdBU0FDSUFOQkFYUnFMZ0VBYWtFQmFrRUJkUThMQW44Z0FDZ0N6QUVpQWdSQUlBQW9BZ1FnQWlnQ0JFWU1BUXRCQUF0RkRRRWdBU0FBS0FMTUFTQURRUUYwYWk0QkhHcEJBV3BCQVhVUEN5QUZRUVJHQkVBZ0FpQURRUUYwYWk0QkFDRUJBbjhnQUNnQ3lBRWlBZ1JBSUFBb0FnUWdBaWdDQkVZTUFRdEJBQXRGRFFFZ0FTQUFLQUxJQVNBRVFRRjBhaTRCSEdwQkFXcEJBWFVQQ3dKL0FuOGdBQ2dDeUFFaUFRUkFJQUFvQWdRZ0FTZ0NCRVlNQVF0QkFBdEZCRUJCQUNFQ1FRQU1BUXRCQVNFQ0lBQW9Bc2dCSUFSQkFYUnFMZ0VjQ3lFQkFuOGdBQ2dDekFFaUJBUkFJQUFvQWdRZ0JDZ0NCRVlNQVF0QkFBdEZEUUFnQUNnQ3pBRWdBMEVCZEdvdUFSd2hBQ0FDUlFSQUlBQVBDeUFBSUFGcVFRRnFRUUYxSVFFTElBRUxpUWNCQjM4Z0F5QUZhaUlOSUFFdUFRQWlERUVDZFdvaEF5QUVJQVpxSWc0Z0FTNEJBaUlQUVFKMWFpRUVJQUlvQWdoQkJIUWhDU0FDS0FJRVFRUjBJUW9nQUNBR1FRUjBhaUFGYWlFTEFrQWdERUVEY1VFRWRDQVBRUU54UVFKMGNrSFFPMm9vQWdBaURFRU9UUVJBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUlBeEJBV3NPRGdFQ0F3UUZCZ2NJQ1FvTERBME9BQXNnQWlnQ0FDQUxJQU1nQkNBS0lBa2dCeUFJUVJBUURBd1BDeUFDS0FJQUlBc2dBeUFFUVg1cUlBb2dDU0FISUFoQkFCQWtEQTRMSUFJb0FnQWdDeUFESUFSQmZtb2dDaUFKSUFjZ0NCQkhEQTBMSUFJb0FnQWdDeUFESUFSQmZtb2dDaUFKSUFjZ0NFRUJFQ1FNREFzZ0FpZ0NBQ0FMSUFOQmZtb2dCQ0FLSUFrZ0J5QUlRUUFRSXd3TEN5QUNLQUlBSUFzZ0EwRithaUFFUVg1cUlBb2dDU0FISUFoQkFCQWFEQW9MSUFJb0FnQWdDeUFEUVg1cUlBUkJmbW9nQ2lBSklBY2dDRUVBRUNFTUNRc2dBaWdDQUNBTElBTkJmbW9nQkVGK2FpQUtJQWtnQnlBSVFRSVFHZ3dJQ3lBQ0tBSUFJQXNnQTBGK2FpQUVJQW9nQ1NBSElBZ1FSZ3dIQ3lBQ0tBSUFJQXNnQTBGK2FpQUVRWDVxSUFvZ0NTQUhJQWhCQUJBaURBWUxJQUlvQWdBZ0N5QURRWDVxSUFSQmZtb2dDaUFKSUFjZ0NCQkZEQVVMSUFJb0FnQWdDeUFEUVg1cUlBUkJmbW9nQ2lBSklBY2dDRUVCRUNJTUJBc2dBaWdDQUNBTElBTkJmbW9nQkNBS0lBa2dCeUFJUVFFUUl3d0RDeUFDS0FJQUlBc2dBMEYrYWlBRVFYNXFJQW9nQ1NBSElBaEJBUkFhREFJTElBSW9BZ0FnQ3lBRFFYNXFJQVJCZm1vZ0NpQUpJQWNnQ0VFQkVDRU1BUXNnQWlnQ0FDQUxJQU5CZm1vZ0JFRithaUFLSUFrZ0J5QUlRUU1RR2dzZ0RVRUJkaUFCTGdFQUlnbEJBM1ZxSVFNZ0RrRUJkaUFCTGdFQ0lnRkJBM1ZxSVFRZ0FpZ0NBQ0FDS0FJRUlnb2dBaWdDQ0NJTGJFRUlkR29oQWlBQUlBWkJBblJCZUhGcUlBVkJBWFpxUVlBQ2FpRUZJQWhCQVhZaEJpQUhRUUYySVFjZ0FVRUhjU0VJSUF0QkEzUWhBQ0FLUVFOMElRRUNRQ0FKUVFkeElnbEZEUUFnQ0VVTkFDQUNJQVVnQXlBRUlBRWdBQ0FKSUFnZ0J5QUdFRWdQQ3lBSkJFQWdBaUFGSUFNZ0JDQUJJQUFnQ1NBSElBWVFTdzhMSUFnRVFDQUNJQVVnQXlBRUlBRWdBQ0FJSUFjZ0JoQktEd3NnQWlBRklBTWdCQ0FCSUFBZ0J5QUdRUWdRRENBQ0lBQWdBV3hxSUFWQlFHc2dBeUFFSUFFZ0FDQUhJQVpCQ0JBTUM4Y0JBUVIvSUFBb0FnUWhBZ0pBSUFBb0FneEJBM1FnQUNnQ0VHc2lBMEVnVGdSQUlBSW9BQUFpQVVFWWRDQUJRUWgwUVlDQS9BZHhjaUFCUVFoMlFZRCtBM0VnQVVFWWRuSnlJUUVnQUNnQ0NDSUFSUTBCSUFFZ0FIUWdBaTBBQkVFSUlBQnJkbklQQ3lBRFFRRklCRUJCQUE4TElBSXRBQUFnQUNnQ0NDSUFRUmhxSWdSMElRRWdBQ0FEYWtGNGFpSUFRUUZJRFFBRFFDQUNMUUFCSUFSQmVHb2lCSFFnQVhJaEFTQUFRUWhLSVFNZ0FrRUJhaUVDSUFCQmVHb2hBQ0FERFFBTEN5QUJDNHdFQVFkL0FrQWdBRUYvYWlJSUxRQUFJZ1VnQUMwQUFDSUdheUlFSUFSQkgzVWlCR29nQkhNZ0FpZ0NCRThOQUNBQVFYNXFMUUFBSWdRZ0JXc2lCeUFIUVI5MUlnZHFJQWR6SUFJb0FnZ2lDVThOQUNBQUxRQUJJZ2NnQm1zaUNpQUtRUjkxSWdwcUlBcHpJQWxQRFFBZ0FVRURUUVJBSUFnZ0JTQUJJQUlvQWdCcVFYOXFMUUFBSWdoQmYzTWlDU0FJUVFGcUlnZ2dCaUFGYTBFQ2RDQUhheUFFYWtFRWFrRURkU0lGSUFVZ0NFb2JJQVVnQ1VnYklnVnFRYkF1YWkwQUFEb0FBQ0FBSUFZZ0JXdEJzQzVxTFFBQU9nQUFEQUVMSUFnZ0JTQUhhaUFFUVFGMGFrRUNha0VDZGpvQUFDQUFJQVlnQjBFQmRHb2dCR3BCQW1wQkFuWTZBQUFMQWtBZ0FDQURhaUlBUVg5cUlnY3RBQUFpQXlBQUxRQUFJZ1ZySWdZZ0JrRWZkU0lHYWlBR2N5QUNLQUlFVHcwQUlBQkJmbW90QUFBaUJpQURheUlFSUFSQkgzVWlCR29nQkhNZ0FpZ0NDQ0lJVHcwQUlBQXRBQUVpQkNBRmF5SUpJQWxCSDNVaUNXb2dDWE1nQ0U4TkFDQUJRUU5OQkVBZ0J5QUJJQUlvQWdCcVFYOXFMUUFBSWdGQmYzTWlBaUFCUVFGcUlnY2dCU0FEYTBFQ2RDQUVheUFHYWtFRWFrRURkU0lCSUFFZ0Iwb2JJQUVnQWtnYklnRWdBMnBCc0M1cUxRQUFPZ0FBSUFBZ0JTQUJhMEd3TG1vdEFBQTZBQUFQQ3lBSElBTWdCR29nQmtFQmRHcEJBbXBCQW5ZNkFBQWdBQ0FGSUFSQkFYUnFJQVpxUVFKcVFRSjJPZ0FBQ3d0SEFBSkFJQUZCQkUwRVFBSkFBa0FDUUFKQUlBRkJBV3NPQkFFQ0F3VUFDeUFBS0FMSUFROExJQUFvQXN3QkR3c2dBQ2dDMEFFUEN5QUFLQUxVQVE4TFFRQWhBQXNnQUF1bEF3RUxmMEVBSUFOcklndEJBWFFoQkNBQklBSW9BZ0JxUVg5cUxRQUFJZ0ZCQVdvaENTQUJRWDl6SVFvQ1FDQUFJQU5ySWdjdEFBQWlCU0FBTFFBQUlnWnJJZ0VnQVVFZmRTSUJhaUFCY3lBQ0tBSUVJZ0ZQRFFBZ0FDQUVhaTBBQUNJTklBVnJJZ2dnQ0VFZmRTSUlhaUFJY3lBQ0tBSUlJZ2hQRFFBZ0FDQURhaTBBQUNJT0lBWnJJZ3dnREVFZmRTSU1haUFNY3lBSVR3MEFJQWNnQ2lBSklBWWdCV3RCQW5RZ0Rtc2dEV3BCQkdwQkEzVWlBU0FCSUFsS0d5QUJJQXBJR3lJQklBVnFRYkF1YWkwQUFEb0FBQ0FBSUFZZ0FXdEJzQzVxTFFBQU9nQUFJQUlvQWdRaEFRc0NRQ0FBUVFGcUlnVWdDMm9pQ3kwQUFDSUdJQUF0QUFFaUFHc2lCeUFIUVI5MUlnZHFJQWR6SUFGUERRQWdCQ0FGYWkwQUFDSUJJQVpySWdRZ0JFRWZkU0lFYWlBRWN5QUNLQUlJSWdKUERRQWdBeUFGYWkwQUFDSURJQUJySWdRZ0JFRWZkU0lFYWlBRWN5QUNUdzBBSUFzZ0NpQUpJQUFnQm10QkFuUWdBMnNnQVdwQkJHcEJBM1VpQVNBQklBbEtHeUFCSUFwSUd5SUJJQVpxUWJBdWFpMEFBRG9BQUNBRklBQWdBV3RCc0M1cUxRQUFPZ0FBQ3d0VkFRSi9RYkRFQUNnQ0FDSUJJQUJCQTJwQmZIRWlBbW9oQUFKQUlBSkJBVTVCQUNBQUlBRk5HdzBBSUFBL0FFRVFkRXNFUUNBQUVBRkZEUUVMUWJERUFDQUFOZ0lBSUFFUEMwR3d3QUJCTURZQ0FFRi9DelFCQVg4Q1FDQUJRUkJMRFFBZ0FDZ0NCQ0FCUVFKMGFpZ0NBQ0lBUlEwQUlBQW9BaFJCQWtrTkFDQUFLQUlBSVFJTElBSUxnZ1FCQTM4Z0FrR0FCRThFUUNBQUlBRWdBaEFBR2lBQUR3c2dBQ0FDYWlFREFrQWdBQ0FCYzBFRGNVVUVRQUpBSUFKQkFVZ0VRQ0FBSVFJTUFRc2dBRUVEY1VVRVFDQUFJUUlNQVFzZ0FDRUNBMEFnQWlBQkxRQUFPZ0FBSUFGQkFXb2hBU0FDUVFGcUlnSWdBMDhOQVNBQ1FRTnhEUUFMQ3dKQUlBTkJmSEVpQkVIQUFFa05BQ0FDSUFSQlFHb2lCVXNOQUFOQUlBSWdBU2dDQURZQ0FDQUNJQUVvQWdRMkFnUWdBaUFCS0FJSU5nSUlJQUlnQVNnQ0REWUNEQ0FDSUFFb0FoQTJBaEFnQWlBQktBSVVOZ0lVSUFJZ0FTZ0NHRFlDR0NBQ0lBRW9BaHcyQWh3Z0FpQUJLQUlnTmdJZ0lBSWdBU2dDSkRZQ0pDQUNJQUVvQWlnMkFpZ2dBaUFCS0FJc05nSXNJQUlnQVNnQ01EWUNNQ0FDSUFFb0FqUTJBalFnQWlBQktBSTROZ0k0SUFJZ0FTZ0NQRFlDUENBQlFVQnJJUUVnQWtGQWF5SUNJQVZORFFBTEN5QUNJQVJQRFFFRFFDQUNJQUVvQWdBMkFnQWdBVUVFYWlFQklBSkJCR29pQWlBRVNRMEFDd3dCQ3lBRFFRUkpCRUFnQUNFQ0RBRUxJQU5CZkdvaUJDQUFTUVJBSUFBaEFnd0JDeUFBSVFJRFFDQUNJQUV0QUFBNkFBQWdBaUFCTFFBQk9nQUJJQUlnQVMwQUFqb0FBaUFDSUFFdEFBTTZBQU1nQVVFRWFpRUJJQUpCQkdvaUFpQUVUUTBBQ3dzZ0FpQURTUVJBQTBBZ0FpQUJMUUFBT2dBQUlBRkJBV29oQVNBQ1FRRnFJZ0lnQTBjTkFBc0xJQUFMd1JnQklIOGpBRUhRQTJzaUJpUUFJQUVvQWdnaEZDQUJJQUVvQWdRaUNpQUNiQ0lhSUFOcUVCMGdBU2dDQUNFSklBQkJBRFlDQ0NBQVFpZzNBaFFnQUVJQU53SU1JQUJCQmpZQ0FDQURRUVIwSVFjQ1FBSkFBa0FnQkVGK2FpSUVRUVZMRFFBQ1FDQUVRUUZyRGdRQkFRRUJBQXNNQVFzZ0JrRUFOZ0lNSUFZZ0ZEWUNHQ0FHSUFvMkFoUWdCaUFGTmdJUUlBVUVRQ0FHUWRBQWFpQUdRUXhxSUFaQkVHb2dCeUFDUVFSMFFRQkJBRUVRUVJBUURnd0NDd3NnQmtIUUFHcEJBRUdBQXhBSEdpQUpJQnBCQ0hScUlBZHFJUXdnQmtJQU53TklJQVpCUUd0Q0FEY0RBQ0FHUWdBM0F6Z2dCa0lBTndNd0lBWkNBRGNES0NBR1FnQTNBeUFnQmtJQU53TVlJQVpDQURjREVFRUFJUWtDZjBFQUlBSkZEUUFhUVFBZ0FFRUFJQXByUWRnQmJHb29Bc1FCUlEwQUdpQUdJQXdnQ2tFRWRHc2lCQzBBQlNBRUxRQUVhaUFFTFFBR2FpQUVMUUFIYWlJWElBUXRBQU1nQkMwQUFpQUVMUUFCSUFRdEFBQnFhbW9pRm1vaUJTQUVMUUFMSUFRdEFBb2dCQzBBQ1NBRUxRQUlhbXBxSWhKcklBUXRBQThnQkMwQURpQUVMUUFOSUFRdEFBeHFhbW9pRTJzaUNEWUNGQ0FHSUFVZ0Vtb2dFMm9pQ1RZQ0VFRUJDeUVGQW44Q1FDQUNJQlJCZjJwSEJFQWdBQ0FLUWRnQmJHb29Bc1FCRFFFTElBVU1BUXNnQmlBTUlBcEJDSFJxSWdJdEFBVWdBaTBBQkdvZ0FpMEFCbW9nQWkwQUIyb2lIaUFDTFFBRElBSXRBQUlnQWkwQUFTQUNMUUFBYW1wcUloOXFJZ1FnQWkwQUN5QUNMUUFLSUFJdEFBa2dBaTBBQ0dwcWFpSVlheUFDTFFBUElBSXRBQTRnQWkwQURTQUNMUUFNYW1wcUlobHJJQWhxSWdnMkFoUWdCaUFFSUJocUlBbHFJQmxxSWdrMkFoQkJBU0VRSUFWQkFXb0xJUWRCQUNFRUFuOENRQ0FEUlEwQUlBQkJiR29vQWdCRkRRQWdCaUFNUVg5cUlnSWdDa0VHZENJT2FpSUVJQXBCQkhRaUMyb3RBQUFnQkMwQUFHb2dCQ0FLUVFWMElnOXFMUUFBYWlBRUlBcEJNR3dpRFdvdEFBQnFJaHNnQWlBTmFpMEFBQ0FDSUE5cUxRQUFJQUlnQzJvdEFBQWdBaTBBQUdwcWFpSWNhaUlSSUFRZ0Rtb2lBaUFMYWkwQUFDQUNMUUFBYWlBQ0lBOXFMUUFBYWlBQ0lBMXFMUUFBYWlJVmF5QUNJQTVxSWdJZ0Myb3RBQUFnQWkwQUFHb2dBaUFQYWkwQUFHb2dBaUFOYWkwQUFHb2lEMnNpQkRZQ0lDQUdJQkVnRldvZ0NXb2dEMm9pQ1RZQ0VDQUhRUUZxSVF0QkFRd0JDeUFISVF0QkFBc2hBZ0pBQWtBQ1FBSkFBa0FDUUNBRElBcEJmMnBIQkVBZ0FDZ0NuQU1OQVF0QkFDRU9JQUpCQUVjaEVTQUhEUUVNQWdzZ0JpQUVJQXhCRUdvaUJDQUtRUVowSWgxcUlnQWdDa0VFZENJTmFpMEFBQ0FBTFFBQWFpQUFJQXBCQlhRaURtb3RBQUJxSUFBZ0NrRXdiQ0lSYWkwQUFHb2lJQ0FFSUJGcUxRQUFJQVFnRG1vdEFBQWdCQ0FOYWkwQUFDQU1MUUFRYW1wcUlpRnFJaUlnQUNBZGFpSUFJQTFxTFFBQUlBQXRBQUJxSUFBZ0Rtb3RBQUJxSUFBZ0VXb3RBQUJxSWd4cklBQWdIV29pQUNBTmFpMEFBQ0FBTFFBQWFpQUFJQTVxTFFBQWFpQUFJQkZxTFFBQWFpSU5hMm9pQkRZQ0lDQUdJQXdnSW1vZ0NXb2dEV29pQ1RZQ0VDQUNRUUJISVJGQkFTRU9JQUpCQVdvaEFDQUxRUUZxSVFzQ1FDQUhEUUFnQWtVTkFDQUdJQnNnSEdvZ0ZXb2dEMm9nSVdzZ0lHc2dER3NnRFd0QkJYVWlDRFlDRkF3REN5QUhSUTBDSUFBaEFnc2dCaUFJSUFkQkEycDFJZ2cyQWhRTEFrQWdFRVVOQUNBRlJRMEFJQUlOQUNBR0lCWWdGMm9nRW1vZ0Uyb2dHV3NnR0dzZ0htc2dIMnRCQlhVaUJEWUNJRUVCSVJCQkFTRU5EQU1MSUJCQkFFY2hFQ0FGUVFCSElRMGdBa1VOQWd3QkN5QVFRUUJISVJBZ0JVRUFSeUVOSUFBaEFnc2dCaUFFSUFKQkEycDFJZ1EyQWlBTElBWUNmeUFMUVg5cUlnQkJBazBFUUFKQUFrQUNRQ0FBUVFGckRnSUJBZ0FMSUFsQkJIWU1Bd3NnQ1VFRmRnd0NDeUFKUVJWc1FRcDFEQUVMSUFsQkJuWUxJZ0EyQWhBQ1FDQUVJQWh5UlFSQUlBWWdBRFlDU0NBR0lBQTJBa3dnQmlBQU5nSkVJQVlnQURZQ1FDQUdJQUEyQWp3Z0JpQUFOZ0k0SUFZZ0FEWUNOQ0FHSUFBMkFqQWdCaUFBTmdJc0lBWWdBRFlDS0NBR0lBQTJBaVFnQmlBQU5nSWdJQVlnQURZQ0hDQUdJQUEyQWhnZ0JpQUFOZ0lVREFFTElBWWdBQ0FJYWlJRklBUnJOZ0pBSUFZZ0JTQUVRUUYxSWdKck5nSXdJQVlnQWlBRmFqWUNJQ0FHSUFRZ0JXbzJBaEFnQmlBQUlBaHJJZ1VnQkdzMkFrd2dCaUFGSUFKck5nSThJQVlnQWlBRmFqWUNMQ0FHSUFRZ0JXbzJBaHdnQmlBQUlBaEJBWFVpQjJvaUJTQUVhellDUkNBR0lBVWdBbXMyQWpRZ0JpQUNJQVZxTmdJa0lBWWdCQ0FGYWpZQ0ZDQUdJQUFnQjJzaUFDQUVhellDU0NBR0lBQWdBbXMyQWpnZ0JpQUFJQUpxTmdJb0lBWWdBQ0FFYWpZQ0dBc2dCa0hRQUdvaENDQUdRUkJxSVFCQkFDRUVBMEFnQ0NBQUlBUkJESEZxS0FJQUlnSkIvd0VnQWtIL0FVZ2JJZ0pCQUNBQ1FRQktHem9BQUNBQUlBQkJFR29nQkVFQmFpSUVRVDl4R3lFQUlBaEJBV29oQ0NBRVFZQUNSdzBBQ3lBQktBSUFJQW9nRkd3aUFFRUlkR29nR2tFR2RHb2dBMEVEZEdvaEF5QUtRUVIwSVF3Z0NrRUdkQ0VhSUFCQkJuUWhIVUVBSUFwQkEzUWlDMnNoSUNBR1FkQUNhaUVoSUFaQlFHc2hJa0VBSVFVRFFDQUdRZ0EzQTBnZ0lrSUFOd01BSUFaQ0FEY0RPQ0FHUWdBM0F6QWdCa0lBTndNb0lBWkNBRGNESUNBR1FnQTNBeGdnQmtJQU53TVFRUUFoQ0VFQUlRUkJBQ0VKSUEwRVFDQUdJQU1nSUdvaUFDMEFBeUFBTFFBQ2FpSVhJQUF0QUFFZ0FDMEFBR29pRm1vaUFpQUFMUUFGSUFBdEFBUnFJaEpySUFBdEFBY2dBQzBBQm1vaUUyc2lDRFlDRkNBR0lBSWdFbW9nRTJvaUJEWUNFRUVCSVFrTElCQUVRQ0FHSUFNZ0dtb2lBQzBBQXlBQUxRQUNhaUllSUFBdEFBRWdBQzBBQUdvaUgyb2lBaUFBTFFBRklBQXRBQVJxSWhocklBQXRBQWNnQUMwQUJtb2lHV3NnQ0dvaUNEWUNGQ0FHSUFJZ0dHb2dCR29nR1dvaUJEWUNFQ0FKUVFGcUlRa0xRUUFoQUFKL0lCRkZCRUFnQ1NFSFFRQU1BUXNnQmlBRFFYOXFJZ0FnREdvaUFpQUxhaTBBQUNBQ0xRQUFhaUliSUFBZ0Myb3RBQUFnQUMwQUFHb2lIR29pQnlBQ0lBeHFJZ0FnQzJvdEFBQWdBQzBBQUdvaUZXc2dBQ0FNYWlJQUlBdHFMUUFBSUFBdEFBQnFJZzlySWdBMkFpQWdCaUFISUJWcUlBUnFJQTlxSWdRMkFoQWdDVUVCYWlFSFFRRUxJUUlDUUNBR0FuOENRQUpBQWtBZ0RrVUVRQ0FKRFFFTUFnc2dCaUFBSUFOQkNHb2lDaUFNYWlJQUlBdHFMUUFBSUFBdEFBQnFJaU1nQ2lBTGFpMEFBQ0FETFFBSWFpSWthaUlsSUFBZ0RHb2lBQ0FMYWkwQUFDQUFMUUFBYWlJS2F5QUFJQXhxSWdBZ0Myb3RBQUFnQUMwQUFHb2lGR3RxSWdBMkFpQWdCaUFLSUNWcUlBUnFJQlJxSWdRMkFoQWdBa0VCYWlFQ0lBZEJBV29oQnlBUlFRRnpJQWxCQUVkeVJRUkFJQVlnR3lBY2FpQVZhaUFQYWlBa2F5QWpheUFLYXlBVWEwRUVkU0lJTmdJVURBTUxJQWxGRFFJTElBWWdDQ0FKUVFKcWRTSUlOZ0lVQ3lBV0lCZHFJQkpxSUJOcUlCbHJJQmhySUI1cklCOXJRUVIxSUJBZ0RTQUNSWEZ4UVFGR0RRRWFJQUpGRFFJTElBQWdBa0VDYW5VTElnQTJBaUFMSUFZQ2Z5QUhRWDlxSWdKQkFrMEVRQUpBQWtBQ1FDQUNRUUZyRGdJQkFnQUxJQVJCQTNZTUF3c2dCRUVFZGd3Q0N5QUVRUlZzUVFsMkRBRUxJQVJCQlhZTElnUTJBaEFDUUNBQUlBaHlSUVJBSUFZZ0JEWUNTQ0FHSUFRMkFrd2dCaUFFTmdKRUlBWWdCRFlDUUNBR0lBUTJBandnQmlBRU5nSTRJQVlnQkRZQ05DQUdJQVEyQWpBZ0JpQUVOZ0lzSUFZZ0JEWUNLQ0FHSUFRMkFpUWdCaUFFTmdJZ0lBWWdCRFlDSENBR0lBUTJBaGdnQmlBRU5nSVVEQUVMSUFZZ0JDQUlhaUlISUFCck5nSkFJQVlnQnlBQVFRRjFJZ0pyTmdJd0lBWWdBaUFIYWpZQ0lDQUdJQUFnQjJvMkFoQWdCaUFFSUFocklnY2dBR3MyQWt3Z0JpQUhJQUpyTmdJOElBWWdBaUFIYWpZQ0xDQUdJQUFnQjJvMkFod2dCaUFFSUFoQkFYVWlDV29pQnlBQWF6WUNSQ0FHSUFjZ0FtczJBalFnQmlBQ0lBZHFOZ0lrSUFZZ0FDQUhhallDRkNBR0lBUWdDV3NpQkNBQWF6WUNTQ0FHSUFRZ0FtczJBamdnQmlBQ0lBUnFOZ0lvSUFZZ0FDQUVhallDR0FzZ0lTQUZRUVowYWlFSVFRQWhBQ0FHUVJCcUlRUURRQ0FJSUFRZ0FFRUJkRUVNY1dvb0FnQWlBa0gvQVNBQ1FmOEJTQnNpQWtFQUlBSkJBRW9iT2dBQUlBUWdCRUVRYWlBQVFRRnFJZ0JCRDNFYklRUWdDRUVCYWlFSUlBQkJ3QUJIRFFBTElBTWdIV29oQXlBRlFRRnFJZ1ZCQWtjTkFBc0xJQUVnQmtIUUFHb1FHeUFHUWRBRGFpUUFDellBSUFJRVFDQUFJQUVRQWc4TFFRRWhBaUFCSUFCQkFSQURJZ0EyQWdBZ0FFRi9Sd1IvSUFFZ0FFRUJjellDQUVFQUJVRUJDd3ZNQXdFU2Z5QURRUUYwSVE4Z0EwRjliQ0VRUVFBZ0Eyc2lFVUVCZENFU0lBRWdBaWdDQUdwQmYyb3RBQUFpQjBFQmFpRVRRUUFnQjJzaENrRUVJUUVEUUFKQUlBQWdFV29pRkMwQUFDSUZJQUF0QUFBaUNHc2lCQ0FFUVI5MUlnUnFJQVJ6SUFJb0FnUlBEUUFnQUNBU2FpSUxMUUFBSWd3Z0JXc2lCQ0FFUVI5MUlnUnFJQVJ6SUFJb0FnZ2lCazhOQUNBQUlBTnFJaFV0QUFBaURTQUlheUlFSUFSQkgzVWlCR29nQkhNZ0JrOE5BQ0FISVFRZ0FDQVFhaTBBQUNJSklBVnJJZzRnRGtFZmRTSU9haUFPY3lBR1NRUkFJQXNnRENBS0lBY2dCU0FJYWtFQmFrRUJkaUFNUVFGMGF5QUpha0VCZFNJRUlBUWdCMG9iSUFRZ0NrZ2Jham9BQUNBQ0tBSUlJUVlnRXlFRUN5QVVJQVVDZnlBQUlBOXFMUUFBSWdzZ0NHc2lDU0FKUVI5MUlnbHFJQWx6SUFaSkJFQWdGU0FOSUFvZ0J5QUZJQWhxUVFGcVFRRjJJQTFCQVhScklBdHFRUUYxSWdZZ0JpQUhTaHNnQmlBS1NCdHFPZ0FBSUFSQkFXb2hCQXRCQUNBRWF5SUdDeUFFSUFnZ0JXdEJBblFnRFdzZ0RHcEJCR3BCQTNVaUJTQUZJQVJLR3lBRklBWklHeUlFYWtHd0xtb3RBQUE2QUFBZ0FDQUlJQVJyUWJBdWFpMEFBRG9BQUFzZ0FFRUJhaUVBSUFGQmYyb2lBUTBBQ3d2N0JnRU9meUFDS0FJSUlRb2dBaWdDQkNFUEFrQWdBVUVFVHdSQUlBOUJBblpCQW1vaEVFRUVJUUlEUUFKQUlBQkJmMm9pQlMwQUFDSUhJQUF0QUFBaUNHc2lBU0FCUVI5MUlnRnFJQUZ6SWcwZ0QwOE5BQ0FBUVg1cUlnNHRBQUFpQVNBSGF5SUVJQVJCSDNVaUJHb2dCSE1nQ2s4TkFDQUFMUUFCSWdrZ0NHc2lCQ0FFUVI5MUlnUnFJQVJ6SUFwUERRQUNRQ0FOSUJCSkJFQWdBQzBBQWlFTEFuOGdBRUY5YWlJTkxRQUFJZ1FnQjJzaUJpQUdRUjkxSWdacUlBWnpJQXBKQkVCQkF5RUdJQVVnQ1NBSElBaHFJQUZxSWdWQkFYUnFJQVJxUVFScVFRTjJPZ0FBSUE0Z0JDQUZha0VDYWtFQ2Rqb0FBQ0FFUVFOc0lRNGdCVUVFYWlFTUlBQkJmR290QUFBTUFRc2dCeUFKYWlFTVFRSWhEa0VDSVFZZ0JTRU5JQUVMSVFRZ0RTQU1JQTVxSUFSQkFYUnFJQVoyT2dBQUlBc2dDR3NpQlNBRlFSOTFJZ1ZxSUFWeklBcFBEUUVnQUNBSElBbHFJQWhxSWdVZ0MycEJBbXBCQW5ZNkFBRWdBQ0FGSUF0QkEyeHFJQUF0QUFOQkFYUnFRUVJxUVFOMk9nQUNJQUFnQVNBRlFRRjBhaUFMYWtFRWFrRURkam9BQUF3Q0N5QUZJQWNnQ1dvZ0FVRUJkR3BCQW1wQkFuWTZBQUFMSUFBZ0FTQUlhaUFKUVFGMGFrRUNha0VDZGpvQUFBc2dBQ0FEYWlFQUlBSkJmMm9pQWcwQUN3d0JDeUFCSUFJb0FnQnFRWDlxTFFBQUlnVkJBV29oRFVFQUlBVnJJUWhCQkNFQ0EwQUNRQ0FBUVg5cUlnNHRBQUFpQkNBQUxRQUFJZ2RySWdFZ0FVRWZkU0lCYWlBQmN5QVBUdzBBSUFCQmZtb2lEQzBBQUNJSklBUnJJZ0VnQVVFZmRTSUJhaUFCY3lBS1R3MEFJQUF0QUFFaUN5QUhheUlCSUFGQkgzVWlBV29nQVhNZ0NrOE5BQ0FBTFFBQ0lRWWdCU0VCSUFCQmZXb3RBQUFpRUNBRWF5SVJJQkZCSDNVaUVXb2dFWE1nQ2trRVFDQU1JQWtnQ0NBRklBUWdCMnBCQVdwQkFYWWdDVUVCZEdzZ0VHcEJBWFVpQVNBQklBVktHeUFCSUFoSUcybzZBQUFnRFNFQkN5QU9JQVFDZnlBR0lBZHJJZ3dnREVFZmRTSU1haUFNY3lBS1NRUkFJQUFnQ3lBSUlBVWdCQ0FIYWtFQmFrRUJkaUFMUVFGMGF5QUdha0VCZFNJR0lBWWdCVW9iSUFZZ0NFZ2Jham9BQVNBQlFRRnFJUUVMUVFBZ0FXc2lCZ3NnQVNBSklBdHJJQWNnQkd0QkFuUnFRUVJxUVFOMUlnUWdCQ0FCU2hzZ0JDQUdTQnNpQVdwQnNDNXFMUUFBT2dBQUlBQWdCeUFCYTBHd0xtb3RBQUE2QUFBTElBQWdBMm9oQUNBQ1FYOXFJZ0lOQUFzTEM5b0hBUTEvSXdCQndBTnJJaEVrQUNBR1FRVnFJUWtDUUFKQUlBSkJBRWdOQUNBRFFRQklEUUFnQWlBSmFpQUVTdzBBSUFNZ0IycEJCV29nQlVzTkFDQUVJUWtnQXlFS0RBRUxJQUFnRVNBQ0lBTWdCQ0FGSUFrZ0IwRUZhaUFKRUF3Z0VTRUFRUUFoQWdzQ1FDQUhSUTBBSUFBZ0NTQUtiQ0FDYW1vaEUwRVFJQVpySVJRQ1FDQUdRUUoySWhJRVFDQUpJQVpySVJVZ0V5QUpJQWhCQVhaQkFYRkJBbkpzYWtFRmFpRUNJQWNoQkFOQUlBSkJmMm90QUFBaEFDQUNRWDVxTFFBQUlRTWdBa0Y5YWkwQUFDRUZJQUpCZkdvdEFBQWhDeUFDUVh0cUxRQUFJUTBnRWlFUEEwQWdBU0FDTFFBQUlnb2dEU0FBSUF0cUlneHJJQU1nQldwQkZHeHFJQXhCQW5ScmFrRVFha0VGZFVHd0xtb3RBQUE2QUFBZ0FTQUNMUUFCSWd3Z0N5QUFJQU5xUVJSc2FpQUZJQXBxSWd0cklBdEJBblJyYWtFUWFrRUZkVUd3TG1vdEFBQTZBQUVnQVNBQ0xRQUNJaEFnQlNBQUlBcHFRUlJzYWlBRElBeHFJZ1ZySUFWQkFuUnJha0VRYWtFRmRVR3dMbW90QUFBNkFBSWdBU0FDTFFBRElnNGdBeUFLSUF4cVFSUnNhaUFBSUJCcUlnTnJJQU5CQW5ScmFrRVFha0VGZFVHd0xtb3RBQUE2QUFNZ0FVRUVhaUVCSUFKQkJHb2hBaUFBSVEwZ0NpRUxJQXdoQlNBUUlRTWdEaUVBSUE5QmYyb2lEdzBBQ3lBQklCUnFJUUVnQWlBVmFpRUNJQVJCZjJvaUJBMEFDd3dCQ3lBSFFYOXFJQlJzSUFacklBRnFRUkJxSVFFTElBZEJBbllpQkVVTkFFSEFBQ0FHYXlFUUlBbEJBWFFoQ2lBSlFRSjBJQVpySVF0QkFDQUpheUlNUVFGMElSSWdBU0FIUVFSMGF5RUNJQWtnRTJvZ0NFRUJjV3BCQW1vaUFDQUpRUVZzYWlFQkEwQWdCaUlEQkVBRFFDQUNJQUFnQ21vdEFBQWlCU0FCSUFwcUxRQUFJQUVnQ1dvdEFBQWlEaUFCSUJKcUxRQUFJZ2RxSWdocklBaEJBblJyYWlBQkxRQUFJZzBnQVNBTWFpMEFBQ0lJYWtFVWJHcEJFR3BCQlhWQnNDNXFMUUFBSUFJdEFEQnFRUUZxUVFGMk9nQXdJQUlnQUNBSmFpMEFBQ0lQSUE0Z0J5QUlha0VVYkdvZ0JTQU5haUlPYXlBT1FRSjBhMnBCRUdwQkJYVkJzQzVxTFFBQUlBSXRBQ0JxUVFGcVFRRjJPZ0FnSUFJZ0FDMEFBQ0lPSUEwZ0JTQUhha0VVYkdvZ0NDQVBhaUlOYXlBTlFRSjBhMnBCRUdwQkJYVkJzQzVxTFFBQUlBSXRBQkJxUVFGcVFRRjJPZ0FRSUFJZ0FDQU1haTBBQUNBSUlBVWdEMnBCRkd4cUlBY2dEbW9pQldzZ0JVRUNkR3RxUVJCcVFRVjFRYkF1YWkwQUFDQUNMUUFBYWtFQmFrRUJkam9BQUNBQVFRRnFJUUFnQWtFQmFpRUNJQUZCQVdvaEFTQURRWDlxSWdNTkFBc0xJQUlnRUdvaEFpQUJJQXRxSVFFZ0FDQUxhaUVBSUFSQmYyb2lCQTBBQ3dzZ0VVSEFBMm9rQUF1MUJRRUVmeUFBS0FJVUlRTWdBQ2dDRUNFRUlBQW9BZ1FoQlNBQUtBSU1JZ0lnQVNrQ0FEY0NBQ0FDSUFFcEFnZzNBZ2dnQWlBRlFRUjBJZ0JxSWdJZ0FTa0NFRGNDQUNBQ0lBRXBBaGczQWdnZ0FDQUNhaUlDSUFFcEFpQTNBZ0FnQWlBQktRSW9Od0lJSUFBZ0Ftb2lBaUFCS1FJd053SUFJQUlnQVNrQ09EY0NDQ0FBSUFKcUlnSWdBU2tDUURjQ0FDQUNJQUVwQWtnM0FnZ2dBQ0FDYWlJQ0lBRXBBbEEzQWdBZ0FpQUJLUUpZTndJSUlBQWdBbW9pQWlBQktRSmdOd0lBSUFJZ0FTa0NhRGNDQ0NBQUlBSnFJZ0lnQVNrQ2NEY0NBQ0FDSUFFcEFuZzNBZ2dnQUNBQ2FpSUNJQUVwQW9BQk53SUFJQUlnQVNrQ2lBRTNBZ2dnQUNBQ2FpSUNJQUVwQXBBQk53SUFJQUlnQVNrQ21BRTNBZ2dnQUNBQ2FpSUNJQUVwQXFBQk53SUFJQUlnQVNrQ3FBRTNBZ2dnQUNBQ2FpSUNJQUVwQXJBQk53SUFJQUlnQVNrQ3VBRTNBZ2dnQUNBQ2FpSUNJQUVwQXNBQk53SUFJQUlnQVNrQ3lBRTNBZ2dnQUNBQ2FpSUNJQUVwQXRBQk53SUFJQUlnQVNrQzJBRTNBZ2dnQUNBQ2FpSUNJQUVwQXVBQk53SUFJQUlnQVNrQzZBRTNBZ2dnQUNBQ2FpSUFJQUVwQXZBQk53SUFJQUFnQVNrQytBRTNBZ2dnQkNBQktRS0FBamNDQUNBRUlBVkJBM1FpQUdvaUJDQUJLUUtJQWpjQ0FDQUFJQVJxSWdRZ0FTa0NrQUkzQWdBZ0FDQUVhaUlFSUFFcEFwZ0NOd0lBSUFBZ0JHb2lCQ0FCS1FLZ0FqY0NBQ0FBSUFScUlnUWdBU2tDcUFJM0FnQWdBQ0FFYWlJRUlBRXBBckFDTndJQUlBQWdCR29nQVNrQ3VBSTNBZ0FnQXlBQktRTEFBamNDQUNBQUlBTnFJZ01nQVNrQ3lBSTNBZ0FnQUNBRGFpSURJQUVwQXRBQ053SUFJQUFnQTJvaUF5QUJLUUxZQWpjQ0FDQUFJQU5xSWdNZ0FTa0M0QUkzQWdBZ0FDQURhaUlESUFFcEF1Z0NOd0lBSUFBZ0Eyb2lBeUFCS1FMd0FqY0NBQ0FBSUFOcUlBRXBBdmdDTndJQUMrZ0NBUVYvQWtBZ0FDQUJFQUlpQXcwQVFRRWhBeUFCSUFFb0FnQkJBV29pQWpZQ0FDQUNRU0JMRFFBZ0FFRUVFQU1pQWtGL1JnMEFJQUVnQWpZQ0JDQUFRUVFRQXlJQ1FYOUdEUUFnQVNBQ05nSUlJQUVvQWdBRVFBTkFJQUFnQVNBRlFRSjBhaUlDSWdSQkRHb1FBaUlERFFKQkFTRURJQVFvQWd3aUJrRi9SZzBDSUFRZ0JrRUJhaUlETmdJTUlBUWdBeUFCS0FJRVFRWnFkRFlDRENBQUlBSkJqQUZxRUFJaUF3MENRUUVoQXlBQ0tBS01BU0lFUVg5R0RRSWdBaUFFUVFGcUlnUTJBb3dCSUFJZ0JDQUJLQUlJUVFScWREWUNqQUVnQUVFQkVBTWlCRUYvUmcwQ0lBSWdCRUVCUmpZQ2pBSWdCVUVCYWlJRklBRW9BZ0JKRFFBTEN5QUFRUVVRQXlJQ1FYOUdEUUFnQVNBQ1FRRnFOZ0tNQXlBQVFRVVFBeUlDUVg5R0RRQWdBU0FDUVFGcU5nS1FBeUFBUVFVUUF5SUNRWDlHRFFBZ0FTQUNRUUZxTmdLVUF5QUFRUVVRQXlJQVFYOUdEUUFnQVNBQU5nS1lBMEVBSVFNTElBTUxXd0VEZnlBQUlBQW9BZ0FpQkNBQklBQW9BZ1FpQW5BaUEwRUVkR29nQVNBRGF5SUJRUWgwYWpZQ0RDQUFJQVFnQWlBQUtBSUliQ0lDUVFoMGFpQUJRUVowYWlBRFFRTjBhaUlCTmdJUUlBQWdBU0FDUVFaMGFqWUNGQXRWQVFKL0lBRWdBa0VCYWlJRElBTWdBVWtiSVFNZ0FDQUNRUUowYWlnQ0FDRUVBMEFDUUNBQ1FRRnFJZ0lnQVU4RVFDQURJUUlNQVFzZ0FDQUNRUUowYWlnQ0FDQUVSdzBCQ3d0QkFDQUNJQUVnQWtZYkN5Y0FJQUJCQ0NBQUtBSUlJZ0JyRUFOQmYwWUVRQThMUVFBZ0FHdEJBblJCekQ5cUtBSUFHZ3Q2QVFKL0l3QkJJR3NpQWlRQUlBSWdBQ2dDRURZQ0VDQUNJQUFwQWdnM0F3Z2dBaUFBS1FJQU53TUFBa0FnQWlBQ1FSeHFFQUlpQUEwQUlBSWdBa0VjYWhBQ0lnQU5BQ0FDSUFKQkhHb1FBaUlBRFFCQkFTRUFJQUlvQWh3aUEwSC9BVXNOQUNBQklBTTJBZ0JCQUNFQUN5QUNRU0JxSkFBZ0FBdm5Cd0VTZnlNQVFZQU9heUlNSkFBZ0JrRUZhaUVKQWtBQ1FDQUNRUUJJRFFBZ0EwRUFTQTBBSUFJZ0NXb2dCRXNOQUNBRElBZHFRUVZxSUFWTERRQWdBeUVLREFFTElBQWdERUhBQ21vZ0FpQURJQVFnQlNBSklBZEJCV29nQ1JBTUlBeEJ3QXBxSVFBZ0NTRUVRUUFoQWdzQ1FDQUhRUUoySWhSRkRRQWdDVVVOQUNBRVFRRjBJUlZCQUNBRWF5SVdRUUYwSVJvZ0JFRUNkQ0FHYTBGN2FpRVhJQUFnQkNBS2JDQUNhbW9nQkdvaUFDQUVRUVZzYWlFQ0lBd2dDVUVDZENJUWFpRURJQWxCQTNRaERVRUFJQWxyUVFKMElRNGdDVUVEYkVFQ2RDRVBBMEFnQ1NFRkEwQWdBeUFOYWlBQUlCVnFMUUFBSWhFZ0FpQVZhaTBBQUNBQ0lBUnFMUUFBSWdzZ0FpQWFhaTBBQUNJU2FpSUtheUFLUVFKMGEyb2dBaTBBQUNJWUlBSWdGbW90QUFBaUUycEJGR3hxTmdJQUlBTWdFR29nQUNBRWFpMEFBQ0laSUFzZ0VpQVRha0VVYkdvZ0VTQVlhaUlLYXlBS1FRSjBhMm8yQWdBZ0F5QUFMUUFBSWdzZ0dDQVJJQkpxUVJSc2FpQVRJQmxxSWdwcklBcEJBblJyYWpZQ0FDQURJQTVxSUFBZ0Ztb3RBQUFnRXlBUklCbHFRUlJzYWlBTElCSnFJZ3BySUFwQkFuUnJhallDQUNBQVFRRnFJUUFnQTBFRWFpRURJQUpCQVdvaEFpQUZRWDlxSWdVTkFBc2dBaUFYYWlFQ0lBQWdGMm9oQUNBRElBOXFJUU1nRkVGL2FpSVVEUUFMQ3lBSEJFQkJFQ0FHYXlFUUlBWkJBblloQ2lBTUlBaEJBblJxUVFocUlRQWdERUVVYWlFQ0EwQWdDZ1JBSUFKQmJHb29BZ0FoQkNBQ1FYQnFLQUlBSVE4Z0FrRjBhaWdDQUNFTklBSkJlR29vQWdBaEJTQUNRWHhxS0FJQUlRTWdDaUVKQTBBZ0FTQUNLQUlBSWc0Z0JDQURJQTlxSWdScklBVWdEV3BCRkd4cUlBUkJBblJyYWtHQUJHcEJDblZCc0M1cUxRQUFJQUFvQWdCQkVHcEJCWFZCc0M1cUxRQUFha0VCYWtFQmRqb0FBQ0FCSUFJb0FnUWlDeUFQSUFNZ0JXcEJGR3hxSUEwZ0Rtb2lCR3NnQkVFQ2RHdHFRWUFFYWtFS2RVR3dMbW90QUFBZ0FDZ0NCRUVRYWtFRmRVR3dMbW90QUFCcVFRRnFRUUYyT2dBQklBRWdBaWdDQ0NJSUlBMGdBeUFPYWtFVWJHb2dCU0FMYWlJRWF5QUVRUUowYTJwQmdBUnFRUXAxUWJBdWFpMEFBQ0FBS0FJSVFSQnFRUVYxUWJBdWFpMEFBR3BCQVdwQkFYWTZBQUlnQVNBQ0tBSU1JZ1lnQlNBTElBNXFRUlJzYWlBRElBaHFJZ1JySUFSQkFuUnJha0dBQkdwQkNuVkJzQzVxTFFBQUlBQW9BZ3hCRUdwQkJYVkJzQzVxTFFBQWFrRUJha0VCZGpvQUF5QUJRUVJxSVFFZ0FFRVFhaUVBSUFKQkVHb2hBaUFESVFRZ0RpRVBJQXNoRFNBSUlRVWdCaUVESUFsQmYyb2lDUTBBQ3dzZ0FTQVFhaUVCSUFCQkZHb2hBQ0FDUVJScUlRSWdCMEYvYWlJSERRQUxDeUFNUVlBT2FpUUFDOUVIQVF4L0l3QkJnQTVySWc4a0FDQUdRUVZxSVFrQ1FBSkFJQUpCQUVnTkFDQURRUUJJRFFBZ0FpQUphaUFFU3cwQUlBZEJCV29pRGlBRGFpQUZTdzBBSUFRaENTQURJUW9NQVFzZ0FDQVBRY0FLYWlBQ0lBTWdCQ0FGSUFrZ0IwRUZhaUlPSUFrUURDQVBRY0FLYWlFQVFRQWhBZ3NDUUNBT1JRMEFJQVpCQW5ZaUVrVU5BQ0FKSUFacklSTWdBQ0FKSUFwc0lBSnFha0VGYWlFQ0lBOGhBQU5BSUFKQmYyb3RBQUFoQ1NBQ1FYNXFMUUFBSVFNZ0FrRjlhaTBBQUNFRklBSkJmR290QUFBaENpQUNRWHRxTFFBQUlRd2dFaUVOQTBBZ0FDQUNMUUFBSWdRZ0RDQUpJQXBxSWd0cklBTWdCV3BCRkd4cUlBdEJBblJyYWpZQ0FDQUFJQUl0QUFFaUN5QURJQWxxUVJSc0lBcHFJQVFnQldvaUNtc2dDa0VDZEd0cU5nSUVJQUFnQWkwQUFpSVFJQVFnQ1dwQkZHd2dCV29nQXlBTGFpSUZheUFGUVFKMGEybzJBZ2dnQUNBQ0xRQURJaFFnQkNBTGFrRVViQ0FEYWlBSklCQnFJZ05ySUFOQkFuUnJhallDRENBQVFSQnFJUUFnQWtFRWFpRUNJQWtoRENBRUlRb2dDeUVGSUJBaEF5QVVJUWtnRFVGL2FpSU5EUUFMSUFJZ0Uyb2hBaUFPUVg5cUlnNE5BQXNMSUFkQkFuWWlCd1JBUWNBQUlBWnJJUlFnRHlBR1FRSjBJZ1JxSWdrZ0JrRVViR29oQWlBSklBaEJBbW9nQm14QkFuUnFJUUFnQmtFRGJFRUNkQ0VGUVFBZ0Jtc2lEa0VEZENFVElBWkJBM1FoQ0FOQUlBWWhBeUFHQkVBRFFDQUJJQWdnQ1dvb0FnQWlDaUFDSUFocUtBSUFJQUlnQkdvb0FnQWlFU0FDSUJOcUtBSUFJZ3RxSWd4cklBeEJBblJyYWlBQ0tBSUFJZzBnQWlBT1FRSjBJaEJxS0FJQUlneHFRUlJzYWtHQUJHcEJDblZCc0M1cUxRQUFJQUFnQ0dvb0FnQkJFR3BCQlhWQnNDNXFMUUFBYWtFQmFrRUJkam9BTUNBQklBUWdDV29vQWdBaUVpQVJJQXNnREdwQkZHeHFJQW9nRFdvaUVXc2dFVUVDZEd0cVFZQUVha0VLZFVHd0xtb3RBQUFnQUNBRWFpZ0NBRUVRYWtFRmRVR3dMbW90QUFCcVFRRnFRUUYyT2dBZ0lBRWdDU2dDQUNJUklBMGdDaUFMYWtFVWJHb2dEQ0FTYWlJTmF5QU5RUUowYTJwQmdBUnFRUXAxUWJBdWFpMEFBQ0FBS0FJQVFSQnFRUVYxUWJBdWFpMEFBR3BCQVdwQkFYWTZBQkFnQVNBSklCQnFLQUlBSUF3Z0NpQVNha0VVYkdvZ0N5QVJhaUlLYXlBS1FRSjBhMnBCZ0FScVFRcDFRYkF1YWkwQUFDQUFJQkJxS0FJQVFSQnFRUVYxUWJBdWFpMEFBR3BCQVdwQkFYWTZBQUFnQUVFRWFpRUFJQWxCQkdvaENTQUJRUUZxSVFFZ0FrRUVhaUVDSUFOQmYyb2lBdzBBQ3dzZ0FTQVVhaUVCSUFBZ0JXb2hBQ0FDSUFWcUlRSWdCU0FKYWlFSklBZEJmMm9pQncwQUN3c2dEMEdBRG1va0FBdTBCZ0VKZnlNQVFjQURheUlOSkFBZ0JrRUZhaUVKQWtBQ1FDQUNRUUJJRFFBZ0F5QUhhaUFGU3cwQUlBTkJBRWdOQUNBQ0lBbHFJQVJMRFFBZ0JDRUpJQU1oQ2d3QkN5QUFJQTBnQWlBRElBUWdCU0FKSUFjZ0NSQU1JQTBoQUVFQUlRSUxJQWNFUUVFUUlBWnJJUkFnQ1NBR2F5RVJJQVpCQW5ZaER5QUFJQWtnQ213Z0FtcHFRUVZxSVFrRFFBSkFJQTlGRFFBZ0NVRi9haTBBQUNFQ0lBbEJmbW90QUFBaEJpQUpRWDFxTFFBQUlRTWdDVUY4YWkwQUFDRUZJQWxCZTJvdEFBQWhDaUFQSWdBaEN5QUlCRUFEUUNBQklBWWdDUzBBQUNJRUlBb2dBaUFGYWlJS2F5QURJQVpxUVJSc2FpQUtRUUowYTJwQkVHcEJCWFZCc0M1cUxRQUFha0VCYWtFQmRqb0FBQ0FCSUFJZ0NTMEFBU0lMSUFVZ0FpQUdha0VVYkdvZ0F5QUVhaUlGYXlBRlFRSjBhMnBCRUdwQkJYVkJzQzVxTFFBQWFrRUJha0VCZGpvQUFTQUJJQVFnQ1MwQUFpSU1JQU1nQWlBRWFrRVViR29nQmlBTGFpSURheUFEUVFKMGEycEJFR3BCQlhWQnNDNXFMUUFBYWtFQmFrRUJkam9BQWlBQklBc2dDUzBBQXlJT0lBWWdCQ0FMYWtFVWJHb2dBaUFNYWlJRGF5QURRUUowYTJwQkVHcEJCWFZCc0M1cUxRQUFha0VCYWtFQmRqb0FBeUFCUVFScUlRRWdDVUVFYWlFSklBSWhDaUFFSVFVZ0N5RURJQXdoQmlBT0lRSWdBRUYvYWlJQURRQU1BZ0FMQUFzRFFDQUJJQU1nQ1MwQUFDSUFJQW9nQWlBRmFpSUVheUFESUFacVFSUnNhaUFFUVFKMGEycEJFR3BCQlhWQnNDNXFMUUFBYWtFQmFrRUJkam9BQUNBQklBWWdDUzBBQVNJRUlBVWdBaUFHYWtFVWJHb2dBQ0FEYWlJRmF5QUZRUUowYTJwQkVHcEJCWFZCc0M1cUxRQUFha0VCYWtFQmRqb0FBU0FCSUFJZ0NTMEFBaUlNSUFNZ0FDQUNha0VVYkdvZ0JDQUdhaUlEYXlBRFFRSjBhMnBCRUdwQkJYVkJzQzVxTFFBQWFrRUJha0VCZGpvQUFpQUJJQUFnQ1MwQUF5SU9JQVlnQUNBRWFrRVViR29nQWlBTWFpSURheUFEUVFKMGEycEJFR3BCQlhWQnNDNXFMUUFBYWtFQmFrRUJkam9BQXlBQlFRUnFJUUVnQ1VFRWFpRUpJQUloQ2lBQUlRVWdCQ0VESUF3aEJpQU9JUUlnQzBGL2FpSUxEUUFMQ3lBQklCQnFJUUVnQ1NBUmFpRUpJQWRCZjJvaUJ3MEFDd3NnRFVIQUEyb2tBQXZHQkFFTGZ5TUFRY0FEYXlJTkpBQUNRQUpBSUFKQkFFZ05BQ0FEUVFCSURRQWdBaUFHYWlBRVN3MEFJQU1nQjJwQkJXb2dCVXNOQUNBRElRa01BUXNnQUNBTklBSWdBeUFFSUFVZ0JpQUhRUVZxSUFZUURDQU5JUUFnQmlFRVFRQWhBZ3NnQjBFQ2RpSVFCRUJCd0FBZ0Jtc2hFaUFFUVFGMElRVWdCRUVDZENBR2F5RU9RUUFnQkdzaUQwRUJkQ0VUSUFBZ0JDQUpiQ0FDYW1vZ0JHb2lBQ0FFUVFWc2FpRUNJQUFnQkNBSVFRSnFiR29oQndOQUlBWWhBeUFHQkVBRFFDQUJJQUFnQldvdEFBQWlDQ0FDSUFWcUxRQUFJQUlnQkdvdEFBQWlDaUFDSUJOcUxRQUFJZ2xxSWd0cklBdEJBblJyYWlBQ0xRQUFJZ3dnQWlBUGFpMEFBQ0lMYWtFVWJHcEJFR3BCQlhWQnNDNXFMUUFBSUFVZ0Iyb3RBQUJxUVFGcVFRRjJPZ0F3SUFFZ0FDQUVhaTBBQUNJUklBb2dDU0FMYWtFVWJHb2dDQ0FNYWlJS2F5QUtRUUowYTJwQkVHcEJCWFZCc0M1cUxRQUFJQVFnQjJvdEFBQnFRUUZxUVFGMk9nQWdJQUVnQUMwQUFDSUtJQXdnQ0NBSmFrRVViR29nQ3lBUmFpSU1heUFNUVFKMGEycEJFR3BCQlhWQnNDNXFMUUFBSUFjdEFBQnFRUUZxUVFGMk9nQVFJQUVnQUNBUGFpMEFBQ0FMSUFnZ0VXcEJGR3hxSUFrZ0Ntb2lDR3NnQ0VFQ2RHdHFRUkJxUVFWMVFiQXVhaTBBQUNBSElBOXFMUUFBYWtFQmFrRUJkam9BQUNBSFFRRnFJUWNnQUVFQmFpRUFJQUZCQVdvaEFTQUNRUUZxSVFJZ0EwRi9haUlERFFBTEN5QUJJQkpxSVFFZ0J5QU9haUVISUFJZ0Rtb2hBaUFBSUE1cUlRQWdFRUYvYWlJUURRQUxDeUFOUWNBRGFpUUFDNDhIQVF4L0lBRW9BZ2doQ3lBQktBSUVJUVlDUUFKQUFrQWdBa0VGU3cwQUlBSkJBV3NPQkFBQUFBQUJDeUFBS0FLNEdnMEFEQUVMSUFCQnhBbHFJUVFEUUNBRUlBTVFGQ0VISUFOQkRrc05BU0FEUVFGcUlRTWdCMFVOQUFzTEFrQUNRQUpBQWtBZ0FDZ0NtQWtpQ0FSQUlBQW9BcndKSVFwQkFDRURRUUFoQkFOQUlBb2dBMEhZQVd4cUtBTEVBVVVFUUVFQUlBUkJBV29pQkNBRUlBWkdJZ1ViSVFRZ0JTQUphaUVKSUFOQkFXb2lBeUFJU1EwQkN3c2dBeUFJUncwQkN3SkFBa0FnQWtGK2FpSUNRUVZMRFFBQ1FDQUNRUUZyRGdRQkFRRUJBQXNnQjBVTkFTQUFLQUs0R2tVTkFRd0RDeUFIRFFJTElBRW9BZ0JCZ0FFZ0JpQUxiRUdBQTJ3UUJ4b01BZ3NnQUNnQ3ZBa2dCaUFKYkVIWUFXeHFJUWdnQkFSQUlBUWhBd05BSUFnZ0EwRi9haUlEUWRnQmJHb2lDaUFCSUFrZ0F5QUNJQWNRRmlBS1FRRTJBc1FCSUFBZ0FDZ0N0QWxCQVdvMkFyUUpJQU1OQUFzTElBUkJBV29pQXlBR1NRUkFBMEFnQ0NBRFFkZ0JiR29pQkNnQ3hBRkZCRUFnQkNBQklBa2dBeUFDSUFjUUZpQUVRUUUyQXNRQklBQWdBQ2dDdEFsQkFXbzJBclFKQ3lBRFFRRnFJZ01nQmtjTkFBc0xBa0FnQ1VVTkFDQUdSUTBBUVFBaEJTQUpRWDlxSWd3Z0Jtd2hEU0FNUlFSQUEwQWdBQ2dDdkFrZ0RVSFlBV3hxSUFWQjJBRnNhaUlFSUFGQkFDQUZJQUlnQnhBV0lBUkJBVFlDeEFFZ0FDQUFLQUswQ1VFQmFqWUN0QWtnQlVFQmFpSUZJQVpIRFFBTUFnQUxBQXNnQ1VGK2FpRUlRUUFnQm10QjJBRnNJUTREUUNBQUtBSzhDU0FOUWRnQmJHb2dCVUhZQVd4cUlnTWdBU0FNSUFVZ0FpQUhFQllnQTBFQk5nTEVBU0FBSUFBb0FyUUpRUUZxTmdLMENTQUlJUVFEUUNBRElBNXFJZ01nQVNBRUlnb2dCU0FDSUFjUUZpQURRUUUyQXNRQklBQWdBQ2dDdEFsQkFXbzJBclFKSUFSQmYyb2hCQ0FLRFFBTElBVkJBV29pQlNBR1J3MEFDd3NnQ1VFQmFpSUZJQXRQRFFJZ0JrVU5BZ05BSUFBb0Fyd0pJQVVnQm14QjJBRnNhaUVJUVFBaEF3TkFJQWdnQTBIWUFXeHFJZ1FvQXNRQlJRUkFJQVFnQVNBRklBTWdBaUFIRUJZZ0JFRUJOZ0xFQVNBQUlBQW9BclFKUVFGcU5nSzBDUXNnQTBFQmFpSURJQVpIRFFBTElBVkJBV29pQlNBTFJ3MEFDd3dDQ3lBQktBSUFJQWNnQmlBTGJFR0FBMndRRlJvTElBQWdBQ2dDbUFraUFUWUN0QWtnQVVVTkFDQUFLQUs4Q1NFQVFRQWhBd05BSUFBZ0EwSFlBV3hxUVFFMkFnZ2dBMEVCYWlJRElBRkhEUUFMQ3dzMkFRSi9JQUFvQWlnaUFnUkFBMEFnQUNnQ0JDQUJRUUowYWlBQUtBSUFJQUZCS0d4cU5nSUFJQUZCQVdvaUFTQUNSdzBBQ3dzTDl3UUNESDhCZmtFSElRVWpBRUVnYXlJSUlRd0RRQ0FGSUFGSkJFQWdBRUVBSUFWclFTaHNhaUVLSUFVaEJnTkFJQUFnQmtFb2JHb2lBaWdDQ0NFSklBSXBBZ0FoRGlBSUlBSXBBZ3czQXhnZ0FpZ0NHQ0VOSUFJb0FoUWhDeUFNSUFJb0FpUTJBaEFnQ0NBQ0tRSWNOd01JQWtBZ0JpSURJQVZKRFFBQ1FDQUxSUVJBQTBBZ0NpQURRU2hzSWdKcUlnUW9BaFFOQWlBTlJRMENJQVFvQWhnTkFpQUFJQUpxSWdRZ0FDQURJQVZySWdOQktHeHFJZ0lwQWdBM0FnQWdCQ0FDS1FJZ053SWdJQVFnQWlrQ0dEY0NHQ0FFSUFJcEFoQTNBaEFnQkNBQ0tRSUlOd0lJSUFNZ0JVOE5BQXdEQUFzQUN5QUxRWDlxUVFGTkJFQURRQUovQWtBZ0NpQURRU2hzSWdKcUlnUW9BaFFpQjBVTkFDQUhRWDlxUVFGTERRQWdCQ2dDQ0NJSElBbEtEUVFnQUNBQ2FpSUVJQWNnQ1VnTkFSb2dCQ0VDREFVTElBQWdBbW9MSWdRZ0FDQURJQVZySWdOQktHeHFJZ0lwQWdBM0FnQWdCQ0FDS1FJZ053SWdJQVFnQWlrQ0dEY0NHQ0FFSUFJcEFoQTNBaEFnQkNBQ0tRSUlOd0lJSUFNZ0JVOE5BQXdEQUFzQUN3TkFJQW9nQTBFb2JDSUNhaUlFS0FJVUlnY0VRQ0FIUVg5cVFRSkpEUUlnQkNnQ0NDQUpUQTBDQ3lBQUlBSnFJZ1FnQUNBRElBVnJJZ05CS0d4cUlnSXBBZ0EzQWdBZ0JDQUNLUUlnTndJZ0lBUWdBaWtDR0RjQ0dDQUVJQUlwQWhBM0FoQWdCQ0FDS1FJSU53SUlJQU1nQlU4TkFBc01BUXNnQUNBRFFTaHNhaUVDQ3lBQ0lBNDNBZ0FnQUNBRFFTaHNhaUlESUFrMkFnZ2dDQ2tER0NFT0lBTWdEVFlDR0NBRElBczJBaFFnQXlBT053SU1JQU1nQ0NrRENEY0NIQ0FESUF3b0FoQTJBaVFnQmtFQmFpSUdJQUZIRFFBTEN5QUZRUUYySWdVTkFBc0xyUVVCQVg4Q1FDQUFLQUlBSWdFb0FoUkZEUUFnQVVFQU5nSVVJQUVvQWhnTkFDQUFJQUFvQWl4QmYybzJBaXdMQWtBZ0FTZ0NQRVVOQUNBQlFRQTJBandnQVVGQWF5Z0NBQTBBSUFBZ0FDZ0NMRUYvYWpZQ0xBc0NRQ0FCS0FKa1JRMEFJQUZCQURZQ1pDQUJLQUpvRFFBZ0FDQUFLQUlzUVg5cU5nSXNDd0pBSUFFb0Fvd0JSUTBBSUFGQkFEWUNqQUVnQVNnQ2tBRU5BQ0FBSUFBb0FpeEJmMm8yQWl3TEFrQWdBU2dDdEFGRkRRQWdBVUVBTmdLMEFTQUJLQUs0QVEwQUlBQWdBQ2dDTEVGL2FqWUNMQXNDUUNBQktBTGNBVVVOQUNBQlFRQTJBdHdCSUFFb0F1QUJEUUFnQUNBQUtBSXNRWDlxTmdJc0N3SkFJQUVvQW9RQ1JRMEFJQUZCQURZQ2hBSWdBU2dDaUFJTkFDQUFJQUFvQWl4QmYybzJBaXdMQWtBZ0FTZ0NyQUpGRFFBZ0FVRUFOZ0tzQWlBQktBS3dBZzBBSUFBZ0FDZ0NMRUYvYWpZQ0xBc0NRQ0FCS0FMVUFrVU5BQ0FCUVFBMkF0UUNJQUVvQXRnQ0RRQWdBQ0FBS0FJc1FYOXFOZ0lzQ3dKQUlBRW9BdndDUlEwQUlBRkJBRFlDL0FJZ0FTZ0NnQU1OQUNBQUlBQW9BaXhCZjJvMkFpd0xBa0FnQVNnQ3BBTkZEUUFnQVVFQU5nS2tBeUFCS0FLb0F3MEFJQUFnQUNnQ0xFRi9hallDTEFzQ1FDQUJLQUxNQTBVTkFDQUJRUUEyQXN3RElBRW9BdEFERFFBZ0FDQUFLQUlzUVg5cU5nSXNDd0pBSUFFb0F2UURSUTBBSUFGQkFEWUM5QU1nQVNnQytBTU5BQ0FBSUFBb0FpeEJmMm8yQWl3TEFrQWdBU2dDbkFSRkRRQWdBVUVBTmdLY0JDQUJLQUtnQkEwQUlBQWdBQ2dDTEVGL2FqWUNMQXNDUUNBQktBTEVCRVVOQUNBQlFRQTJBc1FFSUFFb0FzZ0VEUUFnQUNBQUtBSXNRWDlxTmdJc0N3SkFJQUVvQXV3RVJRMEFJQUZCQURZQzdBUWdBU2dDOEFRTkFDQUFJQUFvQWl4QmYybzJBaXdMQTBBZ0FCQmVSUTBBQ3lBQVFRQTJBakFnQUVMLy93TTNBaVFMM1E0QkNYOGdBaWdDQUNBQUtBSUlJZ0lvQWdCR0JFQWdBRUVBTmdJMElBQW9BamdpQzBVaERRSkFJQUZGQkVBZ0FpQUROZ0lNSUFKQkFEWUNGQ0FDSUEwMkFoZ2dBaUFFTmdJUUlBSWdBellDQ0NBTERRRWdBQ0FBS0FJc1FRRnFOZ0lzREFFTElBVUVRQ0FBUWdBM0FoQWdBQkFvQWtBZ0FTZ0NBRVVFUUNBQUtBSTRSUTBCQ3lBQVFnQTNBaEFMSUFBb0FnZ2lBa0VEUVFJZ0FTZ0NCQ0lCR3pZQ0ZDQUFRUUJCLy84RElBRWJOZ0lrSUFJZ0RUWUNHQ0FDUVFBMkFoQWdBa0lBTndJSUlBQkNnWUNBZ0JBM0FpZ01BUXNDUUFKQUFrQWdBU2dDQ0FSQVFRQWhDd05BSUFFZ0MwRVViR29pQ0NnQ0RDSUNRUVpMRFFJQ1FBSkFBa0FDUUFKQUFrQUNRQ0FDUVFGckRnWUFBUUlEQkFVSkN5QUFLQUlZSWdsRkRRZ2dBeUFJS0FJUWF5RU1JQUFvQWdBaENrRUFJUWdEUUFKQUlBb2dDRUVvYkdvaUFpZ0NGRUYvYWtFQlRRUkFJQUlvQWdnZ0RFWU5BUXNnQ0VFQmFpSUlJQWxIRFFFTUNnc0xJQWhCQUVnTkNDQUNRUUEyQWhRZ0FDQUFLQUlvUVg5cU5nSW9JQUlvQWhnTkJTQUFJQUFvQWl4QmYybzJBaXdnQzBFQmFpRUxEQVlMSUFBb0FoZ2lDVVVOQnlBSUtBSVVJUXdnQUNnQ0FDRUtRUUFoQ0FOQUFrQWdDaUFJUVNoc2FpSUNLQUlVUVFOR0JFQWdBaWdDQ0NBTVJnMEJDeUFJUVFGcUlnZ2dDVWNOQVF3SkN3c2dDRUVBU0EwSElBSkJBRFlDRkNBQUlBQW9BaWhCZjJvMkFpZ2dBaWdDR0EwRUlBQWdBQ2dDTEVGL2FqWUNMQ0FMUVFGcUlRc01CUXNnQUNnQ0pDSUNRZi8vQTBZTkJpQUNJQWdvQWhnaURFa05CaUFBS0FJWUlnbEZEUVlnQ0NnQ0VDRU9JQUFvQWdBaENrRUFJUUlEUUFKQUFrQWdDaUFDUVNoc2FpSUlLQUlVUVFOSERRQWdDQ2dDQ0NBTVJ3MEFJQWhCQURZQ0ZDQUFJQUFvQWloQmYybzJBaWdnQ0NnQ0dBMEJJQUFnQUNnQ0xFRi9hallDTEF3QkN5QUNRUUZxSWdJZ0NVY05BUXNMSUFsQkFTQUpRUUZMR3lFSklBTWdEbXNoRGtFQUlRZ0RRQUpBSUFvZ0NFRW9iR29pQWlnQ0ZDSVBRWDlxUVFGTkJFQWdBaWdDQ0NBT1JnMEJDeUFJUVFGcUlnZ2dDVWNOQVF3SUN3c2dDRUVBU0EwR0lBOUJBa2tOQmlBQ1FRTTJBaFFnQWlBTU5nSUlJQXRCQVdvaEN3d0VDeUFBSUFnb0Fod2lDVFlDSkNBQUtBSVlJZ3hGRFFJZ0FDZ0NBQ0VLUVFBaEFpQUpRZi8vQTBZRVFBTkFBa0FnQ2lBQ1FTaHNhaUlJS0FJVVFRTkhEUUFnQ0VFQU5nSVVJQUFnQUNnQ0tFRi9hallDS0NBSUtBSVlEUUFnQUNBQUtBSXNRWDlxTmdJc0N5QUNRUUZxSWdJZ0RFY05BQXdFQUFzQUN3TkFBa0FnQ2lBQ1FTaHNhaUlJS0FJVVFRTkhEUUFnQ0NnQ0NDQUpUUTBBSUFoQkFEWUNGQ0FBSUFBb0FpaEJmMm8yQWlnZ0NDZ0NHQTBBSUFBZ0FDZ0NMRUYvYWpZQ0xBc2dBa0VCYWlJQ0lBeEhEUUFMREFJTElBQVFLQ0FBUVFFMkFqUkJBQ0VESUF0QkFXb2hDd3dDQ3lBQUtBSWtJZ0pCLy84RFJnMERJQUlnQ0NnQ0dDSU1TUTBESUFBb0FoZ2lDa1VOQXlBQUtBSUFJUWhCQUNFQ0FrQURRQUpBSUFnZ0FrRW9iR29pQ1NnQ0ZFRURSdzBBSUFrb0FnZ2dERWNOQUNBSlFRQTJBaFFnQUNBQUtBSW9RWDlxSWdnMkFpZ2dDU2dDR0EwQ0lBQWdBQ2dDTEVGL2FqWUNMQXdDQ3lBQ1FRRnFJZ0lnQ2tjTkFBc2dBQ2dDS0NFSUN5QUlJQXBQRFFNZ0FDZ0NDQ0lDUVFNMkFoUWdBaUFFTmdJUUlBSWdERFlDQ0NBQ0lBTTJBZ3dnQWlBQUtBSTRSVFlDR0VFQklSQWdBQ0FJUVFGcU5nSW9JQUFnQUNnQ0xFRUJhallDTEFzZ0MwRUJhaUVMREFBQUN3QUxRUUFoQWlBQUtBSW9JZ2tnQUNnQ0dDSUxTUTBCSUFsRkJFQkJBQ0VKREFJTElBQW9BZ0FoREVGL0lRRURRQ0FNSUFKQktHeHFJZ29vQWhSQmYycEJBVTBFUUNBS0tBSUlJZ29nQ0NBQlFYOUdJQW9nQ0VoeUlnb2JJUWdnQWlBQklBb2JJUUVMSUFKQkFXb2lBaUFKUncwQUN5QUJRUUJJRFFFZ0RDQUJRU2hzYWlJQlFRQTJBaFFnQUNBSlFYOXFJZ2syQWlnZ0FTZ0NHQTBCSUFBZ0FDZ0NMRUYvYWpZQ0xBd0JDeUFRRFFFZ0FDZ0NHQ0VMSUFBb0FpZ2hDUXNnQ1NBTFR3MEJJQUFvQWdnaUFTQU5OZ0lZSUFGQkFqWUNGQ0FCSUFRMkFoQWdBU0FETmdJSUlBRWdBellDRENBQUlBbEJBV28yQWlnZ0FDQUFLQUlzUVFGcU5nSXNDd3NnQUNnQ0NDSUJJQWMyQWlBZ0FTQUdOZ0ljSUFFZ0JUWUNKQUpBSUFBb0FqaEZCRUFnQUNnQ0xDSUpJQUFvQWh3aUEwME5BU0FBS0FJQUlRUURRRUgvLy8vL0J5RUZRUUFoQmtFQUlRSURRQ0FFSUFKQktHeHFJZ0VvQWhnRVFDQUJJQVlnQVNnQ0VDSUJJQVZJSWdjYklRWWdBU0FGSUFjYklRVUxJQUpCQVdvaUFpQURUUTBBQ3dKQUlBWkZEUUFnQUNnQ0RDQUFLQUlRSWdKQkJIUnFJZ0VnQmlnQ0FEWUNBQ0FCSUFZb0FpUTJBZ3dnQVNBR0tBSWNOZ0lFSUFFZ0JpZ0NJRFlDQ0NBQUlBSkJBV28yQWhBZ0JrRUFOZ0lZSUFZb0FoUU5BQ0FBSUFsQmYyb2lDVFlDTEFzZ0NTQURTdzBBQ3d3QkN5QUJLQUlBSVFJZ0FDZ0NEQ0FBS0FJUUlnTkJCSFJxSWdFZ0JUWUNEQ0FCSUFJMkFnQWdBU0FITmdJSUlBRWdCallDQkNBQUlBTkJBV28yQWhBZ0FDZ0NIQ0VEQ3lBQUtBSUFJQU5CQVdvUUp3c0wxQXNDQW44QmZpTUFRWkFCYXlJRUpBQWdCRUVBTmdJTUFrQUNRQUpBSUFBb0FwQWFSUTBBSUFBb0FwUWFJQUZIRFFBZ0JDQUFRYVFhYWlrQ0FEY0RHQ0FBS1FLY0dpRUdJQVJCQURZQ0dDQUVJQVkzQXhBZ0JFRUFOZ0lnSUFRZ0JqNENGQ0FESUFBb0FwZ2FOZ0lBREFFTFFRTWhCU0FCSUFJZ0JFRVFhaUFERUdVTkFTQUFJQVFwQXhBM0Fwd2FJQUJCckJwcUlBUW9BaUEyQWdBZ0FFR2tHbW9nQkNrREdEY0NBQ0FES0FJQUlRSWdBQ0FCTmdLVUdpQUFJQUkyQXBnYUMwRUFJUVVnQUVFQU5nS1FHaUFFUVJCcUlBUkJpQUZxRUU4RVFFRURJUVVNQVFzZ0JDZ0NpQUZCZjJwQkMwc05BQ0FFUVJCcUlBUkJpQUZxSUFBZ0JFRU1haEF5SWdFRVFFRUVJUVVnQVVIdy93TkdEUUZCQXlFRkRBRUxBa0FnQkNnQ0RBUkFBa0FnQUNnQ29BbEZEUUFnQUNnQ0VFVU5BRUVESVFVZ0FDZ0N0Qm9OQXdKQUlBQW9BcVFKUlFSQUlBQkJ4QWxxSWdJaUFTQUJLQUlBSUFFb0FoeEJLR3hxSWdFMkFnZ2dBQ0FCS0FJQU5nSzRDaUFDRUNZZ0FDQUFRYmdLYWtFQUVDVU1BUXNnQUNBQVFiZ0thaUFBUWR3S2FpZ0NBQkFsQ3lBRFFRQTJBZ0FnQUVFQU5nS2NDU0FBUVFFMkFwQWFEQUlMSUFCQkFEWUNuQWtnQUVFQU5nS2tDUXNnQkNnQ2lBRkJmMm9pQVVFSFN3MEJBa0FDUUFKQUlBRkJBV3NPQndRRUJBSUVBQUVDQ3lBRVFSQnFJQVJCS0dvUVF3UkFJQVFvQWxBUUJDQUVRUUEyQWxBZ0JDZ0NmQkFFSUFSQkFEWUNmRUVESVFVTUJBc2dBQ0FFUVNocUVEY01Bd3NnQkVFUWFpQUVRU2hxRUV3RVFDQUVLQUk4RUFRZ0JFRUFOZ0k4SUFRb0FrQVFCQ0FFUVFBMkFrQWdCQ2dDUkJBRUlBUkJBRFlDUkNBRUtBSlVFQVFnQkVFQU5nSlVRUU1oQlF3REN5QUFJQVJCS0dvUU5nd0NDeUFBS0FLY0NRMEJJQUJCQVRZQ29Ba0NRQ0FBS0FLa0NRMEFJQUJDQURjQ3RBa2dCRUVRYWlBRVFTaHFFQ0FhSUFBb0FnZ2hBU0FBSUFRb0FpZ2dCQ2dDaUFGQkJVWVFOU0lDQkVBZ0FFS0Fnb0NBZ0FRM0FnUWdBRUVBTmdLMEdpQUFRZ0EzQWd4QkJVRUVJQUpCLy84RFJoc2hCUXdEQ3lBQklBQW9BZ2hHRFFBZ0FDZ0NFQ0VCSUFSQkFUWUNDQ0FBS0FJQUlnSkJIMDBFUUNBQUlBSkJBblJxS0FJVUlRVUxJQU5CQURZQ0FDQUFRUUUyQXBBYUFrQUNRQUpBSUFRb0FvZ0JRUVZIRFFBZ0JFRUlhaUFFUVJCcUlBRWdBQ2dDREJBNElBUW9BZ2h5RFFBZ0JVVU5BQ0FBUWZ3SmFpZ0NBQTBBSUFVb0FqUWdBU2dDTkVjTkFDQUZLQUk0SUFFb0FqaEhEUUFnQlNnQ1dDQUJLQUpZUmcwQkN5QUFRWUFLYWtFQU5nSUFEQUVMSUFCQnhBbHFFRmtMSUFBZ0FDZ0NDRFlDQUVFQ0lRVU1BZ3NnQUNnQ3RCb0VRRUVESVFVTUFnc2dCRUVRYWlBQVFiUVNhaUlDSUFBb0FoQWdBQ2dDRENBRVFZZ0JhaEErQkVCQkF5RUZEQUlMSUFBb0FxUUpSUVJBQWtBZ0JDZ0NpQUZCQlVZTkFDQUFRY1FKYWlBQVFjQVNhaWdDQUNBRUtBS01BVUVBUnlBQUtBSVFLQUl3RUZwRkRRQkJBeUVGREFNTElBQkJ4QWxxSWdFZ0FTZ0NBQ0FCS0FJY1FTaHNhaUlCTmdJSUlBQWdBU2dDQURZQ3VBb0xJQUJCMkFwcUlBSkIzQWNRRlNFQklBQkJBVFlDcEFrZ0FDQUVLUU9JQVRjQzBBb2dBQ2dDbEFrZ0FDZ0NEQ0FBUVpnTGFpZ0NBQ0FBS0FJUUlnSW9BalFnQWlnQ09CQS9JQUJCeEFscUlnSVFKaUFDSUFCQm5BdHFJQUJCNUFwcUtBSUFJQUJCaEF0cUtBSUFFRjhFUUVFRElRVU1BZ3NnQkVFUWFpQUFJQUJCdUFwcUlBRVFRUVJBSUFBZ0FDZ0MyQW9RUUVFRElRVU1BZ3NnQUJBelJRMEJJQUJCQVRZQ25Ba0xJQUJCdUFwcUlnRWdBQ2dDdkFrUVNTQUFFRFFnQUVHRUNtb2dBQ2dDRUNBQVFkZ0thaUFBUWRBS2FoQk5JUUlDUUNBQUtBS2tDVVVOQUNBQVFjUUphaUVESUFCQjFBcHFLQUlBQkVBZ0F5QUFRZXdNYWlBQklBQkI1QXBxS0FJQUlBSWdBQ2dDMEFwQkJVWWdBQ2dDdUFrZ0FDZ0N0QWtRS1F3QkN5QURRUUFnQVNBQVFlUUthaWdDQUNBQ0lBQW9BdEFLUVFWR0lBQW9BcmdKSUFBb0FyUUpFQ2tMSUFCQ0FEY0NvQWxCQVNFRkN5QUVRWkFCYWlRQUlBVUxxQXdCQzM4Q1FDQUJRUVJQQkVCQkFDQURheUlOUVFGMElRb0NRQ0FBSUFOcklnVXRBQUFpQmlBQUxRQUFJZ2hySWdFZ0FVRWZkU0lCYWlBQmN5QUNLQUlFSWdGUERRQWdBQ0FLYWkwQUFDSUhJQVpySWdRZ0JFRWZkU0lFYWlBRWN5QUNLQUlJSWd4UERRQWdBQ0FEYWkwQUFDSUVJQWhySWdzZ0MwRWZkU0lMYWlBTGN5QU1UdzBBSUFVZ0JDQUdhaUFIUVFGMGFrRUNha0VDZGpvQUFDQUFJQWdnQkVFQmRHb2dCMnBCQW1wQkFuWTZBQUFnQWlnQ0JDRUJDd0pBSUFCQkFXb2lCaUFOYWlJTUxRQUFJZ2dnQUMwQUFTSUhheUlFSUFSQkgzVWlCR29nQkhNZ0FVOE5BQ0FHSUFwcUxRQUFJZ1FnQ0dzaUJTQUZRUjkxSWdWcUlBVnpJQUlvQWdnaUMwOE5BQ0FESUFacUxRQUFJZ1VnQjJzaUNTQUpRUjkxSWdscUlBbHpJQXRQRFFBZ0RDQUZJQWhxSUFSQkFYUnFRUUpxUVFKMk9nQUFJQVlnQnlBRlFRRjBhaUFFYWtFQ2FrRUNkam9BQUNBQ0tBSUVJUUVMQWtBZ0FFRUNhaUlHSUExcUlnd3RBQUFpQ0NBQUxRQUNJZ2RySWdRZ0JFRWZkU0lFYWlBRWN5QUJUdzBBSUFZZ0Ntb3RBQUFpQkNBSWF5SUZJQVZCSDNVaUJXb2dCWE1nQWlnQ0NDSUxUdzBBSUFNZ0Jtb3RBQUFpQlNBSGF5SUpJQWxCSDNVaUNXb2dDWE1nQzA4TkFDQU1JQVVnQ0dvZ0JFRUJkR3BCQW1wQkFuWTZBQUFnQmlBSElBVkJBWFJxSUFScVFRSnFRUUoyT2dBQUlBSW9BZ1FoQVFzQ1FDQUFRUU5xSWdZZ0RXb2lEQzBBQUNJSUlBQXRBQU1pQjJzaUJDQUVRUjkxSWdScUlBUnpJQUZQRFFBZ0JpQUthaTBBQUNJRUlBaHJJZ1VnQlVFZmRTSUZhaUFGY3lBQ0tBSUlJZ3RQRFFBZ0F5QUdhaTBBQUNJRklBZHJJZ2tnQ1VFZmRTSUphaUFKY3lBTFR3MEFJQXdnQlNBSWFpQUVRUUYwYWtFQ2FrRUNkam9BQUNBR0lBY2dCVUVCZEdvZ0JHcEJBbXBCQW5ZNkFBQWdBaWdDQkNFQkN3SkFJQUJCQkdvaUJpQU5haUlNTFFBQUlnZ2dBQzBBQkNJSGF5SUVJQVJCSDNVaUJHb2dCSE1nQVU4TkFDQUdJQXBxTFFBQUlnUWdDR3NpQlNBRlFSOTFJZ1ZxSUFWeklBSW9BZ2dpQzA4TkFDQURJQVpxTFFBQUlnVWdCMnNpQ1NBSlFSOTFJZ2xxSUFseklBdFBEUUFnRENBRklBaHFJQVJCQVhScVFRSnFRUUoyT2dBQUlBWWdCeUFGUVFGMGFpQUVha0VDYWtFQ2Rqb0FBQ0FDS0FJRUlRRUxBa0FnQUVFRmFpSUdJQTFxSWd3dEFBQWlDQ0FBTFFBRklnZHJJZ1FnQkVFZmRTSUVhaUFFY3lBQlR3MEFJQVlnQ21vdEFBQWlCQ0FJYXlJRklBVkJIM1VpQldvZ0JYTWdBaWdDQ0NJTFR3MEFJQU1nQm1vdEFBQWlCU0FIYXlJSklBbEJIM1VpQ1dvZ0NYTWdDMDhOQUNBTUlBVWdDR29nQkVFQmRHcEJBbXBCQW5ZNkFBQWdCaUFISUFWQkFYUnFJQVJxUVFKcVFRSjJPZ0FBSUFJb0FnUWhBUXNDUUNBQVFRWnFJZ1lnRFdvaURDMEFBQ0lJSUFBdEFBWWlCMnNpQkNBRVFSOTFJZ1JxSUFSeklBRlBEUUFnQmlBS2FpMEFBQ0lFSUFocklnVWdCVUVmZFNJRmFpQUZjeUFDS0FJSUlndFBEUUFnQXlBR2FpMEFBQ0lGSUFkcklna2dDVUVmZFNJSmFpQUpjeUFMVHcwQUlBd2dCU0FJYWlBRVFRRjBha0VDYWtFQ2Rqb0FBQ0FHSUFjZ0JVRUJkR29nQkdwQkFtcEJBblk2QUFBZ0FpZ0NCQ0VCQ3lBTklBQkJCMm9pRFdvaUNDMEFBQ0lHSUFBdEFBY2lBR3NpQnlBSFFSOTFJZ2RxSUFkeklBRlBEUUVnQ2lBTmFpMEFBQ0lCSUFacklnb2dDa0VmZFNJS2FpQUtjeUFDS0FJSUlncFBEUUVnQXlBTmFpMEFBQ0lDSUFCcklnTWdBMEVmZFNJRGFpQURjeUFLVHcwQklBZ2dBaUFHYWlBQlFRRjBha0VDYWtFQ2Rqb0FBQ0FOSUFBZ0FrRUJkR29nQVdwQkFtcEJBblk2QUFBUEMwRUFJQU5ySWdkQkFYUWhCQ0FCSUFJb0FnQnFRWDlxTFFBQUlnRkJBV29oQmlBQlFYOXpJUWhCQ0NFQkEwQUNRQ0FBSUFkcUlnVXRBQUFpQ2lBQUxRQUFJZzFySWd3Z0RFRWZkU0lNYWlBTWN5QUNLQUlFVHcwQUlBQWdCR290QUFBaURDQUtheUlMSUF0QkgzVWlDMm9nQzNNZ0FpZ0NDQ0lMVHcwQUlBQWdBMm90QUFBaUNTQU5heUlPSUE1QkgzVWlEbW9nRG5NZ0MwOE5BQ0FGSUFvZ0NDQUdJQTBnQ210QkFuUWdDV3NnREdwQkJHcEJBM1VpQ2lBS0lBWktHeUFLSUFoSUd5SUtha0d3TG1vdEFBQTZBQUFnQUNBTklBcHJRYkF1YWkwQUFEb0FBQXNnQUVFQmFpRUFJQUZCZjJvaUFRMEFDd3NMNmdnQkFuOGdBVUVBUWJnSEVBY2hBa0VCSVFFQ1FBSkFJQUJCQVJBRElnTkJmMFlOQUNBQ0lBTkJBVVkyQWdBQ1FDQURRUUZIRFFBZ0FFRUlFQU1pQTBGL1JnMEJJQUlnQXpZQ0JDQURRZjhCUncwQUlBQkJFQkFESWdOQmYwWU5BU0FDSUFNMkFnZ2dBRUVRRUFNaUEwRi9SZzBCSUFJZ0F6WUNEQXNnQUVFQkVBTWlBMEYvUmcwQUlBSWdBMEVCUmpZQ0VDQURRUUZHQkVBZ0FFRUJFQU1pQTBGL1JnMEJJQUlnQTBFQlJqWUNGQXNnQUVFQkVBTWlBMEYvUmcwQUlBSWdBMEVCUmpZQ0dBSkFBa0FnQTBFQlJnUkFJQUJCQXhBRElnTkJmMFlOQXlBQ0lBTTJBaHdnQUVFQkVBTWlBMEYvUmcwRElBSWdBMEVCUmpZQ0lDQUFRUUVRQXlJRFFYOUdEUU1nQWlBRFFRRkdOZ0lrSUFOQkFVY05BU0FBUVFnUUF5SURRWDlHRFFNZ0FpQUROZ0lvSUFCQkNCQURJZ05CZjBZTkF5QUNJQU0yQWl3Z0FFRUlFQU1pQTBGL1J3MENEQU1MSUFKQkJUWUNIQXNnQWtLQ2dJQ0FJRGNDS0VFQ0lRTUxJQUlnQXpZQ01DQUFRUUVRQXlJRFFYOUdEUUFnQWlBRFFRRkdOZ0kwQWtBZ0EwRUJSdzBBSUFBZ0FrRTRhaEFDSWdFTkFTQUNLQUk0UVFWTERRSWdBQ0FDUVR4cUVBSWlBUTBCSUFJb0FqeEJCVTBOQUF3Q0MwRUJJUUVnQUVFQkVBTWlBMEYvUmcwQUlBSWdBMEVCUmpZQ1FDQURRUUZHQkVBZ0FCQVBJUUVnQUVFZ0VBc2hBeUFCUlEwQ0lBTkJmMFlOQWlBQ0lBRTJBa1FnQUJBUElRRWdBRUVnRUFzaEF5QUJSUTBDSUFOQmYwWU5BaUFDSUFFMkFraEJBU0VCSUFCQkFSQURJZ05CZjBZTkFTQUNJQU5CQVVZMkFrd0xJQUJCQVJBRElnTkJmMFlOQUNBQ0lBTkJBVVkyQWxBQ1FDQURRUUZHQkVBZ0FDQUNRZFFBYWhBY0lnRkZEUUVNQWdzZ0FrRUJOZ0pVSUFKQ21JQ0FnSUFETndMb0F5QUNRcGlBZ0lDQUF6Y0M0QU1nQWtHQmtLcUpBVFlDNEFFZ0FrR0JrS3FKQVRZQ1lBdEJBU0VCSUFCQkFSQURJZ05CZjBZTkFDQUNJQU5CQVVZMkF2QURBa0FnQTBFQlJnUkFJQUFnQWtIMEEyb1FIQ0lCUlEwQkRBSUxJQUpCQVRZQzlBTWdBa0tZZ0lDQWdBTTNBb2dISUFKQ21JQ0FnSUFETndLQUJ5QUNRWUc0dVBJQU5nS0FCU0FDUVlHNHVQSUFOZ0tBQkFzQ1FDQUNLQUpRUlFSQUlBSW9BdkFEUlEwQkMwRUJJUUVnQUVFQkVBTWlBMEYvUmcwQklBSWdBMEVCUmpZQ2tBY0xRUUVoQVNBQVFRRVFBeUlEUVg5R0RRQWdBaUFEUVFGR05nS1VCeUFBUVFFUUF5SURRWDlHRFFBZ0FpQURRUUZHTmdLWUJ3SkFJQU5CQVVZRVFDQUFRUUVRQXlJRFFYOUdEUUlnQWlBRFFRRkdOZ0tjQnlBQUlBSkJvQWRxRUFJaUFRMENJQUlvQXFBSFFSQkxEUU1nQUNBQ1FhUUhhaEFDSWdFTkFpQUNLQUtrQjBFUVN3MERJQUFnQWtHb0Iyb1FBaUlCRFFJZ0FpZ0NxQWRCRUVzTkF5QUFJQUpCckFkcUVBSWlBUTBDUVFFaEFTQUNLQUtzQjBFUVN3MENJQUFnQWtHd0Iyb1FBaUlCRFFJZ0FDQUNRYlFIYWhBQ0lnRkZEUUVNQWdzZ0FrRVFOZ0swQnlBQ1FwQ0FnSUNBQWpjQ3JBY2dBa0tCZ0lDQWdBSTNBcVFISUFKQ2dZQ0FnQ0EzQXB3SEMwRUFJUUVMSUFFUEMwRUJDMDBCQW44akFFRVFheUlESkFCQkFTRUVBa0FnQUNBRFFReHFFQUlOQUNBREtBSU1JZ0JCTDBzTkFDQUJRZEEvUVlEQUFDQUNHeUFBYWkwQUFEWUNBRUVBSVFRTElBTkJFR29rQUNBRUN6NEJBbjhDUUNBQUtBSU1RUU4wSUFBb0FoQnJJZ0ZGQkVBTUFRdEJBU0VDSUFGQkNFc05BRUVCSUFGQmYycDBJQUFRRDBFZ0lBRnJka2NQQ3lBQ0N6SUJBbjhDUUVHQWdJREFBQ0lCSUFCeERRQURRQ0FDUVFGcUlRSWdBVUVCZGlJQlJRMEJJQUFnQVhGRkRRQUxDeUFDQzRvQ0FRZC9JQUZCb0QxcUxRQUFRUXhzUWRBOGFpZ0NBQ0VDUVFFaEF5QUJRUVpQQkVCQkFDRURJQUlnQVVHUVBHb3RBQUJCZjJwMElRSUxJQUFnQUNnQ0FDSUJJQUFvQWdnaUJHc2lCU0FBS0FJRUlnWWdBQ2dDRENJSGF5SUlheUFDYkNBRGRUWUNEQ0FBSUFVZ0NHb2dBbXdnQTNVMkFnZ2dBQ0FCSUFScUlnRWdCaUFIYWlJRWF5QUNiQ0FEZFRZQ0JDQUFJQUVnQkdvZ0Ftd2dBM1UyQWdBZ0FDQUFLQUljSWdFZ0FDZ0NGQ0lFYWlJRklBQW9BaGdpQmlBQUtBSVFJZ2RxSWdocUlBSnNJQU4xTmdJUUlBQWdCQ0FCYXlJQklBY2dCbXNpQkdvZ0Ftd2dBM1UyQWhnZ0FDQUlJQVZySUFKc0lBTjFOZ0lVSUFBZ0JDQUJheUFDYkNBRGRUWUNIQXZQQ0FFVWZ5QUFJQUFvQWl3aUFpQUFLQUlNSWdacUlnVWdBQ2dDTkNJRUlBQW9BaUFpRUdvaUNtc2lFVFlDTENBQUtBSW9JUU1nQUNBR0lBSnJJZ2NnRUNBRWF5SUVheUlHTmdJb0lBQW9BaVFoQWlBQUlBUWdCMm9pQkRZQ0pDQUFJQVVnQ21vaUJUWUNJQ0FBSUFBb0Fod2lDaUFBS0FJSUlnZHFJZ2dnQUNnQ01DSU1JQUFvQWhBaUNXb2lDMnNpRURZQ0hDQUFLQUlZSVE4Z0FDQUhJQXBySWdjZ0NTQU1heUlNYXlJS05nSVlJQUFvQWhRaENTQUFJQWNnREdvaUJ6WUNGQ0FBSUFnZ0Myb2lDRFlDRUNBQUlBa2dBQ2dDQUNJTGFpSVNJQThnQUNnQ0JDSU5haUlPYXlJTU5nSU1JQUFnQ3lBSmF5SUpJQTBnRDJzaUMyc2lEellDQ0NBQUlBa2dDMm9pQ1RZQ0JDQUFJQTRnRW1vaUN6WUNBQ0FBSUFJZ0FDZ0NPQ0lOYWlJVElBTWdBQ2dDUENJT2FpSVVheUlTTmdJOElBQWdBaUFOYXlJQ0lBTWdEbXNpQTJzaURUWUNPQ0FBSUFJZ0Eyb2lEallDTkNBQUlCTWdGR29pRXpZQ01DQUJRWkE4YWkwQUFDRUNJQUZCb0QxcUxRQUFRUXhzUWRBOGFpZ0NBQ0VESUFGQkRFOEVRQ0FBSUFNZ0FrRithblFpQVNBRklBdHFJZ01nQ0NBVGFpSUNhMncyQWpBZ0FDQUxJQVZySWdVZ0NDQVRheUlJYXlBQmJEWUNJQ0FBSUFVZ0NHb2dBV3cyQWhBZ0FDQUNJQU5xSUFGc05nSUFJQUFnQkNBSmFpSURJQWNnRG1vaUFtc2dBV3cyQWpRZ0FDQUpJQVJySWdRZ0J5QU9heUlGYXlBQmJEWUNKQ0FBSUFRZ0JXb2dBV3cyQWhRZ0FDQUNJQU5xSUFGc05nSUVJQUFnQmlBUGFpSURJQW9nRFdvaUFtc2dBV3cyQWpnZ0FDQVBJQVpySWdZZ0NpQU5heUlFYXlBQmJEWUNLQ0FBSUFRZ0Jtb2dBV3cyQWhnZ0FDQUNJQU5xSUFGc05nSUlJQUFnRENBUmF5SURJQkFnRW1zaUFtc2dBV3cyQWl3Z0FDQUNJQU5xSUFGc05nSWNJQUFnRUNBU2FpSURJQXdnRVdvaUFtb2dBV3cyQWd3Z0FDQUNJQU5ySUFGc05nSThEd3NnQUVFQlFRSWdBVUY2YWtFR1NSc2lBU0FGSUF0cUloUWdDQ0FUYWlJVmF5QURiR3BCQWlBQ2F5SUNkVFlDTUNBQUlBc2dCV3NpQlNBSUlCTnJJZ2hySUFOc0lBRnFJQUoxTmdJZ0lBQWdCU0FJYWlBRGJDQUJhaUFDZFRZQ0VDQUFJQlFnRldvZ0Eyd2dBV29nQW5VMkFnQWdBQ0FFSUFscUlnVWdCeUFPYWlJSWF5QURiQ0FCYWlBQ2RUWUNOQ0FBSUFrZ0JHc2lCQ0FISUE1cklnZHJJQU5zSUFGcUlBSjFOZ0lrSUFBZ0JDQUhhaUFEYkNBQmFpQUNkVFlDRkNBQUlBVWdDR29nQTJ3Z0FXb2dBblUyQWdRZ0FDQUdJQTlxSWdRZ0NpQU5haUlGYXlBRGJDQUJhaUFDZFRZQ09DQUFJQThnQm1zaUJpQUtJQTFySWdwcklBTnNJQUZxSUFKMU5nSW9JQUFnQmlBS2FpQURiQ0FCYWlBQ2RUWUNHQ0FBSUFRZ0JXb2dBMndnQVdvZ0FuVTJBZ2dnQUNBTUlCRnJJZ1lnRUNBU2F5SUVheUFEYkNBQmFpQUNkVFlDTENBQUlBUWdCbW9nQTJ3Z0FXb2dBblUyQWh3Z0FDQVFJQkpxSWdZZ0RDQVJhaUlSYWlBRGJDQUJhaUFDZFRZQ0RDQUFJQkVnQm1zZ0Eyd2dBV29nQW5VMkFqd0x2UVVCQm44akFFRWdheUlGSkFBZ0EwRUFOZ0lBQWtBZ0FTZ0NBQ0lHUVJKTERRQkJBU0FHZENJR1FjRGZIM0ZGQkVBZ0JrRWljVVVOQVNBQ1FiUUthaWdDQUFSQUlBTkJBVFlDQUNBQ1FRQTJBclFLQ3lBQUlBVkJIR29RSUNJRURRRkI4UDhESVFRZ0FpQUZLQUljUVFKMGFpZ0NsQUVpQ0VVTkFTQUNJQWdvQWdRaUJrRUNkR29vQWhRaUIwVU5BUUpBSUFJb0FnZ2lDVUVnUmcwQUlBWWdDVVlOQUNBQktBSUFRUVZIRFFJTEFrQWdBa0dZQ21vb0FnQWlCQ0FCS0FJRUlnWkdEUUFnQkVFQUlBWWJEUUFnQTBFQk5nSUFDeUFCS0FJQUlRUUNRQUpBSUFJb0FwUUtRUVZHQkVBZ0JFRUZSdzBCREFJTElBUkJCVWNOQVFzZ0EwRUJOZ0lBQzBFQklRUWdBQ0FIS0FJTUlBVkJHR29RUFEwQklBVW9BaGdpQmlBQ1Fad0thaWdDQUVjRVFDQUNJQVkyQXB3S0lBTkJBVFlDQUFzZ0FTZ0NBRUVGUmdSQUlBQWdCeWdDRENBRlFSUnFFRHdOQWdKQUlBSW9BcFFLUVFWSEJFQWdCU2dDRkNFRURBRUxJQUpCb0FwcUtBSUFJZ1FnQlNnQ0ZDSUdSZzBBSUFOQkFUWUNBQ0FHSVFRTElBSkJvQXBxSUFRMkFnQUxBa0FnQnlnQ0VDSUVRUUZMRFFBZ0JFRUJhd1JBUVFFaEJDQUFJQWNnQVNnQ0FDQUZRUWhxRURzTkF5QUZLQUlJSWdRZ0FrR2tDbW9vQWdCSEJFQWdBaUFFTmdLa0NpQURRUUUyQWdBTElBZ29BZ2hGRFFFZ0FDQUhJQUVvQWdBZ0JVRVFhaEE2SWdRTkF5QUZLQUlRSWdBZ0FrR29DbW9vQWdCR0RRRWdBaUFBTmdLb0NpQURRUUUyQWdBTUFRc2dCeWdDR0EwQUlBQWdCeUFCS0FJQUlBZ29BZ2dnQlVFSWFoQTVJZ1FOQWlBRktBSUlJZ0FnQWtHc0Ntb29BZ0JIQkVBZ0FpQUFOZ0tzQ2lBRFFRRTJBZ0FMSUFnb0FnaEZEUUFnQlNnQ0RDSUFJQUpCc0FwcUtBSUFSZzBBSUFJZ0FEWUNzQW9nQTBFQk5nSUFDeUFDSUFFcEFnQTNBcFFLUVFBaEJBd0JDeUFEUVFFMkFnQUxJQVZCSUdva0FDQUVDMzhCQTM4Q1FBSkFBa0FnQUVIOENtb29BZ0FFUUNBQUtBS1lDU0lERFFGQkFROExRUUVoQVNBQVFhd0phaWdDQUNBQUtBS1lDVWNOQVF3Q0N5QUFLQUs4Q1NFQlFRQWhBQU5BSUFJZ0FTQUFRZGdCYkdvb0FzUUJRUUJIYWlFQ0lBQkJBV29pQUNBRFJ3MEFDMEVCSVFFZ0FpQURSZzBCQzBFQUlRRUxJQUVMU2dFRGZ5QUFRZ0EzQXFnSklBQW9BcGdKSWdFRVFDQUFLQUs4Q1NFQ1FRQWhBQU5BSUFJZ0FFSFlBV3hxSWdOQkFEWUN4QUVnQTBFQU5nSUVJQUJCQVdvaUFDQUJSdzBBQ3dzTGd3WUJESDlCQVNFR0FrQWdBQ0FCUVFKMGFpZ0NsQUVpQkVVTkFDQUFJQVFvQWdRaUNVRUNkR29pQ2tFVWFpZ0NBQ0lEUlEwQUFrQWdCQ2dDRENJRlFRSkpEUUFnQXlnQ05DSUhJQU1vQWpoc0lRZ0NRQ0FFS0FJUUlnTkJBa3NOQUFKQUFrQUNRQ0FEUVFGckRnSURBQUVMSUFWQmYyb2hDeUFFS0FJY0lRd2dCQ2dDR0NFTlFRQWhBd3dCQ3lBRUtBSVVJUWRCQUNFREEwQWdCeUFEUVFKMGFpZ0NBQ0FJVFFSQUlBVWdBMEVCYWlJRFJ3MEJEQVFMQzBFQkR3c0RRQ0FOSUFOQkFuUWlCV29vQWdBaURpQUZJQXhxS0FJQUlnVkxEUU1nQlNBSVR3MERJQTRnQjNBZ0JTQUhjRTBFUUNBRFFRRnFJZ01nQzBZTkF3d0JDd3RCQVE4TElBTkJmV3BCQWswRVFDQUVLQUlrSUFoTkRRRU1BZ3NnQTBFR1J3MEFJQVFvQWlnZ0NFa05BUXNDUUNBQUtBSUVJZ05CZ0FKR0JFQWdBQ0FFTmdJTUlBQWdBVFlDQkNBQUlBazJBZ2dnQUNBS0tBSVVJZ0UyQWhBZ0FTZ0NOQ0VDSUFFb0FqZ2hBU0FBUVFFMkFyUWFJQUJCd0FwcUlBRTJBZ0FnQUVHOENtb2dBallDQUNBQUlBRWdBbXcyQXBnSkRBRUxJQUFvQXJRYUJFQWdBRUVBTmdLMEdpQUFLQUs4Q1JBRUlBQkJBRFlDdkFrZ0FDZ0NsQWtRQkNBQUlBQW9BcGdKSWdGQjJBRnNJZ1FRQ2lJQ05nSzhDU0FBSUFGQkFuUVFDaUlETmdLVUNVSC8vd01oQmlBQ1JRMENJQU5GRFFJZ0FrRUFJQVFRQnlBQUtBSVFLQUkwSUFFUVRpQUFLQUlRSVFGQkFTRUNBa0FnQUNnQ3dBa05BQ0FCS0FJUVFRSkdEUUFDUUNBQktBSlFSUTBBSUFFb0FsUWlCQ2dDbUFkRkRRQWdCQ2dDc0FkRkRRRUxRUUFoQWdzZ0FFSEVDV29nQVNnQ09DQUJLQUkwYkNBQktBSllJQUVvQWl3Z0FTZ0NEQ0FDRUZ3aUJrVU5BUXdDQ3lBQklBTkdEUUFnQUNnQ0NDQUpSd1JBSUFKRkRRSWdBQ0FFTmdJTUlBQWdBVFlDQkNBQUlBazJBZ2dnQUNBS0tBSVVJZ0UyQWhBZ0FTZ0NOQ0VDSUFFb0FqZ2hBU0FBUVFFMkFyUWFJQUJCd0FwcUlBRTJBZ0FnQUVHOENtb2dBallDQUNBQUlBRWdBbXcyQXBnSkRBRUxJQUFnQkRZQ0RDQUFJQUUyQWdRTFFRQWhCZ3NnQmd1MkFRRURmd0pBSUFBZ0FTZ0NBQ0lEUVFKMGFpSUNLQUtVQVNJRVJRUkFJQUpCeUFBUUNpSUFOZ0tVQVNBQURRRVBDd0pBSUFNZ0FDZ0NCRWNOQUNBQktBSUVJQUFvQWdoR0RRQWdBRUdCQWpZQ0JBc2dCQ2dDRkJBRUlBSW9BcFFCUVFBMkFoUWdBaWdDbEFFb0FoZ1FCQ0FDS0FLVUFVRUFOZ0lZSUFJb0FwUUJLQUljRUFRZ0FpZ0NsQUZCQURZQ0hDQUNLQUtVQVNnQ0xCQUVJQUlvQXBRQlFRQTJBaXdMSUFJb0FwUUJJQUZCeUFBUUZSb0wxZ0VCQTM4Q1FDQUFJQUVvQWdnaUEwRUNkR29pQWlnQ0ZDSUVSUVJBSUFKQjNBQVFDaUlBTmdJVUlBQU5BUThMSUFBb0FnZ2dBMFlFUUNBQklBQW9BaEFRUWdSQUlBSW9BaFFvQWlnUUJDQUNLQUlVUVFBMkFpZ2dBaWdDRkNnQ1ZCQUVJQUlvQWhSQkFEWUNWQ0FBUVFBMkFoQWdBRUdCQWpZQ0JDQUFRaUUzQWdnTUFnc2dBU2dDS0JBRUlBRkJBRFlDS0NBQktBSlVFQVFnQVVFQU5nSlVEd3NnQkNnQ0tCQUVJQUlvQWhSQkFEWUNLQ0FDS0FJVUtBSlVFQVFnQWlnQ0ZFRUFOZ0pVQ3lBQ0tBSVVJQUZCM0FBUUZSb0wwZ0lCQTM4akFFRWdheUlFSkFBZ0JDQUJLQUlRTmdJUUlBUWdBU2tDQ0RjRENDQUVJQUVwQWdBM0F3QUNRQ0FFSUFSQkhHb1FBaUlCRFFBZ0JDQUVRUnhxRUFJaUFRMEFJQVFnQkVFY2FoQUNJZ0VOQUNBQ0tBSU1JUVpCQUNFQkEwQWdBU0lGUVFGcUlRRWdCaUFGZGcwQUN5QUVJQVZCZjJvUUEwRi9SZ1JBUVFFaEFRd0JDeUFFSUFSQkhHb1FBaUlCRFFBQ1FDQUNLQUlRSWdFRWZ5QUJCU0FDS0FJVUlRWkJBQ0VCQTBBZ0FTSUZRUUZxSVFFZ0JpQUZkZzBBQ3lBRUlBVkJmMm9RQTBGL1JnUkFRUUVoQVF3REN5QURLQUlJQkVBZ0JDQUVRUmhxRUFVaUFRMERDeUFDS0FJUUMwRUJSdzBBSUFJb0FoZ05BQ0FFSUFSQkdHb1FCU0lCRFFFZ0F5Z0NDRVVOQUNBRUlBUkJHR29RQlNJQkRRRUxJQU1vQWtRRVFDQUVJQVJCSEdvUUFpSUJEUUVMSUFBZ0JFRUJFQU1pQURZQ0FDQUFRWDlHSVFFTElBUkJJR29rQUNBQkM4WUJBUUovSXdCQklHc2lCU1FBSUFVZ0FDZ0NFRFlDRUNBRklBQXBBZ2czQXdnZ0JTQUFLUUlBTndNQUFrQWdCU0FGUVJ4cUVBSWlBQTBBSUFVZ0JVRWNhaEFDSWdBTkFDQUZJQVZCSEdvUUFpSUFEUUFnQVNnQ0RDRUdRUUFoQUFOQUlBQWlBVUVCYWlFQUlBWWdBWFlOQUFzZ0JTQUJRWDlxRUFOQmYwWUVRRUVCSVFBTUFRc2dBa0VGUmdSQUlBVWdCVUVjYWhBQ0lnQU5BUXNnQlNBRUVBVWlBQTBBSUFNRVFDQUZJQVJCQkdvUUJTSUFEUUVMUVFBaEFBc2dCVUVnYWlRQUlBQUw0UUVCQTM4akFFRWdheUlFSkFBZ0JDQUFLQUlRTmdJUUlBUWdBQ2tDQ0RjRENDQUVJQUFwQWdBM0F3QUNRQ0FFSUFSQkhHb1FBaUlBRFFBZ0JDQUVRUnhxRUFJaUFBMEFJQVFnQkVFY2FoQUNJZ0FOQUNBQktBSU1JUVpCQUNFQUEwQWdBQ0lGUVFGcUlRQWdCaUFGZGcwQUN5QUVJQVZCZjJvUUEwRi9SZ1JBUVFFaEFBd0JDeUFDUVFWR0JFQWdCQ0FFUVJ4cUVBSWlBQTBCQ3lBQktBSVVJUUpCQUNFQUEwQWdBQ0lCUVFGcUlRQWdBaUFCZGcwQUN5QUVJQUZCZjJvUUEwRi9SZ1JBUVFFaEFBd0JDeUFFSUFNUUJTRUFDeUFFUVNCcUpBQWdBQXZtQVFFRGZ5TUFRU0JySWdRa0FDQUVJQUFvQWhBMkFoQWdCQ0FBS1FJSU53TUlJQVFnQUNrQ0FEY0RBQUpBSUFRZ0JFRWNhaEFDSWdBTkFDQUVJQVJCSEdvUUFpSUFEUUFnQkNBRVFSeHFFQUlpQUEwQUlBRW9BZ3doQmtFQUlRQURRQ0FBSWdWQkFXb2hBQ0FHSUFWMkRRQUxJQVFnQlVGL2FoQURRWDlHQkVCQkFTRUFEQUVMSUFKQkJVWUVRQ0FFSUFSQkhHb1FBaUlBRFFFTElBRW9BaFFoQWtFQUlRQURRQ0FBSWdGQkFXb2hBQ0FDSUFGMkRRQUxJQVFnQVVGL2FoQURJZ0JCZjBZRVFFRUJJUUFNQVFzZ0F5QUFOZ0lBUVFBaEFBc2dCRUVnYWlRQUlBQUxrZ0VCQW44akFFRWdheUlESkFBZ0F5QUFLQUlRTmdJUUlBTWdBQ2tDQURjREFDQURJQUFwQWdnM0F3Z0NRQ0FESUFOQkhHb1FBaUlBRFFBZ0F5QURRUnhxRUFJaUFBMEFJQU1nQTBFY2FoQUNJZ0FOQUVFQUlRQURRQ0FBSWdSQkFXb2hBQ0FCSUFSMkRRQUxJQU1nQkVGL2FoQURRWDlHQkVCQkFTRUFEQUVMSUFNZ0FoQUNJUUFMSUFOQklHb2tBQ0FBQzVjQkFRSi9Jd0JCSUdzaUF5UUFJQU1nQUNnQ0VEWUNFQ0FESUFBcEFnZzNBd2dnQXlBQUtRSUFOd01BQWtBZ0F5QURRUnhxRUFJaUFBMEFJQU1nQTBFY2FoQUNJZ0FOQUNBRElBTkJIR29RQWlJQURRQkJBQ0VBQTBBZ0FDSUVRUUZxSVFBZ0FTQUVkZzBBQ3lBRElBUkJmMm9RQXlJQVFYOUdCRUJCQVNFQURBRUxJQUlnQURZQ0FFRUFJUUFMSUFOQklHb2tBQ0FBQzY4T0FRcC9Jd0JCRUdzaUJTUUFJQUZCQUVIY0J4QUhJUWNnQWlnQ05DRUdJQUlvQWpnaENBSkFJQUFnQlVFRWFoQUNJZ0VOQUNBSElBVW9BZ1FpQVRZQ0FDQUJJQVlnQ0d3aUMwOEVRRUVCSVFFTUFRc2dBQ0FGUVFScUVBSWlBUTBBSUFjZ0JTZ0NCQ0lHTmdJRUlBWkJCMHNFUUVFQklRRU1BUXRCQVNFQkFrQUNRQ0FHUVFGckRnY0NBUUlDQUFJQkFBc2dCQ2dDQUVFRlJnUkFEQUlMSUFJb0Fpd05BQXdCQ3lBQUlBVkJCR29RQWlJQkRRQWdCeUFGS0FJRUlnWTJBZ2hCQVNFQklBWWdBeWdDQUVjTkFDQUNLQUlNSVFoQkFDRUJBMEFnQVNJR1FRRnFJUUVnQ0NBR2RnMEFDMEVCSVFFZ0FDQUdRWDlxRUFNaUJrRi9SZzBBSUFaQkFDQUVLQUlBSWdoQkJVWWJEUUFnQnlBR05nSU1JQWhCQlVZRVFDQUFJQVZCQkdvUUFpSUJEUUVnQnlBRktBSUVJZ1kyQWhCQkFTRUJJQVpCLy84RFN3MEJDd0pBSUFJb0FoQWlBUVIvSUFFRklBSW9BaFFoQ0VFQUlRRURRQ0FCSWdaQkFXb2hBU0FJSUFaMkRRQUxJQUFnQmtGL2FoQURJZ0ZCZjBZRVFFRUJJUUVNQXdzZ0J5QUJOZ0lVSUFNb0FnZ0VRQ0FBSUFVUUJTSUJEUU1nQnlBRktBSUFOZ0lZQ3lBRUtBSUFRUVZHQkVCQkFTRUJJQWNvQWhRaUJpQUNLQUlVUVFGMlN3MERJQVpCQUNBSEtBSVlJZ2hCSDNVZ0NIRnJSdzBEQ3lBQ0tBSVFDMEVCUncwQUlBSW9BaGdOQUNBQUlBVVFCU0lCRFFFZ0J5QUZLQUlBTmdJY0lBTW9BZ2dFUUNBQUlBVVFCU0lCRFFJZ0J5QUZLQUlBTmdJZ0N5QUVLQUlBUVFWSERRQkJBU0VCSUFjb0Fod2lCaUFIS0FJZ0lBWWdBaWdDSUdwcUlnZ2dCaUFJU0JzTkFRc2dBeWdDUkFSQUlBQWdCVUVFYWhBQ0lnRU5BU0FISUFVb0FnUWlCallDSkVFQklRRWdCa0gvQUVzTkFRc0NRQ0FIS0FJRUlnRkJCVXNOQUFKQUlBRkJBV3NPQkFFQkFRRUFDMEVCSVFFZ0FFRUJFQU1pQmtGL1JnMEJJQWNnQmpZQ0tBSkFJQVlFUUNBQUlBVkJCR29RQWlJQkRRTkJBU0VCSUFVb0FnUWlCa0VQU3cwRElBWkJBV29oQmd3QkN5QURLQUl3SWdaQkVFc05BZ3NnQnlBR05nSXNJQWNvQWdRaEFRc0NRQ0FCUVFWTERRQUNRQ0FCUVFGckRnUUJBUUVCQUFzZ0FpZ0NEQ0VKSUFjb0Fpd2hDa0VCSVFFZ0FFRUJFQU1pQmtGL1JnMEJJQWNnQmpZQ1JDQUdSUTBBUVFBaEFRTkFJQUVpQmlBS1N3UkFRUUVoQVF3REN5QUFJQVZCQ0dvUUFpSUJEUUlnQlNnQ0NDSUJRUU5MQkVCQkFTRUJEQU1MSUFjZ0JrRU1iR29pQ0NBQk5nSklBa0FnQVVFQlRRUkFJQUFnQlVFTWFoQUNJZ0VOQkNBRktBSU1JZ0VnQ1U4RVFFRUJJUUVNQlFzZ0NDQUJRUUZxTmdKTURBRUxJQUZCQWtjTkFDQUFJQVZCREdvUUFpSUJEUU1nQ0NBRktBSU1OZ0pRQ3lBR1FRRnFJUUVnQlNnQ0NFRURSdzBBQzBFQklRRWdCa1VOQVFzQ1FDQUVLQUlFUlEwQUlBUW9BZ0FoQkNBQ0tBSXNJUWxCQVNFQklBQkJBUkFESVFJZ0JFRUZSZ1JBSUFKQmYwWU5BaUFISUFJMkFwUUNJQUJCQVJBRElnSkJmMFlOQWlBSElBSTJBcGdDSUFrTkFTQUNSUTBCREFJTElBSkJmMFlOQVNBSElBSTJBcHdDSUFKRkRRQWdDVUVCZEVFRGFpRU9RUUFoQmtFQUlRcEJBQ0VFQTBBZ0JpQU9SZ1JBUVFFaEFRd0RDeUFBSUFWQkNHb1FBaUlCRFFJZ0JTZ0NDQ0lDUVFaTEJFQkJBU0VCREFNTElBY2dCa0VVYkdvaUNDQUNOZ0tnQWdKL0lBSkJmWEZCQVVZRVFDQUFJQVZCREdvUUFpSUJEUVFnQ0NBRktBSU1RUUZxTmdLa0FpQUZLQUlJSVFJTElBSkJBa1lMQkVBZ0FDQUZRUXhxRUFJaUFRMERJQWdnQlNnQ0REWUNxQUlnQlNnQ0NDRUNDd0pBSUFKQmZXb2lBVUVEU3cwQUFrQWdBVUVCYXc0Q0FRRUFDeUFBSUFWQkRHb1FBaUlCRFFNZ0NDQUZLQUlNTmdLc0FpQUZLQUlJSVFJTElBSkJCRVlFUUNBQUlBVkJER29RQWlJQkRRTWdCU2dDRENJQklBbExCRUJCQVNFQkRBUUxJQWdnQVVGL2FrSC8vd01nQVJzMkFyQUNJQXBCQVdvaENpQUZLQUlJSVFJTElBWkJBV29oQmlBTUlBSkJCa1pxSVF3Z0JDQUNRUVZHYWlFRUlBMGdBa0YvYWtFRFNXb2hEU0FDRFFBTFFRRWhBU0FFSUFweUlBeHlRUUZMRFFFZ0JFVU5BQ0FORFFFTElBQWdCUkFGSWdFTkFDQUhJQVVvQWdBaUFUWUNNQ0FGSUFFZ0F5Z0NOR29pQWpZQ0FFRUJJUUVnQWtFelN3MEFBa0FnQXlnQ1BFVU5BQ0FBSUFWQkJHb1FBaUlCRFFFZ0J5QUZLQUlFSWdJMkFqUkJBU0VCSUFKQkFrc05BU0FDUVFGR0RRQWdBQ0FGRUFVaUFRMEJRUUVoQVNBRktBSUFJZ0pCQm1wQkRFc05BU0FISUFKQkFYUTJBamdnQUNBRkVBVWlBUTBCUVFFaEFTQUZLQUlBSWdKQkJtcEJERXNOQVNBSElBSkJBWFEyQWp3TEFrQWdBeWdDREVFQ1NRMEFJQU1vQWhCQmZXcEJBa3NOQUVFQ1FRRWdDeUFMSUFNb0FpUWlBVzRpQWlBQmJHc2JJQUpxSVFSQkFDRUNBMEFnQkNBQ0lnRkJBV29pQW5ZTkFBc2dCU0FBSUFJZ0FTQUVRWDhnQVhSQmYzTnhHeEFESWdBMkFnUkJBU0VCSUFCQmYwWU5BU0FISUFBMkFrQWdBQ0FMSUFNb0FpUWlBR3BCZjJvZ0FHNUxEUUVMUVFBaEFRc2dCVUVRYWlRQUlBRUx3UWtCRFg4Z0F5QUViQ0VGSUFFb0Fnd2lDVUVCUmdSQUlBQkJBQ0FGUVFKMEVBY2FEd3NDUUFKQUFrQUNRQ0FCS0FJUUlnWkJmV3BCQWswRVFDQUJLQUlrSUFKc0lnSWdCU0FDSUFWSkd5RUxJQVpCZm5GQkJFY05BU0FGSUF0cklBc2dBU2dDSUJzaEJ3c0NRQUpBQWtBZ0JrRUZUUVJBSUFaQkFXc09CUVlGQkFNQ0FRc2dCVVVOQmlBQktBSXNJUUpCQUNFQkEwQWdBQ0FCUVFKMElnTnFJQUlnQTJvb0FnQTJBZ0FnQVVFQmFpSUJJQVZIRFFBTERBWUxBa0FnQ1FSQUlBRW9BaFFoQWtFQUlRWU1BUXNnQlVVTkJnTkFEQUFBQ3dBTEEwQkJBQ0VFSUFZZ0JVOE5CZ05BUVFBaEJ3SkFJQUlnQkVFQ2RHb2lBeWdDQUNJQlJRMEFJQUVoQnlBRklBWk5EUUJCQUNFQlFRQWdCU0FHYXlJSElBY2dCVXNiSVFnRFFDQUFJQUVnQm1wQkFuUnFJQVEyQWdBZ0FVRUJhaUlCSUFNb0FnQWlCMDhOQVNBQklBaEhEUUFMQ3lBRVFRRnFJZ1FnQ1VsQkFDQUdJQWRxSWdZZ0JVa2JEUUFMSUFZZ0JVa05BQXNNQlFzZ0EwVU5CQ0FFUlEwRVFRRWdBU2dDSUNJSmF5RUlRUUFoQlVFQUlRSURRRUVBSVFFZ0JTRUdBMEFnQUNBQklBTnNJQUpxUVFKMGFpQUpJQWdnQmlBSFNSczJBZ0FnQmtFQmFpRUdJQUZCQVdvaUFTQUVSdzBBQ3lBRUlBVnFJUVVnQWtFQmFpSUNJQU5IRFFBTERBUUxJQVZGRFFOQkFTQUJLQUlnSWdKcklRTkJBQ0VCQTBBZ0FDQUJRUUowYWlBQ0lBTWdBU0FIU1JzMkFnQWdBVUVCYWlJQklBVkhEUUFMREFNTElBRW9BaUFoQWlBRkJFQkJBQ0VCQTBBZ0FDQUJRUUowYWtFQk5nSUFJQUZCQVdvaUFTQUZSdzBBQ3dzZ0MwVU5BaUFEUVg5cUlROGdCRUYvYWlFUUlBSkJmMm9oQmtFQklBSkJBWFFpQVdzaEJTQUJRWDlxSVFrZ0JDQUNhMEVCZGlJS0lRd2dBeUFDYTBFQmRpSU5JUVFnQ2lFSUlBMGhBVUVBSVFjRFFDQUFJQU1nQ0d3Z0FXcEJBblJxSWc0b0FnQWlFVUVCUmdSQUlBNUJBRFlDQUFzZ0VVRUJSaUVPQWtBQ1FDQUdRWDlIRFFBZ0FTQUVSdzBBUVFBaEJpQUpJUUlnQkVFQklBUkJBVW9iUVg5cUlnRWhCQXdCQ3dKQUlBWkJBVWNOQUNBQklBMUhEUUJCQUNFR0lBVWhBaUFOUVFGcUlnRWdEeUFCSUE5SUd5SUJJUTBNQVFzQ1FDQUNRWDlIRFFBZ0NDQU1SdzBBUVFBaEFpQUZJUVlnREVFQklBeEJBVW9iUVg5cUlnZ2hEQXdCQ3dKQUlBSkJBVWNOQUNBSUlBcEhEUUJCQUNFQ0lBa2hCaUFLUVFGcUlnZ2dFQ0FJSUJCSUd5SUlJUW9NQVFzZ0FpQUlhaUVJSUFFZ0Jtb2hBUXNnQnlBT2FpSUhJQXRKRFFBTERBSUxJQUVvQWh3aEJ5QUJLQUlZSVFnZ0JRUkFJQWxCZjJvaEFrRUFJUUVEUUNBQUlBRkJBblJxSUFJMkFnQWdBVUVCYWlJQklBVkhEUUFMSUFKRkRRSUxJQWxCZm1vaEFRTkFBa0FnQ0NBQklnUkJBblFpQVdvb0FnQWlCaUFEYmlJQ0lBRWdCMm9vQWdBaUFTQURiaUlGU3cwQUlBWWdBaUFEYkdzaUJpQUJJQU1nQld4cklnbExCRUFEUUNBQ1FRRnFJZ0lnQlUwTkFBd0NBQXNBQ3dOQUlBSWdBMndoQ2lBR0lRRURRQ0FBSUFFZ0NtcEJBblJxSUFRMkFnQWdBVUVCYWlJQklBbE5EUUFMSUFKQkFXb2lBaUFGVFEwQUN3c2dCRUYvYWlFQklBUU5BQXNNQVFzZ0JVVU5BRUVBSVFFRFFDQUFJQUZCQW5ScUlBRWdBMjRpQWlBSmJFRUJkaUFCSUFJZ0EyeHJhaUFKY0RZQ0FDQUJRUUZxSWdFZ0JVY05BQXNMQzhRQkFRVi9JQUFvQXFnSklRUUNRQ0FBUWJBSmFpZ0NBQ0lDUlEwQUlBSkJmMm9pQWlBQlRRUkFJQUloQVF3QkN5QUFLQUs4Q1NFRkEwQUNRQ0FGSUFKQjJBRnNhaWdDQkNBRVJ3MEFJQU5CQVdvaUF5QUFLQUlRS0FJMElnWkJDaUFHUVFwTEcwa05BQ0FDSVFFTUFnc2dBa0YvYWlJQ0lBRkxEUUFMQ3dOQUFrQWdBQ2dDdkFrZ0FVSFlBV3hxSWdJb0FnUWdCRWNOQUNBQ0tBTEVBU0lEUlEwQUlBSWdBMEYvYWpZQ3hBRWdBQ2dDbEFrZ0FDZ0NtQWtnQVJBZUlnRU5BUXNMQzcwRUFndC9BWDRqQUVIQUEyc2lCU1FBSUFNb0FnQWhCeUFCS0FLd0dpRUlJQVZCQURZQ0RDQUJRYkFKYWtFQU5nSUFJQUVnQVNnQ3FBbEJBV28yQXFnSklBVWdBeWdDTUNBQktBSU1LQUkwYWpZQ0NDQUJRY1FKYWlFTklBaEJER29oRGdKQUEwQWdBU2dDdkFraEJBSkFJQU1vQWlRTkFDQUVJQWRCMkFGc2FpZ0N4QUZGRFFCQkFTRUVEQUlMSUFNcEFqUWhEeUFES0FJOElRc2dBU2dDcUFraERDQUVJQWRCMkFGc0lnWnFJZ1FnQVNnQ0RDZ0NPRFlDR0NBRUlBczJBaEFnQkNBUE53SUlJQVFnRERZQ0JBSkFJQU1vQWdRaUJFRUNSZzBBSUFrTkFDQUVRUWRHRFFBZ0FDQUZRUXhxRUFJaUJBMENJQVVvQWd3aUJDQUJLQUtZQ1NBSGEwc0VRRUVCSVFRTUF3c2dCRVVFUUVFQUlRa01BUXNnRGtFQVFhUUJFQWNhSUFoQkFEWUNBRUVCSVFrTEFrQWdCU2dDRENJRUJFQWdCU0FFUVg5cU5nSU1EQUVMUVFBaENTQUFJQWdnQVNnQ3ZBa2dCbW9nQXlnQ0JDQURLQUlzRUZFaUJBMENDeUFCS0FLOENTQUdhaUFJSUFJZ0RTQUZRUWhxSUFjZ0FTZ0NEQ2dDUUNBRlFSQnFFRkFpQkEwQklBRW9BcndKSUFacUtBTEVBU0VMSUFBUUxpRUVJQVVvQWd3aEJnSkFJQU1vQWdSQmZtb2lERUVGU3cwQUFrQWdERUVCYXc0RUFRRUJBUUFMSUFFZ0J6WUNzQWtMSUFRZ0JuSWhCa0VCSVFRZ0FTZ0NsQWtnQVNnQ21Ba2dCeEFlSWdkRlFRQWdCaHNOQVNBS0lBdEJBVVpxSVFvZ0JnMEFDeUFCUWF3SmFpZ0NBQ0FLYWlJQUlBRW9BcGdKU3cwQUlBRWdBRFlDckFsQkFDRUVDeUFGUWNBRGFpUUFJQVFMNWdJQkIzOUJBU0VDQWtBZ0FDZ0NBQ0FCS0FJQVJ3MEFJQUFvQWdRZ0FTZ0NCRWNOQUNBQUtBSU1JQUVvQWd4SERRQWdBQ2dDRUNJRElBRW9BaEJIRFFBZ0FDZ0NMQ0FCS0FJc1J3MEFJQUFvQWpBZ0FTZ0NNRWNOQUNBQUtBSTBJQUVvQWpSSERRQWdBQ2dDT0NBQktBSTRSdzBBSUFBb0Fqd2lCU0FCS0FJOFJ3MEFJQUFvQWxBZ0FTZ0NVRWNOQUFKQUlBTkJBVXNOQUNBRFFRRnJSUVJBSUFBb0FoZ2dBU2dDR0VjTkFpQUFLQUljSUFFb0FoeEhEUUlnQUNnQ0lDQUJLQUlnUncwQ0lBQW9BaVFpQkNBQktBSWtSdzBDSUFSRkRRRWdBU2dDS0NFR0lBQW9BaWdoQjBFQUlRTURRQ0FISUFOQkFuUWlDR29vQWdBZ0JpQUlhaWdDQUVjTkF5QUVJQU5CQVdvaUEwY05BQXNNQVFzZ0FDZ0NGQ0FCS0FJVVJ3MEJDeUFGQkVBZ0FDZ0NRQ0FCS0FKQVJ3MEJJQUFvQWtRZ0FTZ0NSRWNOQVNBQUtBSklJQUVvQWtoSERRRWdBQ2dDVENBQktBSk1SdzBCQzBFQUlRSUxJQUlML3drQkJuOGpBRUVRYXlJRUpBQWdBVUVBUWR3QUVBY2hBd0pBSUFCQkNCQURJZ0ZCZjBZRVFFRUJJUUVNQVFzZ0F5QUJOZ0lBSUFCQkFSQURHaUFBUVFFUUF4b2dBRUVCRUFOQmYwWUVRRUVCSVFFTUFRc2dBRUVGRUFOQmYwWUVRRUVCSVFFTUFRc2dBRUVJRUFNaUFVRi9SZ1JBUVFFaEFRd0JDeUFESUFFMkFnUWdBQ0FEUVFocUVBSWlBUTBBSUFNb0FnaEJIMHNFUUVFQklRRU1BUXNnQUNBRVFReHFFQUlpQVEwQVFRRWhBU0FFS0FJTUlnSkJERXNOQUNBRFFRRWdBa0VFYW5RMkFnd2dBQ0FFUVF4cUVBSWlBUTBBUVFFaEFTQUVLQUlNSWdKQkFrc05BQ0FESUFJMkFoQUNRQ0FDUVFGTERRQWdBa0VCYXdSQUlBQWdCRUVNYWhBQ0lnRU5Ba0VCSVFFZ0JDZ0NEQ0lDUVF4TERRSWdBMEVCSUFKQkJHcDBOZ0lVREFFTElBQkJBUkFESWdKQmYwWU5BU0FESUFKQkFVWTJBaGdnQUNBRFFSeHFFQVVpQVEwQklBQWdBMEVnYWhBRklnRU5BU0FBSUFOQkpHb1FBaUlCRFFGQkFTRUJJQU1vQWlRaUFrSC9BVXNOQVNBQ0JFQWdBeUFDUVFKMEVBb2lBVFlDS0NBQlJRUkFRZi8vQXlFQkRBTUxJQUFnQVJBRklnRU5Ba0VCSVFJRFFDQUNJQU1vQWlSUERRSWdBa0VDZENFQklBSkJBV29oQWlBQUlBRWdBeWdDS0dvUUJTSUJSUTBBQ3d3Q0N5QURRUUEyQWlnTElBQWdBMEVzYWhBQ0lnRU5BRUVCSVFFZ0F5Z0NMRUVRU3cwQUlBQkJBUkFESWdKQmYwWU5BQ0FESUFKQkFVWTJBakFnQUNBRVFReHFFQUlpQVEwQUlBTWdCQ2dDREVFQmFqWUNOQ0FBSUFSQkRHb1FBaUlCRFFCQkFTRUJJQU1nQkNnQ0RFRUJhallDT0NBQVFRRVFBMEVCYWtFQ1NRMEFJQUJCQVJBRFFYOUdEUUFnQUVFQkVBTWlBa0YvUmcwQUlBTWdBa0VCUmlJQk5nSThBa0FnQVVVRVFDQURLQUk0SVFVZ0F5Z0NOQ0VHREFFTElBQWdBMEZBYXhBQ0lnRU5BU0FBSUFOQnhBQnFFQUlpQVEwQklBQWdBMEhJQUdvUUFpSUJEUUVnQUNBRFFjd0FhaEFDSWdFTkFVRUJJUUVnQXlnQ1FDQURLQUpFUVg5eklBTW9BalFpQmtFRGRHcEtEUUVnQXlnQ1NDQURLQUpNUVg5eklBTW9BamdpQlVFRGRHcEtEUUVMQWtBQ1FBSkFBa0FnQXlnQ0JFRjJhaUlIUVNsTERRQkI0d0FoQVVHQXBBa2hBZ0pBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBZ0IwRUJhdzRwQUFFQkN3c0xDd3NMQVFJREN3c0xDd3NMQ3dNRUJRc0xDd3NMQ3dzR0JnY0xDd3NMQ3dzTENBa0tDMEdNQXlFQlFZQ01GU0VDREFrTFFZd0RJUUZCZ05nM0lRSU1DQXRCbUFZaEFVR0FzTzhBSVFJTUJ3dEIxQXdoQVVHQTdMMEJJUUlNQmd0QmtCd2hBVUdBOEtVRElRSU1CUXRCZ0NnaEFVR0FnT0FESVFJTUJBdEJnTUFBSVFGQmdJQ0FCaUVDREFNTFFZREVBQ0VCUVlDQXNBWWhBZ3dDQzBIQXJBRWhBVUdBd0pzVUlRSU1BUXRCZ0tBQ0lRRkJnSURnSVNFQ0N5QUJJQVVnQm13aUFVOE5BUXNnQkVILy8vLy9CellDRENBREtBSXNJUUlNQVFzZ0JDQUNJQUZCZ0FOc2JpSUJRUkFnQVVFUVNSc2lBVFlDRENBREtBSXNJZ0lnQVUwTkFRc2dCQ0FDTmdJTUlBSWhBUXNnQXlBQk5nSllRUUVoQVNBQVFRRVFBeUlDUVg5R0RRQWdBeUFDUVFGR05nSlFBa0FnQWtFQlJ3MEFJQU5CdUFjUUNpSUJOZ0pVSUFGRkJFQkIvLzhESVFFTUFnc2dBQ0FCRUN3aUFRMEJJQU1vQWxRaUFpZ0NtQWRGRFFCQkFTRUJJQUlvQXJBSElBSW9BclFISWdKTERRRWdBaUFES0FJc1NRMEJJQUlnQXlnQ1dFc05BU0FESUFKQkFTQUNHellDV0FzZ0FCQWZRUUFoQVFzZ0JFRVFhaVFBSUFFTGpRUUJEbjhnQVFKL0FrQWdBQzhCSUNJSERRQWdBQzhCSEEwQVFRQU1BUXRCQWdzMkFpQWdBUUovQWtBZ0FDOEJJaUlDRFFBZ0FDOEJIZzBBUVFBTUFRdEJBZ3MyQWlnZ0FRSi9Ba0FnQUM4QktDSUREUUFnQUM4QkpBMEFRUUFNQVF0QkFnczJBakFnQVFKL0FrQWdBQzhCS2lJSURRQWdBQzhCSmcwQVFRQU1BUXRCQWdzMkFqZ2dBU0FISUFBdkFTd2lDWEpCQUVkQkFYUTJBa0FnQVNBQ0lBQXZBUzRpQkhKQkFFZEJBWFEyQWtnZ0FTQURJQUF2QVRRaUJYSkJBRWRCQVhRMkFsQWdBU0FJSUFBdkFUWWlDbkpCQUVkQkFYUTJBbGdnQVNBQUx3RXdJZzBnQ1hKQkFFZEJBWFEyQW1BZ0FTQUFMd0V5SWdzZ0JISkJBRWRCQVhRMkFtZ2dBU0FBTHdFNElnd2dCWEpCQUVkQkFYUTJBbkFnQVNBQUx3RTZJZzRnQ25KQkFFZEJBWFEyQW5oQkFpRUdJQUVnQUM4QkhpSVBCSDlCQWdVZ0FDOEJIRUVBUjBFQmRBczJBZ3dnQVNBUElBQXZBU1FpQm5KQkFFZEJBWFEyQWhRZ0FDOEJKaUVBSUFFZ0RDQU9ja0VBUjBFQmREWUNmQ0FCSUFzZ0RISkJBRWRCQVhRMkFuUWdBU0FMSUExeVFRQkhRUUYwTmdKc0lBRWdCU0FLY2tFQVIwRUJkRFlDWENBQklBUWdCWEpCQUVkQkFYUTJBbFFnQVNBRUlBbHlRUUJIUVFGME5nSk1JQUVnQXlBSWNrRUFSMEVCZERZQ1BDQUJJQUlnQTNKQkFFZEJBWFEyQWpRZ0FTQUNJQWR5UVFCSFFRRjBOZ0lzSUFFZ0FDQUdja0VBUjBFQmREWUNIQXZNQmdFTGZ5TUFRWUFPYXlJT0pBQWdCa0VGYWlFSUFrQUNRQ0FDUVFCSURRQWdBMEVBU0EwQUlBSWdDR29nQkVzTkFDQUhRUVZxSWdvZ0Eyb2dCVXNOQUNBRUlRZ2dBeUVKREFFTElBQWdEa0hBQ21vZ0FpQURJQVFnQlNBSUlBZEJCV29pQ2lBSUVBd2dEa0hBQ21vaEFFRUFJUUlMQWtBZ0NrVU5BQ0FHUVFKMkloQkZEUUFnQ0NBR2F5RVJJQUFnQ0NBSmJDQUNhbXBCQldvaEFpQU9JUUFEUUNBQ1FYOXFMUUFBSVFnZ0FrRithaTBBQUNFRElBSkJmV290QUFBaEJTQUNRWHhxTFFBQUlRUWdBa0Y3YWkwQUFDRU1JQkFoRFFOQUlBQWdBaTBBQUNJSklBd2dCQ0FJYWlJTGF5QURJQVZxUVJSc2FpQUxRUUowYTJvMkFnQWdBQ0FDTFFBQklnc2dBeUFJYWtFVWJDQUVhaUFGSUFscUlnUnJJQVJCQW5ScmFqWUNCQ0FBSUFJdEFBSWlEeUFJSUFscVFSUnNJQVZxSUFNZ0Myb2lCR3NnQkVFQ2RHdHFOZ0lJSUFBZ0FpMEFBeUlTSUFrZ0MycEJGR3dnQTJvZ0NDQVBhaUlEYXlBRFFRSjBhMm8yQWd3Z0FFRVFhaUVBSUFKQkJHb2hBaUFJSVF3Z0NTRUVJQXNoQlNBUElRTWdFaUVJSUExQmYyb2lEUTBBQ3lBQ0lCRnFJUUlnQ2tGL2FpSUtEUUFMQ3dKQUlBZEJBbllpQjBVTkFDQUdSUTBBUWNBQUlBWnJJUThnRGlBR1FRSjBhaUlJSUFaQkZHeHFJUUpCQUNBR2F5SVFRUU4wSVJJZ0JrRURkQ0VKSUFaQkEyeEJBblFoQ3dOQUlBWWhCQU5BSUFFZ0NDQUphaWdDQUNJQUlBSWdDV29vQWdBZ0FpQUdRUUowSWcxcUtBSUFJZ29nQWlBU2FpZ0NBQ0lEYWlJRmF5QUZRUUowYTJvZ0FpZ0NBQ0lNSUFJZ0VFRUNkQ0lSYWlnQ0FDSUZha0VVYkdwQmdBUnFRUXAxUWJBdWFpMEFBRG9BTUNBQklBZ2dEV29vQWdBaURTQUtJQU1nQldwQkZHeHFJQUFnREdvaUNtc2dDa0VDZEd0cVFZQUVha0VLZFVHd0xtb3RBQUE2QUNBZ0FTQUlLQUlBSWdvZ0RDQUFJQU5xUVJSc2FpQUZJQTFxSWd4cklBeEJBblJyYWtHQUJHcEJDblZCc0M1cUxRQUFPZ0FRSUFFZ0NDQVJhaWdDQUNBRklBQWdEV3BCRkd4cUlBTWdDbW9pQUdzZ0FFRUNkR3RxUVlBRWFrRUtkVUd3TG1vdEFBQTZBQUFnQ0VFRWFpRUlJQUZCQVdvaEFTQUNRUVJxSVFJZ0JFRi9haUlFRFFBTElBRWdEMm9oQVNBQ0lBdHFJUUlnQ0NBTGFpRUlJQWRCZjJvaUJ3MEFDd3NnRGtHQURtb2tBQXZsQXdFSmZ5TUFRY0FEYXlJS0pBQWdCa0VGYWlFSUFrQUNRQ0FDUVFCSURRQWdBeUFIYWlBRlN3MEFJQU5CQUVnTkFDQUNJQWhxSUFSTERRQWdCQ0VJSUFNaENRd0JDeUFBSUFvZ0FpQURJQVFnQlNBSUlBY2dDQkFNSUFvaEFFRUFJUUlMQWtBZ0IwVU5BQ0FHUVFKMklnMUZEUUJCRUNBR2F5RU9JQWdnQm1zaER5QUFJQWdnQ1d3Z0FtcHFRUVZxSVFJRFFDQUNRWDlxTFFBQUlRZ2dBa0YrYWkwQUFDRUdJQUpCZldvdEFBQWhBQ0FDUVh4cUxRQUFJUVVnQWtGN2FpMEFBQ0VKSUEwaEN3TkFJQUVnQWkwQUFDSURJQWtnQlNBSWFpSUVheUFBSUFacVFSUnNhaUFFUVFKMGEycEJFR3BCQlhWQnNDNXFMUUFBT2dBQUlBRWdBaTBBQVNJRUlBVWdCaUFJYWtFVWJHb2dBQ0FEYWlJRmF5QUZRUUowYTJwQkVHcEJCWFZCc0M1cUxRQUFPZ0FCSUFFZ0FpMEFBaUlNSUFBZ0F5QUlha0VVYkdvZ0JDQUdhaUlBYXlBQVFRSjBhMnBCRUdwQkJYVkJzQzVxTFFBQU9nQUNJQUVnQWkwQUF5SVFJQVlnQXlBRWFrRVViR29nQ0NBTWFpSUFheUFBUVFKMGEycEJFR3BCQlhWQnNDNXFMUUFBT2dBRElBRkJCR29oQVNBQ1FRUnFJUUlnQ0NFSklBTWhCU0FFSVFBZ0RDRUdJQkFoQ0NBTFFYOXFJZ3NOQUFzZ0FTQU9haUVCSUFJZ0Qyb2hBaUFIUVg5cUlnY05BQXNMSUFwQndBTnFKQUFMOVFNQkMzOGpBRUhBQTJzaUN5UUFBa0FDUUNBQ1FRQklEUUFnQTBFQVNBMEFJQUlnQm1vZ0JFc05BQ0FESUFkcVFRVnFJQVZMRFFBZ0F5RUlEQUVMSUFBZ0N5QUNJQU1nQkNBRklBWWdCMEVGYWlBR0VBd2dDeUVBSUFZaEJFRUFJUUlMQWtBZ0IwRUNkaUlNUlEwQUlBWkZEUUJCd0FBZ0Jtc2hFU0FFUVFGMElRMGdCRUVDZENBR2F5RU9RUUFnQkdzaUQwRUJkQ0VTSUFBZ0JDQUliQ0FDYW1vZ0JHb2lCeUFFUVFWc2FpRUNBMEFnQmlFQUEwQWdBU0FISUExcUxRQUFJZ01nQWlBTmFpMEFBQ0FDSUFScUxRQUFJZ2tnQWlBU2FpMEFBQ0lGYWlJSWF5QUlRUUowYTJvZ0FpMEFBQ0lLSUFJZ0Qyb3RBQUFpQ0dwQkZHeHFRUkJxUVFWMVFiQXVhaTBBQURvQU1DQUJJQVFnQjJvdEFBQWlFQ0FKSUFVZ0NHcEJGR3hxSUFNZ0Ntb2lDV3NnQ1VFQ2RHdHFRUkJxUVFWMVFiQXVhaTBBQURvQUlDQUJJQWN0QUFBaUNTQUtJQU1nQldwQkZHeHFJQWdnRUdvaUNtc2dDa0VDZEd0cVFSQnFRUVYxUWJBdWFpMEFBRG9BRUNBQklBY2dEMm90QUFBZ0NDQURJQkJxUVJSc2FpQUZJQWxxSWdOcklBTkJBblJyYWtFUWFrRUZkVUd3TG1vdEFBQTZBQUFnQjBFQmFpRUhJQUZCQVdvaEFTQUNRUUZxSVFJZ0FFRi9haUlBRFFBTElBRWdFV29oQVNBQ0lBNXFJUUlnQnlBT2FpRUhJQXhCZjJvaURBMEFDd3NnQzBIQUEyb2tBQXVxQmdFTmZ5TUFRYkFCYXlJUkpBQWdDRUVCYWlFS0FrQUNRQ0FDUVFCSURRQWdBMEVBU0EwQUlBSWdDbW9nQkVzTkFDQURJQWxxUVFGcUlBVkxEUUFnQlNFTUlBUWhDaUFESVE4TUFRc2dBQ0FSSUFJZ0F5QUVJQVVnQ2lBSlFRRnFJZ3dnQ2hBTUlBQWdCQ0FGYkdvZ0VTQUtJQXhzYWlBQ0lBTWdCQ0FGSUFvZ0RDQUtFQXdnRVNFQVFRQWhBZ3NDUUNBSlFRRjJJZ1ZGRFFBZ0NFRUJkaUlFUlEwQVFSQWdDR3NoRTBFSUlBZHJJUXRCQ0NBR2F5RU5JQXBCQVhRaURpQUlheUVVSUFBZ0Ftb2lGaUFLSUE5c2FpRUNJQUVoQUNBRklSVURRQ0FDSUE1cUxRQUFJQWRzSUFzZ0FpQUthaTBBQUNJRGJHb2hDQ0FESUFkc0lBc2dBaTBBQUd4cUlRa2dCQ0VEQTBBZ0FrRUJhaUlRSUE1cUxRQUFJUklnQUNBSklBMXNJQW9nRUdvdEFBQWlDU0FIYkNBTElBSXRBQUZzYWlJUUlBWnNha0VnYWtFR2Rqb0FBQ0FBSUFnZ0RXd2dCeUFTYkNBSklBdHNhaUlJSUFac2FrRWdha0VHZGpvQUNDQUNMUUFDSVFrZ0FrRUNhaUlDSUE1cUxRQUFJUklnQUNBTklCQnNJQUlnQ21vdEFBQWlFQ0FIYkNBSklBdHNhaUlKSUFac2FrRWdha0VHZGpvQUFTQUFJQWdnRFd3Z0J5QVNiQ0FMSUJCc2FpSUlJQVpzYWtFZ2FrRUdkam9BQ1NBQVFRSnFJUUFnQTBGL2FpSUREUUFMSUFJZ0ZHb2hBaUFBSUJOcUlRQWdGVUYvYWlJVkRRQUxJQUZCUUdzaEFDQVdJQXdnRDJvZ0NteHFJUUlEUUNBQ0lBNXFMUUFBSUFkc0lBc2dBaUFLYWkwQUFDSUJiR29oQ0NBQklBZHNJQXNnQWkwQUFHeHFJUWtnQkNFREEwQWdBa0VCYWlJQklBNXFMUUFBSVF3Z0FDQUpJQTFzSUFFZ0Ntb3RBQUFpQVNBSGJDQUxJQUl0QUFGc2FpSUpJQVpzYWtFZ2FrRUdkam9BQUNBQUlBZ2dEV3dnQnlBTWJDQUJJQXRzYWlJQklBWnNha0VnYWtFR2Rqb0FDQ0FDTFFBQ0lRZ2dBa0VDYWlJQ0lBNXFMUUFBSVF3Z0FDQUpJQTFzSUFJZ0Ntb3RBQUFpRHlBSGJDQUlJQXRzYWlJSklBWnNha0VnYWtFR2Rqb0FBU0FBSUFFZ0RXd2dCeUFNYkNBTElBOXNhaUlJSUFac2FrRWdha0VHZGpvQUNTQUFRUUpxSVFBZ0EwRi9haUlERFFBTElBSWdGR29oQWlBQUlCTnFJUUFnQlVGL2FpSUZEUUFMQ3lBUlFiQUJhaVFBQy85RUFVRi9Jd0JCc0FGcklnTWtBQ0FBS0FJSUlnUUVRQ0FBS0FJRUloOUJBM1FoRmlBRUlCOXNJZ1JCQm5RaE95QUVRUWgwSVR3Z0gwRUdkQ0U5SUI5Qk1Hd2hQaUFmUVFWMElTVWdIMEZRYkNFclFRQWdIMEVFZENJYWF5SW9RUUowSVQ4Z0tFRUJkQ0VzSUFOQkdHb2hJaUFEUVF4eUlTTURRQUpBSUFFb0FnZ2lDVUVCUmcwQUFrQUNRQUpBQWtBZ0FTZ0N5QUVpQWtVRVFFRUJJUVlNQVF0QkJTRUdJQWxCQWtjTkFFRUZRUUVnQVNnQ0JDSUpJQUlvQWdSR0d5RUdJQUVvQXN3QklnUU5BVUVBSVFRTUF3c2dBU2dDekFFaUJFVUVRRUVBSVFRTUF3c2dDVUVDUncwQklBRW9BZ1FoQ1FzZ0NTQUVLQUlFUncwQkN5QUdRUUp5SVFZTEFuOGdCa0VDY1NJdEJFQUNRQ0FCS0FJQVFRVk5CRUFnQkNnQ0FFRUdTUTBCQ3lBRFFRUTJBa0FnQTBFRU5nSklJQU5CQkRZQ09DQURRUVEyQWpCQkFRd0NDMEVDSVE5QkFpRUpBa0FnQVM4QkhBMEFJQVF2QVRBTkFFRUJJUWtnQVNnQ2RDQUVLQUo4UncwQUlBRXVBWVFCSUFRdUFhd0JheUlGSUFWQkgzVWlCV29nQlhOQkEwc05BQ0FCTGdHR0FTQUVMZ0d1QVdzaUNTQUpRUjkxSWdscUlBbHpRUU5MSVFrTElBTWdDVFlDTUFKQUlBRXZBUjROQUNBRUx3RXlEUUJCQVNFUElBRW9BblFnQkNnQ2ZFY05BQ0FCTGdHSUFTQUVMZ0d3QVdzaUJTQUZRUjkxSWdWcUlBVnpRUU5MRFFBZ0FTNEJpZ0VnQkM0QnNnRnJJZ1VnQlVFZmRTSUZhaUFGYzBFRFN5RVBDeUFESUE4MkFqaEJBaUVGUVFJaENnSkFJQUV2QVNRTkFDQUVMd0U0RFFCQkFTRUtJQUVvQW5nZ0JDZ0NnQUZIRFFBZ0FTNEJsQUVnQkM0QnZBRnJJZ2dnQ0VFZmRTSUlhaUFJYzBFRFN3MEFJQUV1QVpZQklBUXVBYjRCYXlJSUlBaEJIM1VpQ0dvZ0NITkJBMHNoQ2dzZ0F5QUtOZ0pBQWtBZ0FTOEJKZzBBSUFRdkFUb05BRUVCSVFVZ0FTZ0NlQ0FFS0FLQUFVY05BQ0FCTGdHWUFTQUVMZ0hBQVdzaUNDQUlRUjkxSWdocUlBaHpRUU5MRFFBZ0FTNEJtZ0VnQkM0QndnRnJJZ1FnQkVFZmRTSUVhaUFFYzBFRFN5RUZDeUFESUFVMkFrZ2dDU0FQY2lBS2NpQUZja0VBUnd3QkN5QURRUUEyQWtBZ0EwRUFOZ0pJSUFOQkFEWUNPQ0FEUVFBMkFqQkJBQXNoQ1FKQUFrQUNRQUpBSUFaQkJIRWlMZ1JBQWtBZ0FTZ0NBQ0lHUVFWTkJFQWdBaWdDQUVFR1NRMEJDeUFEUVFRMkFuUWdBMEVFTmdLVUFTQURRUVEyQWxRZ0EwRUVOZ0kwUVFFaENRd0NDMEVDSVE5QkFpRUVBa0FnQVM4QkhBMEFJQUl2QVNZTkFFRUJJUVFnQVNnQ2RDQUNLQUo0UncwQUlBRXVBWVFCSUFJdUFaZ0JheUlGSUFWQkgzVWlCV29nQlhOQkEwc05BQ0FCTGdHR0FTQUNMZ0dhQVdzaUJDQUVRUjkxSWdScUlBUnpRUU5MSVFRTElBTWdCRFlDTkFKQUlBRXZBU0FOQUNBQ0x3RXFEUUJCQVNFUElBRW9BblFnQWlnQ2VFY05BQ0FCTGdHTUFTQUNMZ0dnQVdzaUJTQUZRUjkxSWdWcUlBVnpRUU5MRFFBZ0FTNEJqZ0VnQWk0Qm9nRnJJZ1VnQlVFZmRTSUZhaUFGYzBFRFN5RVBDeUFESUE4MkFsUkJBaUVGUVFJaENnSkFJQUV2QVN3TkFDQUNMd0UyRFFCQkFTRUtJQUVvQW53Z0FpZ0NnQUZIRFFBZ0FTNEJwQUVnQWk0QnVBRnJJZ2dnQ0VFZmRTSUlhaUFJYzBFRFN3MEFJQUV1QWFZQklBSXVBYm9CYXlJSUlBaEJIM1VpQ0dvZ0NITkJBMHNoQ2dzZ0F5QUtOZ0owQWtBZ0FTOEJNQTBBSUFJdkFUb05BRUVCSVFVZ0FTZ0NmQ0FDS0FLQUFVY05BQ0FCTGdHc0FTQUNMZ0hBQVdzaUNDQUlRUjkxSWdocUlBaHpRUU5MRFFBZ0FTNEJyZ0VnQWk0QndnRnJJZ1VnQlVFZmRTSUZhaUFGYzBFRFN5RUZDeUFESUFVMkFwUUJJQWxGRFFKQkFTRUpEQU1MSUFOQkFEWUNkQ0FEUVFBMkFwUUJJQU5CQURZQ1ZDQURRUUEyQWpRZ0FTZ0NBQ0VHQ3lBR1FRWkpEUUVnQTBFRE5nS2dBU0FEUW9PQWdJQXdOd0trQVNBRFFRTTJBcEFCSUFOQkF6WUNjQ0FEUVFNMkFxd0JJQU5DZzRDQWdEQTNBNWdCSUFOQ2c0Q0FnREEzQTRnQklBTkNnNENBZ0RBM0E0QUJJQU5DZzRDQWdEQTNBM2dnQTBLRGdJQ0FNRGNEYUNBRFFvT0FnSUF3TndOZ0lBTkNnNENBZ0RBM0ExZ2dBMEtEZ0lDQU1EY0NUQ0FEUVFNMkFrUWdBMEVETmdJOERBSUxJQVFnRDNJZ0NuSWdCWEpCQUVjaENRc0NRQUovSUFaQkEwMEVRQ0FHUVFKMFFZdzFhaWdDQUF3QkMwRUVDMEVCUmdSQUlBRWdBMEV3YWhCRUlBTW9BcXdCSVFjZ0F5Z0NwQUVoRGlBREtBS2NBU0VRSUFNb0Fvd0JJUmtnQXlnQ2hBRWhCaUFES0FKOElSY2dBeWdDYkNFSUlBTW9BbVFoQkNBREtBSmNJUlFnQXlnQ1RDRU1JQU1vQWtRaEFpQURLQUk4SVJFZ0F5Z0NxQUVoSENBREtBS2dBU0VtSUFNb0FwZ0JJUTBnQXlnQ2tBRWhIU0FES0FLSUFTRVNJQU1vQW9BQklSVWdBeWdDZUNFYklBTW9BbkFoRXlBREtBSm9JUW9nQXlnQ1lDRVBJQU1vQWxnaEJTQURLQUpRSVNjTUFRc2dBd0ovQWtBZ0F3Si9Ba0FDUUNBQktBSUFRWDVxSWdSQkFVMEVRQ0FFUVFGckJFQWdBd0ovQWtBZ0FTOEJJQ0lFRFFBZ0FTOEJIQTBBUVFBTUFRdEJBZ3NpSnpZQ1VDQURBbjhDUUNBQkx3RWlJZ2NOQUNBQkx3RWVEUUJCQUF3QkMwRUNDeUlGTmdKWUlBTUNmd0pBSUFFdkFTZ2lCZzBBSUFFdkFTUU5BRUVBREFFTFFRSUxJZzgyQW1BZ0F3Si9Ba0FnQVM4QktpSU9EUUFnQVM4QkpnMEFRUUFNQVF0QkFnc2lDallDYUNBREFuOENRQ0FCTHdFd0loNE5BQ0FCTHdFc0RRQkJBQXdCQzBFQ0N5SWROZ0tRQVNBREFuOENRQ0FCTHdFeUloQU5BQ0FCTHdFdURRQkJBQXdCQzBFQ0N5SU5OZ0tZQVNBREFuOENRQ0FCTHdFNElnc05BQ0FCTHdFMERRQkJBQXdCQzBFQ0N5SW1OZ0tnQVNBREFuOENRQ0FCTHdFNkloZ05BQ0FCTHdFMkRRQkJBQXdCQzBFQ0N5SWNOZ0tvQVVFQ0lSdEJBaUVUQWtBZ0JDQUJMd0VzSWhkeURRQkJBU0VUSUFFdUFhUUJJQUV1QVl3QmF5SUNJQUpCSDNVaUFtb2dBbk5CQTBzTkFDQUJMZ0dtQVNBQkxnR09BV3NpQWlBQ1FSOTFJZ0pxSUFKelFRTkxEUUFnQVNnQ2ZDQUJLQUowUnlFVEN5QURJQk0yQW5BQ1FDQUhJQUV2QVM0aUlISU5BRUVCSVJzZ0FTNEJxQUVnQVM0QmtBRnJJZ0lnQWtFZmRTSUNhaUFDYzBFRFN3MEFJQUV1QWFvQklBRXVBWklCYXlJQ0lBSkJIM1VpQW1vZ0FuTkJBMHNOQUNBQktBSjhJQUVvQW5SSElSc0xJQU1nR3pZQ2VFRUNJUkpCQWlFVkFrQWdCaUFCTHdFMElobHlEUUJCQVNFVklBRXVBYlFCSUFFdUFad0JheUlDSUFKQkgzVWlBbW9nQW5OQkEwc05BQ0FCTGdHMkFTQUJMZ0dlQVdzaUFpQUNRUjkxSWdKcUlBSnpRUU5MRFFBZ0FTZ0NnQUVnQVNnQ2VFY2hGUXNnQXlBVk5nS0FBUUpBSUE0Z0FTOEJOaUloY2cwQVFRRWhFaUFCTGdHNEFTQUJMZ0dnQVdzaUFpQUNRUjkxSWdKcUlBSnpRUU5MRFFBZ0FTNEJ1Z0VnQVM0Qm9nRnJJZ0lnQWtFZmRTSUNhaUFDYzBFRFN3MEFJQUVvQW9BQklBRW9BbmhISVJJTElBTWdFallDaUFFZ0FTOEJIZzBDSUFFdkFSd0VRRUVDSVJFZ0EwRUNOZ0k4SUFFdkFTUWlDQTBHUVFBaERFRUFEQWNMUVFBaEVTQURRUUEyQWp4QkFDRU1RUUFnQVM4QkpDSUlSUTBHR2d3RkN5QURBbjhDUUNBQkx3RWdJZ0lOQUNBQkx3RWNEUUJCQUF3QkMwRUNDeUluTmdKUUlBTUNmd0pBSUFFdkFTSWlCZzBBSUFFdkFSNE5BRUVBREFFTFFRSUxJZ1UyQWxnZ0F3Si9Ba0FnQVM4QktDSU9EUUFnQVM4QkpBMEFRUUFNQVF0QkFnc2lEellDWUNBREFuOENRQ0FCTHdFcUlnZ05BQ0FCTHdFbURRQkJBQXdCQzBFQ0N5SUtOZ0pvSUFNZ0FpQUJMd0VzSWhkeVFRQkhRUUYwSWhNMkFuQWdBeUFHSUFFdkFTNGlDM0pCQUVkQkFYUWlHellDZUNBRElBNGdBUzhCTkNJZWNrRUFSMEVCZENJVk5nS0FBU0FESUFnZ0FTOEJOaUlaY2tFQVIwRUJkQ0lTTmdLSUFTQURJQUV2QVRBaUVDQVhja0VBUjBFQmRDSWROZ0tRQVNBRElBRXZBVElpSUNBTGNrRUFSMEVCZENJTk5nS1lBU0FESUFFdkFUZ2lJU0FlY2tFQVIwRUJkQ0ltTmdLZ0FTQURJQUV2QVRvaUJ5QVpja0VBUjBFQmRDSWNOZ0tvQVNBREFuOENRQ0FCTHdFZUlpUU5BQ0FCTHdFY0RRQkJBQXdCQzBFQ0N5SVJOZ0k4SUFFdkFTWUVRQ0FCTHdFa0lSZ01Bd3NnQVM4QkpDSVlEUUpCQUNFWVFRQU1Bd3NnQVM0QmhnRWhGQ0FCTGdHT0FTRUVRUUloQlNBREFuOUJBaUFCTHdFY0loRWdBUzhCSUNJdmNnMEFHa0VCSUFFdUFZd0JJQUV1QVlRQmF5SUdJQVpCSDNVaUJtb2dCbk5CQTBzTkFCb2dCQ0FVYXlJR0lBWkJIM1VpQm1vZ0JuTkJBMHNMSWljMkFsQWdBUzRCaWdFaENDQUJMZ0dTQVNFR0FrQWdBUzhCSGlJd0lBRXZBU0lpRUhJTkFFRUJJUVVnQVM0QmtBRWdBUzRCaUFGcklnSWdBa0VmZFNJQ2FpQUNjMEVEU3cwQUlBWWdDR3NpQlNBRlFSOTFJZ1ZxSUFWelFRTkxJUVVMSUFNZ0JUWUNXQ0FCTGdHV0FTRU1JQUV1QVo0QklRZEJBaUVLSUFNQ2YwRUNJQUV2QVNRaU1TQUJMd0VvSWhkeURRQWFRUUVnQVM0Qm5BRWdBUzRCbEFGcklnSWdBa0VmZFNJQ2FpQUNjMEVEU3cwQUdpQUhJQXhySWdJZ0FrRWZkU0lDYWlBQ2MwRURTd3NpRHpZQ1lDQUJMZ0dhQVNFeUlBRXVBYUlCSVFzQ1FDQUJMd0VtSWtBZ0FTOEJLaUl6Y2cwQVFRRWhDaUFCTGdHZ0FTQUJMZ0dZQVdzaUFpQUNRUjkxSWdKcUlBSnpRUU5MRFFBZ0N5QXlheUlDSUFKQkgzVWlBbW9nQW5OQkEwc2hDZ3NnQXlBS05nSm9JQUV1QWFZQklSNUJBaUViUVFJaEV3SkFJQzhnQVM4QkxDSTBjZzBBUVFFaEV5QUJMZ0drQVNBQkxnR01BV3NpQWlBQ1FSOTFJZ0pxSUFKelFRTkxEUUFnSGlBRWF5SUNJQUpCSDNVaUFtb2dBbk5CQTBzTkFDQUJLQUo4SUFFb0FuUkhJUk1MSUFNZ0V6WUNjQ0FCTGdHcUFTRU9Ba0FnRUNBQkx3RXVJaGh5RFFCQkFTRWJJQUV1QWFnQklBRXVBWkFCYXlJQ0lBSkJIM1VpQW1vZ0FuTkJBMHNOQUNBT0lBWnJJZ0lnQWtFZmRTSUNhaUFDYzBFRFN3MEFJQUVvQW53Z0FTZ0NkRWNoR3dzZ0F5QWJOZ0o0SUFFdUFiWUJJUmxCQWlFU1FRSWhGUUpBSUJjZ0FTOEJOQ0lnY2cwQVFRRWhGU0FCTGdHMEFTQUJMZ0djQVdzaUFpQUNRUjkxSWdKcUlBSnpRUU5MRFFBZ0dTQUhheUlDSUFKQkgzVWlBbW9nQW5OQkEwc05BQ0FCS0FLQUFTQUJLQUo0UnlFVkN5QURJQlUyQW9BQklBRXVBYm9CSVNFQ1FDQXpJQUV2QVRZaU5YSU5BRUVCSVJJZ0FTNEJ1QUVnQVM0Qm9BRnJJZ0lnQWtFZmRTSUNhaUFDYzBFRFN3MEFJQ0VnQzJzaUFpQUNRUjkxSWdKcUlBSnpRUU5MRFFBZ0FTZ0NnQUVnQVNnQ2VFY2hFZ3NnQXlBU05nS0lBU0FCTGdHdUFTRTJRUUloRFNBREFuOUJBaUEwSUFFdkFUQWlRWElOQUJwQkFTQUJMZ0dzQVNBQkxnR2tBV3NpQWlBQ1FSOTFJZ0pxSUFKelFRTkxEUUFhSURZZ0htc2lBaUFDUVI5MUlnSnFJQUp6UVFOTEN5SWROZ0tRQVNBQkxnR3lBU0VrQWtBZ0dDQUJMd0V5SWpkeURRQkJBU0VOSUFFdUFiQUJJQUV1QWFnQmF5SUNJQUpCSDNVaUFtb2dBbk5CQTBzTkFDQWtJQTVySWdJZ0FrRWZkU0lDYWlBQ2MwRURTeUVOQ3lBRElBMDJBcGdCSUFFdUFiNEJJU2xCQWlFY0lBTUNmMEVDSUNBZ0FTOEJPQ0k0Y2cwQUdrRUJJQUV1QWJ3QklBRXVBYlFCYXlJQ0lBSkJIM1VpQW1vZ0FuTkJBMHNOQUJvZ0tTQVpheUlDSUFKQkgzVWlBbW9nQW5OQkEwc0xJaVkyQXFBQklBRXVBY0lCSVRrQ1FDQTFJQUV2QVRvaVFuSU5BRUVCSVJ3Z0FTNEJ3QUVnQVM0QnVBRnJJZ0lnQWtFZmRTSUNhaUFDYzBFRFN3MEFJRGtnSVdzaUFpQUNRUjkxSWdKcUlBSnpRUU5MSVJ3TElBTWdIRFlDcUFGQkFpRUNJQU1DZjBFQ0lCRWdNSElOQUJwQkFTQUJMZ0dJQVNBQkxnR0VBV3NpRVNBUlFSOTFJaEZxSUJGelFRTkxEUUFhSUFnZ0ZHc2lGQ0FVUVI5MUloUnFJQlJ6UVFOTEN5SVJOZ0k4QWtBZ01DQXhjZzBBUVFFaEFpQUJMZ0dVQVNBQkxnR0lBV3NpRkNBVVFSOTFJaFJxSUJSelFRTkxEUUFnRENBSWF5SUlJQWhCSDNVaUNHb2dDSE5CQTBzTkFDQUJLQUo0SUFFb0FuUkhJUUlMSUFNZ0FqWUNSRUVDSVJRZ0F3Si9RUUlnTVNCQWNnMEFHa0VCSUFFdUFaZ0JJQUV1QVpRQmF5SUlJQWhCSDNVaUNHb2dDSE5CQTBzTkFCb2dNaUFNYXlJSUlBaEJIM1VpQ0dvZ0NITkJBMHNMSWd3MkFrd0NRQ0FRSUM5eURRQkJBU0VVSUFFdUFaQUJJQUV1QVl3QmF5SUlJQWhCSDNVaUNHb2dDSE5CQTBzTkFDQUdJQVJySWdRZ0JFRWZkU0lFYWlBRWMwRURTeUVVQ3lBRElCUTJBbHhCQWlFSVFRSWhCQUpBSUJBZ0YzSU5BRUVCSVFRZ0FTNEJuQUVnQVM0QmtBRnJJaEFnRUVFZmRTSVFhaUFRYzBFRFN3MEFJQWNnQm1zaUJpQUdRUjkxSWdacUlBWnpRUU5MRFFBZ0FTZ0NlQ0FCS0FKMFJ5RUVDeUFESUFRMkFtUUNRQ0FYSUROeURRQkJBU0VJSUFFdUFhQUJJQUV1QVp3QmF5SUdJQVpCSDNVaUJtb2dCbk5CQTBzTkFDQUxJQWRySWdZZ0JrRWZkU0lHYWlBR2MwRURTeUVJQ3lBRElBZzJBbXhCQWlFR0lBTUNmMEVDSUJnZ05ISU5BQnBCQVNBQkxnR29BU0FCTGdHa0FXc2lCeUFIUVI5MUlnZHFJQWR6UVFOTERRQWFJQTRnSG1zaUJ5QUhRUjkxSWdkcUlBZHpRUU5MQ3lJWE5nSjhBa0FnR0NBZ2NnMEFRUUVoQmlBQkxnRzBBU0FCTGdHb0FXc2lCeUFIUVI5MUlnZHFJQWR6UVFOTERRQWdHU0FPYXlJSElBZEJIM1VpQjJvZ0IzTkJBMHNOQUNBQktBS0FBU0FCS0FKOFJ5RUdDeUFESUFZMkFvUUJRUUloRUNBREFuOUJBaUFnSURWeURRQWFRUUVnQVM0QnVBRWdBUzRCdEFGcklnY2dCMEVmZFNJSGFpQUhjMEVEU3cwQUdpQWhJQmxySWdjZ0IwRWZkU0lIYWlBSGMwRURTd3NpR1RZQ2pBRUNRQ0EzSUVGeURRQkJBU0VRSUFFdUFiQUJJQUV1QWF3QmF5SUhJQWRCSDNVaUIyb2dCM05CQTBzTkFDQWtJRFpySWdjZ0IwRWZkU0lIYWlBSGMwRURTeUVRQ3lBRElCQTJBcHdCUVFJaEIwRUNJUTRDUUNBM0lEaHlEUUJCQVNFT0lBRXVBYndCSUFFdUFiQUJheUlMSUF0QkgzVWlDMm9nQzNOQkEwc05BQ0FwSUNScklnc2dDMEVmZFNJTGFpQUxjMEVEU3cwQUlBRW9Bb0FCSUFFb0FueEhJUTRMSUFNZ0RqWUNwQUVDUUNBNElFSnlEUUJCQVNFSElBRXVBY0FCSUFFdUFid0JheUlMSUF0QkgzVWlDMm9nQzNOQkEwc05BQ0E1SUNscklnY2dCMEVmZFNJSGFpQUhjMEVEU3lFSEN5QURJQWMyQXF3QkRBVUxRUUloRVNBRFFRSTJBandnQVM4QkpDRUlEQUlMUVFJTElndzJBa3hCQWlFRUlBTkJBaUFJUVFCSFFRRjBJQTRiSWdnMkFtd2dBMEVDSUFaQkFFZEJBWFFnQWhzaUZEWUNYQ0FESUFjZ0lYSkJBRWRCQVhRaUJ6WUNyQUVnQXlBUUlDQnlRUUJIUVFGMEloQTJBcHdCSUFNZ0dTQWVja0VBUjBFQmRDSVpOZ0tNQVNBRElBc2dGM0pCQUVkQkFYUWlGellDZkVFQ0lRSUNRQ0FZSUNSeURRQkJBU0VDSUFFdUFaUUJJQUV1QVlnQmF5SVlJQmhCSDNVaUdHb2dHSE5CQTBzTkFDQUJMZ0dXQVNBQkxnR0tBV3NpR0NBWVFSOTFJaGhxSUJoelFRTkxEUUFnQVNnQ2VDQUJLQUowUnlFQ0N5QURJQUkyQWtRQ1FDQUdJQTV5RFFCQkFTRUVJQUV1QVp3QklBRXVBWkFCYXlJR0lBWkJIM1VpQm1vZ0JuTkJBMHNOQUNBQkxnR2VBU0FCTGdHU0FXc2lCaUFHUVI5MUlnWnFJQVp6UVFOTERRQWdBU2dDZUNBQktBSjBSeUVFQ3lBRElBUTJBbVJCQWlFT1FRSWhCZ0pBSUFzZ0huSU5BRUVCSVFZZ0FTNEJ0QUVnQVM0QnFBRnJJZ3NnQzBFZmRTSUxhaUFMYzBFRFN3MEFJQUV1QWJZQklBRXVBYW9CYXlJTElBdEJIM1VpQzJvZ0MzTkJBMHNOQUNBQktBS0FBU0FCS0FKOFJ5RUdDeUFESUFZMkFvUUJBa0FnSUNBaGNnMEFRUUVoRGlBQkxnRzhBU0FCTGdHd0FXc2lDeUFMUVI5MUlndHFJQXR6UVFOTERRQWdBUzRCdmdFZ0FTNEJzZ0ZySWdzZ0MwRWZkU0lMYWlBTGMwRURTdzBBSUFFb0FvQUJJQUVvQW54SElRNExJQU1nRGpZQ3BBRU1BZ3NnQ0NFTVFRSUxJZ0kyQWtRZ0F5QUJMd0VtSUF4Qi8vOERjWEpCQUVkQkFYUWlERFlDVENBREFuOENRQ0FIUlFSQUlBUUVRRUVDSVJRZ0EwRUNOZ0pjSUFZTkFrRUFEQU1MUVFBaEZDQURRUUEyQWx4QkFDQUdSUTBDR2d3QkMwRUNJUlFnQTBFQ05nSmNDMEVDQ3lJRU5nSmtJQU5CQWlBT1FRQkhRUUYwSUFZYklnZzJBbXdnQXdKL0FrQWdJRVVFUUNBWEJFQkJBaUVYSUFOQkFqWUNmQ0FaRFFKQkFBd0RDMEVBSVJjZ0EwRUFOZ0o4UVFBZ0dVVU5BaG9NQVF0QkFpRVhJQU5CQWpZQ2ZBdEJBZ3NpQmpZQ2hBRWdBeUFMSUJoeVFRQkhRUUYwSWdjMkFxd0JJQU1nQ3lBUWNrRUFSMEVCZENJT05nS2tBU0FEUVFJZ0VFRUFSMEVCZENBZUd5SVFOZ0tjQVNBRElCa2dJWEpCQUVkQkFYUWlHVFlDakFFTElBa2dKM0lnQlhJZ0QzSWdDbklnRTNJZ0czSWdGWElnRW5JZ0hYSWdEWElnSm5JZ0hISWdFWElnQW5JZ0RISWdGSElnQkhJZ0NISWdGM0lnQm5JZ0dYSWdFSElnRG5JZ0IzSkZEUUVMSUFFb0Fnd2hDU0FESUFFb0FoQWlCU0FCS0FJVUlnUnFJZ1pCTXlBR1FUTklHeUlHUVFBZ0JrRUFTaHRCMEJkcUxRQUFJZ1kyQWlBZ0F5QUVJQWxxSWdKQk15QUNRVE5JR3lJQ1FRQWdBa0VBU2hzaUNFR1FGMm90QUFBaUFqWUNIQ0FESUFoQkEyeEJrQmhxSWdnMkFoZ0NRQ0F0UlEwQUlBUWdBU2dDekFFb0FoUWlCMGNFUUNBRElBUWdCMnBCQVdwQkFYWWlCeUFGYWlJTlFUTWdEVUV6U0JzaURVRUFJQTFCQUVvYlFkQVhhaTBBQURZQ0NDQURJQWNnQ1dvaUIwRXpJQWRCTTBnYklnZEJBQ0FIUVFCS0d5SUhRWkFYYWkwQUFEWUNCQ0FESUFkQkEyeEJrQmhxTmdJQURBRUxJQU1nQmpZQ0NDQURJQUkyQWdRZ0F5QUlOZ0lBQ3dKQUlDNUZEUUFnQkNBQktBTElBU2dDRkNJSFJ3UkFJQU1nQkNBSGFrRUJha0VCZGlJRUlBVnFJZ1ZCTXlBRlFUTklHeUlGUVFBZ0JVRUFTaHRCMEJkcUxRQUFOZ0lVSUFNZ0JDQUphaUlFUVRNZ0JFRXpTQnNpQkVFQUlBUkJBRW9iSWdSQmtCZHFMUUFBTmdJUUlBTWdCRUVEYkVHUUdHbzJBZ3dNQVFzZ0F5QUdOZ0lVSUFNZ0FqWUNFQ0FESUFnMkFnd0xJQUFvQWdBZ0h5QTZiQ0lVUVFoMGFpQXFRUVIwYWlFSlFRQWhBa0VESVFRZ0EwRXdhaUVHQTBBZ0JpZ0NCQ0lGQkVBZ0NTQUZJQ01nR2hBWkN5QUdLQUlNSWdVRVFDQUpRUVJxSUFVZ0lpQWFFQmtMSUFZb0FoUWlCUVJBSUFsQkNHb2dCU0FpSUJvUUdRc2dCaWdDSENJRkJFQWdDVUVNYWlBRklDSWdHaEFaQ3lBRUlRZ0NRQUpBQWtBZ0JpZ0NBQ0lFSUFZb0FnZ2lEMGNOQUNBRUlBWW9BaEJIRFFBZ0JDQUdLQUlZUncwQUlBUkZEUUlnQXlBQ1FReHNhaUlGS0FJSUlRd2dCU2dDQkNFYklBUkJCRWtOQVNBYlFRSjJRUUpxSVJCQkVDRVBJQWtoQkFOQUFrQWdCQ0FvYWlJQ0xRQUFJZ29nQkMwQUFDSU9heUlGSUFWQkgzVWlCV29nQlhNaUJ5QWJUdzBBSUFRZ0xHb2lFUzBBQUNJRklBcHJJZzBnRFVFZmRTSU5haUFOY3lBTVR3MEFJQVFnR21vaUhDMEFBQ0lTSUE1cklnMGdEVUVmZFNJTmFpQU5jeUFNVHcwQUFrQWdCeUFRU1FSQUlBUWdKV29pRnkwQUFDRVZBbjhnQkNBcmFpSU5MUUFBSWhNZ0Ntc2lCeUFIUVI5MUlnZHFJQWR6SUF4SkJFQkJBeUVkSUFJZ0VpQUtJQTVxSUFWcUlnSkJBWFJxSUJOcVFRUnFRUU4yT2dBQUlCRWdBaUFUYWtFQ2FrRUNkam9BQUNBQ1FRUnFJUkVnQkNBL2FpMEFBQ0VISUJOQkEyd01BUXNnQ2lBU2FpRVJJQVVoQjBFQ0lSMGdBaUVOUVFJTElRSWdEU0FDSUJGcUlBZEJBWFJxSUIxMk9nQUFJQlVnRG1zaUFpQUNRUjkxSWdKcUlBSnpJQXhQRFFFZ0JDQUZJQW9nRW1vZ0Rtb2lBa0VCZEdvZ0ZXcEJCR3BCQTNZNkFBQWdIQ0FDSUJWcVFRSnFRUUoyT2dBQUlCY2dBaUFWUVFOc2FpQUVJRDVxTFFBQVFRRjBha0VFYWtFRGRqb0FBQXdDQ3lBQ0lBb2dFbW9nQlVFQmRHcEJBbXBCQW5ZNkFBQUxJQVFnQlNBT2FpQVNRUUYwYWtFQ2FrRUNkam9BQUFzZ0JFRUJhaUVFSUE5QmYyb2lEdzBBQ3d3Q0N3Si9JQVFFUUNBSklBUWdBeUFDUVF4c2FpQWFFQmdnQmlnQ0NDRVBDeUFQQ3dSQUlBbEJCR29nRHlBRElBSkJER3hxSUJvUUdBc2dCaWdDRUNJRUJFQWdDVUVJYWlBRUlBTWdBa0VNYkdvZ0doQVlDeUFHS0FJWUlnUkZEUUVnQ1VFTWFpQUVJQU1nQWtFTWJHb2dHaEFZREFFTElBUWdCU2dDQUdwQmYyb3RBQUFpQWtFQmFpRUhRUUFnQW1zaERrRVFJUThnQ1NFRUEwQUNRQ0FFSUNocUloTXRBQUFpRFNBRUxRQUFJZ3BySWdVZ0JVRWZkU0lGYWlBRmN5QWJUdzBBSUFRZ0xHb2lFUzBBQUNJU0lBMXJJZ1VnQlVFZmRTSUZhaUFGY3lBTVR3MEFJQVFnR21vaUVDMEFBQ0lWSUFwcklnVWdCVUVmZFNJRmFpQUZjeUFNVHcwQUlBSWhCU0FFSUN0cUxRQUFJaHdnRFdzaUhTQWRRUjkxSWgxcUlCMXpJQXhKQkVBZ0VTQVNJQTRnQWlBS0lBMXFRUUZxUVFGMklCSkJBWFJySUJ4cVFRRjFJZ1VnQlNBQ1Noc2dCU0FPU0J0cU9nQUFJQWNoQlFzZ0V5QU5BbjhnQkNBbGFpMEFBQ0lUSUFwckloRWdFVUVmZFNJUmFpQVJjeUFNU1FSQUlCQWdGU0FPSUFJZ0NpQU5ha0VCYWtFQmRpQVZRUUYwYXlBVGFrRUJkU0lUSUJNZ0Frb2JJQk1nRGtnYmFqb0FBQ0FGUVFGcUlRVUxRUUFnQldzaUV3c2dCU0FTSUJWcklBb2dEV3RCQW5ScVFRUnFRUU4xSWhJZ0VpQUZTaHNnRWlBVFNCc2lCV3BCc0M1cUxRQUFPZ0FBSUFRZ0NpQUZhMEd3TG1vdEFBQTZBQUFMSUFSQkFXb2hCQ0FQUVg5cUlnOE5BQXNMSUFoQmYyb2hCQ0FHUVNCcUlRWWdDU0E5YWlFSlFRSWhBaUFJRFFBTElBRW9BZ3doQkNBRElBRW9BaEFpQlNBQktBSVVJZ1lnQVNnQ0dDSUNhaUlKUVRNZ0NVRXpTQnNpQ1VFQUlBbEJBRW9iUVFKMFFlQTlhaWdDQUNJSmFpSUlRVE1nQ0VFelNCc2lDRUVBSUFoQkFFb2JRZEFYYWkwQUFDSUlOZ0lnSUFNZ0JDQUphaUlIUVRNZ0IwRXpTQnNpQjBFQUlBZEJBRW9iSWcxQmtCZHFMUUFBSWdjMkFod2dBeUFOUVFOc1FaQVlhaUlOTmdJWUFrQWdMVVVOQUNBR0lBRW9Bc3dCS0FJVUlneEhCRUFnQXlBSklBSWdER29pREVFeklBeEJNMGdiSWd4QkFDQU1RUUJLRzBFQ2RFSGdQV29vQWdCcVFRRnFRUUYySWd3Z0JXb2lEMEV6SUE5Qk0wZ2JJZzlCQUNBUFFRQktHMEhRRjJvdEFBQTJBZ2dnQXlBRUlBeHFJZ3hCTXlBTVFUTklHeUlNUVFBZ0RFRUFTaHNpREVHUUYyb3RBQUEyQWdRZ0F5QU1RUU5zUVpBWWFqWUNBQXdCQ3lBRElBZzJBZ2dnQXlBSE5nSUVJQU1nRFRZQ0FBc0NRQ0F1UlEwQUlBWWdBU2dDeUFFb0FoUWlERWNFUUNBRElBVWdDU0FDSUF4cUlnWkJNeUFHUVROSUd5SUdRUUFnQmtFQVNodEJBblJCNEQxcUtBSUFha0VCYWtFQmRpSUphaUlGUVRNZ0JVRXpTQnNpQlVFQUlBVkJBRW9iUWRBWGFpMEFBRFlDRkNBRElBUWdDV29pQkVFeklBUkJNMGdiSWdSQkFDQUVRUUJLR3lJRVFaQVhhaTBBQURZQ0VDQURJQVJCQTJ4QmtCaHFOZ0lNREFFTElBTWdDRFlDRkNBRElBYzJBaEFnQXlBTk5nSU1DeUFBS0FJQUlEeHFJQlJCQm5ScUlDcEJBM1JxSWdrZ08yb2hCRUVBSVFvZ0EwRXdhaUVHUVFBaEFnTkFJQVlvQWdRaUJRUkFJQWtnQlNBaklCWVFFQ0FFSUFZb0FnUWdJeUFXRUJBTElBWW9BaVFpQlFSQUlBa2dHbW9nQlNBaklCWVFFQ0FFSUJwcUlBWW9BaVFnSXlBV0VCQUxJQVlvQWhRaUJRUkFJQWxCQkdvZ0JTQWlJQllRRUNBRVFRUnFJQVlvQWhRZ0lpQVdFQkFMSUFZb0FqUWlCUVJBSUFrZ0dtcEJCR29nQlNBaUlCWVFFQ0FFSUJwcVFRUnFJQVlvQWpRZ0lpQVdFQkFMSUFJaEJRSkFBa0FnQmlnQ0FDSUNJQVlvQWdnaUQwY05BQ0FDSUFZb0FoQkhEUUFnQWlBR0tBSVlSdzBBSUFKRkRRRWdDU0FDSUFNZ0NrRU1iR29pQWlBV0VDc2dCQ0FHS0FJQUlBSWdGaEFyREFFTEFuOGdBZ1JBSUFrZ0FpQURJQXBCREd4cUlnSWdGaEFTSUFRZ0JpZ0NBQ0FDSUJZUUVpQUdLQUlJSVE4TElBOExCRUFnQ1VFQ2FpQVBJQU1nQ2tFTWJHb2lBaUFXRUJJZ0JFRUNhaUFHS0FJSUlBSWdGaEFTQ3lBR0tBSVFJZ0lFUUNBSlFRUnFJQUlnQXlBS1FReHNhaUlDSUJZUUVpQUVRUVJxSUFZb0FoQWdBaUFXRUJJTElBWW9BaGdpQWtVTkFDQUpRUVpxSUFJZ0F5QUtRUXhzYWlJQ0lCWVFFaUFFUVFacUlBWW9BaGdnQWlBV0VCSUxJQVFnSldvaEJDQUpJQ1ZxSVFrZ0JrRkFheUVHUVFFaEFrRUNJUW9nQlVVTkFBc0xRUUFnS2tFQmFpSUVJQVFnSDBZaUJCc2hLaUFCUWRnQmFpRUJJQVFnT21vaU9pQUFLQUlJU1EwQUN3c2dBMEd3QVdva0FBdUNCUUVLZnlNQVFaQUJheUlMSkFBQ1FBSkFJQUpCQUVnTkFDQURRUUJJRFFBZ0FpQUhhaUFFU3cwQUlBTWdDR3BCQVdvZ0JVc05BQ0FGSVF3Z0F5RU9EQUVMSUFBZ0N5QUNJQU1nQkNBRklBY2dDRUVCYWlJTUlBY1FEQ0FBSUFRZ0JXeHFJQXNnQnlBTWJHb2dBaUFESUFRZ0JTQUhJQXdnQnhBTUlBc2hBQ0FISVFSQkFDRUNDd0pBSUFoQkFYWWlCVVVOQUNBSFFRRjJJZ05GRFFCQkVDQUhheUVRUVFnZ0Jtc2hDU0FFUVFGMElnMGdCMnNoRVNBQUlBSnFJaElnQkNBT2JHb2hCeUFCSVFJZ0JTRUlBMEFnQXlFQUEwQWdCeUFOYWkwQUFDRUtJQUlnQ1NBSExRQUFiQ0FFSUFkcUxRQUFJZzhnQm14cVFRTjBRU0JxUVFaMk9nQUFJQUlnQ1NBUGJDQUdJQXBzYWtFRGRFRWdha0VHZGpvQUNDQUhRUUZxSWdvZ0RXb3RBQUFoRHlBQ0lBa2dCeTBBQVd3Z0JDQUthaTBBQUNJS0lBWnNha0VEZEVFZ2FrRUdkam9BQVNBQ0lBa2dDbXdnQmlBUGJHcEJBM1JCSUdwQkJuWTZBQWtnQWtFQ2FpRUNJQWRCQW1vaEJ5QUFRWDlxSWdBTkFBc2dCeUFSYWlFSElBSWdFR29oQWlBSVFYOXFJZ2dOQUFzZ0FVRkFheUVDSUJJZ0RDQU9haUFFYkdvaEJ3TkFJQU1oQUFOQUlBY2dEV290QUFBaEFTQUNJQWtnQnkwQUFHd2dCQ0FIYWkwQUFDSUlJQVpzYWtFRGRFRWdha0VHZGpvQUFDQUNJQWdnQ1d3Z0FTQUdiR3BCQTNSQklHcEJCblk2QUFnZ0IwRUJhaUlCSUExcUxRQUFJUWdnQWlBSklBY3RBQUZzSUFFZ0JHb3RBQUFpQVNBR2JHcEJBM1JCSUdwQkJuWTZBQUVnQWlBQklBbHNJQVlnQ0d4cVFRTjBRU0JxUVFaMk9nQUpJQUpCQW1vaEFpQUhRUUpxSVFjZ0FFRi9haUlBRFFBTElBY2dFV29oQnlBQ0lCQnFJUUlnQlVGL2FpSUZEUUFMQ3lBTFFaQUJhaVFBQy8wRUFRdC9Jd0JCa0FGcklnd2tBQ0FIUVFGcUlRa0NRQUpBSUFKQkFFZ05BQ0FESUFocUlBVkxEUUFnQTBFQVNBMEFJQUlnQ1dvZ0JFc05BQ0FFSVFrZ0F5RUxEQUVMSUFBZ0RDQUNJQU1nQkNBRklBa2dDQ0FKRUF3Z0FDQUVJQVZzYWlBTUlBZ2dDV3hxSUFJZ0F5QUVJQVVnQ1NBSUlBa1FEQ0FNSVFBZ0NDRUZRUUFoQWdzQ1FDQUlRUUYySWdoRkRRQWdCMEVCZGlJRVJRMEFRUkFnQjJzaERrRUlJQVpySVFvZ0NVRUJkQ0FIYXlFUElBQWdBbW9pRVNBSklBdHNhaUVDSUFFaEF5QUlJUUFEUUNBRUlRY0RRQ0FDUVFGcUlBbHFMUUFBSVJBZ0FpQUphaTBBQUNFTklBTWdBaTBBQVNJU0lBWnNJQW9nQWkwQUFHeHFRUU4wUVNCcVFRWjJPZ0FBSUFNZ0JpQVFiQ0FLSUExc2FrRURkRUVnYWtFR2Rqb0FDQ0FDTFFBQ0lRMGdBa0VDYWlJQ0lBbHFMUUFBSVJNZ0F5QUdJQTFzSUFvZ0VteHFRUU4wUVNCcVFRWjJPZ0FCSUFNZ0JpQVRiQ0FLSUJCc2FrRURkRUVnYWtFR2Rqb0FDU0FEUVFKcUlRTWdCMEYvYWlJSERRQUxJQUlnRDJvaEFpQURJQTVxSVFNZ0FFRi9haUlBRFFBTElBRkJRR3NoQXlBUklBVWdDMm9nQ1d4cUlRSURRQ0FFSVFjRFFDQUNRUUZxSUFscUxRQUFJUUFnQWlBSmFpMEFBQ0VCSUFNZ0FpMEFBU0lGSUFac0lBb2dBaTBBQUd4cVFRTjBRU0JxUVFaMk9nQUFJQU1nQUNBR2JDQUJJQXBzYWtFRGRFRWdha0VHZGpvQUNDQUNMUUFDSVFFZ0FrRUNhaUlDSUFscUxRQUFJUXNnQXlBQklBWnNJQVVnQ214cVFRTjBRU0JxUVFaMk9nQUJJQU1nQmlBTGJDQUFJQXBzYWtFRGRFRWdha0VHZGpvQUNTQURRUUpxSVFNZ0IwRi9haUlIRFFBTElBSWdEMm9oQWlBRElBNXFJUU1nQ0VGL2FpSUlEUUFMQ3lBTVFaQUJhaVFBQzdrSEFRVi9Jd0JCRUdzaUJDUUFBa0FnQUNBQlFRQkJ5QUFRQnlJREVBSWlBUTBBUVFFaEFTQURLQUlBUWY4QlN3MEFJQUFnQTBFRWFoQUNJZ0VOQUVFQklRRWdBeWdDQkVFZlN3MEFJQUJCQVJBRERRQWdBRUVCRUFNaUFrRi9SZzBBSUFNZ0FrRUJSallDQ0NBQUlBUkJER29RQWlJQkRRQWdBeUFFS0FJTVFRRnFJZ0UyQWd3Z0FVRUlTd1JBUVFFaEFRd0JDd0pBSUFGQkFra05BQ0FBSUFOQkVHb1FBaUlCRFFFZ0F5Z0NFQ0lCUVFaTElnSUVRRUVCSVFFTUFnc2dBZzBBQWtBQ1FBSkFBa0FnQVVFQmF3NEdCQUVDQWdJREFBc2dBeUFES0FJTUlnRkJBblFRQ2lJQ05nSVVJQUpGQkVCQi8vOERJUUVNQlFzZ0FVVU5BMEVBSVFJRFFDQUFJQVJCREdvUUFpSUJEUVVnQXlnQ0ZDQUNRUUowYWlBRUtBSU1RUUZxTmdJQUlBSkJBV29pQWlBREtBSU1TUTBBQ3d3REN5QURJQU1vQWd3aUFrRUNkRUY4YWlJQkVBb2lCVFlDR0NBRElBRVFDaUlHTmdJY1FmLy9BeUVCSUFWRkRRTWdCa1VOQXlBQ1FRRkdEUUpCQUNFQ0EwQWdBQ0FFUVF4cUVBSWlBUTBFSUFKQkFuUWlCU0FES0FJWWFpQUVLQUlNTmdJQUlBQWdCRUVNYWhBQ0lnRU5CQ0FES0FJY0lBVnFJQVFvQWd3MkFnQWdBa0VCYWlJQ0lBTW9BZ3hCZjJwSkRRQUxEQUlMUVFFaEFTQUFRUUVRQXlJQ1FYOUdEUUlnQXlBQ1FRRkdOZ0lnSUFBZ0JFRU1haEFDSWdFTkFpQURJQVFvQWd4QkFXbzJBaVFNQVFzZ0FDQUVRUXhxRUFJaUFRMEJJQU1nQkNnQ0RFRUJhaUlCTmdJb0lBTWdBVUVDZEJBS0lnSTJBaXdnQWtVRVFFSC8vd01oQVF3Q0N5QUJSUTBBSUFNb0FneEJBblJCckR0cUtBSUFJUVpCQUNFQ0EwQWdBQ0FHRUFNaEJTQURLQUlzSUFKQkFuUnFJQVUyQWdCQkFTRUJJQVVnQXlnQ0RFOE5BaUFDUVFGcUlnSWdBeWdDS0VrTkFBc0xJQUFnQkVFTWFoQUNJZ0VOQUVFQklRRWdCQ2dDRENJQ1FSOUxEUUFnQXlBQ1FRRnFOZ0l3SUFBZ0JFRU1haEFDSWdFTkFFRUJJUUVnQkNnQ0RFRWZTdzBBSUFCQkFSQURCRUFNQVFzZ0FFRUNFQU5CQWtzRVFBd0JDeUFBSUFSQkNHb1FCU0lCRFFBZ0JDZ0NDRUVhYWlJQlFUTkxCRUJCQVNFQkRBRUxJQU1nQVRZQ05DQUFJQVJCQ0dvUUJTSUJEUUFnQkNnQ0NFRWFha0V6U3dSQVFRRWhBUXdCQ3lBQUlBUkJDR29RQlNJQkRRQkJBU0VCSUFRb0FnZ2lBa0VNYWtFWVN3MEFJQU1nQWpZQ09DQUFRUUVRQXlJQ1FYOUdEUUFnQXlBQ1FRRkdOZ0k4SUFCQkFSQURJZ0pCZjBZTkFDQURJQUpCQVVZMkFrQWdBRUVCRUFNaUFrRi9SZzBBSUFNZ0FrRUJSallDUkNBQUVCOUJBQ0VCQ3lBRVFSQnFKQUFnQVF2cUJRRUpmd0pBSUFJb0Fwd0NSUVJBREFFTFFRRWhCZ05BQWtBQ1FDQUNJQVZCRkd4cUtBS2dBaUlFUVFWTERRQWdCRUVCYXc0RkFBQUFBQU1CQ3lBRlFRRnFJUVVNQVFzTElBUWhCZ3NDZndKQUlBRW9BaEFpQkVFQlRRUkFJQVJCQVdzRVFDQURLQUlBUVFWR0JFQWdBRUlBTndJQUlBSW9BaFFoQlVFQUlRUU1Bd3NnQUNnQ0FDSUVJQUlvQWhRaUJVME5BaUFFSUFWcklBRW9BaFFpQjBFQmRra05BaUFBS0FJRUlBZHFEQU1MUVFBaEJRSi9RUUFnQXlnQ0FFRUZSZzBBR2lBQUtBSU1JZ2NnQUNnQ0NDQUNLQUlNVFEwQUdpQUJLQUlNSUFkcUN5RUhRUUFoQkFKL0lBRW9BaVFpQ0FSQUlBSW9BZ3dnQjJvaEJRc2dCU0FES0FJRUlncEZJQVZCQUVkeGF5SUpDd1JBSUFsQmYyb2lBeUFESUFodUlnc2dDR3hySVFNTElBZ0VRQ0FCS0FJb0lReEJBQ0VGQTBBZ0RDQUZRUUowYWlnQ0FDQUVhaUVFSUFWQkFXb2lCU0FJUncwQUN3c0NRQ0FKUlFSQVFRQWhCQXdCQ3lBRUlBdHNJUVFnQVNnQ0tDRUlRUUFoQlFOQUlBZ2dCVUVDZEdvb0FnQWdCR29oQkNBRlFRRnFJZ1VnQTAwTkFBc0xJQXBGQkVBZ0FTZ0NIQ0FFYWlFRUN5QUdSUVJBSUFJb0FpQWhBeUFCS0FJZ0lRRWdBaWdDSENFR0lBQWdCellDRENBQUlBSW9BZ3cyQWdnZ0JpQUJJQU5xSWdCQkgzVWdBSEVnQkdwcUR3c2dBRUlBTndJSVFRQVBDMEVBSVFWQkFDRUVJQU1vQWdCQkJVY0VRQ0FBS0FJTUlRVWdBQ2dDQ0NBQ0tBSU1JZ1JMQkVBZ0FTZ0NEQ0FGYWlFRkN5QUVJQVZxUVFGMElBTW9BZ1JGYXlFRUN5QUdSUVJBSUFBZ0JUWUNEQ0FBSUFJb0FndzJBZ2dnQkE4TElBQkNBRGNDQ0VFQUR3c0NRQ0FGSUFSTkRRQWdCU0FFYXlBQktBSVVJZ0ZCQVhaTkRRQWdBQ2dDQkNBQmF3d0JDeUFBS0FJRUN5RUVJQU1vQWdSRkJFQWdCQ0FGYWlBQ0tBSVlJZ0JCSDNVZ0FIRnFEd3NnQUNBRU5nSUVJQUlvQWhnaEFTQUdCRUFnQUVFQU5nSUVJQUJCQUNBQmF5QUJRUjkxY1RZQ0FFRUFEd3NnQUNBRk5nSUFJQVFnQldvZ0FVRWZkU0FCY1dvTHZBRUJDSDhnQWdSQUlBRkJmMm9oQjBFQUlBRnJRZGdCYkNFSVFRRWdBV3RCMkFGc0lRa2dBVUYvYzBIWUFXd2hDZ05BSUFBZ0JrSFlBV3hxSWdNZ0EwR29mbXBCQUNBRUd6WUN5QUVnQXdKL0lBVkZCRUFnQTBFQU5nTE1BVUVBREFFTElBTWdBeUFJYWpZQ3pBRWdBeUFKYWtFQUlBUWdCMGtiQ3pZQzBBRWdBeUFESUFwcVFRQWdCQnRCQUNBRkd6WUMxQUZCQUNBRVFRRnFJZ01nQVNBRFJpSURHeUVFSUFNZ0JXb2hCU0FHUVFGcUlnWWdBa2NOQUFzTEMzY0JBbjlCQVNFQ0FrQWdBRUVCRUFOQmYwWU5BQ0FCSUFCQkFoQUROZ0lFSUFFZ0FFRUZFQU1pQURZQ0FDQUFRWDVxUVFOSkRRQUNRQ0FBUVF4TERRQkJBU0FBZENJRFFjQThjVVVFUUNBRFFhQURjVVVOQVNBQVFRWkdEUUlnQVNnQ0JBMEJEQUlMSUFFb0FnUU5BUXRCQUNFQ0N5QUNDNUlUQVFaL0lBQWdBU2dDQUNJTk5nSUFJQUFnQUNnQ3hBRkJBV28yQXNRQklBSWdCUkFkQWtBQ1FBSkFBa0FDUUNBTlFSOUdCRUFnQUVFQU5nSVVJQUFvQXNRQlFRRkxEUUVnQUVFY2FpRUpJQUZCeUFKcUlRUkJGeUVCSUFjaEFBTkFJQWxCRURzQkFDQUFJQVFvQWdBNkFBQWdBQ0FFS0FJRU9nQUJJQUFnQkNnQ0NEb0FBaUFBSUFRb0FndzZBQU1nQUNBRUtBSVFPZ0FFSUFBZ0JDZ0NGRG9BQlNBQUlBUW9BaGc2QUFZZ0FDQUVLQUljT2dBSElBQWdCQ2dDSURvQUNDQUFJQVFvQWlRNkFBa2dBQ0FFS0FJb09nQUtJQUFnQkNnQ0xEb0FDeUFBSUFRb0FqQTZBQXdnQUNBRUtBSTBPZ0FOSUFBZ0JDZ0NPRG9BRGlBQUlBUW9Banc2QUE4Z0FTSURRWDlxSVFFZ0NVRUNhaUVKSUFCQkVHb2hBQ0FFUVVCcklRUWdBdzBBQ3lBQ0lBY1FHd3dFQ3lBQVFSeHFJUWtnRFFSQUlBa2dBU2tDa0FJM0FnQWdDU0FCS1FHK0FqY0JMaUFKSUFFcEFyZ0NOd0lvSUFrZ0FTa0NzQUkzQWlBZ0NTQUJLUUtvQWpjQ0dDQUpJQUVwQXFBQ053SVFJQWtnQVNrQ21BSTNBZ2dnQkNnQ0FDRUtBa0FnQVNnQ0NDSUxSUTBBSUFRZ0NpQUxhaUlLTmdJQUlBUWdDa0YvVEFSL0lBcEJOR29GSUFwQk5FZ05BU0FLUVV4cUN5SUtOZ0lBQ3lBQUlBbzJBaFFnQVVISUQyb2hEQ0FCUWNnQ2FpRUVBa0FDUUNBQUtBSUFRUVpOQkVBZ0NTOEJBRVVOQVVFQklRZ2dCQ0FLUVFBZ0RDZ0NBQkFHUlEwQ0RBZ0xJQUF2QVV3RVFDQUJRY2dPYWlBS0VERUxRYkEwSVFwQkR5RUlBMEFnQ0NFTElBUWdBU0FLS0FJQVFRSjBha0hJRG1vb0FnQWlDRFlDQUFKQUFrQWdDRVVFUUNBSkx3RUFSUTBCQzBFQklRZ2dCQ0FBS0FJVVFRRWdEQ2dDQUJBR1JRMEJEQW9MSUFSQi8vLy9CellDQUFzZ0NrRUVhaUVLSUF0QmYyb2hDQ0FNUVFScUlRd2dDVUVDYWlFSklBUkJRR3NoQkNBTERRQUxEQVFMSUFSQi8vLy9CellDQUFzZ0FVR0lBMm9oQkFKQUlBQXZBUjRFUUVFQklRZ2dCQ0FBS0FJVVFRQWdBVUhNRDJvb0FnQVFCa1VOQVF3SEN5QUVRZi8vL3djMkFnQUxJQUZCeUFOcUlRUUNRQ0FBTHdFZ0JFQkJBU0VJSUFRZ0FDZ0NGRUVBSUFGQjBBOXFLQUlBRUFaRkRRRU1Cd3NnQkVILy8vOEhOZ0lBQ3lBQlFZZ0VhaUVFQWtBZ0FDOEJJZ1JBUVFFaENDQUVJQUFvQWhSQkFDQUJRZFFQYWlnQ0FCQUdSUTBCREFjTElBUkIvLy8vQnpZQ0FBc2dBVUhJQkdvaEJBSkFJQUF2QVNRRVFFRUJJUWdnQkNBQUtBSVVRUUFnQVVIWUQyb29BZ0FRQmtVTkFRd0hDeUFFUWYvLy93YzJBZ0FMSUFGQmlBVnFJUVFDUUNBQUx3RW1CRUJCQVNFSUlBUWdBQ2dDRkVFQUlBRkIzQTlxS0FJQUVBWkZEUUVNQndzZ0JFSC8vLzhITmdJQUN5QUJRY2dGYWlFRUFrQWdBQzhCS0FSQVFRRWhDQ0FFSUFBb0FoUkJBQ0FCUWVBUGFpZ0NBQkFHUlEwQkRBY0xJQVJCLy8vL0J6WUNBQXNnQVVHSUJtb2hCQUpBSUFBdkFTb0VRRUVCSVFnZ0JDQUFLQUlVUVFBZ0FVSGtEMm9vQWdBUUJrVU5BUXdIQ3lBRVFmLy8vd2MyQWdBTElBRkJ5QVpxSVFRQ1FDQUFMd0VzQkVCQkFTRUlJQVFnQUNnQ0ZFRUFJQUZCNkE5cUtBSUFFQVpGRFFFTUJ3c2dCRUgvLy84SE5nSUFDeUFCUVlnSGFpRUVBa0FnQUM4QkxnUkFRUUVoQ0NBRUlBQW9BaFJCQUNBQlFld1BhaWdDQUJBR1JRMEJEQWNMSUFSQi8vLy9CellDQUFzZ0FVSElCMm9oQkFKQUlBQXZBVEFFUUVFQklRZ2dCQ0FBS0FJVVFRQWdBVUh3RDJvb0FnQVFCa1VOQVF3SEN5QUVRZi8vL3djMkFnQUxJQUZCaUFocUlRUUNRQ0FBTHdFeUJFQkJBU0VJSUFRZ0FDZ0NGRUVBSUFGQjlBOXFLQUlBRUFaRkRRRU1Cd3NnQkVILy8vOEhOZ0lBQ3lBQlFjZ0lhaUVFQWtBZ0FDOEJOQVJBUVFFaENDQUVJQUFvQWhSQkFDQUJRZmdQYWlnQ0FCQUdSUTBCREFjTElBUkIvLy8vQnpZQ0FBc2dBVUdJQ1dvaEJBSkFJQUF2QVRZRVFFRUJJUWdnQkNBQUtBSVVRUUFnQVVIOEQyb29BZ0FRQmtVTkFRd0hDeUFFUWYvLy93YzJBZ0FMSUFGQnlBbHFJUVFDUUNBQUx3RTRCRUJCQVNFSUlBUWdBQ2dDRkVFQUlBRkJnQkJxS0FJQUVBWkZEUUVNQndzZ0JFSC8vLzhITmdJQUN5QUJRWWdLYWlFRUFrQWdBQzhCT2dSQVFRRWhDQ0FFSUFBb0FoUkJBQ0FCUVlRUWFpZ0NBQkFHUlEwQkRBY0xJQVJCLy8vL0J6WUNBQXNnQVVHSUVHb2hEQ0FCUWNnS2FpRUVEQUlMSUFsQ0FEY0NBQ0FKUWdBM0FTNGdDVUlBTndJb0lBbENBRGNDSUNBSlFnQTNBaGdnQ1VJQU53SVFJQWxDQURjQ0NDQUFJQVFvQWdBMkFoUU1BZ3NnQUVLUWdNQ0FnSUtBQ0RjQkhDQUFRcENBd0lDQWdvQUlOd0ZFSUFCQ2tJREFnSUNDZ0FnM0FUd2dBRUtRZ01DQWdJS0FDRGNCTkNBQVFwQ0F3SUNBZ29BSU53RXNJQUJDa0lEQWdJQ0NnQWczQVNSQkFBOExJQUFvQWhnZ0FDZ0NGR29pQzBFeklBdEJNMGdiSWd0QkFDQUxRUUJLRzBFQ2RFSGdQV29vQWdBaENRSkFJQUF2QVU1RkJFQWdBQzhCVUVVTkFRc2dBVUdJRDJvZ0NSQXdDeUFFSUFGQmlBOXFLQUlBSWdzMkFnQUNRQUpBSUF0RkJFQWdBQzhCUEVVTkFRdEJBU0VJSUFRZ0NVRUJJQXdvQWdBUUJrVU5BUXdFQ3lBRVFmLy8vd2MyQWdBTElBUWdBU2dDakE4aUN6WUNRQ0FFUVVCcklRb0NRQUpBSUF0RkJFQWdBQzhCUGtVTkFRdEJBU0VJSUFvZ0NVRUJJQXdvQWdRUUJrVU5BUXdFQ3lBS1FmLy8vd2MyQWdBTElBUWdBU2dDa0E4aUN6WUNnQUVnQkVHQUFXb2hDZ0pBQWtBZ0MwVUVRQ0FBUVVCckx3RUFSUTBCQzBFQklRZ2dDaUFKUVFFZ0RDZ0NDQkFHUlEwQkRBUUxJQXBCLy8vL0J6WUNBQXNnQkNBQktBS1VEeUlMTmdMQUFTQUVRY0FCYWlFS0FrQUNRQ0FMUlFSQUlBQXZBVUpGRFFFTFFRRWhDQ0FLSUFsQkFTQU1LQUlNRUFaRkRRRU1CQXNnQ2tILy8vOEhOZ0lBQ3lBRUlBRW9BcGdQSWdzMkFvQUNJQVJCZ0FKcUlRb0NRQUpBSUF0RkJFQWdBQzhCUkVVTkFRdEJBU0VJSUFvZ0NVRUJJQXdvQWhBUUJrVU5BUXdFQ3lBS1FmLy8vd2MyQWdBTElBUWdBU2dDbkE4aUN6WUN3QUlnQkVIQUFtb2hDZ0pBQWtBZ0MwVUVRQ0FBTHdGR1JRMEJDMEVCSVFnZ0NpQUpRUUVnRENnQ0ZCQUdSUTBCREFRTElBcEIvLy8vQnpZQ0FBc2dCQ0FCS0FLZ0R5SUxOZ0tBQXlBRVFZQURhaUVLQWtBQ1FDQUxSUVJBSUFBdkFVaEZEUUVMUVFFaENDQUtJQWxCQVNBTUtBSVlFQVpGRFFFTUJBc2dDa0gvLy84SE5nSUFDeUFFSUFFb0FxUVBJZ3MyQXNBRElBUkJ3QU5xSVFRQ1FBSkFJQXRGQkVBZ0FDOEJTa1VOQVF0QkFTRUlJQVFnQ1VFQklBd29BaHdRQmtVTkFRd0VDeUFFUWYvLy93YzJBZ0FMSUExQkJra05BQ0FBSUFFZ0FpQUZJQVlnQnhCV0lnaEZEUUVNQWdzZ0FDQUJJQU1nQlNBQ0lBY1FWeUlJRFFFTFFRQWhDQXNnQ0F1V0hRRUhmeU1BUVJCcklnY2tBQ0FCUVFCQnFCQVFCeUVGSUFBZ0IwRUVhaEFDSVFFZ0J5Z0NCQ0VJQWtBQ1FBSkFJQU5CZm1vaUEwRUZTdzBBQWtBZ0EwRUJhdzRFQVFFQkFRQUxRUUVoQXlBQkRRSWdDRUVHYWlJR1FSOU5EUUVNQWd0QkFTRURJQUVOQVNBSVFRRnFJZ1pCSDBzTkFRc2dCU0FHTmdJQUFrQWdCa0VmUmdSQUEwQWdBQ2dDQ0FSQUlBQkJBUkFEUlEwQkRBUUxDeUFGUWNnQ2FpRUdBMEFnQnlBQVFRZ1FBeUlCTmdJRUlBRkJmMFlOQXlBR0lBRTJBZ0FnQmtFRWFpRUdJQWxCQVdvaUNVR0FBMGNOQUFzTUFRdEJBaUFHUVFaSElBWkJCa2tiSVFvQ1FBSkFJQVpCQkVrTkFDQUdRUVZMRFFBZ0FDQUhRUXhxRUFJTkFTQUhLQUlNSWdGQkEwc05BU0FGSUFFMkFyQUJJQUFnQjBFTWFoQUNEUUVnQnlnQ0RDSUJRUU5MRFFFZ0JTQUJOZ0swQVNBQUlBZEJER29RQWcwQklBY29BZ3dpQVVFRFN3MEJJQVVnQVRZQ3VBRWdBQ0FIUVF4cUVBSU5BU0FIS0FJTUlnRkJBMHNOQVNBRklBRTJBcndCQWtBZ0JFRUNTUTBBSUFaQkJVWU5BQ0FBSUFkQkRHb2dCRUVDU3lJQkVCY05BaUFIS0FJTUlnZ2dCRThOQWlBRklBZzJBc0FCSUFBZ0IwRU1haUFCRUJjTkFpQUhLQUlNSWdnZ0JFOE5BaUFGSUFnMkFzUUJJQUFnQjBFTWFpQUJFQmNOQWlBSEtBSU1JZ2dnQkU4TkFpQUZJQWcyQXNnQklBQWdCMEVNYWlBQkVCY05BaUFIS0FJTUlnRWdCRThOQWlBRklBRTJBc3dCQ3lBSElBVW9BckFCSWdGQkFrMEVmeUFCUVFKMFFmQTBhaWdDQUFWQkF3czJBZ3hCQUNFR0EwQWdBQ0FIUVFocUVBVWlBdzBDSUFVZ0JrRUNkR29pQVNBSEtBSUlPd0hRQVNBQUlBZEJDR29RQlNJRERRSWdBU0FIS0FJSU93SFNBU0FISUFjb0Fnd2lBVUYvYWpZQ0RDQUdRUUZxSVFZZ0FRMEFDeUFISUFVb0FyUUJJZ0ZCQWswRWZ5QUJRUUowUWZBMGFpZ0NBQVZCQXdzMkFneEJBQ0VHQTBBZ0FDQUhRUWhxRUFVaUF3MENJQVVnQmtFQ2RHb2lBU0FIS0FJSU93SGdBU0FBSUFkQkNHb1FCU0lERFFJZ0FTQUhLQUlJT3dIaUFTQUhJQWNvQWd3aUFVRi9hallDRENBR1FRRnFJUVlnQVEwQUN5QUhJQVVvQXJnQklnRkJBazBFZnlBQlFRSjBRZkEwYWlnQ0FBVkJBd3MyQWd4QkFDRUdBMEFnQUNBSFFRaHFFQVVpQXcwQ0lBVWdCa0VDZEdvaUFTQUhLQUlJT3dId0FTQUFJQWRCQ0dvUUJTSUREUUlnQVNBSEtBSUlPd0h5QVNBSElBY29BZ3dpQVVGL2FqWUNEQ0FHUVFGcUlRWWdBUTBBQ3lBSElBVW9BcndCSWdGQkFrMEVmeUFCUVFKMFFmQTBhaWdDQUFWQkF3czJBZ3hCQUNFR0EwQWdBQ0FIUVFocUVBVWlBdzBDSUFVZ0JrRUNkR29pQVNBSEtBSUlPd0dBQWlBQUlBZEJDR29RQlNJRERRSWdBU0FIS0FJSU93R0NBaUFISUFjb0Fnd2lBVUYvYWpZQ0RDQUdRUUZxSVFaQkFDRURJQUVOQUFzTUFRdEJBQ0VESUFwQkFrc05BQUpBQW44Q1FBSkFBa0FnQ2tFQmF3NENCQUVBQ3lBSFFRQTJBZ2dnQlNBQUVBOGlBVUVmZGpZQ0RDQUJRUUJPRFFFZ0FVRUJkQ0VHUVFBTUFnc2dCRUVDVHdSQVFRTWhBU0FHUVFOTkJFQWdCa0VDZEVIOE5Hb29BZ0FoQVFzZ0JFRUNTeUVMUVFFaEF3TkFJQUFnQjBFTWFpQUxFQmNOQlNBSEtBSU1JZ2dnQkU4TkJTQUZJQWxCQW5ScUlBZzJBcEFCSUFFaUNFRi9haUVCSUFsQkFXb2hDU0FJRFFBTEMwRURJUU1nQmtFRFRRUkFJQVpCQW5SQi9EUnFLQUlBSVFNTFFRQWhCZ05BSUFNaEFTQUFJQWRCQ0dvUUJTSUREUVFnQlNBR1FRSjBhaUlFSUFjb0FnZzdBYUFCSUFBZ0IwRUlhaEFGSWdNTkJDQUVJQWNvQWdnN0FhSUJJQUZCZjJvaEF5QUdRUUZxSVFZZ0FRMEFDMEVBSVFNTUF3c2dCU0FCUVJ4Mk5nSk1JQUZCQkhRaEJrRUJDeUVESUFVZ0JrRWZkallDRUNBRklBWkJBRWdFZnlBR1FRRjBCU0FGSUFaQkhIWTJBbEFnQTBFQmFpRURJQVpCQkhRTElnRkJIM1kyQWhRZ0JTQUJRUUJJQkg4Z0FVRUJkQVVnQlNBQlFSeDJOZ0pVSUFOQkFXb2hBeUFCUVFSMEN5SUJRUjkyTmdJWUlBVWdBVUVBU0FSL0lBRkJBWFFGSUFVZ0FVRWNkallDV0NBRFFRRnFJUU1nQVVFRWRBc2lBVUVmZGpZQ0hDQUZJQUZCQUVnRWZ5QUJRUUYwQlNBRklBRkJISFkyQWx3Z0EwRUJhaUVESUFGQkJIUUxJZ0ZCSDNZMkFpQWdCU0FCUVFCSUJIOGdBVUVCZEFVZ0JTQUJRUngyTmdKZ0lBTkJBV29oQXlBQlFRUjBDeUlCUVI5Mk5nSWtJQVVnQVVFQVNBUi9JQUZCQVhRRklBVWdBVUVjZGpZQ1pDQURRUUZxSVFNZ0FVRUVkQXNpQVVFZmRqWUNLQ0FCUVFCSUJIOGdBVUVCZEFVZ0JTQUJRUngyTmdKb0lBTkJBV29oQXlBQlFRUjBDeUVHQWtBZ0FDQURRUU5zUVFocUVBdEJmMFlOQUNBSFFRRTJBZ2dnQlNBQUVBOGlBVUVmZGpZQ0xBSi9JQUZCQUVnRVFDQUJRUUYwSVFaQkFBd0JDeUFGSUFGQkhIWTJBbXdnQVVFRWRDRUdRUUVMSVFNZ0JTQUdRUjkyTmdJd0lBVWdCa0VBU0FSL0lBWkJBWFFGSUFVZ0JrRWNkallDY0NBRFFRRnFJUU1nQmtFRWRBc2lBVUVmZGpZQ05DQUZJQUZCQUVnRWZ5QUJRUUYwQlNBRklBRkJISFkyQW5RZ0EwRUJhaUVESUFGQkJIUUxJZ0ZCSDNZMkFqZ2dCU0FCUVFCSUJIOGdBVUVCZEFVZ0JTQUJRUngyTmdKNElBTkJBV29oQXlBQlFRUjBDeUlCUVI5Mk5nSThJQVZCUUdzZ0FVRUFTQVIvSUFGQkFYUUZJQVVnQVVFY2RqWUNmQ0FEUVFGcUlRTWdBVUVFZEFzaUFVRWZkallDQUNBRklBRkJBRWdFZnlBQlFRRjBCU0FGSUFGQkhIWTJBb0FCSUFOQkFXb2hBeUFCUVFSMEN5SUJRUjkyTmdKRUlBVWdBVUVBU0FSL0lBRkJBWFFGSUFVZ0FVRWNkallDaEFFZ0EwRUJhaUVESUFGQkJIUUxJZ0ZCSDNZMkFrZ2dBVUVBU0FSL0lBRkJBWFFGSUFVZ0FVRWNkallDaUFFZ0EwRUJhaUVESUFGQkJIUUxJUVlnQUNBRFFRTnNRUWhxRUF0QmYwWU5BQ0FISUFZMkFnd2dCMEVDTmdJSURBRUxJQWNnQmpZQ0RFRUJJUU1NQVF0QkFTRURJQUFnQjBFTWFoQUNEUUFnQnlnQ0RDSUJRUU5MRFFBZ0JTQUJOZ0tNQVVFQUlRTUxJQU1OQVFKQUlBcEJBVWNFUUNBQUlBZEJCR29nQ2tVUUxTSUREUU1nQlNBSEtBSUVJZ0UyQWdRZ0FVVU5BZ3dCQ3lBRklBVW9BZ0FpQVVGNWFpSURRUUowUVhCeElnUkJVR29nQkNBRFFRdExHMEVQUVFBZ0FVRVNTeHR5TmdJRUMwRUJJUU1nQUNBSFFReHFFQVVOQVNBSEtBSU1JZ0ZCR21wQk0wc05BU0FGSUFFMkFnZ2dCVUdRQW1vaENDQUZLQUlFSVFRQ1FBSkFJQVVvQWdCQkIwa0VRRUVBSVFsQkF5RURBMEFnQXlFQklBUkJBWEVFUUNBSUlBbEJBblJxUWJnTmFpQUFJQWdnQ1VFR2RHcEJPR29nQWlBSklBZ1FEVUVRRUFraUEwRVFkallDQUNBRFFROXhEUVFnQ0NBSlFRRjBhaUFEUVFSMlFmOEJjVHNCQUNBSUlBbEJBWElpQmtFQ2RHcEJ1QTFxSUFBZ0NDQUdRUVowYWtFNGFpQUNJQVlnQ0JBTlFSQVFDU0lEUVJCMk5nSUFJQU5CRDNFTkJDQUlJQVpCQVhScUlBTkJCSFpCL3dGeE93RUFJQWdnQ1VFQ2NpSUdRUUowYWtHNERXb2dBQ0FJSUFaQkJuUnFRVGhxSUFJZ0JpQUlFQTFCRUJBSklnTkJFSFkyQWdBZ0EwRVBjUTBFSUFnZ0JrRUJkR29nQTBFRWRrSC9BWEU3QVFBZ0NDQUpRUU55SWdaQkFuUnFRYmdOYWlBQUlBZ2dCa0VHZEdwQk9Hb2dBaUFHSUFnUURVRVFFQWtpQTBFUWRqWUNBQ0FEUVE5eERRUWdCU0FHUVFGMGFpQURRUVIyUWY4QmNUc0JrQUlMSUFSQkFYWWhCQ0FCUVg5cUlRTWdDVUVFYWlFSklBRU5BQXNNQVF0QkFDRUpJQUFnQlVISURtb2dBa0VBSUFnUURVRVFFQWtpQTBFUGNRMEJJQVVnQTBFRWRrSC9BWEU3QWNBQ0lBVkJrQUpxSVFaQkF5RURBMEFnQXlFQklBUkJBWEVFUUNBR0lBbEJBblJxUWJnTmFpQUFJQVlnQ1VFR2RHcEJQR29nQWlBSklBZ1FEVUVQRUFraUEwRVBkallDQUNBRFFROXhEUU1nQmlBSlFRRjBhaUFEUVFSMlFmOEJjVHNCQUNBR0lBbEJBWElpQ2tFQ2RHcEJ1QTFxSUFBZ0JpQUtRUVowYWtFOGFpQUNJQW9nQ0JBTlFROFFDU0lEUVE5Mk5nSUFJQU5CRDNFTkF5QUdJQXBCQVhScUlBTkJCSFpCL3dGeE93RUFJQVlnQ1VFQ2NpSUtRUUowYWtHNERXb2dBQ0FHSUFwQkJuUnFRVHhxSUFJZ0NpQUlFQTFCRHhBSklnTkJEM1kyQWdBZ0EwRVBjUTBESUFZZ0NrRUJkR29nQTBFRWRrSC9BWEU3QVFBZ0JpQUpRUU55SWdwQkFuUnFRYmdOYWlBQUlBWWdDa0VHZEdwQlBHb2dBaUFLSUFnUURVRVBFQWtpQTBFUGRqWUNBQ0FEUVE5eERRTWdCU0FLUVFGMGFpQURRUVIyUWY4QmNUc0JrQUlMSUFSQkFYWWhCQ0FCUVg5cUlRTWdDVUVFYWlFSklBRU5BQXNMSUFSQkEzRUVRQ0FBSUFWQmlBOXFRWDlCQkJBSklnTkJEM0VOQVNBRklBTkJCSFpCL3dGeE93SENBaUFBSUFWQm1BOXFRWDlCQkJBSklnTkJEM0VOQVNBRklBTkJCSFpCL3dGeE93SEVBZ3RCQUNFRElBUkJBbkZGRFFBZ0FDQUZRY3dLYWlBQ1FSQWdDQkFOUVE4UUNTSUJRUTl4QkVBZ0FTRUREQUVMSUFWQmlCQnFJQUZCRDNZMkFnQWdCU0FCUVFSMlFmOEJjVHNCc0FJZ0FDQUZRWXdMYWlBQ1FSRWdDQkFOUVE4UUNTSUJRUTl4QkVBZ0FTRUREQUVMSUFWQmpCQnFJQUZCRDNZMkFnQWdCU0FCUVFSMlFmOEJjVHNCc2dJZ0FDQUZRY3dMYWlBQ1FSSWdDQkFOUVE4UUNTSUJRUTl4QkVBZ0FTRUREQUVMSUFWQmtCQnFJQUZCRDNZMkFnQWdCU0FCUVFSMlFmOEJjVHNCdEFJZ0FDQUZRWXdNYWlBQ1FSTWdDQkFOUVE4UUNTSUJRUTl4QkVBZ0FTRUREQUVMSUFWQmxCQnFJQUZCRDNZMkFnQWdCU0FCUVFSMlFmOEJjVHNCdGdJZ0FDQUZRY3dNYWlBQ1FSUWdDQkFOUVE4UUNTSUJRUTl4QkVBZ0FTRUREQUVMSUFWQm1CQnFJQUZCRDNZMkFnQWdCU0FCUVFSMlFmOEJjVHNCdUFJZ0FDQUZRWXdOYWlBQ1FSVWdDQkFOUVE4UUNTSUJRUTl4QkVBZ0FTRUREQUVMSUFWQm5CQnFJQUZCRDNZMkFnQWdCU0FCUVFSMlFmOEJjVHNCdWdJZ0FDQUZRY3dOYWlBQ1FSWWdDQkFOUVE4UUNTSUJRUTl4QkVBZ0FTRUREQUVMSUFWQm9CQnFJQUZCRDNZMkFnQWdCU0FCUVFSMlFmOEJjVHNCdkFJZ0FDQUZRWXdPYWlBQ1FSY2dDQkFOUVE4UUNTSUJRUTl4QkVBZ0FTRUREQUVMSUFWQnBCQnFJQUZCRDNZMkFnQWdCU0FCUVFSMlFmOEJjVHNCdmdJTElBQWdBQ2dDQ0NBQUtBSUVJQUFvQWdCclFRTjBhallDRUNBRERRRUxRUUFoQXdzZ0IwRVFhaVFBSUFNTHBSUUJESDhDZnlBQUtBTElBU0lIQkVBZ0FDZ0NCQ0FIS0FJRVJnd0JDMEVBQ3lFS0FrQWdCa1VOQUNBS1JRMEFRUUFnQ2tFQ0lBQW9Bc2dCS0FJQUlnZEJCa2NnQjBFR1NSdEJBa1liSVFvTEFuOGdBQ2dDekFFaUJ3UkFJQUFvQWdRZ0J5Z0NCRVlNQVF0QkFBc2hCd0pBSUFaRkRRQWdCMFVOQUVFQUlBZEJBaUFBS0FMTUFTZ0NBQ0lIUVFaSElBZEJCa2tiUVFKR0d5RUhDd0ovSUFBb0F0UUJJZ2tFUUNBQUtBSUVJQWtvQWdSR0RBRUxRUUFMSVFrQ1FDQUdSUTBBSUFsRkRRQkJBaUFBS0FMVUFTZ0NBQ0lBUVFaSElBQkJCa2tiUVFKSElRa0xJQXBCQUVjZ0IwRUFSM0VpRFNBSlFRQkhjU0VPSUFWQkFrc2hEMEVRSVFzRFFBSkFJQTlGQkVBQ1FBSkFBa0FnQlVFQmF3NENBUUlBQ3lBQkFuOGdEUVJBSUFRdEFBTWdCQzBBQWlBRUxRQUJJQVF0QUFBZ0F5MEFCQ0FETFFBRElBTXRBQUVnQXkwQUFtcHFhbXBxYW1wQkJHcEJBM1loQmlBRExRQUlJQU10QUFjZ0F5MEFCU0FETFFBR2FtcHFRUUpxUVFKMkRBRUxJQWNFUUNBRExRQUVJQU10QUFNZ0F5MEFBU0FETFFBQ2FtcHFRUUpxUVFKMklRWWdBeTBBQ0NBRExRQUhJQU10QUFVZ0F5MEFCbXBxYWtFQ2FrRUNkZ3dCQ3lBS1JRUkFRWUFCSVFaQmdBRU1BUXNnQkMwQUF5QUVMUUFDSUFRdEFBQWdCQzBBQVdwcWFrRUNha0VDZGlJR0MwSC9BWEZCZ1lLRUNHd2lBRFlBSENBQklBWkIvd0Z4UVlHQ2hBaHNJZ1kyQUJnZ0FTQUFOZ0FVSUFFZ0JqWUFFQ0FCSUFBMkFBd2dBU0FHTmdBSUlBRWdBRFlBQkNBQklBWTJBQUFDZnlBS0JFQWdCQzBBQnlBRUxRQUdJQVF0QUFVZ0JDMEFCR3BxYWlJR1FRSnFRUUoySWdBZ0IwVU5BUm9nQXkwQUNDQURMUUFISUFNdEFBWWdCaUFETFFBRmFtcHFha0VFYWtFRGRnd0JDeUFIUlFSQVFZQUJJUUJCZ0FFTUFRc2dBeTBBQkNBRExRQURJQU10QUFFZ0F5MEFBbXBxYWtFQ2FrRUNkaUVBSUFNdEFBZ2dBeTBBQnlBRExRQUZJQU10QUFacWFtcEJBbXBCQW5ZTElRWWdBU0FBUWY4QmNVR0Jnb1FJYkNJQU5nQWdJQUVnQmtIL0FYRkJnWUtFQ0d3aUJqWUFQQ0FCSUFBMkFEZ2dBU0FHTmdBMElBRWdBRFlBTUNBQklBWTJBQ3dnQVNBQU5nQW9JQUVnQmpZQUpBd0RDeUFLUlFSQVFRRVBDeUFCSUFRdEFBQTZBQUFnQVNBRUxRQUFPZ0FCSUFFZ0JDMEFBRG9BQWlBQklBUXRBQUE2QUFNZ0FTQUVMUUFBT2dBRUlBRWdCQzBBQURvQUJTQUJJQVF0QUFBNkFBWWdBU0FFTFFBQU9nQUhJQUVnQkMwQUFUb0FDQ0FCSUFRdEFBRTZBQWtnQVNBRUxRQUJPZ0FLSUFFZ0JDMEFBVG9BQ3lBQklBUXRBQUU2QUF3Z0FTQUVMUUFCT2dBTklBRWdCQzBBQVRvQURpQUJJQVF0QUFFNkFBOGdBU0FFTFFBQ09nQVFJQUVnQkMwQUFqb0FFU0FCSUFRdEFBSTZBQklnQVNBRUxRQUNPZ0FUSUFFZ0JDMEFBam9BRkNBQklBUXRBQUk2QUJVZ0FTQUVMUUFDT2dBV0lBRWdCQzBBQWpvQUZ5QUJJQVF0QUFNNkFCZ2dBU0FFTFFBRE9nQVpJQUVnQkMwQUF6b0FHaUFCSUFRdEFBTTZBQnNnQVNBRUxRQURPZ0FjSUFFZ0JDMEFBem9BSFNBQklBUXRBQU02QUI0Z0FTQUVMUUFET2dBZklBRWdCQzBBQkRvQUlDQUJJQVF0QUFRNkFDRWdBU0FFTFFBRU9nQWlJQUVnQkMwQUJEb0FJeUFCSUFRdEFBUTZBQ1FnQVNBRUxRQUVPZ0FsSUFFZ0JDMEFCRG9BSmlBQklBUXRBQVE2QUNjZ0FTQUVMUUFGT2dBb0lBRWdCQzBBQlRvQUtTQUJJQVF0QUFVNkFDb2dBU0FFTFFBRk9nQXJJQUVnQkMwQUJUb0FMQ0FCSUFRdEFBVTZBQzBnQVNBRUxRQUZPZ0F1SUFFZ0JDMEFCVG9BTHlBQklBUXRBQVk2QURBZ0FTQUVMUUFHT2dBeElBRWdCQzBBQmpvQU1pQUJJQVF0QUFZNkFETWdBU0FFTFFBR09nQTBJQUVnQkMwQUJqb0FOU0FCSUFRdEFBWTZBRFlnQVNBRUxRQUdPZ0EzSUFFZ0JDMEFCem9BT0NBQklBUXRBQWM2QURrZ0FTQUVMUUFIT2dBNklBRWdCQzBBQnpvQU95QUJJQVF0QUFjNkFEd2dBU0FFTFFBSE9nQTlJQUVnQkMwQUJ6b0FQaUFCSUFRdEFBYzZBRDhNQWdzZ0IwVUVRRUVCRHdzZ0FTQURMUUFCT2dBQUlBRWdBeTBBQVRvQUNDQUJJQU10QUFFNkFCQWdBU0FETFFBQk9nQVlJQUVnQXkwQUFUb0FJQ0FCSUFNdEFBRTZBQ2dnQVNBRExRQUJPZ0F3SUFFZ0F5MEFBVG9BT0NBQklBTXRBQUk2QUFFZ0FTQURMUUFDT2dBSklBRWdBeTBBQWpvQUVTQUJJQU10QUFJNkFCa2dBU0FETFFBQ09nQWhJQUVnQXkwQUFqb0FLU0FCSUFNdEFBSTZBREVnQVNBRExRQUNPZ0E1SUFFZ0F5MEFBem9BQWlBQklBTXRBQU02QUFvZ0FTQURMUUFET2dBU0lBRWdBeTBBQXpvQUdpQUJJQU10QUFNNkFDSWdBU0FETFFBRE9nQXFJQUVnQXkwQUF6b0FNaUFCSUFNdEFBTTZBRG9nQVNBRExRQUVPZ0FESUFFZ0F5MEFCRG9BQ3lBQklBTXRBQVE2QUJNZ0FTQURMUUFFT2dBYklBRWdBeTBBQkRvQUl5QUJJQU10QUFRNkFDc2dBU0FETFFBRU9nQXpJQUVnQXkwQUJEb0FPeUFCSUFNdEFBVTZBQVFnQVNBRExRQUZPZ0FNSUFFZ0F5MEFCVG9BRkNBQklBTXRBQVU2QUJ3Z0FTQURMUUFGT2dBa0lBRWdBeTBBQlRvQUxDQUJJQU10QUFVNkFEUWdBU0FETFFBRk9nQThJQUVnQXkwQUJqb0FCU0FCSUFNdEFBWTZBQTBnQVNBRExRQUdPZ0FWSUFFZ0F5MEFCam9BSFNBQklBTXRBQVk2QUNVZ0FTQURMUUFHT2dBdElBRWdBeTBBQmpvQU5TQUJJQU10QUFZNkFEMGdBU0FETFFBSE9nQUdJQUVnQXkwQUJ6b0FEaUFCSUFNdEFBYzZBQllnQVNBRExRQUhPZ0FlSUFFZ0F5MEFCem9BSmlBQklBTXRBQWM2QUM0Z0FTQURMUUFIT2dBMklBRWdBeTBBQnpvQVBpQUJJQU10QUFnNkFBY2dBU0FETFFBSU9nQVBJQUVnQXkwQUNEb0FGeUFCSUFNdEFBZzZBQjhnQVNBRExRQUlPZ0FuSUFFZ0F5MEFDRG9BTHlBQklBTXRBQWc2QURjZ0FTQURMUUFJT2dBL0RBRUxJQTVGQkVCQkFROExJQU10QUFVZ0F5MEFBMnNnQXkwQUJpQURMUUFDYTBFQmRHb2dBeTBBQnlBRExRQUJhMEVEYkdvZ0F5MEFDQ0lBSUFNdEFBQWlDV3RCQW5ScVFSRnNRUkJxUVFWMUlnWkJmV3doRUNBQUlBUXRBQWNpREdwQkJIUWdCQzBBQkNBRUxRQUNheUFNSUFsclFRSjBhaUFFTFFBRklBUXRBQUZyUVFGMGFpQUVMUUFHSUFRdEFBQnJRUU5zYWtFUmJFRVFha0VGZFNJUlFYMXNha0VRYWlFSlFRZ2hEQ0FCSVFBRFFDQUFJQWtnRUdvaUNFRUZkVUd3TG1vdEFBQTZBQUFnQUNBR0lBaHFJZ2hCQlhWQnNDNXFMUUFBT2dBQklBQWdCaUFJYWlJSVFRVjFRYkF1YWkwQUFEb0FBaUFBSUFZZ0NHb2lDRUVGZFVHd0xtb3RBQUE2QUFNZ0FDQUdJQWhxSWdoQkJYVkJzQzVxTFFBQU9nQUVJQUFnQmlBSWFpSUlRUVYxUWJBdWFpMEFBRG9BQlNBQUlBWWdDR29pQ0VFRmRVR3dMbW90QUFBNkFBWWdBQ0FHSUFocVFRVjFRYkF1YWkwQUFEb0FCeUFKSUJGcUlRa2dBRUVJYWlFQUlBeEJmMm9pREEwQUN3c2dBU0FDSUFzUUNDQUJJQUpCUUdzZ0MwRUJjaEFJSUFFZ0FrR0FBV29nQzBFQ2NoQUlJQUVnQWtIQUFXb2dDMEVEY2hBSUlBSkJnQUpxSVFJZ0JFRUlhaUVFSUFOQkNXb2hBeUFCUVVCcklRRWdDMEVFYWlFTElCSkJBV29pRWtFQ1J3MEFDMEVBQzZFVkFoaC9BbjRDZndOQUFuOGdBQ0lJSUJaQkEzUkJzRFZxS1FJQUloNm5FQkVpQ1NJR0JFQWdDQ2dDQkNBR0tBSUVSZ3dCQzBFQUN5RU5Ba0FnQlVVTkFDQU5SUTBBUVFBZ0RVRUNJQWtvQWdBaUJrRUdSeUFHUVFaSkcwRUNSaHNoRFFzQ2Z5QUlJQlpCQTNSQjhEWnFLUUlBSWgrbkVCRWlCeUlHQkVBZ0NDZ0NCQ0FHS0FJRVJnd0JDMEVBQ3lFUEFrQWdCVVVOQUNBUFJRMEFRUUFnRDBFQ0lBY29BZ0FpQmtFR1J5QUdRUVpKRzBFQ1Joc2hEd3RCQWlFTUlBMUJBRWNnRDBFQVIzRWlFa0VCUmdSQVFRSWhCZ0ovUVFJZ0NTZ0NBQ0lMUVFaSElBdEJCa2tiUlFSQUlBa2dIa0lnaUtkQi93RnhhaTBBVWlFR0N5QUdDd0ovUVFJZ0J5Z0NBQ0lKUVFaSElBbEJCa2tiUlFSQUlBY2dIMElnaUtkQi93RnhhaTBBVWlFTUN5QU1DeUFHSUF4Skd5RU1DeUFDSUJaQkFuUWlDV29pQmlnQ0RFVUVRQ0FHS0FKTUlnWWdCaUFNVDJvaERBc2dDQ0FXYWlBTU9nQlNBbjhnQ0NBV1FRTjBRYkE0YWlnQ0FCQVJJZ1lpQndSQUlBZ29BZ1FnQnlnQ0JFWU1BUXRCQUFzaERnSkFJQVZGRFFBZ0RrVU5BRUVBSUE1QkFpQUdLQUlBSWdaQkJrY2dCa0VHU1J0QkFrWWJJUTRMQW44Z0FDQVdRUU4wUWZBNWFpZ0NBQkFSSWdnaUJnUkFJQUFvQWdRZ0JpZ0NCRVlNQVF0QkFBc2hFUUpBSUFWRkRRQWdFVVVOQUVFQUlCRkJBaUFJS0FJQUlnaEJCa2NnQ0VFR1NSdEJBa1liSVJFTElBbEI4Q2xxS0FJQUlSY2dDVUd3S1dvb0FnQWhHQUovUVlVS0lCWjJRUUZ4SWh3RVFDQVhRUU5xSVFjZ0JDQVhhaUlJUVFKcUlRWWdDRUVCYWlFTElBUU1BUXNnRjBFRWRDQVlhaUlJUVM5cUlRY2dBU0FJYWlJSVFSOXFJUVlnQ0VFUGFpRUxJQWhCZjJvaENDQUJDeUVKSUFjZ0NXb3RBQUFoQ2lBR0xRQUFJUkFnQ3kwQUFDRVRJQWd0QUFBaEZBSkFRVE1nRm5aQkFYRUVRQ0FESUJocUlnY3RBQWdoR3lBSExRQUhJUmtnQnkwQUJpRVZJQWN0QUFVaEdpQUhMUUFFSVFZZ0J5MEFBeUVMSUFjdEFBSWhDU0FITFFBQklRZ01BUXNnQVNBWFFYOXFJaDFCQkhRZ0dHcHFJZ2N0QUFBaENDQUhMUUFISVJzZ0J5MEFCaUVaSUFjdEFBVWhGU0FITFFBRUlSb2dCeTBBQXlFR0lBY3RBQUloQ3lBSExRQUJJUWtnSEFSQUlBUWdIV29oQnd3QkN5QUhRWDlxSVFjTEFrQWdERUVIVFFSQUlBY3RBQUFoQndKQUFrQUNRQUpBQWtBQ1FBSkFBa0FnREVFQmF3NEhBUUlEQkFVR0J3QUxJQTlGQkVCQkFROExJQWhCL3dGeElBdEIvd0Z4UVJCMElBWkJHSFJ5Y2lBSlFmOEJjVUVJZEhJaEZTQUlJZ3doRFNBSklnNGhFaUFMSWc4aENpQUdJaEVoQnd3SUN5QU5SUVJBUVFFUEN5QUtRWUdDaEFoc0lSVWdFRUdCZ29RSWJDSU5RUmgySVFjZ0RVRVFkaUVLSUExQkNIWWhFaUFUUVlHQ2hBaHNJZ3hCR0hZaEVTQU1RUkIySVE4Z0RFRUlkaUVPSUJSQmdZS0VDR3dpQ0VFWWRpRUdJQWhCRUhZaEN5QUlRUWgySVFrTUJ3c0NmeUFUSUJScUlBcHFJQkJxSUFaQi93RnhhaUFMUWY4QmNXb2dDVUgvQVhGcUlBaEIvd0Z4YWtFRWFrRURkaUFTRFFBYUlCTWdGR29nQ21vZ0VHcEJBbXBCQW5ZZ0RRMEFHa0dBQVNBUFJRMEFHaUFHUWY4QmNTQUxRZjhCY1dvZ0NVSC9BWEZxSUFoQi93Rnhha0VDYWtFQ2Rnc2lDRUdCZ29RSWJDRVZJQWdpQ1NJTElnWWlEQ0lPSWc4aUVTSU5JaElpQ2lFSERBWUxJQTlGQkVCQkFROExJQVpCL3dGeElnMUJBbW9pRVNBVklBWWdEaHRCL3dGeElnZHFJQm9nQmlBT0cwSC9BWEVpQ2tFQmRHcEJBbllpRHlBWklBWWdEaHRCL3dGeElnd2dHeUFHSUE0YlFmOEJjU0lHUVFOc2FrRVdkRUdBZ0lBRWFrR0FnSUI0Y1hJZ0NpQU1haUFIUVFGMGFrRUNhaUlRUVFaMFFZRCtBM0Z5SUFZZ0Iyb2dERUVCZEdwQkFtb2lCa0VPZEVHQWdQd0hjWEloRlNBR1FRSjJJUWNnQzBIL0FYRWlCa0VDYWlJTElBaEIvd0Z4YWlBSlFmOEJjU0lKUVFGMGFrRUNkaUVJSUFrZ0VXb2dCa0VCZEdwQkFuWWlDU0VNSUFvZ0Myb2dEVUVCZEdwQkFuWWlDeUVPSUFzaERTQVBJZ1loRWlBUVFRSjJJaEVoQ2d3RkMwRUJJQkZGSUJKQkFYTnlEUVlhSUJRZ0UwRUJkR29nRUdwQkFtb2lEa0VHZEVHQS9nTnhJQW9nRTBFQ2FpSVBhaUFRUVFGMGFrRUNkbklnQ0VIL0FYRWlDa0VDYWlJTUlCUnFJQWRCQVhScVFRSjJJZ2hCR0hSeUlBOGdGRUVCZEdvZ0Iyb2lFRUVPZEVHQWdQd0hjWEloRlNBSlFmOEJjU0lSUVFKcUlna2dCa0gvQVhGcUlBdEIvd0Z4SWd0QkFYUnFRUUoySVFZZ0RrRUNkaUVOSUFrZ0NrRUJkR29nQjJwQkFuWWlDU0VQSUJGQkFYUWdDMm9nREdwQkFuWWlDeUVSSUJCQkFuWWlEQ0VTSUFnaURpRUtJQWtoQnd3RUMwRUJJQkZGSUJKQkFYTnlEUVVhSUFoQi93RnhJZ3BCQW1vaURpQUxRZjhCY1NJSUlBbEIvd0Z4SWd0QkFYUnFha0VDZGlJUFFSaDBJQlFnRTBFQmRHb2dFR3BCQW1wQkFuWnlJQTRnRkdvZ0IwRUJkR29pQ1VFR2RFR0EvZ054Y2lBTFFRSnFJZzRnQ2tFQmRHb2dCMm9pRFVFT2RFR0FnUHdIY1hJaEZTQUlRUUZxSWhBZ0JrSC9BWEVpREdwQkFYWWhCaUFNSUE1cUlBaEJBWFJxUVFKMklSRWdDVUVDZGlFTUlBMUJBblloRGlBVElCUkJBWFJxSUFkcVFRSnFRUUoySVEwZ0J5QUtha0VCYWtFQmRpSUlJUklnQ2lBTGFrRUJha0VCZGlJSklRb2dDeUFRYWtFQmRpSUxJUWNNQXd0QkFTQVJSU0FTUVFGemNnMEVHaUFUUVFKcUlnNGdDbW9nRUVFQmRHcEJCblJCZ1A0RGNTQVFJQk5xUVFGcUlnOUJEM1JCZ0lEOEIzRWdGRUVDYWlJTUlCTkJBWFJxSUJCcVFRSjJJaEpCR0hSeUlBb2dFR3BCQVdwQkFYWnljaUVWSUFoQi93RnhJZ2dnQzBIL0FYRnFJQWxCL3dGeElnbEJBWFJxUVFKcVFRSjJJUVlnQ1NBSVFRRjBhaUFIYWtFQ2FrRUNkaUVMSUE5QkFYWWhEU0FJSUF4cUlBZEJBWFJxUVFKMkloRWhDU0FVUVFGcUlnb2dCMnBCQVhZaUNDRVBJQW9nRTJwQkFYWWlEQ0VLSUE0Z0ZFRUJkR29nQjJwQkFuWWlEaUVIREFJTElBOUZCRUJCQVE4TElCb2dCaUFPRzBIL0FYRWlDaUFaSUFZZ0RodEIvd0Z4YWlBVklBWWdEaHRCL3dGeElnZEJBWFJxUVJaMElBdEIvd0Z4SWd0QkFtb2lEQ0FLYWlBR1FmOEJjU0lHUVFGMGFpSVBRUVowY2tHQWdJQUVha0dBL29ONGNTQUdRUUpxSWcwZ0NVSC9BWEVpQ1dvZ0MwRUJkR3BCQW5ZaURuSWdCeUFOYWlBS1FRRjBhaUlOUVE1MFFZQ0EvQWR4Y2lFVklBY2dDbXBCQVdwQkFYWWhCeUFOUVFKMklSRWdDU0FJUWY4QmNTSU5ha0VCYWtFQmRpRUlJQTlCQW5ZaER5QU1JQTFxSUFsQkFYUnFRUUoySVF3Z0NTQUxha0VCYWtFQmRpSUpJUTBnQmtFQmFpSUdJQXRxUVFGMklnc2hFaUFHSUFwcVFRRjJJZ1loQ2d3QkN5QU5SUVJBUVFFUEN5QUtRUWgwSUFweUlBcEJFSFJ5SUFwQkdIUnlJUlVnRUVFQ2FpSUhJQlJxSUJOQkFYUnFRUUoySVFrZ0UwRUJhaUlHSUJScVFRRjJJUWdnQmlBUWFrRUJkaUlMSVF3Z0NpQVRhaUFRUVFGMGFrRUNha0VDZGlJR0lRNGdDaUFRYWtFQmFrRUJkaUlQSVEwZ0J5QUtRUU5zYWtFQ2RpSVJJUklnQ2lFSEN5QUJJQmRCQkhRZ0dHcHFJaEFnRlRZQ01DQVFJQTFCL3dGeElCSkIvd0Z4UVFoMGNpQUtRZjhCY1VFUWRISWdCMEVZZEhJMkFpQWdFQ0FNUWY4QmNTQU9RZjhCY1VFSWRISWdEMEgvQVhGQkVIUnlJQkZCR0hSeU5nSVFJQkFnQ0VIL0FYRWdDVUgvQVhGQkNIUnlJQXRCL3dGeFFSQjBjaUFHUVJoMGNqWUNBQ0FCSUFJZ0ZrRUdkR3BCeUFKcUlCWVFDQ0FXUVFGcUloWkJFRWNOQUF0QkFBc0x4UklCRUg4Q2Z5QUFLQUxJQVNJSEJFQWdBQ2dDQkNBSEtBSUVSZ3dCQzBFQUN5RUhBa0FnQlVVTkFDQUhSUTBBUVFBZ0IwRUNJQUFvQXNnQktBSUFJZ2RCQmtjZ0IwRUdTUnRCQWtZYklRY0xBbjhnQUNnQ3pBRWlDQVJBSUFBb0FnUWdDQ2dDQkVZTUFRdEJBQXNoQ0FKQUlBVkZEUUFnQ0VVTkFFRUFJQWhCQWlBQUtBTE1BU2dDQUNJSVFRWkhJQWhCQmtrYlFRSkdHeUVJQ3dKL0lBQW9BdFFCSWdrRVFDQUFLQUlFSUFrb0FnUkdEQUVMUVFBTElRa0NRQ0FGUlEwQUlBbEZEUUJCQWlBQUtBTFVBU2dDQUNJRlFRWkhJQVZCQmtrYlFRSkhJUWtMQWtBQ1FDQUFLQUlBUVFGcVFRTnhJZ0JCQWswRVFBSkFBa0FDUUNBQVFRRnJEZ0lCQWdBTElBaEZCRUJCQVE4TFFRQWhCU0FCSVFBRFFDQUFJQU10QUFFNkFBQWdBQ0FETFFBQ09nQUJJQUFnQXkwQUF6b0FBaUFBSUFNdEFBUTZBQU1nQUNBRExRQUZPZ0FFSUFBZ0F5MEFCam9BQlNBQUlBTXRBQWM2QUFZZ0FDQURMUUFJT2dBSElBQWdBeTBBQ1RvQUNDQUFJQU10QUFvNkFBa2dBQ0FETFFBTE9nQUtJQUFnQXkwQUREb0FDeUFBSUFNdEFBMDZBQXdnQUNBRExRQU9PZ0FOSUFBZ0F5MEFEem9BRGlBQUlBTXRBQkE2QUE4Z0FFRVFhaUVBSUFWQkFXb2lCVUVRUncwQUN3d0RDeUFIUlFSQVFRRVBDMEVBSVFVZ0FTRUFBMEFnQUNBRUlBVnFJZ010QUFBNkFBQWdBQ0FETFFBQU9nQUJJQUFnQXkwQUFEb0FBaUFBSUFNdEFBQTZBQU1nQUNBRExRQUFPZ0FFSUFBZ0F5MEFBRG9BQlNBQUlBTXRBQUE2QUFZZ0FDQURMUUFBT2dBSElBQWdBeTBBQURvQUNDQUFJQU10QUFBNkFBa2dBQ0FETFFBQU9nQUtJQUFnQXkwQUFEb0FDeUFBSUFNdEFBQTZBQXdnQUNBRExRQUFPZ0FOSUFBZ0F5MEFBRG9BRGlBQUlBTXRBQUE2QUE4Z0FFRVFhaUVBSUFWQkFXb2lCVUVRUncwQUN3d0NDeUFCQW44Q1FDQUhSUTBBSUFoRkRRQWdCQzBBRHlBRExRQVFJQVF0QUE0Z0F5MEFEeUFFTFFBTklBTXRBQTRnQkMwQURDQURMUUFOSUFRdEFBc2dBeTBBRENBRUxRQUtJQU10QUFzZ0JDMEFDU0FETFFBS0lBUXRBQWdnQXkwQUNTQUVMUUFISUFNdEFBZ2dCQzBBQmlBRExRQUhJQVF0QUFVZ0F5MEFCaUFFTFFBRUlBTXRBQVVnQkMwQUF5QURMUUFFSUFRdEFBSWdBeTBBQXlBRUxRQUJJQU10QUFJZ0F5MEFBU0FFTFFBQWFtcHFhbXBxYW1wcWFtcHFhbXBxYW1wcWFtcHFhbXBxYW1wcWFtcHFha0VRYWtFRmRnd0JDeUFIQkVBZ0JDMEFEeUFFTFFBT0lBUXRBQTBnQkMwQURDQUVMUUFMSUFRdEFBb2dCQzBBQ1NBRUxRQUlJQVF0QUFjZ0JDMEFCaUFFTFFBRklBUXRBQVFnQkMwQUF5QUVMUUFDSUFRdEFBQWdCQzBBQVdwcWFtcHFhbXBxYW1wcWFtcHFha0VJYWtFRWRnd0JDMEdBQVNBSVJRMEFHaUFETFFBUUlBTXRBQThnQXkwQURpQURMUUFOSUFNdEFBd2dBeTBBQ3lBRExRQUtJQU10QUFrZ0F5MEFDQ0FETFFBSElBTXRBQVlnQXkwQUJTQURMUUFFSUFNdEFBTWdBeTBBQVNBRExRQUNhbXBxYW1wcWFtcHFhbXBxYW1wcVFRaHFRUVIyQzBHQUFoQUhHZ3dCQzBFQklRQWdCMFVOQVNBSVJRMEJJQWxGRFFFZ0JDMEFDQ0FFTFFBR2F5QUVMUUFQSWdBZ0F5MEFBQ0lGYTBFRGRHb2dCQzBBQ1NBRUxRQUZhMEVCZEdvZ0JDMEFDaUFFTFFBRWEwRURiR29nQkMwQUN5QUVMUUFEYTBFQ2RHb2dCQzBBRENBRUxRQUNhMEVGYkdvZ0JDMEFEU0FFTFFBQmEwRUdiR29nQkMwQURpQUVMUUFBYTBFSGJHcEJCV3hCSUdwQkJuVWhCeUFETFFBSklBTXRBQWRySUFNdEFBb2dBeTBBQm10QkFYUnFJQU10QUFzZ0F5MEFCV3RCQTJ4cUlBTXRBQXdnQXkwQUJHdEJBblJxSUFNdEFBMGdBeTBBQTJ0QkJXeHFJQU10QUE0Z0F5MEFBbXRCQm14cUlBTXRBQThnQXkwQUFXdEJCMnhxSUFNdEFCQWlBeUFGYTBFRGRHcEJCV3hCSUdwQkJuVWlCRUVEZENFSUlBUkJCMndoQ1NBRVFRWnNJUW9nQkVFRmJDRUxJQVJCQTJ3aERDQUVRWDFzSVEwZ0JFRjdiQ0VPSUFSQmVtd2hEeUFFUVhsc0lSQkJBQ0FFUVFGMEloRnJJUkpCQUNBRVFRSjBJaE5ySVJRZ0FDQURha0VFZEVFUWFpRVZRUUFoQlFOQUlBRWdCVUVFZENJQWFpQVZJQVZCZVdvZ0IyeHFJZ01nRUdwQkJYVWlCa0gvQVNBR1FmOEJTQnNpQmtFQUlBWkJBRW9iT2dBQUlBRWdBRUVCY21vZ0F5QVBha0VGZFNJR1FmOEJJQVpCL3dGSUd5SUdRUUFnQmtFQVNoczZBQUFnQVNBQVFRSnlhaUFESUE1cVFRVjFJZ1pCL3dFZ0JrSC9BVWdiSWdaQkFDQUdRUUJLR3pvQUFDQUJJQUJCQTNKcUlBTWdGR3BCQlhVaUJrSC9BU0FHUWY4QlNCc2lCa0VBSUFaQkFFb2JPZ0FBSUFFZ0FFRUVjbW9nQXlBTmFrRUZkU0lHUWY4QklBWkIvd0ZJR3lJR1FRQWdCa0VBU2hzNkFBQWdBU0FBUVFWeWFpQURJQkpxUVFWMUlnWkIvd0VnQmtIL0FVZ2JJZ1pCQUNBR1FRQktHem9BQUNBQklBQkJCbkpxSUFNZ0JHdEJCWFVpQmtIL0FTQUdRZjhCU0JzaUJrRUFJQVpCQUVvYk9nQUFJQUVnQUVFSGNtb2dBMEVGZFNJR1FmOEJJQVpCL3dGSUd5SUdRUUFnQmtFQVNoczZBQUFnQVNBQVFRaHlhaUFESUFScVFRVjFJZ1pCL3dFZ0JrSC9BVWdiSWdaQkFDQUdRUUJLR3pvQUFDQUJJQUJCQ1hKcUlBTWdFV3BCQlhVaUJrSC9BU0FHUWY4QlNCc2lCa0VBSUFaQkFFb2JPZ0FBSUFFZ0FFRUtjbW9nQXlBTWFrRUZkU0lHUWY4QklBWkIvd0ZJR3lJR1FRQWdCa0VBU2hzNkFBQWdBU0FBUVF0eWFpQURJQk5xUVFWMUlnWkIvd0VnQmtIL0FVZ2JJZ1pCQUNBR1FRQktHem9BQUNBQklBQkJESEpxSUFNZ0MycEJCWFVpQmtIL0FTQUdRZjhCU0JzaUJrRUFJQVpCQUVvYk9nQUFJQUVnQUVFTmNtb2dBeUFLYWtFRmRTSUdRZjhCSUFaQi93RklHeUlHUVFBZ0JrRUFTaHM2QUFBZ0FTQUFRUTV5YWlBRElBbHFRUVYxSWdaQi93RWdCa0gvQVVnYklnWkJBQ0FHUVFCS0d6b0FBQ0FCSUFCQkQzSnFJQU1nQ0dwQkJYVWlBRUgvQVNBQVFmOEJTQnNpQUVFQUlBQkJBRW9iT2dBQUlBVkJBV29pQlVFUVJ3MEFDd3RCQUNFQUlBRWdBa0VBRUFnZ0FTQUNRVUJyUVFFUUNDQUJJQUpCZ0FGcVFRSVFDQ0FCSUFKQndBRnFRUU1RQ0NBQklBSkJnQUpxUVFRUUNDQUJJQUpCd0FKcVFRVVFDQ0FCSUFKQmdBTnFRUVlRQ0NBQklBSkJ3QU5xUVFjUUNDQUJJQUpCZ0FScVFRZ1FDQ0FCSUFKQndBUnFRUWtRQ0NBQklBSkJnQVZxUVFvUUNDQUJJQUpCd0FWcVFRc1FDQ0FCSUFKQmdBWnFRUXdRQ0NBQklBSkJ3QVpxUVEwUUNDQUJJQUpCZ0FkcVFRNFFDQ0FCSUFKQndBZHFRUThRQ0FzZ0FBdkJDQUVIZndKQUlBTkZEUUFnQUNnQ0FDQURJQUFvQWdRaUJXNGlDQ0FGYkNJRVFRaDBhaUFESUFScklnZEJCSFJxSVFZZ0JVRUVkQ0VFSUFBb0FnZ2hDU0FGSUFOTElncEZCRUFnQVNBR0lBUkJmM05xSWdNdEFBQTZBQUFnQVNBR0lBUnJMUUFBT2dBQklBRWdBeTBBQWpvQUFpQUJJQU10QUFNNkFBTWdBU0FETFFBRU9nQUVJQUVnQXkwQUJUb0FCU0FCSUFNdEFBWTZBQVlnQVNBRExRQUhPZ0FISUFFZ0F5MEFDRG9BQ0NBQklBTXRBQWs2QUFrZ0FTQURMUUFLT2dBS0lBRWdBeTBBQ3pvQUN5QUJJQU10QUF3NkFBd2dBU0FETFFBTk9nQU5JQUVnQXkwQURqb0FEaUFCSUFNdEFBODZBQThnQVNBRExRQVFPZ0FRSUFFZ0F5MEFFVG9BRVNBQklBTXRBQkk2QUJJZ0FTQURMUUFUT2dBVElBRWdBeTBBRkRvQUZDQUJRUlZxSVFFTElBY0VRQ0FDSUFaQmYyb2lBeTBBQURvQUFDQUNJQU1nQkdvaUF5MEFBRG9BQVNBQ0lBTWdCR29pQXkwQUFEb0FBaUFDSUFNZ0JHb2lBeTBBQURvQUF5QUNJQU1nQkdvaUF5MEFBRG9BQkNBQ0lBTWdCR29pQXkwQUFEb0FCU0FDSUFNZ0JHb2lBeTBBQURvQUJpQUNJQU1nQkdvaUF5MEFBRG9BQnlBQ0lBTWdCR29pQXkwQUFEb0FDQ0FDSUFNZ0JHb2lBeTBBQURvQUNTQUNJQU1nQkdvaUF5MEFBRG9BQ2lBQ0lBTWdCR29pQXkwQUFEb0FDeUFDSUFNZ0JHb2lBeTBBQURvQURDQUNJQU1nQkdvaUF5MEFBRG9BRFNBQ0lBTWdCR29pQXkwQUFEb0FEaUFDSUFNZ0JHb3RBQUE2QUE4Z0FrRVFhaUVDQ3lBQUtBSUFJQVVnQ1d3aUJrRUlkR29nQ0NBRlFRTjBJZ0JzUVFOMGFpQUhRUU4wYWlFRUlBQkIrUC8vL3dkeElRQWdDa1VFUUNBQklBUWdBRUYvYzJvaUF5MEFBRG9BQUNBQklBUWdBR3N0QUFBNkFBRWdBU0FETFFBQ09nQUNJQUVnQXkwQUF6b0FBeUFCSUFNdEFBUTZBQVFnQVNBRExRQUZPZ0FGSUFFZ0F5MEFCam9BQmlBQklBTXRBQWM2QUFjZ0FTQURRUWhxSWdNdEFBQTZBQWdnQVNBR1FRWjBJQU5xSWdOQmVHb3RBQUE2QUFrZ0FTQURRWGxxTFFBQU9nQUtJQUVnQTBGNmFpMEFBRG9BQ3lBQklBTkJlMm90QUFBNkFBd2dBU0FEUVh4cUxRQUFPZ0FOSUFFZ0EwRjlhaTBBQURvQURpQUJJQU5CZm1vdEFBQTZBQThnQVNBRFFYOXFMUUFBT2dBUUlBRWdBeTBBQURvQUVRc2dCMFVOQUNBQ0lBUkJmMm9pQVMwQUFEb0FBQ0FDSUFBZ0FXb2lBUzBBQURvQUFTQUNJQUFnQVdvaUFTMEFBRG9BQWlBQ0lBQWdBV29pQVMwQUFEb0FBeUFDSUFBZ0FXb2lBUzBBQURvQUJDQUNJQUFnQVdvaUFTMEFBRG9BQlNBQ0lBQWdBV29pQVMwQUFEb0FCaUFDSUFBZ0FXb2lBUzBBQURvQUJ5QUNJQUFnQVdvZ0JpQUZhMEVHZEdvaUFTMEFBRG9BQ0NBQ0lBQWdBV29pQVMwQUFEb0FDU0FDSUFBZ0FXb2lBUzBBQURvQUNpQUNJQUFnQVdvaUFTMEFBRG9BQ3lBQ0lBQWdBV29pQVMwQUFEb0FEQ0FDSUFBZ0FXb2lBUzBBQURvQURTQUNJQUFnQVdvaUFTMEFBRG9BRGlBQ0lBQWdBV290QUFBNkFBOExDNjhCQVFGL0l3QkIwQUJySWdZa0FDQUNJQVpCSUdvZ0JpQURFRlVDUUFKQVFRSWdBQ2dDQUNJRFFRWkhJQU5CQmtrYlFRRkdCRUFnQUNBRklBRkJ5QUpxSUFaQklHb2dCaUFFRUZRaUEwVU5BUXdDQ3lBQUlBVWdBU0FHUVNCcUlBWWdCQkJUSWdNTkFRc2dBQ0FGUVlBQ2FpQUJRY2dLYWlBR1FUVnFJQVpCRUdvZ0FTZ0NqQUVnQkJCU0lnTU5BRUVBSVFNZ0FDZ0N4QUZCQVVzTkFDQUNJQVVRR3dzZ0JrSFFBR29rQUNBREM2TXFBU1IvSXdCQklHc2lFQ1FBSUJBZ0JDZ0NCQ0lJTmdJTUlCQWdCQ2dDQ0RZQ0VDQURJQWh1SWdaQkJIUWhGQ0FESUFZZ0NHeHJRUVIwSVJVQ1FBSkFBa0FDUUFKQUFrQUNRQUpBSUFBb0FnQWlCa0VEVFFSQUFrQUNRQUpBSUFaQkFtc09BZ0VDQUFzZ0FTZ0NrQUVoRXlBQUtBSUVJUTVCZnlFUEFuOGdBQ2dDeUFFaUNVVUVRRUVBSVFoQmZ3d0JDMEVBSVFoQmZ5QUpLQUlFSUE1SERRQWFRUUVoRWtGL0lBa29BZ0JCQlVzTkFCb2dDU2dDbUFFaUNFRVFkaUVISUFrb0FtZ0xJUTBnQUNnQ3pBRWlDVVVOQ0NBSktBSUVJQTVIRFFoQkFTRVdJQWtvQWdCQkJVc05DQ0FKS0FLc0FTSVJRUkIySVFvZ0NTZ0NiQ0VQREFnTElBRW9BcEFCSVJNZ0FTOEJvZ0VoRFNBQkx3R2dBU0VNSUFBb0FnUWhDMEYvSVFjQ1FDQUFLQUxNQVNJR1JRMEFJQXNnQmlnQ0JFY0VRQXdCQzBFQklSSWdCaWdDQUVFRlN3MEFJQVlvQXF3QklnbEJFSFloQ2lBR0tBSnNJUWNMSUFjZ0UwWUVRQ0FLSVFjZ0NTRUdEQWNMUVg4aER3SkFBa0FDUUNBQUtBTElBU0lJUlFSQVFRQWhCd3dCQzBFQUlRY2dDQ2dDQkNBTFJnMEJDMEVBSVFZTUFRdEJBU0VYSUFnb0FnQkJCVXNFUUVFQUlRWU1BUXNnQ0NnQ21BRWlCa0VRZGlFSElBZ29BbWdoRHdzQ1FBSkFJQUFvQXRBQklnaEZEUUFnQ0NnQ0JDQUxSdzBBSUFnb0FnQkJCVTBOQVF3R0N3SkFJQUFvQXRRQklnaEZEUUFnQ0NnQ0JDQUxSdzBBSUFnb0FnQkJCVXNOQmlBSUtBSndJUllnQ0NnQ3dBRWhDQXdIQzBFQUlRaEJmeUVXSUJJTkJpQVhSUTBHREFjTElBZ29BbXdoRmlBSUtBS3NBU0VJREFVTElBRW9BcEFCSVE4Z0FTOEJvZ0VoRFNBQkx3R2dBU0VNSUFBb0FnUWhCa0YvSVFjQ1FDQUFLQUxJQVNJS1JRUkFRUUFoQ0F3QkMwRUFJUWdnQmlBS0tBSUVSd1JBREFFTFFRRWhFU0FLS0FJQVFRVkxEUUFnQ2lnQ21BRWlDVUVRZGlFSUlBb29BbWdoQndzZ0J5QVBSZzBCQW44Q2Z3SkFBa0FnQUNnQ3pBRWlCMFVOQUNBSEtBSUVJQVpIRFFBZ0J5Z0NBRUVGU3cwQklBY29BbkFoRVNBSEtBSzhBU0VLSUFjb0Ftd2hFaUFIS0FLc0FTSUdRUkIyREFNTEFrQWdBQ2dDMUFFaUIwVU5BQ0FIS0FJRUlBWkhEUUJCQUNFR1FYOGhFaUFIS0FJQVFRVkxCRUJCZnlFUlFRQU1Bd3NnQnlnQ2NDRVJJQWNvQXNBQkRBSUxJQkVOQkF0QmZ5RVJRWDhoRWtFQUlRWkJBQXNoQ2tFQUN5RUhJQThnRWtZaUN5QVBJQkZHYWtFQlJ3UkFJQWNnQ0NBSFFSQjBRUkIxSWdzZ0NFRVFkRUVRZFNJT1NpSUlHeUlISUE0Z0N5QU9JQXNnRGtnYklBZ2JJZ2dnQ2tFUWRTSUxJQWdnQzBvYklBZEJFSFJCRUhVZ0MwZ2JJUWNnQmlBSklBWkJFSFJCRUhVaUN5QUpRUkIwUVJCMUlnbEtJZ1liSWdoQi8vOERjU0FKSUFzZ0NTQUxJQWxJR3lBR0d5SUdJQXBCRUhSQkVIVWlDU0FHSUFsS0d5QUlRUkIwUVJCMUlBbElHeUVHREFNTElBc05BaUFLUVJCMklRY2dDaUVHREFJTFFRRWhHeUFBUVlRQmFpRWNBMEFDZnlBQklCMUJBblFpSG1vaUlDSWtLQUt3QVNJR1FRSk5CRUFnQmtFQ2RFR2NOV29vQWdBTUFRdEJCQXNoSWlBQUlCNXFJZ1lnSUNnQ3dBRTJBbVFnQmlBQ0lDQW9Bc0FCRUJRaUJqWUNkQ0FHUlEwSUlDSUVRQ0FjSUIxQkJIUWlIMm9pSlNFbUlCd2dIMEVNY21vaUowRUNhaUVvSUJ3Z0gwRUljbW9pS1NFUklCd2dIMEVFY21vaUZpRVRRUUFoQmdOQUlBRWdIMm9nQmtFQ2RHb2lDQzhCMGdFaER5QUlMd0hRQVNFT0lDQW9Bc0FCSVNGQmZ5RVhBbjhnQUNBZFFRZDBJQ1FvQXJBQklpTkJCWFJxSUFaQkEzUnFJaHBCc0JscUtBSUFFQkVpQ1VVRVFFRUFJUXhCQUNFSVFRQWhDa0YvREFFTFFRQWhERUVBSVFoQkFDRUtRWDhnQ1NnQ0JDQUFLQUlFUncwQUdrRUJJUXBCZnlBSktBSUFRUVZMRFFBYUlBa2dHa0cwR1dvdEFBQWlCMEVDZEdvb0FvUUJJZ2hCRUhZaERDQUpJQWRCL0FGeGFpZ0NaQXNoRFFKQUFrQUNRQ0FBSUJwQnNCMXFLQUlBRUJFaUdFVUVRRUVBSVFrTUFRdEJBQ0VKSUJnb0FnUWdBQ2dDQkVZTkFRdEJBQ0VTUVFBaEN3d0JDMEVCSVFzZ0dDZ0NBRUVGU3dSQVFRQWhFZ3dCQ3lBWUlCcEJ0QjFxTFFBQUlnZEJBblJxS0FLRUFTSVNRUkIySVFrZ0dDQUhRZndCY1dvb0FtUWhGd3NDUUFKQUFrQUNRQUpBSUFBZ0drR3dJV29vQWdBUUVTSVpSUTBBSUJrb0FnUWdBQ2dDQkVjTkFDQVpLQUlBUVFWTkRRRU1BZ3NDUUNBQUlCcEJzQ1ZxS0FJQUVCRWlHVVVOQUNBWktBSUVJQUFvQWdSSERRQWdHU2dDQUVFRlN3MENJQmtnR2tHMEpXb3RBQUFpQjBIOEFYRnFLQUprSVJnZ0dTQUhRUUowYWlnQ2hBRWhCd3dEQzBFQUlRZEJmeUVZSUFwRkRRSWdDdzBDREFNTElCa2dHa0cwSVdvdEFBQWlCMEg4QVhGcUtBSmtJUmdnR1NBSFFRSjBhaWdDaEFFaEJ3d0JDMEVBSVFkQmZ5RVlDeUFYSUNGR0lnb2dEU0FoUmlJTGFpQVlJQ0ZHYWtFQlJ3UkFJQWtnRENBSlFSQjBRUkIxSWdzZ0RFRVFkRUVRZFNJTVNpSUpHeUlLSUF3Z0N5QU1JQXNnREVnYklBa2JJZ2tnQjBFUWRTSUxJQWtnQzBvYklBcEJFSFJCRUhVZ0MwZ2JJUXdnRWlBSUlCSkJFSFJCRUhVaUNpQUlRUkIwUVJCMUlndEtJZ2diSWdsQi8vOERjU0FMSUFvZ0N5QUtJQXRJR3lBSUd5SUlJQWRCRUhSQkVIVWlCeUFJSUFkS0d5QUpRUkIwUVJCMUlBZElHeUVJREFFTElBZ2dFaUFMR3lFSUlBd2dDU0FMR3lFTUlBc05BQ0FLRFFBZ0IwRVFkaUVNSUFjaENBc2dDQ0FPYWlJS1FSQjBRUkIxUVlCQWEwSC8vd0JMRFFvZ0RDQVBhaUlKUVJCMFFSQjFRWUFRYWtIL0gwc05DaUFqUVFOTkJFQUNmd0pBQWtBQ1FBSkFJQ05CQVdzT0F3RUNBd0FMSUNVZ0Nqc0JBQ0FtSUFrN0FRSWdGaUFLT3dFQUlCTWdDVHNCQWlBcElBbzdBUUFnRVNBSk93RUNJQ2NnQ2pzQkFDQW9EQU1MSUJ3Z0JrRUJkQ0FlYWtFQ2RDSUhhaUlJSUFrN0FRSWdDQ0FLT3dFQUlCd2dCMEVFY21vaUNDQUtPd0VBSUFoQkFtb01BZ3NnQUNBR0lCNXFRUUowYWlJSUlBbzdBWXdCSUFnZ0NUc0JoZ0VnQ0NBS093R0VBU0FJUVk0QmFnd0JDeUFBSUFZZ0htcEJBblJxSWdnZ0Nqc0JoQUVnQ0VHR0FXb0xJQWs3QVFBTElBWkJBV29pQmlBaVJ3MEFDd3NnSFVFQmFpSWRRUVJIRFFBTFFRQWhEQU5BSUJBZ0FDQU1RUUowSWdKcUtBSjBOZ0lJSUF4QkFVdEJBM1FoQ1NBTVFRTjBRUWh4SVFjQ1FDQUJJQUpxS0FLd0FTSUNRUUpOQkVBQ1FBSkFBa0FnQWtFQmF3NENBUUlBQ3lBRklBQWdERUVFZEdwQmhBRnFJQkJCQ0dvZ0ZTQVVJQWNnQ1VFSVFRZ1FEZ3dEQ3lBRklBQWdERUVFZEdvaUFrR0VBV29nRUVFSWFpQVZJQlFnQnlBSlFRaEJCQkFPSUFVZ0FrR01BV29nRUVFSWFpQVZJQlFnQnlBSlFRUnlRUWhCQkJBT0RBSUxJQVVnQUNBTVFRUjBhaUlDUVlRQmFpQVFRUWhxSUJVZ0ZDQUhJQWxCQkVFSUVBNGdCU0FDUVlnQmFpQVFRUWhxSUJVZ0ZDQUhRUVJ5SUFsQkJFRUlFQTRNQVFzZ0JTQUFJQXhCQkhScUlnaEJoQUZxSUJCQkNHb2dGU0FVSUFjZ0NVRUVRUVFRRGlBRklBaEJpQUZxSUJCQkNHb2dGU0FVSUFkQkJISWlCaUFKUVFSQkJCQU9JQVVnQ0VHTUFXb2dFRUVJYWlBVklCUWdCeUFKUVFSeUlnSkJCRUVFRUE0Z0JTQUlRWkFCYWlBUVFRaHFJQlVnRkNBR0lBSkJCRUVFRUE0TElBeEJBV29pREVFRVJ3MEFDd3dHQ3lBSUlRY2dDU0VHQzBFQklSc2dCaUFNYWlJSVFSQjBRUkIxUVlCQWEwSC8vd0JMRFFVZ0J5QU5haUlHUVJCMFFSQjFRWUFRYWtIL0gwc05CU0FDSUE4UUZDSUhSUTBGSUFBZ0Jqc0JzZ0VnQUNBSU93R3dBU0FBSUFjMkFuUWdBQ0FQTmdKa0lBQWdCellDZkNBQUlBODJBbXdnQUNBQUtBS3dBU0lHTmdLc0FTQUFJQVkyQXFnQklBQWdCallDcEFFZ0FDQUdOZ0tRQVNBQUlBWTJBb3dCSUFBZ0JqWUNpQUVnQUNBR05nS0VBU0FCS0FLVUFTRU9JQUV2QWFZQklRd2dBUzhCcEFFaEN5QUFLQUlFSVFrQ1FBSkFJQUFvQXRBQklnZEZEUUFnQnlnQ0JDQUpSdzBBUVFFaEVTQUhLQUlBUVFWTEJFQkJmeUVJUVFBaEJ3d0NDeUFIS0FKc0lRZ2dCeWdDckFFaEJ3d0JDMEYvSVFoQkFDRUhJQUFvQXN3QklncEZCRUJCQUNFUkRBRUxJQWtnQ2lnQ0JFY0VRRUVBSVJFTUFRdEJBU0VSSUFvb0FnQkJCVXNOQUNBS0tBSnNJUWdnQ2lnQ3NBRWhCd3NDUUNBSUlBNUdSUVJBSUFaQkVIWWhDQUovQWtBQ1FDQUFLQUxNQVNJTlJRMEFJQTBvQWdRZ0NVY05BQ0FOS0FJQVFRVkxEUUVnRFNnQ3ZBRWlFVUVRZGlFS0lBMG9BbkFNQWdzZ0VVVU5Bd3RCQUNFUlFRQWhDa0YvQ3lFTklBNGdEMFlpQ1NBTklBNUdha0VCUndSQUlBb2dDQ0FLUVJCMFFSQjFJZzBnQ0VFUWRFRVFkVW9pQ0JzaUNTQUdRUkIxSWdvZ0RTQUtJQW9nRFVvYklBZ2JJZ2dnQjBFUWRTSUtJQWdnQ2tvYklBbEJFSFJCRUhVZ0NrZ2JJUWdnRVNBR0lCRkJFSFJCRUhVaUNpQUdRUkIwUVJCMUlnMUtJZ1liSWdsQi8vOERjU0FOSUFvZ0RTQU5JQXBLR3lBR0d5SUdJQWRCRUhSQkVIVWlCeUFHSUFkS0d5QUpRUkIwUVJCMUlBZElHeUVHREFJTElBa05BU0FOSUE1R0JFQWdFVUgvL3dOeElBcEJFSFJ5SVFZZ0NpRUlEQUlMQ3lBSFFSQjJJUWdnQnlFR0N5QUdJQXRxSWdkQkVIUkJFSFZCZ0VCclFmLy9BRXNOQlNBSUlBeHFJZ1pCRUhSQkVIVkJnQkJxUWY4ZlN3MEZJQUlnRGhBVUlnSkZEUVVnQUNBR093SENBU0FBSUFjN0FjQUJJQUFnQWpZQ2dBRWdBQ0FDTmdKNElBQWdEallDY0NBQUlBNDJBbWdnQUNBQUtBTEFBU0lHTmdLOEFTQUFJQVkyQXJnQklBQWdCallDdEFFZ0FDQUdOZ0tnQVNBQUlBWTJBcHdCSUFBZ0JqWUNtQUVnQUVHVUFXb2lBaUFHTmdJQUlCQWdBQ2dDZERZQ0NDQUZJQUJCaEFGcUlCQkJDR29nRlNBVVFRQkJBRUVJUVJBUURpQVFJQUFvQW5nMkFnZ2dCU0FDSUJCQkNHb2dGU0FVUVFoQkFFRUlRUkFRRGd3RUMwRUFJUWhCZnlFV0N5QVBJQk5HSWdzZ0V5QVdSbXBCQVVjRVFDQUtJQWNnQ2tFUWRFRVFkU0lMSUFkQkVIUkJFSFVpRGtvaUJ4c2lDaUFPSUFzZ0RpQUxJQTVJR3lBSEd5SUhJQWhCRUhVaUN5QUhJQXRLR3lBS1FSQjBRUkIxSUF0SUd5RUhJQWtnQmlBSlFSQjBRUkIxSWdvZ0JrRVFkRUVRZFNJTFNpSUdHeUlKUWYvL0EzRWdDeUFLSUFzZ0NpQUxTQnNnQmhzaUJpQUlRUkIwUVJCMUlnZ2dCaUFJU2hzZ0NVRVFkRUVRZFNBSVNCc2hCZ3dCQ3lBTERRQWdDRUVRZGlFSElBZ2hCZ3RCQVNFYklBWWdER29pQ0VFUWRFRVFkVUdBUUd0Qi8vOEFTdzBDSUFjZ0RXb2lCa0VRZEVFUWRVR0FFR3BCL3g5TERRSWdBaUFURUJRaUIwVU5BaUFBSUFZN0FhSUJJQUFnQ0RzQm9BRWdBQ0FITmdKMElBQWdFellDWkNBQUlBYzJBbmdnQUNBVE5nSm9JQUFnQUNnQ29BRWlEellDbkFFZ0FDQVBOZ0tZQVNBQUlBODJBcFFCSUFBZ0R6WUNrQUVnQUNBUE5nS01BU0FBSUE4MkFvZ0JJQUFnRHpZQ2hBRWdBU2dDbEFFaERpQUJMd0dtQVNFTklBRXZBYVFCSVF3Q2Z3SkFBa0FDUUNBQUtBTElBU0lHQkVBZ0JpZ0NCQ0FBS0FJRVJnUkFJQVlvQWdCQkJVMEVRQ0FHS0FLNEFTSUxRUkIySVFjZ0JpZ0NjQ0FPUncwRUlBc2hDUXdEQzBGL0lSSkJBQ0VKUVFBaEIwRUFJUXRCQUNFS0lBNUJmMFlOQWd3RUMwRi9JUkpCQUNFSlFRQWhCMEVBSVF0QkFDRUtJQTVCZjBZTkFRd0RDMEYvSVJKQkFDRUpRUUFoQjBFQUlRdEJBQ0VLSUE1QmYwY05BZ3NnQ1VILy93TnhJQWRCRUhSeURBSUxJQVlvQW1naEVpQUdLQUtnQVNFS0lBY2hDUXNnRDBFUWRpRUlJQTRnRTBZaUJpQU9JQkpHYWtFQlJ3UkFJQWdnQ1NBSlFSQjBRUkIxSWdrZ0NFRVFkRUVRZFVnaUJ4c2lDQ0FKSUE5QkVIVWlCaUFKSUFZZ0NVZ2JJQWNiSWdZZ0NrRVFkU0lISUFZZ0Iwb2JJQWhCRUhSQkVIVWdCMGdiSVFjZ0R5QUxJQXRCRUhSQkVIVWlDeUFQUVJCMFFSQjFJZ2xJSWdZYklnaEIvLzhEY1NBTElBa2dDeUFKSUF0SUd5QUdHeUlHSUFwQkVIUkJFSFVpQ1NBR0lBbEtHeUFJUVJCMFFSQjFJQWxJR3d3QkN5QUlJQXBCRUhZZ0Joc2hCeUFQSUFvZ0Joc0xJQXhxSWdoQkVIUkJFSFZCZ0VCclFmLy9BRXNOQWlBSElBMXFJZ1pCRUhSQkVIVkJnQkJxUWY4ZlN3MENJQUlnRGhBVUlnSkZEUUlnQUNBR093SENBU0FBSUFnN0FjQUJJQUFnQWpZQ2dBRWdBQ0FDTmdKOElBQWdEallDY0NBQUlBNDJBbXdnQUNBQUtBTEFBU0lHTmdLOEFTQUFJQVkyQXJnQklBQWdCallDdEFFZ0FDQUdOZ0t3QVNBQUlBWTJBcXdCSUFBZ0JqWUNxQUVnQUVHa0FXb2lBaUFHTmdJQUlCQWdBQ2dDZERZQ0NDQUZJQUJCaEFGcUlCQkJDR29nRlNBVVFRQkJBRUVRUVFnUURpQVFJQUFvQW53MkFnZ2dCU0FDSUJCQkNHb2dGU0FVUVFCQkNFRVFRUWdRRGd3QkN3SkFJQVpGQkVBZ0VrVUVRRUVBSVFrTUFnc2dGa1VFUUVFQUlRa01BZ3NnQ0VILy93TnhJQWRCRUhSeUlBMXlSUVJBUVFBaENRd0NDMEVBSVFrZ0VVSC8vd054SUFwQkVIUnlJQTl5UlEwQkN5QUJMd0dpQVNFTElBRXZBYUFCSVFrQ1FBSkFBa0FDUUFKQUlBQW9BdEFCSWdaRkRRQWdCaWdDQkNBT1J3MEFJQVlvQWdCQkJVME5BUXdDQ3dKQUlBQW9BdFFCSWdaRkRRQWdCaWdDQkNBT1J3MEFJQVlvQWdCQkJVc05BaUFHS0FKd0lSY2dCaWdDd0FFaERBd0RDMEYvSVJjZ0VrVU5BaUFXRFFJTUF3c2dCaWdDYkNFWElBWW9BcXdCSVF3TUFRdEJmeUVYQ3lBUElCTkdJZ1lnRFNBVFJpSU5haUFUSUJkR2FrRUJSd1JBSUFvZ0J5QUtRUkIwUVJCMUlnb2dCMEVRZEVFUWRTSU5TaUlHR3lJSElBMGdDaUFOSUFvZ0RVZ2JJQVliSWdZZ0RFRVFkU0lLSUFZZ0Nrb2JJQWRCRUhSQkVIVWdDa2diSVFjZ0VTQUlJQkZCRUhSQkVIVWlDaUFJUVJCMFFSQjFJZzFLSWdZYklnaEIvLzhEY1NBTklBb2dEU0FLSUExSUd5QUdHeUlHSUF4QkVIUkJFSFVpQ2lBR0lBcEtHeUFJUVJCMFFSQjFJQXBJR3lFSURBRUxJQWdnRVNBTkd5RUlJQWNnQ2lBTkd5RUhJQTBOQUNBR0RRQWdERUVRZGlFSElBd2hDQXRCQVNFYklBZ2dDV29pREVFUWRFRVFkVUdBUUd0Qi8vOEFTdzBDSUFjZ0Myb2lDVUVRZEVFUWRVR0FFR3BCL3g5TERRSUxJQUlnRXhBVUlnSkZCRUJCQVNFYkRBSUxJQUFnQ1RzQndnRWdBQ0FNT3dIQUFTQUFJQUkyQW5RZ0FDQVROZ0prSUFBZ0FqWUNnQUVnQUNBQ05nSjhJQUFnQWpZQ2VDQUFJQk0yQW5BZ0FDQVROZ0pzSUFBZ0V6WUNhQ0FBSUFBb0FzQUJJZ1kyQXJ3QklBQWdCallDdUFFZ0FDQUdOZ0swQVNBQUlBWTJBckFCSUFBZ0JqWUNyQUVnQUNBR05nS29BU0FBSUFZMkFxUUJJQUFnQmpZQ29BRWdBQ0FHTmdLY0FTQUFJQVkyQXBnQklBQWdCallDbEFFZ0FDQUdOZ0tRQVNBQUlBWTJBb3dCSUFBZ0JqWUNpQUVnQUNBR05nS0VBU0FRSUFJMkFnZ2dCU0FBUVlRQmFpQVFRUWhxSUJVZ0ZFRUFRUUJCRUVFUUVBNExRUUFoR3lBQUtBTEVBVUVCU3cwQUlBQW9BZ0FFUUNBRUlBTWdCU0FCUWNnQ2FoQllEQUVMSUFRZ0JSQWJDeUFRUVNCcUpBQWdHd3VUQ3dFUGZ5QUFLQUlBSWhFZ0FTQUJJQUFvQWdRaUNuQWlBV3NpQkVFSWRHb2dBVUVFZEdvaEJTQUtRUVIwSVFzZ0FDZ0NDQ0FLYkNJQVFRWjBJUVlnQVVFRGRDRUpJQUJCQ0hRaERDQUVRUVowSVJJZ0NrRUNkRUg4Ly8vL0EzRkJBblFoRUFOQUlBVWdEa0VDZENJQVFmQXBhaWdDQUNJQklBdHNhaUFBUWJBcGFpZ0NBQ0lBYWlFRUlBSWdBVUVFZEdvZ0FHb2hBQUpBSUFNZ0RrRUdkR29pQVNnQ0FDSUhRZi8vL3dkSEJFQWdBU2dDQkNFSUlBQXRBQUVoRFNBRUlBY2dBQzBBQUdwQnNDNXFMUUFBT2dBQUlBRW9BZ2doQnlBQUxRQUNJUThnQkNBSUlBMXFRYkF1YWkwQUFEb0FBU0FCS0FJTUlRZ2dBQzBBQXlFTklBUWdCeUFQYWtHd0xtb3RBQUE2QUFJZ0JDQUlJQTFxUWJBdWFpMEFBRG9BQXlBQktBSVVJUWNnQUMwQUVTRUlJQVFnQzJvaUJDQUJLQUlRSUFBdEFCQnFRYkF1YWkwQUFEb0FBQ0FCS0FJWUlRMGdBQzBBRWlFUElBUWdCeUFJYWtHd0xtb3RBQUE2QUFFZ0FTZ0NIQ0VISUFBdEFCTWhDQ0FFSUEwZ0QycEJzQzVxTFFBQU9nQUNJQVFnQnlBSWFrR3dMbW90QUFBNkFBTWdBU2dDSkNFSElBQXRBQ0VoQ0NBRUlBdHFJZ1FnQVNnQ0lDQUFMUUFnYWtHd0xtb3RBQUE2QUFBZ0FTZ0NLQ0VOSUFBdEFDSWhEeUFFSUFjZ0NHcEJzQzVxTFFBQU9nQUJJQUVvQWl3aEJ5QUFMUUFqSVFnZ0JDQU5JQTlxUWJBdWFpMEFBRG9BQWlBRUlBY2dDR3BCc0M1cUxRQUFPZ0FESUFFb0FqUWhCeUFBTFFBeElRZ2dCQ0FMYWlJRUlBRW9BakFnQUMwQU1HcEJzQzVxTFFBQU9nQUFJQUVvQWpnaERTQUFMUUF5SVE4Z0JDQUhJQWhxUWJBdWFpMEFBRG9BQVNBQktBSThJUUVnQUMwQU15RUFJQVFnRFNBUGFrR3dMbW90QUFBNkFBSWdCQ0FBSUFGcVFiQXVhaTBBQURvQUF3d0JDeUFBS0FJUUlRRWdCQ0FBS0FJQU5nSUFJQVFnRUdvaUJDQUJOZ0lBSUFBb0FqQWhBU0FFSUJCcUlnUWdBQ2dDSURZQ0FDQUVJQkJxSUFFMkFnQUxJQTVCQVdvaURrRVFSdzBBQ3lBTUlCRnFJQkpxSUFscUloQWdCbW9oRVNBS1FRTjBRZmovLy84SGNTSUxRUUoyUVFKMElRNUJFQ0VLQTBBZ0NrRUNkRUVNY1NJQVFmQXBhaWdDQUNJQklBdHNJQUJCc0NscUtBSUFJZ0JxSUJFZ0VDQUtRUk5MSWdVYmFpRUVJQUpCd0FKQmdBSWdCUnRxSUFGQkEzUWdBR3BxSVFBQ1FDQURJQXBCQm5ScUlnRW9BZ0FpQlVILy8vOEhSd1JBSUFFb0FnUWhCaUFBTFFBQklRa2dCQ0FGSUFBdEFBQnFRYkF1YWkwQUFEb0FBQ0FCS0FJSUlRVWdBQzBBQWlFTUlBUWdCaUFKYWtHd0xtb3RBQUE2QUFFZ0FTZ0NEQ0VHSUFBdEFBTWhDU0FFSUFVZ0RHcEJzQzVxTFFBQU9nQUNJQVFnQmlBSmFrR3dMbW90QUFBNkFBTWdBU2dDRkNFRklBQXRBQWtoQmlBRUlBdHFJZ1FnQVNnQ0VDQUFMUUFJYWtHd0xtb3RBQUE2QUFBZ0FTZ0NHQ0VKSUFBdEFBb2hEQ0FFSUFVZ0JtcEJzQzVxTFFBQU9nQUJJQUVvQWh3aEJTQUFMUUFMSVFZZ0JDQUpJQXhxUWJBdWFpMEFBRG9BQWlBRUlBVWdCbXBCc0M1cUxRQUFPZ0FESUFFb0FpUWhCU0FBTFFBUklRWWdCQ0FMYWlJRUlBRW9BaUFnQUMwQUVHcEJzQzVxTFFBQU9nQUFJQUVvQWlnaENTQUFMUUFTSVF3Z0JDQUZJQVpxUWJBdWFpMEFBRG9BQVNBQktBSXNJUVVnQUMwQUV5RUdJQVFnQ1NBTWFrR3dMbW90QUFBNkFBSWdCQ0FGSUFacVFiQXVhaTBBQURvQUF5QUJLQUkwSVFVZ0FDMEFHU0VHSUFRZ0Myb2lCQ0FCS0FJd0lBQXRBQmhxUWJBdWFpMEFBRG9BQUNBQktBSTRJUWtnQUMwQUdpRU1JQVFnQlNBR2FrR3dMbW90QUFBNkFBRWdBU2dDUENFQklBQXRBQnNoQUNBRUlBa2dER3BCc0M1cUxRQUFPZ0FDSUFRZ0FDQUJha0d3TG1vdEFBQTZBQU1NQVFzZ0FDZ0NDQ0VCSUFRZ0FDZ0NBRFlDQUNBRUlBNXFJZ1FnQVRZQ0FDQUFLQUlZSVFFZ0JDQU9haUlFSUFBb0FoQTJBZ0FnQkNBT2FpQUJOZ0lBQ3lBS1FRRnFJZ3BCR0VjTkFBc0w1Z0VCQjM4Q1FDQUFLQUlBSWdWRkRRQWdBRUVCTmdJOElBQW9BamdOQUNBQUtBSWNJUVpCLy8vLy93Y2hBZ05BQTBBZ0JTQURRU2hzYWlJRUtBSVlCRUFnQkNBQklBUW9BaEFpQkNBQ1NDSUhHeUVCSUFRZ0FpQUhHeUVDQ3lBRFFRRnFJZ01nQmswTkFDQUJSUTBDSUFBb0Fnd2dBQ2dDRUNJRFFRUjBhaUlDSUFFb0FnQTJBZ0FnQWlBQktBSWtOZ0lNSUFJZ0FTZ0NIRFlDQkNBQ0lBRW9BaUEyQWdnZ0FDQURRUUZxTmdJUVFRQWhBeUFCUVFBMkFoZ2dBU2dDRkNFRVFRQWhBVUgvLy8vL0J5RUNJQVFOQUFzZ0FDQUFLQUlzUVg5cU5nSXNEQUFBQ3dBTEM5d0dBUXAvSUFCQ0FEY0NFQUpBQWtBQ1FDQURSUTBBQWtBQ1FDQUJJQUFvQWpBaUEwY0VRQ0FEUVFGcUlBQW9BaUFpQkhBaUNTQUJSZzBCSUFBb0FnQWdBQ2dDSEVFb2JHb29BZ0FoQ3dOQUFrQUNRQ0FBS0FJb0lnY0VRQ0FBS0FJQUlRaEJBQ0VEQTBBZ0NDQURRU2hzYWlJRktBSVVRWDlxUVFGTkJFQWdCU0FGS0FJTUlnVWdCRUVBSUFVZ0NVc2JhellDQ0FzZ0EwRUJhaUlESUFkSERRQUxJQWNnQUNnQ0dFa05Ba0YvSVFWQkFDRURRUUFoQkFOQUlBZ2dBMEVvYkdvaUJpZ0NGRUYvYWtFQlRRUkFJQVlvQWdnaUJpQUVJQVZCZjBZZ0JpQUVTSElpQmhzaEJDQURJQVVnQmhzaEJRc2dBMEVCYWlJRElBZEhEUUFMSUFWQkFFNE5BVUVCRHd0QkFDRUhJQUFvQWhnTkFVRUJEd3NnQ0NBRlFTaHNhaUlEUVFBMkFoUWdBQ0FIUVg5cUlnYzJBaWdnQXlnQ0dBMEFJQUFnQUNnQ0xFRi9hallDTEFzZ0FDZ0NMQ0lGSUFBb0Fod2lDRThFUUNBQUtBSTREUVlnQUNnQ0FDRU1BMEJCQUNFRVFmLy8vLzhISVFaQkFDRURBMEFnRENBRFFTaHNhaUlLS0FJWUJFQWdDaUFFSUFvb0FoQWlDaUFHU0NJTkd5RUVJQW9nQmlBTkd5RUdDeUFEUVFGcUlnTWdDRTBOQUFzQ1FDQUVSUTBBSUFBb0Fnd2dBQ2dDRUNJR1FRUjBhaUlESUFRb0FnQTJBZ0FnQXlBRUtBSWtOZ0lNSUFNZ0JDZ0NIRFlDQkNBRElBUW9BaUEyQWdnZ0FDQUdRUUZxTmdJUUlBUkJBRFlDR0NBRUtBSVVEUUFnQUNBRlFYOXFJZ1UyQWl3TElBVWdDRThOQUFzTElBQW9BZ0FpQkNBSVFTaHNhaUlESUFrMkFnd2dBMEtBZ0lDQUVEY0NFQ0FEUVFBMkFoZ2dBeUFKTmdJSUlBQWdCMEVCYWpZQ0tDQUFJQVZCQVdvMkFpd2dCQ0FJUVFGcUVDY2dDVUVCYWlBQUtBSWdJZ1J3SWdrZ0FVY05BQXNDUUNBQUtBSVFJZ2xGRFFBZ0FDZ0NBQ0lGSUFBb0Fod2lCRUVvYkdvaUNDZ0NBQ0VISUFBb0Fnd2hCa0VBSVFNRFFDQUhJQVlnQTBFRWRHb29BZ0JIQkVBZ0NTQURRUUZxSWdOSERRRU1BZ3NMSUFSRkRRQkJBQ0VEQTBBZ0N5QUZJQU5CS0d4cUlna29BZ0JIQkVBZ0JDQURRUUZxSWdOSERRRU1BZ3NMSUFrZ0J6WUNBQ0FJSUFzMkFnQUxJQUlOQlNBQUtBSXdJUU1NQWdzZ0FrRUFSdzhMSUFJTkF3c2dBU0FEUmcwQUlBQWdBU0FBS0FJZ0lnQnFRWDlxSUFCd05nSXdDMEVBRHdzRFFBd0FBQXNBQ3lBQUlBRTJBakJCQUF0MUFRTi9Ba0FnQUNnQ0FDSUJSUTBBSUFBb0FoeEJmMFlOQUFOQUlBRWdBa0VvYkNJRGFpZ0NCQkFFSUFBb0FnQWlBU0FEYWtFQU5nSUVJQUpCQVdvaUFpQUFLQUljUVFGcVNRMEFDd3NnQVJBRUlBQkJBRFlDQUNBQUtBSUVFQVFnQUVFQU5nSUVJQUFvQWd3UUJDQUFRUUEyQWd3TGd3RUJBMzhDUUNBQUtBSUFJZ1pGRFFBZ0FDZ0NIRUYvUmcwQUEwQWdCaUFIUVNoc0lnaHFLQUlFRUFRZ0FDZ0NBQ0lHSUFocVFRQTJBZ1FnQjBFQmFpSUhJQUFvQWh4QkFXcEpEUUFMQ3lBR0VBUWdBRUVBTmdJQUlBQW9BZ1FRQkNBQVFRQTJBZ1FnQUNnQ0RCQUVJQUJCQURZQ0RDQUFJQUVnQWlBRElBUWdCUkJkQzRBQ0FRSi9JQUFnQlRZQ09DQUFJQVEyQWlBZ0FFTC8vd00zQWlRZ0FFSUFOd0lzSUFBZ0EwRUJJQU5CQVVzYklnTTJBaGdnQUNBRElBSWdCUnNpQWpZQ0hDQUFRYWdGRUFvaUF6WUNBRUgvL3dNaEJBSkFJQU5GRFFCQkFDRUZJQU5CQUVHb0JSQUhJUVlnQWtGL1J3UkFJQUZCZ0FOc1FTOXlJUVZCQUNFREEwQWdCaUFEUVNoc2FpSUhJQVVRQ2lJQk5nSUVJQUZGRFFJZ0J5QUJRUUFnQVd0QkQzRnFOZ0lBSUFNZ0Fra2hBU0FEUVFGcUlRTWdBUTBBQ3lBQ1FRUjBRUkJxSVFVTElBQkJ4QUFRQ2lJQk5nSUVJQUFnQlJBS0lnSTJBZ3dnQWtVTkFDQUJSUTBBUVFBaEJDQUJRUUJCeEFBUUJ4b2dBRUlBTndJUUN5QUVDOU1CQVFkL1FRRWhBUUpBSUFBb0FqZ05BQ0FBS0FJY0lRVWdBQ2dDQUNFR1FmLy8vLzhISVFOQkFDRUJBMEFnQmlBQlFTaHNhaUlFS0FJWUJFQWdCQ0FDSUFRb0FoQWlCQ0FEU0NJSEd5RUNJQVFnQXlBSEd5RURDeUFCUVFGcUlnRWdCVTBOQUFzZ0FrVUVRRUVCRHdzZ0FDZ0NEQ0FBS0FJUUlnTkJCSFJxSWdFZ0FpZ0NBRFlDQUNBQklBSW9BaVEyQWd3Z0FTQUNLQUljTmdJRUlBRWdBaWdDSURZQ0NDQUFJQU5CQVdvMkFoQkJBQ0VCSUFKQkFEWUNHQ0FDS0FJVURRQWdBQ0FBS0FJc1FYOXFOZ0lzQ3lBQkMvVUVBUWgvSUFBb0FpZ2lCQVJBSUFBb0FnQWhCd05BSUFjZ0JVRW9iR29pQmlnQ0ZFRi9ha0VCVFFSQUlBWWdCaWdDRENJSUlBSkxCSDhnQ0NBQUtBSWdhd1VnQ0FzMkFnZ0xJQVZCQVdvaUJTQUVSdzBBQ3d0QkFDRUVBa0FnQVNnQ0FFVU5BQ0FCS0FJRUlnVkJBa3NOQUVFQUlRY2dBaUVHQTBBQ1FBSkFBa0FnQlVFQ1J3UkFJQUVnQjBFTWJHb29BZ2doQkFKQUlBVkZCRUFnQmlBRWF5SUdRWDlLRFFFZ0FDZ0NJQ0FHYWlFR0RBRUxJQVFnQm1vaUJrRUFJQUFvQWlBaUJTQUdJQVZJRzJzaEJnc2dCaUVKSUFZZ0Frc0VRQ0FHSUFBb0FpQnJJUWtMSUFBb0FoZ2lDa1VFUUVFQkR3c2dBQ2dDQUNFSVFRQWhCUU5BSUFnZ0JVRW9iR29pQkNnQ0ZDSUxRWDlxUVFGTkJFQWdCQ2dDQ0NBSlJnMERDMEVCSVFRZ0JVRUJhaUlGSUFwSERRQUxEQVVMUVFFaEJDQUFLQUlZSWdsRkRRUWdBU0FIUVF4c2FpZ0NEQ0VLSUFBb0FnQWhDRUVBSVFVRFFDQUlJQVZCS0d4cUlnUW9BaFJCQTBZRVFDQUVLQUlJSUFwR0RRTUxRUUVoQkNBRlFRRnFJZ1VnQ1VjTkFBc01CQXNnQlVFQVNBUkFRUUVQQzBFQklRUWdDMEVCU3cwQkRBTUxRUUVoQkNBRlFRQklEUUlMSUFjZ0F5SUVTUVJBQTBBZ0FDZ0NCQ0lKSUFSQkFuUnFJQWtnQkVGL2FpSUVRUUowYWlnQ0FEWUNBQ0FFSUFkTERRQUxJQUFvQWdBaENBc2dBQ2dDQkNBSFFRSjBhaUFJSUFWQktHd2lDV28yQWdBZ0IwRUJhaUlISVFRZ0J5SUZJQU5OQkVBRFFDQUFLQUlFSWdnZ0JVRUNkR29vQWdBaUNpQUFLQUlBSUFscVJ3UkFJQWdnQkVFQ2RHb2dDallDQUNBRVFRRnFJUVFMSUFWQkFXb2lCU0FEVFEwQUN3dEJBQ0VFSUFFZ0IwRU1iR29vQWdRaUJVRURTUTBBQ3dzZ0JBc0dBQ0FBRUFRTEJ3QkJ4Qm9RQ2d1NEFnRURmd05BSUFBZ0FrRUNkR29pQVVFVWFpZ0NBQ0lEQkVBZ0F5Z0NLQkFFSUFFb0FoUkJBRFlDS0NBQktBSVVLQUpVRUFRZ0FTZ0NGRUVBTmdKVUlBRW9BaFFRQkNBQlFRQTJBaFFMSUFKQkFXb2lBa0VnUncwQUMwRUFJUUlEUUNBQUlBSkJBblJxSWdGQmxBRnFLQUlBSWdNRVFDQURLQUlVRUFRZ0FTZ0NsQUZCQURZQ0ZDQUJLQUtVQVNnQ0dCQUVJQUVvQXBRQlFRQTJBaGdnQVNnQ2xBRW9BaHdRQkNBQktBS1VBVUVBTmdJY0lBRW9BcFFCS0FJc0VBUWdBU2dDbEFGQkFEWUNMQ0FCS0FLVUFSQUVJQUZCQURZQ2xBRUxJQUpCQVdvaUFrR0FBa2NOQUFzZ0FDZ0NzQm9RQkNBQVFRQTJBckFhSUFBb0Fyd0pFQVFnQUVFQU5nSzhDU0FBS0FLVUNSQUVJQUJCQURZQ2xBa2dBQ2dDdkJvaUFRUkFJQUVRQkNBQVFRQTJBcndhQ3lBQVFjUUphaEJiQzdjQkFRSi9Jd0JCRUdzaUJpUUFJQVpCQURZQ0RDQUFJQUVnQWlBR1FReHFFQ29pQjBGOWNVVUVRQU5BSUFBZ0FTQUdLQUlNSWdkcUlnRWdBaUFIYXlJQ0lBWkJER29RS2lJSFFYMXhSUTBBQ3dzZ0IwRUJSZ1JBSUFRZ0FDZ0NFQ0lCS0FJMFFRUjBOZ0lBSUFVZ0FTZ0NPRUVFZERZQ0FDQURJQUJCeEFscUlnQW9BaFFpQVNBQUtBSVFTUVIvSUFBZ0FVRUJhallDRkNBQUtBSU1JQUZCQkhScUJVRUFDeWdDQURZQ0FBc2dCa0VRYWlRQUlBY0xTUUVCZnlBQVFRQkJ4Qm9RQnlJQ1FiUUtha0VCTmdJQUlBSkNnSUtBZ0lBRU53SUVJQUJCd0JBUUNpSUNOZ0t3R2lBQ1JRUkFRUUVQQ3lBQkJFQWdBRUVCTmdMQUNRdEJBQXU2QkFFSmZ3SkFBa0FnQVVFRVNRMEFJQUF0QUFBTkFDQUFMUUFCRFFBZ0FDMEFBaUlIUVFGTERRQkJBeUVFSUFCQkEyb2hCVUVDSVFoQmZTRU1Ba0FEUUNBRklRWUNmeUFJUVFGcUlBZEIvd0Z4SWdWRkRRQWFRUUFoQnlBRlFRRkdRUUFnQ0VFQlN4c05Ba0VBQ3lFSUlBUkJmM01oRENBR1FRRnFJUVVnQmkwQUFDRUhJQVJCQVdvaUJDQUJSdzBBQ3lBRElBRTJBZ0JCQVE4TElBUWhDa0VBSVFoQkFDRUZBMEJCQVNBSUlBY2dCaTBBQUNJTFJXb2lDVUVDUmhzZ0NDQUxRUU5HR3lFSUlBcEJBV29oQ2dKQUlBdEJBVWNOQUNBSlFRSkpEUUFnQWlBS0lBeHFJQWxCZjNOcUlnRTJBZ3hCQUNBSlFYMXFJZ1lnQmlBSlN4c2hCd3dEQzBFQUlBa2dDeHNoQjBFQklBVWdDVUVDU3hzZ0JTQUxHeUVGSUFaQkFXb2hCaUFCSUFwSERRQUxJQUlnQVNBTWFpQUhheUlCTmdJTURBRUxJQUlnQVRZQ0RFRUJJUWhCQUNFSEN5QUNRUUEyQWhBZ0FrRUFOZ0lJSUFJZ0FDQUVhaUlBTmdJRUlBSWdBRFlDQUNBRElBUWdCMm9nQVdvMkFnQkJBU0VEQWtBZ0JRMEFRUUFoQXlBSVJRMEFJQUlDZnlBQ0tBSU1JZ0ZGQkVBZ0FDRUVRUUFNQVFzZ0FDRUVRUUFoQmdOQUlBRkJmMm9oQVNBRUxRQUFJUVVDZndKQUlBWkJBa2NOQUNBRlFRTkdCRUFnQVVVRVFFRUJEd3NnQkMwQUFVRURTd1JBUVFFUEMwRUFJUVlnQkVFQmFnd0NDeUFGUVFOUERRQkJBUThMSUFBZ0JUb0FBRUVBSUFaQkFXb2dCUnNoQmlBQVFRRnFJUUFnQkVFQmFnc2hCQ0FCRFFBTElBSW9BZ3dMSUFBZ0JHdHFOZ0lNQ3lBREN3TUFBUXNMN1RJWkFFR0dDQXZLQldZZ0poQUdDR1VZWlJoREVFTVFReEJERUVNUVF4QkRFRU1RSWdnaUNDSUlJZ2dpQ0NJSUlnZ2lDQ0lJSWdnaUNDSUlJZ2dpQ0NJSUlnZ0FBQUFBQUFBQUFHcEFTakFxS0FvZ2FUaHBPRWtvU1NncElDa2dDUmdKR0dnd2FEQm9NR2d3U0NCSUlFZ2dTQ0FvR0NnWUtCZ29HQWdRQ0JBSUVBZ1FaeWhuS0djb1p5aG5LR2NvWnlobktFY1lSeGhIR0VjWVJ4aEhHRWNZUnhodVlFNVlMbEFPVUc1WVRsQXVTQTVJRFVBTlFFMUlUVWd0UUMxQURUZ05PRzFRYlZCTlFFMUFMVGd0T0Ewd0RUQnJTR3RJYTBoclNHdElhMGhyU0d0SVN6aExPRXM0U3poTE9FczRTemhMT0Nzd0t6QXJNQ3N3S3pBck1Dc3dLekFMS0Fzb0N5Z0xLQXNvQ3lnTEtBc29BQUFBQUM5b0wyZ1FnRkNBTUlBUWVIQ0FVSGd3ZUJCd2NIaFFjREJ3RUdodmNHOXdUMmhQYUM5Z0wyQVBZQTlnYjJodmFFOWdUMkF2V0M5WUQxZ1BXQUFBQUFBQUFBQUFaamhHSUNZZ0JoQm1NRVlZSmhnR0NHVW9aU2dsRUNVUVpDQmtJR1FnWkNCa0dHUVlaQmhrR0VNUVF4QkRFRU1RUXhCREVFTVFReEFBQUFBQUFBQUFBR2xJU1RncE9Ba3dDQ2dJS0Vnd1NEQW9NQ2d3Q0NBSUlHZEFaMEJuUUdkQVJ5aEhLRWNvUnlnbktDY29KeWduS0FjWUJ4Z0hHQWNZQUFBQUFHMTRiWGh1Z0U2QUxvQU9nQzU0RG5oT2VDNXdUWEJOY0Exd0RYQnRjRzF3VFdoTmFDMW9MV2dOYUExb2JXaHRhRTFnVFdBdFlDMWdEV0FOWUF4WURGZ01XQXhZVEZoTVdFeFlURmdzV0N4WUxGZ3NXQXhRREZBTVVBeFFiR0JzWUd4Z2JHQk1VRXhRVEZCTVVDeFFMRkFzVUN4UURFZ01TQXhJREVocldHdFlhMWhyV0d0WWExaHJXR3RZUzBoTFNFdElTMGhMU0V0SVMwaExTQ3RJSzBnclNDdElLMGdyU0N0SUswZ0xRQXRBQzBBTFFBdEFDMEFMUUF0QWExQnJVR3RRYTFCclVHdFFhMUJyVUV0QVMwQkxRRXRBUzBCTFFFdEFTMEFyUUN0QUswQXJRQ3RBSzBBclFDdEFDemdMT0FzNEN6Z0xPQXM0Q3pnTE9BQkI0QTBMcmdrR0dFWTRKamdHRUdaSVJqQW1NQVlJSlNnbEtFVW9SU2dsSUNVZ1JTQkZJQ1VZSlJobFFHVkFSUmhGR0NVUUpSQmtPR1E0WkRoa09HUXdaREJrTUdRd1pDaGtLR1FvWkNoa0lHUWdaQ0JrSUdRWVpCaGtHR1FZUkJCRUVFUVFSQkFrQ0NRSUpBZ2tDQVFBQkFBRUFBUUFBQUFLZ0dxQVNvQXFnQXA0YW5oS2VDcDRDbkJxY0Vwd0tuQUthQ2xvS1dnSllBbGdTV2hKYUNsZ0tXQUpXQWxZYVdocGFFbGdTV0FwV0NsWUNWQUpVR2hnYUdCb1lHaGdTRmhJV0VoWVNGZ29VQ2hRS0ZBb1VBaElDRWdJU0FoSWFGaG9XR2hZYUZoSVVFaFFTRkJJVUNoSUtFZ29TQ2hJQ0VBSVFBaEFDRUFIT0FjNEJ6Z0hPQWM0QnpnSE9BYzRCekFITUFjd0J6QUhNQWN3QnpBSE1FZElSMGhIU0VkSVIwaEhTRWRJUjBnSEtBY29CeWdIS0Fjb0J5Z0hLQWNvWjFCblVHZFFaMUJuVUdkUVoxQm5VRWRBUjBCSFFFZEFSMEJIUUVkQVIwQW5RQ2RBSjBBblFDZEFKMEFuUUNkQUJ5QUhJQWNnQnlBSElBY2dCeUFISUFZSUpnZ0FBQVlBQmhBbUVFWVFBQUFHR0NZWVJoaG1HQVlnSmlCR0lHWWdCaWdtS0VZb1ppZ0dNQ1l3UmpCbU1BWTRKamhHT0dZNEJrQW1RRVpBWmtBR1NDWklSa2htU0FaUUpsQkdVR1pRQmxnbVdFWllabGdHWUNaZ1JtQm1ZQVpvSm1oR2FHWm9CbkFtY0Vad1puQUdlQ1o0Um5obWVBYUFKb0JHZ0dhQUFBQkRFQUlBQWdBaENDRUlJUWdoQ0djZ1p5QklJQ2dnUnhoSEdDY1lKeGdHSUFZZ0JpQUdJQVlZQmhnR0dBWVlCaEFHRUFZUUJoQm1HR1lZWmhobUdDWVFKaEFtRUNZUUJnZ0dDQVlJQmdnQUFHVlZSRVEwTkNNakl5TVRFeE1UQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUQ1NmRuSXlMaTRwNmVucDVlWGw1ZUdob2FHaG9hR2huWjJkbloyZG5aMjV0Ykd0cVdsbFpXRWhJU0VkSFIwZEdSa1pHUlVWRlJVUTBORFEwTkRRME16TXpNek16TXpNeU1qSXlNakl5TWpFeE1URXhNVEV4TURBd01EQXdNREE5YTJ4Y1dscFpXVmhJU0VoRlJVVkZSRVJFUkVCQVFFQkhOemMzTnpjM056WTJOalkyTmpZMk16TXpNek16TXpNeU1qSXlNakl5TWpFeE1URXhNVEV4UEZ0YVVGbEpSMGREUTBKQ1NEZzRPRFkyTmpZMU5UVTFORFEwTkRFeE1URTdXVnBLU0VoQ1FrRkJRRUJITnpjM05qWTJOalUxTlRVME5EUTBNek16TXpwZ1lWRllTRWhJU1RrNU9UazVPVGszTnpjM056YzNOelkyTmpZMk5qWTJOVFUxTlRVMU5UVTBORFEwTkRRME5ETXpNek16TXpNek1qSXlNakl5TWpJNVlHRlJWMGRIUjBnNE9EZzRPRGc0TmpZMk5qWTJOalkwTkRRME5EUTBORE16TXpNek16TXpNakl5TWpJeU1qSTFKU1VsSlNVbEpTVWxKU1VsSlNVbEtHQmlVbEZCUVVGSE56YzNOemMzTnpZMk5qWTJOalkyTXpNek16TXpNek0xSlNVbEpTVWxKU1VsSlNVbEpTVWxKQ1FrSkNRa0pDUWtKQ1FrSkNRa0pDRmdaMWRTUWtKQ1JUVTFOVFUxTlRVMkppWW1KaVltSmlZbUppWW1KaVltSkNRa0pDUWtKQ1FrSkNRa0pDUWtKQ01qSXlNakl5TWpJeU1qSXlNakl5TWhVRlpHUWpJeU1qVWxKU1VsSlNVbEpDUWtKQ1FrSkNRakl5TWpJeU1qSXlCQlFqSXpNelUxTkJRVUZCUVVGQlFRUVVRME1pSWlJaU1URXhNVEV4TVRFREV6SXlJU0VoSVFJU0lTRVJBU0lTQVFFeUloSUNRek1pSWhJU0FnSlRRek1qRWhJQ0FoTWpRek5qVXdJQ0FFR2dGd3NrQkFRRkJnY0lDUW9NRFE4UkZCWVpIQ0FrS0MweU9EOUhVRnBsY1grUW9yYkw0di8vQUVIZ0Z3c2tBZ0lDQXdNREF3UUVCQVlHQndjSUNBa0pDZ29MQ3d3TURRME9EZzhQRUJBUkVSSVNBRUhGR0F1RUFRRUFBQUVBQUFFQUFBRUFBUUVBQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUlCQVFJQkFRSUJBUUlCQWdNQkFnTUNBZ01DQWdRQ0F3UUNBd1FEQXdVREJBWURCQVlFQlFjRUJRZ0VCZ2tGQndvR0NBc0dDQTBIQ2c0SUN4QUpEQklLRFJRTER4Y05FUmtBQUFBQUFBQUFBQVVBQUFEL0FBQUFBQUFBQVA4QUFBQUFBQUFBL3dCQjFCa0xGUVVBQUFBQUFBQUFCd0FBQVA4QUFBQUFBQUFBL3dCQjlCa0xGUVVBQUFBRUFBQUFBQUFBQVA4QUFBQUFBQUFBL3dCQmxCb0xCUVVBQUFBRUFFR2tHZ3VsQVFjQUFBQUVBQUFBQWdBQUFBUUFBQUFCQUFBQS93QUFBQUFBQUFEL0FBQUFBQUFBQVA4QUFBQUFBQUFBQkFBQUFBRUFBQUFFQUFBQUF3QUFBUDhBQUFBQUFBQUEvd0FBQUFBQUFBQUVBQUFBQVFBQUFBUUFBQUFFQUFBQS93QUFBQUFBQUFEL0FBQUFBQUFBQUFRQUFBQUJBQUFBQkFBQUFBUUFBQUFFQUFBQUF3QUFBQVFBQUFBR0FBQUFBQUFBQUEwQUFBRC9BQUFBQUFBQUFQOEFBQUFBQUFBQS93QkIxQnNMRlEwQUFBQUFBQUFBRHdBQUFQOEFBQUFBQUFBQS93QkI5QnNMRlEwQUFBQUVBQUFBQ0FBQUFQOEFBQUFBQUFBQS93QkJsQndMdFFzTkFBQUFCQUFBQUFnQUFBQUFBQUFBRHdBQUFBUUFBQUFLQUFBQUJBQUFBQWtBQUFEL0FBQUFBQUFBQVA4QUFBQUFBQUFBL3dBQUFBQUFBQUFFQUFBQUNRQUFBQVFBQUFBTEFBQUEvd0FBQUFBQUFBRC9BQUFBQUFBQUFBUUFBQUFKQUFBQUJBQUFBQXdBQUFEL0FBQUFBQUFBQVA4QUFBQUFBQUFBQkFBQUFBa0FBQUFFQUFBQURBQUFBQVFBQUFBTEFBQUFCQUFBQUE0QUFBQUJBQUFBQ2dBQUFQOEFBQUFBQUFBQS93QUFBQUFBQUFEL0FBQUFBQUFBQUFFQUFBQUtBQUFBQkFBQUFBQUFBQUQvQUFBQUFBQUFBUDhBQUFBQUFBQUFBUUFBQUFvQUFBQUJBQUFBQ3dBQUFQOEFBQUFBQUFBQS93QUFBQUFBQUFBQkFBQUFDZ0FBQUFFQUFBQUxBQUFBQkFBQUFBQUFBQUFFQUFBQUFRQUFBQUVBQUFBT0FBQUEvd0FBQUFBQUFBRC9BQUFBQUFBQUFQOEFBQUFBQUFBQUFRQUFBQTRBQUFBRUFBQUFCQUFBQVA4QUFBQUFBQUFBL3dBQUFBQUFBQUFCQUFBQURnQUFBQUVBQUFBUEFBQUEvd0FBQUFBQUFBRC9BQUFBQUFBQUFBRUFBQUFPQUFBQUFRQUFBQThBQUFBRUFBQUFCQUFBQUFRQUFBQUZBQUFBQkFBQUFBSUFBQUQvQUFBQUFBQUFBUDhBQUFBQUFBQUEvd0FBQUFBQUFBQUVBQUFBQWdBQUFBUUFBQUFJQUFBQS93QUFBQUFBQUFEL0FBQUFBQUFBQUFRQUFBQUNBQUFBQkFBQUFBTUFBQUQvQUFBQUFBQUFBUDhBQUFBQUFBQUFCQUFBQUFJQUFBQUVBQUFBQXdBQUFBUUFBQUFJQUFBQUJBQUFBQWtBQUFBRUFBQUFCZ0FBQVA4QUFBQUFBQUFBL3dBQUFBQUFBQUQvQUFBQUFBQUFBQVFBQUFBR0FBQUFCQUFBQUF3QUFBRC9BQUFBQUFBQUFQOEFBQUFBQUFBQUJBQUFBQVlBQUFBRUFBQUFCd0FBQVA4QUFBQUFBQUFBL3dBQUFBQUFBQUFFQUFBQUJnQUFBQVFBQUFBSEFBQUFCQUFBQUF3QUFBQUVBQUFBRFFBQUFBRUFBQUFPQUFBQS93QUFBQUFBQUFEL0FBQUFBQUFBQVA4QUFBQUFBQUFBQVFBQUFBNEFBQUQvQUFBQUJBQUFBUDhBQUFBQUFBQUEvd0FBQUFBQUFBQUJBQUFBQ3dBQUFBRUFBQUFPQUFBQS93QUFBQUFBQUFEL0FBQUFBQUFBQUFFQUFBQUxBQUFBQVFBQUFBNEFBQUFFQUFBQUFRQUFBUDhBQUFBRUFBQUFBZ0FBQUFvQUFBRC9BQUFBQUFBQUFQOEFBQUFBQUFBQS93QUFBQUFBQUFBQ0FBQUFDZ0FBQVA4QUFBQUFBQUFBL3dBQUFBQUFBQUQvQUFBQUFBQUFBQUVBQUFBUEFBQUFBZ0FBQUFvQUFBRC9BQUFBQUFBQUFQOEFBQUFBQUFBQUFRQUFBQThBQUFBQ0FBQUFDZ0FBQUFRQUFBQUZBQUFBL3dBQUFBQUFBQUFFQUFBQUJnQUFBUDhBQUFBQUFBQUEvd0FBQUFBQUFBRC9BQUFBQUFBQUFBUUFBQUFHQUFBQS93QUFBQXdBQUFEL0FBQUFBQUFBQVA4QUFBQUFBQUFBQkFBQUFBTUFBQUFFQUFBQUJnQUFBUDhBQUFBQUFBQUEvd0FBQUFBQUFBQUVBQUFBQXdBQUFBUUFBQUFHQUFBQUJBQUFBQWtBQUFEL0FBQUFEQUFBQVA4QUFBQUNBQUFBL3dBQUFBQUFBQUQvQUFBQUFBQUFBUDhBQUFBQUFBQUEvd0FBQUFJQUFBRC9BQUFBQ0FBQUFQOEFBQUFBQUFBQS93QUFBQUFBQUFBRUFBQUFCd0FBQVA4QUFBQUNBQUFBL3dBQUFBQUFBQUQvQUFBQUFBQUFBQVFBQUFBSEFBQUEvd0FBQUFJQUFBQUVBQUFBRFFBQUFQOEFBQUFJQUFBQUF3QUFBQThBQUFEL0FBQUFBQUFBQVA4QUFBQUFBQUFBL3dBQUFBQUFBQUFEQUFBQUR3QUFBQUFBQUFBRkFBQUEvd0FBQUFBQUFBRC9BQUFBQUFBQUFBTUFBQUFQQUFBQUFRQUFBQW9BQUFEL0FBQUFBQUFBQVA4QUFBQUFBQUFBQXdBQUFBOEFBQUFCQUFBQUNnQUFBQUFBQUFBRkFBQUFCQUFBQUFBQUFBQUJBQUFBQ3dBQUFQOEFBQUFBQUFBQS93QUFBQUFBQUFEL0FBQUFBQUFBQUFFQUFBQUxBQUFBQkFBQUFBRUFBQUQvQUFBQUFBQUFBUDhBQUFBQUFBQUFBUUFBQUFzQUFBQUJBQUFBRGdBQUFQOEFBQUFBQUFBQS93QUFBQUFBQUFBQkFBQUFDd0FBQUFFQUFBQU9BQUFBQkFBQUFBRUFBQUFFQUFBQUJBQUFBQUFBQUFBSEFBQUEvd0FBQUFBQUFBRC9BQUFBQUFBQUFQOEFRZFFuQ3hVSEFBQUFBQUFBQUEwQUFBRC9BQUFBQUFBQUFQOEFRZlFuQ3hVSEFBQUFCQUFBQUFJQUFBRC9BQUFBQUFBQUFQOEFRWlFvQzlrQkJ3QUFBQVFBQUFBQ0FBQUFBQUFBQUEwQUFBQUVBQUFBQ0FBQUFBUUFBQUFEQUFBQS93QUFBQUFBQUFEL0FBQUFBQUFBQVA4QUFBQUFBQUFBQkFBQUFBTUFBQUFFQUFBQUNRQUFBUDhBQUFBQUFBQUEvd0FBQUFBQUFBQUVBQUFBQXdBQUFBUUFBQUFHQUFBQS93QUFBQUFBQUFEL0FBQUFBQUFBQUFRQUFBQURBQUFBQkFBQUFBWUFBQUFFQUFBQUNRQUFBQVFBQUFBTUFBQUFBQUFBQUFRQUFBQUFBQUFBQkFBQUFBZ0FBQUFNQUFBQUNBQUFBQXdBQUFBQUFBQUFCQUFBQUFBQUFBQUVBQUFBQ0FBQUFBd0FBQUFJQUFBQURBQkIrQ2tMQlFRQUFBQUVBRUdJS2dzbEJBQUFBQVFBQUFBSUFBQUFDQUFBQUF3QUFBQU1BQUFBQ0FBQUFBZ0FBQUFNQUFBQURBQkJzUzRMeUFZQkFnTUVCUVlIQ0FrS0N3d05EZzhRRVJJVEZCVVdGeGdaR2hzY0hSNGZJQ0VpSXlRbEppY29LU29yTEMwdUx6QXhNak0wTlRZM09EazZPenc5UGo5QVFVSkRSRVZHUjBoSlNrdE1UVTVQVUZGU1UxUlZWbGRZV1ZwYlhGMWVYMkJoWW1Oa1pXWm5hR2xxYTJ4dGJtOXdjWEp6ZEhWMmQzaDVlbnQ4Zlg1L2dJR0NnNFNGaG9lSWlZcUxqSTJPajVDUmtwT1VsWmFYbUptYW01eWRucCtnb2FLanBLV21wNmlwcXF1c3JhNnZzTEd5czdTMXRyZTR1YnE3dkwyK3Y4REJ3c1BFeGNiSHlNbkt5OHpOenMvUTBkTFQxTlhXMTlqWjJ0dmMzZDdmNE9IaTQrVGw1dWZvNmVycjdPM3U3L0R4OHZQMDlmYjMrUG42Ky96OS92Ly8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy93QUFBQUFCQUFBQUJBQUFBQVVBQUFBQ0FBQUFBd0FBQUFZQUFBQUhBQUFBQ0FBQUFBa0FBQUFNQUFBQURRQUFBQW9BQUFBTEFBQUFEZ0FBQUE4QUFBQUFBQUFBQVFBQUFBRUFRWVExQ3lFQkFBQUFBUUFBQUFFQUFBQUJBQUFBQWdBQUFBSUFBQUFCQUFBQUFnQUFBQUlBUWJRMUN3VUZBQUFBQkFCQnhEVUx5UVlIQUFBQUJBQUFBQUlBQUFBRUFBQUFBUUFBQUFRQUFBQUVBQUFBQkFBQUFBTUFBQUFFQUFBQUJnQUFBQUFBQUFBTkFBQUFCQUFBQUFnQUFBQUFBQUFBRHdBQUFBUUFBQUFLQUFBQUJBQUFBQWtBQUFBRUFBQUFEQUFBQUFRQUFBQUxBQUFBQkFBQUFBNEFBQUFBQUFBQUVRQUFBQVFBQUFBUUFBQUFBQUFBQUJNQUFBQUVBQUFBRWdBQUFBQUFBQUFWQUFBQUJBQUFBQlFBQUFBQUFBQUFGd0FBQUFRQUFBQVdBQUFBQVFBQUFBb0FBQUFCQUFBQUN3QUFBQVFBQUFBQUFBQUFCQUFBQUFFQUFBQUJBQUFBRGdBQUFBRUFBQUFQQUFBQUJBQUFBQVFBQUFBRUFBQUFCUUFBQUFRQUFBQUNBQUFBQkFBQUFBTUFBQUFFQUFBQUNBQUFBQVFBQUFBSkFBQUFCQUFBQUFZQUFBQUVBQUFBQndBQUFBUUFBQUFNQUFBQUJBQUFBQTBBQUFBQkFBQUFFZ0FBQUFFQUFBQVRBQUFBQkFBQUFCQUFBQUFFQUFBQUVRQUFBQUVBQUFBV0FBQUFBUUFBQUJjQUFBQUVBQUFBRkFBQUFBUUFBQUFWQUFBQUFRQUFBQXNBQUFBQkFBQUFEZ0FBQUFRQUFBQUJBQUFBL3dBQUFBUUFBQUFCQUFBQUR3QUFBQUlBQUFBS0FBQUFCQUFBQUFVQUFBRC9BQUFBQUFBQUFBUUFBQUFEQUFBQUJBQUFBQVlBQUFBRUFBQUFDUUFBQVA4QUFBQU1BQUFBQkFBQUFBY0FBQUQvQUFBQUFnQUFBQVFBQUFBTkFBQUEvd0FBQUFnQUFBQUJBQUFBRXdBQUFBSUFBQUFTQUFBQUJBQUFBQkVBQUFEL0FBQUFFQUFBQUFFQUFBQVhBQUFBQWdBQUFCWUFBQUFFQUFBQUZRQUFBUDhBQUFBVUFBQUFBd0FBQUE4QUFBQUJBQUFBQ2dBQUFBQUFBQUFGQUFBQUJBQUFBQUFBQUFBQkFBQUFDd0FBQUFFQUFBQU9BQUFBQkFBQUFBRUFBQUFFQUFBQUJBQUFBQUFBQUFBSEFBQUFCQUFBQUFJQUFBQUFBQUFBRFFBQUFBUUFBQUFJQUFBQUJBQUFBQU1BQUFBRUFBQUFCZ0FBQUFRQUFBQUpBQUFBQkFBQUFBd0FBQUFEQUFBQUV3QUFBQUVBQUFBU0FBQUFBQUFBQUJFQUFBQUVBQUFBRUFBQUFBTUFBQUFYQUFBQUFRQUFBQllBQUFBQUFBQUFGUUFBQUFRQUFBQVVBQUFBQVFBQUFBRUFBQUFDQUFBQUFnQUFBQU1BQUFBREFBQUFBd0FBQUFNQUFBQUFBQUFBQVFBQUFBSUFBQUFEQUFBQUJBQUFBQVVBQUFBR0FBQUFCd0FBQUFnQUFBQUpBQUFBQ2dBQUFBc0FBQUFNQUFBQURRQUFBQTRBQUFBUEFFR1dQQXN1QVFFQkFRRUJBZ0lDQWdJQ0F3TURBd01EQkFRRUJBUUVCUVVGQlFVRkJnWUdCZ1lHQndjSEJ3Y0hDQWdJQ0FCQjBEd0xSUW9BQUFBTkFBQUFFQUFBQUFzQUFBQU9BQUFBRWdBQUFBMEFBQUFRQUFBQUZBQUFBQTRBQUFBU0FBQUFGd0FBQUJBQUFBQVVBQUFBR1FBQUFCSUFBQUFYQUFBQUhRQkJvVDBMTXdFQ0F3UUZBQUVDQXdRRkFBRUNBd1FGQUFFQ0F3UUZBQUVDQXdRRkFBRUNBd1FGQUFFQ0F3UUZBQUVDQXdRRkFBRUNBd0JCNUQwTHpBSUJBQUFBQWdBQUFBTUFBQUFFQUFBQUJRQUFBQVlBQUFBSEFBQUFDQUFBQUFrQUFBQUtBQUFBQ3dBQUFBd0FBQUFOQUFBQURnQUFBQThBQUFBUUFBQUFFUUFBQUJJQUFBQVRBQUFBRkFBQUFCVUFBQUFXQUFBQUZ3QUFBQmdBQUFBWkFBQUFHZ0FBQUJzQUFBQWNBQUFBSFFBQUFCMEFBQUFlQUFBQUh3QUFBQ0FBQUFBZ0FBQUFJUUFBQUNJQUFBQWlBQUFBSXdBQUFDTUFBQUFrQUFBQUpBQUFBQ1VBQUFBbEFBQUFKUUFBQUNZQUFBQW1BQUFBSmdBQUFDY0FBQUFuQUFBQUp3QUFBQ2NBQUFBQkFBQUFBZ0FBQUFRQUFBQUlBQUFBRUFBQUFDQUFBQUJBQUFBQWdBQUFBQzhmRHdBWEd4MGVCd3NORGljckxTNFFBd1VLREJNVkdod2pKU29zQVFJRUNCRVNGQmdHQ1JZWklDRWlKQ2dtS1FBUUFRSUVDQ0FEQlFvTUR5OEhDdzBPQmdrZkl5VXFMQ0VpSkNnbkt5MHVFUklVR0JNVkdod1hHeDBlRmhrbUtRPT1cIn0sRD17fTtmdW5jdGlvbiBvKCl7dmFyIEEsST1FKCkoe2xvY2F0ZUZpbGU6ZnVuY3Rpb24oQSl7cmV0dXJuIGlbQV19fSk7cmV0dXJuKEE9SSxuZXcgUHJvbWlzZSgoZnVuY3Rpb24oSSl7QS5jYWxsZWRSdW4/SSgpOkEub25SdW50aW1lSW5pdGlhbGl6ZWQ9ZnVuY3Rpb24oKXtyZXR1cm4gSSgpfX0pKSkudGhlbigoZnVuY3Rpb24oKXtzZWxmLmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsKGZ1bmN0aW9uKEEpe3ZhciBnPUEuZGF0YSxCPWcucmVuZGVyU3RhdGVJZDtzd2l0Y2goZy50eXBlKXtjYXNlXCJkZWNvZGVcIjp2YXIgQz1EW0JdO0N8fChDPW5ldyBRKEksKGZ1bmN0aW9uKEEsSSxnKXtwb3N0TWVzc2FnZSh7dHlwZTpcInBpY3R1cmVSZWFkeVwiLHdpZHRoOkksaGVpZ2h0OmcscmVuZGVyU3RhdGVJZDpCLGRhdGE6QS5idWZmZXJ9LFtBLmJ1ZmZlcl0pfSkpLERbQl09QyksQy5kZWNvZGUobmV3IFVpbnQ4QXJyYXkoZy5kYXRhLGcub2Zmc2V0LGcubGVuZ3RoKSk7YnJlYWs7Y2FzZVwicmVsZWFzZVwiOnZhciBFPURbQl07RSYmKEUucmVsZWFzZSgpLGRlbGV0ZSBEW0JdKX19KSksc2VsZi5wb3N0TWVzc2FnZSh7dHlwZTpcImRlY29kZXJSZWFkeVwifSl9KSl9fX0sST17fTtmdW5jdGlvbiBnKEIpe3ZhciBRPUlbQl07aWYodm9pZCAwIT09USlyZXR1cm4gUS5leHBvcnRzO3ZhciBDPUlbQl09e2V4cG9ydHM6e319O3JldHVybiBBW0JdKEMsQy5leHBvcnRzLGcpLEMuZXhwb3J0c31nLm49QT0+e3ZhciBJPUEmJkEuX19lc01vZHVsZT8oKT0+QS5kZWZhdWx0OigpPT5BO3JldHVybiBnLmQoSSx7YTpJfSksSX0sZy5kPShBLEkpPT57Zm9yKHZhciBCIGluIEkpZy5vKEksQikmJiFnLm8oQSxCKSYmT2JqZWN0LmRlZmluZVByb3BlcnR5KEEsQix7ZW51bWVyYWJsZTohMCxnZXQ6SVtCXX0pfSxnLm89KEEsSSk9Pk9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChBLEkpLGcucj1BPT57XCJ1bmRlZmluZWRcIiE9dHlwZW9mIFN5bWJvbCYmU3ltYm9sLnRvU3RyaW5nVGFnJiZPYmplY3QuZGVmaW5lUHJvcGVydHkoQSxTeW1ib2wudG9TdHJpbmdUYWcse3ZhbHVlOlwiTW9kdWxlXCJ9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkoQSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KX0sKCgpPT57XCJ1c2Ugc3RyaWN0XCI7ZygzNDApLmluaXQoKX0pKCl9KSgpOycsXCJXb3JrZXJcIix2b2lkIDAsdm9pZCAwKX19LDYxNDpBPT57QS5leHBvcnRzPWZ1bmN0aW9uKEEsSSxnLEIpe3ZhciBRPXNlbGZ8fHdpbmRvdzt0cnl7dHJ5e3ZhciBDO3RyeXtDPW5ldyBRLkJsb2IoW0FdKX1jYXRjaChJKXsoQz1uZXcoUS5CbG9iQnVpbGRlcnx8US5XZWJLaXRCbG9iQnVpbGRlcnx8US5Nb3pCbG9iQnVpbGRlcnx8US5NU0Jsb2JCdWlsZGVyKSkuYXBwZW5kKEEpLEM9Qy5nZXRCbG9iKCl9dmFyIGU9US5VUkx8fFEud2Via2l0VVJMLGk9ZS5jcmVhdGVPYmplY3RVUkwoQyksdD1uZXcgUVtJXShpLGcpO3JldHVybiBlLnJldm9rZU9iamVjdFVSTChpKSx0fWNhdGNoKEIpe3JldHVybiBuZXcgUVtJXShcImRhdGE6YXBwbGljYXRpb24vamF2YXNjcmlwdCxcIi5jb25jYXQoZW5jb2RlVVJJQ29tcG9uZW50KEEpKSxnKX19Y2F0Y2goQSl7aWYoIUIpdGhyb3cgRXJyb3IoXCJJbmxpbmUgd29ya2VyIGlzIG5vdCBzdXBwb3J0ZWRcIik7cmV0dXJuIG5ldyBRW0ldKEIsZyl9fX19LEk9e307ZnVuY3Rpb24gZyhCKXt2YXIgUT1JW0JdO2lmKHZvaWQgMCE9PVEpcmV0dXJuIFEuZXhwb3J0czt2YXIgQz1JW0JdPXtleHBvcnRzOnt9fTtyZXR1cm4gQVtCXS5jYWxsKEMuZXhwb3J0cyxDLEMuZXhwb3J0cyxnKSxDLmV4cG9ydHN9cmV0dXJuIGcubj1BPT57dmFyIEk9QSYmQS5fX2VzTW9kdWxlPygpPT5BLmRlZmF1bHQ6KCk9PkE7cmV0dXJuIGcuZChJLHthOkl9KSxJfSxnLmQ9KEEsSSk9Pntmb3IodmFyIEIgaW4gSSlnLm8oSSxCKSYmIWcubyhBLEIpJiZPYmplY3QuZGVmaW5lUHJvcGVydHkoQSxCLHtlbnVtZXJhYmxlOiEwLGdldDpJW0JdfSl9LGcubz0oQSxJKT0+T2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKEEsSSksZy5yPUE9PntcInVuZGVmaW5lZFwiIT10eXBlb2YgU3ltYm9sJiZTeW1ib2wudG9TdHJpbmdUYWcmJk9iamVjdC5kZWZpbmVQcm9wZXJ0eShBLFN5bWJvbC50b1N0cmluZ1RhZyx7dmFsdWU6XCJNb2R1bGVcIn0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pfSxnKDExNCl9KSgpKTtjbGFzcyB0Z3tjb25zdHJ1Y3RvcihBLEksZyl7dGhpcy5nbEN0eD12b2lkIDAsdGhpcy5wcm9ncmFtPXZvaWQgMCx0aGlzLmdsQ3R4PUEsdGhpcy5wcm9ncmFtPXRoaXMuZ2xDdHguY3JlYXRlUHJvZ3JhbSgpLHRoaXMuZ2xDdHguYXR0YWNoU2hhZGVyKHRoaXMucHJvZ3JhbSxJKSx0aGlzLmdsQ3R4LmF0dGFjaFNoYWRlcih0aGlzLnByb2dyYW0sZyksdGhpcy5nbEN0eC5saW5rUHJvZ3JhbSh0aGlzLnByb2dyYW0pLHRoaXMuZ2xDdHguZ2V0UHJvZ3JhbVBhcmFtZXRlcih0aGlzLnByb2dyYW0sdGhpcy5nbEN0eC5MSU5LX1NUQVRVUyl8fElJKHRnLm5hbWUsXCJTaGFkZXIgbGluayBmYWlsZWQuXCIpfXN0YXRpYyBjb21waWxlKEEsSSxnKXtsZXQgQjtCPVwidmVydGV4XCI9PT1JP0EuY3JlYXRlU2hhZGVyKEEuVkVSVEVYX1NIQURFUik6QS5jcmVhdGVTaGFkZXIoQS5GUkFHTUVOVF9TSEFERVIpLEEuc2hhZGVyU291cmNlKEIsZyksQS5jb21waWxlU2hhZGVyKEIpO3JldHVybiAwPT1BLmdldFNoYWRlclBhcmFtZXRlcihCLEEuQ09NUElMRV9TVEFUVVMpJiZJSSh0Zy5uYW1lLFwiU2hhZGVyIGNvbXBpbGUgZmFpbGVkLCBsb2c6IFwiK0EuZ2V0U2hhZGVySW5mb0xvZyhCKSksQn1zdGF0aWMgY3JlYXRlKEEsSSxnKXtjb25zdCBCPXRnLmNvbXBpbGUoQSxcInZlcnRleFwiLEkpLFE9dGcuY29tcGlsZShBLFwiZnJhZ21lbnRcIixnKTtyZXR1cm4gbmV3IHRnKEEsQixRKX11c2UoKXt0aGlzLmdsQ3R4LnVzZVByb2dyYW0odGhpcy5wcm9ncmFtKX1nZXRBdHRyaWJ1dGVMb2NhdGlvbihBKXtyZXR1cm4gdGhpcy5nbEN0eC5nZXRBdHRyaWJMb2NhdGlvbih0aGlzLnByb2dyYW0sQSl9Z2V0VW5pZm9ybUxvY2F0aW9uKEEpe2NvbnN0IEk9dGhpcy5nbEN0eC5nZXRVbmlmb3JtTG9jYXRpb24odGhpcy5wcm9ncmFtLEEpO2lmKEkpcmV0dXJuIEl9c2V0TWF0cml4VW5pZm9ybShBLEkpe3RoaXMuZ2xDdHgudW5pZm9ybU1hdHJpeDRmdihBLCExLEkpfX1jbGFzcyBFZ3tjb25zdHJ1Y3RvcihBLEksZyxCLFEsQyxlLGksdCl7dGhpcy5nbEN0eD1BLHRoaXMucHJvZ3JhbT1JLHRoaXMucHJvamVjdGlvbk10eExvYz1nLHRoaXMucG9zaXRpb25BdHRyPUIsdGhpcy50ZXhDb29yZEF0dHI9USx0aGlzLnZlcnRleEJ1ZmZlcj1DLHRoaXMueVRleHR1cmVMb2M9ZSx0aGlzLnVUZXh0dXJlTG9jPWksdGhpcy52VGV4dHVyZUxvYz10fXN0YXRpYyBjcmVhdGUoQSl7Y29uc3QgST10Zy5jcmVhdGUoQSxcIlxcbiAgICBwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcXG5cXG4gICAgdW5pZm9ybSBtYXQ0IHVQcm9qZWN0aW9uO1xcbiAgICBhdHRyaWJ1dGUgdmVjMiBhUG9zaXRpb247XFxuICAgIGF0dHJpYnV0ZSB2ZWMyIGFUZXhDb29yZDtcXG5cXG4gICAgdmFyeWluZyB2ZWMyIHZUZXhDb29yZDtcXG4gICAgdm9pZCBtYWluKCl7XFxuICAgICAgICB2VGV4Q29vcmQgPSBhVGV4Q29vcmQ7XFxuICAgICAgICBnbF9Qb3NpdGlvbiA9IHVQcm9qZWN0aW9uICogdmVjNChhUG9zaXRpb24sIDAuMCwgMS4wKTtcXG4gICAgfVxcblwiLFwiXFxuICAgIHByZWNpc2lvbiBsb3dwIGZsb2F0O1xcblxcbiAgICB2YXJ5aW5nIHZlYzIgdlRleENvb3JkO1xcblxcbiAgICB1bmlmb3JtIHNhbXBsZXIyRCB5VGV4dHVyZTtcXG4gICAgdW5pZm9ybSBzYW1wbGVyMkQgdVRleHR1cmU7XFxuICAgIHVuaWZvcm0gc2FtcGxlcjJEIHZUZXh0dXJlO1xcbiAgICBjb25zdCBtYXQzIGNvbnZlcnNpb24gPSBtYXQzKFxcbiAgICAgICAgMS4xNjQsIDAuMDAwLCAgMS41OTYsXFxuICAgICAgICAxLjE2NCwgLTAuMzkxLCAtMC44MTMsXFxuICAgICAgICAxLjE2NCwgMi4wMTgsICAwLjAwMFxcbiAgICApO1xcblxcbiAgICBjb25zdCB2ZWMzIG9mZnNldCA9IHZlYzMoMC4wNjI1LCAwLjUsIDAuNSk7XFxuXFxuICAgIHZvaWQgbWFpbih2b2lkKSB7XFxuICAgICAgICBmbG9hdCB5ID0gdGV4dHVyZTJEKHlUZXh0dXJlLCB2VGV4Q29vcmQpLng7XFxuICAgICAgICBmbG9hdCB1ID0gdGV4dHVyZTJEKHVUZXh0dXJlLCB2VGV4Q29vcmQpLng7XFxuICAgICAgICBmbG9hdCB2ID0gdGV4dHVyZTJEKHZUZXh0dXJlLCB2VGV4Q29vcmQpLng7XFxuICAgICAgICB2ZWMzIHl1diA9IHZlYzMoeSwgdSwgdikgLSBvZmZzZXQ7XFxuXFxuICAgICAgICB2ZWMzIHJnYiA9ICh5dXYgKiBjb252ZXJzaW9uKTtcXG5cXG4gICAgICAgIGdsX0ZyYWdDb2xvciA9IHZlYzQocmdiLCAxLjApO1xcbiAgICB9XFxuXCIpO0kudXNlKCk7Y29uc3QgZz1JLmdldFVuaWZvcm1Mb2NhdGlvbihcInVQcm9qZWN0aW9uXCIpLEI9SS5nZXRBdHRyaWJ1dGVMb2NhdGlvbihcImFQb3NpdGlvblwiKTtBLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KEIpO2NvbnN0IFE9SS5nZXRBdHRyaWJ1dGVMb2NhdGlvbihcImFUZXhDb29yZFwiKTtBLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KFEpO2NvbnN0IEM9QS5jcmVhdGVCdWZmZXIoKSxlPUkuZ2V0VW5pZm9ybUxvY2F0aW9uKFwieVRleHR1cmVcIiksaT1JLmdldFVuaWZvcm1Mb2NhdGlvbihcInVUZXh0dXJlXCIpLHQ9SS5nZXRVbmlmb3JtTG9jYXRpb24oXCJ2VGV4dHVyZVwiKTtyZXR1cm4gbmV3IEVnKEEsSSxnLEIsUSxDLGUsaSx0KX1iaW5kSW5wdXRUZXh0dXJlcyhBLEksZyl7Y29uc3QgQj10aGlzLmdsQ3R4O0IudW5pZm9ybTFpKHRoaXMueVRleHR1cmVMb2MsMCksQi5hY3RpdmVUZXh0dXJlKEIuVEVYVFVSRTApLEIuYmluZFRleHR1cmUoQi5URVhUVVJFXzJELEEudGV4dHVyZUlkKSxCLnVuaWZvcm0xaSh0aGlzLnVUZXh0dXJlTG9jLDEpLEIuYWN0aXZlVGV4dHVyZShCLlRFWFRVUkUxKSxCLmJpbmRUZXh0dXJlKEIuVEVYVFVSRV8yRCxJLnRleHR1cmVJZCksQi51bmlmb3JtMWkodGhpcy52VGV4dHVyZUxvYywyKSxCLmFjdGl2ZVRleHR1cmUoQi5URVhUVVJFMiksQi5iaW5kVGV4dHVyZShCLlRFWFRVUkVfMkQsZy50ZXh0dXJlSWQpfXVzZSgpe3RoaXMucHJvZ3JhbS51c2UoKX1kcm9wKCl7dGhpcy5nbEN0eC51c2VQcm9ncmFtKDApfXVwZGF0ZShBLEksZyxCKXt0aGlzLmdsQ3R4LnZpZXdwb3J0KDAsMCxBLEkpLHRoaXMucHJvZ3JhbS5zZXRNYXRyaXhVbmlmb3JtKHRoaXMucHJvamVjdGlvbk10eExvYyxbMi9BLDAsMCwwLDAsMi8tSSwwLDAsMCwwLDEsMCwtMSwxLDAsMV0pLHRoaXMuZ2xDdHguYmluZEJ1ZmZlcih0aGlzLmdsQ3R4LkFSUkFZX0JVRkZFUix0aGlzLnZlcnRleEJ1ZmZlciksdGhpcy5nbEN0eC5idWZmZXJEYXRhKHRoaXMuZ2xDdHguQVJSQVlfQlVGRkVSLG5ldyBGbG9hdDMyQXJyYXkoWzAsMCwwLDAsQSwwLGcsMCxBLEksZyxCLEEsSSxnLEIsMCxJLDAsQiwwLDAsMCwwXSksdGhpcy5nbEN0eC5EWU5BTUlDX0RSQVcpLHRoaXMuZ2xDdHgudmVydGV4QXR0cmliUG9pbnRlcih0aGlzLnBvc2l0aW9uQXR0ciwyLHRoaXMuZ2xDdHguRkxPQVQsITEsMTYsMCksdGhpcy5nbEN0eC52ZXJ0ZXhBdHRyaWJQb2ludGVyKHRoaXMudGV4Q29vcmRBdHRyLDIsdGhpcy5nbEN0eC5GTE9BVCwhMSwxNiw4KX1kcmF3KCl7Y29uc3QgQT10aGlzLmdsQ3R4O0EuY2xlYXIoQS5DT0xPUl9CVUZGRVJfQklUfEEuREVQVEhfQlVGRkVSX0JJVHxBLlNURU5DSUxfQlVGRkVSX0JJVCksQS5kcmF3QXJyYXlzKEEuVFJJQU5HTEVfU1RSSVAsMCw2KSxBLmJpbmRUZXh0dXJlKEEuVEVYVFVSRV8yRCxudWxsKX19Y2xhc3Mgb2d7Y29uc3RydWN0b3IoQSxJKXt0aGlzLmdsQ3R4PXZvaWQgMCx0aGlzLnRleHR1cmVJZD12b2lkIDAsdGhpcy5nbEN0eD1BLHRoaXMudGV4dHVyZUlkPUl9c3RhdGljIGNyZWF0ZShBKXtjb25zdCBJPUEuY3JlYXRlVGV4dHVyZSgpO3JldHVybiBBLmJpbmRUZXh0dXJlKEEuVEVYVFVSRV8yRCxJKSxBLnRleFBhcmFtZXRlcmkoQS5URVhUVVJFXzJELEEuVEVYVFVSRV9NQUdfRklMVEVSLEEuTkVBUkVTVCksQS50ZXhQYXJhbWV0ZXJpKEEuVEVYVFVSRV8yRCxBLlRFWFRVUkVfTUlOX0ZJTFRFUixBLk5FQVJFU1QpLEEudGV4UGFyYW1ldGVyaShBLlRFWFRVUkVfMkQsQS5URVhUVVJFX1dSQVBfUyxBLkNMQU1QX1RPX0VER0UpLEEudGV4UGFyYW1ldGVyaShBLlRFWFRVUkVfMkQsQS5URVhUVVJFX1dSQVBfVCxBLkNMQU1QX1RPX0VER0UpLEEuYmluZFRleHR1cmUoQS5URVhUVVJFXzJELG51bGwpLG5ldyBvZyhBLEkpfXVwbG9hZEJ1ZmZlcihBLEksZyl7Y29uc3QgQj10aGlzLmdsQ3R4O0IuYmluZFRleHR1cmUoQi5URVhUVVJFXzJELHRoaXMudGV4dHVyZUlkKSxCLnRleEltYWdlMkQoQi5URVhUVVJFXzJELDAsQi5MVU1JTkFOQ0UsSSxnLDAsQi5MVU1JTkFOQ0UsQi5VTlNJR05FRF9CWVRFLEEpLEIuYmluZFRleHR1cmUoQi5URVhUVVJFXzJELG51bGwpfWRlbGV0ZSgpe251bGwhPXRoaXMuZ2xDdHgmJjAhPXRoaXMudGV4dHVyZUlkJiYodGhpcy5nbEN0eC5kZWxldGVUZXh0dXJlKHRoaXMudGV4dHVyZUlkKSx0aGlzLnRleHR1cmVJZD0wKX19Y2xhc3MgYWd7Y29uc3RydWN0b3IoQSxJKXt0aGlzLmNvZGVjU3RyaW5nPUEsdGhpcy5mb3JtYXQ9SSx0aGlzLnJlYWR5U3RhdGU9TkkuRGV0YWNoZWQsdGhpcy5uZWVkc1Jlc3RhcnRFdmVudD1uZXcgX0EsdGhpcy5yZWFkeVN0YXRlQ2hhbmdlRXZlbnQ9bmV3IF9BLHRoaXMudmlkZW9GcmFtZVByb2Nlc3NpbmdEdXJhdGlvbkV2ZW50PW5ldyBfQSx0aGlzLnZpZGVvRnJhbWVFdmVudD1uZXcgX0EsdGhpcy5jdXJyZW50RnJhbWVJbmZvPXtjb250YWluc1NQUzohMSxjb250YWluc1BQUzohMSxjb250YWluc0ZyYW1lRGF0YTohMH0sdGhpcy5wYXVzZWQ9ITEsdGhpcy5zdGF0cz1uZXcgWkksdGhpcy50b3RhbEZyYW1lcz0wLHRoaXMud2FpdGluZ1RvRGVjb2RlUXVldWU9W10sdGhpcy5kZWNvZGVRdWV1ZT1bXSx0aGlzLm1heERlY29kZVF1ZXVlU2l6ZT0zLHRoaXMubWF4TGF0ZW5jeUZyYW1lQ291bnQ9Nyx0aGlzLm1heENvbnNlY3V0aXZlRnJhbWVzRHJvcHM9Myx0aGlzLmZyYW1lc0Ryb3BwZWRTaW5jZUxhc3RSZW5kZXI9MCx0aGlzLnRvdGFsRnJhbWVzRHJvcHBlZD0wLHRoaXMuY2FudmFzPXZvaWQgMCx0aGlzLnNoYWRlcj12b2lkIDAsdGhpcy55VGV4dHVyZT12b2lkIDAsdGhpcy51VGV4dHVyZT12b2lkIDAsdGhpcy52VGV4dHVyZT12b2lkIDAsdGhpcy5vbkRlY29kZT0oe3dpZHRoOkEsaGVpZ2h0OkksZGF0YTpnfSk9PntpZigwPT10aGlzLmRlY29kZVF1ZXVlLmxlbmd0aClyZXR1cm4gSUkoYWcubmFtZSxcIm9uRGVjb2RlIGNhbGxlZCB3aXRoIGVtcHR5IGRlY29kZXIgcXVldWUhXCIpLHZvaWQgdGhpcy5zZW5kRGVjb2RlcldhaXRpbmdUb0RlY29kZUZyYW1lcygpOysrdGhpcy50b3RhbEZyYW1lcztjb25zdCBCPXRoaXMuZGVjb2RlUXVldWUuc2hpZnQoKTtpZighdGhpcy5wYXVzZWQpe2NvbnN0IFE9RGF0ZS5ub3coKTtpZihCLnByb2Nlc3NpbmdEdXJhdGlvbj0oUS1CLm1lZGlhVGltZSkvMWUzLHRoaXMudmlkZW9GcmFtZVByb2Nlc3NpbmdEdXJhdGlvbkV2ZW50Lmludm9rZShCLnByb2Nlc3NpbmdEdXJhdGlvbiksdGhpcy5kYXRhUXVldWVMZW5ndGg+dGhpcy5tYXhMYXRlbmN5RnJhbWVDb3VudCYmdGhpcy5mcmFtZXNEcm9wcGVkU2luY2VMYXN0UmVuZGVyPHRoaXMubWF4Q29uc2VjdXRpdmVGcmFtZXNEcm9wcykrK3RoaXMuZnJhbWVzRHJvcHBlZFNpbmNlTGFzdFJlbmRlciwrK3RoaXMudG90YWxGcmFtZXNEcm9wcGVkO2Vsc2V7dGhpcy5mcmFtZXNEcm9wcGVkU2luY2VMYXN0UmVuZGVyPTA7Y29uc3QgUT1CLndpZHRoLEM9Qi5oZWlnaHQ7Qi53aWR0aD1BLEIuaGVpZ2h0PUksdGhpcy5zdGF0cy5wdXNoRnJhbWVNZXRhZGF0YShCKSx0aGlzLnJlbmRlckZyYW1lKFEsQyxnLEEsSSksdGhpcy52aWRlb0ZyYW1lRXZlbnQuaW52b2tlKFtwZXJmb3JtYW5jZS5ub3coKSxCXSl9fXRoaXMuc2VuZERlY29kZXJXYWl0aW5nVG9EZWNvZGVGcmFtZXMoKX0sdGhpcy5lbnN1cmVCdWZmZXI9KCk9Pnt0aGlzLnJlYWR5U3RhdGU9PT1OSS5XYWl0aW5nRm9yS2V5ZnJhbWUmJjA9PT10aGlzLmRhdGFRdWV1ZUxlbmd0aCYmKFFJKGFnLm5hbWUsXCJTZW5kaW5nIGFub3RoZXIgcmVxdWVzdCBmb3IgYSBrZXlmcmFtZS5cIiksdGhpcy5yZXN0YXJ0KCkpfSx0aGlzLnZpZGVvRm9ybWF0PUksdGhpcy5kZWNvZGVyV29ya2VyPW5ldyBpZyx0aGlzLmRlY29kZXJXb3JrZXIuaW5pdGlhbGl6ZSgpLHRoaXMuZGVjb2Rlcldvcmtlci5vbkRlY29kZT10aGlzLm9uRGVjb2RlLmJpbmQodGhpcyksdGhpcy5lbnN1cmVCdWZmZXJJbnRlcnZhbD13aW5kb3cuc2V0SW50ZXJ2YWwodGhpcy5lbnN1cmVCdWZmZXIsMWUzKX1nZXQgZGF0YVF1ZXVlTGVuZ3RoKCl7cmV0dXJuIHRoaXMud2FpdGluZ1RvRGVjb2RlUXVldWUubGVuZ3RoK3RoaXMuZGVjb2RlUXVldWUubGVuZ3RofWNvbmZpZ3VyZShBLEksZyl7dGhpcy5tYXhEZWNvZGVRdWV1ZVNpemU9QSx0aGlzLm1heExhdGVuY3lGcmFtZUNvdW50PUksdGhpcy5tYXhDb25zZWN1dGl2ZUZyYW1lc0Ryb3BzPWd9YXR0YWNoVG9FbGVtZW50KEEpe3RoaXMuc3RhdHMucmVzZXRGcmFtZUNvdW50cygpLHRoaXMucmVhZHlTdGF0ZSE9TkkuV2FpdGluZ0ZvcktleWZyYW1lJiZ0aGlzLnJlc3RhcnQoKX1hdHRhY2hUb0NhbnZhcyhBKXt0aGlzLnJlYWR5U3RhdGUhPU5JLldhaXRpbmdGb3JLZXlmcmFtZSYmdGhpcy5yZXN0YXJ0KCksdGhpcy5jYW52YXMmJnRoaXMuZGV0YWNoRnJvbUNhbnZhcygpLHRoaXMuY2FudmFzPUE7Y29uc3QgST1BLmdldENvbnRleHQoXCJ3ZWJnbFwiKTt0aGlzLnNoYWRlcj1FZy5jcmVhdGUoSSksdGhpcy55VGV4dHVyZT1vZy5jcmVhdGUoSSksdGhpcy51VGV4dHVyZT1vZy5jcmVhdGUoSSksdGhpcy52VGV4dHVyZT1vZy5jcmVhdGUoSSl9ZGV0YWNoRnJvbUVsZW1lbnQoKXt0aGlzLnNldFJlYWR5U3RhdGUoTkkuRGV0YWNoZWQpfWRldGFjaEZyb21DYW52YXMoKXt0aGlzLmRlY29kZXJXb3JrZXIucmVsZWFzZSgpLHRoaXMueVRleHR1cmUmJnRoaXMueVRleHR1cmUuZGVsZXRlKCksdGhpcy51VGV4dHVyZSYmdGhpcy51VGV4dHVyZS5kZWxldGUoKSx0aGlzLnZUZXh0dXJlJiZ0aGlzLnZUZXh0dXJlLmRlbGV0ZSgpLHRoaXMuY2FudmFzPXZvaWQgMH1wYXVzZSgpe3RoaXMucGF1c2VkPSEwLHRoaXMuc2V0UmVhZHlTdGF0ZShOSS5QYXVzZWQpfXBsYXkoKXt0aGlzLnBhdXNlZCYmKHRoaXMucGF1c2VkPSExLHRoaXMucmVzdGFydCgpKX1yZXN0YXJ0KCl7dGhpcy50b3RhbEZyYW1lcz0wLHRoaXMudG90YWxGcmFtZXNEcm9wcGVkPTAsdGhpcy5mcmFtZXNEcm9wcGVkU2luY2VMYXN0UmVuZGVyPTAsdGhpcy53YWl0aW5nVG9EZWNvZGVRdWV1ZT1bXSx0aGlzLnNldFJlYWR5U3RhdGUoTkkuV2FpdGluZ0ZvcktleWZyYW1lKSx0aGlzLm5lZWRzUmVzdGFydEV2ZW50Lmludm9rZSgpfXB1c2hEYXRhKEEpe2lmKHRoaXMuc3RhdHMucHVzaERhdGEoQS5kYXRhKSx0aGlzLnBhdXNlZClyZXR1cm47Y29uc3QgST1uZXcgVWludDhBcnJheShBLmRhdGEpO2xldCBnPSExO2lmKHRoaXMudmlkZW9Gb3JtYXQ9PUNnLkxlbmd0aFByZWZpeGVkP2c9dGhpcy5jb252ZXJ0VG9Bbm5leGJGb3JtYXQoSSk6dGhpcy5yZWFkeVN0YXRlPT1OSS5XYWl0aW5nRm9yS2V5ZnJhbWUmJihnPXRoaXMucGFyc2VBbm5leGJGcmFtZUluZm8oSSkpLHRoaXMucmVhZHlTdGF0ZT09TkkuV2FpdGluZ0ZvcktleWZyYW1lKWlmKGcpdGhpcy5zZXRSZWFkeVN0YXRlKE5JLlBsYXlpbmcpO2Vsc2UgaWYoIXRoaXMuY3VycmVudEZyYW1lSW5mbz8uY29udGFpbnNGcmFtZURhdGEpcmV0dXJuKHRoaXMuY3VycmVudEZyYW1lSW5mbz8uY29udGFpbnNTUFN8fHRoaXMuY3VycmVudEZyYW1lSW5mbz8uY29udGFpbnNQUFMpJiZ0aGlzLmRlY29kZXJXb3JrZXIuZGVjb2RlKEkpLHRoaXMuY3VycmVudEZyYW1lSW5mby5jb250YWluc1NQUz0hMSx0aGlzLmN1cnJlbnRGcmFtZUluZm8uY29udGFpbnNQUFM9ITEsdm9pZCh0aGlzLmN1cnJlbnRGcmFtZUluZm8uY29udGFpbnNGcmFtZURhdGE9ITApO2lmKHRoaXMucmVhZHlTdGF0ZSE9TkkuV2FpdGluZ0ZvcktleWZyYW1lJiZ0aGlzLmN1cnJlbnRGcmFtZUluZm8uY29udGFpbnNGcmFtZURhdGEpe2NvbnN0IGc9e3dpZHRoOkEuaGVhZGVyLndpZHRoLGhlaWdodDpBLmhlYWRlci5oZWlnaHQsbWVkaWFUaW1lOkRhdGUubm93KCkscHJvY2Vzc2luZ0R1cmF0aW9uOjAsZXhwZWN0ZWREaXNwbGF5VGltZTowLHByZXNlbnRhdGlvblRpbWU6MCxwcmVzZW50ZWRGcmFtZXM6MH07dGhpcy5kZWNvZGUoZyxJKX19Y29udmVydFRvQW5uZXhiRm9ybWF0KEEpe2xldCBJPSExO3RoaXMuY3VycmVudEZyYW1lSW5mby5jb250YWluc0ZyYW1lRGF0YT0hMTtmb3IobGV0IGc9MDtnPEEubGVuZ3RoOyl7Y29uc3QgQj10aGlzLm50b2hsKEEsZyk7QVtnXT0wLEFbKytnXT0wLEFbKytnXT0wLEFbKytnXT0xLCsrZztjb25zdCBRPTMxJkFbZ107UTw9NSYmUT49MT8oST01PT1RLHRoaXMuY3VycmVudEZyYW1lSW5mby5jb250YWluc0ZyYW1lRGF0YT0hMCk6Nz09UT90aGlzLmN1cnJlbnRGcmFtZUluZm8uY29udGFpbnNTUFM9ITA6OD09USYmKHRoaXMuY3VycmVudEZyYW1lSW5mby5jb250YWluc1BQUz0hMCksZys9Qn1yZXR1cm4gSX1udG9obChBLEkpe3JldHVybigyNTUmQVtJXSk8PDI0fCgyNTUmQVtJKzFdKTw8MTZ8KDI1NSZBW0krMl0pPDw4fDI1NSZBW0krM119cGFyc2VBbm5leGJGcmFtZUluZm8oQSl7bGV0IEk9ITE7dGhpcy5jdXJyZW50RnJhbWVJbmZvLmNvbnRhaW5zRnJhbWVEYXRhPSExO2ZvcihsZXQgZz0wO2c8QS5sZW5ndGg7KWlmKDA9PUFbZ10mJjA9PUFbZysxXSl7bGV0IEI9MDtpZigxPT1BW2crMl0/KGcrPTMsQj0zMSZBW2ddKTowPT1BW2crMl0mJjE9PUFbZyszXT8oZys9NCxCPTMxJkFbZ10pOisrZyxCPD01JiZCPj0xKXtpZih0aGlzLmN1cnJlbnRGcmFtZUluZm8uY29udGFpbnNGcmFtZURhdGE9ITAsNT09Qil7ST0hMDticmVha319ZWxzZSA3PT1CP3RoaXMuY3VycmVudEZyYW1lSW5mby5jb250YWluc1NQUz0hMDo4PT1CJiYodGhpcy5jdXJyZW50RnJhbWVJbmZvLmNvbnRhaW5zUFBTPSEwKX1lbHNlKytnO3JldHVybiBJfWRlY29kZShBLEkpezA9PXRoaXMuZGVjb2RlUXVldWUubGVuZ3RoPygwIT10aGlzLndhaXRpbmdUb0RlY29kZVF1ZXVlLmxlbmd0aCYmKElJKGFnLm5hbWUsXCJlbXB0eSBkZWNvZGVyIHF1ZXVlLCBidXQgd2FpdGluZyB0byBkZWNvZGUgcXVldWUgbm90IGVtcHR5IVwiKSx0aGlzLndhaXRpbmdUb0RlY29kZVF1ZXVlPVtdKSx0aGlzLnNlbmRUb0RlY29kZXIoQSxJKSk6KHRoaXMud2FpdGluZ1RvRGVjb2RlUXVldWUucHVzaCh7bWV0YWRhdGE6QSxkYXRhOkl9KSx0aGlzLmRlY29kZVF1ZXVlLmxlbmd0aDx0aGlzLm1heERlY29kZVF1ZXVlU2l6ZSYmdGhpcy5zZW5kRGVjb2RlcldhaXRpbmdUb0RlY29kZUZyYW1lcygpKX1zZW5kRGVjb2RlcldhaXRpbmdUb0RlY29kZUZyYW1lcygpe2Zvcig7dGhpcy5kZWNvZGVRdWV1ZS5sZW5ndGg8dGhpcy5tYXhEZWNvZGVRdWV1ZVNpemUmJnRoaXMud2FpdGluZ1RvRGVjb2RlUXVldWUubGVuZ3RoPjA7KXtjb25zdCBBPXRoaXMud2FpdGluZ1RvRGVjb2RlUXVldWUuc2hpZnQoKTt0aGlzLnNlbmRUb0RlY29kZXIoQS5tZXRhZGF0YSxBLmRhdGEpfX1zZW5kVG9EZWNvZGVyKEEsSSl7dGhpcy5zdGF0cy5yZXBvcnRGcmFtZVN1Ym1pdHRlZCgpLHRoaXMuZGVjb2RlUXVldWUucHVzaChBKSx0aGlzLmRlY29kZXJXb3JrZXIuZGVjb2RlKEkpfXJlbmRlckZyYW1lKEEsSSxnLEIsUSl7dGhpcy5jYW52YXMud2lkdGg9QSx0aGlzLmNhbnZhcy5oZWlnaHQ9STtjb25zdCBDPW5ldyBVaW50OEFycmF5KGcpLGU9QipRLGk9Qy5zdWJhcnJheSgwLGUpLHQ9ZT4+MixFPUMuc3ViYXJyYXkoZSxlK3QpLG89Qy5zdWJhcnJheShlK3QsZSsyKnQpO3RoaXMueVRleHR1cmUudXBsb2FkQnVmZmVyKGksQixRKTtjb25zdCBhPUI+PjEscz1RPj4xO3RoaXMudVRleHR1cmUudXBsb2FkQnVmZmVyKEUsYSxzKSx0aGlzLnZUZXh0dXJlLnVwbG9hZEJ1ZmZlcihvLGEscyksdGhpcy5zaGFkZXIuYmluZElucHV0VGV4dHVyZXModGhpcy55VGV4dHVyZSx0aGlzLnVUZXh0dXJlLHRoaXMudlRleHR1cmUpO2NvbnN0IG49QS9CLHI9SS9RO3RoaXMuc2hhZGVyLnVwZGF0ZShCLFEsbixyKSx0aGlzLnNoYWRlci5kcmF3KCl9Z2V0U3RhdHMoKXtyZXR1cm4gdGhpcy5zdGF0cy5nZXRSZXBvcnRTb2Z0d2FyZURlY29kZXIodGhpcy50b3RhbEZyYW1lc0Ryb3BwZWQsdGhpcy50b3RhbEZyYW1lcyx0aGlzLnJlYWR5U3RhdGUpfXNldFJlYWR5U3RhdGUoQSl7dGhpcy5yZWFkeVN0YXRlPUEsdGhpcy5yZWFkeVN0YXRlQ2hhbmdlRXZlbnQuaW52b2tlKEEpfWRpc3Bvc2UoKXtRSShhZy5uYW1lLFwiRGlzcG9zaW5nXCIpLHRoaXMucmVhZHlTdGF0ZT1OSS5EaXNwb3NlZCx0aGlzLmRlY29kZXJXb3JrZXIucmVsZWFzZSgpLHRoaXMuZGVjb2Rlcldvcmtlci5kaXNwb3NlKCksd2luZG93LmNsZWFySW50ZXJ2YWwodGhpcy5lbnN1cmVCdWZmZXJJbnRlcnZhbCl9fWNvbnN0IHNnPXtkcm9wcGVkRnJhbWVzOlwiRHJvcHBlZCBmcmFtZXNcIix0b3RhbEZyYW1lczpcIlRvdGFsIGZyYW1lc1wiLGN1cnJlbnRUaW1lOlwiQ3VycmVudCB2aWRlbyB0aW1lXCIsZW5kT2ZCdWZmZXJlZDpcIkVuZCBvZiB2aWRlbyBidWZmZXJcIixlbmRPZlNlZWthYmxlOlwiRW5kIG9mIHZpZGVvIHNlZWthYmxlXCIsZGF0YUludGVydmFsOlwiVmlkZW8gZGF0YSBpbnRlcnZhbFwiLGRhdGFTaXplOlwiVmlkZW8gZnJhbWUgc2l6ZVwiLHByb2Nlc3NpbmdEdXJhdGlvbjpcIkZyYW1lIHByb2Nlc3NpbmcgZHVyYXRpb25cIn07Y2xhc3Mgbmd7Y29uc3RydWN0b3IoQSxJLGcpe3RoaXMudmlkZW9TdHJlYW09QSx0aGlzLnVzaW5nT3V0cHV0Q2FudmFzPUksdGhpcy5nZXRTdGF0cz1nLHRoaXMuY29tcG9zaXRpbmdUaW1lVHJhY2s9bmV3IEhJKDVlMyxLSSksdGhpcy5wcm9jZXNzaW5nRHVyYXRpb25UcmFjaz1uZXcgSEkoNWUzLEtJKSx0aGlzLmZyYW1lVHJhY2s9bmV3IEhJKDVlMyxLSSksdGhpcy5kcmF3SW50ZXJ2YWxUcmFjaz1uZXcgSEkoNWUzLEtJKSx0aGlzLmRpc3BsYXlUaW1lSW50ZXJ2YWxUcmFjaz1uZXcgSEkoNWUzLEtJKSx0aGlzLmZyYW1lQ291bnRlcj0wLHRoaXMudGhyb3VnaHB1dD1bXSx0aGlzLmZldGNoU3RhdHM9YXN5bmMoKT0+e3RoaXMudmlkZW9TdHJlYW0ucmVhZHlTdGF0ZT09PU5JLlBsYXlpbmcmJih0aGlzLnN0YXRzPXRoaXMudmlkZW9TdHJlYW0uZ2V0U3RhdHMoKSx0aGlzLmxhc3RUcmFuc3BvcnRTdGF0cz10aGlzLnRyYW5zcG9ydFN0YXRzLHRoaXMudHJhbnNwb3J0U3RhdHM9YXdhaXQgdGhpcy5nZXRTdGF0cygpLHRoaXMudGhyb3VnaHB1dD10aGlzLmdldFRocm91Z2hwdXQoKSl9LHRoaXMuYW5pbWF0aW9uRnJhbWVIYW5kbGVyPSgpPT57dGhpcy5mcmFtZVRyYWNrLmZlZWQodGhpcy5mcmFtZUNvdW50ZXIpLHRoaXMuZnJhbWVDb3VudGVyPTAsdGhpcy5hbmltYXRpb25GcmFtZUhhbmRsZT13aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRoaXMuYW5pbWF0aW9uRnJhbWVIYW5kbGVyKX0sdGhpcy5kcmF3U3RhdHNPbmx5T25BbmltYXRpb25GcmFtZT0oKT0+e2lmKHRoaXMuZHJhd1N0YXRzT25seUhhbmRsZT13aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRoaXMuZHJhd1N0YXRzT25seU9uQW5pbWF0aW9uRnJhbWUpLCF0aGlzLmNhbnZhc0NvbnRleHR8fHRoaXMudmlkZW9TdHJlYW0ucmVhZHlTdGF0ZSE9PU5JLlBsYXlpbmcpcmV0dXJuO2NvbnN0IEE9dGhpcy5jYW52YXNDb250ZXh0O3RoaXMudXNpbmdPdXRwdXRDYW52YXN8fChBLmNhbnZhcy53aWR0aCE9PUEuY2FudmFzLmNsaWVudFdpZHRoJiYoQS5jYW52YXMud2lkdGg9QS5jYW52YXMuY2xpZW50V2lkdGgpLEEuY2FudmFzLmhlaWdodCE9PUEuY2FudmFzLmNsaWVudEhlaWdodCYmKEEuY2FudmFzLmhlaWdodD1BLmNhbnZhcy5jbGllbnRIZWlnaHQpLEEuY2xlYXJSZWN0KDAsMCxBLmNhbnZhcy53aWR0aCxBLmNhbnZhcy5oZWlnaHQpKSx0aGlzLmRyYXdTdGF0cygpfSx0aGlzLmRyYXdTdGF0c0FuZEdyYXBoc09uVmlkZW9GcmFtZT0oW0EsSV0pPT57aWYodGhpcy5mcmFtZUNvdW50ZXIrKywhdGhpcy5jYW52YXNDb250ZXh0fHx0aGlzLnZpZGVvU3RyZWFtLnJlYWR5U3RhdGUhPT1OSS5QbGF5aW5nfHwhSSlyZXR1cm47Y29uc3QgZz10aGlzLmNhbnZhc0NvbnRleHQ7dGhpcy51c2luZ091dHB1dENhbnZhc3x8KGcuY2FudmFzLndpZHRoIT09Zy5jYW52YXMuY2xpZW50V2lkdGgmJihnLmNhbnZhcy53aWR0aD1nLmNhbnZhcy5jbGllbnRXaWR0aCksZy5jYW52YXMuaGVpZ2h0IT09Zy5jYW52YXMuY2xpZW50SGVpZ2h0JiYoZy5jYW52YXMuaGVpZ2h0PWcuY2FudmFzLmNsaWVudEhlaWdodCksZy5jbGVhclJlY3QoMCwwLGcuY2FudmFzLndpZHRoLGcuY2FudmFzLmhlaWdodCkpO2NvbnN0IEI9cGVyZm9ybWFuY2Uubm93KCk7dGhpcy5sYXN0Q2FudmFzRHJhd1RpbWUmJnRoaXMuZHJhd0ludGVydmFsVHJhY2suZmVlZChCLXRoaXMubGFzdENhbnZhc0RyYXdUaW1lKSx0aGlzLmxhc3RDYW52YXNEcmF3VGltZT1CO2NvbnN0IFE9SS5leHBlY3RlZERpc3BsYXlUaW1lO3RoaXMubGFzdERpc3BsYXlUaW1lJiZ0aGlzLmRpc3BsYXlUaW1lSW50ZXJ2YWxUcmFjay5mZWVkKFEtdGhpcy5sYXN0RGlzcGxheVRpbWUpLHRoaXMubGFzdERpc3BsYXlUaW1lPVEsdGhpcy5jb21wb3NpdGluZ1RpbWVUcmFjay5mZWVkKEkuZXhwZWN0ZWREaXNwbGF5VGltZS1BKSx0aGlzLnByb2Nlc3NpbmdEdXJhdGlvblRyYWNrLmZlZWQoSS5wcm9jZXNzaW5nRHVyYXRpb24pO2NvbnN0IEM9Zy5jYW52YXM7Qy53aWR0aCxDLmNsaWVudFdpZHRoLEMuaGVpZ2h0LEMuY2xpZW50SGVpZ2h0LHRoaXMuZHJhd1N0YXRzKEkpfX1zZXRFbGVtZW50cyh7dmlkZW86QSxjYW52YXM6SSx1c2luZ091dHB1dENhbnZhczpnPSExfSl7dGhpcy51c2luZ091dHB1dENhbnZhcz1nLHRoaXMuY2FudmFzPUksdGhpcy52aWRlbz1BLHRoaXMuY2FudmFzJiYodGhpcy5jYW52YXNDb250ZXh0PXRoaXMuY2FudmFzLmdldENvbnRleHQoXCIyZFwiLHthbHBoYTohdGhpcy51c2luZ091dHB1dENhbnZhc30pKX1lbmFibGUoKXt0aGlzLmFuaW1hdGlvbkZyYW1lSGFuZGxlJiZ3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWUodGhpcy5hbmltYXRpb25GcmFtZUhhbmRsZSksdGhpcy5kcmF3U3RhdHNPbmx5SGFuZGxlJiZ3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWUodGhpcy5kcmF3U3RhdHNPbmx5SGFuZGxlKSx0aGlzLnZpZGVvU3RyZWFtIGluc3RhbmNlb2YgYWd8fFwicmVxdWVzdFZpZGVvRnJhbWVDYWxsYmFja1wiaW4gSFRNTFZpZGVvRWxlbWVudC5wcm90b3R5cGU/KHRoaXMuYW5pbWF0aW9uRnJhbWVIYW5kbGU9d2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSh0aGlzLmFuaW1hdGlvbkZyYW1lSGFuZGxlciksdGhpcy52aWRlb1N0cmVhbS52aWRlb0ZyYW1lRXZlbnQuYWRkSGFuZGxlcih0aGlzLmRyYXdTdGF0c0FuZEdyYXBoc09uVmlkZW9GcmFtZSkpOnRoaXMuZHJhd1N0YXRzT25seUhhbmRsZT13aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRoaXMuZHJhd1N0YXRzT25seU9uQW5pbWF0aW9uRnJhbWUpLHRoaXMuc3RhdHNJbnRlcnZhbD13aW5kb3cuc2V0SW50ZXJ2YWwodGhpcy5mZXRjaFN0YXRzLDFlMyl9ZGlzYWJsZSgpe3RoaXMuYW5pbWF0aW9uRnJhbWVIYW5kbGUmJndpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZSh0aGlzLmFuaW1hdGlvbkZyYW1lSGFuZGxlKSx0aGlzLmRyYXdTdGF0c09ubHlIYW5kbGUmJndpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZSh0aGlzLmRyYXdTdGF0c09ubHlIYW5kbGUpLHRoaXMudmlkZW9TdHJlYW0udmlkZW9GcmFtZUV2ZW50LnJlbW92ZUhhbmRsZXIodGhpcy5kcmF3U3RhdHNBbmRHcmFwaHNPblZpZGVvRnJhbWUpLHdpbmRvdy5jbGVhckludGVydmFsKHRoaXMuc3RhdHNJbnRlcnZhbCl9Z2V0VGhyb3VnaHB1dCgpe3JldHVybiB0aGlzLnRyYW5zcG9ydFN0YXRzJiZ0aGlzLmxhc3RUcmFuc3BvcnRTdGF0cz9PYmplY3QuZW50cmllcyh0aGlzLnRyYW5zcG9ydFN0YXRzPy5jaGFubmVscykubWFwKCgoW0EsSV0pPT50aGlzLmxhc3RUcmFuc3BvcnRTdGF0cz9bQSxJLmJ5dGVzU2VudC10aGlzLmxhc3RUcmFuc3BvcnRTdGF0cy5jaGFubmVsc1tBXS5ieXRlc1NlbnQsSS5ieXRlc1JlY2VpdmVkLXRoaXMubGFzdFRyYW5zcG9ydFN0YXRzLmNoYW5uZWxzW0FdLmJ5dGVzUmVjZWl2ZWRdOltBLDAsMF0pKTpbXX1kcmF3U3RhdHMoQSl7aWYoIXRoaXMuY2FudmFzQ29udGV4dHx8dGhpcy52aWRlb1N0cmVhbS5yZWFkeVN0YXRlIT09TkkuUGxheWluZylyZXR1cm47Y29uc3QgST10aGlzLmNhbnZhc0NvbnRleHQsZz1JLmNhbnZhcyxCPWcud2lkdGgvZy5jbGllbnRXaWR0aCxRPWcuaGVpZ2h0L2cuY2xpZW50SGVpZ2h0LEM9dGhpcy50aHJvdWdocHV0O2lmKHRoaXMuc3RhdHMpe2NvbnN0IGU9T2JqZWN0LmVudHJpZXModGhpcy5zdGF0cyksaT1lLmxlbmd0aCtDLmxlbmd0aCx0PUkubWVhc3VyZVRleHQoXCJNXCIpLndpZHRoO0kuZmlsbFN0eWxlPVwicmdiYSgwLCAwLCAwLCAwLjUpXCI7Y29uc3QgRT0oaSsyKSp0KzIqKHQrMipRKSsxNSpRO0kuZmlsbFJlY3QoMTAqQixnLmhlaWdodC0oRSsxMCpRKSwzMDAqQixFKSxJLmZpbGxTdHlsZT1cIndoaXRlXCIsSS5mb250PWAkeygxMipCKS50b0ZpeGVkKDApfXB4IHNhbnMtc2VyaWZgLEkudGV4dEJhc2VsaW5lPVwidG9wXCI7bGV0IG89MDtjb25zdCBhPWcuaGVpZ2h0LShFKzE1KlEpKzE1KkI7QT9JLmZpbGxUZXh0KGBSZXNvbHV0aW9uOiAke0Eud2lkdGh9eCR7QS5oZWlnaHR9YCwxNSpCLGEpOkkuZmlsbFRleHQoYFJlc29sdXRpb246ICR7dGhpcy52aWRlbz8udmlkZW9XaWR0aH14JHt0aGlzLnZpZGVvPy52aWRlb0hlaWdodH1gLDE1KkIsYSksSS5maWxsVGV4dChgRWxlbWVudCBzaXplOiAke2cuY2xpZW50V2lkdGh9eCR7Zy5jbGllbnRIZWlnaHR9YCwxNSpCLGErdCk7Zm9yKGNvbnN0W0EsZ11vZiBlKXtsZXQgQyxlPVwiXCI7XCJwcm9jZXNzaW5nRHVyYXRpb25cIj09PUE/KGU9XCJtc1wiLEM9MWUzKmcpOkM9ZyxcImVuZE9mQnVmZmVyZWRcIj09PUF8fFwiZW5kT2ZTZWVrYWJsZVwiPT09QXx8XCJjdXJyZW50VGltZVwiPT09QT9lPVwic1wiOlwiZGF0YUludGVydmFsXCI9PT1BP2U9XCJtc1wiOlwiZGF0YVNpemVcIj09PUEmJihlPVwiYnl0ZXNcIiksSS5maWxsVGV4dChgJHtzZ1tBXX06ICR7Qy50b0ZpeGVkKDIpfSAke2V9YCwxNSpCLG8qKHQrMipRKSsyKih0KzIqUSkrYSksbysrfWZvcihjb25zdFtBLGcsZV1vZiBDKUkuZmlsbFRleHQoYCR7QX0gdGhyb3VnaHB1dCAtIHVwOiAkeyhnLzFlMykudG9GaXhlZCgwKX0ga2IvcywgZG93bjogJHsoZS8xZTMpLnRvRml4ZWQoMCl9IGtiL3NgLDE1KkIsbyoodCsyKlEpKzIqKHQrMipRKSthKSxvKyt9fX12YXIgcmcsaGcsZGcsY2csRGcsd2csRmcsU2cseWcsR2csUmcsdWcsbGcsa2csVWcsTmcsbWcsTWcsTGcsZmcscGcsSGcsSmc7IWZ1bmN0aW9uKEEpe0FbQS5NU0U9MF09XCJNU0VcIixBW0EuU29mdHdhcmU9MV09XCJTb2Z0d2FyZVwifShoZ3x8KGhnPXt9KSksZnVuY3Rpb24oQSl7QVtBLklzb2xhdGVkQXBwcz0wXT1cIklzb2xhdGVkQXBwc1wiLEFbQS5GdWxsRGVza3RvcD0xXT1cIkZ1bGxEZXNrdG9wXCJ9KGRnfHwoZGc9e30pKTtjbGFzcyBLZ3tjb25zdHJ1Y3RvcihBLEksUSxDKXt0aGlzLnN0cmVhbVR5cGU9QSx0aGlzLmNob3NlblZpZGVvQ29uZmlnPUkscmcuc2V0KHRoaXMsdm9pZCAwKSx0aGlzLm92ZXJsYXlFbmFibGVkPSExLHRoaXMuc3RyZWFtRml0PWRnLklzb2xhdGVkQXBwcyxCKHRoaXMscmcse3ZpZGVvOntjb2RlY1N0cmluZzondmlkZW8vbXA0OyBjb2RlY3M9XCJhdmMxLjQyYzAyMFwiJywuLi50aGlzLmF1dG9kZXRlY3RWaWRlb0NvbmZpZ3VyYXRpb24oKSwuLi5RLnZpZGVvfSx2aWRlb1BlcmZvcm1hbmNlOlEudmlkZW9QZXJmb3JtYW5jZT8/e30sYXVkaW86ey4uLlEuYXVkaW99fSxcImZcIiksZyh0aGlzLHJnLFwiZlwiKS52aWRlby5kZWNvZGVyPT09aGcuU29mdHdhcmU/dGhpcy52aWRlb1N0cmVhbT1uZXcgYWcoZyh0aGlzLHJnLFwiZlwiKS52aWRlby5jb2RlY1N0cmluZyxDZy5MZW5ndGhQcmVmaXhlZCk6dGhpcy52aWRlb1N0cmVhbT1uZXcgX0koZyh0aGlzLHJnLFwiZlwiKS52aWRlby5jb2RlY1N0cmluZyksdGhpcy5hdWRpb1N0cmVhbT1uZXcgZ2csdGhpcy5hdWRpb1N0cmVhbS5jb25maWd1cmUoZyh0aGlzLHJnLFwiZlwiKS5hdWRpbyksdGhpcy52aWRlb1BlcmZvcm1hbmNlTW9uaXRvcj1uZXcgUWcodGhpcy52aWRlb1N0cmVhbSxnKHRoaXMscmcsXCJmXCIpLnZpZGVvUGVyZm9ybWFuY2UpLHRoaXMudmlkZW9TdGF0c092ZXJsYXk9bmV3IG5nKHRoaXMudmlkZW9TdHJlYW0sZyh0aGlzLHJnLFwiZlwiKS52aWRlby5kZWNvZGVyPT09aGcuU29mdHdhcmUsQyl9Z2V0IHZpZGVvUmVhZHlTdGF0ZUNoYW5nZUV2ZW50KCl7cmV0dXJuIHRoaXMudmlkZW9TdHJlYW0ucmVhZHlTdGF0ZUNoYW5nZUV2ZW50fWdldCB2aWRlb05lZWRzUmVzdGFydEV2ZW50KCl7cmV0dXJuIHRoaXMudmlkZW9TdHJlYW0ubmVlZHNSZXN0YXJ0RXZlbnR9Z2V0IGF1ZGlvQ29udGV4dCgpe3JldHVybiB0aGlzLmF1ZGlvU3RyZWFtLmF1ZGlvQ29udGV4dH1nZXQgY3VycmVudFN0cmVhbUJvdW5kcygpe3JldHVybiB0aGlzLnN0cmVhbUJvdW5kc31nZXQgY3VycmVudEZ1bGxEZXNrdG9wQm91bmRzKCl7cmV0dXJuIHRoaXMuZnVsbERlc2t0b3BCb3VuZHN9YXN5bmMgaW5pdGlhbGl6ZSgpe2F3YWl0IHRoaXMuYXVkaW9TdHJlYW0uaW5pdGlhbGl6ZSgpLHRoaXMuYXVkaW9TdHJlYW0ucGxheSgpfWdldCBjb25maWcoKXtyZXR1cm4gZyh0aGlzLHJnLFwiZlwiKX1hdXRvZGV0ZWN0VmlkZW9Db25maWd1cmF0aW9uKCl7cmV0dXJue2RlY29kZXI6d2luZG93Lk1lZGlhU291cmNlP2hnLk1TRTpoZy5Tb2Z0d2FyZX19c2V0Q29udGFpbmVyKEEpe2lmKHRoaXMudW5zZXRDb250YWluZXIoKSx0aGlzLmNvbnRhaW5lcj1BLHRoaXMuc3RyZWFtVHlwZT09PUZBLkFwcElzb2xhdGlvbil7Y29uc3QgQT10aGlzLmNyZWF0ZUlzb2xhdGlvbkNhbnZhc0VsZW1lbnQoKTt0aGlzLnNob3dTdHJlYW1FbGVtZW50KEEpLGcodGhpcyxyZyxcImZcIikudmlkZW8uZGVjb2Rlcj09PWhnLk1TRT90aGlzLnNldElzb2xhdGlvblNvdXJjZSh0aGlzLmNyZWF0ZVZpZGVvRWxlbWVudCgpKTp0aGlzLnNldElzb2xhdGlvblNvdXJjZSh0aGlzLmNyZWF0ZUNhbnZhc0VsZW1lbnQoKSl9ZWxzZSBnKHRoaXMscmcsXCJmXCIpLnZpZGVvLmRlY29kZXI9PT1oZy5NU0U/dGhpcy5zaG93U3RyZWFtRWxlbWVudCh0aGlzLmNyZWF0ZVZpZGVvRWxlbWVudCgpKTp0aGlzLnNob3dTdHJlYW1FbGVtZW50KHRoaXMuY3JlYXRlQ2FudmFzRWxlbWVudCgpKTt0aGlzLm92ZXJsYXlFbmFibGVkJiZ0aGlzLmNyZWF0ZUFuZFNob3dTdGF0c092ZXJsYXkoKX1zZXRJc29sYXRpb25Tb3VyY2UoQSl7dGhpcy5pc29sYXRpb25Tb3VyY2U9QX1jcmVhdGVBbmRTaG93U3RhdHNPdmVybGF5KCl7Y29uc3QgQT10aGlzLmNyZWF0ZU92ZXJsYXlDYW52YXNFbGVtZW50KCk7dGhpcy5zaG93T3ZlcmxheUVsZW1lbnQoQSksZyh0aGlzLHJnLFwiZlwiKS52aWRlby5kZWNvZGVyPT09aGcuTVNFP3RoaXMudmlkZW9TdGF0c092ZXJsYXkuc2V0RWxlbWVudHMoe3ZpZGVvOnRoaXMudmlkZW9FbGVtZW50LGNhbnZhczpBLHVzaW5nT3V0cHV0Q2FudmFzOiExfSk6dGhpcy52aWRlb1N0YXRzT3ZlcmxheS5zZXRFbGVtZW50cyh7Y2FudmFzOkEsdXNpbmdPdXRwdXRDYW52YXM6ITF9KX11bnNldENvbnRhaW5lcigpe3RoaXMuZGlzcG9zZVZpZGVvRWxlbWVudCgpLHRoaXMuZGlzcG9zZUNhbnZhc0VsZW1lbnQoKSx0aGlzLmRpc3Bvc2VPdmVybGF5Q2FudmFzRWxlbWVudCgpLHRoaXMuZGlzcG9zZUlzb2xhdGlvbkNhbnZhc0VsZW1lbnQoKSx0aGlzLmNvbnRhaW5lcj8ucXVlcnlTZWxlY3RvcihcIi5yYWlud2F5LXZpZGVvXCIpPy5yZW1vdmUoKSx0aGlzLmNvbnRhaW5lcj8ucXVlcnlTZWxlY3RvcihcIi5yYWlud2F5LWNhbnZhc1wiKT8ucmVtb3ZlKCksdGhpcy5jb250YWluZXI/LnF1ZXJ5U2VsZWN0b3IoXCIucmFpbndheS1vdmVybGF5LWNhbnZhc1wiKT8ucmVtb3ZlKCksdGhpcy5jb250YWluZXI/LnF1ZXJ5U2VsZWN0b3IoXCIucmFpbndheS1pc29sYXRpb24tY2FudmFzXCIpPy5yZW1vdmUoKSx0aGlzLmNvbnRhaW5lcj12b2lkIDB9c2hvd092ZXJsYXlFbGVtZW50KEEpe09iamVjdC5hc3NpZ24oQS5zdHlsZSx7cG9zaXRpb246XCJhYnNvbHV0ZVwiLHRvcDpcIjBcIixib3R0b206XCIwXCIsbGVmdDpcIjBcIixyaWdodDpcIjBcIix3aWR0aDpcIjEwMCVcIixoZWlnaHQ6XCIxMDAlXCIscG9pbnRlckV2ZW50czpcIm5vbmVcIn0pfWNyZWF0ZVZpZGVvRWxlbWVudCgpe3RoaXMuY29udGFpbmVyPy5xdWVyeVNlbGVjdG9yKFwiLnJhaW53YXktdmlkZW9cIik/LnJlbW92ZSgpLHRoaXMudmlkZW9FbGVtZW50PWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJ2aWRlb1wiKTtjb25zdCBBPXRoaXMudmlkZW9FbGVtZW50O3JldHVybiBBLm9uY29udGV4dG1lbnU9KCk9PiExLEEuY2xhc3NOYW1lPVwicmFpbndheS12aWRlb1wiLEEuYXV0b3BsYXk9ITAsQS5tdXRlZD0hMCxBLnN0eWxlLmRpc3BsYXk9XCJub25lXCIsdGhpcy5jb250YWluZXIuYXBwZW5kQ2hpbGQoQSksdGhpcy52aWRlb1N0cmVhbS5hdHRhY2hUb0VsZW1lbnQoQSksdGhpcy52aWRlb0VsZW1lbnR9ZGlzcG9zZVZpZGVvRWxlbWVudCgpe3RoaXMudmlkZW9FbGVtZW50JiYodGhpcy52aWRlb1N0cmVhbS5kZXRhY2hGcm9tRWxlbWVudCgpLHRoaXMudmlkZW9FbGVtZW50LnJlbW92ZSgpLHRoaXMudmlkZW9FbGVtZW50PXZvaWQgMCl9Y3JlYXRlT3ZlcmxheUNhbnZhc0VsZW1lbnQoKXt0aGlzLmNvbnRhaW5lcj8ucXVlcnlTZWxlY3RvcihcIi5yYWlud2F5LW92ZXJsYXktY2FudmFzXCIpPy5yZW1vdmUoKSx0aGlzLmNhbnZhc0VsZW1lbnQ9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKTtjb25zdCBBPXRoaXMuY2FudmFzRWxlbWVudDtyZXR1cm4gQS5vbmNvbnRleHRtZW51PSgpPT4hMSxBLmNsYXNzTmFtZT1cInJhaW53YXktb3ZlcmxheS1jYW52YXNcIix0aGlzLmNvbnRhaW5lci5hcHBlbmRDaGlsZChBKSxBLmdldENvbnRleHQoXCIyZFwiKT8uY2xlYXJSZWN0KDAsMCxBLndpZHRoLEEuaGVpZ2h0KSxBfWRpc3Bvc2VPdmVybGF5Q2FudmFzRWxlbWVudCgpe3RoaXMuY29udGFpbmVyPy5xdWVyeVNlbGVjdG9yKFwiLnJhaW53YXktb3ZlcmxheS1jYW52YXNcIik/LnJlbW92ZSgpLHRoaXMub3ZlcmxheUNhbnZhc0VsZW1lbnQmJih0aGlzLm92ZXJsYXlDYW52YXNFbGVtZW50LnJlbW92ZSgpLHRoaXMub3ZlcmxheUNhbnZhc0VsZW1lbnQ9dm9pZCAwKX1jcmVhdGVDYW52YXNFbGVtZW50KCl7dGhpcy5jb250YWluZXI/LnF1ZXJ5U2VsZWN0b3IoXCIucmFpbndheS1jYW52YXNcIik/LnJlbW92ZSgpLHRoaXMuY2FudmFzRWxlbWVudD1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpO2NvbnN0IEE9dGhpcy5jYW52YXNFbGVtZW50O3JldHVybiBBLm9uY29udGV4dG1lbnU9KCk9PiExLEEuY2xhc3NOYW1lPVwicmFpbndheS1jYW52YXNcIixBLnN0eWxlLmRpc3BsYXk9XCJub25lXCIsdGhpcy5jb250YWluZXIuYXBwZW5kQ2hpbGQoQSksdGhpcy52aWRlb1N0cmVhbSBpbnN0YW5jZW9mIGFnJiZ0aGlzLnZpZGVvU3RyZWFtLmF0dGFjaFRvQ2FudmFzKEEpLEEuZ2V0Q29udGV4dChcIjJkXCIpPy5jbGVhclJlY3QoMCwwLEEud2lkdGgsQS5oZWlnaHQpLEF9ZGlzcG9zZUNhbnZhc0VsZW1lbnQoKXt0aGlzLmNhbnZhc0VsZW1lbnQmJih0aGlzLnZpZGVvU3RyZWFtIGluc3RhbmNlb2YgYWcmJnRoaXMudmlkZW9TdHJlYW0uZGV0YWNoRnJvbUNhbnZhcygpLHRoaXMuY2FudmFzRWxlbWVudC5yZW1vdmUoKSx0aGlzLmNhbnZhc0VsZW1lbnQ9dm9pZCAwKX1jcmVhdGVJc29sYXRpb25DYW52YXNFbGVtZW50KCl7dGhpcy5jb250YWluZXI/LnF1ZXJ5U2VsZWN0b3IoXCIucmFpbndheS1pc29sYXRpb24tY2FudmFzXCIpPy5yZW1vdmUoKSx0aGlzLmlzb2xhdGlvbkNhbnZhc0VsZW1lbnQ9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKTtjb25zdCBBPXRoaXMuaXNvbGF0aW9uQ2FudmFzRWxlbWVudDtyZXR1cm4gQS5vbmNvbnRleHRtZW51PSgpPT4hMSxBLmNsYXNzTmFtZT1cInJhaW53YXktaXNvbGF0aW9uLWNhbnZhc1wiLHRoaXMuY29udGFpbmVyLmFwcGVuZENoaWxkKEEpLEEuZ2V0Q29udGV4dChcIjJkXCIpPy5jbGVhclJlY3QoMCwwLEEud2lkdGgsQS5oZWlnaHQpLEF9ZGlzcG9zZUlzb2xhdGlvbkNhbnZhc0VsZW1lbnQoKXt0aGlzLmlzb2xhdGlvbkNhbnZhc0VsZW1lbnQmJih0aGlzLmlzb2xhdGlvbkNhbnZhc0VsZW1lbnQucmVtb3ZlKCksdGhpcy5pc29sYXRpb25DYW52YXNFbGVtZW50PXZvaWQgMCl9aGlkZVN0cmVhbUVsZW1lbnQoQSl7QS5zdHlsZS53aWR0aD1cIjBcIixBLnN0eWxlLmhlaWdodD1cIjBcIn1zaG93U3RyZWFtRWxlbWVudChBKXt0aGlzLmNvbnRhaW5lciYmKHRoaXMuc3RyZWFtRWxlbWVudD1BLEEuc3R5bGUud2lkdGg9XCIxMDAlXCIsQS5zdHlsZS5oZWlnaHQ9XCIxMDAlXCIsQS5zdHlsZS5kaXNwbGF5PVwiYmxvY2tcIixBLnN0eWxlLm9iamVjdEZpdD1cImNvbnRhaW5cIil9cGF1c2UoKXt0aGlzLnZpZGVvU3RyZWFtLnBhdXNlKCksdGhpcy5hdWRpb1N0cmVhbS5zdG9wKCl9cGxheSgpe3RoaXMudmlkZW9TdHJlYW0ucGxheSgpLHRoaXMuYXVkaW9TdHJlYW0ucGxheSgpfXJlbmRlclZpZGVvRnJhbWUoQSl7dGhpcy52aWRlb1N0cmVhbS5wdXNoRGF0YShBKTtjb25zdHtoZWFkZXI6SX09QTt0aGlzLmZ1bGxEZXNrdG9wQm91bmRzPXtsZWZ0OkkueCx0b3A6SS55LHdpZHRoOkkud2lkdGgsaGVpZ2h0OkkuaGVpZ2h0fSx0aGlzLnN0cmVhbVR5cGU9PT1GQS5BcHBJc29sYXRpb24/KEkubWFzay5sZW5ndGg+MCYmKHRoaXMubWFzaz1JLm1hc2spLEkud2lkdGg+MCYmKHRoaXMuZnJhbWVXaWR0aD1JLndpZHRoKSxJLmhlaWdodD4wJiYodGhpcy5mcmFtZUhlaWdodD1JLmhlaWdodCksdGhpcy5yZW5kZXJJc29sYXRlZEFwcCgpKTp0aGlzLnN0cmVhbUJvdW5kcz10aGlzLmZ1bGxEZXNrdG9wQm91bmRzfXJlbmRlcklzb2xhdGVkQXBwKCl7aWYoIXRoaXMubWFzaylyZXR1cm47aWYoIXRoaXMuZnJhbWVXaWR0aClyZXR1cm47aWYoIXRoaXMuZnJhbWVIZWlnaHQpcmV0dXJuO2NvbnN0IEE9dGhpcy5pc29sYXRpb25Tb3VyY2U7aWYoIUEpcmV0dXJuO2NvbnN0IEk9dGhpcy5pc29sYXRpb25DYW52YXNFbGVtZW50O2lmKCFJKXJldHVybjtjb25zdCBnPUkuZ2V0Q29udGV4dChcIjJkXCIpO2lmKCFnKXJldHVybjtjb25zdCBCPXRoaXMuc3RyZWFtRml0PT1kZy5Jc29sYXRlZEFwcHM/ZnVuY3Rpb24oQSl7Y29uc3QgST1BLmxlbmd0aDtpZigwPT09SSl0aHJvdyBuZXcgRXJyb3IoXCJib3VuZGluZ1JlY3RhbmdsZSgpIG9mIDAgcmVjdGFuZ2xlc1wiKTtjb25zdCBnPUFbMF07bGV0e2xlZnQ6Qix0b3A6UX09ZyxDPUIrZy53aWR0aCxlPVErZy5oZWlnaHQ7Zm9yKGxldCBnPTE7ZzxJO2crKyl7Y29uc3QgST1BW2ddO0I9TWF0aC5taW4oQixJLmxlZnQpLFE9TWF0aC5taW4oUSxJLnRvcCksQz1NYXRoLm1heChDLEkubGVmdCtJLndpZHRoKSxlPU1hdGgubWF4KGUsSS50b3ArSS5oZWlnaHQpfXJldHVybntsZWZ0OkIsdG9wOlEsd2lkdGg6Qy1CLGhlaWdodDplLVF9fSh0aGlzLm1hc2spOnRoaXMuZnVsbERlc2t0b3BCb3VuZHM7dGhpcy5zdHJlYW1Cb3VuZHM9Qjtjb25zdCBRPXRoaXMuY2hvc2VuVmlkZW9Db25maWcuY29kZWMud2lkdGgvdGhpcy5mcmFtZVdpZHRoLEM9dGhpcy5jaG9zZW5WaWRlb0NvbmZpZy5jb2RlYy5oZWlnaHQvdGhpcy5mcmFtZUhlaWdodDtJLndpZHRoPUIud2lkdGgqUSxJLmhlaWdodD1CLmhlaWdodCpDO2Zvcihjb25zdHtsZWZ0OkksdG9wOmUsd2lkdGg6aSxoZWlnaHQ6dH1vZiB0aGlzLm1hc2spe2NvbnN0IEU9SSpRLG89ZSpDLGE9aSpRLHM9dCpDLG49KEktQi5sZWZ0KSpRLHI9KGUtQi50b3ApKkM7Zy5kcmF3SW1hZ2UoQSxFLG8sYSxzLG4scixhLHMpfX1wcm9jZXNzQXVkaW8oQSl7dGhpcy5hdWRpb1N0cmVhbS5wdXNoRGF0YShBKX1nZXRWaWRlb1N0YXRzKCl7cmV0dXJuIHRoaXMudmlkZW9TdHJlYW0uZ2V0U3RhdHMoKX1hc3luYyBjb25maWd1cmVBdWRpbyhBKXtnKHRoaXMscmcsXCJmXCIpLmF1ZGlvPXsuLi5nKHRoaXMscmcsXCJmXCIpLmF1ZGlvLC4uLkF9LHRoaXMuYXVkaW9TdHJlYW0uY29uZmlndXJlKEEpfWVuYWJsZVN0YXRzT3ZlcmxheSgpe3RoaXMub3ZlcmxheUVuYWJsZWQ9ITAsdGhpcy52aWRlb1N0YXRzT3ZlcmxheS5lbmFibGUoKSx0aGlzLmRpc3Bvc2VPdmVybGF5Q2FudmFzRWxlbWVudCgpLHRoaXMuY3JlYXRlQW5kU2hvd1N0YXRzT3ZlcmxheSgpfWRpc2FibGVTdGF0c092ZXJsYXkoKXt0aGlzLmRpc3Bvc2VPdmVybGF5Q2FudmFzRWxlbWVudCgpLHRoaXMub3ZlcmxheUVuYWJsZWQ9ITEsdGhpcy52aWRlb1N0YXRzT3ZlcmxheS5kaXNhYmxlKCl9ZGlzcG9zZSgpe3RoaXMucGF1c2UoKSx0aGlzLnVuc2V0Q29udGFpbmVyKCksdGhpcy5hdWRpb1N0cmVhbS5kaXNwb3NlKCksdGhpcy52aWRlb1N0cmVhbS5kaXNwb3NlKCl9c2V0Vm9sdW1lKEEpe3RoaXMuYXVkaW9TdHJlYW0uc2V0Vm9sdW1lKEEpfX1yZz1uZXcgV2Vha01hcDtjbGFzcyBxZyBleHRlbmRzIHNJe2NvbnN0cnVjdG9yKEEsSSxnLFE9NWUzKXtzdXBlcigpLHRoaXMuZ2V0VHJhbnNwb3J0U3RhdHM9QSx0aGlzLmdldFZpZGVvU3RhdHM9SSx0aGlzLmdldFJhdGVDb250cm9sU3RhdHM9Zyx0aGlzLnN0YXRzU3VtbWFyeUludGVydmFsTXM9USxjZy5zZXQodGhpcyx7ZW50cmllczpbXX0pLERnLnNldCh0aGlzLHZvaWQgMCksd2cuc2V0KHRoaXMsMCksRmcuc2V0KHRoaXMsMCksU2cuc2V0KHRoaXMsMCkseWcuc2V0KHRoaXMsMCksR2cuc2V0KHRoaXMsMCksUmcuc2V0KHRoaXMsdm9pZCAwKSxCKHRoaXMsRGcsd2luZG93LnNldEludGVydmFsKHRoaXMucHVzaFN0YXRzU3VtbWFyeS5iaW5kKHRoaXMpLFEpLFwiZlwiKSxCKHRoaXMsUmcsRGF0ZS5ub3coKSxcImZcIil9Z2V0IHJlcG9ydCgpe3JldHVybiBnKHRoaXMsY2csXCJmXCIpfWRpc3Bvc2UoKXt0aGlzLnJlbW92ZUFsbEV2ZW50TGlzdGVuZXJzKCksd2luZG93LmNsZWFySW50ZXJ2YWwoZyh0aGlzLERnLFwiZlwiKSl9YXN5bmMgcHVzaFN0YXRzU3VtbWFyeSgpe2NvbnN0IEE9YXdhaXQgdGhpcy5nZXRUcmFuc3BvcnRTdGF0cygpLEk9QS5jaGFubmVscyxRPUkuUldfQXVkaW8/LmJ5dGVzUmVjZWl2ZWR8fDAsQz1JLlJXX1ZpZGVvPy5ieXRlc1JlY2VpdmVkfHwwLGU9dGhpcy5zdGF0c1N1bW1hcnlJbnRlcnZhbE1zLzFlMyxpPShRLWcodGhpcyx3ZyxcImZcIikpLzFlMyx0PShDLWcodGhpcyxGZyxcImZcIikpLzFlMyx7dmlkZW9CaXRyYXRlS2JwczpFfT10aGlzLmdldFJhdGVDb250cm9sU3RhdHMoKSxvPURhdGUubm93KCksYT17YXVkaW9UaHJvdWdocHV0S2JwczppL2UsdmlkZW9UaHJvdWdocHV0S2Jwczp0L2UsdmlkZW9SZWNlaXZlZEZwczpnKHRoaXMsR2csXCJmXCIpL2UsdmlkZW9CaXRyYXRlS2JwczpFLGlucHV0RXZlbnRzOmcodGhpcyxTZyxcImZcIiksY3Vyc29yRXZlbnRzOmcodGhpcyx5ZyxcImZcIiksc2Vjb25kczooby1nKHRoaXMsUmcsXCJmXCIpKS8xZTMsbGF0ZW5jeU1zOkEubGF0ZW5jeU1zfTt0aGlzLnB1c2goe3R5cGU6XCJzdGF0c1wiLHN0YXRzOmF9KSx0aGlzLmVtaXQoXCJzdGF0c1wiLGEpLEIodGhpcyxTZywwLFwiZlwiKSxCKHRoaXMseWcsMCxcImZcIiksQih0aGlzLEdnLDAsXCJmXCIpLEIodGhpcyx3ZyxRLFwiZlwiKSxCKHRoaXMsRmcsQyxcImZcIiksQih0aGlzLFJnLERhdGUubm93KCksXCJmXCIpfXB1c2goQSl7Zyh0aGlzLGNnLFwiZlwiKS5lbnRyaWVzLnB1c2goey4uLkEsdGltZVVuaXhNczpEYXRlLm5vdygpfSl9bG9nKEEpe3RoaXMucHVzaCh7dHlwZTpBfSl9bG9nU3RhcnQoQSxJLGcsQixRKXt0aGlzLnB1c2goe3R5cGU6XCJzdGFydGVkXCIsbG9jYWxQZWVySWQ6QS50b1N0cmluZygpLGhvc3RQZWVySWQ6SS50b1N0cmluZygpLHN0cmVhbUlkOmcsdmlkZW9Db2RlYzpCLHN0cmVhbVR5cGU6UT09PUZBLkZ1bGxEZXNrdG9wP1wiZnVsbERlc2t0b3BcIjpRPT09RkEuQXBwSXNvbGF0aW9uP1wiYXBwSXNvbGF0aW9uXCI6XCJieW9mYlwifSl9bG9nVmlkZW9SZWFkeVN0YXRlKEEpe3RoaXMucHVzaCh7dHlwZTpcInZpZGVvUmVhZHlTdGF0ZVwiLHN0YXRlOk5JW0FdfSl9bG9nVmlkZW9CaXRyYXRlQ2hhbmdlKEEsSSl7QSE9PUkmJnRoaXMucHVzaCh7dHlwZTpcInZpZGVvQml0cmF0ZUNoYW5nZVwiLG5ld0ticHM6QSxvbGRLYnBzOkksZGlyZWN0aW9uOkE+ST9cInVwXCI6XCJkb3duXCJ9KX1jb3VudElucHV0RXZlbnQoKXt2YXIgQTtCKHRoaXMsU2csKEE9Zyh0aGlzLFNnLFwiZlwiKSwrK0EpLFwiZlwiKX1jb3VudEN1cnNvckV2ZW50KCl7dmFyIEE7Qih0aGlzLHlnLChBPWcodGhpcyx5ZyxcImZcIiksKytBKSxcImZcIil9Y291bnRWaWRlb0ZyYW1lKCl7dmFyIEE7Qih0aGlzLEdnLChBPWcodGhpcyxHZyxcImZcIiksKytBKSxcImZcIil9fWNnPW5ldyBXZWFrTWFwLERnPW5ldyBXZWFrTWFwLHdnPW5ldyBXZWFrTWFwLEZnPW5ldyBXZWFrTWFwLFNnPW5ldyBXZWFrTWFwLHlnPW5ldyBXZWFrTWFwLEdnPW5ldyBXZWFrTWFwLFJnPW5ldyBXZWFrTWFwO2NsYXNzIFlnIGV4dGVuZHMgc0l7Y29uc3RydWN0b3IoQSxJLFEsQyxlLGksdCxFLG8sYSxzKXtzdXBlcigpLHRoaXMucGVlcj1BLHRoaXMuaWQ9SSx0aGlzLmNob3NlbkF1ZGlvQ29uZmlnPUMsdGhpcy5jaG9zZW5WaWRlb0NvbmZpZz1lLHRoaXMuc3RyZWFtVHlwZT1pLHRoaXMuc2VuZEJlYm9wSW5wdXQ9RSx0aGlzLnNlbmRMb2dpYz1vLHRoaXMuZGlzY2FyZEluUGFyZW50PXMsdGhpcy5yZXNpemVEZWJvdW5jZUhhbmRsZT12b2lkIDAsdWcuc2V0KHRoaXMsITEpLGxnLnNldCh0aGlzLHZvaWQgMCksdGhpcy5zZW5kS2V5ZnJhbWVSZXF1ZXN0PSgpPT57dGhpcy5zZW5kTG9naWMoe2Rpc2NyaW1pbmF0b3I6TEEuZGlzY3JpbWluYXRvcix2YWx1ZTp7c3RyZWFtSWQ6dGhpcy5pZH19KX0sdGhpcy5mZWVkVmlkZW9TdGF0ZUludG9SYXRlQ29udHJvbGxlcj1BPT57Zyh0aGlzLGxnLFwiZlwiKT8ubG9nVmlkZW9SZWFkeVN0YXRlKEEpLHRoaXMucmF0ZUNvbnRyb2xsZXIuaGFuZGxlVmlkZW9SZWFkeVN0YXRlKEEpfSx0aGlzLnNldFJlbW90ZUNsaXBib2FyZD0oKT0+e1wiZnVuY3Rpb25cIiE9dHlwZW9mIG5hdmlnYXRvcj8uY2xpcGJvYXJkPy5yZWFkVGV4dHx8a0l8fG5hdmlnYXRvci5jbGlwYm9hcmQucmVhZFRleHQoKS50aGVuKChBPT57dGhpcy5zZW5kQmVib3BJbnB1dCh7ZGlzY3JpbWluYXRvcjpDQS5kaXNjcmltaW5hdG9yLHZhbHVlOnt0ZXh0OkF9fSl9KSl9O2NvbnN0IG49ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtuLnRhYkluZGV4PTAsbi5zdHlsZS50b3VjaEFjdGlvbj1cIm5vbmVcIixuLnN0eWxlLnVzZXJTZWxlY3Q9XCJub25lXCIsbi5zdHlsZS53ZWJraXRVc2VyU2VsZWN0PVwibm9uZVwiLG4uc3R5bGUucG9zaXRpb249XCJyZWxhdGl2ZVwiLG4uc3R5bGUud2lkdGg9XCIxMDAlXCIsbi5zdHlsZS5oZWlnaHQ9XCIxMDAlXCIsbi5jbGFzc05hbWU9XCJyYWlud2F5LWlubmVyLWNvbnRhaW5lclwiLG4uYWRkRXZlbnRMaXN0ZW5lcihcImZvY3VzXCIsdGhpcy5zZXRSZW1vdGVDbGlwYm9hcmQpLHRoaXMuaW5uZXJDb250YWluZXI9bix0aGlzLmlucHV0TWFuYWdlcj1uZXcgcEkodGhpcyksdGhpcy5tZWRpYU1hbmFnZXI9bmV3IEtnKGksZSx7dmlkZW86e2NvZGVjU3RyaW5nOllJKGUuY29kZWMpfX0sYSksdGhpcy5tZWRpYU1hbmFnZXIuc3RyZWFtRml0PXQuc3RyZWFtRml0Pz9kZy5GdWxsRGVza3RvcCx0aGlzLnJhdGVDb250cm9sbGVyPW5ldyB4SSh2b2lkIDAsZSwoKEEsQik9Pnt0aGlzLnNlbmRMb2dpYyh7ZGlzY3JpbWluYXRvcjpmQS5kaXNjcmltaW5hdG9yLHZhbHVlOntzdHJlYW1JZDpJLGJpdHNQZXJTZWNvbmQ6MWUzKkF9fSksZyh0aGlzLGxnLFwiZlwiKT8ubG9nVmlkZW9CaXRyYXRlQ2hhbmdlKEEsQil9KSx0aGlzLm1lZGlhTWFuYWdlci52aWRlb1BlcmZvcm1hbmNlTW9uaXRvciksbi5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwoKCk9Pnt0aGlzLnJlc3VtZUF1ZGlvKCl9KSksdGhpcy5tZWRpYU1hbmFnZXIuc2V0Q29udGFpbmVyKG4pLHRoaXMubWVkaWFNYW5hZ2VyLnZpZGVvTmVlZHNSZXN0YXJ0RXZlbnQuYWRkSGFuZGxlcih0aGlzLnNlbmRLZXlmcmFtZVJlcXVlc3QpLHRoaXMubWVkaWFNYW5hZ2VyLnZpZGVvUmVhZHlTdGF0ZUNoYW5nZUV2ZW50LmFkZEhhbmRsZXIodGhpcy5mZWVkVmlkZW9TdGF0ZUludG9SYXRlQ29udHJvbGxlciksdGhpcy5pbnB1dE1hbmFnZXIuc2V0Q29udGFpbmVyKG4pLHRoaXMuaW5wdXRNYW5hZ2VyLnNldElucHV0TGV2ZWwoUSksdGhpcy5jb250YWluZXJSZXNpemVPYnNlcnZlcj1uZXcgUmVzaXplT2JzZXJ2ZXIoKCgpPT57dGhpcy5yZXNpemVEZWJvdW5jZUhhbmRsZSYmd2luZG93LmNsZWFyVGltZW91dCh0aGlzLnJlc2l6ZURlYm91bmNlSGFuZGxlKSx0aGlzLnJlc2l6ZURlYm91bmNlSGFuZGxlPXdpbmRvdy5zZXRUaW1lb3V0KCgoKT0+e3RoaXMuc2VuZEJlYm9wSW5wdXQoe2Rpc2NyaW1pbmF0b3I6UUEuZGlzY3JpbWluYXRvcix2YWx1ZTp7d2lkdGg6dGhpcy5pbm5lckNvbnRhaW5lci5jbGllbnRXaWR0aCxoZWlnaHQ6dGhpcy5pbm5lckNvbnRhaW5lci5jbGllbnRIZWlnaHR9fSksdGhpcy5yZXNpemVEZWJvdW5jZUhhbmRsZT12b2lkIDB9KSwxMDApfSkpLHRoaXMuY29udGFpbmVyUmVzaXplT2JzZXJ2ZXIub2JzZXJ2ZShuKSx0Lm1ldHJpY3MmJihCKHRoaXMsbGcsbmV3IHFnKGEsKCgpPT50aGlzLm1lZGlhTWFuYWdlci5nZXRWaWRlb1N0YXRzKCkpLCgoKT0+dGhpcy5yYXRlQ29udHJvbGxlci5nZXRTdGF0cygpKSksXCJmXCIpLGcodGhpcyxsZyxcImZcIikubG9nU3RhcnQoQS5jb25uZWN0aW9uLmlkLEEuaWQsSSxlLmNvZGVjLmZyaWVuZGx5TmFtZSxpKSxnKHRoaXMsbGcsXCJmXCIpLmFkZEV2ZW50TGlzdGVuZXIoXCJzdGF0c1wiLChBPT57dGhpcy5lbWl0KFwic3RhdHNcIixBKX0pKSl9Z2V0IGVuZGVkKCl7cmV0dXJuIGcodGhpcyx1ZyxcImZcIil9Z2V0IGNvbnRhaW5lcigpe3JldHVybiB0aGlzLmlubmVyQ29udGFpbmVyfWdldCBwZXJtaXNzaW9ucygpe3JldHVybiB0aGlzLmlucHV0TWFuYWdlci5nZXRJbnB1dExldmVsKCl9Z2V0IGN1cnJlbnRGcmFtZVNpemUoKXtjb25zdHtjb2RlYzpBfT10aGlzLmNob3NlblZpZGVvQ29uZmlnO3JldHVybntjb2RlY1dpZHRoOkEud2lkdGgsY29kZWNIZWlnaHQ6QS5oZWlnaHQsc3RyZWFtQm91bmRzOnRoaXMubWVkaWFNYW5hZ2VyLmN1cnJlbnRTdHJlYW1Cb3VuZHMsZnVsbERlc2t0b3BCb3VuZHM6dGhpcy5tZWRpYU1hbmFnZXIuY3VycmVudEZ1bGxEZXNrdG9wQm91bmRzfX1nZXQgc3RyZWFtRml0KCl7cmV0dXJuIHRoaXMubWVkaWFNYW5hZ2VyLnN0cmVhbUZpdH1hc3luYyBpbml0aWFsaXplKCl7YXdhaXQgdGhpcy5tZWRpYU1hbmFnZXIuaW5pdGlhbGl6ZSgpfXByb2Nlc3NBdWRpbyhBKXt0aGlzLm1lZGlhTWFuYWdlci5wcm9jZXNzQXVkaW8oQSl9cHJvY2Vzc0N1cnNvcihBKXtnKHRoaXMsbGcsXCJmXCIpPy5jb3VudEN1cnNvckV2ZW50KCksdGhpcy5pbnB1dE1hbmFnZXIucHJvY2Vzc0N1cnNvcihBKX1yZW5kZXJWaWRlb0ZyYW1lKEEpe3RoaXMucmF0ZUNvbnRyb2xsZXIuZmVlZEZyYW1lVGltZXN0YW1wKEEuaGVhZGVyLnRpbWVzdGFtcCksdGhpcy5tZWRpYU1hbmFnZXIucmVuZGVyVmlkZW9GcmFtZShBKX10cmFuc2Zvcm1Qb2ludGVyT2Zmc2V0VG9SZW1vdGUoQSxJKXtjb25zdCBnPXRoaXMubWVkaWFNYW5hZ2VyLmN1cnJlbnRTdHJlYW1Cb3VuZHM7aWYoIWcpcmV0dXJuO2NvbnN0IEI9dGhpcy5tZWRpYU1hbmFnZXIuY3VycmVudEZ1bGxEZXNrdG9wQm91bmRzO2lmKCFCKXJldHVybjtjb25zdHtsZWZ0OlEsdG9wOkMsd2lkdGg6ZSxoZWlnaHQ6aX09Qix7bGVmdDp0LHRvcDpFLHdpZHRoOm8saGVpZ2h0OmF9PWcscz10aGlzLmNob3NlblZpZGVvQ29uZmlnLmNvZGVjLndpZHRoLG49dGhpcy5jaG9zZW5WaWRlb0NvbmZpZy5jb2RlYy5oZWlnaHQscj10aGlzLmlubmVyQ29udGFpbmVyLmNsaWVudFdpZHRoLGg9dGhpcy5pbm5lckNvbnRhaW5lci5jbGllbnRIZWlnaHQsZD1vKnMvZSxjPWEqbi9pLEQ9TWF0aC5taW4oci9kLGgvYyk7cmV0dXJue3g6KEEtKHItRCpkKS8yKS8oRCpzL2UpK3QtUSx5OihJLShoLUQqYykvMikvKEQqbi9pKStFLUN9fXJlbGVhc2VLZXlzKCl7dGhpcy5pbnB1dE1hbmFnZXIucmVsZWFzZUtleXMoKX1lbmFibGVWaWRlb1N0YXRzT3ZlcmxheSgpe3RoaXMubWVkaWFNYW5hZ2VyPy5lbmFibGVTdGF0c092ZXJsYXkoKX1kaXNhYmxlVmlkZW9TdGF0c092ZXJsYXkoKXt0aGlzLm1lZGlhTWFuYWdlcj8uZGlzYWJsZVN0YXRzT3ZlcmxheSgpfXJlcXVlc3RGdWxsc2NyZWVuKEEpe2NvbnN0IEk9QT8ubG9ja0tleWJvYXJkPz8hMCxnPUE/LmxvY2tQb2ludGVyPz8hMDtpZih0aGlzLmlubmVyQ29udGFpbmVyLnJlcXVlc3RGdWxsc2NyZWVuP3RoaXMuaW5uZXJDb250YWluZXIucmVxdWVzdEZ1bGxzY3JlZW4oe25hdmlnYXRpb25VSTpcImhpZGVcIn0pOnRoaXMuaW5uZXJDb250YWluZXIud2Via2l0UmVxdWVzdEZ1bGxzY3JlZW4oe25hdmlnYXRpb25VSTpcImhpZGVcIn0pLEkmJlwia2V5Ym9hcmRcImluIG5hdmlnYXRvcil0cnl7bmF2aWdhdG9yLmtleWJvYXJkLmxvY2soKX1jYXRjaChBKXt9ZyYmdGhpcy5pbnB1dE1hbmFnZXI/LmxvY2tQb2ludGVyKCl9cGxheSgpe2lmKGcodGhpcyx1ZyxcImZcIikpdGhyb3cgbmV3IFEoXCJBdHRlbXB0ZWQgdG8gcGxheSBhIGRlYWQgc3RyZWFtXCIpO2codGhpcyxsZyxcImZcIik/LmxvZyhcInJlc3VtZWRcIiksdGhpcy5tZWRpYU1hbmFnZXIucGxheSgpLHRoaXMucmF0ZUNvbnRyb2xsZXIuc3RhcnQoKX1wYXVzZSgpe2lmKGcodGhpcyx1ZyxcImZcIikpdGhyb3cgbmV3IFEoXCJBdHRlbXB0ZWQgdG8gcGF1c2UgYSBkZWFkIHN0cmVhbVwiKTtnKHRoaXMsbGcsXCJmXCIpPy5sb2coXCJwYXVzZWRcIiksdGhpcy5tZWRpYU1hbmFnZXIucGF1c2UoKSx0aGlzLnJhdGVDb250cm9sbGVyLnN0b3AoKX1jbG9zZSgpe2codGhpcyxsZyxcImZcIik/LmxvZyhcInN0b3BwZWRcIiksZyh0aGlzLHVnLFwiZlwiKT9nSShZZy5uYW1lLFwiQXR0ZW1wdGVkIHRvIGxlYXZlIGEgZGVhZCBzdHJlYW1cIik6KHRoaXMuc2VuZExvZ2ljKHtkaXNjcmltaW5hdG9yOm1BLmRpc2NyaW1pbmF0b3IsdmFsdWU6e3N0cmVhbUlkOnRoaXMuaWR9fSksdGhpcy5kaXNjYXJkSW5QYXJlbnQoKSx0aGlzLnJlc2l6ZURlYm91bmNlSGFuZGxlJiZjbGVhclRpbWVvdXQodGhpcy5yZXNpemVEZWJvdW5jZUhhbmRsZSksdGhpcy5pbm5lckNvbnRhaW5lci5yZW1vdmVFdmVudExpc3RlbmVyKFwiZm9jdXNcIix0aGlzLnNldFJlbW90ZUNsaXBib2FyZCksdGhpcy5jb250YWluZXJSZXNpemVPYnNlcnZlci5kaXNjb25uZWN0KCksdGhpcy5tZWRpYU1hbmFnZXIudmlkZW9OZWVkc1Jlc3RhcnRFdmVudC5yZW1vdmVIYW5kbGVyKHRoaXMuc2VuZEtleWZyYW1lUmVxdWVzdCksdGhpcy5tZWRpYU1hbmFnZXIudmlkZW9SZWFkeVN0YXRlQ2hhbmdlRXZlbnQucmVtb3ZlSGFuZGxlcih0aGlzLmZlZWRWaWRlb1N0YXRlSW50b1JhdGVDb250cm9sbGVyKSx0aGlzLmlucHV0TWFuYWdlci5kaXNwb3NlKCksdGhpcy5tZWRpYU1hbmFnZXIuZGlzcG9zZSgpLGcodGhpcyxsZyxcImZcIik/LmRpc3Bvc2UoKSx0aGlzLnJhdGVDb250cm9sbGVyLnN0b3AoKSx0aGlzLnJlbW92ZUFsbEV2ZW50TGlzdGVuZXJzKCksQih0aGlzLHVnLCEwLFwiZlwiKSl9ZW1pdENsb3NlKCl7dGhpcy5lbWl0KFwiY2xvc2VcIil9cmVzdW1lQXVkaW8oKXt0aGlzLm1lZGlhTWFuYWdlcj8uYXVkaW9Db250ZXh0Py5yZXN1bWUoKX1lbmFibGVHZXN0dXJlcygpe3RoaXMuaW5wdXRNYW5hZ2VyPy5lbmFibGVHZXN0dXJlcygpfWRpc2FibGVHZXN0dXJlcygpe3RoaXMuaW5wdXRNYW5hZ2VyPy5kaXNhYmxlR2VzdHVyZXMoKX1oYW5kbGVPdXRnb2luZ0lucHV0KEEsSSl7Y29uc3QgQj1mdW5jdGlvbihBKXtzd2l0Y2goQS5kaXNjcmltaW5hdG9yKXtjYXNlIFYuZGlzY3JpbWluYXRvcjpyZXR1cm57dHlwZTpVSS5HYW1lcGFkLC4uLkEudmFsdWV9O2Nhc2Ugai5kaXNjcmltaW5hdG9yOnJldHVybjtjYXNlIFouZGlzY3JpbWluYXRvcjpyZXR1cm57dHlwZTpVSS5Nb3VzZUFic29sdXRlLC4uLkEudmFsdWV9O2Nhc2Ugei5kaXNjcmltaW5hdG9yOnJldHVybnt0eXBlOlVJLk1vdXNlUmVsYXRpdmUsLi4uQS52YWx1ZX07Y2FzZSBfLmRpc2NyaW1pbmF0b3I6cmV0dXJue3R5cGU6VUkuTW91c2VDbGljaywuLi5BLnZhbHVlfTtjYXNlICQuZGlzY3JpbWluYXRvcjpyZXR1cm57dHlwZTpVSS5Nb3VzZVNjcm9sbCwuLi5BLnZhbHVlfTtjYXNlIEFBLmRpc2NyaW1pbmF0b3I6cmV0dXJue3R5cGU6VUkuS2V5Ym9hcmQsYWN0aW9uOkEudmFsdWUuYWN0aW9uLGtleTpBLnZhbHVlLmtleWNvZGV9O2Nhc2UgSUEuZGlzY3JpbWluYXRvcjpyZXR1cm57dHlwZTpVSS5QYXN0ZVRleHQsLi4uQS52YWx1ZX07Y2FzZSBnQS5kaXNjcmltaW5hdG9yOnJldHVybnt0eXBlOlVJLlRvdWNoZXNBYnNvbHV0ZSwuLi5BLnZhbHVlfTtjYXNlIEJBLmRpc2NyaW1pbmF0b3I6cmV0dXJue3R5cGU6VUkuUGVuQWJzb2x1dGUsLi4uQS52YWx1ZX07Y2FzZSBRQS5kaXNjcmltaW5hdG9yOnJldHVybnt0eXBlOlVJLlZpZXdwb3J0UmVzaXplLC4uLkEudmFsdWV9O2Nhc2UgQ0EuZGlzY3JpbWluYXRvcjpyZXR1cm57dHlwZTpVSS5TZXRDbGlwYm9hcmRUZXh0LC4uLkEudmFsdWV9fX0oQSk7aWYoIUIpcmV0dXJuO2xldCBRPSExO3RoaXMuZW1pdChcImJlZm9yZS1pbnB1dFwiLHtpbnB1dDpCLGhlbGRLZXlzOkkscHJldmVudERlZmF1bHQ6KCk9PntRPSEwfX0pLFF8fChnKHRoaXMsbGcsXCJmXCIpPy5jb3VudElucHV0RXZlbnQoKSx0aGlzLnNlbmRCZWJvcElucHV0KEEpKX1zZW5kSW5wdXQoQSl7dGhpcy5zZW5kQmVib3BJbnB1dChmdW5jdGlvbihBKXtzd2l0Y2goQS50eXBlKXtjYXNlIFVJLkdhbWVwYWQ6cmV0dXJue2Rpc2NyaW1pbmF0b3I6Vi5kaXNjcmltaW5hdG9yLHZhbHVlOkF9O2Nhc2UgVUkuTW91c2VBYnNvbHV0ZTpyZXR1cm57ZGlzY3JpbWluYXRvcjpaLmRpc2NyaW1pbmF0b3IsdmFsdWU6QX07Y2FzZSBVSS5Nb3VzZVJlbGF0aXZlOnJldHVybntkaXNjcmltaW5hdG9yOnouZGlzY3JpbWluYXRvcix2YWx1ZTpBfTtjYXNlIFVJLk1vdXNlQ2xpY2s6cmV0dXJue2Rpc2NyaW1pbmF0b3I6Xy5kaXNjcmltaW5hdG9yLHZhbHVlOkF9O2Nhc2UgVUkuTW91c2VTY3JvbGw6cmV0dXJue2Rpc2NyaW1pbmF0b3I6JC5kaXNjcmltaW5hdG9yLHZhbHVlOkF9O2Nhc2UgVUkuS2V5Ym9hcmQ6cmV0dXJue2Rpc2NyaW1pbmF0b3I6QUEuZGlzY3JpbWluYXRvcix2YWx1ZTp7YWN0aW9uOkEuYWN0aW9uLGtleWNvZGU6QS5rZXl9fTtjYXNlIFVJLlBhc3RlVGV4dDpyZXR1cm57ZGlzY3JpbWluYXRvcjpJQS5kaXNjcmltaW5hdG9yLHZhbHVlOkF9O2Nhc2UgVUkuVG91Y2hlc0Fic29sdXRlOnJldHVybntkaXNjcmltaW5hdG9yOmdBLmRpc2NyaW1pbmF0b3IsdmFsdWU6QX07Y2FzZSBVSS5QZW5BYnNvbHV0ZTpyZXR1cm57ZGlzY3JpbWluYXRvcjpCQS5kaXNjcmltaW5hdG9yLHZhbHVlOkF9O2Nhc2UgVUkuVmlld3BvcnRSZXNpemU6cmV0dXJue2Rpc2NyaW1pbmF0b3I6UUEuZGlzY3JpbWluYXRvcix2YWx1ZTpBfTtjYXNlIFVJLlNldENsaXBib2FyZFRleHQ6cmV0dXJue2Rpc2NyaW1pbmF0b3I6Q0EuZGlzY3JpbWluYXRvcix2YWx1ZTpBfTtkZWZhdWx0OnRocm93IG5ldyBRKFwidW5oYW5kbGVkIGlucHV0LnR5cGVcIil9fShBKSl9Z2V0UmVwb3J0KCl7cmV0dXJuIGcodGhpcyxsZyxcImZcIik/LnJlcG9ydH19dWc9bmV3IFdlYWtNYXAsbGc9bmV3IFdlYWtNYXA7Y2xhc3MgdmcgZXh0ZW5kcyBzSXtjb25zdHJ1Y3RvcihBLEksZyxRKXtzdXBlcigpLHRoaXMudHJhbnNwb3J0PVEsa2cuc2V0KHRoaXMsdm9pZCAwKSxVZy5zZXQodGhpcyxpLk5ldyksTmcuc2V0KHRoaXMsbmV3IE1hcCksbWcuc2V0KHRoaXMsbmV3IE1hcCksTWcuc2V0KHRoaXMsdm9pZCAwKSxMZy5zZXQodGhpcyx2b2lkIDApLHRoaXMubGFzdFRpbWVzdGFtcD12b2lkIDAsQih0aGlzLGtnLEEsXCJmXCIpLEIodGhpcyxNZyxJLFwiZlwiKSxCKHRoaXMsTGcsZyxcImZcIiksUS5vblJhaW53YXlNZXNzYWdlPXRoaXMuaGFuZGxlVHJhbnNwb3J0TWVzc2FnZS5iaW5kKHRoaXMpLFEub25DbG9zZT10aGlzLm9uVHJhbnNwb3J0Q2xvc2UuYmluZCh0aGlzKX1nZXQgc3RhdGUoKXtyZXR1cm4gZyh0aGlzLFVnLFwiZlwiKX1nZXQgY29ubmVjdGlvbigpe2lmKGcodGhpcyxrZyxcImZcIikpcmV0dXJuIGcodGhpcyxrZyxcImZcIik7dGhyb3cgbmV3IFEoXCJQZWVyJ3MgUmFpbndheUNvbm5lY3Rpb24gd2FzIGRpc3Bvc2VkLlwiKX1nZXQgZGlzY29ubmVjdGVkKCl7cmV0dXJuIHRoaXMuc3RhdGU9PT1pLkRpc2Nvbm5lY3RlZHx8dGhpcy5zdGF0ZT09PWkuRmFpbGVkfWdldCBzdHJlYW1zKCl7cmV0dXJuIGcodGhpcyxOZyxcImZcIil9Z2V0IGRhdGFDaGFubmVscygpe3JldHVybiBnKHRoaXMsbWcsXCJmXCIpfWdldCBpZCgpe3JldHVybiBnKHRoaXMsTWcsXCJmXCIpfWdldCBleHRlcm5hbElkKCl7cmV0dXJuIGcodGhpcyxMZyxcImZcIil9b25UcmFuc3BvcnRDbG9zZSgpe3RoaXMuYXBwbHlTdGF0ZUNoYW5nZShpLkZhaWxlZCl9YXBwbHlTdGF0ZUNoYW5nZShBKXtpZihCKHRoaXMsVWcsQSxcImZcIiksdGhpcy5lbWl0KFwiY29ubmVjdGlvbi1zdGF0ZS1jaGFuZ2VcIixBKSxBPT09aS5GYWlsZWQpe2Zvcihjb25zdCBBIG9mIGcodGhpcyxOZyxcImZcIikudmFsdWVzKCkpQS5lbWl0Q2xvc2UoKTt0aGlzLmRpc3Bvc2UoKSx0aGlzLmVtaXQoXCJjbG9zZVwiKX19YXN5bmMgc2VuZERldmljZUluZm9BbmRFeGNoYW5nZUNvZGVjcygpe2lmKHRoaXMuZGlzY29ubmVjdGVkKXRocm93IG5ldyBRKFwiQ291bGRuJ3Qgc2VuZCBkZXZpY2UgaW5mbyBhbmQgZXhjaGFuZ2UgY29kZWNzOiBwZWVyIGlzIGRpc2Nvbm5lY3RlZFwiKTt0aGlzLnNlbmREZXZpY2VJbmZvKCk7Y29uc3QgQT1hd2FpdCB0aGlzLmV4Y2hhbmdlQ29kZWNzKCk7aWYoMD09QS5sZW5ndGgpdGhyb3cgbmV3IFEoXCJVbmFibGUgdG8gZmluZCBhIGNvZGVjIHBhaXIgdGhhdCBib3RoIHBlZXJzIGNhbiB1c2VcIik7dGhpcy50cmFuc3BvcnQuc2VuZExvZ2ljRGF0YWdyYW0oe2Rpc2NyaW1pbmF0b3I6a0EuZGlzY3JpbWluYXRvcix2YWx1ZTpXSShBKX0pfWhhbmRsZVRyYW5zcG9ydE1lc3NhZ2UoQSl7XCJMb2dpY1wiPT09QS5raW5kP3RoaXMuaGFuZGxlTG9naWNNZXNzYWdlKEEuYm9keSk6XCJJbnB1dFwiPT09QS5raW5kP3RoaXMuaGFuZGxlSW5wdXRNZXNzYWdlKEEuYm9keSk6XCJNZWRpYVwiPT09QS5raW5kJiZ0aGlzLmhhbmRsZU1lZGlhTWVzc2FnZShBLmJvZHkpfXNlbmREZXZpY2VJbmZvKCl7aWYodGhpcy5kaXNjb25uZWN0ZWQpdGhyb3cgbmV3IFEoXCJDb3VsZG4ndCBzZW5kIGRldmljZSBpbmZvOiBwZWVyIGlzIGRpc2Nvbm5lY3RlZFwiKTt0aGlzLnRyYW5zcG9ydC5zZW5kTG9naWNEYXRhZ3JhbSh7ZGlzY3JpbWluYXRvcjpSQS5kaXNjcmltaW5hdG9yLHZhbHVlOntpc1dlYjohMCxmb3JtRmFjdG9yOmFBLkNvbXB1dGVyLGRldmljZU5hbWU6XCJkZXZpY2VOYW1lXCIsZGV2aWNlSWQ6XCJkZXZpY2VJZFwiLGRldmljZU1vZGVsOlwiXCIsZGV2aWNlT3M6c0EuT3RoZXIsZGV2aWNlT3NWZXJzaW9uOlwiXCIsdXNlckFnZW50Om5hdmlnYXRvci51c2VyQWdlbnR9fSl9c2VuZChBLEkpe2lmKEEuc3RhcnRzV2l0aChcIlJXX1wiKSl0aHJvdyBuZXcgUShcIkRhdGEgY2hhbm5lbCBuYW1lcyBzdGFydGluZyB3aXRoIFJXXyBhcmUgcmVzZXJ2ZWQgZm9yIFJhaW53YXlcIik7aWYodGhpcy5kaXNjb25uZWN0ZWQpdGhyb3cgbmV3IFEoXCJDb3VsZG4ndCBzZW5kIG1lc3NhZ2U6IHBlZXIgaXMgZGlzY29ubmVjdGVkXCIpO2NvbnN0IGc9XCJzdHJpbmdcIj09dHlwZW9mIEk/KG5ldyBUZXh0RW5jb2RlcikuZW5jb2RlKEkpOkk7dGhpcy50cmFuc3BvcnQuc2VuZEFyYml0cmFyeURhdGFncmFtKEEsZyl9Y2xvc2UoKXt0aGlzLmRpc3Bvc2UoKSx0aGlzLnRyYW5zcG9ydC5jbG9zZSgpfWRpc3Bvc2UoKXtmb3IoY29uc3QgQSBvZiBnKHRoaXMsTmcsXCJmXCIpLnZhbHVlcygpKUEuY2xvc2UoKTtCKHRoaXMsa2csdm9pZCAwLFwiZlwiKSxnKHRoaXMsTmcsXCJmXCIpLmNsZWFyKCksZyh0aGlzLG1nLFwiZlwiKS5jbGVhcigpfWFzeW5jIGNyZWF0ZVN0cmVhbShBKXtpZih0aGlzLmRpc2Nvbm5lY3RlZCl0aHJvdyBuZXcgUShcIkNvdWxkbid0IHJlcXVlc3Qgc3RyZWFtOiBwZWVyIGlzIGRpc2Nvbm5lY3RlZFwiKTtjb25zdCBJPWF3YWl0IHRoaXMuZXhjaGFuZ2VDb2RlY3MoKTtpZigwPT1JLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJVbmFibGUgdG8gcmUtbmVnb3RpYXRlIGNvZGVjc1wiKTtyZXR1cm4gdGhpcy50cmFuc3BvcnQuc2VuZExvZ2ljRGF0YWdyYW0oe2Rpc2NyaW1pbmF0b3I6a0EuZGlzY3JpbWluYXRvcix2YWx1ZTpXSShJKX0pLHRoaXMudHJhbnNwb3J0LnNlbmRMb2dpY0RhdGFncmFtKHtkaXNjcmltaW5hdG9yOk5BLmRpc2NyaW1pbmF0b3IsdmFsdWU6e2lucHV0TGV2ZWw6QS5wZXJtaXNzaW9uc319KSxuZXcgUHJvbWlzZSgoKEksZyk9Pnt0aGlzLnJlcXVlc3RlZE9wdGlvbnM9QSx0aGlzLnJlc29sdmVTdHJlYW09SSx0aGlzLnJlamVjdFN0cmVhbT1nfSkpfWFzeW5jIGhhbmRsZUxvZ2ljTWVzc2FnZShBKXtpZihBLmRpc2NyaW1pbmF0b3I9PT1SQS5kaXNjcmltaW5hdG9yKXRoaXMuZGVidWcoXCJHb3QgcmVtb3RlIERldmljZUluZm86XFxuXCIrSlNPTi5zdHJpbmdpZnkoQS52YWx1ZSkpO2Vsc2UgaWYoQS5kaXNjcmltaW5hdG9yPT09dUEuZGlzY3JpbWluYXRvcil0aGlzLnRyYW5zcG9ydC5zZW5kTG9naWNEYXRhZ3JhbSh7ZGlzY3JpbWluYXRvcjpsQS5kaXNjcmltaW5hdG9yLHZhbHVlOnt2aWRlb0NvZGVjczpbXX19KTtlbHNlIGlmKEEuZGlzY3JpbWluYXRvcj09PWxBLmRpc2NyaW1pbmF0b3IpdGhpcy5jb2RlY3NSZXNvbHZlPy4oQS52YWx1ZS52aWRlb0NvZGVjcyk7ZWxzZSBpZihBLmRpc2NyaW1pbmF0b3I9PT1rQS5kaXNjcmltaW5hdG9yKXRoaXMuZGVidWcoXCJHb3QgcmVtb3RlIENsaWVudENhcGFiaWxpdGllczpcXG5cIitKU09OLnN0cmluZ2lmeShBLnZhbHVlKSk7ZWxzZSBpZihBLmRpc2NyaW1pbmF0b3I9PT1OQS5kaXNjcmltaW5hdG9yKXRoaXMud2FybihcIkdvdCByZW1vdGUgU3RyZWFtUmVxdWVzdD9cXG5cIitKU09OLnN0cmluZ2lmeShBLnZhbHVlKSk7ZWxzZSBpZihBLmRpc2NyaW1pbmF0b3I9PT1ZQS5kaXNjcmltaW5hdG9yKWlmKHZvaWQgMCE9PXRoaXMucmVzb2x2ZVN0cmVhbSl7Y29uc3QgST1hd2FpdCB0aGlzLmNyZWF0ZVN0cmVhbUludGVybmFsKEEudmFsdWUuc3RyZWFtSW5mbyx0aGlzLnJlcXVlc3RlZE9wdGlvbnMpO2codGhpcyxOZyxcImZcIikuc2V0KEkuaWQsSSksdGhpcy50cmFuc3BvcnQuc2VuZExvZ2ljRGF0YWdyYW0oe2Rpc2NyaW1pbmF0b3I6cEEuZGlzY3JpbWluYXRvcix2YWx1ZTp7c3RyZWFtSWQ6QS52YWx1ZS5zdHJlYW1JbmZvLnN0cmVhbUlkfX0pLHRoaXMucmVzb2x2ZVN0cmVhbShJKSx0aGlzLnJlc29sdmVTdHJlYW09dm9pZCAwLHRoaXMucmVqZWN0U3RyZWFtPXZvaWQgMCx0aGlzLnJlcXVlc3RlZE9wdGlvbnM9dm9pZCAwfWVsc2UgdGhpcy5lbWl0KFwic3RyZWFtLWFubm91bmNlbWVudFwiLHtpbmZvOkEudmFsdWUuc3RyZWFtSW5mbyxqb2luOmFzeW5jIEk9Pnt0aGlzLmRlYnVnKFwiSm9pbmluZyBzdHJlYW1cIik7Y29uc3QgQj1hd2FpdCB0aGlzLmNyZWF0ZVN0cmVhbUludGVybmFsKEEudmFsdWUuc3RyZWFtSW5mbyxJPz97fSk7cmV0dXJuIGcodGhpcyxOZyxcImZcIikuc2V0KEIuaWQsQiksdGhpcy50cmFuc3BvcnQuc2VuZExvZ2ljRGF0YWdyYW0oe2Rpc2NyaW1pbmF0b3I6cEEuZGlzY3JpbWluYXRvcix2YWx1ZTp7c3RyZWFtSWQ6QS52YWx1ZS5zdHJlYW1JbmZvLnN0cmVhbUlkfX0pLHRoaXMucmVzb2x2ZVN0cmVhbT12b2lkIDAsdGhpcy5yZWplY3RTdHJlYW09dm9pZCAwLEJ9fSk7ZWxzZSBBLmRpc2NyaW1pbmF0b3I9PT1KQS5kaXNjcmltaW5hdG9yP3ZvaWQgMCE9PXRoaXMucmVqZWN0U3RyZWFtPyh0aGlzLnJlamVjdFN0cmVhbShBLnZhbHVlLnJlYXNvbiksdGhpcy5yZXNvbHZlU3RyZWFtPXZvaWQgMCx0aGlzLnJlamVjdFN0cmVhbT12b2lkIDApOnRoaXMud2FybihcIkdvdCBSZWplY3RTdHJlYW1SZXF1ZXN0LCBidXQgZGlkbid0IGFzayBmb3IgYSBzdHJlYW0uXCIpOkEuZGlzY3JpbWluYXRvcj09PW1BLmRpc2NyaW1pbmF0b3I/dGhpcy53YXJuKFwiR290IHJlbW90ZSBMZWF2ZVN0cmVhbT9cXG5cIitKU09OLnN0cmluZ2lmeShBLnZhbHVlKSk6QS5kaXNjcmltaW5hdG9yPT09TUEuZGlzY3JpbWluYXRvcj8odGhpcy5kZWJ1ZyhcIkdvdCByZW1vdGUgU3RyZWFtU3RvcHBpbmc6XFxuXCIrSlNPTi5zdHJpbmdpZnkoQS52YWx1ZSkpLHRoaXMuZGlzY2FyZFN0cmVhbShBLnZhbHVlLnN0cmVhbUlkKSk6QS5kaXNjcmltaW5hdG9yPT09YkEuZGlzY3JpbWluYXRvcnx8KEEuZGlzY3JpbWluYXRvcixQQS5kaXNjcmltaW5hdG9yKX1hc3luYyBjcmVhdGVTdHJlYW1JbnRlcm5hbChBLEkpe2NvbnN0e3N0cmVhbUlkOmd9PUEsQj1uZXcgWWcodGhpcyxnLEEuZGVmYXVsdElucHV0TGV2ZWwsQS5jaG9zZW5BdWRpb0NvbmZpZyxBLmNob3NlblZpZGVvQ29uZmlnLEEuc3RyZWFtVHlwZSxJLChBPT50aGlzLnRyYW5zcG9ydC5zZW5kSW5wdXREYXRhZ3JhbSh7c3RyZWFtSWQ6Zyxpbm5lcjpBfSkpLChBPT50aGlzLnRyYW5zcG9ydC5zZW5kTG9naWNEYXRhZ3JhbShBKSksKCgpPT50aGlzLnRyYW5zcG9ydC5nZXRTdGF0cygpKSwoKCk9PnRoaXMuZGlzY2FyZFN0cmVhbShnKSkpO3JldHVybiBhd2FpdCBCLmluaXRpYWxpemUoKSxCfWRpc2NhcmRTdHJlYW0oQSl7Zyh0aGlzLE5nLFwiZlwiKS5kZWxldGUoQSl9aGFuZGxlSW5wdXRNZXNzYWdlKEEpe2NvbnN0IEk9QS5pbm5lcjtpZihJLmRpc2NyaW1pbmF0b3I9PT1qLmRpc2NyaW1pbmF0b3Ipe2NvbnN0IEE9SS52YWx1ZS5sZWZ0TW90b3JTcGVlZCxnPUkudmFsdWUucmlnaHRNb3RvclNwZWVkO3BJLnZpYnJhdGVHYW1lcGFkKEkudmFsdWUucG9ydCx7ZHVyYXRpb246MTAwLHN0YXJ0RGVsYXk6MCxzdHJvbmdNYWduaXR1ZGU6TWF0aC5tYXgoQSxnKS82NTUzNSx3ZWFrTWFnbml0dWRlOjB9KX1lbHNlIGlmKEkuZGlzY3JpbWluYXRvcj09PUNBLmRpc2NyaW1pbmF0b3Ipe2NvbnN0IEE9SS52YWx1ZS50ZXh0O1wiZnVuY3Rpb25cIj09dHlwZW9mIG5hdmlnYXRvcj8uY2xpcGJvYXJkPy53cml0ZVRleHQmJm5hdmlnYXRvci5jbGlwYm9hcmQud3JpdGVUZXh0KEEpLnRoZW4oKCgpPT57fSkpfWVsc2UgdGhpcy53YXJuKGBJZ25vcmluZyB1bnJlY29nbml6ZWQgSW5wdXQgZGlzY3JpbWluYXRvciAke0kuZGlzY3JpbWluYXRvcn1gKX1oYW5kbGVNZWRpYU1lc3NhZ2UoQSl7aWYoQS5kaXNjcmltaW5hdG9yPT09WEEuZGlzY3JpbWluYXRvcil7Y29uc3R7ZGF0YTpJLHNlZ21lbnRUaW1lOkIsdHlwZTpRLGRlc2t0b3BSZWN0OkMsbWFzazplLHN0cmVhbUlkOml9PUEudmFsdWUsdD1nKHRoaXMsTmcsXCJmXCIpLmdldChpKTtpZighdClyZXR1cm47Y29uc3QgRT1JLmJ1ZmZlci5zbGljZShJLmJ5dGVPZmZzZXQsSS5ieXRlT2Zmc2V0K0kubGVuZ3RoKSxvPTFlLTQqTnVtYmVyKEIpO1E9PT1XQS5GcmFtZURpZmYmJnZvaWQgMCE9PXRoaXMubGFzdFRpbWVzdGFtcCYmby10aGlzLmxhc3RUaW1lc3RhbXA8MyYmdGhpcy53YXJuKGBEaWZmZXJlbmNlIGJldHdlZW4gc3VjY2Vzc2l2ZSB0aW1lc3RhbXBzIHdhcyAkeyhvLXRoaXMubGFzdFRpbWVzdGFtcCkudG9GaXhlZCgxKX1gKSxRIT09V0EuTWV0YWRhdGEmJih0aGlzLmxhc3RUaW1lc3RhbXA9byksdC5yZW5kZXJWaWRlb0ZyYW1lKHtoZWFkZXI6e3RpbWVzdGFtcDpvLHg6Qy5sZWZ0LHk6Qy50b3Asd2lkdGg6Qy53aWR0aCxoZWlnaHQ6Qy5oZWlnaHQsbWFzazplfSxkYXRhOkV9KX1lbHNlIGlmKEEuZGlzY3JpbWluYXRvcj09PVZBLmRpc2NyaW1pbmF0b3Ipe2NvbnN0IEk9Zyh0aGlzLE5nLFwiZlwiKS5nZXQoQS52YWx1ZS5zdHJlYW1JZCk7aWYoIUkpcmV0dXJuO0kucHJvY2Vzc0N1cnNvcih7eDpBLnZhbHVlLnBvc2l0aW9uWCx5OkEudmFsdWUucG9zaXRpb25ZLHNwb3RYOkEudmFsdWUuc3BvdFgsc3BvdFk6QS52YWx1ZS5zcG90WSxzaGFwZVdpZHRoOkEudmFsdWUuc2hhcGVXaWR0aCxzaGFwZUhlaWdodDpBLnZhbHVlLnNoYXBlSGVpZ2h0LGV4dGVudFdpZHRoOkEudmFsdWUubW9uaXRvcldpZHRoLGV4dGVudEhlaWdodDpBLnZhbHVlLm1vbml0b3JIZWlnaHQsdmlzaWJsZTpBLnZhbHVlLnZpc2libGUsaGFzUG9pbnRlckltYWdlOkEudmFsdWUuZGF0YS5sZW5ndGg+MCxwb2ludGVySW1hZ2U6QS52YWx1ZS5kYXRhfSl9ZWxzZSBpZihBLmRpc2NyaW1pbmF0b3I9PT1qQS5kaXNjcmltaW5hdG9yKXtjb25zdCBJPWcodGhpcyxOZyxcImZcIikuZ2V0KEEudmFsdWUuc3RyZWFtSWQpO2lmKCFJKXJldHVybjtjb25zdHtkYXRhOkJ9PUEudmFsdWUsUT1CLmJ1ZmZlci5zbGljZShCLmJ5dGVPZmZzZXQsQi5ieXRlT2Zmc2V0K0IubGVuZ3RoKTtJLnByb2Nlc3NBdWRpbyhRKX19YXN5bmMgZXhjaGFuZ2VDb2RlY3MoKXtpZih0aGlzLmRpc2Nvbm5lY3RlZCl0aHJvdyBuZXcgUShcIkNvdWxkbid0IGV4Y2hhbmdlIGNvZGVjczogcGVlciBpcyBkaXNjb25uZWN0ZWRcIik7Y29uc3QgQT1hd2FpdCBuZXcgUHJvbWlzZSgoQT0+e3RoaXMudHJhbnNwb3J0LnNlbmRMb2dpY0RhdGFncmFtKHtkaXNjcmltaW5hdG9yOnVBLmRpc2NyaW1pbmF0b3IsdmFsdWU6e319KSx0aGlzLmNvZGVjc1Jlc29sdmU9QX0pKTtyZXR1cm4gdGhpcy5jb2RlY3NSZXNvbHZlPXZvaWQgMCxBfWFzeW5jIGNyZWF0ZURhdGFDaGFubmVsKEEpe2lmKEEuaWQuc3RhcnRzV2l0aChcIlJXX1wiKSl0aHJvdyBuZXcgUShcIkRhdGEgY2hhbm5lbCBuYW1lcyBzdGFydGluZyB3aXRoIFJXXyBhcmUgcmVzZXJ2ZWQgZm9yIFJhaW53YXlcIik7YXdhaXQgdGhpcy50cmFuc3BvcnQuY3JlYXRlRGF0YUNoYW5uZWwoQS5pZCxBLm1vZGUpO2NvbnN0IEk9bmV3IGRJKEEsdGhpcyk7cmV0dXJuIGcodGhpcyxtZyxcImZcIikuc2V0KEEuaWQsSSksSX1hc3luYyBmb3JjZVN0cmVhbUFubm91bmNlbWVudHMoKXtpZih0aGlzLmRpc2Nvbm5lY3RlZCl0aHJvdyBuZXcgUShcIkNvdWxkbid0IGZvcmNlU3RyZWFtQW5ub3VuY2VtZW50cy4gUGVlciBkaXNjb25uZWN0ZWQuXCIpO3RoaXMudHJhbnNwb3J0LnNlbmRMb2dpY0RhdGFncmFtKHtkaXNjcmltaW5hdG9yOnZBLmRpc2NyaW1pbmF0b3IsdmFsdWU6e319KX1kZWJ1ZyhBKXtRSSh2Zy5uYW1lLEEpfXdhcm4oQSl7Z0kodmcubmFtZSxBKX19a2c9bmV3IFdlYWtNYXAsVWc9bmV3IFdlYWtNYXAsTmc9bmV3IFdlYWtNYXAsbWc9bmV3IFdlYWtNYXAsTWc9bmV3IFdlYWtNYXAsTGc9bmV3IFdlYWtNYXA7Y2xhc3MgYmcgZXh0ZW5kcyBzSXtjb25zdHJ1Y3RvcihBLEkpe3N1cGVyKCksZmcuc2V0KHRoaXMsdm9pZCAwKSxwZy5zZXQodGhpcyxuZXcgTWFwKSx0aGlzLmNvbm5lY3Rpb25UcmFuc3BvcnRzPW5ldyBNYXAsdGhpcy5kb2N1bWVudFZpc2liaWxpdHlDaGFuZ2VIYW5kbGVyPSgpPT57aWYoZG9jdW1lbnQuaGlkZGVuKWZvcihjb25zdCBBIG9mIHRoaXMucGVlcnMudmFsdWVzKCkpZm9yKGNvbnN0IEkgb2YgQS5zdHJlYW1zLnZhbHVlcygpKUkucmVsZWFzZUtleXMoKSxJLnBhdXNlKCk7ZWxzZSBmb3IoY29uc3QgQSBvZiB0aGlzLnBlZXJzLnZhbHVlcygpKWZvcihjb25zdCBJIG9mIEEuc3RyZWFtcy52YWx1ZXMoKSlJLnBsYXkoKX0sdGhpcy53aW5kb3dCbHVySGFuZGxlcj0oKT0+e2Zvcihjb25zdCBBIG9mIHRoaXMucGVlcnMudmFsdWVzKCkpZm9yKGNvbnN0IEkgb2YgQS5zdHJlYW1zLnZhbHVlcygpKUkucmVsZWFzZUtleXMoKX0sQih0aGlzLGZnLEEsXCJmXCIpLHRoaXMuY29uZmlnPUksdGhpcy5nYXRld2F5PW5ldyBvSShnKHRoaXMsZmcsXCJmXCIpLHRoaXMuY29uZmlnLmFwaUtleSx0aGlzLmNvbmZpZy5leHRlcm5hbElkPz9cIlwiLChBPT50aGlzLmhhbmRsZVBlZXJJbmZvKEEpKSwoQT0+dGhpcy5lbWl0KFwicGVlci1yZXF1ZXN0XCIsQSkpLCgoQSxJLGcpPT50aGlzLmFkZFBlZXIoQSxJLGcsXCJhbnN3ZXJcIikpKSx0aGlzLmdhdGV3YXkuY29ubmVjdGlvbkxvc3RFdmVudC5hZGRIYW5kbGVyKChBPT57dGhpcy5lbWl0KFwiY2xvc2VcIixBKSx0aGlzLmRpc2Nvbm5lY3RBbGxQZWVycygpfSkpfWdldCBwZWVycygpe3JldHVyblsuLi5nKHRoaXMscGcsXCJmXCIpLnZhbHVlcygpXX1hc3luYyBpbml0aWFsaXplKCl7YXdhaXQgdGhpcy5nYXRld2F5LmNvbm5lY3QoKSx0aGlzLmFkZExpc3RlbmVycygpfWdldCBpZCgpe3JldHVybiBnKHRoaXMsZmcsXCJmXCIpfWdldCBleHRlcm5hbElkKCl7cmV0dXJuIHRoaXMuY29uZmlnLmV4dGVybmFsSWR9YXN5bmMgY29ubmVjdChBKXtpZihhd2FpdCB0aGlzLmdhdGV3YXkuY29ubmVjdCgpLGcodGhpcyxwZyxcImZcIikuaGFzKEEpKXRocm93IG5ldyBRKGBBbHJlYWR5IGNvbm5lY3RlZCB0byAke0F9YCk7Y29uc3QgST1hd2FpdCB0aGlzLmdhdGV3YXkuY29ubmVjdFRvSG9zdChBLG8uU0NUUCk7aWYoSS5jYW5jZWxlZCl0aHJvdyBuZXcgUShcIlRoZSBjb25uZWN0aW9uIGF0dGVtcHQgd2FzIGNhbmNlbGVkLlwiKTtpZighSS5hY2NlcHRlZCl0aHJvdyBuZXcgUShgVGhlIHBlZXIgYXQgJHtBfSByZWplY3RlZCB0aGUgY29ubmVjdGlvbiwgd2l0aCByZWFzb246ICR7SS5yZWFzb259YCk7cmV0dXJuIGF3YWl0IHRoaXMuYWRkUGVlcihBLEkuaG9zdEV4dGVybmFsSWQsSS5jb25uZWN0aW9uUmVxdWVzdElkLFwib2ZmZXJcIil9YXN5bmMgYWRkUGVlcihBLEksQixRKXtjb25zdCBDPW5ldyBESShnKHRoaXMsZmcsXCJmXCIpLEEsKEk9PnRoaXMuZ2F0ZXdheS5zZW5kT2ZmZXIoQSxJKSksKEk9PnRoaXMuZ2F0ZXdheS5zZW5kQW5zd2VyKEEsSSkpLChJPT50aGlzLmdhdGV3YXkuc2VuZENhbmRpZGF0ZShBLEkpKSwoQT0+e2UuYXBwbHlTdGF0ZUNoYW5nZShBKX0pKSxlPW5ldyB2Zyh0aGlzLEEsSSxDKTtlLmFkZEV2ZW50TGlzdGVuZXIoXCJjbG9zZVwiLCgoKT0+e3RoaXMuZ2F0ZXdheS5kZWxldGVDb25uZWN0aW9uKEEpLGcodGhpcyxwZyxcImZcIikuZGVsZXRlKEEpfSkpLHRoaXMuY29ubmVjdGlvblRyYW5zcG9ydHMuc2V0KEIsQyksQy5vbkFwcGxpY2F0aW9uTWVzc2FnZT0oQSxJKT0+ZS5kYXRhQ2hhbm5lbHMuZ2V0KEEpPy5fZW1pdChJKTt0cnl7YXdhaXQgQy5vcGVuKFEpfWZpbmFsbHl7dGhpcy5jb25uZWN0aW9uVHJhbnNwb3J0cy5kZWxldGUoQil9cmV0dXJuIGF3YWl0IGUuc2VuZERldmljZUluZm9BbmRFeGNoYW5nZUNvZGVjcygpLGcodGhpcyxwZyxcImZcIikuc2V0KEEsZSksZX1jYW5jZWxDb25uZWN0aW9uQXR0ZW1wdChBKXt0aGlzLmdhdGV3YXkuY2FuY2VsQ29ubmVjdGlvbkF0dGVtcHQoQSl9aGFuZGxlUGVlckluZm8oQSl7Y29uc3QgST10aGlzLmNvbm5lY3Rpb25UcmFuc3BvcnRzLmdldChBLmlkKTt2b2lkIDAhPT1JP0kuaGFuZGxlUGVlckluZm8oQSk6QS50eXBlIT09YS5DYW5kaWRhdGUmJmdJKGJnLm5hbWUsXCJHb3QgcGVlciBpbmZvIGZvciB1bmV4cGVjdGVkIENSSUQ/IFwiK0EuaWQpfWRpc2Nvbm5lY3RBbGxQZWVycygpe2Zvcihjb25zdCBBIG9mIGcodGhpcyxwZyxcImZcIikudmFsdWVzKCkpQS5jbG9zZSgpO2codGhpcyxwZyxcImZcIikuY2xlYXIoKX1hZGRMaXN0ZW5lcnMoKXt3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcImJsdXJcIix0aGlzLndpbmRvd0JsdXJIYW5kbGVyKSxkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwidmlzaWJpbGl0eWNoYW5nZVwiLHRoaXMuZG9jdW1lbnRWaXNpYmlsaXR5Q2hhbmdlSGFuZGxlcil9cmVtb3ZlTGlzdGVuZXJzKCl7d2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJibHVyXCIsdGhpcy53aW5kb3dCbHVySGFuZGxlciksZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInZpc2liaWxpdHljaGFuZ2VcIix0aGlzLmRvY3VtZW50VmlzaWJpbGl0eUNoYW5nZUhhbmRsZXIpfWNsb3NlKCl7dGhpcy5kaXNjb25uZWN0QWxsUGVlcnMoKSx0aGlzLmNvbm5lY3Rpb25UcmFuc3BvcnRzLmNsZWFyKCksdGhpcy5nYXRld2F5LmRpc2Nvbm5lY3QoKSx0aGlzLnJlbW92ZUxpc3RlbmVycygpfX1mZz1uZXcgV2Vha01hcCxwZz1uZXcgV2Vha01hcCwoSGc9RGF0YVZpZXcucHJvdG90eXBlKS5zZXRCaWdVaW50NjQ/PyhIZy5zZXRCaWdVaW50NjQ9ZnVuY3Rpb24oQSxJLGcpe2NvbnN0IEI9QmlnSW50KDQyOTQ5NjcyOTUpLFE9TnVtYmVyKEk+PkJpZ0ludCgzMikmQiksQz1OdW1iZXIoSSZCKSxbZSxpXT1nP1s0LDBdOlswLDRdO3RoaXMuc2V0VWludDMyKEErZSxRLGcpLHRoaXMuc2V0VWludDMyKEEraSxDLGcpfSksKEpnPURhdGFWaWV3LnByb3RvdHlwZSkuZ2V0QmlnVWludDY0Pz8oSmcuZ2V0QmlnVWludDY0PWZ1bmN0aW9uKEEsSSl7Y29uc3RbZyxCXT1JP1s0LDBdOlswLDRdLFE9QmlnSW50KHRoaXMuZ2V0VWludDMyKEErZyxJKSksQz1CaWdJbnQodGhpcy5nZXRVaW50MzIoQStCLEkpKTtyZXR1cm4gUTw8QmlnSW50KDMyKXxDfSk7Y29uc3QgUGc9bmV3IGNsYXNzIGV4dGVuZHMgc0l7Y29uc3RydWN0b3IoKXtzdXBlciguLi5hcmd1bWVudHMpLHRoaXMudmVyc2lvbj1cIjAuMy4wLWJldGEuMVwifWdldE1lZGlhQ2FwYWJpbGl0aWVzKEEpe3JldHVybiBuYXZpZ2F0b3IubWVkaWFDYXBhYmlsaXRpZXMuZGVjb2RpbmdJbmZvKEEpfWFzeW5jIGNvbm5lY3QoQSl7Y29uc3QgST1hd2FpdCB0SShBLmFwaUtleSksZz1uZXcgYmcoSSxBKTtyZXR1cm4gYXdhaXQgZy5pbml0aWFsaXplKCksZ319OyRBPXtvbkxvZzooQSxJLGcpPT57UGcuZW1pdChcImxvZ1wiLEEsSSxnKX19O2V4cG9ydHtoQSBhcyBBdWRpb0NvZGVjLGRBIGFzIEF1ZGlvQ29udGFpbmVyLEsgYXMgQnV0dG9uQWN0aW9uLG5JIGFzIERhdGFDaGFubmVsTW9kZSx5QSBhcyBJbnB1dExldmVsLFVJIGFzIElucHV0VHlwZSxlIGFzIExvZ0xldmVsLHEgYXMgTW91c2VCdXR0b24saSBhcyBQZWVyU3RhdGUsTyBhcyBQZW5GbGFncyxUIGFzIFBlbk1hc2ssWSBhcyBTY3JvbGxBeGlzLGRnIGFzIFN0cmVhbUZpdCxGQSBhcyBTdHJlYW1UeXBlLFcgYXMgVG91Y2hNYXNrLHRBIGFzIFZpZGVvQ29kZWNUeXBlLGNBIGFzIFZpZGVvQ29udGFpbmVyLE5JIGFzIFZpZGVvUmVhZHlTdGF0ZSxiIGFzIFZpcnR1YWxLZXksUCBhcyBXaW5kb3dzUG9pbnRlckZsYWdzLEogYXMgWElucHV0QnV0dG9ucyxQZyBhcyBkZWZhdWx0fTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5CZWJvcFZpZXcgPSBleHBvcnRzLkJlYm9wUnVudGltZUVycm9yID0gdm9pZCAwO1xuY29uc3QgaGV4RGlnaXRzID0gXCIwMTIzNDU2Nzg5YWJjZGVmXCI7XG5jb25zdCBhc2NpaVRvSGV4ID0gW1xuICAgIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsXG4gICAgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCxcbiAgICAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLFxuICAgIDAsIDEsIDIsIDMsIDQsIDUsIDYsIDcsIDgsIDksIDAsIDAsIDAsIDAsIDAsIDAsXG4gICAgMCwgMTAsIDExLCAxMiwgMTMsIDE0LCAxNSwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCxcbiAgICAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLFxuICAgIDAsIDEwLCAxMSwgMTIsIDEzLCAxNCwgMTUsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsXG4gICAgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMFxuXTtcbmNvbnN0IGVtcHR5Qnl0ZUFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoMCk7XG5jb25zdCBlbXB0eVN0cmluZyA9IFwiXCI7XG5jb25zdCBieXRlVG9IZXggPSBbXTsgLy8gQSBsb29rdXAgdGFibGU6IFsnMDAnLCAnMDEnLCAuLi4sICdmZiddXG5mb3IgKGNvbnN0IHggb2YgaGV4RGlnaXRzKSB7XG4gICAgZm9yIChjb25zdCB5IG9mIGhleERpZ2l0cykge1xuICAgICAgICBieXRlVG9IZXgucHVzaCh4ICsgeSk7XG4gICAgfVxufVxuaWYgKHR5cGVvZiByZXF1aXJlICE9PSAndW5kZWZpbmVkJykge1xuICAgIGlmICh0eXBlb2YgVGV4dERlY29kZXIgPT09ICd1bmRlZmluZWQnKVxuICAgICAgICBnbG9iYWwuVGV4dERlY29kZXIgPSByZXF1aXJlKCd1dGlsJykuVGV4dERlY29kZXI7XG59XG5jbGFzcyBCZWJvcFJ1bnRpbWVFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlKSB7XG4gICAgICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgICAgICB0aGlzLm5hbWUgPSBcIkJlYm9wUnVudGltZUVycm9yXCI7XG4gICAgfVxufVxuZXhwb3J0cy5CZWJvcFJ1bnRpbWVFcnJvciA9IEJlYm9wUnVudGltZUVycm9yO1xuY2xhc3MgQmVib3BWaWV3IHtcbiAgICBzdGF0aWMgdGV4dERlY29kZXIgPSBuZXcgVGV4dERlY29kZXIoKTtcbiAgICBzdGF0aWMgd3JpdGVCdWZmZXIgPSBuZXcgVWludDhBcnJheSgyNTYpO1xuICAgIHN0YXRpYyB3cml0ZUJ1ZmZlclZpZXcgPSBuZXcgRGF0YVZpZXcoQmVib3BWaWV3LndyaXRlQnVmZmVyLmJ1ZmZlcik7XG4gICAgc3RhdGljIGluc3RhbmNlO1xuICAgIHN0YXRpYyBnZXRJbnN0YW5jZSgpIHtcbiAgICAgICAgaWYgKCFCZWJvcFZpZXcuaW5zdGFuY2UpIHtcbiAgICAgICAgICAgIEJlYm9wVmlldy5pbnN0YW5jZSA9IG5ldyBCZWJvcFZpZXcoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gQmVib3BWaWV3Lmluc3RhbmNlO1xuICAgIH1cbiAgICBtaW5pbXVtVGV4dERlY29kZXJMZW5ndGggPSAzMDA7XG4gICAgYnVmZmVyO1xuICAgIHZpZXc7XG4gICAgaW5kZXg7IC8vIHJlYWQgcG9pbnRlclxuICAgIGxlbmd0aDsgLy8gd3JpdGUgcG9pbnRlclxuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmJ1ZmZlciA9IEJlYm9wVmlldy53cml0ZUJ1ZmZlcjtcbiAgICAgICAgdGhpcy52aWV3ID0gQmVib3BWaWV3LndyaXRlQnVmZmVyVmlldztcbiAgICAgICAgdGhpcy5pbmRleCA9IDA7XG4gICAgICAgIHRoaXMubGVuZ3RoID0gMDtcbiAgICB9XG4gICAgc3RhcnRSZWFkaW5nKGJ1ZmZlcikge1xuICAgICAgICB0aGlzLmJ1ZmZlciA9IGJ1ZmZlcjtcbiAgICAgICAgdGhpcy52aWV3ID0gbmV3IERhdGFWaWV3KHRoaXMuYnVmZmVyLmJ1ZmZlciwgdGhpcy5idWZmZXIuYnl0ZU9mZnNldCwgdGhpcy5idWZmZXIuYnl0ZUxlbmd0aCk7XG4gICAgICAgIHRoaXMuaW5kZXggPSAwO1xuICAgICAgICB0aGlzLmxlbmd0aCA9IGJ1ZmZlci5sZW5ndGg7XG4gICAgfVxuICAgIHN0YXJ0V3JpdGluZygpIHtcbiAgICAgICAgdGhpcy5idWZmZXIgPSBCZWJvcFZpZXcud3JpdGVCdWZmZXI7XG4gICAgICAgIHRoaXMudmlldyA9IEJlYm9wVmlldy53cml0ZUJ1ZmZlclZpZXc7XG4gICAgICAgIHRoaXMuaW5kZXggPSAwO1xuICAgICAgICB0aGlzLmxlbmd0aCA9IDA7XG4gICAgfVxuICAgIGd1YXJhbnRlZUJ1ZmZlckxlbmd0aChsZW5ndGgpIHtcbiAgICAgICAgaWYgKGxlbmd0aCA+IHRoaXMuYnVmZmVyLmxlbmd0aCkge1xuICAgICAgICAgICAgY29uc3QgZGF0YSA9IG5ldyBVaW50OEFycmF5KGxlbmd0aCA8PCAxKTtcbiAgICAgICAgICAgIGRhdGEuc2V0KHRoaXMuYnVmZmVyKTtcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyID0gZGF0YTtcbiAgICAgICAgICAgIHRoaXMudmlldyA9IG5ldyBEYXRhVmlldyhkYXRhLmJ1ZmZlcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ3Jvd0J5KGFtb3VudCkge1xuICAgICAgICB0aGlzLmxlbmd0aCArPSBhbW91bnQ7XG4gICAgICAgIHRoaXMuZ3VhcmFudGVlQnVmZmVyTGVuZ3RoKHRoaXMubGVuZ3RoKTtcbiAgICB9XG4gICAgc2tpcChhbW91bnQpIHtcbiAgICAgICAgdGhpcy5pbmRleCArPSBhbW91bnQ7XG4gICAgfVxuICAgIHRvQXJyYXkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJ1ZmZlci5zdWJhcnJheSgwLCB0aGlzLmxlbmd0aCk7XG4gICAgfVxuICAgIHJlYWRCeXRlKCkgeyByZXR1cm4gdGhpcy5idWZmZXJbdGhpcy5pbmRleCsrXTsgfVxuICAgIHJlYWRVaW50MTYoKSB7IGNvbnN0IHJlc3VsdCA9IHRoaXMudmlldy5nZXRVaW50MTYodGhpcy5pbmRleCwgdHJ1ZSk7IHRoaXMuaW5kZXggKz0gMjsgcmV0dXJuIHJlc3VsdDsgfVxuICAgIHJlYWRJbnQxNigpIHsgY29uc3QgcmVzdWx0ID0gdGhpcy52aWV3LmdldEludDE2KHRoaXMuaW5kZXgsIHRydWUpOyB0aGlzLmluZGV4ICs9IDI7IHJldHVybiByZXN1bHQ7IH1cbiAgICByZWFkVWludDMyKCkgeyBjb25zdCByZXN1bHQgPSB0aGlzLnZpZXcuZ2V0VWludDMyKHRoaXMuaW5kZXgsIHRydWUpOyB0aGlzLmluZGV4ICs9IDQ7IHJldHVybiByZXN1bHQ7IH1cbiAgICByZWFkSW50MzIoKSB7IGNvbnN0IHJlc3VsdCA9IHRoaXMudmlldy5nZXRJbnQzMih0aGlzLmluZGV4LCB0cnVlKTsgdGhpcy5pbmRleCArPSA0OyByZXR1cm4gcmVzdWx0OyB9XG4gICAgcmVhZFVpbnQ2NCgpIHsgY29uc3QgcmVzdWx0ID0gdGhpcy52aWV3LmdldEJpZ1VpbnQ2NCh0aGlzLmluZGV4LCB0cnVlKTsgdGhpcy5pbmRleCArPSA4OyByZXR1cm4gcmVzdWx0OyB9XG4gICAgcmVhZEludDY0KCkgeyBjb25zdCByZXN1bHQgPSB0aGlzLnZpZXcuZ2V0QmlnSW50NjQodGhpcy5pbmRleCwgdHJ1ZSk7IHRoaXMuaW5kZXggKz0gODsgcmV0dXJuIHJlc3VsdDsgfVxuICAgIHJlYWRGbG9hdDMyKCkgeyBjb25zdCByZXN1bHQgPSB0aGlzLnZpZXcuZ2V0RmxvYXQzMih0aGlzLmluZGV4LCB0cnVlKTsgdGhpcy5pbmRleCArPSA0OyByZXR1cm4gcmVzdWx0OyB9XG4gICAgcmVhZEZsb2F0NjQoKSB7IGNvbnN0IHJlc3VsdCA9IHRoaXMudmlldy5nZXRGbG9hdDY0KHRoaXMuaW5kZXgsIHRydWUpOyB0aGlzLmluZGV4ICs9IDg7IHJldHVybiByZXN1bHQ7IH1cbiAgICB3cml0ZUJ5dGUodmFsdWUpIHsgY29uc3QgaW5kZXggPSB0aGlzLmxlbmd0aDsgdGhpcy5ncm93QnkoMSk7IHRoaXMuYnVmZmVyW2luZGV4XSA9IHZhbHVlOyB9XG4gICAgd3JpdGVVaW50MTYodmFsdWUpIHsgY29uc3QgaW5kZXggPSB0aGlzLmxlbmd0aDsgdGhpcy5ncm93QnkoMik7IHRoaXMudmlldy5zZXRVaW50MTYoaW5kZXgsIHZhbHVlLCB0cnVlKTsgfVxuICAgIHdyaXRlSW50MTYodmFsdWUpIHsgY29uc3QgaW5kZXggPSB0aGlzLmxlbmd0aDsgdGhpcy5ncm93QnkoMik7IHRoaXMudmlldy5zZXRJbnQxNihpbmRleCwgdmFsdWUsIHRydWUpOyB9XG4gICAgd3JpdGVVaW50MzIodmFsdWUpIHsgY29uc3QgaW5kZXggPSB0aGlzLmxlbmd0aDsgdGhpcy5ncm93QnkoNCk7IHRoaXMudmlldy5zZXRVaW50MzIoaW5kZXgsIHZhbHVlLCB0cnVlKTsgfVxuICAgIHdyaXRlSW50MzIodmFsdWUpIHsgY29uc3QgaW5kZXggPSB0aGlzLmxlbmd0aDsgdGhpcy5ncm93QnkoNCk7IHRoaXMudmlldy5zZXRJbnQzMihpbmRleCwgdmFsdWUsIHRydWUpOyB9XG4gICAgd3JpdGVVaW50NjQodmFsdWUpIHsgY29uc3QgaW5kZXggPSB0aGlzLmxlbmd0aDsgdGhpcy5ncm93QnkoOCk7IHRoaXMudmlldy5zZXRCaWdVaW50NjQoaW5kZXgsIHZhbHVlLCB0cnVlKTsgfVxuICAgIHdyaXRlSW50NjQodmFsdWUpIHsgY29uc3QgaW5kZXggPSB0aGlzLmxlbmd0aDsgdGhpcy5ncm93QnkoOCk7IHRoaXMudmlldy5zZXRCaWdJbnQ2NChpbmRleCwgdmFsdWUsIHRydWUpOyB9XG4gICAgd3JpdGVGbG9hdDMyKHZhbHVlKSB7IGNvbnN0IGluZGV4ID0gdGhpcy5sZW5ndGg7IHRoaXMuZ3Jvd0J5KDQpOyB0aGlzLnZpZXcuc2V0RmxvYXQzMihpbmRleCwgdmFsdWUsIHRydWUpOyB9XG4gICAgd3JpdGVGbG9hdDY0KHZhbHVlKSB7IGNvbnN0IGluZGV4ID0gdGhpcy5sZW5ndGg7IHRoaXMuZ3Jvd0J5KDgpOyB0aGlzLnZpZXcuc2V0RmxvYXQ2NChpbmRleCwgdmFsdWUsIHRydWUpOyB9XG4gICAgcmVhZEJ5dGVzKCkge1xuICAgICAgICBjb25zdCBsZW5ndGggPSB0aGlzLnJlYWRVaW50MzIoKTtcbiAgICAgICAgaWYgKGxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIGVtcHR5Qnl0ZUFycmF5O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHN0YXJ0ID0gdGhpcy5pbmRleCwgZW5kID0gc3RhcnQgKyBsZW5ndGg7XG4gICAgICAgIHRoaXMuaW5kZXggPSBlbmQ7XG4gICAgICAgIHJldHVybiB0aGlzLmJ1ZmZlci5zdWJhcnJheShzdGFydCwgZW5kKTtcbiAgICB9XG4gICAgd3JpdGVCeXRlcyh2YWx1ZSkge1xuICAgICAgICBjb25zdCBieXRlQ291bnQgPSB2YWx1ZS5sZW5ndGg7XG4gICAgICAgIHRoaXMud3JpdGVVaW50MzIoYnl0ZUNvdW50KTtcbiAgICAgICAgaWYgKGJ5dGVDb3VudCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGluZGV4ID0gdGhpcy5sZW5ndGg7XG4gICAgICAgIHRoaXMuZ3Jvd0J5KGJ5dGVDb3VudCk7XG4gICAgICAgIHRoaXMuYnVmZmVyLnNldCh2YWx1ZSwgaW5kZXgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWFkcyBhIGxlbmd0aC1wcmVmaXhlZCBVVEYtOC1lbmNvZGVkIHN0cmluZy5cbiAgICAgKi9cbiAgICByZWFkU3RyaW5nKCkge1xuICAgICAgICBjb25zdCBsZW5ndGhCeXRlcyA9IHRoaXMucmVhZFVpbnQzMigpO1xuICAgICAgICAvLyBiYWlsIG91dCBlYXJseSBvbiBhbiBlbXB0eSBzdHJpbmdcbiAgICAgICAgaWYgKGxlbmd0aEJ5dGVzID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gZW1wdHlTdHJpbmc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxlbmd0aEJ5dGVzID49IHRoaXMubWluaW11bVRleHREZWNvZGVyTGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gQmVib3BWaWV3LnRleHREZWNvZGVyLmRlY29kZSh0aGlzLmJ1ZmZlci5zdWJhcnJheSh0aGlzLmluZGV4LCB0aGlzLmluZGV4ICs9IGxlbmd0aEJ5dGVzKSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZW5kID0gdGhpcy5pbmRleCArIGxlbmd0aEJ5dGVzO1xuICAgICAgICBsZXQgcmVzdWx0ID0gXCJcIjtcbiAgICAgICAgbGV0IGNvZGVQb2ludDtcbiAgICAgICAgd2hpbGUgKHRoaXMuaW5kZXggPCBlbmQpIHtcbiAgICAgICAgICAgIC8vIGRlY29kZSBVVEYtOFxuICAgICAgICAgICAgY29uc3QgYSA9IHRoaXMuYnVmZmVyW3RoaXMuaW5kZXgrK107XG4gICAgICAgICAgICBpZiAoYSA8IDB4QzApIHtcbiAgICAgICAgICAgICAgICBjb2RlUG9pbnQgPSBhO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYiA9IHRoaXMuYnVmZmVyW3RoaXMuaW5kZXgrK107XG4gICAgICAgICAgICAgICAgaWYgKGEgPCAweEUwKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvZGVQb2ludCA9ICgoYSAmIDB4MUYpIDw8IDYpIHwgKGIgJiAweDNGKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGMgPSB0aGlzLmJ1ZmZlclt0aGlzLmluZGV4KytdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYSA8IDB4RjApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGVQb2ludCA9ICgoYSAmIDB4MEYpIDw8IDEyKSB8ICgoYiAmIDB4M0YpIDw8IDYpIHwgKGMgJiAweDNGKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGQgPSB0aGlzLmJ1ZmZlclt0aGlzLmluZGV4KytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29kZVBvaW50ID0gKChhICYgMHgwNykgPDwgMTgpIHwgKChiICYgMHgzRikgPDwgMTIpIHwgKChjICYgMHgzRikgPDwgNikgfCAoZCAmIDB4M0YpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gZW5jb2RlIFVURi0xNlxuICAgICAgICAgICAgaWYgKGNvZGVQb2ludCA8IDB4MTAwMDApIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlUG9pbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29kZVBvaW50IC09IDB4MTAwMDA7XG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoKGNvZGVQb2ludCA+PiAxMCkgKyAweEQ4MDAsIChjb2RlUG9pbnQgJiAoKDEgPDwgMTApIC0gMSkpICsgMHhEQzAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBEYW1hZ2UgY29udHJvbCwgaWYgdGhlIGlucHV0IGlzIG1hbGZvcm1lZCBVVEYtOC5cbiAgICAgICAgdGhpcy5pbmRleCA9IGVuZDtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogV3JpdGVzIGEgbGVuZ3RoLXByZWZpeGVkIFVURi04LWVuY29kZWQgc3RyaW5nLlxuICAgICAqL1xuICAgIHdyaXRlU3RyaW5nKHZhbHVlKSB7XG4gICAgICAgIC8vIFRoZSBudW1iZXIgb2YgY2hhcmFjdGVycyBpbiB0aGUgc3RyaW5nXG4gICAgICAgIGNvbnN0IHN0cmluZ0xlbmd0aCA9IHZhbHVlLmxlbmd0aDtcbiAgICAgICAgLy8gSWYgdGhlIHN0cmluZyBpcyBlbXB0eSBhdm9pZCB1bm5lY2Vzc2FyeSBhbGxvY2F0aW9ucyBieSB3cml0aW5nIHRoZSB6ZXJvIGxlbmd0aCBhbmQgcmV0dXJuaW5nLlxuICAgICAgICBpZiAoc3RyaW5nTGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLndyaXRlVWludDMyKDApO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIHZhbHVlLmxlbmd0aCAqIDMgaXMgYW4gdXBwZXIgbGltaXQgZm9yIHRoZSBzcGFjZSB0YWtlbiB1cCBieSB0aGUgc3RyaW5nOlxuICAgICAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvVGV4dEVuY29kZXIvZW5jb2RlSW50byNCdWZmZXJfU2l6aW5nXG4gICAgICAgIC8vIFdlIGFkZCA0IGZvciBvdXIgbGVuZ3RoIHByZWZpeC5cbiAgICAgICAgY29uc3QgbWF4Qnl0ZXMgPSA0ICsgc3RyaW5nTGVuZ3RoICogMztcbiAgICAgICAgLy8gUmVhbGxvY2F0ZSBpZiBuZWNlc3NhcnksIHRoZW4gd3JpdGUgdG8gdGhpcy5sZW5ndGggKyA0LlxuICAgICAgICB0aGlzLmd1YXJhbnRlZUJ1ZmZlckxlbmd0aCh0aGlzLmxlbmd0aCArIG1heEJ5dGVzKTtcbiAgICAgICAgLy8gU3RhcnQgd3JpdGluZyB0aGUgc3RyaW5nIGZyb20gaGVyZTpcbiAgICAgICAgbGV0IHcgPSB0aGlzLmxlbmd0aCArIDQ7XG4gICAgICAgIGNvbnN0IHN0YXJ0ID0gdztcbiAgICAgICAgbGV0IGNvZGVQb2ludDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHJpbmdMZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgLy8gZGVjb2RlIFVURi0xNlxuICAgICAgICAgICAgY29uc3QgYSA9IHZhbHVlLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgICAgICBpZiAoaSArIDEgPT09IHN0cmluZ0xlbmd0aCB8fCBhIDwgMHhEODAwIHx8IGEgPj0gMHhEQzAwKSB7XG4gICAgICAgICAgICAgICAgY29kZVBvaW50ID0gYTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IGIgPSB2YWx1ZS5jaGFyQ29kZUF0KCsraSk7XG4gICAgICAgICAgICAgICAgY29kZVBvaW50ID0gKGEgPDwgMTApICsgYiArICgweDEwMDAwIC0gKDB4RDgwMCA8PCAxMCkgLSAweERDMDApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gZW5jb2RlIFVURi04XG4gICAgICAgICAgICBpZiAoY29kZVBvaW50IDwgMHg4MCkge1xuICAgICAgICAgICAgICAgIHRoaXMuYnVmZmVyW3crK10gPSBjb2RlUG9pbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoY29kZVBvaW50IDwgMHg4MDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5idWZmZXJbdysrXSA9ICgoY29kZVBvaW50ID4+IDYpICYgMHgxRikgfCAweEMwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvZGVQb2ludCA8IDB4MTAwMDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYnVmZmVyW3crK10gPSAoKGNvZGVQb2ludCA+PiAxMikgJiAweDBGKSB8IDB4RTA7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmJ1ZmZlclt3KytdID0gKChjb2RlUG9pbnQgPj4gMTgpICYgMHgwNykgfCAweEYwO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5idWZmZXJbdysrXSA9ICgoY29kZVBvaW50ID4+IDEyKSAmIDB4M0YpIHwgMHg4MDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmJ1ZmZlclt3KytdID0gKChjb2RlUG9pbnQgPj4gNikgJiAweDNGKSB8IDB4ODA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuYnVmZmVyW3crK10gPSAoY29kZVBvaW50ICYgMHgzRikgfCAweDgwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIENvdW50IGhvdyBtYW55IGJ5dGVzIHdlIHdyb3RlLlxuICAgICAgICBjb25zdCB3cml0dGVuID0gdyAtIHN0YXJ0O1xuICAgICAgICAvLyBXcml0ZSB0aGUgbGVuZ3RoIHByZWZpeCwgdGhlbiBza2lwIG92ZXIgaXQgYW5kIHRoZSB3cml0dGVuIHN0cmluZy5cbiAgICAgICAgdGhpcy52aWV3LnNldFVpbnQzMih0aGlzLmxlbmd0aCwgd3JpdHRlbiwgdHJ1ZSk7XG4gICAgICAgIHRoaXMubGVuZ3RoICs9IDQgKyB3cml0dGVuO1xuICAgIH1cbiAgICByZWFkR3VpZCgpIHtcbiAgICAgICAgLy8gT3JkZXI6IDMgMiAxIDAgLSA1IDQgLSA3IDYgLSA4IDkgLSBhIGIgYyBkIGUgZlxuICAgICAgICBjb25zdCBiID0gYnl0ZVRvSGV4LCBhID0gdGhpcy5idWZmZXIsIGkgPSB0aGlzLmluZGV4LCBkID0gJy0nO1xuICAgICAgICB2YXIgcyA9IGJbYVtpICsgM11dO1xuICAgICAgICBzICs9IGJbYVtpICsgMl1dO1xuICAgICAgICBzICs9IGJbYVtpICsgMV1dO1xuICAgICAgICBzICs9IGJbYVtpXV07XG4gICAgICAgIHMgKz0gZDtcbiAgICAgICAgcyArPSBiW2FbaSArIDVdXTtcbiAgICAgICAgcyArPSBiW2FbaSArIDRdXTtcbiAgICAgICAgcyArPSBkO1xuICAgICAgICBzICs9IGJbYVtpICsgN11dO1xuICAgICAgICBzICs9IGJbYVtpICsgNl1dO1xuICAgICAgICBzICs9IGQ7XG4gICAgICAgIHMgKz0gYlthW2kgKyA4XV07XG4gICAgICAgIHMgKz0gYlthW2kgKyA5XV07XG4gICAgICAgIHMgKz0gZDtcbiAgICAgICAgcyArPSBiW2FbaSArIDEwXV07XG4gICAgICAgIHMgKz0gYlthW2kgKyAxMV1dO1xuICAgICAgICBzICs9IGJbYVtpICsgMTJdXTtcbiAgICAgICAgcyArPSBiW2FbaSArIDEzXV07XG4gICAgICAgIHMgKz0gYlthW2kgKyAxNF1dO1xuICAgICAgICBzICs9IGJbYVtpICsgMTVdXTtcbiAgICAgICAgdGhpcy5pbmRleCArPSAxNjtcbiAgICAgICAgcmV0dXJuIHM7XG4gICAgfVxuICAgIHdyaXRlR3VpZCh2YWx1ZSkge1xuICAgICAgICBjb25zdCB2ID0gdGhpcy52aWV3LCBpID0gdGhpcy5sZW5ndGg7XG4gICAgICAgIHRoaXMuZ3Jvd0J5KDE2KTtcbiAgICAgICAgdmFyIHAgPSAwLCBhID0gMDtcbiAgICAgICAgYSA9IGEgPDwgNCB8IGFzY2lpVG9IZXhbdmFsdWUuY2hhckNvZGVBdChwKyspXTtcbiAgICAgICAgYSA9IGEgPDwgNCB8IGFzY2lpVG9IZXhbdmFsdWUuY2hhckNvZGVBdChwKyspXTtcbiAgICAgICAgYSA9IGEgPDwgNCB8IGFzY2lpVG9IZXhbdmFsdWUuY2hhckNvZGVBdChwKyspXTtcbiAgICAgICAgYSA9IGEgPDwgNCB8IGFzY2lpVG9IZXhbdmFsdWUuY2hhckNvZGVBdChwKyspXTtcbiAgICAgICAgYSA9IGEgPDwgNCB8IGFzY2lpVG9IZXhbdmFsdWUuY2hhckNvZGVBdChwKyspXTtcbiAgICAgICAgYSA9IGEgPDwgNCB8IGFzY2lpVG9IZXhbdmFsdWUuY2hhckNvZGVBdChwKyspXTtcbiAgICAgICAgYSA9IGEgPDwgNCB8IGFzY2lpVG9IZXhbdmFsdWUuY2hhckNvZGVBdChwKyspXTtcbiAgICAgICAgYSA9IGEgPDwgNCB8IGFzY2lpVG9IZXhbdmFsdWUuY2hhckNvZGVBdChwKyspXTtcbiAgICAgICAgcCArPSAodmFsdWUuY2hhckNvZGVBdChwKSA9PT0gNDUpO1xuICAgICAgICB2LnNldFVpbnQzMihpLCBhLCB0cnVlKTtcbiAgICAgICAgYSA9IGEgPDwgNCB8IGFzY2lpVG9IZXhbdmFsdWUuY2hhckNvZGVBdChwKyspXTtcbiAgICAgICAgYSA9IGEgPDwgNCB8IGFzY2lpVG9IZXhbdmFsdWUuY2hhckNvZGVBdChwKyspXTtcbiAgICAgICAgYSA9IGEgPDwgNCB8IGFzY2lpVG9IZXhbdmFsdWUuY2hhckNvZGVBdChwKyspXTtcbiAgICAgICAgYSA9IGEgPDwgNCB8IGFzY2lpVG9IZXhbdmFsdWUuY2hhckNvZGVBdChwKyspXTtcbiAgICAgICAgcCArPSAodmFsdWUuY2hhckNvZGVBdChwKSA9PT0gNDUpO1xuICAgICAgICB2LnNldFVpbnQxNihpICsgNCwgYSwgdHJ1ZSk7XG4gICAgICAgIGEgPSBhIDw8IDQgfCBhc2NpaVRvSGV4W3ZhbHVlLmNoYXJDb2RlQXQocCsrKV07XG4gICAgICAgIGEgPSBhIDw8IDQgfCBhc2NpaVRvSGV4W3ZhbHVlLmNoYXJDb2RlQXQocCsrKV07XG4gICAgICAgIGEgPSBhIDw8IDQgfCBhc2NpaVRvSGV4W3ZhbHVlLmNoYXJDb2RlQXQocCsrKV07XG4gICAgICAgIGEgPSBhIDw8IDQgfCBhc2NpaVRvSGV4W3ZhbHVlLmNoYXJDb2RlQXQocCsrKV07XG4gICAgICAgIHAgKz0gKHZhbHVlLmNoYXJDb2RlQXQocCkgPT09IDQ1KTtcbiAgICAgICAgdi5zZXRVaW50MTYoaSArIDYsIGEsIHRydWUpO1xuICAgICAgICBhID0gYSA8PCA0IHwgYXNjaWlUb0hleFt2YWx1ZS5jaGFyQ29kZUF0KHArKyldO1xuICAgICAgICBhID0gYSA8PCA0IHwgYXNjaWlUb0hleFt2YWx1ZS5jaGFyQ29kZUF0KHArKyldO1xuICAgICAgICBhID0gYSA8PCA0IHwgYXNjaWlUb0hleFt2YWx1ZS5jaGFyQ29kZUF0KHArKyldO1xuICAgICAgICBhID0gYSA8PCA0IHwgYXNjaWlUb0hleFt2YWx1ZS5jaGFyQ29kZUF0KHArKyldO1xuICAgICAgICBwICs9ICh2YWx1ZS5jaGFyQ29kZUF0KHApID09PSA0NSk7XG4gICAgICAgIGEgPSBhIDw8IDQgfCBhc2NpaVRvSGV4W3ZhbHVlLmNoYXJDb2RlQXQocCsrKV07XG4gICAgICAgIGEgPSBhIDw8IDQgfCBhc2NpaVRvSGV4W3ZhbHVlLmNoYXJDb2RlQXQocCsrKV07XG4gICAgICAgIGEgPSBhIDw8IDQgfCBhc2NpaVRvSGV4W3ZhbHVlLmNoYXJDb2RlQXQocCsrKV07XG4gICAgICAgIGEgPSBhIDw8IDQgfCBhc2NpaVRvSGV4W3ZhbHVlLmNoYXJDb2RlQXQocCsrKV07XG4gICAgICAgIHYuc2V0VWludDMyKGkgKyA4LCBhLCBmYWxzZSk7XG4gICAgICAgIGEgPSBhIDw8IDQgfCBhc2NpaVRvSGV4W3ZhbHVlLmNoYXJDb2RlQXQocCsrKV07XG4gICAgICAgIGEgPSBhIDw8IDQgfCBhc2NpaVRvSGV4W3ZhbHVlLmNoYXJDb2RlQXQocCsrKV07XG4gICAgICAgIGEgPSBhIDw8IDQgfCBhc2NpaVRvSGV4W3ZhbHVlLmNoYXJDb2RlQXQocCsrKV07XG4gICAgICAgIGEgPSBhIDw8IDQgfCBhc2NpaVRvSGV4W3ZhbHVlLmNoYXJDb2RlQXQocCsrKV07XG4gICAgICAgIGEgPSBhIDw8IDQgfCBhc2NpaVRvSGV4W3ZhbHVlLmNoYXJDb2RlQXQocCsrKV07XG4gICAgICAgIGEgPSBhIDw8IDQgfCBhc2NpaVRvSGV4W3ZhbHVlLmNoYXJDb2RlQXQocCsrKV07XG4gICAgICAgIGEgPSBhIDw8IDQgfCBhc2NpaVRvSGV4W3ZhbHVlLmNoYXJDb2RlQXQocCsrKV07XG4gICAgICAgIGEgPSBhIDw8IDQgfCBhc2NpaVRvSGV4W3ZhbHVlLmNoYXJDb2RlQXQocCsrKV07XG4gICAgICAgIHYuc2V0VWludDMyKGkgKyAxMiwgYSwgZmFsc2UpO1xuICAgIH1cbiAgICAvLyBBIG5vdGUgb24gdGhlc2UgbnVtYmVyczpcbiAgICAvLyA2MjEzNTU5NjgwMDAwMCBtcyBpcyB0aGUgZGlmZmVyZW5jZSBiZXR3ZWVuIHRoZSBDIyBlcG9jaCAoMDAwMS0wMS0wMSkgYW5kIHRoZSBVbml4IGVwb2NoICgxOTcwLTAxLTAxKS5cbiAgICAvLyAwLjAwMDEgaXMgdGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgcGVyIFwidGlja1wiIChhIHRpY2sgaXMgMTAwIG5zKS5cbiAgICAvLyA0Mjk0OTYuNzI5NiBpcyB0aGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyBpbiAyXjMyIHRpY2tzLlxuICAgIC8vIDB4M2ZmZmZmZmYgaXMgYSBtYXNrIHRvIGlnbm9yZSB0aGUgXCJLaW5kXCIgYml0cyBvZiB0aGUgRGF0ZS5Ub0JpbmFyeSB2YWx1ZS5cbiAgICAvLyAweDQwMDAwMDAwIGlzIGEgbWFzayB0byBzZXQgdGhlIFwiS2luZFwiIGJpdHMgdG8gXCJEYXRlVGltZUtpbmQuVXRjXCIuXG4gICAgcmVhZERhdGUoKSB7XG4gICAgICAgIGNvbnN0IGxvdyA9IHRoaXMucmVhZFVpbnQzMigpO1xuICAgICAgICBjb25zdCBoaWdoID0gdGhpcy5yZWFkVWludDMyKCkgJiAweDNmZmZmZmZmO1xuICAgICAgICBjb25zdCBtc1NpbmNlMUFEID0gNDI5NDk2LjcyOTYgKiBoaWdoICsgMC4wMDAxICogbG93O1xuICAgICAgICByZXR1cm4gbmV3IERhdGUobXNTaW5jZTFBRCAtIDYyMTM1NTk2ODAwMDAwKTtcbiAgICB9XG4gICAgd3JpdGVEYXRlKGRhdGUpIHtcbiAgICAgICAgY29uc3QgbXMgPSBkYXRlLmdldFRpbWUoKTtcbiAgICAgICAgY29uc3QgbXNTaW5jZTFBRCA9IG1zICsgNjIxMzU1OTY4MDAwMDA7XG4gICAgICAgIGNvbnN0IGxvdyA9IG1zU2luY2UxQUQgJSA0Mjk0OTYuNzI5NiAqIDEwMDAwIHwgMDtcbiAgICAgICAgY29uc3QgaGlnaCA9IG1zU2luY2UxQUQgLyA0Mjk0OTYuNzI5NiB8IDB4NDAwMDAwMDA7XG4gICAgICAgIHRoaXMud3JpdGVVaW50MzIobG93KTtcbiAgICAgICAgdGhpcy53cml0ZVVpbnQzMihoaWdoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVzZXJ2ZSBzb21lIHNwYWNlIHRvIHdyaXRlIGEgbWVzc2FnZSdzIGxlbmd0aCBwcmVmaXgsIGFuZCByZXR1cm4gaXRzIGluZGV4LlxuICAgICAqIFRoZSBsZW5ndGggaXMgc3RvcmVkIGFzIGEgbGl0dGxlLWVuZGlhbiBmaXhlZC13aWR0aCB1bnNpZ25lZCAzMi1iaXQgaW50ZWdlciwgc28gNCBieXRlcyBhcmUgcmVzZXJ2ZWQuXG4gICAgICovXG4gICAgcmVzZXJ2ZU1lc3NhZ2VMZW5ndGgoKSB7XG4gICAgICAgIGNvbnN0IGkgPSB0aGlzLmxlbmd0aDtcbiAgICAgICAgdGhpcy5ncm93QnkoNCk7XG4gICAgICAgIHJldHVybiBpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBGaWxsIGluIGEgbWVzc2FnZSdzIGxlbmd0aCBwcmVmaXguXG4gICAgICovXG4gICAgZmlsbE1lc3NhZ2VMZW5ndGgocG9zaXRpb24sIG1lc3NhZ2VMZW5ndGgpIHtcbiAgICAgICAgdGhpcy52aWV3LnNldFVpbnQzMihwb3NpdGlvbiwgbWVzc2FnZUxlbmd0aCwgdHJ1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlYWQgb3V0IGEgbWVzc2FnZSdzIGxlbmd0aCBwcmVmaXguXG4gICAgICovXG4gICAgcmVhZE1lc3NhZ2VMZW5ndGgoKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMudmlldy5nZXRVaW50MzIodGhpcy5pbmRleCwgdHJ1ZSk7XG4gICAgICAgIHRoaXMuaW5kZXggKz0gNDtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG59XG5leHBvcnRzLkJlYm9wVmlldyA9IEJlYm9wVmlldztcbiIsIlwidXNlIHN0cmljdFwiO1xuXG4vKlxuICBNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxuICBBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXG4qL1xuLy8gY3NzIGJhc2UgY29kZSwgaW5qZWN0ZWQgYnkgdGhlIGNzcy1sb2FkZXJcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBmdW5jLW5hbWVzXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh1c2VTb3VyY2VNYXApIHtcbiAgdmFyIGxpc3QgPSBbXTsgLy8gcmV0dXJuIHRoZSBsaXN0IG9mIG1vZHVsZXMgYXMgY3NzIHN0cmluZ1xuXG4gIGxpc3QudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gdGhpcy5tYXAoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgIHZhciBjb250ZW50ID0gY3NzV2l0aE1hcHBpbmdUb1N0cmluZyhpdGVtLCB1c2VTb3VyY2VNYXApO1xuXG4gICAgICBpZiAoaXRlbVsyXSkge1xuICAgICAgICByZXR1cm4gXCJAbWVkaWEgXCIuY29uY2F0KGl0ZW1bMl0sIFwiIHtcIikuY29uY2F0KGNvbnRlbnQsIFwifVwiKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGNvbnRlbnQ7XG4gICAgfSkuam9pbignJyk7XG4gIH07IC8vIGltcG9ydCBhIGxpc3Qgb2YgbW9kdWxlcyBpbnRvIHRoZSBsaXN0XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBmdW5jLW5hbWVzXG5cblxuICBsaXN0LmkgPSBmdW5jdGlvbiAobW9kdWxlcywgbWVkaWFRdWVyeSwgZGVkdXBlKSB7XG4gICAgaWYgKHR5cGVvZiBtb2R1bGVzID09PSAnc3RyaW5nJykge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgICBtb2R1bGVzID0gW1tudWxsLCBtb2R1bGVzLCAnJ11dO1xuICAgIH1cblxuICAgIHZhciBhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzID0ge307XG5cbiAgICBpZiAoZGVkdXBlKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHByZWZlci1kZXN0cnVjdHVyaW5nXG4gICAgICAgIHZhciBpZCA9IHRoaXNbaV1bMF07XG5cbiAgICAgICAgaWYgKGlkICE9IG51bGwpIHtcbiAgICAgICAgICBhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzW2lkXSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgbW9kdWxlcy5sZW5ndGg7IF9pKyspIHtcbiAgICAgIHZhciBpdGVtID0gW10uY29uY2F0KG1vZHVsZXNbX2ldKTtcblxuICAgICAgaWYgKGRlZHVwZSAmJiBhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzW2l0ZW1bMF1dKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb250aW51ZVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKG1lZGlhUXVlcnkpIHtcbiAgICAgICAgaWYgKCFpdGVtWzJdKSB7XG4gICAgICAgICAgaXRlbVsyXSA9IG1lZGlhUXVlcnk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaXRlbVsyXSA9IFwiXCIuY29uY2F0KG1lZGlhUXVlcnksIFwiIGFuZCBcIikuY29uY2F0KGl0ZW1bMl0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGxpc3QucHVzaChpdGVtKTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIGxpc3Q7XG59O1xuXG5mdW5jdGlvbiBjc3NXaXRoTWFwcGluZ1RvU3RyaW5nKGl0ZW0sIHVzZVNvdXJjZU1hcCkge1xuICB2YXIgY29udGVudCA9IGl0ZW1bMV0gfHwgJyc7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBwcmVmZXItZGVzdHJ1Y3R1cmluZ1xuXG4gIHZhciBjc3NNYXBwaW5nID0gaXRlbVszXTtcblxuICBpZiAoIWNzc01hcHBpbmcpIHtcbiAgICByZXR1cm4gY29udGVudDtcbiAgfVxuXG4gIGlmICh1c2VTb3VyY2VNYXAgJiYgdHlwZW9mIGJ0b2EgPT09ICdmdW5jdGlvbicpIHtcbiAgICB2YXIgc291cmNlTWFwcGluZyA9IHRvQ29tbWVudChjc3NNYXBwaW5nKTtcbiAgICB2YXIgc291cmNlVVJMcyA9IGNzc01hcHBpbmcuc291cmNlcy5tYXAoZnVuY3Rpb24gKHNvdXJjZSkge1xuICAgICAgcmV0dXJuIFwiLyojIHNvdXJjZVVSTD1cIi5jb25jYXQoY3NzTWFwcGluZy5zb3VyY2VSb290IHx8ICcnKS5jb25jYXQoc291cmNlLCBcIiAqL1wiKTtcbiAgICB9KTtcbiAgICByZXR1cm4gW2NvbnRlbnRdLmNvbmNhdChzb3VyY2VVUkxzKS5jb25jYXQoW3NvdXJjZU1hcHBpbmddKS5qb2luKCdcXG4nKTtcbiAgfVxuXG4gIHJldHVybiBbY29udGVudF0uam9pbignXFxuJyk7XG59IC8vIEFkYXB0ZWQgZnJvbSBjb252ZXJ0LXNvdXJjZS1tYXAgKE1JVClcblxuXG5mdW5jdGlvbiB0b0NvbW1lbnQoc291cmNlTWFwKSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlZlxuICB2YXIgYmFzZTY0ID0gYnRvYSh1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoSlNPTi5zdHJpbmdpZnkoc291cmNlTWFwKSkpKTtcbiAgdmFyIGRhdGEgPSBcInNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2NoYXJzZXQ9dXRmLTg7YmFzZTY0LFwiLmNvbmNhdChiYXNlNjQpO1xuICByZXR1cm4gXCIvKiMgXCIuY29uY2F0KGRhdGEsIFwiICovXCIpO1xufSIsIi8qXG5vYmplY3QtYXNzaWduXG4oYykgU2luZHJlIFNvcmh1c1xuQGxpY2Vuc2UgTUlUXG4qL1xuXG4ndXNlIHN0cmljdCc7XG4vKiBlc2xpbnQtZGlzYWJsZSBuby11bnVzZWQtdmFycyAqL1xudmFyIGdldE93blByb3BlcnR5U3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIHByb3BJc0VudW1lcmFibGUgPSBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xuXG5mdW5jdGlvbiB0b09iamVjdCh2YWwpIHtcblx0aWYgKHZhbCA9PT0gbnVsbCB8fCB2YWwgPT09IHVuZGVmaW5lZCkge1xuXHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ09iamVjdC5hc3NpZ24gY2Fubm90IGJlIGNhbGxlZCB3aXRoIG51bGwgb3IgdW5kZWZpbmVkJyk7XG5cdH1cblxuXHRyZXR1cm4gT2JqZWN0KHZhbCk7XG59XG5cbmZ1bmN0aW9uIHNob3VsZFVzZU5hdGl2ZSgpIHtcblx0dHJ5IHtcblx0XHRpZiAoIU9iamVjdC5hc3NpZ24pIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHQvLyBEZXRlY3QgYnVnZ3kgcHJvcGVydHkgZW51bWVyYXRpb24gb3JkZXIgaW4gb2xkZXIgVjggdmVyc2lvbnMuXG5cblx0XHQvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD00MTE4XG5cdFx0dmFyIHRlc3QxID0gbmV3IFN0cmluZygnYWJjJyk7ICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5ldy13cmFwcGVyc1xuXHRcdHRlc3QxWzVdID0gJ2RlJztcblx0XHRpZiAoT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGVzdDEpWzBdID09PSAnNScpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHQvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD0zMDU2XG5cdFx0dmFyIHRlc3QyID0ge307XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCAxMDsgaSsrKSB7XG5cdFx0XHR0ZXN0MlsnXycgKyBTdHJpbmcuZnJvbUNoYXJDb2RlKGkpXSA9IGk7XG5cdFx0fVxuXHRcdHZhciBvcmRlcjIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0ZXN0MikubWFwKGZ1bmN0aW9uIChuKSB7XG5cdFx0XHRyZXR1cm4gdGVzdDJbbl07XG5cdFx0fSk7XG5cdFx0aWYgKG9yZGVyMi5qb2luKCcnKSAhPT0gJzAxMjM0NTY3ODknKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0Ly8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9MzA1NlxuXHRcdHZhciB0ZXN0MyA9IHt9O1xuXHRcdCdhYmNkZWZnaGlqa2xtbm9wcXJzdCcuc3BsaXQoJycpLmZvckVhY2goZnVuY3Rpb24gKGxldHRlcikge1xuXHRcdFx0dGVzdDNbbGV0dGVyXSA9IGxldHRlcjtcblx0XHR9KTtcblx0XHRpZiAoT2JqZWN0LmtleXMoT2JqZWN0LmFzc2lnbih7fSwgdGVzdDMpKS5qb2luKCcnKSAhPT1cblx0XHRcdFx0J2FiY2RlZmdoaWprbG1ub3BxcnN0Jykge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdHJldHVybiB0cnVlO1xuXHR9IGNhdGNoIChlcnIpIHtcblx0XHQvLyBXZSBkb24ndCBleHBlY3QgYW55IG9mIHRoZSBhYm92ZSB0byB0aHJvdywgYnV0IGJldHRlciB0byBiZSBzYWZlLlxuXHRcdHJldHVybiBmYWxzZTtcblx0fVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNob3VsZFVzZU5hdGl2ZSgpID8gT2JqZWN0LmFzc2lnbiA6IGZ1bmN0aW9uICh0YXJnZXQsIHNvdXJjZSkge1xuXHR2YXIgZnJvbTtcblx0dmFyIHRvID0gdG9PYmplY3QodGFyZ2V0KTtcblx0dmFyIHN5bWJvbHM7XG5cblx0Zm9yICh2YXIgcyA9IDE7IHMgPCBhcmd1bWVudHMubGVuZ3RoOyBzKyspIHtcblx0XHRmcm9tID0gT2JqZWN0KGFyZ3VtZW50c1tzXSk7XG5cblx0XHRmb3IgKHZhciBrZXkgaW4gZnJvbSkge1xuXHRcdFx0aWYgKGhhc093blByb3BlcnR5LmNhbGwoZnJvbSwga2V5KSkge1xuXHRcdFx0XHR0b1trZXldID0gZnJvbVtrZXldO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmIChnZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcblx0XHRcdHN5bWJvbHMgPSBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZnJvbSk7XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHN5bWJvbHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0aWYgKHByb3BJc0VudW1lcmFibGUuY2FsbChmcm9tLCBzeW1ib2xzW2ldKSkge1xuXHRcdFx0XHRcdHRvW3N5bWJvbHNbaV1dID0gZnJvbVtzeW1ib2xzW2ldXTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiB0bztcbn07XG4iLCIvKiogQGxpY2Vuc2UgUmVhY3QgdjE3LjAuMlxuICogcmVhY3QtZG9tLmRldmVsb3BtZW50LmpzXG4gKlxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gIChmdW5jdGlvbigpIHtcbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcbnZhciBfYXNzaWduID0gcmVxdWlyZSgnb2JqZWN0LWFzc2lnbicpO1xudmFyIFNjaGVkdWxlciA9IHJlcXVpcmUoJ3NjaGVkdWxlcicpO1xudmFyIHRyYWNpbmcgPSByZXF1aXJlKCdzY2hlZHVsZXIvdHJhY2luZycpO1xuXG52YXIgUmVhY3RTaGFyZWRJbnRlcm5hbHMgPSBSZWFjdC5fX1NFQ1JFVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRDtcblxuLy8gYnkgY2FsbHMgdG8gdGhlc2UgbWV0aG9kcyBieSBhIEJhYmVsIHBsdWdpbi5cbi8vXG4vLyBJbiBQUk9EIChvciBpbiBwYWNrYWdlcyB3aXRob3V0IGFjY2VzcyB0byBSZWFjdCBpbnRlcm5hbHMpLFxuLy8gdGhleSBhcmUgbGVmdCBhcyB0aGV5IGFyZSBpbnN0ZWFkLlxuXG5mdW5jdGlvbiB3YXJuKGZvcm1hdCkge1xuICB7XG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgcHJpbnRXYXJuaW5nKCd3YXJuJywgZm9ybWF0LCBhcmdzKTtcbiAgfVxufVxuZnVuY3Rpb24gZXJyb3IoZm9ybWF0KSB7XG4gIHtcbiAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjIgPiAxID8gX2xlbjIgLSAxIDogMCksIF9rZXkyID0gMTsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgICAgYXJnc1tfa2V5MiAtIDFdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgICB9XG5cbiAgICBwcmludFdhcm5pbmcoJ2Vycm9yJywgZm9ybWF0LCBhcmdzKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwcmludFdhcm5pbmcobGV2ZWwsIGZvcm1hdCwgYXJncykge1xuICAvLyBXaGVuIGNoYW5naW5nIHRoaXMgbG9naWMsIHlvdSBtaWdodCB3YW50IHRvIGFsc29cbiAgLy8gdXBkYXRlIGNvbnNvbGVXaXRoU3RhY2tEZXYud3d3LmpzIGFzIHdlbGwuXG4gIHtcbiAgICB2YXIgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0RGVidWdDdXJyZW50RnJhbWU7XG4gICAgdmFyIHN0YWNrID0gUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5nZXRTdGFja0FkZGVuZHVtKCk7XG5cbiAgICBpZiAoc3RhY2sgIT09ICcnKSB7XG4gICAgICBmb3JtYXQgKz0gJyVzJztcbiAgICAgIGFyZ3MgPSBhcmdzLmNvbmNhdChbc3RhY2tdKTtcbiAgICB9XG5cbiAgICB2YXIgYXJnc1dpdGhGb3JtYXQgPSBhcmdzLm1hcChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgcmV0dXJuICcnICsgaXRlbTtcbiAgICB9KTsgLy8gQ2FyZWZ1bDogUk4gY3VycmVudGx5IGRlcGVuZHMgb24gdGhpcyBwcmVmaXhcblxuICAgIGFyZ3NXaXRoRm9ybWF0LnVuc2hpZnQoJ1dhcm5pbmc6ICcgKyBmb3JtYXQpOyAvLyBXZSBpbnRlbnRpb25hbGx5IGRvbid0IHVzZSBzcHJlYWQgKG9yIC5hcHBseSkgZGlyZWN0bHkgYmVjYXVzZSBpdFxuICAgIC8vIGJyZWFrcyBJRTk6IGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTM2MTBcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nXG5cbiAgICBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkuY2FsbChjb25zb2xlW2xldmVsXSwgY29uc29sZSwgYXJnc1dpdGhGb3JtYXQpO1xuICB9XG59XG5cbmlmICghUmVhY3QpIHtcbiAge1xuICAgIHRocm93IEVycm9yKCBcIlJlYWN0RE9NIHdhcyBsb2FkZWQgYmVmb3JlIFJlYWN0LiBNYWtlIHN1cmUgeW91IGxvYWQgdGhlIFJlYWN0IHBhY2thZ2UgYmVmb3JlIGxvYWRpbmcgUmVhY3RET00uXCIgKTtcbiAgfVxufVxuXG52YXIgRnVuY3Rpb25Db21wb25lbnQgPSAwO1xudmFyIENsYXNzQ29tcG9uZW50ID0gMTtcbnZhciBJbmRldGVybWluYXRlQ29tcG9uZW50ID0gMjsgLy8gQmVmb3JlIHdlIGtub3cgd2hldGhlciBpdCBpcyBmdW5jdGlvbiBvciBjbGFzc1xuXG52YXIgSG9zdFJvb3QgPSAzOyAvLyBSb290IG9mIGEgaG9zdCB0cmVlLiBDb3VsZCBiZSBuZXN0ZWQgaW5zaWRlIGFub3RoZXIgbm9kZS5cblxudmFyIEhvc3RQb3J0YWwgPSA0OyAvLyBBIHN1YnRyZWUuIENvdWxkIGJlIGFuIGVudHJ5IHBvaW50IHRvIGEgZGlmZmVyZW50IHJlbmRlcmVyLlxuXG52YXIgSG9zdENvbXBvbmVudCA9IDU7XG52YXIgSG9zdFRleHQgPSA2O1xudmFyIEZyYWdtZW50ID0gNztcbnZhciBNb2RlID0gODtcbnZhciBDb250ZXh0Q29uc3VtZXIgPSA5O1xudmFyIENvbnRleHRQcm92aWRlciA9IDEwO1xudmFyIEZvcndhcmRSZWYgPSAxMTtcbnZhciBQcm9maWxlciA9IDEyO1xudmFyIFN1c3BlbnNlQ29tcG9uZW50ID0gMTM7XG52YXIgTWVtb0NvbXBvbmVudCA9IDE0O1xudmFyIFNpbXBsZU1lbW9Db21wb25lbnQgPSAxNTtcbnZhciBMYXp5Q29tcG9uZW50ID0gMTY7XG52YXIgSW5jb21wbGV0ZUNsYXNzQ29tcG9uZW50ID0gMTc7XG52YXIgRGVoeWRyYXRlZEZyYWdtZW50ID0gMTg7XG52YXIgU3VzcGVuc2VMaXN0Q29tcG9uZW50ID0gMTk7XG52YXIgRnVuZGFtZW50YWxDb21wb25lbnQgPSAyMDtcbnZhciBTY29wZUNvbXBvbmVudCA9IDIxO1xudmFyIEJsb2NrID0gMjI7XG52YXIgT2Zmc2NyZWVuQ29tcG9uZW50ID0gMjM7XG52YXIgTGVnYWN5SGlkZGVuQ29tcG9uZW50ID0gMjQ7XG5cbi8vIEZpbHRlciBjZXJ0YWluIERPTSBhdHRyaWJ1dGVzIChlLmcuIHNyYywgaHJlZikgaWYgdGhlaXIgdmFsdWVzIGFyZSBlbXB0eSBzdHJpbmdzLlxuXG52YXIgZW5hYmxlUHJvZmlsZXJUaW1lciA9IHRydWU7IC8vIFJlY29yZCBkdXJhdGlvbnMgZm9yIGNvbW1pdCBhbmQgcGFzc2l2ZSBlZmZlY3RzIHBoYXNlcy5cblxudmFyIGVuYWJsZUZ1bmRhbWVudGFsQVBJID0gZmFsc2U7IC8vIEV4cGVyaW1lbnRhbCBTY29wZSBzdXBwb3J0LlxudmFyIGVuYWJsZU5ld1JlY29uY2lsZXIgPSBmYWxzZTsgLy8gRXJyb3JzIHRoYXQgYXJlIHRocm93biB3aGlsZSB1bm1vdW50aW5nIChvciBhZnRlciBpbiB0aGUgY2FzZSBvZiBwYXNzaXZlIGVmZmVjdHMpXG52YXIgd2FybkFib3V0U3RyaW5nUmVmcyA9IGZhbHNlO1xuXG52YXIgYWxsTmF0aXZlRXZlbnRzID0gbmV3IFNldCgpO1xuLyoqXG4gKiBNYXBwaW5nIGZyb20gcmVnaXN0cmF0aW9uIG5hbWUgdG8gZXZlbnQgbmFtZVxuICovXG5cblxudmFyIHJlZ2lzdHJhdGlvbk5hbWVEZXBlbmRlbmNpZXMgPSB7fTtcbi8qKlxuICogTWFwcGluZyBmcm9tIGxvd2VyY2FzZSByZWdpc3RyYXRpb24gbmFtZXMgdG8gdGhlIHByb3Blcmx5IGNhc2VkIHZlcnNpb24sXG4gKiB1c2VkIHRvIHdhcm4gaW4gdGhlIGNhc2Ugb2YgbWlzc2luZyBldmVudCBoYW5kbGVycy4gQXZhaWxhYmxlXG4gKiBvbmx5IGluIHRydWUuXG4gKiBAdHlwZSB7T2JqZWN0fVxuICovXG5cbnZhciBwb3NzaWJsZVJlZ2lzdHJhdGlvbk5hbWVzID0gIHt9IDsgLy8gVHJ1c3QgdGhlIGRldmVsb3BlciB0byBvbmx5IHVzZSBwb3NzaWJsZVJlZ2lzdHJhdGlvbk5hbWVzIGluIHRydWVcblxuZnVuY3Rpb24gcmVnaXN0ZXJUd29QaGFzZUV2ZW50KHJlZ2lzdHJhdGlvbk5hbWUsIGRlcGVuZGVuY2llcykge1xuICByZWdpc3RlckRpcmVjdEV2ZW50KHJlZ2lzdHJhdGlvbk5hbWUsIGRlcGVuZGVuY2llcyk7XG4gIHJlZ2lzdGVyRGlyZWN0RXZlbnQocmVnaXN0cmF0aW9uTmFtZSArICdDYXB0dXJlJywgZGVwZW5kZW5jaWVzKTtcbn1cbmZ1bmN0aW9uIHJlZ2lzdGVyRGlyZWN0RXZlbnQocmVnaXN0cmF0aW9uTmFtZSwgZGVwZW5kZW5jaWVzKSB7XG4gIHtcbiAgICBpZiAocmVnaXN0cmF0aW9uTmFtZURlcGVuZGVuY2llc1tyZWdpc3RyYXRpb25OYW1lXSkge1xuICAgICAgZXJyb3IoJ0V2ZW50UmVnaXN0cnk6IE1vcmUgdGhhbiBvbmUgcGx1Z2luIGF0dGVtcHRlZCB0byBwdWJsaXNoIHRoZSBzYW1lICcgKyAncmVnaXN0cmF0aW9uIG5hbWUsIGAlc2AuJywgcmVnaXN0cmF0aW9uTmFtZSk7XG4gICAgfVxuICB9XG5cbiAgcmVnaXN0cmF0aW9uTmFtZURlcGVuZGVuY2llc1tyZWdpc3RyYXRpb25OYW1lXSA9IGRlcGVuZGVuY2llcztcblxuICB7XG4gICAgdmFyIGxvd2VyQ2FzZWROYW1lID0gcmVnaXN0cmF0aW9uTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgIHBvc3NpYmxlUmVnaXN0cmF0aW9uTmFtZXNbbG93ZXJDYXNlZE5hbWVdID0gcmVnaXN0cmF0aW9uTmFtZTtcblxuICAgIGlmIChyZWdpc3RyYXRpb25OYW1lID09PSAnb25Eb3VibGVDbGljaycpIHtcbiAgICAgIHBvc3NpYmxlUmVnaXN0cmF0aW9uTmFtZXMub25kYmxjbGljayA9IHJlZ2lzdHJhdGlvbk5hbWU7XG4gICAgfVxuICB9XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBkZXBlbmRlbmNpZXMubGVuZ3RoOyBpKyspIHtcbiAgICBhbGxOYXRpdmVFdmVudHMuYWRkKGRlcGVuZGVuY2llc1tpXSk7XG4gIH1cbn1cblxudmFyIGNhblVzZURPTSA9ICEhKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiB3aW5kb3cuZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiB3aW5kb3cuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCAhPT0gJ3VuZGVmaW5lZCcpO1xuXG4vLyBBIHJlc2VydmVkIGF0dHJpYnV0ZS5cbi8vIEl0IGlzIGhhbmRsZWQgYnkgUmVhY3Qgc2VwYXJhdGVseSBhbmQgc2hvdWxkbid0IGJlIHdyaXR0ZW4gdG8gdGhlIERPTS5cbnZhciBSRVNFUlZFRCA9IDA7IC8vIEEgc2ltcGxlIHN0cmluZyBhdHRyaWJ1dGUuXG4vLyBBdHRyaWJ1dGVzIHRoYXQgYXJlbid0IGluIHRoZSBmaWx0ZXIgYXJlIHByZXN1bWVkIHRvIGhhdmUgdGhpcyB0eXBlLlxuXG52YXIgU1RSSU5HID0gMTsgLy8gQSBzdHJpbmcgYXR0cmlidXRlIHRoYXQgYWNjZXB0cyBib29sZWFucyBpbiBSZWFjdC4gSW4gSFRNTCwgdGhlc2UgYXJlIGNhbGxlZFxuLy8gXCJlbnVtZXJhdGVkXCIgYXR0cmlidXRlcyB3aXRoIFwidHJ1ZVwiIGFuZCBcImZhbHNlXCIgYXMgcG9zc2libGUgdmFsdWVzLlxuLy8gV2hlbiB0cnVlLCBpdCBzaG91bGQgYmUgc2V0IHRvIGEgXCJ0cnVlXCIgc3RyaW5nLlxuLy8gV2hlbiBmYWxzZSwgaXQgc2hvdWxkIGJlIHNldCB0byBhIFwiZmFsc2VcIiBzdHJpbmcuXG5cbnZhciBCT09MRUFOSVNIX1NUUklORyA9IDI7IC8vIEEgcmVhbCBib29sZWFuIGF0dHJpYnV0ZS5cbi8vIFdoZW4gdHJ1ZSwgaXQgc2hvdWxkIGJlIHByZXNlbnQgKHNldCBlaXRoZXIgdG8gYW4gZW1wdHkgc3RyaW5nIG9yIGl0cyBuYW1lKS5cbi8vIFdoZW4gZmFsc2UsIGl0IHNob3VsZCBiZSBvbWl0dGVkLlxuXG52YXIgQk9PTEVBTiA9IDM7IC8vIEFuIGF0dHJpYnV0ZSB0aGF0IGNhbiBiZSB1c2VkIGFzIGEgZmxhZyBhcyB3ZWxsIGFzIHdpdGggYSB2YWx1ZS5cbi8vIFdoZW4gdHJ1ZSwgaXQgc2hvdWxkIGJlIHByZXNlbnQgKHNldCBlaXRoZXIgdG8gYW4gZW1wdHkgc3RyaW5nIG9yIGl0cyBuYW1lKS5cbi8vIFdoZW4gZmFsc2UsIGl0IHNob3VsZCBiZSBvbWl0dGVkLlxuLy8gRm9yIGFueSBvdGhlciB2YWx1ZSwgc2hvdWxkIGJlIHByZXNlbnQgd2l0aCB0aGF0IHZhbHVlLlxuXG52YXIgT1ZFUkxPQURFRF9CT09MRUFOID0gNDsgLy8gQW4gYXR0cmlidXRlIHRoYXQgbXVzdCBiZSBudW1lcmljIG9yIHBhcnNlIGFzIGEgbnVtZXJpYy5cbi8vIFdoZW4gZmFsc3ksIGl0IHNob3VsZCBiZSByZW1vdmVkLlxuXG52YXIgTlVNRVJJQyA9IDU7IC8vIEFuIGF0dHJpYnV0ZSB0aGF0IG11c3QgYmUgcG9zaXRpdmUgbnVtZXJpYyBvciBwYXJzZSBhcyBhIHBvc2l0aXZlIG51bWVyaWMuXG4vLyBXaGVuIGZhbHN5LCBpdCBzaG91bGQgYmUgcmVtb3ZlZC5cblxudmFyIFBPU0lUSVZFX05VTUVSSUMgPSA2O1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuICovXG52YXIgQVRUUklCVVRFX05BTUVfU1RBUlRfQ0hBUiA9IFwiOkEtWl9hLXpcXFxcdTAwQzAtXFxcXHUwMEQ2XFxcXHUwMEQ4LVxcXFx1MDBGNlxcXFx1MDBGOC1cXFxcdTAyRkZcXFxcdTAzNzAtXFxcXHUwMzdEXFxcXHUwMzdGLVxcXFx1MUZGRlxcXFx1MjAwQy1cXFxcdTIwMERcXFxcdTIwNzAtXFxcXHUyMThGXFxcXHUyQzAwLVxcXFx1MkZFRlxcXFx1MzAwMS1cXFxcdUQ3RkZcXFxcdUY5MDAtXFxcXHVGRENGXFxcXHVGREYwLVxcXFx1RkZGRFwiO1xuLyogZXNsaW50LWVuYWJsZSBtYXgtbGVuICovXG5cbnZhciBBVFRSSUJVVEVfTkFNRV9DSEFSID0gQVRUUklCVVRFX05BTUVfU1RBUlRfQ0hBUiArIFwiXFxcXC0uMC05XFxcXHUwMEI3XFxcXHUwMzAwLVxcXFx1MDM2RlxcXFx1MjAzRi1cXFxcdTIwNDBcIjtcbnZhciBST09UX0FUVFJJQlVURV9OQU1FID0gJ2RhdGEtcmVhY3Ryb290JztcbnZhciBWQUxJRF9BVFRSSUJVVEVfTkFNRV9SRUdFWCA9IG5ldyBSZWdFeHAoJ15bJyArIEFUVFJJQlVURV9OQU1FX1NUQVJUX0NIQVIgKyAnXVsnICsgQVRUUklCVVRFX05BTUVfQ0hBUiArICddKiQnKTtcbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgaWxsZWdhbEF0dHJpYnV0ZU5hbWVDYWNoZSA9IHt9O1xudmFyIHZhbGlkYXRlZEF0dHJpYnV0ZU5hbWVDYWNoZSA9IHt9O1xuZnVuY3Rpb24gaXNBdHRyaWJ1dGVOYW1lU2FmZShhdHRyaWJ1dGVOYW1lKSB7XG4gIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbGlkYXRlZEF0dHJpYnV0ZU5hbWVDYWNoZSwgYXR0cmlidXRlTmFtZSkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGlsbGVnYWxBdHRyaWJ1dGVOYW1lQ2FjaGUsIGF0dHJpYnV0ZU5hbWUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKFZBTElEX0FUVFJJQlVURV9OQU1FX1JFR0VYLnRlc3QoYXR0cmlidXRlTmFtZSkpIHtcbiAgICB2YWxpZGF0ZWRBdHRyaWJ1dGVOYW1lQ2FjaGVbYXR0cmlidXRlTmFtZV0gPSB0cnVlO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWxsZWdhbEF0dHJpYnV0ZU5hbWVDYWNoZVthdHRyaWJ1dGVOYW1lXSA9IHRydWU7XG5cbiAge1xuICAgIGVycm9yKCdJbnZhbGlkIGF0dHJpYnV0ZSBuYW1lOiBgJXNgJywgYXR0cmlidXRlTmFtZSk7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBzaG91bGRJZ25vcmVBdHRyaWJ1dGUobmFtZSwgcHJvcGVydHlJbmZvLCBpc0N1c3RvbUNvbXBvbmVudFRhZykge1xuICBpZiAocHJvcGVydHlJbmZvICE9PSBudWxsKSB7XG4gICAgcmV0dXJuIHByb3BlcnR5SW5mby50eXBlID09PSBSRVNFUlZFRDtcbiAgfVxuXG4gIGlmIChpc0N1c3RvbUNvbXBvbmVudFRhZykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChuYW1lLmxlbmd0aCA+IDIgJiYgKG5hbWVbMF0gPT09ICdvJyB8fCBuYW1lWzBdID09PSAnTycpICYmIChuYW1lWzFdID09PSAnbicgfHwgbmFtZVsxXSA9PT0gJ04nKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gc2hvdWxkUmVtb3ZlQXR0cmlidXRlV2l0aFdhcm5pbmcobmFtZSwgdmFsdWUsIHByb3BlcnR5SW5mbywgaXNDdXN0b21Db21wb25lbnRUYWcpIHtcbiAgaWYgKHByb3BlcnR5SW5mbyAhPT0gbnVsbCAmJiBwcm9wZXJ0eUluZm8udHlwZSA9PT0gUkVTRVJWRUQpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBzd2l0Y2ggKHR5cGVvZiB2YWx1ZSkge1xuICAgIGNhc2UgJ2Z1bmN0aW9uJzogLy8gJEZsb3dJc3N1ZSBzeW1ib2wgaXMgcGVyZmVjdGx5IHZhbGlkIGhlcmVcblxuICAgIGNhc2UgJ3N5bWJvbCc6XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgICByZXR1cm4gdHJ1ZTtcblxuICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAge1xuICAgICAgICBpZiAoaXNDdXN0b21Db21wb25lbnRUYWcpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocHJvcGVydHlJbmZvICE9PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuICFwcm9wZXJ0eUluZm8uYWNjZXB0c0Jvb2xlYW5zO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBwcmVmaXggPSBuYW1lLnRvTG93ZXJDYXNlKCkuc2xpY2UoMCwgNSk7XG4gICAgICAgICAgcmV0dXJuIHByZWZpeCAhPT0gJ2RhdGEtJyAmJiBwcmVmaXggIT09ICdhcmlhLSc7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cbmZ1bmN0aW9uIHNob3VsZFJlbW92ZUF0dHJpYnV0ZShuYW1lLCB2YWx1ZSwgcHJvcGVydHlJbmZvLCBpc0N1c3RvbUNvbXBvbmVudFRhZykge1xuICBpZiAodmFsdWUgPT09IG51bGwgfHwgdHlwZW9mIHZhbHVlID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKHNob3VsZFJlbW92ZUF0dHJpYnV0ZVdpdGhXYXJuaW5nKG5hbWUsIHZhbHVlLCBwcm9wZXJ0eUluZm8sIGlzQ3VzdG9tQ29tcG9uZW50VGFnKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKGlzQ3VzdG9tQ29tcG9uZW50VGFnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKHByb3BlcnR5SW5mbyAhPT0gbnVsbCkge1xuXG4gICAgc3dpdGNoIChwcm9wZXJ0eUluZm8udHlwZSkge1xuICAgICAgY2FzZSBCT09MRUFOOlxuICAgICAgICByZXR1cm4gIXZhbHVlO1xuXG4gICAgICBjYXNlIE9WRVJMT0FERURfQk9PTEVBTjpcbiAgICAgICAgcmV0dXJuIHZhbHVlID09PSBmYWxzZTtcblxuICAgICAgY2FzZSBOVU1FUklDOlxuICAgICAgICByZXR1cm4gaXNOYU4odmFsdWUpO1xuXG4gICAgICBjYXNlIFBPU0lUSVZFX05VTUVSSUM6XG4gICAgICAgIHJldHVybiBpc05hTih2YWx1ZSkgfHwgdmFsdWUgPCAxO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGdldFByb3BlcnR5SW5mbyhuYW1lKSB7XG4gIHJldHVybiBwcm9wZXJ0aWVzLmhhc093blByb3BlcnR5KG5hbWUpID8gcHJvcGVydGllc1tuYW1lXSA6IG51bGw7XG59XG5cbmZ1bmN0aW9uIFByb3BlcnR5SW5mb1JlY29yZChuYW1lLCB0eXBlLCBtdXN0VXNlUHJvcGVydHksIGF0dHJpYnV0ZU5hbWUsIGF0dHJpYnV0ZU5hbWVzcGFjZSwgc2FuaXRpemVVUkwsIHJlbW92ZUVtcHR5U3RyaW5nKSB7XG4gIHRoaXMuYWNjZXB0c0Jvb2xlYW5zID0gdHlwZSA9PT0gQk9PTEVBTklTSF9TVFJJTkcgfHwgdHlwZSA9PT0gQk9PTEVBTiB8fCB0eXBlID09PSBPVkVSTE9BREVEX0JPT0xFQU47XG4gIHRoaXMuYXR0cmlidXRlTmFtZSA9IGF0dHJpYnV0ZU5hbWU7XG4gIHRoaXMuYXR0cmlidXRlTmFtZXNwYWNlID0gYXR0cmlidXRlTmFtZXNwYWNlO1xuICB0aGlzLm11c3RVc2VQcm9wZXJ0eSA9IG11c3RVc2VQcm9wZXJ0eTtcbiAgdGhpcy5wcm9wZXJ0eU5hbWUgPSBuYW1lO1xuICB0aGlzLnR5cGUgPSB0eXBlO1xuICB0aGlzLnNhbml0aXplVVJMID0gc2FuaXRpemVVUkw7XG4gIHRoaXMucmVtb3ZlRW1wdHlTdHJpbmcgPSByZW1vdmVFbXB0eVN0cmluZztcbn0gLy8gV2hlbiBhZGRpbmcgYXR0cmlidXRlcyB0byB0aGlzIGxpc3QsIGJlIHN1cmUgdG8gYWxzbyBhZGQgdGhlbSB0b1xuLy8gdGhlIGBwb3NzaWJsZVN0YW5kYXJkTmFtZXNgIG1vZHVsZSB0byBlbnN1cmUgY2FzaW5nIGFuZCBpbmNvcnJlY3Rcbi8vIG5hbWUgd2FybmluZ3MuXG5cblxudmFyIHByb3BlcnRpZXMgPSB7fTsgLy8gVGhlc2UgcHJvcHMgYXJlIHJlc2VydmVkIGJ5IFJlYWN0LiBUaGV5IHNob3VsZG4ndCBiZSB3cml0dGVuIHRvIHRoZSBET00uXG5cbnZhciByZXNlcnZlZFByb3BzID0gWydjaGlsZHJlbicsICdkYW5nZXJvdXNseVNldElubmVySFRNTCcsIC8vIFRPRE86IFRoaXMgcHJldmVudHMgdGhlIGFzc2lnbm1lbnQgb2YgZGVmYXVsdFZhbHVlIHRvIHJlZ3VsYXJcbi8vIGVsZW1lbnRzIChub3QganVzdCBpbnB1dHMpLiBOb3cgdGhhdCBSZWFjdERPTUlucHV0IGFzc2lnbnMgdG8gdGhlXG4vLyBkZWZhdWx0VmFsdWUgcHJvcGVydHkgLS0gZG8gd2UgbmVlZCB0aGlzP1xuJ2RlZmF1bHRWYWx1ZScsICdkZWZhdWx0Q2hlY2tlZCcsICdpbm5lckhUTUwnLCAnc3VwcHJlc3NDb250ZW50RWRpdGFibGVXYXJuaW5nJywgJ3N1cHByZXNzSHlkcmF0aW9uV2FybmluZycsICdzdHlsZSddO1xucmVzZXJ2ZWRQcm9wcy5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gIHByb3BlcnRpZXNbbmFtZV0gPSBuZXcgUHJvcGVydHlJbmZvUmVjb3JkKG5hbWUsIFJFU0VSVkVELCBmYWxzZSwgLy8gbXVzdFVzZVByb3BlcnR5XG4gIG5hbWUsIC8vIGF0dHJpYnV0ZU5hbWVcbiAgbnVsbCwgLy8gYXR0cmlidXRlTmFtZXNwYWNlXG4gIGZhbHNlLCAvLyBzYW5pdGl6ZVVSTFxuICBmYWxzZSk7XG59KTsgLy8gQSBmZXcgUmVhY3Qgc3RyaW5nIGF0dHJpYnV0ZXMgaGF2ZSBhIGRpZmZlcmVudCBuYW1lLlxuLy8gVGhpcyBpcyBhIG1hcHBpbmcgZnJvbSBSZWFjdCBwcm9wIG5hbWVzIHRvIHRoZSBhdHRyaWJ1dGUgbmFtZXMuXG5cbltbJ2FjY2VwdENoYXJzZXQnLCAnYWNjZXB0LWNoYXJzZXQnXSwgWydjbGFzc05hbWUnLCAnY2xhc3MnXSwgWydodG1sRm9yJywgJ2ZvciddLCBbJ2h0dHBFcXVpdicsICdodHRwLWVxdWl2J11dLmZvckVhY2goZnVuY3Rpb24gKF9yZWYpIHtcbiAgdmFyIG5hbWUgPSBfcmVmWzBdLFxuICAgICAgYXR0cmlidXRlTmFtZSA9IF9yZWZbMV07XG4gIHByb3BlcnRpZXNbbmFtZV0gPSBuZXcgUHJvcGVydHlJbmZvUmVjb3JkKG5hbWUsIFNUUklORywgZmFsc2UsIC8vIG11c3RVc2VQcm9wZXJ0eVxuICBhdHRyaWJ1dGVOYW1lLCAvLyBhdHRyaWJ1dGVOYW1lXG4gIG51bGwsIC8vIGF0dHJpYnV0ZU5hbWVzcGFjZVxuICBmYWxzZSwgLy8gc2FuaXRpemVVUkxcbiAgZmFsc2UpO1xufSk7IC8vIFRoZXNlIGFyZSBcImVudW1lcmF0ZWRcIiBIVE1MIGF0dHJpYnV0ZXMgdGhhdCBhY2NlcHQgXCJ0cnVlXCIgYW5kIFwiZmFsc2VcIi5cbi8vIEluIFJlYWN0LCB3ZSBsZXQgdXNlcnMgcGFzcyBgdHJ1ZWAgYW5kIGBmYWxzZWAgZXZlbiB0aG91Z2ggdGVjaG5pY2FsbHlcbi8vIHRoZXNlIGFyZW4ndCBib29sZWFuIGF0dHJpYnV0ZXMgKHRoZXkgYXJlIGNvZXJjZWQgdG8gc3RyaW5ncykuXG5cblsnY29udGVudEVkaXRhYmxlJywgJ2RyYWdnYWJsZScsICdzcGVsbENoZWNrJywgJ3ZhbHVlJ10uZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICBwcm9wZXJ0aWVzW25hbWVdID0gbmV3IFByb3BlcnR5SW5mb1JlY29yZChuYW1lLCBCT09MRUFOSVNIX1NUUklORywgZmFsc2UsIC8vIG11c3RVc2VQcm9wZXJ0eVxuICBuYW1lLnRvTG93ZXJDYXNlKCksIC8vIGF0dHJpYnV0ZU5hbWVcbiAgbnVsbCwgLy8gYXR0cmlidXRlTmFtZXNwYWNlXG4gIGZhbHNlLCAvLyBzYW5pdGl6ZVVSTFxuICBmYWxzZSk7XG59KTsgLy8gVGhlc2UgYXJlIFwiZW51bWVyYXRlZFwiIFNWRyBhdHRyaWJ1dGVzIHRoYXQgYWNjZXB0IFwidHJ1ZVwiIGFuZCBcImZhbHNlXCIuXG4vLyBJbiBSZWFjdCwgd2UgbGV0IHVzZXJzIHBhc3MgYHRydWVgIGFuZCBgZmFsc2VgIGV2ZW4gdGhvdWdoIHRlY2huaWNhbGx5XG4vLyB0aGVzZSBhcmVuJ3QgYm9vbGVhbiBhdHRyaWJ1dGVzICh0aGV5IGFyZSBjb2VyY2VkIHRvIHN0cmluZ3MpLlxuLy8gU2luY2UgdGhlc2UgYXJlIFNWRyBhdHRyaWJ1dGVzLCB0aGVpciBhdHRyaWJ1dGUgbmFtZXMgYXJlIGNhc2Utc2Vuc2l0aXZlLlxuXG5bJ2F1dG9SZXZlcnNlJywgJ2V4dGVybmFsUmVzb3VyY2VzUmVxdWlyZWQnLCAnZm9jdXNhYmxlJywgJ3ByZXNlcnZlQWxwaGEnXS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gIHByb3BlcnRpZXNbbmFtZV0gPSBuZXcgUHJvcGVydHlJbmZvUmVjb3JkKG5hbWUsIEJPT0xFQU5JU0hfU1RSSU5HLCBmYWxzZSwgLy8gbXVzdFVzZVByb3BlcnR5XG4gIG5hbWUsIC8vIGF0dHJpYnV0ZU5hbWVcbiAgbnVsbCwgLy8gYXR0cmlidXRlTmFtZXNwYWNlXG4gIGZhbHNlLCAvLyBzYW5pdGl6ZVVSTFxuICBmYWxzZSk7XG59KTsgLy8gVGhlc2UgYXJlIEhUTUwgYm9vbGVhbiBhdHRyaWJ1dGVzLlxuXG5bJ2FsbG93RnVsbFNjcmVlbicsICdhc3luYycsIC8vIE5vdGU6IHRoZXJlIGlzIGEgc3BlY2lhbCBjYXNlIHRoYXQgcHJldmVudHMgaXQgZnJvbSBiZWluZyB3cml0dGVuIHRvIHRoZSBET01cbi8vIG9uIHRoZSBjbGllbnQgc2lkZSBiZWNhdXNlIHRoZSBicm93c2VycyBhcmUgaW5jb25zaXN0ZW50LiBJbnN0ZWFkIHdlIGNhbGwgZm9jdXMoKS5cbidhdXRvRm9jdXMnLCAnYXV0b1BsYXknLCAnY29udHJvbHMnLCAnZGVmYXVsdCcsICdkZWZlcicsICdkaXNhYmxlZCcsICdkaXNhYmxlUGljdHVyZUluUGljdHVyZScsICdkaXNhYmxlUmVtb3RlUGxheWJhY2snLCAnZm9ybU5vVmFsaWRhdGUnLCAnaGlkZGVuJywgJ2xvb3AnLCAnbm9Nb2R1bGUnLCAnbm9WYWxpZGF0ZScsICdvcGVuJywgJ3BsYXlzSW5saW5lJywgJ3JlYWRPbmx5JywgJ3JlcXVpcmVkJywgJ3JldmVyc2VkJywgJ3Njb3BlZCcsICdzZWFtbGVzcycsIC8vIE1pY3JvZGF0YVxuJ2l0ZW1TY29wZSddLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgcHJvcGVydGllc1tuYW1lXSA9IG5ldyBQcm9wZXJ0eUluZm9SZWNvcmQobmFtZSwgQk9PTEVBTiwgZmFsc2UsIC8vIG11c3RVc2VQcm9wZXJ0eVxuICBuYW1lLnRvTG93ZXJDYXNlKCksIC8vIGF0dHJpYnV0ZU5hbWVcbiAgbnVsbCwgLy8gYXR0cmlidXRlTmFtZXNwYWNlXG4gIGZhbHNlLCAvLyBzYW5pdGl6ZVVSTFxuICBmYWxzZSk7XG59KTsgLy8gVGhlc2UgYXJlIHRoZSBmZXcgUmVhY3QgcHJvcHMgdGhhdCB3ZSBzZXQgYXMgRE9NIHByb3BlcnRpZXNcbi8vIHJhdGhlciB0aGFuIGF0dHJpYnV0ZXMuIFRoZXNlIGFyZSBhbGwgYm9vbGVhbnMuXG5cblsnY2hlY2tlZCcsIC8vIE5vdGU6IGBvcHRpb24uc2VsZWN0ZWRgIGlzIG5vdCB1cGRhdGVkIGlmIGBzZWxlY3QubXVsdGlwbGVgIGlzXG4vLyBkaXNhYmxlZCB3aXRoIGByZW1vdmVBdHRyaWJ1dGVgLiBXZSBoYXZlIHNwZWNpYWwgbG9naWMgZm9yIGhhbmRsaW5nIHRoaXMuXG4nbXVsdGlwbGUnLCAnbXV0ZWQnLCAnc2VsZWN0ZWQnIC8vIE5PVEU6IGlmIHlvdSBhZGQgYSBjYW1lbENhc2VkIHByb3AgdG8gdGhpcyBsaXN0LFxuLy8geW91J2xsIG5lZWQgdG8gc2V0IGF0dHJpYnV0ZU5hbWUgdG8gbmFtZS50b0xvd2VyQ2FzZSgpXG4vLyBpbnN0ZWFkIGluIHRoZSBhc3NpZ25tZW50IGJlbG93LlxuXS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gIHByb3BlcnRpZXNbbmFtZV0gPSBuZXcgUHJvcGVydHlJbmZvUmVjb3JkKG5hbWUsIEJPT0xFQU4sIHRydWUsIC8vIG11c3RVc2VQcm9wZXJ0eVxuICBuYW1lLCAvLyBhdHRyaWJ1dGVOYW1lXG4gIG51bGwsIC8vIGF0dHJpYnV0ZU5hbWVzcGFjZVxuICBmYWxzZSwgLy8gc2FuaXRpemVVUkxcbiAgZmFsc2UpO1xufSk7IC8vIFRoZXNlIGFyZSBIVE1MIGF0dHJpYnV0ZXMgdGhhdCBhcmUgXCJvdmVybG9hZGVkIGJvb2xlYW5zXCI6IHRoZXkgYmVoYXZlIGxpa2Vcbi8vIGJvb2xlYW5zLCBidXQgY2FuIGFsc28gYWNjZXB0IGEgc3RyaW5nIHZhbHVlLlxuXG5bJ2NhcHR1cmUnLCAnZG93bmxvYWQnIC8vIE5PVEU6IGlmIHlvdSBhZGQgYSBjYW1lbENhc2VkIHByb3AgdG8gdGhpcyBsaXN0LFxuLy8geW91J2xsIG5lZWQgdG8gc2V0IGF0dHJpYnV0ZU5hbWUgdG8gbmFtZS50b0xvd2VyQ2FzZSgpXG4vLyBpbnN0ZWFkIGluIHRoZSBhc3NpZ25tZW50IGJlbG93LlxuXS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gIHByb3BlcnRpZXNbbmFtZV0gPSBuZXcgUHJvcGVydHlJbmZvUmVjb3JkKG5hbWUsIE9WRVJMT0FERURfQk9PTEVBTiwgZmFsc2UsIC8vIG11c3RVc2VQcm9wZXJ0eVxuICBuYW1lLCAvLyBhdHRyaWJ1dGVOYW1lXG4gIG51bGwsIC8vIGF0dHJpYnV0ZU5hbWVzcGFjZVxuICBmYWxzZSwgLy8gc2FuaXRpemVVUkxcbiAgZmFsc2UpO1xufSk7IC8vIFRoZXNlIGFyZSBIVE1MIGF0dHJpYnV0ZXMgdGhhdCBtdXN0IGJlIHBvc2l0aXZlIG51bWJlcnMuXG5cblsnY29scycsICdyb3dzJywgJ3NpemUnLCAnc3BhbicgLy8gTk9URTogaWYgeW91IGFkZCBhIGNhbWVsQ2FzZWQgcHJvcCB0byB0aGlzIGxpc3QsXG4vLyB5b3UnbGwgbmVlZCB0byBzZXQgYXR0cmlidXRlTmFtZSB0byBuYW1lLnRvTG93ZXJDYXNlKClcbi8vIGluc3RlYWQgaW4gdGhlIGFzc2lnbm1lbnQgYmVsb3cuXG5dLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgcHJvcGVydGllc1tuYW1lXSA9IG5ldyBQcm9wZXJ0eUluZm9SZWNvcmQobmFtZSwgUE9TSVRJVkVfTlVNRVJJQywgZmFsc2UsIC8vIG11c3RVc2VQcm9wZXJ0eVxuICBuYW1lLCAvLyBhdHRyaWJ1dGVOYW1lXG4gIG51bGwsIC8vIGF0dHJpYnV0ZU5hbWVzcGFjZVxuICBmYWxzZSwgLy8gc2FuaXRpemVVUkxcbiAgZmFsc2UpO1xufSk7IC8vIFRoZXNlIGFyZSBIVE1MIGF0dHJpYnV0ZXMgdGhhdCBtdXN0IGJlIG51bWJlcnMuXG5cblsncm93U3BhbicsICdzdGFydCddLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgcHJvcGVydGllc1tuYW1lXSA9IG5ldyBQcm9wZXJ0eUluZm9SZWNvcmQobmFtZSwgTlVNRVJJQywgZmFsc2UsIC8vIG11c3RVc2VQcm9wZXJ0eVxuICBuYW1lLnRvTG93ZXJDYXNlKCksIC8vIGF0dHJpYnV0ZU5hbWVcbiAgbnVsbCwgLy8gYXR0cmlidXRlTmFtZXNwYWNlXG4gIGZhbHNlLCAvLyBzYW5pdGl6ZVVSTFxuICBmYWxzZSk7XG59KTtcbnZhciBDQU1FTElaRSA9IC9bXFwtXFw6XShbYS16XSkvZztcblxudmFyIGNhcGl0YWxpemUgPSBmdW5jdGlvbiAodG9rZW4pIHtcbiAgcmV0dXJuIHRva2VuWzFdLnRvVXBwZXJDYXNlKCk7XG59OyAvLyBUaGlzIGlzIGEgbGlzdCBvZiBhbGwgU1ZHIGF0dHJpYnV0ZXMgdGhhdCBuZWVkIHNwZWNpYWwgY2FzaW5nLCBuYW1lc3BhY2luZyxcbi8vIG9yIGJvb2xlYW4gdmFsdWUgYXNzaWdubWVudC4gUmVndWxhciBhdHRyaWJ1dGVzIHRoYXQganVzdCBhY2NlcHQgc3RyaW5nc1xuLy8gYW5kIGhhdmUgdGhlIHNhbWUgbmFtZXMgYXJlIG9taXR0ZWQsIGp1c3QgbGlrZSBpbiB0aGUgSFRNTCBhdHRyaWJ1dGUgZmlsdGVyLlxuLy8gU29tZSBvZiB0aGVzZSBhdHRyaWJ1dGVzIGNhbiBiZSBoYXJkIHRvIGZpbmQuIFRoaXMgbGlzdCB3YXMgY3JlYXRlZCBieVxuLy8gc2NyYXBpbmcgdGhlIE1ETiBkb2N1bWVudGF0aW9uLlxuXG5cblsnYWNjZW50LWhlaWdodCcsICdhbGlnbm1lbnQtYmFzZWxpbmUnLCAnYXJhYmljLWZvcm0nLCAnYmFzZWxpbmUtc2hpZnQnLCAnY2FwLWhlaWdodCcsICdjbGlwLXBhdGgnLCAnY2xpcC1ydWxlJywgJ2NvbG9yLWludGVycG9sYXRpb24nLCAnY29sb3ItaW50ZXJwb2xhdGlvbi1maWx0ZXJzJywgJ2NvbG9yLXByb2ZpbGUnLCAnY29sb3ItcmVuZGVyaW5nJywgJ2RvbWluYW50LWJhc2VsaW5lJywgJ2VuYWJsZS1iYWNrZ3JvdW5kJywgJ2ZpbGwtb3BhY2l0eScsICdmaWxsLXJ1bGUnLCAnZmxvb2QtY29sb3InLCAnZmxvb2Qtb3BhY2l0eScsICdmb250LWZhbWlseScsICdmb250LXNpemUnLCAnZm9udC1zaXplLWFkanVzdCcsICdmb250LXN0cmV0Y2gnLCAnZm9udC1zdHlsZScsICdmb250LXZhcmlhbnQnLCAnZm9udC13ZWlnaHQnLCAnZ2x5cGgtbmFtZScsICdnbHlwaC1vcmllbnRhdGlvbi1ob3Jpem9udGFsJywgJ2dseXBoLW9yaWVudGF0aW9uLXZlcnRpY2FsJywgJ2hvcml6LWFkdi14JywgJ2hvcml6LW9yaWdpbi14JywgJ2ltYWdlLXJlbmRlcmluZycsICdsZXR0ZXItc3BhY2luZycsICdsaWdodGluZy1jb2xvcicsICdtYXJrZXItZW5kJywgJ21hcmtlci1taWQnLCAnbWFya2VyLXN0YXJ0JywgJ292ZXJsaW5lLXBvc2l0aW9uJywgJ292ZXJsaW5lLXRoaWNrbmVzcycsICdwYWludC1vcmRlcicsICdwYW5vc2UtMScsICdwb2ludGVyLWV2ZW50cycsICdyZW5kZXJpbmctaW50ZW50JywgJ3NoYXBlLXJlbmRlcmluZycsICdzdG9wLWNvbG9yJywgJ3N0b3Atb3BhY2l0eScsICdzdHJpa2V0aHJvdWdoLXBvc2l0aW9uJywgJ3N0cmlrZXRocm91Z2gtdGhpY2tuZXNzJywgJ3N0cm9rZS1kYXNoYXJyYXknLCAnc3Ryb2tlLWRhc2hvZmZzZXQnLCAnc3Ryb2tlLWxpbmVjYXAnLCAnc3Ryb2tlLWxpbmVqb2luJywgJ3N0cm9rZS1taXRlcmxpbWl0JywgJ3N0cm9rZS1vcGFjaXR5JywgJ3N0cm9rZS13aWR0aCcsICd0ZXh0LWFuY2hvcicsICd0ZXh0LWRlY29yYXRpb24nLCAndGV4dC1yZW5kZXJpbmcnLCAndW5kZXJsaW5lLXBvc2l0aW9uJywgJ3VuZGVybGluZS10aGlja25lc3MnLCAndW5pY29kZS1iaWRpJywgJ3VuaWNvZGUtcmFuZ2UnLCAndW5pdHMtcGVyLWVtJywgJ3YtYWxwaGFiZXRpYycsICd2LWhhbmdpbmcnLCAndi1pZGVvZ3JhcGhpYycsICd2LW1hdGhlbWF0aWNhbCcsICd2ZWN0b3ItZWZmZWN0JywgJ3ZlcnQtYWR2LXknLCAndmVydC1vcmlnaW4teCcsICd2ZXJ0LW9yaWdpbi15JywgJ3dvcmQtc3BhY2luZycsICd3cml0aW5nLW1vZGUnLCAneG1sbnM6eGxpbmsnLCAneC1oZWlnaHQnIC8vIE5PVEU6IGlmIHlvdSBhZGQgYSBjYW1lbENhc2VkIHByb3AgdG8gdGhpcyBsaXN0LFxuLy8geW91J2xsIG5lZWQgdG8gc2V0IGF0dHJpYnV0ZU5hbWUgdG8gbmFtZS50b0xvd2VyQ2FzZSgpXG4vLyBpbnN0ZWFkIGluIHRoZSBhc3NpZ25tZW50IGJlbG93LlxuXS5mb3JFYWNoKGZ1bmN0aW9uIChhdHRyaWJ1dGVOYW1lKSB7XG4gIHZhciBuYW1lID0gYXR0cmlidXRlTmFtZS5yZXBsYWNlKENBTUVMSVpFLCBjYXBpdGFsaXplKTtcbiAgcHJvcGVydGllc1tuYW1lXSA9IG5ldyBQcm9wZXJ0eUluZm9SZWNvcmQobmFtZSwgU1RSSU5HLCBmYWxzZSwgLy8gbXVzdFVzZVByb3BlcnR5XG4gIGF0dHJpYnV0ZU5hbWUsIG51bGwsIC8vIGF0dHJpYnV0ZU5hbWVzcGFjZVxuICBmYWxzZSwgLy8gc2FuaXRpemVVUkxcbiAgZmFsc2UpO1xufSk7IC8vIFN0cmluZyBTVkcgYXR0cmlidXRlcyB3aXRoIHRoZSB4bGluayBuYW1lc3BhY2UuXG5cblsneGxpbms6YWN0dWF0ZScsICd4bGluazphcmNyb2xlJywgJ3hsaW5rOnJvbGUnLCAneGxpbms6c2hvdycsICd4bGluazp0aXRsZScsICd4bGluazp0eXBlJyAvLyBOT1RFOiBpZiB5b3UgYWRkIGEgY2FtZWxDYXNlZCBwcm9wIHRvIHRoaXMgbGlzdCxcbi8vIHlvdSdsbCBuZWVkIHRvIHNldCBhdHRyaWJ1dGVOYW1lIHRvIG5hbWUudG9Mb3dlckNhc2UoKVxuLy8gaW5zdGVhZCBpbiB0aGUgYXNzaWdubWVudCBiZWxvdy5cbl0uZm9yRWFjaChmdW5jdGlvbiAoYXR0cmlidXRlTmFtZSkge1xuICB2YXIgbmFtZSA9IGF0dHJpYnV0ZU5hbWUucmVwbGFjZShDQU1FTElaRSwgY2FwaXRhbGl6ZSk7XG4gIHByb3BlcnRpZXNbbmFtZV0gPSBuZXcgUHJvcGVydHlJbmZvUmVjb3JkKG5hbWUsIFNUUklORywgZmFsc2UsIC8vIG11c3RVc2VQcm9wZXJ0eVxuICBhdHRyaWJ1dGVOYW1lLCAnaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycsIGZhbHNlLCAvLyBzYW5pdGl6ZVVSTFxuICBmYWxzZSk7XG59KTsgLy8gU3RyaW5nIFNWRyBhdHRyaWJ1dGVzIHdpdGggdGhlIHhtbCBuYW1lc3BhY2UuXG5cblsneG1sOmJhc2UnLCAneG1sOmxhbmcnLCAneG1sOnNwYWNlJyAvLyBOT1RFOiBpZiB5b3UgYWRkIGEgY2FtZWxDYXNlZCBwcm9wIHRvIHRoaXMgbGlzdCxcbi8vIHlvdSdsbCBuZWVkIHRvIHNldCBhdHRyaWJ1dGVOYW1lIHRvIG5hbWUudG9Mb3dlckNhc2UoKVxuLy8gaW5zdGVhZCBpbiB0aGUgYXNzaWdubWVudCBiZWxvdy5cbl0uZm9yRWFjaChmdW5jdGlvbiAoYXR0cmlidXRlTmFtZSkge1xuICB2YXIgbmFtZSA9IGF0dHJpYnV0ZU5hbWUucmVwbGFjZShDQU1FTElaRSwgY2FwaXRhbGl6ZSk7XG4gIHByb3BlcnRpZXNbbmFtZV0gPSBuZXcgUHJvcGVydHlJbmZvUmVjb3JkKG5hbWUsIFNUUklORywgZmFsc2UsIC8vIG11c3RVc2VQcm9wZXJ0eVxuICBhdHRyaWJ1dGVOYW1lLCAnaHR0cDovL3d3dy53My5vcmcvWE1MLzE5OTgvbmFtZXNwYWNlJywgZmFsc2UsIC8vIHNhbml0aXplVVJMXG4gIGZhbHNlKTtcbn0pOyAvLyBUaGVzZSBhdHRyaWJ1dGUgZXhpc3RzIGJvdGggaW4gSFRNTCBhbmQgU1ZHLlxuLy8gVGhlIGF0dHJpYnV0ZSBuYW1lIGlzIGNhc2Utc2Vuc2l0aXZlIGluIFNWRyBzbyB3ZSBjYW4ndCBqdXN0IHVzZVxuLy8gdGhlIFJlYWN0IG5hbWUgbGlrZSB3ZSBkbyBmb3IgYXR0cmlidXRlcyB0aGF0IGV4aXN0IG9ubHkgaW4gSFRNTC5cblxuWyd0YWJJbmRleCcsICdjcm9zc09yaWdpbiddLmZvckVhY2goZnVuY3Rpb24gKGF0dHJpYnV0ZU5hbWUpIHtcbiAgcHJvcGVydGllc1thdHRyaWJ1dGVOYW1lXSA9IG5ldyBQcm9wZXJ0eUluZm9SZWNvcmQoYXR0cmlidXRlTmFtZSwgU1RSSU5HLCBmYWxzZSwgLy8gbXVzdFVzZVByb3BlcnR5XG4gIGF0dHJpYnV0ZU5hbWUudG9Mb3dlckNhc2UoKSwgLy8gYXR0cmlidXRlTmFtZVxuICBudWxsLCAvLyBhdHRyaWJ1dGVOYW1lc3BhY2VcbiAgZmFsc2UsIC8vIHNhbml0aXplVVJMXG4gIGZhbHNlKTtcbn0pOyAvLyBUaGVzZSBhdHRyaWJ1dGVzIGFjY2VwdCBVUkxzLiBUaGVzZSBtdXN0IG5vdCBhbGxvdyBqYXZhc2NyaXB0OiBVUkxTLlxuLy8gVGhlc2Ugd2lsbCBhbHNvIG5lZWQgdG8gYWNjZXB0IFRydXN0ZWQgVHlwZXMgb2JqZWN0IGluIHRoZSBmdXR1cmUuXG5cbnZhciB4bGlua0hyZWYgPSAneGxpbmtIcmVmJztcbnByb3BlcnRpZXNbeGxpbmtIcmVmXSA9IG5ldyBQcm9wZXJ0eUluZm9SZWNvcmQoJ3hsaW5rSHJlZicsIFNUUklORywgZmFsc2UsIC8vIG11c3RVc2VQcm9wZXJ0eVxuJ3hsaW5rOmhyZWYnLCAnaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycsIHRydWUsIC8vIHNhbml0aXplVVJMXG5mYWxzZSk7XG5bJ3NyYycsICdocmVmJywgJ2FjdGlvbicsICdmb3JtQWN0aW9uJ10uZm9yRWFjaChmdW5jdGlvbiAoYXR0cmlidXRlTmFtZSkge1xuICBwcm9wZXJ0aWVzW2F0dHJpYnV0ZU5hbWVdID0gbmV3IFByb3BlcnR5SW5mb1JlY29yZChhdHRyaWJ1dGVOYW1lLCBTVFJJTkcsIGZhbHNlLCAvLyBtdXN0VXNlUHJvcGVydHlcbiAgYXR0cmlidXRlTmFtZS50b0xvd2VyQ2FzZSgpLCAvLyBhdHRyaWJ1dGVOYW1lXG4gIG51bGwsIC8vIGF0dHJpYnV0ZU5hbWVzcGFjZVxuICB0cnVlLCAvLyBzYW5pdGl6ZVVSTFxuICB0cnVlKTtcbn0pO1xuXG4vLyBhbmQgYW55IG5ld2xpbmUgb3IgdGFiIGFyZSBmaWx0ZXJlZCBvdXQgYXMgaWYgdGhleSdyZSBub3QgcGFydCBvZiB0aGUgVVJMLlxuLy8gaHR0cHM6Ly91cmwuc3BlYy53aGF0d2cub3JnLyN1cmwtcGFyc2luZ1xuLy8gVGFiIG9yIG5ld2xpbmUgYXJlIGRlZmluZWQgYXMgXFxyXFxuXFx0OlxuLy8gaHR0cHM6Ly9pbmZyYS5zcGVjLndoYXR3Zy5vcmcvI2FzY2lpLXRhYi1vci1uZXdsaW5lXG4vLyBBIEMwIGNvbnRyb2wgaXMgYSBjb2RlIHBvaW50IGluIHRoZSByYW5nZSBcXHUwMDAwIE5VTEwgdG8gXFx1MDAxRlxuLy8gSU5GT1JNQVRJT04gU0VQQVJBVE9SIE9ORSwgaW5jbHVzaXZlOlxuLy8gaHR0cHM6Ly9pbmZyYS5zcGVjLndoYXR3Zy5vcmcvI2MwLWNvbnRyb2wtb3Itc3BhY2VcblxuLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiAqL1xuXG52YXIgaXNKYXZhU2NyaXB0UHJvdG9jb2wgPSAvXltcXHUwMDAwLVxcdTAwMUYgXSpqW1xcclxcblxcdF0qYVtcXHJcXG5cXHRdKnZbXFxyXFxuXFx0XSphW1xcclxcblxcdF0qc1tcXHJcXG5cXHRdKmNbXFxyXFxuXFx0XSpyW1xcclxcblxcdF0qaVtcXHJcXG5cXHRdKnBbXFxyXFxuXFx0XSp0W1xcclxcblxcdF0qXFw6L2k7XG52YXIgZGlkV2FybiA9IGZhbHNlO1xuXG5mdW5jdGlvbiBzYW5pdGl6ZVVSTCh1cmwpIHtcbiAge1xuICAgIGlmICghZGlkV2FybiAmJiBpc0phdmFTY3JpcHRQcm90b2NvbC50ZXN0KHVybCkpIHtcbiAgICAgIGRpZFdhcm4gPSB0cnVlO1xuXG4gICAgICBlcnJvcignQSBmdXR1cmUgdmVyc2lvbiBvZiBSZWFjdCB3aWxsIGJsb2NrIGphdmFzY3JpcHQ6IFVSTHMgYXMgYSBzZWN1cml0eSBwcmVjYXV0aW9uLiAnICsgJ1VzZSBldmVudCBoYW5kbGVycyBpbnN0ZWFkIGlmIHlvdSBjYW4uIElmIHlvdSBuZWVkIHRvIGdlbmVyYXRlIHVuc2FmZSBIVE1MIHRyeSAnICsgJ3VzaW5nIGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MIGluc3RlYWQuIFJlYWN0IHdhcyBwYXNzZWQgJXMuJywgSlNPTi5zdHJpbmdpZnkodXJsKSk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogR2V0IHRoZSB2YWx1ZSBmb3IgYSBwcm9wZXJ0eSBvbiBhIG5vZGUuIE9ubHkgdXNlZCBpbiBERVYgZm9yIFNTUiB2YWxpZGF0aW9uLlxuICogVGhlIFwiZXhwZWN0ZWRcIiBhcmd1bWVudCBpcyB1c2VkIGFzIGEgaGludCBvZiB3aGF0IHRoZSBleHBlY3RlZCB2YWx1ZSBpcy5cbiAqIFNvbWUgcHJvcGVydGllcyBoYXZlIG11bHRpcGxlIGVxdWl2YWxlbnQgdmFsdWVzLlxuICovXG5mdW5jdGlvbiBnZXRWYWx1ZUZvclByb3BlcnR5KG5vZGUsIG5hbWUsIGV4cGVjdGVkLCBwcm9wZXJ0eUluZm8pIHtcbiAge1xuICAgIGlmIChwcm9wZXJ0eUluZm8ubXVzdFVzZVByb3BlcnR5KSB7XG4gICAgICB2YXIgcHJvcGVydHlOYW1lID0gcHJvcGVydHlJbmZvLnByb3BlcnR5TmFtZTtcbiAgICAgIHJldHVybiBub2RlW3Byb3BlcnR5TmFtZV07XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICggcHJvcGVydHlJbmZvLnNhbml0aXplVVJMKSB7XG4gICAgICAgIC8vIElmIHdlIGhhdmVuJ3QgZnVsbHkgZGlzYWJsZWQgamF2YXNjcmlwdDogVVJMcywgYW5kIGlmXG4gICAgICAgIC8vIHRoZSBoeWRyYXRpb24gaXMgc3VjY2Vzc2Z1bCBvZiBhIGphdmFzY3JpcHQ6IFVSTCwgd2VcbiAgICAgICAgLy8gc3RpbGwgd2FudCB0byB3YXJuIG9uIHRoZSBjbGllbnQuXG4gICAgICAgIHNhbml0aXplVVJMKCcnICsgZXhwZWN0ZWQpO1xuICAgICAgfVxuXG4gICAgICB2YXIgYXR0cmlidXRlTmFtZSA9IHByb3BlcnR5SW5mby5hdHRyaWJ1dGVOYW1lO1xuICAgICAgdmFyIHN0cmluZ1ZhbHVlID0gbnVsbDtcblxuICAgICAgaWYgKHByb3BlcnR5SW5mby50eXBlID09PSBPVkVSTE9BREVEX0JPT0xFQU4pIHtcbiAgICAgICAgaWYgKG5vZGUuaGFzQXR0cmlidXRlKGF0dHJpYnV0ZU5hbWUpKSB7XG4gICAgICAgICAgdmFyIHZhbHVlID0gbm9kZS5nZXRBdHRyaWJ1dGUoYXR0cmlidXRlTmFtZSk7XG5cbiAgICAgICAgICBpZiAodmFsdWUgPT09ICcnKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoc2hvdWxkUmVtb3ZlQXR0cmlidXRlKG5hbWUsIGV4cGVjdGVkLCBwcm9wZXJ0eUluZm8sIGZhbHNlKSkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICh2YWx1ZSA9PT0gJycgKyBleHBlY3RlZCkge1xuICAgICAgICAgICAgcmV0dXJuIGV4cGVjdGVkO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChub2RlLmhhc0F0dHJpYnV0ZShhdHRyaWJ1dGVOYW1lKSkge1xuICAgICAgICBpZiAoc2hvdWxkUmVtb3ZlQXR0cmlidXRlKG5hbWUsIGV4cGVjdGVkLCBwcm9wZXJ0eUluZm8sIGZhbHNlKSkge1xuICAgICAgICAgIC8vIFdlIGhhZCBhbiBhdHRyaWJ1dGUgYnV0IHNob3VsZG4ndCBoYXZlIGhhZCBvbmUsIHNvIHJlYWQgaXRcbiAgICAgICAgICAvLyBmb3IgdGhlIGVycm9yIG1lc3NhZ2UuXG4gICAgICAgICAgcmV0dXJuIG5vZGUuZ2V0QXR0cmlidXRlKGF0dHJpYnV0ZU5hbWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHByb3BlcnR5SW5mby50eXBlID09PSBCT09MRUFOKSB7XG4gICAgICAgICAgLy8gSWYgdGhpcyB3YXMgYSBib29sZWFuLCBpdCBkb2Vzbid0IG1hdHRlciB3aGF0IHRoZSB2YWx1ZSBpc1xuICAgICAgICAgIC8vIHRoZSBmYWN0IHRoYXQgd2UgaGF2ZSBpdCBpcyB0aGUgc2FtZSBhcyB0aGUgZXhwZWN0ZWQuXG4gICAgICAgICAgcmV0dXJuIGV4cGVjdGVkO1xuICAgICAgICB9IC8vIEV2ZW4gaWYgdGhpcyBwcm9wZXJ0eSB1c2VzIGEgbmFtZXNwYWNlIHdlIHVzZSBnZXRBdHRyaWJ1dGVcbiAgICAgICAgLy8gYmVjYXVzZSB3ZSBhc3N1bWUgaXRzIG5hbWVzcGFjZWQgbmFtZSBpcyB0aGUgc2FtZSBhcyBvdXIgY29uZmlnLlxuICAgICAgICAvLyBUbyB1c2UgZ2V0QXR0cmlidXRlTlMgd2UgbmVlZCB0aGUgbG9jYWwgbmFtZSB3aGljaCB3ZSBkb24ndCBoYXZlXG4gICAgICAgIC8vIGluIG91ciBjb25maWcgYXRtLlxuXG5cbiAgICAgICAgc3RyaW5nVmFsdWUgPSBub2RlLmdldEF0dHJpYnV0ZShhdHRyaWJ1dGVOYW1lKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHNob3VsZFJlbW92ZUF0dHJpYnV0ZShuYW1lLCBleHBlY3RlZCwgcHJvcGVydHlJbmZvLCBmYWxzZSkpIHtcbiAgICAgICAgcmV0dXJuIHN0cmluZ1ZhbHVlID09PSBudWxsID8gZXhwZWN0ZWQgOiBzdHJpbmdWYWx1ZTtcbiAgICAgIH0gZWxzZSBpZiAoc3RyaW5nVmFsdWUgPT09ICcnICsgZXhwZWN0ZWQpIHtcbiAgICAgICAgcmV0dXJuIGV4cGVjdGVkO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHN0cmluZ1ZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuLyoqXG4gKiBHZXQgdGhlIHZhbHVlIGZvciBhIGF0dHJpYnV0ZSBvbiBhIG5vZGUuIE9ubHkgdXNlZCBpbiBERVYgZm9yIFNTUiB2YWxpZGF0aW9uLlxuICogVGhlIHRoaXJkIGFyZ3VtZW50IGlzIHVzZWQgYXMgYSBoaW50IG9mIHdoYXQgdGhlIGV4cGVjdGVkIHZhbHVlIGlzLiBTb21lXG4gKiBhdHRyaWJ1dGVzIGhhdmUgbXVsdGlwbGUgZXF1aXZhbGVudCB2YWx1ZXMuXG4gKi9cblxuZnVuY3Rpb24gZ2V0VmFsdWVGb3JBdHRyaWJ1dGUobm9kZSwgbmFtZSwgZXhwZWN0ZWQpIHtcbiAge1xuICAgIGlmICghaXNBdHRyaWJ1dGVOYW1lU2FmZShuYW1lKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gSWYgdGhlIG9iamVjdCBpcyBhbiBvcGFxdWUgcmVmZXJlbmNlIElELCBpdCdzIGV4cGVjdGVkIHRoYXRcbiAgICAvLyB0aGUgbmV4dCBwcm9wIGlzIGRpZmZlcmVudCB0aGFuIHRoZSBzZXJ2ZXIgdmFsdWUsIHNvIGp1c3QgcmV0dXJuXG4gICAgLy8gZXhwZWN0ZWRcblxuXG4gICAgaWYgKGlzT3BhcXVlSHlkcmF0aW5nT2JqZWN0KGV4cGVjdGVkKSkge1xuICAgICAgcmV0dXJuIGV4cGVjdGVkO1xuICAgIH1cblxuICAgIGlmICghbm9kZS5oYXNBdHRyaWJ1dGUobmFtZSkpIHtcbiAgICAgIHJldHVybiBleHBlY3RlZCA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgdmFsdWUgPSBub2RlLmdldEF0dHJpYnV0ZShuYW1lKTtcblxuICAgIGlmICh2YWx1ZSA9PT0gJycgKyBleHBlY3RlZCkge1xuICAgICAgcmV0dXJuIGV4cGVjdGVkO1xuICAgIH1cblxuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxufVxuLyoqXG4gKiBTZXRzIHRoZSB2YWx1ZSBmb3IgYSBwcm9wZXJ0eSBvbiBhIG5vZGUuXG4gKlxuICogQHBhcmFtIHtET01FbGVtZW50fSBub2RlXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICogQHBhcmFtIHsqfSB2YWx1ZVxuICovXG5cbmZ1bmN0aW9uIHNldFZhbHVlRm9yUHJvcGVydHkobm9kZSwgbmFtZSwgdmFsdWUsIGlzQ3VzdG9tQ29tcG9uZW50VGFnKSB7XG4gIHZhciBwcm9wZXJ0eUluZm8gPSBnZXRQcm9wZXJ0eUluZm8obmFtZSk7XG5cbiAgaWYgKHNob3VsZElnbm9yZUF0dHJpYnV0ZShuYW1lLCBwcm9wZXJ0eUluZm8sIGlzQ3VzdG9tQ29tcG9uZW50VGFnKSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChzaG91bGRSZW1vdmVBdHRyaWJ1dGUobmFtZSwgdmFsdWUsIHByb3BlcnR5SW5mbywgaXNDdXN0b21Db21wb25lbnRUYWcpKSB7XG4gICAgdmFsdWUgPSBudWxsO1xuICB9IC8vIElmIHRoZSBwcm9wIGlzbid0IGluIHRoZSBzcGVjaWFsIGxpc3QsIHRyZWF0IGl0IGFzIGEgc2ltcGxlIGF0dHJpYnV0ZS5cblxuXG4gIGlmIChpc0N1c3RvbUNvbXBvbmVudFRhZyB8fCBwcm9wZXJ0eUluZm8gPT09IG51bGwpIHtcbiAgICBpZiAoaXNBdHRyaWJ1dGVOYW1lU2FmZShuYW1lKSkge1xuICAgICAgdmFyIF9hdHRyaWJ1dGVOYW1lID0gbmFtZTtcblxuICAgICAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgICAgIG5vZGUucmVtb3ZlQXR0cmlidXRlKF9hdHRyaWJ1dGVOYW1lKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5vZGUuc2V0QXR0cmlidXRlKF9hdHRyaWJ1dGVOYW1lLCAgJycgKyB2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIG11c3RVc2VQcm9wZXJ0eSA9IHByb3BlcnR5SW5mby5tdXN0VXNlUHJvcGVydHk7XG5cbiAgaWYgKG11c3RVc2VQcm9wZXJ0eSkge1xuICAgIHZhciBwcm9wZXJ0eU5hbWUgPSBwcm9wZXJ0eUluZm8ucHJvcGVydHlOYW1lO1xuXG4gICAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgICB2YXIgdHlwZSA9IHByb3BlcnR5SW5mby50eXBlO1xuICAgICAgbm9kZVtwcm9wZXJ0eU5hbWVdID0gdHlwZSA9PT0gQk9PTEVBTiA/IGZhbHNlIDogJyc7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIENvbnRyYXJ5IHRvIGBzZXRBdHRyaWJ1dGVgLCBvYmplY3QgcHJvcGVydGllcyBhcmUgcHJvcGVybHlcbiAgICAgIC8vIGB0b1N0cmluZ2BlZCBieSBJRTgvOS5cbiAgICAgIG5vZGVbcHJvcGVydHlOYW1lXSA9IHZhbHVlO1xuICAgIH1cblxuICAgIHJldHVybjtcbiAgfSAvLyBUaGUgcmVzdCBhcmUgdHJlYXRlZCBhcyBhdHRyaWJ1dGVzIHdpdGggc3BlY2lhbCBjYXNlcy5cblxuXG4gIHZhciBhdHRyaWJ1dGVOYW1lID0gcHJvcGVydHlJbmZvLmF0dHJpYnV0ZU5hbWUsXG4gICAgICBhdHRyaWJ1dGVOYW1lc3BhY2UgPSBwcm9wZXJ0eUluZm8uYXR0cmlidXRlTmFtZXNwYWNlO1xuXG4gIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgIG5vZGUucmVtb3ZlQXR0cmlidXRlKGF0dHJpYnV0ZU5hbWUpO1xuICB9IGVsc2Uge1xuICAgIHZhciBfdHlwZSA9IHByb3BlcnR5SW5mby50eXBlO1xuICAgIHZhciBhdHRyaWJ1dGVWYWx1ZTtcblxuICAgIGlmIChfdHlwZSA9PT0gQk9PTEVBTiB8fCBfdHlwZSA9PT0gT1ZFUkxPQURFRF9CT09MRUFOICYmIHZhbHVlID09PSB0cnVlKSB7XG4gICAgICAvLyBJZiBhdHRyaWJ1dGUgdHlwZSBpcyBib29sZWFuLCB3ZSBrbm93IGZvciBzdXJlIGl0IHdvbid0IGJlIGFuIGV4ZWN1dGlvbiBzaW5rXG4gICAgICAvLyBhbmQgd2Ugd29uJ3QgcmVxdWlyZSBUcnVzdGVkIFR5cGUgaGVyZS5cbiAgICAgIGF0dHJpYnV0ZVZhbHVlID0gJyc7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGBzZXRBdHRyaWJ1dGVgIHdpdGggb2JqZWN0cyBiZWNvbWVzIG9ubHkgYFtvYmplY3RdYCBpbiBJRTgvOSxcbiAgICAgIC8vICgnJyArIHZhbHVlKSBtYWtlcyBpdCBvdXRwdXQgdGhlIGNvcnJlY3QgdG9TdHJpbmcoKS12YWx1ZS5cbiAgICAgIHtcbiAgICAgICAgYXR0cmlidXRlVmFsdWUgPSAnJyArIHZhbHVlO1xuICAgICAgfVxuXG4gICAgICBpZiAocHJvcGVydHlJbmZvLnNhbml0aXplVVJMKSB7XG4gICAgICAgIHNhbml0aXplVVJMKGF0dHJpYnV0ZVZhbHVlLnRvU3RyaW5nKCkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChhdHRyaWJ1dGVOYW1lc3BhY2UpIHtcbiAgICAgIG5vZGUuc2V0QXR0cmlidXRlTlMoYXR0cmlidXRlTmFtZXNwYWNlLCBhdHRyaWJ1dGVOYW1lLCBhdHRyaWJ1dGVWYWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5vZGUuc2V0QXR0cmlidXRlKGF0dHJpYnV0ZU5hbWUsIGF0dHJpYnV0ZVZhbHVlKTtcbiAgICB9XG4gIH1cbn1cblxuLy8gQVRURU5USU9OXG4vLyBXaGVuIGFkZGluZyBuZXcgc3ltYm9scyB0byB0aGlzIGZpbGUsXG4vLyBQbGVhc2UgY29uc2lkZXIgYWxzbyBhZGRpbmcgdG8gJ3JlYWN0LWRldnRvb2xzLXNoYXJlZC9zcmMvYmFja2VuZC9SZWFjdFN5bWJvbHMnXG4vLyBUaGUgU3ltYm9sIHVzZWQgdG8gdGFnIHRoZSBSZWFjdEVsZW1lbnQtbGlrZSB0eXBlcy4gSWYgdGhlcmUgaXMgbm8gbmF0aXZlIFN5bWJvbFxuLy8gbm9yIHBvbHlmaWxsLCB0aGVuIGEgcGxhaW4gbnVtYmVyIGlzIHVzZWQgZm9yIHBlcmZvcm1hbmNlLlxudmFyIFJFQUNUX0VMRU1FTlRfVFlQRSA9IDB4ZWFjNztcbnZhciBSRUFDVF9QT1JUQUxfVFlQRSA9IDB4ZWFjYTtcbnZhciBSRUFDVF9GUkFHTUVOVF9UWVBFID0gMHhlYWNiO1xudmFyIFJFQUNUX1NUUklDVF9NT0RFX1RZUEUgPSAweGVhY2M7XG52YXIgUkVBQ1RfUFJPRklMRVJfVFlQRSA9IDB4ZWFkMjtcbnZhciBSRUFDVF9QUk9WSURFUl9UWVBFID0gMHhlYWNkO1xudmFyIFJFQUNUX0NPTlRFWFRfVFlQRSA9IDB4ZWFjZTtcbnZhciBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFID0gMHhlYWQwO1xudmFyIFJFQUNUX1NVU1BFTlNFX1RZUEUgPSAweGVhZDE7XG52YXIgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFID0gMHhlYWQ4O1xudmFyIFJFQUNUX01FTU9fVFlQRSA9IDB4ZWFkMztcbnZhciBSRUFDVF9MQVpZX1RZUEUgPSAweGVhZDQ7XG52YXIgUkVBQ1RfQkxPQ0tfVFlQRSA9IDB4ZWFkOTtcbnZhciBSRUFDVF9TRVJWRVJfQkxPQ0tfVFlQRSA9IDB4ZWFkYTtcbnZhciBSRUFDVF9GVU5EQU1FTlRBTF9UWVBFID0gMHhlYWQ1O1xudmFyIFJFQUNUX1NDT1BFX1RZUEUgPSAweGVhZDc7XG52YXIgUkVBQ1RfT1BBUVVFX0lEX1RZUEUgPSAweGVhZTA7XG52YXIgUkVBQ1RfREVCVUdfVFJBQ0lOR19NT0RFX1RZUEUgPSAweGVhZTE7XG52YXIgUkVBQ1RfT0ZGU0NSRUVOX1RZUEUgPSAweGVhZTI7XG52YXIgUkVBQ1RfTEVHQUNZX0hJRERFTl9UWVBFID0gMHhlYWUzO1xuXG5pZiAodHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2wuZm9yKSB7XG4gIHZhciBzeW1ib2xGb3IgPSBTeW1ib2wuZm9yO1xuICBSRUFDVF9FTEVNRU5UX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LmVsZW1lbnQnKTtcbiAgUkVBQ1RfUE9SVEFMX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LnBvcnRhbCcpO1xuICBSRUFDVF9GUkFHTUVOVF9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5mcmFnbWVudCcpO1xuICBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5zdHJpY3RfbW9kZScpO1xuICBSRUFDVF9QUk9GSUxFUl9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5wcm9maWxlcicpO1xuICBSRUFDVF9QUk9WSURFUl9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5wcm92aWRlcicpO1xuICBSRUFDVF9DT05URVhUX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LmNvbnRleHQnKTtcbiAgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSA9IHN5bWJvbEZvcigncmVhY3QuZm9yd2FyZF9yZWYnKTtcbiAgUkVBQ1RfU1VTUEVOU0VfVFlQRSA9IHN5bWJvbEZvcigncmVhY3Quc3VzcGVuc2UnKTtcbiAgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5zdXNwZW5zZV9saXN0Jyk7XG4gIFJFQUNUX01FTU9fVFlQRSA9IHN5bWJvbEZvcigncmVhY3QubWVtbycpO1xuICBSRUFDVF9MQVpZX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LmxhenknKTtcbiAgUkVBQ1RfQkxPQ0tfVFlQRSA9IHN5bWJvbEZvcigncmVhY3QuYmxvY2snKTtcbiAgUkVBQ1RfU0VSVkVSX0JMT0NLX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LnNlcnZlci5ibG9jaycpO1xuICBSRUFDVF9GVU5EQU1FTlRBTF9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5mdW5kYW1lbnRhbCcpO1xuICBSRUFDVF9TQ09QRV9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5zY29wZScpO1xuICBSRUFDVF9PUEFRVUVfSURfVFlQRSA9IHN5bWJvbEZvcigncmVhY3Qub3BhcXVlLmlkJyk7XG4gIFJFQUNUX0RFQlVHX1RSQUNJTkdfTU9ERV9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5kZWJ1Z190cmFjZV9tb2RlJyk7XG4gIFJFQUNUX09GRlNDUkVFTl9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5vZmZzY3JlZW4nKTtcbiAgUkVBQ1RfTEVHQUNZX0hJRERFTl9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5sZWdhY3lfaGlkZGVuJyk7XG59XG5cbnZhciBNQVlCRV9JVEVSQVRPUl9TWU1CT0wgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC5pdGVyYXRvcjtcbnZhciBGQVVYX0lURVJBVE9SX1NZTUJPTCA9ICdAQGl0ZXJhdG9yJztcbmZ1bmN0aW9uIGdldEl0ZXJhdG9yRm4obWF5YmVJdGVyYWJsZSkge1xuICBpZiAobWF5YmVJdGVyYWJsZSA9PT0gbnVsbCB8fCB0eXBlb2YgbWF5YmVJdGVyYWJsZSAhPT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBtYXliZUl0ZXJhdG9yID0gTUFZQkVfSVRFUkFUT1JfU1lNQk9MICYmIG1heWJlSXRlcmFibGVbTUFZQkVfSVRFUkFUT1JfU1lNQk9MXSB8fCBtYXliZUl0ZXJhYmxlW0ZBVVhfSVRFUkFUT1JfU1lNQk9MXTtcblxuICBpZiAodHlwZW9mIG1heWJlSXRlcmF0b3IgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gbWF5YmVJdGVyYXRvcjtcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG4vLyBIZWxwZXJzIHRvIHBhdGNoIGNvbnNvbGUubG9ncyB0byBhdm9pZCBsb2dnaW5nIGR1cmluZyBzaWRlLWVmZmVjdCBmcmVlXG4vLyByZXBsYXlpbmcgb24gcmVuZGVyIGZ1bmN0aW9uLiBUaGlzIGN1cnJlbnRseSBvbmx5IHBhdGNoZXMgdGhlIG9iamVjdFxuLy8gbGF6aWx5IHdoaWNoIHdvbid0IGNvdmVyIGlmIHRoZSBsb2cgZnVuY3Rpb24gd2FzIGV4dHJhY3RlZCBlYWdlcmx5LlxuLy8gV2UgY291bGQgYWxzbyBlYWdlcmx5IHBhdGNoIHRoZSBtZXRob2QuXG52YXIgZGlzYWJsZWREZXB0aCA9IDA7XG52YXIgcHJldkxvZztcbnZhciBwcmV2SW5mbztcbnZhciBwcmV2V2FybjtcbnZhciBwcmV2RXJyb3I7XG52YXIgcHJldkdyb3VwO1xudmFyIHByZXZHcm91cENvbGxhcHNlZDtcbnZhciBwcmV2R3JvdXBFbmQ7XG5cbmZ1bmN0aW9uIGRpc2FibGVkTG9nKCkge31cblxuZGlzYWJsZWRMb2cuX19yZWFjdERpc2FibGVkTG9nID0gdHJ1ZTtcbmZ1bmN0aW9uIGRpc2FibGVMb2dzKCkge1xuICB7XG4gICAgaWYgKGRpc2FibGVkRGVwdGggPT09IDApIHtcbiAgICAgIC8qIGVzbGludC1kaXNhYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgICAgcHJldkxvZyA9IGNvbnNvbGUubG9nO1xuICAgICAgcHJldkluZm8gPSBjb25zb2xlLmluZm87XG4gICAgICBwcmV2V2FybiA9IGNvbnNvbGUud2FybjtcbiAgICAgIHByZXZFcnJvciA9IGNvbnNvbGUuZXJyb3I7XG4gICAgICBwcmV2R3JvdXAgPSBjb25zb2xlLmdyb3VwO1xuICAgICAgcHJldkdyb3VwQ29sbGFwc2VkID0gY29uc29sZS5ncm91cENvbGxhcHNlZDtcbiAgICAgIHByZXZHcm91cEVuZCA9IGNvbnNvbGUuZ3JvdXBFbmQ7IC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTkwOTlcblxuICAgICAgdmFyIHByb3BzID0ge1xuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIHZhbHVlOiBkaXNhYmxlZExvZyxcbiAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgIH07IC8vICRGbG93Rml4TWUgRmxvdyB0aGlua3MgY29uc29sZSBpcyBpbW11dGFibGUuXG5cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGNvbnNvbGUsIHtcbiAgICAgICAgaW5mbzogcHJvcHMsXG4gICAgICAgIGxvZzogcHJvcHMsXG4gICAgICAgIHdhcm46IHByb3BzLFxuICAgICAgICBlcnJvcjogcHJvcHMsXG4gICAgICAgIGdyb3VwOiBwcm9wcyxcbiAgICAgICAgZ3JvdXBDb2xsYXBzZWQ6IHByb3BzLFxuICAgICAgICBncm91cEVuZDogcHJvcHNcbiAgICAgIH0pO1xuICAgICAgLyogZXNsaW50LWVuYWJsZSByZWFjdC1pbnRlcm5hbC9uby1wcm9kdWN0aW9uLWxvZ2dpbmcgKi9cbiAgICB9XG5cbiAgICBkaXNhYmxlZERlcHRoKys7XG4gIH1cbn1cbmZ1bmN0aW9uIHJlZW5hYmxlTG9ncygpIHtcbiAge1xuICAgIGRpc2FibGVkRGVwdGgtLTtcblxuICAgIGlmIChkaXNhYmxlZERlcHRoID09PSAwKSB7XG4gICAgICAvKiBlc2xpbnQtZGlzYWJsZSByZWFjdC1pbnRlcm5hbC9uby1wcm9kdWN0aW9uLWxvZ2dpbmcgKi9cbiAgICAgIHZhciBwcm9wcyA9IHtcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgfTsgLy8gJEZsb3dGaXhNZSBGbG93IHRoaW5rcyBjb25zb2xlIGlzIGltbXV0YWJsZS5cblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoY29uc29sZSwge1xuICAgICAgICBsb2c6IF9hc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZMb2dcbiAgICAgICAgfSksXG4gICAgICAgIGluZm86IF9hc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZJbmZvXG4gICAgICAgIH0pLFxuICAgICAgICB3YXJuOiBfYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2V2FyblxuICAgICAgICB9KSxcbiAgICAgICAgZXJyb3I6IF9hc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZFcnJvclxuICAgICAgICB9KSxcbiAgICAgICAgZ3JvdXA6IF9hc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZHcm91cFxuICAgICAgICB9KSxcbiAgICAgICAgZ3JvdXBDb2xsYXBzZWQ6IF9hc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZHcm91cENvbGxhcHNlZFxuICAgICAgICB9KSxcbiAgICAgICAgZ3JvdXBFbmQ6IF9hc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZHcm91cEVuZFxuICAgICAgICB9KVxuICAgICAgfSk7XG4gICAgICAvKiBlc2xpbnQtZW5hYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgIH1cblxuICAgIGlmIChkaXNhYmxlZERlcHRoIDwgMCkge1xuICAgICAgZXJyb3IoJ2Rpc2FibGVkRGVwdGggZmVsbCBiZWxvdyB6ZXJvLiAnICsgJ1RoaXMgaXMgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgIH1cbiAgfVxufVxuXG52YXIgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0Q3VycmVudERpc3BhdGNoZXI7XG52YXIgcHJlZml4O1xuZnVuY3Rpb24gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUobmFtZSwgc291cmNlLCBvd25lckZuKSB7XG4gIHtcbiAgICBpZiAocHJlZml4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIEV4dHJhY3QgdGhlIFZNIHNwZWNpZmljIHByZWZpeCB1c2VkIGJ5IGVhY2ggbGluZS5cbiAgICAgIHRyeSB7XG4gICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgIHZhciBtYXRjaCA9IHguc3RhY2sudHJpbSgpLm1hdGNoKC9cXG4oICooYXQgKT8pLyk7XG4gICAgICAgIHByZWZpeCA9IG1hdGNoICYmIG1hdGNoWzFdIHx8ICcnO1xuICAgICAgfVxuICAgIH0gLy8gV2UgdXNlIHRoZSBwcmVmaXggdG8gZW5zdXJlIG91ciBzdGFja3MgbGluZSB1cCB3aXRoIG5hdGl2ZSBzdGFjayBmcmFtZXMuXG5cblxuICAgIHJldHVybiAnXFxuJyArIHByZWZpeCArIG5hbWU7XG4gIH1cbn1cbnZhciByZWVudHJ5ID0gZmFsc2U7XG52YXIgY29tcG9uZW50RnJhbWVDYWNoZTtcblxue1xuICB2YXIgUG9zc2libHlXZWFrTWFwID0gdHlwZW9mIFdlYWtNYXAgPT09ICdmdW5jdGlvbicgPyBXZWFrTWFwIDogTWFwO1xuICBjb21wb25lbnRGcmFtZUNhY2hlID0gbmV3IFBvc3NpYmx5V2Vha01hcCgpO1xufVxuXG5mdW5jdGlvbiBkZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lKGZuLCBjb25zdHJ1Y3QpIHtcbiAgLy8gSWYgc29tZXRoaW5nIGFza2VkIGZvciBhIHN0YWNrIGluc2lkZSBhIGZha2UgcmVuZGVyLCBpdCBzaG91bGQgZ2V0IGlnbm9yZWQuXG4gIGlmICghZm4gfHwgcmVlbnRyeSkge1xuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIHtcbiAgICB2YXIgZnJhbWUgPSBjb21wb25lbnRGcmFtZUNhY2hlLmdldChmbik7XG5cbiAgICBpZiAoZnJhbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGZyYW1lO1xuICAgIH1cbiAgfVxuXG4gIHZhciBjb250cm9sO1xuICByZWVudHJ5ID0gdHJ1ZTtcbiAgdmFyIHByZXZpb3VzUHJlcGFyZVN0YWNrVHJhY2UgPSBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZTsgLy8gJEZsb3dGaXhNZSBJdCBkb2VzIGFjY2VwdCB1bmRlZmluZWQuXG5cbiAgRXJyb3IucHJlcGFyZVN0YWNrVHJhY2UgPSB1bmRlZmluZWQ7XG4gIHZhciBwcmV2aW91c0Rpc3BhdGNoZXI7XG5cbiAge1xuICAgIHByZXZpb3VzRGlzcGF0Y2hlciA9IFJlYWN0Q3VycmVudERpc3BhdGNoZXIuY3VycmVudDsgLy8gU2V0IHRoZSBkaXNwYXRjaGVyIGluIERFViBiZWNhdXNlIHRoaXMgbWlnaHQgYmUgY2FsbCBpbiB0aGUgcmVuZGVyIGZ1bmN0aW9uXG4gICAgLy8gZm9yIHdhcm5pbmdzLlxuXG4gICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlci5jdXJyZW50ID0gbnVsbDtcbiAgICBkaXNhYmxlTG9ncygpO1xuICB9XG5cbiAgdHJ5IHtcbiAgICAvLyBUaGlzIHNob3VsZCB0aHJvdy5cbiAgICBpZiAoY29uc3RydWN0KSB7XG4gICAgICAvLyBTb21ldGhpbmcgc2hvdWxkIGJlIHNldHRpbmcgdGhlIHByb3BzIGluIHRoZSBjb25zdHJ1Y3Rvci5cbiAgICAgIHZhciBGYWtlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgfTsgLy8gJEZsb3dGaXhNZVxuXG5cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShGYWtlLnByb3RvdHlwZSwgJ3Byb3BzJywge1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAvLyBXZSB1c2UgYSB0aHJvd2luZyBzZXR0ZXIgaW5zdGVhZCBvZiBmcm96ZW4gb3Igbm9uLXdyaXRhYmxlIHByb3BzXG4gICAgICAgICAgLy8gYmVjYXVzZSB0aGF0IHdvbid0IHRocm93IGluIGEgbm9uLXN0cmljdCBtb2RlIGZ1bmN0aW9uLlxuICAgICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09ICdvYmplY3QnICYmIFJlZmxlY3QuY29uc3RydWN0KSB7XG4gICAgICAgIC8vIFdlIGNvbnN0cnVjdCBhIGRpZmZlcmVudCBjb250cm9sIGZvciB0aGlzIGNhc2UgdG8gaW5jbHVkZSBhbnkgZXh0cmFcbiAgICAgICAgLy8gZnJhbWVzIGFkZGVkIGJ5IHRoZSBjb25zdHJ1Y3QgY2FsbC5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBSZWZsZWN0LmNvbnN0cnVjdChGYWtlLCBbXSk7XG4gICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICBjb250cm9sID0geDtcbiAgICAgICAgfVxuXG4gICAgICAgIFJlZmxlY3QuY29uc3RydWN0KGZuLCBbXSwgRmFrZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIEZha2UuY2FsbCgpO1xuICAgICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgICAgY29udHJvbCA9IHg7XG4gICAgICAgIH1cblxuICAgICAgICBmbi5jYWxsKEZha2UucHJvdG90eXBlKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgY29udHJvbCA9IHg7XG4gICAgICB9XG5cbiAgICAgIGZuKCk7XG4gICAgfVxuICB9IGNhdGNoIChzYW1wbGUpIHtcbiAgICAvLyBUaGlzIGlzIGlubGluZWQgbWFudWFsbHkgYmVjYXVzZSBjbG9zdXJlIGRvZXNuJ3QgZG8gaXQgZm9yIHVzLlxuICAgIGlmIChzYW1wbGUgJiYgY29udHJvbCAmJiB0eXBlb2Ygc2FtcGxlLnN0YWNrID09PSAnc3RyaW5nJykge1xuICAgICAgLy8gVGhpcyBleHRyYWN0cyB0aGUgZmlyc3QgZnJhbWUgZnJvbSB0aGUgc2FtcGxlIHRoYXQgaXNuJ3QgYWxzbyBpbiB0aGUgY29udHJvbC5cbiAgICAgIC8vIFNraXBwaW5nIG9uZSBmcmFtZSB0aGF0IHdlIGFzc3VtZSBpcyB0aGUgZnJhbWUgdGhhdCBjYWxscyB0aGUgdHdvLlxuICAgICAgdmFyIHNhbXBsZUxpbmVzID0gc2FtcGxlLnN0YWNrLnNwbGl0KCdcXG4nKTtcbiAgICAgIHZhciBjb250cm9sTGluZXMgPSBjb250cm9sLnN0YWNrLnNwbGl0KCdcXG4nKTtcbiAgICAgIHZhciBzID0gc2FtcGxlTGluZXMubGVuZ3RoIC0gMTtcbiAgICAgIHZhciBjID0gY29udHJvbExpbmVzLmxlbmd0aCAtIDE7XG5cbiAgICAgIHdoaWxlIChzID49IDEgJiYgYyA+PSAwICYmIHNhbXBsZUxpbmVzW3NdICE9PSBjb250cm9sTGluZXNbY10pIHtcbiAgICAgICAgLy8gV2UgZXhwZWN0IGF0IGxlYXN0IG9uZSBzdGFjayBmcmFtZSB0byBiZSBzaGFyZWQuXG4gICAgICAgIC8vIFR5cGljYWxseSB0aGlzIHdpbGwgYmUgdGhlIHJvb3QgbW9zdCBvbmUuIEhvd2V2ZXIsIHN0YWNrIGZyYW1lcyBtYXkgYmVcbiAgICAgICAgLy8gY3V0IG9mZiBkdWUgdG8gbWF4aW11bSBzdGFjayBsaW1pdHMuIEluIHRoaXMgY2FzZSwgb25lIG1heWJlIGN1dCBvZmZcbiAgICAgICAgLy8gZWFybGllciB0aGFuIHRoZSBvdGhlci4gV2UgYXNzdW1lIHRoYXQgdGhlIHNhbXBsZSBpcyBsb25nZXIgb3IgdGhlIHNhbWVcbiAgICAgICAgLy8gYW5kIHRoZXJlIGZvciBjdXQgb2ZmIGVhcmxpZXIuIFNvIHdlIHNob3VsZCBmaW5kIHRoZSByb290IG1vc3QgZnJhbWUgaW5cbiAgICAgICAgLy8gdGhlIHNhbXBsZSBzb21ld2hlcmUgaW4gdGhlIGNvbnRyb2wuXG4gICAgICAgIGMtLTtcbiAgICAgIH1cblxuICAgICAgZm9yICg7IHMgPj0gMSAmJiBjID49IDA7IHMtLSwgYy0tKSB7XG4gICAgICAgIC8vIE5leHQgd2UgZmluZCB0aGUgZmlyc3Qgb25lIHRoYXQgaXNuJ3QgdGhlIHNhbWUgd2hpY2ggc2hvdWxkIGJlIHRoZVxuICAgICAgICAvLyBmcmFtZSB0aGF0IGNhbGxlZCBvdXIgc2FtcGxlIGZ1bmN0aW9uIGFuZCB0aGUgY29udHJvbC5cbiAgICAgICAgaWYgKHNhbXBsZUxpbmVzW3NdICE9PSBjb250cm9sTGluZXNbY10pIHtcbiAgICAgICAgICAvLyBJbiBWOCwgdGhlIGZpcnN0IGxpbmUgaXMgZGVzY3JpYmluZyB0aGUgbWVzc2FnZSBidXQgb3RoZXIgVk1zIGRvbid0LlxuICAgICAgICAgIC8vIElmIHdlJ3JlIGFib3V0IHRvIHJldHVybiB0aGUgZmlyc3QgbGluZSwgYW5kIHRoZSBjb250cm9sIGlzIGFsc28gb24gdGhlIHNhbWVcbiAgICAgICAgICAvLyBsaW5lLCB0aGF0J3MgYSBwcmV0dHkgZ29vZCBpbmRpY2F0b3IgdGhhdCBvdXIgc2FtcGxlIHRocmV3IGF0IHNhbWUgbGluZSBhc1xuICAgICAgICAgIC8vIHRoZSBjb250cm9sLiBJLmUuIGJlZm9yZSB3ZSBlbnRlcmVkIHRoZSBzYW1wbGUgZnJhbWUuIFNvIHdlIGlnbm9yZSB0aGlzIHJlc3VsdC5cbiAgICAgICAgICAvLyBUaGlzIGNhbiBoYXBwZW4gaWYgeW91IHBhc3NlZCBhIGNsYXNzIHRvIGZ1bmN0aW9uIGNvbXBvbmVudCwgb3Igbm9uLWZ1bmN0aW9uLlxuICAgICAgICAgIGlmIChzICE9PSAxIHx8IGMgIT09IDEpIHtcbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgcy0tO1xuICAgICAgICAgICAgICBjLS07IC8vIFdlIG1heSBzdGlsbCBoYXZlIHNpbWlsYXIgaW50ZXJtZWRpYXRlIGZyYW1lcyBmcm9tIHRoZSBjb25zdHJ1Y3QgY2FsbC5cbiAgICAgICAgICAgICAgLy8gVGhlIG5leHQgb25lIHRoYXQgaXNuJ3QgdGhlIHNhbWUgc2hvdWxkIGJlIG91ciBtYXRjaCB0aG91Z2guXG5cbiAgICAgICAgICAgICAgaWYgKGMgPCAwIHx8IHNhbXBsZUxpbmVzW3NdICE9PSBjb250cm9sTGluZXNbY10pIHtcbiAgICAgICAgICAgICAgICAvLyBWOCBhZGRzIGEgXCJuZXdcIiBwcmVmaXggZm9yIG5hdGl2ZSBjbGFzc2VzLiBMZXQncyByZW1vdmUgaXQgdG8gbWFrZSBpdCBwcmV0dGllci5cbiAgICAgICAgICAgICAgICB2YXIgX2ZyYW1lID0gJ1xcbicgKyBzYW1wbGVMaW5lc1tzXS5yZXBsYWNlKCcgYXQgbmV3ICcsICcgYXQgJyk7XG5cbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudEZyYW1lQ2FjaGUuc2V0KGZuLCBfZnJhbWUpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gLy8gUmV0dXJuIHRoZSBsaW5lIHdlIGZvdW5kLlxuXG5cbiAgICAgICAgICAgICAgICByZXR1cm4gX2ZyYW1lO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IHdoaWxlIChzID49IDEgJiYgYyA+PSAwKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSBmaW5hbGx5IHtcbiAgICByZWVudHJ5ID0gZmFsc2U7XG5cbiAgICB7XG4gICAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyLmN1cnJlbnQgPSBwcmV2aW91c0Rpc3BhdGNoZXI7XG4gICAgICByZWVuYWJsZUxvZ3MoKTtcbiAgICB9XG5cbiAgICBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZSA9IHByZXZpb3VzUHJlcGFyZVN0YWNrVHJhY2U7XG4gIH0gLy8gRmFsbGJhY2sgdG8ganVzdCB1c2luZyB0aGUgbmFtZSBpZiB3ZSBjb3VsZG4ndCBtYWtlIGl0IHRocm93LlxuXG5cbiAgdmFyIG5hbWUgPSBmbiA/IGZuLmRpc3BsYXlOYW1lIHx8IGZuLm5hbWUgOiAnJztcbiAgdmFyIHN5bnRoZXRpY0ZyYW1lID0gbmFtZSA/IGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKG5hbWUpIDogJyc7XG5cbiAge1xuICAgIGlmICh0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNvbXBvbmVudEZyYW1lQ2FjaGUuc2V0KGZuLCBzeW50aGV0aWNGcmFtZSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHN5bnRoZXRpY0ZyYW1lO1xufVxuXG5mdW5jdGlvbiBkZXNjcmliZUNsYXNzQ29tcG9uZW50RnJhbWUoY3Rvciwgc291cmNlLCBvd25lckZuKSB7XG4gIHtcbiAgICByZXR1cm4gZGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZShjdG9yLCB0cnVlKTtcbiAgfVxufVxuZnVuY3Rpb24gZGVzY3JpYmVGdW5jdGlvbkNvbXBvbmVudEZyYW1lKGZuLCBzb3VyY2UsIG93bmVyRm4pIHtcbiAge1xuICAgIHJldHVybiBkZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lKGZuLCBmYWxzZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gc2hvdWxkQ29uc3RydWN0KENvbXBvbmVudCkge1xuICB2YXIgcHJvdG90eXBlID0gQ29tcG9uZW50LnByb3RvdHlwZTtcbiAgcmV0dXJuICEhKHByb3RvdHlwZSAmJiBwcm90b3R5cGUuaXNSZWFjdENvbXBvbmVudCk7XG59XG5cbmZ1bmN0aW9uIGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVih0eXBlLCBzb3VyY2UsIG93bmVyRm4pIHtcblxuICBpZiAodHlwZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAge1xuICAgICAgcmV0dXJuIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUodHlwZSwgc2hvdWxkQ29uc3RydWN0KHR5cGUpKTtcbiAgICB9XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKHR5cGUpO1xuICB9XG5cbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9UWVBFOlxuICAgICAgcmV0dXJuIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKCdTdXNwZW5zZScpO1xuXG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEU6XG4gICAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUoJ1N1c3BlbnNlTGlzdCcpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0Jykge1xuICAgIHN3aXRjaCAodHlwZS4kJHR5cGVvZikge1xuICAgICAgY2FzZSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFOlxuICAgICAgICByZXR1cm4gZGVzY3JpYmVGdW5jdGlvbkNvbXBvbmVudEZyYW1lKHR5cGUucmVuZGVyKTtcblxuICAgICAgY2FzZSBSRUFDVF9NRU1PX1RZUEU6XG4gICAgICAgIC8vIE1lbW8gbWF5IGNvbnRhaW4gYW55IGNvbXBvbmVudCB0eXBlIHNvIHdlIHJlY3Vyc2l2ZWx5IHJlc29sdmUgaXQuXG4gICAgICAgIHJldHVybiBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYodHlwZS50eXBlLCBzb3VyY2UsIG93bmVyRm4pO1xuXG4gICAgICBjYXNlIFJFQUNUX0JMT0NLX1RZUEU6XG4gICAgICAgIHJldHVybiBkZXNjcmliZUZ1bmN0aW9uQ29tcG9uZW50RnJhbWUodHlwZS5fcmVuZGVyKTtcblxuICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgbGF6eUNvbXBvbmVudCA9IHR5cGU7XG4gICAgICAgICAgdmFyIHBheWxvYWQgPSBsYXp5Q29tcG9uZW50Ll9wYXlsb2FkO1xuICAgICAgICAgIHZhciBpbml0ID0gbGF6eUNvbXBvbmVudC5faW5pdDtcblxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBMYXp5IG1heSBjb250YWluIGFueSBjb21wb25lbnQgdHlwZSBzbyB3ZSByZWN1cnNpdmVseSByZXNvbHZlIGl0LlxuICAgICAgICAgICAgcmV0dXJuIGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVihpbml0KHBheWxvYWQpLCBzb3VyY2UsIG93bmVyRm4pO1xuICAgICAgICAgIH0gY2F0Y2ggKHgpIHt9XG4gICAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gJyc7XG59XG5cbmZ1bmN0aW9uIGRlc2NyaWJlRmliZXIoZmliZXIpIHtcbiAgdmFyIG93bmVyID0gIGZpYmVyLl9kZWJ1Z093bmVyID8gZmliZXIuX2RlYnVnT3duZXIudHlwZSA6IG51bGwgO1xuICB2YXIgc291cmNlID0gIGZpYmVyLl9kZWJ1Z1NvdXJjZSA7XG5cbiAgc3dpdGNoIChmaWJlci50YWcpIHtcbiAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUoZmliZXIudHlwZSk7XG5cbiAgICBjYXNlIExhenlDb21wb25lbnQ6XG4gICAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUoJ0xhenknKTtcblxuICAgIGNhc2UgU3VzcGVuc2VDb21wb25lbnQ6XG4gICAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUoJ1N1c3BlbnNlJyk7XG5cbiAgICBjYXNlIFN1c3BlbnNlTGlzdENvbXBvbmVudDpcbiAgICAgIHJldHVybiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZSgnU3VzcGVuc2VMaXN0Jyk7XG5cbiAgICBjYXNlIEZ1bmN0aW9uQ29tcG9uZW50OlxuICAgIGNhc2UgSW5kZXRlcm1pbmF0ZUNvbXBvbmVudDpcbiAgICBjYXNlIFNpbXBsZU1lbW9Db21wb25lbnQ6XG4gICAgICByZXR1cm4gZGVzY3JpYmVGdW5jdGlvbkNvbXBvbmVudEZyYW1lKGZpYmVyLnR5cGUpO1xuXG4gICAgY2FzZSBGb3J3YXJkUmVmOlxuICAgICAgcmV0dXJuIGRlc2NyaWJlRnVuY3Rpb25Db21wb25lbnRGcmFtZShmaWJlci50eXBlLnJlbmRlcik7XG5cbiAgICBjYXNlIEJsb2NrOlxuICAgICAgcmV0dXJuIGRlc2NyaWJlRnVuY3Rpb25Db21wb25lbnRGcmFtZShmaWJlci50eXBlLl9yZW5kZXIpO1xuXG4gICAgY2FzZSBDbGFzc0NvbXBvbmVudDpcbiAgICAgIHJldHVybiBkZXNjcmliZUNsYXNzQ29tcG9uZW50RnJhbWUoZmliZXIudHlwZSk7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuICcnO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldFN0YWNrQnlGaWJlckluRGV2QW5kUHJvZCh3b3JrSW5Qcm9ncmVzcykge1xuICB0cnkge1xuICAgIHZhciBpbmZvID0gJyc7XG4gICAgdmFyIG5vZGUgPSB3b3JrSW5Qcm9ncmVzcztcblxuICAgIGRvIHtcbiAgICAgIGluZm8gKz0gZGVzY3JpYmVGaWJlcihub2RlKTtcbiAgICAgIG5vZGUgPSBub2RlLnJldHVybjtcbiAgICB9IHdoaWxlIChub2RlKTtcblxuICAgIHJldHVybiBpbmZvO1xuICB9IGNhdGNoICh4KSB7XG4gICAgcmV0dXJuICdcXG5FcnJvciBnZW5lcmF0aW5nIHN0YWNrOiAnICsgeC5tZXNzYWdlICsgJ1xcbicgKyB4LnN0YWNrO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldFdyYXBwZWROYW1lKG91dGVyVHlwZSwgaW5uZXJUeXBlLCB3cmFwcGVyTmFtZSkge1xuICB2YXIgZnVuY3Rpb25OYW1lID0gaW5uZXJUeXBlLmRpc3BsYXlOYW1lIHx8IGlubmVyVHlwZS5uYW1lIHx8ICcnO1xuICByZXR1cm4gb3V0ZXJUeXBlLmRpc3BsYXlOYW1lIHx8IChmdW5jdGlvbk5hbWUgIT09ICcnID8gd3JhcHBlck5hbWUgKyBcIihcIiArIGZ1bmN0aW9uTmFtZSArIFwiKVwiIDogd3JhcHBlck5hbWUpO1xufVxuXG5mdW5jdGlvbiBnZXRDb250ZXh0TmFtZSh0eXBlKSB7XG4gIHJldHVybiB0eXBlLmRpc3BsYXlOYW1lIHx8ICdDb250ZXh0Jztcbn1cblxuZnVuY3Rpb24gZ2V0Q29tcG9uZW50TmFtZSh0eXBlKSB7XG4gIGlmICh0eXBlID09IG51bGwpIHtcbiAgICAvLyBIb3N0IHJvb3QsIHRleHQgbm9kZSBvciBqdXN0IGludmFsaWQgdHlwZS5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHtcbiAgICBpZiAodHlwZW9mIHR5cGUudGFnID09PSAnbnVtYmVyJykge1xuICAgICAgZXJyb3IoJ1JlY2VpdmVkIGFuIHVuZXhwZWN0ZWQgb2JqZWN0IGluIGdldENvbXBvbmVudE5hbWUoKS4gJyArICdUaGlzIGlzIGxpa2VseSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIHR5cGUuZGlzcGxheU5hbWUgfHwgdHlwZS5uYW1lIHx8IG51bGw7XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHR5cGU7XG4gIH1cblxuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlIFJFQUNUX0ZSQUdNRU5UX1RZUEU6XG4gICAgICByZXR1cm4gJ0ZyYWdtZW50JztcblxuICAgIGNhc2UgUkVBQ1RfUE9SVEFMX1RZUEU6XG4gICAgICByZXR1cm4gJ1BvcnRhbCc7XG5cbiAgICBjYXNlIFJFQUNUX1BST0ZJTEVSX1RZUEU6XG4gICAgICByZXR1cm4gJ1Byb2ZpbGVyJztcblxuICAgIGNhc2UgUkVBQ1RfU1RSSUNUX01PREVfVFlQRTpcbiAgICAgIHJldHVybiAnU3RyaWN0TW9kZSc7XG5cbiAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX1RZUEU6XG4gICAgICByZXR1cm4gJ1N1c3BlbnNlJztcblxuICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFOlxuICAgICAgcmV0dXJuICdTdXNwZW5zZUxpc3QnO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0Jykge1xuICAgIHN3aXRjaCAodHlwZS4kJHR5cGVvZikge1xuICAgICAgY2FzZSBSRUFDVF9DT05URVhUX1RZUEU6XG4gICAgICAgIHZhciBjb250ZXh0ID0gdHlwZTtcbiAgICAgICAgcmV0dXJuIGdldENvbnRleHROYW1lKGNvbnRleHQpICsgJy5Db25zdW1lcic7XG5cbiAgICAgIGNhc2UgUkVBQ1RfUFJPVklERVJfVFlQRTpcbiAgICAgICAgdmFyIHByb3ZpZGVyID0gdHlwZTtcbiAgICAgICAgcmV0dXJuIGdldENvbnRleHROYW1lKHByb3ZpZGVyLl9jb250ZXh0KSArICcuUHJvdmlkZXInO1xuXG4gICAgICBjYXNlIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU6XG4gICAgICAgIHJldHVybiBnZXRXcmFwcGVkTmFtZSh0eXBlLCB0eXBlLnJlbmRlciwgJ0ZvcndhcmRSZWYnKTtcblxuICAgICAgY2FzZSBSRUFDVF9NRU1PX1RZUEU6XG4gICAgICAgIHJldHVybiBnZXRDb21wb25lbnROYW1lKHR5cGUudHlwZSk7XG5cbiAgICAgIGNhc2UgUkVBQ1RfQkxPQ0tfVFlQRTpcbiAgICAgICAgcmV0dXJuIGdldENvbXBvbmVudE5hbWUodHlwZS5fcmVuZGVyKTtcblxuICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgbGF6eUNvbXBvbmVudCA9IHR5cGU7XG4gICAgICAgICAgdmFyIHBheWxvYWQgPSBsYXp5Q29tcG9uZW50Ll9wYXlsb2FkO1xuICAgICAgICAgIHZhciBpbml0ID0gbGF6eUNvbXBvbmVudC5faW5pdDtcblxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0Q29tcG9uZW50TmFtZShpbml0KHBheWxvYWQpKTtcbiAgICAgICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxudmFyIFJlYWN0RGVidWdDdXJyZW50RnJhbWUgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdERlYnVnQ3VycmVudEZyYW1lO1xudmFyIGN1cnJlbnQgPSBudWxsO1xudmFyIGlzUmVuZGVyaW5nID0gZmFsc2U7XG5mdW5jdGlvbiBnZXRDdXJyZW50RmliZXJPd25lck5hbWVJbkRldk9yTnVsbCgpIHtcbiAge1xuICAgIGlmIChjdXJyZW50ID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgb3duZXIgPSBjdXJyZW50Ll9kZWJ1Z093bmVyO1xuXG4gICAgaWYgKG93bmVyICE9PSBudWxsICYmIHR5cGVvZiBvd25lciAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHJldHVybiBnZXRDb21wb25lbnROYW1lKG93bmVyLnR5cGUpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiBnZXRDdXJyZW50RmliZXJTdGFja0luRGV2KCkge1xuICB7XG4gICAgaWYgKGN1cnJlbnQgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiAnJztcbiAgICB9IC8vIFNhZmUgYmVjYXVzZSBpZiBjdXJyZW50IGZpYmVyIGV4aXN0cywgd2UgYXJlIHJlY29uY2lsaW5nLFxuICAgIC8vIGFuZCBpdCBpcyBndWFyYW50ZWVkIHRvIGJlIHRoZSB3b3JrLWluLXByb2dyZXNzIHZlcnNpb24uXG5cblxuICAgIHJldHVybiBnZXRTdGFja0J5RmliZXJJbkRldkFuZFByb2QoY3VycmVudCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVzZXRDdXJyZW50RmliZXIoKSB7XG4gIHtcbiAgICBSZWFjdERlYnVnQ3VycmVudEZyYW1lLmdldEN1cnJlbnRTdGFjayA9IG51bGw7XG4gICAgY3VycmVudCA9IG51bGw7XG4gICAgaXNSZW5kZXJpbmcgPSBmYWxzZTtcbiAgfVxufVxuZnVuY3Rpb24gc2V0Q3VycmVudEZpYmVyKGZpYmVyKSB7XG4gIHtcbiAgICBSZWFjdERlYnVnQ3VycmVudEZyYW1lLmdldEN1cnJlbnRTdGFjayA9IGdldEN1cnJlbnRGaWJlclN0YWNrSW5EZXY7XG4gICAgY3VycmVudCA9IGZpYmVyO1xuICAgIGlzUmVuZGVyaW5nID0gZmFsc2U7XG4gIH1cbn1cbmZ1bmN0aW9uIHNldElzUmVuZGVyaW5nKHJlbmRlcmluZykge1xuICB7XG4gICAgaXNSZW5kZXJpbmcgPSByZW5kZXJpbmc7XG4gIH1cbn1cbmZ1bmN0aW9uIGdldElzUmVuZGVyaW5nKCkge1xuICB7XG4gICAgcmV0dXJuIGlzUmVuZGVyaW5nO1xuICB9XG59XG5cbi8vIEZsb3cgZG9lcyBub3QgYWxsb3cgc3RyaW5nIGNvbmNhdGVuYXRpb24gb2YgbW9zdCBub24tc3RyaW5nIHR5cGVzLiBUbyB3b3JrXG4vLyBhcm91bmQgdGhpcyBsaW1pdGF0aW9uLCB3ZSB1c2UgYW4gb3BhcXVlIHR5cGUgdGhhdCBjYW4gb25seSBiZSBvYnRhaW5lZCBieVxuLy8gcGFzc2luZyB0aGUgdmFsdWUgdGhyb3VnaCBnZXRUb1N0cmluZ1ZhbHVlIGZpcnN0LlxuZnVuY3Rpb24gdG9TdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuICcnICsgdmFsdWU7XG59XG5mdW5jdGlvbiBnZXRUb1N0cmluZ1ZhbHVlKHZhbHVlKSB7XG4gIHN3aXRjaCAodHlwZW9mIHZhbHVlKSB7XG4gICAgY2FzZSAnYm9vbGVhbic6XG4gICAgY2FzZSAnbnVtYmVyJzpcbiAgICBjYXNlICdvYmplY3QnOlxuICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgY2FzZSAndW5kZWZpbmVkJzpcbiAgICAgIHJldHVybiB2YWx1ZTtcblxuICAgIGRlZmF1bHQ6XG4gICAgICAvLyBmdW5jdGlvbiwgc3ltYm9sIGFyZSBhc3NpZ25lZCBhcyBlbXB0eSBzdHJpbmdzXG4gICAgICByZXR1cm4gJyc7XG4gIH1cbn1cblxudmFyIGhhc1JlYWRPbmx5VmFsdWUgPSB7XG4gIGJ1dHRvbjogdHJ1ZSxcbiAgY2hlY2tib3g6IHRydWUsXG4gIGltYWdlOiB0cnVlLFxuICBoaWRkZW46IHRydWUsXG4gIHJhZGlvOiB0cnVlLFxuICByZXNldDogdHJ1ZSxcbiAgc3VibWl0OiB0cnVlXG59O1xuZnVuY3Rpb24gY2hlY2tDb250cm9sbGVkVmFsdWVQcm9wcyh0YWdOYW1lLCBwcm9wcykge1xuICB7XG4gICAgaWYgKCEoaGFzUmVhZE9ubHlWYWx1ZVtwcm9wcy50eXBlXSB8fCBwcm9wcy5vbkNoYW5nZSB8fCBwcm9wcy5vbklucHV0IHx8IHByb3BzLnJlYWRPbmx5IHx8IHByb3BzLmRpc2FibGVkIHx8IHByb3BzLnZhbHVlID09IG51bGwpKSB7XG4gICAgICBlcnJvcignWW91IHByb3ZpZGVkIGEgYHZhbHVlYCBwcm9wIHRvIGEgZm9ybSBmaWVsZCB3aXRob3V0IGFuICcgKyAnYG9uQ2hhbmdlYCBoYW5kbGVyLiBUaGlzIHdpbGwgcmVuZGVyIGEgcmVhZC1vbmx5IGZpZWxkLiBJZiAnICsgJ3RoZSBmaWVsZCBzaG91bGQgYmUgbXV0YWJsZSB1c2UgYGRlZmF1bHRWYWx1ZWAuIE90aGVyd2lzZSwgJyArICdzZXQgZWl0aGVyIGBvbkNoYW5nZWAgb3IgYHJlYWRPbmx5YC4nKTtcbiAgICB9XG5cbiAgICBpZiAoIShwcm9wcy5vbkNoYW5nZSB8fCBwcm9wcy5yZWFkT25seSB8fCBwcm9wcy5kaXNhYmxlZCB8fCBwcm9wcy5jaGVja2VkID09IG51bGwpKSB7XG4gICAgICBlcnJvcignWW91IHByb3ZpZGVkIGEgYGNoZWNrZWRgIHByb3AgdG8gYSBmb3JtIGZpZWxkIHdpdGhvdXQgYW4gJyArICdgb25DaGFuZ2VgIGhhbmRsZXIuIFRoaXMgd2lsbCByZW5kZXIgYSByZWFkLW9ubHkgZmllbGQuIElmICcgKyAndGhlIGZpZWxkIHNob3VsZCBiZSBtdXRhYmxlIHVzZSBgZGVmYXVsdENoZWNrZWRgLiBPdGhlcndpc2UsICcgKyAnc2V0IGVpdGhlciBgb25DaGFuZ2VgIG9yIGByZWFkT25seWAuJyk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGlzQ2hlY2thYmxlKGVsZW0pIHtcbiAgdmFyIHR5cGUgPSBlbGVtLnR5cGU7XG4gIHZhciBub2RlTmFtZSA9IGVsZW0ubm9kZU5hbWU7XG4gIHJldHVybiBub2RlTmFtZSAmJiBub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSAnaW5wdXQnICYmICh0eXBlID09PSAnY2hlY2tib3gnIHx8IHR5cGUgPT09ICdyYWRpbycpO1xufVxuXG5mdW5jdGlvbiBnZXRUcmFja2VyKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUuX3ZhbHVlVHJhY2tlcjtcbn1cblxuZnVuY3Rpb24gZGV0YWNoVHJhY2tlcihub2RlKSB7XG4gIG5vZGUuX3ZhbHVlVHJhY2tlciA9IG51bGw7XG59XG5cbmZ1bmN0aW9uIGdldFZhbHVlRnJvbU5vZGUobm9kZSkge1xuICB2YXIgdmFsdWUgPSAnJztcblxuICBpZiAoIW5vZGUpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cblxuICBpZiAoaXNDaGVja2FibGUobm9kZSkpIHtcbiAgICB2YWx1ZSA9IG5vZGUuY2hlY2tlZCA/ICd0cnVlJyA6ICdmYWxzZSc7XG4gIH0gZWxzZSB7XG4gICAgdmFsdWUgPSBub2RlLnZhbHVlO1xuICB9XG5cbiAgcmV0dXJuIHZhbHVlO1xufVxuXG5mdW5jdGlvbiB0cmFja1ZhbHVlT25Ob2RlKG5vZGUpIHtcbiAgdmFyIHZhbHVlRmllbGQgPSBpc0NoZWNrYWJsZShub2RlKSA/ICdjaGVja2VkJyA6ICd2YWx1ZSc7XG4gIHZhciBkZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihub2RlLmNvbnN0cnVjdG9yLnByb3RvdHlwZSwgdmFsdWVGaWVsZCk7XG4gIHZhciBjdXJyZW50VmFsdWUgPSAnJyArIG5vZGVbdmFsdWVGaWVsZF07IC8vIGlmIHNvbWVvbmUgaGFzIGFscmVhZHkgZGVmaW5lZCBhIHZhbHVlIG9yIFNhZmFyaSwgdGhlbiBiYWlsXG4gIC8vIGFuZCBkb24ndCB0cmFjayB2YWx1ZSB3aWxsIGNhdXNlIG92ZXIgcmVwb3J0aW5nIG9mIGNoYW5nZXMsXG4gIC8vIGJ1dCBpdCdzIGJldHRlciB0aGVuIGEgaGFyZCBmYWlsdXJlXG4gIC8vIChuZWVkZWQgZm9yIGNlcnRhaW4gdGVzdHMgdGhhdCBzcHlPbiBpbnB1dCB2YWx1ZXMgYW5kIFNhZmFyaSlcblxuICBpZiAobm9kZS5oYXNPd25Qcm9wZXJ0eSh2YWx1ZUZpZWxkKSB8fCB0eXBlb2YgZGVzY3JpcHRvciA9PT0gJ3VuZGVmaW5lZCcgfHwgdHlwZW9mIGRlc2NyaXB0b3IuZ2V0ICE9PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBkZXNjcmlwdG9yLnNldCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBnZXQgPSBkZXNjcmlwdG9yLmdldCxcbiAgICAgIHNldCA9IGRlc2NyaXB0b3Iuc2V0O1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkobm9kZSwgdmFsdWVGaWVsZCwge1xuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBnZXQuY2FsbCh0aGlzKTtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICBjdXJyZW50VmFsdWUgPSAnJyArIHZhbHVlO1xuICAgICAgc2V0LmNhbGwodGhpcywgdmFsdWUpO1xuICAgIH1cbiAgfSk7IC8vIFdlIGNvdWxkJ3ZlIHBhc3NlZCB0aGlzIHRoZSBmaXJzdCB0aW1lXG4gIC8vIGJ1dCBpdCB0cmlnZ2VycyBhIGJ1ZyBpbiBJRTExIGFuZCBFZGdlIDE0LzE1LlxuICAvLyBDYWxsaW5nIGRlZmluZVByb3BlcnR5KCkgYWdhaW4gc2hvdWxkIGJlIGVxdWl2YWxlbnQuXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTE3NjhcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkobm9kZSwgdmFsdWVGaWVsZCwge1xuICAgIGVudW1lcmFibGU6IGRlc2NyaXB0b3IuZW51bWVyYWJsZVxuICB9KTtcbiAgdmFyIHRyYWNrZXIgPSB7XG4gICAgZ2V0VmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBjdXJyZW50VmFsdWU7XG4gICAgfSxcbiAgICBzZXRWYWx1ZTogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICBjdXJyZW50VmFsdWUgPSAnJyArIHZhbHVlO1xuICAgIH0sXG4gICAgc3RvcFRyYWNraW5nOiBmdW5jdGlvbiAoKSB7XG4gICAgICBkZXRhY2hUcmFja2VyKG5vZGUpO1xuICAgICAgZGVsZXRlIG5vZGVbdmFsdWVGaWVsZF07XG4gICAgfVxuICB9O1xuICByZXR1cm4gdHJhY2tlcjtcbn1cblxuZnVuY3Rpb24gdHJhY2sobm9kZSkge1xuICBpZiAoZ2V0VHJhY2tlcihub2RlKSkge1xuICAgIHJldHVybjtcbiAgfSAvLyBUT0RPOiBPbmNlIGl0J3MganVzdCBGaWJlciB3ZSBjYW4gbW92ZSB0aGlzIHRvIG5vZGUuX3dyYXBwZXJTdGF0ZVxuXG5cbiAgbm9kZS5fdmFsdWVUcmFja2VyID0gdHJhY2tWYWx1ZU9uTm9kZShub2RlKTtcbn1cbmZ1bmN0aW9uIHVwZGF0ZVZhbHVlSWZDaGFuZ2VkKG5vZGUpIHtcbiAgaWYgKCFub2RlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIHRyYWNrZXIgPSBnZXRUcmFja2VyKG5vZGUpOyAvLyBpZiB0aGVyZSBpcyBubyB0cmFja2VyIGF0IHRoaXMgcG9pbnQgaXQncyB1bmxpa2VseVxuICAvLyB0aGF0IHRyeWluZyBhZ2FpbiB3aWxsIHN1Y2NlZWRcblxuICBpZiAoIXRyYWNrZXIpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHZhciBsYXN0VmFsdWUgPSB0cmFja2VyLmdldFZhbHVlKCk7XG4gIHZhciBuZXh0VmFsdWUgPSBnZXRWYWx1ZUZyb21Ob2RlKG5vZGUpO1xuXG4gIGlmIChuZXh0VmFsdWUgIT09IGxhc3RWYWx1ZSkge1xuICAgIHRyYWNrZXIuc2V0VmFsdWUobmV4dFZhbHVlKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gZ2V0QWN0aXZlRWxlbWVudChkb2MpIHtcbiAgZG9jID0gZG9jIHx8ICh0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnID8gZG9jdW1lbnQgOiB1bmRlZmluZWQpO1xuXG4gIGlmICh0eXBlb2YgZG9jID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdHJ5IHtcbiAgICByZXR1cm4gZG9jLmFjdGl2ZUVsZW1lbnQgfHwgZG9jLmJvZHk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZG9jLmJvZHk7XG4gIH1cbn1cblxudmFyIGRpZFdhcm5WYWx1ZURlZmF1bHRWYWx1ZSA9IGZhbHNlO1xudmFyIGRpZFdhcm5DaGVja2VkRGVmYXVsdENoZWNrZWQgPSBmYWxzZTtcbnZhciBkaWRXYXJuQ29udHJvbGxlZFRvVW5jb250cm9sbGVkID0gZmFsc2U7XG52YXIgZGlkV2FyblVuY29udHJvbGxlZFRvQ29udHJvbGxlZCA9IGZhbHNlO1xuXG5mdW5jdGlvbiBpc0NvbnRyb2xsZWQocHJvcHMpIHtcbiAgdmFyIHVzZXNDaGVja2VkID0gcHJvcHMudHlwZSA9PT0gJ2NoZWNrYm94JyB8fCBwcm9wcy50eXBlID09PSAncmFkaW8nO1xuICByZXR1cm4gdXNlc0NoZWNrZWQgPyBwcm9wcy5jaGVja2VkICE9IG51bGwgOiBwcm9wcy52YWx1ZSAhPSBudWxsO1xufVxuLyoqXG4gKiBJbXBsZW1lbnRzIGFuIDxpbnB1dD4gaG9zdCBjb21wb25lbnQgdGhhdCBhbGxvd3Mgc2V0dGluZyB0aGVzZSBvcHRpb25hbFxuICogcHJvcHM6IGBjaGVja2VkYCwgYHZhbHVlYCwgYGRlZmF1bHRDaGVja2VkYCwgYW5kIGBkZWZhdWx0VmFsdWVgLlxuICpcbiAqIElmIGBjaGVja2VkYCBvciBgdmFsdWVgIGFyZSBub3Qgc3VwcGxpZWQgKG9yIG51bGwvdW5kZWZpbmVkKSwgdXNlciBhY3Rpb25zXG4gKiB0aGF0IGFmZmVjdCB0aGUgY2hlY2tlZCBzdGF0ZSBvciB2YWx1ZSB3aWxsIHRyaWdnZXIgdXBkYXRlcyB0byB0aGUgZWxlbWVudC5cbiAqXG4gKiBJZiB0aGV5IGFyZSBzdXBwbGllZCAoYW5kIG5vdCBudWxsL3VuZGVmaW5lZCksIHRoZSByZW5kZXJlZCBlbGVtZW50IHdpbGwgbm90XG4gKiB0cmlnZ2VyIHVwZGF0ZXMgdG8gdGhlIGVsZW1lbnQuIEluc3RlYWQsIHRoZSBwcm9wcyBtdXN0IGNoYW5nZSBpbiBvcmRlciBmb3JcbiAqIHRoZSByZW5kZXJlZCBlbGVtZW50IHRvIGJlIHVwZGF0ZWQuXG4gKlxuICogVGhlIHJlbmRlcmVkIGVsZW1lbnQgd2lsbCBiZSBpbml0aWFsaXplZCBhcyB1bmNoZWNrZWQgKG9yIGBkZWZhdWx0Q2hlY2tlZGApXG4gKiB3aXRoIGFuIGVtcHR5IHZhbHVlIChvciBgZGVmYXVsdFZhbHVlYCkuXG4gKlxuICogU2VlIGh0dHA6Ly93d3cudzMub3JnL1RSLzIwMTIvV0QtaHRtbDUtMjAxMjEwMjUvdGhlLWlucHV0LWVsZW1lbnQuaHRtbFxuICovXG5cblxuZnVuY3Rpb24gZ2V0SG9zdFByb3BzKGVsZW1lbnQsIHByb3BzKSB7XG4gIHZhciBub2RlID0gZWxlbWVudDtcbiAgdmFyIGNoZWNrZWQgPSBwcm9wcy5jaGVja2VkO1xuXG4gIHZhciBob3N0UHJvcHMgPSBfYXNzaWduKHt9LCBwcm9wcywge1xuICAgIGRlZmF1bHRDaGVja2VkOiB1bmRlZmluZWQsXG4gICAgZGVmYXVsdFZhbHVlOiB1bmRlZmluZWQsXG4gICAgdmFsdWU6IHVuZGVmaW5lZCxcbiAgICBjaGVja2VkOiBjaGVja2VkICE9IG51bGwgPyBjaGVja2VkIDogbm9kZS5fd3JhcHBlclN0YXRlLmluaXRpYWxDaGVja2VkXG4gIH0pO1xuXG4gIHJldHVybiBob3N0UHJvcHM7XG59XG5mdW5jdGlvbiBpbml0V3JhcHBlclN0YXRlKGVsZW1lbnQsIHByb3BzKSB7XG4gIHtcbiAgICBjaGVja0NvbnRyb2xsZWRWYWx1ZVByb3BzKCdpbnB1dCcsIHByb3BzKTtcblxuICAgIGlmIChwcm9wcy5jaGVja2VkICE9PSB1bmRlZmluZWQgJiYgcHJvcHMuZGVmYXVsdENoZWNrZWQgIT09IHVuZGVmaW5lZCAmJiAhZGlkV2FybkNoZWNrZWREZWZhdWx0Q2hlY2tlZCkge1xuICAgICAgZXJyb3IoJyVzIGNvbnRhaW5zIGFuIGlucHV0IG9mIHR5cGUgJXMgd2l0aCBib3RoIGNoZWNrZWQgYW5kIGRlZmF1bHRDaGVja2VkIHByb3BzLiAnICsgJ0lucHV0IGVsZW1lbnRzIG11c3QgYmUgZWl0aGVyIGNvbnRyb2xsZWQgb3IgdW5jb250cm9sbGVkICcgKyAnKHNwZWNpZnkgZWl0aGVyIHRoZSBjaGVja2VkIHByb3AsIG9yIHRoZSBkZWZhdWx0Q2hlY2tlZCBwcm9wLCBidXQgbm90ICcgKyAnYm90aCkuIERlY2lkZSBiZXR3ZWVuIHVzaW5nIGEgY29udHJvbGxlZCBvciB1bmNvbnRyb2xsZWQgaW5wdXQgJyArICdlbGVtZW50IGFuZCByZW1vdmUgb25lIG9mIHRoZXNlIHByb3BzLiBNb3JlIGluZm86ICcgKyAnaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL2NvbnRyb2xsZWQtY29tcG9uZW50cycsIGdldEN1cnJlbnRGaWJlck93bmVyTmFtZUluRGV2T3JOdWxsKCkgfHwgJ0EgY29tcG9uZW50JywgcHJvcHMudHlwZSk7XG5cbiAgICAgIGRpZFdhcm5DaGVja2VkRGVmYXVsdENoZWNrZWQgPSB0cnVlO1xuICAgIH1cblxuICAgIGlmIChwcm9wcy52YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHByb3BzLmRlZmF1bHRWYWx1ZSAhPT0gdW5kZWZpbmVkICYmICFkaWRXYXJuVmFsdWVEZWZhdWx0VmFsdWUpIHtcbiAgICAgIGVycm9yKCclcyBjb250YWlucyBhbiBpbnB1dCBvZiB0eXBlICVzIHdpdGggYm90aCB2YWx1ZSBhbmQgZGVmYXVsdFZhbHVlIHByb3BzLiAnICsgJ0lucHV0IGVsZW1lbnRzIG11c3QgYmUgZWl0aGVyIGNvbnRyb2xsZWQgb3IgdW5jb250cm9sbGVkICcgKyAnKHNwZWNpZnkgZWl0aGVyIHRoZSB2YWx1ZSBwcm9wLCBvciB0aGUgZGVmYXVsdFZhbHVlIHByb3AsIGJ1dCBub3QgJyArICdib3RoKS4gRGVjaWRlIGJldHdlZW4gdXNpbmcgYSBjb250cm9sbGVkIG9yIHVuY29udHJvbGxlZCBpbnB1dCAnICsgJ2VsZW1lbnQgYW5kIHJlbW92ZSBvbmUgb2YgdGhlc2UgcHJvcHMuIE1vcmUgaW5mbzogJyArICdodHRwczovL3JlYWN0anMub3JnL2xpbmsvY29udHJvbGxlZC1jb21wb25lbnRzJywgZ2V0Q3VycmVudEZpYmVyT3duZXJOYW1lSW5EZXZPck51bGwoKSB8fCAnQSBjb21wb25lbnQnLCBwcm9wcy50eXBlKTtcblxuICAgICAgZGlkV2FyblZhbHVlRGVmYXVsdFZhbHVlID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICB2YXIgbm9kZSA9IGVsZW1lbnQ7XG4gIHZhciBkZWZhdWx0VmFsdWUgPSBwcm9wcy5kZWZhdWx0VmFsdWUgPT0gbnVsbCA/ICcnIDogcHJvcHMuZGVmYXVsdFZhbHVlO1xuICBub2RlLl93cmFwcGVyU3RhdGUgPSB7XG4gICAgaW5pdGlhbENoZWNrZWQ6IHByb3BzLmNoZWNrZWQgIT0gbnVsbCA/IHByb3BzLmNoZWNrZWQgOiBwcm9wcy5kZWZhdWx0Q2hlY2tlZCxcbiAgICBpbml0aWFsVmFsdWU6IGdldFRvU3RyaW5nVmFsdWUocHJvcHMudmFsdWUgIT0gbnVsbCA/IHByb3BzLnZhbHVlIDogZGVmYXVsdFZhbHVlKSxcbiAgICBjb250cm9sbGVkOiBpc0NvbnRyb2xsZWQocHJvcHMpXG4gIH07XG59XG5mdW5jdGlvbiB1cGRhdGVDaGVja2VkKGVsZW1lbnQsIHByb3BzKSB7XG4gIHZhciBub2RlID0gZWxlbWVudDtcbiAgdmFyIGNoZWNrZWQgPSBwcm9wcy5jaGVja2VkO1xuXG4gIGlmIChjaGVja2VkICE9IG51bGwpIHtcbiAgICBzZXRWYWx1ZUZvclByb3BlcnR5KG5vZGUsICdjaGVja2VkJywgY2hlY2tlZCwgZmFsc2UpO1xuICB9XG59XG5mdW5jdGlvbiB1cGRhdGVXcmFwcGVyKGVsZW1lbnQsIHByb3BzKSB7XG4gIHZhciBub2RlID0gZWxlbWVudDtcblxuICB7XG4gICAgdmFyIGNvbnRyb2xsZWQgPSBpc0NvbnRyb2xsZWQocHJvcHMpO1xuXG4gICAgaWYgKCFub2RlLl93cmFwcGVyU3RhdGUuY29udHJvbGxlZCAmJiBjb250cm9sbGVkICYmICFkaWRXYXJuVW5jb250cm9sbGVkVG9Db250cm9sbGVkKSB7XG4gICAgICBlcnJvcignQSBjb21wb25lbnQgaXMgY2hhbmdpbmcgYW4gdW5jb250cm9sbGVkIGlucHV0IHRvIGJlIGNvbnRyb2xsZWQuICcgKyAnVGhpcyBpcyBsaWtlbHkgY2F1c2VkIGJ5IHRoZSB2YWx1ZSBjaGFuZ2luZyBmcm9tIHVuZGVmaW5lZCB0byAnICsgJ2EgZGVmaW5lZCB2YWx1ZSwgd2hpY2ggc2hvdWxkIG5vdCBoYXBwZW4uICcgKyAnRGVjaWRlIGJldHdlZW4gdXNpbmcgYSBjb250cm9sbGVkIG9yIHVuY29udHJvbGxlZCBpbnB1dCAnICsgJ2VsZW1lbnQgZm9yIHRoZSBsaWZldGltZSBvZiB0aGUgY29tcG9uZW50LiBNb3JlIGluZm86IGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9jb250cm9sbGVkLWNvbXBvbmVudHMnKTtcblxuICAgICAgZGlkV2FyblVuY29udHJvbGxlZFRvQ29udHJvbGxlZCA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKG5vZGUuX3dyYXBwZXJTdGF0ZS5jb250cm9sbGVkICYmICFjb250cm9sbGVkICYmICFkaWRXYXJuQ29udHJvbGxlZFRvVW5jb250cm9sbGVkKSB7XG4gICAgICBlcnJvcignQSBjb21wb25lbnQgaXMgY2hhbmdpbmcgYSBjb250cm9sbGVkIGlucHV0IHRvIGJlIHVuY29udHJvbGxlZC4gJyArICdUaGlzIGlzIGxpa2VseSBjYXVzZWQgYnkgdGhlIHZhbHVlIGNoYW5naW5nIGZyb20gYSBkZWZpbmVkIHRvICcgKyAndW5kZWZpbmVkLCB3aGljaCBzaG91bGQgbm90IGhhcHBlbi4gJyArICdEZWNpZGUgYmV0d2VlbiB1c2luZyBhIGNvbnRyb2xsZWQgb3IgdW5jb250cm9sbGVkIGlucHV0ICcgKyAnZWxlbWVudCBmb3IgdGhlIGxpZmV0aW1lIG9mIHRoZSBjb21wb25lbnQuIE1vcmUgaW5mbzogaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL2NvbnRyb2xsZWQtY29tcG9uZW50cycpO1xuXG4gICAgICBkaWRXYXJuQ29udHJvbGxlZFRvVW5jb250cm9sbGVkID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICB1cGRhdGVDaGVja2VkKGVsZW1lbnQsIHByb3BzKTtcbiAgdmFyIHZhbHVlID0gZ2V0VG9TdHJpbmdWYWx1ZShwcm9wcy52YWx1ZSk7XG4gIHZhciB0eXBlID0gcHJvcHMudHlwZTtcblxuICBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgIGlmICh0eXBlID09PSAnbnVtYmVyJykge1xuICAgICAgaWYgKHZhbHVlID09PSAwICYmIG5vZGUudmFsdWUgPT09ICcnIHx8IC8vIFdlIGV4cGxpY2l0bHkgd2FudCB0byBjb2VyY2UgdG8gbnVtYmVyIGhlcmUgaWYgcG9zc2libGUuXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgICAgIG5vZGUudmFsdWUgIT0gdmFsdWUpIHtcbiAgICAgICAgbm9kZS52YWx1ZSA9IHRvU3RyaW5nKHZhbHVlKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG5vZGUudmFsdWUgIT09IHRvU3RyaW5nKHZhbHVlKSkge1xuICAgICAgbm9kZS52YWx1ZSA9IHRvU3RyaW5nKHZhbHVlKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gJ3N1Ym1pdCcgfHwgdHlwZSA9PT0gJ3Jlc2V0Jykge1xuICAgIC8vIFN1Ym1pdC9yZXNldCBpbnB1dHMgbmVlZCB0aGUgYXR0cmlidXRlIHJlbW92ZWQgY29tcGxldGVseSB0byBhdm9pZFxuICAgIC8vIGJsYW5rLXRleHQgYnV0dG9ucy5cbiAgICBub2RlLnJlbW92ZUF0dHJpYnV0ZSgndmFsdWUnKTtcbiAgICByZXR1cm47XG4gIH1cblxuICB7XG4gICAgLy8gV2hlbiBzeW5jaW5nIHRoZSB2YWx1ZSBhdHRyaWJ1dGUsIHRoZSB2YWx1ZSBjb21lcyBmcm9tIGEgY2FzY2FkZSBvZlxuICAgIC8vIHByb3BlcnRpZXM6XG4gICAgLy8gIDEuIFRoZSB2YWx1ZSBSZWFjdCBwcm9wZXJ0eVxuICAgIC8vICAyLiBUaGUgZGVmYXVsdFZhbHVlIFJlYWN0IHByb3BlcnR5XG4gICAgLy8gIDMuIE90aGVyd2lzZSB0aGVyZSBzaG91bGQgYmUgbm8gY2hhbmdlXG4gICAgaWYgKHByb3BzLmhhc093blByb3BlcnR5KCd2YWx1ZScpKSB7XG4gICAgICBzZXREZWZhdWx0VmFsdWUobm9kZSwgcHJvcHMudHlwZSwgdmFsdWUpO1xuICAgIH0gZWxzZSBpZiAocHJvcHMuaGFzT3duUHJvcGVydHkoJ2RlZmF1bHRWYWx1ZScpKSB7XG4gICAgICBzZXREZWZhdWx0VmFsdWUobm9kZSwgcHJvcHMudHlwZSwgZ2V0VG9TdHJpbmdWYWx1ZShwcm9wcy5kZWZhdWx0VmFsdWUpKTtcbiAgICB9XG4gIH1cblxuICB7XG4gICAgLy8gV2hlbiBzeW5jaW5nIHRoZSBjaGVja2VkIGF0dHJpYnV0ZSwgaXQgb25seSBjaGFuZ2VzIHdoZW4gaXQgbmVlZHNcbiAgICAvLyB0byBiZSByZW1vdmVkLCBzdWNoIGFzIHRyYW5zaXRpb25pbmcgZnJvbSBhIGNoZWNrYm94IGludG8gYSB0ZXh0IGlucHV0XG4gICAgaWYgKHByb3BzLmNoZWNrZWQgPT0gbnVsbCAmJiBwcm9wcy5kZWZhdWx0Q2hlY2tlZCAhPSBudWxsKSB7XG4gICAgICBub2RlLmRlZmF1bHRDaGVja2VkID0gISFwcm9wcy5kZWZhdWx0Q2hlY2tlZDtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIHBvc3RNb3VudFdyYXBwZXIoZWxlbWVudCwgcHJvcHMsIGlzSHlkcmF0aW5nKSB7XG4gIHZhciBub2RlID0gZWxlbWVudDsgLy8gRG8gbm90IGFzc2lnbiB2YWx1ZSBpZiBpdCBpcyBhbHJlYWR5IHNldC4gVGhpcyBwcmV2ZW50cyB1c2VyIHRleHQgaW5wdXRcbiAgLy8gZnJvbSBiZWluZyBsb3N0IGR1cmluZyBTU1IgaHlkcmF0aW9uLlxuXG4gIGlmIChwcm9wcy5oYXNPd25Qcm9wZXJ0eSgndmFsdWUnKSB8fCBwcm9wcy5oYXNPd25Qcm9wZXJ0eSgnZGVmYXVsdFZhbHVlJykpIHtcbiAgICB2YXIgdHlwZSA9IHByb3BzLnR5cGU7XG4gICAgdmFyIGlzQnV0dG9uID0gdHlwZSA9PT0gJ3N1Ym1pdCcgfHwgdHlwZSA9PT0gJ3Jlc2V0JzsgLy8gQXZvaWQgc2V0dGluZyB2YWx1ZSBhdHRyaWJ1dGUgb24gc3VibWl0L3Jlc2V0IGlucHV0cyBhcyBpdCBvdmVycmlkZXMgdGhlXG4gICAgLy8gZGVmYXVsdCB2YWx1ZSBwcm92aWRlZCBieSB0aGUgYnJvd3Nlci4gU2VlOiAjMTI4NzJcblxuICAgIGlmIChpc0J1dHRvbiAmJiAocHJvcHMudmFsdWUgPT09IHVuZGVmaW5lZCB8fCBwcm9wcy52YWx1ZSA9PT0gbnVsbCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgaW5pdGlhbFZhbHVlID0gdG9TdHJpbmcobm9kZS5fd3JhcHBlclN0YXRlLmluaXRpYWxWYWx1ZSk7IC8vIERvIG5vdCBhc3NpZ24gdmFsdWUgaWYgaXQgaXMgYWxyZWFkeSBzZXQuIFRoaXMgcHJldmVudHMgdXNlciB0ZXh0IGlucHV0XG4gICAgLy8gZnJvbSBiZWluZyBsb3N0IGR1cmluZyBTU1IgaHlkcmF0aW9uLlxuXG4gICAgaWYgKCFpc0h5ZHJhdGluZykge1xuICAgICAge1xuICAgICAgICAvLyBXaGVuIHN5bmNpbmcgdGhlIHZhbHVlIGF0dHJpYnV0ZSwgdGhlIHZhbHVlIHByb3BlcnR5IHNob3VsZCB1c2VcbiAgICAgICAgLy8gdGhlIHdyYXBwZXJTdGF0ZS5faW5pdGlhbFZhbHVlIHByb3BlcnR5LiBUaGlzIHVzZXM6XG4gICAgICAgIC8vXG4gICAgICAgIC8vICAgMS4gVGhlIHZhbHVlIFJlYWN0IHByb3BlcnR5IHdoZW4gcHJlc2VudFxuICAgICAgICAvLyAgIDIuIFRoZSBkZWZhdWx0VmFsdWUgUmVhY3QgcHJvcGVydHkgd2hlbiBwcmVzZW50XG4gICAgICAgIC8vICAgMy4gQW4gZW1wdHkgc3RyaW5nXG4gICAgICAgIGlmIChpbml0aWFsVmFsdWUgIT09IG5vZGUudmFsdWUpIHtcbiAgICAgICAgICBub2RlLnZhbHVlID0gaW5pdGlhbFZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAge1xuICAgICAgLy8gT3RoZXJ3aXNlLCB0aGUgdmFsdWUgYXR0cmlidXRlIGlzIHN5bmNocm9uaXplZCB0byB0aGUgcHJvcGVydHksXG4gICAgICAvLyBzbyB3ZSBhc3NpZ24gZGVmYXVsdFZhbHVlIHRvIHRoZSBzYW1lIHRoaW5nIGFzIHRoZSB2YWx1ZSBwcm9wZXJ0eVxuICAgICAgLy8gYXNzaWdubWVudCBzdGVwIGFib3ZlLlxuICAgICAgbm9kZS5kZWZhdWx0VmFsdWUgPSBpbml0aWFsVmFsdWU7XG4gICAgfVxuICB9IC8vIE5vcm1hbGx5LCB3ZSdkIGp1c3QgZG8gYG5vZGUuY2hlY2tlZCA9IG5vZGUuY2hlY2tlZGAgdXBvbiBpbml0aWFsIG1vdW50LCBsZXNzIHRoaXMgYnVnXG4gIC8vIHRoaXMgaXMgbmVlZGVkIHRvIHdvcmsgYXJvdW5kIGEgY2hyb21lIGJ1ZyB3aGVyZSBzZXR0aW5nIGRlZmF1bHRDaGVja2VkXG4gIC8vIHdpbGwgc29tZXRpbWVzIGluZmx1ZW5jZSB0aGUgdmFsdWUgb2YgY2hlY2tlZCAoZXZlbiBhZnRlciBkZXRhY2htZW50KS5cbiAgLy8gUmVmZXJlbmNlOiBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD02MDg0MTZcbiAgLy8gV2UgbmVlZCB0byB0ZW1wb3JhcmlseSB1bnNldCBuYW1lIHRvIGF2b2lkIGRpc3J1cHRpbmcgcmFkaW8gYnV0dG9uIGdyb3Vwcy5cblxuXG4gIHZhciBuYW1lID0gbm9kZS5uYW1lO1xuXG4gIGlmIChuYW1lICE9PSAnJykge1xuICAgIG5vZGUubmFtZSA9ICcnO1xuICB9XG5cbiAge1xuICAgIC8vIFdoZW4gc3luY2luZyB0aGUgY2hlY2tlZCBhdHRyaWJ1dGUsIGJvdGggdGhlIGNoZWNrZWQgcHJvcGVydHkgYW5kXG4gICAgLy8gYXR0cmlidXRlIGFyZSBhc3NpZ25lZCBhdCB0aGUgc2FtZSB0aW1lIHVzaW5nIGRlZmF1bHRDaGVja2VkLiBUaGlzIHVzZXM6XG4gICAgLy9cbiAgICAvLyAgIDEuIFRoZSBjaGVja2VkIFJlYWN0IHByb3BlcnR5IHdoZW4gcHJlc2VudFxuICAgIC8vICAgMi4gVGhlIGRlZmF1bHRDaGVja2VkIFJlYWN0IHByb3BlcnR5IHdoZW4gcHJlc2VudFxuICAgIC8vICAgMy4gT3RoZXJ3aXNlLCBmYWxzZVxuICAgIG5vZGUuZGVmYXVsdENoZWNrZWQgPSAhbm9kZS5kZWZhdWx0Q2hlY2tlZDtcbiAgICBub2RlLmRlZmF1bHRDaGVja2VkID0gISFub2RlLl93cmFwcGVyU3RhdGUuaW5pdGlhbENoZWNrZWQ7XG4gIH1cblxuICBpZiAobmFtZSAhPT0gJycpIHtcbiAgICBub2RlLm5hbWUgPSBuYW1lO1xuICB9XG59XG5mdW5jdGlvbiByZXN0b3JlQ29udHJvbGxlZFN0YXRlKGVsZW1lbnQsIHByb3BzKSB7XG4gIHZhciBub2RlID0gZWxlbWVudDtcbiAgdXBkYXRlV3JhcHBlcihub2RlLCBwcm9wcyk7XG4gIHVwZGF0ZU5hbWVkQ291c2lucyhub2RlLCBwcm9wcyk7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZU5hbWVkQ291c2lucyhyb290Tm9kZSwgcHJvcHMpIHtcbiAgdmFyIG5hbWUgPSBwcm9wcy5uYW1lO1xuXG4gIGlmIChwcm9wcy50eXBlID09PSAncmFkaW8nICYmIG5hbWUgIT0gbnVsbCkge1xuICAgIHZhciBxdWVyeVJvb3QgPSByb290Tm9kZTtcblxuICAgIHdoaWxlIChxdWVyeVJvb3QucGFyZW50Tm9kZSkge1xuICAgICAgcXVlcnlSb290ID0gcXVlcnlSb290LnBhcmVudE5vZGU7XG4gICAgfSAvLyBJZiBgcm9vdE5vZGUuZm9ybWAgd2FzIG5vbi1udWxsLCB0aGVuIHdlIGNvdWxkIHRyeSBgZm9ybS5lbGVtZW50c2AsXG4gICAgLy8gYnV0IHRoYXQgc29tZXRpbWVzIGJlaGF2ZXMgc3RyYW5nZWx5IGluIElFOC4gV2UgY291bGQgYWxzbyB0cnkgdXNpbmdcbiAgICAvLyBgZm9ybS5nZXRFbGVtZW50c0J5TmFtZWAsIGJ1dCB0aGF0IHdpbGwgb25seSByZXR1cm4gZGlyZWN0IGNoaWxkcmVuXG4gICAgLy8gYW5kIHdvbid0IGluY2x1ZGUgaW5wdXRzIHRoYXQgdXNlIHRoZSBIVE1MNSBgZm9ybT1gIGF0dHJpYnV0ZS4gU2luY2VcbiAgICAvLyB0aGUgaW5wdXQgbWlnaHQgbm90IGV2ZW4gYmUgaW4gYSBmb3JtLiBJdCBtaWdodCBub3QgZXZlbiBiZSBpbiB0aGVcbiAgICAvLyBkb2N1bWVudC4gTGV0J3MganVzdCB1c2UgdGhlIGxvY2FsIGBxdWVyeVNlbGVjdG9yQWxsYCB0byBlbnN1cmUgd2UgZG9uJ3RcbiAgICAvLyBtaXNzIGFueXRoaW5nLlxuXG5cbiAgICB2YXIgZ3JvdXAgPSBxdWVyeVJvb3QucXVlcnlTZWxlY3RvckFsbCgnaW5wdXRbbmFtZT0nICsgSlNPTi5zdHJpbmdpZnkoJycgKyBuYW1lKSArICddW3R5cGU9XCJyYWRpb1wiXScpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBncm91cC5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIG90aGVyTm9kZSA9IGdyb3VwW2ldO1xuXG4gICAgICBpZiAob3RoZXJOb2RlID09PSByb290Tm9kZSB8fCBvdGhlck5vZGUuZm9ybSAhPT0gcm9vdE5vZGUuZm9ybSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH0gLy8gVGhpcyB3aWxsIHRocm93IGlmIHJhZGlvIGJ1dHRvbnMgcmVuZGVyZWQgYnkgZGlmZmVyZW50IGNvcGllcyBvZiBSZWFjdFxuICAgICAgLy8gYW5kIHRoZSBzYW1lIG5hbWUgYXJlIHJlbmRlcmVkIGludG8gdGhlIHNhbWUgZm9ybSAoc2FtZSBhcyAjMTkzOSkuXG4gICAgICAvLyBUaGF0J3MgcHJvYmFibHkgb2theTsgd2UgZG9uJ3Qgc3VwcG9ydCBpdCBqdXN0IGFzIHdlIGRvbid0IHN1cHBvcnRcbiAgICAgIC8vIG1peGluZyBSZWFjdCByYWRpbyBidXR0b25zIHdpdGggbm9uLVJlYWN0IG9uZXMuXG5cblxuICAgICAgdmFyIG90aGVyUHJvcHMgPSBnZXRGaWJlckN1cnJlbnRQcm9wc0Zyb21Ob2RlKG90aGVyTm9kZSk7XG5cbiAgICAgIGlmICghb3RoZXJQcm9wcykge1xuICAgICAgICB7XG4gICAgICAgICAgdGhyb3cgRXJyb3IoIFwiUmVhY3RET01JbnB1dDogTWl4aW5nIFJlYWN0IGFuZCBub24tUmVhY3QgcmFkaW8gaW5wdXRzIHdpdGggdGhlIHNhbWUgYG5hbWVgIGlzIG5vdCBzdXBwb3J0ZWQuXCIgKTtcbiAgICAgICAgfVxuICAgICAgfSAvLyBXZSBuZWVkIHVwZGF0ZSB0aGUgdHJhY2tlZCB2YWx1ZSBvbiB0aGUgbmFtZWQgY291c2luIHNpbmNlIHRoZSB2YWx1ZVxuICAgICAgLy8gd2FzIGNoYW5nZWQgYnV0IHRoZSBpbnB1dCBzYXcgbm8gZXZlbnQgb3IgdmFsdWUgc2V0XG5cblxuICAgICAgdXBkYXRlVmFsdWVJZkNoYW5nZWQob3RoZXJOb2RlKTsgLy8gSWYgdGhpcyBpcyBhIGNvbnRyb2xsZWQgcmFkaW8gYnV0dG9uIGdyb3VwLCBmb3JjaW5nIHRoZSBpbnB1dCB0aGF0XG4gICAgICAvLyB3YXMgcHJldmlvdXNseSBjaGVja2VkIHRvIHVwZGF0ZSB3aWxsIGNhdXNlIGl0IHRvIGJlIGNvbWUgcmUtY2hlY2tlZFxuICAgICAgLy8gYXMgYXBwcm9wcmlhdGUuXG5cbiAgICAgIHVwZGF0ZVdyYXBwZXIob3RoZXJOb2RlLCBvdGhlclByb3BzKTtcbiAgICB9XG4gIH1cbn0gLy8gSW4gQ2hyb21lLCBhc3NpZ25pbmcgZGVmYXVsdFZhbHVlIHRvIGNlcnRhaW4gaW5wdXQgdHlwZXMgdHJpZ2dlcnMgaW5wdXQgdmFsaWRhdGlvbi5cbi8vIEZvciBudW1iZXIgaW5wdXRzLCB0aGUgZGlzcGxheSB2YWx1ZSBsb3NlcyB0cmFpbGluZyBkZWNpbWFsIHBvaW50cy4gRm9yIGVtYWlsIGlucHV0cyxcbi8vIENocm9tZSByYWlzZXMgXCJUaGUgc3BlY2lmaWVkIHZhbHVlIDx4PiBpcyBub3QgYSB2YWxpZCBlbWFpbCBhZGRyZXNzXCIuXG4vL1xuLy8gSGVyZSB3ZSBjaGVjayB0byBzZWUgaWYgdGhlIGRlZmF1bHRWYWx1ZSBoYXMgYWN0dWFsbHkgY2hhbmdlZCwgYXZvaWRpbmcgdGhlc2UgcHJvYmxlbXNcbi8vIHdoZW4gdGhlIHVzZXIgaXMgaW5wdXR0aW5nIHRleHRcbi8vXG4vLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzcyNTNcblxuXG5mdW5jdGlvbiBzZXREZWZhdWx0VmFsdWUobm9kZSwgdHlwZSwgdmFsdWUpIHtcbiAgaWYgKCAvLyBGb2N1c2VkIG51bWJlciBpbnB1dHMgc3luY2hyb25pemUgb24gYmx1ci4gU2VlIENoYW5nZUV2ZW50UGx1Z2luLmpzXG4gIHR5cGUgIT09ICdudW1iZXInIHx8IGdldEFjdGl2ZUVsZW1lbnQobm9kZS5vd25lckRvY3VtZW50KSAhPT0gbm9kZSkge1xuICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICBub2RlLmRlZmF1bHRWYWx1ZSA9IHRvU3RyaW5nKG5vZGUuX3dyYXBwZXJTdGF0ZS5pbml0aWFsVmFsdWUpO1xuICAgIH0gZWxzZSBpZiAobm9kZS5kZWZhdWx0VmFsdWUgIT09IHRvU3RyaW5nKHZhbHVlKSkge1xuICAgICAgbm9kZS5kZWZhdWx0VmFsdWUgPSB0b1N0cmluZyh2YWx1ZSk7XG4gICAgfVxuICB9XG59XG5cbnZhciBkaWRXYXJuU2VsZWN0ZWRTZXRPbk9wdGlvbiA9IGZhbHNlO1xudmFyIGRpZFdhcm5JbnZhbGlkQ2hpbGQgPSBmYWxzZTtcblxuZnVuY3Rpb24gZmxhdHRlbkNoaWxkcmVuKGNoaWxkcmVuKSB7XG4gIHZhciBjb250ZW50ID0gJyc7IC8vIEZsYXR0ZW4gY2hpbGRyZW4uIFdlJ2xsIHdhcm4gaWYgdGhleSBhcmUgaW52YWxpZFxuICAvLyBkdXJpbmcgdmFsaWRhdGVQcm9wcygpIHdoaWNoIHJ1bnMgZm9yIGh5ZHJhdGlvbiB0b28uXG4gIC8vIE5vdGUgdGhhdCB0aGlzIHdvdWxkIHRocm93IG9uIG5vbi1lbGVtZW50IG9iamVjdHMuXG4gIC8vIEVsZW1lbnRzIGFyZSBzdHJpbmdpZmllZCAod2hpY2ggaXMgbm9ybWFsbHkgaXJyZWxldmFudFxuICAvLyBidXQgbWF0dGVycyBmb3IgPGZidD4pLlxuXG4gIFJlYWN0LkNoaWxkcmVuLmZvckVhY2goY2hpbGRyZW4sIGZ1bmN0aW9uIChjaGlsZCkge1xuICAgIGlmIChjaGlsZCA9PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29udGVudCArPSBjaGlsZDsgLy8gTm90ZTogd2UgZG9uJ3Qgd2FybiBhYm91dCBpbnZhbGlkIGNoaWxkcmVuIGhlcmUuXG4gICAgLy8gSW5zdGVhZCwgdGhpcyBpcyBkb25lIHNlcGFyYXRlbHkgYmVsb3cgc28gdGhhdFxuICAgIC8vIGl0IGhhcHBlbnMgZHVyaW5nIHRoZSBoeWRyYXRpb24gY29kZSBwYXRoIHRvby5cbiAgfSk7XG4gIHJldHVybiBjb250ZW50O1xufVxuLyoqXG4gKiBJbXBsZW1lbnRzIGFuIDxvcHRpb24+IGhvc3QgY29tcG9uZW50IHRoYXQgd2FybnMgd2hlbiBgc2VsZWN0ZWRgIGlzIHNldC5cbiAqL1xuXG5cbmZ1bmN0aW9uIHZhbGlkYXRlUHJvcHMoZWxlbWVudCwgcHJvcHMpIHtcbiAge1xuICAgIC8vIFRoaXMgbWlycm9ycyB0aGUgY29kZSBwYXRoIGFib3ZlLCBidXQgcnVucyBmb3IgaHlkcmF0aW9uIHRvby5cbiAgICAvLyBXYXJuIGFib3V0IGludmFsaWQgY2hpbGRyZW4gaGVyZSBzbyB0aGF0IGNsaWVudCBhbmQgaHlkcmF0aW9uIGFyZSBjb25zaXN0ZW50LlxuICAgIC8vIFRPRE86IHRoaXMgc2VlbXMgbGlrZSBpdCBjb3VsZCBjYXVzZSBhIERFVi1vbmx5IHRocm93IGZvciBoeWRyYXRpb25cbiAgICAvLyBpZiBjaGlsZHJlbiBjb250YWlucyBhIG5vbi1lbGVtZW50IG9iamVjdC4gV2Ugc2hvdWxkIHRyeSB0byBhdm9pZCB0aGF0LlxuICAgIGlmICh0eXBlb2YgcHJvcHMuY2hpbGRyZW4gPT09ICdvYmplY3QnICYmIHByb3BzLmNoaWxkcmVuICE9PSBudWxsKSB7XG4gICAgICBSZWFjdC5DaGlsZHJlbi5mb3JFYWNoKHByb3BzLmNoaWxkcmVuLCBmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgaWYgKGNoaWxkID09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGNoaWxkID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgY2hpbGQgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBjaGlsZC50eXBlICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghZGlkV2FybkludmFsaWRDaGlsZCkge1xuICAgICAgICAgIGRpZFdhcm5JbnZhbGlkQ2hpbGQgPSB0cnVlO1xuXG4gICAgICAgICAgZXJyb3IoJ09ubHkgc3RyaW5ncyBhbmQgbnVtYmVycyBhcmUgc3VwcG9ydGVkIGFzIDxvcHRpb24+IGNoaWxkcmVuLicpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IC8vIFRPRE86IFJlbW92ZSBzdXBwb3J0IGZvciBgc2VsZWN0ZWRgIGluIDxvcHRpb24+LlxuXG5cbiAgICBpZiAocHJvcHMuc2VsZWN0ZWQgIT0gbnVsbCAmJiAhZGlkV2FyblNlbGVjdGVkU2V0T25PcHRpb24pIHtcbiAgICAgIGVycm9yKCdVc2UgdGhlIGBkZWZhdWx0VmFsdWVgIG9yIGB2YWx1ZWAgcHJvcHMgb24gPHNlbGVjdD4gaW5zdGVhZCBvZiAnICsgJ3NldHRpbmcgYHNlbGVjdGVkYCBvbiA8b3B0aW9uPi4nKTtcblxuICAgICAgZGlkV2FyblNlbGVjdGVkU2V0T25PcHRpb24gPSB0cnVlO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gcG9zdE1vdW50V3JhcHBlciQxKGVsZW1lbnQsIHByb3BzKSB7XG4gIC8vIHZhbHVlPVwiXCIgc2hvdWxkIG1ha2UgYSB2YWx1ZSBhdHRyaWJ1dGUgKCM2MjE5KVxuICBpZiAocHJvcHMudmFsdWUgIT0gbnVsbCkge1xuICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKCd2YWx1ZScsIHRvU3RyaW5nKGdldFRvU3RyaW5nVmFsdWUocHJvcHMudmFsdWUpKSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGdldEhvc3RQcm9wcyQxKGVsZW1lbnQsIHByb3BzKSB7XG4gIHZhciBob3N0UHJvcHMgPSBfYXNzaWduKHtcbiAgICBjaGlsZHJlbjogdW5kZWZpbmVkXG4gIH0sIHByb3BzKTtcblxuICB2YXIgY29udGVudCA9IGZsYXR0ZW5DaGlsZHJlbihwcm9wcy5jaGlsZHJlbik7XG5cbiAgaWYgKGNvbnRlbnQpIHtcbiAgICBob3N0UHJvcHMuY2hpbGRyZW4gPSBjb250ZW50O1xuICB9XG5cbiAgcmV0dXJuIGhvc3RQcm9wcztcbn1cblxudmFyIGRpZFdhcm5WYWx1ZURlZmF1bHRWYWx1ZSQxO1xuXG57XG4gIGRpZFdhcm5WYWx1ZURlZmF1bHRWYWx1ZSQxID0gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bSgpIHtcbiAgdmFyIG93bmVyTmFtZSA9IGdldEN1cnJlbnRGaWJlck93bmVyTmFtZUluRGV2T3JOdWxsKCk7XG5cbiAgaWYgKG93bmVyTmFtZSkge1xuICAgIHJldHVybiAnXFxuXFxuQ2hlY2sgdGhlIHJlbmRlciBtZXRob2Qgb2YgYCcgKyBvd25lck5hbWUgKyAnYC4nO1xuICB9XG5cbiAgcmV0dXJuICcnO1xufVxuXG52YXIgdmFsdWVQcm9wTmFtZXMgPSBbJ3ZhbHVlJywgJ2RlZmF1bHRWYWx1ZSddO1xuLyoqXG4gKiBWYWxpZGF0aW9uIGZ1bmN0aW9uIGZvciBgdmFsdWVgIGFuZCBgZGVmYXVsdFZhbHVlYC5cbiAqL1xuXG5mdW5jdGlvbiBjaGVja1NlbGVjdFByb3BUeXBlcyhwcm9wcykge1xuICB7XG4gICAgY2hlY2tDb250cm9sbGVkVmFsdWVQcm9wcygnc2VsZWN0JywgcHJvcHMpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWx1ZVByb3BOYW1lcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHByb3BOYW1lID0gdmFsdWVQcm9wTmFtZXNbaV07XG5cbiAgICAgIGlmIChwcm9wc1twcm9wTmFtZV0gPT0gbnVsbCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgdmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5KHByb3BzW3Byb3BOYW1lXSk7XG5cbiAgICAgIGlmIChwcm9wcy5tdWx0aXBsZSAmJiAhaXNBcnJheSkge1xuICAgICAgICBlcnJvcignVGhlIGAlc2AgcHJvcCBzdXBwbGllZCB0byA8c2VsZWN0PiBtdXN0IGJlIGFuIGFycmF5IGlmICcgKyAnYG11bHRpcGxlYCBpcyB0cnVlLiVzJywgcHJvcE5hbWUsIGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bSgpKTtcbiAgICAgIH0gZWxzZSBpZiAoIXByb3BzLm11bHRpcGxlICYmIGlzQXJyYXkpIHtcbiAgICAgICAgZXJyb3IoJ1RoZSBgJXNgIHByb3Agc3VwcGxpZWQgdG8gPHNlbGVjdD4gbXVzdCBiZSBhIHNjYWxhciAnICsgJ3ZhbHVlIGlmIGBtdWx0aXBsZWAgaXMgZmFsc2UuJXMnLCBwcm9wTmFtZSwgZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKCkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiB1cGRhdGVPcHRpb25zKG5vZGUsIG11bHRpcGxlLCBwcm9wVmFsdWUsIHNldERlZmF1bHRTZWxlY3RlZCkge1xuICB2YXIgb3B0aW9ucyA9IG5vZGUub3B0aW9ucztcblxuICBpZiAobXVsdGlwbGUpIHtcbiAgICB2YXIgc2VsZWN0ZWRWYWx1ZXMgPSBwcm9wVmFsdWU7XG4gICAgdmFyIHNlbGVjdGVkVmFsdWUgPSB7fTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2VsZWN0ZWRWYWx1ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIC8vIFByZWZpeCB0byBhdm9pZCBjaGFvcyB3aXRoIHNwZWNpYWwga2V5cy5cbiAgICAgIHNlbGVjdGVkVmFsdWVbJyQnICsgc2VsZWN0ZWRWYWx1ZXNbaV1dID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgb3B0aW9ucy5sZW5ndGg7IF9pKyspIHtcbiAgICAgIHZhciBzZWxlY3RlZCA9IHNlbGVjdGVkVmFsdWUuaGFzT3duUHJvcGVydHkoJyQnICsgb3B0aW9uc1tfaV0udmFsdWUpO1xuXG4gICAgICBpZiAob3B0aW9uc1tfaV0uc2VsZWN0ZWQgIT09IHNlbGVjdGVkKSB7XG4gICAgICAgIG9wdGlvbnNbX2ldLnNlbGVjdGVkID0gc2VsZWN0ZWQ7XG4gICAgICB9XG5cbiAgICAgIGlmIChzZWxlY3RlZCAmJiBzZXREZWZhdWx0U2VsZWN0ZWQpIHtcbiAgICAgICAgb3B0aW9uc1tfaV0uZGVmYXVsdFNlbGVjdGVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gRG8gbm90IHNldCBgc2VsZWN0LnZhbHVlYCBhcyBleGFjdCBiZWhhdmlvciBpc24ndCBjb25zaXN0ZW50IGFjcm9zcyBhbGxcbiAgICAvLyBicm93c2VycyBmb3IgYWxsIGNhc2VzLlxuICAgIHZhciBfc2VsZWN0ZWRWYWx1ZSA9IHRvU3RyaW5nKGdldFRvU3RyaW5nVmFsdWUocHJvcFZhbHVlKSk7XG5cbiAgICB2YXIgZGVmYXVsdFNlbGVjdGVkID0gbnVsbDtcblxuICAgIGZvciAodmFyIF9pMiA9IDA7IF9pMiA8IG9wdGlvbnMubGVuZ3RoOyBfaTIrKykge1xuICAgICAgaWYgKG9wdGlvbnNbX2kyXS52YWx1ZSA9PT0gX3NlbGVjdGVkVmFsdWUpIHtcbiAgICAgICAgb3B0aW9uc1tfaTJdLnNlbGVjdGVkID0gdHJ1ZTtcblxuICAgICAgICBpZiAoc2V0RGVmYXVsdFNlbGVjdGVkKSB7XG4gICAgICAgICAgb3B0aW9uc1tfaTJdLmRlZmF1bHRTZWxlY3RlZCA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChkZWZhdWx0U2VsZWN0ZWQgPT09IG51bGwgJiYgIW9wdGlvbnNbX2kyXS5kaXNhYmxlZCkge1xuICAgICAgICBkZWZhdWx0U2VsZWN0ZWQgPSBvcHRpb25zW19pMl07XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGRlZmF1bHRTZWxlY3RlZCAhPT0gbnVsbCkge1xuICAgICAgZGVmYXVsdFNlbGVjdGVkLnNlbGVjdGVkID0gdHJ1ZTtcbiAgICB9XG4gIH1cbn1cbi8qKlxuICogSW1wbGVtZW50cyBhIDxzZWxlY3Q+IGhvc3QgY29tcG9uZW50IHRoYXQgYWxsb3dzIG9wdGlvbmFsbHkgc2V0dGluZyB0aGVcbiAqIHByb3BzIGB2YWx1ZWAgYW5kIGBkZWZhdWx0VmFsdWVgLiBJZiBgbXVsdGlwbGVgIGlzIGZhbHNlLCB0aGUgcHJvcCBtdXN0IGJlIGFcbiAqIHN0cmluZ2FibGUuIElmIGBtdWx0aXBsZWAgaXMgdHJ1ZSwgdGhlIHByb3AgbXVzdCBiZSBhbiBhcnJheSBvZiBzdHJpbmdhYmxlcy5cbiAqXG4gKiBJZiBgdmFsdWVgIGlzIG5vdCBzdXBwbGllZCAob3IgbnVsbC91bmRlZmluZWQpLCB1c2VyIGFjdGlvbnMgdGhhdCBjaGFuZ2UgdGhlXG4gKiBzZWxlY3RlZCBvcHRpb24gd2lsbCB0cmlnZ2VyIHVwZGF0ZXMgdG8gdGhlIHJlbmRlcmVkIG9wdGlvbnMuXG4gKlxuICogSWYgaXQgaXMgc3VwcGxpZWQgKGFuZCBub3QgbnVsbC91bmRlZmluZWQpLCB0aGUgcmVuZGVyZWQgb3B0aW9ucyB3aWxsIG5vdFxuICogdXBkYXRlIGluIHJlc3BvbnNlIHRvIHVzZXIgYWN0aW9ucy4gSW5zdGVhZCwgdGhlIGB2YWx1ZWAgcHJvcCBtdXN0IGNoYW5nZSBpblxuICogb3JkZXIgZm9yIHRoZSByZW5kZXJlZCBvcHRpb25zIHRvIHVwZGF0ZS5cbiAqXG4gKiBJZiBgZGVmYXVsdFZhbHVlYCBpcyBwcm92aWRlZCwgYW55IG9wdGlvbnMgd2l0aCB0aGUgc3VwcGxpZWQgdmFsdWVzIHdpbGwgYmVcbiAqIHNlbGVjdGVkLlxuICovXG5cblxuZnVuY3Rpb24gZ2V0SG9zdFByb3BzJDIoZWxlbWVudCwgcHJvcHMpIHtcbiAgcmV0dXJuIF9hc3NpZ24oe30sIHByb3BzLCB7XG4gICAgdmFsdWU6IHVuZGVmaW5lZFxuICB9KTtcbn1cbmZ1bmN0aW9uIGluaXRXcmFwcGVyU3RhdGUkMShlbGVtZW50LCBwcm9wcykge1xuICB2YXIgbm9kZSA9IGVsZW1lbnQ7XG5cbiAge1xuICAgIGNoZWNrU2VsZWN0UHJvcFR5cGVzKHByb3BzKTtcbiAgfVxuXG4gIG5vZGUuX3dyYXBwZXJTdGF0ZSA9IHtcbiAgICB3YXNNdWx0aXBsZTogISFwcm9wcy5tdWx0aXBsZVxuICB9O1xuXG4gIHtcbiAgICBpZiAocHJvcHMudmFsdWUgIT09IHVuZGVmaW5lZCAmJiBwcm9wcy5kZWZhdWx0VmFsdWUgIT09IHVuZGVmaW5lZCAmJiAhZGlkV2FyblZhbHVlRGVmYXVsdFZhbHVlJDEpIHtcbiAgICAgIGVycm9yKCdTZWxlY3QgZWxlbWVudHMgbXVzdCBiZSBlaXRoZXIgY29udHJvbGxlZCBvciB1bmNvbnRyb2xsZWQgJyArICcoc3BlY2lmeSBlaXRoZXIgdGhlIHZhbHVlIHByb3AsIG9yIHRoZSBkZWZhdWx0VmFsdWUgcHJvcCwgYnV0IG5vdCAnICsgJ2JvdGgpLiBEZWNpZGUgYmV0d2VlbiB1c2luZyBhIGNvbnRyb2xsZWQgb3IgdW5jb250cm9sbGVkIHNlbGVjdCAnICsgJ2VsZW1lbnQgYW5kIHJlbW92ZSBvbmUgb2YgdGhlc2UgcHJvcHMuIE1vcmUgaW5mbzogJyArICdodHRwczovL3JlYWN0anMub3JnL2xpbmsvY29udHJvbGxlZC1jb21wb25lbnRzJyk7XG5cbiAgICAgIGRpZFdhcm5WYWx1ZURlZmF1bHRWYWx1ZSQxID0gdHJ1ZTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIHBvc3RNb3VudFdyYXBwZXIkMihlbGVtZW50LCBwcm9wcykge1xuICB2YXIgbm9kZSA9IGVsZW1lbnQ7XG4gIG5vZGUubXVsdGlwbGUgPSAhIXByb3BzLm11bHRpcGxlO1xuICB2YXIgdmFsdWUgPSBwcm9wcy52YWx1ZTtcblxuICBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgIHVwZGF0ZU9wdGlvbnMobm9kZSwgISFwcm9wcy5tdWx0aXBsZSwgdmFsdWUsIGZhbHNlKTtcbiAgfSBlbHNlIGlmIChwcm9wcy5kZWZhdWx0VmFsdWUgIT0gbnVsbCkge1xuICAgIHVwZGF0ZU9wdGlvbnMobm9kZSwgISFwcm9wcy5tdWx0aXBsZSwgcHJvcHMuZGVmYXVsdFZhbHVlLCB0cnVlKTtcbiAgfVxufVxuZnVuY3Rpb24gcG9zdFVwZGF0ZVdyYXBwZXIoZWxlbWVudCwgcHJvcHMpIHtcbiAgdmFyIG5vZGUgPSBlbGVtZW50O1xuICB2YXIgd2FzTXVsdGlwbGUgPSBub2RlLl93cmFwcGVyU3RhdGUud2FzTXVsdGlwbGU7XG4gIG5vZGUuX3dyYXBwZXJTdGF0ZS53YXNNdWx0aXBsZSA9ICEhcHJvcHMubXVsdGlwbGU7XG4gIHZhciB2YWx1ZSA9IHByb3BzLnZhbHVlO1xuXG4gIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgdXBkYXRlT3B0aW9ucyhub2RlLCAhIXByb3BzLm11bHRpcGxlLCB2YWx1ZSwgZmFsc2UpO1xuICB9IGVsc2UgaWYgKHdhc011bHRpcGxlICE9PSAhIXByb3BzLm11bHRpcGxlKSB7XG4gICAgLy8gRm9yIHNpbXBsaWNpdHksIHJlYXBwbHkgYGRlZmF1bHRWYWx1ZWAgaWYgYG11bHRpcGxlYCBpcyB0b2dnbGVkLlxuICAgIGlmIChwcm9wcy5kZWZhdWx0VmFsdWUgIT0gbnVsbCkge1xuICAgICAgdXBkYXRlT3B0aW9ucyhub2RlLCAhIXByb3BzLm11bHRpcGxlLCBwcm9wcy5kZWZhdWx0VmFsdWUsIHRydWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBSZXZlcnQgdGhlIHNlbGVjdCBiYWNrIHRvIGl0cyBkZWZhdWx0IHVuc2VsZWN0ZWQgc3RhdGUuXG4gICAgICB1cGRhdGVPcHRpb25zKG5vZGUsICEhcHJvcHMubXVsdGlwbGUsIHByb3BzLm11bHRpcGxlID8gW10gOiAnJywgZmFsc2UpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gcmVzdG9yZUNvbnRyb2xsZWRTdGF0ZSQxKGVsZW1lbnQsIHByb3BzKSB7XG4gIHZhciBub2RlID0gZWxlbWVudDtcbiAgdmFyIHZhbHVlID0gcHJvcHMudmFsdWU7XG5cbiAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICB1cGRhdGVPcHRpb25zKG5vZGUsICEhcHJvcHMubXVsdGlwbGUsIHZhbHVlLCBmYWxzZSk7XG4gIH1cbn1cblxudmFyIGRpZFdhcm5WYWxEZWZhdWx0VmFsID0gZmFsc2U7XG5cbi8qKlxuICogSW1wbGVtZW50cyBhIDx0ZXh0YXJlYT4gaG9zdCBjb21wb25lbnQgdGhhdCBhbGxvd3Mgc2V0dGluZyBgdmFsdWVgLCBhbmRcbiAqIGBkZWZhdWx0VmFsdWVgLiBUaGlzIGRpZmZlcnMgZnJvbSB0aGUgdHJhZGl0aW9uYWwgRE9NIEFQSSBiZWNhdXNlIHZhbHVlIGlzXG4gKiB1c3VhbGx5IHNldCBhcyBQQ0RBVEEgY2hpbGRyZW4uXG4gKlxuICogSWYgYHZhbHVlYCBpcyBub3Qgc3VwcGxpZWQgKG9yIG51bGwvdW5kZWZpbmVkKSwgdXNlciBhY3Rpb25zIHRoYXQgYWZmZWN0IHRoZVxuICogdmFsdWUgd2lsbCB0cmlnZ2VyIHVwZGF0ZXMgdG8gdGhlIGVsZW1lbnQuXG4gKlxuICogSWYgYHZhbHVlYCBpcyBzdXBwbGllZCAoYW5kIG5vdCBudWxsL3VuZGVmaW5lZCksIHRoZSByZW5kZXJlZCBlbGVtZW50IHdpbGxcbiAqIG5vdCB0cmlnZ2VyIHVwZGF0ZXMgdG8gdGhlIGVsZW1lbnQuIEluc3RlYWQsIHRoZSBgdmFsdWVgIHByb3AgbXVzdCBjaGFuZ2UgaW5cbiAqIG9yZGVyIGZvciB0aGUgcmVuZGVyZWQgZWxlbWVudCB0byBiZSB1cGRhdGVkLlxuICpcbiAqIFRoZSByZW5kZXJlZCBlbGVtZW50IHdpbGwgYmUgaW5pdGlhbGl6ZWQgd2l0aCBhbiBlbXB0eSB2YWx1ZSwgdGhlIHByb3BcbiAqIGBkZWZhdWx0VmFsdWVgIGlmIHNwZWNpZmllZCwgb3IgdGhlIGNoaWxkcmVuIGNvbnRlbnQgKGRlcHJlY2F0ZWQpLlxuICovXG5mdW5jdGlvbiBnZXRIb3N0UHJvcHMkMyhlbGVtZW50LCBwcm9wcykge1xuICB2YXIgbm9kZSA9IGVsZW1lbnQ7XG5cbiAgaWYgKCEocHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwgPT0gbnVsbCkpIHtcbiAgICB7XG4gICAgICB0aHJvdyBFcnJvciggXCJgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxgIGRvZXMgbm90IG1ha2Ugc2Vuc2Ugb24gPHRleHRhcmVhPi5cIiApO1xuICAgIH1cbiAgfSAvLyBBbHdheXMgc2V0IGNoaWxkcmVuIHRvIHRoZSBzYW1lIHRoaW5nLiBJbiBJRTksIHRoZSBzZWxlY3Rpb24gcmFuZ2Ugd2lsbFxuICAvLyBnZXQgcmVzZXQgaWYgYHRleHRDb250ZW50YCBpcyBtdXRhdGVkLiAgV2UgY291bGQgYWRkIGEgY2hlY2sgaW4gc2V0VGV4dENvbnRlbnRcbiAgLy8gdG8gb25seSBzZXQgdGhlIHZhbHVlIGlmL3doZW4gdGhlIHZhbHVlIGRpZmZlcnMgZnJvbSB0aGUgbm9kZSB2YWx1ZSAod2hpY2ggd291bGRcbiAgLy8gY29tcGxldGVseSBzb2x2ZSB0aGlzIElFOSBidWcpLCBidXQgU2ViYXN0aWFuK1NvcGhpZSBzZWVtZWQgdG8gbGlrZSB0aGlzXG4gIC8vIHNvbHV0aW9uLiBUaGUgdmFsdWUgY2FuIGJlIGEgYm9vbGVhbiBvciBvYmplY3Qgc28gdGhhdCdzIHdoeSBpdCdzIGZvcmNlZFxuICAvLyB0byBiZSBhIHN0cmluZy5cblxuXG4gIHZhciBob3N0UHJvcHMgPSBfYXNzaWduKHt9LCBwcm9wcywge1xuICAgIHZhbHVlOiB1bmRlZmluZWQsXG4gICAgZGVmYXVsdFZhbHVlOiB1bmRlZmluZWQsXG4gICAgY2hpbGRyZW46IHRvU3RyaW5nKG5vZGUuX3dyYXBwZXJTdGF0ZS5pbml0aWFsVmFsdWUpXG4gIH0pO1xuXG4gIHJldHVybiBob3N0UHJvcHM7XG59XG5mdW5jdGlvbiBpbml0V3JhcHBlclN0YXRlJDIoZWxlbWVudCwgcHJvcHMpIHtcbiAgdmFyIG5vZGUgPSBlbGVtZW50O1xuXG4gIHtcbiAgICBjaGVja0NvbnRyb2xsZWRWYWx1ZVByb3BzKCd0ZXh0YXJlYScsIHByb3BzKTtcblxuICAgIGlmIChwcm9wcy52YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHByb3BzLmRlZmF1bHRWYWx1ZSAhPT0gdW5kZWZpbmVkICYmICFkaWRXYXJuVmFsRGVmYXVsdFZhbCkge1xuICAgICAgZXJyb3IoJyVzIGNvbnRhaW5zIGEgdGV4dGFyZWEgd2l0aCBib3RoIHZhbHVlIGFuZCBkZWZhdWx0VmFsdWUgcHJvcHMuICcgKyAnVGV4dGFyZWEgZWxlbWVudHMgbXVzdCBiZSBlaXRoZXIgY29udHJvbGxlZCBvciB1bmNvbnRyb2xsZWQgJyArICcoc3BlY2lmeSBlaXRoZXIgdGhlIHZhbHVlIHByb3AsIG9yIHRoZSBkZWZhdWx0VmFsdWUgcHJvcCwgYnV0IG5vdCAnICsgJ2JvdGgpLiBEZWNpZGUgYmV0d2VlbiB1c2luZyBhIGNvbnRyb2xsZWQgb3IgdW5jb250cm9sbGVkIHRleHRhcmVhICcgKyAnYW5kIHJlbW92ZSBvbmUgb2YgdGhlc2UgcHJvcHMuIE1vcmUgaW5mbzogJyArICdodHRwczovL3JlYWN0anMub3JnL2xpbmsvY29udHJvbGxlZC1jb21wb25lbnRzJywgZ2V0Q3VycmVudEZpYmVyT3duZXJOYW1lSW5EZXZPck51bGwoKSB8fCAnQSBjb21wb25lbnQnKTtcblxuICAgICAgZGlkV2FyblZhbERlZmF1bHRWYWwgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHZhciBpbml0aWFsVmFsdWUgPSBwcm9wcy52YWx1ZTsgLy8gT25seSBib3RoZXIgZmV0Y2hpbmcgZGVmYXVsdCB2YWx1ZSBpZiB3ZSdyZSBnb2luZyB0byB1c2UgaXRcblxuICBpZiAoaW5pdGlhbFZhbHVlID09IG51bGwpIHtcbiAgICB2YXIgY2hpbGRyZW4gPSBwcm9wcy5jaGlsZHJlbixcbiAgICAgICAgZGVmYXVsdFZhbHVlID0gcHJvcHMuZGVmYXVsdFZhbHVlO1xuXG4gICAgaWYgKGNoaWxkcmVuICE9IG51bGwpIHtcbiAgICAgIHtcbiAgICAgICAgZXJyb3IoJ1VzZSB0aGUgYGRlZmF1bHRWYWx1ZWAgb3IgYHZhbHVlYCBwcm9wcyBpbnN0ZWFkIG9mIHNldHRpbmcgJyArICdjaGlsZHJlbiBvbiA8dGV4dGFyZWE+LicpO1xuICAgICAgfVxuXG4gICAgICB7XG4gICAgICAgIGlmICghKGRlZmF1bHRWYWx1ZSA9PSBudWxsKSkge1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKCBcIklmIHlvdSBzdXBwbHkgYGRlZmF1bHRWYWx1ZWAgb24gYSA8dGV4dGFyZWE+LCBkbyBub3QgcGFzcyBjaGlsZHJlbi5cIiApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGNoaWxkcmVuKSkge1xuICAgICAgICAgIGlmICghKGNoaWxkcmVuLmxlbmd0aCA8PSAxKSkge1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICB0aHJvdyBFcnJvciggXCI8dGV4dGFyZWE+IGNhbiBvbmx5IGhhdmUgYXQgbW9zdCBvbmUgY2hpbGQuXCIgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjaGlsZHJlbiA9IGNoaWxkcmVuWzBdO1xuICAgICAgICB9XG5cbiAgICAgICAgZGVmYXVsdFZhbHVlID0gY2hpbGRyZW47XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGRlZmF1bHRWYWx1ZSA9PSBudWxsKSB7XG4gICAgICBkZWZhdWx0VmFsdWUgPSAnJztcbiAgICB9XG5cbiAgICBpbml0aWFsVmFsdWUgPSBkZWZhdWx0VmFsdWU7XG4gIH1cblxuICBub2RlLl93cmFwcGVyU3RhdGUgPSB7XG4gICAgaW5pdGlhbFZhbHVlOiBnZXRUb1N0cmluZ1ZhbHVlKGluaXRpYWxWYWx1ZSlcbiAgfTtcbn1cbmZ1bmN0aW9uIHVwZGF0ZVdyYXBwZXIkMShlbGVtZW50LCBwcm9wcykge1xuICB2YXIgbm9kZSA9IGVsZW1lbnQ7XG4gIHZhciB2YWx1ZSA9IGdldFRvU3RyaW5nVmFsdWUocHJvcHMudmFsdWUpO1xuICB2YXIgZGVmYXVsdFZhbHVlID0gZ2V0VG9TdHJpbmdWYWx1ZShwcm9wcy5kZWZhdWx0VmFsdWUpO1xuXG4gIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgLy8gQ2FzdCBgdmFsdWVgIHRvIGEgc3RyaW5nIHRvIGVuc3VyZSB0aGUgdmFsdWUgaXMgc2V0IGNvcnJlY3RseS4gV2hpbGVcbiAgICAvLyBicm93c2VycyB0eXBpY2FsbHkgZG8gdGhpcyBhcyBuZWNlc3NhcnksIGpzZG9tIGRvZXNuJ3QuXG4gICAgdmFyIG5ld1ZhbHVlID0gdG9TdHJpbmcodmFsdWUpOyAvLyBUbyBhdm9pZCBzaWRlIGVmZmVjdHMgKHN1Y2ggYXMgbG9zaW5nIHRleHQgc2VsZWN0aW9uKSwgb25seSBzZXQgdmFsdWUgaWYgY2hhbmdlZFxuXG4gICAgaWYgKG5ld1ZhbHVlICE9PSBub2RlLnZhbHVlKSB7XG4gICAgICBub2RlLnZhbHVlID0gbmV3VmFsdWU7XG4gICAgfVxuXG4gICAgaWYgKHByb3BzLmRlZmF1bHRWYWx1ZSA9PSBudWxsICYmIG5vZGUuZGVmYXVsdFZhbHVlICE9PSBuZXdWYWx1ZSkge1xuICAgICAgbm9kZS5kZWZhdWx0VmFsdWUgPSBuZXdWYWx1ZTtcbiAgICB9XG4gIH1cblxuICBpZiAoZGVmYXVsdFZhbHVlICE9IG51bGwpIHtcbiAgICBub2RlLmRlZmF1bHRWYWx1ZSA9IHRvU3RyaW5nKGRlZmF1bHRWYWx1ZSk7XG4gIH1cbn1cbmZ1bmN0aW9uIHBvc3RNb3VudFdyYXBwZXIkMyhlbGVtZW50LCBwcm9wcykge1xuICB2YXIgbm9kZSA9IGVsZW1lbnQ7IC8vIFRoaXMgaXMgaW4gcG9zdE1vdW50IGJlY2F1c2Ugd2UgbmVlZCBhY2Nlc3MgdG8gdGhlIERPTSBub2RlLCB3aGljaCBpcyBub3RcbiAgLy8gYXZhaWxhYmxlIHVudGlsIGFmdGVyIHRoZSBjb21wb25lbnQgaGFzIG1vdW50ZWQuXG5cbiAgdmFyIHRleHRDb250ZW50ID0gbm9kZS50ZXh0Q29udGVudDsgLy8gT25seSBzZXQgbm9kZS52YWx1ZSBpZiB0ZXh0Q29udGVudCBpcyBlcXVhbCB0byB0aGUgZXhwZWN0ZWRcbiAgLy8gaW5pdGlhbCB2YWx1ZS4gSW4gSUUxMC9JRTExIHRoZXJlIGlzIGEgYnVnIHdoZXJlIHRoZSBwbGFjZWhvbGRlciBhdHRyaWJ1dGVcbiAgLy8gd2lsbCBwb3B1bGF0ZSB0ZXh0Q29udGVudCBhcyB3ZWxsLlxuICAvLyBodHRwczovL2RldmVsb3Blci5taWNyb3NvZnQuY29tL21pY3Jvc29mdC1lZGdlL3BsYXRmb3JtL2lzc3Vlcy8xMDE1MjUvXG5cbiAgaWYgKHRleHRDb250ZW50ID09PSBub2RlLl93cmFwcGVyU3RhdGUuaW5pdGlhbFZhbHVlKSB7XG4gICAgaWYgKHRleHRDb250ZW50ICE9PSAnJyAmJiB0ZXh0Q29udGVudCAhPT0gbnVsbCkge1xuICAgICAgbm9kZS52YWx1ZSA9IHRleHRDb250ZW50O1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gcmVzdG9yZUNvbnRyb2xsZWRTdGF0ZSQyKGVsZW1lbnQsIHByb3BzKSB7XG4gIC8vIERPTSBjb21wb25lbnQgaXMgc3RpbGwgbW91bnRlZDsgdXBkYXRlXG4gIHVwZGF0ZVdyYXBwZXIkMShlbGVtZW50LCBwcm9wcyk7XG59XG5cbnZhciBIVE1MX05BTUVTUEFDRSA9ICdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sJztcbnZhciBNQVRIX05BTUVTUEFDRSA9ICdodHRwOi8vd3d3LnczLm9yZy8xOTk4L01hdGgvTWF0aE1MJztcbnZhciBTVkdfTkFNRVNQQUNFID0gJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJztcbnZhciBOYW1lc3BhY2VzID0ge1xuICBodG1sOiBIVE1MX05BTUVTUEFDRSxcbiAgbWF0aG1sOiBNQVRIX05BTUVTUEFDRSxcbiAgc3ZnOiBTVkdfTkFNRVNQQUNFXG59OyAvLyBBc3N1bWVzIHRoZXJlIGlzIG5vIHBhcmVudCBuYW1lc3BhY2UuXG5cbmZ1bmN0aW9uIGdldEludHJpbnNpY05hbWVzcGFjZSh0eXBlKSB7XG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgJ3N2Zyc6XG4gICAgICByZXR1cm4gU1ZHX05BTUVTUEFDRTtcblxuICAgIGNhc2UgJ21hdGgnOlxuICAgICAgcmV0dXJuIE1BVEhfTkFNRVNQQUNFO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBIVE1MX05BTUVTUEFDRTtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0Q2hpbGROYW1lc3BhY2UocGFyZW50TmFtZXNwYWNlLCB0eXBlKSB7XG4gIGlmIChwYXJlbnROYW1lc3BhY2UgPT0gbnVsbCB8fCBwYXJlbnROYW1lc3BhY2UgPT09IEhUTUxfTkFNRVNQQUNFKSB7XG4gICAgLy8gTm8gKG9yIGRlZmF1bHQpIHBhcmVudCBuYW1lc3BhY2U6IHBvdGVudGlhbCBlbnRyeSBwb2ludC5cbiAgICByZXR1cm4gZ2V0SW50cmluc2ljTmFtZXNwYWNlKHR5cGUpO1xuICB9XG5cbiAgaWYgKHBhcmVudE5hbWVzcGFjZSA9PT0gU1ZHX05BTUVTUEFDRSAmJiB0eXBlID09PSAnZm9yZWlnbk9iamVjdCcpIHtcbiAgICAvLyBXZSdyZSBsZWF2aW5nIFNWRy5cbiAgICByZXR1cm4gSFRNTF9OQU1FU1BBQ0U7XG4gIH0gLy8gQnkgZGVmYXVsdCwgcGFzcyBuYW1lc3BhY2UgYmVsb3cuXG5cblxuICByZXR1cm4gcGFyZW50TmFtZXNwYWNlO1xufVxuXG4vKiBnbG9iYWxzIE1TQXBwICovXG5cbi8qKlxuICogQ3JlYXRlIGEgZnVuY3Rpb24gd2hpY2ggaGFzICd1bnNhZmUnIHByaXZpbGVnZXMgKHJlcXVpcmVkIGJ5IHdpbmRvd3M4IGFwcHMpXG4gKi9cbnZhciBjcmVhdGVNaWNyb3NvZnRVbnNhZmVMb2NhbEZ1bmN0aW9uID0gZnVuY3Rpb24gKGZ1bmMpIHtcbiAgaWYgKHR5cGVvZiBNU0FwcCAhPT0gJ3VuZGVmaW5lZCcgJiYgTVNBcHAuZXhlY1Vuc2FmZUxvY2FsRnVuY3Rpb24pIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGFyZzAsIGFyZzEsIGFyZzIsIGFyZzMpIHtcbiAgICAgIE1TQXBwLmV4ZWNVbnNhZmVMb2NhbEZ1bmN0aW9uKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmMoYXJnMCwgYXJnMSwgYXJnMiwgYXJnMyk7XG4gICAgICB9KTtcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBmdW5jO1xuICB9XG59O1xuXG52YXIgcmV1c2FibGVTVkdDb250YWluZXI7XG4vKipcbiAqIFNldCB0aGUgaW5uZXJIVE1MIHByb3BlcnR5IG9mIGEgbm9kZVxuICpcbiAqIEBwYXJhbSB7RE9NRWxlbWVudH0gbm9kZVxuICogQHBhcmFtIHtzdHJpbmd9IGh0bWxcbiAqIEBpbnRlcm5hbFxuICovXG5cbnZhciBzZXRJbm5lckhUTUwgPSBjcmVhdGVNaWNyb3NvZnRVbnNhZmVMb2NhbEZ1bmN0aW9uKGZ1bmN0aW9uIChub2RlLCBodG1sKSB7XG4gIGlmIChub2RlLm5hbWVzcGFjZVVSSSA9PT0gTmFtZXNwYWNlcy5zdmcpIHtcblxuICAgIGlmICghKCdpbm5lckhUTUwnIGluIG5vZGUpKSB7XG4gICAgICAvLyBJRSBkb2VzIG5vdCBoYXZlIGlubmVySFRNTCBmb3IgU1ZHIG5vZGVzLCBzbyBpbnN0ZWFkIHdlIGluamVjdCB0aGVcbiAgICAgIC8vIG5ldyBtYXJrdXAgaW4gYSB0ZW1wIG5vZGUgYW5kIHRoZW4gbW92ZSB0aGUgY2hpbGQgbm9kZXMgYWNyb3NzIGludG9cbiAgICAgIC8vIHRoZSB0YXJnZXQgbm9kZVxuICAgICAgcmV1c2FibGVTVkdDb250YWluZXIgPSByZXVzYWJsZVNWR0NvbnRhaW5lciB8fCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgIHJldXNhYmxlU1ZHQ29udGFpbmVyLmlubmVySFRNTCA9ICc8c3ZnPicgKyBodG1sLnZhbHVlT2YoKS50b1N0cmluZygpICsgJzwvc3ZnPic7XG4gICAgICB2YXIgc3ZnTm9kZSA9IHJldXNhYmxlU1ZHQ29udGFpbmVyLmZpcnN0Q2hpbGQ7XG5cbiAgICAgIHdoaWxlIChub2RlLmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgbm9kZS5yZW1vdmVDaGlsZChub2RlLmZpcnN0Q2hpbGQpO1xuICAgICAgfVxuXG4gICAgICB3aGlsZSAoc3ZnTm9kZS5maXJzdENoaWxkKSB7XG4gICAgICAgIG5vZGUuYXBwZW5kQ2hpbGQoc3ZnTm9kZS5maXJzdENoaWxkKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxuXG4gIG5vZGUuaW5uZXJIVE1MID0gaHRtbDtcbn0pO1xuXG4vKipcbiAqIEhUTUwgbm9kZVR5cGUgdmFsdWVzIHRoYXQgcmVwcmVzZW50IHRoZSB0eXBlIG9mIHRoZSBub2RlXG4gKi9cbnZhciBFTEVNRU5UX05PREUgPSAxO1xudmFyIFRFWFRfTk9ERSA9IDM7XG52YXIgQ09NTUVOVF9OT0RFID0gODtcbnZhciBET0NVTUVOVF9OT0RFID0gOTtcbnZhciBET0NVTUVOVF9GUkFHTUVOVF9OT0RFID0gMTE7XG5cbi8qKlxuICogU2V0IHRoZSB0ZXh0Q29udGVudCBwcm9wZXJ0eSBvZiBhIG5vZGUuIEZvciB0ZXh0IHVwZGF0ZXMsIGl0J3MgZmFzdGVyXG4gKiB0byBzZXQgdGhlIGBub2RlVmFsdWVgIG9mIHRoZSBUZXh0IG5vZGUgZGlyZWN0bHkgaW5zdGVhZCBvZiB1c2luZ1xuICogYC50ZXh0Q29udGVudGAgd2hpY2ggd2lsbCByZW1vdmUgdGhlIGV4aXN0aW5nIG5vZGUgYW5kIGNyZWF0ZSBhIG5ldyBvbmUuXG4gKlxuICogQHBhcmFtIHtET01FbGVtZW50fSBub2RlXG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dFxuICogQGludGVybmFsXG4gKi9cblxudmFyIHNldFRleHRDb250ZW50ID0gZnVuY3Rpb24gKG5vZGUsIHRleHQpIHtcbiAgaWYgKHRleHQpIHtcbiAgICB2YXIgZmlyc3RDaGlsZCA9IG5vZGUuZmlyc3RDaGlsZDtcblxuICAgIGlmIChmaXJzdENoaWxkICYmIGZpcnN0Q2hpbGQgPT09IG5vZGUubGFzdENoaWxkICYmIGZpcnN0Q2hpbGQubm9kZVR5cGUgPT09IFRFWFRfTk9ERSkge1xuICAgICAgZmlyc3RDaGlsZC5ub2RlVmFsdWUgPSB0ZXh0O1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxuXG4gIG5vZGUudGV4dENvbnRlbnQgPSB0ZXh0O1xufTtcblxuLy8gTGlzdCBkZXJpdmVkIGZyb20gR2Vja28gc291cmNlIGNvZGU6XG4vLyBodHRwczovL2dpdGh1Yi5jb20vbW96aWxsYS9nZWNrby1kZXYvYmxvYi80ZTYzOGVmYzcxL2xheW91dC9zdHlsZS90ZXN0L3Byb3BlcnR5X2RhdGFiYXNlLmpzXG52YXIgc2hvcnRoYW5kVG9Mb25naGFuZCA9IHtcbiAgYW5pbWF0aW9uOiBbJ2FuaW1hdGlvbkRlbGF5JywgJ2FuaW1hdGlvbkRpcmVjdGlvbicsICdhbmltYXRpb25EdXJhdGlvbicsICdhbmltYXRpb25GaWxsTW9kZScsICdhbmltYXRpb25JdGVyYXRpb25Db3VudCcsICdhbmltYXRpb25OYW1lJywgJ2FuaW1hdGlvblBsYXlTdGF0ZScsICdhbmltYXRpb25UaW1pbmdGdW5jdGlvbiddLFxuICBiYWNrZ3JvdW5kOiBbJ2JhY2tncm91bmRBdHRhY2htZW50JywgJ2JhY2tncm91bmRDbGlwJywgJ2JhY2tncm91bmRDb2xvcicsICdiYWNrZ3JvdW5kSW1hZ2UnLCAnYmFja2dyb3VuZE9yaWdpbicsICdiYWNrZ3JvdW5kUG9zaXRpb25YJywgJ2JhY2tncm91bmRQb3NpdGlvblknLCAnYmFja2dyb3VuZFJlcGVhdCcsICdiYWNrZ3JvdW5kU2l6ZSddLFxuICBiYWNrZ3JvdW5kUG9zaXRpb246IFsnYmFja2dyb3VuZFBvc2l0aW9uWCcsICdiYWNrZ3JvdW5kUG9zaXRpb25ZJ10sXG4gIGJvcmRlcjogWydib3JkZXJCb3R0b21Db2xvcicsICdib3JkZXJCb3R0b21TdHlsZScsICdib3JkZXJCb3R0b21XaWR0aCcsICdib3JkZXJJbWFnZU91dHNldCcsICdib3JkZXJJbWFnZVJlcGVhdCcsICdib3JkZXJJbWFnZVNsaWNlJywgJ2JvcmRlckltYWdlU291cmNlJywgJ2JvcmRlckltYWdlV2lkdGgnLCAnYm9yZGVyTGVmdENvbG9yJywgJ2JvcmRlckxlZnRTdHlsZScsICdib3JkZXJMZWZ0V2lkdGgnLCAnYm9yZGVyUmlnaHRDb2xvcicsICdib3JkZXJSaWdodFN0eWxlJywgJ2JvcmRlclJpZ2h0V2lkdGgnLCAnYm9yZGVyVG9wQ29sb3InLCAnYm9yZGVyVG9wU3R5bGUnLCAnYm9yZGVyVG9wV2lkdGgnXSxcbiAgYm9yZGVyQmxvY2tFbmQ6IFsnYm9yZGVyQmxvY2tFbmRDb2xvcicsICdib3JkZXJCbG9ja0VuZFN0eWxlJywgJ2JvcmRlckJsb2NrRW5kV2lkdGgnXSxcbiAgYm9yZGVyQmxvY2tTdGFydDogWydib3JkZXJCbG9ja1N0YXJ0Q29sb3InLCAnYm9yZGVyQmxvY2tTdGFydFN0eWxlJywgJ2JvcmRlckJsb2NrU3RhcnRXaWR0aCddLFxuICBib3JkZXJCb3R0b206IFsnYm9yZGVyQm90dG9tQ29sb3InLCAnYm9yZGVyQm90dG9tU3R5bGUnLCAnYm9yZGVyQm90dG9tV2lkdGgnXSxcbiAgYm9yZGVyQ29sb3I6IFsnYm9yZGVyQm90dG9tQ29sb3InLCAnYm9yZGVyTGVmdENvbG9yJywgJ2JvcmRlclJpZ2h0Q29sb3InLCAnYm9yZGVyVG9wQ29sb3InXSxcbiAgYm9yZGVySW1hZ2U6IFsnYm9yZGVySW1hZ2VPdXRzZXQnLCAnYm9yZGVySW1hZ2VSZXBlYXQnLCAnYm9yZGVySW1hZ2VTbGljZScsICdib3JkZXJJbWFnZVNvdXJjZScsICdib3JkZXJJbWFnZVdpZHRoJ10sXG4gIGJvcmRlcklubGluZUVuZDogWydib3JkZXJJbmxpbmVFbmRDb2xvcicsICdib3JkZXJJbmxpbmVFbmRTdHlsZScsICdib3JkZXJJbmxpbmVFbmRXaWR0aCddLFxuICBib3JkZXJJbmxpbmVTdGFydDogWydib3JkZXJJbmxpbmVTdGFydENvbG9yJywgJ2JvcmRlcklubGluZVN0YXJ0U3R5bGUnLCAnYm9yZGVySW5saW5lU3RhcnRXaWR0aCddLFxuICBib3JkZXJMZWZ0OiBbJ2JvcmRlckxlZnRDb2xvcicsICdib3JkZXJMZWZ0U3R5bGUnLCAnYm9yZGVyTGVmdFdpZHRoJ10sXG4gIGJvcmRlclJhZGl1czogWydib3JkZXJCb3R0b21MZWZ0UmFkaXVzJywgJ2JvcmRlckJvdHRvbVJpZ2h0UmFkaXVzJywgJ2JvcmRlclRvcExlZnRSYWRpdXMnLCAnYm9yZGVyVG9wUmlnaHRSYWRpdXMnXSxcbiAgYm9yZGVyUmlnaHQ6IFsnYm9yZGVyUmlnaHRDb2xvcicsICdib3JkZXJSaWdodFN0eWxlJywgJ2JvcmRlclJpZ2h0V2lkdGgnXSxcbiAgYm9yZGVyU3R5bGU6IFsnYm9yZGVyQm90dG9tU3R5bGUnLCAnYm9yZGVyTGVmdFN0eWxlJywgJ2JvcmRlclJpZ2h0U3R5bGUnLCAnYm9yZGVyVG9wU3R5bGUnXSxcbiAgYm9yZGVyVG9wOiBbJ2JvcmRlclRvcENvbG9yJywgJ2JvcmRlclRvcFN0eWxlJywgJ2JvcmRlclRvcFdpZHRoJ10sXG4gIGJvcmRlcldpZHRoOiBbJ2JvcmRlckJvdHRvbVdpZHRoJywgJ2JvcmRlckxlZnRXaWR0aCcsICdib3JkZXJSaWdodFdpZHRoJywgJ2JvcmRlclRvcFdpZHRoJ10sXG4gIGNvbHVtblJ1bGU6IFsnY29sdW1uUnVsZUNvbG9yJywgJ2NvbHVtblJ1bGVTdHlsZScsICdjb2x1bW5SdWxlV2lkdGgnXSxcbiAgY29sdW1uczogWydjb2x1bW5Db3VudCcsICdjb2x1bW5XaWR0aCddLFxuICBmbGV4OiBbJ2ZsZXhCYXNpcycsICdmbGV4R3JvdycsICdmbGV4U2hyaW5rJ10sXG4gIGZsZXhGbG93OiBbJ2ZsZXhEaXJlY3Rpb24nLCAnZmxleFdyYXAnXSxcbiAgZm9udDogWydmb250RmFtaWx5JywgJ2ZvbnRGZWF0dXJlU2V0dGluZ3MnLCAnZm9udEtlcm5pbmcnLCAnZm9udExhbmd1YWdlT3ZlcnJpZGUnLCAnZm9udFNpemUnLCAnZm9udFNpemVBZGp1c3QnLCAnZm9udFN0cmV0Y2gnLCAnZm9udFN0eWxlJywgJ2ZvbnRWYXJpYW50JywgJ2ZvbnRWYXJpYW50QWx0ZXJuYXRlcycsICdmb250VmFyaWFudENhcHMnLCAnZm9udFZhcmlhbnRFYXN0QXNpYW4nLCAnZm9udFZhcmlhbnRMaWdhdHVyZXMnLCAnZm9udFZhcmlhbnROdW1lcmljJywgJ2ZvbnRWYXJpYW50UG9zaXRpb24nLCAnZm9udFdlaWdodCcsICdsaW5lSGVpZ2h0J10sXG4gIGZvbnRWYXJpYW50OiBbJ2ZvbnRWYXJpYW50QWx0ZXJuYXRlcycsICdmb250VmFyaWFudENhcHMnLCAnZm9udFZhcmlhbnRFYXN0QXNpYW4nLCAnZm9udFZhcmlhbnRMaWdhdHVyZXMnLCAnZm9udFZhcmlhbnROdW1lcmljJywgJ2ZvbnRWYXJpYW50UG9zaXRpb24nXSxcbiAgZ2FwOiBbJ2NvbHVtbkdhcCcsICdyb3dHYXAnXSxcbiAgZ3JpZDogWydncmlkQXV0b0NvbHVtbnMnLCAnZ3JpZEF1dG9GbG93JywgJ2dyaWRBdXRvUm93cycsICdncmlkVGVtcGxhdGVBcmVhcycsICdncmlkVGVtcGxhdGVDb2x1bW5zJywgJ2dyaWRUZW1wbGF0ZVJvd3MnXSxcbiAgZ3JpZEFyZWE6IFsnZ3JpZENvbHVtbkVuZCcsICdncmlkQ29sdW1uU3RhcnQnLCAnZ3JpZFJvd0VuZCcsICdncmlkUm93U3RhcnQnXSxcbiAgZ3JpZENvbHVtbjogWydncmlkQ29sdW1uRW5kJywgJ2dyaWRDb2x1bW5TdGFydCddLFxuICBncmlkQ29sdW1uR2FwOiBbJ2NvbHVtbkdhcCddLFxuICBncmlkR2FwOiBbJ2NvbHVtbkdhcCcsICdyb3dHYXAnXSxcbiAgZ3JpZFJvdzogWydncmlkUm93RW5kJywgJ2dyaWRSb3dTdGFydCddLFxuICBncmlkUm93R2FwOiBbJ3Jvd0dhcCddLFxuICBncmlkVGVtcGxhdGU6IFsnZ3JpZFRlbXBsYXRlQXJlYXMnLCAnZ3JpZFRlbXBsYXRlQ29sdW1ucycsICdncmlkVGVtcGxhdGVSb3dzJ10sXG4gIGxpc3RTdHlsZTogWydsaXN0U3R5bGVJbWFnZScsICdsaXN0U3R5bGVQb3NpdGlvbicsICdsaXN0U3R5bGVUeXBlJ10sXG4gIG1hcmdpbjogWydtYXJnaW5Cb3R0b20nLCAnbWFyZ2luTGVmdCcsICdtYXJnaW5SaWdodCcsICdtYXJnaW5Ub3AnXSxcbiAgbWFya2VyOiBbJ21hcmtlckVuZCcsICdtYXJrZXJNaWQnLCAnbWFya2VyU3RhcnQnXSxcbiAgbWFzazogWydtYXNrQ2xpcCcsICdtYXNrQ29tcG9zaXRlJywgJ21hc2tJbWFnZScsICdtYXNrTW9kZScsICdtYXNrT3JpZ2luJywgJ21hc2tQb3NpdGlvblgnLCAnbWFza1Bvc2l0aW9uWScsICdtYXNrUmVwZWF0JywgJ21hc2tTaXplJ10sXG4gIG1hc2tQb3NpdGlvbjogWydtYXNrUG9zaXRpb25YJywgJ21hc2tQb3NpdGlvblknXSxcbiAgb3V0bGluZTogWydvdXRsaW5lQ29sb3InLCAnb3V0bGluZVN0eWxlJywgJ291dGxpbmVXaWR0aCddLFxuICBvdmVyZmxvdzogWydvdmVyZmxvd1gnLCAnb3ZlcmZsb3dZJ10sXG4gIHBhZGRpbmc6IFsncGFkZGluZ0JvdHRvbScsICdwYWRkaW5nTGVmdCcsICdwYWRkaW5nUmlnaHQnLCAncGFkZGluZ1RvcCddLFxuICBwbGFjZUNvbnRlbnQ6IFsnYWxpZ25Db250ZW50JywgJ2p1c3RpZnlDb250ZW50J10sXG4gIHBsYWNlSXRlbXM6IFsnYWxpZ25JdGVtcycsICdqdXN0aWZ5SXRlbXMnXSxcbiAgcGxhY2VTZWxmOiBbJ2FsaWduU2VsZicsICdqdXN0aWZ5U2VsZiddLFxuICB0ZXh0RGVjb3JhdGlvbjogWyd0ZXh0RGVjb3JhdGlvbkNvbG9yJywgJ3RleHREZWNvcmF0aW9uTGluZScsICd0ZXh0RGVjb3JhdGlvblN0eWxlJ10sXG4gIHRleHRFbXBoYXNpczogWyd0ZXh0RW1waGFzaXNDb2xvcicsICd0ZXh0RW1waGFzaXNTdHlsZSddLFxuICB0cmFuc2l0aW9uOiBbJ3RyYW5zaXRpb25EZWxheScsICd0cmFuc2l0aW9uRHVyYXRpb24nLCAndHJhbnNpdGlvblByb3BlcnR5JywgJ3RyYW5zaXRpb25UaW1pbmdGdW5jdGlvbiddLFxuICB3b3JkV3JhcDogWydvdmVyZmxvd1dyYXAnXVxufTtcblxuLyoqXG4gKiBDU1MgcHJvcGVydGllcyB3aGljaCBhY2NlcHQgbnVtYmVycyBidXQgYXJlIG5vdCBpbiB1bml0cyBvZiBcInB4XCIuXG4gKi9cbnZhciBpc1VuaXRsZXNzTnVtYmVyID0ge1xuICBhbmltYXRpb25JdGVyYXRpb25Db3VudDogdHJ1ZSxcbiAgYm9yZGVySW1hZ2VPdXRzZXQ6IHRydWUsXG4gIGJvcmRlckltYWdlU2xpY2U6IHRydWUsXG4gIGJvcmRlckltYWdlV2lkdGg6IHRydWUsXG4gIGJveEZsZXg6IHRydWUsXG4gIGJveEZsZXhHcm91cDogdHJ1ZSxcbiAgYm94T3JkaW5hbEdyb3VwOiB0cnVlLFxuICBjb2x1bW5Db3VudDogdHJ1ZSxcbiAgY29sdW1uczogdHJ1ZSxcbiAgZmxleDogdHJ1ZSxcbiAgZmxleEdyb3c6IHRydWUsXG4gIGZsZXhQb3NpdGl2ZTogdHJ1ZSxcbiAgZmxleFNocmluazogdHJ1ZSxcbiAgZmxleE5lZ2F0aXZlOiB0cnVlLFxuICBmbGV4T3JkZXI6IHRydWUsXG4gIGdyaWRBcmVhOiB0cnVlLFxuICBncmlkUm93OiB0cnVlLFxuICBncmlkUm93RW5kOiB0cnVlLFxuICBncmlkUm93U3BhbjogdHJ1ZSxcbiAgZ3JpZFJvd1N0YXJ0OiB0cnVlLFxuICBncmlkQ29sdW1uOiB0cnVlLFxuICBncmlkQ29sdW1uRW5kOiB0cnVlLFxuICBncmlkQ29sdW1uU3BhbjogdHJ1ZSxcbiAgZ3JpZENvbHVtblN0YXJ0OiB0cnVlLFxuICBmb250V2VpZ2h0OiB0cnVlLFxuICBsaW5lQ2xhbXA6IHRydWUsXG4gIGxpbmVIZWlnaHQ6IHRydWUsXG4gIG9wYWNpdHk6IHRydWUsXG4gIG9yZGVyOiB0cnVlLFxuICBvcnBoYW5zOiB0cnVlLFxuICB0YWJTaXplOiB0cnVlLFxuICB3aWRvd3M6IHRydWUsXG4gIHpJbmRleDogdHJ1ZSxcbiAgem9vbTogdHJ1ZSxcbiAgLy8gU1ZHLXJlbGF0ZWQgcHJvcGVydGllc1xuICBmaWxsT3BhY2l0eTogdHJ1ZSxcbiAgZmxvb2RPcGFjaXR5OiB0cnVlLFxuICBzdG9wT3BhY2l0eTogdHJ1ZSxcbiAgc3Ryb2tlRGFzaGFycmF5OiB0cnVlLFxuICBzdHJva2VEYXNob2Zmc2V0OiB0cnVlLFxuICBzdHJva2VNaXRlcmxpbWl0OiB0cnVlLFxuICBzdHJva2VPcGFjaXR5OiB0cnVlLFxuICBzdHJva2VXaWR0aDogdHJ1ZVxufTtcbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHByZWZpeCB2ZW5kb3Itc3BlY2lmaWMgcHJlZml4LCBlZzogV2Via2l0XG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IHN0eWxlIG5hbWUsIGVnOiB0cmFuc2l0aW9uRHVyYXRpb25cbiAqIEByZXR1cm4ge3N0cmluZ30gc3R5bGUgbmFtZSBwcmVmaXhlZCB3aXRoIGBwcmVmaXhgLCBwcm9wZXJseSBjYW1lbENhc2VkLCBlZzpcbiAqIFdlYmtpdFRyYW5zaXRpb25EdXJhdGlvblxuICovXG5cbmZ1bmN0aW9uIHByZWZpeEtleShwcmVmaXgsIGtleSkge1xuICByZXR1cm4gcHJlZml4ICsga2V5LmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsga2V5LnN1YnN0cmluZygxKTtcbn1cbi8qKlxuICogU3VwcG9ydCBzdHlsZSBuYW1lcyB0aGF0IG1heSBjb21lIHBhc3NlZCBpbiBwcmVmaXhlZCBieSBhZGRpbmcgcGVybXV0YXRpb25zXG4gKiBvZiB2ZW5kb3IgcHJlZml4ZXMuXG4gKi9cblxuXG52YXIgcHJlZml4ZXMgPSBbJ1dlYmtpdCcsICdtcycsICdNb3onLCAnTyddOyAvLyBVc2luZyBPYmplY3Qua2V5cyBoZXJlLCBvciBlbHNlIHRoZSB2YW5pbGxhIGZvci1pbiBsb29wIG1ha2VzIElFOCBnbyBpbnRvIGFuXG4vLyBpbmZpbml0ZSBsb29wLCBiZWNhdXNlIGl0IGl0ZXJhdGVzIG92ZXIgdGhlIG5ld2x5IGFkZGVkIHByb3BzIHRvby5cblxuT2JqZWN0LmtleXMoaXNVbml0bGVzc051bWJlcikuZm9yRWFjaChmdW5jdGlvbiAocHJvcCkge1xuICBwcmVmaXhlcy5mb3JFYWNoKGZ1bmN0aW9uIChwcmVmaXgpIHtcbiAgICBpc1VuaXRsZXNzTnVtYmVyW3ByZWZpeEtleShwcmVmaXgsIHByb3ApXSA9IGlzVW5pdGxlc3NOdW1iZXJbcHJvcF07XG4gIH0pO1xufSk7XG5cbi8qKlxuICogQ29udmVydCBhIHZhbHVlIGludG8gdGhlIHByb3BlciBjc3Mgd3JpdGFibGUgdmFsdWUuIFRoZSBzdHlsZSBuYW1lIGBuYW1lYFxuICogc2hvdWxkIGJlIGxvZ2ljYWwgKG5vIGh5cGhlbnMpLCBhcyBzcGVjaWZpZWRcbiAqIGluIGBDU1NQcm9wZXJ0eS5pc1VuaXRsZXNzTnVtYmVyYC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBDU1MgcHJvcGVydHkgbmFtZSBzdWNoIGFzIGB0b3BNYXJnaW5gLlxuICogQHBhcmFtIHsqfSB2YWx1ZSBDU1MgcHJvcGVydHkgdmFsdWUgc3VjaCBhcyBgMTBweGAuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IE5vcm1hbGl6ZWQgc3R5bGUgdmFsdWUgd2l0aCBkaW1lbnNpb25zIGFwcGxpZWQuXG4gKi9cblxuZnVuY3Rpb24gZGFuZ2Vyb3VzU3R5bGVWYWx1ZShuYW1lLCB2YWx1ZSwgaXNDdXN0b21Qcm9wZXJ0eSkge1xuICAvLyBOb3RlIHRoYXQgd2UndmUgcmVtb3ZlZCBlc2NhcGVUZXh0Rm9yQnJvd3NlcigpIGNhbGxzIGhlcmUgc2luY2UgdGhlXG4gIC8vIHdob2xlIHN0cmluZyB3aWxsIGJlIGVzY2FwZWQgd2hlbiB0aGUgYXR0cmlidXRlIGlzIGluamVjdGVkIGludG9cbiAgLy8gdGhlIG1hcmt1cC4gSWYgeW91IHByb3ZpZGUgdW5zYWZlIHVzZXIgZGF0YSBoZXJlIHRoZXkgY2FuIGluamVjdFxuICAvLyBhcmJpdHJhcnkgQ1NTIHdoaWNoIG1heSBiZSBwcm9ibGVtYXRpYyAoSSBjb3VsZG4ndCByZXBybyB0aGlzKTpcbiAgLy8gaHR0cHM6Ly93d3cub3dhc3Aub3JnL2luZGV4LnBocC9YU1NfRmlsdGVyX0V2YXNpb25fQ2hlYXRfU2hlZXRcbiAgLy8gaHR0cDovL3d3dy50aGVzcGFubmVyLmNvLnVrLzIwMDcvMTEvMjYvdWx0aW1hdGUteHNzLWNzcy1pbmplY3Rpb24vXG4gIC8vIFRoaXMgaXMgbm90IGFuIFhTUyBob2xlIGJ1dCBpbnN0ZWFkIGEgcG90ZW50aWFsIENTUyBpbmplY3Rpb24gaXNzdWVcbiAgLy8gd2hpY2ggaGFzIGxlYWQgdG8gYSBncmVhdGVyIGRpc2N1c3Npb24gYWJvdXQgaG93IHdlJ3JlIGdvaW5nIHRvXG4gIC8vIHRydXN0IFVSTHMgbW92aW5nIGZvcndhcmQuIFNlZSAjMjExNTkwMVxuICB2YXIgaXNFbXB0eSA9IHZhbHVlID09IG51bGwgfHwgdHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicgfHwgdmFsdWUgPT09ICcnO1xuXG4gIGlmIChpc0VtcHR5KSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAgaWYgKCFpc0N1c3RvbVByb3BlcnR5ICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgJiYgdmFsdWUgIT09IDAgJiYgIShpc1VuaXRsZXNzTnVtYmVyLmhhc093blByb3BlcnR5KG5hbWUpICYmIGlzVW5pdGxlc3NOdW1iZXJbbmFtZV0pKSB7XG4gICAgcmV0dXJuIHZhbHVlICsgJ3B4JzsgLy8gUHJlc3VtZXMgaW1wbGljaXQgJ3B4JyBzdWZmaXggZm9yIHVuaXRsZXNzIG51bWJlcnNcbiAgfVxuXG4gIHJldHVybiAoJycgKyB2YWx1ZSkudHJpbSgpO1xufVxuXG52YXIgdXBwZXJjYXNlUGF0dGVybiA9IC8oW0EtWl0pL2c7XG52YXIgbXNQYXR0ZXJuID0gL15tcy0vO1xuLyoqXG4gKiBIeXBoZW5hdGVzIGEgY2FtZWxjYXNlZCBDU1MgcHJvcGVydHkgbmFtZSwgZm9yIGV4YW1wbGU6XG4gKlxuICogICA+IGh5cGhlbmF0ZVN0eWxlTmFtZSgnYmFja2dyb3VuZENvbG9yJylcbiAqICAgPCBcImJhY2tncm91bmQtY29sb3JcIlxuICogICA+IGh5cGhlbmF0ZVN0eWxlTmFtZSgnTW96VHJhbnNpdGlvbicpXG4gKiAgIDwgXCItbW96LXRyYW5zaXRpb25cIlxuICogICA+IGh5cGhlbmF0ZVN0eWxlTmFtZSgnbXNUcmFuc2l0aW9uJylcbiAqICAgPCBcIi1tcy10cmFuc2l0aW9uXCJcbiAqXG4gKiBBcyBNb2Rlcm5penIgc3VnZ2VzdHMgKGh0dHA6Ly9tb2Rlcm5penIuY29tL2RvY3MvI3ByZWZpeGVkKSwgYW4gYG1zYCBwcmVmaXhcbiAqIGlzIGNvbnZlcnRlZCB0byBgLW1zLWAuXG4gKi9cblxuZnVuY3Rpb24gaHlwaGVuYXRlU3R5bGVOYW1lKG5hbWUpIHtcbiAgcmV0dXJuIG5hbWUucmVwbGFjZSh1cHBlcmNhc2VQYXR0ZXJuLCAnLSQxJykudG9Mb3dlckNhc2UoKS5yZXBsYWNlKG1zUGF0dGVybiwgJy1tcy0nKTtcbn1cblxudmFyIHdhcm5WYWxpZFN0eWxlID0gZnVuY3Rpb24gKCkge307XG5cbntcbiAgLy8gJ21zVHJhbnNmb3JtJyBpcyBjb3JyZWN0LCBidXQgdGhlIG90aGVyIHByZWZpeGVzIHNob3VsZCBiZSBjYXBpdGFsaXplZFxuICB2YXIgYmFkVmVuZG9yZWRTdHlsZU5hbWVQYXR0ZXJuID0gL14oPzp3ZWJraXR8bW96fG8pW0EtWl0vO1xuICB2YXIgbXNQYXR0ZXJuJDEgPSAvXi1tcy0vO1xuICB2YXIgaHlwaGVuUGF0dGVybiA9IC8tKC4pL2c7IC8vIHN0eWxlIHZhbHVlcyBzaG91bGRuJ3QgY29udGFpbiBhIHNlbWljb2xvblxuXG4gIHZhciBiYWRTdHlsZVZhbHVlV2l0aFNlbWljb2xvblBhdHRlcm4gPSAvO1xccyokLztcbiAgdmFyIHdhcm5lZFN0eWxlTmFtZXMgPSB7fTtcbiAgdmFyIHdhcm5lZFN0eWxlVmFsdWVzID0ge307XG4gIHZhciB3YXJuZWRGb3JOYU5WYWx1ZSA9IGZhbHNlO1xuICB2YXIgd2FybmVkRm9ySW5maW5pdHlWYWx1ZSA9IGZhbHNlO1xuXG4gIHZhciBjYW1lbGl6ZSA9IGZ1bmN0aW9uIChzdHJpbmcpIHtcbiAgICByZXR1cm4gc3RyaW5nLnJlcGxhY2UoaHlwaGVuUGF0dGVybiwgZnVuY3Rpb24gKF8sIGNoYXJhY3Rlcikge1xuICAgICAgcmV0dXJuIGNoYXJhY3Rlci50b1VwcGVyQ2FzZSgpO1xuICAgIH0pO1xuICB9O1xuXG4gIHZhciB3YXJuSHlwaGVuYXRlZFN0eWxlTmFtZSA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgaWYgKHdhcm5lZFN0eWxlTmFtZXMuaGFzT3duUHJvcGVydHkobmFtZSkgJiYgd2FybmVkU3R5bGVOYW1lc1tuYW1lXSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHdhcm5lZFN0eWxlTmFtZXNbbmFtZV0gPSB0cnVlO1xuXG4gICAgZXJyb3IoJ1Vuc3VwcG9ydGVkIHN0eWxlIHByb3BlcnR5ICVzLiBEaWQgeW91IG1lYW4gJXM/JywgbmFtZSwgLy8gQXMgQW5kaSBTbWl0aCBzdWdnZXN0c1xuICAgIC8vIChodHRwOi8vd3d3LmFuZGlzbWl0aC5jb20vYmxvZy8yMDEyLzAyL21vZGVybml6ci1wcmVmaXhlZC8pLCBhbiBgLW1zYCBwcmVmaXhcbiAgICAvLyBpcyBjb252ZXJ0ZWQgdG8gbG93ZXJjYXNlIGBtc2AuXG4gICAgY2FtZWxpemUobmFtZS5yZXBsYWNlKG1zUGF0dGVybiQxLCAnbXMtJykpKTtcbiAgfTtcblxuICB2YXIgd2FybkJhZFZlbmRvcmVkU3R5bGVOYW1lID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICBpZiAod2FybmVkU3R5bGVOYW1lcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSAmJiB3YXJuZWRTdHlsZU5hbWVzW25hbWVdKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgd2FybmVkU3R5bGVOYW1lc1tuYW1lXSA9IHRydWU7XG5cbiAgICBlcnJvcignVW5zdXBwb3J0ZWQgdmVuZG9yLXByZWZpeGVkIHN0eWxlIHByb3BlcnR5ICVzLiBEaWQgeW91IG1lYW4gJXM/JywgbmFtZSwgbmFtZS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIG5hbWUuc2xpY2UoMSkpO1xuICB9O1xuXG4gIHZhciB3YXJuU3R5bGVWYWx1ZVdpdGhTZW1pY29sb24gPSBmdW5jdGlvbiAobmFtZSwgdmFsdWUpIHtcbiAgICBpZiAod2FybmVkU3R5bGVWYWx1ZXMuaGFzT3duUHJvcGVydHkodmFsdWUpICYmIHdhcm5lZFN0eWxlVmFsdWVzW3ZhbHVlXSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHdhcm5lZFN0eWxlVmFsdWVzW3ZhbHVlXSA9IHRydWU7XG5cbiAgICBlcnJvcihcIlN0eWxlIHByb3BlcnR5IHZhbHVlcyBzaG91bGRuJ3QgY29udGFpbiBhIHNlbWljb2xvbi4gXCIgKyAnVHJ5IFwiJXM6ICVzXCIgaW5zdGVhZC4nLCBuYW1lLCB2YWx1ZS5yZXBsYWNlKGJhZFN0eWxlVmFsdWVXaXRoU2VtaWNvbG9uUGF0dGVybiwgJycpKTtcbiAgfTtcblxuICB2YXIgd2FyblN0eWxlVmFsdWVJc05hTiA9IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSkge1xuICAgIGlmICh3YXJuZWRGb3JOYU5WYWx1ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHdhcm5lZEZvck5hTlZhbHVlID0gdHJ1ZTtcblxuICAgIGVycm9yKCdgTmFOYCBpcyBhbiBpbnZhbGlkIHZhbHVlIGZvciB0aGUgYCVzYCBjc3Mgc3R5bGUgcHJvcGVydHkuJywgbmFtZSk7XG4gIH07XG5cbiAgdmFyIHdhcm5TdHlsZVZhbHVlSXNJbmZpbml0eSA9IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSkge1xuICAgIGlmICh3YXJuZWRGb3JJbmZpbml0eVZhbHVlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgd2FybmVkRm9ySW5maW5pdHlWYWx1ZSA9IHRydWU7XG5cbiAgICBlcnJvcignYEluZmluaXR5YCBpcyBhbiBpbnZhbGlkIHZhbHVlIGZvciB0aGUgYCVzYCBjc3Mgc3R5bGUgcHJvcGVydHkuJywgbmFtZSk7XG4gIH07XG5cbiAgd2FyblZhbGlkU3R5bGUgPSBmdW5jdGlvbiAobmFtZSwgdmFsdWUpIHtcbiAgICBpZiAobmFtZS5pbmRleE9mKCctJykgPiAtMSkge1xuICAgICAgd2Fybkh5cGhlbmF0ZWRTdHlsZU5hbWUobmFtZSk7XG4gICAgfSBlbHNlIGlmIChiYWRWZW5kb3JlZFN0eWxlTmFtZVBhdHRlcm4udGVzdChuYW1lKSkge1xuICAgICAgd2FybkJhZFZlbmRvcmVkU3R5bGVOYW1lKG5hbWUpO1xuICAgIH0gZWxzZSBpZiAoYmFkU3R5bGVWYWx1ZVdpdGhTZW1pY29sb25QYXR0ZXJuLnRlc3QodmFsdWUpKSB7XG4gICAgICB3YXJuU3R5bGVWYWx1ZVdpdGhTZW1pY29sb24obmFtZSwgdmFsdWUpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgICBpZiAoaXNOYU4odmFsdWUpKSB7XG4gICAgICAgIHdhcm5TdHlsZVZhbHVlSXNOYU4obmFtZSwgdmFsdWUpO1xuICAgICAgfSBlbHNlIGlmICghaXNGaW5pdGUodmFsdWUpKSB7XG4gICAgICAgIHdhcm5TdHlsZVZhbHVlSXNJbmZpbml0eShuYW1lLCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xufVxuXG52YXIgd2FyblZhbGlkU3R5bGUkMSA9IHdhcm5WYWxpZFN0eWxlO1xuXG4vKipcbiAqIE9wZXJhdGlvbnMgZm9yIGRlYWxpbmcgd2l0aCBDU1MgcHJvcGVydGllcy5cbiAqL1xuXG4vKipcbiAqIFRoaXMgY3JlYXRlcyBhIHN0cmluZyB0aGF0IGlzIGV4cGVjdGVkIHRvIGJlIGVxdWl2YWxlbnQgdG8gdGhlIHN0eWxlXG4gKiBhdHRyaWJ1dGUgZ2VuZXJhdGVkIGJ5IHNlcnZlci1zaWRlIHJlbmRlcmluZy4gSXQgYnktcGFzc2VzIHdhcm5pbmdzIGFuZFxuICogc2VjdXJpdHkgY2hlY2tzIHNvIGl0J3Mgbm90IHNhZmUgdG8gdXNlIHRoaXMgdmFsdWUgZm9yIGFueXRoaW5nIG90aGVyIHRoYW5cbiAqIGNvbXBhcmlzb24uIEl0IGlzIG9ubHkgdXNlZCBpbiBERVYgZm9yIFNTUiB2YWxpZGF0aW9uLlxuICovXG5cbmZ1bmN0aW9uIGNyZWF0ZURhbmdlcm91c1N0cmluZ0ZvclN0eWxlcyhzdHlsZXMpIHtcbiAge1xuICAgIHZhciBzZXJpYWxpemVkID0gJyc7XG4gICAgdmFyIGRlbGltaXRlciA9ICcnO1xuXG4gICAgZm9yICh2YXIgc3R5bGVOYW1lIGluIHN0eWxlcykge1xuICAgICAgaWYgKCFzdHlsZXMuaGFzT3duUHJvcGVydHkoc3R5bGVOYW1lKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgdmFyIHN0eWxlVmFsdWUgPSBzdHlsZXNbc3R5bGVOYW1lXTtcblxuICAgICAgaWYgKHN0eWxlVmFsdWUgIT0gbnVsbCkge1xuICAgICAgICB2YXIgaXNDdXN0b21Qcm9wZXJ0eSA9IHN0eWxlTmFtZS5pbmRleE9mKCctLScpID09PSAwO1xuICAgICAgICBzZXJpYWxpemVkICs9IGRlbGltaXRlciArIChpc0N1c3RvbVByb3BlcnR5ID8gc3R5bGVOYW1lIDogaHlwaGVuYXRlU3R5bGVOYW1lKHN0eWxlTmFtZSkpICsgJzonO1xuICAgICAgICBzZXJpYWxpemVkICs9IGRhbmdlcm91c1N0eWxlVmFsdWUoc3R5bGVOYW1lLCBzdHlsZVZhbHVlLCBpc0N1c3RvbVByb3BlcnR5KTtcbiAgICAgICAgZGVsaW1pdGVyID0gJzsnO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBzZXJpYWxpemVkIHx8IG51bGw7XG4gIH1cbn1cbi8qKlxuICogU2V0cyB0aGUgdmFsdWUgZm9yIG11bHRpcGxlIHN0eWxlcyBvbiBhIG5vZGUuICBJZiBhIHZhbHVlIGlzIHNwZWNpZmllZCBhc1xuICogJycgKGVtcHR5IHN0cmluZyksIHRoZSBjb3JyZXNwb25kaW5nIHN0eWxlIHByb3BlcnR5IHdpbGwgYmUgdW5zZXQuXG4gKlxuICogQHBhcmFtIHtET01FbGVtZW50fSBub2RlXG4gKiBAcGFyYW0ge29iamVjdH0gc3R5bGVzXG4gKi9cblxuZnVuY3Rpb24gc2V0VmFsdWVGb3JTdHlsZXMobm9kZSwgc3R5bGVzKSB7XG4gIHZhciBzdHlsZSA9IG5vZGUuc3R5bGU7XG5cbiAgZm9yICh2YXIgc3R5bGVOYW1lIGluIHN0eWxlcykge1xuICAgIGlmICghc3R5bGVzLmhhc093blByb3BlcnR5KHN0eWxlTmFtZSkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIHZhciBpc0N1c3RvbVByb3BlcnR5ID0gc3R5bGVOYW1lLmluZGV4T2YoJy0tJykgPT09IDA7XG5cbiAgICB7XG4gICAgICBpZiAoIWlzQ3VzdG9tUHJvcGVydHkpIHtcbiAgICAgICAgd2FyblZhbGlkU3R5bGUkMShzdHlsZU5hbWUsIHN0eWxlc1tzdHlsZU5hbWVdKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgc3R5bGVWYWx1ZSA9IGRhbmdlcm91c1N0eWxlVmFsdWUoc3R5bGVOYW1lLCBzdHlsZXNbc3R5bGVOYW1lXSwgaXNDdXN0b21Qcm9wZXJ0eSk7XG5cbiAgICBpZiAoc3R5bGVOYW1lID09PSAnZmxvYXQnKSB7XG4gICAgICBzdHlsZU5hbWUgPSAnY3NzRmxvYXQnO1xuICAgIH1cblxuICAgIGlmIChpc0N1c3RvbVByb3BlcnR5KSB7XG4gICAgICBzdHlsZS5zZXRQcm9wZXJ0eShzdHlsZU5hbWUsIHN0eWxlVmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdHlsZVtzdHlsZU5hbWVdID0gc3R5bGVWYWx1ZTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNWYWx1ZUVtcHR5KHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA9PSBudWxsIHx8IHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nIHx8IHZhbHVlID09PSAnJztcbn1cbi8qKlxuICogR2l2ZW4ge2NvbG9yOiAncmVkJywgb3ZlcmZsb3c6ICdoaWRkZW4nfSByZXR1cm5zIHtcbiAqICAgY29sb3I6ICdjb2xvcicsXG4gKiAgIG92ZXJmbG93WDogJ292ZXJmbG93JyxcbiAqICAgb3ZlcmZsb3dZOiAnb3ZlcmZsb3cnLFxuICogfS4gVGhpcyBjYW4gYmUgcmVhZCBhcyBcInRoZSBvdmVyZmxvd1kgcHJvcGVydHkgd2FzIHNldCBieSB0aGUgb3ZlcmZsb3dcbiAqIHNob3J0aGFuZFwiLiBUaGF0IGlzLCB0aGUgdmFsdWVzIGFyZSB0aGUgcHJvcGVydHkgdGhhdCBlYWNoIHdhcyBkZXJpdmVkIGZyb20uXG4gKi9cblxuXG5mdW5jdGlvbiBleHBhbmRTaG9ydGhhbmRNYXAoc3R5bGVzKSB7XG4gIHZhciBleHBhbmRlZCA9IHt9O1xuXG4gIGZvciAodmFyIGtleSBpbiBzdHlsZXMpIHtcbiAgICB2YXIgbG9uZ2hhbmRzID0gc2hvcnRoYW5kVG9Mb25naGFuZFtrZXldIHx8IFtrZXldO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsb25naGFuZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGV4cGFuZGVkW2xvbmdoYW5kc1tpXV0gPSBrZXk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGV4cGFuZGVkO1xufVxuLyoqXG4gKiBXaGVuIG1peGluZyBzaG9ydGhhbmQgYW5kIGxvbmdoYW5kIHByb3BlcnR5IG5hbWVzLCB3ZSB3YXJuIGR1cmluZyB1cGRhdGVzIGlmXG4gKiB3ZSBleHBlY3QgYW4gaW5jb3JyZWN0IHJlc3VsdCB0byBvY2N1ci4gSW4gcGFydGljdWxhciwgd2Ugd2FybiBmb3I6XG4gKlxuICogVXBkYXRpbmcgYSBzaG9ydGhhbmQgcHJvcGVydHkgKGxvbmdoYW5kIGdldHMgb3ZlcndyaXR0ZW4pOlxuICogICB7Zm9udDogJ2ZvbycsIGZvbnRWYXJpYW50OiAnYmFyJ30gLT4ge2ZvbnQ6ICdiYXonLCBmb250VmFyaWFudDogJ2Jhcid9XG4gKiAgIGJlY29tZXMgLnN0eWxlLmZvbnQgPSAnYmF6J1xuICogUmVtb3ZpbmcgYSBzaG9ydGhhbmQgcHJvcGVydHkgKGxvbmdoYW5kIGdldHMgbG9zdCB0b28pOlxuICogICB7Zm9udDogJ2ZvbycsIGZvbnRWYXJpYW50OiAnYmFyJ30gLT4ge2ZvbnRWYXJpYW50OiAnYmFyJ31cbiAqICAgYmVjb21lcyAuc3R5bGUuZm9udCA9ICcnXG4gKiBSZW1vdmluZyBhIGxvbmdoYW5kIHByb3BlcnR5IChzaG91bGQgcmV2ZXJ0IHRvIHNob3J0aGFuZDsgZG9lc24ndCk6XG4gKiAgIHtmb250OiAnZm9vJywgZm9udFZhcmlhbnQ6ICdiYXInfSAtPiB7Zm9udDogJ2Zvbyd9XG4gKiAgIGJlY29tZXMgLnN0eWxlLmZvbnRWYXJpYW50ID0gJydcbiAqL1xuXG5cbmZ1bmN0aW9uIHZhbGlkYXRlU2hvcnRoYW5kUHJvcGVydHlDb2xsaXNpb25JbkRldihzdHlsZVVwZGF0ZXMsIG5leHRTdHlsZXMpIHtcbiAge1xuICAgIGlmICghbmV4dFN0eWxlcykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBleHBhbmRlZFVwZGF0ZXMgPSBleHBhbmRTaG9ydGhhbmRNYXAoc3R5bGVVcGRhdGVzKTtcbiAgICB2YXIgZXhwYW5kZWRTdHlsZXMgPSBleHBhbmRTaG9ydGhhbmRNYXAobmV4dFN0eWxlcyk7XG4gICAgdmFyIHdhcm5lZEFib3V0ID0ge307XG5cbiAgICBmb3IgKHZhciBrZXkgaW4gZXhwYW5kZWRVcGRhdGVzKSB7XG4gICAgICB2YXIgb3JpZ2luYWxLZXkgPSBleHBhbmRlZFVwZGF0ZXNba2V5XTtcbiAgICAgIHZhciBjb3JyZWN0T3JpZ2luYWxLZXkgPSBleHBhbmRlZFN0eWxlc1trZXldO1xuXG4gICAgICBpZiAoY29ycmVjdE9yaWdpbmFsS2V5ICYmIG9yaWdpbmFsS2V5ICE9PSBjb3JyZWN0T3JpZ2luYWxLZXkpIHtcbiAgICAgICAgdmFyIHdhcm5pbmdLZXkgPSBvcmlnaW5hbEtleSArICcsJyArIGNvcnJlY3RPcmlnaW5hbEtleTtcblxuICAgICAgICBpZiAod2FybmVkQWJvdXRbd2FybmluZ0tleV0pIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHdhcm5lZEFib3V0W3dhcm5pbmdLZXldID0gdHJ1ZTtcblxuICAgICAgICBlcnJvcignJXMgYSBzdHlsZSBwcm9wZXJ0eSBkdXJpbmcgcmVyZW5kZXIgKCVzKSB3aGVuIGEgJyArICdjb25mbGljdGluZyBwcm9wZXJ0eSBpcyBzZXQgKCVzKSBjYW4gbGVhZCB0byBzdHlsaW5nIGJ1Z3MuIFRvICcgKyBcImF2b2lkIHRoaXMsIGRvbid0IG1peCBzaG9ydGhhbmQgYW5kIG5vbi1zaG9ydGhhbmQgcHJvcGVydGllcyBcIiArICdmb3IgdGhlIHNhbWUgdmFsdWU7IGluc3RlYWQsIHJlcGxhY2UgdGhlIHNob3J0aGFuZCB3aXRoICcgKyAnc2VwYXJhdGUgdmFsdWVzLicsIGlzVmFsdWVFbXB0eShzdHlsZVVwZGF0ZXNbb3JpZ2luYWxLZXldKSA/ICdSZW1vdmluZycgOiAnVXBkYXRpbmcnLCBvcmlnaW5hbEtleSwgY29ycmVjdE9yaWdpbmFsS2V5KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLy8gRm9yIEhUTUwsIGNlcnRhaW4gdGFncyBzaG91bGQgb21pdCB0aGVpciBjbG9zZSB0YWcuIFdlIGtlZXAgYSBsaXN0IGZvclxuLy8gdGhvc2Ugc3BlY2lhbC1jYXNlIHRhZ3MuXG52YXIgb21pdHRlZENsb3NlVGFncyA9IHtcbiAgYXJlYTogdHJ1ZSxcbiAgYmFzZTogdHJ1ZSxcbiAgYnI6IHRydWUsXG4gIGNvbDogdHJ1ZSxcbiAgZW1iZWQ6IHRydWUsXG4gIGhyOiB0cnVlLFxuICBpbWc6IHRydWUsXG4gIGlucHV0OiB0cnVlLFxuICBrZXlnZW46IHRydWUsXG4gIGxpbms6IHRydWUsXG4gIG1ldGE6IHRydWUsXG4gIHBhcmFtOiB0cnVlLFxuICBzb3VyY2U6IHRydWUsXG4gIHRyYWNrOiB0cnVlLFxuICB3YnI6IHRydWUgLy8gTk9URTogbWVudWl0ZW0ncyBjbG9zZSB0YWcgc2hvdWxkIGJlIG9taXR0ZWQsIGJ1dCB0aGF0IGNhdXNlcyBwcm9ibGVtcy5cblxufTtcblxuLy8gYG9taXR0ZWRDbG9zZVRhZ3NgIGV4Y2VwdCB0aGF0IGBtZW51aXRlbWAgc2hvdWxkIHN0aWxsIGhhdmUgaXRzIGNsb3NpbmcgdGFnLlxuXG52YXIgdm9pZEVsZW1lbnRUYWdzID0gX2Fzc2lnbih7XG4gIG1lbnVpdGVtOiB0cnVlXG59LCBvbWl0dGVkQ2xvc2VUYWdzKTtcblxudmFyIEhUTUwgPSAnX19odG1sJztcblxuZnVuY3Rpb24gYXNzZXJ0VmFsaWRQcm9wcyh0YWcsIHByb3BzKSB7XG4gIGlmICghcHJvcHMpIHtcbiAgICByZXR1cm47XG4gIH0gLy8gTm90ZSB0aGUgdXNlIG9mIGA9PWAgd2hpY2ggY2hlY2tzIGZvciBudWxsIG9yIHVuZGVmaW5lZC5cblxuXG4gIGlmICh2b2lkRWxlbWVudFRhZ3NbdGFnXSkge1xuICAgIGlmICghKHByb3BzLmNoaWxkcmVuID09IG51bGwgJiYgcHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwgPT0gbnVsbCkpIHtcbiAgICAgIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoIHRhZyArIFwiIGlzIGEgdm9pZCBlbGVtZW50IHRhZyBhbmQgbXVzdCBuZWl0aGVyIGhhdmUgYGNoaWxkcmVuYCBub3IgdXNlIGBkYW5nZXJvdXNseVNldElubmVySFRNTGAuXCIgKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAocHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwgIT0gbnVsbCkge1xuICAgIGlmICghKHByb3BzLmNoaWxkcmVuID09IG51bGwpKSB7XG4gICAgICB7XG4gICAgICAgIHRocm93IEVycm9yKCBcIkNhbiBvbmx5IHNldCBvbmUgb2YgYGNoaWxkcmVuYCBvciBgcHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxgLlwiICk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCEodHlwZW9mIHByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MID09PSAnb2JqZWN0JyAmJiBIVE1MIGluIHByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MKSkge1xuICAgICAge1xuICAgICAgICB0aHJvdyBFcnJvciggXCJgcHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxgIG11c3QgYmUgaW4gdGhlIGZvcm0gYHtfX2h0bWw6IC4uLn1gLiBQbGVhc2UgdmlzaXQgaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL2Rhbmdlcm91c2x5LXNldC1pbm5lci1odG1sIGZvciBtb3JlIGluZm9ybWF0aW9uLlwiICk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAge1xuICAgIGlmICghcHJvcHMuc3VwcHJlc3NDb250ZW50RWRpdGFibGVXYXJuaW5nICYmIHByb3BzLmNvbnRlbnRFZGl0YWJsZSAmJiBwcm9wcy5jaGlsZHJlbiAhPSBudWxsKSB7XG4gICAgICBlcnJvcignQSBjb21wb25lbnQgaXMgYGNvbnRlbnRFZGl0YWJsZWAgYW5kIGNvbnRhaW5zIGBjaGlsZHJlbmAgbWFuYWdlZCBieSAnICsgJ1JlYWN0LiBJdCBpcyBub3cgeW91ciByZXNwb25zaWJpbGl0eSB0byBndWFyYW50ZWUgdGhhdCBub25lIG9mICcgKyAndGhvc2Ugbm9kZXMgYXJlIHVuZXhwZWN0ZWRseSBtb2RpZmllZCBvciBkdXBsaWNhdGVkLiBUaGlzIGlzICcgKyAncHJvYmFibHkgbm90IGludGVudGlvbmFsLicpO1xuICAgIH1cbiAgfVxuXG4gIGlmICghKHByb3BzLnN0eWxlID09IG51bGwgfHwgdHlwZW9mIHByb3BzLnN0eWxlID09PSAnb2JqZWN0JykpIHtcbiAgICB7XG4gICAgICB0aHJvdyBFcnJvciggXCJUaGUgYHN0eWxlYCBwcm9wIGV4cGVjdHMgYSBtYXBwaW5nIGZyb20gc3R5bGUgcHJvcGVydGllcyB0byB2YWx1ZXMsIG5vdCBhIHN0cmluZy4gRm9yIGV4YW1wbGUsIHN0eWxlPXt7bWFyZ2luUmlnaHQ6IHNwYWNpbmcgKyAnZW0nfX0gd2hlbiB1c2luZyBKU1guXCIgKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNDdXN0b21Db21wb25lbnQodGFnTmFtZSwgcHJvcHMpIHtcbiAgaWYgKHRhZ05hbWUuaW5kZXhPZignLScpID09PSAtMSkge1xuICAgIHJldHVybiB0eXBlb2YgcHJvcHMuaXMgPT09ICdzdHJpbmcnO1xuICB9XG5cbiAgc3dpdGNoICh0YWdOYW1lKSB7XG4gICAgLy8gVGhlc2UgYXJlIHJlc2VydmVkIFNWRyBhbmQgTWF0aE1MIGVsZW1lbnRzLlxuICAgIC8vIFdlIGRvbid0IG1pbmQgdGhpcyBsaXN0IHRvbyBtdWNoIGJlY2F1c2Ugd2UgZXhwZWN0IGl0IHRvIG5ldmVyIGdyb3cuXG4gICAgLy8gVGhlIGFsdGVybmF0aXZlIGlzIHRvIHRyYWNrIHRoZSBuYW1lc3BhY2UgaW4gYSBmZXcgcGxhY2VzIHdoaWNoIGlzIGNvbnZvbHV0ZWQuXG4gICAgLy8gaHR0cHM6Ly93M2MuZ2l0aHViLmlvL3dlYmNvbXBvbmVudHMvc3BlYy9jdXN0b20vI2N1c3RvbS1lbGVtZW50cy1jb3JlLWNvbmNlcHRzXG4gICAgY2FzZSAnYW5ub3RhdGlvbi14bWwnOlxuICAgIGNhc2UgJ2NvbG9yLXByb2ZpbGUnOlxuICAgIGNhc2UgJ2ZvbnQtZmFjZSc6XG4gICAgY2FzZSAnZm9udC1mYWNlLXNyYyc6XG4gICAgY2FzZSAnZm9udC1mYWNlLXVyaSc6XG4gICAgY2FzZSAnZm9udC1mYWNlLWZvcm1hdCc6XG4gICAgY2FzZSAnZm9udC1mYWNlLW5hbWUnOlxuICAgIGNhc2UgJ21pc3NpbmctZ2x5cGgnOlxuICAgICAgcmV0dXJuIGZhbHNlO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiB0cnVlO1xuICB9XG59XG5cbi8vIFdoZW4gYWRkaW5nIGF0dHJpYnV0ZXMgdG8gdGhlIEhUTUwgb3IgU1ZHIGFsbG93ZWQgYXR0cmlidXRlIGxpc3QsIGJlIHN1cmUgdG9cbi8vIGFsc28gYWRkIHRoZW0gdG8gdGhpcyBtb2R1bGUgdG8gZW5zdXJlIGNhc2luZyBhbmQgaW5jb3JyZWN0IG5hbWVcbi8vIHdhcm5pbmdzLlxudmFyIHBvc3NpYmxlU3RhbmRhcmROYW1lcyA9IHtcbiAgLy8gSFRNTFxuICBhY2NlcHQ6ICdhY2NlcHQnLFxuICBhY2NlcHRjaGFyc2V0OiAnYWNjZXB0Q2hhcnNldCcsXG4gICdhY2NlcHQtY2hhcnNldCc6ICdhY2NlcHRDaGFyc2V0JyxcbiAgYWNjZXNza2V5OiAnYWNjZXNzS2V5JyxcbiAgYWN0aW9uOiAnYWN0aW9uJyxcbiAgYWxsb3dmdWxsc2NyZWVuOiAnYWxsb3dGdWxsU2NyZWVuJyxcbiAgYWx0OiAnYWx0JyxcbiAgYXM6ICdhcycsXG4gIGFzeW5jOiAnYXN5bmMnLFxuICBhdXRvY2FwaXRhbGl6ZTogJ2F1dG9DYXBpdGFsaXplJyxcbiAgYXV0b2NvbXBsZXRlOiAnYXV0b0NvbXBsZXRlJyxcbiAgYXV0b2NvcnJlY3Q6ICdhdXRvQ29ycmVjdCcsXG4gIGF1dG9mb2N1czogJ2F1dG9Gb2N1cycsXG4gIGF1dG9wbGF5OiAnYXV0b1BsYXknLFxuICBhdXRvc2F2ZTogJ2F1dG9TYXZlJyxcbiAgY2FwdHVyZTogJ2NhcHR1cmUnLFxuICBjZWxscGFkZGluZzogJ2NlbGxQYWRkaW5nJyxcbiAgY2VsbHNwYWNpbmc6ICdjZWxsU3BhY2luZycsXG4gIGNoYWxsZW5nZTogJ2NoYWxsZW5nZScsXG4gIGNoYXJzZXQ6ICdjaGFyU2V0JyxcbiAgY2hlY2tlZDogJ2NoZWNrZWQnLFxuICBjaGlsZHJlbjogJ2NoaWxkcmVuJyxcbiAgY2l0ZTogJ2NpdGUnLFxuICBjbGFzczogJ2NsYXNzTmFtZScsXG4gIGNsYXNzaWQ6ICdjbGFzc0lEJyxcbiAgY2xhc3NuYW1lOiAnY2xhc3NOYW1lJyxcbiAgY29sczogJ2NvbHMnLFxuICBjb2xzcGFuOiAnY29sU3BhbicsXG4gIGNvbnRlbnQ6ICdjb250ZW50JyxcbiAgY29udGVudGVkaXRhYmxlOiAnY29udGVudEVkaXRhYmxlJyxcbiAgY29udGV4dG1lbnU6ICdjb250ZXh0TWVudScsXG4gIGNvbnRyb2xzOiAnY29udHJvbHMnLFxuICBjb250cm9sc2xpc3Q6ICdjb250cm9sc0xpc3QnLFxuICBjb29yZHM6ICdjb29yZHMnLFxuICBjcm9zc29yaWdpbjogJ2Nyb3NzT3JpZ2luJyxcbiAgZGFuZ2Vyb3VzbHlzZXRpbm5lcmh0bWw6ICdkYW5nZXJvdXNseVNldElubmVySFRNTCcsXG4gIGRhdGE6ICdkYXRhJyxcbiAgZGF0ZXRpbWU6ICdkYXRlVGltZScsXG4gIGRlZmF1bHQ6ICdkZWZhdWx0JyxcbiAgZGVmYXVsdGNoZWNrZWQ6ICdkZWZhdWx0Q2hlY2tlZCcsXG4gIGRlZmF1bHR2YWx1ZTogJ2RlZmF1bHRWYWx1ZScsXG4gIGRlZmVyOiAnZGVmZXInLFxuICBkaXI6ICdkaXInLFxuICBkaXNhYmxlZDogJ2Rpc2FibGVkJyxcbiAgZGlzYWJsZXBpY3R1cmVpbnBpY3R1cmU6ICdkaXNhYmxlUGljdHVyZUluUGljdHVyZScsXG4gIGRpc2FibGVyZW1vdGVwbGF5YmFjazogJ2Rpc2FibGVSZW1vdGVQbGF5YmFjaycsXG4gIGRvd25sb2FkOiAnZG93bmxvYWQnLFxuICBkcmFnZ2FibGU6ICdkcmFnZ2FibGUnLFxuICBlbmN0eXBlOiAnZW5jVHlwZScsXG4gIGVudGVya2V5aGludDogJ2VudGVyS2V5SGludCcsXG4gIGZvcjogJ2h0bWxGb3InLFxuICBmb3JtOiAnZm9ybScsXG4gIGZvcm1tZXRob2Q6ICdmb3JtTWV0aG9kJyxcbiAgZm9ybWFjdGlvbjogJ2Zvcm1BY3Rpb24nLFxuICBmb3JtZW5jdHlwZTogJ2Zvcm1FbmNUeXBlJyxcbiAgZm9ybW5vdmFsaWRhdGU6ICdmb3JtTm9WYWxpZGF0ZScsXG4gIGZvcm10YXJnZXQ6ICdmb3JtVGFyZ2V0JyxcbiAgZnJhbWVib3JkZXI6ICdmcmFtZUJvcmRlcicsXG4gIGhlYWRlcnM6ICdoZWFkZXJzJyxcbiAgaGVpZ2h0OiAnaGVpZ2h0JyxcbiAgaGlkZGVuOiAnaGlkZGVuJyxcbiAgaGlnaDogJ2hpZ2gnLFxuICBocmVmOiAnaHJlZicsXG4gIGhyZWZsYW5nOiAnaHJlZkxhbmcnLFxuICBodG1sZm9yOiAnaHRtbEZvcicsXG4gIGh0dHBlcXVpdjogJ2h0dHBFcXVpdicsXG4gICdodHRwLWVxdWl2JzogJ2h0dHBFcXVpdicsXG4gIGljb246ICdpY29uJyxcbiAgaWQ6ICdpZCcsXG4gIGlubmVyaHRtbDogJ2lubmVySFRNTCcsXG4gIGlucHV0bW9kZTogJ2lucHV0TW9kZScsXG4gIGludGVncml0eTogJ2ludGVncml0eScsXG4gIGlzOiAnaXMnLFxuICBpdGVtaWQ6ICdpdGVtSUQnLFxuICBpdGVtcHJvcDogJ2l0ZW1Qcm9wJyxcbiAgaXRlbXJlZjogJ2l0ZW1SZWYnLFxuICBpdGVtc2NvcGU6ICdpdGVtU2NvcGUnLFxuICBpdGVtdHlwZTogJ2l0ZW1UeXBlJyxcbiAga2V5cGFyYW1zOiAna2V5UGFyYW1zJyxcbiAga2V5dHlwZTogJ2tleVR5cGUnLFxuICBraW5kOiAna2luZCcsXG4gIGxhYmVsOiAnbGFiZWwnLFxuICBsYW5nOiAnbGFuZycsXG4gIGxpc3Q6ICdsaXN0JyxcbiAgbG9vcDogJ2xvb3AnLFxuICBsb3c6ICdsb3cnLFxuICBtYW5pZmVzdDogJ21hbmlmZXN0JyxcbiAgbWFyZ2lud2lkdGg6ICdtYXJnaW5XaWR0aCcsXG4gIG1hcmdpbmhlaWdodDogJ21hcmdpbkhlaWdodCcsXG4gIG1heDogJ21heCcsXG4gIG1heGxlbmd0aDogJ21heExlbmd0aCcsXG4gIG1lZGlhOiAnbWVkaWEnLFxuICBtZWRpYWdyb3VwOiAnbWVkaWFHcm91cCcsXG4gIG1ldGhvZDogJ21ldGhvZCcsXG4gIG1pbjogJ21pbicsXG4gIG1pbmxlbmd0aDogJ21pbkxlbmd0aCcsXG4gIG11bHRpcGxlOiAnbXVsdGlwbGUnLFxuICBtdXRlZDogJ211dGVkJyxcbiAgbmFtZTogJ25hbWUnLFxuICBub21vZHVsZTogJ25vTW9kdWxlJyxcbiAgbm9uY2U6ICdub25jZScsXG4gIG5vdmFsaWRhdGU6ICdub1ZhbGlkYXRlJyxcbiAgb3BlbjogJ29wZW4nLFxuICBvcHRpbXVtOiAnb3B0aW11bScsXG4gIHBhdHRlcm46ICdwYXR0ZXJuJyxcbiAgcGxhY2Vob2xkZXI6ICdwbGFjZWhvbGRlcicsXG4gIHBsYXlzaW5saW5lOiAncGxheXNJbmxpbmUnLFxuICBwb3N0ZXI6ICdwb3N0ZXInLFxuICBwcmVsb2FkOiAncHJlbG9hZCcsXG4gIHByb2ZpbGU6ICdwcm9maWxlJyxcbiAgcmFkaW9ncm91cDogJ3JhZGlvR3JvdXAnLFxuICByZWFkb25seTogJ3JlYWRPbmx5JyxcbiAgcmVmZXJyZXJwb2xpY3k6ICdyZWZlcnJlclBvbGljeScsXG4gIHJlbDogJ3JlbCcsXG4gIHJlcXVpcmVkOiAncmVxdWlyZWQnLFxuICByZXZlcnNlZDogJ3JldmVyc2VkJyxcbiAgcm9sZTogJ3JvbGUnLFxuICByb3dzOiAncm93cycsXG4gIHJvd3NwYW46ICdyb3dTcGFuJyxcbiAgc2FuZGJveDogJ3NhbmRib3gnLFxuICBzY29wZTogJ3Njb3BlJyxcbiAgc2NvcGVkOiAnc2NvcGVkJyxcbiAgc2Nyb2xsaW5nOiAnc2Nyb2xsaW5nJyxcbiAgc2VhbWxlc3M6ICdzZWFtbGVzcycsXG4gIHNlbGVjdGVkOiAnc2VsZWN0ZWQnLFxuICBzaGFwZTogJ3NoYXBlJyxcbiAgc2l6ZTogJ3NpemUnLFxuICBzaXplczogJ3NpemVzJyxcbiAgc3BhbjogJ3NwYW4nLFxuICBzcGVsbGNoZWNrOiAnc3BlbGxDaGVjaycsXG4gIHNyYzogJ3NyYycsXG4gIHNyY2RvYzogJ3NyY0RvYycsXG4gIHNyY2xhbmc6ICdzcmNMYW5nJyxcbiAgc3Jjc2V0OiAnc3JjU2V0JyxcbiAgc3RhcnQ6ICdzdGFydCcsXG4gIHN0ZXA6ICdzdGVwJyxcbiAgc3R5bGU6ICdzdHlsZScsXG4gIHN1bW1hcnk6ICdzdW1tYXJ5JyxcbiAgdGFiaW5kZXg6ICd0YWJJbmRleCcsXG4gIHRhcmdldDogJ3RhcmdldCcsXG4gIHRpdGxlOiAndGl0bGUnLFxuICB0eXBlOiAndHlwZScsXG4gIHVzZW1hcDogJ3VzZU1hcCcsXG4gIHZhbHVlOiAndmFsdWUnLFxuICB3aWR0aDogJ3dpZHRoJyxcbiAgd21vZGU6ICd3bW9kZScsXG4gIHdyYXA6ICd3cmFwJyxcbiAgLy8gU1ZHXG4gIGFib3V0OiAnYWJvdXQnLFxuICBhY2NlbnRoZWlnaHQ6ICdhY2NlbnRIZWlnaHQnLFxuICAnYWNjZW50LWhlaWdodCc6ICdhY2NlbnRIZWlnaHQnLFxuICBhY2N1bXVsYXRlOiAnYWNjdW11bGF0ZScsXG4gIGFkZGl0aXZlOiAnYWRkaXRpdmUnLFxuICBhbGlnbm1lbnRiYXNlbGluZTogJ2FsaWdubWVudEJhc2VsaW5lJyxcbiAgJ2FsaWdubWVudC1iYXNlbGluZSc6ICdhbGlnbm1lbnRCYXNlbGluZScsXG4gIGFsbG93cmVvcmRlcjogJ2FsbG93UmVvcmRlcicsXG4gIGFscGhhYmV0aWM6ICdhbHBoYWJldGljJyxcbiAgYW1wbGl0dWRlOiAnYW1wbGl0dWRlJyxcbiAgYXJhYmljZm9ybTogJ2FyYWJpY0Zvcm0nLFxuICAnYXJhYmljLWZvcm0nOiAnYXJhYmljRm9ybScsXG4gIGFzY2VudDogJ2FzY2VudCcsXG4gIGF0dHJpYnV0ZW5hbWU6ICdhdHRyaWJ1dGVOYW1lJyxcbiAgYXR0cmlidXRldHlwZTogJ2F0dHJpYnV0ZVR5cGUnLFxuICBhdXRvcmV2ZXJzZTogJ2F1dG9SZXZlcnNlJyxcbiAgYXppbXV0aDogJ2F6aW11dGgnLFxuICBiYXNlZnJlcXVlbmN5OiAnYmFzZUZyZXF1ZW5jeScsXG4gIGJhc2VsaW5lc2hpZnQ6ICdiYXNlbGluZVNoaWZ0JyxcbiAgJ2Jhc2VsaW5lLXNoaWZ0JzogJ2Jhc2VsaW5lU2hpZnQnLFxuICBiYXNlcHJvZmlsZTogJ2Jhc2VQcm9maWxlJyxcbiAgYmJveDogJ2Jib3gnLFxuICBiZWdpbjogJ2JlZ2luJyxcbiAgYmlhczogJ2JpYXMnLFxuICBieTogJ2J5JyxcbiAgY2FsY21vZGU6ICdjYWxjTW9kZScsXG4gIGNhcGhlaWdodDogJ2NhcEhlaWdodCcsXG4gICdjYXAtaGVpZ2h0JzogJ2NhcEhlaWdodCcsXG4gIGNsaXA6ICdjbGlwJyxcbiAgY2xpcHBhdGg6ICdjbGlwUGF0aCcsXG4gICdjbGlwLXBhdGgnOiAnY2xpcFBhdGgnLFxuICBjbGlwcGF0aHVuaXRzOiAnY2xpcFBhdGhVbml0cycsXG4gIGNsaXBydWxlOiAnY2xpcFJ1bGUnLFxuICAnY2xpcC1ydWxlJzogJ2NsaXBSdWxlJyxcbiAgY29sb3I6ICdjb2xvcicsXG4gIGNvbG9yaW50ZXJwb2xhdGlvbjogJ2NvbG9ySW50ZXJwb2xhdGlvbicsXG4gICdjb2xvci1pbnRlcnBvbGF0aW9uJzogJ2NvbG9ySW50ZXJwb2xhdGlvbicsXG4gIGNvbG9yaW50ZXJwb2xhdGlvbmZpbHRlcnM6ICdjb2xvckludGVycG9sYXRpb25GaWx0ZXJzJyxcbiAgJ2NvbG9yLWludGVycG9sYXRpb24tZmlsdGVycyc6ICdjb2xvckludGVycG9sYXRpb25GaWx0ZXJzJyxcbiAgY29sb3Jwcm9maWxlOiAnY29sb3JQcm9maWxlJyxcbiAgJ2NvbG9yLXByb2ZpbGUnOiAnY29sb3JQcm9maWxlJyxcbiAgY29sb3JyZW5kZXJpbmc6ICdjb2xvclJlbmRlcmluZycsXG4gICdjb2xvci1yZW5kZXJpbmcnOiAnY29sb3JSZW5kZXJpbmcnLFxuICBjb250ZW50c2NyaXB0dHlwZTogJ2NvbnRlbnRTY3JpcHRUeXBlJyxcbiAgY29udGVudHN0eWxldHlwZTogJ2NvbnRlbnRTdHlsZVR5cGUnLFxuICBjdXJzb3I6ICdjdXJzb3InLFxuICBjeDogJ2N4JyxcbiAgY3k6ICdjeScsXG4gIGQ6ICdkJyxcbiAgZGF0YXR5cGU6ICdkYXRhdHlwZScsXG4gIGRlY2VsZXJhdGU6ICdkZWNlbGVyYXRlJyxcbiAgZGVzY2VudDogJ2Rlc2NlbnQnLFxuICBkaWZmdXNlY29uc3RhbnQ6ICdkaWZmdXNlQ29uc3RhbnQnLFxuICBkaXJlY3Rpb246ICdkaXJlY3Rpb24nLFxuICBkaXNwbGF5OiAnZGlzcGxheScsXG4gIGRpdmlzb3I6ICdkaXZpc29yJyxcbiAgZG9taW5hbnRiYXNlbGluZTogJ2RvbWluYW50QmFzZWxpbmUnLFxuICAnZG9taW5hbnQtYmFzZWxpbmUnOiAnZG9taW5hbnRCYXNlbGluZScsXG4gIGR1cjogJ2R1cicsXG4gIGR4OiAnZHgnLFxuICBkeTogJ2R5JyxcbiAgZWRnZW1vZGU6ICdlZGdlTW9kZScsXG4gIGVsZXZhdGlvbjogJ2VsZXZhdGlvbicsXG4gIGVuYWJsZWJhY2tncm91bmQ6ICdlbmFibGVCYWNrZ3JvdW5kJyxcbiAgJ2VuYWJsZS1iYWNrZ3JvdW5kJzogJ2VuYWJsZUJhY2tncm91bmQnLFxuICBlbmQ6ICdlbmQnLFxuICBleHBvbmVudDogJ2V4cG9uZW50JyxcbiAgZXh0ZXJuYWxyZXNvdXJjZXNyZXF1aXJlZDogJ2V4dGVybmFsUmVzb3VyY2VzUmVxdWlyZWQnLFxuICBmaWxsOiAnZmlsbCcsXG4gIGZpbGxvcGFjaXR5OiAnZmlsbE9wYWNpdHknLFxuICAnZmlsbC1vcGFjaXR5JzogJ2ZpbGxPcGFjaXR5JyxcbiAgZmlsbHJ1bGU6ICdmaWxsUnVsZScsXG4gICdmaWxsLXJ1bGUnOiAnZmlsbFJ1bGUnLFxuICBmaWx0ZXI6ICdmaWx0ZXInLFxuICBmaWx0ZXJyZXM6ICdmaWx0ZXJSZXMnLFxuICBmaWx0ZXJ1bml0czogJ2ZpbHRlclVuaXRzJyxcbiAgZmxvb2RvcGFjaXR5OiAnZmxvb2RPcGFjaXR5JyxcbiAgJ2Zsb29kLW9wYWNpdHknOiAnZmxvb2RPcGFjaXR5JyxcbiAgZmxvb2Rjb2xvcjogJ2Zsb29kQ29sb3InLFxuICAnZmxvb2QtY29sb3InOiAnZmxvb2RDb2xvcicsXG4gIGZvY3VzYWJsZTogJ2ZvY3VzYWJsZScsXG4gIGZvbnRmYW1pbHk6ICdmb250RmFtaWx5JyxcbiAgJ2ZvbnQtZmFtaWx5JzogJ2ZvbnRGYW1pbHknLFxuICBmb250c2l6ZTogJ2ZvbnRTaXplJyxcbiAgJ2ZvbnQtc2l6ZSc6ICdmb250U2l6ZScsXG4gIGZvbnRzaXplYWRqdXN0OiAnZm9udFNpemVBZGp1c3QnLFxuICAnZm9udC1zaXplLWFkanVzdCc6ICdmb250U2l6ZUFkanVzdCcsXG4gIGZvbnRzdHJldGNoOiAnZm9udFN0cmV0Y2gnLFxuICAnZm9udC1zdHJldGNoJzogJ2ZvbnRTdHJldGNoJyxcbiAgZm9udHN0eWxlOiAnZm9udFN0eWxlJyxcbiAgJ2ZvbnQtc3R5bGUnOiAnZm9udFN0eWxlJyxcbiAgZm9udHZhcmlhbnQ6ICdmb250VmFyaWFudCcsXG4gICdmb250LXZhcmlhbnQnOiAnZm9udFZhcmlhbnQnLFxuICBmb250d2VpZ2h0OiAnZm9udFdlaWdodCcsXG4gICdmb250LXdlaWdodCc6ICdmb250V2VpZ2h0JyxcbiAgZm9ybWF0OiAnZm9ybWF0JyxcbiAgZnJvbTogJ2Zyb20nLFxuICBmeDogJ2Z4JyxcbiAgZnk6ICdmeScsXG4gIGcxOiAnZzEnLFxuICBnMjogJ2cyJyxcbiAgZ2x5cGhuYW1lOiAnZ2x5cGhOYW1lJyxcbiAgJ2dseXBoLW5hbWUnOiAnZ2x5cGhOYW1lJyxcbiAgZ2x5cGhvcmllbnRhdGlvbmhvcml6b250YWw6ICdnbHlwaE9yaWVudGF0aW9uSG9yaXpvbnRhbCcsXG4gICdnbHlwaC1vcmllbnRhdGlvbi1ob3Jpem9udGFsJzogJ2dseXBoT3JpZW50YXRpb25Ib3Jpem9udGFsJyxcbiAgZ2x5cGhvcmllbnRhdGlvbnZlcnRpY2FsOiAnZ2x5cGhPcmllbnRhdGlvblZlcnRpY2FsJyxcbiAgJ2dseXBoLW9yaWVudGF0aW9uLXZlcnRpY2FsJzogJ2dseXBoT3JpZW50YXRpb25WZXJ0aWNhbCcsXG4gIGdseXBocmVmOiAnZ2x5cGhSZWYnLFxuICBncmFkaWVudHRyYW5zZm9ybTogJ2dyYWRpZW50VHJhbnNmb3JtJyxcbiAgZ3JhZGllbnR1bml0czogJ2dyYWRpZW50VW5pdHMnLFxuICBoYW5naW5nOiAnaGFuZ2luZycsXG4gIGhvcml6YWR2eDogJ2hvcml6QWR2WCcsXG4gICdob3Jpei1hZHYteCc6ICdob3JpekFkdlgnLFxuICBob3Jpem9yaWdpbng6ICdob3Jpek9yaWdpblgnLFxuICAnaG9yaXotb3JpZ2luLXgnOiAnaG9yaXpPcmlnaW5YJyxcbiAgaWRlb2dyYXBoaWM6ICdpZGVvZ3JhcGhpYycsXG4gIGltYWdlcmVuZGVyaW5nOiAnaW1hZ2VSZW5kZXJpbmcnLFxuICAnaW1hZ2UtcmVuZGVyaW5nJzogJ2ltYWdlUmVuZGVyaW5nJyxcbiAgaW4yOiAnaW4yJyxcbiAgaW46ICdpbicsXG4gIGlubGlzdDogJ2lubGlzdCcsXG4gIGludGVyY2VwdDogJ2ludGVyY2VwdCcsXG4gIGsxOiAnazEnLFxuICBrMjogJ2syJyxcbiAgazM6ICdrMycsXG4gIGs0OiAnazQnLFxuICBrOiAnaycsXG4gIGtlcm5lbG1hdHJpeDogJ2tlcm5lbE1hdHJpeCcsXG4gIGtlcm5lbHVuaXRsZW5ndGg6ICdrZXJuZWxVbml0TGVuZ3RoJyxcbiAga2VybmluZzogJ2tlcm5pbmcnLFxuICBrZXlwb2ludHM6ICdrZXlQb2ludHMnLFxuICBrZXlzcGxpbmVzOiAna2V5U3BsaW5lcycsXG4gIGtleXRpbWVzOiAna2V5VGltZXMnLFxuICBsZW5ndGhhZGp1c3Q6ICdsZW5ndGhBZGp1c3QnLFxuICBsZXR0ZXJzcGFjaW5nOiAnbGV0dGVyU3BhY2luZycsXG4gICdsZXR0ZXItc3BhY2luZyc6ICdsZXR0ZXJTcGFjaW5nJyxcbiAgbGlnaHRpbmdjb2xvcjogJ2xpZ2h0aW5nQ29sb3InLFxuICAnbGlnaHRpbmctY29sb3InOiAnbGlnaHRpbmdDb2xvcicsXG4gIGxpbWl0aW5nY29uZWFuZ2xlOiAnbGltaXRpbmdDb25lQW5nbGUnLFxuICBsb2NhbDogJ2xvY2FsJyxcbiAgbWFya2VyZW5kOiAnbWFya2VyRW5kJyxcbiAgJ21hcmtlci1lbmQnOiAnbWFya2VyRW5kJyxcbiAgbWFya2VyaGVpZ2h0OiAnbWFya2VySGVpZ2h0JyxcbiAgbWFya2VybWlkOiAnbWFya2VyTWlkJyxcbiAgJ21hcmtlci1taWQnOiAnbWFya2VyTWlkJyxcbiAgbWFya2Vyc3RhcnQ6ICdtYXJrZXJTdGFydCcsXG4gICdtYXJrZXItc3RhcnQnOiAnbWFya2VyU3RhcnQnLFxuICBtYXJrZXJ1bml0czogJ21hcmtlclVuaXRzJyxcbiAgbWFya2Vyd2lkdGg6ICdtYXJrZXJXaWR0aCcsXG4gIG1hc2s6ICdtYXNrJyxcbiAgbWFza2NvbnRlbnR1bml0czogJ21hc2tDb250ZW50VW5pdHMnLFxuICBtYXNrdW5pdHM6ICdtYXNrVW5pdHMnLFxuICBtYXRoZW1hdGljYWw6ICdtYXRoZW1hdGljYWwnLFxuICBtb2RlOiAnbW9kZScsXG4gIG51bW9jdGF2ZXM6ICdudW1PY3RhdmVzJyxcbiAgb2Zmc2V0OiAnb2Zmc2V0JyxcbiAgb3BhY2l0eTogJ29wYWNpdHknLFxuICBvcGVyYXRvcjogJ29wZXJhdG9yJyxcbiAgb3JkZXI6ICdvcmRlcicsXG4gIG9yaWVudDogJ29yaWVudCcsXG4gIG9yaWVudGF0aW9uOiAnb3JpZW50YXRpb24nLFxuICBvcmlnaW46ICdvcmlnaW4nLFxuICBvdmVyZmxvdzogJ292ZXJmbG93JyxcbiAgb3ZlcmxpbmVwb3NpdGlvbjogJ292ZXJsaW5lUG9zaXRpb24nLFxuICAnb3ZlcmxpbmUtcG9zaXRpb24nOiAnb3ZlcmxpbmVQb3NpdGlvbicsXG4gIG92ZXJsaW5ldGhpY2tuZXNzOiAnb3ZlcmxpbmVUaGlja25lc3MnLFxuICAnb3ZlcmxpbmUtdGhpY2tuZXNzJzogJ292ZXJsaW5lVGhpY2tuZXNzJyxcbiAgcGFpbnRvcmRlcjogJ3BhaW50T3JkZXInLFxuICAncGFpbnQtb3JkZXInOiAncGFpbnRPcmRlcicsXG4gIHBhbm9zZTE6ICdwYW5vc2UxJyxcbiAgJ3Bhbm9zZS0xJzogJ3Bhbm9zZTEnLFxuICBwYXRobGVuZ3RoOiAncGF0aExlbmd0aCcsXG4gIHBhdHRlcm5jb250ZW50dW5pdHM6ICdwYXR0ZXJuQ29udGVudFVuaXRzJyxcbiAgcGF0dGVybnRyYW5zZm9ybTogJ3BhdHRlcm5UcmFuc2Zvcm0nLFxuICBwYXR0ZXJudW5pdHM6ICdwYXR0ZXJuVW5pdHMnLFxuICBwb2ludGVyZXZlbnRzOiAncG9pbnRlckV2ZW50cycsXG4gICdwb2ludGVyLWV2ZW50cyc6ICdwb2ludGVyRXZlbnRzJyxcbiAgcG9pbnRzOiAncG9pbnRzJyxcbiAgcG9pbnRzYXR4OiAncG9pbnRzQXRYJyxcbiAgcG9pbnRzYXR5OiAncG9pbnRzQXRZJyxcbiAgcG9pbnRzYXR6OiAncG9pbnRzQXRaJyxcbiAgcHJlZml4OiAncHJlZml4JyxcbiAgcHJlc2VydmVhbHBoYTogJ3ByZXNlcnZlQWxwaGEnLFxuICBwcmVzZXJ2ZWFzcGVjdHJhdGlvOiAncHJlc2VydmVBc3BlY3RSYXRpbycsXG4gIHByaW1pdGl2ZXVuaXRzOiAncHJpbWl0aXZlVW5pdHMnLFxuICBwcm9wZXJ0eTogJ3Byb3BlcnR5JyxcbiAgcjogJ3InLFxuICByYWRpdXM6ICdyYWRpdXMnLFxuICByZWZ4OiAncmVmWCcsXG4gIHJlZnk6ICdyZWZZJyxcbiAgcmVuZGVyaW5naW50ZW50OiAncmVuZGVyaW5nSW50ZW50JyxcbiAgJ3JlbmRlcmluZy1pbnRlbnQnOiAncmVuZGVyaW5nSW50ZW50JyxcbiAgcmVwZWF0Y291bnQ6ICdyZXBlYXRDb3VudCcsXG4gIHJlcGVhdGR1cjogJ3JlcGVhdER1cicsXG4gIHJlcXVpcmVkZXh0ZW5zaW9uczogJ3JlcXVpcmVkRXh0ZW5zaW9ucycsXG4gIHJlcXVpcmVkZmVhdHVyZXM6ICdyZXF1aXJlZEZlYXR1cmVzJyxcbiAgcmVzb3VyY2U6ICdyZXNvdXJjZScsXG4gIHJlc3RhcnQ6ICdyZXN0YXJ0JyxcbiAgcmVzdWx0OiAncmVzdWx0JyxcbiAgcmVzdWx0czogJ3Jlc3VsdHMnLFxuICByb3RhdGU6ICdyb3RhdGUnLFxuICByeDogJ3J4JyxcbiAgcnk6ICdyeScsXG4gIHNjYWxlOiAnc2NhbGUnLFxuICBzZWN1cml0eTogJ3NlY3VyaXR5JyxcbiAgc2VlZDogJ3NlZWQnLFxuICBzaGFwZXJlbmRlcmluZzogJ3NoYXBlUmVuZGVyaW5nJyxcbiAgJ3NoYXBlLXJlbmRlcmluZyc6ICdzaGFwZVJlbmRlcmluZycsXG4gIHNsb3BlOiAnc2xvcGUnLFxuICBzcGFjaW5nOiAnc3BhY2luZycsXG4gIHNwZWN1bGFyY29uc3RhbnQ6ICdzcGVjdWxhckNvbnN0YW50JyxcbiAgc3BlY3VsYXJleHBvbmVudDogJ3NwZWN1bGFyRXhwb25lbnQnLFxuICBzcGVlZDogJ3NwZWVkJyxcbiAgc3ByZWFkbWV0aG9kOiAnc3ByZWFkTWV0aG9kJyxcbiAgc3RhcnRvZmZzZXQ6ICdzdGFydE9mZnNldCcsXG4gIHN0ZGRldmlhdGlvbjogJ3N0ZERldmlhdGlvbicsXG4gIHN0ZW1oOiAnc3RlbWgnLFxuICBzdGVtdjogJ3N0ZW12JyxcbiAgc3RpdGNodGlsZXM6ICdzdGl0Y2hUaWxlcycsXG4gIHN0b3Bjb2xvcjogJ3N0b3BDb2xvcicsXG4gICdzdG9wLWNvbG9yJzogJ3N0b3BDb2xvcicsXG4gIHN0b3BvcGFjaXR5OiAnc3RvcE9wYWNpdHknLFxuICAnc3RvcC1vcGFjaXR5JzogJ3N0b3BPcGFjaXR5JyxcbiAgc3RyaWtldGhyb3VnaHBvc2l0aW9uOiAnc3RyaWtldGhyb3VnaFBvc2l0aW9uJyxcbiAgJ3N0cmlrZXRocm91Z2gtcG9zaXRpb24nOiAnc3RyaWtldGhyb3VnaFBvc2l0aW9uJyxcbiAgc3RyaWtldGhyb3VnaHRoaWNrbmVzczogJ3N0cmlrZXRocm91Z2hUaGlja25lc3MnLFxuICAnc3RyaWtldGhyb3VnaC10aGlja25lc3MnOiAnc3RyaWtldGhyb3VnaFRoaWNrbmVzcycsXG4gIHN0cmluZzogJ3N0cmluZycsXG4gIHN0cm9rZTogJ3N0cm9rZScsXG4gIHN0cm9rZWRhc2hhcnJheTogJ3N0cm9rZURhc2hhcnJheScsXG4gICdzdHJva2UtZGFzaGFycmF5JzogJ3N0cm9rZURhc2hhcnJheScsXG4gIHN0cm9rZWRhc2hvZmZzZXQ6ICdzdHJva2VEYXNob2Zmc2V0JyxcbiAgJ3N0cm9rZS1kYXNob2Zmc2V0JzogJ3N0cm9rZURhc2hvZmZzZXQnLFxuICBzdHJva2VsaW5lY2FwOiAnc3Ryb2tlTGluZWNhcCcsXG4gICdzdHJva2UtbGluZWNhcCc6ICdzdHJva2VMaW5lY2FwJyxcbiAgc3Ryb2tlbGluZWpvaW46ICdzdHJva2VMaW5lam9pbicsXG4gICdzdHJva2UtbGluZWpvaW4nOiAnc3Ryb2tlTGluZWpvaW4nLFxuICBzdHJva2VtaXRlcmxpbWl0OiAnc3Ryb2tlTWl0ZXJsaW1pdCcsXG4gICdzdHJva2UtbWl0ZXJsaW1pdCc6ICdzdHJva2VNaXRlcmxpbWl0JyxcbiAgc3Ryb2tld2lkdGg6ICdzdHJva2VXaWR0aCcsXG4gICdzdHJva2Utd2lkdGgnOiAnc3Ryb2tlV2lkdGgnLFxuICBzdHJva2VvcGFjaXR5OiAnc3Ryb2tlT3BhY2l0eScsXG4gICdzdHJva2Utb3BhY2l0eSc6ICdzdHJva2VPcGFjaXR5JyxcbiAgc3VwcHJlc3Njb250ZW50ZWRpdGFibGV3YXJuaW5nOiAnc3VwcHJlc3NDb250ZW50RWRpdGFibGVXYXJuaW5nJyxcbiAgc3VwcHJlc3NoeWRyYXRpb253YXJuaW5nOiAnc3VwcHJlc3NIeWRyYXRpb25XYXJuaW5nJyxcbiAgc3VyZmFjZXNjYWxlOiAnc3VyZmFjZVNjYWxlJyxcbiAgc3lzdGVtbGFuZ3VhZ2U6ICdzeXN0ZW1MYW5ndWFnZScsXG4gIHRhYmxldmFsdWVzOiAndGFibGVWYWx1ZXMnLFxuICB0YXJnZXR4OiAndGFyZ2V0WCcsXG4gIHRhcmdldHk6ICd0YXJnZXRZJyxcbiAgdGV4dGFuY2hvcjogJ3RleHRBbmNob3InLFxuICAndGV4dC1hbmNob3InOiAndGV4dEFuY2hvcicsXG4gIHRleHRkZWNvcmF0aW9uOiAndGV4dERlY29yYXRpb24nLFxuICAndGV4dC1kZWNvcmF0aW9uJzogJ3RleHREZWNvcmF0aW9uJyxcbiAgdGV4dGxlbmd0aDogJ3RleHRMZW5ndGgnLFxuICB0ZXh0cmVuZGVyaW5nOiAndGV4dFJlbmRlcmluZycsXG4gICd0ZXh0LXJlbmRlcmluZyc6ICd0ZXh0UmVuZGVyaW5nJyxcbiAgdG86ICd0bycsXG4gIHRyYW5zZm9ybTogJ3RyYW5zZm9ybScsXG4gIHR5cGVvZjogJ3R5cGVvZicsXG4gIHUxOiAndTEnLFxuICB1MjogJ3UyJyxcbiAgdW5kZXJsaW5lcG9zaXRpb246ICd1bmRlcmxpbmVQb3NpdGlvbicsXG4gICd1bmRlcmxpbmUtcG9zaXRpb24nOiAndW5kZXJsaW5lUG9zaXRpb24nLFxuICB1bmRlcmxpbmV0aGlja25lc3M6ICd1bmRlcmxpbmVUaGlja25lc3MnLFxuICAndW5kZXJsaW5lLXRoaWNrbmVzcyc6ICd1bmRlcmxpbmVUaGlja25lc3MnLFxuICB1bmljb2RlOiAndW5pY29kZScsXG4gIHVuaWNvZGViaWRpOiAndW5pY29kZUJpZGknLFxuICAndW5pY29kZS1iaWRpJzogJ3VuaWNvZGVCaWRpJyxcbiAgdW5pY29kZXJhbmdlOiAndW5pY29kZVJhbmdlJyxcbiAgJ3VuaWNvZGUtcmFuZ2UnOiAndW5pY29kZVJhbmdlJyxcbiAgdW5pdHNwZXJlbTogJ3VuaXRzUGVyRW0nLFxuICAndW5pdHMtcGVyLWVtJzogJ3VuaXRzUGVyRW0nLFxuICB1bnNlbGVjdGFibGU6ICd1bnNlbGVjdGFibGUnLFxuICB2YWxwaGFiZXRpYzogJ3ZBbHBoYWJldGljJyxcbiAgJ3YtYWxwaGFiZXRpYyc6ICd2QWxwaGFiZXRpYycsXG4gIHZhbHVlczogJ3ZhbHVlcycsXG4gIHZlY3RvcmVmZmVjdDogJ3ZlY3RvckVmZmVjdCcsXG4gICd2ZWN0b3ItZWZmZWN0JzogJ3ZlY3RvckVmZmVjdCcsXG4gIHZlcnNpb246ICd2ZXJzaW9uJyxcbiAgdmVydGFkdnk6ICd2ZXJ0QWR2WScsXG4gICd2ZXJ0LWFkdi15JzogJ3ZlcnRBZHZZJyxcbiAgdmVydG9yaWdpbng6ICd2ZXJ0T3JpZ2luWCcsXG4gICd2ZXJ0LW9yaWdpbi14JzogJ3ZlcnRPcmlnaW5YJyxcbiAgdmVydG9yaWdpbnk6ICd2ZXJ0T3JpZ2luWScsXG4gICd2ZXJ0LW9yaWdpbi15JzogJ3ZlcnRPcmlnaW5ZJyxcbiAgdmhhbmdpbmc6ICd2SGFuZ2luZycsXG4gICd2LWhhbmdpbmcnOiAndkhhbmdpbmcnLFxuICB2aWRlb2dyYXBoaWM6ICd2SWRlb2dyYXBoaWMnLFxuICAndi1pZGVvZ3JhcGhpYyc6ICd2SWRlb2dyYXBoaWMnLFxuICB2aWV3Ym94OiAndmlld0JveCcsXG4gIHZpZXd0YXJnZXQ6ICd2aWV3VGFyZ2V0JyxcbiAgdmlzaWJpbGl0eTogJ3Zpc2liaWxpdHknLFxuICB2bWF0aGVtYXRpY2FsOiAndk1hdGhlbWF0aWNhbCcsXG4gICd2LW1hdGhlbWF0aWNhbCc6ICd2TWF0aGVtYXRpY2FsJyxcbiAgdm9jYWI6ICd2b2NhYicsXG4gIHdpZHRoczogJ3dpZHRocycsXG4gIHdvcmRzcGFjaW5nOiAnd29yZFNwYWNpbmcnLFxuICAnd29yZC1zcGFjaW5nJzogJ3dvcmRTcGFjaW5nJyxcbiAgd3JpdGluZ21vZGU6ICd3cml0aW5nTW9kZScsXG4gICd3cml0aW5nLW1vZGUnOiAnd3JpdGluZ01vZGUnLFxuICB4MTogJ3gxJyxcbiAgeDI6ICd4MicsXG4gIHg6ICd4JyxcbiAgeGNoYW5uZWxzZWxlY3RvcjogJ3hDaGFubmVsU2VsZWN0b3InLFxuICB4aGVpZ2h0OiAneEhlaWdodCcsXG4gICd4LWhlaWdodCc6ICd4SGVpZ2h0JyxcbiAgeGxpbmthY3R1YXRlOiAneGxpbmtBY3R1YXRlJyxcbiAgJ3hsaW5rOmFjdHVhdGUnOiAneGxpbmtBY3R1YXRlJyxcbiAgeGxpbmthcmNyb2xlOiAneGxpbmtBcmNyb2xlJyxcbiAgJ3hsaW5rOmFyY3JvbGUnOiAneGxpbmtBcmNyb2xlJyxcbiAgeGxpbmtocmVmOiAneGxpbmtIcmVmJyxcbiAgJ3hsaW5rOmhyZWYnOiAneGxpbmtIcmVmJyxcbiAgeGxpbmtyb2xlOiAneGxpbmtSb2xlJyxcbiAgJ3hsaW5rOnJvbGUnOiAneGxpbmtSb2xlJyxcbiAgeGxpbmtzaG93OiAneGxpbmtTaG93JyxcbiAgJ3hsaW5rOnNob3cnOiAneGxpbmtTaG93JyxcbiAgeGxpbmt0aXRsZTogJ3hsaW5rVGl0bGUnLFxuICAneGxpbms6dGl0bGUnOiAneGxpbmtUaXRsZScsXG4gIHhsaW5rdHlwZTogJ3hsaW5rVHlwZScsXG4gICd4bGluazp0eXBlJzogJ3hsaW5rVHlwZScsXG4gIHhtbGJhc2U6ICd4bWxCYXNlJyxcbiAgJ3htbDpiYXNlJzogJ3htbEJhc2UnLFxuICB4bWxsYW5nOiAneG1sTGFuZycsXG4gICd4bWw6bGFuZyc6ICd4bWxMYW5nJyxcbiAgeG1sbnM6ICd4bWxucycsXG4gICd4bWw6c3BhY2UnOiAneG1sU3BhY2UnLFxuICB4bWxuc3hsaW5rOiAneG1sbnNYbGluaycsXG4gICd4bWxuczp4bGluayc6ICd4bWxuc1hsaW5rJyxcbiAgeG1sc3BhY2U6ICd4bWxTcGFjZScsXG4gIHkxOiAneTEnLFxuICB5MjogJ3kyJyxcbiAgeTogJ3knLFxuICB5Y2hhbm5lbHNlbGVjdG9yOiAneUNoYW5uZWxTZWxlY3RvcicsXG4gIHo6ICd6JyxcbiAgem9vbWFuZHBhbjogJ3pvb21BbmRQYW4nXG59O1xuXG52YXIgYXJpYVByb3BlcnRpZXMgPSB7XG4gICdhcmlhLWN1cnJlbnQnOiAwLFxuICAvLyBzdGF0ZVxuICAnYXJpYS1kZXRhaWxzJzogMCxcbiAgJ2FyaWEtZGlzYWJsZWQnOiAwLFxuICAvLyBzdGF0ZVxuICAnYXJpYS1oaWRkZW4nOiAwLFxuICAvLyBzdGF0ZVxuICAnYXJpYS1pbnZhbGlkJzogMCxcbiAgLy8gc3RhdGVcbiAgJ2FyaWEta2V5c2hvcnRjdXRzJzogMCxcbiAgJ2FyaWEtbGFiZWwnOiAwLFxuICAnYXJpYS1yb2xlZGVzY3JpcHRpb24nOiAwLFxuICAvLyBXaWRnZXQgQXR0cmlidXRlc1xuICAnYXJpYS1hdXRvY29tcGxldGUnOiAwLFxuICAnYXJpYS1jaGVja2VkJzogMCxcbiAgJ2FyaWEtZXhwYW5kZWQnOiAwLFxuICAnYXJpYS1oYXNwb3B1cCc6IDAsXG4gICdhcmlhLWxldmVsJzogMCxcbiAgJ2FyaWEtbW9kYWwnOiAwLFxuICAnYXJpYS1tdWx0aWxpbmUnOiAwLFxuICAnYXJpYS1tdWx0aXNlbGVjdGFibGUnOiAwLFxuICAnYXJpYS1vcmllbnRhdGlvbic6IDAsXG4gICdhcmlhLXBsYWNlaG9sZGVyJzogMCxcbiAgJ2FyaWEtcHJlc3NlZCc6IDAsXG4gICdhcmlhLXJlYWRvbmx5JzogMCxcbiAgJ2FyaWEtcmVxdWlyZWQnOiAwLFxuICAnYXJpYS1zZWxlY3RlZCc6IDAsXG4gICdhcmlhLXNvcnQnOiAwLFxuICAnYXJpYS12YWx1ZW1heCc6IDAsXG4gICdhcmlhLXZhbHVlbWluJzogMCxcbiAgJ2FyaWEtdmFsdWVub3cnOiAwLFxuICAnYXJpYS12YWx1ZXRleHQnOiAwLFxuICAvLyBMaXZlIFJlZ2lvbiBBdHRyaWJ1dGVzXG4gICdhcmlhLWF0b21pYyc6IDAsXG4gICdhcmlhLWJ1c3knOiAwLFxuICAnYXJpYS1saXZlJzogMCxcbiAgJ2FyaWEtcmVsZXZhbnQnOiAwLFxuICAvLyBEcmFnLWFuZC1Ecm9wIEF0dHJpYnV0ZXNcbiAgJ2FyaWEtZHJvcGVmZmVjdCc6IDAsXG4gICdhcmlhLWdyYWJiZWQnOiAwLFxuICAvLyBSZWxhdGlvbnNoaXAgQXR0cmlidXRlc1xuICAnYXJpYS1hY3RpdmVkZXNjZW5kYW50JzogMCxcbiAgJ2FyaWEtY29sY291bnQnOiAwLFxuICAnYXJpYS1jb2xpbmRleCc6IDAsXG4gICdhcmlhLWNvbHNwYW4nOiAwLFxuICAnYXJpYS1jb250cm9scyc6IDAsXG4gICdhcmlhLWRlc2NyaWJlZGJ5JzogMCxcbiAgJ2FyaWEtZXJyb3JtZXNzYWdlJzogMCxcbiAgJ2FyaWEtZmxvd3RvJzogMCxcbiAgJ2FyaWEtbGFiZWxsZWRieSc6IDAsXG4gICdhcmlhLW93bnMnOiAwLFxuICAnYXJpYS1wb3NpbnNldCc6IDAsXG4gICdhcmlhLXJvd2NvdW50JzogMCxcbiAgJ2FyaWEtcm93aW5kZXgnOiAwLFxuICAnYXJpYS1yb3dzcGFuJzogMCxcbiAgJ2FyaWEtc2V0c2l6ZSc6IDBcbn07XG5cbnZhciB3YXJuZWRQcm9wZXJ0aWVzID0ge307XG52YXIgckFSSUEgPSBuZXcgUmVnRXhwKCdeKGFyaWEpLVsnICsgQVRUUklCVVRFX05BTUVfQ0hBUiArICddKiQnKTtcbnZhciByQVJJQUNhbWVsID0gbmV3IFJlZ0V4cCgnXihhcmlhKVtBLVpdWycgKyBBVFRSSUJVVEVfTkFNRV9DSEFSICsgJ10qJCcpO1xudmFyIGhhc093blByb3BlcnR5JDEgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG5mdW5jdGlvbiB2YWxpZGF0ZVByb3BlcnR5KHRhZ05hbWUsIG5hbWUpIHtcbiAge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eSQxLmNhbGwod2FybmVkUHJvcGVydGllcywgbmFtZSkgJiYgd2FybmVkUHJvcGVydGllc1tuYW1lXSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgaWYgKHJBUklBQ2FtZWwudGVzdChuYW1lKSkge1xuICAgICAgdmFyIGFyaWFOYW1lID0gJ2FyaWEtJyArIG5hbWUuc2xpY2UoNCkudG9Mb3dlckNhc2UoKTtcbiAgICAgIHZhciBjb3JyZWN0TmFtZSA9IGFyaWFQcm9wZXJ0aWVzLmhhc093blByb3BlcnR5KGFyaWFOYW1lKSA/IGFyaWFOYW1lIDogbnVsbDsgLy8gSWYgdGhpcyBpcyBhbiBhcmlhLSogYXR0cmlidXRlLCBidXQgaXMgbm90IGxpc3RlZCBpbiB0aGUga25vd24gRE9NXG4gICAgICAvLyBET00gcHJvcGVydGllcywgdGhlbiBpdCBpcyBhbiBpbnZhbGlkIGFyaWEtKiBhdHRyaWJ1dGUuXG5cbiAgICAgIGlmIChjb3JyZWN0TmFtZSA9PSBudWxsKSB7XG4gICAgICAgIGVycm9yKCdJbnZhbGlkIEFSSUEgYXR0cmlidXRlIGAlc2AuIEFSSUEgYXR0cmlidXRlcyBmb2xsb3cgdGhlIHBhdHRlcm4gYXJpYS0qIGFuZCBtdXN0IGJlIGxvd2VyY2FzZS4nLCBuYW1lKTtcblxuICAgICAgICB3YXJuZWRQcm9wZXJ0aWVzW25hbWVdID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9IC8vIGFyaWEtKiBhdHRyaWJ1dGVzIHNob3VsZCBiZSBsb3dlcmNhc2U7IHN1Z2dlc3QgdGhlIGxvd2VyY2FzZSB2ZXJzaW9uLlxuXG5cbiAgICAgIGlmIChuYW1lICE9PSBjb3JyZWN0TmFtZSkge1xuICAgICAgICBlcnJvcignSW52YWxpZCBBUklBIGF0dHJpYnV0ZSBgJXNgLiBEaWQgeW91IG1lYW4gYCVzYD8nLCBuYW1lLCBjb3JyZWN0TmFtZSk7XG5cbiAgICAgICAgd2FybmVkUHJvcGVydGllc1tuYW1lXSA9IHRydWU7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChyQVJJQS50ZXN0KG5hbWUpKSB7XG4gICAgICB2YXIgbG93ZXJDYXNlZE5hbWUgPSBuYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICB2YXIgc3RhbmRhcmROYW1lID0gYXJpYVByb3BlcnRpZXMuaGFzT3duUHJvcGVydHkobG93ZXJDYXNlZE5hbWUpID8gbG93ZXJDYXNlZE5hbWUgOiBudWxsOyAvLyBJZiB0aGlzIGlzIGFuIGFyaWEtKiBhdHRyaWJ1dGUsIGJ1dCBpcyBub3QgbGlzdGVkIGluIHRoZSBrbm93biBET01cbiAgICAgIC8vIERPTSBwcm9wZXJ0aWVzLCB0aGVuIGl0IGlzIGFuIGludmFsaWQgYXJpYS0qIGF0dHJpYnV0ZS5cblxuICAgICAgaWYgKHN0YW5kYXJkTmFtZSA9PSBudWxsKSB7XG4gICAgICAgIHdhcm5lZFByb3BlcnRpZXNbbmFtZV0gPSB0cnVlO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9IC8vIGFyaWEtKiBhdHRyaWJ1dGVzIHNob3VsZCBiZSBsb3dlcmNhc2U7IHN1Z2dlc3QgdGhlIGxvd2VyY2FzZSB2ZXJzaW9uLlxuXG5cbiAgICAgIGlmIChuYW1lICE9PSBzdGFuZGFyZE5hbWUpIHtcbiAgICAgICAgZXJyb3IoJ1Vua25vd24gQVJJQSBhdHRyaWJ1dGUgYCVzYC4gRGlkIHlvdSBtZWFuIGAlc2A/JywgbmFtZSwgc3RhbmRhcmROYW1lKTtcblxuICAgICAgICB3YXJuZWRQcm9wZXJ0aWVzW25hbWVdID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIHdhcm5JbnZhbGlkQVJJQVByb3BzKHR5cGUsIHByb3BzKSB7XG4gIHtcbiAgICB2YXIgaW52YWxpZFByb3BzID0gW107XG5cbiAgICBmb3IgKHZhciBrZXkgaW4gcHJvcHMpIHtcbiAgICAgIHZhciBpc1ZhbGlkID0gdmFsaWRhdGVQcm9wZXJ0eSh0eXBlLCBrZXkpO1xuXG4gICAgICBpZiAoIWlzVmFsaWQpIHtcbiAgICAgICAgaW52YWxpZFByb3BzLnB1c2goa2V5KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgdW5rbm93blByb3BTdHJpbmcgPSBpbnZhbGlkUHJvcHMubWFwKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgICByZXR1cm4gJ2AnICsgcHJvcCArICdgJztcbiAgICB9KS5qb2luKCcsICcpO1xuXG4gICAgaWYgKGludmFsaWRQcm9wcy5sZW5ndGggPT09IDEpIHtcbiAgICAgIGVycm9yKCdJbnZhbGlkIGFyaWEgcHJvcCAlcyBvbiA8JXM+IHRhZy4gJyArICdGb3IgZGV0YWlscywgc2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9pbnZhbGlkLWFyaWEtcHJvcHMnLCB1bmtub3duUHJvcFN0cmluZywgdHlwZSk7XG4gICAgfSBlbHNlIGlmIChpbnZhbGlkUHJvcHMubGVuZ3RoID4gMSkge1xuICAgICAgZXJyb3IoJ0ludmFsaWQgYXJpYSBwcm9wcyAlcyBvbiA8JXM+IHRhZy4gJyArICdGb3IgZGV0YWlscywgc2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9pbnZhbGlkLWFyaWEtcHJvcHMnLCB1bmtub3duUHJvcFN0cmluZywgdHlwZSk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlUHJvcGVydGllcyh0eXBlLCBwcm9wcykge1xuICBpZiAoaXNDdXN0b21Db21wb25lbnQodHlwZSwgcHJvcHMpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgd2FybkludmFsaWRBUklBUHJvcHModHlwZSwgcHJvcHMpO1xufVxuXG52YXIgZGlkV2FyblZhbHVlTnVsbCA9IGZhbHNlO1xuZnVuY3Rpb24gdmFsaWRhdGVQcm9wZXJ0aWVzJDEodHlwZSwgcHJvcHMpIHtcbiAge1xuICAgIGlmICh0eXBlICE9PSAnaW5wdXQnICYmIHR5cGUgIT09ICd0ZXh0YXJlYScgJiYgdHlwZSAhPT0gJ3NlbGVjdCcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAocHJvcHMgIT0gbnVsbCAmJiBwcm9wcy52YWx1ZSA9PT0gbnVsbCAmJiAhZGlkV2FyblZhbHVlTnVsbCkge1xuICAgICAgZGlkV2FyblZhbHVlTnVsbCA9IHRydWU7XG5cbiAgICAgIGlmICh0eXBlID09PSAnc2VsZWN0JyAmJiBwcm9wcy5tdWx0aXBsZSkge1xuICAgICAgICBlcnJvcignYHZhbHVlYCBwcm9wIG9uIGAlc2Agc2hvdWxkIG5vdCBiZSBudWxsLiAnICsgJ0NvbnNpZGVyIHVzaW5nIGFuIGVtcHR5IGFycmF5IHdoZW4gYG11bHRpcGxlYCBpcyBzZXQgdG8gYHRydWVgICcgKyAndG8gY2xlYXIgdGhlIGNvbXBvbmVudCBvciBgdW5kZWZpbmVkYCBmb3IgdW5jb250cm9sbGVkIGNvbXBvbmVudHMuJywgdHlwZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlcnJvcignYHZhbHVlYCBwcm9wIG9uIGAlc2Agc2hvdWxkIG5vdCBiZSBudWxsLiAnICsgJ0NvbnNpZGVyIHVzaW5nIGFuIGVtcHR5IHN0cmluZyB0byBjbGVhciB0aGUgY29tcG9uZW50IG9yIGB1bmRlZmluZWRgICcgKyAnZm9yIHVuY29udHJvbGxlZCBjb21wb25lbnRzLicsIHR5cGUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG52YXIgdmFsaWRhdGVQcm9wZXJ0eSQxID0gZnVuY3Rpb24gKCkge307XG5cbntcbiAgdmFyIHdhcm5lZFByb3BlcnRpZXMkMSA9IHt9O1xuICB2YXIgX2hhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbiAgdmFyIEVWRU5UX05BTUVfUkVHRVggPSAvXm9uLi87XG4gIHZhciBJTlZBTElEX0VWRU5UX05BTUVfUkVHRVggPSAvXm9uW15BLVpdLztcbiAgdmFyIHJBUklBJDEgPSBuZXcgUmVnRXhwKCdeKGFyaWEpLVsnICsgQVRUUklCVVRFX05BTUVfQ0hBUiArICddKiQnKTtcbiAgdmFyIHJBUklBQ2FtZWwkMSA9IG5ldyBSZWdFeHAoJ14oYXJpYSlbQS1aXVsnICsgQVRUUklCVVRFX05BTUVfQ0hBUiArICddKiQnKTtcblxuICB2YWxpZGF0ZVByb3BlcnR5JDEgPSBmdW5jdGlvbiAodGFnTmFtZSwgbmFtZSwgdmFsdWUsIGV2ZW50UmVnaXN0cnkpIHtcbiAgICBpZiAoX2hhc093blByb3BlcnR5LmNhbGwod2FybmVkUHJvcGVydGllcyQxLCBuYW1lKSAmJiB3YXJuZWRQcm9wZXJ0aWVzJDFbbmFtZV0pIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHZhciBsb3dlckNhc2VkTmFtZSA9IG5hbWUudG9Mb3dlckNhc2UoKTtcblxuICAgIGlmIChsb3dlckNhc2VkTmFtZSA9PT0gJ29uZm9jdXNpbicgfHwgbG93ZXJDYXNlZE5hbWUgPT09ICdvbmZvY3Vzb3V0Jykge1xuICAgICAgZXJyb3IoJ1JlYWN0IHVzZXMgb25Gb2N1cyBhbmQgb25CbHVyIGluc3RlYWQgb2Ygb25Gb2N1c0luIGFuZCBvbkZvY3VzT3V0LiAnICsgJ0FsbCBSZWFjdCBldmVudHMgYXJlIG5vcm1hbGl6ZWQgdG8gYnViYmxlLCBzbyBvbkZvY3VzSW4gYW5kIG9uRm9jdXNPdXQgJyArICdhcmUgbm90IG5lZWRlZC9zdXBwb3J0ZWQgYnkgUmVhY3QuJyk7XG5cbiAgICAgIHdhcm5lZFByb3BlcnRpZXMkMVtuYW1lXSA9IHRydWU7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IC8vIFdlIGNhbid0IHJlbHkgb24gdGhlIGV2ZW50IHN5c3RlbSBiZWluZyBpbmplY3RlZCBvbiB0aGUgc2VydmVyLlxuXG5cbiAgICBpZiAoZXZlbnRSZWdpc3RyeSAhPSBudWxsKSB7XG4gICAgICB2YXIgcmVnaXN0cmF0aW9uTmFtZURlcGVuZGVuY2llcyA9IGV2ZW50UmVnaXN0cnkucmVnaXN0cmF0aW9uTmFtZURlcGVuZGVuY2llcyxcbiAgICAgICAgICBwb3NzaWJsZVJlZ2lzdHJhdGlvbk5hbWVzID0gZXZlbnRSZWdpc3RyeS5wb3NzaWJsZVJlZ2lzdHJhdGlvbk5hbWVzO1xuXG4gICAgICBpZiAocmVnaXN0cmF0aW9uTmFtZURlcGVuZGVuY2llcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgdmFyIHJlZ2lzdHJhdGlvbk5hbWUgPSBwb3NzaWJsZVJlZ2lzdHJhdGlvbk5hbWVzLmhhc093blByb3BlcnR5KGxvd2VyQ2FzZWROYW1lKSA/IHBvc3NpYmxlUmVnaXN0cmF0aW9uTmFtZXNbbG93ZXJDYXNlZE5hbWVdIDogbnVsbDtcblxuICAgICAgaWYgKHJlZ2lzdHJhdGlvbk5hbWUgIT0gbnVsbCkge1xuICAgICAgICBlcnJvcignSW52YWxpZCBldmVudCBoYW5kbGVyIHByb3BlcnR5IGAlc2AuIERpZCB5b3UgbWVhbiBgJXNgPycsIG5hbWUsIHJlZ2lzdHJhdGlvbk5hbWUpO1xuXG4gICAgICAgIHdhcm5lZFByb3BlcnRpZXMkMVtuYW1lXSA9IHRydWU7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoRVZFTlRfTkFNRV9SRUdFWC50ZXN0KG5hbWUpKSB7XG4gICAgICAgIGVycm9yKCdVbmtub3duIGV2ZW50IGhhbmRsZXIgcHJvcGVydHkgYCVzYC4gSXQgd2lsbCBiZSBpZ25vcmVkLicsIG5hbWUpO1xuXG4gICAgICAgIHdhcm5lZFByb3BlcnRpZXMkMVtuYW1lXSA9IHRydWU7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoRVZFTlRfTkFNRV9SRUdFWC50ZXN0KG5hbWUpKSB7XG4gICAgICAvLyBJZiBubyBldmVudCBwbHVnaW5zIGhhdmUgYmVlbiBpbmplY3RlZCwgd2UgYXJlIGluIGEgc2VydmVyIGVudmlyb25tZW50LlxuICAgICAgLy8gU28gd2UgY2FuJ3QgdGVsbCBpZiB0aGUgZXZlbnQgbmFtZSBpcyBjb3JyZWN0IGZvciBzdXJlLCBidXQgd2UgY2FuIGZpbHRlclxuICAgICAgLy8gb3V0IGtub3duIGJhZCBvbmVzIGxpa2UgYG9uY2xpY2tgLiBXZSBjYW4ndCBzdWdnZXN0IGEgc3BlY2lmaWMgcmVwbGFjZW1lbnQgdGhvdWdoLlxuICAgICAgaWYgKElOVkFMSURfRVZFTlRfTkFNRV9SRUdFWC50ZXN0KG5hbWUpKSB7XG4gICAgICAgIGVycm9yKCdJbnZhbGlkIGV2ZW50IGhhbmRsZXIgcHJvcGVydHkgYCVzYC4gJyArICdSZWFjdCBldmVudHMgdXNlIHRoZSBjYW1lbENhc2UgbmFtaW5nIGNvbnZlbnRpb24sIGZvciBleGFtcGxlIGBvbkNsaWNrYC4nLCBuYW1lKTtcbiAgICAgIH1cblxuICAgICAgd2FybmVkUHJvcGVydGllcyQxW25hbWVdID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gLy8gTGV0IHRoZSBBUklBIGF0dHJpYnV0ZSBob29rIHZhbGlkYXRlIEFSSUEgYXR0cmlidXRlc1xuXG5cbiAgICBpZiAockFSSUEkMS50ZXN0KG5hbWUpIHx8IHJBUklBQ2FtZWwkMS50ZXN0KG5hbWUpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAobG93ZXJDYXNlZE5hbWUgPT09ICdpbm5lcmh0bWwnKSB7XG4gICAgICBlcnJvcignRGlyZWN0bHkgc2V0dGluZyBwcm9wZXJ0eSBgaW5uZXJIVE1MYCBpcyBub3QgcGVybWl0dGVkLiAnICsgJ0ZvciBtb3JlIGluZm9ybWF0aW9uLCBsb29rdXAgZG9jdW1lbnRhdGlvbiBvbiBgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxgLicpO1xuXG4gICAgICB3YXJuZWRQcm9wZXJ0aWVzJDFbbmFtZV0gPSB0cnVlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgaWYgKGxvd2VyQ2FzZWROYW1lID09PSAnYXJpYScpIHtcbiAgICAgIGVycm9yKCdUaGUgYGFyaWFgIGF0dHJpYnV0ZSBpcyByZXNlcnZlZCBmb3IgZnV0dXJlIHVzZSBpbiBSZWFjdC4gJyArICdQYXNzIGluZGl2aWR1YWwgYGFyaWEtYCBhdHRyaWJ1dGVzIGluc3RlYWQuJyk7XG5cbiAgICAgIHdhcm5lZFByb3BlcnRpZXMkMVtuYW1lXSA9IHRydWU7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAobG93ZXJDYXNlZE5hbWUgPT09ICdpcycgJiYgdmFsdWUgIT09IG51bGwgJiYgdmFsdWUgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICBlcnJvcignUmVjZWl2ZWQgYSBgJXNgIGZvciBhIHN0cmluZyBhdHRyaWJ1dGUgYGlzYC4gSWYgdGhpcyBpcyBleHBlY3RlZCwgY2FzdCAnICsgJ3RoZSB2YWx1ZSB0byBhIHN0cmluZy4nLCB0eXBlb2YgdmFsdWUpO1xuXG4gICAgICB3YXJuZWRQcm9wZXJ0aWVzJDFbbmFtZV0gPSB0cnVlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgJiYgaXNOYU4odmFsdWUpKSB7XG4gICAgICBlcnJvcignUmVjZWl2ZWQgTmFOIGZvciB0aGUgYCVzYCBhdHRyaWJ1dGUuIElmIHRoaXMgaXMgZXhwZWN0ZWQsIGNhc3QgJyArICd0aGUgdmFsdWUgdG8gYSBzdHJpbmcuJywgbmFtZSk7XG5cbiAgICAgIHdhcm5lZFByb3BlcnRpZXMkMVtuYW1lXSA9IHRydWU7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICB2YXIgcHJvcGVydHlJbmZvID0gZ2V0UHJvcGVydHlJbmZvKG5hbWUpO1xuICAgIHZhciBpc1Jlc2VydmVkID0gcHJvcGVydHlJbmZvICE9PSBudWxsICYmIHByb3BlcnR5SW5mby50eXBlID09PSBSRVNFUlZFRDsgLy8gS25vd24gYXR0cmlidXRlcyBzaG91bGQgbWF0Y2ggdGhlIGNhc2luZyBzcGVjaWZpZWQgaW4gdGhlIHByb3BlcnR5IGNvbmZpZy5cblxuICAgIGlmIChwb3NzaWJsZVN0YW5kYXJkTmFtZXMuaGFzT3duUHJvcGVydHkobG93ZXJDYXNlZE5hbWUpKSB7XG4gICAgICB2YXIgc3RhbmRhcmROYW1lID0gcG9zc2libGVTdGFuZGFyZE5hbWVzW2xvd2VyQ2FzZWROYW1lXTtcblxuICAgICAgaWYgKHN0YW5kYXJkTmFtZSAhPT0gbmFtZSkge1xuICAgICAgICBlcnJvcignSW52YWxpZCBET00gcHJvcGVydHkgYCVzYC4gRGlkIHlvdSBtZWFuIGAlc2A/JywgbmFtZSwgc3RhbmRhcmROYW1lKTtcblxuICAgICAgICB3YXJuZWRQcm9wZXJ0aWVzJDFbbmFtZV0gPSB0cnVlO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCFpc1Jlc2VydmVkICYmIG5hbWUgIT09IGxvd2VyQ2FzZWROYW1lKSB7XG4gICAgICAvLyBVbmtub3duIGF0dHJpYnV0ZXMgc2hvdWxkIGhhdmUgbG93ZXJjYXNlIGNhc2luZyBzaW5jZSB0aGF0J3MgaG93IHRoZXlcbiAgICAgIC8vIHdpbGwgYmUgY2FzZWQgYW55d2F5IHdpdGggc2VydmVyIHJlbmRlcmluZy5cbiAgICAgIGVycm9yKCdSZWFjdCBkb2VzIG5vdCByZWNvZ25pemUgdGhlIGAlc2AgcHJvcCBvbiBhIERPTSBlbGVtZW50LiBJZiB5b3UgJyArICdpbnRlbnRpb25hbGx5IHdhbnQgaXQgdG8gYXBwZWFyIGluIHRoZSBET00gYXMgYSBjdXN0b20gJyArICdhdHRyaWJ1dGUsIHNwZWxsIGl0IGFzIGxvd2VyY2FzZSBgJXNgIGluc3RlYWQuICcgKyAnSWYgeW91IGFjY2lkZW50YWxseSBwYXNzZWQgaXQgZnJvbSBhIHBhcmVudCBjb21wb25lbnQsIHJlbW92ZSAnICsgJ2l0IGZyb20gdGhlIERPTSBlbGVtZW50LicsIG5hbWUsIGxvd2VyQ2FzZWROYW1lKTtcblxuICAgICAgd2FybmVkUHJvcGVydGllcyQxW25hbWVdID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJyAmJiBzaG91bGRSZW1vdmVBdHRyaWJ1dGVXaXRoV2FybmluZyhuYW1lLCB2YWx1ZSwgcHJvcGVydHlJbmZvLCBmYWxzZSkpIHtcbiAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICBlcnJvcignUmVjZWl2ZWQgYCVzYCBmb3IgYSBub24tYm9vbGVhbiBhdHRyaWJ1dGUgYCVzYC5cXG5cXG4nICsgJ0lmIHlvdSB3YW50IHRvIHdyaXRlIGl0IHRvIHRoZSBET00sIHBhc3MgYSBzdHJpbmcgaW5zdGVhZDogJyArICclcz1cIiVzXCIgb3IgJXM9e3ZhbHVlLnRvU3RyaW5nKCl9LicsIHZhbHVlLCBuYW1lLCBuYW1lLCB2YWx1ZSwgbmFtZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlcnJvcignUmVjZWl2ZWQgYCVzYCBmb3IgYSBub24tYm9vbGVhbiBhdHRyaWJ1dGUgYCVzYC5cXG5cXG4nICsgJ0lmIHlvdSB3YW50IHRvIHdyaXRlIGl0IHRvIHRoZSBET00sIHBhc3MgYSBzdHJpbmcgaW5zdGVhZDogJyArICclcz1cIiVzXCIgb3IgJXM9e3ZhbHVlLnRvU3RyaW5nKCl9LlxcblxcbicgKyAnSWYgeW91IHVzZWQgdG8gY29uZGl0aW9uYWxseSBvbWl0IGl0IHdpdGggJXM9e2NvbmRpdGlvbiAmJiB2YWx1ZX0sICcgKyAncGFzcyAlcz17Y29uZGl0aW9uID8gdmFsdWUgOiB1bmRlZmluZWR9IGluc3RlYWQuJywgdmFsdWUsIG5hbWUsIG5hbWUsIHZhbHVlLCBuYW1lLCBuYW1lLCBuYW1lKTtcbiAgICAgIH1cblxuICAgICAgd2FybmVkUHJvcGVydGllcyQxW25hbWVdID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gLy8gTm93IHRoYXQgd2UndmUgdmFsaWRhdGVkIGNhc2luZywgZG8gbm90IHZhbGlkYXRlXG4gICAgLy8gZGF0YSB0eXBlcyBmb3IgcmVzZXJ2ZWQgcHJvcHNcblxuXG4gICAgaWYgKGlzUmVzZXJ2ZWQpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gLy8gV2FybiB3aGVuIGEga25vd24gYXR0cmlidXRlIGlzIGEgYmFkIHR5cGVcblxuXG4gICAgaWYgKHNob3VsZFJlbW92ZUF0dHJpYnV0ZVdpdGhXYXJuaW5nKG5hbWUsIHZhbHVlLCBwcm9wZXJ0eUluZm8sIGZhbHNlKSkge1xuICAgICAgd2FybmVkUHJvcGVydGllcyQxW25hbWVdID0gdHJ1ZTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IC8vIFdhcm4gd2hlbiBwYXNzaW5nIHRoZSBzdHJpbmdzICdmYWxzZScgb3IgJ3RydWUnIGludG8gYSBib29sZWFuIHByb3BcblxuXG4gICAgaWYgKCh2YWx1ZSA9PT0gJ2ZhbHNlJyB8fCB2YWx1ZSA9PT0gJ3RydWUnKSAmJiBwcm9wZXJ0eUluZm8gIT09IG51bGwgJiYgcHJvcGVydHlJbmZvLnR5cGUgPT09IEJPT0xFQU4pIHtcbiAgICAgIGVycm9yKCdSZWNlaXZlZCB0aGUgc3RyaW5nIGAlc2AgZm9yIHRoZSBib29sZWFuIGF0dHJpYnV0ZSBgJXNgLiAnICsgJyVzICcgKyAnRGlkIHlvdSBtZWFuICVzPXslc30/JywgdmFsdWUsIG5hbWUsIHZhbHVlID09PSAnZmFsc2UnID8gJ1RoZSBicm93c2VyIHdpbGwgaW50ZXJwcmV0IGl0IGFzIGEgdHJ1dGh5IHZhbHVlLicgOiAnQWx0aG91Z2ggdGhpcyB3b3JrcywgaXQgd2lsbCBub3Qgd29yayBhcyBleHBlY3RlZCBpZiB5b3UgcGFzcyB0aGUgc3RyaW5nIFwiZmFsc2VcIi4nLCBuYW1lLCB2YWx1ZSk7XG5cbiAgICAgIHdhcm5lZFByb3BlcnRpZXMkMVtuYW1lXSA9IHRydWU7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcbn1cblxudmFyIHdhcm5Vbmtub3duUHJvcGVydGllcyA9IGZ1bmN0aW9uICh0eXBlLCBwcm9wcywgZXZlbnRSZWdpc3RyeSkge1xuICB7XG4gICAgdmFyIHVua25vd25Qcm9wcyA9IFtdO1xuXG4gICAgZm9yICh2YXIga2V5IGluIHByb3BzKSB7XG4gICAgICB2YXIgaXNWYWxpZCA9IHZhbGlkYXRlUHJvcGVydHkkMSh0eXBlLCBrZXksIHByb3BzW2tleV0sIGV2ZW50UmVnaXN0cnkpO1xuXG4gICAgICBpZiAoIWlzVmFsaWQpIHtcbiAgICAgICAgdW5rbm93blByb3BzLnB1c2goa2V5KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgdW5rbm93blByb3BTdHJpbmcgPSB1bmtub3duUHJvcHMubWFwKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgICByZXR1cm4gJ2AnICsgcHJvcCArICdgJztcbiAgICB9KS5qb2luKCcsICcpO1xuXG4gICAgaWYgKHVua25vd25Qcm9wcy5sZW5ndGggPT09IDEpIHtcbiAgICAgIGVycm9yKCdJbnZhbGlkIHZhbHVlIGZvciBwcm9wICVzIG9uIDwlcz4gdGFnLiBFaXRoZXIgcmVtb3ZlIGl0IGZyb20gdGhlIGVsZW1lbnQsICcgKyAnb3IgcGFzcyBhIHN0cmluZyBvciBudW1iZXIgdmFsdWUgdG8ga2VlcCBpdCBpbiB0aGUgRE9NLiAnICsgJ0ZvciBkZXRhaWxzLCBzZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL2F0dHJpYnV0ZS1iZWhhdmlvciAnLCB1bmtub3duUHJvcFN0cmluZywgdHlwZSk7XG4gICAgfSBlbHNlIGlmICh1bmtub3duUHJvcHMubGVuZ3RoID4gMSkge1xuICAgICAgZXJyb3IoJ0ludmFsaWQgdmFsdWVzIGZvciBwcm9wcyAlcyBvbiA8JXM+IHRhZy4gRWl0aGVyIHJlbW92ZSB0aGVtIGZyb20gdGhlIGVsZW1lbnQsICcgKyAnb3IgcGFzcyBhIHN0cmluZyBvciBudW1iZXIgdmFsdWUgdG8ga2VlcCB0aGVtIGluIHRoZSBET00uICcgKyAnRm9yIGRldGFpbHMsIHNlZSBodHRwczovL3JlYWN0anMub3JnL2xpbmsvYXR0cmlidXRlLWJlaGF2aW9yICcsIHVua25vd25Qcm9wU3RyaW5nLCB0eXBlKTtcbiAgICB9XG4gIH1cbn07XG5cbmZ1bmN0aW9uIHZhbGlkYXRlUHJvcGVydGllcyQyKHR5cGUsIHByb3BzLCBldmVudFJlZ2lzdHJ5KSB7XG4gIGlmIChpc0N1c3RvbUNvbXBvbmVudCh0eXBlLCBwcm9wcykpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB3YXJuVW5rbm93blByb3BlcnRpZXModHlwZSwgcHJvcHMsIGV2ZW50UmVnaXN0cnkpO1xufVxuXG52YXIgSVNfRVZFTlRfSEFORExFX05PTl9NQU5BR0VEX05PREUgPSAxO1xudmFyIElTX05PTl9ERUxFR0FURUQgPSAxIDw8IDE7XG52YXIgSVNfQ0FQVFVSRV9QSEFTRSA9IDEgPDwgMjtcbnZhciBJU19SRVBMQVlFRCA9IDEgPDwgNDtcbi8vIHNldCB0byBMRUdBQ1lfRkJfU1VQUE9SVC4gTEVHQUNZX0ZCX1NVUFBPUlQgb25seSBnZXRzIHNldCB3aGVuXG4vLyB3ZSBjYWxsIHdpbGxEZWZlckxhdGVyRm9yTGVnYWN5RkJTdXBwb3J0LCB0aHVzIG5vdCBiYWlsaW5nIG91dFxuLy8gd2lsbCByZXN1bHQgaW4gZW5kbGVzcyBjeWNsZXMgbGlrZSBhbiBpbmZpbml0ZSBsb29wLlxuLy8gV2UgYWxzbyBkb24ndCB3YW50IHRvIGRlZmVyIGR1cmluZyBldmVudCByZXBsYXlpbmcuXG5cbnZhciBTSE9VTERfTk9UX1BST0NFU1NfUE9MWUZJTExfRVZFTlRfUExVR0lOUyA9IElTX0VWRU5UX0hBTkRMRV9OT05fTUFOQUdFRF9OT0RFIHwgSVNfTk9OX0RFTEVHQVRFRCB8IElTX0NBUFRVUkVfUEhBU0U7XG5cbi8qKlxuICogR2V0cyB0aGUgdGFyZ2V0IG5vZGUgZnJvbSBhIG5hdGl2ZSBicm93c2VyIGV2ZW50IGJ5IGFjY291bnRpbmcgZm9yXG4gKiBpbmNvbnNpc3RlbmNpZXMgaW4gYnJvd3NlciBET00gQVBJcy5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gKiBAcmV0dXJuIHtET01FdmVudFRhcmdldH0gVGFyZ2V0IG5vZGUuXG4gKi9cblxuZnVuY3Rpb24gZ2V0RXZlbnRUYXJnZXQobmF0aXZlRXZlbnQpIHtcbiAgLy8gRmFsbGJhY2sgdG8gbmF0aXZlRXZlbnQuc3JjRWxlbWVudCBmb3IgSUU5XG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTI1MDZcbiAgdmFyIHRhcmdldCA9IG5hdGl2ZUV2ZW50LnRhcmdldCB8fCBuYXRpdmVFdmVudC5zcmNFbGVtZW50IHx8IHdpbmRvdzsgLy8gTm9ybWFsaXplIFNWRyA8dXNlPiBlbGVtZW50IGV2ZW50cyAjNDk2M1xuXG4gIGlmICh0YXJnZXQuY29ycmVzcG9uZGluZ1VzZUVsZW1lbnQpIHtcbiAgICB0YXJnZXQgPSB0YXJnZXQuY29ycmVzcG9uZGluZ1VzZUVsZW1lbnQ7XG4gIH0gLy8gU2FmYXJpIG1heSBmaXJlIGV2ZW50cyBvbiB0ZXh0IG5vZGVzIChOb2RlLlRFWFRfTk9ERSBpcyAzKS5cbiAgLy8gQHNlZSBodHRwOi8vd3d3LnF1aXJrc21vZGUub3JnL2pzL2V2ZW50c19wcm9wZXJ0aWVzLmh0bWxcblxuXG4gIHJldHVybiB0YXJnZXQubm9kZVR5cGUgPT09IFRFWFRfTk9ERSA/IHRhcmdldC5wYXJlbnROb2RlIDogdGFyZ2V0O1xufVxuXG52YXIgcmVzdG9yZUltcGwgPSBudWxsO1xudmFyIHJlc3RvcmVUYXJnZXQgPSBudWxsO1xudmFyIHJlc3RvcmVRdWV1ZSA9IG51bGw7XG5cbmZ1bmN0aW9uIHJlc3RvcmVTdGF0ZU9mVGFyZ2V0KHRhcmdldCkge1xuICAvLyBXZSBwZXJmb3JtIHRoaXMgdHJhbnNsYXRpb24gYXQgdGhlIGVuZCBvZiB0aGUgZXZlbnQgbG9vcCBzbyB0aGF0IHdlXG4gIC8vIGFsd2F5cyByZWNlaXZlIHRoZSBjb3JyZWN0IGZpYmVyIGhlcmVcbiAgdmFyIGludGVybmFsSW5zdGFuY2UgPSBnZXRJbnN0YW5jZUZyb21Ob2RlKHRhcmdldCk7XG5cbiAgaWYgKCFpbnRlcm5hbEluc3RhbmNlKSB7XG4gICAgLy8gVW5tb3VudGVkXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKCEodHlwZW9mIHJlc3RvcmVJbXBsID09PSAnZnVuY3Rpb24nKSkge1xuICAgIHtcbiAgICAgIHRocm93IEVycm9yKCBcInNldFJlc3RvcmVJbXBsZW1lbnRhdGlvbigpIG5lZWRzIHRvIGJlIGNhbGxlZCB0byBoYW5kbGUgYSB0YXJnZXQgZm9yIGNvbnRyb2xsZWQgZXZlbnRzLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiICk7XG4gICAgfVxuICB9XG5cbiAgdmFyIHN0YXRlTm9kZSA9IGludGVybmFsSW5zdGFuY2Uuc3RhdGVOb2RlOyAvLyBHdWFyZCBhZ2FpbnN0IEZpYmVyIGJlaW5nIHVubW91bnRlZC5cblxuICBpZiAoc3RhdGVOb2RlKSB7XG4gICAgdmFyIF9wcm9wcyA9IGdldEZpYmVyQ3VycmVudFByb3BzRnJvbU5vZGUoc3RhdGVOb2RlKTtcblxuICAgIHJlc3RvcmVJbXBsKGludGVybmFsSW5zdGFuY2Uuc3RhdGVOb2RlLCBpbnRlcm5hbEluc3RhbmNlLnR5cGUsIF9wcm9wcyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gc2V0UmVzdG9yZUltcGxlbWVudGF0aW9uKGltcGwpIHtcbiAgcmVzdG9yZUltcGwgPSBpbXBsO1xufVxuZnVuY3Rpb24gZW5xdWV1ZVN0YXRlUmVzdG9yZSh0YXJnZXQpIHtcbiAgaWYgKHJlc3RvcmVUYXJnZXQpIHtcbiAgICBpZiAocmVzdG9yZVF1ZXVlKSB7XG4gICAgICByZXN0b3JlUXVldWUucHVzaCh0YXJnZXQpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN0b3JlUXVldWUgPSBbdGFyZ2V0XTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcmVzdG9yZVRhcmdldCA9IHRhcmdldDtcbiAgfVxufVxuZnVuY3Rpb24gbmVlZHNTdGF0ZVJlc3RvcmUoKSB7XG4gIHJldHVybiByZXN0b3JlVGFyZ2V0ICE9PSBudWxsIHx8IHJlc3RvcmVRdWV1ZSAhPT0gbnVsbDtcbn1cbmZ1bmN0aW9uIHJlc3RvcmVTdGF0ZUlmTmVlZGVkKCkge1xuICBpZiAoIXJlc3RvcmVUYXJnZXQpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgdGFyZ2V0ID0gcmVzdG9yZVRhcmdldDtcbiAgdmFyIHF1ZXVlZFRhcmdldHMgPSByZXN0b3JlUXVldWU7XG4gIHJlc3RvcmVUYXJnZXQgPSBudWxsO1xuICByZXN0b3JlUXVldWUgPSBudWxsO1xuICByZXN0b3JlU3RhdGVPZlRhcmdldCh0YXJnZXQpO1xuXG4gIGlmIChxdWV1ZWRUYXJnZXRzKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBxdWV1ZWRUYXJnZXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICByZXN0b3JlU3RhdGVPZlRhcmdldChxdWV1ZWRUYXJnZXRzW2ldKTtcbiAgICB9XG4gIH1cbn1cblxuLy8gdGhlIHJlbmRlcmVyLiBTdWNoIGFzIHdoZW4gd2UncmUgZGlzcGF0Y2hpbmcgZXZlbnRzIG9yIGlmIHRoaXJkIHBhcnR5XG4vLyBsaWJyYXJpZXMgbmVlZCB0byBjYWxsIGJhdGNoZWRVcGRhdGVzLiBFdmVudHVhbGx5LCB0aGlzIEFQSSB3aWxsIGdvIGF3YXkgd2hlblxuLy8gZXZlcnl0aGluZyBpcyBiYXRjaGVkIGJ5IGRlZmF1bHQuIFdlJ2xsIHRoZW4gaGF2ZSBhIHNpbWlsYXIgQVBJIHRvIG9wdC1vdXQgb2Zcbi8vIHNjaGVkdWxlZCB3b3JrIGFuZCBpbnN0ZWFkIGRvIHN5bmNocm9ub3VzIHdvcmsuXG4vLyBEZWZhdWx0c1xuXG52YXIgYmF0Y2hlZFVwZGF0ZXNJbXBsID0gZnVuY3Rpb24gKGZuLCBib29ra2VlcGluZykge1xuICByZXR1cm4gZm4oYm9va2tlZXBpbmcpO1xufTtcblxudmFyIGRpc2NyZXRlVXBkYXRlc0ltcGwgPSBmdW5jdGlvbiAoZm4sIGEsIGIsIGMsIGQpIHtcbiAgcmV0dXJuIGZuKGEsIGIsIGMsIGQpO1xufTtcblxudmFyIGZsdXNoRGlzY3JldGVVcGRhdGVzSW1wbCA9IGZ1bmN0aW9uICgpIHt9O1xuXG52YXIgYmF0Y2hlZEV2ZW50VXBkYXRlc0ltcGwgPSBiYXRjaGVkVXBkYXRlc0ltcGw7XG52YXIgaXNJbnNpZGVFdmVudEhhbmRsZXIgPSBmYWxzZTtcbnZhciBpc0JhdGNoaW5nRXZlbnRVcGRhdGVzID0gZmFsc2U7XG5cbmZ1bmN0aW9uIGZpbmlzaEV2ZW50SGFuZGxlcigpIHtcbiAgLy8gSGVyZSB3ZSB3YWl0IHVudGlsIGFsbCB1cGRhdGVzIGhhdmUgcHJvcGFnYXRlZCwgd2hpY2ggaXMgaW1wb3J0YW50XG4gIC8vIHdoZW4gdXNpbmcgY29udHJvbGxlZCBjb21wb25lbnRzIHdpdGhpbiBsYXllcnM6XG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTY5OFxuICAvLyBUaGVuIHdlIHJlc3RvcmUgc3RhdGUgb2YgYW55IGNvbnRyb2xsZWQgY29tcG9uZW50LlxuICB2YXIgY29udHJvbGxlZENvbXBvbmVudHNIYXZlUGVuZGluZ1VwZGF0ZXMgPSBuZWVkc1N0YXRlUmVzdG9yZSgpO1xuXG4gIGlmIChjb250cm9sbGVkQ29tcG9uZW50c0hhdmVQZW5kaW5nVXBkYXRlcykge1xuICAgIC8vIElmIGEgY29udHJvbGxlZCBldmVudCB3YXMgZmlyZWQsIHdlIG1heSBuZWVkIHRvIHJlc3RvcmUgdGhlIHN0YXRlIG9mXG4gICAgLy8gdGhlIERPTSBub2RlIGJhY2sgdG8gdGhlIGNvbnRyb2xsZWQgdmFsdWUuIFRoaXMgaXMgbmVjZXNzYXJ5IHdoZW4gUmVhY3RcbiAgICAvLyBiYWlscyBvdXQgb2YgdGhlIHVwZGF0ZSB3aXRob3V0IHRvdWNoaW5nIHRoZSBET00uXG4gICAgZmx1c2hEaXNjcmV0ZVVwZGF0ZXNJbXBsKCk7XG4gICAgcmVzdG9yZVN0YXRlSWZOZWVkZWQoKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBiYXRjaGVkVXBkYXRlcyhmbiwgYm9va2tlZXBpbmcpIHtcbiAgaWYgKGlzSW5zaWRlRXZlbnRIYW5kbGVyKSB7XG4gICAgLy8gSWYgd2UgYXJlIGN1cnJlbnRseSBpbnNpZGUgYW5vdGhlciBiYXRjaCwgd2UgbmVlZCB0byB3YWl0IHVudGlsIGl0XG4gICAgLy8gZnVsbHkgY29tcGxldGVzIGJlZm9yZSByZXN0b3Jpbmcgc3RhdGUuXG4gICAgcmV0dXJuIGZuKGJvb2trZWVwaW5nKTtcbiAgfVxuXG4gIGlzSW5zaWRlRXZlbnRIYW5kbGVyID0gdHJ1ZTtcblxuICB0cnkge1xuICAgIHJldHVybiBiYXRjaGVkVXBkYXRlc0ltcGwoZm4sIGJvb2trZWVwaW5nKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBpc0luc2lkZUV2ZW50SGFuZGxlciA9IGZhbHNlO1xuICAgIGZpbmlzaEV2ZW50SGFuZGxlcigpO1xuICB9XG59XG5mdW5jdGlvbiBiYXRjaGVkRXZlbnRVcGRhdGVzKGZuLCBhLCBiKSB7XG4gIGlmIChpc0JhdGNoaW5nRXZlbnRVcGRhdGVzKSB7XG4gICAgLy8gSWYgd2UgYXJlIGN1cnJlbnRseSBpbnNpZGUgYW5vdGhlciBiYXRjaCwgd2UgbmVlZCB0byB3YWl0IHVudGlsIGl0XG4gICAgLy8gZnVsbHkgY29tcGxldGVzIGJlZm9yZSByZXN0b3Jpbmcgc3RhdGUuXG4gICAgcmV0dXJuIGZuKGEsIGIpO1xuICB9XG5cbiAgaXNCYXRjaGluZ0V2ZW50VXBkYXRlcyA9IHRydWU7XG5cbiAgdHJ5IHtcbiAgICByZXR1cm4gYmF0Y2hlZEV2ZW50VXBkYXRlc0ltcGwoZm4sIGEsIGIpO1xuICB9IGZpbmFsbHkge1xuICAgIGlzQmF0Y2hpbmdFdmVudFVwZGF0ZXMgPSBmYWxzZTtcbiAgICBmaW5pc2hFdmVudEhhbmRsZXIoKTtcbiAgfVxufVxuZnVuY3Rpb24gZGlzY3JldGVVcGRhdGVzKGZuLCBhLCBiLCBjLCBkKSB7XG4gIHZhciBwcmV2SXNJbnNpZGVFdmVudEhhbmRsZXIgPSBpc0luc2lkZUV2ZW50SGFuZGxlcjtcbiAgaXNJbnNpZGVFdmVudEhhbmRsZXIgPSB0cnVlO1xuXG4gIHRyeSB7XG4gICAgcmV0dXJuIGRpc2NyZXRlVXBkYXRlc0ltcGwoZm4sIGEsIGIsIGMsIGQpO1xuICB9IGZpbmFsbHkge1xuICAgIGlzSW5zaWRlRXZlbnRIYW5kbGVyID0gcHJldklzSW5zaWRlRXZlbnRIYW5kbGVyO1xuXG4gICAgaWYgKCFpc0luc2lkZUV2ZW50SGFuZGxlcikge1xuICAgICAgZmluaXNoRXZlbnRIYW5kbGVyKCk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBmbHVzaERpc2NyZXRlVXBkYXRlc0lmTmVlZGVkKHRpbWVTdGFtcCkge1xuICB7XG4gICAgaWYgKCFpc0luc2lkZUV2ZW50SGFuZGxlcikge1xuICAgICAgZmx1c2hEaXNjcmV0ZVVwZGF0ZXNJbXBsKCk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBzZXRCYXRjaGluZ0ltcGxlbWVudGF0aW9uKF9iYXRjaGVkVXBkYXRlc0ltcGwsIF9kaXNjcmV0ZVVwZGF0ZXNJbXBsLCBfZmx1c2hEaXNjcmV0ZVVwZGF0ZXNJbXBsLCBfYmF0Y2hlZEV2ZW50VXBkYXRlc0ltcGwpIHtcbiAgYmF0Y2hlZFVwZGF0ZXNJbXBsID0gX2JhdGNoZWRVcGRhdGVzSW1wbDtcbiAgZGlzY3JldGVVcGRhdGVzSW1wbCA9IF9kaXNjcmV0ZVVwZGF0ZXNJbXBsO1xuICBmbHVzaERpc2NyZXRlVXBkYXRlc0ltcGwgPSBfZmx1c2hEaXNjcmV0ZVVwZGF0ZXNJbXBsO1xuICBiYXRjaGVkRXZlbnRVcGRhdGVzSW1wbCA9IF9iYXRjaGVkRXZlbnRVcGRhdGVzSW1wbDtcbn1cblxuZnVuY3Rpb24gaXNJbnRlcmFjdGl2ZSh0YWcpIHtcbiAgcmV0dXJuIHRhZyA9PT0gJ2J1dHRvbicgfHwgdGFnID09PSAnaW5wdXQnIHx8IHRhZyA9PT0gJ3NlbGVjdCcgfHwgdGFnID09PSAndGV4dGFyZWEnO1xufVxuXG5mdW5jdGlvbiBzaG91bGRQcmV2ZW50TW91c2VFdmVudChuYW1lLCB0eXBlLCBwcm9wcykge1xuICBzd2l0Y2ggKG5hbWUpIHtcbiAgICBjYXNlICdvbkNsaWNrJzpcbiAgICBjYXNlICdvbkNsaWNrQ2FwdHVyZSc6XG4gICAgY2FzZSAnb25Eb3VibGVDbGljayc6XG4gICAgY2FzZSAnb25Eb3VibGVDbGlja0NhcHR1cmUnOlxuICAgIGNhc2UgJ29uTW91c2VEb3duJzpcbiAgICBjYXNlICdvbk1vdXNlRG93bkNhcHR1cmUnOlxuICAgIGNhc2UgJ29uTW91c2VNb3ZlJzpcbiAgICBjYXNlICdvbk1vdXNlTW92ZUNhcHR1cmUnOlxuICAgIGNhc2UgJ29uTW91c2VVcCc6XG4gICAgY2FzZSAnb25Nb3VzZVVwQ2FwdHVyZSc6XG4gICAgY2FzZSAnb25Nb3VzZUVudGVyJzpcbiAgICAgIHJldHVybiAhIShwcm9wcy5kaXNhYmxlZCAmJiBpc0ludGVyYWN0aXZlKHR5cGUpKTtcblxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IGluc3QgVGhlIGluc3RhbmNlLCB3aGljaCBpcyB0aGUgc291cmNlIG9mIGV2ZW50cy5cbiAqIEBwYXJhbSB7c3RyaW5nfSByZWdpc3RyYXRpb25OYW1lIE5hbWUgb2YgbGlzdGVuZXIgKGUuZy4gYG9uQ2xpY2tgKS5cbiAqIEByZXR1cm4gez9mdW5jdGlvbn0gVGhlIHN0b3JlZCBjYWxsYmFjay5cbiAqL1xuXG5cbmZ1bmN0aW9uIGdldExpc3RlbmVyKGluc3QsIHJlZ2lzdHJhdGlvbk5hbWUpIHtcbiAgdmFyIHN0YXRlTm9kZSA9IGluc3Quc3RhdGVOb2RlO1xuXG4gIGlmIChzdGF0ZU5vZGUgPT09IG51bGwpIHtcbiAgICAvLyBXb3JrIGluIHByb2dyZXNzIChleDogb25sb2FkIGV2ZW50cyBpbiBpbmNyZW1lbnRhbCBtb2RlKS5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBwcm9wcyA9IGdldEZpYmVyQ3VycmVudFByb3BzRnJvbU5vZGUoc3RhdGVOb2RlKTtcblxuICBpZiAocHJvcHMgPT09IG51bGwpIHtcbiAgICAvLyBXb3JrIGluIHByb2dyZXNzLlxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIGxpc3RlbmVyID0gcHJvcHNbcmVnaXN0cmF0aW9uTmFtZV07XG5cbiAgaWYgKHNob3VsZFByZXZlbnRNb3VzZUV2ZW50KHJlZ2lzdHJhdGlvbk5hbWUsIGluc3QudHlwZSwgcHJvcHMpKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBpZiAoISghbGlzdGVuZXIgfHwgdHlwZW9mIGxpc3RlbmVyID09PSAnZnVuY3Rpb24nKSkge1xuICAgIHtcbiAgICAgIHRocm93IEVycm9yKCBcIkV4cGVjdGVkIGBcIiArIHJlZ2lzdHJhdGlvbk5hbWUgKyBcImAgbGlzdGVuZXIgdG8gYmUgYSBmdW5jdGlvbiwgaW5zdGVhZCBnb3QgYSB2YWx1ZSBvZiBgXCIgKyB0eXBlb2YgbGlzdGVuZXIgKyBcImAgdHlwZS5cIiApO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBsaXN0ZW5lcjtcbn1cblxudmFyIHBhc3NpdmVCcm93c2VyRXZlbnRzU3VwcG9ydGVkID0gZmFsc2U7IC8vIENoZWNrIGlmIGJyb3dzZXIgc3VwcG9ydCBldmVudHMgd2l0aCBwYXNzaXZlIGxpc3RlbmVyc1xuLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0V2ZW50VGFyZ2V0L2FkZEV2ZW50TGlzdGVuZXIjU2FmZWx5X2RldGVjdGluZ19vcHRpb25fc3VwcG9ydFxuXG5pZiAoY2FuVXNlRE9NKSB7XG4gIHRyeSB7XG4gICAgdmFyIG9wdGlvbnMgPSB7fTsgLy8gJEZsb3dGaXhNZTogSWdub3JlIEZsb3cgY29tcGxhaW5pbmcgYWJvdXQgbmVlZGluZyBhIHZhbHVlXG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob3B0aW9ucywgJ3Bhc3NpdmUnLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcGFzc2l2ZUJyb3dzZXJFdmVudHNTdXBwb3J0ZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCd0ZXN0Jywgb3B0aW9ucywgb3B0aW9ucyk7XG4gICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Rlc3QnLCBvcHRpb25zLCBvcHRpb25zKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHBhc3NpdmVCcm93c2VyRXZlbnRzU3VwcG9ydGVkID0gZmFsc2U7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW52b2tlR3VhcmRlZENhbGxiYWNrUHJvZChuYW1lLCBmdW5jLCBjb250ZXh0LCBhLCBiLCBjLCBkLCBlLCBmKSB7XG4gIHZhciBmdW5jQXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMyk7XG5cbiAgdHJ5IHtcbiAgICBmdW5jLmFwcGx5KGNvbnRleHQsIGZ1bmNBcmdzKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICB0aGlzLm9uRXJyb3IoZXJyb3IpO1xuICB9XG59XG5cbnZhciBpbnZva2VHdWFyZGVkQ2FsbGJhY2tJbXBsID0gaW52b2tlR3VhcmRlZENhbGxiYWNrUHJvZDtcblxue1xuICAvLyBJbiBERVYgbW9kZSwgd2Ugc3dhcCBvdXQgaW52b2tlR3VhcmRlZENhbGxiYWNrIGZvciBhIHNwZWNpYWwgdmVyc2lvblxuICAvLyB0aGF0IHBsYXlzIG1vcmUgbmljZWx5IHdpdGggdGhlIGJyb3dzZXIncyBEZXZUb29scy4gVGhlIGlkZWEgaXMgdG8gcHJlc2VydmVcbiAgLy8gXCJQYXVzZSBvbiBleGNlcHRpb25zXCIgYmVoYXZpb3IuIEJlY2F1c2UgUmVhY3Qgd3JhcHMgYWxsIHVzZXItcHJvdmlkZWRcbiAgLy8gZnVuY3Rpb25zIGluIGludm9rZUd1YXJkZWRDYWxsYmFjaywgYW5kIHRoZSBwcm9kdWN0aW9uIHZlcnNpb24gb2ZcbiAgLy8gaW52b2tlR3VhcmRlZENhbGxiYWNrIHVzZXMgYSB0cnktY2F0Y2gsIGFsbCB1c2VyIGV4Y2VwdGlvbnMgYXJlIHRyZWF0ZWRcbiAgLy8gbGlrZSBjYXVnaHQgZXhjZXB0aW9ucywgYW5kIHRoZSBEZXZUb29scyB3b24ndCBwYXVzZSB1bmxlc3MgdGhlIGRldmVsb3BlclxuICAvLyB0YWtlcyB0aGUgZXh0cmEgc3RlcCBvZiBlbmFibGluZyBwYXVzZSBvbiBjYXVnaHQgZXhjZXB0aW9ucy4gVGhpcyBpc1xuICAvLyB1bmludHVpdGl2ZSwgdGhvdWdoLCBiZWNhdXNlIGV2ZW4gdGhvdWdoIFJlYWN0IGhhcyBjYXVnaHQgdGhlIGVycm9yLCBmcm9tXG4gIC8vIHRoZSBkZXZlbG9wZXIncyBwZXJzcGVjdGl2ZSwgdGhlIGVycm9yIGlzIHVuY2F1Z2h0LlxuICAvL1xuICAvLyBUbyBwcmVzZXJ2ZSB0aGUgZXhwZWN0ZWQgXCJQYXVzZSBvbiBleGNlcHRpb25zXCIgYmVoYXZpb3IsIHdlIGRvbid0IHVzZSBhXG4gIC8vIHRyeS1jYXRjaCBpbiBERVYuIEluc3RlYWQsIHdlIHN5bmNocm9ub3VzbHkgZGlzcGF0Y2ggYSBmYWtlIGV2ZW50IHRvIGEgZmFrZVxuICAvLyBET00gbm9kZSwgYW5kIGNhbGwgdGhlIHVzZXItcHJvdmlkZWQgY2FsbGJhY2sgZnJvbSBpbnNpZGUgYW4gZXZlbnQgaGFuZGxlclxuICAvLyBmb3IgdGhhdCBmYWtlIGV2ZW50LiBJZiB0aGUgY2FsbGJhY2sgdGhyb3dzLCB0aGUgZXJyb3IgaXMgXCJjYXB0dXJlZFwiIHVzaW5nXG4gIC8vIGEgZ2xvYmFsIGV2ZW50IGhhbmRsZXIuIEJ1dCBiZWNhdXNlIHRoZSBlcnJvciBoYXBwZW5zIGluIGEgZGlmZmVyZW50XG4gIC8vIGV2ZW50IGxvb3AgY29udGV4dCwgaXQgZG9lcyBub3QgaW50ZXJydXB0IHRoZSBub3JtYWwgcHJvZ3JhbSBmbG93LlxuICAvLyBFZmZlY3RpdmVseSwgdGhpcyBnaXZlcyB1cyB0cnktY2F0Y2ggYmVoYXZpb3Igd2l0aG91dCBhY3R1YWxseSB1c2luZ1xuICAvLyB0cnktY2F0Y2guIE5lYXQhXG4gIC8vIENoZWNrIHRoYXQgdGhlIGJyb3dzZXIgc3VwcG9ydHMgdGhlIEFQSXMgd2UgbmVlZCB0byBpbXBsZW1lbnQgb3VyIHNwZWNpYWxcbiAgLy8gREVWIHZlcnNpb24gb2YgaW52b2tlR3VhcmRlZENhbGxiYWNrXG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2Ygd2luZG93LmRpc3BhdGNoRXZlbnQgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgZG9jdW1lbnQuY3JlYXRlRXZlbnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICB2YXIgZmFrZU5vZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdyZWFjdCcpO1xuXG4gICAgaW52b2tlR3VhcmRlZENhbGxiYWNrSW1wbCA9IGZ1bmN0aW9uIGludm9rZUd1YXJkZWRDYWxsYmFja0RldihuYW1lLCBmdW5jLCBjb250ZXh0LCBhLCBiLCBjLCBkLCBlLCBmKSB7XG4gICAgICAvLyBJZiBkb2N1bWVudCBkb2Vzbid0IGV4aXN0IHdlIGtub3cgZm9yIHN1cmUgd2Ugd2lsbCBjcmFzaCBpbiB0aGlzIG1ldGhvZFxuICAgICAgLy8gd2hlbiB3ZSBjYWxsIGRvY3VtZW50LmNyZWF0ZUV2ZW50KCkuIEhvd2V2ZXIgdGhpcyBjYW4gY2F1c2UgY29uZnVzaW5nXG4gICAgICAvLyBlcnJvcnM6IGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9va2luY3ViYXRvci9jcmVhdGUtcmVhY3QtYXBwL2lzc3Vlcy8zNDgyXG4gICAgICAvLyBTbyB3ZSBwcmVlbXB0aXZlbHkgdGhyb3cgd2l0aCBhIGJldHRlciBtZXNzYWdlIGluc3RlYWQuXG4gICAgICBpZiAoISh0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnKSkge1xuICAgICAgICB7XG4gICAgICAgICAgdGhyb3cgRXJyb3IoIFwiVGhlIGBkb2N1bWVudGAgZ2xvYmFsIHdhcyBkZWZpbmVkIHdoZW4gUmVhY3Qgd2FzIGluaXRpYWxpemVkLCBidXQgaXMgbm90IGRlZmluZWQgYW55bW9yZS4gVGhpcyBjYW4gaGFwcGVuIGluIGEgdGVzdCBlbnZpcm9ubWVudCBpZiBhIGNvbXBvbmVudCBzY2hlZHVsZXMgYW4gdXBkYXRlIGZyb20gYW4gYXN5bmNocm9ub3VzIGNhbGxiYWNrLCBidXQgdGhlIHRlc3QgaGFzIGFscmVhZHkgZmluaXNoZWQgcnVubmluZy4gVG8gc29sdmUgdGhpcywgeW91IGNhbiBlaXRoZXIgdW5tb3VudCB0aGUgY29tcG9uZW50IGF0IHRoZSBlbmQgb2YgeW91ciB0ZXN0IChhbmQgZW5zdXJlIHRoYXQgYW55IGFzeW5jaHJvbm91cyBvcGVyYXRpb25zIGdldCBjYW5jZWxlZCBpbiBgY29tcG9uZW50V2lsbFVubW91bnRgKSwgb3IgeW91IGNhbiBjaGFuZ2UgdGhlIHRlc3QgaXRzZWxmIHRvIGJlIGFzeW5jaHJvbm91cy5cIiApO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBldnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnRXZlbnQnKTtcbiAgICAgIHZhciBkaWRDYWxsID0gZmFsc2U7IC8vIEtlZXBzIHRyYWNrIG9mIHdoZXRoZXIgdGhlIHVzZXItcHJvdmlkZWQgY2FsbGJhY2sgdGhyZXcgYW4gZXJyb3IuIFdlXG4gICAgICAvLyBzZXQgdGhpcyB0byB0cnVlIGF0IHRoZSBiZWdpbm5pbmcsIHRoZW4gc2V0IGl0IHRvIGZhbHNlIHJpZ2h0IGFmdGVyXG4gICAgICAvLyBjYWxsaW5nIHRoZSBmdW5jdGlvbi4gSWYgdGhlIGZ1bmN0aW9uIGVycm9ycywgYGRpZEVycm9yYCB3aWxsIG5ldmVyIGJlXG4gICAgICAvLyBzZXQgdG8gZmFsc2UuIFRoaXMgc3RyYXRlZ3kgd29ya3MgZXZlbiBpZiB0aGUgYnJvd3NlciBpcyBmbGFreSBhbmRcbiAgICAgIC8vIGZhaWxzIHRvIGNhbGwgb3VyIGdsb2JhbCBlcnJvciBoYW5kbGVyLCBiZWNhdXNlIGl0IGRvZXNuJ3QgcmVseSBvblxuICAgICAgLy8gdGhlIGVycm9yIGV2ZW50IGF0IGFsbC5cblxuICAgICAgdmFyIGRpZEVycm9yID0gdHJ1ZTsgLy8gS2VlcHMgdHJhY2sgb2YgdGhlIHZhbHVlIG9mIHdpbmRvdy5ldmVudCBzbyB0aGF0IHdlIGNhbiByZXNldCBpdFxuICAgICAgLy8gZHVyaW5nIHRoZSBjYWxsYmFjayB0byBsZXQgdXNlciBjb2RlIGFjY2VzcyB3aW5kb3cuZXZlbnQgaW4gdGhlXG4gICAgICAvLyBicm93c2VycyB0aGF0IHN1cHBvcnQgaXQuXG5cbiAgICAgIHZhciB3aW5kb3dFdmVudCA9IHdpbmRvdy5ldmVudDsgLy8gS2VlcHMgdHJhY2sgb2YgdGhlIGRlc2NyaXB0b3Igb2Ygd2luZG93LmV2ZW50IHRvIHJlc3RvcmUgaXQgYWZ0ZXIgZXZlbnRcbiAgICAgIC8vIGRpc3BhdGNoaW5nOiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzEzNjg4XG5cbiAgICAgIHZhciB3aW5kb3dFdmVudERlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHdpbmRvdywgJ2V2ZW50Jyk7XG5cbiAgICAgIGZ1bmN0aW9uIHJlc3RvcmVBZnRlckRpc3BhdGNoKCkge1xuICAgICAgICAvLyBXZSBpbW1lZGlhdGVseSByZW1vdmUgdGhlIGNhbGxiYWNrIGZyb20gZXZlbnQgbGlzdGVuZXJzIHNvIHRoYXRcbiAgICAgICAgLy8gbmVzdGVkIGBpbnZva2VHdWFyZGVkQ2FsbGJhY2tgIGNhbGxzIGRvIG5vdCBjbGFzaC4gT3RoZXJ3aXNlLCBhXG4gICAgICAgIC8vIG5lc3RlZCBjYWxsIHdvdWxkIHRyaWdnZXIgdGhlIGZha2UgZXZlbnQgaGFuZGxlcnMgb2YgYW55IGNhbGwgaGlnaGVyXG4gICAgICAgIC8vIGluIHRoZSBzdGFjay5cbiAgICAgICAgZmFrZU5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihldnRUeXBlLCBjYWxsQ2FsbGJhY2ssIGZhbHNlKTsgLy8gV2UgY2hlY2sgZm9yIHdpbmRvdy5oYXNPd25Qcm9wZXJ0eSgnZXZlbnQnKSB0byBwcmV2ZW50IHRoZVxuICAgICAgICAvLyB3aW5kb3cuZXZlbnQgYXNzaWdubWVudCBpbiBib3RoIElFIDw9IDEwIGFzIHRoZXkgdGhyb3cgYW4gZXJyb3JcbiAgICAgICAgLy8gXCJNZW1iZXIgbm90IGZvdW5kXCIgaW4gc3RyaWN0IG1vZGUsIGFuZCBpbiBGaXJlZm94IHdoaWNoIGRvZXMgbm90XG4gICAgICAgIC8vIHN1cHBvcnQgd2luZG93LmV2ZW50LlxuXG4gICAgICAgIGlmICh0eXBlb2Ygd2luZG93LmV2ZW50ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuaGFzT3duUHJvcGVydHkoJ2V2ZW50JykpIHtcbiAgICAgICAgICB3aW5kb3cuZXZlbnQgPSB3aW5kb3dFdmVudDtcbiAgICAgICAgfVxuICAgICAgfSAvLyBDcmVhdGUgYW4gZXZlbnQgaGFuZGxlciBmb3Igb3VyIGZha2UgZXZlbnQuIFdlIHdpbGwgc3luY2hyb25vdXNseVxuICAgICAgLy8gZGlzcGF0Y2ggb3VyIGZha2UgZXZlbnQgdXNpbmcgYGRpc3BhdGNoRXZlbnRgLiBJbnNpZGUgdGhlIGhhbmRsZXIsIHdlXG4gICAgICAvLyBjYWxsIHRoZSB1c2VyLXByb3ZpZGVkIGNhbGxiYWNrLlxuXG5cbiAgICAgIHZhciBmdW5jQXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMyk7XG5cbiAgICAgIGZ1bmN0aW9uIGNhbGxDYWxsYmFjaygpIHtcbiAgICAgICAgZGlkQ2FsbCA9IHRydWU7XG4gICAgICAgIHJlc3RvcmVBZnRlckRpc3BhdGNoKCk7XG4gICAgICAgIGZ1bmMuYXBwbHkoY29udGV4dCwgZnVuY0FyZ3MpO1xuICAgICAgICBkaWRFcnJvciA9IGZhbHNlO1xuICAgICAgfSAvLyBDcmVhdGUgYSBnbG9iYWwgZXJyb3IgZXZlbnQgaGFuZGxlci4gV2UgdXNlIHRoaXMgdG8gY2FwdHVyZSB0aGUgdmFsdWVcbiAgICAgIC8vIHRoYXQgd2FzIHRocm93bi4gSXQncyBwb3NzaWJsZSB0aGF0IHRoaXMgZXJyb3IgaGFuZGxlciB3aWxsIGZpcmUgbW9yZVxuICAgICAgLy8gdGhhbiBvbmNlOyBmb3IgZXhhbXBsZSwgaWYgbm9uLVJlYWN0IGNvZGUgYWxzbyBjYWxscyBgZGlzcGF0Y2hFdmVudGBcbiAgICAgIC8vIGFuZCBhIGhhbmRsZXIgZm9yIHRoYXQgZXZlbnQgdGhyb3dzLiBXZSBzaG91bGQgYmUgcmVzaWxpZW50IHRvIG1vc3Qgb2ZcbiAgICAgIC8vIHRob3NlIGNhc2VzLiBFdmVuIGlmIG91ciBlcnJvciBldmVudCBoYW5kbGVyIGZpcmVzIG1vcmUgdGhhbiBvbmNlLCB0aGVcbiAgICAgIC8vIGxhc3QgZXJyb3IgZXZlbnQgaXMgYWx3YXlzIHVzZWQuIElmIHRoZSBjYWxsYmFjayBhY3R1YWxseSBkb2VzIGVycm9yLFxuICAgICAgLy8gd2Uga25vdyB0aGF0IHRoZSBsYXN0IGVycm9yIGV2ZW50IGlzIHRoZSBjb3JyZWN0IG9uZSwgYmVjYXVzZSBpdCdzIG5vdFxuICAgICAgLy8gcG9zc2libGUgZm9yIGFueXRoaW5nIGVsc2UgdG8gaGF2ZSBoYXBwZW5lZCBpbiBiZXR3ZWVuIG91ciBjYWxsYmFja1xuICAgICAgLy8gZXJyb3JpbmcgYW5kIHRoZSBjb2RlIHRoYXQgZm9sbG93cyB0aGUgYGRpc3BhdGNoRXZlbnRgIGNhbGwgYmVsb3cuIElmXG4gICAgICAvLyB0aGUgY2FsbGJhY2sgZG9lc24ndCBlcnJvciwgYnV0IHRoZSBlcnJvciBldmVudCB3YXMgZmlyZWQsIHdlIGtub3cgdG9cbiAgICAgIC8vIGlnbm9yZSBpdCBiZWNhdXNlIGBkaWRFcnJvcmAgd2lsbCBiZSBmYWxzZSwgYXMgZGVzY3JpYmVkIGFib3ZlLlxuXG5cbiAgICAgIHZhciBlcnJvcjsgLy8gVXNlIHRoaXMgdG8gdHJhY2sgd2hldGhlciB0aGUgZXJyb3IgZXZlbnQgaXMgZXZlciBjYWxsZWQuXG5cbiAgICAgIHZhciBkaWRTZXRFcnJvciA9IGZhbHNlO1xuICAgICAgdmFyIGlzQ3Jvc3NPcmlnaW5FcnJvciA9IGZhbHNlO1xuXG4gICAgICBmdW5jdGlvbiBoYW5kbGVXaW5kb3dFcnJvcihldmVudCkge1xuICAgICAgICBlcnJvciA9IGV2ZW50LmVycm9yO1xuICAgICAgICBkaWRTZXRFcnJvciA9IHRydWU7XG5cbiAgICAgICAgaWYgKGVycm9yID09PSBudWxsICYmIGV2ZW50LmNvbG5vID09PSAwICYmIGV2ZW50LmxpbmVubyA9PT0gMCkge1xuICAgICAgICAgIGlzQ3Jvc3NPcmlnaW5FcnJvciA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZXZlbnQuZGVmYXVsdFByZXZlbnRlZCkge1xuICAgICAgICAgIC8vIFNvbWUgb3RoZXIgZXJyb3IgaGFuZGxlciBoYXMgcHJldmVudGVkIGRlZmF1bHQuXG4gICAgICAgICAgLy8gQnJvd3NlcnMgc2lsZW5jZSB0aGUgZXJyb3IgcmVwb3J0IGlmIHRoaXMgaGFwcGVucy5cbiAgICAgICAgICAvLyBXZSdsbCByZW1lbWJlciB0aGlzIHRvIGxhdGVyIGRlY2lkZSB3aGV0aGVyIHRvIGxvZyBpdCBvciBub3QuXG4gICAgICAgICAgaWYgKGVycm9yICE9IG51bGwgJiYgdHlwZW9mIGVycm9yID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgZXJyb3IuX3N1cHByZXNzTG9nZ2luZyA9IHRydWU7XG4gICAgICAgICAgICB9IGNhdGNoIChpbm5lcikgey8vIElnbm9yZS5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gLy8gQ3JlYXRlIGEgZmFrZSBldmVudCB0eXBlLlxuXG5cbiAgICAgIHZhciBldnRUeXBlID0gXCJyZWFjdC1cIiArIChuYW1lID8gbmFtZSA6ICdpbnZva2VndWFyZGVkY2FsbGJhY2snKTsgLy8gQXR0YWNoIG91ciBldmVudCBoYW5kbGVyc1xuXG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignZXJyb3InLCBoYW5kbGVXaW5kb3dFcnJvcik7XG4gICAgICBmYWtlTm9kZS5hZGRFdmVudExpc3RlbmVyKGV2dFR5cGUsIGNhbGxDYWxsYmFjaywgZmFsc2UpOyAvLyBTeW5jaHJvbm91c2x5IGRpc3BhdGNoIG91ciBmYWtlIGV2ZW50LiBJZiB0aGUgdXNlci1wcm92aWRlZCBmdW5jdGlvblxuICAgICAgLy8gZXJyb3JzLCBpdCB3aWxsIHRyaWdnZXIgb3VyIGdsb2JhbCBlcnJvciBoYW5kbGVyLlxuXG4gICAgICBldnQuaW5pdEV2ZW50KGV2dFR5cGUsIGZhbHNlLCBmYWxzZSk7XG4gICAgICBmYWtlTm9kZS5kaXNwYXRjaEV2ZW50KGV2dCk7XG5cbiAgICAgIGlmICh3aW5kb3dFdmVudERlc2NyaXB0b3IpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHdpbmRvdywgJ2V2ZW50Jywgd2luZG93RXZlbnREZXNjcmlwdG9yKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGRpZENhbGwgJiYgZGlkRXJyb3IpIHtcbiAgICAgICAgaWYgKCFkaWRTZXRFcnJvcikge1xuICAgICAgICAgIC8vIFRoZSBjYWxsYmFjayBlcnJvcmVkLCBidXQgdGhlIGVycm9yIGV2ZW50IG5ldmVyIGZpcmVkLlxuICAgICAgICAgIGVycm9yID0gbmV3IEVycm9yKCdBbiBlcnJvciB3YXMgdGhyb3duIGluc2lkZSBvbmUgb2YgeW91ciBjb21wb25lbnRzLCBidXQgUmVhY3QgJyArIFwiZG9lc24ndCBrbm93IHdoYXQgaXQgd2FzLiBUaGlzIGlzIGxpa2VseSBkdWUgdG8gYnJvd3NlciBcIiArICdmbGFraW5lc3MuIFJlYWN0IGRvZXMgaXRzIGJlc3QgdG8gcHJlc2VydmUgdGhlIFwiUGF1c2Ugb24gJyArICdleGNlcHRpb25zXCIgYmVoYXZpb3Igb2YgdGhlIERldlRvb2xzLCB3aGljaCByZXF1aXJlcyBzb21lICcgKyBcIkRFVi1tb2RlIG9ubHkgdHJpY2tzLiBJdCdzIHBvc3NpYmxlIHRoYXQgdGhlc2UgZG9uJ3Qgd29yayBpbiBcIiArICd5b3VyIGJyb3dzZXIuIFRyeSB0cmlnZ2VyaW5nIHRoZSBlcnJvciBpbiBwcm9kdWN0aW9uIG1vZGUsICcgKyAnb3Igc3dpdGNoaW5nIHRvIGEgbW9kZXJuIGJyb3dzZXIuIElmIHlvdSBzdXNwZWN0IHRoYXQgdGhpcyBpcyAnICsgJ2FjdHVhbGx5IGFuIGlzc3VlIHdpdGggUmVhY3QsIHBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgICAgICB9IGVsc2UgaWYgKGlzQ3Jvc3NPcmlnaW5FcnJvcikge1xuICAgICAgICAgIGVycm9yID0gbmV3IEVycm9yKFwiQSBjcm9zcy1vcmlnaW4gZXJyb3Igd2FzIHRocm93bi4gUmVhY3QgZG9lc24ndCBoYXZlIGFjY2VzcyB0byBcIiArICd0aGUgYWN0dWFsIGVycm9yIG9iamVjdCBpbiBkZXZlbG9wbWVudC4gJyArICdTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL2Nyb3Nzb3JpZ2luLWVycm9yIGZvciBtb3JlIGluZm9ybWF0aW9uLicpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5vbkVycm9yKGVycm9yKTtcbiAgICAgIH0gLy8gUmVtb3ZlIG91ciBldmVudCBsaXN0ZW5lcnNcblxuXG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignZXJyb3InLCBoYW5kbGVXaW5kb3dFcnJvcik7XG5cbiAgICAgIGlmICghZGlkQ2FsbCkge1xuICAgICAgICAvLyBTb21ldGhpbmcgd2VudCByZWFsbHkgd3JvbmcsIGFuZCBvdXIgZXZlbnQgd2FzIG5vdCBkaXNwYXRjaGVkLlxuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzE2NzM0XG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTY1ODVcbiAgICAgICAgLy8gRmFsbCBiYWNrIHRvIHRoZSBwcm9kdWN0aW9uIGltcGxlbWVudGF0aW9uLlxuICAgICAgICByZXN0b3JlQWZ0ZXJEaXNwYXRjaCgpO1xuICAgICAgICByZXR1cm4gaW52b2tlR3VhcmRlZENhbGxiYWNrUHJvZC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuICAgIH07XG4gIH1cbn1cblxudmFyIGludm9rZUd1YXJkZWRDYWxsYmFja0ltcGwkMSA9IGludm9rZUd1YXJkZWRDYWxsYmFja0ltcGw7XG5cbnZhciBoYXNFcnJvciA9IGZhbHNlO1xudmFyIGNhdWdodEVycm9yID0gbnVsbDsgLy8gVXNlZCBieSBldmVudCBzeXN0ZW0gdG8gY2FwdHVyZS9yZXRocm93IHRoZSBmaXJzdCBlcnJvci5cblxudmFyIGhhc1JldGhyb3dFcnJvciA9IGZhbHNlO1xudmFyIHJldGhyb3dFcnJvciA9IG51bGw7XG52YXIgcmVwb3J0ZXIgPSB7XG4gIG9uRXJyb3I6IGZ1bmN0aW9uIChlcnJvcikge1xuICAgIGhhc0Vycm9yID0gdHJ1ZTtcbiAgICBjYXVnaHRFcnJvciA9IGVycm9yO1xuICB9XG59O1xuLyoqXG4gKiBDYWxsIGEgZnVuY3Rpb24gd2hpbGUgZ3VhcmRpbmcgYWdhaW5zdCBlcnJvcnMgdGhhdCBoYXBwZW5zIHdpdGhpbiBpdC5cbiAqIFJldHVybnMgYW4gZXJyb3IgaWYgaXQgdGhyb3dzLCBvdGhlcndpc2UgbnVsbC5cbiAqXG4gKiBJbiBwcm9kdWN0aW9uLCB0aGlzIGlzIGltcGxlbWVudGVkIHVzaW5nIGEgdHJ5LWNhdGNoLiBUaGUgcmVhc29uIHdlIGRvbid0XG4gKiB1c2UgYSB0cnktY2F0Y2ggZGlyZWN0bHkgaXMgc28gdGhhdCB3ZSBjYW4gc3dhcCBvdXQgYSBkaWZmZXJlbnRcbiAqIGltcGxlbWVudGF0aW9uIGluIERFViBtb2RlLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIG9mIHRoZSBndWFyZCB0byB1c2UgZm9yIGxvZ2dpbmcgb3IgZGVidWdnaW5nXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBpbnZva2VcbiAqIEBwYXJhbSB7Kn0gY29udGV4dCBUaGUgY29udGV4dCB0byB1c2Ugd2hlbiBjYWxsaW5nIHRoZSBmdW5jdGlvblxuICogQHBhcmFtIHsuLi4qfSBhcmdzIEFyZ3VtZW50cyBmb3IgZnVuY3Rpb25cbiAqL1xuXG5mdW5jdGlvbiBpbnZva2VHdWFyZGVkQ2FsbGJhY2sobmFtZSwgZnVuYywgY29udGV4dCwgYSwgYiwgYywgZCwgZSwgZikge1xuICBoYXNFcnJvciA9IGZhbHNlO1xuICBjYXVnaHRFcnJvciA9IG51bGw7XG4gIGludm9rZUd1YXJkZWRDYWxsYmFja0ltcGwkMS5hcHBseShyZXBvcnRlciwgYXJndW1lbnRzKTtcbn1cbi8qKlxuICogU2FtZSBhcyBpbnZva2VHdWFyZGVkQ2FsbGJhY2ssIGJ1dCBpbnN0ZWFkIG9mIHJldHVybmluZyBhbiBlcnJvciwgaXQgc3RvcmVzXG4gKiBpdCBpbiBhIGdsb2JhbCBzbyBpdCBjYW4gYmUgcmV0aHJvd24gYnkgYHJldGhyb3dDYXVnaHRFcnJvcmAgbGF0ZXIuXG4gKiBUT0RPOiBTZWUgaWYgY2F1Z2h0RXJyb3IgYW5kIHJldGhyb3dFcnJvciBjYW4gYmUgdW5pZmllZC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBvZiB0aGUgZ3VhcmQgdG8gdXNlIGZvciBsb2dnaW5nIG9yIGRlYnVnZ2luZ1xuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gaW52b2tlXG4gKiBAcGFyYW0geyp9IGNvbnRleHQgVGhlIGNvbnRleHQgdG8gdXNlIHdoZW4gY2FsbGluZyB0aGUgZnVuY3Rpb25cbiAqIEBwYXJhbSB7Li4uKn0gYXJncyBBcmd1bWVudHMgZm9yIGZ1bmN0aW9uXG4gKi9cblxuZnVuY3Rpb24gaW52b2tlR3VhcmRlZENhbGxiYWNrQW5kQ2F0Y2hGaXJzdEVycm9yKG5hbWUsIGZ1bmMsIGNvbnRleHQsIGEsIGIsIGMsIGQsIGUsIGYpIHtcbiAgaW52b2tlR3VhcmRlZENhbGxiYWNrLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgaWYgKGhhc0Vycm9yKSB7XG4gICAgdmFyIGVycm9yID0gY2xlYXJDYXVnaHRFcnJvcigpO1xuXG4gICAgaWYgKCFoYXNSZXRocm93RXJyb3IpIHtcbiAgICAgIGhhc1JldGhyb3dFcnJvciA9IHRydWU7XG4gICAgICByZXRocm93RXJyb3IgPSBlcnJvcjtcbiAgICB9XG4gIH1cbn1cbi8qKlxuICogRHVyaW5nIGV4ZWN1dGlvbiBvZiBndWFyZGVkIGZ1bmN0aW9ucyB3ZSB3aWxsIGNhcHR1cmUgdGhlIGZpcnN0IGVycm9yIHdoaWNoXG4gKiB3ZSB3aWxsIHJldGhyb3cgdG8gYmUgaGFuZGxlZCBieSB0aGUgdG9wIGxldmVsIGVycm9yIGhhbmRsZXIuXG4gKi9cblxuZnVuY3Rpb24gcmV0aHJvd0NhdWdodEVycm9yKCkge1xuICBpZiAoaGFzUmV0aHJvd0Vycm9yKSB7XG4gICAgdmFyIGVycm9yID0gcmV0aHJvd0Vycm9yO1xuICAgIGhhc1JldGhyb3dFcnJvciA9IGZhbHNlO1xuICAgIHJldGhyb3dFcnJvciA9IG51bGw7XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbn1cbmZ1bmN0aW9uIGhhc0NhdWdodEVycm9yKCkge1xuICByZXR1cm4gaGFzRXJyb3I7XG59XG5mdW5jdGlvbiBjbGVhckNhdWdodEVycm9yKCkge1xuICBpZiAoaGFzRXJyb3IpIHtcbiAgICB2YXIgZXJyb3IgPSBjYXVnaHRFcnJvcjtcbiAgICBoYXNFcnJvciA9IGZhbHNlO1xuICAgIGNhdWdodEVycm9yID0gbnVsbDtcbiAgICByZXR1cm4gZXJyb3I7XG4gIH0gZWxzZSB7XG4gICAge1xuICAgICAge1xuICAgICAgICB0aHJvdyBFcnJvciggXCJjbGVhckNhdWdodEVycm9yIHdhcyBjYWxsZWQgYnV0IG5vIGVycm9yIHdhcyBjYXB0dXJlZC4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS5cIiApO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIGBSZWFjdEluc3RhbmNlTWFwYCBtYWludGFpbnMgYSBtYXBwaW5nIGZyb20gYSBwdWJsaWMgZmFjaW5nIHN0YXRlZnVsXG4gKiBpbnN0YW5jZSAoa2V5KSBhbmQgdGhlIGludGVybmFsIHJlcHJlc2VudGF0aW9uICh2YWx1ZSkuIFRoaXMgYWxsb3dzIHB1YmxpY1xuICogbWV0aG9kcyB0byBhY2NlcHQgdGhlIHVzZXIgZmFjaW5nIGluc3RhbmNlIGFzIGFuIGFyZ3VtZW50IGFuZCBtYXAgdGhlbSBiYWNrXG4gKiB0byBpbnRlcm5hbCBtZXRob2RzLlxuICpcbiAqIE5vdGUgdGhhdCB0aGlzIG1vZHVsZSBpcyBjdXJyZW50bHkgc2hhcmVkIGFuZCBhc3N1bWVkIHRvIGJlIHN0YXRlbGVzcy5cbiAqIElmIHRoaXMgYmVjb21lcyBhbiBhY3R1YWwgTWFwLCB0aGF0IHdpbGwgYnJlYWsuXG4gKi9cbmZ1bmN0aW9uIGdldChrZXkpIHtcbiAgcmV0dXJuIGtleS5fcmVhY3RJbnRlcm5hbHM7XG59XG5mdW5jdGlvbiBoYXMoa2V5KSB7XG4gIHJldHVybiBrZXkuX3JlYWN0SW50ZXJuYWxzICE9PSB1bmRlZmluZWQ7XG59XG5mdW5jdGlvbiBzZXQoa2V5LCB2YWx1ZSkge1xuICBrZXkuX3JlYWN0SW50ZXJuYWxzID0gdmFsdWU7XG59XG5cbi8vIERvbid0IGNoYW5nZSB0aGVzZSB0d28gdmFsdWVzLiBUaGV5J3JlIHVzZWQgYnkgUmVhY3QgRGV2IFRvb2xzLlxudmFyIE5vRmxhZ3MgPVxuLyogICAgICAgICAgICAgICAgICAgICAgKi9cbjA7XG52YXIgUGVyZm9ybWVkV29yayA9XG4vKiAgICAgICAgICAgICAgICAqL1xuMTsgLy8gWW91IGNhbiBjaGFuZ2UgdGhlIHJlc3QgKGFuZCBhZGQgbW9yZSkuXG5cbnZhciBQbGFjZW1lbnQgPVxuLyogICAgICAgICAgICAgICAgICAgICovXG4yO1xudmFyIFVwZGF0ZSA9XG4vKiAgICAgICAgICAgICAgICAgICAgICAgKi9cbjQ7XG52YXIgUGxhY2VtZW50QW5kVXBkYXRlID1cbi8qICAgICAgICAgICAqL1xuNjtcbnZhciBEZWxldGlvbiA9XG4vKiAgICAgICAgICAgICAgICAgICAgICovXG44O1xudmFyIENvbnRlbnRSZXNldCA9XG4vKiAgICAgICAgICAgICAgICAgKi9cbjE2O1xudmFyIENhbGxiYWNrID1cbi8qICAgICAgICAgICAgICAgICAgICAgKi9cbjMyO1xudmFyIERpZENhcHR1cmUgPVxuLyogICAgICAgICAgICAgICAgICAgKi9cbjY0O1xudmFyIFJlZiA9XG4vKiAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cbjEyODtcbnZhciBTbmFwc2hvdCA9XG4vKiAgICAgICAgICAgICAgICAgICAgICovXG4yNTY7XG52YXIgUGFzc2l2ZSA9XG4vKiAgICAgICAgICAgICAgICAgICAgICAqL1xuNTEyOyAvLyBUT0RPIChlZmZlY3RzKSBSZW1vdmUgdGhpcyBiaXQgb25jZSB0aGUgbmV3IHJlY29uY2lsZXIgaXMgc3luY2VkIHRvIHRoZSBvbGQuXG5cbnZhciBQYXNzaXZlVW5tb3VudFBlbmRpbmdEZXYgPVxuLyogICAgICovXG44MTkyO1xudmFyIEh5ZHJhdGluZyA9XG4vKiAgICAgICAgICAgICAgICAgICAgKi9cbjEwMjQ7XG52YXIgSHlkcmF0aW5nQW5kVXBkYXRlID1cbi8qICAgICAgICAgICAqL1xuMTAyODsgLy8gUGFzc2l2ZSAmIFVwZGF0ZSAmIENhbGxiYWNrICYgUmVmICYgU25hcHNob3RcblxudmFyIExpZmVjeWNsZUVmZmVjdE1hc2sgPVxuLyogICAgICAgICAgKi9cbjkzMjsgLy8gVW5pb24gb2YgYWxsIGhvc3QgZWZmZWN0c1xuXG52YXIgSG9zdEVmZmVjdE1hc2sgPVxuLyogICAgICAgICAgICAgICAqL1xuMjA0NzsgLy8gVGhlc2UgYXJlIG5vdCByZWFsbHkgc2lkZSBlZmZlY3RzLCBidXQgd2Ugc3RpbGwgcmV1c2UgdGhpcyBmaWVsZC5cblxudmFyIEluY29tcGxldGUgPVxuLyogICAgICAgICAgICAgICAgICAgKi9cbjIwNDg7XG52YXIgU2hvdWxkQ2FwdHVyZSA9XG4vKiAgICAgICAgICAgICAgICAqL1xuNDA5NjtcbnZhciBGb3JjZVVwZGF0ZUZvckxlZ2FjeVN1c3BlbnNlID1cbi8qICovXG4xNjM4NDsgLy8gU3RhdGljIHRhZ3MgZGVzY3JpYmUgYXNwZWN0cyBvZiBhIGZpYmVyIHRoYXQgYXJlIG5vdCBzcGVjaWZpYyB0byBhIHJlbmRlcixcblxudmFyIFJlYWN0Q3VycmVudE93bmVyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3RDdXJyZW50T3duZXI7XG5mdW5jdGlvbiBnZXROZWFyZXN0TW91bnRlZEZpYmVyKGZpYmVyKSB7XG4gIHZhciBub2RlID0gZmliZXI7XG4gIHZhciBuZWFyZXN0TW91bnRlZCA9IGZpYmVyO1xuXG4gIGlmICghZmliZXIuYWx0ZXJuYXRlKSB7XG4gICAgLy8gSWYgdGhlcmUgaXMgbm8gYWx0ZXJuYXRlLCB0aGlzIG1pZ2h0IGJlIGEgbmV3IHRyZWUgdGhhdCBpc24ndCBpbnNlcnRlZFxuICAgIC8vIHlldC4gSWYgaXQgaXMsIHRoZW4gaXQgd2lsbCBoYXZlIGEgcGVuZGluZyBpbnNlcnRpb24gZWZmZWN0IG9uIGl0LlxuICAgIHZhciBuZXh0Tm9kZSA9IG5vZGU7XG5cbiAgICBkbyB7XG4gICAgICBub2RlID0gbmV4dE5vZGU7XG5cbiAgICAgIGlmICgobm9kZS5mbGFncyAmIChQbGFjZW1lbnQgfCBIeWRyYXRpbmcpKSAhPT0gTm9GbGFncykge1xuICAgICAgICAvLyBUaGlzIGlzIGFuIGluc2VydGlvbiBvciBpbi1wcm9ncmVzcyBoeWRyYXRpb24uIFRoZSBuZWFyZXN0IHBvc3NpYmxlXG4gICAgICAgIC8vIG1vdW50ZWQgZmliZXIgaXMgdGhlIHBhcmVudCBidXQgd2UgbmVlZCB0byBjb250aW51ZSB0byBmaWd1cmUgb3V0XG4gICAgICAgIC8vIGlmIHRoYXQgb25lIGlzIHN0aWxsIG1vdW50ZWQuXG4gICAgICAgIG5lYXJlc3RNb3VudGVkID0gbm9kZS5yZXR1cm47XG4gICAgICB9XG5cbiAgICAgIG5leHROb2RlID0gbm9kZS5yZXR1cm47XG4gICAgfSB3aGlsZSAobmV4dE5vZGUpO1xuICB9IGVsc2Uge1xuICAgIHdoaWxlIChub2RlLnJldHVybikge1xuICAgICAgbm9kZSA9IG5vZGUucmV0dXJuO1xuICAgIH1cbiAgfVxuXG4gIGlmIChub2RlLnRhZyA9PT0gSG9zdFJvb3QpIHtcbiAgICAvLyBUT0RPOiBDaGVjayBpZiB0aGlzIHdhcyBhIG5lc3RlZCBIb3N0Um9vdCB3aGVuIHVzZWQgd2l0aFxuICAgIC8vIHJlbmRlckNvbnRhaW5lckludG9TdWJ0cmVlLlxuICAgIHJldHVybiBuZWFyZXN0TW91bnRlZDtcbiAgfSAvLyBJZiB3ZSBkaWRuJ3QgaGl0IHRoZSByb290LCB0aGF0IG1lYW5zIHRoYXQgd2UncmUgaW4gYW4gZGlzY29ubmVjdGVkIHRyZWVcbiAgLy8gdGhhdCBoYXMgYmVlbiB1bm1vdW50ZWQuXG5cblxuICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGdldFN1c3BlbnNlSW5zdGFuY2VGcm9tRmliZXIoZmliZXIpIHtcbiAgaWYgKGZpYmVyLnRhZyA9PT0gU3VzcGVuc2VDb21wb25lbnQpIHtcbiAgICB2YXIgc3VzcGVuc2VTdGF0ZSA9IGZpYmVyLm1lbW9pemVkU3RhdGU7XG5cbiAgICBpZiAoc3VzcGVuc2VTdGF0ZSA9PT0gbnVsbCkge1xuICAgICAgdmFyIGN1cnJlbnQgPSBmaWJlci5hbHRlcm5hdGU7XG5cbiAgICAgIGlmIChjdXJyZW50ICE9PSBudWxsKSB7XG4gICAgICAgIHN1c3BlbnNlU3RhdGUgPSBjdXJyZW50Lm1lbW9pemVkU3RhdGU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHN1c3BlbnNlU3RhdGUgIT09IG51bGwpIHtcbiAgICAgIHJldHVybiBzdXNwZW5zZVN0YXRlLmRlaHlkcmF0ZWQ7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBnZXRDb250YWluZXJGcm9tRmliZXIoZmliZXIpIHtcbiAgcmV0dXJuIGZpYmVyLnRhZyA9PT0gSG9zdFJvb3QgPyBmaWJlci5zdGF0ZU5vZGUuY29udGFpbmVySW5mbyA6IG51bGw7XG59XG5mdW5jdGlvbiBpc0ZpYmVyTW91bnRlZChmaWJlcikge1xuICByZXR1cm4gZ2V0TmVhcmVzdE1vdW50ZWRGaWJlcihmaWJlcikgPT09IGZpYmVyO1xufVxuZnVuY3Rpb24gaXNNb3VudGVkKGNvbXBvbmVudCkge1xuICB7XG4gICAgdmFyIG93bmVyID0gUmVhY3RDdXJyZW50T3duZXIuY3VycmVudDtcblxuICAgIGlmIChvd25lciAhPT0gbnVsbCAmJiBvd25lci50YWcgPT09IENsYXNzQ29tcG9uZW50KSB7XG4gICAgICB2YXIgb3duZXJGaWJlciA9IG93bmVyO1xuICAgICAgdmFyIGluc3RhbmNlID0gb3duZXJGaWJlci5zdGF0ZU5vZGU7XG5cbiAgICAgIGlmICghaW5zdGFuY2UuX3dhcm5lZEFib3V0UmVmc0luUmVuZGVyKSB7XG4gICAgICAgIGVycm9yKCclcyBpcyBhY2Nlc3NpbmcgaXNNb3VudGVkIGluc2lkZSBpdHMgcmVuZGVyKCkgZnVuY3Rpb24uICcgKyAncmVuZGVyKCkgc2hvdWxkIGJlIGEgcHVyZSBmdW5jdGlvbiBvZiBwcm9wcyBhbmQgc3RhdGUuIEl0IHNob3VsZCAnICsgJ25ldmVyIGFjY2VzcyBzb21ldGhpbmcgdGhhdCByZXF1aXJlcyBzdGFsZSBkYXRhIGZyb20gdGhlIHByZXZpb3VzICcgKyAncmVuZGVyLCBzdWNoIGFzIHJlZnMuIE1vdmUgdGhpcyBsb2dpYyB0byBjb21wb25lbnREaWRNb3VudCBhbmQgJyArICdjb21wb25lbnREaWRVcGRhdGUgaW5zdGVhZC4nLCBnZXRDb21wb25lbnROYW1lKG93bmVyRmliZXIudHlwZSkgfHwgJ0EgY29tcG9uZW50Jyk7XG4gICAgICB9XG5cbiAgICAgIGluc3RhbmNlLl93YXJuZWRBYm91dFJlZnNJblJlbmRlciA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgdmFyIGZpYmVyID0gZ2V0KGNvbXBvbmVudCk7XG5cbiAgaWYgKCFmaWJlcikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBnZXROZWFyZXN0TW91bnRlZEZpYmVyKGZpYmVyKSA9PT0gZmliZXI7XG59XG5cbmZ1bmN0aW9uIGFzc2VydElzTW91bnRlZChmaWJlcikge1xuICBpZiAoIShnZXROZWFyZXN0TW91bnRlZEZpYmVyKGZpYmVyKSA9PT0gZmliZXIpKSB7XG4gICAge1xuICAgICAgdGhyb3cgRXJyb3IoIFwiVW5hYmxlIHRvIGZpbmQgbm9kZSBvbiBhbiB1bm1vdW50ZWQgY29tcG9uZW50LlwiICk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGZpbmRDdXJyZW50RmliZXJVc2luZ1Nsb3dQYXRoKGZpYmVyKSB7XG4gIHZhciBhbHRlcm5hdGUgPSBmaWJlci5hbHRlcm5hdGU7XG5cbiAgaWYgKCFhbHRlcm5hdGUpIHtcbiAgICAvLyBJZiB0aGVyZSBpcyBubyBhbHRlcm5hdGUsIHRoZW4gd2Ugb25seSBuZWVkIHRvIGNoZWNrIGlmIGl0IGlzIG1vdW50ZWQuXG4gICAgdmFyIG5lYXJlc3RNb3VudGVkID0gZ2V0TmVhcmVzdE1vdW50ZWRGaWJlcihmaWJlcik7XG5cbiAgICBpZiAoIShuZWFyZXN0TW91bnRlZCAhPT0gbnVsbCkpIHtcbiAgICAgIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoIFwiVW5hYmxlIHRvIGZpbmQgbm9kZSBvbiBhbiB1bm1vdW50ZWQgY29tcG9uZW50LlwiICk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG5lYXJlc3RNb3VudGVkICE9PSBmaWJlcikge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZpYmVyO1xuICB9IC8vIElmIHdlIGhhdmUgdHdvIHBvc3NpYmxlIGJyYW5jaGVzLCB3ZSdsbCB3YWxrIGJhY2t3YXJkcyB1cCB0byB0aGUgcm9vdFxuICAvLyB0byBzZWUgd2hhdCBwYXRoIHRoZSByb290IHBvaW50cyB0by4gT24gdGhlIHdheSB3ZSBtYXkgaGl0IG9uZSBvZiB0aGVcbiAgLy8gc3BlY2lhbCBjYXNlcyBhbmQgd2UnbGwgZGVhbCB3aXRoIHRoZW0uXG5cblxuICB2YXIgYSA9IGZpYmVyO1xuICB2YXIgYiA9IGFsdGVybmF0ZTtcblxuICB3aGlsZSAodHJ1ZSkge1xuICAgIHZhciBwYXJlbnRBID0gYS5yZXR1cm47XG5cbiAgICBpZiAocGFyZW50QSA9PT0gbnVsbCkge1xuICAgICAgLy8gV2UncmUgYXQgdGhlIHJvb3QuXG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICB2YXIgcGFyZW50QiA9IHBhcmVudEEuYWx0ZXJuYXRlO1xuXG4gICAgaWYgKHBhcmVudEIgPT09IG51bGwpIHtcbiAgICAgIC8vIFRoZXJlIGlzIG5vIGFsdGVybmF0ZS4gVGhpcyBpcyBhbiB1bnVzdWFsIGNhc2UuIEN1cnJlbnRseSwgaXQgb25seVxuICAgICAgLy8gaGFwcGVucyB3aGVuIGEgU3VzcGVuc2UgY29tcG9uZW50IGlzIGhpZGRlbi4gQW4gZXh0cmEgZnJhZ21lbnQgZmliZXJcbiAgICAgIC8vIGlzIGluc2VydGVkIGluIGJldHdlZW4gdGhlIFN1c3BlbnNlIGZpYmVyIGFuZCBpdHMgY2hpbGRyZW4uIFNraXBcbiAgICAgIC8vIG92ZXIgdGhpcyBleHRyYSBmcmFnbWVudCBmaWJlciBhbmQgcHJvY2VlZCB0byB0aGUgbmV4dCBwYXJlbnQuXG4gICAgICB2YXIgbmV4dFBhcmVudCA9IHBhcmVudEEucmV0dXJuO1xuXG4gICAgICBpZiAobmV4dFBhcmVudCAhPT0gbnVsbCkge1xuICAgICAgICBhID0gYiA9IG5leHRQYXJlbnQ7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfSAvLyBJZiB0aGVyZSdzIG5vIHBhcmVudCwgd2UncmUgYXQgdGhlIHJvb3QuXG5cblxuICAgICAgYnJlYWs7XG4gICAgfSAvLyBJZiBib3RoIGNvcGllcyBvZiB0aGUgcGFyZW50IGZpYmVyIHBvaW50IHRvIHRoZSBzYW1lIGNoaWxkLCB3ZSBjYW5cbiAgICAvLyBhc3N1bWUgdGhhdCB0aGUgY2hpbGQgaXMgY3VycmVudC4gVGhpcyBoYXBwZW5zIHdoZW4gd2UgYmFpbG91dCBvbiBsb3dcbiAgICAvLyBwcmlvcml0eTogdGhlIGJhaWxlZCBvdXQgZmliZXIncyBjaGlsZCByZXVzZXMgdGhlIGN1cnJlbnQgY2hpbGQuXG5cblxuICAgIGlmIChwYXJlbnRBLmNoaWxkID09PSBwYXJlbnRCLmNoaWxkKSB7XG4gICAgICB2YXIgY2hpbGQgPSBwYXJlbnRBLmNoaWxkO1xuXG4gICAgICB3aGlsZSAoY2hpbGQpIHtcbiAgICAgICAgaWYgKGNoaWxkID09PSBhKSB7XG4gICAgICAgICAgLy8gV2UndmUgZGV0ZXJtaW5lZCB0aGF0IEEgaXMgdGhlIGN1cnJlbnQgYnJhbmNoLlxuICAgICAgICAgIGFzc2VydElzTW91bnRlZChwYXJlbnRBKTtcbiAgICAgICAgICByZXR1cm4gZmliZXI7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY2hpbGQgPT09IGIpIHtcbiAgICAgICAgICAvLyBXZSd2ZSBkZXRlcm1pbmVkIHRoYXQgQiBpcyB0aGUgY3VycmVudCBicmFuY2guXG4gICAgICAgICAgYXNzZXJ0SXNNb3VudGVkKHBhcmVudEEpO1xuICAgICAgICAgIHJldHVybiBhbHRlcm5hdGU7XG4gICAgICAgIH1cblxuICAgICAgICBjaGlsZCA9IGNoaWxkLnNpYmxpbmc7XG4gICAgICB9IC8vIFdlIHNob3VsZCBuZXZlciBoYXZlIGFuIGFsdGVybmF0ZSBmb3IgYW55IG1vdW50aW5nIG5vZGUuIFNvIHRoZSBvbmx5XG4gICAgICAvLyB3YXkgdGhpcyBjb3VsZCBwb3NzaWJseSBoYXBwZW4gaXMgaWYgdGhpcyB3YXMgdW5tb3VudGVkLCBpZiBhdCBhbGwuXG5cblxuICAgICAge1xuICAgICAgICB7XG4gICAgICAgICAgdGhyb3cgRXJyb3IoIFwiVW5hYmxlIHRvIGZpbmQgbm9kZSBvbiBhbiB1bm1vdW50ZWQgY29tcG9uZW50LlwiICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoYS5yZXR1cm4gIT09IGIucmV0dXJuKSB7XG4gICAgICAvLyBUaGUgcmV0dXJuIHBvaW50ZXIgb2YgQSBhbmQgdGhlIHJldHVybiBwb2ludGVyIG9mIEIgcG9pbnQgdG8gZGlmZmVyZW50XG4gICAgICAvLyBmaWJlcnMuIFdlIGFzc3VtZSB0aGF0IHJldHVybiBwb2ludGVycyBuZXZlciBjcmlzcy1jcm9zcywgc28gQSBtdXN0XG4gICAgICAvLyBiZWxvbmcgdG8gdGhlIGNoaWxkIHNldCBvZiBBLnJldHVybiwgYW5kIEIgbXVzdCBiZWxvbmcgdG8gdGhlIGNoaWxkXG4gICAgICAvLyBzZXQgb2YgQi5yZXR1cm4uXG4gICAgICBhID0gcGFyZW50QTtcbiAgICAgIGIgPSBwYXJlbnRCO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBUaGUgcmV0dXJuIHBvaW50ZXJzIHBvaW50IHRvIHRoZSBzYW1lIGZpYmVyLiBXZSdsbCBoYXZlIHRvIHVzZSB0aGVcbiAgICAgIC8vIGRlZmF1bHQsIHNsb3cgcGF0aDogc2NhbiB0aGUgY2hpbGQgc2V0cyBvZiBlYWNoIHBhcmVudCBhbHRlcm5hdGUgdG8gc2VlXG4gICAgICAvLyB3aGljaCBjaGlsZCBiZWxvbmdzIHRvIHdoaWNoIHNldC5cbiAgICAgIC8vXG4gICAgICAvLyBTZWFyY2ggcGFyZW50IEEncyBjaGlsZCBzZXRcbiAgICAgIHZhciBkaWRGaW5kQ2hpbGQgPSBmYWxzZTtcbiAgICAgIHZhciBfY2hpbGQgPSBwYXJlbnRBLmNoaWxkO1xuXG4gICAgICB3aGlsZSAoX2NoaWxkKSB7XG4gICAgICAgIGlmIChfY2hpbGQgPT09IGEpIHtcbiAgICAgICAgICBkaWRGaW5kQ2hpbGQgPSB0cnVlO1xuICAgICAgICAgIGEgPSBwYXJlbnRBO1xuICAgICAgICAgIGIgPSBwYXJlbnRCO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKF9jaGlsZCA9PT0gYikge1xuICAgICAgICAgIGRpZEZpbmRDaGlsZCA9IHRydWU7XG4gICAgICAgICAgYiA9IHBhcmVudEE7XG4gICAgICAgICAgYSA9IHBhcmVudEI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBfY2hpbGQgPSBfY2hpbGQuc2libGluZztcbiAgICAgIH1cblxuICAgICAgaWYgKCFkaWRGaW5kQ2hpbGQpIHtcbiAgICAgICAgLy8gU2VhcmNoIHBhcmVudCBCJ3MgY2hpbGQgc2V0XG4gICAgICAgIF9jaGlsZCA9IHBhcmVudEIuY2hpbGQ7XG5cbiAgICAgICAgd2hpbGUgKF9jaGlsZCkge1xuICAgICAgICAgIGlmIChfY2hpbGQgPT09IGEpIHtcbiAgICAgICAgICAgIGRpZEZpbmRDaGlsZCA9IHRydWU7XG4gICAgICAgICAgICBhID0gcGFyZW50QjtcbiAgICAgICAgICAgIGIgPSBwYXJlbnRBO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKF9jaGlsZCA9PT0gYikge1xuICAgICAgICAgICAgZGlkRmluZENoaWxkID0gdHJ1ZTtcbiAgICAgICAgICAgIGIgPSBwYXJlbnRCO1xuICAgICAgICAgICAgYSA9IHBhcmVudEE7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBfY2hpbGQgPSBfY2hpbGQuc2libGluZztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghZGlkRmluZENoaWxkKSB7XG4gICAgICAgICAge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoIFwiQ2hpbGQgd2FzIG5vdCBmb3VuZCBpbiBlaXRoZXIgcGFyZW50IHNldC4gVGhpcyBpbmRpY2F0ZXMgYSBidWcgaW4gUmVhY3QgcmVsYXRlZCB0byB0aGUgcmV0dXJuIHBvaW50ZXIuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCEoYS5hbHRlcm5hdGUgPT09IGIpKSB7XG4gICAgICB7XG4gICAgICAgIHRocm93IEVycm9yKCBcIlJldHVybiBmaWJlcnMgc2hvdWxkIGFsd2F5cyBiZSBlYWNoIG90aGVycycgYWx0ZXJuYXRlcy4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS5cIiApO1xuICAgICAgfVxuICAgIH1cbiAgfSAvLyBJZiB0aGUgcm9vdCBpcyBub3QgYSBob3N0IGNvbnRhaW5lciwgd2UncmUgaW4gYSBkaXNjb25uZWN0ZWQgdHJlZS4gSS5lLlxuICAvLyB1bm1vdW50ZWQuXG5cblxuICBpZiAoIShhLnRhZyA9PT0gSG9zdFJvb3QpKSB7XG4gICAge1xuICAgICAgdGhyb3cgRXJyb3IoIFwiVW5hYmxlIHRvIGZpbmQgbm9kZSBvbiBhbiB1bm1vdW50ZWQgY29tcG9uZW50LlwiICk7XG4gICAgfVxuICB9XG5cbiAgaWYgKGEuc3RhdGVOb2RlLmN1cnJlbnQgPT09IGEpIHtcbiAgICAvLyBXZSd2ZSBkZXRlcm1pbmVkIHRoYXQgQSBpcyB0aGUgY3VycmVudCBicmFuY2guXG4gICAgcmV0dXJuIGZpYmVyO1xuICB9IC8vIE90aGVyd2lzZSBCIGhhcyB0byBiZSBjdXJyZW50IGJyYW5jaC5cblxuXG4gIHJldHVybiBhbHRlcm5hdGU7XG59XG5mdW5jdGlvbiBmaW5kQ3VycmVudEhvc3RGaWJlcihwYXJlbnQpIHtcbiAgdmFyIGN1cnJlbnRQYXJlbnQgPSBmaW5kQ3VycmVudEZpYmVyVXNpbmdTbG93UGF0aChwYXJlbnQpO1xuXG4gIGlmICghY3VycmVudFBhcmVudCkge1xuICAgIHJldHVybiBudWxsO1xuICB9IC8vIE5leHQgd2UnbGwgZHJpbGwgZG93biB0aGlzIGNvbXBvbmVudCB0byBmaW5kIHRoZSBmaXJzdCBIb3N0Q29tcG9uZW50L1RleHQuXG5cblxuICB2YXIgbm9kZSA9IGN1cnJlbnRQYXJlbnQ7XG5cbiAgd2hpbGUgKHRydWUpIHtcbiAgICBpZiAobm9kZS50YWcgPT09IEhvc3RDb21wb25lbnQgfHwgbm9kZS50YWcgPT09IEhvc3RUZXh0KSB7XG4gICAgICByZXR1cm4gbm9kZTtcbiAgICB9IGVsc2UgaWYgKG5vZGUuY2hpbGQpIHtcbiAgICAgIG5vZGUuY2hpbGQucmV0dXJuID0gbm9kZTtcbiAgICAgIG5vZGUgPSBub2RlLmNoaWxkO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKG5vZGUgPT09IGN1cnJlbnRQYXJlbnQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHdoaWxlICghbm9kZS5zaWJsaW5nKSB7XG4gICAgICBpZiAoIW5vZGUucmV0dXJuIHx8IG5vZGUucmV0dXJuID09PSBjdXJyZW50UGFyZW50KSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICBub2RlID0gbm9kZS5yZXR1cm47XG4gICAgfVxuXG4gICAgbm9kZS5zaWJsaW5nLnJldHVybiA9IG5vZGUucmV0dXJuO1xuICAgIG5vZGUgPSBub2RlLnNpYmxpbmc7XG4gIH0gLy8gRmxvdyBuZWVkcyB0aGUgcmV0dXJuIG51bGwgaGVyZSwgYnV0IEVTTGludCBjb21wbGFpbnMgYWJvdXQgaXQuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnJlYWNoYWJsZVxuXG5cbiAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBmaW5kQ3VycmVudEhvc3RGaWJlcldpdGhOb1BvcnRhbHMocGFyZW50KSB7XG4gIHZhciBjdXJyZW50UGFyZW50ID0gZmluZEN1cnJlbnRGaWJlclVzaW5nU2xvd1BhdGgocGFyZW50KTtcblxuICBpZiAoIWN1cnJlbnRQYXJlbnQpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfSAvLyBOZXh0IHdlJ2xsIGRyaWxsIGRvd24gdGhpcyBjb21wb25lbnQgdG8gZmluZCB0aGUgZmlyc3QgSG9zdENvbXBvbmVudC9UZXh0LlxuXG5cbiAgdmFyIG5vZGUgPSBjdXJyZW50UGFyZW50O1xuXG4gIHdoaWxlICh0cnVlKSB7XG4gICAgaWYgKG5vZGUudGFnID09PSBIb3N0Q29tcG9uZW50IHx8IG5vZGUudGFnID09PSBIb3N0VGV4dCB8fCBlbmFibGVGdW5kYW1lbnRhbEFQSSApIHtcbiAgICAgIHJldHVybiBub2RlO1xuICAgIH0gZWxzZSBpZiAobm9kZS5jaGlsZCAmJiBub2RlLnRhZyAhPT0gSG9zdFBvcnRhbCkge1xuICAgICAgbm9kZS5jaGlsZC5yZXR1cm4gPSBub2RlO1xuICAgICAgbm9kZSA9IG5vZGUuY2hpbGQ7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpZiAobm9kZSA9PT0gY3VycmVudFBhcmVudCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgd2hpbGUgKCFub2RlLnNpYmxpbmcpIHtcbiAgICAgIGlmICghbm9kZS5yZXR1cm4gfHwgbm9kZS5yZXR1cm4gPT09IGN1cnJlbnRQYXJlbnQpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIG5vZGUgPSBub2RlLnJldHVybjtcbiAgICB9XG5cbiAgICBub2RlLnNpYmxpbmcucmV0dXJuID0gbm9kZS5yZXR1cm47XG4gICAgbm9kZSA9IG5vZGUuc2libGluZztcbiAgfSAvLyBGbG93IG5lZWRzIHRoZSByZXR1cm4gbnVsbCBoZXJlLCBidXQgRVNMaW50IGNvbXBsYWlucyBhYm91dCBpdC5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVucmVhY2hhYmxlXG5cblxuICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGRvZXNGaWJlckNvbnRhaW4ocGFyZW50RmliZXIsIGNoaWxkRmliZXIpIHtcbiAgdmFyIG5vZGUgPSBjaGlsZEZpYmVyO1xuICB2YXIgcGFyZW50RmliZXJBbHRlcm5hdGUgPSBwYXJlbnRGaWJlci5hbHRlcm5hdGU7XG5cbiAgd2hpbGUgKG5vZGUgIT09IG51bGwpIHtcbiAgICBpZiAobm9kZSA9PT0gcGFyZW50RmliZXIgfHwgbm9kZSA9PT0gcGFyZW50RmliZXJBbHRlcm5hdGUpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIG5vZGUgPSBub2RlLnJldHVybjtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxudmFyIGF0dGVtcHRVc2VyQmxvY2tpbmdIeWRyYXRpb247XG5mdW5jdGlvbiBzZXRBdHRlbXB0VXNlckJsb2NraW5nSHlkcmF0aW9uKGZuKSB7XG4gIGF0dGVtcHRVc2VyQmxvY2tpbmdIeWRyYXRpb24gPSBmbjtcbn1cbnZhciBhdHRlbXB0Q29udGludW91c0h5ZHJhdGlvbjtcbmZ1bmN0aW9uIHNldEF0dGVtcHRDb250aW51b3VzSHlkcmF0aW9uKGZuKSB7XG4gIGF0dGVtcHRDb250aW51b3VzSHlkcmF0aW9uID0gZm47XG59XG52YXIgYXR0ZW1wdEh5ZHJhdGlvbkF0Q3VycmVudFByaW9yaXR5O1xuZnVuY3Rpb24gc2V0QXR0ZW1wdEh5ZHJhdGlvbkF0Q3VycmVudFByaW9yaXR5KGZuKSB7XG4gIGF0dGVtcHRIeWRyYXRpb25BdEN1cnJlbnRQcmlvcml0eSA9IGZuO1xufVxudmFyIGF0dGVtcHRIeWRyYXRpb25BdFByaW9yaXR5O1xuZnVuY3Rpb24gc2V0QXR0ZW1wdEh5ZHJhdGlvbkF0UHJpb3JpdHkoZm4pIHtcbiAgYXR0ZW1wdEh5ZHJhdGlvbkF0UHJpb3JpdHkgPSBmbjtcbn0gLy8gVE9ETzogVXBncmFkZSB0aGlzIGRlZmluaXRpb24gb25jZSB3ZSdyZSBvbiBhIG5ld2VyIHZlcnNpb24gb2YgRmxvdyB0aGF0XG52YXIgaGFzU2NoZWR1bGVkUmVwbGF5QXR0ZW1wdCA9IGZhbHNlOyAvLyBUaGUgcXVldWUgb2YgZGlzY3JldGUgZXZlbnRzIHRvIGJlIHJlcGxheWVkLlxuXG52YXIgcXVldWVkRGlzY3JldGVFdmVudHMgPSBbXTsgLy8gSW5kaWNhdGVzIGlmIGFueSBjb250aW51b3VzIGV2ZW50IHRhcmdldHMgYXJlIG5vbi1udWxsIGZvciBlYXJseSBiYWlsb3V0LlxuLy8gaWYgdGhlIGxhc3QgdGFyZ2V0IHdhcyBkZWh5ZHJhdGVkLlxuXG52YXIgcXVldWVkRm9jdXMgPSBudWxsO1xudmFyIHF1ZXVlZERyYWcgPSBudWxsO1xudmFyIHF1ZXVlZE1vdXNlID0gbnVsbDsgLy8gRm9yIHBvaW50ZXIgZXZlbnRzIHRoZXJlIGNhbiBiZSBvbmUgbGF0ZXN0IGV2ZW50IHBlciBwb2ludGVySWQuXG5cbnZhciBxdWV1ZWRQb2ludGVycyA9IG5ldyBNYXAoKTtcbnZhciBxdWV1ZWRQb2ludGVyQ2FwdHVyZXMgPSBuZXcgTWFwKCk7IC8vIFdlIGNvdWxkIGNvbnNpZGVyIHJlcGxheWluZyBzZWxlY3Rpb25jaGFuZ2UgYW5kIHRvdWNobW92ZXMgdG9vLlxuXG52YXIgcXVldWVkRXhwbGljaXRIeWRyYXRpb25UYXJnZXRzID0gW107XG5mdW5jdGlvbiBoYXNRdWV1ZWREaXNjcmV0ZUV2ZW50cygpIHtcbiAgcmV0dXJuIHF1ZXVlZERpc2NyZXRlRXZlbnRzLmxlbmd0aCA+IDA7XG59XG52YXIgZGlzY3JldGVSZXBsYXlhYmxlRXZlbnRzID0gWydtb3VzZWRvd24nLCAnbW91c2V1cCcsICd0b3VjaGNhbmNlbCcsICd0b3VjaGVuZCcsICd0b3VjaHN0YXJ0JywgJ2F1eGNsaWNrJywgJ2RibGNsaWNrJywgJ3BvaW50ZXJjYW5jZWwnLCAncG9pbnRlcmRvd24nLCAncG9pbnRlcnVwJywgJ2RyYWdlbmQnLCAnZHJhZ3N0YXJ0JywgJ2Ryb3AnLCAnY29tcG9zaXRpb25lbmQnLCAnY29tcG9zaXRpb25zdGFydCcsICdrZXlkb3duJywgJ2tleXByZXNzJywgJ2tleXVwJywgJ2lucHV0JywgJ3RleHRJbnB1dCcsIC8vIEludGVudGlvbmFsbHkgY2FtZWxDYXNlXG4nY29weScsICdjdXQnLCAncGFzdGUnLCAnY2xpY2snLCAnY2hhbmdlJywgJ2NvbnRleHRtZW51JywgJ3Jlc2V0JywgJ3N1Ym1pdCddO1xuZnVuY3Rpb24gaXNSZXBsYXlhYmxlRGlzY3JldGVFdmVudChldmVudFR5cGUpIHtcbiAgcmV0dXJuIGRpc2NyZXRlUmVwbGF5YWJsZUV2ZW50cy5pbmRleE9mKGV2ZW50VHlwZSkgPiAtMTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlUXVldWVkUmVwbGF5YWJsZUV2ZW50KGJsb2NrZWRPbiwgZG9tRXZlbnROYW1lLCBldmVudFN5c3RlbUZsYWdzLCB0YXJnZXRDb250YWluZXIsIG5hdGl2ZUV2ZW50KSB7XG4gIHJldHVybiB7XG4gICAgYmxvY2tlZE9uOiBibG9ja2VkT24sXG4gICAgZG9tRXZlbnROYW1lOiBkb21FdmVudE5hbWUsXG4gICAgZXZlbnRTeXN0ZW1GbGFnczogZXZlbnRTeXN0ZW1GbGFncyB8IElTX1JFUExBWUVELFxuICAgIG5hdGl2ZUV2ZW50OiBuYXRpdmVFdmVudCxcbiAgICB0YXJnZXRDb250YWluZXJzOiBbdGFyZ2V0Q29udGFpbmVyXVxuICB9O1xufVxuXG5mdW5jdGlvbiBxdWV1ZURpc2NyZXRlRXZlbnQoYmxvY2tlZE9uLCBkb21FdmVudE5hbWUsIGV2ZW50U3lzdGVtRmxhZ3MsIHRhcmdldENvbnRhaW5lciwgbmF0aXZlRXZlbnQpIHtcbiAgdmFyIHF1ZXVlZEV2ZW50ID0gY3JlYXRlUXVldWVkUmVwbGF5YWJsZUV2ZW50KGJsb2NrZWRPbiwgZG9tRXZlbnROYW1lLCBldmVudFN5c3RlbUZsYWdzLCB0YXJnZXRDb250YWluZXIsIG5hdGl2ZUV2ZW50KTtcbiAgcXVldWVkRGlzY3JldGVFdmVudHMucHVzaChxdWV1ZWRFdmVudCk7XG59IC8vIFJlc2V0cyB0aGUgcmVwbGF5aW5nIGZvciB0aGlzIHR5cGUgb2YgY29udGludW91cyBldmVudCB0byBubyBldmVudC5cblxuZnVuY3Rpb24gY2xlYXJJZkNvbnRpbnVvdXNFdmVudChkb21FdmVudE5hbWUsIG5hdGl2ZUV2ZW50KSB7XG4gIHN3aXRjaCAoZG9tRXZlbnROYW1lKSB7XG4gICAgY2FzZSAnZm9jdXNpbic6XG4gICAgY2FzZSAnZm9jdXNvdXQnOlxuICAgICAgcXVldWVkRm9jdXMgPSBudWxsO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdkcmFnZW50ZXInOlxuICAgIGNhc2UgJ2RyYWdsZWF2ZSc6XG4gICAgICBxdWV1ZWREcmFnID0gbnVsbDtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnbW91c2VvdmVyJzpcbiAgICBjYXNlICdtb3VzZW91dCc6XG4gICAgICBxdWV1ZWRNb3VzZSA9IG51bGw7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ3BvaW50ZXJvdmVyJzpcbiAgICBjYXNlICdwb2ludGVyb3V0JzpcbiAgICAgIHtcbiAgICAgICAgdmFyIHBvaW50ZXJJZCA9IG5hdGl2ZUV2ZW50LnBvaW50ZXJJZDtcbiAgICAgICAgcXVldWVkUG9pbnRlcnMuZGVsZXRlKHBvaW50ZXJJZCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgY2FzZSAnZ290cG9pbnRlcmNhcHR1cmUnOlxuICAgIGNhc2UgJ2xvc3Rwb2ludGVyY2FwdHVyZSc6XG4gICAgICB7XG4gICAgICAgIHZhciBfcG9pbnRlcklkID0gbmF0aXZlRXZlbnQucG9pbnRlcklkO1xuICAgICAgICBxdWV1ZWRQb2ludGVyQ2FwdHVyZXMuZGVsZXRlKF9wb2ludGVySWQpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBhY2N1bXVsYXRlT3JDcmVhdGVDb250aW51b3VzUXVldWVkUmVwbGF5YWJsZUV2ZW50KGV4aXN0aW5nUXVldWVkRXZlbnQsIGJsb2NrZWRPbiwgZG9tRXZlbnROYW1lLCBldmVudFN5c3RlbUZsYWdzLCB0YXJnZXRDb250YWluZXIsIG5hdGl2ZUV2ZW50KSB7XG4gIGlmIChleGlzdGluZ1F1ZXVlZEV2ZW50ID09PSBudWxsIHx8IGV4aXN0aW5nUXVldWVkRXZlbnQubmF0aXZlRXZlbnQgIT09IG5hdGl2ZUV2ZW50KSB7XG4gICAgdmFyIHF1ZXVlZEV2ZW50ID0gY3JlYXRlUXVldWVkUmVwbGF5YWJsZUV2ZW50KGJsb2NrZWRPbiwgZG9tRXZlbnROYW1lLCBldmVudFN5c3RlbUZsYWdzLCB0YXJnZXRDb250YWluZXIsIG5hdGl2ZUV2ZW50KTtcblxuICAgIGlmIChibG9ja2VkT24gIT09IG51bGwpIHtcbiAgICAgIHZhciBfZmliZXIyID0gZ2V0SW5zdGFuY2VGcm9tTm9kZShibG9ja2VkT24pO1xuXG4gICAgICBpZiAoX2ZpYmVyMiAhPT0gbnVsbCkge1xuICAgICAgICAvLyBBdHRlbXB0IHRvIGluY3JlYXNlIHRoZSBwcmlvcml0eSBvZiB0aGlzIHRhcmdldC5cbiAgICAgICAgYXR0ZW1wdENvbnRpbnVvdXNIeWRyYXRpb24oX2ZpYmVyMik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHF1ZXVlZEV2ZW50O1xuICB9IC8vIElmIHdlIGhhdmUgYWxyZWFkeSBxdWV1ZWQgdGhpcyBleGFjdCBldmVudCwgdGhlbiBpdCdzIGJlY2F1c2VcbiAgLy8gdGhlIGRpZmZlcmVudCBldmVudCBzeXN0ZW1zIGhhdmUgZGlmZmVyZW50IERPTSBldmVudCBsaXN0ZW5lcnMuXG4gIC8vIFdlIGNhbiBhY2N1bXVsYXRlIHRoZSBmbGFncywgYW5kIHRoZSB0YXJnZXRDb250YWluZXJzLCBhbmRcbiAgLy8gc3RvcmUgYSBzaW5nbGUgZXZlbnQgdG8gYmUgcmVwbGF5ZWQuXG5cblxuICBleGlzdGluZ1F1ZXVlZEV2ZW50LmV2ZW50U3lzdGVtRmxhZ3MgfD0gZXZlbnRTeXN0ZW1GbGFncztcbiAgdmFyIHRhcmdldENvbnRhaW5lcnMgPSBleGlzdGluZ1F1ZXVlZEV2ZW50LnRhcmdldENvbnRhaW5lcnM7XG5cbiAgaWYgKHRhcmdldENvbnRhaW5lciAhPT0gbnVsbCAmJiB0YXJnZXRDb250YWluZXJzLmluZGV4T2YodGFyZ2V0Q29udGFpbmVyKSA9PT0gLTEpIHtcbiAgICB0YXJnZXRDb250YWluZXJzLnB1c2godGFyZ2V0Q29udGFpbmVyKTtcbiAgfVxuXG4gIHJldHVybiBleGlzdGluZ1F1ZXVlZEV2ZW50O1xufVxuXG5mdW5jdGlvbiBxdWV1ZUlmQ29udGludW91c0V2ZW50KGJsb2NrZWRPbiwgZG9tRXZlbnROYW1lLCBldmVudFN5c3RlbUZsYWdzLCB0YXJnZXRDb250YWluZXIsIG5hdGl2ZUV2ZW50KSB7XG4gIC8vIFRoZXNlIHNldCByZWxhdGVkVGFyZ2V0IHRvIG51bGwgYmVjYXVzZSB0aGUgcmVwbGF5ZWQgZXZlbnQgd2lsbCBiZSB0cmVhdGVkIGFzIGlmIHdlXG4gIC8vIG1vdmVkIGZyb20gb3V0c2lkZSB0aGUgd2luZG93IChubyB0YXJnZXQpIG9udG8gdGhlIHRhcmdldCBvbmNlIGl0IGh5ZHJhdGVzLlxuICAvLyBJbnN0ZWFkIG9mIG11dGF0aW5nIHdlIGNvdWxkIGNsb25lIHRoZSBldmVudC5cbiAgc3dpdGNoIChkb21FdmVudE5hbWUpIHtcbiAgICBjYXNlICdmb2N1c2luJzpcbiAgICAgIHtcbiAgICAgICAgdmFyIGZvY3VzRXZlbnQgPSBuYXRpdmVFdmVudDtcbiAgICAgICAgcXVldWVkRm9jdXMgPSBhY2N1bXVsYXRlT3JDcmVhdGVDb250aW51b3VzUXVldWVkUmVwbGF5YWJsZUV2ZW50KHF1ZXVlZEZvY3VzLCBibG9ja2VkT24sIGRvbUV2ZW50TmFtZSwgZXZlbnRTeXN0ZW1GbGFncywgdGFyZ2V0Q29udGFpbmVyLCBmb2N1c0V2ZW50KTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICBjYXNlICdkcmFnZW50ZXInOlxuICAgICAge1xuICAgICAgICB2YXIgZHJhZ0V2ZW50ID0gbmF0aXZlRXZlbnQ7XG4gICAgICAgIHF1ZXVlZERyYWcgPSBhY2N1bXVsYXRlT3JDcmVhdGVDb250aW51b3VzUXVldWVkUmVwbGF5YWJsZUV2ZW50KHF1ZXVlZERyYWcsIGJsb2NrZWRPbiwgZG9tRXZlbnROYW1lLCBldmVudFN5c3RlbUZsYWdzLCB0YXJnZXRDb250YWluZXIsIGRyYWdFdmVudCk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgY2FzZSAnbW91c2VvdmVyJzpcbiAgICAgIHtcbiAgICAgICAgdmFyIG1vdXNlRXZlbnQgPSBuYXRpdmVFdmVudDtcbiAgICAgICAgcXVldWVkTW91c2UgPSBhY2N1bXVsYXRlT3JDcmVhdGVDb250aW51b3VzUXVldWVkUmVwbGF5YWJsZUV2ZW50KHF1ZXVlZE1vdXNlLCBibG9ja2VkT24sIGRvbUV2ZW50TmFtZSwgZXZlbnRTeXN0ZW1GbGFncywgdGFyZ2V0Q29udGFpbmVyLCBtb3VzZUV2ZW50KTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICBjYXNlICdwb2ludGVyb3Zlcic6XG4gICAgICB7XG4gICAgICAgIHZhciBwb2ludGVyRXZlbnQgPSBuYXRpdmVFdmVudDtcbiAgICAgICAgdmFyIHBvaW50ZXJJZCA9IHBvaW50ZXJFdmVudC5wb2ludGVySWQ7XG4gICAgICAgIHF1ZXVlZFBvaW50ZXJzLnNldChwb2ludGVySWQsIGFjY3VtdWxhdGVPckNyZWF0ZUNvbnRpbnVvdXNRdWV1ZWRSZXBsYXlhYmxlRXZlbnQocXVldWVkUG9pbnRlcnMuZ2V0KHBvaW50ZXJJZCkgfHwgbnVsbCwgYmxvY2tlZE9uLCBkb21FdmVudE5hbWUsIGV2ZW50U3lzdGVtRmxhZ3MsIHRhcmdldENvbnRhaW5lciwgcG9pbnRlckV2ZW50KSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgY2FzZSAnZ290cG9pbnRlcmNhcHR1cmUnOlxuICAgICAge1xuICAgICAgICB2YXIgX3BvaW50ZXJFdmVudCA9IG5hdGl2ZUV2ZW50O1xuICAgICAgICB2YXIgX3BvaW50ZXJJZDIgPSBfcG9pbnRlckV2ZW50LnBvaW50ZXJJZDtcbiAgICAgICAgcXVldWVkUG9pbnRlckNhcHR1cmVzLnNldChfcG9pbnRlcklkMiwgYWNjdW11bGF0ZU9yQ3JlYXRlQ29udGludW91c1F1ZXVlZFJlcGxheWFibGVFdmVudChxdWV1ZWRQb2ludGVyQ2FwdHVyZXMuZ2V0KF9wb2ludGVySWQyKSB8fCBudWxsLCBibG9ja2VkT24sIGRvbUV2ZW50TmFtZSwgZXZlbnRTeXN0ZW1GbGFncywgdGFyZ2V0Q29udGFpbmVyLCBfcG9pbnRlckV2ZW50KSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufSAvLyBDaGVjayBpZiB0aGlzIHRhcmdldCBpcyB1bmJsb2NrZWQuIFJldHVybnMgdHJ1ZSBpZiBpdCdzIHVuYmxvY2tlZC5cblxuZnVuY3Rpb24gYXR0ZW1wdEV4cGxpY2l0SHlkcmF0aW9uVGFyZ2V0KHF1ZXVlZFRhcmdldCkge1xuICAvLyBUT0RPOiBUaGlzIGZ1bmN0aW9uIHNoYXJlcyBhIGxvdCBvZiBsb2dpYyB3aXRoIGF0dGVtcHRUb0Rpc3BhdGNoRXZlbnQuXG4gIC8vIFRyeSB0byB1bmlmeSB0aGVtLiBJdCdzIGEgYml0IHRyaWNreSBzaW5jZSBpdCB3b3VsZCByZXF1aXJlIHR3byByZXR1cm5cbiAgLy8gdmFsdWVzLlxuICB2YXIgdGFyZ2V0SW5zdCA9IGdldENsb3Nlc3RJbnN0YW5jZUZyb21Ob2RlKHF1ZXVlZFRhcmdldC50YXJnZXQpO1xuXG4gIGlmICh0YXJnZXRJbnN0ICE9PSBudWxsKSB7XG4gICAgdmFyIG5lYXJlc3RNb3VudGVkID0gZ2V0TmVhcmVzdE1vdW50ZWRGaWJlcih0YXJnZXRJbnN0KTtcblxuICAgIGlmIChuZWFyZXN0TW91bnRlZCAhPT0gbnVsbCkge1xuICAgICAgdmFyIHRhZyA9IG5lYXJlc3RNb3VudGVkLnRhZztcblxuICAgICAgaWYgKHRhZyA9PT0gU3VzcGVuc2VDb21wb25lbnQpIHtcbiAgICAgICAgdmFyIGluc3RhbmNlID0gZ2V0U3VzcGVuc2VJbnN0YW5jZUZyb21GaWJlcihuZWFyZXN0TW91bnRlZCk7XG5cbiAgICAgICAgaWYgKGluc3RhbmNlICE9PSBudWxsKSB7XG4gICAgICAgICAgLy8gV2UncmUgYmxvY2tlZCBvbiBoeWRyYXRpbmcgdGhpcyBib3VuZGFyeS5cbiAgICAgICAgICAvLyBJbmNyZWFzZSBpdHMgcHJpb3JpdHkuXG4gICAgICAgICAgcXVldWVkVGFyZ2V0LmJsb2NrZWRPbiA9IGluc3RhbmNlO1xuICAgICAgICAgIGF0dGVtcHRIeWRyYXRpb25BdFByaW9yaXR5KHF1ZXVlZFRhcmdldC5sYW5lUHJpb3JpdHksIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIFNjaGVkdWxlci51bnN0YWJsZV9ydW5XaXRoUHJpb3JpdHkocXVldWVkVGFyZ2V0LnByaW9yaXR5LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIGF0dGVtcHRIeWRyYXRpb25BdEN1cnJlbnRQcmlvcml0eShuZWFyZXN0TW91bnRlZCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodGFnID09PSBIb3N0Um9vdCkge1xuICAgICAgICB2YXIgcm9vdCA9IG5lYXJlc3RNb3VudGVkLnN0YXRlTm9kZTtcblxuICAgICAgICBpZiAocm9vdC5oeWRyYXRlKSB7XG4gICAgICAgICAgcXVldWVkVGFyZ2V0LmJsb2NrZWRPbiA9IGdldENvbnRhaW5lckZyb21GaWJlcihuZWFyZXN0TW91bnRlZCk7IC8vIFdlIGRvbid0IGN1cnJlbnRseSBoYXZlIGEgd2F5IHRvIGluY3JlYXNlIHRoZSBwcmlvcml0eSBvZlxuICAgICAgICAgIC8vIGEgcm9vdCBvdGhlciB0aGFuIHN5bmMuXG5cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBxdWV1ZWRUYXJnZXQuYmxvY2tlZE9uID0gbnVsbDtcbn1cblxuZnVuY3Rpb24gYXR0ZW1wdFJlcGxheUNvbnRpbnVvdXNRdWV1ZWRFdmVudChxdWV1ZWRFdmVudCkge1xuICBpZiAocXVldWVkRXZlbnQuYmxvY2tlZE9uICE9PSBudWxsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIHRhcmdldENvbnRhaW5lcnMgPSBxdWV1ZWRFdmVudC50YXJnZXRDb250YWluZXJzO1xuXG4gIHdoaWxlICh0YXJnZXRDb250YWluZXJzLmxlbmd0aCA+IDApIHtcbiAgICB2YXIgdGFyZ2V0Q29udGFpbmVyID0gdGFyZ2V0Q29udGFpbmVyc1swXTtcbiAgICB2YXIgbmV4dEJsb2NrZWRPbiA9IGF0dGVtcHRUb0Rpc3BhdGNoRXZlbnQocXVldWVkRXZlbnQuZG9tRXZlbnROYW1lLCBxdWV1ZWRFdmVudC5ldmVudFN5c3RlbUZsYWdzLCB0YXJnZXRDb250YWluZXIsIHF1ZXVlZEV2ZW50Lm5hdGl2ZUV2ZW50KTtcblxuICAgIGlmIChuZXh0QmxvY2tlZE9uICE9PSBudWxsKSB7XG4gICAgICAvLyBXZSdyZSBzdGlsbCBibG9ja2VkLiBUcnkgYWdhaW4gbGF0ZXIuXG4gICAgICB2YXIgX2ZpYmVyMyA9IGdldEluc3RhbmNlRnJvbU5vZGUobmV4dEJsb2NrZWRPbik7XG5cbiAgICAgIGlmIChfZmliZXIzICE9PSBudWxsKSB7XG4gICAgICAgIGF0dGVtcHRDb250aW51b3VzSHlkcmF0aW9uKF9maWJlcjMpO1xuICAgICAgfVxuXG4gICAgICBxdWV1ZWRFdmVudC5ibG9ja2VkT24gPSBuZXh0QmxvY2tlZE9uO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gLy8gVGhpcyB0YXJnZXQgY29udGFpbmVyIHdhcyBzdWNjZXNzZnVsbHkgZGlzcGF0Y2hlZC4gVHJ5IHRoZSBuZXh0LlxuXG5cbiAgICB0YXJnZXRDb250YWluZXJzLnNoaWZ0KCk7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gYXR0ZW1wdFJlcGxheUNvbnRpbnVvdXNRdWV1ZWRFdmVudEluTWFwKHF1ZXVlZEV2ZW50LCBrZXksIG1hcCkge1xuICBpZiAoYXR0ZW1wdFJlcGxheUNvbnRpbnVvdXNRdWV1ZWRFdmVudChxdWV1ZWRFdmVudCkpIHtcbiAgICBtYXAuZGVsZXRlKGtleSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVwbGF5VW5ibG9ja2VkRXZlbnRzKCkge1xuICBoYXNTY2hlZHVsZWRSZXBsYXlBdHRlbXB0ID0gZmFsc2U7IC8vIEZpcnN0IHJlcGxheSBkaXNjcmV0ZSBldmVudHMuXG5cbiAgd2hpbGUgKHF1ZXVlZERpc2NyZXRlRXZlbnRzLmxlbmd0aCA+IDApIHtcbiAgICB2YXIgbmV4dERpc2NyZXRlRXZlbnQgPSBxdWV1ZWREaXNjcmV0ZUV2ZW50c1swXTtcblxuICAgIGlmIChuZXh0RGlzY3JldGVFdmVudC5ibG9ja2VkT24gIT09IG51bGwpIHtcbiAgICAgIC8vIFdlJ3JlIHN0aWxsIGJsb2NrZWQuXG4gICAgICAvLyBJbmNyZWFzZSB0aGUgcHJpb3JpdHkgb2YgdGhpcyBib3VuZGFyeSB0byB1bmJsb2NrXG4gICAgICAvLyB0aGUgbmV4dCBkaXNjcmV0ZSBldmVudC5cbiAgICAgIHZhciBfZmliZXI0ID0gZ2V0SW5zdGFuY2VGcm9tTm9kZShuZXh0RGlzY3JldGVFdmVudC5ibG9ja2VkT24pO1xuXG4gICAgICBpZiAoX2ZpYmVyNCAhPT0gbnVsbCkge1xuICAgICAgICBhdHRlbXB0VXNlckJsb2NraW5nSHlkcmF0aW9uKF9maWJlcjQpO1xuICAgICAgfVxuXG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICB2YXIgdGFyZ2V0Q29udGFpbmVycyA9IG5leHREaXNjcmV0ZUV2ZW50LnRhcmdldENvbnRhaW5lcnM7XG5cbiAgICB3aGlsZSAodGFyZ2V0Q29udGFpbmVycy5sZW5ndGggPiAwKSB7XG4gICAgICB2YXIgdGFyZ2V0Q29udGFpbmVyID0gdGFyZ2V0Q29udGFpbmVyc1swXTtcbiAgICAgIHZhciBuZXh0QmxvY2tlZE9uID0gYXR0ZW1wdFRvRGlzcGF0Y2hFdmVudChuZXh0RGlzY3JldGVFdmVudC5kb21FdmVudE5hbWUsIG5leHREaXNjcmV0ZUV2ZW50LmV2ZW50U3lzdGVtRmxhZ3MsIHRhcmdldENvbnRhaW5lciwgbmV4dERpc2NyZXRlRXZlbnQubmF0aXZlRXZlbnQpO1xuXG4gICAgICBpZiAobmV4dEJsb2NrZWRPbiAhPT0gbnVsbCkge1xuICAgICAgICAvLyBXZSdyZSBzdGlsbCBibG9ja2VkLiBUcnkgYWdhaW4gbGF0ZXIuXG4gICAgICAgIG5leHREaXNjcmV0ZUV2ZW50LmJsb2NrZWRPbiA9IG5leHRCbG9ja2VkT247XG4gICAgICAgIGJyZWFrO1xuICAgICAgfSAvLyBUaGlzIHRhcmdldCBjb250YWluZXIgd2FzIHN1Y2Nlc3NmdWxseSBkaXNwYXRjaGVkLiBUcnkgdGhlIG5leHQuXG5cblxuICAgICAgdGFyZ2V0Q29udGFpbmVycy5zaGlmdCgpO1xuICAgIH1cblxuICAgIGlmIChuZXh0RGlzY3JldGVFdmVudC5ibG9ja2VkT24gPT09IG51bGwpIHtcbiAgICAgIC8vIFdlJ3ZlIHN1Y2Nlc3NmdWxseSByZXBsYXllZCB0aGUgZmlyc3QgZXZlbnQuIExldCdzIHRyeSB0aGUgbmV4dCBvbmUuXG4gICAgICBxdWV1ZWREaXNjcmV0ZUV2ZW50cy5zaGlmdCgpO1xuICAgIH1cbiAgfSAvLyBOZXh0IHJlcGxheSBhbnkgY29udGludW91cyBldmVudHMuXG5cblxuICBpZiAocXVldWVkRm9jdXMgIT09IG51bGwgJiYgYXR0ZW1wdFJlcGxheUNvbnRpbnVvdXNRdWV1ZWRFdmVudChxdWV1ZWRGb2N1cykpIHtcbiAgICBxdWV1ZWRGb2N1cyA9IG51bGw7XG4gIH1cblxuICBpZiAocXVldWVkRHJhZyAhPT0gbnVsbCAmJiBhdHRlbXB0UmVwbGF5Q29udGludW91c1F1ZXVlZEV2ZW50KHF1ZXVlZERyYWcpKSB7XG4gICAgcXVldWVkRHJhZyA9IG51bGw7XG4gIH1cblxuICBpZiAocXVldWVkTW91c2UgIT09IG51bGwgJiYgYXR0ZW1wdFJlcGxheUNvbnRpbnVvdXNRdWV1ZWRFdmVudChxdWV1ZWRNb3VzZSkpIHtcbiAgICBxdWV1ZWRNb3VzZSA9IG51bGw7XG4gIH1cblxuICBxdWV1ZWRQb2ludGVycy5mb3JFYWNoKGF0dGVtcHRSZXBsYXlDb250aW51b3VzUXVldWVkRXZlbnRJbk1hcCk7XG4gIHF1ZXVlZFBvaW50ZXJDYXB0dXJlcy5mb3JFYWNoKGF0dGVtcHRSZXBsYXlDb250aW51b3VzUXVldWVkRXZlbnRJbk1hcCk7XG59XG5cbmZ1bmN0aW9uIHNjaGVkdWxlQ2FsbGJhY2tJZlVuYmxvY2tlZChxdWV1ZWRFdmVudCwgdW5ibG9ja2VkKSB7XG4gIGlmIChxdWV1ZWRFdmVudC5ibG9ja2VkT24gPT09IHVuYmxvY2tlZCkge1xuICAgIHF1ZXVlZEV2ZW50LmJsb2NrZWRPbiA9IG51bGw7XG5cbiAgICBpZiAoIWhhc1NjaGVkdWxlZFJlcGxheUF0dGVtcHQpIHtcbiAgICAgIGhhc1NjaGVkdWxlZFJlcGxheUF0dGVtcHQgPSB0cnVlOyAvLyBTY2hlZHVsZSBhIGNhbGxiYWNrIHRvIGF0dGVtcHQgcmVwbGF5aW5nIGFzIG1hbnkgZXZlbnRzIGFzIGFyZVxuICAgICAgLy8gbm93IHVuYmxvY2tlZC4gVGhpcyBmaXJzdCBtaWdodCBub3QgYWN0dWFsbHkgYmUgdW5ibG9ja2VkIHlldC5cbiAgICAgIC8vIFdlIGNvdWxkIGNoZWNrIGl0IGVhcmx5IHRvIGF2b2lkIHNjaGVkdWxpbmcgYW4gdW5uZWNlc3NhcnkgY2FsbGJhY2suXG5cbiAgICAgIFNjaGVkdWxlci51bnN0YWJsZV9zY2hlZHVsZUNhbGxiYWNrKFNjaGVkdWxlci51bnN0YWJsZV9Ob3JtYWxQcmlvcml0eSwgcmVwbGF5VW5ibG9ja2VkRXZlbnRzKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcmV0cnlJZkJsb2NrZWRPbih1bmJsb2NrZWQpIHtcbiAgLy8gTWFyayBhbnl0aGluZyB0aGF0IHdhcyBibG9ja2VkIG9uIHRoaXMgYXMgbm8gbG9uZ2VyIGJsb2NrZWRcbiAgLy8gYW5kIGVsaWdpYmxlIGZvciBhIHJlcGxheS5cbiAgaWYgKHF1ZXVlZERpc2NyZXRlRXZlbnRzLmxlbmd0aCA+IDApIHtcbiAgICBzY2hlZHVsZUNhbGxiYWNrSWZVbmJsb2NrZWQocXVldWVkRGlzY3JldGVFdmVudHNbMF0sIHVuYmxvY2tlZCk7IC8vIFRoaXMgaXMgYSBleHBvbmVudGlhbCBzZWFyY2ggZm9yIGVhY2ggYm91bmRhcnkgdGhhdCBjb21taXRzLiBJIHRoaW5rIGl0J3NcbiAgICAvLyB3b3J0aCBpdCBiZWNhdXNlIHdlIGV4cGVjdCB2ZXJ5IGZldyBkaXNjcmV0ZSBldmVudHMgdG8gcXVldWUgdXAgYW5kIG9uY2VcbiAgICAvLyB3ZSBhcmUgYWN0dWFsbHkgZnVsbHkgdW5ibG9ja2VkIGl0IHdpbGwgYmUgZmFzdCB0byByZXBsYXkgdGhlbS5cblxuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgcXVldWVkRGlzY3JldGVFdmVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBxdWV1ZWRFdmVudCA9IHF1ZXVlZERpc2NyZXRlRXZlbnRzW2ldO1xuXG4gICAgICBpZiAocXVldWVkRXZlbnQuYmxvY2tlZE9uID09PSB1bmJsb2NrZWQpIHtcbiAgICAgICAgcXVldWVkRXZlbnQuYmxvY2tlZE9uID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAocXVldWVkRm9jdXMgIT09IG51bGwpIHtcbiAgICBzY2hlZHVsZUNhbGxiYWNrSWZVbmJsb2NrZWQocXVldWVkRm9jdXMsIHVuYmxvY2tlZCk7XG4gIH1cblxuICBpZiAocXVldWVkRHJhZyAhPT0gbnVsbCkge1xuICAgIHNjaGVkdWxlQ2FsbGJhY2tJZlVuYmxvY2tlZChxdWV1ZWREcmFnLCB1bmJsb2NrZWQpO1xuICB9XG5cbiAgaWYgKHF1ZXVlZE1vdXNlICE9PSBudWxsKSB7XG4gICAgc2NoZWR1bGVDYWxsYmFja0lmVW5ibG9ja2VkKHF1ZXVlZE1vdXNlLCB1bmJsb2NrZWQpO1xuICB9XG5cbiAgdmFyIHVuYmxvY2sgPSBmdW5jdGlvbiAocXVldWVkRXZlbnQpIHtcbiAgICByZXR1cm4gc2NoZWR1bGVDYWxsYmFja0lmVW5ibG9ja2VkKHF1ZXVlZEV2ZW50LCB1bmJsb2NrZWQpO1xuICB9O1xuXG4gIHF1ZXVlZFBvaW50ZXJzLmZvckVhY2godW5ibG9jayk7XG4gIHF1ZXVlZFBvaW50ZXJDYXB0dXJlcy5mb3JFYWNoKHVuYmxvY2spO1xuXG4gIGZvciAodmFyIF9pID0gMDsgX2kgPCBxdWV1ZWRFeHBsaWNpdEh5ZHJhdGlvblRhcmdldHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgdmFyIHF1ZXVlZFRhcmdldCA9IHF1ZXVlZEV4cGxpY2l0SHlkcmF0aW9uVGFyZ2V0c1tfaV07XG5cbiAgICBpZiAocXVldWVkVGFyZ2V0LmJsb2NrZWRPbiA9PT0gdW5ibG9ja2VkKSB7XG4gICAgICBxdWV1ZWRUYXJnZXQuYmxvY2tlZE9uID0gbnVsbDtcbiAgICB9XG4gIH1cblxuICB3aGlsZSAocXVldWVkRXhwbGljaXRIeWRyYXRpb25UYXJnZXRzLmxlbmd0aCA+IDApIHtcbiAgICB2YXIgbmV4dEV4cGxpY2l0VGFyZ2V0ID0gcXVldWVkRXhwbGljaXRIeWRyYXRpb25UYXJnZXRzWzBdO1xuXG4gICAgaWYgKG5leHRFeHBsaWNpdFRhcmdldC5ibG9ja2VkT24gIT09IG51bGwpIHtcbiAgICAgIC8vIFdlJ3JlIHN0aWxsIGJsb2NrZWQuXG4gICAgICBicmVhaztcbiAgICB9IGVsc2Uge1xuICAgICAgYXR0ZW1wdEV4cGxpY2l0SHlkcmF0aW9uVGFyZ2V0KG5leHRFeHBsaWNpdFRhcmdldCk7XG5cbiAgICAgIGlmIChuZXh0RXhwbGljaXRUYXJnZXQuYmxvY2tlZE9uID09PSBudWxsKSB7XG4gICAgICAgIC8vIFdlJ3JlIHVuYmxvY2tlZC5cbiAgICAgICAgcXVldWVkRXhwbGljaXRIeWRyYXRpb25UYXJnZXRzLnNoaWZ0KCk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbnZhciBEaXNjcmV0ZUV2ZW50ID0gMDtcbnZhciBVc2VyQmxvY2tpbmdFdmVudCA9IDE7XG52YXIgQ29udGludW91c0V2ZW50ID0gMjtcblxuLyoqXG4gKiBHZW5lcmF0ZSBhIG1hcHBpbmcgb2Ygc3RhbmRhcmQgdmVuZG9yIHByZWZpeGVzIHVzaW5nIHRoZSBkZWZpbmVkIHN0eWxlIHByb3BlcnR5IGFuZCBldmVudCBuYW1lLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHlsZVByb3BcbiAqIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWVcbiAqIEByZXR1cm5zIHtvYmplY3R9XG4gKi9cblxuZnVuY3Rpb24gbWFrZVByZWZpeE1hcChzdHlsZVByb3AsIGV2ZW50TmFtZSkge1xuICB2YXIgcHJlZml4ZXMgPSB7fTtcbiAgcHJlZml4ZXNbc3R5bGVQcm9wLnRvTG93ZXJDYXNlKCldID0gZXZlbnROYW1lLnRvTG93ZXJDYXNlKCk7XG4gIHByZWZpeGVzWydXZWJraXQnICsgc3R5bGVQcm9wXSA9ICd3ZWJraXQnICsgZXZlbnROYW1lO1xuICBwcmVmaXhlc1snTW96JyArIHN0eWxlUHJvcF0gPSAnbW96JyArIGV2ZW50TmFtZTtcbiAgcmV0dXJuIHByZWZpeGVzO1xufVxuLyoqXG4gKiBBIGxpc3Qgb2YgZXZlbnQgbmFtZXMgdG8gYSBjb25maWd1cmFibGUgbGlzdCBvZiB2ZW5kb3IgcHJlZml4ZXMuXG4gKi9cblxuXG52YXIgdmVuZG9yUHJlZml4ZXMgPSB7XG4gIGFuaW1hdGlvbmVuZDogbWFrZVByZWZpeE1hcCgnQW5pbWF0aW9uJywgJ0FuaW1hdGlvbkVuZCcpLFxuICBhbmltYXRpb25pdGVyYXRpb246IG1ha2VQcmVmaXhNYXAoJ0FuaW1hdGlvbicsICdBbmltYXRpb25JdGVyYXRpb24nKSxcbiAgYW5pbWF0aW9uc3RhcnQ6IG1ha2VQcmVmaXhNYXAoJ0FuaW1hdGlvbicsICdBbmltYXRpb25TdGFydCcpLFxuICB0cmFuc2l0aW9uZW5kOiBtYWtlUHJlZml4TWFwKCdUcmFuc2l0aW9uJywgJ1RyYW5zaXRpb25FbmQnKVxufTtcbi8qKlxuICogRXZlbnQgbmFtZXMgdGhhdCBoYXZlIGFscmVhZHkgYmVlbiBkZXRlY3RlZCBhbmQgcHJlZml4ZWQgKGlmIGFwcGxpY2FibGUpLlxuICovXG5cbnZhciBwcmVmaXhlZEV2ZW50TmFtZXMgPSB7fTtcbi8qKlxuICogRWxlbWVudCB0byBjaGVjayBmb3IgcHJlZml4ZXMgb24uXG4gKi9cblxudmFyIHN0eWxlID0ge307XG4vKipcbiAqIEJvb3RzdHJhcCBpZiBhIERPTSBleGlzdHMuXG4gKi9cblxuaWYgKGNhblVzZURPTSkge1xuICBzdHlsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpLnN0eWxlOyAvLyBPbiBzb21lIHBsYXRmb3JtcywgaW4gcGFydGljdWxhciBzb21lIHJlbGVhc2VzIG9mIEFuZHJvaWQgNC54LFxuICAvLyB0aGUgdW4tcHJlZml4ZWQgXCJhbmltYXRpb25cIiBhbmQgXCJ0cmFuc2l0aW9uXCIgcHJvcGVydGllcyBhcmUgZGVmaW5lZCBvbiB0aGVcbiAgLy8gc3R5bGUgb2JqZWN0IGJ1dCB0aGUgZXZlbnRzIHRoYXQgZmlyZSB3aWxsIHN0aWxsIGJlIHByZWZpeGVkLCBzbyB3ZSBuZWVkXG4gIC8vIHRvIGNoZWNrIGlmIHRoZSB1bi1wcmVmaXhlZCBldmVudHMgYXJlIHVzYWJsZSwgYW5kIGlmIG5vdCByZW1vdmUgdGhlbSBmcm9tIHRoZSBtYXAuXG5cbiAgaWYgKCEoJ0FuaW1hdGlvbkV2ZW50JyBpbiB3aW5kb3cpKSB7XG4gICAgZGVsZXRlIHZlbmRvclByZWZpeGVzLmFuaW1hdGlvbmVuZC5hbmltYXRpb247XG4gICAgZGVsZXRlIHZlbmRvclByZWZpeGVzLmFuaW1hdGlvbml0ZXJhdGlvbi5hbmltYXRpb247XG4gICAgZGVsZXRlIHZlbmRvclByZWZpeGVzLmFuaW1hdGlvbnN0YXJ0LmFuaW1hdGlvbjtcbiAgfSAvLyBTYW1lIGFzIGFib3ZlXG5cblxuICBpZiAoISgnVHJhbnNpdGlvbkV2ZW50JyBpbiB3aW5kb3cpKSB7XG4gICAgZGVsZXRlIHZlbmRvclByZWZpeGVzLnRyYW5zaXRpb25lbmQudHJhbnNpdGlvbjtcbiAgfVxufVxuLyoqXG4gKiBBdHRlbXB0cyB0byBkZXRlcm1pbmUgdGhlIGNvcnJlY3QgdmVuZG9yIHByZWZpeGVkIGV2ZW50IG5hbWUuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50TmFtZVxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuXG5cbmZ1bmN0aW9uIGdldFZlbmRvclByZWZpeGVkRXZlbnROYW1lKGV2ZW50TmFtZSkge1xuICBpZiAocHJlZml4ZWRFdmVudE5hbWVzW2V2ZW50TmFtZV0pIHtcbiAgICByZXR1cm4gcHJlZml4ZWRFdmVudE5hbWVzW2V2ZW50TmFtZV07XG4gIH0gZWxzZSBpZiAoIXZlbmRvclByZWZpeGVzW2V2ZW50TmFtZV0pIHtcbiAgICByZXR1cm4gZXZlbnROYW1lO1xuICB9XG5cbiAgdmFyIHByZWZpeE1hcCA9IHZlbmRvclByZWZpeGVzW2V2ZW50TmFtZV07XG5cbiAgZm9yICh2YXIgc3R5bGVQcm9wIGluIHByZWZpeE1hcCkge1xuICAgIGlmIChwcmVmaXhNYXAuaGFzT3duUHJvcGVydHkoc3R5bGVQcm9wKSAmJiBzdHlsZVByb3AgaW4gc3R5bGUpIHtcbiAgICAgIHJldHVybiBwcmVmaXhlZEV2ZW50TmFtZXNbZXZlbnROYW1lXSA9IHByZWZpeE1hcFtzdHlsZVByb3BdO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBldmVudE5hbWU7XG59XG5cbnZhciBBTklNQVRJT05fRU5EID0gZ2V0VmVuZG9yUHJlZml4ZWRFdmVudE5hbWUoJ2FuaW1hdGlvbmVuZCcpO1xudmFyIEFOSU1BVElPTl9JVEVSQVRJT04gPSBnZXRWZW5kb3JQcmVmaXhlZEV2ZW50TmFtZSgnYW5pbWF0aW9uaXRlcmF0aW9uJyk7XG52YXIgQU5JTUFUSU9OX1NUQVJUID0gZ2V0VmVuZG9yUHJlZml4ZWRFdmVudE5hbWUoJ2FuaW1hdGlvbnN0YXJ0Jyk7XG52YXIgVFJBTlNJVElPTl9FTkQgPSBnZXRWZW5kb3JQcmVmaXhlZEV2ZW50TmFtZSgndHJhbnNpdGlvbmVuZCcpO1xuXG52YXIgdG9wTGV2ZWxFdmVudHNUb1JlYWN0TmFtZXMgPSBuZXcgTWFwKCk7XG52YXIgZXZlbnRQcmlvcml0aWVzID0gbmV3IE1hcCgpOyAvLyBXZSBzdG9yZSBtb3N0IG9mIHRoZSBldmVudHMgaW4gdGhpcyBtb2R1bGUgaW4gcGFpcnMgb2YgdHdvIHN0cmluZ3Mgc28gd2UgY2FuIHJlLXVzZVxuLy8gdGhlIGNvZGUgcmVxdWlyZWQgdG8gYXBwbHkgdGhlIHNhbWUgbG9naWMgZm9yIGV2ZW50IHByaW9yaXRpemF0aW9uIGFuZCB0aGF0IG9mIHRoZVxuLy8gU2ltcGxlRXZlbnRQbHVnaW4uIFRoaXMgY29tcGxpY2F0ZXMgdGhpbmdzIHNsaWdodGx5LCBidXQgdGhlIGFpbSBpcyB0byByZWR1Y2UgY29kZVxuLy8gZHVwbGljYXRpb24gKGZvciB3aGljaCB0aGVyZSB3b3VsZCBiZSBxdWl0ZSBhIGJpdCkuIEZvciB0aGUgZXZlbnRzIHRoYXQgYXJlIG5vdCBuZWVkZWRcbi8vIGZvciB0aGUgU2ltcGxlRXZlbnRQbHVnaW4gKG90aGVyRGlzY3JldGVFdmVudHMpIHdlIHByb2Nlc3MgdGhlbSBzZXBhcmF0ZWx5IGFzIGFuXG4vLyBhcnJheSBvZiB0b3AgbGV2ZWwgZXZlbnRzLlxuLy8gTGFzdGx5LCB3ZSBpZ25vcmUgcHJldHRpZXIgc28gd2UgY2FuIGtlZXAgdGhlIGZvcm1hdHRpbmcgc2FuZS5cbi8vIHByZXR0aWVyLWlnbm9yZVxuXG52YXIgZGlzY3JldGVFdmVudFBhaXJzRm9yU2ltcGxlRXZlbnRQbHVnaW4gPSBbJ2NhbmNlbCcsICdjYW5jZWwnLCAnY2xpY2snLCAnY2xpY2snLCAnY2xvc2UnLCAnY2xvc2UnLCAnY29udGV4dG1lbnUnLCAnY29udGV4dE1lbnUnLCAnY29weScsICdjb3B5JywgJ2N1dCcsICdjdXQnLCAnYXV4Y2xpY2snLCAnYXV4Q2xpY2snLCAnZGJsY2xpY2snLCAnZG91YmxlQ2xpY2snLCAvLyBDYXJlZnVsIVxuJ2RyYWdlbmQnLCAnZHJhZ0VuZCcsICdkcmFnc3RhcnQnLCAnZHJhZ1N0YXJ0JywgJ2Ryb3AnLCAnZHJvcCcsICdmb2N1c2luJywgJ2ZvY3VzJywgLy8gQ2FyZWZ1bCFcbidmb2N1c291dCcsICdibHVyJywgLy8gQ2FyZWZ1bCFcbidpbnB1dCcsICdpbnB1dCcsICdpbnZhbGlkJywgJ2ludmFsaWQnLCAna2V5ZG93bicsICdrZXlEb3duJywgJ2tleXByZXNzJywgJ2tleVByZXNzJywgJ2tleXVwJywgJ2tleVVwJywgJ21vdXNlZG93bicsICdtb3VzZURvd24nLCAnbW91c2V1cCcsICdtb3VzZVVwJywgJ3Bhc3RlJywgJ3Bhc3RlJywgJ3BhdXNlJywgJ3BhdXNlJywgJ3BsYXknLCAncGxheScsICdwb2ludGVyY2FuY2VsJywgJ3BvaW50ZXJDYW5jZWwnLCAncG9pbnRlcmRvd24nLCAncG9pbnRlckRvd24nLCAncG9pbnRlcnVwJywgJ3BvaW50ZXJVcCcsICdyYXRlY2hhbmdlJywgJ3JhdGVDaGFuZ2UnLCAncmVzZXQnLCAncmVzZXQnLCAnc2Vla2VkJywgJ3NlZWtlZCcsICdzdWJtaXQnLCAnc3VibWl0JywgJ3RvdWNoY2FuY2VsJywgJ3RvdWNoQ2FuY2VsJywgJ3RvdWNoZW5kJywgJ3RvdWNoRW5kJywgJ3RvdWNoc3RhcnQnLCAndG91Y2hTdGFydCcsICd2b2x1bWVjaGFuZ2UnLCAndm9sdW1lQ2hhbmdlJ107XG52YXIgb3RoZXJEaXNjcmV0ZUV2ZW50cyA9IFsnY2hhbmdlJywgJ3NlbGVjdGlvbmNoYW5nZScsICd0ZXh0SW5wdXQnLCAnY29tcG9zaXRpb25zdGFydCcsICdjb21wb3NpdGlvbmVuZCcsICdjb21wb3NpdGlvbnVwZGF0ZSddO1xuXG5cbnZhciB1c2VyQmxvY2tpbmdQYWlyc0ZvclNpbXBsZUV2ZW50UGx1Z2luID0gWydkcmFnJywgJ2RyYWcnLCAnZHJhZ2VudGVyJywgJ2RyYWdFbnRlcicsICdkcmFnZXhpdCcsICdkcmFnRXhpdCcsICdkcmFnbGVhdmUnLCAnZHJhZ0xlYXZlJywgJ2RyYWdvdmVyJywgJ2RyYWdPdmVyJywgJ21vdXNlbW92ZScsICdtb3VzZU1vdmUnLCAnbW91c2VvdXQnLCAnbW91c2VPdXQnLCAnbW91c2VvdmVyJywgJ21vdXNlT3ZlcicsICdwb2ludGVybW92ZScsICdwb2ludGVyTW92ZScsICdwb2ludGVyb3V0JywgJ3BvaW50ZXJPdXQnLCAncG9pbnRlcm92ZXInLCAncG9pbnRlck92ZXInLCAnc2Nyb2xsJywgJ3Njcm9sbCcsICd0b2dnbGUnLCAndG9nZ2xlJywgJ3RvdWNobW92ZScsICd0b3VjaE1vdmUnLCAnd2hlZWwnLCAnd2hlZWwnXTsgLy8gcHJldHRpZXItaWdub3JlXG5cbnZhciBjb250aW51b3VzUGFpcnNGb3JTaW1wbGVFdmVudFBsdWdpbiA9IFsnYWJvcnQnLCAnYWJvcnQnLCBBTklNQVRJT05fRU5ELCAnYW5pbWF0aW9uRW5kJywgQU5JTUFUSU9OX0lURVJBVElPTiwgJ2FuaW1hdGlvbkl0ZXJhdGlvbicsIEFOSU1BVElPTl9TVEFSVCwgJ2FuaW1hdGlvblN0YXJ0JywgJ2NhbnBsYXknLCAnY2FuUGxheScsICdjYW5wbGF5dGhyb3VnaCcsICdjYW5QbGF5VGhyb3VnaCcsICdkdXJhdGlvbmNoYW5nZScsICdkdXJhdGlvbkNoYW5nZScsICdlbXB0aWVkJywgJ2VtcHRpZWQnLCAnZW5jcnlwdGVkJywgJ2VuY3J5cHRlZCcsICdlbmRlZCcsICdlbmRlZCcsICdlcnJvcicsICdlcnJvcicsICdnb3Rwb2ludGVyY2FwdHVyZScsICdnb3RQb2ludGVyQ2FwdHVyZScsICdsb2FkJywgJ2xvYWQnLCAnbG9hZGVkZGF0YScsICdsb2FkZWREYXRhJywgJ2xvYWRlZG1ldGFkYXRhJywgJ2xvYWRlZE1ldGFkYXRhJywgJ2xvYWRzdGFydCcsICdsb2FkU3RhcnQnLCAnbG9zdHBvaW50ZXJjYXB0dXJlJywgJ2xvc3RQb2ludGVyQ2FwdHVyZScsICdwbGF5aW5nJywgJ3BsYXlpbmcnLCAncHJvZ3Jlc3MnLCAncHJvZ3Jlc3MnLCAnc2Vla2luZycsICdzZWVraW5nJywgJ3N0YWxsZWQnLCAnc3RhbGxlZCcsICdzdXNwZW5kJywgJ3N1c3BlbmQnLCAndGltZXVwZGF0ZScsICd0aW1lVXBkYXRlJywgVFJBTlNJVElPTl9FTkQsICd0cmFuc2l0aW9uRW5kJywgJ3dhaXRpbmcnLCAnd2FpdGluZyddO1xuLyoqXG4gKiBUdXJuc1xuICogWydhYm9ydCcsIC4uLl1cbiAqXG4gKiBpbnRvXG4gKlxuICogdG9wTGV2ZWxFdmVudHNUb1JlYWN0TmFtZXMgPSBuZXcgTWFwKFtcbiAqICAgWydhYm9ydCcsICdvbkFib3J0J10sXG4gKiBdKTtcbiAqXG4gKiBhbmQgcmVnaXN0ZXJzIHRoZW0uXG4gKi9cblxuZnVuY3Rpb24gcmVnaXN0ZXJTaW1wbGVQbHVnaW5FdmVudHNBbmRTZXRUaGVpclByaW9yaXRpZXMoZXZlbnRUeXBlcywgcHJpb3JpdHkpIHtcbiAgLy8gQXMgdGhlIGV2ZW50IHR5cGVzIGFyZSBpbiBwYWlycyBvZiB0d28sIHdlIG5lZWQgdG8gaXRlcmF0ZVxuICAvLyB0aHJvdWdoIGluIHR3b3MuIFRoZSBldmVudHMgYXJlIGluIHBhaXJzIG9mIHR3byB0byBzYXZlIGNvZGVcbiAgLy8gYW5kIGltcHJvdmUgaW5pdCBwZXJmIG9mIHByb2Nlc3NpbmcgdGhpcyBhcnJheSwgYXMgaXQgd2lsbFxuICAvLyByZXN1bHQgaW4gZmFyIGZld2VyIG9iamVjdCBhbGxvY2F0aW9ucyBhbmQgcHJvcGVydHkgYWNjZXNzZXNcbiAgLy8gaWYgd2Ugb25seSB1c2UgdGhyZWUgYXJyYXlzIHRvIHByb2Nlc3MgYWxsIHRoZSBjYXRlZ29yaWVzIG9mXG4gIC8vIGluc3RlYWQgb2YgdHVwbGVzLlxuICBmb3IgKHZhciBpID0gMDsgaSA8IGV2ZW50VHlwZXMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICB2YXIgdG9wRXZlbnQgPSBldmVudFR5cGVzW2ldO1xuICAgIHZhciBldmVudCA9IGV2ZW50VHlwZXNbaSArIDFdO1xuICAgIHZhciBjYXBpdGFsaXplZEV2ZW50ID0gZXZlbnRbMF0udG9VcHBlckNhc2UoKSArIGV2ZW50LnNsaWNlKDEpO1xuICAgIHZhciByZWFjdE5hbWUgPSAnb24nICsgY2FwaXRhbGl6ZWRFdmVudDtcbiAgICBldmVudFByaW9yaXRpZXMuc2V0KHRvcEV2ZW50LCBwcmlvcml0eSk7XG4gICAgdG9wTGV2ZWxFdmVudHNUb1JlYWN0TmFtZXMuc2V0KHRvcEV2ZW50LCByZWFjdE5hbWUpO1xuICAgIHJlZ2lzdGVyVHdvUGhhc2VFdmVudChyZWFjdE5hbWUsIFt0b3BFdmVudF0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIHNldEV2ZW50UHJpb3JpdGllcyhldmVudFR5cGVzLCBwcmlvcml0eSkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGV2ZW50VHlwZXMubGVuZ3RoOyBpKyspIHtcbiAgICBldmVudFByaW9yaXRpZXMuc2V0KGV2ZW50VHlwZXNbaV0sIHByaW9yaXR5KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRFdmVudFByaW9yaXR5Rm9yUGx1Z2luU3lzdGVtKGRvbUV2ZW50TmFtZSkge1xuICB2YXIgcHJpb3JpdHkgPSBldmVudFByaW9yaXRpZXMuZ2V0KGRvbUV2ZW50TmFtZSk7IC8vIERlZmF1bHQgdG8gYSBDb250aW51b3VzRXZlbnQuIE5vdGU6IHdlIG1pZ2h0XG4gIC8vIHdhbnQgdG8gd2FybiBpZiB3ZSBjYW4ndCBkZXRlY3QgdGhlIHByaW9yaXR5XG4gIC8vIGZvciB0aGUgZXZlbnQuXG5cbiAgcmV0dXJuIHByaW9yaXR5ID09PSB1bmRlZmluZWQgPyBDb250aW51b3VzRXZlbnQgOiBwcmlvcml0eTtcbn1cbmZ1bmN0aW9uIHJlZ2lzdGVyU2ltcGxlRXZlbnRzKCkge1xuICByZWdpc3RlclNpbXBsZVBsdWdpbkV2ZW50c0FuZFNldFRoZWlyUHJpb3JpdGllcyhkaXNjcmV0ZUV2ZW50UGFpcnNGb3JTaW1wbGVFdmVudFBsdWdpbiwgRGlzY3JldGVFdmVudCk7XG4gIHJlZ2lzdGVyU2ltcGxlUGx1Z2luRXZlbnRzQW5kU2V0VGhlaXJQcmlvcml0aWVzKHVzZXJCbG9ja2luZ1BhaXJzRm9yU2ltcGxlRXZlbnRQbHVnaW4sIFVzZXJCbG9ja2luZ0V2ZW50KTtcbiAgcmVnaXN0ZXJTaW1wbGVQbHVnaW5FdmVudHNBbmRTZXRUaGVpclByaW9yaXRpZXMoY29udGludW91c1BhaXJzRm9yU2ltcGxlRXZlbnRQbHVnaW4sIENvbnRpbnVvdXNFdmVudCk7XG4gIHNldEV2ZW50UHJpb3JpdGllcyhvdGhlckRpc2NyZXRlRXZlbnRzLCBEaXNjcmV0ZUV2ZW50KTtcbn1cblxudmFyIFNjaGVkdWxlcl9ub3cgPSBTY2hlZHVsZXIudW5zdGFibGVfbm93O1xuXG57XG4gIC8vIFByb3ZpZGUgZXhwbGljaXQgZXJyb3IgbWVzc2FnZSB3aGVuIHByb2R1Y3Rpb24rcHJvZmlsaW5nIGJ1bmRsZSBvZiBlLmcuXG4gIC8vIHJlYWN0LWRvbSBpcyB1c2VkIHdpdGggcHJvZHVjdGlvbiAobm9uLXByb2ZpbGluZykgYnVuZGxlIG9mXG4gIC8vIHNjaGVkdWxlci90cmFjaW5nXG4gIGlmICghKHRyYWNpbmcuX19pbnRlcmFjdGlvbnNSZWYgIT0gbnVsbCAmJiB0cmFjaW5nLl9faW50ZXJhY3Rpb25zUmVmLmN1cnJlbnQgIT0gbnVsbCkpIHtcbiAgICB7XG4gICAgICB0aHJvdyBFcnJvciggXCJJdCBpcyBub3Qgc3VwcG9ydGVkIHRvIHJ1biB0aGUgcHJvZmlsaW5nIHZlcnNpb24gb2YgYSByZW5kZXJlciAoZm9yIGV4YW1wbGUsIGByZWFjdC1kb20vcHJvZmlsaW5nYCkgd2l0aG91dCBhbHNvIHJlcGxhY2luZyB0aGUgYHNjaGVkdWxlci90cmFjaW5nYCBtb2R1bGUgd2l0aCBgc2NoZWR1bGVyL3RyYWNpbmctcHJvZmlsaW5nYC4gWW91ciBidW5kbGVyIG1pZ2h0IGhhdmUgYSBzZXR0aW5nIGZvciBhbGlhc2luZyBib3RoIG1vZHVsZXMuIExlYXJuIG1vcmUgYXQgaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3Byb2ZpbGluZ1wiICk7XG4gICAgfVxuICB9XG59XG4vLyBhc2NlbmRpbmcgbnVtYmVycyBzbyB3ZSBjYW4gY29tcGFyZSB0aGVtIGxpa2UgbnVtYmVycy4gVGhleSBzdGFydCBhdCA5MCB0b1xuLy8gYXZvaWQgY2xhc2hpbmcgd2l0aCBTY2hlZHVsZXIncyBwcmlvcml0aWVzLlxuXG52YXIgSW1tZWRpYXRlUHJpb3JpdHkgPSA5OTtcbnZhciBVc2VyQmxvY2tpbmdQcmlvcml0eSA9IDk4O1xudmFyIE5vcm1hbFByaW9yaXR5ID0gOTc7XG52YXIgTG93UHJpb3JpdHkgPSA5NjtcbnZhciBJZGxlUHJpb3JpdHkgPSA5NTsgLy8gTm9Qcmlvcml0eSBpcyB0aGUgYWJzZW5jZSBvZiBwcmlvcml0eS4gQWxzbyBSZWFjdC1vbmx5LlxuXG52YXIgTm9Qcmlvcml0eSA9IDkwO1xudmFyIGluaXRpYWxUaW1lTXMgPSBTY2hlZHVsZXJfbm93KCk7IC8vIElmIHRoZSBpbml0aWFsIHRpbWVzdGFtcCBpcyByZWFzb25hYmx5IHNtYWxsLCB1c2UgU2NoZWR1bGVyJ3MgYG5vd2AgZGlyZWN0bHkuXG5cbnZhciBTeW5jTGFuZVByaW9yaXR5ID0gMTU7XG52YXIgU3luY0JhdGNoZWRMYW5lUHJpb3JpdHkgPSAxNDtcbnZhciBJbnB1dERpc2NyZXRlSHlkcmF0aW9uTGFuZVByaW9yaXR5ID0gMTM7XG52YXIgSW5wdXREaXNjcmV0ZUxhbmVQcmlvcml0eSA9IDEyO1xudmFyIElucHV0Q29udGludW91c0h5ZHJhdGlvbkxhbmVQcmlvcml0eSA9IDExO1xudmFyIElucHV0Q29udGludW91c0xhbmVQcmlvcml0eSA9IDEwO1xudmFyIERlZmF1bHRIeWRyYXRpb25MYW5lUHJpb3JpdHkgPSA5O1xudmFyIERlZmF1bHRMYW5lUHJpb3JpdHkgPSA4O1xudmFyIFRyYW5zaXRpb25IeWRyYXRpb25Qcmlvcml0eSA9IDc7XG52YXIgVHJhbnNpdGlvblByaW9yaXR5ID0gNjtcbnZhciBSZXRyeUxhbmVQcmlvcml0eSA9IDU7XG52YXIgU2VsZWN0aXZlSHlkcmF0aW9uTGFuZVByaW9yaXR5ID0gNDtcbnZhciBJZGxlSHlkcmF0aW9uTGFuZVByaW9yaXR5ID0gMztcbnZhciBJZGxlTGFuZVByaW9yaXR5ID0gMjtcbnZhciBPZmZzY3JlZW5MYW5lUHJpb3JpdHkgPSAxO1xudmFyIE5vTGFuZVByaW9yaXR5ID0gMDtcbnZhciBUb3RhbExhbmVzID0gMzE7XG52YXIgTm9MYW5lcyA9XG4vKiAgICAgICAgICAgICAgICAgICAgICAgICovXG4wO1xudmFyIE5vTGFuZSA9XG4vKiAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cbjA7XG52YXIgU3luY0xhbmUgPVxuLyogICAgICAgICAgICAgICAgICAgICAgICAqL1xuMTtcbnZhciBTeW5jQmF0Y2hlZExhbmUgPVxuLyogICAgICAgICAgICAgICAgICovXG4yO1xudmFyIElucHV0RGlzY3JldGVIeWRyYXRpb25MYW5lID1cbi8qICAgICAgKi9cbjQ7XG52YXIgSW5wdXREaXNjcmV0ZUxhbmVzID1cbi8qICAgICAgICAgICAgICAgICAgICAqL1xuMjQ7XG52YXIgSW5wdXRDb250aW51b3VzSHlkcmF0aW9uTGFuZSA9XG4vKiAgICAgICAgICAgKi9cbjMyO1xudmFyIElucHV0Q29udGludW91c0xhbmVzID1cbi8qICAgICAgICAgICAgICAgICAgKi9cbjE5MjtcbnZhciBEZWZhdWx0SHlkcmF0aW9uTGFuZSA9XG4vKiAgICAgICAgICAgICovXG4yNTY7XG52YXIgRGVmYXVsdExhbmVzID1cbi8qICAgICAgICAgICAgICAgICAgICovXG4zNTg0O1xudmFyIFRyYW5zaXRpb25IeWRyYXRpb25MYW5lID1cbi8qICAgICAgICAgICAgICAgICovXG40MDk2O1xudmFyIFRyYW5zaXRpb25MYW5lcyA9XG4vKiAgICAgICAgICAgICAgICAgICAgICAgKi9cbjQxODYxMTI7XG52YXIgUmV0cnlMYW5lcyA9XG4vKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuNjI5MTQ1NjA7XG52YXIgU29tZVJldHJ5TGFuZSA9XG4vKiAgICAgICAgICAgICAgICAgICovXG4zMzU1NDQzMjtcbnZhciBTZWxlY3RpdmVIeWRyYXRpb25MYW5lID1cbi8qICAgICAgICAgICovXG42NzEwODg2NDtcbnZhciBOb25JZGxlTGFuZXMgPVxuLyogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuMTM0MjE3NzI3O1xudmFyIElkbGVIeWRyYXRpb25MYW5lID1cbi8qICAgICAgICAgICAgICAgKi9cbjEzNDIxNzcyODtcbnZhciBJZGxlTGFuZXMgPVxuLyogICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG44MDUzMDYzNjg7XG52YXIgT2Zmc2NyZWVuTGFuZSA9XG4vKiAgICAgICAgICAgICAgICAgICAqL1xuMTA3Mzc0MTgyNDtcbnZhciBOb1RpbWVzdGFtcCA9IC0xO1xuZnVuY3Rpb24gc2V0Q3VycmVudFVwZGF0ZUxhbmVQcmlvcml0eShuZXdMYW5lUHJpb3JpdHkpIHtcbn0gLy8gXCJSZWdpc3RlcnNcIiB1c2VkIHRvIFwicmV0dXJuXCIgbXVsdGlwbGUgdmFsdWVzXG4vLyBVc2VkIGJ5IGdldEhpZ2hlc3RQcmlvcml0eUxhbmVzIGFuZCBnZXROZXh0TGFuZXM6XG5cbnZhciByZXR1cm5faGlnaGVzdExhbmVQcmlvcml0eSA9IERlZmF1bHRMYW5lUHJpb3JpdHk7XG5cbmZ1bmN0aW9uIGdldEhpZ2hlc3RQcmlvcml0eUxhbmVzKGxhbmVzKSB7XG4gIGlmICgoU3luY0xhbmUgJiBsYW5lcykgIT09IE5vTGFuZXMpIHtcbiAgICByZXR1cm5faGlnaGVzdExhbmVQcmlvcml0eSA9IFN5bmNMYW5lUHJpb3JpdHk7XG4gICAgcmV0dXJuIFN5bmNMYW5lO1xuICB9XG5cbiAgaWYgKChTeW5jQmF0Y2hlZExhbmUgJiBsYW5lcykgIT09IE5vTGFuZXMpIHtcbiAgICByZXR1cm5faGlnaGVzdExhbmVQcmlvcml0eSA9IFN5bmNCYXRjaGVkTGFuZVByaW9yaXR5O1xuICAgIHJldHVybiBTeW5jQmF0Y2hlZExhbmU7XG4gIH1cblxuICBpZiAoKElucHV0RGlzY3JldGVIeWRyYXRpb25MYW5lICYgbGFuZXMpICE9PSBOb0xhbmVzKSB7XG4gICAgcmV0dXJuX2hpZ2hlc3RMYW5lUHJpb3JpdHkgPSBJbnB1dERpc2NyZXRlSHlkcmF0aW9uTGFuZVByaW9yaXR5O1xuICAgIHJldHVybiBJbnB1dERpc2NyZXRlSHlkcmF0aW9uTGFuZTtcbiAgfVxuXG4gIHZhciBpbnB1dERpc2NyZXRlTGFuZXMgPSBJbnB1dERpc2NyZXRlTGFuZXMgJiBsYW5lcztcblxuICBpZiAoaW5wdXREaXNjcmV0ZUxhbmVzICE9PSBOb0xhbmVzKSB7XG4gICAgcmV0dXJuX2hpZ2hlc3RMYW5lUHJpb3JpdHkgPSBJbnB1dERpc2NyZXRlTGFuZVByaW9yaXR5O1xuICAgIHJldHVybiBpbnB1dERpc2NyZXRlTGFuZXM7XG4gIH1cblxuICBpZiAoKGxhbmVzICYgSW5wdXRDb250aW51b3VzSHlkcmF0aW9uTGFuZSkgIT09IE5vTGFuZXMpIHtcbiAgICByZXR1cm5faGlnaGVzdExhbmVQcmlvcml0eSA9IElucHV0Q29udGludW91c0h5ZHJhdGlvbkxhbmVQcmlvcml0eTtcbiAgICByZXR1cm4gSW5wdXRDb250aW51b3VzSHlkcmF0aW9uTGFuZTtcbiAgfVxuXG4gIHZhciBpbnB1dENvbnRpbnVvdXNMYW5lcyA9IElucHV0Q29udGludW91c0xhbmVzICYgbGFuZXM7XG5cbiAgaWYgKGlucHV0Q29udGludW91c0xhbmVzICE9PSBOb0xhbmVzKSB7XG4gICAgcmV0dXJuX2hpZ2hlc3RMYW5lUHJpb3JpdHkgPSBJbnB1dENvbnRpbnVvdXNMYW5lUHJpb3JpdHk7XG4gICAgcmV0dXJuIGlucHV0Q29udGludW91c0xhbmVzO1xuICB9XG5cbiAgaWYgKChsYW5lcyAmIERlZmF1bHRIeWRyYXRpb25MYW5lKSAhPT0gTm9MYW5lcykge1xuICAgIHJldHVybl9oaWdoZXN0TGFuZVByaW9yaXR5ID0gRGVmYXVsdEh5ZHJhdGlvbkxhbmVQcmlvcml0eTtcbiAgICByZXR1cm4gRGVmYXVsdEh5ZHJhdGlvbkxhbmU7XG4gIH1cblxuICB2YXIgZGVmYXVsdExhbmVzID0gRGVmYXVsdExhbmVzICYgbGFuZXM7XG5cbiAgaWYgKGRlZmF1bHRMYW5lcyAhPT0gTm9MYW5lcykge1xuICAgIHJldHVybl9oaWdoZXN0TGFuZVByaW9yaXR5ID0gRGVmYXVsdExhbmVQcmlvcml0eTtcbiAgICByZXR1cm4gZGVmYXVsdExhbmVzO1xuICB9XG5cbiAgaWYgKChsYW5lcyAmIFRyYW5zaXRpb25IeWRyYXRpb25MYW5lKSAhPT0gTm9MYW5lcykge1xuICAgIHJldHVybl9oaWdoZXN0TGFuZVByaW9yaXR5ID0gVHJhbnNpdGlvbkh5ZHJhdGlvblByaW9yaXR5O1xuICAgIHJldHVybiBUcmFuc2l0aW9uSHlkcmF0aW9uTGFuZTtcbiAgfVxuXG4gIHZhciB0cmFuc2l0aW9uTGFuZXMgPSBUcmFuc2l0aW9uTGFuZXMgJiBsYW5lcztcblxuICBpZiAodHJhbnNpdGlvbkxhbmVzICE9PSBOb0xhbmVzKSB7XG4gICAgcmV0dXJuX2hpZ2hlc3RMYW5lUHJpb3JpdHkgPSBUcmFuc2l0aW9uUHJpb3JpdHk7XG4gICAgcmV0dXJuIHRyYW5zaXRpb25MYW5lcztcbiAgfVxuXG4gIHZhciByZXRyeUxhbmVzID0gUmV0cnlMYW5lcyAmIGxhbmVzO1xuXG4gIGlmIChyZXRyeUxhbmVzICE9PSBOb0xhbmVzKSB7XG4gICAgcmV0dXJuX2hpZ2hlc3RMYW5lUHJpb3JpdHkgPSBSZXRyeUxhbmVQcmlvcml0eTtcbiAgICByZXR1cm4gcmV0cnlMYW5lcztcbiAgfVxuXG4gIGlmIChsYW5lcyAmIFNlbGVjdGl2ZUh5ZHJhdGlvbkxhbmUpIHtcbiAgICByZXR1cm5faGlnaGVzdExhbmVQcmlvcml0eSA9IFNlbGVjdGl2ZUh5ZHJhdGlvbkxhbmVQcmlvcml0eTtcbiAgICByZXR1cm4gU2VsZWN0aXZlSHlkcmF0aW9uTGFuZTtcbiAgfVxuXG4gIGlmICgobGFuZXMgJiBJZGxlSHlkcmF0aW9uTGFuZSkgIT09IE5vTGFuZXMpIHtcbiAgICByZXR1cm5faGlnaGVzdExhbmVQcmlvcml0eSA9IElkbGVIeWRyYXRpb25MYW5lUHJpb3JpdHk7XG4gICAgcmV0dXJuIElkbGVIeWRyYXRpb25MYW5lO1xuICB9XG5cbiAgdmFyIGlkbGVMYW5lcyA9IElkbGVMYW5lcyAmIGxhbmVzO1xuXG4gIGlmIChpZGxlTGFuZXMgIT09IE5vTGFuZXMpIHtcbiAgICByZXR1cm5faGlnaGVzdExhbmVQcmlvcml0eSA9IElkbGVMYW5lUHJpb3JpdHk7XG4gICAgcmV0dXJuIGlkbGVMYW5lcztcbiAgfVxuXG4gIGlmICgoT2Zmc2NyZWVuTGFuZSAmIGxhbmVzKSAhPT0gTm9MYW5lcykge1xuICAgIHJldHVybl9oaWdoZXN0TGFuZVByaW9yaXR5ID0gT2Zmc2NyZWVuTGFuZVByaW9yaXR5O1xuICAgIHJldHVybiBPZmZzY3JlZW5MYW5lO1xuICB9XG5cbiAge1xuICAgIGVycm9yKCdTaG91bGQgaGF2ZSBmb3VuZCBtYXRjaGluZyBsYW5lcy4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC4nKTtcbiAgfSAvLyBUaGlzIHNob3VsZG4ndCBiZSByZWFjaGFibGUsIGJ1dCBhcyBhIGZhbGxiYWNrLCByZXR1cm4gdGhlIGVudGlyZSBiaXRtYXNrLlxuXG5cbiAgcmV0dXJuX2hpZ2hlc3RMYW5lUHJpb3JpdHkgPSBEZWZhdWx0TGFuZVByaW9yaXR5O1xuICByZXR1cm4gbGFuZXM7XG59XG5cbmZ1bmN0aW9uIHNjaGVkdWxlclByaW9yaXR5VG9MYW5lUHJpb3JpdHkoc2NoZWR1bGVyUHJpb3JpdHlMZXZlbCkge1xuICBzd2l0Y2ggKHNjaGVkdWxlclByaW9yaXR5TGV2ZWwpIHtcbiAgICBjYXNlIEltbWVkaWF0ZVByaW9yaXR5OlxuICAgICAgcmV0dXJuIFN5bmNMYW5lUHJpb3JpdHk7XG5cbiAgICBjYXNlIFVzZXJCbG9ja2luZ1ByaW9yaXR5OlxuICAgICAgcmV0dXJuIElucHV0Q29udGludW91c0xhbmVQcmlvcml0eTtcblxuICAgIGNhc2UgTm9ybWFsUHJpb3JpdHk6XG4gICAgY2FzZSBMb3dQcmlvcml0eTpcbiAgICAgIC8vIFRPRE86IEhhbmRsZSBMb3dTY2hlZHVsZXJQcmlvcml0eSwgc29tZWhvdy4gTWF5YmUgdGhlIHNhbWUgbGFuZSBhcyBoeWRyYXRpb24uXG4gICAgICByZXR1cm4gRGVmYXVsdExhbmVQcmlvcml0eTtcblxuICAgIGNhc2UgSWRsZVByaW9yaXR5OlxuICAgICAgcmV0dXJuIElkbGVMYW5lUHJpb3JpdHk7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIE5vTGFuZVByaW9yaXR5O1xuICB9XG59XG5mdW5jdGlvbiBsYW5lUHJpb3JpdHlUb1NjaGVkdWxlclByaW9yaXR5KGxhbmVQcmlvcml0eSkge1xuICBzd2l0Y2ggKGxhbmVQcmlvcml0eSkge1xuICAgIGNhc2UgU3luY0xhbmVQcmlvcml0eTpcbiAgICBjYXNlIFN5bmNCYXRjaGVkTGFuZVByaW9yaXR5OlxuICAgICAgcmV0dXJuIEltbWVkaWF0ZVByaW9yaXR5O1xuXG4gICAgY2FzZSBJbnB1dERpc2NyZXRlSHlkcmF0aW9uTGFuZVByaW9yaXR5OlxuICAgIGNhc2UgSW5wdXREaXNjcmV0ZUxhbmVQcmlvcml0eTpcbiAgICBjYXNlIElucHV0Q29udGludW91c0h5ZHJhdGlvbkxhbmVQcmlvcml0eTpcbiAgICBjYXNlIElucHV0Q29udGludW91c0xhbmVQcmlvcml0eTpcbiAgICAgIHJldHVybiBVc2VyQmxvY2tpbmdQcmlvcml0eTtcblxuICAgIGNhc2UgRGVmYXVsdEh5ZHJhdGlvbkxhbmVQcmlvcml0eTpcbiAgICBjYXNlIERlZmF1bHRMYW5lUHJpb3JpdHk6XG4gICAgY2FzZSBUcmFuc2l0aW9uSHlkcmF0aW9uUHJpb3JpdHk6XG4gICAgY2FzZSBUcmFuc2l0aW9uUHJpb3JpdHk6XG4gICAgY2FzZSBTZWxlY3RpdmVIeWRyYXRpb25MYW5lUHJpb3JpdHk6XG4gICAgY2FzZSBSZXRyeUxhbmVQcmlvcml0eTpcbiAgICAgIHJldHVybiBOb3JtYWxQcmlvcml0eTtcblxuICAgIGNhc2UgSWRsZUh5ZHJhdGlvbkxhbmVQcmlvcml0eTpcbiAgICBjYXNlIElkbGVMYW5lUHJpb3JpdHk6XG4gICAgY2FzZSBPZmZzY3JlZW5MYW5lUHJpb3JpdHk6XG4gICAgICByZXR1cm4gSWRsZVByaW9yaXR5O1xuXG4gICAgY2FzZSBOb0xhbmVQcmlvcml0eTpcbiAgICAgIHJldHVybiBOb1ByaW9yaXR5O1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHtcbiAgICAgICAge1xuICAgICAgICAgIHRocm93IEVycm9yKCBcIkludmFsaWQgdXBkYXRlIHByaW9yaXR5OiBcIiArIGxhbmVQcmlvcml0eSArIFwiLiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0LlwiICk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICB9XG59XG5mdW5jdGlvbiBnZXROZXh0TGFuZXMocm9vdCwgd2lwTGFuZXMpIHtcbiAgLy8gRWFybHkgYmFpbG91dCBpZiB0aGVyZSdzIG5vIHBlbmRpbmcgd29yayBsZWZ0LlxuICB2YXIgcGVuZGluZ0xhbmVzID0gcm9vdC5wZW5kaW5nTGFuZXM7XG5cbiAgaWYgKHBlbmRpbmdMYW5lcyA9PT0gTm9MYW5lcykge1xuICAgIHJldHVybl9oaWdoZXN0TGFuZVByaW9yaXR5ID0gTm9MYW5lUHJpb3JpdHk7XG4gICAgcmV0dXJuIE5vTGFuZXM7XG4gIH1cblxuICB2YXIgbmV4dExhbmVzID0gTm9MYW5lcztcbiAgdmFyIG5leHRMYW5lUHJpb3JpdHkgPSBOb0xhbmVQcmlvcml0eTtcbiAgdmFyIGV4cGlyZWRMYW5lcyA9IHJvb3QuZXhwaXJlZExhbmVzO1xuICB2YXIgc3VzcGVuZGVkTGFuZXMgPSByb290LnN1c3BlbmRlZExhbmVzO1xuICB2YXIgcGluZ2VkTGFuZXMgPSByb290LnBpbmdlZExhbmVzOyAvLyBDaGVjayBpZiBhbnkgd29yayBoYXMgZXhwaXJlZC5cblxuICBpZiAoZXhwaXJlZExhbmVzICE9PSBOb0xhbmVzKSB7XG4gICAgbmV4dExhbmVzID0gZXhwaXJlZExhbmVzO1xuICAgIG5leHRMYW5lUHJpb3JpdHkgPSByZXR1cm5faGlnaGVzdExhbmVQcmlvcml0eSA9IFN5bmNMYW5lUHJpb3JpdHk7XG4gIH0gZWxzZSB7XG4gICAgLy8gRG8gbm90IHdvcmsgb24gYW55IGlkbGUgd29yayB1bnRpbCBhbGwgdGhlIG5vbi1pZGxlIHdvcmsgaGFzIGZpbmlzaGVkLFxuICAgIC8vIGV2ZW4gaWYgdGhlIHdvcmsgaXMgc3VzcGVuZGVkLlxuICAgIHZhciBub25JZGxlUGVuZGluZ0xhbmVzID0gcGVuZGluZ0xhbmVzICYgTm9uSWRsZUxhbmVzO1xuXG4gICAgaWYgKG5vbklkbGVQZW5kaW5nTGFuZXMgIT09IE5vTGFuZXMpIHtcbiAgICAgIHZhciBub25JZGxlVW5ibG9ja2VkTGFuZXMgPSBub25JZGxlUGVuZGluZ0xhbmVzICYgfnN1c3BlbmRlZExhbmVzO1xuXG4gICAgICBpZiAobm9uSWRsZVVuYmxvY2tlZExhbmVzICE9PSBOb0xhbmVzKSB7XG4gICAgICAgIG5leHRMYW5lcyA9IGdldEhpZ2hlc3RQcmlvcml0eUxhbmVzKG5vbklkbGVVbmJsb2NrZWRMYW5lcyk7XG4gICAgICAgIG5leHRMYW5lUHJpb3JpdHkgPSByZXR1cm5faGlnaGVzdExhbmVQcmlvcml0eTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBub25JZGxlUGluZ2VkTGFuZXMgPSBub25JZGxlUGVuZGluZ0xhbmVzICYgcGluZ2VkTGFuZXM7XG5cbiAgICAgICAgaWYgKG5vbklkbGVQaW5nZWRMYW5lcyAhPT0gTm9MYW5lcykge1xuICAgICAgICAgIG5leHRMYW5lcyA9IGdldEhpZ2hlc3RQcmlvcml0eUxhbmVzKG5vbklkbGVQaW5nZWRMYW5lcyk7XG4gICAgICAgICAgbmV4dExhbmVQcmlvcml0eSA9IHJldHVybl9oaWdoZXN0TGFuZVByaW9yaXR5O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRoZSBvbmx5IHJlbWFpbmluZyB3b3JrIGlzIElkbGUuXG4gICAgICB2YXIgdW5ibG9ja2VkTGFuZXMgPSBwZW5kaW5nTGFuZXMgJiB+c3VzcGVuZGVkTGFuZXM7XG5cbiAgICAgIGlmICh1bmJsb2NrZWRMYW5lcyAhPT0gTm9MYW5lcykge1xuICAgICAgICBuZXh0TGFuZXMgPSBnZXRIaWdoZXN0UHJpb3JpdHlMYW5lcyh1bmJsb2NrZWRMYW5lcyk7XG4gICAgICAgIG5leHRMYW5lUHJpb3JpdHkgPSByZXR1cm5faGlnaGVzdExhbmVQcmlvcml0eTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChwaW5nZWRMYW5lcyAhPT0gTm9MYW5lcykge1xuICAgICAgICAgIG5leHRMYW5lcyA9IGdldEhpZ2hlc3RQcmlvcml0eUxhbmVzKHBpbmdlZExhbmVzKTtcbiAgICAgICAgICBuZXh0TGFuZVByaW9yaXR5ID0gcmV0dXJuX2hpZ2hlc3RMYW5lUHJpb3JpdHk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAobmV4dExhbmVzID09PSBOb0xhbmVzKSB7XG4gICAgLy8gVGhpcyBzaG91bGQgb25seSBiZSByZWFjaGFibGUgaWYgd2UncmUgc3VzcGVuZGVkXG4gICAgLy8gVE9ETzogQ29uc2lkZXIgd2FybmluZyBpbiB0aGlzIHBhdGggaWYgYSBmYWxsYmFjayB0aW1lciBpcyBub3Qgc2NoZWR1bGVkLlxuICAgIHJldHVybiBOb0xhbmVzO1xuICB9IC8vIElmIHRoZXJlIGFyZSBoaWdoZXIgcHJpb3JpdHkgbGFuZXMsIHdlJ2xsIGluY2x1ZGUgdGhlbSBldmVuIGlmIHRoZXlcbiAgLy8gYXJlIHN1c3BlbmRlZC5cblxuXG4gIG5leHRMYW5lcyA9IHBlbmRpbmdMYW5lcyAmIGdldEVxdWFsT3JIaWdoZXJQcmlvcml0eUxhbmVzKG5leHRMYW5lcyk7IC8vIElmIHdlJ3JlIGFscmVhZHkgaW4gdGhlIG1pZGRsZSBvZiBhIHJlbmRlciwgc3dpdGNoaW5nIGxhbmVzIHdpbGwgaW50ZXJydXB0XG4gIC8vIGl0IGFuZCB3ZSdsbCBsb3NlIG91ciBwcm9ncmVzcy4gV2Ugc2hvdWxkIG9ubHkgZG8gdGhpcyBpZiB0aGUgbmV3IGxhbmVzIGFyZVxuICAvLyBoaWdoZXIgcHJpb3JpdHkuXG5cbiAgaWYgKHdpcExhbmVzICE9PSBOb0xhbmVzICYmIHdpcExhbmVzICE9PSBuZXh0TGFuZXMgJiYgLy8gSWYgd2UgYWxyZWFkeSBzdXNwZW5kZWQgd2l0aCBhIGRlbGF5LCB0aGVuIGludGVycnVwdGluZyBpcyBmaW5lLiBEb24ndFxuICAvLyBib3RoZXIgd2FpdGluZyB1bnRpbCB0aGUgcm9vdCBpcyBjb21wbGV0ZS5cbiAgKHdpcExhbmVzICYgc3VzcGVuZGVkTGFuZXMpID09PSBOb0xhbmVzKSB7XG4gICAgZ2V0SGlnaGVzdFByaW9yaXR5TGFuZXMod2lwTGFuZXMpO1xuICAgIHZhciB3aXBMYW5lUHJpb3JpdHkgPSByZXR1cm5faGlnaGVzdExhbmVQcmlvcml0eTtcblxuICAgIGlmIChuZXh0TGFuZVByaW9yaXR5IDw9IHdpcExhbmVQcmlvcml0eSkge1xuICAgICAgcmV0dXJuIHdpcExhbmVzO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm5faGlnaGVzdExhbmVQcmlvcml0eSA9IG5leHRMYW5lUHJpb3JpdHk7XG4gICAgfVxuICB9IC8vIENoZWNrIGZvciBlbnRhbmdsZWQgbGFuZXMgYW5kIGFkZCB0aGVtIHRvIHRoZSBiYXRjaC5cbiAgLy9cbiAgLy8gQSBsYW5lIGlzIHNhaWQgdG8gYmUgZW50YW5nbGVkIHdpdGggYW5vdGhlciB3aGVuIGl0J3Mgbm90IGFsbG93ZWQgdG8gcmVuZGVyXG4gIC8vIGluIGEgYmF0Y2ggdGhhdCBkb2VzIG5vdCBhbHNvIGluY2x1ZGUgdGhlIG90aGVyIGxhbmUuIFR5cGljYWxseSB3ZSBkbyB0aGlzXG4gIC8vIHdoZW4gbXVsdGlwbGUgdXBkYXRlcyBoYXZlIHRoZSBzYW1lIHNvdXJjZSwgYW5kIHdlIG9ubHkgd2FudCB0byByZXNwb25kIHRvXG4gIC8vIHRoZSBtb3N0IHJlY2VudCBldmVudCBmcm9tIHRoYXQgc291cmNlLlxuICAvL1xuICAvLyBOb3RlIHRoYXQgd2UgYXBwbHkgZW50YW5nbGVtZW50cyAqYWZ0ZXIqIGNoZWNraW5nIGZvciBwYXJ0aWFsIHdvcmsgYWJvdmUuXG4gIC8vIFRoaXMgbWVhbnMgdGhhdCBpZiBhIGxhbmUgaXMgZW50YW5nbGVkIGR1cmluZyBhbiBpbnRlcmxlYXZlZCBldmVudCB3aGlsZVxuICAvLyBpdCdzIGFscmVhZHkgcmVuZGVyaW5nLCB3ZSB3b24ndCBpbnRlcnJ1cHQgaXQuIFRoaXMgaXMgaW50ZW50aW9uYWwsIHNpbmNlXG4gIC8vIGVudGFuZ2xlbWVudCBpcyB1c3VhbGx5IFwiYmVzdCBlZmZvcnRcIjogd2UnbGwgdHJ5IG91ciBiZXN0IHRvIHJlbmRlciB0aGVcbiAgLy8gbGFuZXMgaW4gdGhlIHNhbWUgYmF0Y2gsIGJ1dCBpdCdzIG5vdCB3b3J0aCB0aHJvd2luZyBvdXQgcGFydGlhbGx5XG4gIC8vIGNvbXBsZXRlZCB3b3JrIGluIG9yZGVyIHRvIGRvIGl0LlxuICAvL1xuICAvLyBGb3IgdGhvc2UgZXhjZXB0aW9ucyB3aGVyZSBlbnRhbmdsZW1lbnQgaXMgc2VtYW50aWNhbGx5IGltcG9ydGFudCwgbGlrZVxuICAvLyB1c2VNdXRhYmxlU291cmNlLCB3ZSBzaG91bGQgZW5zdXJlIHRoYXQgdGhlcmUgaXMgbm8gcGFydGlhbCB3b3JrIGF0IHRoZVxuICAvLyB0aW1lIHdlIGFwcGx5IHRoZSBlbnRhbmdsZW1lbnQuXG5cblxuICB2YXIgZW50YW5nbGVkTGFuZXMgPSByb290LmVudGFuZ2xlZExhbmVzO1xuXG4gIGlmIChlbnRhbmdsZWRMYW5lcyAhPT0gTm9MYW5lcykge1xuICAgIHZhciBlbnRhbmdsZW1lbnRzID0gcm9vdC5lbnRhbmdsZW1lbnRzO1xuICAgIHZhciBsYW5lcyA9IG5leHRMYW5lcyAmIGVudGFuZ2xlZExhbmVzO1xuXG4gICAgd2hpbGUgKGxhbmVzID4gMCkge1xuICAgICAgdmFyIGluZGV4ID0gcGlja0FyYml0cmFyeUxhbmVJbmRleChsYW5lcyk7XG4gICAgICB2YXIgbGFuZSA9IDEgPDwgaW5kZXg7XG4gICAgICBuZXh0TGFuZXMgfD0gZW50YW5nbGVtZW50c1tpbmRleF07XG4gICAgICBsYW5lcyAmPSB+bGFuZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmV4dExhbmVzO1xufVxuZnVuY3Rpb24gZ2V0TW9zdFJlY2VudEV2ZW50VGltZShyb290LCBsYW5lcykge1xuICB2YXIgZXZlbnRUaW1lcyA9IHJvb3QuZXZlbnRUaW1lcztcbiAgdmFyIG1vc3RSZWNlbnRFdmVudFRpbWUgPSBOb1RpbWVzdGFtcDtcblxuICB3aGlsZSAobGFuZXMgPiAwKSB7XG4gICAgdmFyIGluZGV4ID0gcGlja0FyYml0cmFyeUxhbmVJbmRleChsYW5lcyk7XG4gICAgdmFyIGxhbmUgPSAxIDw8IGluZGV4O1xuICAgIHZhciBldmVudFRpbWUgPSBldmVudFRpbWVzW2luZGV4XTtcblxuICAgIGlmIChldmVudFRpbWUgPiBtb3N0UmVjZW50RXZlbnRUaW1lKSB7XG4gICAgICBtb3N0UmVjZW50RXZlbnRUaW1lID0gZXZlbnRUaW1lO1xuICAgIH1cblxuICAgIGxhbmVzICY9IH5sYW5lO1xuICB9XG5cbiAgcmV0dXJuIG1vc3RSZWNlbnRFdmVudFRpbWU7XG59XG5cbmZ1bmN0aW9uIGNvbXB1dGVFeHBpcmF0aW9uVGltZShsYW5lLCBjdXJyZW50VGltZSkge1xuICAvLyBUT0RPOiBFeHBpcmF0aW9uIGhldXJpc3RpYyBpcyBjb25zdGFudCBwZXIgbGFuZSwgc28gY291bGQgdXNlIGEgbWFwLlxuICBnZXRIaWdoZXN0UHJpb3JpdHlMYW5lcyhsYW5lKTtcbiAgdmFyIHByaW9yaXR5ID0gcmV0dXJuX2hpZ2hlc3RMYW5lUHJpb3JpdHk7XG5cbiAgaWYgKHByaW9yaXR5ID49IElucHV0Q29udGludW91c0xhbmVQcmlvcml0eSkge1xuICAgIC8vIFVzZXIgaW50ZXJhY3Rpb25zIHNob3VsZCBleHBpcmUgc2xpZ2h0bHkgbW9yZSBxdWlja2x5LlxuICAgIC8vXG4gICAgLy8gTk9URTogVGhpcyBpcyBzZXQgdG8gdGhlIGNvcnJlc3BvbmRpbmcgY29uc3RhbnQgYXMgaW4gU2NoZWR1bGVyLmpzLiBXaGVuXG4gICAgLy8gd2UgbWFkZSBpdCBsYXJnZXIsIGEgcHJvZHVjdCBtZXRyaWMgaW4gd3d3IHJlZ3Jlc3NlZCwgc3VnZ2VzdGluZyB0aGVyZSdzXG4gICAgLy8gYSB1c2VyIGludGVyYWN0aW9uIHRoYXQncyBiZWluZyBzdGFydmVkIGJ5IGEgc2VyaWVzIG9mIHN5bmNocm9ub3VzXG4gICAgLy8gdXBkYXRlcy4gSWYgdGhhdCB0aGVvcnkgaXMgY29ycmVjdCwgdGhlIHByb3BlciBzb2x1dGlvbiBpcyB0byBmaXggdGhlXG4gICAgLy8gc3RhcnZhdGlvbi4gSG93ZXZlciwgdGhpcyBzY2VuYXJpbyBzdXBwb3J0cyB0aGUgaWRlYSB0aGF0IGV4cGlyYXRpb25cbiAgICAvLyB0aW1lcyBhcmUgYW4gaW1wb3J0YW50IHNhZmVndWFyZCB3aGVuIHN0YXJ2YXRpb24gZG9lcyBoYXBwZW4uXG4gICAgLy9cbiAgICAvLyBBbHNvIG5vdGUgdGhhdCwgaW4gdGhlIGNhc2Ugb2YgdXNlciBpbnB1dCBzcGVjaWZpY2FsbHksIHRoaXMgd2lsbCBzb29uIG5vXG4gICAgLy8gbG9uZ2VyIGJlIGFuIGlzc3VlIGJlY2F1c2Ugd2UgcGxhbiB0byBtYWtlIHVzZXIgaW5wdXQgc3luY2hyb25vdXMgYnlcbiAgICAvLyBkZWZhdWx0ICh1bnRpbCB5b3UgZW50ZXIgYHN0YXJ0VHJhbnNpdGlvbmAsIG9mIGNvdXJzZS4pXG4gICAgLy9cbiAgICAvLyBJZiB3ZXJlbid0IHBsYW5uaW5nIHRvIG1ha2UgdGhlc2UgdXBkYXRlcyBzeW5jaHJvbm91cyBzb29uIGFueXdheSwgSVxuICAgIC8vIHdvdWxkIHByb2JhYmx5IG1ha2UgdGhpcyBudW1iZXIgYSBjb25maWd1cmFibGUgcGFyYW1ldGVyLlxuICAgIHJldHVybiBjdXJyZW50VGltZSArIDI1MDtcbiAgfSBlbHNlIGlmIChwcmlvcml0eSA+PSBUcmFuc2l0aW9uUHJpb3JpdHkpIHtcbiAgICByZXR1cm4gY3VycmVudFRpbWUgKyA1MDAwO1xuICB9IGVsc2Uge1xuICAgIC8vIEFueXRoaW5nIGlkbGUgcHJpb3JpdHkgb3IgbG93ZXIgc2hvdWxkIG5ldmVyIGV4cGlyZS5cbiAgICByZXR1cm4gTm9UaW1lc3RhbXA7XG4gIH1cbn1cblxuZnVuY3Rpb24gbWFya1N0YXJ2ZWRMYW5lc0FzRXhwaXJlZChyb290LCBjdXJyZW50VGltZSkge1xuICAvLyBUT0RPOiBUaGlzIGdldHMgY2FsbGVkIGV2ZXJ5IHRpbWUgd2UgeWllbGQuIFdlIGNhbiBvcHRpbWl6ZSBieSBzdG9yaW5nXG4gIC8vIHRoZSBlYXJsaWVzdCBleHBpcmF0aW9uIHRpbWUgb24gdGhlIHJvb3QuIFRoZW4gdXNlIHRoYXQgdG8gcXVpY2tseSBiYWlsIG91dFxuICAvLyBvZiB0aGlzIGZ1bmN0aW9uLlxuICB2YXIgcGVuZGluZ0xhbmVzID0gcm9vdC5wZW5kaW5nTGFuZXM7XG4gIHZhciBzdXNwZW5kZWRMYW5lcyA9IHJvb3Quc3VzcGVuZGVkTGFuZXM7XG4gIHZhciBwaW5nZWRMYW5lcyA9IHJvb3QucGluZ2VkTGFuZXM7XG4gIHZhciBleHBpcmF0aW9uVGltZXMgPSByb290LmV4cGlyYXRpb25UaW1lczsgLy8gSXRlcmF0ZSB0aHJvdWdoIHRoZSBwZW5kaW5nIGxhbmVzIGFuZCBjaGVjayBpZiB3ZSd2ZSByZWFjaGVkIHRoZWlyXG4gIC8vIGV4cGlyYXRpb24gdGltZS4gSWYgc28sIHdlJ2xsIGFzc3VtZSB0aGUgdXBkYXRlIGlzIGJlaW5nIHN0YXJ2ZWQgYW5kIG1hcmtcbiAgLy8gaXQgYXMgZXhwaXJlZCB0byBmb3JjZSBpdCB0byBmaW5pc2guXG5cbiAgdmFyIGxhbmVzID0gcGVuZGluZ0xhbmVzO1xuXG4gIHdoaWxlIChsYW5lcyA+IDApIHtcbiAgICB2YXIgaW5kZXggPSBwaWNrQXJiaXRyYXJ5TGFuZUluZGV4KGxhbmVzKTtcbiAgICB2YXIgbGFuZSA9IDEgPDwgaW5kZXg7XG4gICAgdmFyIGV4cGlyYXRpb25UaW1lID0gZXhwaXJhdGlvblRpbWVzW2luZGV4XTtcblxuICAgIGlmIChleHBpcmF0aW9uVGltZSA9PT0gTm9UaW1lc3RhbXApIHtcbiAgICAgIC8vIEZvdW5kIGEgcGVuZGluZyBsYW5lIHdpdGggbm8gZXhwaXJhdGlvbiB0aW1lLiBJZiBpdCdzIG5vdCBzdXNwZW5kZWQsIG9yXG4gICAgICAvLyBpZiBpdCdzIHBpbmdlZCwgYXNzdW1lIGl0J3MgQ1BVLWJvdW5kLiBDb21wdXRlIGEgbmV3IGV4cGlyYXRpb24gdGltZVxuICAgICAgLy8gdXNpbmcgdGhlIGN1cnJlbnQgdGltZS5cbiAgICAgIGlmICgobGFuZSAmIHN1c3BlbmRlZExhbmVzKSA9PT0gTm9MYW5lcyB8fCAobGFuZSAmIHBpbmdlZExhbmVzKSAhPT0gTm9MYW5lcykge1xuICAgICAgICAvLyBBc3N1bWVzIHRpbWVzdGFtcHMgYXJlIG1vbm90b25pY2FsbHkgaW5jcmVhc2luZy5cbiAgICAgICAgZXhwaXJhdGlvblRpbWVzW2luZGV4XSA9IGNvbXB1dGVFeHBpcmF0aW9uVGltZShsYW5lLCBjdXJyZW50VGltZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChleHBpcmF0aW9uVGltZSA8PSBjdXJyZW50VGltZSkge1xuICAgICAgLy8gVGhpcyBsYW5lIGV4cGlyZWRcbiAgICAgIHJvb3QuZXhwaXJlZExhbmVzIHw9IGxhbmU7XG4gICAgfVxuXG4gICAgbGFuZXMgJj0gfmxhbmU7XG4gIH1cbn0gLy8gVGhpcyByZXR1cm5zIHRoZSBoaWdoZXN0IHByaW9yaXR5IHBlbmRpbmcgbGFuZXMgcmVnYXJkbGVzcyBvZiB3aGV0aGVyIHRoZXlcbmZ1bmN0aW9uIGdldExhbmVzVG9SZXRyeVN5bmNocm9ub3VzbHlPbkVycm9yKHJvb3QpIHtcbiAgdmFyIGV2ZXJ5dGhpbmdCdXRPZmZzY3JlZW4gPSByb290LnBlbmRpbmdMYW5lcyAmIH5PZmZzY3JlZW5MYW5lO1xuXG4gIGlmIChldmVyeXRoaW5nQnV0T2Zmc2NyZWVuICE9PSBOb0xhbmVzKSB7XG4gICAgcmV0dXJuIGV2ZXJ5dGhpbmdCdXRPZmZzY3JlZW47XG4gIH1cblxuICBpZiAoZXZlcnl0aGluZ0J1dE9mZnNjcmVlbiAmIE9mZnNjcmVlbkxhbmUpIHtcbiAgICByZXR1cm4gT2Zmc2NyZWVuTGFuZTtcbiAgfVxuXG4gIHJldHVybiBOb0xhbmVzO1xufVxuZnVuY3Rpb24gcmV0dXJuTmV4dExhbmVzUHJpb3JpdHkoKSB7XG4gIHJldHVybiByZXR1cm5faGlnaGVzdExhbmVQcmlvcml0eTtcbn1cbmZ1bmN0aW9uIGluY2x1ZGVzTm9uSWRsZVdvcmsobGFuZXMpIHtcbiAgcmV0dXJuIChsYW5lcyAmIE5vbklkbGVMYW5lcykgIT09IE5vTGFuZXM7XG59XG5mdW5jdGlvbiBpbmNsdWRlc09ubHlSZXRyaWVzKGxhbmVzKSB7XG4gIHJldHVybiAobGFuZXMgJiBSZXRyeUxhbmVzKSA9PT0gbGFuZXM7XG59XG5mdW5jdGlvbiBpbmNsdWRlc09ubHlUcmFuc2l0aW9ucyhsYW5lcykge1xuICByZXR1cm4gKGxhbmVzICYgVHJhbnNpdGlvbkxhbmVzKSA9PT0gbGFuZXM7XG59IC8vIFRvIGVuc3VyZSBjb25zaXN0ZW5jeSBhY3Jvc3MgbXVsdGlwbGUgdXBkYXRlcyBpbiB0aGUgc2FtZSBldmVudCwgdGhpcyBzaG91bGRcbi8vIGJlIGEgcHVyZSBmdW5jdGlvbiwgc28gdGhhdCBpdCBhbHdheXMgcmV0dXJucyB0aGUgc2FtZSBsYW5lIGZvciBnaXZlbiBpbnB1dHMuXG5cbmZ1bmN0aW9uIGZpbmRVcGRhdGVMYW5lKGxhbmVQcmlvcml0eSwgd2lwTGFuZXMpIHtcbiAgc3dpdGNoIChsYW5lUHJpb3JpdHkpIHtcbiAgICBjYXNlIE5vTGFuZVByaW9yaXR5OlxuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIFN5bmNMYW5lUHJpb3JpdHk6XG4gICAgICByZXR1cm4gU3luY0xhbmU7XG5cbiAgICBjYXNlIFN5bmNCYXRjaGVkTGFuZVByaW9yaXR5OlxuICAgICAgcmV0dXJuIFN5bmNCYXRjaGVkTGFuZTtcblxuICAgIGNhc2UgSW5wdXREaXNjcmV0ZUxhbmVQcmlvcml0eTpcbiAgICAgIHtcbiAgICAgICAgdmFyIF9sYW5lID0gcGlja0FyYml0cmFyeUxhbmUoSW5wdXREaXNjcmV0ZUxhbmVzICYgfndpcExhbmVzKTtcblxuICAgICAgICBpZiAoX2xhbmUgPT09IE5vTGFuZSkge1xuICAgICAgICAgIC8vIFNoaWZ0IHRvIHRoZSBuZXh0IHByaW9yaXR5IGxldmVsXG4gICAgICAgICAgcmV0dXJuIGZpbmRVcGRhdGVMYW5lKElucHV0Q29udGludW91c0xhbmVQcmlvcml0eSwgd2lwTGFuZXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIF9sYW5lO1xuICAgICAgfVxuXG4gICAgY2FzZSBJbnB1dENvbnRpbnVvdXNMYW5lUHJpb3JpdHk6XG4gICAgICB7XG4gICAgICAgIHZhciBfbGFuZTIgPSBwaWNrQXJiaXRyYXJ5TGFuZShJbnB1dENvbnRpbnVvdXNMYW5lcyAmIH53aXBMYW5lcyk7XG5cbiAgICAgICAgaWYgKF9sYW5lMiA9PT0gTm9MYW5lKSB7XG4gICAgICAgICAgLy8gU2hpZnQgdG8gdGhlIG5leHQgcHJpb3JpdHkgbGV2ZWxcbiAgICAgICAgICByZXR1cm4gZmluZFVwZGF0ZUxhbmUoRGVmYXVsdExhbmVQcmlvcml0eSwgd2lwTGFuZXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIF9sYW5lMjtcbiAgICAgIH1cblxuICAgIGNhc2UgRGVmYXVsdExhbmVQcmlvcml0eTpcbiAgICAgIHtcbiAgICAgICAgdmFyIF9sYW5lMyA9IHBpY2tBcmJpdHJhcnlMYW5lKERlZmF1bHRMYW5lcyAmIH53aXBMYW5lcyk7XG5cbiAgICAgICAgaWYgKF9sYW5lMyA9PT0gTm9MYW5lKSB7XG4gICAgICAgICAgLy8gSWYgYWxsIHRoZSBkZWZhdWx0IGxhbmVzIGFyZSBhbHJlYWR5IGJlaW5nIHdvcmtlZCBvbiwgbG9vayBmb3IgYVxuICAgICAgICAgIC8vIGxhbmUgaW4gdGhlIHRyYW5zaXRpb24gcmFuZ2UuXG4gICAgICAgICAgX2xhbmUzID0gcGlja0FyYml0cmFyeUxhbmUoVHJhbnNpdGlvbkxhbmVzICYgfndpcExhbmVzKTtcblxuICAgICAgICAgIGlmIChfbGFuZTMgPT09IE5vTGFuZSkge1xuICAgICAgICAgICAgLy8gQWxsIHRoZSB0cmFuc2l0aW9uIGxhbmVzIGFyZSB0YWtlbiwgdG9vLiBUaGlzIHNob3VsZCBiZSB2ZXJ5XG4gICAgICAgICAgICAvLyByYXJlLCBidXQgYXMgYSBsYXN0IHJlc29ydCwgcGljayBhIGRlZmF1bHQgbGFuZS4gVGhpcyB3aWxsIGhhdmVcbiAgICAgICAgICAgIC8vIHRoZSBlZmZlY3Qgb2YgaW50ZXJydXB0aW5nIHRoZSBjdXJyZW50IHdvcmstaW4tcHJvZ3Jlc3MgcmVuZGVyLlxuICAgICAgICAgICAgX2xhbmUzID0gcGlja0FyYml0cmFyeUxhbmUoRGVmYXVsdExhbmVzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gX2xhbmUzO1xuICAgICAgfVxuXG4gICAgY2FzZSBUcmFuc2l0aW9uUHJpb3JpdHk6IC8vIFNob3VsZCBiZSBoYW5kbGVkIGJ5IGZpbmRUcmFuc2l0aW9uTGFuZSBpbnN0ZWFkXG5cbiAgICBjYXNlIFJldHJ5TGFuZVByaW9yaXR5OlxuICAgICAgLy8gU2hvdWxkIGJlIGhhbmRsZWQgYnkgZmluZFJldHJ5TGFuZSBpbnN0ZWFkXG4gICAgICBicmVhaztcblxuICAgIGNhc2UgSWRsZUxhbmVQcmlvcml0eTpcbiAgICAgIHZhciBsYW5lID0gcGlja0FyYml0cmFyeUxhbmUoSWRsZUxhbmVzICYgfndpcExhbmVzKTtcblxuICAgICAgaWYgKGxhbmUgPT09IE5vTGFuZSkge1xuICAgICAgICBsYW5lID0gcGlja0FyYml0cmFyeUxhbmUoSWRsZUxhbmVzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGxhbmU7XG4gIH1cblxuICB7XG4gICAge1xuICAgICAgdGhyb3cgRXJyb3IoIFwiSW52YWxpZCB1cGRhdGUgcHJpb3JpdHk6IFwiICsgbGFuZVByaW9yaXR5ICsgXCIuIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuXCIgKTtcbiAgICB9XG4gIH1cbn0gLy8gVG8gZW5zdXJlIGNvbnNpc3RlbmN5IGFjcm9zcyBtdWx0aXBsZSB1cGRhdGVzIGluIHRoZSBzYW1lIGV2ZW50LCB0aGlzIHNob3VsZFxuLy8gYmUgcHVyZSBmdW5jdGlvbiwgc28gdGhhdCBpdCBhbHdheXMgcmV0dXJucyB0aGUgc2FtZSBsYW5lIGZvciBnaXZlbiBpbnB1dHMuXG5cbmZ1bmN0aW9uIGZpbmRUcmFuc2l0aW9uTGFuZSh3aXBMYW5lcywgcGVuZGluZ0xhbmVzKSB7XG4gIC8vIEZpcnN0IGxvb2sgZm9yIGxhbmVzIHRoYXQgYXJlIGNvbXBsZXRlbHkgdW5jbGFpbWVkLCBpLmUuIGhhdmUgbm9cbiAgLy8gcGVuZGluZyB3b3JrLlxuICB2YXIgbGFuZSA9IHBpY2tBcmJpdHJhcnlMYW5lKFRyYW5zaXRpb25MYW5lcyAmIH5wZW5kaW5nTGFuZXMpO1xuXG4gIGlmIChsYW5lID09PSBOb0xhbmUpIHtcbiAgICAvLyBJZiBhbGwgbGFuZXMgaGF2ZSBwZW5kaW5nIHdvcmssIGxvb2sgZm9yIGEgbGFuZSB0aGF0IGlzbid0IGN1cnJlbnRseVxuICAgIC8vIGJlaW5nIHdvcmtlZCBvbi5cbiAgICBsYW5lID0gcGlja0FyYml0cmFyeUxhbmUoVHJhbnNpdGlvbkxhbmVzICYgfndpcExhbmVzKTtcblxuICAgIGlmIChsYW5lID09PSBOb0xhbmUpIHtcbiAgICAgIC8vIElmIGV2ZXJ5dGhpbmcgaXMgYmVpbmcgd29ya2VkIG9uLCBwaWNrIGFueSBsYW5lLiBUaGlzIGhhcyB0aGVcbiAgICAgIC8vIGVmZmVjdCBvZiBpbnRlcnJ1cHRpbmcgdGhlIGN1cnJlbnQgd29yay1pbi1wcm9ncmVzcy5cbiAgICAgIGxhbmUgPSBwaWNrQXJiaXRyYXJ5TGFuZShUcmFuc2l0aW9uTGFuZXMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBsYW5lO1xufSAvLyBUbyBlbnN1cmUgY29uc2lzdGVuY3kgYWNyb3NzIG11bHRpcGxlIHVwZGF0ZXMgaW4gdGhlIHNhbWUgZXZlbnQsIHRoaXMgc2hvdWxkXG4vLyBiZSBwdXJlIGZ1bmN0aW9uLCBzbyB0aGF0IGl0IGFsd2F5cyByZXR1cm5zIHRoZSBzYW1lIGxhbmUgZm9yIGdpdmVuIGlucHV0cy5cblxuZnVuY3Rpb24gZmluZFJldHJ5TGFuZSh3aXBMYW5lcykge1xuICAvLyBUaGlzIGlzIGEgZm9yayBvZiBgZmluZFVwZGF0ZUxhbmVgIGRlc2lnbmVkIHNwZWNpZmljYWxseSBmb3IgU3VzcGVuc2VcbiAgLy8gXCJyZXRyaWVzXCIg4oCUIGEgc3BlY2lhbCB1cGRhdGUgdGhhdCBhdHRlbXB0cyB0byBmbGlwIGEgU3VzcGVuc2UgYm91bmRhcnlcbiAgLy8gZnJvbSBpdHMgcGxhY2Vob2xkZXIgc3RhdGUgdG8gaXRzIHByaW1hcnkvcmVzb2x2ZWQgc3RhdGUuXG4gIHZhciBsYW5lID0gcGlja0FyYml0cmFyeUxhbmUoUmV0cnlMYW5lcyAmIH53aXBMYW5lcyk7XG5cbiAgaWYgKGxhbmUgPT09IE5vTGFuZSkge1xuICAgIGxhbmUgPSBwaWNrQXJiaXRyYXJ5TGFuZShSZXRyeUxhbmVzKTtcbiAgfVxuXG4gIHJldHVybiBsYW5lO1xufVxuXG5mdW5jdGlvbiBnZXRIaWdoZXN0UHJpb3JpdHlMYW5lKGxhbmVzKSB7XG4gIHJldHVybiBsYW5lcyAmIC1sYW5lcztcbn1cblxuZnVuY3Rpb24gZ2V0TG93ZXN0UHJpb3JpdHlMYW5lKGxhbmVzKSB7XG4gIC8vIFRoaXMgZmluZHMgdGhlIG1vc3Qgc2lnbmlmaWNhbnQgbm9uLXplcm8gYml0LlxuICB2YXIgaW5kZXggPSAzMSAtIGNsejMyKGxhbmVzKTtcbiAgcmV0dXJuIGluZGV4IDwgMCA/IE5vTGFuZXMgOiAxIDw8IGluZGV4O1xufVxuXG5mdW5jdGlvbiBnZXRFcXVhbE9ySGlnaGVyUHJpb3JpdHlMYW5lcyhsYW5lcykge1xuICByZXR1cm4gKGdldExvd2VzdFByaW9yaXR5TGFuZShsYW5lcykgPDwgMSkgLSAxO1xufVxuXG5mdW5jdGlvbiBwaWNrQXJiaXRyYXJ5TGFuZShsYW5lcykge1xuICAvLyBUaGlzIHdyYXBwZXIgZnVuY3Rpb24gZ2V0cyBpbmxpbmVkLiBPbmx5IGV4aXN0cyBzbyB0byBjb21tdW5pY2F0ZSB0aGF0IGl0XG4gIC8vIGRvZXNuJ3QgbWF0dGVyIHdoaWNoIGJpdCBpcyBzZWxlY3RlZDsgeW91IGNhbiBwaWNrIGFueSBiaXQgd2l0aG91dFxuICAvLyBhZmZlY3RpbmcgdGhlIGFsZ29yaXRobXMgd2hlcmUgaXRzIHVzZWQuIEhlcmUgSSdtIHVzaW5nXG4gIC8vIGdldEhpZ2hlc3RQcmlvcml0eUxhbmUgYmVjYXVzZSBpdCByZXF1aXJlcyB0aGUgZmV3ZXN0IG9wZXJhdGlvbnMuXG4gIHJldHVybiBnZXRIaWdoZXN0UHJpb3JpdHlMYW5lKGxhbmVzKTtcbn1cblxuZnVuY3Rpb24gcGlja0FyYml0cmFyeUxhbmVJbmRleChsYW5lcykge1xuICByZXR1cm4gMzEgLSBjbHozMihsYW5lcyk7XG59XG5cbmZ1bmN0aW9uIGxhbmVUb0luZGV4KGxhbmUpIHtcbiAgcmV0dXJuIHBpY2tBcmJpdHJhcnlMYW5lSW5kZXgobGFuZSk7XG59XG5cbmZ1bmN0aW9uIGluY2x1ZGVzU29tZUxhbmUoYSwgYikge1xuICByZXR1cm4gKGEgJiBiKSAhPT0gTm9MYW5lcztcbn1cbmZ1bmN0aW9uIGlzU3Vic2V0T2ZMYW5lcyhzZXQsIHN1YnNldCkge1xuICByZXR1cm4gKHNldCAmIHN1YnNldCkgPT09IHN1YnNldDtcbn1cbmZ1bmN0aW9uIG1lcmdlTGFuZXMoYSwgYikge1xuICByZXR1cm4gYSB8IGI7XG59XG5mdW5jdGlvbiByZW1vdmVMYW5lcyhzZXQsIHN1YnNldCkge1xuICByZXR1cm4gc2V0ICYgfnN1YnNldDtcbn0gLy8gU2VlbXMgcmVkdW5kYW50LCBidXQgaXQgY2hhbmdlcyB0aGUgdHlwZSBmcm9tIGEgc2luZ2xlIGxhbmUgKHVzZWQgZm9yXG4vLyB1cGRhdGVzKSB0byBhIGdyb3VwIG9mIGxhbmVzICh1c2VkIGZvciBmbHVzaGluZyB3b3JrKS5cblxuZnVuY3Rpb24gbGFuZVRvTGFuZXMobGFuZSkge1xuICByZXR1cm4gbGFuZTtcbn1cbmZ1bmN0aW9uIGhpZ2hlclByaW9yaXR5TGFuZShhLCBiKSB7XG4gIC8vIFRoaXMgd29ya3MgYmVjYXVzZSB0aGUgYml0IHJhbmdlcyBkZWNyZWFzZSBpbiBwcmlvcml0eSBhcyB5b3UgZ28gbGVmdC5cbiAgcmV0dXJuIGEgIT09IE5vTGFuZSAmJiBhIDwgYiA/IGEgOiBiO1xufVxuZnVuY3Rpb24gY3JlYXRlTGFuZU1hcChpbml0aWFsKSB7XG4gIC8vIEludGVudGlvbmFsbHkgcHVzaGluZyBvbmUgYnkgb25lLlxuICAvLyBodHRwczovL3Y4LmRldi9ibG9nL2VsZW1lbnRzLWtpbmRzI2F2b2lkLWNyZWF0aW5nLWhvbGVzXG4gIHZhciBsYW5lTWFwID0gW107XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBUb3RhbExhbmVzOyBpKyspIHtcbiAgICBsYW5lTWFwLnB1c2goaW5pdGlhbCk7XG4gIH1cblxuICByZXR1cm4gbGFuZU1hcDtcbn1cbmZ1bmN0aW9uIG1hcmtSb290VXBkYXRlZChyb290LCB1cGRhdGVMYW5lLCBldmVudFRpbWUpIHtcbiAgcm9vdC5wZW5kaW5nTGFuZXMgfD0gdXBkYXRlTGFuZTsgLy8gVE9ETzogVGhlb3JldGljYWxseSwgYW55IHVwZGF0ZSB0byBhbnkgbGFuZSBjYW4gdW5ibG9jayBhbnkgb3RoZXIgbGFuZS4gQnV0XG4gIC8vIGl0J3Mgbm90IHByYWN0aWNhbCB0byB0cnkgZXZlcnkgc2luZ2xlIHBvc3NpYmxlIGNvbWJpbmF0aW9uLiBXZSBuZWVkIGFcbiAgLy8gaGV1cmlzdGljIHRvIGRlY2lkZSB3aGljaCBsYW5lcyB0byBhdHRlbXB0IHRvIHJlbmRlciwgYW5kIGluIHdoaWNoIGJhdGNoZXMuXG4gIC8vIEZvciBub3csIHdlIHVzZSB0aGUgc2FtZSBoZXVyaXN0aWMgYXMgaW4gdGhlIG9sZCBFeHBpcmF0aW9uVGltZXMgbW9kZWw6XG4gIC8vIHJldHJ5IGFueSBsYW5lIGF0IGVxdWFsIG9yIGxvd2VyIHByaW9yaXR5LCBidXQgZG9uJ3QgdHJ5IHVwZGF0ZXMgYXQgaGlnaGVyXG4gIC8vIHByaW9yaXR5IHdpdGhvdXQgYWxzbyBpbmNsdWRpbmcgdGhlIGxvd2VyIHByaW9yaXR5IHVwZGF0ZXMuIFRoaXMgd29ya3Mgd2VsbFxuICAvLyB3aGVuIGNvbnNpZGVyaW5nIHVwZGF0ZXMgYWNyb3NzIGRpZmZlcmVudCBwcmlvcml0eSBsZXZlbHMsIGJ1dCBpc24ndFxuICAvLyBzdWZmaWNpZW50IGZvciB1cGRhdGVzIHdpdGhpbiB0aGUgc2FtZSBwcmlvcml0eSwgc2luY2Ugd2Ugd2FudCB0byB0cmVhdFxuICAvLyB0aG9zZSB1cGRhdGVzIGFzIHBhcmFsbGVsLlxuICAvLyBVbnN1c3BlbmQgYW55IHVwZGF0ZSBhdCBlcXVhbCBvciBsb3dlciBwcmlvcml0eS5cblxuICB2YXIgaGlnaGVyUHJpb3JpdHlMYW5lcyA9IHVwZGF0ZUxhbmUgLSAxOyAvLyBUdXJucyAwYjEwMDAgaW50byAwYjAxMTFcblxuICByb290LnN1c3BlbmRlZExhbmVzICY9IGhpZ2hlclByaW9yaXR5TGFuZXM7XG4gIHJvb3QucGluZ2VkTGFuZXMgJj0gaGlnaGVyUHJpb3JpdHlMYW5lcztcbiAgdmFyIGV2ZW50VGltZXMgPSByb290LmV2ZW50VGltZXM7XG4gIHZhciBpbmRleCA9IGxhbmVUb0luZGV4KHVwZGF0ZUxhbmUpOyAvLyBXZSBjYW4gYWx3YXlzIG92ZXJ3cml0ZSBhbiBleGlzdGluZyB0aW1lc3RhbXAgYmVjYXVzZSB3ZSBwcmVmZXIgdGhlIG1vc3RcbiAgLy8gcmVjZW50IGV2ZW50LCBhbmQgd2UgYXNzdW1lIHRpbWUgaXMgbW9ub3RvbmljYWxseSBpbmNyZWFzaW5nLlxuXG4gIGV2ZW50VGltZXNbaW5kZXhdID0gZXZlbnRUaW1lO1xufVxuZnVuY3Rpb24gbWFya1Jvb3RTdXNwZW5kZWQocm9vdCwgc3VzcGVuZGVkTGFuZXMpIHtcbiAgcm9vdC5zdXNwZW5kZWRMYW5lcyB8PSBzdXNwZW5kZWRMYW5lcztcbiAgcm9vdC5waW5nZWRMYW5lcyAmPSB+c3VzcGVuZGVkTGFuZXM7IC8vIFRoZSBzdXNwZW5kZWQgbGFuZXMgYXJlIG5vIGxvbmdlciBDUFUtYm91bmQuIENsZWFyIHRoZWlyIGV4cGlyYXRpb24gdGltZXMuXG5cbiAgdmFyIGV4cGlyYXRpb25UaW1lcyA9IHJvb3QuZXhwaXJhdGlvblRpbWVzO1xuICB2YXIgbGFuZXMgPSBzdXNwZW5kZWRMYW5lcztcblxuICB3aGlsZSAobGFuZXMgPiAwKSB7XG4gICAgdmFyIGluZGV4ID0gcGlja0FyYml0cmFyeUxhbmVJbmRleChsYW5lcyk7XG4gICAgdmFyIGxhbmUgPSAxIDw8IGluZGV4O1xuICAgIGV4cGlyYXRpb25UaW1lc1tpbmRleF0gPSBOb1RpbWVzdGFtcDtcbiAgICBsYW5lcyAmPSB+bGFuZTtcbiAgfVxufVxuZnVuY3Rpb24gbWFya1Jvb3RQaW5nZWQocm9vdCwgcGluZ2VkTGFuZXMsIGV2ZW50VGltZSkge1xuICByb290LnBpbmdlZExhbmVzIHw9IHJvb3Quc3VzcGVuZGVkTGFuZXMgJiBwaW5nZWRMYW5lcztcbn1cbmZ1bmN0aW9uIG1hcmtEaXNjcmV0ZVVwZGF0ZXNFeHBpcmVkKHJvb3QpIHtcbiAgcm9vdC5leHBpcmVkTGFuZXMgfD0gSW5wdXREaXNjcmV0ZUxhbmVzICYgcm9vdC5wZW5kaW5nTGFuZXM7XG59XG5mdW5jdGlvbiBoYXNEaXNjcmV0ZUxhbmVzKGxhbmVzKSB7XG4gIHJldHVybiAobGFuZXMgJiBJbnB1dERpc2NyZXRlTGFuZXMpICE9PSBOb0xhbmVzO1xufVxuZnVuY3Rpb24gbWFya1Jvb3RNdXRhYmxlUmVhZChyb290LCB1cGRhdGVMYW5lKSB7XG4gIHJvb3QubXV0YWJsZVJlYWRMYW5lcyB8PSB1cGRhdGVMYW5lICYgcm9vdC5wZW5kaW5nTGFuZXM7XG59XG5mdW5jdGlvbiBtYXJrUm9vdEZpbmlzaGVkKHJvb3QsIHJlbWFpbmluZ0xhbmVzKSB7XG4gIHZhciBub0xvbmdlclBlbmRpbmdMYW5lcyA9IHJvb3QucGVuZGluZ0xhbmVzICYgfnJlbWFpbmluZ0xhbmVzO1xuICByb290LnBlbmRpbmdMYW5lcyA9IHJlbWFpbmluZ0xhbmVzOyAvLyBMZXQncyB0cnkgZXZlcnl0aGluZyBhZ2FpblxuXG4gIHJvb3Quc3VzcGVuZGVkTGFuZXMgPSAwO1xuICByb290LnBpbmdlZExhbmVzID0gMDtcbiAgcm9vdC5leHBpcmVkTGFuZXMgJj0gcmVtYWluaW5nTGFuZXM7XG4gIHJvb3QubXV0YWJsZVJlYWRMYW5lcyAmPSByZW1haW5pbmdMYW5lcztcbiAgcm9vdC5lbnRhbmdsZWRMYW5lcyAmPSByZW1haW5pbmdMYW5lcztcbiAgdmFyIGVudGFuZ2xlbWVudHMgPSByb290LmVudGFuZ2xlbWVudHM7XG4gIHZhciBldmVudFRpbWVzID0gcm9vdC5ldmVudFRpbWVzO1xuICB2YXIgZXhwaXJhdGlvblRpbWVzID0gcm9vdC5leHBpcmF0aW9uVGltZXM7IC8vIENsZWFyIHRoZSBsYW5lcyB0aGF0IG5vIGxvbmdlciBoYXZlIHBlbmRpbmcgd29ya1xuXG4gIHZhciBsYW5lcyA9IG5vTG9uZ2VyUGVuZGluZ0xhbmVzO1xuXG4gIHdoaWxlIChsYW5lcyA+IDApIHtcbiAgICB2YXIgaW5kZXggPSBwaWNrQXJiaXRyYXJ5TGFuZUluZGV4KGxhbmVzKTtcbiAgICB2YXIgbGFuZSA9IDEgPDwgaW5kZXg7XG4gICAgZW50YW5nbGVtZW50c1tpbmRleF0gPSBOb0xhbmVzO1xuICAgIGV2ZW50VGltZXNbaW5kZXhdID0gTm9UaW1lc3RhbXA7XG4gICAgZXhwaXJhdGlvblRpbWVzW2luZGV4XSA9IE5vVGltZXN0YW1wO1xuICAgIGxhbmVzICY9IH5sYW5lO1xuICB9XG59XG5mdW5jdGlvbiBtYXJrUm9vdEVudGFuZ2xlZChyb290LCBlbnRhbmdsZWRMYW5lcykge1xuICByb290LmVudGFuZ2xlZExhbmVzIHw9IGVudGFuZ2xlZExhbmVzO1xuICB2YXIgZW50YW5nbGVtZW50cyA9IHJvb3QuZW50YW5nbGVtZW50cztcbiAgdmFyIGxhbmVzID0gZW50YW5nbGVkTGFuZXM7XG5cbiAgd2hpbGUgKGxhbmVzID4gMCkge1xuICAgIHZhciBpbmRleCA9IHBpY2tBcmJpdHJhcnlMYW5lSW5kZXgobGFuZXMpO1xuICAgIHZhciBsYW5lID0gMSA8PCBpbmRleDtcbiAgICBlbnRhbmdsZW1lbnRzW2luZGV4XSB8PSBlbnRhbmdsZWRMYW5lcztcbiAgICBsYW5lcyAmPSB+bGFuZTtcbiAgfVxufVxudmFyIGNsejMyID0gTWF0aC5jbHozMiA/IE1hdGguY2x6MzIgOiBjbHozMkZhbGxiYWNrOyAvLyBDb3VudCBsZWFkaW5nIHplcm9zLiBPbmx5IHVzZWQgb24gbGFuZXMsIHNvIGFzc3VtZSBpbnB1dCBpcyBhbiBpbnRlZ2VyLlxuLy8gQmFzZWQgb246XG4vLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9NYXRoL2NsejMyXG5cbnZhciBsb2cgPSBNYXRoLmxvZztcbnZhciBMTjIgPSBNYXRoLkxOMjtcblxuZnVuY3Rpb24gY2x6MzJGYWxsYmFjayhsYW5lcykge1xuICBpZiAobGFuZXMgPT09IDApIHtcbiAgICByZXR1cm4gMzI7XG4gIH1cblxuICByZXR1cm4gMzEgLSAobG9nKGxhbmVzKSAvIExOMiB8IDApIHwgMDtcbn1cblxuLy8gSW50ZW50aW9uYWxseSBub3QgbmFtZWQgaW1wb3J0cyBiZWNhdXNlIFJvbGx1cCB3b3VsZCB1c2UgZHluYW1pYyBkaXNwYXRjaCBmb3JcbnZhciBVc2VyQmxvY2tpbmdQcmlvcml0eSQxID0gU2NoZWR1bGVyLnVuc3RhYmxlX1VzZXJCbG9ja2luZ1ByaW9yaXR5LFxuICAgIHJ1bldpdGhQcmlvcml0eSA9IFNjaGVkdWxlci51bnN0YWJsZV9ydW5XaXRoUHJpb3JpdHk7IC8vIFRPRE86IGNhbiB3ZSBzdG9wIGV4cG9ydGluZyB0aGVzZT9cblxudmFyIF9lbmFibGVkID0gdHJ1ZTsgLy8gVGhpcyBpcyBleHBvcnRlZCBpbiBGQiBidWlsZHMgZm9yIHVzZSBieSBsZWdhY3kgRkIgbGF5ZXIgaW5mcmEuXG4vLyBXZSdkIGxpa2UgdG8gcmVtb3ZlIHRoaXMgYnV0IGl0J3Mgbm90IGNsZWFyIGlmIHRoaXMgaXMgc2FmZS5cblxuZnVuY3Rpb24gc2V0RW5hYmxlZChlbmFibGVkKSB7XG4gIF9lbmFibGVkID0gISFlbmFibGVkO1xufVxuZnVuY3Rpb24gaXNFbmFibGVkKCkge1xuICByZXR1cm4gX2VuYWJsZWQ7XG59XG5mdW5jdGlvbiBjcmVhdGVFdmVudExpc3RlbmVyV3JhcHBlcldpdGhQcmlvcml0eSh0YXJnZXRDb250YWluZXIsIGRvbUV2ZW50TmFtZSwgZXZlbnRTeXN0ZW1GbGFncykge1xuICB2YXIgZXZlbnRQcmlvcml0eSA9IGdldEV2ZW50UHJpb3JpdHlGb3JQbHVnaW5TeXN0ZW0oZG9tRXZlbnROYW1lKTtcbiAgdmFyIGxpc3RlbmVyV3JhcHBlcjtcblxuICBzd2l0Y2ggKGV2ZW50UHJpb3JpdHkpIHtcbiAgICBjYXNlIERpc2NyZXRlRXZlbnQ6XG4gICAgICBsaXN0ZW5lcldyYXBwZXIgPSBkaXNwYXRjaERpc2NyZXRlRXZlbnQ7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgVXNlckJsb2NraW5nRXZlbnQ6XG4gICAgICBsaXN0ZW5lcldyYXBwZXIgPSBkaXNwYXRjaFVzZXJCbG9ja2luZ1VwZGF0ZTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBDb250aW51b3VzRXZlbnQ6XG4gICAgZGVmYXVsdDpcbiAgICAgIGxpc3RlbmVyV3JhcHBlciA9IGRpc3BhdGNoRXZlbnQ7XG4gICAgICBicmVhaztcbiAgfVxuXG4gIHJldHVybiBsaXN0ZW5lcldyYXBwZXIuYmluZChudWxsLCBkb21FdmVudE5hbWUsIGV2ZW50U3lzdGVtRmxhZ3MsIHRhcmdldENvbnRhaW5lcik7XG59XG5cbmZ1bmN0aW9uIGRpc3BhdGNoRGlzY3JldGVFdmVudChkb21FdmVudE5hbWUsIGV2ZW50U3lzdGVtRmxhZ3MsIGNvbnRhaW5lciwgbmF0aXZlRXZlbnQpIHtcbiAge1xuICAgIGZsdXNoRGlzY3JldGVVcGRhdGVzSWZOZWVkZWQobmF0aXZlRXZlbnQudGltZVN0YW1wKTtcbiAgfVxuXG4gIGRpc2NyZXRlVXBkYXRlcyhkaXNwYXRjaEV2ZW50LCBkb21FdmVudE5hbWUsIGV2ZW50U3lzdGVtRmxhZ3MsIGNvbnRhaW5lciwgbmF0aXZlRXZlbnQpO1xufVxuXG5mdW5jdGlvbiBkaXNwYXRjaFVzZXJCbG9ja2luZ1VwZGF0ZShkb21FdmVudE5hbWUsIGV2ZW50U3lzdGVtRmxhZ3MsIGNvbnRhaW5lciwgbmF0aXZlRXZlbnQpIHtcbiAge1xuICAgIHJ1bldpdGhQcmlvcml0eShVc2VyQmxvY2tpbmdQcmlvcml0eSQxLCBkaXNwYXRjaEV2ZW50LmJpbmQobnVsbCwgZG9tRXZlbnROYW1lLCBldmVudFN5c3RlbUZsYWdzLCBjb250YWluZXIsIG5hdGl2ZUV2ZW50KSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZGlzcGF0Y2hFdmVudChkb21FdmVudE5hbWUsIGV2ZW50U3lzdGVtRmxhZ3MsIHRhcmdldENvbnRhaW5lciwgbmF0aXZlRXZlbnQpIHtcbiAgaWYgKCFfZW5hYmxlZCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBhbGxvd1JlcGxheSA9IHRydWU7XG5cbiAge1xuICAgIC8vIFRPRE86IHJlcGxheWluZyBjYXB0dXJlIHBoYXNlIGV2ZW50cyBpcyBjdXJyZW50bHkgYnJva2VuXG4gICAgLy8gYmVjYXVzZSB3ZSB1c2VkIHRvIGRvIGl0IGR1cmluZyB0b3AtbGV2ZWwgbmF0aXZlIGJ1YmJsZSBoYW5kbGVyc1xuICAgIC8vIGJ1dCBub3cgd2UgdXNlIGRpZmZlcmVudCBidWJibGUgYW5kIGNhcHR1cmUgaGFuZGxlcnMuXG4gICAgLy8gSW4gZWFnZXIgbW9kZSwgd2UgYXR0YWNoIGNhcHR1cmUgbGlzdGVuZXJzIGVhcmx5LCBzbyB3ZSBuZWVkXG4gICAgLy8gdG8gZmlsdGVyIHRoZW0gb3V0IHVudGlsIHdlIGZpeCB0aGUgbG9naWMgdG8gaGFuZGxlIHRoZW0gY29ycmVjdGx5LlxuICAgIC8vIFRoaXMgY291bGQndmUgYmVlbiBvdXRzaWRlIHRoZSBmbGFnIGJ1dCBJIHB1dCBpdCBpbnNpZGUgdG8gcmVkdWNlIHJpc2suXG4gICAgYWxsb3dSZXBsYXkgPSAoZXZlbnRTeXN0ZW1GbGFncyAmIElTX0NBUFRVUkVfUEhBU0UpID09PSAwO1xuICB9XG5cbiAgaWYgKGFsbG93UmVwbGF5ICYmIGhhc1F1ZXVlZERpc2NyZXRlRXZlbnRzKCkgJiYgaXNSZXBsYXlhYmxlRGlzY3JldGVFdmVudChkb21FdmVudE5hbWUpKSB7XG4gICAgLy8gSWYgd2UgYWxyZWFkeSBoYXZlIGEgcXVldWUgb2YgZGlzY3JldGUgZXZlbnRzLCBhbmQgdGhpcyBpcyBhbm90aGVyIGRpc2NyZXRlXG4gICAgLy8gZXZlbnQsIHRoZW4gd2UgY2FuJ3QgZGlzcGF0Y2ggaXQgcmVnYXJkbGVzcyBvZiBpdHMgdGFyZ2V0LCBzaW5jZSB0aGV5XG4gICAgLy8gbmVlZCB0byBkaXNwYXRjaCBpbiBvcmRlci5cbiAgICBxdWV1ZURpc2NyZXRlRXZlbnQobnVsbCwgLy8gRmxhZ3MgdGhhdCB3ZSdyZSBub3QgYWN0dWFsbHkgYmxvY2tlZCBvbiBhbnl0aGluZyBhcyBmYXIgYXMgd2Uga25vdy5cbiAgICBkb21FdmVudE5hbWUsIGV2ZW50U3lzdGVtRmxhZ3MsIHRhcmdldENvbnRhaW5lciwgbmF0aXZlRXZlbnQpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBibG9ja2VkT24gPSBhdHRlbXB0VG9EaXNwYXRjaEV2ZW50KGRvbUV2ZW50TmFtZSwgZXZlbnRTeXN0ZW1GbGFncywgdGFyZ2V0Q29udGFpbmVyLCBuYXRpdmVFdmVudCk7XG5cbiAgaWYgKGJsb2NrZWRPbiA9PT0gbnVsbCkge1xuICAgIC8vIFdlIHN1Y2Nlc3NmdWxseSBkaXNwYXRjaGVkIHRoaXMgZXZlbnQuXG4gICAgaWYgKGFsbG93UmVwbGF5KSB7XG4gICAgICBjbGVhcklmQ29udGludW91c0V2ZW50KGRvbUV2ZW50TmFtZSwgbmF0aXZlRXZlbnQpO1xuICAgIH1cblxuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChhbGxvd1JlcGxheSkge1xuICAgIGlmIChpc1JlcGxheWFibGVEaXNjcmV0ZUV2ZW50KGRvbUV2ZW50TmFtZSkpIHtcbiAgICAgIC8vIFRoaXMgdGhpcyB0byBiZSByZXBsYXllZCBsYXRlciBvbmNlIHRoZSB0YXJnZXQgaXMgYXZhaWxhYmxlLlxuICAgICAgcXVldWVEaXNjcmV0ZUV2ZW50KGJsb2NrZWRPbiwgZG9tRXZlbnROYW1lLCBldmVudFN5c3RlbUZsYWdzLCB0YXJnZXRDb250YWluZXIsIG5hdGl2ZUV2ZW50KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAocXVldWVJZkNvbnRpbnVvdXNFdmVudChibG9ja2VkT24sIGRvbUV2ZW50TmFtZSwgZXZlbnRTeXN0ZW1GbGFncywgdGFyZ2V0Q29udGFpbmVyLCBuYXRpdmVFdmVudCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIFdlIG5lZWQgdG8gY2xlYXIgb25seSBpZiB3ZSBkaWRuJ3QgcXVldWUgYmVjYXVzZVxuICAgIC8vIHF1ZXVlaW5nIGlzIGFjY3VtbXVsYXRpdmUuXG5cblxuICAgIGNsZWFySWZDb250aW51b3VzRXZlbnQoZG9tRXZlbnROYW1lLCBuYXRpdmVFdmVudCk7XG4gIH0gLy8gVGhpcyBpcyBub3QgcmVwbGF5YWJsZSBzbyB3ZSdsbCBpbnZva2UgaXQgYnV0IHdpdGhvdXQgYSB0YXJnZXQsXG4gIC8vIGluIGNhc2UgdGhlIGV2ZW50IHN5c3RlbSBuZWVkcyB0byB0cmFjZSBpdC5cblxuXG4gIGRpc3BhdGNoRXZlbnRGb3JQbHVnaW5FdmVudFN5c3RlbShkb21FdmVudE5hbWUsIGV2ZW50U3lzdGVtRmxhZ3MsIG5hdGl2ZUV2ZW50LCBudWxsLCB0YXJnZXRDb250YWluZXIpO1xufSAvLyBBdHRlbXB0IGRpc3BhdGNoaW5nIGFuIGV2ZW50LiBSZXR1cm5zIGEgU3VzcGVuc2VJbnN0YW5jZSBvciBDb250YWluZXIgaWYgaXQncyBibG9ja2VkLlxuXG5mdW5jdGlvbiBhdHRlbXB0VG9EaXNwYXRjaEV2ZW50KGRvbUV2ZW50TmFtZSwgZXZlbnRTeXN0ZW1GbGFncywgdGFyZ2V0Q29udGFpbmVyLCBuYXRpdmVFdmVudCkge1xuICAvLyBUT0RPOiBXYXJuIGlmIF9lbmFibGVkIGlzIGZhbHNlLlxuICB2YXIgbmF0aXZlRXZlbnRUYXJnZXQgPSBnZXRFdmVudFRhcmdldChuYXRpdmVFdmVudCk7XG4gIHZhciB0YXJnZXRJbnN0ID0gZ2V0Q2xvc2VzdEluc3RhbmNlRnJvbU5vZGUobmF0aXZlRXZlbnRUYXJnZXQpO1xuXG4gIGlmICh0YXJnZXRJbnN0ICE9PSBudWxsKSB7XG4gICAgdmFyIG5lYXJlc3RNb3VudGVkID0gZ2V0TmVhcmVzdE1vdW50ZWRGaWJlcih0YXJnZXRJbnN0KTtcblxuICAgIGlmIChuZWFyZXN0TW91bnRlZCA9PT0gbnVsbCkge1xuICAgICAgLy8gVGhpcyB0cmVlIGhhcyBiZWVuIHVubW91bnRlZCBhbHJlYWR5LiBEaXNwYXRjaCB3aXRob3V0IGEgdGFyZ2V0LlxuICAgICAgdGFyZ2V0SW5zdCA9IG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciB0YWcgPSBuZWFyZXN0TW91bnRlZC50YWc7XG5cbiAgICAgIGlmICh0YWcgPT09IFN1c3BlbnNlQ29tcG9uZW50KSB7XG4gICAgICAgIHZhciBpbnN0YW5jZSA9IGdldFN1c3BlbnNlSW5zdGFuY2VGcm9tRmliZXIobmVhcmVzdE1vdW50ZWQpO1xuXG4gICAgICAgIGlmIChpbnN0YW5jZSAhPT0gbnVsbCkge1xuICAgICAgICAgIC8vIFF1ZXVlIHRoZSBldmVudCB0byBiZSByZXBsYXllZCBsYXRlci4gQWJvcnQgZGlzcGF0Y2hpbmcgc2luY2Ugd2VcbiAgICAgICAgICAvLyBkb24ndCB3YW50IHRoaXMgZXZlbnQgZGlzcGF0Y2hlZCB0d2ljZSB0aHJvdWdoIHRoZSBldmVudCBzeXN0ZW0uXG4gICAgICAgICAgLy8gVE9ETzogSWYgdGhpcyBpcyB0aGUgZmlyc3QgZGlzY3JldGUgZXZlbnQgaW4gdGhlIHF1ZXVlLiBTY2hlZHVsZSBhbiBpbmNyZWFzZWRcbiAgICAgICAgICAvLyBwcmlvcml0eSBmb3IgdGhpcyBib3VuZGFyeS5cbiAgICAgICAgICByZXR1cm4gaW5zdGFuY2U7XG4gICAgICAgIH0gLy8gVGhpcyBzaG91bGRuJ3QgaGFwcGVuLCBzb21ldGhpbmcgd2VudCB3cm9uZyBidXQgdG8gYXZvaWQgYmxvY2tpbmdcbiAgICAgICAgLy8gdGhlIHdob2xlIHN5c3RlbSwgZGlzcGF0Y2ggdGhlIGV2ZW50IHdpdGhvdXQgYSB0YXJnZXQuXG4gICAgICAgIC8vIFRPRE86IFdhcm4uXG5cblxuICAgICAgICB0YXJnZXRJbnN0ID0gbnVsbDtcbiAgICAgIH0gZWxzZSBpZiAodGFnID09PSBIb3N0Um9vdCkge1xuICAgICAgICB2YXIgcm9vdCA9IG5lYXJlc3RNb3VudGVkLnN0YXRlTm9kZTtcblxuICAgICAgICBpZiAocm9vdC5oeWRyYXRlKSB7XG4gICAgICAgICAgLy8gSWYgdGhpcyBoYXBwZW5zIGR1cmluZyBhIHJlcGxheSBzb21ldGhpbmcgd2VudCB3cm9uZyBhbmQgaXQgbWlnaHQgYmxvY2tcbiAgICAgICAgICAvLyB0aGUgd2hvbGUgc3lzdGVtLlxuICAgICAgICAgIHJldHVybiBnZXRDb250YWluZXJGcm9tRmliZXIobmVhcmVzdE1vdW50ZWQpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGFyZ2V0SW5zdCA9IG51bGw7XG4gICAgICB9IGVsc2UgaWYgKG5lYXJlc3RNb3VudGVkICE9PSB0YXJnZXRJbnN0KSB7XG4gICAgICAgIC8vIElmIHdlIGdldCBhbiBldmVudCAoZXg6IGltZyBvbmxvYWQpIGJlZm9yZSBjb21taXR0aW5nIHRoYXRcbiAgICAgICAgLy8gY29tcG9uZW50J3MgbW91bnQsIGlnbm9yZSBpdCBmb3Igbm93ICh0aGF0IGlzLCB0cmVhdCBpdCBhcyBpZiBpdCB3YXMgYW5cbiAgICAgICAgLy8gZXZlbnQgb24gYSBub24tUmVhY3QgdHJlZSkuIFdlIG1pZ2h0IGFsc28gY29uc2lkZXIgcXVldWVpbmcgZXZlbnRzIGFuZFxuICAgICAgICAvLyBkaXNwYXRjaGluZyB0aGVtIGFmdGVyIHRoZSBtb3VudC5cbiAgICAgICAgdGFyZ2V0SW5zdCA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZGlzcGF0Y2hFdmVudEZvclBsdWdpbkV2ZW50U3lzdGVtKGRvbUV2ZW50TmFtZSwgZXZlbnRTeXN0ZW1GbGFncywgbmF0aXZlRXZlbnQsIHRhcmdldEluc3QsIHRhcmdldENvbnRhaW5lcik7IC8vIFdlJ3JlIG5vdCBibG9ja2VkIG9uIGFueXRoaW5nLlxuXG4gIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiBhZGRFdmVudEJ1YmJsZUxpc3RlbmVyKHRhcmdldCwgZXZlbnRUeXBlLCBsaXN0ZW5lcikge1xuICB0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcihldmVudFR5cGUsIGxpc3RlbmVyLCBmYWxzZSk7XG4gIHJldHVybiBsaXN0ZW5lcjtcbn1cbmZ1bmN0aW9uIGFkZEV2ZW50Q2FwdHVyZUxpc3RlbmVyKHRhcmdldCwgZXZlbnRUeXBlLCBsaXN0ZW5lcikge1xuICB0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcihldmVudFR5cGUsIGxpc3RlbmVyLCB0cnVlKTtcbiAgcmV0dXJuIGxpc3RlbmVyO1xufVxuZnVuY3Rpb24gYWRkRXZlbnRDYXB0dXJlTGlzdGVuZXJXaXRoUGFzc2l2ZUZsYWcodGFyZ2V0LCBldmVudFR5cGUsIGxpc3RlbmVyLCBwYXNzaXZlKSB7XG4gIHRhcmdldC5hZGRFdmVudExpc3RlbmVyKGV2ZW50VHlwZSwgbGlzdGVuZXIsIHtcbiAgICBjYXB0dXJlOiB0cnVlLFxuICAgIHBhc3NpdmU6IHBhc3NpdmVcbiAgfSk7XG4gIHJldHVybiBsaXN0ZW5lcjtcbn1cbmZ1bmN0aW9uIGFkZEV2ZW50QnViYmxlTGlzdGVuZXJXaXRoUGFzc2l2ZUZsYWcodGFyZ2V0LCBldmVudFR5cGUsIGxpc3RlbmVyLCBwYXNzaXZlKSB7XG4gIHRhcmdldC5hZGRFdmVudExpc3RlbmVyKGV2ZW50VHlwZSwgbGlzdGVuZXIsIHtcbiAgICBwYXNzaXZlOiBwYXNzaXZlXG4gIH0pO1xuICByZXR1cm4gbGlzdGVuZXI7XG59XG5cbi8qKlxuICogVGhlc2UgdmFyaWFibGVzIHN0b3JlIGluZm9ybWF0aW9uIGFib3V0IHRleHQgY29udGVudCBvZiBhIHRhcmdldCBub2RlLFxuICogYWxsb3dpbmcgY29tcGFyaXNvbiBvZiBjb250ZW50IGJlZm9yZSBhbmQgYWZ0ZXIgYSBnaXZlbiBldmVudC5cbiAqXG4gKiBJZGVudGlmeSB0aGUgbm9kZSB3aGVyZSBzZWxlY3Rpb24gY3VycmVudGx5IGJlZ2lucywgdGhlbiBvYnNlcnZlXG4gKiBib3RoIGl0cyB0ZXh0IGNvbnRlbnQgYW5kIGl0cyBjdXJyZW50IHBvc2l0aW9uIGluIHRoZSBET00uIFNpbmNlIHRoZVxuICogYnJvd3NlciBtYXkgbmF0aXZlbHkgcmVwbGFjZSB0aGUgdGFyZ2V0IG5vZGUgZHVyaW5nIGNvbXBvc2l0aW9uLCB3ZSBjYW5cbiAqIHVzZSBpdHMgcG9zaXRpb24gdG8gZmluZCBpdHMgcmVwbGFjZW1lbnQuXG4gKlxuICpcbiAqL1xudmFyIHJvb3QgPSBudWxsO1xudmFyIHN0YXJ0VGV4dCA9IG51bGw7XG52YXIgZmFsbGJhY2tUZXh0ID0gbnVsbDtcbmZ1bmN0aW9uIGluaXRpYWxpemUobmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgcm9vdCA9IG5hdGl2ZUV2ZW50VGFyZ2V0O1xuICBzdGFydFRleHQgPSBnZXRUZXh0KCk7XG4gIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gcmVzZXQoKSB7XG4gIHJvb3QgPSBudWxsO1xuICBzdGFydFRleHQgPSBudWxsO1xuICBmYWxsYmFja1RleHQgPSBudWxsO1xufVxuZnVuY3Rpb24gZ2V0RGF0YSgpIHtcbiAgaWYgKGZhbGxiYWNrVGV4dCkge1xuICAgIHJldHVybiBmYWxsYmFja1RleHQ7XG4gIH1cblxuICB2YXIgc3RhcnQ7XG4gIHZhciBzdGFydFZhbHVlID0gc3RhcnRUZXh0O1xuICB2YXIgc3RhcnRMZW5ndGggPSBzdGFydFZhbHVlLmxlbmd0aDtcbiAgdmFyIGVuZDtcbiAgdmFyIGVuZFZhbHVlID0gZ2V0VGV4dCgpO1xuICB2YXIgZW5kTGVuZ3RoID0gZW5kVmFsdWUubGVuZ3RoO1xuXG4gIGZvciAoc3RhcnQgPSAwOyBzdGFydCA8IHN0YXJ0TGVuZ3RoOyBzdGFydCsrKSB7XG4gICAgaWYgKHN0YXJ0VmFsdWVbc3RhcnRdICE9PSBlbmRWYWx1ZVtzdGFydF0pIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHZhciBtaW5FbmQgPSBzdGFydExlbmd0aCAtIHN0YXJ0O1xuXG4gIGZvciAoZW5kID0gMTsgZW5kIDw9IG1pbkVuZDsgZW5kKyspIHtcbiAgICBpZiAoc3RhcnRWYWx1ZVtzdGFydExlbmd0aCAtIGVuZF0gIT09IGVuZFZhbHVlW2VuZExlbmd0aCAtIGVuZF0pIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHZhciBzbGljZVRhaWwgPSBlbmQgPiAxID8gMSAtIGVuZCA6IHVuZGVmaW5lZDtcbiAgZmFsbGJhY2tUZXh0ID0gZW5kVmFsdWUuc2xpY2Uoc3RhcnQsIHNsaWNlVGFpbCk7XG4gIHJldHVybiBmYWxsYmFja1RleHQ7XG59XG5mdW5jdGlvbiBnZXRUZXh0KCkge1xuICBpZiAoJ3ZhbHVlJyBpbiByb290KSB7XG4gICAgcmV0dXJuIHJvb3QudmFsdWU7XG4gIH1cblxuICByZXR1cm4gcm9vdC50ZXh0Q29udGVudDtcbn1cblxuLyoqXG4gKiBgY2hhckNvZGVgIHJlcHJlc2VudHMgdGhlIGFjdHVhbCBcImNoYXJhY3RlciBjb2RlXCIgYW5kIGlzIHNhZmUgdG8gdXNlIHdpdGhcbiAqIGBTdHJpbmcuZnJvbUNoYXJDb2RlYC4gQXMgc3VjaCwgb25seSBrZXlzIHRoYXQgY29ycmVzcG9uZCB0byBwcmludGFibGVcbiAqIGNoYXJhY3RlcnMgcHJvZHVjZSBhIHZhbGlkIGBjaGFyQ29kZWAsIHRoZSBvbmx5IGV4Y2VwdGlvbiB0byB0aGlzIGlzIEVudGVyLlxuICogVGhlIFRhYi1rZXkgaXMgY29uc2lkZXJlZCBub24tcHJpbnRhYmxlIGFuZCBkb2VzIG5vdCBoYXZlIGEgYGNoYXJDb2RlYCxcbiAqIHByZXN1bWFibHkgYmVjYXVzZSBpdCBkb2VzIG5vdCBwcm9kdWNlIGEgdGFiLWNoYXJhY3RlciBpbiBicm93c2Vycy5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IE5vcm1hbGl6ZWQgYGNoYXJDb2RlYCBwcm9wZXJ0eS5cbiAqL1xuZnVuY3Rpb24gZ2V0RXZlbnRDaGFyQ29kZShuYXRpdmVFdmVudCkge1xuICB2YXIgY2hhckNvZGU7XG4gIHZhciBrZXlDb2RlID0gbmF0aXZlRXZlbnQua2V5Q29kZTtcblxuICBpZiAoJ2NoYXJDb2RlJyBpbiBuYXRpdmVFdmVudCkge1xuICAgIGNoYXJDb2RlID0gbmF0aXZlRXZlbnQuY2hhckNvZGU7IC8vIEZGIGRvZXMgbm90IHNldCBgY2hhckNvZGVgIGZvciB0aGUgRW50ZXIta2V5LCBjaGVjayBhZ2FpbnN0IGBrZXlDb2RlYC5cblxuICAgIGlmIChjaGFyQ29kZSA9PT0gMCAmJiBrZXlDb2RlID09PSAxMykge1xuICAgICAgY2hhckNvZGUgPSAxMztcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gSUU4IGRvZXMgbm90IGltcGxlbWVudCBgY2hhckNvZGVgLCBidXQgYGtleUNvZGVgIGhhcyB0aGUgY29ycmVjdCB2YWx1ZS5cbiAgICBjaGFyQ29kZSA9IGtleUNvZGU7XG4gIH0gLy8gSUUgYW5kIEVkZ2UgKG9uIFdpbmRvd3MpIGFuZCBDaHJvbWUgLyBTYWZhcmkgKG9uIFdpbmRvd3MgYW5kIExpbnV4KVxuICAvLyByZXBvcnQgRW50ZXIgYXMgY2hhckNvZGUgMTAgd2hlbiBjdHJsIGlzIHByZXNzZWQuXG5cblxuICBpZiAoY2hhckNvZGUgPT09IDEwKSB7XG4gICAgY2hhckNvZGUgPSAxMztcbiAgfSAvLyBTb21lIG5vbi1wcmludGFibGUga2V5cyBhcmUgcmVwb3J0ZWQgaW4gYGNoYXJDb2RlYC9ga2V5Q29kZWAsIGRpc2NhcmQgdGhlbS5cbiAgLy8gTXVzdCBub3QgZGlzY2FyZCB0aGUgKG5vbi0pcHJpbnRhYmxlIEVudGVyLWtleS5cblxuXG4gIGlmIChjaGFyQ29kZSA+PSAzMiB8fCBjaGFyQ29kZSA9PT0gMTMpIHtcbiAgICByZXR1cm4gY2hhckNvZGU7XG4gIH1cblxuICByZXR1cm4gMDtcbn1cblxuZnVuY3Rpb24gZnVuY3Rpb25UaGF0UmV0dXJuc1RydWUoKSB7XG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBmdW5jdGlvblRoYXRSZXR1cm5zRmFsc2UoKSB7XG4gIHJldHVybiBmYWxzZTtcbn0gLy8gVGhpcyBpcyBpbnRlbnRpb25hbGx5IGEgZmFjdG9yeSBzbyB0aGF0IHdlIGhhdmUgZGlmZmVyZW50IHJldHVybmVkIGNvbnN0cnVjdG9ycy5cbi8vIElmIHdlIGhhZCBhIHNpbmdsZSBjb25zdHJ1Y3RvciwgaXQgd291bGQgYmUgbWVnYW1vcnBoaWMgYW5kIGVuZ2luZXMgd291bGQgZGVvcHQuXG5cblxuZnVuY3Rpb24gY3JlYXRlU3ludGhldGljRXZlbnQoSW50ZXJmYWNlKSB7XG4gIC8qKlxuICAgKiBTeW50aGV0aWMgZXZlbnRzIGFyZSBkaXNwYXRjaGVkIGJ5IGV2ZW50IHBsdWdpbnMsIHR5cGljYWxseSBpbiByZXNwb25zZSB0byBhXG4gICAqIHRvcC1sZXZlbCBldmVudCBkZWxlZ2F0aW9uIGhhbmRsZXIuXG4gICAqXG4gICAqIFRoZXNlIHN5c3RlbXMgc2hvdWxkIGdlbmVyYWxseSB1c2UgcG9vbGluZyB0byByZWR1Y2UgdGhlIGZyZXF1ZW5jeSBvZiBnYXJiYWdlXG4gICAqIGNvbGxlY3Rpb24uIFRoZSBzeXN0ZW0gc2hvdWxkIGNoZWNrIGBpc1BlcnNpc3RlbnRgIHRvIGRldGVybWluZSB3aGV0aGVyIHRoZVxuICAgKiBldmVudCBzaG91bGQgYmUgcmVsZWFzZWQgaW50byB0aGUgcG9vbCBhZnRlciBiZWluZyBkaXNwYXRjaGVkLiBVc2VycyB0aGF0XG4gICAqIG5lZWQgYSBwZXJzaXN0ZWQgZXZlbnQgc2hvdWxkIGludm9rZSBgcGVyc2lzdGAuXG4gICAqXG4gICAqIFN5bnRoZXRpYyBldmVudHMgKGFuZCBzdWJjbGFzc2VzKSBpbXBsZW1lbnQgdGhlIERPTSBMZXZlbCAzIEV2ZW50cyBBUEkgYnlcbiAgICogbm9ybWFsaXppbmcgYnJvd3NlciBxdWlya3MuIFN1YmNsYXNzZXMgZG8gbm90IG5lY2Vzc2FyaWx5IGhhdmUgdG8gaW1wbGVtZW50IGFcbiAgICogRE9NIGludGVyZmFjZTsgY3VzdG9tIGFwcGxpY2F0aW9uLXNwZWNpZmljIGV2ZW50cyBjYW4gYWxzbyBzdWJjbGFzcyB0aGlzLlxuICAgKi9cbiAgZnVuY3Rpb24gU3ludGhldGljQmFzZUV2ZW50KHJlYWN0TmFtZSwgcmVhY3RFdmVudFR5cGUsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICAgIHRoaXMuX3JlYWN0TmFtZSA9IHJlYWN0TmFtZTtcbiAgICB0aGlzLl90YXJnZXRJbnN0ID0gdGFyZ2V0SW5zdDtcbiAgICB0aGlzLnR5cGUgPSByZWFjdEV2ZW50VHlwZTtcbiAgICB0aGlzLm5hdGl2ZUV2ZW50ID0gbmF0aXZlRXZlbnQ7XG4gICAgdGhpcy50YXJnZXQgPSBuYXRpdmVFdmVudFRhcmdldDtcbiAgICB0aGlzLmN1cnJlbnRUYXJnZXQgPSBudWxsO1xuXG4gICAgZm9yICh2YXIgX3Byb3BOYW1lIGluIEludGVyZmFjZSkge1xuICAgICAgaWYgKCFJbnRlcmZhY2UuaGFzT3duUHJvcGVydHkoX3Byb3BOYW1lKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgdmFyIG5vcm1hbGl6ZSA9IEludGVyZmFjZVtfcHJvcE5hbWVdO1xuXG4gICAgICBpZiAobm9ybWFsaXplKSB7XG4gICAgICAgIHRoaXNbX3Byb3BOYW1lXSA9IG5vcm1hbGl6ZShuYXRpdmVFdmVudCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzW19wcm9wTmFtZV0gPSBuYXRpdmVFdmVudFtfcHJvcE5hbWVdO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBkZWZhdWx0UHJldmVudGVkID0gbmF0aXZlRXZlbnQuZGVmYXVsdFByZXZlbnRlZCAhPSBudWxsID8gbmF0aXZlRXZlbnQuZGVmYXVsdFByZXZlbnRlZCA6IG5hdGl2ZUV2ZW50LnJldHVyblZhbHVlID09PSBmYWxzZTtcblxuICAgIGlmIChkZWZhdWx0UHJldmVudGVkKSB7XG4gICAgICB0aGlzLmlzRGVmYXVsdFByZXZlbnRlZCA9IGZ1bmN0aW9uVGhhdFJldHVybnNUcnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmlzRGVmYXVsdFByZXZlbnRlZCA9IGZ1bmN0aW9uVGhhdFJldHVybnNGYWxzZTtcbiAgICB9XG5cbiAgICB0aGlzLmlzUHJvcGFnYXRpb25TdG9wcGVkID0gZnVuY3Rpb25UaGF0UmV0dXJuc0ZhbHNlO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgX2Fzc2lnbihTeW50aGV0aWNCYXNlRXZlbnQucHJvdG90eXBlLCB7XG4gICAgcHJldmVudERlZmF1bHQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuZGVmYXVsdFByZXZlbnRlZCA9IHRydWU7XG4gICAgICB2YXIgZXZlbnQgPSB0aGlzLm5hdGl2ZUV2ZW50O1xuXG4gICAgICBpZiAoIWV2ZW50KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKGV2ZW50LnByZXZlbnREZWZhdWx0KSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7IC8vICRGbG93Rml4TWUgLSBmbG93IGlzIG5vdCBhd2FyZSBvZiBgdW5rbm93bmAgaW4gSUVcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGV2ZW50LnJldHVyblZhbHVlICE9PSAndW5rbm93bicpIHtcbiAgICAgICAgZXZlbnQucmV0dXJuVmFsdWUgPSBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5pc0RlZmF1bHRQcmV2ZW50ZWQgPSBmdW5jdGlvblRoYXRSZXR1cm5zVHJ1ZTtcbiAgICB9LFxuICAgIHN0b3BQcm9wYWdhdGlvbjogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGV2ZW50ID0gdGhpcy5uYXRpdmVFdmVudDtcblxuICAgICAgaWYgKCFldmVudCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChldmVudC5zdG9wUHJvcGFnYXRpb24pIHtcbiAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7IC8vICRGbG93Rml4TWUgLSBmbG93IGlzIG5vdCBhd2FyZSBvZiBgdW5rbm93bmAgaW4gSUVcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGV2ZW50LmNhbmNlbEJ1YmJsZSAhPT0gJ3Vua25vd24nKSB7XG4gICAgICAgIC8vIFRoZSBDaGFuZ2VFdmVudFBsdWdpbiByZWdpc3RlcnMgYSBcInByb3BlcnR5Y2hhbmdlXCIgZXZlbnQgZm9yXG4gICAgICAgIC8vIElFLiBUaGlzIGV2ZW50IGRvZXMgbm90IHN1cHBvcnQgYnViYmxpbmcgb3IgY2FuY2VsbGluZywgYW5kXG4gICAgICAgIC8vIGFueSByZWZlcmVuY2VzIHRvIGNhbmNlbEJ1YmJsZSB0aHJvdyBcIk1lbWJlciBub3QgZm91bmRcIi4gIEFcbiAgICAgICAgLy8gdHlwZW9mIGNoZWNrIG9mIFwidW5rbm93blwiIGNpcmN1bXZlbnRzIHRoaXMgaXNzdWUgKGFuZCBpcyBhbHNvXG4gICAgICAgIC8vIElFIHNwZWNpZmljKS5cbiAgICAgICAgZXZlbnQuY2FuY2VsQnViYmxlID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5pc1Byb3BhZ2F0aW9uU3RvcHBlZCA9IGZ1bmN0aW9uVGhhdFJldHVybnNUcnVlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBXZSByZWxlYXNlIGFsbCBkaXNwYXRjaGVkIGBTeW50aGV0aWNFdmVudGBzIGFmdGVyIGVhY2ggZXZlbnQgbG9vcCwgYWRkaW5nXG4gICAgICogdGhlbSBiYWNrIGludG8gdGhlIHBvb2wuIFRoaXMgYWxsb3dzIGEgd2F5IHRvIGhvbGQgb250byBhIHJlZmVyZW5jZSB0aGF0XG4gICAgICogd29uJ3QgYmUgYWRkZWQgYmFjayBpbnRvIHRoZSBwb29sLlxuICAgICAqL1xuICAgIHBlcnNpc3Q6IGZ1bmN0aW9uICgpIHsvLyBNb2Rlcm4gZXZlbnQgc3lzdGVtIGRvZXNuJ3QgdXNlIHBvb2xpbmcuXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiB0aGlzIGV2ZW50IHNob3VsZCBiZSByZWxlYXNlZCBiYWNrIGludG8gdGhlIHBvb2wuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoaXMgc2hvdWxkIG5vdCBiZSByZWxlYXNlZCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgICAqL1xuICAgIGlzUGVyc2lzdGVudDogZnVuY3Rpb25UaGF0UmV0dXJuc1RydWVcbiAgfSk7XG5cbiAgcmV0dXJuIFN5bnRoZXRpY0Jhc2VFdmVudDtcbn1cbi8qKlxuICogQGludGVyZmFjZSBFdmVudFxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMvXG4gKi9cblxuXG52YXIgRXZlbnRJbnRlcmZhY2UgPSB7XG4gIGV2ZW50UGhhc2U6IDAsXG4gIGJ1YmJsZXM6IDAsXG4gIGNhbmNlbGFibGU6IDAsXG4gIHRpbWVTdGFtcDogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgcmV0dXJuIGV2ZW50LnRpbWVTdGFtcCB8fCBEYXRlLm5vdygpO1xuICB9LFxuICBkZWZhdWx0UHJldmVudGVkOiAwLFxuICBpc1RydXN0ZWQ6IDBcbn07XG52YXIgU3ludGhldGljRXZlbnQgPSBjcmVhdGVTeW50aGV0aWNFdmVudChFdmVudEludGVyZmFjZSk7XG5cbnZhciBVSUV2ZW50SW50ZXJmYWNlID0gX2Fzc2lnbih7fSwgRXZlbnRJbnRlcmZhY2UsIHtcbiAgdmlldzogMCxcbiAgZGV0YWlsOiAwXG59KTtcblxudmFyIFN5bnRoZXRpY1VJRXZlbnQgPSBjcmVhdGVTeW50aGV0aWNFdmVudChVSUV2ZW50SW50ZXJmYWNlKTtcbnZhciBsYXN0TW92ZW1lbnRYO1xudmFyIGxhc3RNb3ZlbWVudFk7XG52YXIgbGFzdE1vdXNlRXZlbnQ7XG5cbmZ1bmN0aW9uIHVwZGF0ZU1vdXNlTW92ZW1lbnRQb2x5ZmlsbFN0YXRlKGV2ZW50KSB7XG4gIGlmIChldmVudCAhPT0gbGFzdE1vdXNlRXZlbnQpIHtcbiAgICBpZiAobGFzdE1vdXNlRXZlbnQgJiYgZXZlbnQudHlwZSA9PT0gJ21vdXNlbW92ZScpIHtcbiAgICAgIGxhc3RNb3ZlbWVudFggPSBldmVudC5zY3JlZW5YIC0gbGFzdE1vdXNlRXZlbnQuc2NyZWVuWDtcbiAgICAgIGxhc3RNb3ZlbWVudFkgPSBldmVudC5zY3JlZW5ZIC0gbGFzdE1vdXNlRXZlbnQuc2NyZWVuWTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGFzdE1vdmVtZW50WCA9IDA7XG4gICAgICBsYXN0TW92ZW1lbnRZID0gMDtcbiAgICB9XG5cbiAgICBsYXN0TW91c2VFdmVudCA9IGV2ZW50O1xuICB9XG59XG4vKipcbiAqIEBpbnRlcmZhY2UgTW91c2VFdmVudFxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMvXG4gKi9cblxuXG52YXIgTW91c2VFdmVudEludGVyZmFjZSA9IF9hc3NpZ24oe30sIFVJRXZlbnRJbnRlcmZhY2UsIHtcbiAgc2NyZWVuWDogMCxcbiAgc2NyZWVuWTogMCxcbiAgY2xpZW50WDogMCxcbiAgY2xpZW50WTogMCxcbiAgcGFnZVg6IDAsXG4gIHBhZ2VZOiAwLFxuICBjdHJsS2V5OiAwLFxuICBzaGlmdEtleTogMCxcbiAgYWx0S2V5OiAwLFxuICBtZXRhS2V5OiAwLFxuICBnZXRNb2RpZmllclN0YXRlOiBnZXRFdmVudE1vZGlmaWVyU3RhdGUsXG4gIGJ1dHRvbjogMCxcbiAgYnV0dG9uczogMCxcbiAgcmVsYXRlZFRhcmdldDogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgaWYgKGV2ZW50LnJlbGF0ZWRUYXJnZXQgPT09IHVuZGVmaW5lZCkgcmV0dXJuIGV2ZW50LmZyb21FbGVtZW50ID09PSBldmVudC5zcmNFbGVtZW50ID8gZXZlbnQudG9FbGVtZW50IDogZXZlbnQuZnJvbUVsZW1lbnQ7XG4gICAgcmV0dXJuIGV2ZW50LnJlbGF0ZWRUYXJnZXQ7XG4gIH0sXG4gIG1vdmVtZW50WDogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgaWYgKCdtb3ZlbWVudFgnIGluIGV2ZW50KSB7XG4gICAgICByZXR1cm4gZXZlbnQubW92ZW1lbnRYO1xuICAgIH1cblxuICAgIHVwZGF0ZU1vdXNlTW92ZW1lbnRQb2x5ZmlsbFN0YXRlKGV2ZW50KTtcbiAgICByZXR1cm4gbGFzdE1vdmVtZW50WDtcbiAgfSxcbiAgbW92ZW1lbnRZOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICBpZiAoJ21vdmVtZW50WScgaW4gZXZlbnQpIHtcbiAgICAgIHJldHVybiBldmVudC5tb3ZlbWVudFk7XG4gICAgfSAvLyBEb24ndCBuZWVkIHRvIGNhbGwgdXBkYXRlTW91c2VNb3ZlbWVudFBvbHlmaWxsU3RhdGUoKSBoZXJlXG4gICAgLy8gYmVjYXVzZSBpdCdzIGd1YXJhbnRlZWQgdG8gaGF2ZSBhbHJlYWR5IHJ1biB3aGVuIG1vdmVtZW50WFxuICAgIC8vIHdhcyBjb3BpZWQuXG5cblxuICAgIHJldHVybiBsYXN0TW92ZW1lbnRZO1xuICB9XG59KTtcblxudmFyIFN5bnRoZXRpY01vdXNlRXZlbnQgPSBjcmVhdGVTeW50aGV0aWNFdmVudChNb3VzZUV2ZW50SW50ZXJmYWNlKTtcbi8qKlxuICogQGludGVyZmFjZSBEcmFnRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtRXZlbnRzL1xuICovXG5cbnZhciBEcmFnRXZlbnRJbnRlcmZhY2UgPSBfYXNzaWduKHt9LCBNb3VzZUV2ZW50SW50ZXJmYWNlLCB7XG4gIGRhdGFUcmFuc2ZlcjogMFxufSk7XG5cbnZhciBTeW50aGV0aWNEcmFnRXZlbnQgPSBjcmVhdGVTeW50aGV0aWNFdmVudChEcmFnRXZlbnRJbnRlcmZhY2UpO1xuLyoqXG4gKiBAaW50ZXJmYWNlIEZvY3VzRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtRXZlbnRzL1xuICovXG5cbnZhciBGb2N1c0V2ZW50SW50ZXJmYWNlID0gX2Fzc2lnbih7fSwgVUlFdmVudEludGVyZmFjZSwge1xuICByZWxhdGVkVGFyZ2V0OiAwXG59KTtcblxudmFyIFN5bnRoZXRpY0ZvY3VzRXZlbnQgPSBjcmVhdGVTeW50aGV0aWNFdmVudChGb2N1c0V2ZW50SW50ZXJmYWNlKTtcbi8qKlxuICogQGludGVyZmFjZSBFdmVudFxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9jc3MzLWFuaW1hdGlvbnMvI0FuaW1hdGlvbkV2ZW50LWludGVyZmFjZVxuICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvQW5pbWF0aW9uRXZlbnRcbiAqL1xuXG52YXIgQW5pbWF0aW9uRXZlbnRJbnRlcmZhY2UgPSBfYXNzaWduKHt9LCBFdmVudEludGVyZmFjZSwge1xuICBhbmltYXRpb25OYW1lOiAwLFxuICBlbGFwc2VkVGltZTogMCxcbiAgcHNldWRvRWxlbWVudDogMFxufSk7XG5cbnZhciBTeW50aGV0aWNBbmltYXRpb25FdmVudCA9IGNyZWF0ZVN5bnRoZXRpY0V2ZW50KEFuaW1hdGlvbkV2ZW50SW50ZXJmYWNlKTtcbi8qKlxuICogQGludGVyZmFjZSBFdmVudFxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9jbGlwYm9hcmQtYXBpcy9cbiAqL1xuXG52YXIgQ2xpcGJvYXJkRXZlbnRJbnRlcmZhY2UgPSBfYXNzaWduKHt9LCBFdmVudEludGVyZmFjZSwge1xuICBjbGlwYm9hcmREYXRhOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICByZXR1cm4gJ2NsaXBib2FyZERhdGEnIGluIGV2ZW50ID8gZXZlbnQuY2xpcGJvYXJkRGF0YSA6IHdpbmRvdy5jbGlwYm9hcmREYXRhO1xuICB9XG59KTtcblxudmFyIFN5bnRoZXRpY0NsaXBib2FyZEV2ZW50ID0gY3JlYXRlU3ludGhldGljRXZlbnQoQ2xpcGJvYXJkRXZlbnRJbnRlcmZhY2UpO1xuLyoqXG4gKiBAaW50ZXJmYWNlIEV2ZW50XG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0zLUV2ZW50cy8jZXZlbnRzLWNvbXBvc2l0aW9uZXZlbnRzXG4gKi9cblxudmFyIENvbXBvc2l0aW9uRXZlbnRJbnRlcmZhY2UgPSBfYXNzaWduKHt9LCBFdmVudEludGVyZmFjZSwge1xuICBkYXRhOiAwXG59KTtcblxudmFyIFN5bnRoZXRpY0NvbXBvc2l0aW9uRXZlbnQgPSBjcmVhdGVTeW50aGV0aWNFdmVudChDb21wb3NpdGlvbkV2ZW50SW50ZXJmYWNlKTtcbi8qKlxuICogQGludGVyZmFjZSBFdmVudFxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi8yMDEzL1dELURPTS1MZXZlbC0zLUV2ZW50cy0yMDEzMTEwNVxuICogICAgICAvI2V2ZW50cy1pbnB1dGV2ZW50c1xuICovXG4vLyBIYXBwZW5zIHRvIHNoYXJlIHRoZSBzYW1lIGxpc3QgZm9yIG5vdy5cblxudmFyIFN5bnRoZXRpY0lucHV0RXZlbnQgPSBTeW50aGV0aWNDb21wb3NpdGlvbkV2ZW50O1xuLyoqXG4gKiBOb3JtYWxpemF0aW9uIG9mIGRlcHJlY2F0ZWQgSFRNTDUgYGtleWAgdmFsdWVzXG4gKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9LZXlib2FyZEV2ZW50I0tleV9uYW1lc1xuICovXG5cbnZhciBub3JtYWxpemVLZXkgPSB7XG4gIEVzYzogJ0VzY2FwZScsXG4gIFNwYWNlYmFyOiAnICcsXG4gIExlZnQ6ICdBcnJvd0xlZnQnLFxuICBVcDogJ0Fycm93VXAnLFxuICBSaWdodDogJ0Fycm93UmlnaHQnLFxuICBEb3duOiAnQXJyb3dEb3duJyxcbiAgRGVsOiAnRGVsZXRlJyxcbiAgV2luOiAnT1MnLFxuICBNZW51OiAnQ29udGV4dE1lbnUnLFxuICBBcHBzOiAnQ29udGV4dE1lbnUnLFxuICBTY3JvbGw6ICdTY3JvbGxMb2NrJyxcbiAgTW96UHJpbnRhYmxlS2V5OiAnVW5pZGVudGlmaWVkJ1xufTtcbi8qKlxuICogVHJhbnNsYXRpb24gZnJvbSBsZWdhY3kgYGtleUNvZGVgIHRvIEhUTUw1IGBrZXlgXG4gKiBPbmx5IHNwZWNpYWwga2V5cyBzdXBwb3J0ZWQsIGFsbCBvdGhlcnMgZGVwZW5kIG9uIGtleWJvYXJkIGxheW91dCBvciBicm93c2VyXG4gKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9LZXlib2FyZEV2ZW50I0tleV9uYW1lc1xuICovXG5cbnZhciB0cmFuc2xhdGVUb0tleSA9IHtcbiAgJzgnOiAnQmFja3NwYWNlJyxcbiAgJzknOiAnVGFiJyxcbiAgJzEyJzogJ0NsZWFyJyxcbiAgJzEzJzogJ0VudGVyJyxcbiAgJzE2JzogJ1NoaWZ0JyxcbiAgJzE3JzogJ0NvbnRyb2wnLFxuICAnMTgnOiAnQWx0JyxcbiAgJzE5JzogJ1BhdXNlJyxcbiAgJzIwJzogJ0NhcHNMb2NrJyxcbiAgJzI3JzogJ0VzY2FwZScsXG4gICczMic6ICcgJyxcbiAgJzMzJzogJ1BhZ2VVcCcsXG4gICczNCc6ICdQYWdlRG93bicsXG4gICczNSc6ICdFbmQnLFxuICAnMzYnOiAnSG9tZScsXG4gICczNyc6ICdBcnJvd0xlZnQnLFxuICAnMzgnOiAnQXJyb3dVcCcsXG4gICczOSc6ICdBcnJvd1JpZ2h0JyxcbiAgJzQwJzogJ0Fycm93RG93bicsXG4gICc0NSc6ICdJbnNlcnQnLFxuICAnNDYnOiAnRGVsZXRlJyxcbiAgJzExMic6ICdGMScsXG4gICcxMTMnOiAnRjInLFxuICAnMTE0JzogJ0YzJyxcbiAgJzExNSc6ICdGNCcsXG4gICcxMTYnOiAnRjUnLFxuICAnMTE3JzogJ0Y2JyxcbiAgJzExOCc6ICdGNycsXG4gICcxMTknOiAnRjgnLFxuICAnMTIwJzogJ0Y5JyxcbiAgJzEyMSc6ICdGMTAnLFxuICAnMTIyJzogJ0YxMScsXG4gICcxMjMnOiAnRjEyJyxcbiAgJzE0NCc6ICdOdW1Mb2NrJyxcbiAgJzE0NSc6ICdTY3JvbGxMb2NrJyxcbiAgJzIyNCc6ICdNZXRhJ1xufTtcbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQHJldHVybiB7c3RyaW5nfSBOb3JtYWxpemVkIGBrZXlgIHByb3BlcnR5LlxuICovXG5cbmZ1bmN0aW9uIGdldEV2ZW50S2V5KG5hdGl2ZUV2ZW50KSB7XG4gIGlmIChuYXRpdmVFdmVudC5rZXkpIHtcbiAgICAvLyBOb3JtYWxpemUgaW5jb25zaXN0ZW50IHZhbHVlcyByZXBvcnRlZCBieSBicm93c2VycyBkdWUgdG9cbiAgICAvLyBpbXBsZW1lbnRhdGlvbnMgb2YgYSB3b3JraW5nIGRyYWZ0IHNwZWNpZmljYXRpb24uXG4gICAgLy8gRmlyZUZveCBpbXBsZW1lbnRzIGBrZXlgIGJ1dCByZXR1cm5zIGBNb3pQcmludGFibGVLZXlgIGZvciBhbGxcbiAgICAvLyBwcmludGFibGUgY2hhcmFjdGVycyAobm9ybWFsaXplZCB0byBgVW5pZGVudGlmaWVkYCksIGlnbm9yZSBpdC5cbiAgICB2YXIga2V5ID0gbm9ybWFsaXplS2V5W25hdGl2ZUV2ZW50LmtleV0gfHwgbmF0aXZlRXZlbnQua2V5O1xuXG4gICAgaWYgKGtleSAhPT0gJ1VuaWRlbnRpZmllZCcpIHtcbiAgICAgIHJldHVybiBrZXk7XG4gICAgfVxuICB9IC8vIEJyb3dzZXIgZG9lcyBub3QgaW1wbGVtZW50IGBrZXlgLCBwb2x5ZmlsbCBhcyBtdWNoIG9mIGl0IGFzIHdlIGNhbi5cblxuXG4gIGlmIChuYXRpdmVFdmVudC50eXBlID09PSAna2V5cHJlc3MnKSB7XG4gICAgdmFyIGNoYXJDb2RlID0gZ2V0RXZlbnRDaGFyQ29kZShuYXRpdmVFdmVudCk7IC8vIFRoZSBlbnRlci1rZXkgaXMgdGVjaG5pY2FsbHkgYm90aCBwcmludGFibGUgYW5kIG5vbi1wcmludGFibGUgYW5kIGNhblxuICAgIC8vIHRodXMgYmUgY2FwdHVyZWQgYnkgYGtleXByZXNzYCwgbm8gb3RoZXIgbm9uLXByaW50YWJsZSBrZXkgc2hvdWxkLlxuXG4gICAgcmV0dXJuIGNoYXJDb2RlID09PSAxMyA/ICdFbnRlcicgOiBTdHJpbmcuZnJvbUNoYXJDb2RlKGNoYXJDb2RlKTtcbiAgfVxuXG4gIGlmIChuYXRpdmVFdmVudC50eXBlID09PSAna2V5ZG93bicgfHwgbmF0aXZlRXZlbnQudHlwZSA9PT0gJ2tleXVwJykge1xuICAgIC8vIFdoaWxlIHVzZXIga2V5Ym9hcmQgbGF5b3V0IGRldGVybWluZXMgdGhlIGFjdHVhbCBtZWFuaW5nIG9mIGVhY2hcbiAgICAvLyBga2V5Q29kZWAgdmFsdWUsIGFsbW9zdCBhbGwgZnVuY3Rpb24ga2V5cyBoYXZlIGEgdW5pdmVyc2FsIHZhbHVlLlxuICAgIHJldHVybiB0cmFuc2xhdGVUb0tleVtuYXRpdmVFdmVudC5rZXlDb2RlXSB8fCAnVW5pZGVudGlmaWVkJztcbiAgfVxuXG4gIHJldHVybiAnJztcbn1cbi8qKlxuICogVHJhbnNsYXRpb24gZnJvbSBtb2RpZmllciBrZXkgdG8gdGhlIGFzc29jaWF0ZWQgcHJvcGVydHkgaW4gdGhlIGV2ZW50LlxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMvI2tleXMtTW9kaWZpZXJzXG4gKi9cblxuXG52YXIgbW9kaWZpZXJLZXlUb1Byb3AgPSB7XG4gIEFsdDogJ2FsdEtleScsXG4gIENvbnRyb2w6ICdjdHJsS2V5JyxcbiAgTWV0YTogJ21ldGFLZXknLFxuICBTaGlmdDogJ3NoaWZ0S2V5J1xufTsgLy8gT2xkZXIgYnJvd3NlcnMgKFNhZmFyaSA8PSAxMCwgaU9TIFNhZmFyaSA8PSAxMC4yKSBkbyBub3Qgc3VwcG9ydFxuLy8gZ2V0TW9kaWZpZXJTdGF0ZS4gSWYgZ2V0TW9kaWZpZXJTdGF0ZSBpcyBub3Qgc3VwcG9ydGVkLCB3ZSBtYXAgaXQgdG8gYSBzZXQgb2Zcbi8vIG1vZGlmaWVyIGtleXMgZXhwb3NlZCBieSB0aGUgZXZlbnQuIEluIHRoaXMgY2FzZSwgTG9jay1rZXlzIGFyZSBub3Qgc3VwcG9ydGVkLlxuXG5mdW5jdGlvbiBtb2RpZmllclN0YXRlR2V0dGVyKGtleUFyZykge1xuICB2YXIgc3ludGhldGljRXZlbnQgPSB0aGlzO1xuICB2YXIgbmF0aXZlRXZlbnQgPSBzeW50aGV0aWNFdmVudC5uYXRpdmVFdmVudDtcblxuICBpZiAobmF0aXZlRXZlbnQuZ2V0TW9kaWZpZXJTdGF0ZSkge1xuICAgIHJldHVybiBuYXRpdmVFdmVudC5nZXRNb2RpZmllclN0YXRlKGtleUFyZyk7XG4gIH1cblxuICB2YXIga2V5UHJvcCA9IG1vZGlmaWVyS2V5VG9Qcm9wW2tleUFyZ107XG4gIHJldHVybiBrZXlQcm9wID8gISFuYXRpdmVFdmVudFtrZXlQcm9wXSA6IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBnZXRFdmVudE1vZGlmaWVyU3RhdGUobmF0aXZlRXZlbnQpIHtcbiAgcmV0dXJuIG1vZGlmaWVyU3RhdGVHZXR0ZXI7XG59XG4vKipcbiAqIEBpbnRlcmZhY2UgS2V5Ym9hcmRFdmVudFxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMvXG4gKi9cblxuXG52YXIgS2V5Ym9hcmRFdmVudEludGVyZmFjZSA9IF9hc3NpZ24oe30sIFVJRXZlbnRJbnRlcmZhY2UsIHtcbiAga2V5OiBnZXRFdmVudEtleSxcbiAgY29kZTogMCxcbiAgbG9jYXRpb246IDAsXG4gIGN0cmxLZXk6IDAsXG4gIHNoaWZ0S2V5OiAwLFxuICBhbHRLZXk6IDAsXG4gIG1ldGFLZXk6IDAsXG4gIHJlcGVhdDogMCxcbiAgbG9jYWxlOiAwLFxuICBnZXRNb2RpZmllclN0YXRlOiBnZXRFdmVudE1vZGlmaWVyU3RhdGUsXG4gIC8vIExlZ2FjeSBJbnRlcmZhY2VcbiAgY2hhckNvZGU6IGZ1bmN0aW9uIChldmVudCkge1xuICAgIC8vIGBjaGFyQ29kZWAgaXMgdGhlIHJlc3VsdCBvZiBhIEtleVByZXNzIGV2ZW50IGFuZCByZXByZXNlbnRzIHRoZSB2YWx1ZSBvZlxuICAgIC8vIHRoZSBhY3R1YWwgcHJpbnRhYmxlIGNoYXJhY3Rlci5cbiAgICAvLyBLZXlQcmVzcyBpcyBkZXByZWNhdGVkLCBidXQgaXRzIHJlcGxhY2VtZW50IGlzIG5vdCB5ZXQgZmluYWwgYW5kIG5vdFxuICAgIC8vIGltcGxlbWVudGVkIGluIGFueSBtYWpvciBicm93c2VyLiBPbmx5IEtleVByZXNzIGhhcyBjaGFyQ29kZS5cbiAgICBpZiAoZXZlbnQudHlwZSA9PT0gJ2tleXByZXNzJykge1xuICAgICAgcmV0dXJuIGdldEV2ZW50Q2hhckNvZGUoZXZlbnQpO1xuICAgIH1cblxuICAgIHJldHVybiAwO1xuICB9LFxuICBrZXlDb2RlOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAvLyBga2V5Q29kZWAgaXMgdGhlIHJlc3VsdCBvZiBhIEtleURvd24vVXAgZXZlbnQgYW5kIHJlcHJlc2VudHMgdGhlIHZhbHVlIG9mXG4gICAgLy8gcGh5c2ljYWwga2V5Ym9hcmQga2V5LlxuICAgIC8vIFRoZSBhY3R1YWwgbWVhbmluZyBvZiB0aGUgdmFsdWUgZGVwZW5kcyBvbiB0aGUgdXNlcnMnIGtleWJvYXJkIGxheW91dFxuICAgIC8vIHdoaWNoIGNhbm5vdCBiZSBkZXRlY3RlZC4gQXNzdW1pbmcgdGhhdCBpdCBpcyBhIFVTIGtleWJvYXJkIGxheW91dFxuICAgIC8vIHByb3ZpZGVzIGEgc3VycHJpc2luZ2x5IGFjY3VyYXRlIG1hcHBpbmcgZm9yIFVTIGFuZCBFdXJvcGVhbiB1c2Vycy5cbiAgICAvLyBEdWUgdG8gdGhpcywgaXQgaXMgbGVmdCB0byB0aGUgdXNlciB0byBpbXBsZW1lbnQgYXQgdGhpcyB0aW1lLlxuICAgIGlmIChldmVudC50eXBlID09PSAna2V5ZG93bicgfHwgZXZlbnQudHlwZSA9PT0gJ2tleXVwJykge1xuICAgICAgcmV0dXJuIGV2ZW50LmtleUNvZGU7XG4gICAgfVxuXG4gICAgcmV0dXJuIDA7XG4gIH0sXG4gIHdoaWNoOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAvLyBgd2hpY2hgIGlzIGFuIGFsaWFzIGZvciBlaXRoZXIgYGtleUNvZGVgIG9yIGBjaGFyQ29kZWAgZGVwZW5kaW5nIG9uIHRoZVxuICAgIC8vIHR5cGUgb2YgdGhlIGV2ZW50LlxuICAgIGlmIChldmVudC50eXBlID09PSAna2V5cHJlc3MnKSB7XG4gICAgICByZXR1cm4gZ2V0RXZlbnRDaGFyQ29kZShldmVudCk7XG4gICAgfVxuXG4gICAgaWYgKGV2ZW50LnR5cGUgPT09ICdrZXlkb3duJyB8fCBldmVudC50eXBlID09PSAna2V5dXAnKSB7XG4gICAgICByZXR1cm4gZXZlbnQua2V5Q29kZTtcbiAgICB9XG5cbiAgICByZXR1cm4gMDtcbiAgfVxufSk7XG5cbnZhciBTeW50aGV0aWNLZXlib2FyZEV2ZW50ID0gY3JlYXRlU3ludGhldGljRXZlbnQoS2V5Ym9hcmRFdmVudEludGVyZmFjZSk7XG4vKipcbiAqIEBpbnRlcmZhY2UgUG9pbnRlckV2ZW50XG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL3BvaW50ZXJldmVudHMvXG4gKi9cblxudmFyIFBvaW50ZXJFdmVudEludGVyZmFjZSA9IF9hc3NpZ24oe30sIE1vdXNlRXZlbnRJbnRlcmZhY2UsIHtcbiAgcG9pbnRlcklkOiAwLFxuICB3aWR0aDogMCxcbiAgaGVpZ2h0OiAwLFxuICBwcmVzc3VyZTogMCxcbiAgdGFuZ2VudGlhbFByZXNzdXJlOiAwLFxuICB0aWx0WDogMCxcbiAgdGlsdFk6IDAsXG4gIHR3aXN0OiAwLFxuICBwb2ludGVyVHlwZTogMCxcbiAgaXNQcmltYXJ5OiAwXG59KTtcblxudmFyIFN5bnRoZXRpY1BvaW50ZXJFdmVudCA9IGNyZWF0ZVN5bnRoZXRpY0V2ZW50KFBvaW50ZXJFdmVudEludGVyZmFjZSk7XG4vKipcbiAqIEBpbnRlcmZhY2UgVG91Y2hFdmVudFxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi90b3VjaC1ldmVudHMvXG4gKi9cblxudmFyIFRvdWNoRXZlbnRJbnRlcmZhY2UgPSBfYXNzaWduKHt9LCBVSUV2ZW50SW50ZXJmYWNlLCB7XG4gIHRvdWNoZXM6IDAsXG4gIHRhcmdldFRvdWNoZXM6IDAsXG4gIGNoYW5nZWRUb3VjaGVzOiAwLFxuICBhbHRLZXk6IDAsXG4gIG1ldGFLZXk6IDAsXG4gIGN0cmxLZXk6IDAsXG4gIHNoaWZ0S2V5OiAwLFxuICBnZXRNb2RpZmllclN0YXRlOiBnZXRFdmVudE1vZGlmaWVyU3RhdGVcbn0pO1xuXG52YXIgU3ludGhldGljVG91Y2hFdmVudCA9IGNyZWF0ZVN5bnRoZXRpY0V2ZW50KFRvdWNoRXZlbnRJbnRlcmZhY2UpO1xuLyoqXG4gKiBAaW50ZXJmYWNlIEV2ZW50XG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSLzIwMDkvV0QtY3NzMy10cmFuc2l0aW9ucy0yMDA5MDMyMC8jdHJhbnNpdGlvbi1ldmVudHMtXG4gKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9UcmFuc2l0aW9uRXZlbnRcbiAqL1xuXG52YXIgVHJhbnNpdGlvbkV2ZW50SW50ZXJmYWNlID0gX2Fzc2lnbih7fSwgRXZlbnRJbnRlcmZhY2UsIHtcbiAgcHJvcGVydHlOYW1lOiAwLFxuICBlbGFwc2VkVGltZTogMCxcbiAgcHNldWRvRWxlbWVudDogMFxufSk7XG5cbnZhciBTeW50aGV0aWNUcmFuc2l0aW9uRXZlbnQgPSBjcmVhdGVTeW50aGV0aWNFdmVudChUcmFuc2l0aW9uRXZlbnRJbnRlcmZhY2UpO1xuLyoqXG4gKiBAaW50ZXJmYWNlIFdoZWVsRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtRXZlbnRzL1xuICovXG5cbnZhciBXaGVlbEV2ZW50SW50ZXJmYWNlID0gX2Fzc2lnbih7fSwgTW91c2VFdmVudEludGVyZmFjZSwge1xuICBkZWx0YVg6IGZ1bmN0aW9uIChldmVudCkge1xuICAgIHJldHVybiAnZGVsdGFYJyBpbiBldmVudCA/IGV2ZW50LmRlbHRhWCA6IC8vIEZhbGxiYWNrIHRvIGB3aGVlbERlbHRhWGAgZm9yIFdlYmtpdCBhbmQgbm9ybWFsaXplIChyaWdodCBpcyBwb3NpdGl2ZSkuXG4gICAgJ3doZWVsRGVsdGFYJyBpbiBldmVudCA/IC1ldmVudC53aGVlbERlbHRhWCA6IDA7XG4gIH0sXG4gIGRlbHRhWTogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgcmV0dXJuICdkZWx0YVknIGluIGV2ZW50ID8gZXZlbnQuZGVsdGFZIDogLy8gRmFsbGJhY2sgdG8gYHdoZWVsRGVsdGFZYCBmb3IgV2Via2l0IGFuZCBub3JtYWxpemUgKGRvd24gaXMgcG9zaXRpdmUpLlxuICAgICd3aGVlbERlbHRhWScgaW4gZXZlbnQgPyAtZXZlbnQud2hlZWxEZWx0YVkgOiAvLyBGYWxsYmFjayB0byBgd2hlZWxEZWx0YWAgZm9yIElFPDkgYW5kIG5vcm1hbGl6ZSAoZG93biBpcyBwb3NpdGl2ZSkuXG4gICAgJ3doZWVsRGVsdGEnIGluIGV2ZW50ID8gLWV2ZW50LndoZWVsRGVsdGEgOiAwO1xuICB9LFxuICBkZWx0YVo6IDAsXG4gIC8vIEJyb3dzZXJzIHdpdGhvdXQgXCJkZWx0YU1vZGVcIiBpcyByZXBvcnRpbmcgaW4gcmF3IHdoZWVsIGRlbHRhIHdoZXJlIG9uZVxuICAvLyBub3RjaCBvbiB0aGUgc2Nyb2xsIGlzIGFsd2F5cyArLy0gMTIwLCByb3VnaGx5IGVxdWl2YWxlbnQgdG8gcGl4ZWxzLlxuICAvLyBBIGdvb2QgYXBwcm94aW1hdGlvbiBvZiBET01fREVMVEFfTElORSAoMSkgaXMgNSUgb2Ygdmlld3BvcnQgc2l6ZSBvclxuICAvLyB+NDAgcGl4ZWxzLCBmb3IgRE9NX0RFTFRBX1NDUkVFTiAoMikgaXQgaXMgODcuNSUgb2Ygdmlld3BvcnQgc2l6ZS5cbiAgZGVsdGFNb2RlOiAwXG59KTtcblxudmFyIFN5bnRoZXRpY1doZWVsRXZlbnQgPSBjcmVhdGVTeW50aGV0aWNFdmVudChXaGVlbEV2ZW50SW50ZXJmYWNlKTtcblxudmFyIEVORF9LRVlDT0RFUyA9IFs5LCAxMywgMjcsIDMyXTsgLy8gVGFiLCBSZXR1cm4sIEVzYywgU3BhY2VcblxudmFyIFNUQVJUX0tFWUNPREUgPSAyMjk7XG52YXIgY2FuVXNlQ29tcG9zaXRpb25FdmVudCA9IGNhblVzZURPTSAmJiAnQ29tcG9zaXRpb25FdmVudCcgaW4gd2luZG93O1xudmFyIGRvY3VtZW50TW9kZSA9IG51bGw7XG5cbmlmIChjYW5Vc2VET00gJiYgJ2RvY3VtZW50TW9kZScgaW4gZG9jdW1lbnQpIHtcbiAgZG9jdW1lbnRNb2RlID0gZG9jdW1lbnQuZG9jdW1lbnRNb2RlO1xufSAvLyBXZWJraXQgb2ZmZXJzIGEgdmVyeSB1c2VmdWwgYHRleHRJbnB1dGAgZXZlbnQgdGhhdCBjYW4gYmUgdXNlZCB0b1xuLy8gZGlyZWN0bHkgcmVwcmVzZW50IGBiZWZvcmVJbnB1dGAuIFRoZSBJRSBgdGV4dGlucHV0YCBldmVudCBpcyBub3QgYXNcbi8vIHVzZWZ1bCwgc28gd2UgZG9uJ3QgdXNlIGl0LlxuXG5cbnZhciBjYW5Vc2VUZXh0SW5wdXRFdmVudCA9IGNhblVzZURPTSAmJiAnVGV4dEV2ZW50JyBpbiB3aW5kb3cgJiYgIWRvY3VtZW50TW9kZTsgLy8gSW4gSUU5Kywgd2UgaGF2ZSBhY2Nlc3MgdG8gY29tcG9zaXRpb24gZXZlbnRzLCBidXQgdGhlIGRhdGEgc3VwcGxpZWRcbi8vIGJ5IHRoZSBuYXRpdmUgY29tcG9zaXRpb25lbmQgZXZlbnQgbWF5IGJlIGluY29ycmVjdC4gSmFwYW5lc2UgaWRlb2dyYXBoaWNcbi8vIHNwYWNlcywgZm9yIGluc3RhbmNlIChcXHUzMDAwKSBhcmUgbm90IHJlY29yZGVkIGNvcnJlY3RseS5cblxudmFyIHVzZUZhbGxiYWNrQ29tcG9zaXRpb25EYXRhID0gY2FuVXNlRE9NICYmICghY2FuVXNlQ29tcG9zaXRpb25FdmVudCB8fCBkb2N1bWVudE1vZGUgJiYgZG9jdW1lbnRNb2RlID4gOCAmJiBkb2N1bWVudE1vZGUgPD0gMTEpO1xudmFyIFNQQUNFQkFSX0NPREUgPSAzMjtcbnZhciBTUEFDRUJBUl9DSEFSID0gU3RyaW5nLmZyb21DaGFyQ29kZShTUEFDRUJBUl9DT0RFKTtcblxuZnVuY3Rpb24gcmVnaXN0ZXJFdmVudHMoKSB7XG4gIHJlZ2lzdGVyVHdvUGhhc2VFdmVudCgnb25CZWZvcmVJbnB1dCcsIFsnY29tcG9zaXRpb25lbmQnLCAna2V5cHJlc3MnLCAndGV4dElucHV0JywgJ3Bhc3RlJ10pO1xuICByZWdpc3RlclR3b1BoYXNlRXZlbnQoJ29uQ29tcG9zaXRpb25FbmQnLCBbJ2NvbXBvc2l0aW9uZW5kJywgJ2ZvY3Vzb3V0JywgJ2tleWRvd24nLCAna2V5cHJlc3MnLCAna2V5dXAnLCAnbW91c2Vkb3duJ10pO1xuICByZWdpc3RlclR3b1BoYXNlRXZlbnQoJ29uQ29tcG9zaXRpb25TdGFydCcsIFsnY29tcG9zaXRpb25zdGFydCcsICdmb2N1c291dCcsICdrZXlkb3duJywgJ2tleXByZXNzJywgJ2tleXVwJywgJ21vdXNlZG93biddKTtcbiAgcmVnaXN0ZXJUd29QaGFzZUV2ZW50KCdvbkNvbXBvc2l0aW9uVXBkYXRlJywgWydjb21wb3NpdGlvbnVwZGF0ZScsICdmb2N1c291dCcsICdrZXlkb3duJywgJ2tleXByZXNzJywgJ2tleXVwJywgJ21vdXNlZG93biddKTtcbn0gLy8gVHJhY2sgd2hldGhlciB3ZSd2ZSBldmVyIGhhbmRsZWQgYSBrZXlwcmVzcyBvbiB0aGUgc3BhY2Uga2V5LlxuXG5cbnZhciBoYXNTcGFjZUtleXByZXNzID0gZmFsc2U7XG4vKipcbiAqIFJldHVybiB3aGV0aGVyIGEgbmF0aXZlIGtleXByZXNzIGV2ZW50IGlzIGFzc3VtZWQgdG8gYmUgYSBjb21tYW5kLlxuICogVGhpcyBpcyByZXF1aXJlZCBiZWNhdXNlIEZpcmVmb3ggZmlyZXMgYGtleXByZXNzYCBldmVudHMgZm9yIGtleSBjb21tYW5kc1xuICogKGN1dCwgY29weSwgc2VsZWN0LWFsbCwgZXRjLikgZXZlbiB0aG91Z2ggbm8gY2hhcmFjdGVyIGlzIGluc2VydGVkLlxuICovXG5cbmZ1bmN0aW9uIGlzS2V5cHJlc3NDb21tYW5kKG5hdGl2ZUV2ZW50KSB7XG4gIHJldHVybiAobmF0aXZlRXZlbnQuY3RybEtleSB8fCBuYXRpdmVFdmVudC5hbHRLZXkgfHwgbmF0aXZlRXZlbnQubWV0YUtleSkgJiYgLy8gY3RybEtleSAmJiBhbHRLZXkgaXMgZXF1aXZhbGVudCB0byBBbHRHciwgYW5kIGlzIG5vdCBhIGNvbW1hbmQuXG4gICEobmF0aXZlRXZlbnQuY3RybEtleSAmJiBuYXRpdmVFdmVudC5hbHRLZXkpO1xufVxuLyoqXG4gKiBUcmFuc2xhdGUgbmF0aXZlIHRvcCBsZXZlbCBldmVudHMgaW50byBldmVudCB0eXBlcy5cbiAqL1xuXG5cbmZ1bmN0aW9uIGdldENvbXBvc2l0aW9uRXZlbnRUeXBlKGRvbUV2ZW50TmFtZSkge1xuICBzd2l0Y2ggKGRvbUV2ZW50TmFtZSkge1xuICAgIGNhc2UgJ2NvbXBvc2l0aW9uc3RhcnQnOlxuICAgICAgcmV0dXJuICdvbkNvbXBvc2l0aW9uU3RhcnQnO1xuXG4gICAgY2FzZSAnY29tcG9zaXRpb25lbmQnOlxuICAgICAgcmV0dXJuICdvbkNvbXBvc2l0aW9uRW5kJztcblxuICAgIGNhc2UgJ2NvbXBvc2l0aW9udXBkYXRlJzpcbiAgICAgIHJldHVybiAnb25Db21wb3NpdGlvblVwZGF0ZSc7XG4gIH1cbn1cbi8qKlxuICogRG9lcyBvdXIgZmFsbGJhY2sgYmVzdC1ndWVzcyBtb2RlbCB0aGluayB0aGlzIGV2ZW50IHNpZ25pZmllcyB0aGF0XG4gKiBjb21wb3NpdGlvbiBoYXMgYmVndW4/XG4gKi9cblxuXG5mdW5jdGlvbiBpc0ZhbGxiYWNrQ29tcG9zaXRpb25TdGFydChkb21FdmVudE5hbWUsIG5hdGl2ZUV2ZW50KSB7XG4gIHJldHVybiBkb21FdmVudE5hbWUgPT09ICdrZXlkb3duJyAmJiBuYXRpdmVFdmVudC5rZXlDb2RlID09PSBTVEFSVF9LRVlDT0RFO1xufVxuLyoqXG4gKiBEb2VzIG91ciBmYWxsYmFjayBtb2RlIHRoaW5rIHRoYXQgdGhpcyBldmVudCBpcyB0aGUgZW5kIG9mIGNvbXBvc2l0aW9uP1xuICovXG5cblxuZnVuY3Rpb24gaXNGYWxsYmFja0NvbXBvc2l0aW9uRW5kKGRvbUV2ZW50TmFtZSwgbmF0aXZlRXZlbnQpIHtcbiAgc3dpdGNoIChkb21FdmVudE5hbWUpIHtcbiAgICBjYXNlICdrZXl1cCc6XG4gICAgICAvLyBDb21tYW5kIGtleXMgaW5zZXJ0IG9yIGNsZWFyIElNRSBpbnB1dC5cbiAgICAgIHJldHVybiBFTkRfS0VZQ09ERVMuaW5kZXhPZihuYXRpdmVFdmVudC5rZXlDb2RlKSAhPT0gLTE7XG5cbiAgICBjYXNlICdrZXlkb3duJzpcbiAgICAgIC8vIEV4cGVjdCBJTUUga2V5Q29kZSBvbiBlYWNoIGtleWRvd24uIElmIHdlIGdldCBhbnkgb3RoZXJcbiAgICAgIC8vIGNvZGUgd2UgbXVzdCBoYXZlIGV4aXRlZCBlYXJsaWVyLlxuICAgICAgcmV0dXJuIG5hdGl2ZUV2ZW50LmtleUNvZGUgIT09IFNUQVJUX0tFWUNPREU7XG5cbiAgICBjYXNlICdrZXlwcmVzcyc6XG4gICAgY2FzZSAnbW91c2Vkb3duJzpcbiAgICBjYXNlICdmb2N1c291dCc6XG4gICAgICAvLyBFdmVudHMgYXJlIG5vdCBwb3NzaWJsZSB3aXRob3V0IGNhbmNlbGxpbmcgSU1FLlxuICAgICAgcmV0dXJuIHRydWU7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG4vKipcbiAqIEdvb2dsZSBJbnB1dCBUb29scyBwcm92aWRlcyBjb21wb3NpdGlvbiBkYXRhIHZpYSBhIEN1c3RvbUV2ZW50LFxuICogd2l0aCB0aGUgYGRhdGFgIHByb3BlcnR5IHBvcHVsYXRlZCBpbiB0aGUgYGRldGFpbGAgb2JqZWN0LiBJZiB0aGlzXG4gKiBpcyBhdmFpbGFibGUgb24gdGhlIGV2ZW50IG9iamVjdCwgdXNlIGl0LiBJZiBub3QsIHRoaXMgaXMgYSBwbGFpblxuICogY29tcG9zaXRpb24gZXZlbnQgYW5kIHdlIGhhdmUgbm90aGluZyBzcGVjaWFsIHRvIGV4dHJhY3QuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50XG4gKiBAcmV0dXJuIHs/c3RyaW5nfVxuICovXG5cblxuZnVuY3Rpb24gZ2V0RGF0YUZyb21DdXN0b21FdmVudChuYXRpdmVFdmVudCkge1xuICB2YXIgZGV0YWlsID0gbmF0aXZlRXZlbnQuZGV0YWlsO1xuXG4gIGlmICh0eXBlb2YgZGV0YWlsID09PSAnb2JqZWN0JyAmJiAnZGF0YScgaW4gZGV0YWlsKSB7XG4gICAgcmV0dXJuIGRldGFpbC5kYXRhO1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG4vKipcbiAqIENoZWNrIGlmIGEgY29tcG9zaXRpb24gZXZlbnQgd2FzIHRyaWdnZXJlZCBieSBLb3JlYW4gSU1FLlxuICogT3VyIGZhbGxiYWNrIG1vZGUgZG9lcyBub3Qgd29yayB3ZWxsIHdpdGggSUUncyBLb3JlYW4gSU1FLFxuICogc28ganVzdCB1c2UgbmF0aXZlIGNvbXBvc2l0aW9uIGV2ZW50cyB3aGVuIEtvcmVhbiBJTUUgaXMgdXNlZC5cbiAqIEFsdGhvdWdoIENvbXBvc2l0aW9uRXZlbnQubG9jYWxlIHByb3BlcnR5IGlzIGRlcHJlY2F0ZWQsXG4gKiBpdCBpcyBhdmFpbGFibGUgaW4gSUUsIHdoZXJlIG91ciBmYWxsYmFjayBtb2RlIGlzIGVuYWJsZWQuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50XG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5cblxuZnVuY3Rpb24gaXNVc2luZ0tvcmVhbklNRShuYXRpdmVFdmVudCkge1xuICByZXR1cm4gbmF0aXZlRXZlbnQubG9jYWxlID09PSAna28nO1xufSAvLyBUcmFjayB0aGUgY3VycmVudCBJTUUgY29tcG9zaXRpb24gc3RhdHVzLCBpZiBhbnkuXG5cblxudmFyIGlzQ29tcG9zaW5nID0gZmFsc2U7XG4vKipcbiAqIEByZXR1cm4gez9vYmplY3R9IEEgU3ludGhldGljQ29tcG9zaXRpb25FdmVudC5cbiAqL1xuXG5mdW5jdGlvbiBleHRyYWN0Q29tcG9zaXRpb25FdmVudChkaXNwYXRjaFF1ZXVlLCBkb21FdmVudE5hbWUsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICB2YXIgZXZlbnRUeXBlO1xuICB2YXIgZmFsbGJhY2tEYXRhO1xuXG4gIGlmIChjYW5Vc2VDb21wb3NpdGlvbkV2ZW50KSB7XG4gICAgZXZlbnRUeXBlID0gZ2V0Q29tcG9zaXRpb25FdmVudFR5cGUoZG9tRXZlbnROYW1lKTtcbiAgfSBlbHNlIGlmICghaXNDb21wb3NpbmcpIHtcbiAgICBpZiAoaXNGYWxsYmFja0NvbXBvc2l0aW9uU3RhcnQoZG9tRXZlbnROYW1lLCBuYXRpdmVFdmVudCkpIHtcbiAgICAgIGV2ZW50VHlwZSA9ICdvbkNvbXBvc2l0aW9uU3RhcnQnO1xuICAgIH1cbiAgfSBlbHNlIGlmIChpc0ZhbGxiYWNrQ29tcG9zaXRpb25FbmQoZG9tRXZlbnROYW1lLCBuYXRpdmVFdmVudCkpIHtcbiAgICBldmVudFR5cGUgPSAnb25Db21wb3NpdGlvbkVuZCc7XG4gIH1cblxuICBpZiAoIWV2ZW50VHlwZSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgaWYgKHVzZUZhbGxiYWNrQ29tcG9zaXRpb25EYXRhICYmICFpc1VzaW5nS29yZWFuSU1FKG5hdGl2ZUV2ZW50KSkge1xuICAgIC8vIFRoZSBjdXJyZW50IGNvbXBvc2l0aW9uIGlzIHN0b3JlZCBzdGF0aWNhbGx5IGFuZCBtdXN0IG5vdCBiZVxuICAgIC8vIG92ZXJ3cml0dGVuIHdoaWxlIGNvbXBvc2l0aW9uIGNvbnRpbnVlcy5cbiAgICBpZiAoIWlzQ29tcG9zaW5nICYmIGV2ZW50VHlwZSA9PT0gJ29uQ29tcG9zaXRpb25TdGFydCcpIHtcbiAgICAgIGlzQ29tcG9zaW5nID0gaW5pdGlhbGl6ZShuYXRpdmVFdmVudFRhcmdldCk7XG4gICAgfSBlbHNlIGlmIChldmVudFR5cGUgPT09ICdvbkNvbXBvc2l0aW9uRW5kJykge1xuICAgICAgaWYgKGlzQ29tcG9zaW5nKSB7XG4gICAgICAgIGZhbGxiYWNrRGF0YSA9IGdldERhdGEoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB2YXIgbGlzdGVuZXJzID0gYWNjdW11bGF0ZVR3b1BoYXNlTGlzdGVuZXJzKHRhcmdldEluc3QsIGV2ZW50VHlwZSk7XG5cbiAgaWYgKGxpc3RlbmVycy5sZW5ndGggPiAwKSB7XG4gICAgdmFyIGV2ZW50ID0gbmV3IFN5bnRoZXRpY0NvbXBvc2l0aW9uRXZlbnQoZXZlbnRUeXBlLCBkb21FdmVudE5hbWUsIG51bGwsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG4gICAgZGlzcGF0Y2hRdWV1ZS5wdXNoKHtcbiAgICAgIGV2ZW50OiBldmVudCxcbiAgICAgIGxpc3RlbmVyczogbGlzdGVuZXJzXG4gICAgfSk7XG5cbiAgICBpZiAoZmFsbGJhY2tEYXRhKSB7XG4gICAgICAvLyBJbmplY3QgZGF0YSBnZW5lcmF0ZWQgZnJvbSBmYWxsYmFjayBwYXRoIGludG8gdGhlIHN5bnRoZXRpYyBldmVudC5cbiAgICAgIC8vIFRoaXMgbWF0Y2hlcyB0aGUgcHJvcGVydHkgb2YgbmF0aXZlIENvbXBvc2l0aW9uRXZlbnRJbnRlcmZhY2UuXG4gICAgICBldmVudC5kYXRhID0gZmFsbGJhY2tEYXRhO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgY3VzdG9tRGF0YSA9IGdldERhdGFGcm9tQ3VzdG9tRXZlbnQobmF0aXZlRXZlbnQpO1xuXG4gICAgICBpZiAoY3VzdG9tRGF0YSAhPT0gbnVsbCkge1xuICAgICAgICBldmVudC5kYXRhID0gY3VzdG9tRGF0YTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0TmF0aXZlQmVmb3JlSW5wdXRDaGFycyhkb21FdmVudE5hbWUsIG5hdGl2ZUV2ZW50KSB7XG4gIHN3aXRjaCAoZG9tRXZlbnROYW1lKSB7XG4gICAgY2FzZSAnY29tcG9zaXRpb25lbmQnOlxuICAgICAgcmV0dXJuIGdldERhdGFGcm9tQ3VzdG9tRXZlbnQobmF0aXZlRXZlbnQpO1xuXG4gICAgY2FzZSAna2V5cHJlc3MnOlxuICAgICAgLyoqXG4gICAgICAgKiBJZiBuYXRpdmUgYHRleHRJbnB1dGAgZXZlbnRzIGFyZSBhdmFpbGFibGUsIG91ciBnb2FsIGlzIHRvIG1ha2VcbiAgICAgICAqIHVzZSBvZiB0aGVtLiBIb3dldmVyLCB0aGVyZSBpcyBhIHNwZWNpYWwgY2FzZTogdGhlIHNwYWNlYmFyIGtleS5cbiAgICAgICAqIEluIFdlYmtpdCwgcHJldmVudGluZyBkZWZhdWx0IG9uIGEgc3BhY2ViYXIgYHRleHRJbnB1dGAgZXZlbnRcbiAgICAgICAqIGNhbmNlbHMgY2hhcmFjdGVyIGluc2VydGlvbiwgYnV0IGl0ICphbHNvKiBjYXVzZXMgdGhlIGJyb3dzZXJcbiAgICAgICAqIHRvIGZhbGwgYmFjayB0byBpdHMgZGVmYXVsdCBzcGFjZWJhciBiZWhhdmlvciBvZiBzY3JvbGxpbmcgdGhlXG4gICAgICAgKiBwYWdlLlxuICAgICAgICpcbiAgICAgICAqIFRyYWNraW5nIGF0OlxuICAgICAgICogaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTM1NTEwM1xuICAgICAgICpcbiAgICAgICAqIFRvIGF2b2lkIHRoaXMgaXNzdWUsIHVzZSB0aGUga2V5cHJlc3MgZXZlbnQgYXMgaWYgbm8gYHRleHRJbnB1dGBcbiAgICAgICAqIGV2ZW50IGlzIGF2YWlsYWJsZS5cbiAgICAgICAqL1xuICAgICAgdmFyIHdoaWNoID0gbmF0aXZlRXZlbnQud2hpY2g7XG5cbiAgICAgIGlmICh3aGljaCAhPT0gU1BBQ0VCQVJfQ09ERSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgaGFzU3BhY2VLZXlwcmVzcyA9IHRydWU7XG4gICAgICByZXR1cm4gU1BBQ0VCQVJfQ0hBUjtcblxuICAgIGNhc2UgJ3RleHRJbnB1dCc6XG4gICAgICAvLyBSZWNvcmQgdGhlIGNoYXJhY3RlcnMgdG8gYmUgYWRkZWQgdG8gdGhlIERPTS5cbiAgICAgIHZhciBjaGFycyA9IG5hdGl2ZUV2ZW50LmRhdGE7IC8vIElmIGl0J3MgYSBzcGFjZWJhciBjaGFyYWN0ZXIsIGFzc3VtZSB0aGF0IHdlIGhhdmUgYWxyZWFkeSBoYW5kbGVkXG4gICAgICAvLyBpdCBhdCB0aGUga2V5cHJlc3MgbGV2ZWwgYW5kIGJhaWwgaW1tZWRpYXRlbHkuIEFuZHJvaWQgQ2hyb21lXG4gICAgICAvLyBkb2Vzbid0IGdpdmUgdXMga2V5Y29kZXMsIHNvIHdlIG5lZWQgdG8gaWdub3JlIGl0LlxuXG4gICAgICBpZiAoY2hhcnMgPT09IFNQQUNFQkFSX0NIQVIgJiYgaGFzU3BhY2VLZXlwcmVzcykge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGNoYXJzO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIC8vIEZvciBvdGhlciBuYXRpdmUgZXZlbnQgdHlwZXMsIGRvIG5vdGhpbmcuXG4gICAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuLyoqXG4gKiBGb3IgYnJvd3NlcnMgdGhhdCBkbyBub3QgcHJvdmlkZSB0aGUgYHRleHRJbnB1dGAgZXZlbnQsIGV4dHJhY3QgdGhlXG4gKiBhcHByb3ByaWF0ZSBzdHJpbmcgdG8gdXNlIGZvciBTeW50aGV0aWNJbnB1dEV2ZW50LlxuICovXG5cblxuZnVuY3Rpb24gZ2V0RmFsbGJhY2tCZWZvcmVJbnB1dENoYXJzKGRvbUV2ZW50TmFtZSwgbmF0aXZlRXZlbnQpIHtcbiAgLy8gSWYgd2UgYXJlIGN1cnJlbnRseSBjb21wb3NpbmcgKElNRSkgYW5kIHVzaW5nIGEgZmFsbGJhY2sgdG8gZG8gc28sXG4gIC8vIHRyeSB0byBleHRyYWN0IHRoZSBjb21wb3NlZCBjaGFyYWN0ZXJzIGZyb20gdGhlIGZhbGxiYWNrIG9iamVjdC5cbiAgLy8gSWYgY29tcG9zaXRpb24gZXZlbnQgaXMgYXZhaWxhYmxlLCB3ZSBleHRyYWN0IGEgc3RyaW5nIG9ubHkgYXRcbiAgLy8gY29tcG9zaXRpb25ldmVudCwgb3RoZXJ3aXNlIGV4dHJhY3QgaXQgYXQgZmFsbGJhY2sgZXZlbnRzLlxuICBpZiAoaXNDb21wb3NpbmcpIHtcbiAgICBpZiAoZG9tRXZlbnROYW1lID09PSAnY29tcG9zaXRpb25lbmQnIHx8ICFjYW5Vc2VDb21wb3NpdGlvbkV2ZW50ICYmIGlzRmFsbGJhY2tDb21wb3NpdGlvbkVuZChkb21FdmVudE5hbWUsIG5hdGl2ZUV2ZW50KSkge1xuICAgICAgdmFyIGNoYXJzID0gZ2V0RGF0YSgpO1xuICAgICAgcmVzZXQoKTtcbiAgICAgIGlzQ29tcG9zaW5nID0gZmFsc2U7XG4gICAgICByZXR1cm4gY2hhcnM7XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBzd2l0Y2ggKGRvbUV2ZW50TmFtZSkge1xuICAgIGNhc2UgJ3Bhc3RlJzpcbiAgICAgIC8vIElmIGEgcGFzdGUgZXZlbnQgb2NjdXJzIGFmdGVyIGEga2V5cHJlc3MsIHRocm93IG91dCB0aGUgaW5wdXRcbiAgICAgIC8vIGNoYXJzLiBQYXN0ZSBldmVudHMgc2hvdWxkIG5vdCBsZWFkIHRvIEJlZm9yZUlucHV0IGV2ZW50cy5cbiAgICAgIHJldHVybiBudWxsO1xuXG4gICAgY2FzZSAna2V5cHJlc3MnOlxuICAgICAgLyoqXG4gICAgICAgKiBBcyBvZiB2MjcsIEZpcmVmb3ggbWF5IGZpcmUga2V5cHJlc3MgZXZlbnRzIGV2ZW4gd2hlbiBubyBjaGFyYWN0ZXJcbiAgICAgICAqIHdpbGwgYmUgaW5zZXJ0ZWQuIEEgZmV3IHBvc3NpYmlsaXRpZXM6XG4gICAgICAgKlxuICAgICAgICogLSBgd2hpY2hgIGlzIGAwYC4gQXJyb3cga2V5cywgRXNjIGtleSwgZXRjLlxuICAgICAgICpcbiAgICAgICAqIC0gYHdoaWNoYCBpcyB0aGUgcHJlc3NlZCBrZXkgY29kZSwgYnV0IG5vIGNoYXIgaXMgYXZhaWxhYmxlLlxuICAgICAgICogICBFeDogJ0FsdEdyICsgZGAgaW4gUG9saXNoLiBUaGVyZSBpcyBubyBtb2RpZmllZCBjaGFyYWN0ZXIgZm9yXG4gICAgICAgKiAgIHRoaXMga2V5IGNvbWJpbmF0aW9uIGFuZCBubyBjaGFyYWN0ZXIgaXMgaW5zZXJ0ZWQgaW50byB0aGVcbiAgICAgICAqICAgZG9jdW1lbnQsIGJ1dCBGRiBmaXJlcyB0aGUga2V5cHJlc3MgZm9yIGNoYXIgY29kZSBgMTAwYCBhbnl3YXkuXG4gICAgICAgKiAgIE5vIGBpbnB1dGAgZXZlbnQgd2lsbCBvY2N1ci5cbiAgICAgICAqXG4gICAgICAgKiAtIGB3aGljaGAgaXMgdGhlIHByZXNzZWQga2V5IGNvZGUsIGJ1dCBhIGNvbW1hbmQgY29tYmluYXRpb24gaXNcbiAgICAgICAqICAgYmVpbmcgdXNlZC4gRXg6IGBDbWQrQ2AuIE5vIGNoYXJhY3RlciBpcyBpbnNlcnRlZCwgYW5kIG5vXG4gICAgICAgKiAgIGBpbnB1dGAgZXZlbnQgd2lsbCBvY2N1ci5cbiAgICAgICAqL1xuICAgICAgaWYgKCFpc0tleXByZXNzQ29tbWFuZChuYXRpdmVFdmVudCkpIHtcbiAgICAgICAgLy8gSUUgZmlyZXMgdGhlIGBrZXlwcmVzc2AgZXZlbnQgd2hlbiBhIHVzZXIgdHlwZXMgYW4gZW1vamkgdmlhXG4gICAgICAgIC8vIFRvdWNoIGtleWJvYXJkIG9mIFdpbmRvd3MuICBJbiBzdWNoIGEgY2FzZSwgdGhlIGBjaGFyYCBwcm9wZXJ0eVxuICAgICAgICAvLyBob2xkcyBhbiBlbW9qaSBjaGFyYWN0ZXIgbGlrZSBgXFx1RDgzRFxcdURFMEFgLiAgQmVjYXVzZSBpdHMgbGVuZ3RoXG4gICAgICAgIC8vIGlzIDIsIHRoZSBwcm9wZXJ0eSBgd2hpY2hgIGRvZXMgbm90IHJlcHJlc2VudCBhbiBlbW9qaSBjb3JyZWN0bHkuXG4gICAgICAgIC8vIEluIHN1Y2ggYSBjYXNlLCB3ZSBkaXJlY3RseSByZXR1cm4gdGhlIGBjaGFyYCBwcm9wZXJ0eSBpbnN0ZWFkIG9mXG4gICAgICAgIC8vIHVzaW5nIGB3aGljaGAuXG4gICAgICAgIGlmIChuYXRpdmVFdmVudC5jaGFyICYmIG5hdGl2ZUV2ZW50LmNoYXIubGVuZ3RoID4gMSkge1xuICAgICAgICAgIHJldHVybiBuYXRpdmVFdmVudC5jaGFyO1xuICAgICAgICB9IGVsc2UgaWYgKG5hdGl2ZUV2ZW50LndoaWNoKSB7XG4gICAgICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUobmF0aXZlRXZlbnQud2hpY2gpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBudWxsO1xuXG4gICAgY2FzZSAnY29tcG9zaXRpb25lbmQnOlxuICAgICAgcmV0dXJuIHVzZUZhbGxiYWNrQ29tcG9zaXRpb25EYXRhICYmICFpc1VzaW5nS29yZWFuSU1FKG5hdGl2ZUV2ZW50KSA/IG51bGwgOiBuYXRpdmVFdmVudC5kYXRhO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBudWxsO1xuICB9XG59XG4vKipcbiAqIEV4dHJhY3QgYSBTeW50aGV0aWNJbnB1dEV2ZW50IGZvciBgYmVmb3JlSW5wdXRgLCBiYXNlZCBvbiBlaXRoZXIgbmF0aXZlXG4gKiBgdGV4dElucHV0YCBvciBmYWxsYmFjayBiZWhhdmlvci5cbiAqXG4gKiBAcmV0dXJuIHs/b2JqZWN0fSBBIFN5bnRoZXRpY0lucHV0RXZlbnQuXG4gKi9cblxuXG5mdW5jdGlvbiBleHRyYWN0QmVmb3JlSW5wdXRFdmVudChkaXNwYXRjaFF1ZXVlLCBkb21FdmVudE5hbWUsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICB2YXIgY2hhcnM7XG5cbiAgaWYgKGNhblVzZVRleHRJbnB1dEV2ZW50KSB7XG4gICAgY2hhcnMgPSBnZXROYXRpdmVCZWZvcmVJbnB1dENoYXJzKGRvbUV2ZW50TmFtZSwgbmF0aXZlRXZlbnQpO1xuICB9IGVsc2Uge1xuICAgIGNoYXJzID0gZ2V0RmFsbGJhY2tCZWZvcmVJbnB1dENoYXJzKGRvbUV2ZW50TmFtZSwgbmF0aXZlRXZlbnQpO1xuICB9IC8vIElmIG5vIGNoYXJhY3RlcnMgYXJlIGJlaW5nIGluc2VydGVkLCBubyBCZWZvcmVJbnB1dCBldmVudCBzaG91bGRcbiAgLy8gYmUgZmlyZWQuXG5cblxuICBpZiAoIWNoYXJzKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgbGlzdGVuZXJzID0gYWNjdW11bGF0ZVR3b1BoYXNlTGlzdGVuZXJzKHRhcmdldEluc3QsICdvbkJlZm9yZUlucHV0Jyk7XG5cbiAgaWYgKGxpc3RlbmVycy5sZW5ndGggPiAwKSB7XG4gICAgdmFyIGV2ZW50ID0gbmV3IFN5bnRoZXRpY0lucHV0RXZlbnQoJ29uQmVmb3JlSW5wdXQnLCAnYmVmb3JlaW5wdXQnLCBudWxsLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xuICAgIGRpc3BhdGNoUXVldWUucHVzaCh7XG4gICAgICBldmVudDogZXZlbnQsXG4gICAgICBsaXN0ZW5lcnM6IGxpc3RlbmVyc1xuICAgIH0pO1xuICAgIGV2ZW50LmRhdGEgPSBjaGFycztcbiAgfVxufVxuLyoqXG4gKiBDcmVhdGUgYW4gYG9uQmVmb3JlSW5wdXRgIGV2ZW50IHRvIG1hdGNoXG4gKiBodHRwOi8vd3d3LnczLm9yZy9UUi8yMDEzL1dELURPTS1MZXZlbC0zLUV2ZW50cy0yMDEzMTEwNS8jZXZlbnRzLWlucHV0ZXZlbnRzLlxuICpcbiAqIFRoaXMgZXZlbnQgcGx1Z2luIGlzIGJhc2VkIG9uIHRoZSBuYXRpdmUgYHRleHRJbnB1dGAgZXZlbnRcbiAqIGF2YWlsYWJsZSBpbiBDaHJvbWUsIFNhZmFyaSwgT3BlcmEsIGFuZCBJRS4gVGhpcyBldmVudCBmaXJlcyBhZnRlclxuICogYG9uS2V5UHJlc3NgIGFuZCBgb25Db21wb3NpdGlvbkVuZGAsIGJ1dCBiZWZvcmUgYG9uSW5wdXRgLlxuICpcbiAqIGBiZWZvcmVJbnB1dGAgaXMgc3BlYydkIGJ1dCBub3QgaW1wbGVtZW50ZWQgaW4gYW55IGJyb3dzZXJzLCBhbmRcbiAqIHRoZSBgaW5wdXRgIGV2ZW50IGRvZXMgbm90IHByb3ZpZGUgYW55IHVzZWZ1bCBpbmZvcm1hdGlvbiBhYm91dCB3aGF0IGhhc1xuICogYWN0dWFsbHkgYmVlbiBhZGRlZCwgY29udHJhcnkgdG8gdGhlIHNwZWMuIFRodXMsIGB0ZXh0SW5wdXRgIGlzIHRoZSBiZXN0XG4gKiBhdmFpbGFibGUgZXZlbnQgdG8gaWRlbnRpZnkgdGhlIGNoYXJhY3RlcnMgdGhhdCBoYXZlIGFjdHVhbGx5IGJlZW4gaW5zZXJ0ZWRcbiAqIGludG8gdGhlIHRhcmdldCBub2RlLlxuICpcbiAqIFRoaXMgcGx1Z2luIGlzIGFsc28gcmVzcG9uc2libGUgZm9yIGVtaXR0aW5nIGBjb21wb3NpdGlvbmAgZXZlbnRzLCB0aHVzXG4gKiBhbGxvd2luZyB1cyB0byBzaGFyZSBjb21wb3NpdGlvbiBmYWxsYmFjayBjb2RlIGZvciBib3RoIGBiZWZvcmVJbnB1dGAgYW5kXG4gKiBgY29tcG9zaXRpb25gIGV2ZW50IHR5cGVzLlxuICovXG5cblxuZnVuY3Rpb24gZXh0cmFjdEV2ZW50cyhkaXNwYXRjaFF1ZXVlLCBkb21FdmVudE5hbWUsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCwgZXZlbnRTeXN0ZW1GbGFncywgdGFyZ2V0Q29udGFpbmVyKSB7XG4gIGV4dHJhY3RDb21wb3NpdGlvbkV2ZW50KGRpc3BhdGNoUXVldWUsIGRvbUV2ZW50TmFtZSwgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbiAgZXh0cmFjdEJlZm9yZUlucHV0RXZlbnQoZGlzcGF0Y2hRdWV1ZSwgZG9tRXZlbnROYW1lLCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xufVxuXG4vKipcbiAqIEBzZWUgaHR0cDovL3d3dy53aGF0d2cub3JnL3NwZWNzL3dlYi1hcHBzL2N1cnJlbnQtd29yay9tdWx0aXBhZ2UvdGhlLWlucHV0LWVsZW1lbnQuaHRtbCNpbnB1dC10eXBlLWF0dHItc3VtbWFyeVxuICovXG52YXIgc3VwcG9ydGVkSW5wdXRUeXBlcyA9IHtcbiAgY29sb3I6IHRydWUsXG4gIGRhdGU6IHRydWUsXG4gIGRhdGV0aW1lOiB0cnVlLFxuICAnZGF0ZXRpbWUtbG9jYWwnOiB0cnVlLFxuICBlbWFpbDogdHJ1ZSxcbiAgbW9udGg6IHRydWUsXG4gIG51bWJlcjogdHJ1ZSxcbiAgcGFzc3dvcmQ6IHRydWUsXG4gIHJhbmdlOiB0cnVlLFxuICBzZWFyY2g6IHRydWUsXG4gIHRlbDogdHJ1ZSxcbiAgdGV4dDogdHJ1ZSxcbiAgdGltZTogdHJ1ZSxcbiAgdXJsOiB0cnVlLFxuICB3ZWVrOiB0cnVlXG59O1xuXG5mdW5jdGlvbiBpc1RleHRJbnB1dEVsZW1lbnQoZWxlbSkge1xuICB2YXIgbm9kZU5hbWUgPSBlbGVtICYmIGVsZW0ubm9kZU5hbWUgJiYgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuXG4gIGlmIChub2RlTmFtZSA9PT0gJ2lucHV0Jykge1xuICAgIHJldHVybiAhIXN1cHBvcnRlZElucHV0VHlwZXNbZWxlbS50eXBlXTtcbiAgfVxuXG4gIGlmIChub2RlTmFtZSA9PT0gJ3RleHRhcmVhJykge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBhbiBldmVudCBpcyBzdXBwb3J0ZWQgaW4gdGhlIGN1cnJlbnQgZXhlY3V0aW9uIGVudmlyb25tZW50LlxuICpcbiAqIE5PVEU6IFRoaXMgd2lsbCBub3Qgd29yayBjb3JyZWN0bHkgZm9yIG5vbi1nZW5lcmljIGV2ZW50cyBzdWNoIGFzIGBjaGFuZ2VgLFxuICogYHJlc2V0YCwgYGxvYWRgLCBgZXJyb3JgLCBhbmQgYHNlbGVjdGAuXG4gKlxuICogQm9ycm93cyBmcm9tIE1vZGVybml6ci5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gZXZlbnROYW1lU3VmZml4IEV2ZW50IG5hbWUsIGUuZy4gXCJjbGlja1wiLlxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgZXZlbnQgaXMgc3VwcG9ydGVkLlxuICogQGludGVybmFsXG4gKiBAbGljZW5zZSBNb2Rlcm5penIgMy4wLjBwcmUgKEN1c3RvbSBCdWlsZCkgfCBNSVRcbiAqL1xuXG5mdW5jdGlvbiBpc0V2ZW50U3VwcG9ydGVkKGV2ZW50TmFtZVN1ZmZpeCkge1xuICBpZiAoIWNhblVzZURPTSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBldmVudE5hbWUgPSAnb24nICsgZXZlbnROYW1lU3VmZml4O1xuICB2YXIgaXNTdXBwb3J0ZWQgPSAoZXZlbnROYW1lIGluIGRvY3VtZW50KTtcblxuICBpZiAoIWlzU3VwcG9ydGVkKSB7XG4gICAgdmFyIGVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBlbGVtZW50LnNldEF0dHJpYnV0ZShldmVudE5hbWUsICdyZXR1cm47Jyk7XG4gICAgaXNTdXBwb3J0ZWQgPSB0eXBlb2YgZWxlbWVudFtldmVudE5hbWVdID09PSAnZnVuY3Rpb24nO1xuICB9XG5cbiAgcmV0dXJuIGlzU3VwcG9ydGVkO1xufVxuXG5mdW5jdGlvbiByZWdpc3RlckV2ZW50cyQxKCkge1xuICByZWdpc3RlclR3b1BoYXNlRXZlbnQoJ29uQ2hhbmdlJywgWydjaGFuZ2UnLCAnY2xpY2snLCAnZm9jdXNpbicsICdmb2N1c291dCcsICdpbnB1dCcsICdrZXlkb3duJywgJ2tleXVwJywgJ3NlbGVjdGlvbmNoYW5nZSddKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlQW5kQWNjdW11bGF0ZUNoYW5nZUV2ZW50KGRpc3BhdGNoUXVldWUsIGluc3QsIG5hdGl2ZUV2ZW50LCB0YXJnZXQpIHtcbiAgLy8gRmxhZyB0aGlzIGV2ZW50IGxvb3AgYXMgbmVlZGluZyBzdGF0ZSByZXN0b3JlLlxuICBlbnF1ZXVlU3RhdGVSZXN0b3JlKHRhcmdldCk7XG4gIHZhciBsaXN0ZW5lcnMgPSBhY2N1bXVsYXRlVHdvUGhhc2VMaXN0ZW5lcnMoaW5zdCwgJ29uQ2hhbmdlJyk7XG5cbiAgaWYgKGxpc3RlbmVycy5sZW5ndGggPiAwKSB7XG4gICAgdmFyIGV2ZW50ID0gbmV3IFN5bnRoZXRpY0V2ZW50KCdvbkNoYW5nZScsICdjaGFuZ2UnLCBudWxsLCBuYXRpdmVFdmVudCwgdGFyZ2V0KTtcbiAgICBkaXNwYXRjaFF1ZXVlLnB1c2goe1xuICAgICAgZXZlbnQ6IGV2ZW50LFxuICAgICAgbGlzdGVuZXJzOiBsaXN0ZW5lcnNcbiAgICB9KTtcbiAgfVxufVxuLyoqXG4gKiBGb3IgSUUgc2hpbXNcbiAqL1xuXG5cbnZhciBhY3RpdmVFbGVtZW50ID0gbnVsbDtcbnZhciBhY3RpdmVFbGVtZW50SW5zdCA9IG51bGw7XG4vKipcbiAqIFNFQ1RJT046IGhhbmRsZSBgY2hhbmdlYCBldmVudFxuICovXG5cbmZ1bmN0aW9uIHNob3VsZFVzZUNoYW5nZUV2ZW50KGVsZW0pIHtcbiAgdmFyIG5vZGVOYW1lID0gZWxlbS5ub2RlTmFtZSAmJiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG4gIHJldHVybiBub2RlTmFtZSA9PT0gJ3NlbGVjdCcgfHwgbm9kZU5hbWUgPT09ICdpbnB1dCcgJiYgZWxlbS50eXBlID09PSAnZmlsZSc7XG59XG5cbmZ1bmN0aW9uIG1hbnVhbERpc3BhdGNoQ2hhbmdlRXZlbnQobmF0aXZlRXZlbnQpIHtcbiAgdmFyIGRpc3BhdGNoUXVldWUgPSBbXTtcbiAgY3JlYXRlQW5kQWNjdW11bGF0ZUNoYW5nZUV2ZW50KGRpc3BhdGNoUXVldWUsIGFjdGl2ZUVsZW1lbnRJbnN0LCBuYXRpdmVFdmVudCwgZ2V0RXZlbnRUYXJnZXQobmF0aXZlRXZlbnQpKTsgLy8gSWYgY2hhbmdlIGFuZCBwcm9wZXJ0eWNoYW5nZSBidWJibGVkLCB3ZSdkIGp1c3QgYmluZCB0byBpdCBsaWtlIGFsbCB0aGVcbiAgLy8gb3RoZXIgZXZlbnRzIGFuZCBoYXZlIGl0IGdvIHRocm91Z2ggUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLiBTaW5jZSBpdFxuICAvLyBkb2Vzbid0LCB3ZSBtYW51YWxseSBsaXN0ZW4gZm9yIHRoZSBldmVudHMgYW5kIHNvIHdlIGhhdmUgdG8gZW5xdWV1ZSBhbmRcbiAgLy8gcHJvY2VzcyB0aGUgYWJzdHJhY3QgZXZlbnQgbWFudWFsbHkuXG4gIC8vXG4gIC8vIEJhdGNoaW5nIGlzIG5lY2Vzc2FyeSBoZXJlIGluIG9yZGVyIHRvIGVuc3VyZSB0aGF0IGFsbCBldmVudCBoYW5kbGVycyBydW5cbiAgLy8gYmVmb3JlIHRoZSBuZXh0IHJlcmVuZGVyIChpbmNsdWRpbmcgZXZlbnQgaGFuZGxlcnMgYXR0YWNoZWQgdG8gYW5jZXN0b3JcbiAgLy8gZWxlbWVudHMgaW5zdGVhZCBvZiBkaXJlY3RseSBvbiB0aGUgaW5wdXQpLiBXaXRob3V0IHRoaXMsIGNvbnRyb2xsZWRcbiAgLy8gY29tcG9uZW50cyBkb24ndCB3b3JrIHByb3Blcmx5IGluIGNvbmp1bmN0aW9uIHdpdGggZXZlbnQgYnViYmxpbmcgYmVjYXVzZVxuICAvLyB0aGUgY29tcG9uZW50IGlzIHJlcmVuZGVyZWQgYW5kIHRoZSB2YWx1ZSByZXZlcnRlZCBiZWZvcmUgYWxsIHRoZSBldmVudFxuICAvLyBoYW5kbGVycyBjYW4gcnVuLiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy83MDguXG5cbiAgYmF0Y2hlZFVwZGF0ZXMocnVuRXZlbnRJbkJhdGNoLCBkaXNwYXRjaFF1ZXVlKTtcbn1cblxuZnVuY3Rpb24gcnVuRXZlbnRJbkJhdGNoKGRpc3BhdGNoUXVldWUpIHtcbiAgcHJvY2Vzc0Rpc3BhdGNoUXVldWUoZGlzcGF0Y2hRdWV1ZSwgMCk7XG59XG5cbmZ1bmN0aW9uIGdldEluc3RJZlZhbHVlQ2hhbmdlZCh0YXJnZXRJbnN0KSB7XG4gIHZhciB0YXJnZXROb2RlID0gZ2V0Tm9kZUZyb21JbnN0YW5jZSh0YXJnZXRJbnN0KTtcblxuICBpZiAodXBkYXRlVmFsdWVJZkNoYW5nZWQodGFyZ2V0Tm9kZSkpIHtcbiAgICByZXR1cm4gdGFyZ2V0SW5zdDtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRUYXJnZXRJbnN0Rm9yQ2hhbmdlRXZlbnQoZG9tRXZlbnROYW1lLCB0YXJnZXRJbnN0KSB7XG4gIGlmIChkb21FdmVudE5hbWUgPT09ICdjaGFuZ2UnKSB7XG4gICAgcmV0dXJuIHRhcmdldEluc3Q7XG4gIH1cbn1cbi8qKlxuICogU0VDVElPTjogaGFuZGxlIGBpbnB1dGAgZXZlbnRcbiAqL1xuXG5cbnZhciBpc0lucHV0RXZlbnRTdXBwb3J0ZWQgPSBmYWxzZTtcblxuaWYgKGNhblVzZURPTSkge1xuICAvLyBJRTkgY2xhaW1zIHRvIHN1cHBvcnQgdGhlIGlucHV0IGV2ZW50IGJ1dCBmYWlscyB0byB0cmlnZ2VyIGl0IHdoZW5cbiAgLy8gZGVsZXRpbmcgdGV4dCwgc28gd2UgaWdub3JlIGl0cyBpbnB1dCBldmVudHMuXG4gIGlzSW5wdXRFdmVudFN1cHBvcnRlZCA9IGlzRXZlbnRTdXBwb3J0ZWQoJ2lucHV0JykgJiYgKCFkb2N1bWVudC5kb2N1bWVudE1vZGUgfHwgZG9jdW1lbnQuZG9jdW1lbnRNb2RlID4gOSk7XG59XG4vKipcbiAqIChGb3IgSUUgPD05KSBTdGFydHMgdHJhY2tpbmcgcHJvcGVydHljaGFuZ2UgZXZlbnRzIG9uIHRoZSBwYXNzZWQtaW4gZWxlbWVudFxuICogYW5kIG92ZXJyaWRlIHRoZSB2YWx1ZSBwcm9wZXJ0eSBzbyB0aGF0IHdlIGNhbiBkaXN0aW5ndWlzaCB1c2VyIGV2ZW50cyBmcm9tXG4gKiB2YWx1ZSBjaGFuZ2VzIGluIEpTLlxuICovXG5cblxuZnVuY3Rpb24gc3RhcnRXYXRjaGluZ0ZvclZhbHVlQ2hhbmdlKHRhcmdldCwgdGFyZ2V0SW5zdCkge1xuICBhY3RpdmVFbGVtZW50ID0gdGFyZ2V0O1xuICBhY3RpdmVFbGVtZW50SW5zdCA9IHRhcmdldEluc3Q7XG4gIGFjdGl2ZUVsZW1lbnQuYXR0YWNoRXZlbnQoJ29ucHJvcGVydHljaGFuZ2UnLCBoYW5kbGVQcm9wZXJ0eUNoYW5nZSk7XG59XG4vKipcbiAqIChGb3IgSUUgPD05KSBSZW1vdmVzIHRoZSBldmVudCBsaXN0ZW5lcnMgZnJvbSB0aGUgY3VycmVudGx5LXRyYWNrZWQgZWxlbWVudCxcbiAqIGlmIGFueSBleGlzdHMuXG4gKi9cblxuXG5mdW5jdGlvbiBzdG9wV2F0Y2hpbmdGb3JWYWx1ZUNoYW5nZSgpIHtcbiAgaWYgKCFhY3RpdmVFbGVtZW50KSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgYWN0aXZlRWxlbWVudC5kZXRhY2hFdmVudCgnb25wcm9wZXJ0eWNoYW5nZScsIGhhbmRsZVByb3BlcnR5Q2hhbmdlKTtcbiAgYWN0aXZlRWxlbWVudCA9IG51bGw7XG4gIGFjdGl2ZUVsZW1lbnRJbnN0ID0gbnVsbDtcbn1cbi8qKlxuICogKEZvciBJRSA8PTkpIEhhbmRsZXMgYSBwcm9wZXJ0eWNoYW5nZSBldmVudCwgc2VuZGluZyBhIGBjaGFuZ2VgIGV2ZW50IGlmXG4gKiB0aGUgdmFsdWUgb2YgdGhlIGFjdGl2ZSBlbGVtZW50IGhhcyBjaGFuZ2VkLlxuICovXG5cblxuZnVuY3Rpb24gaGFuZGxlUHJvcGVydHlDaGFuZ2UobmF0aXZlRXZlbnQpIHtcbiAgaWYgKG5hdGl2ZUV2ZW50LnByb3BlcnR5TmFtZSAhPT0gJ3ZhbHVlJykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChnZXRJbnN0SWZWYWx1ZUNoYW5nZWQoYWN0aXZlRWxlbWVudEluc3QpKSB7XG4gICAgbWFudWFsRGlzcGF0Y2hDaGFuZ2VFdmVudChuYXRpdmVFdmVudCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaGFuZGxlRXZlbnRzRm9ySW5wdXRFdmVudFBvbHlmaWxsKGRvbUV2ZW50TmFtZSwgdGFyZ2V0LCB0YXJnZXRJbnN0KSB7XG4gIGlmIChkb21FdmVudE5hbWUgPT09ICdmb2N1c2luJykge1xuICAgIC8vIEluIElFOSwgcHJvcGVydHljaGFuZ2UgZmlyZXMgZm9yIG1vc3QgaW5wdXQgZXZlbnRzIGJ1dCBpcyBidWdneSBhbmRcbiAgICAvLyBkb2Vzbid0IGZpcmUgd2hlbiB0ZXh0IGlzIGRlbGV0ZWQsIGJ1dCBjb252ZW5pZW50bHksIHNlbGVjdGlvbmNoYW5nZVxuICAgIC8vIGFwcGVhcnMgdG8gZmlyZSBpbiBhbGwgb2YgdGhlIHJlbWFpbmluZyBjYXNlcyBzbyB3ZSBjYXRjaCB0aG9zZSBhbmRcbiAgICAvLyBmb3J3YXJkIHRoZSBldmVudCBpZiB0aGUgdmFsdWUgaGFzIGNoYW5nZWRcbiAgICAvLyBJbiBlaXRoZXIgY2FzZSwgd2UgZG9uJ3Qgd2FudCB0byBjYWxsIHRoZSBldmVudCBoYW5kbGVyIGlmIHRoZSB2YWx1ZVxuICAgIC8vIGlzIGNoYW5nZWQgZnJvbSBKUyBzbyB3ZSByZWRlZmluZSBhIHNldHRlciBmb3IgYC52YWx1ZWAgdGhhdCB1cGRhdGVzXG4gICAgLy8gb3VyIGFjdGl2ZUVsZW1lbnRWYWx1ZSB2YXJpYWJsZSwgYWxsb3dpbmcgdXMgdG8gaWdub3JlIHRob3NlIGNoYW5nZXNcbiAgICAvL1xuICAgIC8vIHN0b3BXYXRjaGluZygpIHNob3VsZCBiZSBhIG5vb3AgaGVyZSBidXQgd2UgY2FsbCBpdCBqdXN0IGluIGNhc2Ugd2VcbiAgICAvLyBtaXNzZWQgYSBibHVyIGV2ZW50IHNvbWVob3cuXG4gICAgc3RvcFdhdGNoaW5nRm9yVmFsdWVDaGFuZ2UoKTtcbiAgICBzdGFydFdhdGNoaW5nRm9yVmFsdWVDaGFuZ2UodGFyZ2V0LCB0YXJnZXRJbnN0KTtcbiAgfSBlbHNlIGlmIChkb21FdmVudE5hbWUgPT09ICdmb2N1c291dCcpIHtcbiAgICBzdG9wV2F0Y2hpbmdGb3JWYWx1ZUNoYW5nZSgpO1xuICB9XG59IC8vIEZvciBJRTggYW5kIElFOS5cblxuXG5mdW5jdGlvbiBnZXRUYXJnZXRJbnN0Rm9ySW5wdXRFdmVudFBvbHlmaWxsKGRvbUV2ZW50TmFtZSwgdGFyZ2V0SW5zdCkge1xuICBpZiAoZG9tRXZlbnROYW1lID09PSAnc2VsZWN0aW9uY2hhbmdlJyB8fCBkb21FdmVudE5hbWUgPT09ICdrZXl1cCcgfHwgZG9tRXZlbnROYW1lID09PSAna2V5ZG93bicpIHtcbiAgICAvLyBPbiB0aGUgc2VsZWN0aW9uY2hhbmdlIGV2ZW50LCB0aGUgdGFyZ2V0IGlzIGp1c3QgZG9jdW1lbnQgd2hpY2ggaXNuJ3RcbiAgICAvLyBoZWxwZnVsIGZvciB1cyBzbyBqdXN0IGNoZWNrIGFjdGl2ZUVsZW1lbnQgaW5zdGVhZC5cbiAgICAvL1xuICAgIC8vIDk5JSBvZiB0aGUgdGltZSwga2V5ZG93biBhbmQga2V5dXAgYXJlbid0IG5lY2Vzc2FyeS4gSUU4IGZhaWxzIHRvIGZpcmVcbiAgICAvLyBwcm9wZXJ0eWNoYW5nZSBvbiB0aGUgZmlyc3QgaW5wdXQgZXZlbnQgYWZ0ZXIgc2V0dGluZyBgdmFsdWVgIGZyb20gYVxuICAgIC8vIHNjcmlwdCBhbmQgZmlyZXMgb25seSBrZXlkb3duLCBrZXlwcmVzcywga2V5dXAuIENhdGNoaW5nIGtleXVwIHVzdWFsbHlcbiAgICAvLyBnZXRzIGl0IGFuZCBjYXRjaGluZyBrZXlkb3duIGxldHMgdXMgZmlyZSBhbiBldmVudCBmb3IgdGhlIGZpcnN0XG4gICAgLy8ga2V5c3Ryb2tlIGlmIHVzZXIgZG9lcyBhIGtleSByZXBlYXQgKGl0J2xsIGJlIGEgbGl0dGxlIGRlbGF5ZWQ6IHJpZ2h0XG4gICAgLy8gYmVmb3JlIHRoZSBzZWNvbmQga2V5c3Ryb2tlKS4gT3RoZXIgaW5wdXQgbWV0aG9kcyAoZS5nLiwgcGFzdGUpIHNlZW0gdG9cbiAgICAvLyBmaXJlIHNlbGVjdGlvbmNoYW5nZSBub3JtYWxseS5cbiAgICByZXR1cm4gZ2V0SW5zdElmVmFsdWVDaGFuZ2VkKGFjdGl2ZUVsZW1lbnRJbnN0KTtcbiAgfVxufVxuLyoqXG4gKiBTRUNUSU9OOiBoYW5kbGUgYGNsaWNrYCBldmVudFxuICovXG5cblxuZnVuY3Rpb24gc2hvdWxkVXNlQ2xpY2tFdmVudChlbGVtKSB7XG4gIC8vIFVzZSB0aGUgYGNsaWNrYCBldmVudCB0byBkZXRlY3QgY2hhbmdlcyB0byBjaGVja2JveCBhbmQgcmFkaW8gaW5wdXRzLlxuICAvLyBUaGlzIGFwcHJvYWNoIHdvcmtzIGFjcm9zcyBhbGwgYnJvd3NlcnMsIHdoZXJlYXMgYGNoYW5nZWAgZG9lcyBub3QgZmlyZVxuICAvLyB1bnRpbCBgYmx1cmAgaW4gSUU4LlxuICB2YXIgbm9kZU5hbWUgPSBlbGVtLm5vZGVOYW1lO1xuICByZXR1cm4gbm9kZU5hbWUgJiYgbm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ2lucHV0JyAmJiAoZWxlbS50eXBlID09PSAnY2hlY2tib3gnIHx8IGVsZW0udHlwZSA9PT0gJ3JhZGlvJyk7XG59XG5cbmZ1bmN0aW9uIGdldFRhcmdldEluc3RGb3JDbGlja0V2ZW50KGRvbUV2ZW50TmFtZSwgdGFyZ2V0SW5zdCkge1xuICBpZiAoZG9tRXZlbnROYW1lID09PSAnY2xpY2snKSB7XG4gICAgcmV0dXJuIGdldEluc3RJZlZhbHVlQ2hhbmdlZCh0YXJnZXRJbnN0KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRUYXJnZXRJbnN0Rm9ySW5wdXRPckNoYW5nZUV2ZW50KGRvbUV2ZW50TmFtZSwgdGFyZ2V0SW5zdCkge1xuICBpZiAoZG9tRXZlbnROYW1lID09PSAnaW5wdXQnIHx8IGRvbUV2ZW50TmFtZSA9PT0gJ2NoYW5nZScpIHtcbiAgICByZXR1cm4gZ2V0SW5zdElmVmFsdWVDaGFuZ2VkKHRhcmdldEluc3QpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGhhbmRsZUNvbnRyb2xsZWRJbnB1dEJsdXIobm9kZSkge1xuICB2YXIgc3RhdGUgPSBub2RlLl93cmFwcGVyU3RhdGU7XG5cbiAgaWYgKCFzdGF0ZSB8fCAhc3RhdGUuY29udHJvbGxlZCB8fCBub2RlLnR5cGUgIT09ICdudW1iZXInKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAge1xuICAgIC8vIElmIGNvbnRyb2xsZWQsIGFzc2lnbiB0aGUgdmFsdWUgYXR0cmlidXRlIHRvIHRoZSBjdXJyZW50IHZhbHVlIG9uIGJsdXJcbiAgICBzZXREZWZhdWx0VmFsdWUobm9kZSwgJ251bWJlcicsIG5vZGUudmFsdWUpO1xuICB9XG59XG4vKipcbiAqIFRoaXMgcGx1Z2luIGNyZWF0ZXMgYW4gYG9uQ2hhbmdlYCBldmVudCB0aGF0IG5vcm1hbGl6ZXMgY2hhbmdlIGV2ZW50c1xuICogYWNyb3NzIGZvcm0gZWxlbWVudHMuIFRoaXMgZXZlbnQgZmlyZXMgYXQgYSB0aW1lIHdoZW4gaXQncyBwb3NzaWJsZSB0b1xuICogY2hhbmdlIHRoZSBlbGVtZW50J3MgdmFsdWUgd2l0aG91dCBzZWVpbmcgYSBmbGlja2VyLlxuICpcbiAqIFN1cHBvcnRlZCBlbGVtZW50cyBhcmU6XG4gKiAtIGlucHV0IChzZWUgYGlzVGV4dElucHV0RWxlbWVudGApXG4gKiAtIHRleHRhcmVhXG4gKiAtIHNlbGVjdFxuICovXG5cblxuZnVuY3Rpb24gZXh0cmFjdEV2ZW50cyQxKGRpc3BhdGNoUXVldWUsIGRvbUV2ZW50TmFtZSwgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0LCBldmVudFN5c3RlbUZsYWdzLCB0YXJnZXRDb250YWluZXIpIHtcbiAgdmFyIHRhcmdldE5vZGUgPSB0YXJnZXRJbnN0ID8gZ2V0Tm9kZUZyb21JbnN0YW5jZSh0YXJnZXRJbnN0KSA6IHdpbmRvdztcbiAgdmFyIGdldFRhcmdldEluc3RGdW5jLCBoYW5kbGVFdmVudEZ1bmM7XG5cbiAgaWYgKHNob3VsZFVzZUNoYW5nZUV2ZW50KHRhcmdldE5vZGUpKSB7XG4gICAgZ2V0VGFyZ2V0SW5zdEZ1bmMgPSBnZXRUYXJnZXRJbnN0Rm9yQ2hhbmdlRXZlbnQ7XG4gIH0gZWxzZSBpZiAoaXNUZXh0SW5wdXRFbGVtZW50KHRhcmdldE5vZGUpKSB7XG4gICAgaWYgKGlzSW5wdXRFdmVudFN1cHBvcnRlZCkge1xuICAgICAgZ2V0VGFyZ2V0SW5zdEZ1bmMgPSBnZXRUYXJnZXRJbnN0Rm9ySW5wdXRPckNoYW5nZUV2ZW50O1xuICAgIH0gZWxzZSB7XG4gICAgICBnZXRUYXJnZXRJbnN0RnVuYyA9IGdldFRhcmdldEluc3RGb3JJbnB1dEV2ZW50UG9seWZpbGw7XG4gICAgICBoYW5kbGVFdmVudEZ1bmMgPSBoYW5kbGVFdmVudHNGb3JJbnB1dEV2ZW50UG9seWZpbGw7XG4gICAgfVxuICB9IGVsc2UgaWYgKHNob3VsZFVzZUNsaWNrRXZlbnQodGFyZ2V0Tm9kZSkpIHtcbiAgICBnZXRUYXJnZXRJbnN0RnVuYyA9IGdldFRhcmdldEluc3RGb3JDbGlja0V2ZW50O1xuICB9XG5cbiAgaWYgKGdldFRhcmdldEluc3RGdW5jKSB7XG4gICAgdmFyIGluc3QgPSBnZXRUYXJnZXRJbnN0RnVuYyhkb21FdmVudE5hbWUsIHRhcmdldEluc3QpO1xuXG4gICAgaWYgKGluc3QpIHtcbiAgICAgIGNyZWF0ZUFuZEFjY3VtdWxhdGVDaGFuZ2VFdmVudChkaXNwYXRjaFF1ZXVlLCBpbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxuXG4gIGlmIChoYW5kbGVFdmVudEZ1bmMpIHtcbiAgICBoYW5kbGVFdmVudEZ1bmMoZG9tRXZlbnROYW1lLCB0YXJnZXROb2RlLCB0YXJnZXRJbnN0KTtcbiAgfSAvLyBXaGVuIGJsdXJyaW5nLCBzZXQgdGhlIHZhbHVlIGF0dHJpYnV0ZSBmb3IgbnVtYmVyIGlucHV0c1xuXG5cbiAgaWYgKGRvbUV2ZW50TmFtZSA9PT0gJ2ZvY3Vzb3V0Jykge1xuICAgIGhhbmRsZUNvbnRyb2xsZWRJbnB1dEJsdXIodGFyZ2V0Tm9kZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVnaXN0ZXJFdmVudHMkMigpIHtcbiAgcmVnaXN0ZXJEaXJlY3RFdmVudCgnb25Nb3VzZUVudGVyJywgWydtb3VzZW91dCcsICdtb3VzZW92ZXInXSk7XG4gIHJlZ2lzdGVyRGlyZWN0RXZlbnQoJ29uTW91c2VMZWF2ZScsIFsnbW91c2VvdXQnLCAnbW91c2VvdmVyJ10pO1xuICByZWdpc3RlckRpcmVjdEV2ZW50KCdvblBvaW50ZXJFbnRlcicsIFsncG9pbnRlcm91dCcsICdwb2ludGVyb3ZlciddKTtcbiAgcmVnaXN0ZXJEaXJlY3RFdmVudCgnb25Qb2ludGVyTGVhdmUnLCBbJ3BvaW50ZXJvdXQnLCAncG9pbnRlcm92ZXInXSk7XG59XG4vKipcbiAqIEZvciBhbG1vc3QgZXZlcnkgaW50ZXJhY3Rpb24gd2UgY2FyZSBhYm91dCwgdGhlcmUgd2lsbCBiZSBib3RoIGEgdG9wLWxldmVsXG4gKiBgbW91c2VvdmVyYCBhbmQgYG1vdXNlb3V0YCBldmVudCB0aGF0IG9jY3Vycy4gT25seSB1c2UgYG1vdXNlb3V0YCBzbyB0aGF0XG4gKiB3ZSBkbyBub3QgZXh0cmFjdCBkdXBsaWNhdGUgZXZlbnRzLiBIb3dldmVyLCBtb3ZpbmcgdGhlIG1vdXNlIGludG8gdGhlXG4gKiBicm93c2VyIGZyb20gb3V0c2lkZSB3aWxsIG5vdCBmaXJlIGEgYG1vdXNlb3V0YCBldmVudC4gSW4gdGhpcyBjYXNlLCB3ZSB1c2VcbiAqIHRoZSBgbW91c2VvdmVyYCB0b3AtbGV2ZWwgZXZlbnQuXG4gKi9cblxuXG5mdW5jdGlvbiBleHRyYWN0RXZlbnRzJDIoZGlzcGF0Y2hRdWV1ZSwgZG9tRXZlbnROYW1lLCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQsIGV2ZW50U3lzdGVtRmxhZ3MsIHRhcmdldENvbnRhaW5lcikge1xuICB2YXIgaXNPdmVyRXZlbnQgPSBkb21FdmVudE5hbWUgPT09ICdtb3VzZW92ZXInIHx8IGRvbUV2ZW50TmFtZSA9PT0gJ3BvaW50ZXJvdmVyJztcbiAgdmFyIGlzT3V0RXZlbnQgPSBkb21FdmVudE5hbWUgPT09ICdtb3VzZW91dCcgfHwgZG9tRXZlbnROYW1lID09PSAncG9pbnRlcm91dCc7XG5cbiAgaWYgKGlzT3ZlckV2ZW50ICYmIChldmVudFN5c3RlbUZsYWdzICYgSVNfUkVQTEFZRUQpID09PSAwKSB7XG4gICAgLy8gSWYgdGhpcyBpcyBhbiBvdmVyIGV2ZW50IHdpdGggYSB0YXJnZXQsIHdlIG1pZ2h0IGhhdmUgYWxyZWFkeSBkaXNwYXRjaGVkXG4gICAgLy8gdGhlIGV2ZW50IGluIHRoZSBvdXQgZXZlbnQgb2YgdGhlIG90aGVyIHRhcmdldC4gSWYgdGhpcyBpcyByZXBsYXllZCxcbiAgICAvLyB0aGVuIGl0J3MgYmVjYXVzZSB3ZSBjb3VsZG4ndCBkaXNwYXRjaCBhZ2FpbnN0IHRoaXMgdGFyZ2V0IHByZXZpb3VzbHlcbiAgICAvLyBzbyB3ZSBoYXZlIHRvIGRvIGl0IG5vdyBpbnN0ZWFkLlxuICAgIHZhciByZWxhdGVkID0gbmF0aXZlRXZlbnQucmVsYXRlZFRhcmdldCB8fCBuYXRpdmVFdmVudC5mcm9tRWxlbWVudDtcblxuICAgIGlmIChyZWxhdGVkKSB7XG4gICAgICAvLyBJZiB0aGUgcmVsYXRlZCBub2RlIGlzIG1hbmFnZWQgYnkgUmVhY3QsIHdlIGNhbiBhc3N1bWUgdGhhdCB3ZSBoYXZlXG4gICAgICAvLyBhbHJlYWR5IGRpc3BhdGNoZWQgdGhlIGNvcnJlc3BvbmRpbmcgZXZlbnRzIGR1cmluZyBpdHMgbW91c2VvdXQuXG4gICAgICBpZiAoZ2V0Q2xvc2VzdEluc3RhbmNlRnJvbU5vZGUocmVsYXRlZCkgfHwgaXNDb250YWluZXJNYXJrZWRBc1Jvb3QocmVsYXRlZCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmICghaXNPdXRFdmVudCAmJiAhaXNPdmVyRXZlbnQpIHtcbiAgICAvLyBNdXN0IG5vdCBiZSBhIG1vdXNlIG9yIHBvaW50ZXIgaW4gb3Igb3V0IC0gaWdub3JpbmcuXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIHdpbjsgLy8gVE9ETzogd2h5IGlzIHRoaXMgbnVsbGFibGUgaW4gdGhlIHR5cGVzIGJ1dCB3ZSByZWFkIGZyb20gaXQ/XG5cbiAgaWYgKG5hdGl2ZUV2ZW50VGFyZ2V0LndpbmRvdyA9PT0gbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgICAvLyBgbmF0aXZlRXZlbnRUYXJnZXRgIGlzIHByb2JhYmx5IGEgd2luZG93IG9iamVjdC5cbiAgICB3aW4gPSBuYXRpdmVFdmVudFRhcmdldDtcbiAgfSBlbHNlIHtcbiAgICAvLyBUT0RPOiBGaWd1cmUgb3V0IHdoeSBgb3duZXJEb2N1bWVudGAgaXMgc29tZXRpbWVzIHVuZGVmaW5lZCBpbiBJRTguXG4gICAgdmFyIGRvYyA9IG5hdGl2ZUV2ZW50VGFyZ2V0Lm93bmVyRG9jdW1lbnQ7XG5cbiAgICBpZiAoZG9jKSB7XG4gICAgICB3aW4gPSBkb2MuZGVmYXVsdFZpZXcgfHwgZG9jLnBhcmVudFdpbmRvdztcbiAgICB9IGVsc2Uge1xuICAgICAgd2luID0gd2luZG93O1xuICAgIH1cbiAgfVxuXG4gIHZhciBmcm9tO1xuICB2YXIgdG87XG5cbiAgaWYgKGlzT3V0RXZlbnQpIHtcbiAgICB2YXIgX3JlbGF0ZWQgPSBuYXRpdmVFdmVudC5yZWxhdGVkVGFyZ2V0IHx8IG5hdGl2ZUV2ZW50LnRvRWxlbWVudDtcblxuICAgIGZyb20gPSB0YXJnZXRJbnN0O1xuICAgIHRvID0gX3JlbGF0ZWQgPyBnZXRDbG9zZXN0SW5zdGFuY2VGcm9tTm9kZShfcmVsYXRlZCkgOiBudWxsO1xuXG4gICAgaWYgKHRvICE9PSBudWxsKSB7XG4gICAgICB2YXIgbmVhcmVzdE1vdW50ZWQgPSBnZXROZWFyZXN0TW91bnRlZEZpYmVyKHRvKTtcblxuICAgICAgaWYgKHRvICE9PSBuZWFyZXN0TW91bnRlZCB8fCB0by50YWcgIT09IEhvc3RDb21wb25lbnQgJiYgdG8udGFnICE9PSBIb3N0VGV4dCkge1xuICAgICAgICB0byA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIE1vdmluZyB0byBhIG5vZGUgZnJvbSBvdXRzaWRlIHRoZSB3aW5kb3cuXG4gICAgZnJvbSA9IG51bGw7XG4gICAgdG8gPSB0YXJnZXRJbnN0O1xuICB9XG5cbiAgaWYgKGZyb20gPT09IHRvKSB7XG4gICAgLy8gTm90aGluZyBwZXJ0YWlucyB0byBvdXIgbWFuYWdlZCBjb21wb25lbnRzLlxuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBTeW50aGV0aWNFdmVudEN0b3IgPSBTeW50aGV0aWNNb3VzZUV2ZW50O1xuICB2YXIgbGVhdmVFdmVudFR5cGUgPSAnb25Nb3VzZUxlYXZlJztcbiAgdmFyIGVudGVyRXZlbnRUeXBlID0gJ29uTW91c2VFbnRlcic7XG4gIHZhciBldmVudFR5cGVQcmVmaXggPSAnbW91c2UnO1xuXG4gIGlmIChkb21FdmVudE5hbWUgPT09ICdwb2ludGVyb3V0JyB8fCBkb21FdmVudE5hbWUgPT09ICdwb2ludGVyb3ZlcicpIHtcbiAgICBTeW50aGV0aWNFdmVudEN0b3IgPSBTeW50aGV0aWNQb2ludGVyRXZlbnQ7XG4gICAgbGVhdmVFdmVudFR5cGUgPSAnb25Qb2ludGVyTGVhdmUnO1xuICAgIGVudGVyRXZlbnRUeXBlID0gJ29uUG9pbnRlckVudGVyJztcbiAgICBldmVudFR5cGVQcmVmaXggPSAncG9pbnRlcic7XG4gIH1cblxuICB2YXIgZnJvbU5vZGUgPSBmcm9tID09IG51bGwgPyB3aW4gOiBnZXROb2RlRnJvbUluc3RhbmNlKGZyb20pO1xuICB2YXIgdG9Ob2RlID0gdG8gPT0gbnVsbCA/IHdpbiA6IGdldE5vZGVGcm9tSW5zdGFuY2UodG8pO1xuICB2YXIgbGVhdmUgPSBuZXcgU3ludGhldGljRXZlbnRDdG9yKGxlYXZlRXZlbnRUeXBlLCBldmVudFR5cGVQcmVmaXggKyAnbGVhdmUnLCBmcm9tLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xuICBsZWF2ZS50YXJnZXQgPSBmcm9tTm9kZTtcbiAgbGVhdmUucmVsYXRlZFRhcmdldCA9IHRvTm9kZTtcbiAgdmFyIGVudGVyID0gbnVsbDsgLy8gV2Ugc2hvdWxkIG9ubHkgcHJvY2VzcyB0aGlzIG5hdGl2ZUV2ZW50IGlmIHdlIGFyZSBwcm9jZXNzaW5nXG4gIC8vIHRoZSBmaXJzdCBhbmNlc3Rvci4gTmV4dCB0aW1lLCB3ZSB3aWxsIGlnbm9yZSB0aGUgZXZlbnQuXG5cbiAgdmFyIG5hdGl2ZVRhcmdldEluc3QgPSBnZXRDbG9zZXN0SW5zdGFuY2VGcm9tTm9kZShuYXRpdmVFdmVudFRhcmdldCk7XG5cbiAgaWYgKG5hdGl2ZVRhcmdldEluc3QgPT09IHRhcmdldEluc3QpIHtcbiAgICB2YXIgZW50ZXJFdmVudCA9IG5ldyBTeW50aGV0aWNFdmVudEN0b3IoZW50ZXJFdmVudFR5cGUsIGV2ZW50VHlwZVByZWZpeCArICdlbnRlcicsIHRvLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xuICAgIGVudGVyRXZlbnQudGFyZ2V0ID0gdG9Ob2RlO1xuICAgIGVudGVyRXZlbnQucmVsYXRlZFRhcmdldCA9IGZyb21Ob2RlO1xuICAgIGVudGVyID0gZW50ZXJFdmVudDtcbiAgfVxuXG4gIGFjY3VtdWxhdGVFbnRlckxlYXZlVHdvUGhhc2VMaXN0ZW5lcnMoZGlzcGF0Y2hRdWV1ZSwgbGVhdmUsIGVudGVyLCBmcm9tLCB0byk7XG59XG5cbi8qKlxuICogaW5saW5lZCBPYmplY3QuaXMgcG9seWZpbGwgdG8gYXZvaWQgcmVxdWlyaW5nIGNvbnN1bWVycyBzaGlwIHRoZWlyIG93blxuICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvT2JqZWN0L2lzXG4gKi9cbmZ1bmN0aW9uIGlzKHgsIHkpIHtcbiAgcmV0dXJuIHggPT09IHkgJiYgKHggIT09IDAgfHwgMSAvIHggPT09IDEgLyB5KSB8fCB4ICE9PSB4ICYmIHkgIT09IHkgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1zZWxmLWNvbXBhcmVcbiAgO1xufVxuXG52YXIgb2JqZWN0SXMgPSB0eXBlb2YgT2JqZWN0LmlzID09PSAnZnVuY3Rpb24nID8gT2JqZWN0LmlzIDogaXM7XG5cbnZhciBoYXNPd25Qcm9wZXJ0eSQyID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbi8qKlxuICogUGVyZm9ybXMgZXF1YWxpdHkgYnkgaXRlcmF0aW5nIHRocm91Z2gga2V5cyBvbiBhbiBvYmplY3QgYW5kIHJldHVybmluZyBmYWxzZVxuICogd2hlbiBhbnkga2V5IGhhcyB2YWx1ZXMgd2hpY2ggYXJlIG5vdCBzdHJpY3RseSBlcXVhbCBiZXR3ZWVuIHRoZSBhcmd1bWVudHMuXG4gKiBSZXR1cm5zIHRydWUgd2hlbiB0aGUgdmFsdWVzIG9mIGFsbCBrZXlzIGFyZSBzdHJpY3RseSBlcXVhbC5cbiAqL1xuXG5mdW5jdGlvbiBzaGFsbG93RXF1YWwob2JqQSwgb2JqQikge1xuICBpZiAob2JqZWN0SXMob2JqQSwgb2JqQikpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmICh0eXBlb2Ygb2JqQSAhPT0gJ29iamVjdCcgfHwgb2JqQSA9PT0gbnVsbCB8fCB0eXBlb2Ygb2JqQiAhPT0gJ29iamVjdCcgfHwgb2JqQiA9PT0gbnVsbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBrZXlzQSA9IE9iamVjdC5rZXlzKG9iakEpO1xuICB2YXIga2V5c0IgPSBPYmplY3Qua2V5cyhvYmpCKTtcblxuICBpZiAoa2V5c0EubGVuZ3RoICE9PSBrZXlzQi5sZW5ndGgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0gLy8gVGVzdCBmb3IgQSdzIGtleXMgZGlmZmVyZW50IGZyb20gQi5cblxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwga2V5c0EubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoIWhhc093blByb3BlcnR5JDIuY2FsbChvYmpCLCBrZXlzQVtpXSkgfHwgIW9iamVjdElzKG9iakFba2V5c0FbaV1dLCBvYmpCW2tleXNBW2ldXSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuLyoqXG4gKiBHaXZlbiBhbnkgbm9kZSByZXR1cm4gdGhlIGZpcnN0IGxlYWYgbm9kZSB3aXRob3V0IGNoaWxkcmVuLlxuICpcbiAqIEBwYXJhbSB7RE9NRWxlbWVudHxET01UZXh0Tm9kZX0gbm9kZVxuICogQHJldHVybiB7RE9NRWxlbWVudHxET01UZXh0Tm9kZX1cbiAqL1xuXG5mdW5jdGlvbiBnZXRMZWFmTm9kZShub2RlKSB7XG4gIHdoaWxlIChub2RlICYmIG5vZGUuZmlyc3RDaGlsZCkge1xuICAgIG5vZGUgPSBub2RlLmZpcnN0Q2hpbGQ7XG4gIH1cblxuICByZXR1cm4gbm9kZTtcbn1cbi8qKlxuICogR2V0IHRoZSBuZXh0IHNpYmxpbmcgd2l0aGluIGEgY29udGFpbmVyLiBUaGlzIHdpbGwgd2FsayB1cCB0aGVcbiAqIERPTSBpZiBhIG5vZGUncyBzaWJsaW5ncyBoYXZlIGJlZW4gZXhoYXVzdGVkLlxuICpcbiAqIEBwYXJhbSB7RE9NRWxlbWVudHxET01UZXh0Tm9kZX0gbm9kZVxuICogQHJldHVybiB7P0RPTUVsZW1lbnR8RE9NVGV4dE5vZGV9XG4gKi9cblxuXG5mdW5jdGlvbiBnZXRTaWJsaW5nTm9kZShub2RlKSB7XG4gIHdoaWxlIChub2RlKSB7XG4gICAgaWYgKG5vZGUubmV4dFNpYmxpbmcpIHtcbiAgICAgIHJldHVybiBub2RlLm5leHRTaWJsaW5nO1xuICAgIH1cblxuICAgIG5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG4gIH1cbn1cbi8qKlxuICogR2V0IG9iamVjdCBkZXNjcmliaW5nIHRoZSBub2RlcyB3aGljaCBjb250YWluIGNoYXJhY3RlcnMgYXQgb2Zmc2V0LlxuICpcbiAqIEBwYXJhbSB7RE9NRWxlbWVudHxET01UZXh0Tm9kZX0gcm9vdFxuICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldFxuICogQHJldHVybiB7P29iamVjdH1cbiAqL1xuXG5cbmZ1bmN0aW9uIGdldE5vZGVGb3JDaGFyYWN0ZXJPZmZzZXQocm9vdCwgb2Zmc2V0KSB7XG4gIHZhciBub2RlID0gZ2V0TGVhZk5vZGUocm9vdCk7XG4gIHZhciBub2RlU3RhcnQgPSAwO1xuICB2YXIgbm9kZUVuZCA9IDA7XG5cbiAgd2hpbGUgKG5vZGUpIHtcbiAgICBpZiAobm9kZS5ub2RlVHlwZSA9PT0gVEVYVF9OT0RFKSB7XG4gICAgICBub2RlRW5kID0gbm9kZVN0YXJ0ICsgbm9kZS50ZXh0Q29udGVudC5sZW5ndGg7XG5cbiAgICAgIGlmIChub2RlU3RhcnQgPD0gb2Zmc2V0ICYmIG5vZGVFbmQgPj0gb2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbm9kZTogbm9kZSxcbiAgICAgICAgICBvZmZzZXQ6IG9mZnNldCAtIG5vZGVTdGFydFxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICBub2RlU3RhcnQgPSBub2RlRW5kO1xuICAgIH1cblxuICAgIG5vZGUgPSBnZXRMZWFmTm9kZShnZXRTaWJsaW5nTm9kZShub2RlKSk7XG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR9IG91dGVyTm9kZVxuICogQHJldHVybiB7P29iamVjdH1cbiAqL1xuXG5mdW5jdGlvbiBnZXRPZmZzZXRzKG91dGVyTm9kZSkge1xuICB2YXIgb3duZXJEb2N1bWVudCA9IG91dGVyTm9kZS5vd25lckRvY3VtZW50O1xuICB2YXIgd2luID0gb3duZXJEb2N1bWVudCAmJiBvd25lckRvY3VtZW50LmRlZmF1bHRWaWV3IHx8IHdpbmRvdztcbiAgdmFyIHNlbGVjdGlvbiA9IHdpbi5nZXRTZWxlY3Rpb24gJiYgd2luLmdldFNlbGVjdGlvbigpO1xuXG4gIGlmICghc2VsZWN0aW9uIHx8IHNlbGVjdGlvbi5yYW5nZUNvdW50ID09PSAwKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgYW5jaG9yTm9kZSA9IHNlbGVjdGlvbi5hbmNob3JOb2RlLFxuICAgICAgYW5jaG9yT2Zmc2V0ID0gc2VsZWN0aW9uLmFuY2hvck9mZnNldCxcbiAgICAgIGZvY3VzTm9kZSA9IHNlbGVjdGlvbi5mb2N1c05vZGUsXG4gICAgICBmb2N1c09mZnNldCA9IHNlbGVjdGlvbi5mb2N1c09mZnNldDsgLy8gSW4gRmlyZWZveCwgYW5jaG9yTm9kZSBhbmQgZm9jdXNOb2RlIGNhbiBiZSBcImFub255bW91cyBkaXZzXCIsIGUuZy4gdGhlXG4gIC8vIHVwL2Rvd24gYnV0dG9ucyBvbiBhbiA8aW5wdXQgdHlwZT1cIm51bWJlclwiPi4gQW5vbnltb3VzIGRpdnMgZG8gbm90IHNlZW0gdG9cbiAgLy8gZXhwb3NlIHByb3BlcnRpZXMsIHRyaWdnZXJpbmcgYSBcIlBlcm1pc3Npb24gZGVuaWVkIGVycm9yXCIgaWYgYW55IG9mIGl0c1xuICAvLyBwcm9wZXJ0aWVzIGFyZSBhY2Nlc3NlZC4gVGhlIG9ubHkgc2VlbWluZ2x5IHBvc3NpYmxlIHdheSB0byBhdm9pZCBlcnJvcmluZ1xuICAvLyBpcyB0byBhY2Nlc3MgYSBwcm9wZXJ0eSB0aGF0IHR5cGljYWxseSB3b3JrcyBmb3Igbm9uLWFub255bW91cyBkaXZzIGFuZFxuICAvLyBjYXRjaCBhbnkgZXJyb3IgdGhhdCBtYXkgb3RoZXJ3aXNlIGFyaXNlLiBTZWVcbiAgLy8gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MjA4NDI3XG5cbiAgdHJ5IHtcbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby11bnVzZWQtZXhwcmVzc2lvbnMgKi9cbiAgICBhbmNob3JOb2RlLm5vZGVUeXBlO1xuICAgIGZvY3VzTm9kZS5ub2RlVHlwZTtcbiAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLXVudXNlZC1leHByZXNzaW9ucyAqL1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICByZXR1cm4gZ2V0TW9kZXJuT2Zmc2V0c0Zyb21Qb2ludHMob3V0ZXJOb2RlLCBhbmNob3JOb2RlLCBhbmNob3JPZmZzZXQsIGZvY3VzTm9kZSwgZm9jdXNPZmZzZXQpO1xufVxuLyoqXG4gKiBSZXR1cm5zIHtzdGFydCwgZW5kfSB3aGVyZSBgc3RhcnRgIGlzIHRoZSBjaGFyYWN0ZXIvY29kZXBvaW50IGluZGV4IG9mXG4gKiAoYW5jaG9yTm9kZSwgYW5jaG9yT2Zmc2V0KSB3aXRoaW4gdGhlIHRleHRDb250ZW50IG9mIGBvdXRlck5vZGVgLCBhbmRcbiAqIGBlbmRgIGlzIHRoZSBpbmRleCBvZiAoZm9jdXNOb2RlLCBmb2N1c09mZnNldCkuXG4gKlxuICogUmV0dXJucyBudWxsIGlmIHlvdSBwYXNzIGluIGdhcmJhZ2UgaW5wdXQgYnV0IHdlIHNob3VsZCBwcm9iYWJseSBqdXN0IGNyYXNoLlxuICpcbiAqIEV4cG9ydGVkIG9ubHkgZm9yIHRlc3RpbmcuXG4gKi9cblxuZnVuY3Rpb24gZ2V0TW9kZXJuT2Zmc2V0c0Zyb21Qb2ludHMob3V0ZXJOb2RlLCBhbmNob3JOb2RlLCBhbmNob3JPZmZzZXQsIGZvY3VzTm9kZSwgZm9jdXNPZmZzZXQpIHtcbiAgdmFyIGxlbmd0aCA9IDA7XG4gIHZhciBzdGFydCA9IC0xO1xuICB2YXIgZW5kID0gLTE7XG4gIHZhciBpbmRleFdpdGhpbkFuY2hvciA9IDA7XG4gIHZhciBpbmRleFdpdGhpbkZvY3VzID0gMDtcbiAgdmFyIG5vZGUgPSBvdXRlck5vZGU7XG4gIHZhciBwYXJlbnROb2RlID0gbnVsbDtcblxuICBvdXRlcjogd2hpbGUgKHRydWUpIHtcbiAgICB2YXIgbmV4dCA9IG51bGw7XG5cbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgaWYgKG5vZGUgPT09IGFuY2hvck5vZGUgJiYgKGFuY2hvck9mZnNldCA9PT0gMCB8fCBub2RlLm5vZGVUeXBlID09PSBURVhUX05PREUpKSB7XG4gICAgICAgIHN0YXJ0ID0gbGVuZ3RoICsgYW5jaG9yT2Zmc2V0O1xuICAgICAgfVxuXG4gICAgICBpZiAobm9kZSA9PT0gZm9jdXNOb2RlICYmIChmb2N1c09mZnNldCA9PT0gMCB8fCBub2RlLm5vZGVUeXBlID09PSBURVhUX05PREUpKSB7XG4gICAgICAgIGVuZCA9IGxlbmd0aCArIGZvY3VzT2Zmc2V0O1xuICAgICAgfVxuXG4gICAgICBpZiAobm9kZS5ub2RlVHlwZSA9PT0gVEVYVF9OT0RFKSB7XG4gICAgICAgIGxlbmd0aCArPSBub2RlLm5vZGVWYWx1ZS5sZW5ndGg7XG4gICAgICB9XG5cbiAgICAgIGlmICgobmV4dCA9IG5vZGUuZmlyc3RDaGlsZCkgPT09IG51bGwpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9IC8vIE1vdmluZyBmcm9tIGBub2RlYCB0byBpdHMgZmlyc3QgY2hpbGQgYG5leHRgLlxuXG5cbiAgICAgIHBhcmVudE5vZGUgPSBub2RlO1xuICAgICAgbm9kZSA9IG5leHQ7XG4gICAgfVxuXG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIGlmIChub2RlID09PSBvdXRlck5vZGUpIHtcbiAgICAgICAgLy8gSWYgYG91dGVyTm9kZWAgaGFzIGNoaWxkcmVuLCB0aGlzIGlzIGFsd2F5cyB0aGUgc2Vjb25kIHRpbWUgdmlzaXRpbmdcbiAgICAgICAgLy8gaXQuIElmIGl0IGhhcyBubyBjaGlsZHJlbiwgdGhpcyBpcyBzdGlsbCB0aGUgZmlyc3QgbG9vcCwgYW5kIHRoZSBvbmx5XG4gICAgICAgIC8vIHZhbGlkIHNlbGVjdGlvbiBpcyBhbmNob3JOb2RlIGFuZCBmb2N1c05vZGUgYm90aCBlcXVhbCB0byB0aGlzIG5vZGVcbiAgICAgICAgLy8gYW5kIGJvdGggb2Zmc2V0cyAwLCBpbiB3aGljaCBjYXNlIHdlIHdpbGwgaGF2ZSBoYW5kbGVkIGFib3ZlLlxuICAgICAgICBicmVhayBvdXRlcjtcbiAgICAgIH1cblxuICAgICAgaWYgKHBhcmVudE5vZGUgPT09IGFuY2hvck5vZGUgJiYgKytpbmRleFdpdGhpbkFuY2hvciA9PT0gYW5jaG9yT2Zmc2V0KSB7XG4gICAgICAgIHN0YXJ0ID0gbGVuZ3RoO1xuICAgICAgfVxuXG4gICAgICBpZiAocGFyZW50Tm9kZSA9PT0gZm9jdXNOb2RlICYmICsraW5kZXhXaXRoaW5Gb2N1cyA9PT0gZm9jdXNPZmZzZXQpIHtcbiAgICAgICAgZW5kID0gbGVuZ3RoO1xuICAgICAgfVxuXG4gICAgICBpZiAoKG5leHQgPSBub2RlLm5leHRTaWJsaW5nKSAhPT0gbnVsbCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgbm9kZSA9IHBhcmVudE5vZGU7XG4gICAgICBwYXJlbnROb2RlID0gbm9kZS5wYXJlbnROb2RlO1xuICAgIH0gLy8gTW92aW5nIGZyb20gYG5vZGVgIHRvIGl0cyBuZXh0IHNpYmxpbmcgYG5leHRgLlxuXG5cbiAgICBub2RlID0gbmV4dDtcbiAgfVxuXG4gIGlmIChzdGFydCA9PT0gLTEgfHwgZW5kID09PSAtMSkge1xuICAgIC8vIFRoaXMgc2hvdWxkIG5ldmVyIGhhcHBlbi4gKFdvdWxkIGhhcHBlbiBpZiB0aGUgYW5jaG9yL2ZvY3VzIG5vZGVzIGFyZW4ndFxuICAgIC8vIGFjdHVhbGx5IGluc2lkZSB0aGUgcGFzc2VkLWluIG5vZGUuKVxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBzdGFydDogc3RhcnQsXG4gICAgZW5kOiBlbmRcbiAgfTtcbn1cbi8qKlxuICogSW4gbW9kZXJuIG5vbi1JRSBicm93c2Vycywgd2UgY2FuIHN1cHBvcnQgYm90aCBmb3J3YXJkIGFuZCBiYWNrd2FyZFxuICogc2VsZWN0aW9ucy5cbiAqXG4gKiBOb3RlOiBJRTEwKyBzdXBwb3J0cyB0aGUgU2VsZWN0aW9uIG9iamVjdCwgYnV0IGl0IGRvZXMgbm90IHN1cHBvcnRcbiAqIHRoZSBgZXh0ZW5kYCBtZXRob2QsIHdoaWNoIG1lYW5zIHRoYXQgZXZlbiBpbiBtb2Rlcm4gSUUsIGl0J3Mgbm90IHBvc3NpYmxlXG4gKiB0byBwcm9ncmFtbWF0aWNhbGx5IGNyZWF0ZSBhIGJhY2t3YXJkIHNlbGVjdGlvbi4gVGh1cywgZm9yIGFsbCBJRVxuICogdmVyc2lvbnMsIHdlIHVzZSB0aGUgb2xkIElFIEFQSSB0byBjcmVhdGUgb3VyIHNlbGVjdGlvbnMuXG4gKlxuICogQHBhcmFtIHtET01FbGVtZW50fERPTVRleHROb2RlfSBub2RlXG4gKiBAcGFyYW0ge29iamVjdH0gb2Zmc2V0c1xuICovXG5cbmZ1bmN0aW9uIHNldE9mZnNldHMobm9kZSwgb2Zmc2V0cykge1xuICB2YXIgZG9jID0gbm9kZS5vd25lckRvY3VtZW50IHx8IGRvY3VtZW50O1xuICB2YXIgd2luID0gZG9jICYmIGRvYy5kZWZhdWx0VmlldyB8fCB3aW5kb3c7IC8vIEVkZ2UgZmFpbHMgd2l0aCBcIk9iamVjdCBleHBlY3RlZFwiIGluIHNvbWUgc2NlbmFyaW9zLlxuICAvLyAoRm9yIGluc3RhbmNlOiBUaW55TUNFIGVkaXRvciB1c2VkIGluIGEgbGlzdCBjb21wb25lbnQgdGhhdCBzdXBwb3J0cyBwYXN0aW5nIHRvIGFkZCBtb3JlLFxuICAvLyBmYWlscyB3aGVuIHBhc3RpbmcgMTAwKyBpdGVtcylcblxuICBpZiAoIXdpbi5nZXRTZWxlY3Rpb24pIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgc2VsZWN0aW9uID0gd2luLmdldFNlbGVjdGlvbigpO1xuICB2YXIgbGVuZ3RoID0gbm9kZS50ZXh0Q29udGVudC5sZW5ndGg7XG4gIHZhciBzdGFydCA9IE1hdGgubWluKG9mZnNldHMuc3RhcnQsIGxlbmd0aCk7XG4gIHZhciBlbmQgPSBvZmZzZXRzLmVuZCA9PT0gdW5kZWZpbmVkID8gc3RhcnQgOiBNYXRoLm1pbihvZmZzZXRzLmVuZCwgbGVuZ3RoKTsgLy8gSUUgMTEgdXNlcyBtb2Rlcm4gc2VsZWN0aW9uLCBidXQgZG9lc24ndCBzdXBwb3J0IHRoZSBleHRlbmQgbWV0aG9kLlxuICAvLyBGbGlwIGJhY2t3YXJkIHNlbGVjdGlvbnMsIHNvIHdlIGNhbiBzZXQgd2l0aCBhIHNpbmdsZSByYW5nZS5cblxuICBpZiAoIXNlbGVjdGlvbi5leHRlbmQgJiYgc3RhcnQgPiBlbmQpIHtcbiAgICB2YXIgdGVtcCA9IGVuZDtcbiAgICBlbmQgPSBzdGFydDtcbiAgICBzdGFydCA9IHRlbXA7XG4gIH1cblxuICB2YXIgc3RhcnRNYXJrZXIgPSBnZXROb2RlRm9yQ2hhcmFjdGVyT2Zmc2V0KG5vZGUsIHN0YXJ0KTtcbiAgdmFyIGVuZE1hcmtlciA9IGdldE5vZGVGb3JDaGFyYWN0ZXJPZmZzZXQobm9kZSwgZW5kKTtcblxuICBpZiAoc3RhcnRNYXJrZXIgJiYgZW5kTWFya2VyKSB7XG4gICAgaWYgKHNlbGVjdGlvbi5yYW5nZUNvdW50ID09PSAxICYmIHNlbGVjdGlvbi5hbmNob3JOb2RlID09PSBzdGFydE1hcmtlci5ub2RlICYmIHNlbGVjdGlvbi5hbmNob3JPZmZzZXQgPT09IHN0YXJ0TWFya2VyLm9mZnNldCAmJiBzZWxlY3Rpb24uZm9jdXNOb2RlID09PSBlbmRNYXJrZXIubm9kZSAmJiBzZWxlY3Rpb24uZm9jdXNPZmZzZXQgPT09IGVuZE1hcmtlci5vZmZzZXQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgcmFuZ2UgPSBkb2MuY3JlYXRlUmFuZ2UoKTtcbiAgICByYW5nZS5zZXRTdGFydChzdGFydE1hcmtlci5ub2RlLCBzdGFydE1hcmtlci5vZmZzZXQpO1xuICAgIHNlbGVjdGlvbi5yZW1vdmVBbGxSYW5nZXMoKTtcblxuICAgIGlmIChzdGFydCA+IGVuZCkge1xuICAgICAgc2VsZWN0aW9uLmFkZFJhbmdlKHJhbmdlKTtcbiAgICAgIHNlbGVjdGlvbi5leHRlbmQoZW5kTWFya2VyLm5vZGUsIGVuZE1hcmtlci5vZmZzZXQpO1xuICAgIH0gZWxzZSB7XG4gICAgICByYW5nZS5zZXRFbmQoZW5kTWFya2VyLm5vZGUsIGVuZE1hcmtlci5vZmZzZXQpO1xuICAgICAgc2VsZWN0aW9uLmFkZFJhbmdlKHJhbmdlKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNUZXh0Tm9kZShub2RlKSB7XG4gIHJldHVybiBub2RlICYmIG5vZGUubm9kZVR5cGUgPT09IFRFWFRfTk9ERTtcbn1cblxuZnVuY3Rpb24gY29udGFpbnNOb2RlKG91dGVyTm9kZSwgaW5uZXJOb2RlKSB7XG4gIGlmICghb3V0ZXJOb2RlIHx8ICFpbm5lck5vZGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0gZWxzZSBpZiAob3V0ZXJOb2RlID09PSBpbm5lck5vZGUpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBlbHNlIGlmIChpc1RleHROb2RlKG91dGVyTm9kZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0gZWxzZSBpZiAoaXNUZXh0Tm9kZShpbm5lck5vZGUpKSB7XG4gICAgcmV0dXJuIGNvbnRhaW5zTm9kZShvdXRlck5vZGUsIGlubmVyTm9kZS5wYXJlbnROb2RlKTtcbiAgfSBlbHNlIGlmICgnY29udGFpbnMnIGluIG91dGVyTm9kZSkge1xuICAgIHJldHVybiBvdXRlck5vZGUuY29udGFpbnMoaW5uZXJOb2RlKTtcbiAgfSBlbHNlIGlmIChvdXRlck5vZGUuY29tcGFyZURvY3VtZW50UG9zaXRpb24pIHtcbiAgICByZXR1cm4gISEob3V0ZXJOb2RlLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKGlubmVyTm9kZSkgJiAxNik7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGlzSW5Eb2N1bWVudChub2RlKSB7XG4gIHJldHVybiBub2RlICYmIG5vZGUub3duZXJEb2N1bWVudCAmJiBjb250YWluc05vZGUobm9kZS5vd25lckRvY3VtZW50LmRvY3VtZW50RWxlbWVudCwgbm9kZSk7XG59XG5cbmZ1bmN0aW9uIGlzU2FtZU9yaWdpbkZyYW1lKGlmcmFtZSkge1xuICB0cnkge1xuICAgIC8vIEFjY2Vzc2luZyB0aGUgY29udGVudERvY3VtZW50IG9mIGEgSFRNTElmcmFtZUVsZW1lbnQgY2FuIGNhdXNlIHRoZSBicm93c2VyXG4gICAgLy8gdG8gdGhyb3csIGUuZy4gaWYgaXQgaGFzIGEgY3Jvc3Mtb3JpZ2luIHNyYyBhdHRyaWJ1dGUuXG4gICAgLy8gU2FmYXJpIHdpbGwgc2hvdyBhbiBlcnJvciBpbiB0aGUgY29uc29sZSB3aGVuIHRoZSBhY2Nlc3MgcmVzdWx0cyBpbiBcIkJsb2NrZWQgYSBmcmFtZSB3aXRoIG9yaWdpblwiLiBlLmc6XG4gICAgLy8gaWZyYW1lLmNvbnRlbnREb2N1bWVudC5kZWZhdWx0VmlldztcbiAgICAvLyBBIHNhZmV0eSB3YXkgaXMgdG8gYWNjZXNzIG9uZSBvZiB0aGUgY3Jvc3Mgb3JpZ2luIHByb3BlcnRpZXM6IFdpbmRvdyBvciBMb2NhdGlvblxuICAgIC8vIFdoaWNoIG1pZ2h0IHJlc3VsdCBpbiBcIlNlY3VyaXR5RXJyb3JcIiBET00gRXhjZXB0aW9uIGFuZCBpdCBpcyBjb21wYXRpYmxlIHRvIFNhZmFyaS5cbiAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9icm93c2Vycy5odG1sI2ludGVncmF0aW9uLXdpdGgtaWRsXG4gICAgcmV0dXJuIHR5cGVvZiBpZnJhbWUuY29udGVudFdpbmRvdy5sb2NhdGlvbi5ocmVmID09PSAnc3RyaW5nJztcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldEFjdGl2ZUVsZW1lbnREZWVwKCkge1xuICB2YXIgd2luID0gd2luZG93O1xuICB2YXIgZWxlbWVudCA9IGdldEFjdGl2ZUVsZW1lbnQoKTtcblxuICB3aGlsZSAoZWxlbWVudCBpbnN0YW5jZW9mIHdpbi5IVE1MSUZyYW1lRWxlbWVudCkge1xuICAgIGlmIChpc1NhbWVPcmlnaW5GcmFtZShlbGVtZW50KSkge1xuICAgICAgd2luID0gZWxlbWVudC5jb250ZW50V2luZG93O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZWxlbWVudDtcbiAgICB9XG5cbiAgICBlbGVtZW50ID0gZ2V0QWN0aXZlRWxlbWVudCh3aW4uZG9jdW1lbnQpO1xuICB9XG5cbiAgcmV0dXJuIGVsZW1lbnQ7XG59XG4vKipcbiAqIEBSZWFjdElucHV0U2VsZWN0aW9uOiBSZWFjdCBpbnB1dCBzZWxlY3Rpb24gbW9kdWxlLiBCYXNlZCBvbiBTZWxlY3Rpb24uanMsXG4gKiBidXQgbW9kaWZpZWQgdG8gYmUgc3VpdGFibGUgZm9yIHJlYWN0IGFuZCBoYXMgYSBjb3VwbGUgb2YgYnVnIGZpeGVzIChkb2Vzbid0XG4gKiBhc3N1bWUgYnV0dG9ucyBoYXZlIHJhbmdlIHNlbGVjdGlvbnMgYWxsb3dlZCkuXG4gKiBJbnB1dCBzZWxlY3Rpb24gbW9kdWxlIGZvciBSZWFjdC5cbiAqL1xuXG4vKipcbiAqIEBoYXNTZWxlY3Rpb25DYXBhYmlsaXRpZXM6IHdlIGdldCB0aGUgZWxlbWVudCB0eXBlcyB0aGF0IHN1cHBvcnQgc2VsZWN0aW9uXG4gKiBmcm9tIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvI2RvLW5vdC1hcHBseSwgbG9va2luZyBhdCBgc2VsZWN0aW9uU3RhcnRgXG4gKiBhbmQgYHNlbGVjdGlvbkVuZGAgcm93cy5cbiAqL1xuXG5cbmZ1bmN0aW9uIGhhc1NlbGVjdGlvbkNhcGFiaWxpdGllcyhlbGVtKSB7XG4gIHZhciBub2RlTmFtZSA9IGVsZW0gJiYgZWxlbS5ub2RlTmFtZSAmJiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG4gIHJldHVybiBub2RlTmFtZSAmJiAobm9kZU5hbWUgPT09ICdpbnB1dCcgJiYgKGVsZW0udHlwZSA9PT0gJ3RleHQnIHx8IGVsZW0udHlwZSA9PT0gJ3NlYXJjaCcgfHwgZWxlbS50eXBlID09PSAndGVsJyB8fCBlbGVtLnR5cGUgPT09ICd1cmwnIHx8IGVsZW0udHlwZSA9PT0gJ3Bhc3N3b3JkJykgfHwgbm9kZU5hbWUgPT09ICd0ZXh0YXJlYScgfHwgZWxlbS5jb250ZW50RWRpdGFibGUgPT09ICd0cnVlJyk7XG59XG5mdW5jdGlvbiBnZXRTZWxlY3Rpb25JbmZvcm1hdGlvbigpIHtcbiAgdmFyIGZvY3VzZWRFbGVtID0gZ2V0QWN0aXZlRWxlbWVudERlZXAoKTtcbiAgcmV0dXJuIHtcbiAgICBmb2N1c2VkRWxlbTogZm9jdXNlZEVsZW0sXG4gICAgc2VsZWN0aW9uUmFuZ2U6IGhhc1NlbGVjdGlvbkNhcGFiaWxpdGllcyhmb2N1c2VkRWxlbSkgPyBnZXRTZWxlY3Rpb24oZm9jdXNlZEVsZW0pIDogbnVsbFxuICB9O1xufVxuLyoqXG4gKiBAcmVzdG9yZVNlbGVjdGlvbjogSWYgYW55IHNlbGVjdGlvbiBpbmZvcm1hdGlvbiB3YXMgcG90ZW50aWFsbHkgbG9zdCxcbiAqIHJlc3RvcmUgaXQuIFRoaXMgaXMgdXNlZnVsIHdoZW4gcGVyZm9ybWluZyBvcGVyYXRpb25zIHRoYXQgY291bGQgcmVtb3ZlIGRvbVxuICogbm9kZXMgYW5kIHBsYWNlIHRoZW0gYmFjayBpbiwgcmVzdWx0aW5nIGluIGZvY3VzIGJlaW5nIGxvc3QuXG4gKi9cblxuZnVuY3Rpb24gcmVzdG9yZVNlbGVjdGlvbihwcmlvclNlbGVjdGlvbkluZm9ybWF0aW9uKSB7XG4gIHZhciBjdXJGb2N1c2VkRWxlbSA9IGdldEFjdGl2ZUVsZW1lbnREZWVwKCk7XG4gIHZhciBwcmlvckZvY3VzZWRFbGVtID0gcHJpb3JTZWxlY3Rpb25JbmZvcm1hdGlvbi5mb2N1c2VkRWxlbTtcbiAgdmFyIHByaW9yU2VsZWN0aW9uUmFuZ2UgPSBwcmlvclNlbGVjdGlvbkluZm9ybWF0aW9uLnNlbGVjdGlvblJhbmdlO1xuXG4gIGlmIChjdXJGb2N1c2VkRWxlbSAhPT0gcHJpb3JGb2N1c2VkRWxlbSAmJiBpc0luRG9jdW1lbnQocHJpb3JGb2N1c2VkRWxlbSkpIHtcbiAgICBpZiAocHJpb3JTZWxlY3Rpb25SYW5nZSAhPT0gbnVsbCAmJiBoYXNTZWxlY3Rpb25DYXBhYmlsaXRpZXMocHJpb3JGb2N1c2VkRWxlbSkpIHtcbiAgICAgIHNldFNlbGVjdGlvbihwcmlvckZvY3VzZWRFbGVtLCBwcmlvclNlbGVjdGlvblJhbmdlKTtcbiAgICB9IC8vIEZvY3VzaW5nIGEgbm9kZSBjYW4gY2hhbmdlIHRoZSBzY3JvbGwgcG9zaXRpb24sIHdoaWNoIGlzIHVuZGVzaXJhYmxlXG5cblxuICAgIHZhciBhbmNlc3RvcnMgPSBbXTtcbiAgICB2YXIgYW5jZXN0b3IgPSBwcmlvckZvY3VzZWRFbGVtO1xuXG4gICAgd2hpbGUgKGFuY2VzdG9yID0gYW5jZXN0b3IucGFyZW50Tm9kZSkge1xuICAgICAgaWYgKGFuY2VzdG9yLm5vZGVUeXBlID09PSBFTEVNRU5UX05PREUpIHtcbiAgICAgICAgYW5jZXN0b3JzLnB1c2goe1xuICAgICAgICAgIGVsZW1lbnQ6IGFuY2VzdG9yLFxuICAgICAgICAgIGxlZnQ6IGFuY2VzdG9yLnNjcm9sbExlZnQsXG4gICAgICAgICAgdG9wOiBhbmNlc3Rvci5zY3JvbGxUb3BcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBwcmlvckZvY3VzZWRFbGVtLmZvY3VzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBwcmlvckZvY3VzZWRFbGVtLmZvY3VzKCk7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhbmNlc3RvcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBpbmZvID0gYW5jZXN0b3JzW2ldO1xuICAgICAgaW5mby5lbGVtZW50LnNjcm9sbExlZnQgPSBpbmZvLmxlZnQ7XG4gICAgICBpbmZvLmVsZW1lbnQuc2Nyb2xsVG9wID0gaW5mby50b3A7XG4gICAgfVxuICB9XG59XG4vKipcbiAqIEBnZXRTZWxlY3Rpb246IEdldHMgdGhlIHNlbGVjdGlvbiBib3VuZHMgb2YgYSBmb2N1c2VkIHRleHRhcmVhLCBpbnB1dCBvclxuICogY29udGVudEVkaXRhYmxlIG5vZGUuXG4gKiAtQGlucHV0OiBMb29rIHVwIHNlbGVjdGlvbiBib3VuZHMgb2YgdGhpcyBpbnB1dFxuICogLUByZXR1cm4ge3N0YXJ0OiBzZWxlY3Rpb25TdGFydCwgZW5kOiBzZWxlY3Rpb25FbmR9XG4gKi9cblxuZnVuY3Rpb24gZ2V0U2VsZWN0aW9uKGlucHV0KSB7XG4gIHZhciBzZWxlY3Rpb247XG5cbiAgaWYgKCdzZWxlY3Rpb25TdGFydCcgaW4gaW5wdXQpIHtcbiAgICAvLyBNb2Rlcm4gYnJvd3NlciB3aXRoIGlucHV0IG9yIHRleHRhcmVhLlxuICAgIHNlbGVjdGlvbiA9IHtcbiAgICAgIHN0YXJ0OiBpbnB1dC5zZWxlY3Rpb25TdGFydCxcbiAgICAgIGVuZDogaW5wdXQuc2VsZWN0aW9uRW5kXG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICAvLyBDb250ZW50IGVkaXRhYmxlIG9yIG9sZCBJRSB0ZXh0YXJlYS5cbiAgICBzZWxlY3Rpb24gPSBnZXRPZmZzZXRzKGlucHV0KTtcbiAgfVxuXG4gIHJldHVybiBzZWxlY3Rpb24gfHwge1xuICAgIHN0YXJ0OiAwLFxuICAgIGVuZDogMFxuICB9O1xufVxuLyoqXG4gKiBAc2V0U2VsZWN0aW9uOiBTZXRzIHRoZSBzZWxlY3Rpb24gYm91bmRzIG9mIGEgdGV4dGFyZWEgb3IgaW5wdXQgYW5kIGZvY3VzZXNcbiAqIHRoZSBpbnB1dC5cbiAqIC1AaW5wdXQgICAgIFNldCBzZWxlY3Rpb24gYm91bmRzIG9mIHRoaXMgaW5wdXQgb3IgdGV4dGFyZWFcbiAqIC1Ab2Zmc2V0cyAgIE9iamVjdCBvZiBzYW1lIGZvcm0gdGhhdCBpcyByZXR1cm5lZCBmcm9tIGdldCpcbiAqL1xuXG5mdW5jdGlvbiBzZXRTZWxlY3Rpb24oaW5wdXQsIG9mZnNldHMpIHtcbiAgdmFyIHN0YXJ0ID0gb2Zmc2V0cy5zdGFydDtcbiAgdmFyIGVuZCA9IG9mZnNldHMuZW5kO1xuXG4gIGlmIChlbmQgPT09IHVuZGVmaW5lZCkge1xuICAgIGVuZCA9IHN0YXJ0O1xuICB9XG5cbiAgaWYgKCdzZWxlY3Rpb25TdGFydCcgaW4gaW5wdXQpIHtcbiAgICBpbnB1dC5zZWxlY3Rpb25TdGFydCA9IHN0YXJ0O1xuICAgIGlucHV0LnNlbGVjdGlvbkVuZCA9IE1hdGgubWluKGVuZCwgaW5wdXQudmFsdWUubGVuZ3RoKTtcbiAgfSBlbHNlIHtcbiAgICBzZXRPZmZzZXRzKGlucHV0LCBvZmZzZXRzKTtcbiAgfVxufVxuXG52YXIgc2tpcFNlbGVjdGlvbkNoYW5nZUV2ZW50ID0gY2FuVXNlRE9NICYmICdkb2N1bWVudE1vZGUnIGluIGRvY3VtZW50ICYmIGRvY3VtZW50LmRvY3VtZW50TW9kZSA8PSAxMTtcblxuZnVuY3Rpb24gcmVnaXN0ZXJFdmVudHMkMygpIHtcbiAgcmVnaXN0ZXJUd29QaGFzZUV2ZW50KCdvblNlbGVjdCcsIFsnZm9jdXNvdXQnLCAnY29udGV4dG1lbnUnLCAnZHJhZ2VuZCcsICdmb2N1c2luJywgJ2tleWRvd24nLCAna2V5dXAnLCAnbW91c2Vkb3duJywgJ21vdXNldXAnLCAnc2VsZWN0aW9uY2hhbmdlJ10pO1xufVxuXG52YXIgYWN0aXZlRWxlbWVudCQxID0gbnVsbDtcbnZhciBhY3RpdmVFbGVtZW50SW5zdCQxID0gbnVsbDtcbnZhciBsYXN0U2VsZWN0aW9uID0gbnVsbDtcbnZhciBtb3VzZURvd24gPSBmYWxzZTtcbi8qKlxuICogR2V0IGFuIG9iamVjdCB3aGljaCBpcyBhIHVuaXF1ZSByZXByZXNlbnRhdGlvbiBvZiB0aGUgY3VycmVudCBzZWxlY3Rpb24uXG4gKlxuICogVGhlIHJldHVybiB2YWx1ZSB3aWxsIG5vdCBiZSBjb25zaXN0ZW50IGFjcm9zcyBub2RlcyBvciBicm93c2VycywgYnV0XG4gKiB0d28gaWRlbnRpY2FsIHNlbGVjdGlvbnMgb24gdGhlIHNhbWUgbm9kZSB3aWxsIHJldHVybiBpZGVudGljYWwgb2JqZWN0cy5cbiAqL1xuXG5mdW5jdGlvbiBnZXRTZWxlY3Rpb24kMShub2RlKSB7XG4gIGlmICgnc2VsZWN0aW9uU3RhcnQnIGluIG5vZGUgJiYgaGFzU2VsZWN0aW9uQ2FwYWJpbGl0aWVzKG5vZGUpKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHN0YXJ0OiBub2RlLnNlbGVjdGlvblN0YXJ0LFxuICAgICAgZW5kOiBub2RlLnNlbGVjdGlvbkVuZFxuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgdmFyIHdpbiA9IG5vZGUub3duZXJEb2N1bWVudCAmJiBub2RlLm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXcgfHwgd2luZG93O1xuICAgIHZhciBzZWxlY3Rpb24gPSB3aW4uZ2V0U2VsZWN0aW9uKCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGFuY2hvck5vZGU6IHNlbGVjdGlvbi5hbmNob3JOb2RlLFxuICAgICAgYW5jaG9yT2Zmc2V0OiBzZWxlY3Rpb24uYW5jaG9yT2Zmc2V0LFxuICAgICAgZm9jdXNOb2RlOiBzZWxlY3Rpb24uZm9jdXNOb2RlLFxuICAgICAgZm9jdXNPZmZzZXQ6IHNlbGVjdGlvbi5mb2N1c09mZnNldFxuICAgIH07XG4gIH1cbn1cbi8qKlxuICogR2V0IGRvY3VtZW50IGFzc29jaWF0ZWQgd2l0aCB0aGUgZXZlbnQgdGFyZ2V0LlxuICovXG5cblxuZnVuY3Rpb24gZ2V0RXZlbnRUYXJnZXREb2N1bWVudChldmVudFRhcmdldCkge1xuICByZXR1cm4gZXZlbnRUYXJnZXQud2luZG93ID09PSBldmVudFRhcmdldCA/IGV2ZW50VGFyZ2V0LmRvY3VtZW50IDogZXZlbnRUYXJnZXQubm9kZVR5cGUgPT09IERPQ1VNRU5UX05PREUgPyBldmVudFRhcmdldCA6IGV2ZW50VGFyZ2V0Lm93bmVyRG9jdW1lbnQ7XG59XG4vKipcbiAqIFBvbGwgc2VsZWN0aW9uIHRvIHNlZSB3aGV0aGVyIGl0J3MgY2hhbmdlZC5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnRcbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudFRhcmdldFxuICogQHJldHVybiB7P1N5bnRoZXRpY0V2ZW50fVxuICovXG5cblxuZnVuY3Rpb24gY29uc3RydWN0U2VsZWN0RXZlbnQoZGlzcGF0Y2hRdWV1ZSwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gIC8vIEVuc3VyZSB3ZSBoYXZlIHRoZSByaWdodCBlbGVtZW50LCBhbmQgdGhhdCB0aGUgdXNlciBpcyBub3QgZHJhZ2dpbmcgYVxuICAvLyBzZWxlY3Rpb24gKHRoaXMgbWF0Y2hlcyBuYXRpdmUgYHNlbGVjdGAgZXZlbnQgYmVoYXZpb3IpLiBJbiBIVE1MNSwgc2VsZWN0XG4gIC8vIGZpcmVzIG9ubHkgb24gaW5wdXQgYW5kIHRleHRhcmVhIHRodXMgaWYgdGhlcmUncyBubyBmb2N1c2VkIGVsZW1lbnQgd2VcbiAgLy8gd29uJ3QgZGlzcGF0Y2guXG4gIHZhciBkb2MgPSBnZXRFdmVudFRhcmdldERvY3VtZW50KG5hdGl2ZUV2ZW50VGFyZ2V0KTtcblxuICBpZiAobW91c2VEb3duIHx8IGFjdGl2ZUVsZW1lbnQkMSA9PSBudWxsIHx8IGFjdGl2ZUVsZW1lbnQkMSAhPT0gZ2V0QWN0aXZlRWxlbWVudChkb2MpKSB7XG4gICAgcmV0dXJuO1xuICB9IC8vIE9ubHkgZmlyZSB3aGVuIHNlbGVjdGlvbiBoYXMgYWN0dWFsbHkgY2hhbmdlZC5cblxuXG4gIHZhciBjdXJyZW50U2VsZWN0aW9uID0gZ2V0U2VsZWN0aW9uJDEoYWN0aXZlRWxlbWVudCQxKTtcblxuICBpZiAoIWxhc3RTZWxlY3Rpb24gfHwgIXNoYWxsb3dFcXVhbChsYXN0U2VsZWN0aW9uLCBjdXJyZW50U2VsZWN0aW9uKSkge1xuICAgIGxhc3RTZWxlY3Rpb24gPSBjdXJyZW50U2VsZWN0aW9uO1xuICAgIHZhciBsaXN0ZW5lcnMgPSBhY2N1bXVsYXRlVHdvUGhhc2VMaXN0ZW5lcnMoYWN0aXZlRWxlbWVudEluc3QkMSwgJ29uU2VsZWN0Jyk7XG5cbiAgICBpZiAobGlzdGVuZXJzLmxlbmd0aCA+IDApIHtcbiAgICAgIHZhciBldmVudCA9IG5ldyBTeW50aGV0aWNFdmVudCgnb25TZWxlY3QnLCAnc2VsZWN0JywgbnVsbCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbiAgICAgIGRpc3BhdGNoUXVldWUucHVzaCh7XG4gICAgICAgIGV2ZW50OiBldmVudCxcbiAgICAgICAgbGlzdGVuZXJzOiBsaXN0ZW5lcnNcbiAgICAgIH0pO1xuICAgICAgZXZlbnQudGFyZ2V0ID0gYWN0aXZlRWxlbWVudCQxO1xuICAgIH1cbiAgfVxufVxuLyoqXG4gKiBUaGlzIHBsdWdpbiBjcmVhdGVzIGFuIGBvblNlbGVjdGAgZXZlbnQgdGhhdCBub3JtYWxpemVzIHNlbGVjdCBldmVudHNcbiAqIGFjcm9zcyBmb3JtIGVsZW1lbnRzLlxuICpcbiAqIFN1cHBvcnRlZCBlbGVtZW50cyBhcmU6XG4gKiAtIGlucHV0IChzZWUgYGlzVGV4dElucHV0RWxlbWVudGApXG4gKiAtIHRleHRhcmVhXG4gKiAtIGNvbnRlbnRFZGl0YWJsZVxuICpcbiAqIFRoaXMgZGlmZmVycyBmcm9tIG5hdGl2ZSBicm93c2VyIGltcGxlbWVudGF0aW9ucyBpbiB0aGUgZm9sbG93aW5nIHdheXM6XG4gKiAtIEZpcmVzIG9uIGNvbnRlbnRFZGl0YWJsZSBmaWVsZHMgYXMgd2VsbCBhcyBpbnB1dHMuXG4gKiAtIEZpcmVzIGZvciBjb2xsYXBzZWQgc2VsZWN0aW9uLlxuICogLSBGaXJlcyBhZnRlciB1c2VyIGlucHV0LlxuICovXG5cblxuZnVuY3Rpb24gZXh0cmFjdEV2ZW50cyQzKGRpc3BhdGNoUXVldWUsIGRvbUV2ZW50TmFtZSwgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0LCBldmVudFN5c3RlbUZsYWdzLCB0YXJnZXRDb250YWluZXIpIHtcblxuICB2YXIgdGFyZ2V0Tm9kZSA9IHRhcmdldEluc3QgPyBnZXROb2RlRnJvbUluc3RhbmNlKHRhcmdldEluc3QpIDogd2luZG93O1xuXG4gIHN3aXRjaCAoZG9tRXZlbnROYW1lKSB7XG4gICAgLy8gVHJhY2sgdGhlIGlucHV0IG5vZGUgdGhhdCBoYXMgZm9jdXMuXG4gICAgY2FzZSAnZm9jdXNpbic6XG4gICAgICBpZiAoaXNUZXh0SW5wdXRFbGVtZW50KHRhcmdldE5vZGUpIHx8IHRhcmdldE5vZGUuY29udGVudEVkaXRhYmxlID09PSAndHJ1ZScpIHtcbiAgICAgICAgYWN0aXZlRWxlbWVudCQxID0gdGFyZ2V0Tm9kZTtcbiAgICAgICAgYWN0aXZlRWxlbWVudEluc3QkMSA9IHRhcmdldEluc3Q7XG4gICAgICAgIGxhc3RTZWxlY3Rpb24gPSBudWxsO1xuICAgICAgfVxuXG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ2ZvY3Vzb3V0JzpcbiAgICAgIGFjdGl2ZUVsZW1lbnQkMSA9IG51bGw7XG4gICAgICBhY3RpdmVFbGVtZW50SW5zdCQxID0gbnVsbDtcbiAgICAgIGxhc3RTZWxlY3Rpb24gPSBudWxsO1xuICAgICAgYnJlYWs7XG4gICAgLy8gRG9uJ3QgZmlyZSB0aGUgZXZlbnQgd2hpbGUgdGhlIHVzZXIgaXMgZHJhZ2dpbmcuIFRoaXMgbWF0Y2hlcyB0aGVcbiAgICAvLyBzZW1hbnRpY3Mgb2YgdGhlIG5hdGl2ZSBzZWxlY3QgZXZlbnQuXG5cbiAgICBjYXNlICdtb3VzZWRvd24nOlxuICAgICAgbW91c2VEb3duID0gdHJ1ZTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnY29udGV4dG1lbnUnOlxuICAgIGNhc2UgJ21vdXNldXAnOlxuICAgIGNhc2UgJ2RyYWdlbmQnOlxuICAgICAgbW91c2VEb3duID0gZmFsc2U7XG4gICAgICBjb25zdHJ1Y3RTZWxlY3RFdmVudChkaXNwYXRjaFF1ZXVlLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xuICAgICAgYnJlYWs7XG4gICAgLy8gQ2hyb21lIGFuZCBJRSBmaXJlIG5vbi1zdGFuZGFyZCBldmVudCB3aGVuIHNlbGVjdGlvbiBpcyBjaGFuZ2VkIChhbmRcbiAgICAvLyBzb21ldGltZXMgd2hlbiBpdCBoYXNuJ3QpLiBJRSdzIGV2ZW50IGZpcmVzIG91dCBvZiBvcmRlciB3aXRoIHJlc3BlY3RcbiAgICAvLyB0byBrZXkgYW5kIGlucHV0IGV2ZW50cyBvbiBkZWxldGlvbiwgc28gd2UgZGlzY2FyZCBpdC5cbiAgICAvL1xuICAgIC8vIEZpcmVmb3ggZG9lc24ndCBzdXBwb3J0IHNlbGVjdGlvbmNoYW5nZSwgc28gY2hlY2sgc2VsZWN0aW9uIHN0YXR1c1xuICAgIC8vIGFmdGVyIGVhY2gga2V5IGVudHJ5LiBUaGUgc2VsZWN0aW9uIGNoYW5nZXMgYWZ0ZXIga2V5ZG93biBhbmQgYmVmb3JlXG4gICAgLy8ga2V5dXAsIGJ1dCB3ZSBjaGVjayBvbiBrZXlkb3duIGFzIHdlbGwgaW4gdGhlIGNhc2Ugb2YgaG9sZGluZyBkb3duIGFcbiAgICAvLyBrZXksIHdoZW4gbXVsdGlwbGUga2V5ZG93biBldmVudHMgYXJlIGZpcmVkIGJ1dCBvbmx5IG9uZSBrZXl1cCBpcy5cbiAgICAvLyBUaGlzIGlzIGFsc28gb3VyIGFwcHJvYWNoIGZvciBJRSBoYW5kbGluZywgZm9yIHRoZSByZWFzb24gYWJvdmUuXG5cbiAgICBjYXNlICdzZWxlY3Rpb25jaGFuZ2UnOlxuICAgICAgaWYgKHNraXBTZWxlY3Rpb25DaGFuZ2VFdmVudCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgIC8vIGZhbGxzIHRocm91Z2hcblxuICAgIGNhc2UgJ2tleWRvd24nOlxuICAgIGNhc2UgJ2tleXVwJzpcbiAgICAgIGNvbnN0cnVjdFNlbGVjdEV2ZW50KGRpc3BhdGNoUXVldWUsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZXh0cmFjdEV2ZW50cyQ0KGRpc3BhdGNoUXVldWUsIGRvbUV2ZW50TmFtZSwgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0LCBldmVudFN5c3RlbUZsYWdzLCB0YXJnZXRDb250YWluZXIpIHtcbiAgdmFyIHJlYWN0TmFtZSA9IHRvcExldmVsRXZlbnRzVG9SZWFjdE5hbWVzLmdldChkb21FdmVudE5hbWUpO1xuXG4gIGlmIChyZWFjdE5hbWUgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBTeW50aGV0aWNFdmVudEN0b3IgPSBTeW50aGV0aWNFdmVudDtcbiAgdmFyIHJlYWN0RXZlbnRUeXBlID0gZG9tRXZlbnROYW1lO1xuXG4gIHN3aXRjaCAoZG9tRXZlbnROYW1lKSB7XG4gICAgY2FzZSAna2V5cHJlc3MnOlxuICAgICAgLy8gRmlyZWZveCBjcmVhdGVzIGEga2V5cHJlc3MgZXZlbnQgZm9yIGZ1bmN0aW9uIGtleXMgdG9vLiBUaGlzIHJlbW92ZXNcbiAgICAgIC8vIHRoZSB1bndhbnRlZCBrZXlwcmVzcyBldmVudHMuIEVudGVyIGlzIGhvd2V2ZXIgYm90aCBwcmludGFibGUgYW5kXG4gICAgICAvLyBub24tcHJpbnRhYmxlLiBPbmUgd291bGQgZXhwZWN0IFRhYiB0byBiZSBhcyB3ZWxsIChidXQgaXQgaXNuJ3QpLlxuICAgICAgaWYgKGdldEV2ZW50Q2hhckNvZGUobmF0aXZlRXZlbnQpID09PSAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cblxuICAgIGNhc2UgJ2tleWRvd24nOlxuICAgIGNhc2UgJ2tleXVwJzpcbiAgICAgIFN5bnRoZXRpY0V2ZW50Q3RvciA9IFN5bnRoZXRpY0tleWJvYXJkRXZlbnQ7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ2ZvY3VzaW4nOlxuICAgICAgcmVhY3RFdmVudFR5cGUgPSAnZm9jdXMnO1xuICAgICAgU3ludGhldGljRXZlbnRDdG9yID0gU3ludGhldGljRm9jdXNFdmVudDtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnZm9jdXNvdXQnOlxuICAgICAgcmVhY3RFdmVudFR5cGUgPSAnYmx1cic7XG4gICAgICBTeW50aGV0aWNFdmVudEN0b3IgPSBTeW50aGV0aWNGb2N1c0V2ZW50O1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdiZWZvcmVibHVyJzpcbiAgICBjYXNlICdhZnRlcmJsdXInOlxuICAgICAgU3ludGhldGljRXZlbnRDdG9yID0gU3ludGhldGljRm9jdXNFdmVudDtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnY2xpY2snOlxuICAgICAgLy8gRmlyZWZveCBjcmVhdGVzIGEgY2xpY2sgZXZlbnQgb24gcmlnaHQgbW91c2UgY2xpY2tzLiBUaGlzIHJlbW92ZXMgdGhlXG4gICAgICAvLyB1bndhbnRlZCBjbGljayBldmVudHMuXG4gICAgICBpZiAobmF0aXZlRXZlbnQuYnV0dG9uID09PSAyKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cblxuICAgIGNhc2UgJ2F1eGNsaWNrJzpcbiAgICBjYXNlICdkYmxjbGljayc6XG4gICAgY2FzZSAnbW91c2Vkb3duJzpcbiAgICBjYXNlICdtb3VzZW1vdmUnOlxuICAgIGNhc2UgJ21vdXNldXAnOiAvLyBUT0RPOiBEaXNhYmxlZCBlbGVtZW50cyBzaG91bGQgbm90IHJlc3BvbmQgdG8gbW91c2UgZXZlbnRzXG5cbiAgICAvKiBmYWxscyB0aHJvdWdoICovXG5cbiAgICBjYXNlICdtb3VzZW91dCc6XG4gICAgY2FzZSAnbW91c2VvdmVyJzpcbiAgICBjYXNlICdjb250ZXh0bWVudSc6XG4gICAgICBTeW50aGV0aWNFdmVudEN0b3IgPSBTeW50aGV0aWNNb3VzZUV2ZW50O1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdkcmFnJzpcbiAgICBjYXNlICdkcmFnZW5kJzpcbiAgICBjYXNlICdkcmFnZW50ZXInOlxuICAgIGNhc2UgJ2RyYWdleGl0JzpcbiAgICBjYXNlICdkcmFnbGVhdmUnOlxuICAgIGNhc2UgJ2RyYWdvdmVyJzpcbiAgICBjYXNlICdkcmFnc3RhcnQnOlxuICAgIGNhc2UgJ2Ryb3AnOlxuICAgICAgU3ludGhldGljRXZlbnRDdG9yID0gU3ludGhldGljRHJhZ0V2ZW50O1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICd0b3VjaGNhbmNlbCc6XG4gICAgY2FzZSAndG91Y2hlbmQnOlxuICAgIGNhc2UgJ3RvdWNobW92ZSc6XG4gICAgY2FzZSAndG91Y2hzdGFydCc6XG4gICAgICBTeW50aGV0aWNFdmVudEN0b3IgPSBTeW50aGV0aWNUb3VjaEV2ZW50O1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIEFOSU1BVElPTl9FTkQ6XG4gICAgY2FzZSBBTklNQVRJT05fSVRFUkFUSU9OOlxuICAgIGNhc2UgQU5JTUFUSU9OX1NUQVJUOlxuICAgICAgU3ludGhldGljRXZlbnRDdG9yID0gU3ludGhldGljQW5pbWF0aW9uRXZlbnQ7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgVFJBTlNJVElPTl9FTkQ6XG4gICAgICBTeW50aGV0aWNFdmVudEN0b3IgPSBTeW50aGV0aWNUcmFuc2l0aW9uRXZlbnQ7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ3Njcm9sbCc6XG4gICAgICBTeW50aGV0aWNFdmVudEN0b3IgPSBTeW50aGV0aWNVSUV2ZW50O1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICd3aGVlbCc6XG4gICAgICBTeW50aGV0aWNFdmVudEN0b3IgPSBTeW50aGV0aWNXaGVlbEV2ZW50O1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdjb3B5JzpcbiAgICBjYXNlICdjdXQnOlxuICAgIGNhc2UgJ3Bhc3RlJzpcbiAgICAgIFN5bnRoZXRpY0V2ZW50Q3RvciA9IFN5bnRoZXRpY0NsaXBib2FyZEV2ZW50O1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdnb3Rwb2ludGVyY2FwdHVyZSc6XG4gICAgY2FzZSAnbG9zdHBvaW50ZXJjYXB0dXJlJzpcbiAgICBjYXNlICdwb2ludGVyY2FuY2VsJzpcbiAgICBjYXNlICdwb2ludGVyZG93bic6XG4gICAgY2FzZSAncG9pbnRlcm1vdmUnOlxuICAgIGNhc2UgJ3BvaW50ZXJvdXQnOlxuICAgIGNhc2UgJ3BvaW50ZXJvdmVyJzpcbiAgICBjYXNlICdwb2ludGVydXAnOlxuICAgICAgU3ludGhldGljRXZlbnRDdG9yID0gU3ludGhldGljUG9pbnRlckV2ZW50O1xuICAgICAgYnJlYWs7XG4gIH1cblxuICB2YXIgaW5DYXB0dXJlUGhhc2UgPSAoZXZlbnRTeXN0ZW1GbGFncyAmIElTX0NBUFRVUkVfUEhBU0UpICE9PSAwO1xuXG4gIHtcbiAgICAvLyBTb21lIGV2ZW50cyBkb24ndCBidWJibGUgaW4gdGhlIGJyb3dzZXIuXG4gICAgLy8gSW4gdGhlIHBhc3QsIFJlYWN0IGhhcyBhbHdheXMgYnViYmxlZCB0aGVtLCBidXQgdGhpcyBjYW4gYmUgc3VycHJpc2luZy5cbiAgICAvLyBXZSdyZSBnb2luZyB0byB0cnkgYWxpZ25pbmcgY2xvc2VyIHRvIHRoZSBicm93c2VyIGJlaGF2aW9yIGJ5IG5vdCBidWJibGluZ1xuICAgIC8vIHRoZW0gaW4gUmVhY3QgZWl0aGVyLiBXZSdsbCBzdGFydCBieSBub3QgYnViYmxpbmcgb25TY3JvbGwsIGFuZCB0aGVuIGV4cGFuZC5cbiAgICB2YXIgYWNjdW11bGF0ZVRhcmdldE9ubHkgPSAhaW5DYXB0dXJlUGhhc2UgJiYgLy8gVE9ETzogaWRlYWxseSwgd2UnZCBldmVudHVhbGx5IGFkZCBhbGwgZXZlbnRzIGZyb21cbiAgICAvLyBub25EZWxlZ2F0ZWRFdmVudHMgbGlzdCBpbiBET01QbHVnaW5FdmVudFN5c3RlbS5cbiAgICAvLyBUaGVuIHdlIGNhbiByZW1vdmUgdGhpcyBzcGVjaWFsIGxpc3QuXG4gICAgLy8gVGhpcyBpcyBhIGJyZWFraW5nIGNoYW5nZSB0aGF0IGNhbiB3YWl0IHVudGlsIFJlYWN0IDE4LlxuICAgIGRvbUV2ZW50TmFtZSA9PT0gJ3Njcm9sbCc7XG5cbiAgICB2YXIgX2xpc3RlbmVycyA9IGFjY3VtdWxhdGVTaW5nbGVQaGFzZUxpc3RlbmVycyh0YXJnZXRJbnN0LCByZWFjdE5hbWUsIG5hdGl2ZUV2ZW50LnR5cGUsIGluQ2FwdHVyZVBoYXNlLCBhY2N1bXVsYXRlVGFyZ2V0T25seSk7XG5cbiAgICBpZiAoX2xpc3RlbmVycy5sZW5ndGggPiAwKSB7XG4gICAgICAvLyBJbnRlbnRpb25hbGx5IGNyZWF0ZSBldmVudCBsYXppbHkuXG4gICAgICB2YXIgX2V2ZW50ID0gbmV3IFN5bnRoZXRpY0V2ZW50Q3RvcihyZWFjdE5hbWUsIHJlYWN0RXZlbnRUeXBlLCBudWxsLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xuXG4gICAgICBkaXNwYXRjaFF1ZXVlLnB1c2goe1xuICAgICAgICBldmVudDogX2V2ZW50LFxuICAgICAgICBsaXN0ZW5lcnM6IF9saXN0ZW5lcnNcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxufVxuXG4vLyBUT0RPOiByZW1vdmUgdG9wLWxldmVsIHNpZGUgZWZmZWN0LlxucmVnaXN0ZXJTaW1wbGVFdmVudHMoKTtcbnJlZ2lzdGVyRXZlbnRzJDIoKTtcbnJlZ2lzdGVyRXZlbnRzJDEoKTtcbnJlZ2lzdGVyRXZlbnRzJDMoKTtcbnJlZ2lzdGVyRXZlbnRzKCk7XG5cbmZ1bmN0aW9uIGV4dHJhY3RFdmVudHMkNShkaXNwYXRjaFF1ZXVlLCBkb21FdmVudE5hbWUsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCwgZXZlbnRTeXN0ZW1GbGFncywgdGFyZ2V0Q29udGFpbmVyKSB7XG4gIC8vIFRPRE86IHdlIHNob3VsZCByZW1vdmUgdGhlIGNvbmNlcHQgb2YgYSBcIlNpbXBsZUV2ZW50UGx1Z2luXCIuXG4gIC8vIFRoaXMgaXMgdGhlIGJhc2ljIGZ1bmN0aW9uYWxpdHkgb2YgdGhlIGV2ZW50IHN5c3RlbS4gQWxsXG4gIC8vIHRoZSBvdGhlciBwbHVnaW5zIGFyZSBlc3NlbnRpYWxseSBwb2x5ZmlsbHMuIFNvIHRoZSBwbHVnaW5cbiAgLy8gc2hvdWxkIHByb2JhYmx5IGJlIGlubGluZWQgc29tZXdoZXJlIGFuZCBoYXZlIGl0cyBsb2dpY1xuICAvLyBiZSBjb3JlIHRoZSB0byBldmVudCBzeXN0ZW0uIFRoaXMgd291bGQgcG90ZW50aWFsbHkgYWxsb3dcbiAgLy8gdXMgdG8gc2hpcCBidWlsZHMgb2YgUmVhY3Qgd2l0aG91dCB0aGUgcG9seWZpbGxlZCBwbHVnaW5zIGJlbG93LlxuICBleHRyYWN0RXZlbnRzJDQoZGlzcGF0Y2hRdWV1ZSwgZG9tRXZlbnROYW1lLCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQsIGV2ZW50U3lzdGVtRmxhZ3MpO1xuICB2YXIgc2hvdWxkUHJvY2Vzc1BvbHlmaWxsUGx1Z2lucyA9IChldmVudFN5c3RlbUZsYWdzICYgU0hPVUxEX05PVF9QUk9DRVNTX1BPTFlGSUxMX0VWRU5UX1BMVUdJTlMpID09PSAwOyAvLyBXZSBkb24ndCBwcm9jZXNzIHRoZXNlIGV2ZW50cyB1bmxlc3Mgd2UgYXJlIGluIHRoZVxuICAvLyBldmVudCdzIG5hdGl2ZSBcImJ1YmJsZVwiIHBoYXNlLCB3aGljaCBtZWFucyB0aGF0IHdlJ3JlXG4gIC8vIG5vdCBpbiB0aGUgY2FwdHVyZSBwaGFzZS4gVGhhdCdzIGJlY2F1c2Ugd2UgZW11bGF0ZVxuICAvLyB0aGUgY2FwdHVyZSBwaGFzZSBoZXJlIHN0aWxsLiBUaGlzIGlzIGEgdHJhZGUtb2ZmLFxuICAvLyBiZWNhdXNlIGluIGFuIGlkZWFsIHdvcmxkIHdlIHdvdWxkIG5vdCBlbXVsYXRlIGFuZCB1c2VcbiAgLy8gdGhlIHBoYXNlcyBwcm9wZXJseSwgbGlrZSB3ZSBkbyB3aXRoIHRoZSBTaW1wbGVFdmVudFxuICAvLyBwbHVnaW4uIEhvd2V2ZXIsIHRoZSBwbHVnaW5zIGJlbG93IGVpdGhlciBleHBlY3RcbiAgLy8gZW11bGF0aW9uIChFbnRlckxlYXZlKSBvciB1c2Ugc3RhdGUgbG9jYWxpemVkIHRvIHRoYXRcbiAgLy8gcGx1Z2luIChCZWZvcmVJbnB1dCwgQ2hhbmdlLCBTZWxlY3QpLiBUaGUgc3RhdGUgaW5cbiAgLy8gdGhlc2UgbW9kdWxlcyBjb21wbGljYXRlcyB0aGluZ3MsIGFzIHlvdSdsbCBlc3NlbnRpYWxseVxuICAvLyBnZXQgdGhlIGNhc2Ugd2hlcmUgdGhlIGNhcHR1cmUgcGhhc2UgZXZlbnQgbWlnaHQgY2hhbmdlXG4gIC8vIHN0YXRlLCBvbmx5IGZvciB0aGUgZm9sbG93aW5nIGJ1YmJsZSBldmVudCB0byBjb21lIGluXG4gIC8vIGxhdGVyIGFuZCBub3QgdHJpZ2dlciBhbnl0aGluZyBhcyB0aGUgc3RhdGUgbm93XG4gIC8vIGludmFsaWRhdGVzIHRoZSBoZXVyaXN0aWNzIG9mIHRoZSBldmVudCBwbHVnaW4uIFdlXG4gIC8vIGNvdWxkIGFsdGVyIGFsbCB0aGVzZSBwbHVnaW5zIHRvIHdvcmsgaW4gc3VjaCB3YXlzLCBidXRcbiAgLy8gdGhhdCBtaWdodCBjYXVzZSBvdGhlciB1bmtub3duIHNpZGUtZWZmZWN0cyB0aGF0IHdlXG4gIC8vIGNhbid0IGZvcnNlZSByaWdodCBub3cuXG5cbiAgaWYgKHNob3VsZFByb2Nlc3NQb2x5ZmlsbFBsdWdpbnMpIHtcbiAgICBleHRyYWN0RXZlbnRzJDIoZGlzcGF0Y2hRdWV1ZSwgZG9tRXZlbnROYW1lLCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQsIGV2ZW50U3lzdGVtRmxhZ3MpO1xuICAgIGV4dHJhY3RFdmVudHMkMShkaXNwYXRjaFF1ZXVlLCBkb21FdmVudE5hbWUsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG4gICAgZXh0cmFjdEV2ZW50cyQzKGRpc3BhdGNoUXVldWUsIGRvbUV2ZW50TmFtZSwgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbiAgICBleHRyYWN0RXZlbnRzKGRpc3BhdGNoUXVldWUsIGRvbUV2ZW50TmFtZSwgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbiAgfVxufSAvLyBMaXN0IG9mIGV2ZW50cyB0aGF0IG5lZWQgdG8gYmUgaW5kaXZpZHVhbGx5IGF0dGFjaGVkIHRvIG1lZGlhIGVsZW1lbnRzLlxuXG5cbnZhciBtZWRpYUV2ZW50VHlwZXMgPSBbJ2Fib3J0JywgJ2NhbnBsYXknLCAnY2FucGxheXRocm91Z2gnLCAnZHVyYXRpb25jaGFuZ2UnLCAnZW1wdGllZCcsICdlbmNyeXB0ZWQnLCAnZW5kZWQnLCAnZXJyb3InLCAnbG9hZGVkZGF0YScsICdsb2FkZWRtZXRhZGF0YScsICdsb2Fkc3RhcnQnLCAncGF1c2UnLCAncGxheScsICdwbGF5aW5nJywgJ3Byb2dyZXNzJywgJ3JhdGVjaGFuZ2UnLCAnc2Vla2VkJywgJ3NlZWtpbmcnLCAnc3RhbGxlZCcsICdzdXNwZW5kJywgJ3RpbWV1cGRhdGUnLCAndm9sdW1lY2hhbmdlJywgJ3dhaXRpbmcnXTsgLy8gV2Ugc2hvdWxkIG5vdCBkZWxlZ2F0ZSB0aGVzZSBldmVudHMgdG8gdGhlIGNvbnRhaW5lciwgYnV0IHJhdGhlclxuLy8gc2V0IHRoZW0gb24gdGhlIGFjdHVhbCB0YXJnZXQgZWxlbWVudCBpdHNlbGYuIFRoaXMgaXMgcHJpbWFyaWx5XG4vLyBiZWNhdXNlIHRoZXNlIGV2ZW50cyBkbyBub3QgY29uc2lzdGVudGx5IGJ1YmJsZSBpbiB0aGUgRE9NLlxuXG52YXIgbm9uRGVsZWdhdGVkRXZlbnRzID0gbmV3IFNldChbJ2NhbmNlbCcsICdjbG9zZScsICdpbnZhbGlkJywgJ2xvYWQnLCAnc2Nyb2xsJywgJ3RvZ2dsZSddLmNvbmNhdChtZWRpYUV2ZW50VHlwZXMpKTtcblxuZnVuY3Rpb24gZXhlY3V0ZURpc3BhdGNoKGV2ZW50LCBsaXN0ZW5lciwgY3VycmVudFRhcmdldCkge1xuICB2YXIgdHlwZSA9IGV2ZW50LnR5cGUgfHwgJ3Vua25vd24tZXZlbnQnO1xuICBldmVudC5jdXJyZW50VGFyZ2V0ID0gY3VycmVudFRhcmdldDtcbiAgaW52b2tlR3VhcmRlZENhbGxiYWNrQW5kQ2F0Y2hGaXJzdEVycm9yKHR5cGUsIGxpc3RlbmVyLCB1bmRlZmluZWQsIGV2ZW50KTtcbiAgZXZlbnQuY3VycmVudFRhcmdldCA9IG51bGw7XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NEaXNwYXRjaFF1ZXVlSXRlbXNJbk9yZGVyKGV2ZW50LCBkaXNwYXRjaExpc3RlbmVycywgaW5DYXB0dXJlUGhhc2UpIHtcbiAgdmFyIHByZXZpb3VzSW5zdGFuY2U7XG5cbiAgaWYgKGluQ2FwdHVyZVBoYXNlKSB7XG4gICAgZm9yICh2YXIgaSA9IGRpc3BhdGNoTGlzdGVuZXJzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICB2YXIgX2Rpc3BhdGNoTGlzdGVuZXJzJGkgPSBkaXNwYXRjaExpc3RlbmVyc1tpXSxcbiAgICAgICAgICBpbnN0YW5jZSA9IF9kaXNwYXRjaExpc3RlbmVycyRpLmluc3RhbmNlLFxuICAgICAgICAgIGN1cnJlbnRUYXJnZXQgPSBfZGlzcGF0Y2hMaXN0ZW5lcnMkaS5jdXJyZW50VGFyZ2V0LFxuICAgICAgICAgIGxpc3RlbmVyID0gX2Rpc3BhdGNoTGlzdGVuZXJzJGkubGlzdGVuZXI7XG5cbiAgICAgIGlmIChpbnN0YW5jZSAhPT0gcHJldmlvdXNJbnN0YW5jZSAmJiBldmVudC5pc1Byb3BhZ2F0aW9uU3RvcHBlZCgpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgZXhlY3V0ZURpc3BhdGNoKGV2ZW50LCBsaXN0ZW5lciwgY3VycmVudFRhcmdldCk7XG4gICAgICBwcmV2aW91c0luc3RhbmNlID0gaW5zdGFuY2U7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBkaXNwYXRjaExpc3RlbmVycy5sZW5ndGg7IF9pKyspIHtcbiAgICAgIHZhciBfZGlzcGF0Y2hMaXN0ZW5lcnMkX2kgPSBkaXNwYXRjaExpc3RlbmVyc1tfaV0sXG4gICAgICAgICAgX2luc3RhbmNlID0gX2Rpc3BhdGNoTGlzdGVuZXJzJF9pLmluc3RhbmNlLFxuICAgICAgICAgIF9jdXJyZW50VGFyZ2V0ID0gX2Rpc3BhdGNoTGlzdGVuZXJzJF9pLmN1cnJlbnRUYXJnZXQsXG4gICAgICAgICAgX2xpc3RlbmVyID0gX2Rpc3BhdGNoTGlzdGVuZXJzJF9pLmxpc3RlbmVyO1xuXG4gICAgICBpZiAoX2luc3RhbmNlICE9PSBwcmV2aW91c0luc3RhbmNlICYmIGV2ZW50LmlzUHJvcGFnYXRpb25TdG9wcGVkKCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBleGVjdXRlRGlzcGF0Y2goZXZlbnQsIF9saXN0ZW5lciwgX2N1cnJlbnRUYXJnZXQpO1xuICAgICAgcHJldmlvdXNJbnN0YW5jZSA9IF9pbnN0YW5jZTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJvY2Vzc0Rpc3BhdGNoUXVldWUoZGlzcGF0Y2hRdWV1ZSwgZXZlbnRTeXN0ZW1GbGFncykge1xuICB2YXIgaW5DYXB0dXJlUGhhc2UgPSAoZXZlbnRTeXN0ZW1GbGFncyAmIElTX0NBUFRVUkVfUEhBU0UpICE9PSAwO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZGlzcGF0Y2hRdWV1ZS5sZW5ndGg7IGkrKykge1xuICAgIHZhciBfZGlzcGF0Y2hRdWV1ZSRpID0gZGlzcGF0Y2hRdWV1ZVtpXSxcbiAgICAgICAgZXZlbnQgPSBfZGlzcGF0Y2hRdWV1ZSRpLmV2ZW50LFxuICAgICAgICBsaXN0ZW5lcnMgPSBfZGlzcGF0Y2hRdWV1ZSRpLmxpc3RlbmVycztcbiAgICBwcm9jZXNzRGlzcGF0Y2hRdWV1ZUl0ZW1zSW5PcmRlcihldmVudCwgbGlzdGVuZXJzLCBpbkNhcHR1cmVQaGFzZSk7IC8vICBldmVudCBzeXN0ZW0gZG9lc24ndCB1c2UgcG9vbGluZy5cbiAgfSAvLyBUaGlzIHdvdWxkIGJlIGEgZ29vZCB0aW1lIHRvIHJldGhyb3cgaWYgYW55IG9mIHRoZSBldmVudCBoYW5kbGVycyB0aHJldy5cblxuXG4gIHJldGhyb3dDYXVnaHRFcnJvcigpO1xufVxuXG5mdW5jdGlvbiBkaXNwYXRjaEV2ZW50c0ZvclBsdWdpbnMoZG9tRXZlbnROYW1lLCBldmVudFN5c3RlbUZsYWdzLCBuYXRpdmVFdmVudCwgdGFyZ2V0SW5zdCwgdGFyZ2V0Q29udGFpbmVyKSB7XG4gIHZhciBuYXRpdmVFdmVudFRhcmdldCA9IGdldEV2ZW50VGFyZ2V0KG5hdGl2ZUV2ZW50KTtcbiAgdmFyIGRpc3BhdGNoUXVldWUgPSBbXTtcbiAgZXh0cmFjdEV2ZW50cyQ1KGRpc3BhdGNoUXVldWUsIGRvbUV2ZW50TmFtZSwgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0LCBldmVudFN5c3RlbUZsYWdzKTtcbiAgcHJvY2Vzc0Rpc3BhdGNoUXVldWUoZGlzcGF0Y2hRdWV1ZSwgZXZlbnRTeXN0ZW1GbGFncyk7XG59XG5cbmZ1bmN0aW9uIGxpc3RlblRvTm9uRGVsZWdhdGVkRXZlbnQoZG9tRXZlbnROYW1lLCB0YXJnZXRFbGVtZW50KSB7XG4gIHZhciBpc0NhcHR1cmVQaGFzZUxpc3RlbmVyID0gZmFsc2U7XG4gIHZhciBsaXN0ZW5lclNldCA9IGdldEV2ZW50TGlzdGVuZXJTZXQodGFyZ2V0RWxlbWVudCk7XG4gIHZhciBsaXN0ZW5lclNldEtleSA9IGdldExpc3RlbmVyU2V0S2V5KGRvbUV2ZW50TmFtZSwgaXNDYXB0dXJlUGhhc2VMaXN0ZW5lcik7XG5cbiAgaWYgKCFsaXN0ZW5lclNldC5oYXMobGlzdGVuZXJTZXRLZXkpKSB7XG4gICAgYWRkVHJhcHBlZEV2ZW50TGlzdGVuZXIodGFyZ2V0RWxlbWVudCwgZG9tRXZlbnROYW1lLCBJU19OT05fREVMRUdBVEVELCBpc0NhcHR1cmVQaGFzZUxpc3RlbmVyKTtcbiAgICBsaXN0ZW5lclNldC5hZGQobGlzdGVuZXJTZXRLZXkpO1xuICB9XG59XG52YXIgbGlzdGVuaW5nTWFya2VyID0gJ19yZWFjdExpc3RlbmluZycgKyBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zbGljZSgyKTtcbmZ1bmN0aW9uIGxpc3RlblRvQWxsU3VwcG9ydGVkRXZlbnRzKHJvb3RDb250YWluZXJFbGVtZW50KSB7XG4gIHtcbiAgICBpZiAocm9vdENvbnRhaW5lckVsZW1lbnRbbGlzdGVuaW5nTWFya2VyXSkge1xuICAgICAgLy8gUGVyZm9ybWFuY2Ugb3B0aW1pemF0aW9uOiBkb24ndCBpdGVyYXRlIHRocm91Z2ggZXZlbnRzXG4gICAgICAvLyBmb3IgdGhlIHNhbWUgcG9ydGFsIGNvbnRhaW5lciBvciByb290IG5vZGUgbW9yZSB0aGFuIG9uY2UuXG4gICAgICAvLyBUT0RPOiBvbmNlIHdlIHJlbW92ZSB0aGUgZmxhZywgd2UgbWF5IGJlIGFibGUgdG8gYWxzb1xuICAgICAgLy8gcmVtb3ZlIHNvbWUgb2YgdGhlIGJvb2trZWVwaW5nIG1hcHMgdXNlZCBmb3IgbGF6aW5lc3MuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgcm9vdENvbnRhaW5lckVsZW1lbnRbbGlzdGVuaW5nTWFya2VyXSA9IHRydWU7XG4gICAgYWxsTmF0aXZlRXZlbnRzLmZvckVhY2goZnVuY3Rpb24gKGRvbUV2ZW50TmFtZSkge1xuICAgICAgaWYgKCFub25EZWxlZ2F0ZWRFdmVudHMuaGFzKGRvbUV2ZW50TmFtZSkpIHtcbiAgICAgICAgbGlzdGVuVG9OYXRpdmVFdmVudChkb21FdmVudE5hbWUsIGZhbHNlLCByb290Q29udGFpbmVyRWxlbWVudCwgbnVsbCk7XG4gICAgICB9XG5cbiAgICAgIGxpc3RlblRvTmF0aXZlRXZlbnQoZG9tRXZlbnROYW1lLCB0cnVlLCByb290Q29udGFpbmVyRWxlbWVudCwgbnVsbCk7XG4gICAgfSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGxpc3RlblRvTmF0aXZlRXZlbnQoZG9tRXZlbnROYW1lLCBpc0NhcHR1cmVQaGFzZUxpc3RlbmVyLCByb290Q29udGFpbmVyRWxlbWVudCwgdGFyZ2V0RWxlbWVudCkge1xuICB2YXIgZXZlbnRTeXN0ZW1GbGFncyA9IGFyZ3VtZW50cy5sZW5ndGggPiA0ICYmIGFyZ3VtZW50c1s0XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzRdIDogMDtcbiAgdmFyIHRhcmdldCA9IHJvb3RDb250YWluZXJFbGVtZW50OyAvLyBzZWxlY3Rpb25jaGFuZ2UgbmVlZHMgdG8gYmUgYXR0YWNoZWQgdG8gdGhlIGRvY3VtZW50XG4gIC8vIG90aGVyd2lzZSBpdCB3b24ndCBjYXB0dXJlIGluY29taW5nIGV2ZW50cyB0aGF0IGFyZSBvbmx5XG4gIC8vIHRyaWdnZXJlZCBvbiB0aGUgZG9jdW1lbnQgZGlyZWN0bHkuXG5cbiAgaWYgKGRvbUV2ZW50TmFtZSA9PT0gJ3NlbGVjdGlvbmNoYW5nZScgJiYgcm9vdENvbnRhaW5lckVsZW1lbnQubm9kZVR5cGUgIT09IERPQ1VNRU5UX05PREUpIHtcbiAgICB0YXJnZXQgPSByb290Q29udGFpbmVyRWxlbWVudC5vd25lckRvY3VtZW50O1xuICB9IC8vIElmIHRoZSBldmVudCBjYW4gYmUgZGVsZWdhdGVkIChvciBpcyBjYXB0dXJlIHBoYXNlKSwgd2UgY2FuXG4gIC8vIHJlZ2lzdGVyIGl0IHRvIHRoZSByb290IGNvbnRhaW5lci4gT3RoZXJ3aXNlLCB3ZSBzaG91bGRcbiAgLy8gcmVnaXN0ZXIgdGhlIGV2ZW50IHRvIHRoZSB0YXJnZXQgZWxlbWVudCBhbmQgbWFyayBpdCBhc1xuICAvLyBhIG5vbi1kZWxlZ2F0ZWQgZXZlbnQuXG5cblxuICBpZiAodGFyZ2V0RWxlbWVudCAhPT0gbnVsbCAmJiAhaXNDYXB0dXJlUGhhc2VMaXN0ZW5lciAmJiBub25EZWxlZ2F0ZWRFdmVudHMuaGFzKGRvbUV2ZW50TmFtZSkpIHtcbiAgICAvLyBGb3IgYWxsIG5vbi1kZWxlZ2F0ZWQgZXZlbnRzLCBhcGFydCBmcm9tIHNjcm9sbCwgd2UgYXR0YWNoXG4gICAgLy8gdGhlaXIgZXZlbnQgbGlzdGVuZXJzIHRvIHRoZSByZXNwZWN0aXZlIGVsZW1lbnRzIHRoYXQgdGhlaXJcbiAgICAvLyBldmVudHMgZmlyZSBvbi4gVGhhdCBtZWFucyB3ZSBjYW4gc2tpcCB0aGlzIHN0ZXAsIGFzIGV2ZW50XG4gICAgLy8gbGlzdGVuZXIgaGFzIGFscmVhZHkgYmVlbiBhZGRlZCBwcmV2aW91c2x5LiBIb3dldmVyLCB3ZVxuICAgIC8vIHNwZWNpYWwgY2FzZSB0aGUgc2Nyb2xsIGV2ZW50IGJlY2F1c2UgdGhlIHJlYWxpdHkgaXMgdGhhdCBhbnlcbiAgICAvLyBlbGVtZW50IGNhbiBzY3JvbGwuXG4gICAgLy8gVE9ETzogaWRlYWxseSwgd2UnZCBldmVudHVhbGx5IGFwcGx5IHRoZSBzYW1lIGxvZ2ljIHRvIGFsbFxuICAgIC8vIGV2ZW50cyBmcm9tIHRoZSBub25EZWxlZ2F0ZWRFdmVudHMgbGlzdC4gVGhlbiB3ZSBjYW4gcmVtb3ZlXG4gICAgLy8gdGhpcyBzcGVjaWFsIGNhc2UgYW5kIHVzZSB0aGUgc2FtZSBsb2dpYyBmb3IgYWxsIGV2ZW50cy5cbiAgICBpZiAoZG9tRXZlbnROYW1lICE9PSAnc2Nyb2xsJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGV2ZW50U3lzdGVtRmxhZ3MgfD0gSVNfTk9OX0RFTEVHQVRFRDtcbiAgICB0YXJnZXQgPSB0YXJnZXRFbGVtZW50O1xuICB9XG5cbiAgdmFyIGxpc3RlbmVyU2V0ID0gZ2V0RXZlbnRMaXN0ZW5lclNldCh0YXJnZXQpO1xuICB2YXIgbGlzdGVuZXJTZXRLZXkgPSBnZXRMaXN0ZW5lclNldEtleShkb21FdmVudE5hbWUsIGlzQ2FwdHVyZVBoYXNlTGlzdGVuZXIpOyAvLyBJZiB0aGUgbGlzdGVuZXIgZW50cnkgaXMgZW1wdHkgb3Igd2Ugc2hvdWxkIHVwZ3JhZGUsIHRoZW5cbiAgLy8gd2UgbmVlZCB0byB0cmFwIGFuIGV2ZW50IGxpc3RlbmVyIG9udG8gdGhlIHRhcmdldC5cblxuICBpZiAoIWxpc3RlbmVyU2V0LmhhcyhsaXN0ZW5lclNldEtleSkpIHtcbiAgICBpZiAoaXNDYXB0dXJlUGhhc2VMaXN0ZW5lcikge1xuICAgICAgZXZlbnRTeXN0ZW1GbGFncyB8PSBJU19DQVBUVVJFX1BIQVNFO1xuICAgIH1cblxuICAgIGFkZFRyYXBwZWRFdmVudExpc3RlbmVyKHRhcmdldCwgZG9tRXZlbnROYW1lLCBldmVudFN5c3RlbUZsYWdzLCBpc0NhcHR1cmVQaGFzZUxpc3RlbmVyKTtcbiAgICBsaXN0ZW5lclNldC5hZGQobGlzdGVuZXJTZXRLZXkpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGFkZFRyYXBwZWRFdmVudExpc3RlbmVyKHRhcmdldENvbnRhaW5lciwgZG9tRXZlbnROYW1lLCBldmVudFN5c3RlbUZsYWdzLCBpc0NhcHR1cmVQaGFzZUxpc3RlbmVyLCBpc0RlZmVycmVkTGlzdGVuZXJGb3JMZWdhY3lGQlN1cHBvcnQpIHtcbiAgdmFyIGxpc3RlbmVyID0gY3JlYXRlRXZlbnRMaXN0ZW5lcldyYXBwZXJXaXRoUHJpb3JpdHkodGFyZ2V0Q29udGFpbmVyLCBkb21FdmVudE5hbWUsIGV2ZW50U3lzdGVtRmxhZ3MpOyAvLyBJZiBwYXNzaXZlIG9wdGlvbiBpcyBub3Qgc3VwcG9ydGVkLCB0aGVuIHRoZSBldmVudCB3aWxsIGJlXG4gIC8vIGFjdGl2ZSBhbmQgbm90IHBhc3NpdmUuXG5cbiAgdmFyIGlzUGFzc2l2ZUxpc3RlbmVyID0gdW5kZWZpbmVkO1xuXG4gIGlmIChwYXNzaXZlQnJvd3NlckV2ZW50c1N1cHBvcnRlZCkge1xuICAgIC8vIEJyb3dzZXJzIGludHJvZHVjZWQgYW4gaW50ZXJ2ZW50aW9uLCBtYWtpbmcgdGhlc2UgZXZlbnRzXG4gICAgLy8gcGFzc2l2ZSBieSBkZWZhdWx0IG9uIGRvY3VtZW50LiBSZWFjdCBkb2Vzbid0IGJpbmQgdGhlbVxuICAgIC8vIHRvIGRvY3VtZW50IGFueW1vcmUsIGJ1dCBjaGFuZ2luZyB0aGlzIG5vdyB3b3VsZCB1bmRvXG4gICAgLy8gdGhlIHBlcmZvcm1hbmNlIHdpbnMgZnJvbSB0aGUgY2hhbmdlLiBTbyB3ZSBlbXVsYXRlXG4gICAgLy8gdGhlIGV4aXN0aW5nIGJlaGF2aW9yIG1hbnVhbGx5IG9uIHRoZSByb290cyBub3cuXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xOTY1MVxuICAgIGlmIChkb21FdmVudE5hbWUgPT09ICd0b3VjaHN0YXJ0JyB8fCBkb21FdmVudE5hbWUgPT09ICd0b3VjaG1vdmUnIHx8IGRvbUV2ZW50TmFtZSA9PT0gJ3doZWVsJykge1xuICAgICAgaXNQYXNzaXZlTGlzdGVuZXIgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHRhcmdldENvbnRhaW5lciA9ICB0YXJnZXRDb250YWluZXI7XG4gIHZhciB1bnN1YnNjcmliZUxpc3RlbmVyOyAvLyBXaGVuIGxlZ2FjeUZCU3VwcG9ydCBpcyBlbmFibGVkLCBpdCdzIGZvciB3aGVuIHdlXG5cblxuICBpZiAoaXNDYXB0dXJlUGhhc2VMaXN0ZW5lcikge1xuICAgIGlmIChpc1Bhc3NpdmVMaXN0ZW5lciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB1bnN1YnNjcmliZUxpc3RlbmVyID0gYWRkRXZlbnRDYXB0dXJlTGlzdGVuZXJXaXRoUGFzc2l2ZUZsYWcodGFyZ2V0Q29udGFpbmVyLCBkb21FdmVudE5hbWUsIGxpc3RlbmVyLCBpc1Bhc3NpdmVMaXN0ZW5lcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHVuc3Vic2NyaWJlTGlzdGVuZXIgPSBhZGRFdmVudENhcHR1cmVMaXN0ZW5lcih0YXJnZXRDb250YWluZXIsIGRvbUV2ZW50TmFtZSwgbGlzdGVuZXIpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoaXNQYXNzaXZlTGlzdGVuZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdW5zdWJzY3JpYmVMaXN0ZW5lciA9IGFkZEV2ZW50QnViYmxlTGlzdGVuZXJXaXRoUGFzc2l2ZUZsYWcodGFyZ2V0Q29udGFpbmVyLCBkb21FdmVudE5hbWUsIGxpc3RlbmVyLCBpc1Bhc3NpdmVMaXN0ZW5lcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHVuc3Vic2NyaWJlTGlzdGVuZXIgPSBhZGRFdmVudEJ1YmJsZUxpc3RlbmVyKHRhcmdldENvbnRhaW5lciwgZG9tRXZlbnROYW1lLCBsaXN0ZW5lcik7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGlzTWF0Y2hpbmdSb290Q29udGFpbmVyKGdyYW5kQ29udGFpbmVyLCB0YXJnZXRDb250YWluZXIpIHtcbiAgcmV0dXJuIGdyYW5kQ29udGFpbmVyID09PSB0YXJnZXRDb250YWluZXIgfHwgZ3JhbmRDb250YWluZXIubm9kZVR5cGUgPT09IENPTU1FTlRfTk9ERSAmJiBncmFuZENvbnRhaW5lci5wYXJlbnROb2RlID09PSB0YXJnZXRDb250YWluZXI7XG59XG5cbmZ1bmN0aW9uIGRpc3BhdGNoRXZlbnRGb3JQbHVnaW5FdmVudFN5c3RlbShkb21FdmVudE5hbWUsIGV2ZW50U3lzdGVtRmxhZ3MsIG5hdGl2ZUV2ZW50LCB0YXJnZXRJbnN0LCB0YXJnZXRDb250YWluZXIpIHtcbiAgdmFyIGFuY2VzdG9ySW5zdCA9IHRhcmdldEluc3Q7XG5cbiAgaWYgKChldmVudFN5c3RlbUZsYWdzICYgSVNfRVZFTlRfSEFORExFX05PTl9NQU5BR0VEX05PREUpID09PSAwICYmIChldmVudFN5c3RlbUZsYWdzICYgSVNfTk9OX0RFTEVHQVRFRCkgPT09IDApIHtcbiAgICB2YXIgdGFyZ2V0Q29udGFpbmVyTm9kZSA9IHRhcmdldENvbnRhaW5lcjsgLy8gSWYgd2UgYXJlIHVzaW5nIHRoZSBsZWdhY3kgRkIgc3VwcG9ydCBmbGFnLCB3ZVxuXG4gICAgaWYgKHRhcmdldEluc3QgIT09IG51bGwpIHtcbiAgICAgIC8vIFRoZSBiZWxvdyBsb2dpYyBhdHRlbXB0cyB0byB3b3JrIG91dCBpZiB3ZSBuZWVkIHRvIGNoYW5nZVxuICAgICAgLy8gdGhlIHRhcmdldCBmaWJlciB0byBhIGRpZmZlcmVudCBhbmNlc3Rvci4gV2UgaGFkIHNpbWlsYXIgbG9naWNcbiAgICAgIC8vIGluIHRoZSBsZWdhY3kgZXZlbnQgc3lzdGVtLCBleGNlcHQgdGhlIGJpZyBkaWZmZXJlbmNlIGJldHdlZW5cbiAgICAgIC8vIHN5c3RlbXMgaXMgdGhhdCB0aGUgbW9kZXJuIGV2ZW50IHN5c3RlbSBub3cgaGFzIGFuIGV2ZW50IGxpc3RlbmVyXG4gICAgICAvLyBhdHRhY2hlZCB0byBlYWNoIFJlYWN0IFJvb3QgYW5kIFJlYWN0IFBvcnRhbCBSb290LiBUb2dldGhlcixcbiAgICAgIC8vIHRoZSBET00gbm9kZXMgcmVwcmVzZW50aW5nIHRoZXNlIHJvb3RzIGFyZSB0aGUgXCJyb290Q29udGFpbmVyXCIuXG4gICAgICAvLyBUbyBmaWd1cmUgb3V0IHdoaWNoIGFuY2VzdG9yIGluc3RhbmNlIHdlIHNob3VsZCB1c2UsIHdlIHRyYXZlcnNlXG4gICAgICAvLyB1cCB0aGUgZmliZXIgdHJlZSBmcm9tIHRoZSB0YXJnZXQgaW5zdGFuY2UgYW5kIGF0dGVtcHQgdG8gZmluZFxuICAgICAgLy8gcm9vdCBib3VuZGFyaWVzIHRoYXQgbWF0Y2ggdGhhdCBvZiBvdXIgY3VycmVudCBcInJvb3RDb250YWluZXJcIi5cbiAgICAgIC8vIElmIHdlIGZpbmQgdGhhdCBcInJvb3RDb250YWluZXJcIiwgd2UgZmluZCB0aGUgcGFyZW50IGZpYmVyXG4gICAgICAvLyBzdWItdHJlZSBmb3IgdGhhdCByb290IGFuZCBtYWtlIHRoYXQgb3VyIGFuY2VzdG9yIGluc3RhbmNlLlxuICAgICAgdmFyIG5vZGUgPSB0YXJnZXRJbnN0O1xuXG4gICAgICBtYWluTG9vcDogd2hpbGUgKHRydWUpIHtcbiAgICAgICAgaWYgKG5vZGUgPT09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbm9kZVRhZyA9IG5vZGUudGFnO1xuXG4gICAgICAgIGlmIChub2RlVGFnID09PSBIb3N0Um9vdCB8fCBub2RlVGFnID09PSBIb3N0UG9ydGFsKSB7XG4gICAgICAgICAgdmFyIGNvbnRhaW5lciA9IG5vZGUuc3RhdGVOb2RlLmNvbnRhaW5lckluZm87XG5cbiAgICAgICAgICBpZiAoaXNNYXRjaGluZ1Jvb3RDb250YWluZXIoY29udGFpbmVyLCB0YXJnZXRDb250YWluZXJOb2RlKSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKG5vZGVUYWcgPT09IEhvc3RQb3J0YWwpIHtcbiAgICAgICAgICAgIC8vIFRoZSB0YXJnZXQgaXMgYSBwb3J0YWwsIGJ1dCBpdCdzIG5vdCB0aGUgcm9vdENvbnRhaW5lciB3ZSdyZSBsb29raW5nIGZvci5cbiAgICAgICAgICAgIC8vIE5vcm1hbGx5IHBvcnRhbHMgaGFuZGxlIHRoZWlyIG93biBldmVudHMgYWxsIHRoZSB3YXkgZG93biB0byB0aGUgcm9vdC5cbiAgICAgICAgICAgIC8vIFNvIHdlIHNob3VsZCBiZSBhYmxlIHRvIHN0b3Agbm93LiBIb3dldmVyLCB3ZSBkb24ndCBrbm93IGlmIHRoaXMgcG9ydGFsXG4gICAgICAgICAgICAvLyB3YXMgcGFydCBvZiAqb3VyKiByb290LlxuICAgICAgICAgICAgdmFyIGdyYW5kTm9kZSA9IG5vZGUucmV0dXJuO1xuXG4gICAgICAgICAgICB3aGlsZSAoZ3JhbmROb2RlICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgIHZhciBncmFuZFRhZyA9IGdyYW5kTm9kZS50YWc7XG5cbiAgICAgICAgICAgICAgaWYgKGdyYW5kVGFnID09PSBIb3N0Um9vdCB8fCBncmFuZFRhZyA9PT0gSG9zdFBvcnRhbCkge1xuICAgICAgICAgICAgICAgIHZhciBncmFuZENvbnRhaW5lciA9IGdyYW5kTm9kZS5zdGF0ZU5vZGUuY29udGFpbmVySW5mbztcblxuICAgICAgICAgICAgICAgIGlmIChpc01hdGNoaW5nUm9vdENvbnRhaW5lcihncmFuZENvbnRhaW5lciwgdGFyZ2V0Q29udGFpbmVyTm9kZSkpIHtcbiAgICAgICAgICAgICAgICAgIC8vIFRoaXMgaXMgdGhlIHJvb3RDb250YWluZXIgd2UncmUgbG9va2luZyBmb3IgYW5kIHdlIGZvdW5kIGl0IGFzXG4gICAgICAgICAgICAgICAgICAvLyBhIHBhcmVudCBvZiB0aGUgUG9ydGFsLiBUaGF0IG1lYW5zIHdlIGNhbiBpZ25vcmUgaXQgYmVjYXVzZSB0aGVcbiAgICAgICAgICAgICAgICAgIC8vIFBvcnRhbCB3aWxsIGJ1YmJsZSB0aHJvdWdoIHRvIHVzLlxuICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGdyYW5kTm9kZSA9IGdyYW5kTm9kZS5yZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSAvLyBOb3cgd2UgbmVlZCB0byBmaW5kIGl0J3MgY29ycmVzcG9uZGluZyBob3N0IGZpYmVyIGluIHRoZSBvdGhlclxuICAgICAgICAgIC8vIHRyZWUuIFRvIGRvIHRoaXMgd2UgY2FuIHVzZSBnZXRDbG9zZXN0SW5zdGFuY2VGcm9tTm9kZSwgYnV0IHdlXG4gICAgICAgICAgLy8gbmVlZCB0byB2YWxpZGF0ZSB0aGF0IHRoZSBmaWJlciBpcyBhIGhvc3QgaW5zdGFuY2UsIG90aGVyd2lzZVxuICAgICAgICAgIC8vIHdlIG5lZWQgdG8gdHJhdmVyc2UgdXAgdGhyb3VnaCB0aGUgRE9NIHRpbGwgd2UgZmluZCB0aGUgY29ycmVjdFxuICAgICAgICAgIC8vIG5vZGUgdGhhdCBpcyBmcm9tIHRoZSBvdGhlciB0cmVlLlxuXG5cbiAgICAgICAgICB3aGlsZSAoY29udGFpbmVyICE9PSBudWxsKSB7XG4gICAgICAgICAgICB2YXIgcGFyZW50Tm9kZSA9IGdldENsb3Nlc3RJbnN0YW5jZUZyb21Ob2RlKGNvbnRhaW5lcik7XG5cbiAgICAgICAgICAgIGlmIChwYXJlbnROb2RlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHBhcmVudFRhZyA9IHBhcmVudE5vZGUudGFnO1xuXG4gICAgICAgICAgICBpZiAocGFyZW50VGFnID09PSBIb3N0Q29tcG9uZW50IHx8IHBhcmVudFRhZyA9PT0gSG9zdFRleHQpIHtcbiAgICAgICAgICAgICAgbm9kZSA9IGFuY2VzdG9ySW5zdCA9IHBhcmVudE5vZGU7XG4gICAgICAgICAgICAgIGNvbnRpbnVlIG1haW5Mb29wO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb250YWluZXIgPSBjb250YWluZXIucGFyZW50Tm9kZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBub2RlID0gbm9kZS5yZXR1cm47XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgYmF0Y2hlZEV2ZW50VXBkYXRlcyhmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGRpc3BhdGNoRXZlbnRzRm9yUGx1Z2lucyhkb21FdmVudE5hbWUsIGV2ZW50U3lzdGVtRmxhZ3MsIG5hdGl2ZUV2ZW50LCBhbmNlc3Rvckluc3QpO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlRGlzcGF0Y2hMaXN0ZW5lcihpbnN0YW5jZSwgbGlzdGVuZXIsIGN1cnJlbnRUYXJnZXQpIHtcbiAgcmV0dXJuIHtcbiAgICBpbnN0YW5jZTogaW5zdGFuY2UsXG4gICAgbGlzdGVuZXI6IGxpc3RlbmVyLFxuICAgIGN1cnJlbnRUYXJnZXQ6IGN1cnJlbnRUYXJnZXRcbiAgfTtcbn1cblxuZnVuY3Rpb24gYWNjdW11bGF0ZVNpbmdsZVBoYXNlTGlzdGVuZXJzKHRhcmdldEZpYmVyLCByZWFjdE5hbWUsIG5hdGl2ZUV2ZW50VHlwZSwgaW5DYXB0dXJlUGhhc2UsIGFjY3VtdWxhdGVUYXJnZXRPbmx5KSB7XG4gIHZhciBjYXB0dXJlTmFtZSA9IHJlYWN0TmFtZSAhPT0gbnVsbCA/IHJlYWN0TmFtZSArICdDYXB0dXJlJyA6IG51bGw7XG4gIHZhciByZWFjdEV2ZW50TmFtZSA9IGluQ2FwdHVyZVBoYXNlID8gY2FwdHVyZU5hbWUgOiByZWFjdE5hbWU7XG4gIHZhciBsaXN0ZW5lcnMgPSBbXTtcbiAgdmFyIGluc3RhbmNlID0gdGFyZ2V0RmliZXI7XG4gIHZhciBsYXN0SG9zdENvbXBvbmVudCA9IG51bGw7IC8vIEFjY3VtdWxhdGUgYWxsIGluc3RhbmNlcyBhbmQgbGlzdGVuZXJzIHZpYSB0aGUgdGFyZ2V0IC0+IHJvb3QgcGF0aC5cblxuICB3aGlsZSAoaW5zdGFuY2UgIT09IG51bGwpIHtcbiAgICB2YXIgX2luc3RhbmNlMiA9IGluc3RhbmNlLFxuICAgICAgICBzdGF0ZU5vZGUgPSBfaW5zdGFuY2UyLnN0YXRlTm9kZSxcbiAgICAgICAgdGFnID0gX2luc3RhbmNlMi50YWc7IC8vIEhhbmRsZSBsaXN0ZW5lcnMgdGhhdCBhcmUgb24gSG9zdENvbXBvbmVudHMgKGkuZS4gPGRpdj4pXG5cbiAgICBpZiAodGFnID09PSBIb3N0Q29tcG9uZW50ICYmIHN0YXRlTm9kZSAhPT0gbnVsbCkge1xuICAgICAgbGFzdEhvc3RDb21wb25lbnQgPSBzdGF0ZU5vZGU7IC8vIGNyZWF0ZUV2ZW50SGFuZGxlIGxpc3RlbmVyc1xuXG5cbiAgICAgIGlmIChyZWFjdEV2ZW50TmFtZSAhPT0gbnVsbCkge1xuICAgICAgICB2YXIgbGlzdGVuZXIgPSBnZXRMaXN0ZW5lcihpbnN0YW5jZSwgcmVhY3RFdmVudE5hbWUpO1xuXG4gICAgICAgIGlmIChsaXN0ZW5lciAhPSBudWxsKSB7XG4gICAgICAgICAgbGlzdGVuZXJzLnB1c2goY3JlYXRlRGlzcGF0Y2hMaXN0ZW5lcihpbnN0YW5jZSwgbGlzdGVuZXIsIGxhc3RIb3N0Q29tcG9uZW50KSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IC8vIElmIHdlIGFyZSBvbmx5IGFjY3VtdWxhdGluZyBldmVudHMgZm9yIHRoZSB0YXJnZXQsIHRoZW4gd2UgZG9uJ3RcbiAgICAvLyBjb250aW51ZSB0byBwcm9wYWdhdGUgdGhyb3VnaCB0aGUgUmVhY3QgZmliZXIgdHJlZSB0byBmaW5kIG90aGVyXG4gICAgLy8gbGlzdGVuZXJzLlxuXG5cbiAgICBpZiAoYWNjdW11bGF0ZVRhcmdldE9ubHkpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGluc3RhbmNlID0gaW5zdGFuY2UucmV0dXJuO1xuICB9XG5cbiAgcmV0dXJuIGxpc3RlbmVycztcbn0gLy8gV2Ugc2hvdWxkIG9ubHkgdXNlIHRoaXMgZnVuY3Rpb24gZm9yOlxuLy8gLSBCZWZvcmVJbnB1dEV2ZW50UGx1Z2luXG4vLyAtIENoYW5nZUV2ZW50UGx1Z2luXG4vLyAtIFNlbGVjdEV2ZW50UGx1Z2luXG4vLyBUaGlzIGlzIGJlY2F1c2Ugd2Ugb25seSBwcm9jZXNzIHRoZXNlIHBsdWdpbnNcbi8vIGluIHRoZSBidWJibGUgcGhhc2UsIHNvIHdlIG5lZWQgdG8gYWNjdW11bGF0ZSB0d29cbi8vIHBoYXNlIGV2ZW50IGxpc3RlbmVycyAodmlhIGVtdWxhdGlvbikuXG5cbmZ1bmN0aW9uIGFjY3VtdWxhdGVUd29QaGFzZUxpc3RlbmVycyh0YXJnZXRGaWJlciwgcmVhY3ROYW1lKSB7XG4gIHZhciBjYXB0dXJlTmFtZSA9IHJlYWN0TmFtZSArICdDYXB0dXJlJztcbiAgdmFyIGxpc3RlbmVycyA9IFtdO1xuICB2YXIgaW5zdGFuY2UgPSB0YXJnZXRGaWJlcjsgLy8gQWNjdW11bGF0ZSBhbGwgaW5zdGFuY2VzIGFuZCBsaXN0ZW5lcnMgdmlhIHRoZSB0YXJnZXQgLT4gcm9vdCBwYXRoLlxuXG4gIHdoaWxlIChpbnN0YW5jZSAhPT0gbnVsbCkge1xuICAgIHZhciBfaW5zdGFuY2UzID0gaW5zdGFuY2UsXG4gICAgICAgIHN0YXRlTm9kZSA9IF9pbnN0YW5jZTMuc3RhdGVOb2RlLFxuICAgICAgICB0YWcgPSBfaW5zdGFuY2UzLnRhZzsgLy8gSGFuZGxlIGxpc3RlbmVycyB0aGF0IGFyZSBvbiBIb3N0Q29tcG9uZW50cyAoaS5lLiA8ZGl2PilcblxuICAgIGlmICh0YWcgPT09IEhvc3RDb21wb25lbnQgJiYgc3RhdGVOb2RlICE9PSBudWxsKSB7XG4gICAgICB2YXIgY3VycmVudFRhcmdldCA9IHN0YXRlTm9kZTtcbiAgICAgIHZhciBjYXB0dXJlTGlzdGVuZXIgPSBnZXRMaXN0ZW5lcihpbnN0YW5jZSwgY2FwdHVyZU5hbWUpO1xuXG4gICAgICBpZiAoY2FwdHVyZUxpc3RlbmVyICE9IG51bGwpIHtcbiAgICAgICAgbGlzdGVuZXJzLnVuc2hpZnQoY3JlYXRlRGlzcGF0Y2hMaXN0ZW5lcihpbnN0YW5jZSwgY2FwdHVyZUxpc3RlbmVyLCBjdXJyZW50VGFyZ2V0KSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBidWJibGVMaXN0ZW5lciA9IGdldExpc3RlbmVyKGluc3RhbmNlLCByZWFjdE5hbWUpO1xuXG4gICAgICBpZiAoYnViYmxlTGlzdGVuZXIgIT0gbnVsbCkge1xuICAgICAgICBsaXN0ZW5lcnMucHVzaChjcmVhdGVEaXNwYXRjaExpc3RlbmVyKGluc3RhbmNlLCBidWJibGVMaXN0ZW5lciwgY3VycmVudFRhcmdldCkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGluc3RhbmNlID0gaW5zdGFuY2UucmV0dXJuO1xuICB9XG5cbiAgcmV0dXJuIGxpc3RlbmVycztcbn1cblxuZnVuY3Rpb24gZ2V0UGFyZW50KGluc3QpIHtcbiAgaWYgKGluc3QgPT09IG51bGwpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGRvIHtcbiAgICBpbnN0ID0gaW5zdC5yZXR1cm47IC8vIFRPRE86IElmIHRoaXMgaXMgYSBIb3N0Um9vdCB3ZSBtaWdodCB3YW50IHRvIGJhaWwgb3V0LlxuICAgIC8vIFRoYXQgaXMgZGVwZW5kaW5nIG9uIGlmIHdlIHdhbnQgbmVzdGVkIHN1YnRyZWVzIChsYXllcnMpIHRvIGJ1YmJsZVxuICAgIC8vIGV2ZW50cyB0byB0aGVpciBwYXJlbnQuIFdlIGNvdWxkIGFsc28gZ28gdGhyb3VnaCBwYXJlbnROb2RlIG9uIHRoZVxuICAgIC8vIGhvc3Qgbm9kZSBidXQgdGhhdCB3b3VsZG4ndCB3b3JrIGZvciBSZWFjdCBOYXRpdmUgYW5kIGRvZXNuJ3QgbGV0IHVzXG4gICAgLy8gZG8gdGhlIHBvcnRhbCBmZWF0dXJlLlxuICB9IHdoaWxlIChpbnN0ICYmIGluc3QudGFnICE9PSBIb3N0Q29tcG9uZW50KTtcblxuICBpZiAoaW5zdCkge1xuICAgIHJldHVybiBpbnN0O1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG4vKipcbiAqIFJldHVybiB0aGUgbG93ZXN0IGNvbW1vbiBhbmNlc3RvciBvZiBBIGFuZCBCLCBvciBudWxsIGlmIHRoZXkgYXJlIGluXG4gKiBkaWZmZXJlbnQgdHJlZXMuXG4gKi9cblxuXG5mdW5jdGlvbiBnZXRMb3dlc3RDb21tb25BbmNlc3RvcihpbnN0QSwgaW5zdEIpIHtcbiAgdmFyIG5vZGVBID0gaW5zdEE7XG4gIHZhciBub2RlQiA9IGluc3RCO1xuICB2YXIgZGVwdGhBID0gMDtcblxuICBmb3IgKHZhciB0ZW1wQSA9IG5vZGVBOyB0ZW1wQTsgdGVtcEEgPSBnZXRQYXJlbnQodGVtcEEpKSB7XG4gICAgZGVwdGhBKys7XG4gIH1cblxuICB2YXIgZGVwdGhCID0gMDtcblxuICBmb3IgKHZhciB0ZW1wQiA9IG5vZGVCOyB0ZW1wQjsgdGVtcEIgPSBnZXRQYXJlbnQodGVtcEIpKSB7XG4gICAgZGVwdGhCKys7XG4gIH0gLy8gSWYgQSBpcyBkZWVwZXIsIGNyYXdsIHVwLlxuXG5cbiAgd2hpbGUgKGRlcHRoQSAtIGRlcHRoQiA+IDApIHtcbiAgICBub2RlQSA9IGdldFBhcmVudChub2RlQSk7XG4gICAgZGVwdGhBLS07XG4gIH0gLy8gSWYgQiBpcyBkZWVwZXIsIGNyYXdsIHVwLlxuXG5cbiAgd2hpbGUgKGRlcHRoQiAtIGRlcHRoQSA+IDApIHtcbiAgICBub2RlQiA9IGdldFBhcmVudChub2RlQik7XG4gICAgZGVwdGhCLS07XG4gIH0gLy8gV2FsayBpbiBsb2Nrc3RlcCB1bnRpbCB3ZSBmaW5kIGEgbWF0Y2guXG5cblxuICB2YXIgZGVwdGggPSBkZXB0aEE7XG5cbiAgd2hpbGUgKGRlcHRoLS0pIHtcbiAgICBpZiAobm9kZUEgPT09IG5vZGVCIHx8IG5vZGVCICE9PSBudWxsICYmIG5vZGVBID09PSBub2RlQi5hbHRlcm5hdGUpIHtcbiAgICAgIHJldHVybiBub2RlQTtcbiAgICB9XG5cbiAgICBub2RlQSA9IGdldFBhcmVudChub2RlQSk7XG4gICAgbm9kZUIgPSBnZXRQYXJlbnQobm9kZUIpO1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIGFjY3VtdWxhdGVFbnRlckxlYXZlTGlzdGVuZXJzRm9yRXZlbnQoZGlzcGF0Y2hRdWV1ZSwgZXZlbnQsIHRhcmdldCwgY29tbW9uLCBpbkNhcHR1cmVQaGFzZSkge1xuICB2YXIgcmVnaXN0cmF0aW9uTmFtZSA9IGV2ZW50Ll9yZWFjdE5hbWU7XG4gIHZhciBsaXN0ZW5lcnMgPSBbXTtcbiAgdmFyIGluc3RhbmNlID0gdGFyZ2V0O1xuXG4gIHdoaWxlIChpbnN0YW5jZSAhPT0gbnVsbCkge1xuICAgIGlmIChpbnN0YW5jZSA9PT0gY29tbW9uKSB7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICB2YXIgX2luc3RhbmNlNCA9IGluc3RhbmNlLFxuICAgICAgICBhbHRlcm5hdGUgPSBfaW5zdGFuY2U0LmFsdGVybmF0ZSxcbiAgICAgICAgc3RhdGVOb2RlID0gX2luc3RhbmNlNC5zdGF0ZU5vZGUsXG4gICAgICAgIHRhZyA9IF9pbnN0YW5jZTQudGFnO1xuXG4gICAgaWYgKGFsdGVybmF0ZSAhPT0gbnVsbCAmJiBhbHRlcm5hdGUgPT09IGNvbW1vbikge1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgaWYgKHRhZyA9PT0gSG9zdENvbXBvbmVudCAmJiBzdGF0ZU5vZGUgIT09IG51bGwpIHtcbiAgICAgIHZhciBjdXJyZW50VGFyZ2V0ID0gc3RhdGVOb2RlO1xuXG4gICAgICBpZiAoaW5DYXB0dXJlUGhhc2UpIHtcbiAgICAgICAgdmFyIGNhcHR1cmVMaXN0ZW5lciA9IGdldExpc3RlbmVyKGluc3RhbmNlLCByZWdpc3RyYXRpb25OYW1lKTtcblxuICAgICAgICBpZiAoY2FwdHVyZUxpc3RlbmVyICE9IG51bGwpIHtcbiAgICAgICAgICBsaXN0ZW5lcnMudW5zaGlmdChjcmVhdGVEaXNwYXRjaExpc3RlbmVyKGluc3RhbmNlLCBjYXB0dXJlTGlzdGVuZXIsIGN1cnJlbnRUYXJnZXQpKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICghaW5DYXB0dXJlUGhhc2UpIHtcbiAgICAgICAgdmFyIGJ1YmJsZUxpc3RlbmVyID0gZ2V0TGlzdGVuZXIoaW5zdGFuY2UsIHJlZ2lzdHJhdGlvbk5hbWUpO1xuXG4gICAgICAgIGlmIChidWJibGVMaXN0ZW5lciAhPSBudWxsKSB7XG4gICAgICAgICAgbGlzdGVuZXJzLnB1c2goY3JlYXRlRGlzcGF0Y2hMaXN0ZW5lcihpbnN0YW5jZSwgYnViYmxlTGlzdGVuZXIsIGN1cnJlbnRUYXJnZXQpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGluc3RhbmNlID0gaW5zdGFuY2UucmV0dXJuO1xuICB9XG5cbiAgaWYgKGxpc3RlbmVycy5sZW5ndGggIT09IDApIHtcbiAgICBkaXNwYXRjaFF1ZXVlLnB1c2goe1xuICAgICAgZXZlbnQ6IGV2ZW50LFxuICAgICAgbGlzdGVuZXJzOiBsaXN0ZW5lcnNcbiAgICB9KTtcbiAgfVxufSAvLyBXZSBzaG91bGQgb25seSB1c2UgdGhpcyBmdW5jdGlvbiBmb3I6XG4vLyAtIEVudGVyTGVhdmVFdmVudFBsdWdpblxuLy8gVGhpcyBpcyBiZWNhdXNlIHdlIG9ubHkgcHJvY2VzcyB0aGlzIHBsdWdpblxuLy8gaW4gdGhlIGJ1YmJsZSBwaGFzZSwgc28gd2UgbmVlZCB0byBhY2N1bXVsYXRlIHR3b1xuLy8gcGhhc2UgZXZlbnQgbGlzdGVuZXJzLlxuXG5cbmZ1bmN0aW9uIGFjY3VtdWxhdGVFbnRlckxlYXZlVHdvUGhhc2VMaXN0ZW5lcnMoZGlzcGF0Y2hRdWV1ZSwgbGVhdmVFdmVudCwgZW50ZXJFdmVudCwgZnJvbSwgdG8pIHtcbiAgdmFyIGNvbW1vbiA9IGZyb20gJiYgdG8gPyBnZXRMb3dlc3RDb21tb25BbmNlc3Rvcihmcm9tLCB0bykgOiBudWxsO1xuXG4gIGlmIChmcm9tICE9PSBudWxsKSB7XG4gICAgYWNjdW11bGF0ZUVudGVyTGVhdmVMaXN0ZW5lcnNGb3JFdmVudChkaXNwYXRjaFF1ZXVlLCBsZWF2ZUV2ZW50LCBmcm9tLCBjb21tb24sIGZhbHNlKTtcbiAgfVxuXG4gIGlmICh0byAhPT0gbnVsbCAmJiBlbnRlckV2ZW50ICE9PSBudWxsKSB7XG4gICAgYWNjdW11bGF0ZUVudGVyTGVhdmVMaXN0ZW5lcnNGb3JFdmVudChkaXNwYXRjaFF1ZXVlLCBlbnRlckV2ZW50LCB0bywgY29tbW9uLCB0cnVlKTtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0TGlzdGVuZXJTZXRLZXkoZG9tRXZlbnROYW1lLCBjYXB0dXJlKSB7XG4gIHJldHVybiBkb21FdmVudE5hbWUgKyBcIl9fXCIgKyAoY2FwdHVyZSA/ICdjYXB0dXJlJyA6ICdidWJibGUnKTtcbn1cblxudmFyIGRpZFdhcm5JbnZhbGlkSHlkcmF0aW9uID0gZmFsc2U7XG52YXIgREFOR0VST1VTTFlfU0VUX0lOTkVSX0hUTUwgPSAnZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwnO1xudmFyIFNVUFBSRVNTX0NPTlRFTlRfRURJVEFCTEVfV0FSTklORyA9ICdzdXBwcmVzc0NvbnRlbnRFZGl0YWJsZVdhcm5pbmcnO1xudmFyIFNVUFBSRVNTX0hZRFJBVElPTl9XQVJOSU5HID0gJ3N1cHByZXNzSHlkcmF0aW9uV2FybmluZyc7XG52YXIgQVVUT0ZPQ1VTID0gJ2F1dG9Gb2N1cyc7XG52YXIgQ0hJTERSRU4gPSAnY2hpbGRyZW4nO1xudmFyIFNUWUxFID0gJ3N0eWxlJztcbnZhciBIVE1MJDEgPSAnX19odG1sJztcbnZhciBIVE1MX05BTUVTUEFDRSQxID0gTmFtZXNwYWNlcy5odG1sO1xudmFyIHdhcm5lZFVua25vd25UYWdzO1xudmFyIHN1cHByZXNzSHlkcmF0aW9uV2FybmluZztcbnZhciB2YWxpZGF0ZVByb3BlcnRpZXNJbkRldmVsb3BtZW50O1xudmFyIHdhcm5Gb3JUZXh0RGlmZmVyZW5jZTtcbnZhciB3YXJuRm9yUHJvcERpZmZlcmVuY2U7XG52YXIgd2FybkZvckV4dHJhQXR0cmlidXRlcztcbnZhciB3YXJuRm9ySW52YWxpZEV2ZW50TGlzdGVuZXI7XG52YXIgY2FuRGlmZlN0eWxlRm9ySHlkcmF0aW9uV2FybmluZztcbnZhciBub3JtYWxpemVNYXJrdXBGb3JUZXh0T3JBdHRyaWJ1dGU7XG52YXIgbm9ybWFsaXplSFRNTDtcblxue1xuICB3YXJuZWRVbmtub3duVGFncyA9IHtcbiAgICAvLyBUaGVyZSBhcmUgd29ya2luZyBwb2x5ZmlsbHMgZm9yIDxkaWFsb2c+LiBMZXQgcGVvcGxlIHVzZSBpdC5cbiAgICBkaWFsb2c6IHRydWUsXG4gICAgLy8gRWxlY3Ryb24gc2hpcHMgYSBjdXN0b20gPHdlYnZpZXc+IHRhZyB0byBkaXNwbGF5IGV4dGVybmFsIHdlYiBjb250ZW50IGluXG4gICAgLy8gYW4gaXNvbGF0ZWQgZnJhbWUgYW5kIHByb2Nlc3MuXG4gICAgLy8gVGhpcyB0YWcgaXMgbm90IHByZXNlbnQgaW4gbm9uIEVsZWN0cm9uIGVudmlyb25tZW50cyBzdWNoIGFzIEpTRG9tIHdoaWNoXG4gICAgLy8gaXMgb2Z0ZW4gdXNlZCBmb3IgdGVzdGluZyBwdXJwb3Nlcy5cbiAgICAvLyBAc2VlIGh0dHBzOi8vZWxlY3Ryb25qcy5vcmcvZG9jcy9hcGkvd2Vidmlldy10YWdcbiAgICB3ZWJ2aWV3OiB0cnVlXG4gIH07XG5cbiAgdmFsaWRhdGVQcm9wZXJ0aWVzSW5EZXZlbG9wbWVudCA9IGZ1bmN0aW9uICh0eXBlLCBwcm9wcykge1xuICAgIHZhbGlkYXRlUHJvcGVydGllcyh0eXBlLCBwcm9wcyk7XG4gICAgdmFsaWRhdGVQcm9wZXJ0aWVzJDEodHlwZSwgcHJvcHMpO1xuICAgIHZhbGlkYXRlUHJvcGVydGllcyQyKHR5cGUsIHByb3BzLCB7XG4gICAgICByZWdpc3RyYXRpb25OYW1lRGVwZW5kZW5jaWVzOiByZWdpc3RyYXRpb25OYW1lRGVwZW5kZW5jaWVzLFxuICAgICAgcG9zc2libGVSZWdpc3RyYXRpb25OYW1lczogcG9zc2libGVSZWdpc3RyYXRpb25OYW1lc1xuICAgIH0pO1xuICB9OyAvLyBJRSAxMSBwYXJzZXMgJiBub3JtYWxpemVzIHRoZSBzdHlsZSBhdHRyaWJ1dGUgYXMgb3Bwb3NlZCB0byBvdGhlclxuICAvLyBicm93c2Vycy4gSXQgYWRkcyBzcGFjZXMgYW5kIHNvcnRzIHRoZSBwcm9wZXJ0aWVzIGluIHNvbWVcbiAgLy8gbm9uLWFscGhhYmV0aWNhbCBvcmRlci4gSGFuZGxpbmcgdGhhdCB3b3VsZCByZXF1aXJlIHNvcnRpbmcgQ1NTXG4gIC8vIHByb3BlcnRpZXMgaW4gdGhlIGNsaWVudCAmIHNlcnZlciB2ZXJzaW9ucyBvciBhcHBseWluZ1xuICAvLyBgZXhwZWN0ZWRTdHlsZWAgdG8gYSB0ZW1wb3JhcnkgRE9NIG5vZGUgdG8gcmVhZCBpdHMgYHN0eWxlYCBhdHRyaWJ1dGVcbiAgLy8gbm9ybWFsaXplZC4gU2luY2UgaXQgb25seSBhZmZlY3RzIElFLCB3ZSdyZSBza2lwcGluZyBzdHlsZSB3YXJuaW5nc1xuICAvLyBpbiB0aGF0IGJyb3dzZXIgY29tcGxldGVseSBpbiBmYXZvciBvZiBkb2luZyBhbGwgdGhhdCB3b3JrLlxuICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xMTgwN1xuXG5cbiAgY2FuRGlmZlN0eWxlRm9ySHlkcmF0aW9uV2FybmluZyA9IGNhblVzZURPTSAmJiAhZG9jdW1lbnQuZG9jdW1lbnRNb2RlOyAvLyBIVE1MIHBhcnNpbmcgbm9ybWFsaXplcyBDUiBhbmQgQ1JMRiB0byBMRi5cbiAgLy8gSXQgYWxzbyBjYW4gdHVybiBcXHUwMDAwIGludG8gXFx1RkZGRCBpbnNpZGUgYXR0cmlidXRlcy5cbiAgLy8gaHR0cHM6Ly93d3cudzMub3JnL1RSL2h0bWw1L3NpbmdsZS1wYWdlLmh0bWwjcHJlcHJvY2Vzc2luZy10aGUtaW5wdXQtc3RyZWFtXG4gIC8vIElmIHdlIGhhdmUgYSBtaXNtYXRjaCwgaXQgbWlnaHQgYmUgY2F1c2VkIGJ5IHRoYXQuXG4gIC8vIFdlIHdpbGwgc3RpbGwgcGF0Y2ggdXAgaW4gdGhpcyBjYXNlIGJ1dCBub3QgZmlyZSB0aGUgd2FybmluZy5cblxuICB2YXIgTk9STUFMSVpFX05FV0xJTkVTX1JFR0VYID0gL1xcclxcbj8vZztcbiAgdmFyIE5PUk1BTElaRV9OVUxMX0FORF9SRVBMQUNFTUVOVF9SRUdFWCA9IC9cXHUwMDAwfFxcdUZGRkQvZztcblxuICBub3JtYWxpemVNYXJrdXBGb3JUZXh0T3JBdHRyaWJ1dGUgPSBmdW5jdGlvbiAobWFya3VwKSB7XG4gICAgdmFyIG1hcmt1cFN0cmluZyA9IHR5cGVvZiBtYXJrdXAgPT09ICdzdHJpbmcnID8gbWFya3VwIDogJycgKyBtYXJrdXA7XG4gICAgcmV0dXJuIG1hcmt1cFN0cmluZy5yZXBsYWNlKE5PUk1BTElaRV9ORVdMSU5FU19SRUdFWCwgJ1xcbicpLnJlcGxhY2UoTk9STUFMSVpFX05VTExfQU5EX1JFUExBQ0VNRU5UX1JFR0VYLCAnJyk7XG4gIH07XG5cbiAgd2FybkZvclRleHREaWZmZXJlbmNlID0gZnVuY3Rpb24gKHNlcnZlclRleHQsIGNsaWVudFRleHQpIHtcbiAgICBpZiAoZGlkV2FybkludmFsaWRIeWRyYXRpb24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgbm9ybWFsaXplZENsaWVudFRleHQgPSBub3JtYWxpemVNYXJrdXBGb3JUZXh0T3JBdHRyaWJ1dGUoY2xpZW50VGV4dCk7XG4gICAgdmFyIG5vcm1hbGl6ZWRTZXJ2ZXJUZXh0ID0gbm9ybWFsaXplTWFya3VwRm9yVGV4dE9yQXR0cmlidXRlKHNlcnZlclRleHQpO1xuXG4gICAgaWYgKG5vcm1hbGl6ZWRTZXJ2ZXJUZXh0ID09PSBub3JtYWxpemVkQ2xpZW50VGV4dCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGRpZFdhcm5JbnZhbGlkSHlkcmF0aW9uID0gdHJ1ZTtcblxuICAgIGVycm9yKCdUZXh0IGNvbnRlbnQgZGlkIG5vdCBtYXRjaC4gU2VydmVyOiBcIiVzXCIgQ2xpZW50OiBcIiVzXCInLCBub3JtYWxpemVkU2VydmVyVGV4dCwgbm9ybWFsaXplZENsaWVudFRleHQpO1xuICB9O1xuXG4gIHdhcm5Gb3JQcm9wRGlmZmVyZW5jZSA9IGZ1bmN0aW9uIChwcm9wTmFtZSwgc2VydmVyVmFsdWUsIGNsaWVudFZhbHVlKSB7XG4gICAgaWYgKGRpZFdhcm5JbnZhbGlkSHlkcmF0aW9uKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIG5vcm1hbGl6ZWRDbGllbnRWYWx1ZSA9IG5vcm1hbGl6ZU1hcmt1cEZvclRleHRPckF0dHJpYnV0ZShjbGllbnRWYWx1ZSk7XG4gICAgdmFyIG5vcm1hbGl6ZWRTZXJ2ZXJWYWx1ZSA9IG5vcm1hbGl6ZU1hcmt1cEZvclRleHRPckF0dHJpYnV0ZShzZXJ2ZXJWYWx1ZSk7XG5cbiAgICBpZiAobm9ybWFsaXplZFNlcnZlclZhbHVlID09PSBub3JtYWxpemVkQ2xpZW50VmFsdWUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBkaWRXYXJuSW52YWxpZEh5ZHJhdGlvbiA9IHRydWU7XG5cbiAgICBlcnJvcignUHJvcCBgJXNgIGRpZCBub3QgbWF0Y2guIFNlcnZlcjogJXMgQ2xpZW50OiAlcycsIHByb3BOYW1lLCBKU09OLnN0cmluZ2lmeShub3JtYWxpemVkU2VydmVyVmFsdWUpLCBKU09OLnN0cmluZ2lmeShub3JtYWxpemVkQ2xpZW50VmFsdWUpKTtcbiAgfTtcblxuICB3YXJuRm9yRXh0cmFBdHRyaWJ1dGVzID0gZnVuY3Rpb24gKGF0dHJpYnV0ZU5hbWVzKSB7XG4gICAgaWYgKGRpZFdhcm5JbnZhbGlkSHlkcmF0aW9uKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZGlkV2FybkludmFsaWRIeWRyYXRpb24gPSB0cnVlO1xuICAgIHZhciBuYW1lcyA9IFtdO1xuICAgIGF0dHJpYnV0ZU5hbWVzLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgIG5hbWVzLnB1c2gobmFtZSk7XG4gICAgfSk7XG5cbiAgICBlcnJvcignRXh0cmEgYXR0cmlidXRlcyBmcm9tIHRoZSBzZXJ2ZXI6ICVzJywgbmFtZXMpO1xuICB9O1xuXG4gIHdhcm5Gb3JJbnZhbGlkRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uIChyZWdpc3RyYXRpb25OYW1lLCBsaXN0ZW5lcikge1xuICAgIGlmIChsaXN0ZW5lciA9PT0gZmFsc2UpIHtcbiAgICAgIGVycm9yKCdFeHBlY3RlZCBgJXNgIGxpc3RlbmVyIHRvIGJlIGEgZnVuY3Rpb24sIGluc3RlYWQgZ290IGBmYWxzZWAuXFxuXFxuJyArICdJZiB5b3UgdXNlZCB0byBjb25kaXRpb25hbGx5IG9taXQgaXQgd2l0aCAlcz17Y29uZGl0aW9uICYmIHZhbHVlfSwgJyArICdwYXNzICVzPXtjb25kaXRpb24gPyB2YWx1ZSA6IHVuZGVmaW5lZH0gaW5zdGVhZC4nLCByZWdpc3RyYXRpb25OYW1lLCByZWdpc3RyYXRpb25OYW1lLCByZWdpc3RyYXRpb25OYW1lKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZXJyb3IoJ0V4cGVjdGVkIGAlc2AgbGlzdGVuZXIgdG8gYmUgYSBmdW5jdGlvbiwgaW5zdGVhZCBnb3QgYSB2YWx1ZSBvZiBgJXNgIHR5cGUuJywgcmVnaXN0cmF0aW9uTmFtZSwgdHlwZW9mIGxpc3RlbmVyKTtcbiAgICB9XG4gIH07IC8vIFBhcnNlIHRoZSBIVE1MIGFuZCByZWFkIGl0IGJhY2sgdG8gbm9ybWFsaXplIHRoZSBIVE1MIHN0cmluZyBzbyB0aGF0IGl0XG4gIC8vIGNhbiBiZSB1c2VkIGZvciBjb21wYXJpc29uLlxuXG5cbiAgbm9ybWFsaXplSFRNTCA9IGZ1bmN0aW9uIChwYXJlbnQsIGh0bWwpIHtcbiAgICAvLyBXZSBjb3VsZCBoYXZlIGNyZWF0ZWQgYSBzZXBhcmF0ZSBkb2N1bWVudCBoZXJlIHRvIGF2b2lkXG4gICAgLy8gcmUtaW5pdGlhbGl6aW5nIGN1c3RvbSBlbGVtZW50cyBpZiB0aGV5IGV4aXN0LiBCdXQgdGhpcyBicmVha3NcbiAgICAvLyBob3cgPG5vc2NyaXB0PiBpcyBiZWluZyBoYW5kbGVkLiBTbyB3ZSB1c2UgdGhlIHNhbWUgZG9jdW1lbnQuXG4gICAgLy8gU2VlIHRoZSBkaXNjdXNzaW9uIGluIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9wdWxsLzExMTU3LlxuICAgIHZhciB0ZXN0RWxlbWVudCA9IHBhcmVudC5uYW1lc3BhY2VVUkkgPT09IEhUTUxfTkFNRVNQQUNFJDEgPyBwYXJlbnQub3duZXJEb2N1bWVudC5jcmVhdGVFbGVtZW50KHBhcmVudC50YWdOYW1lKSA6IHBhcmVudC5vd25lckRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhwYXJlbnQubmFtZXNwYWNlVVJJLCBwYXJlbnQudGFnTmFtZSk7XG4gICAgdGVzdEVsZW1lbnQuaW5uZXJIVE1MID0gaHRtbDtcbiAgICByZXR1cm4gdGVzdEVsZW1lbnQuaW5uZXJIVE1MO1xuICB9O1xufVxuXG5mdW5jdGlvbiBnZXRPd25lckRvY3VtZW50RnJvbVJvb3RDb250YWluZXIocm9vdENvbnRhaW5lckVsZW1lbnQpIHtcbiAgcmV0dXJuIHJvb3RDb250YWluZXJFbGVtZW50Lm5vZGVUeXBlID09PSBET0NVTUVOVF9OT0RFID8gcm9vdENvbnRhaW5lckVsZW1lbnQgOiByb290Q29udGFpbmVyRWxlbWVudC5vd25lckRvY3VtZW50O1xufVxuXG5mdW5jdGlvbiBub29wKCkge31cblxuZnVuY3Rpb24gdHJhcENsaWNrT25Ob25JbnRlcmFjdGl2ZUVsZW1lbnQobm9kZSkge1xuICAvLyBNb2JpbGUgU2FmYXJpIGRvZXMgbm90IGZpcmUgcHJvcGVybHkgYnViYmxlIGNsaWNrIGV2ZW50cyBvblxuICAvLyBub24taW50ZXJhY3RpdmUgZWxlbWVudHMsIHdoaWNoIG1lYW5zIGRlbGVnYXRlZCBjbGljayBsaXN0ZW5lcnMgZG8gbm90XG4gIC8vIGZpcmUuIFRoZSB3b3JrYXJvdW5kIGZvciB0aGlzIGJ1ZyBpbnZvbHZlcyBhdHRhY2hpbmcgYW4gZW1wdHkgY2xpY2tcbiAgLy8gbGlzdGVuZXIgb24gdGhlIHRhcmdldCBub2RlLlxuICAvLyBodHRwczovL3d3dy5xdWlya3Ntb2RlLm9yZy9ibG9nL2FyY2hpdmVzLzIwMTAvMDkvY2xpY2tfZXZlbnRfZGVsLmh0bWxcbiAgLy8gSnVzdCBzZXQgaXQgdXNpbmcgdGhlIG9uY2xpY2sgcHJvcGVydHkgc28gdGhhdCB3ZSBkb24ndCBoYXZlIHRvIG1hbmFnZSBhbnlcbiAgLy8gYm9va2tlZXBpbmcgZm9yIGl0LiBOb3Qgc3VyZSBpZiB3ZSBuZWVkIHRvIGNsZWFyIGl0IHdoZW4gdGhlIGxpc3RlbmVyIGlzXG4gIC8vIHJlbW92ZWQuXG4gIC8vIFRPRE86IE9ubHkgZG8gdGhpcyBmb3IgdGhlIHJlbGV2YW50IFNhZmFyaXMgbWF5YmU/XG4gIG5vZGUub25jbGljayA9IG5vb3A7XG59XG5cbmZ1bmN0aW9uIHNldEluaXRpYWxET01Qcm9wZXJ0aWVzKHRhZywgZG9tRWxlbWVudCwgcm9vdENvbnRhaW5lckVsZW1lbnQsIG5leHRQcm9wcywgaXNDdXN0b21Db21wb25lbnRUYWcpIHtcbiAgZm9yICh2YXIgcHJvcEtleSBpbiBuZXh0UHJvcHMpIHtcbiAgICBpZiAoIW5leHRQcm9wcy5oYXNPd25Qcm9wZXJ0eShwcm9wS2V5KSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgdmFyIG5leHRQcm9wID0gbmV4dFByb3BzW3Byb3BLZXldO1xuXG4gICAgaWYgKHByb3BLZXkgPT09IFNUWUxFKSB7XG4gICAgICB7XG4gICAgICAgIGlmIChuZXh0UHJvcCkge1xuICAgICAgICAgIC8vIEZyZWV6ZSB0aGUgbmV4dCBzdHlsZSBvYmplY3Qgc28gdGhhdCB3ZSBjYW4gYXNzdW1lIGl0IHdvbid0IGJlXG4gICAgICAgICAgLy8gbXV0YXRlZC4gV2UgaGF2ZSBhbHJlYWR5IHdhcm5lZCBmb3IgdGhpcyBpbiB0aGUgcGFzdC5cbiAgICAgICAgICBPYmplY3QuZnJlZXplKG5leHRQcm9wKTtcbiAgICAgICAgfVxuICAgICAgfSAvLyBSZWxpZXMgb24gYHVwZGF0ZVN0eWxlc0J5SURgIG5vdCBtdXRhdGluZyBgc3R5bGVVcGRhdGVzYC5cblxuXG4gICAgICBzZXRWYWx1ZUZvclN0eWxlcyhkb21FbGVtZW50LCBuZXh0UHJvcCk7XG4gICAgfSBlbHNlIGlmIChwcm9wS2V5ID09PSBEQU5HRVJPVVNMWV9TRVRfSU5ORVJfSFRNTCkge1xuICAgICAgdmFyIG5leHRIdG1sID0gbmV4dFByb3AgPyBuZXh0UHJvcFtIVE1MJDFdIDogdW5kZWZpbmVkO1xuXG4gICAgICBpZiAobmV4dEh0bWwgIT0gbnVsbCkge1xuICAgICAgICBzZXRJbm5lckhUTUwoZG9tRWxlbWVudCwgbmV4dEh0bWwpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocHJvcEtleSA9PT0gQ0hJTERSRU4pIHtcbiAgICAgIGlmICh0eXBlb2YgbmV4dFByb3AgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIC8vIEF2b2lkIHNldHRpbmcgaW5pdGlhbCB0ZXh0Q29udGVudCB3aGVuIHRoZSB0ZXh0IGlzIGVtcHR5LiBJbiBJRTExIHNldHRpbmdcbiAgICAgICAgLy8gdGV4dENvbnRlbnQgb24gYSA8dGV4dGFyZWE+IHdpbGwgY2F1c2UgdGhlIHBsYWNlaG9sZGVyIHRvIG5vdFxuICAgICAgICAvLyBzaG93IHdpdGhpbiB0aGUgPHRleHRhcmVhPiB1bnRpbCBpdCBoYXMgYmVlbiBmb2N1c2VkIGFuZCBibHVycmVkIGFnYWluLlxuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzY3MzEjaXNzdWVjb21tZW50LTI1NDg3NDU1M1xuICAgICAgICB2YXIgY2FuU2V0VGV4dENvbnRlbnQgPSB0YWcgIT09ICd0ZXh0YXJlYScgfHwgbmV4dFByb3AgIT09ICcnO1xuXG4gICAgICAgIGlmIChjYW5TZXRUZXh0Q29udGVudCkge1xuICAgICAgICAgIHNldFRleHRDb250ZW50KGRvbUVsZW1lbnQsIG5leHRQcm9wKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgbmV4dFByb3AgPT09ICdudW1iZXInKSB7XG4gICAgICAgIHNldFRleHRDb250ZW50KGRvbUVsZW1lbnQsICcnICsgbmV4dFByb3ApO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocHJvcEtleSA9PT0gU1VQUFJFU1NfQ09OVEVOVF9FRElUQUJMRV9XQVJOSU5HIHx8IHByb3BLZXkgPT09IFNVUFBSRVNTX0hZRFJBVElPTl9XQVJOSU5HKSA7IGVsc2UgaWYgKHByb3BLZXkgPT09IEFVVE9GT0NVUykgOyBlbHNlIGlmIChyZWdpc3RyYXRpb25OYW1lRGVwZW5kZW5jaWVzLmhhc093blByb3BlcnR5KHByb3BLZXkpKSB7XG4gICAgICBpZiAobmV4dFByb3AgIT0gbnVsbCkge1xuICAgICAgICBpZiAoIHR5cGVvZiBuZXh0UHJvcCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHdhcm5Gb3JJbnZhbGlkRXZlbnRMaXN0ZW5lcihwcm9wS2V5LCBuZXh0UHJvcCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocHJvcEtleSA9PT0gJ29uU2Nyb2xsJykge1xuICAgICAgICAgIGxpc3RlblRvTm9uRGVsZWdhdGVkRXZlbnQoJ3Njcm9sbCcsIGRvbUVsZW1lbnQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChuZXh0UHJvcCAhPSBudWxsKSB7XG4gICAgICBzZXRWYWx1ZUZvclByb3BlcnR5KGRvbUVsZW1lbnQsIHByb3BLZXksIG5leHRQcm9wLCBpc0N1c3RvbUNvbXBvbmVudFRhZyk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZURPTVByb3BlcnRpZXMoZG9tRWxlbWVudCwgdXBkYXRlUGF5bG9hZCwgd2FzQ3VzdG9tQ29tcG9uZW50VGFnLCBpc0N1c3RvbUNvbXBvbmVudFRhZykge1xuICAvLyBUT0RPOiBIYW5kbGUgd2FzQ3VzdG9tQ29tcG9uZW50VGFnXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdXBkYXRlUGF5bG9hZC5sZW5ndGg7IGkgKz0gMikge1xuICAgIHZhciBwcm9wS2V5ID0gdXBkYXRlUGF5bG9hZFtpXTtcbiAgICB2YXIgcHJvcFZhbHVlID0gdXBkYXRlUGF5bG9hZFtpICsgMV07XG5cbiAgICBpZiAocHJvcEtleSA9PT0gU1RZTEUpIHtcbiAgICAgIHNldFZhbHVlRm9yU3R5bGVzKGRvbUVsZW1lbnQsIHByb3BWYWx1ZSk7XG4gICAgfSBlbHNlIGlmIChwcm9wS2V5ID09PSBEQU5HRVJPVVNMWV9TRVRfSU5ORVJfSFRNTCkge1xuICAgICAgc2V0SW5uZXJIVE1MKGRvbUVsZW1lbnQsIHByb3BWYWx1ZSk7XG4gICAgfSBlbHNlIGlmIChwcm9wS2V5ID09PSBDSElMRFJFTikge1xuICAgICAgc2V0VGV4dENvbnRlbnQoZG9tRWxlbWVudCwgcHJvcFZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2V0VmFsdWVGb3JQcm9wZXJ0eShkb21FbGVtZW50LCBwcm9wS2V5LCBwcm9wVmFsdWUsIGlzQ3VzdG9tQ29tcG9uZW50VGFnKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlRWxlbWVudCh0eXBlLCBwcm9wcywgcm9vdENvbnRhaW5lckVsZW1lbnQsIHBhcmVudE5hbWVzcGFjZSkge1xuICB2YXIgaXNDdXN0b21Db21wb25lbnRUYWc7IC8vIFdlIGNyZWF0ZSB0YWdzIGluIHRoZSBuYW1lc3BhY2Ugb2YgdGhlaXIgcGFyZW50IGNvbnRhaW5lciwgZXhjZXB0IEhUTUxcbiAgLy8gdGFncyBnZXQgbm8gbmFtZXNwYWNlLlxuXG4gIHZhciBvd25lckRvY3VtZW50ID0gZ2V0T3duZXJEb2N1bWVudEZyb21Sb290Q29udGFpbmVyKHJvb3RDb250YWluZXJFbGVtZW50KTtcbiAgdmFyIGRvbUVsZW1lbnQ7XG4gIHZhciBuYW1lc3BhY2VVUkkgPSBwYXJlbnROYW1lc3BhY2U7XG5cbiAgaWYgKG5hbWVzcGFjZVVSSSA9PT0gSFRNTF9OQU1FU1BBQ0UkMSkge1xuICAgIG5hbWVzcGFjZVVSSSA9IGdldEludHJpbnNpY05hbWVzcGFjZSh0eXBlKTtcbiAgfVxuXG4gIGlmIChuYW1lc3BhY2VVUkkgPT09IEhUTUxfTkFNRVNQQUNFJDEpIHtcbiAgICB7XG4gICAgICBpc0N1c3RvbUNvbXBvbmVudFRhZyA9IGlzQ3VzdG9tQ29tcG9uZW50KHR5cGUsIHByb3BzKTsgLy8gU2hvdWxkIHRoaXMgY2hlY2sgYmUgZ2F0ZWQgYnkgcGFyZW50IG5hbWVzcGFjZT8gTm90IHN1cmUgd2Ugd2FudCB0b1xuICAgICAgLy8gYWxsb3cgPFNWRz4gb3IgPG1BVEg+LlxuXG4gICAgICBpZiAoIWlzQ3VzdG9tQ29tcG9uZW50VGFnICYmIHR5cGUgIT09IHR5cGUudG9Mb3dlckNhc2UoKSkge1xuICAgICAgICBlcnJvcignPCVzIC8+IGlzIHVzaW5nIGluY29ycmVjdCBjYXNpbmcuICcgKyAnVXNlIFBhc2NhbENhc2UgZm9yIFJlYWN0IGNvbXBvbmVudHMsICcgKyAnb3IgbG93ZXJjYXNlIGZvciBIVE1MIGVsZW1lbnRzLicsIHR5cGUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0eXBlID09PSAnc2NyaXB0Jykge1xuICAgICAgLy8gQ3JlYXRlIHRoZSBzY3JpcHQgdmlhIC5pbm5lckhUTUwgc28gaXRzIFwicGFyc2VyLWluc2VydGVkXCIgZmxhZyBpc1xuICAgICAgLy8gc2V0IHRvIHRydWUgYW5kIGl0IGRvZXMgbm90IGV4ZWN1dGVcbiAgICAgIHZhciBkaXYgPSBvd25lckRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuXG4gICAgICBkaXYuaW5uZXJIVE1MID0gJzxzY3JpcHQ+PCcgKyAnL3NjcmlwdD4nOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgICAvLyBUaGlzIGlzIGd1YXJhbnRlZWQgdG8geWllbGQgYSBzY3JpcHQgZWxlbWVudC5cblxuICAgICAgdmFyIGZpcnN0Q2hpbGQgPSBkaXYuZmlyc3RDaGlsZDtcbiAgICAgIGRvbUVsZW1lbnQgPSBkaXYucmVtb3ZlQ2hpbGQoZmlyc3RDaGlsZCk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgcHJvcHMuaXMgPT09ICdzdHJpbmcnKSB7XG4gICAgICAvLyAkRmxvd0lzc3VlIGBjcmVhdGVFbGVtZW50YCBzaG91bGQgYmUgdXBkYXRlZCBmb3IgV2ViIENvbXBvbmVudHNcbiAgICAgIGRvbUVsZW1lbnQgPSBvd25lckRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodHlwZSwge1xuICAgICAgICBpczogcHJvcHMuaXNcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBTZXBhcmF0ZSBlbHNlIGJyYW5jaCBpbnN0ZWFkIG9mIHVzaW5nIGBwcm9wcy5pcyB8fCB1bmRlZmluZWRgIGFib3ZlIGJlY2F1c2Ugb2YgYSBGaXJlZm94IGJ1Zy5cbiAgICAgIC8vIFNlZSBkaXNjdXNzaW9uIGluIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9wdWxsLzY4OTZcbiAgICAgIC8vIGFuZCBkaXNjdXNzaW9uIGluIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTEyNzYyNDBcbiAgICAgIGRvbUVsZW1lbnQgPSBvd25lckRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodHlwZSk7IC8vIE5vcm1hbGx5IGF0dHJpYnV0ZXMgYXJlIGFzc2lnbmVkIGluIGBzZXRJbml0aWFsRE9NUHJvcGVydGllc2AsIGhvd2V2ZXIgdGhlIGBtdWx0aXBsZWAgYW5kIGBzaXplYFxuICAgICAgLy8gYXR0cmlidXRlcyBvbiBgc2VsZWN0YHMgbmVlZHMgdG8gYmUgYWRkZWQgYmVmb3JlIGBvcHRpb25gcyBhcmUgaW5zZXJ0ZWQuXG4gICAgICAvLyBUaGlzIHByZXZlbnRzOlxuICAgICAgLy8gLSBhIGJ1ZyB3aGVyZSB0aGUgYHNlbGVjdGAgZG9lcyBub3Qgc2Nyb2xsIHRvIHRoZSBjb3JyZWN0IG9wdGlvbiBiZWNhdXNlIHNpbmd1bGFyXG4gICAgICAvLyAgYHNlbGVjdGAgZWxlbWVudHMgYXV0b21hdGljYWxseSBwaWNrIHRoZSBmaXJzdCBpdGVtICMxMzIyMlxuICAgICAgLy8gLSBhIGJ1ZyB3aGVyZSB0aGUgYHNlbGVjdGAgc2V0IHRoZSBmaXJzdCBpdGVtIGFzIHNlbGVjdGVkIGRlc3BpdGUgdGhlIGBzaXplYCBhdHRyaWJ1dGUgIzE0MjM5XG4gICAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xMzIyMlxuICAgICAgLy8gYW5kIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTQyMzlcblxuICAgICAgaWYgKHR5cGUgPT09ICdzZWxlY3QnKSB7XG4gICAgICAgIHZhciBub2RlID0gZG9tRWxlbWVudDtcblxuICAgICAgICBpZiAocHJvcHMubXVsdGlwbGUpIHtcbiAgICAgICAgICBub2RlLm11bHRpcGxlID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIGlmIChwcm9wcy5zaXplKSB7XG4gICAgICAgICAgLy8gU2V0dGluZyBhIHNpemUgZ3JlYXRlciB0aGFuIDEgY2F1c2VzIGEgc2VsZWN0IHRvIGJlaGF2ZSBsaWtlIGBtdWx0aXBsZT10cnVlYCwgd2hlcmVcbiAgICAgICAgICAvLyBpdCBpcyBwb3NzaWJsZSB0aGF0IG5vIG9wdGlvbiBpcyBzZWxlY3RlZC5cbiAgICAgICAgICAvL1xuICAgICAgICAgIC8vIFRoaXMgaXMgb25seSBuZWNlc3Nhcnkgd2hlbiBhIHNlbGVjdCBpbiBcInNpbmdsZSBzZWxlY3Rpb24gbW9kZVwiLlxuICAgICAgICAgIG5vZGUuc2l6ZSA9IHByb3BzLnNpemU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgZG9tRWxlbWVudCA9IG93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKG5hbWVzcGFjZVVSSSwgdHlwZSk7XG4gIH1cblxuICB7XG4gICAgaWYgKG5hbWVzcGFjZVVSSSA9PT0gSFRNTF9OQU1FU1BBQ0UkMSkge1xuICAgICAgaWYgKCFpc0N1c3RvbUNvbXBvbmVudFRhZyAmJiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoZG9tRWxlbWVudCkgPT09ICdbb2JqZWN0IEhUTUxVbmtub3duRWxlbWVudF0nICYmICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwod2FybmVkVW5rbm93blRhZ3MsIHR5cGUpKSB7XG4gICAgICAgIHdhcm5lZFVua25vd25UYWdzW3R5cGVdID0gdHJ1ZTtcblxuICAgICAgICBlcnJvcignVGhlIHRhZyA8JXM+IGlzIHVucmVjb2duaXplZCBpbiB0aGlzIGJyb3dzZXIuICcgKyAnSWYgeW91IG1lYW50IHRvIHJlbmRlciBhIFJlYWN0IGNvbXBvbmVudCwgc3RhcnQgaXRzIG5hbWUgd2l0aCAnICsgJ2FuIHVwcGVyY2FzZSBsZXR0ZXIuJywgdHlwZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGRvbUVsZW1lbnQ7XG59XG5mdW5jdGlvbiBjcmVhdGVUZXh0Tm9kZSh0ZXh0LCByb290Q29udGFpbmVyRWxlbWVudCkge1xuICByZXR1cm4gZ2V0T3duZXJEb2N1bWVudEZyb21Sb290Q29udGFpbmVyKHJvb3RDb250YWluZXJFbGVtZW50KS5jcmVhdGVUZXh0Tm9kZSh0ZXh0KTtcbn1cbmZ1bmN0aW9uIHNldEluaXRpYWxQcm9wZXJ0aWVzKGRvbUVsZW1lbnQsIHRhZywgcmF3UHJvcHMsIHJvb3RDb250YWluZXJFbGVtZW50KSB7XG4gIHZhciBpc0N1c3RvbUNvbXBvbmVudFRhZyA9IGlzQ3VzdG9tQ29tcG9uZW50KHRhZywgcmF3UHJvcHMpO1xuXG4gIHtcbiAgICB2YWxpZGF0ZVByb3BlcnRpZXNJbkRldmVsb3BtZW50KHRhZywgcmF3UHJvcHMpO1xuICB9IC8vIFRPRE86IE1ha2Ugc3VyZSB0aGF0IHdlIGNoZWNrIGlzTW91bnRlZCBiZWZvcmUgZmlyaW5nIGFueSBvZiB0aGVzZSBldmVudHMuXG5cblxuICB2YXIgcHJvcHM7XG5cbiAgc3dpdGNoICh0YWcpIHtcbiAgICBjYXNlICdkaWFsb2cnOlxuICAgICAgbGlzdGVuVG9Ob25EZWxlZ2F0ZWRFdmVudCgnY2FuY2VsJywgZG9tRWxlbWVudCk7XG4gICAgICBsaXN0ZW5Ub05vbkRlbGVnYXRlZEV2ZW50KCdjbG9zZScsIGRvbUVsZW1lbnQpO1xuICAgICAgcHJvcHMgPSByYXdQcm9wcztcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnaWZyYW1lJzpcbiAgICBjYXNlICdvYmplY3QnOlxuICAgIGNhc2UgJ2VtYmVkJzpcbiAgICAgIC8vIFdlIGxpc3RlbiB0byB0aGlzIGV2ZW50IGluIGNhc2UgdG8gZW5zdXJlIGVtdWxhdGVkIGJ1YmJsZVxuICAgICAgLy8gbGlzdGVuZXJzIHN0aWxsIGZpcmUgZm9yIHRoZSBsb2FkIGV2ZW50LlxuICAgICAgbGlzdGVuVG9Ob25EZWxlZ2F0ZWRFdmVudCgnbG9hZCcsIGRvbUVsZW1lbnQpO1xuICAgICAgcHJvcHMgPSByYXdQcm9wcztcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAndmlkZW8nOlxuICAgIGNhc2UgJ2F1ZGlvJzpcbiAgICAgIC8vIFdlIGxpc3RlbiB0byB0aGVzZSBldmVudHMgaW4gY2FzZSB0byBlbnN1cmUgZW11bGF0ZWQgYnViYmxlXG4gICAgICAvLyBsaXN0ZW5lcnMgc3RpbGwgZmlyZSBmb3IgYWxsIHRoZSBtZWRpYSBldmVudHMuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1lZGlhRXZlbnRUeXBlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBsaXN0ZW5Ub05vbkRlbGVnYXRlZEV2ZW50KG1lZGlhRXZlbnRUeXBlc1tpXSwgZG9tRWxlbWVudCk7XG4gICAgICB9XG5cbiAgICAgIHByb3BzID0gcmF3UHJvcHM7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ3NvdXJjZSc6XG4gICAgICAvLyBXZSBsaXN0ZW4gdG8gdGhpcyBldmVudCBpbiBjYXNlIHRvIGVuc3VyZSBlbXVsYXRlZCBidWJibGVcbiAgICAgIC8vIGxpc3RlbmVycyBzdGlsbCBmaXJlIGZvciB0aGUgZXJyb3IgZXZlbnQuXG4gICAgICBsaXN0ZW5Ub05vbkRlbGVnYXRlZEV2ZW50KCdlcnJvcicsIGRvbUVsZW1lbnQpO1xuICAgICAgcHJvcHMgPSByYXdQcm9wcztcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnaW1nJzpcbiAgICBjYXNlICdpbWFnZSc6XG4gICAgY2FzZSAnbGluayc6XG4gICAgICAvLyBXZSBsaXN0ZW4gdG8gdGhlc2UgZXZlbnRzIGluIGNhc2UgdG8gZW5zdXJlIGVtdWxhdGVkIGJ1YmJsZVxuICAgICAgLy8gbGlzdGVuZXJzIHN0aWxsIGZpcmUgZm9yIGVycm9yIGFuZCBsb2FkIGV2ZW50cy5cbiAgICAgIGxpc3RlblRvTm9uRGVsZWdhdGVkRXZlbnQoJ2Vycm9yJywgZG9tRWxlbWVudCk7XG4gICAgICBsaXN0ZW5Ub05vbkRlbGVnYXRlZEV2ZW50KCdsb2FkJywgZG9tRWxlbWVudCk7XG4gICAgICBwcm9wcyA9IHJhd1Byb3BzO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdkZXRhaWxzJzpcbiAgICAgIC8vIFdlIGxpc3RlbiB0byB0aGlzIGV2ZW50IGluIGNhc2UgdG8gZW5zdXJlIGVtdWxhdGVkIGJ1YmJsZVxuICAgICAgLy8gbGlzdGVuZXJzIHN0aWxsIGZpcmUgZm9yIHRoZSB0b2dnbGUgZXZlbnQuXG4gICAgICBsaXN0ZW5Ub05vbkRlbGVnYXRlZEV2ZW50KCd0b2dnbGUnLCBkb21FbGVtZW50KTtcbiAgICAgIHByb3BzID0gcmF3UHJvcHM7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ2lucHV0JzpcbiAgICAgIGluaXRXcmFwcGVyU3RhdGUoZG9tRWxlbWVudCwgcmF3UHJvcHMpO1xuICAgICAgcHJvcHMgPSBnZXRIb3N0UHJvcHMoZG9tRWxlbWVudCwgcmF3UHJvcHMpOyAvLyBXZSBsaXN0ZW4gdG8gdGhpcyBldmVudCBpbiBjYXNlIHRvIGVuc3VyZSBlbXVsYXRlZCBidWJibGVcbiAgICAgIC8vIGxpc3RlbmVycyBzdGlsbCBmaXJlIGZvciB0aGUgaW52YWxpZCBldmVudC5cblxuICAgICAgbGlzdGVuVG9Ob25EZWxlZ2F0ZWRFdmVudCgnaW52YWxpZCcsIGRvbUVsZW1lbnQpO1xuXG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ29wdGlvbic6XG4gICAgICB2YWxpZGF0ZVByb3BzKGRvbUVsZW1lbnQsIHJhd1Byb3BzKTtcbiAgICAgIHByb3BzID0gZ2V0SG9zdFByb3BzJDEoZG9tRWxlbWVudCwgcmF3UHJvcHMpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdzZWxlY3QnOlxuICAgICAgaW5pdFdyYXBwZXJTdGF0ZSQxKGRvbUVsZW1lbnQsIHJhd1Byb3BzKTtcbiAgICAgIHByb3BzID0gZ2V0SG9zdFByb3BzJDIoZG9tRWxlbWVudCwgcmF3UHJvcHMpOyAvLyBXZSBsaXN0ZW4gdG8gdGhpcyBldmVudCBpbiBjYXNlIHRvIGVuc3VyZSBlbXVsYXRlZCBidWJibGVcbiAgICAgIC8vIGxpc3RlbmVycyBzdGlsbCBmaXJlIGZvciB0aGUgaW52YWxpZCBldmVudC5cblxuICAgICAgbGlzdGVuVG9Ob25EZWxlZ2F0ZWRFdmVudCgnaW52YWxpZCcsIGRvbUVsZW1lbnQpO1xuXG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ3RleHRhcmVhJzpcbiAgICAgIGluaXRXcmFwcGVyU3RhdGUkMihkb21FbGVtZW50LCByYXdQcm9wcyk7XG4gICAgICBwcm9wcyA9IGdldEhvc3RQcm9wcyQzKGRvbUVsZW1lbnQsIHJhd1Byb3BzKTsgLy8gV2UgbGlzdGVuIHRvIHRoaXMgZXZlbnQgaW4gY2FzZSB0byBlbnN1cmUgZW11bGF0ZWQgYnViYmxlXG4gICAgICAvLyBsaXN0ZW5lcnMgc3RpbGwgZmlyZSBmb3IgdGhlIGludmFsaWQgZXZlbnQuXG5cbiAgICAgIGxpc3RlblRvTm9uRGVsZWdhdGVkRXZlbnQoJ2ludmFsaWQnLCBkb21FbGVtZW50KTtcblxuICAgICAgYnJlYWs7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgcHJvcHMgPSByYXdQcm9wcztcbiAgfVxuXG4gIGFzc2VydFZhbGlkUHJvcHModGFnLCBwcm9wcyk7XG4gIHNldEluaXRpYWxET01Qcm9wZXJ0aWVzKHRhZywgZG9tRWxlbWVudCwgcm9vdENvbnRhaW5lckVsZW1lbnQsIHByb3BzLCBpc0N1c3RvbUNvbXBvbmVudFRhZyk7XG5cbiAgc3dpdGNoICh0YWcpIHtcbiAgICBjYXNlICdpbnB1dCc6XG4gICAgICAvLyBUT0RPOiBNYWtlIHN1cmUgd2UgY2hlY2sgaWYgdGhpcyBpcyBzdGlsbCB1bm1vdW50ZWQgb3IgZG8gYW55IGNsZWFuXG4gICAgICAvLyB1cCBuZWNlc3Nhcnkgc2luY2Ugd2UgbmV2ZXIgc3RvcCB0cmFja2luZyBhbnltb3JlLlxuICAgICAgdHJhY2soZG9tRWxlbWVudCk7XG4gICAgICBwb3N0TW91bnRXcmFwcGVyKGRvbUVsZW1lbnQsIHJhd1Byb3BzLCBmYWxzZSk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ3RleHRhcmVhJzpcbiAgICAgIC8vIFRPRE86IE1ha2Ugc3VyZSB3ZSBjaGVjayBpZiB0aGlzIGlzIHN0aWxsIHVubW91bnRlZCBvciBkbyBhbnkgY2xlYW5cbiAgICAgIC8vIHVwIG5lY2Vzc2FyeSBzaW5jZSB3ZSBuZXZlciBzdG9wIHRyYWNraW5nIGFueW1vcmUuXG4gICAgICB0cmFjayhkb21FbGVtZW50KTtcbiAgICAgIHBvc3RNb3VudFdyYXBwZXIkMyhkb21FbGVtZW50KTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnb3B0aW9uJzpcbiAgICAgIHBvc3RNb3VudFdyYXBwZXIkMShkb21FbGVtZW50LCByYXdQcm9wcyk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ3NlbGVjdCc6XG4gICAgICBwb3N0TW91bnRXcmFwcGVyJDIoZG9tRWxlbWVudCwgcmF3UHJvcHMpO1xuICAgICAgYnJlYWs7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgaWYgKHR5cGVvZiBwcm9wcy5vbkNsaWNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8vIFRPRE86IFRoaXMgY2FzdCBtYXkgbm90IGJlIHNvdW5kIGZvciBTVkcsIE1hdGhNTCBvciBjdXN0b20gZWxlbWVudHMuXG4gICAgICAgIHRyYXBDbGlja09uTm9uSW50ZXJhY3RpdmVFbGVtZW50KGRvbUVsZW1lbnQpO1xuICAgICAgfVxuXG4gICAgICBicmVhaztcbiAgfVxufSAvLyBDYWxjdWxhdGUgdGhlIGRpZmYgYmV0d2VlbiB0aGUgdHdvIG9iamVjdHMuXG5cbmZ1bmN0aW9uIGRpZmZQcm9wZXJ0aWVzKGRvbUVsZW1lbnQsIHRhZywgbGFzdFJhd1Byb3BzLCBuZXh0UmF3UHJvcHMsIHJvb3RDb250YWluZXJFbGVtZW50KSB7XG4gIHtcbiAgICB2YWxpZGF0ZVByb3BlcnRpZXNJbkRldmVsb3BtZW50KHRhZywgbmV4dFJhd1Byb3BzKTtcbiAgfVxuXG4gIHZhciB1cGRhdGVQYXlsb2FkID0gbnVsbDtcbiAgdmFyIGxhc3RQcm9wcztcbiAgdmFyIG5leHRQcm9wcztcblxuICBzd2l0Y2ggKHRhZykge1xuICAgIGNhc2UgJ2lucHV0JzpcbiAgICAgIGxhc3RQcm9wcyA9IGdldEhvc3RQcm9wcyhkb21FbGVtZW50LCBsYXN0UmF3UHJvcHMpO1xuICAgICAgbmV4dFByb3BzID0gZ2V0SG9zdFByb3BzKGRvbUVsZW1lbnQsIG5leHRSYXdQcm9wcyk7XG4gICAgICB1cGRhdGVQYXlsb2FkID0gW107XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ29wdGlvbic6XG4gICAgICBsYXN0UHJvcHMgPSBnZXRIb3N0UHJvcHMkMShkb21FbGVtZW50LCBsYXN0UmF3UHJvcHMpO1xuICAgICAgbmV4dFByb3BzID0gZ2V0SG9zdFByb3BzJDEoZG9tRWxlbWVudCwgbmV4dFJhd1Byb3BzKTtcbiAgICAgIHVwZGF0ZVBheWxvYWQgPSBbXTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnc2VsZWN0JzpcbiAgICAgIGxhc3RQcm9wcyA9IGdldEhvc3RQcm9wcyQyKGRvbUVsZW1lbnQsIGxhc3RSYXdQcm9wcyk7XG4gICAgICBuZXh0UHJvcHMgPSBnZXRIb3N0UHJvcHMkMihkb21FbGVtZW50LCBuZXh0UmF3UHJvcHMpO1xuICAgICAgdXBkYXRlUGF5bG9hZCA9IFtdO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICd0ZXh0YXJlYSc6XG4gICAgICBsYXN0UHJvcHMgPSBnZXRIb3N0UHJvcHMkMyhkb21FbGVtZW50LCBsYXN0UmF3UHJvcHMpO1xuICAgICAgbmV4dFByb3BzID0gZ2V0SG9zdFByb3BzJDMoZG9tRWxlbWVudCwgbmV4dFJhd1Byb3BzKTtcbiAgICAgIHVwZGF0ZVBheWxvYWQgPSBbXTtcbiAgICAgIGJyZWFrO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIGxhc3RQcm9wcyA9IGxhc3RSYXdQcm9wcztcbiAgICAgIG5leHRQcm9wcyA9IG5leHRSYXdQcm9wcztcblxuICAgICAgaWYgKHR5cGVvZiBsYXN0UHJvcHMub25DbGljayAhPT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgbmV4dFByb3BzLm9uQ2xpY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgLy8gVE9ETzogVGhpcyBjYXN0IG1heSBub3QgYmUgc291bmQgZm9yIFNWRywgTWF0aE1MIG9yIGN1c3RvbSBlbGVtZW50cy5cbiAgICAgICAgdHJhcENsaWNrT25Ob25JbnRlcmFjdGl2ZUVsZW1lbnQoZG9tRWxlbWVudCk7XG4gICAgICB9XG5cbiAgICAgIGJyZWFrO1xuICB9XG5cbiAgYXNzZXJ0VmFsaWRQcm9wcyh0YWcsIG5leHRQcm9wcyk7XG4gIHZhciBwcm9wS2V5O1xuICB2YXIgc3R5bGVOYW1lO1xuICB2YXIgc3R5bGVVcGRhdGVzID0gbnVsbDtcblxuICBmb3IgKHByb3BLZXkgaW4gbGFzdFByb3BzKSB7XG4gICAgaWYgKG5leHRQcm9wcy5oYXNPd25Qcm9wZXJ0eShwcm9wS2V5KSB8fCAhbGFzdFByb3BzLmhhc093blByb3BlcnR5KHByb3BLZXkpIHx8IGxhc3RQcm9wc1twcm9wS2V5XSA9PSBudWxsKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpZiAocHJvcEtleSA9PT0gU1RZTEUpIHtcbiAgICAgIHZhciBsYXN0U3R5bGUgPSBsYXN0UHJvcHNbcHJvcEtleV07XG5cbiAgICAgIGZvciAoc3R5bGVOYW1lIGluIGxhc3RTdHlsZSkge1xuICAgICAgICBpZiAobGFzdFN0eWxlLmhhc093blByb3BlcnR5KHN0eWxlTmFtZSkpIHtcbiAgICAgICAgICBpZiAoIXN0eWxlVXBkYXRlcykge1xuICAgICAgICAgICAgc3R5bGVVcGRhdGVzID0ge307XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgc3R5bGVVcGRhdGVzW3N0eWxlTmFtZV0gPSAnJztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocHJvcEtleSA9PT0gREFOR0VST1VTTFlfU0VUX0lOTkVSX0hUTUwgfHwgcHJvcEtleSA9PT0gQ0hJTERSRU4pIDsgZWxzZSBpZiAocHJvcEtleSA9PT0gU1VQUFJFU1NfQ09OVEVOVF9FRElUQUJMRV9XQVJOSU5HIHx8IHByb3BLZXkgPT09IFNVUFBSRVNTX0hZRFJBVElPTl9XQVJOSU5HKSA7IGVsc2UgaWYgKHByb3BLZXkgPT09IEFVVE9GT0NVUykgOyBlbHNlIGlmIChyZWdpc3RyYXRpb25OYW1lRGVwZW5kZW5jaWVzLmhhc093blByb3BlcnR5KHByb3BLZXkpKSB7XG4gICAgICAvLyBUaGlzIGlzIGEgc3BlY2lhbCBjYXNlLiBJZiBhbnkgbGlzdGVuZXIgdXBkYXRlcyB3ZSBuZWVkIHRvIGVuc3VyZVxuICAgICAgLy8gdGhhdCB0aGUgXCJjdXJyZW50XCIgZmliZXIgcG9pbnRlciBnZXRzIHVwZGF0ZWQgc28gd2UgbmVlZCBhIGNvbW1pdFxuICAgICAgLy8gdG8gdXBkYXRlIHRoaXMgZWxlbWVudC5cbiAgICAgIGlmICghdXBkYXRlUGF5bG9hZCkge1xuICAgICAgICB1cGRhdGVQYXlsb2FkID0gW107XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEZvciBhbGwgb3RoZXIgZGVsZXRlZCBwcm9wZXJ0aWVzIHdlIGFkZCBpdCB0byB0aGUgcXVldWUuIFdlIHVzZVxuICAgICAgLy8gdGhlIGFsbG93ZWQgcHJvcGVydHkgbGlzdCBpbiB0aGUgY29tbWl0IHBoYXNlIGluc3RlYWQuXG4gICAgICAodXBkYXRlUGF5bG9hZCA9IHVwZGF0ZVBheWxvYWQgfHwgW10pLnB1c2gocHJvcEtleSwgbnVsbCk7XG4gICAgfVxuICB9XG5cbiAgZm9yIChwcm9wS2V5IGluIG5leHRQcm9wcykge1xuICAgIHZhciBuZXh0UHJvcCA9IG5leHRQcm9wc1twcm9wS2V5XTtcbiAgICB2YXIgbGFzdFByb3AgPSBsYXN0UHJvcHMgIT0gbnVsbCA/IGxhc3RQcm9wc1twcm9wS2V5XSA6IHVuZGVmaW5lZDtcblxuICAgIGlmICghbmV4dFByb3BzLmhhc093blByb3BlcnR5KHByb3BLZXkpIHx8IG5leHRQcm9wID09PSBsYXN0UHJvcCB8fCBuZXh0UHJvcCA9PSBudWxsICYmIGxhc3RQcm9wID09IG51bGwpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGlmIChwcm9wS2V5ID09PSBTVFlMRSkge1xuICAgICAge1xuICAgICAgICBpZiAobmV4dFByb3ApIHtcbiAgICAgICAgICAvLyBGcmVlemUgdGhlIG5leHQgc3R5bGUgb2JqZWN0IHNvIHRoYXQgd2UgY2FuIGFzc3VtZSBpdCB3b24ndCBiZVxuICAgICAgICAgIC8vIG11dGF0ZWQuIFdlIGhhdmUgYWxyZWFkeSB3YXJuZWQgZm9yIHRoaXMgaW4gdGhlIHBhc3QuXG4gICAgICAgICAgT2JqZWN0LmZyZWV6ZShuZXh0UHJvcCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGxhc3RQcm9wKSB7XG4gICAgICAgIC8vIFVuc2V0IHN0eWxlcyBvbiBgbGFzdFByb3BgIGJ1dCBub3Qgb24gYG5leHRQcm9wYC5cbiAgICAgICAgZm9yIChzdHlsZU5hbWUgaW4gbGFzdFByb3ApIHtcbiAgICAgICAgICBpZiAobGFzdFByb3AuaGFzT3duUHJvcGVydHkoc3R5bGVOYW1lKSAmJiAoIW5leHRQcm9wIHx8ICFuZXh0UHJvcC5oYXNPd25Qcm9wZXJ0eShzdHlsZU5hbWUpKSkge1xuICAgICAgICAgICAgaWYgKCFzdHlsZVVwZGF0ZXMpIHtcbiAgICAgICAgICAgICAgc3R5bGVVcGRhdGVzID0ge307XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHN0eWxlVXBkYXRlc1tzdHlsZU5hbWVdID0gJyc7XG4gICAgICAgICAgfVxuICAgICAgICB9IC8vIFVwZGF0ZSBzdHlsZXMgdGhhdCBjaGFuZ2VkIHNpbmNlIGBsYXN0UHJvcGAuXG5cblxuICAgICAgICBmb3IgKHN0eWxlTmFtZSBpbiBuZXh0UHJvcCkge1xuICAgICAgICAgIGlmIChuZXh0UHJvcC5oYXNPd25Qcm9wZXJ0eShzdHlsZU5hbWUpICYmIGxhc3RQcm9wW3N0eWxlTmFtZV0gIT09IG5leHRQcm9wW3N0eWxlTmFtZV0pIHtcbiAgICAgICAgICAgIGlmICghc3R5bGVVcGRhdGVzKSB7XG4gICAgICAgICAgICAgIHN0eWxlVXBkYXRlcyA9IHt9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzdHlsZVVwZGF0ZXNbc3R5bGVOYW1lXSA9IG5leHRQcm9wW3N0eWxlTmFtZV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBSZWxpZXMgb24gYHVwZGF0ZVN0eWxlc0J5SURgIG5vdCBtdXRhdGluZyBgc3R5bGVVcGRhdGVzYC5cbiAgICAgICAgaWYgKCFzdHlsZVVwZGF0ZXMpIHtcbiAgICAgICAgICBpZiAoIXVwZGF0ZVBheWxvYWQpIHtcbiAgICAgICAgICAgIHVwZGF0ZVBheWxvYWQgPSBbXTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB1cGRhdGVQYXlsb2FkLnB1c2gocHJvcEtleSwgc3R5bGVVcGRhdGVzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN0eWxlVXBkYXRlcyA9IG5leHRQcm9wO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocHJvcEtleSA9PT0gREFOR0VST1VTTFlfU0VUX0lOTkVSX0hUTUwpIHtcbiAgICAgIHZhciBuZXh0SHRtbCA9IG5leHRQcm9wID8gbmV4dFByb3BbSFRNTCQxXSA6IHVuZGVmaW5lZDtcbiAgICAgIHZhciBsYXN0SHRtbCA9IGxhc3RQcm9wID8gbGFzdFByb3BbSFRNTCQxXSA6IHVuZGVmaW5lZDtcblxuICAgICAgaWYgKG5leHRIdG1sICE9IG51bGwpIHtcbiAgICAgICAgaWYgKGxhc3RIdG1sICE9PSBuZXh0SHRtbCkge1xuICAgICAgICAgICh1cGRhdGVQYXlsb2FkID0gdXBkYXRlUGF5bG9hZCB8fCBbXSkucHVzaChwcm9wS2V5LCBuZXh0SHRtbCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHByb3BLZXkgPT09IENISUxEUkVOKSB7XG4gICAgICBpZiAodHlwZW9mIG5leHRQcm9wID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgbmV4dFByb3AgPT09ICdudW1iZXInKSB7XG4gICAgICAgICh1cGRhdGVQYXlsb2FkID0gdXBkYXRlUGF5bG9hZCB8fCBbXSkucHVzaChwcm9wS2V5LCAnJyArIG5leHRQcm9wKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHByb3BLZXkgPT09IFNVUFBSRVNTX0NPTlRFTlRfRURJVEFCTEVfV0FSTklORyB8fCBwcm9wS2V5ID09PSBTVVBQUkVTU19IWURSQVRJT05fV0FSTklORykgOyBlbHNlIGlmIChyZWdpc3RyYXRpb25OYW1lRGVwZW5kZW5jaWVzLmhhc093blByb3BlcnR5KHByb3BLZXkpKSB7XG4gICAgICBpZiAobmV4dFByb3AgIT0gbnVsbCkge1xuICAgICAgICAvLyBXZSBlYWdlcmx5IGxpc3RlbiB0byB0aGlzIGV2ZW4gdGhvdWdoIHdlIGhhdmVuJ3QgY29tbWl0dGVkIHlldC5cbiAgICAgICAgaWYgKCB0eXBlb2YgbmV4dFByb3AgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICB3YXJuRm9ySW52YWxpZEV2ZW50TGlzdGVuZXIocHJvcEtleSwgbmV4dFByb3ApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHByb3BLZXkgPT09ICdvblNjcm9sbCcpIHtcbiAgICAgICAgICBsaXN0ZW5Ub05vbkRlbGVnYXRlZEV2ZW50KCdzY3JvbGwnLCBkb21FbGVtZW50KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoIXVwZGF0ZVBheWxvYWQgJiYgbGFzdFByb3AgIT09IG5leHRQcm9wKSB7XG4gICAgICAgIC8vIFRoaXMgaXMgYSBzcGVjaWFsIGNhc2UuIElmIGFueSBsaXN0ZW5lciB1cGRhdGVzIHdlIG5lZWQgdG8gZW5zdXJlXG4gICAgICAgIC8vIHRoYXQgdGhlIFwiY3VycmVudFwiIHByb3BzIHBvaW50ZXIgZ2V0cyB1cGRhdGVkIHNvIHdlIG5lZWQgYSBjb21taXRcbiAgICAgICAgLy8gdG8gdXBkYXRlIHRoaXMgZWxlbWVudC5cbiAgICAgICAgdXBkYXRlUGF5bG9hZCA9IFtdO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodHlwZW9mIG5leHRQcm9wID09PSAnb2JqZWN0JyAmJiBuZXh0UHJvcCAhPT0gbnVsbCAmJiBuZXh0UHJvcC4kJHR5cGVvZiA9PT0gUkVBQ1RfT1BBUVVFX0lEX1RZUEUpIHtcbiAgICAgIC8vIElmIHdlIGVuY291bnRlciB1c2VPcGFxdWVSZWZlcmVuY2UncyBvcGFxdWUgb2JqZWN0LCB0aGlzIG1lYW5zIHdlIGFyZSBoeWRyYXRpbmcuXG4gICAgICAvLyBJbiB0aGlzIGNhc2UsIGNhbGwgdGhlIG9wYXF1ZSBvYmplY3QncyB0b1N0cmluZyBmdW5jdGlvbiB3aGljaCBnZW5lcmF0ZXMgYSBuZXcgY2xpZW50XG4gICAgICAvLyBJRCBzbyBjbGllbnQgYW5kIHNlcnZlciBJRHMgbWF0Y2ggYW5kIHRocm93cyB0byByZXJlbmRlci5cbiAgICAgIG5leHRQcm9wLnRvU3RyaW5nKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEZvciBhbnkgb3RoZXIgcHJvcGVydHkgd2UgYWx3YXlzIGFkZCBpdCB0byB0aGUgcXVldWUgYW5kIHRoZW4gd2VcbiAgICAgIC8vIGZpbHRlciBpdCBvdXQgdXNpbmcgdGhlIGFsbG93ZWQgcHJvcGVydHkgbGlzdCBkdXJpbmcgdGhlIGNvbW1pdC5cbiAgICAgICh1cGRhdGVQYXlsb2FkID0gdXBkYXRlUGF5bG9hZCB8fCBbXSkucHVzaChwcm9wS2V5LCBuZXh0UHJvcCk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHN0eWxlVXBkYXRlcykge1xuICAgIHtcbiAgICAgIHZhbGlkYXRlU2hvcnRoYW5kUHJvcGVydHlDb2xsaXNpb25JbkRldihzdHlsZVVwZGF0ZXMsIG5leHRQcm9wc1tTVFlMRV0pO1xuICAgIH1cblxuICAgICh1cGRhdGVQYXlsb2FkID0gdXBkYXRlUGF5bG9hZCB8fCBbXSkucHVzaChTVFlMRSwgc3R5bGVVcGRhdGVzKTtcbiAgfVxuXG4gIHJldHVybiB1cGRhdGVQYXlsb2FkO1xufSAvLyBBcHBseSB0aGUgZGlmZi5cblxuZnVuY3Rpb24gdXBkYXRlUHJvcGVydGllcyhkb21FbGVtZW50LCB1cGRhdGVQYXlsb2FkLCB0YWcsIGxhc3RSYXdQcm9wcywgbmV4dFJhd1Byb3BzKSB7XG4gIC8vIFVwZGF0ZSBjaGVja2VkICpiZWZvcmUqIG5hbWUuXG4gIC8vIEluIHRoZSBtaWRkbGUgb2YgYW4gdXBkYXRlLCBpdCBpcyBwb3NzaWJsZSB0byBoYXZlIG11bHRpcGxlIGNoZWNrZWQuXG4gIC8vIFdoZW4gYSBjaGVja2VkIHJhZGlvIHRyaWVzIHRvIGNoYW5nZSBuYW1lLCBicm93c2VyIG1ha2VzIGFub3RoZXIgcmFkaW8ncyBjaGVja2VkIGZhbHNlLlxuICBpZiAodGFnID09PSAnaW5wdXQnICYmIG5leHRSYXdQcm9wcy50eXBlID09PSAncmFkaW8nICYmIG5leHRSYXdQcm9wcy5uYW1lICE9IG51bGwpIHtcbiAgICB1cGRhdGVDaGVja2VkKGRvbUVsZW1lbnQsIG5leHRSYXdQcm9wcyk7XG4gIH1cblxuICB2YXIgd2FzQ3VzdG9tQ29tcG9uZW50VGFnID0gaXNDdXN0b21Db21wb25lbnQodGFnLCBsYXN0UmF3UHJvcHMpO1xuICB2YXIgaXNDdXN0b21Db21wb25lbnRUYWcgPSBpc0N1c3RvbUNvbXBvbmVudCh0YWcsIG5leHRSYXdQcm9wcyk7IC8vIEFwcGx5IHRoZSBkaWZmLlxuXG4gIHVwZGF0ZURPTVByb3BlcnRpZXMoZG9tRWxlbWVudCwgdXBkYXRlUGF5bG9hZCwgd2FzQ3VzdG9tQ29tcG9uZW50VGFnLCBpc0N1c3RvbUNvbXBvbmVudFRhZyk7IC8vIFRPRE86IEVuc3VyZSB0aGF0IGFuIHVwZGF0ZSBnZXRzIHNjaGVkdWxlZCBpZiBhbnkgb2YgdGhlIHNwZWNpYWwgcHJvcHNcbiAgLy8gY2hhbmdlZC5cblxuICBzd2l0Y2ggKHRhZykge1xuICAgIGNhc2UgJ2lucHV0JzpcbiAgICAgIC8vIFVwZGF0ZSB0aGUgd3JhcHBlciBhcm91bmQgaW5wdXRzICphZnRlciogdXBkYXRpbmcgcHJvcHMuIFRoaXMgaGFzIHRvXG4gICAgICAvLyBoYXBwZW4gYWZ0ZXIgYHVwZGF0ZURPTVByb3BlcnRpZXNgLiBPdGhlcndpc2UgSFRNTDUgaW5wdXQgdmFsaWRhdGlvbnNcbiAgICAgIC8vIHJhaXNlIHdhcm5pbmdzIGFuZCBwcmV2ZW50IHRoZSBuZXcgdmFsdWUgZnJvbSBiZWluZyBhc3NpZ25lZC5cbiAgICAgIHVwZGF0ZVdyYXBwZXIoZG9tRWxlbWVudCwgbmV4dFJhd1Byb3BzKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAndGV4dGFyZWEnOlxuICAgICAgdXBkYXRlV3JhcHBlciQxKGRvbUVsZW1lbnQsIG5leHRSYXdQcm9wcyk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ3NlbGVjdCc6XG4gICAgICAvLyA8c2VsZWN0PiB2YWx1ZSB1cGRhdGUgbmVlZHMgdG8gb2NjdXIgYWZ0ZXIgPG9wdGlvbj4gY2hpbGRyZW5cbiAgICAgIC8vIHJlY29uY2lsaWF0aW9uXG4gICAgICBwb3N0VXBkYXRlV3JhcHBlcihkb21FbGVtZW50LCBuZXh0UmF3UHJvcHMpO1xuICAgICAgYnJlYWs7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0UG9zc2libGVTdGFuZGFyZE5hbWUocHJvcE5hbWUpIHtcbiAge1xuICAgIHZhciBsb3dlckNhc2VkTmFtZSA9IHByb3BOYW1lLnRvTG93ZXJDYXNlKCk7XG5cbiAgICBpZiAoIXBvc3NpYmxlU3RhbmRhcmROYW1lcy5oYXNPd25Qcm9wZXJ0eShsb3dlckNhc2VkTmFtZSkpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiBwb3NzaWJsZVN0YW5kYXJkTmFtZXNbbG93ZXJDYXNlZE5hbWVdIHx8IG51bGw7XG4gIH1cbn1cblxuZnVuY3Rpb24gZGlmZkh5ZHJhdGVkUHJvcGVydGllcyhkb21FbGVtZW50LCB0YWcsIHJhd1Byb3BzLCBwYXJlbnROYW1lc3BhY2UsIHJvb3RDb250YWluZXJFbGVtZW50KSB7XG4gIHZhciBpc0N1c3RvbUNvbXBvbmVudFRhZztcbiAgdmFyIGV4dHJhQXR0cmlidXRlTmFtZXM7XG5cbiAge1xuICAgIHN1cHByZXNzSHlkcmF0aW9uV2FybmluZyA9IHJhd1Byb3BzW1NVUFBSRVNTX0hZRFJBVElPTl9XQVJOSU5HXSA9PT0gdHJ1ZTtcbiAgICBpc0N1c3RvbUNvbXBvbmVudFRhZyA9IGlzQ3VzdG9tQ29tcG9uZW50KHRhZywgcmF3UHJvcHMpO1xuICAgIHZhbGlkYXRlUHJvcGVydGllc0luRGV2ZWxvcG1lbnQodGFnLCByYXdQcm9wcyk7XG4gIH0gLy8gVE9ETzogTWFrZSBzdXJlIHRoYXQgd2UgY2hlY2sgaXNNb3VudGVkIGJlZm9yZSBmaXJpbmcgYW55IG9mIHRoZXNlIGV2ZW50cy5cblxuXG4gIHN3aXRjaCAodGFnKSB7XG4gICAgY2FzZSAnZGlhbG9nJzpcbiAgICAgIGxpc3RlblRvTm9uRGVsZWdhdGVkRXZlbnQoJ2NhbmNlbCcsIGRvbUVsZW1lbnQpO1xuICAgICAgbGlzdGVuVG9Ob25EZWxlZ2F0ZWRFdmVudCgnY2xvc2UnLCBkb21FbGVtZW50KTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnaWZyYW1lJzpcbiAgICBjYXNlICdvYmplY3QnOlxuICAgIGNhc2UgJ2VtYmVkJzpcbiAgICAgIC8vIFdlIGxpc3RlbiB0byB0aGlzIGV2ZW50IGluIGNhc2UgdG8gZW5zdXJlIGVtdWxhdGVkIGJ1YmJsZVxuICAgICAgLy8gbGlzdGVuZXJzIHN0aWxsIGZpcmUgZm9yIHRoZSBsb2FkIGV2ZW50LlxuICAgICAgbGlzdGVuVG9Ob25EZWxlZ2F0ZWRFdmVudCgnbG9hZCcsIGRvbUVsZW1lbnQpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICd2aWRlbyc6XG4gICAgY2FzZSAnYXVkaW8nOlxuICAgICAgLy8gV2UgbGlzdGVuIHRvIHRoZXNlIGV2ZW50cyBpbiBjYXNlIHRvIGVuc3VyZSBlbXVsYXRlZCBidWJibGVcbiAgICAgIC8vIGxpc3RlbmVycyBzdGlsbCBmaXJlIGZvciBhbGwgdGhlIG1lZGlhIGV2ZW50cy5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWVkaWFFdmVudFR5cGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxpc3RlblRvTm9uRGVsZWdhdGVkRXZlbnQobWVkaWFFdmVudFR5cGVzW2ldLCBkb21FbGVtZW50KTtcbiAgICAgIH1cblxuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdzb3VyY2UnOlxuICAgICAgLy8gV2UgbGlzdGVuIHRvIHRoaXMgZXZlbnQgaW4gY2FzZSB0byBlbnN1cmUgZW11bGF0ZWQgYnViYmxlXG4gICAgICAvLyBsaXN0ZW5lcnMgc3RpbGwgZmlyZSBmb3IgdGhlIGVycm9yIGV2ZW50LlxuICAgICAgbGlzdGVuVG9Ob25EZWxlZ2F0ZWRFdmVudCgnZXJyb3InLCBkb21FbGVtZW50KTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnaW1nJzpcbiAgICBjYXNlICdpbWFnZSc6XG4gICAgY2FzZSAnbGluayc6XG4gICAgICAvLyBXZSBsaXN0ZW4gdG8gdGhlc2UgZXZlbnRzIGluIGNhc2UgdG8gZW5zdXJlIGVtdWxhdGVkIGJ1YmJsZVxuICAgICAgLy8gbGlzdGVuZXJzIHN0aWxsIGZpcmUgZm9yIGVycm9yIGFuZCBsb2FkIGV2ZW50cy5cbiAgICAgIGxpc3RlblRvTm9uRGVsZWdhdGVkRXZlbnQoJ2Vycm9yJywgZG9tRWxlbWVudCk7XG4gICAgICBsaXN0ZW5Ub05vbkRlbGVnYXRlZEV2ZW50KCdsb2FkJywgZG9tRWxlbWVudCk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ2RldGFpbHMnOlxuICAgICAgLy8gV2UgbGlzdGVuIHRvIHRoaXMgZXZlbnQgaW4gY2FzZSB0byBlbnN1cmUgZW11bGF0ZWQgYnViYmxlXG4gICAgICAvLyBsaXN0ZW5lcnMgc3RpbGwgZmlyZSBmb3IgdGhlIHRvZ2dsZSBldmVudC5cbiAgICAgIGxpc3RlblRvTm9uRGVsZWdhdGVkRXZlbnQoJ3RvZ2dsZScsIGRvbUVsZW1lbnQpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdpbnB1dCc6XG4gICAgICBpbml0V3JhcHBlclN0YXRlKGRvbUVsZW1lbnQsIHJhd1Byb3BzKTsgLy8gV2UgbGlzdGVuIHRvIHRoaXMgZXZlbnQgaW4gY2FzZSB0byBlbnN1cmUgZW11bGF0ZWQgYnViYmxlXG4gICAgICAvLyBsaXN0ZW5lcnMgc3RpbGwgZmlyZSBmb3IgdGhlIGludmFsaWQgZXZlbnQuXG5cbiAgICAgIGxpc3RlblRvTm9uRGVsZWdhdGVkRXZlbnQoJ2ludmFsaWQnLCBkb21FbGVtZW50KTtcblxuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdvcHRpb24nOlxuICAgICAgdmFsaWRhdGVQcm9wcyhkb21FbGVtZW50LCByYXdQcm9wcyk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ3NlbGVjdCc6XG4gICAgICBpbml0V3JhcHBlclN0YXRlJDEoZG9tRWxlbWVudCwgcmF3UHJvcHMpOyAvLyBXZSBsaXN0ZW4gdG8gdGhpcyBldmVudCBpbiBjYXNlIHRvIGVuc3VyZSBlbXVsYXRlZCBidWJibGVcbiAgICAgIC8vIGxpc3RlbmVycyBzdGlsbCBmaXJlIGZvciB0aGUgaW52YWxpZCBldmVudC5cblxuICAgICAgbGlzdGVuVG9Ob25EZWxlZ2F0ZWRFdmVudCgnaW52YWxpZCcsIGRvbUVsZW1lbnQpO1xuXG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ3RleHRhcmVhJzpcbiAgICAgIGluaXRXcmFwcGVyU3RhdGUkMihkb21FbGVtZW50LCByYXdQcm9wcyk7IC8vIFdlIGxpc3RlbiB0byB0aGlzIGV2ZW50IGluIGNhc2UgdG8gZW5zdXJlIGVtdWxhdGVkIGJ1YmJsZVxuICAgICAgLy8gbGlzdGVuZXJzIHN0aWxsIGZpcmUgZm9yIHRoZSBpbnZhbGlkIGV2ZW50LlxuXG4gICAgICBsaXN0ZW5Ub05vbkRlbGVnYXRlZEV2ZW50KCdpbnZhbGlkJywgZG9tRWxlbWVudCk7XG5cbiAgICAgIGJyZWFrO1xuICB9XG5cbiAgYXNzZXJ0VmFsaWRQcm9wcyh0YWcsIHJhd1Byb3BzKTtcblxuICB7XG4gICAgZXh0cmFBdHRyaWJ1dGVOYW1lcyA9IG5ldyBTZXQoKTtcbiAgICB2YXIgYXR0cmlidXRlcyA9IGRvbUVsZW1lbnQuYXR0cmlidXRlcztcblxuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhdHRyaWJ1dGVzLmxlbmd0aDsgX2krKykge1xuICAgICAgdmFyIG5hbWUgPSBhdHRyaWJ1dGVzW19pXS5uYW1lLnRvTG93ZXJDYXNlKCk7XG5cbiAgICAgIHN3aXRjaCAobmFtZSkge1xuICAgICAgICAvLyBCdWlsdC1pbiBTU1IgYXR0cmlidXRlIGlzIGFsbG93ZWRcbiAgICAgICAgY2FzZSAnZGF0YS1yZWFjdHJvb3QnOlxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICAvLyBDb250cm9sbGVkIGF0dHJpYnV0ZXMgYXJlIG5vdCB2YWxpZGF0ZWRcbiAgICAgICAgLy8gVE9ETzogT25seSBpZ25vcmUgdGhlbSBvbiBjb250cm9sbGVkIHRhZ3MuXG5cbiAgICAgICAgY2FzZSAndmFsdWUnOlxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ2NoZWNrZWQnOlxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ3NlbGVjdGVkJzpcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIC8vIEludGVudGlvbmFsbHkgdXNlIHRoZSBvcmlnaW5hbCBuYW1lLlxuICAgICAgICAgIC8vIFNlZSBkaXNjdXNzaW9uIGluIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9wdWxsLzEwNjc2LlxuICAgICAgICAgIGV4dHJhQXR0cmlidXRlTmFtZXMuYWRkKGF0dHJpYnV0ZXNbX2ldLm5hbWUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHZhciB1cGRhdGVQYXlsb2FkID0gbnVsbDtcblxuICBmb3IgKHZhciBwcm9wS2V5IGluIHJhd1Byb3BzKSB7XG4gICAgaWYgKCFyYXdQcm9wcy5oYXNPd25Qcm9wZXJ0eShwcm9wS2V5KSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgdmFyIG5leHRQcm9wID0gcmF3UHJvcHNbcHJvcEtleV07XG5cbiAgICBpZiAocHJvcEtleSA9PT0gQ0hJTERSRU4pIHtcbiAgICAgIC8vIEZvciB0ZXh0IGNvbnRlbnQgY2hpbGRyZW4gd2UgY29tcGFyZSBhZ2FpbnN0IHRleHRDb250ZW50LiBUaGlzXG4gICAgICAvLyBtaWdodCBtYXRjaCBhZGRpdGlvbmFsIEhUTUwgdGhhdCBpcyBoaWRkZW4gd2hlbiB3ZSByZWFkIGl0IHVzaW5nXG4gICAgICAvLyB0ZXh0Q29udGVudC4gRS5nLiBcImZvb1wiIHdpbGwgbWF0Y2ggXCJmPHNwYW4+b288L3NwYW4+XCIgYnV0IHRoYXQgc3RpbGxcbiAgICAgIC8vIHNhdGlzZmllcyBvdXIgcmVxdWlyZW1lbnQuIE91ciByZXF1aXJlbWVudCBpcyBub3QgdG8gcHJvZHVjZSBwZXJmZWN0XG4gICAgICAvLyBIVE1MIGFuZCBhdHRyaWJ1dGVzLiBJZGVhbGx5IHdlIHNob3VsZCBwcmVzZXJ2ZSBzdHJ1Y3R1cmUgYnV0IGl0J3NcbiAgICAgIC8vIG9rIG5vdCB0byBpZiB0aGUgdmlzaWJsZSBjb250ZW50IGlzIHN0aWxsIGVub3VnaCB0byBpbmRpY2F0ZSB3aGF0XG4gICAgICAvLyBldmVuIGxpc3RlbmVycyB0aGVzZSBub2RlcyBtaWdodCBiZSB3aXJlZCB1cCB0by5cbiAgICAgIC8vIFRPRE86IFdhcm4gaWYgdGhlcmUgaXMgbW9yZSB0aGFuIGEgc2luZ2xlIHRleHROb2RlIGFzIGEgY2hpbGQuXG4gICAgICAvLyBUT0RPOiBTaG91bGQgd2UgdXNlIGRvbUVsZW1lbnQuZmlyc3RDaGlsZC5ub2RlVmFsdWUgdG8gY29tcGFyZT9cbiAgICAgIGlmICh0eXBlb2YgbmV4dFByb3AgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGlmIChkb21FbGVtZW50LnRleHRDb250ZW50ICE9PSBuZXh0UHJvcCkge1xuICAgICAgICAgIGlmICggIXN1cHByZXNzSHlkcmF0aW9uV2FybmluZykge1xuICAgICAgICAgICAgd2FybkZvclRleHREaWZmZXJlbmNlKGRvbUVsZW1lbnQudGV4dENvbnRlbnQsIG5leHRQcm9wKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB1cGRhdGVQYXlsb2FkID0gW0NISUxEUkVOLCBuZXh0UHJvcF07XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIG5leHRQcm9wID09PSAnbnVtYmVyJykge1xuICAgICAgICBpZiAoZG9tRWxlbWVudC50ZXh0Q29udGVudCAhPT0gJycgKyBuZXh0UHJvcCkge1xuICAgICAgICAgIGlmICggIXN1cHByZXNzSHlkcmF0aW9uV2FybmluZykge1xuICAgICAgICAgICAgd2FybkZvclRleHREaWZmZXJlbmNlKGRvbUVsZW1lbnQudGV4dENvbnRlbnQsIG5leHRQcm9wKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB1cGRhdGVQYXlsb2FkID0gW0NISUxEUkVOLCAnJyArIG5leHRQcm9wXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocmVnaXN0cmF0aW9uTmFtZURlcGVuZGVuY2llcy5oYXNPd25Qcm9wZXJ0eShwcm9wS2V5KSkge1xuICAgICAgaWYgKG5leHRQcm9wICE9IG51bGwpIHtcbiAgICAgICAgaWYgKCB0eXBlb2YgbmV4dFByb3AgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICB3YXJuRm9ySW52YWxpZEV2ZW50TGlzdGVuZXIocHJvcEtleSwgbmV4dFByb3ApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHByb3BLZXkgPT09ICdvblNjcm9sbCcpIHtcbiAgICAgICAgICBsaXN0ZW5Ub05vbkRlbGVnYXRlZEV2ZW50KCdzY3JvbGwnLCBkb21FbGVtZW50KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoIC8vIENvbnZpbmNlIEZsb3cgd2UndmUgY2FsY3VsYXRlZCBpdCAoaXQncyBERVYtb25seSBpbiB0aGlzIG1ldGhvZC4pXG4gICAgdHlwZW9mIGlzQ3VzdG9tQ29tcG9uZW50VGFnID09PSAnYm9vbGVhbicpIHtcbiAgICAgIC8vIFZhbGlkYXRlIHRoYXQgdGhlIHByb3BlcnRpZXMgY29ycmVzcG9uZCB0byB0aGVpciBleHBlY3RlZCB2YWx1ZXMuXG4gICAgICB2YXIgc2VydmVyVmFsdWUgPSB2b2lkIDA7XG4gICAgICB2YXIgcHJvcGVydHlJbmZvID0gZ2V0UHJvcGVydHlJbmZvKHByb3BLZXkpO1xuXG4gICAgICBpZiAoc3VwcHJlc3NIeWRyYXRpb25XYXJuaW5nKSA7IGVsc2UgaWYgKHByb3BLZXkgPT09IFNVUFBSRVNTX0NPTlRFTlRfRURJVEFCTEVfV0FSTklORyB8fCBwcm9wS2V5ID09PSBTVVBQUkVTU19IWURSQVRJT05fV0FSTklORyB8fCAvLyBDb250cm9sbGVkIGF0dHJpYnV0ZXMgYXJlIG5vdCB2YWxpZGF0ZWRcbiAgICAgIC8vIFRPRE86IE9ubHkgaWdub3JlIHRoZW0gb24gY29udHJvbGxlZCB0YWdzLlxuICAgICAgcHJvcEtleSA9PT0gJ3ZhbHVlJyB8fCBwcm9wS2V5ID09PSAnY2hlY2tlZCcgfHwgcHJvcEtleSA9PT0gJ3NlbGVjdGVkJykgOyBlbHNlIGlmIChwcm9wS2V5ID09PSBEQU5HRVJPVVNMWV9TRVRfSU5ORVJfSFRNTCkge1xuICAgICAgICB2YXIgc2VydmVySFRNTCA9IGRvbUVsZW1lbnQuaW5uZXJIVE1MO1xuICAgICAgICB2YXIgbmV4dEh0bWwgPSBuZXh0UHJvcCA/IG5leHRQcm9wW0hUTUwkMV0gOiB1bmRlZmluZWQ7XG5cbiAgICAgICAgaWYgKG5leHRIdG1sICE9IG51bGwpIHtcbiAgICAgICAgICB2YXIgZXhwZWN0ZWRIVE1MID0gbm9ybWFsaXplSFRNTChkb21FbGVtZW50LCBuZXh0SHRtbCk7XG5cbiAgICAgICAgICBpZiAoZXhwZWN0ZWRIVE1MICE9PSBzZXJ2ZXJIVE1MKSB7XG4gICAgICAgICAgICB3YXJuRm9yUHJvcERpZmZlcmVuY2UocHJvcEtleSwgc2VydmVySFRNTCwgZXhwZWN0ZWRIVE1MKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAocHJvcEtleSA9PT0gU1RZTEUpIHtcbiAgICAgICAgLy8gJEZsb3dGaXhNZSAtIFNob3VsZCBiZSBpbmZlcnJlZCBhcyBub3QgdW5kZWZpbmVkLlxuICAgICAgICBleHRyYUF0dHJpYnV0ZU5hbWVzLmRlbGV0ZShwcm9wS2V5KTtcblxuICAgICAgICBpZiAoY2FuRGlmZlN0eWxlRm9ySHlkcmF0aW9uV2FybmluZykge1xuICAgICAgICAgIHZhciBleHBlY3RlZFN0eWxlID0gY3JlYXRlRGFuZ2Vyb3VzU3RyaW5nRm9yU3R5bGVzKG5leHRQcm9wKTtcbiAgICAgICAgICBzZXJ2ZXJWYWx1ZSA9IGRvbUVsZW1lbnQuZ2V0QXR0cmlidXRlKCdzdHlsZScpO1xuXG4gICAgICAgICAgaWYgKGV4cGVjdGVkU3R5bGUgIT09IHNlcnZlclZhbHVlKSB7XG4gICAgICAgICAgICB3YXJuRm9yUHJvcERpZmZlcmVuY2UocHJvcEtleSwgc2VydmVyVmFsdWUsIGV4cGVjdGVkU3R5bGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChpc0N1c3RvbUNvbXBvbmVudFRhZykge1xuICAgICAgICAvLyAkRmxvd0ZpeE1lIC0gU2hvdWxkIGJlIGluZmVycmVkIGFzIG5vdCB1bmRlZmluZWQuXG4gICAgICAgIGV4dHJhQXR0cmlidXRlTmFtZXMuZGVsZXRlKHByb3BLZXkudG9Mb3dlckNhc2UoKSk7XG4gICAgICAgIHNlcnZlclZhbHVlID0gZ2V0VmFsdWVGb3JBdHRyaWJ1dGUoZG9tRWxlbWVudCwgcHJvcEtleSwgbmV4dFByb3ApO1xuXG4gICAgICAgIGlmIChuZXh0UHJvcCAhPT0gc2VydmVyVmFsdWUpIHtcbiAgICAgICAgICB3YXJuRm9yUHJvcERpZmZlcmVuY2UocHJvcEtleSwgc2VydmVyVmFsdWUsIG5leHRQcm9wKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICghc2hvdWxkSWdub3JlQXR0cmlidXRlKHByb3BLZXksIHByb3BlcnR5SW5mbywgaXNDdXN0b21Db21wb25lbnRUYWcpICYmICFzaG91bGRSZW1vdmVBdHRyaWJ1dGUocHJvcEtleSwgbmV4dFByb3AsIHByb3BlcnR5SW5mbywgaXNDdXN0b21Db21wb25lbnRUYWcpKSB7XG4gICAgICAgIHZhciBpc01pc21hdGNoRHVlVG9CYWRDYXNpbmcgPSBmYWxzZTtcblxuICAgICAgICBpZiAocHJvcGVydHlJbmZvICE9PSBudWxsKSB7XG4gICAgICAgICAgLy8gJEZsb3dGaXhNZSAtIFNob3VsZCBiZSBpbmZlcnJlZCBhcyBub3QgdW5kZWZpbmVkLlxuICAgICAgICAgIGV4dHJhQXR0cmlidXRlTmFtZXMuZGVsZXRlKHByb3BlcnR5SW5mby5hdHRyaWJ1dGVOYW1lKTtcbiAgICAgICAgICBzZXJ2ZXJWYWx1ZSA9IGdldFZhbHVlRm9yUHJvcGVydHkoZG9tRWxlbWVudCwgcHJvcEtleSwgbmV4dFByb3AsIHByb3BlcnR5SW5mbyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIG93bk5hbWVzcGFjZSA9IHBhcmVudE5hbWVzcGFjZTtcblxuICAgICAgICAgIGlmIChvd25OYW1lc3BhY2UgPT09IEhUTUxfTkFNRVNQQUNFJDEpIHtcbiAgICAgICAgICAgIG93bk5hbWVzcGFjZSA9IGdldEludHJpbnNpY05hbWVzcGFjZSh0YWcpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChvd25OYW1lc3BhY2UgPT09IEhUTUxfTkFNRVNQQUNFJDEpIHtcbiAgICAgICAgICAgIC8vICRGbG93Rml4TWUgLSBTaG91bGQgYmUgaW5mZXJyZWQgYXMgbm90IHVuZGVmaW5lZC5cbiAgICAgICAgICAgIGV4dHJhQXR0cmlidXRlTmFtZXMuZGVsZXRlKHByb3BLZXkudG9Mb3dlckNhc2UoKSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBzdGFuZGFyZE5hbWUgPSBnZXRQb3NzaWJsZVN0YW5kYXJkTmFtZShwcm9wS2V5KTtcblxuICAgICAgICAgICAgaWYgKHN0YW5kYXJkTmFtZSAhPT0gbnVsbCAmJiBzdGFuZGFyZE5hbWUgIT09IHByb3BLZXkpIHtcbiAgICAgICAgICAgICAgLy8gSWYgYW4gU1ZHIHByb3AgaXMgc3VwcGxpZWQgd2l0aCBiYWQgY2FzaW5nLCBpdCB3aWxsXG4gICAgICAgICAgICAgIC8vIGJlIHN1Y2Nlc3NmdWxseSBwYXJzZWQgZnJvbSBIVE1MLCBidXQgd2lsbCBwcm9kdWNlIGEgbWlzbWF0Y2hcbiAgICAgICAgICAgICAgLy8gKGFuZCB3b3VsZCBiZSBpbmNvcnJlY3RseSByZW5kZXJlZCBvbiB0aGUgY2xpZW50KS5cbiAgICAgICAgICAgICAgLy8gSG93ZXZlciwgd2UgYWxyZWFkeSB3YXJuIGFib3V0IGJhZCBjYXNpbmcgZWxzZXdoZXJlLlxuICAgICAgICAgICAgICAvLyBTbyB3ZSdsbCBza2lwIHRoZSBtaXNsZWFkaW5nIGV4dHJhIG1pc21hdGNoIHdhcm5pbmcgaW4gdGhpcyBjYXNlLlxuICAgICAgICAgICAgICBpc01pc21hdGNoRHVlVG9CYWRDYXNpbmcgPSB0cnVlOyAvLyAkRmxvd0ZpeE1lIC0gU2hvdWxkIGJlIGluZmVycmVkIGFzIG5vdCB1bmRlZmluZWQuXG5cbiAgICAgICAgICAgICAgZXh0cmFBdHRyaWJ1dGVOYW1lcy5kZWxldGUoc3RhbmRhcmROYW1lKTtcbiAgICAgICAgICAgIH0gLy8gJEZsb3dGaXhNZSAtIFNob3VsZCBiZSBpbmZlcnJlZCBhcyBub3QgdW5kZWZpbmVkLlxuXG5cbiAgICAgICAgICAgIGV4dHJhQXR0cmlidXRlTmFtZXMuZGVsZXRlKHByb3BLZXkpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHNlcnZlclZhbHVlID0gZ2V0VmFsdWVGb3JBdHRyaWJ1dGUoZG9tRWxlbWVudCwgcHJvcEtleSwgbmV4dFByb3ApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG5leHRQcm9wICE9PSBzZXJ2ZXJWYWx1ZSAmJiAhaXNNaXNtYXRjaER1ZVRvQmFkQ2FzaW5nKSB7XG4gICAgICAgICAgd2FybkZvclByb3BEaWZmZXJlbmNlKHByb3BLZXksIHNlcnZlclZhbHVlLCBuZXh0UHJvcCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB7XG4gICAgLy8gJEZsb3dGaXhNZSAtIFNob3VsZCBiZSBpbmZlcnJlZCBhcyBub3QgdW5kZWZpbmVkLlxuICAgIGlmIChleHRyYUF0dHJpYnV0ZU5hbWVzLnNpemUgPiAwICYmICFzdXBwcmVzc0h5ZHJhdGlvbldhcm5pbmcpIHtcbiAgICAgIC8vICRGbG93Rml4TWUgLSBTaG91bGQgYmUgaW5mZXJyZWQgYXMgbm90IHVuZGVmaW5lZC5cbiAgICAgIHdhcm5Gb3JFeHRyYUF0dHJpYnV0ZXMoZXh0cmFBdHRyaWJ1dGVOYW1lcyk7XG4gICAgfVxuICB9XG5cbiAgc3dpdGNoICh0YWcpIHtcbiAgICBjYXNlICdpbnB1dCc6XG4gICAgICAvLyBUT0RPOiBNYWtlIHN1cmUgd2UgY2hlY2sgaWYgdGhpcyBpcyBzdGlsbCB1bm1vdW50ZWQgb3IgZG8gYW55IGNsZWFuXG4gICAgICAvLyB1cCBuZWNlc3Nhcnkgc2luY2Ugd2UgbmV2ZXIgc3RvcCB0cmFja2luZyBhbnltb3JlLlxuICAgICAgdHJhY2soZG9tRWxlbWVudCk7XG4gICAgICBwb3N0TW91bnRXcmFwcGVyKGRvbUVsZW1lbnQsIHJhd1Byb3BzLCB0cnVlKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAndGV4dGFyZWEnOlxuICAgICAgLy8gVE9ETzogTWFrZSBzdXJlIHdlIGNoZWNrIGlmIHRoaXMgaXMgc3RpbGwgdW5tb3VudGVkIG9yIGRvIGFueSBjbGVhblxuICAgICAgLy8gdXAgbmVjZXNzYXJ5IHNpbmNlIHdlIG5ldmVyIHN0b3AgdHJhY2tpbmcgYW55bW9yZS5cbiAgICAgIHRyYWNrKGRvbUVsZW1lbnQpO1xuICAgICAgcG9zdE1vdW50V3JhcHBlciQzKGRvbUVsZW1lbnQpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdzZWxlY3QnOlxuICAgIGNhc2UgJ29wdGlvbic6XG4gICAgICAvLyBGb3IgaW5wdXQgYW5kIHRleHRhcmVhIHdlIGN1cnJlbnQgYWx3YXlzIHNldCB0aGUgdmFsdWUgcHJvcGVydHkgYXRcbiAgICAgIC8vIHBvc3QgbW91bnQgdG8gZm9yY2UgaXQgdG8gZGl2ZXJnZSBmcm9tIGF0dHJpYnV0ZXMuIEhvd2V2ZXIsIGZvclxuICAgICAgLy8gb3B0aW9uIGFuZCBzZWxlY3Qgd2UgZG9uJ3QgcXVpdGUgZG8gdGhlIHNhbWUgdGhpbmcgYW5kIHNlbGVjdFxuICAgICAgLy8gaXMgbm90IHJlc2lsaWVudCB0byB0aGUgRE9NIHN0YXRlIGNoYW5naW5nIHNvIHdlIGRvbid0IGRvIHRoYXQgaGVyZS5cbiAgICAgIC8vIFRPRE86IENvbnNpZGVyIG5vdCBkb2luZyB0aGlzIGZvciBpbnB1dCBhbmQgdGV4dGFyZWEuXG4gICAgICBicmVhaztcblxuICAgIGRlZmF1bHQ6XG4gICAgICBpZiAodHlwZW9mIHJhd1Byb3BzLm9uQ2xpY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgLy8gVE9ETzogVGhpcyBjYXN0IG1heSBub3QgYmUgc291bmQgZm9yIFNWRywgTWF0aE1MIG9yIGN1c3RvbSBlbGVtZW50cy5cbiAgICAgICAgdHJhcENsaWNrT25Ob25JbnRlcmFjdGl2ZUVsZW1lbnQoZG9tRWxlbWVudCk7XG4gICAgICB9XG5cbiAgICAgIGJyZWFrO1xuICB9XG5cbiAgcmV0dXJuIHVwZGF0ZVBheWxvYWQ7XG59XG5mdW5jdGlvbiBkaWZmSHlkcmF0ZWRUZXh0KHRleHROb2RlLCB0ZXh0KSB7XG4gIHZhciBpc0RpZmZlcmVudCA9IHRleHROb2RlLm5vZGVWYWx1ZSAhPT0gdGV4dDtcbiAgcmV0dXJuIGlzRGlmZmVyZW50O1xufVxuZnVuY3Rpb24gd2FybkZvclVubWF0Y2hlZFRleHQodGV4dE5vZGUsIHRleHQpIHtcbiAge1xuICAgIHdhcm5Gb3JUZXh0RGlmZmVyZW5jZSh0ZXh0Tm9kZS5ub2RlVmFsdWUsIHRleHQpO1xuICB9XG59XG5mdW5jdGlvbiB3YXJuRm9yRGVsZXRlZEh5ZHJhdGFibGVFbGVtZW50KHBhcmVudE5vZGUsIGNoaWxkKSB7XG4gIHtcbiAgICBpZiAoZGlkV2FybkludmFsaWRIeWRyYXRpb24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBkaWRXYXJuSW52YWxpZEh5ZHJhdGlvbiA9IHRydWU7XG5cbiAgICBlcnJvcignRGlkIG5vdCBleHBlY3Qgc2VydmVyIEhUTUwgdG8gY29udGFpbiBhIDwlcz4gaW4gPCVzPi4nLCBjaGlsZC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpLCBwYXJlbnROb2RlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkpO1xuICB9XG59XG5mdW5jdGlvbiB3YXJuRm9yRGVsZXRlZEh5ZHJhdGFibGVUZXh0KHBhcmVudE5vZGUsIGNoaWxkKSB7XG4gIHtcbiAgICBpZiAoZGlkV2FybkludmFsaWRIeWRyYXRpb24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBkaWRXYXJuSW52YWxpZEh5ZHJhdGlvbiA9IHRydWU7XG5cbiAgICBlcnJvcignRGlkIG5vdCBleHBlY3Qgc2VydmVyIEhUTUwgdG8gY29udGFpbiB0aGUgdGV4dCBub2RlIFwiJXNcIiBpbiA8JXM+LicsIGNoaWxkLm5vZGVWYWx1ZSwgcGFyZW50Tm9kZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpKTtcbiAgfVxufVxuZnVuY3Rpb24gd2FybkZvckluc2VydGVkSHlkcmF0ZWRFbGVtZW50KHBhcmVudE5vZGUsIHRhZywgcHJvcHMpIHtcbiAge1xuICAgIGlmIChkaWRXYXJuSW52YWxpZEh5ZHJhdGlvbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGRpZFdhcm5JbnZhbGlkSHlkcmF0aW9uID0gdHJ1ZTtcblxuICAgIGVycm9yKCdFeHBlY3RlZCBzZXJ2ZXIgSFRNTCB0byBjb250YWluIGEgbWF0Y2hpbmcgPCVzPiBpbiA8JXM+LicsIHRhZywgcGFyZW50Tm9kZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpKTtcbiAgfVxufVxuZnVuY3Rpb24gd2FybkZvckluc2VydGVkSHlkcmF0ZWRUZXh0KHBhcmVudE5vZGUsIHRleHQpIHtcbiAge1xuICAgIGlmICh0ZXh0ID09PSAnJykge1xuICAgICAgLy8gV2UgZXhwZWN0IHRvIGluc2VydCBlbXB0eSB0ZXh0IG5vZGVzIHNpbmNlIHRoZXkncmUgbm90IHJlcHJlc2VudGVkIGluXG4gICAgICAvLyB0aGUgSFRNTC5cbiAgICAgIC8vIFRPRE86IFJlbW92ZSB0aGlzIHNwZWNpYWwgY2FzZSBpZiB3ZSBjYW4ganVzdCBhdm9pZCBpbnNlcnRpbmcgZW1wdHlcbiAgICAgIC8vIHRleHQgbm9kZXMuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGRpZFdhcm5JbnZhbGlkSHlkcmF0aW9uKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZGlkV2FybkludmFsaWRIeWRyYXRpb24gPSB0cnVlO1xuXG4gICAgZXJyb3IoJ0V4cGVjdGVkIHNlcnZlciBIVE1MIHRvIGNvbnRhaW4gYSBtYXRjaGluZyB0ZXh0IG5vZGUgZm9yIFwiJXNcIiBpbiA8JXM+LicsIHRleHQsIHBhcmVudE5vZGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKSk7XG4gIH1cbn1cbmZ1bmN0aW9uIHJlc3RvcmVDb250cm9sbGVkU3RhdGUkMyhkb21FbGVtZW50LCB0YWcsIHByb3BzKSB7XG4gIHN3aXRjaCAodGFnKSB7XG4gICAgY2FzZSAnaW5wdXQnOlxuICAgICAgcmVzdG9yZUNvbnRyb2xsZWRTdGF0ZShkb21FbGVtZW50LCBwcm9wcyk7XG4gICAgICByZXR1cm47XG5cbiAgICBjYXNlICd0ZXh0YXJlYSc6XG4gICAgICByZXN0b3JlQ29udHJvbGxlZFN0YXRlJDIoZG9tRWxlbWVudCwgcHJvcHMpO1xuICAgICAgcmV0dXJuO1xuXG4gICAgY2FzZSAnc2VsZWN0JzpcbiAgICAgIHJlc3RvcmVDb250cm9sbGVkU3RhdGUkMShkb21FbGVtZW50LCBwcm9wcyk7XG4gICAgICByZXR1cm47XG4gIH1cbn1cblxudmFyIHZhbGlkYXRlRE9NTmVzdGluZyA9IGZ1bmN0aW9uICgpIHt9O1xuXG52YXIgdXBkYXRlZEFuY2VzdG9ySW5mbyA9IGZ1bmN0aW9uICgpIHt9O1xuXG57XG4gIC8vIFRoaXMgdmFsaWRhdGlvbiBjb2RlIHdhcyB3cml0dGVuIGJhc2VkIG9uIHRoZSBIVE1MNSBwYXJzaW5nIHNwZWM6XG4gIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI2hhcy1hbi1lbGVtZW50LWluLXNjb3BlXG4gIC8vXG4gIC8vIE5vdGU6IHRoaXMgZG9lcyBub3QgY2F0Y2ggYWxsIGludmFsaWQgbmVzdGluZywgbm9yIGRvZXMgaXQgdHJ5IHRvIChhcyBpdCdzXG4gIC8vIG5vdCBjbGVhciB3aGF0IHByYWN0aWNhbCBiZW5lZml0IGRvaW5nIHNvIHByb3ZpZGVzKTsgaW5zdGVhZCwgd2Ugd2FybiBvbmx5XG4gIC8vIGZvciBjYXNlcyB3aGVyZSB0aGUgcGFyc2VyIHdpbGwgZ2l2ZSBhIHBhcnNlIHRyZWUgZGlmZmVyaW5nIGZyb20gd2hhdCBSZWFjdFxuICAvLyBpbnRlbmRlZC4gRm9yIGV4YW1wbGUsIDxiPjxkaXY+PC9kaXY+PC9iPiBpcyBpbnZhbGlkIGJ1dCB3ZSBkb24ndCB3YXJuXG4gIC8vIGJlY2F1c2UgaXQgc3RpbGwgcGFyc2VzIGNvcnJlY3RseTsgd2UgZG8gd2FybiBmb3Igb3RoZXIgY2FzZXMgbGlrZSBuZXN0ZWRcbiAgLy8gPHA+IHRhZ3Mgd2hlcmUgdGhlIGJlZ2lubmluZyBvZiB0aGUgc2Vjb25kIGVsZW1lbnQgaW1wbGljaXRseSBjbG9zZXMgdGhlXG4gIC8vIGZpcnN0LCBjYXVzaW5nIGEgY29uZnVzaW5nIG1lc3MuXG4gIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI3NwZWNpYWxcbiAgdmFyIHNwZWNpYWxUYWdzID0gWydhZGRyZXNzJywgJ2FwcGxldCcsICdhcmVhJywgJ2FydGljbGUnLCAnYXNpZGUnLCAnYmFzZScsICdiYXNlZm9udCcsICdiZ3NvdW5kJywgJ2Jsb2NrcXVvdGUnLCAnYm9keScsICdicicsICdidXR0b24nLCAnY2FwdGlvbicsICdjZW50ZXInLCAnY29sJywgJ2NvbGdyb3VwJywgJ2RkJywgJ2RldGFpbHMnLCAnZGlyJywgJ2RpdicsICdkbCcsICdkdCcsICdlbWJlZCcsICdmaWVsZHNldCcsICdmaWdjYXB0aW9uJywgJ2ZpZ3VyZScsICdmb290ZXInLCAnZm9ybScsICdmcmFtZScsICdmcmFtZXNldCcsICdoMScsICdoMicsICdoMycsICdoNCcsICdoNScsICdoNicsICdoZWFkJywgJ2hlYWRlcicsICdoZ3JvdXAnLCAnaHInLCAnaHRtbCcsICdpZnJhbWUnLCAnaW1nJywgJ2lucHV0JywgJ2lzaW5kZXgnLCAnbGknLCAnbGluaycsICdsaXN0aW5nJywgJ21haW4nLCAnbWFycXVlZScsICdtZW51JywgJ21lbnVpdGVtJywgJ21ldGEnLCAnbmF2JywgJ25vZW1iZWQnLCAnbm9mcmFtZXMnLCAnbm9zY3JpcHQnLCAnb2JqZWN0JywgJ29sJywgJ3AnLCAncGFyYW0nLCAncGxhaW50ZXh0JywgJ3ByZScsICdzY3JpcHQnLCAnc2VjdGlvbicsICdzZWxlY3QnLCAnc291cmNlJywgJ3N0eWxlJywgJ3N1bW1hcnknLCAndGFibGUnLCAndGJvZHknLCAndGQnLCAndGVtcGxhdGUnLCAndGV4dGFyZWEnLCAndGZvb3QnLCAndGgnLCAndGhlYWQnLCAndGl0bGUnLCAndHInLCAndHJhY2snLCAndWwnLCAnd2JyJywgJ3htcCddOyAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNoYXMtYW4tZWxlbWVudC1pbi1zY29wZVxuXG4gIHZhciBpblNjb3BlVGFncyA9IFsnYXBwbGV0JywgJ2NhcHRpb24nLCAnaHRtbCcsICd0YWJsZScsICd0ZCcsICd0aCcsICdtYXJxdWVlJywgJ29iamVjdCcsICd0ZW1wbGF0ZScsIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI2h0bWwtaW50ZWdyYXRpb24tcG9pbnRcbiAgLy8gVE9ETzogRGlzdGluZ3Vpc2ggYnkgbmFtZXNwYWNlIGhlcmUgLS0gZm9yIDx0aXRsZT4sIGluY2x1ZGluZyBpdCBoZXJlXG4gIC8vIGVycnMgb24gdGhlIHNpZGUgb2YgZmV3ZXIgd2FybmluZ3NcbiAgJ2ZvcmVpZ25PYmplY3QnLCAnZGVzYycsICd0aXRsZSddOyAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNoYXMtYW4tZWxlbWVudC1pbi1idXR0b24tc2NvcGVcblxuICB2YXIgYnV0dG9uU2NvcGVUYWdzID0gaW5TY29wZVRhZ3MuY29uY2F0KFsnYnV0dG9uJ10pOyAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNnZW5lcmF0ZS1pbXBsaWVkLWVuZC10YWdzXG5cbiAgdmFyIGltcGxpZWRFbmRUYWdzID0gWydkZCcsICdkdCcsICdsaScsICdvcHRpb24nLCAnb3B0Z3JvdXAnLCAncCcsICdycCcsICdydCddO1xuICB2YXIgZW1wdHlBbmNlc3RvckluZm8gPSB7XG4gICAgY3VycmVudDogbnVsbCxcbiAgICBmb3JtVGFnOiBudWxsLFxuICAgIGFUYWdJblNjb3BlOiBudWxsLFxuICAgIGJ1dHRvblRhZ0luU2NvcGU6IG51bGwsXG4gICAgbm9iclRhZ0luU2NvcGU6IG51bGwsXG4gICAgcFRhZ0luQnV0dG9uU2NvcGU6IG51bGwsXG4gICAgbGlzdEl0ZW1UYWdBdXRvY2xvc2luZzogbnVsbCxcbiAgICBkbEl0ZW1UYWdBdXRvY2xvc2luZzogbnVsbFxuICB9O1xuXG4gIHVwZGF0ZWRBbmNlc3RvckluZm8gPSBmdW5jdGlvbiAob2xkSW5mbywgdGFnKSB7XG4gICAgdmFyIGFuY2VzdG9ySW5mbyA9IF9hc3NpZ24oe30sIG9sZEluZm8gfHwgZW1wdHlBbmNlc3RvckluZm8pO1xuXG4gICAgdmFyIGluZm8gPSB7XG4gICAgICB0YWc6IHRhZ1xuICAgIH07XG5cbiAgICBpZiAoaW5TY29wZVRhZ3MuaW5kZXhPZih0YWcpICE9PSAtMSkge1xuICAgICAgYW5jZXN0b3JJbmZvLmFUYWdJblNjb3BlID0gbnVsbDtcbiAgICAgIGFuY2VzdG9ySW5mby5idXR0b25UYWdJblNjb3BlID0gbnVsbDtcbiAgICAgIGFuY2VzdG9ySW5mby5ub2JyVGFnSW5TY29wZSA9IG51bGw7XG4gICAgfVxuXG4gICAgaWYgKGJ1dHRvblNjb3BlVGFncy5pbmRleE9mKHRhZykgIT09IC0xKSB7XG4gICAgICBhbmNlc3RvckluZm8ucFRhZ0luQnV0dG9uU2NvcGUgPSBudWxsO1xuICAgIH0gLy8gU2VlIHJ1bGVzIGZvciAnbGknLCAnZGQnLCAnZHQnIHN0YXJ0IHRhZ3MgaW5cbiAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNwYXJzaW5nLW1haW4taW5ib2R5XG5cblxuICAgIGlmIChzcGVjaWFsVGFncy5pbmRleE9mKHRhZykgIT09IC0xICYmIHRhZyAhPT0gJ2FkZHJlc3MnICYmIHRhZyAhPT0gJ2RpdicgJiYgdGFnICE9PSAncCcpIHtcbiAgICAgIGFuY2VzdG9ySW5mby5saXN0SXRlbVRhZ0F1dG9jbG9zaW5nID0gbnVsbDtcbiAgICAgIGFuY2VzdG9ySW5mby5kbEl0ZW1UYWdBdXRvY2xvc2luZyA9IG51bGw7XG4gICAgfVxuXG4gICAgYW5jZXN0b3JJbmZvLmN1cnJlbnQgPSBpbmZvO1xuXG4gICAgaWYgKHRhZyA9PT0gJ2Zvcm0nKSB7XG4gICAgICBhbmNlc3RvckluZm8uZm9ybVRhZyA9IGluZm87XG4gICAgfVxuXG4gICAgaWYgKHRhZyA9PT0gJ2EnKSB7XG4gICAgICBhbmNlc3RvckluZm8uYVRhZ0luU2NvcGUgPSBpbmZvO1xuICAgIH1cblxuICAgIGlmICh0YWcgPT09ICdidXR0b24nKSB7XG4gICAgICBhbmNlc3RvckluZm8uYnV0dG9uVGFnSW5TY29wZSA9IGluZm87XG4gICAgfVxuXG4gICAgaWYgKHRhZyA9PT0gJ25vYnInKSB7XG4gICAgICBhbmNlc3RvckluZm8ubm9iclRhZ0luU2NvcGUgPSBpbmZvO1xuICAgIH1cblxuICAgIGlmICh0YWcgPT09ICdwJykge1xuICAgICAgYW5jZXN0b3JJbmZvLnBUYWdJbkJ1dHRvblNjb3BlID0gaW5mbztcbiAgICB9XG5cbiAgICBpZiAodGFnID09PSAnbGknKSB7XG4gICAgICBhbmNlc3RvckluZm8ubGlzdEl0ZW1UYWdBdXRvY2xvc2luZyA9IGluZm87XG4gICAgfVxuXG4gICAgaWYgKHRhZyA9PT0gJ2RkJyB8fCB0YWcgPT09ICdkdCcpIHtcbiAgICAgIGFuY2VzdG9ySW5mby5kbEl0ZW1UYWdBdXRvY2xvc2luZyA9IGluZm87XG4gICAgfVxuXG4gICAgcmV0dXJuIGFuY2VzdG9ySW5mbztcbiAgfTtcbiAgLyoqXG4gICAqIFJldHVybnMgd2hldGhlclxuICAgKi9cblxuXG4gIHZhciBpc1RhZ1ZhbGlkV2l0aFBhcmVudCA9IGZ1bmN0aW9uICh0YWcsIHBhcmVudFRhZykge1xuICAgIC8vIEZpcnN0LCBsZXQncyBjaGVjayBpZiB3ZSdyZSBpbiBhbiB1bnVzdWFsIHBhcnNpbmcgbW9kZS4uLlxuICAgIHN3aXRjaCAocGFyZW50VGFnKSB7XG4gICAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNwYXJzaW5nLW1haW4taW5zZWxlY3RcbiAgICAgIGNhc2UgJ3NlbGVjdCc6XG4gICAgICAgIHJldHVybiB0YWcgPT09ICdvcHRpb24nIHx8IHRhZyA9PT0gJ29wdGdyb3VwJyB8fCB0YWcgPT09ICcjdGV4dCc7XG5cbiAgICAgIGNhc2UgJ29wdGdyb3VwJzpcbiAgICAgICAgcmV0dXJuIHRhZyA9PT0gJ29wdGlvbicgfHwgdGFnID09PSAnI3RleHQnO1xuICAgICAgLy8gU3RyaWN0bHkgc3BlYWtpbmcsIHNlZWluZyBhbiA8b3B0aW9uPiBkb2Vzbid0IG1lYW4gd2UncmUgaW4gYSA8c2VsZWN0PlxuICAgICAgLy8gYnV0XG5cbiAgICAgIGNhc2UgJ29wdGlvbic6XG4gICAgICAgIHJldHVybiB0YWcgPT09ICcjdGV4dCc7XG4gICAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNwYXJzaW5nLW1haW4taW50ZFxuICAgICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjcGFyc2luZy1tYWluLWluY2FwdGlvblxuICAgICAgLy8gTm8gc3BlY2lhbCBiZWhhdmlvciBzaW5jZSB0aGVzZSBydWxlcyBmYWxsIGJhY2sgdG8gXCJpbiBib2R5XCIgbW9kZSBmb3JcbiAgICAgIC8vIGFsbCBleGNlcHQgc3BlY2lhbCB0YWJsZSBub2RlcyB3aGljaCBjYXVzZSBiYWQgcGFyc2luZyBiZWhhdmlvciBhbnl3YXkuXG4gICAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNwYXJzaW5nLW1haW4taW50clxuXG4gICAgICBjYXNlICd0cic6XG4gICAgICAgIHJldHVybiB0YWcgPT09ICd0aCcgfHwgdGFnID09PSAndGQnIHx8IHRhZyA9PT0gJ3N0eWxlJyB8fCB0YWcgPT09ICdzY3JpcHQnIHx8IHRhZyA9PT0gJ3RlbXBsYXRlJztcbiAgICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI3BhcnNpbmctbWFpbi1pbnRib2R5XG5cbiAgICAgIGNhc2UgJ3Rib2R5JzpcbiAgICAgIGNhc2UgJ3RoZWFkJzpcbiAgICAgIGNhc2UgJ3Rmb290JzpcbiAgICAgICAgcmV0dXJuIHRhZyA9PT0gJ3RyJyB8fCB0YWcgPT09ICdzdHlsZScgfHwgdGFnID09PSAnc2NyaXB0JyB8fCB0YWcgPT09ICd0ZW1wbGF0ZSc7XG4gICAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNwYXJzaW5nLW1haW4taW5jb2xncm91cFxuXG4gICAgICBjYXNlICdjb2xncm91cCc6XG4gICAgICAgIHJldHVybiB0YWcgPT09ICdjb2wnIHx8IHRhZyA9PT0gJ3RlbXBsYXRlJztcbiAgICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI3BhcnNpbmctbWFpbi1pbnRhYmxlXG5cbiAgICAgIGNhc2UgJ3RhYmxlJzpcbiAgICAgICAgcmV0dXJuIHRhZyA9PT0gJ2NhcHRpb24nIHx8IHRhZyA9PT0gJ2NvbGdyb3VwJyB8fCB0YWcgPT09ICd0Ym9keScgfHwgdGFnID09PSAndGZvb3QnIHx8IHRhZyA9PT0gJ3RoZWFkJyB8fCB0YWcgPT09ICdzdHlsZScgfHwgdGFnID09PSAnc2NyaXB0JyB8fCB0YWcgPT09ICd0ZW1wbGF0ZSc7XG4gICAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNwYXJzaW5nLW1haW4taW5oZWFkXG5cbiAgICAgIGNhc2UgJ2hlYWQnOlxuICAgICAgICByZXR1cm4gdGFnID09PSAnYmFzZScgfHwgdGFnID09PSAnYmFzZWZvbnQnIHx8IHRhZyA9PT0gJ2Jnc291bmQnIHx8IHRhZyA9PT0gJ2xpbmsnIHx8IHRhZyA9PT0gJ21ldGEnIHx8IHRhZyA9PT0gJ3RpdGxlJyB8fCB0YWcgPT09ICdub3NjcmlwdCcgfHwgdGFnID09PSAnbm9mcmFtZXMnIHx8IHRhZyA9PT0gJ3N0eWxlJyB8fCB0YWcgPT09ICdzY3JpcHQnIHx8IHRhZyA9PT0gJ3RlbXBsYXRlJztcbiAgICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3NlbWFudGljcy5odG1sI3RoZS1odG1sLWVsZW1lbnRcblxuICAgICAgY2FzZSAnaHRtbCc6XG4gICAgICAgIHJldHVybiB0YWcgPT09ICdoZWFkJyB8fCB0YWcgPT09ICdib2R5JyB8fCB0YWcgPT09ICdmcmFtZXNldCc7XG5cbiAgICAgIGNhc2UgJ2ZyYW1lc2V0JzpcbiAgICAgICAgcmV0dXJuIHRhZyA9PT0gJ2ZyYW1lJztcblxuICAgICAgY2FzZSAnI2RvY3VtZW50JzpcbiAgICAgICAgcmV0dXJuIHRhZyA9PT0gJ2h0bWwnO1xuICAgIH0gLy8gUHJvYmFibHkgaW4gdGhlIFwiaW4gYm9keVwiIHBhcnNpbmcgbW9kZSwgc28gd2Ugb3V0bGF3IG9ubHkgdGFnIGNvbWJvc1xuICAgIC8vIHdoZXJlIHRoZSBwYXJzaW5nIHJ1bGVzIGNhdXNlIGltcGxpY2l0IG9wZW5zIG9yIGNsb3NlcyB0byBiZSBhZGRlZC5cbiAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNwYXJzaW5nLW1haW4taW5ib2R5XG5cblxuICAgIHN3aXRjaCAodGFnKSB7XG4gICAgICBjYXNlICdoMSc6XG4gICAgICBjYXNlICdoMic6XG4gICAgICBjYXNlICdoMyc6XG4gICAgICBjYXNlICdoNCc6XG4gICAgICBjYXNlICdoNSc6XG4gICAgICBjYXNlICdoNic6XG4gICAgICAgIHJldHVybiBwYXJlbnRUYWcgIT09ICdoMScgJiYgcGFyZW50VGFnICE9PSAnaDInICYmIHBhcmVudFRhZyAhPT0gJ2gzJyAmJiBwYXJlbnRUYWcgIT09ICdoNCcgJiYgcGFyZW50VGFnICE9PSAnaDUnICYmIHBhcmVudFRhZyAhPT0gJ2g2JztcblxuICAgICAgY2FzZSAncnAnOlxuICAgICAgY2FzZSAncnQnOlxuICAgICAgICByZXR1cm4gaW1wbGllZEVuZFRhZ3MuaW5kZXhPZihwYXJlbnRUYWcpID09PSAtMTtcblxuICAgICAgY2FzZSAnYm9keSc6XG4gICAgICBjYXNlICdjYXB0aW9uJzpcbiAgICAgIGNhc2UgJ2NvbCc6XG4gICAgICBjYXNlICdjb2xncm91cCc6XG4gICAgICBjYXNlICdmcmFtZXNldCc6XG4gICAgICBjYXNlICdmcmFtZSc6XG4gICAgICBjYXNlICdoZWFkJzpcbiAgICAgIGNhc2UgJ2h0bWwnOlxuICAgICAgY2FzZSAndGJvZHknOlxuICAgICAgY2FzZSAndGQnOlxuICAgICAgY2FzZSAndGZvb3QnOlxuICAgICAgY2FzZSAndGgnOlxuICAgICAgY2FzZSAndGhlYWQnOlxuICAgICAgY2FzZSAndHInOlxuICAgICAgICAvLyBUaGVzZSB0YWdzIGFyZSBvbmx5IHZhbGlkIHdpdGggYSBmZXcgcGFyZW50cyB0aGF0IGhhdmUgc3BlY2lhbCBjaGlsZFxuICAgICAgICAvLyBwYXJzaW5nIHJ1bGVzIC0tIGlmIHdlJ3JlIGRvd24gaGVyZSwgdGhlbiBub25lIG9mIHRob3NlIG1hdGNoZWQgYW5kXG4gICAgICAgIC8vIHNvIHdlIGFsbG93IGl0IG9ubHkgaWYgd2UgZG9uJ3Qga25vdyB3aGF0IHRoZSBwYXJlbnQgaXMsIGFzIGFsbCBvdGhlclxuICAgICAgICAvLyBjYXNlcyBhcmUgaW52YWxpZC5cbiAgICAgICAgcmV0dXJuIHBhcmVudFRhZyA9PSBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9O1xuICAvKipcbiAgICogUmV0dXJucyB3aGV0aGVyXG4gICAqL1xuXG5cbiAgdmFyIGZpbmRJbnZhbGlkQW5jZXN0b3JGb3JUYWcgPSBmdW5jdGlvbiAodGFnLCBhbmNlc3RvckluZm8pIHtcbiAgICBzd2l0Y2ggKHRhZykge1xuICAgICAgY2FzZSAnYWRkcmVzcyc6XG4gICAgICBjYXNlICdhcnRpY2xlJzpcbiAgICAgIGNhc2UgJ2FzaWRlJzpcbiAgICAgIGNhc2UgJ2Jsb2NrcXVvdGUnOlxuICAgICAgY2FzZSAnY2VudGVyJzpcbiAgICAgIGNhc2UgJ2RldGFpbHMnOlxuICAgICAgY2FzZSAnZGlhbG9nJzpcbiAgICAgIGNhc2UgJ2Rpcic6XG4gICAgICBjYXNlICdkaXYnOlxuICAgICAgY2FzZSAnZGwnOlxuICAgICAgY2FzZSAnZmllbGRzZXQnOlxuICAgICAgY2FzZSAnZmlnY2FwdGlvbic6XG4gICAgICBjYXNlICdmaWd1cmUnOlxuICAgICAgY2FzZSAnZm9vdGVyJzpcbiAgICAgIGNhc2UgJ2hlYWRlcic6XG4gICAgICBjYXNlICdoZ3JvdXAnOlxuICAgICAgY2FzZSAnbWFpbic6XG4gICAgICBjYXNlICdtZW51JzpcbiAgICAgIGNhc2UgJ25hdic6XG4gICAgICBjYXNlICdvbCc6XG4gICAgICBjYXNlICdwJzpcbiAgICAgIGNhc2UgJ3NlY3Rpb24nOlxuICAgICAgY2FzZSAnc3VtbWFyeSc6XG4gICAgICBjYXNlICd1bCc6XG4gICAgICBjYXNlICdwcmUnOlxuICAgICAgY2FzZSAnbGlzdGluZyc6XG4gICAgICBjYXNlICd0YWJsZSc6XG4gICAgICBjYXNlICdocic6XG4gICAgICBjYXNlICd4bXAnOlxuICAgICAgY2FzZSAnaDEnOlxuICAgICAgY2FzZSAnaDInOlxuICAgICAgY2FzZSAnaDMnOlxuICAgICAgY2FzZSAnaDQnOlxuICAgICAgY2FzZSAnaDUnOlxuICAgICAgY2FzZSAnaDYnOlxuICAgICAgICByZXR1cm4gYW5jZXN0b3JJbmZvLnBUYWdJbkJ1dHRvblNjb3BlO1xuXG4gICAgICBjYXNlICdmb3JtJzpcbiAgICAgICAgcmV0dXJuIGFuY2VzdG9ySW5mby5mb3JtVGFnIHx8IGFuY2VzdG9ySW5mby5wVGFnSW5CdXR0b25TY29wZTtcblxuICAgICAgY2FzZSAnbGknOlxuICAgICAgICByZXR1cm4gYW5jZXN0b3JJbmZvLmxpc3RJdGVtVGFnQXV0b2Nsb3Npbmc7XG5cbiAgICAgIGNhc2UgJ2RkJzpcbiAgICAgIGNhc2UgJ2R0JzpcbiAgICAgICAgcmV0dXJuIGFuY2VzdG9ySW5mby5kbEl0ZW1UYWdBdXRvY2xvc2luZztcblxuICAgICAgY2FzZSAnYnV0dG9uJzpcbiAgICAgICAgcmV0dXJuIGFuY2VzdG9ySW5mby5idXR0b25UYWdJblNjb3BlO1xuXG4gICAgICBjYXNlICdhJzpcbiAgICAgICAgLy8gU3BlYyBzYXlzIHNvbWV0aGluZyBhYm91dCBzdG9yaW5nIGEgbGlzdCBvZiBtYXJrZXJzLCBidXQgaXQgc291bmRzXG4gICAgICAgIC8vIGVxdWl2YWxlbnQgdG8gdGhpcyBjaGVjay5cbiAgICAgICAgcmV0dXJuIGFuY2VzdG9ySW5mby5hVGFnSW5TY29wZTtcblxuICAgICAgY2FzZSAnbm9icic6XG4gICAgICAgIHJldHVybiBhbmNlc3RvckluZm8ubm9iclRhZ0luU2NvcGU7XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH07XG5cbiAgdmFyIGRpZFdhcm4kMSA9IHt9O1xuXG4gIHZhbGlkYXRlRE9NTmVzdGluZyA9IGZ1bmN0aW9uIChjaGlsZFRhZywgY2hpbGRUZXh0LCBhbmNlc3RvckluZm8pIHtcbiAgICBhbmNlc3RvckluZm8gPSBhbmNlc3RvckluZm8gfHwgZW1wdHlBbmNlc3RvckluZm87XG4gICAgdmFyIHBhcmVudEluZm8gPSBhbmNlc3RvckluZm8uY3VycmVudDtcbiAgICB2YXIgcGFyZW50VGFnID0gcGFyZW50SW5mbyAmJiBwYXJlbnRJbmZvLnRhZztcblxuICAgIGlmIChjaGlsZFRleHQgIT0gbnVsbCkge1xuICAgICAgaWYgKGNoaWxkVGFnICE9IG51bGwpIHtcbiAgICAgICAgZXJyb3IoJ3ZhbGlkYXRlRE9NTmVzdGluZzogd2hlbiBjaGlsZFRleHQgaXMgcGFzc2VkLCBjaGlsZFRhZyBzaG91bGQgYmUgbnVsbCcpO1xuICAgICAgfVxuXG4gICAgICBjaGlsZFRhZyA9ICcjdGV4dCc7XG4gICAgfVxuXG4gICAgdmFyIGludmFsaWRQYXJlbnQgPSBpc1RhZ1ZhbGlkV2l0aFBhcmVudChjaGlsZFRhZywgcGFyZW50VGFnKSA/IG51bGwgOiBwYXJlbnRJbmZvO1xuICAgIHZhciBpbnZhbGlkQW5jZXN0b3IgPSBpbnZhbGlkUGFyZW50ID8gbnVsbCA6IGZpbmRJbnZhbGlkQW5jZXN0b3JGb3JUYWcoY2hpbGRUYWcsIGFuY2VzdG9ySW5mbyk7XG4gICAgdmFyIGludmFsaWRQYXJlbnRPckFuY2VzdG9yID0gaW52YWxpZFBhcmVudCB8fCBpbnZhbGlkQW5jZXN0b3I7XG5cbiAgICBpZiAoIWludmFsaWRQYXJlbnRPckFuY2VzdG9yKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGFuY2VzdG9yVGFnID0gaW52YWxpZFBhcmVudE9yQW5jZXN0b3IudGFnO1xuICAgIHZhciB3YXJuS2V5ID0gISFpbnZhbGlkUGFyZW50ICsgJ3wnICsgY2hpbGRUYWcgKyAnfCcgKyBhbmNlc3RvclRhZztcblxuICAgIGlmIChkaWRXYXJuJDFbd2FybktleV0pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBkaWRXYXJuJDFbd2FybktleV0gPSB0cnVlO1xuICAgIHZhciB0YWdEaXNwbGF5TmFtZSA9IGNoaWxkVGFnO1xuICAgIHZhciB3aGl0ZXNwYWNlSW5mbyA9ICcnO1xuXG4gICAgaWYgKGNoaWxkVGFnID09PSAnI3RleHQnKSB7XG4gICAgICBpZiAoL1xcUy8udGVzdChjaGlsZFRleHQpKSB7XG4gICAgICAgIHRhZ0Rpc3BsYXlOYW1lID0gJ1RleHQgbm9kZXMnO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGFnRGlzcGxheU5hbWUgPSAnV2hpdGVzcGFjZSB0ZXh0IG5vZGVzJztcbiAgICAgICAgd2hpdGVzcGFjZUluZm8gPSBcIiBNYWtlIHN1cmUgeW91IGRvbid0IGhhdmUgYW55IGV4dHJhIHdoaXRlc3BhY2UgYmV0d2VlbiB0YWdzIG9uIFwiICsgJ2VhY2ggbGluZSBvZiB5b3VyIHNvdXJjZSBjb2RlLic7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRhZ0Rpc3BsYXlOYW1lID0gJzwnICsgY2hpbGRUYWcgKyAnPic7XG4gICAgfVxuXG4gICAgaWYgKGludmFsaWRQYXJlbnQpIHtcbiAgICAgIHZhciBpbmZvID0gJyc7XG5cbiAgICAgIGlmIChhbmNlc3RvclRhZyA9PT0gJ3RhYmxlJyAmJiBjaGlsZFRhZyA9PT0gJ3RyJykge1xuICAgICAgICBpbmZvICs9ICcgQWRkIGEgPHRib2R5PiwgPHRoZWFkPiBvciA8dGZvb3Q+IHRvIHlvdXIgY29kZSB0byBtYXRjaCB0aGUgRE9NIHRyZWUgZ2VuZXJhdGVkIGJ5ICcgKyAndGhlIGJyb3dzZXIuJztcbiAgICAgIH1cblxuICAgICAgZXJyb3IoJ3ZhbGlkYXRlRE9NTmVzdGluZyguLi4pOiAlcyBjYW5ub3QgYXBwZWFyIGFzIGEgY2hpbGQgb2YgPCVzPi4lcyVzJywgdGFnRGlzcGxheU5hbWUsIGFuY2VzdG9yVGFnLCB3aGl0ZXNwYWNlSW5mbywgaW5mbyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVycm9yKCd2YWxpZGF0ZURPTU5lc3RpbmcoLi4uKTogJXMgY2Fubm90IGFwcGVhciBhcyBhIGRlc2NlbmRhbnQgb2YgJyArICc8JXM+LicsIHRhZ0Rpc3BsYXlOYW1lLCBhbmNlc3RvclRhZyk7XG4gICAgfVxuICB9O1xufVxuXG52YXIgU1VQUFJFU1NfSFlEUkFUSU9OX1dBUk5JTkckMTtcblxue1xuICBTVVBQUkVTU19IWURSQVRJT05fV0FSTklORyQxID0gJ3N1cHByZXNzSHlkcmF0aW9uV2FybmluZyc7XG59XG5cbnZhciBTVVNQRU5TRV9TVEFSVF9EQVRBID0gJyQnO1xudmFyIFNVU1BFTlNFX0VORF9EQVRBID0gJy8kJztcbnZhciBTVVNQRU5TRV9QRU5ESU5HX1NUQVJUX0RBVEEgPSAnJD8nO1xudmFyIFNVU1BFTlNFX0ZBTExCQUNLX1NUQVJUX0RBVEEgPSAnJCEnO1xudmFyIFNUWUxFJDEgPSAnc3R5bGUnO1xudmFyIGV2ZW50c0VuYWJsZWQgPSBudWxsO1xudmFyIHNlbGVjdGlvbkluZm9ybWF0aW9uID0gbnVsbDtcblxuZnVuY3Rpb24gc2hvdWxkQXV0b0ZvY3VzSG9zdENvbXBvbmVudCh0eXBlLCBwcm9wcykge1xuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlICdidXR0b24nOlxuICAgIGNhc2UgJ2lucHV0JzpcbiAgICBjYXNlICdzZWxlY3QnOlxuICAgIGNhc2UgJ3RleHRhcmVhJzpcbiAgICAgIHJldHVybiAhIXByb3BzLmF1dG9Gb2N1cztcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGdldFJvb3RIb3N0Q29udGV4dChyb290Q29udGFpbmVySW5zdGFuY2UpIHtcbiAgdmFyIHR5cGU7XG4gIHZhciBuYW1lc3BhY2U7XG4gIHZhciBub2RlVHlwZSA9IHJvb3RDb250YWluZXJJbnN0YW5jZS5ub2RlVHlwZTtcblxuICBzd2l0Y2ggKG5vZGVUeXBlKSB7XG4gICAgY2FzZSBET0NVTUVOVF9OT0RFOlxuICAgIGNhc2UgRE9DVU1FTlRfRlJBR01FTlRfTk9ERTpcbiAgICAgIHtcbiAgICAgICAgdHlwZSA9IG5vZGVUeXBlID09PSBET0NVTUVOVF9OT0RFID8gJyNkb2N1bWVudCcgOiAnI2ZyYWdtZW50JztcbiAgICAgICAgdmFyIHJvb3QgPSByb290Q29udGFpbmVySW5zdGFuY2UuZG9jdW1lbnRFbGVtZW50O1xuICAgICAgICBuYW1lc3BhY2UgPSByb290ID8gcm9vdC5uYW1lc3BhY2VVUkkgOiBnZXRDaGlsZE5hbWVzcGFjZShudWxsLCAnJyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgZGVmYXVsdDpcbiAgICAgIHtcbiAgICAgICAgdmFyIGNvbnRhaW5lciA9IG5vZGVUeXBlID09PSBDT01NRU5UX05PREUgPyByb290Q29udGFpbmVySW5zdGFuY2UucGFyZW50Tm9kZSA6IHJvb3RDb250YWluZXJJbnN0YW5jZTtcbiAgICAgICAgdmFyIG93bk5hbWVzcGFjZSA9IGNvbnRhaW5lci5uYW1lc3BhY2VVUkkgfHwgbnVsbDtcbiAgICAgICAgdHlwZSA9IGNvbnRhaW5lci50YWdOYW1lO1xuICAgICAgICBuYW1lc3BhY2UgPSBnZXRDaGlsZE5hbWVzcGFjZShvd25OYW1lc3BhY2UsIHR5cGUpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgfVxuXG4gIHtcbiAgICB2YXIgdmFsaWRhdGVkVGFnID0gdHlwZS50b0xvd2VyQ2FzZSgpO1xuICAgIHZhciBhbmNlc3RvckluZm8gPSB1cGRhdGVkQW5jZXN0b3JJbmZvKG51bGwsIHZhbGlkYXRlZFRhZyk7XG4gICAgcmV0dXJuIHtcbiAgICAgIG5hbWVzcGFjZTogbmFtZXNwYWNlLFxuICAgICAgYW5jZXN0b3JJbmZvOiBhbmNlc3RvckluZm9cbiAgICB9O1xuICB9XG59XG5mdW5jdGlvbiBnZXRDaGlsZEhvc3RDb250ZXh0KHBhcmVudEhvc3RDb250ZXh0LCB0eXBlLCByb290Q29udGFpbmVySW5zdGFuY2UpIHtcbiAge1xuICAgIHZhciBwYXJlbnRIb3N0Q29udGV4dERldiA9IHBhcmVudEhvc3RDb250ZXh0O1xuICAgIHZhciBuYW1lc3BhY2UgPSBnZXRDaGlsZE5hbWVzcGFjZShwYXJlbnRIb3N0Q29udGV4dERldi5uYW1lc3BhY2UsIHR5cGUpO1xuICAgIHZhciBhbmNlc3RvckluZm8gPSB1cGRhdGVkQW5jZXN0b3JJbmZvKHBhcmVudEhvc3RDb250ZXh0RGV2LmFuY2VzdG9ySW5mbywgdHlwZSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIG5hbWVzcGFjZTogbmFtZXNwYWNlLFxuICAgICAgYW5jZXN0b3JJbmZvOiBhbmNlc3RvckluZm9cbiAgICB9O1xuICB9XG59XG5mdW5jdGlvbiBnZXRQdWJsaWNJbnN0YW5jZShpbnN0YW5jZSkge1xuICByZXR1cm4gaW5zdGFuY2U7XG59XG5mdW5jdGlvbiBwcmVwYXJlRm9yQ29tbWl0KGNvbnRhaW5lckluZm8pIHtcbiAgZXZlbnRzRW5hYmxlZCA9IGlzRW5hYmxlZCgpO1xuICBzZWxlY3Rpb25JbmZvcm1hdGlvbiA9IGdldFNlbGVjdGlvbkluZm9ybWF0aW9uKCk7XG4gIHZhciBhY3RpdmVJbnN0YW5jZSA9IG51bGw7XG5cbiAgc2V0RW5hYmxlZChmYWxzZSk7XG4gIHJldHVybiBhY3RpdmVJbnN0YW5jZTtcbn1cbmZ1bmN0aW9uIHJlc2V0QWZ0ZXJDb21taXQoY29udGFpbmVySW5mbykge1xuICByZXN0b3JlU2VsZWN0aW9uKHNlbGVjdGlvbkluZm9ybWF0aW9uKTtcbiAgc2V0RW5hYmxlZChldmVudHNFbmFibGVkKTtcbiAgZXZlbnRzRW5hYmxlZCA9IG51bGw7XG4gIHNlbGVjdGlvbkluZm9ybWF0aW9uID0gbnVsbDtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUluc3RhbmNlKHR5cGUsIHByb3BzLCByb290Q29udGFpbmVySW5zdGFuY2UsIGhvc3RDb250ZXh0LCBpbnRlcm5hbEluc3RhbmNlSGFuZGxlKSB7XG4gIHZhciBwYXJlbnROYW1lc3BhY2U7XG5cbiAge1xuICAgIC8vIFRPRE86IHRha2UgbmFtZXNwYWNlIGludG8gYWNjb3VudCB3aGVuIHZhbGlkYXRpbmcuXG4gICAgdmFyIGhvc3RDb250ZXh0RGV2ID0gaG9zdENvbnRleHQ7XG4gICAgdmFsaWRhdGVET01OZXN0aW5nKHR5cGUsIG51bGwsIGhvc3RDb250ZXh0RGV2LmFuY2VzdG9ySW5mbyk7XG5cbiAgICBpZiAodHlwZW9mIHByb3BzLmNoaWxkcmVuID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgcHJvcHMuY2hpbGRyZW4gPT09ICdudW1iZXInKSB7XG4gICAgICB2YXIgc3RyaW5nID0gJycgKyBwcm9wcy5jaGlsZHJlbjtcbiAgICAgIHZhciBvd25BbmNlc3RvckluZm8gPSB1cGRhdGVkQW5jZXN0b3JJbmZvKGhvc3RDb250ZXh0RGV2LmFuY2VzdG9ySW5mbywgdHlwZSk7XG4gICAgICB2YWxpZGF0ZURPTU5lc3RpbmcobnVsbCwgc3RyaW5nLCBvd25BbmNlc3RvckluZm8pO1xuICAgIH1cblxuICAgIHBhcmVudE5hbWVzcGFjZSA9IGhvc3RDb250ZXh0RGV2Lm5hbWVzcGFjZTtcbiAgfVxuXG4gIHZhciBkb21FbGVtZW50ID0gY3JlYXRlRWxlbWVudCh0eXBlLCBwcm9wcywgcm9vdENvbnRhaW5lckluc3RhbmNlLCBwYXJlbnROYW1lc3BhY2UpO1xuICBwcmVjYWNoZUZpYmVyTm9kZShpbnRlcm5hbEluc3RhbmNlSGFuZGxlLCBkb21FbGVtZW50KTtcbiAgdXBkYXRlRmliZXJQcm9wcyhkb21FbGVtZW50LCBwcm9wcyk7XG4gIHJldHVybiBkb21FbGVtZW50O1xufVxuZnVuY3Rpb24gYXBwZW5kSW5pdGlhbENoaWxkKHBhcmVudEluc3RhbmNlLCBjaGlsZCkge1xuICBwYXJlbnRJbnN0YW5jZS5hcHBlbmRDaGlsZChjaGlsZCk7XG59XG5mdW5jdGlvbiBmaW5hbGl6ZUluaXRpYWxDaGlsZHJlbihkb21FbGVtZW50LCB0eXBlLCBwcm9wcywgcm9vdENvbnRhaW5lckluc3RhbmNlLCBob3N0Q29udGV4dCkge1xuICBzZXRJbml0aWFsUHJvcGVydGllcyhkb21FbGVtZW50LCB0eXBlLCBwcm9wcywgcm9vdENvbnRhaW5lckluc3RhbmNlKTtcbiAgcmV0dXJuIHNob3VsZEF1dG9Gb2N1c0hvc3RDb21wb25lbnQodHlwZSwgcHJvcHMpO1xufVxuZnVuY3Rpb24gcHJlcGFyZVVwZGF0ZShkb21FbGVtZW50LCB0eXBlLCBvbGRQcm9wcywgbmV3UHJvcHMsIHJvb3RDb250YWluZXJJbnN0YW5jZSwgaG9zdENvbnRleHQpIHtcbiAge1xuICAgIHZhciBob3N0Q29udGV4dERldiA9IGhvc3RDb250ZXh0O1xuXG4gICAgaWYgKHR5cGVvZiBuZXdQcm9wcy5jaGlsZHJlbiAhPT0gdHlwZW9mIG9sZFByb3BzLmNoaWxkcmVuICYmICh0eXBlb2YgbmV3UHJvcHMuY2hpbGRyZW4gPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBuZXdQcm9wcy5jaGlsZHJlbiA9PT0gJ251bWJlcicpKSB7XG4gICAgICB2YXIgc3RyaW5nID0gJycgKyBuZXdQcm9wcy5jaGlsZHJlbjtcbiAgICAgIHZhciBvd25BbmNlc3RvckluZm8gPSB1cGRhdGVkQW5jZXN0b3JJbmZvKGhvc3RDb250ZXh0RGV2LmFuY2VzdG9ySW5mbywgdHlwZSk7XG4gICAgICB2YWxpZGF0ZURPTU5lc3RpbmcobnVsbCwgc3RyaW5nLCBvd25BbmNlc3RvckluZm8pO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBkaWZmUHJvcGVydGllcyhkb21FbGVtZW50LCB0eXBlLCBvbGRQcm9wcywgbmV3UHJvcHMpO1xufVxuZnVuY3Rpb24gc2hvdWxkU2V0VGV4dENvbnRlbnQodHlwZSwgcHJvcHMpIHtcbiAgcmV0dXJuIHR5cGUgPT09ICd0ZXh0YXJlYScgfHwgdHlwZSA9PT0gJ29wdGlvbicgfHwgdHlwZSA9PT0gJ25vc2NyaXB0JyB8fCB0eXBlb2YgcHJvcHMuY2hpbGRyZW4gPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBwcm9wcy5jaGlsZHJlbiA9PT0gJ251bWJlcicgfHwgdHlwZW9mIHByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MID09PSAnb2JqZWN0JyAmJiBwcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTCAhPT0gbnVsbCAmJiBwcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTC5fX2h0bWwgIT0gbnVsbDtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVRleHRJbnN0YW5jZSh0ZXh0LCByb290Q29udGFpbmVySW5zdGFuY2UsIGhvc3RDb250ZXh0LCBpbnRlcm5hbEluc3RhbmNlSGFuZGxlKSB7XG4gIHtcbiAgICB2YXIgaG9zdENvbnRleHREZXYgPSBob3N0Q29udGV4dDtcbiAgICB2YWxpZGF0ZURPTU5lc3RpbmcobnVsbCwgdGV4dCwgaG9zdENvbnRleHREZXYuYW5jZXN0b3JJbmZvKTtcbiAgfVxuXG4gIHZhciB0ZXh0Tm9kZSA9IGNyZWF0ZVRleHROb2RlKHRleHQsIHJvb3RDb250YWluZXJJbnN0YW5jZSk7XG4gIHByZWNhY2hlRmliZXJOb2RlKGludGVybmFsSW5zdGFuY2VIYW5kbGUsIHRleHROb2RlKTtcbiAgcmV0dXJuIHRleHROb2RlO1xufVxuLy8gaWYgYSBjb21wb25lbnQganVzdCBpbXBvcnRzIFJlYWN0RE9NIChlLmcuIGZvciBmaW5kRE9NTm9kZSkuXG4vLyBTb21lIGVudmlyb25tZW50cyBtaWdodCBub3QgaGF2ZSBzZXRUaW1lb3V0IG9yIGNsZWFyVGltZW91dC5cblxudmFyIHNjaGVkdWxlVGltZW91dCA9IHR5cGVvZiBzZXRUaW1lb3V0ID09PSAnZnVuY3Rpb24nID8gc2V0VGltZW91dCA6IHVuZGVmaW5lZDtcbnZhciBjYW5jZWxUaW1lb3V0ID0gdHlwZW9mIGNsZWFyVGltZW91dCA9PT0gJ2Z1bmN0aW9uJyA/IGNsZWFyVGltZW91dCA6IHVuZGVmaW5lZDtcbnZhciBub1RpbWVvdXQgPSAtMTsgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLVxuZnVuY3Rpb24gY29tbWl0TW91bnQoZG9tRWxlbWVudCwgdHlwZSwgbmV3UHJvcHMsIGludGVybmFsSW5zdGFuY2VIYW5kbGUpIHtcbiAgLy8gRGVzcGl0ZSB0aGUgbmFtaW5nIHRoYXQgbWlnaHQgaW1wbHkgb3RoZXJ3aXNlLCB0aGlzIG1ldGhvZCBvbmx5XG4gIC8vIGZpcmVzIGlmIHRoZXJlIGlzIGFuIGBVcGRhdGVgIGVmZmVjdCBzY2hlZHVsZWQgZHVyaW5nIG1vdW50aW5nLlxuICAvLyBUaGlzIGhhcHBlbnMgaWYgYGZpbmFsaXplSW5pdGlhbENoaWxkcmVuYCByZXR1cm5zIGB0cnVlYCAod2hpY2ggaXRcbiAgLy8gZG9lcyB0byBpbXBsZW1lbnQgdGhlIGBhdXRvRm9jdXNgIGF0dHJpYnV0ZSBvbiB0aGUgY2xpZW50KS4gQnV0XG4gIC8vIHRoZXJlIGFyZSBhbHNvIG90aGVyIGNhc2VzIHdoZW4gdGhpcyBtaWdodCBoYXBwZW4gKHN1Y2ggYXMgcGF0Y2hpbmdcbiAgLy8gdXAgdGV4dCBjb250ZW50IGR1cmluZyBoeWRyYXRpb24gbWlzbWF0Y2gpLiBTbyB3ZSdsbCBjaGVjayB0aGlzIGFnYWluLlxuICBpZiAoc2hvdWxkQXV0b0ZvY3VzSG9zdENvbXBvbmVudCh0eXBlLCBuZXdQcm9wcykpIHtcbiAgICBkb21FbGVtZW50LmZvY3VzKCk7XG4gIH1cbn1cbmZ1bmN0aW9uIGNvbW1pdFVwZGF0ZShkb21FbGVtZW50LCB1cGRhdGVQYXlsb2FkLCB0eXBlLCBvbGRQcm9wcywgbmV3UHJvcHMsIGludGVybmFsSW5zdGFuY2VIYW5kbGUpIHtcbiAgLy8gVXBkYXRlIHRoZSBwcm9wcyBoYW5kbGUgc28gdGhhdCB3ZSBrbm93IHdoaWNoIHByb3BzIGFyZSB0aGUgb25lcyB3aXRoXG4gIC8vIHdpdGggY3VycmVudCBldmVudCBoYW5kbGVycy5cbiAgdXBkYXRlRmliZXJQcm9wcyhkb21FbGVtZW50LCBuZXdQcm9wcyk7IC8vIEFwcGx5IHRoZSBkaWZmIHRvIHRoZSBET00gbm9kZS5cblxuICB1cGRhdGVQcm9wZXJ0aWVzKGRvbUVsZW1lbnQsIHVwZGF0ZVBheWxvYWQsIHR5cGUsIG9sZFByb3BzLCBuZXdQcm9wcyk7XG59XG5mdW5jdGlvbiByZXNldFRleHRDb250ZW50KGRvbUVsZW1lbnQpIHtcbiAgc2V0VGV4dENvbnRlbnQoZG9tRWxlbWVudCwgJycpO1xufVxuZnVuY3Rpb24gY29tbWl0VGV4dFVwZGF0ZSh0ZXh0SW5zdGFuY2UsIG9sZFRleHQsIG5ld1RleHQpIHtcbiAgdGV4dEluc3RhbmNlLm5vZGVWYWx1ZSA9IG5ld1RleHQ7XG59XG5mdW5jdGlvbiBhcHBlbmRDaGlsZChwYXJlbnRJbnN0YW5jZSwgY2hpbGQpIHtcbiAgcGFyZW50SW5zdGFuY2UuYXBwZW5kQ2hpbGQoY2hpbGQpO1xufVxuZnVuY3Rpb24gYXBwZW5kQ2hpbGRUb0NvbnRhaW5lcihjb250YWluZXIsIGNoaWxkKSB7XG4gIHZhciBwYXJlbnROb2RlO1xuXG4gIGlmIChjb250YWluZXIubm9kZVR5cGUgPT09IENPTU1FTlRfTk9ERSkge1xuICAgIHBhcmVudE5vZGUgPSBjb250YWluZXIucGFyZW50Tm9kZTtcbiAgICBwYXJlbnROb2RlLmluc2VydEJlZm9yZShjaGlsZCwgY29udGFpbmVyKTtcbiAgfSBlbHNlIHtcbiAgICBwYXJlbnROb2RlID0gY29udGFpbmVyO1xuICAgIHBhcmVudE5vZGUuYXBwZW5kQ2hpbGQoY2hpbGQpO1xuICB9IC8vIFRoaXMgY29udGFpbmVyIG1pZ2h0IGJlIHVzZWQgZm9yIGEgcG9ydGFsLlxuICAvLyBJZiBzb21ldGhpbmcgaW5zaWRlIGEgcG9ydGFsIGlzIGNsaWNrZWQsIHRoYXQgY2xpY2sgc2hvdWxkIGJ1YmJsZVxuICAvLyB0aHJvdWdoIHRoZSBSZWFjdCB0cmVlLiBIb3dldmVyLCBvbiBNb2JpbGUgU2FmYXJpIHRoZSBjbGljayB3b3VsZFxuICAvLyBuZXZlciBidWJibGUgdGhyb3VnaCB0aGUgKkRPTSogdHJlZSB1bmxlc3MgYW4gYW5jZXN0b3Igd2l0aCBvbmNsaWNrXG4gIC8vIGV2ZW50IGV4aXN0cy4gU28gd2Ugd291bGRuJ3Qgc2VlIGl0IGFuZCBkaXNwYXRjaCBpdC5cbiAgLy8gVGhpcyBpcyB3aHkgd2UgZW5zdXJlIHRoYXQgbm9uIFJlYWN0IHJvb3QgY29udGFpbmVycyBoYXZlIGlubGluZSBvbmNsaWNrXG4gIC8vIGRlZmluZWQuXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTE5MThcblxuXG4gIHZhciByZWFjdFJvb3RDb250YWluZXIgPSBjb250YWluZXIuX3JlYWN0Um9vdENvbnRhaW5lcjtcblxuICBpZiAoKHJlYWN0Um9vdENvbnRhaW5lciA9PT0gbnVsbCB8fCByZWFjdFJvb3RDb250YWluZXIgPT09IHVuZGVmaW5lZCkgJiYgcGFyZW50Tm9kZS5vbmNsaWNrID09PSBudWxsKSB7XG4gICAgLy8gVE9ETzogVGhpcyBjYXN0IG1heSBub3QgYmUgc291bmQgZm9yIFNWRywgTWF0aE1MIG9yIGN1c3RvbSBlbGVtZW50cy5cbiAgICB0cmFwQ2xpY2tPbk5vbkludGVyYWN0aXZlRWxlbWVudChwYXJlbnROb2RlKTtcbiAgfVxufVxuZnVuY3Rpb24gaW5zZXJ0QmVmb3JlKHBhcmVudEluc3RhbmNlLCBjaGlsZCwgYmVmb3JlQ2hpbGQpIHtcbiAgcGFyZW50SW5zdGFuY2UuaW5zZXJ0QmVmb3JlKGNoaWxkLCBiZWZvcmVDaGlsZCk7XG59XG5mdW5jdGlvbiBpbnNlcnRJbkNvbnRhaW5lckJlZm9yZShjb250YWluZXIsIGNoaWxkLCBiZWZvcmVDaGlsZCkge1xuICBpZiAoY29udGFpbmVyLm5vZGVUeXBlID09PSBDT01NRU5UX05PREUpIHtcbiAgICBjb250YWluZXIucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoY2hpbGQsIGJlZm9yZUNoaWxkKTtcbiAgfSBlbHNlIHtcbiAgICBjb250YWluZXIuaW5zZXJ0QmVmb3JlKGNoaWxkLCBiZWZvcmVDaGlsZCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVtb3ZlQ2hpbGQocGFyZW50SW5zdGFuY2UsIGNoaWxkKSB7XG4gIHBhcmVudEluc3RhbmNlLnJlbW92ZUNoaWxkKGNoaWxkKTtcbn1cbmZ1bmN0aW9uIHJlbW92ZUNoaWxkRnJvbUNvbnRhaW5lcihjb250YWluZXIsIGNoaWxkKSB7XG4gIGlmIChjb250YWluZXIubm9kZVR5cGUgPT09IENPTU1FTlRfTk9ERSkge1xuICAgIGNvbnRhaW5lci5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGNoaWxkKTtcbiAgfSBlbHNlIHtcbiAgICBjb250YWluZXIucmVtb3ZlQ2hpbGQoY2hpbGQpO1xuICB9XG59XG5mdW5jdGlvbiBoaWRlSW5zdGFuY2UoaW5zdGFuY2UpIHtcbiAgLy8gVE9ETzogRG9lcyB0aGlzIHdvcmsgZm9yIGFsbCBlbGVtZW50IHR5cGVzPyBXaGF0IGFib3V0IE1hdGhNTD8gU2hvdWxkIHdlXG4gIC8vIHBhc3MgaG9zdCBjb250ZXh0IHRvIHRoaXMgbWV0aG9kP1xuICBpbnN0YW5jZSA9IGluc3RhbmNlO1xuICB2YXIgc3R5bGUgPSBpbnN0YW5jZS5zdHlsZTtcblxuICBpZiAodHlwZW9mIHN0eWxlLnNldFByb3BlcnR5ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgc3R5bGUuc2V0UHJvcGVydHkoJ2Rpc3BsYXknLCAnbm9uZScsICdpbXBvcnRhbnQnKTtcbiAgfSBlbHNlIHtcbiAgICBzdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICB9XG59XG5mdW5jdGlvbiBoaWRlVGV4dEluc3RhbmNlKHRleHRJbnN0YW5jZSkge1xuICB0ZXh0SW5zdGFuY2Uubm9kZVZhbHVlID0gJyc7XG59XG5mdW5jdGlvbiB1bmhpZGVJbnN0YW5jZShpbnN0YW5jZSwgcHJvcHMpIHtcbiAgaW5zdGFuY2UgPSBpbnN0YW5jZTtcbiAgdmFyIHN0eWxlUHJvcCA9IHByb3BzW1NUWUxFJDFdO1xuICB2YXIgZGlzcGxheSA9IHN0eWxlUHJvcCAhPT0gdW5kZWZpbmVkICYmIHN0eWxlUHJvcCAhPT0gbnVsbCAmJiBzdHlsZVByb3AuaGFzT3duUHJvcGVydHkoJ2Rpc3BsYXknKSA/IHN0eWxlUHJvcC5kaXNwbGF5IDogbnVsbDtcbiAgaW5zdGFuY2Uuc3R5bGUuZGlzcGxheSA9IGRhbmdlcm91c1N0eWxlVmFsdWUoJ2Rpc3BsYXknLCBkaXNwbGF5KTtcbn1cbmZ1bmN0aW9uIHVuaGlkZVRleHRJbnN0YW5jZSh0ZXh0SW5zdGFuY2UsIHRleHQpIHtcbiAgdGV4dEluc3RhbmNlLm5vZGVWYWx1ZSA9IHRleHQ7XG59XG5mdW5jdGlvbiBjbGVhckNvbnRhaW5lcihjb250YWluZXIpIHtcbiAgaWYgKGNvbnRhaW5lci5ub2RlVHlwZSA9PT0gRUxFTUVOVF9OT0RFKSB7XG4gICAgY29udGFpbmVyLnRleHRDb250ZW50ID0gJyc7XG4gIH0gZWxzZSBpZiAoY29udGFpbmVyLm5vZGVUeXBlID09PSBET0NVTUVOVF9OT0RFKSB7XG4gICAgdmFyIGJvZHkgPSBjb250YWluZXIuYm9keTtcblxuICAgIGlmIChib2R5ICE9IG51bGwpIHtcbiAgICAgIGJvZHkudGV4dENvbnRlbnQgPSAnJztcbiAgICB9XG4gIH1cbn0gLy8gLS0tLS0tLS0tLS0tLS0tLS0tLVxuZnVuY3Rpb24gY2FuSHlkcmF0ZUluc3RhbmNlKGluc3RhbmNlLCB0eXBlLCBwcm9wcykge1xuICBpZiAoaW5zdGFuY2Uubm9kZVR5cGUgIT09IEVMRU1FTlRfTk9ERSB8fCB0eXBlLnRvTG93ZXJDYXNlKCkgIT09IGluc3RhbmNlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfSAvLyBUaGlzIGhhcyBub3cgYmVlbiByZWZpbmVkIHRvIGFuIGVsZW1lbnQgbm9kZS5cblxuXG4gIHJldHVybiBpbnN0YW5jZTtcbn1cbmZ1bmN0aW9uIGNhbkh5ZHJhdGVUZXh0SW5zdGFuY2UoaW5zdGFuY2UsIHRleHQpIHtcbiAgaWYgKHRleHQgPT09ICcnIHx8IGluc3RhbmNlLm5vZGVUeXBlICE9PSBURVhUX05PREUpIHtcbiAgICAvLyBFbXB0eSBzdHJpbmdzIGFyZSBub3QgcGFyc2VkIGJ5IEhUTUwgc28gdGhlcmUgd29uJ3QgYmUgYSBjb3JyZWN0IG1hdGNoIGhlcmUuXG4gICAgcmV0dXJuIG51bGw7XG4gIH0gLy8gVGhpcyBoYXMgbm93IGJlZW4gcmVmaW5lZCB0byBhIHRleHQgbm9kZS5cblxuXG4gIHJldHVybiBpbnN0YW5jZTtcbn1cbmZ1bmN0aW9uIGlzU3VzcGVuc2VJbnN0YW5jZVBlbmRpbmcoaW5zdGFuY2UpIHtcbiAgcmV0dXJuIGluc3RhbmNlLmRhdGEgPT09IFNVU1BFTlNFX1BFTkRJTkdfU1RBUlRfREFUQTtcbn1cbmZ1bmN0aW9uIGlzU3VzcGVuc2VJbnN0YW5jZUZhbGxiYWNrKGluc3RhbmNlKSB7XG4gIHJldHVybiBpbnN0YW5jZS5kYXRhID09PSBTVVNQRU5TRV9GQUxMQkFDS19TVEFSVF9EQVRBO1xufVxuXG5mdW5jdGlvbiBnZXROZXh0SHlkcmF0YWJsZShub2RlKSB7XG4gIC8vIFNraXAgbm9uLWh5ZHJhdGFibGUgbm9kZXMuXG4gIGZvciAoOyBub2RlICE9IG51bGw7IG5vZGUgPSBub2RlLm5leHRTaWJsaW5nKSB7XG4gICAgdmFyIG5vZGVUeXBlID0gbm9kZS5ub2RlVHlwZTtcblxuICAgIGlmIChub2RlVHlwZSA9PT0gRUxFTUVOVF9OT0RFIHx8IG5vZGVUeXBlID09PSBURVhUX05PREUpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBub2RlO1xufVxuXG5mdW5jdGlvbiBnZXROZXh0SHlkcmF0YWJsZVNpYmxpbmcoaW5zdGFuY2UpIHtcbiAgcmV0dXJuIGdldE5leHRIeWRyYXRhYmxlKGluc3RhbmNlLm5leHRTaWJsaW5nKTtcbn1cbmZ1bmN0aW9uIGdldEZpcnN0SHlkcmF0YWJsZUNoaWxkKHBhcmVudEluc3RhbmNlKSB7XG4gIHJldHVybiBnZXROZXh0SHlkcmF0YWJsZShwYXJlbnRJbnN0YW5jZS5maXJzdENoaWxkKTtcbn1cbmZ1bmN0aW9uIGh5ZHJhdGVJbnN0YW5jZShpbnN0YW5jZSwgdHlwZSwgcHJvcHMsIHJvb3RDb250YWluZXJJbnN0YW5jZSwgaG9zdENvbnRleHQsIGludGVybmFsSW5zdGFuY2VIYW5kbGUpIHtcbiAgcHJlY2FjaGVGaWJlck5vZGUoaW50ZXJuYWxJbnN0YW5jZUhhbmRsZSwgaW5zdGFuY2UpOyAvLyBUT0RPOiBQb3NzaWJseSBkZWZlciB0aGlzIHVudGlsIHRoZSBjb21taXQgcGhhc2Ugd2hlcmUgYWxsIHRoZSBldmVudHNcbiAgLy8gZ2V0IGF0dGFjaGVkLlxuXG4gIHVwZGF0ZUZpYmVyUHJvcHMoaW5zdGFuY2UsIHByb3BzKTtcbiAgdmFyIHBhcmVudE5hbWVzcGFjZTtcblxuICB7XG4gICAgdmFyIGhvc3RDb250ZXh0RGV2ID0gaG9zdENvbnRleHQ7XG4gICAgcGFyZW50TmFtZXNwYWNlID0gaG9zdENvbnRleHREZXYubmFtZXNwYWNlO1xuICB9XG5cbiAgcmV0dXJuIGRpZmZIeWRyYXRlZFByb3BlcnRpZXMoaW5zdGFuY2UsIHR5cGUsIHByb3BzLCBwYXJlbnROYW1lc3BhY2UpO1xufVxuZnVuY3Rpb24gaHlkcmF0ZVRleHRJbnN0YW5jZSh0ZXh0SW5zdGFuY2UsIHRleHQsIGludGVybmFsSW5zdGFuY2VIYW5kbGUpIHtcbiAgcHJlY2FjaGVGaWJlck5vZGUoaW50ZXJuYWxJbnN0YW5jZUhhbmRsZSwgdGV4dEluc3RhbmNlKTtcbiAgcmV0dXJuIGRpZmZIeWRyYXRlZFRleHQodGV4dEluc3RhbmNlLCB0ZXh0KTtcbn1cbmZ1bmN0aW9uIGdldE5leHRIeWRyYXRhYmxlSW5zdGFuY2VBZnRlclN1c3BlbnNlSW5zdGFuY2Uoc3VzcGVuc2VJbnN0YW5jZSkge1xuICB2YXIgbm9kZSA9IHN1c3BlbnNlSW5zdGFuY2UubmV4dFNpYmxpbmc7IC8vIFNraXAgcGFzdCBhbGwgbm9kZXMgd2l0aGluIHRoaXMgc3VzcGVuc2UgYm91bmRhcnkuXG4gIC8vIFRoZXJlIG1pZ2h0IGJlIG5lc3RlZCBub2RlcyBzbyB3ZSBuZWVkIHRvIGtlZXAgdHJhY2sgb2YgaG93XG4gIC8vIGRlZXAgd2UgYXJlIGFuZCBvbmx5IGJyZWFrIG91dCB3aGVuIHdlJ3JlIGJhY2sgb24gdG9wLlxuXG4gIHZhciBkZXB0aCA9IDA7XG5cbiAgd2hpbGUgKG5vZGUpIHtcbiAgICBpZiAobm9kZS5ub2RlVHlwZSA9PT0gQ09NTUVOVF9OT0RFKSB7XG4gICAgICB2YXIgZGF0YSA9IG5vZGUuZGF0YTtcblxuICAgICAgaWYgKGRhdGEgPT09IFNVU1BFTlNFX0VORF9EQVRBKSB7XG4gICAgICAgIGlmIChkZXB0aCA9PT0gMCkge1xuICAgICAgICAgIHJldHVybiBnZXROZXh0SHlkcmF0YWJsZVNpYmxpbmcobm9kZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZGVwdGgtLTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChkYXRhID09PSBTVVNQRU5TRV9TVEFSVF9EQVRBIHx8IGRhdGEgPT09IFNVU1BFTlNFX0ZBTExCQUNLX1NUQVJUX0RBVEEgfHwgZGF0YSA9PT0gU1VTUEVOU0VfUEVORElOR19TVEFSVF9EQVRBKSB7XG4gICAgICAgIGRlcHRoKys7XG4gICAgICB9XG4gICAgfVxuXG4gICAgbm9kZSA9IG5vZGUubmV4dFNpYmxpbmc7XG4gIH0gLy8gVE9ETzogV2Fybiwgd2UgZGlkbid0IGZpbmQgdGhlIGVuZCBjb21tZW50IGJvdW5kYXJ5LlxuXG5cbiAgcmV0dXJuIG51bGw7XG59IC8vIFJldHVybnMgdGhlIFN1c3BlbnNlSW5zdGFuY2UgaWYgdGhpcyBub2RlIGlzIGEgZGlyZWN0IGNoaWxkIG9mIGFcbi8vIFN1c3BlbnNlSW5zdGFuY2UuIEkuZS4gaWYgaXRzIHByZXZpb3VzIHNpYmxpbmcgaXMgYSBDb21tZW50IHdpdGhcbi8vIFNVU1BFTlNFX3hfU1RBUlRfREFUQS4gT3RoZXJ3aXNlLCBudWxsLlxuXG5mdW5jdGlvbiBnZXRQYXJlbnRTdXNwZW5zZUluc3RhbmNlKHRhcmdldEluc3RhbmNlKSB7XG4gIHZhciBub2RlID0gdGFyZ2V0SW5zdGFuY2UucHJldmlvdXNTaWJsaW5nOyAvLyBTa2lwIHBhc3QgYWxsIG5vZGVzIHdpdGhpbiB0aGlzIHN1c3BlbnNlIGJvdW5kYXJ5LlxuICAvLyBUaGVyZSBtaWdodCBiZSBuZXN0ZWQgbm9kZXMgc28gd2UgbmVlZCB0byBrZWVwIHRyYWNrIG9mIGhvd1xuICAvLyBkZWVwIHdlIGFyZSBhbmQgb25seSBicmVhayBvdXQgd2hlbiB3ZSdyZSBiYWNrIG9uIHRvcC5cblxuICB2YXIgZGVwdGggPSAwO1xuXG4gIHdoaWxlIChub2RlKSB7XG4gICAgaWYgKG5vZGUubm9kZVR5cGUgPT09IENPTU1FTlRfTk9ERSkge1xuICAgICAgdmFyIGRhdGEgPSBub2RlLmRhdGE7XG5cbiAgICAgIGlmIChkYXRhID09PSBTVVNQRU5TRV9TVEFSVF9EQVRBIHx8IGRhdGEgPT09IFNVU1BFTlNFX0ZBTExCQUNLX1NUQVJUX0RBVEEgfHwgZGF0YSA9PT0gU1VTUEVOU0VfUEVORElOR19TVEFSVF9EQVRBKSB7XG4gICAgICAgIGlmIChkZXB0aCA9PT0gMCkge1xuICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRlcHRoLS07XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoZGF0YSA9PT0gU1VTUEVOU0VfRU5EX0RBVEEpIHtcbiAgICAgICAgZGVwdGgrKztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBub2RlID0gbm9kZS5wcmV2aW91c1NpYmxpbmc7XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGNvbW1pdEh5ZHJhdGVkQ29udGFpbmVyKGNvbnRhaW5lcikge1xuICAvLyBSZXRyeSBpZiBhbnkgZXZlbnQgcmVwbGF5aW5nIHdhcyBibG9ja2VkIG9uIHRoaXMuXG4gIHJldHJ5SWZCbG9ja2VkT24oY29udGFpbmVyKTtcbn1cbmZ1bmN0aW9uIGNvbW1pdEh5ZHJhdGVkU3VzcGVuc2VJbnN0YW5jZShzdXNwZW5zZUluc3RhbmNlKSB7XG4gIC8vIFJldHJ5IGlmIGFueSBldmVudCByZXBsYXlpbmcgd2FzIGJsb2NrZWQgb24gdGhpcy5cbiAgcmV0cnlJZkJsb2NrZWRPbihzdXNwZW5zZUluc3RhbmNlKTtcbn1cbmZ1bmN0aW9uIGRpZE5vdE1hdGNoSHlkcmF0ZWRDb250YWluZXJUZXh0SW5zdGFuY2UocGFyZW50Q29udGFpbmVyLCB0ZXh0SW5zdGFuY2UsIHRleHQpIHtcbiAge1xuICAgIHdhcm5Gb3JVbm1hdGNoZWRUZXh0KHRleHRJbnN0YW5jZSwgdGV4dCk7XG4gIH1cbn1cbmZ1bmN0aW9uIGRpZE5vdE1hdGNoSHlkcmF0ZWRUZXh0SW5zdGFuY2UocGFyZW50VHlwZSwgcGFyZW50UHJvcHMsIHBhcmVudEluc3RhbmNlLCB0ZXh0SW5zdGFuY2UsIHRleHQpIHtcbiAgaWYgKCBwYXJlbnRQcm9wc1tTVVBQUkVTU19IWURSQVRJT05fV0FSTklORyQxXSAhPT0gdHJ1ZSkge1xuICAgIHdhcm5Gb3JVbm1hdGNoZWRUZXh0KHRleHRJbnN0YW5jZSwgdGV4dCk7XG4gIH1cbn1cbmZ1bmN0aW9uIGRpZE5vdEh5ZHJhdGVDb250YWluZXJJbnN0YW5jZShwYXJlbnRDb250YWluZXIsIGluc3RhbmNlKSB7XG4gIHtcbiAgICBpZiAoaW5zdGFuY2Uubm9kZVR5cGUgPT09IEVMRU1FTlRfTk9ERSkge1xuICAgICAgd2FybkZvckRlbGV0ZWRIeWRyYXRhYmxlRWxlbWVudChwYXJlbnRDb250YWluZXIsIGluc3RhbmNlKTtcbiAgICB9IGVsc2UgaWYgKGluc3RhbmNlLm5vZGVUeXBlID09PSBDT01NRU5UX05PREUpIDsgZWxzZSB7XG4gICAgICB3YXJuRm9yRGVsZXRlZEh5ZHJhdGFibGVUZXh0KHBhcmVudENvbnRhaW5lciwgaW5zdGFuY2UpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gZGlkTm90SHlkcmF0ZUluc3RhbmNlKHBhcmVudFR5cGUsIHBhcmVudFByb3BzLCBwYXJlbnRJbnN0YW5jZSwgaW5zdGFuY2UpIHtcbiAgaWYgKCBwYXJlbnRQcm9wc1tTVVBQUkVTU19IWURSQVRJT05fV0FSTklORyQxXSAhPT0gdHJ1ZSkge1xuICAgIGlmIChpbnN0YW5jZS5ub2RlVHlwZSA9PT0gRUxFTUVOVF9OT0RFKSB7XG4gICAgICB3YXJuRm9yRGVsZXRlZEh5ZHJhdGFibGVFbGVtZW50KHBhcmVudEluc3RhbmNlLCBpbnN0YW5jZSk7XG4gICAgfSBlbHNlIGlmIChpbnN0YW5jZS5ub2RlVHlwZSA9PT0gQ09NTUVOVF9OT0RFKSA7IGVsc2Uge1xuICAgICAgd2FybkZvckRlbGV0ZWRIeWRyYXRhYmxlVGV4dChwYXJlbnRJbnN0YW5jZSwgaW5zdGFuY2UpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gZGlkTm90RmluZEh5ZHJhdGFibGVDb250YWluZXJJbnN0YW5jZShwYXJlbnRDb250YWluZXIsIHR5cGUsIHByb3BzKSB7XG4gIHtcbiAgICB3YXJuRm9ySW5zZXJ0ZWRIeWRyYXRlZEVsZW1lbnQocGFyZW50Q29udGFpbmVyLCB0eXBlKTtcbiAgfVxufVxuZnVuY3Rpb24gZGlkTm90RmluZEh5ZHJhdGFibGVDb250YWluZXJUZXh0SW5zdGFuY2UocGFyZW50Q29udGFpbmVyLCB0ZXh0KSB7XG4gIHtcbiAgICB3YXJuRm9ySW5zZXJ0ZWRIeWRyYXRlZFRleHQocGFyZW50Q29udGFpbmVyLCB0ZXh0KTtcbiAgfVxufVxuZnVuY3Rpb24gZGlkTm90RmluZEh5ZHJhdGFibGVJbnN0YW5jZShwYXJlbnRUeXBlLCBwYXJlbnRQcm9wcywgcGFyZW50SW5zdGFuY2UsIHR5cGUsIHByb3BzKSB7XG4gIGlmICggcGFyZW50UHJvcHNbU1VQUFJFU1NfSFlEUkFUSU9OX1dBUk5JTkckMV0gIT09IHRydWUpIHtcbiAgICB3YXJuRm9ySW5zZXJ0ZWRIeWRyYXRlZEVsZW1lbnQocGFyZW50SW5zdGFuY2UsIHR5cGUpO1xuICB9XG59XG5mdW5jdGlvbiBkaWROb3RGaW5kSHlkcmF0YWJsZVRleHRJbnN0YW5jZShwYXJlbnRUeXBlLCBwYXJlbnRQcm9wcywgcGFyZW50SW5zdGFuY2UsIHRleHQpIHtcbiAgaWYgKCBwYXJlbnRQcm9wc1tTVVBQUkVTU19IWURSQVRJT05fV0FSTklORyQxXSAhPT0gdHJ1ZSkge1xuICAgIHdhcm5Gb3JJbnNlcnRlZEh5ZHJhdGVkVGV4dChwYXJlbnRJbnN0YW5jZSwgdGV4dCk7XG4gIH1cbn1cbmZ1bmN0aW9uIGRpZE5vdEZpbmRIeWRyYXRhYmxlU3VzcGVuc2VJbnN0YW5jZShwYXJlbnRUeXBlLCBwYXJlbnRQcm9wcywgcGFyZW50SW5zdGFuY2UpIHtcbiAgaWYgKCBwYXJlbnRQcm9wc1tTVVBQUkVTU19IWURSQVRJT05fV0FSTklORyQxXSAhPT0gdHJ1ZSkgO1xufVxudmFyIGNsaWVudElkID0gMDtcbmZ1bmN0aW9uIG1ha2VDbGllbnRJZEluREVWKHdhcm5PbkFjY2Vzc0luREVWKSB7XG4gIHZhciBpZCA9ICdyOicgKyAoY2xpZW50SWQrKykudG9TdHJpbmcoMzYpO1xuICByZXR1cm4ge1xuICAgIHRvU3RyaW5nOiBmdW5jdGlvbiAoKSB7XG4gICAgICB3YXJuT25BY2Nlc3NJbkRFVigpO1xuICAgICAgcmV0dXJuIGlkO1xuICAgIH0sXG4gICAgdmFsdWVPZjogZnVuY3Rpb24gKCkge1xuICAgICAgd2Fybk9uQWNjZXNzSW5ERVYoKTtcbiAgICAgIHJldHVybiBpZDtcbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiBpc09wYXF1ZUh5ZHJhdGluZ09iamVjdCh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT09IG51bGwgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZS4kJHR5cGVvZiA9PT0gUkVBQ1RfT1BBUVVFX0lEX1RZUEU7XG59XG5mdW5jdGlvbiBtYWtlT3BhcXVlSHlkcmF0aW5nT2JqZWN0KGF0dGVtcHRUb1JlYWRWYWx1ZSkge1xuICByZXR1cm4ge1xuICAgICQkdHlwZW9mOiBSRUFDVF9PUEFRVUVfSURfVFlQRSxcbiAgICB0b1N0cmluZzogYXR0ZW1wdFRvUmVhZFZhbHVlLFxuICAgIHZhbHVlT2Y6IGF0dGVtcHRUb1JlYWRWYWx1ZVxuICB9O1xufVxuZnVuY3Rpb24gcHJlcGFyZVBvcnRhbE1vdW50KHBvcnRhbEluc3RhbmNlKSB7XG4gIHtcbiAgICBsaXN0ZW5Ub0FsbFN1cHBvcnRlZEV2ZW50cyhwb3J0YWxJbnN0YW5jZSk7XG4gIH1cbn1cblxudmFyIHJhbmRvbUtleSA9IE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnNsaWNlKDIpO1xudmFyIGludGVybmFsSW5zdGFuY2VLZXkgPSAnX19yZWFjdEZpYmVyJCcgKyByYW5kb21LZXk7XG52YXIgaW50ZXJuYWxQcm9wc0tleSA9ICdfX3JlYWN0UHJvcHMkJyArIHJhbmRvbUtleTtcbnZhciBpbnRlcm5hbENvbnRhaW5lckluc3RhbmNlS2V5ID0gJ19fcmVhY3RDb250YWluZXIkJyArIHJhbmRvbUtleTtcbnZhciBpbnRlcm5hbEV2ZW50SGFuZGxlcnNLZXkgPSAnX19yZWFjdEV2ZW50cyQnICsgcmFuZG9tS2V5O1xuZnVuY3Rpb24gcHJlY2FjaGVGaWJlck5vZGUoaG9zdEluc3QsIG5vZGUpIHtcbiAgbm9kZVtpbnRlcm5hbEluc3RhbmNlS2V5XSA9IGhvc3RJbnN0O1xufVxuZnVuY3Rpb24gbWFya0NvbnRhaW5lckFzUm9vdChob3N0Um9vdCwgbm9kZSkge1xuICBub2RlW2ludGVybmFsQ29udGFpbmVySW5zdGFuY2VLZXldID0gaG9zdFJvb3Q7XG59XG5mdW5jdGlvbiB1bm1hcmtDb250YWluZXJBc1Jvb3Qobm9kZSkge1xuICBub2RlW2ludGVybmFsQ29udGFpbmVySW5zdGFuY2VLZXldID0gbnVsbDtcbn1cbmZ1bmN0aW9uIGlzQ29udGFpbmVyTWFya2VkQXNSb290KG5vZGUpIHtcbiAgcmV0dXJuICEhbm9kZVtpbnRlcm5hbENvbnRhaW5lckluc3RhbmNlS2V5XTtcbn0gLy8gR2l2ZW4gYSBET00gbm9kZSwgcmV0dXJuIHRoZSBjbG9zZXN0IEhvc3RDb21wb25lbnQgb3IgSG9zdFRleHQgZmliZXIgYW5jZXN0b3IuXG4vLyBJZiB0aGUgdGFyZ2V0IG5vZGUgaXMgcGFydCBvZiBhIGh5ZHJhdGVkIG9yIG5vdCB5ZXQgcmVuZGVyZWQgc3VidHJlZSwgdGhlblxuLy8gdGhpcyBtYXkgYWxzbyByZXR1cm4gYSBTdXNwZW5zZUNvbXBvbmVudCBvciBIb3N0Um9vdCB0byBpbmRpY2F0ZSB0aGF0LlxuLy8gQ29uY2VwdHVhbGx5IHRoZSBIb3N0Um9vdCBmaWJlciBpcyBhIGNoaWxkIG9mIHRoZSBDb250YWluZXIgbm9kZS4gU28gaWYgeW91XG4vLyBwYXNzIHRoZSBDb250YWluZXIgbm9kZSBhcyB0aGUgdGFyZ2V0Tm9kZSwgeW91IHdpbGwgbm90IGFjdHVhbGx5IGdldCB0aGVcbi8vIEhvc3RSb290IGJhY2suIFRvIGdldCB0byB0aGUgSG9zdFJvb3QsIHlvdSBuZWVkIHRvIHBhc3MgYSBjaGlsZCBvZiBpdC5cbi8vIFRoZSBzYW1lIHRoaW5nIGFwcGxpZXMgdG8gU3VzcGVuc2UgYm91bmRhcmllcy5cblxuZnVuY3Rpb24gZ2V0Q2xvc2VzdEluc3RhbmNlRnJvbU5vZGUodGFyZ2V0Tm9kZSkge1xuICB2YXIgdGFyZ2V0SW5zdCA9IHRhcmdldE5vZGVbaW50ZXJuYWxJbnN0YW5jZUtleV07XG5cbiAgaWYgKHRhcmdldEluc3QpIHtcbiAgICAvLyBEb24ndCByZXR1cm4gSG9zdFJvb3Qgb3IgU3VzcGVuc2VDb21wb25lbnQgaGVyZS5cbiAgICByZXR1cm4gdGFyZ2V0SW5zdDtcbiAgfSAvLyBJZiB0aGUgZGlyZWN0IGV2ZW50IHRhcmdldCBpc24ndCBhIFJlYWN0IG93bmVkIERPTSBub2RlLCB3ZSBuZWVkIHRvIGxvb2tcbiAgLy8gdG8gc2VlIGlmIG9uZSBvZiBpdHMgcGFyZW50cyBpcyBhIFJlYWN0IG93bmVkIERPTSBub2RlLlxuXG5cbiAgdmFyIHBhcmVudE5vZGUgPSB0YXJnZXROb2RlLnBhcmVudE5vZGU7XG5cbiAgd2hpbGUgKHBhcmVudE5vZGUpIHtcbiAgICAvLyBXZSdsbCBjaGVjayBpZiB0aGlzIGlzIGEgY29udGFpbmVyIHJvb3QgdGhhdCBjb3VsZCBpbmNsdWRlXG4gICAgLy8gUmVhY3Qgbm9kZXMgaW4gdGhlIGZ1dHVyZS4gV2UgbmVlZCB0byBjaGVjayB0aGlzIGZpcnN0IGJlY2F1c2VcbiAgICAvLyBpZiB3ZSdyZSBhIGNoaWxkIG9mIGEgZGVoeWRyYXRlZCBjb250YWluZXIsIHdlIG5lZWQgdG8gZmlyc3RcbiAgICAvLyBmaW5kIHRoYXQgaW5uZXIgY29udGFpbmVyIGJlZm9yZSBtb3Zpbmcgb24gdG8gZmluZGluZyB0aGUgcGFyZW50XG4gICAgLy8gaW5zdGFuY2UuIE5vdGUgdGhhdCB3ZSBkb24ndCBjaGVjayB0aGlzIGZpZWxkIG9uICB0aGUgdGFyZ2V0Tm9kZVxuICAgIC8vIGl0c2VsZiBiZWNhdXNlIHRoZSBmaWJlcnMgYXJlIGNvbmNlcHR1YWxseSBiZXR3ZWVuIHRoZSBjb250YWluZXJcbiAgICAvLyBub2RlIGFuZCB0aGUgZmlyc3QgY2hpbGQuIEl0IGlzbid0IHN1cnJvdW5kaW5nIHRoZSBjb250YWluZXIgbm9kZS5cbiAgICAvLyBJZiBpdCdzIG5vdCBhIGNvbnRhaW5lciwgd2UgY2hlY2sgaWYgaXQncyBhbiBpbnN0YW5jZS5cbiAgICB0YXJnZXRJbnN0ID0gcGFyZW50Tm9kZVtpbnRlcm5hbENvbnRhaW5lckluc3RhbmNlS2V5XSB8fCBwYXJlbnROb2RlW2ludGVybmFsSW5zdGFuY2VLZXldO1xuXG4gICAgaWYgKHRhcmdldEluc3QpIHtcbiAgICAgIC8vIFNpbmNlIHRoaXMgd2Fzbid0IHRoZSBkaXJlY3QgdGFyZ2V0IG9mIHRoZSBldmVudCwgd2UgbWlnaHQgaGF2ZVxuICAgICAgLy8gc3RlcHBlZCBwYXN0IGRlaHlkcmF0ZWQgRE9NIG5vZGVzIHRvIGdldCBoZXJlLiBIb3dldmVyIHRoZXkgY291bGRcbiAgICAgIC8vIGFsc28gaGF2ZSBiZWVuIG5vbi1SZWFjdCBub2Rlcy4gV2UgbmVlZCB0byBhbnN3ZXIgd2hpY2ggb25lLlxuICAgICAgLy8gSWYgd2UgdGhlIGluc3RhbmNlIGRvZXNuJ3QgaGF2ZSBhbnkgY2hpbGRyZW4sIHRoZW4gdGhlcmUgY2FuJ3QgYmVcbiAgICAgIC8vIGEgbmVzdGVkIHN1c3BlbnNlIGJvdW5kYXJ5IHdpdGhpbiBpdC4gU28gd2UgY2FuIHVzZSB0aGlzIGFzIGEgZmFzdFxuICAgICAgLy8gYmFpbG91dC4gTW9zdCBvZiB0aGUgdGltZSwgd2hlbiBwZW9wbGUgYWRkIG5vbi1SZWFjdCBjaGlsZHJlbiB0b1xuICAgICAgLy8gdGhlIHRyZWUsIGl0IGlzIHVzaW5nIGEgcmVmIHRvIGEgY2hpbGQtbGVzcyBET00gbm9kZS5cbiAgICAgIC8vIE5vcm1hbGx5IHdlJ2Qgb25seSBuZWVkIHRvIGNoZWNrIG9uZSBvZiB0aGUgZmliZXJzIGJlY2F1c2UgaWYgaXRcbiAgICAgIC8vIGhhcyBldmVyIGdvbmUgZnJvbSBoYXZpbmcgY2hpbGRyZW4gdG8gZGVsZXRpbmcgdGhlbSBvciB2aWNlIHZlcnNhXG4gICAgICAvLyBpdCB3b3VsZCBoYXZlIGRlbGV0ZWQgdGhlIGRlaHlkcmF0ZWQgYm91bmRhcnkgbmVzdGVkIGluc2lkZSBhbHJlYWR5LlxuICAgICAgLy8gSG93ZXZlciwgc2luY2UgdGhlIEhvc3RSb290IHN0YXJ0cyBvdXQgd2l0aCBhbiBhbHRlcm5hdGUgaXQgbWlnaHRcbiAgICAgIC8vIGhhdmUgb25lIG9uIHRoZSBhbHRlcm5hdGUgc28gd2UgbmVlZCB0byBjaGVjayBpbiBjYXNlIHRoaXMgd2FzIGFcbiAgICAgIC8vIHJvb3QuXG4gICAgICB2YXIgYWx0ZXJuYXRlID0gdGFyZ2V0SW5zdC5hbHRlcm5hdGU7XG5cbiAgICAgIGlmICh0YXJnZXRJbnN0LmNoaWxkICE9PSBudWxsIHx8IGFsdGVybmF0ZSAhPT0gbnVsbCAmJiBhbHRlcm5hdGUuY2hpbGQgIT09IG51bGwpIHtcbiAgICAgICAgLy8gTmV4dCB3ZSBuZWVkIHRvIGZpZ3VyZSBvdXQgaWYgdGhlIG5vZGUgdGhhdCBza2lwcGVkIHBhc3QgaXNcbiAgICAgICAgLy8gbmVzdGVkIHdpdGhpbiBhIGRlaHlkcmF0ZWQgYm91bmRhcnkgYW5kIGlmIHNvLCB3aGljaCBvbmUuXG4gICAgICAgIHZhciBzdXNwZW5zZUluc3RhbmNlID0gZ2V0UGFyZW50U3VzcGVuc2VJbnN0YW5jZSh0YXJnZXROb2RlKTtcblxuICAgICAgICB3aGlsZSAoc3VzcGVuc2VJbnN0YW5jZSAhPT0gbnVsbCkge1xuICAgICAgICAgIC8vIFdlIGZvdW5kIGEgc3VzcGVuc2UgaW5zdGFuY2UuIFRoYXQgbWVhbnMgdGhhdCB3ZSBoYXZlbid0XG4gICAgICAgICAgLy8gaHlkcmF0ZWQgaXQgeWV0LiBFdmVuIHRob3VnaCB3ZSBsZWF2ZSB0aGUgY29tbWVudHMgaW4gdGhlXG4gICAgICAgICAgLy8gRE9NIGFmdGVyIGh5ZHJhdGluZywgYW5kIHRoZXJlIGFyZSBib3VuZGFyaWVzIGluIHRoZSBET01cbiAgICAgICAgICAvLyB0aGF0IGNvdWxkIGFscmVhZHkgYmUgaHlkcmF0ZWQsIHdlIHdvdWxkbid0IGhhdmUgZm91bmQgdGhlbVxuICAgICAgICAgIC8vIHRocm91Z2ggdGhpcyBwYXNzIHNpbmNlIGlmIHRoZSB0YXJnZXQgaXMgaHlkcmF0ZWQgaXQgd291bGRcbiAgICAgICAgICAvLyBoYXZlIGhhZCBhbiBpbnRlcm5hbEluc3RhbmNlS2V5IG9uIGl0LlxuICAgICAgICAgIC8vIExldCdzIGdldCB0aGUgZmliZXIgYXNzb2NpYXRlZCB3aXRoIHRoZSBTdXNwZW5zZUNvbXBvbmVudFxuICAgICAgICAgIC8vIGFzIHRoZSBkZWVwZXN0IGluc3RhbmNlLlxuICAgICAgICAgIHZhciB0YXJnZXRTdXNwZW5zZUluc3QgPSBzdXNwZW5zZUluc3RhbmNlW2ludGVybmFsSW5zdGFuY2VLZXldO1xuXG4gICAgICAgICAgaWYgKHRhcmdldFN1c3BlbnNlSW5zdCkge1xuICAgICAgICAgICAgcmV0dXJuIHRhcmdldFN1c3BlbnNlSW5zdDtcbiAgICAgICAgICB9IC8vIElmIHdlIGRvbid0IGZpbmQgYSBGaWJlciBvbiB0aGUgY29tbWVudCwgaXQgbWlnaHQgYmUgYmVjYXVzZVxuICAgICAgICAgIC8vIHdlIGhhdmVuJ3QgZ290dGVuIHRvIGh5ZHJhdGUgaXQgeWV0LiBUaGVyZSBtaWdodCBzdGlsbCBiZSBhXG4gICAgICAgICAgLy8gcGFyZW50IGJvdW5kYXJ5IHRoYXQgaGFzbid0IGFib3ZlIHRoaXMgb25lIHNvIHdlIG5lZWQgdG8gZmluZFxuICAgICAgICAgIC8vIHRoZSBvdXRlciBtb3N0IHRoYXQgaXMga25vd24uXG5cblxuICAgICAgICAgIHN1c3BlbnNlSW5zdGFuY2UgPSBnZXRQYXJlbnRTdXNwZW5zZUluc3RhbmNlKHN1c3BlbnNlSW5zdGFuY2UpOyAvLyBJZiB3ZSBkb24ndCBmaW5kIG9uZSwgdGhlbiB0aGF0IHNob3VsZCBtZWFuIHRoYXQgdGhlIHBhcmVudFxuICAgICAgICAgIC8vIGhvc3QgY29tcG9uZW50IGFsc28gaGFzbid0IGh5ZHJhdGVkIHlldC4gV2UgY2FuIHJldHVybiBpdFxuICAgICAgICAgIC8vIGJlbG93IHNpbmNlIGl0IHdpbGwgYmFpbCBvdXQgb24gdGhlIGlzTW91bnRlZCBjaGVjayBsYXRlci5cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGFyZ2V0SW5zdDtcbiAgICB9XG5cbiAgICB0YXJnZXROb2RlID0gcGFyZW50Tm9kZTtcbiAgICBwYXJlbnROb2RlID0gdGFyZ2V0Tm9kZS5wYXJlbnROb2RlO1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG4vKipcbiAqIEdpdmVuIGEgRE9NIG5vZGUsIHJldHVybiB0aGUgUmVhY3RET01Db21wb25lbnQgb3IgUmVhY3RET01UZXh0Q29tcG9uZW50XG4gKiBpbnN0YW5jZSwgb3IgbnVsbCBpZiB0aGUgbm9kZSB3YXMgbm90IHJlbmRlcmVkIGJ5IHRoaXMgUmVhY3QuXG4gKi9cblxuZnVuY3Rpb24gZ2V0SW5zdGFuY2VGcm9tTm9kZShub2RlKSB7XG4gIHZhciBpbnN0ID0gbm9kZVtpbnRlcm5hbEluc3RhbmNlS2V5XSB8fCBub2RlW2ludGVybmFsQ29udGFpbmVySW5zdGFuY2VLZXldO1xuXG4gIGlmIChpbnN0KSB7XG4gICAgaWYgKGluc3QudGFnID09PSBIb3N0Q29tcG9uZW50IHx8IGluc3QudGFnID09PSBIb3N0VGV4dCB8fCBpbnN0LnRhZyA9PT0gU3VzcGVuc2VDb21wb25lbnQgfHwgaW5zdC50YWcgPT09IEhvc3RSb290KSB7XG4gICAgICByZXR1cm4gaW5zdDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG4vKipcbiAqIEdpdmVuIGEgUmVhY3RET01Db21wb25lbnQgb3IgUmVhY3RET01UZXh0Q29tcG9uZW50LCByZXR1cm4gdGhlIGNvcnJlc3BvbmRpbmdcbiAqIERPTSBub2RlLlxuICovXG5cbmZ1bmN0aW9uIGdldE5vZGVGcm9tSW5zdGFuY2UoaW5zdCkge1xuICBpZiAoaW5zdC50YWcgPT09IEhvc3RDb21wb25lbnQgfHwgaW5zdC50YWcgPT09IEhvc3RUZXh0KSB7XG4gICAgLy8gSW4gRmliZXIgdGhpcywgaXMganVzdCB0aGUgc3RhdGUgbm9kZSByaWdodCBub3cuIFdlIGFzc3VtZSBpdCB3aWxsIGJlXG4gICAgLy8gYSBob3N0IGNvbXBvbmVudCBvciBob3N0IHRleHQuXG4gICAgcmV0dXJuIGluc3Quc3RhdGVOb2RlO1xuICB9IC8vIFdpdGhvdXQgdGhpcyBmaXJzdCBpbnZhcmlhbnQsIHBhc3NpbmcgYSBub24tRE9NLWNvbXBvbmVudCB0cmlnZ2VycyB0aGUgbmV4dFxuICAvLyBpbnZhcmlhbnQgZm9yIGEgbWlzc2luZyBwYXJlbnQsIHdoaWNoIGlzIHN1cGVyIGNvbmZ1c2luZy5cblxuXG4gIHtcbiAgICB7XG4gICAgICB0aHJvdyBFcnJvciggXCJnZXROb2RlRnJvbUluc3RhbmNlOiBJbnZhbGlkIGFyZ3VtZW50LlwiICk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBnZXRGaWJlckN1cnJlbnRQcm9wc0Zyb21Ob2RlKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGVbaW50ZXJuYWxQcm9wc0tleV0gfHwgbnVsbDtcbn1cbmZ1bmN0aW9uIHVwZGF0ZUZpYmVyUHJvcHMobm9kZSwgcHJvcHMpIHtcbiAgbm9kZVtpbnRlcm5hbFByb3BzS2V5XSA9IHByb3BzO1xufVxuZnVuY3Rpb24gZ2V0RXZlbnRMaXN0ZW5lclNldChub2RlKSB7XG4gIHZhciBlbGVtZW50TGlzdGVuZXJTZXQgPSBub2RlW2ludGVybmFsRXZlbnRIYW5kbGVyc0tleV07XG5cbiAgaWYgKGVsZW1lbnRMaXN0ZW5lclNldCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZWxlbWVudExpc3RlbmVyU2V0ID0gbm9kZVtpbnRlcm5hbEV2ZW50SGFuZGxlcnNLZXldID0gbmV3IFNldCgpO1xuICB9XG5cbiAgcmV0dXJuIGVsZW1lbnRMaXN0ZW5lclNldDtcbn1cblxudmFyIGxvZ2dlZFR5cGVGYWlsdXJlcyA9IHt9O1xudmFyIFJlYWN0RGVidWdDdXJyZW50RnJhbWUkMSA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0RGVidWdDdXJyZW50RnJhbWU7XG5cbmZ1bmN0aW9uIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KGVsZW1lbnQpIHtcbiAge1xuICAgIGlmIChlbGVtZW50KSB7XG4gICAgICB2YXIgb3duZXIgPSBlbGVtZW50Ll9vd25lcjtcbiAgICAgIHZhciBzdGFjayA9IGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVihlbGVtZW50LnR5cGUsIGVsZW1lbnQuX3NvdXJjZSwgb3duZXIgPyBvd25lci50eXBlIDogbnVsbCk7XG4gICAgICBSZWFjdERlYnVnQ3VycmVudEZyYW1lJDEuc2V0RXh0cmFTdGFja0ZyYW1lKHN0YWNrKTtcbiAgICB9IGVsc2Uge1xuICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSQxLnNldEV4dHJhU3RhY2tGcmFtZShudWxsKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY2hlY2tQcm9wVHlwZXModHlwZVNwZWNzLCB2YWx1ZXMsIGxvY2F0aW9uLCBjb21wb25lbnROYW1lLCBlbGVtZW50KSB7XG4gIHtcbiAgICAvLyAkRmxvd0ZpeE1lIFRoaXMgaXMgb2theSBidXQgRmxvdyBkb2Vzbid0IGtub3cgaXQuXG4gICAgdmFyIGhhcyA9IEZ1bmN0aW9uLmNhbGwuYmluZChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5KTtcblxuICAgIGZvciAodmFyIHR5cGVTcGVjTmFtZSBpbiB0eXBlU3BlY3MpIHtcbiAgICAgIGlmIChoYXModHlwZVNwZWNzLCB0eXBlU3BlY05hbWUpKSB7XG4gICAgICAgIHZhciBlcnJvciQxID0gdm9pZCAwOyAvLyBQcm9wIHR5cGUgdmFsaWRhdGlvbiBtYXkgdGhyb3cuIEluIGNhc2UgdGhleSBkbywgd2UgZG9uJ3Qgd2FudCB0b1xuICAgICAgICAvLyBmYWlsIHRoZSByZW5kZXIgcGhhc2Ugd2hlcmUgaXQgZGlkbid0IGZhaWwgYmVmb3JlLiBTbyB3ZSBsb2cgaXQuXG4gICAgICAgIC8vIEFmdGVyIHRoZXNlIGhhdmUgYmVlbiBjbGVhbmVkIHVwLCB3ZSdsbCBsZXQgdGhlbSB0aHJvdy5cblxuICAgICAgICB0cnkge1xuICAgICAgICAgIC8vIFRoaXMgaXMgaW50ZW50aW9uYWxseSBhbiBpbnZhcmlhbnQgdGhhdCBnZXRzIGNhdWdodC4gSXQncyB0aGUgc2FtZVxuICAgICAgICAgIC8vIGJlaGF2aW9yIGFzIHdpdGhvdXQgdGhpcyBzdGF0ZW1lbnQgZXhjZXB0IHdpdGggYSBiZXR0ZXIgbWVzc2FnZS5cbiAgICAgICAgICBpZiAodHlwZW9mIHR5cGVTcGVjc1t0eXBlU3BlY05hbWVdICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB2YXIgZXJyID0gRXJyb3IoKGNvbXBvbmVudE5hbWUgfHwgJ1JlYWN0IGNsYXNzJykgKyAnOiAnICsgbG9jYXRpb24gKyAnIHR5cGUgYCcgKyB0eXBlU3BlY05hbWUgKyAnYCBpcyBpbnZhbGlkOyAnICsgJ2l0IG11c3QgYmUgYSBmdW5jdGlvbiwgdXN1YWxseSBmcm9tIHRoZSBgcHJvcC10eXBlc2AgcGFja2FnZSwgYnV0IHJlY2VpdmVkIGAnICsgdHlwZW9mIHR5cGVTcGVjc1t0eXBlU3BlY05hbWVdICsgJ2AuJyArICdUaGlzIG9mdGVuIGhhcHBlbnMgYmVjYXVzZSBvZiB0eXBvcyBzdWNoIGFzIGBQcm9wVHlwZXMuZnVuY3Rpb25gIGluc3RlYWQgb2YgYFByb3BUeXBlcy5mdW5jYC4nKTtcbiAgICAgICAgICAgIGVyci5uYW1lID0gJ0ludmFyaWFudCBWaW9sYXRpb24nO1xuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGVycm9yJDEgPSB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSh2YWx1ZXMsIHR5cGVTcGVjTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIG51bGwsICdTRUNSRVRfRE9fTk9UX1BBU1NfVEhJU19PUl9ZT1VfV0lMTF9CRV9GSVJFRCcpO1xuICAgICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICAgIGVycm9yJDEgPSBleDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlcnJvciQxICYmICEoZXJyb3IkMSBpbnN0YW5jZW9mIEVycm9yKSkge1xuICAgICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KGVsZW1lbnQpO1xuXG4gICAgICAgICAgZXJyb3IoJyVzOiB0eXBlIHNwZWNpZmljYXRpb24gb2YgJXMnICsgJyBgJXNgIGlzIGludmFsaWQ7IHRoZSB0eXBlIGNoZWNrZXIgJyArICdmdW5jdGlvbiBtdXN0IHJldHVybiBgbnVsbGAgb3IgYW4gYEVycm9yYCBidXQgcmV0dXJuZWQgYSAlcy4gJyArICdZb3UgbWF5IGhhdmUgZm9yZ290dGVuIHRvIHBhc3MgYW4gYXJndW1lbnQgdG8gdGhlIHR5cGUgY2hlY2tlciAnICsgJ2NyZWF0b3IgKGFycmF5T2YsIGluc3RhbmNlT2YsIG9iamVjdE9mLCBvbmVPZiwgb25lT2ZUeXBlLCBhbmQgJyArICdzaGFwZSBhbGwgcmVxdWlyZSBhbiBhcmd1bWVudCkuJywgY29tcG9uZW50TmFtZSB8fCAnUmVhY3QgY2xhc3MnLCBsb2NhdGlvbiwgdHlwZVNwZWNOYW1lLCB0eXBlb2YgZXJyb3IkMSk7XG5cbiAgICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChudWxsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlcnJvciQxIGluc3RhbmNlb2YgRXJyb3IgJiYgIShlcnJvciQxLm1lc3NhZ2UgaW4gbG9nZ2VkVHlwZUZhaWx1cmVzKSkge1xuICAgICAgICAgIC8vIE9ubHkgbW9uaXRvciB0aGlzIGZhaWx1cmUgb25jZSBiZWNhdXNlIHRoZXJlIHRlbmRzIHRvIGJlIGEgbG90IG9mIHRoZVxuICAgICAgICAgIC8vIHNhbWUgZXJyb3IuXG4gICAgICAgICAgbG9nZ2VkVHlwZUZhaWx1cmVzW2Vycm9yJDEubWVzc2FnZV0gPSB0cnVlO1xuICAgICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KGVsZW1lbnQpO1xuXG4gICAgICAgICAgZXJyb3IoJ0ZhaWxlZCAlcyB0eXBlOiAlcycsIGxvY2F0aW9uLCBlcnJvciQxLm1lc3NhZ2UpO1xuXG4gICAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQobnVsbCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxudmFyIHZhbHVlU3RhY2sgPSBbXTtcbnZhciBmaWJlclN0YWNrO1xuXG57XG4gIGZpYmVyU3RhY2sgPSBbXTtcbn1cblxudmFyIGluZGV4ID0gLTE7XG5cbmZ1bmN0aW9uIGNyZWF0ZUN1cnNvcihkZWZhdWx0VmFsdWUpIHtcbiAgcmV0dXJuIHtcbiAgICBjdXJyZW50OiBkZWZhdWx0VmFsdWVcbiAgfTtcbn1cblxuZnVuY3Rpb24gcG9wKGN1cnNvciwgZmliZXIpIHtcbiAgaWYgKGluZGV4IDwgMCkge1xuICAgIHtcbiAgICAgIGVycm9yKCdVbmV4cGVjdGVkIHBvcC4nKTtcbiAgICB9XG5cbiAgICByZXR1cm47XG4gIH1cblxuICB7XG4gICAgaWYgKGZpYmVyICE9PSBmaWJlclN0YWNrW2luZGV4XSkge1xuICAgICAgZXJyb3IoJ1VuZXhwZWN0ZWQgRmliZXIgcG9wcGVkLicpO1xuICAgIH1cbiAgfVxuXG4gIGN1cnNvci5jdXJyZW50ID0gdmFsdWVTdGFja1tpbmRleF07XG4gIHZhbHVlU3RhY2tbaW5kZXhdID0gbnVsbDtcblxuICB7XG4gICAgZmliZXJTdGFja1tpbmRleF0gPSBudWxsO1xuICB9XG5cbiAgaW5kZXgtLTtcbn1cblxuZnVuY3Rpb24gcHVzaChjdXJzb3IsIHZhbHVlLCBmaWJlcikge1xuICBpbmRleCsrO1xuICB2YWx1ZVN0YWNrW2luZGV4XSA9IGN1cnNvci5jdXJyZW50O1xuXG4gIHtcbiAgICBmaWJlclN0YWNrW2luZGV4XSA9IGZpYmVyO1xuICB9XG5cbiAgY3Vyc29yLmN1cnJlbnQgPSB2YWx1ZTtcbn1cblxudmFyIHdhcm5lZEFib3V0TWlzc2luZ0dldENoaWxkQ29udGV4dDtcblxue1xuICB3YXJuZWRBYm91dE1pc3NpbmdHZXRDaGlsZENvbnRleHQgPSB7fTtcbn1cblxudmFyIGVtcHR5Q29udGV4dE9iamVjdCA9IHt9O1xuXG57XG4gIE9iamVjdC5mcmVlemUoZW1wdHlDb250ZXh0T2JqZWN0KTtcbn0gLy8gQSBjdXJzb3IgdG8gdGhlIGN1cnJlbnQgbWVyZ2VkIGNvbnRleHQgb2JqZWN0IG9uIHRoZSBzdGFjay5cblxuXG52YXIgY29udGV4dFN0YWNrQ3Vyc29yID0gY3JlYXRlQ3Vyc29yKGVtcHR5Q29udGV4dE9iamVjdCk7IC8vIEEgY3Vyc29yIHRvIGEgYm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgdGhlIGNvbnRleHQgaGFzIGNoYW5nZWQuXG5cbnZhciBkaWRQZXJmb3JtV29ya1N0YWNrQ3Vyc29yID0gY3JlYXRlQ3Vyc29yKGZhbHNlKTsgLy8gS2VlcCB0cmFjayBvZiB0aGUgcHJldmlvdXMgY29udGV4dCBvYmplY3QgdGhhdCB3YXMgb24gdGhlIHN0YWNrLlxuLy8gV2UgdXNlIHRoaXMgdG8gZ2V0IGFjY2VzcyB0byB0aGUgcGFyZW50IGNvbnRleHQgYWZ0ZXIgd2UgaGF2ZSBhbHJlYWR5XG4vLyBwdXNoZWQgdGhlIG5leHQgY29udGV4dCBwcm92aWRlciwgYW5kIG5vdyBuZWVkIHRvIG1lcmdlIHRoZWlyIGNvbnRleHRzLlxuXG52YXIgcHJldmlvdXNDb250ZXh0ID0gZW1wdHlDb250ZXh0T2JqZWN0O1xuXG5mdW5jdGlvbiBnZXRVbm1hc2tlZENvbnRleHQod29ya0luUHJvZ3Jlc3MsIENvbXBvbmVudCwgZGlkUHVzaE93bkNvbnRleHRJZlByb3ZpZGVyKSB7XG4gIHtcbiAgICBpZiAoZGlkUHVzaE93bkNvbnRleHRJZlByb3ZpZGVyICYmIGlzQ29udGV4dFByb3ZpZGVyKENvbXBvbmVudCkpIHtcbiAgICAgIC8vIElmIHRoZSBmaWJlciBpcyBhIGNvbnRleHQgcHJvdmlkZXIgaXRzZWxmLCB3aGVuIHdlIHJlYWQgaXRzIGNvbnRleHRcbiAgICAgIC8vIHdlIG1heSBoYXZlIGFscmVhZHkgcHVzaGVkIGl0cyBvd24gY2hpbGQgY29udGV4dCBvbiB0aGUgc3RhY2suIEEgY29udGV4dFxuICAgICAgLy8gcHJvdmlkZXIgc2hvdWxkIG5vdCBcInNlZVwiIGl0cyBvd24gY2hpbGQgY29udGV4dC4gVGhlcmVmb3JlIHdlIHJlYWQgdGhlXG4gICAgICAvLyBwcmV2aW91cyAocGFyZW50KSBjb250ZXh0IGluc3RlYWQgZm9yIGEgY29udGV4dCBwcm92aWRlci5cbiAgICAgIHJldHVybiBwcmV2aW91c0NvbnRleHQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNvbnRleHRTdGFja0N1cnNvci5jdXJyZW50O1xuICB9XG59XG5cbmZ1bmN0aW9uIGNhY2hlQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgdW5tYXNrZWRDb250ZXh0LCBtYXNrZWRDb250ZXh0KSB7XG4gIHtcbiAgICB2YXIgaW5zdGFuY2UgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG4gICAgaW5zdGFuY2UuX19yZWFjdEludGVybmFsTWVtb2l6ZWRVbm1hc2tlZENoaWxkQ29udGV4dCA9IHVubWFza2VkQ29udGV4dDtcbiAgICBpbnN0YW5jZS5fX3JlYWN0SW50ZXJuYWxNZW1vaXplZE1hc2tlZENoaWxkQ29udGV4dCA9IG1hc2tlZENvbnRleHQ7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0TWFza2VkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgdW5tYXNrZWRDb250ZXh0KSB7XG4gIHtcbiAgICB2YXIgdHlwZSA9IHdvcmtJblByb2dyZXNzLnR5cGU7XG4gICAgdmFyIGNvbnRleHRUeXBlcyA9IHR5cGUuY29udGV4dFR5cGVzO1xuXG4gICAgaWYgKCFjb250ZXh0VHlwZXMpIHtcbiAgICAgIHJldHVybiBlbXB0eUNvbnRleHRPYmplY3Q7XG4gICAgfSAvLyBBdm9pZCByZWNyZWF0aW5nIG1hc2tlZCBjb250ZXh0IHVubGVzcyB1bm1hc2tlZCBjb250ZXh0IGhhcyBjaGFuZ2VkLlxuICAgIC8vIEZhaWxpbmcgdG8gZG8gdGhpcyB3aWxsIHJlc3VsdCBpbiB1bm5lY2Vzc2FyeSBjYWxscyB0byBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzLlxuICAgIC8vIFRoaXMgbWF5IHRyaWdnZXIgaW5maW5pdGUgbG9vcHMgaWYgY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyBjYWxscyBzZXRTdGF0ZS5cblxuXG4gICAgdmFyIGluc3RhbmNlID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuXG4gICAgaWYgKGluc3RhbmNlICYmIGluc3RhbmNlLl9fcmVhY3RJbnRlcm5hbE1lbW9pemVkVW5tYXNrZWRDaGlsZENvbnRleHQgPT09IHVubWFza2VkQ29udGV4dCkge1xuICAgICAgcmV0dXJuIGluc3RhbmNlLl9fcmVhY3RJbnRlcm5hbE1lbW9pemVkTWFza2VkQ2hpbGRDb250ZXh0O1xuICAgIH1cblxuICAgIHZhciBjb250ZXh0ID0ge307XG5cbiAgICBmb3IgKHZhciBrZXkgaW4gY29udGV4dFR5cGVzKSB7XG4gICAgICBjb250ZXh0W2tleV0gPSB1bm1hc2tlZENvbnRleHRba2V5XTtcbiAgICB9XG5cbiAgICB7XG4gICAgICB2YXIgbmFtZSA9IGdldENvbXBvbmVudE5hbWUodHlwZSkgfHwgJ1Vua25vd24nO1xuICAgICAgY2hlY2tQcm9wVHlwZXMoY29udGV4dFR5cGVzLCBjb250ZXh0LCAnY29udGV4dCcsIG5hbWUpO1xuICAgIH0gLy8gQ2FjaGUgdW5tYXNrZWQgY29udGV4dCBzbyB3ZSBjYW4gYXZvaWQgcmVjcmVhdGluZyBtYXNrZWQgY29udGV4dCB1bmxlc3MgbmVjZXNzYXJ5LlxuICAgIC8vIENvbnRleHQgaXMgY3JlYXRlZCBiZWZvcmUgdGhlIGNsYXNzIGNvbXBvbmVudCBpcyBpbnN0YW50aWF0ZWQgc28gY2hlY2sgZm9yIGluc3RhbmNlLlxuXG5cbiAgICBpZiAoaW5zdGFuY2UpIHtcbiAgICAgIGNhY2hlQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgdW5tYXNrZWRDb250ZXh0LCBjb250ZXh0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gY29udGV4dDtcbiAgfVxufVxuXG5mdW5jdGlvbiBoYXNDb250ZXh0Q2hhbmdlZCgpIHtcbiAge1xuICAgIHJldHVybiBkaWRQZXJmb3JtV29ya1N0YWNrQ3Vyc29yLmN1cnJlbnQ7XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNDb250ZXh0UHJvdmlkZXIodHlwZSkge1xuICB7XG4gICAgdmFyIGNoaWxkQ29udGV4dFR5cGVzID0gdHlwZS5jaGlsZENvbnRleHRUeXBlcztcbiAgICByZXR1cm4gY2hpbGRDb250ZXh0VHlwZXMgIT09IG51bGwgJiYgY2hpbGRDb250ZXh0VHlwZXMgIT09IHVuZGVmaW5lZDtcbiAgfVxufVxuXG5mdW5jdGlvbiBwb3BDb250ZXh0KGZpYmVyKSB7XG4gIHtcbiAgICBwb3AoZGlkUGVyZm9ybVdvcmtTdGFja0N1cnNvciwgZmliZXIpO1xuICAgIHBvcChjb250ZXh0U3RhY2tDdXJzb3IsIGZpYmVyKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwb3BUb3BMZXZlbENvbnRleHRPYmplY3QoZmliZXIpIHtcbiAge1xuICAgIHBvcChkaWRQZXJmb3JtV29ya1N0YWNrQ3Vyc29yLCBmaWJlcik7XG4gICAgcG9wKGNvbnRleHRTdGFja0N1cnNvciwgZmliZXIpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHB1c2hUb3BMZXZlbENvbnRleHRPYmplY3QoZmliZXIsIGNvbnRleHQsIGRpZENoYW5nZSkge1xuICB7XG4gICAgaWYgKCEoY29udGV4dFN0YWNrQ3Vyc29yLmN1cnJlbnQgPT09IGVtcHR5Q29udGV4dE9iamVjdCkpIHtcbiAgICAgIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoIFwiVW5leHBlY3RlZCBjb250ZXh0IGZvdW5kIG9uIHN0YWNrLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiICk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcHVzaChjb250ZXh0U3RhY2tDdXJzb3IsIGNvbnRleHQsIGZpYmVyKTtcbiAgICBwdXNoKGRpZFBlcmZvcm1Xb3JrU3RhY2tDdXJzb3IsIGRpZENoYW5nZSwgZmliZXIpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NDaGlsZENvbnRleHQoZmliZXIsIHR5cGUsIHBhcmVudENvbnRleHQpIHtcbiAge1xuICAgIHZhciBpbnN0YW5jZSA9IGZpYmVyLnN0YXRlTm9kZTtcbiAgICB2YXIgY2hpbGRDb250ZXh0VHlwZXMgPSB0eXBlLmNoaWxkQ29udGV4dFR5cGVzOyAvLyBUT0RPIChidmF1Z2huKSBSZXBsYWNlIHRoaXMgYmVoYXZpb3Igd2l0aCBhbiBpbnZhcmlhbnQoKSBpbiB0aGUgZnV0dXJlLlxuICAgIC8vIEl0IGhhcyBvbmx5IGJlZW4gYWRkZWQgaW4gRmliZXIgdG8gbWF0Y2ggdGhlICh1bmludGVudGlvbmFsKSBiZWhhdmlvciBpbiBTdGFjay5cblxuICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuZ2V0Q2hpbGRDb250ZXh0ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB7XG4gICAgICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZSh0eXBlKSB8fCAnVW5rbm93bic7XG5cbiAgICAgICAgaWYgKCF3YXJuZWRBYm91dE1pc3NpbmdHZXRDaGlsZENvbnRleHRbY29tcG9uZW50TmFtZV0pIHtcbiAgICAgICAgICB3YXJuZWRBYm91dE1pc3NpbmdHZXRDaGlsZENvbnRleHRbY29tcG9uZW50TmFtZV0gPSB0cnVlO1xuXG4gICAgICAgICAgZXJyb3IoJyVzLmNoaWxkQ29udGV4dFR5cGVzIGlzIHNwZWNpZmllZCBidXQgdGhlcmUgaXMgbm8gZ2V0Q2hpbGRDb250ZXh0KCkgbWV0aG9kICcgKyAnb24gdGhlIGluc3RhbmNlLiBZb3UgY2FuIGVpdGhlciBkZWZpbmUgZ2V0Q2hpbGRDb250ZXh0KCkgb24gJXMgb3IgcmVtb3ZlICcgKyAnY2hpbGRDb250ZXh0VHlwZXMgZnJvbSBpdC4nLCBjb21wb25lbnROYW1lLCBjb21wb25lbnROYW1lKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcGFyZW50Q29udGV4dDtcbiAgICB9XG5cbiAgICB2YXIgY2hpbGRDb250ZXh0ID0gaW5zdGFuY2UuZ2V0Q2hpbGRDb250ZXh0KCk7XG5cbiAgICBmb3IgKHZhciBjb250ZXh0S2V5IGluIGNoaWxkQ29udGV4dCkge1xuICAgICAgaWYgKCEoY29udGV4dEtleSBpbiBjaGlsZENvbnRleHRUeXBlcykpIHtcbiAgICAgICAge1xuICAgICAgICAgIHRocm93IEVycm9yKCAoZ2V0Q29tcG9uZW50TmFtZSh0eXBlKSB8fCAnVW5rbm93bicpICsgXCIuZ2V0Q2hpbGRDb250ZXh0KCk6IGtleSBcXFwiXCIgKyBjb250ZXh0S2V5ICsgXCJcXFwiIGlzIG5vdCBkZWZpbmVkIGluIGNoaWxkQ29udGV4dFR5cGVzLlwiICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB7XG4gICAgICB2YXIgbmFtZSA9IGdldENvbXBvbmVudE5hbWUodHlwZSkgfHwgJ1Vua25vd24nO1xuICAgICAgY2hlY2tQcm9wVHlwZXMoY2hpbGRDb250ZXh0VHlwZXMsIGNoaWxkQ29udGV4dCwgJ2NoaWxkIGNvbnRleHQnLCBuYW1lKTtcbiAgICB9XG5cbiAgICByZXR1cm4gX2Fzc2lnbih7fSwgcGFyZW50Q29udGV4dCwgY2hpbGRDb250ZXh0KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwdXNoQ29udGV4dFByb3ZpZGVyKHdvcmtJblByb2dyZXNzKSB7XG4gIHtcbiAgICB2YXIgaW5zdGFuY2UgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7IC8vIFdlIHB1c2ggdGhlIGNvbnRleHQgYXMgZWFybHkgYXMgcG9zc2libGUgdG8gZW5zdXJlIHN0YWNrIGludGVncml0eS5cbiAgICAvLyBJZiB0aGUgaW5zdGFuY2UgZG9lcyBub3QgZXhpc3QgeWV0LCB3ZSB3aWxsIHB1c2ggbnVsbCBhdCBmaXJzdCxcbiAgICAvLyBhbmQgcmVwbGFjZSBpdCBvbiB0aGUgc3RhY2sgbGF0ZXIgd2hlbiBpbnZhbGlkYXRpbmcgdGhlIGNvbnRleHQuXG5cbiAgICB2YXIgbWVtb2l6ZWRNZXJnZWRDaGlsZENvbnRleHQgPSBpbnN0YW5jZSAmJiBpbnN0YW5jZS5fX3JlYWN0SW50ZXJuYWxNZW1vaXplZE1lcmdlZENoaWxkQ29udGV4dCB8fCBlbXB0eUNvbnRleHRPYmplY3Q7IC8vIFJlbWVtYmVyIHRoZSBwYXJlbnQgY29udGV4dCBzbyB3ZSBjYW4gbWVyZ2Ugd2l0aCBpdCBsYXRlci5cbiAgICAvLyBJbmhlcml0IHRoZSBwYXJlbnQncyBkaWQtcGVyZm9ybS13b3JrIHZhbHVlIHRvIGF2b2lkIGluYWR2ZXJ0ZW50bHkgYmxvY2tpbmcgdXBkYXRlcy5cblxuICAgIHByZXZpb3VzQ29udGV4dCA9IGNvbnRleHRTdGFja0N1cnNvci5jdXJyZW50O1xuICAgIHB1c2goY29udGV4dFN0YWNrQ3Vyc29yLCBtZW1vaXplZE1lcmdlZENoaWxkQ29udGV4dCwgd29ya0luUHJvZ3Jlc3MpO1xuICAgIHB1c2goZGlkUGVyZm9ybVdvcmtTdGFja0N1cnNvciwgZGlkUGVyZm9ybVdvcmtTdGFja0N1cnNvci5jdXJyZW50LCB3b3JrSW5Qcm9ncmVzcyk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW52YWxpZGF0ZUNvbnRleHRQcm92aWRlcih3b3JrSW5Qcm9ncmVzcywgdHlwZSwgZGlkQ2hhbmdlKSB7XG4gIHtcbiAgICB2YXIgaW5zdGFuY2UgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG5cbiAgICBpZiAoIWluc3RhbmNlKSB7XG4gICAgICB7XG4gICAgICAgIHRocm93IEVycm9yKCBcIkV4cGVjdGVkIHRvIGhhdmUgYW4gaW5zdGFuY2UgYnkgdGhpcyBwb2ludC4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS5cIiApO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChkaWRDaGFuZ2UpIHtcbiAgICAgIC8vIE1lcmdlIHBhcmVudCBhbmQgb3duIGNvbnRleHQuXG4gICAgICAvLyBTa2lwIHRoaXMgaWYgd2UncmUgbm90IHVwZGF0aW5nIGR1ZSB0byBzQ1UuXG4gICAgICAvLyBUaGlzIGF2b2lkcyB1bm5lY2Vzc2FyaWx5IHJlY29tcHV0aW5nIG1lbW9pemVkIHZhbHVlcy5cbiAgICAgIHZhciBtZXJnZWRDb250ZXh0ID0gcHJvY2Vzc0NoaWxkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgdHlwZSwgcHJldmlvdXNDb250ZXh0KTtcbiAgICAgIGluc3RhbmNlLl9fcmVhY3RJbnRlcm5hbE1lbW9pemVkTWVyZ2VkQ2hpbGRDb250ZXh0ID0gbWVyZ2VkQ29udGV4dDsgLy8gUmVwbGFjZSB0aGUgb2xkIChvciBlbXB0eSkgY29udGV4dCB3aXRoIHRoZSBuZXcgb25lLlxuICAgICAgLy8gSXQgaXMgaW1wb3J0YW50IHRvIHVud2luZCB0aGUgY29udGV4dCBpbiB0aGUgcmV2ZXJzZSBvcmRlci5cblxuICAgICAgcG9wKGRpZFBlcmZvcm1Xb3JrU3RhY2tDdXJzb3IsIHdvcmtJblByb2dyZXNzKTtcbiAgICAgIHBvcChjb250ZXh0U3RhY2tDdXJzb3IsIHdvcmtJblByb2dyZXNzKTsgLy8gTm93IHB1c2ggdGhlIG5ldyBjb250ZXh0IGFuZCBtYXJrIHRoYXQgaXQgaGFzIGNoYW5nZWQuXG5cbiAgICAgIHB1c2goY29udGV4dFN0YWNrQ3Vyc29yLCBtZXJnZWRDb250ZXh0LCB3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICBwdXNoKGRpZFBlcmZvcm1Xb3JrU3RhY2tDdXJzb3IsIGRpZENoYW5nZSwgd29ya0luUHJvZ3Jlc3MpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwb3AoZGlkUGVyZm9ybVdvcmtTdGFja0N1cnNvciwgd29ya0luUHJvZ3Jlc3MpO1xuICAgICAgcHVzaChkaWRQZXJmb3JtV29ya1N0YWNrQ3Vyc29yLCBkaWRDaGFuZ2UsIHdvcmtJblByb2dyZXNzKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZmluZEN1cnJlbnRVbm1hc2tlZENvbnRleHQoZmliZXIpIHtcbiAge1xuICAgIC8vIEN1cnJlbnRseSB0aGlzIGlzIG9ubHkgdXNlZCB3aXRoIHJlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyOyBub3Qgc3VyZSBpZiBpdFxuICAgIC8vIG1ha2VzIHNlbnNlIGVsc2V3aGVyZVxuICAgIGlmICghKGlzRmliZXJNb3VudGVkKGZpYmVyKSAmJiBmaWJlci50YWcgPT09IENsYXNzQ29tcG9uZW50KSkge1xuICAgICAge1xuICAgICAgICB0aHJvdyBFcnJvciggXCJFeHBlY3RlZCBzdWJ0cmVlIHBhcmVudCB0byBiZSBhIG1vdW50ZWQgY2xhc3MgY29tcG9uZW50LiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiICk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIG5vZGUgPSBmaWJlcjtcblxuICAgIGRvIHtcbiAgICAgIHN3aXRjaCAobm9kZS50YWcpIHtcbiAgICAgICAgY2FzZSBIb3N0Um9vdDpcbiAgICAgICAgICByZXR1cm4gbm9kZS5zdGF0ZU5vZGUuY29udGV4dDtcblxuICAgICAgICBjYXNlIENsYXNzQ29tcG9uZW50OlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHZhciBDb21wb25lbnQgPSBub2RlLnR5cGU7XG5cbiAgICAgICAgICAgIGlmIChpc0NvbnRleHRQcm92aWRlcihDb21wb25lbnQpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBub2RlLnN0YXRlTm9kZS5fX3JlYWN0SW50ZXJuYWxNZW1vaXplZE1lcmdlZENoaWxkQ29udGV4dDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBub2RlID0gbm9kZS5yZXR1cm47XG4gICAgfSB3aGlsZSAobm9kZSAhPT0gbnVsbCk7XG5cbiAgICB7XG4gICAgICB7XG4gICAgICAgIHRocm93IEVycm9yKCBcIkZvdW5kIHVuZXhwZWN0ZWQgZGV0YWNoZWQgc3VidHJlZSBwYXJlbnQuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCIgKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxudmFyIExlZ2FjeVJvb3QgPSAwO1xudmFyIEJsb2NraW5nUm9vdCA9IDE7XG52YXIgQ29uY3VycmVudFJvb3QgPSAyO1xuXG52YXIgcmVuZGVyZXJJRCA9IG51bGw7XG52YXIgaW5qZWN0ZWRIb29rID0gbnVsbDtcbnZhciBoYXNMb2dnZWRFcnJvciA9IGZhbHNlO1xudmFyIGlzRGV2VG9vbHNQcmVzZW50ID0gdHlwZW9mIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXyAhPT0gJ3VuZGVmaW5lZCc7XG5mdW5jdGlvbiBpbmplY3RJbnRlcm5hbHMoaW50ZXJuYWxzKSB7XG4gIGlmICh0eXBlb2YgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fID09PSAndW5kZWZpbmVkJykge1xuICAgIC8vIE5vIERldlRvb2xzXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIGhvb2sgPSBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX187XG5cbiAgaWYgKGhvb2suaXNEaXNhYmxlZCkge1xuICAgIC8vIFRoaXMgaXNuJ3QgYSByZWFsIHByb3BlcnR5IG9uIHRoZSBob29rLCBidXQgaXQgY2FuIGJlIHNldCB0byBvcHQgb3V0XG4gICAgLy8gb2YgRGV2VG9vbHMgaW50ZWdyYXRpb24gYW5kIGFzc29jaWF0ZWQgd2FybmluZ3MgYW5kIGxvZ3MuXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8zODc3XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAoIWhvb2suc3VwcG9ydHNGaWJlcikge1xuICAgIHtcbiAgICAgIGVycm9yKCdUaGUgaW5zdGFsbGVkIHZlcnNpb24gb2YgUmVhY3QgRGV2VG9vbHMgaXMgdG9vIG9sZCBhbmQgd2lsbCBub3Qgd29yayAnICsgJ3dpdGggdGhlIGN1cnJlbnQgdmVyc2lvbiBvZiBSZWFjdC4gUGxlYXNlIHVwZGF0ZSBSZWFjdCBEZXZUb29scy4gJyArICdodHRwczovL3JlYWN0anMub3JnL2xpbmsvcmVhY3QtZGV2dG9vbHMnKTtcbiAgICB9IC8vIERldlRvb2xzIGV4aXN0cywgZXZlbiB0aG91Z2ggaXQgZG9lc24ndCBzdXBwb3J0IEZpYmVyLlxuXG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHRyeSB7XG4gICAgcmVuZGVyZXJJRCA9IGhvb2suaW5qZWN0KGludGVybmFscyk7IC8vIFdlIGhhdmUgc3VjY2Vzc2Z1bGx5IGluamVjdGVkLCBzbyBub3cgaXQgaXMgc2FmZSB0byBzZXQgdXAgaG9va3MuXG5cbiAgICBpbmplY3RlZEhvb2sgPSBob29rO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICAvLyBDYXRjaCBhbGwgZXJyb3JzIGJlY2F1c2UgaXQgaXMgdW5zYWZlIHRvIHRocm93IGR1cmluZyBpbml0aWFsaXphdGlvbi5cbiAgICB7XG4gICAgICBlcnJvcignUmVhY3QgaW5zdHJ1bWVudGF0aW9uIGVuY291bnRlcmVkIGFuIGVycm9yOiAlcy4nLCBlcnIpO1xuICAgIH1cbiAgfSAvLyBEZXZUb29scyBleGlzdHNcblxuXG4gIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gb25TY2hlZHVsZVJvb3Qocm9vdCwgY2hpbGRyZW4pIHtcbiAge1xuICAgIGlmIChpbmplY3RlZEhvb2sgJiYgdHlwZW9mIGluamVjdGVkSG9vay5vblNjaGVkdWxlRmliZXJSb290ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0cnkge1xuICAgICAgICBpbmplY3RlZEhvb2sub25TY2hlZHVsZUZpYmVyUm9vdChyZW5kZXJlcklELCByb290LCBjaGlsZHJlbik7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgaWYgKCAhaGFzTG9nZ2VkRXJyb3IpIHtcbiAgICAgICAgICBoYXNMb2dnZWRFcnJvciA9IHRydWU7XG5cbiAgICAgICAgICBlcnJvcignUmVhY3QgaW5zdHJ1bWVudGF0aW9uIGVuY291bnRlcmVkIGFuIGVycm9yOiAlcycsIGVycik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIG9uQ29tbWl0Um9vdChyb290LCBwcmlvcml0eUxldmVsKSB7XG4gIGlmIChpbmplY3RlZEhvb2sgJiYgdHlwZW9mIGluamVjdGVkSG9vay5vbkNvbW1pdEZpYmVyUm9vdCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHRyeSB7XG4gICAgICB2YXIgZGlkRXJyb3IgPSAocm9vdC5jdXJyZW50LmZsYWdzICYgRGlkQ2FwdHVyZSkgPT09IERpZENhcHR1cmU7XG5cbiAgICAgIGlmIChlbmFibGVQcm9maWxlclRpbWVyKSB7XG4gICAgICAgIGluamVjdGVkSG9vay5vbkNvbW1pdEZpYmVyUm9vdChyZW5kZXJlcklELCByb290LCBwcmlvcml0eUxldmVsLCBkaWRFcnJvcik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbmplY3RlZEhvb2sub25Db21taXRGaWJlclJvb3QocmVuZGVyZXJJRCwgcm9vdCwgdW5kZWZpbmVkLCBkaWRFcnJvcik7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICB7XG4gICAgICAgIGlmICghaGFzTG9nZ2VkRXJyb3IpIHtcbiAgICAgICAgICBoYXNMb2dnZWRFcnJvciA9IHRydWU7XG5cbiAgICAgICAgICBlcnJvcignUmVhY3QgaW5zdHJ1bWVudGF0aW9uIGVuY291bnRlcmVkIGFuIGVycm9yOiAlcycsIGVycik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIG9uQ29tbWl0VW5tb3VudChmaWJlcikge1xuICBpZiAoaW5qZWN0ZWRIb29rICYmIHR5cGVvZiBpbmplY3RlZEhvb2sub25Db21taXRGaWJlclVubW91bnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICB0cnkge1xuICAgICAgaW5qZWN0ZWRIb29rLm9uQ29tbWl0RmliZXJVbm1vdW50KHJlbmRlcmVySUQsIGZpYmVyKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHtcbiAgICAgICAgaWYgKCFoYXNMb2dnZWRFcnJvcikge1xuICAgICAgICAgIGhhc0xvZ2dlZEVycm9yID0gdHJ1ZTtcblxuICAgICAgICAgIGVycm9yKCdSZWFjdCBpbnN0cnVtZW50YXRpb24gZW5jb3VudGVyZWQgYW4gZXJyb3I6ICVzJywgZXJyKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG52YXIgU2NoZWR1bGVyX3J1bldpdGhQcmlvcml0eSA9IFNjaGVkdWxlci51bnN0YWJsZV9ydW5XaXRoUHJpb3JpdHksXG4gICAgU2NoZWR1bGVyX3NjaGVkdWxlQ2FsbGJhY2sgPSBTY2hlZHVsZXIudW5zdGFibGVfc2NoZWR1bGVDYWxsYmFjayxcbiAgICBTY2hlZHVsZXJfY2FuY2VsQ2FsbGJhY2sgPSBTY2hlZHVsZXIudW5zdGFibGVfY2FuY2VsQ2FsbGJhY2ssXG4gICAgU2NoZWR1bGVyX3Nob3VsZFlpZWxkID0gU2NoZWR1bGVyLnVuc3RhYmxlX3Nob3VsZFlpZWxkLFxuICAgIFNjaGVkdWxlcl9yZXF1ZXN0UGFpbnQgPSBTY2hlZHVsZXIudW5zdGFibGVfcmVxdWVzdFBhaW50LFxuICAgIFNjaGVkdWxlcl9ub3ckMSA9IFNjaGVkdWxlci51bnN0YWJsZV9ub3csXG4gICAgU2NoZWR1bGVyX2dldEN1cnJlbnRQcmlvcml0eUxldmVsID0gU2NoZWR1bGVyLnVuc3RhYmxlX2dldEN1cnJlbnRQcmlvcml0eUxldmVsLFxuICAgIFNjaGVkdWxlcl9JbW1lZGlhdGVQcmlvcml0eSA9IFNjaGVkdWxlci51bnN0YWJsZV9JbW1lZGlhdGVQcmlvcml0eSxcbiAgICBTY2hlZHVsZXJfVXNlckJsb2NraW5nUHJpb3JpdHkgPSBTY2hlZHVsZXIudW5zdGFibGVfVXNlckJsb2NraW5nUHJpb3JpdHksXG4gICAgU2NoZWR1bGVyX05vcm1hbFByaW9yaXR5ID0gU2NoZWR1bGVyLnVuc3RhYmxlX05vcm1hbFByaW9yaXR5LFxuICAgIFNjaGVkdWxlcl9Mb3dQcmlvcml0eSA9IFNjaGVkdWxlci51bnN0YWJsZV9Mb3dQcmlvcml0eSxcbiAgICBTY2hlZHVsZXJfSWRsZVByaW9yaXR5ID0gU2NoZWR1bGVyLnVuc3RhYmxlX0lkbGVQcmlvcml0eTtcblxue1xuICAvLyBQcm92aWRlIGV4cGxpY2l0IGVycm9yIG1lc3NhZ2Ugd2hlbiBwcm9kdWN0aW9uK3Byb2ZpbGluZyBidW5kbGUgb2YgZS5nLlxuICAvLyByZWFjdC1kb20gaXMgdXNlZCB3aXRoIHByb2R1Y3Rpb24gKG5vbi1wcm9maWxpbmcpIGJ1bmRsZSBvZlxuICAvLyBzY2hlZHVsZXIvdHJhY2luZ1xuICBpZiAoISh0cmFjaW5nLl9faW50ZXJhY3Rpb25zUmVmICE9IG51bGwgJiYgdHJhY2luZy5fX2ludGVyYWN0aW9uc1JlZi5jdXJyZW50ICE9IG51bGwpKSB7XG4gICAge1xuICAgICAgdGhyb3cgRXJyb3IoIFwiSXQgaXMgbm90IHN1cHBvcnRlZCB0byBydW4gdGhlIHByb2ZpbGluZyB2ZXJzaW9uIG9mIGEgcmVuZGVyZXIgKGZvciBleGFtcGxlLCBgcmVhY3QtZG9tL3Byb2ZpbGluZ2ApIHdpdGhvdXQgYWxzbyByZXBsYWNpbmcgdGhlIGBzY2hlZHVsZXIvdHJhY2luZ2AgbW9kdWxlIHdpdGggYHNjaGVkdWxlci90cmFjaW5nLXByb2ZpbGluZ2AuIFlvdXIgYnVuZGxlciBtaWdodCBoYXZlIGEgc2V0dGluZyBmb3IgYWxpYXNpbmcgYm90aCBtb2R1bGVzLiBMZWFybiBtb3JlIGF0IGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9wcm9maWxpbmdcIiApO1xuICAgIH1cbiAgfVxufVxuXG52YXIgZmFrZUNhbGxiYWNrTm9kZSA9IHt9OyAvLyBFeGNlcHQgZm9yIE5vUHJpb3JpdHksIHRoZXNlIGNvcnJlc3BvbmQgdG8gU2NoZWR1bGVyIHByaW9yaXRpZXMuIFdlIHVzZVxuLy8gYXNjZW5kaW5nIG51bWJlcnMgc28gd2UgY2FuIGNvbXBhcmUgdGhlbSBsaWtlIG51bWJlcnMuIFRoZXkgc3RhcnQgYXQgOTAgdG9cbi8vIGF2b2lkIGNsYXNoaW5nIHdpdGggU2NoZWR1bGVyJ3MgcHJpb3JpdGllcy5cblxudmFyIEltbWVkaWF0ZVByaW9yaXR5JDEgPSA5OTtcbnZhciBVc2VyQmxvY2tpbmdQcmlvcml0eSQyID0gOTg7XG52YXIgTm9ybWFsUHJpb3JpdHkkMSA9IDk3O1xudmFyIExvd1ByaW9yaXR5JDEgPSA5NjtcbnZhciBJZGxlUHJpb3JpdHkkMSA9IDk1OyAvLyBOb1ByaW9yaXR5IGlzIHRoZSBhYnNlbmNlIG9mIHByaW9yaXR5LiBBbHNvIFJlYWN0LW9ubHkuXG5cbnZhciBOb1ByaW9yaXR5JDEgPSA5MDtcbnZhciBzaG91bGRZaWVsZCA9IFNjaGVkdWxlcl9zaG91bGRZaWVsZDtcbnZhciByZXF1ZXN0UGFpbnQgPSAvLyBGYWxsIGJhY2sgZ3JhY2VmdWxseSBpZiB3ZSdyZSBydW5uaW5nIGFuIG9sZGVyIHZlcnNpb24gb2YgU2NoZWR1bGVyLlxuU2NoZWR1bGVyX3JlcXVlc3RQYWludCAhPT0gdW5kZWZpbmVkID8gU2NoZWR1bGVyX3JlcXVlc3RQYWludCA6IGZ1bmN0aW9uICgpIHt9O1xudmFyIHN5bmNRdWV1ZSA9IG51bGw7XG52YXIgaW1tZWRpYXRlUXVldWVDYWxsYmFja05vZGUgPSBudWxsO1xudmFyIGlzRmx1c2hpbmdTeW5jUXVldWUgPSBmYWxzZTtcbnZhciBpbml0aWFsVGltZU1zJDEgPSBTY2hlZHVsZXJfbm93JDEoKTsgLy8gSWYgdGhlIGluaXRpYWwgdGltZXN0YW1wIGlzIHJlYXNvbmFibHkgc21hbGwsIHVzZSBTY2hlZHVsZXIncyBgbm93YCBkaXJlY3RseS5cbi8vIFRoaXMgd2lsbCBiZSB0aGUgY2FzZSBmb3IgbW9kZXJuIGJyb3dzZXJzIHRoYXQgc3VwcG9ydCBgcGVyZm9ybWFuY2Uubm93YC4gSW5cbi8vIG9sZGVyIGJyb3dzZXJzLCBTY2hlZHVsZXIgZmFsbHMgYmFjayB0byBgRGF0ZS5ub3dgLCB3aGljaCByZXR1cm5zIGEgVW5peFxuLy8gdGltZXN0YW1wLiBJbiB0aGF0IGNhc2UsIHN1YnRyYWN0IHRoZSBtb2R1bGUgaW5pdGlhbGl6YXRpb24gdGltZSB0byBzaW11bGF0ZVxuLy8gdGhlIGJlaGF2aW9yIG9mIHBlcmZvcm1hbmNlLm5vdyBhbmQga2VlcCBvdXIgdGltZXMgc21hbGwgZW5vdWdoIHRvIGZpdFxuLy8gd2l0aGluIDMyIGJpdHMuXG4vLyBUT0RPOiBDb25zaWRlciBsaWZ0aW5nIHRoaXMgaW50byBTY2hlZHVsZXIuXG5cbnZhciBub3cgPSBpbml0aWFsVGltZU1zJDEgPCAxMDAwMCA/IFNjaGVkdWxlcl9ub3ckMSA6IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIFNjaGVkdWxlcl9ub3ckMSgpIC0gaW5pdGlhbFRpbWVNcyQxO1xufTtcbmZ1bmN0aW9uIGdldEN1cnJlbnRQcmlvcml0eUxldmVsKCkge1xuICBzd2l0Y2ggKFNjaGVkdWxlcl9nZXRDdXJyZW50UHJpb3JpdHlMZXZlbCgpKSB7XG4gICAgY2FzZSBTY2hlZHVsZXJfSW1tZWRpYXRlUHJpb3JpdHk6XG4gICAgICByZXR1cm4gSW1tZWRpYXRlUHJpb3JpdHkkMTtcblxuICAgIGNhc2UgU2NoZWR1bGVyX1VzZXJCbG9ja2luZ1ByaW9yaXR5OlxuICAgICAgcmV0dXJuIFVzZXJCbG9ja2luZ1ByaW9yaXR5JDI7XG5cbiAgICBjYXNlIFNjaGVkdWxlcl9Ob3JtYWxQcmlvcml0eTpcbiAgICAgIHJldHVybiBOb3JtYWxQcmlvcml0eSQxO1xuXG4gICAgY2FzZSBTY2hlZHVsZXJfTG93UHJpb3JpdHk6XG4gICAgICByZXR1cm4gTG93UHJpb3JpdHkkMTtcblxuICAgIGNhc2UgU2NoZWR1bGVyX0lkbGVQcmlvcml0eTpcbiAgICAgIHJldHVybiBJZGxlUHJpb3JpdHkkMTtcblxuICAgIGRlZmF1bHQ6XG4gICAgICB7XG4gICAgICAgIHtcbiAgICAgICAgICB0aHJvdyBFcnJvciggXCJVbmtub3duIHByaW9yaXR5IGxldmVsLlwiICk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICB9XG59XG5cbmZ1bmN0aW9uIHJlYWN0UHJpb3JpdHlUb1NjaGVkdWxlclByaW9yaXR5KHJlYWN0UHJpb3JpdHlMZXZlbCkge1xuICBzd2l0Y2ggKHJlYWN0UHJpb3JpdHlMZXZlbCkge1xuICAgIGNhc2UgSW1tZWRpYXRlUHJpb3JpdHkkMTpcbiAgICAgIHJldHVybiBTY2hlZHVsZXJfSW1tZWRpYXRlUHJpb3JpdHk7XG5cbiAgICBjYXNlIFVzZXJCbG9ja2luZ1ByaW9yaXR5JDI6XG4gICAgICByZXR1cm4gU2NoZWR1bGVyX1VzZXJCbG9ja2luZ1ByaW9yaXR5O1xuXG4gICAgY2FzZSBOb3JtYWxQcmlvcml0eSQxOlxuICAgICAgcmV0dXJuIFNjaGVkdWxlcl9Ob3JtYWxQcmlvcml0eTtcblxuICAgIGNhc2UgTG93UHJpb3JpdHkkMTpcbiAgICAgIHJldHVybiBTY2hlZHVsZXJfTG93UHJpb3JpdHk7XG5cbiAgICBjYXNlIElkbGVQcmlvcml0eSQxOlxuICAgICAgcmV0dXJuIFNjaGVkdWxlcl9JZGxlUHJpb3JpdHk7XG5cbiAgICBkZWZhdWx0OlxuICAgICAge1xuICAgICAgICB7XG4gICAgICAgICAgdGhyb3cgRXJyb3IoIFwiVW5rbm93biBwcmlvcml0eSBsZXZlbC5cIiApO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgfVxufVxuXG5mdW5jdGlvbiBydW5XaXRoUHJpb3JpdHkkMShyZWFjdFByaW9yaXR5TGV2ZWwsIGZuKSB7XG4gIHZhciBwcmlvcml0eUxldmVsID0gcmVhY3RQcmlvcml0eVRvU2NoZWR1bGVyUHJpb3JpdHkocmVhY3RQcmlvcml0eUxldmVsKTtcbiAgcmV0dXJuIFNjaGVkdWxlcl9ydW5XaXRoUHJpb3JpdHkocHJpb3JpdHlMZXZlbCwgZm4pO1xufVxuZnVuY3Rpb24gc2NoZWR1bGVDYWxsYmFjayhyZWFjdFByaW9yaXR5TGV2ZWwsIGNhbGxiYWNrLCBvcHRpb25zKSB7XG4gIHZhciBwcmlvcml0eUxldmVsID0gcmVhY3RQcmlvcml0eVRvU2NoZWR1bGVyUHJpb3JpdHkocmVhY3RQcmlvcml0eUxldmVsKTtcbiAgcmV0dXJuIFNjaGVkdWxlcl9zY2hlZHVsZUNhbGxiYWNrKHByaW9yaXR5TGV2ZWwsIGNhbGxiYWNrLCBvcHRpb25zKTtcbn1cbmZ1bmN0aW9uIHNjaGVkdWxlU3luY0NhbGxiYWNrKGNhbGxiYWNrKSB7XG4gIC8vIFB1c2ggdGhpcyBjYWxsYmFjayBpbnRvIGFuIGludGVybmFsIHF1ZXVlLiBXZSdsbCBmbHVzaCB0aGVzZSBlaXRoZXIgaW5cbiAgLy8gdGhlIG5leHQgdGljaywgb3IgZWFybGllciBpZiBzb21ldGhpbmcgY2FsbHMgYGZsdXNoU3luY0NhbGxiYWNrUXVldWVgLlxuICBpZiAoc3luY1F1ZXVlID09PSBudWxsKSB7XG4gICAgc3luY1F1ZXVlID0gW2NhbGxiYWNrXTsgLy8gRmx1c2ggdGhlIHF1ZXVlIGluIHRoZSBuZXh0IHRpY2ssIGF0IHRoZSBlYXJsaWVzdC5cblxuICAgIGltbWVkaWF0ZVF1ZXVlQ2FsbGJhY2tOb2RlID0gU2NoZWR1bGVyX3NjaGVkdWxlQ2FsbGJhY2soU2NoZWR1bGVyX0ltbWVkaWF0ZVByaW9yaXR5LCBmbHVzaFN5bmNDYWxsYmFja1F1ZXVlSW1wbCk7XG4gIH0gZWxzZSB7XG4gICAgLy8gUHVzaCBvbnRvIGV4aXN0aW5nIHF1ZXVlLiBEb24ndCBuZWVkIHRvIHNjaGVkdWxlIGEgY2FsbGJhY2sgYmVjYXVzZVxuICAgIC8vIHdlIGFscmVhZHkgc2NoZWR1bGVkIG9uZSB3aGVuIHdlIGNyZWF0ZWQgdGhlIHF1ZXVlLlxuICAgIHN5bmNRdWV1ZS5wdXNoKGNhbGxiYWNrKTtcbiAgfVxuXG4gIHJldHVybiBmYWtlQ2FsbGJhY2tOb2RlO1xufVxuZnVuY3Rpb24gY2FuY2VsQ2FsbGJhY2soY2FsbGJhY2tOb2RlKSB7XG4gIGlmIChjYWxsYmFja05vZGUgIT09IGZha2VDYWxsYmFja05vZGUpIHtcbiAgICBTY2hlZHVsZXJfY2FuY2VsQ2FsbGJhY2soY2FsbGJhY2tOb2RlKTtcbiAgfVxufVxuZnVuY3Rpb24gZmx1c2hTeW5jQ2FsbGJhY2tRdWV1ZSgpIHtcbiAgaWYgKGltbWVkaWF0ZVF1ZXVlQ2FsbGJhY2tOb2RlICE9PSBudWxsKSB7XG4gICAgdmFyIG5vZGUgPSBpbW1lZGlhdGVRdWV1ZUNhbGxiYWNrTm9kZTtcbiAgICBpbW1lZGlhdGVRdWV1ZUNhbGxiYWNrTm9kZSA9IG51bGw7XG4gICAgU2NoZWR1bGVyX2NhbmNlbENhbGxiYWNrKG5vZGUpO1xuICB9XG5cbiAgZmx1c2hTeW5jQ2FsbGJhY2tRdWV1ZUltcGwoKTtcbn1cblxuZnVuY3Rpb24gZmx1c2hTeW5jQ2FsbGJhY2tRdWV1ZUltcGwoKSB7XG4gIGlmICghaXNGbHVzaGluZ1N5bmNRdWV1ZSAmJiBzeW5jUXVldWUgIT09IG51bGwpIHtcbiAgICAvLyBQcmV2ZW50IHJlLWVudHJhbmN5LlxuICAgIGlzRmx1c2hpbmdTeW5jUXVldWUgPSB0cnVlO1xuICAgIHZhciBpID0gMDtcblxuICAgIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciBfaXNTeW5jMiA9IHRydWU7XG4gICAgICAgIHZhciBfcXVldWUgPSBzeW5jUXVldWU7XG4gICAgICAgIHJ1bldpdGhQcmlvcml0eSQxKEltbWVkaWF0ZVByaW9yaXR5JDEsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBmb3IgKDsgaSA8IF9xdWV1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGNhbGxiYWNrID0gX3F1ZXVlW2ldO1xuXG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgIGNhbGxiYWNrID0gY2FsbGJhY2soX2lzU3luYzIpO1xuICAgICAgICAgICAgfSB3aGlsZSAoY2FsbGJhY2sgIT09IG51bGwpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHN5bmNRdWV1ZSA9IG51bGw7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAvLyBJZiBzb21ldGhpbmcgdGhyb3dzLCBsZWF2ZSB0aGUgcmVtYWluaW5nIGNhbGxiYWNrcyBvbiB0aGUgcXVldWUuXG4gICAgICAgIGlmIChzeW5jUXVldWUgIT09IG51bGwpIHtcbiAgICAgICAgICBzeW5jUXVldWUgPSBzeW5jUXVldWUuc2xpY2UoaSArIDEpO1xuICAgICAgICB9IC8vIFJlc3VtZSBmbHVzaGluZyBpbiB0aGUgbmV4dCB0aWNrXG5cblxuICAgICAgICBTY2hlZHVsZXJfc2NoZWR1bGVDYWxsYmFjayhTY2hlZHVsZXJfSW1tZWRpYXRlUHJpb3JpdHksIGZsdXNoU3luY0NhbGxiYWNrUXVldWUpO1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGlzRmx1c2hpbmdTeW5jUXVldWUgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLy8gVE9ETzogdGhpcyBpcyBzcGVjaWFsIGJlY2F1c2UgaXQgZ2V0cyBpbXBvcnRlZCBkdXJpbmcgYnVpbGQuXG52YXIgUmVhY3RWZXJzaW9uID0gJzE3LjAuMic7XG5cbnZhciBOb01vZGUgPSAwO1xudmFyIFN0cmljdE1vZGUgPSAxOyAvLyBUT0RPOiBSZW1vdmUgQmxvY2tpbmdNb2RlIGFuZCBDb25jdXJyZW50TW9kZSBieSByZWFkaW5nIGZyb20gdGhlIHJvb3Rcbi8vIHRhZyBpbnN0ZWFkXG5cbnZhciBCbG9ja2luZ01vZGUgPSAyO1xudmFyIENvbmN1cnJlbnRNb2RlID0gNDtcbnZhciBQcm9maWxlTW9kZSA9IDg7XG52YXIgRGVidWdUcmFjaW5nTW9kZSA9IDE2O1xuXG52YXIgUmVhY3RDdXJyZW50QmF0Y2hDb25maWcgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdEN1cnJlbnRCYXRjaENvbmZpZztcbnZhciBOb1RyYW5zaXRpb24gPSAwO1xuZnVuY3Rpb24gcmVxdWVzdEN1cnJlbnRUcmFuc2l0aW9uKCkge1xuICByZXR1cm4gUmVhY3RDdXJyZW50QmF0Y2hDb25maWcudHJhbnNpdGlvbjtcbn1cblxudmFyIFJlYWN0U3RyaWN0TW9kZVdhcm5pbmdzID0ge1xuICByZWNvcmRVbnNhZmVMaWZlY3ljbGVXYXJuaW5nczogZnVuY3Rpb24gKGZpYmVyLCBpbnN0YW5jZSkge30sXG4gIGZsdXNoUGVuZGluZ1Vuc2FmZUxpZmVjeWNsZVdhcm5pbmdzOiBmdW5jdGlvbiAoKSB7fSxcbiAgcmVjb3JkTGVnYWN5Q29udGV4dFdhcm5pbmc6IGZ1bmN0aW9uIChmaWJlciwgaW5zdGFuY2UpIHt9LFxuICBmbHVzaExlZ2FjeUNvbnRleHRXYXJuaW5nOiBmdW5jdGlvbiAoKSB7fSxcbiAgZGlzY2FyZFBlbmRpbmdXYXJuaW5nczogZnVuY3Rpb24gKCkge31cbn07XG5cbntcbiAgdmFyIGZpbmRTdHJpY3RSb290ID0gZnVuY3Rpb24gKGZpYmVyKSB7XG4gICAgdmFyIG1heWJlU3RyaWN0Um9vdCA9IG51bGw7XG4gICAgdmFyIG5vZGUgPSBmaWJlcjtcblxuICAgIHdoaWxlIChub2RlICE9PSBudWxsKSB7XG4gICAgICBpZiAobm9kZS5tb2RlICYgU3RyaWN0TW9kZSkge1xuICAgICAgICBtYXliZVN0cmljdFJvb3QgPSBub2RlO1xuICAgICAgfVxuXG4gICAgICBub2RlID0gbm9kZS5yZXR1cm47XG4gICAgfVxuXG4gICAgcmV0dXJuIG1heWJlU3RyaWN0Um9vdDtcbiAgfTtcblxuICB2YXIgc2V0VG9Tb3J0ZWRTdHJpbmcgPSBmdW5jdGlvbiAoc2V0KSB7XG4gICAgdmFyIGFycmF5ID0gW107XG4gICAgc2V0LmZvckVhY2goZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICBhcnJheS5wdXNoKHZhbHVlKTtcbiAgICB9KTtcbiAgICByZXR1cm4gYXJyYXkuc29ydCgpLmpvaW4oJywgJyk7XG4gIH07XG5cbiAgdmFyIHBlbmRpbmdDb21wb25lbnRXaWxsTW91bnRXYXJuaW5ncyA9IFtdO1xuICB2YXIgcGVuZGluZ1VOU0FGRV9Db21wb25lbnRXaWxsTW91bnRXYXJuaW5ncyA9IFtdO1xuICB2YXIgcGVuZGluZ0NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNXYXJuaW5ncyA9IFtdO1xuICB2YXIgcGVuZGluZ1VOU0FGRV9Db21wb25lbnRXaWxsUmVjZWl2ZVByb3BzV2FybmluZ3MgPSBbXTtcbiAgdmFyIHBlbmRpbmdDb21wb25lbnRXaWxsVXBkYXRlV2FybmluZ3MgPSBbXTtcbiAgdmFyIHBlbmRpbmdVTlNBRkVfQ29tcG9uZW50V2lsbFVwZGF0ZVdhcm5pbmdzID0gW107IC8vIFRyYWNrcyBjb21wb25lbnRzIHdlIGhhdmUgYWxyZWFkeSB3YXJuZWQgYWJvdXQuXG5cbiAgdmFyIGRpZFdhcm5BYm91dFVuc2FmZUxpZmVjeWNsZXMgPSBuZXcgU2V0KCk7XG5cbiAgUmVhY3RTdHJpY3RNb2RlV2FybmluZ3MucmVjb3JkVW5zYWZlTGlmZWN5Y2xlV2FybmluZ3MgPSBmdW5jdGlvbiAoZmliZXIsIGluc3RhbmNlKSB7XG4gICAgLy8gRGVkdXAgc3RyYXRlZ3k6IFdhcm4gb25jZSBwZXIgY29tcG9uZW50LlxuICAgIGlmIChkaWRXYXJuQWJvdXRVbnNhZmVMaWZlY3ljbGVzLmhhcyhmaWJlci50eXBlKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50V2lsbE1vdW50ID09PSAnZnVuY3Rpb24nICYmIC8vIERvbid0IHdhcm4gYWJvdXQgcmVhY3QtbGlmZWN5Y2xlcy1jb21wYXQgcG9seWZpbGxlZCBjb21wb25lbnRzLlxuICAgIGluc3RhbmNlLmNvbXBvbmVudFdpbGxNb3VudC5fX3N1cHByZXNzRGVwcmVjYXRpb25XYXJuaW5nICE9PSB0cnVlKSB7XG4gICAgICBwZW5kaW5nQ29tcG9uZW50V2lsbE1vdW50V2FybmluZ3MucHVzaChmaWJlcik7XG4gICAgfVxuXG4gICAgaWYgKGZpYmVyLm1vZGUgJiBTdHJpY3RNb2RlICYmIHR5cGVvZiBpbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbE1vdW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBwZW5kaW5nVU5TQUZFX0NvbXBvbmVudFdpbGxNb3VudFdhcm5pbmdzLnB1c2goZmliZXIpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyA9PT0gJ2Z1bmN0aW9uJyAmJiBpbnN0YW5jZS5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzLl9fc3VwcHJlc3NEZXByZWNhdGlvbldhcm5pbmcgIT09IHRydWUpIHtcbiAgICAgIHBlbmRpbmdDb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzV2FybmluZ3MucHVzaChmaWJlcik7XG4gICAgfVxuXG4gICAgaWYgKGZpYmVyLm1vZGUgJiBTdHJpY3RNb2RlICYmIHR5cGVvZiBpbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcGVuZGluZ1VOU0FGRV9Db21wb25lbnRXaWxsUmVjZWl2ZVByb3BzV2FybmluZ3MucHVzaChmaWJlcik7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnRXaWxsVXBkYXRlID09PSAnZnVuY3Rpb24nICYmIGluc3RhbmNlLmNvbXBvbmVudFdpbGxVcGRhdGUuX19zdXBwcmVzc0RlcHJlY2F0aW9uV2FybmluZyAhPT0gdHJ1ZSkge1xuICAgICAgcGVuZGluZ0NvbXBvbmVudFdpbGxVcGRhdGVXYXJuaW5ncy5wdXNoKGZpYmVyKTtcbiAgICB9XG5cbiAgICBpZiAoZmliZXIubW9kZSAmIFN0cmljdE1vZGUgJiYgdHlwZW9mIGluc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsVXBkYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBwZW5kaW5nVU5TQUZFX0NvbXBvbmVudFdpbGxVcGRhdGVXYXJuaW5ncy5wdXNoKGZpYmVyKTtcbiAgICB9XG4gIH07XG5cbiAgUmVhY3RTdHJpY3RNb2RlV2FybmluZ3MuZmx1c2hQZW5kaW5nVW5zYWZlTGlmZWN5Y2xlV2FybmluZ3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgLy8gV2UgZG8gYW4gaW5pdGlhbCBwYXNzIHRvIGdhdGhlciBjb21wb25lbnQgbmFtZXNcbiAgICB2YXIgY29tcG9uZW50V2lsbE1vdW50VW5pcXVlTmFtZXMgPSBuZXcgU2V0KCk7XG5cbiAgICBpZiAocGVuZGluZ0NvbXBvbmVudFdpbGxNb3VudFdhcm5pbmdzLmxlbmd0aCA+IDApIHtcbiAgICAgIHBlbmRpbmdDb21wb25lbnRXaWxsTW91bnRXYXJuaW5ncy5mb3JFYWNoKGZ1bmN0aW9uIChmaWJlcikge1xuICAgICAgICBjb21wb25lbnRXaWxsTW91bnRVbmlxdWVOYW1lcy5hZGQoZ2V0Q29tcG9uZW50TmFtZShmaWJlci50eXBlKSB8fCAnQ29tcG9uZW50Jyk7XG4gICAgICAgIGRpZFdhcm5BYm91dFVuc2FmZUxpZmVjeWNsZXMuYWRkKGZpYmVyLnR5cGUpO1xuICAgICAgfSk7XG4gICAgICBwZW5kaW5nQ29tcG9uZW50V2lsbE1vdW50V2FybmluZ3MgPSBbXTtcbiAgICB9XG5cbiAgICB2YXIgVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudFVuaXF1ZU5hbWVzID0gbmV3IFNldCgpO1xuXG4gICAgaWYgKHBlbmRpbmdVTlNBRkVfQ29tcG9uZW50V2lsbE1vdW50V2FybmluZ3MubGVuZ3RoID4gMCkge1xuICAgICAgcGVuZGluZ1VOU0FGRV9Db21wb25lbnRXaWxsTW91bnRXYXJuaW5ncy5mb3JFYWNoKGZ1bmN0aW9uIChmaWJlcikge1xuICAgICAgICBVTlNBRkVfY29tcG9uZW50V2lsbE1vdW50VW5pcXVlTmFtZXMuYWRkKGdldENvbXBvbmVudE5hbWUoZmliZXIudHlwZSkgfHwgJ0NvbXBvbmVudCcpO1xuICAgICAgICBkaWRXYXJuQWJvdXRVbnNhZmVMaWZlY3ljbGVzLmFkZChmaWJlci50eXBlKTtcbiAgICAgIH0pO1xuICAgICAgcGVuZGluZ1VOU0FGRV9Db21wb25lbnRXaWxsTW91bnRXYXJuaW5ncyA9IFtdO1xuICAgIH1cblxuICAgIHZhciBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzVW5pcXVlTmFtZXMgPSBuZXcgU2V0KCk7XG5cbiAgICBpZiAocGVuZGluZ0NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNXYXJuaW5ncy5sZW5ndGggPiAwKSB7XG4gICAgICBwZW5kaW5nQ29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc1dhcm5pbmdzLmZvckVhY2goZnVuY3Rpb24gKGZpYmVyKSB7XG4gICAgICAgIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNVbmlxdWVOYW1lcy5hZGQoZ2V0Q29tcG9uZW50TmFtZShmaWJlci50eXBlKSB8fCAnQ29tcG9uZW50Jyk7XG4gICAgICAgIGRpZFdhcm5BYm91dFVuc2FmZUxpZmVjeWNsZXMuYWRkKGZpYmVyLnR5cGUpO1xuICAgICAgfSk7XG4gICAgICBwZW5kaW5nQ29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc1dhcm5pbmdzID0gW107XG4gICAgfVxuXG4gICAgdmFyIFVOU0FGRV9jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzVW5pcXVlTmFtZXMgPSBuZXcgU2V0KCk7XG5cbiAgICBpZiAocGVuZGluZ1VOU0FGRV9Db21wb25lbnRXaWxsUmVjZWl2ZVByb3BzV2FybmluZ3MubGVuZ3RoID4gMCkge1xuICAgICAgcGVuZGluZ1VOU0FGRV9Db21wb25lbnRXaWxsUmVjZWl2ZVByb3BzV2FybmluZ3MuZm9yRWFjaChmdW5jdGlvbiAoZmliZXIpIHtcbiAgICAgICAgVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNVbmlxdWVOYW1lcy5hZGQoZ2V0Q29tcG9uZW50TmFtZShmaWJlci50eXBlKSB8fCAnQ29tcG9uZW50Jyk7XG4gICAgICAgIGRpZFdhcm5BYm91dFVuc2FmZUxpZmVjeWNsZXMuYWRkKGZpYmVyLnR5cGUpO1xuICAgICAgfSk7XG4gICAgICBwZW5kaW5nVU5TQUZFX0NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNXYXJuaW5ncyA9IFtdO1xuICAgIH1cblxuICAgIHZhciBjb21wb25lbnRXaWxsVXBkYXRlVW5pcXVlTmFtZXMgPSBuZXcgU2V0KCk7XG5cbiAgICBpZiAocGVuZGluZ0NvbXBvbmVudFdpbGxVcGRhdGVXYXJuaW5ncy5sZW5ndGggPiAwKSB7XG4gICAgICBwZW5kaW5nQ29tcG9uZW50V2lsbFVwZGF0ZVdhcm5pbmdzLmZvckVhY2goZnVuY3Rpb24gKGZpYmVyKSB7XG4gICAgICAgIGNvbXBvbmVudFdpbGxVcGRhdGVVbmlxdWVOYW1lcy5hZGQoZ2V0Q29tcG9uZW50TmFtZShmaWJlci50eXBlKSB8fCAnQ29tcG9uZW50Jyk7XG4gICAgICAgIGRpZFdhcm5BYm91dFVuc2FmZUxpZmVjeWNsZXMuYWRkKGZpYmVyLnR5cGUpO1xuICAgICAgfSk7XG4gICAgICBwZW5kaW5nQ29tcG9uZW50V2lsbFVwZGF0ZVdhcm5pbmdzID0gW107XG4gICAgfVxuXG4gICAgdmFyIFVOU0FGRV9jb21wb25lbnRXaWxsVXBkYXRlVW5pcXVlTmFtZXMgPSBuZXcgU2V0KCk7XG5cbiAgICBpZiAocGVuZGluZ1VOU0FGRV9Db21wb25lbnRXaWxsVXBkYXRlV2FybmluZ3MubGVuZ3RoID4gMCkge1xuICAgICAgcGVuZGluZ1VOU0FGRV9Db21wb25lbnRXaWxsVXBkYXRlV2FybmluZ3MuZm9yRWFjaChmdW5jdGlvbiAoZmliZXIpIHtcbiAgICAgICAgVU5TQUZFX2NvbXBvbmVudFdpbGxVcGRhdGVVbmlxdWVOYW1lcy5hZGQoZ2V0Q29tcG9uZW50TmFtZShmaWJlci50eXBlKSB8fCAnQ29tcG9uZW50Jyk7XG4gICAgICAgIGRpZFdhcm5BYm91dFVuc2FmZUxpZmVjeWNsZXMuYWRkKGZpYmVyLnR5cGUpO1xuICAgICAgfSk7XG4gICAgICBwZW5kaW5nVU5TQUZFX0NvbXBvbmVudFdpbGxVcGRhdGVXYXJuaW5ncyA9IFtdO1xuICAgIH0gLy8gRmluYWxseSwgd2UgZmx1c2ggYWxsIHRoZSB3YXJuaW5nc1xuICAgIC8vIFVOU0FGRV8gb25lcyBiZWZvcmUgdGhlIGRlcHJlY2F0ZWQgb25lcywgc2luY2UgdGhleSdsbCBiZSAnbG91ZGVyJ1xuXG5cbiAgICBpZiAoVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudFVuaXF1ZU5hbWVzLnNpemUgPiAwKSB7XG4gICAgICB2YXIgc29ydGVkTmFtZXMgPSBzZXRUb1NvcnRlZFN0cmluZyhVTlNBRkVfY29tcG9uZW50V2lsbE1vdW50VW5pcXVlTmFtZXMpO1xuXG4gICAgICBlcnJvcignVXNpbmcgVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudCBpbiBzdHJpY3QgbW9kZSBpcyBub3QgcmVjb21tZW5kZWQgYW5kIG1heSBpbmRpY2F0ZSBidWdzIGluIHlvdXIgY29kZS4gJyArICdTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3Vuc2FmZS1jb21wb25lbnQtbGlmZWN5Y2xlcyBmb3IgZGV0YWlscy5cXG5cXG4nICsgJyogTW92ZSBjb2RlIHdpdGggc2lkZSBlZmZlY3RzIHRvIGNvbXBvbmVudERpZE1vdW50LCBhbmQgc2V0IGluaXRpYWwgc3RhdGUgaW4gdGhlIGNvbnN0cnVjdG9yLlxcbicgKyAnXFxuUGxlYXNlIHVwZGF0ZSB0aGUgZm9sbG93aW5nIGNvbXBvbmVudHM6ICVzJywgc29ydGVkTmFtZXMpO1xuICAgIH1cblxuICAgIGlmIChVTlNBRkVfY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc1VuaXF1ZU5hbWVzLnNpemUgPiAwKSB7XG4gICAgICB2YXIgX3NvcnRlZE5hbWVzID0gc2V0VG9Tb3J0ZWRTdHJpbmcoVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNVbmlxdWVOYW1lcyk7XG5cbiAgICAgIGVycm9yKCdVc2luZyBVTlNBRkVfY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyBpbiBzdHJpY3QgbW9kZSBpcyBub3QgcmVjb21tZW5kZWQgJyArICdhbmQgbWF5IGluZGljYXRlIGJ1Z3MgaW4geW91ciBjb2RlLiAnICsgJ1NlZSBodHRwczovL3JlYWN0anMub3JnL2xpbmsvdW5zYWZlLWNvbXBvbmVudC1saWZlY3ljbGVzIGZvciBkZXRhaWxzLlxcblxcbicgKyAnKiBNb3ZlIGRhdGEgZmV0Y2hpbmcgY29kZSBvciBzaWRlIGVmZmVjdHMgdG8gY29tcG9uZW50RGlkVXBkYXRlLlxcbicgKyBcIiogSWYgeW91J3JlIHVwZGF0aW5nIHN0YXRlIHdoZW5ldmVyIHByb3BzIGNoYW5nZSwgXCIgKyAncmVmYWN0b3IgeW91ciBjb2RlIHRvIHVzZSBtZW1vaXphdGlvbiB0ZWNobmlxdWVzIG9yIG1vdmUgaXQgdG8gJyArICdzdGF0aWMgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzLiBMZWFybiBtb3JlIGF0OiBodHRwczovL3JlYWN0anMub3JnL2xpbmsvZGVyaXZlZC1zdGF0ZVxcbicgKyAnXFxuUGxlYXNlIHVwZGF0ZSB0aGUgZm9sbG93aW5nIGNvbXBvbmVudHM6ICVzJywgX3NvcnRlZE5hbWVzKTtcbiAgICB9XG5cbiAgICBpZiAoVU5TQUZFX2NvbXBvbmVudFdpbGxVcGRhdGVVbmlxdWVOYW1lcy5zaXplID4gMCkge1xuICAgICAgdmFyIF9zb3J0ZWROYW1lczIgPSBzZXRUb1NvcnRlZFN0cmluZyhVTlNBRkVfY29tcG9uZW50V2lsbFVwZGF0ZVVuaXF1ZU5hbWVzKTtcblxuICAgICAgZXJyb3IoJ1VzaW5nIFVOU0FGRV9jb21wb25lbnRXaWxsVXBkYXRlIGluIHN0cmljdCBtb2RlIGlzIG5vdCByZWNvbW1lbmRlZCAnICsgJ2FuZCBtYXkgaW5kaWNhdGUgYnVncyBpbiB5b3VyIGNvZGUuICcgKyAnU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay91bnNhZmUtY29tcG9uZW50LWxpZmVjeWNsZXMgZm9yIGRldGFpbHMuXFxuXFxuJyArICcqIE1vdmUgZGF0YSBmZXRjaGluZyBjb2RlIG9yIHNpZGUgZWZmZWN0cyB0byBjb21wb25lbnREaWRVcGRhdGUuXFxuJyArICdcXG5QbGVhc2UgdXBkYXRlIHRoZSBmb2xsb3dpbmcgY29tcG9uZW50czogJXMnLCBfc29ydGVkTmFtZXMyKTtcbiAgICB9XG5cbiAgICBpZiAoY29tcG9uZW50V2lsbE1vdW50VW5pcXVlTmFtZXMuc2l6ZSA+IDApIHtcbiAgICAgIHZhciBfc29ydGVkTmFtZXMzID0gc2V0VG9Tb3J0ZWRTdHJpbmcoY29tcG9uZW50V2lsbE1vdW50VW5pcXVlTmFtZXMpO1xuXG4gICAgICB3YXJuKCdjb21wb25lbnRXaWxsTW91bnQgaGFzIGJlZW4gcmVuYW1lZCwgYW5kIGlzIG5vdCByZWNvbW1lbmRlZCBmb3IgdXNlLiAnICsgJ1NlZSBodHRwczovL3JlYWN0anMub3JnL2xpbmsvdW5zYWZlLWNvbXBvbmVudC1saWZlY3ljbGVzIGZvciBkZXRhaWxzLlxcblxcbicgKyAnKiBNb3ZlIGNvZGUgd2l0aCBzaWRlIGVmZmVjdHMgdG8gY29tcG9uZW50RGlkTW91bnQsIGFuZCBzZXQgaW5pdGlhbCBzdGF0ZSBpbiB0aGUgY29uc3RydWN0b3IuXFxuJyArICcqIFJlbmFtZSBjb21wb25lbnRXaWxsTW91bnQgdG8gVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudCB0byBzdXBwcmVzcyAnICsgJ3RoaXMgd2FybmluZyBpbiBub24tc3RyaWN0IG1vZGUuIEluIFJlYWN0IDE4LngsIG9ubHkgdGhlIFVOU0FGRV8gbmFtZSB3aWxsIHdvcmsuICcgKyAnVG8gcmVuYW1lIGFsbCBkZXByZWNhdGVkIGxpZmVjeWNsZXMgdG8gdGhlaXIgbmV3IG5hbWVzLCB5b3UgY2FuIHJ1biAnICsgJ2BucHggcmVhY3QtY29kZW1vZCByZW5hbWUtdW5zYWZlLWxpZmVjeWNsZXNgIGluIHlvdXIgcHJvamVjdCBzb3VyY2UgZm9sZGVyLlxcbicgKyAnXFxuUGxlYXNlIHVwZGF0ZSB0aGUgZm9sbG93aW5nIGNvbXBvbmVudHM6ICVzJywgX3NvcnRlZE5hbWVzMyk7XG4gICAgfVxuXG4gICAgaWYgKGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNVbmlxdWVOYW1lcy5zaXplID4gMCkge1xuICAgICAgdmFyIF9zb3J0ZWROYW1lczQgPSBzZXRUb1NvcnRlZFN0cmluZyhjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzVW5pcXVlTmFtZXMpO1xuXG4gICAgICB3YXJuKCdjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzIGhhcyBiZWVuIHJlbmFtZWQsIGFuZCBpcyBub3QgcmVjb21tZW5kZWQgZm9yIHVzZS4gJyArICdTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3Vuc2FmZS1jb21wb25lbnQtbGlmZWN5Y2xlcyBmb3IgZGV0YWlscy5cXG5cXG4nICsgJyogTW92ZSBkYXRhIGZldGNoaW5nIGNvZGUgb3Igc2lkZSBlZmZlY3RzIHRvIGNvbXBvbmVudERpZFVwZGF0ZS5cXG4nICsgXCIqIElmIHlvdSdyZSB1cGRhdGluZyBzdGF0ZSB3aGVuZXZlciBwcm9wcyBjaGFuZ2UsIHJlZmFjdG9yIHlvdXIgXCIgKyAnY29kZSB0byB1c2UgbWVtb2l6YXRpb24gdGVjaG5pcXVlcyBvciBtb3ZlIGl0IHRvICcgKyAnc3RhdGljIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcy4gTGVhcm4gbW9yZSBhdDogaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL2Rlcml2ZWQtc3RhdGVcXG4nICsgJyogUmVuYW1lIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgdG8gVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgdG8gc3VwcHJlc3MgJyArICd0aGlzIHdhcm5pbmcgaW4gbm9uLXN0cmljdCBtb2RlLiBJbiBSZWFjdCAxOC54LCBvbmx5IHRoZSBVTlNBRkVfIG5hbWUgd2lsbCB3b3JrLiAnICsgJ1RvIHJlbmFtZSBhbGwgZGVwcmVjYXRlZCBsaWZlY3ljbGVzIHRvIHRoZWlyIG5ldyBuYW1lcywgeW91IGNhbiBydW4gJyArICdgbnB4IHJlYWN0LWNvZGVtb2QgcmVuYW1lLXVuc2FmZS1saWZlY3ljbGVzYCBpbiB5b3VyIHByb2plY3Qgc291cmNlIGZvbGRlci5cXG4nICsgJ1xcblBsZWFzZSB1cGRhdGUgdGhlIGZvbGxvd2luZyBjb21wb25lbnRzOiAlcycsIF9zb3J0ZWROYW1lczQpO1xuICAgIH1cblxuICAgIGlmIChjb21wb25lbnRXaWxsVXBkYXRlVW5pcXVlTmFtZXMuc2l6ZSA+IDApIHtcbiAgICAgIHZhciBfc29ydGVkTmFtZXM1ID0gc2V0VG9Tb3J0ZWRTdHJpbmcoY29tcG9uZW50V2lsbFVwZGF0ZVVuaXF1ZU5hbWVzKTtcblxuICAgICAgd2FybignY29tcG9uZW50V2lsbFVwZGF0ZSBoYXMgYmVlbiByZW5hbWVkLCBhbmQgaXMgbm90IHJlY29tbWVuZGVkIGZvciB1c2UuICcgKyAnU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay91bnNhZmUtY29tcG9uZW50LWxpZmVjeWNsZXMgZm9yIGRldGFpbHMuXFxuXFxuJyArICcqIE1vdmUgZGF0YSBmZXRjaGluZyBjb2RlIG9yIHNpZGUgZWZmZWN0cyB0byBjb21wb25lbnREaWRVcGRhdGUuXFxuJyArICcqIFJlbmFtZSBjb21wb25lbnRXaWxsVXBkYXRlIHRvIFVOU0FGRV9jb21wb25lbnRXaWxsVXBkYXRlIHRvIHN1cHByZXNzICcgKyAndGhpcyB3YXJuaW5nIGluIG5vbi1zdHJpY3QgbW9kZS4gSW4gUmVhY3QgMTgueCwgb25seSB0aGUgVU5TQUZFXyBuYW1lIHdpbGwgd29yay4gJyArICdUbyByZW5hbWUgYWxsIGRlcHJlY2F0ZWQgbGlmZWN5Y2xlcyB0byB0aGVpciBuZXcgbmFtZXMsIHlvdSBjYW4gcnVuICcgKyAnYG5weCByZWFjdC1jb2RlbW9kIHJlbmFtZS11bnNhZmUtbGlmZWN5Y2xlc2AgaW4geW91ciBwcm9qZWN0IHNvdXJjZSBmb2xkZXIuXFxuJyArICdcXG5QbGVhc2UgdXBkYXRlIHRoZSBmb2xsb3dpbmcgY29tcG9uZW50czogJXMnLCBfc29ydGVkTmFtZXM1KTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIHBlbmRpbmdMZWdhY3lDb250ZXh0V2FybmluZyA9IG5ldyBNYXAoKTsgLy8gVHJhY2tzIGNvbXBvbmVudHMgd2UgaGF2ZSBhbHJlYWR5IHdhcm5lZCBhYm91dC5cblxuICB2YXIgZGlkV2FybkFib3V0TGVnYWN5Q29udGV4dCA9IG5ldyBTZXQoKTtcblxuICBSZWFjdFN0cmljdE1vZGVXYXJuaW5ncy5yZWNvcmRMZWdhY3lDb250ZXh0V2FybmluZyA9IGZ1bmN0aW9uIChmaWJlciwgaW5zdGFuY2UpIHtcbiAgICB2YXIgc3RyaWN0Um9vdCA9IGZpbmRTdHJpY3RSb290KGZpYmVyKTtcblxuICAgIGlmIChzdHJpY3RSb290ID09PSBudWxsKSB7XG4gICAgICBlcnJvcignRXhwZWN0ZWQgdG8gZmluZCBhIFN0cmljdE1vZGUgY29tcG9uZW50IGluIGEgc3RyaWN0IG1vZGUgdHJlZS4gJyArICdUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuXG4gICAgICByZXR1cm47XG4gICAgfSAvLyBEZWR1cCBzdHJhdGVneTogV2FybiBvbmNlIHBlciBjb21wb25lbnQuXG5cblxuICAgIGlmIChkaWRXYXJuQWJvdXRMZWdhY3lDb250ZXh0LmhhcyhmaWJlci50eXBlKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciB3YXJuaW5nc0ZvclJvb3QgPSBwZW5kaW5nTGVnYWN5Q29udGV4dFdhcm5pbmcuZ2V0KHN0cmljdFJvb3QpO1xuXG4gICAgaWYgKGZpYmVyLnR5cGUuY29udGV4dFR5cGVzICE9IG51bGwgfHwgZmliZXIudHlwZS5jaGlsZENvbnRleHRUeXBlcyAhPSBudWxsIHx8IGluc3RhbmNlICE9PSBudWxsICYmIHR5cGVvZiBpbnN0YW5jZS5nZXRDaGlsZENvbnRleHQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGlmICh3YXJuaW5nc0ZvclJvb3QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB3YXJuaW5nc0ZvclJvb3QgPSBbXTtcbiAgICAgICAgcGVuZGluZ0xlZ2FjeUNvbnRleHRXYXJuaW5nLnNldChzdHJpY3RSb290LCB3YXJuaW5nc0ZvclJvb3QpO1xuICAgICAgfVxuXG4gICAgICB3YXJuaW5nc0ZvclJvb3QucHVzaChmaWJlcik7XG4gICAgfVxuICB9O1xuXG4gIFJlYWN0U3RyaWN0TW9kZVdhcm5pbmdzLmZsdXNoTGVnYWN5Q29udGV4dFdhcm5pbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgcGVuZGluZ0xlZ2FjeUNvbnRleHRXYXJuaW5nLmZvckVhY2goZnVuY3Rpb24gKGZpYmVyQXJyYXksIHN0cmljdFJvb3QpIHtcbiAgICAgIGlmIChmaWJlckFycmF5Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBmaXJzdEZpYmVyID0gZmliZXJBcnJheVswXTtcbiAgICAgIHZhciB1bmlxdWVOYW1lcyA9IG5ldyBTZXQoKTtcbiAgICAgIGZpYmVyQXJyYXkuZm9yRWFjaChmdW5jdGlvbiAoZmliZXIpIHtcbiAgICAgICAgdW5pcXVlTmFtZXMuYWRkKGdldENvbXBvbmVudE5hbWUoZmliZXIudHlwZSkgfHwgJ0NvbXBvbmVudCcpO1xuICAgICAgICBkaWRXYXJuQWJvdXRMZWdhY3lDb250ZXh0LmFkZChmaWJlci50eXBlKTtcbiAgICAgIH0pO1xuICAgICAgdmFyIHNvcnRlZE5hbWVzID0gc2V0VG9Tb3J0ZWRTdHJpbmcodW5pcXVlTmFtZXMpO1xuXG4gICAgICB0cnkge1xuICAgICAgICBzZXRDdXJyZW50RmliZXIoZmlyc3RGaWJlcik7XG5cbiAgICAgICAgZXJyb3IoJ0xlZ2FjeSBjb250ZXh0IEFQSSBoYXMgYmVlbiBkZXRlY3RlZCB3aXRoaW4gYSBzdHJpY3QtbW9kZSB0cmVlLicgKyAnXFxuXFxuVGhlIG9sZCBBUEkgd2lsbCBiZSBzdXBwb3J0ZWQgaW4gYWxsIDE2LnggcmVsZWFzZXMsIGJ1dCBhcHBsaWNhdGlvbnMgJyArICd1c2luZyBpdCBzaG91bGQgbWlncmF0ZSB0byB0aGUgbmV3IHZlcnNpb24uJyArICdcXG5cXG5QbGVhc2UgdXBkYXRlIHRoZSBmb2xsb3dpbmcgY29tcG9uZW50czogJXMnICsgJ1xcblxcbkxlYXJuIG1vcmUgYWJvdXQgdGhpcyB3YXJuaW5nIGhlcmU6IGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9sZWdhY3ktY29udGV4dCcsIHNvcnRlZE5hbWVzKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHJlc2V0Q3VycmVudEZpYmVyKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgUmVhY3RTdHJpY3RNb2RlV2FybmluZ3MuZGlzY2FyZFBlbmRpbmdXYXJuaW5ncyA9IGZ1bmN0aW9uICgpIHtcbiAgICBwZW5kaW5nQ29tcG9uZW50V2lsbE1vdW50V2FybmluZ3MgPSBbXTtcbiAgICBwZW5kaW5nVU5TQUZFX0NvbXBvbmVudFdpbGxNb3VudFdhcm5pbmdzID0gW107XG4gICAgcGVuZGluZ0NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNXYXJuaW5ncyA9IFtdO1xuICAgIHBlbmRpbmdVTlNBRkVfQ29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc1dhcm5pbmdzID0gW107XG4gICAgcGVuZGluZ0NvbXBvbmVudFdpbGxVcGRhdGVXYXJuaW5ncyA9IFtdO1xuICAgIHBlbmRpbmdVTlNBRkVfQ29tcG9uZW50V2lsbFVwZGF0ZVdhcm5pbmdzID0gW107XG4gICAgcGVuZGluZ0xlZ2FjeUNvbnRleHRXYXJuaW5nID0gbmV3IE1hcCgpO1xuICB9O1xufVxuXG5mdW5jdGlvbiByZXNvbHZlRGVmYXVsdFByb3BzKENvbXBvbmVudCwgYmFzZVByb3BzKSB7XG4gIGlmIChDb21wb25lbnQgJiYgQ29tcG9uZW50LmRlZmF1bHRQcm9wcykge1xuICAgIC8vIFJlc29sdmUgZGVmYXVsdCBwcm9wcy4gVGFrZW4gZnJvbSBSZWFjdEVsZW1lbnRcbiAgICB2YXIgcHJvcHMgPSBfYXNzaWduKHt9LCBiYXNlUHJvcHMpO1xuXG4gICAgdmFyIGRlZmF1bHRQcm9wcyA9IENvbXBvbmVudC5kZWZhdWx0UHJvcHM7XG5cbiAgICBmb3IgKHZhciBwcm9wTmFtZSBpbiBkZWZhdWx0UHJvcHMpIHtcbiAgICAgIGlmIChwcm9wc1twcm9wTmFtZV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBwcm9wc1twcm9wTmFtZV0gPSBkZWZhdWx0UHJvcHNbcHJvcE5hbWVdO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBwcm9wcztcbiAgfVxuXG4gIHJldHVybiBiYXNlUHJvcHM7XG59XG5cbi8vIE1heCAzMSBiaXQgaW50ZWdlci4gVGhlIG1heCBpbnRlZ2VyIHNpemUgaW4gVjggZm9yIDMyLWJpdCBzeXN0ZW1zLlxuLy8gTWF0aC5wb3coMiwgMzApIC0gMVxuLy8gMGIxMTExMTExMTExMTExMTExMTExMTExMTExMTExMTFcbnZhciBNQVhfU0lHTkVEXzMxX0JJVF9JTlQgPSAxMDczNzQxODIzO1xuXG52YXIgdmFsdWVDdXJzb3IgPSBjcmVhdGVDdXJzb3IobnVsbCk7XG52YXIgcmVuZGVyZXJTaWdpbDtcblxue1xuICAvLyBVc2UgdGhpcyB0byBkZXRlY3QgbXVsdGlwbGUgcmVuZGVyZXJzIHVzaW5nIHRoZSBzYW1lIGNvbnRleHRcbiAgcmVuZGVyZXJTaWdpbCA9IHt9O1xufVxuXG52YXIgY3VycmVudGx5UmVuZGVyaW5nRmliZXIgPSBudWxsO1xudmFyIGxhc3RDb250ZXh0RGVwZW5kZW5jeSA9IG51bGw7XG52YXIgbGFzdENvbnRleHRXaXRoQWxsQml0c09ic2VydmVkID0gbnVsbDtcbnZhciBpc0Rpc2FsbG93ZWRDb250ZXh0UmVhZEluREVWID0gZmFsc2U7XG5mdW5jdGlvbiByZXNldENvbnRleHREZXBlbmRlbmNpZXMoKSB7XG4gIC8vIFRoaXMgaXMgY2FsbGVkIHJpZ2h0IGJlZm9yZSBSZWFjdCB5aWVsZHMgZXhlY3V0aW9uLCB0byBlbnN1cmUgYHJlYWRDb250ZXh0YFxuICAvLyBjYW5ub3QgYmUgY2FsbGVkIG91dHNpZGUgdGhlIHJlbmRlciBwaGFzZS5cbiAgY3VycmVudGx5UmVuZGVyaW5nRmliZXIgPSBudWxsO1xuICBsYXN0Q29udGV4dERlcGVuZGVuY3kgPSBudWxsO1xuICBsYXN0Q29udGV4dFdpdGhBbGxCaXRzT2JzZXJ2ZWQgPSBudWxsO1xuXG4gIHtcbiAgICBpc0Rpc2FsbG93ZWRDb250ZXh0UmVhZEluREVWID0gZmFsc2U7XG4gIH1cbn1cbmZ1bmN0aW9uIGVudGVyRGlzYWxsb3dlZENvbnRleHRSZWFkSW5ERVYoKSB7XG4gIHtcbiAgICBpc0Rpc2FsbG93ZWRDb250ZXh0UmVhZEluREVWID0gdHJ1ZTtcbiAgfVxufVxuZnVuY3Rpb24gZXhpdERpc2FsbG93ZWRDb250ZXh0UmVhZEluREVWKCkge1xuICB7XG4gICAgaXNEaXNhbGxvd2VkQ29udGV4dFJlYWRJbkRFViA9IGZhbHNlO1xuICB9XG59XG5mdW5jdGlvbiBwdXNoUHJvdmlkZXIocHJvdmlkZXJGaWJlciwgbmV4dFZhbHVlKSB7XG4gIHZhciBjb250ZXh0ID0gcHJvdmlkZXJGaWJlci50eXBlLl9jb250ZXh0O1xuXG4gIHtcbiAgICBwdXNoKHZhbHVlQ3Vyc29yLCBjb250ZXh0Ll9jdXJyZW50VmFsdWUsIHByb3ZpZGVyRmliZXIpO1xuICAgIGNvbnRleHQuX2N1cnJlbnRWYWx1ZSA9IG5leHRWYWx1ZTtcblxuICAgIHtcbiAgICAgIGlmIChjb250ZXh0Ll9jdXJyZW50UmVuZGVyZXIgIT09IHVuZGVmaW5lZCAmJiBjb250ZXh0Ll9jdXJyZW50UmVuZGVyZXIgIT09IG51bGwgJiYgY29udGV4dC5fY3VycmVudFJlbmRlcmVyICE9PSByZW5kZXJlclNpZ2lsKSB7XG4gICAgICAgIGVycm9yKCdEZXRlY3RlZCBtdWx0aXBsZSByZW5kZXJlcnMgY29uY3VycmVudGx5IHJlbmRlcmluZyB0aGUgJyArICdzYW1lIGNvbnRleHQgcHJvdmlkZXIuIFRoaXMgaXMgY3VycmVudGx5IHVuc3VwcG9ydGVkLicpO1xuICAgICAgfVxuXG4gICAgICBjb250ZXh0Ll9jdXJyZW50UmVuZGVyZXIgPSByZW5kZXJlclNpZ2lsO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gcG9wUHJvdmlkZXIocHJvdmlkZXJGaWJlcikge1xuICB2YXIgY3VycmVudFZhbHVlID0gdmFsdWVDdXJzb3IuY3VycmVudDtcbiAgcG9wKHZhbHVlQ3Vyc29yLCBwcm92aWRlckZpYmVyKTtcbiAgdmFyIGNvbnRleHQgPSBwcm92aWRlckZpYmVyLnR5cGUuX2NvbnRleHQ7XG5cbiAge1xuICAgIGNvbnRleHQuX2N1cnJlbnRWYWx1ZSA9IGN1cnJlbnRWYWx1ZTtcbiAgfVxufVxuZnVuY3Rpb24gY2FsY3VsYXRlQ2hhbmdlZEJpdHMoY29udGV4dCwgbmV3VmFsdWUsIG9sZFZhbHVlKSB7XG4gIGlmIChvYmplY3RJcyhvbGRWYWx1ZSwgbmV3VmFsdWUpKSB7XG4gICAgLy8gTm8gY2hhbmdlXG4gICAgcmV0dXJuIDA7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGNoYW5nZWRCaXRzID0gdHlwZW9mIGNvbnRleHQuX2NhbGN1bGF0ZUNoYW5nZWRCaXRzID09PSAnZnVuY3Rpb24nID8gY29udGV4dC5fY2FsY3VsYXRlQ2hhbmdlZEJpdHMob2xkVmFsdWUsIG5ld1ZhbHVlKSA6IE1BWF9TSUdORURfMzFfQklUX0lOVDtcblxuICAgIHtcbiAgICAgIGlmICgoY2hhbmdlZEJpdHMgJiBNQVhfU0lHTkVEXzMxX0JJVF9JTlQpICE9PSBjaGFuZ2VkQml0cykge1xuICAgICAgICBlcnJvcignY2FsY3VsYXRlQ2hhbmdlZEJpdHM6IEV4cGVjdGVkIHRoZSByZXR1cm4gdmFsdWUgdG8gYmUgYSAnICsgJzMxLWJpdCBpbnRlZ2VyLiBJbnN0ZWFkIHJlY2VpdmVkOiAlcycsIGNoYW5nZWRCaXRzKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gY2hhbmdlZEJpdHMgfCAwO1xuICB9XG59XG5mdW5jdGlvbiBzY2hlZHVsZVdvcmtPblBhcmVudFBhdGgocGFyZW50LCByZW5kZXJMYW5lcykge1xuICAvLyBVcGRhdGUgdGhlIGNoaWxkIGxhbmVzIG9mIGFsbCB0aGUgYW5jZXN0b3JzLCBpbmNsdWRpbmcgdGhlIGFsdGVybmF0ZXMuXG4gIHZhciBub2RlID0gcGFyZW50O1xuXG4gIHdoaWxlIChub2RlICE9PSBudWxsKSB7XG4gICAgdmFyIGFsdGVybmF0ZSA9IG5vZGUuYWx0ZXJuYXRlO1xuXG4gICAgaWYgKCFpc1N1YnNldE9mTGFuZXMobm9kZS5jaGlsZExhbmVzLCByZW5kZXJMYW5lcykpIHtcbiAgICAgIG5vZGUuY2hpbGRMYW5lcyA9IG1lcmdlTGFuZXMobm9kZS5jaGlsZExhbmVzLCByZW5kZXJMYW5lcyk7XG5cbiAgICAgIGlmIChhbHRlcm5hdGUgIT09IG51bGwpIHtcbiAgICAgICAgYWx0ZXJuYXRlLmNoaWxkTGFuZXMgPSBtZXJnZUxhbmVzKGFsdGVybmF0ZS5jaGlsZExhbmVzLCByZW5kZXJMYW5lcyk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChhbHRlcm5hdGUgIT09IG51bGwgJiYgIWlzU3Vic2V0T2ZMYW5lcyhhbHRlcm5hdGUuY2hpbGRMYW5lcywgcmVuZGVyTGFuZXMpKSB7XG4gICAgICBhbHRlcm5hdGUuY2hpbGRMYW5lcyA9IG1lcmdlTGFuZXMoYWx0ZXJuYXRlLmNoaWxkTGFuZXMsIHJlbmRlckxhbmVzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gTmVpdGhlciBhbHRlcm5hdGUgd2FzIHVwZGF0ZWQsIHdoaWNoIG1lYW5zIHRoZSByZXN0IG9mIHRoZVxuICAgICAgLy8gYW5jZXN0b3IgcGF0aCBhbHJlYWR5IGhhcyBzdWZmaWNpZW50IHByaW9yaXR5LlxuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgbm9kZSA9IG5vZGUucmV0dXJuO1xuICB9XG59XG5mdW5jdGlvbiBwcm9wYWdhdGVDb250ZXh0Q2hhbmdlKHdvcmtJblByb2dyZXNzLCBjb250ZXh0LCBjaGFuZ2VkQml0cywgcmVuZGVyTGFuZXMpIHtcbiAgdmFyIGZpYmVyID0gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG5cbiAgaWYgKGZpYmVyICE9PSBudWxsKSB7XG4gICAgLy8gU2V0IHRoZSByZXR1cm4gcG9pbnRlciBvZiB0aGUgY2hpbGQgdG8gdGhlIHdvcmstaW4tcHJvZ3Jlc3MgZmliZXIuXG4gICAgZmliZXIucmV0dXJuID0gd29ya0luUHJvZ3Jlc3M7XG4gIH1cblxuICB3aGlsZSAoZmliZXIgIT09IG51bGwpIHtcbiAgICB2YXIgbmV4dEZpYmVyID0gdm9pZCAwOyAvLyBWaXNpdCB0aGlzIGZpYmVyLlxuXG4gICAgdmFyIGxpc3QgPSBmaWJlci5kZXBlbmRlbmNpZXM7XG5cbiAgICBpZiAobGlzdCAhPT0gbnVsbCkge1xuICAgICAgbmV4dEZpYmVyID0gZmliZXIuY2hpbGQ7XG4gICAgICB2YXIgZGVwZW5kZW5jeSA9IGxpc3QuZmlyc3RDb250ZXh0O1xuXG4gICAgICB3aGlsZSAoZGVwZW5kZW5jeSAhPT0gbnVsbCkge1xuICAgICAgICAvLyBDaGVjayBpZiB0aGUgY29udGV4dCBtYXRjaGVzLlxuICAgICAgICBpZiAoZGVwZW5kZW5jeS5jb250ZXh0ID09PSBjb250ZXh0ICYmIChkZXBlbmRlbmN5Lm9ic2VydmVkQml0cyAmIGNoYW5nZWRCaXRzKSAhPT0gMCkge1xuICAgICAgICAgIC8vIE1hdGNoISBTY2hlZHVsZSBhbiB1cGRhdGUgb24gdGhpcyBmaWJlci5cbiAgICAgICAgICBpZiAoZmliZXIudGFnID09PSBDbGFzc0NvbXBvbmVudCkge1xuICAgICAgICAgICAgLy8gU2NoZWR1bGUgYSBmb3JjZSB1cGRhdGUgb24gdGhlIHdvcmstaW4tcHJvZ3Jlc3MuXG4gICAgICAgICAgICB2YXIgdXBkYXRlID0gY3JlYXRlVXBkYXRlKE5vVGltZXN0YW1wLCBwaWNrQXJiaXRyYXJ5TGFuZShyZW5kZXJMYW5lcykpO1xuICAgICAgICAgICAgdXBkYXRlLnRhZyA9IEZvcmNlVXBkYXRlOyAvLyBUT0RPOiBCZWNhdXNlIHdlIGRvbid0IGhhdmUgYSB3b3JrLWluLXByb2dyZXNzLCB0aGlzIHdpbGwgYWRkIHRoZVxuICAgICAgICAgICAgLy8gdXBkYXRlIHRvIHRoZSBjdXJyZW50IGZpYmVyLCB0b28sIHdoaWNoIG1lYW5zIGl0IHdpbGwgcGVyc2lzdCBldmVuIGlmXG4gICAgICAgICAgICAvLyB0aGlzIHJlbmRlciBpcyB0aHJvd24gYXdheS4gU2luY2UgaXQncyBhIHJhY2UgY29uZGl0aW9uLCBub3Qgc3VyZSBpdCdzXG4gICAgICAgICAgICAvLyB3b3J0aCBmaXhpbmcuXG5cbiAgICAgICAgICAgIGVucXVldWVVcGRhdGUoZmliZXIsIHVwZGF0ZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZmliZXIubGFuZXMgPSBtZXJnZUxhbmVzKGZpYmVyLmxhbmVzLCByZW5kZXJMYW5lcyk7XG4gICAgICAgICAgdmFyIGFsdGVybmF0ZSA9IGZpYmVyLmFsdGVybmF0ZTtcblxuICAgICAgICAgIGlmIChhbHRlcm5hdGUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGFsdGVybmF0ZS5sYW5lcyA9IG1lcmdlTGFuZXMoYWx0ZXJuYXRlLmxhbmVzLCByZW5kZXJMYW5lcyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgc2NoZWR1bGVXb3JrT25QYXJlbnRQYXRoKGZpYmVyLnJldHVybiwgcmVuZGVyTGFuZXMpOyAvLyBNYXJrIHRoZSB1cGRhdGVkIGxhbmVzIG9uIHRoZSBsaXN0LCB0b28uXG5cbiAgICAgICAgICBsaXN0LmxhbmVzID0gbWVyZ2VMYW5lcyhsaXN0LmxhbmVzLCByZW5kZXJMYW5lcyk7IC8vIFNpbmNlIHdlIGFscmVhZHkgZm91bmQgYSBtYXRjaCwgd2UgY2FuIHN0b3AgdHJhdmVyc2luZyB0aGVcbiAgICAgICAgICAvLyBkZXBlbmRlbmN5IGxpc3QuXG5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIGRlcGVuZGVuY3kgPSBkZXBlbmRlbmN5Lm5leHQ7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChmaWJlci50YWcgPT09IENvbnRleHRQcm92aWRlcikge1xuICAgICAgLy8gRG9uJ3Qgc2NhbiBkZWVwZXIgaWYgdGhpcyBpcyBhIG1hdGNoaW5nIHByb3ZpZGVyXG4gICAgICBuZXh0RmliZXIgPSBmaWJlci50eXBlID09PSB3b3JrSW5Qcm9ncmVzcy50eXBlID8gbnVsbCA6IGZpYmVyLmNoaWxkO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBUcmF2ZXJzZSBkb3duLlxuICAgICAgbmV4dEZpYmVyID0gZmliZXIuY2hpbGQ7XG4gICAgfVxuXG4gICAgaWYgKG5leHRGaWJlciAhPT0gbnVsbCkge1xuICAgICAgLy8gU2V0IHRoZSByZXR1cm4gcG9pbnRlciBvZiB0aGUgY2hpbGQgdG8gdGhlIHdvcmstaW4tcHJvZ3Jlc3MgZmliZXIuXG4gICAgICBuZXh0RmliZXIucmV0dXJuID0gZmliZXI7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIE5vIGNoaWxkLiBUcmF2ZXJzZSB0byBuZXh0IHNpYmxpbmcuXG4gICAgICBuZXh0RmliZXIgPSBmaWJlcjtcblxuICAgICAgd2hpbGUgKG5leHRGaWJlciAhPT0gbnVsbCkge1xuICAgICAgICBpZiAobmV4dEZpYmVyID09PSB3b3JrSW5Qcm9ncmVzcykge1xuICAgICAgICAgIC8vIFdlJ3JlIGJhY2sgdG8gdGhlIHJvb3Qgb2YgdGhpcyBzdWJ0cmVlLiBFeGl0LlxuICAgICAgICAgIG5leHRGaWJlciA9IG51bGw7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc2libGluZyA9IG5leHRGaWJlci5zaWJsaW5nO1xuXG4gICAgICAgIGlmIChzaWJsaW5nICE9PSBudWxsKSB7XG4gICAgICAgICAgLy8gU2V0IHRoZSByZXR1cm4gcG9pbnRlciBvZiB0aGUgc2libGluZyB0byB0aGUgd29yay1pbi1wcm9ncmVzcyBmaWJlci5cbiAgICAgICAgICBzaWJsaW5nLnJldHVybiA9IG5leHRGaWJlci5yZXR1cm47XG4gICAgICAgICAgbmV4dEZpYmVyID0gc2libGluZztcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfSAvLyBObyBtb3JlIHNpYmxpbmdzLiBUcmF2ZXJzZSB1cC5cblxuXG4gICAgICAgIG5leHRGaWJlciA9IG5leHRGaWJlci5yZXR1cm47XG4gICAgICB9XG4gICAgfVxuXG4gICAgZmliZXIgPSBuZXh0RmliZXI7XG4gIH1cbn1cbmZ1bmN0aW9uIHByZXBhcmVUb1JlYWRDb250ZXh0KHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcykge1xuICBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciA9IHdvcmtJblByb2dyZXNzO1xuICBsYXN0Q29udGV4dERlcGVuZGVuY3kgPSBudWxsO1xuICBsYXN0Q29udGV4dFdpdGhBbGxCaXRzT2JzZXJ2ZWQgPSBudWxsO1xuICB2YXIgZGVwZW5kZW5jaWVzID0gd29ya0luUHJvZ3Jlc3MuZGVwZW5kZW5jaWVzO1xuXG4gIGlmIChkZXBlbmRlbmNpZXMgIT09IG51bGwpIHtcbiAgICB2YXIgZmlyc3RDb250ZXh0ID0gZGVwZW5kZW5jaWVzLmZpcnN0Q29udGV4dDtcblxuICAgIGlmIChmaXJzdENvbnRleHQgIT09IG51bGwpIHtcbiAgICAgIGlmIChpbmNsdWRlc1NvbWVMYW5lKGRlcGVuZGVuY2llcy5sYW5lcywgcmVuZGVyTGFuZXMpKSB7XG4gICAgICAgIC8vIENvbnRleHQgbGlzdCBoYXMgYSBwZW5kaW5nIHVwZGF0ZS4gTWFyayB0aGF0IHRoaXMgZmliZXIgcGVyZm9ybWVkIHdvcmsuXG4gICAgICAgIG1hcmtXb3JrSW5Qcm9ncmVzc1JlY2VpdmVkVXBkYXRlKCk7XG4gICAgICB9IC8vIFJlc2V0IHRoZSB3b3JrLWluLXByb2dyZXNzIGxpc3RcblxuXG4gICAgICBkZXBlbmRlbmNpZXMuZmlyc3RDb250ZXh0ID0gbnVsbDtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIHJlYWRDb250ZXh0KGNvbnRleHQsIG9ic2VydmVkQml0cykge1xuICB7XG4gICAgLy8gVGhpcyB3YXJuaW5nIHdvdWxkIGZpcmUgaWYgeW91IHJlYWQgY29udGV4dCBpbnNpZGUgYSBIb29rIGxpa2UgdXNlTWVtby5cbiAgICAvLyBVbmxpa2UgdGhlIGNsYXNzIGNoZWNrIGJlbG93LCBpdCdzIG5vdCBlbmZvcmNlZCBpbiBwcm9kdWN0aW9uIGZvciBwZXJmLlxuICAgIGlmIChpc0Rpc2FsbG93ZWRDb250ZXh0UmVhZEluREVWKSB7XG4gICAgICBlcnJvcignQ29udGV4dCBjYW4gb25seSBiZSByZWFkIHdoaWxlIFJlYWN0IGlzIHJlbmRlcmluZy4gJyArICdJbiBjbGFzc2VzLCB5b3UgY2FuIHJlYWQgaXQgaW4gdGhlIHJlbmRlciBtZXRob2Qgb3IgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzLiAnICsgJ0luIGZ1bmN0aW9uIGNvbXBvbmVudHMsIHlvdSBjYW4gcmVhZCBpdCBkaXJlY3RseSBpbiB0aGUgZnVuY3Rpb24gYm9keSwgYnV0IG5vdCAnICsgJ2luc2lkZSBIb29rcyBsaWtlIHVzZVJlZHVjZXIoKSBvciB1c2VNZW1vKCkuJyk7XG4gICAgfVxuICB9XG5cbiAgaWYgKGxhc3RDb250ZXh0V2l0aEFsbEJpdHNPYnNlcnZlZCA9PT0gY29udGV4dCkgOyBlbHNlIGlmIChvYnNlcnZlZEJpdHMgPT09IGZhbHNlIHx8IG9ic2VydmVkQml0cyA9PT0gMCkgOyBlbHNlIHtcbiAgICB2YXIgcmVzb2x2ZWRPYnNlcnZlZEJpdHM7IC8vIEF2b2lkIGRlb3B0aW5nIG9uIG9ic2VydmFibGUgYXJndW1lbnRzIG9yIGhldGVyb2dlbmVvdXMgdHlwZXMuXG5cbiAgICBpZiAodHlwZW9mIG9ic2VydmVkQml0cyAhPT0gJ251bWJlcicgfHwgb2JzZXJ2ZWRCaXRzID09PSBNQVhfU0lHTkVEXzMxX0JJVF9JTlQpIHtcbiAgICAgIC8vIE9ic2VydmUgYWxsIHVwZGF0ZXMuXG4gICAgICBsYXN0Q29udGV4dFdpdGhBbGxCaXRzT2JzZXJ2ZWQgPSBjb250ZXh0O1xuICAgICAgcmVzb2x2ZWRPYnNlcnZlZEJpdHMgPSBNQVhfU0lHTkVEXzMxX0JJVF9JTlQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc29sdmVkT2JzZXJ2ZWRCaXRzID0gb2JzZXJ2ZWRCaXRzO1xuICAgIH1cblxuICAgIHZhciBjb250ZXh0SXRlbSA9IHtcbiAgICAgIGNvbnRleHQ6IGNvbnRleHQsXG4gICAgICBvYnNlcnZlZEJpdHM6IHJlc29sdmVkT2JzZXJ2ZWRCaXRzLFxuICAgICAgbmV4dDogbnVsbFxuICAgIH07XG5cbiAgICBpZiAobGFzdENvbnRleHREZXBlbmRlbmN5ID09PSBudWxsKSB7XG4gICAgICBpZiAoIShjdXJyZW50bHlSZW5kZXJpbmdGaWJlciAhPT0gbnVsbCkpIHtcbiAgICAgICAge1xuICAgICAgICAgIHRocm93IEVycm9yKCBcIkNvbnRleHQgY2FuIG9ubHkgYmUgcmVhZCB3aGlsZSBSZWFjdCBpcyByZW5kZXJpbmcuIEluIGNsYXNzZXMsIHlvdSBjYW4gcmVhZCBpdCBpbiB0aGUgcmVuZGVyIG1ldGhvZCBvciBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMuIEluIGZ1bmN0aW9uIGNvbXBvbmVudHMsIHlvdSBjYW4gcmVhZCBpdCBkaXJlY3RseSBpbiB0aGUgZnVuY3Rpb24gYm9keSwgYnV0IG5vdCBpbnNpZGUgSG9va3MgbGlrZSB1c2VSZWR1Y2VyKCkgb3IgdXNlTWVtbygpLlwiICk7XG4gICAgICAgIH1cbiAgICAgIH0gLy8gVGhpcyBpcyB0aGUgZmlyc3QgZGVwZW5kZW5jeSBmb3IgdGhpcyBjb21wb25lbnQuIENyZWF0ZSBhIG5ldyBsaXN0LlxuXG5cbiAgICAgIGxhc3RDb250ZXh0RGVwZW5kZW5jeSA9IGNvbnRleHRJdGVtO1xuICAgICAgY3VycmVudGx5UmVuZGVyaW5nRmliZXIuZGVwZW5kZW5jaWVzID0ge1xuICAgICAgICBsYW5lczogTm9MYW5lcyxcbiAgICAgICAgZmlyc3RDb250ZXh0OiBjb250ZXh0SXRlbSxcbiAgICAgICAgcmVzcG9uZGVyczogbnVsbFxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gQXBwZW5kIGEgbmV3IGNvbnRleHQgaXRlbS5cbiAgICAgIGxhc3RDb250ZXh0RGVwZW5kZW5jeSA9IGxhc3RDb250ZXh0RGVwZW5kZW5jeS5uZXh0ID0gY29udGV4dEl0ZW07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuICBjb250ZXh0Ll9jdXJyZW50VmFsdWUgO1xufVxuXG52YXIgVXBkYXRlU3RhdGUgPSAwO1xudmFyIFJlcGxhY2VTdGF0ZSA9IDE7XG52YXIgRm9yY2VVcGRhdGUgPSAyO1xudmFyIENhcHR1cmVVcGRhdGUgPSAzOyAvLyBHbG9iYWwgc3RhdGUgdGhhdCBpcyByZXNldCBhdCB0aGUgYmVnaW5uaW5nIG9mIGNhbGxpbmcgYHByb2Nlc3NVcGRhdGVRdWV1ZWAuXG4vLyBJdCBzaG91bGQgb25seSBiZSByZWFkIHJpZ2h0IGFmdGVyIGNhbGxpbmcgYHByb2Nlc3NVcGRhdGVRdWV1ZWAsIHZpYVxuLy8gYGNoZWNrSGFzRm9yY2VVcGRhdGVBZnRlclByb2Nlc3NpbmdgLlxuXG52YXIgaGFzRm9yY2VVcGRhdGUgPSBmYWxzZTtcbnZhciBkaWRXYXJuVXBkYXRlSW5zaWRlVXBkYXRlO1xudmFyIGN1cnJlbnRseVByb2Nlc3NpbmdRdWV1ZTtcblxue1xuICBkaWRXYXJuVXBkYXRlSW5zaWRlVXBkYXRlID0gZmFsc2U7XG4gIGN1cnJlbnRseVByb2Nlc3NpbmdRdWV1ZSA9IG51bGw7XG59XG5cbmZ1bmN0aW9uIGluaXRpYWxpemVVcGRhdGVRdWV1ZShmaWJlcikge1xuICB2YXIgcXVldWUgPSB7XG4gICAgYmFzZVN0YXRlOiBmaWJlci5tZW1vaXplZFN0YXRlLFxuICAgIGZpcnN0QmFzZVVwZGF0ZTogbnVsbCxcbiAgICBsYXN0QmFzZVVwZGF0ZTogbnVsbCxcbiAgICBzaGFyZWQ6IHtcbiAgICAgIHBlbmRpbmc6IG51bGxcbiAgICB9LFxuICAgIGVmZmVjdHM6IG51bGxcbiAgfTtcbiAgZmliZXIudXBkYXRlUXVldWUgPSBxdWV1ZTtcbn1cbmZ1bmN0aW9uIGNsb25lVXBkYXRlUXVldWUoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpIHtcbiAgLy8gQ2xvbmUgdGhlIHVwZGF0ZSBxdWV1ZSBmcm9tIGN1cnJlbnQuIFVubGVzcyBpdCdzIGFscmVhZHkgYSBjbG9uZS5cbiAgdmFyIHF1ZXVlID0gd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWU7XG4gIHZhciBjdXJyZW50UXVldWUgPSBjdXJyZW50LnVwZGF0ZVF1ZXVlO1xuXG4gIGlmIChxdWV1ZSA9PT0gY3VycmVudFF1ZXVlKSB7XG4gICAgdmFyIGNsb25lID0ge1xuICAgICAgYmFzZVN0YXRlOiBjdXJyZW50UXVldWUuYmFzZVN0YXRlLFxuICAgICAgZmlyc3RCYXNlVXBkYXRlOiBjdXJyZW50UXVldWUuZmlyc3RCYXNlVXBkYXRlLFxuICAgICAgbGFzdEJhc2VVcGRhdGU6IGN1cnJlbnRRdWV1ZS5sYXN0QmFzZVVwZGF0ZSxcbiAgICAgIHNoYXJlZDogY3VycmVudFF1ZXVlLnNoYXJlZCxcbiAgICAgIGVmZmVjdHM6IGN1cnJlbnRRdWV1ZS5lZmZlY3RzXG4gICAgfTtcbiAgICB3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZSA9IGNsb25lO1xuICB9XG59XG5mdW5jdGlvbiBjcmVhdGVVcGRhdGUoZXZlbnRUaW1lLCBsYW5lKSB7XG4gIHZhciB1cGRhdGUgPSB7XG4gICAgZXZlbnRUaW1lOiBldmVudFRpbWUsXG4gICAgbGFuZTogbGFuZSxcbiAgICB0YWc6IFVwZGF0ZVN0YXRlLFxuICAgIHBheWxvYWQ6IG51bGwsXG4gICAgY2FsbGJhY2s6IG51bGwsXG4gICAgbmV4dDogbnVsbFxuICB9O1xuICByZXR1cm4gdXBkYXRlO1xufVxuZnVuY3Rpb24gZW5xdWV1ZVVwZGF0ZShmaWJlciwgdXBkYXRlKSB7XG4gIHZhciB1cGRhdGVRdWV1ZSA9IGZpYmVyLnVwZGF0ZVF1ZXVlO1xuXG4gIGlmICh1cGRhdGVRdWV1ZSA9PT0gbnVsbCkge1xuICAgIC8vIE9ubHkgb2NjdXJzIGlmIHRoZSBmaWJlciBoYXMgYmVlbiB1bm1vdW50ZWQuXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIHNoYXJlZFF1ZXVlID0gdXBkYXRlUXVldWUuc2hhcmVkO1xuICB2YXIgcGVuZGluZyA9IHNoYXJlZFF1ZXVlLnBlbmRpbmc7XG5cbiAgaWYgKHBlbmRpbmcgPT09IG51bGwpIHtcbiAgICAvLyBUaGlzIGlzIHRoZSBmaXJzdCB1cGRhdGUuIENyZWF0ZSBhIGNpcmN1bGFyIGxpc3QuXG4gICAgdXBkYXRlLm5leHQgPSB1cGRhdGU7XG4gIH0gZWxzZSB7XG4gICAgdXBkYXRlLm5leHQgPSBwZW5kaW5nLm5leHQ7XG4gICAgcGVuZGluZy5uZXh0ID0gdXBkYXRlO1xuICB9XG5cbiAgc2hhcmVkUXVldWUucGVuZGluZyA9IHVwZGF0ZTtcblxuICB7XG4gICAgaWYgKGN1cnJlbnRseVByb2Nlc3NpbmdRdWV1ZSA9PT0gc2hhcmVkUXVldWUgJiYgIWRpZFdhcm5VcGRhdGVJbnNpZGVVcGRhdGUpIHtcbiAgICAgIGVycm9yKCdBbiB1cGRhdGUgKHNldFN0YXRlLCByZXBsYWNlU3RhdGUsIG9yIGZvcmNlVXBkYXRlKSB3YXMgc2NoZWR1bGVkICcgKyAnZnJvbSBpbnNpZGUgYW4gdXBkYXRlIGZ1bmN0aW9uLiBVcGRhdGUgZnVuY3Rpb25zIHNob3VsZCBiZSBwdXJlLCAnICsgJ3dpdGggemVybyBzaWRlLWVmZmVjdHMuIENvbnNpZGVyIHVzaW5nIGNvbXBvbmVudERpZFVwZGF0ZSBvciBhICcgKyAnY2FsbGJhY2suJyk7XG5cbiAgICAgIGRpZFdhcm5VcGRhdGVJbnNpZGVVcGRhdGUgPSB0cnVlO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gZW5xdWV1ZUNhcHR1cmVkVXBkYXRlKHdvcmtJblByb2dyZXNzLCBjYXB0dXJlZFVwZGF0ZSkge1xuICAvLyBDYXB0dXJlZCB1cGRhdGVzIGFyZSB1cGRhdGVzIHRoYXQgYXJlIHRocm93biBieSBhIGNoaWxkIGR1cmluZyB0aGUgcmVuZGVyXG4gIC8vIHBoYXNlLiBUaGV5IHNob3VsZCBiZSBkaXNjYXJkZWQgaWYgdGhlIHJlbmRlciBpcyBhYm9ydGVkLiBUaGVyZWZvcmUsXG4gIC8vIHdlIHNob3VsZCBvbmx5IHB1dCB0aGVtIG9uIHRoZSB3b3JrLWluLXByb2dyZXNzIHF1ZXVlLCBub3QgdGhlIGN1cnJlbnQgb25lLlxuICB2YXIgcXVldWUgPSB3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZTsgLy8gQ2hlY2sgaWYgdGhlIHdvcmstaW4tcHJvZ3Jlc3MgcXVldWUgaXMgYSBjbG9uZS5cblxuICB2YXIgY3VycmVudCA9IHdvcmtJblByb2dyZXNzLmFsdGVybmF0ZTtcblxuICBpZiAoY3VycmVudCAhPT0gbnVsbCkge1xuICAgIHZhciBjdXJyZW50UXVldWUgPSBjdXJyZW50LnVwZGF0ZVF1ZXVlO1xuXG4gICAgaWYgKHF1ZXVlID09PSBjdXJyZW50UXVldWUpIHtcbiAgICAgIC8vIFRoZSB3b3JrLWluLXByb2dyZXNzIHF1ZXVlIGlzIHRoZSBzYW1lIGFzIGN1cnJlbnQuIFRoaXMgaGFwcGVucyB3aGVuXG4gICAgICAvLyB3ZSBiYWlsIG91dCBvbiBhIHBhcmVudCBmaWJlciB0aGF0IHRoZW4gY2FwdHVyZXMgYW4gZXJyb3IgdGhyb3duIGJ5XG4gICAgICAvLyBhIGNoaWxkLiBTaW5jZSB3ZSB3YW50IHRvIGFwcGVuZCB0aGUgdXBkYXRlIG9ubHkgdG8gdGhlIHdvcmstaW5cbiAgICAgIC8vIC1wcm9ncmVzcyBxdWV1ZSwgd2UgbmVlZCB0byBjbG9uZSB0aGUgdXBkYXRlcy4gV2UgdXN1YWxseSBjbG9uZSBkdXJpbmdcbiAgICAgIC8vIHByb2Nlc3NVcGRhdGVRdWV1ZSwgYnV0IHRoYXQgZGlkbid0IGhhcHBlbiBpbiB0aGlzIGNhc2UgYmVjYXVzZSB3ZVxuICAgICAgLy8gc2tpcHBlZCBvdmVyIHRoZSBwYXJlbnQgd2hlbiB3ZSBiYWlsZWQgb3V0LlxuICAgICAgdmFyIG5ld0ZpcnN0ID0gbnVsbDtcbiAgICAgIHZhciBuZXdMYXN0ID0gbnVsbDtcbiAgICAgIHZhciBmaXJzdEJhc2VVcGRhdGUgPSBxdWV1ZS5maXJzdEJhc2VVcGRhdGU7XG5cbiAgICAgIGlmIChmaXJzdEJhc2VVcGRhdGUgIT09IG51bGwpIHtcbiAgICAgICAgLy8gTG9vcCB0aHJvdWdoIHRoZSB1cGRhdGVzIGFuZCBjbG9uZSB0aGVtLlxuICAgICAgICB2YXIgdXBkYXRlID0gZmlyc3RCYXNlVXBkYXRlO1xuXG4gICAgICAgIGRvIHtcbiAgICAgICAgICB2YXIgY2xvbmUgPSB7XG4gICAgICAgICAgICBldmVudFRpbWU6IHVwZGF0ZS5ldmVudFRpbWUsXG4gICAgICAgICAgICBsYW5lOiB1cGRhdGUubGFuZSxcbiAgICAgICAgICAgIHRhZzogdXBkYXRlLnRhZyxcbiAgICAgICAgICAgIHBheWxvYWQ6IHVwZGF0ZS5wYXlsb2FkLFxuICAgICAgICAgICAgY2FsbGJhY2s6IHVwZGF0ZS5jYWxsYmFjayxcbiAgICAgICAgICAgIG5leHQ6IG51bGxcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgaWYgKG5ld0xhc3QgPT09IG51bGwpIHtcbiAgICAgICAgICAgIG5ld0ZpcnN0ID0gbmV3TGFzdCA9IGNsb25lO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBuZXdMYXN0Lm5leHQgPSBjbG9uZTtcbiAgICAgICAgICAgIG5ld0xhc3QgPSBjbG9uZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB1cGRhdGUgPSB1cGRhdGUubmV4dDtcbiAgICAgICAgfSB3aGlsZSAodXBkYXRlICE9PSBudWxsKTsgLy8gQXBwZW5kIHRoZSBjYXB0dXJlZCB1cGRhdGUgdGhlIGVuZCBvZiB0aGUgY2xvbmVkIGxpc3QuXG5cblxuICAgICAgICBpZiAobmV3TGFzdCA9PT0gbnVsbCkge1xuICAgICAgICAgIG5ld0ZpcnN0ID0gbmV3TGFzdCA9IGNhcHR1cmVkVXBkYXRlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5ld0xhc3QubmV4dCA9IGNhcHR1cmVkVXBkYXRlO1xuICAgICAgICAgIG5ld0xhc3QgPSBjYXB0dXJlZFVwZGF0ZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gVGhlcmUgYXJlIG5vIGJhc2UgdXBkYXRlcy5cbiAgICAgICAgbmV3Rmlyc3QgPSBuZXdMYXN0ID0gY2FwdHVyZWRVcGRhdGU7XG4gICAgICB9XG5cbiAgICAgIHF1ZXVlID0ge1xuICAgICAgICBiYXNlU3RhdGU6IGN1cnJlbnRRdWV1ZS5iYXNlU3RhdGUsXG4gICAgICAgIGZpcnN0QmFzZVVwZGF0ZTogbmV3Rmlyc3QsXG4gICAgICAgIGxhc3RCYXNlVXBkYXRlOiBuZXdMYXN0LFxuICAgICAgICBzaGFyZWQ6IGN1cnJlbnRRdWV1ZS5zaGFyZWQsXG4gICAgICAgIGVmZmVjdHM6IGN1cnJlbnRRdWV1ZS5lZmZlY3RzXG4gICAgICB9O1xuICAgICAgd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWUgPSBxdWV1ZTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH0gLy8gQXBwZW5kIHRoZSB1cGRhdGUgdG8gdGhlIGVuZCBvZiB0aGUgbGlzdC5cblxuXG4gIHZhciBsYXN0QmFzZVVwZGF0ZSA9IHF1ZXVlLmxhc3RCYXNlVXBkYXRlO1xuXG4gIGlmIChsYXN0QmFzZVVwZGF0ZSA9PT0gbnVsbCkge1xuICAgIHF1ZXVlLmZpcnN0QmFzZVVwZGF0ZSA9IGNhcHR1cmVkVXBkYXRlO1xuICB9IGVsc2Uge1xuICAgIGxhc3RCYXNlVXBkYXRlLm5leHQgPSBjYXB0dXJlZFVwZGF0ZTtcbiAgfVxuXG4gIHF1ZXVlLmxhc3RCYXNlVXBkYXRlID0gY2FwdHVyZWRVcGRhdGU7XG59XG5cbmZ1bmN0aW9uIGdldFN0YXRlRnJvbVVwZGF0ZSh3b3JrSW5Qcm9ncmVzcywgcXVldWUsIHVwZGF0ZSwgcHJldlN0YXRlLCBuZXh0UHJvcHMsIGluc3RhbmNlKSB7XG4gIHN3aXRjaCAodXBkYXRlLnRhZykge1xuICAgIGNhc2UgUmVwbGFjZVN0YXRlOlxuICAgICAge1xuICAgICAgICB2YXIgcGF5bG9hZCA9IHVwZGF0ZS5wYXlsb2FkO1xuXG4gICAgICAgIGlmICh0eXBlb2YgcGF5bG9hZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIC8vIFVwZGF0ZXIgZnVuY3Rpb25cbiAgICAgICAgICB7XG4gICAgICAgICAgICBlbnRlckRpc2FsbG93ZWRDb250ZXh0UmVhZEluREVWKCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIG5leHRTdGF0ZSA9IHBheWxvYWQuY2FsbChpbnN0YW5jZSwgcHJldlN0YXRlLCBuZXh0UHJvcHMpO1xuXG4gICAgICAgICAge1xuICAgICAgICAgICAgaWYgKCB3b3JrSW5Qcm9ncmVzcy5tb2RlICYgU3RyaWN0TW9kZSkge1xuICAgICAgICAgICAgICBkaXNhYmxlTG9ncygpO1xuXG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcGF5bG9hZC5jYWxsKGluc3RhbmNlLCBwcmV2U3RhdGUsIG5leHRQcm9wcyk7XG4gICAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgcmVlbmFibGVMb2dzKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZXhpdERpc2FsbG93ZWRDb250ZXh0UmVhZEluREVWKCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIG5leHRTdGF0ZTtcbiAgICAgICAgfSAvLyBTdGF0ZSBvYmplY3RcblxuXG4gICAgICAgIHJldHVybiBwYXlsb2FkO1xuICAgICAgfVxuXG4gICAgY2FzZSBDYXB0dXJlVXBkYXRlOlxuICAgICAge1xuICAgICAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyA9IHdvcmtJblByb2dyZXNzLmZsYWdzICYgflNob3VsZENhcHR1cmUgfCBEaWRDYXB0dXJlO1xuICAgICAgfVxuICAgIC8vIEludGVudGlvbmFsIGZhbGx0aHJvdWdoXG5cbiAgICBjYXNlIFVwZGF0ZVN0YXRlOlxuICAgICAge1xuICAgICAgICB2YXIgX3BheWxvYWQgPSB1cGRhdGUucGF5bG9hZDtcbiAgICAgICAgdmFyIHBhcnRpYWxTdGF0ZTtcblxuICAgICAgICBpZiAodHlwZW9mIF9wYXlsb2FkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgLy8gVXBkYXRlciBmdW5jdGlvblxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGVudGVyRGlzYWxsb3dlZENvbnRleHRSZWFkSW5ERVYoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBwYXJ0aWFsU3RhdGUgPSBfcGF5bG9hZC5jYWxsKGluc3RhbmNlLCBwcmV2U3RhdGUsIG5leHRQcm9wcyk7XG5cbiAgICAgICAgICB7XG4gICAgICAgICAgICBpZiAoIHdvcmtJblByb2dyZXNzLm1vZGUgJiBTdHJpY3RNb2RlKSB7XG4gICAgICAgICAgICAgIGRpc2FibGVMb2dzKCk7XG5cbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBfcGF5bG9hZC5jYWxsKGluc3RhbmNlLCBwcmV2U3RhdGUsIG5leHRQcm9wcyk7XG4gICAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgcmVlbmFibGVMb2dzKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZXhpdERpc2FsbG93ZWRDb250ZXh0UmVhZEluREVWKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIFBhcnRpYWwgc3RhdGUgb2JqZWN0XG4gICAgICAgICAgcGFydGlhbFN0YXRlID0gX3BheWxvYWQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocGFydGlhbFN0YXRlID09PSBudWxsIHx8IHBhcnRpYWxTdGF0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgLy8gTnVsbCBhbmQgdW5kZWZpbmVkIGFyZSB0cmVhdGVkIGFzIG5vLW9wcy5cbiAgICAgICAgICByZXR1cm4gcHJldlN0YXRlO1xuICAgICAgICB9IC8vIE1lcmdlIHRoZSBwYXJ0aWFsIHN0YXRlIGFuZCB0aGUgcHJldmlvdXMgc3RhdGUuXG5cblxuICAgICAgICByZXR1cm4gX2Fzc2lnbih7fSwgcHJldlN0YXRlLCBwYXJ0aWFsU3RhdGUpO1xuICAgICAgfVxuXG4gICAgY2FzZSBGb3JjZVVwZGF0ZTpcbiAgICAgIHtcbiAgICAgICAgaGFzRm9yY2VVcGRhdGUgPSB0cnVlO1xuICAgICAgICByZXR1cm4gcHJldlN0YXRlO1xuICAgICAgfVxuICB9XG5cbiAgcmV0dXJuIHByZXZTdGF0ZTtcbn1cblxuZnVuY3Rpb24gcHJvY2Vzc1VwZGF0ZVF1ZXVlKHdvcmtJblByb2dyZXNzLCBwcm9wcywgaW5zdGFuY2UsIHJlbmRlckxhbmVzKSB7XG4gIC8vIFRoaXMgaXMgYWx3YXlzIG5vbi1udWxsIG9uIGEgQ2xhc3NDb21wb25lbnQgb3IgSG9zdFJvb3RcbiAgdmFyIHF1ZXVlID0gd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWU7XG4gIGhhc0ZvcmNlVXBkYXRlID0gZmFsc2U7XG5cbiAge1xuICAgIGN1cnJlbnRseVByb2Nlc3NpbmdRdWV1ZSA9IHF1ZXVlLnNoYXJlZDtcbiAgfVxuXG4gIHZhciBmaXJzdEJhc2VVcGRhdGUgPSBxdWV1ZS5maXJzdEJhc2VVcGRhdGU7XG4gIHZhciBsYXN0QmFzZVVwZGF0ZSA9IHF1ZXVlLmxhc3RCYXNlVXBkYXRlOyAvLyBDaGVjayBpZiB0aGVyZSBhcmUgcGVuZGluZyB1cGRhdGVzLiBJZiBzbywgdHJhbnNmZXIgdGhlbSB0byB0aGUgYmFzZSBxdWV1ZS5cblxuICB2YXIgcGVuZGluZ1F1ZXVlID0gcXVldWUuc2hhcmVkLnBlbmRpbmc7XG5cbiAgaWYgKHBlbmRpbmdRdWV1ZSAhPT0gbnVsbCkge1xuICAgIHF1ZXVlLnNoYXJlZC5wZW5kaW5nID0gbnVsbDsgLy8gVGhlIHBlbmRpbmcgcXVldWUgaXMgY2lyY3VsYXIuIERpc2Nvbm5lY3QgdGhlIHBvaW50ZXIgYmV0d2VlbiBmaXJzdFxuICAgIC8vIGFuZCBsYXN0IHNvIHRoYXQgaXQncyBub24tY2lyY3VsYXIuXG5cbiAgICB2YXIgbGFzdFBlbmRpbmdVcGRhdGUgPSBwZW5kaW5nUXVldWU7XG4gICAgdmFyIGZpcnN0UGVuZGluZ1VwZGF0ZSA9IGxhc3RQZW5kaW5nVXBkYXRlLm5leHQ7XG4gICAgbGFzdFBlbmRpbmdVcGRhdGUubmV4dCA9IG51bGw7IC8vIEFwcGVuZCBwZW5kaW5nIHVwZGF0ZXMgdG8gYmFzZSBxdWV1ZVxuXG4gICAgaWYgKGxhc3RCYXNlVXBkYXRlID09PSBudWxsKSB7XG4gICAgICBmaXJzdEJhc2VVcGRhdGUgPSBmaXJzdFBlbmRpbmdVcGRhdGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxhc3RCYXNlVXBkYXRlLm5leHQgPSBmaXJzdFBlbmRpbmdVcGRhdGU7XG4gICAgfVxuXG4gICAgbGFzdEJhc2VVcGRhdGUgPSBsYXN0UGVuZGluZ1VwZGF0ZTsgLy8gSWYgdGhlcmUncyBhIGN1cnJlbnQgcXVldWUsIGFuZCBpdCdzIGRpZmZlcmVudCBmcm9tIHRoZSBiYXNlIHF1ZXVlLCB0aGVuXG4gICAgLy8gd2UgbmVlZCB0byB0cmFuc2ZlciB0aGUgdXBkYXRlcyB0byB0aGF0IHF1ZXVlLCB0b28uIEJlY2F1c2UgdGhlIGJhc2VcbiAgICAvLyBxdWV1ZSBpcyBhIHNpbmdseS1saW5rZWQgbGlzdCB3aXRoIG5vIGN5Y2xlcywgd2UgY2FuIGFwcGVuZCB0byBib3RoXG4gICAgLy8gbGlzdHMgYW5kIHRha2UgYWR2YW50YWdlIG9mIHN0cnVjdHVyYWwgc2hhcmluZy5cbiAgICAvLyBUT0RPOiBQYXNzIGBjdXJyZW50YCBhcyBhcmd1bWVudFxuXG4gICAgdmFyIGN1cnJlbnQgPSB3b3JrSW5Qcm9ncmVzcy5hbHRlcm5hdGU7XG5cbiAgICBpZiAoY3VycmVudCAhPT0gbnVsbCkge1xuICAgICAgLy8gVGhpcyBpcyBhbHdheXMgbm9uLW51bGwgb24gYSBDbGFzc0NvbXBvbmVudCBvciBIb3N0Um9vdFxuICAgICAgdmFyIGN1cnJlbnRRdWV1ZSA9IGN1cnJlbnQudXBkYXRlUXVldWU7XG4gICAgICB2YXIgY3VycmVudExhc3RCYXNlVXBkYXRlID0gY3VycmVudFF1ZXVlLmxhc3RCYXNlVXBkYXRlO1xuXG4gICAgICBpZiAoY3VycmVudExhc3RCYXNlVXBkYXRlICE9PSBsYXN0QmFzZVVwZGF0ZSkge1xuICAgICAgICBpZiAoY3VycmVudExhc3RCYXNlVXBkYXRlID09PSBudWxsKSB7XG4gICAgICAgICAgY3VycmVudFF1ZXVlLmZpcnN0QmFzZVVwZGF0ZSA9IGZpcnN0UGVuZGluZ1VwZGF0ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjdXJyZW50TGFzdEJhc2VVcGRhdGUubmV4dCA9IGZpcnN0UGVuZGluZ1VwZGF0ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGN1cnJlbnRRdWV1ZS5sYXN0QmFzZVVwZGF0ZSA9IGxhc3RQZW5kaW5nVXBkYXRlO1xuICAgICAgfVxuICAgIH1cbiAgfSAvLyBUaGVzZSB2YWx1ZXMgbWF5IGNoYW5nZSBhcyB3ZSBwcm9jZXNzIHRoZSBxdWV1ZS5cblxuXG4gIGlmIChmaXJzdEJhc2VVcGRhdGUgIT09IG51bGwpIHtcbiAgICAvLyBJdGVyYXRlIHRocm91Z2ggdGhlIGxpc3Qgb2YgdXBkYXRlcyB0byBjb21wdXRlIHRoZSByZXN1bHQuXG4gICAgdmFyIG5ld1N0YXRlID0gcXVldWUuYmFzZVN0YXRlOyAvLyBUT0RPOiBEb24ndCBuZWVkIHRvIGFjY3VtdWxhdGUgdGhpcy4gSW5zdGVhZCwgd2UgY2FuIHJlbW92ZSByZW5kZXJMYW5lc1xuICAgIC8vIGZyb20gdGhlIG9yaWdpbmFsIGxhbmVzLlxuXG4gICAgdmFyIG5ld0xhbmVzID0gTm9MYW5lcztcbiAgICB2YXIgbmV3QmFzZVN0YXRlID0gbnVsbDtcbiAgICB2YXIgbmV3Rmlyc3RCYXNlVXBkYXRlID0gbnVsbDtcbiAgICB2YXIgbmV3TGFzdEJhc2VVcGRhdGUgPSBudWxsO1xuICAgIHZhciB1cGRhdGUgPSBmaXJzdEJhc2VVcGRhdGU7XG5cbiAgICBkbyB7XG4gICAgICB2YXIgdXBkYXRlTGFuZSA9IHVwZGF0ZS5sYW5lO1xuICAgICAgdmFyIHVwZGF0ZUV2ZW50VGltZSA9IHVwZGF0ZS5ldmVudFRpbWU7XG5cbiAgICAgIGlmICghaXNTdWJzZXRPZkxhbmVzKHJlbmRlckxhbmVzLCB1cGRhdGVMYW5lKSkge1xuICAgICAgICAvLyBQcmlvcml0eSBpcyBpbnN1ZmZpY2llbnQuIFNraXAgdGhpcyB1cGRhdGUuIElmIHRoaXMgaXMgdGhlIGZpcnN0XG4gICAgICAgIC8vIHNraXBwZWQgdXBkYXRlLCB0aGUgcHJldmlvdXMgdXBkYXRlL3N0YXRlIGlzIHRoZSBuZXcgYmFzZVxuICAgICAgICAvLyB1cGRhdGUvc3RhdGUuXG4gICAgICAgIHZhciBjbG9uZSA9IHtcbiAgICAgICAgICBldmVudFRpbWU6IHVwZGF0ZUV2ZW50VGltZSxcbiAgICAgICAgICBsYW5lOiB1cGRhdGVMYW5lLFxuICAgICAgICAgIHRhZzogdXBkYXRlLnRhZyxcbiAgICAgICAgICBwYXlsb2FkOiB1cGRhdGUucGF5bG9hZCxcbiAgICAgICAgICBjYWxsYmFjazogdXBkYXRlLmNhbGxiYWNrLFxuICAgICAgICAgIG5leHQ6IG51bGxcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAobmV3TGFzdEJhc2VVcGRhdGUgPT09IG51bGwpIHtcbiAgICAgICAgICBuZXdGaXJzdEJhc2VVcGRhdGUgPSBuZXdMYXN0QmFzZVVwZGF0ZSA9IGNsb25lO1xuICAgICAgICAgIG5ld0Jhc2VTdGF0ZSA9IG5ld1N0YXRlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5ld0xhc3RCYXNlVXBkYXRlID0gbmV3TGFzdEJhc2VVcGRhdGUubmV4dCA9IGNsb25lO1xuICAgICAgICB9IC8vIFVwZGF0ZSB0aGUgcmVtYWluaW5nIHByaW9yaXR5IGluIHRoZSBxdWV1ZS5cblxuXG4gICAgICAgIG5ld0xhbmVzID0gbWVyZ2VMYW5lcyhuZXdMYW5lcywgdXBkYXRlTGFuZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBUaGlzIHVwZGF0ZSBkb2VzIGhhdmUgc3VmZmljaWVudCBwcmlvcml0eS5cbiAgICAgICAgaWYgKG5ld0xhc3RCYXNlVXBkYXRlICE9PSBudWxsKSB7XG4gICAgICAgICAgdmFyIF9jbG9uZSA9IHtcbiAgICAgICAgICAgIGV2ZW50VGltZTogdXBkYXRlRXZlbnRUaW1lLFxuICAgICAgICAgICAgLy8gVGhpcyB1cGRhdGUgaXMgZ29pbmcgdG8gYmUgY29tbWl0dGVkIHNvIHdlIG5ldmVyIHdhbnQgdW5jb21taXRcbiAgICAgICAgICAgIC8vIGl0LiBVc2luZyBOb0xhbmUgd29ya3MgYmVjYXVzZSAwIGlzIGEgc3Vic2V0IG9mIGFsbCBiaXRtYXNrcywgc29cbiAgICAgICAgICAgIC8vIHRoaXMgd2lsbCBuZXZlciBiZSBza2lwcGVkIGJ5IHRoZSBjaGVjayBhYm92ZS5cbiAgICAgICAgICAgIGxhbmU6IE5vTGFuZSxcbiAgICAgICAgICAgIHRhZzogdXBkYXRlLnRhZyxcbiAgICAgICAgICAgIHBheWxvYWQ6IHVwZGF0ZS5wYXlsb2FkLFxuICAgICAgICAgICAgY2FsbGJhY2s6IHVwZGF0ZS5jYWxsYmFjayxcbiAgICAgICAgICAgIG5leHQ6IG51bGxcbiAgICAgICAgICB9O1xuICAgICAgICAgIG5ld0xhc3RCYXNlVXBkYXRlID0gbmV3TGFzdEJhc2VVcGRhdGUubmV4dCA9IF9jbG9uZTtcbiAgICAgICAgfSAvLyBQcm9jZXNzIHRoaXMgdXBkYXRlLlxuXG5cbiAgICAgICAgbmV3U3RhdGUgPSBnZXRTdGF0ZUZyb21VcGRhdGUod29ya0luUHJvZ3Jlc3MsIHF1ZXVlLCB1cGRhdGUsIG5ld1N0YXRlLCBwcm9wcywgaW5zdGFuY2UpO1xuICAgICAgICB2YXIgY2FsbGJhY2sgPSB1cGRhdGUuY2FsbGJhY2s7XG5cbiAgICAgICAgaWYgKGNhbGxiYWNrICE9PSBudWxsKSB7XG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gQ2FsbGJhY2s7XG4gICAgICAgICAgdmFyIGVmZmVjdHMgPSBxdWV1ZS5lZmZlY3RzO1xuXG4gICAgICAgICAgaWYgKGVmZmVjdHMgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHF1ZXVlLmVmZmVjdHMgPSBbdXBkYXRlXTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZWZmZWN0cy5wdXNoKHVwZGF0ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHVwZGF0ZSA9IHVwZGF0ZS5uZXh0O1xuXG4gICAgICBpZiAodXBkYXRlID09PSBudWxsKSB7XG4gICAgICAgIHBlbmRpbmdRdWV1ZSA9IHF1ZXVlLnNoYXJlZC5wZW5kaW5nO1xuXG4gICAgICAgIGlmIChwZW5kaW5nUXVldWUgPT09IG51bGwpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBBbiB1cGRhdGUgd2FzIHNjaGVkdWxlZCBmcm9tIGluc2lkZSBhIHJlZHVjZXIuIEFkZCB0aGUgbmV3XG4gICAgICAgICAgLy8gcGVuZGluZyB1cGRhdGVzIHRvIHRoZSBlbmQgb2YgdGhlIGxpc3QgYW5kIGtlZXAgcHJvY2Vzc2luZy5cbiAgICAgICAgICB2YXIgX2xhc3RQZW5kaW5nVXBkYXRlID0gcGVuZGluZ1F1ZXVlOyAvLyBJbnRlbnRpb25hbGx5IHVuc291bmQuIFBlbmRpbmcgdXBkYXRlcyBmb3JtIGEgY2lyY3VsYXIgbGlzdCwgYnV0IHdlXG4gICAgICAgICAgLy8gdW5yYXZlbCB0aGVtIHdoZW4gdHJhbnNmZXJyaW5nIHRoZW0gdG8gdGhlIGJhc2UgcXVldWUuXG5cbiAgICAgICAgICB2YXIgX2ZpcnN0UGVuZGluZ1VwZGF0ZSA9IF9sYXN0UGVuZGluZ1VwZGF0ZS5uZXh0O1xuICAgICAgICAgIF9sYXN0UGVuZGluZ1VwZGF0ZS5uZXh0ID0gbnVsbDtcbiAgICAgICAgICB1cGRhdGUgPSBfZmlyc3RQZW5kaW5nVXBkYXRlO1xuICAgICAgICAgIHF1ZXVlLmxhc3RCYXNlVXBkYXRlID0gX2xhc3RQZW5kaW5nVXBkYXRlO1xuICAgICAgICAgIHF1ZXVlLnNoYXJlZC5wZW5kaW5nID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gd2hpbGUgKHRydWUpO1xuXG4gICAgaWYgKG5ld0xhc3RCYXNlVXBkYXRlID09PSBudWxsKSB7XG4gICAgICBuZXdCYXNlU3RhdGUgPSBuZXdTdGF0ZTtcbiAgICB9XG5cbiAgICBxdWV1ZS5iYXNlU3RhdGUgPSBuZXdCYXNlU3RhdGU7XG4gICAgcXVldWUuZmlyc3RCYXNlVXBkYXRlID0gbmV3Rmlyc3RCYXNlVXBkYXRlO1xuICAgIHF1ZXVlLmxhc3RCYXNlVXBkYXRlID0gbmV3TGFzdEJhc2VVcGRhdGU7IC8vIFNldCB0aGUgcmVtYWluaW5nIGV4cGlyYXRpb24gdGltZSB0byBiZSB3aGF0ZXZlciBpcyByZW1haW5pbmcgaW4gdGhlIHF1ZXVlLlxuICAgIC8vIFRoaXMgc2hvdWxkIGJlIGZpbmUgYmVjYXVzZSB0aGUgb25seSB0d28gb3RoZXIgdGhpbmdzIHRoYXQgY29udHJpYnV0ZSB0b1xuICAgIC8vIGV4cGlyYXRpb24gdGltZSBhcmUgcHJvcHMgYW5kIGNvbnRleHQuIFdlJ3JlIGFscmVhZHkgaW4gdGhlIG1pZGRsZSBvZiB0aGVcbiAgICAvLyBiZWdpbiBwaGFzZSBieSB0aGUgdGltZSB3ZSBzdGFydCBwcm9jZXNzaW5nIHRoZSBxdWV1ZSwgc28gd2UndmUgYWxyZWFkeVxuICAgIC8vIGRlYWx0IHdpdGggdGhlIHByb3BzLiBDb250ZXh0IGluIGNvbXBvbmVudHMgdGhhdCBzcGVjaWZ5XG4gICAgLy8gc2hvdWxkQ29tcG9uZW50VXBkYXRlIGlzIHRyaWNreTsgYnV0IHdlJ2xsIGhhdmUgdG8gYWNjb3VudCBmb3JcbiAgICAvLyB0aGF0IHJlZ2FyZGxlc3MuXG5cbiAgICBtYXJrU2tpcHBlZFVwZGF0ZUxhbmVzKG5ld0xhbmVzKTtcbiAgICB3b3JrSW5Qcm9ncmVzcy5sYW5lcyA9IG5ld0xhbmVzO1xuICAgIHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSBuZXdTdGF0ZTtcbiAgfVxuXG4gIHtcbiAgICBjdXJyZW50bHlQcm9jZXNzaW5nUXVldWUgPSBudWxsO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNhbGxDYWxsYmFjayhjYWxsYmFjaywgY29udGV4dCkge1xuICBpZiAoISh0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicpKSB7XG4gICAge1xuICAgICAgdGhyb3cgRXJyb3IoIFwiSW52YWxpZCBhcmd1bWVudCBwYXNzZWQgYXMgY2FsbGJhY2suIEV4cGVjdGVkIGEgZnVuY3Rpb24uIEluc3RlYWQgcmVjZWl2ZWQ6IFwiICsgY2FsbGJhY2sgKTtcbiAgICB9XG4gIH1cblxuICBjYWxsYmFjay5jYWxsKGNvbnRleHQpO1xufVxuXG5mdW5jdGlvbiByZXNldEhhc0ZvcmNlVXBkYXRlQmVmb3JlUHJvY2Vzc2luZygpIHtcbiAgaGFzRm9yY2VVcGRhdGUgPSBmYWxzZTtcbn1cbmZ1bmN0aW9uIGNoZWNrSGFzRm9yY2VVcGRhdGVBZnRlclByb2Nlc3NpbmcoKSB7XG4gIHJldHVybiBoYXNGb3JjZVVwZGF0ZTtcbn1cbmZ1bmN0aW9uIGNvbW1pdFVwZGF0ZVF1ZXVlKGZpbmlzaGVkV29yaywgZmluaXNoZWRRdWV1ZSwgaW5zdGFuY2UpIHtcbiAgLy8gQ29tbWl0IHRoZSBlZmZlY3RzXG4gIHZhciBlZmZlY3RzID0gZmluaXNoZWRRdWV1ZS5lZmZlY3RzO1xuICBmaW5pc2hlZFF1ZXVlLmVmZmVjdHMgPSBudWxsO1xuXG4gIGlmIChlZmZlY3RzICE9PSBudWxsKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlZmZlY3RzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgZWZmZWN0ID0gZWZmZWN0c1tpXTtcbiAgICAgIHZhciBjYWxsYmFjayA9IGVmZmVjdC5jYWxsYmFjaztcblxuICAgICAgaWYgKGNhbGxiYWNrICE9PSBudWxsKSB7XG4gICAgICAgIGVmZmVjdC5jYWxsYmFjayA9IG51bGw7XG4gICAgICAgIGNhbGxDYWxsYmFjayhjYWxsYmFjaywgaW5zdGFuY2UpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG52YXIgZmFrZUludGVybmFsSW5zdGFuY2UgPSB7fTtcbnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheTsgLy8gUmVhY3QuQ29tcG9uZW50IHVzZXMgYSBzaGFyZWQgZnJvemVuIG9iamVjdCBieSBkZWZhdWx0LlxuLy8gV2UnbGwgdXNlIGl0IHRvIGRldGVybWluZSB3aGV0aGVyIHdlIG5lZWQgdG8gaW5pdGlhbGl6ZSBsZWdhY3kgcmVmcy5cblxudmFyIGVtcHR5UmVmc09iamVjdCA9IG5ldyBSZWFjdC5Db21wb25lbnQoKS5yZWZzO1xudmFyIGRpZFdhcm5BYm91dFN0YXRlQXNzaWdubWVudEZvckNvbXBvbmVudDtcbnZhciBkaWRXYXJuQWJvdXRVbmluaXRpYWxpemVkU3RhdGU7XG52YXIgZGlkV2FybkFib3V0R2V0U25hcHNob3RCZWZvcmVVcGRhdGVXaXRob3V0RGlkVXBkYXRlO1xudmFyIGRpZFdhcm5BYm91dExlZ2FjeUxpZmVjeWNsZXNBbmREZXJpdmVkU3RhdGU7XG52YXIgZGlkV2FybkFib3V0VW5kZWZpbmVkRGVyaXZlZFN0YXRlO1xudmFyIHdhcm5PblVuZGVmaW5lZERlcml2ZWRTdGF0ZTtcbnZhciB3YXJuT25JbnZhbGlkQ2FsbGJhY2s7XG52YXIgZGlkV2FybkFib3V0RGlyZWN0bHlBc3NpZ25pbmdQcm9wc1RvU3RhdGU7XG52YXIgZGlkV2FybkFib3V0Q29udGV4dFR5cGVBbmRDb250ZXh0VHlwZXM7XG52YXIgZGlkV2FybkFib3V0SW52YWxpZGF0ZUNvbnRleHRUeXBlO1xuXG57XG4gIGRpZFdhcm5BYm91dFN0YXRlQXNzaWdubWVudEZvckNvbXBvbmVudCA9IG5ldyBTZXQoKTtcbiAgZGlkV2FybkFib3V0VW5pbml0aWFsaXplZFN0YXRlID0gbmV3IFNldCgpO1xuICBkaWRXYXJuQWJvdXRHZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZVdpdGhvdXREaWRVcGRhdGUgPSBuZXcgU2V0KCk7XG4gIGRpZFdhcm5BYm91dExlZ2FjeUxpZmVjeWNsZXNBbmREZXJpdmVkU3RhdGUgPSBuZXcgU2V0KCk7XG4gIGRpZFdhcm5BYm91dERpcmVjdGx5QXNzaWduaW5nUHJvcHNUb1N0YXRlID0gbmV3IFNldCgpO1xuICBkaWRXYXJuQWJvdXRVbmRlZmluZWREZXJpdmVkU3RhdGUgPSBuZXcgU2V0KCk7XG4gIGRpZFdhcm5BYm91dENvbnRleHRUeXBlQW5kQ29udGV4dFR5cGVzID0gbmV3IFNldCgpO1xuICBkaWRXYXJuQWJvdXRJbnZhbGlkYXRlQ29udGV4dFR5cGUgPSBuZXcgU2V0KCk7XG4gIHZhciBkaWRXYXJuT25JbnZhbGlkQ2FsbGJhY2sgPSBuZXcgU2V0KCk7XG5cbiAgd2Fybk9uSW52YWxpZENhbGxiYWNrID0gZnVuY3Rpb24gKGNhbGxiYWNrLCBjYWxsZXJOYW1lKSB7XG4gICAgaWYgKGNhbGxiYWNrID09PSBudWxsIHx8IHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBrZXkgPSBjYWxsZXJOYW1lICsgJ18nICsgY2FsbGJhY2s7XG5cbiAgICBpZiAoIWRpZFdhcm5PbkludmFsaWRDYWxsYmFjay5oYXMoa2V5KSkge1xuICAgICAgZGlkV2Fybk9uSW52YWxpZENhbGxiYWNrLmFkZChrZXkpO1xuXG4gICAgICBlcnJvcignJXMoLi4uKTogRXhwZWN0ZWQgdGhlIGxhc3Qgb3B0aW9uYWwgYGNhbGxiYWNrYCBhcmd1bWVudCB0byBiZSBhICcgKyAnZnVuY3Rpb24uIEluc3RlYWQgcmVjZWl2ZWQ6ICVzLicsIGNhbGxlck5hbWUsIGNhbGxiYWNrKTtcbiAgICB9XG4gIH07XG5cbiAgd2Fybk9uVW5kZWZpbmVkRGVyaXZlZFN0YXRlID0gZnVuY3Rpb24gKHR5cGUsIHBhcnRpYWxTdGF0ZSkge1xuICAgIGlmIChwYXJ0aWFsU3RhdGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lKHR5cGUpIHx8ICdDb21wb25lbnQnO1xuXG4gICAgICBpZiAoIWRpZFdhcm5BYm91dFVuZGVmaW5lZERlcml2ZWRTdGF0ZS5oYXMoY29tcG9uZW50TmFtZSkpIHtcbiAgICAgICAgZGlkV2FybkFib3V0VW5kZWZpbmVkRGVyaXZlZFN0YXRlLmFkZChjb21wb25lbnROYW1lKTtcblxuICAgICAgICBlcnJvcignJXMuZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzKCk6IEEgdmFsaWQgc3RhdGUgb2JqZWN0IChvciBudWxsKSBtdXN0IGJlIHJldHVybmVkLiAnICsgJ1lvdSBoYXZlIHJldHVybmVkIHVuZGVmaW5lZC4nLCBjb21wb25lbnROYW1lKTtcbiAgICAgIH1cbiAgICB9XG4gIH07IC8vIFRoaXMgaXMgc28gZ3Jvc3MgYnV0IGl0J3MgYXQgbGVhc3Qgbm9uLWNyaXRpY2FsIGFuZCBjYW4gYmUgcmVtb3ZlZCBpZlxuICAvLyBpdCBjYXVzZXMgcHJvYmxlbXMuIFRoaXMgaXMgbWVhbnQgdG8gZ2l2ZSBhIG5pY2VyIGVycm9yIG1lc3NhZ2UgZm9yXG4gIC8vIFJlYWN0RE9NMTUudW5zdGFibGVfcmVuZGVyU3VidHJlZUludG9Db250YWluZXIocmVhY3RET00xNkNvbXBvbmVudCxcbiAgLy8gLi4uKSkgd2hpY2ggb3RoZXJ3aXNlIHRocm93cyBhIFwiX3Byb2Nlc3NDaGlsZENvbnRleHQgaXMgbm90IGEgZnVuY3Rpb25cIlxuICAvLyBleGNlcHRpb24uXG5cblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZmFrZUludGVybmFsSW5zdGFuY2UsICdfcHJvY2Vzc0NoaWxkQ29udGV4dCcsIHtcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAge1xuICAgICAgICB7XG4gICAgICAgICAgdGhyb3cgRXJyb3IoIFwiX3Byb2Nlc3NDaGlsZENvbnRleHQgaXMgbm90IGF2YWlsYWJsZSBpbiBSZWFjdCAxNisuIFRoaXMgbGlrZWx5IG1lYW5zIHlvdSBoYXZlIG11bHRpcGxlIGNvcGllcyBvZiBSZWFjdCBhbmQgYXJlIGF0dGVtcHRpbmcgdG8gbmVzdCBhIFJlYWN0IDE1IHRyZWUgaW5zaWRlIGEgUmVhY3QgMTYgdHJlZSB1c2luZyB1bnN0YWJsZV9yZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lciwgd2hpY2ggaXNuJ3Qgc3VwcG9ydGVkLiBUcnkgdG8gbWFrZSBzdXJlIHlvdSBoYXZlIG9ubHkgb25lIGNvcHkgb2YgUmVhY3QgKGFuZCBpZGVhbGx5LCBzd2l0Y2ggdG8gUmVhY3RET00uY3JlYXRlUG9ydGFsKS5cIiApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgT2JqZWN0LmZyZWV6ZShmYWtlSW50ZXJuYWxJbnN0YW5jZSk7XG59XG5cbmZ1bmN0aW9uIGFwcGx5RGVyaXZlZFN0YXRlRnJvbVByb3BzKHdvcmtJblByb2dyZXNzLCBjdG9yLCBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMsIG5leHRQcm9wcykge1xuICB2YXIgcHJldlN0YXRlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTtcblxuICB7XG4gICAgaWYgKCB3b3JrSW5Qcm9ncmVzcy5tb2RlICYgU3RyaWN0TW9kZSkge1xuICAgICAgZGlzYWJsZUxvZ3MoKTtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gSW52b2tlIHRoZSBmdW5jdGlvbiBhbiBleHRyYSB0aW1lIHRvIGhlbHAgZGV0ZWN0IHNpZGUtZWZmZWN0cy5cbiAgICAgICAgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzKG5leHRQcm9wcywgcHJldlN0YXRlKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHJlZW5hYmxlTG9ncygpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHZhciBwYXJ0aWFsU3RhdGUgPSBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMobmV4dFByb3BzLCBwcmV2U3RhdGUpO1xuXG4gIHtcbiAgICB3YXJuT25VbmRlZmluZWREZXJpdmVkU3RhdGUoY3RvciwgcGFydGlhbFN0YXRlKTtcbiAgfSAvLyBNZXJnZSB0aGUgcGFydGlhbCBzdGF0ZSBhbmQgdGhlIHByZXZpb3VzIHN0YXRlLlxuXG5cbiAgdmFyIG1lbW9pemVkU3RhdGUgPSBwYXJ0aWFsU3RhdGUgPT09IG51bGwgfHwgcGFydGlhbFN0YXRlID09PSB1bmRlZmluZWQgPyBwcmV2U3RhdGUgOiBfYXNzaWduKHt9LCBwcmV2U3RhdGUsIHBhcnRpYWxTdGF0ZSk7XG4gIHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSBtZW1vaXplZFN0YXRlOyAvLyBPbmNlIHRoZSB1cGRhdGUgcXVldWUgaXMgZW1wdHksIHBlcnNpc3QgdGhlIGRlcml2ZWQgc3RhdGUgb250byB0aGVcbiAgLy8gYmFzZSBzdGF0ZS5cblxuICBpZiAod29ya0luUHJvZ3Jlc3MubGFuZXMgPT09IE5vTGFuZXMpIHtcbiAgICAvLyBRdWV1ZSBpcyBhbHdheXMgbm9uLW51bGwgZm9yIGNsYXNzZXNcbiAgICB2YXIgdXBkYXRlUXVldWUgPSB3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZTtcbiAgICB1cGRhdGVRdWV1ZS5iYXNlU3RhdGUgPSBtZW1vaXplZFN0YXRlO1xuICB9XG59XG52YXIgY2xhc3NDb21wb25lbnRVcGRhdGVyID0ge1xuICBpc01vdW50ZWQ6IGlzTW91bnRlZCxcbiAgZW5xdWV1ZVNldFN0YXRlOiBmdW5jdGlvbiAoaW5zdCwgcGF5bG9hZCwgY2FsbGJhY2spIHtcbiAgICB2YXIgZmliZXIgPSBnZXQoaW5zdCk7XG4gICAgdmFyIGV2ZW50VGltZSA9IHJlcXVlc3RFdmVudFRpbWUoKTtcbiAgICB2YXIgbGFuZSA9IHJlcXVlc3RVcGRhdGVMYW5lKGZpYmVyKTtcbiAgICB2YXIgdXBkYXRlID0gY3JlYXRlVXBkYXRlKGV2ZW50VGltZSwgbGFuZSk7XG4gICAgdXBkYXRlLnBheWxvYWQgPSBwYXlsb2FkO1xuXG4gICAgaWYgKGNhbGxiYWNrICE9PSB1bmRlZmluZWQgJiYgY2FsbGJhY2sgIT09IG51bGwpIHtcbiAgICAgIHtcbiAgICAgICAgd2Fybk9uSW52YWxpZENhbGxiYWNrKGNhbGxiYWNrLCAnc2V0U3RhdGUnKTtcbiAgICAgIH1cblxuICAgICAgdXBkYXRlLmNhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgfVxuXG4gICAgZW5xdWV1ZVVwZGF0ZShmaWJlciwgdXBkYXRlKTtcbiAgICBzY2hlZHVsZVVwZGF0ZU9uRmliZXIoZmliZXIsIGxhbmUsIGV2ZW50VGltZSk7XG4gIH0sXG4gIGVucXVldWVSZXBsYWNlU3RhdGU6IGZ1bmN0aW9uIChpbnN0LCBwYXlsb2FkLCBjYWxsYmFjaykge1xuICAgIHZhciBmaWJlciA9IGdldChpbnN0KTtcbiAgICB2YXIgZXZlbnRUaW1lID0gcmVxdWVzdEV2ZW50VGltZSgpO1xuICAgIHZhciBsYW5lID0gcmVxdWVzdFVwZGF0ZUxhbmUoZmliZXIpO1xuICAgIHZhciB1cGRhdGUgPSBjcmVhdGVVcGRhdGUoZXZlbnRUaW1lLCBsYW5lKTtcbiAgICB1cGRhdGUudGFnID0gUmVwbGFjZVN0YXRlO1xuICAgIHVwZGF0ZS5wYXlsb2FkID0gcGF5bG9hZDtcblxuICAgIGlmIChjYWxsYmFjayAhPT0gdW5kZWZpbmVkICYmIGNhbGxiYWNrICE9PSBudWxsKSB7XG4gICAgICB7XG4gICAgICAgIHdhcm5PbkludmFsaWRDYWxsYmFjayhjYWxsYmFjaywgJ3JlcGxhY2VTdGF0ZScpO1xuICAgICAgfVxuXG4gICAgICB1cGRhdGUuY2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICB9XG5cbiAgICBlbnF1ZXVlVXBkYXRlKGZpYmVyLCB1cGRhdGUpO1xuICAgIHNjaGVkdWxlVXBkYXRlT25GaWJlcihmaWJlciwgbGFuZSwgZXZlbnRUaW1lKTtcbiAgfSxcbiAgZW5xdWV1ZUZvcmNlVXBkYXRlOiBmdW5jdGlvbiAoaW5zdCwgY2FsbGJhY2spIHtcbiAgICB2YXIgZmliZXIgPSBnZXQoaW5zdCk7XG4gICAgdmFyIGV2ZW50VGltZSA9IHJlcXVlc3RFdmVudFRpbWUoKTtcbiAgICB2YXIgbGFuZSA9IHJlcXVlc3RVcGRhdGVMYW5lKGZpYmVyKTtcbiAgICB2YXIgdXBkYXRlID0gY3JlYXRlVXBkYXRlKGV2ZW50VGltZSwgbGFuZSk7XG4gICAgdXBkYXRlLnRhZyA9IEZvcmNlVXBkYXRlO1xuXG4gICAgaWYgKGNhbGxiYWNrICE9PSB1bmRlZmluZWQgJiYgY2FsbGJhY2sgIT09IG51bGwpIHtcbiAgICAgIHtcbiAgICAgICAgd2Fybk9uSW52YWxpZENhbGxiYWNrKGNhbGxiYWNrLCAnZm9yY2VVcGRhdGUnKTtcbiAgICAgIH1cblxuICAgICAgdXBkYXRlLmNhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgfVxuXG4gICAgZW5xdWV1ZVVwZGF0ZShmaWJlciwgdXBkYXRlKTtcbiAgICBzY2hlZHVsZVVwZGF0ZU9uRmliZXIoZmliZXIsIGxhbmUsIGV2ZW50VGltZSk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGNoZWNrU2hvdWxkQ29tcG9uZW50VXBkYXRlKHdvcmtJblByb2dyZXNzLCBjdG9yLCBvbGRQcm9wcywgbmV3UHJvcHMsIG9sZFN0YXRlLCBuZXdTdGF0ZSwgbmV4dENvbnRleHQpIHtcbiAgdmFyIGluc3RhbmNlID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuXG4gIGlmICh0eXBlb2YgaW5zdGFuY2Uuc2hvdWxkQ29tcG9uZW50VXBkYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAge1xuICAgICAgaWYgKCB3b3JrSW5Qcm9ncmVzcy5tb2RlICYgU3RyaWN0TW9kZSkge1xuICAgICAgICBkaXNhYmxlTG9ncygpO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgLy8gSW52b2tlIHRoZSBmdW5jdGlvbiBhbiBleHRyYSB0aW1lIHRvIGhlbHAgZGV0ZWN0IHNpZGUtZWZmZWN0cy5cbiAgICAgICAgICBpbnN0YW5jZS5zaG91bGRDb21wb25lbnRVcGRhdGUobmV3UHJvcHMsIG5ld1N0YXRlLCBuZXh0Q29udGV4dCk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgcmVlbmFibGVMb2dzKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgc2hvdWxkVXBkYXRlID0gaW5zdGFuY2Uuc2hvdWxkQ29tcG9uZW50VXBkYXRlKG5ld1Byb3BzLCBuZXdTdGF0ZSwgbmV4dENvbnRleHQpO1xuXG4gICAge1xuICAgICAgaWYgKHNob3VsZFVwZGF0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGVycm9yKCclcy5zaG91bGRDb21wb25lbnRVcGRhdGUoKTogUmV0dXJuZWQgdW5kZWZpbmVkIGluc3RlYWQgb2YgYSAnICsgJ2Jvb2xlYW4gdmFsdWUuIE1ha2Ugc3VyZSB0byByZXR1cm4gdHJ1ZSBvciBmYWxzZS4nLCBnZXRDb21wb25lbnROYW1lKGN0b3IpIHx8ICdDb21wb25lbnQnKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gc2hvdWxkVXBkYXRlO1xuICB9XG5cbiAgaWYgKGN0b3IucHJvdG90eXBlICYmIGN0b3IucHJvdG90eXBlLmlzUHVyZVJlYWN0Q29tcG9uZW50KSB7XG4gICAgcmV0dXJuICFzaGFsbG93RXF1YWwob2xkUHJvcHMsIG5ld1Byb3BzKSB8fCAhc2hhbGxvd0VxdWFsKG9sZFN0YXRlLCBuZXdTdGF0ZSk7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gY2hlY2tDbGFzc0luc3RhbmNlKHdvcmtJblByb2dyZXNzLCBjdG9yLCBuZXdQcm9wcykge1xuICB2YXIgaW5zdGFuY2UgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG5cbiAge1xuICAgIHZhciBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZShjdG9yKSB8fCAnQ29tcG9uZW50JztcbiAgICB2YXIgcmVuZGVyUHJlc2VudCA9IGluc3RhbmNlLnJlbmRlcjtcblxuICAgIGlmICghcmVuZGVyUHJlc2VudCkge1xuICAgICAgaWYgKGN0b3IucHJvdG90eXBlICYmIHR5cGVvZiBjdG9yLnByb3RvdHlwZS5yZW5kZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgZXJyb3IoJyVzKC4uLik6IE5vIGByZW5kZXJgIG1ldGhvZCBmb3VuZCBvbiB0aGUgcmV0dXJuZWQgY29tcG9uZW50ICcgKyAnaW5zdGFuY2U6IGRpZCB5b3UgYWNjaWRlbnRhbGx5IHJldHVybiBhbiBvYmplY3QgZnJvbSB0aGUgY29uc3RydWN0b3I/JywgbmFtZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlcnJvcignJXMoLi4uKTogTm8gYHJlbmRlcmAgbWV0aG9kIGZvdW5kIG9uIHRoZSByZXR1cm5lZCBjb21wb25lbnQgJyArICdpbnN0YW5jZTogeW91IG1heSBoYXZlIGZvcmdvdHRlbiB0byBkZWZpbmUgYHJlbmRlcmAuJywgbmFtZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGluc3RhbmNlLmdldEluaXRpYWxTdGF0ZSAmJiAhaW5zdGFuY2UuZ2V0SW5pdGlhbFN0YXRlLmlzUmVhY3RDbGFzc0FwcHJvdmVkICYmICFpbnN0YW5jZS5zdGF0ZSkge1xuICAgICAgZXJyb3IoJ2dldEluaXRpYWxTdGF0ZSB3YXMgZGVmaW5lZCBvbiAlcywgYSBwbGFpbiBKYXZhU2NyaXB0IGNsYXNzLiAnICsgJ1RoaXMgaXMgb25seSBzdXBwb3J0ZWQgZm9yIGNsYXNzZXMgY3JlYXRlZCB1c2luZyBSZWFjdC5jcmVhdGVDbGFzcy4gJyArICdEaWQgeW91IG1lYW4gdG8gZGVmaW5lIGEgc3RhdGUgcHJvcGVydHkgaW5zdGVhZD8nLCBuYW1lKTtcbiAgICB9XG5cbiAgICBpZiAoaW5zdGFuY2UuZ2V0RGVmYXVsdFByb3BzICYmICFpbnN0YW5jZS5nZXREZWZhdWx0UHJvcHMuaXNSZWFjdENsYXNzQXBwcm92ZWQpIHtcbiAgICAgIGVycm9yKCdnZXREZWZhdWx0UHJvcHMgd2FzIGRlZmluZWQgb24gJXMsIGEgcGxhaW4gSmF2YVNjcmlwdCBjbGFzcy4gJyArICdUaGlzIGlzIG9ubHkgc3VwcG9ydGVkIGZvciBjbGFzc2VzIGNyZWF0ZWQgdXNpbmcgUmVhY3QuY3JlYXRlQ2xhc3MuICcgKyAnVXNlIGEgc3RhdGljIHByb3BlcnR5IHRvIGRlZmluZSBkZWZhdWx0UHJvcHMgaW5zdGVhZC4nLCBuYW1lKTtcbiAgICB9XG5cbiAgICBpZiAoaW5zdGFuY2UucHJvcFR5cGVzKSB7XG4gICAgICBlcnJvcigncHJvcFR5cGVzIHdhcyBkZWZpbmVkIGFzIGFuIGluc3RhbmNlIHByb3BlcnR5IG9uICVzLiBVc2UgYSBzdGF0aWMgJyArICdwcm9wZXJ0eSB0byBkZWZpbmUgcHJvcFR5cGVzIGluc3RlYWQuJywgbmFtZSk7XG4gICAgfVxuXG4gICAgaWYgKGluc3RhbmNlLmNvbnRleHRUeXBlKSB7XG4gICAgICBlcnJvcignY29udGV4dFR5cGUgd2FzIGRlZmluZWQgYXMgYW4gaW5zdGFuY2UgcHJvcGVydHkgb24gJXMuIFVzZSBhIHN0YXRpYyAnICsgJ3Byb3BlcnR5IHRvIGRlZmluZSBjb250ZXh0VHlwZSBpbnN0ZWFkLicsIG5hbWUpO1xuICAgIH1cblxuICAgIHtcbiAgICAgIGlmIChpbnN0YW5jZS5jb250ZXh0VHlwZXMpIHtcbiAgICAgICAgZXJyb3IoJ2NvbnRleHRUeXBlcyB3YXMgZGVmaW5lZCBhcyBhbiBpbnN0YW5jZSBwcm9wZXJ0eSBvbiAlcy4gVXNlIGEgc3RhdGljICcgKyAncHJvcGVydHkgdG8gZGVmaW5lIGNvbnRleHRUeXBlcyBpbnN0ZWFkLicsIG5hbWUpO1xuICAgICAgfVxuXG4gICAgICBpZiAoY3Rvci5jb250ZXh0VHlwZSAmJiBjdG9yLmNvbnRleHRUeXBlcyAmJiAhZGlkV2FybkFib3V0Q29udGV4dFR5cGVBbmRDb250ZXh0VHlwZXMuaGFzKGN0b3IpKSB7XG4gICAgICAgIGRpZFdhcm5BYm91dENvbnRleHRUeXBlQW5kQ29udGV4dFR5cGVzLmFkZChjdG9yKTtcblxuICAgICAgICBlcnJvcignJXMgZGVjbGFyZXMgYm90aCBjb250ZXh0VHlwZXMgYW5kIGNvbnRleHRUeXBlIHN0YXRpYyBwcm9wZXJ0aWVzLiAnICsgJ1RoZSBsZWdhY3kgY29udGV4dFR5cGVzIHByb3BlcnR5IHdpbGwgYmUgaWdub3JlZC4nLCBuYW1lKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFNob3VsZFVwZGF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgZXJyb3IoJyVzIGhhcyBhIG1ldGhvZCBjYWxsZWQgJyArICdjb21wb25lbnRTaG91bGRVcGRhdGUoKS4gRGlkIHlvdSBtZWFuIHNob3VsZENvbXBvbmVudFVwZGF0ZSgpPyAnICsgJ1RoZSBuYW1lIGlzIHBocmFzZWQgYXMgYSBxdWVzdGlvbiBiZWNhdXNlIHRoZSBmdW5jdGlvbiBpcyAnICsgJ2V4cGVjdGVkIHRvIHJldHVybiBhIHZhbHVlLicsIG5hbWUpO1xuICAgIH1cblxuICAgIGlmIChjdG9yLnByb3RvdHlwZSAmJiBjdG9yLnByb3RvdHlwZS5pc1B1cmVSZWFjdENvbXBvbmVudCAmJiB0eXBlb2YgaW5zdGFuY2Uuc2hvdWxkQ29tcG9uZW50VXBkYXRlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgZXJyb3IoJyVzIGhhcyBhIG1ldGhvZCBjYWxsZWQgc2hvdWxkQ29tcG9uZW50VXBkYXRlKCkuICcgKyAnc2hvdWxkQ29tcG9uZW50VXBkYXRlIHNob3VsZCBub3QgYmUgdXNlZCB3aGVuIGV4dGVuZGluZyBSZWFjdC5QdXJlQ29tcG9uZW50LiAnICsgJ1BsZWFzZSBleHRlbmQgUmVhY3QuQ29tcG9uZW50IGlmIHNob3VsZENvbXBvbmVudFVwZGF0ZSBpcyB1c2VkLicsIGdldENvbXBvbmVudE5hbWUoY3RvcikgfHwgJ0EgcHVyZSBjb21wb25lbnQnKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudERpZFVubW91bnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGVycm9yKCclcyBoYXMgYSBtZXRob2QgY2FsbGVkICcgKyAnY29tcG9uZW50RGlkVW5tb3VudCgpLiBCdXQgdGhlcmUgaXMgbm8gc3VjaCBsaWZlY3ljbGUgbWV0aG9kLiAnICsgJ0RpZCB5b3UgbWVhbiBjb21wb25lbnRXaWxsVW5tb3VudCgpPycsIG5hbWUpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50RGlkUmVjZWl2ZVByb3BzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBlcnJvcignJXMgaGFzIGEgbWV0aG9kIGNhbGxlZCAnICsgJ2NvbXBvbmVudERpZFJlY2VpdmVQcm9wcygpLiBCdXQgdGhlcmUgaXMgbm8gc3VjaCBsaWZlY3ljbGUgbWV0aG9kLiAnICsgJ0lmIHlvdSBtZWFudCB0byB1cGRhdGUgdGhlIHN0YXRlIGluIHJlc3BvbnNlIHRvIGNoYW5naW5nIHByb3BzLCAnICsgJ3VzZSBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKCkuIElmIHlvdSBtZWFudCB0byBmZXRjaCBkYXRhIG9yICcgKyAncnVuIHNpZGUtZWZmZWN0cyBvciBtdXRhdGlvbnMgYWZ0ZXIgUmVhY3QgaGFzIHVwZGF0ZWQgdGhlIFVJLCB1c2UgY29tcG9uZW50RGlkVXBkYXRlKCkuJywgbmFtZSk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnRXaWxsUmVjaWV2ZVByb3BzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBlcnJvcignJXMgaGFzIGEgbWV0aG9kIGNhbGxlZCAnICsgJ2NvbXBvbmVudFdpbGxSZWNpZXZlUHJvcHMoKS4gRGlkIHlvdSBtZWFuIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMoKT8nLCBuYW1lKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGluc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsUmVjaWV2ZVByb3BzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBlcnJvcignJXMgaGFzIGEgbWV0aG9kIGNhbGxlZCAnICsgJ1VOU0FGRV9jb21wb25lbnRXaWxsUmVjaWV2ZVByb3BzKCkuIERpZCB5b3UgbWVhbiBVTlNBRkVfY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcygpPycsIG5hbWUpO1xuICAgIH1cblxuICAgIHZhciBoYXNNdXRhdGVkUHJvcHMgPSBpbnN0YW5jZS5wcm9wcyAhPT0gbmV3UHJvcHM7XG5cbiAgICBpZiAoaW5zdGFuY2UucHJvcHMgIT09IHVuZGVmaW5lZCAmJiBoYXNNdXRhdGVkUHJvcHMpIHtcbiAgICAgIGVycm9yKCclcyguLi4pOiBXaGVuIGNhbGxpbmcgc3VwZXIoKSBpbiBgJXNgLCBtYWtlIHN1cmUgdG8gcGFzcyAnICsgXCJ1cCB0aGUgc2FtZSBwcm9wcyB0aGF0IHlvdXIgY29tcG9uZW50J3MgY29uc3RydWN0b3Igd2FzIHBhc3NlZC5cIiwgbmFtZSwgbmFtZSk7XG4gICAgfVxuXG4gICAgaWYgKGluc3RhbmNlLmRlZmF1bHRQcm9wcykge1xuICAgICAgZXJyb3IoJ1NldHRpbmcgZGVmYXVsdFByb3BzIGFzIGFuIGluc3RhbmNlIHByb3BlcnR5IG9uICVzIGlzIG5vdCBzdXBwb3J0ZWQgYW5kIHdpbGwgYmUgaWdub3JlZC4nICsgJyBJbnN0ZWFkLCBkZWZpbmUgZGVmYXVsdFByb3BzIGFzIGEgc3RhdGljIHByb3BlcnR5IG9uICVzLicsIG5hbWUsIG5hbWUpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudERpZFVwZGF0ZSAhPT0gJ2Z1bmN0aW9uJyAmJiAhZGlkV2FybkFib3V0R2V0U25hcHNob3RCZWZvcmVVcGRhdGVXaXRob3V0RGlkVXBkYXRlLmhhcyhjdG9yKSkge1xuICAgICAgZGlkV2FybkFib3V0R2V0U25hcHNob3RCZWZvcmVVcGRhdGVXaXRob3V0RGlkVXBkYXRlLmFkZChjdG9yKTtcblxuICAgICAgZXJyb3IoJyVzOiBnZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSgpIHNob3VsZCBiZSB1c2VkIHdpdGggY29tcG9uZW50RGlkVXBkYXRlKCkuICcgKyAnVGhpcyBjb21wb25lbnQgZGVmaW5lcyBnZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSgpIG9ubHkuJywgZ2V0Q29tcG9uZW50TmFtZShjdG9yKSk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGVycm9yKCclczogZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzKCkgaXMgZGVmaW5lZCBhcyBhbiBpbnN0YW5jZSBtZXRob2QgJyArICdhbmQgd2lsbCBiZSBpZ25vcmVkLiBJbnN0ZWFkLCBkZWNsYXJlIGl0IGFzIGEgc3RhdGljIG1ldGhvZC4nLCBuYW1lKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGluc3RhbmNlLmdldERlcml2ZWRTdGF0ZUZyb21FcnJvciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgZXJyb3IoJyVzOiBnZXREZXJpdmVkU3RhdGVGcm9tRXJyb3IoKSBpcyBkZWZpbmVkIGFzIGFuIGluc3RhbmNlIG1ldGhvZCAnICsgJ2FuZCB3aWxsIGJlIGlnbm9yZWQuIEluc3RlYWQsIGRlY2xhcmUgaXQgYXMgYSBzdGF0aWMgbWV0aG9kLicsIG5hbWUpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgY3Rvci5nZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgZXJyb3IoJyVzOiBnZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSgpIGlzIGRlZmluZWQgYXMgYSBzdGF0aWMgbWV0aG9kICcgKyAnYW5kIHdpbGwgYmUgaWdub3JlZC4gSW5zdGVhZCwgZGVjbGFyZSBpdCBhcyBhbiBpbnN0YW5jZSBtZXRob2QuJywgbmFtZSk7XG4gICAgfVxuXG4gICAgdmFyIF9zdGF0ZSA9IGluc3RhbmNlLnN0YXRlO1xuXG4gICAgaWYgKF9zdGF0ZSAmJiAodHlwZW9mIF9zdGF0ZSAhPT0gJ29iamVjdCcgfHwgaXNBcnJheShfc3RhdGUpKSkge1xuICAgICAgZXJyb3IoJyVzLnN0YXRlOiBtdXN0IGJlIHNldCB0byBhbiBvYmplY3Qgb3IgbnVsbCcsIG5hbWUpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuZ2V0Q2hpbGRDb250ZXh0ID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBjdG9yLmNoaWxkQ29udGV4dFR5cGVzICE9PSAnb2JqZWN0Jykge1xuICAgICAgZXJyb3IoJyVzLmdldENoaWxkQ29udGV4dCgpOiBjaGlsZENvbnRleHRUeXBlcyBtdXN0IGJlIGRlZmluZWQgaW4gb3JkZXIgdG8gJyArICd1c2UgZ2V0Q2hpbGRDb250ZXh0KCkuJywgbmFtZSk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGFkb3B0Q2xhc3NJbnN0YW5jZSh3b3JrSW5Qcm9ncmVzcywgaW5zdGFuY2UpIHtcbiAgaW5zdGFuY2UudXBkYXRlciA9IGNsYXNzQ29tcG9uZW50VXBkYXRlcjtcbiAgd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlID0gaW5zdGFuY2U7IC8vIFRoZSBpbnN0YW5jZSBuZWVkcyBhY2Nlc3MgdG8gdGhlIGZpYmVyIHNvIHRoYXQgaXQgY2FuIHNjaGVkdWxlIHVwZGF0ZXNcblxuICBzZXQoaW5zdGFuY2UsIHdvcmtJblByb2dyZXNzKTtcblxuICB7XG4gICAgaW5zdGFuY2UuX3JlYWN0SW50ZXJuYWxJbnN0YW5jZSA9IGZha2VJbnRlcm5hbEluc3RhbmNlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNvbnN0cnVjdENsYXNzSW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MsIGN0b3IsIHByb3BzKSB7XG4gIHZhciBpc0xlZ2FjeUNvbnRleHRDb25zdW1lciA9IGZhbHNlO1xuICB2YXIgdW5tYXNrZWRDb250ZXh0ID0gZW1wdHlDb250ZXh0T2JqZWN0O1xuICB2YXIgY29udGV4dCA9IGVtcHR5Q29udGV4dE9iamVjdDtcbiAgdmFyIGNvbnRleHRUeXBlID0gY3Rvci5jb250ZXh0VHlwZTtcblxuICB7XG4gICAgaWYgKCdjb250ZXh0VHlwZScgaW4gY3Rvcikge1xuICAgICAgdmFyIGlzVmFsaWQgPSAvLyBBbGxvdyBudWxsIGZvciBjb25kaXRpb25hbCBkZWNsYXJhdGlvblxuICAgICAgY29udGV4dFR5cGUgPT09IG51bGwgfHwgY29udGV4dFR5cGUgIT09IHVuZGVmaW5lZCAmJiBjb250ZXh0VHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfQ09OVEVYVF9UWVBFICYmIGNvbnRleHRUeXBlLl9jb250ZXh0ID09PSB1bmRlZmluZWQ7IC8vIE5vdCBhIDxDb250ZXh0LkNvbnN1bWVyPlxuXG4gICAgICBpZiAoIWlzVmFsaWQgJiYgIWRpZFdhcm5BYm91dEludmFsaWRhdGVDb250ZXh0VHlwZS5oYXMoY3RvcikpIHtcbiAgICAgICAgZGlkV2FybkFib3V0SW52YWxpZGF0ZUNvbnRleHRUeXBlLmFkZChjdG9yKTtcbiAgICAgICAgdmFyIGFkZGVuZHVtID0gJyc7XG5cbiAgICAgICAgaWYgKGNvbnRleHRUeXBlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBhZGRlbmR1bSA9ICcgSG93ZXZlciwgaXQgaXMgc2V0IHRvIHVuZGVmaW5lZC4gJyArICdUaGlzIGNhbiBiZSBjYXVzZWQgYnkgYSB0eXBvIG9yIGJ5IG1peGluZyB1cCBuYW1lZCBhbmQgZGVmYXVsdCBpbXBvcnRzLiAnICsgJ1RoaXMgY2FuIGFsc28gaGFwcGVuIGR1ZSB0byBhIGNpcmN1bGFyIGRlcGVuZGVuY3ksIHNvICcgKyAndHJ5IG1vdmluZyB0aGUgY3JlYXRlQ29udGV4dCgpIGNhbGwgdG8gYSBzZXBhcmF0ZSBmaWxlLic7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGNvbnRleHRUeXBlICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgIGFkZGVuZHVtID0gJyBIb3dldmVyLCBpdCBpcyBzZXQgdG8gYSAnICsgdHlwZW9mIGNvbnRleHRUeXBlICsgJy4nO1xuICAgICAgICB9IGVsc2UgaWYgKGNvbnRleHRUeXBlLiQkdHlwZW9mID09PSBSRUFDVF9QUk9WSURFUl9UWVBFKSB7XG4gICAgICAgICAgYWRkZW5kdW0gPSAnIERpZCB5b3UgYWNjaWRlbnRhbGx5IHBhc3MgdGhlIENvbnRleHQuUHJvdmlkZXIgaW5zdGVhZD8nO1xuICAgICAgICB9IGVsc2UgaWYgKGNvbnRleHRUeXBlLl9jb250ZXh0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAvLyA8Q29udGV4dC5Db25zdW1lcj5cbiAgICAgICAgICBhZGRlbmR1bSA9ICcgRGlkIHlvdSBhY2NpZGVudGFsbHkgcGFzcyB0aGUgQ29udGV4dC5Db25zdW1lciBpbnN0ZWFkPyc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYWRkZW5kdW0gPSAnIEhvd2V2ZXIsIGl0IGlzIHNldCB0byBhbiBvYmplY3Qgd2l0aCBrZXlzIHsnICsgT2JqZWN0LmtleXMoY29udGV4dFR5cGUpLmpvaW4oJywgJykgKyAnfS4nO1xuICAgICAgICB9XG5cbiAgICAgICAgZXJyb3IoJyVzIGRlZmluZXMgYW4gaW52YWxpZCBjb250ZXh0VHlwZS4gJyArICdjb250ZXh0VHlwZSBzaG91bGQgcG9pbnQgdG8gdGhlIENvbnRleHQgb2JqZWN0IHJldHVybmVkIGJ5IFJlYWN0LmNyZWF0ZUNvbnRleHQoKS4lcycsIGdldENvbXBvbmVudE5hbWUoY3RvcikgfHwgJ0NvbXBvbmVudCcsIGFkZGVuZHVtKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAodHlwZW9mIGNvbnRleHRUeXBlID09PSAnb2JqZWN0JyAmJiBjb250ZXh0VHlwZSAhPT0gbnVsbCkge1xuICAgIGNvbnRleHQgPSByZWFkQ29udGV4dChjb250ZXh0VHlwZSk7XG4gIH0gZWxzZSB7XG4gICAgdW5tYXNrZWRDb250ZXh0ID0gZ2V0VW5tYXNrZWRDb250ZXh0KHdvcmtJblByb2dyZXNzLCBjdG9yLCB0cnVlKTtcbiAgICB2YXIgY29udGV4dFR5cGVzID0gY3Rvci5jb250ZXh0VHlwZXM7XG4gICAgaXNMZWdhY3lDb250ZXh0Q29uc3VtZXIgPSBjb250ZXh0VHlwZXMgIT09IG51bGwgJiYgY29udGV4dFR5cGVzICE9PSB1bmRlZmluZWQ7XG4gICAgY29udGV4dCA9IGlzTGVnYWN5Q29udGV4dENvbnN1bWVyID8gZ2V0TWFza2VkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgdW5tYXNrZWRDb250ZXh0KSA6IGVtcHR5Q29udGV4dE9iamVjdDtcbiAgfSAvLyBJbnN0YW50aWF0ZSB0d2ljZSB0byBoZWxwIGRldGVjdCBzaWRlLWVmZmVjdHMuXG5cblxuICB7XG4gICAgaWYgKCB3b3JrSW5Qcm9ncmVzcy5tb2RlICYgU3RyaWN0TW9kZSkge1xuICAgICAgZGlzYWJsZUxvZ3MoKTtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgbmV3IGN0b3IocHJvcHMsIGNvbnRleHQpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5ld1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgcmVlbmFibGVMb2dzKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdmFyIGluc3RhbmNlID0gbmV3IGN0b3IocHJvcHMsIGNvbnRleHQpO1xuICB2YXIgc3RhdGUgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID0gaW5zdGFuY2Uuc3RhdGUgIT09IG51bGwgJiYgaW5zdGFuY2Uuc3RhdGUgIT09IHVuZGVmaW5lZCA/IGluc3RhbmNlLnN0YXRlIDogbnVsbDtcbiAgYWRvcHRDbGFzc0luc3RhbmNlKHdvcmtJblByb2dyZXNzLCBpbnN0YW5jZSk7XG5cbiAge1xuICAgIGlmICh0eXBlb2YgY3Rvci5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMgPT09ICdmdW5jdGlvbicgJiYgc3RhdGUgPT09IG51bGwpIHtcbiAgICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZShjdG9yKSB8fCAnQ29tcG9uZW50JztcblxuICAgICAgaWYgKCFkaWRXYXJuQWJvdXRVbmluaXRpYWxpemVkU3RhdGUuaGFzKGNvbXBvbmVudE5hbWUpKSB7XG4gICAgICAgIGRpZFdhcm5BYm91dFVuaW5pdGlhbGl6ZWRTdGF0ZS5hZGQoY29tcG9uZW50TmFtZSk7XG5cbiAgICAgICAgZXJyb3IoJ2Alc2AgdXNlcyBgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzYCBidXQgaXRzIGluaXRpYWwgc3RhdGUgaXMgJyArICclcy4gVGhpcyBpcyBub3QgcmVjb21tZW5kZWQuIEluc3RlYWQsIGRlZmluZSB0aGUgaW5pdGlhbCBzdGF0ZSBieSAnICsgJ2Fzc2lnbmluZyBhbiBvYmplY3QgdG8gYHRoaXMuc3RhdGVgIGluIHRoZSBjb25zdHJ1Y3RvciBvZiBgJXNgLiAnICsgJ1RoaXMgZW5zdXJlcyB0aGF0IGBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHNgIGFyZ3VtZW50cyBoYXZlIGEgY29uc2lzdGVudCBzaGFwZS4nLCBjb21wb25lbnROYW1lLCBpbnN0YW5jZS5zdGF0ZSA9PT0gbnVsbCA/ICdudWxsJyA6ICd1bmRlZmluZWQnLCBjb21wb25lbnROYW1lKTtcbiAgICAgIH1cbiAgICB9IC8vIElmIG5ldyBjb21wb25lbnQgQVBJcyBhcmUgZGVmaW5lZCwgXCJ1bnNhZmVcIiBsaWZlY3ljbGVzIHdvbid0IGJlIGNhbGxlZC5cbiAgICAvLyBXYXJuIGFib3V0IHRoZXNlIGxpZmVjeWNsZXMgaWYgdGhleSBhcmUgcHJlc2VudC5cbiAgICAvLyBEb24ndCB3YXJuIGFib3V0IHJlYWN0LWxpZmVjeWNsZXMtY29tcGF0IHBvbHlmaWxsZWQgbWV0aG9kcyB0aG91Z2guXG5cblxuICAgIGlmICh0eXBlb2YgY3Rvci5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMgPT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIGluc3RhbmNlLmdldFNuYXBzaG90QmVmb3JlVXBkYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB2YXIgZm91bmRXaWxsTW91bnROYW1lID0gbnVsbDtcbiAgICAgIHZhciBmb3VuZFdpbGxSZWNlaXZlUHJvcHNOYW1lID0gbnVsbDtcbiAgICAgIHZhciBmb3VuZFdpbGxVcGRhdGVOYW1lID0gbnVsbDtcblxuICAgICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnRXaWxsTW91bnQgPT09ICdmdW5jdGlvbicgJiYgaW5zdGFuY2UuY29tcG9uZW50V2lsbE1vdW50Ll9fc3VwcHJlc3NEZXByZWNhdGlvbldhcm5pbmcgIT09IHRydWUpIHtcbiAgICAgICAgZm91bmRXaWxsTW91bnROYW1lID0gJ2NvbXBvbmVudFdpbGxNb3VudCc7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBpbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbE1vdW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGZvdW5kV2lsbE1vdW50TmFtZSA9ICdVTlNBRkVfY29tcG9uZW50V2lsbE1vdW50JztcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzID09PSAnZnVuY3Rpb24nICYmIGluc3RhbmNlLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMuX19zdXBwcmVzc0RlcHJlY2F0aW9uV2FybmluZyAhPT0gdHJ1ZSkge1xuICAgICAgICBmb3VuZFdpbGxSZWNlaXZlUHJvcHNOYW1lID0gJ2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMnO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgZm91bmRXaWxsUmVjZWl2ZVByb3BzTmFtZSA9ICdVTlNBRkVfY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyc7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50V2lsbFVwZGF0ZSA9PT0gJ2Z1bmN0aW9uJyAmJiBpbnN0YW5jZS5jb21wb25lbnRXaWxsVXBkYXRlLl9fc3VwcHJlc3NEZXByZWNhdGlvbldhcm5pbmcgIT09IHRydWUpIHtcbiAgICAgICAgZm91bmRXaWxsVXBkYXRlTmFtZSA9ICdjb21wb25lbnRXaWxsVXBkYXRlJztcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGluc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsVXBkYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGZvdW5kV2lsbFVwZGF0ZU5hbWUgPSAnVU5TQUZFX2NvbXBvbmVudFdpbGxVcGRhdGUnO1xuICAgICAgfVxuXG4gICAgICBpZiAoZm91bmRXaWxsTW91bnROYW1lICE9PSBudWxsIHx8IGZvdW5kV2lsbFJlY2VpdmVQcm9wc05hbWUgIT09IG51bGwgfHwgZm91bmRXaWxsVXBkYXRlTmFtZSAhPT0gbnVsbCkge1xuICAgICAgICB2YXIgX2NvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lKGN0b3IpIHx8ICdDb21wb25lbnQnO1xuXG4gICAgICAgIHZhciBuZXdBcGlOYW1lID0gdHlwZW9mIGN0b3IuZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzID09PSAnZnVuY3Rpb24nID8gJ2dldERlcml2ZWRTdGF0ZUZyb21Qcm9wcygpJyA6ICdnZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSgpJztcblxuICAgICAgICBpZiAoIWRpZFdhcm5BYm91dExlZ2FjeUxpZmVjeWNsZXNBbmREZXJpdmVkU3RhdGUuaGFzKF9jb21wb25lbnROYW1lKSkge1xuICAgICAgICAgIGRpZFdhcm5BYm91dExlZ2FjeUxpZmVjeWNsZXNBbmREZXJpdmVkU3RhdGUuYWRkKF9jb21wb25lbnROYW1lKTtcblxuICAgICAgICAgIGVycm9yKCdVbnNhZmUgbGVnYWN5IGxpZmVjeWNsZXMgd2lsbCBub3QgYmUgY2FsbGVkIGZvciBjb21wb25lbnRzIHVzaW5nIG5ldyBjb21wb25lbnQgQVBJcy5cXG5cXG4nICsgJyVzIHVzZXMgJXMgYnV0IGFsc28gY29udGFpbnMgdGhlIGZvbGxvd2luZyBsZWdhY3kgbGlmZWN5Y2xlczolcyVzJXNcXG5cXG4nICsgJ1RoZSBhYm92ZSBsaWZlY3ljbGVzIHNob3VsZCBiZSByZW1vdmVkLiBMZWFybiBtb3JlIGFib3V0IHRoaXMgd2FybmluZyBoZXJlOlxcbicgKyAnaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3Vuc2FmZS1jb21wb25lbnQtbGlmZWN5Y2xlcycsIF9jb21wb25lbnROYW1lLCBuZXdBcGlOYW1lLCBmb3VuZFdpbGxNb3VudE5hbWUgIT09IG51bGwgPyBcIlxcbiAgXCIgKyBmb3VuZFdpbGxNb3VudE5hbWUgOiAnJywgZm91bmRXaWxsUmVjZWl2ZVByb3BzTmFtZSAhPT0gbnVsbCA/IFwiXFxuICBcIiArIGZvdW5kV2lsbFJlY2VpdmVQcm9wc05hbWUgOiAnJywgZm91bmRXaWxsVXBkYXRlTmFtZSAhPT0gbnVsbCA/IFwiXFxuICBcIiArIGZvdW5kV2lsbFVwZGF0ZU5hbWUgOiAnJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0gLy8gQ2FjaGUgdW5tYXNrZWQgY29udGV4dCBzbyB3ZSBjYW4gYXZvaWQgcmVjcmVhdGluZyBtYXNrZWQgY29udGV4dCB1bmxlc3MgbmVjZXNzYXJ5LlxuICAvLyBSZWFjdEZpYmVyQ29udGV4dCB1c3VhbGx5IHVwZGF0ZXMgdGhpcyBjYWNoZSBidXQgY2FuJ3QgZm9yIG5ld2x5LWNyZWF0ZWQgaW5zdGFuY2VzLlxuXG5cbiAgaWYgKGlzTGVnYWN5Q29udGV4dENvbnN1bWVyKSB7XG4gICAgY2FjaGVDb250ZXh0KHdvcmtJblByb2dyZXNzLCB1bm1hc2tlZENvbnRleHQsIGNvbnRleHQpO1xuICB9XG5cbiAgcmV0dXJuIGluc3RhbmNlO1xufVxuXG5mdW5jdGlvbiBjYWxsQ29tcG9uZW50V2lsbE1vdW50KHdvcmtJblByb2dyZXNzLCBpbnN0YW5jZSkge1xuICB2YXIgb2xkU3RhdGUgPSBpbnN0YW5jZS5zdGF0ZTtcblxuICBpZiAodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFdpbGxNb3VudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGluc3RhbmNlLmNvbXBvbmVudFdpbGxNb3VudCgpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBpbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbE1vdW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudCgpO1xuICB9XG5cbiAgaWYgKG9sZFN0YXRlICE9PSBpbnN0YW5jZS5zdGF0ZSkge1xuICAgIHtcbiAgICAgIGVycm9yKCclcy5jb21wb25lbnRXaWxsTW91bnQoKTogQXNzaWduaW5nIGRpcmVjdGx5IHRvIHRoaXMuc3RhdGUgaXMgJyArIFwiZGVwcmVjYXRlZCAoZXhjZXB0IGluc2lkZSBhIGNvbXBvbmVudCdzIFwiICsgJ2NvbnN0cnVjdG9yKS4gVXNlIHNldFN0YXRlIGluc3RlYWQuJywgZ2V0Q29tcG9uZW50TmFtZSh3b3JrSW5Qcm9ncmVzcy50eXBlKSB8fCAnQ29tcG9uZW50Jyk7XG4gICAgfVxuXG4gICAgY2xhc3NDb21wb25lbnRVcGRhdGVyLmVucXVldWVSZXBsYWNlU3RhdGUoaW5zdGFuY2UsIGluc3RhbmNlLnN0YXRlLCBudWxsKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjYWxsQ29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyh3b3JrSW5Qcm9ncmVzcywgaW5zdGFuY2UsIG5ld1Byb3BzLCBuZXh0Q29udGV4dCkge1xuICB2YXIgb2xkU3RhdGUgPSBpbnN0YW5jZS5zdGF0ZTtcblxuICBpZiAodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICBpbnN0YW5jZS5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKG5ld1Byb3BzLCBuZXh0Q29udGV4dCk7XG4gIH1cblxuICBpZiAodHlwZW9mIGluc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMobmV3UHJvcHMsIG5leHRDb250ZXh0KTtcbiAgfVxuXG4gIGlmIChpbnN0YW5jZS5zdGF0ZSAhPT0gb2xkU3RhdGUpIHtcbiAgICB7XG4gICAgICB2YXIgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWUod29ya0luUHJvZ3Jlc3MudHlwZSkgfHwgJ0NvbXBvbmVudCc7XG5cbiAgICAgIGlmICghZGlkV2FybkFib3V0U3RhdGVBc3NpZ25tZW50Rm9yQ29tcG9uZW50Lmhhcyhjb21wb25lbnROYW1lKSkge1xuICAgICAgICBkaWRXYXJuQWJvdXRTdGF0ZUFzc2lnbm1lbnRGb3JDb21wb25lbnQuYWRkKGNvbXBvbmVudE5hbWUpO1xuXG4gICAgICAgIGVycm9yKCclcy5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKCk6IEFzc2lnbmluZyBkaXJlY3RseSB0byAnICsgXCJ0aGlzLnN0YXRlIGlzIGRlcHJlY2F0ZWQgKGV4Y2VwdCBpbnNpZGUgYSBjb21wb25lbnQncyBcIiArICdjb25zdHJ1Y3RvcikuIFVzZSBzZXRTdGF0ZSBpbnN0ZWFkLicsIGNvbXBvbmVudE5hbWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNsYXNzQ29tcG9uZW50VXBkYXRlci5lbnF1ZXVlUmVwbGFjZVN0YXRlKGluc3RhbmNlLCBpbnN0YW5jZS5zdGF0ZSwgbnVsbCk7XG4gIH1cbn0gLy8gSW52b2tlcyB0aGUgbW91bnQgbGlmZS1jeWNsZXMgb24gYSBwcmV2aW91c2x5IG5ldmVyIHJlbmRlcmVkIGluc3RhbmNlLlxuXG5cbmZ1bmN0aW9uIG1vdW50Q2xhc3NJbnN0YW5jZSh3b3JrSW5Qcm9ncmVzcywgY3RvciwgbmV3UHJvcHMsIHJlbmRlckxhbmVzKSB7XG4gIHtcbiAgICBjaGVja0NsYXNzSW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MsIGN0b3IsIG5ld1Byb3BzKTtcbiAgfVxuXG4gIHZhciBpbnN0YW5jZSA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcbiAgaW5zdGFuY2UucHJvcHMgPSBuZXdQcm9wcztcbiAgaW5zdGFuY2Uuc3RhdGUgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO1xuICBpbnN0YW5jZS5yZWZzID0gZW1wdHlSZWZzT2JqZWN0O1xuICBpbml0aWFsaXplVXBkYXRlUXVldWUod29ya0luUHJvZ3Jlc3MpO1xuICB2YXIgY29udGV4dFR5cGUgPSBjdG9yLmNvbnRleHRUeXBlO1xuXG4gIGlmICh0eXBlb2YgY29udGV4dFR5cGUgPT09ICdvYmplY3QnICYmIGNvbnRleHRUeXBlICE9PSBudWxsKSB7XG4gICAgaW5zdGFuY2UuY29udGV4dCA9IHJlYWRDb250ZXh0KGNvbnRleHRUeXBlKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgdW5tYXNrZWRDb250ZXh0ID0gZ2V0VW5tYXNrZWRDb250ZXh0KHdvcmtJblByb2dyZXNzLCBjdG9yLCB0cnVlKTtcbiAgICBpbnN0YW5jZS5jb250ZXh0ID0gZ2V0TWFza2VkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgdW5tYXNrZWRDb250ZXh0KTtcbiAgfVxuXG4gIHtcbiAgICBpZiAoaW5zdGFuY2Uuc3RhdGUgPT09IG5ld1Byb3BzKSB7XG4gICAgICB2YXIgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWUoY3RvcikgfHwgJ0NvbXBvbmVudCc7XG5cbiAgICAgIGlmICghZGlkV2FybkFib3V0RGlyZWN0bHlBc3NpZ25pbmdQcm9wc1RvU3RhdGUuaGFzKGNvbXBvbmVudE5hbWUpKSB7XG4gICAgICAgIGRpZFdhcm5BYm91dERpcmVjdGx5QXNzaWduaW5nUHJvcHNUb1N0YXRlLmFkZChjb21wb25lbnROYW1lKTtcblxuICAgICAgICBlcnJvcignJXM6IEl0IGlzIG5vdCByZWNvbW1lbmRlZCB0byBhc3NpZ24gcHJvcHMgZGlyZWN0bHkgdG8gc3RhdGUgJyArIFwiYmVjYXVzZSB1cGRhdGVzIHRvIHByb3BzIHdvbid0IGJlIHJlZmxlY3RlZCBpbiBzdGF0ZS4gXCIgKyAnSW4gbW9zdCBjYXNlcywgaXQgaXMgYmV0dGVyIHRvIHVzZSBwcm9wcyBkaXJlY3RseS4nLCBjb21wb25lbnROYW1lKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAod29ya0luUHJvZ3Jlc3MubW9kZSAmIFN0cmljdE1vZGUpIHtcbiAgICAgIFJlYWN0U3RyaWN0TW9kZVdhcm5pbmdzLnJlY29yZExlZ2FjeUNvbnRleHRXYXJuaW5nKHdvcmtJblByb2dyZXNzLCBpbnN0YW5jZSk7XG4gICAgfVxuXG4gICAge1xuICAgICAgUmVhY3RTdHJpY3RNb2RlV2FybmluZ3MucmVjb3JkVW5zYWZlTGlmZWN5Y2xlV2FybmluZ3Mod29ya0luUHJvZ3Jlc3MsIGluc3RhbmNlKTtcbiAgICB9XG4gIH1cblxuICBwcm9jZXNzVXBkYXRlUXVldWUod29ya0luUHJvZ3Jlc3MsIG5ld1Byb3BzLCBpbnN0YW5jZSwgcmVuZGVyTGFuZXMpO1xuICBpbnN0YW5jZS5zdGF0ZSA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7XG4gIHZhciBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMgPSBjdG9yLmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcztcblxuICBpZiAodHlwZW9mIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGFwcGx5RGVyaXZlZFN0YXRlRnJvbVByb3BzKHdvcmtJblByb2dyZXNzLCBjdG9yLCBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMsIG5ld1Byb3BzKTtcbiAgICBpbnN0YW5jZS5zdGF0ZSA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7XG4gIH0gLy8gSW4gb3JkZXIgdG8gc3VwcG9ydCByZWFjdC1saWZlY3ljbGVzLWNvbXBhdCBwb2x5ZmlsbGVkIGNvbXBvbmVudHMsXG4gIC8vIFVuc2FmZSBsaWZlY3ljbGVzIHNob3VsZCBub3QgYmUgaW52b2tlZCBmb3IgY29tcG9uZW50cyB1c2luZyB0aGUgbmV3IEFQSXMuXG5cblxuICBpZiAodHlwZW9mIGN0b3IuZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzICE9PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBpbnN0YW5jZS5nZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSAhPT0gJ2Z1bmN0aW9uJyAmJiAodHlwZW9mIGluc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsTW91bnQgPT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFdpbGxNb3VudCA9PT0gJ2Z1bmN0aW9uJykpIHtcbiAgICBjYWxsQ29tcG9uZW50V2lsbE1vdW50KHdvcmtJblByb2dyZXNzLCBpbnN0YW5jZSk7IC8vIElmIHdlIGhhZCBhZGRpdGlvbmFsIHN0YXRlIHVwZGF0ZXMgZHVyaW5nIHRoaXMgbGlmZS1jeWNsZSwgbGV0J3NcbiAgICAvLyBwcm9jZXNzIHRoZW0gbm93LlxuXG4gICAgcHJvY2Vzc1VwZGF0ZVF1ZXVlKHdvcmtJblByb2dyZXNzLCBuZXdQcm9wcywgaW5zdGFuY2UsIHJlbmRlckxhbmVzKTtcbiAgICBpbnN0YW5jZS5zdGF0ZSA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7XG4gIH1cblxuICBpZiAodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudERpZE1vdW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gVXBkYXRlO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlc3VtZU1vdW50Q2xhc3NJbnN0YW5jZSh3b3JrSW5Qcm9ncmVzcywgY3RvciwgbmV3UHJvcHMsIHJlbmRlckxhbmVzKSB7XG4gIHZhciBpbnN0YW5jZSA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcbiAgdmFyIG9sZFByb3BzID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcztcbiAgaW5zdGFuY2UucHJvcHMgPSBvbGRQcm9wcztcbiAgdmFyIG9sZENvbnRleHQgPSBpbnN0YW5jZS5jb250ZXh0O1xuICB2YXIgY29udGV4dFR5cGUgPSBjdG9yLmNvbnRleHRUeXBlO1xuICB2YXIgbmV4dENvbnRleHQgPSBlbXB0eUNvbnRleHRPYmplY3Q7XG5cbiAgaWYgKHR5cGVvZiBjb250ZXh0VHlwZSA9PT0gJ29iamVjdCcgJiYgY29udGV4dFR5cGUgIT09IG51bGwpIHtcbiAgICBuZXh0Q29udGV4dCA9IHJlYWRDb250ZXh0KGNvbnRleHRUeXBlKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgbmV4dExlZ2FjeVVubWFza2VkQ29udGV4dCA9IGdldFVubWFza2VkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgY3RvciwgdHJ1ZSk7XG4gICAgbmV4dENvbnRleHQgPSBnZXRNYXNrZWRDb250ZXh0KHdvcmtJblByb2dyZXNzLCBuZXh0TGVnYWN5VW5tYXNrZWRDb250ZXh0KTtcbiAgfVxuXG4gIHZhciBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMgPSBjdG9yLmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcztcbiAgdmFyIGhhc05ld0xpZmVjeWNsZXMgPSB0eXBlb2YgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzID09PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBpbnN0YW5jZS5nZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSA9PT0gJ2Z1bmN0aW9uJzsgLy8gTm90ZTogRHVyaW5nIHRoZXNlIGxpZmUtY3ljbGVzLCBpbnN0YW5jZS5wcm9wcy9pbnN0YW5jZS5zdGF0ZSBhcmUgd2hhdFxuICAvLyBldmVyIHRoZSBwcmV2aW91c2x5IGF0dGVtcHRlZCB0byByZW5kZXIgLSBub3QgdGhlIFwiY3VycmVudFwiLiBIb3dldmVyLFxuICAvLyBkdXJpbmcgY29tcG9uZW50RGlkVXBkYXRlIHdlIHBhc3MgdGhlIFwiY3VycmVudFwiIHByb3BzLlxuICAvLyBJbiBvcmRlciB0byBzdXBwb3J0IHJlYWN0LWxpZmVjeWNsZXMtY29tcGF0IHBvbHlmaWxsZWQgY29tcG9uZW50cyxcbiAgLy8gVW5zYWZlIGxpZmVjeWNsZXMgc2hvdWxkIG5vdCBiZSBpbnZva2VkIGZvciBjb21wb25lbnRzIHVzaW5nIHRoZSBuZXcgQVBJcy5cblxuICBpZiAoIWhhc05ld0xpZmVjeWNsZXMgJiYgKHR5cGVvZiBpbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyA9PT0gJ2Z1bmN0aW9uJykpIHtcbiAgICBpZiAob2xkUHJvcHMgIT09IG5ld1Byb3BzIHx8IG9sZENvbnRleHQgIT09IG5leHRDb250ZXh0KSB7XG4gICAgICBjYWxsQ29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyh3b3JrSW5Qcm9ncmVzcywgaW5zdGFuY2UsIG5ld1Byb3BzLCBuZXh0Q29udGV4dCk7XG4gICAgfVxuICB9XG5cbiAgcmVzZXRIYXNGb3JjZVVwZGF0ZUJlZm9yZVByb2Nlc3NpbmcoKTtcbiAgdmFyIG9sZFN0YXRlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTtcbiAgdmFyIG5ld1N0YXRlID0gaW5zdGFuY2Uuc3RhdGUgPSBvbGRTdGF0ZTtcbiAgcHJvY2Vzc1VwZGF0ZVF1ZXVlKHdvcmtJblByb2dyZXNzLCBuZXdQcm9wcywgaW5zdGFuY2UsIHJlbmRlckxhbmVzKTtcbiAgbmV3U3RhdGUgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO1xuXG4gIGlmIChvbGRQcm9wcyA9PT0gbmV3UHJvcHMgJiYgb2xkU3RhdGUgPT09IG5ld1N0YXRlICYmICFoYXNDb250ZXh0Q2hhbmdlZCgpICYmICFjaGVja0hhc0ZvcmNlVXBkYXRlQWZ0ZXJQcm9jZXNzaW5nKCkpIHtcbiAgICAvLyBJZiBhbiB1cGRhdGUgd2FzIGFscmVhZHkgaW4gcHJvZ3Jlc3MsIHdlIHNob3VsZCBzY2hlZHVsZSBhbiBVcGRhdGVcbiAgICAvLyBlZmZlY3QgZXZlbiB0aG91Z2ggd2UncmUgYmFpbGluZyBvdXQsIHNvIHRoYXQgY1dVL2NEVSBhcmUgY2FsbGVkLlxuICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50RGlkTW91bnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IFVwZGF0ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAodHlwZW9mIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGFwcGx5RGVyaXZlZFN0YXRlRnJvbVByb3BzKHdvcmtJblByb2dyZXNzLCBjdG9yLCBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMsIG5ld1Byb3BzKTtcbiAgICBuZXdTdGF0ZSA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7XG4gIH1cblxuICB2YXIgc2hvdWxkVXBkYXRlID0gY2hlY2tIYXNGb3JjZVVwZGF0ZUFmdGVyUHJvY2Vzc2luZygpIHx8IGNoZWNrU2hvdWxkQ29tcG9uZW50VXBkYXRlKHdvcmtJblByb2dyZXNzLCBjdG9yLCBvbGRQcm9wcywgbmV3UHJvcHMsIG9sZFN0YXRlLCBuZXdTdGF0ZSwgbmV4dENvbnRleHQpO1xuXG4gIGlmIChzaG91bGRVcGRhdGUpIHtcbiAgICAvLyBJbiBvcmRlciB0byBzdXBwb3J0IHJlYWN0LWxpZmVjeWNsZXMtY29tcGF0IHBvbHlmaWxsZWQgY29tcG9uZW50cyxcbiAgICAvLyBVbnNhZmUgbGlmZWN5Y2xlcyBzaG91bGQgbm90IGJlIGludm9rZWQgZm9yIGNvbXBvbmVudHMgdXNpbmcgdGhlIG5ldyBBUElzLlxuICAgIGlmICghaGFzTmV3TGlmZWN5Y2xlcyAmJiAodHlwZW9mIGluc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsTW91bnQgPT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFdpbGxNb3VudCA9PT0gJ2Z1bmN0aW9uJykpIHtcbiAgICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50V2lsbE1vdW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGluc3RhbmNlLmNvbXBvbmVudFdpbGxNb3VudCgpO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIGluc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsTW91bnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudCgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50RGlkTW91bnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IFVwZGF0ZTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gSWYgYW4gdXBkYXRlIHdhcyBhbHJlYWR5IGluIHByb2dyZXNzLCB3ZSBzaG91bGQgc2NoZWR1bGUgYW4gVXBkYXRlXG4gICAgLy8gZWZmZWN0IGV2ZW4gdGhvdWdoIHdlJ3JlIGJhaWxpbmcgb3V0LCBzbyB0aGF0IGNXVS9jRFUgYXJlIGNhbGxlZC5cbiAgICBpZiAodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudERpZE1vdW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSBVcGRhdGU7XG4gICAgfSAvLyBJZiBzaG91bGRDb21wb25lbnRVcGRhdGUgcmV0dXJuZWQgZmFsc2UsIHdlIHNob3VsZCBzdGlsbCB1cGRhdGUgdGhlXG4gICAgLy8gbWVtb2l6ZWQgc3RhdGUgdG8gaW5kaWNhdGUgdGhhdCB0aGlzIHdvcmsgY2FuIGJlIHJldXNlZC5cblxuXG4gICAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcyA9IG5ld1Byb3BzO1xuICAgIHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSBuZXdTdGF0ZTtcbiAgfSAvLyBVcGRhdGUgdGhlIGV4aXN0aW5nIGluc3RhbmNlJ3Mgc3RhdGUsIHByb3BzLCBhbmQgY29udGV4dCBwb2ludGVycyBldmVuXG4gIC8vIGlmIHNob3VsZENvbXBvbmVudFVwZGF0ZSByZXR1cm5zIGZhbHNlLlxuXG5cbiAgaW5zdGFuY2UucHJvcHMgPSBuZXdQcm9wcztcbiAgaW5zdGFuY2Uuc3RhdGUgPSBuZXdTdGF0ZTtcbiAgaW5zdGFuY2UuY29udGV4dCA9IG5leHRDb250ZXh0O1xuICByZXR1cm4gc2hvdWxkVXBkYXRlO1xufSAvLyBJbnZva2VzIHRoZSB1cGRhdGUgbGlmZS1jeWNsZXMgYW5kIHJldHVybnMgZmFsc2UgaWYgaXQgc2hvdWxkbid0IHJlcmVuZGVyLlxuXG5cbmZ1bmN0aW9uIHVwZGF0ZUNsYXNzSW5zdGFuY2UoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIGN0b3IsIG5ld1Byb3BzLCByZW5kZXJMYW5lcykge1xuICB2YXIgaW5zdGFuY2UgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG4gIGNsb25lVXBkYXRlUXVldWUoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpO1xuICB2YXIgdW5yZXNvbHZlZE9sZFByb3BzID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcztcbiAgdmFyIG9sZFByb3BzID0gd29ya0luUHJvZ3Jlc3MudHlwZSA9PT0gd29ya0luUHJvZ3Jlc3MuZWxlbWVudFR5cGUgPyB1bnJlc29sdmVkT2xkUHJvcHMgOiByZXNvbHZlRGVmYXVsdFByb3BzKHdvcmtJblByb2dyZXNzLnR5cGUsIHVucmVzb2x2ZWRPbGRQcm9wcyk7XG4gIGluc3RhbmNlLnByb3BzID0gb2xkUHJvcHM7XG4gIHZhciB1bnJlc29sdmVkTmV3UHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHM7XG4gIHZhciBvbGRDb250ZXh0ID0gaW5zdGFuY2UuY29udGV4dDtcbiAgdmFyIGNvbnRleHRUeXBlID0gY3Rvci5jb250ZXh0VHlwZTtcbiAgdmFyIG5leHRDb250ZXh0ID0gZW1wdHlDb250ZXh0T2JqZWN0O1xuXG4gIGlmICh0eXBlb2YgY29udGV4dFR5cGUgPT09ICdvYmplY3QnICYmIGNvbnRleHRUeXBlICE9PSBudWxsKSB7XG4gICAgbmV4dENvbnRleHQgPSByZWFkQ29udGV4dChjb250ZXh0VHlwZSk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIG5leHRVbm1hc2tlZENvbnRleHQgPSBnZXRVbm1hc2tlZENvbnRleHQod29ya0luUHJvZ3Jlc3MsIGN0b3IsIHRydWUpO1xuICAgIG5leHRDb250ZXh0ID0gZ2V0TWFza2VkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgbmV4dFVubWFza2VkQ29udGV4dCk7XG4gIH1cblxuICB2YXIgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzID0gY3Rvci5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHM7XG4gIHZhciBoYXNOZXdMaWZlY3ljbGVzID0gdHlwZW9mIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgaW5zdGFuY2UuZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUgPT09ICdmdW5jdGlvbic7IC8vIE5vdGU6IER1cmluZyB0aGVzZSBsaWZlLWN5Y2xlcywgaW5zdGFuY2UucHJvcHMvaW5zdGFuY2Uuc3RhdGUgYXJlIHdoYXRcbiAgLy8gZXZlciB0aGUgcHJldmlvdXNseSBhdHRlbXB0ZWQgdG8gcmVuZGVyIC0gbm90IHRoZSBcImN1cnJlbnRcIi4gSG93ZXZlcixcbiAgLy8gZHVyaW5nIGNvbXBvbmVudERpZFVwZGF0ZSB3ZSBwYXNzIHRoZSBcImN1cnJlbnRcIiBwcm9wcy5cbiAgLy8gSW4gb3JkZXIgdG8gc3VwcG9ydCByZWFjdC1saWZlY3ljbGVzLWNvbXBhdCBwb2x5ZmlsbGVkIGNvbXBvbmVudHMsXG4gIC8vIFVuc2FmZSBsaWZlY3ljbGVzIHNob3VsZCBub3QgYmUgaW52b2tlZCBmb3IgY29tcG9uZW50cyB1c2luZyB0aGUgbmV3IEFQSXMuXG5cbiAgaWYgKCFoYXNOZXdMaWZlY3ljbGVzICYmICh0eXBlb2YgaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgPT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgPT09ICdmdW5jdGlvbicpKSB7XG4gICAgaWYgKHVucmVzb2x2ZWRPbGRQcm9wcyAhPT0gdW5yZXNvbHZlZE5ld1Byb3BzIHx8IG9sZENvbnRleHQgIT09IG5leHRDb250ZXh0KSB7XG4gICAgICBjYWxsQ29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyh3b3JrSW5Qcm9ncmVzcywgaW5zdGFuY2UsIG5ld1Byb3BzLCBuZXh0Q29udGV4dCk7XG4gICAgfVxuICB9XG5cbiAgcmVzZXRIYXNGb3JjZVVwZGF0ZUJlZm9yZVByb2Nlc3NpbmcoKTtcbiAgdmFyIG9sZFN0YXRlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTtcbiAgdmFyIG5ld1N0YXRlID0gaW5zdGFuY2Uuc3RhdGUgPSBvbGRTdGF0ZTtcbiAgcHJvY2Vzc1VwZGF0ZVF1ZXVlKHdvcmtJblByb2dyZXNzLCBuZXdQcm9wcywgaW5zdGFuY2UsIHJlbmRlckxhbmVzKTtcbiAgbmV3U3RhdGUgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO1xuXG4gIGlmICh1bnJlc29sdmVkT2xkUHJvcHMgPT09IHVucmVzb2x2ZWROZXdQcm9wcyAmJiBvbGRTdGF0ZSA9PT0gbmV3U3RhdGUgJiYgIWhhc0NvbnRleHRDaGFuZ2VkKCkgJiYgIWNoZWNrSGFzRm9yY2VVcGRhdGVBZnRlclByb2Nlc3NpbmcoKSkge1xuICAgIC8vIElmIGFuIHVwZGF0ZSB3YXMgYWxyZWFkeSBpbiBwcm9ncmVzcywgd2Ugc2hvdWxkIHNjaGVkdWxlIGFuIFVwZGF0ZVxuICAgIC8vIGVmZmVjdCBldmVuIHRob3VnaCB3ZSdyZSBiYWlsaW5nIG91dCwgc28gdGhhdCBjV1UvY0RVIGFyZSBjYWxsZWQuXG4gICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnREaWRVcGRhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGlmICh1bnJlc29sdmVkT2xkUHJvcHMgIT09IGN1cnJlbnQubWVtb2l6ZWRQcm9wcyB8fCBvbGRTdGF0ZSAhPT0gY3VycmVudC5tZW1vaXplZFN0YXRlKSB7XG4gICAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IFVwZGF0ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGluc3RhbmNlLmdldFNuYXBzaG90QmVmb3JlVXBkYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBpZiAodW5yZXNvbHZlZE9sZFByb3BzICE9PSBjdXJyZW50Lm1lbW9pemVkUHJvcHMgfHwgb2xkU3RhdGUgIT09IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZSkge1xuICAgICAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSBTbmFwc2hvdDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAodHlwZW9mIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGFwcGx5RGVyaXZlZFN0YXRlRnJvbVByb3BzKHdvcmtJblByb2dyZXNzLCBjdG9yLCBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMsIG5ld1Byb3BzKTtcbiAgICBuZXdTdGF0ZSA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7XG4gIH1cblxuICB2YXIgc2hvdWxkVXBkYXRlID0gY2hlY2tIYXNGb3JjZVVwZGF0ZUFmdGVyUHJvY2Vzc2luZygpIHx8IGNoZWNrU2hvdWxkQ29tcG9uZW50VXBkYXRlKHdvcmtJblByb2dyZXNzLCBjdG9yLCBvbGRQcm9wcywgbmV3UHJvcHMsIG9sZFN0YXRlLCBuZXdTdGF0ZSwgbmV4dENvbnRleHQpO1xuXG4gIGlmIChzaG91bGRVcGRhdGUpIHtcbiAgICAvLyBJbiBvcmRlciB0byBzdXBwb3J0IHJlYWN0LWxpZmVjeWNsZXMtY29tcGF0IHBvbHlmaWxsZWQgY29tcG9uZW50cyxcbiAgICAvLyBVbnNhZmUgbGlmZWN5Y2xlcyBzaG91bGQgbm90IGJlIGludm9rZWQgZm9yIGNvbXBvbmVudHMgdXNpbmcgdGhlIG5ldyBBUElzLlxuICAgIGlmICghaGFzTmV3TGlmZWN5Y2xlcyAmJiAodHlwZW9mIGluc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsVXBkYXRlID09PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnRXaWxsVXBkYXRlID09PSAnZnVuY3Rpb24nKSkge1xuICAgICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnRXaWxsVXBkYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGluc3RhbmNlLmNvbXBvbmVudFdpbGxVcGRhdGUobmV3UHJvcHMsIG5ld1N0YXRlLCBuZXh0Q29udGV4dCk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxVcGRhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxVcGRhdGUobmV3UHJvcHMsIG5ld1N0YXRlLCBuZXh0Q29udGV4dCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnREaWRVcGRhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IFVwZGF0ZTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGluc3RhbmNlLmdldFNuYXBzaG90QmVmb3JlVXBkYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSBTbmFwc2hvdDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gSWYgYW4gdXBkYXRlIHdhcyBhbHJlYWR5IGluIHByb2dyZXNzLCB3ZSBzaG91bGQgc2NoZWR1bGUgYW4gVXBkYXRlXG4gICAgLy8gZWZmZWN0IGV2ZW4gdGhvdWdoIHdlJ3JlIGJhaWxpbmcgb3V0LCBzbyB0aGF0IGNXVS9jRFUgYXJlIGNhbGxlZC5cbiAgICBpZiAodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudERpZFVwZGF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaWYgKHVucmVzb2x2ZWRPbGRQcm9wcyAhPT0gY3VycmVudC5tZW1vaXplZFByb3BzIHx8IG9sZFN0YXRlICE9PSBjdXJyZW50Lm1lbW9pemVkU3RhdGUpIHtcbiAgICAgICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gVXBkYXRlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGlmICh1bnJlc29sdmVkT2xkUHJvcHMgIT09IGN1cnJlbnQubWVtb2l6ZWRQcm9wcyB8fCBvbGRTdGF0ZSAhPT0gY3VycmVudC5tZW1vaXplZFN0YXRlKSB7XG4gICAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IFNuYXBzaG90O1xuICAgICAgfVxuICAgIH0gLy8gSWYgc2hvdWxkQ29tcG9uZW50VXBkYXRlIHJldHVybmVkIGZhbHNlLCB3ZSBzaG91bGQgc3RpbGwgdXBkYXRlIHRoZVxuICAgIC8vIG1lbW9pemVkIHByb3BzL3N0YXRlIHRvIGluZGljYXRlIHRoYXQgdGhpcyB3b3JrIGNhbiBiZSByZXVzZWQuXG5cblxuICAgIHdvcmtJblByb2dyZXNzLm1lbW9pemVkUHJvcHMgPSBuZXdQcm9wcztcbiAgICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID0gbmV3U3RhdGU7XG4gIH0gLy8gVXBkYXRlIHRoZSBleGlzdGluZyBpbnN0YW5jZSdzIHN0YXRlLCBwcm9wcywgYW5kIGNvbnRleHQgcG9pbnRlcnMgZXZlblxuICAvLyBpZiBzaG91bGRDb21wb25lbnRVcGRhdGUgcmV0dXJucyBmYWxzZS5cblxuXG4gIGluc3RhbmNlLnByb3BzID0gbmV3UHJvcHM7XG4gIGluc3RhbmNlLnN0YXRlID0gbmV3U3RhdGU7XG4gIGluc3RhbmNlLmNvbnRleHQgPSBuZXh0Q29udGV4dDtcbiAgcmV0dXJuIHNob3VsZFVwZGF0ZTtcbn1cblxudmFyIGRpZFdhcm5BYm91dE1hcHM7XG52YXIgZGlkV2FybkFib3V0R2VuZXJhdG9ycztcbnZhciBkaWRXYXJuQWJvdXRTdHJpbmdSZWZzO1xudmFyIG93bmVySGFzS2V5VXNlV2FybmluZztcbnZhciBvd25lckhhc0Z1bmN0aW9uVHlwZVdhcm5pbmc7XG5cbnZhciB3YXJuRm9yTWlzc2luZ0tleSA9IGZ1bmN0aW9uIChjaGlsZCwgcmV0dXJuRmliZXIpIHt9O1xuXG57XG4gIGRpZFdhcm5BYm91dE1hcHMgPSBmYWxzZTtcbiAgZGlkV2FybkFib3V0R2VuZXJhdG9ycyA9IGZhbHNlO1xuICBkaWRXYXJuQWJvdXRTdHJpbmdSZWZzID0ge307XG4gIC8qKlxuICAgKiBXYXJuIGlmIHRoZXJlJ3Mgbm8ga2V5IGV4cGxpY2l0bHkgc2V0IG9uIGR5bmFtaWMgYXJyYXlzIG9mIGNoaWxkcmVuIG9yXG4gICAqIG9iamVjdCBrZXlzIGFyZSBub3QgdmFsaWQuIFRoaXMgYWxsb3dzIHVzIHRvIGtlZXAgdHJhY2sgb2YgY2hpbGRyZW4gYmV0d2VlblxuICAgKiB1cGRhdGVzLlxuICAgKi9cblxuICBvd25lckhhc0tleVVzZVdhcm5pbmcgPSB7fTtcbiAgb3duZXJIYXNGdW5jdGlvblR5cGVXYXJuaW5nID0ge307XG5cbiAgd2FybkZvck1pc3NpbmdLZXkgPSBmdW5jdGlvbiAoY2hpbGQsIHJldHVybkZpYmVyKSB7XG4gICAgaWYgKGNoaWxkID09PSBudWxsIHx8IHR5cGVvZiBjaGlsZCAhPT0gJ29iamVjdCcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoIWNoaWxkLl9zdG9yZSB8fCBjaGlsZC5fc3RvcmUudmFsaWRhdGVkIHx8IGNoaWxkLmtleSAhPSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKCEodHlwZW9mIGNoaWxkLl9zdG9yZSA9PT0gJ29iamVjdCcpKSB7XG4gICAgICB7XG4gICAgICAgIHRocm93IEVycm9yKCBcIlJlYWN0IENvbXBvbmVudCBpbiB3YXJuRm9yTWlzc2luZ0tleSBzaG91bGQgaGF2ZSBhIF9zdG9yZS4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS5cIiApO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNoaWxkLl9zdG9yZS52YWxpZGF0ZWQgPSB0cnVlO1xuICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZShyZXR1cm5GaWJlci50eXBlKSB8fCAnQ29tcG9uZW50JztcblxuICAgIGlmIChvd25lckhhc0tleVVzZVdhcm5pbmdbY29tcG9uZW50TmFtZV0pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBvd25lckhhc0tleVVzZVdhcm5pbmdbY29tcG9uZW50TmFtZV0gPSB0cnVlO1xuXG4gICAgZXJyb3IoJ0VhY2ggY2hpbGQgaW4gYSBsaXN0IHNob3VsZCBoYXZlIGEgdW5pcXVlICcgKyAnXCJrZXlcIiBwcm9wLiBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3dhcm5pbmcta2V5cyBmb3IgJyArICdtb3JlIGluZm9ybWF0aW9uLicpO1xuICB9O1xufVxuXG52YXIgaXNBcnJheSQxID0gQXJyYXkuaXNBcnJheTtcblxuZnVuY3Rpb24gY29lcmNlUmVmKHJldHVybkZpYmVyLCBjdXJyZW50LCBlbGVtZW50KSB7XG4gIHZhciBtaXhlZFJlZiA9IGVsZW1lbnQucmVmO1xuXG4gIGlmIChtaXhlZFJlZiAhPT0gbnVsbCAmJiB0eXBlb2YgbWl4ZWRSZWYgIT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIG1peGVkUmVmICE9PSAnb2JqZWN0Jykge1xuICAgIHtcbiAgICAgIC8vIFRPRE86IENsZWFuIHRoaXMgdXAgb25jZSB3ZSB0dXJuIG9uIHRoZSBzdHJpbmcgcmVmIHdhcm5pbmcgZm9yXG4gICAgICAvLyBldmVyeW9uZSwgYmVjYXVzZSB0aGUgc3RyaWN0IG1vZGUgY2FzZSB3aWxsIG5vIGxvbmdlciBiZSByZWxldmFudFxuICAgICAgaWYgKChyZXR1cm5GaWJlci5tb2RlICYgU3RyaWN0TW9kZSB8fCB3YXJuQWJvdXRTdHJpbmdSZWZzKSAmJiAvLyBXZSB3YXJuIGluIFJlYWN0RWxlbWVudC5qcyBpZiBvd25lciBhbmQgc2VsZiBhcmUgZXF1YWwgZm9yIHN0cmluZyByZWZzXG4gICAgICAvLyBiZWNhdXNlIHRoZXNlIGNhbm5vdCBiZSBhdXRvbWF0aWNhbGx5IGNvbnZlcnRlZCB0byBhbiBhcnJvdyBmdW5jdGlvblxuICAgICAgLy8gdXNpbmcgYSBjb2RlbW9kLiBUaGVyZWZvcmUsIHdlIGRvbid0IGhhdmUgdG8gd2FybiBhYm91dCBzdHJpbmcgcmVmcyBhZ2Fpbi5cbiAgICAgICEoZWxlbWVudC5fb3duZXIgJiYgZWxlbWVudC5fc2VsZiAmJiBlbGVtZW50Ll9vd25lci5zdGF0ZU5vZGUgIT09IGVsZW1lbnQuX3NlbGYpKSB7XG4gICAgICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZShyZXR1cm5GaWJlci50eXBlKSB8fCAnQ29tcG9uZW50JztcblxuICAgICAgICBpZiAoIWRpZFdhcm5BYm91dFN0cmluZ1JlZnNbY29tcG9uZW50TmFtZV0pIHtcbiAgICAgICAgICB7XG4gICAgICAgICAgICBlcnJvcignQSBzdHJpbmcgcmVmLCBcIiVzXCIsIGhhcyBiZWVuIGZvdW5kIHdpdGhpbiBhIHN0cmljdCBtb2RlIHRyZWUuICcgKyAnU3RyaW5nIHJlZnMgYXJlIGEgc291cmNlIG9mIHBvdGVudGlhbCBidWdzIGFuZCBzaG91bGQgYmUgYXZvaWRlZC4gJyArICdXZSByZWNvbW1lbmQgdXNpbmcgdXNlUmVmKCkgb3IgY3JlYXRlUmVmKCkgaW5zdGVhZC4gJyArICdMZWFybiBtb3JlIGFib3V0IHVzaW5nIHJlZnMgc2FmZWx5IGhlcmU6ICcgKyAnaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3N0cmljdC1tb2RlLXN0cmluZy1yZWYnLCBtaXhlZFJlZik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZGlkV2FybkFib3V0U3RyaW5nUmVmc1tjb21wb25lbnROYW1lXSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZWxlbWVudC5fb3duZXIpIHtcbiAgICAgIHZhciBvd25lciA9IGVsZW1lbnQuX293bmVyO1xuICAgICAgdmFyIGluc3Q7XG5cbiAgICAgIGlmIChvd25lcikge1xuICAgICAgICB2YXIgb3duZXJGaWJlciA9IG93bmVyO1xuXG4gICAgICAgIGlmICghKG93bmVyRmliZXIudGFnID09PSBDbGFzc0NvbXBvbmVudCkpIHtcbiAgICAgICAgICB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvciggXCJGdW5jdGlvbiBjb21wb25lbnRzIGNhbm5vdCBoYXZlIHN0cmluZyByZWZzLiBXZSByZWNvbW1lbmQgdXNpbmcgdXNlUmVmKCkgaW5zdGVhZC4gTGVhcm4gbW9yZSBhYm91dCB1c2luZyByZWZzIHNhZmVseSBoZXJlOiBodHRwczovL3JlYWN0anMub3JnL2xpbmsvc3RyaWN0LW1vZGUtc3RyaW5nLXJlZlwiICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaW5zdCA9IG93bmVyRmliZXIuc3RhdGVOb2RlO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWluc3QpIHtcbiAgICAgICAge1xuICAgICAgICAgIHRocm93IEVycm9yKCBcIk1pc3Npbmcgb3duZXIgZm9yIHN0cmluZyByZWYgXCIgKyBtaXhlZFJlZiArIFwiLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiICk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIHN0cmluZ1JlZiA9ICcnICsgbWl4ZWRSZWY7IC8vIENoZWNrIGlmIHByZXZpb3VzIHN0cmluZyByZWYgbWF0Y2hlcyBuZXcgc3RyaW5nIHJlZlxuXG4gICAgICBpZiAoY3VycmVudCAhPT0gbnVsbCAmJiBjdXJyZW50LnJlZiAhPT0gbnVsbCAmJiB0eXBlb2YgY3VycmVudC5yZWYgPT09ICdmdW5jdGlvbicgJiYgY3VycmVudC5yZWYuX3N0cmluZ1JlZiA9PT0gc3RyaW5nUmVmKSB7XG4gICAgICAgIHJldHVybiBjdXJyZW50LnJlZjtcbiAgICAgIH1cblxuICAgICAgdmFyIHJlZiA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB2YXIgcmVmcyA9IGluc3QucmVmcztcblxuICAgICAgICBpZiAocmVmcyA9PT0gZW1wdHlSZWZzT2JqZWN0KSB7XG4gICAgICAgICAgLy8gVGhpcyBpcyBhIGxhenkgcG9vbGVkIGZyb3plbiBvYmplY3QsIHNvIHdlIG5lZWQgdG8gaW5pdGlhbGl6ZS5cbiAgICAgICAgICByZWZzID0gaW5zdC5yZWZzID0ge307XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICBkZWxldGUgcmVmc1tzdHJpbmdSZWZdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlZnNbc3RyaW5nUmVmXSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICByZWYuX3N0cmluZ1JlZiA9IHN0cmluZ1JlZjtcbiAgICAgIHJldHVybiByZWY7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICghKHR5cGVvZiBtaXhlZFJlZiA9PT0gJ3N0cmluZycpKSB7XG4gICAgICAgIHtcbiAgICAgICAgICB0aHJvdyBFcnJvciggXCJFeHBlY3RlZCByZWYgdG8gYmUgYSBmdW5jdGlvbiwgYSBzdHJpbmcsIGFuIG9iamVjdCByZXR1cm5lZCBieSBSZWFjdC5jcmVhdGVSZWYoKSwgb3IgbnVsbC5cIiApO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICghZWxlbWVudC5fb3duZXIpIHtcbiAgICAgICAge1xuICAgICAgICAgIHRocm93IEVycm9yKCBcIkVsZW1lbnQgcmVmIHdhcyBzcGVjaWZpZWQgYXMgYSBzdHJpbmcgKFwiICsgbWl4ZWRSZWYgKyBcIikgYnV0IG5vIG93bmVyIHdhcyBzZXQuIFRoaXMgY291bGQgaGFwcGVuIGZvciBvbmUgb2YgdGhlIGZvbGxvd2luZyByZWFzb25zOlxcbjEuIFlvdSBtYXkgYmUgYWRkaW5nIGEgcmVmIHRvIGEgZnVuY3Rpb24gY29tcG9uZW50XFxuMi4gWW91IG1heSBiZSBhZGRpbmcgYSByZWYgdG8gYSBjb21wb25lbnQgdGhhdCB3YXMgbm90IGNyZWF0ZWQgaW5zaWRlIGEgY29tcG9uZW50J3MgcmVuZGVyIG1ldGhvZFxcbjMuIFlvdSBoYXZlIG11bHRpcGxlIGNvcGllcyBvZiBSZWFjdCBsb2FkZWRcXG5TZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3JlZnMtbXVzdC1oYXZlLW93bmVyIGZvciBtb3JlIGluZm9ybWF0aW9uLlwiICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbWl4ZWRSZWY7XG59XG5cbmZ1bmN0aW9uIHRocm93T25JbnZhbGlkT2JqZWN0VHlwZShyZXR1cm5GaWJlciwgbmV3Q2hpbGQpIHtcbiAgaWYgKHJldHVybkZpYmVyLnR5cGUgIT09ICd0ZXh0YXJlYScpIHtcbiAgICB7XG4gICAgICB7XG4gICAgICAgIHRocm93IEVycm9yKCBcIk9iamVjdHMgYXJlIG5vdCB2YWxpZCBhcyBhIFJlYWN0IGNoaWxkIChmb3VuZDogXCIgKyAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG5ld0NoaWxkKSA9PT0gJ1tvYmplY3QgT2JqZWN0XScgPyAnb2JqZWN0IHdpdGgga2V5cyB7JyArIE9iamVjdC5rZXlzKG5ld0NoaWxkKS5qb2luKCcsICcpICsgJ30nIDogbmV3Q2hpbGQpICsgXCIpLiBJZiB5b3UgbWVhbnQgdG8gcmVuZGVyIGEgY29sbGVjdGlvbiBvZiBjaGlsZHJlbiwgdXNlIGFuIGFycmF5IGluc3RlYWQuXCIgKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gd2Fybk9uRnVuY3Rpb25UeXBlKHJldHVybkZpYmVyKSB7XG4gIHtcbiAgICB2YXIgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWUocmV0dXJuRmliZXIudHlwZSkgfHwgJ0NvbXBvbmVudCc7XG5cbiAgICBpZiAob3duZXJIYXNGdW5jdGlvblR5cGVXYXJuaW5nW2NvbXBvbmVudE5hbWVdKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgb3duZXJIYXNGdW5jdGlvblR5cGVXYXJuaW5nW2NvbXBvbmVudE5hbWVdID0gdHJ1ZTtcblxuICAgIGVycm9yKCdGdW5jdGlvbnMgYXJlIG5vdCB2YWxpZCBhcyBhIFJlYWN0IGNoaWxkLiBUaGlzIG1heSBoYXBwZW4gaWYgJyArICd5b3UgcmV0dXJuIGEgQ29tcG9uZW50IGluc3RlYWQgb2YgPENvbXBvbmVudCAvPiBmcm9tIHJlbmRlci4gJyArICdPciBtYXliZSB5b3UgbWVhbnQgdG8gY2FsbCB0aGlzIGZ1bmN0aW9uIHJhdGhlciB0aGFuIHJldHVybiBpdC4nKTtcbiAgfVxufSAvLyBXZSBhdm9pZCBpbmxpbmluZyB0aGlzIHRvIGF2b2lkIHBvdGVudGlhbCBkZW9wdHMgZnJvbSB1c2luZyB0cnkvY2F0Y2guXG4vLyB0byBiZSBhYmxlIHRvIG9wdGltaXplIGVhY2ggcGF0aCBpbmRpdmlkdWFsbHkgYnkgYnJhbmNoaW5nIGVhcmx5LiBUaGlzIG5lZWRzXG4vLyBhIGNvbXBpbGVyIG9yIHdlIGNhbiBkbyBpdCBtYW51YWxseS4gSGVscGVycyB0aGF0IGRvbid0IG5lZWQgdGhpcyBicmFuY2hpbmdcbi8vIGxpdmUgb3V0c2lkZSBvZiB0aGlzIGZ1bmN0aW9uLlxuXG5cbmZ1bmN0aW9uIENoaWxkUmVjb25jaWxlcihzaG91bGRUcmFja1NpZGVFZmZlY3RzKSB7XG4gIGZ1bmN0aW9uIGRlbGV0ZUNoaWxkKHJldHVybkZpYmVyLCBjaGlsZFRvRGVsZXRlKSB7XG4gICAgaWYgKCFzaG91bGRUcmFja1NpZGVFZmZlY3RzKSB7XG4gICAgICAvLyBOb29wLlxuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gRGVsZXRpb25zIGFyZSBhZGRlZCBpbiByZXZlcnNlZCBvcmRlciBzbyB3ZSBhZGQgaXQgdG8gdGhlIGZyb250LlxuICAgIC8vIEF0IHRoaXMgcG9pbnQsIHRoZSByZXR1cm4gZmliZXIncyBlZmZlY3QgbGlzdCBpcyBlbXB0eSBleGNlcHQgZm9yXG4gICAgLy8gZGVsZXRpb25zLCBzbyB3ZSBjYW4ganVzdCBhcHBlbmQgdGhlIGRlbGV0aW9uIHRvIHRoZSBsaXN0LiBUaGUgcmVtYWluaW5nXG4gICAgLy8gZWZmZWN0cyBhcmVuJ3QgYWRkZWQgdW50aWwgdGhlIGNvbXBsZXRlIHBoYXNlLiBPbmNlIHdlIGltcGxlbWVudFxuICAgIC8vIHJlc3VtaW5nLCB0aGlzIG1heSBub3QgYmUgdHJ1ZS5cblxuXG4gICAgdmFyIGxhc3QgPSByZXR1cm5GaWJlci5sYXN0RWZmZWN0O1xuXG4gICAgaWYgKGxhc3QgIT09IG51bGwpIHtcbiAgICAgIGxhc3QubmV4dEVmZmVjdCA9IGNoaWxkVG9EZWxldGU7XG4gICAgICByZXR1cm5GaWJlci5sYXN0RWZmZWN0ID0gY2hpbGRUb0RlbGV0ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuRmliZXIuZmlyc3RFZmZlY3QgPSByZXR1cm5GaWJlci5sYXN0RWZmZWN0ID0gY2hpbGRUb0RlbGV0ZTtcbiAgICB9XG5cbiAgICBjaGlsZFRvRGVsZXRlLm5leHRFZmZlY3QgPSBudWxsO1xuICAgIGNoaWxkVG9EZWxldGUuZmxhZ3MgPSBEZWxldGlvbjtcbiAgfVxuXG4gIGZ1bmN0aW9uIGRlbGV0ZVJlbWFpbmluZ0NoaWxkcmVuKHJldHVybkZpYmVyLCBjdXJyZW50Rmlyc3RDaGlsZCkge1xuICAgIGlmICghc2hvdWxkVHJhY2tTaWRlRWZmZWN0cykge1xuICAgICAgLy8gTm9vcC5cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0gLy8gVE9ETzogRm9yIHRoZSBzaG91bGRDbG9uZSBjYXNlLCB0aGlzIGNvdWxkIGJlIG1pY3JvLW9wdGltaXplZCBhIGJpdCBieVxuICAgIC8vIGFzc3VtaW5nIHRoYXQgYWZ0ZXIgdGhlIGZpcnN0IGNoaWxkIHdlJ3ZlIGFscmVhZHkgYWRkZWQgZXZlcnl0aGluZy5cblxuXG4gICAgdmFyIGNoaWxkVG9EZWxldGUgPSBjdXJyZW50Rmlyc3RDaGlsZDtcblxuICAgIHdoaWxlIChjaGlsZFRvRGVsZXRlICE9PSBudWxsKSB7XG4gICAgICBkZWxldGVDaGlsZChyZXR1cm5GaWJlciwgY2hpbGRUb0RlbGV0ZSk7XG4gICAgICBjaGlsZFRvRGVsZXRlID0gY2hpbGRUb0RlbGV0ZS5zaWJsaW5nO1xuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgZnVuY3Rpb24gbWFwUmVtYWluaW5nQ2hpbGRyZW4ocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkKSB7XG4gICAgLy8gQWRkIHRoZSByZW1haW5pbmcgY2hpbGRyZW4gdG8gYSB0ZW1wb3JhcnkgbWFwIHNvIHRoYXQgd2UgY2FuIGZpbmQgdGhlbSBieVxuICAgIC8vIGtleXMgcXVpY2tseS4gSW1wbGljaXQgKG51bGwpIGtleXMgZ2V0IGFkZGVkIHRvIHRoaXMgc2V0IHdpdGggdGhlaXIgaW5kZXhcbiAgICAvLyBpbnN0ZWFkLlxuICAgIHZhciBleGlzdGluZ0NoaWxkcmVuID0gbmV3IE1hcCgpO1xuICAgIHZhciBleGlzdGluZ0NoaWxkID0gY3VycmVudEZpcnN0Q2hpbGQ7XG5cbiAgICB3aGlsZSAoZXhpc3RpbmdDaGlsZCAhPT0gbnVsbCkge1xuICAgICAgaWYgKGV4aXN0aW5nQ2hpbGQua2V5ICE9PSBudWxsKSB7XG4gICAgICAgIGV4aXN0aW5nQ2hpbGRyZW4uc2V0KGV4aXN0aW5nQ2hpbGQua2V5LCBleGlzdGluZ0NoaWxkKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGV4aXN0aW5nQ2hpbGRyZW4uc2V0KGV4aXN0aW5nQ2hpbGQuaW5kZXgsIGV4aXN0aW5nQ2hpbGQpO1xuICAgICAgfVxuXG4gICAgICBleGlzdGluZ0NoaWxkID0gZXhpc3RpbmdDaGlsZC5zaWJsaW5nO1xuICAgIH1cblxuICAgIHJldHVybiBleGlzdGluZ0NoaWxkcmVuO1xuICB9XG5cbiAgZnVuY3Rpb24gdXNlRmliZXIoZmliZXIsIHBlbmRpbmdQcm9wcykge1xuICAgIC8vIFdlIGN1cnJlbnRseSBzZXQgc2libGluZyB0byBudWxsIGFuZCBpbmRleCB0byAwIGhlcmUgYmVjYXVzZSBpdCBpcyBlYXN5XG4gICAgLy8gdG8gZm9yZ2V0IHRvIGRvIGJlZm9yZSByZXR1cm5pbmcgaXQuIEUuZy4gZm9yIHRoZSBzaW5nbGUgY2hpbGQgY2FzZS5cbiAgICB2YXIgY2xvbmUgPSBjcmVhdGVXb3JrSW5Qcm9ncmVzcyhmaWJlciwgcGVuZGluZ1Byb3BzKTtcbiAgICBjbG9uZS5pbmRleCA9IDA7XG4gICAgY2xvbmUuc2libGluZyA9IG51bGw7XG4gICAgcmV0dXJuIGNsb25lO1xuICB9XG5cbiAgZnVuY3Rpb24gcGxhY2VDaGlsZChuZXdGaWJlciwgbGFzdFBsYWNlZEluZGV4LCBuZXdJbmRleCkge1xuICAgIG5ld0ZpYmVyLmluZGV4ID0gbmV3SW5kZXg7XG5cbiAgICBpZiAoIXNob3VsZFRyYWNrU2lkZUVmZmVjdHMpIHtcbiAgICAgIC8vIE5vb3AuXG4gICAgICByZXR1cm4gbGFzdFBsYWNlZEluZGV4O1xuICAgIH1cblxuICAgIHZhciBjdXJyZW50ID0gbmV3RmliZXIuYWx0ZXJuYXRlO1xuXG4gICAgaWYgKGN1cnJlbnQgIT09IG51bGwpIHtcbiAgICAgIHZhciBvbGRJbmRleCA9IGN1cnJlbnQuaW5kZXg7XG5cbiAgICAgIGlmIChvbGRJbmRleCA8IGxhc3RQbGFjZWRJbmRleCkge1xuICAgICAgICAvLyBUaGlzIGlzIGEgbW92ZS5cbiAgICAgICAgbmV3RmliZXIuZmxhZ3MgPSBQbGFjZW1lbnQ7XG4gICAgICAgIHJldHVybiBsYXN0UGxhY2VkSW5kZXg7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBUaGlzIGl0ZW0gY2FuIHN0YXkgaW4gcGxhY2UuXG4gICAgICAgIHJldHVybiBvbGRJbmRleDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVGhpcyBpcyBhbiBpbnNlcnRpb24uXG4gICAgICBuZXdGaWJlci5mbGFncyA9IFBsYWNlbWVudDtcbiAgICAgIHJldHVybiBsYXN0UGxhY2VkSW5kZXg7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcGxhY2VTaW5nbGVDaGlsZChuZXdGaWJlcikge1xuICAgIC8vIFRoaXMgaXMgc2ltcGxlciBmb3IgdGhlIHNpbmdsZSBjaGlsZCBjYXNlLiBXZSBvbmx5IG5lZWQgdG8gZG8gYVxuICAgIC8vIHBsYWNlbWVudCBmb3IgaW5zZXJ0aW5nIG5ldyBjaGlsZHJlbi5cbiAgICBpZiAoc2hvdWxkVHJhY2tTaWRlRWZmZWN0cyAmJiBuZXdGaWJlci5hbHRlcm5hdGUgPT09IG51bGwpIHtcbiAgICAgIG5ld0ZpYmVyLmZsYWdzID0gUGxhY2VtZW50O1xuICAgIH1cblxuICAgIHJldHVybiBuZXdGaWJlcjtcbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZVRleHROb2RlKHJldHVybkZpYmVyLCBjdXJyZW50LCB0ZXh0Q29udGVudCwgbGFuZXMpIHtcbiAgICBpZiAoY3VycmVudCA9PT0gbnVsbCB8fCBjdXJyZW50LnRhZyAhPT0gSG9zdFRleHQpIHtcbiAgICAgIC8vIEluc2VydFxuICAgICAgdmFyIGNyZWF0ZWQgPSBjcmVhdGVGaWJlckZyb21UZXh0KHRleHRDb250ZW50LCByZXR1cm5GaWJlci5tb2RlLCBsYW5lcyk7XG4gICAgICBjcmVhdGVkLnJldHVybiA9IHJldHVybkZpYmVyO1xuICAgICAgcmV0dXJuIGNyZWF0ZWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFVwZGF0ZVxuICAgICAgdmFyIGV4aXN0aW5nID0gdXNlRmliZXIoY3VycmVudCwgdGV4dENvbnRlbnQpO1xuICAgICAgZXhpc3RpbmcucmV0dXJuID0gcmV0dXJuRmliZXI7XG4gICAgICByZXR1cm4gZXhpc3Rpbmc7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlRWxlbWVudChyZXR1cm5GaWJlciwgY3VycmVudCwgZWxlbWVudCwgbGFuZXMpIHtcbiAgICBpZiAoY3VycmVudCAhPT0gbnVsbCkge1xuICAgICAgaWYgKGN1cnJlbnQuZWxlbWVudFR5cGUgPT09IGVsZW1lbnQudHlwZSB8fCAoIC8vIEtlZXAgdGhpcyBjaGVjayBpbmxpbmUgc28gaXQgb25seSBydW5zIG9uIHRoZSBmYWxzZSBwYXRoOlxuICAgICAgIGlzQ29tcGF0aWJsZUZhbWlseUZvckhvdFJlbG9hZGluZyhjdXJyZW50LCBlbGVtZW50KSApKSB7XG4gICAgICAgIC8vIE1vdmUgYmFzZWQgb24gaW5kZXhcbiAgICAgICAgdmFyIGV4aXN0aW5nID0gdXNlRmliZXIoY3VycmVudCwgZWxlbWVudC5wcm9wcyk7XG4gICAgICAgIGV4aXN0aW5nLnJlZiA9IGNvZXJjZVJlZihyZXR1cm5GaWJlciwgY3VycmVudCwgZWxlbWVudCk7XG4gICAgICAgIGV4aXN0aW5nLnJldHVybiA9IHJldHVybkZpYmVyO1xuXG4gICAgICAgIHtcbiAgICAgICAgICBleGlzdGluZy5fZGVidWdTb3VyY2UgPSBlbGVtZW50Ll9zb3VyY2U7XG4gICAgICAgICAgZXhpc3RpbmcuX2RlYnVnT3duZXIgPSBlbGVtZW50Ll9vd25lcjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBleGlzdGluZztcbiAgICAgIH1cbiAgICB9IC8vIEluc2VydFxuXG5cbiAgICB2YXIgY3JlYXRlZCA9IGNyZWF0ZUZpYmVyRnJvbUVsZW1lbnQoZWxlbWVudCwgcmV0dXJuRmliZXIubW9kZSwgbGFuZXMpO1xuICAgIGNyZWF0ZWQucmVmID0gY29lcmNlUmVmKHJldHVybkZpYmVyLCBjdXJyZW50LCBlbGVtZW50KTtcbiAgICBjcmVhdGVkLnJldHVybiA9IHJldHVybkZpYmVyO1xuICAgIHJldHVybiBjcmVhdGVkO1xuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlUG9ydGFsKHJldHVybkZpYmVyLCBjdXJyZW50LCBwb3J0YWwsIGxhbmVzKSB7XG4gICAgaWYgKGN1cnJlbnQgPT09IG51bGwgfHwgY3VycmVudC50YWcgIT09IEhvc3RQb3J0YWwgfHwgY3VycmVudC5zdGF0ZU5vZGUuY29udGFpbmVySW5mbyAhPT0gcG9ydGFsLmNvbnRhaW5lckluZm8gfHwgY3VycmVudC5zdGF0ZU5vZGUuaW1wbGVtZW50YXRpb24gIT09IHBvcnRhbC5pbXBsZW1lbnRhdGlvbikge1xuICAgICAgLy8gSW5zZXJ0XG4gICAgICB2YXIgY3JlYXRlZCA9IGNyZWF0ZUZpYmVyRnJvbVBvcnRhbChwb3J0YWwsIHJldHVybkZpYmVyLm1vZGUsIGxhbmVzKTtcbiAgICAgIGNyZWF0ZWQucmV0dXJuID0gcmV0dXJuRmliZXI7XG4gICAgICByZXR1cm4gY3JlYXRlZDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVXBkYXRlXG4gICAgICB2YXIgZXhpc3RpbmcgPSB1c2VGaWJlcihjdXJyZW50LCBwb3J0YWwuY2hpbGRyZW4gfHwgW10pO1xuICAgICAgZXhpc3RpbmcucmV0dXJuID0gcmV0dXJuRmliZXI7XG4gICAgICByZXR1cm4gZXhpc3Rpbmc7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlRnJhZ21lbnQocmV0dXJuRmliZXIsIGN1cnJlbnQsIGZyYWdtZW50LCBsYW5lcywga2V5KSB7XG4gICAgaWYgKGN1cnJlbnQgPT09IG51bGwgfHwgY3VycmVudC50YWcgIT09IEZyYWdtZW50KSB7XG4gICAgICAvLyBJbnNlcnRcbiAgICAgIHZhciBjcmVhdGVkID0gY3JlYXRlRmliZXJGcm9tRnJhZ21lbnQoZnJhZ21lbnQsIHJldHVybkZpYmVyLm1vZGUsIGxhbmVzLCBrZXkpO1xuICAgICAgY3JlYXRlZC5yZXR1cm4gPSByZXR1cm5GaWJlcjtcbiAgICAgIHJldHVybiBjcmVhdGVkO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBVcGRhdGVcbiAgICAgIHZhciBleGlzdGluZyA9IHVzZUZpYmVyKGN1cnJlbnQsIGZyYWdtZW50KTtcbiAgICAgIGV4aXN0aW5nLnJldHVybiA9IHJldHVybkZpYmVyO1xuICAgICAgcmV0dXJuIGV4aXN0aW5nO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUNoaWxkKHJldHVybkZpYmVyLCBuZXdDaGlsZCwgbGFuZXMpIHtcbiAgICBpZiAodHlwZW9mIG5ld0NoaWxkID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgbmV3Q2hpbGQgPT09ICdudW1iZXInKSB7XG4gICAgICAvLyBUZXh0IG5vZGVzIGRvbid0IGhhdmUga2V5cy4gSWYgdGhlIHByZXZpb3VzIG5vZGUgaXMgaW1wbGljaXRseSBrZXllZFxuICAgICAgLy8gd2UgY2FuIGNvbnRpbnVlIHRvIHJlcGxhY2UgaXQgd2l0aG91dCBhYm9ydGluZyBldmVuIGlmIGl0IGlzIG5vdCBhIHRleHRcbiAgICAgIC8vIG5vZGUuXG4gICAgICB2YXIgY3JlYXRlZCA9IGNyZWF0ZUZpYmVyRnJvbVRleHQoJycgKyBuZXdDaGlsZCwgcmV0dXJuRmliZXIubW9kZSwgbGFuZXMpO1xuICAgICAgY3JlYXRlZC5yZXR1cm4gPSByZXR1cm5GaWJlcjtcbiAgICAgIHJldHVybiBjcmVhdGVkO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgbmV3Q2hpbGQgPT09ICdvYmplY3QnICYmIG5ld0NoaWxkICE9PSBudWxsKSB7XG4gICAgICBzd2l0Y2ggKG5ld0NoaWxkLiQkdHlwZW9mKSB7XG4gICAgICAgIGNhc2UgUkVBQ1RfRUxFTUVOVF9UWVBFOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHZhciBfY3JlYXRlZCA9IGNyZWF0ZUZpYmVyRnJvbUVsZW1lbnQobmV3Q2hpbGQsIHJldHVybkZpYmVyLm1vZGUsIGxhbmVzKTtcblxuICAgICAgICAgICAgX2NyZWF0ZWQucmVmID0gY29lcmNlUmVmKHJldHVybkZpYmVyLCBudWxsLCBuZXdDaGlsZCk7XG4gICAgICAgICAgICBfY3JlYXRlZC5yZXR1cm4gPSByZXR1cm5GaWJlcjtcbiAgICAgICAgICAgIHJldHVybiBfY3JlYXRlZDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgY2FzZSBSRUFDVF9QT1JUQUxfVFlQRTpcbiAgICAgICAgICB7XG4gICAgICAgICAgICB2YXIgX2NyZWF0ZWQyID0gY3JlYXRlRmliZXJGcm9tUG9ydGFsKG5ld0NoaWxkLCByZXR1cm5GaWJlci5tb2RlLCBsYW5lcyk7XG5cbiAgICAgICAgICAgIF9jcmVhdGVkMi5yZXR1cm4gPSByZXR1cm5GaWJlcjtcbiAgICAgICAgICAgIHJldHVybiBfY3JlYXRlZDI7XG4gICAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoaXNBcnJheSQxKG5ld0NoaWxkKSB8fCBnZXRJdGVyYXRvckZuKG5ld0NoaWxkKSkge1xuICAgICAgICB2YXIgX2NyZWF0ZWQzID0gY3JlYXRlRmliZXJGcm9tRnJhZ21lbnQobmV3Q2hpbGQsIHJldHVybkZpYmVyLm1vZGUsIGxhbmVzLCBudWxsKTtcblxuICAgICAgICBfY3JlYXRlZDMucmV0dXJuID0gcmV0dXJuRmliZXI7XG4gICAgICAgIHJldHVybiBfY3JlYXRlZDM7XG4gICAgICB9XG5cbiAgICAgIHRocm93T25JbnZhbGlkT2JqZWN0VHlwZShyZXR1cm5GaWJlciwgbmV3Q2hpbGQpO1xuICAgIH1cblxuICAgIHtcbiAgICAgIGlmICh0eXBlb2YgbmV3Q2hpbGQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgd2Fybk9uRnVuY3Rpb25UeXBlKHJldHVybkZpYmVyKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZVNsb3QocmV0dXJuRmliZXIsIG9sZEZpYmVyLCBuZXdDaGlsZCwgbGFuZXMpIHtcbiAgICAvLyBVcGRhdGUgdGhlIGZpYmVyIGlmIHRoZSBrZXlzIG1hdGNoLCBvdGhlcndpc2UgcmV0dXJuIG51bGwuXG4gICAgdmFyIGtleSA9IG9sZEZpYmVyICE9PSBudWxsID8gb2xkRmliZXIua2V5IDogbnVsbDtcblxuICAgIGlmICh0eXBlb2YgbmV3Q2hpbGQgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBuZXdDaGlsZCA9PT0gJ251bWJlcicpIHtcbiAgICAgIC8vIFRleHQgbm9kZXMgZG9uJ3QgaGF2ZSBrZXlzLiBJZiB0aGUgcHJldmlvdXMgbm9kZSBpcyBpbXBsaWNpdGx5IGtleWVkXG4gICAgICAvLyB3ZSBjYW4gY29udGludWUgdG8gcmVwbGFjZSBpdCB3aXRob3V0IGFib3J0aW5nIGV2ZW4gaWYgaXQgaXMgbm90IGEgdGV4dFxuICAgICAgLy8gbm9kZS5cbiAgICAgIGlmIChrZXkgIT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB1cGRhdGVUZXh0Tm9kZShyZXR1cm5GaWJlciwgb2xkRmliZXIsICcnICsgbmV3Q2hpbGQsIGxhbmVzKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIG5ld0NoaWxkID09PSAnb2JqZWN0JyAmJiBuZXdDaGlsZCAhPT0gbnVsbCkge1xuICAgICAgc3dpdGNoIChuZXdDaGlsZC4kJHR5cGVvZikge1xuICAgICAgICBjYXNlIFJFQUNUX0VMRU1FTlRfVFlQRTpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBpZiAobmV3Q2hpbGQua2V5ID09PSBrZXkpIHtcbiAgICAgICAgICAgICAgaWYgKG5ld0NoaWxkLnR5cGUgPT09IFJFQUNUX0ZSQUdNRU5UX1RZUEUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdXBkYXRlRnJhZ21lbnQocmV0dXJuRmliZXIsIG9sZEZpYmVyLCBuZXdDaGlsZC5wcm9wcy5jaGlsZHJlbiwgbGFuZXMsIGtleSk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICByZXR1cm4gdXBkYXRlRWxlbWVudChyZXR1cm5GaWJlciwgb2xkRmliZXIsIG5ld0NoaWxkLCBsYW5lcyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgY2FzZSBSRUFDVF9QT1JUQUxfVFlQRTpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBpZiAobmV3Q2hpbGQua2V5ID09PSBrZXkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHVwZGF0ZVBvcnRhbChyZXR1cm5GaWJlciwgb2xkRmliZXIsIG5ld0NoaWxkLCBsYW5lcyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChpc0FycmF5JDEobmV3Q2hpbGQpIHx8IGdldEl0ZXJhdG9yRm4obmV3Q2hpbGQpKSB7XG4gICAgICAgIGlmIChrZXkgIT09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB1cGRhdGVGcmFnbWVudChyZXR1cm5GaWJlciwgb2xkRmliZXIsIG5ld0NoaWxkLCBsYW5lcywgbnVsbCk7XG4gICAgICB9XG5cbiAgICAgIHRocm93T25JbnZhbGlkT2JqZWN0VHlwZShyZXR1cm5GaWJlciwgbmV3Q2hpbGQpO1xuICAgIH1cblxuICAgIHtcbiAgICAgIGlmICh0eXBlb2YgbmV3Q2hpbGQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgd2Fybk9uRnVuY3Rpb25UeXBlKHJldHVybkZpYmVyKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZUZyb21NYXAoZXhpc3RpbmdDaGlsZHJlbiwgcmV0dXJuRmliZXIsIG5ld0lkeCwgbmV3Q2hpbGQsIGxhbmVzKSB7XG4gICAgaWYgKHR5cGVvZiBuZXdDaGlsZCA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIG5ld0NoaWxkID09PSAnbnVtYmVyJykge1xuICAgICAgLy8gVGV4dCBub2RlcyBkb24ndCBoYXZlIGtleXMsIHNvIHdlIG5laXRoZXIgaGF2ZSB0byBjaGVjayB0aGUgb2xkIG5vclxuICAgICAgLy8gbmV3IG5vZGUgZm9yIHRoZSBrZXkuIElmIGJvdGggYXJlIHRleHQgbm9kZXMsIHRoZXkgbWF0Y2guXG4gICAgICB2YXIgbWF0Y2hlZEZpYmVyID0gZXhpc3RpbmdDaGlsZHJlbi5nZXQobmV3SWR4KSB8fCBudWxsO1xuICAgICAgcmV0dXJuIHVwZGF0ZVRleHROb2RlKHJldHVybkZpYmVyLCBtYXRjaGVkRmliZXIsICcnICsgbmV3Q2hpbGQsIGxhbmVzKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIG5ld0NoaWxkID09PSAnb2JqZWN0JyAmJiBuZXdDaGlsZCAhPT0gbnVsbCkge1xuICAgICAgc3dpdGNoIChuZXdDaGlsZC4kJHR5cGVvZikge1xuICAgICAgICBjYXNlIFJFQUNUX0VMRU1FTlRfVFlQRTpcbiAgICAgICAgICB7XG4gICAgICAgICAgICB2YXIgX21hdGNoZWRGaWJlciA9IGV4aXN0aW5nQ2hpbGRyZW4uZ2V0KG5ld0NoaWxkLmtleSA9PT0gbnVsbCA/IG5ld0lkeCA6IG5ld0NoaWxkLmtleSkgfHwgbnVsbDtcblxuICAgICAgICAgICAgaWYgKG5ld0NoaWxkLnR5cGUgPT09IFJFQUNUX0ZSQUdNRU5UX1RZUEUpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHVwZGF0ZUZyYWdtZW50KHJldHVybkZpYmVyLCBfbWF0Y2hlZEZpYmVyLCBuZXdDaGlsZC5wcm9wcy5jaGlsZHJlbiwgbGFuZXMsIG5ld0NoaWxkLmtleSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB1cGRhdGVFbGVtZW50KHJldHVybkZpYmVyLCBfbWF0Y2hlZEZpYmVyLCBuZXdDaGlsZCwgbGFuZXMpO1xuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHZhciBfbWF0Y2hlZEZpYmVyMiA9IGV4aXN0aW5nQ2hpbGRyZW4uZ2V0KG5ld0NoaWxkLmtleSA9PT0gbnVsbCA/IG5ld0lkeCA6IG5ld0NoaWxkLmtleSkgfHwgbnVsbDtcblxuICAgICAgICAgICAgcmV0dXJuIHVwZGF0ZVBvcnRhbChyZXR1cm5GaWJlciwgX21hdGNoZWRGaWJlcjIsIG5ld0NoaWxkLCBsYW5lcyk7XG4gICAgICAgICAgfVxuXG4gICAgICB9XG5cbiAgICAgIGlmIChpc0FycmF5JDEobmV3Q2hpbGQpIHx8IGdldEl0ZXJhdG9yRm4obmV3Q2hpbGQpKSB7XG4gICAgICAgIHZhciBfbWF0Y2hlZEZpYmVyMyA9IGV4aXN0aW5nQ2hpbGRyZW4uZ2V0KG5ld0lkeCkgfHwgbnVsbDtcblxuICAgICAgICByZXR1cm4gdXBkYXRlRnJhZ21lbnQocmV0dXJuRmliZXIsIF9tYXRjaGVkRmliZXIzLCBuZXdDaGlsZCwgbGFuZXMsIG51bGwpO1xuICAgICAgfVxuXG4gICAgICB0aHJvd09uSW52YWxpZE9iamVjdFR5cGUocmV0dXJuRmliZXIsIG5ld0NoaWxkKTtcbiAgICB9XG5cbiAgICB7XG4gICAgICBpZiAodHlwZW9mIG5ld0NoaWxkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHdhcm5PbkZ1bmN0aW9uVHlwZShyZXR1cm5GaWJlcik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgLyoqXG4gICAqIFdhcm5zIGlmIHRoZXJlIGlzIGEgZHVwbGljYXRlIG9yIG1pc3Npbmcga2V5XG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gd2Fybk9uSW52YWxpZEtleShjaGlsZCwga25vd25LZXlzLCByZXR1cm5GaWJlcikge1xuICAgIHtcbiAgICAgIGlmICh0eXBlb2YgY2hpbGQgIT09ICdvYmplY3QnIHx8IGNoaWxkID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBrbm93bktleXM7XG4gICAgICB9XG5cbiAgICAgIHN3aXRjaCAoY2hpbGQuJCR0eXBlb2YpIHtcbiAgICAgICAgY2FzZSBSRUFDVF9FTEVNRU5UX1RZUEU6XG4gICAgICAgIGNhc2UgUkVBQ1RfUE9SVEFMX1RZUEU6XG4gICAgICAgICAgd2FybkZvck1pc3NpbmdLZXkoY2hpbGQsIHJldHVybkZpYmVyKTtcbiAgICAgICAgICB2YXIga2V5ID0gY2hpbGQua2V5O1xuXG4gICAgICAgICAgaWYgKHR5cGVvZiBrZXkgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoa25vd25LZXlzID09PSBudWxsKSB7XG4gICAgICAgICAgICBrbm93bktleXMgPSBuZXcgU2V0KCk7XG4gICAgICAgICAgICBrbm93bktleXMuYWRkKGtleSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoIWtub3duS2V5cy5oYXMoa2V5KSkge1xuICAgICAgICAgICAga25vd25LZXlzLmFkZChrZXkpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZXJyb3IoJ0VuY291bnRlcmVkIHR3byBjaGlsZHJlbiB3aXRoIHRoZSBzYW1lIGtleSwgYCVzYC4gJyArICdLZXlzIHNob3VsZCBiZSB1bmlxdWUgc28gdGhhdCBjb21wb25lbnRzIG1haW50YWluIHRoZWlyIGlkZW50aXR5ICcgKyAnYWNyb3NzIHVwZGF0ZXMuIE5vbi11bmlxdWUga2V5cyBtYXkgY2F1c2UgY2hpbGRyZW4gdG8gYmUgJyArICdkdXBsaWNhdGVkIGFuZC9vciBvbWl0dGVkIOKAlCB0aGUgYmVoYXZpb3IgaXMgdW5zdXBwb3J0ZWQgYW5kICcgKyAnY291bGQgY2hhbmdlIGluIGEgZnV0dXJlIHZlcnNpb24uJywga2V5KTtcblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBrbm93bktleXM7XG4gIH1cblxuICBmdW5jdGlvbiByZWNvbmNpbGVDaGlsZHJlbkFycmF5KHJldHVybkZpYmVyLCBjdXJyZW50Rmlyc3RDaGlsZCwgbmV3Q2hpbGRyZW4sIGxhbmVzKSB7XG4gICAgLy8gVGhpcyBhbGdvcml0aG0gY2FuJ3Qgb3B0aW1pemUgYnkgc2VhcmNoaW5nIGZyb20gYm90aCBlbmRzIHNpbmNlIHdlXG4gICAgLy8gZG9uJ3QgaGF2ZSBiYWNrcG9pbnRlcnMgb24gZmliZXJzLiBJJ20gdHJ5aW5nIHRvIHNlZSBob3cgZmFyIHdlIGNhbiBnZXRcbiAgICAvLyB3aXRoIHRoYXQgbW9kZWwuIElmIGl0IGVuZHMgdXAgbm90IGJlaW5nIHdvcnRoIHRoZSB0cmFkZW9mZnMsIHdlIGNhblxuICAgIC8vIGFkZCBpdCBsYXRlci5cbiAgICAvLyBFdmVuIHdpdGggYSB0d28gZW5kZWQgb3B0aW1pemF0aW9uLCB3ZSdkIHdhbnQgdG8gb3B0aW1pemUgZm9yIHRoZSBjYXNlXG4gICAgLy8gd2hlcmUgdGhlcmUgYXJlIGZldyBjaGFuZ2VzIGFuZCBicnV0ZSBmb3JjZSB0aGUgY29tcGFyaXNvbiBpbnN0ZWFkIG9mXG4gICAgLy8gZ29pbmcgZm9yIHRoZSBNYXAuIEl0J2QgbGlrZSB0byBleHBsb3JlIGhpdHRpbmcgdGhhdCBwYXRoIGZpcnN0IGluXG4gICAgLy8gZm9yd2FyZC1vbmx5IG1vZGUgYW5kIG9ubHkgZ28gZm9yIHRoZSBNYXAgb25jZSB3ZSBub3RpY2UgdGhhdCB3ZSBuZWVkXG4gICAgLy8gbG90cyBvZiBsb29rIGFoZWFkLiBUaGlzIGRvZXNuJ3QgaGFuZGxlIHJldmVyc2FsIGFzIHdlbGwgYXMgdHdvIGVuZGVkXG4gICAgLy8gc2VhcmNoIGJ1dCB0aGF0J3MgdW51c3VhbC4gQmVzaWRlcywgZm9yIHRoZSB0d28gZW5kZWQgb3B0aW1pemF0aW9uIHRvXG4gICAgLy8gd29yayBvbiBJdGVyYWJsZXMsIHdlJ2QgbmVlZCB0byBjb3B5IHRoZSB3aG9sZSBzZXQuXG4gICAgLy8gSW4gdGhpcyBmaXJzdCBpdGVyYXRpb24sIHdlJ2xsIGp1c3QgbGl2ZSB3aXRoIGhpdHRpbmcgdGhlIGJhZCBjYXNlXG4gICAgLy8gKGFkZGluZyBldmVyeXRoaW5nIHRvIGEgTWFwKSBpbiBmb3IgZXZlcnkgaW5zZXJ0L21vdmUuXG4gICAgLy8gSWYgeW91IGNoYW5nZSB0aGlzIGNvZGUsIGFsc28gdXBkYXRlIHJlY29uY2lsZUNoaWxkcmVuSXRlcmF0b3IoKSB3aGljaFxuICAgIC8vIHVzZXMgdGhlIHNhbWUgYWxnb3JpdGhtLlxuICAgIHtcbiAgICAgIC8vIEZpcnN0LCB2YWxpZGF0ZSBrZXlzLlxuICAgICAgdmFyIGtub3duS2V5cyA9IG51bGw7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbmV3Q2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGNoaWxkID0gbmV3Q2hpbGRyZW5baV07XG4gICAgICAgIGtub3duS2V5cyA9IHdhcm5PbkludmFsaWRLZXkoY2hpbGQsIGtub3duS2V5cywgcmV0dXJuRmliZXIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciByZXN1bHRpbmdGaXJzdENoaWxkID0gbnVsbDtcbiAgICB2YXIgcHJldmlvdXNOZXdGaWJlciA9IG51bGw7XG4gICAgdmFyIG9sZEZpYmVyID0gY3VycmVudEZpcnN0Q2hpbGQ7XG4gICAgdmFyIGxhc3RQbGFjZWRJbmRleCA9IDA7XG4gICAgdmFyIG5ld0lkeCA9IDA7XG4gICAgdmFyIG5leHRPbGRGaWJlciA9IG51bGw7XG5cbiAgICBmb3IgKDsgb2xkRmliZXIgIT09IG51bGwgJiYgbmV3SWR4IDwgbmV3Q2hpbGRyZW4ubGVuZ3RoOyBuZXdJZHgrKykge1xuICAgICAgaWYgKG9sZEZpYmVyLmluZGV4ID4gbmV3SWR4KSB7XG4gICAgICAgIG5leHRPbGRGaWJlciA9IG9sZEZpYmVyO1xuICAgICAgICBvbGRGaWJlciA9IG51bGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuZXh0T2xkRmliZXIgPSBvbGRGaWJlci5zaWJsaW5nO1xuICAgICAgfVxuXG4gICAgICB2YXIgbmV3RmliZXIgPSB1cGRhdGVTbG90KHJldHVybkZpYmVyLCBvbGRGaWJlciwgbmV3Q2hpbGRyZW5bbmV3SWR4XSwgbGFuZXMpO1xuXG4gICAgICBpZiAobmV3RmliZXIgPT09IG51bGwpIHtcbiAgICAgICAgLy8gVE9ETzogVGhpcyBicmVha3Mgb24gZW1wdHkgc2xvdHMgbGlrZSBudWxsIGNoaWxkcmVuLiBUaGF0J3NcbiAgICAgICAgLy8gdW5mb3J0dW5hdGUgYmVjYXVzZSBpdCB0cmlnZ2VycyB0aGUgc2xvdyBwYXRoIGFsbCB0aGUgdGltZS4gV2UgbmVlZFxuICAgICAgICAvLyBhIGJldHRlciB3YXkgdG8gY29tbXVuaWNhdGUgd2hldGhlciB0aGlzIHdhcyBhIG1pc3Mgb3IgbnVsbCxcbiAgICAgICAgLy8gYm9vbGVhbiwgdW5kZWZpbmVkLCBldGMuXG4gICAgICAgIGlmIChvbGRGaWJlciA9PT0gbnVsbCkge1xuICAgICAgICAgIG9sZEZpYmVyID0gbmV4dE9sZEZpYmVyO1xuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGlmIChzaG91bGRUcmFja1NpZGVFZmZlY3RzKSB7XG4gICAgICAgIGlmIChvbGRGaWJlciAmJiBuZXdGaWJlci5hbHRlcm5hdGUgPT09IG51bGwpIHtcbiAgICAgICAgICAvLyBXZSBtYXRjaGVkIHRoZSBzbG90LCBidXQgd2UgZGlkbid0IHJldXNlIHRoZSBleGlzdGluZyBmaWJlciwgc28gd2VcbiAgICAgICAgICAvLyBuZWVkIHRvIGRlbGV0ZSB0aGUgZXhpc3RpbmcgY2hpbGQuXG4gICAgICAgICAgZGVsZXRlQ2hpbGQocmV0dXJuRmliZXIsIG9sZEZpYmVyKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBsYXN0UGxhY2VkSW5kZXggPSBwbGFjZUNoaWxkKG5ld0ZpYmVyLCBsYXN0UGxhY2VkSW5kZXgsIG5ld0lkeCk7XG5cbiAgICAgIGlmIChwcmV2aW91c05ld0ZpYmVyID09PSBudWxsKSB7XG4gICAgICAgIC8vIFRPRE86IE1vdmUgb3V0IG9mIHRoZSBsb29wLiBUaGlzIG9ubHkgaGFwcGVucyBmb3IgdGhlIGZpcnN0IHJ1bi5cbiAgICAgICAgcmVzdWx0aW5nRmlyc3RDaGlsZCA9IG5ld0ZpYmVyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gVE9ETzogRGVmZXIgc2libGluZ3MgaWYgd2UncmUgbm90IGF0IHRoZSByaWdodCBpbmRleCBmb3IgdGhpcyBzbG90LlxuICAgICAgICAvLyBJLmUuIGlmIHdlIGhhZCBudWxsIHZhbHVlcyBiZWZvcmUsIHRoZW4gd2Ugd2FudCB0byBkZWZlciB0aGlzXG4gICAgICAgIC8vIGZvciBlYWNoIG51bGwgdmFsdWUuIEhvd2V2ZXIsIHdlIGFsc28gZG9uJ3Qgd2FudCB0byBjYWxsIHVwZGF0ZVNsb3RcbiAgICAgICAgLy8gd2l0aCB0aGUgcHJldmlvdXMgb25lLlxuICAgICAgICBwcmV2aW91c05ld0ZpYmVyLnNpYmxpbmcgPSBuZXdGaWJlcjtcbiAgICAgIH1cblxuICAgICAgcHJldmlvdXNOZXdGaWJlciA9IG5ld0ZpYmVyO1xuICAgICAgb2xkRmliZXIgPSBuZXh0T2xkRmliZXI7XG4gICAgfVxuXG4gICAgaWYgKG5ld0lkeCA9PT0gbmV3Q2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICAvLyBXZSd2ZSByZWFjaGVkIHRoZSBlbmQgb2YgdGhlIG5ldyBjaGlsZHJlbi4gV2UgY2FuIGRlbGV0ZSB0aGUgcmVzdC5cbiAgICAgIGRlbGV0ZVJlbWFpbmluZ0NoaWxkcmVuKHJldHVybkZpYmVyLCBvbGRGaWJlcik7XG4gICAgICByZXR1cm4gcmVzdWx0aW5nRmlyc3RDaGlsZDtcbiAgICB9XG5cbiAgICBpZiAob2xkRmliZXIgPT09IG51bGwpIHtcbiAgICAgIC8vIElmIHdlIGRvbid0IGhhdmUgYW55IG1vcmUgZXhpc3RpbmcgY2hpbGRyZW4gd2UgY2FuIGNob29zZSBhIGZhc3QgcGF0aFxuICAgICAgLy8gc2luY2UgdGhlIHJlc3Qgd2lsbCBhbGwgYmUgaW5zZXJ0aW9ucy5cbiAgICAgIGZvciAoOyBuZXdJZHggPCBuZXdDaGlsZHJlbi5sZW5ndGg7IG5ld0lkeCsrKSB7XG4gICAgICAgIHZhciBfbmV3RmliZXIgPSBjcmVhdGVDaGlsZChyZXR1cm5GaWJlciwgbmV3Q2hpbGRyZW5bbmV3SWR4XSwgbGFuZXMpO1xuXG4gICAgICAgIGlmIChfbmV3RmliZXIgPT09IG51bGwpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxhc3RQbGFjZWRJbmRleCA9IHBsYWNlQ2hpbGQoX25ld0ZpYmVyLCBsYXN0UGxhY2VkSW5kZXgsIG5ld0lkeCk7XG5cbiAgICAgICAgaWYgKHByZXZpb3VzTmV3RmliZXIgPT09IG51bGwpIHtcbiAgICAgICAgICAvLyBUT0RPOiBNb3ZlIG91dCBvZiB0aGUgbG9vcC4gVGhpcyBvbmx5IGhhcHBlbnMgZm9yIHRoZSBmaXJzdCBydW4uXG4gICAgICAgICAgcmVzdWx0aW5nRmlyc3RDaGlsZCA9IF9uZXdGaWJlcjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwcmV2aW91c05ld0ZpYmVyLnNpYmxpbmcgPSBfbmV3RmliZXI7XG4gICAgICAgIH1cblxuICAgICAgICBwcmV2aW91c05ld0ZpYmVyID0gX25ld0ZpYmVyO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0aW5nRmlyc3RDaGlsZDtcbiAgICB9IC8vIEFkZCBhbGwgY2hpbGRyZW4gdG8gYSBrZXkgbWFwIGZvciBxdWljayBsb29rdXBzLlxuXG5cbiAgICB2YXIgZXhpc3RpbmdDaGlsZHJlbiA9IG1hcFJlbWFpbmluZ0NoaWxkcmVuKHJldHVybkZpYmVyLCBvbGRGaWJlcik7IC8vIEtlZXAgc2Nhbm5pbmcgYW5kIHVzZSB0aGUgbWFwIHRvIHJlc3RvcmUgZGVsZXRlZCBpdGVtcyBhcyBtb3Zlcy5cblxuICAgIGZvciAoOyBuZXdJZHggPCBuZXdDaGlsZHJlbi5sZW5ndGg7IG5ld0lkeCsrKSB7XG4gICAgICB2YXIgX25ld0ZpYmVyMiA9IHVwZGF0ZUZyb21NYXAoZXhpc3RpbmdDaGlsZHJlbiwgcmV0dXJuRmliZXIsIG5ld0lkeCwgbmV3Q2hpbGRyZW5bbmV3SWR4XSwgbGFuZXMpO1xuXG4gICAgICBpZiAoX25ld0ZpYmVyMiAhPT0gbnVsbCkge1xuICAgICAgICBpZiAoc2hvdWxkVHJhY2tTaWRlRWZmZWN0cykge1xuICAgICAgICAgIGlmIChfbmV3RmliZXIyLmFsdGVybmF0ZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gVGhlIG5ldyBmaWJlciBpcyBhIHdvcmsgaW4gcHJvZ3Jlc3MsIGJ1dCBpZiB0aGVyZSBleGlzdHMgYVxuICAgICAgICAgICAgLy8gY3VycmVudCwgdGhhdCBtZWFucyB0aGF0IHdlIHJldXNlZCB0aGUgZmliZXIuIFdlIG5lZWQgdG8gZGVsZXRlXG4gICAgICAgICAgICAvLyBpdCBmcm9tIHRoZSBjaGlsZCBsaXN0IHNvIHRoYXQgd2UgZG9uJ3QgYWRkIGl0IHRvIHRoZSBkZWxldGlvblxuICAgICAgICAgICAgLy8gbGlzdC5cbiAgICAgICAgICAgIGV4aXN0aW5nQ2hpbGRyZW4uZGVsZXRlKF9uZXdGaWJlcjIua2V5ID09PSBudWxsID8gbmV3SWR4IDogX25ld0ZpYmVyMi5rZXkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGxhc3RQbGFjZWRJbmRleCA9IHBsYWNlQ2hpbGQoX25ld0ZpYmVyMiwgbGFzdFBsYWNlZEluZGV4LCBuZXdJZHgpO1xuXG4gICAgICAgIGlmIChwcmV2aW91c05ld0ZpYmVyID09PSBudWxsKSB7XG4gICAgICAgICAgcmVzdWx0aW5nRmlyc3RDaGlsZCA9IF9uZXdGaWJlcjI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcHJldmlvdXNOZXdGaWJlci5zaWJsaW5nID0gX25ld0ZpYmVyMjtcbiAgICAgICAgfVxuXG4gICAgICAgIHByZXZpb3VzTmV3RmliZXIgPSBfbmV3RmliZXIyO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChzaG91bGRUcmFja1NpZGVFZmZlY3RzKSB7XG4gICAgICAvLyBBbnkgZXhpc3RpbmcgY2hpbGRyZW4gdGhhdCB3ZXJlbid0IGNvbnN1bWVkIGFib3ZlIHdlcmUgZGVsZXRlZC4gV2UgbmVlZFxuICAgICAgLy8gdG8gYWRkIHRoZW0gdG8gdGhlIGRlbGV0aW9uIGxpc3QuXG4gICAgICBleGlzdGluZ0NoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgIHJldHVybiBkZWxldGVDaGlsZChyZXR1cm5GaWJlciwgY2hpbGQpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdGluZ0ZpcnN0Q2hpbGQ7XG4gIH1cblxuICBmdW5jdGlvbiByZWNvbmNpbGVDaGlsZHJlbkl0ZXJhdG9yKHJldHVybkZpYmVyLCBjdXJyZW50Rmlyc3RDaGlsZCwgbmV3Q2hpbGRyZW5JdGVyYWJsZSwgbGFuZXMpIHtcbiAgICAvLyBUaGlzIGlzIHRoZSBzYW1lIGltcGxlbWVudGF0aW9uIGFzIHJlY29uY2lsZUNoaWxkcmVuQXJyYXkoKSxcbiAgICAvLyBidXQgdXNpbmcgdGhlIGl0ZXJhdG9yIGluc3RlYWQuXG4gICAgdmFyIGl0ZXJhdG9yRm4gPSBnZXRJdGVyYXRvckZuKG5ld0NoaWxkcmVuSXRlcmFibGUpO1xuXG4gICAgaWYgKCEodHlwZW9mIGl0ZXJhdG9yRm4gPT09ICdmdW5jdGlvbicpKSB7XG4gICAgICB7XG4gICAgICAgIHRocm93IEVycm9yKCBcIkFuIG9iamVjdCBpcyBub3QgYW4gaXRlcmFibGUuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCIgKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB7XG4gICAgICAvLyBXZSBkb24ndCBzdXBwb3J0IHJlbmRlcmluZyBHZW5lcmF0b3JzIGJlY2F1c2UgaXQncyBhIG11dGF0aW9uLlxuICAgICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTI5OTVcbiAgICAgIGlmICh0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIC8vICRGbG93Rml4TWUgRmxvdyBkb2Vzbid0IGtub3cgYWJvdXQgdG9TdHJpbmdUYWdcbiAgICAgIG5ld0NoaWxkcmVuSXRlcmFibGVbU3ltYm9sLnRvU3RyaW5nVGFnXSA9PT0gJ0dlbmVyYXRvcicpIHtcbiAgICAgICAgaWYgKCFkaWRXYXJuQWJvdXRHZW5lcmF0b3JzKSB7XG4gICAgICAgICAgZXJyb3IoJ1VzaW5nIEdlbmVyYXRvcnMgYXMgY2hpbGRyZW4gaXMgdW5zdXBwb3J0ZWQgYW5kIHdpbGwgbGlrZWx5IHlpZWxkICcgKyAndW5leHBlY3RlZCByZXN1bHRzIGJlY2F1c2UgZW51bWVyYXRpbmcgYSBnZW5lcmF0b3IgbXV0YXRlcyBpdC4gJyArICdZb3UgbWF5IGNvbnZlcnQgaXQgdG8gYW4gYXJyYXkgd2l0aCBgQXJyYXkuZnJvbSgpYCBvciB0aGUgJyArICdgWy4uLnNwcmVhZF1gIG9wZXJhdG9yIGJlZm9yZSByZW5kZXJpbmcuIEtlZXAgaW4gbWluZCAnICsgJ3lvdSBtaWdodCBuZWVkIHRvIHBvbHlmaWxsIHRoZXNlIGZlYXR1cmVzIGZvciBvbGRlciBicm93c2Vycy4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGRpZFdhcm5BYm91dEdlbmVyYXRvcnMgPSB0cnVlO1xuICAgICAgfSAvLyBXYXJuIGFib3V0IHVzaW5nIE1hcHMgYXMgY2hpbGRyZW5cblxuXG4gICAgICBpZiAobmV3Q2hpbGRyZW5JdGVyYWJsZS5lbnRyaWVzID09PSBpdGVyYXRvckZuKSB7XG4gICAgICAgIGlmICghZGlkV2FybkFib3V0TWFwcykge1xuICAgICAgICAgIGVycm9yKCdVc2luZyBNYXBzIGFzIGNoaWxkcmVuIGlzIG5vdCBzdXBwb3J0ZWQuICcgKyAnVXNlIGFuIGFycmF5IG9mIGtleWVkIFJlYWN0RWxlbWVudHMgaW5zdGVhZC4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGRpZFdhcm5BYm91dE1hcHMgPSB0cnVlO1xuICAgICAgfSAvLyBGaXJzdCwgdmFsaWRhdGUga2V5cy5cbiAgICAgIC8vIFdlJ2xsIGdldCBhIGRpZmZlcmVudCBpdGVyYXRvciBsYXRlciBmb3IgdGhlIG1haW4gcGFzcy5cblxuXG4gICAgICB2YXIgX25ld0NoaWxkcmVuID0gaXRlcmF0b3JGbi5jYWxsKG5ld0NoaWxkcmVuSXRlcmFibGUpO1xuXG4gICAgICBpZiAoX25ld0NoaWxkcmVuKSB7XG4gICAgICAgIHZhciBrbm93bktleXMgPSBudWxsO1xuXG4gICAgICAgIHZhciBfc3RlcCA9IF9uZXdDaGlsZHJlbi5uZXh0KCk7XG5cbiAgICAgICAgZm9yICg7ICFfc3RlcC5kb25lOyBfc3RlcCA9IF9uZXdDaGlsZHJlbi5uZXh0KCkpIHtcbiAgICAgICAgICB2YXIgY2hpbGQgPSBfc3RlcC52YWx1ZTtcbiAgICAgICAgICBrbm93bktleXMgPSB3YXJuT25JbnZhbGlkS2V5KGNoaWxkLCBrbm93bktleXMsIHJldHVybkZpYmVyKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBuZXdDaGlsZHJlbiA9IGl0ZXJhdG9yRm4uY2FsbChuZXdDaGlsZHJlbkl0ZXJhYmxlKTtcblxuICAgIGlmICghKG5ld0NoaWxkcmVuICE9IG51bGwpKSB7XG4gICAgICB7XG4gICAgICAgIHRocm93IEVycm9yKCBcIkFuIGl0ZXJhYmxlIG9iamVjdCBwcm92aWRlZCBubyBpdGVyYXRvci5cIiApO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciByZXN1bHRpbmdGaXJzdENoaWxkID0gbnVsbDtcbiAgICB2YXIgcHJldmlvdXNOZXdGaWJlciA9IG51bGw7XG4gICAgdmFyIG9sZEZpYmVyID0gY3VycmVudEZpcnN0Q2hpbGQ7XG4gICAgdmFyIGxhc3RQbGFjZWRJbmRleCA9IDA7XG4gICAgdmFyIG5ld0lkeCA9IDA7XG4gICAgdmFyIG5leHRPbGRGaWJlciA9IG51bGw7XG4gICAgdmFyIHN0ZXAgPSBuZXdDaGlsZHJlbi5uZXh0KCk7XG5cbiAgICBmb3IgKDsgb2xkRmliZXIgIT09IG51bGwgJiYgIXN0ZXAuZG9uZTsgbmV3SWR4KyssIHN0ZXAgPSBuZXdDaGlsZHJlbi5uZXh0KCkpIHtcbiAgICAgIGlmIChvbGRGaWJlci5pbmRleCA+IG5ld0lkeCkge1xuICAgICAgICBuZXh0T2xkRmliZXIgPSBvbGRGaWJlcjtcbiAgICAgICAgb2xkRmliZXIgPSBudWxsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbmV4dE9sZEZpYmVyID0gb2xkRmliZXIuc2libGluZztcbiAgICAgIH1cblxuICAgICAgdmFyIG5ld0ZpYmVyID0gdXBkYXRlU2xvdChyZXR1cm5GaWJlciwgb2xkRmliZXIsIHN0ZXAudmFsdWUsIGxhbmVzKTtcblxuICAgICAgaWYgKG5ld0ZpYmVyID09PSBudWxsKSB7XG4gICAgICAgIC8vIFRPRE86IFRoaXMgYnJlYWtzIG9uIGVtcHR5IHNsb3RzIGxpa2UgbnVsbCBjaGlsZHJlbi4gVGhhdCdzXG4gICAgICAgIC8vIHVuZm9ydHVuYXRlIGJlY2F1c2UgaXQgdHJpZ2dlcnMgdGhlIHNsb3cgcGF0aCBhbGwgdGhlIHRpbWUuIFdlIG5lZWRcbiAgICAgICAgLy8gYSBiZXR0ZXIgd2F5IHRvIGNvbW11bmljYXRlIHdoZXRoZXIgdGhpcyB3YXMgYSBtaXNzIG9yIG51bGwsXG4gICAgICAgIC8vIGJvb2xlYW4sIHVuZGVmaW5lZCwgZXRjLlxuICAgICAgICBpZiAob2xkRmliZXIgPT09IG51bGwpIHtcbiAgICAgICAgICBvbGRGaWJlciA9IG5leHRPbGRGaWJlcjtcbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBpZiAoc2hvdWxkVHJhY2tTaWRlRWZmZWN0cykge1xuICAgICAgICBpZiAob2xkRmliZXIgJiYgbmV3RmliZXIuYWx0ZXJuYXRlID09PSBudWxsKSB7XG4gICAgICAgICAgLy8gV2UgbWF0Y2hlZCB0aGUgc2xvdCwgYnV0IHdlIGRpZG4ndCByZXVzZSB0aGUgZXhpc3RpbmcgZmliZXIsIHNvIHdlXG4gICAgICAgICAgLy8gbmVlZCB0byBkZWxldGUgdGhlIGV4aXN0aW5nIGNoaWxkLlxuICAgICAgICAgIGRlbGV0ZUNoaWxkKHJldHVybkZpYmVyLCBvbGRGaWJlcik7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgbGFzdFBsYWNlZEluZGV4ID0gcGxhY2VDaGlsZChuZXdGaWJlciwgbGFzdFBsYWNlZEluZGV4LCBuZXdJZHgpO1xuXG4gICAgICBpZiAocHJldmlvdXNOZXdGaWJlciA9PT0gbnVsbCkge1xuICAgICAgICAvLyBUT0RPOiBNb3ZlIG91dCBvZiB0aGUgbG9vcC4gVGhpcyBvbmx5IGhhcHBlbnMgZm9yIHRoZSBmaXJzdCBydW4uXG4gICAgICAgIHJlc3VsdGluZ0ZpcnN0Q2hpbGQgPSBuZXdGaWJlcjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFRPRE86IERlZmVyIHNpYmxpbmdzIGlmIHdlJ3JlIG5vdCBhdCB0aGUgcmlnaHQgaW5kZXggZm9yIHRoaXMgc2xvdC5cbiAgICAgICAgLy8gSS5lLiBpZiB3ZSBoYWQgbnVsbCB2YWx1ZXMgYmVmb3JlLCB0aGVuIHdlIHdhbnQgdG8gZGVmZXIgdGhpc1xuICAgICAgICAvLyBmb3IgZWFjaCBudWxsIHZhbHVlLiBIb3dldmVyLCB3ZSBhbHNvIGRvbid0IHdhbnQgdG8gY2FsbCB1cGRhdGVTbG90XG4gICAgICAgIC8vIHdpdGggdGhlIHByZXZpb3VzIG9uZS5cbiAgICAgICAgcHJldmlvdXNOZXdGaWJlci5zaWJsaW5nID0gbmV3RmliZXI7XG4gICAgICB9XG5cbiAgICAgIHByZXZpb3VzTmV3RmliZXIgPSBuZXdGaWJlcjtcbiAgICAgIG9sZEZpYmVyID0gbmV4dE9sZEZpYmVyO1xuICAgIH1cblxuICAgIGlmIChzdGVwLmRvbmUpIHtcbiAgICAgIC8vIFdlJ3ZlIHJlYWNoZWQgdGhlIGVuZCBvZiB0aGUgbmV3IGNoaWxkcmVuLiBXZSBjYW4gZGVsZXRlIHRoZSByZXN0LlxuICAgICAgZGVsZXRlUmVtYWluaW5nQ2hpbGRyZW4ocmV0dXJuRmliZXIsIG9sZEZpYmVyKTtcbiAgICAgIHJldHVybiByZXN1bHRpbmdGaXJzdENoaWxkO1xuICAgIH1cblxuICAgIGlmIChvbGRGaWJlciA9PT0gbnVsbCkge1xuICAgICAgLy8gSWYgd2UgZG9uJ3QgaGF2ZSBhbnkgbW9yZSBleGlzdGluZyBjaGlsZHJlbiB3ZSBjYW4gY2hvb3NlIGEgZmFzdCBwYXRoXG4gICAgICAvLyBzaW5jZSB0aGUgcmVzdCB3aWxsIGFsbCBiZSBpbnNlcnRpb25zLlxuICAgICAgZm9yICg7ICFzdGVwLmRvbmU7IG5ld0lkeCsrLCBzdGVwID0gbmV3Q2hpbGRyZW4ubmV4dCgpKSB7XG4gICAgICAgIHZhciBfbmV3RmliZXIzID0gY3JlYXRlQ2hpbGQocmV0dXJuRmliZXIsIHN0ZXAudmFsdWUsIGxhbmVzKTtcblxuICAgICAgICBpZiAoX25ld0ZpYmVyMyA9PT0gbnVsbCkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgbGFzdFBsYWNlZEluZGV4ID0gcGxhY2VDaGlsZChfbmV3RmliZXIzLCBsYXN0UGxhY2VkSW5kZXgsIG5ld0lkeCk7XG5cbiAgICAgICAgaWYgKHByZXZpb3VzTmV3RmliZXIgPT09IG51bGwpIHtcbiAgICAgICAgICAvLyBUT0RPOiBNb3ZlIG91dCBvZiB0aGUgbG9vcC4gVGhpcyBvbmx5IGhhcHBlbnMgZm9yIHRoZSBmaXJzdCBydW4uXG4gICAgICAgICAgcmVzdWx0aW5nRmlyc3RDaGlsZCA9IF9uZXdGaWJlcjM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcHJldmlvdXNOZXdGaWJlci5zaWJsaW5nID0gX25ld0ZpYmVyMztcbiAgICAgICAgfVxuXG4gICAgICAgIHByZXZpb3VzTmV3RmliZXIgPSBfbmV3RmliZXIzO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0aW5nRmlyc3RDaGlsZDtcbiAgICB9IC8vIEFkZCBhbGwgY2hpbGRyZW4gdG8gYSBrZXkgbWFwIGZvciBxdWljayBsb29rdXBzLlxuXG5cbiAgICB2YXIgZXhpc3RpbmdDaGlsZHJlbiA9IG1hcFJlbWFpbmluZ0NoaWxkcmVuKHJldHVybkZpYmVyLCBvbGRGaWJlcik7IC8vIEtlZXAgc2Nhbm5pbmcgYW5kIHVzZSB0aGUgbWFwIHRvIHJlc3RvcmUgZGVsZXRlZCBpdGVtcyBhcyBtb3Zlcy5cblxuICAgIGZvciAoOyAhc3RlcC5kb25lOyBuZXdJZHgrKywgc3RlcCA9IG5ld0NoaWxkcmVuLm5leHQoKSkge1xuICAgICAgdmFyIF9uZXdGaWJlcjQgPSB1cGRhdGVGcm9tTWFwKGV4aXN0aW5nQ2hpbGRyZW4sIHJldHVybkZpYmVyLCBuZXdJZHgsIHN0ZXAudmFsdWUsIGxhbmVzKTtcblxuICAgICAgaWYgKF9uZXdGaWJlcjQgIT09IG51bGwpIHtcbiAgICAgICAgaWYgKHNob3VsZFRyYWNrU2lkZUVmZmVjdHMpIHtcbiAgICAgICAgICBpZiAoX25ld0ZpYmVyNC5hbHRlcm5hdGUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIFRoZSBuZXcgZmliZXIgaXMgYSB3b3JrIGluIHByb2dyZXNzLCBidXQgaWYgdGhlcmUgZXhpc3RzIGFcbiAgICAgICAgICAgIC8vIGN1cnJlbnQsIHRoYXQgbWVhbnMgdGhhdCB3ZSByZXVzZWQgdGhlIGZpYmVyLiBXZSBuZWVkIHRvIGRlbGV0ZVxuICAgICAgICAgICAgLy8gaXQgZnJvbSB0aGUgY2hpbGQgbGlzdCBzbyB0aGF0IHdlIGRvbid0IGFkZCBpdCB0byB0aGUgZGVsZXRpb25cbiAgICAgICAgICAgIC8vIGxpc3QuXG4gICAgICAgICAgICBleGlzdGluZ0NoaWxkcmVuLmRlbGV0ZShfbmV3RmliZXI0LmtleSA9PT0gbnVsbCA/IG5ld0lkeCA6IF9uZXdGaWJlcjQua2V5KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBsYXN0UGxhY2VkSW5kZXggPSBwbGFjZUNoaWxkKF9uZXdGaWJlcjQsIGxhc3RQbGFjZWRJbmRleCwgbmV3SWR4KTtcblxuICAgICAgICBpZiAocHJldmlvdXNOZXdGaWJlciA9PT0gbnVsbCkge1xuICAgICAgICAgIHJlc3VsdGluZ0ZpcnN0Q2hpbGQgPSBfbmV3RmliZXI0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHByZXZpb3VzTmV3RmliZXIuc2libGluZyA9IF9uZXdGaWJlcjQ7XG4gICAgICAgIH1cblxuICAgICAgICBwcmV2aW91c05ld0ZpYmVyID0gX25ld0ZpYmVyNDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoc2hvdWxkVHJhY2tTaWRlRWZmZWN0cykge1xuICAgICAgLy8gQW55IGV4aXN0aW5nIGNoaWxkcmVuIHRoYXQgd2VyZW4ndCBjb25zdW1lZCBhYm92ZSB3ZXJlIGRlbGV0ZWQuIFdlIG5lZWRcbiAgICAgIC8vIHRvIGFkZCB0aGVtIHRvIHRoZSBkZWxldGlvbiBsaXN0LlxuICAgICAgZXhpc3RpbmdDaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICByZXR1cm4gZGVsZXRlQ2hpbGQocmV0dXJuRmliZXIsIGNoaWxkKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHRpbmdGaXJzdENoaWxkO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVjb25jaWxlU2luZ2xlVGV4dE5vZGUocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkLCB0ZXh0Q29udGVudCwgbGFuZXMpIHtcbiAgICAvLyBUaGVyZSdzIG5vIG5lZWQgdG8gY2hlY2sgZm9yIGtleXMgb24gdGV4dCBub2RlcyBzaW5jZSB3ZSBkb24ndCBoYXZlIGFcbiAgICAvLyB3YXkgdG8gZGVmaW5lIHRoZW0uXG4gICAgaWYgKGN1cnJlbnRGaXJzdENoaWxkICE9PSBudWxsICYmIGN1cnJlbnRGaXJzdENoaWxkLnRhZyA9PT0gSG9zdFRleHQpIHtcbiAgICAgIC8vIFdlIGFscmVhZHkgaGF2ZSBhbiBleGlzdGluZyBub2RlIHNvIGxldCdzIGp1c3QgdXBkYXRlIGl0IGFuZCBkZWxldGVcbiAgICAgIC8vIHRoZSByZXN0LlxuICAgICAgZGVsZXRlUmVtYWluaW5nQ2hpbGRyZW4ocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkLnNpYmxpbmcpO1xuICAgICAgdmFyIGV4aXN0aW5nID0gdXNlRmliZXIoY3VycmVudEZpcnN0Q2hpbGQsIHRleHRDb250ZW50KTtcbiAgICAgIGV4aXN0aW5nLnJldHVybiA9IHJldHVybkZpYmVyO1xuICAgICAgcmV0dXJuIGV4aXN0aW5nO1xuICAgIH0gLy8gVGhlIGV4aXN0aW5nIGZpcnN0IGNoaWxkIGlzIG5vdCBhIHRleHQgbm9kZSBzbyB3ZSBuZWVkIHRvIGNyZWF0ZSBvbmVcbiAgICAvLyBhbmQgZGVsZXRlIHRoZSBleGlzdGluZyBvbmVzLlxuXG5cbiAgICBkZWxldGVSZW1haW5pbmdDaGlsZHJlbihyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQpO1xuICAgIHZhciBjcmVhdGVkID0gY3JlYXRlRmliZXJGcm9tVGV4dCh0ZXh0Q29udGVudCwgcmV0dXJuRmliZXIubW9kZSwgbGFuZXMpO1xuICAgIGNyZWF0ZWQucmV0dXJuID0gcmV0dXJuRmliZXI7XG4gICAgcmV0dXJuIGNyZWF0ZWQ7XG4gIH1cblxuICBmdW5jdGlvbiByZWNvbmNpbGVTaW5nbGVFbGVtZW50KHJldHVybkZpYmVyLCBjdXJyZW50Rmlyc3RDaGlsZCwgZWxlbWVudCwgbGFuZXMpIHtcbiAgICB2YXIga2V5ID0gZWxlbWVudC5rZXk7XG4gICAgdmFyIGNoaWxkID0gY3VycmVudEZpcnN0Q2hpbGQ7XG5cbiAgICB3aGlsZSAoY2hpbGQgIT09IG51bGwpIHtcbiAgICAgIC8vIFRPRE86IElmIGtleSA9PT0gbnVsbCBhbmQgY2hpbGQua2V5ID09PSBudWxsLCB0aGVuIHRoaXMgb25seSBhcHBsaWVzIHRvXG4gICAgICAvLyB0aGUgZmlyc3QgaXRlbSBpbiB0aGUgbGlzdC5cbiAgICAgIGlmIChjaGlsZC5rZXkgPT09IGtleSkge1xuICAgICAgICBzd2l0Y2ggKGNoaWxkLnRhZykge1xuICAgICAgICAgIGNhc2UgRnJhZ21lbnQ6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGlmIChlbGVtZW50LnR5cGUgPT09IFJFQUNUX0ZSQUdNRU5UX1RZUEUpIHtcbiAgICAgICAgICAgICAgICBkZWxldGVSZW1haW5pbmdDaGlsZHJlbihyZXR1cm5GaWJlciwgY2hpbGQuc2libGluZyk7XG4gICAgICAgICAgICAgICAgdmFyIGV4aXN0aW5nID0gdXNlRmliZXIoY2hpbGQsIGVsZW1lbnQucHJvcHMuY2hpbGRyZW4pO1xuICAgICAgICAgICAgICAgIGV4aXN0aW5nLnJldHVybiA9IHJldHVybkZpYmVyO1xuXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgZXhpc3RpbmcuX2RlYnVnU291cmNlID0gZWxlbWVudC5fc291cmNlO1xuICAgICAgICAgICAgICAgICAgZXhpc3RpbmcuX2RlYnVnT3duZXIgPSBlbGVtZW50Ll9vd25lcjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gZXhpc3Rpbmc7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIGNhc2UgQmxvY2s6XG5cbiAgICAgICAgICAvLyBXZSBpbnRlbnRpb25hbGx5IGZhbGx0aHJvdWdoIGhlcmUgaWYgZW5hYmxlQmxvY2tzQVBJIGlzIG5vdCBvbi5cbiAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVkIG5vLWZhbGx0aHJvdWdoXG5cbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBpZiAoY2hpbGQuZWxlbWVudFR5cGUgPT09IGVsZW1lbnQudHlwZSB8fCAoIC8vIEtlZXAgdGhpcyBjaGVjayBpbmxpbmUgc28gaXQgb25seSBydW5zIG9uIHRoZSBmYWxzZSBwYXRoOlxuICAgICAgICAgICAgICAgaXNDb21wYXRpYmxlRmFtaWx5Rm9ySG90UmVsb2FkaW5nKGNoaWxkLCBlbGVtZW50KSApKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlUmVtYWluaW5nQ2hpbGRyZW4ocmV0dXJuRmliZXIsIGNoaWxkLnNpYmxpbmcpO1xuXG4gICAgICAgICAgICAgICAgdmFyIF9leGlzdGluZzMgPSB1c2VGaWJlcihjaGlsZCwgZWxlbWVudC5wcm9wcyk7XG5cbiAgICAgICAgICAgICAgICBfZXhpc3RpbmczLnJlZiA9IGNvZXJjZVJlZihyZXR1cm5GaWJlciwgY2hpbGQsIGVsZW1lbnQpO1xuICAgICAgICAgICAgICAgIF9leGlzdGluZzMucmV0dXJuID0gcmV0dXJuRmliZXI7XG5cbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICBfZXhpc3RpbmczLl9kZWJ1Z1NvdXJjZSA9IGVsZW1lbnQuX3NvdXJjZTtcbiAgICAgICAgICAgICAgICAgIF9leGlzdGluZzMuX2RlYnVnT3duZXIgPSBlbGVtZW50Ll9vd25lcjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gX2V4aXN0aW5nMztcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IC8vIERpZG4ndCBtYXRjaC5cblxuXG4gICAgICAgIGRlbGV0ZVJlbWFpbmluZ0NoaWxkcmVuKHJldHVybkZpYmVyLCBjaGlsZCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVsZXRlQ2hpbGQocmV0dXJuRmliZXIsIGNoaWxkKTtcbiAgICAgIH1cblxuICAgICAgY2hpbGQgPSBjaGlsZC5zaWJsaW5nO1xuICAgIH1cblxuICAgIGlmIChlbGVtZW50LnR5cGUgPT09IFJFQUNUX0ZSQUdNRU5UX1RZUEUpIHtcbiAgICAgIHZhciBjcmVhdGVkID0gY3JlYXRlRmliZXJGcm9tRnJhZ21lbnQoZWxlbWVudC5wcm9wcy5jaGlsZHJlbiwgcmV0dXJuRmliZXIubW9kZSwgbGFuZXMsIGVsZW1lbnQua2V5KTtcbiAgICAgIGNyZWF0ZWQucmV0dXJuID0gcmV0dXJuRmliZXI7XG4gICAgICByZXR1cm4gY3JlYXRlZDtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIF9jcmVhdGVkNCA9IGNyZWF0ZUZpYmVyRnJvbUVsZW1lbnQoZWxlbWVudCwgcmV0dXJuRmliZXIubW9kZSwgbGFuZXMpO1xuXG4gICAgICBfY3JlYXRlZDQucmVmID0gY29lcmNlUmVmKHJldHVybkZpYmVyLCBjdXJyZW50Rmlyc3RDaGlsZCwgZWxlbWVudCk7XG4gICAgICBfY3JlYXRlZDQucmV0dXJuID0gcmV0dXJuRmliZXI7XG4gICAgICByZXR1cm4gX2NyZWF0ZWQ0O1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlY29uY2lsZVNpbmdsZVBvcnRhbChyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQsIHBvcnRhbCwgbGFuZXMpIHtcbiAgICB2YXIga2V5ID0gcG9ydGFsLmtleTtcbiAgICB2YXIgY2hpbGQgPSBjdXJyZW50Rmlyc3RDaGlsZDtcblxuICAgIHdoaWxlIChjaGlsZCAhPT0gbnVsbCkge1xuICAgICAgLy8gVE9ETzogSWYga2V5ID09PSBudWxsIGFuZCBjaGlsZC5rZXkgPT09IG51bGwsIHRoZW4gdGhpcyBvbmx5IGFwcGxpZXMgdG9cbiAgICAgIC8vIHRoZSBmaXJzdCBpdGVtIGluIHRoZSBsaXN0LlxuICAgICAgaWYgKGNoaWxkLmtleSA9PT0ga2V5KSB7XG4gICAgICAgIGlmIChjaGlsZC50YWcgPT09IEhvc3RQb3J0YWwgJiYgY2hpbGQuc3RhdGVOb2RlLmNvbnRhaW5lckluZm8gPT09IHBvcnRhbC5jb250YWluZXJJbmZvICYmIGNoaWxkLnN0YXRlTm9kZS5pbXBsZW1lbnRhdGlvbiA9PT0gcG9ydGFsLmltcGxlbWVudGF0aW9uKSB7XG4gICAgICAgICAgZGVsZXRlUmVtYWluaW5nQ2hpbGRyZW4ocmV0dXJuRmliZXIsIGNoaWxkLnNpYmxpbmcpO1xuICAgICAgICAgIHZhciBleGlzdGluZyA9IHVzZUZpYmVyKGNoaWxkLCBwb3J0YWwuY2hpbGRyZW4gfHwgW10pO1xuICAgICAgICAgIGV4aXN0aW5nLnJldHVybiA9IHJldHVybkZpYmVyO1xuICAgICAgICAgIHJldHVybiBleGlzdGluZztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkZWxldGVSZW1haW5pbmdDaGlsZHJlbihyZXR1cm5GaWJlciwgY2hpbGQpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWxldGVDaGlsZChyZXR1cm5GaWJlciwgY2hpbGQpO1xuICAgICAgfVxuXG4gICAgICBjaGlsZCA9IGNoaWxkLnNpYmxpbmc7XG4gICAgfVxuXG4gICAgdmFyIGNyZWF0ZWQgPSBjcmVhdGVGaWJlckZyb21Qb3J0YWwocG9ydGFsLCByZXR1cm5GaWJlci5tb2RlLCBsYW5lcyk7XG4gICAgY3JlYXRlZC5yZXR1cm4gPSByZXR1cm5GaWJlcjtcbiAgICByZXR1cm4gY3JlYXRlZDtcbiAgfSAvLyBUaGlzIEFQSSB3aWxsIHRhZyB0aGUgY2hpbGRyZW4gd2l0aCB0aGUgc2lkZS1lZmZlY3Qgb2YgdGhlIHJlY29uY2lsaWF0aW9uXG4gIC8vIGl0c2VsZi4gVGhleSB3aWxsIGJlIGFkZGVkIHRvIHRoZSBzaWRlLWVmZmVjdCBsaXN0IGFzIHdlIHBhc3MgdGhyb3VnaCB0aGVcbiAgLy8gY2hpbGRyZW4gYW5kIHRoZSBwYXJlbnQuXG5cblxuICBmdW5jdGlvbiByZWNvbmNpbGVDaGlsZEZpYmVycyhyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQsIG5ld0NoaWxkLCBsYW5lcykge1xuICAgIC8vIFRoaXMgZnVuY3Rpb24gaXMgbm90IHJlY3Vyc2l2ZS5cbiAgICAvLyBJZiB0aGUgdG9wIGxldmVsIGl0ZW0gaXMgYW4gYXJyYXksIHdlIHRyZWF0IGl0IGFzIGEgc2V0IG9mIGNoaWxkcmVuLFxuICAgIC8vIG5vdCBhcyBhIGZyYWdtZW50LiBOZXN0ZWQgYXJyYXlzIG9uIHRoZSBvdGhlciBoYW5kIHdpbGwgYmUgdHJlYXRlZCBhc1xuICAgIC8vIGZyYWdtZW50IG5vZGVzLiBSZWN1cnNpb24gaGFwcGVucyBhdCB0aGUgbm9ybWFsIGZsb3cuXG4gICAgLy8gSGFuZGxlIHRvcCBsZXZlbCB1bmtleWVkIGZyYWdtZW50cyBhcyBpZiB0aGV5IHdlcmUgYXJyYXlzLlxuICAgIC8vIFRoaXMgbGVhZHMgdG8gYW4gYW1iaWd1aXR5IGJldHdlZW4gPD57Wy4uLl19PC8+IGFuZCA8Pi4uLjwvPi5cbiAgICAvLyBXZSB0cmVhdCB0aGUgYW1iaWd1b3VzIGNhc2VzIGFib3ZlIHRoZSBzYW1lLlxuICAgIHZhciBpc1Vua2V5ZWRUb3BMZXZlbEZyYWdtZW50ID0gdHlwZW9mIG5ld0NoaWxkID09PSAnb2JqZWN0JyAmJiBuZXdDaGlsZCAhPT0gbnVsbCAmJiBuZXdDaGlsZC50eXBlID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFICYmIG5ld0NoaWxkLmtleSA9PT0gbnVsbDtcblxuICAgIGlmIChpc1Vua2V5ZWRUb3BMZXZlbEZyYWdtZW50KSB7XG4gICAgICBuZXdDaGlsZCA9IG5ld0NoaWxkLnByb3BzLmNoaWxkcmVuO1xuICAgIH0gLy8gSGFuZGxlIG9iamVjdCB0eXBlc1xuXG5cbiAgICB2YXIgaXNPYmplY3QgPSB0eXBlb2YgbmV3Q2hpbGQgPT09ICdvYmplY3QnICYmIG5ld0NoaWxkICE9PSBudWxsO1xuXG4gICAgaWYgKGlzT2JqZWN0KSB7XG4gICAgICBzd2l0Y2ggKG5ld0NoaWxkLiQkdHlwZW9mKSB7XG4gICAgICAgIGNhc2UgUkVBQ1RfRUxFTUVOVF9UWVBFOlxuICAgICAgICAgIHJldHVybiBwbGFjZVNpbmdsZUNoaWxkKHJlY29uY2lsZVNpbmdsZUVsZW1lbnQocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkLCBuZXdDaGlsZCwgbGFuZXMpKTtcblxuICAgICAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxuICAgICAgICAgIHJldHVybiBwbGFjZVNpbmdsZUNoaWxkKHJlY29uY2lsZVNpbmdsZVBvcnRhbChyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQsIG5ld0NoaWxkLCBsYW5lcykpO1xuXG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBuZXdDaGlsZCA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIG5ld0NoaWxkID09PSAnbnVtYmVyJykge1xuICAgICAgcmV0dXJuIHBsYWNlU2luZ2xlQ2hpbGQocmVjb25jaWxlU2luZ2xlVGV4dE5vZGUocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkLCAnJyArIG5ld0NoaWxkLCBsYW5lcykpO1xuICAgIH1cblxuICAgIGlmIChpc0FycmF5JDEobmV3Q2hpbGQpKSB7XG4gICAgICByZXR1cm4gcmVjb25jaWxlQ2hpbGRyZW5BcnJheShyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQsIG5ld0NoaWxkLCBsYW5lcyk7XG4gICAgfVxuXG4gICAgaWYgKGdldEl0ZXJhdG9yRm4obmV3Q2hpbGQpKSB7XG4gICAgICByZXR1cm4gcmVjb25jaWxlQ2hpbGRyZW5JdGVyYXRvcihyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQsIG5ld0NoaWxkLCBsYW5lcyk7XG4gICAgfVxuXG4gICAgaWYgKGlzT2JqZWN0KSB7XG4gICAgICB0aHJvd09uSW52YWxpZE9iamVjdFR5cGUocmV0dXJuRmliZXIsIG5ld0NoaWxkKTtcbiAgICB9XG5cbiAgICB7XG4gICAgICBpZiAodHlwZW9mIG5ld0NoaWxkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHdhcm5PbkZ1bmN0aW9uVHlwZShyZXR1cm5GaWJlcik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBuZXdDaGlsZCA9PT0gJ3VuZGVmaW5lZCcgJiYgIWlzVW5rZXllZFRvcExldmVsRnJhZ21lbnQpIHtcbiAgICAgIC8vIElmIHRoZSBuZXcgY2hpbGQgaXMgdW5kZWZpbmVkLCBhbmQgdGhlIHJldHVybiBmaWJlciBpcyBhIGNvbXBvc2l0ZVxuICAgICAgLy8gY29tcG9uZW50LCB0aHJvdyBhbiBlcnJvci4gSWYgRmliZXIgcmV0dXJuIHR5cGVzIGFyZSBkaXNhYmxlZCxcbiAgICAgIC8vIHdlIGFscmVhZHkgdGhyZXcgYWJvdmUuXG4gICAgICBzd2l0Y2ggKHJldHVybkZpYmVyLnRhZykge1xuICAgICAgICBjYXNlIENsYXNzQ29tcG9uZW50OlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgdmFyIGluc3RhbmNlID0gcmV0dXJuRmliZXIuc3RhdGVOb2RlO1xuXG4gICAgICAgICAgICAgIGlmIChpbnN0YW5jZS5yZW5kZXIuX2lzTW9ja0Z1bmN0aW9uKSB7XG4gICAgICAgICAgICAgICAgLy8gV2UgYWxsb3cgYXV0by1tb2NrcyB0byBwcm9jZWVkIGFzIGlmIHRoZXkncmUgcmV0dXJuaW5nIG51bGwuXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIC8vIEludGVudGlvbmFsbHkgZmFsbCB0aHJvdWdoIHRvIHRoZSBuZXh0IGNhc2UsIHdoaWNoIGhhbmRsZXMgYm90aFxuICAgICAgICAvLyBmdW5jdGlvbnMgYW5kIGNsYXNzZXNcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lZCBuby1mYWxsdGhyb3VnaFxuXG4gICAgICAgIGNhc2UgQmxvY2s6XG4gICAgICAgIGNhc2UgRnVuY3Rpb25Db21wb25lbnQ6XG4gICAgICAgIGNhc2UgRm9yd2FyZFJlZjpcbiAgICAgICAgY2FzZSBTaW1wbGVNZW1vQ29tcG9uZW50OlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRocm93IEVycm9yKCAoZ2V0Q29tcG9uZW50TmFtZShyZXR1cm5GaWJlci50eXBlKSB8fCAnQ29tcG9uZW50JykgKyBcIiguLi4pOiBOb3RoaW5nIHdhcyByZXR1cm5lZCBmcm9tIHJlbmRlci4gVGhpcyB1c3VhbGx5IG1lYW5zIGEgcmV0dXJuIHN0YXRlbWVudCBpcyBtaXNzaW5nLiBPciwgdG8gcmVuZGVyIG5vdGhpbmcsIHJldHVybiBudWxsLlwiICk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgfSAvLyBSZW1haW5pbmcgY2FzZXMgYXJlIGFsbCB0cmVhdGVkIGFzIGVtcHR5LlxuXG5cbiAgICByZXR1cm4gZGVsZXRlUmVtYWluaW5nQ2hpbGRyZW4ocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkKTtcbiAgfVxuXG4gIHJldHVybiByZWNvbmNpbGVDaGlsZEZpYmVycztcbn1cblxudmFyIHJlY29uY2lsZUNoaWxkRmliZXJzID0gQ2hpbGRSZWNvbmNpbGVyKHRydWUpO1xudmFyIG1vdW50Q2hpbGRGaWJlcnMgPSBDaGlsZFJlY29uY2lsZXIoZmFsc2UpO1xuZnVuY3Rpb24gY2xvbmVDaGlsZEZpYmVycyhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcykge1xuICBpZiAoIShjdXJyZW50ID09PSBudWxsIHx8IHdvcmtJblByb2dyZXNzLmNoaWxkID09PSBjdXJyZW50LmNoaWxkKSkge1xuICAgIHtcbiAgICAgIHRocm93IEVycm9yKCBcIlJlc3VtaW5nIHdvcmsgbm90IHlldCBpbXBsZW1lbnRlZC5cIiApO1xuICAgIH1cbiAgfVxuXG4gIGlmICh3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9PT0gbnVsbCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBjdXJyZW50Q2hpbGQgPSB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbiAgdmFyIG5ld0NoaWxkID0gY3JlYXRlV29ya0luUHJvZ3Jlc3MoY3VycmVudENoaWxkLCBjdXJyZW50Q2hpbGQucGVuZGluZ1Byb3BzKTtcbiAgd29ya0luUHJvZ3Jlc3MuY2hpbGQgPSBuZXdDaGlsZDtcbiAgbmV3Q2hpbGQucmV0dXJuID0gd29ya0luUHJvZ3Jlc3M7XG5cbiAgd2hpbGUgKGN1cnJlbnRDaGlsZC5zaWJsaW5nICE9PSBudWxsKSB7XG4gICAgY3VycmVudENoaWxkID0gY3VycmVudENoaWxkLnNpYmxpbmc7XG4gICAgbmV3Q2hpbGQgPSBuZXdDaGlsZC5zaWJsaW5nID0gY3JlYXRlV29ya0luUHJvZ3Jlc3MoY3VycmVudENoaWxkLCBjdXJyZW50Q2hpbGQucGVuZGluZ1Byb3BzKTtcbiAgICBuZXdDaGlsZC5yZXR1cm4gPSB3b3JrSW5Qcm9ncmVzcztcbiAgfVxuXG4gIG5ld0NoaWxkLnNpYmxpbmcgPSBudWxsO1xufSAvLyBSZXNldCBhIHdvcmtJblByb2dyZXNzIGNoaWxkIHNldCB0byBwcmVwYXJlIGl0IGZvciBhIHNlY29uZCBwYXNzLlxuXG5mdW5jdGlvbiByZXNldENoaWxkRmliZXJzKHdvcmtJblByb2dyZXNzLCBsYW5lcykge1xuICB2YXIgY2hpbGQgPSB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcblxuICB3aGlsZSAoY2hpbGQgIT09IG51bGwpIHtcbiAgICByZXNldFdvcmtJblByb2dyZXNzKGNoaWxkLCBsYW5lcyk7XG4gICAgY2hpbGQgPSBjaGlsZC5zaWJsaW5nO1xuICB9XG59XG5cbnZhciBOT19DT05URVhUID0ge307XG52YXIgY29udGV4dFN0YWNrQ3Vyc29yJDEgPSBjcmVhdGVDdXJzb3IoTk9fQ09OVEVYVCk7XG52YXIgY29udGV4dEZpYmVyU3RhY2tDdXJzb3IgPSBjcmVhdGVDdXJzb3IoTk9fQ09OVEVYVCk7XG52YXIgcm9vdEluc3RhbmNlU3RhY2tDdXJzb3IgPSBjcmVhdGVDdXJzb3IoTk9fQ09OVEVYVCk7XG5cbmZ1bmN0aW9uIHJlcXVpcmVkQ29udGV4dChjKSB7XG4gIGlmICghKGMgIT09IE5PX0NPTlRFWFQpKSB7XG4gICAge1xuICAgICAgdGhyb3cgRXJyb3IoIFwiRXhwZWN0ZWQgaG9zdCBjb250ZXh0IHRvIGV4aXN0LiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiICk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGM7XG59XG5cbmZ1bmN0aW9uIGdldFJvb3RIb3N0Q29udGFpbmVyKCkge1xuICB2YXIgcm9vdEluc3RhbmNlID0gcmVxdWlyZWRDb250ZXh0KHJvb3RJbnN0YW5jZVN0YWNrQ3Vyc29yLmN1cnJlbnQpO1xuICByZXR1cm4gcm9vdEluc3RhbmNlO1xufVxuXG5mdW5jdGlvbiBwdXNoSG9zdENvbnRhaW5lcihmaWJlciwgbmV4dFJvb3RJbnN0YW5jZSkge1xuICAvLyBQdXNoIGN1cnJlbnQgcm9vdCBpbnN0YW5jZSBvbnRvIHRoZSBzdGFjaztcbiAgLy8gVGhpcyBhbGxvd3MgdXMgdG8gcmVzZXQgcm9vdCB3aGVuIHBvcnRhbHMgYXJlIHBvcHBlZC5cbiAgcHVzaChyb290SW5zdGFuY2VTdGFja0N1cnNvciwgbmV4dFJvb3RJbnN0YW5jZSwgZmliZXIpOyAvLyBUcmFjayB0aGUgY29udGV4dCBhbmQgdGhlIEZpYmVyIHRoYXQgcHJvdmlkZWQgaXQuXG4gIC8vIFRoaXMgZW5hYmxlcyB1cyB0byBwb3Agb25seSBGaWJlcnMgdGhhdCBwcm92aWRlIHVuaXF1ZSBjb250ZXh0cy5cblxuICBwdXNoKGNvbnRleHRGaWJlclN0YWNrQ3Vyc29yLCBmaWJlciwgZmliZXIpOyAvLyBGaW5hbGx5LCB3ZSBuZWVkIHRvIHB1c2ggdGhlIGhvc3QgY29udGV4dCB0byB0aGUgc3RhY2suXG4gIC8vIEhvd2V2ZXIsIHdlIGNhbid0IGp1c3QgY2FsbCBnZXRSb290SG9zdENvbnRleHQoKSBhbmQgcHVzaCBpdCBiZWNhdXNlXG4gIC8vIHdlJ2QgaGF2ZSBhIGRpZmZlcmVudCBudW1iZXIgb2YgZW50cmllcyBvbiB0aGUgc3RhY2sgZGVwZW5kaW5nIG9uXG4gIC8vIHdoZXRoZXIgZ2V0Um9vdEhvc3RDb250ZXh0KCkgdGhyb3dzIHNvbWV3aGVyZSBpbiByZW5kZXJlciBjb2RlIG9yIG5vdC5cbiAgLy8gU28gd2UgcHVzaCBhbiBlbXB0eSB2YWx1ZSBmaXJzdC4gVGhpcyBsZXRzIHVzIHNhZmVseSB1bndpbmQgb24gZXJyb3JzLlxuXG4gIHB1c2goY29udGV4dFN0YWNrQ3Vyc29yJDEsIE5PX0NPTlRFWFQsIGZpYmVyKTtcbiAgdmFyIG5leHRSb290Q29udGV4dCA9IGdldFJvb3RIb3N0Q29udGV4dChuZXh0Um9vdEluc3RhbmNlKTsgLy8gTm93IHRoYXQgd2Uga25vdyB0aGlzIGZ1bmN0aW9uIGRvZXNuJ3QgdGhyb3csIHJlcGxhY2UgaXQuXG5cbiAgcG9wKGNvbnRleHRTdGFja0N1cnNvciQxLCBmaWJlcik7XG4gIHB1c2goY29udGV4dFN0YWNrQ3Vyc29yJDEsIG5leHRSb290Q29udGV4dCwgZmliZXIpO1xufVxuXG5mdW5jdGlvbiBwb3BIb3N0Q29udGFpbmVyKGZpYmVyKSB7XG4gIHBvcChjb250ZXh0U3RhY2tDdXJzb3IkMSwgZmliZXIpO1xuICBwb3AoY29udGV4dEZpYmVyU3RhY2tDdXJzb3IsIGZpYmVyKTtcbiAgcG9wKHJvb3RJbnN0YW5jZVN0YWNrQ3Vyc29yLCBmaWJlcik7XG59XG5cbmZ1bmN0aW9uIGdldEhvc3RDb250ZXh0KCkge1xuICB2YXIgY29udGV4dCA9IHJlcXVpcmVkQ29udGV4dChjb250ZXh0U3RhY2tDdXJzb3IkMS5jdXJyZW50KTtcbiAgcmV0dXJuIGNvbnRleHQ7XG59XG5cbmZ1bmN0aW9uIHB1c2hIb3N0Q29udGV4dChmaWJlcikge1xuICB2YXIgcm9vdEluc3RhbmNlID0gcmVxdWlyZWRDb250ZXh0KHJvb3RJbnN0YW5jZVN0YWNrQ3Vyc29yLmN1cnJlbnQpO1xuICB2YXIgY29udGV4dCA9IHJlcXVpcmVkQ29udGV4dChjb250ZXh0U3RhY2tDdXJzb3IkMS5jdXJyZW50KTtcbiAgdmFyIG5leHRDb250ZXh0ID0gZ2V0Q2hpbGRIb3N0Q29udGV4dChjb250ZXh0LCBmaWJlci50eXBlKTsgLy8gRG9uJ3QgcHVzaCB0aGlzIEZpYmVyJ3MgY29udGV4dCB1bmxlc3MgaXQncyB1bmlxdWUuXG5cbiAgaWYgKGNvbnRleHQgPT09IG5leHRDb250ZXh0KSB7XG4gICAgcmV0dXJuO1xuICB9IC8vIFRyYWNrIHRoZSBjb250ZXh0IGFuZCB0aGUgRmliZXIgdGhhdCBwcm92aWRlZCBpdC5cbiAgLy8gVGhpcyBlbmFibGVzIHVzIHRvIHBvcCBvbmx5IEZpYmVycyB0aGF0IHByb3ZpZGUgdW5pcXVlIGNvbnRleHRzLlxuXG5cbiAgcHVzaChjb250ZXh0RmliZXJTdGFja0N1cnNvciwgZmliZXIsIGZpYmVyKTtcbiAgcHVzaChjb250ZXh0U3RhY2tDdXJzb3IkMSwgbmV4dENvbnRleHQsIGZpYmVyKTtcbn1cblxuZnVuY3Rpb24gcG9wSG9zdENvbnRleHQoZmliZXIpIHtcbiAgLy8gRG8gbm90IHBvcCB1bmxlc3MgdGhpcyBGaWJlciBwcm92aWRlZCB0aGUgY3VycmVudCBjb250ZXh0LlxuICAvLyBwdXNoSG9zdENvbnRleHQoKSBvbmx5IHB1c2hlcyBGaWJlcnMgdGhhdCBwcm92aWRlIHVuaXF1ZSBjb250ZXh0cy5cbiAgaWYgKGNvbnRleHRGaWJlclN0YWNrQ3Vyc29yLmN1cnJlbnQgIT09IGZpYmVyKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgcG9wKGNvbnRleHRTdGFja0N1cnNvciQxLCBmaWJlcik7XG4gIHBvcChjb250ZXh0RmliZXJTdGFja0N1cnNvciwgZmliZXIpO1xufVxuXG52YXIgRGVmYXVsdFN1c3BlbnNlQ29udGV4dCA9IDA7IC8vIFRoZSBTdXNwZW5zZSBDb250ZXh0IGlzIHNwbGl0IGludG8gdHdvIHBhcnRzLiBUaGUgbG93ZXIgYml0cyBpc1xuLy8gaW5oZXJpdGVkIGRlZXBseSBkb3duIHRoZSBzdWJ0cmVlLiBUaGUgdXBwZXIgYml0cyBvbmx5IGFmZmVjdFxuLy8gdGhpcyBpbW1lZGlhdGUgc3VzcGVuc2UgYm91bmRhcnkgYW5kIGdldHMgcmVzZXQgZWFjaCBuZXdcbi8vIGJvdW5kYXJ5IG9yIHN1c3BlbnNlIGxpc3QuXG5cbnZhciBTdWJ0cmVlU3VzcGVuc2VDb250ZXh0TWFzayA9IDE7IC8vIFN1YnRyZWUgRmxhZ3M6XG4vLyBJbnZpc2libGVQYXJlbnRTdXNwZW5zZUNvbnRleHQgaW5kaWNhdGVzIHRoYXQgb25lIG9mIG91ciBwYXJlbnQgU3VzcGVuc2Vcbi8vIGJvdW5kYXJpZXMgaXMgbm90IGN1cnJlbnRseSBzaG93aW5nIHZpc2libGUgbWFpbiBjb250ZW50LlxuLy8gRWl0aGVyIGJlY2F1c2UgaXQgaXMgYWxyZWFkeSBzaG93aW5nIGEgZmFsbGJhY2sgb3IgaXMgbm90IG1vdW50ZWQgYXQgYWxsLlxuLy8gV2UgY2FuIHVzZSB0aGlzIHRvIGRldGVybWluZSBpZiBpdCBpcyBkZXNpcmFibGUgdG8gdHJpZ2dlciBhIGZhbGxiYWNrIGF0XG4vLyB0aGUgcGFyZW50LiBJZiBub3QsIHRoZW4gd2UgbWlnaHQgbmVlZCB0byB0cmlnZ2VyIHVuZGVzaXJhYmxlIGJvdW5kYXJpZXNcbi8vIGFuZC9vciBzdXNwZW5kIHRoZSBjb21taXQgdG8gYXZvaWQgaGlkaW5nIHRoZSBwYXJlbnQgY29udGVudC5cblxudmFyIEludmlzaWJsZVBhcmVudFN1c3BlbnNlQ29udGV4dCA9IDE7IC8vIFNoYWxsb3cgRmxhZ3M6XG4vLyBGb3JjZVN1c3BlbnNlRmFsbGJhY2sgY2FuIGJlIHVzZWQgYnkgU3VzcGVuc2VMaXN0IHRvIGZvcmNlIG5ld2x5IGFkZGVkXG4vLyBpdGVtcyBpbnRvIHRoZWlyIGZhbGxiYWNrIHN0YXRlIGR1cmluZyBvbmUgb2YgdGhlIHJlbmRlciBwYXNzZXMuXG5cbnZhciBGb3JjZVN1c3BlbnNlRmFsbGJhY2sgPSAyO1xudmFyIHN1c3BlbnNlU3RhY2tDdXJzb3IgPSBjcmVhdGVDdXJzb3IoRGVmYXVsdFN1c3BlbnNlQ29udGV4dCk7XG5mdW5jdGlvbiBoYXNTdXNwZW5zZUNvbnRleHQocGFyZW50Q29udGV4dCwgZmxhZykge1xuICByZXR1cm4gKHBhcmVudENvbnRleHQgJiBmbGFnKSAhPT0gMDtcbn1cbmZ1bmN0aW9uIHNldERlZmF1bHRTaGFsbG93U3VzcGVuc2VDb250ZXh0KHBhcmVudENvbnRleHQpIHtcbiAgcmV0dXJuIHBhcmVudENvbnRleHQgJiBTdWJ0cmVlU3VzcGVuc2VDb250ZXh0TWFzaztcbn1cbmZ1bmN0aW9uIHNldFNoYWxsb3dTdXNwZW5zZUNvbnRleHQocGFyZW50Q29udGV4dCwgc2hhbGxvd0NvbnRleHQpIHtcbiAgcmV0dXJuIHBhcmVudENvbnRleHQgJiBTdWJ0cmVlU3VzcGVuc2VDb250ZXh0TWFzayB8IHNoYWxsb3dDb250ZXh0O1xufVxuZnVuY3Rpb24gYWRkU3VidHJlZVN1c3BlbnNlQ29udGV4dChwYXJlbnRDb250ZXh0LCBzdWJ0cmVlQ29udGV4dCkge1xuICByZXR1cm4gcGFyZW50Q29udGV4dCB8IHN1YnRyZWVDb250ZXh0O1xufVxuZnVuY3Rpb24gcHVzaFN1c3BlbnNlQ29udGV4dChmaWJlciwgbmV3Q29udGV4dCkge1xuICBwdXNoKHN1c3BlbnNlU3RhY2tDdXJzb3IsIG5ld0NvbnRleHQsIGZpYmVyKTtcbn1cbmZ1bmN0aW9uIHBvcFN1c3BlbnNlQ29udGV4dChmaWJlcikge1xuICBwb3Aoc3VzcGVuc2VTdGFja0N1cnNvciwgZmliZXIpO1xufVxuXG5mdW5jdGlvbiBzaG91bGRDYXB0dXJlU3VzcGVuc2Uod29ya0luUHJvZ3Jlc3MsIGhhc0ludmlzaWJsZVBhcmVudCkge1xuICAvLyBJZiBpdCB3YXMgdGhlIHByaW1hcnkgY2hpbGRyZW4gdGhhdCBqdXN0IHN1c3BlbmRlZCwgY2FwdHVyZSBhbmQgcmVuZGVyIHRoZVxuICAvLyBmYWxsYmFjay4gT3RoZXJ3aXNlLCBkb24ndCBjYXB0dXJlIGFuZCBidWJibGUgdG8gdGhlIG5leHQgYm91bmRhcnkuXG4gIHZhciBuZXh0U3RhdGUgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO1xuXG4gIGlmIChuZXh0U3RhdGUgIT09IG51bGwpIHtcbiAgICBpZiAobmV4dFN0YXRlLmRlaHlkcmF0ZWQgIT09IG51bGwpIHtcbiAgICAgIC8vIEEgZGVoeWRyYXRlZCBib3VuZGFyeSBhbHdheXMgY2FwdHVyZXMuXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIgcHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFByb3BzOyAvLyBJbiBvcmRlciB0byBjYXB0dXJlLCB0aGUgU3VzcGVuc2UgY29tcG9uZW50IG11c3QgaGF2ZSBhIGZhbGxiYWNrIHByb3AuXG5cbiAgaWYgKHByb3BzLmZhbGxiYWNrID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0gLy8gUmVndWxhciBib3VuZGFyaWVzIGFsd2F5cyBjYXB0dXJlLlxuXG5cbiAgaWYgKHByb3BzLnVuc3RhYmxlX2F2b2lkVGhpc0ZhbGxiYWNrICE9PSB0cnVlKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gLy8gSWYgaXQncyBhIGJvdW5kYXJ5IHdlIHNob3VsZCBhdm9pZCwgdGhlbiB3ZSBwcmVmZXIgdG8gYnViYmxlIHVwIHRvIHRoZVxuICAvLyBwYXJlbnQgYm91bmRhcnkgaWYgaXQgaXMgY3VycmVudGx5IGludmlzaWJsZS5cblxuXG4gIGlmIChoYXNJbnZpc2libGVQYXJlbnQpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0gLy8gSWYgdGhlIHBhcmVudCBpcyBub3QgYWJsZSB0byBoYW5kbGUgaXQsIHdlIG11c3QgaGFuZGxlIGl0LlxuXG5cbiAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBmaW5kRmlyc3RTdXNwZW5kZWQocm93KSB7XG4gIHZhciBub2RlID0gcm93O1xuXG4gIHdoaWxlIChub2RlICE9PSBudWxsKSB7XG4gICAgaWYgKG5vZGUudGFnID09PSBTdXNwZW5zZUNvbXBvbmVudCkge1xuICAgICAgdmFyIHN0YXRlID0gbm9kZS5tZW1vaXplZFN0YXRlO1xuXG4gICAgICBpZiAoc3RhdGUgIT09IG51bGwpIHtcbiAgICAgICAgdmFyIGRlaHlkcmF0ZWQgPSBzdGF0ZS5kZWh5ZHJhdGVkO1xuXG4gICAgICAgIGlmIChkZWh5ZHJhdGVkID09PSBudWxsIHx8IGlzU3VzcGVuc2VJbnN0YW5jZVBlbmRpbmcoZGVoeWRyYXRlZCkgfHwgaXNTdXNwZW5zZUluc3RhbmNlRmFsbGJhY2soZGVoeWRyYXRlZCkpIHtcbiAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobm9kZS50YWcgPT09IFN1c3BlbnNlTGlzdENvbXBvbmVudCAmJiAvLyByZXZlYWxPcmRlciB1bmRlZmluZWQgY2FuJ3QgYmUgdHJ1c3RlZCBiZWNhdXNlIGl0IGRvbid0XG4gICAgLy8ga2VlcCB0cmFjayBvZiB3aGV0aGVyIGl0IHN1c3BlbmRlZCBvciBub3QuXG4gICAgbm9kZS5tZW1vaXplZFByb3BzLnJldmVhbE9yZGVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHZhciBkaWRTdXNwZW5kID0gKG5vZGUuZmxhZ3MgJiBEaWRDYXB0dXJlKSAhPT0gTm9GbGFncztcblxuICAgICAgaWYgKGRpZFN1c3BlbmQpIHtcbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChub2RlLmNoaWxkICE9PSBudWxsKSB7XG4gICAgICBub2RlLmNoaWxkLnJldHVybiA9IG5vZGU7XG4gICAgICBub2RlID0gbm9kZS5jaGlsZDtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGlmIChub2RlID09PSByb3cpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHdoaWxlIChub2RlLnNpYmxpbmcgPT09IG51bGwpIHtcbiAgICAgIGlmIChub2RlLnJldHVybiA9PT0gbnVsbCB8fCBub2RlLnJldHVybiA9PT0gcm93KSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICBub2RlID0gbm9kZS5yZXR1cm47XG4gICAgfVxuXG4gICAgbm9kZS5zaWJsaW5nLnJldHVybiA9IG5vZGUucmV0dXJuO1xuICAgIG5vZGUgPSBub2RlLnNpYmxpbmc7XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxudmFyIE5vRmxhZ3MkMSA9XG4vKiAgKi9cbjA7IC8vIFJlcHJlc2VudHMgd2hldGhlciBlZmZlY3Qgc2hvdWxkIGZpcmUuXG5cbnZhciBIYXNFZmZlY3QgPVxuLyogKi9cbjE7IC8vIFJlcHJlc2VudHMgdGhlIHBoYXNlIGluIHdoaWNoIHRoZSBlZmZlY3QgKG5vdCB0aGUgY2xlYW4tdXApIGZpcmVzLlxuXG52YXIgTGF5b3V0ID1cbi8qICAgICovXG4yO1xudmFyIFBhc3NpdmUkMSA9XG4vKiAgICovXG40O1xuXG4vLyBUaGlzIG1heSBoYXZlIGJlZW4gYW4gaW5zZXJ0aW9uIG9yIGEgaHlkcmF0aW9uLlxuXG52YXIgaHlkcmF0aW9uUGFyZW50RmliZXIgPSBudWxsO1xudmFyIG5leHRIeWRyYXRhYmxlSW5zdGFuY2UgPSBudWxsO1xudmFyIGlzSHlkcmF0aW5nID0gZmFsc2U7XG5cbmZ1bmN0aW9uIGVudGVySHlkcmF0aW9uU3RhdGUoZmliZXIpIHtcblxuICB2YXIgcGFyZW50SW5zdGFuY2UgPSBmaWJlci5zdGF0ZU5vZGUuY29udGFpbmVySW5mbztcbiAgbmV4dEh5ZHJhdGFibGVJbnN0YW5jZSA9IGdldEZpcnN0SHlkcmF0YWJsZUNoaWxkKHBhcmVudEluc3RhbmNlKTtcbiAgaHlkcmF0aW9uUGFyZW50RmliZXIgPSBmaWJlcjtcbiAgaXNIeWRyYXRpbmcgPSB0cnVlO1xuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gZGVsZXRlSHlkcmF0YWJsZUluc3RhbmNlKHJldHVybkZpYmVyLCBpbnN0YW5jZSkge1xuICB7XG4gICAgc3dpdGNoIChyZXR1cm5GaWJlci50YWcpIHtcbiAgICAgIGNhc2UgSG9zdFJvb3Q6XG4gICAgICAgIGRpZE5vdEh5ZHJhdGVDb250YWluZXJJbnN0YW5jZShyZXR1cm5GaWJlci5zdGF0ZU5vZGUuY29udGFpbmVySW5mbywgaW5zdGFuY2UpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgICAgICBkaWROb3RIeWRyYXRlSW5zdGFuY2UocmV0dXJuRmliZXIudHlwZSwgcmV0dXJuRmliZXIubWVtb2l6ZWRQcm9wcywgcmV0dXJuRmliZXIuc3RhdGVOb2RlLCBpbnN0YW5jZSk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHZhciBjaGlsZFRvRGVsZXRlID0gY3JlYXRlRmliZXJGcm9tSG9zdEluc3RhbmNlRm9yRGVsZXRpb24oKTtcbiAgY2hpbGRUb0RlbGV0ZS5zdGF0ZU5vZGUgPSBpbnN0YW5jZTtcbiAgY2hpbGRUb0RlbGV0ZS5yZXR1cm4gPSByZXR1cm5GaWJlcjtcbiAgY2hpbGRUb0RlbGV0ZS5mbGFncyA9IERlbGV0aW9uOyAvLyBUaGlzIG1pZ2h0IHNlZW0gbGlrZSBpdCBiZWxvbmdzIG9uIHByb2dyZXNzZWRGaXJzdERlbGV0aW9uLiBIb3dldmVyLFxuICAvLyB0aGVzZSBjaGlsZHJlbiBhcmUgbm90IHBhcnQgb2YgdGhlIHJlY29uY2lsaWF0aW9uIGxpc3Qgb2YgY2hpbGRyZW4uXG4gIC8vIEV2ZW4gaWYgd2UgYWJvcnQgYW5kIHJlcmVjb25jaWxlIHRoZSBjaGlsZHJlbiwgdGhhdCB3aWxsIHRyeSB0byBoeWRyYXRlXG4gIC8vIGFnYWluIGFuZCB0aGUgbm9kZXMgYXJlIHN0aWxsIGluIHRoZSBob3N0IHRyZWUgc28gdGhlc2Ugd2lsbCBiZVxuICAvLyByZWNyZWF0ZWQuXG5cbiAgaWYgKHJldHVybkZpYmVyLmxhc3RFZmZlY3QgIT09IG51bGwpIHtcbiAgICByZXR1cm5GaWJlci5sYXN0RWZmZWN0Lm5leHRFZmZlY3QgPSBjaGlsZFRvRGVsZXRlO1xuICAgIHJldHVybkZpYmVyLmxhc3RFZmZlY3QgPSBjaGlsZFRvRGVsZXRlO1xuICB9IGVsc2Uge1xuICAgIHJldHVybkZpYmVyLmZpcnN0RWZmZWN0ID0gcmV0dXJuRmliZXIubGFzdEVmZmVjdCA9IGNoaWxkVG9EZWxldGU7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW5zZXJ0Tm9uSHlkcmF0ZWRJbnN0YW5jZShyZXR1cm5GaWJlciwgZmliZXIpIHtcbiAgZmliZXIuZmxhZ3MgPSBmaWJlci5mbGFncyAmIH5IeWRyYXRpbmcgfCBQbGFjZW1lbnQ7XG5cbiAge1xuICAgIHN3aXRjaCAocmV0dXJuRmliZXIudGFnKSB7XG4gICAgICBjYXNlIEhvc3RSb290OlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIHBhcmVudENvbnRhaW5lciA9IHJldHVybkZpYmVyLnN0YXRlTm9kZS5jb250YWluZXJJbmZvO1xuXG4gICAgICAgICAgc3dpdGNoIChmaWJlci50YWcpIHtcbiAgICAgICAgICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICAgICAgICAgICAgdmFyIHR5cGUgPSBmaWJlci50eXBlO1xuICAgICAgICAgICAgICB2YXIgcHJvcHMgPSBmaWJlci5wZW5kaW5nUHJvcHM7XG4gICAgICAgICAgICAgIGRpZE5vdEZpbmRIeWRyYXRhYmxlQ29udGFpbmVySW5zdGFuY2UocGFyZW50Q29udGFpbmVyLCB0eXBlKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgSG9zdFRleHQ6XG4gICAgICAgICAgICAgIHZhciB0ZXh0ID0gZmliZXIucGVuZGluZ1Byb3BzO1xuICAgICAgICAgICAgICBkaWROb3RGaW5kSHlkcmF0YWJsZUNvbnRhaW5lclRleHRJbnN0YW5jZShwYXJlbnRDb250YWluZXIsIHRleHQpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgcGFyZW50VHlwZSA9IHJldHVybkZpYmVyLnR5cGU7XG4gICAgICAgICAgdmFyIHBhcmVudFByb3BzID0gcmV0dXJuRmliZXIubWVtb2l6ZWRQcm9wcztcbiAgICAgICAgICB2YXIgcGFyZW50SW5zdGFuY2UgPSByZXR1cm5GaWJlci5zdGF0ZU5vZGU7XG5cbiAgICAgICAgICBzd2l0Y2ggKGZpYmVyLnRhZykge1xuICAgICAgICAgICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgICAgICAgICAgICB2YXIgX3R5cGUgPSBmaWJlci50eXBlO1xuICAgICAgICAgICAgICB2YXIgX3Byb3BzID0gZmliZXIucGVuZGluZ1Byb3BzO1xuICAgICAgICAgICAgICBkaWROb3RGaW5kSHlkcmF0YWJsZUluc3RhbmNlKHBhcmVudFR5cGUsIHBhcmVudFByb3BzLCBwYXJlbnRJbnN0YW5jZSwgX3R5cGUpO1xuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSBIb3N0VGV4dDpcbiAgICAgICAgICAgICAgdmFyIF90ZXh0ID0gZmliZXIucGVuZGluZ1Byb3BzO1xuICAgICAgICAgICAgICBkaWROb3RGaW5kSHlkcmF0YWJsZVRleHRJbnN0YW5jZShwYXJlbnRUeXBlLCBwYXJlbnRQcm9wcywgcGFyZW50SW5zdGFuY2UsIF90ZXh0KTtcbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgU3VzcGVuc2VDb21wb25lbnQ6XG4gICAgICAgICAgICAgIGRpZE5vdEZpbmRIeWRyYXRhYmxlU3VzcGVuc2VJbnN0YW5jZShwYXJlbnRUeXBlLCBwYXJlbnRQcm9wcyk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gdHJ5SHlkcmF0ZShmaWJlciwgbmV4dEluc3RhbmNlKSB7XG4gIHN3aXRjaCAoZmliZXIudGFnKSB7XG4gICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgICAge1xuICAgICAgICB2YXIgdHlwZSA9IGZpYmVyLnR5cGU7XG4gICAgICAgIHZhciBwcm9wcyA9IGZpYmVyLnBlbmRpbmdQcm9wcztcbiAgICAgICAgdmFyIGluc3RhbmNlID0gY2FuSHlkcmF0ZUluc3RhbmNlKG5leHRJbnN0YW5jZSwgdHlwZSk7XG5cbiAgICAgICAgaWYgKGluc3RhbmNlICE9PSBudWxsKSB7XG4gICAgICAgICAgZmliZXIuc3RhdGVOb2RlID0gaW5zdGFuY2U7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICBjYXNlIEhvc3RUZXh0OlxuICAgICAge1xuICAgICAgICB2YXIgdGV4dCA9IGZpYmVyLnBlbmRpbmdQcm9wcztcbiAgICAgICAgdmFyIHRleHRJbnN0YW5jZSA9IGNhbkh5ZHJhdGVUZXh0SW5zdGFuY2UobmV4dEluc3RhbmNlLCB0ZXh0KTtcblxuICAgICAgICBpZiAodGV4dEluc3RhbmNlICE9PSBudWxsKSB7XG4gICAgICAgICAgZmliZXIuc3RhdGVOb2RlID0gdGV4dEluc3RhbmNlO1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgY2FzZSBTdXNwZW5zZUNvbXBvbmVudDpcbiAgICAgIHtcblxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbmZ1bmN0aW9uIHRyeVRvQ2xhaW1OZXh0SHlkcmF0YWJsZUluc3RhbmNlKGZpYmVyKSB7XG4gIGlmICghaXNIeWRyYXRpbmcpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgbmV4dEluc3RhbmNlID0gbmV4dEh5ZHJhdGFibGVJbnN0YW5jZTtcblxuICBpZiAoIW5leHRJbnN0YW5jZSkge1xuICAgIC8vIE5vdGhpbmcgdG8gaHlkcmF0ZS4gTWFrZSBpdCBhbiBpbnNlcnRpb24uXG4gICAgaW5zZXJ0Tm9uSHlkcmF0ZWRJbnN0YW5jZShoeWRyYXRpb25QYXJlbnRGaWJlciwgZmliZXIpO1xuICAgIGlzSHlkcmF0aW5nID0gZmFsc2U7XG4gICAgaHlkcmF0aW9uUGFyZW50RmliZXIgPSBmaWJlcjtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgZmlyc3RBdHRlbXB0ZWRJbnN0YW5jZSA9IG5leHRJbnN0YW5jZTtcblxuICBpZiAoIXRyeUh5ZHJhdGUoZmliZXIsIG5leHRJbnN0YW5jZSkpIHtcbiAgICAvLyBJZiB3ZSBjYW4ndCBoeWRyYXRlIHRoaXMgaW5zdGFuY2UgbGV0J3MgdHJ5IHRoZSBuZXh0IG9uZS5cbiAgICAvLyBXZSB1c2UgdGhpcyBhcyBhIGhldXJpc3RpYy4gSXQncyBiYXNlZCBvbiBpbnR1aXRpb24gYW5kIG5vdCBkYXRhIHNvIGl0XG4gICAgLy8gbWlnaHQgYmUgZmxhd2VkIG9yIHVubmVjZXNzYXJ5LlxuICAgIG5leHRJbnN0YW5jZSA9IGdldE5leHRIeWRyYXRhYmxlU2libGluZyhmaXJzdEF0dGVtcHRlZEluc3RhbmNlKTtcblxuICAgIGlmICghbmV4dEluc3RhbmNlIHx8ICF0cnlIeWRyYXRlKGZpYmVyLCBuZXh0SW5zdGFuY2UpKSB7XG4gICAgICAvLyBOb3RoaW5nIHRvIGh5ZHJhdGUuIE1ha2UgaXQgYW4gaW5zZXJ0aW9uLlxuICAgICAgaW5zZXJ0Tm9uSHlkcmF0ZWRJbnN0YW5jZShoeWRyYXRpb25QYXJlbnRGaWJlciwgZmliZXIpO1xuICAgICAgaXNIeWRyYXRpbmcgPSBmYWxzZTtcbiAgICAgIGh5ZHJhdGlvblBhcmVudEZpYmVyID0gZmliZXI7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyBXZSBtYXRjaGVkIHRoZSBuZXh0IG9uZSwgd2UnbGwgbm93IGFzc3VtZSB0aGF0IHRoZSBmaXJzdCBvbmUgd2FzXG4gICAgLy8gc3VwZXJmbHVvdXMgYW5kIHdlJ2xsIGRlbGV0ZSBpdC4gU2luY2Ugd2UgY2FuJ3QgZWFnZXJseSBkZWxldGUgaXRcbiAgICAvLyB3ZSdsbCBoYXZlIHRvIHNjaGVkdWxlIGEgZGVsZXRpb24uIFRvIGRvIHRoYXQsIHRoaXMgbm9kZSBuZWVkcyBhIGR1bW15XG4gICAgLy8gZmliZXIgYXNzb2NpYXRlZCB3aXRoIGl0LlxuXG5cbiAgICBkZWxldGVIeWRyYXRhYmxlSW5zdGFuY2UoaHlkcmF0aW9uUGFyZW50RmliZXIsIGZpcnN0QXR0ZW1wdGVkSW5zdGFuY2UpO1xuICB9XG5cbiAgaHlkcmF0aW9uUGFyZW50RmliZXIgPSBmaWJlcjtcbiAgbmV4dEh5ZHJhdGFibGVJbnN0YW5jZSA9IGdldEZpcnN0SHlkcmF0YWJsZUNoaWxkKG5leHRJbnN0YW5jZSk7XG59XG5cbmZ1bmN0aW9uIHByZXBhcmVUb0h5ZHJhdGVIb3N0SW5zdGFuY2UoZmliZXIsIHJvb3RDb250YWluZXJJbnN0YW5jZSwgaG9zdENvbnRleHQpIHtcblxuICB2YXIgaW5zdGFuY2UgPSBmaWJlci5zdGF0ZU5vZGU7XG4gIHZhciB1cGRhdGVQYXlsb2FkID0gaHlkcmF0ZUluc3RhbmNlKGluc3RhbmNlLCBmaWJlci50eXBlLCBmaWJlci5tZW1vaXplZFByb3BzLCByb290Q29udGFpbmVySW5zdGFuY2UsIGhvc3RDb250ZXh0LCBmaWJlcik7IC8vIFRPRE86IFR5cGUgdGhpcyBzcGVjaWZpYyB0byB0aGlzIHR5cGUgb2YgY29tcG9uZW50LlxuXG4gIGZpYmVyLnVwZGF0ZVF1ZXVlID0gdXBkYXRlUGF5bG9hZDsgLy8gSWYgdGhlIHVwZGF0ZSBwYXlsb2FkIGluZGljYXRlcyB0aGF0IHRoZXJlIGlzIGEgY2hhbmdlIG9yIGlmIHRoZXJlXG4gIC8vIGlzIGEgbmV3IHJlZiB3ZSBtYXJrIHRoaXMgYXMgYW4gdXBkYXRlLlxuXG4gIGlmICh1cGRhdGVQYXlsb2FkICE9PSBudWxsKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIHByZXBhcmVUb0h5ZHJhdGVIb3N0VGV4dEluc3RhbmNlKGZpYmVyKSB7XG5cbiAgdmFyIHRleHRJbnN0YW5jZSA9IGZpYmVyLnN0YXRlTm9kZTtcbiAgdmFyIHRleHRDb250ZW50ID0gZmliZXIubWVtb2l6ZWRQcm9wcztcbiAgdmFyIHNob3VsZFVwZGF0ZSA9IGh5ZHJhdGVUZXh0SW5zdGFuY2UodGV4dEluc3RhbmNlLCB0ZXh0Q29udGVudCwgZmliZXIpO1xuXG4gIHtcbiAgICBpZiAoc2hvdWxkVXBkYXRlKSB7XG4gICAgICAvLyBXZSBhc3N1bWUgdGhhdCBwcmVwYXJlVG9IeWRyYXRlSG9zdFRleHRJbnN0YW5jZSBpcyBjYWxsZWQgaW4gYSBjb250ZXh0IHdoZXJlIHRoZVxuICAgICAgLy8gaHlkcmF0aW9uIHBhcmVudCBpcyB0aGUgcGFyZW50IGhvc3QgY29tcG9uZW50IG9mIHRoaXMgaG9zdCB0ZXh0LlxuICAgICAgdmFyIHJldHVybkZpYmVyID0gaHlkcmF0aW9uUGFyZW50RmliZXI7XG5cbiAgICAgIGlmIChyZXR1cm5GaWJlciAhPT0gbnVsbCkge1xuICAgICAgICBzd2l0Y2ggKHJldHVybkZpYmVyLnRhZykge1xuICAgICAgICAgIGNhc2UgSG9zdFJvb3Q6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHZhciBwYXJlbnRDb250YWluZXIgPSByZXR1cm5GaWJlci5zdGF0ZU5vZGUuY29udGFpbmVySW5mbztcbiAgICAgICAgICAgICAgZGlkTm90TWF0Y2hIeWRyYXRlZENvbnRhaW5lclRleHRJbnN0YW5jZShwYXJlbnRDb250YWluZXIsIHRleHRJbnN0YW5jZSwgdGV4dENvbnRlbnQpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgdmFyIHBhcmVudFR5cGUgPSByZXR1cm5GaWJlci50eXBlO1xuICAgICAgICAgICAgICB2YXIgcGFyZW50UHJvcHMgPSByZXR1cm5GaWJlci5tZW1vaXplZFByb3BzO1xuICAgICAgICAgICAgICB2YXIgcGFyZW50SW5zdGFuY2UgPSByZXR1cm5GaWJlci5zdGF0ZU5vZGU7XG4gICAgICAgICAgICAgIGRpZE5vdE1hdGNoSHlkcmF0ZWRUZXh0SW5zdGFuY2UocGFyZW50VHlwZSwgcGFyZW50UHJvcHMsIHBhcmVudEluc3RhbmNlLCB0ZXh0SW5zdGFuY2UsIHRleHRDb250ZW50KTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gc2hvdWxkVXBkYXRlO1xufVxuXG5mdW5jdGlvbiBza2lwUGFzdERlaHlkcmF0ZWRTdXNwZW5zZUluc3RhbmNlKGZpYmVyKSB7XG5cbiAgdmFyIHN1c3BlbnNlU3RhdGUgPSBmaWJlci5tZW1vaXplZFN0YXRlO1xuICB2YXIgc3VzcGVuc2VJbnN0YW5jZSA9IHN1c3BlbnNlU3RhdGUgIT09IG51bGwgPyBzdXNwZW5zZVN0YXRlLmRlaHlkcmF0ZWQgOiBudWxsO1xuXG4gIGlmICghc3VzcGVuc2VJbnN0YW5jZSkge1xuICAgIHtcbiAgICAgIHRocm93IEVycm9yKCBcIkV4cGVjdGVkIHRvIGhhdmUgYSBoeWRyYXRlZCBzdXNwZW5zZSBpbnN0YW5jZS4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS5cIiApO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBnZXROZXh0SHlkcmF0YWJsZUluc3RhbmNlQWZ0ZXJTdXNwZW5zZUluc3RhbmNlKHN1c3BlbnNlSW5zdGFuY2UpO1xufVxuXG5mdW5jdGlvbiBwb3BUb05leHRIb3N0UGFyZW50KGZpYmVyKSB7XG4gIHZhciBwYXJlbnQgPSBmaWJlci5yZXR1cm47XG5cbiAgd2hpbGUgKHBhcmVudCAhPT0gbnVsbCAmJiBwYXJlbnQudGFnICE9PSBIb3N0Q29tcG9uZW50ICYmIHBhcmVudC50YWcgIT09IEhvc3RSb290ICYmIHBhcmVudC50YWcgIT09IFN1c3BlbnNlQ29tcG9uZW50KSB7XG4gICAgcGFyZW50ID0gcGFyZW50LnJldHVybjtcbiAgfVxuXG4gIGh5ZHJhdGlvblBhcmVudEZpYmVyID0gcGFyZW50O1xufVxuXG5mdW5jdGlvbiBwb3BIeWRyYXRpb25TdGF0ZShmaWJlcikge1xuXG4gIGlmIChmaWJlciAhPT0gaHlkcmF0aW9uUGFyZW50RmliZXIpIHtcbiAgICAvLyBXZSdyZSBkZWVwZXIgdGhhbiB0aGUgY3VycmVudCBoeWRyYXRpb24gY29udGV4dCwgaW5zaWRlIGFuIGluc2VydGVkXG4gICAgLy8gdHJlZS5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoIWlzSHlkcmF0aW5nKSB7XG4gICAgLy8gSWYgd2UncmUgbm90IGN1cnJlbnRseSBoeWRyYXRpbmcgYnV0IHdlJ3JlIGluIGEgaHlkcmF0aW9uIGNvbnRleHQsIHRoZW5cbiAgICAvLyB3ZSB3ZXJlIGFuIGluc2VydGlvbiBhbmQgbm93IG5lZWQgdG8gcG9wIHVwIHJlZW50ZXIgaHlkcmF0aW9uIG9mIG91clxuICAgIC8vIHNpYmxpbmdzLlxuICAgIHBvcFRvTmV4dEhvc3RQYXJlbnQoZmliZXIpO1xuICAgIGlzSHlkcmF0aW5nID0gdHJ1ZTtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIgdHlwZSA9IGZpYmVyLnR5cGU7IC8vIElmIHdlIGhhdmUgYW55IHJlbWFpbmluZyBoeWRyYXRhYmxlIG5vZGVzLCB3ZSBuZWVkIHRvIGRlbGV0ZSB0aGVtIG5vdy5cbiAgLy8gV2Ugb25seSBkbyB0aGlzIGRlZXBlciB0aGFuIGhlYWQgYW5kIGJvZHkgc2luY2UgdGhleSB0ZW5kIHRvIGhhdmUgcmFuZG9tXG4gIC8vIG90aGVyIG5vZGVzIGluIHRoZW0uIFdlIGFsc28gaWdub3JlIGNvbXBvbmVudHMgd2l0aCBwdXJlIHRleHQgY29udGVudCBpblxuICAvLyBzaWRlIG9mIHRoZW0uXG4gIC8vIFRPRE86IEJldHRlciBoZXVyaXN0aWMuXG5cbiAgaWYgKGZpYmVyLnRhZyAhPT0gSG9zdENvbXBvbmVudCB8fCB0eXBlICE9PSAnaGVhZCcgJiYgdHlwZSAhPT0gJ2JvZHknICYmICFzaG91bGRTZXRUZXh0Q29udGVudCh0eXBlLCBmaWJlci5tZW1vaXplZFByb3BzKSkge1xuICAgIHZhciBuZXh0SW5zdGFuY2UgPSBuZXh0SHlkcmF0YWJsZUluc3RhbmNlO1xuXG4gICAgd2hpbGUgKG5leHRJbnN0YW5jZSkge1xuICAgICAgZGVsZXRlSHlkcmF0YWJsZUluc3RhbmNlKGZpYmVyLCBuZXh0SW5zdGFuY2UpO1xuICAgICAgbmV4dEluc3RhbmNlID0gZ2V0TmV4dEh5ZHJhdGFibGVTaWJsaW5nKG5leHRJbnN0YW5jZSk7XG4gICAgfVxuICB9XG5cbiAgcG9wVG9OZXh0SG9zdFBhcmVudChmaWJlcik7XG5cbiAgaWYgKGZpYmVyLnRhZyA9PT0gU3VzcGVuc2VDb21wb25lbnQpIHtcbiAgICBuZXh0SHlkcmF0YWJsZUluc3RhbmNlID0gc2tpcFBhc3REZWh5ZHJhdGVkU3VzcGVuc2VJbnN0YW5jZShmaWJlcik7XG4gIH0gZWxzZSB7XG4gICAgbmV4dEh5ZHJhdGFibGVJbnN0YW5jZSA9IGh5ZHJhdGlvblBhcmVudEZpYmVyID8gZ2V0TmV4dEh5ZHJhdGFibGVTaWJsaW5nKGZpYmVyLnN0YXRlTm9kZSkgOiBudWxsO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIHJlc2V0SHlkcmF0aW9uU3RhdGUoKSB7XG5cbiAgaHlkcmF0aW9uUGFyZW50RmliZXIgPSBudWxsO1xuICBuZXh0SHlkcmF0YWJsZUluc3RhbmNlID0gbnVsbDtcbiAgaXNIeWRyYXRpbmcgPSBmYWxzZTtcbn1cblxuZnVuY3Rpb24gZ2V0SXNIeWRyYXRpbmcoKSB7XG4gIHJldHVybiBpc0h5ZHJhdGluZztcbn1cblxuLy8gYW5kIHNob3VsZCBiZSByZXNldCBiZWZvcmUgc3RhcnRpbmcgYSBuZXcgcmVuZGVyLlxuLy8gVGhpcyB0cmFja3Mgd2hpY2ggbXV0YWJsZSBzb3VyY2VzIG5lZWQgdG8gYmUgcmVzZXQgYWZ0ZXIgYSByZW5kZXIuXG5cbnZhciB3b3JrSW5Qcm9ncmVzc1NvdXJjZXMgPSBbXTtcbnZhciByZW5kZXJlclNpZ2lsJDE7XG5cbntcbiAgLy8gVXNlZCB0byBkZXRlY3QgbXVsdGlwbGUgcmVuZGVyZXJzIHVzaW5nIHRoZSBzYW1lIG11dGFibGUgc291cmNlLlxuICByZW5kZXJlclNpZ2lsJDEgPSB7fTtcbn1cblxuZnVuY3Rpb24gbWFya1NvdXJjZUFzRGlydHkobXV0YWJsZVNvdXJjZSkge1xuICB3b3JrSW5Qcm9ncmVzc1NvdXJjZXMucHVzaChtdXRhYmxlU291cmNlKTtcbn1cbmZ1bmN0aW9uIHJlc2V0V29ya0luUHJvZ3Jlc3NWZXJzaW9ucygpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB3b3JrSW5Qcm9ncmVzc1NvdXJjZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgbXV0YWJsZVNvdXJjZSA9IHdvcmtJblByb2dyZXNzU291cmNlc1tpXTtcblxuICAgIHtcbiAgICAgIG11dGFibGVTb3VyY2UuX3dvcmtJblByb2dyZXNzVmVyc2lvblByaW1hcnkgPSBudWxsO1xuICAgIH1cbiAgfVxuXG4gIHdvcmtJblByb2dyZXNzU291cmNlcy5sZW5ndGggPSAwO1xufVxuZnVuY3Rpb24gZ2V0V29ya0luUHJvZ3Jlc3NWZXJzaW9uKG11dGFibGVTb3VyY2UpIHtcbiAge1xuICAgIHJldHVybiBtdXRhYmxlU291cmNlLl93b3JrSW5Qcm9ncmVzc1ZlcnNpb25QcmltYXJ5O1xuICB9XG59XG5mdW5jdGlvbiBzZXRXb3JrSW5Qcm9ncmVzc1ZlcnNpb24obXV0YWJsZVNvdXJjZSwgdmVyc2lvbikge1xuICB7XG4gICAgbXV0YWJsZVNvdXJjZS5fd29ya0luUHJvZ3Jlc3NWZXJzaW9uUHJpbWFyeSA9IHZlcnNpb247XG4gIH1cblxuICB3b3JrSW5Qcm9ncmVzc1NvdXJjZXMucHVzaChtdXRhYmxlU291cmNlKTtcbn1cbmZ1bmN0aW9uIHdhcm5BYm91dE11bHRpcGxlUmVuZGVyZXJzREVWKG11dGFibGVTb3VyY2UpIHtcbiAge1xuICAgIHtcbiAgICAgIGlmIChtdXRhYmxlU291cmNlLl9jdXJyZW50UHJpbWFyeVJlbmRlcmVyID09IG51bGwpIHtcbiAgICAgICAgbXV0YWJsZVNvdXJjZS5fY3VycmVudFByaW1hcnlSZW5kZXJlciA9IHJlbmRlcmVyU2lnaWwkMTtcbiAgICAgIH0gZWxzZSBpZiAobXV0YWJsZVNvdXJjZS5fY3VycmVudFByaW1hcnlSZW5kZXJlciAhPT0gcmVuZGVyZXJTaWdpbCQxKSB7XG4gICAgICAgIGVycm9yKCdEZXRlY3RlZCBtdWx0aXBsZSByZW5kZXJlcnMgY29uY3VycmVudGx5IHJlbmRlcmluZyB0aGUgJyArICdzYW1lIG11dGFibGUgc291cmNlLiBUaGlzIGlzIGN1cnJlbnRseSB1bnN1cHBvcnRlZC4nKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn0gLy8gRWFnZXIgcmVhZHMgdGhlIHZlcnNpb24gb2YgYSBtdXRhYmxlIHNvdXJjZSBhbmQgc3RvcmVzIGl0IG9uIHRoZSByb290LlxuXG52YXIgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3RDdXJyZW50RGlzcGF0Y2hlcixcbiAgICBSZWFjdEN1cnJlbnRCYXRjaENvbmZpZyQxID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3RDdXJyZW50QmF0Y2hDb25maWc7XG52YXIgZGlkV2FybkFib3V0TWlzbWF0Y2hlZEhvb2tzRm9yQ29tcG9uZW50O1xudmFyIGRpZFdhcm5BYm91dFVzZU9wYXF1ZUlkZW50aWZpZXI7XG5cbntcbiAgZGlkV2FybkFib3V0VXNlT3BhcXVlSWRlbnRpZmllciA9IHt9O1xuICBkaWRXYXJuQWJvdXRNaXNtYXRjaGVkSG9va3NGb3JDb21wb25lbnQgPSBuZXcgU2V0KCk7XG59XG5cbi8vIFRoZXNlIGFyZSBzZXQgcmlnaHQgYmVmb3JlIGNhbGxpbmcgdGhlIGNvbXBvbmVudC5cbnZhciByZW5kZXJMYW5lcyA9IE5vTGFuZXM7IC8vIFRoZSB3b3JrLWluLXByb2dyZXNzIGZpYmVyLiBJJ3ZlIG5hbWVkIGl0IGRpZmZlcmVudGx5IHRvIGRpc3Rpbmd1aXNoIGl0IGZyb21cbi8vIHRoZSB3b3JrLWluLXByb2dyZXNzIGhvb2suXG5cbnZhciBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxID0gbnVsbDsgLy8gSG9va3MgYXJlIHN0b3JlZCBhcyBhIGxpbmtlZCBsaXN0IG9uIHRoZSBmaWJlcidzIG1lbW9pemVkU3RhdGUgZmllbGQuIFRoZVxuLy8gY3VycmVudCBob29rIGxpc3QgaXMgdGhlIGxpc3QgdGhhdCBiZWxvbmdzIHRvIHRoZSBjdXJyZW50IGZpYmVyLiBUaGVcbi8vIHdvcmstaW4tcHJvZ3Jlc3MgaG9vayBsaXN0IGlzIGEgbmV3IGxpc3QgdGhhdCB3aWxsIGJlIGFkZGVkIHRvIHRoZVxuLy8gd29yay1pbi1wcm9ncmVzcyBmaWJlci5cblxudmFyIGN1cnJlbnRIb29rID0gbnVsbDtcbnZhciB3b3JrSW5Qcm9ncmVzc0hvb2sgPSBudWxsOyAvLyBXaGV0aGVyIGFuIHVwZGF0ZSB3YXMgc2NoZWR1bGVkIGF0IGFueSBwb2ludCBkdXJpbmcgdGhlIHJlbmRlciBwaGFzZS4gVGhpc1xuLy8gZG9lcyBub3QgZ2V0IHJlc2V0IGlmIHdlIGRvIGFub3RoZXIgcmVuZGVyIHBhc3M7IG9ubHkgd2hlbiB3ZSdyZSBjb21wbGV0ZWx5XG4vLyBmaW5pc2hlZCBldmFsdWF0aW5nIHRoaXMgY29tcG9uZW50LiBUaGlzIGlzIGFuIG9wdGltaXphdGlvbiBzbyB3ZSBrbm93XG4vLyB3aGV0aGVyIHdlIG5lZWQgdG8gY2xlYXIgcmVuZGVyIHBoYXNlIHVwZGF0ZXMgYWZ0ZXIgYSB0aHJvdy5cblxudmFyIGRpZFNjaGVkdWxlUmVuZGVyUGhhc2VVcGRhdGUgPSBmYWxzZTsgLy8gV2hlcmUgYW4gdXBkYXRlIHdhcyBzY2hlZHVsZWQgb25seSBkdXJpbmcgdGhlIGN1cnJlbnQgcmVuZGVyIHBhc3MuIFRoaXNcbi8vIGdldHMgcmVzZXQgYWZ0ZXIgZWFjaCBhdHRlbXB0LlxuLy8gVE9ETzogTWF5YmUgdGhlcmUncyBzb21lIHdheSB0byBjb25zb2xpZGF0ZSB0aGlzIHdpdGhcbi8vIGBkaWRTY2hlZHVsZVJlbmRlclBoYXNlVXBkYXRlYC4gT3Igd2l0aCBgbnVtYmVyT2ZSZVJlbmRlcnNgLlxuXG52YXIgZGlkU2NoZWR1bGVSZW5kZXJQaGFzZVVwZGF0ZUR1cmluZ1RoaXNQYXNzID0gZmFsc2U7XG52YXIgUkVfUkVOREVSX0xJTUlUID0gMjU7IC8vIEluIERFViwgdGhpcyBpcyB0aGUgbmFtZSBvZiB0aGUgY3VycmVudGx5IGV4ZWN1dGluZyBwcmltaXRpdmUgaG9va1xuXG52YXIgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBudWxsOyAvLyBJbiBERVYsIHRoaXMgbGlzdCBlbnN1cmVzIHRoYXQgaG9va3MgYXJlIGNhbGxlZCBpbiB0aGUgc2FtZSBvcmRlciBiZXR3ZWVuIHJlbmRlcnMuXG4vLyBUaGUgbGlzdCBzdG9yZXMgdGhlIG9yZGVyIG9mIGhvb2tzIHVzZWQgZHVyaW5nIHRoZSBpbml0aWFsIHJlbmRlciAobW91bnQpLlxuLy8gU3Vic2VxdWVudCByZW5kZXJzICh1cGRhdGVzKSByZWZlcmVuY2UgdGhpcyBsaXN0LlxuXG52YXIgaG9va1R5cGVzRGV2ID0gbnVsbDtcbnZhciBob29rVHlwZXNVcGRhdGVJbmRleERldiA9IC0xOyAvLyBJbiBERVYsIHRoaXMgdHJhY2tzIHdoZXRoZXIgY3VycmVudGx5IHJlbmRlcmluZyBjb21wb25lbnQgbmVlZHMgdG8gaWdub3JlXG4vLyB0aGUgZGVwZW5kZW5jaWVzIGZvciBIb29rcyB0aGF0IG5lZWQgdGhlbSAoZS5nLiB1c2VFZmZlY3Qgb3IgdXNlTWVtbykuXG4vLyBXaGVuIHRydWUsIHN1Y2ggSG9va3Mgd2lsbCBhbHdheXMgYmUgXCJyZW1vdW50ZWRcIi4gT25seSB1c2VkIGR1cmluZyBob3QgcmVsb2FkLlxuXG52YXIgaWdub3JlUHJldmlvdXNEZXBlbmRlbmNpZXMgPSBmYWxzZTtcblxuZnVuY3Rpb24gbW91bnRIb29rVHlwZXNEZXYoKSB7XG4gIHtcbiAgICB2YXIgaG9va05hbWUgPSBjdXJyZW50SG9va05hbWVJbkRldjtcblxuICAgIGlmIChob29rVHlwZXNEZXYgPT09IG51bGwpIHtcbiAgICAgIGhvb2tUeXBlc0RldiA9IFtob29rTmFtZV07XG4gICAgfSBlbHNlIHtcbiAgICAgIGhvb2tUeXBlc0Rldi5wdXNoKGhvb2tOYW1lKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gdXBkYXRlSG9va1R5cGVzRGV2KCkge1xuICB7XG4gICAgdmFyIGhvb2tOYW1lID0gY3VycmVudEhvb2tOYW1lSW5EZXY7XG5cbiAgICBpZiAoaG9va1R5cGVzRGV2ICE9PSBudWxsKSB7XG4gICAgICBob29rVHlwZXNVcGRhdGVJbmRleERldisrO1xuXG4gICAgICBpZiAoaG9va1R5cGVzRGV2W2hvb2tUeXBlc1VwZGF0ZUluZGV4RGV2XSAhPT0gaG9va05hbWUpIHtcbiAgICAgICAgd2Fybk9uSG9va01pc21hdGNoSW5EZXYoaG9va05hbWUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjaGVja0RlcHNBcmVBcnJheURldihkZXBzKSB7XG4gIHtcbiAgICBpZiAoZGVwcyAhPT0gdW5kZWZpbmVkICYmIGRlcHMgIT09IG51bGwgJiYgIUFycmF5LmlzQXJyYXkoZGVwcykpIHtcbiAgICAgIC8vIFZlcmlmeSBkZXBzLCBidXQgb25seSBvbiBtb3VudCB0byBhdm9pZCBleHRyYSBjaGVja3MuXG4gICAgICAvLyBJdCdzIHVubGlrZWx5IHRoZWlyIHR5cGUgd291bGQgY2hhbmdlIGFzIHVzdWFsbHkgeW91IGRlZmluZSB0aGVtIGlubGluZS5cbiAgICAgIGVycm9yKCclcyByZWNlaXZlZCBhIGZpbmFsIGFyZ3VtZW50IHRoYXQgaXMgbm90IGFuIGFycmF5IChpbnN0ZWFkLCByZWNlaXZlZCBgJXNgKS4gV2hlbiAnICsgJ3NwZWNpZmllZCwgdGhlIGZpbmFsIGFyZ3VtZW50IG11c3QgYmUgYW4gYXJyYXkuJywgY3VycmVudEhvb2tOYW1lSW5EZXYsIHR5cGVvZiBkZXBzKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gd2Fybk9uSG9va01pc21hdGNoSW5EZXYoY3VycmVudEhvb2tOYW1lKSB7XG4gIHtcbiAgICB2YXIgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWUoY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMS50eXBlKTtcblxuICAgIGlmICghZGlkV2FybkFib3V0TWlzbWF0Y2hlZEhvb2tzRm9yQ29tcG9uZW50Lmhhcyhjb21wb25lbnROYW1lKSkge1xuICAgICAgZGlkV2FybkFib3V0TWlzbWF0Y2hlZEhvb2tzRm9yQ29tcG9uZW50LmFkZChjb21wb25lbnROYW1lKTtcblxuICAgICAgaWYgKGhvb2tUeXBlc0RldiAhPT0gbnVsbCkge1xuICAgICAgICB2YXIgdGFibGUgPSAnJztcbiAgICAgICAgdmFyIHNlY29uZENvbHVtblN0YXJ0ID0gMzA7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPD0gaG9va1R5cGVzVXBkYXRlSW5kZXhEZXY7IGkrKykge1xuICAgICAgICAgIHZhciBvbGRIb29rTmFtZSA9IGhvb2tUeXBlc0RldltpXTtcbiAgICAgICAgICB2YXIgbmV3SG9va05hbWUgPSBpID09PSBob29rVHlwZXNVcGRhdGVJbmRleERldiA/IGN1cnJlbnRIb29rTmFtZSA6IG9sZEhvb2tOYW1lO1xuICAgICAgICAgIHZhciByb3cgPSBpICsgMSArIFwiLiBcIiArIG9sZEhvb2tOYW1lOyAvLyBFeHRyYSBzcGFjZSBzbyBzZWNvbmQgY29sdW1uIGxpbmVzIHVwXG4gICAgICAgICAgLy8gbG9sIEAgSUUgbm90IHN1cHBvcnRpbmcgU3RyaW5nI3JlcGVhdFxuXG4gICAgICAgICAgd2hpbGUgKHJvdy5sZW5ndGggPCBzZWNvbmRDb2x1bW5TdGFydCkge1xuICAgICAgICAgICAgcm93ICs9ICcgJztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByb3cgKz0gbmV3SG9va05hbWUgKyAnXFxuJztcbiAgICAgICAgICB0YWJsZSArPSByb3c7XG4gICAgICAgIH1cblxuICAgICAgICBlcnJvcignUmVhY3QgaGFzIGRldGVjdGVkIGEgY2hhbmdlIGluIHRoZSBvcmRlciBvZiBIb29rcyBjYWxsZWQgYnkgJXMuICcgKyAnVGhpcyB3aWxsIGxlYWQgdG8gYnVncyBhbmQgZXJyb3JzIGlmIG5vdCBmaXhlZC4gJyArICdGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVhZCB0aGUgUnVsZXMgb2YgSG9va3M6IGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9ydWxlcy1vZi1ob29rc1xcblxcbicgKyAnICAgUHJldmlvdXMgcmVuZGVyICAgICAgICAgICAgTmV4dCByZW5kZXJcXG4nICsgJyAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcbicgKyAnJXMnICsgJyAgIF5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXlxcbicsIGNvbXBvbmVudE5hbWUsIHRhYmxlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gdGhyb3dJbnZhbGlkSG9va0Vycm9yKCkge1xuICB7XG4gICAge1xuICAgICAgdGhyb3cgRXJyb3IoIFwiSW52YWxpZCBob29rIGNhbGwuIEhvb2tzIGNhbiBvbmx5IGJlIGNhbGxlZCBpbnNpZGUgb2YgdGhlIGJvZHkgb2YgYSBmdW5jdGlvbiBjb21wb25lbnQuIFRoaXMgY291bGQgaGFwcGVuIGZvciBvbmUgb2YgdGhlIGZvbGxvd2luZyByZWFzb25zOlxcbjEuIFlvdSBtaWdodCBoYXZlIG1pc21hdGNoaW5nIHZlcnNpb25zIG9mIFJlYWN0IGFuZCB0aGUgcmVuZGVyZXIgKHN1Y2ggYXMgUmVhY3QgRE9NKVxcbjIuIFlvdSBtaWdodCBiZSBicmVha2luZyB0aGUgUnVsZXMgb2YgSG9va3NcXG4zLiBZb3UgbWlnaHQgaGF2ZSBtb3JlIHRoYW4gb25lIGNvcHkgb2YgUmVhY3QgaW4gdGhlIHNhbWUgYXBwXFxuU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9pbnZhbGlkLWhvb2stY2FsbCBmb3IgdGlwcyBhYm91dCBob3cgdG8gZGVidWcgYW5kIGZpeCB0aGlzIHByb2JsZW0uXCIgKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gYXJlSG9va0lucHV0c0VxdWFsKG5leHREZXBzLCBwcmV2RGVwcykge1xuICB7XG4gICAgaWYgKGlnbm9yZVByZXZpb3VzRGVwZW5kZW5jaWVzKSB7XG4gICAgICAvLyBPbmx5IHRydWUgd2hlbiB0aGlzIGNvbXBvbmVudCBpcyBiZWluZyBob3QgcmVsb2FkZWQuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgaWYgKHByZXZEZXBzID09PSBudWxsKSB7XG4gICAge1xuICAgICAgZXJyb3IoJyVzIHJlY2VpdmVkIGEgZmluYWwgYXJndW1lbnQgZHVyaW5nIHRoaXMgcmVuZGVyLCBidXQgbm90IGR1cmluZyAnICsgJ3RoZSBwcmV2aW91cyByZW5kZXIuIEV2ZW4gdGhvdWdoIHRoZSBmaW5hbCBhcmd1bWVudCBpcyBvcHRpb25hbCwgJyArICdpdHMgdHlwZSBjYW5ub3QgY2hhbmdlIGJldHdlZW4gcmVuZGVycy4nLCBjdXJyZW50SG9va05hbWVJbkRldik7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAge1xuICAgIC8vIERvbid0IGJvdGhlciBjb21wYXJpbmcgbGVuZ3RocyBpbiBwcm9kIGJlY2F1c2UgdGhlc2UgYXJyYXlzIHNob3VsZCBiZVxuICAgIC8vIHBhc3NlZCBpbmxpbmUuXG4gICAgaWYgKG5leHREZXBzLmxlbmd0aCAhPT0gcHJldkRlcHMubGVuZ3RoKSB7XG4gICAgICBlcnJvcignVGhlIGZpbmFsIGFyZ3VtZW50IHBhc3NlZCB0byAlcyBjaGFuZ2VkIHNpemUgYmV0d2VlbiByZW5kZXJzLiBUaGUgJyArICdvcmRlciBhbmQgc2l6ZSBvZiB0aGlzIGFycmF5IG11c3QgcmVtYWluIGNvbnN0YW50LlxcblxcbicgKyAnUHJldmlvdXM6ICVzXFxuJyArICdJbmNvbWluZzogJXMnLCBjdXJyZW50SG9va05hbWVJbkRldiwgXCJbXCIgKyBwcmV2RGVwcy5qb2luKCcsICcpICsgXCJdXCIsIFwiW1wiICsgbmV4dERlcHMuam9pbignLCAnKSArIFwiXVwiKTtcbiAgICB9XG4gIH1cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHByZXZEZXBzLmxlbmd0aCAmJiBpIDwgbmV4dERlcHMubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAob2JqZWN0SXMobmV4dERlcHNbaV0sIHByZXZEZXBzW2ldKSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIHJlbmRlcldpdGhIb29rcyhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgQ29tcG9uZW50LCBwcm9wcywgc2Vjb25kQXJnLCBuZXh0UmVuZGVyTGFuZXMpIHtcbiAgcmVuZGVyTGFuZXMgPSBuZXh0UmVuZGVyTGFuZXM7XG4gIGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEgPSB3b3JrSW5Qcm9ncmVzcztcblxuICB7XG4gICAgaG9va1R5cGVzRGV2ID0gY3VycmVudCAhPT0gbnVsbCA/IGN1cnJlbnQuX2RlYnVnSG9va1R5cGVzIDogbnVsbDtcbiAgICBob29rVHlwZXNVcGRhdGVJbmRleERldiA9IC0xOyAvLyBVc2VkIGZvciBob3QgcmVsb2FkaW5nOlxuXG4gICAgaWdub3JlUHJldmlvdXNEZXBlbmRlbmNpZXMgPSBjdXJyZW50ICE9PSBudWxsICYmIGN1cnJlbnQudHlwZSAhPT0gd29ya0luUHJvZ3Jlc3MudHlwZTtcbiAgfVxuXG4gIHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSBudWxsO1xuICB3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZSA9IG51bGw7XG4gIHdvcmtJblByb2dyZXNzLmxhbmVzID0gTm9MYW5lczsgLy8gVGhlIGZvbGxvd2luZyBzaG91bGQgaGF2ZSBhbHJlYWR5IGJlZW4gcmVzZXRcbiAgLy8gY3VycmVudEhvb2sgPSBudWxsO1xuICAvLyB3b3JrSW5Qcm9ncmVzc0hvb2sgPSBudWxsO1xuICAvLyBkaWRTY2hlZHVsZVJlbmRlclBoYXNlVXBkYXRlID0gZmFsc2U7XG4gIC8vIFRPRE8gV2FybiBpZiBubyBob29rcyBhcmUgdXNlZCBhdCBhbGwgZHVyaW5nIG1vdW50LCB0aGVuIHNvbWUgYXJlIHVzZWQgZHVyaW5nIHVwZGF0ZS5cbiAgLy8gQ3VycmVudGx5IHdlIHdpbGwgaWRlbnRpZnkgdGhlIHVwZGF0ZSByZW5kZXIgYXMgYSBtb3VudCBiZWNhdXNlIG1lbW9pemVkU3RhdGUgPT09IG51bGwuXG4gIC8vIFRoaXMgaXMgdHJpY2t5IGJlY2F1c2UgaXQncyB2YWxpZCBmb3IgY2VydGFpbiB0eXBlcyBvZiBjb21wb25lbnRzIChlLmcuIFJlYWN0LmxhenkpXG4gIC8vIFVzaW5nIG1lbW9pemVkU3RhdGUgdG8gZGlmZmVyZW50aWF0ZSBiZXR3ZWVuIG1vdW50L3VwZGF0ZSBvbmx5IHdvcmtzIGlmIGF0IGxlYXN0IG9uZSBzdGF0ZWZ1bCBob29rIGlzIHVzZWQuXG4gIC8vIE5vbi1zdGF0ZWZ1bCBob29rcyAoZS5nLiBjb250ZXh0KSBkb24ndCBnZXQgYWRkZWQgdG8gbWVtb2l6ZWRTdGF0ZSxcbiAgLy8gc28gbWVtb2l6ZWRTdGF0ZSB3b3VsZCBiZSBudWxsIGR1cmluZyB1cGRhdGVzIGFuZCBtb3VudHMuXG5cbiAge1xuICAgIGlmIChjdXJyZW50ICE9PSBudWxsICYmIGN1cnJlbnQubWVtb2l6ZWRTdGF0ZSAhPT0gbnVsbCkge1xuICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQgPSBIb29rc0Rpc3BhdGNoZXJPblVwZGF0ZUluREVWO1xuICAgIH0gZWxzZSBpZiAoaG9va1R5cGVzRGV2ICE9PSBudWxsKSB7XG4gICAgICAvLyBUaGlzIGRpc3BhdGNoZXIgaGFuZGxlcyBhbiBlZGdlIGNhc2Ugd2hlcmUgYSBjb21wb25lbnQgaXMgdXBkYXRpbmcsXG4gICAgICAvLyBidXQgbm8gc3RhdGVmdWwgaG9va3MgaGF2ZSBiZWVuIHVzZWQuXG4gICAgICAvLyBXZSB3YW50IHRvIG1hdGNoIHRoZSBwcm9kdWN0aW9uIGNvZGUgYmVoYXZpb3IgKHdoaWNoIHdpbGwgdXNlIEhvb2tzRGlzcGF0Y2hlck9uTW91bnQpLFxuICAgICAgLy8gYnV0IHdpdGggdGhlIGV4dHJhIERFViB2YWxpZGF0aW9uIHRvIGVuc3VyZSBob29rcyBvcmRlcmluZyBoYXNuJ3QgY2hhbmdlZC5cbiAgICAgIC8vIFRoaXMgZGlzcGF0Y2hlciBkb2VzIHRoYXQuXG4gICAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudCA9IEhvb2tzRGlzcGF0Y2hlck9uTW91bnRXaXRoSG9va1R5cGVzSW5ERVY7XG4gICAgfSBlbHNlIHtcbiAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50ID0gSG9va3NEaXNwYXRjaGVyT25Nb3VudEluREVWO1xuICAgIH1cbiAgfVxuXG4gIHZhciBjaGlsZHJlbiA9IENvbXBvbmVudChwcm9wcywgc2Vjb25kQXJnKTsgLy8gQ2hlY2sgaWYgdGhlcmUgd2FzIGEgcmVuZGVyIHBoYXNlIHVwZGF0ZVxuXG4gIGlmIChkaWRTY2hlZHVsZVJlbmRlclBoYXNlVXBkYXRlRHVyaW5nVGhpc1Bhc3MpIHtcbiAgICAvLyBLZWVwIHJlbmRlcmluZyBpbiBhIGxvb3AgZm9yIGFzIGxvbmcgYXMgcmVuZGVyIHBoYXNlIHVwZGF0ZXMgY29udGludWUgdG9cbiAgICAvLyBiZSBzY2hlZHVsZWQuIFVzZSBhIGNvdW50ZXIgdG8gcHJldmVudCBpbmZpbml0ZSBsb29wcy5cbiAgICB2YXIgbnVtYmVyT2ZSZVJlbmRlcnMgPSAwO1xuXG4gICAgZG8ge1xuICAgICAgZGlkU2NoZWR1bGVSZW5kZXJQaGFzZVVwZGF0ZUR1cmluZ1RoaXNQYXNzID0gZmFsc2U7XG5cbiAgICAgIGlmICghKG51bWJlck9mUmVSZW5kZXJzIDwgUkVfUkVOREVSX0xJTUlUKSkge1xuICAgICAgICB7XG4gICAgICAgICAgdGhyb3cgRXJyb3IoIFwiVG9vIG1hbnkgcmUtcmVuZGVycy4gUmVhY3QgbGltaXRzIHRoZSBudW1iZXIgb2YgcmVuZGVycyB0byBwcmV2ZW50IGFuIGluZmluaXRlIGxvb3AuXCIgKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBudW1iZXJPZlJlUmVuZGVycyArPSAxO1xuXG4gICAgICB7XG4gICAgICAgIC8vIEV2ZW4gd2hlbiBob3QgcmVsb2FkaW5nLCBhbGxvdyBkZXBlbmRlbmNpZXMgdG8gc3RhYmlsaXplXG4gICAgICAgIC8vIGFmdGVyIGZpcnN0IHJlbmRlciB0byBwcmV2ZW50IGluZmluaXRlIHJlbmRlciBwaGFzZSB1cGRhdGVzLlxuICAgICAgICBpZ25vcmVQcmV2aW91c0RlcGVuZGVuY2llcyA9IGZhbHNlO1xuICAgICAgfSAvLyBTdGFydCBvdmVyIGZyb20gdGhlIGJlZ2lubmluZyBvZiB0aGUgbGlzdFxuXG5cbiAgICAgIGN1cnJlbnRIb29rID0gbnVsbDtcbiAgICAgIHdvcmtJblByb2dyZXNzSG9vayA9IG51bGw7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZSA9IG51bGw7XG5cbiAgICAgIHtcbiAgICAgICAgLy8gQWxzbyB2YWxpZGF0ZSBob29rIG9yZGVyIGZvciBjYXNjYWRpbmcgdXBkYXRlcy5cbiAgICAgICAgaG9va1R5cGVzVXBkYXRlSW5kZXhEZXYgPSAtMTtcbiAgICAgIH1cblxuICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQgPSAgSG9va3NEaXNwYXRjaGVyT25SZXJlbmRlckluREVWIDtcbiAgICAgIGNoaWxkcmVuID0gQ29tcG9uZW50KHByb3BzLCBzZWNvbmRBcmcpO1xuICAgIH0gd2hpbGUgKGRpZFNjaGVkdWxlUmVuZGVyUGhhc2VVcGRhdGVEdXJpbmdUaGlzUGFzcyk7XG4gIH0gLy8gV2UgY2FuIGFzc3VtZSB0aGUgcHJldmlvdXMgZGlzcGF0Y2hlciBpcyBhbHdheXMgdGhpcyBvbmUsIHNpbmNlIHdlIHNldCBpdFxuICAvLyBhdCB0aGUgYmVnaW5uaW5nIG9mIHRoZSByZW5kZXIgcGhhc2UgYW5kIHRoZXJlJ3Mgbm8gcmUtZW50cmFuY3kuXG5cblxuICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudCA9IENvbnRleHRPbmx5RGlzcGF0Y2hlcjtcblxuICB7XG4gICAgd29ya0luUHJvZ3Jlc3MuX2RlYnVnSG9va1R5cGVzID0gaG9va1R5cGVzRGV2O1xuICB9IC8vIFRoaXMgY2hlY2sgdXNlcyBjdXJyZW50SG9vayBzbyB0aGF0IGl0IHdvcmtzIHRoZSBzYW1lIGluIERFViBhbmQgcHJvZCBidW5kbGVzLlxuICAvLyBob29rVHlwZXNEZXYgY291bGQgY2F0Y2ggbW9yZSBjYXNlcyAoZS5nLiBjb250ZXh0KSBidXQgb25seSBpbiBERVYgYnVuZGxlcy5cblxuXG4gIHZhciBkaWRSZW5kZXJUb29GZXdIb29rcyA9IGN1cnJlbnRIb29rICE9PSBudWxsICYmIGN1cnJlbnRIb29rLm5leHQgIT09IG51bGw7XG4gIHJlbmRlckxhbmVzID0gTm9MYW5lcztcbiAgY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMSA9IG51bGw7XG4gIGN1cnJlbnRIb29rID0gbnVsbDtcbiAgd29ya0luUHJvZ3Jlc3NIb29rID0gbnVsbDtcblxuICB7XG4gICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBudWxsO1xuICAgIGhvb2tUeXBlc0RldiA9IG51bGw7XG4gICAgaG9va1R5cGVzVXBkYXRlSW5kZXhEZXYgPSAtMTtcbiAgfVxuXG4gIGRpZFNjaGVkdWxlUmVuZGVyUGhhc2VVcGRhdGUgPSBmYWxzZTtcblxuICBpZiAoISFkaWRSZW5kZXJUb29GZXdIb29rcykge1xuICAgIHtcbiAgICAgIHRocm93IEVycm9yKCBcIlJlbmRlcmVkIGZld2VyIGhvb2tzIHRoYW4gZXhwZWN0ZWQuIFRoaXMgbWF5IGJlIGNhdXNlZCBieSBhbiBhY2NpZGVudGFsIGVhcmx5IHJldHVybiBzdGF0ZW1lbnQuXCIgKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gY2hpbGRyZW47XG59XG5mdW5jdGlvbiBiYWlsb3V0SG9va3MoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIGxhbmVzKSB7XG4gIHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlID0gY3VycmVudC51cGRhdGVRdWV1ZTtcbiAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgJj0gfihQYXNzaXZlIHwgVXBkYXRlKTtcbiAgY3VycmVudC5sYW5lcyA9IHJlbW92ZUxhbmVzKGN1cnJlbnQubGFuZXMsIGxhbmVzKTtcbn1cbmZ1bmN0aW9uIHJlc2V0SG9va3NBZnRlclRocm93KCkge1xuICAvLyBXZSBjYW4gYXNzdW1lIHRoZSBwcmV2aW91cyBkaXNwYXRjaGVyIGlzIGFsd2F5cyB0aGlzIG9uZSwgc2luY2Ugd2Ugc2V0IGl0XG4gIC8vIGF0IHRoZSBiZWdpbm5pbmcgb2YgdGhlIHJlbmRlciBwaGFzZSBhbmQgdGhlcmUncyBubyByZS1lbnRyYW5jeS5cbiAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQgPSBDb250ZXh0T25seURpc3BhdGNoZXI7XG5cbiAgaWYgKGRpZFNjaGVkdWxlUmVuZGVyUGhhc2VVcGRhdGUpIHtcbiAgICAvLyBUaGVyZSB3ZXJlIHJlbmRlciBwaGFzZSB1cGRhdGVzLiBUaGVzZSBhcmUgb25seSB2YWxpZCBmb3IgdGhpcyByZW5kZXJcbiAgICAvLyBwaGFzZSwgd2hpY2ggd2UgYXJlIG5vdyBhYm9ydGluZy4gUmVtb3ZlIHRoZSB1cGRhdGVzIGZyb20gdGhlIHF1ZXVlcyBzb1xuICAgIC8vIHRoZXkgZG8gbm90IHBlcnNpc3QgdG8gdGhlIG5leHQgcmVuZGVyLiBEbyBub3QgcmVtb3ZlIHVwZGF0ZXMgZnJvbSBob29rc1xuICAgIC8vIHRoYXQgd2VyZW4ndCBwcm9jZXNzZWQuXG4gICAgLy9cbiAgICAvLyBPbmx5IHJlc2V0IHRoZSB1cGRhdGVzIGZyb20gdGhlIHF1ZXVlIGlmIGl0IGhhcyBhIGNsb25lLiBJZiBpdCBkb2VzXG4gICAgLy8gbm90IGhhdmUgYSBjbG9uZSwgdGhhdCBtZWFucyBpdCB3YXNuJ3QgcHJvY2Vzc2VkLCBhbmQgdGhlIHVwZGF0ZXMgd2VyZVxuICAgIC8vIHNjaGVkdWxlZCBiZWZvcmUgd2UgZW50ZXJlZCB0aGUgcmVuZGVyIHBoYXNlLlxuICAgIHZhciBob29rID0gY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMS5tZW1vaXplZFN0YXRlO1xuXG4gICAgd2hpbGUgKGhvb2sgIT09IG51bGwpIHtcbiAgICAgIHZhciBxdWV1ZSA9IGhvb2sucXVldWU7XG5cbiAgICAgIGlmIChxdWV1ZSAhPT0gbnVsbCkge1xuICAgICAgICBxdWV1ZS5wZW5kaW5nID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgaG9vayA9IGhvb2submV4dDtcbiAgICB9XG5cbiAgICBkaWRTY2hlZHVsZVJlbmRlclBoYXNlVXBkYXRlID0gZmFsc2U7XG4gIH1cblxuICByZW5kZXJMYW5lcyA9IE5vTGFuZXM7XG4gIGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEgPSBudWxsO1xuICBjdXJyZW50SG9vayA9IG51bGw7XG4gIHdvcmtJblByb2dyZXNzSG9vayA9IG51bGw7XG5cbiAge1xuICAgIGhvb2tUeXBlc0RldiA9IG51bGw7XG4gICAgaG9va1R5cGVzVXBkYXRlSW5kZXhEZXYgPSAtMTtcbiAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IG51bGw7XG4gICAgaXNVcGRhdGluZ09wYXF1ZVZhbHVlSW5SZW5kZXJQaGFzZSA9IGZhbHNlO1xuICB9XG5cbiAgZGlkU2NoZWR1bGVSZW5kZXJQaGFzZVVwZGF0ZUR1cmluZ1RoaXNQYXNzID0gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIG1vdW50V29ya0luUHJvZ3Jlc3NIb29rKCkge1xuICB2YXIgaG9vayA9IHtcbiAgICBtZW1vaXplZFN0YXRlOiBudWxsLFxuICAgIGJhc2VTdGF0ZTogbnVsbCxcbiAgICBiYXNlUXVldWU6IG51bGwsXG4gICAgcXVldWU6IG51bGwsXG4gICAgbmV4dDogbnVsbFxuICB9O1xuXG4gIGlmICh3b3JrSW5Qcm9ncmVzc0hvb2sgPT09IG51bGwpIHtcbiAgICAvLyBUaGlzIGlzIHRoZSBmaXJzdCBob29rIGluIHRoZSBsaXN0XG4gICAgY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMS5tZW1vaXplZFN0YXRlID0gd29ya0luUHJvZ3Jlc3NIb29rID0gaG9vaztcbiAgfSBlbHNlIHtcbiAgICAvLyBBcHBlbmQgdG8gdGhlIGVuZCBvZiB0aGUgbGlzdFxuICAgIHdvcmtJblByb2dyZXNzSG9vayA9IHdvcmtJblByb2dyZXNzSG9vay5uZXh0ID0gaG9vaztcbiAgfVxuXG4gIHJldHVybiB3b3JrSW5Qcm9ncmVzc0hvb2s7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZVdvcmtJblByb2dyZXNzSG9vaygpIHtcbiAgLy8gVGhpcyBmdW5jdGlvbiBpcyB1c2VkIGJvdGggZm9yIHVwZGF0ZXMgYW5kIGZvciByZS1yZW5kZXJzIHRyaWdnZXJlZCBieSBhXG4gIC8vIHJlbmRlciBwaGFzZSB1cGRhdGUuIEl0IGFzc3VtZXMgdGhlcmUgaXMgZWl0aGVyIGEgY3VycmVudCBob29rIHdlIGNhblxuICAvLyBjbG9uZSwgb3IgYSB3b3JrLWluLXByb2dyZXNzIGhvb2sgZnJvbSBhIHByZXZpb3VzIHJlbmRlciBwYXNzIHRoYXQgd2UgY2FuXG4gIC8vIHVzZSBhcyBhIGJhc2UuIFdoZW4gd2UgcmVhY2ggdGhlIGVuZCBvZiB0aGUgYmFzZSBsaXN0LCB3ZSBtdXN0IHN3aXRjaCB0b1xuICAvLyB0aGUgZGlzcGF0Y2hlciB1c2VkIGZvciBtb3VudHMuXG4gIHZhciBuZXh0Q3VycmVudEhvb2s7XG5cbiAgaWYgKGN1cnJlbnRIb29rID09PSBudWxsKSB7XG4gICAgdmFyIGN1cnJlbnQgPSBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxLmFsdGVybmF0ZTtcblxuICAgIGlmIChjdXJyZW50ICE9PSBudWxsKSB7XG4gICAgICBuZXh0Q3VycmVudEhvb2sgPSBjdXJyZW50Lm1lbW9pemVkU3RhdGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5leHRDdXJyZW50SG9vayA9IG51bGw7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIG5leHRDdXJyZW50SG9vayA9IGN1cnJlbnRIb29rLm5leHQ7XG4gIH1cblxuICB2YXIgbmV4dFdvcmtJblByb2dyZXNzSG9vaztcblxuICBpZiAod29ya0luUHJvZ3Jlc3NIb29rID09PSBudWxsKSB7XG4gICAgbmV4dFdvcmtJblByb2dyZXNzSG9vayA9IGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEubWVtb2l6ZWRTdGF0ZTtcbiAgfSBlbHNlIHtcbiAgICBuZXh0V29ya0luUHJvZ3Jlc3NIb29rID0gd29ya0luUHJvZ3Jlc3NIb29rLm5leHQ7XG4gIH1cblxuICBpZiAobmV4dFdvcmtJblByb2dyZXNzSG9vayAhPT0gbnVsbCkge1xuICAgIC8vIFRoZXJlJ3MgYWxyZWFkeSBhIHdvcmstaW4tcHJvZ3Jlc3MuIFJldXNlIGl0LlxuICAgIHdvcmtJblByb2dyZXNzSG9vayA9IG5leHRXb3JrSW5Qcm9ncmVzc0hvb2s7XG4gICAgbmV4dFdvcmtJblByb2dyZXNzSG9vayA9IHdvcmtJblByb2dyZXNzSG9vay5uZXh0O1xuICAgIGN1cnJlbnRIb29rID0gbmV4dEN1cnJlbnRIb29rO1xuICB9IGVsc2Uge1xuICAgIC8vIENsb25lIGZyb20gdGhlIGN1cnJlbnQgaG9vay5cbiAgICBpZiAoIShuZXh0Q3VycmVudEhvb2sgIT09IG51bGwpKSB7XG4gICAgICB7XG4gICAgICAgIHRocm93IEVycm9yKCBcIlJlbmRlcmVkIG1vcmUgaG9va3MgdGhhbiBkdXJpbmcgdGhlIHByZXZpb3VzIHJlbmRlci5cIiApO1xuICAgICAgfVxuICAgIH1cblxuICAgIGN1cnJlbnRIb29rID0gbmV4dEN1cnJlbnRIb29rO1xuICAgIHZhciBuZXdIb29rID0ge1xuICAgICAgbWVtb2l6ZWRTdGF0ZTogY3VycmVudEhvb2subWVtb2l6ZWRTdGF0ZSxcbiAgICAgIGJhc2VTdGF0ZTogY3VycmVudEhvb2suYmFzZVN0YXRlLFxuICAgICAgYmFzZVF1ZXVlOiBjdXJyZW50SG9vay5iYXNlUXVldWUsXG4gICAgICBxdWV1ZTogY3VycmVudEhvb2sucXVldWUsXG4gICAgICBuZXh0OiBudWxsXG4gICAgfTtcblxuICAgIGlmICh3b3JrSW5Qcm9ncmVzc0hvb2sgPT09IG51bGwpIHtcbiAgICAgIC8vIFRoaXMgaXMgdGhlIGZpcnN0IGhvb2sgaW4gdGhlIGxpc3QuXG4gICAgICBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxLm1lbW9pemVkU3RhdGUgPSB3b3JrSW5Qcm9ncmVzc0hvb2sgPSBuZXdIb29rO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBBcHBlbmQgdG8gdGhlIGVuZCBvZiB0aGUgbGlzdC5cbiAgICAgIHdvcmtJblByb2dyZXNzSG9vayA9IHdvcmtJblByb2dyZXNzSG9vay5uZXh0ID0gbmV3SG9vaztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gd29ya0luUHJvZ3Jlc3NIb29rO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVGdW5jdGlvbkNvbXBvbmVudFVwZGF0ZVF1ZXVlKCkge1xuICByZXR1cm4ge1xuICAgIGxhc3RFZmZlY3Q6IG51bGxcbiAgfTtcbn1cblxuZnVuY3Rpb24gYmFzaWNTdGF0ZVJlZHVjZXIoc3RhdGUsIGFjdGlvbikge1xuICAvLyAkRmxvd0ZpeE1lOiBGbG93IGRvZXNuJ3QgbGlrZSBtaXhlZCB0eXBlc1xuICByZXR1cm4gdHlwZW9mIGFjdGlvbiA9PT0gJ2Z1bmN0aW9uJyA/IGFjdGlvbihzdGF0ZSkgOiBhY3Rpb247XG59XG5cbmZ1bmN0aW9uIG1vdW50UmVkdWNlcihyZWR1Y2VyLCBpbml0aWFsQXJnLCBpbml0KSB7XG4gIHZhciBob29rID0gbW91bnRXb3JrSW5Qcm9ncmVzc0hvb2soKTtcbiAgdmFyIGluaXRpYWxTdGF0ZTtcblxuICBpZiAoaW5pdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgaW5pdGlhbFN0YXRlID0gaW5pdChpbml0aWFsQXJnKTtcbiAgfSBlbHNlIHtcbiAgICBpbml0aWFsU3RhdGUgPSBpbml0aWFsQXJnO1xuICB9XG5cbiAgaG9vay5tZW1vaXplZFN0YXRlID0gaG9vay5iYXNlU3RhdGUgPSBpbml0aWFsU3RhdGU7XG4gIHZhciBxdWV1ZSA9IGhvb2sucXVldWUgPSB7XG4gICAgcGVuZGluZzogbnVsbCxcbiAgICBkaXNwYXRjaDogbnVsbCxcbiAgICBsYXN0UmVuZGVyZWRSZWR1Y2VyOiByZWR1Y2VyLFxuICAgIGxhc3RSZW5kZXJlZFN0YXRlOiBpbml0aWFsU3RhdGVcbiAgfTtcbiAgdmFyIGRpc3BhdGNoID0gcXVldWUuZGlzcGF0Y2ggPSBkaXNwYXRjaEFjdGlvbi5iaW5kKG51bGwsIGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEsIHF1ZXVlKTtcbiAgcmV0dXJuIFtob29rLm1lbW9pemVkU3RhdGUsIGRpc3BhdGNoXTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlUmVkdWNlcihyZWR1Y2VyLCBpbml0aWFsQXJnLCBpbml0KSB7XG4gIHZhciBob29rID0gdXBkYXRlV29ya0luUHJvZ3Jlc3NIb29rKCk7XG4gIHZhciBxdWV1ZSA9IGhvb2sucXVldWU7XG5cbiAgaWYgKCEocXVldWUgIT09IG51bGwpKSB7XG4gICAge1xuICAgICAgdGhyb3cgRXJyb3IoIFwiU2hvdWxkIGhhdmUgYSBxdWV1ZS4gVGhpcyBpcyBsaWtlbHkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiICk7XG4gICAgfVxuICB9XG5cbiAgcXVldWUubGFzdFJlbmRlcmVkUmVkdWNlciA9IHJlZHVjZXI7XG4gIHZhciBjdXJyZW50ID0gY3VycmVudEhvb2s7IC8vIFRoZSBsYXN0IHJlYmFzZSB1cGRhdGUgdGhhdCBpcyBOT1QgcGFydCBvZiB0aGUgYmFzZSBzdGF0ZS5cblxuICB2YXIgYmFzZVF1ZXVlID0gY3VycmVudC5iYXNlUXVldWU7IC8vIFRoZSBsYXN0IHBlbmRpbmcgdXBkYXRlIHRoYXQgaGFzbid0IGJlZW4gcHJvY2Vzc2VkIHlldC5cblxuICB2YXIgcGVuZGluZ1F1ZXVlID0gcXVldWUucGVuZGluZztcblxuICBpZiAocGVuZGluZ1F1ZXVlICE9PSBudWxsKSB7XG4gICAgLy8gV2UgaGF2ZSBuZXcgdXBkYXRlcyB0aGF0IGhhdmVuJ3QgYmVlbiBwcm9jZXNzZWQgeWV0LlxuICAgIC8vIFdlJ2xsIGFkZCB0aGVtIHRvIHRoZSBiYXNlIHF1ZXVlLlxuICAgIGlmIChiYXNlUXVldWUgIT09IG51bGwpIHtcbiAgICAgIC8vIE1lcmdlIHRoZSBwZW5kaW5nIHF1ZXVlIGFuZCB0aGUgYmFzZSBxdWV1ZS5cbiAgICAgIHZhciBiYXNlRmlyc3QgPSBiYXNlUXVldWUubmV4dDtcbiAgICAgIHZhciBwZW5kaW5nRmlyc3QgPSBwZW5kaW5nUXVldWUubmV4dDtcbiAgICAgIGJhc2VRdWV1ZS5uZXh0ID0gcGVuZGluZ0ZpcnN0O1xuICAgICAgcGVuZGluZ1F1ZXVlLm5leHQgPSBiYXNlRmlyc3Q7XG4gICAgfVxuXG4gICAge1xuICAgICAgaWYgKGN1cnJlbnQuYmFzZVF1ZXVlICE9PSBiYXNlUXVldWUpIHtcbiAgICAgICAgLy8gSW50ZXJuYWwgaW52YXJpYW50IHRoYXQgc2hvdWxkIG5ldmVyIGhhcHBlbiwgYnV0IGZlYXNpYmx5IGNvdWxkIGluXG4gICAgICAgIC8vIHRoZSBmdXR1cmUgaWYgd2UgaW1wbGVtZW50IHJlc3VtaW5nLCBvciBzb21lIGZvcm0gb2YgdGhhdC5cbiAgICAgICAgZXJyb3IoJ0ludGVybmFsIGVycm9yOiBFeHBlY3RlZCB3b3JrLWluLXByb2dyZXNzIHF1ZXVlIHRvIGJlIGEgY2xvbmUuICcgKyAnVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC4nKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjdXJyZW50LmJhc2VRdWV1ZSA9IGJhc2VRdWV1ZSA9IHBlbmRpbmdRdWV1ZTtcbiAgICBxdWV1ZS5wZW5kaW5nID0gbnVsbDtcbiAgfVxuXG4gIGlmIChiYXNlUXVldWUgIT09IG51bGwpIHtcbiAgICAvLyBXZSBoYXZlIGEgcXVldWUgdG8gcHJvY2Vzcy5cbiAgICB2YXIgZmlyc3QgPSBiYXNlUXVldWUubmV4dDtcbiAgICB2YXIgbmV3U3RhdGUgPSBjdXJyZW50LmJhc2VTdGF0ZTtcbiAgICB2YXIgbmV3QmFzZVN0YXRlID0gbnVsbDtcbiAgICB2YXIgbmV3QmFzZVF1ZXVlRmlyc3QgPSBudWxsO1xuICAgIHZhciBuZXdCYXNlUXVldWVMYXN0ID0gbnVsbDtcbiAgICB2YXIgdXBkYXRlID0gZmlyc3Q7XG5cbiAgICBkbyB7XG4gICAgICB2YXIgdXBkYXRlTGFuZSA9IHVwZGF0ZS5sYW5lO1xuXG4gICAgICBpZiAoIWlzU3Vic2V0T2ZMYW5lcyhyZW5kZXJMYW5lcywgdXBkYXRlTGFuZSkpIHtcbiAgICAgICAgLy8gUHJpb3JpdHkgaXMgaW5zdWZmaWNpZW50LiBTa2lwIHRoaXMgdXBkYXRlLiBJZiB0aGlzIGlzIHRoZSBmaXJzdFxuICAgICAgICAvLyBza2lwcGVkIHVwZGF0ZSwgdGhlIHByZXZpb3VzIHVwZGF0ZS9zdGF0ZSBpcyB0aGUgbmV3IGJhc2VcbiAgICAgICAgLy8gdXBkYXRlL3N0YXRlLlxuICAgICAgICB2YXIgY2xvbmUgPSB7XG4gICAgICAgICAgbGFuZTogdXBkYXRlTGFuZSxcbiAgICAgICAgICBhY3Rpb246IHVwZGF0ZS5hY3Rpb24sXG4gICAgICAgICAgZWFnZXJSZWR1Y2VyOiB1cGRhdGUuZWFnZXJSZWR1Y2VyLFxuICAgICAgICAgIGVhZ2VyU3RhdGU6IHVwZGF0ZS5lYWdlclN0YXRlLFxuICAgICAgICAgIG5leHQ6IG51bGxcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAobmV3QmFzZVF1ZXVlTGFzdCA9PT0gbnVsbCkge1xuICAgICAgICAgIG5ld0Jhc2VRdWV1ZUZpcnN0ID0gbmV3QmFzZVF1ZXVlTGFzdCA9IGNsb25lO1xuICAgICAgICAgIG5ld0Jhc2VTdGF0ZSA9IG5ld1N0YXRlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5ld0Jhc2VRdWV1ZUxhc3QgPSBuZXdCYXNlUXVldWVMYXN0Lm5leHQgPSBjbG9uZTtcbiAgICAgICAgfSAvLyBVcGRhdGUgdGhlIHJlbWFpbmluZyBwcmlvcml0eSBpbiB0aGUgcXVldWUuXG4gICAgICAgIC8vIFRPRE86IERvbid0IG5lZWQgdG8gYWNjdW11bGF0ZSB0aGlzLiBJbnN0ZWFkLCB3ZSBjYW4gcmVtb3ZlXG4gICAgICAgIC8vIHJlbmRlckxhbmVzIGZyb20gdGhlIG9yaWdpbmFsIGxhbmVzLlxuXG5cbiAgICAgICAgY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMS5sYW5lcyA9IG1lcmdlTGFuZXMoY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMS5sYW5lcywgdXBkYXRlTGFuZSk7XG4gICAgICAgIG1hcmtTa2lwcGVkVXBkYXRlTGFuZXModXBkYXRlTGFuZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBUaGlzIHVwZGF0ZSBkb2VzIGhhdmUgc3VmZmljaWVudCBwcmlvcml0eS5cbiAgICAgICAgaWYgKG5ld0Jhc2VRdWV1ZUxhc3QgIT09IG51bGwpIHtcbiAgICAgICAgICB2YXIgX2Nsb25lID0ge1xuICAgICAgICAgICAgLy8gVGhpcyB1cGRhdGUgaXMgZ29pbmcgdG8gYmUgY29tbWl0dGVkIHNvIHdlIG5ldmVyIHdhbnQgdW5jb21taXRcbiAgICAgICAgICAgIC8vIGl0LiBVc2luZyBOb0xhbmUgd29ya3MgYmVjYXVzZSAwIGlzIGEgc3Vic2V0IG9mIGFsbCBiaXRtYXNrcywgc29cbiAgICAgICAgICAgIC8vIHRoaXMgd2lsbCBuZXZlciBiZSBza2lwcGVkIGJ5IHRoZSBjaGVjayBhYm92ZS5cbiAgICAgICAgICAgIGxhbmU6IE5vTGFuZSxcbiAgICAgICAgICAgIGFjdGlvbjogdXBkYXRlLmFjdGlvbixcbiAgICAgICAgICAgIGVhZ2VyUmVkdWNlcjogdXBkYXRlLmVhZ2VyUmVkdWNlcixcbiAgICAgICAgICAgIGVhZ2VyU3RhdGU6IHVwZGF0ZS5lYWdlclN0YXRlLFxuICAgICAgICAgICAgbmV4dDogbnVsbFxuICAgICAgICAgIH07XG4gICAgICAgICAgbmV3QmFzZVF1ZXVlTGFzdCA9IG5ld0Jhc2VRdWV1ZUxhc3QubmV4dCA9IF9jbG9uZTtcbiAgICAgICAgfSAvLyBQcm9jZXNzIHRoaXMgdXBkYXRlLlxuXG5cbiAgICAgICAgaWYgKHVwZGF0ZS5lYWdlclJlZHVjZXIgPT09IHJlZHVjZXIpIHtcbiAgICAgICAgICAvLyBJZiB0aGlzIHVwZGF0ZSB3YXMgcHJvY2Vzc2VkIGVhZ2VybHksIGFuZCBpdHMgcmVkdWNlciBtYXRjaGVzIHRoZVxuICAgICAgICAgIC8vIGN1cnJlbnQgcmVkdWNlciwgd2UgY2FuIHVzZSB0aGUgZWFnZXJseSBjb21wdXRlZCBzdGF0ZS5cbiAgICAgICAgICBuZXdTdGF0ZSA9IHVwZGF0ZS5lYWdlclN0YXRlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBhY3Rpb24gPSB1cGRhdGUuYWN0aW9uO1xuICAgICAgICAgIG5ld1N0YXRlID0gcmVkdWNlcihuZXdTdGF0ZSwgYWN0aW9uKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB1cGRhdGUgPSB1cGRhdGUubmV4dDtcbiAgICB9IHdoaWxlICh1cGRhdGUgIT09IG51bGwgJiYgdXBkYXRlICE9PSBmaXJzdCk7XG5cbiAgICBpZiAobmV3QmFzZVF1ZXVlTGFzdCA9PT0gbnVsbCkge1xuICAgICAgbmV3QmFzZVN0YXRlID0gbmV3U3RhdGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5ld0Jhc2VRdWV1ZUxhc3QubmV4dCA9IG5ld0Jhc2VRdWV1ZUZpcnN0O1xuICAgIH0gLy8gTWFyayB0aGF0IHRoZSBmaWJlciBwZXJmb3JtZWQgd29yaywgYnV0IG9ubHkgaWYgdGhlIG5ldyBzdGF0ZSBpc1xuICAgIC8vIGRpZmZlcmVudCBmcm9tIHRoZSBjdXJyZW50IHN0YXRlLlxuXG5cbiAgICBpZiAoIW9iamVjdElzKG5ld1N0YXRlLCBob29rLm1lbW9pemVkU3RhdGUpKSB7XG4gICAgICBtYXJrV29ya0luUHJvZ3Jlc3NSZWNlaXZlZFVwZGF0ZSgpO1xuICAgIH1cblxuICAgIGhvb2subWVtb2l6ZWRTdGF0ZSA9IG5ld1N0YXRlO1xuICAgIGhvb2suYmFzZVN0YXRlID0gbmV3QmFzZVN0YXRlO1xuICAgIGhvb2suYmFzZVF1ZXVlID0gbmV3QmFzZVF1ZXVlTGFzdDtcbiAgICBxdWV1ZS5sYXN0UmVuZGVyZWRTdGF0ZSA9IG5ld1N0YXRlO1xuICB9XG5cbiAgdmFyIGRpc3BhdGNoID0gcXVldWUuZGlzcGF0Y2g7XG4gIHJldHVybiBbaG9vay5tZW1vaXplZFN0YXRlLCBkaXNwYXRjaF07XG59XG5cbmZ1bmN0aW9uIHJlcmVuZGVyUmVkdWNlcihyZWR1Y2VyLCBpbml0aWFsQXJnLCBpbml0KSB7XG4gIHZhciBob29rID0gdXBkYXRlV29ya0luUHJvZ3Jlc3NIb29rKCk7XG4gIHZhciBxdWV1ZSA9IGhvb2sucXVldWU7XG5cbiAgaWYgKCEocXVldWUgIT09IG51bGwpKSB7XG4gICAge1xuICAgICAgdGhyb3cgRXJyb3IoIFwiU2hvdWxkIGhhdmUgYSBxdWV1ZS4gVGhpcyBpcyBsaWtlbHkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiICk7XG4gICAgfVxuICB9XG5cbiAgcXVldWUubGFzdFJlbmRlcmVkUmVkdWNlciA9IHJlZHVjZXI7IC8vIFRoaXMgaXMgYSByZS1yZW5kZXIuIEFwcGx5IHRoZSBuZXcgcmVuZGVyIHBoYXNlIHVwZGF0ZXMgdG8gdGhlIHByZXZpb3VzXG4gIC8vIHdvcmstaW4tcHJvZ3Jlc3MgaG9vay5cblxuICB2YXIgZGlzcGF0Y2ggPSBxdWV1ZS5kaXNwYXRjaDtcbiAgdmFyIGxhc3RSZW5kZXJQaGFzZVVwZGF0ZSA9IHF1ZXVlLnBlbmRpbmc7XG4gIHZhciBuZXdTdGF0ZSA9IGhvb2subWVtb2l6ZWRTdGF0ZTtcblxuICBpZiAobGFzdFJlbmRlclBoYXNlVXBkYXRlICE9PSBudWxsKSB7XG4gICAgLy8gVGhlIHF1ZXVlIGRvZXNuJ3QgcGVyc2lzdCBwYXN0IHRoaXMgcmVuZGVyIHBhc3MuXG4gICAgcXVldWUucGVuZGluZyA9IG51bGw7XG4gICAgdmFyIGZpcnN0UmVuZGVyUGhhc2VVcGRhdGUgPSBsYXN0UmVuZGVyUGhhc2VVcGRhdGUubmV4dDtcbiAgICB2YXIgdXBkYXRlID0gZmlyc3RSZW5kZXJQaGFzZVVwZGF0ZTtcblxuICAgIGRvIHtcbiAgICAgIC8vIFByb2Nlc3MgdGhpcyByZW5kZXIgcGhhc2UgdXBkYXRlLiBXZSBkb24ndCBoYXZlIHRvIGNoZWNrIHRoZVxuICAgICAgLy8gcHJpb3JpdHkgYmVjYXVzZSBpdCB3aWxsIGFsd2F5cyBiZSB0aGUgc2FtZSBhcyB0aGUgY3VycmVudFxuICAgICAgLy8gcmVuZGVyJ3MuXG4gICAgICB2YXIgYWN0aW9uID0gdXBkYXRlLmFjdGlvbjtcbiAgICAgIG5ld1N0YXRlID0gcmVkdWNlcihuZXdTdGF0ZSwgYWN0aW9uKTtcbiAgICAgIHVwZGF0ZSA9IHVwZGF0ZS5uZXh0O1xuICAgIH0gd2hpbGUgKHVwZGF0ZSAhPT0gZmlyc3RSZW5kZXJQaGFzZVVwZGF0ZSk7IC8vIE1hcmsgdGhhdCB0aGUgZmliZXIgcGVyZm9ybWVkIHdvcmssIGJ1dCBvbmx5IGlmIHRoZSBuZXcgc3RhdGUgaXNcbiAgICAvLyBkaWZmZXJlbnQgZnJvbSB0aGUgY3VycmVudCBzdGF0ZS5cblxuXG4gICAgaWYgKCFvYmplY3RJcyhuZXdTdGF0ZSwgaG9vay5tZW1vaXplZFN0YXRlKSkge1xuICAgICAgbWFya1dvcmtJblByb2dyZXNzUmVjZWl2ZWRVcGRhdGUoKTtcbiAgICB9XG5cbiAgICBob29rLm1lbW9pemVkU3RhdGUgPSBuZXdTdGF0ZTsgLy8gRG9uJ3QgcGVyc2lzdCB0aGUgc3RhdGUgYWNjdW11bGF0ZWQgZnJvbSB0aGUgcmVuZGVyIHBoYXNlIHVwZGF0ZXMgdG9cbiAgICAvLyB0aGUgYmFzZSBzdGF0ZSB1bmxlc3MgdGhlIHF1ZXVlIGlzIGVtcHR5LlxuICAgIC8vIFRPRE86IE5vdCBzdXJlIGlmIHRoaXMgaXMgdGhlIGRlc2lyZWQgc2VtYW50aWNzLCBidXQgaXQncyB3aGF0IHdlXG4gICAgLy8gZG8gZm9yIGdEU0ZQLiBJIGNhbid0IHJlbWVtYmVyIHdoeS5cblxuICAgIGlmIChob29rLmJhc2VRdWV1ZSA9PT0gbnVsbCkge1xuICAgICAgaG9vay5iYXNlU3RhdGUgPSBuZXdTdGF0ZTtcbiAgICB9XG5cbiAgICBxdWV1ZS5sYXN0UmVuZGVyZWRTdGF0ZSA9IG5ld1N0YXRlO1xuICB9XG5cbiAgcmV0dXJuIFtuZXdTdGF0ZSwgZGlzcGF0Y2hdO1xufVxuXG5mdW5jdGlvbiByZWFkRnJvbVVuc3ViY3JpYmVkTXV0YWJsZVNvdXJjZShyb290LCBzb3VyY2UsIGdldFNuYXBzaG90KSB7XG4gIHtcbiAgICB3YXJuQWJvdXRNdWx0aXBsZVJlbmRlcmVyc0RFVihzb3VyY2UpO1xuICB9XG5cbiAgdmFyIGdldFZlcnNpb24gPSBzb3VyY2UuX2dldFZlcnNpb247XG4gIHZhciB2ZXJzaW9uID0gZ2V0VmVyc2lvbihzb3VyY2UuX3NvdXJjZSk7IC8vIElzIGl0IHNhZmUgZm9yIHRoaXMgY29tcG9uZW50IHRvIHJlYWQgZnJvbSB0aGlzIHNvdXJjZSBkdXJpbmcgdGhlIGN1cnJlbnQgcmVuZGVyP1xuXG4gIHZhciBpc1NhZmVUb1JlYWRGcm9tU291cmNlID0gZmFsc2U7IC8vIENoZWNrIHRoZSB2ZXJzaW9uIGZpcnN0LlxuICAvLyBJZiB0aGlzIHJlbmRlciBoYXMgYWxyZWFkeSBiZWVuIHN0YXJ0ZWQgd2l0aCBhIHNwZWNpZmljIHZlcnNpb24sXG4gIC8vIHdlIGNhbiB1c2UgaXQgYWxvbmUgdG8gZGV0ZXJtaW5lIGlmIHdlIGNhbiBzYWZlbHkgcmVhZCBmcm9tIHRoZSBzb3VyY2UuXG5cbiAgdmFyIGN1cnJlbnRSZW5kZXJWZXJzaW9uID0gZ2V0V29ya0luUHJvZ3Jlc3NWZXJzaW9uKHNvdXJjZSk7XG5cbiAgaWYgKGN1cnJlbnRSZW5kZXJWZXJzaW9uICE9PSBudWxsKSB7XG4gICAgLy8gSXQncyBzYWZlIHRvIHJlYWQgaWYgdGhlIHN0b3JlIGhhc24ndCBiZWVuIG11dGF0ZWQgc2luY2UgdGhlIGxhc3QgdGltZVxuICAgIC8vIHdlIHJlYWQgc29tZXRoaW5nLlxuICAgIGlzU2FmZVRvUmVhZEZyb21Tb3VyY2UgPSBjdXJyZW50UmVuZGVyVmVyc2lvbiA9PT0gdmVyc2lvbjtcbiAgfSBlbHNlIHtcbiAgICAvLyBJZiB0aGVyZSdzIG5vIHZlcnNpb24sIHRoZW4gdGhpcyBpcyB0aGUgZmlyc3QgdGltZSB3ZSd2ZSByZWFkIGZyb20gdGhlXG4gICAgLy8gc291cmNlIGR1cmluZyB0aGUgY3VycmVudCByZW5kZXIgcGFzcywgc28gd2UgbmVlZCB0byBkbyBhIGJpdCBtb3JlIHdvcmsuXG4gICAgLy8gV2hhdCB3ZSBuZWVkIHRvIGRldGVybWluZSBpcyBpZiB0aGVyZSBhcmUgYW55IGhvb2tzIHRoYXQgYWxyZWFkeVxuICAgIC8vIHN1YnNjcmliZWQgdG8gdGhlIHNvdXJjZSwgYW5kIGlmIHNvLCB3aGV0aGVyIHRoZXJlIGFyZSBhbnkgcGVuZGluZ1xuICAgIC8vIG11dGF0aW9ucyB0aGF0IGhhdmVuJ3QgYmVlbiBzeW5jaHJvbml6ZWQgeWV0LlxuICAgIC8vXG4gICAgLy8gSWYgdGhlcmUgYXJlIG5vIHBlbmRpbmcgbXV0YXRpb25zLCB0aGVuIGByb290Lm11dGFibGVSZWFkTGFuZXNgIHdpbGwgYmVcbiAgICAvLyBlbXB0eSwgYW5kIHdlIGtub3cgd2UgY2FuIHNhZmVseSByZWFkLlxuICAgIC8vXG4gICAgLy8gSWYgdGhlcmUgKmFyZSogcGVuZGluZyBtdXRhdGlvbnMsIHdlIG1heSBzdGlsbCBiZSBhYmxlIHRvIHNhZmVseSByZWFkXG4gICAgLy8gaWYgdGhlIGN1cnJlbnRseSByZW5kZXJpbmcgbGFuZXMgYXJlIGluY2x1c2l2ZSBvZiB0aGUgcGVuZGluZyBtdXRhdGlvblxuICAgIC8vIGxhbmVzLCBzaW5jZSB0aGF0IGd1YXJhbnRlZXMgdGhhdCB0aGUgdmFsdWUgd2UncmUgYWJvdXQgdG8gcmVhZCBmcm9tXG4gICAgLy8gdGhlIHNvdXJjZSBpcyBjb25zaXN0ZW50IHdpdGggdGhlIHZhbHVlcyB0aGF0IHdlIHJlYWQgZHVyaW5nIHRoZSBtb3N0XG4gICAgLy8gcmVjZW50IG11dGF0aW9uLlxuICAgIGlzU2FmZVRvUmVhZEZyb21Tb3VyY2UgPSBpc1N1YnNldE9mTGFuZXMocmVuZGVyTGFuZXMsIHJvb3QubXV0YWJsZVJlYWRMYW5lcyk7XG5cbiAgICBpZiAoaXNTYWZlVG9SZWFkRnJvbVNvdXJjZSkge1xuICAgICAgLy8gSWYgaXQncyBzYWZlIHRvIHJlYWQgZnJvbSB0aGlzIHNvdXJjZSBkdXJpbmcgdGhlIGN1cnJlbnQgcmVuZGVyLFxuICAgICAgLy8gc3RvcmUgdGhlIHZlcnNpb24gaW4gY2FzZSBvdGhlciBjb21wb25lbnRzIHJlYWQgZnJvbSBpdC5cbiAgICAgIC8vIEEgY2hhbmdlZCB2ZXJzaW9uIG51bWJlciB3aWxsIGxldCB0aG9zZSBjb21wb25lbnRzIGtub3cgdG8gdGhyb3cgYW5kIHJlc3RhcnQgdGhlIHJlbmRlci5cbiAgICAgIHNldFdvcmtJblByb2dyZXNzVmVyc2lvbihzb3VyY2UsIHZlcnNpb24pO1xuICAgIH1cbiAgfVxuXG4gIGlmIChpc1NhZmVUb1JlYWRGcm9tU291cmNlKSB7XG4gICAgdmFyIHNuYXBzaG90ID0gZ2V0U25hcHNob3Qoc291cmNlLl9zb3VyY2UpO1xuXG4gICAge1xuICAgICAgaWYgKHR5cGVvZiBzbmFwc2hvdCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBlcnJvcignTXV0YWJsZSBzb3VyY2Ugc2hvdWxkIG5vdCByZXR1cm4gYSBmdW5jdGlvbiBhcyB0aGUgc25hcHNob3QgdmFsdWUuICcgKyAnRnVuY3Rpb25zIG1heSBjbG9zZSBvdmVyIG11dGFibGUgdmFsdWVzIGFuZCBjYXVzZSB0ZWFyaW5nLicpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBzbmFwc2hvdDtcbiAgfSBlbHNlIHtcbiAgICAvLyBUaGlzIGhhbmRsZXMgdGhlIHNwZWNpYWwgY2FzZSBvZiBhIG11dGFibGUgc291cmNlIGJlaW5nIHNoYXJlZCBiZXR3ZWVuIHJlbmRlcmVycy5cbiAgICAvLyBJbiB0aGF0IGNhc2UsIGlmIHRoZSBzb3VyY2UgaXMgbXV0YXRlZCBiZXR3ZWVuIHRoZSBmaXJzdCBhbmQgc2Vjb25kIHJlbmRlcmVyLFxuICAgIC8vIFRoZSBzZWNvbmQgcmVuZGVyZXIgZG9uJ3Qga25vdyB0aGF0IGl0IG5lZWRzIHRvIHJlc2V0IHRoZSBXSVAgdmVyc2lvbiBkdXJpbmcgdW53aW5kLFxuICAgIC8vIChiZWNhdXNlIHRoZSBob29rIG9ubHkgbWFya3Mgc291cmNlcyBhcyBkaXJ0eSBpZiBpdCdzIHdyaXR0ZW4gdG8gdGhlaXIgV0lQIHZlcnNpb24pLlxuICAgIC8vIFRoYXQgd291bGQgY2F1c2UgdGhpcyB0ZWFyIGNoZWNrIHRvIHRocm93IGFnYWluIGFuZCBldmVudHVhbGx5IGJlIHZpc2libGUgdG8gdGhlIHVzZXIuXG4gICAgLy8gV2UgY2FuIGF2b2lkIHRoaXMgaW5maW5pdGUgbG9vcCBieSBleHBsaWNpdGx5IG1hcmtpbmcgdGhlIHNvdXJjZSBhcyBkaXJ0eS5cbiAgICAvL1xuICAgIC8vIFRoaXMgY2FuIGxlYWQgdG8gdGVhcmluZyBpbiB0aGUgZmlyc3QgcmVuZGVyZXIgd2hlbiBpdCByZXN1bWVzLFxuICAgIC8vIGJ1dCB0aGVyZSdzIG5vdGhpbmcgd2UgY2FuIGRvIGFib3V0IHRoYXQgKHNob3J0IG9mIHRocm93aW5nIGhlcmUgYW5kIHJlZnVzaW5nIHRvIGNvbnRpbnVlIHRoZSByZW5kZXIpLlxuICAgIG1hcmtTb3VyY2VBc0RpcnR5KHNvdXJjZSk7XG5cbiAgICB7XG4gICAgICB7XG4gICAgICAgIHRocm93IEVycm9yKCBcIkNhbm5vdCByZWFkIGZyb20gbXV0YWJsZSBzb3VyY2UgZHVyaW5nIHRoZSBjdXJyZW50IHJlbmRlciB3aXRob3V0IHRlYXJpbmcuIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiICk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHVzZU11dGFibGVTb3VyY2UoaG9vaywgc291cmNlLCBnZXRTbmFwc2hvdCwgc3Vic2NyaWJlKSB7XG4gIHZhciByb290ID0gZ2V0V29ya0luUHJvZ3Jlc3NSb290KCk7XG5cbiAgaWYgKCEocm9vdCAhPT0gbnVsbCkpIHtcbiAgICB7XG4gICAgICB0aHJvdyBFcnJvciggXCJFeHBlY3RlZCBhIHdvcmstaW4tcHJvZ3Jlc3Mgcm9vdC4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCIgKTtcbiAgICB9XG4gIH1cblxuICB2YXIgZ2V0VmVyc2lvbiA9IHNvdXJjZS5fZ2V0VmVyc2lvbjtcbiAgdmFyIHZlcnNpb24gPSBnZXRWZXJzaW9uKHNvdXJjZS5fc291cmNlKTtcbiAgdmFyIGRpc3BhdGNoZXIgPSBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudDsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHByZWZlci1jb25zdFxuXG4gIHZhciBfZGlzcGF0Y2hlciR1c2VTdGF0ZSA9IGRpc3BhdGNoZXIudXNlU3RhdGUoZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiByZWFkRnJvbVVuc3ViY3JpYmVkTXV0YWJsZVNvdXJjZShyb290LCBzb3VyY2UsIGdldFNuYXBzaG90KTtcbiAgfSksXG4gICAgICBjdXJyZW50U25hcHNob3QgPSBfZGlzcGF0Y2hlciR1c2VTdGF0ZVswXSxcbiAgICAgIHNldFNuYXBzaG90ID0gX2Rpc3BhdGNoZXIkdXNlU3RhdGVbMV07XG5cbiAgdmFyIHNuYXBzaG90ID0gY3VycmVudFNuYXBzaG90OyAvLyBHcmFiIGEgaGFuZGxlIHRvIHRoZSBzdGF0ZSBob29rIGFzIHdlbGwuXG4gIC8vIFdlIHVzZSBpdCB0byBjbGVhciB0aGUgcGVuZGluZyB1cGRhdGUgcXVldWUgaWYgd2UgaGF2ZSBhIG5ldyBzb3VyY2UuXG5cbiAgdmFyIHN0YXRlSG9vayA9IHdvcmtJblByb2dyZXNzSG9vaztcbiAgdmFyIG1lbW9pemVkU3RhdGUgPSBob29rLm1lbW9pemVkU3RhdGU7XG4gIHZhciByZWZzID0gbWVtb2l6ZWRTdGF0ZS5yZWZzO1xuICB2YXIgcHJldkdldFNuYXBzaG90ID0gcmVmcy5nZXRTbmFwc2hvdDtcbiAgdmFyIHByZXZTb3VyY2UgPSBtZW1vaXplZFN0YXRlLnNvdXJjZTtcbiAgdmFyIHByZXZTdWJzY3JpYmUgPSBtZW1vaXplZFN0YXRlLnN1YnNjcmliZTtcbiAgdmFyIGZpYmVyID0gY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMTtcbiAgaG9vay5tZW1vaXplZFN0YXRlID0ge1xuICAgIHJlZnM6IHJlZnMsXG4gICAgc291cmNlOiBzb3VyY2UsXG4gICAgc3Vic2NyaWJlOiBzdWJzY3JpYmVcbiAgfTsgLy8gU3luYyB0aGUgdmFsdWVzIG5lZWRlZCBieSBvdXIgc3Vic2NyaXB0aW9uIGhhbmRsZXIgYWZ0ZXIgZWFjaCBjb21taXQuXG5cbiAgZGlzcGF0Y2hlci51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgIHJlZnMuZ2V0U25hcHNob3QgPSBnZXRTbmFwc2hvdDsgLy8gTm9ybWFsbHkgdGhlIGRpc3BhdGNoIGZ1bmN0aW9uIGZvciBhIHN0YXRlIGhvb2sgbmV2ZXIgY2hhbmdlcyxcbiAgICAvLyBidXQgdGhpcyBob29rIHJlY3JlYXRlcyB0aGUgcXVldWUgaW4gY2VydGFpbiBjYXNlcyAgdG8gYXZvaWQgdXBkYXRlcyBmcm9tIHN0YWxlIHNvdXJjZXMuXG4gICAgLy8gaGFuZGxlQ2hhbmdlKCkgYmVsb3cgbmVlZHMgdG8gcmVmZXJlbmNlIHRoZSBkaXNwYXRjaCBmdW5jdGlvbiB3aXRob3V0IHJlLXN1YnNjcmliaW5nLFxuICAgIC8vIHNvIHdlIHVzZSBhIHJlZiB0byBlbnN1cmUgdGhhdCBpdCBhbHdheXMgaGFzIHRoZSBsYXRlc3QgdmVyc2lvbi5cblxuICAgIHJlZnMuc2V0U25hcHNob3QgPSBzZXRTbmFwc2hvdDsgLy8gQ2hlY2sgZm9yIGEgcG9zc2libGUgY2hhbmdlIGJldHdlZW4gd2hlbiB3ZSBsYXN0IHJlbmRlcmVkIG5vdy5cblxuICAgIHZhciBtYXliZU5ld1ZlcnNpb24gPSBnZXRWZXJzaW9uKHNvdXJjZS5fc291cmNlKTtcblxuICAgIGlmICghb2JqZWN0SXModmVyc2lvbiwgbWF5YmVOZXdWZXJzaW9uKSkge1xuICAgICAgdmFyIG1heWJlTmV3U25hcHNob3QgPSBnZXRTbmFwc2hvdChzb3VyY2UuX3NvdXJjZSk7XG5cbiAgICAgIHtcbiAgICAgICAgaWYgKHR5cGVvZiBtYXliZU5ld1NuYXBzaG90ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgZXJyb3IoJ011dGFibGUgc291cmNlIHNob3VsZCBub3QgcmV0dXJuIGEgZnVuY3Rpb24gYXMgdGhlIHNuYXBzaG90IHZhbHVlLiAnICsgJ0Z1bmN0aW9ucyBtYXkgY2xvc2Ugb3ZlciBtdXRhYmxlIHZhbHVlcyBhbmQgY2F1c2UgdGVhcmluZy4nKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoIW9iamVjdElzKHNuYXBzaG90LCBtYXliZU5ld1NuYXBzaG90KSkge1xuICAgICAgICBzZXRTbmFwc2hvdChtYXliZU5ld1NuYXBzaG90KTtcbiAgICAgICAgdmFyIGxhbmUgPSByZXF1ZXN0VXBkYXRlTGFuZShmaWJlcik7XG4gICAgICAgIG1hcmtSb290TXV0YWJsZVJlYWQocm9vdCwgbGFuZSk7XG4gICAgICB9IC8vIElmIHRoZSBzb3VyY2UgbXV0YXRlZCBiZXR3ZWVuIHJlbmRlciBhbmQgbm93LFxuICAgICAgLy8gdGhlcmUgbWF5IGJlIHN0YXRlIHVwZGF0ZXMgYWxyZWFkeSBzY2hlZHVsZWQgZnJvbSB0aGUgb2xkIHNvdXJjZS5cbiAgICAgIC8vIEVudGFuZ2xlIHRoZSB1cGRhdGVzIHNvIHRoYXQgdGhleSByZW5kZXIgaW4gdGhlIHNhbWUgYmF0Y2guXG5cblxuICAgICAgbWFya1Jvb3RFbnRhbmdsZWQocm9vdCwgcm9vdC5tdXRhYmxlUmVhZExhbmVzKTtcbiAgICB9XG4gIH0sIFtnZXRTbmFwc2hvdCwgc291cmNlLCBzdWJzY3JpYmVdKTsgLy8gSWYgd2UgZ290IGEgbmV3IHNvdXJjZSBvciBzdWJzY3JpYmUgZnVuY3Rpb24sIHJlLXN1YnNjcmliZSBpbiBhIHBhc3NpdmUgZWZmZWN0LlxuXG4gIGRpc3BhdGNoZXIudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgaGFuZGxlQ2hhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGxhdGVzdEdldFNuYXBzaG90ID0gcmVmcy5nZXRTbmFwc2hvdDtcbiAgICAgIHZhciBsYXRlc3RTZXRTbmFwc2hvdCA9IHJlZnMuc2V0U25hcHNob3Q7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGxhdGVzdFNldFNuYXBzaG90KGxhdGVzdEdldFNuYXBzaG90KHNvdXJjZS5fc291cmNlKSk7IC8vIFJlY29yZCBhIHBlbmRpbmcgbXV0YWJsZSBzb3VyY2UgdXBkYXRlIHdpdGggdGhlIHNhbWUgZXhwaXJhdGlvbiB0aW1lLlxuXG4gICAgICAgIHZhciBsYW5lID0gcmVxdWVzdFVwZGF0ZUxhbmUoZmliZXIpO1xuICAgICAgICBtYXJrUm9vdE11dGFibGVSZWFkKHJvb3QsIGxhbmUpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgLy8gQSBzZWxlY3RvciBtaWdodCB0aHJvdyBhZnRlciBhIHNvdXJjZSBtdXRhdGlvbi5cbiAgICAgICAgLy8gZS5nLiBpdCBtaWdodCB0cnkgdG8gcmVhZCBmcm9tIGEgcGFydCBvZiB0aGUgc3RvcmUgdGhhdCBubyBsb25nZXIgZXhpc3RzLlxuICAgICAgICAvLyBJbiB0aGlzIGNhc2Ugd2Ugc2hvdWxkIHN0aWxsIHNjaGVkdWxlIGFuIHVwZGF0ZSB3aXRoIFJlYWN0LlxuICAgICAgICAvLyBXb3JzdCBjYXNlIHRoZSBzZWxlY3RvciB3aWxsIHRocm93IGFnYWluIGFuZCB0aGVuIGFuIGVycm9yIGJvdW5kYXJ5IHdpbGwgaGFuZGxlIGl0LlxuICAgICAgICBsYXRlc3RTZXRTbmFwc2hvdChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgdW5zdWJzY3JpYmUgPSBzdWJzY3JpYmUoc291cmNlLl9zb3VyY2UsIGhhbmRsZUNoYW5nZSk7XG5cbiAgICB7XG4gICAgICBpZiAodHlwZW9mIHVuc3Vic2NyaWJlICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGVycm9yKCdNdXRhYmxlIHNvdXJjZSBzdWJzY3JpYmUgZnVuY3Rpb24gbXVzdCByZXR1cm4gYW4gdW5zdWJzY3JpYmUgZnVuY3Rpb24uJyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHVuc3Vic2NyaWJlO1xuICB9LCBbc291cmNlLCBzdWJzY3JpYmVdKTsgLy8gSWYgYW55IG9mIHRoZSBpbnB1dHMgdG8gdXNlTXV0YWJsZVNvdXJjZSBjaGFuZ2UsIHJlYWRpbmcgaXMgcG90ZW50aWFsbHkgdW5zYWZlLlxuICAvL1xuICAvLyBJZiBlaXRoZXIgdGhlIHNvdXJjZSBvciB0aGUgc3Vic2NyaXB0aW9uIGhhdmUgY2hhbmdlZCB3ZSBjYW4ndCBjYW4ndCB0cnVzdCB0aGUgdXBkYXRlIHF1ZXVlLlxuICAvLyBNYXliZSB0aGUgc291cmNlIGNoYW5nZWQgaW4gYSB3YXkgdGhhdCB0aGUgb2xkIHN1YnNjcmlwdGlvbiBpZ25vcmVkIGJ1dCB0aGUgbmV3IG9uZSBkZXBlbmRzIG9uLlxuICAvL1xuICAvLyBJZiB0aGUgZ2V0U25hcHNob3QgZnVuY3Rpb24gY2hhbmdlZCwgd2UgYWxzbyBzaG91bGRuJ3QgcmVseSBvbiB0aGUgdXBkYXRlIHF1ZXVlLlxuICAvLyBJdCdzIHBvc3NpYmxlIHRoYXQgdGhlIHVuZGVybHlpbmcgc291cmNlIHdhcyBtdXRhdGVkIGJldHdlZW4gdGhlIHdoZW4gdGhlIGxhc3QgXCJjaGFuZ2VcIiBldmVudCBmaXJlZCxcbiAgLy8gYW5kIHdoZW4gdGhlIGN1cnJlbnQgcmVuZGVyICh3aXRoIHRoZSBuZXcgZ2V0U25hcHNob3QgZnVuY3Rpb24pIGlzIHByb2Nlc3NlZC5cbiAgLy9cbiAgLy8gSW4gYm90aCBjYXNlcywgd2UgbmVlZCB0byB0aHJvdyBhd2F5IHBlbmRpbmcgdXBkYXRlcyAoc2luY2UgdGhleSBhcmUgbm8gbG9uZ2VyIHJlbGV2YW50KVxuICAvLyBhbmQgdHJlYXQgcmVhZGluZyBmcm9tIHRoZSBzb3VyY2UgYXMgd2UgZG8gaW4gdGhlIG1vdW50IGNhc2UuXG5cbiAgaWYgKCFvYmplY3RJcyhwcmV2R2V0U25hcHNob3QsIGdldFNuYXBzaG90KSB8fCAhb2JqZWN0SXMocHJldlNvdXJjZSwgc291cmNlKSB8fCAhb2JqZWN0SXMocHJldlN1YnNjcmliZSwgc3Vic2NyaWJlKSkge1xuICAgIC8vIENyZWF0ZSBhIG5ldyBxdWV1ZSBhbmQgc2V0U3RhdGUgbWV0aG9kLFxuICAgIC8vIFNvIGlmIHRoZXJlIGFyZSBpbnRlcmxlYXZlZCB1cGRhdGVzLCB0aGV5IGdldCBwdXNoZWQgdG8gdGhlIG9sZGVyIHF1ZXVlLlxuICAgIC8vIFdoZW4gdGhpcyBiZWNvbWVzIGN1cnJlbnQsIHRoZSBwcmV2aW91cyBxdWV1ZSBhbmQgZGlzcGF0Y2ggbWV0aG9kIHdpbGwgYmUgZGlzY2FyZGVkLFxuICAgIC8vIGluY2x1ZGluZyBhbnkgaW50ZXJsZWF2aW5nIHVwZGF0ZXMgdGhhdCBvY2N1ci5cbiAgICB2YXIgbmV3UXVldWUgPSB7XG4gICAgICBwZW5kaW5nOiBudWxsLFxuICAgICAgZGlzcGF0Y2g6IG51bGwsXG4gICAgICBsYXN0UmVuZGVyZWRSZWR1Y2VyOiBiYXNpY1N0YXRlUmVkdWNlcixcbiAgICAgIGxhc3RSZW5kZXJlZFN0YXRlOiBzbmFwc2hvdFxuICAgIH07XG4gICAgbmV3UXVldWUuZGlzcGF0Y2ggPSBzZXRTbmFwc2hvdCA9IGRpc3BhdGNoQWN0aW9uLmJpbmQobnVsbCwgY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMSwgbmV3UXVldWUpO1xuICAgIHN0YXRlSG9vay5xdWV1ZSA9IG5ld1F1ZXVlO1xuICAgIHN0YXRlSG9vay5iYXNlUXVldWUgPSBudWxsO1xuICAgIHNuYXBzaG90ID0gcmVhZEZyb21VbnN1YmNyaWJlZE11dGFibGVTb3VyY2Uocm9vdCwgc291cmNlLCBnZXRTbmFwc2hvdCk7XG4gICAgc3RhdGVIb29rLm1lbW9pemVkU3RhdGUgPSBzdGF0ZUhvb2suYmFzZVN0YXRlID0gc25hcHNob3Q7XG4gIH1cblxuICByZXR1cm4gc25hcHNob3Q7XG59XG5cbmZ1bmN0aW9uIG1vdW50TXV0YWJsZVNvdXJjZShzb3VyY2UsIGdldFNuYXBzaG90LCBzdWJzY3JpYmUpIHtcbiAgdmFyIGhvb2sgPSBtb3VudFdvcmtJblByb2dyZXNzSG9vaygpO1xuICBob29rLm1lbW9pemVkU3RhdGUgPSB7XG4gICAgcmVmczoge1xuICAgICAgZ2V0U25hcHNob3Q6IGdldFNuYXBzaG90LFxuICAgICAgc2V0U25hcHNob3Q6IG51bGxcbiAgICB9LFxuICAgIHNvdXJjZTogc291cmNlLFxuICAgIHN1YnNjcmliZTogc3Vic2NyaWJlXG4gIH07XG4gIHJldHVybiB1c2VNdXRhYmxlU291cmNlKGhvb2ssIHNvdXJjZSwgZ2V0U25hcHNob3QsIHN1YnNjcmliZSk7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZU11dGFibGVTb3VyY2Uoc291cmNlLCBnZXRTbmFwc2hvdCwgc3Vic2NyaWJlKSB7XG4gIHZhciBob29rID0gdXBkYXRlV29ya0luUHJvZ3Jlc3NIb29rKCk7XG4gIHJldHVybiB1c2VNdXRhYmxlU291cmNlKGhvb2ssIHNvdXJjZSwgZ2V0U25hcHNob3QsIHN1YnNjcmliZSk7XG59XG5cbmZ1bmN0aW9uIG1vdW50U3RhdGUoaW5pdGlhbFN0YXRlKSB7XG4gIHZhciBob29rID0gbW91bnRXb3JrSW5Qcm9ncmVzc0hvb2soKTtcblxuICBpZiAodHlwZW9mIGluaXRpYWxTdGF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIC8vICRGbG93Rml4TWU6IEZsb3cgZG9lc24ndCBsaWtlIG1peGVkIHR5cGVzXG4gICAgaW5pdGlhbFN0YXRlID0gaW5pdGlhbFN0YXRlKCk7XG4gIH1cblxuICBob29rLm1lbW9pemVkU3RhdGUgPSBob29rLmJhc2VTdGF0ZSA9IGluaXRpYWxTdGF0ZTtcbiAgdmFyIHF1ZXVlID0gaG9vay5xdWV1ZSA9IHtcbiAgICBwZW5kaW5nOiBudWxsLFxuICAgIGRpc3BhdGNoOiBudWxsLFxuICAgIGxhc3RSZW5kZXJlZFJlZHVjZXI6IGJhc2ljU3RhdGVSZWR1Y2VyLFxuICAgIGxhc3RSZW5kZXJlZFN0YXRlOiBpbml0aWFsU3RhdGVcbiAgfTtcbiAgdmFyIGRpc3BhdGNoID0gcXVldWUuZGlzcGF0Y2ggPSBkaXNwYXRjaEFjdGlvbi5iaW5kKG51bGwsIGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEsIHF1ZXVlKTtcbiAgcmV0dXJuIFtob29rLm1lbW9pemVkU3RhdGUsIGRpc3BhdGNoXTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlU3RhdGUoaW5pdGlhbFN0YXRlKSB7XG4gIHJldHVybiB1cGRhdGVSZWR1Y2VyKGJhc2ljU3RhdGVSZWR1Y2VyKTtcbn1cblxuZnVuY3Rpb24gcmVyZW5kZXJTdGF0ZShpbml0aWFsU3RhdGUpIHtcbiAgcmV0dXJuIHJlcmVuZGVyUmVkdWNlcihiYXNpY1N0YXRlUmVkdWNlcik7XG59XG5cbmZ1bmN0aW9uIHB1c2hFZmZlY3QodGFnLCBjcmVhdGUsIGRlc3Ryb3ksIGRlcHMpIHtcbiAgdmFyIGVmZmVjdCA9IHtcbiAgICB0YWc6IHRhZyxcbiAgICBjcmVhdGU6IGNyZWF0ZSxcbiAgICBkZXN0cm95OiBkZXN0cm95LFxuICAgIGRlcHM6IGRlcHMsXG4gICAgLy8gQ2lyY3VsYXJcbiAgICBuZXh0OiBudWxsXG4gIH07XG4gIHZhciBjb21wb25lbnRVcGRhdGVRdWV1ZSA9IGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEudXBkYXRlUXVldWU7XG5cbiAgaWYgKGNvbXBvbmVudFVwZGF0ZVF1ZXVlID09PSBudWxsKSB7XG4gICAgY29tcG9uZW50VXBkYXRlUXVldWUgPSBjcmVhdGVGdW5jdGlvbkNvbXBvbmVudFVwZGF0ZVF1ZXVlKCk7XG4gICAgY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMS51cGRhdGVRdWV1ZSA9IGNvbXBvbmVudFVwZGF0ZVF1ZXVlO1xuICAgIGNvbXBvbmVudFVwZGF0ZVF1ZXVlLmxhc3RFZmZlY3QgPSBlZmZlY3QubmV4dCA9IGVmZmVjdDtcbiAgfSBlbHNlIHtcbiAgICB2YXIgbGFzdEVmZmVjdCA9IGNvbXBvbmVudFVwZGF0ZVF1ZXVlLmxhc3RFZmZlY3Q7XG5cbiAgICBpZiAobGFzdEVmZmVjdCA9PT0gbnVsbCkge1xuICAgICAgY29tcG9uZW50VXBkYXRlUXVldWUubGFzdEVmZmVjdCA9IGVmZmVjdC5uZXh0ID0gZWZmZWN0O1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgZmlyc3RFZmZlY3QgPSBsYXN0RWZmZWN0Lm5leHQ7XG4gICAgICBsYXN0RWZmZWN0Lm5leHQgPSBlZmZlY3Q7XG4gICAgICBlZmZlY3QubmV4dCA9IGZpcnN0RWZmZWN0O1xuICAgICAgY29tcG9uZW50VXBkYXRlUXVldWUubGFzdEVmZmVjdCA9IGVmZmVjdDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZWZmZWN0O1xufVxuXG5mdW5jdGlvbiBtb3VudFJlZihpbml0aWFsVmFsdWUpIHtcbiAgdmFyIGhvb2sgPSBtb3VudFdvcmtJblByb2dyZXNzSG9vaygpO1xuICB2YXIgcmVmID0ge1xuICAgIGN1cnJlbnQ6IGluaXRpYWxWYWx1ZVxuICB9O1xuXG4gIHtcbiAgICBPYmplY3Quc2VhbChyZWYpO1xuICB9XG5cbiAgaG9vay5tZW1vaXplZFN0YXRlID0gcmVmO1xuICByZXR1cm4gcmVmO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVSZWYoaW5pdGlhbFZhbHVlKSB7XG4gIHZhciBob29rID0gdXBkYXRlV29ya0luUHJvZ3Jlc3NIb29rKCk7XG4gIHJldHVybiBob29rLm1lbW9pemVkU3RhdGU7XG59XG5cbmZ1bmN0aW9uIG1vdW50RWZmZWN0SW1wbChmaWJlckZsYWdzLCBob29rRmxhZ3MsIGNyZWF0ZSwgZGVwcykge1xuICB2YXIgaG9vayA9IG1vdW50V29ya0luUHJvZ3Jlc3NIb29rKCk7XG4gIHZhciBuZXh0RGVwcyA9IGRlcHMgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBkZXBzO1xuICBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxLmZsYWdzIHw9IGZpYmVyRmxhZ3M7XG4gIGhvb2subWVtb2l6ZWRTdGF0ZSA9IHB1c2hFZmZlY3QoSGFzRWZmZWN0IHwgaG9va0ZsYWdzLCBjcmVhdGUsIHVuZGVmaW5lZCwgbmV4dERlcHMpO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVFZmZlY3RJbXBsKGZpYmVyRmxhZ3MsIGhvb2tGbGFncywgY3JlYXRlLCBkZXBzKSB7XG4gIHZhciBob29rID0gdXBkYXRlV29ya0luUHJvZ3Jlc3NIb29rKCk7XG4gIHZhciBuZXh0RGVwcyA9IGRlcHMgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBkZXBzO1xuICB2YXIgZGVzdHJveSA9IHVuZGVmaW5lZDtcblxuICBpZiAoY3VycmVudEhvb2sgIT09IG51bGwpIHtcbiAgICB2YXIgcHJldkVmZmVjdCA9IGN1cnJlbnRIb29rLm1lbW9pemVkU3RhdGU7XG4gICAgZGVzdHJveSA9IHByZXZFZmZlY3QuZGVzdHJveTtcblxuICAgIGlmIChuZXh0RGVwcyAhPT0gbnVsbCkge1xuICAgICAgdmFyIHByZXZEZXBzID0gcHJldkVmZmVjdC5kZXBzO1xuXG4gICAgICBpZiAoYXJlSG9va0lucHV0c0VxdWFsKG5leHREZXBzLCBwcmV2RGVwcykpIHtcbiAgICAgICAgcHVzaEVmZmVjdChob29rRmxhZ3MsIGNyZWF0ZSwgZGVzdHJveSwgbmV4dERlcHMpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMS5mbGFncyB8PSBmaWJlckZsYWdzO1xuICBob29rLm1lbW9pemVkU3RhdGUgPSBwdXNoRWZmZWN0KEhhc0VmZmVjdCB8IGhvb2tGbGFncywgY3JlYXRlLCBkZXN0cm95LCBuZXh0RGVwcyk7XG59XG5cbmZ1bmN0aW9uIG1vdW50RWZmZWN0KGNyZWF0ZSwgZGVwcykge1xuICB7XG4gICAgLy8gJEZsb3dFeHBlY3RlZEVycm9yIC0gamVzdCBpc24ndCBhIGdsb2JhbCwgYW5kIGlzbid0IHJlY29nbml6ZWQgb3V0c2lkZSBvZiB0ZXN0c1xuICAgIGlmICgndW5kZWZpbmVkJyAhPT0gdHlwZW9mIGplc3QpIHtcbiAgICAgIHdhcm5JZk5vdEN1cnJlbnRseUFjdGluZ0VmZmVjdHNJbkRFVihjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbW91bnRFZmZlY3RJbXBsKFVwZGF0ZSB8IFBhc3NpdmUsIFBhc3NpdmUkMSwgY3JlYXRlLCBkZXBzKTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlRWZmZWN0KGNyZWF0ZSwgZGVwcykge1xuICB7XG4gICAgLy8gJEZsb3dFeHBlY3RlZEVycm9yIC0gamVzdCBpc24ndCBhIGdsb2JhbCwgYW5kIGlzbid0IHJlY29nbml6ZWQgb3V0c2lkZSBvZiB0ZXN0c1xuICAgIGlmICgndW5kZWZpbmVkJyAhPT0gdHlwZW9mIGplc3QpIHtcbiAgICAgIHdhcm5JZk5vdEN1cnJlbnRseUFjdGluZ0VmZmVjdHNJbkRFVihjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdXBkYXRlRWZmZWN0SW1wbChVcGRhdGUgfCBQYXNzaXZlLCBQYXNzaXZlJDEsIGNyZWF0ZSwgZGVwcyk7XG59XG5cbmZ1bmN0aW9uIG1vdW50TGF5b3V0RWZmZWN0KGNyZWF0ZSwgZGVwcykge1xuICByZXR1cm4gbW91bnRFZmZlY3RJbXBsKFVwZGF0ZSwgTGF5b3V0LCBjcmVhdGUsIGRlcHMpO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVMYXlvdXRFZmZlY3QoY3JlYXRlLCBkZXBzKSB7XG4gIHJldHVybiB1cGRhdGVFZmZlY3RJbXBsKFVwZGF0ZSwgTGF5b3V0LCBjcmVhdGUsIGRlcHMpO1xufVxuXG5mdW5jdGlvbiBpbXBlcmF0aXZlSGFuZGxlRWZmZWN0KGNyZWF0ZSwgcmVmKSB7XG4gIGlmICh0eXBlb2YgcmVmID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdmFyIHJlZkNhbGxiYWNrID0gcmVmO1xuXG4gICAgdmFyIF9pbnN0ID0gY3JlYXRlKCk7XG5cbiAgICByZWZDYWxsYmFjayhfaW5zdCk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIHJlZkNhbGxiYWNrKG51bGwpO1xuICAgIH07XG4gIH0gZWxzZSBpZiAocmVmICE9PSBudWxsICYmIHJlZiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdmFyIHJlZk9iamVjdCA9IHJlZjtcblxuICAgIHtcbiAgICAgIGlmICghcmVmT2JqZWN0Lmhhc093blByb3BlcnR5KCdjdXJyZW50JykpIHtcbiAgICAgICAgZXJyb3IoJ0V4cGVjdGVkIHVzZUltcGVyYXRpdmVIYW5kbGUoKSBmaXJzdCBhcmd1bWVudCB0byBlaXRoZXIgYmUgYSAnICsgJ3JlZiBjYWxsYmFjayBvciBSZWFjdC5jcmVhdGVSZWYoKSBvYmplY3QuIEluc3RlYWQgcmVjZWl2ZWQ6ICVzLicsICdhbiBvYmplY3Qgd2l0aCBrZXlzIHsnICsgT2JqZWN0LmtleXMocmVmT2JqZWN0KS5qb2luKCcsICcpICsgJ30nKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgX2luc3QyID0gY3JlYXRlKCk7XG5cbiAgICByZWZPYmplY3QuY3VycmVudCA9IF9pbnN0MjtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgcmVmT2JqZWN0LmN1cnJlbnQgPSBudWxsO1xuICAgIH07XG4gIH1cbn1cblxuZnVuY3Rpb24gbW91bnRJbXBlcmF0aXZlSGFuZGxlKHJlZiwgY3JlYXRlLCBkZXBzKSB7XG4gIHtcbiAgICBpZiAodHlwZW9mIGNyZWF0ZSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgZXJyb3IoJ0V4cGVjdGVkIHVzZUltcGVyYXRpdmVIYW5kbGUoKSBzZWNvbmQgYXJndW1lbnQgdG8gYmUgYSBmdW5jdGlvbiAnICsgJ3RoYXQgY3JlYXRlcyBhIGhhbmRsZS4gSW5zdGVhZCByZWNlaXZlZDogJXMuJywgY3JlYXRlICE9PSBudWxsID8gdHlwZW9mIGNyZWF0ZSA6ICdudWxsJyk7XG4gICAgfVxuICB9IC8vIFRPRE86IElmIGRlcHMgYXJlIHByb3ZpZGVkLCBzaG91bGQgd2Ugc2tpcCBjb21wYXJpbmcgdGhlIHJlZiBpdHNlbGY/XG5cblxuICB2YXIgZWZmZWN0RGVwcyA9IGRlcHMgIT09IG51bGwgJiYgZGVwcyAhPT0gdW5kZWZpbmVkID8gZGVwcy5jb25jYXQoW3JlZl0pIDogbnVsbDtcbiAgcmV0dXJuIG1vdW50RWZmZWN0SW1wbChVcGRhdGUsIExheW91dCwgaW1wZXJhdGl2ZUhhbmRsZUVmZmVjdC5iaW5kKG51bGwsIGNyZWF0ZSwgcmVmKSwgZWZmZWN0RGVwcyk7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUltcGVyYXRpdmVIYW5kbGUocmVmLCBjcmVhdGUsIGRlcHMpIHtcbiAge1xuICAgIGlmICh0eXBlb2YgY3JlYXRlICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICBlcnJvcignRXhwZWN0ZWQgdXNlSW1wZXJhdGl2ZUhhbmRsZSgpIHNlY29uZCBhcmd1bWVudCB0byBiZSBhIGZ1bmN0aW9uICcgKyAndGhhdCBjcmVhdGVzIGEgaGFuZGxlLiBJbnN0ZWFkIHJlY2VpdmVkOiAlcy4nLCBjcmVhdGUgIT09IG51bGwgPyB0eXBlb2YgY3JlYXRlIDogJ251bGwnKTtcbiAgICB9XG4gIH0gLy8gVE9ETzogSWYgZGVwcyBhcmUgcHJvdmlkZWQsIHNob3VsZCB3ZSBza2lwIGNvbXBhcmluZyB0aGUgcmVmIGl0c2VsZj9cblxuXG4gIHZhciBlZmZlY3REZXBzID0gZGVwcyAhPT0gbnVsbCAmJiBkZXBzICE9PSB1bmRlZmluZWQgPyBkZXBzLmNvbmNhdChbcmVmXSkgOiBudWxsO1xuICByZXR1cm4gdXBkYXRlRWZmZWN0SW1wbChVcGRhdGUsIExheW91dCwgaW1wZXJhdGl2ZUhhbmRsZUVmZmVjdC5iaW5kKG51bGwsIGNyZWF0ZSwgcmVmKSwgZWZmZWN0RGVwcyk7XG59XG5cbmZ1bmN0aW9uIG1vdW50RGVidWdWYWx1ZSh2YWx1ZSwgZm9ybWF0dGVyRm4pIHsvLyBUaGlzIGhvb2sgaXMgbm9ybWFsbHkgYSBuby1vcC5cbiAgLy8gVGhlIHJlYWN0LWRlYnVnLWhvb2tzIHBhY2thZ2UgaW5qZWN0cyBpdHMgb3duIGltcGxlbWVudGF0aW9uXG4gIC8vIHNvIHRoYXQgZS5nLiBEZXZUb29scyBjYW4gZGlzcGxheSBjdXN0b20gaG9vayB2YWx1ZXMuXG59XG5cbnZhciB1cGRhdGVEZWJ1Z1ZhbHVlID0gbW91bnREZWJ1Z1ZhbHVlO1xuXG5mdW5jdGlvbiBtb3VudENhbGxiYWNrKGNhbGxiYWNrLCBkZXBzKSB7XG4gIHZhciBob29rID0gbW91bnRXb3JrSW5Qcm9ncmVzc0hvb2soKTtcbiAgdmFyIG5leHREZXBzID0gZGVwcyA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IGRlcHM7XG4gIGhvb2subWVtb2l6ZWRTdGF0ZSA9IFtjYWxsYmFjaywgbmV4dERlcHNdO1xuICByZXR1cm4gY2FsbGJhY2s7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUNhbGxiYWNrKGNhbGxiYWNrLCBkZXBzKSB7XG4gIHZhciBob29rID0gdXBkYXRlV29ya0luUHJvZ3Jlc3NIb29rKCk7XG4gIHZhciBuZXh0RGVwcyA9IGRlcHMgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBkZXBzO1xuICB2YXIgcHJldlN0YXRlID0gaG9vay5tZW1vaXplZFN0YXRlO1xuXG4gIGlmIChwcmV2U3RhdGUgIT09IG51bGwpIHtcbiAgICBpZiAobmV4dERlcHMgIT09IG51bGwpIHtcbiAgICAgIHZhciBwcmV2RGVwcyA9IHByZXZTdGF0ZVsxXTtcblxuICAgICAgaWYgKGFyZUhvb2tJbnB1dHNFcXVhbChuZXh0RGVwcywgcHJldkRlcHMpKSB7XG4gICAgICAgIHJldHVybiBwcmV2U3RhdGVbMF07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaG9vay5tZW1vaXplZFN0YXRlID0gW2NhbGxiYWNrLCBuZXh0RGVwc107XG4gIHJldHVybiBjYWxsYmFjaztcbn1cblxuZnVuY3Rpb24gbW91bnRNZW1vKG5leHRDcmVhdGUsIGRlcHMpIHtcbiAgdmFyIGhvb2sgPSBtb3VudFdvcmtJblByb2dyZXNzSG9vaygpO1xuICB2YXIgbmV4dERlcHMgPSBkZXBzID09PSB1bmRlZmluZWQgPyBudWxsIDogZGVwcztcbiAgdmFyIG5leHRWYWx1ZSA9IG5leHRDcmVhdGUoKTtcbiAgaG9vay5tZW1vaXplZFN0YXRlID0gW25leHRWYWx1ZSwgbmV4dERlcHNdO1xuICByZXR1cm4gbmV4dFZhbHVlO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVNZW1vKG5leHRDcmVhdGUsIGRlcHMpIHtcbiAgdmFyIGhvb2sgPSB1cGRhdGVXb3JrSW5Qcm9ncmVzc0hvb2soKTtcbiAgdmFyIG5leHREZXBzID0gZGVwcyA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IGRlcHM7XG4gIHZhciBwcmV2U3RhdGUgPSBob29rLm1lbW9pemVkU3RhdGU7XG5cbiAgaWYgKHByZXZTdGF0ZSAhPT0gbnVsbCkge1xuICAgIC8vIEFzc3VtZSB0aGVzZSBhcmUgZGVmaW5lZC4gSWYgdGhleSdyZSBub3QsIGFyZUhvb2tJbnB1dHNFcXVhbCB3aWxsIHdhcm4uXG4gICAgaWYgKG5leHREZXBzICE9PSBudWxsKSB7XG4gICAgICB2YXIgcHJldkRlcHMgPSBwcmV2U3RhdGVbMV07XG5cbiAgICAgIGlmIChhcmVIb29rSW5wdXRzRXF1YWwobmV4dERlcHMsIHByZXZEZXBzKSkge1xuICAgICAgICByZXR1cm4gcHJldlN0YXRlWzBdO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHZhciBuZXh0VmFsdWUgPSBuZXh0Q3JlYXRlKCk7XG4gIGhvb2subWVtb2l6ZWRTdGF0ZSA9IFtuZXh0VmFsdWUsIG5leHREZXBzXTtcbiAgcmV0dXJuIG5leHRWYWx1ZTtcbn1cblxuZnVuY3Rpb24gbW91bnREZWZlcnJlZFZhbHVlKHZhbHVlKSB7XG4gIHZhciBfbW91bnRTdGF0ZSA9IG1vdW50U3RhdGUodmFsdWUpLFxuICAgICAgcHJldlZhbHVlID0gX21vdW50U3RhdGVbMF0sXG4gICAgICBzZXRWYWx1ZSA9IF9tb3VudFN0YXRlWzFdO1xuXG4gIG1vdW50RWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcHJldlRyYW5zaXRpb24gPSBSZWFjdEN1cnJlbnRCYXRjaENvbmZpZyQxLnRyYW5zaXRpb247XG4gICAgUmVhY3RDdXJyZW50QmF0Y2hDb25maWckMS50cmFuc2l0aW9uID0gMTtcblxuICAgIHRyeSB7XG4gICAgICBzZXRWYWx1ZSh2YWx1ZSk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIFJlYWN0Q3VycmVudEJhdGNoQ29uZmlnJDEudHJhbnNpdGlvbiA9IHByZXZUcmFuc2l0aW9uO1xuICAgIH1cbiAgfSwgW3ZhbHVlXSk7XG4gIHJldHVybiBwcmV2VmFsdWU7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZURlZmVycmVkVmFsdWUodmFsdWUpIHtcbiAgdmFyIF91cGRhdGVTdGF0ZSA9IHVwZGF0ZVN0YXRlKCksXG4gICAgICBwcmV2VmFsdWUgPSBfdXBkYXRlU3RhdGVbMF0sXG4gICAgICBzZXRWYWx1ZSA9IF91cGRhdGVTdGF0ZVsxXTtcblxuICB1cGRhdGVFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgIHZhciBwcmV2VHJhbnNpdGlvbiA9IFJlYWN0Q3VycmVudEJhdGNoQ29uZmlnJDEudHJhbnNpdGlvbjtcbiAgICBSZWFjdEN1cnJlbnRCYXRjaENvbmZpZyQxLnRyYW5zaXRpb24gPSAxO1xuXG4gICAgdHJ5IHtcbiAgICAgIHNldFZhbHVlKHZhbHVlKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgUmVhY3RDdXJyZW50QmF0Y2hDb25maWckMS50cmFuc2l0aW9uID0gcHJldlRyYW5zaXRpb247XG4gICAgfVxuICB9LCBbdmFsdWVdKTtcbiAgcmV0dXJuIHByZXZWYWx1ZTtcbn1cblxuZnVuY3Rpb24gcmVyZW5kZXJEZWZlcnJlZFZhbHVlKHZhbHVlKSB7XG4gIHZhciBfcmVyZW5kZXJTdGF0ZSA9IHJlcmVuZGVyU3RhdGUoKSxcbiAgICAgIHByZXZWYWx1ZSA9IF9yZXJlbmRlclN0YXRlWzBdLFxuICAgICAgc2V0VmFsdWUgPSBfcmVyZW5kZXJTdGF0ZVsxXTtcblxuICB1cGRhdGVFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgIHZhciBwcmV2VHJhbnNpdGlvbiA9IFJlYWN0Q3VycmVudEJhdGNoQ29uZmlnJDEudHJhbnNpdGlvbjtcbiAgICBSZWFjdEN1cnJlbnRCYXRjaENvbmZpZyQxLnRyYW5zaXRpb24gPSAxO1xuXG4gICAgdHJ5IHtcbiAgICAgIHNldFZhbHVlKHZhbHVlKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgUmVhY3RDdXJyZW50QmF0Y2hDb25maWckMS50cmFuc2l0aW9uID0gcHJldlRyYW5zaXRpb247XG4gICAgfVxuICB9LCBbdmFsdWVdKTtcbiAgcmV0dXJuIHByZXZWYWx1ZTtcbn1cblxuZnVuY3Rpb24gc3RhcnRUcmFuc2l0aW9uKHNldFBlbmRpbmcsIGNhbGxiYWNrKSB7XG4gIHZhciBwcmlvcml0eUxldmVsID0gZ2V0Q3VycmVudFByaW9yaXR5TGV2ZWwoKTtcblxuICB7XG4gICAgcnVuV2l0aFByaW9yaXR5JDEocHJpb3JpdHlMZXZlbCA8IFVzZXJCbG9ja2luZ1ByaW9yaXR5JDIgPyBVc2VyQmxvY2tpbmdQcmlvcml0eSQyIDogcHJpb3JpdHlMZXZlbCwgZnVuY3Rpb24gKCkge1xuICAgICAgc2V0UGVuZGluZyh0cnVlKTtcbiAgICB9KTtcbiAgICBydW5XaXRoUHJpb3JpdHkkMShwcmlvcml0eUxldmVsID4gTm9ybWFsUHJpb3JpdHkkMSA/IE5vcm1hbFByaW9yaXR5JDEgOiBwcmlvcml0eUxldmVsLCBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgcHJldlRyYW5zaXRpb24gPSBSZWFjdEN1cnJlbnRCYXRjaENvbmZpZyQxLnRyYW5zaXRpb247XG4gICAgICBSZWFjdEN1cnJlbnRCYXRjaENvbmZpZyQxLnRyYW5zaXRpb24gPSAxO1xuXG4gICAgICB0cnkge1xuICAgICAgICBzZXRQZW5kaW5nKGZhbHNlKTtcbiAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIFJlYWN0Q3VycmVudEJhdGNoQ29uZmlnJDEudHJhbnNpdGlvbiA9IHByZXZUcmFuc2l0aW9uO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIG1vdW50VHJhbnNpdGlvbigpIHtcbiAgdmFyIF9tb3VudFN0YXRlMiA9IG1vdW50U3RhdGUoZmFsc2UpLFxuICAgICAgaXNQZW5kaW5nID0gX21vdW50U3RhdGUyWzBdLFxuICAgICAgc2V0UGVuZGluZyA9IF9tb3VudFN0YXRlMlsxXTsgLy8gVGhlIGBzdGFydGAgbWV0aG9kIGNhbiBiZSBzdG9yZWQgb24gYSByZWYsIHNpbmNlIGBzZXRQZW5kaW5nYFxuICAvLyBuZXZlciBjaGFuZ2VzLlxuXG5cbiAgdmFyIHN0YXJ0ID0gc3RhcnRUcmFuc2l0aW9uLmJpbmQobnVsbCwgc2V0UGVuZGluZyk7XG4gIG1vdW50UmVmKHN0YXJ0KTtcbiAgcmV0dXJuIFtzdGFydCwgaXNQZW5kaW5nXTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlVHJhbnNpdGlvbigpIHtcbiAgdmFyIF91cGRhdGVTdGF0ZTIgPSB1cGRhdGVTdGF0ZSgpLFxuICAgICAgaXNQZW5kaW5nID0gX3VwZGF0ZVN0YXRlMlswXTtcblxuICB2YXIgc3RhcnRSZWYgPSB1cGRhdGVSZWYoKTtcbiAgdmFyIHN0YXJ0ID0gc3RhcnRSZWYuY3VycmVudDtcbiAgcmV0dXJuIFtzdGFydCwgaXNQZW5kaW5nXTtcbn1cblxuZnVuY3Rpb24gcmVyZW5kZXJUcmFuc2l0aW9uKCkge1xuICB2YXIgX3JlcmVuZGVyU3RhdGUyID0gcmVyZW5kZXJTdGF0ZSgpLFxuICAgICAgaXNQZW5kaW5nID0gX3JlcmVuZGVyU3RhdGUyWzBdO1xuXG4gIHZhciBzdGFydFJlZiA9IHVwZGF0ZVJlZigpO1xuICB2YXIgc3RhcnQgPSBzdGFydFJlZi5jdXJyZW50O1xuICByZXR1cm4gW3N0YXJ0LCBpc1BlbmRpbmddO1xufVxuXG52YXIgaXNVcGRhdGluZ09wYXF1ZVZhbHVlSW5SZW5kZXJQaGFzZSA9IGZhbHNlO1xuZnVuY3Rpb24gZ2V0SXNVcGRhdGluZ09wYXF1ZVZhbHVlSW5SZW5kZXJQaGFzZUluREVWKCkge1xuICB7XG4gICAgcmV0dXJuIGlzVXBkYXRpbmdPcGFxdWVWYWx1ZUluUmVuZGVyUGhhc2U7XG4gIH1cbn1cblxuZnVuY3Rpb24gd2Fybk9uT3BhcXVlSWRlbnRpZmllckFjY2Vzc0luREVWKGZpYmVyKSB7XG4gIHtcbiAgICAvLyBUT0RPOiBTaG91bGQgd2FybiBpbiBlZmZlY3RzIGFuZCBjYWxsYmFja3MsIHRvb1xuICAgIHZhciBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZShmaWJlci50eXBlKSB8fCAnVW5rbm93bic7XG5cbiAgICBpZiAoZ2V0SXNSZW5kZXJpbmcoKSAmJiAhZGlkV2FybkFib3V0VXNlT3BhcXVlSWRlbnRpZmllcltuYW1lXSkge1xuICAgICAgZXJyb3IoJ1RoZSBvYmplY3QgcGFzc2VkIGJhY2sgZnJvbSB1c2VPcGFxdWVJZGVudGlmaWVyIGlzIG1lYW50IHRvIGJlICcgKyAncGFzc2VkIHRocm91Z2ggdG8gYXR0cmlidXRlcyBvbmx5LiBEbyBub3QgcmVhZCB0aGUgJyArICd2YWx1ZSBkaXJlY3RseS4nKTtcblxuICAgICAgZGlkV2FybkFib3V0VXNlT3BhcXVlSWRlbnRpZmllcltuYW1lXSA9IHRydWU7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIG1vdW50T3BhcXVlSWRlbnRpZmllcigpIHtcbiAgdmFyIG1ha2VJZCA9ICBtYWtlQ2xpZW50SWRJbkRFVi5iaW5kKG51bGwsIHdhcm5Pbk9wYXF1ZUlkZW50aWZpZXJBY2Nlc3NJbkRFVi5iaW5kKG51bGwsIGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEpKSA7XG5cbiAgaWYgKGdldElzSHlkcmF0aW5nKCkpIHtcbiAgICB2YXIgZGlkVXBncmFkZSA9IGZhbHNlO1xuICAgIHZhciBmaWJlciA9IGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDE7XG5cbiAgICB2YXIgcmVhZFZhbHVlID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKCFkaWRVcGdyYWRlKSB7XG4gICAgICAgIC8vIE9ubHkgdXBncmFkZSBvbmNlLiBUaGlzIHdvcmtzIGV2ZW4gaW5zaWRlIHRoZSByZW5kZXIgcGhhc2UgYmVjYXVzZVxuICAgICAgICAvLyB0aGUgdXBkYXRlIGlzIGFkZGVkIHRvIGEgc2hhcmVkIHF1ZXVlLCB3aGljaCBvdXRsYXN0cyB0aGVcbiAgICAgICAgLy8gaW4tcHJvZ3Jlc3MgcmVuZGVyLlxuICAgICAgICBkaWRVcGdyYWRlID0gdHJ1ZTtcblxuICAgICAgICB7XG4gICAgICAgICAgaXNVcGRhdGluZ09wYXF1ZVZhbHVlSW5SZW5kZXJQaGFzZSA9IHRydWU7XG4gICAgICAgICAgc2V0SWQobWFrZUlkKCkpO1xuICAgICAgICAgIGlzVXBkYXRpbmdPcGFxdWVWYWx1ZUluUmVuZGVyUGhhc2UgPSBmYWxzZTtcbiAgICAgICAgICB3YXJuT25PcGFxdWVJZGVudGlmaWVyQWNjZXNzSW5ERVYoZmliZXIpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHtcbiAgICAgICAge1xuICAgICAgICAgIHRocm93IEVycm9yKCBcIlRoZSBvYmplY3QgcGFzc2VkIGJhY2sgZnJvbSB1c2VPcGFxdWVJZGVudGlmaWVyIGlzIG1lYW50IHRvIGJlIHBhc3NlZCB0aHJvdWdoIHRvIGF0dHJpYnV0ZXMgb25seS4gRG8gbm90IHJlYWQgdGhlIHZhbHVlIGRpcmVjdGx5LlwiICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIGlkID0gbWFrZU9wYXF1ZUh5ZHJhdGluZ09iamVjdChyZWFkVmFsdWUpO1xuICAgIHZhciBzZXRJZCA9IG1vdW50U3RhdGUoaWQpWzFdO1xuXG4gICAgaWYgKChjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxLm1vZGUgJiBCbG9ja2luZ01vZGUpID09PSBOb01vZGUpIHtcbiAgICAgIGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEuZmxhZ3MgfD0gVXBkYXRlIHwgUGFzc2l2ZTtcbiAgICAgIHB1c2hFZmZlY3QoSGFzRWZmZWN0IHwgUGFzc2l2ZSQxLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHNldElkKG1ha2VJZCgpKTtcbiAgICAgIH0sIHVuZGVmaW5lZCwgbnVsbCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGlkO1xuICB9IGVsc2Uge1xuICAgIHZhciBfaWQgPSBtYWtlSWQoKTtcblxuICAgIG1vdW50U3RhdGUoX2lkKTtcbiAgICByZXR1cm4gX2lkO1xuICB9XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZU9wYXF1ZUlkZW50aWZpZXIoKSB7XG4gIHZhciBpZCA9IHVwZGF0ZVN0YXRlKClbMF07XG4gIHJldHVybiBpZDtcbn1cblxuZnVuY3Rpb24gcmVyZW5kZXJPcGFxdWVJZGVudGlmaWVyKCkge1xuICB2YXIgaWQgPSByZXJlbmRlclN0YXRlKClbMF07XG4gIHJldHVybiBpZDtcbn1cblxuZnVuY3Rpb24gZGlzcGF0Y2hBY3Rpb24oZmliZXIsIHF1ZXVlLCBhY3Rpb24pIHtcbiAge1xuICAgIGlmICh0eXBlb2YgYXJndW1lbnRzWzNdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBlcnJvcihcIlN0YXRlIHVwZGF0ZXMgZnJvbSB0aGUgdXNlU3RhdGUoKSBhbmQgdXNlUmVkdWNlcigpIEhvb2tzIGRvbid0IHN1cHBvcnQgdGhlIFwiICsgJ3NlY29uZCBjYWxsYmFjayBhcmd1bWVudC4gVG8gZXhlY3V0ZSBhIHNpZGUgZWZmZWN0IGFmdGVyICcgKyAncmVuZGVyaW5nLCBkZWNsYXJlIGl0IGluIHRoZSBjb21wb25lbnQgYm9keSB3aXRoIHVzZUVmZmVjdCgpLicpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBldmVudFRpbWUgPSByZXF1ZXN0RXZlbnRUaW1lKCk7XG4gIHZhciBsYW5lID0gcmVxdWVzdFVwZGF0ZUxhbmUoZmliZXIpO1xuICB2YXIgdXBkYXRlID0ge1xuICAgIGxhbmU6IGxhbmUsXG4gICAgYWN0aW9uOiBhY3Rpb24sXG4gICAgZWFnZXJSZWR1Y2VyOiBudWxsLFxuICAgIGVhZ2VyU3RhdGU6IG51bGwsXG4gICAgbmV4dDogbnVsbFxuICB9OyAvLyBBcHBlbmQgdGhlIHVwZGF0ZSB0byB0aGUgZW5kIG9mIHRoZSBsaXN0LlxuXG4gIHZhciBwZW5kaW5nID0gcXVldWUucGVuZGluZztcblxuICBpZiAocGVuZGluZyA9PT0gbnVsbCkge1xuICAgIC8vIFRoaXMgaXMgdGhlIGZpcnN0IHVwZGF0ZS4gQ3JlYXRlIGEgY2lyY3VsYXIgbGlzdC5cbiAgICB1cGRhdGUubmV4dCA9IHVwZGF0ZTtcbiAgfSBlbHNlIHtcbiAgICB1cGRhdGUubmV4dCA9IHBlbmRpbmcubmV4dDtcbiAgICBwZW5kaW5nLm5leHQgPSB1cGRhdGU7XG4gIH1cblxuICBxdWV1ZS5wZW5kaW5nID0gdXBkYXRlO1xuICB2YXIgYWx0ZXJuYXRlID0gZmliZXIuYWx0ZXJuYXRlO1xuXG4gIGlmIChmaWJlciA9PT0gY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMSB8fCBhbHRlcm5hdGUgIT09IG51bGwgJiYgYWx0ZXJuYXRlID09PSBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxKSB7XG4gICAgLy8gVGhpcyBpcyBhIHJlbmRlciBwaGFzZSB1cGRhdGUuIFN0YXNoIGl0IGluIGEgbGF6aWx5LWNyZWF0ZWQgbWFwIG9mXG4gICAgLy8gcXVldWUgLT4gbGlua2VkIGxpc3Qgb2YgdXBkYXRlcy4gQWZ0ZXIgdGhpcyByZW5kZXIgcGFzcywgd2UnbGwgcmVzdGFydFxuICAgIC8vIGFuZCBhcHBseSB0aGUgc3Rhc2hlZCB1cGRhdGVzIG9uIHRvcCBvZiB0aGUgd29yay1pbi1wcm9ncmVzcyBob29rLlxuICAgIGRpZFNjaGVkdWxlUmVuZGVyUGhhc2VVcGRhdGVEdXJpbmdUaGlzUGFzcyA9IGRpZFNjaGVkdWxlUmVuZGVyUGhhc2VVcGRhdGUgPSB0cnVlO1xuICB9IGVsc2Uge1xuICAgIGlmIChmaWJlci5sYW5lcyA9PT0gTm9MYW5lcyAmJiAoYWx0ZXJuYXRlID09PSBudWxsIHx8IGFsdGVybmF0ZS5sYW5lcyA9PT0gTm9MYW5lcykpIHtcbiAgICAgIC8vIFRoZSBxdWV1ZSBpcyBjdXJyZW50bHkgZW1wdHksIHdoaWNoIG1lYW5zIHdlIGNhbiBlYWdlcmx5IGNvbXB1dGUgdGhlXG4gICAgICAvLyBuZXh0IHN0YXRlIGJlZm9yZSBlbnRlcmluZyB0aGUgcmVuZGVyIHBoYXNlLiBJZiB0aGUgbmV3IHN0YXRlIGlzIHRoZVxuICAgICAgLy8gc2FtZSBhcyB0aGUgY3VycmVudCBzdGF0ZSwgd2UgbWF5IGJlIGFibGUgdG8gYmFpbCBvdXQgZW50aXJlbHkuXG4gICAgICB2YXIgbGFzdFJlbmRlcmVkUmVkdWNlciA9IHF1ZXVlLmxhc3RSZW5kZXJlZFJlZHVjZXI7XG5cbiAgICAgIGlmIChsYXN0UmVuZGVyZWRSZWR1Y2VyICE9PSBudWxsKSB7XG4gICAgICAgIHZhciBwcmV2RGlzcGF0Y2hlcjtcblxuICAgICAgICB7XG4gICAgICAgICAgcHJldkRpc3BhdGNoZXIgPSBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudDtcbiAgICAgICAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudCA9IEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPblVwZGF0ZUluREVWO1xuICAgICAgICB9XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB2YXIgY3VycmVudFN0YXRlID0gcXVldWUubGFzdFJlbmRlcmVkU3RhdGU7XG4gICAgICAgICAgdmFyIGVhZ2VyU3RhdGUgPSBsYXN0UmVuZGVyZWRSZWR1Y2VyKGN1cnJlbnRTdGF0ZSwgYWN0aW9uKTsgLy8gU3Rhc2ggdGhlIGVhZ2VybHkgY29tcHV0ZWQgc3RhdGUsIGFuZCB0aGUgcmVkdWNlciB1c2VkIHRvIGNvbXB1dGVcbiAgICAgICAgICAvLyBpdCwgb24gdGhlIHVwZGF0ZSBvYmplY3QuIElmIHRoZSByZWR1Y2VyIGhhc24ndCBjaGFuZ2VkIGJ5IHRoZVxuICAgICAgICAgIC8vIHRpbWUgd2UgZW50ZXIgdGhlIHJlbmRlciBwaGFzZSwgdGhlbiB0aGUgZWFnZXIgc3RhdGUgY2FuIGJlIHVzZWRcbiAgICAgICAgICAvLyB3aXRob3V0IGNhbGxpbmcgdGhlIHJlZHVjZXIgYWdhaW4uXG5cbiAgICAgICAgICB1cGRhdGUuZWFnZXJSZWR1Y2VyID0gbGFzdFJlbmRlcmVkUmVkdWNlcjtcbiAgICAgICAgICB1cGRhdGUuZWFnZXJTdGF0ZSA9IGVhZ2VyU3RhdGU7XG5cbiAgICAgICAgICBpZiAob2JqZWN0SXMoZWFnZXJTdGF0ZSwgY3VycmVudFN0YXRlKSkge1xuICAgICAgICAgICAgLy8gRmFzdCBwYXRoLiBXZSBjYW4gYmFpbCBvdXQgd2l0aG91dCBzY2hlZHVsaW5nIFJlYWN0IHRvIHJlLXJlbmRlci5cbiAgICAgICAgICAgIC8vIEl0J3Mgc3RpbGwgcG9zc2libGUgdGhhdCB3ZSdsbCBuZWVkIHRvIHJlYmFzZSB0aGlzIHVwZGF0ZSBsYXRlcixcbiAgICAgICAgICAgIC8vIGlmIHRoZSBjb21wb25lbnQgcmUtcmVuZGVycyBmb3IgYSBkaWZmZXJlbnQgcmVhc29uIGFuZCBieSB0aGF0XG4gICAgICAgICAgICAvLyB0aW1lIHRoZSByZWR1Y2VyIGhhcyBjaGFuZ2VkLlxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHsvLyBTdXBwcmVzcyB0aGUgZXJyb3IuIEl0IHdpbGwgdGhyb3cgYWdhaW4gaW4gdGhlIHJlbmRlciBwaGFzZS5cbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICB7XG4gICAgICAgICAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudCA9IHByZXZEaXNwYXRjaGVyO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHtcbiAgICAgIC8vICRGbG93RXhwZWN0ZWRFcnJvciAtIGplc3QgaXNuJ3QgYSBnbG9iYWwsIGFuZCBpc24ndCByZWNvZ25pemVkIG91dHNpZGUgb2YgdGVzdHNcbiAgICAgIGlmICgndW5kZWZpbmVkJyAhPT0gdHlwZW9mIGplc3QpIHtcbiAgICAgICAgd2FybklmTm90U2NvcGVkV2l0aE1hdGNoaW5nQWN0KGZpYmVyKTtcbiAgICAgICAgd2FybklmTm90Q3VycmVudGx5QWN0aW5nVXBkYXRlc0luRGV2KGZpYmVyKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBzY2hlZHVsZVVwZGF0ZU9uRmliZXIoZmliZXIsIGxhbmUsIGV2ZW50VGltZSk7XG4gIH1cbn1cblxudmFyIENvbnRleHRPbmx5RGlzcGF0Y2hlciA9IHtcbiAgcmVhZENvbnRleHQ6IHJlYWRDb250ZXh0LFxuICB1c2VDYWxsYmFjazogdGhyb3dJbnZhbGlkSG9va0Vycm9yLFxuICB1c2VDb250ZXh0OiB0aHJvd0ludmFsaWRIb29rRXJyb3IsXG4gIHVzZUVmZmVjdDogdGhyb3dJbnZhbGlkSG9va0Vycm9yLFxuICB1c2VJbXBlcmF0aXZlSGFuZGxlOiB0aHJvd0ludmFsaWRIb29rRXJyb3IsXG4gIHVzZUxheW91dEVmZmVjdDogdGhyb3dJbnZhbGlkSG9va0Vycm9yLFxuICB1c2VNZW1vOiB0aHJvd0ludmFsaWRIb29rRXJyb3IsXG4gIHVzZVJlZHVjZXI6IHRocm93SW52YWxpZEhvb2tFcnJvcixcbiAgdXNlUmVmOiB0aHJvd0ludmFsaWRIb29rRXJyb3IsXG4gIHVzZVN0YXRlOiB0aHJvd0ludmFsaWRIb29rRXJyb3IsXG4gIHVzZURlYnVnVmFsdWU6IHRocm93SW52YWxpZEhvb2tFcnJvcixcbiAgdXNlRGVmZXJyZWRWYWx1ZTogdGhyb3dJbnZhbGlkSG9va0Vycm9yLFxuICB1c2VUcmFuc2l0aW9uOiB0aHJvd0ludmFsaWRIb29rRXJyb3IsXG4gIHVzZU11dGFibGVTb3VyY2U6IHRocm93SW52YWxpZEhvb2tFcnJvcixcbiAgdXNlT3BhcXVlSWRlbnRpZmllcjogdGhyb3dJbnZhbGlkSG9va0Vycm9yLFxuICB1bnN0YWJsZV9pc05ld1JlY29uY2lsZXI6IGVuYWJsZU5ld1JlY29uY2lsZXJcbn07XG52YXIgSG9va3NEaXNwYXRjaGVyT25Nb3VudEluREVWID0gbnVsbDtcbnZhciBIb29rc0Rpc3BhdGNoZXJPbk1vdW50V2l0aEhvb2tUeXBlc0luREVWID0gbnVsbDtcbnZhciBIb29rc0Rpc3BhdGNoZXJPblVwZGF0ZUluREVWID0gbnVsbDtcbnZhciBIb29rc0Rpc3BhdGNoZXJPblJlcmVuZGVySW5ERVYgPSBudWxsO1xudmFyIEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPbk1vdW50SW5ERVYgPSBudWxsO1xudmFyIEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPblVwZGF0ZUluREVWID0gbnVsbDtcbnZhciBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25SZXJlbmRlckluREVWID0gbnVsbDtcblxue1xuICB2YXIgd2FybkludmFsaWRDb250ZXh0QWNjZXNzID0gZnVuY3Rpb24gKCkge1xuICAgIGVycm9yKCdDb250ZXh0IGNhbiBvbmx5IGJlIHJlYWQgd2hpbGUgUmVhY3QgaXMgcmVuZGVyaW5nLiAnICsgJ0luIGNsYXNzZXMsIHlvdSBjYW4gcmVhZCBpdCBpbiB0aGUgcmVuZGVyIG1ldGhvZCBvciBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMuICcgKyAnSW4gZnVuY3Rpb24gY29tcG9uZW50cywgeW91IGNhbiByZWFkIGl0IGRpcmVjdGx5IGluIHRoZSBmdW5jdGlvbiBib2R5LCBidXQgbm90ICcgKyAnaW5zaWRlIEhvb2tzIGxpa2UgdXNlUmVkdWNlcigpIG9yIHVzZU1lbW8oKS4nKTtcbiAgfTtcblxuICB2YXIgd2FybkludmFsaWRIb29rQWNjZXNzID0gZnVuY3Rpb24gKCkge1xuICAgIGVycm9yKCdEbyBub3QgY2FsbCBIb29rcyBpbnNpZGUgdXNlRWZmZWN0KC4uLiksIHVzZU1lbW8oLi4uKSwgb3Igb3RoZXIgYnVpbHQtaW4gSG9va3MuICcgKyAnWW91IGNhbiBvbmx5IGNhbGwgSG9va3MgYXQgdGhlIHRvcCBsZXZlbCBvZiB5b3VyIFJlYWN0IGZ1bmN0aW9uLiAnICsgJ0ZvciBtb3JlIGluZm9ybWF0aW9uLCBzZWUgJyArICdodHRwczovL3JlYWN0anMub3JnL2xpbmsvcnVsZXMtb2YtaG9va3MnKTtcbiAgfTtcblxuICBIb29rc0Rpc3BhdGNoZXJPbk1vdW50SW5ERVYgPSB7XG4gICAgcmVhZENvbnRleHQ6IGZ1bmN0aW9uIChjb250ZXh0LCBvYnNlcnZlZEJpdHMpIHtcbiAgICAgIHJldHVybiByZWFkQ29udGV4dChjb250ZXh0LCBvYnNlcnZlZEJpdHMpO1xuICAgIH0sXG4gICAgdXNlQ2FsbGJhY2s6IGZ1bmN0aW9uIChjYWxsYmFjaywgZGVwcykge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlQ2FsbGJhY2snO1xuICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgIGNoZWNrRGVwc0FyZUFycmF5RGV2KGRlcHMpO1xuICAgICAgcmV0dXJuIG1vdW50Q2FsbGJhY2soY2FsbGJhY2ssIGRlcHMpO1xuICAgIH0sXG4gICAgdXNlQ29udGV4dDogZnVuY3Rpb24gKGNvbnRleHQsIG9ic2VydmVkQml0cykge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlQ29udGV4dCc7XG4gICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHJlYWRDb250ZXh0KGNvbnRleHQsIG9ic2VydmVkQml0cyk7XG4gICAgfSxcbiAgICB1c2VFZmZlY3Q6IGZ1bmN0aW9uIChjcmVhdGUsIGRlcHMpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUVmZmVjdCc7XG4gICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgY2hlY2tEZXBzQXJlQXJyYXlEZXYoZGVwcyk7XG4gICAgICByZXR1cm4gbW91bnRFZmZlY3QoY3JlYXRlLCBkZXBzKTtcbiAgICB9LFxuICAgIHVzZUltcGVyYXRpdmVIYW5kbGU6IGZ1bmN0aW9uIChyZWYsIGNyZWF0ZSwgZGVwcykge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlSW1wZXJhdGl2ZUhhbmRsZSc7XG4gICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgY2hlY2tEZXBzQXJlQXJyYXlEZXYoZGVwcyk7XG4gICAgICByZXR1cm4gbW91bnRJbXBlcmF0aXZlSGFuZGxlKHJlZiwgY3JlYXRlLCBkZXBzKTtcbiAgICB9LFxuICAgIHVzZUxheW91dEVmZmVjdDogZnVuY3Rpb24gKGNyZWF0ZSwgZGVwcykge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlTGF5b3V0RWZmZWN0JztcbiAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICBjaGVja0RlcHNBcmVBcnJheURldihkZXBzKTtcbiAgICAgIHJldHVybiBtb3VudExheW91dEVmZmVjdChjcmVhdGUsIGRlcHMpO1xuICAgIH0sXG4gICAgdXNlTWVtbzogZnVuY3Rpb24gKGNyZWF0ZSwgZGVwcykge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlTWVtbyc7XG4gICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgY2hlY2tEZXBzQXJlQXJyYXlEZXYoZGVwcyk7XG4gICAgICB2YXIgcHJldkRpc3BhdGNoZXIgPSBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudDtcbiAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50ID0gSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uTW91bnRJbkRFVjtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIG1vdW50TWVtbyhjcmVhdGUsIGRlcHMpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQgPSBwcmV2RGlzcGF0Y2hlcjtcbiAgICAgIH1cbiAgICB9LFxuICAgIHVzZVJlZHVjZXI6IGZ1bmN0aW9uIChyZWR1Y2VyLCBpbml0aWFsQXJnLCBpbml0KSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VSZWR1Y2VyJztcbiAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICB2YXIgcHJldkRpc3BhdGNoZXIgPSBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudDtcbiAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50ID0gSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uTW91bnRJbkRFVjtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIG1vdW50UmVkdWNlcihyZWR1Y2VyLCBpbml0aWFsQXJnLCBpbml0KTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50ID0gcHJldkRpc3BhdGNoZXI7XG4gICAgICB9XG4gICAgfSxcbiAgICB1c2VSZWY6IGZ1bmN0aW9uIChpbml0aWFsVmFsdWUpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZVJlZic7XG4gICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIG1vdW50UmVmKGluaXRpYWxWYWx1ZSk7XG4gICAgfSxcbiAgICB1c2VTdGF0ZTogZnVuY3Rpb24gKGluaXRpYWxTdGF0ZSkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlU3RhdGUnO1xuICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgIHZhciBwcmV2RGlzcGF0Y2hlciA9IFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50O1xuICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQgPSBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25Nb3VudEluREVWO1xuXG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gbW91bnRTdGF0ZShpbml0aWFsU3RhdGUpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQgPSBwcmV2RGlzcGF0Y2hlcjtcbiAgICAgIH1cbiAgICB9LFxuICAgIHVzZURlYnVnVmFsdWU6IGZ1bmN0aW9uICh2YWx1ZSwgZm9ybWF0dGVyRm4pIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZURlYnVnVmFsdWUnO1xuICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiBtb3VudERlYnVnVmFsdWUoKTtcbiAgICB9LFxuICAgIHVzZURlZmVycmVkVmFsdWU6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlRGVmZXJyZWRWYWx1ZSc7XG4gICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIG1vdW50RGVmZXJyZWRWYWx1ZSh2YWx1ZSk7XG4gICAgfSxcbiAgICB1c2VUcmFuc2l0aW9uOiBmdW5jdGlvbiAoKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VUcmFuc2l0aW9uJztcbiAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gbW91bnRUcmFuc2l0aW9uKCk7XG4gICAgfSxcbiAgICB1c2VNdXRhYmxlU291cmNlOiBmdW5jdGlvbiAoc291cmNlLCBnZXRTbmFwc2hvdCwgc3Vic2NyaWJlKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VNdXRhYmxlU291cmNlJztcbiAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gbW91bnRNdXRhYmxlU291cmNlKHNvdXJjZSwgZ2V0U25hcHNob3QsIHN1YnNjcmliZSk7XG4gICAgfSxcbiAgICB1c2VPcGFxdWVJZGVudGlmaWVyOiBmdW5jdGlvbiAoKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VPcGFxdWVJZGVudGlmaWVyJztcbiAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gbW91bnRPcGFxdWVJZGVudGlmaWVyKCk7XG4gICAgfSxcbiAgICB1bnN0YWJsZV9pc05ld1JlY29uY2lsZXI6IGVuYWJsZU5ld1JlY29uY2lsZXJcbiAgfTtcbiAgSG9va3NEaXNwYXRjaGVyT25Nb3VudFdpdGhIb29rVHlwZXNJbkRFViA9IHtcbiAgICByZWFkQ29udGV4dDogZnVuY3Rpb24gKGNvbnRleHQsIG9ic2VydmVkQml0cykge1xuICAgICAgcmV0dXJuIHJlYWRDb250ZXh0KGNvbnRleHQsIG9ic2VydmVkQml0cyk7XG4gICAgfSxcbiAgICB1c2VDYWxsYmFjazogZnVuY3Rpb24gKGNhbGxiYWNrLCBkZXBzKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VDYWxsYmFjayc7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiBtb3VudENhbGxiYWNrKGNhbGxiYWNrLCBkZXBzKTtcbiAgICB9LFxuICAgIHVzZUNvbnRleHQ6IGZ1bmN0aW9uIChjb250ZXh0LCBvYnNlcnZlZEJpdHMpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUNvbnRleHQnO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gcmVhZENvbnRleHQoY29udGV4dCwgb2JzZXJ2ZWRCaXRzKTtcbiAgICB9LFxuICAgIHVzZUVmZmVjdDogZnVuY3Rpb24gKGNyZWF0ZSwgZGVwcykge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlRWZmZWN0JztcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIG1vdW50RWZmZWN0KGNyZWF0ZSwgZGVwcyk7XG4gICAgfSxcbiAgICB1c2VJbXBlcmF0aXZlSGFuZGxlOiBmdW5jdGlvbiAocmVmLCBjcmVhdGUsIGRlcHMpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUltcGVyYXRpdmVIYW5kbGUnO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gbW91bnRJbXBlcmF0aXZlSGFuZGxlKHJlZiwgY3JlYXRlLCBkZXBzKTtcbiAgICB9LFxuICAgIHVzZUxheW91dEVmZmVjdDogZnVuY3Rpb24gKGNyZWF0ZSwgZGVwcykge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlTGF5b3V0RWZmZWN0JztcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIG1vdW50TGF5b3V0RWZmZWN0KGNyZWF0ZSwgZGVwcyk7XG4gICAgfSxcbiAgICB1c2VNZW1vOiBmdW5jdGlvbiAoY3JlYXRlLCBkZXBzKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VNZW1vJztcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgdmFyIHByZXZEaXNwYXRjaGVyID0gUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQ7XG4gICAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudCA9IEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPbk1vdW50SW5ERVY7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBtb3VudE1lbW8oY3JlYXRlLCBkZXBzKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50ID0gcHJldkRpc3BhdGNoZXI7XG4gICAgICB9XG4gICAgfSxcbiAgICB1c2VSZWR1Y2VyOiBmdW5jdGlvbiAocmVkdWNlciwgaW5pdGlhbEFyZywgaW5pdCkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlUmVkdWNlcic7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHZhciBwcmV2RGlzcGF0Y2hlciA9IFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50O1xuICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQgPSBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25Nb3VudEluREVWO1xuXG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gbW91bnRSZWR1Y2VyKHJlZHVjZXIsIGluaXRpYWxBcmcsIGluaXQpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQgPSBwcmV2RGlzcGF0Y2hlcjtcbiAgICAgIH1cbiAgICB9LFxuICAgIHVzZVJlZjogZnVuY3Rpb24gKGluaXRpYWxWYWx1ZSkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlUmVmJztcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIG1vdW50UmVmKGluaXRpYWxWYWx1ZSk7XG4gICAgfSxcbiAgICB1c2VTdGF0ZTogZnVuY3Rpb24gKGluaXRpYWxTdGF0ZSkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlU3RhdGUnO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICB2YXIgcHJldkRpc3BhdGNoZXIgPSBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudDtcbiAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50ID0gSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uTW91bnRJbkRFVjtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIG1vdW50U3RhdGUoaW5pdGlhbFN0YXRlKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50ID0gcHJldkRpc3BhdGNoZXI7XG4gICAgICB9XG4gICAgfSxcbiAgICB1c2VEZWJ1Z1ZhbHVlOiBmdW5jdGlvbiAodmFsdWUsIGZvcm1hdHRlckZuKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VEZWJ1Z1ZhbHVlJztcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIG1vdW50RGVidWdWYWx1ZSgpO1xuICAgIH0sXG4gICAgdXNlRGVmZXJyZWRWYWx1ZTogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VEZWZlcnJlZFZhbHVlJztcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIG1vdW50RGVmZXJyZWRWYWx1ZSh2YWx1ZSk7XG4gICAgfSxcbiAgICB1c2VUcmFuc2l0aW9uOiBmdW5jdGlvbiAoKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VUcmFuc2l0aW9uJztcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIG1vdW50VHJhbnNpdGlvbigpO1xuICAgIH0sXG4gICAgdXNlTXV0YWJsZVNvdXJjZTogZnVuY3Rpb24gKHNvdXJjZSwgZ2V0U25hcHNob3QsIHN1YnNjcmliZSkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlTXV0YWJsZVNvdXJjZSc7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiBtb3VudE11dGFibGVTb3VyY2Uoc291cmNlLCBnZXRTbmFwc2hvdCwgc3Vic2NyaWJlKTtcbiAgICB9LFxuICAgIHVzZU9wYXF1ZUlkZW50aWZpZXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZU9wYXF1ZUlkZW50aWZpZXInO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gbW91bnRPcGFxdWVJZGVudGlmaWVyKCk7XG4gICAgfSxcbiAgICB1bnN0YWJsZV9pc05ld1JlY29uY2lsZXI6IGVuYWJsZU5ld1JlY29uY2lsZXJcbiAgfTtcbiAgSG9va3NEaXNwYXRjaGVyT25VcGRhdGVJbkRFViA9IHtcbiAgICByZWFkQ29udGV4dDogZnVuY3Rpb24gKGNvbnRleHQsIG9ic2VydmVkQml0cykge1xuICAgICAgcmV0dXJuIHJlYWRDb250ZXh0KGNvbnRleHQsIG9ic2VydmVkQml0cyk7XG4gICAgfSxcbiAgICB1c2VDYWxsYmFjazogZnVuY3Rpb24gKGNhbGxiYWNrLCBkZXBzKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VDYWxsYmFjayc7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiB1cGRhdGVDYWxsYmFjayhjYWxsYmFjaywgZGVwcyk7XG4gICAgfSxcbiAgICB1c2VDb250ZXh0OiBmdW5jdGlvbiAoY29udGV4dCwgb2JzZXJ2ZWRCaXRzKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VDb250ZXh0JztcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHJlYWRDb250ZXh0KGNvbnRleHQsIG9ic2VydmVkQml0cyk7XG4gICAgfSxcbiAgICB1c2VFZmZlY3Q6IGZ1bmN0aW9uIChjcmVhdGUsIGRlcHMpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUVmZmVjdCc7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiB1cGRhdGVFZmZlY3QoY3JlYXRlLCBkZXBzKTtcbiAgICB9LFxuICAgIHVzZUltcGVyYXRpdmVIYW5kbGU6IGZ1bmN0aW9uIChyZWYsIGNyZWF0ZSwgZGVwcykge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlSW1wZXJhdGl2ZUhhbmRsZSc7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiB1cGRhdGVJbXBlcmF0aXZlSGFuZGxlKHJlZiwgY3JlYXRlLCBkZXBzKTtcbiAgICB9LFxuICAgIHVzZUxheW91dEVmZmVjdDogZnVuY3Rpb24gKGNyZWF0ZSwgZGVwcykge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlTGF5b3V0RWZmZWN0JztcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHVwZGF0ZUxheW91dEVmZmVjdChjcmVhdGUsIGRlcHMpO1xuICAgIH0sXG4gICAgdXNlTWVtbzogZnVuY3Rpb24gKGNyZWF0ZSwgZGVwcykge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlTWVtbyc7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHZhciBwcmV2RGlzcGF0Y2hlciA9IFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50O1xuICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQgPSBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25VcGRhdGVJbkRFVjtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIHVwZGF0ZU1lbW8oY3JlYXRlLCBkZXBzKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50ID0gcHJldkRpc3BhdGNoZXI7XG4gICAgICB9XG4gICAgfSxcbiAgICB1c2VSZWR1Y2VyOiBmdW5jdGlvbiAocmVkdWNlciwgaW5pdGlhbEFyZywgaW5pdCkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlUmVkdWNlcic7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHZhciBwcmV2RGlzcGF0Y2hlciA9IFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50O1xuICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQgPSBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25VcGRhdGVJbkRFVjtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIHVwZGF0ZVJlZHVjZXIocmVkdWNlciwgaW5pdGlhbEFyZywgaW5pdCk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudCA9IHByZXZEaXNwYXRjaGVyO1xuICAgICAgfVxuICAgIH0sXG4gICAgdXNlUmVmOiBmdW5jdGlvbiAoaW5pdGlhbFZhbHVlKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VSZWYnO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gdXBkYXRlUmVmKCk7XG4gICAgfSxcbiAgICB1c2VTdGF0ZTogZnVuY3Rpb24gKGluaXRpYWxTdGF0ZSkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlU3RhdGUnO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICB2YXIgcHJldkRpc3BhdGNoZXIgPSBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudDtcbiAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50ID0gSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uVXBkYXRlSW5ERVY7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiB1cGRhdGVTdGF0ZShpbml0aWFsU3RhdGUpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQgPSBwcmV2RGlzcGF0Y2hlcjtcbiAgICAgIH1cbiAgICB9LFxuICAgIHVzZURlYnVnVmFsdWU6IGZ1bmN0aW9uICh2YWx1ZSwgZm9ybWF0dGVyRm4pIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZURlYnVnVmFsdWUnO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gdXBkYXRlRGVidWdWYWx1ZSgpO1xuICAgIH0sXG4gICAgdXNlRGVmZXJyZWRWYWx1ZTogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VEZWZlcnJlZFZhbHVlJztcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHVwZGF0ZURlZmVycmVkVmFsdWUodmFsdWUpO1xuICAgIH0sXG4gICAgdXNlVHJhbnNpdGlvbjogZnVuY3Rpb24gKCkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlVHJhbnNpdGlvbic7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiB1cGRhdGVUcmFuc2l0aW9uKCk7XG4gICAgfSxcbiAgICB1c2VNdXRhYmxlU291cmNlOiBmdW5jdGlvbiAoc291cmNlLCBnZXRTbmFwc2hvdCwgc3Vic2NyaWJlKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VNdXRhYmxlU291cmNlJztcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHVwZGF0ZU11dGFibGVTb3VyY2Uoc291cmNlLCBnZXRTbmFwc2hvdCwgc3Vic2NyaWJlKTtcbiAgICB9LFxuICAgIHVzZU9wYXF1ZUlkZW50aWZpZXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZU9wYXF1ZUlkZW50aWZpZXInO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gdXBkYXRlT3BhcXVlSWRlbnRpZmllcigpO1xuICAgIH0sXG4gICAgdW5zdGFibGVfaXNOZXdSZWNvbmNpbGVyOiBlbmFibGVOZXdSZWNvbmNpbGVyXG4gIH07XG4gIEhvb2tzRGlzcGF0Y2hlck9uUmVyZW5kZXJJbkRFViA9IHtcbiAgICByZWFkQ29udGV4dDogZnVuY3Rpb24gKGNvbnRleHQsIG9ic2VydmVkQml0cykge1xuICAgICAgcmV0dXJuIHJlYWRDb250ZXh0KGNvbnRleHQsIG9ic2VydmVkQml0cyk7XG4gICAgfSxcbiAgICB1c2VDYWxsYmFjazogZnVuY3Rpb24gKGNhbGxiYWNrLCBkZXBzKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VDYWxsYmFjayc7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiB1cGRhdGVDYWxsYmFjayhjYWxsYmFjaywgZGVwcyk7XG4gICAgfSxcbiAgICB1c2VDb250ZXh0OiBmdW5jdGlvbiAoY29udGV4dCwgb2JzZXJ2ZWRCaXRzKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VDb250ZXh0JztcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHJlYWRDb250ZXh0KGNvbnRleHQsIG9ic2VydmVkQml0cyk7XG4gICAgfSxcbiAgICB1c2VFZmZlY3Q6IGZ1bmN0aW9uIChjcmVhdGUsIGRlcHMpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUVmZmVjdCc7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiB1cGRhdGVFZmZlY3QoY3JlYXRlLCBkZXBzKTtcbiAgICB9LFxuICAgIHVzZUltcGVyYXRpdmVIYW5kbGU6IGZ1bmN0aW9uIChyZWYsIGNyZWF0ZSwgZGVwcykge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlSW1wZXJhdGl2ZUhhbmRsZSc7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiB1cGRhdGVJbXBlcmF0aXZlSGFuZGxlKHJlZiwgY3JlYXRlLCBkZXBzKTtcbiAgICB9LFxuICAgIHVzZUxheW91dEVmZmVjdDogZnVuY3Rpb24gKGNyZWF0ZSwgZGVwcykge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlTGF5b3V0RWZmZWN0JztcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHVwZGF0ZUxheW91dEVmZmVjdChjcmVhdGUsIGRlcHMpO1xuICAgIH0sXG4gICAgdXNlTWVtbzogZnVuY3Rpb24gKGNyZWF0ZSwgZGVwcykge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlTWVtbyc7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHZhciBwcmV2RGlzcGF0Y2hlciA9IFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50O1xuICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQgPSBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25SZXJlbmRlckluREVWO1xuXG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gdXBkYXRlTWVtbyhjcmVhdGUsIGRlcHMpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQgPSBwcmV2RGlzcGF0Y2hlcjtcbiAgICAgIH1cbiAgICB9LFxuICAgIHVzZVJlZHVjZXI6IGZ1bmN0aW9uIChyZWR1Y2VyLCBpbml0aWFsQXJnLCBpbml0KSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VSZWR1Y2VyJztcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgdmFyIHByZXZEaXNwYXRjaGVyID0gUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQ7XG4gICAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudCA9IEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPblJlcmVuZGVySW5ERVY7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiByZXJlbmRlclJlZHVjZXIocmVkdWNlciwgaW5pdGlhbEFyZywgaW5pdCk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudCA9IHByZXZEaXNwYXRjaGVyO1xuICAgICAgfVxuICAgIH0sXG4gICAgdXNlUmVmOiBmdW5jdGlvbiAoaW5pdGlhbFZhbHVlKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VSZWYnO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gdXBkYXRlUmVmKCk7XG4gICAgfSxcbiAgICB1c2VTdGF0ZTogZnVuY3Rpb24gKGluaXRpYWxTdGF0ZSkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlU3RhdGUnO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICB2YXIgcHJldkRpc3BhdGNoZXIgPSBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudDtcbiAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50ID0gSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uUmVyZW5kZXJJbkRFVjtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIHJlcmVuZGVyU3RhdGUoaW5pdGlhbFN0YXRlKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50ID0gcHJldkRpc3BhdGNoZXI7XG4gICAgICB9XG4gICAgfSxcbiAgICB1c2VEZWJ1Z1ZhbHVlOiBmdW5jdGlvbiAodmFsdWUsIGZvcm1hdHRlckZuKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VEZWJ1Z1ZhbHVlJztcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHVwZGF0ZURlYnVnVmFsdWUoKTtcbiAgICB9LFxuICAgIHVzZURlZmVycmVkVmFsdWU6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlRGVmZXJyZWRWYWx1ZSc7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiByZXJlbmRlckRlZmVycmVkVmFsdWUodmFsdWUpO1xuICAgIH0sXG4gICAgdXNlVHJhbnNpdGlvbjogZnVuY3Rpb24gKCkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlVHJhbnNpdGlvbic7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiByZXJlbmRlclRyYW5zaXRpb24oKTtcbiAgICB9LFxuICAgIHVzZU11dGFibGVTb3VyY2U6IGZ1bmN0aW9uIChzb3VyY2UsIGdldFNuYXBzaG90LCBzdWJzY3JpYmUpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZU11dGFibGVTb3VyY2UnO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gdXBkYXRlTXV0YWJsZVNvdXJjZShzb3VyY2UsIGdldFNuYXBzaG90LCBzdWJzY3JpYmUpO1xuICAgIH0sXG4gICAgdXNlT3BhcXVlSWRlbnRpZmllcjogZnVuY3Rpb24gKCkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlT3BhcXVlSWRlbnRpZmllcic7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiByZXJlbmRlck9wYXF1ZUlkZW50aWZpZXIoKTtcbiAgICB9LFxuICAgIHVuc3RhYmxlX2lzTmV3UmVjb25jaWxlcjogZW5hYmxlTmV3UmVjb25jaWxlclxuICB9O1xuICBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25Nb3VudEluREVWID0ge1xuICAgIHJlYWRDb250ZXh0OiBmdW5jdGlvbiAoY29udGV4dCwgb2JzZXJ2ZWRCaXRzKSB7XG4gICAgICB3YXJuSW52YWxpZENvbnRleHRBY2Nlc3MoKTtcbiAgICAgIHJldHVybiByZWFkQ29udGV4dChjb250ZXh0LCBvYnNlcnZlZEJpdHMpO1xuICAgIH0sXG4gICAgdXNlQ2FsbGJhY2s6IGZ1bmN0aW9uIChjYWxsYmFjaywgZGVwcykge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlQ2FsbGJhY2snO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIG1vdW50Q2FsbGJhY2soY2FsbGJhY2ssIGRlcHMpO1xuICAgIH0sXG4gICAgdXNlQ29udGV4dDogZnVuY3Rpb24gKGNvbnRleHQsIG9ic2VydmVkQml0cykge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlQ29udGV4dCc7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gcmVhZENvbnRleHQoY29udGV4dCwgb2JzZXJ2ZWRCaXRzKTtcbiAgICB9LFxuICAgIHVzZUVmZmVjdDogZnVuY3Rpb24gKGNyZWF0ZSwgZGVwcykge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlRWZmZWN0JztcbiAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiBtb3VudEVmZmVjdChjcmVhdGUsIGRlcHMpO1xuICAgIH0sXG4gICAgdXNlSW1wZXJhdGl2ZUhhbmRsZTogZnVuY3Rpb24gKHJlZiwgY3JlYXRlLCBkZXBzKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VJbXBlcmF0aXZlSGFuZGxlJztcbiAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiBtb3VudEltcGVyYXRpdmVIYW5kbGUocmVmLCBjcmVhdGUsIGRlcHMpO1xuICAgIH0sXG4gICAgdXNlTGF5b3V0RWZmZWN0OiBmdW5jdGlvbiAoY3JlYXRlLCBkZXBzKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VMYXlvdXRFZmZlY3QnO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIG1vdW50TGF5b3V0RWZmZWN0KGNyZWF0ZSwgZGVwcyk7XG4gICAgfSxcbiAgICB1c2VNZW1vOiBmdW5jdGlvbiAoY3JlYXRlLCBkZXBzKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VNZW1vJztcbiAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgIHZhciBwcmV2RGlzcGF0Y2hlciA9IFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50O1xuICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQgPSBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25Nb3VudEluREVWO1xuXG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gbW91bnRNZW1vKGNyZWF0ZSwgZGVwcyk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudCA9IHByZXZEaXNwYXRjaGVyO1xuICAgICAgfVxuICAgIH0sXG4gICAgdXNlUmVkdWNlcjogZnVuY3Rpb24gKHJlZHVjZXIsIGluaXRpYWxBcmcsIGluaXQpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZVJlZHVjZXInO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgdmFyIHByZXZEaXNwYXRjaGVyID0gUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQ7XG4gICAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudCA9IEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPbk1vdW50SW5ERVY7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBtb3VudFJlZHVjZXIocmVkdWNlciwgaW5pdGlhbEFyZywgaW5pdCk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudCA9IHByZXZEaXNwYXRjaGVyO1xuICAgICAgfVxuICAgIH0sXG4gICAgdXNlUmVmOiBmdW5jdGlvbiAoaW5pdGlhbFZhbHVlKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VSZWYnO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIG1vdW50UmVmKGluaXRpYWxWYWx1ZSk7XG4gICAgfSxcbiAgICB1c2VTdGF0ZTogZnVuY3Rpb24gKGluaXRpYWxTdGF0ZSkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlU3RhdGUnO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgdmFyIHByZXZEaXNwYXRjaGVyID0gUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQ7XG4gICAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudCA9IEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPbk1vdW50SW5ERVY7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBtb3VudFN0YXRlKGluaXRpYWxTdGF0ZSk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudCA9IHByZXZEaXNwYXRjaGVyO1xuICAgICAgfVxuICAgIH0sXG4gICAgdXNlRGVidWdWYWx1ZTogZnVuY3Rpb24gKHZhbHVlLCBmb3JtYXR0ZXJGbikge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlRGVidWdWYWx1ZSc7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gbW91bnREZWJ1Z1ZhbHVlKCk7XG4gICAgfSxcbiAgICB1c2VEZWZlcnJlZFZhbHVlOiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZURlZmVycmVkVmFsdWUnO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIG1vdW50RGVmZXJyZWRWYWx1ZSh2YWx1ZSk7XG4gICAgfSxcbiAgICB1c2VUcmFuc2l0aW9uOiBmdW5jdGlvbiAoKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VUcmFuc2l0aW9uJztcbiAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiBtb3VudFRyYW5zaXRpb24oKTtcbiAgICB9LFxuICAgIHVzZU11dGFibGVTb3VyY2U6IGZ1bmN0aW9uIChzb3VyY2UsIGdldFNuYXBzaG90LCBzdWJzY3JpYmUpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZU11dGFibGVTb3VyY2UnO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIG1vdW50TXV0YWJsZVNvdXJjZShzb3VyY2UsIGdldFNuYXBzaG90LCBzdWJzY3JpYmUpO1xuICAgIH0sXG4gICAgdXNlT3BhcXVlSWRlbnRpZmllcjogZnVuY3Rpb24gKCkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlT3BhcXVlSWRlbnRpZmllcic7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gbW91bnRPcGFxdWVJZGVudGlmaWVyKCk7XG4gICAgfSxcbiAgICB1bnN0YWJsZV9pc05ld1JlY29uY2lsZXI6IGVuYWJsZU5ld1JlY29uY2lsZXJcbiAgfTtcbiAgSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uVXBkYXRlSW5ERVYgPSB7XG4gICAgcmVhZENvbnRleHQ6IGZ1bmN0aW9uIChjb250ZXh0LCBvYnNlcnZlZEJpdHMpIHtcbiAgICAgIHdhcm5JbnZhbGlkQ29udGV4dEFjY2VzcygpO1xuICAgICAgcmV0dXJuIHJlYWRDb250ZXh0KGNvbnRleHQsIG9ic2VydmVkQml0cyk7XG4gICAgfSxcbiAgICB1c2VDYWxsYmFjazogZnVuY3Rpb24gKGNhbGxiYWNrLCBkZXBzKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VDYWxsYmFjayc7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHVwZGF0ZUNhbGxiYWNrKGNhbGxiYWNrLCBkZXBzKTtcbiAgICB9LFxuICAgIHVzZUNvbnRleHQ6IGZ1bmN0aW9uIChjb250ZXh0LCBvYnNlcnZlZEJpdHMpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUNvbnRleHQnO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiByZWFkQ29udGV4dChjb250ZXh0LCBvYnNlcnZlZEJpdHMpO1xuICAgIH0sXG4gICAgdXNlRWZmZWN0OiBmdW5jdGlvbiAoY3JlYXRlLCBkZXBzKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VFZmZlY3QnO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiB1cGRhdGVFZmZlY3QoY3JlYXRlLCBkZXBzKTtcbiAgICB9LFxuICAgIHVzZUltcGVyYXRpdmVIYW5kbGU6IGZ1bmN0aW9uIChyZWYsIGNyZWF0ZSwgZGVwcykge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlSW1wZXJhdGl2ZUhhbmRsZSc7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHVwZGF0ZUltcGVyYXRpdmVIYW5kbGUocmVmLCBjcmVhdGUsIGRlcHMpO1xuICAgIH0sXG4gICAgdXNlTGF5b3V0RWZmZWN0OiBmdW5jdGlvbiAoY3JlYXRlLCBkZXBzKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VMYXlvdXRFZmZlY3QnO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiB1cGRhdGVMYXlvdXRFZmZlY3QoY3JlYXRlLCBkZXBzKTtcbiAgICB9LFxuICAgIHVzZU1lbW86IGZ1bmN0aW9uIChjcmVhdGUsIGRlcHMpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZU1lbW8nO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHZhciBwcmV2RGlzcGF0Y2hlciA9IFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50O1xuICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQgPSBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25VcGRhdGVJbkRFVjtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIHVwZGF0ZU1lbW8oY3JlYXRlLCBkZXBzKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50ID0gcHJldkRpc3BhdGNoZXI7XG4gICAgICB9XG4gICAgfSxcbiAgICB1c2VSZWR1Y2VyOiBmdW5jdGlvbiAocmVkdWNlciwgaW5pdGlhbEFyZywgaW5pdCkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlUmVkdWNlcic7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgdmFyIHByZXZEaXNwYXRjaGVyID0gUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQ7XG4gICAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudCA9IEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPblVwZGF0ZUluREVWO1xuXG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gdXBkYXRlUmVkdWNlcihyZWR1Y2VyLCBpbml0aWFsQXJnLCBpbml0KTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50ID0gcHJldkRpc3BhdGNoZXI7XG4gICAgICB9XG4gICAgfSxcbiAgICB1c2VSZWY6IGZ1bmN0aW9uIChpbml0aWFsVmFsdWUpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZVJlZic7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHVwZGF0ZVJlZigpO1xuICAgIH0sXG4gICAgdXNlU3RhdGU6IGZ1bmN0aW9uIChpbml0aWFsU3RhdGUpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZVN0YXRlJztcbiAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICB2YXIgcHJldkRpc3BhdGNoZXIgPSBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudDtcbiAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50ID0gSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uVXBkYXRlSW5ERVY7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiB1cGRhdGVTdGF0ZShpbml0aWFsU3RhdGUpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQgPSBwcmV2RGlzcGF0Y2hlcjtcbiAgICAgIH1cbiAgICB9LFxuICAgIHVzZURlYnVnVmFsdWU6IGZ1bmN0aW9uICh2YWx1ZSwgZm9ybWF0dGVyRm4pIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZURlYnVnVmFsdWUnO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiB1cGRhdGVEZWJ1Z1ZhbHVlKCk7XG4gICAgfSxcbiAgICB1c2VEZWZlcnJlZFZhbHVlOiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZURlZmVycmVkVmFsdWUnO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiB1cGRhdGVEZWZlcnJlZFZhbHVlKHZhbHVlKTtcbiAgICB9LFxuICAgIHVzZVRyYW5zaXRpb246IGZ1bmN0aW9uICgpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZVRyYW5zaXRpb24nO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiB1cGRhdGVUcmFuc2l0aW9uKCk7XG4gICAgfSxcbiAgICB1c2VNdXRhYmxlU291cmNlOiBmdW5jdGlvbiAoc291cmNlLCBnZXRTbmFwc2hvdCwgc3Vic2NyaWJlKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VNdXRhYmxlU291cmNlJztcbiAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gdXBkYXRlTXV0YWJsZVNvdXJjZShzb3VyY2UsIGdldFNuYXBzaG90LCBzdWJzY3JpYmUpO1xuICAgIH0sXG4gICAgdXNlT3BhcXVlSWRlbnRpZmllcjogZnVuY3Rpb24gKCkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlT3BhcXVlSWRlbnRpZmllcic7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHVwZGF0ZU9wYXF1ZUlkZW50aWZpZXIoKTtcbiAgICB9LFxuICAgIHVuc3RhYmxlX2lzTmV3UmVjb25jaWxlcjogZW5hYmxlTmV3UmVjb25jaWxlclxuICB9O1xuICBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25SZXJlbmRlckluREVWID0ge1xuICAgIHJlYWRDb250ZXh0OiBmdW5jdGlvbiAoY29udGV4dCwgb2JzZXJ2ZWRCaXRzKSB7XG4gICAgICB3YXJuSW52YWxpZENvbnRleHRBY2Nlc3MoKTtcbiAgICAgIHJldHVybiByZWFkQ29udGV4dChjb250ZXh0LCBvYnNlcnZlZEJpdHMpO1xuICAgIH0sXG4gICAgdXNlQ2FsbGJhY2s6IGZ1bmN0aW9uIChjYWxsYmFjaywgZGVwcykge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlQ2FsbGJhY2snO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiB1cGRhdGVDYWxsYmFjayhjYWxsYmFjaywgZGVwcyk7XG4gICAgfSxcbiAgICB1c2VDb250ZXh0OiBmdW5jdGlvbiAoY29udGV4dCwgb2JzZXJ2ZWRCaXRzKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VDb250ZXh0JztcbiAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gcmVhZENvbnRleHQoY29udGV4dCwgb2JzZXJ2ZWRCaXRzKTtcbiAgICB9LFxuICAgIHVzZUVmZmVjdDogZnVuY3Rpb24gKGNyZWF0ZSwgZGVwcykge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlRWZmZWN0JztcbiAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gdXBkYXRlRWZmZWN0KGNyZWF0ZSwgZGVwcyk7XG4gICAgfSxcbiAgICB1c2VJbXBlcmF0aXZlSGFuZGxlOiBmdW5jdGlvbiAocmVmLCBjcmVhdGUsIGRlcHMpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUltcGVyYXRpdmVIYW5kbGUnO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiB1cGRhdGVJbXBlcmF0aXZlSGFuZGxlKHJlZiwgY3JlYXRlLCBkZXBzKTtcbiAgICB9LFxuICAgIHVzZUxheW91dEVmZmVjdDogZnVuY3Rpb24gKGNyZWF0ZSwgZGVwcykge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlTGF5b3V0RWZmZWN0JztcbiAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gdXBkYXRlTGF5b3V0RWZmZWN0KGNyZWF0ZSwgZGVwcyk7XG4gICAgfSxcbiAgICB1c2VNZW1vOiBmdW5jdGlvbiAoY3JlYXRlLCBkZXBzKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VNZW1vJztcbiAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICB2YXIgcHJldkRpc3BhdGNoZXIgPSBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudDtcbiAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50ID0gSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uVXBkYXRlSW5ERVY7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiB1cGRhdGVNZW1vKGNyZWF0ZSwgZGVwcyk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudCA9IHByZXZEaXNwYXRjaGVyO1xuICAgICAgfVxuICAgIH0sXG4gICAgdXNlUmVkdWNlcjogZnVuY3Rpb24gKHJlZHVjZXIsIGluaXRpYWxBcmcsIGluaXQpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZVJlZHVjZXInO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHZhciBwcmV2RGlzcGF0Y2hlciA9IFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50O1xuICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQgPSBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25VcGRhdGVJbkRFVjtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIHJlcmVuZGVyUmVkdWNlcihyZWR1Y2VyLCBpbml0aWFsQXJnLCBpbml0KTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50ID0gcHJldkRpc3BhdGNoZXI7XG4gICAgICB9XG4gICAgfSxcbiAgICB1c2VSZWY6IGZ1bmN0aW9uIChpbml0aWFsVmFsdWUpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZVJlZic7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHVwZGF0ZVJlZigpO1xuICAgIH0sXG4gICAgdXNlU3RhdGU6IGZ1bmN0aW9uIChpbml0aWFsU3RhdGUpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZVN0YXRlJztcbiAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICB2YXIgcHJldkRpc3BhdGNoZXIgPSBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudDtcbiAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50ID0gSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uVXBkYXRlSW5ERVY7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiByZXJlbmRlclN0YXRlKGluaXRpYWxTdGF0ZSk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudCA9IHByZXZEaXNwYXRjaGVyO1xuICAgICAgfVxuICAgIH0sXG4gICAgdXNlRGVidWdWYWx1ZTogZnVuY3Rpb24gKHZhbHVlLCBmb3JtYXR0ZXJGbikge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlRGVidWdWYWx1ZSc7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHVwZGF0ZURlYnVnVmFsdWUoKTtcbiAgICB9LFxuICAgIHVzZURlZmVycmVkVmFsdWU6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlRGVmZXJyZWRWYWx1ZSc7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHJlcmVuZGVyRGVmZXJyZWRWYWx1ZSh2YWx1ZSk7XG4gICAgfSxcbiAgICB1c2VUcmFuc2l0aW9uOiBmdW5jdGlvbiAoKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VUcmFuc2l0aW9uJztcbiAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gcmVyZW5kZXJUcmFuc2l0aW9uKCk7XG4gICAgfSxcbiAgICB1c2VNdXRhYmxlU291cmNlOiBmdW5jdGlvbiAoc291cmNlLCBnZXRTbmFwc2hvdCwgc3Vic2NyaWJlKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VNdXRhYmxlU291cmNlJztcbiAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gdXBkYXRlTXV0YWJsZVNvdXJjZShzb3VyY2UsIGdldFNuYXBzaG90LCBzdWJzY3JpYmUpO1xuICAgIH0sXG4gICAgdXNlT3BhcXVlSWRlbnRpZmllcjogZnVuY3Rpb24gKCkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlT3BhcXVlSWRlbnRpZmllcic7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHJlcmVuZGVyT3BhcXVlSWRlbnRpZmllcigpO1xuICAgIH0sXG4gICAgdW5zdGFibGVfaXNOZXdSZWNvbmNpbGVyOiBlbmFibGVOZXdSZWNvbmNpbGVyXG4gIH07XG59XG5cbnZhciBub3ckMSA9IFNjaGVkdWxlci51bnN0YWJsZV9ub3c7XG52YXIgY29tbWl0VGltZSA9IDA7XG52YXIgcHJvZmlsZXJTdGFydFRpbWUgPSAtMTtcblxuZnVuY3Rpb24gZ2V0Q29tbWl0VGltZSgpIHtcbiAgcmV0dXJuIGNvbW1pdFRpbWU7XG59XG5cbmZ1bmN0aW9uIHJlY29yZENvbW1pdFRpbWUoKSB7XG5cbiAgY29tbWl0VGltZSA9IG5vdyQxKCk7XG59XG5cbmZ1bmN0aW9uIHN0YXJ0UHJvZmlsZXJUaW1lcihmaWJlcikge1xuXG4gIHByb2ZpbGVyU3RhcnRUaW1lID0gbm93JDEoKTtcblxuICBpZiAoZmliZXIuYWN0dWFsU3RhcnRUaW1lIDwgMCkge1xuICAgIGZpYmVyLmFjdHVhbFN0YXJ0VGltZSA9IG5vdyQxKCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gc3RvcFByb2ZpbGVyVGltZXJJZlJ1bm5pbmcoZmliZXIpIHtcblxuICBwcm9maWxlclN0YXJ0VGltZSA9IC0xO1xufVxuXG5mdW5jdGlvbiBzdG9wUHJvZmlsZXJUaW1lcklmUnVubmluZ0FuZFJlY29yZERlbHRhKGZpYmVyLCBvdmVycmlkZUJhc2VUaW1lKSB7XG5cbiAgaWYgKHByb2ZpbGVyU3RhcnRUaW1lID49IDApIHtcbiAgICB2YXIgZWxhcHNlZFRpbWUgPSBub3ckMSgpIC0gcHJvZmlsZXJTdGFydFRpbWU7XG4gICAgZmliZXIuYWN0dWFsRHVyYXRpb24gKz0gZWxhcHNlZFRpbWU7XG5cbiAgICBpZiAob3ZlcnJpZGVCYXNlVGltZSkge1xuICAgICAgZmliZXIuc2VsZkJhc2VEdXJhdGlvbiA9IGVsYXBzZWRUaW1lO1xuICAgIH1cblxuICAgIHByb2ZpbGVyU3RhcnRUaW1lID0gLTE7XG4gIH1cbn1cblxuZnVuY3Rpb24gdHJhbnNmZXJBY3R1YWxEdXJhdGlvbihmaWJlcikge1xuICAvLyBUcmFuc2ZlciB0aW1lIHNwZW50IHJlbmRlcmluZyB0aGVzZSBjaGlsZHJlbiBzbyB3ZSBkb24ndCBsb3NlIGl0XG4gIC8vIGFmdGVyIHdlIHJlcmVuZGVyLiBUaGlzIGlzIHVzZWQgYXMgYSBoZWxwZXIgaW4gc3BlY2lhbCBjYXNlc1xuICAvLyB3aGVyZSB3ZSBzaG91bGQgY291bnQgdGhlIHdvcmsgb2YgbXVsdGlwbGUgcGFzc2VzLlxuICB2YXIgY2hpbGQgPSBmaWJlci5jaGlsZDtcblxuICB3aGlsZSAoY2hpbGQpIHtcbiAgICBmaWJlci5hY3R1YWxEdXJhdGlvbiArPSBjaGlsZC5hY3R1YWxEdXJhdGlvbjtcbiAgICBjaGlsZCA9IGNoaWxkLnNpYmxpbmc7XG4gIH1cbn1cblxudmFyIFJlYWN0Q3VycmVudE93bmVyJDEgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdEN1cnJlbnRPd25lcjtcbnZhciBkaWRSZWNlaXZlVXBkYXRlID0gZmFsc2U7XG52YXIgZGlkV2FybkFib3V0QmFkQ2xhc3M7XG52YXIgZGlkV2FybkFib3V0TW9kdWxlUGF0dGVybkNvbXBvbmVudDtcbnZhciBkaWRXYXJuQWJvdXRDb250ZXh0VHlwZU9uRnVuY3Rpb25Db21wb25lbnQ7XG52YXIgZGlkV2FybkFib3V0R2V0RGVyaXZlZFN0YXRlT25GdW5jdGlvbkNvbXBvbmVudDtcbnZhciBkaWRXYXJuQWJvdXRGdW5jdGlvblJlZnM7XG52YXIgZGlkV2FybkFib3V0UmVhc3NpZ25pbmdQcm9wcztcbnZhciBkaWRXYXJuQWJvdXRSZXZlYWxPcmRlcjtcbnZhciBkaWRXYXJuQWJvdXRUYWlsT3B0aW9ucztcblxue1xuICBkaWRXYXJuQWJvdXRCYWRDbGFzcyA9IHt9O1xuICBkaWRXYXJuQWJvdXRNb2R1bGVQYXR0ZXJuQ29tcG9uZW50ID0ge307XG4gIGRpZFdhcm5BYm91dENvbnRleHRUeXBlT25GdW5jdGlvbkNvbXBvbmVudCA9IHt9O1xuICBkaWRXYXJuQWJvdXRHZXREZXJpdmVkU3RhdGVPbkZ1bmN0aW9uQ29tcG9uZW50ID0ge307XG4gIGRpZFdhcm5BYm91dEZ1bmN0aW9uUmVmcyA9IHt9O1xuICBkaWRXYXJuQWJvdXRSZWFzc2lnbmluZ1Byb3BzID0gZmFsc2U7XG4gIGRpZFdhcm5BYm91dFJldmVhbE9yZGVyID0ge307XG4gIGRpZFdhcm5BYm91dFRhaWxPcHRpb25zID0ge307XG59XG5cbmZ1bmN0aW9uIHJlY29uY2lsZUNoaWxkcmVuKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBuZXh0Q2hpbGRyZW4sIHJlbmRlckxhbmVzKSB7XG4gIGlmIChjdXJyZW50ID09PSBudWxsKSB7XG4gICAgLy8gSWYgdGhpcyBpcyBhIGZyZXNoIG5ldyBjb21wb25lbnQgdGhhdCBoYXNuJ3QgYmVlbiByZW5kZXJlZCB5ZXQsIHdlXG4gICAgLy8gd29uJ3QgdXBkYXRlIGl0cyBjaGlsZCBzZXQgYnkgYXBwbHlpbmcgbWluaW1hbCBzaWRlLWVmZmVjdHMuIEluc3RlYWQsXG4gICAgLy8gd2Ugd2lsbCBhZGQgdGhlbSBhbGwgdG8gdGhlIGNoaWxkIGJlZm9yZSBpdCBnZXRzIHJlbmRlcmVkLiBUaGF0IG1lYW5zXG4gICAgLy8gd2UgY2FuIG9wdGltaXplIHRoaXMgcmVjb25jaWxpYXRpb24gcGFzcyBieSBub3QgdHJhY2tpbmcgc2lkZS1lZmZlY3RzLlxuICAgIHdvcmtJblByb2dyZXNzLmNoaWxkID0gbW91bnRDaGlsZEZpYmVycyh3b3JrSW5Qcm9ncmVzcywgbnVsbCwgbmV4dENoaWxkcmVuLCByZW5kZXJMYW5lcyk7XG4gIH0gZWxzZSB7XG4gICAgLy8gSWYgdGhlIGN1cnJlbnQgY2hpbGQgaXMgdGhlIHNhbWUgYXMgdGhlIHdvcmsgaW4gcHJvZ3Jlc3MsIGl0IG1lYW5zIHRoYXRcbiAgICAvLyB3ZSBoYXZlbid0IHlldCBzdGFydGVkIGFueSB3b3JrIG9uIHRoZXNlIGNoaWxkcmVuLiBUaGVyZWZvcmUsIHdlIHVzZVxuICAgIC8vIHRoZSBjbG9uZSBhbGdvcml0aG0gdG8gY3JlYXRlIGEgY29weSBvZiBhbGwgdGhlIGN1cnJlbnQgY2hpbGRyZW4uXG4gICAgLy8gSWYgd2UgaGFkIGFueSBwcm9ncmVzc2VkIHdvcmsgYWxyZWFkeSwgdGhhdCBpcyBpbnZhbGlkIGF0IHRoaXMgcG9pbnQgc29cbiAgICAvLyBsZXQncyB0aHJvdyBpdCBvdXQuXG4gICAgd29ya0luUHJvZ3Jlc3MuY2hpbGQgPSByZWNvbmNpbGVDaGlsZEZpYmVycyh3b3JrSW5Qcm9ncmVzcywgY3VycmVudC5jaGlsZCwgbmV4dENoaWxkcmVuLCByZW5kZXJMYW5lcyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZm9yY2VVbm1vdW50Q3VycmVudEFuZFJlY29uY2lsZShjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgbmV4dENoaWxkcmVuLCByZW5kZXJMYW5lcykge1xuICAvLyBUaGlzIGZ1bmN0aW9uIGlzIGZvcmsgb2YgcmVjb25jaWxlQ2hpbGRyZW4uIEl0J3MgdXNlZCBpbiBjYXNlcyB3aGVyZSB3ZVxuICAvLyB3YW50IHRvIHJlY29uY2lsZSB3aXRob3V0IG1hdGNoaW5nIGFnYWluc3QgdGhlIGV4aXN0aW5nIHNldC4gVGhpcyBoYXMgdGhlXG4gIC8vIGVmZmVjdCBvZiBhbGwgY3VycmVudCBjaGlsZHJlbiBiZWluZyB1bm1vdW50ZWQ7IGV2ZW4gaWYgdGhlIHR5cGUgYW5kIGtleVxuICAvLyBhcmUgdGhlIHNhbWUsIHRoZSBvbGQgY2hpbGQgaXMgdW5tb3VudGVkIGFuZCBhIG5ldyBjaGlsZCBpcyBjcmVhdGVkLlxuICAvL1xuICAvLyBUbyBkbyB0aGlzLCB3ZSdyZSBnb2luZyB0byBnbyB0aHJvdWdoIHRoZSByZWNvbmNpbGUgYWxnb3JpdGhtIHR3aWNlLiBJblxuICAvLyB0aGUgZmlyc3QgcGFzcywgd2Ugc2NoZWR1bGUgYSBkZWxldGlvbiBmb3IgYWxsIHRoZSBjdXJyZW50IGNoaWxkcmVuIGJ5XG4gIC8vIHBhc3NpbmcgbnVsbC5cbiAgd29ya0luUHJvZ3Jlc3MuY2hpbGQgPSByZWNvbmNpbGVDaGlsZEZpYmVycyh3b3JrSW5Qcm9ncmVzcywgY3VycmVudC5jaGlsZCwgbnVsbCwgcmVuZGVyTGFuZXMpOyAvLyBJbiB0aGUgc2Vjb25kIHBhc3MsIHdlIG1vdW50IHRoZSBuZXcgY2hpbGRyZW4uIFRoZSB0cmljayBoZXJlIGlzIHRoYXQgd2VcbiAgLy8gcGFzcyBudWxsIGluIHBsYWNlIG9mIHdoZXJlIHdlIHVzdWFsbHkgcGFzcyB0aGUgY3VycmVudCBjaGlsZCBzZXQuIFRoaXMgaGFzXG4gIC8vIHRoZSBlZmZlY3Qgb2YgcmVtb3VudGluZyBhbGwgY2hpbGRyZW4gcmVnYXJkbGVzcyBvZiB3aGV0aGVyIHRoZWlyXG4gIC8vIGlkZW50aXRpZXMgbWF0Y2guXG5cbiAgd29ya0luUHJvZ3Jlc3MuY2hpbGQgPSByZWNvbmNpbGVDaGlsZEZpYmVycyh3b3JrSW5Qcm9ncmVzcywgbnVsbCwgbmV4dENoaWxkcmVuLCByZW5kZXJMYW5lcyk7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUZvcndhcmRSZWYoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIENvbXBvbmVudCwgbmV4dFByb3BzLCByZW5kZXJMYW5lcykge1xuICAvLyBUT0RPOiBjdXJyZW50IGNhbiBiZSBub24tbnVsbCBoZXJlIGV2ZW4gaWYgdGhlIGNvbXBvbmVudFxuICAvLyBoYXNuJ3QgeWV0IG1vdW50ZWQuIFRoaXMgaGFwcGVucyBhZnRlciB0aGUgZmlyc3QgcmVuZGVyIHN1c3BlbmRzLlxuICAvLyBXZSdsbCBuZWVkIHRvIGZpZ3VyZSBvdXQgaWYgdGhpcyBpcyBmaW5lIG9yIGNhbiBjYXVzZSBpc3N1ZXMuXG4gIHtcbiAgICBpZiAod29ya0luUHJvZ3Jlc3MudHlwZSAhPT0gd29ya0luUHJvZ3Jlc3MuZWxlbWVudFR5cGUpIHtcbiAgICAgIC8vIExhenkgY29tcG9uZW50IHByb3BzIGNhbid0IGJlIHZhbGlkYXRlZCBpbiBjcmVhdGVFbGVtZW50XG4gICAgICAvLyBiZWNhdXNlIHRoZXkncmUgb25seSBndWFyYW50ZWVkIHRvIGJlIHJlc29sdmVkIGhlcmUuXG4gICAgICB2YXIgaW5uZXJQcm9wVHlwZXMgPSBDb21wb25lbnQucHJvcFR5cGVzO1xuXG4gICAgICBpZiAoaW5uZXJQcm9wVHlwZXMpIHtcbiAgICAgICAgY2hlY2tQcm9wVHlwZXMoaW5uZXJQcm9wVHlwZXMsIG5leHRQcm9wcywgLy8gUmVzb2x2ZWQgcHJvcHNcbiAgICAgICAgJ3Byb3AnLCBnZXRDb21wb25lbnROYW1lKENvbXBvbmVudCkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHZhciByZW5kZXIgPSBDb21wb25lbnQucmVuZGVyO1xuICB2YXIgcmVmID0gd29ya0luUHJvZ3Jlc3MucmVmOyAvLyBUaGUgcmVzdCBpcyBhIGZvcmsgb2YgdXBkYXRlRnVuY3Rpb25Db21wb25lbnRcblxuICB2YXIgbmV4dENoaWxkcmVuO1xuICBwcmVwYXJlVG9SZWFkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpO1xuXG4gIHtcbiAgICBSZWFjdEN1cnJlbnRPd25lciQxLmN1cnJlbnQgPSB3b3JrSW5Qcm9ncmVzcztcbiAgICBzZXRJc1JlbmRlcmluZyh0cnVlKTtcbiAgICBuZXh0Q2hpbGRyZW4gPSByZW5kZXJXaXRoSG9va3MoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlciwgbmV4dFByb3BzLCByZWYsIHJlbmRlckxhbmVzKTtcblxuICAgIGlmICggd29ya0luUHJvZ3Jlc3MubW9kZSAmIFN0cmljdE1vZGUpIHtcbiAgICAgIGRpc2FibGVMb2dzKCk7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIG5leHRDaGlsZHJlbiA9IHJlbmRlcldpdGhIb29rcyhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyLCBuZXh0UHJvcHMsIHJlZiwgcmVuZGVyTGFuZXMpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgcmVlbmFibGVMb2dzKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgc2V0SXNSZW5kZXJpbmcoZmFsc2UpO1xuICB9XG5cbiAgaWYgKGN1cnJlbnQgIT09IG51bGwgJiYgIWRpZFJlY2VpdmVVcGRhdGUpIHtcbiAgICBiYWlsb3V0SG9va3MoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKTtcbiAgICByZXR1cm4gYmFpbG91dE9uQWxyZWFkeUZpbmlzaGVkV29yayhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpO1xuICB9IC8vIFJlYWN0IERldlRvb2xzIHJlYWRzIHRoaXMgZmxhZy5cblxuXG4gIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IFBlcmZvcm1lZFdvcms7XG4gIHJlY29uY2lsZUNoaWxkcmVuKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBuZXh0Q2hpbGRyZW4sIHJlbmRlckxhbmVzKTtcbiAgcmV0dXJuIHdvcmtJblByb2dyZXNzLmNoaWxkO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVNZW1vQ29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBDb21wb25lbnQsIG5leHRQcm9wcywgdXBkYXRlTGFuZXMsIHJlbmRlckxhbmVzKSB7XG4gIGlmIChjdXJyZW50ID09PSBudWxsKSB7XG4gICAgdmFyIHR5cGUgPSBDb21wb25lbnQudHlwZTtcblxuICAgIGlmIChpc1NpbXBsZUZ1bmN0aW9uQ29tcG9uZW50KHR5cGUpICYmIENvbXBvbmVudC5jb21wYXJlID09PSBudWxsICYmIC8vIFNpbXBsZU1lbW9Db21wb25lbnQgY29kZXBhdGggZG9lc24ndCByZXNvbHZlIG91dGVyIHByb3BzIGVpdGhlci5cbiAgICBDb21wb25lbnQuZGVmYXVsdFByb3BzID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHZhciByZXNvbHZlZFR5cGUgPSB0eXBlO1xuXG4gICAgICB7XG4gICAgICAgIHJlc29sdmVkVHlwZSA9IHJlc29sdmVGdW5jdGlvbkZvckhvdFJlbG9hZGluZyh0eXBlKTtcbiAgICAgIH0gLy8gSWYgdGhpcyBpcyBhIHBsYWluIGZ1bmN0aW9uIGNvbXBvbmVudCB3aXRob3V0IGRlZmF1bHQgcHJvcHMsXG4gICAgICAvLyBhbmQgd2l0aCBvbmx5IHRoZSBkZWZhdWx0IHNoYWxsb3cgY29tcGFyaXNvbiwgd2UgdXBncmFkZSBpdFxuICAgICAgLy8gdG8gYSBTaW1wbGVNZW1vQ29tcG9uZW50IHRvIGFsbG93IGZhc3QgcGF0aCB1cGRhdGVzLlxuXG5cbiAgICAgIHdvcmtJblByb2dyZXNzLnRhZyA9IFNpbXBsZU1lbW9Db21wb25lbnQ7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy50eXBlID0gcmVzb2x2ZWRUeXBlO1xuXG4gICAgICB7XG4gICAgICAgIHZhbGlkYXRlRnVuY3Rpb25Db21wb25lbnRJbkRldih3b3JrSW5Qcm9ncmVzcywgdHlwZSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB1cGRhdGVTaW1wbGVNZW1vQ29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZXNvbHZlZFR5cGUsIG5leHRQcm9wcywgdXBkYXRlTGFuZXMsIHJlbmRlckxhbmVzKTtcbiAgICB9XG5cbiAgICB7XG4gICAgICB2YXIgaW5uZXJQcm9wVHlwZXMgPSB0eXBlLnByb3BUeXBlcztcblxuICAgICAgaWYgKGlubmVyUHJvcFR5cGVzKSB7XG4gICAgICAgIC8vIElubmVyIG1lbW8gY29tcG9uZW50IHByb3BzIGFyZW4ndCBjdXJyZW50bHkgdmFsaWRhdGVkIGluIGNyZWF0ZUVsZW1lbnQuXG4gICAgICAgIC8vIFdlIGNvdWxkIG1vdmUgaXQgdGhlcmUsIGJ1dCB3ZSdkIHN0aWxsIG5lZWQgdGhpcyBmb3IgbGF6eSBjb2RlIHBhdGguXG4gICAgICAgIGNoZWNrUHJvcFR5cGVzKGlubmVyUHJvcFR5cGVzLCBuZXh0UHJvcHMsIC8vIFJlc29sdmVkIHByb3BzXG4gICAgICAgICdwcm9wJywgZ2V0Q29tcG9uZW50TmFtZSh0eXBlKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGNoaWxkID0gY3JlYXRlRmliZXJGcm9tVHlwZUFuZFByb3BzKENvbXBvbmVudC50eXBlLCBudWxsLCBuZXh0UHJvcHMsIHdvcmtJblByb2dyZXNzLCB3b3JrSW5Qcm9ncmVzcy5tb2RlLCByZW5kZXJMYW5lcyk7XG4gICAgY2hpbGQucmVmID0gd29ya0luUHJvZ3Jlc3MucmVmO1xuICAgIGNoaWxkLnJldHVybiA9IHdvcmtJblByb2dyZXNzO1xuICAgIHdvcmtJblByb2dyZXNzLmNoaWxkID0gY2hpbGQ7XG4gICAgcmV0dXJuIGNoaWxkO1xuICB9XG5cbiAge1xuICAgIHZhciBfdHlwZSA9IENvbXBvbmVudC50eXBlO1xuICAgIHZhciBfaW5uZXJQcm9wVHlwZXMgPSBfdHlwZS5wcm9wVHlwZXM7XG5cbiAgICBpZiAoX2lubmVyUHJvcFR5cGVzKSB7XG4gICAgICAvLyBJbm5lciBtZW1vIGNvbXBvbmVudCBwcm9wcyBhcmVuJ3QgY3VycmVudGx5IHZhbGlkYXRlZCBpbiBjcmVhdGVFbGVtZW50LlxuICAgICAgLy8gV2UgY291bGQgbW92ZSBpdCB0aGVyZSwgYnV0IHdlJ2Qgc3RpbGwgbmVlZCB0aGlzIGZvciBsYXp5IGNvZGUgcGF0aC5cbiAgICAgIGNoZWNrUHJvcFR5cGVzKF9pbm5lclByb3BUeXBlcywgbmV4dFByb3BzLCAvLyBSZXNvbHZlZCBwcm9wc1xuICAgICAgJ3Byb3AnLCBnZXRDb21wb25lbnROYW1lKF90eXBlKSk7XG4gICAgfVxuICB9XG5cbiAgdmFyIGN1cnJlbnRDaGlsZCA9IGN1cnJlbnQuY2hpbGQ7IC8vIFRoaXMgaXMgYWx3YXlzIGV4YWN0bHkgb25lIGNoaWxkXG5cbiAgaWYgKCFpbmNsdWRlc1NvbWVMYW5lKHVwZGF0ZUxhbmVzLCByZW5kZXJMYW5lcykpIHtcbiAgICAvLyBUaGlzIHdpbGwgYmUgdGhlIHByb3BzIHdpdGggcmVzb2x2ZWQgZGVmYXVsdFByb3BzLFxuICAgIC8vIHVubGlrZSBjdXJyZW50Lm1lbW9pemVkUHJvcHMgd2hpY2ggd2lsbCBiZSB0aGUgdW5yZXNvbHZlZCBvbmVzLlxuICAgIHZhciBwcmV2UHJvcHMgPSBjdXJyZW50Q2hpbGQubWVtb2l6ZWRQcm9wczsgLy8gRGVmYXVsdCB0byBzaGFsbG93IGNvbXBhcmlzb25cblxuICAgIHZhciBjb21wYXJlID0gQ29tcG9uZW50LmNvbXBhcmU7XG4gICAgY29tcGFyZSA9IGNvbXBhcmUgIT09IG51bGwgPyBjb21wYXJlIDogc2hhbGxvd0VxdWFsO1xuXG4gICAgaWYgKGNvbXBhcmUocHJldlByb3BzLCBuZXh0UHJvcHMpICYmIGN1cnJlbnQucmVmID09PSB3b3JrSW5Qcm9ncmVzcy5yZWYpIHtcbiAgICAgIHJldHVybiBiYWlsb3V0T25BbHJlYWR5RmluaXNoZWRXb3JrKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcyk7XG4gICAgfVxuICB9IC8vIFJlYWN0IERldlRvb2xzIHJlYWRzIHRoaXMgZmxhZy5cblxuXG4gIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IFBlcmZvcm1lZFdvcms7XG4gIHZhciBuZXdDaGlsZCA9IGNyZWF0ZVdvcmtJblByb2dyZXNzKGN1cnJlbnRDaGlsZCwgbmV4dFByb3BzKTtcbiAgbmV3Q2hpbGQucmVmID0gd29ya0luUHJvZ3Jlc3MucmVmO1xuICBuZXdDaGlsZC5yZXR1cm4gPSB3b3JrSW5Qcm9ncmVzcztcbiAgd29ya0luUHJvZ3Jlc3MuY2hpbGQgPSBuZXdDaGlsZDtcbiAgcmV0dXJuIG5ld0NoaWxkO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVTaW1wbGVNZW1vQ29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBDb21wb25lbnQsIG5leHRQcm9wcywgdXBkYXRlTGFuZXMsIHJlbmRlckxhbmVzKSB7XG4gIC8vIFRPRE86IGN1cnJlbnQgY2FuIGJlIG5vbi1udWxsIGhlcmUgZXZlbiBpZiB0aGUgY29tcG9uZW50XG4gIC8vIGhhc24ndCB5ZXQgbW91bnRlZC4gVGhpcyBoYXBwZW5zIHdoZW4gdGhlIGlubmVyIHJlbmRlciBzdXNwZW5kcy5cbiAgLy8gV2UnbGwgbmVlZCB0byBmaWd1cmUgb3V0IGlmIHRoaXMgaXMgZmluZSBvciBjYW4gY2F1c2UgaXNzdWVzLlxuICB7XG4gICAgaWYgKHdvcmtJblByb2dyZXNzLnR5cGUgIT09IHdvcmtJblByb2dyZXNzLmVsZW1lbnRUeXBlKSB7XG4gICAgICAvLyBMYXp5IGNvbXBvbmVudCBwcm9wcyBjYW4ndCBiZSB2YWxpZGF0ZWQgaW4gY3JlYXRlRWxlbWVudFxuICAgICAgLy8gYmVjYXVzZSB0aGV5J3JlIG9ubHkgZ3VhcmFudGVlZCB0byBiZSByZXNvbHZlZCBoZXJlLlxuICAgICAgdmFyIG91dGVyTWVtb1R5cGUgPSB3b3JrSW5Qcm9ncmVzcy5lbGVtZW50VHlwZTtcblxuICAgICAgaWYgKG91dGVyTWVtb1R5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0xBWllfVFlQRSkge1xuICAgICAgICAvLyBXZSB3YXJuIHdoZW4geW91IGRlZmluZSBwcm9wVHlwZXMgb24gbGF6eSgpXG4gICAgICAgIC8vIHNvIGxldCdzIGp1c3Qgc2tpcCBvdmVyIGl0IHRvIGZpbmQgbWVtbygpIG91dGVyIHdyYXBwZXIuXG4gICAgICAgIC8vIElubmVyIHByb3BzIGZvciBtZW1vIGFyZSB2YWxpZGF0ZWQgbGF0ZXIuXG4gICAgICAgIHZhciBsYXp5Q29tcG9uZW50ID0gb3V0ZXJNZW1vVHlwZTtcbiAgICAgICAgdmFyIHBheWxvYWQgPSBsYXp5Q29tcG9uZW50Ll9wYXlsb2FkO1xuICAgICAgICB2YXIgaW5pdCA9IGxhenlDb21wb25lbnQuX2luaXQ7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBvdXRlck1lbW9UeXBlID0gaW5pdChwYXlsb2FkKTtcbiAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgIG91dGVyTWVtb1R5cGUgPSBudWxsO1xuICAgICAgICB9IC8vIElubmVyIHByb3BUeXBlcyB3aWxsIGJlIHZhbGlkYXRlZCBpbiB0aGUgZnVuY3Rpb24gY29tcG9uZW50IHBhdGguXG5cblxuICAgICAgICB2YXIgb3V0ZXJQcm9wVHlwZXMgPSBvdXRlck1lbW9UeXBlICYmIG91dGVyTWVtb1R5cGUucHJvcFR5cGVzO1xuXG4gICAgICAgIGlmIChvdXRlclByb3BUeXBlcykge1xuICAgICAgICAgIGNoZWNrUHJvcFR5cGVzKG91dGVyUHJvcFR5cGVzLCBuZXh0UHJvcHMsIC8vIFJlc29sdmVkIChTaW1wbGVNZW1vQ29tcG9uZW50IGhhcyBubyBkZWZhdWx0UHJvcHMpXG4gICAgICAgICAgJ3Byb3AnLCBnZXRDb21wb25lbnROYW1lKG91dGVyTWVtb1R5cGUpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChjdXJyZW50ICE9PSBudWxsKSB7XG4gICAgdmFyIHByZXZQcm9wcyA9IGN1cnJlbnQubWVtb2l6ZWRQcm9wcztcblxuICAgIGlmIChzaGFsbG93RXF1YWwocHJldlByb3BzLCBuZXh0UHJvcHMpICYmIGN1cnJlbnQucmVmID09PSB3b3JrSW5Qcm9ncmVzcy5yZWYgJiYgKCAvLyBQcmV2ZW50IGJhaWxvdXQgaWYgdGhlIGltcGxlbWVudGF0aW9uIGNoYW5nZWQgZHVlIHRvIGhvdCByZWxvYWQuXG4gICAgIHdvcmtJblByb2dyZXNzLnR5cGUgPT09IGN1cnJlbnQudHlwZSApKSB7XG4gICAgICBkaWRSZWNlaXZlVXBkYXRlID0gZmFsc2U7XG5cbiAgICAgIGlmICghaW5jbHVkZXNTb21lTGFuZShyZW5kZXJMYW5lcywgdXBkYXRlTGFuZXMpKSB7XG4gICAgICAgIC8vIFRoZSBwZW5kaW5nIGxhbmVzIHdlcmUgY2xlYXJlZCBhdCB0aGUgYmVnaW5uaW5nIG9mIGJlZ2luV29yay4gV2UncmVcbiAgICAgICAgLy8gYWJvdXQgdG8gYmFpbCBvdXQsIGJ1dCB0aGVyZSBtaWdodCBiZSBvdGhlciBsYW5lcyB0aGF0IHdlcmVuJ3RcbiAgICAgICAgLy8gaW5jbHVkZWQgaW4gdGhlIGN1cnJlbnQgcmVuZGVyLiBVc3VhbGx5LCB0aGUgcHJpb3JpdHkgbGV2ZWwgb2YgdGhlXG4gICAgICAgIC8vIHJlbWFpbmluZyB1cGRhdGVzIGlzIGFjY3VtbGF0ZWQgZHVyaW5nIHRoZSBldmFsdWF0aW9uIG9mIHRoZVxuICAgICAgICAvLyBjb21wb25lbnQgKGkuZS4gd2hlbiBwcm9jZXNzaW5nIHRoZSB1cGRhdGUgcXVldWUpLiBCdXQgc2luY2Ugc2luY2VcbiAgICAgICAgLy8gd2UncmUgYmFpbGluZyBvdXQgZWFybHkgKndpdGhvdXQqIGV2YWx1YXRpbmcgdGhlIGNvbXBvbmVudCwgd2UgbmVlZFxuICAgICAgICAvLyB0byBhY2NvdW50IGZvciBpdCBoZXJlLCB0b28uIFJlc2V0IHRvIHRoZSB2YWx1ZSBvZiB0aGUgY3VycmVudCBmaWJlci5cbiAgICAgICAgLy8gTk9URTogVGhpcyBvbmx5IGFwcGxpZXMgdG8gU2ltcGxlTWVtb0NvbXBvbmVudCwgbm90IE1lbW9Db21wb25lbnQsXG4gICAgICAgIC8vIGJlY2F1c2UgYSBNZW1vQ29tcG9uZW50IGZpYmVyIGRvZXMgbm90IGhhdmUgaG9va3Mgb3IgYW4gdXBkYXRlIHF1ZXVlO1xuICAgICAgICAvLyByYXRoZXIsIGl0IHdyYXBzIGFyb3VuZCBhbiBpbm5lciBjb21wb25lbnQsIHdoaWNoIG1heSBvciBtYXkgbm90XG4gICAgICAgIC8vIGNvbnRhaW5zIGhvb2tzLlxuICAgICAgICAvLyBUT0RPOiBNb3ZlIHRoZSByZXNldCBhdCBpbiBiZWdpbldvcmsgb3V0IG9mIHRoZSBjb21tb24gcGF0aCBzbyB0aGF0XG4gICAgICAgIC8vIHRoaXMgaXMgbm8gbG9uZ2VyIG5lY2Vzc2FyeS5cbiAgICAgICAgd29ya0luUHJvZ3Jlc3MubGFuZXMgPSBjdXJyZW50LmxhbmVzO1xuICAgICAgICByZXR1cm4gYmFpbG91dE9uQWxyZWFkeUZpbmlzaGVkV29yayhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpO1xuICAgICAgfSBlbHNlIGlmICgoY3VycmVudC5mbGFncyAmIEZvcmNlVXBkYXRlRm9yTGVnYWN5U3VzcGVuc2UpICE9PSBOb0ZsYWdzKSB7XG4gICAgICAgIC8vIFRoaXMgaXMgYSBzcGVjaWFsIGNhc2UgdGhhdCBvbmx5IGV4aXN0cyBmb3IgbGVnYWN5IG1vZGUuXG4gICAgICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvcHVsbC8xOTIxNi5cbiAgICAgICAgZGlkUmVjZWl2ZVVwZGF0ZSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHVwZGF0ZUZ1bmN0aW9uQ29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBDb21wb25lbnQsIG5leHRQcm9wcywgcmVuZGVyTGFuZXMpO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVPZmZzY3JlZW5Db21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKSB7XG4gIHZhciBuZXh0UHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHM7XG4gIHZhciBuZXh0Q2hpbGRyZW4gPSBuZXh0UHJvcHMuY2hpbGRyZW47XG4gIHZhciBwcmV2U3RhdGUgPSBjdXJyZW50ICE9PSBudWxsID8gY3VycmVudC5tZW1vaXplZFN0YXRlIDogbnVsbDtcblxuICBpZiAobmV4dFByb3BzLm1vZGUgPT09ICdoaWRkZW4nIHx8IG5leHRQcm9wcy5tb2RlID09PSAndW5zdGFibGUtZGVmZXItd2l0aG91dC1oaWRpbmcnKSB7XG4gICAgaWYgKCh3b3JrSW5Qcm9ncmVzcy5tb2RlICYgQ29uY3VycmVudE1vZGUpID09PSBOb01vZGUpIHtcbiAgICAgIC8vIEluIGxlZ2FjeSBzeW5jIG1vZGUsIGRvbid0IGRlZmVyIHRoZSBzdWJ0cmVlLiBSZW5kZXIgaXQgbm93LlxuICAgICAgLy8gVE9ETzogRmlndXJlIG91dCB3aGF0IHdlIHNob3VsZCBkbyBpbiBCbG9ja2luZyBtb2RlLlxuICAgICAgdmFyIG5leHRTdGF0ZSA9IHtcbiAgICAgICAgYmFzZUxhbmVzOiBOb0xhbmVzXG4gICAgICB9O1xuICAgICAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IG5leHRTdGF0ZTtcbiAgICAgIHB1c2hSZW5kZXJMYW5lcyh3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpO1xuICAgIH0gZWxzZSBpZiAoIWluY2x1ZGVzU29tZUxhbmUocmVuZGVyTGFuZXMsIE9mZnNjcmVlbkxhbmUpKSB7XG4gICAgICB2YXIgbmV4dEJhc2VMYW5lcztcblxuICAgICAgaWYgKHByZXZTdGF0ZSAhPT0gbnVsbCkge1xuICAgICAgICB2YXIgcHJldkJhc2VMYW5lcyA9IHByZXZTdGF0ZS5iYXNlTGFuZXM7XG4gICAgICAgIG5leHRCYXNlTGFuZXMgPSBtZXJnZUxhbmVzKHByZXZCYXNlTGFuZXMsIHJlbmRlckxhbmVzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5leHRCYXNlTGFuZXMgPSByZW5kZXJMYW5lcztcbiAgICAgIH0gLy8gU2NoZWR1bGUgdGhpcyBmaWJlciB0byByZS1yZW5kZXIgYXQgb2Zmc2NyZWVuIHByaW9yaXR5LiBUaGVuIGJhaWxvdXQuXG5cblxuICAgICAge1xuICAgICAgICBtYXJrU3Bhd25lZFdvcmsoT2Zmc2NyZWVuTGFuZSk7XG4gICAgICB9XG5cbiAgICAgIHdvcmtJblByb2dyZXNzLmxhbmVzID0gd29ya0luUHJvZ3Jlc3MuY2hpbGRMYW5lcyA9IGxhbmVUb0xhbmVzKE9mZnNjcmVlbkxhbmUpO1xuICAgICAgdmFyIF9uZXh0U3RhdGUgPSB7XG4gICAgICAgIGJhc2VMYW5lczogbmV4dEJhc2VMYW5lc1xuICAgICAgfTtcbiAgICAgIHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSBfbmV4dFN0YXRlOyAvLyBXZSdyZSBhYm91dCB0byBiYWlsIG91dCwgYnV0IHdlIG5lZWQgdG8gcHVzaCB0aGlzIHRvIHRoZSBzdGFjayBhbnl3YXlcbiAgICAgIC8vIHRvIGF2b2lkIGEgcHVzaC9wb3AgbWlzYWxpZ25tZW50LlxuXG4gICAgICBwdXNoUmVuZGVyTGFuZXMod29ya0luUHJvZ3Jlc3MsIG5leHRCYXNlTGFuZXMpO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFJlbmRlcmluZyBhdCBvZmZzY3JlZW4sIHNvIHdlIGNhbiBjbGVhciB0aGUgYmFzZSBsYW5lcy5cbiAgICAgIHZhciBfbmV4dFN0YXRlMiA9IHtcbiAgICAgICAgYmFzZUxhbmVzOiBOb0xhbmVzXG4gICAgICB9O1xuICAgICAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IF9uZXh0U3RhdGUyOyAvLyBQdXNoIHRoZSBsYW5lcyB0aGF0IHdlcmUgc2tpcHBlZCB3aGVuIHdlIGJhaWxlZCBvdXQuXG5cbiAgICAgIHZhciBzdWJ0cmVlUmVuZGVyTGFuZXMgPSBwcmV2U3RhdGUgIT09IG51bGwgPyBwcmV2U3RhdGUuYmFzZUxhbmVzIDogcmVuZGVyTGFuZXM7XG4gICAgICBwdXNoUmVuZGVyTGFuZXMod29ya0luUHJvZ3Jlc3MsIHN1YnRyZWVSZW5kZXJMYW5lcyk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBfc3VidHJlZVJlbmRlckxhbmVzO1xuXG4gICAgaWYgKHByZXZTdGF0ZSAhPT0gbnVsbCkge1xuICAgICAgX3N1YnRyZWVSZW5kZXJMYW5lcyA9IG1lcmdlTGFuZXMocHJldlN0YXRlLmJhc2VMYW5lcywgcmVuZGVyTGFuZXMpOyAvLyBTaW5jZSB3ZSdyZSBub3QgaGlkZGVuIGFueW1vcmUsIHJlc2V0IHRoZSBzdGF0ZVxuXG4gICAgICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID0gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gV2Ugd2VyZW4ndCBwcmV2aW91c2x5IGhpZGRlbiwgYW5kIHdlIHN0aWxsIGFyZW4ndCwgc28gdGhlcmUncyBub3RoaW5nXG4gICAgICAvLyBzcGVjaWFsIHRvIGRvLiBOZWVkIHRvIHB1c2ggdG8gdGhlIHN0YWNrIHJlZ2FyZGxlc3MsIHRob3VnaCwgdG8gYXZvaWRcbiAgICAgIC8vIGEgcHVzaC9wb3AgbWlzYWxpZ25tZW50LlxuICAgICAgX3N1YnRyZWVSZW5kZXJMYW5lcyA9IHJlbmRlckxhbmVzO1xuICAgIH1cblxuICAgIHB1c2hSZW5kZXJMYW5lcyh3b3JrSW5Qcm9ncmVzcywgX3N1YnRyZWVSZW5kZXJMYW5lcyk7XG4gIH1cblxuICByZWNvbmNpbGVDaGlsZHJlbihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgbmV4dENoaWxkcmVuLCByZW5kZXJMYW5lcyk7XG4gIHJldHVybiB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbn0gLy8gTm90ZTogVGhlc2UgaGFwcGVuIHRvIGhhdmUgaWRlbnRpY2FsIGJlZ2luIHBoYXNlcywgZm9yIG5vdy4gV2Ugc2hvdWxkbid0IGhvbGRcbi8vIG91cnNlbHZlcyB0byB0aGlzIGNvbnN0cmFpbnQsIHRob3VnaC4gSWYgdGhlIGJlaGF2aW9yIGRpdmVyZ2VzLCB3ZSBzaG91bGRcbi8vIGZvcmsgdGhlIGZ1bmN0aW9uLlxuXG5cbnZhciB1cGRhdGVMZWdhY3lIaWRkZW5Db21wb25lbnQgPSB1cGRhdGVPZmZzY3JlZW5Db21wb25lbnQ7XG5cbmZ1bmN0aW9uIHVwZGF0ZUZyYWdtZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcykge1xuICB2YXIgbmV4dENoaWxkcmVuID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzO1xuICByZWNvbmNpbGVDaGlsZHJlbihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgbmV4dENoaWxkcmVuLCByZW5kZXJMYW5lcyk7XG4gIHJldHVybiB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbn1cblxuZnVuY3Rpb24gdXBkYXRlTW9kZShjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpIHtcbiAgdmFyIG5leHRDaGlsZHJlbiA9IHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcy5jaGlsZHJlbjtcbiAgcmVjb25jaWxlQ2hpbGRyZW4oY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIG5leHRDaGlsZHJlbiwgcmVuZGVyTGFuZXMpO1xuICByZXR1cm4gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZVByb2ZpbGVyKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcykge1xuICB7XG4gICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gVXBkYXRlOyAvLyBSZXNldCBlZmZlY3QgZHVyYXRpb25zIGZvciB0aGUgbmV4dCBldmVudHVhbCBlZmZlY3QgcGhhc2UuXG4gICAgLy8gVGhlc2UgYXJlIHJlc2V0IGR1cmluZyByZW5kZXIgdG8gYWxsb3cgdGhlIERldlRvb2xzIGNvbW1pdCBob29rIGEgY2hhbmNlIHRvIHJlYWQgdGhlbSxcblxuICAgIHZhciBzdGF0ZU5vZGUgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG4gICAgc3RhdGVOb2RlLmVmZmVjdER1cmF0aW9uID0gMDtcbiAgICBzdGF0ZU5vZGUucGFzc2l2ZUVmZmVjdER1cmF0aW9uID0gMDtcbiAgfVxuXG4gIHZhciBuZXh0UHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHM7XG4gIHZhciBuZXh0Q2hpbGRyZW4gPSBuZXh0UHJvcHMuY2hpbGRyZW47XG4gIHJlY29uY2lsZUNoaWxkcmVuKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBuZXh0Q2hpbGRyZW4sIHJlbmRlckxhbmVzKTtcbiAgcmV0dXJuIHdvcmtJblByb2dyZXNzLmNoaWxkO1xufVxuXG5mdW5jdGlvbiBtYXJrUmVmKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKSB7XG4gIHZhciByZWYgPSB3b3JrSW5Qcm9ncmVzcy5yZWY7XG5cbiAgaWYgKGN1cnJlbnQgPT09IG51bGwgJiYgcmVmICE9PSBudWxsIHx8IGN1cnJlbnQgIT09IG51bGwgJiYgY3VycmVudC5yZWYgIT09IHJlZikge1xuICAgIC8vIFNjaGVkdWxlIGEgUmVmIGVmZmVjdFxuICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IFJlZjtcbiAgfVxufVxuXG5mdW5jdGlvbiB1cGRhdGVGdW5jdGlvbkNvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgQ29tcG9uZW50LCBuZXh0UHJvcHMsIHJlbmRlckxhbmVzKSB7XG4gIHtcbiAgICBpZiAod29ya0luUHJvZ3Jlc3MudHlwZSAhPT0gd29ya0luUHJvZ3Jlc3MuZWxlbWVudFR5cGUpIHtcbiAgICAgIC8vIExhenkgY29tcG9uZW50IHByb3BzIGNhbid0IGJlIHZhbGlkYXRlZCBpbiBjcmVhdGVFbGVtZW50XG4gICAgICAvLyBiZWNhdXNlIHRoZXkncmUgb25seSBndWFyYW50ZWVkIHRvIGJlIHJlc29sdmVkIGhlcmUuXG4gICAgICB2YXIgaW5uZXJQcm9wVHlwZXMgPSBDb21wb25lbnQucHJvcFR5cGVzO1xuXG4gICAgICBpZiAoaW5uZXJQcm9wVHlwZXMpIHtcbiAgICAgICAgY2hlY2tQcm9wVHlwZXMoaW5uZXJQcm9wVHlwZXMsIG5leHRQcm9wcywgLy8gUmVzb2x2ZWQgcHJvcHNcbiAgICAgICAgJ3Byb3AnLCBnZXRDb21wb25lbnROYW1lKENvbXBvbmVudCkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHZhciBjb250ZXh0O1xuXG4gIHtcbiAgICB2YXIgdW5tYXNrZWRDb250ZXh0ID0gZ2V0VW5tYXNrZWRDb250ZXh0KHdvcmtJblByb2dyZXNzLCBDb21wb25lbnQsIHRydWUpO1xuICAgIGNvbnRleHQgPSBnZXRNYXNrZWRDb250ZXh0KHdvcmtJblByb2dyZXNzLCB1bm1hc2tlZENvbnRleHQpO1xuICB9XG5cbiAgdmFyIG5leHRDaGlsZHJlbjtcbiAgcHJlcGFyZVRvUmVhZENvbnRleHQod29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKTtcblxuICB7XG4gICAgUmVhY3RDdXJyZW50T3duZXIkMS5jdXJyZW50ID0gd29ya0luUHJvZ3Jlc3M7XG4gICAgc2V0SXNSZW5kZXJpbmcodHJ1ZSk7XG4gICAgbmV4dENoaWxkcmVuID0gcmVuZGVyV2l0aEhvb2tzKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBDb21wb25lbnQsIG5leHRQcm9wcywgY29udGV4dCwgcmVuZGVyTGFuZXMpO1xuXG4gICAgaWYgKCB3b3JrSW5Qcm9ncmVzcy5tb2RlICYgU3RyaWN0TW9kZSkge1xuICAgICAgZGlzYWJsZUxvZ3MoKTtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgbmV4dENoaWxkcmVuID0gcmVuZGVyV2l0aEhvb2tzKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBDb21wb25lbnQsIG5leHRQcm9wcywgY29udGV4dCwgcmVuZGVyTGFuZXMpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgcmVlbmFibGVMb2dzKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgc2V0SXNSZW5kZXJpbmcoZmFsc2UpO1xuICB9XG5cbiAgaWYgKGN1cnJlbnQgIT09IG51bGwgJiYgIWRpZFJlY2VpdmVVcGRhdGUpIHtcbiAgICBiYWlsb3V0SG9va3MoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKTtcbiAgICByZXR1cm4gYmFpbG91dE9uQWxyZWFkeUZpbmlzaGVkV29yayhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpO1xuICB9IC8vIFJlYWN0IERldlRvb2xzIHJlYWRzIHRoaXMgZmxhZy5cblxuXG4gIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IFBlcmZvcm1lZFdvcms7XG4gIHJlY29uY2lsZUNoaWxkcmVuKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBuZXh0Q2hpbGRyZW4sIHJlbmRlckxhbmVzKTtcbiAgcmV0dXJuIHdvcmtJblByb2dyZXNzLmNoaWxkO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVDbGFzc0NvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgQ29tcG9uZW50LCBuZXh0UHJvcHMsIHJlbmRlckxhbmVzKSB7XG4gIHtcbiAgICBpZiAod29ya0luUHJvZ3Jlc3MudHlwZSAhPT0gd29ya0luUHJvZ3Jlc3MuZWxlbWVudFR5cGUpIHtcbiAgICAgIC8vIExhenkgY29tcG9uZW50IHByb3BzIGNhbid0IGJlIHZhbGlkYXRlZCBpbiBjcmVhdGVFbGVtZW50XG4gICAgICAvLyBiZWNhdXNlIHRoZXkncmUgb25seSBndWFyYW50ZWVkIHRvIGJlIHJlc29sdmVkIGhlcmUuXG4gICAgICB2YXIgaW5uZXJQcm9wVHlwZXMgPSBDb21wb25lbnQucHJvcFR5cGVzO1xuXG4gICAgICBpZiAoaW5uZXJQcm9wVHlwZXMpIHtcbiAgICAgICAgY2hlY2tQcm9wVHlwZXMoaW5uZXJQcm9wVHlwZXMsIG5leHRQcm9wcywgLy8gUmVzb2x2ZWQgcHJvcHNcbiAgICAgICAgJ3Byb3AnLCBnZXRDb21wb25lbnROYW1lKENvbXBvbmVudCkpO1xuICAgICAgfVxuICAgIH1cbiAgfSAvLyBQdXNoIGNvbnRleHQgcHJvdmlkZXJzIGVhcmx5IHRvIHByZXZlbnQgY29udGV4dCBzdGFjayBtaXNtYXRjaGVzLlxuICAvLyBEdXJpbmcgbW91bnRpbmcgd2UgZG9uJ3Qga25vdyB0aGUgY2hpbGQgY29udGV4dCB5ZXQgYXMgdGhlIGluc3RhbmNlIGRvZXNuJ3QgZXhpc3QuXG4gIC8vIFdlIHdpbGwgaW52YWxpZGF0ZSB0aGUgY2hpbGQgY29udGV4dCBpbiBmaW5pc2hDbGFzc0NvbXBvbmVudCgpIHJpZ2h0IGFmdGVyIHJlbmRlcmluZy5cblxuXG4gIHZhciBoYXNDb250ZXh0O1xuXG4gIGlmIChpc0NvbnRleHRQcm92aWRlcihDb21wb25lbnQpKSB7XG4gICAgaGFzQ29udGV4dCA9IHRydWU7XG4gICAgcHVzaENvbnRleHRQcm92aWRlcih3b3JrSW5Qcm9ncmVzcyk7XG4gIH0gZWxzZSB7XG4gICAgaGFzQ29udGV4dCA9IGZhbHNlO1xuICB9XG5cbiAgcHJlcGFyZVRvUmVhZENvbnRleHQod29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKTtcbiAgdmFyIGluc3RhbmNlID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuICB2YXIgc2hvdWxkVXBkYXRlO1xuXG4gIGlmIChpbnN0YW5jZSA9PT0gbnVsbCkge1xuICAgIGlmIChjdXJyZW50ICE9PSBudWxsKSB7XG4gICAgICAvLyBBIGNsYXNzIGNvbXBvbmVudCB3aXRob3V0IGFuIGluc3RhbmNlIG9ubHkgbW91bnRzIGlmIGl0IHN1c3BlbmRlZFxuICAgICAgLy8gaW5zaWRlIGEgbm9uLWNvbmN1cnJlbnQgdHJlZSwgaW4gYW4gaW5jb25zaXN0ZW50IHN0YXRlLiBXZSB3YW50IHRvXG4gICAgICAvLyB0cmVhdCBpdCBsaWtlIGEgbmV3IG1vdW50LCBldmVuIHRob3VnaCBhbiBlbXB0eSB2ZXJzaW9uIG9mIGl0IGFscmVhZHlcbiAgICAgIC8vIGNvbW1pdHRlZC4gRGlzY29ubmVjdCB0aGUgYWx0ZXJuYXRlIHBvaW50ZXJzLlxuICAgICAgY3VycmVudC5hbHRlcm5hdGUgPSBudWxsO1xuICAgICAgd29ya0luUHJvZ3Jlc3MuYWx0ZXJuYXRlID0gbnVsbDsgLy8gU2luY2UgdGhpcyBpcyBjb25jZXB0dWFsbHkgYSBuZXcgZmliZXIsIHNjaGVkdWxlIGEgUGxhY2VtZW50IGVmZmVjdFxuXG4gICAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSBQbGFjZW1lbnQ7XG4gICAgfSAvLyBJbiB0aGUgaW5pdGlhbCBwYXNzIHdlIG1pZ2h0IG5lZWQgdG8gY29uc3RydWN0IHRoZSBpbnN0YW5jZS5cblxuXG4gICAgY29uc3RydWN0Q2xhc3NJbnN0YW5jZSh3b3JrSW5Qcm9ncmVzcywgQ29tcG9uZW50LCBuZXh0UHJvcHMpO1xuICAgIG1vdW50Q2xhc3NJbnN0YW5jZSh3b3JrSW5Qcm9ncmVzcywgQ29tcG9uZW50LCBuZXh0UHJvcHMsIHJlbmRlckxhbmVzKTtcbiAgICBzaG91bGRVcGRhdGUgPSB0cnVlO1xuICB9IGVsc2UgaWYgKGN1cnJlbnQgPT09IG51bGwpIHtcbiAgICAvLyBJbiBhIHJlc3VtZSwgd2UnbGwgYWxyZWFkeSBoYXZlIGFuIGluc3RhbmNlIHdlIGNhbiByZXVzZS5cbiAgICBzaG91bGRVcGRhdGUgPSByZXN1bWVNb3VudENsYXNzSW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MsIENvbXBvbmVudCwgbmV4dFByb3BzLCByZW5kZXJMYW5lcyk7XG4gIH0gZWxzZSB7XG4gICAgc2hvdWxkVXBkYXRlID0gdXBkYXRlQ2xhc3NJbnN0YW5jZShjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgQ29tcG9uZW50LCBuZXh0UHJvcHMsIHJlbmRlckxhbmVzKTtcbiAgfVxuXG4gIHZhciBuZXh0VW5pdE9mV29yayA9IGZpbmlzaENsYXNzQ29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBDb21wb25lbnQsIHNob3VsZFVwZGF0ZSwgaGFzQ29udGV4dCwgcmVuZGVyTGFuZXMpO1xuXG4gIHtcbiAgICB2YXIgaW5zdCA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcblxuICAgIGlmIChzaG91bGRVcGRhdGUgJiYgaW5zdC5wcm9wcyAhPT0gbmV4dFByb3BzKSB7XG4gICAgICBpZiAoIWRpZFdhcm5BYm91dFJlYXNzaWduaW5nUHJvcHMpIHtcbiAgICAgICAgZXJyb3IoJ0l0IGxvb2tzIGxpa2UgJXMgaXMgcmVhc3NpZ25pbmcgaXRzIG93biBgdGhpcy5wcm9wc2Agd2hpbGUgcmVuZGVyaW5nLiAnICsgJ1RoaXMgaXMgbm90IHN1cHBvcnRlZCBhbmQgY2FuIGxlYWQgdG8gY29uZnVzaW5nIGJ1Z3MuJywgZ2V0Q29tcG9uZW50TmFtZSh3b3JrSW5Qcm9ncmVzcy50eXBlKSB8fCAnYSBjb21wb25lbnQnKTtcbiAgICAgIH1cblxuICAgICAgZGlkV2FybkFib3V0UmVhc3NpZ25pbmdQcm9wcyA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5leHRVbml0T2ZXb3JrO1xufVxuXG5mdW5jdGlvbiBmaW5pc2hDbGFzc0NvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgQ29tcG9uZW50LCBzaG91bGRVcGRhdGUsIGhhc0NvbnRleHQsIHJlbmRlckxhbmVzKSB7XG4gIC8vIFJlZnMgc2hvdWxkIHVwZGF0ZSBldmVuIGlmIHNob3VsZENvbXBvbmVudFVwZGF0ZSByZXR1cm5zIGZhbHNlXG4gIG1hcmtSZWYoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpO1xuICB2YXIgZGlkQ2FwdHVyZUVycm9yID0gKHdvcmtJblByb2dyZXNzLmZsYWdzICYgRGlkQ2FwdHVyZSkgIT09IE5vRmxhZ3M7XG5cbiAgaWYgKCFzaG91bGRVcGRhdGUgJiYgIWRpZENhcHR1cmVFcnJvcikge1xuICAgIC8vIENvbnRleHQgcHJvdmlkZXJzIHNob3VsZCBkZWZlciB0byBzQ1UgZm9yIHJlbmRlcmluZ1xuICAgIGlmIChoYXNDb250ZXh0KSB7XG4gICAgICBpbnZhbGlkYXRlQ29udGV4dFByb3ZpZGVyKHdvcmtJblByb2dyZXNzLCBDb21wb25lbnQsIGZhbHNlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYmFpbG91dE9uQWxyZWFkeUZpbmlzaGVkV29yayhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpO1xuICB9XG5cbiAgdmFyIGluc3RhbmNlID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlOyAvLyBSZXJlbmRlclxuXG4gIFJlYWN0Q3VycmVudE93bmVyJDEuY3VycmVudCA9IHdvcmtJblByb2dyZXNzO1xuICB2YXIgbmV4dENoaWxkcmVuO1xuXG4gIGlmIChkaWRDYXB0dXJlRXJyb3IgJiYgdHlwZW9mIENvbXBvbmVudC5nZXREZXJpdmVkU3RhdGVGcm9tRXJyb3IgIT09ICdmdW5jdGlvbicpIHtcbiAgICAvLyBJZiB3ZSBjYXB0dXJlZCBhbiBlcnJvciwgYnV0IGdldERlcml2ZWRTdGF0ZUZyb21FcnJvciBpcyBub3QgZGVmaW5lZCxcbiAgICAvLyB1bm1vdW50IGFsbCB0aGUgY2hpbGRyZW4uIGNvbXBvbmVudERpZENhdGNoIHdpbGwgc2NoZWR1bGUgYW4gdXBkYXRlIHRvXG4gICAgLy8gcmUtcmVuZGVyIGEgZmFsbGJhY2suIFRoaXMgaXMgdGVtcG9yYXJ5IHVudGlsIHdlIG1pZ3JhdGUgZXZlcnlvbmUgdG9cbiAgICAvLyB0aGUgbmV3IEFQSS5cbiAgICAvLyBUT0RPOiBXYXJuIGluIGEgZnV0dXJlIHJlbGVhc2UuXG4gICAgbmV4dENoaWxkcmVuID0gbnVsbDtcblxuICAgIHtcbiAgICAgIHN0b3BQcm9maWxlclRpbWVySWZSdW5uaW5nKCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHtcbiAgICAgIHNldElzUmVuZGVyaW5nKHRydWUpO1xuICAgICAgbmV4dENoaWxkcmVuID0gaW5zdGFuY2UucmVuZGVyKCk7XG5cbiAgICAgIGlmICggd29ya0luUHJvZ3Jlc3MubW9kZSAmIFN0cmljdE1vZGUpIHtcbiAgICAgICAgZGlzYWJsZUxvZ3MoKTtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgIGluc3RhbmNlLnJlbmRlcigpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIHJlZW5hYmxlTG9ncygpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHNldElzUmVuZGVyaW5nKGZhbHNlKTtcbiAgICB9XG4gIH0gLy8gUmVhY3QgRGV2VG9vbHMgcmVhZHMgdGhpcyBmbGFnLlxuXG5cbiAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gUGVyZm9ybWVkV29yaztcblxuICBpZiAoY3VycmVudCAhPT0gbnVsbCAmJiBkaWRDYXB0dXJlRXJyb3IpIHtcbiAgICAvLyBJZiB3ZSdyZSByZWNvdmVyaW5nIGZyb20gYW4gZXJyb3IsIHJlY29uY2lsZSB3aXRob3V0IHJldXNpbmcgYW55IG9mXG4gICAgLy8gdGhlIGV4aXN0aW5nIGNoaWxkcmVuLiBDb25jZXB0dWFsbHksIHRoZSBub3JtYWwgY2hpbGRyZW4gYW5kIHRoZSBjaGlsZHJlblxuICAgIC8vIHRoYXQgYXJlIHNob3duIG9uIGVycm9yIGFyZSB0d28gZGlmZmVyZW50IHNldHMsIHNvIHdlIHNob3VsZG4ndCByZXVzZVxuICAgIC8vIG5vcm1hbCBjaGlsZHJlbiBldmVuIGlmIHRoZWlyIGlkZW50aXRpZXMgbWF0Y2guXG4gICAgZm9yY2VVbm1vdW50Q3VycmVudEFuZFJlY29uY2lsZShjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgbmV4dENoaWxkcmVuLCByZW5kZXJMYW5lcyk7XG4gIH0gZWxzZSB7XG4gICAgcmVjb25jaWxlQ2hpbGRyZW4oY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIG5leHRDaGlsZHJlbiwgcmVuZGVyTGFuZXMpO1xuICB9IC8vIE1lbW9pemUgc3RhdGUgdXNpbmcgdGhlIHZhbHVlcyB3ZSBqdXN0IHVzZWQgdG8gcmVuZGVyLlxuICAvLyBUT0RPOiBSZXN0cnVjdHVyZSBzbyB3ZSBuZXZlciByZWFkIHZhbHVlcyBmcm9tIHRoZSBpbnN0YW5jZS5cblxuXG4gIHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSBpbnN0YW5jZS5zdGF0ZTsgLy8gVGhlIGNvbnRleHQgbWlnaHQgaGF2ZSBjaGFuZ2VkIHNvIHdlIG5lZWQgdG8gcmVjYWxjdWxhdGUgaXQuXG5cbiAgaWYgKGhhc0NvbnRleHQpIHtcbiAgICBpbnZhbGlkYXRlQ29udGV4dFByb3ZpZGVyKHdvcmtJblByb2dyZXNzLCBDb21wb25lbnQsIHRydWUpO1xuICB9XG5cbiAgcmV0dXJuIHdvcmtJblByb2dyZXNzLmNoaWxkO1xufVxuXG5mdW5jdGlvbiBwdXNoSG9zdFJvb3RDb250ZXh0KHdvcmtJblByb2dyZXNzKSB7XG4gIHZhciByb290ID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuXG4gIGlmIChyb290LnBlbmRpbmdDb250ZXh0KSB7XG4gICAgcHVzaFRvcExldmVsQ29udGV4dE9iamVjdCh3b3JrSW5Qcm9ncmVzcywgcm9vdC5wZW5kaW5nQ29udGV4dCwgcm9vdC5wZW5kaW5nQ29udGV4dCAhPT0gcm9vdC5jb250ZXh0KTtcbiAgfSBlbHNlIGlmIChyb290LmNvbnRleHQpIHtcbiAgICAvLyBTaG91bGQgYWx3YXlzIGJlIHNldFxuICAgIHB1c2hUb3BMZXZlbENvbnRleHRPYmplY3Qod29ya0luUHJvZ3Jlc3MsIHJvb3QuY29udGV4dCwgZmFsc2UpO1xuICB9XG5cbiAgcHVzaEhvc3RDb250YWluZXIod29ya0luUHJvZ3Jlc3MsIHJvb3QuY29udGFpbmVySW5mbyk7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUhvc3RSb290KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcykge1xuICBwdXNoSG9zdFJvb3RDb250ZXh0KHdvcmtJblByb2dyZXNzKTtcbiAgdmFyIHVwZGF0ZVF1ZXVlID0gd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWU7XG5cbiAgaWYgKCEoY3VycmVudCAhPT0gbnVsbCAmJiB1cGRhdGVRdWV1ZSAhPT0gbnVsbCkpIHtcbiAgICB7XG4gICAgICB0aHJvdyBFcnJvciggXCJJZiB0aGUgcm9vdCBkb2VzIG5vdCBoYXZlIGFuIHVwZGF0ZVF1ZXVlLCB3ZSBzaG91bGQgaGF2ZSBhbHJlYWR5IGJhaWxlZCBvdXQuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCIgKTtcbiAgICB9XG4gIH1cblxuICB2YXIgbmV4dFByb3BzID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzO1xuICB2YXIgcHJldlN0YXRlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTtcbiAgdmFyIHByZXZDaGlsZHJlbiA9IHByZXZTdGF0ZSAhPT0gbnVsbCA/IHByZXZTdGF0ZS5lbGVtZW50IDogbnVsbDtcbiAgY2xvbmVVcGRhdGVRdWV1ZShjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcyk7XG4gIHByb2Nlc3NVcGRhdGVRdWV1ZSh3b3JrSW5Qcm9ncmVzcywgbmV4dFByb3BzLCBudWxsLCByZW5kZXJMYW5lcyk7XG4gIHZhciBuZXh0U3RhdGUgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlOyAvLyBDYXV0aW9uOiBSZWFjdCBEZXZUb29scyBjdXJyZW50bHkgZGVwZW5kcyBvbiB0aGlzIHByb3BlcnR5XG4gIC8vIGJlaW5nIGNhbGxlZCBcImVsZW1lbnRcIi5cblxuICB2YXIgbmV4dENoaWxkcmVuID0gbmV4dFN0YXRlLmVsZW1lbnQ7XG5cbiAgaWYgKG5leHRDaGlsZHJlbiA9PT0gcHJldkNoaWxkcmVuKSB7XG4gICAgcmVzZXRIeWRyYXRpb25TdGF0ZSgpO1xuICAgIHJldHVybiBiYWlsb3V0T25BbHJlYWR5RmluaXNoZWRXb3JrKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcyk7XG4gIH1cblxuICB2YXIgcm9vdCA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcblxuICBpZiAocm9vdC5oeWRyYXRlICYmIGVudGVySHlkcmF0aW9uU3RhdGUod29ya0luUHJvZ3Jlc3MpKSB7XG4gICAgLy8gSWYgd2UgZG9uJ3QgaGF2ZSBhbnkgY3VycmVudCBjaGlsZHJlbiB0aGlzIG1pZ2h0IGJlIHRoZSBmaXJzdCBwYXNzLlxuICAgIC8vIFdlIGFsd2F5cyB0cnkgdG8gaHlkcmF0ZS4gSWYgdGhpcyBpc24ndCBhIGh5ZHJhdGlvbiBwYXNzIHRoZXJlIHdvbid0XG4gICAgLy8gYmUgYW55IGNoaWxkcmVuIHRvIGh5ZHJhdGUgd2hpY2ggaXMgZWZmZWN0aXZlbHkgdGhlIHNhbWUgdGhpbmcgYXNcbiAgICAvLyBub3QgaHlkcmF0aW5nLlxuICAgIHtcbiAgICAgIHZhciBtdXRhYmxlU291cmNlRWFnZXJIeWRyYXRpb25EYXRhID0gcm9vdC5tdXRhYmxlU291cmNlRWFnZXJIeWRyYXRpb25EYXRhO1xuXG4gICAgICBpZiAobXV0YWJsZVNvdXJjZUVhZ2VySHlkcmF0aW9uRGF0YSAhPSBudWxsKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbXV0YWJsZVNvdXJjZUVhZ2VySHlkcmF0aW9uRGF0YS5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgICAgIHZhciBtdXRhYmxlU291cmNlID0gbXV0YWJsZVNvdXJjZUVhZ2VySHlkcmF0aW9uRGF0YVtpXTtcbiAgICAgICAgICB2YXIgdmVyc2lvbiA9IG11dGFibGVTb3VyY2VFYWdlckh5ZHJhdGlvbkRhdGFbaSArIDFdO1xuICAgICAgICAgIHNldFdvcmtJblByb2dyZXNzVmVyc2lvbihtdXRhYmxlU291cmNlLCB2ZXJzaW9uKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBjaGlsZCA9IG1vdW50Q2hpbGRGaWJlcnMod29ya0luUHJvZ3Jlc3MsIG51bGwsIG5leHRDaGlsZHJlbiwgcmVuZGVyTGFuZXMpO1xuICAgIHdvcmtJblByb2dyZXNzLmNoaWxkID0gY2hpbGQ7XG4gICAgdmFyIG5vZGUgPSBjaGlsZDtcblxuICAgIHdoaWxlIChub2RlKSB7XG4gICAgICAvLyBNYXJrIGVhY2ggY2hpbGQgYXMgaHlkcmF0aW5nLiBUaGlzIGlzIGEgZmFzdCBwYXRoIHRvIGtub3cgd2hldGhlciB0aGlzXG4gICAgICAvLyB0cmVlIGlzIHBhcnQgb2YgYSBoeWRyYXRpbmcgdHJlZS4gVGhpcyBpcyB1c2VkIHRvIGRldGVybWluZSBpZiBhIGNoaWxkXG4gICAgICAvLyBub2RlIGhhcyBmdWxseSBtb3VudGVkIHlldCwgYW5kIGZvciBzY2hlZHVsaW5nIGV2ZW50IHJlcGxheWluZy5cbiAgICAgIC8vIENvbmNlcHR1YWxseSB0aGlzIGlzIHNpbWlsYXIgdG8gUGxhY2VtZW50IGluIHRoYXQgYSBuZXcgc3VidHJlZSBpc1xuICAgICAgLy8gaW5zZXJ0ZWQgaW50byB0aGUgUmVhY3QgdHJlZSBoZXJlLiBJdCBqdXN0IGhhcHBlbnMgdG8gbm90IG5lZWQgRE9NXG4gICAgICAvLyBtdXRhdGlvbnMgYmVjYXVzZSBpdCBhbHJlYWR5IGV4aXN0cy5cbiAgICAgIG5vZGUuZmxhZ3MgPSBub2RlLmZsYWdzICYgflBsYWNlbWVudCB8IEh5ZHJhdGluZztcbiAgICAgIG5vZGUgPSBub2RlLnNpYmxpbmc7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIE90aGVyd2lzZSByZXNldCBoeWRyYXRpb24gc3RhdGUgaW4gY2FzZSB3ZSBhYm9ydGVkIGFuZCByZXN1bWVkIGFub3RoZXJcbiAgICAvLyByb290LlxuICAgIHJlY29uY2lsZUNoaWxkcmVuKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBuZXh0Q2hpbGRyZW4sIHJlbmRlckxhbmVzKTtcbiAgICByZXNldEh5ZHJhdGlvblN0YXRlKCk7XG4gIH1cblxuICByZXR1cm4gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUhvc3RDb21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKSB7XG4gIHB1c2hIb3N0Q29udGV4dCh3b3JrSW5Qcm9ncmVzcyk7XG5cbiAgaWYgKGN1cnJlbnQgPT09IG51bGwpIHtcbiAgICB0cnlUb0NsYWltTmV4dEh5ZHJhdGFibGVJbnN0YW5jZSh3b3JrSW5Qcm9ncmVzcyk7XG4gIH1cblxuICB2YXIgdHlwZSA9IHdvcmtJblByb2dyZXNzLnR5cGU7XG4gIHZhciBuZXh0UHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHM7XG4gIHZhciBwcmV2UHJvcHMgPSBjdXJyZW50ICE9PSBudWxsID8gY3VycmVudC5tZW1vaXplZFByb3BzIDogbnVsbDtcbiAgdmFyIG5leHRDaGlsZHJlbiA9IG5leHRQcm9wcy5jaGlsZHJlbjtcbiAgdmFyIGlzRGlyZWN0VGV4dENoaWxkID0gc2hvdWxkU2V0VGV4dENvbnRlbnQodHlwZSwgbmV4dFByb3BzKTtcblxuICBpZiAoaXNEaXJlY3RUZXh0Q2hpbGQpIHtcbiAgICAvLyBXZSBzcGVjaWFsIGNhc2UgYSBkaXJlY3QgdGV4dCBjaGlsZCBvZiBhIGhvc3Qgbm9kZS4gVGhpcyBpcyBhIGNvbW1vblxuICAgIC8vIGNhc2UuIFdlIHdvbid0IGhhbmRsZSBpdCBhcyBhIHJlaWZpZWQgY2hpbGQuIFdlIHdpbGwgaW5zdGVhZCBoYW5kbGVcbiAgICAvLyB0aGlzIGluIHRoZSBob3N0IGVudmlyb25tZW50IHRoYXQgYWxzbyBoYXMgYWNjZXNzIHRvIHRoaXMgcHJvcC4gVGhhdFxuICAgIC8vIGF2b2lkcyBhbGxvY2F0aW5nIGFub3RoZXIgSG9zdFRleHQgZmliZXIgYW5kIHRyYXZlcnNpbmcgaXQuXG4gICAgbmV4dENoaWxkcmVuID0gbnVsbDtcbiAgfSBlbHNlIGlmIChwcmV2UHJvcHMgIT09IG51bGwgJiYgc2hvdWxkU2V0VGV4dENvbnRlbnQodHlwZSwgcHJldlByb3BzKSkge1xuICAgIC8vIElmIHdlJ3JlIHN3aXRjaGluZyBmcm9tIGEgZGlyZWN0IHRleHQgY2hpbGQgdG8gYSBub3JtYWwgY2hpbGQsIG9yIHRvXG4gICAgLy8gZW1wdHksIHdlIG5lZWQgdG8gc2NoZWR1bGUgdGhlIHRleHQgY29udGVudCB0byBiZSByZXNldC5cbiAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSBDb250ZW50UmVzZXQ7XG4gIH1cblxuICBtYXJrUmVmKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKTtcbiAgcmVjb25jaWxlQ2hpbGRyZW4oY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIG5leHRDaGlsZHJlbiwgcmVuZGVyTGFuZXMpO1xuICByZXR1cm4gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUhvc3RUZXh0KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKSB7XG4gIGlmIChjdXJyZW50ID09PSBudWxsKSB7XG4gICAgdHJ5VG9DbGFpbU5leHRIeWRyYXRhYmxlSW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MpO1xuICB9IC8vIE5vdGhpbmcgdG8gZG8gaGVyZS4gVGhpcyBpcyB0ZXJtaW5hbC4gV2UnbGwgZG8gdGhlIGNvbXBsZXRpb24gc3RlcFxuICAvLyBpbW1lZGlhdGVseSBhZnRlci5cblxuXG4gIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiBtb3VudExhenlDb21wb25lbnQoX2N1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBlbGVtZW50VHlwZSwgdXBkYXRlTGFuZXMsIHJlbmRlckxhbmVzKSB7XG4gIGlmIChfY3VycmVudCAhPT0gbnVsbCkge1xuICAgIC8vIEEgbGF6eSBjb21wb25lbnQgb25seSBtb3VudHMgaWYgaXQgc3VzcGVuZGVkIGluc2lkZSBhIG5vbi1cbiAgICAvLyBjb25jdXJyZW50IHRyZWUsIGluIGFuIGluY29uc2lzdGVudCBzdGF0ZS4gV2Ugd2FudCB0byB0cmVhdCBpdCBsaWtlXG4gICAgLy8gYSBuZXcgbW91bnQsIGV2ZW4gdGhvdWdoIGFuIGVtcHR5IHZlcnNpb24gb2YgaXQgYWxyZWFkeSBjb21taXR0ZWQuXG4gICAgLy8gRGlzY29ubmVjdCB0aGUgYWx0ZXJuYXRlIHBvaW50ZXJzLlxuICAgIF9jdXJyZW50LmFsdGVybmF0ZSA9IG51bGw7XG4gICAgd29ya0luUHJvZ3Jlc3MuYWx0ZXJuYXRlID0gbnVsbDsgLy8gU2luY2UgdGhpcyBpcyBjb25jZXB0dWFsbHkgYSBuZXcgZmliZXIsIHNjaGVkdWxlIGEgUGxhY2VtZW50IGVmZmVjdFxuXG4gICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gUGxhY2VtZW50O1xuICB9XG5cbiAgdmFyIHByb3BzID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzO1xuICB2YXIgbGF6eUNvbXBvbmVudCA9IGVsZW1lbnRUeXBlO1xuICB2YXIgcGF5bG9hZCA9IGxhenlDb21wb25lbnQuX3BheWxvYWQ7XG4gIHZhciBpbml0ID0gbGF6eUNvbXBvbmVudC5faW5pdDtcbiAgdmFyIENvbXBvbmVudCA9IGluaXQocGF5bG9hZCk7IC8vIFN0b3JlIHRoZSB1bndyYXBwZWQgY29tcG9uZW50IGluIHRoZSB0eXBlLlxuXG4gIHdvcmtJblByb2dyZXNzLnR5cGUgPSBDb21wb25lbnQ7XG4gIHZhciByZXNvbHZlZFRhZyA9IHdvcmtJblByb2dyZXNzLnRhZyA9IHJlc29sdmVMYXp5Q29tcG9uZW50VGFnKENvbXBvbmVudCk7XG4gIHZhciByZXNvbHZlZFByb3BzID0gcmVzb2x2ZURlZmF1bHRQcm9wcyhDb21wb25lbnQsIHByb3BzKTtcbiAgdmFyIGNoaWxkO1xuXG4gIHN3aXRjaCAocmVzb2x2ZWRUYWcpIHtcbiAgICBjYXNlIEZ1bmN0aW9uQ29tcG9uZW50OlxuICAgICAge1xuICAgICAgICB7XG4gICAgICAgICAgdmFsaWRhdGVGdW5jdGlvbkNvbXBvbmVudEluRGV2KHdvcmtJblByb2dyZXNzLCBDb21wb25lbnQpO1xuICAgICAgICAgIHdvcmtJblByb2dyZXNzLnR5cGUgPSBDb21wb25lbnQgPSByZXNvbHZlRnVuY3Rpb25Gb3JIb3RSZWxvYWRpbmcoQ29tcG9uZW50KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNoaWxkID0gdXBkYXRlRnVuY3Rpb25Db21wb25lbnQobnVsbCwgd29ya0luUHJvZ3Jlc3MsIENvbXBvbmVudCwgcmVzb2x2ZWRQcm9wcywgcmVuZGVyTGFuZXMpO1xuICAgICAgICByZXR1cm4gY2hpbGQ7XG4gICAgICB9XG5cbiAgICBjYXNlIENsYXNzQ29tcG9uZW50OlxuICAgICAge1xuICAgICAgICB7XG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3MudHlwZSA9IENvbXBvbmVudCA9IHJlc29sdmVDbGFzc0ZvckhvdFJlbG9hZGluZyhDb21wb25lbnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgY2hpbGQgPSB1cGRhdGVDbGFzc0NvbXBvbmVudChudWxsLCB3b3JrSW5Qcm9ncmVzcywgQ29tcG9uZW50LCByZXNvbHZlZFByb3BzLCByZW5kZXJMYW5lcyk7XG4gICAgICAgIHJldHVybiBjaGlsZDtcbiAgICAgIH1cblxuICAgIGNhc2UgRm9yd2FyZFJlZjpcbiAgICAgIHtcbiAgICAgICAge1xuICAgICAgICAgIHdvcmtJblByb2dyZXNzLnR5cGUgPSBDb21wb25lbnQgPSByZXNvbHZlRm9yd2FyZFJlZkZvckhvdFJlbG9hZGluZyhDb21wb25lbnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgY2hpbGQgPSB1cGRhdGVGb3J3YXJkUmVmKG51bGwsIHdvcmtJblByb2dyZXNzLCBDb21wb25lbnQsIHJlc29sdmVkUHJvcHMsIHJlbmRlckxhbmVzKTtcbiAgICAgICAgcmV0dXJuIGNoaWxkO1xuICAgICAgfVxuXG4gICAgY2FzZSBNZW1vQ29tcG9uZW50OlxuICAgICAge1xuICAgICAgICB7XG4gICAgICAgICAgaWYgKHdvcmtJblByb2dyZXNzLnR5cGUgIT09IHdvcmtJblByb2dyZXNzLmVsZW1lbnRUeXBlKSB7XG4gICAgICAgICAgICB2YXIgb3V0ZXJQcm9wVHlwZXMgPSBDb21wb25lbnQucHJvcFR5cGVzO1xuXG4gICAgICAgICAgICBpZiAob3V0ZXJQcm9wVHlwZXMpIHtcbiAgICAgICAgICAgICAgY2hlY2tQcm9wVHlwZXMob3V0ZXJQcm9wVHlwZXMsIHJlc29sdmVkUHJvcHMsIC8vIFJlc29sdmVkIGZvciBvdXRlciBvbmx5XG4gICAgICAgICAgICAgICdwcm9wJywgZ2V0Q29tcG9uZW50TmFtZShDb21wb25lbnQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjaGlsZCA9IHVwZGF0ZU1lbW9Db21wb25lbnQobnVsbCwgd29ya0luUHJvZ3Jlc3MsIENvbXBvbmVudCwgcmVzb2x2ZURlZmF1bHRQcm9wcyhDb21wb25lbnQudHlwZSwgcmVzb2x2ZWRQcm9wcyksIC8vIFRoZSBpbm5lciB0eXBlIGNhbiBoYXZlIGRlZmF1bHRzIHRvb1xuICAgICAgICB1cGRhdGVMYW5lcywgcmVuZGVyTGFuZXMpO1xuICAgICAgICByZXR1cm4gY2hpbGQ7XG4gICAgICB9XG4gIH1cblxuICB2YXIgaGludCA9ICcnO1xuXG4gIHtcbiAgICBpZiAoQ29tcG9uZW50ICE9PSBudWxsICYmIHR5cGVvZiBDb21wb25lbnQgPT09ICdvYmplY3QnICYmIENvbXBvbmVudC4kJHR5cGVvZiA9PT0gUkVBQ1RfTEFaWV9UWVBFKSB7XG4gICAgICBoaW50ID0gJyBEaWQgeW91IHdyYXAgYSBjb21wb25lbnQgaW4gUmVhY3QubGF6eSgpIG1vcmUgdGhhbiBvbmNlPyc7XG4gICAgfVxuICB9IC8vIFRoaXMgbWVzc2FnZSBpbnRlbnRpb25hbGx5IGRvZXNuJ3QgbWVudGlvbiBGb3J3YXJkUmVmIG9yIE1lbW9Db21wb25lbnRcbiAgLy8gYmVjYXVzZSB0aGUgZmFjdCB0aGF0IGl0J3MgYSBzZXBhcmF0ZSB0eXBlIG9mIHdvcmsgaXMgYW5cbiAgLy8gaW1wbGVtZW50YXRpb24gZGV0YWlsLlxuXG5cbiAge1xuICAgIHtcbiAgICAgIHRocm93IEVycm9yKCBcIkVsZW1lbnQgdHlwZSBpcyBpbnZhbGlkLiBSZWNlaXZlZCBhIHByb21pc2UgdGhhdCByZXNvbHZlcyB0bzogXCIgKyBDb21wb25lbnQgKyBcIi4gTGF6eSBlbGVtZW50IHR5cGUgbXVzdCByZXNvbHZlIHRvIGEgY2xhc3Mgb3IgZnVuY3Rpb24uXCIgKyBoaW50ICk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIG1vdW50SW5jb21wbGV0ZUNsYXNzQ29tcG9uZW50KF9jdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgQ29tcG9uZW50LCBuZXh0UHJvcHMsIHJlbmRlckxhbmVzKSB7XG4gIGlmIChfY3VycmVudCAhPT0gbnVsbCkge1xuICAgIC8vIEFuIGluY29tcGxldGUgY29tcG9uZW50IG9ubHkgbW91bnRzIGlmIGl0IHN1c3BlbmRlZCBpbnNpZGUgYSBub24tXG4gICAgLy8gY29uY3VycmVudCB0cmVlLCBpbiBhbiBpbmNvbnNpc3RlbnQgc3RhdGUuIFdlIHdhbnQgdG8gdHJlYXQgaXQgbGlrZVxuICAgIC8vIGEgbmV3IG1vdW50LCBldmVuIHRob3VnaCBhbiBlbXB0eSB2ZXJzaW9uIG9mIGl0IGFscmVhZHkgY29tbWl0dGVkLlxuICAgIC8vIERpc2Nvbm5lY3QgdGhlIGFsdGVybmF0ZSBwb2ludGVycy5cbiAgICBfY3VycmVudC5hbHRlcm5hdGUgPSBudWxsO1xuICAgIHdvcmtJblByb2dyZXNzLmFsdGVybmF0ZSA9IG51bGw7IC8vIFNpbmNlIHRoaXMgaXMgY29uY2VwdHVhbGx5IGEgbmV3IGZpYmVyLCBzY2hlZHVsZSBhIFBsYWNlbWVudCBlZmZlY3RcblxuICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IFBsYWNlbWVudDtcbiAgfSAvLyBQcm9tb3RlIHRoZSBmaWJlciB0byBhIGNsYXNzIGFuZCB0cnkgcmVuZGVyaW5nIGFnYWluLlxuXG5cbiAgd29ya0luUHJvZ3Jlc3MudGFnID0gQ2xhc3NDb21wb25lbnQ7IC8vIFRoZSByZXN0IG9mIHRoaXMgZnVuY3Rpb24gaXMgYSBmb3JrIG9mIGB1cGRhdGVDbGFzc0NvbXBvbmVudGBcbiAgLy8gUHVzaCBjb250ZXh0IHByb3ZpZGVycyBlYXJseSB0byBwcmV2ZW50IGNvbnRleHQgc3RhY2sgbWlzbWF0Y2hlcy5cbiAgLy8gRHVyaW5nIG1vdW50aW5nIHdlIGRvbid0IGtub3cgdGhlIGNoaWxkIGNvbnRleHQgeWV0IGFzIHRoZSBpbnN0YW5jZSBkb2Vzbid0IGV4aXN0LlxuICAvLyBXZSB3aWxsIGludmFsaWRhdGUgdGhlIGNoaWxkIGNvbnRleHQgaW4gZmluaXNoQ2xhc3NDb21wb25lbnQoKSByaWdodCBhZnRlciByZW5kZXJpbmcuXG5cbiAgdmFyIGhhc0NvbnRleHQ7XG5cbiAgaWYgKGlzQ29udGV4dFByb3ZpZGVyKENvbXBvbmVudCkpIHtcbiAgICBoYXNDb250ZXh0ID0gdHJ1ZTtcbiAgICBwdXNoQ29udGV4dFByb3ZpZGVyKHdvcmtJblByb2dyZXNzKTtcbiAgfSBlbHNlIHtcbiAgICBoYXNDb250ZXh0ID0gZmFsc2U7XG4gIH1cblxuICBwcmVwYXJlVG9SZWFkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpO1xuICBjb25zdHJ1Y3RDbGFzc0luc3RhbmNlKHdvcmtJblByb2dyZXNzLCBDb21wb25lbnQsIG5leHRQcm9wcyk7XG4gIG1vdW50Q2xhc3NJbnN0YW5jZSh3b3JrSW5Qcm9ncmVzcywgQ29tcG9uZW50LCBuZXh0UHJvcHMsIHJlbmRlckxhbmVzKTtcbiAgcmV0dXJuIGZpbmlzaENsYXNzQ29tcG9uZW50KG51bGwsIHdvcmtJblByb2dyZXNzLCBDb21wb25lbnQsIHRydWUsIGhhc0NvbnRleHQsIHJlbmRlckxhbmVzKTtcbn1cblxuZnVuY3Rpb24gbW91bnRJbmRldGVybWluYXRlQ29tcG9uZW50KF9jdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgQ29tcG9uZW50LCByZW5kZXJMYW5lcykge1xuICBpZiAoX2N1cnJlbnQgIT09IG51bGwpIHtcbiAgICAvLyBBbiBpbmRldGVybWluYXRlIGNvbXBvbmVudCBvbmx5IG1vdW50cyBpZiBpdCBzdXNwZW5kZWQgaW5zaWRlIGEgbm9uLVxuICAgIC8vIGNvbmN1cnJlbnQgdHJlZSwgaW4gYW4gaW5jb25zaXN0ZW50IHN0YXRlLiBXZSB3YW50IHRvIHRyZWF0IGl0IGxpa2VcbiAgICAvLyBhIG5ldyBtb3VudCwgZXZlbiB0aG91Z2ggYW4gZW1wdHkgdmVyc2lvbiBvZiBpdCBhbHJlYWR5IGNvbW1pdHRlZC5cbiAgICAvLyBEaXNjb25uZWN0IHRoZSBhbHRlcm5hdGUgcG9pbnRlcnMuXG4gICAgX2N1cnJlbnQuYWx0ZXJuYXRlID0gbnVsbDtcbiAgICB3b3JrSW5Qcm9ncmVzcy5hbHRlcm5hdGUgPSBudWxsOyAvLyBTaW5jZSB0aGlzIGlzIGNvbmNlcHR1YWxseSBhIG5ldyBmaWJlciwgc2NoZWR1bGUgYSBQbGFjZW1lbnQgZWZmZWN0XG5cbiAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSBQbGFjZW1lbnQ7XG4gIH1cblxuICB2YXIgcHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHM7XG4gIHZhciBjb250ZXh0O1xuXG4gIHtcbiAgICB2YXIgdW5tYXNrZWRDb250ZXh0ID0gZ2V0VW5tYXNrZWRDb250ZXh0KHdvcmtJblByb2dyZXNzLCBDb21wb25lbnQsIGZhbHNlKTtcbiAgICBjb250ZXh0ID0gZ2V0TWFza2VkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgdW5tYXNrZWRDb250ZXh0KTtcbiAgfVxuXG4gIHByZXBhcmVUb1JlYWRDb250ZXh0KHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcyk7XG4gIHZhciB2YWx1ZTtcblxuICB7XG4gICAgaWYgKENvbXBvbmVudC5wcm90b3R5cGUgJiYgdHlwZW9mIENvbXBvbmVudC5wcm90b3R5cGUucmVuZGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB2YXIgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWUoQ29tcG9uZW50KSB8fCAnVW5rbm93bic7XG5cbiAgICAgIGlmICghZGlkV2FybkFib3V0QmFkQ2xhc3NbY29tcG9uZW50TmFtZV0pIHtcbiAgICAgICAgZXJyb3IoXCJUaGUgPCVzIC8+IGNvbXBvbmVudCBhcHBlYXJzIHRvIGhhdmUgYSByZW5kZXIgbWV0aG9kLCBidXQgZG9lc24ndCBleHRlbmQgUmVhY3QuQ29tcG9uZW50LiBcIiArICdUaGlzIGlzIGxpa2VseSB0byBjYXVzZSBlcnJvcnMuIENoYW5nZSAlcyB0byBleHRlbmQgUmVhY3QuQ29tcG9uZW50IGluc3RlYWQuJywgY29tcG9uZW50TmFtZSwgY29tcG9uZW50TmFtZSk7XG5cbiAgICAgICAgZGlkV2FybkFib3V0QmFkQ2xhc3NbY29tcG9uZW50TmFtZV0gPSB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh3b3JrSW5Qcm9ncmVzcy5tb2RlICYgU3RyaWN0TW9kZSkge1xuICAgICAgUmVhY3RTdHJpY3RNb2RlV2FybmluZ3MucmVjb3JkTGVnYWN5Q29udGV4dFdhcm5pbmcod29ya0luUHJvZ3Jlc3MsIG51bGwpO1xuICAgIH1cblxuICAgIHNldElzUmVuZGVyaW5nKHRydWUpO1xuICAgIFJlYWN0Q3VycmVudE93bmVyJDEuY3VycmVudCA9IHdvcmtJblByb2dyZXNzO1xuICAgIHZhbHVlID0gcmVuZGVyV2l0aEhvb2tzKG51bGwsIHdvcmtJblByb2dyZXNzLCBDb21wb25lbnQsIHByb3BzLCBjb250ZXh0LCByZW5kZXJMYW5lcyk7XG4gICAgc2V0SXNSZW5kZXJpbmcoZmFsc2UpO1xuICB9IC8vIFJlYWN0IERldlRvb2xzIHJlYWRzIHRoaXMgZmxhZy5cblxuXG4gIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IFBlcmZvcm1lZFdvcms7XG5cbiAge1xuICAgIC8vIFN1cHBvcnQgZm9yIG1vZHVsZSBjb21wb25lbnRzIGlzIGRlcHJlY2F0ZWQgYW5kIGlzIHJlbW92ZWQgYmVoaW5kIGEgZmxhZy5cbiAgICAvLyBXaGV0aGVyIG9yIG5vdCBpdCB3b3VsZCBjcmFzaCBsYXRlciwgd2Ugd2FudCB0byBzaG93IGEgZ29vZCBtZXNzYWdlIGluIERFViBmaXJzdC5cbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAhPT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUucmVuZGVyID09PSAnZnVuY3Rpb24nICYmIHZhbHVlLiQkdHlwZW9mID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHZhciBfY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWUoQ29tcG9uZW50KSB8fCAnVW5rbm93bic7XG5cbiAgICAgIGlmICghZGlkV2FybkFib3V0TW9kdWxlUGF0dGVybkNvbXBvbmVudFtfY29tcG9uZW50TmFtZV0pIHtcbiAgICAgICAgZXJyb3IoJ1RoZSA8JXMgLz4gY29tcG9uZW50IGFwcGVhcnMgdG8gYmUgYSBmdW5jdGlvbiBjb21wb25lbnQgdGhhdCByZXR1cm5zIGEgY2xhc3MgaW5zdGFuY2UuICcgKyAnQ2hhbmdlICVzIHRvIGEgY2xhc3MgdGhhdCBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCBpbnN0ZWFkLiAnICsgXCJJZiB5b3UgY2FuJ3QgdXNlIGEgY2xhc3MgdHJ5IGFzc2lnbmluZyB0aGUgcHJvdG90eXBlIG9uIHRoZSBmdW5jdGlvbiBhcyBhIHdvcmthcm91bmQuIFwiICsgXCJgJXMucHJvdG90eXBlID0gUmVhY3QuQ29tcG9uZW50LnByb3RvdHlwZWAuIERvbid0IHVzZSBhbiBhcnJvdyBmdW5jdGlvbiBzaW5jZSBpdCBcIiArICdjYW5ub3QgYmUgY2FsbGVkIHdpdGggYG5ld2AgYnkgUmVhY3QuJywgX2NvbXBvbmVudE5hbWUsIF9jb21wb25lbnROYW1lLCBfY29tcG9uZW50TmFtZSk7XG5cbiAgICAgICAgZGlkV2FybkFib3V0TW9kdWxlUGF0dGVybkNvbXBvbmVudFtfY29tcG9uZW50TmFtZV0gPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmICggLy8gUnVuIHRoZXNlIGNoZWNrcyBpbiBwcm9kdWN0aW9uIG9ubHkgaWYgdGhlIGZsYWcgaXMgb2ZmLlxuICAvLyBFdmVudHVhbGx5IHdlJ2xsIGRlbGV0ZSB0aGlzIGJyYW5jaCBhbHRvZ2V0aGVyLlxuICAgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAhPT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUucmVuZGVyID09PSAnZnVuY3Rpb24nICYmIHZhbHVlLiQkdHlwZW9mID09PSB1bmRlZmluZWQpIHtcbiAgICB7XG4gICAgICB2YXIgX2NvbXBvbmVudE5hbWUyID0gZ2V0Q29tcG9uZW50TmFtZShDb21wb25lbnQpIHx8ICdVbmtub3duJztcblxuICAgICAgaWYgKCFkaWRXYXJuQWJvdXRNb2R1bGVQYXR0ZXJuQ29tcG9uZW50W19jb21wb25lbnROYW1lMl0pIHtcbiAgICAgICAgZXJyb3IoJ1RoZSA8JXMgLz4gY29tcG9uZW50IGFwcGVhcnMgdG8gYmUgYSBmdW5jdGlvbiBjb21wb25lbnQgdGhhdCByZXR1cm5zIGEgY2xhc3MgaW5zdGFuY2UuICcgKyAnQ2hhbmdlICVzIHRvIGEgY2xhc3MgdGhhdCBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCBpbnN0ZWFkLiAnICsgXCJJZiB5b3UgY2FuJ3QgdXNlIGEgY2xhc3MgdHJ5IGFzc2lnbmluZyB0aGUgcHJvdG90eXBlIG9uIHRoZSBmdW5jdGlvbiBhcyBhIHdvcmthcm91bmQuIFwiICsgXCJgJXMucHJvdG90eXBlID0gUmVhY3QuQ29tcG9uZW50LnByb3RvdHlwZWAuIERvbid0IHVzZSBhbiBhcnJvdyBmdW5jdGlvbiBzaW5jZSBpdCBcIiArICdjYW5ub3QgYmUgY2FsbGVkIHdpdGggYG5ld2AgYnkgUmVhY3QuJywgX2NvbXBvbmVudE5hbWUyLCBfY29tcG9uZW50TmFtZTIsIF9jb21wb25lbnROYW1lMik7XG5cbiAgICAgICAgZGlkV2FybkFib3V0TW9kdWxlUGF0dGVybkNvbXBvbmVudFtfY29tcG9uZW50TmFtZTJdID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9IC8vIFByb2NlZWQgdW5kZXIgdGhlIGFzc3VtcHRpb24gdGhhdCB0aGlzIGlzIGEgY2xhc3MgaW5zdGFuY2VcblxuXG4gICAgd29ya0luUHJvZ3Jlc3MudGFnID0gQ2xhc3NDb21wb25lbnQ7IC8vIFRocm93IG91dCBhbnkgaG9va3MgdGhhdCB3ZXJlIHVzZWQuXG5cbiAgICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID0gbnVsbDtcbiAgICB3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZSA9IG51bGw7IC8vIFB1c2ggY29udGV4dCBwcm92aWRlcnMgZWFybHkgdG8gcHJldmVudCBjb250ZXh0IHN0YWNrIG1pc21hdGNoZXMuXG4gICAgLy8gRHVyaW5nIG1vdW50aW5nIHdlIGRvbid0IGtub3cgdGhlIGNoaWxkIGNvbnRleHQgeWV0IGFzIHRoZSBpbnN0YW5jZSBkb2Vzbid0IGV4aXN0LlxuICAgIC8vIFdlIHdpbGwgaW52YWxpZGF0ZSB0aGUgY2hpbGQgY29udGV4dCBpbiBmaW5pc2hDbGFzc0NvbXBvbmVudCgpIHJpZ2h0IGFmdGVyIHJlbmRlcmluZy5cblxuICAgIHZhciBoYXNDb250ZXh0ID0gZmFsc2U7XG5cbiAgICBpZiAoaXNDb250ZXh0UHJvdmlkZXIoQ29tcG9uZW50KSkge1xuICAgICAgaGFzQ29udGV4dCA9IHRydWU7XG4gICAgICBwdXNoQ29udGV4dFByb3ZpZGVyKHdvcmtJblByb2dyZXNzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaGFzQ29udGV4dCA9IGZhbHNlO1xuICAgIH1cblxuICAgIHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSB2YWx1ZS5zdGF0ZSAhPT0gbnVsbCAmJiB2YWx1ZS5zdGF0ZSAhPT0gdW5kZWZpbmVkID8gdmFsdWUuc3RhdGUgOiBudWxsO1xuICAgIGluaXRpYWxpemVVcGRhdGVRdWV1ZSh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgdmFyIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyA9IENvbXBvbmVudC5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHM7XG5cbiAgICBpZiAodHlwZW9mIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgYXBwbHlEZXJpdmVkU3RhdGVGcm9tUHJvcHMod29ya0luUHJvZ3Jlc3MsIENvbXBvbmVudCwgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzLCBwcm9wcyk7XG4gICAgfVxuXG4gICAgYWRvcHRDbGFzc0luc3RhbmNlKHdvcmtJblByb2dyZXNzLCB2YWx1ZSk7XG4gICAgbW91bnRDbGFzc0luc3RhbmNlKHdvcmtJblByb2dyZXNzLCBDb21wb25lbnQsIHByb3BzLCByZW5kZXJMYW5lcyk7XG4gICAgcmV0dXJuIGZpbmlzaENsYXNzQ29tcG9uZW50KG51bGwsIHdvcmtJblByb2dyZXNzLCBDb21wb25lbnQsIHRydWUsIGhhc0NvbnRleHQsIHJlbmRlckxhbmVzKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBQcm9jZWVkIHVuZGVyIHRoZSBhc3N1bXB0aW9uIHRoYXQgdGhpcyBpcyBhIGZ1bmN0aW9uIGNvbXBvbmVudFxuICAgIHdvcmtJblByb2dyZXNzLnRhZyA9IEZ1bmN0aW9uQ29tcG9uZW50O1xuXG4gICAge1xuXG4gICAgICBpZiAoIHdvcmtJblByb2dyZXNzLm1vZGUgJiBTdHJpY3RNb2RlKSB7XG4gICAgICAgIGRpc2FibGVMb2dzKCk7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB2YWx1ZSA9IHJlbmRlcldpdGhIb29rcyhudWxsLCB3b3JrSW5Qcm9ncmVzcywgQ29tcG9uZW50LCBwcm9wcywgY29udGV4dCwgcmVuZGVyTGFuZXMpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIHJlZW5hYmxlTG9ncygpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmVjb25jaWxlQ2hpbGRyZW4obnVsbCwgd29ya0luUHJvZ3Jlc3MsIHZhbHVlLCByZW5kZXJMYW5lcyk7XG5cbiAgICB7XG4gICAgICB2YWxpZGF0ZUZ1bmN0aW9uQ29tcG9uZW50SW5EZXYod29ya0luUHJvZ3Jlc3MsIENvbXBvbmVudCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHdvcmtJblByb2dyZXNzLmNoaWxkO1xuICB9XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlRnVuY3Rpb25Db21wb25lbnRJbkRldih3b3JrSW5Qcm9ncmVzcywgQ29tcG9uZW50KSB7XG4gIHtcbiAgICBpZiAoQ29tcG9uZW50KSB7XG4gICAgICBpZiAoQ29tcG9uZW50LmNoaWxkQ29udGV4dFR5cGVzKSB7XG4gICAgICAgIGVycm9yKCclcyguLi4pOiBjaGlsZENvbnRleHRUeXBlcyBjYW5ub3QgYmUgZGVmaW5lZCBvbiBhIGZ1bmN0aW9uIGNvbXBvbmVudC4nLCBDb21wb25lbnQuZGlzcGxheU5hbWUgfHwgQ29tcG9uZW50Lm5hbWUgfHwgJ0NvbXBvbmVudCcpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh3b3JrSW5Qcm9ncmVzcy5yZWYgIT09IG51bGwpIHtcbiAgICAgIHZhciBpbmZvID0gJyc7XG4gICAgICB2YXIgb3duZXJOYW1lID0gZ2V0Q3VycmVudEZpYmVyT3duZXJOYW1lSW5EZXZPck51bGwoKTtcblxuICAgICAgaWYgKG93bmVyTmFtZSkge1xuICAgICAgICBpbmZvICs9ICdcXG5cXG5DaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiBgJyArIG93bmVyTmFtZSArICdgLic7XG4gICAgICB9XG5cbiAgICAgIHZhciB3YXJuaW5nS2V5ID0gb3duZXJOYW1lIHx8IHdvcmtJblByb2dyZXNzLl9kZWJ1Z0lEIHx8ICcnO1xuICAgICAgdmFyIGRlYnVnU291cmNlID0gd29ya0luUHJvZ3Jlc3MuX2RlYnVnU291cmNlO1xuXG4gICAgICBpZiAoZGVidWdTb3VyY2UpIHtcbiAgICAgICAgd2FybmluZ0tleSA9IGRlYnVnU291cmNlLmZpbGVOYW1lICsgJzonICsgZGVidWdTb3VyY2UubGluZU51bWJlcjtcbiAgICAgIH1cblxuICAgICAgaWYgKCFkaWRXYXJuQWJvdXRGdW5jdGlvblJlZnNbd2FybmluZ0tleV0pIHtcbiAgICAgICAgZGlkV2FybkFib3V0RnVuY3Rpb25SZWZzW3dhcm5pbmdLZXldID0gdHJ1ZTtcblxuICAgICAgICBlcnJvcignRnVuY3Rpb24gY29tcG9uZW50cyBjYW5ub3QgYmUgZ2l2ZW4gcmVmcy4gJyArICdBdHRlbXB0cyB0byBhY2Nlc3MgdGhpcyByZWYgd2lsbCBmYWlsLiAnICsgJ0RpZCB5b3UgbWVhbiB0byB1c2UgUmVhY3QuZm9yd2FyZFJlZigpPyVzJywgaW5mbyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBDb21wb25lbnQuZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB2YXIgX2NvbXBvbmVudE5hbWUzID0gZ2V0Q29tcG9uZW50TmFtZShDb21wb25lbnQpIHx8ICdVbmtub3duJztcblxuICAgICAgaWYgKCFkaWRXYXJuQWJvdXRHZXREZXJpdmVkU3RhdGVPbkZ1bmN0aW9uQ29tcG9uZW50W19jb21wb25lbnROYW1lM10pIHtcbiAgICAgICAgZXJyb3IoJyVzOiBGdW5jdGlvbiBjb21wb25lbnRzIGRvIG5vdCBzdXBwb3J0IGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcy4nLCBfY29tcG9uZW50TmFtZTMpO1xuXG4gICAgICAgIGRpZFdhcm5BYm91dEdldERlcml2ZWRTdGF0ZU9uRnVuY3Rpb25Db21wb25lbnRbX2NvbXBvbmVudE5hbWUzXSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBDb21wb25lbnQuY29udGV4dFR5cGUgPT09ICdvYmplY3QnICYmIENvbXBvbmVudC5jb250ZXh0VHlwZSAhPT0gbnVsbCkge1xuICAgICAgdmFyIF9jb21wb25lbnROYW1lNCA9IGdldENvbXBvbmVudE5hbWUoQ29tcG9uZW50KSB8fCAnVW5rbm93bic7XG5cbiAgICAgIGlmICghZGlkV2FybkFib3V0Q29udGV4dFR5cGVPbkZ1bmN0aW9uQ29tcG9uZW50W19jb21wb25lbnROYW1lNF0pIHtcbiAgICAgICAgZXJyb3IoJyVzOiBGdW5jdGlvbiBjb21wb25lbnRzIGRvIG5vdCBzdXBwb3J0IGNvbnRleHRUeXBlLicsIF9jb21wb25lbnROYW1lNCk7XG5cbiAgICAgICAgZGlkV2FybkFib3V0Q29udGV4dFR5cGVPbkZ1bmN0aW9uQ29tcG9uZW50W19jb21wb25lbnROYW1lNF0gPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG52YXIgU1VTUEVOREVEX01BUktFUiA9IHtcbiAgZGVoeWRyYXRlZDogbnVsbCxcbiAgcmV0cnlMYW5lOiBOb0xhbmVcbn07XG5cbmZ1bmN0aW9uIG1vdW50U3VzcGVuc2VPZmZzY3JlZW5TdGF0ZShyZW5kZXJMYW5lcykge1xuICByZXR1cm4ge1xuICAgIGJhc2VMYW5lczogcmVuZGVyTGFuZXNcbiAgfTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlU3VzcGVuc2VPZmZzY3JlZW5TdGF0ZShwcmV2T2Zmc2NyZWVuU3RhdGUsIHJlbmRlckxhbmVzKSB7XG4gIHJldHVybiB7XG4gICAgYmFzZUxhbmVzOiBtZXJnZUxhbmVzKHByZXZPZmZzY3JlZW5TdGF0ZS5iYXNlTGFuZXMsIHJlbmRlckxhbmVzKVxuICB9O1xufSAvLyBUT0RPOiBQcm9iYWJseSBzaG91bGQgaW5saW5lIHRoaXMgYmFja1xuXG5cbmZ1bmN0aW9uIHNob3VsZFJlbWFpbk9uRmFsbGJhY2soc3VzcGVuc2VDb250ZXh0LCBjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpIHtcbiAgLy8gSWYgd2UncmUgYWxyZWFkeSBzaG93aW5nIGEgZmFsbGJhY2ssIHRoZXJlIGFyZSBjYXNlcyB3aGVyZSB3ZSBuZWVkIHRvXG4gIC8vIHJlbWFpbiBvbiB0aGF0IGZhbGxiYWNrIHJlZ2FyZGxlc3Mgb2Ygd2hldGhlciB0aGUgY29udGVudCBoYXMgcmVzb2x2ZWQuXG4gIC8vIEZvciBleGFtcGxlLCBTdXNwZW5zZUxpc3QgY29vcmRpbmF0ZXMgd2hlbiBuZXN0ZWQgY29udGVudCBhcHBlYXJzLlxuICBpZiAoY3VycmVudCAhPT0gbnVsbCkge1xuICAgIHZhciBzdXNwZW5zZVN0YXRlID0gY3VycmVudC5tZW1vaXplZFN0YXRlO1xuXG4gICAgaWYgKHN1c3BlbnNlU3RhdGUgPT09IG51bGwpIHtcbiAgICAgIC8vIEN1cnJlbnRseSBzaG93aW5nIGNvbnRlbnQuIERvbid0IGhpZGUgaXQsIGV2ZW4gaWYgRm9yY2VTdXNwZW5zZUZhbGxhY2tcbiAgICAgIC8vIGlzIHRydWUuIE1vcmUgcHJlY2lzZSBuYW1lIG1pZ2h0IGJlIFwiRm9yY2VSZW1haW5TdXNwZW5zZUZhbGxiYWNrXCIuXG4gICAgICAvLyBOb3RlOiBUaGlzIGlzIGEgZmFjdG9yaW5nIHNtZWxsLiBDYW4ndCByZW1haW4gb24gYSBmYWxsYmFjayBpZiB0aGVyZSdzXG4gICAgICAvLyBubyBmYWxsYmFjayB0byByZW1haW4gb24uXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9IC8vIE5vdCBjdXJyZW50bHkgc2hvd2luZyBjb250ZW50LiBDb25zdWx0IHRoZSBTdXNwZW5zZSBjb250ZXh0LlxuXG5cbiAgcmV0dXJuIGhhc1N1c3BlbnNlQ29udGV4dChzdXNwZW5zZUNvbnRleHQsIEZvcmNlU3VzcGVuc2VGYWxsYmFjayk7XG59XG5cbmZ1bmN0aW9uIGdldFJlbWFpbmluZ1dvcmtJblByaW1hcnlUcmVlKGN1cnJlbnQsIHJlbmRlckxhbmVzKSB7XG4gIC8vIFRPRE86IFNob3VsZCBub3QgcmVtb3ZlIHJlbmRlciBsYW5lcyB0aGF0IHdlcmUgcGluZ2VkIGR1cmluZyB0aGlzIHJlbmRlclxuICByZXR1cm4gcmVtb3ZlTGFuZXMoY3VycmVudC5jaGlsZExhbmVzLCByZW5kZXJMYW5lcyk7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZVN1c3BlbnNlQ29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcykge1xuICB2YXIgbmV4dFByb3BzID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzOyAvLyBUaGlzIGlzIHVzZWQgYnkgRGV2VG9vbHMgdG8gZm9yY2UgYSBib3VuZGFyeSB0byBzdXNwZW5kLlxuXG4gIHtcbiAgICBpZiAoc2hvdWxkU3VzcGVuZCh3b3JrSW5Qcm9ncmVzcykpIHtcbiAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IERpZENhcHR1cmU7XG4gICAgfVxuICB9XG5cbiAgdmFyIHN1c3BlbnNlQ29udGV4dCA9IHN1c3BlbnNlU3RhY2tDdXJzb3IuY3VycmVudDtcbiAgdmFyIHNob3dGYWxsYmFjayA9IGZhbHNlO1xuICB2YXIgZGlkU3VzcGVuZCA9ICh3b3JrSW5Qcm9ncmVzcy5mbGFncyAmIERpZENhcHR1cmUpICE9PSBOb0ZsYWdzO1xuXG4gIGlmIChkaWRTdXNwZW5kIHx8IHNob3VsZFJlbWFpbk9uRmFsbGJhY2soc3VzcGVuc2VDb250ZXh0LCBjdXJyZW50KSkge1xuICAgIC8vIFNvbWV0aGluZyBpbiB0aGlzIGJvdW5kYXJ5J3Mgc3VidHJlZSBhbHJlYWR5IHN1c3BlbmRlZC4gU3dpdGNoIHRvXG4gICAgLy8gcmVuZGVyaW5nIHRoZSBmYWxsYmFjayBjaGlsZHJlbi5cbiAgICBzaG93RmFsbGJhY2sgPSB0cnVlO1xuICAgIHdvcmtJblByb2dyZXNzLmZsYWdzICY9IH5EaWRDYXB0dXJlO1xuICB9IGVsc2Uge1xuICAgIC8vIEF0dGVtcHRpbmcgdGhlIG1haW4gY29udGVudFxuICAgIGlmIChjdXJyZW50ID09PSBudWxsIHx8IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZSAhPT0gbnVsbCkge1xuICAgICAgLy8gVGhpcyBpcyBhIG5ldyBtb3VudCBvciB0aGlzIGJvdW5kYXJ5IGlzIGFscmVhZHkgc2hvd2luZyBhIGZhbGxiYWNrIHN0YXRlLlxuICAgICAgLy8gTWFyayB0aGlzIHN1YnRyZWUgY29udGV4dCBhcyBoYXZpbmcgYXQgbGVhc3Qgb25lIGludmlzaWJsZSBwYXJlbnQgdGhhdCBjb3VsZFxuICAgICAgLy8gaGFuZGxlIHRoZSBmYWxsYmFjayBzdGF0ZS5cbiAgICAgIC8vIEJvdW5kYXJpZXMgd2l0aG91dCBmYWxsYmFja3Mgb3Igc2hvdWxkIGJlIGF2b2lkZWQgYXJlIG5vdCBjb25zaWRlcmVkIHNpbmNlXG4gICAgICAvLyB0aGV5IGNhbm5vdCBoYW5kbGUgcHJlZmVycmVkIGZhbGxiYWNrIHN0YXRlcy5cbiAgICAgIGlmIChuZXh0UHJvcHMuZmFsbGJhY2sgIT09IHVuZGVmaW5lZCAmJiBuZXh0UHJvcHMudW5zdGFibGVfYXZvaWRUaGlzRmFsbGJhY2sgIT09IHRydWUpIHtcbiAgICAgICAgc3VzcGVuc2VDb250ZXh0ID0gYWRkU3VidHJlZVN1c3BlbnNlQ29udGV4dChzdXNwZW5zZUNvbnRleHQsIEludmlzaWJsZVBhcmVudFN1c3BlbnNlQ29udGV4dCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgc3VzcGVuc2VDb250ZXh0ID0gc2V0RGVmYXVsdFNoYWxsb3dTdXNwZW5zZUNvbnRleHQoc3VzcGVuc2VDb250ZXh0KTtcbiAgcHVzaFN1c3BlbnNlQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgc3VzcGVuc2VDb250ZXh0KTsgLy8gT0ssIHRoZSBuZXh0IHBhcnQgaXMgY29uZnVzaW5nLiBXZSdyZSBhYm91dCB0byByZWNvbmNpbGUgdGhlIFN1c3BlbnNlXG4gIC8vIGJvdW5kYXJ5J3MgY2hpbGRyZW4uIFRoaXMgaW52b2x2ZXMgc29tZSBjdXN0b20gcmVjb25jaWxhdGlvbiBsb2dpYy4gVHdvXG4gIC8vIG1haW4gcmVhc29ucyB0aGlzIGlzIHNvIGNvbXBsaWNhdGVkLlxuICAvL1xuICAvLyBGaXJzdCwgTGVnYWN5IE1vZGUgaGFzIGRpZmZlcmVudCBzZW1hbnRpY3MgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LiBUaGVcbiAgLy8gcHJpbWFyeSB0cmVlIHdpbGwgY29tbWl0IGluIGFuIGluY29uc2lzdGVudCBzdGF0ZSwgc28gd2hlbiB3ZSBkbyB0aGVcbiAgLy8gc2Vjb25kIHBhc3MgdG8gcmVuZGVyIHRoZSBmYWxsYmFjaywgd2UgZG8gc29tZSBleGNlZWRpbmdseSwgdWgsIGNsZXZlclxuICAvLyBoYWNrcyB0byBtYWtlIHRoYXQgbm90IHRvdGFsbHkgYnJlYWsuIExpa2UgdHJhbnNmZXJyaW5nIGVmZmVjdHMgYW5kXG4gIC8vIGRlbGV0aW9ucyBmcm9tIGhpZGRlbiB0cmVlLiBJbiBDb25jdXJyZW50IE1vZGUsIGl0J3MgbXVjaCBzaW1wbGVyLFxuICAvLyBiZWNhdXNlIHdlIGJhaWxvdXQgb24gdGhlIHByaW1hcnkgdHJlZSBjb21wbGV0ZWx5IGFuZCBsZWF2ZSBpdCBpbiBpdHMgb2xkXG4gIC8vIHN0YXRlLCBubyBlZmZlY3RzLiBTYW1lIGFzIHdoYXQgd2UgZG8gZm9yIE9mZnNjcmVlbiAoZXhjZXB0IHRoYXRcbiAgLy8gT2Zmc2NyZWVuIGRvZXNuJ3QgaGF2ZSB0aGUgZmlyc3QgcmVuZGVyIHBhc3MpLlxuICAvL1xuICAvLyBTZWNvbmQgaXMgaHlkcmF0aW9uLiBEdXJpbmcgaHlkcmF0aW9uLCB0aGUgU3VzcGVuc2UgZmliZXIgaGFzIGEgc2xpZ2h0bHlcbiAgLy8gZGlmZmVyZW50IGxheW91dCwgd2hlcmUgdGhlIGNoaWxkIHBvaW50cyB0byBhIGRlaHlkcmF0ZWQgZnJhZ21lbnQsIHdoaWNoXG4gIC8vIGNvbnRhaW5zIHRoZSBET00gcmVuZGVyZWQgYnkgdGhlIHNlcnZlci5cbiAgLy9cbiAgLy8gVGhpcmQsIGV2ZW4gaWYgeW91IHNldCBhbGwgdGhhdCBhc2lkZSwgU3VzcGVuc2UgaXMgbGlrZSBlcnJvciBib3VuZGFyaWVzIGluXG4gIC8vIHRoYXQgd2UgZmlyc3Qgd2UgdHJ5IHRvIHJlbmRlciBvbmUgdHJlZSwgYW5kIGlmIHRoYXQgZmFpbHMsIHdlIHJlbmRlciBhZ2FpblxuICAvLyBhbmQgc3dpdGNoIHRvIGEgZGlmZmVyZW50IHRyZWUuIExpa2UgYSB0cnkvY2F0Y2ggYmxvY2suIFNvIHdlIGhhdmUgdG8gdHJhY2tcbiAgLy8gd2hpY2ggYnJhbmNoIHdlJ3JlIGN1cnJlbnRseSByZW5kZXJpbmcuIElkZWFsbHkgd2Ugd291bGQgbW9kZWwgdGhpcyB1c2luZ1xuICAvLyBhIHN0YWNrLlxuXG4gIGlmIChjdXJyZW50ID09PSBudWxsKSB7XG4gICAgLy8gSW5pdGlhbCBtb3VudFxuICAgIC8vIElmIHdlJ3JlIGN1cnJlbnRseSBoeWRyYXRpbmcsIHRyeSB0byBoeWRyYXRlIHRoaXMgYm91bmRhcnkuXG4gICAgLy8gQnV0IG9ubHkgaWYgdGhpcyBoYXMgYSBmYWxsYmFjay5cbiAgICBpZiAobmV4dFByb3BzLmZhbGxiYWNrICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRyeVRvQ2xhaW1OZXh0SHlkcmF0YWJsZUluc3RhbmNlKHdvcmtJblByb2dyZXNzKTsgLy8gVGhpcyBjb3VsZCd2ZSBiZWVuIGEgZGVoeWRyYXRlZCBzdXNwZW5zZSBjb21wb25lbnQuXG4gICAgfVxuXG4gICAgdmFyIG5leHRQcmltYXJ5Q2hpbGRyZW4gPSBuZXh0UHJvcHMuY2hpbGRyZW47XG4gICAgdmFyIG5leHRGYWxsYmFja0NoaWxkcmVuID0gbmV4dFByb3BzLmZhbGxiYWNrO1xuXG4gICAgaWYgKHNob3dGYWxsYmFjaykge1xuICAgICAgdmFyIGZhbGxiYWNrRnJhZ21lbnQgPSBtb3VudFN1c3BlbnNlRmFsbGJhY2tDaGlsZHJlbih3b3JrSW5Qcm9ncmVzcywgbmV4dFByaW1hcnlDaGlsZHJlbiwgbmV4dEZhbGxiYWNrQ2hpbGRyZW4sIHJlbmRlckxhbmVzKTtcbiAgICAgIHZhciBwcmltYXJ5Q2hpbGRGcmFnbWVudCA9IHdvcmtJblByb2dyZXNzLmNoaWxkO1xuICAgICAgcHJpbWFyeUNoaWxkRnJhZ21lbnQubWVtb2l6ZWRTdGF0ZSA9IG1vdW50U3VzcGVuc2VPZmZzY3JlZW5TdGF0ZShyZW5kZXJMYW5lcyk7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID0gU1VTUEVOREVEX01BUktFUjtcbiAgICAgIHJldHVybiBmYWxsYmFja0ZyYWdtZW50O1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIG5leHRQcm9wcy51bnN0YWJsZV9leHBlY3RlZExvYWRUaW1lID09PSAnbnVtYmVyJykge1xuICAgICAgLy8gVGhpcyBpcyBhIENQVS1ib3VuZCB0cmVlLiBTa2lwIHRoaXMgdHJlZSBhbmQgc2hvdyBhIHBsYWNlaG9sZGVyIHRvXG4gICAgICAvLyB1bmJsb2NrIHRoZSBzdXJyb3VuZGluZyBjb250ZW50LiBUaGVuIGltbWVkaWF0ZWx5IHJldHJ5IGFmdGVyIHRoZVxuICAgICAgLy8gaW5pdGlhbCBjb21taXQuXG4gICAgICB2YXIgX2ZhbGxiYWNrRnJhZ21lbnQgPSBtb3VudFN1c3BlbnNlRmFsbGJhY2tDaGlsZHJlbih3b3JrSW5Qcm9ncmVzcywgbmV4dFByaW1hcnlDaGlsZHJlbiwgbmV4dEZhbGxiYWNrQ2hpbGRyZW4sIHJlbmRlckxhbmVzKTtcblxuICAgICAgdmFyIF9wcmltYXJ5Q2hpbGRGcmFnbWVudCA9IHdvcmtJblByb2dyZXNzLmNoaWxkO1xuICAgICAgX3ByaW1hcnlDaGlsZEZyYWdtZW50Lm1lbW9pemVkU3RhdGUgPSBtb3VudFN1c3BlbnNlT2Zmc2NyZWVuU3RhdGUocmVuZGVyTGFuZXMpO1xuICAgICAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IFNVU1BFTkRFRF9NQVJLRVI7IC8vIFNpbmNlIG5vdGhpbmcgYWN0dWFsbHkgc3VzcGVuZGVkLCB0aGVyZSB3aWxsIG5vdGhpbmcgdG8gcGluZyB0aGlzIHRvXG4gICAgICAvLyBnZXQgaXQgc3RhcnRlZCBiYWNrIHVwIHRvIGF0dGVtcHQgdGhlIG5leHQgaXRlbS4gV2hpbGUgaW4gdGVybXMgb2ZcbiAgICAgIC8vIHByaW9yaXR5IHRoaXMgd29yayBoYXMgdGhlIHNhbWUgcHJpb3JpdHkgYXMgdGhpcyBjdXJyZW50IHJlbmRlciwgaXQnc1xuICAgICAgLy8gbm90IHBhcnQgb2YgdGhlIHNhbWUgdHJhbnNpdGlvbiBvbmNlIHRoZSB0cmFuc2l0aW9uIGhhcyBjb21taXR0ZWQuIElmXG4gICAgICAvLyBpdCdzIHN5bmMsIHdlIHN0aWxsIHdhbnQgdG8geWllbGQgc28gdGhhdCBpdCBjYW4gYmUgcGFpbnRlZC5cbiAgICAgIC8vIENvbmNlcHR1YWxseSwgdGhpcyBpcyByZWFsbHkgdGhlIHNhbWUgYXMgcGluZ2luZy4gV2UgY2FuIHVzZSBhbnlcbiAgICAgIC8vIFJldHJ5TGFuZSBldmVuIGlmIGl0J3MgdGhlIG9uZSBjdXJyZW50bHkgcmVuZGVyaW5nIHNpbmNlIHdlJ3JlIGxlYXZpbmdcbiAgICAgIC8vIGl0IGJlaGluZCBvbiB0aGlzIG5vZGUuXG5cbiAgICAgIHdvcmtJblByb2dyZXNzLmxhbmVzID0gU29tZVJldHJ5TGFuZTtcblxuICAgICAge1xuICAgICAgICBtYXJrU3Bhd25lZFdvcmsoU29tZVJldHJ5TGFuZSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBfZmFsbGJhY2tGcmFnbWVudDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG1vdW50U3VzcGVuc2VQcmltYXJ5Q2hpbGRyZW4od29ya0luUHJvZ3Jlc3MsIG5leHRQcmltYXJ5Q2hpbGRyZW4sIHJlbmRlckxhbmVzKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gVGhpcyBpcyBhbiB1cGRhdGUuXG4gICAgLy8gSWYgdGhlIGN1cnJlbnQgZmliZXIgaGFzIGEgU3VzcGVuc2VTdGF0ZSwgdGhhdCBtZWFucyBpdCdzIGFscmVhZHkgc2hvd2luZ1xuICAgIC8vIGEgZmFsbGJhY2suXG4gICAgdmFyIHByZXZTdGF0ZSA9IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZTtcblxuICAgIGlmIChwcmV2U3RhdGUgIT09IG51bGwpIHtcblxuICAgICAgaWYgKHNob3dGYWxsYmFjaykge1xuICAgICAgICB2YXIgX25leHRGYWxsYmFja0NoaWxkcmVuMiA9IG5leHRQcm9wcy5mYWxsYmFjaztcbiAgICAgICAgdmFyIF9uZXh0UHJpbWFyeUNoaWxkcmVuMiA9IG5leHRQcm9wcy5jaGlsZHJlbjtcblxuICAgICAgICB2YXIgX2ZhbGxiYWNrQ2hpbGRGcmFnbWVudCA9IHVwZGF0ZVN1c3BlbnNlRmFsbGJhY2tDaGlsZHJlbihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgX25leHRQcmltYXJ5Q2hpbGRyZW4yLCBfbmV4dEZhbGxiYWNrQ2hpbGRyZW4yLCByZW5kZXJMYW5lcyk7XG5cbiAgICAgICAgdmFyIF9wcmltYXJ5Q2hpbGRGcmFnbWVudDMgPSB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbiAgICAgICAgdmFyIHByZXZPZmZzY3JlZW5TdGF0ZSA9IGN1cnJlbnQuY2hpbGQubWVtb2l6ZWRTdGF0ZTtcbiAgICAgICAgX3ByaW1hcnlDaGlsZEZyYWdtZW50My5tZW1vaXplZFN0YXRlID0gcHJldk9mZnNjcmVlblN0YXRlID09PSBudWxsID8gbW91bnRTdXNwZW5zZU9mZnNjcmVlblN0YXRlKHJlbmRlckxhbmVzKSA6IHVwZGF0ZVN1c3BlbnNlT2Zmc2NyZWVuU3RhdGUocHJldk9mZnNjcmVlblN0YXRlLCByZW5kZXJMYW5lcyk7XG4gICAgICAgIF9wcmltYXJ5Q2hpbGRGcmFnbWVudDMuY2hpbGRMYW5lcyA9IGdldFJlbWFpbmluZ1dvcmtJblByaW1hcnlUcmVlKGN1cnJlbnQsIHJlbmRlckxhbmVzKTtcbiAgICAgICAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IFNVU1BFTkRFRF9NQVJLRVI7XG4gICAgICAgIHJldHVybiBfZmFsbGJhY2tDaGlsZEZyYWdtZW50O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIF9uZXh0UHJpbWFyeUNoaWxkcmVuMyA9IG5leHRQcm9wcy5jaGlsZHJlbjtcblxuICAgICAgICB2YXIgX3ByaW1hcnlDaGlsZEZyYWdtZW50NCA9IHVwZGF0ZVN1c3BlbnNlUHJpbWFyeUNoaWxkcmVuKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBfbmV4dFByaW1hcnlDaGlsZHJlbjMsIHJlbmRlckxhbmVzKTtcblxuICAgICAgICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIF9wcmltYXJ5Q2hpbGRGcmFnbWVudDQ7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRoZSBjdXJyZW50IHRyZWUgaXMgbm90IGFscmVhZHkgc2hvd2luZyBhIGZhbGxiYWNrLlxuICAgICAgaWYgKHNob3dGYWxsYmFjaykge1xuICAgICAgICAvLyBUaW1lZCBvdXQuXG4gICAgICAgIHZhciBfbmV4dEZhbGxiYWNrQ2hpbGRyZW4zID0gbmV4dFByb3BzLmZhbGxiYWNrO1xuICAgICAgICB2YXIgX25leHRQcmltYXJ5Q2hpbGRyZW40ID0gbmV4dFByb3BzLmNoaWxkcmVuO1xuXG4gICAgICAgIHZhciBfZmFsbGJhY2tDaGlsZEZyYWdtZW50MiA9IHVwZGF0ZVN1c3BlbnNlRmFsbGJhY2tDaGlsZHJlbihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgX25leHRQcmltYXJ5Q2hpbGRyZW40LCBfbmV4dEZhbGxiYWNrQ2hpbGRyZW4zLCByZW5kZXJMYW5lcyk7XG5cbiAgICAgICAgdmFyIF9wcmltYXJ5Q2hpbGRGcmFnbWVudDUgPSB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbiAgICAgICAgdmFyIF9wcmV2T2Zmc2NyZWVuU3RhdGUgPSBjdXJyZW50LmNoaWxkLm1lbW9pemVkU3RhdGU7XG4gICAgICAgIF9wcmltYXJ5Q2hpbGRGcmFnbWVudDUubWVtb2l6ZWRTdGF0ZSA9IF9wcmV2T2Zmc2NyZWVuU3RhdGUgPT09IG51bGwgPyBtb3VudFN1c3BlbnNlT2Zmc2NyZWVuU3RhdGUocmVuZGVyTGFuZXMpIDogdXBkYXRlU3VzcGVuc2VPZmZzY3JlZW5TdGF0ZShfcHJldk9mZnNjcmVlblN0YXRlLCByZW5kZXJMYW5lcyk7XG4gICAgICAgIF9wcmltYXJ5Q2hpbGRGcmFnbWVudDUuY2hpbGRMYW5lcyA9IGdldFJlbWFpbmluZ1dvcmtJblByaW1hcnlUcmVlKGN1cnJlbnQsIHJlbmRlckxhbmVzKTsgLy8gU2tpcCB0aGUgcHJpbWFyeSBjaGlsZHJlbiwgYW5kIGNvbnRpbnVlIHdvcmtpbmcgb24gdGhlXG4gICAgICAgIC8vIGZhbGxiYWNrIGNoaWxkcmVuLlxuXG4gICAgICAgIHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSBTVVNQRU5ERURfTUFSS0VSO1xuICAgICAgICByZXR1cm4gX2ZhbGxiYWNrQ2hpbGRGcmFnbWVudDI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBTdGlsbCBoYXZlbid0IHRpbWVkIG91dC4gQ29udGludWUgcmVuZGVyaW5nIHRoZSBjaGlsZHJlbiwgbGlrZSB3ZVxuICAgICAgICAvLyBub3JtYWxseSBkby5cbiAgICAgICAgdmFyIF9uZXh0UHJpbWFyeUNoaWxkcmVuNSA9IG5leHRQcm9wcy5jaGlsZHJlbjtcblxuICAgICAgICB2YXIgX3ByaW1hcnlDaGlsZEZyYWdtZW50NiA9IHVwZGF0ZVN1c3BlbnNlUHJpbWFyeUNoaWxkcmVuKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBfbmV4dFByaW1hcnlDaGlsZHJlbjUsIHJlbmRlckxhbmVzKTtcblxuICAgICAgICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIF9wcmltYXJ5Q2hpbGRGcmFnbWVudDY7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIG1vdW50U3VzcGVuc2VQcmltYXJ5Q2hpbGRyZW4od29ya0luUHJvZ3Jlc3MsIHByaW1hcnlDaGlsZHJlbiwgcmVuZGVyTGFuZXMpIHtcbiAgdmFyIG1vZGUgPSB3b3JrSW5Qcm9ncmVzcy5tb2RlO1xuICB2YXIgcHJpbWFyeUNoaWxkUHJvcHMgPSB7XG4gICAgbW9kZTogJ3Zpc2libGUnLFxuICAgIGNoaWxkcmVuOiBwcmltYXJ5Q2hpbGRyZW5cbiAgfTtcbiAgdmFyIHByaW1hcnlDaGlsZEZyYWdtZW50ID0gY3JlYXRlRmliZXJGcm9tT2Zmc2NyZWVuKHByaW1hcnlDaGlsZFByb3BzLCBtb2RlLCByZW5kZXJMYW5lcywgbnVsbCk7XG4gIHByaW1hcnlDaGlsZEZyYWdtZW50LnJldHVybiA9IHdvcmtJblByb2dyZXNzO1xuICB3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IHByaW1hcnlDaGlsZEZyYWdtZW50O1xuICByZXR1cm4gcHJpbWFyeUNoaWxkRnJhZ21lbnQ7XG59XG5cbmZ1bmN0aW9uIG1vdW50U3VzcGVuc2VGYWxsYmFja0NoaWxkcmVuKHdvcmtJblByb2dyZXNzLCBwcmltYXJ5Q2hpbGRyZW4sIGZhbGxiYWNrQ2hpbGRyZW4sIHJlbmRlckxhbmVzKSB7XG4gIHZhciBtb2RlID0gd29ya0luUHJvZ3Jlc3MubW9kZTtcbiAgdmFyIHByb2dyZXNzZWRQcmltYXJ5RnJhZ21lbnQgPSB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbiAgdmFyIHByaW1hcnlDaGlsZFByb3BzID0ge1xuICAgIG1vZGU6ICdoaWRkZW4nLFxuICAgIGNoaWxkcmVuOiBwcmltYXJ5Q2hpbGRyZW5cbiAgfTtcbiAgdmFyIHByaW1hcnlDaGlsZEZyYWdtZW50O1xuICB2YXIgZmFsbGJhY2tDaGlsZEZyYWdtZW50O1xuXG4gIGlmICgobW9kZSAmIEJsb2NraW5nTW9kZSkgPT09IE5vTW9kZSAmJiBwcm9ncmVzc2VkUHJpbWFyeUZyYWdtZW50ICE9PSBudWxsKSB7XG4gICAgLy8gSW4gbGVnYWN5IG1vZGUsIHdlIGNvbW1pdCB0aGUgcHJpbWFyeSB0cmVlIGFzIGlmIGl0IHN1Y2Nlc3NmdWxseVxuICAgIC8vIGNvbXBsZXRlZCwgZXZlbiB0aG91Z2ggaXQncyBpbiBhbiBpbmNvbnNpc3RlbnQgc3RhdGUuXG4gICAgcHJpbWFyeUNoaWxkRnJhZ21lbnQgPSBwcm9ncmVzc2VkUHJpbWFyeUZyYWdtZW50O1xuICAgIHByaW1hcnlDaGlsZEZyYWdtZW50LmNoaWxkTGFuZXMgPSBOb0xhbmVzO1xuICAgIHByaW1hcnlDaGlsZEZyYWdtZW50LnBlbmRpbmdQcm9wcyA9IHByaW1hcnlDaGlsZFByb3BzO1xuXG4gICAgaWYgKCB3b3JrSW5Qcm9ncmVzcy5tb2RlICYgUHJvZmlsZU1vZGUpIHtcbiAgICAgIC8vIFJlc2V0IHRoZSBkdXJhdGlvbnMgZnJvbSB0aGUgZmlyc3QgcGFzcyBzbyB0aGV5IGFyZW4ndCBpbmNsdWRlZCBpbiB0aGVcbiAgICAgIC8vIGZpbmFsIGFtb3VudHMuIFRoaXMgc2VlbXMgY291bnRlcmludHVpdGl2ZSwgc2luY2Ugd2UncmUgaW50ZW50aW9uYWxseVxuICAgICAgLy8gbm90IG1lYXN1cmluZyBwYXJ0IG9mIHRoZSByZW5kZXIgcGhhc2UsIGJ1dCB0aGlzIG1ha2VzIGl0IG1hdGNoIHdoYXQgd2VcbiAgICAgIC8vIGRvIGluIENvbmN1cnJlbnQgTW9kZS5cbiAgICAgIHByaW1hcnlDaGlsZEZyYWdtZW50LmFjdHVhbER1cmF0aW9uID0gMDtcbiAgICAgIHByaW1hcnlDaGlsZEZyYWdtZW50LmFjdHVhbFN0YXJ0VGltZSA9IC0xO1xuICAgICAgcHJpbWFyeUNoaWxkRnJhZ21lbnQuc2VsZkJhc2VEdXJhdGlvbiA9IDA7XG4gICAgICBwcmltYXJ5Q2hpbGRGcmFnbWVudC50cmVlQmFzZUR1cmF0aW9uID0gMDtcbiAgICB9XG5cbiAgICBmYWxsYmFja0NoaWxkRnJhZ21lbnQgPSBjcmVhdGVGaWJlckZyb21GcmFnbWVudChmYWxsYmFja0NoaWxkcmVuLCBtb2RlLCByZW5kZXJMYW5lcywgbnVsbCk7XG4gIH0gZWxzZSB7XG4gICAgcHJpbWFyeUNoaWxkRnJhZ21lbnQgPSBjcmVhdGVGaWJlckZyb21PZmZzY3JlZW4ocHJpbWFyeUNoaWxkUHJvcHMsIG1vZGUsIE5vTGFuZXMsIG51bGwpO1xuICAgIGZhbGxiYWNrQ2hpbGRGcmFnbWVudCA9IGNyZWF0ZUZpYmVyRnJvbUZyYWdtZW50KGZhbGxiYWNrQ2hpbGRyZW4sIG1vZGUsIHJlbmRlckxhbmVzLCBudWxsKTtcbiAgfVxuXG4gIHByaW1hcnlDaGlsZEZyYWdtZW50LnJldHVybiA9IHdvcmtJblByb2dyZXNzO1xuICBmYWxsYmFja0NoaWxkRnJhZ21lbnQucmV0dXJuID0gd29ya0luUHJvZ3Jlc3M7XG4gIHByaW1hcnlDaGlsZEZyYWdtZW50LnNpYmxpbmcgPSBmYWxsYmFja0NoaWxkRnJhZ21lbnQ7XG4gIHdvcmtJblByb2dyZXNzLmNoaWxkID0gcHJpbWFyeUNoaWxkRnJhZ21lbnQ7XG4gIHJldHVybiBmYWxsYmFja0NoaWxkRnJhZ21lbnQ7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVdvcmtJblByb2dyZXNzT2Zmc2NyZWVuRmliZXIoY3VycmVudCwgb2Zmc2NyZWVuUHJvcHMpIHtcbiAgLy8gVGhlIHByb3BzIGFyZ3VtZW50IHRvIGBjcmVhdGVXb3JrSW5Qcm9ncmVzc2AgaXMgYGFueWAgdHlwZWQsIHNvIHdlIHVzZSB0aGlzXG4gIC8vIHdyYXBwZXIgZnVuY3Rpb24gdG8gY29uc3RyYWluIGl0LlxuICByZXR1cm4gY3JlYXRlV29ya0luUHJvZ3Jlc3MoY3VycmVudCwgb2Zmc2NyZWVuUHJvcHMpO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVTdXNwZW5zZVByaW1hcnlDaGlsZHJlbihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcHJpbWFyeUNoaWxkcmVuLCByZW5kZXJMYW5lcykge1xuICB2YXIgY3VycmVudFByaW1hcnlDaGlsZEZyYWdtZW50ID0gY3VycmVudC5jaGlsZDtcbiAgdmFyIGN1cnJlbnRGYWxsYmFja0NoaWxkRnJhZ21lbnQgPSBjdXJyZW50UHJpbWFyeUNoaWxkRnJhZ21lbnQuc2libGluZztcbiAgdmFyIHByaW1hcnlDaGlsZEZyYWdtZW50ID0gY3JlYXRlV29ya0luUHJvZ3Jlc3NPZmZzY3JlZW5GaWJlcihjdXJyZW50UHJpbWFyeUNoaWxkRnJhZ21lbnQsIHtcbiAgICBtb2RlOiAndmlzaWJsZScsXG4gICAgY2hpbGRyZW46IHByaW1hcnlDaGlsZHJlblxuICB9KTtcblxuICBpZiAoKHdvcmtJblByb2dyZXNzLm1vZGUgJiBCbG9ja2luZ01vZGUpID09PSBOb01vZGUpIHtcbiAgICBwcmltYXJ5Q2hpbGRGcmFnbWVudC5sYW5lcyA9IHJlbmRlckxhbmVzO1xuICB9XG5cbiAgcHJpbWFyeUNoaWxkRnJhZ21lbnQucmV0dXJuID0gd29ya0luUHJvZ3Jlc3M7XG4gIHByaW1hcnlDaGlsZEZyYWdtZW50LnNpYmxpbmcgPSBudWxsO1xuXG4gIGlmIChjdXJyZW50RmFsbGJhY2tDaGlsZEZyYWdtZW50ICE9PSBudWxsKSB7XG4gICAgLy8gRGVsZXRlIHRoZSBmYWxsYmFjayBjaGlsZCBmcmFnbWVudFxuICAgIGN1cnJlbnRGYWxsYmFja0NoaWxkRnJhZ21lbnQubmV4dEVmZmVjdCA9IG51bGw7XG4gICAgY3VycmVudEZhbGxiYWNrQ2hpbGRGcmFnbWVudC5mbGFncyA9IERlbGV0aW9uO1xuICAgIHdvcmtJblByb2dyZXNzLmZpcnN0RWZmZWN0ID0gd29ya0luUHJvZ3Jlc3MubGFzdEVmZmVjdCA9IGN1cnJlbnRGYWxsYmFja0NoaWxkRnJhZ21lbnQ7XG4gIH1cblxuICB3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IHByaW1hcnlDaGlsZEZyYWdtZW50O1xuICByZXR1cm4gcHJpbWFyeUNoaWxkRnJhZ21lbnQ7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZVN1c3BlbnNlRmFsbGJhY2tDaGlsZHJlbihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcHJpbWFyeUNoaWxkcmVuLCBmYWxsYmFja0NoaWxkcmVuLCByZW5kZXJMYW5lcykge1xuICB2YXIgbW9kZSA9IHdvcmtJblByb2dyZXNzLm1vZGU7XG4gIHZhciBjdXJyZW50UHJpbWFyeUNoaWxkRnJhZ21lbnQgPSBjdXJyZW50LmNoaWxkO1xuICB2YXIgY3VycmVudEZhbGxiYWNrQ2hpbGRGcmFnbWVudCA9IGN1cnJlbnRQcmltYXJ5Q2hpbGRGcmFnbWVudC5zaWJsaW5nO1xuICB2YXIgcHJpbWFyeUNoaWxkUHJvcHMgPSB7XG4gICAgbW9kZTogJ2hpZGRlbicsXG4gICAgY2hpbGRyZW46IHByaW1hcnlDaGlsZHJlblxuICB9O1xuICB2YXIgcHJpbWFyeUNoaWxkRnJhZ21lbnQ7XG5cbiAgaWYgKCAvLyBJbiBsZWdhY3kgbW9kZSwgd2UgY29tbWl0IHRoZSBwcmltYXJ5IHRyZWUgYXMgaWYgaXQgc3VjY2Vzc2Z1bGx5XG4gIC8vIGNvbXBsZXRlZCwgZXZlbiB0aG91Z2ggaXQncyBpbiBhbiBpbmNvbnNpc3RlbnQgc3RhdGUuXG4gIChtb2RlICYgQmxvY2tpbmdNb2RlKSA9PT0gTm9Nb2RlICYmIC8vIE1ha2Ugc3VyZSB3ZSdyZSBvbiB0aGUgc2Vjb25kIHBhc3MsIGkuZS4gdGhlIHByaW1hcnkgY2hpbGQgZnJhZ21lbnQgd2FzXG4gIC8vIGFscmVhZHkgY2xvbmVkLiBJbiBsZWdhY3kgbW9kZSwgdGhlIG9ubHkgY2FzZSB3aGVyZSB0aGlzIGlzbid0IHRydWUgaXNcbiAgLy8gd2hlbiBEZXZUb29scyBmb3JjZXMgdXMgdG8gZGlzcGxheSBhIGZhbGxiYWNrOyB3ZSBza2lwIHRoZSBmaXJzdCByZW5kZXJcbiAgLy8gcGFzcyBlbnRpcmVseSBhbmQgZ28gc3RyYWlnaHQgdG8gcmVuZGVyaW5nIHRoZSBmYWxsYmFjay4gKEluIENvbmN1cnJlbnRcbiAgLy8gTW9kZSwgU3VzcGVuc2VMaXN0IGNhbiBhbHNvIHRyaWdnZXIgdGhpcyBzY2VuYXJpbywgYnV0IHRoaXMgaXMgYSBsZWdhY3ktXG4gIC8vIG9ubHkgY29kZXBhdGguKVxuICB3b3JrSW5Qcm9ncmVzcy5jaGlsZCAhPT0gY3VycmVudFByaW1hcnlDaGlsZEZyYWdtZW50KSB7XG4gICAgdmFyIHByb2dyZXNzZWRQcmltYXJ5RnJhZ21lbnQgPSB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbiAgICBwcmltYXJ5Q2hpbGRGcmFnbWVudCA9IHByb2dyZXNzZWRQcmltYXJ5RnJhZ21lbnQ7XG4gICAgcHJpbWFyeUNoaWxkRnJhZ21lbnQuY2hpbGRMYW5lcyA9IE5vTGFuZXM7XG4gICAgcHJpbWFyeUNoaWxkRnJhZ21lbnQucGVuZGluZ1Byb3BzID0gcHJpbWFyeUNoaWxkUHJvcHM7XG5cbiAgICBpZiAoIHdvcmtJblByb2dyZXNzLm1vZGUgJiBQcm9maWxlTW9kZSkge1xuICAgICAgLy8gUmVzZXQgdGhlIGR1cmF0aW9ucyBmcm9tIHRoZSBmaXJzdCBwYXNzIHNvIHRoZXkgYXJlbid0IGluY2x1ZGVkIGluIHRoZVxuICAgICAgLy8gZmluYWwgYW1vdW50cy4gVGhpcyBzZWVtcyBjb3VudGVyaW50dWl0aXZlLCBzaW5jZSB3ZSdyZSBpbnRlbnRpb25hbGx5XG4gICAgICAvLyBub3QgbWVhc3VyaW5nIHBhcnQgb2YgdGhlIHJlbmRlciBwaGFzZSwgYnV0IHRoaXMgbWFrZXMgaXQgbWF0Y2ggd2hhdCB3ZVxuICAgICAgLy8gZG8gaW4gQ29uY3VycmVudCBNb2RlLlxuICAgICAgcHJpbWFyeUNoaWxkRnJhZ21lbnQuYWN0dWFsRHVyYXRpb24gPSAwO1xuICAgICAgcHJpbWFyeUNoaWxkRnJhZ21lbnQuYWN0dWFsU3RhcnRUaW1lID0gLTE7XG4gICAgICBwcmltYXJ5Q2hpbGRGcmFnbWVudC5zZWxmQmFzZUR1cmF0aW9uID0gY3VycmVudFByaW1hcnlDaGlsZEZyYWdtZW50LnNlbGZCYXNlRHVyYXRpb247XG4gICAgICBwcmltYXJ5Q2hpbGRGcmFnbWVudC50cmVlQmFzZUR1cmF0aW9uID0gY3VycmVudFByaW1hcnlDaGlsZEZyYWdtZW50LnRyZWVCYXNlRHVyYXRpb247XG4gICAgfSAvLyBUaGUgZmFsbGJhY2sgZmliZXIgd2FzIGFkZGVkIGFzIGEgZGVsZXRpb24gZWZmZWN0IGR1cmluZyB0aGUgZmlyc3QgcGFzcy5cbiAgICAvLyBIb3dldmVyLCBzaW5jZSB3ZSdyZSBnb2luZyB0byByZW1haW4gb24gdGhlIGZhbGxiYWNrLCB3ZSBubyBsb25nZXIgd2FudFxuICAgIC8vIHRvIGRlbGV0ZSBpdC4gU28gd2UgbmVlZCB0byByZW1vdmUgaXQgZnJvbSB0aGUgbGlzdC4gRGVsZXRpb25zIGFyZSBzdG9yZWRcbiAgICAvLyBvbiB0aGUgc2FtZSBsaXN0IGFzIGVmZmVjdHMuIFdlIHdhbnQgdG8ga2VlcCB0aGUgZWZmZWN0cyBmcm9tIHRoZSBwcmltYXJ5XG4gICAgLy8gdHJlZS4gU28gd2UgY29weSB0aGUgcHJpbWFyeSBjaGlsZCBmcmFnbWVudCdzIGVmZmVjdCBsaXN0LCB3aGljaCBkb2VzIG5vdFxuICAgIC8vIGluY2x1ZGUgdGhlIGZhbGxiYWNrIGRlbGV0aW9uIGVmZmVjdC5cblxuXG4gICAgdmFyIHByb2dyZXNzZWRMYXN0RWZmZWN0ID0gcHJpbWFyeUNoaWxkRnJhZ21lbnQubGFzdEVmZmVjdDtcblxuICAgIGlmIChwcm9ncmVzc2VkTGFzdEVmZmVjdCAhPT0gbnVsbCkge1xuICAgICAgd29ya0luUHJvZ3Jlc3MuZmlyc3RFZmZlY3QgPSBwcmltYXJ5Q2hpbGRGcmFnbWVudC5maXJzdEVmZmVjdDtcbiAgICAgIHdvcmtJblByb2dyZXNzLmxhc3RFZmZlY3QgPSBwcm9ncmVzc2VkTGFzdEVmZmVjdDtcbiAgICAgIHByb2dyZXNzZWRMYXN0RWZmZWN0Lm5leHRFZmZlY3QgPSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBUT0RPOiBSZXNldCB0aGlzIHNvbWV3aGVyZSBlbHNlPyBMb2wgbGVnYWN5IG1vZGUgaXMgc28gd2VpcmQuXG4gICAgICB3b3JrSW5Qcm9ncmVzcy5maXJzdEVmZmVjdCA9IHdvcmtJblByb2dyZXNzLmxhc3RFZmZlY3QgPSBudWxsO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBwcmltYXJ5Q2hpbGRGcmFnbWVudCA9IGNyZWF0ZVdvcmtJblByb2dyZXNzT2Zmc2NyZWVuRmliZXIoY3VycmVudFByaW1hcnlDaGlsZEZyYWdtZW50LCBwcmltYXJ5Q2hpbGRQcm9wcyk7XG4gIH1cblxuICB2YXIgZmFsbGJhY2tDaGlsZEZyYWdtZW50O1xuXG4gIGlmIChjdXJyZW50RmFsbGJhY2tDaGlsZEZyYWdtZW50ICE9PSBudWxsKSB7XG4gICAgZmFsbGJhY2tDaGlsZEZyYWdtZW50ID0gY3JlYXRlV29ya0luUHJvZ3Jlc3MoY3VycmVudEZhbGxiYWNrQ2hpbGRGcmFnbWVudCwgZmFsbGJhY2tDaGlsZHJlbik7XG4gIH0gZWxzZSB7XG4gICAgZmFsbGJhY2tDaGlsZEZyYWdtZW50ID0gY3JlYXRlRmliZXJGcm9tRnJhZ21lbnQoZmFsbGJhY2tDaGlsZHJlbiwgbW9kZSwgcmVuZGVyTGFuZXMsIG51bGwpOyAvLyBOZWVkcyBhIHBsYWNlbWVudCBlZmZlY3QgYmVjYXVzZSB0aGUgcGFyZW50ICh0aGUgU3VzcGVuc2UgYm91bmRhcnkpIGFscmVhZHlcbiAgICAvLyBtb3VudGVkIGJ1dCB0aGlzIGlzIGEgbmV3IGZpYmVyLlxuXG4gICAgZmFsbGJhY2tDaGlsZEZyYWdtZW50LmZsYWdzIHw9IFBsYWNlbWVudDtcbiAgfVxuXG4gIGZhbGxiYWNrQ2hpbGRGcmFnbWVudC5yZXR1cm4gPSB3b3JrSW5Qcm9ncmVzcztcbiAgcHJpbWFyeUNoaWxkRnJhZ21lbnQucmV0dXJuID0gd29ya0luUHJvZ3Jlc3M7XG4gIHByaW1hcnlDaGlsZEZyYWdtZW50LnNpYmxpbmcgPSBmYWxsYmFja0NoaWxkRnJhZ21lbnQ7XG4gIHdvcmtJblByb2dyZXNzLmNoaWxkID0gcHJpbWFyeUNoaWxkRnJhZ21lbnQ7XG4gIHJldHVybiBmYWxsYmFja0NoaWxkRnJhZ21lbnQ7XG59XG5cbmZ1bmN0aW9uIHNjaGVkdWxlV29ya09uRmliZXIoZmliZXIsIHJlbmRlckxhbmVzKSB7XG4gIGZpYmVyLmxhbmVzID0gbWVyZ2VMYW5lcyhmaWJlci5sYW5lcywgcmVuZGVyTGFuZXMpO1xuICB2YXIgYWx0ZXJuYXRlID0gZmliZXIuYWx0ZXJuYXRlO1xuXG4gIGlmIChhbHRlcm5hdGUgIT09IG51bGwpIHtcbiAgICBhbHRlcm5hdGUubGFuZXMgPSBtZXJnZUxhbmVzKGFsdGVybmF0ZS5sYW5lcywgcmVuZGVyTGFuZXMpO1xuICB9XG5cbiAgc2NoZWR1bGVXb3JrT25QYXJlbnRQYXRoKGZpYmVyLnJldHVybiwgcmVuZGVyTGFuZXMpO1xufVxuXG5mdW5jdGlvbiBwcm9wYWdhdGVTdXNwZW5zZUNvbnRleHRDaGFuZ2Uod29ya0luUHJvZ3Jlc3MsIGZpcnN0Q2hpbGQsIHJlbmRlckxhbmVzKSB7XG4gIC8vIE1hcmsgYW55IFN1c3BlbnNlIGJvdW5kYXJpZXMgd2l0aCBmYWxsYmFja3MgYXMgaGF2aW5nIHdvcmsgdG8gZG8uXG4gIC8vIElmIHRoZXkgd2VyZSBwcmV2aW91c2x5IGZvcmNlZCBpbnRvIGZhbGxiYWNrcywgdGhleSBtYXkgbm93IGJlIGFibGVcbiAgLy8gdG8gdW5ibG9jay5cbiAgdmFyIG5vZGUgPSBmaXJzdENoaWxkO1xuXG4gIHdoaWxlIChub2RlICE9PSBudWxsKSB7XG4gICAgaWYgKG5vZGUudGFnID09PSBTdXNwZW5zZUNvbXBvbmVudCkge1xuICAgICAgdmFyIHN0YXRlID0gbm9kZS5tZW1vaXplZFN0YXRlO1xuXG4gICAgICBpZiAoc3RhdGUgIT09IG51bGwpIHtcbiAgICAgICAgc2NoZWR1bGVXb3JrT25GaWJlcihub2RlLCByZW5kZXJMYW5lcyk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChub2RlLnRhZyA9PT0gU3VzcGVuc2VMaXN0Q29tcG9uZW50KSB7XG4gICAgICAvLyBJZiB0aGUgdGFpbCBpcyBoaWRkZW4gdGhlcmUgbWlnaHQgbm90IGJlIGFuIFN1c3BlbnNlIGJvdW5kYXJpZXNcbiAgICAgIC8vIHRvIHNjaGVkdWxlIHdvcmsgb24uIEluIHRoaXMgY2FzZSB3ZSBoYXZlIHRvIHNjaGVkdWxlIGl0IG9uIHRoZVxuICAgICAgLy8gbGlzdCBpdHNlbGYuXG4gICAgICAvLyBXZSBkb24ndCBoYXZlIHRvIHRyYXZlcnNlIHRvIHRoZSBjaGlsZHJlbiBvZiB0aGUgbGlzdCBzaW5jZVxuICAgICAgLy8gdGhlIGxpc3Qgd2lsbCBwcm9wYWdhdGUgdGhlIGNoYW5nZSB3aGVuIGl0IHJlcmVuZGVycy5cbiAgICAgIHNjaGVkdWxlV29ya09uRmliZXIobm9kZSwgcmVuZGVyTGFuZXMpO1xuICAgIH0gZWxzZSBpZiAobm9kZS5jaGlsZCAhPT0gbnVsbCkge1xuICAgICAgbm9kZS5jaGlsZC5yZXR1cm4gPSBub2RlO1xuICAgICAgbm9kZSA9IG5vZGUuY2hpbGQ7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpZiAobm9kZSA9PT0gd29ya0luUHJvZ3Jlc3MpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB3aGlsZSAobm9kZS5zaWJsaW5nID09PSBudWxsKSB7XG4gICAgICBpZiAobm9kZS5yZXR1cm4gPT09IG51bGwgfHwgbm9kZS5yZXR1cm4gPT09IHdvcmtJblByb2dyZXNzKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgbm9kZSA9IG5vZGUucmV0dXJuO1xuICAgIH1cblxuICAgIG5vZGUuc2libGluZy5yZXR1cm4gPSBub2RlLnJldHVybjtcbiAgICBub2RlID0gbm9kZS5zaWJsaW5nO1xuICB9XG59XG5cbmZ1bmN0aW9uIGZpbmRMYXN0Q29udGVudFJvdyhmaXJzdENoaWxkKSB7XG4gIC8vIFRoaXMgaXMgZ29pbmcgdG8gZmluZCB0aGUgbGFzdCByb3cgYW1vbmcgdGhlc2UgY2hpbGRyZW4gdGhhdCBpcyBhbHJlYWR5XG4gIC8vIHNob3dpbmcgY29udGVudCBvbiB0aGUgc2NyZWVuLCBhcyBvcHBvc2VkIHRvIGJlaW5nIGluIGZhbGxiYWNrIHN0YXRlIG9yXG4gIC8vIG5ldy4gSWYgYSByb3cgaGFzIG11bHRpcGxlIFN1c3BlbnNlIGJvdW5kYXJpZXMsIGFueSBvZiB0aGVtIGJlaW5nIGluIHRoZVxuICAvLyBmYWxsYmFjayBzdGF0ZSwgY291bnRzIGFzIHRoZSB3aG9sZSByb3cgYmVpbmcgaW4gYSBmYWxsYmFjayBzdGF0ZS5cbiAgLy8gTm90ZSB0aGF0IHRoZSBcInJvd3NcIiB3aWxsIGJlIHdvcmtJblByb2dyZXNzLCBidXQgYW55IG5lc3RlZCBjaGlsZHJlblxuICAvLyB3aWxsIHN0aWxsIGJlIGN1cnJlbnQgc2luY2Ugd2UgaGF2ZW4ndCByZW5kZXJlZCB0aGVtIHlldC4gVGhlIG1vdW50ZWRcbiAgLy8gb3JkZXIgbWF5IG5vdCBiZSB0aGUgc2FtZSBhcyB0aGUgbmV3IG9yZGVyLiBXZSB1c2UgdGhlIG5ldyBvcmRlci5cbiAgdmFyIHJvdyA9IGZpcnN0Q2hpbGQ7XG4gIHZhciBsYXN0Q29udGVudFJvdyA9IG51bGw7XG5cbiAgd2hpbGUgKHJvdyAhPT0gbnVsbCkge1xuICAgIHZhciBjdXJyZW50Um93ID0gcm93LmFsdGVybmF0ZTsgLy8gTmV3IHJvd3MgY2FuJ3QgYmUgY29udGVudCByb3dzLlxuXG4gICAgaWYgKGN1cnJlbnRSb3cgIT09IG51bGwgJiYgZmluZEZpcnN0U3VzcGVuZGVkKGN1cnJlbnRSb3cpID09PSBudWxsKSB7XG4gICAgICBsYXN0Q29udGVudFJvdyA9IHJvdztcbiAgICB9XG5cbiAgICByb3cgPSByb3cuc2libGluZztcbiAgfVxuXG4gIHJldHVybiBsYXN0Q29udGVudFJvdztcbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVSZXZlYWxPcmRlcihyZXZlYWxPcmRlcikge1xuICB7XG4gICAgaWYgKHJldmVhbE9yZGVyICE9PSB1bmRlZmluZWQgJiYgcmV2ZWFsT3JkZXIgIT09ICdmb3J3YXJkcycgJiYgcmV2ZWFsT3JkZXIgIT09ICdiYWNrd2FyZHMnICYmIHJldmVhbE9yZGVyICE9PSAndG9nZXRoZXInICYmICFkaWRXYXJuQWJvdXRSZXZlYWxPcmRlcltyZXZlYWxPcmRlcl0pIHtcbiAgICAgIGRpZFdhcm5BYm91dFJldmVhbE9yZGVyW3JldmVhbE9yZGVyXSA9IHRydWU7XG5cbiAgICAgIGlmICh0eXBlb2YgcmV2ZWFsT3JkZXIgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHN3aXRjaCAocmV2ZWFsT3JkZXIudG9Mb3dlckNhc2UoKSkge1xuICAgICAgICAgIGNhc2UgJ3RvZ2V0aGVyJzpcbiAgICAgICAgICBjYXNlICdmb3J3YXJkcyc6XG4gICAgICAgICAgY2FzZSAnYmFja3dhcmRzJzpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgZXJyb3IoJ1wiJXNcIiBpcyBub3QgYSB2YWxpZCB2YWx1ZSBmb3IgcmV2ZWFsT3JkZXIgb24gPFN1c3BlbnNlTGlzdCAvPi4gJyArICdVc2UgbG93ZXJjYXNlIFwiJXNcIiBpbnN0ZWFkLicsIHJldmVhbE9yZGVyLCByZXZlYWxPcmRlci50b0xvd2VyQ2FzZSgpKTtcblxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIGNhc2UgJ2ZvcndhcmQnOlxuICAgICAgICAgIGNhc2UgJ2JhY2t3YXJkJzpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgZXJyb3IoJ1wiJXNcIiBpcyBub3QgYSB2YWxpZCB2YWx1ZSBmb3IgcmV2ZWFsT3JkZXIgb24gPFN1c3BlbnNlTGlzdCAvPi4gJyArICdSZWFjdCB1c2VzIHRoZSAtcyBzdWZmaXggaW4gdGhlIHNwZWxsaW5nLiBVc2UgXCIlc3NcIiBpbnN0ZWFkLicsIHJldmVhbE9yZGVyLCByZXZlYWxPcmRlci50b0xvd2VyQ2FzZSgpKTtcblxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBlcnJvcignXCIlc1wiIGlzIG5vdCBhIHN1cHBvcnRlZCByZXZlYWxPcmRlciBvbiA8U3VzcGVuc2VMaXN0IC8+LiAnICsgJ0RpZCB5b3UgbWVhbiBcInRvZ2V0aGVyXCIsIFwiZm9yd2FyZHNcIiBvciBcImJhY2t3YXJkc1wiPycsIHJldmVhbE9yZGVyKTtcblxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVycm9yKCclcyBpcyBub3QgYSBzdXBwb3J0ZWQgdmFsdWUgZm9yIHJldmVhbE9yZGVyIG9uIDxTdXNwZW5zZUxpc3QgLz4uICcgKyAnRGlkIHlvdSBtZWFuIFwidG9nZXRoZXJcIiwgXCJmb3J3YXJkc1wiIG9yIFwiYmFja3dhcmRzXCI/JywgcmV2ZWFsT3JkZXIpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZVRhaWxPcHRpb25zKHRhaWxNb2RlLCByZXZlYWxPcmRlcikge1xuICB7XG4gICAgaWYgKHRhaWxNb2RlICE9PSB1bmRlZmluZWQgJiYgIWRpZFdhcm5BYm91dFRhaWxPcHRpb25zW3RhaWxNb2RlXSkge1xuICAgICAgaWYgKHRhaWxNb2RlICE9PSAnY29sbGFwc2VkJyAmJiB0YWlsTW9kZSAhPT0gJ2hpZGRlbicpIHtcbiAgICAgICAgZGlkV2FybkFib3V0VGFpbE9wdGlvbnNbdGFpbE1vZGVdID0gdHJ1ZTtcblxuICAgICAgICBlcnJvcignXCIlc1wiIGlzIG5vdCBhIHN1cHBvcnRlZCB2YWx1ZSBmb3IgdGFpbCBvbiA8U3VzcGVuc2VMaXN0IC8+LiAnICsgJ0RpZCB5b3UgbWVhbiBcImNvbGxhcHNlZFwiIG9yIFwiaGlkZGVuXCI/JywgdGFpbE1vZGUpO1xuICAgICAgfSBlbHNlIGlmIChyZXZlYWxPcmRlciAhPT0gJ2ZvcndhcmRzJyAmJiByZXZlYWxPcmRlciAhPT0gJ2JhY2t3YXJkcycpIHtcbiAgICAgICAgZGlkV2FybkFib3V0VGFpbE9wdGlvbnNbdGFpbE1vZGVdID0gdHJ1ZTtcblxuICAgICAgICBlcnJvcignPFN1c3BlbnNlTGlzdCB0YWlsPVwiJXNcIiAvPiBpcyBvbmx5IHZhbGlkIGlmIHJldmVhbE9yZGVyIGlzICcgKyAnXCJmb3J3YXJkc1wiIG9yIFwiYmFja3dhcmRzXCIuICcgKyAnRGlkIHlvdSBtZWFuIHRvIHNwZWNpZnkgcmV2ZWFsT3JkZXI9XCJmb3J3YXJkc1wiPycsIHRhaWxNb2RlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVTdXNwZW5zZUxpc3ROZXN0ZWRDaGlsZChjaGlsZFNsb3QsIGluZGV4KSB7XG4gIHtcbiAgICB2YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXkoY2hpbGRTbG90KTtcbiAgICB2YXIgaXNJdGVyYWJsZSA9ICFpc0FycmF5ICYmIHR5cGVvZiBnZXRJdGVyYXRvckZuKGNoaWxkU2xvdCkgPT09ICdmdW5jdGlvbic7XG5cbiAgICBpZiAoaXNBcnJheSB8fCBpc0l0ZXJhYmxlKSB7XG4gICAgICB2YXIgdHlwZSA9IGlzQXJyYXkgPyAnYXJyYXknIDogJ2l0ZXJhYmxlJztcblxuICAgICAgZXJyb3IoJ0EgbmVzdGVkICVzIHdhcyBwYXNzZWQgdG8gcm93ICMlcyBpbiA8U3VzcGVuc2VMaXN0IC8+LiBXcmFwIGl0IGluICcgKyAnYW4gYWRkaXRpb25hbCBTdXNwZW5zZUxpc3QgdG8gY29uZmlndXJlIGl0cyByZXZlYWxPcmRlcjogJyArICc8U3VzcGVuc2VMaXN0IHJldmVhbE9yZGVyPS4uLj4gLi4uICcgKyAnPFN1c3BlbnNlTGlzdCByZXZlYWxPcmRlcj0uLi4+eyVzfTwvU3VzcGVuc2VMaXN0PiAuLi4gJyArICc8L1N1c3BlbnNlTGlzdD4nLCB0eXBlLCBpbmRleCwgdHlwZSk7XG5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVTdXNwZW5zZUxpc3RDaGlsZHJlbihjaGlsZHJlbiwgcmV2ZWFsT3JkZXIpIHtcbiAge1xuICAgIGlmICgocmV2ZWFsT3JkZXIgPT09ICdmb3J3YXJkcycgfHwgcmV2ZWFsT3JkZXIgPT09ICdiYWNrd2FyZHMnKSAmJiBjaGlsZHJlbiAhPT0gdW5kZWZpbmVkICYmIGNoaWxkcmVuICE9PSBudWxsICYmIGNoaWxkcmVuICE9PSBmYWxzZSkge1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBpZiAoIXZhbGlkYXRlU3VzcGVuc2VMaXN0TmVzdGVkQ2hpbGQoY2hpbGRyZW5baV0sIGkpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgaXRlcmF0b3JGbiA9IGdldEl0ZXJhdG9yRm4oY2hpbGRyZW4pO1xuXG4gICAgICAgIGlmICh0eXBlb2YgaXRlcmF0b3JGbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHZhciBjaGlsZHJlbkl0ZXJhdG9yID0gaXRlcmF0b3JGbi5jYWxsKGNoaWxkcmVuKTtcblxuICAgICAgICAgIGlmIChjaGlsZHJlbkl0ZXJhdG9yKSB7XG4gICAgICAgICAgICB2YXIgc3RlcCA9IGNoaWxkcmVuSXRlcmF0b3IubmV4dCgpO1xuICAgICAgICAgICAgdmFyIF9pID0gMDtcblxuICAgICAgICAgICAgZm9yICg7ICFzdGVwLmRvbmU7IHN0ZXAgPSBjaGlsZHJlbkl0ZXJhdG9yLm5leHQoKSkge1xuICAgICAgICAgICAgICBpZiAoIXZhbGlkYXRlU3VzcGVuc2VMaXN0TmVzdGVkQ2hpbGQoc3RlcC52YWx1ZSwgX2kpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgX2krKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZXJyb3IoJ0Egc2luZ2xlIHJvdyB3YXMgcGFzc2VkIHRvIGEgPFN1c3BlbnNlTGlzdCByZXZlYWxPcmRlcj1cIiVzXCIgLz4uICcgKyAnVGhpcyBpcyBub3QgdXNlZnVsIHNpbmNlIGl0IG5lZWRzIG11bHRpcGxlIHJvd3MuICcgKyAnRGlkIHlvdSBtZWFuIHRvIHBhc3MgbXVsdGlwbGUgY2hpbGRyZW4gb3IgYW4gYXJyYXk/JywgcmV2ZWFsT3JkZXIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGluaXRTdXNwZW5zZUxpc3RSZW5kZXJTdGF0ZSh3b3JrSW5Qcm9ncmVzcywgaXNCYWNrd2FyZHMsIHRhaWwsIGxhc3RDb250ZW50Um93LCB0YWlsTW9kZSwgbGFzdEVmZmVjdEJlZm9yZVJlbmRlcmluZykge1xuICB2YXIgcmVuZGVyU3RhdGUgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO1xuXG4gIGlmIChyZW5kZXJTdGF0ZSA9PT0gbnVsbCkge1xuICAgIHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSB7XG4gICAgICBpc0JhY2t3YXJkczogaXNCYWNrd2FyZHMsXG4gICAgICByZW5kZXJpbmc6IG51bGwsXG4gICAgICByZW5kZXJpbmdTdGFydFRpbWU6IDAsXG4gICAgICBsYXN0OiBsYXN0Q29udGVudFJvdyxcbiAgICAgIHRhaWw6IHRhaWwsXG4gICAgICB0YWlsTW9kZTogdGFpbE1vZGUsXG4gICAgICBsYXN0RWZmZWN0OiBsYXN0RWZmZWN0QmVmb3JlUmVuZGVyaW5nXG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICAvLyBXZSBjYW4gcmV1c2UgdGhlIGV4aXN0aW5nIG9iamVjdCBmcm9tIHByZXZpb3VzIHJlbmRlcnMuXG4gICAgcmVuZGVyU3RhdGUuaXNCYWNrd2FyZHMgPSBpc0JhY2t3YXJkcztcbiAgICByZW5kZXJTdGF0ZS5yZW5kZXJpbmcgPSBudWxsO1xuICAgIHJlbmRlclN0YXRlLnJlbmRlcmluZ1N0YXJ0VGltZSA9IDA7XG4gICAgcmVuZGVyU3RhdGUubGFzdCA9IGxhc3RDb250ZW50Um93O1xuICAgIHJlbmRlclN0YXRlLnRhaWwgPSB0YWlsO1xuICAgIHJlbmRlclN0YXRlLnRhaWxNb2RlID0gdGFpbE1vZGU7XG4gICAgcmVuZGVyU3RhdGUubGFzdEVmZmVjdCA9IGxhc3RFZmZlY3RCZWZvcmVSZW5kZXJpbmc7XG4gIH1cbn0gLy8gVGhpcyBjYW4gZW5kIHVwIHJlbmRlcmluZyB0aGlzIGNvbXBvbmVudCBtdWx0aXBsZSBwYXNzZXMuXG4vLyBUaGUgZmlyc3QgcGFzcyBzcGxpdHMgdGhlIGNoaWxkcmVuIGZpYmVycyBpbnRvIHR3byBzZXRzLiBBIGhlYWQgYW5kIHRhaWwuXG4vLyBXZSBmaXJzdCByZW5kZXIgdGhlIGhlYWQuIElmIGFueXRoaW5nIGlzIGluIGZhbGxiYWNrIHN0YXRlLCB3ZSBkbyBhbm90aGVyXG4vLyBwYXNzIHRocm91Z2ggYmVnaW5Xb3JrIHRvIHJlcmVuZGVyIGFsbCBjaGlsZHJlbiAoaW5jbHVkaW5nIHRoZSB0YWlsKSB3aXRoXG4vLyB0aGUgZm9yY2Ugc3VzcGVuZCBjb250ZXh0LiBJZiB0aGUgZmlyc3QgcmVuZGVyIGRpZG4ndCBoYXZlIGFueXRoaW5nIGluXG4vLyBpbiBmYWxsYmFjayBzdGF0ZS4gVGhlbiB3ZSByZW5kZXIgZWFjaCByb3cgaW4gdGhlIHRhaWwgb25lLWJ5LW9uZS5cbi8vIFRoYXQgaGFwcGVucyBpbiB0aGUgY29tcGxldGVXb3JrIHBoYXNlIHdpdGhvdXQgZ29pbmcgYmFjayB0byBiZWdpbldvcmsuXG5cblxuZnVuY3Rpb24gdXBkYXRlU3VzcGVuc2VMaXN0Q29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcykge1xuICB2YXIgbmV4dFByb3BzID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzO1xuICB2YXIgcmV2ZWFsT3JkZXIgPSBuZXh0UHJvcHMucmV2ZWFsT3JkZXI7XG4gIHZhciB0YWlsTW9kZSA9IG5leHRQcm9wcy50YWlsO1xuICB2YXIgbmV3Q2hpbGRyZW4gPSBuZXh0UHJvcHMuY2hpbGRyZW47XG4gIHZhbGlkYXRlUmV2ZWFsT3JkZXIocmV2ZWFsT3JkZXIpO1xuICB2YWxpZGF0ZVRhaWxPcHRpb25zKHRhaWxNb2RlLCByZXZlYWxPcmRlcik7XG4gIHZhbGlkYXRlU3VzcGVuc2VMaXN0Q2hpbGRyZW4obmV3Q2hpbGRyZW4sIHJldmVhbE9yZGVyKTtcbiAgcmVjb25jaWxlQ2hpbGRyZW4oY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIG5ld0NoaWxkcmVuLCByZW5kZXJMYW5lcyk7XG4gIHZhciBzdXNwZW5zZUNvbnRleHQgPSBzdXNwZW5zZVN0YWNrQ3Vyc29yLmN1cnJlbnQ7XG4gIHZhciBzaG91bGRGb3JjZUZhbGxiYWNrID0gaGFzU3VzcGVuc2VDb250ZXh0KHN1c3BlbnNlQ29udGV4dCwgRm9yY2VTdXNwZW5zZUZhbGxiYWNrKTtcblxuICBpZiAoc2hvdWxkRm9yY2VGYWxsYmFjaykge1xuICAgIHN1c3BlbnNlQ29udGV4dCA9IHNldFNoYWxsb3dTdXNwZW5zZUNvbnRleHQoc3VzcGVuc2VDb250ZXh0LCBGb3JjZVN1c3BlbnNlRmFsbGJhY2spO1xuICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IERpZENhcHR1cmU7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGRpZFN1c3BlbmRCZWZvcmUgPSBjdXJyZW50ICE9PSBudWxsICYmIChjdXJyZW50LmZsYWdzICYgRGlkQ2FwdHVyZSkgIT09IE5vRmxhZ3M7XG5cbiAgICBpZiAoZGlkU3VzcGVuZEJlZm9yZSkge1xuICAgICAgLy8gSWYgd2UgcHJldmlvdXNseSBmb3JjZWQgYSBmYWxsYmFjaywgd2UgbmVlZCB0byBzY2hlZHVsZSB3b3JrXG4gICAgICAvLyBvbiBhbnkgbmVzdGVkIGJvdW5kYXJpZXMgdG8gbGV0IHRoZW0ga25vdyB0byB0cnkgdG8gcmVuZGVyXG4gICAgICAvLyBhZ2Fpbi4gVGhpcyBpcyB0aGUgc2FtZSBhcyBjb250ZXh0IHVwZGF0aW5nLlxuICAgICAgcHJvcGFnYXRlU3VzcGVuc2VDb250ZXh0Q2hhbmdlKHdvcmtJblByb2dyZXNzLCB3b3JrSW5Qcm9ncmVzcy5jaGlsZCwgcmVuZGVyTGFuZXMpO1xuICAgIH1cblxuICAgIHN1c3BlbnNlQ29udGV4dCA9IHNldERlZmF1bHRTaGFsbG93U3VzcGVuc2VDb250ZXh0KHN1c3BlbnNlQ29udGV4dCk7XG4gIH1cblxuICBwdXNoU3VzcGVuc2VDb250ZXh0KHdvcmtJblByb2dyZXNzLCBzdXNwZW5zZUNvbnRleHQpO1xuXG4gIGlmICgod29ya0luUHJvZ3Jlc3MubW9kZSAmIEJsb2NraW5nTW9kZSkgPT09IE5vTW9kZSkge1xuICAgIC8vIEluIGxlZ2FjeSBtb2RlLCBTdXNwZW5zZUxpc3QgZG9lc24ndCB3b3JrIHNvIHdlIGp1c3RcbiAgICAvLyB1c2UgbWFrZSBpdCBhIG5vb3AgYnkgdHJlYXRpbmcgaXQgYXMgdGhlIGRlZmF1bHQgcmV2ZWFsT3JkZXIuXG4gICAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IG51bGw7XG4gIH0gZWxzZSB7XG4gICAgc3dpdGNoIChyZXZlYWxPcmRlcikge1xuICAgICAgY2FzZSAnZm9yd2FyZHMnOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIGxhc3RDb250ZW50Um93ID0gZmluZExhc3RDb250ZW50Um93KHdvcmtJblByb2dyZXNzLmNoaWxkKTtcbiAgICAgICAgICB2YXIgdGFpbDtcblxuICAgICAgICAgIGlmIChsYXN0Q29udGVudFJvdyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gVGhlIHdob2xlIGxpc3QgaXMgcGFydCBvZiB0aGUgdGFpbC5cbiAgICAgICAgICAgIC8vIFRPRE86IFdlIGNvdWxkIGZhc3QgcGF0aCBieSBqdXN0IHJlbmRlcmluZyB0aGUgdGFpbCBub3cuXG4gICAgICAgICAgICB0YWlsID0gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IG51bGw7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIERpc2Nvbm5lY3QgdGhlIHRhaWwgcm93cyBhZnRlciB0aGUgY29udGVudCByb3cuXG4gICAgICAgICAgICAvLyBXZSdyZSBnb2luZyB0byByZW5kZXIgdGhlbSBzZXBhcmF0ZWx5IGxhdGVyLlxuICAgICAgICAgICAgdGFpbCA9IGxhc3RDb250ZW50Um93LnNpYmxpbmc7XG4gICAgICAgICAgICBsYXN0Q29udGVudFJvdy5zaWJsaW5nID0gbnVsbDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpbml0U3VzcGVuc2VMaXN0UmVuZGVyU3RhdGUod29ya0luUHJvZ3Jlc3MsIGZhbHNlLCAvLyBpc0JhY2t3YXJkc1xuICAgICAgICAgIHRhaWwsIGxhc3RDb250ZW50Um93LCB0YWlsTW9kZSwgd29ya0luUHJvZ3Jlc3MubGFzdEVmZmVjdCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSAnYmFja3dhcmRzJzpcbiAgICAgICAge1xuICAgICAgICAgIC8vIFdlJ3JlIGdvaW5nIHRvIGZpbmQgdGhlIGZpcnN0IHJvdyB0aGF0IGhhcyBleGlzdGluZyBjb250ZW50LlxuICAgICAgICAgIC8vIEF0IHRoZSBzYW1lIHRpbWUgd2UncmUgZ29pbmcgdG8gcmV2ZXJzZSB0aGUgbGlzdCBvZiBldmVyeXRoaW5nXG4gICAgICAgICAgLy8gd2UgcGFzcyBpbiB0aGUgbWVhbnRpbWUuIFRoYXQncyBnb2luZyB0byBiZSBvdXIgdGFpbCBpbiByZXZlcnNlXG4gICAgICAgICAgLy8gb3JkZXIuXG4gICAgICAgICAgdmFyIF90YWlsID0gbnVsbDtcbiAgICAgICAgICB2YXIgcm93ID0gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3MuY2hpbGQgPSBudWxsO1xuXG4gICAgICAgICAgd2hpbGUgKHJvdyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdmFyIGN1cnJlbnRSb3cgPSByb3cuYWx0ZXJuYXRlOyAvLyBOZXcgcm93cyBjYW4ndCBiZSBjb250ZW50IHJvd3MuXG5cbiAgICAgICAgICAgIGlmIChjdXJyZW50Um93ICE9PSBudWxsICYmIGZpbmRGaXJzdFN1c3BlbmRlZChjdXJyZW50Um93KSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAvLyBUaGlzIGlzIHRoZSBiZWdpbm5pbmcgb2YgdGhlIG1haW4gY29udGVudC5cbiAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MuY2hpbGQgPSByb3c7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgbmV4dFJvdyA9IHJvdy5zaWJsaW5nO1xuICAgICAgICAgICAgcm93LnNpYmxpbmcgPSBfdGFpbDtcbiAgICAgICAgICAgIF90YWlsID0gcm93O1xuICAgICAgICAgICAgcm93ID0gbmV4dFJvdztcbiAgICAgICAgICB9IC8vIFRPRE86IElmIHdvcmtJblByb2dyZXNzLmNoaWxkIGlzIG51bGwsIHdlIGNhbiBjb250aW51ZSBvbiB0aGUgdGFpbCBpbW1lZGlhdGVseS5cblxuXG4gICAgICAgICAgaW5pdFN1c3BlbnNlTGlzdFJlbmRlclN0YXRlKHdvcmtJblByb2dyZXNzLCB0cnVlLCAvLyBpc0JhY2t3YXJkc1xuICAgICAgICAgIF90YWlsLCBudWxsLCAvLyBsYXN0XG4gICAgICAgICAgdGFpbE1vZGUsIHdvcmtJblByb2dyZXNzLmxhc3RFZmZlY3QpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgJ3RvZ2V0aGVyJzpcbiAgICAgICAge1xuICAgICAgICAgIGluaXRTdXNwZW5zZUxpc3RSZW5kZXJTdGF0ZSh3b3JrSW5Qcm9ncmVzcywgZmFsc2UsIC8vIGlzQmFja3dhcmRzXG4gICAgICAgICAgbnVsbCwgLy8gdGFpbFxuICAgICAgICAgIG51bGwsIC8vIGxhc3RcbiAgICAgICAgICB1bmRlZmluZWQsIHdvcmtJblByb2dyZXNzLmxhc3RFZmZlY3QpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHtcbiAgICAgICAgICAvLyBUaGUgZGVmYXVsdCByZXZlYWwgb3JkZXIgaXMgdGhlIHNhbWUgYXMgbm90IGhhdmluZ1xuICAgICAgICAgIC8vIGEgYm91bmRhcnkuXG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZVBvcnRhbENvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpIHtcbiAgcHVzaEhvc3RDb250YWluZXIod29ya0luUHJvZ3Jlc3MsIHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZS5jb250YWluZXJJbmZvKTtcbiAgdmFyIG5leHRDaGlsZHJlbiA9IHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcztcblxuICBpZiAoY3VycmVudCA9PT0gbnVsbCkge1xuICAgIC8vIFBvcnRhbHMgYXJlIHNwZWNpYWwgYmVjYXVzZSB3ZSBkb24ndCBhcHBlbmQgdGhlIGNoaWxkcmVuIGR1cmluZyBtb3VudFxuICAgIC8vIGJ1dCBhdCBjb21taXQuIFRoZXJlZm9yZSB3ZSBuZWVkIHRvIHRyYWNrIGluc2VydGlvbnMgd2hpY2ggdGhlIG5vcm1hbFxuICAgIC8vIGZsb3cgZG9lc24ndCBkbyBkdXJpbmcgbW91bnQuIFRoaXMgZG9lc24ndCBoYXBwZW4gYXQgdGhlIHJvb3QgYmVjYXVzZVxuICAgIC8vIHRoZSByb290IGFsd2F5cyBzdGFydHMgd2l0aCBhIFwiY3VycmVudFwiIHdpdGggYSBudWxsIGNoaWxkLlxuICAgIC8vIFRPRE86IENvbnNpZGVyIHVuaWZ5aW5nIHRoaXMgd2l0aCBob3cgdGhlIHJvb3Qgd29ya3MuXG4gICAgd29ya0luUHJvZ3Jlc3MuY2hpbGQgPSByZWNvbmNpbGVDaGlsZEZpYmVycyh3b3JrSW5Qcm9ncmVzcywgbnVsbCwgbmV4dENoaWxkcmVuLCByZW5kZXJMYW5lcyk7XG4gIH0gZWxzZSB7XG4gICAgcmVjb25jaWxlQ2hpbGRyZW4oY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIG5leHRDaGlsZHJlbiwgcmVuZGVyTGFuZXMpO1xuICB9XG5cbiAgcmV0dXJuIHdvcmtJblByb2dyZXNzLmNoaWxkO1xufVxuXG52YXIgaGFzV2FybmVkQWJvdXRVc2luZ05vVmFsdWVQcm9wT25Db250ZXh0UHJvdmlkZXIgPSBmYWxzZTtcblxuZnVuY3Rpb24gdXBkYXRlQ29udGV4dFByb3ZpZGVyKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcykge1xuICB2YXIgcHJvdmlkZXJUeXBlID0gd29ya0luUHJvZ3Jlc3MudHlwZTtcbiAgdmFyIGNvbnRleHQgPSBwcm92aWRlclR5cGUuX2NvbnRleHQ7XG4gIHZhciBuZXdQcm9wcyA9IHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcztcbiAgdmFyIG9sZFByb3BzID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcztcbiAgdmFyIG5ld1ZhbHVlID0gbmV3UHJvcHMudmFsdWU7XG5cbiAge1xuICAgIGlmICghKCd2YWx1ZScgaW4gbmV3UHJvcHMpKSB7XG4gICAgICBpZiAoIWhhc1dhcm5lZEFib3V0VXNpbmdOb1ZhbHVlUHJvcE9uQ29udGV4dFByb3ZpZGVyKSB7XG4gICAgICAgIGhhc1dhcm5lZEFib3V0VXNpbmdOb1ZhbHVlUHJvcE9uQ29udGV4dFByb3ZpZGVyID0gdHJ1ZTtcblxuICAgICAgICBlcnJvcignVGhlIGB2YWx1ZWAgcHJvcCBpcyByZXF1aXJlZCBmb3IgdGhlIGA8Q29udGV4dC5Qcm92aWRlcj5gLiBEaWQgeW91IG1pc3NwZWxsIGl0IG9yIGZvcmdldCB0byBwYXNzIGl0PycpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBwcm92aWRlclByb3BUeXBlcyA9IHdvcmtJblByb2dyZXNzLnR5cGUucHJvcFR5cGVzO1xuXG4gICAgaWYgKHByb3ZpZGVyUHJvcFR5cGVzKSB7XG4gICAgICBjaGVja1Byb3BUeXBlcyhwcm92aWRlclByb3BUeXBlcywgbmV3UHJvcHMsICdwcm9wJywgJ0NvbnRleHQuUHJvdmlkZXInKTtcbiAgICB9XG4gIH1cblxuICBwdXNoUHJvdmlkZXIod29ya0luUHJvZ3Jlc3MsIG5ld1ZhbHVlKTtcblxuICBpZiAob2xkUHJvcHMgIT09IG51bGwpIHtcbiAgICB2YXIgb2xkVmFsdWUgPSBvbGRQcm9wcy52YWx1ZTtcbiAgICB2YXIgY2hhbmdlZEJpdHMgPSBjYWxjdWxhdGVDaGFuZ2VkQml0cyhjb250ZXh0LCBuZXdWYWx1ZSwgb2xkVmFsdWUpO1xuXG4gICAgaWYgKGNoYW5nZWRCaXRzID09PSAwKSB7XG4gICAgICAvLyBObyBjaGFuZ2UuIEJhaWxvdXQgZWFybHkgaWYgY2hpbGRyZW4gYXJlIHRoZSBzYW1lLlxuICAgICAgaWYgKG9sZFByb3BzLmNoaWxkcmVuID09PSBuZXdQcm9wcy5jaGlsZHJlbiAmJiAhaGFzQ29udGV4dENoYW5nZWQoKSkge1xuICAgICAgICByZXR1cm4gYmFpbG91dE9uQWxyZWFkeUZpbmlzaGVkV29yayhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBUaGUgY29udGV4dCB2YWx1ZSBjaGFuZ2VkLiBTZWFyY2ggZm9yIG1hdGNoaW5nIGNvbnN1bWVycyBhbmQgc2NoZWR1bGVcbiAgICAgIC8vIHRoZW0gdG8gdXBkYXRlLlxuICAgICAgcHJvcGFnYXRlQ29udGV4dENoYW5nZSh3b3JrSW5Qcm9ncmVzcywgY29udGV4dCwgY2hhbmdlZEJpdHMsIHJlbmRlckxhbmVzKTtcbiAgICB9XG4gIH1cblxuICB2YXIgbmV3Q2hpbGRyZW4gPSBuZXdQcm9wcy5jaGlsZHJlbjtcbiAgcmVjb25jaWxlQ2hpbGRyZW4oY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIG5ld0NoaWxkcmVuLCByZW5kZXJMYW5lcyk7XG4gIHJldHVybiB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbn1cblxudmFyIGhhc1dhcm5lZEFib3V0VXNpbmdDb250ZXh0QXNDb25zdW1lciA9IGZhbHNlO1xuXG5mdW5jdGlvbiB1cGRhdGVDb250ZXh0Q29uc3VtZXIoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKSB7XG4gIHZhciBjb250ZXh0ID0gd29ya0luUHJvZ3Jlc3MudHlwZTsgLy8gVGhlIGxvZ2ljIGJlbG93IGZvciBDb250ZXh0IGRpZmZlcnMgZGVwZW5kaW5nIG9uIFBST0Qgb3IgREVWIG1vZGUuIEluXG4gIC8vIERFViBtb2RlLCB3ZSBjcmVhdGUgYSBzZXBhcmF0ZSBvYmplY3QgZm9yIENvbnRleHQuQ29uc3VtZXIgdGhhdCBhY3RzXG4gIC8vIGxpa2UgYSBwcm94eSB0byBDb250ZXh0LiBUaGlzIHByb3h5IG9iamVjdCBhZGRzIHVubmVjZXNzYXJ5IGNvZGUgaW4gUFJPRFxuICAvLyBzbyB3ZSB1c2UgdGhlIG9sZCBiZWhhdmlvdXIgKENvbnRleHQuQ29uc3VtZXIgcmVmZXJlbmNlcyBDb250ZXh0KSB0b1xuICAvLyByZWR1Y2Ugc2l6ZSBhbmQgb3ZlcmhlYWQuIFRoZSBzZXBhcmF0ZSBvYmplY3QgcmVmZXJlbmNlcyBjb250ZXh0IHZpYVxuICAvLyBhIHByb3BlcnR5IGNhbGxlZCBcIl9jb250ZXh0XCIsIHdoaWNoIGFsc28gZ2l2ZXMgdXMgdGhlIGFiaWxpdHkgdG8gY2hlY2tcbiAgLy8gaW4gREVWIG1vZGUgaWYgdGhpcyBwcm9wZXJ0eSBleGlzdHMgb3Igbm90IGFuZCB3YXJuIGlmIGl0IGRvZXMgbm90LlxuXG4gIHtcbiAgICBpZiAoY29udGV4dC5fY29udGV4dCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBUaGlzIG1heSBiZSBiZWNhdXNlIGl0J3MgYSBDb250ZXh0IChyYXRoZXIgdGhhbiBhIENvbnN1bWVyKS5cbiAgICAgIC8vIE9yIGl0IG1heSBiZSBiZWNhdXNlIGl0J3Mgb2xkZXIgUmVhY3Qgd2hlcmUgdGhleSdyZSB0aGUgc2FtZSB0aGluZy5cbiAgICAgIC8vIFdlIG9ubHkgd2FudCB0byB3YXJuIGlmIHdlJ3JlIHN1cmUgaXQncyBhIG5ldyBSZWFjdC5cbiAgICAgIGlmIChjb250ZXh0ICE9PSBjb250ZXh0LkNvbnN1bWVyKSB7XG4gICAgICAgIGlmICghaGFzV2FybmVkQWJvdXRVc2luZ0NvbnRleHRBc0NvbnN1bWVyKSB7XG4gICAgICAgICAgaGFzV2FybmVkQWJvdXRVc2luZ0NvbnRleHRBc0NvbnN1bWVyID0gdHJ1ZTtcblxuICAgICAgICAgIGVycm9yKCdSZW5kZXJpbmcgPENvbnRleHQ+IGRpcmVjdGx5IGlzIG5vdCBzdXBwb3J0ZWQgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiAnICsgJ2EgZnV0dXJlIG1ham9yIHJlbGVhc2UuIERpZCB5b3UgbWVhbiB0byByZW5kZXIgPENvbnRleHQuQ29uc3VtZXI+IGluc3RlYWQ/Jyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29udGV4dCA9IGNvbnRleHQuX2NvbnRleHQ7XG4gICAgfVxuICB9XG5cbiAgdmFyIG5ld1Byb3BzID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzO1xuICB2YXIgcmVuZGVyID0gbmV3UHJvcHMuY2hpbGRyZW47XG5cbiAge1xuICAgIGlmICh0eXBlb2YgcmVuZGVyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICBlcnJvcignQSBjb250ZXh0IGNvbnN1bWVyIHdhcyByZW5kZXJlZCB3aXRoIG11bHRpcGxlIGNoaWxkcmVuLCBvciBhIGNoaWxkICcgKyBcInRoYXQgaXNuJ3QgYSBmdW5jdGlvbi4gQSBjb250ZXh0IGNvbnN1bWVyIGV4cGVjdHMgYSBzaW5nbGUgY2hpbGQgXCIgKyAndGhhdCBpcyBhIGZ1bmN0aW9uLiBJZiB5b3UgZGlkIHBhc3MgYSBmdW5jdGlvbiwgbWFrZSBzdXJlIHRoZXJlICcgKyAnaXMgbm8gdHJhaWxpbmcgb3IgbGVhZGluZyB3aGl0ZXNwYWNlIGFyb3VuZCBpdC4nKTtcbiAgICB9XG4gIH1cblxuICBwcmVwYXJlVG9SZWFkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpO1xuICB2YXIgbmV3VmFsdWUgPSByZWFkQ29udGV4dChjb250ZXh0LCBuZXdQcm9wcy51bnN0YWJsZV9vYnNlcnZlZEJpdHMpO1xuICB2YXIgbmV3Q2hpbGRyZW47XG5cbiAge1xuICAgIFJlYWN0Q3VycmVudE93bmVyJDEuY3VycmVudCA9IHdvcmtJblByb2dyZXNzO1xuICAgIHNldElzUmVuZGVyaW5nKHRydWUpO1xuICAgIG5ld0NoaWxkcmVuID0gcmVuZGVyKG5ld1ZhbHVlKTtcbiAgICBzZXRJc1JlbmRlcmluZyhmYWxzZSk7XG4gIH0gLy8gUmVhY3QgRGV2VG9vbHMgcmVhZHMgdGhpcyBmbGFnLlxuXG5cbiAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gUGVyZm9ybWVkV29yaztcbiAgcmVjb25jaWxlQ2hpbGRyZW4oY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIG5ld0NoaWxkcmVuLCByZW5kZXJMYW5lcyk7XG4gIHJldHVybiB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbn1cblxuZnVuY3Rpb24gbWFya1dvcmtJblByb2dyZXNzUmVjZWl2ZWRVcGRhdGUoKSB7XG4gIGRpZFJlY2VpdmVVcGRhdGUgPSB0cnVlO1xufVxuXG5mdW5jdGlvbiBiYWlsb3V0T25BbHJlYWR5RmluaXNoZWRXb3JrKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcykge1xuICBpZiAoY3VycmVudCAhPT0gbnVsbCkge1xuICAgIC8vIFJldXNlIHByZXZpb3VzIGRlcGVuZGVuY2llc1xuICAgIHdvcmtJblByb2dyZXNzLmRlcGVuZGVuY2llcyA9IGN1cnJlbnQuZGVwZW5kZW5jaWVzO1xuICB9XG5cbiAge1xuICAgIC8vIERvbid0IHVwZGF0ZSBcImJhc2VcIiByZW5kZXIgdGltZXMgZm9yIGJhaWxvdXRzLlxuICAgIHN0b3BQcm9maWxlclRpbWVySWZSdW5uaW5nKCk7XG4gIH1cblxuICBtYXJrU2tpcHBlZFVwZGF0ZUxhbmVzKHdvcmtJblByb2dyZXNzLmxhbmVzKTsgLy8gQ2hlY2sgaWYgdGhlIGNoaWxkcmVuIGhhdmUgYW55IHBlbmRpbmcgd29yay5cblxuICBpZiAoIWluY2x1ZGVzU29tZUxhbmUocmVuZGVyTGFuZXMsIHdvcmtJblByb2dyZXNzLmNoaWxkTGFuZXMpKSB7XG4gICAgLy8gVGhlIGNoaWxkcmVuIGRvbid0IGhhdmUgYW55IHdvcmsgZWl0aGVyLiBXZSBjYW4gc2tpcCB0aGVtLlxuICAgIC8vIFRPRE86IE9uY2Ugd2UgYWRkIGJhY2sgcmVzdW1pbmcsIHdlIHNob3VsZCBjaGVjayBpZiB0aGUgY2hpbGRyZW4gYXJlXG4gICAgLy8gYSB3b3JrLWluLXByb2dyZXNzIHNldC4gSWYgc28sIHdlIG5lZWQgdG8gdHJhbnNmZXIgdGhlaXIgZWZmZWN0cy5cbiAgICByZXR1cm4gbnVsbDtcbiAgfSBlbHNlIHtcbiAgICAvLyBUaGlzIGZpYmVyIGRvZXNuJ3QgaGF2ZSB3b3JrLCBidXQgaXRzIHN1YnRyZWUgZG9lcy4gQ2xvbmUgdGhlIGNoaWxkXG4gICAgLy8gZmliZXJzIGFuZCBjb250aW51ZS5cbiAgICBjbG9uZUNoaWxkRmliZXJzKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKTtcbiAgICByZXR1cm4gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVtb3VudEZpYmVyKGN1cnJlbnQsIG9sZFdvcmtJblByb2dyZXNzLCBuZXdXb3JrSW5Qcm9ncmVzcykge1xuICB7XG4gICAgdmFyIHJldHVybkZpYmVyID0gb2xkV29ya0luUHJvZ3Jlc3MucmV0dXJuO1xuXG4gICAgaWYgKHJldHVybkZpYmVyID09PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBzd2FwIHRoZSByb290IGZpYmVyLicpO1xuICAgIH0gLy8gRGlzY29ubmVjdCBmcm9tIHRoZSBvbGQgY3VycmVudC5cbiAgICAvLyBJdCB3aWxsIGdldCBkZWxldGVkLlxuXG5cbiAgICBjdXJyZW50LmFsdGVybmF0ZSA9IG51bGw7XG4gICAgb2xkV29ya0luUHJvZ3Jlc3MuYWx0ZXJuYXRlID0gbnVsbDsgLy8gQ29ubmVjdCB0byB0aGUgbmV3IHRyZWUuXG5cbiAgICBuZXdXb3JrSW5Qcm9ncmVzcy5pbmRleCA9IG9sZFdvcmtJblByb2dyZXNzLmluZGV4O1xuICAgIG5ld1dvcmtJblByb2dyZXNzLnNpYmxpbmcgPSBvbGRXb3JrSW5Qcm9ncmVzcy5zaWJsaW5nO1xuICAgIG5ld1dvcmtJblByb2dyZXNzLnJldHVybiA9IG9sZFdvcmtJblByb2dyZXNzLnJldHVybjtcbiAgICBuZXdXb3JrSW5Qcm9ncmVzcy5yZWYgPSBvbGRXb3JrSW5Qcm9ncmVzcy5yZWY7IC8vIFJlcGxhY2UgdGhlIGNoaWxkL3NpYmxpbmcgcG9pbnRlcnMgYWJvdmUgaXQuXG5cbiAgICBpZiAob2xkV29ya0luUHJvZ3Jlc3MgPT09IHJldHVybkZpYmVyLmNoaWxkKSB7XG4gICAgICByZXR1cm5GaWJlci5jaGlsZCA9IG5ld1dvcmtJblByb2dyZXNzO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgcHJldlNpYmxpbmcgPSByZXR1cm5GaWJlci5jaGlsZDtcblxuICAgICAgaWYgKHByZXZTaWJsaW5nID09PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgcGFyZW50IHRvIGhhdmUgYSBjaGlsZC4nKTtcbiAgICAgIH1cblxuICAgICAgd2hpbGUgKHByZXZTaWJsaW5nLnNpYmxpbmcgIT09IG9sZFdvcmtJblByb2dyZXNzKSB7XG4gICAgICAgIHByZXZTaWJsaW5nID0gcHJldlNpYmxpbmcuc2libGluZztcblxuICAgICAgICBpZiAocHJldlNpYmxpbmcgPT09IG51bGwpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIHRvIGZpbmQgdGhlIHByZXZpb3VzIHNpYmxpbmcuJyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcHJldlNpYmxpbmcuc2libGluZyA9IG5ld1dvcmtJblByb2dyZXNzO1xuICAgIH0gLy8gRGVsZXRlIHRoZSBvbGQgZmliZXIgYW5kIHBsYWNlIHRoZSBuZXcgb25lLlxuICAgIC8vIFNpbmNlIHRoZSBvbGQgZmliZXIgaXMgZGlzY29ubmVjdGVkLCB3ZSBoYXZlIHRvIHNjaGVkdWxlIGl0IG1hbnVhbGx5LlxuXG5cbiAgICB2YXIgbGFzdCA9IHJldHVybkZpYmVyLmxhc3RFZmZlY3Q7XG5cbiAgICBpZiAobGFzdCAhPT0gbnVsbCkge1xuICAgICAgbGFzdC5uZXh0RWZmZWN0ID0gY3VycmVudDtcbiAgICAgIHJldHVybkZpYmVyLmxhc3RFZmZlY3QgPSBjdXJyZW50O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm5GaWJlci5maXJzdEVmZmVjdCA9IHJldHVybkZpYmVyLmxhc3RFZmZlY3QgPSBjdXJyZW50O1xuICAgIH1cblxuICAgIGN1cnJlbnQubmV4dEVmZmVjdCA9IG51bGw7XG4gICAgY3VycmVudC5mbGFncyA9IERlbGV0aW9uO1xuICAgIG5ld1dvcmtJblByb2dyZXNzLmZsYWdzIHw9IFBsYWNlbWVudDsgLy8gUmVzdGFydCB3b3JrIGZyb20gdGhlIG5ldyBmaWJlci5cblxuICAgIHJldHVybiBuZXdXb3JrSW5Qcm9ncmVzcztcbiAgfVxufVxuXG5mdW5jdGlvbiBiZWdpbldvcmsoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKSB7XG4gIHZhciB1cGRhdGVMYW5lcyA9IHdvcmtJblByb2dyZXNzLmxhbmVzO1xuXG4gIHtcbiAgICBpZiAod29ya0luUHJvZ3Jlc3MuX2RlYnVnTmVlZHNSZW1vdW50ICYmIGN1cnJlbnQgIT09IG51bGwpIHtcbiAgICAgIC8vIFRoaXMgd2lsbCByZXN0YXJ0IHRoZSBiZWdpbiBwaGFzZSB3aXRoIGEgbmV3IGZpYmVyLlxuICAgICAgcmV0dXJuIHJlbW91bnRGaWJlcihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgY3JlYXRlRmliZXJGcm9tVHlwZUFuZFByb3BzKHdvcmtJblByb2dyZXNzLnR5cGUsIHdvcmtJblByb2dyZXNzLmtleSwgd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzLCB3b3JrSW5Qcm9ncmVzcy5fZGVidWdPd25lciB8fCBudWxsLCB3b3JrSW5Qcm9ncmVzcy5tb2RlLCB3b3JrSW5Qcm9ncmVzcy5sYW5lcykpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChjdXJyZW50ICE9PSBudWxsKSB7XG4gICAgdmFyIG9sZFByb3BzID0gY3VycmVudC5tZW1vaXplZFByb3BzO1xuICAgIHZhciBuZXdQcm9wcyA9IHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcztcblxuICAgIGlmIChvbGRQcm9wcyAhPT0gbmV3UHJvcHMgfHwgaGFzQ29udGV4dENoYW5nZWQoKSB8fCAoIC8vIEZvcmNlIGEgcmUtcmVuZGVyIGlmIHRoZSBpbXBsZW1lbnRhdGlvbiBjaGFuZ2VkIGR1ZSB0byBob3QgcmVsb2FkOlxuICAgICB3b3JrSW5Qcm9ncmVzcy50eXBlICE9PSBjdXJyZW50LnR5cGUgKSkge1xuICAgICAgLy8gSWYgcHJvcHMgb3IgY29udGV4dCBjaGFuZ2VkLCBtYXJrIHRoZSBmaWJlciBhcyBoYXZpbmcgcGVyZm9ybWVkIHdvcmsuXG4gICAgICAvLyBUaGlzIG1heSBiZSB1bnNldCBpZiB0aGUgcHJvcHMgYXJlIGRldGVybWluZWQgdG8gYmUgZXF1YWwgbGF0ZXIgKG1lbW8pLlxuICAgICAgZGlkUmVjZWl2ZVVwZGF0ZSA9IHRydWU7XG4gICAgfSBlbHNlIGlmICghaW5jbHVkZXNTb21lTGFuZShyZW5kZXJMYW5lcywgdXBkYXRlTGFuZXMpKSB7XG4gICAgICBkaWRSZWNlaXZlVXBkYXRlID0gZmFsc2U7IC8vIFRoaXMgZmliZXIgZG9lcyBub3QgaGF2ZSBhbnkgcGVuZGluZyB3b3JrLiBCYWlsb3V0IHdpdGhvdXQgZW50ZXJpbmdcbiAgICAgIC8vIHRoZSBiZWdpbiBwaGFzZS4gVGhlcmUncyBzdGlsbCBzb21lIGJvb2trZWVwaW5nIHdlIHRoYXQgbmVlZHMgdG8gYmUgZG9uZVxuICAgICAgLy8gaW4gdGhpcyBvcHRpbWl6ZWQgcGF0aCwgbW9zdGx5IHB1c2hpbmcgc3R1ZmYgb250byB0aGUgc3RhY2suXG5cbiAgICAgIHN3aXRjaCAod29ya0luUHJvZ3Jlc3MudGFnKSB7XG4gICAgICAgIGNhc2UgSG9zdFJvb3Q6XG4gICAgICAgICAgcHVzaEhvc3RSb290Q29udGV4dCh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgcmVzZXRIeWRyYXRpb25TdGF0ZSgpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICAgICAgICBwdXNoSG9zdENvbnRleHQod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgQ2xhc3NDb21wb25lbnQ6XG4gICAgICAgICAge1xuICAgICAgICAgICAgdmFyIENvbXBvbmVudCA9IHdvcmtJblByb2dyZXNzLnR5cGU7XG5cbiAgICAgICAgICAgIGlmIChpc0NvbnRleHRQcm92aWRlcihDb21wb25lbnQpKSB7XG4gICAgICAgICAgICAgIHB1c2hDb250ZXh0UHJvdmlkZXIod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgY2FzZSBIb3N0UG9ydGFsOlxuICAgICAgICAgIHB1c2hIb3N0Q29udGFpbmVyKHdvcmtJblByb2dyZXNzLCB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUuY29udGFpbmVySW5mbyk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBDb250ZXh0UHJvdmlkZXI6XG4gICAgICAgICAge1xuICAgICAgICAgICAgdmFyIG5ld1ZhbHVlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcy52YWx1ZTtcbiAgICAgICAgICAgIHB1c2hQcm92aWRlcih3b3JrSW5Qcm9ncmVzcywgbmV3VmFsdWUpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgUHJvZmlsZXI6XG4gICAgICAgICAge1xuICAgICAgICAgICAgLy8gUHJvZmlsZXIgc2hvdWxkIG9ubHkgY2FsbCBvblJlbmRlciB3aGVuIG9uZSBvZiBpdHMgZGVzY2VuZGFudHMgYWN0dWFsbHkgcmVuZGVyZWQuXG4gICAgICAgICAgICB2YXIgaGFzQ2hpbGRXb3JrID0gaW5jbHVkZXNTb21lTGFuZShyZW5kZXJMYW5lcywgd29ya0luUHJvZ3Jlc3MuY2hpbGRMYW5lcyk7XG5cbiAgICAgICAgICAgIGlmIChoYXNDaGlsZFdvcmspIHtcbiAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gVXBkYXRlO1xuICAgICAgICAgICAgfSAvLyBSZXNldCBlZmZlY3QgZHVyYXRpb25zIGZvciB0aGUgbmV4dCBldmVudHVhbCBlZmZlY3QgcGhhc2UuXG4gICAgICAgICAgICAvLyBUaGVzZSBhcmUgcmVzZXQgZHVyaW5nIHJlbmRlciB0byBhbGxvdyB0aGUgRGV2VG9vbHMgY29tbWl0IGhvb2sgYSBjaGFuY2UgdG8gcmVhZCB0aGVtLFxuXG5cbiAgICAgICAgICAgIHZhciBzdGF0ZU5vZGUgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG4gICAgICAgICAgICBzdGF0ZU5vZGUuZWZmZWN0RHVyYXRpb24gPSAwO1xuICAgICAgICAgICAgc3RhdGVOb2RlLnBhc3NpdmVFZmZlY3REdXJhdGlvbiA9IDA7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBTdXNwZW5zZUNvbXBvbmVudDpcbiAgICAgICAgICB7XG4gICAgICAgICAgICB2YXIgc3RhdGUgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO1xuXG4gICAgICAgICAgICBpZiAoc3RhdGUgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgLy8gd2hldGhlciB0byByZXRyeSB0aGUgcHJpbWFyeSBjaGlsZHJlbiwgb3IgdG8gc2tpcCBvdmVyIGl0IGFuZFxuICAgICAgICAgICAgICAvLyBnbyBzdHJhaWdodCB0byB0aGUgZmFsbGJhY2suIENoZWNrIHRoZSBwcmlvcml0eSBvZiB0aGUgcHJpbWFyeVxuICAgICAgICAgICAgICAvLyBjaGlsZCBmcmFnbWVudC5cblxuXG4gICAgICAgICAgICAgIHZhciBwcmltYXJ5Q2hpbGRGcmFnbWVudCA9IHdvcmtJblByb2dyZXNzLmNoaWxkO1xuICAgICAgICAgICAgICB2YXIgcHJpbWFyeUNoaWxkTGFuZXMgPSBwcmltYXJ5Q2hpbGRGcmFnbWVudC5jaGlsZExhbmVzO1xuXG4gICAgICAgICAgICAgIGlmIChpbmNsdWRlc1NvbWVMYW5lKHJlbmRlckxhbmVzLCBwcmltYXJ5Q2hpbGRMYW5lcykpIHtcbiAgICAgICAgICAgICAgICAvLyBUaGUgcHJpbWFyeSBjaGlsZHJlbiBoYXZlIHBlbmRpbmcgd29yay4gVXNlIHRoZSBub3JtYWwgcGF0aFxuICAgICAgICAgICAgICAgIC8vIHRvIGF0dGVtcHQgdG8gcmVuZGVyIHRoZSBwcmltYXJ5IGNoaWxkcmVuIGFnYWluLlxuICAgICAgICAgICAgICAgIHJldHVybiB1cGRhdGVTdXNwZW5zZUNvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIFRoZSBwcmltYXJ5IGNoaWxkIGZyYWdtZW50IGRvZXMgbm90IGhhdmUgcGVuZGluZyB3b3JrIG1hcmtlZFxuICAgICAgICAgICAgICAgIC8vIG9uIGl0XG4gICAgICAgICAgICAgICAgcHVzaFN1c3BlbnNlQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgc2V0RGVmYXVsdFNoYWxsb3dTdXNwZW5zZUNvbnRleHQoc3VzcGVuc2VTdGFja0N1cnNvci5jdXJyZW50KSk7IC8vIFRoZSBwcmltYXJ5IGNoaWxkcmVuIGRvIG5vdCBoYXZlIHBlbmRpbmcgd29yayB3aXRoIHN1ZmZpY2llbnRcbiAgICAgICAgICAgICAgICAvLyBwcmlvcml0eS4gQmFpbG91dC5cblxuICAgICAgICAgICAgICAgIHZhciBjaGlsZCA9IGJhaWxvdXRPbkFscmVhZHlGaW5pc2hlZFdvcmsoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKTtcblxuICAgICAgICAgICAgICAgIGlmIChjaGlsZCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgLy8gVGhlIGZhbGxiYWNrIGNoaWxkcmVuIGhhdmUgcGVuZGluZyB3b3JrLiBTa2lwIG92ZXIgdGhlXG4gICAgICAgICAgICAgICAgICAvLyBwcmltYXJ5IGNoaWxkcmVuIGFuZCB3b3JrIG9uIHRoZSBmYWxsYmFjay5cbiAgICAgICAgICAgICAgICAgIHJldHVybiBjaGlsZC5zaWJsaW5nO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHB1c2hTdXNwZW5zZUNvbnRleHQod29ya0luUHJvZ3Jlc3MsIHNldERlZmF1bHRTaGFsbG93U3VzcGVuc2VDb250ZXh0KHN1c3BlbnNlU3RhY2tDdXJzb3IuY3VycmVudCkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgY2FzZSBTdXNwZW5zZUxpc3RDb21wb25lbnQ6XG4gICAgICAgICAge1xuICAgICAgICAgICAgdmFyIGRpZFN1c3BlbmRCZWZvcmUgPSAoY3VycmVudC5mbGFncyAmIERpZENhcHR1cmUpICE9PSBOb0ZsYWdzO1xuXG4gICAgICAgICAgICB2YXIgX2hhc0NoaWxkV29yayA9IGluY2x1ZGVzU29tZUxhbmUocmVuZGVyTGFuZXMsIHdvcmtJblByb2dyZXNzLmNoaWxkTGFuZXMpO1xuXG4gICAgICAgICAgICBpZiAoZGlkU3VzcGVuZEJlZm9yZSkge1xuICAgICAgICAgICAgICBpZiAoX2hhc0NoaWxkV29yaykge1xuICAgICAgICAgICAgICAgIC8vIElmIHNvbWV0aGluZyB3YXMgaW4gZmFsbGJhY2sgc3RhdGUgbGFzdCB0aW1lLCBhbmQgd2UgaGF2ZSBhbGwgdGhlXG4gICAgICAgICAgICAgICAgLy8gc2FtZSBjaGlsZHJlbiB0aGVuIHdlJ3JlIHN0aWxsIGluIHByb2dyZXNzaXZlIGxvYWRpbmcgc3RhdGUuXG4gICAgICAgICAgICAgICAgLy8gU29tZXRoaW5nIG1pZ2h0IGdldCB1bmJsb2NrZWQgYnkgc3RhdGUgdXBkYXRlcyBvciByZXRyaWVzIGluIHRoZVxuICAgICAgICAgICAgICAgIC8vIHRyZWUgd2hpY2ggd2lsbCBhZmZlY3QgdGhlIHRhaWwuIFNvIHdlIG5lZWQgdG8gdXNlIHRoZSBub3JtYWxcbiAgICAgICAgICAgICAgICAvLyBwYXRoIHRvIGNvbXB1dGUgdGhlIGNvcnJlY3QgdGFpbC5cbiAgICAgICAgICAgICAgICByZXR1cm4gdXBkYXRlU3VzcGVuc2VMaXN0Q29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcyk7XG4gICAgICAgICAgICAgIH0gLy8gSWYgbm9uZSBvZiB0aGUgY2hpbGRyZW4gaGFkIGFueSB3b3JrLCB0aGF0IG1lYW5zIHRoYXQgbm9uZSBvZlxuICAgICAgICAgICAgICAvLyB0aGVtIGdvdCByZXRyaWVkIHNvIHRoZXknbGwgc3RpbGwgYmUgYmxvY2tlZCBpbiB0aGUgc2FtZSB3YXlcbiAgICAgICAgICAgICAgLy8gYXMgYmVmb3JlLiBXZSBjYW4gZmFzdCBiYWlsIG91dC5cblxuXG4gICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IERpZENhcHR1cmU7XG4gICAgICAgICAgICB9IC8vIElmIG5vdGhpbmcgc3VzcGVuZGVkIGJlZm9yZSBhbmQgd2UncmUgcmVuZGVyaW5nIHRoZSBzYW1lIGNoaWxkcmVuLFxuICAgICAgICAgICAgLy8gdGhlbiB0aGUgdGFpbCBkb2Vzbid0IG1hdHRlci4gQW55dGhpbmcgbmV3IHRoYXQgc3VzcGVuZHMgd2lsbCB3b3JrXG4gICAgICAgICAgICAvLyBpbiB0aGUgXCJ0b2dldGhlclwiIG1vZGUsIHNvIHdlIGNhbiBjb250aW51ZSBmcm9tIHRoZSBzdGF0ZSB3ZSBoYWQuXG5cblxuICAgICAgICAgICAgdmFyIHJlbmRlclN0YXRlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTtcblxuICAgICAgICAgICAgaWYgKHJlbmRlclN0YXRlICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgIC8vIFJlc2V0IHRvIHRoZSBcInRvZ2V0aGVyXCIgbW9kZSBpbiBjYXNlIHdlJ3ZlIHN0YXJ0ZWQgYSBkaWZmZXJlbnRcbiAgICAgICAgICAgICAgLy8gdXBkYXRlIGluIHRoZSBwYXN0IGJ1dCBkaWRuJ3QgY29tcGxldGUgaXQuXG4gICAgICAgICAgICAgIHJlbmRlclN0YXRlLnJlbmRlcmluZyA9IG51bGw7XG4gICAgICAgICAgICAgIHJlbmRlclN0YXRlLnRhaWwgPSBudWxsO1xuICAgICAgICAgICAgICByZW5kZXJTdGF0ZS5sYXN0RWZmZWN0ID0gbnVsbDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcHVzaFN1c3BlbnNlQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgc3VzcGVuc2VTdGFja0N1cnNvci5jdXJyZW50KTtcblxuICAgICAgICAgICAgaWYgKF9oYXNDaGlsZFdvcmspIHtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyBJZiBub25lIG9mIHRoZSBjaGlsZHJlbiBoYWQgYW55IHdvcmssIHRoYXQgbWVhbnMgdGhhdCBub25lIG9mXG4gICAgICAgICAgICAgIC8vIHRoZW0gZ290IHJldHJpZWQgc28gdGhleSdsbCBzdGlsbCBiZSBibG9ja2VkIGluIHRoZSBzYW1lIHdheVxuICAgICAgICAgICAgICAvLyBhcyBiZWZvcmUuIFdlIGNhbiBmYXN0IGJhaWwgb3V0LlxuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgY2FzZSBPZmZzY3JlZW5Db21wb25lbnQ6XG4gICAgICAgIGNhc2UgTGVnYWN5SGlkZGVuQ29tcG9uZW50OlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIC8vIE5lZWQgdG8gY2hlY2sgaWYgdGhlIHRyZWUgc3RpbGwgbmVlZHMgdG8gYmUgZGVmZXJyZWQuIFRoaXMgaXNcbiAgICAgICAgICAgIC8vIGFsbW9zdCBpZGVudGljYWwgdG8gdGhlIGxvZ2ljIHVzZWQgaW4gdGhlIG5vcm1hbCB1cGRhdGUgcGF0aCxcbiAgICAgICAgICAgIC8vIHNvIHdlJ2xsIGp1c3QgZW50ZXIgdGhhdC4gVGhlIG9ubHkgZGlmZmVyZW5jZSBpcyB3ZSdsbCBiYWlsIG91dFxuICAgICAgICAgICAgLy8gYXQgdGhlIG5leHQgbGV2ZWwgaW5zdGVhZCBvZiB0aGlzIG9uZSwgYmVjYXVzZSB0aGUgY2hpbGQgcHJvcHNcbiAgICAgICAgICAgIC8vIGhhdmUgbm90IGNoYW5nZWQuIFdoaWNoIGlzIGZpbmUuXG4gICAgICAgICAgICAvLyBUT0RPOiBQcm9iYWJseSBzaG91bGQgcmVmYWN0b3IgYGJlZ2luV29ya2AgdG8gc3BsaXQgdGhlIGJhaWxvdXRcbiAgICAgICAgICAgIC8vIHBhdGggZnJvbSB0aGUgbm9ybWFsIHBhdGguIEknbSB0ZW1wdGVkIHRvIGRvIGEgbGFiZWxlZCBicmVhayBoZXJlXG4gICAgICAgICAgICAvLyBidXQgSSB3b24ndCA6KVxuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MubGFuZXMgPSBOb0xhbmVzO1xuICAgICAgICAgICAgcmV0dXJuIHVwZGF0ZU9mZnNjcmVlbkNvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpO1xuICAgICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGJhaWxvdXRPbkFscmVhZHlGaW5pc2hlZFdvcmsoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKChjdXJyZW50LmZsYWdzICYgRm9yY2VVcGRhdGVGb3JMZWdhY3lTdXNwZW5zZSkgIT09IE5vRmxhZ3MpIHtcbiAgICAgICAgLy8gVGhpcyBpcyBhIHNwZWNpYWwgY2FzZSB0aGF0IG9ubHkgZXhpc3RzIGZvciBsZWdhY3kgbW9kZS5cbiAgICAgICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9wdWxsLzE5MjE2LlxuICAgICAgICBkaWRSZWNlaXZlVXBkYXRlID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEFuIHVwZGF0ZSB3YXMgc2NoZWR1bGVkIG9uIHRoaXMgZmliZXIsIGJ1dCB0aGVyZSBhcmUgbm8gbmV3IHByb3BzXG4gICAgICAgIC8vIG5vciBsZWdhY3kgY29udGV4dC4gU2V0IHRoaXMgdG8gZmFsc2UuIElmIGFuIHVwZGF0ZSBxdWV1ZSBvciBjb250ZXh0XG4gICAgICAgIC8vIGNvbnN1bWVyIHByb2R1Y2VzIGEgY2hhbmdlZCB2YWx1ZSwgaXQgd2lsbCBzZXQgdGhpcyB0byB0cnVlLiBPdGhlcndpc2UsXG4gICAgICAgIC8vIHRoZSBjb21wb25lbnQgd2lsbCBhc3N1bWUgdGhlIGNoaWxkcmVuIGhhdmUgbm90IGNoYW5nZWQgYW5kIGJhaWwgb3V0LlxuICAgICAgICBkaWRSZWNlaXZlVXBkYXRlID0gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGRpZFJlY2VpdmVVcGRhdGUgPSBmYWxzZTtcbiAgfSAvLyBCZWZvcmUgZW50ZXJpbmcgdGhlIGJlZ2luIHBoYXNlLCBjbGVhciBwZW5kaW5nIHVwZGF0ZSBwcmlvcml0eS5cbiAgLy8gVE9ETzogVGhpcyBhc3N1bWVzIHRoYXQgd2UncmUgYWJvdXQgdG8gZXZhbHVhdGUgdGhlIGNvbXBvbmVudCBhbmQgcHJvY2Vzc1xuICAvLyB0aGUgdXBkYXRlIHF1ZXVlLiBIb3dldmVyLCB0aGVyZSdzIGFuIGV4Y2VwdGlvbjogU2ltcGxlTWVtb0NvbXBvbmVudFxuICAvLyBzb21ldGltZXMgYmFpbHMgb3V0IGxhdGVyIGluIHRoZSBiZWdpbiBwaGFzZS4gVGhpcyBpbmRpY2F0ZXMgdGhhdCB3ZSBzaG91bGRcbiAgLy8gbW92ZSB0aGlzIGFzc2lnbm1lbnQgb3V0IG9mIHRoZSBjb21tb24gcGF0aCBhbmQgaW50byBlYWNoIGJyYW5jaC5cblxuXG4gIHdvcmtJblByb2dyZXNzLmxhbmVzID0gTm9MYW5lcztcblxuICBzd2l0Y2ggKHdvcmtJblByb2dyZXNzLnRhZykge1xuICAgIGNhc2UgSW5kZXRlcm1pbmF0ZUNvbXBvbmVudDpcbiAgICAgIHtcbiAgICAgICAgcmV0dXJuIG1vdW50SW5kZXRlcm1pbmF0ZUNvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgd29ya0luUHJvZ3Jlc3MudHlwZSwgcmVuZGVyTGFuZXMpO1xuICAgICAgfVxuXG4gICAgY2FzZSBMYXp5Q29tcG9uZW50OlxuICAgICAge1xuICAgICAgICB2YXIgZWxlbWVudFR5cGUgPSB3b3JrSW5Qcm9ncmVzcy5lbGVtZW50VHlwZTtcbiAgICAgICAgcmV0dXJuIG1vdW50TGF6eUNvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgZWxlbWVudFR5cGUsIHVwZGF0ZUxhbmVzLCByZW5kZXJMYW5lcyk7XG4gICAgICB9XG5cbiAgICBjYXNlIEZ1bmN0aW9uQ29tcG9uZW50OlxuICAgICAge1xuICAgICAgICB2YXIgX0NvbXBvbmVudCA9IHdvcmtJblByb2dyZXNzLnR5cGU7XG4gICAgICAgIHZhciB1bnJlc29sdmVkUHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHM7XG4gICAgICAgIHZhciByZXNvbHZlZFByb3BzID0gd29ya0luUHJvZ3Jlc3MuZWxlbWVudFR5cGUgPT09IF9Db21wb25lbnQgPyB1bnJlc29sdmVkUHJvcHMgOiByZXNvbHZlRGVmYXVsdFByb3BzKF9Db21wb25lbnQsIHVucmVzb2x2ZWRQcm9wcyk7XG4gICAgICAgIHJldHVybiB1cGRhdGVGdW5jdGlvbkNvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgX0NvbXBvbmVudCwgcmVzb2x2ZWRQcm9wcywgcmVuZGVyTGFuZXMpO1xuICAgICAgfVxuXG4gICAgY2FzZSBDbGFzc0NvbXBvbmVudDpcbiAgICAgIHtcbiAgICAgICAgdmFyIF9Db21wb25lbnQyID0gd29ya0luUHJvZ3Jlc3MudHlwZTtcbiAgICAgICAgdmFyIF91bnJlc29sdmVkUHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHM7XG5cbiAgICAgICAgdmFyIF9yZXNvbHZlZFByb3BzID0gd29ya0luUHJvZ3Jlc3MuZWxlbWVudFR5cGUgPT09IF9Db21wb25lbnQyID8gX3VucmVzb2x2ZWRQcm9wcyA6IHJlc29sdmVEZWZhdWx0UHJvcHMoX0NvbXBvbmVudDIsIF91bnJlc29sdmVkUHJvcHMpO1xuXG4gICAgICAgIHJldHVybiB1cGRhdGVDbGFzc0NvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgX0NvbXBvbmVudDIsIF9yZXNvbHZlZFByb3BzLCByZW5kZXJMYW5lcyk7XG4gICAgICB9XG5cbiAgICBjYXNlIEhvc3RSb290OlxuICAgICAgcmV0dXJuIHVwZGF0ZUhvc3RSb290KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcyk7XG5cbiAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICByZXR1cm4gdXBkYXRlSG9zdENvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpO1xuXG4gICAgY2FzZSBIb3N0VGV4dDpcbiAgICAgIHJldHVybiB1cGRhdGVIb3N0VGV4dChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcyk7XG5cbiAgICBjYXNlIFN1c3BlbnNlQ29tcG9uZW50OlxuICAgICAgcmV0dXJuIHVwZGF0ZVN1c3BlbnNlQ29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcyk7XG5cbiAgICBjYXNlIEhvc3RQb3J0YWw6XG4gICAgICByZXR1cm4gdXBkYXRlUG9ydGFsQ29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcyk7XG5cbiAgICBjYXNlIEZvcndhcmRSZWY6XG4gICAgICB7XG4gICAgICAgIHZhciB0eXBlID0gd29ya0luUHJvZ3Jlc3MudHlwZTtcbiAgICAgICAgdmFyIF91bnJlc29sdmVkUHJvcHMyID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzO1xuXG4gICAgICAgIHZhciBfcmVzb2x2ZWRQcm9wczIgPSB3b3JrSW5Qcm9ncmVzcy5lbGVtZW50VHlwZSA9PT0gdHlwZSA/IF91bnJlc29sdmVkUHJvcHMyIDogcmVzb2x2ZURlZmF1bHRQcm9wcyh0eXBlLCBfdW5yZXNvbHZlZFByb3BzMik7XG5cbiAgICAgICAgcmV0dXJuIHVwZGF0ZUZvcndhcmRSZWYoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHR5cGUsIF9yZXNvbHZlZFByb3BzMiwgcmVuZGVyTGFuZXMpO1xuICAgICAgfVxuXG4gICAgY2FzZSBGcmFnbWVudDpcbiAgICAgIHJldHVybiB1cGRhdGVGcmFnbWVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpO1xuXG4gICAgY2FzZSBNb2RlOlxuICAgICAgcmV0dXJuIHVwZGF0ZU1vZGUoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKTtcblxuICAgIGNhc2UgUHJvZmlsZXI6XG4gICAgICByZXR1cm4gdXBkYXRlUHJvZmlsZXIoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKTtcblxuICAgIGNhc2UgQ29udGV4dFByb3ZpZGVyOlxuICAgICAgcmV0dXJuIHVwZGF0ZUNvbnRleHRQcm92aWRlcihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpO1xuXG4gICAgY2FzZSBDb250ZXh0Q29uc3VtZXI6XG4gICAgICByZXR1cm4gdXBkYXRlQ29udGV4dENvbnN1bWVyKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcyk7XG5cbiAgICBjYXNlIE1lbW9Db21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIHZhciBfdHlwZTIgPSB3b3JrSW5Qcm9ncmVzcy50eXBlO1xuICAgICAgICB2YXIgX3VucmVzb2x2ZWRQcm9wczMgPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHM7IC8vIFJlc29sdmUgb3V0ZXIgcHJvcHMgZmlyc3QsIHRoZW4gcmVzb2x2ZSBpbm5lciBwcm9wcy5cblxuICAgICAgICB2YXIgX3Jlc29sdmVkUHJvcHMzID0gcmVzb2x2ZURlZmF1bHRQcm9wcyhfdHlwZTIsIF91bnJlc29sdmVkUHJvcHMzKTtcblxuICAgICAgICB7XG4gICAgICAgICAgaWYgKHdvcmtJblByb2dyZXNzLnR5cGUgIT09IHdvcmtJblByb2dyZXNzLmVsZW1lbnRUeXBlKSB7XG4gICAgICAgICAgICB2YXIgb3V0ZXJQcm9wVHlwZXMgPSBfdHlwZTIucHJvcFR5cGVzO1xuXG4gICAgICAgICAgICBpZiAob3V0ZXJQcm9wVHlwZXMpIHtcbiAgICAgICAgICAgICAgY2hlY2tQcm9wVHlwZXMob3V0ZXJQcm9wVHlwZXMsIF9yZXNvbHZlZFByb3BzMywgLy8gUmVzb2x2ZWQgZm9yIG91dGVyIG9ubHlcbiAgICAgICAgICAgICAgJ3Byb3AnLCBnZXRDb21wb25lbnROYW1lKF90eXBlMikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIF9yZXNvbHZlZFByb3BzMyA9IHJlc29sdmVEZWZhdWx0UHJvcHMoX3R5cGUyLnR5cGUsIF9yZXNvbHZlZFByb3BzMyk7XG4gICAgICAgIHJldHVybiB1cGRhdGVNZW1vQ29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBfdHlwZTIsIF9yZXNvbHZlZFByb3BzMywgdXBkYXRlTGFuZXMsIHJlbmRlckxhbmVzKTtcbiAgICAgIH1cblxuICAgIGNhc2UgU2ltcGxlTWVtb0NvbXBvbmVudDpcbiAgICAgIHtcbiAgICAgICAgcmV0dXJuIHVwZGF0ZVNpbXBsZU1lbW9Db21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHdvcmtJblByb2dyZXNzLnR5cGUsIHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcywgdXBkYXRlTGFuZXMsIHJlbmRlckxhbmVzKTtcbiAgICAgIH1cblxuICAgIGNhc2UgSW5jb21wbGV0ZUNsYXNzQ29tcG9uZW50OlxuICAgICAge1xuICAgICAgICB2YXIgX0NvbXBvbmVudDMgPSB3b3JrSW5Qcm9ncmVzcy50eXBlO1xuICAgICAgICB2YXIgX3VucmVzb2x2ZWRQcm9wczQgPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHM7XG5cbiAgICAgICAgdmFyIF9yZXNvbHZlZFByb3BzNCA9IHdvcmtJblByb2dyZXNzLmVsZW1lbnRUeXBlID09PSBfQ29tcG9uZW50MyA/IF91bnJlc29sdmVkUHJvcHM0IDogcmVzb2x2ZURlZmF1bHRQcm9wcyhfQ29tcG9uZW50MywgX3VucmVzb2x2ZWRQcm9wczQpO1xuXG4gICAgICAgIHJldHVybiBtb3VudEluY29tcGxldGVDbGFzc0NvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgX0NvbXBvbmVudDMsIF9yZXNvbHZlZFByb3BzNCwgcmVuZGVyTGFuZXMpO1xuICAgICAgfVxuXG4gICAgY2FzZSBTdXNwZW5zZUxpc3RDb21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIHJldHVybiB1cGRhdGVTdXNwZW5zZUxpc3RDb21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKTtcbiAgICAgIH1cblxuICAgIGNhc2UgRnVuZGFtZW50YWxDb21wb25lbnQ6XG4gICAgICB7XG5cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICBjYXNlIFNjb3BlQ29tcG9uZW50OlxuICAgICAge1xuXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgY2FzZSBCbG9jazpcbiAgICAgIHtcblxuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgIGNhc2UgT2Zmc2NyZWVuQ29tcG9uZW50OlxuICAgICAge1xuICAgICAgICByZXR1cm4gdXBkYXRlT2Zmc2NyZWVuQ29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcyk7XG4gICAgICB9XG5cbiAgICBjYXNlIExlZ2FjeUhpZGRlbkNvbXBvbmVudDpcbiAgICAgIHtcbiAgICAgICAgcmV0dXJuIHVwZGF0ZUxlZ2FjeUhpZGRlbkNvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpO1xuICAgICAgfVxuICB9XG5cbiAge1xuICAgIHtcbiAgICAgIHRocm93IEVycm9yKCBcIlVua25vd24gdW5pdCBvZiB3b3JrIHRhZyAoXCIgKyB3b3JrSW5Qcm9ncmVzcy50YWcgKyBcIikuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCIgKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gbWFya1VwZGF0ZSh3b3JrSW5Qcm9ncmVzcykge1xuICAvLyBUYWcgdGhlIGZpYmVyIHdpdGggYW4gdXBkYXRlIGVmZmVjdC4gVGhpcyB0dXJucyBhIFBsYWNlbWVudCBpbnRvXG4gIC8vIGEgUGxhY2VtZW50QW5kVXBkYXRlLlxuICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSBVcGRhdGU7XG59XG5cbmZ1bmN0aW9uIG1hcmtSZWYkMSh3b3JrSW5Qcm9ncmVzcykge1xuICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSBSZWY7XG59XG5cbnZhciBhcHBlbmRBbGxDaGlsZHJlbjtcbnZhciB1cGRhdGVIb3N0Q29udGFpbmVyO1xudmFyIHVwZGF0ZUhvc3RDb21wb25lbnQkMTtcbnZhciB1cGRhdGVIb3N0VGV4dCQxO1xuXG57XG4gIC8vIE11dGF0aW9uIG1vZGVcbiAgYXBwZW5kQWxsQ2hpbGRyZW4gPSBmdW5jdGlvbiAocGFyZW50LCB3b3JrSW5Qcm9ncmVzcywgbmVlZHNWaXNpYmlsaXR5VG9nZ2xlLCBpc0hpZGRlbikge1xuICAgIC8vIFdlIG9ubHkgaGF2ZSB0aGUgdG9wIEZpYmVyIHRoYXQgd2FzIGNyZWF0ZWQgYnV0IHdlIG5lZWQgcmVjdXJzZSBkb3duIGl0c1xuICAgIC8vIGNoaWxkcmVuIHRvIGZpbmQgYWxsIHRoZSB0ZXJtaW5hbCBub2Rlcy5cbiAgICB2YXIgbm9kZSA9IHdvcmtJblByb2dyZXNzLmNoaWxkO1xuXG4gICAgd2hpbGUgKG5vZGUgIT09IG51bGwpIHtcbiAgICAgIGlmIChub2RlLnRhZyA9PT0gSG9zdENvbXBvbmVudCB8fCBub2RlLnRhZyA9PT0gSG9zdFRleHQpIHtcbiAgICAgICAgYXBwZW5kSW5pdGlhbENoaWxkKHBhcmVudCwgbm9kZS5zdGF0ZU5vZGUpO1xuICAgICAgfSBlbHNlIGlmIChub2RlLnRhZyA9PT0gSG9zdFBvcnRhbCkgOyBlbHNlIGlmIChub2RlLmNoaWxkICE9PSBudWxsKSB7XG4gICAgICAgIG5vZGUuY2hpbGQucmV0dXJuID0gbm9kZTtcbiAgICAgICAgbm9kZSA9IG5vZGUuY2hpbGQ7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAobm9kZSA9PT0gd29ya0luUHJvZ3Jlc3MpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB3aGlsZSAobm9kZS5zaWJsaW5nID09PSBudWxsKSB7XG4gICAgICAgIGlmIChub2RlLnJldHVybiA9PT0gbnVsbCB8fCBub2RlLnJldHVybiA9PT0gd29ya0luUHJvZ3Jlc3MpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBub2RlID0gbm9kZS5yZXR1cm47XG4gICAgICB9XG5cbiAgICAgIG5vZGUuc2libGluZy5yZXR1cm4gPSBub2RlLnJldHVybjtcbiAgICAgIG5vZGUgPSBub2RlLnNpYmxpbmc7XG4gICAgfVxuICB9O1xuXG4gIHVwZGF0ZUhvc3RDb250YWluZXIgPSBmdW5jdGlvbiAod29ya0luUHJvZ3Jlc3MpIHsvLyBOb29wXG4gIH07XG5cbiAgdXBkYXRlSG9zdENvbXBvbmVudCQxID0gZnVuY3Rpb24gKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCB0eXBlLCBuZXdQcm9wcywgcm9vdENvbnRhaW5lckluc3RhbmNlKSB7XG4gICAgLy8gSWYgd2UgaGF2ZSBhbiBhbHRlcm5hdGUsIHRoYXQgbWVhbnMgdGhpcyBpcyBhbiB1cGRhdGUgYW5kIHdlIG5lZWQgdG9cbiAgICAvLyBzY2hlZHVsZSBhIHNpZGUtZWZmZWN0IHRvIGRvIHRoZSB1cGRhdGVzLlxuICAgIHZhciBvbGRQcm9wcyA9IGN1cnJlbnQubWVtb2l6ZWRQcm9wcztcblxuICAgIGlmIChvbGRQcm9wcyA9PT0gbmV3UHJvcHMpIHtcbiAgICAgIC8vIEluIG11dGF0aW9uIG1vZGUsIHRoaXMgaXMgc3VmZmljaWVudCBmb3IgYSBiYWlsb3V0IGJlY2F1c2VcbiAgICAgIC8vIHdlIHdvbid0IHRvdWNoIHRoaXMgbm9kZSBldmVuIGlmIGNoaWxkcmVuIGNoYW5nZWQuXG4gICAgICByZXR1cm47XG4gICAgfSAvLyBJZiB3ZSBnZXQgdXBkYXRlZCBiZWNhdXNlIG9uZSBvZiBvdXIgY2hpbGRyZW4gdXBkYXRlZCwgd2UgZG9uJ3RcbiAgICAvLyBoYXZlIG5ld1Byb3BzIHNvIHdlJ2xsIGhhdmUgdG8gcmV1c2UgdGhlbS5cbiAgICAvLyBUT0RPOiBTcGxpdCB0aGUgdXBkYXRlIEFQSSBhcyBzZXBhcmF0ZSBmb3IgdGhlIHByb3BzIHZzLiBjaGlsZHJlbi5cbiAgICAvLyBFdmVuIGJldHRlciB3b3VsZCBiZSBpZiBjaGlsZHJlbiB3ZXJlbid0IHNwZWNpYWwgY2FzZWQgYXQgYWxsIHRoby5cblxuXG4gICAgdmFyIGluc3RhbmNlID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuICAgIHZhciBjdXJyZW50SG9zdENvbnRleHQgPSBnZXRIb3N0Q29udGV4dCgpOyAvLyBUT0RPOiBFeHBlcmllbmNpbmcgYW4gZXJyb3Igd2hlcmUgb2xkUHJvcHMgaXMgbnVsbC4gU3VnZ2VzdHMgYSBob3N0XG4gICAgLy8gY29tcG9uZW50IGlzIGhpdHRpbmcgdGhlIHJlc3VtZSBwYXRoLiBGaWd1cmUgb3V0IHdoeS4gUG9zc2libHlcbiAgICAvLyByZWxhdGVkIHRvIGBoaWRkZW5gLlxuXG4gICAgdmFyIHVwZGF0ZVBheWxvYWQgPSBwcmVwYXJlVXBkYXRlKGluc3RhbmNlLCB0eXBlLCBvbGRQcm9wcywgbmV3UHJvcHMsIHJvb3RDb250YWluZXJJbnN0YW5jZSwgY3VycmVudEhvc3RDb250ZXh0KTsgLy8gVE9ETzogVHlwZSB0aGlzIHNwZWNpZmljIHRvIHRoaXMgdHlwZSBvZiBjb21wb25lbnQuXG5cbiAgICB3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZSA9IHVwZGF0ZVBheWxvYWQ7IC8vIElmIHRoZSB1cGRhdGUgcGF5bG9hZCBpbmRpY2F0ZXMgdGhhdCB0aGVyZSBpcyBhIGNoYW5nZSBvciBpZiB0aGVyZVxuICAgIC8vIGlzIGEgbmV3IHJlZiB3ZSBtYXJrIHRoaXMgYXMgYW4gdXBkYXRlLiBBbGwgdGhlIHdvcmsgaXMgZG9uZSBpbiBjb21taXRXb3JrLlxuXG4gICAgaWYgKHVwZGF0ZVBheWxvYWQpIHtcbiAgICAgIG1hcmtVcGRhdGUod29ya0luUHJvZ3Jlc3MpO1xuICAgIH1cbiAgfTtcblxuICB1cGRhdGVIb3N0VGV4dCQxID0gZnVuY3Rpb24gKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBvbGRUZXh0LCBuZXdUZXh0KSB7XG4gICAgLy8gSWYgdGhlIHRleHQgZGlmZmVycywgbWFyayBpdCBhcyBhbiB1cGRhdGUuIEFsbCB0aGUgd29yayBpbiBkb25lIGluIGNvbW1pdFdvcmsuXG4gICAgaWYgKG9sZFRleHQgIT09IG5ld1RleHQpIHtcbiAgICAgIG1hcmtVcGRhdGUod29ya0luUHJvZ3Jlc3MpO1xuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gY3V0T2ZmVGFpbElmTmVlZGVkKHJlbmRlclN0YXRlLCBoYXNSZW5kZXJlZEFUYWlsRmFsbGJhY2spIHtcbiAgaWYgKGdldElzSHlkcmF0aW5nKCkpIHtcbiAgICAvLyBJZiB3ZSdyZSBoeWRyYXRpbmcsIHdlIHNob3VsZCBjb25zdW1lIGFzIG1hbnkgaXRlbXMgYXMgd2UgY2FuXG4gICAgLy8gc28gd2UgZG9uJ3QgbGVhdmUgYW55IGJlaGluZC5cbiAgICByZXR1cm47XG4gIH1cblxuICBzd2l0Y2ggKHJlbmRlclN0YXRlLnRhaWxNb2RlKSB7XG4gICAgY2FzZSAnaGlkZGVuJzpcbiAgICAgIHtcbiAgICAgICAgLy8gQW55IGluc2VydGlvbnMgYXQgdGhlIGVuZCBvZiB0aGUgdGFpbCBsaXN0IGFmdGVyIHRoaXMgcG9pbnRcbiAgICAgICAgLy8gc2hvdWxkIGJlIGludmlzaWJsZS4gSWYgdGhlcmUgYXJlIGFscmVhZHkgbW91bnRlZCBib3VuZGFyaWVzXG4gICAgICAgIC8vIGFueXRoaW5nIGJlZm9yZSB0aGVtIGFyZSBub3QgY29uc2lkZXJlZCBmb3IgY29sbGFwc2luZy5cbiAgICAgICAgLy8gVGhlcmVmb3JlIHdlIG5lZWQgdG8gZ28gdGhyb3VnaCB0aGUgd2hvbGUgdGFpbCB0byBmaW5kIGlmXG4gICAgICAgIC8vIHRoZXJlIGFyZSBhbnkuXG4gICAgICAgIHZhciB0YWlsTm9kZSA9IHJlbmRlclN0YXRlLnRhaWw7XG4gICAgICAgIHZhciBsYXN0VGFpbE5vZGUgPSBudWxsO1xuXG4gICAgICAgIHdoaWxlICh0YWlsTm9kZSAhPT0gbnVsbCkge1xuICAgICAgICAgIGlmICh0YWlsTm9kZS5hbHRlcm5hdGUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGxhc3RUYWlsTm9kZSA9IHRhaWxOb2RlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRhaWxOb2RlID0gdGFpbE5vZGUuc2libGluZztcbiAgICAgICAgfSAvLyBOZXh0IHdlJ3JlIHNpbXBseSBnb2luZyB0byBkZWxldGUgYWxsIGluc2VydGlvbnMgYWZ0ZXIgdGhlXG4gICAgICAgIC8vIGxhc3QgcmVuZGVyZWQgaXRlbS5cblxuXG4gICAgICAgIGlmIChsYXN0VGFpbE5vZGUgPT09IG51bGwpIHtcbiAgICAgICAgICAvLyBBbGwgcmVtYWluaW5nIGl0ZW1zIGluIHRoZSB0YWlsIGFyZSBpbnNlcnRpb25zLlxuICAgICAgICAgIHJlbmRlclN0YXRlLnRhaWwgPSBudWxsO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIERldGFjaCB0aGUgaW5zZXJ0aW9uIGFmdGVyIHRoZSBsYXN0IG5vZGUgdGhhdCB3YXMgYWxyZWFkeVxuICAgICAgICAgIC8vIGluc2VydGVkLlxuICAgICAgICAgIGxhc3RUYWlsTm9kZS5zaWJsaW5nID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgY2FzZSAnY29sbGFwc2VkJzpcbiAgICAgIHtcbiAgICAgICAgLy8gQW55IGluc2VydGlvbnMgYXQgdGhlIGVuZCBvZiB0aGUgdGFpbCBsaXN0IGFmdGVyIHRoaXMgcG9pbnRcbiAgICAgICAgLy8gc2hvdWxkIGJlIGludmlzaWJsZS4gSWYgdGhlcmUgYXJlIGFscmVhZHkgbW91bnRlZCBib3VuZGFyaWVzXG4gICAgICAgIC8vIGFueXRoaW5nIGJlZm9yZSB0aGVtIGFyZSBub3QgY29uc2lkZXJlZCBmb3IgY29sbGFwc2luZy5cbiAgICAgICAgLy8gVGhlcmVmb3JlIHdlIG5lZWQgdG8gZ28gdGhyb3VnaCB0aGUgd2hvbGUgdGFpbCB0byBmaW5kIGlmXG4gICAgICAgIC8vIHRoZXJlIGFyZSBhbnkuXG4gICAgICAgIHZhciBfdGFpbE5vZGUgPSByZW5kZXJTdGF0ZS50YWlsO1xuICAgICAgICB2YXIgX2xhc3RUYWlsTm9kZSA9IG51bGw7XG5cbiAgICAgICAgd2hpbGUgKF90YWlsTm9kZSAhPT0gbnVsbCkge1xuICAgICAgICAgIGlmIChfdGFpbE5vZGUuYWx0ZXJuYXRlICE9PSBudWxsKSB7XG4gICAgICAgICAgICBfbGFzdFRhaWxOb2RlID0gX3RhaWxOb2RlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIF90YWlsTm9kZSA9IF90YWlsTm9kZS5zaWJsaW5nO1xuICAgICAgICB9IC8vIE5leHQgd2UncmUgc2ltcGx5IGdvaW5nIHRvIGRlbGV0ZSBhbGwgaW5zZXJ0aW9ucyBhZnRlciB0aGVcbiAgICAgICAgLy8gbGFzdCByZW5kZXJlZCBpdGVtLlxuXG5cbiAgICAgICAgaWYgKF9sYXN0VGFpbE5vZGUgPT09IG51bGwpIHtcbiAgICAgICAgICAvLyBBbGwgcmVtYWluaW5nIGl0ZW1zIGluIHRoZSB0YWlsIGFyZSBpbnNlcnRpb25zLlxuICAgICAgICAgIGlmICghaGFzUmVuZGVyZWRBVGFpbEZhbGxiYWNrICYmIHJlbmRlclN0YXRlLnRhaWwgIT09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIFdlIHN1c3BlbmRlZCBkdXJpbmcgdGhlIGhlYWQuIFdlIHdhbnQgdG8gc2hvdyBhdCBsZWFzdCBvbmVcbiAgICAgICAgICAgIC8vIHJvdyBhdCB0aGUgdGFpbC4gU28gd2UnbGwga2VlcCBvbiBhbmQgY3V0IG9mZiB0aGUgcmVzdC5cbiAgICAgICAgICAgIHJlbmRlclN0YXRlLnRhaWwuc2libGluZyA9IG51bGw7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlbmRlclN0YXRlLnRhaWwgPSBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBEZXRhY2ggdGhlIGluc2VydGlvbiBhZnRlciB0aGUgbGFzdCBub2RlIHRoYXQgd2FzIGFscmVhZHlcbiAgICAgICAgICAvLyBpbnNlcnRlZC5cbiAgICAgICAgICBfbGFzdFRhaWxOb2RlLnNpYmxpbmcgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY29tcGxldGVXb3JrKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcykge1xuICB2YXIgbmV3UHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHM7XG5cbiAgc3dpdGNoICh3b3JrSW5Qcm9ncmVzcy50YWcpIHtcbiAgICBjYXNlIEluZGV0ZXJtaW5hdGVDb21wb25lbnQ6XG4gICAgY2FzZSBMYXp5Q29tcG9uZW50OlxuICAgIGNhc2UgU2ltcGxlTWVtb0NvbXBvbmVudDpcbiAgICBjYXNlIEZ1bmN0aW9uQ29tcG9uZW50OlxuICAgIGNhc2UgRm9yd2FyZFJlZjpcbiAgICBjYXNlIEZyYWdtZW50OlxuICAgIGNhc2UgTW9kZTpcbiAgICBjYXNlIFByb2ZpbGVyOlxuICAgIGNhc2UgQ29udGV4dENvbnN1bWVyOlxuICAgIGNhc2UgTWVtb0NvbXBvbmVudDpcbiAgICAgIHJldHVybiBudWxsO1xuXG4gICAgY2FzZSBDbGFzc0NvbXBvbmVudDpcbiAgICAgIHtcbiAgICAgICAgdmFyIENvbXBvbmVudCA9IHdvcmtJblByb2dyZXNzLnR5cGU7XG5cbiAgICAgICAgaWYgKGlzQ29udGV4dFByb3ZpZGVyKENvbXBvbmVudCkpIHtcbiAgICAgICAgICBwb3BDb250ZXh0KHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgY2FzZSBIb3N0Um9vdDpcbiAgICAgIHtcbiAgICAgICAgcG9wSG9zdENvbnRhaW5lcih3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgIHBvcFRvcExldmVsQ29udGV4dE9iamVjdCh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgIHJlc2V0V29ya0luUHJvZ3Jlc3NWZXJzaW9ucygpO1xuICAgICAgICB2YXIgZmliZXJSb290ID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuXG4gICAgICAgIGlmIChmaWJlclJvb3QucGVuZGluZ0NvbnRleHQpIHtcbiAgICAgICAgICBmaWJlclJvb3QuY29udGV4dCA9IGZpYmVyUm9vdC5wZW5kaW5nQ29udGV4dDtcbiAgICAgICAgICBmaWJlclJvb3QucGVuZGluZ0NvbnRleHQgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGN1cnJlbnQgPT09IG51bGwgfHwgY3VycmVudC5jaGlsZCA9PT0gbnVsbCkge1xuICAgICAgICAgIC8vIElmIHdlIGh5ZHJhdGVkLCBwb3Agc28gdGhhdCB3ZSBjYW4gZGVsZXRlIGFueSByZW1haW5pbmcgY2hpbGRyZW5cbiAgICAgICAgICAvLyB0aGF0IHdlcmVuJ3QgaHlkcmF0ZWQuXG4gICAgICAgICAgdmFyIHdhc0h5ZHJhdGVkID0gcG9wSHlkcmF0aW9uU3RhdGUod29ya0luUHJvZ3Jlc3MpO1xuXG4gICAgICAgICAgaWYgKHdhc0h5ZHJhdGVkKSB7XG4gICAgICAgICAgICAvLyBJZiB3ZSBoeWRyYXRlZCwgdGhlbiB3ZSdsbCBuZWVkIHRvIHNjaGVkdWxlIGFuIHVwZGF0ZSBmb3JcbiAgICAgICAgICAgIC8vIHRoZSBjb21taXQgc2lkZS1lZmZlY3RzIG9uIHRoZSByb290LlxuICAgICAgICAgICAgbWFya1VwZGF0ZSh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgfSBlbHNlIGlmICghZmliZXJSb290Lmh5ZHJhdGUpIHtcbiAgICAgICAgICAgIC8vIFNjaGVkdWxlIGFuIGVmZmVjdCB0byBjbGVhciB0aGlzIGNvbnRhaW5lciBhdCB0aGUgc3RhcnQgb2YgdGhlIG5leHQgY29tbWl0LlxuICAgICAgICAgICAgLy8gVGhpcyBoYW5kbGVzIHRoZSBjYXNlIG9mIFJlYWN0IHJlbmRlcmluZyBpbnRvIGEgY29udGFpbmVyIHdpdGggcHJldmlvdXMgY2hpbGRyZW4uXG4gICAgICAgICAgICAvLyBJdCdzIGFsc28gc2FmZSB0byBkbyBmb3IgdXBkYXRlcyB0b28sIGJlY2F1c2UgY3VycmVudC5jaGlsZCB3b3VsZCBvbmx5IGJlIG51bGxcbiAgICAgICAgICAgIC8vIGlmIHRoZSBwcmV2aW91cyByZW5kZXIgd2FzIG51bGwgKHNvIHRoZSB0aGUgY29udGFpbmVyIHdvdWxkIGFscmVhZHkgYmUgZW1wdHkpLlxuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gU25hcHNob3Q7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdXBkYXRlSG9zdENvbnRhaW5lcih3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgICAge1xuICAgICAgICBwb3BIb3N0Q29udGV4dCh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgIHZhciByb290Q29udGFpbmVySW5zdGFuY2UgPSBnZXRSb290SG9zdENvbnRhaW5lcigpO1xuICAgICAgICB2YXIgdHlwZSA9IHdvcmtJblByb2dyZXNzLnR5cGU7XG5cbiAgICAgICAgaWYgKGN1cnJlbnQgIT09IG51bGwgJiYgd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlICE9IG51bGwpIHtcbiAgICAgICAgICB1cGRhdGVIb3N0Q29tcG9uZW50JDEoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHR5cGUsIG5ld1Byb3BzLCByb290Q29udGFpbmVySW5zdGFuY2UpO1xuXG4gICAgICAgICAgaWYgKGN1cnJlbnQucmVmICE9PSB3b3JrSW5Qcm9ncmVzcy5yZWYpIHtcbiAgICAgICAgICAgIG1hcmtSZWYkMSh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICghbmV3UHJvcHMpIHtcbiAgICAgICAgICAgIGlmICghKHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSAhPT0gbnVsbCkpIHtcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRocm93IEVycm9yKCBcIldlIG11c3QgaGF2ZSBuZXcgcHJvcHMgZm9yIG5ldyBtb3VudHMuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCIgKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSAvLyBUaGlzIGNhbiBoYXBwZW4gd2hlbiB3ZSBhYm9ydCB3b3JrLlxuXG5cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBjdXJyZW50SG9zdENvbnRleHQgPSBnZXRIb3N0Q29udGV4dCgpOyAvLyBUT0RPOiBNb3ZlIGNyZWF0ZUluc3RhbmNlIHRvIGJlZ2luV29yayBhbmQga2VlcCBpdCBvbiBhIGNvbnRleHRcbiAgICAgICAgICAvLyBcInN0YWNrXCIgYXMgdGhlIHBhcmVudC4gVGhlbiBhcHBlbmQgY2hpbGRyZW4gYXMgd2UgZ28gaW4gYmVnaW5Xb3JrXG4gICAgICAgICAgLy8gb3IgY29tcGxldGVXb3JrIGRlcGVuZGluZyBvbiB3aGV0aGVyIHdlIHdhbnQgdG8gYWRkIHRoZW0gdG9wLT5kb3duIG9yXG4gICAgICAgICAgLy8gYm90dG9tLT51cC4gVG9wLT5kb3duIGlzIGZhc3RlciBpbiBJRTExLlxuXG4gICAgICAgICAgdmFyIF93YXNIeWRyYXRlZCA9IHBvcEh5ZHJhdGlvblN0YXRlKHdvcmtJblByb2dyZXNzKTtcblxuICAgICAgICAgIGlmIChfd2FzSHlkcmF0ZWQpIHtcbiAgICAgICAgICAgIC8vIFRPRE86IE1vdmUgdGhpcyBhbmQgY3JlYXRlSW5zdGFuY2Ugc3RlcCBpbnRvIHRoZSBiZWdpblBoYXNlXG4gICAgICAgICAgICAvLyB0byBjb25zb2xpZGF0ZS5cbiAgICAgICAgICAgIGlmIChwcmVwYXJlVG9IeWRyYXRlSG9zdEluc3RhbmNlKHdvcmtJblByb2dyZXNzLCByb290Q29udGFpbmVySW5zdGFuY2UsIGN1cnJlbnRIb3N0Q29udGV4dCkpIHtcbiAgICAgICAgICAgICAgLy8gSWYgY2hhbmdlcyB0byB0aGUgaHlkcmF0ZWQgbm9kZSBuZWVkIHRvIGJlIGFwcGxpZWQgYXQgdGhlXG4gICAgICAgICAgICAgIC8vIGNvbW1pdC1waGFzZSB3ZSBtYXJrIHRoaXMgYXMgc3VjaC5cbiAgICAgICAgICAgICAgbWFya1VwZGF0ZSh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBpbnN0YW5jZSA9IGNyZWF0ZUluc3RhbmNlKHR5cGUsIG5ld1Byb3BzLCByb290Q29udGFpbmVySW5zdGFuY2UsIGN1cnJlbnRIb3N0Q29udGV4dCwgd29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgICAgYXBwZW5kQWxsQ2hpbGRyZW4oaW5zdGFuY2UsIHdvcmtJblByb2dyZXNzLCBmYWxzZSwgZmFsc2UpO1xuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlID0gaW5zdGFuY2U7IC8vIENlcnRhaW4gcmVuZGVyZXJzIHJlcXVpcmUgY29tbWl0LXRpbWUgZWZmZWN0cyBmb3IgaW5pdGlhbCBtb3VudC5cbiAgICAgICAgICAgIC8vIChlZyBET00gcmVuZGVyZXIgc3VwcG9ydHMgYXV0by1mb2N1cyBmb3IgY2VydGFpbiBlbGVtZW50cykuXG4gICAgICAgICAgICAvLyBNYWtlIHN1cmUgc3VjaCByZW5kZXJlcnMgZ2V0IHNjaGVkdWxlZCBmb3IgbGF0ZXIgd29yay5cblxuICAgICAgICAgICAgaWYgKGZpbmFsaXplSW5pdGlhbENoaWxkcmVuKGluc3RhbmNlLCB0eXBlLCBuZXdQcm9wcywgcm9vdENvbnRhaW5lckluc3RhbmNlKSkge1xuICAgICAgICAgICAgICBtYXJrVXBkYXRlKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAod29ya0luUHJvZ3Jlc3MucmVmICE9PSBudWxsKSB7XG4gICAgICAgICAgICAvLyBJZiB0aGVyZSBpcyBhIHJlZiBvbiBhIGhvc3Qgbm9kZSB3ZSBuZWVkIHRvIHNjaGVkdWxlIGEgY2FsbGJhY2tcbiAgICAgICAgICAgIG1hcmtSZWYkMSh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICBjYXNlIEhvc3RUZXh0OlxuICAgICAge1xuICAgICAgICB2YXIgbmV3VGV4dCA9IG5ld1Byb3BzO1xuXG4gICAgICAgIGlmIChjdXJyZW50ICYmIHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSAhPSBudWxsKSB7XG4gICAgICAgICAgdmFyIG9sZFRleHQgPSBjdXJyZW50Lm1lbW9pemVkUHJvcHM7IC8vIElmIHdlIGhhdmUgYW4gYWx0ZXJuYXRlLCB0aGF0IG1lYW5zIHRoaXMgaXMgYW4gdXBkYXRlIGFuZCB3ZSBuZWVkXG4gICAgICAgICAgLy8gdG8gc2NoZWR1bGUgYSBzaWRlLWVmZmVjdCB0byBkbyB0aGUgdXBkYXRlcy5cblxuICAgICAgICAgIHVwZGF0ZUhvc3RUZXh0JDEoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIG9sZFRleHQsIG5ld1RleHQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICh0eXBlb2YgbmV3VGV4dCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGlmICghKHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSAhPT0gbnVsbCkpIHtcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRocm93IEVycm9yKCBcIldlIG11c3QgaGF2ZSBuZXcgcHJvcHMgZm9yIG5ldyBtb3VudHMuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCIgKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSAvLyBUaGlzIGNhbiBoYXBwZW4gd2hlbiB3ZSBhYm9ydCB3b3JrLlxuXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIF9yb290Q29udGFpbmVySW5zdGFuY2UgPSBnZXRSb290SG9zdENvbnRhaW5lcigpO1xuXG4gICAgICAgICAgdmFyIF9jdXJyZW50SG9zdENvbnRleHQgPSBnZXRIb3N0Q29udGV4dCgpO1xuXG4gICAgICAgICAgdmFyIF93YXNIeWRyYXRlZDIgPSBwb3BIeWRyYXRpb25TdGF0ZSh3b3JrSW5Qcm9ncmVzcyk7XG5cbiAgICAgICAgICBpZiAoX3dhc0h5ZHJhdGVkMikge1xuICAgICAgICAgICAgaWYgKHByZXBhcmVUb0h5ZHJhdGVIb3N0VGV4dEluc3RhbmNlKHdvcmtJblByb2dyZXNzKSkge1xuICAgICAgICAgICAgICBtYXJrVXBkYXRlKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlID0gY3JlYXRlVGV4dEluc3RhbmNlKG5ld1RleHQsIF9yb290Q29udGFpbmVySW5zdGFuY2UsIF9jdXJyZW50SG9zdENvbnRleHQsIHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgIGNhc2UgU3VzcGVuc2VDb21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIHBvcFN1c3BlbnNlQ29udGV4dCh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgIHZhciBuZXh0U3RhdGUgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO1xuXG4gICAgICAgIGlmICgod29ya0luUHJvZ3Jlc3MuZmxhZ3MgJiBEaWRDYXB0dXJlKSAhPT0gTm9GbGFncykge1xuICAgICAgICAgIC8vIFNvbWV0aGluZyBzdXNwZW5kZWQuIFJlLXJlbmRlciB3aXRoIHRoZSBmYWxsYmFjayBjaGlsZHJlbi5cbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5sYW5lcyA9IHJlbmRlckxhbmVzOyAvLyBEbyBub3QgcmVzZXQgdGhlIGVmZmVjdCBsaXN0LlxuXG4gICAgICAgICAgaWYgKCAod29ya0luUHJvZ3Jlc3MubW9kZSAmIFByb2ZpbGVNb2RlKSAhPT0gTm9Nb2RlKSB7XG4gICAgICAgICAgICB0cmFuc2ZlckFjdHVhbER1cmF0aW9uKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gd29ya0luUHJvZ3Jlc3M7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbmV4dERpZFRpbWVvdXQgPSBuZXh0U3RhdGUgIT09IG51bGw7XG4gICAgICAgIHZhciBwcmV2RGlkVGltZW91dCA9IGZhbHNlO1xuXG4gICAgICAgIGlmIChjdXJyZW50ID09PSBudWxsKSB7XG4gICAgICAgICAgaWYgKHdvcmtJblByb2dyZXNzLm1lbW9pemVkUHJvcHMuZmFsbGJhY2sgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcG9wSHlkcmF0aW9uU3RhdGUod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgcHJldlN0YXRlID0gY3VycmVudC5tZW1vaXplZFN0YXRlO1xuICAgICAgICAgIHByZXZEaWRUaW1lb3V0ID0gcHJldlN0YXRlICE9PSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG5leHREaWRUaW1lb3V0ICYmICFwcmV2RGlkVGltZW91dCkge1xuICAgICAgICAgIC8vIElmIHRoaXMgc3VidHJlZWUgaXMgcnVubmluZyBpbiBibG9ja2luZyBtb2RlIHdlIGNhbiBzdXNwZW5kLFxuICAgICAgICAgIC8vIG90aGVyd2lzZSB3ZSB3b24ndCBzdXNwZW5kLlxuICAgICAgICAgIC8vIFRPRE86IFRoaXMgd2lsbCBzdGlsbCBzdXNwZW5kIGEgc3luY2hyb25vdXMgdHJlZSBpZiBhbnl0aGluZ1xuICAgICAgICAgIC8vIGluIHRoZSBjb25jdXJyZW50IHRyZWUgYWxyZWFkeSBzdXNwZW5kZWQgZHVyaW5nIHRoaXMgcmVuZGVyLlxuICAgICAgICAgIC8vIFRoaXMgaXMgYSBrbm93biBidWcuXG4gICAgICAgICAgaWYgKCh3b3JrSW5Qcm9ncmVzcy5tb2RlICYgQmxvY2tpbmdNb2RlKSAhPT0gTm9Nb2RlKSB7XG4gICAgICAgICAgICAvLyBUT0RPOiBNb3ZlIHRoaXMgYmFjayB0byB0aHJvd0V4Y2VwdGlvbiBiZWNhdXNlIHRoaXMgaXMgdG9vIGxhdGVcbiAgICAgICAgICAgIC8vIGlmIHRoaXMgaXMgYSBsYXJnZSB0cmVlIHdoaWNoIGlzIGNvbW1vbiBmb3IgaW5pdGlhbCBsb2Fkcy4gV2VcbiAgICAgICAgICAgIC8vIGRvbid0IGtub3cgaWYgd2Ugc2hvdWxkIHJlc3RhcnQgYSByZW5kZXIgb3Igbm90IHVudGlsIHdlIGdldFxuICAgICAgICAgICAgLy8gdGhpcyBtYXJrZXIsIGFuZCB0aGlzIGlzIHRvbyBsYXRlLlxuICAgICAgICAgICAgLy8gSWYgdGhpcyByZW5kZXIgYWxyZWFkeSBoYWQgYSBwaW5nIG9yIGxvd2VyIHByaSB1cGRhdGVzLFxuICAgICAgICAgICAgLy8gYW5kIHRoaXMgaXMgdGhlIGZpcnN0IHRpbWUgd2Uga25vdyB3ZSdyZSBnb2luZyB0byBzdXNwZW5kIHdlXG4gICAgICAgICAgICAvLyBzaG91bGQgYmUgYWJsZSB0byBpbW1lZGlhdGVseSByZXN0YXJ0IGZyb20gd2l0aGluIHRocm93RXhjZXB0aW9uLlxuICAgICAgICAgICAgdmFyIGhhc0ludmlzaWJsZUNoaWxkQ29udGV4dCA9IGN1cnJlbnQgPT09IG51bGwgJiYgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcy51bnN0YWJsZV9hdm9pZFRoaXNGYWxsYmFjayAhPT0gdHJ1ZTtcblxuICAgICAgICAgICAgaWYgKGhhc0ludmlzaWJsZUNoaWxkQ29udGV4dCB8fCBoYXNTdXNwZW5zZUNvbnRleHQoc3VzcGVuc2VTdGFja0N1cnNvci5jdXJyZW50LCBJbnZpc2libGVQYXJlbnRTdXNwZW5zZUNvbnRleHQpKSB7XG4gICAgICAgICAgICAgIC8vIElmIHRoaXMgd2FzIGluIGFuIGludmlzaWJsZSB0cmVlIG9yIGEgbmV3IHJlbmRlciwgdGhlbiBzaG93aW5nXG4gICAgICAgICAgICAgIC8vIHRoaXMgYm91bmRhcnkgaXMgb2suXG4gICAgICAgICAgICAgIHJlbmRlckRpZFN1c3BlbmQoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vIE90aGVyd2lzZSwgd2UncmUgZ29pbmcgdG8gaGF2ZSB0byBoaWRlIGNvbnRlbnQgc28gd2Ugc2hvdWxkXG4gICAgICAgICAgICAgIC8vIHN1c3BlbmQgZm9yIGxvbmdlciBpZiBwb3NzaWJsZS5cbiAgICAgICAgICAgICAgcmVuZGVyRGlkU3VzcGVuZERlbGF5SWZQb3NzaWJsZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHtcbiAgICAgICAgICAvLyBUT0RPOiBPbmx5IHNjaGVkdWxlIHVwZGF0ZXMgaWYgdGhlc2UgdmFsdWVzIGFyZSBub24gZXF1YWwsIGkuZS4gaXQgY2hhbmdlZC5cbiAgICAgICAgICBpZiAobmV4dERpZFRpbWVvdXQgfHwgcHJldkRpZFRpbWVvdXQpIHtcbiAgICAgICAgICAgIC8vIElmIHRoaXMgYm91bmRhcnkganVzdCB0aW1lZCBvdXQsIHNjaGVkdWxlIGFuIGVmZmVjdCB0byBhdHRhY2ggYVxuICAgICAgICAgICAgLy8gcmV0cnkgbGlzdGVuZXIgdG8gdGhlIHByb21pc2UuIFRoaXMgZmxhZyBpcyBhbHNvIHVzZWQgdG8gaGlkZSB0aGVcbiAgICAgICAgICAgIC8vIHByaW1hcnkgY2hpbGRyZW4uIEluIG11dGF0aW9uIG1vZGUsIHdlIGFsc28gbmVlZCB0aGUgZmxhZyB0b1xuICAgICAgICAgICAgLy8gKnVuaGlkZSogY2hpbGRyZW4gdGhhdCB3ZXJlIHByZXZpb3VzbHkgaGlkZGVuLCBzbyBjaGVjayBpZiB0aGlzXG4gICAgICAgICAgICAvLyBpcyBjdXJyZW50bHkgdGltZWQgb3V0LCB0b28uXG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSBVcGRhdGU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICBjYXNlIEhvc3RQb3J0YWw6XG4gICAgICBwb3BIb3N0Q29udGFpbmVyKHdvcmtJblByb2dyZXNzKTtcbiAgICAgIHVwZGF0ZUhvc3RDb250YWluZXIod29ya0luUHJvZ3Jlc3MpO1xuXG4gICAgICBpZiAoY3VycmVudCA9PT0gbnVsbCkge1xuICAgICAgICBwcmVwYXJlUG9ydGFsTW91bnQod29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlLmNvbnRhaW5lckluZm8pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbnVsbDtcblxuICAgIGNhc2UgQ29udGV4dFByb3ZpZGVyOlxuICAgICAgLy8gUG9wIHByb3ZpZGVyIGZpYmVyXG4gICAgICBwb3BQcm92aWRlcih3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICByZXR1cm4gbnVsbDtcblxuICAgIGNhc2UgSW5jb21wbGV0ZUNsYXNzQ29tcG9uZW50OlxuICAgICAge1xuICAgICAgICAvLyBTYW1lIGFzIGNsYXNzIGNvbXBvbmVudCBjYXNlLiBJIHB1dCBpdCBkb3duIGhlcmUgc28gdGhhdCB0aGUgdGFncyBhcmVcbiAgICAgICAgLy8gc2VxdWVudGlhbCB0byBlbnN1cmUgdGhpcyBzd2l0Y2ggaXMgY29tcGlsZWQgdG8gYSBqdW1wIHRhYmxlLlxuICAgICAgICB2YXIgX0NvbXBvbmVudCA9IHdvcmtJblByb2dyZXNzLnR5cGU7XG5cbiAgICAgICAgaWYgKGlzQ29udGV4dFByb3ZpZGVyKF9Db21wb25lbnQpKSB7XG4gICAgICAgICAgcG9wQ29udGV4dCh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgIGNhc2UgU3VzcGVuc2VMaXN0Q29tcG9uZW50OlxuICAgICAge1xuICAgICAgICBwb3BTdXNwZW5zZUNvbnRleHQod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICB2YXIgcmVuZGVyU3RhdGUgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO1xuXG4gICAgICAgIGlmIChyZW5kZXJTdGF0ZSA9PT0gbnVsbCkge1xuICAgICAgICAgIC8vIFdlJ3JlIHJ1bm5pbmcgaW4gdGhlIGRlZmF1bHQsIFwiaW5kZXBlbmRlbnRcIiBtb2RlLlxuICAgICAgICAgIC8vIFdlIGRvbid0IGRvIGFueXRoaW5nIGluIHRoaXMgbW9kZS5cbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBkaWRTdXNwZW5kQWxyZWFkeSA9ICh3b3JrSW5Qcm9ncmVzcy5mbGFncyAmIERpZENhcHR1cmUpICE9PSBOb0ZsYWdzO1xuICAgICAgICB2YXIgcmVuZGVyZWRUYWlsID0gcmVuZGVyU3RhdGUucmVuZGVyaW5nO1xuXG4gICAgICAgIGlmIChyZW5kZXJlZFRhaWwgPT09IG51bGwpIHtcbiAgICAgICAgICAvLyBXZSBqdXN0IHJlbmRlcmVkIHRoZSBoZWFkLlxuICAgICAgICAgIGlmICghZGlkU3VzcGVuZEFscmVhZHkpIHtcbiAgICAgICAgICAgIC8vIFRoaXMgaXMgdGhlIGZpcnN0IHBhc3MuIFdlIG5lZWQgdG8gZmlndXJlIG91dCBpZiBhbnl0aGluZyBpcyBzdGlsbFxuICAgICAgICAgICAgLy8gc3VzcGVuZGVkIGluIHRoZSByZW5kZXJlZCBzZXQuXG4gICAgICAgICAgICAvLyBJZiBuZXcgY29udGVudCB1bnN1c3BlbmRlZCwgYnV0IHRoZXJlJ3Mgc3RpbGwgc29tZSBjb250ZW50IHRoYXRcbiAgICAgICAgICAgIC8vIGRpZG4ndC4gVGhlbiB3ZSBuZWVkIHRvIGRvIGEgc2Vjb25kIHBhc3MgdGhhdCBmb3JjZXMgZXZlcnl0aGluZ1xuICAgICAgICAgICAgLy8gdG8ga2VlcCBzaG93aW5nIHRoZWlyIGZhbGxiYWNrcy5cbiAgICAgICAgICAgIC8vIFdlIG1pZ2h0IGJlIHN1c3BlbmRlZCBpZiBzb21ldGhpbmcgaW4gdGhpcyByZW5kZXIgcGFzcyBzdXNwZW5kZWQsIG9yXG4gICAgICAgICAgICAvLyBzb21ldGhpbmcgaW4gdGhlIHByZXZpb3VzIGNvbW1pdHRlZCBwYXNzIHN1c3BlbmRlZC4gT3RoZXJ3aXNlLFxuICAgICAgICAgICAgLy8gdGhlcmUncyBubyBjaGFuY2Ugc28gd2UgY2FuIHNraXAgdGhlIGV4cGVuc2l2ZSBjYWxsIHRvXG4gICAgICAgICAgICAvLyBmaW5kRmlyc3RTdXNwZW5kZWQuXG4gICAgICAgICAgICB2YXIgY2Fubm90QmVTdXNwZW5kZWQgPSByZW5kZXJIYXNOb3RTdXNwZW5kZWRZZXQoKSAmJiAoY3VycmVudCA9PT0gbnVsbCB8fCAoY3VycmVudC5mbGFncyAmIERpZENhcHR1cmUpID09PSBOb0ZsYWdzKTtcblxuICAgICAgICAgICAgaWYgKCFjYW5ub3RCZVN1c3BlbmRlZCkge1xuICAgICAgICAgICAgICB2YXIgcm93ID0gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG5cbiAgICAgICAgICAgICAgd2hpbGUgKHJvdyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHZhciBzdXNwZW5kZWQgPSBmaW5kRmlyc3RTdXNwZW5kZWQocm93KTtcblxuICAgICAgICAgICAgICAgIGlmIChzdXNwZW5kZWQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgIGRpZFN1c3BlbmRBbHJlYWR5ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IERpZENhcHR1cmU7XG4gICAgICAgICAgICAgICAgICBjdXRPZmZUYWlsSWZOZWVkZWQocmVuZGVyU3RhdGUsIGZhbHNlKTsgLy8gSWYgdGhpcyBpcyBhIG5ld2x5IHN1c3BlbmRlZCB0cmVlLCBpdCBtaWdodCBub3QgZ2V0IGNvbW1pdHRlZCBhc1xuICAgICAgICAgICAgICAgICAgLy8gcGFydCBvZiB0aGUgc2Vjb25kIHBhc3MuIEluIHRoYXQgY2FzZSBub3RoaW5nIHdpbGwgc3Vic2NyaWJlIHRvXG4gICAgICAgICAgICAgICAgICAvLyBpdHMgdGhlbm5hYmxlcy4gSW5zdGVhZCwgd2UnbGwgdHJhbnNmZXIgaXRzIHRoZW5uYWJsZXMgdG8gdGhlXG4gICAgICAgICAgICAgICAgICAvLyBTdXNwZW5zZUxpc3Qgc28gdGhhdCBpdCBjYW4gcmV0cnkgaWYgdGhleSByZXNvbHZlLlxuICAgICAgICAgICAgICAgICAgLy8gVGhlcmUgbWlnaHQgYmUgbXVsdGlwbGUgb2YgdGhlc2UgaW4gdGhlIGxpc3QgYnV0IHNpbmNlIHdlJ3JlXG4gICAgICAgICAgICAgICAgICAvLyBnb2luZyB0byB3YWl0IGZvciBhbGwgb2YgdGhlbSBhbnl3YXksIGl0IGRvZXNuJ3QgcmVhbGx5IG1hdHRlclxuICAgICAgICAgICAgICAgICAgLy8gd2hpY2ggb25lcyBnZXRzIHRvIHBpbmcuIEluIHRoZW9yeSB3ZSBjb3VsZCBnZXQgY2xldmVyIGFuZCBrZWVwXG4gICAgICAgICAgICAgICAgICAvLyB0cmFjayBvZiBob3cgbWFueSBkZXBlbmRlbmNpZXMgcmVtYWluIGJ1dCBpdCBnZXRzIHRyaWNreSBiZWNhdXNlXG4gICAgICAgICAgICAgICAgICAvLyBpbiB0aGUgbWVhbnRpbWUsIHdlIGNhbiBhZGQvcmVtb3ZlL2NoYW5nZSBpdGVtcyBhbmQgZGVwZW5kZW5jaWVzLlxuICAgICAgICAgICAgICAgICAgLy8gV2UgbWlnaHQgYmFpbCBvdXQgb2YgdGhlIGxvb3AgYmVmb3JlIGZpbmRpbmcgYW55IGJ1dCB0aGF0XG4gICAgICAgICAgICAgICAgICAvLyBkb2Vzbid0IG1hdHRlciBzaW5jZSB0aGF0IG1lYW5zIHRoYXQgdGhlIG90aGVyIGJvdW5kYXJpZXMgdGhhdFxuICAgICAgICAgICAgICAgICAgLy8gd2UgZGlkIGZpbmQgYWxyZWFkeSBoYXMgdGhlaXIgbGlzdGVuZXJzIGF0dGFjaGVkLlxuXG4gICAgICAgICAgICAgICAgICB2YXIgbmV3VGhlbm5hYmxlcyA9IHN1c3BlbmRlZC51cGRhdGVRdWV1ZTtcblxuICAgICAgICAgICAgICAgICAgaWYgKG5ld1RoZW5uYWJsZXMgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWUgPSBuZXdUaGVubmFibGVzO1xuICAgICAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSBVcGRhdGU7XG4gICAgICAgICAgICAgICAgICB9IC8vIFJlcmVuZGVyIHRoZSB3aG9sZSBsaXN0LCBidXQgdGhpcyB0aW1lLCB3ZSdsbCBmb3JjZSBmYWxsYmFja3NcbiAgICAgICAgICAgICAgICAgIC8vIHRvIHN0YXkgaW4gcGxhY2UuXG4gICAgICAgICAgICAgICAgICAvLyBSZXNldCB0aGUgZWZmZWN0IGxpc3QgYmVmb3JlIGRvaW5nIHRoZSBzZWNvbmQgcGFzcyBzaW5jZSB0aGF0J3Mgbm93IGludmFsaWQuXG5cblxuICAgICAgICAgICAgICAgICAgaWYgKHJlbmRlclN0YXRlLmxhc3RFZmZlY3QgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MuZmlyc3RFZmZlY3QgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5sYXN0RWZmZWN0ID0gcmVuZGVyU3RhdGUubGFzdEVmZmVjdDsgLy8gUmVzZXQgdGhlIGNoaWxkIGZpYmVycyB0byB0aGVpciBvcmlnaW5hbCBzdGF0ZS5cblxuICAgICAgICAgICAgICAgICAgcmVzZXRDaGlsZEZpYmVycyh3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpOyAvLyBTZXQgdXAgdGhlIFN1c3BlbnNlIENvbnRleHQgdG8gZm9yY2Ugc3VzcGVuc2UgYW5kIGltbWVkaWF0ZWx5XG4gICAgICAgICAgICAgICAgICAvLyByZXJlbmRlciB0aGUgY2hpbGRyZW4uXG5cbiAgICAgICAgICAgICAgICAgIHB1c2hTdXNwZW5zZUNvbnRleHQod29ya0luUHJvZ3Jlc3MsIHNldFNoYWxsb3dTdXNwZW5zZUNvbnRleHQoc3VzcGVuc2VTdGFja0N1cnNvci5jdXJyZW50LCBGb3JjZVN1c3BlbnNlRmFsbGJhY2spKTtcbiAgICAgICAgICAgICAgICAgIHJldHVybiB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByb3cgPSByb3cuc2libGluZztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAocmVuZGVyU3RhdGUudGFpbCAhPT0gbnVsbCAmJiBub3coKSA+IGdldFJlbmRlclRhcmdldFRpbWUoKSkge1xuICAgICAgICAgICAgICAvLyBXZSBoYXZlIGFscmVhZHkgcGFzc2VkIG91ciBDUFUgZGVhZGxpbmUgYnV0IHdlIHN0aWxsIGhhdmUgcm93c1xuICAgICAgICAgICAgICAvLyBsZWZ0IGluIHRoZSB0YWlsLiBXZSdsbCBqdXN0IGdpdmUgdXAgZnVydGhlciBhdHRlbXB0cyB0byByZW5kZXJcbiAgICAgICAgICAgICAgLy8gdGhlIG1haW4gY29udGVudCBhbmQgb25seSByZW5kZXIgZmFsbGJhY2tzLlxuICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSBEaWRDYXB0dXJlO1xuICAgICAgICAgICAgICBkaWRTdXNwZW5kQWxyZWFkeSA9IHRydWU7XG4gICAgICAgICAgICAgIGN1dE9mZlRhaWxJZk5lZWRlZChyZW5kZXJTdGF0ZSwgZmFsc2UpOyAvLyBTaW5jZSBub3RoaW5nIGFjdHVhbGx5IHN1c3BlbmRlZCwgdGhlcmUgd2lsbCBub3RoaW5nIHRvIHBpbmcgdGhpc1xuICAgICAgICAgICAgICAvLyB0byBnZXQgaXQgc3RhcnRlZCBiYWNrIHVwIHRvIGF0dGVtcHQgdGhlIG5leHQgaXRlbS4gV2hpbGUgaW4gdGVybXNcbiAgICAgICAgICAgICAgLy8gb2YgcHJpb3JpdHkgdGhpcyB3b3JrIGhhcyB0aGUgc2FtZSBwcmlvcml0eSBhcyB0aGlzIGN1cnJlbnQgcmVuZGVyLFxuICAgICAgICAgICAgICAvLyBpdCdzIG5vdCBwYXJ0IG9mIHRoZSBzYW1lIHRyYW5zaXRpb24gb25jZSB0aGUgdHJhbnNpdGlvbiBoYXNcbiAgICAgICAgICAgICAgLy8gY29tbWl0dGVkLiBJZiBpdCdzIHN5bmMsIHdlIHN0aWxsIHdhbnQgdG8geWllbGQgc28gdGhhdCBpdCBjYW4gYmVcbiAgICAgICAgICAgICAgLy8gcGFpbnRlZC4gQ29uY2VwdHVhbGx5LCB0aGlzIGlzIHJlYWxseSB0aGUgc2FtZSBhcyBwaW5naW5nLlxuICAgICAgICAgICAgICAvLyBXZSBjYW4gdXNlIGFueSBSZXRyeUxhbmUgZXZlbiBpZiBpdCdzIHRoZSBvbmUgY3VycmVudGx5IHJlbmRlcmluZ1xuICAgICAgICAgICAgICAvLyBzaW5jZSB3ZSdyZSBsZWF2aW5nIGl0IGJlaGluZCBvbiB0aGlzIG5vZGUuXG5cbiAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MubGFuZXMgPSBTb21lUmV0cnlMYW5lO1xuXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBtYXJrU3Bhd25lZFdvcmsoU29tZVJldHJ5TGFuZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY3V0T2ZmVGFpbElmTmVlZGVkKHJlbmRlclN0YXRlLCBmYWxzZSk7XG4gICAgICAgICAgfSAvLyBOZXh0IHdlJ3JlIGdvaW5nIHRvIHJlbmRlciB0aGUgdGFpbC5cblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIEFwcGVuZCB0aGUgcmVuZGVyZWQgcm93IHRvIHRoZSBjaGlsZCBsaXN0LlxuICAgICAgICAgIGlmICghZGlkU3VzcGVuZEFscmVhZHkpIHtcbiAgICAgICAgICAgIHZhciBfc3VzcGVuZGVkID0gZmluZEZpcnN0U3VzcGVuZGVkKHJlbmRlcmVkVGFpbCk7XG5cbiAgICAgICAgICAgIGlmIChfc3VzcGVuZGVkICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IERpZENhcHR1cmU7XG4gICAgICAgICAgICAgIGRpZFN1c3BlbmRBbHJlYWR5ID0gdHJ1ZTsgLy8gRW5zdXJlIHdlIHRyYW5zZmVyIHRoZSB1cGRhdGUgcXVldWUgdG8gdGhlIHBhcmVudCBzbyB0aGF0IGl0IGRvZXNuJ3RcbiAgICAgICAgICAgICAgLy8gZ2V0IGxvc3QgaWYgdGhpcyByb3cgZW5kcyB1cCBkcm9wcGVkIGR1cmluZyBhIHNlY29uZCBwYXNzLlxuXG4gICAgICAgICAgICAgIHZhciBfbmV3VGhlbm5hYmxlcyA9IF9zdXNwZW5kZWQudXBkYXRlUXVldWU7XG5cbiAgICAgICAgICAgICAgaWYgKF9uZXdUaGVubmFibGVzICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWUgPSBfbmV3VGhlbm5hYmxlcztcbiAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSBVcGRhdGU7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBjdXRPZmZUYWlsSWZOZWVkZWQocmVuZGVyU3RhdGUsIHRydWUpOyAvLyBUaGlzIG1pZ2h0IGhhdmUgYmVlbiBtb2RpZmllZC5cblxuICAgICAgICAgICAgICBpZiAocmVuZGVyU3RhdGUudGFpbCA9PT0gbnVsbCAmJiByZW5kZXJTdGF0ZS50YWlsTW9kZSA9PT0gJ2hpZGRlbicgJiYgIXJlbmRlcmVkVGFpbC5hbHRlcm5hdGUgJiYgIWdldElzSHlkcmF0aW5nKCkgLy8gV2UgZG9uJ3QgY3V0IGl0IGlmIHdlJ3JlIGh5ZHJhdGluZy5cbiAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAvLyBXZSBuZWVkIHRvIGRlbGV0ZSB0aGUgcm93IHdlIGp1c3QgcmVuZGVyZWQuXG4gICAgICAgICAgICAgICAgICAvLyBSZXNldCB0aGUgZWZmZWN0IGxpc3QgdG8gd2hhdCBpdCB3YXMgYmVmb3JlIHdlIHJlbmRlcmVkIHRoaXNcbiAgICAgICAgICAgICAgICAgIC8vIGNoaWxkLiBUaGUgbmVzdGVkIGNoaWxkcmVuIGhhdmUgYWxyZWFkeSBhcHBlbmRlZCB0aGVtc2VsdmVzLlxuICAgICAgICAgICAgICAgICAgdmFyIGxhc3RFZmZlY3QgPSB3b3JrSW5Qcm9ncmVzcy5sYXN0RWZmZWN0ID0gcmVuZGVyU3RhdGUubGFzdEVmZmVjdDsgLy8gUmVtb3ZlIGFueSBlZmZlY3RzIHRoYXQgd2VyZSBhcHBlbmRlZCBhZnRlciB0aGlzIHBvaW50LlxuXG4gICAgICAgICAgICAgICAgICBpZiAobGFzdEVmZmVjdCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBsYXN0RWZmZWN0Lm5leHRFZmZlY3QgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgfSAvLyBXZSdyZSBkb25lLlxuXG5cbiAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIC8vIFRoZSB0aW1lIGl0IHRvb2sgdG8gcmVuZGVyIGxhc3Qgcm93IGlzIGdyZWF0ZXIgdGhhbiB0aGUgcmVtYWluaW5nXG4gICAgICAgICAgICAvLyB0aW1lIHdlIGhhdmUgdG8gcmVuZGVyLiBTbyByZW5kZXJpbmcgb25lIG1vcmUgcm93IHdvdWxkIGxpa2VseVxuICAgICAgICAgICAgLy8gZXhjZWVkIGl0LlxuICAgICAgICAgICAgbm93KCkgKiAyIC0gcmVuZGVyU3RhdGUucmVuZGVyaW5nU3RhcnRUaW1lID4gZ2V0UmVuZGVyVGFyZ2V0VGltZSgpICYmIHJlbmRlckxhbmVzICE9PSBPZmZzY3JlZW5MYW5lKSB7XG4gICAgICAgICAgICAgIC8vIFdlIGhhdmUgbm93IHBhc3NlZCBvdXIgQ1BVIGRlYWRsaW5lIGFuZCB3ZSdsbCBqdXN0IGdpdmUgdXAgZnVydGhlclxuICAgICAgICAgICAgICAvLyBhdHRlbXB0cyB0byByZW5kZXIgdGhlIG1haW4gY29udGVudCBhbmQgb25seSByZW5kZXIgZmFsbGJhY2tzLlxuICAgICAgICAgICAgICAvLyBUaGUgYXNzdW1wdGlvbiBpcyB0aGF0IHRoaXMgaXMgdXN1YWxseSBmYXN0ZXIuXG4gICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IERpZENhcHR1cmU7XG4gICAgICAgICAgICAgIGRpZFN1c3BlbmRBbHJlYWR5ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgY3V0T2ZmVGFpbElmTmVlZGVkKHJlbmRlclN0YXRlLCBmYWxzZSk7IC8vIFNpbmNlIG5vdGhpbmcgYWN0dWFsbHkgc3VzcGVuZGVkLCB0aGVyZSB3aWxsIG5vdGhpbmcgdG8gcGluZyB0aGlzXG4gICAgICAgICAgICAgIC8vIHRvIGdldCBpdCBzdGFydGVkIGJhY2sgdXAgdG8gYXR0ZW1wdCB0aGUgbmV4dCBpdGVtLiBXaGlsZSBpbiB0ZXJtc1xuICAgICAgICAgICAgICAvLyBvZiBwcmlvcml0eSB0aGlzIHdvcmsgaGFzIHRoZSBzYW1lIHByaW9yaXR5IGFzIHRoaXMgY3VycmVudCByZW5kZXIsXG4gICAgICAgICAgICAgIC8vIGl0J3Mgbm90IHBhcnQgb2YgdGhlIHNhbWUgdHJhbnNpdGlvbiBvbmNlIHRoZSB0cmFuc2l0aW9uIGhhc1xuICAgICAgICAgICAgICAvLyBjb21taXR0ZWQuIElmIGl0J3Mgc3luYywgd2Ugc3RpbGwgd2FudCB0byB5aWVsZCBzbyB0aGF0IGl0IGNhbiBiZVxuICAgICAgICAgICAgICAvLyBwYWludGVkLiBDb25jZXB0dWFsbHksIHRoaXMgaXMgcmVhbGx5IHRoZSBzYW1lIGFzIHBpbmdpbmcuXG4gICAgICAgICAgICAgIC8vIFdlIGNhbiB1c2UgYW55IFJldHJ5TGFuZSBldmVuIGlmIGl0J3MgdGhlIG9uZSBjdXJyZW50bHkgcmVuZGVyaW5nXG4gICAgICAgICAgICAgIC8vIHNpbmNlIHdlJ3JlIGxlYXZpbmcgaXQgYmVoaW5kIG9uIHRoaXMgbm9kZS5cblxuICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5sYW5lcyA9IFNvbWVSZXRyeUxhbmU7XG5cbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG1hcmtTcGF3bmVkV29yayhTb21lUmV0cnlMYW5lKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChyZW5kZXJTdGF0ZS5pc0JhY2t3YXJkcykge1xuICAgICAgICAgICAgLy8gVGhlIGVmZmVjdCBsaXN0IG9mIHRoZSBiYWNrd2FyZHMgdGFpbCB3aWxsIGhhdmUgYmVlbiBhZGRlZFxuICAgICAgICAgICAgLy8gdG8gdGhlIGVuZC4gVGhpcyBicmVha3MgdGhlIGd1YXJhbnRlZSB0aGF0IGxpZmUtY3ljbGVzIGZpcmUgaW5cbiAgICAgICAgICAgIC8vIHNpYmxpbmcgb3JkZXIgYnV0IHRoYXQgaXNuJ3QgYSBzdHJvbmcgZ3VhcmFudGVlIHByb21pc2VkIGJ5IFJlYWN0LlxuICAgICAgICAgICAgLy8gRXNwZWNpYWxseSBzaW5jZSB0aGVzZSBtaWdodCBhbHNvIGp1c3QgcG9wIGluIGR1cmluZyBmdXR1cmUgY29tbWl0cy5cbiAgICAgICAgICAgIC8vIEFwcGVuZCB0byB0aGUgYmVnaW5uaW5nIG9mIHRoZSBsaXN0LlxuICAgICAgICAgICAgcmVuZGVyZWRUYWlsLnNpYmxpbmcgPSB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLmNoaWxkID0gcmVuZGVyZWRUYWlsO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgcHJldmlvdXNTaWJsaW5nID0gcmVuZGVyU3RhdGUubGFzdDtcblxuICAgICAgICAgICAgaWYgKHByZXZpb3VzU2libGluZyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICBwcmV2aW91c1NpYmxpbmcuc2libGluZyA9IHJlbmRlcmVkVGFpbDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLmNoaWxkID0gcmVuZGVyZWRUYWlsO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZW5kZXJTdGF0ZS5sYXN0ID0gcmVuZGVyZWRUYWlsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChyZW5kZXJTdGF0ZS50YWlsICE9PSBudWxsKSB7XG4gICAgICAgICAgLy8gV2Ugc3RpbGwgaGF2ZSB0YWlsIHJvd3MgdG8gcmVuZGVyLlxuICAgICAgICAgIC8vIFBvcCBhIHJvdy5cbiAgICAgICAgICB2YXIgbmV4dCA9IHJlbmRlclN0YXRlLnRhaWw7XG4gICAgICAgICAgcmVuZGVyU3RhdGUucmVuZGVyaW5nID0gbmV4dDtcbiAgICAgICAgICByZW5kZXJTdGF0ZS50YWlsID0gbmV4dC5zaWJsaW5nO1xuICAgICAgICAgIHJlbmRlclN0YXRlLmxhc3RFZmZlY3QgPSB3b3JrSW5Qcm9ncmVzcy5sYXN0RWZmZWN0O1xuICAgICAgICAgIHJlbmRlclN0YXRlLnJlbmRlcmluZ1N0YXJ0VGltZSA9IG5vdygpO1xuICAgICAgICAgIG5leHQuc2libGluZyA9IG51bGw7IC8vIFJlc3RvcmUgdGhlIGNvbnRleHQuXG4gICAgICAgICAgLy8gVE9ETzogV2UgY2FuIHByb2JhYmx5IGp1c3QgYXZvaWQgcG9wcGluZyBpdCBpbnN0ZWFkIGFuZCBvbmx5XG4gICAgICAgICAgLy8gc2V0dGluZyBpdCB0aGUgZmlyc3QgdGltZSB3ZSBnbyBmcm9tIG5vdCBzdXNwZW5kZWQgdG8gc3VzcGVuZGVkLlxuXG4gICAgICAgICAgdmFyIHN1c3BlbnNlQ29udGV4dCA9IHN1c3BlbnNlU3RhY2tDdXJzb3IuY3VycmVudDtcblxuICAgICAgICAgIGlmIChkaWRTdXNwZW5kQWxyZWFkeSkge1xuICAgICAgICAgICAgc3VzcGVuc2VDb250ZXh0ID0gc2V0U2hhbGxvd1N1c3BlbnNlQ29udGV4dChzdXNwZW5zZUNvbnRleHQsIEZvcmNlU3VzcGVuc2VGYWxsYmFjayk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN1c3BlbnNlQ29udGV4dCA9IHNldERlZmF1bHRTaGFsbG93U3VzcGVuc2VDb250ZXh0KHN1c3BlbnNlQ29udGV4dCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcHVzaFN1c3BlbnNlQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgc3VzcGVuc2VDb250ZXh0KTsgLy8gRG8gYSBwYXNzIG92ZXIgdGhlIG5leHQgcm93LlxuXG4gICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgIGNhc2UgRnVuZGFtZW50YWxDb21wb25lbnQ6XG4gICAgICB7XG5cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICBjYXNlIFNjb3BlQ29tcG9uZW50OlxuICAgICAge1xuXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgY2FzZSBCbG9jazpcblxuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIE9mZnNjcmVlbkNvbXBvbmVudDpcbiAgICBjYXNlIExlZ2FjeUhpZGRlbkNvbXBvbmVudDpcbiAgICAgIHtcbiAgICAgICAgcG9wUmVuZGVyTGFuZXMod29ya0luUHJvZ3Jlc3MpO1xuXG4gICAgICAgIGlmIChjdXJyZW50ICE9PSBudWxsKSB7XG4gICAgICAgICAgdmFyIF9uZXh0U3RhdGUgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO1xuICAgICAgICAgIHZhciBfcHJldlN0YXRlID0gY3VycmVudC5tZW1vaXplZFN0YXRlO1xuICAgICAgICAgIHZhciBwcmV2SXNIaWRkZW4gPSBfcHJldlN0YXRlICE9PSBudWxsO1xuICAgICAgICAgIHZhciBuZXh0SXNIaWRkZW4gPSBfbmV4dFN0YXRlICE9PSBudWxsO1xuXG4gICAgICAgICAgaWYgKHByZXZJc0hpZGRlbiAhPT0gbmV4dElzSGlkZGVuICYmIG5ld1Byb3BzLm1vZGUgIT09ICd1bnN0YWJsZS1kZWZlci13aXRob3V0LWhpZGluZycpIHtcbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IFVwZGF0ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgfVxuXG4gIHtcbiAgICB7XG4gICAgICB0aHJvdyBFcnJvciggXCJVbmtub3duIHVuaXQgb2Ygd29yayB0YWcgKFwiICsgd29ya0luUHJvZ3Jlc3MudGFnICsgXCIpLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiICk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHVud2luZFdvcmsod29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKSB7XG4gIHN3aXRjaCAod29ya0luUHJvZ3Jlc3MudGFnKSB7XG4gICAgY2FzZSBDbGFzc0NvbXBvbmVudDpcbiAgICAgIHtcbiAgICAgICAgdmFyIENvbXBvbmVudCA9IHdvcmtJblByb2dyZXNzLnR5cGU7XG5cbiAgICAgICAgaWYgKGlzQ29udGV4dFByb3ZpZGVyKENvbXBvbmVudCkpIHtcbiAgICAgICAgICBwb3BDb250ZXh0KHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBmbGFncyA9IHdvcmtJblByb2dyZXNzLmZsYWdzO1xuXG4gICAgICAgIGlmIChmbGFncyAmIFNob3VsZENhcHR1cmUpIHtcbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyA9IGZsYWdzICYgflNob3VsZENhcHR1cmUgfCBEaWRDYXB0dXJlO1xuXG4gICAgICAgICAgaWYgKCAod29ya0luUHJvZ3Jlc3MubW9kZSAmIFByb2ZpbGVNb2RlKSAhPT0gTm9Nb2RlKSB7XG4gICAgICAgICAgICB0cmFuc2ZlckFjdHVhbER1cmF0aW9uKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gd29ya0luUHJvZ3Jlc3M7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgIGNhc2UgSG9zdFJvb3Q6XG4gICAgICB7XG4gICAgICAgIHBvcEhvc3RDb250YWluZXIod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICBwb3BUb3BMZXZlbENvbnRleHRPYmplY3Qod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICByZXNldFdvcmtJblByb2dyZXNzVmVyc2lvbnMoKTtcbiAgICAgICAgdmFyIF9mbGFncyA9IHdvcmtJblByb2dyZXNzLmZsYWdzO1xuXG4gICAgICAgIGlmICghKChfZmxhZ3MgJiBEaWRDYXB0dXJlKSA9PT0gTm9GbGFncykpIHtcbiAgICAgICAgICB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvciggXCJUaGUgcm9vdCBmYWlsZWQgdG8gdW5tb3VudCBhZnRlciBhbiBlcnJvci4gVGhpcyBpcyBsaWtlbHkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgPSBfZmxhZ3MgJiB+U2hvdWxkQ2FwdHVyZSB8IERpZENhcHR1cmU7XG4gICAgICAgIHJldHVybiB3b3JrSW5Qcm9ncmVzcztcbiAgICAgIH1cblxuICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICAgIHtcbiAgICAgICAgLy8gVE9ETzogcG9wSHlkcmF0aW9uU3RhdGVcbiAgICAgICAgcG9wSG9zdENvbnRleHQod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgIGNhc2UgU3VzcGVuc2VDb21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIHBvcFN1c3BlbnNlQ29udGV4dCh3b3JrSW5Qcm9ncmVzcyk7XG5cbiAgICAgICAgdmFyIF9mbGFnczIgPSB3b3JrSW5Qcm9ncmVzcy5mbGFncztcblxuICAgICAgICBpZiAoX2ZsYWdzMiAmIFNob3VsZENhcHR1cmUpIHtcbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyA9IF9mbGFnczIgJiB+U2hvdWxkQ2FwdHVyZSB8IERpZENhcHR1cmU7IC8vIENhcHR1cmVkIGEgc3VzcGVuc2UgZWZmZWN0LiBSZS1yZW5kZXIgdGhlIGJvdW5kYXJ5LlxuXG4gICAgICAgICAgaWYgKCAod29ya0luUHJvZ3Jlc3MubW9kZSAmIFByb2ZpbGVNb2RlKSAhPT0gTm9Nb2RlKSB7XG4gICAgICAgICAgICB0cmFuc2ZlckFjdHVhbER1cmF0aW9uKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gd29ya0luUHJvZ3Jlc3M7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgIGNhc2UgU3VzcGVuc2VMaXN0Q29tcG9uZW50OlxuICAgICAge1xuICAgICAgICBwb3BTdXNwZW5zZUNvbnRleHQod29ya0luUHJvZ3Jlc3MpOyAvLyBTdXNwZW5zZUxpc3QgZG9lc24ndCBhY3R1YWxseSBjYXRjaCBhbnl0aGluZy4gSXQgc2hvdWxkJ3ZlIGJlZW5cbiAgICAgICAgLy8gY2F1Z2h0IGJ5IGEgbmVzdGVkIGJvdW5kYXJ5LiBJZiBub3QsIGl0IHNob3VsZCBidWJibGUgdGhyb3VnaC5cblxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgIGNhc2UgSG9zdFBvcnRhbDpcbiAgICAgIHBvcEhvc3RDb250YWluZXIod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgcmV0dXJuIG51bGw7XG5cbiAgICBjYXNlIENvbnRleHRQcm92aWRlcjpcbiAgICAgIHBvcFByb3ZpZGVyKHdvcmtJblByb2dyZXNzKTtcbiAgICAgIHJldHVybiBudWxsO1xuXG4gICAgY2FzZSBPZmZzY3JlZW5Db21wb25lbnQ6XG4gICAgY2FzZSBMZWdhY3lIaWRkZW5Db21wb25lbnQ6XG4gICAgICBwb3BSZW5kZXJMYW5lcyh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICByZXR1cm4gbnVsbDtcblxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG5mdW5jdGlvbiB1bndpbmRJbnRlcnJ1cHRlZFdvcmsoaW50ZXJydXB0ZWRXb3JrKSB7XG4gIHN3aXRjaCAoaW50ZXJydXB0ZWRXb3JrLnRhZykge1xuICAgIGNhc2UgQ2xhc3NDb21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIHZhciBjaGlsZENvbnRleHRUeXBlcyA9IGludGVycnVwdGVkV29yay50eXBlLmNoaWxkQ29udGV4dFR5cGVzO1xuXG4gICAgICAgIGlmIChjaGlsZENvbnRleHRUeXBlcyAhPT0gbnVsbCAmJiBjaGlsZENvbnRleHRUeXBlcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcG9wQ29udGV4dChpbnRlcnJ1cHRlZFdvcmspO1xuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICBjYXNlIEhvc3RSb290OlxuICAgICAge1xuICAgICAgICBwb3BIb3N0Q29udGFpbmVyKGludGVycnVwdGVkV29yayk7XG4gICAgICAgIHBvcFRvcExldmVsQ29udGV4dE9iamVjdChpbnRlcnJ1cHRlZFdvcmspO1xuICAgICAgICByZXNldFdvcmtJblByb2dyZXNzVmVyc2lvbnMoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIHBvcEhvc3RDb250ZXh0KGludGVycnVwdGVkV29yayk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgY2FzZSBIb3N0UG9ydGFsOlxuICAgICAgcG9wSG9zdENvbnRhaW5lcihpbnRlcnJ1cHRlZFdvcmspO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIFN1c3BlbnNlQ29tcG9uZW50OlxuICAgICAgcG9wU3VzcGVuc2VDb250ZXh0KGludGVycnVwdGVkV29yayk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgU3VzcGVuc2VMaXN0Q29tcG9uZW50OlxuICAgICAgcG9wU3VzcGVuc2VDb250ZXh0KGludGVycnVwdGVkV29yayk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgQ29udGV4dFByb3ZpZGVyOlxuICAgICAgcG9wUHJvdmlkZXIoaW50ZXJydXB0ZWRXb3JrKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBPZmZzY3JlZW5Db21wb25lbnQ6XG4gICAgY2FzZSBMZWdhY3lIaWRkZW5Db21wb25lbnQ6XG4gICAgICBwb3BSZW5kZXJMYW5lcyhpbnRlcnJ1cHRlZFdvcmspO1xuICAgICAgYnJlYWs7XG4gIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlQ2FwdHVyZWRWYWx1ZSh2YWx1ZSwgc291cmNlKSB7XG4gIC8vIElmIHRoZSB2YWx1ZSBpcyBhbiBlcnJvciwgY2FsbCB0aGlzIGZ1bmN0aW9uIGltbWVkaWF0ZWx5IGFmdGVyIGl0IGlzIHRocm93blxuICAvLyBzbyB0aGUgc3RhY2sgaXMgYWNjdXJhdGUuXG4gIHJldHVybiB7XG4gICAgdmFsdWU6IHZhbHVlLFxuICAgIHNvdXJjZTogc291cmNlLFxuICAgIHN0YWNrOiBnZXRTdGFja0J5RmliZXJJbkRldkFuZFByb2Qoc291cmNlKVxuICB9O1xufVxuXG4vLyBUaGlzIG1vZHVsZSBpcyBmb3JrZWQgaW4gZGlmZmVyZW50IGVudmlyb25tZW50cy5cbi8vIEJ5IGRlZmF1bHQsIHJldHVybiBgdHJ1ZWAgdG8gbG9nIGVycm9ycyB0byB0aGUgY29uc29sZS5cbi8vIEZvcmtzIGNhbiByZXR1cm4gYGZhbHNlYCBpZiB0aGlzIGlzbid0IGRlc2lyYWJsZS5cbmZ1bmN0aW9uIHNob3dFcnJvckRpYWxvZyhib3VuZGFyeSwgZXJyb3JJbmZvKSB7XG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBsb2dDYXB0dXJlZEVycm9yKGJvdW5kYXJ5LCBlcnJvckluZm8pIHtcbiAgdHJ5IHtcbiAgICB2YXIgbG9nRXJyb3IgPSBzaG93RXJyb3JEaWFsb2coYm91bmRhcnksIGVycm9ySW5mbyk7IC8vIEFsbG93IGluamVjdGVkIHNob3dFcnJvckRpYWxvZygpIHRvIHByZXZlbnQgZGVmYXVsdCBjb25zb2xlLmVycm9yIGxvZ2dpbmcuXG4gICAgLy8gVGhpcyBlbmFibGVzIHJlbmRlcmVycyBsaWtlIFJlYWN0TmF0aXZlIHRvIGJldHRlciBtYW5hZ2UgcmVkYm94IGJlaGF2aW9yLlxuXG4gICAgaWYgKGxvZ0Vycm9yID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBlcnJvciA9IGVycm9ySW5mby52YWx1ZTtcblxuICAgIGlmICh0cnVlKSB7XG4gICAgICB2YXIgc291cmNlID0gZXJyb3JJbmZvLnNvdXJjZTtcbiAgICAgIHZhciBzdGFjayA9IGVycm9ySW5mby5zdGFjaztcbiAgICAgIHZhciBjb21wb25lbnRTdGFjayA9IHN0YWNrICE9PSBudWxsID8gc3RhY2sgOiAnJzsgLy8gQnJvd3NlcnMgc3VwcG9ydCBzaWxlbmNpbmcgdW5jYXVnaHQgZXJyb3JzIGJ5IGNhbGxpbmdcbiAgICAgIC8vIGBwcmV2ZW50RGVmYXVsdCgpYCBpbiB3aW5kb3cgYGVycm9yYCBoYW5kbGVyLlxuICAgICAgLy8gV2UgcmVjb3JkIHRoaXMgaW5mb3JtYXRpb24gYXMgYW4gZXhwYW5kbyBvbiB0aGUgZXJyb3IuXG5cbiAgICAgIGlmIChlcnJvciAhPSBudWxsICYmIGVycm9yLl9zdXBwcmVzc0xvZ2dpbmcpIHtcbiAgICAgICAgaWYgKGJvdW5kYXJ5LnRhZyA9PT0gQ2xhc3NDb21wb25lbnQpIHtcbiAgICAgICAgICAvLyBUaGUgZXJyb3IgaXMgcmVjb3ZlcmFibGUgYW5kIHdhcyBzaWxlbmNlZC5cbiAgICAgICAgICAvLyBJZ25vcmUgaXQgYW5kIGRvbid0IHByaW50IHRoZSBzdGFjayBhZGRlbmR1bS5cbiAgICAgICAgICAvLyBUaGlzIGlzIGhhbmR5IGZvciB0ZXN0aW5nIGVycm9yIGJvdW5kYXJpZXMgd2l0aG91dCBub2lzZS5cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gLy8gVGhlIGVycm9yIGlzIGZhdGFsLiBTaW5jZSB0aGUgc2lsZW5jaW5nIG1pZ2h0IGhhdmVcbiAgICAgICAgLy8gYmVlbiBhY2NpZGVudGFsLCB3ZSdsbCBzdXJmYWNlIGl0IGFueXdheS5cbiAgICAgICAgLy8gSG93ZXZlciwgdGhlIGJyb3dzZXIgd291bGQgaGF2ZSBzaWxlbmNlZCB0aGUgb3JpZ2luYWwgZXJyb3JcbiAgICAgICAgLy8gc28gd2UnbGwgcHJpbnQgaXQgZmlyc3QsIGFuZCB0aGVuIHByaW50IHRoZSBzdGFjayBhZGRlbmR1bS5cblxuXG4gICAgICAgIGNvbnNvbGVbJ2Vycm9yJ10oZXJyb3IpOyAvLyBEb24ndCB0cmFuc2Zvcm0gdG8gb3VyIHdyYXBwZXJcbiAgICAgICAgLy8gRm9yIGEgbW9yZSBkZXRhaWxlZCBkZXNjcmlwdGlvbiBvZiB0aGlzIGJsb2NrLCBzZWU6XG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9wdWxsLzEzMzg0XG4gICAgICB9XG5cbiAgICAgIHZhciBjb21wb25lbnROYW1lID0gc291cmNlID8gZ2V0Q29tcG9uZW50TmFtZShzb3VyY2UudHlwZSkgOiBudWxsO1xuICAgICAgdmFyIGNvbXBvbmVudE5hbWVNZXNzYWdlID0gY29tcG9uZW50TmFtZSA/IFwiVGhlIGFib3ZlIGVycm9yIG9jY3VycmVkIGluIHRoZSA8XCIgKyBjb21wb25lbnROYW1lICsgXCI+IGNvbXBvbmVudDpcIiA6ICdUaGUgYWJvdmUgZXJyb3Igb2NjdXJyZWQgaW4gb25lIG9mIHlvdXIgUmVhY3QgY29tcG9uZW50czonO1xuICAgICAgdmFyIGVycm9yQm91bmRhcnlNZXNzYWdlO1xuICAgICAgdmFyIGVycm9yQm91bmRhcnlOYW1lID0gZ2V0Q29tcG9uZW50TmFtZShib3VuZGFyeS50eXBlKTtcblxuICAgICAgaWYgKGVycm9yQm91bmRhcnlOYW1lKSB7XG4gICAgICAgIGVycm9yQm91bmRhcnlNZXNzYWdlID0gXCJSZWFjdCB3aWxsIHRyeSB0byByZWNyZWF0ZSB0aGlzIGNvbXBvbmVudCB0cmVlIGZyb20gc2NyYXRjaCBcIiArIChcInVzaW5nIHRoZSBlcnJvciBib3VuZGFyeSB5b3UgcHJvdmlkZWQsIFwiICsgZXJyb3JCb3VuZGFyeU5hbWUgKyBcIi5cIik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlcnJvckJvdW5kYXJ5TWVzc2FnZSA9ICdDb25zaWRlciBhZGRpbmcgYW4gZXJyb3IgYm91bmRhcnkgdG8geW91ciB0cmVlIHRvIGN1c3RvbWl6ZSBlcnJvciBoYW5kbGluZyBiZWhhdmlvci5cXG4nICsgJ1Zpc2l0IGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9lcnJvci1ib3VuZGFyaWVzIHRvIGxlYXJuIG1vcmUgYWJvdXQgZXJyb3IgYm91bmRhcmllcy4nO1xuICAgICAgfVxuXG4gICAgICB2YXIgY29tYmluZWRNZXNzYWdlID0gY29tcG9uZW50TmFtZU1lc3NhZ2UgKyBcIlxcblwiICsgY29tcG9uZW50U3RhY2sgKyBcIlxcblxcblwiICsgKFwiXCIgKyBlcnJvckJvdW5kYXJ5TWVzc2FnZSk7IC8vIEluIGRldmVsb3BtZW50LCB3ZSBwcm92aWRlIG91ciBvd24gbWVzc2FnZSB3aXRoIGp1c3QgdGhlIGNvbXBvbmVudCBzdGFjay5cbiAgICAgIC8vIFdlIGRvbid0IGluY2x1ZGUgdGhlIG9yaWdpbmFsIGVycm9yIG1lc3NhZ2UgYW5kIEpTIHN0YWNrIGJlY2F1c2UgdGhlIGJyb3dzZXJcbiAgICAgIC8vIGhhcyBhbHJlYWR5IHByaW50ZWQgaXQuIEV2ZW4gaWYgdGhlIGFwcGxpY2F0aW9uIHN3YWxsb3dzIHRoZSBlcnJvciwgaXQgaXMgc3RpbGxcbiAgICAgIC8vIGRpc3BsYXllZCBieSB0aGUgYnJvd3NlciB0aGFua3MgdG8gdGhlIERFVi1vbmx5IGZha2UgZXZlbnQgdHJpY2sgaW4gUmVhY3RFcnJvclV0aWxzLlxuXG4gICAgICBjb25zb2xlWydlcnJvciddKGNvbWJpbmVkTWVzc2FnZSk7IC8vIERvbid0IHRyYW5zZm9ybSB0byBvdXIgd3JhcHBlclxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBJbiBwcm9kdWN0aW9uLCB3ZSBwcmludCB0aGUgZXJyb3IgZGlyZWN0bHkuXG4gICAgICAvLyBUaGlzIHdpbGwgaW5jbHVkZSB0aGUgbWVzc2FnZSwgdGhlIEpTIHN0YWNrLCBhbmQgYW55dGhpbmcgdGhlIGJyb3dzZXIgd2FudHMgdG8gc2hvdy5cbiAgICAgIC8vIFdlIHBhc3MgdGhlIGVycm9yIG9iamVjdCBpbnN0ZWFkIG9mIGN1c3RvbSBtZXNzYWdlIHNvIHRoYXQgdGhlIGJyb3dzZXIgZGlzcGxheXMgdGhlIGVycm9yIG5hdGl2ZWx5LlxuICAgICAgY29uc29sZVsnZXJyb3InXShlcnJvcik7IC8vIERvbid0IHRyYW5zZm9ybSB0byBvdXIgd3JhcHBlclxuICAgIH1cbiAgfSBjYXRjaCAoZSkge1xuICAgIC8vIFRoaXMgbWV0aG9kIG11c3Qgbm90IHRocm93LCBvciBSZWFjdCBpbnRlcm5hbCBzdGF0ZSB3aWxsIGdldCBtZXNzZWQgdXAuXG4gICAgLy8gSWYgY29uc29sZS5lcnJvciBpcyBvdmVycmlkZGVuLCBvciBsb2dDYXB0dXJlZEVycm9yKCkgc2hvd3MgYSBkaWFsb2cgdGhhdCB0aHJvd3MsXG4gICAgLy8gd2Ugd2FudCB0byByZXBvcnQgdGhpcyBlcnJvciBvdXRzaWRlIG9mIHRoZSBub3JtYWwgc3RhY2sgYXMgYSBsYXN0IHJlc29ydC5cbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzEzMTg4XG4gICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICB0aHJvdyBlO1xuICAgIH0pO1xuICB9XG59XG5cbnZhciBQb3NzaWJseVdlYWtNYXAkMSA9IHR5cGVvZiBXZWFrTWFwID09PSAnZnVuY3Rpb24nID8gV2Vha01hcCA6IE1hcDtcblxuZnVuY3Rpb24gY3JlYXRlUm9vdEVycm9yVXBkYXRlKGZpYmVyLCBlcnJvckluZm8sIGxhbmUpIHtcbiAgdmFyIHVwZGF0ZSA9IGNyZWF0ZVVwZGF0ZShOb1RpbWVzdGFtcCwgbGFuZSk7IC8vIFVubW91bnQgdGhlIHJvb3QgYnkgcmVuZGVyaW5nIG51bGwuXG5cbiAgdXBkYXRlLnRhZyA9IENhcHR1cmVVcGRhdGU7IC8vIENhdXRpb246IFJlYWN0IERldlRvb2xzIGN1cnJlbnRseSBkZXBlbmRzIG9uIHRoaXMgcHJvcGVydHlcbiAgLy8gYmVpbmcgY2FsbGVkIFwiZWxlbWVudFwiLlxuXG4gIHVwZGF0ZS5wYXlsb2FkID0ge1xuICAgIGVsZW1lbnQ6IG51bGxcbiAgfTtcbiAgdmFyIGVycm9yID0gZXJyb3JJbmZvLnZhbHVlO1xuXG4gIHVwZGF0ZS5jYWxsYmFjayA9IGZ1bmN0aW9uICgpIHtcbiAgICBvblVuY2F1Z2h0RXJyb3IoZXJyb3IpO1xuICAgIGxvZ0NhcHR1cmVkRXJyb3IoZmliZXIsIGVycm9ySW5mbyk7XG4gIH07XG5cbiAgcmV0dXJuIHVwZGF0ZTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlQ2xhc3NFcnJvclVwZGF0ZShmaWJlciwgZXJyb3JJbmZvLCBsYW5lKSB7XG4gIHZhciB1cGRhdGUgPSBjcmVhdGVVcGRhdGUoTm9UaW1lc3RhbXAsIGxhbmUpO1xuICB1cGRhdGUudGFnID0gQ2FwdHVyZVVwZGF0ZTtcbiAgdmFyIGdldERlcml2ZWRTdGF0ZUZyb21FcnJvciA9IGZpYmVyLnR5cGUuZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yO1xuXG4gIGlmICh0eXBlb2YgZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdmFyIGVycm9yJDEgPSBlcnJvckluZm8udmFsdWU7XG5cbiAgICB1cGRhdGUucGF5bG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGxvZ0NhcHR1cmVkRXJyb3IoZmliZXIsIGVycm9ySW5mbyk7XG4gICAgICByZXR1cm4gZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yKGVycm9yJDEpO1xuICAgIH07XG4gIH1cblxuICB2YXIgaW5zdCA9IGZpYmVyLnN0YXRlTm9kZTtcblxuICBpZiAoaW5zdCAhPT0gbnVsbCAmJiB0eXBlb2YgaW5zdC5jb21wb25lbnREaWRDYXRjaCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHVwZGF0ZS5jYWxsYmFjayA9IGZ1bmN0aW9uIGNhbGxiYWNrKCkge1xuICAgICAge1xuICAgICAgICBtYXJrRmFpbGVkRXJyb3JCb3VuZGFyeUZvckhvdFJlbG9hZGluZyhmaWJlcik7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8vIFRvIHByZXNlcnZlIHRoZSBwcmVleGlzdGluZyByZXRyeSBiZWhhdmlvciBvZiBlcnJvciBib3VuZGFyaWVzLFxuICAgICAgICAvLyB3ZSBrZWVwIHRyYWNrIG9mIHdoaWNoIG9uZXMgYWxyZWFkeSBmYWlsZWQgZHVyaW5nIHRoaXMgYmF0Y2guXG4gICAgICAgIC8vIFRoaXMgZ2V0cyByZXNldCBiZWZvcmUgd2UgeWllbGQgYmFjayB0byB0aGUgYnJvd3Nlci5cbiAgICAgICAgLy8gVE9ETzogV2FybiBpbiBzdHJpY3QgbW9kZSBpZiBnZXREZXJpdmVkU3RhdGVGcm9tRXJyb3IgaXNcbiAgICAgICAgLy8gbm90IGRlZmluZWQuXG4gICAgICAgIG1hcmtMZWdhY3lFcnJvckJvdW5kYXJ5QXNGYWlsZWQodGhpcyk7IC8vIE9ubHkgbG9nIGhlcmUgaWYgY29tcG9uZW50RGlkQ2F0Y2ggaXMgdGhlIG9ubHkgZXJyb3IgYm91bmRhcnkgbWV0aG9kIGRlZmluZWRcblxuICAgICAgICBsb2dDYXB0dXJlZEVycm9yKGZpYmVyLCBlcnJvckluZm8pO1xuICAgICAgfVxuXG4gICAgICB2YXIgZXJyb3IkMSA9IGVycm9ySW5mby52YWx1ZTtcbiAgICAgIHZhciBzdGFjayA9IGVycm9ySW5mby5zdGFjaztcbiAgICAgIHRoaXMuY29tcG9uZW50RGlkQ2F0Y2goZXJyb3IkMSwge1xuICAgICAgICBjb21wb25lbnRTdGFjazogc3RhY2sgIT09IG51bGwgPyBzdGFjayA6ICcnXG4gICAgICB9KTtcblxuICAgICAge1xuICAgICAgICBpZiAodHlwZW9mIGdldERlcml2ZWRTdGF0ZUZyb21FcnJvciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIC8vIElmIGNvbXBvbmVudERpZENhdGNoIGlzIHRoZSBvbmx5IGVycm9yIGJvdW5kYXJ5IG1ldGhvZCBkZWZpbmVkLFxuICAgICAgICAgIC8vIHRoZW4gaXQgbmVlZHMgdG8gY2FsbCBzZXRTdGF0ZSB0byByZWNvdmVyIGZyb20gZXJyb3JzLlxuICAgICAgICAgIC8vIElmIG5vIHN0YXRlIHVwZGF0ZSBpcyBzY2hlZHVsZWQgdGhlbiB0aGUgYm91bmRhcnkgd2lsbCBzd2FsbG93IHRoZSBlcnJvci5cbiAgICAgICAgICBpZiAoIWluY2x1ZGVzU29tZUxhbmUoZmliZXIubGFuZXMsIFN5bmNMYW5lKSkge1xuICAgICAgICAgICAgZXJyb3IoJyVzOiBFcnJvciBib3VuZGFyaWVzIHNob3VsZCBpbXBsZW1lbnQgZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yKCkuICcgKyAnSW4gdGhhdCBtZXRob2QsIHJldHVybiBhIHN0YXRlIHVwZGF0ZSB0byBkaXNwbGF5IGFuIGVycm9yIG1lc3NhZ2Ugb3IgZmFsbGJhY2sgVUkuJywgZ2V0Q29tcG9uZW50TmFtZShmaWJlci50eXBlKSB8fCAnVW5rbm93bicpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgdXBkYXRlLmNhbGxiYWNrID0gZnVuY3Rpb24gKCkge1xuICAgICAgbWFya0ZhaWxlZEVycm9yQm91bmRhcnlGb3JIb3RSZWxvYWRpbmcoZmliZXIpO1xuICAgIH07XG4gIH1cblxuICByZXR1cm4gdXBkYXRlO1xufVxuXG5mdW5jdGlvbiBhdHRhY2hQaW5nTGlzdGVuZXIocm9vdCwgd2FrZWFibGUsIGxhbmVzKSB7XG4gIC8vIEF0dGFjaCBhIGxpc3RlbmVyIHRvIHRoZSBwcm9taXNlIHRvIFwicGluZ1wiIHRoZSByb290IGFuZCByZXRyeS4gQnV0IG9ubHkgaWZcbiAgLy8gb25lIGRvZXMgbm90IGFscmVhZHkgZXhpc3QgZm9yIHRoZSBsYW5lcyB3ZSdyZSBjdXJyZW50bHkgcmVuZGVyaW5nICh3aGljaFxuICAvLyBhY3RzIGxpa2UgYSBcInRocmVhZCBJRFwiIGhlcmUpLlxuICB2YXIgcGluZ0NhY2hlID0gcm9vdC5waW5nQ2FjaGU7XG4gIHZhciB0aHJlYWRJRHM7XG5cbiAgaWYgKHBpbmdDYWNoZSA9PT0gbnVsbCkge1xuICAgIHBpbmdDYWNoZSA9IHJvb3QucGluZ0NhY2hlID0gbmV3IFBvc3NpYmx5V2Vha01hcCQxKCk7XG4gICAgdGhyZWFkSURzID0gbmV3IFNldCgpO1xuICAgIHBpbmdDYWNoZS5zZXQod2FrZWFibGUsIHRocmVhZElEcyk7XG4gIH0gZWxzZSB7XG4gICAgdGhyZWFkSURzID0gcGluZ0NhY2hlLmdldCh3YWtlYWJsZSk7XG5cbiAgICBpZiAodGhyZWFkSURzID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocmVhZElEcyA9IG5ldyBTZXQoKTtcbiAgICAgIHBpbmdDYWNoZS5zZXQod2FrZWFibGUsIHRocmVhZElEcyk7XG4gICAgfVxuICB9XG5cbiAgaWYgKCF0aHJlYWRJRHMuaGFzKGxhbmVzKSkge1xuICAgIC8vIE1lbW9pemUgdXNpbmcgdGhlIHRocmVhZCBJRCB0byBwcmV2ZW50IHJlZHVuZGFudCBsaXN0ZW5lcnMuXG4gICAgdGhyZWFkSURzLmFkZChsYW5lcyk7XG4gICAgdmFyIHBpbmcgPSBwaW5nU3VzcGVuZGVkUm9vdC5iaW5kKG51bGwsIHJvb3QsIHdha2VhYmxlLCBsYW5lcyk7XG4gICAgd2FrZWFibGUudGhlbihwaW5nLCBwaW5nKTtcbiAgfVxufVxuXG5mdW5jdGlvbiB0aHJvd0V4Y2VwdGlvbihyb290LCByZXR1cm5GaWJlciwgc291cmNlRmliZXIsIHZhbHVlLCByb290UmVuZGVyTGFuZXMpIHtcbiAgLy8gVGhlIHNvdXJjZSBmaWJlciBkaWQgbm90IGNvbXBsZXRlLlxuICBzb3VyY2VGaWJlci5mbGFncyB8PSBJbmNvbXBsZXRlOyAvLyBJdHMgZWZmZWN0IGxpc3QgaXMgbm8gbG9uZ2VyIHZhbGlkLlxuXG4gIHNvdXJjZUZpYmVyLmZpcnN0RWZmZWN0ID0gc291cmNlRmliZXIubGFzdEVmZmVjdCA9IG51bGw7XG5cbiAgaWYgKHZhbHVlICE9PSBudWxsICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIHZhbHVlLnRoZW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAvLyBUaGlzIGlzIGEgd2FrZWFibGUuXG4gICAgdmFyIHdha2VhYmxlID0gdmFsdWU7XG5cbiAgICBpZiAoKHNvdXJjZUZpYmVyLm1vZGUgJiBCbG9ja2luZ01vZGUpID09PSBOb01vZGUpIHtcbiAgICAgIC8vIFJlc2V0IHRoZSBtZW1vaXplZFN0YXRlIHRvIHdoYXQgaXQgd2FzIGJlZm9yZSB3ZSBhdHRlbXB0ZWRcbiAgICAgIC8vIHRvIHJlbmRlciBpdC5cbiAgICAgIHZhciBjdXJyZW50U291cmNlID0gc291cmNlRmliZXIuYWx0ZXJuYXRlO1xuXG4gICAgICBpZiAoY3VycmVudFNvdXJjZSkge1xuICAgICAgICBzb3VyY2VGaWJlci51cGRhdGVRdWV1ZSA9IGN1cnJlbnRTb3VyY2UudXBkYXRlUXVldWU7XG4gICAgICAgIHNvdXJjZUZpYmVyLm1lbW9pemVkU3RhdGUgPSBjdXJyZW50U291cmNlLm1lbW9pemVkU3RhdGU7XG4gICAgICAgIHNvdXJjZUZpYmVyLmxhbmVzID0gY3VycmVudFNvdXJjZS5sYW5lcztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNvdXJjZUZpYmVyLnVwZGF0ZVF1ZXVlID0gbnVsbDtcbiAgICAgICAgc291cmNlRmliZXIubWVtb2l6ZWRTdGF0ZSA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGhhc0ludmlzaWJsZVBhcmVudEJvdW5kYXJ5ID0gaGFzU3VzcGVuc2VDb250ZXh0KHN1c3BlbnNlU3RhY2tDdXJzb3IuY3VycmVudCwgSW52aXNpYmxlUGFyZW50U3VzcGVuc2VDb250ZXh0KTsgLy8gU2NoZWR1bGUgdGhlIG5lYXJlc3QgU3VzcGVuc2UgdG8gcmUtcmVuZGVyIHRoZSB0aW1lZCBvdXQgdmlldy5cblxuICAgIHZhciBfd29ya0luUHJvZ3Jlc3MgPSByZXR1cm5GaWJlcjtcblxuICAgIGRvIHtcbiAgICAgIGlmIChfd29ya0luUHJvZ3Jlc3MudGFnID09PSBTdXNwZW5zZUNvbXBvbmVudCAmJiBzaG91bGRDYXB0dXJlU3VzcGVuc2UoX3dvcmtJblByb2dyZXNzLCBoYXNJbnZpc2libGVQYXJlbnRCb3VuZGFyeSkpIHtcbiAgICAgICAgLy8gRm91bmQgdGhlIG5lYXJlc3QgYm91bmRhcnkuXG4gICAgICAgIC8vIFN0YXNoIHRoZSBwcm9taXNlIG9uIHRoZSBib3VuZGFyeSBmaWJlci4gSWYgdGhlIGJvdW5kYXJ5IHRpbWVzIG91dCwgd2UnbGxcbiAgICAgICAgLy8gYXR0YWNoIGFub3RoZXIgbGlzdGVuZXIgdG8gZmxpcCB0aGUgYm91bmRhcnkgYmFjayB0byBpdHMgbm9ybWFsIHN0YXRlLlxuICAgICAgICB2YXIgd2FrZWFibGVzID0gX3dvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlO1xuXG4gICAgICAgIGlmICh3YWtlYWJsZXMgPT09IG51bGwpIHtcbiAgICAgICAgICB2YXIgdXBkYXRlUXVldWUgPSBuZXcgU2V0KCk7XG4gICAgICAgICAgdXBkYXRlUXVldWUuYWRkKHdha2VhYmxlKTtcbiAgICAgICAgICBfd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWUgPSB1cGRhdGVRdWV1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB3YWtlYWJsZXMuYWRkKHdha2VhYmxlKTtcbiAgICAgICAgfSAvLyBJZiB0aGUgYm91bmRhcnkgaXMgb3V0c2lkZSBvZiBibG9ja2luZyBtb2RlLCB3ZSBzaG91bGQgKm5vdCpcbiAgICAgICAgLy8gc3VzcGVuZCB0aGUgY29tbWl0LiBQcmV0ZW5kIGFzIGlmIHRoZSBzdXNwZW5kZWQgY29tcG9uZW50IHJlbmRlcmVkXG4gICAgICAgIC8vIG51bGwgYW5kIGtlZXAgcmVuZGVyaW5nLiBJbiB0aGUgY29tbWl0IHBoYXNlLCB3ZSdsbCBzY2hlZHVsZSBhXG4gICAgICAgIC8vIHN1YnNlcXVlbnQgc3luY2hyb25vdXMgdXBkYXRlIHRvIHJlLXJlbmRlciB0aGUgU3VzcGVuc2UuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIE5vdGU6IEl0IGRvZXNuJ3QgbWF0dGVyIHdoZXRoZXIgdGhlIGNvbXBvbmVudCB0aGF0IHN1c3BlbmRlZCB3YXNcbiAgICAgICAgLy8gaW5zaWRlIGEgYmxvY2tpbmcgbW9kZSB0cmVlLiBJZiB0aGUgU3VzcGVuc2UgaXMgb3V0c2lkZSBvZiBpdCwgd2VcbiAgICAgICAgLy8gc2hvdWxkICpub3QqIHN1c3BlbmQgdGhlIGNvbW1pdC5cblxuXG4gICAgICAgIGlmICgoX3dvcmtJblByb2dyZXNzLm1vZGUgJiBCbG9ja2luZ01vZGUpID09PSBOb01vZGUpIHtcbiAgICAgICAgICBfd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gRGlkQ2FwdHVyZTtcbiAgICAgICAgICBzb3VyY2VGaWJlci5mbGFncyB8PSBGb3JjZVVwZGF0ZUZvckxlZ2FjeVN1c3BlbnNlOyAvLyBXZSdyZSBnb2luZyB0byBjb21taXQgdGhpcyBmaWJlciBldmVuIHRob3VnaCBpdCBkaWRuJ3QgY29tcGxldGUuXG4gICAgICAgICAgLy8gQnV0IHdlIHNob3VsZG4ndCBjYWxsIGFueSBsaWZlY3ljbGUgbWV0aG9kcyBvciBjYWxsYmFja3MuIFJlbW92ZVxuICAgICAgICAgIC8vIGFsbCBsaWZlY3ljbGUgZWZmZWN0IHRhZ3MuXG5cbiAgICAgICAgICBzb3VyY2VGaWJlci5mbGFncyAmPSB+KExpZmVjeWNsZUVmZmVjdE1hc2sgfCBJbmNvbXBsZXRlKTtcblxuICAgICAgICAgIGlmIChzb3VyY2VGaWJlci50YWcgPT09IENsYXNzQ29tcG9uZW50KSB7XG4gICAgICAgICAgICB2YXIgY3VycmVudFNvdXJjZUZpYmVyID0gc291cmNlRmliZXIuYWx0ZXJuYXRlO1xuXG4gICAgICAgICAgICBpZiAoY3VycmVudFNvdXJjZUZpYmVyID09PSBudWxsKSB7XG4gICAgICAgICAgICAgIC8vIFRoaXMgaXMgYSBuZXcgbW91bnQuIENoYW5nZSB0aGUgdGFnIHNvIGl0J3Mgbm90IG1pc3Rha2VuIGZvciBhXG4gICAgICAgICAgICAgIC8vIGNvbXBsZXRlZCBjbGFzcyBjb21wb25lbnQuIEZvciBleGFtcGxlLCB3ZSBzaG91bGQgbm90IGNhbGxcbiAgICAgICAgICAgICAgLy8gY29tcG9uZW50V2lsbFVubW91bnQgaWYgaXQgaXMgZGVsZXRlZC5cbiAgICAgICAgICAgICAgc291cmNlRmliZXIudGFnID0gSW5jb21wbGV0ZUNsYXNzQ29tcG9uZW50O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gV2hlbiB3ZSB0cnkgcmVuZGVyaW5nIGFnYWluLCB3ZSBzaG91bGQgbm90IHJldXNlIHRoZSBjdXJyZW50IGZpYmVyLFxuICAgICAgICAgICAgICAvLyBzaW5jZSBpdCdzIGtub3duIHRvIGJlIGluIGFuIGluY29uc2lzdGVudCBzdGF0ZS4gVXNlIGEgZm9yY2UgdXBkYXRlIHRvXG4gICAgICAgICAgICAgIC8vIHByZXZlbnQgYSBiYWlsIG91dC5cbiAgICAgICAgICAgICAgdmFyIHVwZGF0ZSA9IGNyZWF0ZVVwZGF0ZShOb1RpbWVzdGFtcCwgU3luY0xhbmUpO1xuICAgICAgICAgICAgICB1cGRhdGUudGFnID0gRm9yY2VVcGRhdGU7XG4gICAgICAgICAgICAgIGVucXVldWVVcGRhdGUoc291cmNlRmliZXIsIHVwZGF0ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSAvLyBUaGUgc291cmNlIGZpYmVyIGRpZCBub3QgY29tcGxldGUuIE1hcmsgaXQgd2l0aCBTeW5jIHByaW9yaXR5IHRvXG4gICAgICAgICAgLy8gaW5kaWNhdGUgdGhhdCBpdCBzdGlsbCBoYXMgcGVuZGluZyB3b3JrLlxuXG5cbiAgICAgICAgICBzb3VyY2VGaWJlci5sYW5lcyA9IG1lcmdlTGFuZXMoc291cmNlRmliZXIubGFuZXMsIFN5bmNMYW5lKTsgLy8gRXhpdCB3aXRob3V0IHN1c3BlbmRpbmcuXG5cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gLy8gQ29uZmlybWVkIHRoYXQgdGhlIGJvdW5kYXJ5IGlzIGluIGEgY29uY3VycmVudCBtb2RlIHRyZWUuIENvbnRpbnVlXG4gICAgICAgIC8vIHdpdGggdGhlIG5vcm1hbCBzdXNwZW5kIHBhdGguXG4gICAgICAgIC8vXG4gICAgICAgIC8vIEFmdGVyIHRoaXMgd2UnbGwgdXNlIGEgc2V0IG9mIGhldXJpc3RpY3MgdG8gZGV0ZXJtaW5lIHdoZXRoZXIgdGhpc1xuICAgICAgICAvLyByZW5kZXIgcGFzcyB3aWxsIHJ1biB0byBjb21wbGV0aW9uIG9yIHJlc3RhcnQgb3IgXCJzdXNwZW5kXCIgdGhlIGNvbW1pdC5cbiAgICAgICAgLy8gVGhlIGFjdHVhbCBsb2dpYyBmb3IgdGhpcyBpcyBzcHJlYWQgb3V0IGluIGRpZmZlcmVudCBwbGFjZXMuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIFRoaXMgZmlyc3QgcHJpbmNpcGxlIGlzIHRoYXQgaWYgd2UncmUgZ29pbmcgdG8gc3VzcGVuZCB3aGVuIHdlIGNvbXBsZXRlXG4gICAgICAgIC8vIGEgcm9vdCwgdGhlbiB3ZSBzaG91bGQgYWxzbyByZXN0YXJ0IGlmIHdlIGdldCBhbiB1cGRhdGUgb3IgcGluZyB0aGF0XG4gICAgICAgIC8vIG1pZ2h0IHVuc3VzcGVuZCBpdCwgYW5kIHZpY2UgdmVyc2EuIFRoZSBvbmx5IHJlYXNvbiB0byBzdXNwZW5kIGlzXG4gICAgICAgIC8vIGJlY2F1c2UgeW91IHRoaW5rIHlvdSBtaWdodCB3YW50IHRvIHJlc3RhcnQgYmVmb3JlIGNvbW1pdHRpbmcuIEhvd2V2ZXIsXG4gICAgICAgIC8vIGl0IGRvZXNuJ3QgbWFrZSBzZW5zZSB0byByZXN0YXJ0IG9ubHkgd2hpbGUgaW4gdGhlIHBlcmlvZCB3ZSdyZSBzdXNwZW5kZWQuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIFJlc3RhcnRpbmcgdG9vIGFnZ3Jlc3NpdmVseSBpcyBhbHNvIG5vdCBnb29kIGJlY2F1c2UgaXQgc3RhcnZlcyBvdXQgYW55XG4gICAgICAgIC8vIGludGVybWVkaWF0ZSBsb2FkaW5nIHN0YXRlLiBTbyB3ZSB1c2UgaGV1cmlzdGljcyB0byBkZXRlcm1pbmUgd2hlbi5cbiAgICAgICAgLy8gU3VzcGVuc2UgSGV1cmlzdGljc1xuICAgICAgICAvL1xuICAgICAgICAvLyBJZiBub3RoaW5nIHRocmV3IGEgUHJvbWlzZSBvciBhbGwgdGhlIHNhbWUgZmFsbGJhY2tzIGFyZSBhbHJlYWR5IHNob3dpbmcsXG4gICAgICAgIC8vIHRoZW4gZG9uJ3Qgc3VzcGVuZC9yZXN0YXJ0LlxuICAgICAgICAvL1xuICAgICAgICAvLyBJZiB0aGlzIGlzIGFuIGluaXRpYWwgcmVuZGVyIG9mIGEgbmV3IHRyZWUgb2YgU3VzcGVuc2UgYm91bmRhcmllcyBhbmRcbiAgICAgICAgLy8gdGhvc2UgdHJpZ2dlciBhIGZhbGxiYWNrLCB0aGVuIGRvbid0IHN1c3BlbmQvcmVzdGFydC4gV2Ugd2FudCB0byBlbnN1cmVcbiAgICAgICAgLy8gdGhhdCB3ZSBjYW4gc2hvdyB0aGUgaW5pdGlhbCBsb2FkaW5nIHN0YXRlIGFzIHF1aWNrbHkgYXMgcG9zc2libGUuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIElmIHdlIGhpdCBhIFwiRGVsYXllZFwiIGNhc2UsIHN1Y2ggYXMgd2hlbiB3ZSdkIHN3aXRjaCBmcm9tIGNvbnRlbnQgYmFjayBpbnRvXG4gICAgICAgIC8vIGEgZmFsbGJhY2ssIHRoZW4gd2Ugc2hvdWxkIGFsd2F5cyBzdXNwZW5kL3Jlc3RhcnQuIFRyYW5zaXRpb25zIGFwcGx5XG4gICAgICAgIC8vIHRvIHRoaXMgY2FzZS4gSWYgbm9uZSBpcyBkZWZpbmVkLCBKTkQgaXMgdXNlZCBpbnN0ZWFkLlxuICAgICAgICAvL1xuICAgICAgICAvLyBJZiB3ZSdyZSBhbHJlYWR5IHNob3dpbmcgYSBmYWxsYmFjayBhbmQgaXQgZ2V0cyBcInJldHJpZWRcIiwgYWxsb3dpbmcgdXMgdG8gc2hvd1xuICAgICAgICAvLyBhbm90aGVyIGxldmVsLCBidXQgdGhlcmUncyBzdGlsbCBhbiBpbm5lciBib3VuZGFyeSB0aGF0IHdvdWxkIHNob3cgYSBmYWxsYmFjayxcbiAgICAgICAgLy8gdGhlbiB3ZSBzdXNwZW5kL3Jlc3RhcnQgZm9yIDUwMG1zIHNpbmNlIHRoZSBsYXN0IHRpbWUgd2Ugc2hvd2VkIGEgZmFsbGJhY2tcbiAgICAgICAgLy8gYW55d2hlcmUgaW4gdGhlIHRyZWUuIFRoaXMgZWZmZWN0aXZlbHkgdGhyb3R0bGVzIHByb2dyZXNzaXZlIGxvYWRpbmcgaW50byBhXG4gICAgICAgIC8vIGNvbnNpc3RlbnQgdHJhaW4gb2YgY29tbWl0cy4gVGhpcyBhbHNvIGdpdmVzIHVzIGFuIG9wcG9ydHVuaXR5IHRvIHJlc3RhcnQgdG9cbiAgICAgICAgLy8gZ2V0IHRvIHRoZSBjb21wbGV0ZWQgc3RhdGUgc2xpZ2h0bHkgZWFybGllci5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gSWYgdGhlcmUncyBhbWJpZ3VpdHkgZHVlIHRvIGJhdGNoaW5nIGl0J3MgcmVzb2x2ZWQgaW4gcHJlZmVyZW5jZSBvZjpcbiAgICAgICAgLy8gMSkgXCJkZWxheWVkXCIsIDIpIFwiaW5pdGlhbCByZW5kZXJcIiwgMykgXCJyZXRyeVwiLlxuICAgICAgICAvL1xuICAgICAgICAvLyBXZSB3YW50IHRvIGVuc3VyZSB0aGF0IGEgXCJidXN5XCIgc3RhdGUgZG9lc24ndCBnZXQgZm9yY2UgY29tbWl0dGVkLiBXZSB3YW50IHRvXG4gICAgICAgIC8vIGVuc3VyZSB0aGF0IG5ldyBpbml0aWFsIGxvYWRpbmcgc3RhdGVzIGNhbiBjb21taXQgYXMgc29vbiBhcyBwb3NzaWJsZS5cblxuXG4gICAgICAgIGF0dGFjaFBpbmdMaXN0ZW5lcihyb290LCB3YWtlYWJsZSwgcm9vdFJlbmRlckxhbmVzKTtcbiAgICAgICAgX3dvcmtJblByb2dyZXNzLmZsYWdzIHw9IFNob3VsZENhcHR1cmU7XG4gICAgICAgIF93b3JrSW5Qcm9ncmVzcy5sYW5lcyA9IHJvb3RSZW5kZXJMYW5lcztcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSAvLyBUaGlzIGJvdW5kYXJ5IGFscmVhZHkgY2FwdHVyZWQgZHVyaW5nIHRoaXMgcmVuZGVyLiBDb250aW51ZSB0byB0aGUgbmV4dFxuICAgICAgLy8gYm91bmRhcnkuXG5cblxuICAgICAgX3dvcmtJblByb2dyZXNzID0gX3dvcmtJblByb2dyZXNzLnJldHVybjtcbiAgICB9IHdoaWxlIChfd29ya0luUHJvZ3Jlc3MgIT09IG51bGwpOyAvLyBObyBib3VuZGFyeSB3YXMgZm91bmQuIEZhbGx0aHJvdWdoIHRvIGVycm9yIG1vZGUuXG4gICAgLy8gVE9ETzogVXNlIGludmFyaWFudCBzbyB0aGUgbWVzc2FnZSBpcyBzdHJpcHBlZCBpbiBwcm9kP1xuXG5cbiAgICB2YWx1ZSA9IG5ldyBFcnJvcigoZ2V0Q29tcG9uZW50TmFtZShzb3VyY2VGaWJlci50eXBlKSB8fCAnQSBSZWFjdCBjb21wb25lbnQnKSArICcgc3VzcGVuZGVkIHdoaWxlIHJlbmRlcmluZywgYnV0IG5vIGZhbGxiYWNrIFVJIHdhcyBzcGVjaWZpZWQuXFxuJyArICdcXG4nICsgJ0FkZCBhIDxTdXNwZW5zZSBmYWxsYmFjaz0uLi4+IGNvbXBvbmVudCBoaWdoZXIgaW4gdGhlIHRyZWUgdG8gJyArICdwcm92aWRlIGEgbG9hZGluZyBpbmRpY2F0b3Igb3IgcGxhY2Vob2xkZXIgdG8gZGlzcGxheS4nKTtcbiAgfSAvLyBXZSBkaWRuJ3QgZmluZCBhIGJvdW5kYXJ5IHRoYXQgY291bGQgaGFuZGxlIHRoaXMgdHlwZSBvZiBleGNlcHRpb24uIFN0YXJ0XG4gIC8vIG92ZXIgYW5kIHRyYXZlcnNlIHBhcmVudCBwYXRoIGFnYWluLCB0aGlzIHRpbWUgdHJlYXRpbmcgdGhlIGV4Y2VwdGlvblxuICAvLyBhcyBhbiBlcnJvci5cblxuXG4gIHJlbmRlckRpZEVycm9yKCk7XG4gIHZhbHVlID0gY3JlYXRlQ2FwdHVyZWRWYWx1ZSh2YWx1ZSwgc291cmNlRmliZXIpO1xuICB2YXIgd29ya0luUHJvZ3Jlc3MgPSByZXR1cm5GaWJlcjtcblxuICBkbyB7XG4gICAgc3dpdGNoICh3b3JrSW5Qcm9ncmVzcy50YWcpIHtcbiAgICAgIGNhc2UgSG9zdFJvb3Q6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgX2Vycm9ySW5mbyA9IHZhbHVlO1xuICAgICAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IFNob3VsZENhcHR1cmU7XG4gICAgICAgICAgdmFyIGxhbmUgPSBwaWNrQXJiaXRyYXJ5TGFuZShyb290UmVuZGVyTGFuZXMpO1xuICAgICAgICAgIHdvcmtJblByb2dyZXNzLmxhbmVzID0gbWVyZ2VMYW5lcyh3b3JrSW5Qcm9ncmVzcy5sYW5lcywgbGFuZSk7XG5cbiAgICAgICAgICB2YXIgX3VwZGF0ZSA9IGNyZWF0ZVJvb3RFcnJvclVwZGF0ZSh3b3JrSW5Qcm9ncmVzcywgX2Vycm9ySW5mbywgbGFuZSk7XG5cbiAgICAgICAgICBlbnF1ZXVlQ2FwdHVyZWRVcGRhdGUod29ya0luUHJvZ3Jlc3MsIF91cGRhdGUpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIENsYXNzQ29tcG9uZW50OlxuICAgICAgICAvLyBDYXB0dXJlIGFuZCByZXRyeVxuICAgICAgICB2YXIgZXJyb3JJbmZvID0gdmFsdWU7XG4gICAgICAgIHZhciBjdG9yID0gd29ya0luUHJvZ3Jlc3MudHlwZTtcbiAgICAgICAgdmFyIGluc3RhbmNlID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuXG4gICAgICAgIGlmICgod29ya0luUHJvZ3Jlc3MuZmxhZ3MgJiBEaWRDYXB0dXJlKSA9PT0gTm9GbGFncyAmJiAodHlwZW9mIGN0b3IuZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yID09PSAnZnVuY3Rpb24nIHx8IGluc3RhbmNlICE9PSBudWxsICYmIHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnREaWRDYXRjaCA9PT0gJ2Z1bmN0aW9uJyAmJiAhaXNBbHJlYWR5RmFpbGVkTGVnYWN5RXJyb3JCb3VuZGFyeShpbnN0YW5jZSkpKSB7XG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gU2hvdWxkQ2FwdHVyZTtcblxuICAgICAgICAgIHZhciBfbGFuZSA9IHBpY2tBcmJpdHJhcnlMYW5lKHJvb3RSZW5kZXJMYW5lcyk7XG5cbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5sYW5lcyA9IG1lcmdlTGFuZXMod29ya0luUHJvZ3Jlc3MubGFuZXMsIF9sYW5lKTsgLy8gU2NoZWR1bGUgdGhlIGVycm9yIGJvdW5kYXJ5IHRvIHJlLXJlbmRlciB1c2luZyB1cGRhdGVkIHN0YXRlXG5cbiAgICAgICAgICB2YXIgX3VwZGF0ZTIgPSBjcmVhdGVDbGFzc0Vycm9yVXBkYXRlKHdvcmtJblByb2dyZXNzLCBlcnJvckluZm8sIF9sYW5lKTtcblxuICAgICAgICAgIGVucXVldWVDYXB0dXJlZFVwZGF0ZSh3b3JrSW5Qcm9ncmVzcywgX3VwZGF0ZTIpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIHdvcmtJblByb2dyZXNzID0gd29ya0luUHJvZ3Jlc3MucmV0dXJuO1xuICB9IHdoaWxlICh3b3JrSW5Qcm9ncmVzcyAhPT0gbnVsbCk7XG59XG5cbnZhciBkaWRXYXJuQWJvdXRVbmRlZmluZWRTbmFwc2hvdEJlZm9yZVVwZGF0ZSA9IG51bGw7XG5cbntcbiAgZGlkV2FybkFib3V0VW5kZWZpbmVkU25hcHNob3RCZWZvcmVVcGRhdGUgPSBuZXcgU2V0KCk7XG59XG5cbnZhciBQb3NzaWJseVdlYWtTZXQgPSB0eXBlb2YgV2Vha1NldCA9PT0gJ2Z1bmN0aW9uJyA/IFdlYWtTZXQgOiBTZXQ7XG5cbnZhciBjYWxsQ29tcG9uZW50V2lsbFVubW91bnRXaXRoVGltZXIgPSBmdW5jdGlvbiAoY3VycmVudCwgaW5zdGFuY2UpIHtcbiAgaW5zdGFuY2UucHJvcHMgPSBjdXJyZW50Lm1lbW9pemVkUHJvcHM7XG4gIGluc3RhbmNlLnN0YXRlID0gY3VycmVudC5tZW1vaXplZFN0YXRlO1xuXG4gIHtcbiAgICBpbnN0YW5jZS5jb21wb25lbnRXaWxsVW5tb3VudCgpO1xuICB9XG59OyAvLyBDYXB0dXJlIGVycm9ycyBzbyB0aGV5IGRvbid0IGludGVycnVwdCB1bm1vdW50aW5nLlxuXG5cbmZ1bmN0aW9uIHNhZmVseUNhbGxDb21wb25lbnRXaWxsVW5tb3VudChjdXJyZW50LCBpbnN0YW5jZSkge1xuICB7XG4gICAgaW52b2tlR3VhcmRlZENhbGxiYWNrKG51bGwsIGNhbGxDb21wb25lbnRXaWxsVW5tb3VudFdpdGhUaW1lciwgbnVsbCwgY3VycmVudCwgaW5zdGFuY2UpO1xuXG4gICAgaWYgKGhhc0NhdWdodEVycm9yKCkpIHtcbiAgICAgIHZhciB1bm1vdW50RXJyb3IgPSBjbGVhckNhdWdodEVycm9yKCk7XG4gICAgICBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihjdXJyZW50LCB1bm1vdW50RXJyb3IpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBzYWZlbHlEZXRhY2hSZWYoY3VycmVudCkge1xuICB2YXIgcmVmID0gY3VycmVudC5yZWY7XG5cbiAgaWYgKHJlZiAhPT0gbnVsbCkge1xuICAgIGlmICh0eXBlb2YgcmVmID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB7XG4gICAgICAgIGludm9rZUd1YXJkZWRDYWxsYmFjayhudWxsLCByZWYsIG51bGwsIG51bGwpO1xuXG4gICAgICAgIGlmIChoYXNDYXVnaHRFcnJvcigpKSB7XG4gICAgICAgICAgdmFyIHJlZkVycm9yID0gY2xlYXJDYXVnaHRFcnJvcigpO1xuICAgICAgICAgIGNhcHR1cmVDb21taXRQaGFzZUVycm9yKGN1cnJlbnQsIHJlZkVycm9yKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZWYuY3VycmVudCA9IG51bGw7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHNhZmVseUNhbGxEZXN0cm95KGN1cnJlbnQsIGRlc3Ryb3kpIHtcbiAge1xuICAgIGludm9rZUd1YXJkZWRDYWxsYmFjayhudWxsLCBkZXN0cm95LCBudWxsKTtcblxuICAgIGlmIChoYXNDYXVnaHRFcnJvcigpKSB7XG4gICAgICB2YXIgZXJyb3IgPSBjbGVhckNhdWdodEVycm9yKCk7XG4gICAgICBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihjdXJyZW50LCBlcnJvcik7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNvbW1pdEJlZm9yZU11dGF0aW9uTGlmZUN5Y2xlcyhjdXJyZW50LCBmaW5pc2hlZFdvcmspIHtcbiAgc3dpdGNoIChmaW5pc2hlZFdvcmsudGFnKSB7XG4gICAgY2FzZSBGdW5jdGlvbkNvbXBvbmVudDpcbiAgICBjYXNlIEZvcndhcmRSZWY6XG4gICAgY2FzZSBTaW1wbGVNZW1vQ29tcG9uZW50OlxuICAgIGNhc2UgQmxvY2s6XG4gICAgICB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgIGNhc2UgQ2xhc3NDb21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIGlmIChmaW5pc2hlZFdvcmsuZmxhZ3MgJiBTbmFwc2hvdCkge1xuICAgICAgICAgIGlmIChjdXJyZW50ICE9PSBudWxsKSB7XG4gICAgICAgICAgICB2YXIgcHJldlByb3BzID0gY3VycmVudC5tZW1vaXplZFByb3BzO1xuICAgICAgICAgICAgdmFyIHByZXZTdGF0ZSA9IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZTtcbiAgICAgICAgICAgIHZhciBpbnN0YW5jZSA9IGZpbmlzaGVkV29yay5zdGF0ZU5vZGU7IC8vIFdlIGNvdWxkIHVwZGF0ZSBpbnN0YW5jZSBwcm9wcyBhbmQgc3RhdGUgaGVyZSxcbiAgICAgICAgICAgIC8vIGJ1dCBpbnN0ZWFkIHdlIHJlbHkgb24gdGhlbSBiZWluZyBzZXQgZHVyaW5nIGxhc3QgcmVuZGVyLlxuICAgICAgICAgICAgLy8gVE9ETzogcmV2aXNpdCB0aGlzIHdoZW4gd2UgaW1wbGVtZW50IHJlc3VtaW5nLlxuXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGlmIChmaW5pc2hlZFdvcmsudHlwZSA9PT0gZmluaXNoZWRXb3JrLmVsZW1lbnRUeXBlICYmICFkaWRXYXJuQWJvdXRSZWFzc2lnbmluZ1Byb3BzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGluc3RhbmNlLnByb3BzICE9PSBmaW5pc2hlZFdvcmsubWVtb2l6ZWRQcm9wcykge1xuICAgICAgICAgICAgICAgICAgZXJyb3IoJ0V4cGVjdGVkICVzIHByb3BzIHRvIG1hdGNoIG1lbW9pemVkIHByb3BzIGJlZm9yZSAnICsgJ2dldFNuYXBzaG90QmVmb3JlVXBkYXRlLiAnICsgJ1RoaXMgbWlnaHQgZWl0aGVyIGJlIGJlY2F1c2Ugb2YgYSBidWcgaW4gUmVhY3QsIG9yIGJlY2F1c2UgJyArICdhIGNvbXBvbmVudCByZWFzc2lnbnMgaXRzIG93biBgdGhpcy5wcm9wc2AuICcgKyAnUGxlYXNlIGZpbGUgYW4gaXNzdWUuJywgZ2V0Q29tcG9uZW50TmFtZShmaW5pc2hlZFdvcmsudHlwZSkgfHwgJ2luc3RhbmNlJyk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGluc3RhbmNlLnN0YXRlICE9PSBmaW5pc2hlZFdvcmsubWVtb2l6ZWRTdGF0ZSkge1xuICAgICAgICAgICAgICAgICAgZXJyb3IoJ0V4cGVjdGVkICVzIHN0YXRlIHRvIG1hdGNoIG1lbW9pemVkIHN0YXRlIGJlZm9yZSAnICsgJ2dldFNuYXBzaG90QmVmb3JlVXBkYXRlLiAnICsgJ1RoaXMgbWlnaHQgZWl0aGVyIGJlIGJlY2F1c2Ugb2YgYSBidWcgaW4gUmVhY3QsIG9yIGJlY2F1c2UgJyArICdhIGNvbXBvbmVudCByZWFzc2lnbnMgaXRzIG93biBgdGhpcy5zdGF0ZWAuICcgKyAnUGxlYXNlIGZpbGUgYW4gaXNzdWUuJywgZ2V0Q29tcG9uZW50TmFtZShmaW5pc2hlZFdvcmsudHlwZSkgfHwgJ2luc3RhbmNlJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBzbmFwc2hvdCA9IGluc3RhbmNlLmdldFNuYXBzaG90QmVmb3JlVXBkYXRlKGZpbmlzaGVkV29yay5lbGVtZW50VHlwZSA9PT0gZmluaXNoZWRXb3JrLnR5cGUgPyBwcmV2UHJvcHMgOiByZXNvbHZlRGVmYXVsdFByb3BzKGZpbmlzaGVkV29yay50eXBlLCBwcmV2UHJvcHMpLCBwcmV2U3RhdGUpO1xuXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHZhciBkaWRXYXJuU2V0ID0gZGlkV2FybkFib3V0VW5kZWZpbmVkU25hcHNob3RCZWZvcmVVcGRhdGU7XG5cbiAgICAgICAgICAgICAgaWYgKHNuYXBzaG90ID09PSB1bmRlZmluZWQgJiYgIWRpZFdhcm5TZXQuaGFzKGZpbmlzaGVkV29yay50eXBlKSkge1xuICAgICAgICAgICAgICAgIGRpZFdhcm5TZXQuYWRkKGZpbmlzaGVkV29yay50eXBlKTtcblxuICAgICAgICAgICAgICAgIGVycm9yKCclcy5nZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSgpOiBBIHNuYXBzaG90IHZhbHVlIChvciBudWxsKSAnICsgJ211c3QgYmUgcmV0dXJuZWQuIFlvdSBoYXZlIHJldHVybmVkIHVuZGVmaW5lZC4nLCBnZXRDb21wb25lbnROYW1lKGZpbmlzaGVkV29yay50eXBlKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaW5zdGFuY2UuX19yZWFjdEludGVybmFsU25hcHNob3RCZWZvcmVVcGRhdGUgPSBzbmFwc2hvdDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICBjYXNlIEhvc3RSb290OlxuICAgICAge1xuICAgICAgICB7XG4gICAgICAgICAgaWYgKGZpbmlzaGVkV29yay5mbGFncyAmIFNuYXBzaG90KSB7XG4gICAgICAgICAgICB2YXIgcm9vdCA9IGZpbmlzaGVkV29yay5zdGF0ZU5vZGU7XG4gICAgICAgICAgICBjbGVhckNvbnRhaW5lcihyb290LmNvbnRhaW5lckluZm8pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICBjYXNlIEhvc3RUZXh0OlxuICAgIGNhc2UgSG9zdFBvcnRhbDpcbiAgICBjYXNlIEluY29tcGxldGVDbGFzc0NvbXBvbmVudDpcbiAgICAgIC8vIE5vdGhpbmcgdG8gZG8gZm9yIHRoZXNlIGNvbXBvbmVudCB0eXBlc1xuICAgICAgcmV0dXJuO1xuICB9XG5cbiAge1xuICAgIHtcbiAgICAgIHRocm93IEVycm9yKCBcIlRoaXMgdW5pdCBvZiB3b3JrIHRhZyBzaG91bGQgbm90IGhhdmUgc2lkZS1lZmZlY3RzLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiICk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNvbW1pdEhvb2tFZmZlY3RMaXN0VW5tb3VudCh0YWcsIGZpbmlzaGVkV29yaykge1xuICB2YXIgdXBkYXRlUXVldWUgPSBmaW5pc2hlZFdvcmsudXBkYXRlUXVldWU7XG4gIHZhciBsYXN0RWZmZWN0ID0gdXBkYXRlUXVldWUgIT09IG51bGwgPyB1cGRhdGVRdWV1ZS5sYXN0RWZmZWN0IDogbnVsbDtcblxuICBpZiAobGFzdEVmZmVjdCAhPT0gbnVsbCkge1xuICAgIHZhciBmaXJzdEVmZmVjdCA9IGxhc3RFZmZlY3QubmV4dDtcbiAgICB2YXIgZWZmZWN0ID0gZmlyc3RFZmZlY3Q7XG5cbiAgICBkbyB7XG4gICAgICBpZiAoKGVmZmVjdC50YWcgJiB0YWcpID09PSB0YWcpIHtcbiAgICAgICAgLy8gVW5tb3VudFxuICAgICAgICB2YXIgZGVzdHJveSA9IGVmZmVjdC5kZXN0cm95O1xuICAgICAgICBlZmZlY3QuZGVzdHJveSA9IHVuZGVmaW5lZDtcblxuICAgICAgICBpZiAoZGVzdHJveSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgZGVzdHJveSgpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGVmZmVjdCA9IGVmZmVjdC5uZXh0O1xuICAgIH0gd2hpbGUgKGVmZmVjdCAhPT0gZmlyc3RFZmZlY3QpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNvbW1pdEhvb2tFZmZlY3RMaXN0TW91bnQodGFnLCBmaW5pc2hlZFdvcmspIHtcbiAgdmFyIHVwZGF0ZVF1ZXVlID0gZmluaXNoZWRXb3JrLnVwZGF0ZVF1ZXVlO1xuICB2YXIgbGFzdEVmZmVjdCA9IHVwZGF0ZVF1ZXVlICE9PSBudWxsID8gdXBkYXRlUXVldWUubGFzdEVmZmVjdCA6IG51bGw7XG5cbiAgaWYgKGxhc3RFZmZlY3QgIT09IG51bGwpIHtcbiAgICB2YXIgZmlyc3RFZmZlY3QgPSBsYXN0RWZmZWN0Lm5leHQ7XG4gICAgdmFyIGVmZmVjdCA9IGZpcnN0RWZmZWN0O1xuXG4gICAgZG8ge1xuICAgICAgaWYgKChlZmZlY3QudGFnICYgdGFnKSA9PT0gdGFnKSB7XG4gICAgICAgIC8vIE1vdW50XG4gICAgICAgIHZhciBjcmVhdGUgPSBlZmZlY3QuY3JlYXRlO1xuICAgICAgICBlZmZlY3QuZGVzdHJveSA9IGNyZWF0ZSgpO1xuXG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgZGVzdHJveSA9IGVmZmVjdC5kZXN0cm95O1xuXG4gICAgICAgICAgaWYgKGRlc3Ryb3kgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgZGVzdHJveSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdmFyIGFkZGVuZHVtID0gdm9pZCAwO1xuXG4gICAgICAgICAgICBpZiAoZGVzdHJveSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICBhZGRlbmR1bSA9ICcgWW91IHJldHVybmVkIG51bGwuIElmIHlvdXIgZWZmZWN0IGRvZXMgbm90IHJlcXVpcmUgY2xlYW4gJyArICd1cCwgcmV0dXJuIHVuZGVmaW5lZCAob3Igbm90aGluZykuJztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGRlc3Ryb3kudGhlbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICBhZGRlbmR1bSA9ICdcXG5cXG5JdCBsb29rcyBsaWtlIHlvdSB3cm90ZSB1c2VFZmZlY3QoYXN5bmMgKCkgPT4gLi4uKSBvciByZXR1cm5lZCBhIFByb21pc2UuICcgKyAnSW5zdGVhZCwgd3JpdGUgdGhlIGFzeW5jIGZ1bmN0aW9uIGluc2lkZSB5b3VyIGVmZmVjdCAnICsgJ2FuZCBjYWxsIGl0IGltbWVkaWF0ZWx5OlxcblxcbicgKyAndXNlRWZmZWN0KCgpID0+IHtcXG4nICsgJyAgYXN5bmMgZnVuY3Rpb24gZmV0Y2hEYXRhKCkge1xcbicgKyAnICAgIC8vIFlvdSBjYW4gYXdhaXQgaGVyZVxcbicgKyAnICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgTXlBUEkuZ2V0RGF0YShzb21lSWQpO1xcbicgKyAnICAgIC8vIC4uLlxcbicgKyAnICB9XFxuJyArICcgIGZldGNoRGF0YSgpO1xcbicgKyBcIn0sIFtzb21lSWRdKTsgLy8gT3IgW10gaWYgZWZmZWN0IGRvZXNuJ3QgbmVlZCBwcm9wcyBvciBzdGF0ZVxcblxcblwiICsgJ0xlYXJuIG1vcmUgYWJvdXQgZGF0YSBmZXRjaGluZyB3aXRoIEhvb2tzOiBodHRwczovL3JlYWN0anMub3JnL2xpbmsvaG9va3MtZGF0YS1mZXRjaGluZyc7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBhZGRlbmR1bSA9ICcgWW91IHJldHVybmVkOiAnICsgZGVzdHJveTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZXJyb3IoJ0FuIGVmZmVjdCBmdW5jdGlvbiBtdXN0IG5vdCByZXR1cm4gYW55dGhpbmcgYmVzaWRlcyBhIGZ1bmN0aW9uLCAnICsgJ3doaWNoIGlzIHVzZWQgZm9yIGNsZWFuLXVwLiVzJywgYWRkZW5kdW0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBlZmZlY3QgPSBlZmZlY3QubmV4dDtcbiAgICB9IHdoaWxlIChlZmZlY3QgIT09IGZpcnN0RWZmZWN0KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzY2hlZHVsZVBhc3NpdmVFZmZlY3RzKGZpbmlzaGVkV29yaykge1xuICB2YXIgdXBkYXRlUXVldWUgPSBmaW5pc2hlZFdvcmsudXBkYXRlUXVldWU7XG4gIHZhciBsYXN0RWZmZWN0ID0gdXBkYXRlUXVldWUgIT09IG51bGwgPyB1cGRhdGVRdWV1ZS5sYXN0RWZmZWN0IDogbnVsbDtcblxuICBpZiAobGFzdEVmZmVjdCAhPT0gbnVsbCkge1xuICAgIHZhciBmaXJzdEVmZmVjdCA9IGxhc3RFZmZlY3QubmV4dDtcbiAgICB2YXIgZWZmZWN0ID0gZmlyc3RFZmZlY3Q7XG5cbiAgICBkbyB7XG4gICAgICB2YXIgX2VmZmVjdCA9IGVmZmVjdCxcbiAgICAgICAgICBuZXh0ID0gX2VmZmVjdC5uZXh0LFxuICAgICAgICAgIHRhZyA9IF9lZmZlY3QudGFnO1xuXG4gICAgICBpZiAoKHRhZyAmIFBhc3NpdmUkMSkgIT09IE5vRmxhZ3MkMSAmJiAodGFnICYgSGFzRWZmZWN0KSAhPT0gTm9GbGFncyQxKSB7XG4gICAgICAgIGVucXVldWVQZW5kaW5nUGFzc2l2ZUhvb2tFZmZlY3RVbm1vdW50KGZpbmlzaGVkV29yaywgZWZmZWN0KTtcbiAgICAgICAgZW5xdWV1ZVBlbmRpbmdQYXNzaXZlSG9va0VmZmVjdE1vdW50KGZpbmlzaGVkV29yaywgZWZmZWN0KTtcbiAgICAgIH1cblxuICAgICAgZWZmZWN0ID0gbmV4dDtcbiAgICB9IHdoaWxlIChlZmZlY3QgIT09IGZpcnN0RWZmZWN0KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjb21taXRMaWZlQ3ljbGVzKGZpbmlzaGVkUm9vdCwgY3VycmVudCwgZmluaXNoZWRXb3JrLCBjb21taXR0ZWRMYW5lcykge1xuICBzd2l0Y2ggKGZpbmlzaGVkV29yay50YWcpIHtcbiAgICBjYXNlIEZ1bmN0aW9uQ29tcG9uZW50OlxuICAgIGNhc2UgRm9yd2FyZFJlZjpcbiAgICBjYXNlIFNpbXBsZU1lbW9Db21wb25lbnQ6XG4gICAgY2FzZSBCbG9jazpcbiAgICAgIHtcbiAgICAgICAgLy8gQXQgdGhpcyBwb2ludCBsYXlvdXQgZWZmZWN0cyBoYXZlIGFscmVhZHkgYmVlbiBkZXN0cm95ZWQgKGR1cmluZyBtdXRhdGlvbiBwaGFzZSkuXG4gICAgICAgIC8vIFRoaXMgaXMgZG9uZSB0byBwcmV2ZW50IHNpYmxpbmcgY29tcG9uZW50IGVmZmVjdHMgZnJvbSBpbnRlcmZlcmluZyB3aXRoIGVhY2ggb3RoZXIsXG4gICAgICAgIC8vIGUuZy4gYSBkZXN0cm95IGZ1bmN0aW9uIGluIG9uZSBjb21wb25lbnQgc2hvdWxkIG5ldmVyIG92ZXJyaWRlIGEgcmVmIHNldFxuICAgICAgICAvLyBieSBhIGNyZWF0ZSBmdW5jdGlvbiBpbiBhbm90aGVyIGNvbXBvbmVudCBkdXJpbmcgdGhlIHNhbWUgY29tbWl0LlxuICAgICAgICB7XG4gICAgICAgICAgY29tbWl0SG9va0VmZmVjdExpc3RNb3VudChMYXlvdXQgfCBIYXNFZmZlY3QsIGZpbmlzaGVkV29yayk7XG4gICAgICAgIH1cblxuICAgICAgICBzY2hlZHVsZVBhc3NpdmVFZmZlY3RzKGZpbmlzaGVkV29yayk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgIGNhc2UgQ2xhc3NDb21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIHZhciBpbnN0YW5jZSA9IGZpbmlzaGVkV29yay5zdGF0ZU5vZGU7XG5cbiAgICAgICAgaWYgKGZpbmlzaGVkV29yay5mbGFncyAmIFVwZGF0ZSkge1xuICAgICAgICAgIGlmIChjdXJyZW50ID09PSBudWxsKSB7XG4gICAgICAgICAgICAvLyBXZSBjb3VsZCB1cGRhdGUgaW5zdGFuY2UgcHJvcHMgYW5kIHN0YXRlIGhlcmUsXG4gICAgICAgICAgICAvLyBidXQgaW5zdGVhZCB3ZSByZWx5IG9uIHRoZW0gYmVpbmcgc2V0IGR1cmluZyBsYXN0IHJlbmRlci5cbiAgICAgICAgICAgIC8vIFRPRE86IHJldmlzaXQgdGhpcyB3aGVuIHdlIGltcGxlbWVudCByZXN1bWluZy5cbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgaWYgKGZpbmlzaGVkV29yay50eXBlID09PSBmaW5pc2hlZFdvcmsuZWxlbWVudFR5cGUgJiYgIWRpZFdhcm5BYm91dFJlYXNzaWduaW5nUHJvcHMpIHtcbiAgICAgICAgICAgICAgICBpZiAoaW5zdGFuY2UucHJvcHMgIT09IGZpbmlzaGVkV29yay5tZW1vaXplZFByb3BzKSB7XG4gICAgICAgICAgICAgICAgICBlcnJvcignRXhwZWN0ZWQgJXMgcHJvcHMgdG8gbWF0Y2ggbWVtb2l6ZWQgcHJvcHMgYmVmb3JlICcgKyAnY29tcG9uZW50RGlkTW91bnQuICcgKyAnVGhpcyBtaWdodCBlaXRoZXIgYmUgYmVjYXVzZSBvZiBhIGJ1ZyBpbiBSZWFjdCwgb3IgYmVjYXVzZSAnICsgJ2EgY29tcG9uZW50IHJlYXNzaWducyBpdHMgb3duIGB0aGlzLnByb3BzYC4gJyArICdQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nLCBnZXRDb21wb25lbnROYW1lKGZpbmlzaGVkV29yay50eXBlKSB8fCAnaW5zdGFuY2UnKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoaW5zdGFuY2Uuc3RhdGUgIT09IGZpbmlzaGVkV29yay5tZW1vaXplZFN0YXRlKSB7XG4gICAgICAgICAgICAgICAgICBlcnJvcignRXhwZWN0ZWQgJXMgc3RhdGUgdG8gbWF0Y2ggbWVtb2l6ZWQgc3RhdGUgYmVmb3JlICcgKyAnY29tcG9uZW50RGlkTW91bnQuICcgKyAnVGhpcyBtaWdodCBlaXRoZXIgYmUgYmVjYXVzZSBvZiBhIGJ1ZyBpbiBSZWFjdCwgb3IgYmVjYXVzZSAnICsgJ2EgY29tcG9uZW50IHJlYXNzaWducyBpdHMgb3duIGB0aGlzLnN0YXRlYC4gJyArICdQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nLCBnZXRDb21wb25lbnROYW1lKGZpbmlzaGVkV29yay50eXBlKSB8fCAnaW5zdGFuY2UnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBpbnN0YW5jZS5jb21wb25lbnREaWRNb3VudCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgcHJldlByb3BzID0gZmluaXNoZWRXb3JrLmVsZW1lbnRUeXBlID09PSBmaW5pc2hlZFdvcmsudHlwZSA/IGN1cnJlbnQubWVtb2l6ZWRQcm9wcyA6IHJlc29sdmVEZWZhdWx0UHJvcHMoZmluaXNoZWRXb3JrLnR5cGUsIGN1cnJlbnQubWVtb2l6ZWRQcm9wcyk7XG4gICAgICAgICAgICB2YXIgcHJldlN0YXRlID0gY3VycmVudC5tZW1vaXplZFN0YXRlOyAvLyBXZSBjb3VsZCB1cGRhdGUgaW5zdGFuY2UgcHJvcHMgYW5kIHN0YXRlIGhlcmUsXG4gICAgICAgICAgICAvLyBidXQgaW5zdGVhZCB3ZSByZWx5IG9uIHRoZW0gYmVpbmcgc2V0IGR1cmluZyBsYXN0IHJlbmRlci5cbiAgICAgICAgICAgIC8vIFRPRE86IHJldmlzaXQgdGhpcyB3aGVuIHdlIGltcGxlbWVudCByZXN1bWluZy5cblxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBpZiAoZmluaXNoZWRXb3JrLnR5cGUgPT09IGZpbmlzaGVkV29yay5lbGVtZW50VHlwZSAmJiAhZGlkV2FybkFib3V0UmVhc3NpZ25pbmdQcm9wcykge1xuICAgICAgICAgICAgICAgIGlmIChpbnN0YW5jZS5wcm9wcyAhPT0gZmluaXNoZWRXb3JrLm1lbW9pemVkUHJvcHMpIHtcbiAgICAgICAgICAgICAgICAgIGVycm9yKCdFeHBlY3RlZCAlcyBwcm9wcyB0byBtYXRjaCBtZW1vaXplZCBwcm9wcyBiZWZvcmUgJyArICdjb21wb25lbnREaWRVcGRhdGUuICcgKyAnVGhpcyBtaWdodCBlaXRoZXIgYmUgYmVjYXVzZSBvZiBhIGJ1ZyBpbiBSZWFjdCwgb3IgYmVjYXVzZSAnICsgJ2EgY29tcG9uZW50IHJlYXNzaWducyBpdHMgb3duIGB0aGlzLnByb3BzYC4gJyArICdQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nLCBnZXRDb21wb25lbnROYW1lKGZpbmlzaGVkV29yay50eXBlKSB8fCAnaW5zdGFuY2UnKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoaW5zdGFuY2Uuc3RhdGUgIT09IGZpbmlzaGVkV29yay5tZW1vaXplZFN0YXRlKSB7XG4gICAgICAgICAgICAgICAgICBlcnJvcignRXhwZWN0ZWQgJXMgc3RhdGUgdG8gbWF0Y2ggbWVtb2l6ZWQgc3RhdGUgYmVmb3JlICcgKyAnY29tcG9uZW50RGlkVXBkYXRlLiAnICsgJ1RoaXMgbWlnaHQgZWl0aGVyIGJlIGJlY2F1c2Ugb2YgYSBidWcgaW4gUmVhY3QsIG9yIGJlY2F1c2UgJyArICdhIGNvbXBvbmVudCByZWFzc2lnbnMgaXRzIG93biBgdGhpcy5zdGF0ZWAuICcgKyAnUGxlYXNlIGZpbGUgYW4gaXNzdWUuJywgZ2V0Q29tcG9uZW50TmFtZShmaW5pc2hlZFdvcmsudHlwZSkgfHwgJ2luc3RhbmNlJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgaW5zdGFuY2UuY29tcG9uZW50RGlkVXBkYXRlKHByZXZQcm9wcywgcHJldlN0YXRlLCBpbnN0YW5jZS5fX3JlYWN0SW50ZXJuYWxTbmFwc2hvdEJlZm9yZVVwZGF0ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IC8vIFRPRE86IEkgdGhpbmsgdGhpcyBpcyBub3cgYWx3YXlzIG5vbi1udWxsIGJ5IHRoZSB0aW1lIGl0IHJlYWNoZXMgdGhlXG4gICAgICAgIC8vIGNvbW1pdCBwaGFzZS4gQ29uc2lkZXIgcmVtb3ZpbmcgdGhlIHR5cGUgY2hlY2suXG5cblxuICAgICAgICB2YXIgdXBkYXRlUXVldWUgPSBmaW5pc2hlZFdvcmsudXBkYXRlUXVldWU7XG5cbiAgICAgICAgaWYgKHVwZGF0ZVF1ZXVlICE9PSBudWxsKSB7XG4gICAgICAgICAge1xuICAgICAgICAgICAgaWYgKGZpbmlzaGVkV29yay50eXBlID09PSBmaW5pc2hlZFdvcmsuZWxlbWVudFR5cGUgJiYgIWRpZFdhcm5BYm91dFJlYXNzaWduaW5nUHJvcHMpIHtcbiAgICAgICAgICAgICAgaWYgKGluc3RhbmNlLnByb3BzICE9PSBmaW5pc2hlZFdvcmsubWVtb2l6ZWRQcm9wcykge1xuICAgICAgICAgICAgICAgIGVycm9yKCdFeHBlY3RlZCAlcyBwcm9wcyB0byBtYXRjaCBtZW1vaXplZCBwcm9wcyBiZWZvcmUgJyArICdwcm9jZXNzaW5nIHRoZSB1cGRhdGUgcXVldWUuICcgKyAnVGhpcyBtaWdodCBlaXRoZXIgYmUgYmVjYXVzZSBvZiBhIGJ1ZyBpbiBSZWFjdCwgb3IgYmVjYXVzZSAnICsgJ2EgY29tcG9uZW50IHJlYXNzaWducyBpdHMgb3duIGB0aGlzLnByb3BzYC4gJyArICdQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nLCBnZXRDb21wb25lbnROYW1lKGZpbmlzaGVkV29yay50eXBlKSB8fCAnaW5zdGFuY2UnKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmIChpbnN0YW5jZS5zdGF0ZSAhPT0gZmluaXNoZWRXb3JrLm1lbW9pemVkU3RhdGUpIHtcbiAgICAgICAgICAgICAgICBlcnJvcignRXhwZWN0ZWQgJXMgc3RhdGUgdG8gbWF0Y2ggbWVtb2l6ZWQgc3RhdGUgYmVmb3JlICcgKyAncHJvY2Vzc2luZyB0aGUgdXBkYXRlIHF1ZXVlLiAnICsgJ1RoaXMgbWlnaHQgZWl0aGVyIGJlIGJlY2F1c2Ugb2YgYSBidWcgaW4gUmVhY3QsIG9yIGJlY2F1c2UgJyArICdhIGNvbXBvbmVudCByZWFzc2lnbnMgaXRzIG93biBgdGhpcy5zdGF0ZWAuICcgKyAnUGxlYXNlIGZpbGUgYW4gaXNzdWUuJywgZ2V0Q29tcG9uZW50TmFtZShmaW5pc2hlZFdvcmsudHlwZSkgfHwgJ2luc3RhbmNlJyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IC8vIFdlIGNvdWxkIHVwZGF0ZSBpbnN0YW5jZSBwcm9wcyBhbmQgc3RhdGUgaGVyZSxcbiAgICAgICAgICAvLyBidXQgaW5zdGVhZCB3ZSByZWx5IG9uIHRoZW0gYmVpbmcgc2V0IGR1cmluZyBsYXN0IHJlbmRlci5cbiAgICAgICAgICAvLyBUT0RPOiByZXZpc2l0IHRoaXMgd2hlbiB3ZSBpbXBsZW1lbnQgcmVzdW1pbmcuXG5cblxuICAgICAgICAgIGNvbW1pdFVwZGF0ZVF1ZXVlKGZpbmlzaGVkV29yaywgdXBkYXRlUXVldWUsIGluc3RhbmNlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgIGNhc2UgSG9zdFJvb3Q6XG4gICAgICB7XG4gICAgICAgIC8vIFRPRE86IEkgdGhpbmsgdGhpcyBpcyBub3cgYWx3YXlzIG5vbi1udWxsIGJ5IHRoZSB0aW1lIGl0IHJlYWNoZXMgdGhlXG4gICAgICAgIC8vIGNvbW1pdCBwaGFzZS4gQ29uc2lkZXIgcmVtb3ZpbmcgdGhlIHR5cGUgY2hlY2suXG4gICAgICAgIHZhciBfdXBkYXRlUXVldWUgPSBmaW5pc2hlZFdvcmsudXBkYXRlUXVldWU7XG5cbiAgICAgICAgaWYgKF91cGRhdGVRdWV1ZSAhPT0gbnVsbCkge1xuICAgICAgICAgIHZhciBfaW5zdGFuY2UgPSBudWxsO1xuXG4gICAgICAgICAgaWYgKGZpbmlzaGVkV29yay5jaGlsZCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgc3dpdGNoIChmaW5pc2hlZFdvcmsuY2hpbGQudGFnKSB7XG4gICAgICAgICAgICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICAgICAgICAgICAgICBfaW5zdGFuY2UgPSBnZXRQdWJsaWNJbnN0YW5jZShmaW5pc2hlZFdvcmsuY2hpbGQuc3RhdGVOb2RlKTtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICBjYXNlIENsYXNzQ29tcG9uZW50OlxuICAgICAgICAgICAgICAgIF9pbnN0YW5jZSA9IGZpbmlzaGVkV29yay5jaGlsZC5zdGF0ZU5vZGU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29tbWl0VXBkYXRlUXVldWUoZmluaXNoZWRXb3JrLCBfdXBkYXRlUXVldWUsIF9pbnN0YW5jZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIHZhciBfaW5zdGFuY2UyID0gZmluaXNoZWRXb3JrLnN0YXRlTm9kZTsgLy8gUmVuZGVyZXJzIG1heSBzY2hlZHVsZSB3b3JrIHRvIGJlIGRvbmUgYWZ0ZXIgaG9zdCBjb21wb25lbnRzIGFyZSBtb3VudGVkXG4gICAgICAgIC8vIChlZyBET00gcmVuZGVyZXIgbWF5IHNjaGVkdWxlIGF1dG8tZm9jdXMgZm9yIGlucHV0cyBhbmQgZm9ybSBjb250cm9scykuXG4gICAgICAgIC8vIFRoZXNlIGVmZmVjdHMgc2hvdWxkIG9ubHkgYmUgY29tbWl0dGVkIHdoZW4gY29tcG9uZW50cyBhcmUgZmlyc3QgbW91bnRlZCxcbiAgICAgICAgLy8gYWthIHdoZW4gdGhlcmUgaXMgbm8gY3VycmVudC9hbHRlcm5hdGUuXG5cbiAgICAgICAgaWYgKGN1cnJlbnQgPT09IG51bGwgJiYgZmluaXNoZWRXb3JrLmZsYWdzICYgVXBkYXRlKSB7XG4gICAgICAgICAgdmFyIHR5cGUgPSBmaW5pc2hlZFdvcmsudHlwZTtcbiAgICAgICAgICB2YXIgcHJvcHMgPSBmaW5pc2hlZFdvcmsubWVtb2l6ZWRQcm9wcztcbiAgICAgICAgICBjb21taXRNb3VudChfaW5zdGFuY2UyLCB0eXBlLCBwcm9wcyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICBjYXNlIEhvc3RUZXh0OlxuICAgICAge1xuICAgICAgICAvLyBXZSBoYXZlIG5vIGxpZmUtY3ljbGVzIGFzc29jaWF0ZWQgd2l0aCB0ZXh0LlxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICBjYXNlIEhvc3RQb3J0YWw6XG4gICAgICB7XG4gICAgICAgIC8vIFdlIGhhdmUgbm8gbGlmZS1jeWNsZXMgYXNzb2NpYXRlZCB3aXRoIHBvcnRhbHMuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgIGNhc2UgUHJvZmlsZXI6XG4gICAgICB7XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgX2ZpbmlzaGVkV29yayRtZW1vaXplMiA9IGZpbmlzaGVkV29yay5tZW1vaXplZFByb3BzLFxuICAgICAgICAgICAgICBvbkNvbW1pdCA9IF9maW5pc2hlZFdvcmskbWVtb2l6ZTIub25Db21taXQsXG4gICAgICAgICAgICAgIG9uUmVuZGVyID0gX2ZpbmlzaGVkV29yayRtZW1vaXplMi5vblJlbmRlcjtcbiAgICAgICAgICB2YXIgZWZmZWN0RHVyYXRpb24gPSBmaW5pc2hlZFdvcmsuc3RhdGVOb2RlLmVmZmVjdER1cmF0aW9uO1xuICAgICAgICAgIHZhciBjb21taXRUaW1lID0gZ2V0Q29tbWl0VGltZSgpO1xuXG4gICAgICAgICAgaWYgKHR5cGVvZiBvblJlbmRlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBvblJlbmRlcihmaW5pc2hlZFdvcmsubWVtb2l6ZWRQcm9wcy5pZCwgY3VycmVudCA9PT0gbnVsbCA/ICdtb3VudCcgOiAndXBkYXRlJywgZmluaXNoZWRXb3JrLmFjdHVhbER1cmF0aW9uLCBmaW5pc2hlZFdvcmsudHJlZUJhc2VEdXJhdGlvbiwgZmluaXNoZWRXb3JrLmFjdHVhbFN0YXJ0VGltZSwgY29tbWl0VGltZSwgZmluaXNoZWRSb290Lm1lbW9pemVkSW50ZXJhY3Rpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICBjYXNlIFN1c3BlbnNlQ29tcG9uZW50OlxuICAgICAge1xuICAgICAgICBjb21taXRTdXNwZW5zZUh5ZHJhdGlvbkNhbGxiYWNrcyhmaW5pc2hlZFJvb3QsIGZpbmlzaGVkV29yayk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgIGNhc2UgU3VzcGVuc2VMaXN0Q29tcG9uZW50OlxuICAgIGNhc2UgSW5jb21wbGV0ZUNsYXNzQ29tcG9uZW50OlxuICAgIGNhc2UgRnVuZGFtZW50YWxDb21wb25lbnQ6XG4gICAgY2FzZSBTY29wZUNvbXBvbmVudDpcbiAgICBjYXNlIE9mZnNjcmVlbkNvbXBvbmVudDpcbiAgICBjYXNlIExlZ2FjeUhpZGRlbkNvbXBvbmVudDpcbiAgICAgIHJldHVybjtcbiAgfVxuXG4gIHtcbiAgICB7XG4gICAgICB0aHJvdyBFcnJvciggXCJUaGlzIHVuaXQgb2Ygd29yayB0YWcgc2hvdWxkIG5vdCBoYXZlIHNpZGUtZWZmZWN0cy4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS5cIiApO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBoaWRlT3JVbmhpZGVBbGxDaGlsZHJlbihmaW5pc2hlZFdvcmssIGlzSGlkZGVuKSB7XG4gIHtcbiAgICAvLyBXZSBvbmx5IGhhdmUgdGhlIHRvcCBGaWJlciB0aGF0IHdhcyBpbnNlcnRlZCBidXQgd2UgbmVlZCB0byByZWN1cnNlIGRvd24gaXRzXG4gICAgLy8gY2hpbGRyZW4gdG8gZmluZCBhbGwgdGhlIHRlcm1pbmFsIG5vZGVzLlxuICAgIHZhciBub2RlID0gZmluaXNoZWRXb3JrO1xuXG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIGlmIChub2RlLnRhZyA9PT0gSG9zdENvbXBvbmVudCkge1xuICAgICAgICB2YXIgaW5zdGFuY2UgPSBub2RlLnN0YXRlTm9kZTtcblxuICAgICAgICBpZiAoaXNIaWRkZW4pIHtcbiAgICAgICAgICBoaWRlSW5zdGFuY2UoaW5zdGFuY2UpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHVuaGlkZUluc3RhbmNlKG5vZGUuc3RhdGVOb2RlLCBub2RlLm1lbW9pemVkUHJvcHMpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKG5vZGUudGFnID09PSBIb3N0VGV4dCkge1xuICAgICAgICB2YXIgX2luc3RhbmNlMyA9IG5vZGUuc3RhdGVOb2RlO1xuXG4gICAgICAgIGlmIChpc0hpZGRlbikge1xuICAgICAgICAgIGhpZGVUZXh0SW5zdGFuY2UoX2luc3RhbmNlMyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdW5oaWRlVGV4dEluc3RhbmNlKF9pbnN0YW5jZTMsIG5vZGUubWVtb2l6ZWRQcm9wcyk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoKG5vZGUudGFnID09PSBPZmZzY3JlZW5Db21wb25lbnQgfHwgbm9kZS50YWcgPT09IExlZ2FjeUhpZGRlbkNvbXBvbmVudCkgJiYgbm9kZS5tZW1vaXplZFN0YXRlICE9PSBudWxsICYmIG5vZGUgIT09IGZpbmlzaGVkV29yaykgOyBlbHNlIGlmIChub2RlLmNoaWxkICE9PSBudWxsKSB7XG4gICAgICAgIG5vZGUuY2hpbGQucmV0dXJuID0gbm9kZTtcbiAgICAgICAgbm9kZSA9IG5vZGUuY2hpbGQ7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAobm9kZSA9PT0gZmluaXNoZWRXb3JrKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgd2hpbGUgKG5vZGUuc2libGluZyA9PT0gbnVsbCkge1xuICAgICAgICBpZiAobm9kZS5yZXR1cm4gPT09IG51bGwgfHwgbm9kZS5yZXR1cm4gPT09IGZpbmlzaGVkV29yaykge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIG5vZGUgPSBub2RlLnJldHVybjtcbiAgICAgIH1cblxuICAgICAgbm9kZS5zaWJsaW5nLnJldHVybiA9IG5vZGUucmV0dXJuO1xuICAgICAgbm9kZSA9IG5vZGUuc2libGluZztcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY29tbWl0QXR0YWNoUmVmKGZpbmlzaGVkV29yaykge1xuICB2YXIgcmVmID0gZmluaXNoZWRXb3JrLnJlZjtcblxuICBpZiAocmVmICE9PSBudWxsKSB7XG4gICAgdmFyIGluc3RhbmNlID0gZmluaXNoZWRXb3JrLnN0YXRlTm9kZTtcbiAgICB2YXIgaW5zdGFuY2VUb1VzZTtcblxuICAgIHN3aXRjaCAoZmluaXNoZWRXb3JrLnRhZykge1xuICAgICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgICAgICBpbnN0YW5jZVRvVXNlID0gZ2V0UHVibGljSW5zdGFuY2UoaW5zdGFuY2UpO1xuICAgICAgICBicmVhaztcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaW5zdGFuY2VUb1VzZSA9IGluc3RhbmNlO1xuICAgIH0gLy8gTW92ZWQgb3V0c2lkZSB0byBlbnN1cmUgRENFIHdvcmtzIHdpdGggdGhpcyBmbGFnXG5cbiAgICBpZiAodHlwZW9mIHJlZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmVmKGluc3RhbmNlVG9Vc2UpO1xuICAgIH0gZWxzZSB7XG4gICAgICB7XG4gICAgICAgIGlmICghcmVmLmhhc093blByb3BlcnR5KCdjdXJyZW50JykpIHtcbiAgICAgICAgICBlcnJvcignVW5leHBlY3RlZCByZWYgb2JqZWN0IHByb3ZpZGVkIGZvciAlcy4gJyArICdVc2UgZWl0aGVyIGEgcmVmLXNldHRlciBmdW5jdGlvbiBvciBSZWFjdC5jcmVhdGVSZWYoKS4nLCBnZXRDb21wb25lbnROYW1lKGZpbmlzaGVkV29yay50eXBlKSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmVmLmN1cnJlbnQgPSBpbnN0YW5jZVRvVXNlO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjb21taXREZXRhY2hSZWYoY3VycmVudCkge1xuICB2YXIgY3VycmVudFJlZiA9IGN1cnJlbnQucmVmO1xuXG4gIGlmIChjdXJyZW50UmVmICE9PSBudWxsKSB7XG4gICAgaWYgKHR5cGVvZiBjdXJyZW50UmVmID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjdXJyZW50UmVmKG51bGwpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjdXJyZW50UmVmLmN1cnJlbnQgPSBudWxsO1xuICAgIH1cbiAgfVxufSAvLyBVc2VyLW9yaWdpbmF0aW5nIGVycm9ycyAobGlmZWN5Y2xlcyBhbmQgcmVmcykgc2hvdWxkIG5vdCBpbnRlcnJ1cHRcbi8vIGRlbGV0aW9uLCBzbyBkb24ndCBsZXQgdGhlbSB0aHJvdy4gSG9zdC1vcmlnaW5hdGluZyBlcnJvcnMgc2hvdWxkXG4vLyBpbnRlcnJ1cHQgZGVsZXRpb24sIHNvIGl0J3Mgb2theVxuXG5cbmZ1bmN0aW9uIGNvbW1pdFVubW91bnQoZmluaXNoZWRSb290LCBjdXJyZW50LCByZW5kZXJQcmlvcml0eUxldmVsKSB7XG4gIG9uQ29tbWl0VW5tb3VudChjdXJyZW50KTtcblxuICBzd2l0Y2ggKGN1cnJlbnQudGFnKSB7XG4gICAgY2FzZSBGdW5jdGlvbkNvbXBvbmVudDpcbiAgICBjYXNlIEZvcndhcmRSZWY6XG4gICAgY2FzZSBNZW1vQ29tcG9uZW50OlxuICAgIGNhc2UgU2ltcGxlTWVtb0NvbXBvbmVudDpcbiAgICBjYXNlIEJsb2NrOlxuICAgICAge1xuICAgICAgICB2YXIgdXBkYXRlUXVldWUgPSBjdXJyZW50LnVwZGF0ZVF1ZXVlO1xuXG4gICAgICAgIGlmICh1cGRhdGVRdWV1ZSAhPT0gbnVsbCkge1xuICAgICAgICAgIHZhciBsYXN0RWZmZWN0ID0gdXBkYXRlUXVldWUubGFzdEVmZmVjdDtcblxuICAgICAgICAgIGlmIChsYXN0RWZmZWN0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICB2YXIgZmlyc3RFZmZlY3QgPSBsYXN0RWZmZWN0Lm5leHQ7XG4gICAgICAgICAgICB2YXIgZWZmZWN0ID0gZmlyc3RFZmZlY3Q7XG5cbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgdmFyIF9lZmZlY3QyID0gZWZmZWN0LFxuICAgICAgICAgICAgICAgICAgZGVzdHJveSA9IF9lZmZlY3QyLmRlc3Ryb3ksXG4gICAgICAgICAgICAgICAgICB0YWcgPSBfZWZmZWN0Mi50YWc7XG5cbiAgICAgICAgICAgICAgaWYgKGRlc3Ryb3kgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGlmICgodGFnICYgUGFzc2l2ZSQxKSAhPT0gTm9GbGFncyQxKSB7XG4gICAgICAgICAgICAgICAgICBlbnF1ZXVlUGVuZGluZ1Bhc3NpdmVIb29rRWZmZWN0VW5tb3VudChjdXJyZW50LCBlZmZlY3QpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHNhZmVseUNhbGxEZXN0cm95KGN1cnJlbnQsIGRlc3Ryb3kpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGVmZmVjdCA9IGVmZmVjdC5uZXh0O1xuICAgICAgICAgICAgfSB3aGlsZSAoZWZmZWN0ICE9PSBmaXJzdEVmZmVjdCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgY2FzZSBDbGFzc0NvbXBvbmVudDpcbiAgICAgIHtcbiAgICAgICAgc2FmZWx5RGV0YWNoUmVmKGN1cnJlbnQpO1xuICAgICAgICB2YXIgaW5zdGFuY2UgPSBjdXJyZW50LnN0YXRlTm9kZTtcblxuICAgICAgICBpZiAodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFdpbGxVbm1vdW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgc2FmZWx5Q2FsbENvbXBvbmVudFdpbGxVbm1vdW50KGN1cnJlbnQsIGluc3RhbmNlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICAgIHtcbiAgICAgICAgc2FmZWx5RGV0YWNoUmVmKGN1cnJlbnQpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICBjYXNlIEhvc3RQb3J0YWw6XG4gICAgICB7XG4gICAgICAgIC8vIFRPRE86IHRoaXMgaXMgcmVjdXJzaXZlLlxuICAgICAgICAvLyBXZSBhcmUgYWxzbyBub3QgdXNpbmcgdGhpcyBwYXJlbnQgYmVjYXVzZVxuICAgICAgICAvLyB0aGUgcG9ydGFsIHdpbGwgZ2V0IHB1c2hlZCBpbW1lZGlhdGVseS5cbiAgICAgICAge1xuICAgICAgICAgIHVubW91bnRIb3N0Q29tcG9uZW50cyhmaW5pc2hlZFJvb3QsIGN1cnJlbnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgY2FzZSBGdW5kYW1lbnRhbENvbXBvbmVudDpcbiAgICAgIHtcblxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICBjYXNlIERlaHlkcmF0ZWRGcmFnbWVudDpcbiAgICAgIHtcblxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICBjYXNlIFNjb3BlQ29tcG9uZW50OlxuICAgICAge1xuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjb21taXROZXN0ZWRVbm1vdW50cyhmaW5pc2hlZFJvb3QsIHJvb3QsIHJlbmRlclByaW9yaXR5TGV2ZWwpIHtcbiAgLy8gV2hpbGUgd2UncmUgaW5zaWRlIGEgcmVtb3ZlZCBob3N0IG5vZGUgd2UgZG9uJ3Qgd2FudCB0byBjYWxsXG4gIC8vIHJlbW92ZUNoaWxkIG9uIHRoZSBpbm5lciBub2RlcyBiZWNhdXNlIHRoZXkncmUgcmVtb3ZlZCBieSB0aGUgdG9wXG4gIC8vIGNhbGwgYW55d2F5LiBXZSBhbHNvIHdhbnQgdG8gY2FsbCBjb21wb25lbnRXaWxsVW5tb3VudCBvbiBhbGxcbiAgLy8gY29tcG9zaXRlcyBiZWZvcmUgdGhpcyBob3N0IG5vZGUgaXMgcmVtb3ZlZCBmcm9tIHRoZSB0cmVlLiBUaGVyZWZvcmVcbiAgLy8gd2UgZG8gYW4gaW5uZXIgbG9vcCB3aGlsZSB3ZSdyZSBzdGlsbCBpbnNpZGUgdGhlIGhvc3Qgbm9kZS5cbiAgdmFyIG5vZGUgPSByb290O1xuXG4gIHdoaWxlICh0cnVlKSB7XG4gICAgY29tbWl0VW5tb3VudChmaW5pc2hlZFJvb3QsIG5vZGUpOyAvLyBWaXNpdCBjaGlsZHJlbiBiZWNhdXNlIHRoZXkgbWF5IGNvbnRhaW4gbW9yZSBjb21wb3NpdGUgb3IgaG9zdCBub2Rlcy5cbiAgICAvLyBTa2lwIHBvcnRhbHMgYmVjYXVzZSBjb21taXRVbm1vdW50KCkgY3VycmVudGx5IHZpc2l0cyB0aGVtIHJlY3Vyc2l2ZWx5LlxuXG4gICAgaWYgKG5vZGUuY2hpbGQgIT09IG51bGwgJiYgKCAvLyBJZiB3ZSB1c2UgbXV0YXRpb24gd2UgZHJpbGwgZG93biBpbnRvIHBvcnRhbHMgdXNpbmcgY29tbWl0VW5tb3VudCBhYm92ZS5cbiAgICAvLyBJZiB3ZSBkb24ndCB1c2UgbXV0YXRpb24gd2UgZHJpbGwgZG93biBpbnRvIHBvcnRhbHMgaGVyZSBpbnN0ZWFkLlxuICAgICBub2RlLnRhZyAhPT0gSG9zdFBvcnRhbCkpIHtcbiAgICAgIG5vZGUuY2hpbGQucmV0dXJuID0gbm9kZTtcbiAgICAgIG5vZGUgPSBub2RlLmNoaWxkO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKG5vZGUgPT09IHJvb3QpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB3aGlsZSAobm9kZS5zaWJsaW5nID09PSBudWxsKSB7XG4gICAgICBpZiAobm9kZS5yZXR1cm4gPT09IG51bGwgfHwgbm9kZS5yZXR1cm4gPT09IHJvb3QpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBub2RlID0gbm9kZS5yZXR1cm47XG4gICAgfVxuXG4gICAgbm9kZS5zaWJsaW5nLnJldHVybiA9IG5vZGUucmV0dXJuO1xuICAgIG5vZGUgPSBub2RlLnNpYmxpbmc7XG4gIH1cbn1cblxuZnVuY3Rpb24gZGV0YWNoRmliZXJNdXRhdGlvbihmaWJlcikge1xuICAvLyBDdXQgb2ZmIHRoZSByZXR1cm4gcG9pbnRlcnMgdG8gZGlzY29ubmVjdCBpdCBmcm9tIHRoZSB0cmVlLiBJZGVhbGx5LCB3ZVxuICAvLyBzaG91bGQgY2xlYXIgdGhlIGNoaWxkIHBvaW50ZXIgb2YgdGhlIHBhcmVudCBhbHRlcm5hdGUgdG8gbGV0IHRoaXNcbiAgLy8gZ2V0IEdDOmVkIGJ1dCB3ZSBkb24ndCBrbm93IHdoaWNoIGZvciBzdXJlIHdoaWNoIHBhcmVudCBpcyB0aGUgY3VycmVudFxuICAvLyBvbmUgc28gd2UnbGwgc2V0dGxlIGZvciBHQzppbmcgdGhlIHN1YnRyZWUgb2YgdGhpcyBjaGlsZC4gVGhpcyBjaGlsZFxuICAvLyBpdHNlbGYgd2lsbCBiZSBHQzplZCB3aGVuIHRoZSBwYXJlbnQgdXBkYXRlcyB0aGUgbmV4dCB0aW1lLlxuICAvLyBOb3RlOiB3ZSBjYW5ub3QgbnVsbCBvdXQgc2libGluZyBoZXJlLCBvdGhlcndpc2UgaXQgY2FuIGNhdXNlIGlzc3Vlc1xuICAvLyB3aXRoIGZpbmRET01Ob2RlIGFuZCBob3cgaXQgcmVxdWlyZXMgdGhlIHNpYmxpbmcgZmllbGQgdG8gY2Fycnkgb3V0XG4gIC8vIHRyYXZlcnNhbCBpbiBhIGxhdGVyIGVmZmVjdC4gU2VlIFBSICMxNjgyMC4gV2Ugbm93IGNsZWFyIHRoZSBzaWJsaW5nXG4gIC8vIGZpZWxkIGFmdGVyIGVmZmVjdHMsIHNlZTogZGV0YWNoRmliZXJBZnRlckVmZmVjdHMuXG4gIC8vXG4gIC8vIERvbid0IGRpc2Nvbm5lY3Qgc3RhdGVOb2RlIG5vdzsgaXQgd2lsbCBiZSBkZXRhY2hlZCBpbiBkZXRhY2hGaWJlckFmdGVyRWZmZWN0cy5cbiAgLy8gSXQgbWF5IGJlIHJlcXVpcmVkIGlmIHRoZSBjdXJyZW50IGNvbXBvbmVudCBpcyBhbiBlcnJvciBib3VuZGFyeSxcbiAgLy8gYW5kIG9uZSBvZiBpdHMgZGVzY2VuZGFudHMgdGhyb3dzIHdoaWxlIHVubW91bnRpbmcgYSBwYXNzaXZlIGVmZmVjdC5cbiAgZmliZXIuYWx0ZXJuYXRlID0gbnVsbDtcbiAgZmliZXIuY2hpbGQgPSBudWxsO1xuICBmaWJlci5kZXBlbmRlbmNpZXMgPSBudWxsO1xuICBmaWJlci5maXJzdEVmZmVjdCA9IG51bGw7XG4gIGZpYmVyLmxhc3RFZmZlY3QgPSBudWxsO1xuICBmaWJlci5tZW1vaXplZFByb3BzID0gbnVsbDtcbiAgZmliZXIubWVtb2l6ZWRTdGF0ZSA9IG51bGw7XG4gIGZpYmVyLnBlbmRpbmdQcm9wcyA9IG51bGw7XG4gIGZpYmVyLnJldHVybiA9IG51bGw7XG4gIGZpYmVyLnVwZGF0ZVF1ZXVlID0gbnVsbDtcblxuICB7XG4gICAgZmliZXIuX2RlYnVnT3duZXIgPSBudWxsO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldEhvc3RQYXJlbnRGaWJlcihmaWJlcikge1xuICB2YXIgcGFyZW50ID0gZmliZXIucmV0dXJuO1xuXG4gIHdoaWxlIChwYXJlbnQgIT09IG51bGwpIHtcbiAgICBpZiAoaXNIb3N0UGFyZW50KHBhcmVudCkpIHtcbiAgICAgIHJldHVybiBwYXJlbnQ7XG4gICAgfVxuXG4gICAgcGFyZW50ID0gcGFyZW50LnJldHVybjtcbiAgfVxuXG4gIHtcbiAgICB7XG4gICAgICB0aHJvdyBFcnJvciggXCJFeHBlY3RlZCB0byBmaW5kIGEgaG9zdCBwYXJlbnQuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCIgKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNIb3N0UGFyZW50KGZpYmVyKSB7XG4gIHJldHVybiBmaWJlci50YWcgPT09IEhvc3RDb21wb25lbnQgfHwgZmliZXIudGFnID09PSBIb3N0Um9vdCB8fCBmaWJlci50YWcgPT09IEhvc3RQb3J0YWw7XG59XG5cbmZ1bmN0aW9uIGdldEhvc3RTaWJsaW5nKGZpYmVyKSB7XG4gIC8vIFdlJ3JlIGdvaW5nIHRvIHNlYXJjaCBmb3J3YXJkIGludG8gdGhlIHRyZWUgdW50aWwgd2UgZmluZCBhIHNpYmxpbmcgaG9zdFxuICAvLyBub2RlLiBVbmZvcnR1bmF0ZWx5LCBpZiBtdWx0aXBsZSBpbnNlcnRpb25zIGFyZSBkb25lIGluIGEgcm93IHdlIGhhdmUgdG9cbiAgLy8gc2VhcmNoIHBhc3QgdGhlbS4gVGhpcyBsZWFkcyB0byBleHBvbmVudGlhbCBzZWFyY2ggZm9yIHRoZSBuZXh0IHNpYmxpbmcuXG4gIC8vIFRPRE86IEZpbmQgYSBtb3JlIGVmZmljaWVudCB3YXkgdG8gZG8gdGhpcy5cbiAgdmFyIG5vZGUgPSBmaWJlcjtcblxuICBzaWJsaW5nczogd2hpbGUgKHRydWUpIHtcbiAgICAvLyBJZiB3ZSBkaWRuJ3QgZmluZCBhbnl0aGluZywgbGV0J3MgdHJ5IHRoZSBuZXh0IHNpYmxpbmcuXG4gICAgd2hpbGUgKG5vZGUuc2libGluZyA9PT0gbnVsbCkge1xuICAgICAgaWYgKG5vZGUucmV0dXJuID09PSBudWxsIHx8IGlzSG9zdFBhcmVudChub2RlLnJldHVybikpIHtcbiAgICAgICAgLy8gSWYgd2UgcG9wIG91dCBvZiB0aGUgcm9vdCBvciBoaXQgdGhlIHBhcmVudCB0aGUgZmliZXIgd2UgYXJlIHRoZVxuICAgICAgICAvLyBsYXN0IHNpYmxpbmcuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICBub2RlID0gbm9kZS5yZXR1cm47XG4gICAgfVxuXG4gICAgbm9kZS5zaWJsaW5nLnJldHVybiA9IG5vZGUucmV0dXJuO1xuICAgIG5vZGUgPSBub2RlLnNpYmxpbmc7XG5cbiAgICB3aGlsZSAobm9kZS50YWcgIT09IEhvc3RDb21wb25lbnQgJiYgbm9kZS50YWcgIT09IEhvc3RUZXh0ICYmIG5vZGUudGFnICE9PSBEZWh5ZHJhdGVkRnJhZ21lbnQpIHtcbiAgICAgIC8vIElmIGl0IGlzIG5vdCBob3N0IG5vZGUgYW5kLCB3ZSBtaWdodCBoYXZlIGEgaG9zdCBub2RlIGluc2lkZSBpdC5cbiAgICAgIC8vIFRyeSB0byBzZWFyY2ggZG93biB1bnRpbCB3ZSBmaW5kIG9uZS5cbiAgICAgIGlmIChub2RlLmZsYWdzICYgUGxhY2VtZW50KSB7XG4gICAgICAgIC8vIElmIHdlIGRvbid0IGhhdmUgYSBjaGlsZCwgdHJ5IHRoZSBzaWJsaW5ncyBpbnN0ZWFkLlxuICAgICAgICBjb250aW51ZSBzaWJsaW5ncztcbiAgICAgIH0gLy8gSWYgd2UgZG9uJ3QgaGF2ZSBhIGNoaWxkLCB0cnkgdGhlIHNpYmxpbmdzIGluc3RlYWQuXG4gICAgICAvLyBXZSBhbHNvIHNraXAgcG9ydGFscyBiZWNhdXNlIHRoZXkgYXJlIG5vdCBwYXJ0IG9mIHRoaXMgaG9zdCB0cmVlLlxuXG5cbiAgICAgIGlmIChub2RlLmNoaWxkID09PSBudWxsIHx8IG5vZGUudGFnID09PSBIb3N0UG9ydGFsKSB7XG4gICAgICAgIGNvbnRpbnVlIHNpYmxpbmdzO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbm9kZS5jaGlsZC5yZXR1cm4gPSBub2RlO1xuICAgICAgICBub2RlID0gbm9kZS5jaGlsZDtcbiAgICAgIH1cbiAgICB9IC8vIENoZWNrIGlmIHRoaXMgaG9zdCBub2RlIGlzIHN0YWJsZSBvciBhYm91dCB0byBiZSBwbGFjZWQuXG5cblxuICAgIGlmICghKG5vZGUuZmxhZ3MgJiBQbGFjZW1lbnQpKSB7XG4gICAgICAvLyBGb3VuZCBpdCFcbiAgICAgIHJldHVybiBub2RlLnN0YXRlTm9kZTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY29tbWl0UGxhY2VtZW50KGZpbmlzaGVkV29yaykge1xuXG5cbiAgdmFyIHBhcmVudEZpYmVyID0gZ2V0SG9zdFBhcmVudEZpYmVyKGZpbmlzaGVkV29yayk7IC8vIE5vdGU6IHRoZXNlIHR3byB2YXJpYWJsZXMgKm11c3QqIGFsd2F5cyBiZSB1cGRhdGVkIHRvZ2V0aGVyLlxuXG4gIHZhciBwYXJlbnQ7XG4gIHZhciBpc0NvbnRhaW5lcjtcbiAgdmFyIHBhcmVudFN0YXRlTm9kZSA9IHBhcmVudEZpYmVyLnN0YXRlTm9kZTtcblxuICBzd2l0Y2ggKHBhcmVudEZpYmVyLnRhZykge1xuICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICAgIHBhcmVudCA9IHBhcmVudFN0YXRlTm9kZTtcbiAgICAgIGlzQ29udGFpbmVyID0gZmFsc2U7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgSG9zdFJvb3Q6XG4gICAgICBwYXJlbnQgPSBwYXJlbnRTdGF0ZU5vZGUuY29udGFpbmVySW5mbztcbiAgICAgIGlzQ29udGFpbmVyID0gdHJ1ZTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBIb3N0UG9ydGFsOlxuICAgICAgcGFyZW50ID0gcGFyZW50U3RhdGVOb2RlLmNvbnRhaW5lckluZm87XG4gICAgICBpc0NvbnRhaW5lciA9IHRydWU7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgRnVuZGFtZW50YWxDb21wb25lbnQ6XG5cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUtbm8tZmFsbHRocm91Z2hcblxuICAgIGRlZmF1bHQ6XG4gICAgICB7XG4gICAgICAgIHtcbiAgICAgICAgICB0aHJvdyBFcnJvciggXCJJbnZhbGlkIGhvc3QgcGFyZW50IGZpYmVyLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiICk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICB9XG5cbiAgaWYgKHBhcmVudEZpYmVyLmZsYWdzICYgQ29udGVudFJlc2V0KSB7XG4gICAgLy8gUmVzZXQgdGhlIHRleHQgY29udGVudCBvZiB0aGUgcGFyZW50IGJlZm9yZSBkb2luZyBhbnkgaW5zZXJ0aW9uc1xuICAgIHJlc2V0VGV4dENvbnRlbnQocGFyZW50KTsgLy8gQ2xlYXIgQ29udGVudFJlc2V0IGZyb20gdGhlIGVmZmVjdCB0YWdcblxuICAgIHBhcmVudEZpYmVyLmZsYWdzICY9IH5Db250ZW50UmVzZXQ7XG4gIH1cblxuICB2YXIgYmVmb3JlID0gZ2V0SG9zdFNpYmxpbmcoZmluaXNoZWRXb3JrKTsgLy8gV2Ugb25seSBoYXZlIHRoZSB0b3AgRmliZXIgdGhhdCB3YXMgaW5zZXJ0ZWQgYnV0IHdlIG5lZWQgdG8gcmVjdXJzZSBkb3duIGl0c1xuICAvLyBjaGlsZHJlbiB0byBmaW5kIGFsbCB0aGUgdGVybWluYWwgbm9kZXMuXG5cbiAgaWYgKGlzQ29udGFpbmVyKSB7XG4gICAgaW5zZXJ0T3JBcHBlbmRQbGFjZW1lbnROb2RlSW50b0NvbnRhaW5lcihmaW5pc2hlZFdvcmssIGJlZm9yZSwgcGFyZW50KTtcbiAgfSBlbHNlIHtcbiAgICBpbnNlcnRPckFwcGVuZFBsYWNlbWVudE5vZGUoZmluaXNoZWRXb3JrLCBiZWZvcmUsIHBhcmVudCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW5zZXJ0T3JBcHBlbmRQbGFjZW1lbnROb2RlSW50b0NvbnRhaW5lcihub2RlLCBiZWZvcmUsIHBhcmVudCkge1xuICB2YXIgdGFnID0gbm9kZS50YWc7XG4gIHZhciBpc0hvc3QgPSB0YWcgPT09IEhvc3RDb21wb25lbnQgfHwgdGFnID09PSBIb3N0VGV4dDtcblxuICBpZiAoaXNIb3N0IHx8IGVuYWJsZUZ1bmRhbWVudGFsQVBJICkge1xuICAgIHZhciBzdGF0ZU5vZGUgPSBpc0hvc3QgPyBub2RlLnN0YXRlTm9kZSA6IG5vZGUuc3RhdGVOb2RlLmluc3RhbmNlO1xuXG4gICAgaWYgKGJlZm9yZSkge1xuICAgICAgaW5zZXJ0SW5Db250YWluZXJCZWZvcmUocGFyZW50LCBzdGF0ZU5vZGUsIGJlZm9yZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFwcGVuZENoaWxkVG9Db250YWluZXIocGFyZW50LCBzdGF0ZU5vZGUpO1xuICAgIH1cbiAgfSBlbHNlIGlmICh0YWcgPT09IEhvc3RQb3J0YWwpIDsgZWxzZSB7XG4gICAgdmFyIGNoaWxkID0gbm9kZS5jaGlsZDtcblxuICAgIGlmIChjaGlsZCAhPT0gbnVsbCkge1xuICAgICAgaW5zZXJ0T3JBcHBlbmRQbGFjZW1lbnROb2RlSW50b0NvbnRhaW5lcihjaGlsZCwgYmVmb3JlLCBwYXJlbnQpO1xuICAgICAgdmFyIHNpYmxpbmcgPSBjaGlsZC5zaWJsaW5nO1xuXG4gICAgICB3aGlsZSAoc2libGluZyAhPT0gbnVsbCkge1xuICAgICAgICBpbnNlcnRPckFwcGVuZFBsYWNlbWVudE5vZGVJbnRvQ29udGFpbmVyKHNpYmxpbmcsIGJlZm9yZSwgcGFyZW50KTtcbiAgICAgICAgc2libGluZyA9IHNpYmxpbmcuc2libGluZztcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gaW5zZXJ0T3JBcHBlbmRQbGFjZW1lbnROb2RlKG5vZGUsIGJlZm9yZSwgcGFyZW50KSB7XG4gIHZhciB0YWcgPSBub2RlLnRhZztcbiAgdmFyIGlzSG9zdCA9IHRhZyA9PT0gSG9zdENvbXBvbmVudCB8fCB0YWcgPT09IEhvc3RUZXh0O1xuXG4gIGlmIChpc0hvc3QgfHwgZW5hYmxlRnVuZGFtZW50YWxBUEkgKSB7XG4gICAgdmFyIHN0YXRlTm9kZSA9IGlzSG9zdCA/IG5vZGUuc3RhdGVOb2RlIDogbm9kZS5zdGF0ZU5vZGUuaW5zdGFuY2U7XG5cbiAgICBpZiAoYmVmb3JlKSB7XG4gICAgICBpbnNlcnRCZWZvcmUocGFyZW50LCBzdGF0ZU5vZGUsIGJlZm9yZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFwcGVuZENoaWxkKHBhcmVudCwgc3RhdGVOb2RlKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAodGFnID09PSBIb3N0UG9ydGFsKSA7IGVsc2Uge1xuICAgIHZhciBjaGlsZCA9IG5vZGUuY2hpbGQ7XG5cbiAgICBpZiAoY2hpbGQgIT09IG51bGwpIHtcbiAgICAgIGluc2VydE9yQXBwZW5kUGxhY2VtZW50Tm9kZShjaGlsZCwgYmVmb3JlLCBwYXJlbnQpO1xuICAgICAgdmFyIHNpYmxpbmcgPSBjaGlsZC5zaWJsaW5nO1xuXG4gICAgICB3aGlsZSAoc2libGluZyAhPT0gbnVsbCkge1xuICAgICAgICBpbnNlcnRPckFwcGVuZFBsYWNlbWVudE5vZGUoc2libGluZywgYmVmb3JlLCBwYXJlbnQpO1xuICAgICAgICBzaWJsaW5nID0gc2libGluZy5zaWJsaW5nO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiB1bm1vdW50SG9zdENvbXBvbmVudHMoZmluaXNoZWRSb290LCBjdXJyZW50LCByZW5kZXJQcmlvcml0eUxldmVsKSB7XG4gIC8vIFdlIG9ubHkgaGF2ZSB0aGUgdG9wIEZpYmVyIHRoYXQgd2FzIGRlbGV0ZWQgYnV0IHdlIG5lZWQgdG8gcmVjdXJzZSBkb3duIGl0c1xuICAvLyBjaGlsZHJlbiB0byBmaW5kIGFsbCB0aGUgdGVybWluYWwgbm9kZXMuXG4gIHZhciBub2RlID0gY3VycmVudDsgLy8gRWFjaCBpdGVyYXRpb24sIGN1cnJlbnRQYXJlbnQgaXMgcG9wdWxhdGVkIHdpdGggbm9kZSdzIGhvc3QgcGFyZW50IGlmIG5vdFxuICAvLyBjdXJyZW50UGFyZW50SXNWYWxpZC5cblxuICB2YXIgY3VycmVudFBhcmVudElzVmFsaWQgPSBmYWxzZTsgLy8gTm90ZTogdGhlc2UgdHdvIHZhcmlhYmxlcyAqbXVzdCogYWx3YXlzIGJlIHVwZGF0ZWQgdG9nZXRoZXIuXG5cbiAgdmFyIGN1cnJlbnRQYXJlbnQ7XG4gIHZhciBjdXJyZW50UGFyZW50SXNDb250YWluZXI7XG5cbiAgd2hpbGUgKHRydWUpIHtcbiAgICBpZiAoIWN1cnJlbnRQYXJlbnRJc1ZhbGlkKSB7XG4gICAgICB2YXIgcGFyZW50ID0gbm9kZS5yZXR1cm47XG5cbiAgICAgIGZpbmRQYXJlbnQ6IHdoaWxlICh0cnVlKSB7XG4gICAgICAgIGlmICghKHBhcmVudCAhPT0gbnVsbCkpIHtcbiAgICAgICAgICB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvciggXCJFeHBlY3RlZCB0byBmaW5kIGEgaG9zdCBwYXJlbnQuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCIgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcGFyZW50U3RhdGVOb2RlID0gcGFyZW50LnN0YXRlTm9kZTtcblxuICAgICAgICBzd2l0Y2ggKHBhcmVudC50YWcpIHtcbiAgICAgICAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICAgICAgICBjdXJyZW50UGFyZW50ID0gcGFyZW50U3RhdGVOb2RlO1xuICAgICAgICAgICAgY3VycmVudFBhcmVudElzQ29udGFpbmVyID0gZmFsc2U7XG4gICAgICAgICAgICBicmVhayBmaW5kUGFyZW50O1xuXG4gICAgICAgICAgY2FzZSBIb3N0Um9vdDpcbiAgICAgICAgICAgIGN1cnJlbnRQYXJlbnQgPSBwYXJlbnRTdGF0ZU5vZGUuY29udGFpbmVySW5mbztcbiAgICAgICAgICAgIGN1cnJlbnRQYXJlbnRJc0NvbnRhaW5lciA9IHRydWU7XG4gICAgICAgICAgICBicmVhayBmaW5kUGFyZW50O1xuXG4gICAgICAgICAgY2FzZSBIb3N0UG9ydGFsOlxuICAgICAgICAgICAgY3VycmVudFBhcmVudCA9IHBhcmVudFN0YXRlTm9kZS5jb250YWluZXJJbmZvO1xuICAgICAgICAgICAgY3VycmVudFBhcmVudElzQ29udGFpbmVyID0gdHJ1ZTtcbiAgICAgICAgICAgIGJyZWFrIGZpbmRQYXJlbnQ7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHBhcmVudCA9IHBhcmVudC5yZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGN1cnJlbnRQYXJlbnRJc1ZhbGlkID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAobm9kZS50YWcgPT09IEhvc3RDb21wb25lbnQgfHwgbm9kZS50YWcgPT09IEhvc3RUZXh0KSB7XG4gICAgICBjb21taXROZXN0ZWRVbm1vdW50cyhmaW5pc2hlZFJvb3QsIG5vZGUpOyAvLyBBZnRlciBhbGwgdGhlIGNoaWxkcmVuIGhhdmUgdW5tb3VudGVkLCBpdCBpcyBub3cgc2FmZSB0byByZW1vdmUgdGhlXG4gICAgICAvLyBub2RlIGZyb20gdGhlIHRyZWUuXG5cbiAgICAgIGlmIChjdXJyZW50UGFyZW50SXNDb250YWluZXIpIHtcbiAgICAgICAgcmVtb3ZlQ2hpbGRGcm9tQ29udGFpbmVyKGN1cnJlbnRQYXJlbnQsIG5vZGUuc3RhdGVOb2RlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlbW92ZUNoaWxkKGN1cnJlbnRQYXJlbnQsIG5vZGUuc3RhdGVOb2RlKTtcbiAgICAgIH0gLy8gRG9uJ3QgdmlzaXQgY2hpbGRyZW4gYmVjYXVzZSB3ZSBhbHJlYWR5IHZpc2l0ZWQgdGhlbS5cblxuICAgIH0gZWxzZSBpZiAobm9kZS50YWcgPT09IEhvc3RQb3J0YWwpIHtcbiAgICAgIGlmIChub2RlLmNoaWxkICE9PSBudWxsKSB7XG4gICAgICAgIC8vIFdoZW4gd2UgZ28gaW50byBhIHBvcnRhbCwgaXQgYmVjb21lcyB0aGUgcGFyZW50IHRvIHJlbW92ZSBmcm9tLlxuICAgICAgICAvLyBXZSB3aWxsIHJlYXNzaWduIGl0IGJhY2sgd2hlbiB3ZSBwb3AgdGhlIHBvcnRhbCBvbiB0aGUgd2F5IHVwLlxuICAgICAgICBjdXJyZW50UGFyZW50ID0gbm9kZS5zdGF0ZU5vZGUuY29udGFpbmVySW5mbztcbiAgICAgICAgY3VycmVudFBhcmVudElzQ29udGFpbmVyID0gdHJ1ZTsgLy8gVmlzaXQgY2hpbGRyZW4gYmVjYXVzZSBwb3J0YWxzIG1pZ2h0IGNvbnRhaW4gaG9zdCBjb21wb25lbnRzLlxuXG4gICAgICAgIG5vZGUuY2hpbGQucmV0dXJuID0gbm9kZTtcbiAgICAgICAgbm9kZSA9IG5vZGUuY2hpbGQ7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb21taXRVbm1vdW50KGZpbmlzaGVkUm9vdCwgbm9kZSk7IC8vIFZpc2l0IGNoaWxkcmVuIGJlY2F1c2Ugd2UgbWF5IGZpbmQgbW9yZSBob3N0IGNvbXBvbmVudHMgYmVsb3cuXG5cbiAgICAgIGlmIChub2RlLmNoaWxkICE9PSBudWxsKSB7XG4gICAgICAgIG5vZGUuY2hpbGQucmV0dXJuID0gbm9kZTtcbiAgICAgICAgbm9kZSA9IG5vZGUuY2hpbGQ7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChub2RlID09PSBjdXJyZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgd2hpbGUgKG5vZGUuc2libGluZyA9PT0gbnVsbCkge1xuICAgICAgaWYgKG5vZGUucmV0dXJuID09PSBudWxsIHx8IG5vZGUucmV0dXJuID09PSBjdXJyZW50KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgbm9kZSA9IG5vZGUucmV0dXJuO1xuXG4gICAgICBpZiAobm9kZS50YWcgPT09IEhvc3RQb3J0YWwpIHtcbiAgICAgICAgLy8gV2hlbiB3ZSBnbyBvdXQgb2YgdGhlIHBvcnRhbCwgd2UgbmVlZCB0byByZXN0b3JlIHRoZSBwYXJlbnQuXG4gICAgICAgIC8vIFNpbmNlIHdlIGRvbid0IGtlZXAgYSBzdGFjayBvZiB0aGVtLCB3ZSB3aWxsIHNlYXJjaCBmb3IgaXQuXG4gICAgICAgIGN1cnJlbnRQYXJlbnRJc1ZhbGlkID0gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgbm9kZS5zaWJsaW5nLnJldHVybiA9IG5vZGUucmV0dXJuO1xuICAgIG5vZGUgPSBub2RlLnNpYmxpbmc7XG4gIH1cbn1cblxuZnVuY3Rpb24gY29tbWl0RGVsZXRpb24oZmluaXNoZWRSb290LCBjdXJyZW50LCByZW5kZXJQcmlvcml0eUxldmVsKSB7XG4gIHtcbiAgICAvLyBSZWN1cnNpdmVseSBkZWxldGUgYWxsIGhvc3Qgbm9kZXMgZnJvbSB0aGUgcGFyZW50LlxuICAgIC8vIERldGFjaCByZWZzIGFuZCBjYWxsIGNvbXBvbmVudFdpbGxVbm1vdW50KCkgb24gdGhlIHdob2xlIHN1YnRyZWUuXG4gICAgdW5tb3VudEhvc3RDb21wb25lbnRzKGZpbmlzaGVkUm9vdCwgY3VycmVudCk7XG4gIH1cblxuICB2YXIgYWx0ZXJuYXRlID0gY3VycmVudC5hbHRlcm5hdGU7XG4gIGRldGFjaEZpYmVyTXV0YXRpb24oY3VycmVudCk7XG5cbiAgaWYgKGFsdGVybmF0ZSAhPT0gbnVsbCkge1xuICAgIGRldGFjaEZpYmVyTXV0YXRpb24oYWx0ZXJuYXRlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjb21taXRXb3JrKGN1cnJlbnQsIGZpbmlzaGVkV29yaykge1xuXG4gIHN3aXRjaCAoZmluaXNoZWRXb3JrLnRhZykge1xuICAgIGNhc2UgRnVuY3Rpb25Db21wb25lbnQ6XG4gICAgY2FzZSBGb3J3YXJkUmVmOlxuICAgIGNhc2UgTWVtb0NvbXBvbmVudDpcbiAgICBjYXNlIFNpbXBsZU1lbW9Db21wb25lbnQ6XG4gICAgY2FzZSBCbG9jazpcbiAgICAgIHtcbiAgICAgICAgLy8gTGF5b3V0IGVmZmVjdHMgYXJlIGRlc3Ryb3llZCBkdXJpbmcgdGhlIG11dGF0aW9uIHBoYXNlIHNvIHRoYXQgYWxsXG4gICAgICAgIC8vIGRlc3Ryb3kgZnVuY3Rpb25zIGZvciBhbGwgZmliZXJzIGFyZSBjYWxsZWQgYmVmb3JlIGFueSBjcmVhdGUgZnVuY3Rpb25zLlxuICAgICAgICAvLyBUaGlzIHByZXZlbnRzIHNpYmxpbmcgY29tcG9uZW50IGVmZmVjdHMgZnJvbSBpbnRlcmZlcmluZyB3aXRoIGVhY2ggb3RoZXIsXG4gICAgICAgIC8vIGUuZy4gYSBkZXN0cm95IGZ1bmN0aW9uIGluIG9uZSBjb21wb25lbnQgc2hvdWxkIG5ldmVyIG92ZXJyaWRlIGEgcmVmIHNldFxuICAgICAgICAvLyBieSBhIGNyZWF0ZSBmdW5jdGlvbiBpbiBhbm90aGVyIGNvbXBvbmVudCBkdXJpbmcgdGhlIHNhbWUgY29tbWl0LlxuICAgICAgICB7XG4gICAgICAgICAgY29tbWl0SG9va0VmZmVjdExpc3RVbm1vdW50KExheW91dCB8IEhhc0VmZmVjdCwgZmluaXNoZWRXb3JrKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgIGNhc2UgQ2xhc3NDb21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICAgIHtcbiAgICAgICAgdmFyIGluc3RhbmNlID0gZmluaXNoZWRXb3JrLnN0YXRlTm9kZTtcblxuICAgICAgICBpZiAoaW5zdGFuY2UgIT0gbnVsbCkge1xuICAgICAgICAgIC8vIENvbW1pdCB0aGUgd29yayBwcmVwYXJlZCBlYXJsaWVyLlxuICAgICAgICAgIHZhciBuZXdQcm9wcyA9IGZpbmlzaGVkV29yay5tZW1vaXplZFByb3BzOyAvLyBGb3IgaHlkcmF0aW9uIHdlIHJldXNlIHRoZSB1cGRhdGUgcGF0aCBidXQgd2UgdHJlYXQgdGhlIG9sZFByb3BzXG4gICAgICAgICAgLy8gYXMgdGhlIG5ld1Byb3BzLiBUaGUgdXBkYXRlUGF5bG9hZCB3aWxsIGNvbnRhaW4gdGhlIHJlYWwgY2hhbmdlIGluXG4gICAgICAgICAgLy8gdGhpcyBjYXNlLlxuXG4gICAgICAgICAgdmFyIG9sZFByb3BzID0gY3VycmVudCAhPT0gbnVsbCA/IGN1cnJlbnQubWVtb2l6ZWRQcm9wcyA6IG5ld1Byb3BzO1xuICAgICAgICAgIHZhciB0eXBlID0gZmluaXNoZWRXb3JrLnR5cGU7IC8vIFRPRE86IFR5cGUgdGhlIHVwZGF0ZVF1ZXVlIHRvIGJlIHNwZWNpZmljIHRvIGhvc3QgY29tcG9uZW50cy5cblxuICAgICAgICAgIHZhciB1cGRhdGVQYXlsb2FkID0gZmluaXNoZWRXb3JrLnVwZGF0ZVF1ZXVlO1xuICAgICAgICAgIGZpbmlzaGVkV29yay51cGRhdGVRdWV1ZSA9IG51bGw7XG5cbiAgICAgICAgICBpZiAodXBkYXRlUGF5bG9hZCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgY29tbWl0VXBkYXRlKGluc3RhbmNlLCB1cGRhdGVQYXlsb2FkLCB0eXBlLCBvbGRQcm9wcywgbmV3UHJvcHMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgIGNhc2UgSG9zdFRleHQ6XG4gICAgICB7XG4gICAgICAgIGlmICghKGZpbmlzaGVkV29yay5zdGF0ZU5vZGUgIT09IG51bGwpKSB7XG4gICAgICAgICAge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoIFwiVGhpcyBzaG91bGQgaGF2ZSBhIHRleHQgbm9kZSBpbml0aWFsaXplZC4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS5cIiApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB0ZXh0SW5zdGFuY2UgPSBmaW5pc2hlZFdvcmsuc3RhdGVOb2RlO1xuICAgICAgICB2YXIgbmV3VGV4dCA9IGZpbmlzaGVkV29yay5tZW1vaXplZFByb3BzOyAvLyBGb3IgaHlkcmF0aW9uIHdlIHJldXNlIHRoZSB1cGRhdGUgcGF0aCBidXQgd2UgdHJlYXQgdGhlIG9sZFByb3BzXG4gICAgICAgIC8vIGFzIHRoZSBuZXdQcm9wcy4gVGhlIHVwZGF0ZVBheWxvYWQgd2lsbCBjb250YWluIHRoZSByZWFsIGNoYW5nZSBpblxuICAgICAgICAvLyB0aGlzIGNhc2UuXG5cbiAgICAgICAgdmFyIG9sZFRleHQgPSBjdXJyZW50ICE9PSBudWxsID8gY3VycmVudC5tZW1vaXplZFByb3BzIDogbmV3VGV4dDtcbiAgICAgICAgY29tbWl0VGV4dFVwZGF0ZSh0ZXh0SW5zdGFuY2UsIG9sZFRleHQsIG5ld1RleHQpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICBjYXNlIEhvc3RSb290OlxuICAgICAge1xuICAgICAgICB7XG4gICAgICAgICAgdmFyIF9yb290ID0gZmluaXNoZWRXb3JrLnN0YXRlTm9kZTtcblxuICAgICAgICAgIGlmIChfcm9vdC5oeWRyYXRlKSB7XG4gICAgICAgICAgICAvLyBXZSd2ZSBqdXN0IGh5ZHJhdGVkLiBObyBuZWVkIHRvIGh5ZHJhdGUgYWdhaW4uXG4gICAgICAgICAgICBfcm9vdC5oeWRyYXRlID0gZmFsc2U7XG4gICAgICAgICAgICBjb21taXRIeWRyYXRlZENvbnRhaW5lcihfcm9vdC5jb250YWluZXJJbmZvKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICBjYXNlIFByb2ZpbGVyOlxuICAgICAge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICBjYXNlIFN1c3BlbnNlQ29tcG9uZW50OlxuICAgICAge1xuICAgICAgICBjb21taXRTdXNwZW5zZUNvbXBvbmVudChmaW5pc2hlZFdvcmspO1xuICAgICAgICBhdHRhY2hTdXNwZW5zZVJldHJ5TGlzdGVuZXJzKGZpbmlzaGVkV29yayk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgIGNhc2UgU3VzcGVuc2VMaXN0Q29tcG9uZW50OlxuICAgICAge1xuICAgICAgICBhdHRhY2hTdXNwZW5zZVJldHJ5TGlzdGVuZXJzKGZpbmlzaGVkV29yayk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgIGNhc2UgSW5jb21wbGV0ZUNsYXNzQ29tcG9uZW50OlxuICAgICAge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICBjYXNlIEZ1bmRhbWVudGFsQ29tcG9uZW50OlxuICAgICAge1xuXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgY2FzZSBTY29wZUNvbXBvbmVudDpcbiAgICAgIHtcblxuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgIGNhc2UgT2Zmc2NyZWVuQ29tcG9uZW50OlxuICAgIGNhc2UgTGVnYWN5SGlkZGVuQ29tcG9uZW50OlxuICAgICAge1xuICAgICAgICB2YXIgbmV3U3RhdGUgPSBmaW5pc2hlZFdvcmsubWVtb2l6ZWRTdGF0ZTtcbiAgICAgICAgdmFyIGlzSGlkZGVuID0gbmV3U3RhdGUgIT09IG51bGw7XG4gICAgICAgIGhpZGVPclVuaGlkZUFsbENoaWxkcmVuKGZpbmlzaGVkV29yaywgaXNIaWRkZW4pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gIH1cblxuICB7XG4gICAge1xuICAgICAgdGhyb3cgRXJyb3IoIFwiVGhpcyB1bml0IG9mIHdvcmsgdGFnIHNob3VsZCBub3QgaGF2ZSBzaWRlLWVmZmVjdHMuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCIgKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY29tbWl0U3VzcGVuc2VDb21wb25lbnQoZmluaXNoZWRXb3JrKSB7XG4gIHZhciBuZXdTdGF0ZSA9IGZpbmlzaGVkV29yay5tZW1vaXplZFN0YXRlO1xuXG4gIGlmIChuZXdTdGF0ZSAhPT0gbnVsbCkge1xuICAgIG1hcmtDb21taXRUaW1lT2ZGYWxsYmFjaygpO1xuXG4gICAge1xuICAgICAgLy8gSGlkZSB0aGUgT2Zmc2NyZWVuIGNvbXBvbmVudCB0aGF0IGNvbnRhaW5zIHRoZSBwcmltYXJ5IGNoaWxkcmVuLiBUT0RPOlxuICAgICAgLy8gSWRlYWxseSwgdGhpcyBlZmZlY3Qgd291bGQgaGF2ZSBiZWVuIHNjaGVkdWxlZCBvbiB0aGUgT2Zmc2NyZWVuIGZpYmVyXG4gICAgICAvLyBpdHNlbGYuIFRoYXQncyBob3cgdW5oaWRpbmcgd29ya3M6IHRoZSBPZmZzY3JlZW4gY29tcG9uZW50IHNjaGVkdWxlcyBhblxuICAgICAgLy8gZWZmZWN0IG9uIGl0c2VsZi4gSG93ZXZlciwgaW4gdGhpcyBjYXNlLCB0aGUgY29tcG9uZW50IGRpZG4ndCBjb21wbGV0ZSxcbiAgICAgIC8vIHNvIHRoZSBmaWJlciB3YXMgbmV2ZXIgYWRkZWQgdG8gdGhlIGVmZmVjdCBsaXN0IGluIHRoZSBub3JtYWwgcGF0aC4gV2VcbiAgICAgIC8vIGNvdWxkIGhhdmUgYXBwZW5kZWQgaXQgdG8gdGhlIGVmZmVjdCBsaXN0IGluIHRoZSBTdXNwZW5zZSBjb21wb25lbnQnc1xuICAgICAgLy8gc2Vjb25kIHBhc3MsIGJ1dCBkb2luZyBpdCB0aGlzIHdheSBpcyBsZXNzIGNvbXBsaWNhdGVkLiBUaGlzIHdvdWxkIGJlXG4gICAgICAvLyBzaW1wbGVyIGlmIHdlIGdvdCByaWQgb2YgdGhlIGVmZmVjdCBsaXN0IGFuZCB0cmF2ZXJzZWQgdGhlIHRyZWUsIGxpa2VcbiAgICAgIC8vIHdlJ3JlIHBsYW5uaW5nIHRvIGRvLlxuICAgICAgdmFyIHByaW1hcnlDaGlsZFBhcmVudCA9IGZpbmlzaGVkV29yay5jaGlsZDtcbiAgICAgIGhpZGVPclVuaGlkZUFsbENoaWxkcmVuKHByaW1hcnlDaGlsZFBhcmVudCwgdHJ1ZSk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNvbW1pdFN1c3BlbnNlSHlkcmF0aW9uQ2FsbGJhY2tzKGZpbmlzaGVkUm9vdCwgZmluaXNoZWRXb3JrKSB7XG5cbiAgdmFyIG5ld1N0YXRlID0gZmluaXNoZWRXb3JrLm1lbW9pemVkU3RhdGU7XG5cbiAgaWYgKG5ld1N0YXRlID09PSBudWxsKSB7XG4gICAgdmFyIGN1cnJlbnQgPSBmaW5pc2hlZFdvcmsuYWx0ZXJuYXRlO1xuXG4gICAgaWYgKGN1cnJlbnQgIT09IG51bGwpIHtcbiAgICAgIHZhciBwcmV2U3RhdGUgPSBjdXJyZW50Lm1lbW9pemVkU3RhdGU7XG5cbiAgICAgIGlmIChwcmV2U3RhdGUgIT09IG51bGwpIHtcbiAgICAgICAgdmFyIHN1c3BlbnNlSW5zdGFuY2UgPSBwcmV2U3RhdGUuZGVoeWRyYXRlZDtcblxuICAgICAgICBpZiAoc3VzcGVuc2VJbnN0YW5jZSAhPT0gbnVsbCkge1xuICAgICAgICAgIGNvbW1pdEh5ZHJhdGVkU3VzcGVuc2VJbnN0YW5jZShzdXNwZW5zZUluc3RhbmNlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBhdHRhY2hTdXNwZW5zZVJldHJ5TGlzdGVuZXJzKGZpbmlzaGVkV29yaykge1xuICAvLyBJZiB0aGlzIGJvdW5kYXJ5IGp1c3QgdGltZWQgb3V0LCB0aGVuIGl0IHdpbGwgaGF2ZSBhIHNldCBvZiB3YWtlYWJsZXMuXG4gIC8vIEZvciBlYWNoIHdha2VhYmxlLCBhdHRhY2ggYSBsaXN0ZW5lciBzbyB0aGF0IHdoZW4gaXQgcmVzb2x2ZXMsIFJlYWN0XG4gIC8vIGF0dGVtcHRzIHRvIHJlLXJlbmRlciB0aGUgYm91bmRhcnkgaW4gdGhlIHByaW1hcnkgKHByZS10aW1lb3V0KSBzdGF0ZS5cbiAgdmFyIHdha2VhYmxlcyA9IGZpbmlzaGVkV29yay51cGRhdGVRdWV1ZTtcblxuICBpZiAod2FrZWFibGVzICE9PSBudWxsKSB7XG4gICAgZmluaXNoZWRXb3JrLnVwZGF0ZVF1ZXVlID0gbnVsbDtcbiAgICB2YXIgcmV0cnlDYWNoZSA9IGZpbmlzaGVkV29yay5zdGF0ZU5vZGU7XG5cbiAgICBpZiAocmV0cnlDYWNoZSA9PT0gbnVsbCkge1xuICAgICAgcmV0cnlDYWNoZSA9IGZpbmlzaGVkV29yay5zdGF0ZU5vZGUgPSBuZXcgUG9zc2libHlXZWFrU2V0KCk7XG4gICAgfVxuXG4gICAgd2FrZWFibGVzLmZvckVhY2goZnVuY3Rpb24gKHdha2VhYmxlKSB7XG4gICAgICAvLyBNZW1vaXplIHVzaW5nIHRoZSBib3VuZGFyeSBmaWJlciB0byBwcmV2ZW50IHJlZHVuZGFudCBsaXN0ZW5lcnMuXG4gICAgICB2YXIgcmV0cnkgPSByZXNvbHZlUmV0cnlXYWtlYWJsZS5iaW5kKG51bGwsIGZpbmlzaGVkV29yaywgd2FrZWFibGUpO1xuXG4gICAgICBpZiAoIXJldHJ5Q2FjaGUuaGFzKHdha2VhYmxlKSkge1xuICAgICAgICB7XG4gICAgICAgICAgaWYgKHdha2VhYmxlLl9fcmVhY3REb05vdFRyYWNlSW50ZXJhY3Rpb25zICE9PSB0cnVlKSB7XG4gICAgICAgICAgICByZXRyeSA9IHRyYWNpbmcudW5zdGFibGVfd3JhcChyZXRyeSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0cnlDYWNoZS5hZGQod2FrZWFibGUpO1xuICAgICAgICB3YWtlYWJsZS50aGVuKHJldHJ5LCByZXRyeSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn0gLy8gVGhpcyBmdW5jdGlvbiBkZXRlY3RzIHdoZW4gYSBTdXNwZW5zZSBib3VuZGFyeSBnb2VzIGZyb20gdmlzaWJsZSB0byBoaWRkZW4uXG4vLyBJdCByZXR1cm5zIGZhbHNlIGlmIHRoZSBib3VuZGFyeSBpcyBhbHJlYWR5IGhpZGRlbi5cbi8vIFRPRE86IFVzZSBhbiBlZmZlY3QgdGFnLlxuXG5cbmZ1bmN0aW9uIGlzU3VzcGVuc2VCb3VuZGFyeUJlaW5nSGlkZGVuKGN1cnJlbnQsIGZpbmlzaGVkV29yaykge1xuICBpZiAoY3VycmVudCAhPT0gbnVsbCkge1xuICAgIHZhciBvbGRTdGF0ZSA9IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZTtcblxuICAgIGlmIChvbGRTdGF0ZSA9PT0gbnVsbCB8fCBvbGRTdGF0ZS5kZWh5ZHJhdGVkICE9PSBudWxsKSB7XG4gICAgICB2YXIgbmV3U3RhdGUgPSBmaW5pc2hlZFdvcmsubWVtb2l6ZWRTdGF0ZTtcbiAgICAgIHJldHVybiBuZXdTdGF0ZSAhPT0gbnVsbCAmJiBuZXdTdGF0ZS5kZWh5ZHJhdGVkID09PSBudWxsO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gY29tbWl0UmVzZXRUZXh0Q29udGVudChjdXJyZW50KSB7XG5cbiAgcmVzZXRUZXh0Q29udGVudChjdXJyZW50LnN0YXRlTm9kZSk7XG59XG5cbnZhciBDT01QT05FTlRfVFlQRSA9IDA7XG52YXIgSEFTX1BTRVVET19DTEFTU19UWVBFID0gMTtcbnZhciBST0xFX1RZUEUgPSAyO1xudmFyIFRFU1RfTkFNRV9UWVBFID0gMztcbnZhciBURVhUX1RZUEUgPSA0O1xuXG5pZiAodHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2wuZm9yKSB7XG4gIHZhciBzeW1ib2xGb3IkMSA9IFN5bWJvbC5mb3I7XG4gIENPTVBPTkVOVF9UWVBFID0gc3ltYm9sRm9yJDEoJ3NlbGVjdG9yLmNvbXBvbmVudCcpO1xuICBIQVNfUFNFVURPX0NMQVNTX1RZUEUgPSBzeW1ib2xGb3IkMSgnc2VsZWN0b3IuaGFzX3BzZXVkb19jbGFzcycpO1xuICBST0xFX1RZUEUgPSBzeW1ib2xGb3IkMSgnc2VsZWN0b3Iucm9sZScpO1xuICBURVNUX05BTUVfVFlQRSA9IHN5bWJvbEZvciQxKCdzZWxlY3Rvci50ZXN0X2lkJyk7XG4gIFRFWFRfVFlQRSA9IHN5bWJvbEZvciQxKCdzZWxlY3Rvci50ZXh0Jyk7XG59XG52YXIgY29tbWl0SG9va3MgPSBbXTtcbmZ1bmN0aW9uIG9uQ29tbWl0Um9vdCQxKCkge1xuICB7XG4gICAgY29tbWl0SG9va3MuZm9yRWFjaChmdW5jdGlvbiAoY29tbWl0SG9vaykge1xuICAgICAgcmV0dXJuIGNvbW1pdEhvb2soKTtcbiAgICB9KTtcbiAgfVxufVxuXG52YXIgY2VpbCA9IE1hdGguY2VpbDtcbnZhciBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDIgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdEN1cnJlbnREaXNwYXRjaGVyLFxuICAgIFJlYWN0Q3VycmVudE93bmVyJDIgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdEN1cnJlbnRPd25lcixcbiAgICBJc1NvbWVSZW5kZXJlckFjdGluZyA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLklzU29tZVJlbmRlcmVyQWN0aW5nO1xudmFyIE5vQ29udGV4dCA9XG4vKiAgICAgICAgICAgICAqL1xuMDtcbnZhciBCYXRjaGVkQ29udGV4dCA9XG4vKiAgICAgICAgICAgICAgICovXG4xO1xudmFyIEV2ZW50Q29udGV4dCA9XG4vKiAgICAgICAgICAgICAgICAgKi9cbjI7XG52YXIgRGlzY3JldGVFdmVudENvbnRleHQgPVxuLyogICAgICAgICAqL1xuNDtcbnZhciBMZWdhY3lVbmJhdGNoZWRDb250ZXh0ID1cbi8qICAgICAgICovXG44O1xudmFyIFJlbmRlckNvbnRleHQgPVxuLyogICAgICAgICAgICAgICAgKi9cbjE2O1xudmFyIENvbW1pdENvbnRleHQgPVxuLyogICAgICAgICAgICAgICAgKi9cbjMyO1xudmFyIFJldHJ5QWZ0ZXJFcnJvciA9XG4vKiAgICAgICAqL1xuNjQ7XG52YXIgUm9vdEluY29tcGxldGUgPSAwO1xudmFyIFJvb3RGYXRhbEVycm9yZWQgPSAxO1xudmFyIFJvb3RFcnJvcmVkID0gMjtcbnZhciBSb290U3VzcGVuZGVkID0gMztcbnZhciBSb290U3VzcGVuZGVkV2l0aERlbGF5ID0gNDtcbnZhciBSb290Q29tcGxldGVkID0gNTsgLy8gRGVzY3JpYmVzIHdoZXJlIHdlIGFyZSBpbiB0aGUgUmVhY3QgZXhlY3V0aW9uIHN0YWNrXG5cbnZhciBleGVjdXRpb25Db250ZXh0ID0gTm9Db250ZXh0OyAvLyBUaGUgcm9vdCB3ZSdyZSB3b3JraW5nIG9uXG5cbnZhciB3b3JrSW5Qcm9ncmVzc1Jvb3QgPSBudWxsOyAvLyBUaGUgZmliZXIgd2UncmUgd29ya2luZyBvblxuXG52YXIgd29ya0luUHJvZ3Jlc3MgPSBudWxsOyAvLyBUaGUgbGFuZXMgd2UncmUgcmVuZGVyaW5nXG5cbnZhciB3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcyA9IE5vTGFuZXM7IC8vIFN0YWNrIHRoYXQgYWxsb3dzIGNvbXBvbmVudHMgdG8gY2hhbmdlIHRoZSByZW5kZXIgbGFuZXMgZm9yIGl0cyBzdWJ0cmVlXG4vLyBUaGlzIGlzIGEgc3VwZXJzZXQgb2YgdGhlIGxhbmVzIHdlIHN0YXJ0ZWQgd29ya2luZyBvbiBhdCB0aGUgcm9vdC4gVGhlIG9ubHlcbi8vIGNhc2Ugd2hlcmUgaXQncyBkaWZmZXJlbnQgZnJvbSBgd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXNgIGlzIHdoZW4gd2Vcbi8vIGVudGVyIGEgc3VidHJlZSB0aGF0IGlzIGhpZGRlbiBhbmQgbmVlZHMgdG8gYmUgdW5oaWRkZW46IFN1c3BlbnNlIGFuZFxuLy8gT2Zmc2NyZWVuIGNvbXBvbmVudC5cbi8vXG4vLyBNb3N0IHRoaW5ncyBpbiB0aGUgd29yayBsb29wIHNob3VsZCBkZWFsIHdpdGggd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMuXG4vLyBNb3N0IHRoaW5ncyBpbiBiZWdpbi9jb21wbGV0ZSBwaGFzZXMgc2hvdWxkIGRlYWwgd2l0aCBzdWJ0cmVlUmVuZGVyTGFuZXMuXG5cbnZhciBzdWJ0cmVlUmVuZGVyTGFuZXMgPSBOb0xhbmVzO1xudmFyIHN1YnRyZWVSZW5kZXJMYW5lc0N1cnNvciA9IGNyZWF0ZUN1cnNvcihOb0xhbmVzKTsgLy8gV2hldGhlciB0byByb290IGNvbXBsZXRlZCwgZXJyb3JlZCwgc3VzcGVuZGVkLCBldGMuXG5cbnZhciB3b3JrSW5Qcm9ncmVzc1Jvb3RFeGl0U3RhdHVzID0gUm9vdEluY29tcGxldGU7IC8vIEEgZmF0YWwgZXJyb3IsIGlmIG9uZSBpcyB0aHJvd25cblxudmFyIHdvcmtJblByb2dyZXNzUm9vdEZhdGFsRXJyb3IgPSBudWxsOyAvLyBcIkluY2x1ZGVkXCIgbGFuZXMgcmVmZXIgdG8gbGFuZXMgdGhhdCB3ZXJlIHdvcmtlZCBvbiBkdXJpbmcgdGhpcyByZW5kZXIuIEl0J3Ncbi8vIHNsaWdodGx5IGRpZmZlcmVudCB0aGFuIGByZW5kZXJMYW5lc2AgYmVjYXVzZSBgcmVuZGVyTGFuZXNgIGNhbiBjaGFuZ2UgYXMgeW91XG4vLyBlbnRlciBhbmQgZXhpdCBhbiBPZmZzY3JlZW4gdHJlZS4gVGhpcyB2YWx1ZSBpcyB0aGUgY29tYmluYXRpb24gb2YgYWxsIHJlbmRlclxuLy8gbGFuZXMgZm9yIHRoZSBlbnRpcmUgcmVuZGVyIHBoYXNlLlxuXG52YXIgd29ya0luUHJvZ3Jlc3NSb290SW5jbHVkZWRMYW5lcyA9IE5vTGFuZXM7IC8vIFRoZSB3b3JrIGxlZnQgb3ZlciBieSBjb21wb25lbnRzIHRoYXQgd2VyZSB2aXNpdGVkIGR1cmluZyB0aGlzIHJlbmRlci4gT25seVxuLy8gaW5jbHVkZXMgdW5wcm9jZXNzZWQgdXBkYXRlcywgbm90IHdvcmsgaW4gYmFpbGVkIG91dCBjaGlsZHJlbi5cblxudmFyIHdvcmtJblByb2dyZXNzUm9vdFNraXBwZWRMYW5lcyA9IE5vTGFuZXM7IC8vIExhbmVzIHRoYXQgd2VyZSB1cGRhdGVkIChpbiBhbiBpbnRlcmxlYXZlZCBldmVudCkgZHVyaW5nIHRoaXMgcmVuZGVyLlxuXG52YXIgd29ya0luUHJvZ3Jlc3NSb290VXBkYXRlZExhbmVzID0gTm9MYW5lczsgLy8gTGFuZXMgdGhhdCB3ZXJlIHBpbmdlZCAoaW4gYW4gaW50ZXJsZWF2ZWQgZXZlbnQpIGR1cmluZyB0aGlzIHJlbmRlci5cblxudmFyIHdvcmtJblByb2dyZXNzUm9vdFBpbmdlZExhbmVzID0gTm9MYW5lcztcbnZhciBtb3N0UmVjZW50bHlVcGRhdGVkUm9vdCA9IG51bGw7IC8vIFRoZSBtb3N0IHJlY2VudCB0aW1lIHdlIGNvbW1pdHRlZCBhIGZhbGxiYWNrLiBUaGlzIGxldHMgdXMgZW5zdXJlIGEgdHJhaW5cbi8vIG1vZGVsIHdoZXJlIHdlIGRvbid0IGNvbW1pdCBuZXcgbG9hZGluZyBzdGF0ZXMgaW4gdG9vIHF1aWNrIHN1Y2Nlc3Npb24uXG5cbnZhciBnbG9iYWxNb3N0UmVjZW50RmFsbGJhY2tUaW1lID0gMDtcbnZhciBGQUxMQkFDS19USFJPVFRMRV9NUyA9IDUwMDsgLy8gVGhlIGFic29sdXRlIHRpbWUgZm9yIHdoZW4gd2Ugc2hvdWxkIHN0YXJ0IGdpdmluZyB1cCBvbiByZW5kZXJpbmdcbi8vIG1vcmUgYW5kIHByZWZlciBDUFUgc3VzcGVuc2UgaGV1cmlzdGljcyBpbnN0ZWFkLlxuXG52YXIgd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyVGFyZ2V0VGltZSA9IEluZmluaXR5OyAvLyBIb3cgbG9uZyBhIHJlbmRlciBpcyBzdXBwb3NlZCB0byB0YWtlIGJlZm9yZSB3ZSBzdGFydCBmb2xsb3dpbmcgQ1BVXG4vLyBzdXNwZW5zZSBoZXVyaXN0aWNzIGFuZCBvcHQgb3V0IG9mIHJlbmRlcmluZyBtb3JlIGNvbnRlbnQuXG5cbnZhciBSRU5ERVJfVElNRU9VVF9NUyA9IDUwMDtcblxuZnVuY3Rpb24gcmVzZXRSZW5kZXJUaW1lcigpIHtcbiAgd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyVGFyZ2V0VGltZSA9IG5vdygpICsgUkVOREVSX1RJTUVPVVRfTVM7XG59XG5cbmZ1bmN0aW9uIGdldFJlbmRlclRhcmdldFRpbWUoKSB7XG4gIHJldHVybiB3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJUYXJnZXRUaW1lO1xufVxudmFyIG5leHRFZmZlY3QgPSBudWxsO1xudmFyIGhhc1VuY2F1Z2h0RXJyb3IgPSBmYWxzZTtcbnZhciBmaXJzdFVuY2F1Z2h0RXJyb3IgPSBudWxsO1xudmFyIGxlZ2FjeUVycm9yQm91bmRhcmllc1RoYXRBbHJlYWR5RmFpbGVkID0gbnVsbDtcbnZhciByb290RG9lc0hhdmVQYXNzaXZlRWZmZWN0cyA9IGZhbHNlO1xudmFyIHJvb3RXaXRoUGVuZGluZ1Bhc3NpdmVFZmZlY3RzID0gbnVsbDtcbnZhciBwZW5kaW5nUGFzc2l2ZUVmZmVjdHNSZW5kZXJQcmlvcml0eSA9IE5vUHJpb3JpdHkkMTtcbnZhciBwZW5kaW5nUGFzc2l2ZUVmZmVjdHNMYW5lcyA9IE5vTGFuZXM7XG52YXIgcGVuZGluZ1Bhc3NpdmVIb29rRWZmZWN0c01vdW50ID0gW107XG52YXIgcGVuZGluZ1Bhc3NpdmVIb29rRWZmZWN0c1VubW91bnQgPSBbXTtcbnZhciByb290c1dpdGhQZW5kaW5nRGlzY3JldGVVcGRhdGVzID0gbnVsbDsgLy8gVXNlIHRoZXNlIHRvIHByZXZlbnQgYW4gaW5maW5pdGUgbG9vcCBvZiBuZXN0ZWQgdXBkYXRlc1xuXG52YXIgTkVTVEVEX1VQREFURV9MSU1JVCA9IDUwO1xudmFyIG5lc3RlZFVwZGF0ZUNvdW50ID0gMDtcbnZhciByb290V2l0aE5lc3RlZFVwZGF0ZXMgPSBudWxsO1xudmFyIE5FU1RFRF9QQVNTSVZFX1VQREFURV9MSU1JVCA9IDUwO1xudmFyIG5lc3RlZFBhc3NpdmVVcGRhdGVDb3VudCA9IDA7IC8vIE1hcmtzIHRoZSBuZWVkIHRvIHJlc2NoZWR1bGUgcGVuZGluZyBpbnRlcmFjdGlvbnMgYXQgdGhlc2UgbGFuZXNcbi8vIGR1cmluZyB0aGUgY29tbWl0IHBoYXNlLiBUaGlzIGVuYWJsZXMgdGhlbSB0byBiZSB0cmFjZWQgYWNyb3NzIGNvbXBvbmVudHNcbi8vIHRoYXQgc3Bhd24gbmV3IHdvcmsgZHVyaW5nIHJlbmRlci4gRS5nLiBoaWRkZW4gYm91bmRhcmllcywgc3VzcGVuZGVkIFNTUlxuLy8gaHlkcmF0aW9uIG9yIFN1c3BlbnNlTGlzdC5cbi8vIFRPRE86IENhbiB1c2UgYSBiaXRtYXNrIGluc3RlYWQgb2YgYW4gYXJyYXlcblxudmFyIHNwYXduZWRXb3JrRHVyaW5nUmVuZGVyID0gbnVsbDsgLy8gSWYgdHdvIHVwZGF0ZXMgYXJlIHNjaGVkdWxlZCB3aXRoaW4gdGhlIHNhbWUgZXZlbnQsIHdlIHNob3VsZCB0cmVhdCB0aGVpclxuLy8gZXZlbnQgdGltZXMgYXMgc2ltdWx0YW5lb3VzLCBldmVuIGlmIHRoZSBhY3R1YWwgY2xvY2sgdGltZSBoYXMgYWR2YW5jZWRcbi8vIGJldHdlZW4gdGhlIGZpcnN0IGFuZCBzZWNvbmQgY2FsbC5cblxudmFyIGN1cnJlbnRFdmVudFRpbWUgPSBOb1RpbWVzdGFtcDtcbnZhciBjdXJyZW50RXZlbnRXaXBMYW5lcyA9IE5vTGFuZXM7XG52YXIgY3VycmVudEV2ZW50UGVuZGluZ0xhbmVzID0gTm9MYW5lczsgLy8gRGV2IG9ubHkgZmxhZyB0aGF0IHRyYWNrcyBpZiBwYXNzaXZlIGVmZmVjdHMgYXJlIGN1cnJlbnRseSBiZWluZyBmbHVzaGVkLlxuLy8gV2Ugd2FybiBhYm91dCBzdGF0ZSB1cGRhdGVzIGZvciB1bm1vdW50ZWQgY29tcG9uZW50cyBkaWZmZXJlbnRseSBpbiB0aGlzIGNhc2UuXG5cbnZhciBpc0ZsdXNoaW5nUGFzc2l2ZUVmZmVjdHMgPSBmYWxzZTtcbnZhciBmb2N1c2VkSW5zdGFuY2VIYW5kbGUgPSBudWxsO1xudmFyIHNob3VsZEZpcmVBZnRlckFjdGl2ZUluc3RhbmNlQmx1ciA9IGZhbHNlO1xuZnVuY3Rpb24gZ2V0V29ya0luUHJvZ3Jlc3NSb290KCkge1xuICByZXR1cm4gd29ya0luUHJvZ3Jlc3NSb290O1xufVxuZnVuY3Rpb24gcmVxdWVzdEV2ZW50VGltZSgpIHtcbiAgaWYgKChleGVjdXRpb25Db250ZXh0ICYgKFJlbmRlckNvbnRleHQgfCBDb21taXRDb250ZXh0KSkgIT09IE5vQ29udGV4dCkge1xuICAgIC8vIFdlJ3JlIGluc2lkZSBSZWFjdCwgc28gaXQncyBmaW5lIHRvIHJlYWQgdGhlIGFjdHVhbCB0aW1lLlxuICAgIHJldHVybiBub3coKTtcbiAgfSAvLyBXZSdyZSBub3QgaW5zaWRlIFJlYWN0LCBzbyB3ZSBtYXkgYmUgaW4gdGhlIG1pZGRsZSBvZiBhIGJyb3dzZXIgZXZlbnQuXG5cblxuICBpZiAoY3VycmVudEV2ZW50VGltZSAhPT0gTm9UaW1lc3RhbXApIHtcbiAgICAvLyBVc2UgdGhlIHNhbWUgc3RhcnQgdGltZSBmb3IgYWxsIHVwZGF0ZXMgdW50aWwgd2UgZW50ZXIgUmVhY3QgYWdhaW4uXG4gICAgcmV0dXJuIGN1cnJlbnRFdmVudFRpbWU7XG4gIH0gLy8gVGhpcyBpcyB0aGUgZmlyc3QgdXBkYXRlIHNpbmNlIFJlYWN0IHlpZWxkZWQuIENvbXB1dGUgYSBuZXcgc3RhcnQgdGltZS5cblxuXG4gIGN1cnJlbnRFdmVudFRpbWUgPSBub3coKTtcbiAgcmV0dXJuIGN1cnJlbnRFdmVudFRpbWU7XG59XG5mdW5jdGlvbiByZXF1ZXN0VXBkYXRlTGFuZShmaWJlcikge1xuICAvLyBTcGVjaWFsIGNhc2VzXG4gIHZhciBtb2RlID0gZmliZXIubW9kZTtcblxuICBpZiAoKG1vZGUgJiBCbG9ja2luZ01vZGUpID09PSBOb01vZGUpIHtcbiAgICByZXR1cm4gU3luY0xhbmU7XG4gIH0gZWxzZSBpZiAoKG1vZGUgJiBDb25jdXJyZW50TW9kZSkgPT09IE5vTW9kZSkge1xuICAgIHJldHVybiBnZXRDdXJyZW50UHJpb3JpdHlMZXZlbCgpID09PSBJbW1lZGlhdGVQcmlvcml0eSQxID8gU3luY0xhbmUgOiBTeW5jQmF0Y2hlZExhbmU7XG4gIH0gLy8gVGhlIGFsZ29yaXRobSBmb3IgYXNzaWduaW5nIGFuIHVwZGF0ZSB0byBhIGxhbmUgc2hvdWxkIGJlIHN0YWJsZSBmb3IgYWxsXG4gIC8vIHVwZGF0ZXMgYXQgdGhlIHNhbWUgcHJpb3JpdHkgd2l0aGluIHRoZSBzYW1lIGV2ZW50LiBUbyBkbyB0aGlzLCB0aGUgaW5wdXRzXG4gIC8vIHRvIHRoZSBhbGdvcml0aG0gbXVzdCBiZSB0aGUgc2FtZS4gRm9yIGV4YW1wbGUsIHdlIHVzZSB0aGUgYHJlbmRlckxhbmVzYFxuICAvLyB0byBhdm9pZCBjaG9vc2luZyBhIGxhbmUgdGhhdCBpcyBhbHJlYWR5IGluIHRoZSBtaWRkbGUgb2YgcmVuZGVyaW5nLlxuICAvL1xuICAvLyBIb3dldmVyLCB0aGUgXCJpbmNsdWRlZFwiIGxhbmVzIGNvdWxkIGJlIG11dGF0ZWQgaW4gYmV0d2VlbiB1cGRhdGVzIGluIHRoZVxuICAvLyBzYW1lIGV2ZW50LCBsaWtlIGlmIHlvdSBwZXJmb3JtIGFuIHVwZGF0ZSBpbnNpZGUgYGZsdXNoU3luY2AuIE9yIGFueSBvdGhlclxuICAvLyBjb2RlIHBhdGggdGhhdCBtaWdodCBjYWxsIGBwcmVwYXJlRnJlc2hTdGFja2AuXG4gIC8vXG4gIC8vIFRoZSB0cmljayB3ZSB1c2UgaXMgdG8gY2FjaGUgdGhlIGZpcnN0IG9mIGVhY2ggb2YgdGhlc2UgaW5wdXRzIHdpdGhpbiBhblxuICAvLyBldmVudC4gVGhlbiByZXNldCB0aGUgY2FjaGVkIHZhbHVlcyBvbmNlIHdlIGNhbiBiZSBzdXJlIHRoZSBldmVudCBpcyBvdmVyLlxuICAvLyBPdXIgaGV1cmlzdGljIGZvciB0aGF0IGlzIHdoZW5ldmVyIHdlIGVudGVyIGEgY29uY3VycmVudCB3b3JrIGxvb3AuXG4gIC8vXG4gIC8vIFdlJ2xsIGRvIHRoZSBzYW1lIGZvciBgY3VycmVudEV2ZW50UGVuZGluZ0xhbmVzYCBiZWxvdy5cblxuXG4gIGlmIChjdXJyZW50RXZlbnRXaXBMYW5lcyA9PT0gTm9MYW5lcykge1xuICAgIGN1cnJlbnRFdmVudFdpcExhbmVzID0gd29ya0luUHJvZ3Jlc3NSb290SW5jbHVkZWRMYW5lcztcbiAgfVxuXG4gIHZhciBpc1RyYW5zaXRpb24gPSByZXF1ZXN0Q3VycmVudFRyYW5zaXRpb24oKSAhPT0gTm9UcmFuc2l0aW9uO1xuXG4gIGlmIChpc1RyYW5zaXRpb24pIHtcbiAgICBpZiAoY3VycmVudEV2ZW50UGVuZGluZ0xhbmVzICE9PSBOb0xhbmVzKSB7XG4gICAgICBjdXJyZW50RXZlbnRQZW5kaW5nTGFuZXMgPSBtb3N0UmVjZW50bHlVcGRhdGVkUm9vdCAhPT0gbnVsbCA/IG1vc3RSZWNlbnRseVVwZGF0ZWRSb290LnBlbmRpbmdMYW5lcyA6IE5vTGFuZXM7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZpbmRUcmFuc2l0aW9uTGFuZShjdXJyZW50RXZlbnRXaXBMYW5lcywgY3VycmVudEV2ZW50UGVuZGluZ0xhbmVzKTtcbiAgfSAvLyBUT0RPOiBSZW1vdmUgdGhpcyBkZXBlbmRlbmN5IG9uIHRoZSBTY2hlZHVsZXIgcHJpb3JpdHkuXG4gIC8vIFRvIGRvIHRoYXQsIHdlJ3JlIHJlcGxhY2luZyBpdCB3aXRoIGFuIHVwZGF0ZSBsYW5lIHByaW9yaXR5LlxuXG5cbiAgdmFyIHNjaGVkdWxlclByaW9yaXR5ID0gZ2V0Q3VycmVudFByaW9yaXR5TGV2ZWwoKTsgLy8gVGhlIG9sZCBiZWhhdmlvciB3YXMgdXNpbmcgdGhlIHByaW9yaXR5IGxldmVsIG9mIHRoZSBTY2hlZHVsZXIuXG4gIC8vIFRoaXMgY291cGxlcyBSZWFjdCB0byB0aGUgU2NoZWR1bGVyIGludGVybmFscywgc28gd2UncmUgcmVwbGFjaW5nIGl0XG4gIC8vIHdpdGggdGhlIGN1cnJlbnRVcGRhdGVMYW5lUHJpb3JpdHkgYWJvdmUuIEFzIGFuIGV4YW1wbGUgb2YgaG93IHRoaXNcbiAgLy8gY291bGQgYmUgcHJvYmxlbWF0aWMsIGlmIHdlJ3JlIG5vdCBpbnNpZGUgYFNjaGVkdWxlci5ydW5XaXRoUHJpb3JpdHlgLFxuICAvLyB0aGVuIHdlJ2xsIGdldCB0aGUgcHJpb3JpdHkgb2YgdGhlIGN1cnJlbnQgcnVubmluZyBTY2hlZHVsZXIgdGFzayxcbiAgLy8gd2hpY2ggaXMgcHJvYmFibHkgbm90IHdoYXQgd2Ugd2FudC5cblxuICB2YXIgbGFuZTtcblxuICBpZiAoIC8vIFRPRE86IFRlbXBvcmFyeS4gV2UncmUgcmVtb3ZpbmcgdGhlIGNvbmNlcHQgb2YgZGlzY3JldGUgdXBkYXRlcy5cbiAgKGV4ZWN1dGlvbkNvbnRleHQgJiBEaXNjcmV0ZUV2ZW50Q29udGV4dCkgIT09IE5vQ29udGV4dCAmJiBzY2hlZHVsZXJQcmlvcml0eSA9PT0gVXNlckJsb2NraW5nUHJpb3JpdHkkMikge1xuICAgIGxhbmUgPSBmaW5kVXBkYXRlTGFuZShJbnB1dERpc2NyZXRlTGFuZVByaW9yaXR5LCBjdXJyZW50RXZlbnRXaXBMYW5lcyk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIHNjaGVkdWxlckxhbmVQcmlvcml0eSA9IHNjaGVkdWxlclByaW9yaXR5VG9MYW5lUHJpb3JpdHkoc2NoZWR1bGVyUHJpb3JpdHkpO1xuXG4gICAgbGFuZSA9IGZpbmRVcGRhdGVMYW5lKHNjaGVkdWxlckxhbmVQcmlvcml0eSwgY3VycmVudEV2ZW50V2lwTGFuZXMpO1xuICB9XG5cbiAgcmV0dXJuIGxhbmU7XG59XG5cbmZ1bmN0aW9uIHJlcXVlc3RSZXRyeUxhbmUoZmliZXIpIHtcbiAgLy8gVGhpcyBpcyBhIGZvcmsgb2YgYHJlcXVlc3RVcGRhdGVMYW5lYCBkZXNpZ25lZCBzcGVjaWZpY2FsbHkgZm9yIFN1c3BlbnNlXG4gIC8vIFwicmV0cmllc1wiIOKAlCBhIHNwZWNpYWwgdXBkYXRlIHRoYXQgYXR0ZW1wdHMgdG8gZmxpcCBhIFN1c3BlbnNlIGJvdW5kYXJ5XG4gIC8vIGZyb20gaXRzIHBsYWNlaG9sZGVyIHN0YXRlIHRvIGl0cyBwcmltYXJ5L3Jlc29sdmVkIHN0YXRlLlxuICAvLyBTcGVjaWFsIGNhc2VzXG4gIHZhciBtb2RlID0gZmliZXIubW9kZTtcblxuICBpZiAoKG1vZGUgJiBCbG9ja2luZ01vZGUpID09PSBOb01vZGUpIHtcbiAgICByZXR1cm4gU3luY0xhbmU7XG4gIH0gZWxzZSBpZiAoKG1vZGUgJiBDb25jdXJyZW50TW9kZSkgPT09IE5vTW9kZSkge1xuICAgIHJldHVybiBnZXRDdXJyZW50UHJpb3JpdHlMZXZlbCgpID09PSBJbW1lZGlhdGVQcmlvcml0eSQxID8gU3luY0xhbmUgOiBTeW5jQmF0Y2hlZExhbmU7XG4gIH0gLy8gU2VlIGByZXF1ZXN0VXBkYXRlTGFuZWAgZm9yIGV4cGxhbmF0aW9uIG9mIGBjdXJyZW50RXZlbnRXaXBMYW5lc2BcblxuXG4gIGlmIChjdXJyZW50RXZlbnRXaXBMYW5lcyA9PT0gTm9MYW5lcykge1xuICAgIGN1cnJlbnRFdmVudFdpcExhbmVzID0gd29ya0luUHJvZ3Jlc3NSb290SW5jbHVkZWRMYW5lcztcbiAgfVxuXG4gIHJldHVybiBmaW5kUmV0cnlMYW5lKGN1cnJlbnRFdmVudFdpcExhbmVzKTtcbn1cblxuZnVuY3Rpb24gc2NoZWR1bGVVcGRhdGVPbkZpYmVyKGZpYmVyLCBsYW5lLCBldmVudFRpbWUpIHtcbiAgY2hlY2tGb3JOZXN0ZWRVcGRhdGVzKCk7XG4gIHdhcm5BYm91dFJlbmRlclBoYXNlVXBkYXRlc0luREVWKGZpYmVyKTtcbiAgdmFyIHJvb3QgPSBtYXJrVXBkYXRlTGFuZUZyb21GaWJlclRvUm9vdChmaWJlciwgbGFuZSk7XG5cbiAgaWYgKHJvb3QgPT09IG51bGwpIHtcbiAgICB3YXJuQWJvdXRVcGRhdGVPblVubW91bnRlZEZpYmVySW5ERVYoZmliZXIpO1xuICAgIHJldHVybiBudWxsO1xuICB9IC8vIE1hcmsgdGhhdCB0aGUgcm9vdCBoYXMgYSBwZW5kaW5nIHVwZGF0ZS5cblxuXG4gIG1hcmtSb290VXBkYXRlZChyb290LCBsYW5lLCBldmVudFRpbWUpO1xuXG4gIGlmIChyb290ID09PSB3b3JrSW5Qcm9ncmVzc1Jvb3QpIHtcbiAgICAvLyBSZWNlaXZlZCBhbiB1cGRhdGUgdG8gYSB0cmVlIHRoYXQncyBpbiB0aGUgbWlkZGxlIG9mIHJlbmRlcmluZy4gTWFya1xuICAgIC8vIHRoYXQgdGhlcmUgd2FzIGFuIGludGVybGVhdmVkIHVwZGF0ZSB3b3JrIG9uIHRoaXMgcm9vdC4gVW5sZXNzIHRoZVxuICAgIC8vIGBkZWZlclJlbmRlclBoYXNlVXBkYXRlVG9OZXh0QmF0Y2hgIGZsYWcgaXMgb2ZmIGFuZCB0aGlzIGlzIGEgcmVuZGVyXG4gICAgLy8gcGhhc2UgdXBkYXRlLiBJbiB0aGF0IGNhc2UsIHdlIGRvbid0IHRyZWF0IHJlbmRlciBwaGFzZSB1cGRhdGVzIGFzIGlmXG4gICAgLy8gdGhleSB3ZXJlIGludGVybGVhdmVkLCBmb3IgYmFja3dhcmRzIGNvbXBhdCByZWFzb25zLlxuICAgIHtcbiAgICAgIHdvcmtJblByb2dyZXNzUm9vdFVwZGF0ZWRMYW5lcyA9IG1lcmdlTGFuZXMod29ya0luUHJvZ3Jlc3NSb290VXBkYXRlZExhbmVzLCBsYW5lKTtcbiAgICB9XG5cbiAgICBpZiAod29ya0luUHJvZ3Jlc3NSb290RXhpdFN0YXR1cyA9PT0gUm9vdFN1c3BlbmRlZFdpdGhEZWxheSkge1xuICAgICAgLy8gVGhlIHJvb3QgYWxyZWFkeSBzdXNwZW5kZWQgd2l0aCBhIGRlbGF5LCB3aGljaCBtZWFucyB0aGlzIHJlbmRlclxuICAgICAgLy8gZGVmaW5pdGVseSB3b24ndCBmaW5pc2guIFNpbmNlIHdlIGhhdmUgYSBuZXcgdXBkYXRlLCBsZXQncyBtYXJrIGl0IGFzXG4gICAgICAvLyBzdXNwZW5kZWQgbm93LCByaWdodCBiZWZvcmUgbWFya2luZyB0aGUgaW5jb21pbmcgdXBkYXRlLiBUaGlzIGhhcyB0aGVcbiAgICAgIC8vIGVmZmVjdCBvZiBpbnRlcnJ1cHRpbmcgdGhlIGN1cnJlbnQgcmVuZGVyIGFuZCBzd2l0Y2hpbmcgdG8gdGhlIHVwZGF0ZS5cbiAgICAgIC8vIFRPRE86IE1ha2Ugc3VyZSB0aGlzIGRvZXNuJ3Qgb3ZlcnJpZGUgcGluZ3MgdGhhdCBoYXBwZW4gd2hpbGUgd2UndmVcbiAgICAgIC8vIGFscmVhZHkgc3RhcnRlZCByZW5kZXJpbmcuXG4gICAgICBtYXJrUm9vdFN1c3BlbmRlZCQxKHJvb3QsIHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzKTtcbiAgICB9XG4gIH0gLy8gVE9ETzogcmVxdWVzdFVwZGF0ZUxhbmVQcmlvcml0eSBhbHNvIHJlYWRzIHRoZSBwcmlvcml0eS4gUGFzcyB0aGVcbiAgLy8gcHJpb3JpdHkgYXMgYW4gYXJndW1lbnQgdG8gdGhhdCBmdW5jdGlvbiBhbmQgdGhpcyBvbmUuXG5cblxuICB2YXIgcHJpb3JpdHlMZXZlbCA9IGdldEN1cnJlbnRQcmlvcml0eUxldmVsKCk7XG5cbiAgaWYgKGxhbmUgPT09IFN5bmNMYW5lKSB7XG4gICAgaWYgKCAvLyBDaGVjayBpZiB3ZSdyZSBpbnNpZGUgdW5iYXRjaGVkVXBkYXRlc1xuICAgIChleGVjdXRpb25Db250ZXh0ICYgTGVnYWN5VW5iYXRjaGVkQ29udGV4dCkgIT09IE5vQ29udGV4dCAmJiAvLyBDaGVjayBpZiB3ZSdyZSBub3QgYWxyZWFkeSByZW5kZXJpbmdcbiAgICAoZXhlY3V0aW9uQ29udGV4dCAmIChSZW5kZXJDb250ZXh0IHwgQ29tbWl0Q29udGV4dCkpID09PSBOb0NvbnRleHQpIHtcbiAgICAgIC8vIFJlZ2lzdGVyIHBlbmRpbmcgaW50ZXJhY3Rpb25zIG9uIHRoZSByb290IHRvIGF2b2lkIGxvc2luZyB0cmFjZWQgaW50ZXJhY3Rpb24gZGF0YS5cbiAgICAgIHNjaGVkdWxlUGVuZGluZ0ludGVyYWN0aW9ucyhyb290LCBsYW5lKTsgLy8gVGhpcyBpcyBhIGxlZ2FjeSBlZGdlIGNhc2UuIFRoZSBpbml0aWFsIG1vdW50IG9mIGEgUmVhY3RET00ucmVuZGVyLWVkXG4gICAgICAvLyByb290IGluc2lkZSBvZiBiYXRjaGVkVXBkYXRlcyBzaG91bGQgYmUgc3luY2hyb25vdXMsIGJ1dCBsYXlvdXQgdXBkYXRlc1xuICAgICAgLy8gc2hvdWxkIGJlIGRlZmVycmVkIHVudGlsIHRoZSBlbmQgb2YgdGhlIGJhdGNoLlxuXG4gICAgICBwZXJmb3JtU3luY1dvcmtPblJvb3Qocm9vdCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVuc3VyZVJvb3RJc1NjaGVkdWxlZChyb290LCBldmVudFRpbWUpO1xuICAgICAgc2NoZWR1bGVQZW5kaW5nSW50ZXJhY3Rpb25zKHJvb3QsIGxhbmUpO1xuXG4gICAgICBpZiAoZXhlY3V0aW9uQ29udGV4dCA9PT0gTm9Db250ZXh0KSB7XG4gICAgICAgIC8vIEZsdXNoIHRoZSBzeW5jaHJvbm91cyB3b3JrIG5vdywgdW5sZXNzIHdlJ3JlIGFscmVhZHkgd29ya2luZyBvciBpbnNpZGVcbiAgICAgICAgLy8gYSBiYXRjaC4gVGhpcyBpcyBpbnRlbnRpb25hbGx5IGluc2lkZSBzY2hlZHVsZVVwZGF0ZU9uRmliZXIgaW5zdGVhZCBvZlxuICAgICAgICAvLyBzY2hlZHVsZUNhbGxiYWNrRm9yRmliZXIgdG8gcHJlc2VydmUgdGhlIGFiaWxpdHkgdG8gc2NoZWR1bGUgYSBjYWxsYmFja1xuICAgICAgICAvLyB3aXRob3V0IGltbWVkaWF0ZWx5IGZsdXNoaW5nIGl0LiBXZSBvbmx5IGRvIHRoaXMgZm9yIHVzZXItaW5pdGlhdGVkXG4gICAgICAgIC8vIHVwZGF0ZXMsIHRvIHByZXNlcnZlIGhpc3RvcmljYWwgYmVoYXZpb3Igb2YgbGVnYWN5IG1vZGUuXG4gICAgICAgIHJlc2V0UmVuZGVyVGltZXIoKTtcbiAgICAgICAgZmx1c2hTeW5jQ2FsbGJhY2tRdWV1ZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBTY2hlZHVsZSBhIGRpc2NyZXRlIHVwZGF0ZSBidXQgb25seSBpZiBpdCdzIG5vdCBTeW5jLlxuICAgIGlmICgoZXhlY3V0aW9uQ29udGV4dCAmIERpc2NyZXRlRXZlbnRDb250ZXh0KSAhPT0gTm9Db250ZXh0ICYmICggLy8gT25seSB1cGRhdGVzIGF0IHVzZXItYmxvY2tpbmcgcHJpb3JpdHkgb3IgZ3JlYXRlciBhcmUgY29uc2lkZXJlZFxuICAgIC8vIGRpc2NyZXRlLCBldmVuIGluc2lkZSBhIGRpc2NyZXRlIGV2ZW50LlxuICAgIHByaW9yaXR5TGV2ZWwgPT09IFVzZXJCbG9ja2luZ1ByaW9yaXR5JDIgfHwgcHJpb3JpdHlMZXZlbCA9PT0gSW1tZWRpYXRlUHJpb3JpdHkkMSkpIHtcbiAgICAgIC8vIFRoaXMgaXMgdGhlIHJlc3VsdCBvZiBhIGRpc2NyZXRlIGV2ZW50LiBUcmFjayB0aGUgbG93ZXN0IHByaW9yaXR5XG4gICAgICAvLyBkaXNjcmV0ZSB1cGRhdGUgcGVyIHJvb3Qgc28gd2UgY2FuIGZsdXNoIHRoZW0gZWFybHksIGlmIG5lZWRlZC5cbiAgICAgIGlmIChyb290c1dpdGhQZW5kaW5nRGlzY3JldGVVcGRhdGVzID09PSBudWxsKSB7XG4gICAgICAgIHJvb3RzV2l0aFBlbmRpbmdEaXNjcmV0ZVVwZGF0ZXMgPSBuZXcgU2V0KFtyb290XSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByb290c1dpdGhQZW5kaW5nRGlzY3JldGVVcGRhdGVzLmFkZChyb290KTtcbiAgICAgIH1cbiAgICB9IC8vIFNjaGVkdWxlIG90aGVyIHVwZGF0ZXMgYWZ0ZXIgaW4gY2FzZSB0aGUgY2FsbGJhY2sgaXMgc3luYy5cblxuXG4gICAgZW5zdXJlUm9vdElzU2NoZWR1bGVkKHJvb3QsIGV2ZW50VGltZSk7XG4gICAgc2NoZWR1bGVQZW5kaW5nSW50ZXJhY3Rpb25zKHJvb3QsIGxhbmUpO1xuICB9IC8vIFdlIHVzZSB0aGlzIHdoZW4gYXNzaWduaW5nIGEgbGFuZSBmb3IgYSB0cmFuc2l0aW9uIGluc2lkZVxuICAvLyBgcmVxdWVzdFVwZGF0ZUxhbmVgLiBXZSBhc3N1bWUgaXQncyB0aGUgc2FtZSBhcyB0aGUgcm9vdCBiZWluZyB1cGRhdGVkLFxuICAvLyBzaW5jZSBpbiB0aGUgY29tbW9uIGNhc2Ugb2YgYSBzaW5nbGUgcm9vdCBhcHAgaXQgcHJvYmFibHkgaXMuIElmIGl0J3Mgbm90XG4gIC8vIHRoZSBzYW1lIHJvb3QsIHRoZW4gaXQncyBub3QgYSBodWdlIGRlYWwsIHdlIGp1c3QgbWlnaHQgYmF0Y2ggbW9yZSBzdHVmZlxuICAvLyB0b2dldGhlciBtb3JlIHRoYW4gbmVjZXNzYXJ5LlxuXG5cbiAgbW9zdFJlY2VudGx5VXBkYXRlZFJvb3QgPSByb290O1xufSAvLyBUaGlzIGlzIHNwbGl0IGludG8gYSBzZXBhcmF0ZSBmdW5jdGlvbiBzbyB3ZSBjYW4gbWFyayBhIGZpYmVyIHdpdGggcGVuZGluZ1xuLy8gd29yayB3aXRob3V0IHRyZWF0aW5nIGl0IGFzIGEgdHlwaWNhbCB1cGRhdGUgdGhhdCBvcmlnaW5hdGVzIGZyb20gYW4gZXZlbnQ7XG4vLyBlLmcuIHJldHJ5aW5nIGEgU3VzcGVuc2UgYm91bmRhcnkgaXNuJ3QgYW4gdXBkYXRlLCBidXQgaXQgZG9lcyBzY2hlZHVsZSB3b3JrXG4vLyBvbiBhIGZpYmVyLlxuXG5mdW5jdGlvbiBtYXJrVXBkYXRlTGFuZUZyb21GaWJlclRvUm9vdChzb3VyY2VGaWJlciwgbGFuZSkge1xuICAvLyBVcGRhdGUgdGhlIHNvdXJjZSBmaWJlcidzIGxhbmVzXG4gIHNvdXJjZUZpYmVyLmxhbmVzID0gbWVyZ2VMYW5lcyhzb3VyY2VGaWJlci5sYW5lcywgbGFuZSk7XG4gIHZhciBhbHRlcm5hdGUgPSBzb3VyY2VGaWJlci5hbHRlcm5hdGU7XG5cbiAgaWYgKGFsdGVybmF0ZSAhPT0gbnVsbCkge1xuICAgIGFsdGVybmF0ZS5sYW5lcyA9IG1lcmdlTGFuZXMoYWx0ZXJuYXRlLmxhbmVzLCBsYW5lKTtcbiAgfVxuXG4gIHtcbiAgICBpZiAoYWx0ZXJuYXRlID09PSBudWxsICYmIChzb3VyY2VGaWJlci5mbGFncyAmIChQbGFjZW1lbnQgfCBIeWRyYXRpbmcpKSAhPT0gTm9GbGFncykge1xuICAgICAgd2FybkFib3V0VXBkYXRlT25Ob3RZZXRNb3VudGVkRmliZXJJbkRFVihzb3VyY2VGaWJlcik7XG4gICAgfVxuICB9IC8vIFdhbGsgdGhlIHBhcmVudCBwYXRoIHRvIHRoZSByb290IGFuZCB1cGRhdGUgdGhlIGNoaWxkIGV4cGlyYXRpb24gdGltZS5cblxuXG4gIHZhciBub2RlID0gc291cmNlRmliZXI7XG4gIHZhciBwYXJlbnQgPSBzb3VyY2VGaWJlci5yZXR1cm47XG5cbiAgd2hpbGUgKHBhcmVudCAhPT0gbnVsbCkge1xuICAgIHBhcmVudC5jaGlsZExhbmVzID0gbWVyZ2VMYW5lcyhwYXJlbnQuY2hpbGRMYW5lcywgbGFuZSk7XG4gICAgYWx0ZXJuYXRlID0gcGFyZW50LmFsdGVybmF0ZTtcblxuICAgIGlmIChhbHRlcm5hdGUgIT09IG51bGwpIHtcbiAgICAgIGFsdGVybmF0ZS5jaGlsZExhbmVzID0gbWVyZ2VMYW5lcyhhbHRlcm5hdGUuY2hpbGRMYW5lcywgbGFuZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHtcbiAgICAgICAgaWYgKChwYXJlbnQuZmxhZ3MgJiAoUGxhY2VtZW50IHwgSHlkcmF0aW5nKSkgIT09IE5vRmxhZ3MpIHtcbiAgICAgICAgICB3YXJuQWJvdXRVcGRhdGVPbk5vdFlldE1vdW50ZWRGaWJlckluREVWKHNvdXJjZUZpYmVyKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIG5vZGUgPSBwYXJlbnQ7XG4gICAgcGFyZW50ID0gcGFyZW50LnJldHVybjtcbiAgfVxuXG4gIGlmIChub2RlLnRhZyA9PT0gSG9zdFJvb3QpIHtcbiAgICB2YXIgcm9vdCA9IG5vZGUuc3RhdGVOb2RlO1xuICAgIHJldHVybiByb290O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBudWxsO1xuICB9XG59IC8vIFVzZSB0aGlzIGZ1bmN0aW9uIHRvIHNjaGVkdWxlIGEgdGFzayBmb3IgYSByb290LiBUaGVyZSdzIG9ubHkgb25lIHRhc2sgcGVyXG4vLyByb290OyBpZiBhIHRhc2sgd2FzIGFscmVhZHkgc2NoZWR1bGVkLCB3ZSdsbCBjaGVjayB0byBtYWtlIHN1cmUgdGhlIHByaW9yaXR5XG4vLyBvZiB0aGUgZXhpc3RpbmcgdGFzayBpcyB0aGUgc2FtZSBhcyB0aGUgcHJpb3JpdHkgb2YgdGhlIG5leHQgbGV2ZWwgdGhhdCB0aGVcbi8vIHJvb3QgaGFzIHdvcmsgb24uIFRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIG9uIGV2ZXJ5IHVwZGF0ZSwgYW5kIHJpZ2h0IGJlZm9yZVxuLy8gZXhpdGluZyBhIHRhc2suXG5cblxuZnVuY3Rpb24gZW5zdXJlUm9vdElzU2NoZWR1bGVkKHJvb3QsIGN1cnJlbnRUaW1lKSB7XG4gIHZhciBleGlzdGluZ0NhbGxiYWNrTm9kZSA9IHJvb3QuY2FsbGJhY2tOb2RlOyAvLyBDaGVjayBpZiBhbnkgbGFuZXMgYXJlIGJlaW5nIHN0YXJ2ZWQgYnkgb3RoZXIgd29yay4gSWYgc28sIG1hcmsgdGhlbSBhc1xuICAvLyBleHBpcmVkIHNvIHdlIGtub3cgdG8gd29yayBvbiB0aG9zZSBuZXh0LlxuXG4gIG1hcmtTdGFydmVkTGFuZXNBc0V4cGlyZWQocm9vdCwgY3VycmVudFRpbWUpOyAvLyBEZXRlcm1pbmUgdGhlIG5leHQgbGFuZXMgdG8gd29yayBvbiwgYW5kIHRoZWlyIHByaW9yaXR5LlxuXG4gIHZhciBuZXh0TGFuZXMgPSBnZXROZXh0TGFuZXMocm9vdCwgcm9vdCA9PT0gd29ya0luUHJvZ3Jlc3NSb290ID8gd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMgOiBOb0xhbmVzKTsgLy8gVGhpcyByZXR1cm5zIHRoZSBwcmlvcml0eSBsZXZlbCBjb21wdXRlZCBkdXJpbmcgdGhlIGBnZXROZXh0TGFuZXNgIGNhbGwuXG5cbiAgdmFyIG5ld0NhbGxiYWNrUHJpb3JpdHkgPSByZXR1cm5OZXh0TGFuZXNQcmlvcml0eSgpO1xuXG4gIGlmIChuZXh0TGFuZXMgPT09IE5vTGFuZXMpIHtcbiAgICAvLyBTcGVjaWFsIGNhc2U6IFRoZXJlJ3Mgbm90aGluZyB0byB3b3JrIG9uLlxuICAgIGlmIChleGlzdGluZ0NhbGxiYWNrTm9kZSAhPT0gbnVsbCkge1xuICAgICAgY2FuY2VsQ2FsbGJhY2soZXhpc3RpbmdDYWxsYmFja05vZGUpO1xuICAgICAgcm9vdC5jYWxsYmFja05vZGUgPSBudWxsO1xuICAgICAgcm9vdC5jYWxsYmFja1ByaW9yaXR5ID0gTm9MYW5lUHJpb3JpdHk7XG4gICAgfVxuXG4gICAgcmV0dXJuO1xuICB9IC8vIENoZWNrIGlmIHRoZXJlJ3MgYW4gZXhpc3RpbmcgdGFzay4gV2UgbWF5IGJlIGFibGUgdG8gcmV1c2UgaXQuXG5cblxuICBpZiAoZXhpc3RpbmdDYWxsYmFja05vZGUgIT09IG51bGwpIHtcbiAgICB2YXIgZXhpc3RpbmdDYWxsYmFja1ByaW9yaXR5ID0gcm9vdC5jYWxsYmFja1ByaW9yaXR5O1xuXG4gICAgaWYgKGV4aXN0aW5nQ2FsbGJhY2tQcmlvcml0eSA9PT0gbmV3Q2FsbGJhY2tQcmlvcml0eSkge1xuICAgICAgLy8gVGhlIHByaW9yaXR5IGhhc24ndCBjaGFuZ2VkLiBXZSBjYW4gcmV1c2UgdGhlIGV4aXN0aW5nIHRhc2suIEV4aXQuXG4gICAgICByZXR1cm47XG4gICAgfSAvLyBUaGUgcHJpb3JpdHkgY2hhbmdlZC4gQ2FuY2VsIHRoZSBleGlzdGluZyBjYWxsYmFjay4gV2UnbGwgc2NoZWR1bGUgYSBuZXdcbiAgICAvLyBvbmUgYmVsb3cuXG5cblxuICAgIGNhbmNlbENhbGxiYWNrKGV4aXN0aW5nQ2FsbGJhY2tOb2RlKTtcbiAgfSAvLyBTY2hlZHVsZSBhIG5ldyBjYWxsYmFjay5cblxuXG4gIHZhciBuZXdDYWxsYmFja05vZGU7XG5cbiAgaWYgKG5ld0NhbGxiYWNrUHJpb3JpdHkgPT09IFN5bmNMYW5lUHJpb3JpdHkpIHtcbiAgICAvLyBTcGVjaWFsIGNhc2U6IFN5bmMgUmVhY3QgY2FsbGJhY2tzIGFyZSBzY2hlZHVsZWQgb24gYSBzcGVjaWFsXG4gICAgLy8gaW50ZXJuYWwgcXVldWVcbiAgICBuZXdDYWxsYmFja05vZGUgPSBzY2hlZHVsZVN5bmNDYWxsYmFjayhwZXJmb3JtU3luY1dvcmtPblJvb3QuYmluZChudWxsLCByb290KSk7XG4gIH0gZWxzZSBpZiAobmV3Q2FsbGJhY2tQcmlvcml0eSA9PT0gU3luY0JhdGNoZWRMYW5lUHJpb3JpdHkpIHtcbiAgICBuZXdDYWxsYmFja05vZGUgPSBzY2hlZHVsZUNhbGxiYWNrKEltbWVkaWF0ZVByaW9yaXR5JDEsIHBlcmZvcm1TeW5jV29ya09uUm9vdC5iaW5kKG51bGwsIHJvb3QpKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgc2NoZWR1bGVyUHJpb3JpdHlMZXZlbCA9IGxhbmVQcmlvcml0eVRvU2NoZWR1bGVyUHJpb3JpdHkobmV3Q2FsbGJhY2tQcmlvcml0eSk7XG4gICAgbmV3Q2FsbGJhY2tOb2RlID0gc2NoZWR1bGVDYWxsYmFjayhzY2hlZHVsZXJQcmlvcml0eUxldmVsLCBwZXJmb3JtQ29uY3VycmVudFdvcmtPblJvb3QuYmluZChudWxsLCByb290KSk7XG4gIH1cblxuICByb290LmNhbGxiYWNrUHJpb3JpdHkgPSBuZXdDYWxsYmFja1ByaW9yaXR5O1xuICByb290LmNhbGxiYWNrTm9kZSA9IG5ld0NhbGxiYWNrTm9kZTtcbn0gLy8gVGhpcyBpcyB0aGUgZW50cnkgcG9pbnQgZm9yIGV2ZXJ5IGNvbmN1cnJlbnQgdGFzaywgaS5lLiBhbnl0aGluZyB0aGF0XG4vLyBnb2VzIHRocm91Z2ggU2NoZWR1bGVyLlxuXG5cbmZ1bmN0aW9uIHBlcmZvcm1Db25jdXJyZW50V29ya09uUm9vdChyb290KSB7XG4gIC8vIFNpbmNlIHdlIGtub3cgd2UncmUgaW4gYSBSZWFjdCBldmVudCwgd2UgY2FuIGNsZWFyIHRoZSBjdXJyZW50XG4gIC8vIGV2ZW50IHRpbWUuIFRoZSBuZXh0IHVwZGF0ZSB3aWxsIGNvbXB1dGUgYSBuZXcgZXZlbnQgdGltZS5cbiAgY3VycmVudEV2ZW50VGltZSA9IE5vVGltZXN0YW1wO1xuICBjdXJyZW50RXZlbnRXaXBMYW5lcyA9IE5vTGFuZXM7XG4gIGN1cnJlbnRFdmVudFBlbmRpbmdMYW5lcyA9IE5vTGFuZXM7XG5cbiAgaWYgKCEoKGV4ZWN1dGlvbkNvbnRleHQgJiAoUmVuZGVyQ29udGV4dCB8IENvbW1pdENvbnRleHQpKSA9PT0gTm9Db250ZXh0KSkge1xuICAgIHtcbiAgICAgIHRocm93IEVycm9yKCBcIlNob3VsZCBub3QgYWxyZWFkeSBiZSB3b3JraW5nLlwiICk7XG4gICAgfVxuICB9IC8vIEZsdXNoIGFueSBwZW5kaW5nIHBhc3NpdmUgZWZmZWN0cyBiZWZvcmUgZGVjaWRpbmcgd2hpY2ggbGFuZXMgdG8gd29yayBvbixcbiAgLy8gaW4gY2FzZSB0aGV5IHNjaGVkdWxlIGFkZGl0aW9uYWwgd29yay5cblxuXG4gIHZhciBvcmlnaW5hbENhbGxiYWNrTm9kZSA9IHJvb3QuY2FsbGJhY2tOb2RlO1xuICB2YXIgZGlkRmx1c2hQYXNzaXZlRWZmZWN0cyA9IGZsdXNoUGFzc2l2ZUVmZmVjdHMoKTtcblxuICBpZiAoZGlkRmx1c2hQYXNzaXZlRWZmZWN0cykge1xuICAgIC8vIFNvbWV0aGluZyBpbiB0aGUgcGFzc2l2ZSBlZmZlY3QgcGhhc2UgbWF5IGhhdmUgY2FuY2VsZWQgdGhlIGN1cnJlbnQgdGFzay5cbiAgICAvLyBDaGVjayBpZiB0aGUgdGFzayBub2RlIGZvciB0aGlzIHJvb3Qgd2FzIGNoYW5nZWQuXG4gICAgaWYgKHJvb3QuY2FsbGJhY2tOb2RlICE9PSBvcmlnaW5hbENhbGxiYWNrTm9kZSkge1xuICAgICAgLy8gVGhlIGN1cnJlbnQgdGFzayB3YXMgY2FuY2VsZWQuIEV4aXQuIFdlIGRvbid0IG5lZWQgdG8gY2FsbFxuICAgICAgLy8gYGVuc3VyZVJvb3RJc1NjaGVkdWxlZGAgYmVjYXVzZSB0aGUgY2hlY2sgYWJvdmUgaW1wbGllcyBlaXRoZXIgdGhhdFxuICAgICAgLy8gdGhlcmUncyBhIG5ldyB0YXNrLCBvciB0aGF0IHRoZXJlJ3Mgbm8gcmVtYWluaW5nIHdvcmsgb24gdGhpcyByb290LlxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9IC8vIERldGVybWluZSB0aGUgbmV4dCBleHBpcmF0aW9uIHRpbWUgdG8gd29yayBvbiwgdXNpbmcgdGhlIGZpZWxkcyBzdG9yZWRcbiAgLy8gb24gdGhlIHJvb3QuXG5cblxuICB2YXIgbGFuZXMgPSBnZXROZXh0TGFuZXMocm9vdCwgcm9vdCA9PT0gd29ya0luUHJvZ3Jlc3NSb290ID8gd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMgOiBOb0xhbmVzKTtcblxuICBpZiAobGFuZXMgPT09IE5vTGFuZXMpIHtcbiAgICAvLyBEZWZlbnNpdmUgY29kaW5nLiBUaGlzIGlzIG5ldmVyIGV4cGVjdGVkIHRvIGhhcHBlbi5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBleGl0U3RhdHVzID0gcmVuZGVyUm9vdENvbmN1cnJlbnQocm9vdCwgbGFuZXMpO1xuXG4gIGlmIChpbmNsdWRlc1NvbWVMYW5lKHdvcmtJblByb2dyZXNzUm9vdEluY2x1ZGVkTGFuZXMsIHdvcmtJblByb2dyZXNzUm9vdFVwZGF0ZWRMYW5lcykpIHtcbiAgICAvLyBUaGUgcmVuZGVyIGluY2x1ZGVkIGxhbmVzIHRoYXQgd2VyZSB1cGRhdGVkIGR1cmluZyB0aGUgcmVuZGVyIHBoYXNlLlxuICAgIC8vIEZvciBleGFtcGxlLCB3aGVuIHVuaGlkaW5nIGEgaGlkZGVuIHRyZWUsIHdlIGluY2x1ZGUgYWxsIHRoZSBsYW5lc1xuICAgIC8vIHRoYXQgd2VyZSBwcmV2aW91c2x5IHNraXBwZWQgd2hlbiB0aGUgdHJlZSB3YXMgaGlkZGVuLiBUaGF0IHNldCBvZlxuICAgIC8vIGxhbmVzIGlzIGEgc3VwZXJzZXQgb2YgdGhlIGxhbmVzIHdlIHN0YXJ0ZWQgcmVuZGVyaW5nIHdpdGguXG4gICAgLy9cbiAgICAvLyBTbyB3ZSdsbCB0aHJvdyBvdXQgdGhlIGN1cnJlbnQgd29yayBhbmQgcmVzdGFydC5cbiAgICBwcmVwYXJlRnJlc2hTdGFjayhyb290LCBOb0xhbmVzKTtcbiAgfSBlbHNlIGlmIChleGl0U3RhdHVzICE9PSBSb290SW5jb21wbGV0ZSkge1xuICAgIGlmIChleGl0U3RhdHVzID09PSBSb290RXJyb3JlZCkge1xuICAgICAgZXhlY3V0aW9uQ29udGV4dCB8PSBSZXRyeUFmdGVyRXJyb3I7IC8vIElmIGFuIGVycm9yIG9jY3VycmVkIGR1cmluZyBoeWRyYXRpb24sXG4gICAgICAvLyBkaXNjYXJkIHNlcnZlciByZXNwb25zZSBhbmQgZmFsbCBiYWNrIHRvIGNsaWVudCBzaWRlIHJlbmRlci5cblxuICAgICAgaWYgKHJvb3QuaHlkcmF0ZSkge1xuICAgICAgICByb290Lmh5ZHJhdGUgPSBmYWxzZTtcbiAgICAgICAgY2xlYXJDb250YWluZXIocm9vdC5jb250YWluZXJJbmZvKTtcbiAgICAgIH0gLy8gSWYgc29tZXRoaW5nIHRocmV3IGFuIGVycm9yLCB0cnkgcmVuZGVyaW5nIG9uZSBtb3JlIHRpbWUuIFdlJ2xsIHJlbmRlclxuICAgICAgLy8gc3luY2hyb25vdXNseSB0byBibG9jayBjb25jdXJyZW50IGRhdGEgbXV0YXRpb25zLCBhbmQgd2UnbGwgaW5jbHVkZXNcbiAgICAgIC8vIGFsbCBwZW5kaW5nIHVwZGF0ZXMgYXJlIGluY2x1ZGVkLiBJZiBpdCBzdGlsbCBmYWlscyBhZnRlciB0aGUgc2Vjb25kXG4gICAgICAvLyBhdHRlbXB0LCB3ZSdsbCBnaXZlIHVwIGFuZCBjb21taXQgdGhlIHJlc3VsdGluZyB0cmVlLlxuXG5cbiAgICAgIGxhbmVzID0gZ2V0TGFuZXNUb1JldHJ5U3luY2hyb25vdXNseU9uRXJyb3Iocm9vdCk7XG5cbiAgICAgIGlmIChsYW5lcyAhPT0gTm9MYW5lcykge1xuICAgICAgICBleGl0U3RhdHVzID0gcmVuZGVyUm9vdFN5bmMocm9vdCwgbGFuZXMpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChleGl0U3RhdHVzID09PSBSb290RmF0YWxFcnJvcmVkKSB7XG4gICAgICB2YXIgZmF0YWxFcnJvciA9IHdvcmtJblByb2dyZXNzUm9vdEZhdGFsRXJyb3I7XG4gICAgICBwcmVwYXJlRnJlc2hTdGFjayhyb290LCBOb0xhbmVzKTtcbiAgICAgIG1hcmtSb290U3VzcGVuZGVkJDEocm9vdCwgbGFuZXMpO1xuICAgICAgZW5zdXJlUm9vdElzU2NoZWR1bGVkKHJvb3QsIG5vdygpKTtcbiAgICAgIHRocm93IGZhdGFsRXJyb3I7XG4gICAgfSAvLyBXZSBub3cgaGF2ZSBhIGNvbnNpc3RlbnQgdHJlZS4gVGhlIG5leHQgc3RlcCBpcyBlaXRoZXIgdG8gY29tbWl0IGl0LFxuICAgIC8vIG9yLCBpZiBzb21ldGhpbmcgc3VzcGVuZGVkLCB3YWl0IHRvIGNvbW1pdCBpdCBhZnRlciBhIHRpbWVvdXQuXG5cblxuICAgIHZhciBmaW5pc2hlZFdvcmsgPSByb290LmN1cnJlbnQuYWx0ZXJuYXRlO1xuICAgIHJvb3QuZmluaXNoZWRXb3JrID0gZmluaXNoZWRXb3JrO1xuICAgIHJvb3QuZmluaXNoZWRMYW5lcyA9IGxhbmVzO1xuICAgIGZpbmlzaENvbmN1cnJlbnRSZW5kZXIocm9vdCwgZXhpdFN0YXR1cywgbGFuZXMpO1xuICB9XG5cbiAgZW5zdXJlUm9vdElzU2NoZWR1bGVkKHJvb3QsIG5vdygpKTtcblxuICBpZiAocm9vdC5jYWxsYmFja05vZGUgPT09IG9yaWdpbmFsQ2FsbGJhY2tOb2RlKSB7XG4gICAgLy8gVGhlIHRhc2sgbm9kZSBzY2hlZHVsZWQgZm9yIHRoaXMgcm9vdCBpcyB0aGUgc2FtZSBvbmUgdGhhdCdzXG4gICAgLy8gY3VycmVudGx5IGV4ZWN1dGVkLiBOZWVkIHRvIHJldHVybiBhIGNvbnRpbnVhdGlvbi5cbiAgICByZXR1cm4gcGVyZm9ybUNvbmN1cnJlbnRXb3JrT25Sb290LmJpbmQobnVsbCwgcm9vdCk7XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gZmluaXNoQ29uY3VycmVudFJlbmRlcihyb290LCBleGl0U3RhdHVzLCBsYW5lcykge1xuICBzd2l0Y2ggKGV4aXRTdGF0dXMpIHtcbiAgICBjYXNlIFJvb3RJbmNvbXBsZXRlOlxuICAgIGNhc2UgUm9vdEZhdGFsRXJyb3JlZDpcbiAgICAgIHtcbiAgICAgICAge1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKCBcIlJvb3QgZGlkIG5vdCBjb21wbGV0ZS4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC5cIiApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIC8vIEZsb3cga25vd3MgYWJvdXQgaW52YXJpYW50LCBzbyBpdCBjb21wbGFpbnMgaWYgSSBhZGQgYSBicmVha1xuICAgIC8vIHN0YXRlbWVudCwgYnV0IGVzbGludCBkb2Vzbid0IGtub3cgYWJvdXQgaW52YXJpYW50LCBzbyBpdCBjb21wbGFpbnNcbiAgICAvLyBpZiBJIGRvLiBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZmFsbHRocm91Z2hcblxuICAgIGNhc2UgUm9vdEVycm9yZWQ6XG4gICAgICB7XG4gICAgICAgIC8vIFdlIHNob3VsZCBoYXZlIGFscmVhZHkgYXR0ZW1wdGVkIHRvIHJldHJ5IHRoaXMgdHJlZS4gSWYgd2UgcmVhY2hlZFxuICAgICAgICAvLyB0aGlzIHBvaW50LCBpdCBlcnJvcmVkIGFnYWluLiBDb21taXQgaXQuXG4gICAgICAgIGNvbW1pdFJvb3Qocm9vdCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgY2FzZSBSb290U3VzcGVuZGVkOlxuICAgICAge1xuICAgICAgICBtYXJrUm9vdFN1c3BlbmRlZCQxKHJvb3QsIGxhbmVzKTsgLy8gV2UgaGF2ZSBhbiBhY2NlcHRhYmxlIGxvYWRpbmcgc3RhdGUuIFdlIG5lZWQgdG8gZmlndXJlIG91dCBpZiB3ZVxuICAgICAgICAvLyBzaG91bGQgaW1tZWRpYXRlbHkgY29tbWl0IGl0IG9yIHdhaXQgYSBiaXQuXG5cbiAgICAgICAgaWYgKGluY2x1ZGVzT25seVJldHJpZXMobGFuZXMpICYmIC8vIGRvIG5vdCBkZWxheSBpZiB3ZSdyZSBpbnNpZGUgYW4gYWN0KCkgc2NvcGVcbiAgICAgICAgIXNob3VsZEZvcmNlRmx1c2hGYWxsYmFja3NJbkRFVigpKSB7XG4gICAgICAgICAgLy8gVGhpcyByZW5kZXIgb25seSBpbmNsdWRlZCByZXRyaWVzLCBubyB1cGRhdGVzLiBUaHJvdHRsZSBjb21taXR0aW5nXG4gICAgICAgICAgLy8gcmV0cmllcyBzbyB0aGF0IHdlIGRvbid0IHNob3cgdG9vIG1hbnkgbG9hZGluZyBzdGF0ZXMgdG9vIHF1aWNrbHkuXG4gICAgICAgICAgdmFyIG1zVW50aWxUaW1lb3V0ID0gZ2xvYmFsTW9zdFJlY2VudEZhbGxiYWNrVGltZSArIEZBTExCQUNLX1RIUk9UVExFX01TIC0gbm93KCk7IC8vIERvbid0IGJvdGhlciB3aXRoIGEgdmVyeSBzaG9ydCBzdXNwZW5zZSB0aW1lLlxuXG4gICAgICAgICAgaWYgKG1zVW50aWxUaW1lb3V0ID4gMTApIHtcbiAgICAgICAgICAgIHZhciBuZXh0TGFuZXMgPSBnZXROZXh0TGFuZXMocm9vdCwgTm9MYW5lcyk7XG5cbiAgICAgICAgICAgIGlmIChuZXh0TGFuZXMgIT09IE5vTGFuZXMpIHtcbiAgICAgICAgICAgICAgLy8gVGhlcmUncyBhZGRpdGlvbmFsIHdvcmsgb24gdGhpcyByb290LlxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHN1c3BlbmRlZExhbmVzID0gcm9vdC5zdXNwZW5kZWRMYW5lcztcblxuICAgICAgICAgICAgaWYgKCFpc1N1YnNldE9mTGFuZXMoc3VzcGVuZGVkTGFuZXMsIGxhbmVzKSkge1xuICAgICAgICAgICAgICAvLyBXZSBzaG91bGQgcHJlZmVyIHRvIHJlbmRlciB0aGUgZmFsbGJhY2sgb2YgYXQgdGhlIGxhc3RcbiAgICAgICAgICAgICAgLy8gc3VzcGVuZGVkIGxldmVsLiBQaW5nIHRoZSBsYXN0IHN1c3BlbmRlZCBsZXZlbCB0byB0cnlcbiAgICAgICAgICAgICAgLy8gcmVuZGVyaW5nIGl0IGFnYWluLlxuICAgICAgICAgICAgICAvLyBGSVhNRTogV2hhdCBpZiB0aGUgc3VzcGVuZGVkIGxhbmVzIGFyZSBJZGxlPyBTaG91bGQgbm90IHJlc3RhcnQuXG4gICAgICAgICAgICAgIHZhciBldmVudFRpbWUgPSByZXF1ZXN0RXZlbnRUaW1lKCk7XG4gICAgICAgICAgICAgIG1hcmtSb290UGluZ2VkKHJvb3QsIHN1c3BlbmRlZExhbmVzKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9IC8vIFRoZSByZW5kZXIgaXMgc3VzcGVuZGVkLCBpdCBoYXNuJ3QgdGltZWQgb3V0LCBhbmQgdGhlcmUncyBub1xuICAgICAgICAgICAgLy8gbG93ZXIgcHJpb3JpdHkgd29yayB0byBkby4gSW5zdGVhZCBvZiBjb21taXR0aW5nIHRoZSBmYWxsYmFja1xuICAgICAgICAgICAgLy8gaW1tZWRpYXRlbHksIHdhaXQgZm9yIG1vcmUgZGF0YSB0byBhcnJpdmUuXG5cblxuICAgICAgICAgICAgcm9vdC50aW1lb3V0SGFuZGxlID0gc2NoZWR1bGVUaW1lb3V0KGNvbW1pdFJvb3QuYmluZChudWxsLCByb290KSwgbXNVbnRpbFRpbWVvdXQpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9IC8vIFRoZSB3b3JrIGV4cGlyZWQuIENvbW1pdCBpbW1lZGlhdGVseS5cblxuXG4gICAgICAgIGNvbW1pdFJvb3Qocm9vdCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgY2FzZSBSb290U3VzcGVuZGVkV2l0aERlbGF5OlxuICAgICAge1xuICAgICAgICBtYXJrUm9vdFN1c3BlbmRlZCQxKHJvb3QsIGxhbmVzKTtcblxuICAgICAgICBpZiAoaW5jbHVkZXNPbmx5VHJhbnNpdGlvbnMobGFuZXMpKSB7XG4gICAgICAgICAgLy8gVGhpcyBpcyBhIHRyYW5zaXRpb24sIHNvIHdlIHNob3VsZCBleGl0IHdpdGhvdXQgY29tbWl0dGluZyBhXG4gICAgICAgICAgLy8gcGxhY2Vob2xkZXIgYW5kIHdpdGhvdXQgc2NoZWR1bGluZyBhIHRpbWVvdXQuIERlbGF5IGluZGVmaW5pdGVseVxuICAgICAgICAgIC8vIHVudGlsIHdlIHJlY2VpdmUgbW9yZSBkYXRhLlxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFzaG91bGRGb3JjZUZsdXNoRmFsbGJhY2tzSW5ERVYoKSkge1xuICAgICAgICAgIC8vIFRoaXMgaXMgbm90IGEgdHJhbnNpdGlvbiwgYnV0IHdlIGRpZCB0cmlnZ2VyIGFuIGF2b2lkZWQgc3RhdGUuXG4gICAgICAgICAgLy8gU2NoZWR1bGUgYSBwbGFjZWhvbGRlciB0byBkaXNwbGF5IGFmdGVyIGEgc2hvcnQgZGVsYXksIHVzaW5nIHRoZSBKdXN0XG4gICAgICAgICAgLy8gTm90aWNlYWJsZSBEaWZmZXJlbmNlLlxuICAgICAgICAgIC8vIFRPRE86IElzIHRoZSBKTkQgb3B0aW1pemF0aW9uIHdvcnRoIHRoZSBhZGRlZCBjb21wbGV4aXR5PyBJZiB0aGlzIGlzXG4gICAgICAgICAgLy8gdGhlIG9ubHkgcmVhc29uIHdlIHRyYWNrIHRoZSBldmVudCB0aW1lLCB0aGVuIHByb2JhYmx5IG5vdC5cbiAgICAgICAgICAvLyBDb25zaWRlciByZW1vdmluZy5cbiAgICAgICAgICB2YXIgbW9zdFJlY2VudEV2ZW50VGltZSA9IGdldE1vc3RSZWNlbnRFdmVudFRpbWUocm9vdCwgbGFuZXMpO1xuICAgICAgICAgIHZhciBldmVudFRpbWVNcyA9IG1vc3RSZWNlbnRFdmVudFRpbWU7XG4gICAgICAgICAgdmFyIHRpbWVFbGFwc2VkTXMgPSBub3coKSAtIGV2ZW50VGltZU1zO1xuXG4gICAgICAgICAgdmFyIF9tc1VudGlsVGltZW91dCA9IGpuZCh0aW1lRWxhcHNlZE1zKSAtIHRpbWVFbGFwc2VkTXM7IC8vIERvbid0IGJvdGhlciB3aXRoIGEgdmVyeSBzaG9ydCBzdXNwZW5zZSB0aW1lLlxuXG5cbiAgICAgICAgICBpZiAoX21zVW50aWxUaW1lb3V0ID4gMTApIHtcbiAgICAgICAgICAgIC8vIEluc3RlYWQgb2YgY29tbWl0dGluZyB0aGUgZmFsbGJhY2sgaW1tZWRpYXRlbHksIHdhaXQgZm9yIG1vcmUgZGF0YVxuICAgICAgICAgICAgLy8gdG8gYXJyaXZlLlxuICAgICAgICAgICAgcm9vdC50aW1lb3V0SGFuZGxlID0gc2NoZWR1bGVUaW1lb3V0KGNvbW1pdFJvb3QuYmluZChudWxsLCByb290KSwgX21zVW50aWxUaW1lb3V0KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfSAvLyBDb21taXQgdGhlIHBsYWNlaG9sZGVyLlxuXG5cbiAgICAgICAgY29tbWl0Um9vdChyb290KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICBjYXNlIFJvb3RDb21wbGV0ZWQ6XG4gICAgICB7XG4gICAgICAgIC8vIFRoZSB3b3JrIGNvbXBsZXRlZC4gUmVhZHkgdG8gY29tbWl0LlxuICAgICAgICBjb21taXRSb290KHJvb3QpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgIGRlZmF1bHQ6XG4gICAgICB7XG4gICAgICAgIHtcbiAgICAgICAgICB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvciggXCJVbmtub3duIHJvb3QgZXhpdCBzdGF0dXMuXCIgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBtYXJrUm9vdFN1c3BlbmRlZCQxKHJvb3QsIHN1c3BlbmRlZExhbmVzKSB7XG4gIC8vIFdoZW4gc3VzcGVuZGluZywgd2Ugc2hvdWxkIGFsd2F5cyBleGNsdWRlIGxhbmVzIHRoYXQgd2VyZSBwaW5nZWQgb3IgKG1vcmVcbiAgLy8gcmFyZWx5LCBzaW5jZSB3ZSB0cnkgdG8gYXZvaWQgaXQpIHVwZGF0ZWQgZHVyaW5nIHRoZSByZW5kZXIgcGhhc2UuXG4gIC8vIFRPRE86IExvbCBtYXliZSB0aGVyZSdzIGEgYmV0dGVyIHdheSB0byBmYWN0b3IgdGhpcyBiZXNpZGVzIHRoaXNcbiAgLy8gb2Jub3hpb3VzbHkgbmFtZWQgZnVuY3Rpb24gOilcbiAgc3VzcGVuZGVkTGFuZXMgPSByZW1vdmVMYW5lcyhzdXNwZW5kZWRMYW5lcywgd29ya0luUHJvZ3Jlc3NSb290UGluZ2VkTGFuZXMpO1xuICBzdXNwZW5kZWRMYW5lcyA9IHJlbW92ZUxhbmVzKHN1c3BlbmRlZExhbmVzLCB3b3JrSW5Qcm9ncmVzc1Jvb3RVcGRhdGVkTGFuZXMpO1xuICBtYXJrUm9vdFN1c3BlbmRlZChyb290LCBzdXNwZW5kZWRMYW5lcyk7XG59IC8vIFRoaXMgaXMgdGhlIGVudHJ5IHBvaW50IGZvciBzeW5jaHJvbm91cyB0YXNrcyB0aGF0IGRvbid0IGdvXG4vLyB0aHJvdWdoIFNjaGVkdWxlclxuXG5cbmZ1bmN0aW9uIHBlcmZvcm1TeW5jV29ya09uUm9vdChyb290KSB7XG4gIGlmICghKChleGVjdXRpb25Db250ZXh0ICYgKFJlbmRlckNvbnRleHQgfCBDb21taXRDb250ZXh0KSkgPT09IE5vQ29udGV4dCkpIHtcbiAgICB7XG4gICAgICB0aHJvdyBFcnJvciggXCJTaG91bGQgbm90IGFscmVhZHkgYmUgd29ya2luZy5cIiApO1xuICAgIH1cbiAgfVxuXG4gIGZsdXNoUGFzc2l2ZUVmZmVjdHMoKTtcbiAgdmFyIGxhbmVzO1xuICB2YXIgZXhpdFN0YXR1cztcblxuICBpZiAocm9vdCA9PT0gd29ya0luUHJvZ3Jlc3NSb290ICYmIGluY2x1ZGVzU29tZUxhbmUocm9vdC5leHBpcmVkTGFuZXMsIHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzKSkge1xuICAgIC8vIFRoZXJlJ3MgYSBwYXJ0aWFsIHRyZWUsIGFuZCBhdCBsZWFzdCBvbmUgb2YgaXRzIGxhbmVzIGhhcyBleHBpcmVkLiBGaW5pc2hcbiAgICAvLyByZW5kZXJpbmcgaXQgYmVmb3JlIHJlbmRlcmluZyB0aGUgcmVzdCBvZiB0aGUgZXhwaXJlZCB3b3JrLlxuICAgIGxhbmVzID0gd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXM7XG4gICAgZXhpdFN0YXR1cyA9IHJlbmRlclJvb3RTeW5jKHJvb3QsIGxhbmVzKTtcblxuICAgIGlmIChpbmNsdWRlc1NvbWVMYW5lKHdvcmtJblByb2dyZXNzUm9vdEluY2x1ZGVkTGFuZXMsIHdvcmtJblByb2dyZXNzUm9vdFVwZGF0ZWRMYW5lcykpIHtcbiAgICAgIC8vIFRoZSByZW5kZXIgaW5jbHVkZWQgbGFuZXMgdGhhdCB3ZXJlIHVwZGF0ZWQgZHVyaW5nIHRoZSByZW5kZXIgcGhhc2UuXG4gICAgICAvLyBGb3IgZXhhbXBsZSwgd2hlbiB1bmhpZGluZyBhIGhpZGRlbiB0cmVlLCB3ZSBpbmNsdWRlIGFsbCB0aGUgbGFuZXNcbiAgICAgIC8vIHRoYXQgd2VyZSBwcmV2aW91c2x5IHNraXBwZWQgd2hlbiB0aGUgdHJlZSB3YXMgaGlkZGVuLiBUaGF0IHNldCBvZlxuICAgICAgLy8gbGFuZXMgaXMgYSBzdXBlcnNldCBvZiB0aGUgbGFuZXMgd2Ugc3RhcnRlZCByZW5kZXJpbmcgd2l0aC5cbiAgICAgIC8vXG4gICAgICAvLyBOb3RlIHRoYXQgdGhpcyBvbmx5IGhhcHBlbnMgd2hlbiBwYXJ0IG9mIHRoZSB0cmVlIGlzIHJlbmRlcmVkXG4gICAgICAvLyBjb25jdXJyZW50bHkuIElmIHRoZSB3aG9sZSB0cmVlIGlzIHJlbmRlcmVkIHN5bmNocm9ub3VzbHksIHRoZW4gdGhlcmVcbiAgICAgIC8vIGFyZSBubyBpbnRlcmxlYXZlZCBldmVudHMuXG4gICAgICBsYW5lcyA9IGdldE5leHRMYW5lcyhyb290LCBsYW5lcyk7XG4gICAgICBleGl0U3RhdHVzID0gcmVuZGVyUm9vdFN5bmMocm9vdCwgbGFuZXMpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBsYW5lcyA9IGdldE5leHRMYW5lcyhyb290LCBOb0xhbmVzKTtcbiAgICBleGl0U3RhdHVzID0gcmVuZGVyUm9vdFN5bmMocm9vdCwgbGFuZXMpO1xuICB9XG5cbiAgaWYgKHJvb3QudGFnICE9PSBMZWdhY3lSb290ICYmIGV4aXRTdGF0dXMgPT09IFJvb3RFcnJvcmVkKSB7XG4gICAgZXhlY3V0aW9uQ29udGV4dCB8PSBSZXRyeUFmdGVyRXJyb3I7IC8vIElmIGFuIGVycm9yIG9jY3VycmVkIGR1cmluZyBoeWRyYXRpb24sXG4gICAgLy8gZGlzY2FyZCBzZXJ2ZXIgcmVzcG9uc2UgYW5kIGZhbGwgYmFjayB0byBjbGllbnQgc2lkZSByZW5kZXIuXG5cbiAgICBpZiAocm9vdC5oeWRyYXRlKSB7XG4gICAgICByb290Lmh5ZHJhdGUgPSBmYWxzZTtcbiAgICAgIGNsZWFyQ29udGFpbmVyKHJvb3QuY29udGFpbmVySW5mbyk7XG4gICAgfSAvLyBJZiBzb21ldGhpbmcgdGhyZXcgYW4gZXJyb3IsIHRyeSByZW5kZXJpbmcgb25lIG1vcmUgdGltZS4gV2UnbGwgcmVuZGVyXG4gICAgLy8gc3luY2hyb25vdXNseSB0byBibG9jayBjb25jdXJyZW50IGRhdGEgbXV0YXRpb25zLCBhbmQgd2UnbGwgaW5jbHVkZXNcbiAgICAvLyBhbGwgcGVuZGluZyB1cGRhdGVzIGFyZSBpbmNsdWRlZC4gSWYgaXQgc3RpbGwgZmFpbHMgYWZ0ZXIgdGhlIHNlY29uZFxuICAgIC8vIGF0dGVtcHQsIHdlJ2xsIGdpdmUgdXAgYW5kIGNvbW1pdCB0aGUgcmVzdWx0aW5nIHRyZWUuXG5cblxuICAgIGxhbmVzID0gZ2V0TGFuZXNUb1JldHJ5U3luY2hyb25vdXNseU9uRXJyb3Iocm9vdCk7XG5cbiAgICBpZiAobGFuZXMgIT09IE5vTGFuZXMpIHtcbiAgICAgIGV4aXRTdGF0dXMgPSByZW5kZXJSb290U3luYyhyb290LCBsYW5lcyk7XG4gICAgfVxuICB9XG5cbiAgaWYgKGV4aXRTdGF0dXMgPT09IFJvb3RGYXRhbEVycm9yZWQpIHtcbiAgICB2YXIgZmF0YWxFcnJvciA9IHdvcmtJblByb2dyZXNzUm9vdEZhdGFsRXJyb3I7XG4gICAgcHJlcGFyZUZyZXNoU3RhY2socm9vdCwgTm9MYW5lcyk7XG4gICAgbWFya1Jvb3RTdXNwZW5kZWQkMShyb290LCBsYW5lcyk7XG4gICAgZW5zdXJlUm9vdElzU2NoZWR1bGVkKHJvb3QsIG5vdygpKTtcbiAgICB0aHJvdyBmYXRhbEVycm9yO1xuICB9IC8vIFdlIG5vdyBoYXZlIGEgY29uc2lzdGVudCB0cmVlLiBCZWNhdXNlIHRoaXMgaXMgYSBzeW5jIHJlbmRlciwgd2VcbiAgLy8gd2lsbCBjb21taXQgaXQgZXZlbiBpZiBzb21ldGhpbmcgc3VzcGVuZGVkLlxuXG5cbiAgdmFyIGZpbmlzaGVkV29yayA9IHJvb3QuY3VycmVudC5hbHRlcm5hdGU7XG4gIHJvb3QuZmluaXNoZWRXb3JrID0gZmluaXNoZWRXb3JrO1xuICByb290LmZpbmlzaGVkTGFuZXMgPSBsYW5lcztcbiAgY29tbWl0Um9vdChyb290KTsgLy8gQmVmb3JlIGV4aXRpbmcsIG1ha2Ugc3VyZSB0aGVyZSdzIGEgY2FsbGJhY2sgc2NoZWR1bGVkIGZvciB0aGUgbmV4dFxuICAvLyBwZW5kaW5nIGxldmVsLlxuXG4gIGVuc3VyZVJvb3RJc1NjaGVkdWxlZChyb290LCBub3coKSk7XG4gIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gZmx1c2hEaXNjcmV0ZVVwZGF0ZXMoKSB7XG4gIC8vIFRPRE86IFNob3VsZCBiZSBhYmxlIHRvIGZsdXNoIGluc2lkZSBiYXRjaGVkVXBkYXRlcywgYnV0IG5vdCBpbnNpZGUgYGFjdGAuXG4gIC8vIEhvd2V2ZXIsIGBhY3RgIHVzZXMgYGJhdGNoZWRVcGRhdGVzYCwgc28gdGhlcmUncyBubyB3YXkgdG8gZGlzdGluZ3Vpc2hcbiAgLy8gdGhvc2UgdHdvIGNhc2VzLiBOZWVkIHRvIGZpeCB0aGlzIGJlZm9yZSBleHBvc2luZyBmbHVzaERpc2NyZXRlVXBkYXRlc1xuICAvLyBhcyBhIHB1YmxpYyBBUEkuXG4gIGlmICgoZXhlY3V0aW9uQ29udGV4dCAmIChCYXRjaGVkQ29udGV4dCB8IFJlbmRlckNvbnRleHQgfCBDb21taXRDb250ZXh0KSkgIT09IE5vQ29udGV4dCkge1xuICAgIHtcbiAgICAgIGlmICgoZXhlY3V0aW9uQ29udGV4dCAmIFJlbmRlckNvbnRleHQpICE9PSBOb0NvbnRleHQpIHtcbiAgICAgICAgZXJyb3IoJ3Vuc3RhYmxlX2ZsdXNoRGlzY3JldGVVcGRhdGVzOiBDYW5ub3QgZmx1c2ggdXBkYXRlcyB3aGVuIFJlYWN0IGlzICcgKyAnYWxyZWFkeSByZW5kZXJpbmcuJyk7XG4gICAgICB9XG4gICAgfSAvLyBXZSdyZSBhbHJlYWR5IHJlbmRlcmluZywgc28gd2UgY2FuJ3Qgc3luY2hyb25vdXNseSBmbHVzaCBwZW5kaW5nIHdvcmsuXG4gICAgLy8gVGhpcyBpcyBwcm9iYWJseSBhIG5lc3RlZCBldmVudCBkaXNwYXRjaCB0cmlnZ2VyZWQgYnkgYSBsaWZlY3ljbGUvZWZmZWN0LFxuICAgIC8vIGxpa2UgYGVsLmZvY3VzKClgLiBFeGl0LlxuXG5cbiAgICByZXR1cm47XG4gIH1cblxuICBmbHVzaFBlbmRpbmdEaXNjcmV0ZVVwZGF0ZXMoKTsgLy8gSWYgdGhlIGRpc2NyZXRlIHVwZGF0ZXMgc2NoZWR1bGVkIHBhc3NpdmUgZWZmZWN0cywgZmx1c2ggdGhlbSBub3cgc28gdGhhdFxuICAvLyB0aGV5IGZpcmUgYmVmb3JlIHRoZSBuZXh0IHNlcmlhbCBldmVudC5cblxuICBmbHVzaFBhc3NpdmVFZmZlY3RzKCk7XG59XG5cbmZ1bmN0aW9uIGZsdXNoUGVuZGluZ0Rpc2NyZXRlVXBkYXRlcygpIHtcbiAgaWYgKHJvb3RzV2l0aFBlbmRpbmdEaXNjcmV0ZVVwZGF0ZXMgIT09IG51bGwpIHtcbiAgICAvLyBGb3IgZWFjaCByb290IHdpdGggcGVuZGluZyBkaXNjcmV0ZSB1cGRhdGVzLCBzY2hlZHVsZSBhIGNhbGxiYWNrIHRvXG4gICAgLy8gaW1tZWRpYXRlbHkgZmx1c2ggdGhlbS5cbiAgICB2YXIgcm9vdHMgPSByb290c1dpdGhQZW5kaW5nRGlzY3JldGVVcGRhdGVzO1xuICAgIHJvb3RzV2l0aFBlbmRpbmdEaXNjcmV0ZVVwZGF0ZXMgPSBudWxsO1xuICAgIHJvb3RzLmZvckVhY2goZnVuY3Rpb24gKHJvb3QpIHtcbiAgICAgIG1hcmtEaXNjcmV0ZVVwZGF0ZXNFeHBpcmVkKHJvb3QpO1xuICAgICAgZW5zdXJlUm9vdElzU2NoZWR1bGVkKHJvb3QsIG5vdygpKTtcbiAgICB9KTtcbiAgfSAvLyBOb3cgZmx1c2ggdGhlIGltbWVkaWF0ZSBxdWV1ZS5cblxuXG4gIGZsdXNoU3luY0NhbGxiYWNrUXVldWUoKTtcbn1cblxuZnVuY3Rpb24gYmF0Y2hlZFVwZGF0ZXMkMShmbiwgYSkge1xuICB2YXIgcHJldkV4ZWN1dGlvbkNvbnRleHQgPSBleGVjdXRpb25Db250ZXh0O1xuICBleGVjdXRpb25Db250ZXh0IHw9IEJhdGNoZWRDb250ZXh0O1xuXG4gIHRyeSB7XG4gICAgcmV0dXJuIGZuKGEpO1xuICB9IGZpbmFsbHkge1xuICAgIGV4ZWN1dGlvbkNvbnRleHQgPSBwcmV2RXhlY3V0aW9uQ29udGV4dDtcblxuICAgIGlmIChleGVjdXRpb25Db250ZXh0ID09PSBOb0NvbnRleHQpIHtcbiAgICAgIC8vIEZsdXNoIHRoZSBpbW1lZGlhdGUgY2FsbGJhY2tzIHRoYXQgd2VyZSBzY2hlZHVsZWQgZHVyaW5nIHRoaXMgYmF0Y2hcbiAgICAgIHJlc2V0UmVuZGVyVGltZXIoKTtcbiAgICAgIGZsdXNoU3luY0NhbGxiYWNrUXVldWUoKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGJhdGNoZWRFdmVudFVwZGF0ZXMkMShmbiwgYSkge1xuICB2YXIgcHJldkV4ZWN1dGlvbkNvbnRleHQgPSBleGVjdXRpb25Db250ZXh0O1xuICBleGVjdXRpb25Db250ZXh0IHw9IEV2ZW50Q29udGV4dDtcblxuICB0cnkge1xuICAgIHJldHVybiBmbihhKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBleGVjdXRpb25Db250ZXh0ID0gcHJldkV4ZWN1dGlvbkNvbnRleHQ7XG5cbiAgICBpZiAoZXhlY3V0aW9uQ29udGV4dCA9PT0gTm9Db250ZXh0KSB7XG4gICAgICAvLyBGbHVzaCB0aGUgaW1tZWRpYXRlIGNhbGxiYWNrcyB0aGF0IHdlcmUgc2NoZWR1bGVkIGR1cmluZyB0aGlzIGJhdGNoXG4gICAgICByZXNldFJlbmRlclRpbWVyKCk7XG4gICAgICBmbHVzaFN5bmNDYWxsYmFja1F1ZXVlKCk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBkaXNjcmV0ZVVwZGF0ZXMkMShmbiwgYSwgYiwgYywgZCkge1xuICB2YXIgcHJldkV4ZWN1dGlvbkNvbnRleHQgPSBleGVjdXRpb25Db250ZXh0O1xuICBleGVjdXRpb25Db250ZXh0IHw9IERpc2NyZXRlRXZlbnRDb250ZXh0O1xuXG4gIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIHJ1bldpdGhQcmlvcml0eSQxKFVzZXJCbG9ja2luZ1ByaW9yaXR5JDIsIGZuLmJpbmQobnVsbCwgYSwgYiwgYywgZCkpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBleGVjdXRpb25Db250ZXh0ID0gcHJldkV4ZWN1dGlvbkNvbnRleHQ7XG5cbiAgICAgIGlmIChleGVjdXRpb25Db250ZXh0ID09PSBOb0NvbnRleHQpIHtcbiAgICAgICAgLy8gRmx1c2ggdGhlIGltbWVkaWF0ZSBjYWxsYmFja3MgdGhhdCB3ZXJlIHNjaGVkdWxlZCBkdXJpbmcgdGhpcyBiYXRjaFxuICAgICAgICByZXNldFJlbmRlclRpbWVyKCk7XG4gICAgICAgIGZsdXNoU3luY0NhbGxiYWNrUXVldWUoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIHVuYmF0Y2hlZFVwZGF0ZXMoZm4sIGEpIHtcbiAgdmFyIHByZXZFeGVjdXRpb25Db250ZXh0ID0gZXhlY3V0aW9uQ29udGV4dDtcbiAgZXhlY3V0aW9uQ29udGV4dCAmPSB+QmF0Y2hlZENvbnRleHQ7XG4gIGV4ZWN1dGlvbkNvbnRleHQgfD0gTGVnYWN5VW5iYXRjaGVkQ29udGV4dDtcblxuICB0cnkge1xuICAgIHJldHVybiBmbihhKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBleGVjdXRpb25Db250ZXh0ID0gcHJldkV4ZWN1dGlvbkNvbnRleHQ7XG5cbiAgICBpZiAoZXhlY3V0aW9uQ29udGV4dCA9PT0gTm9Db250ZXh0KSB7XG4gICAgICAvLyBGbHVzaCB0aGUgaW1tZWRpYXRlIGNhbGxiYWNrcyB0aGF0IHdlcmUgc2NoZWR1bGVkIGR1cmluZyB0aGlzIGJhdGNoXG4gICAgICByZXNldFJlbmRlclRpbWVyKCk7XG4gICAgICBmbHVzaFN5bmNDYWxsYmFja1F1ZXVlKCk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBmbHVzaFN5bmMoZm4sIGEpIHtcbiAgdmFyIHByZXZFeGVjdXRpb25Db250ZXh0ID0gZXhlY3V0aW9uQ29udGV4dDtcblxuICBpZiAoKHByZXZFeGVjdXRpb25Db250ZXh0ICYgKFJlbmRlckNvbnRleHQgfCBDb21taXRDb250ZXh0KSkgIT09IE5vQ29udGV4dCkge1xuICAgIHtcbiAgICAgIGVycm9yKCdmbHVzaFN5bmMgd2FzIGNhbGxlZCBmcm9tIGluc2lkZSBhIGxpZmVjeWNsZSBtZXRob2QuIFJlYWN0IGNhbm5vdCAnICsgJ2ZsdXNoIHdoZW4gUmVhY3QgaXMgYWxyZWFkeSByZW5kZXJpbmcuIENvbnNpZGVyIG1vdmluZyB0aGlzIGNhbGwgdG8gJyArICdhIHNjaGVkdWxlciB0YXNrIG9yIG1pY3JvIHRhc2suJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZuKGEpO1xuICB9XG5cbiAgZXhlY3V0aW9uQ29udGV4dCB8PSBCYXRjaGVkQ29udGV4dDtcblxuICB7XG4gICAgdHJ5IHtcbiAgICAgIGlmIChmbikge1xuICAgICAgICByZXR1cm4gcnVuV2l0aFByaW9yaXR5JDEoSW1tZWRpYXRlUHJpb3JpdHkkMSwgZm4uYmluZChudWxsLCBhKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgIH0gZmluYWxseSB7XG4gICAgICBleGVjdXRpb25Db250ZXh0ID0gcHJldkV4ZWN1dGlvbkNvbnRleHQ7IC8vIEZsdXNoIHRoZSBpbW1lZGlhdGUgY2FsbGJhY2tzIHRoYXQgd2VyZSBzY2hlZHVsZWQgZHVyaW5nIHRoaXMgYmF0Y2guXG4gICAgICAvLyBOb3RlIHRoYXQgdGhpcyB3aWxsIGhhcHBlbiBldmVuIGlmIGJhdGNoZWRVcGRhdGVzIGlzIGhpZ2hlciB1cFxuICAgICAgLy8gdGhlIHN0YWNrLlxuXG4gICAgICBmbHVzaFN5bmNDYWxsYmFja1F1ZXVlKCk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBwdXNoUmVuZGVyTGFuZXMoZmliZXIsIGxhbmVzKSB7XG4gIHB1c2goc3VidHJlZVJlbmRlckxhbmVzQ3Vyc29yLCBzdWJ0cmVlUmVuZGVyTGFuZXMsIGZpYmVyKTtcbiAgc3VidHJlZVJlbmRlckxhbmVzID0gbWVyZ2VMYW5lcyhzdWJ0cmVlUmVuZGVyTGFuZXMsIGxhbmVzKTtcbiAgd29ya0luUHJvZ3Jlc3NSb290SW5jbHVkZWRMYW5lcyA9IG1lcmdlTGFuZXMod29ya0luUHJvZ3Jlc3NSb290SW5jbHVkZWRMYW5lcywgbGFuZXMpO1xufVxuZnVuY3Rpb24gcG9wUmVuZGVyTGFuZXMoZmliZXIpIHtcbiAgc3VidHJlZVJlbmRlckxhbmVzID0gc3VidHJlZVJlbmRlckxhbmVzQ3Vyc29yLmN1cnJlbnQ7XG4gIHBvcChzdWJ0cmVlUmVuZGVyTGFuZXNDdXJzb3IsIGZpYmVyKTtcbn1cblxuZnVuY3Rpb24gcHJlcGFyZUZyZXNoU3RhY2socm9vdCwgbGFuZXMpIHtcbiAgcm9vdC5maW5pc2hlZFdvcmsgPSBudWxsO1xuICByb290LmZpbmlzaGVkTGFuZXMgPSBOb0xhbmVzO1xuICB2YXIgdGltZW91dEhhbmRsZSA9IHJvb3QudGltZW91dEhhbmRsZTtcblxuICBpZiAodGltZW91dEhhbmRsZSAhPT0gbm9UaW1lb3V0KSB7XG4gICAgLy8gVGhlIHJvb3QgcHJldmlvdXMgc3VzcGVuZGVkIGFuZCBzY2hlZHVsZWQgYSB0aW1lb3V0IHRvIGNvbW1pdCBhIGZhbGxiYWNrXG4gICAgLy8gc3RhdGUuIE5vdyB0aGF0IHdlIGhhdmUgYWRkaXRpb25hbCB3b3JrLCBjYW5jZWwgdGhlIHRpbWVvdXQuXG4gICAgcm9vdC50aW1lb3V0SGFuZGxlID0gbm9UaW1lb3V0OyAvLyAkRmxvd0ZpeE1lIENvbXBsYWlucyBub1RpbWVvdXQgaXMgbm90IGEgVGltZW91dElELCBkZXNwaXRlIHRoZSBjaGVjayBhYm92ZVxuXG4gICAgY2FuY2VsVGltZW91dCh0aW1lb3V0SGFuZGxlKTtcbiAgfVxuXG4gIGlmICh3b3JrSW5Qcm9ncmVzcyAhPT0gbnVsbCkge1xuICAgIHZhciBpbnRlcnJ1cHRlZFdvcmsgPSB3b3JrSW5Qcm9ncmVzcy5yZXR1cm47XG5cbiAgICB3aGlsZSAoaW50ZXJydXB0ZWRXb3JrICE9PSBudWxsKSB7XG4gICAgICB1bndpbmRJbnRlcnJ1cHRlZFdvcmsoaW50ZXJydXB0ZWRXb3JrKTtcbiAgICAgIGludGVycnVwdGVkV29yayA9IGludGVycnVwdGVkV29yay5yZXR1cm47XG4gICAgfVxuICB9XG5cbiAgd29ya0luUHJvZ3Jlc3NSb290ID0gcm9vdDtcbiAgd29ya0luUHJvZ3Jlc3MgPSBjcmVhdGVXb3JrSW5Qcm9ncmVzcyhyb290LmN1cnJlbnQsIG51bGwpO1xuICB3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcyA9IHN1YnRyZWVSZW5kZXJMYW5lcyA9IHdvcmtJblByb2dyZXNzUm9vdEluY2x1ZGVkTGFuZXMgPSBsYW5lcztcbiAgd29ya0luUHJvZ3Jlc3NSb290RXhpdFN0YXR1cyA9IFJvb3RJbmNvbXBsZXRlO1xuICB3b3JrSW5Qcm9ncmVzc1Jvb3RGYXRhbEVycm9yID0gbnVsbDtcbiAgd29ya0luUHJvZ3Jlc3NSb290U2tpcHBlZExhbmVzID0gTm9MYW5lcztcbiAgd29ya0luUHJvZ3Jlc3NSb290VXBkYXRlZExhbmVzID0gTm9MYW5lcztcbiAgd29ya0luUHJvZ3Jlc3NSb290UGluZ2VkTGFuZXMgPSBOb0xhbmVzO1xuXG4gIHtcbiAgICBzcGF3bmVkV29ya0R1cmluZ1JlbmRlciA9IG51bGw7XG4gIH1cblxuICB7XG4gICAgUmVhY3RTdHJpY3RNb2RlV2FybmluZ3MuZGlzY2FyZFBlbmRpbmdXYXJuaW5ncygpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGhhbmRsZUVycm9yKHJvb3QsIHRocm93blZhbHVlKSB7XG4gIGRvIHtcbiAgICB2YXIgZXJyb3JlZFdvcmsgPSB3b3JrSW5Qcm9ncmVzcztcblxuICAgIHRyeSB7XG4gICAgICAvLyBSZXNldCBtb2R1bGUtbGV2ZWwgc3RhdGUgdGhhdCB3YXMgc2V0IGR1cmluZyB0aGUgcmVuZGVyIHBoYXNlLlxuICAgICAgcmVzZXRDb250ZXh0RGVwZW5kZW5jaWVzKCk7XG4gICAgICByZXNldEhvb2tzQWZ0ZXJUaHJvdygpO1xuICAgICAgcmVzZXRDdXJyZW50RmliZXIoKTsgLy8gVE9ETzogSSBmb3VuZCBhbmQgYWRkZWQgdGhpcyBtaXNzaW5nIGxpbmUgd2hpbGUgaW52ZXN0aWdhdGluZyBhXG4gICAgICAvLyBzZXBhcmF0ZSBpc3N1ZS4gV3JpdGUgYSByZWdyZXNzaW9uIHRlc3QgdXNpbmcgc3RyaW5nIHJlZnMuXG5cbiAgICAgIFJlYWN0Q3VycmVudE93bmVyJDIuY3VycmVudCA9IG51bGw7XG5cbiAgICAgIGlmIChlcnJvcmVkV29yayA9PT0gbnVsbCB8fCBlcnJvcmVkV29yay5yZXR1cm4gPT09IG51bGwpIHtcbiAgICAgICAgLy8gRXhwZWN0ZWQgdG8gYmUgd29ya2luZyBvbiBhIG5vbi1yb290IGZpYmVyLiBUaGlzIGlzIGEgZmF0YWwgZXJyb3JcbiAgICAgICAgLy8gYmVjYXVzZSB0aGVyZSdzIG5vIGFuY2VzdG9yIHRoYXQgY2FuIGhhbmRsZSBpdDsgdGhlIHJvb3QgaXNcbiAgICAgICAgLy8gc3VwcG9zZWQgdG8gY2FwdHVyZSBhbGwgZXJyb3JzIHRoYXQgd2VyZW4ndCBjYXVnaHQgYnkgYW4gZXJyb3JcbiAgICAgICAgLy8gYm91bmRhcnkuXG4gICAgICAgIHdvcmtJblByb2dyZXNzUm9vdEV4aXRTdGF0dXMgPSBSb290RmF0YWxFcnJvcmVkO1xuICAgICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RGYXRhbEVycm9yID0gdGhyb3duVmFsdWU7IC8vIFNldCBgd29ya0luUHJvZ3Jlc3NgIHRvIG51bGwuIFRoaXMgcmVwcmVzZW50cyBhZHZhbmNpbmcgdG8gdGhlIG5leHRcbiAgICAgICAgLy8gc2libGluZywgb3IgdGhlIHBhcmVudCBpZiB0aGVyZSBhcmUgbm8gc2libGluZ3MuIEJ1dCBzaW5jZSB0aGUgcm9vdFxuICAgICAgICAvLyBoYXMgbm8gc2libGluZ3Mgbm9yIGEgcGFyZW50LCB3ZSBzZXQgaXQgdG8gbnVsbC4gVXN1YWxseSB0aGlzIGlzXG4gICAgICAgIC8vIGhhbmRsZWQgYnkgYGNvbXBsZXRlVW5pdE9mV29ya2Agb3IgYHVud2luZFdvcmtgLCBidXQgc2luY2Ugd2UncmVcbiAgICAgICAgLy8gaW50ZW50aW9uYWxseSBub3QgY2FsbGluZyB0aG9zZSwgd2UgbmVlZCBzZXQgaXQgaGVyZS5cbiAgICAgICAgLy8gVE9ETzogQ29uc2lkZXIgY2FsbGluZyBgdW53aW5kV29ya2AgdG8gcG9wIHRoZSBjb250ZXh0cy5cblxuICAgICAgICB3b3JrSW5Qcm9ncmVzcyA9IG51bGw7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKGVuYWJsZVByb2ZpbGVyVGltZXIgJiYgZXJyb3JlZFdvcmsubW9kZSAmIFByb2ZpbGVNb2RlKSB7XG4gICAgICAgIC8vIFJlY29yZCB0aGUgdGltZSBzcGVudCByZW5kZXJpbmcgYmVmb3JlIGFuIGVycm9yIHdhcyB0aHJvd24uIFRoaXNcbiAgICAgICAgLy8gYXZvaWRzIGluYWNjdXJhdGUgUHJvZmlsZXIgZHVyYXRpb25zIGluIHRoZSBjYXNlIG9mIGFcbiAgICAgICAgLy8gc3VzcGVuZGVkIHJlbmRlci5cbiAgICAgICAgc3RvcFByb2ZpbGVyVGltZXJJZlJ1bm5pbmdBbmRSZWNvcmREZWx0YShlcnJvcmVkV29yaywgdHJ1ZSk7XG4gICAgICB9XG5cbiAgICAgIHRocm93RXhjZXB0aW9uKHJvb3QsIGVycm9yZWRXb3JrLnJldHVybiwgZXJyb3JlZFdvcmssIHRocm93blZhbHVlLCB3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcyk7XG4gICAgICBjb21wbGV0ZVVuaXRPZldvcmsoZXJyb3JlZFdvcmspO1xuICAgIH0gY2F0Y2ggKHlldEFub3RoZXJUaHJvd25WYWx1ZSkge1xuICAgICAgLy8gU29tZXRoaW5nIGluIHRoZSByZXR1cm4gcGF0aCBhbHNvIHRocmV3LlxuICAgICAgdGhyb3duVmFsdWUgPSB5ZXRBbm90aGVyVGhyb3duVmFsdWU7XG5cbiAgICAgIGlmICh3b3JrSW5Qcm9ncmVzcyA9PT0gZXJyb3JlZFdvcmsgJiYgZXJyb3JlZFdvcmsgIT09IG51bGwpIHtcbiAgICAgICAgLy8gSWYgdGhpcyBib3VuZGFyeSBoYXMgYWxyZWFkeSBlcnJvcmVkLCB0aGVuIHdlIGhhZCB0cm91YmxlIHByb2Nlc3NpbmdcbiAgICAgICAgLy8gdGhlIGVycm9yLiBCdWJibGUgaXQgdG8gdGhlIG5leHQgYm91bmRhcnkuXG4gICAgICAgIGVycm9yZWRXb3JrID0gZXJyb3JlZFdvcmsucmV0dXJuO1xuICAgICAgICB3b3JrSW5Qcm9ncmVzcyA9IGVycm9yZWRXb3JrO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZXJyb3JlZFdvcmsgPSB3b3JrSW5Qcm9ncmVzcztcbiAgICAgIH1cblxuICAgICAgY29udGludWU7XG4gICAgfSAvLyBSZXR1cm4gdG8gdGhlIG5vcm1hbCB3b3JrIGxvb3AuXG5cblxuICAgIHJldHVybjtcbiAgfSB3aGlsZSAodHJ1ZSk7XG59XG5cbmZ1bmN0aW9uIHB1c2hEaXNwYXRjaGVyKCkge1xuICB2YXIgcHJldkRpc3BhdGNoZXIgPSBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDIuY3VycmVudDtcbiAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQyLmN1cnJlbnQgPSBDb250ZXh0T25seURpc3BhdGNoZXI7XG5cbiAgaWYgKHByZXZEaXNwYXRjaGVyID09PSBudWxsKSB7XG4gICAgLy8gVGhlIFJlYWN0IGlzb21vcnBoaWMgcGFja2FnZSBkb2VzIG5vdCBpbmNsdWRlIGEgZGVmYXVsdCBkaXNwYXRjaGVyLlxuICAgIC8vIEluc3RlYWQgdGhlIGZpcnN0IHJlbmRlcmVyIHdpbGwgbGF6aWx5IGF0dGFjaCBvbmUsIGluIG9yZGVyIHRvIGdpdmVcbiAgICAvLyBuaWNlciBlcnJvciBtZXNzYWdlcy5cbiAgICByZXR1cm4gQ29udGV4dE9ubHlEaXNwYXRjaGVyO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBwcmV2RGlzcGF0Y2hlcjtcbiAgfVxufVxuXG5mdW5jdGlvbiBwb3BEaXNwYXRjaGVyKHByZXZEaXNwYXRjaGVyKSB7XG4gIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMi5jdXJyZW50ID0gcHJldkRpc3BhdGNoZXI7XG59XG5cbmZ1bmN0aW9uIHB1c2hJbnRlcmFjdGlvbnMocm9vdCkge1xuICB7XG4gICAgdmFyIHByZXZJbnRlcmFjdGlvbnMgPSB0cmFjaW5nLl9faW50ZXJhY3Rpb25zUmVmLmN1cnJlbnQ7XG4gICAgdHJhY2luZy5fX2ludGVyYWN0aW9uc1JlZi5jdXJyZW50ID0gcm9vdC5tZW1vaXplZEludGVyYWN0aW9ucztcbiAgICByZXR1cm4gcHJldkludGVyYWN0aW9ucztcbiAgfVxufVxuXG5mdW5jdGlvbiBwb3BJbnRlcmFjdGlvbnMocHJldkludGVyYWN0aW9ucykge1xuICB7XG4gICAgdHJhY2luZy5fX2ludGVyYWN0aW9uc1JlZi5jdXJyZW50ID0gcHJldkludGVyYWN0aW9ucztcbiAgfVxufVxuXG5mdW5jdGlvbiBtYXJrQ29tbWl0VGltZU9mRmFsbGJhY2soKSB7XG4gIGdsb2JhbE1vc3RSZWNlbnRGYWxsYmFja1RpbWUgPSBub3coKTtcbn1cbmZ1bmN0aW9uIG1hcmtTa2lwcGVkVXBkYXRlTGFuZXMobGFuZSkge1xuICB3b3JrSW5Qcm9ncmVzc1Jvb3RTa2lwcGVkTGFuZXMgPSBtZXJnZUxhbmVzKGxhbmUsIHdvcmtJblByb2dyZXNzUm9vdFNraXBwZWRMYW5lcyk7XG59XG5mdW5jdGlvbiByZW5kZXJEaWRTdXNwZW5kKCkge1xuICBpZiAod29ya0luUHJvZ3Jlc3NSb290RXhpdFN0YXR1cyA9PT0gUm9vdEluY29tcGxldGUpIHtcbiAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RFeGl0U3RhdHVzID0gUm9vdFN1c3BlbmRlZDtcbiAgfVxufVxuZnVuY3Rpb24gcmVuZGVyRGlkU3VzcGVuZERlbGF5SWZQb3NzaWJsZSgpIHtcbiAgaWYgKHdvcmtJblByb2dyZXNzUm9vdEV4aXRTdGF0dXMgPT09IFJvb3RJbmNvbXBsZXRlIHx8IHdvcmtJblByb2dyZXNzUm9vdEV4aXRTdGF0dXMgPT09IFJvb3RTdXNwZW5kZWQpIHtcbiAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RFeGl0U3RhdHVzID0gUm9vdFN1c3BlbmRlZFdpdGhEZWxheTtcbiAgfSAvLyBDaGVjayBpZiB0aGVyZSBhcmUgdXBkYXRlcyB0aGF0IHdlIHNraXBwZWQgdHJlZSB0aGF0IG1pZ2h0IGhhdmUgdW5ibG9ja2VkXG4gIC8vIHRoaXMgcmVuZGVyLlxuXG5cbiAgaWYgKHdvcmtJblByb2dyZXNzUm9vdCAhPT0gbnVsbCAmJiAoaW5jbHVkZXNOb25JZGxlV29yayh3b3JrSW5Qcm9ncmVzc1Jvb3RTa2lwcGVkTGFuZXMpIHx8IGluY2x1ZGVzTm9uSWRsZVdvcmsod29ya0luUHJvZ3Jlc3NSb290VXBkYXRlZExhbmVzKSkpIHtcbiAgICAvLyBNYXJrIHRoZSBjdXJyZW50IHJlbmRlciBhcyBzdXNwZW5kZWQgc28gdGhhdCB3ZSBzd2l0Y2ggdG8gd29ya2luZyBvblxuICAgIC8vIHRoZSB1cGRhdGVzIHRoYXQgd2VyZSBza2lwcGVkLiBVc3VhbGx5IHdlIG9ubHkgc3VzcGVuZCBhdCB0aGUgZW5kIG9mXG4gICAgLy8gdGhlIHJlbmRlciBwaGFzZS5cbiAgICAvLyBUT0RPOiBXZSBzaG91bGQgcHJvYmFibHkgYWx3YXlzIG1hcmsgdGhlIHJvb3QgYXMgc3VzcGVuZGVkIGltbWVkaWF0ZWx5XG4gICAgLy8gKGluc2lkZSB0aGlzIGZ1bmN0aW9uKSwgc2luY2UgYnkgc3VzcGVuZGluZyBhdCB0aGUgZW5kIG9mIHRoZSByZW5kZXJcbiAgICAvLyBwaGFzZSBpbnRyb2R1Y2VzIGEgcG90ZW50aWFsIG1pc3Rha2Ugd2hlcmUgd2Ugc3VzcGVuZCBsYW5lcyB0aGF0IHdlcmVcbiAgICAvLyBwaW5nZWQgb3IgdXBkYXRlZCB3aGlsZSB3ZSB3ZXJlIHJlbmRlcmluZy5cbiAgICBtYXJrUm9vdFN1c3BlbmRlZCQxKHdvcmtJblByb2dyZXNzUm9vdCwgd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMpO1xuICB9XG59XG5mdW5jdGlvbiByZW5kZXJEaWRFcnJvcigpIHtcbiAgaWYgKHdvcmtJblByb2dyZXNzUm9vdEV4aXRTdGF0dXMgIT09IFJvb3RDb21wbGV0ZWQpIHtcbiAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RFeGl0U3RhdHVzID0gUm9vdEVycm9yZWQ7XG4gIH1cbn0gLy8gQ2FsbGVkIGR1cmluZyByZW5kZXIgdG8gZGV0ZXJtaW5lIGlmIGFueXRoaW5nIGhhcyBzdXNwZW5kZWQuXG4vLyBSZXR1cm5zIGZhbHNlIGlmIHdlJ3JlIG5vdCBzdXJlLlxuXG5mdW5jdGlvbiByZW5kZXJIYXNOb3RTdXNwZW5kZWRZZXQoKSB7XG4gIC8vIElmIHNvbWV0aGluZyBlcnJvcmVkIG9yIGNvbXBsZXRlZCwgd2UgY2FuJ3QgcmVhbGx5IGJlIHN1cmUsXG4gIC8vIHNvIHRob3NlIGFyZSBmYWxzZS5cbiAgcmV0dXJuIHdvcmtJblByb2dyZXNzUm9vdEV4aXRTdGF0dXMgPT09IFJvb3RJbmNvbXBsZXRlO1xufVxuXG5mdW5jdGlvbiByZW5kZXJSb290U3luYyhyb290LCBsYW5lcykge1xuICB2YXIgcHJldkV4ZWN1dGlvbkNvbnRleHQgPSBleGVjdXRpb25Db250ZXh0O1xuICBleGVjdXRpb25Db250ZXh0IHw9IFJlbmRlckNvbnRleHQ7XG4gIHZhciBwcmV2RGlzcGF0Y2hlciA9IHB1c2hEaXNwYXRjaGVyKCk7IC8vIElmIHRoZSByb290IG9yIGxhbmVzIGhhdmUgY2hhbmdlZCwgdGhyb3cgb3V0IHRoZSBleGlzdGluZyBzdGFja1xuICAvLyBhbmQgcHJlcGFyZSBhIGZyZXNoIG9uZS4gT3RoZXJ3aXNlIHdlJ2xsIGNvbnRpbnVlIHdoZXJlIHdlIGxlZnQgb2ZmLlxuXG4gIGlmICh3b3JrSW5Qcm9ncmVzc1Jvb3QgIT09IHJvb3QgfHwgd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMgIT09IGxhbmVzKSB7XG4gICAgcHJlcGFyZUZyZXNoU3RhY2socm9vdCwgbGFuZXMpO1xuICAgIHN0YXJ0V29ya09uUGVuZGluZ0ludGVyYWN0aW9ucyhyb290LCBsYW5lcyk7XG4gIH1cblxuICB2YXIgcHJldkludGVyYWN0aW9ucyA9IHB1c2hJbnRlcmFjdGlvbnMocm9vdCk7XG5cbiAgZG8ge1xuICAgIHRyeSB7XG4gICAgICB3b3JrTG9vcFN5bmMoKTtcbiAgICAgIGJyZWFrO1xuICAgIH0gY2F0Y2ggKHRocm93blZhbHVlKSB7XG4gICAgICBoYW5kbGVFcnJvcihyb290LCB0aHJvd25WYWx1ZSk7XG4gICAgfVxuICB9IHdoaWxlICh0cnVlKTtcblxuICByZXNldENvbnRleHREZXBlbmRlbmNpZXMoKTtcblxuICB7XG4gICAgcG9wSW50ZXJhY3Rpb25zKHByZXZJbnRlcmFjdGlvbnMpO1xuICB9XG5cbiAgZXhlY3V0aW9uQ29udGV4dCA9IHByZXZFeGVjdXRpb25Db250ZXh0O1xuICBwb3BEaXNwYXRjaGVyKHByZXZEaXNwYXRjaGVyKTtcblxuICBpZiAod29ya0luUHJvZ3Jlc3MgIT09IG51bGwpIHtcbiAgICAvLyBUaGlzIGlzIGEgc3luYyByZW5kZXIsIHNvIHdlIHNob3VsZCBoYXZlIGZpbmlzaGVkIHRoZSB3aG9sZSB0cmVlLlxuICAgIHtcbiAgICAgIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoIFwiQ2Fubm90IGNvbW1pdCBhbiBpbmNvbXBsZXRlIHJvb3QuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCIgKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuXG4gIHdvcmtJblByb2dyZXNzUm9vdCA9IG51bGw7XG4gIHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzID0gTm9MYW5lcztcbiAgcmV0dXJuIHdvcmtJblByb2dyZXNzUm9vdEV4aXRTdGF0dXM7XG59IC8vIFRoZSB3b3JrIGxvb3AgaXMgYW4gZXh0cmVtZWx5IGhvdCBwYXRoLiBUZWxsIENsb3N1cmUgbm90IHRvIGlubGluZSBpdC5cblxuLyoqIEBub2lubGluZSAqL1xuXG5cbmZ1bmN0aW9uIHdvcmtMb29wU3luYygpIHtcbiAgLy8gQWxyZWFkeSB0aW1lZCBvdXQsIHNvIHBlcmZvcm0gd29yayB3aXRob3V0IGNoZWNraW5nIGlmIHdlIG5lZWQgdG8geWllbGQuXG4gIHdoaWxlICh3b3JrSW5Qcm9ncmVzcyAhPT0gbnVsbCkge1xuICAgIHBlcmZvcm1Vbml0T2ZXb3JrKHdvcmtJblByb2dyZXNzKTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZW5kZXJSb290Q29uY3VycmVudChyb290LCBsYW5lcykge1xuICB2YXIgcHJldkV4ZWN1dGlvbkNvbnRleHQgPSBleGVjdXRpb25Db250ZXh0O1xuICBleGVjdXRpb25Db250ZXh0IHw9IFJlbmRlckNvbnRleHQ7XG4gIHZhciBwcmV2RGlzcGF0Y2hlciA9IHB1c2hEaXNwYXRjaGVyKCk7IC8vIElmIHRoZSByb290IG9yIGxhbmVzIGhhdmUgY2hhbmdlZCwgdGhyb3cgb3V0IHRoZSBleGlzdGluZyBzdGFja1xuICAvLyBhbmQgcHJlcGFyZSBhIGZyZXNoIG9uZS4gT3RoZXJ3aXNlIHdlJ2xsIGNvbnRpbnVlIHdoZXJlIHdlIGxlZnQgb2ZmLlxuXG4gIGlmICh3b3JrSW5Qcm9ncmVzc1Jvb3QgIT09IHJvb3QgfHwgd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMgIT09IGxhbmVzKSB7XG4gICAgcmVzZXRSZW5kZXJUaW1lcigpO1xuICAgIHByZXBhcmVGcmVzaFN0YWNrKHJvb3QsIGxhbmVzKTtcbiAgICBzdGFydFdvcmtPblBlbmRpbmdJbnRlcmFjdGlvbnMocm9vdCwgbGFuZXMpO1xuICB9XG5cbiAgdmFyIHByZXZJbnRlcmFjdGlvbnMgPSBwdXNoSW50ZXJhY3Rpb25zKHJvb3QpO1xuXG4gIGRvIHtcbiAgICB0cnkge1xuICAgICAgd29ya0xvb3BDb25jdXJyZW50KCk7XG4gICAgICBicmVhaztcbiAgICB9IGNhdGNoICh0aHJvd25WYWx1ZSkge1xuICAgICAgaGFuZGxlRXJyb3Iocm9vdCwgdGhyb3duVmFsdWUpO1xuICAgIH1cbiAgfSB3aGlsZSAodHJ1ZSk7XG5cbiAgcmVzZXRDb250ZXh0RGVwZW5kZW5jaWVzKCk7XG5cbiAge1xuICAgIHBvcEludGVyYWN0aW9ucyhwcmV2SW50ZXJhY3Rpb25zKTtcbiAgfVxuXG4gIHBvcERpc3BhdGNoZXIocHJldkRpc3BhdGNoZXIpO1xuICBleGVjdXRpb25Db250ZXh0ID0gcHJldkV4ZWN1dGlvbkNvbnRleHQ7XG5cblxuICBpZiAod29ya0luUHJvZ3Jlc3MgIT09IG51bGwpIHtcblxuICAgIHJldHVybiBSb290SW5jb21wbGV0ZTtcbiAgfSBlbHNlIHtcblxuXG4gICAgd29ya0luUHJvZ3Jlc3NSb290ID0gbnVsbDtcbiAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcyA9IE5vTGFuZXM7IC8vIFJldHVybiB0aGUgZmluYWwgZXhpdCBzdGF0dXMuXG5cbiAgICByZXR1cm4gd29ya0luUHJvZ3Jlc3NSb290RXhpdFN0YXR1cztcbiAgfVxufVxuLyoqIEBub2lubGluZSAqL1xuXG5cbmZ1bmN0aW9uIHdvcmtMb29wQ29uY3VycmVudCgpIHtcbiAgLy8gUGVyZm9ybSB3b3JrIHVudGlsIFNjaGVkdWxlciBhc2tzIHVzIHRvIHlpZWxkXG4gIHdoaWxlICh3b3JrSW5Qcm9ncmVzcyAhPT0gbnVsbCAmJiAhc2hvdWxkWWllbGQoKSkge1xuICAgIHBlcmZvcm1Vbml0T2ZXb3JrKHdvcmtJblByb2dyZXNzKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwZXJmb3JtVW5pdE9mV29yayh1bml0T2ZXb3JrKSB7XG4gIC8vIFRoZSBjdXJyZW50LCBmbHVzaGVkLCBzdGF0ZSBvZiB0aGlzIGZpYmVyIGlzIHRoZSBhbHRlcm5hdGUuIElkZWFsbHlcbiAgLy8gbm90aGluZyBzaG91bGQgcmVseSBvbiB0aGlzLCBidXQgcmVseWluZyBvbiBpdCBoZXJlIG1lYW5zIHRoYXQgd2UgZG9uJ3RcbiAgLy8gbmVlZCBhbiBhZGRpdGlvbmFsIGZpZWxkIG9uIHRoZSB3b3JrIGluIHByb2dyZXNzLlxuICB2YXIgY3VycmVudCA9IHVuaXRPZldvcmsuYWx0ZXJuYXRlO1xuICBzZXRDdXJyZW50RmliZXIodW5pdE9mV29yayk7XG4gIHZhciBuZXh0O1xuXG4gIGlmICggKHVuaXRPZldvcmsubW9kZSAmIFByb2ZpbGVNb2RlKSAhPT0gTm9Nb2RlKSB7XG4gICAgc3RhcnRQcm9maWxlclRpbWVyKHVuaXRPZldvcmspO1xuICAgIG5leHQgPSBiZWdpbldvcmskMShjdXJyZW50LCB1bml0T2ZXb3JrLCBzdWJ0cmVlUmVuZGVyTGFuZXMpO1xuICAgIHN0b3BQcm9maWxlclRpbWVySWZSdW5uaW5nQW5kUmVjb3JkRGVsdGEodW5pdE9mV29yaywgdHJ1ZSk7XG4gIH0gZWxzZSB7XG4gICAgbmV4dCA9IGJlZ2luV29yayQxKGN1cnJlbnQsIHVuaXRPZldvcmssIHN1YnRyZWVSZW5kZXJMYW5lcyk7XG4gIH1cblxuICByZXNldEN1cnJlbnRGaWJlcigpO1xuICB1bml0T2ZXb3JrLm1lbW9pemVkUHJvcHMgPSB1bml0T2ZXb3JrLnBlbmRpbmdQcm9wcztcblxuICBpZiAobmV4dCA9PT0gbnVsbCkge1xuICAgIC8vIElmIHRoaXMgZG9lc24ndCBzcGF3biBuZXcgd29yaywgY29tcGxldGUgdGhlIGN1cnJlbnQgd29yay5cbiAgICBjb21wbGV0ZVVuaXRPZldvcmsodW5pdE9mV29yayk7XG4gIH0gZWxzZSB7XG4gICAgd29ya0luUHJvZ3Jlc3MgPSBuZXh0O1xuICB9XG5cbiAgUmVhY3RDdXJyZW50T3duZXIkMi5jdXJyZW50ID0gbnVsbDtcbn1cblxuZnVuY3Rpb24gY29tcGxldGVVbml0T2ZXb3JrKHVuaXRPZldvcmspIHtcbiAgLy8gQXR0ZW1wdCB0byBjb21wbGV0ZSB0aGUgY3VycmVudCB1bml0IG9mIHdvcmssIHRoZW4gbW92ZSB0byB0aGUgbmV4dFxuICAvLyBzaWJsaW5nLiBJZiB0aGVyZSBhcmUgbm8gbW9yZSBzaWJsaW5ncywgcmV0dXJuIHRvIHRoZSBwYXJlbnQgZmliZXIuXG4gIHZhciBjb21wbGV0ZWRXb3JrID0gdW5pdE9mV29yaztcblxuICBkbyB7XG4gICAgLy8gVGhlIGN1cnJlbnQsIGZsdXNoZWQsIHN0YXRlIG9mIHRoaXMgZmliZXIgaXMgdGhlIGFsdGVybmF0ZS4gSWRlYWxseVxuICAgIC8vIG5vdGhpbmcgc2hvdWxkIHJlbHkgb24gdGhpcywgYnV0IHJlbHlpbmcgb24gaXQgaGVyZSBtZWFucyB0aGF0IHdlIGRvbid0XG4gICAgLy8gbmVlZCBhbiBhZGRpdGlvbmFsIGZpZWxkIG9uIHRoZSB3b3JrIGluIHByb2dyZXNzLlxuICAgIHZhciBjdXJyZW50ID0gY29tcGxldGVkV29yay5hbHRlcm5hdGU7XG4gICAgdmFyIHJldHVybkZpYmVyID0gY29tcGxldGVkV29yay5yZXR1cm47IC8vIENoZWNrIGlmIHRoZSB3b3JrIGNvbXBsZXRlZCBvciBpZiBzb21ldGhpbmcgdGhyZXcuXG5cbiAgICBpZiAoKGNvbXBsZXRlZFdvcmsuZmxhZ3MgJiBJbmNvbXBsZXRlKSA9PT0gTm9GbGFncykge1xuICAgICAgc2V0Q3VycmVudEZpYmVyKGNvbXBsZXRlZFdvcmspO1xuICAgICAgdmFyIG5leHQgPSB2b2lkIDA7XG5cbiAgICAgIGlmICggKGNvbXBsZXRlZFdvcmsubW9kZSAmIFByb2ZpbGVNb2RlKSA9PT0gTm9Nb2RlKSB7XG4gICAgICAgIG5leHQgPSBjb21wbGV0ZVdvcmsoY3VycmVudCwgY29tcGxldGVkV29yaywgc3VidHJlZVJlbmRlckxhbmVzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0YXJ0UHJvZmlsZXJUaW1lcihjb21wbGV0ZWRXb3JrKTtcbiAgICAgICAgbmV4dCA9IGNvbXBsZXRlV29yayhjdXJyZW50LCBjb21wbGV0ZWRXb3JrLCBzdWJ0cmVlUmVuZGVyTGFuZXMpOyAvLyBVcGRhdGUgcmVuZGVyIGR1cmF0aW9uIGFzc3VtaW5nIHdlIGRpZG4ndCBlcnJvci5cblxuICAgICAgICBzdG9wUHJvZmlsZXJUaW1lcklmUnVubmluZ0FuZFJlY29yZERlbHRhKGNvbXBsZXRlZFdvcmssIGZhbHNlKTtcbiAgICAgIH1cblxuICAgICAgcmVzZXRDdXJyZW50RmliZXIoKTtcblxuICAgICAgaWYgKG5leHQgIT09IG51bGwpIHtcbiAgICAgICAgLy8gQ29tcGxldGluZyB0aGlzIGZpYmVyIHNwYXduZWQgbmV3IHdvcmsuIFdvcmsgb24gdGhhdCBuZXh0LlxuICAgICAgICB3b3JrSW5Qcm9ncmVzcyA9IG5leHQ7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgcmVzZXRDaGlsZExhbmVzKGNvbXBsZXRlZFdvcmspO1xuXG4gICAgICBpZiAocmV0dXJuRmliZXIgIT09IG51bGwgJiYgLy8gRG8gbm90IGFwcGVuZCBlZmZlY3RzIHRvIHBhcmVudHMgaWYgYSBzaWJsaW5nIGZhaWxlZCB0byBjb21wbGV0ZVxuICAgICAgKHJldHVybkZpYmVyLmZsYWdzICYgSW5jb21wbGV0ZSkgPT09IE5vRmxhZ3MpIHtcbiAgICAgICAgLy8gQXBwZW5kIGFsbCB0aGUgZWZmZWN0cyBvZiB0aGUgc3VidHJlZSBhbmQgdGhpcyBmaWJlciBvbnRvIHRoZSBlZmZlY3RcbiAgICAgICAgLy8gbGlzdCBvZiB0aGUgcGFyZW50LiBUaGUgY29tcGxldGlvbiBvcmRlciBvZiB0aGUgY2hpbGRyZW4gYWZmZWN0cyB0aGVcbiAgICAgICAgLy8gc2lkZS1lZmZlY3Qgb3JkZXIuXG4gICAgICAgIGlmIChyZXR1cm5GaWJlci5maXJzdEVmZmVjdCA9PT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybkZpYmVyLmZpcnN0RWZmZWN0ID0gY29tcGxldGVkV29yay5maXJzdEVmZmVjdDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjb21wbGV0ZWRXb3JrLmxhc3RFZmZlY3QgIT09IG51bGwpIHtcbiAgICAgICAgICBpZiAocmV0dXJuRmliZXIubGFzdEVmZmVjdCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuRmliZXIubGFzdEVmZmVjdC5uZXh0RWZmZWN0ID0gY29tcGxldGVkV29yay5maXJzdEVmZmVjdDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm5GaWJlci5sYXN0RWZmZWN0ID0gY29tcGxldGVkV29yay5sYXN0RWZmZWN0O1xuICAgICAgICB9IC8vIElmIHRoaXMgZmliZXIgaGFkIHNpZGUtZWZmZWN0cywgd2UgYXBwZW5kIGl0IEFGVEVSIHRoZSBjaGlsZHJlbidzXG4gICAgICAgIC8vIHNpZGUtZWZmZWN0cy4gV2UgY2FuIHBlcmZvcm0gY2VydGFpbiBzaWRlLWVmZmVjdHMgZWFybGllciBpZiBuZWVkZWQsXG4gICAgICAgIC8vIGJ5IGRvaW5nIG11bHRpcGxlIHBhc3NlcyBvdmVyIHRoZSBlZmZlY3QgbGlzdC4gV2UgZG9uJ3Qgd2FudCB0b1xuICAgICAgICAvLyBzY2hlZHVsZSBvdXIgb3duIHNpZGUtZWZmZWN0IG9uIG91ciBvd24gbGlzdCBiZWNhdXNlIGlmIGVuZCB1cFxuICAgICAgICAvLyByZXVzaW5nIGNoaWxkcmVuIHdlJ2xsIHNjaGVkdWxlIHRoaXMgZWZmZWN0IG9udG8gaXRzZWxmIHNpbmNlIHdlJ3JlXG4gICAgICAgIC8vIGF0IHRoZSBlbmQuXG5cblxuICAgICAgICB2YXIgZmxhZ3MgPSBjb21wbGV0ZWRXb3JrLmZsYWdzOyAvLyBTa2lwIGJvdGggTm9Xb3JrIGFuZCBQZXJmb3JtZWRXb3JrIHRhZ3Mgd2hlbiBjcmVhdGluZyB0aGUgZWZmZWN0XG4gICAgICAgIC8vIGxpc3QuIFBlcmZvcm1lZFdvcmsgZWZmZWN0IGlzIHJlYWQgYnkgUmVhY3QgRGV2VG9vbHMgYnV0IHNob3VsZG4ndCBiZVxuICAgICAgICAvLyBjb21taXR0ZWQuXG5cbiAgICAgICAgaWYgKGZsYWdzID4gUGVyZm9ybWVkV29yaykge1xuICAgICAgICAgIGlmIChyZXR1cm5GaWJlci5sYXN0RWZmZWN0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm5GaWJlci5sYXN0RWZmZWN0Lm5leHRFZmZlY3QgPSBjb21wbGV0ZWRXb3JrO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm5GaWJlci5maXJzdEVmZmVjdCA9IGNvbXBsZXRlZFdvcms7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuRmliZXIubGFzdEVmZmVjdCA9IGNvbXBsZXRlZFdvcms7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVGhpcyBmaWJlciBkaWQgbm90IGNvbXBsZXRlIGJlY2F1c2Ugc29tZXRoaW5nIHRocmV3LiBQb3AgdmFsdWVzIG9mZlxuICAgICAgLy8gdGhlIHN0YWNrIHdpdGhvdXQgZW50ZXJpbmcgdGhlIGNvbXBsZXRlIHBoYXNlLiBJZiB0aGlzIGlzIGEgYm91bmRhcnksXG4gICAgICAvLyBjYXB0dXJlIHZhbHVlcyBpZiBwb3NzaWJsZS5cbiAgICAgIHZhciBfbmV4dCA9IHVud2luZFdvcmsoY29tcGxldGVkV29yayk7IC8vIEJlY2F1c2UgdGhpcyBmaWJlciBkaWQgbm90IGNvbXBsZXRlLCBkb24ndCByZXNldCBpdHMgZXhwaXJhdGlvbiB0aW1lLlxuXG5cbiAgICAgIGlmIChfbmV4dCAhPT0gbnVsbCkge1xuICAgICAgICAvLyBJZiBjb21wbGV0aW5nIHRoaXMgd29yayBzcGF3bmVkIG5ldyB3b3JrLCBkbyB0aGF0IG5leHQuIFdlJ2xsIGNvbWVcbiAgICAgICAgLy8gYmFjayBoZXJlIGFnYWluLlxuICAgICAgICAvLyBTaW5jZSB3ZSdyZSByZXN0YXJ0aW5nLCByZW1vdmUgYW55dGhpbmcgdGhhdCBpcyBub3QgYSBob3N0IGVmZmVjdFxuICAgICAgICAvLyBmcm9tIHRoZSBlZmZlY3QgdGFnLlxuICAgICAgICBfbmV4dC5mbGFncyAmPSBIb3N0RWZmZWN0TWFzaztcbiAgICAgICAgd29ya0luUHJvZ3Jlc3MgPSBfbmV4dDtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoIChjb21wbGV0ZWRXb3JrLm1vZGUgJiBQcm9maWxlTW9kZSkgIT09IE5vTW9kZSkge1xuICAgICAgICAvLyBSZWNvcmQgdGhlIHJlbmRlciBkdXJhdGlvbiBmb3IgdGhlIGZpYmVyIHRoYXQgZXJyb3JlZC5cbiAgICAgICAgc3RvcFByb2ZpbGVyVGltZXJJZlJ1bm5pbmdBbmRSZWNvcmREZWx0YShjb21wbGV0ZWRXb3JrLCBmYWxzZSk7IC8vIEluY2x1ZGUgdGhlIHRpbWUgc3BlbnQgd29ya2luZyBvbiBmYWlsZWQgY2hpbGRyZW4gYmVmb3JlIGNvbnRpbnVpbmcuXG5cbiAgICAgICAgdmFyIGFjdHVhbER1cmF0aW9uID0gY29tcGxldGVkV29yay5hY3R1YWxEdXJhdGlvbjtcbiAgICAgICAgdmFyIGNoaWxkID0gY29tcGxldGVkV29yay5jaGlsZDtcblxuICAgICAgICB3aGlsZSAoY2hpbGQgIT09IG51bGwpIHtcbiAgICAgICAgICBhY3R1YWxEdXJhdGlvbiArPSBjaGlsZC5hY3R1YWxEdXJhdGlvbjtcbiAgICAgICAgICBjaGlsZCA9IGNoaWxkLnNpYmxpbmc7XG4gICAgICAgIH1cblxuICAgICAgICBjb21wbGV0ZWRXb3JrLmFjdHVhbER1cmF0aW9uID0gYWN0dWFsRHVyYXRpb247XG4gICAgICB9XG5cbiAgICAgIGlmIChyZXR1cm5GaWJlciAhPT0gbnVsbCkge1xuICAgICAgICAvLyBNYXJrIHRoZSBwYXJlbnQgZmliZXIgYXMgaW5jb21wbGV0ZSBhbmQgY2xlYXIgaXRzIGVmZmVjdCBsaXN0LlxuICAgICAgICByZXR1cm5GaWJlci5maXJzdEVmZmVjdCA9IHJldHVybkZpYmVyLmxhc3RFZmZlY3QgPSBudWxsO1xuICAgICAgICByZXR1cm5GaWJlci5mbGFncyB8PSBJbmNvbXBsZXRlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBzaWJsaW5nRmliZXIgPSBjb21wbGV0ZWRXb3JrLnNpYmxpbmc7XG5cbiAgICBpZiAoc2libGluZ0ZpYmVyICE9PSBudWxsKSB7XG4gICAgICAvLyBJZiB0aGVyZSBpcyBtb3JlIHdvcmsgdG8gZG8gaW4gdGhpcyByZXR1cm5GaWJlciwgZG8gdGhhdCBuZXh0LlxuICAgICAgd29ya0luUHJvZ3Jlc3MgPSBzaWJsaW5nRmliZXI7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyBPdGhlcndpc2UsIHJldHVybiB0byB0aGUgcGFyZW50XG5cblxuICAgIGNvbXBsZXRlZFdvcmsgPSByZXR1cm5GaWJlcjsgLy8gVXBkYXRlIHRoZSBuZXh0IHRoaW5nIHdlJ3JlIHdvcmtpbmcgb24gaW4gY2FzZSBzb21ldGhpbmcgdGhyb3dzLlxuXG4gICAgd29ya0luUHJvZ3Jlc3MgPSBjb21wbGV0ZWRXb3JrO1xuICB9IHdoaWxlIChjb21wbGV0ZWRXb3JrICE9PSBudWxsKTsgLy8gV2UndmUgcmVhY2hlZCB0aGUgcm9vdC5cblxuXG4gIGlmICh3b3JrSW5Qcm9ncmVzc1Jvb3RFeGl0U3RhdHVzID09PSBSb290SW5jb21wbGV0ZSkge1xuICAgIHdvcmtJblByb2dyZXNzUm9vdEV4aXRTdGF0dXMgPSBSb290Q29tcGxldGVkO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlc2V0Q2hpbGRMYW5lcyhjb21wbGV0ZWRXb3JrKSB7XG4gIGlmICggLy8gVE9ETzogTW92ZSB0aGlzIGNoZWNrIG91dCBvZiB0aGUgaG90IHBhdGggYnkgbW92aW5nIGByZXNldENoaWxkTGFuZXNgXG4gIC8vIHRvIHN3aXRjaCBzdGF0ZW1lbnQgaW4gYGNvbXBsZXRlV29ya2AuXG4gIChjb21wbGV0ZWRXb3JrLnRhZyA9PT0gTGVnYWN5SGlkZGVuQ29tcG9uZW50IHx8IGNvbXBsZXRlZFdvcmsudGFnID09PSBPZmZzY3JlZW5Db21wb25lbnQpICYmIGNvbXBsZXRlZFdvcmsubWVtb2l6ZWRTdGF0ZSAhPT0gbnVsbCAmJiAhaW5jbHVkZXNTb21lTGFuZShzdWJ0cmVlUmVuZGVyTGFuZXMsIE9mZnNjcmVlbkxhbmUpICYmIChjb21wbGV0ZWRXb3JrLm1vZGUgJiBDb25jdXJyZW50TW9kZSkgIT09IE5vTGFuZXMpIHtcbiAgICAvLyBUaGUgY2hpbGRyZW4gb2YgdGhpcyBjb21wb25lbnQgYXJlIGhpZGRlbi4gRG9uJ3QgYnViYmxlIHRoZWlyXG4gICAgLy8gZXhwaXJhdGlvbiB0aW1lcy5cbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgbmV3Q2hpbGRMYW5lcyA9IE5vTGFuZXM7IC8vIEJ1YmJsZSB1cCB0aGUgZWFybGllc3QgZXhwaXJhdGlvbiB0aW1lLlxuXG4gIGlmICggKGNvbXBsZXRlZFdvcmsubW9kZSAmIFByb2ZpbGVNb2RlKSAhPT0gTm9Nb2RlKSB7XG4gICAgLy8gSW4gcHJvZmlsaW5nIG1vZGUsIHJlc2V0Q2hpbGRFeHBpcmF0aW9uVGltZSBpcyBhbHNvIHVzZWQgdG8gcmVzZXRcbiAgICAvLyBwcm9maWxlciBkdXJhdGlvbnMuXG4gICAgdmFyIGFjdHVhbER1cmF0aW9uID0gY29tcGxldGVkV29yay5hY3R1YWxEdXJhdGlvbjtcbiAgICB2YXIgdHJlZUJhc2VEdXJhdGlvbiA9IGNvbXBsZXRlZFdvcmsuc2VsZkJhc2VEdXJhdGlvbjsgLy8gV2hlbiBhIGZpYmVyIGlzIGNsb25lZCwgaXRzIGFjdHVhbER1cmF0aW9uIGlzIHJlc2V0IHRvIDAuIFRoaXMgdmFsdWUgd2lsbFxuICAgIC8vIG9ubHkgYmUgdXBkYXRlZCBpZiB3b3JrIGlzIGRvbmUgb24gdGhlIGZpYmVyIChpLmUuIGl0IGRvZXNuJ3QgYmFpbG91dCkuXG4gICAgLy8gV2hlbiB3b3JrIGlzIGRvbmUsIGl0IHNob3VsZCBidWJibGUgdG8gdGhlIHBhcmVudCdzIGFjdHVhbER1cmF0aW9uLiBJZlxuICAgIC8vIHRoZSBmaWJlciBoYXMgbm90IGJlZW4gY2xvbmVkIHRob3VnaCwgKG1lYW5pbmcgbm8gd29yayB3YXMgZG9uZSksIHRoZW5cbiAgICAvLyB0aGlzIHZhbHVlIHdpbGwgcmVmbGVjdCB0aGUgYW1vdW50IG9mIHRpbWUgc3BlbnQgd29ya2luZyBvbiBhIHByZXZpb3VzXG4gICAgLy8gcmVuZGVyLiBJbiB0aGF0IGNhc2UgaXQgc2hvdWxkIG5vdCBidWJibGUuIFdlIGRldGVybWluZSB3aGV0aGVyIGl0IHdhc1xuICAgIC8vIGNsb25lZCBieSBjb21wYXJpbmcgdGhlIGNoaWxkIHBvaW50ZXIuXG5cbiAgICB2YXIgc2hvdWxkQnViYmxlQWN0dWFsRHVyYXRpb25zID0gY29tcGxldGVkV29yay5hbHRlcm5hdGUgPT09IG51bGwgfHwgY29tcGxldGVkV29yay5jaGlsZCAhPT0gY29tcGxldGVkV29yay5hbHRlcm5hdGUuY2hpbGQ7XG4gICAgdmFyIGNoaWxkID0gY29tcGxldGVkV29yay5jaGlsZDtcblxuICAgIHdoaWxlIChjaGlsZCAhPT0gbnVsbCkge1xuICAgICAgbmV3Q2hpbGRMYW5lcyA9IG1lcmdlTGFuZXMobmV3Q2hpbGRMYW5lcywgbWVyZ2VMYW5lcyhjaGlsZC5sYW5lcywgY2hpbGQuY2hpbGRMYW5lcykpO1xuXG4gICAgICBpZiAoc2hvdWxkQnViYmxlQWN0dWFsRHVyYXRpb25zKSB7XG4gICAgICAgIGFjdHVhbER1cmF0aW9uICs9IGNoaWxkLmFjdHVhbER1cmF0aW9uO1xuICAgICAgfVxuXG4gICAgICB0cmVlQmFzZUR1cmF0aW9uICs9IGNoaWxkLnRyZWVCYXNlRHVyYXRpb247XG4gICAgICBjaGlsZCA9IGNoaWxkLnNpYmxpbmc7XG4gICAgfVxuXG4gICAgdmFyIGlzVGltZWRPdXRTdXNwZW5zZSA9IGNvbXBsZXRlZFdvcmsudGFnID09PSBTdXNwZW5zZUNvbXBvbmVudCAmJiBjb21wbGV0ZWRXb3JrLm1lbW9pemVkU3RhdGUgIT09IG51bGw7XG5cbiAgICBpZiAoaXNUaW1lZE91dFN1c3BlbnNlKSB7XG4gICAgICAvLyBEb24ndCBjb3VudCB0aW1lIHNwZW50IGluIGEgdGltZWQgb3V0IFN1c3BlbnNlIHN1YnRyZWUgYXMgcGFydCBvZiB0aGUgYmFzZSBkdXJhdGlvbi5cbiAgICAgIHZhciBwcmltYXJ5Q2hpbGRGcmFnbWVudCA9IGNvbXBsZXRlZFdvcmsuY2hpbGQ7XG5cbiAgICAgIGlmIChwcmltYXJ5Q2hpbGRGcmFnbWVudCAhPT0gbnVsbCkge1xuICAgICAgICB0cmVlQmFzZUR1cmF0aW9uIC09IHByaW1hcnlDaGlsZEZyYWdtZW50LnRyZWVCYXNlRHVyYXRpb247XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29tcGxldGVkV29yay5hY3R1YWxEdXJhdGlvbiA9IGFjdHVhbER1cmF0aW9uO1xuICAgIGNvbXBsZXRlZFdvcmsudHJlZUJhc2VEdXJhdGlvbiA9IHRyZWVCYXNlRHVyYXRpb247XG4gIH0gZWxzZSB7XG4gICAgdmFyIF9jaGlsZCA9IGNvbXBsZXRlZFdvcmsuY2hpbGQ7XG5cbiAgICB3aGlsZSAoX2NoaWxkICE9PSBudWxsKSB7XG4gICAgICBuZXdDaGlsZExhbmVzID0gbWVyZ2VMYW5lcyhuZXdDaGlsZExhbmVzLCBtZXJnZUxhbmVzKF9jaGlsZC5sYW5lcywgX2NoaWxkLmNoaWxkTGFuZXMpKTtcbiAgICAgIF9jaGlsZCA9IF9jaGlsZC5zaWJsaW5nO1xuICAgIH1cbiAgfVxuXG4gIGNvbXBsZXRlZFdvcmsuY2hpbGRMYW5lcyA9IG5ld0NoaWxkTGFuZXM7XG59XG5cbmZ1bmN0aW9uIGNvbW1pdFJvb3Qocm9vdCkge1xuICB2YXIgcmVuZGVyUHJpb3JpdHlMZXZlbCA9IGdldEN1cnJlbnRQcmlvcml0eUxldmVsKCk7XG4gIHJ1bldpdGhQcmlvcml0eSQxKEltbWVkaWF0ZVByaW9yaXR5JDEsIGNvbW1pdFJvb3RJbXBsLmJpbmQobnVsbCwgcm9vdCwgcmVuZGVyUHJpb3JpdHlMZXZlbCkpO1xuICByZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gY29tbWl0Um9vdEltcGwocm9vdCwgcmVuZGVyUHJpb3JpdHlMZXZlbCkge1xuICBkbyB7XG4gICAgLy8gYGZsdXNoUGFzc2l2ZUVmZmVjdHNgIHdpbGwgY2FsbCBgZmx1c2hTeW5jVXBkYXRlUXVldWVgIGF0IHRoZSBlbmQsIHdoaWNoXG4gICAgLy8gbWVhbnMgYGZsdXNoUGFzc2l2ZUVmZmVjdHNgIHdpbGwgc29tZXRpbWVzIHJlc3VsdCBpbiBhZGRpdGlvbmFsXG4gICAgLy8gcGFzc2l2ZSBlZmZlY3RzLiBTbyB3ZSBuZWVkIHRvIGtlZXAgZmx1c2hpbmcgaW4gYSBsb29wIHVudGlsIHRoZXJlIGFyZVxuICAgIC8vIG5vIG1vcmUgcGVuZGluZyBlZmZlY3RzLlxuICAgIC8vIFRPRE86IE1pZ2h0IGJlIGJldHRlciBpZiBgZmx1c2hQYXNzaXZlRWZmZWN0c2AgZGlkIG5vdCBhdXRvbWF0aWNhbGx5XG4gICAgLy8gZmx1c2ggc3luY2hyb25vdXMgd29yayBhdCB0aGUgZW5kLCB0byBhdm9pZCBmYWN0b3JpbmcgaGF6YXJkcyBsaWtlIHRoaXMuXG4gICAgZmx1c2hQYXNzaXZlRWZmZWN0cygpO1xuICB9IHdoaWxlIChyb290V2l0aFBlbmRpbmdQYXNzaXZlRWZmZWN0cyAhPT0gbnVsbCk7XG5cbiAgZmx1c2hSZW5kZXJQaGFzZVN0cmljdE1vZGVXYXJuaW5nc0luREVWKCk7XG5cbiAgaWYgKCEoKGV4ZWN1dGlvbkNvbnRleHQgJiAoUmVuZGVyQ29udGV4dCB8IENvbW1pdENvbnRleHQpKSA9PT0gTm9Db250ZXh0KSkge1xuICAgIHtcbiAgICAgIHRocm93IEVycm9yKCBcIlNob3VsZCBub3QgYWxyZWFkeSBiZSB3b3JraW5nLlwiICk7XG4gICAgfVxuICB9XG5cbiAgdmFyIGZpbmlzaGVkV29yayA9IHJvb3QuZmluaXNoZWRXb3JrO1xuICB2YXIgbGFuZXMgPSByb290LmZpbmlzaGVkTGFuZXM7XG5cbiAgaWYgKGZpbmlzaGVkV29yayA9PT0gbnVsbCkge1xuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICByb290LmZpbmlzaGVkV29yayA9IG51bGw7XG4gIHJvb3QuZmluaXNoZWRMYW5lcyA9IE5vTGFuZXM7XG5cbiAgaWYgKCEoZmluaXNoZWRXb3JrICE9PSByb290LmN1cnJlbnQpKSB7XG4gICAge1xuICAgICAgdGhyb3cgRXJyb3IoIFwiQ2Fubm90IGNvbW1pdCB0aGUgc2FtZSB0cmVlIGFzIGJlZm9yZS4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS5cIiApO1xuICAgIH1cbiAgfSAvLyBjb21taXRSb290IG5ldmVyIHJldHVybnMgYSBjb250aW51YXRpb247IGl0IGFsd2F5cyBmaW5pc2hlcyBzeW5jaHJvbm91c2x5LlxuICAvLyBTbyB3ZSBjYW4gY2xlYXIgdGhlc2Ugbm93IHRvIGFsbG93IGEgbmV3IGNhbGxiYWNrIHRvIGJlIHNjaGVkdWxlZC5cblxuXG4gIHJvb3QuY2FsbGJhY2tOb2RlID0gbnVsbDsgLy8gVXBkYXRlIHRoZSBmaXJzdCBhbmQgbGFzdCBwZW5kaW5nIHRpbWVzIG9uIHRoaXMgcm9vdC4gVGhlIG5ldyBmaXJzdFxuICAvLyBwZW5kaW5nIHRpbWUgaXMgd2hhdGV2ZXIgaXMgbGVmdCBvbiB0aGUgcm9vdCBmaWJlci5cblxuICB2YXIgcmVtYWluaW5nTGFuZXMgPSBtZXJnZUxhbmVzKGZpbmlzaGVkV29yay5sYW5lcywgZmluaXNoZWRXb3JrLmNoaWxkTGFuZXMpO1xuICBtYXJrUm9vdEZpbmlzaGVkKHJvb3QsIHJlbWFpbmluZ0xhbmVzKTsgLy8gQ2xlYXIgYWxyZWFkeSBmaW5pc2hlZCBkaXNjcmV0ZSB1cGRhdGVzIGluIGNhc2UgdGhhdCBhIGxhdGVyIGNhbGwgb2ZcbiAgLy8gYGZsdXNoRGlzY3JldGVVcGRhdGVzYCBzdGFydHMgYSB1c2VsZXNzIHJlbmRlciBwYXNzIHdoaWNoIG1heSBjYW5jZWxzXG4gIC8vIGEgc2NoZWR1bGVkIHRpbWVvdXQuXG5cbiAgaWYgKHJvb3RzV2l0aFBlbmRpbmdEaXNjcmV0ZVVwZGF0ZXMgIT09IG51bGwpIHtcbiAgICBpZiAoIWhhc0Rpc2NyZXRlTGFuZXMocmVtYWluaW5nTGFuZXMpICYmIHJvb3RzV2l0aFBlbmRpbmdEaXNjcmV0ZVVwZGF0ZXMuaGFzKHJvb3QpKSB7XG4gICAgICByb290c1dpdGhQZW5kaW5nRGlzY3JldGVVcGRhdGVzLmRlbGV0ZShyb290KTtcbiAgICB9XG4gIH1cblxuICBpZiAocm9vdCA9PT0gd29ya0luUHJvZ3Jlc3NSb290KSB7XG4gICAgLy8gV2UgY2FuIHJlc2V0IHRoZXNlIG5vdyB0aGF0IHRoZXkgYXJlIGZpbmlzaGVkLlxuICAgIHdvcmtJblByb2dyZXNzUm9vdCA9IG51bGw7XG4gICAgd29ya0luUHJvZ3Jlc3MgPSBudWxsO1xuICAgIHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzID0gTm9MYW5lcztcbiAgfSAvLyBHZXQgdGhlIGxpc3Qgb2YgZWZmZWN0cy5cblxuXG4gIHZhciBmaXJzdEVmZmVjdDtcblxuICBpZiAoZmluaXNoZWRXb3JrLmZsYWdzID4gUGVyZm9ybWVkV29yaykge1xuICAgIC8vIEEgZmliZXIncyBlZmZlY3QgbGlzdCBjb25zaXN0cyBvbmx5IG9mIGl0cyBjaGlsZHJlbiwgbm90IGl0c2VsZi4gU28gaWZcbiAgICAvLyB0aGUgcm9vdCBoYXMgYW4gZWZmZWN0LCB3ZSBuZWVkIHRvIGFkZCBpdCB0byB0aGUgZW5kIG9mIHRoZSBsaXN0LiBUaGVcbiAgICAvLyByZXN1bHRpbmcgbGlzdCBpcyB0aGUgc2V0IHRoYXQgd291bGQgYmVsb25nIHRvIHRoZSByb290J3MgcGFyZW50LCBpZiBpdFxuICAgIC8vIGhhZCBvbmU7IHRoYXQgaXMsIGFsbCB0aGUgZWZmZWN0cyBpbiB0aGUgdHJlZSBpbmNsdWRpbmcgdGhlIHJvb3QuXG4gICAgaWYgKGZpbmlzaGVkV29yay5sYXN0RWZmZWN0ICE9PSBudWxsKSB7XG4gICAgICBmaW5pc2hlZFdvcmsubGFzdEVmZmVjdC5uZXh0RWZmZWN0ID0gZmluaXNoZWRXb3JrO1xuICAgICAgZmlyc3RFZmZlY3QgPSBmaW5pc2hlZFdvcmsuZmlyc3RFZmZlY3Q7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZpcnN0RWZmZWN0ID0gZmluaXNoZWRXb3JrO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBUaGVyZSBpcyBubyBlZmZlY3Qgb24gdGhlIHJvb3QuXG4gICAgZmlyc3RFZmZlY3QgPSBmaW5pc2hlZFdvcmsuZmlyc3RFZmZlY3Q7XG4gIH1cblxuICBpZiAoZmlyc3RFZmZlY3QgIT09IG51bGwpIHtcblxuICAgIHZhciBwcmV2RXhlY3V0aW9uQ29udGV4dCA9IGV4ZWN1dGlvbkNvbnRleHQ7XG4gICAgZXhlY3V0aW9uQ29udGV4dCB8PSBDb21taXRDb250ZXh0O1xuICAgIHZhciBwcmV2SW50ZXJhY3Rpb25zID0gcHVzaEludGVyYWN0aW9ucyhyb290KTsgLy8gUmVzZXQgdGhpcyB0byBudWxsIGJlZm9yZSBjYWxsaW5nIGxpZmVjeWNsZXNcblxuICAgIFJlYWN0Q3VycmVudE93bmVyJDIuY3VycmVudCA9IG51bGw7IC8vIFRoZSBjb21taXQgcGhhc2UgaXMgYnJva2VuIGludG8gc2V2ZXJhbCBzdWItcGhhc2VzLiBXZSBkbyBhIHNlcGFyYXRlIHBhc3NcbiAgICAvLyBvZiB0aGUgZWZmZWN0IGxpc3QgZm9yIGVhY2ggcGhhc2U6IGFsbCBtdXRhdGlvbiBlZmZlY3RzIGNvbWUgYmVmb3JlIGFsbFxuICAgIC8vIGxheW91dCBlZmZlY3RzLCBhbmQgc28gb24uXG4gICAgLy8gVGhlIGZpcnN0IHBoYXNlIGEgXCJiZWZvcmUgbXV0YXRpb25cIiBwaGFzZS4gV2UgdXNlIHRoaXMgcGhhc2UgdG8gcmVhZCB0aGVcbiAgICAvLyBzdGF0ZSBvZiB0aGUgaG9zdCB0cmVlIHJpZ2h0IGJlZm9yZSB3ZSBtdXRhdGUgaXQuIFRoaXMgaXMgd2hlcmVcbiAgICAvLyBnZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSBpcyBjYWxsZWQuXG5cbiAgICBmb2N1c2VkSW5zdGFuY2VIYW5kbGUgPSBwcmVwYXJlRm9yQ29tbWl0KHJvb3QuY29udGFpbmVySW5mbyk7XG4gICAgc2hvdWxkRmlyZUFmdGVyQWN0aXZlSW5zdGFuY2VCbHVyID0gZmFsc2U7XG4gICAgbmV4dEVmZmVjdCA9IGZpcnN0RWZmZWN0O1xuXG4gICAgZG8ge1xuICAgICAge1xuICAgICAgICBpbnZva2VHdWFyZGVkQ2FsbGJhY2sobnVsbCwgY29tbWl0QmVmb3JlTXV0YXRpb25FZmZlY3RzLCBudWxsKTtcblxuICAgICAgICBpZiAoaGFzQ2F1Z2h0RXJyb3IoKSkge1xuICAgICAgICAgIGlmICghKG5leHRFZmZlY3QgIT09IG51bGwpKSB7XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHRocm93IEVycm9yKCBcIlNob3VsZCBiZSB3b3JraW5nIG9uIGFuIGVmZmVjdC5cIiApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBlcnJvciA9IGNsZWFyQ2F1Z2h0RXJyb3IoKTtcbiAgICAgICAgICBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihuZXh0RWZmZWN0LCBlcnJvcik7XG4gICAgICAgICAgbmV4dEVmZmVjdCA9IG5leHRFZmZlY3QubmV4dEVmZmVjdDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gd2hpbGUgKG5leHRFZmZlY3QgIT09IG51bGwpOyAvLyBXZSBubyBsb25nZXIgbmVlZCB0byB0cmFjayB0aGUgYWN0aXZlIGluc3RhbmNlIGZpYmVyXG5cblxuICAgIGZvY3VzZWRJbnN0YW5jZUhhbmRsZSA9IG51bGw7XG5cbiAgICB7XG4gICAgICAvLyBNYXJrIHRoZSBjdXJyZW50IGNvbW1pdCB0aW1lIHRvIGJlIHNoYXJlZCBieSBhbGwgUHJvZmlsZXJzIGluIHRoaXNcbiAgICAgIC8vIGJhdGNoLiBUaGlzIGVuYWJsZXMgdGhlbSB0byBiZSBncm91cGVkIGxhdGVyLlxuICAgICAgcmVjb3JkQ29tbWl0VGltZSgpO1xuICAgIH0gLy8gVGhlIG5leHQgcGhhc2UgaXMgdGhlIG11dGF0aW9uIHBoYXNlLCB3aGVyZSB3ZSBtdXRhdGUgdGhlIGhvc3QgdHJlZS5cblxuXG4gICAgbmV4dEVmZmVjdCA9IGZpcnN0RWZmZWN0O1xuXG4gICAgZG8ge1xuICAgICAge1xuICAgICAgICBpbnZva2VHdWFyZGVkQ2FsbGJhY2sobnVsbCwgY29tbWl0TXV0YXRpb25FZmZlY3RzLCBudWxsLCByb290LCByZW5kZXJQcmlvcml0eUxldmVsKTtcblxuICAgICAgICBpZiAoaGFzQ2F1Z2h0RXJyb3IoKSkge1xuICAgICAgICAgIGlmICghKG5leHRFZmZlY3QgIT09IG51bGwpKSB7XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHRocm93IEVycm9yKCBcIlNob3VsZCBiZSB3b3JraW5nIG9uIGFuIGVmZmVjdC5cIiApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBfZXJyb3IgPSBjbGVhckNhdWdodEVycm9yKCk7XG5cbiAgICAgICAgICBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihuZXh0RWZmZWN0LCBfZXJyb3IpO1xuICAgICAgICAgIG5leHRFZmZlY3QgPSBuZXh0RWZmZWN0Lm5leHRFZmZlY3Q7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IHdoaWxlIChuZXh0RWZmZWN0ICE9PSBudWxsKTtcblxuICAgIHJlc2V0QWZ0ZXJDb21taXQocm9vdC5jb250YWluZXJJbmZvKTsgLy8gVGhlIHdvcmstaW4tcHJvZ3Jlc3MgdHJlZSBpcyBub3cgdGhlIGN1cnJlbnQgdHJlZS4gVGhpcyBtdXN0IGNvbWUgYWZ0ZXJcbiAgICAvLyB0aGUgbXV0YXRpb24gcGhhc2UsIHNvIHRoYXQgdGhlIHByZXZpb3VzIHRyZWUgaXMgc3RpbGwgY3VycmVudCBkdXJpbmdcbiAgICAvLyBjb21wb25lbnRXaWxsVW5tb3VudCwgYnV0IGJlZm9yZSB0aGUgbGF5b3V0IHBoYXNlLCBzbyB0aGF0IHRoZSBmaW5pc2hlZFxuICAgIC8vIHdvcmsgaXMgY3VycmVudCBkdXJpbmcgY29tcG9uZW50RGlkTW91bnQvVXBkYXRlLlxuXG4gICAgcm9vdC5jdXJyZW50ID0gZmluaXNoZWRXb3JrOyAvLyBUaGUgbmV4dCBwaGFzZSBpcyB0aGUgbGF5b3V0IHBoYXNlLCB3aGVyZSB3ZSBjYWxsIGVmZmVjdHMgdGhhdCByZWFkXG4gICAgLy8gdGhlIGhvc3QgdHJlZSBhZnRlciBpdCdzIGJlZW4gbXV0YXRlZC4gVGhlIGlkaW9tYXRpYyB1c2UgY2FzZSBmb3IgdGhpcyBpc1xuICAgIC8vIGxheW91dCwgYnV0IGNsYXNzIGNvbXBvbmVudCBsaWZlY3ljbGVzIGFsc28gZmlyZSBoZXJlIGZvciBsZWdhY3kgcmVhc29ucy5cblxuICAgIG5leHRFZmZlY3QgPSBmaXJzdEVmZmVjdDtcblxuICAgIGRvIHtcbiAgICAgIHtcbiAgICAgICAgaW52b2tlR3VhcmRlZENhbGxiYWNrKG51bGwsIGNvbW1pdExheW91dEVmZmVjdHMsIG51bGwsIHJvb3QsIGxhbmVzKTtcblxuICAgICAgICBpZiAoaGFzQ2F1Z2h0RXJyb3IoKSkge1xuICAgICAgICAgIGlmICghKG5leHRFZmZlY3QgIT09IG51bGwpKSB7XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHRocm93IEVycm9yKCBcIlNob3VsZCBiZSB3b3JraW5nIG9uIGFuIGVmZmVjdC5cIiApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBfZXJyb3IyID0gY2xlYXJDYXVnaHRFcnJvcigpO1xuXG4gICAgICAgICAgY2FwdHVyZUNvbW1pdFBoYXNlRXJyb3IobmV4dEVmZmVjdCwgX2Vycm9yMik7XG4gICAgICAgICAgbmV4dEVmZmVjdCA9IG5leHRFZmZlY3QubmV4dEVmZmVjdDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gd2hpbGUgKG5leHRFZmZlY3QgIT09IG51bGwpO1xuXG4gICAgbmV4dEVmZmVjdCA9IG51bGw7IC8vIFRlbGwgU2NoZWR1bGVyIHRvIHlpZWxkIGF0IHRoZSBlbmQgb2YgdGhlIGZyYW1lLCBzbyB0aGUgYnJvd3NlciBoYXMgYW5cbiAgICAvLyBvcHBvcnR1bml0eSB0byBwYWludC5cblxuICAgIHJlcXVlc3RQYWludCgpO1xuXG4gICAge1xuICAgICAgcG9wSW50ZXJhY3Rpb25zKHByZXZJbnRlcmFjdGlvbnMpO1xuICAgIH1cblxuICAgIGV4ZWN1dGlvbkNvbnRleHQgPSBwcmV2RXhlY3V0aW9uQ29udGV4dDtcbiAgfSBlbHNlIHtcbiAgICAvLyBObyBlZmZlY3RzLlxuICAgIHJvb3QuY3VycmVudCA9IGZpbmlzaGVkV29yazsgLy8gTWVhc3VyZSB0aGVzZSBhbnl3YXkgc28gdGhlIGZsYW1lZ3JhcGggZXhwbGljaXRseSBzaG93cyB0aGF0IHRoZXJlIHdlcmVcbiAgICAvLyBubyBlZmZlY3RzLlxuICAgIC8vIFRPRE86IE1heWJlIHRoZXJlJ3MgYSBiZXR0ZXIgd2F5IHRvIHJlcG9ydCB0aGlzLlxuXG4gICAge1xuICAgICAgcmVjb3JkQ29tbWl0VGltZSgpO1xuICAgIH1cbiAgfVxuXG4gIHZhciByb290RGlkSGF2ZVBhc3NpdmVFZmZlY3RzID0gcm9vdERvZXNIYXZlUGFzc2l2ZUVmZmVjdHM7XG5cbiAgaWYgKHJvb3REb2VzSGF2ZVBhc3NpdmVFZmZlY3RzKSB7XG4gICAgLy8gVGhpcyBjb21taXQgaGFzIHBhc3NpdmUgZWZmZWN0cy4gU3Rhc2ggYSByZWZlcmVuY2UgdG8gdGhlbS4gQnV0IGRvbid0XG4gICAgLy8gc2NoZWR1bGUgYSBjYWxsYmFjayB1bnRpbCBhZnRlciBmbHVzaGluZyBsYXlvdXQgd29yay5cbiAgICByb290RG9lc0hhdmVQYXNzaXZlRWZmZWN0cyA9IGZhbHNlO1xuICAgIHJvb3RXaXRoUGVuZGluZ1Bhc3NpdmVFZmZlY3RzID0gcm9vdDtcbiAgICBwZW5kaW5nUGFzc2l2ZUVmZmVjdHNMYW5lcyA9IGxhbmVzO1xuICAgIHBlbmRpbmdQYXNzaXZlRWZmZWN0c1JlbmRlclByaW9yaXR5ID0gcmVuZGVyUHJpb3JpdHlMZXZlbDtcbiAgfSBlbHNlIHtcbiAgICAvLyBXZSBhcmUgZG9uZSB3aXRoIHRoZSBlZmZlY3QgY2hhaW4gYXQgdGhpcyBwb2ludCBzbyBsZXQncyBjbGVhciB0aGVcbiAgICAvLyBuZXh0RWZmZWN0IHBvaW50ZXJzIHRvIGFzc2lzdCB3aXRoIEdDLiBJZiB3ZSBoYXZlIHBhc3NpdmUgZWZmZWN0cywgd2UnbGxcbiAgICAvLyBjbGVhciB0aGlzIGluIGZsdXNoUGFzc2l2ZUVmZmVjdHMuXG4gICAgbmV4dEVmZmVjdCA9IGZpcnN0RWZmZWN0O1xuXG4gICAgd2hpbGUgKG5leHRFZmZlY3QgIT09IG51bGwpIHtcbiAgICAgIHZhciBuZXh0TmV4dEVmZmVjdCA9IG5leHRFZmZlY3QubmV4dEVmZmVjdDtcbiAgICAgIG5leHRFZmZlY3QubmV4dEVmZmVjdCA9IG51bGw7XG5cbiAgICAgIGlmIChuZXh0RWZmZWN0LmZsYWdzICYgRGVsZXRpb24pIHtcbiAgICAgICAgZGV0YWNoRmliZXJBZnRlckVmZmVjdHMobmV4dEVmZmVjdCk7XG4gICAgICB9XG5cbiAgICAgIG5leHRFZmZlY3QgPSBuZXh0TmV4dEVmZmVjdDtcbiAgICB9XG4gIH0gLy8gUmVhZCB0aGlzIGFnYWluLCBzaW5jZSBhbiBlZmZlY3QgbWlnaHQgaGF2ZSB1cGRhdGVkIGl0XG5cblxuICByZW1haW5pbmdMYW5lcyA9IHJvb3QucGVuZGluZ0xhbmVzOyAvLyBDaGVjayBpZiB0aGVyZSdzIHJlbWFpbmluZyB3b3JrIG9uIHRoaXMgcm9vdFxuXG4gIGlmIChyZW1haW5pbmdMYW5lcyAhPT0gTm9MYW5lcykge1xuICAgIHtcbiAgICAgIGlmIChzcGF3bmVkV29ya0R1cmluZ1JlbmRlciAhPT0gbnVsbCkge1xuICAgICAgICB2YXIgZXhwaXJhdGlvblRpbWVzID0gc3Bhd25lZFdvcmtEdXJpbmdSZW5kZXI7XG4gICAgICAgIHNwYXduZWRXb3JrRHVyaW5nUmVuZGVyID0gbnVsbDtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGV4cGlyYXRpb25UaW1lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHNjaGVkdWxlSW50ZXJhY3Rpb25zKHJvb3QsIGV4cGlyYXRpb25UaW1lc1tpXSwgcm9vdC5tZW1vaXplZEludGVyYWN0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgc2NoZWR1bGVQZW5kaW5nSW50ZXJhY3Rpb25zKHJvb3QsIHJlbWFpbmluZ0xhbmVzKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gSWYgdGhlcmUncyBubyByZW1haW5pbmcgd29yaywgd2UgY2FuIGNsZWFyIHRoZSBzZXQgb2YgYWxyZWFkeSBmYWlsZWRcbiAgICAvLyBlcnJvciBib3VuZGFyaWVzLlxuICAgIGxlZ2FjeUVycm9yQm91bmRhcmllc1RoYXRBbHJlYWR5RmFpbGVkID0gbnVsbDtcbiAgfVxuXG4gIHtcbiAgICBpZiAoIXJvb3REaWRIYXZlUGFzc2l2ZUVmZmVjdHMpIHtcbiAgICAgIC8vIElmIHRoZXJlIGFyZSBubyBwYXNzaXZlIGVmZmVjdHMsIHRoZW4gd2UgY2FuIGNvbXBsZXRlIHRoZSBwZW5kaW5nIGludGVyYWN0aW9ucy5cbiAgICAgIC8vIE90aGVyd2lzZSwgd2UnbGwgd2FpdCB1bnRpbCBhZnRlciB0aGUgcGFzc2l2ZSBlZmZlY3RzIGFyZSBmbHVzaGVkLlxuICAgICAgLy8gV2FpdCB0byBkbyB0aGlzIHVudGlsIGFmdGVyIHJlbWFpbmluZyB3b3JrIGhhcyBiZWVuIHNjaGVkdWxlZCxcbiAgICAgIC8vIHNvIHRoYXQgd2UgZG9uJ3QgcHJlbWF0dXJlbHkgc2lnbmFsIGNvbXBsZXRlIGZvciBpbnRlcmFjdGlvbnMgd2hlbiB0aGVyZSdzIGUuZy4gaGlkZGVuIHdvcmsuXG4gICAgICBmaW5pc2hQZW5kaW5nSW50ZXJhY3Rpb25zKHJvb3QsIGxhbmVzKTtcbiAgICB9XG4gIH1cblxuICBpZiAocmVtYWluaW5nTGFuZXMgPT09IFN5bmNMYW5lKSB7XG4gICAgLy8gQ291bnQgdGhlIG51bWJlciBvZiB0aW1lcyB0aGUgcm9vdCBzeW5jaHJvbm91c2x5IHJlLXJlbmRlcnMgd2l0aG91dFxuICAgIC8vIGZpbmlzaGluZy4gSWYgdGhlcmUgYXJlIHRvbyBtYW55LCBpdCBpbmRpY2F0ZXMgYW4gaW5maW5pdGUgdXBkYXRlIGxvb3AuXG4gICAgaWYgKHJvb3QgPT09IHJvb3RXaXRoTmVzdGVkVXBkYXRlcykge1xuICAgICAgbmVzdGVkVXBkYXRlQ291bnQrKztcbiAgICB9IGVsc2Uge1xuICAgICAgbmVzdGVkVXBkYXRlQ291bnQgPSAwO1xuICAgICAgcm9vdFdpdGhOZXN0ZWRVcGRhdGVzID0gcm9vdDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgbmVzdGVkVXBkYXRlQ291bnQgPSAwO1xuICB9XG5cbiAgb25Db21taXRSb290KGZpbmlzaGVkV29yay5zdGF0ZU5vZGUsIHJlbmRlclByaW9yaXR5TGV2ZWwpO1xuXG4gIHtcbiAgICBvbkNvbW1pdFJvb3QkMSgpO1xuICB9IC8vIEFsd2F5cyBjYWxsIHRoaXMgYmVmb3JlIGV4aXRpbmcgYGNvbW1pdFJvb3RgLCB0byBlbnN1cmUgdGhhdCBhbnlcbiAgLy8gYWRkaXRpb25hbCB3b3JrIG9uIHRoaXMgcm9vdCBpcyBzY2hlZHVsZWQuXG5cblxuICBlbnN1cmVSb290SXNTY2hlZHVsZWQocm9vdCwgbm93KCkpO1xuXG4gIGlmIChoYXNVbmNhdWdodEVycm9yKSB7XG4gICAgaGFzVW5jYXVnaHRFcnJvciA9IGZhbHNlO1xuICAgIHZhciBfZXJyb3IzID0gZmlyc3RVbmNhdWdodEVycm9yO1xuICAgIGZpcnN0VW5jYXVnaHRFcnJvciA9IG51bGw7XG4gICAgdGhyb3cgX2Vycm9yMztcbiAgfVxuXG4gIGlmICgoZXhlY3V0aW9uQ29udGV4dCAmIExlZ2FjeVVuYmF0Y2hlZENvbnRleHQpICE9PSBOb0NvbnRleHQpIHtcbiAgICAvLyBhIFJlYWN0RE9NLnJlbmRlci1lZCByb290IGluc2lkZSBvZiBiYXRjaGVkVXBkYXRlcy4gVGhlIGNvbW1pdCBmaXJlZFxuICAgIC8vIHN5bmNocm9ub3VzbHksIGJ1dCBsYXlvdXQgdXBkYXRlcyBzaG91bGQgYmUgZGVmZXJyZWQgdW50aWwgdGhlIGVuZFxuICAgIC8vIG9mIHRoZSBiYXRjaC5cblxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH0gLy8gSWYgbGF5b3V0IHdvcmsgd2FzIHNjaGVkdWxlZCwgZmx1c2ggaXQgbm93LlxuXG5cbiAgZmx1c2hTeW5jQ2FsbGJhY2tRdWV1ZSgpO1xuXG4gIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiBjb21taXRCZWZvcmVNdXRhdGlvbkVmZmVjdHMoKSB7XG4gIHdoaWxlIChuZXh0RWZmZWN0ICE9PSBudWxsKSB7XG4gICAgdmFyIGN1cnJlbnQgPSBuZXh0RWZmZWN0LmFsdGVybmF0ZTtcblxuICAgIGlmICghc2hvdWxkRmlyZUFmdGVyQWN0aXZlSW5zdGFuY2VCbHVyICYmIGZvY3VzZWRJbnN0YW5jZUhhbmRsZSAhPT0gbnVsbCkge1xuICAgICAgaWYgKChuZXh0RWZmZWN0LmZsYWdzICYgRGVsZXRpb24pICE9PSBOb0ZsYWdzKSB7XG4gICAgICAgIGlmIChkb2VzRmliZXJDb250YWluKG5leHRFZmZlY3QsIGZvY3VzZWRJbnN0YW5jZUhhbmRsZSkpIHtcbiAgICAgICAgICBzaG91bGRGaXJlQWZ0ZXJBY3RpdmVJbnN0YW5jZUJsdXIgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBUT0RPOiBNb3ZlIHRoaXMgb3V0IG9mIHRoZSBob3QgcGF0aCB1c2luZyBhIGRlZGljYXRlZCBlZmZlY3QgdGFnLlxuICAgICAgICBpZiAobmV4dEVmZmVjdC50YWcgPT09IFN1c3BlbnNlQ29tcG9uZW50ICYmIGlzU3VzcGVuc2VCb3VuZGFyeUJlaW5nSGlkZGVuKGN1cnJlbnQsIG5leHRFZmZlY3QpICYmIGRvZXNGaWJlckNvbnRhaW4obmV4dEVmZmVjdCwgZm9jdXNlZEluc3RhbmNlSGFuZGxlKSkge1xuICAgICAgICAgIHNob3VsZEZpcmVBZnRlckFjdGl2ZUluc3RhbmNlQmx1ciA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgZmxhZ3MgPSBuZXh0RWZmZWN0LmZsYWdzO1xuXG4gICAgaWYgKChmbGFncyAmIFNuYXBzaG90KSAhPT0gTm9GbGFncykge1xuICAgICAgc2V0Q3VycmVudEZpYmVyKG5leHRFZmZlY3QpO1xuICAgICAgY29tbWl0QmVmb3JlTXV0YXRpb25MaWZlQ3ljbGVzKGN1cnJlbnQsIG5leHRFZmZlY3QpO1xuICAgICAgcmVzZXRDdXJyZW50RmliZXIoKTtcbiAgICB9XG5cbiAgICBpZiAoKGZsYWdzICYgUGFzc2l2ZSkgIT09IE5vRmxhZ3MpIHtcbiAgICAgIC8vIElmIHRoZXJlIGFyZSBwYXNzaXZlIGVmZmVjdHMsIHNjaGVkdWxlIGEgY2FsbGJhY2sgdG8gZmx1c2ggYXRcbiAgICAgIC8vIHRoZSBlYXJsaWVzdCBvcHBvcnR1bml0eS5cbiAgICAgIGlmICghcm9vdERvZXNIYXZlUGFzc2l2ZUVmZmVjdHMpIHtcbiAgICAgICAgcm9vdERvZXNIYXZlUGFzc2l2ZUVmZmVjdHMgPSB0cnVlO1xuICAgICAgICBzY2hlZHVsZUNhbGxiYWNrKE5vcm1hbFByaW9yaXR5JDEsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBmbHVzaFBhc3NpdmVFZmZlY3RzKCk7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIG5leHRFZmZlY3QgPSBuZXh0RWZmZWN0Lm5leHRFZmZlY3Q7XG4gIH1cbn1cblxuZnVuY3Rpb24gY29tbWl0TXV0YXRpb25FZmZlY3RzKHJvb3QsIHJlbmRlclByaW9yaXR5TGV2ZWwpIHtcbiAgLy8gVE9ETzogU2hvdWxkIHByb2JhYmx5IG1vdmUgdGhlIGJ1bGsgb2YgdGhpcyBmdW5jdGlvbiB0byBjb21taXRXb3JrLlxuICB3aGlsZSAobmV4dEVmZmVjdCAhPT0gbnVsbCkge1xuICAgIHNldEN1cnJlbnRGaWJlcihuZXh0RWZmZWN0KTtcbiAgICB2YXIgZmxhZ3MgPSBuZXh0RWZmZWN0LmZsYWdzO1xuXG4gICAgaWYgKGZsYWdzICYgQ29udGVudFJlc2V0KSB7XG4gICAgICBjb21taXRSZXNldFRleHRDb250ZW50KG5leHRFZmZlY3QpO1xuICAgIH1cblxuICAgIGlmIChmbGFncyAmIFJlZikge1xuICAgICAgdmFyIGN1cnJlbnQgPSBuZXh0RWZmZWN0LmFsdGVybmF0ZTtcblxuICAgICAgaWYgKGN1cnJlbnQgIT09IG51bGwpIHtcbiAgICAgICAgY29tbWl0RGV0YWNoUmVmKGN1cnJlbnQpO1xuICAgICAgfVxuICAgIH0gLy8gVGhlIGZvbGxvd2luZyBzd2l0Y2ggc3RhdGVtZW50IGlzIG9ubHkgY29uY2VybmVkIGFib3V0IHBsYWNlbWVudCxcbiAgICAvLyB1cGRhdGVzLCBhbmQgZGVsZXRpb25zLiBUbyBhdm9pZCBuZWVkaW5nIHRvIGFkZCBhIGNhc2UgZm9yIGV2ZXJ5IHBvc3NpYmxlXG4gICAgLy8gYml0bWFwIHZhbHVlLCB3ZSByZW1vdmUgdGhlIHNlY29uZGFyeSBlZmZlY3RzIGZyb20gdGhlIGVmZmVjdCB0YWcgYW5kXG4gICAgLy8gc3dpdGNoIG9uIHRoYXQgdmFsdWUuXG5cblxuICAgIHZhciBwcmltYXJ5RmxhZ3MgPSBmbGFncyAmIChQbGFjZW1lbnQgfCBVcGRhdGUgfCBEZWxldGlvbiB8IEh5ZHJhdGluZyk7XG5cbiAgICBzd2l0Y2ggKHByaW1hcnlGbGFncykge1xuICAgICAgY2FzZSBQbGFjZW1lbnQ6XG4gICAgICAgIHtcbiAgICAgICAgICBjb21taXRQbGFjZW1lbnQobmV4dEVmZmVjdCk7IC8vIENsZWFyIHRoZSBcInBsYWNlbWVudFwiIGZyb20gZWZmZWN0IHRhZyBzbyB0aGF0IHdlIGtub3cgdGhhdCB0aGlzIGlzXG4gICAgICAgICAgLy8gaW5zZXJ0ZWQsIGJlZm9yZSBhbnkgbGlmZS1jeWNsZXMgbGlrZSBjb21wb25lbnREaWRNb3VudCBnZXRzIGNhbGxlZC5cbiAgICAgICAgICAvLyBUT0RPOiBmaW5kRE9NTm9kZSBkb2Vzbid0IHJlbHkgb24gdGhpcyBhbnkgbW9yZSBidXQgaXNNb3VudGVkIGRvZXNcbiAgICAgICAgICAvLyBhbmQgaXNNb3VudGVkIGlzIGRlcHJlY2F0ZWQgYW55d2F5IHNvIHdlIHNob3VsZCBiZSBhYmxlIHRvIGtpbGwgdGhpcy5cblxuICAgICAgICAgIG5leHRFZmZlY3QuZmxhZ3MgJj0gflBsYWNlbWVudDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIFBsYWNlbWVudEFuZFVwZGF0ZTpcbiAgICAgICAge1xuICAgICAgICAgIC8vIFBsYWNlbWVudFxuICAgICAgICAgIGNvbW1pdFBsYWNlbWVudChuZXh0RWZmZWN0KTsgLy8gQ2xlYXIgdGhlIFwicGxhY2VtZW50XCIgZnJvbSBlZmZlY3QgdGFnIHNvIHRoYXQgd2Uga25vdyB0aGF0IHRoaXMgaXNcbiAgICAgICAgICAvLyBpbnNlcnRlZCwgYmVmb3JlIGFueSBsaWZlLWN5Y2xlcyBsaWtlIGNvbXBvbmVudERpZE1vdW50IGdldHMgY2FsbGVkLlxuXG4gICAgICAgICAgbmV4dEVmZmVjdC5mbGFncyAmPSB+UGxhY2VtZW50OyAvLyBVcGRhdGVcblxuICAgICAgICAgIHZhciBfY3VycmVudCA9IG5leHRFZmZlY3QuYWx0ZXJuYXRlO1xuICAgICAgICAgIGNvbW1pdFdvcmsoX2N1cnJlbnQsIG5leHRFZmZlY3QpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgSHlkcmF0aW5nOlxuICAgICAgICB7XG4gICAgICAgICAgbmV4dEVmZmVjdC5mbGFncyAmPSB+SHlkcmF0aW5nO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgSHlkcmF0aW5nQW5kVXBkYXRlOlxuICAgICAgICB7XG4gICAgICAgICAgbmV4dEVmZmVjdC5mbGFncyAmPSB+SHlkcmF0aW5nOyAvLyBVcGRhdGVcblxuICAgICAgICAgIHZhciBfY3VycmVudDIgPSBuZXh0RWZmZWN0LmFsdGVybmF0ZTtcbiAgICAgICAgICBjb21taXRXb3JrKF9jdXJyZW50MiwgbmV4dEVmZmVjdCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBVcGRhdGU6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgX2N1cnJlbnQzID0gbmV4dEVmZmVjdC5hbHRlcm5hdGU7XG4gICAgICAgICAgY29tbWl0V29yayhfY3VycmVudDMsIG5leHRFZmZlY3QpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgRGVsZXRpb246XG4gICAgICAgIHtcbiAgICAgICAgICBjb21taXREZWxldGlvbihyb290LCBuZXh0RWZmZWN0KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJlc2V0Q3VycmVudEZpYmVyKCk7XG4gICAgbmV4dEVmZmVjdCA9IG5leHRFZmZlY3QubmV4dEVmZmVjdDtcbiAgfVxufVxuXG5mdW5jdGlvbiBjb21taXRMYXlvdXRFZmZlY3RzKHJvb3QsIGNvbW1pdHRlZExhbmVzKSB7XG5cblxuICB3aGlsZSAobmV4dEVmZmVjdCAhPT0gbnVsbCkge1xuICAgIHNldEN1cnJlbnRGaWJlcihuZXh0RWZmZWN0KTtcbiAgICB2YXIgZmxhZ3MgPSBuZXh0RWZmZWN0LmZsYWdzO1xuXG4gICAgaWYgKGZsYWdzICYgKFVwZGF0ZSB8IENhbGxiYWNrKSkge1xuICAgICAgdmFyIGN1cnJlbnQgPSBuZXh0RWZmZWN0LmFsdGVybmF0ZTtcbiAgICAgIGNvbW1pdExpZmVDeWNsZXMocm9vdCwgY3VycmVudCwgbmV4dEVmZmVjdCk7XG4gICAgfVxuXG4gICAge1xuICAgICAgaWYgKGZsYWdzICYgUmVmKSB7XG4gICAgICAgIGNvbW1pdEF0dGFjaFJlZihuZXh0RWZmZWN0KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXNldEN1cnJlbnRGaWJlcigpO1xuICAgIG5leHRFZmZlY3QgPSBuZXh0RWZmZWN0Lm5leHRFZmZlY3Q7XG4gIH1cbn1cblxuZnVuY3Rpb24gZmx1c2hQYXNzaXZlRWZmZWN0cygpIHtcbiAgLy8gUmV0dXJucyB3aGV0aGVyIHBhc3NpdmUgZWZmZWN0cyB3ZXJlIGZsdXNoZWQuXG4gIGlmIChwZW5kaW5nUGFzc2l2ZUVmZmVjdHNSZW5kZXJQcmlvcml0eSAhPT0gTm9Qcmlvcml0eSQxKSB7XG4gICAgdmFyIHByaW9yaXR5TGV2ZWwgPSBwZW5kaW5nUGFzc2l2ZUVmZmVjdHNSZW5kZXJQcmlvcml0eSA+IE5vcm1hbFByaW9yaXR5JDEgPyBOb3JtYWxQcmlvcml0eSQxIDogcGVuZGluZ1Bhc3NpdmVFZmZlY3RzUmVuZGVyUHJpb3JpdHk7XG4gICAgcGVuZGluZ1Bhc3NpdmVFZmZlY3RzUmVuZGVyUHJpb3JpdHkgPSBOb1ByaW9yaXR5JDE7XG5cbiAgICB7XG4gICAgICByZXR1cm4gcnVuV2l0aFByaW9yaXR5JDEocHJpb3JpdHlMZXZlbCwgZmx1c2hQYXNzaXZlRWZmZWN0c0ltcGwpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGVucXVldWVQZW5kaW5nUGFzc2l2ZUhvb2tFZmZlY3RNb3VudChmaWJlciwgZWZmZWN0KSB7XG4gIHBlbmRpbmdQYXNzaXZlSG9va0VmZmVjdHNNb3VudC5wdXNoKGVmZmVjdCwgZmliZXIpO1xuXG4gIGlmICghcm9vdERvZXNIYXZlUGFzc2l2ZUVmZmVjdHMpIHtcbiAgICByb290RG9lc0hhdmVQYXNzaXZlRWZmZWN0cyA9IHRydWU7XG4gICAgc2NoZWR1bGVDYWxsYmFjayhOb3JtYWxQcmlvcml0eSQxLCBmdW5jdGlvbiAoKSB7XG4gICAgICBmbHVzaFBhc3NpdmVFZmZlY3RzKCk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9KTtcbiAgfVxufVxuZnVuY3Rpb24gZW5xdWV1ZVBlbmRpbmdQYXNzaXZlSG9va0VmZmVjdFVubW91bnQoZmliZXIsIGVmZmVjdCkge1xuICBwZW5kaW5nUGFzc2l2ZUhvb2tFZmZlY3RzVW5tb3VudC5wdXNoKGVmZmVjdCwgZmliZXIpO1xuXG4gIHtcbiAgICBmaWJlci5mbGFncyB8PSBQYXNzaXZlVW5tb3VudFBlbmRpbmdEZXY7XG4gICAgdmFyIGFsdGVybmF0ZSA9IGZpYmVyLmFsdGVybmF0ZTtcblxuICAgIGlmIChhbHRlcm5hdGUgIT09IG51bGwpIHtcbiAgICAgIGFsdGVybmF0ZS5mbGFncyB8PSBQYXNzaXZlVW5tb3VudFBlbmRpbmdEZXY7XG4gICAgfVxuICB9XG5cbiAgaWYgKCFyb290RG9lc0hhdmVQYXNzaXZlRWZmZWN0cykge1xuICAgIHJvb3REb2VzSGF2ZVBhc3NpdmVFZmZlY3RzID0gdHJ1ZTtcbiAgICBzY2hlZHVsZUNhbGxiYWNrKE5vcm1hbFByaW9yaXR5JDEsIGZ1bmN0aW9uICgpIHtcbiAgICAgIGZsdXNoUGFzc2l2ZUVmZmVjdHMoKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGludm9rZVBhc3NpdmVFZmZlY3RDcmVhdGUoZWZmZWN0KSB7XG4gIHZhciBjcmVhdGUgPSBlZmZlY3QuY3JlYXRlO1xuICBlZmZlY3QuZGVzdHJveSA9IGNyZWF0ZSgpO1xufVxuXG5mdW5jdGlvbiBmbHVzaFBhc3NpdmVFZmZlY3RzSW1wbCgpIHtcbiAgaWYgKHJvb3RXaXRoUGVuZGluZ1Bhc3NpdmVFZmZlY3RzID09PSBudWxsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIHJvb3QgPSByb290V2l0aFBlbmRpbmdQYXNzaXZlRWZmZWN0cztcbiAgdmFyIGxhbmVzID0gcGVuZGluZ1Bhc3NpdmVFZmZlY3RzTGFuZXM7XG4gIHJvb3RXaXRoUGVuZGluZ1Bhc3NpdmVFZmZlY3RzID0gbnVsbDtcbiAgcGVuZGluZ1Bhc3NpdmVFZmZlY3RzTGFuZXMgPSBOb0xhbmVzO1xuXG4gIGlmICghKChleGVjdXRpb25Db250ZXh0ICYgKFJlbmRlckNvbnRleHQgfCBDb21taXRDb250ZXh0KSkgPT09IE5vQ29udGV4dCkpIHtcbiAgICB7XG4gICAgICB0aHJvdyBFcnJvciggXCJDYW5ub3QgZmx1c2ggcGFzc2l2ZSBlZmZlY3RzIHdoaWxlIGFscmVhZHkgcmVuZGVyaW5nLlwiICk7XG4gICAgfVxuICB9XG5cbiAge1xuICAgIGlzRmx1c2hpbmdQYXNzaXZlRWZmZWN0cyA9IHRydWU7XG4gIH1cblxuICB2YXIgcHJldkV4ZWN1dGlvbkNvbnRleHQgPSBleGVjdXRpb25Db250ZXh0O1xuICBleGVjdXRpb25Db250ZXh0IHw9IENvbW1pdENvbnRleHQ7XG4gIHZhciBwcmV2SW50ZXJhY3Rpb25zID0gcHVzaEludGVyYWN0aW9ucyhyb290KTsgLy8gSXQncyBpbXBvcnRhbnQgdGhhdCBBTEwgcGVuZGluZyBwYXNzaXZlIGVmZmVjdCBkZXN0cm95IGZ1bmN0aW9ucyBhcmUgY2FsbGVkXG4gIC8vIGJlZm9yZSBBTlkgcGFzc2l2ZSBlZmZlY3QgY3JlYXRlIGZ1bmN0aW9ucyBhcmUgY2FsbGVkLlxuICAvLyBPdGhlcndpc2UgZWZmZWN0cyBpbiBzaWJsaW5nIGNvbXBvbmVudHMgbWlnaHQgaW50ZXJmZXJlIHdpdGggZWFjaCBvdGhlci5cbiAgLy8gZS5nLiBhIGRlc3Ryb3kgZnVuY3Rpb24gaW4gb25lIGNvbXBvbmVudCBtYXkgdW5pbnRlbnRpb25hbGx5IG92ZXJyaWRlIGEgcmVmXG4gIC8vIHZhbHVlIHNldCBieSBhIGNyZWF0ZSBmdW5jdGlvbiBpbiBhbm90aGVyIGNvbXBvbmVudC5cbiAgLy8gTGF5b3V0IGVmZmVjdHMgaGF2ZSB0aGUgc2FtZSBjb25zdHJhaW50LlxuICAvLyBGaXJzdCBwYXNzOiBEZXN0cm95IHN0YWxlIHBhc3NpdmUgZWZmZWN0cy5cblxuICB2YXIgdW5tb3VudEVmZmVjdHMgPSBwZW5kaW5nUGFzc2l2ZUhvb2tFZmZlY3RzVW5tb3VudDtcbiAgcGVuZGluZ1Bhc3NpdmVIb29rRWZmZWN0c1VubW91bnQgPSBbXTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHVubW91bnRFZmZlY3RzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgdmFyIF9lZmZlY3QgPSB1bm1vdW50RWZmZWN0c1tpXTtcbiAgICB2YXIgZmliZXIgPSB1bm1vdW50RWZmZWN0c1tpICsgMV07XG4gICAgdmFyIGRlc3Ryb3kgPSBfZWZmZWN0LmRlc3Ryb3k7XG4gICAgX2VmZmVjdC5kZXN0cm95ID0gdW5kZWZpbmVkO1xuXG4gICAge1xuICAgICAgZmliZXIuZmxhZ3MgJj0gflBhc3NpdmVVbm1vdW50UGVuZGluZ0RldjtcbiAgICAgIHZhciBhbHRlcm5hdGUgPSBmaWJlci5hbHRlcm5hdGU7XG5cbiAgICAgIGlmIChhbHRlcm5hdGUgIT09IG51bGwpIHtcbiAgICAgICAgYWx0ZXJuYXRlLmZsYWdzICY9IH5QYXNzaXZlVW5tb3VudFBlbmRpbmdEZXY7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBkZXN0cm95ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB7XG4gICAgICAgIHNldEN1cnJlbnRGaWJlcihmaWJlcik7XG5cbiAgICAgICAge1xuICAgICAgICAgIGludm9rZUd1YXJkZWRDYWxsYmFjayhudWxsLCBkZXN0cm95LCBudWxsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChoYXNDYXVnaHRFcnJvcigpKSB7XG4gICAgICAgICAgaWYgKCEoZmliZXIgIT09IG51bGwpKSB7XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHRocm93IEVycm9yKCBcIlNob3VsZCBiZSB3b3JraW5nIG9uIGFuIGVmZmVjdC5cIiApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBlcnJvciA9IGNsZWFyQ2F1Z2h0RXJyb3IoKTtcbiAgICAgICAgICBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihmaWJlciwgZXJyb3IpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVzZXRDdXJyZW50RmliZXIoKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gLy8gU2Vjb25kIHBhc3M6IENyZWF0ZSBuZXcgcGFzc2l2ZSBlZmZlY3RzLlxuXG5cbiAgdmFyIG1vdW50RWZmZWN0cyA9IHBlbmRpbmdQYXNzaXZlSG9va0VmZmVjdHNNb3VudDtcbiAgcGVuZGluZ1Bhc3NpdmVIb29rRWZmZWN0c01vdW50ID0gW107XG5cbiAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IG1vdW50RWZmZWN0cy5sZW5ndGg7IF9pICs9IDIpIHtcbiAgICB2YXIgX2VmZmVjdDIgPSBtb3VudEVmZmVjdHNbX2ldO1xuICAgIHZhciBfZmliZXIgPSBtb3VudEVmZmVjdHNbX2kgKyAxXTtcblxuICAgIHtcbiAgICAgIHNldEN1cnJlbnRGaWJlcihfZmliZXIpO1xuXG4gICAgICB7XG4gICAgICAgIGludm9rZUd1YXJkZWRDYWxsYmFjayhudWxsLCBpbnZva2VQYXNzaXZlRWZmZWN0Q3JlYXRlLCBudWxsLCBfZWZmZWN0Mik7XG4gICAgICB9XG5cbiAgICAgIGlmIChoYXNDYXVnaHRFcnJvcigpKSB7XG4gICAgICAgIGlmICghKF9maWJlciAhPT0gbnVsbCkpIHtcbiAgICAgICAgICB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvciggXCJTaG91bGQgYmUgd29ya2luZyBvbiBhbiBlZmZlY3QuXCIgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgX2Vycm9yNCA9IGNsZWFyQ2F1Z2h0RXJyb3IoKTtcblxuICAgICAgICBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihfZmliZXIsIF9lcnJvcjQpO1xuICAgICAgfVxuXG4gICAgICByZXNldEN1cnJlbnRGaWJlcigpO1xuICAgIH1cbiAgfSAvLyBOb3RlOiBUaGlzIGN1cnJlbnRseSBhc3N1bWVzIHRoZXJlIGFyZSBubyBwYXNzaXZlIGVmZmVjdHMgb24gdGhlIHJvb3QgZmliZXJcbiAgLy8gYmVjYXVzZSB0aGUgcm9vdCBpcyBub3QgcGFydCBvZiBpdHMgb3duIGVmZmVjdCBsaXN0LlxuICAvLyBUaGlzIGNvdWxkIGNoYW5nZSBpbiB0aGUgZnV0dXJlLlxuXG5cbiAgdmFyIGVmZmVjdCA9IHJvb3QuY3VycmVudC5maXJzdEVmZmVjdDtcblxuICB3aGlsZSAoZWZmZWN0ICE9PSBudWxsKSB7XG4gICAgdmFyIG5leHROZXh0RWZmZWN0ID0gZWZmZWN0Lm5leHRFZmZlY3Q7IC8vIFJlbW92ZSBuZXh0RWZmZWN0IHBvaW50ZXIgdG8gYXNzaXN0IEdDXG5cbiAgICBlZmZlY3QubmV4dEVmZmVjdCA9IG51bGw7XG5cbiAgICBpZiAoZWZmZWN0LmZsYWdzICYgRGVsZXRpb24pIHtcbiAgICAgIGRldGFjaEZpYmVyQWZ0ZXJFZmZlY3RzKGVmZmVjdCk7XG4gICAgfVxuXG4gICAgZWZmZWN0ID0gbmV4dE5leHRFZmZlY3Q7XG4gIH1cblxuICB7XG4gICAgcG9wSW50ZXJhY3Rpb25zKHByZXZJbnRlcmFjdGlvbnMpO1xuICAgIGZpbmlzaFBlbmRpbmdJbnRlcmFjdGlvbnMocm9vdCwgbGFuZXMpO1xuICB9XG5cbiAge1xuICAgIGlzRmx1c2hpbmdQYXNzaXZlRWZmZWN0cyA9IGZhbHNlO1xuICB9XG5cbiAgZXhlY3V0aW9uQ29udGV4dCA9IHByZXZFeGVjdXRpb25Db250ZXh0O1xuICBmbHVzaFN5bmNDYWxsYmFja1F1ZXVlKCk7IC8vIElmIGFkZGl0aW9uYWwgcGFzc2l2ZSBlZmZlY3RzIHdlcmUgc2NoZWR1bGVkLCBpbmNyZW1lbnQgYSBjb3VudGVyLiBJZiB0aGlzXG4gIC8vIGV4Y2VlZHMgdGhlIGxpbWl0LCB3ZSdsbCBmaXJlIGEgd2FybmluZy5cblxuICBuZXN0ZWRQYXNzaXZlVXBkYXRlQ291bnQgPSByb290V2l0aFBlbmRpbmdQYXNzaXZlRWZmZWN0cyA9PT0gbnVsbCA/IDAgOiBuZXN0ZWRQYXNzaXZlVXBkYXRlQ291bnQgKyAxO1xuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gaXNBbHJlYWR5RmFpbGVkTGVnYWN5RXJyb3JCb3VuZGFyeShpbnN0YW5jZSkge1xuICByZXR1cm4gbGVnYWN5RXJyb3JCb3VuZGFyaWVzVGhhdEFscmVhZHlGYWlsZWQgIT09IG51bGwgJiYgbGVnYWN5RXJyb3JCb3VuZGFyaWVzVGhhdEFscmVhZHlGYWlsZWQuaGFzKGluc3RhbmNlKTtcbn1cbmZ1bmN0aW9uIG1hcmtMZWdhY3lFcnJvckJvdW5kYXJ5QXNGYWlsZWQoaW5zdGFuY2UpIHtcbiAgaWYgKGxlZ2FjeUVycm9yQm91bmRhcmllc1RoYXRBbHJlYWR5RmFpbGVkID09PSBudWxsKSB7XG4gICAgbGVnYWN5RXJyb3JCb3VuZGFyaWVzVGhhdEFscmVhZHlGYWlsZWQgPSBuZXcgU2V0KFtpbnN0YW5jZV0pO1xuICB9IGVsc2Uge1xuICAgIGxlZ2FjeUVycm9yQm91bmRhcmllc1RoYXRBbHJlYWR5RmFpbGVkLmFkZChpbnN0YW5jZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJlcGFyZVRvVGhyb3dVbmNhdWdodEVycm9yKGVycm9yKSB7XG4gIGlmICghaGFzVW5jYXVnaHRFcnJvcikge1xuICAgIGhhc1VuY2F1Z2h0RXJyb3IgPSB0cnVlO1xuICAgIGZpcnN0VW5jYXVnaHRFcnJvciA9IGVycm9yO1xuICB9XG59XG5cbnZhciBvblVuY2F1Z2h0RXJyb3IgPSBwcmVwYXJlVG9UaHJvd1VuY2F1Z2h0RXJyb3I7XG5cbmZ1bmN0aW9uIGNhcHR1cmVDb21taXRQaGFzZUVycm9yT25Sb290KHJvb3RGaWJlciwgc291cmNlRmliZXIsIGVycm9yKSB7XG4gIHZhciBlcnJvckluZm8gPSBjcmVhdGVDYXB0dXJlZFZhbHVlKGVycm9yLCBzb3VyY2VGaWJlcik7XG4gIHZhciB1cGRhdGUgPSBjcmVhdGVSb290RXJyb3JVcGRhdGUocm9vdEZpYmVyLCBlcnJvckluZm8sIFN5bmNMYW5lKTtcbiAgZW5xdWV1ZVVwZGF0ZShyb290RmliZXIsIHVwZGF0ZSk7XG4gIHZhciBldmVudFRpbWUgPSByZXF1ZXN0RXZlbnRUaW1lKCk7XG4gIHZhciByb290ID0gbWFya1VwZGF0ZUxhbmVGcm9tRmliZXJUb1Jvb3Qocm9vdEZpYmVyLCBTeW5jTGFuZSk7XG5cbiAgaWYgKHJvb3QgIT09IG51bGwpIHtcbiAgICBtYXJrUm9vdFVwZGF0ZWQocm9vdCwgU3luY0xhbmUsIGV2ZW50VGltZSk7XG4gICAgZW5zdXJlUm9vdElzU2NoZWR1bGVkKHJvb3QsIGV2ZW50VGltZSk7XG4gICAgc2NoZWR1bGVQZW5kaW5nSW50ZXJhY3Rpb25zKHJvb3QsIFN5bmNMYW5lKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihzb3VyY2VGaWJlciwgZXJyb3IpIHtcbiAgaWYgKHNvdXJjZUZpYmVyLnRhZyA9PT0gSG9zdFJvb3QpIHtcbiAgICAvLyBFcnJvciB3YXMgdGhyb3duIGF0IHRoZSByb290LiBUaGVyZSBpcyBubyBwYXJlbnQsIHNvIHRoZSByb290XG4gICAgLy8gaXRzZWxmIHNob3VsZCBjYXB0dXJlIGl0LlxuICAgIGNhcHR1cmVDb21taXRQaGFzZUVycm9yT25Sb290KHNvdXJjZUZpYmVyLCBzb3VyY2VGaWJlciwgZXJyb3IpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBmaWJlciA9IHNvdXJjZUZpYmVyLnJldHVybjtcblxuICB3aGlsZSAoZmliZXIgIT09IG51bGwpIHtcbiAgICBpZiAoZmliZXIudGFnID09PSBIb3N0Um9vdCkge1xuICAgICAgY2FwdHVyZUNvbW1pdFBoYXNlRXJyb3JPblJvb3QoZmliZXIsIHNvdXJjZUZpYmVyLCBlcnJvcik7XG4gICAgICByZXR1cm47XG4gICAgfSBlbHNlIGlmIChmaWJlci50YWcgPT09IENsYXNzQ29tcG9uZW50KSB7XG4gICAgICB2YXIgY3RvciA9IGZpYmVyLnR5cGU7XG4gICAgICB2YXIgaW5zdGFuY2UgPSBmaWJlci5zdGF0ZU5vZGU7XG5cbiAgICAgIGlmICh0eXBlb2YgY3Rvci5nZXREZXJpdmVkU3RhdGVGcm9tRXJyb3IgPT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudERpZENhdGNoID09PSAnZnVuY3Rpb24nICYmICFpc0FscmVhZHlGYWlsZWRMZWdhY3lFcnJvckJvdW5kYXJ5KGluc3RhbmNlKSkge1xuICAgICAgICB2YXIgZXJyb3JJbmZvID0gY3JlYXRlQ2FwdHVyZWRWYWx1ZShlcnJvciwgc291cmNlRmliZXIpO1xuICAgICAgICB2YXIgdXBkYXRlID0gY3JlYXRlQ2xhc3NFcnJvclVwZGF0ZShmaWJlciwgZXJyb3JJbmZvLCBTeW5jTGFuZSk7XG4gICAgICAgIGVucXVldWVVcGRhdGUoZmliZXIsIHVwZGF0ZSk7XG4gICAgICAgIHZhciBldmVudFRpbWUgPSByZXF1ZXN0RXZlbnRUaW1lKCk7XG4gICAgICAgIHZhciByb290ID0gbWFya1VwZGF0ZUxhbmVGcm9tRmliZXJUb1Jvb3QoZmliZXIsIFN5bmNMYW5lKTtcblxuICAgICAgICBpZiAocm9vdCAhPT0gbnVsbCkge1xuICAgICAgICAgIG1hcmtSb290VXBkYXRlZChyb290LCBTeW5jTGFuZSwgZXZlbnRUaW1lKTtcbiAgICAgICAgICBlbnN1cmVSb290SXNTY2hlZHVsZWQocm9vdCwgZXZlbnRUaW1lKTtcbiAgICAgICAgICBzY2hlZHVsZVBlbmRpbmdJbnRlcmFjdGlvbnMocm9vdCwgU3luY0xhbmUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIFRoaXMgY29tcG9uZW50IGhhcyBhbHJlYWR5IGJlZW4gdW5tb3VudGVkLlxuICAgICAgICAgIC8vIFdlIGNhbid0IHNjaGVkdWxlIGFueSBmb2xsb3cgdXAgd29yayBmb3IgdGhlIHJvb3QgYmVjYXVzZSB0aGUgZmliZXIgaXMgYWxyZWFkeSB1bm1vdW50ZWQsXG4gICAgICAgICAgLy8gYnV0IHdlIGNhbiBzdGlsbCBjYWxsIHRoZSBsb2ctb25seSBib3VuZGFyeSBzbyB0aGUgZXJyb3IgaXNuJ3Qgc3dhbGxvd2VkLlxuICAgICAgICAgIC8vXG4gICAgICAgICAgLy8gVE9ETyBUaGlzIGlzIG9ubHkgYSB0ZW1wb3JhcnkgYmFuZGFpZCBmb3IgdGhlIG9sZCByZWNvbmNpbGVyIGZvcmsuXG4gICAgICAgICAgLy8gV2UgY2FuIGRlbGV0ZSB0aGlzIHNwZWNpYWwgY2FzZSBvbmNlIHRoZSBuZXcgZm9yayBpcyBtZXJnZWQuXG4gICAgICAgICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnREaWRDYXRjaCA9PT0gJ2Z1bmN0aW9uJyAmJiAhaXNBbHJlYWR5RmFpbGVkTGVnYWN5RXJyb3JCb3VuZGFyeShpbnN0YW5jZSkpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGluc3RhbmNlLmNvbXBvbmVudERpZENhdGNoKGVycm9yLCBlcnJvckluZm8pO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3JUb0lnbm9yZSkgey8vIFRPRE8gSWdub3JlIHRoaXMgZXJyb3I/IFJldGhyb3cgaXQ/XG4gICAgICAgICAgICAgIC8vIFRoaXMgaXMga2luZCBvZiBhbiBlZGdlIGNhc2UuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZpYmVyID0gZmliZXIucmV0dXJuO1xuICB9XG59XG5mdW5jdGlvbiBwaW5nU3VzcGVuZGVkUm9vdChyb290LCB3YWtlYWJsZSwgcGluZ2VkTGFuZXMpIHtcbiAgdmFyIHBpbmdDYWNoZSA9IHJvb3QucGluZ0NhY2hlO1xuXG4gIGlmIChwaW5nQ2FjaGUgIT09IG51bGwpIHtcbiAgICAvLyBUaGUgd2FrZWFibGUgcmVzb2x2ZWQsIHNvIHdlIG5vIGxvbmdlciBuZWVkIHRvIG1lbW9pemUsIGJlY2F1c2UgaXQgd2lsbFxuICAgIC8vIG5ldmVyIGJlIHRocm93biBhZ2Fpbi5cbiAgICBwaW5nQ2FjaGUuZGVsZXRlKHdha2VhYmxlKTtcbiAgfVxuXG4gIHZhciBldmVudFRpbWUgPSByZXF1ZXN0RXZlbnRUaW1lKCk7XG4gIG1hcmtSb290UGluZ2VkKHJvb3QsIHBpbmdlZExhbmVzKTtcblxuICBpZiAod29ya0luUHJvZ3Jlc3NSb290ID09PSByb290ICYmIGlzU3Vic2V0T2ZMYW5lcyh3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcywgcGluZ2VkTGFuZXMpKSB7XG4gICAgLy8gUmVjZWl2ZWQgYSBwaW5nIGF0IHRoZSBzYW1lIHByaW9yaXR5IGxldmVsIGF0IHdoaWNoIHdlJ3JlIGN1cnJlbnRseVxuICAgIC8vIHJlbmRlcmluZy4gV2UgbWlnaHQgd2FudCB0byByZXN0YXJ0IHRoaXMgcmVuZGVyLiBUaGlzIHNob3VsZCBtaXJyb3JcbiAgICAvLyB0aGUgbG9naWMgb2Ygd2hldGhlciBvciBub3QgYSByb290IHN1c3BlbmRzIG9uY2UgaXQgY29tcGxldGVzLlxuICAgIC8vIFRPRE86IElmIHdlJ3JlIHJlbmRlcmluZyBzeW5jIGVpdGhlciBkdWUgdG8gU3luYywgQmF0Y2hlZCBvciBleHBpcmVkLFxuICAgIC8vIHdlIHNob3VsZCBwcm9iYWJseSBuZXZlciByZXN0YXJ0LlxuICAgIC8vIElmIHdlJ3JlIHN1c3BlbmRlZCB3aXRoIGRlbGF5LCBvciBpZiBpdCdzIGEgcmV0cnksIHdlJ2xsIGFsd2F5cyBzdXNwZW5kXG4gICAgLy8gc28gd2UgY2FuIGFsd2F5cyByZXN0YXJ0LlxuICAgIGlmICh3b3JrSW5Qcm9ncmVzc1Jvb3RFeGl0U3RhdHVzID09PSBSb290U3VzcGVuZGVkV2l0aERlbGF5IHx8IHdvcmtJblByb2dyZXNzUm9vdEV4aXRTdGF0dXMgPT09IFJvb3RTdXNwZW5kZWQgJiYgaW5jbHVkZXNPbmx5UmV0cmllcyh3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcykgJiYgbm93KCkgLSBnbG9iYWxNb3N0UmVjZW50RmFsbGJhY2tUaW1lIDwgRkFMTEJBQ0tfVEhST1RUTEVfTVMpIHtcbiAgICAgIC8vIFJlc3RhcnQgZnJvbSB0aGUgcm9vdC5cbiAgICAgIHByZXBhcmVGcmVzaFN0YWNrKHJvb3QsIE5vTGFuZXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBFdmVuIHRob3VnaCB3ZSBjYW4ndCByZXN0YXJ0IHJpZ2h0IG5vdywgd2UgbWlnaHQgZ2V0IGFuXG4gICAgICAvLyBvcHBvcnR1bml0eSBsYXRlci4gU28gd2UgbWFyayB0aGlzIHJlbmRlciBhcyBoYXZpbmcgYSBwaW5nLlxuICAgICAgd29ya0luUHJvZ3Jlc3NSb290UGluZ2VkTGFuZXMgPSBtZXJnZUxhbmVzKHdvcmtJblByb2dyZXNzUm9vdFBpbmdlZExhbmVzLCBwaW5nZWRMYW5lcyk7XG4gICAgfVxuICB9XG5cbiAgZW5zdXJlUm9vdElzU2NoZWR1bGVkKHJvb3QsIGV2ZW50VGltZSk7XG4gIHNjaGVkdWxlUGVuZGluZ0ludGVyYWN0aW9ucyhyb290LCBwaW5nZWRMYW5lcyk7XG59XG5cbmZ1bmN0aW9uIHJldHJ5VGltZWRPdXRCb3VuZGFyeShib3VuZGFyeUZpYmVyLCByZXRyeUxhbmUpIHtcbiAgLy8gVGhlIGJvdW5kYXJ5IGZpYmVyIChhIFN1c3BlbnNlIGNvbXBvbmVudCBvciBTdXNwZW5zZUxpc3QgY29tcG9uZW50KVxuICAvLyBwcmV2aW91c2x5IHdhcyByZW5kZXJlZCBpbiBpdHMgZmFsbGJhY2sgc3RhdGUuIE9uZSBvZiB0aGUgcHJvbWlzZXMgdGhhdFxuICAvLyBzdXNwZW5kZWQgaXQgaGFzIHJlc29sdmVkLCB3aGljaCBtZWFucyBhdCBsZWFzdCBwYXJ0IG9mIHRoZSB0cmVlIHdhc1xuICAvLyBsaWtlbHkgdW5ibG9ja2VkLiBUcnkgcmVuZGVyaW5nIGFnYWluLCBhdCBhIG5ldyBleHBpcmF0aW9uIHRpbWUuXG4gIGlmIChyZXRyeUxhbmUgPT09IE5vTGFuZSkge1xuICAgIHJldHJ5TGFuZSA9IHJlcXVlc3RSZXRyeUxhbmUoYm91bmRhcnlGaWJlcik7XG4gIH0gLy8gVE9ETzogU3BlY2lhbCBjYXNlIGlkbGUgcHJpb3JpdHk/XG5cblxuICB2YXIgZXZlbnRUaW1lID0gcmVxdWVzdEV2ZW50VGltZSgpO1xuICB2YXIgcm9vdCA9IG1hcmtVcGRhdGVMYW5lRnJvbUZpYmVyVG9Sb290KGJvdW5kYXJ5RmliZXIsIHJldHJ5TGFuZSk7XG5cbiAgaWYgKHJvb3QgIT09IG51bGwpIHtcbiAgICBtYXJrUm9vdFVwZGF0ZWQocm9vdCwgcmV0cnlMYW5lLCBldmVudFRpbWUpO1xuICAgIGVuc3VyZVJvb3RJc1NjaGVkdWxlZChyb290LCBldmVudFRpbWUpO1xuICAgIHNjaGVkdWxlUGVuZGluZ0ludGVyYWN0aW9ucyhyb290LCByZXRyeUxhbmUpO1xuICB9XG59XG5mdW5jdGlvbiByZXNvbHZlUmV0cnlXYWtlYWJsZShib3VuZGFyeUZpYmVyLCB3YWtlYWJsZSkge1xuICB2YXIgcmV0cnlMYW5lID0gTm9MYW5lOyAvLyBEZWZhdWx0XG5cbiAgdmFyIHJldHJ5Q2FjaGU7XG5cbiAge1xuICAgIHJldHJ5Q2FjaGUgPSBib3VuZGFyeUZpYmVyLnN0YXRlTm9kZTtcbiAgfVxuXG4gIGlmIChyZXRyeUNhY2hlICE9PSBudWxsKSB7XG4gICAgLy8gVGhlIHdha2VhYmxlIHJlc29sdmVkLCBzbyB3ZSBubyBsb25nZXIgbmVlZCB0byBtZW1vaXplLCBiZWNhdXNlIGl0IHdpbGxcbiAgICAvLyBuZXZlciBiZSB0aHJvd24gYWdhaW4uXG4gICAgcmV0cnlDYWNoZS5kZWxldGUod2FrZWFibGUpO1xuICB9XG5cbiAgcmV0cnlUaW1lZE91dEJvdW5kYXJ5KGJvdW5kYXJ5RmliZXIsIHJldHJ5TGFuZSk7XG59IC8vIENvbXB1dGVzIHRoZSBuZXh0IEp1c3QgTm90aWNlYWJsZSBEaWZmZXJlbmNlIChKTkQpIGJvdW5kYXJ5LlxuLy8gVGhlIHRoZW9yeSBpcyB0aGF0IGEgcGVyc29uIGNhbid0IHRlbGwgdGhlIGRpZmZlcmVuY2UgYmV0d2VlbiBzbWFsbCBkaWZmZXJlbmNlcyBpbiB0aW1lLlxuLy8gVGhlcmVmb3JlLCBpZiB3ZSB3YWl0IGEgYml0IGxvbmdlciB0aGFuIG5lY2Vzc2FyeSB0aGF0IHdvbid0IHRyYW5zbGF0ZSB0byBhIG5vdGljZWFibGVcbi8vIGRpZmZlcmVuY2UgaW4gdGhlIGV4cGVyaWVuY2UuIEhvd2V2ZXIsIHdhaXRpbmcgZm9yIGxvbmdlciBtaWdodCBtZWFuIHRoYXQgd2UgY2FuIGF2b2lkXG4vLyBzaG93aW5nIGFuIGludGVybWVkaWF0ZSBsb2FkaW5nIHN0YXRlLiBUaGUgbG9uZ2VyIHdlIGhhdmUgYWxyZWFkeSB3YWl0ZWQsIHRoZSBoYXJkZXIgaXRcbi8vIGlzIHRvIHRlbGwgc21hbGwgZGlmZmVyZW5jZXMgaW4gdGltZS4gVGhlcmVmb3JlLCB0aGUgbG9uZ2VyIHdlJ3ZlIGFscmVhZHkgd2FpdGVkLFxuLy8gdGhlIGxvbmdlciB3ZSBjYW4gd2FpdCBhZGRpdGlvbmFsbHkuIEF0IHNvbWUgcG9pbnQgd2UgaGF2ZSB0byBnaXZlIHVwIHRob3VnaC5cbi8vIFdlIHBpY2sgYSB0cmFpbiBtb2RlbCB3aGVyZSB0aGUgbmV4dCBib3VuZGFyeSBjb21taXRzIGF0IGEgY29uc2lzdGVudCBzY2hlZHVsZS5cbi8vIFRoZXNlIHBhcnRpY3VsYXIgbnVtYmVycyBhcmUgdmFndWUgZXN0aW1hdGVzLiBXZSBleHBlY3QgdG8gYWRqdXN0IHRoZW0gYmFzZWQgb24gcmVzZWFyY2guXG5cbmZ1bmN0aW9uIGpuZCh0aW1lRWxhcHNlZCkge1xuICByZXR1cm4gdGltZUVsYXBzZWQgPCAxMjAgPyAxMjAgOiB0aW1lRWxhcHNlZCA8IDQ4MCA/IDQ4MCA6IHRpbWVFbGFwc2VkIDwgMTA4MCA/IDEwODAgOiB0aW1lRWxhcHNlZCA8IDE5MjAgPyAxOTIwIDogdGltZUVsYXBzZWQgPCAzMDAwID8gMzAwMCA6IHRpbWVFbGFwc2VkIDwgNDMyMCA/IDQzMjAgOiBjZWlsKHRpbWVFbGFwc2VkIC8gMTk2MCkgKiAxOTYwO1xufVxuXG5mdW5jdGlvbiBjaGVja0Zvck5lc3RlZFVwZGF0ZXMoKSB7XG4gIGlmIChuZXN0ZWRVcGRhdGVDb3VudCA+IE5FU1RFRF9VUERBVEVfTElNSVQpIHtcbiAgICBuZXN0ZWRVcGRhdGVDb3VudCA9IDA7XG4gICAgcm9vdFdpdGhOZXN0ZWRVcGRhdGVzID0gbnVsbDtcblxuICAgIHtcbiAgICAgIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoIFwiTWF4aW11bSB1cGRhdGUgZGVwdGggZXhjZWVkZWQuIFRoaXMgY2FuIGhhcHBlbiB3aGVuIGEgY29tcG9uZW50IHJlcGVhdGVkbHkgY2FsbHMgc2V0U3RhdGUgaW5zaWRlIGNvbXBvbmVudFdpbGxVcGRhdGUgb3IgY29tcG9uZW50RGlkVXBkYXRlLiBSZWFjdCBsaW1pdHMgdGhlIG51bWJlciBvZiBuZXN0ZWQgdXBkYXRlcyB0byBwcmV2ZW50IGluZmluaXRlIGxvb3BzLlwiICk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAge1xuICAgIGlmIChuZXN0ZWRQYXNzaXZlVXBkYXRlQ291bnQgPiBORVNURURfUEFTU0lWRV9VUERBVEVfTElNSVQpIHtcbiAgICAgIG5lc3RlZFBhc3NpdmVVcGRhdGVDb3VudCA9IDA7XG5cbiAgICAgIGVycm9yKCdNYXhpbXVtIHVwZGF0ZSBkZXB0aCBleGNlZWRlZC4gVGhpcyBjYW4gaGFwcGVuIHdoZW4gYSBjb21wb25lbnQgJyArIFwiY2FsbHMgc2V0U3RhdGUgaW5zaWRlIHVzZUVmZmVjdCwgYnV0IHVzZUVmZmVjdCBlaXRoZXIgZG9lc24ndCBcIiArICdoYXZlIGEgZGVwZW5kZW5jeSBhcnJheSwgb3Igb25lIG9mIHRoZSBkZXBlbmRlbmNpZXMgY2hhbmdlcyBvbiAnICsgJ2V2ZXJ5IHJlbmRlci4nKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZmx1c2hSZW5kZXJQaGFzZVN0cmljdE1vZGVXYXJuaW5nc0luREVWKCkge1xuICB7XG4gICAgUmVhY3RTdHJpY3RNb2RlV2FybmluZ3MuZmx1c2hMZWdhY3lDb250ZXh0V2FybmluZygpO1xuXG4gICAge1xuICAgICAgUmVhY3RTdHJpY3RNb2RlV2FybmluZ3MuZmx1c2hQZW5kaW5nVW5zYWZlTGlmZWN5Y2xlV2FybmluZ3MoKTtcbiAgICB9XG4gIH1cbn1cblxudmFyIGRpZFdhcm5TdGF0ZVVwZGF0ZUZvck5vdFlldE1vdW50ZWRDb21wb25lbnQgPSBudWxsO1xuXG5mdW5jdGlvbiB3YXJuQWJvdXRVcGRhdGVPbk5vdFlldE1vdW50ZWRGaWJlckluREVWKGZpYmVyKSB7XG4gIHtcbiAgICBpZiAoKGV4ZWN1dGlvbkNvbnRleHQgJiBSZW5kZXJDb250ZXh0KSAhPT0gTm9Db250ZXh0KSB7XG4gICAgICAvLyBXZSBsZXQgdGhlIG90aGVyIHdhcm5pbmcgYWJvdXQgcmVuZGVyIHBoYXNlIHVwZGF0ZXMgZGVhbCB3aXRoIHRoaXMgb25lLlxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICghKGZpYmVyLm1vZGUgJiAoQmxvY2tpbmdNb2RlIHwgQ29uY3VycmVudE1vZGUpKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciB0YWcgPSBmaWJlci50YWc7XG5cbiAgICBpZiAodGFnICE9PSBJbmRldGVybWluYXRlQ29tcG9uZW50ICYmIHRhZyAhPT0gSG9zdFJvb3QgJiYgdGFnICE9PSBDbGFzc0NvbXBvbmVudCAmJiB0YWcgIT09IEZ1bmN0aW9uQ29tcG9uZW50ICYmIHRhZyAhPT0gRm9yd2FyZFJlZiAmJiB0YWcgIT09IE1lbW9Db21wb25lbnQgJiYgdGFnICE9PSBTaW1wbGVNZW1vQ29tcG9uZW50ICYmIHRhZyAhPT0gQmxvY2spIHtcbiAgICAgIC8vIE9ubHkgd2FybiBmb3IgdXNlci1kZWZpbmVkIGNvbXBvbmVudHMsIG5vdCBpbnRlcm5hbCBvbmVzIGxpa2UgU3VzcGVuc2UuXG4gICAgICByZXR1cm47XG4gICAgfSAvLyBXZSBzaG93IHRoZSB3aG9sZSBzdGFjayBidXQgZGVkdXBlIG9uIHRoZSB0b3AgY29tcG9uZW50J3MgbmFtZSBiZWNhdXNlXG4gICAgLy8gdGhlIHByb2JsZW1hdGljIGNvZGUgYWxtb3N0IGFsd2F5cyBsaWVzIGluc2lkZSB0aGF0IGNvbXBvbmVudC5cblxuXG4gICAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lKGZpYmVyLnR5cGUpIHx8ICdSZWFjdENvbXBvbmVudCc7XG5cbiAgICBpZiAoZGlkV2FyblN0YXRlVXBkYXRlRm9yTm90WWV0TW91bnRlZENvbXBvbmVudCAhPT0gbnVsbCkge1xuICAgICAgaWYgKGRpZFdhcm5TdGF0ZVVwZGF0ZUZvck5vdFlldE1vdW50ZWRDb21wb25lbnQuaGFzKGNvbXBvbmVudE5hbWUpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgZGlkV2FyblN0YXRlVXBkYXRlRm9yTm90WWV0TW91bnRlZENvbXBvbmVudC5hZGQoY29tcG9uZW50TmFtZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRpZFdhcm5TdGF0ZVVwZGF0ZUZvck5vdFlldE1vdW50ZWRDb21wb25lbnQgPSBuZXcgU2V0KFtjb21wb25lbnROYW1lXSk7XG4gICAgfVxuXG4gICAgdmFyIHByZXZpb3VzRmliZXIgPSBjdXJyZW50O1xuXG4gICAgdHJ5IHtcbiAgICAgIHNldEN1cnJlbnRGaWJlcihmaWJlcik7XG5cbiAgICAgIGVycm9yKFwiQ2FuJ3QgcGVyZm9ybSBhIFJlYWN0IHN0YXRlIHVwZGF0ZSBvbiBhIGNvbXBvbmVudCB0aGF0IGhhc24ndCBtb3VudGVkIHlldC4gXCIgKyAnVGhpcyBpbmRpY2F0ZXMgdGhhdCB5b3UgaGF2ZSBhIHNpZGUtZWZmZWN0IGluIHlvdXIgcmVuZGVyIGZ1bmN0aW9uIHRoYXQgJyArICdhc3luY2hyb25vdXNseSBsYXRlciBjYWxscyB0cmllcyB0byB1cGRhdGUgdGhlIGNvbXBvbmVudC4gTW92ZSB0aGlzIHdvcmsgdG8gJyArICd1c2VFZmZlY3QgaW5zdGVhZC4nKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgaWYgKHByZXZpb3VzRmliZXIpIHtcbiAgICAgICAgc2V0Q3VycmVudEZpYmVyKGZpYmVyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc2V0Q3VycmVudEZpYmVyKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbnZhciBkaWRXYXJuU3RhdGVVcGRhdGVGb3JVbm1vdW50ZWRDb21wb25lbnQgPSBudWxsO1xuXG5mdW5jdGlvbiB3YXJuQWJvdXRVcGRhdGVPblVubW91bnRlZEZpYmVySW5ERVYoZmliZXIpIHtcbiAge1xuICAgIHZhciB0YWcgPSBmaWJlci50YWc7XG5cbiAgICBpZiAodGFnICE9PSBIb3N0Um9vdCAmJiB0YWcgIT09IENsYXNzQ29tcG9uZW50ICYmIHRhZyAhPT0gRnVuY3Rpb25Db21wb25lbnQgJiYgdGFnICE9PSBGb3J3YXJkUmVmICYmIHRhZyAhPT0gTWVtb0NvbXBvbmVudCAmJiB0YWcgIT09IFNpbXBsZU1lbW9Db21wb25lbnQgJiYgdGFnICE9PSBCbG9jaykge1xuICAgICAgLy8gT25seSB3YXJuIGZvciB1c2VyLWRlZmluZWQgY29tcG9uZW50cywgbm90IGludGVybmFsIG9uZXMgbGlrZSBTdXNwZW5zZS5cbiAgICAgIHJldHVybjtcbiAgICB9IC8vIElmIHRoZXJlIGFyZSBwZW5kaW5nIHBhc3NpdmUgZWZmZWN0cyB1bm1vdW50cyBmb3IgdGhpcyBGaWJlcixcbiAgICAvLyB3ZSBjYW4gYXNzdW1lIHRoYXQgdGhleSB3b3VsZCBoYXZlIHByZXZlbnRlZCB0aGlzIHVwZGF0ZS5cblxuXG4gICAgaWYgKChmaWJlci5mbGFncyAmIFBhc3NpdmVVbm1vdW50UGVuZGluZ0RldikgIT09IE5vRmxhZ3MpIHtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIFdlIHNob3cgdGhlIHdob2xlIHN0YWNrIGJ1dCBkZWR1cGUgb24gdGhlIHRvcCBjb21wb25lbnQncyBuYW1lIGJlY2F1c2VcbiAgICAvLyB0aGUgcHJvYmxlbWF0aWMgY29kZSBhbG1vc3QgYWx3YXlzIGxpZXMgaW5zaWRlIHRoYXQgY29tcG9uZW50LlxuXG5cbiAgICB2YXIgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWUoZmliZXIudHlwZSkgfHwgJ1JlYWN0Q29tcG9uZW50JztcblxuICAgIGlmIChkaWRXYXJuU3RhdGVVcGRhdGVGb3JVbm1vdW50ZWRDb21wb25lbnQgIT09IG51bGwpIHtcbiAgICAgIGlmIChkaWRXYXJuU3RhdGVVcGRhdGVGb3JVbm1vdW50ZWRDb21wb25lbnQuaGFzKGNvbXBvbmVudE5hbWUpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgZGlkV2FyblN0YXRlVXBkYXRlRm9yVW5tb3VudGVkQ29tcG9uZW50LmFkZChjb21wb25lbnROYW1lKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGlkV2FyblN0YXRlVXBkYXRlRm9yVW5tb3VudGVkQ29tcG9uZW50ID0gbmV3IFNldChbY29tcG9uZW50TmFtZV0pO1xuICAgIH1cblxuICAgIGlmIChpc0ZsdXNoaW5nUGFzc2l2ZUVmZmVjdHMpIDsgZWxzZSB7XG4gICAgICB2YXIgcHJldmlvdXNGaWJlciA9IGN1cnJlbnQ7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHNldEN1cnJlbnRGaWJlcihmaWJlcik7XG5cbiAgICAgICAgZXJyb3IoXCJDYW4ndCBwZXJmb3JtIGEgUmVhY3Qgc3RhdGUgdXBkYXRlIG9uIGFuIHVubW91bnRlZCBjb21wb25lbnQuIFRoaXMgXCIgKyAnaXMgYSBuby1vcCwgYnV0IGl0IGluZGljYXRlcyBhIG1lbW9yeSBsZWFrIGluIHlvdXIgYXBwbGljYXRpb24uIFRvICcgKyAnZml4LCBjYW5jZWwgYWxsIHN1YnNjcmlwdGlvbnMgYW5kIGFzeW5jaHJvbm91cyB0YXNrcyBpbiAlcy4nLCB0YWcgPT09IENsYXNzQ29tcG9uZW50ID8gJ3RoZSBjb21wb25lbnRXaWxsVW5tb3VudCBtZXRob2QnIDogJ2EgdXNlRWZmZWN0IGNsZWFudXAgZnVuY3Rpb24nKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGlmIChwcmV2aW91c0ZpYmVyKSB7XG4gICAgICAgICAgc2V0Q3VycmVudEZpYmVyKGZpYmVyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXNldEN1cnJlbnRGaWJlcigpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbnZhciBiZWdpbldvcmskMTtcblxue1xuICB2YXIgZHVtbXlGaWJlciA9IG51bGw7XG5cbiAgYmVnaW5Xb3JrJDEgPSBmdW5jdGlvbiAoY3VycmVudCwgdW5pdE9mV29yaywgbGFuZXMpIHtcbiAgICAvLyBJZiBhIGNvbXBvbmVudCB0aHJvd3MgYW4gZXJyb3IsIHdlIHJlcGxheSBpdCBhZ2FpbiBpbiBhIHN5bmNocm9ub3VzbHlcbiAgICAvLyBkaXNwYXRjaGVkIGV2ZW50LCBzbyB0aGF0IHRoZSBkZWJ1Z2dlciB3aWxsIHRyZWF0IGl0IGFzIGFuIHVuY2F1Z2h0XG4gICAgLy8gZXJyb3IgU2VlIFJlYWN0RXJyb3JVdGlscyBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cbiAgICAvLyBCZWZvcmUgZW50ZXJpbmcgdGhlIGJlZ2luIHBoYXNlLCBjb3B5IHRoZSB3b3JrLWluLXByb2dyZXNzIG9udG8gYSBkdW1teVxuICAgIC8vIGZpYmVyLiBJZiBiZWdpbldvcmsgdGhyb3dzLCB3ZSdsbCB1c2UgdGhpcyB0byByZXNldCB0aGUgc3RhdGUuXG4gICAgdmFyIG9yaWdpbmFsV29ya0luUHJvZ3Jlc3NDb3B5ID0gYXNzaWduRmliZXJQcm9wZXJ0aWVzSW5ERVYoZHVtbXlGaWJlciwgdW5pdE9mV29yayk7XG5cbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGJlZ2luV29yayhjdXJyZW50LCB1bml0T2ZXb3JrLCBsYW5lcyk7XG4gICAgfSBjYXRjaCAob3JpZ2luYWxFcnJvcikge1xuICAgICAgaWYgKG9yaWdpbmFsRXJyb3IgIT09IG51bGwgJiYgdHlwZW9mIG9yaWdpbmFsRXJyb3IgPT09ICdvYmplY3QnICYmIHR5cGVvZiBvcmlnaW5hbEVycm9yLnRoZW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgLy8gRG9uJ3QgcmVwbGF5IHByb21pc2VzLiBUcmVhdCBldmVyeXRoaW5nIGVsc2UgbGlrZSBhbiBlcnJvci5cbiAgICAgICAgdGhyb3cgb3JpZ2luYWxFcnJvcjtcbiAgICAgIH0gLy8gS2VlcCB0aGlzIGNvZGUgaW4gc3luYyB3aXRoIGhhbmRsZUVycm9yOyBhbnkgY2hhbmdlcyBoZXJlIG11c3QgaGF2ZVxuICAgICAgLy8gY29ycmVzcG9uZGluZyBjaGFuZ2VzIHRoZXJlLlxuXG5cbiAgICAgIHJlc2V0Q29udGV4dERlcGVuZGVuY2llcygpO1xuICAgICAgcmVzZXRIb29rc0FmdGVyVGhyb3coKTsgLy8gRG9uJ3QgcmVzZXQgY3VycmVudCBkZWJ1ZyBmaWJlciwgc2luY2Ugd2UncmUgYWJvdXQgdG8gd29yayBvbiB0aGVcbiAgICAgIC8vIHNhbWUgZmliZXIgYWdhaW4uXG4gICAgICAvLyBVbndpbmQgdGhlIGZhaWxlZCBzdGFjayBmcmFtZVxuXG4gICAgICB1bndpbmRJbnRlcnJ1cHRlZFdvcmsodW5pdE9mV29yayk7IC8vIFJlc3RvcmUgdGhlIG9yaWdpbmFsIHByb3BlcnRpZXMgb2YgdGhlIGZpYmVyLlxuXG4gICAgICBhc3NpZ25GaWJlclByb3BlcnRpZXNJbkRFVih1bml0T2ZXb3JrLCBvcmlnaW5hbFdvcmtJblByb2dyZXNzQ29weSk7XG5cbiAgICAgIGlmICggdW5pdE9mV29yay5tb2RlICYgUHJvZmlsZU1vZGUpIHtcbiAgICAgICAgLy8gUmVzZXQgdGhlIHByb2ZpbGVyIHRpbWVyLlxuICAgICAgICBzdGFydFByb2ZpbGVyVGltZXIodW5pdE9mV29yayk7XG4gICAgICB9IC8vIFJ1biBiZWdpbldvcmsgYWdhaW4uXG5cblxuICAgICAgaW52b2tlR3VhcmRlZENhbGxiYWNrKG51bGwsIGJlZ2luV29yaywgbnVsbCwgY3VycmVudCwgdW5pdE9mV29yaywgbGFuZXMpO1xuXG4gICAgICBpZiAoaGFzQ2F1Z2h0RXJyb3IoKSkge1xuICAgICAgICB2YXIgcmVwbGF5RXJyb3IgPSBjbGVhckNhdWdodEVycm9yKCk7IC8vIGBpbnZva2VHdWFyZGVkQ2FsbGJhY2tgIHNvbWV0aW1lcyBzZXRzIGFuIGV4cGFuZG8gYF9zdXBwcmVzc0xvZ2dpbmdgLlxuICAgICAgICAvLyBSZXRocm93IHRoaXMgZXJyb3IgaW5zdGVhZCBvZiB0aGUgb3JpZ2luYWwgb25lLlxuXG4gICAgICAgIHRocm93IHJlcGxheUVycm9yO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gVGhpcyBicmFuY2ggaXMgcmVhY2hhYmxlIGlmIHRoZSByZW5kZXIgcGhhc2UgaXMgaW1wdXJlLlxuICAgICAgICB0aHJvdyBvcmlnaW5hbEVycm9yO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbn1cblxudmFyIGRpZFdhcm5BYm91dFVwZGF0ZUluUmVuZGVyID0gZmFsc2U7XG52YXIgZGlkV2FybkFib3V0VXBkYXRlSW5SZW5kZXJGb3JBbm90aGVyQ29tcG9uZW50O1xuXG57XG4gIGRpZFdhcm5BYm91dFVwZGF0ZUluUmVuZGVyRm9yQW5vdGhlckNvbXBvbmVudCA9IG5ldyBTZXQoKTtcbn1cblxuZnVuY3Rpb24gd2FybkFib3V0UmVuZGVyUGhhc2VVcGRhdGVzSW5ERVYoZmliZXIpIHtcbiAge1xuICAgIGlmIChpc1JlbmRlcmluZyAmJiAoZXhlY3V0aW9uQ29udGV4dCAmIFJlbmRlckNvbnRleHQpICE9PSBOb0NvbnRleHQgJiYgIWdldElzVXBkYXRpbmdPcGFxdWVWYWx1ZUluUmVuZGVyUGhhc2VJbkRFVigpKSB7XG4gICAgICBzd2l0Y2ggKGZpYmVyLnRhZykge1xuICAgICAgICBjYXNlIEZ1bmN0aW9uQ29tcG9uZW50OlxuICAgICAgICBjYXNlIEZvcndhcmRSZWY6XG4gICAgICAgIGNhc2UgU2ltcGxlTWVtb0NvbXBvbmVudDpcbiAgICAgICAgICB7XG4gICAgICAgICAgICB2YXIgcmVuZGVyaW5nQ29tcG9uZW50TmFtZSA9IHdvcmtJblByb2dyZXNzICYmIGdldENvbXBvbmVudE5hbWUod29ya0luUHJvZ3Jlc3MudHlwZSkgfHwgJ1Vua25vd24nOyAvLyBEZWR1cGUgYnkgdGhlIHJlbmRlcmluZyBjb21wb25lbnQgYmVjYXVzZSBpdCdzIHRoZSBvbmUgdGhhdCBuZWVkcyB0byBiZSBmaXhlZC5cblxuICAgICAgICAgICAgdmFyIGRlZHVwZUtleSA9IHJlbmRlcmluZ0NvbXBvbmVudE5hbWU7XG5cbiAgICAgICAgICAgIGlmICghZGlkV2FybkFib3V0VXBkYXRlSW5SZW5kZXJGb3JBbm90aGVyQ29tcG9uZW50LmhhcyhkZWR1cGVLZXkpKSB7XG4gICAgICAgICAgICAgIGRpZFdhcm5BYm91dFVwZGF0ZUluUmVuZGVyRm9yQW5vdGhlckNvbXBvbmVudC5hZGQoZGVkdXBlS2V5KTtcbiAgICAgICAgICAgICAgdmFyIHNldFN0YXRlQ29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWUoZmliZXIudHlwZSkgfHwgJ1Vua25vd24nO1xuXG4gICAgICAgICAgICAgIGVycm9yKCdDYW5ub3QgdXBkYXRlIGEgY29tcG9uZW50IChgJXNgKSB3aGlsZSByZW5kZXJpbmcgYSAnICsgJ2RpZmZlcmVudCBjb21wb25lbnQgKGAlc2ApLiBUbyBsb2NhdGUgdGhlIGJhZCBzZXRTdGF0ZSgpIGNhbGwgaW5zaWRlIGAlc2AsICcgKyAnZm9sbG93IHRoZSBzdGFjayB0cmFjZSBhcyBkZXNjcmliZWQgaW4gaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3NldHN0YXRlLWluLXJlbmRlcicsIHNldFN0YXRlQ29tcG9uZW50TmFtZSwgcmVuZGVyaW5nQ29tcG9uZW50TmFtZSwgcmVuZGVyaW5nQ29tcG9uZW50TmFtZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlIENsYXNzQ29tcG9uZW50OlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlmICghZGlkV2FybkFib3V0VXBkYXRlSW5SZW5kZXIpIHtcbiAgICAgICAgICAgICAgZXJyb3IoJ0Nhbm5vdCB1cGRhdGUgZHVyaW5nIGFuIGV4aXN0aW5nIHN0YXRlIHRyYW5zaXRpb24gKHN1Y2ggYXMgJyArICd3aXRoaW4gYHJlbmRlcmApLiBSZW5kZXIgbWV0aG9kcyBzaG91bGQgYmUgYSBwdXJlICcgKyAnZnVuY3Rpb24gb2YgcHJvcHMgYW5kIHN0YXRlLicpO1xuXG4gICAgICAgICAgICAgIGRpZFdhcm5BYm91dFVwZGF0ZUluUmVuZGVyID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufSAvLyBhICdzaGFyZWQnIHZhcmlhYmxlIHRoYXQgY2hhbmdlcyB3aGVuIGFjdCgpIG9wZW5zL2Nsb3NlcyBpbiB0ZXN0cy5cblxuXG52YXIgSXNUaGlzUmVuZGVyZXJBY3RpbmcgPSB7XG4gIGN1cnJlbnQ6IGZhbHNlXG59O1xuZnVuY3Rpb24gd2FybklmTm90U2NvcGVkV2l0aE1hdGNoaW5nQWN0KGZpYmVyKSB7XG4gIHtcbiAgICBpZiAoIElzU29tZVJlbmRlcmVyQWN0aW5nLmN1cnJlbnQgPT09IHRydWUgJiYgSXNUaGlzUmVuZGVyZXJBY3RpbmcuY3VycmVudCAhPT0gdHJ1ZSkge1xuICAgICAgdmFyIHByZXZpb3VzRmliZXIgPSBjdXJyZW50O1xuXG4gICAgICB0cnkge1xuICAgICAgICBzZXRDdXJyZW50RmliZXIoZmliZXIpO1xuXG4gICAgICAgIGVycm9yKFwiSXQgbG9va3MgbGlrZSB5b3UncmUgdXNpbmcgdGhlIHdyb25nIGFjdCgpIGFyb3VuZCB5b3VyIHRlc3QgaW50ZXJhY3Rpb25zLlxcblwiICsgJ0JlIHN1cmUgdG8gdXNlIHRoZSBtYXRjaGluZyB2ZXJzaW9uIG9mIGFjdCgpIGNvcnJlc3BvbmRpbmcgdG8geW91ciByZW5kZXJlcjpcXG5cXG4nICsgJy8vIGZvciByZWFjdC1kb206XFxuJyArIC8vIEJyZWFrIHVwIGltcG9ydHMgdG8gYXZvaWQgYWNjaWRlbnRhbGx5IHBhcnNpbmcgdGhlbSBhcyBkZXBlbmRlbmNpZXMuXG4gICAgICAgICdpbXBvcnQge2FjdH0gZnInICsgXCJvbSAncmVhY3QtZG9tL3Rlc3QtdXRpbHMnO1xcblwiICsgJy8vIC4uLlxcbicgKyAnYWN0KCgpID0+IC4uLik7XFxuXFxuJyArICcvLyBmb3IgcmVhY3QtdGVzdC1yZW5kZXJlcjpcXG4nICsgLy8gQnJlYWsgdXAgaW1wb3J0cyB0byBhdm9pZCBhY2NpZGVudGFsbHkgcGFyc2luZyB0aGVtIGFzIGRlcGVuZGVuY2llcy5cbiAgICAgICAgJ2ltcG9ydCBUZXN0UmVuZGVyZXIgZnInICsgXCJvbSByZWFjdC10ZXN0LXJlbmRlcmVyJztcXG5cIiArICdjb25zdCB7YWN0fSA9IFRlc3RSZW5kZXJlcjtcXG4nICsgJy8vIC4uLlxcbicgKyAnYWN0KCgpID0+IC4uLik7Jyk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBpZiAocHJldmlvdXNGaWJlcikge1xuICAgICAgICAgIHNldEN1cnJlbnRGaWJlcihmaWJlcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzZXRDdXJyZW50RmliZXIoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gd2FybklmTm90Q3VycmVudGx5QWN0aW5nRWZmZWN0c0luREVWKGZpYmVyKSB7XG4gIHtcbiAgICBpZiAoIChmaWJlci5tb2RlICYgU3RyaWN0TW9kZSkgIT09IE5vTW9kZSAmJiBJc1NvbWVSZW5kZXJlckFjdGluZy5jdXJyZW50ID09PSBmYWxzZSAmJiBJc1RoaXNSZW5kZXJlckFjdGluZy5jdXJyZW50ID09PSBmYWxzZSkge1xuICAgICAgZXJyb3IoJ0FuIHVwZGF0ZSB0byAlcyByYW4gYW4gZWZmZWN0LCBidXQgd2FzIG5vdCB3cmFwcGVkIGluIGFjdCguLi4pLlxcblxcbicgKyAnV2hlbiB0ZXN0aW5nLCBjb2RlIHRoYXQgY2F1c2VzIFJlYWN0IHN0YXRlIHVwZGF0ZXMgc2hvdWxkIGJlICcgKyAnd3JhcHBlZCBpbnRvIGFjdCguLi4pOlxcblxcbicgKyAnYWN0KCgpID0+IHtcXG4nICsgJyAgLyogZmlyZSBldmVudHMgdGhhdCB1cGRhdGUgc3RhdGUgKi9cXG4nICsgJ30pO1xcbicgKyAnLyogYXNzZXJ0IG9uIHRoZSBvdXRwdXQgKi9cXG5cXG4nICsgXCJUaGlzIGVuc3VyZXMgdGhhdCB5b3UncmUgdGVzdGluZyB0aGUgYmVoYXZpb3IgdGhlIHVzZXIgd291bGQgc2VlIFwiICsgJ2luIHRoZSBicm93c2VyLicgKyAnIExlYXJuIG1vcmUgYXQgaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3dyYXAtdGVzdHMtd2l0aC1hY3QnLCBnZXRDb21wb25lbnROYW1lKGZpYmVyLnR5cGUpKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gd2FybklmTm90Q3VycmVudGx5QWN0aW5nVXBkYXRlc0luREVWKGZpYmVyKSB7XG4gIHtcbiAgICBpZiAoIGV4ZWN1dGlvbkNvbnRleHQgPT09IE5vQ29udGV4dCAmJiBJc1NvbWVSZW5kZXJlckFjdGluZy5jdXJyZW50ID09PSBmYWxzZSAmJiBJc1RoaXNSZW5kZXJlckFjdGluZy5jdXJyZW50ID09PSBmYWxzZSkge1xuICAgICAgdmFyIHByZXZpb3VzRmliZXIgPSBjdXJyZW50O1xuXG4gICAgICB0cnkge1xuICAgICAgICBzZXRDdXJyZW50RmliZXIoZmliZXIpO1xuXG4gICAgICAgIGVycm9yKCdBbiB1cGRhdGUgdG8gJXMgaW5zaWRlIGEgdGVzdCB3YXMgbm90IHdyYXBwZWQgaW4gYWN0KC4uLikuXFxuXFxuJyArICdXaGVuIHRlc3RpbmcsIGNvZGUgdGhhdCBjYXVzZXMgUmVhY3Qgc3RhdGUgdXBkYXRlcyBzaG91bGQgYmUgJyArICd3cmFwcGVkIGludG8gYWN0KC4uLik6XFxuXFxuJyArICdhY3QoKCkgPT4ge1xcbicgKyAnICAvKiBmaXJlIGV2ZW50cyB0aGF0IHVwZGF0ZSBzdGF0ZSAqL1xcbicgKyAnfSk7XFxuJyArICcvKiBhc3NlcnQgb24gdGhlIG91dHB1dCAqL1xcblxcbicgKyBcIlRoaXMgZW5zdXJlcyB0aGF0IHlvdSdyZSB0ZXN0aW5nIHRoZSBiZWhhdmlvciB0aGUgdXNlciB3b3VsZCBzZWUgXCIgKyAnaW4gdGhlIGJyb3dzZXIuJyArICcgTGVhcm4gbW9yZSBhdCBodHRwczovL3JlYWN0anMub3JnL2xpbmsvd3JhcC10ZXN0cy13aXRoLWFjdCcsIGdldENvbXBvbmVudE5hbWUoZmliZXIudHlwZSkpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgaWYgKHByZXZpb3VzRmliZXIpIHtcbiAgICAgICAgICBzZXRDdXJyZW50RmliZXIoZmliZXIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc2V0Q3VycmVudEZpYmVyKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxudmFyIHdhcm5JZk5vdEN1cnJlbnRseUFjdGluZ1VwZGF0ZXNJbkRldiA9IHdhcm5JZk5vdEN1cnJlbnRseUFjdGluZ1VwZGF0ZXNJbkRFVjsgLy8gSW4gdGVzdHMsIHdlIHdhbnQgdG8gZW5mb3JjZSBhIG1vY2tlZCBzY2hlZHVsZXIuXG5cbnZhciBkaWRXYXJuQWJvdXRVbm1vY2tlZFNjaGVkdWxlciA9IGZhbHNlOyAvLyBUT0RPIEJlZm9yZSB3ZSByZWxlYXNlIGNvbmN1cnJlbnQgbW9kZSwgcmV2aXNpdCB0aGlzIGFuZCBkZWNpZGUgd2hldGhlciBhIG1vY2tlZFxuLy8gc2NoZWR1bGVyIGlzIHRoZSBhY3R1YWwgcmVjb21tZW5kYXRpb24uIFRoZSBhbHRlcm5hdGl2ZSBjb3VsZCBiZSBhIHRlc3RpbmcgYnVpbGQsXG4vLyBhIG5ldyBsaWIsIG9yIHdoYXRldmVyOyB3ZSBkdW5ubyBqdXN0IHlldC4gVGhpcyBtZXNzYWdlIGlzIGZvciBlYXJseSBhZG9wdGVyc1xuLy8gdG8gZ2V0IHRoZWlyIHRlc3RzIHJpZ2h0LlxuXG5mdW5jdGlvbiB3YXJuSWZVbm1vY2tlZFNjaGVkdWxlcihmaWJlcikge1xuICB7XG4gICAgaWYgKGRpZFdhcm5BYm91dFVubW9ja2VkU2NoZWR1bGVyID09PSBmYWxzZSAmJiBTY2hlZHVsZXIudW5zdGFibGVfZmx1c2hBbGxXaXRob3V0QXNzZXJ0aW5nID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmIChmaWJlci5tb2RlICYgQmxvY2tpbmdNb2RlIHx8IGZpYmVyLm1vZGUgJiBDb25jdXJyZW50TW9kZSkge1xuICAgICAgICBkaWRXYXJuQWJvdXRVbm1vY2tlZFNjaGVkdWxlciA9IHRydWU7XG5cbiAgICAgICAgZXJyb3IoJ0luIENvbmN1cnJlbnQgb3IgU3luYyBtb2RlcywgdGhlIFwic2NoZWR1bGVyXCIgbW9kdWxlIG5lZWRzIHRvIGJlIG1vY2tlZCAnICsgJ3RvIGd1YXJhbnRlZSBjb25zaXN0ZW50IGJlaGF2aW91ciBhY3Jvc3MgdGVzdHMgYW5kIGJyb3dzZXJzLiAnICsgJ0ZvciBleGFtcGxlLCB3aXRoIGplc3Q6IFxcbicgKyAvLyBCcmVhayB1cCByZXF1aXJlcyB0byBhdm9pZCBhY2NpZGVudGFsbHkgcGFyc2luZyB0aGVtIGFzIGRlcGVuZGVuY2llcy5cbiAgICAgICAgXCJqZXN0Lm1vY2soJ3NjaGVkdWxlcicsICgpID0+IHJlcXVpcmVcIiArIFwiKCdzY2hlZHVsZXIvdW5zdGFibGVfbW9jaycpKTtcXG5cXG5cIiArICdGb3IgbW9yZSBpbmZvLCB2aXNpdCBodHRwczovL3JlYWN0anMub3JnL2xpbmsvbW9jay1zY2hlZHVsZXInKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY29tcHV0ZVRocmVhZElEKHJvb3QsIGxhbmUpIHtcbiAgLy8gSW50ZXJhY3Rpb24gdGhyZWFkcyBhcmUgdW5pcXVlIHBlciByb290IGFuZCBleHBpcmF0aW9uIHRpbWUuXG4gIC8vIE5PVEU6IEludGVudGlvbmFsbHkgdW5zb3VuZCBjYXN0LiBBbGwgdGhhdCBtYXR0ZXJzIGlzIHRoYXQgaXQncyBhIG51bWJlclxuICAvLyBhbmQgaXQgcmVwcmVzZW50cyBhIGJhdGNoIG9mIHdvcmsuIENvdWxkIG1ha2UgYSBoZWxwZXIgZnVuY3Rpb24gaW5zdGVhZCxcbiAgLy8gYnV0IG1laCB0aGlzIGlzIGZpbmUgZm9yIG5vdy5cbiAgcmV0dXJuIGxhbmUgKiAxMDAwICsgcm9vdC5pbnRlcmFjdGlvblRocmVhZElEO1xufVxuXG5mdW5jdGlvbiBtYXJrU3Bhd25lZFdvcmsobGFuZSkge1xuXG4gIGlmIChzcGF3bmVkV29ya0R1cmluZ1JlbmRlciA9PT0gbnVsbCkge1xuICAgIHNwYXduZWRXb3JrRHVyaW5nUmVuZGVyID0gW2xhbmVdO1xuICB9IGVsc2Uge1xuICAgIHNwYXduZWRXb3JrRHVyaW5nUmVuZGVyLnB1c2gobGFuZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gc2NoZWR1bGVJbnRlcmFjdGlvbnMocm9vdCwgbGFuZSwgaW50ZXJhY3Rpb25zKSB7XG5cbiAgaWYgKGludGVyYWN0aW9ucy5zaXplID4gMCkge1xuICAgIHZhciBwZW5kaW5nSW50ZXJhY3Rpb25NYXAgPSByb290LnBlbmRpbmdJbnRlcmFjdGlvbk1hcDtcbiAgICB2YXIgcGVuZGluZ0ludGVyYWN0aW9ucyA9IHBlbmRpbmdJbnRlcmFjdGlvbk1hcC5nZXQobGFuZSk7XG5cbiAgICBpZiAocGVuZGluZ0ludGVyYWN0aW9ucyAhPSBudWxsKSB7XG4gICAgICBpbnRlcmFjdGlvbnMuZm9yRWFjaChmdW5jdGlvbiAoaW50ZXJhY3Rpb24pIHtcbiAgICAgICAgaWYgKCFwZW5kaW5nSW50ZXJhY3Rpb25zLmhhcyhpbnRlcmFjdGlvbikpIHtcbiAgICAgICAgICAvLyBVcGRhdGUgdGhlIHBlbmRpbmcgYXN5bmMgd29yayBjb3VudCBmb3IgcHJldmlvdXNseSB1bnNjaGVkdWxlZCBpbnRlcmFjdGlvbi5cbiAgICAgICAgICBpbnRlcmFjdGlvbi5fX2NvdW50Kys7XG4gICAgICAgIH1cblxuICAgICAgICBwZW5kaW5nSW50ZXJhY3Rpb25zLmFkZChpbnRlcmFjdGlvbik7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcGVuZGluZ0ludGVyYWN0aW9uTWFwLnNldChsYW5lLCBuZXcgU2V0KGludGVyYWN0aW9ucykpOyAvLyBVcGRhdGUgdGhlIHBlbmRpbmcgYXN5bmMgd29yayBjb3VudCBmb3IgdGhlIGN1cnJlbnQgaW50ZXJhY3Rpb25zLlxuXG4gICAgICBpbnRlcmFjdGlvbnMuZm9yRWFjaChmdW5jdGlvbiAoaW50ZXJhY3Rpb24pIHtcbiAgICAgICAgaW50ZXJhY3Rpb24uX19jb3VudCsrO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgdmFyIHN1YnNjcmliZXIgPSB0cmFjaW5nLl9fc3Vic2NyaWJlclJlZi5jdXJyZW50O1xuXG4gICAgaWYgKHN1YnNjcmliZXIgIT09IG51bGwpIHtcbiAgICAgIHZhciB0aHJlYWRJRCA9IGNvbXB1dGVUaHJlYWRJRChyb290LCBsYW5lKTtcbiAgICAgIHN1YnNjcmliZXIub25Xb3JrU2NoZWR1bGVkKGludGVyYWN0aW9ucywgdGhyZWFkSUQpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBzY2hlZHVsZVBlbmRpbmdJbnRlcmFjdGlvbnMocm9vdCwgbGFuZSkge1xuXG4gIHNjaGVkdWxlSW50ZXJhY3Rpb25zKHJvb3QsIGxhbmUsIHRyYWNpbmcuX19pbnRlcmFjdGlvbnNSZWYuY3VycmVudCk7XG59XG5cbmZ1bmN0aW9uIHN0YXJ0V29ya09uUGVuZGluZ0ludGVyYWN0aW9ucyhyb290LCBsYW5lcykge1xuICAvLyB3ZSBjYW4gYWNjdXJhdGVseSBhdHRyaWJ1dGUgdGltZSBzcGVudCB3b3JraW5nIG9uIGl0LCBBbmQgc28gdGhhdCBjYXNjYWRpbmdcbiAgLy8gd29yayB0cmlnZ2VyZWQgZHVyaW5nIHRoZSByZW5kZXIgcGhhc2Ugd2lsbCBiZSBhc3NvY2lhdGVkIHdpdGggaXQuXG5cblxuICB2YXIgaW50ZXJhY3Rpb25zID0gbmV3IFNldCgpO1xuICByb290LnBlbmRpbmdJbnRlcmFjdGlvbk1hcC5mb3JFYWNoKGZ1bmN0aW9uIChzY2hlZHVsZWRJbnRlcmFjdGlvbnMsIHNjaGVkdWxlZExhbmUpIHtcbiAgICBpZiAoaW5jbHVkZXNTb21lTGFuZShsYW5lcywgc2NoZWR1bGVkTGFuZSkpIHtcbiAgICAgIHNjaGVkdWxlZEludGVyYWN0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChpbnRlcmFjdGlvbikge1xuICAgICAgICByZXR1cm4gaW50ZXJhY3Rpb25zLmFkZChpbnRlcmFjdGlvbik7XG4gICAgICB9KTtcbiAgICB9XG4gIH0pOyAvLyBTdG9yZSB0aGUgY3VycmVudCBzZXQgb2YgaW50ZXJhY3Rpb25zIG9uIHRoZSBGaWJlclJvb3QgZm9yIGEgZmV3IHJlYXNvbnM6XG4gIC8vIFdlIGNhbiByZS11c2UgaXQgaW4gaG90IGZ1bmN0aW9ucyBsaWtlIHBlcmZvcm1Db25jdXJyZW50V29ya09uUm9vdCgpXG4gIC8vIHdpdGhvdXQgaGF2aW5nIHRvIHJlY2FsY3VsYXRlIGl0LiBXZSB3aWxsIGFsc28gdXNlIGl0IGluIGNvbW1pdFdvcmsoKSB0b1xuICAvLyBwYXNzIHRvIGFueSBQcm9maWxlciBvblJlbmRlcigpIGhvb2tzLiBUaGlzIGFsc28gcHJvdmlkZXMgRGV2VG9vbHMgd2l0aCBhXG4gIC8vIHdheSB0byBhY2Nlc3MgaXQgd2hlbiB0aGUgb25Db21taXRSb290KCkgaG9vayBpcyBjYWxsZWQuXG5cbiAgcm9vdC5tZW1vaXplZEludGVyYWN0aW9ucyA9IGludGVyYWN0aW9ucztcblxuICBpZiAoaW50ZXJhY3Rpb25zLnNpemUgPiAwKSB7XG4gICAgdmFyIHN1YnNjcmliZXIgPSB0cmFjaW5nLl9fc3Vic2NyaWJlclJlZi5jdXJyZW50O1xuXG4gICAgaWYgKHN1YnNjcmliZXIgIT09IG51bGwpIHtcbiAgICAgIHZhciB0aHJlYWRJRCA9IGNvbXB1dGVUaHJlYWRJRChyb290LCBsYW5lcyk7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHN1YnNjcmliZXIub25Xb3JrU3RhcnRlZChpbnRlcmFjdGlvbnMsIHRocmVhZElEKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIC8vIElmIHRoZSBzdWJzY3JpYmVyIHRocm93cywgcmV0aHJvdyBpdCBpbiBhIHNlcGFyYXRlIHRhc2tcbiAgICAgICAgc2NoZWR1bGVDYWxsYmFjayhJbW1lZGlhdGVQcmlvcml0eSQxLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBmaW5pc2hQZW5kaW5nSW50ZXJhY3Rpb25zKHJvb3QsIGNvbW1pdHRlZExhbmVzKSB7XG5cbiAgdmFyIHJlbWFpbmluZ0xhbmVzQWZ0ZXJDb21taXQgPSByb290LnBlbmRpbmdMYW5lcztcbiAgdmFyIHN1YnNjcmliZXI7XG5cbiAgdHJ5IHtcbiAgICBzdWJzY3JpYmVyID0gdHJhY2luZy5fX3N1YnNjcmliZXJSZWYuY3VycmVudDtcblxuICAgIGlmIChzdWJzY3JpYmVyICE9PSBudWxsICYmIHJvb3QubWVtb2l6ZWRJbnRlcmFjdGlvbnMuc2l6ZSA+IDApIHtcbiAgICAgIC8vIEZJWE1FOiBNb3JlIHRoYW4gb25lIGxhbmUgY2FuIGZpbmlzaCBpbiBhIHNpbmdsZSBjb21taXQuXG4gICAgICB2YXIgdGhyZWFkSUQgPSBjb21wdXRlVGhyZWFkSUQocm9vdCwgY29tbWl0dGVkTGFuZXMpO1xuICAgICAgc3Vic2NyaWJlci5vbldvcmtTdG9wcGVkKHJvb3QubWVtb2l6ZWRJbnRlcmFjdGlvbnMsIHRocmVhZElEKTtcbiAgICB9XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgLy8gSWYgdGhlIHN1YnNjcmliZXIgdGhyb3dzLCByZXRocm93IGl0IGluIGEgc2VwYXJhdGUgdGFza1xuICAgIHNjaGVkdWxlQ2FsbGJhY2soSW1tZWRpYXRlUHJpb3JpdHkkMSwgZnVuY3Rpb24gKCkge1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfSk7XG4gIH0gZmluYWxseSB7XG4gICAgLy8gQ2xlYXIgY29tcGxldGVkIGludGVyYWN0aW9ucyBmcm9tIHRoZSBwZW5kaW5nIE1hcC5cbiAgICAvLyBVbmxlc3MgdGhlIHJlbmRlciB3YXMgc3VzcGVuZGVkIG9yIGNhc2NhZGluZyB3b3JrIHdhcyBzY2hlZHVsZWQsXG4gICAgLy8gSW4gd2hpY2ggY2FzZeKAkyBsZWF2ZSBwZW5kaW5nIGludGVyYWN0aW9ucyB1bnRpbCB0aGUgc3Vic2VxdWVudCByZW5kZXIuXG4gICAgdmFyIHBlbmRpbmdJbnRlcmFjdGlvbk1hcCA9IHJvb3QucGVuZGluZ0ludGVyYWN0aW9uTWFwO1xuICAgIHBlbmRpbmdJbnRlcmFjdGlvbk1hcC5mb3JFYWNoKGZ1bmN0aW9uIChzY2hlZHVsZWRJbnRlcmFjdGlvbnMsIGxhbmUpIHtcbiAgICAgIC8vIE9ubHkgZGVjcmVtZW50IHRoZSBwZW5kaW5nIGludGVyYWN0aW9uIGNvdW50IGlmIHdlJ3JlIGRvbmUuXG4gICAgICAvLyBJZiB0aGVyZSdzIHN0aWxsIHdvcmsgYXQgdGhlIGN1cnJlbnQgcHJpb3JpdHksXG4gICAgICAvLyBUaGF0IGluZGljYXRlcyB0aGF0IHdlIGFyZSB3YWl0aW5nIGZvciBzdXNwZW5zZSBkYXRhLlxuICAgICAgaWYgKCFpbmNsdWRlc1NvbWVMYW5lKHJlbWFpbmluZ0xhbmVzQWZ0ZXJDb21taXQsIGxhbmUpKSB7XG4gICAgICAgIHBlbmRpbmdJbnRlcmFjdGlvbk1hcC5kZWxldGUobGFuZSk7XG4gICAgICAgIHNjaGVkdWxlZEludGVyYWN0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChpbnRlcmFjdGlvbikge1xuICAgICAgICAgIGludGVyYWN0aW9uLl9fY291bnQtLTtcblxuICAgICAgICAgIGlmIChzdWJzY3JpYmVyICE9PSBudWxsICYmIGludGVyYWN0aW9uLl9fY291bnQgPT09IDApIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHN1YnNjcmliZXIub25JbnRlcmFjdGlvblNjaGVkdWxlZFdvcmtDb21wbGV0ZWQoaW50ZXJhY3Rpb24pO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgLy8gSWYgdGhlIHN1YnNjcmliZXIgdGhyb3dzLCByZXRocm93IGl0IGluIGEgc2VwYXJhdGUgdGFza1xuICAgICAgICAgICAgICBzY2hlZHVsZUNhbGxiYWNrKEltbWVkaWF0ZVByaW9yaXR5JDEsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufSAvLyBgYWN0YCB0ZXN0aW5nIEFQSVxuXG5mdW5jdGlvbiBzaG91bGRGb3JjZUZsdXNoRmFsbGJhY2tzSW5ERVYoKSB7XG4gIC8vIE5ldmVyIGZvcmNlIGZsdXNoIGluIHByb2R1Y3Rpb24uIFRoaXMgZnVuY3Rpb24gc2hvdWxkIGdldCBzdHJpcHBlZCBvdXQuXG4gIHJldHVybiAgYWN0aW5nVXBkYXRlc1Njb3BlRGVwdGggPiAwO1xufVxuLy8gc28gd2UgY2FuIHRlbGwgaWYgYW55IGFzeW5jIGFjdCgpIGNhbGxzIHRyeSB0byBydW4gaW4gcGFyYWxsZWwuXG5cblxudmFyIGFjdGluZ1VwZGF0ZXNTY29wZURlcHRoID0gMDtcblxuZnVuY3Rpb24gZGV0YWNoRmliZXJBZnRlckVmZmVjdHMoZmliZXIpIHtcbiAgZmliZXIuc2libGluZyA9IG51bGw7XG4gIGZpYmVyLnN0YXRlTm9kZSA9IG51bGw7XG59XG5cbnZhciByZXNvbHZlRmFtaWx5ID0gbnVsbDsgLy8gJEZsb3dGaXhNZSBGbG93IGdldHMgY29uZnVzZWQgYnkgYSBXZWFrU2V0IGZlYXR1cmUgY2hlY2sgYmVsb3cuXG5cbnZhciBmYWlsZWRCb3VuZGFyaWVzID0gbnVsbDtcbnZhciBzZXRSZWZyZXNoSGFuZGxlciA9IGZ1bmN0aW9uIChoYW5kbGVyKSB7XG4gIHtcbiAgICByZXNvbHZlRmFtaWx5ID0gaGFuZGxlcjtcbiAgfVxufTtcbmZ1bmN0aW9uIHJlc29sdmVGdW5jdGlvbkZvckhvdFJlbG9hZGluZyh0eXBlKSB7XG4gIHtcbiAgICBpZiAocmVzb2x2ZUZhbWlseSA9PT0gbnVsbCkge1xuICAgICAgLy8gSG90IHJlbG9hZGluZyBpcyBkaXNhYmxlZC5cbiAgICAgIHJldHVybiB0eXBlO1xuICAgIH1cblxuICAgIHZhciBmYW1pbHkgPSByZXNvbHZlRmFtaWx5KHR5cGUpO1xuXG4gICAgaWYgKGZhbWlseSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gdHlwZTtcbiAgICB9IC8vIFVzZSB0aGUgbGF0ZXN0IGtub3duIGltcGxlbWVudGF0aW9uLlxuXG5cbiAgICByZXR1cm4gZmFtaWx5LmN1cnJlbnQ7XG4gIH1cbn1cbmZ1bmN0aW9uIHJlc29sdmVDbGFzc0ZvckhvdFJlbG9hZGluZyh0eXBlKSB7XG4gIC8vIE5vIGltcGxlbWVudGF0aW9uIGRpZmZlcmVuY2VzLlxuICByZXR1cm4gcmVzb2x2ZUZ1bmN0aW9uRm9ySG90UmVsb2FkaW5nKHR5cGUpO1xufVxuZnVuY3Rpb24gcmVzb2x2ZUZvcndhcmRSZWZGb3JIb3RSZWxvYWRpbmcodHlwZSkge1xuICB7XG4gICAgaWYgKHJlc29sdmVGYW1pbHkgPT09IG51bGwpIHtcbiAgICAgIC8vIEhvdCByZWxvYWRpbmcgaXMgZGlzYWJsZWQuXG4gICAgICByZXR1cm4gdHlwZTtcbiAgICB9XG5cbiAgICB2YXIgZmFtaWx5ID0gcmVzb2x2ZUZhbWlseSh0eXBlKTtcblxuICAgIGlmIChmYW1pbHkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gQ2hlY2sgaWYgd2UncmUgZGVhbGluZyB3aXRoIGEgcmVhbCBmb3J3YXJkUmVmLiBEb24ndCB3YW50IHRvIGNyYXNoIGVhcmx5LlxuICAgICAgaWYgKHR5cGUgIT09IG51bGwgJiYgdHlwZSAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiB0eXBlLnJlbmRlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAvLyBGb3J3YXJkUmVmIGlzIHNwZWNpYWwgYmVjYXVzZSBpdHMgcmVzb2x2ZWQgLnR5cGUgaXMgYW4gb2JqZWN0LFxuICAgICAgICAvLyBidXQgaXQncyBwb3NzaWJsZSB0aGF0IHdlIG9ubHkgaGF2ZSBpdHMgaW5uZXIgcmVuZGVyIGZ1bmN0aW9uIGluIHRoZSBtYXAuXG4gICAgICAgIC8vIElmIHRoYXQgaW5uZXIgcmVuZGVyIGZ1bmN0aW9uIGlzIGRpZmZlcmVudCwgd2UnbGwgYnVpbGQgYSBuZXcgZm9yd2FyZFJlZiB0eXBlLlxuICAgICAgICB2YXIgY3VycmVudFJlbmRlciA9IHJlc29sdmVGdW5jdGlvbkZvckhvdFJlbG9hZGluZyh0eXBlLnJlbmRlcik7XG5cbiAgICAgICAgaWYgKHR5cGUucmVuZGVyICE9PSBjdXJyZW50UmVuZGVyKSB7XG4gICAgICAgICAgdmFyIHN5bnRoZXRpY1R5cGUgPSB7XG4gICAgICAgICAgICAkJHR5cGVvZjogUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSxcbiAgICAgICAgICAgIHJlbmRlcjogY3VycmVudFJlbmRlclxuICAgICAgICAgIH07XG5cbiAgICAgICAgICBpZiAodHlwZS5kaXNwbGF5TmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBzeW50aGV0aWNUeXBlLmRpc3BsYXlOYW1lID0gdHlwZS5kaXNwbGF5TmFtZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gc3ludGhldGljVHlwZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdHlwZTtcbiAgICB9IC8vIFVzZSB0aGUgbGF0ZXN0IGtub3duIGltcGxlbWVudGF0aW9uLlxuXG5cbiAgICByZXR1cm4gZmFtaWx5LmN1cnJlbnQ7XG4gIH1cbn1cbmZ1bmN0aW9uIGlzQ29tcGF0aWJsZUZhbWlseUZvckhvdFJlbG9hZGluZyhmaWJlciwgZWxlbWVudCkge1xuICB7XG4gICAgaWYgKHJlc29sdmVGYW1pbHkgPT09IG51bGwpIHtcbiAgICAgIC8vIEhvdCByZWxvYWRpbmcgaXMgZGlzYWJsZWQuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIHByZXZUeXBlID0gZmliZXIuZWxlbWVudFR5cGU7XG4gICAgdmFyIG5leHRUeXBlID0gZWxlbWVudC50eXBlOyAvLyBJZiB3ZSBnb3QgaGVyZSwgd2Uga25vdyB0eXBlcyBhcmVuJ3QgPT09IGVxdWFsLlxuXG4gICAgdmFyIG5lZWRzQ29tcGFyZUZhbWlsaWVzID0gZmFsc2U7XG4gICAgdmFyICQkdHlwZW9mTmV4dFR5cGUgPSB0eXBlb2YgbmV4dFR5cGUgPT09ICdvYmplY3QnICYmIG5leHRUeXBlICE9PSBudWxsID8gbmV4dFR5cGUuJCR0eXBlb2YgOiBudWxsO1xuXG4gICAgc3dpdGNoIChmaWJlci50YWcpIHtcbiAgICAgIGNhc2UgQ2xhc3NDb21wb25lbnQ6XG4gICAgICAgIHtcbiAgICAgICAgICBpZiAodHlwZW9mIG5leHRUeXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBuZWVkc0NvbXBhcmVGYW1pbGllcyA9IHRydWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBGdW5jdGlvbkNvbXBvbmVudDpcbiAgICAgICAge1xuICAgICAgICAgIGlmICh0eXBlb2YgbmV4dFR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIG5lZWRzQ29tcGFyZUZhbWlsaWVzID0gdHJ1ZTtcbiAgICAgICAgICB9IGVsc2UgaWYgKCQkdHlwZW9mTmV4dFR5cGUgPT09IFJFQUNUX0xBWllfVFlQRSkge1xuICAgICAgICAgICAgLy8gV2UgZG9uJ3Qga25vdyB0aGUgaW5uZXIgdHlwZSB5ZXQuXG4gICAgICAgICAgICAvLyBXZSdyZSBnb2luZyB0byBhc3N1bWUgdGhhdCB0aGUgbGF6eSBpbm5lciB0eXBlIGlzIHN0YWJsZSxcbiAgICAgICAgICAgIC8vIGFuZCBzbyBpdCBpcyBzdWZmaWNpZW50IHRvIGF2b2lkIHJlY29uY2lsaW5nIGl0IGF3YXkuXG4gICAgICAgICAgICAvLyBXZSdyZSBub3QgZ29pbmcgdG8gdW53cmFwIG9yIGFjdHVhbGx5IHVzZSB0aGUgbmV3IGxhenkgdHlwZS5cbiAgICAgICAgICAgIG5lZWRzQ29tcGFyZUZhbWlsaWVzID0gdHJ1ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIEZvcndhcmRSZWY6XG4gICAgICAgIHtcbiAgICAgICAgICBpZiAoJCR0eXBlb2ZOZXh0VHlwZSA9PT0gUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSkge1xuICAgICAgICAgICAgbmVlZHNDb21wYXJlRmFtaWxpZXMgPSB0cnVlO1xuICAgICAgICAgIH0gZWxzZSBpZiAoJCR0eXBlb2ZOZXh0VHlwZSA9PT0gUkVBQ1RfTEFaWV9UWVBFKSB7XG4gICAgICAgICAgICBuZWVkc0NvbXBhcmVGYW1pbGllcyA9IHRydWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBNZW1vQ29tcG9uZW50OlxuICAgICAgY2FzZSBTaW1wbGVNZW1vQ29tcG9uZW50OlxuICAgICAgICB7XG4gICAgICAgICAgaWYgKCQkdHlwZW9mTmV4dFR5cGUgPT09IFJFQUNUX01FTU9fVFlQRSkge1xuICAgICAgICAgICAgLy8gVE9ETzogaWYgaXQgd2FzIGJ1dCBjYW4gbm8gbG9uZ2VyIGJlIHNpbXBsZSxcbiAgICAgICAgICAgIC8vIHdlIHNob3VsZG4ndCBzZXQgdGhpcy5cbiAgICAgICAgICAgIG5lZWRzQ29tcGFyZUZhbWlsaWVzID0gdHJ1ZTtcbiAgICAgICAgICB9IGVsc2UgaWYgKCQkdHlwZW9mTmV4dFR5cGUgPT09IFJFQUNUX0xBWllfVFlQRSkge1xuICAgICAgICAgICAgbmVlZHNDb21wYXJlRmFtaWxpZXMgPSB0cnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IC8vIENoZWNrIGlmIGJvdGggdHlwZXMgaGF2ZSBhIGZhbWlseSBhbmQgaXQncyB0aGUgc2FtZSBvbmUuXG5cblxuICAgIGlmIChuZWVkc0NvbXBhcmVGYW1pbGllcykge1xuICAgICAgLy8gTm90ZTogbWVtbygpIGFuZCBmb3J3YXJkUmVmKCkgd2UnbGwgY29tcGFyZSBvdXRlciByYXRoZXIgdGhhbiBpbm5lciB0eXBlLlxuICAgICAgLy8gVGhpcyBtZWFucyBib3RoIG9mIHRoZW0gbmVlZCB0byBiZSByZWdpc3RlcmVkIHRvIHByZXNlcnZlIHN0YXRlLlxuICAgICAgLy8gSWYgd2UgdW53cmFwcGVkIGFuZCBjb21wYXJlZCB0aGUgaW5uZXIgdHlwZXMgZm9yIHdyYXBwZXJzIGluc3RlYWQsXG4gICAgICAvLyB0aGVuIHdlIHdvdWxkIHJpc2sgZmFsc2VseSBzYXlpbmcgdHdvIHNlcGFyYXRlIG1lbW8oRm9vKVxuICAgICAgLy8gY2FsbHMgYXJlIGVxdWl2YWxlbnQgYmVjYXVzZSB0aGV5IHdyYXAgdGhlIHNhbWUgRm9vIGZ1bmN0aW9uLlxuICAgICAgdmFyIHByZXZGYW1pbHkgPSByZXNvbHZlRmFtaWx5KHByZXZUeXBlKTtcblxuICAgICAgaWYgKHByZXZGYW1pbHkgIT09IHVuZGVmaW5lZCAmJiBwcmV2RmFtaWx5ID09PSByZXNvbHZlRmFtaWx5KG5leHRUeXBlKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cbmZ1bmN0aW9uIG1hcmtGYWlsZWRFcnJvckJvdW5kYXJ5Rm9ySG90UmVsb2FkaW5nKGZpYmVyKSB7XG4gIHtcbiAgICBpZiAocmVzb2x2ZUZhbWlseSA9PT0gbnVsbCkge1xuICAgICAgLy8gSG90IHJlbG9hZGluZyBpcyBkaXNhYmxlZC5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIFdlYWtTZXQgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoZmFpbGVkQm91bmRhcmllcyA9PT0gbnVsbCkge1xuICAgICAgZmFpbGVkQm91bmRhcmllcyA9IG5ldyBXZWFrU2V0KCk7XG4gICAgfVxuXG4gICAgZmFpbGVkQm91bmRhcmllcy5hZGQoZmliZXIpO1xuICB9XG59XG52YXIgc2NoZWR1bGVSZWZyZXNoID0gZnVuY3Rpb24gKHJvb3QsIHVwZGF0ZSkge1xuICB7XG4gICAgaWYgKHJlc29sdmVGYW1pbHkgPT09IG51bGwpIHtcbiAgICAgIC8vIEhvdCByZWxvYWRpbmcgaXMgZGlzYWJsZWQuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHN0YWxlRmFtaWxpZXMgPSB1cGRhdGUuc3RhbGVGYW1pbGllcyxcbiAgICAgICAgdXBkYXRlZEZhbWlsaWVzID0gdXBkYXRlLnVwZGF0ZWRGYW1pbGllcztcbiAgICBmbHVzaFBhc3NpdmVFZmZlY3RzKCk7XG4gICAgZmx1c2hTeW5jKGZ1bmN0aW9uICgpIHtcbiAgICAgIHNjaGVkdWxlRmliZXJzV2l0aEZhbWlsaWVzUmVjdXJzaXZlbHkocm9vdC5jdXJyZW50LCB1cGRhdGVkRmFtaWxpZXMsIHN0YWxlRmFtaWxpZXMpO1xuICAgIH0pO1xuICB9XG59O1xudmFyIHNjaGVkdWxlUm9vdCA9IGZ1bmN0aW9uIChyb290LCBlbGVtZW50KSB7XG4gIHtcbiAgICBpZiAocm9vdC5jb250ZXh0ICE9PSBlbXB0eUNvbnRleHRPYmplY3QpIHtcbiAgICAgIC8vIFN1cGVyIGVkZ2UgY2FzZTogcm9vdCBoYXMgYSBsZWdhY3kgX3JlbmRlclN1YnRyZWUgY29udGV4dFxuICAgICAgLy8gYnV0IHdlIGRvbid0IGtub3cgdGhlIHBhcmVudENvbXBvbmVudCBzbyB3ZSBjYW4ndCBwYXNzIGl0LlxuICAgICAgLy8gSnVzdCBpZ25vcmUuIFdlJ2xsIGRlbGV0ZSB0aGlzIHdpdGggX3JlbmRlclN1YnRyZWUgY29kZSBwYXRoIGxhdGVyLlxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGZsdXNoUGFzc2l2ZUVmZmVjdHMoKTtcbiAgICBmbHVzaFN5bmMoZnVuY3Rpb24gKCkge1xuICAgICAgdXBkYXRlQ29udGFpbmVyKGVsZW1lbnQsIHJvb3QsIG51bGwsIG51bGwpO1xuICAgIH0pO1xuICB9XG59O1xuXG5mdW5jdGlvbiBzY2hlZHVsZUZpYmVyc1dpdGhGYW1pbGllc1JlY3Vyc2l2ZWx5KGZpYmVyLCB1cGRhdGVkRmFtaWxpZXMsIHN0YWxlRmFtaWxpZXMpIHtcbiAge1xuICAgIHZhciBhbHRlcm5hdGUgPSBmaWJlci5hbHRlcm5hdGUsXG4gICAgICAgIGNoaWxkID0gZmliZXIuY2hpbGQsXG4gICAgICAgIHNpYmxpbmcgPSBmaWJlci5zaWJsaW5nLFxuICAgICAgICB0YWcgPSBmaWJlci50YWcsXG4gICAgICAgIHR5cGUgPSBmaWJlci50eXBlO1xuICAgIHZhciBjYW5kaWRhdGVUeXBlID0gbnVsbDtcblxuICAgIHN3aXRjaCAodGFnKSB7XG4gICAgICBjYXNlIEZ1bmN0aW9uQ29tcG9uZW50OlxuICAgICAgY2FzZSBTaW1wbGVNZW1vQ29tcG9uZW50OlxuICAgICAgY2FzZSBDbGFzc0NvbXBvbmVudDpcbiAgICAgICAgY2FuZGlkYXRlVHlwZSA9IHR5cGU7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIEZvcndhcmRSZWY6XG4gICAgICAgIGNhbmRpZGF0ZVR5cGUgPSB0eXBlLnJlbmRlcjtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgaWYgKHJlc29sdmVGYW1pbHkgPT09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgcmVzb2x2ZUZhbWlseSB0byBiZSBzZXQgZHVyaW5nIGhvdCByZWxvYWQuJyk7XG4gICAgfVxuXG4gICAgdmFyIG5lZWRzUmVuZGVyID0gZmFsc2U7XG4gICAgdmFyIG5lZWRzUmVtb3VudCA9IGZhbHNlO1xuXG4gICAgaWYgKGNhbmRpZGF0ZVR5cGUgIT09IG51bGwpIHtcbiAgICAgIHZhciBmYW1pbHkgPSByZXNvbHZlRmFtaWx5KGNhbmRpZGF0ZVR5cGUpO1xuXG4gICAgICBpZiAoZmFtaWx5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKHN0YWxlRmFtaWxpZXMuaGFzKGZhbWlseSkpIHtcbiAgICAgICAgICBuZWVkc1JlbW91bnQgPSB0cnVlO1xuICAgICAgICB9IGVsc2UgaWYgKHVwZGF0ZWRGYW1pbGllcy5oYXMoZmFtaWx5KSkge1xuICAgICAgICAgIGlmICh0YWcgPT09IENsYXNzQ29tcG9uZW50KSB7XG4gICAgICAgICAgICBuZWVkc1JlbW91bnQgPSB0cnVlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBuZWVkc1JlbmRlciA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGZhaWxlZEJvdW5kYXJpZXMgIT09IG51bGwpIHtcbiAgICAgIGlmIChmYWlsZWRCb3VuZGFyaWVzLmhhcyhmaWJlcikgfHwgYWx0ZXJuYXRlICE9PSBudWxsICYmIGZhaWxlZEJvdW5kYXJpZXMuaGFzKGFsdGVybmF0ZSkpIHtcbiAgICAgICAgbmVlZHNSZW1vdW50ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAobmVlZHNSZW1vdW50KSB7XG4gICAgICBmaWJlci5fZGVidWdOZWVkc1JlbW91bnQgPSB0cnVlO1xuICAgIH1cblxuICAgIGlmIChuZWVkc1JlbW91bnQgfHwgbmVlZHNSZW5kZXIpIHtcbiAgICAgIHNjaGVkdWxlVXBkYXRlT25GaWJlcihmaWJlciwgU3luY0xhbmUsIE5vVGltZXN0YW1wKTtcbiAgICB9XG5cbiAgICBpZiAoY2hpbGQgIT09IG51bGwgJiYgIW5lZWRzUmVtb3VudCkge1xuICAgICAgc2NoZWR1bGVGaWJlcnNXaXRoRmFtaWxpZXNSZWN1cnNpdmVseShjaGlsZCwgdXBkYXRlZEZhbWlsaWVzLCBzdGFsZUZhbWlsaWVzKTtcbiAgICB9XG5cbiAgICBpZiAoc2libGluZyAhPT0gbnVsbCkge1xuICAgICAgc2NoZWR1bGVGaWJlcnNXaXRoRmFtaWxpZXNSZWN1cnNpdmVseShzaWJsaW5nLCB1cGRhdGVkRmFtaWxpZXMsIHN0YWxlRmFtaWxpZXMpO1xuICAgIH1cbiAgfVxufVxuXG52YXIgZmluZEhvc3RJbnN0YW5jZXNGb3JSZWZyZXNoID0gZnVuY3Rpb24gKHJvb3QsIGZhbWlsaWVzKSB7XG4gIHtcbiAgICB2YXIgaG9zdEluc3RhbmNlcyA9IG5ldyBTZXQoKTtcbiAgICB2YXIgdHlwZXMgPSBuZXcgU2V0KGZhbWlsaWVzLm1hcChmdW5jdGlvbiAoZmFtaWx5KSB7XG4gICAgICByZXR1cm4gZmFtaWx5LmN1cnJlbnQ7XG4gICAgfSkpO1xuICAgIGZpbmRIb3N0SW5zdGFuY2VzRm9yTWF0Y2hpbmdGaWJlcnNSZWN1cnNpdmVseShyb290LmN1cnJlbnQsIHR5cGVzLCBob3N0SW5zdGFuY2VzKTtcbiAgICByZXR1cm4gaG9zdEluc3RhbmNlcztcbiAgfVxufTtcblxuZnVuY3Rpb24gZmluZEhvc3RJbnN0YW5jZXNGb3JNYXRjaGluZ0ZpYmVyc1JlY3Vyc2l2ZWx5KGZpYmVyLCB0eXBlcywgaG9zdEluc3RhbmNlcykge1xuICB7XG4gICAgdmFyIGNoaWxkID0gZmliZXIuY2hpbGQsXG4gICAgICAgIHNpYmxpbmcgPSBmaWJlci5zaWJsaW5nLFxuICAgICAgICB0YWcgPSBmaWJlci50YWcsXG4gICAgICAgIHR5cGUgPSBmaWJlci50eXBlO1xuICAgIHZhciBjYW5kaWRhdGVUeXBlID0gbnVsbDtcblxuICAgIHN3aXRjaCAodGFnKSB7XG4gICAgICBjYXNlIEZ1bmN0aW9uQ29tcG9uZW50OlxuICAgICAgY2FzZSBTaW1wbGVNZW1vQ29tcG9uZW50OlxuICAgICAgY2FzZSBDbGFzc0NvbXBvbmVudDpcbiAgICAgICAgY2FuZGlkYXRlVHlwZSA9IHR5cGU7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIEZvcndhcmRSZWY6XG4gICAgICAgIGNhbmRpZGF0ZVR5cGUgPSB0eXBlLnJlbmRlcjtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgdmFyIGRpZE1hdGNoID0gZmFsc2U7XG5cbiAgICBpZiAoY2FuZGlkYXRlVHlwZSAhPT0gbnVsbCkge1xuICAgICAgaWYgKHR5cGVzLmhhcyhjYW5kaWRhdGVUeXBlKSkge1xuICAgICAgICBkaWRNYXRjaCA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGRpZE1hdGNoKSB7XG4gICAgICAvLyBXZSBoYXZlIGEgbWF0Y2guIFRoaXMgb25seSBkcmlsbHMgZG93biB0byB0aGUgY2xvc2VzdCBob3N0IGNvbXBvbmVudHMuXG4gICAgICAvLyBUaGVyZSdzIG5vIG5lZWQgdG8gc2VhcmNoIGRlZXBlciBiZWNhdXNlIGZvciB0aGUgcHVycG9zZSBvZiBnaXZpbmdcbiAgICAgIC8vIHZpc3VhbCBmZWVkYmFjaywgXCJmbGFzaGluZ1wiIG91dGVybW9zdCBwYXJlbnQgcmVjdGFuZ2xlcyBpcyBzdWZmaWNpZW50LlxuICAgICAgZmluZEhvc3RJbnN0YW5jZXNGb3JGaWJlclNoYWxsb3dseShmaWJlciwgaG9zdEluc3RhbmNlcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIElmIHRoZXJlJ3Mgbm8gbWF0Y2gsIG1heWJlIHRoZXJlIHdpbGwgYmUgb25lIGZ1cnRoZXIgZG93biBpbiB0aGUgY2hpbGQgdHJlZS5cbiAgICAgIGlmIChjaGlsZCAhPT0gbnVsbCkge1xuICAgICAgICBmaW5kSG9zdEluc3RhbmNlc0Zvck1hdGNoaW5nRmliZXJzUmVjdXJzaXZlbHkoY2hpbGQsIHR5cGVzLCBob3N0SW5zdGFuY2VzKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoc2libGluZyAhPT0gbnVsbCkge1xuICAgICAgZmluZEhvc3RJbnN0YW5jZXNGb3JNYXRjaGluZ0ZpYmVyc1JlY3Vyc2l2ZWx5KHNpYmxpbmcsIHR5cGVzLCBob3N0SW5zdGFuY2VzKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZmluZEhvc3RJbnN0YW5jZXNGb3JGaWJlclNoYWxsb3dseShmaWJlciwgaG9zdEluc3RhbmNlcykge1xuICB7XG4gICAgdmFyIGZvdW5kSG9zdEluc3RhbmNlcyA9IGZpbmRDaGlsZEhvc3RJbnN0YW5jZXNGb3JGaWJlclNoYWxsb3dseShmaWJlciwgaG9zdEluc3RhbmNlcyk7XG5cbiAgICBpZiAoZm91bmRIb3N0SW5zdGFuY2VzKSB7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyBJZiB3ZSBkaWRuJ3QgZmluZCBhbnkgaG9zdCBjaGlsZHJlbiwgZmFsbGJhY2sgdG8gY2xvc2VzdCBob3N0IHBhcmVudC5cblxuXG4gICAgdmFyIG5vZGUgPSBmaWJlcjtcblxuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICBzd2l0Y2ggKG5vZGUudGFnKSB7XG4gICAgICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICAgICAgICBob3N0SW5zdGFuY2VzLmFkZChub2RlLnN0YXRlTm9kZSk7XG4gICAgICAgICAgcmV0dXJuO1xuXG4gICAgICAgIGNhc2UgSG9zdFBvcnRhbDpcbiAgICAgICAgICBob3N0SW5zdGFuY2VzLmFkZChub2RlLnN0YXRlTm9kZS5jb250YWluZXJJbmZvKTtcbiAgICAgICAgICByZXR1cm47XG5cbiAgICAgICAgY2FzZSBIb3N0Um9vdDpcbiAgICAgICAgICBob3N0SW5zdGFuY2VzLmFkZChub2RlLnN0YXRlTm9kZS5jb250YWluZXJJbmZvKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChub2RlLnJldHVybiA9PT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIHRvIHJlYWNoIHJvb3QgZmlyc3QuJyk7XG4gICAgICB9XG5cbiAgICAgIG5vZGUgPSBub2RlLnJldHVybjtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZmluZENoaWxkSG9zdEluc3RhbmNlc0ZvckZpYmVyU2hhbGxvd2x5KGZpYmVyLCBob3N0SW5zdGFuY2VzKSB7XG4gIHtcbiAgICB2YXIgbm9kZSA9IGZpYmVyO1xuICAgIHZhciBmb3VuZEhvc3RJbnN0YW5jZXMgPSBmYWxzZTtcblxuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICBpZiAobm9kZS50YWcgPT09IEhvc3RDb21wb25lbnQpIHtcbiAgICAgICAgLy8gV2UgZ290IGEgbWF0Y2guXG4gICAgICAgIGZvdW5kSG9zdEluc3RhbmNlcyA9IHRydWU7XG4gICAgICAgIGhvc3RJbnN0YW5jZXMuYWRkKG5vZGUuc3RhdGVOb2RlKTsgLy8gVGhlcmUgbWF5IHN0aWxsIGJlIG1vcmUsIHNvIGtlZXAgc2VhcmNoaW5nLlxuICAgICAgfSBlbHNlIGlmIChub2RlLmNoaWxkICE9PSBudWxsKSB7XG4gICAgICAgIG5vZGUuY2hpbGQucmV0dXJuID0gbm9kZTtcbiAgICAgICAgbm9kZSA9IG5vZGUuY2hpbGQ7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAobm9kZSA9PT0gZmliZXIpIHtcbiAgICAgICAgcmV0dXJuIGZvdW5kSG9zdEluc3RhbmNlcztcbiAgICAgIH1cblxuICAgICAgd2hpbGUgKG5vZGUuc2libGluZyA9PT0gbnVsbCkge1xuICAgICAgICBpZiAobm9kZS5yZXR1cm4gPT09IG51bGwgfHwgbm9kZS5yZXR1cm4gPT09IGZpYmVyKSB7XG4gICAgICAgICAgcmV0dXJuIGZvdW5kSG9zdEluc3RhbmNlcztcbiAgICAgICAgfVxuXG4gICAgICAgIG5vZGUgPSBub2RlLnJldHVybjtcbiAgICAgIH1cblxuICAgICAgbm9kZS5zaWJsaW5nLnJldHVybiA9IG5vZGUucmV0dXJuO1xuICAgICAgbm9kZSA9IG5vZGUuc2libGluZztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbnZhciBoYXNCYWRNYXBQb2x5ZmlsbDtcblxue1xuICBoYXNCYWRNYXBQb2x5ZmlsbCA9IGZhbHNlO1xuXG4gIHRyeSB7XG4gICAgdmFyIG5vbkV4dGVuc2libGVPYmplY3QgPSBPYmplY3QucHJldmVudEV4dGVuc2lvbnMoe30pO1xuICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLW5ldyAqL1xuXG4gICAgbmV3IE1hcChbW25vbkV4dGVuc2libGVPYmplY3QsIG51bGxdXSk7XG4gICAgbmV3IFNldChbbm9uRXh0ZW5zaWJsZU9iamVjdF0pO1xuICAgIC8qIGVzbGludC1lbmFibGUgbm8tbmV3ICovXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICAvLyBUT0RPOiBDb25zaWRlciB3YXJuaW5nIGFib3V0IGJhZCBwb2x5ZmlsbHNcbiAgICBoYXNCYWRNYXBQb2x5ZmlsbCA9IHRydWU7XG4gIH1cbn1cblxudmFyIGRlYnVnQ291bnRlciA9IDE7XG5cbmZ1bmN0aW9uIEZpYmVyTm9kZSh0YWcsIHBlbmRpbmdQcm9wcywga2V5LCBtb2RlKSB7XG4gIC8vIEluc3RhbmNlXG4gIHRoaXMudGFnID0gdGFnO1xuICB0aGlzLmtleSA9IGtleTtcbiAgdGhpcy5lbGVtZW50VHlwZSA9IG51bGw7XG4gIHRoaXMudHlwZSA9IG51bGw7XG4gIHRoaXMuc3RhdGVOb2RlID0gbnVsbDsgLy8gRmliZXJcblxuICB0aGlzLnJldHVybiA9IG51bGw7XG4gIHRoaXMuY2hpbGQgPSBudWxsO1xuICB0aGlzLnNpYmxpbmcgPSBudWxsO1xuICB0aGlzLmluZGV4ID0gMDtcbiAgdGhpcy5yZWYgPSBudWxsO1xuICB0aGlzLnBlbmRpbmdQcm9wcyA9IHBlbmRpbmdQcm9wcztcbiAgdGhpcy5tZW1vaXplZFByb3BzID0gbnVsbDtcbiAgdGhpcy51cGRhdGVRdWV1ZSA9IG51bGw7XG4gIHRoaXMubWVtb2l6ZWRTdGF0ZSA9IG51bGw7XG4gIHRoaXMuZGVwZW5kZW5jaWVzID0gbnVsbDtcbiAgdGhpcy5tb2RlID0gbW9kZTsgLy8gRWZmZWN0c1xuXG4gIHRoaXMuZmxhZ3MgPSBOb0ZsYWdzO1xuICB0aGlzLm5leHRFZmZlY3QgPSBudWxsO1xuICB0aGlzLmZpcnN0RWZmZWN0ID0gbnVsbDtcbiAgdGhpcy5sYXN0RWZmZWN0ID0gbnVsbDtcbiAgdGhpcy5sYW5lcyA9IE5vTGFuZXM7XG4gIHRoaXMuY2hpbGRMYW5lcyA9IE5vTGFuZXM7XG4gIHRoaXMuYWx0ZXJuYXRlID0gbnVsbDtcblxuICB7XG4gICAgLy8gTm90ZTogVGhlIGZvbGxvd2luZyBpcyBkb25lIHRvIGF2b2lkIGEgdjggcGVyZm9ybWFuY2UgY2xpZmYuXG4gICAgLy9cbiAgICAvLyBJbml0aWFsaXppbmcgdGhlIGZpZWxkcyBiZWxvdyB0byBzbWlzIGFuZCBsYXRlciB1cGRhdGluZyB0aGVtIHdpdGhcbiAgICAvLyBkb3VibGUgdmFsdWVzIHdpbGwgY2F1c2UgRmliZXJzIHRvIGVuZCB1cCBoYXZpbmcgc2VwYXJhdGUgc2hhcGVzLlxuICAgIC8vIFRoaXMgYmVoYXZpb3IvYnVnIGhhcyBzb21ldGhpbmcgdG8gZG8gd2l0aCBPYmplY3QucHJldmVudEV4dGVuc2lvbigpLlxuICAgIC8vIEZvcnR1bmF0ZWx5IHRoaXMgb25seSBpbXBhY3RzIERFViBidWlsZHMuXG4gICAgLy8gVW5mb3J0dW5hdGVseSBpdCBtYWtlcyBSZWFjdCB1bnVzYWJseSBzbG93IGZvciBzb21lIGFwcGxpY2F0aW9ucy5cbiAgICAvLyBUbyB3b3JrIGFyb3VuZCB0aGlzLCBpbml0aWFsaXplIHRoZSBmaWVsZHMgYmVsb3cgd2l0aCBkb3VibGVzLlxuICAgIC8vXG4gICAgLy8gTGVhcm4gbW9yZSBhYm91dCB0aGlzIGhlcmU6XG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xNDM2NVxuICAgIC8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTg1MzhcbiAgICB0aGlzLmFjdHVhbER1cmF0aW9uID0gTnVtYmVyLk5hTjtcbiAgICB0aGlzLmFjdHVhbFN0YXJ0VGltZSA9IE51bWJlci5OYU47XG4gICAgdGhpcy5zZWxmQmFzZUR1cmF0aW9uID0gTnVtYmVyLk5hTjtcbiAgICB0aGlzLnRyZWVCYXNlRHVyYXRpb24gPSBOdW1iZXIuTmFOOyAvLyBJdCdzIG9rYXkgdG8gcmVwbGFjZSB0aGUgaW5pdGlhbCBkb3VibGVzIHdpdGggc21pcyBhZnRlciBpbml0aWFsaXphdGlvbi5cbiAgICAvLyBUaGlzIHdvbid0IHRyaWdnZXIgdGhlIHBlcmZvcm1hbmNlIGNsaWZmIG1lbnRpb25lZCBhYm92ZSxcbiAgICAvLyBhbmQgaXQgc2ltcGxpZmllcyBvdGhlciBwcm9maWxlciBjb2RlIChpbmNsdWRpbmcgRGV2VG9vbHMpLlxuXG4gICAgdGhpcy5hY3R1YWxEdXJhdGlvbiA9IDA7XG4gICAgdGhpcy5hY3R1YWxTdGFydFRpbWUgPSAtMTtcbiAgICB0aGlzLnNlbGZCYXNlRHVyYXRpb24gPSAwO1xuICAgIHRoaXMudHJlZUJhc2VEdXJhdGlvbiA9IDA7XG4gIH1cblxuICB7XG4gICAgLy8gVGhpcyBpc24ndCBkaXJlY3RseSB1c2VkIGJ1dCBpcyBoYW5keSBmb3IgZGVidWdnaW5nIGludGVybmFsczpcbiAgICB0aGlzLl9kZWJ1Z0lEID0gZGVidWdDb3VudGVyKys7XG4gICAgdGhpcy5fZGVidWdTb3VyY2UgPSBudWxsO1xuICAgIHRoaXMuX2RlYnVnT3duZXIgPSBudWxsO1xuICAgIHRoaXMuX2RlYnVnTmVlZHNSZW1vdW50ID0gZmFsc2U7XG4gICAgdGhpcy5fZGVidWdIb29rVHlwZXMgPSBudWxsO1xuXG4gICAgaWYgKCFoYXNCYWRNYXBQb2x5ZmlsbCAmJiB0eXBlb2YgT2JqZWN0LnByZXZlbnRFeHRlbnNpb25zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBPYmplY3QucHJldmVudEV4dGVuc2lvbnModGhpcyk7XG4gICAgfVxuICB9XG59IC8vIFRoaXMgaXMgYSBjb25zdHJ1Y3RvciBmdW5jdGlvbiwgcmF0aGVyIHRoYW4gYSBQT0pPIGNvbnN0cnVjdG9yLCBzdGlsbFxuLy8gcGxlYXNlIGVuc3VyZSB3ZSBkbyB0aGUgZm9sbG93aW5nOlxuLy8gMSkgTm9ib2R5IHNob3VsZCBhZGQgYW55IGluc3RhbmNlIG1ldGhvZHMgb24gdGhpcy4gSW5zdGFuY2UgbWV0aG9kcyBjYW4gYmVcbi8vICAgIG1vcmUgZGlmZmljdWx0IHRvIHByZWRpY3Qgd2hlbiB0aGV5IGdldCBvcHRpbWl6ZWQgYW5kIHRoZXkgYXJlIGFsbW9zdFxuLy8gICAgbmV2ZXIgaW5saW5lZCBwcm9wZXJseSBpbiBzdGF0aWMgY29tcGlsZXJzLlxuLy8gMikgTm9ib2R5IHNob3VsZCByZWx5IG9uIGBpbnN0YW5jZW9mIEZpYmVyYCBmb3IgdHlwZSB0ZXN0aW5nLiBXZSBzaG91bGRcbi8vICAgIGFsd2F5cyBrbm93IHdoZW4gaXQgaXMgYSBmaWJlci5cbi8vIDMpIFdlIG1pZ2h0IHdhbnQgdG8gZXhwZXJpbWVudCB3aXRoIHVzaW5nIG51bWVyaWMga2V5cyBzaW5jZSB0aGV5IGFyZSBlYXNpZXJcbi8vICAgIHRvIG9wdGltaXplIGluIGEgbm9uLUpJVCBlbnZpcm9ubWVudC5cbi8vIDQpIFdlIGNhbiBlYXNpbHkgZ28gZnJvbSBhIGNvbnN0cnVjdG9yIHRvIGEgY3JlYXRlRmliZXIgb2JqZWN0IGxpdGVyYWwgaWYgdGhhdFxuLy8gICAgaXMgZmFzdGVyLlxuLy8gNSkgSXQgc2hvdWxkIGJlIGVhc3kgdG8gcG9ydCB0aGlzIHRvIGEgQyBzdHJ1Y3QgYW5kIGtlZXAgYSBDIGltcGxlbWVudGF0aW9uXG4vLyAgICBjb21wYXRpYmxlLlxuXG5cbnZhciBjcmVhdGVGaWJlciA9IGZ1bmN0aW9uICh0YWcsIHBlbmRpbmdQcm9wcywga2V5LCBtb2RlKSB7XG4gIC8vICRGbG93Rml4TWU6IHRoZSBzaGFwZXMgYXJlIGV4YWN0IGhlcmUgYnV0IEZsb3cgZG9lc24ndCBsaWtlIGNvbnN0cnVjdG9yc1xuICByZXR1cm4gbmV3IEZpYmVyTm9kZSh0YWcsIHBlbmRpbmdQcm9wcywga2V5LCBtb2RlKTtcbn07XG5cbmZ1bmN0aW9uIHNob3VsZENvbnN0cnVjdCQxKENvbXBvbmVudCkge1xuICB2YXIgcHJvdG90eXBlID0gQ29tcG9uZW50LnByb3RvdHlwZTtcbiAgcmV0dXJuICEhKHByb3RvdHlwZSAmJiBwcm90b3R5cGUuaXNSZWFjdENvbXBvbmVudCk7XG59XG5cbmZ1bmN0aW9uIGlzU2ltcGxlRnVuY3Rpb25Db21wb25lbnQodHlwZSkge1xuICByZXR1cm4gdHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicgJiYgIXNob3VsZENvbnN0cnVjdCQxKHR5cGUpICYmIHR5cGUuZGVmYXVsdFByb3BzID09PSB1bmRlZmluZWQ7XG59XG5mdW5jdGlvbiByZXNvbHZlTGF6eUNvbXBvbmVudFRhZyhDb21wb25lbnQpIHtcbiAgaWYgKHR5cGVvZiBDb21wb25lbnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gc2hvdWxkQ29uc3RydWN0JDEoQ29tcG9uZW50KSA/IENsYXNzQ29tcG9uZW50IDogRnVuY3Rpb25Db21wb25lbnQ7XG4gIH0gZWxzZSBpZiAoQ29tcG9uZW50ICE9PSB1bmRlZmluZWQgJiYgQ29tcG9uZW50ICE9PSBudWxsKSB7XG4gICAgdmFyICQkdHlwZW9mID0gQ29tcG9uZW50LiQkdHlwZW9mO1xuXG4gICAgaWYgKCQkdHlwZW9mID09PSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFKSB7XG4gICAgICByZXR1cm4gRm9yd2FyZFJlZjtcbiAgICB9XG5cbiAgICBpZiAoJCR0eXBlb2YgPT09IFJFQUNUX01FTU9fVFlQRSkge1xuICAgICAgcmV0dXJuIE1lbW9Db21wb25lbnQ7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIEluZGV0ZXJtaW5hdGVDb21wb25lbnQ7XG59IC8vIFRoaXMgaXMgdXNlZCB0byBjcmVhdGUgYW4gYWx0ZXJuYXRlIGZpYmVyIHRvIGRvIHdvcmsgb24uXG5cbmZ1bmN0aW9uIGNyZWF0ZVdvcmtJblByb2dyZXNzKGN1cnJlbnQsIHBlbmRpbmdQcm9wcykge1xuICB2YXIgd29ya0luUHJvZ3Jlc3MgPSBjdXJyZW50LmFsdGVybmF0ZTtcblxuICBpZiAod29ya0luUHJvZ3Jlc3MgPT09IG51bGwpIHtcbiAgICAvLyBXZSB1c2UgYSBkb3VibGUgYnVmZmVyaW5nIHBvb2xpbmcgdGVjaG5pcXVlIGJlY2F1c2Ugd2Uga25vdyB0aGF0IHdlJ2xsXG4gICAgLy8gb25seSBldmVyIG5lZWQgYXQgbW9zdCB0d28gdmVyc2lvbnMgb2YgYSB0cmVlLiBXZSBwb29sIHRoZSBcIm90aGVyXCIgdW51c2VkXG4gICAgLy8gbm9kZSB0aGF0IHdlJ3JlIGZyZWUgdG8gcmV1c2UuIFRoaXMgaXMgbGF6aWx5IGNyZWF0ZWQgdG8gYXZvaWQgYWxsb2NhdGluZ1xuICAgIC8vIGV4dHJhIG9iamVjdHMgZm9yIHRoaW5ncyB0aGF0IGFyZSBuZXZlciB1cGRhdGVkLiBJdCBhbHNvIGFsbG93IHVzIHRvXG4gICAgLy8gcmVjbGFpbSB0aGUgZXh0cmEgbWVtb3J5IGlmIG5lZWRlZC5cbiAgICB3b3JrSW5Qcm9ncmVzcyA9IGNyZWF0ZUZpYmVyKGN1cnJlbnQudGFnLCBwZW5kaW5nUHJvcHMsIGN1cnJlbnQua2V5LCBjdXJyZW50Lm1vZGUpO1xuICAgIHdvcmtJblByb2dyZXNzLmVsZW1lbnRUeXBlID0gY3VycmVudC5lbGVtZW50VHlwZTtcbiAgICB3b3JrSW5Qcm9ncmVzcy50eXBlID0gY3VycmVudC50eXBlO1xuICAgIHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSA9IGN1cnJlbnQuc3RhdGVOb2RlO1xuXG4gICAge1xuICAgICAgLy8gREVWLW9ubHkgZmllbGRzXG4gICAgICB3b3JrSW5Qcm9ncmVzcy5fZGVidWdJRCA9IGN1cnJlbnQuX2RlYnVnSUQ7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5fZGVidWdTb3VyY2UgPSBjdXJyZW50Ll9kZWJ1Z1NvdXJjZTtcbiAgICAgIHdvcmtJblByb2dyZXNzLl9kZWJ1Z093bmVyID0gY3VycmVudC5fZGVidWdPd25lcjtcbiAgICAgIHdvcmtJblByb2dyZXNzLl9kZWJ1Z0hvb2tUeXBlcyA9IGN1cnJlbnQuX2RlYnVnSG9va1R5cGVzO1xuICAgIH1cblxuICAgIHdvcmtJblByb2dyZXNzLmFsdGVybmF0ZSA9IGN1cnJlbnQ7XG4gICAgY3VycmVudC5hbHRlcm5hdGUgPSB3b3JrSW5Qcm9ncmVzcztcbiAgfSBlbHNlIHtcbiAgICB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHMgPSBwZW5kaW5nUHJvcHM7IC8vIE5lZWRlZCBiZWNhdXNlIEJsb2NrcyBzdG9yZSBkYXRhIG9uIHR5cGUuXG5cbiAgICB3b3JrSW5Qcm9ncmVzcy50eXBlID0gY3VycmVudC50eXBlOyAvLyBXZSBhbHJlYWR5IGhhdmUgYW4gYWx0ZXJuYXRlLlxuICAgIC8vIFJlc2V0IHRoZSBlZmZlY3QgdGFnLlxuXG4gICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgPSBOb0ZsYWdzOyAvLyBUaGUgZWZmZWN0IGxpc3QgaXMgbm8gbG9uZ2VyIHZhbGlkLlxuXG4gICAgd29ya0luUHJvZ3Jlc3MubmV4dEVmZmVjdCA9IG51bGw7XG4gICAgd29ya0luUHJvZ3Jlc3MuZmlyc3RFZmZlY3QgPSBudWxsO1xuICAgIHdvcmtJblByb2dyZXNzLmxhc3RFZmZlY3QgPSBudWxsO1xuXG4gICAge1xuICAgICAgLy8gV2UgaW50ZW50aW9uYWxseSByZXNldCwgcmF0aGVyIHRoYW4gY29weSwgYWN0dWFsRHVyYXRpb24gJiBhY3R1YWxTdGFydFRpbWUuXG4gICAgICAvLyBUaGlzIHByZXZlbnRzIHRpbWUgZnJvbSBlbmRsZXNzbHkgYWNjdW11bGF0aW5nIGluIG5ldyBjb21taXRzLlxuICAgICAgLy8gVGhpcyBoYXMgdGhlIGRvd25zaWRlIG9mIHJlc2V0dGluZyB2YWx1ZXMgZm9yIGRpZmZlcmVudCBwcmlvcml0eSByZW5kZXJzLFxuICAgICAgLy8gQnV0IHdvcmtzIGZvciB5aWVsZGluZyAodGhlIGNvbW1vbiBjYXNlKSBhbmQgc2hvdWxkIHN1cHBvcnQgcmVzdW1pbmcuXG4gICAgICB3b3JrSW5Qcm9ncmVzcy5hY3R1YWxEdXJhdGlvbiA9IDA7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5hY3R1YWxTdGFydFRpbWUgPSAtMTtcbiAgICB9XG4gIH1cblxuICB3b3JrSW5Qcm9ncmVzcy5jaGlsZExhbmVzID0gY3VycmVudC5jaGlsZExhbmVzO1xuICB3b3JrSW5Qcm9ncmVzcy5sYW5lcyA9IGN1cnJlbnQubGFuZXM7XG4gIHdvcmtJblByb2dyZXNzLmNoaWxkID0gY3VycmVudC5jaGlsZDtcbiAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcyA9IGN1cnJlbnQubWVtb2l6ZWRQcm9wcztcbiAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZTtcbiAgd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWUgPSBjdXJyZW50LnVwZGF0ZVF1ZXVlOyAvLyBDbG9uZSB0aGUgZGVwZW5kZW5jaWVzIG9iamVjdC4gVGhpcyBpcyBtdXRhdGVkIGR1cmluZyB0aGUgcmVuZGVyIHBoYXNlLCBzb1xuICAvLyBpdCBjYW5ub3QgYmUgc2hhcmVkIHdpdGggdGhlIGN1cnJlbnQgZmliZXIuXG5cbiAgdmFyIGN1cnJlbnREZXBlbmRlbmNpZXMgPSBjdXJyZW50LmRlcGVuZGVuY2llcztcbiAgd29ya0luUHJvZ3Jlc3MuZGVwZW5kZW5jaWVzID0gY3VycmVudERlcGVuZGVuY2llcyA9PT0gbnVsbCA/IG51bGwgOiB7XG4gICAgbGFuZXM6IGN1cnJlbnREZXBlbmRlbmNpZXMubGFuZXMsXG4gICAgZmlyc3RDb250ZXh0OiBjdXJyZW50RGVwZW5kZW5jaWVzLmZpcnN0Q29udGV4dFxuICB9OyAvLyBUaGVzZSB3aWxsIGJlIG92ZXJyaWRkZW4gZHVyaW5nIHRoZSBwYXJlbnQncyByZWNvbmNpbGlhdGlvblxuXG4gIHdvcmtJblByb2dyZXNzLnNpYmxpbmcgPSBjdXJyZW50LnNpYmxpbmc7XG4gIHdvcmtJblByb2dyZXNzLmluZGV4ID0gY3VycmVudC5pbmRleDtcbiAgd29ya0luUHJvZ3Jlc3MucmVmID0gY3VycmVudC5yZWY7XG5cbiAge1xuICAgIHdvcmtJblByb2dyZXNzLnNlbGZCYXNlRHVyYXRpb24gPSBjdXJyZW50LnNlbGZCYXNlRHVyYXRpb247XG4gICAgd29ya0luUHJvZ3Jlc3MudHJlZUJhc2VEdXJhdGlvbiA9IGN1cnJlbnQudHJlZUJhc2VEdXJhdGlvbjtcbiAgfVxuXG4gIHtcbiAgICB3b3JrSW5Qcm9ncmVzcy5fZGVidWdOZWVkc1JlbW91bnQgPSBjdXJyZW50Ll9kZWJ1Z05lZWRzUmVtb3VudDtcblxuICAgIHN3aXRjaCAod29ya0luUHJvZ3Jlc3MudGFnKSB7XG4gICAgICBjYXNlIEluZGV0ZXJtaW5hdGVDb21wb25lbnQ6XG4gICAgICBjYXNlIEZ1bmN0aW9uQ29tcG9uZW50OlxuICAgICAgY2FzZSBTaW1wbGVNZW1vQ29tcG9uZW50OlxuICAgICAgICB3b3JrSW5Qcm9ncmVzcy50eXBlID0gcmVzb2x2ZUZ1bmN0aW9uRm9ySG90UmVsb2FkaW5nKGN1cnJlbnQudHlwZSk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIENsYXNzQ29tcG9uZW50OlxuICAgICAgICB3b3JrSW5Qcm9ncmVzcy50eXBlID0gcmVzb2x2ZUNsYXNzRm9ySG90UmVsb2FkaW5nKGN1cnJlbnQudHlwZSk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIEZvcndhcmRSZWY6XG4gICAgICAgIHdvcmtJblByb2dyZXNzLnR5cGUgPSByZXNvbHZlRm9yd2FyZFJlZkZvckhvdFJlbG9hZGluZyhjdXJyZW50LnR5cGUpO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gd29ya0luUHJvZ3Jlc3M7XG59IC8vIFVzZWQgdG8gcmV1c2UgYSBGaWJlciBmb3IgYSBzZWNvbmQgcGFzcy5cblxuZnVuY3Rpb24gcmVzZXRXb3JrSW5Qcm9ncmVzcyh3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpIHtcbiAgLy8gVGhpcyByZXNldHMgdGhlIEZpYmVyIHRvIHdoYXQgY3JlYXRlRmliZXIgb3IgY3JlYXRlV29ya0luUHJvZ3Jlc3Mgd291bGRcbiAgLy8gaGF2ZSBzZXQgdGhlIHZhbHVlcyB0byBiZWZvcmUgZHVyaW5nIHRoZSBmaXJzdCBwYXNzLiBJZGVhbGx5IHRoaXMgd291bGRuJ3RcbiAgLy8gYmUgbmVjZXNzYXJ5IGJ1dCB1bmZvcnR1bmF0ZWx5IG1hbnkgY29kZSBwYXRocyByZWFkcyBmcm9tIHRoZSB3b3JrSW5Qcm9ncmVzc1xuICAvLyB3aGVuIHRoZXkgc2hvdWxkIGJlIHJlYWRpbmcgZnJvbSBjdXJyZW50IGFuZCB3cml0aW5nIHRvIHdvcmtJblByb2dyZXNzLlxuICAvLyBXZSBhc3N1bWUgcGVuZGluZ1Byb3BzLCBpbmRleCwga2V5LCByZWYsIHJldHVybiBhcmUgc3RpbGwgdW50b3VjaGVkIHRvXG4gIC8vIGF2b2lkIGRvaW5nIGFub3RoZXIgcmVjb25jaWxpYXRpb24uXG4gIC8vIFJlc2V0IHRoZSBlZmZlY3QgdGFnIGJ1dCBrZWVwIGFueSBQbGFjZW1lbnQgdGFncywgc2luY2UgdGhhdCdzIHNvbWV0aGluZ1xuICAvLyB0aGF0IGNoaWxkIGZpYmVyIGlzIHNldHRpbmcsIG5vdCB0aGUgcmVjb25jaWxpYXRpb24uXG4gIHdvcmtJblByb2dyZXNzLmZsYWdzICY9IFBsYWNlbWVudDsgLy8gVGhlIGVmZmVjdCBsaXN0IGlzIG5vIGxvbmdlciB2YWxpZC5cblxuICB3b3JrSW5Qcm9ncmVzcy5uZXh0RWZmZWN0ID0gbnVsbDtcbiAgd29ya0luUHJvZ3Jlc3MuZmlyc3RFZmZlY3QgPSBudWxsO1xuICB3b3JrSW5Qcm9ncmVzcy5sYXN0RWZmZWN0ID0gbnVsbDtcbiAgdmFyIGN1cnJlbnQgPSB3b3JrSW5Qcm9ncmVzcy5hbHRlcm5hdGU7XG5cbiAgaWYgKGN1cnJlbnQgPT09IG51bGwpIHtcbiAgICAvLyBSZXNldCB0byBjcmVhdGVGaWJlcidzIGluaXRpYWwgdmFsdWVzLlxuICAgIHdvcmtJblByb2dyZXNzLmNoaWxkTGFuZXMgPSBOb0xhbmVzO1xuICAgIHdvcmtJblByb2dyZXNzLmxhbmVzID0gcmVuZGVyTGFuZXM7XG4gICAgd29ya0luUHJvZ3Jlc3MuY2hpbGQgPSBudWxsO1xuICAgIHdvcmtJblByb2dyZXNzLm1lbW9pemVkUHJvcHMgPSBudWxsO1xuICAgIHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSBudWxsO1xuICAgIHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlID0gbnVsbDtcbiAgICB3b3JrSW5Qcm9ncmVzcy5kZXBlbmRlbmNpZXMgPSBudWxsO1xuICAgIHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSA9IG51bGw7XG5cbiAgICB7XG4gICAgICAvLyBOb3RlOiBXZSBkb24ndCByZXNldCB0aGUgYWN0dWFsVGltZSBjb3VudHMuIEl0J3MgdXNlZnVsIHRvIGFjY3VtdWxhdGVcbiAgICAgIC8vIGFjdHVhbCB0aW1lIGFjcm9zcyBtdWx0aXBsZSByZW5kZXIgcGFzc2VzLlxuICAgICAgd29ya0luUHJvZ3Jlc3Muc2VsZkJhc2VEdXJhdGlvbiA9IDA7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy50cmVlQmFzZUR1cmF0aW9uID0gMDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gUmVzZXQgdG8gdGhlIGNsb25lZCB2YWx1ZXMgdGhhdCBjcmVhdGVXb3JrSW5Qcm9ncmVzcyB3b3VsZCd2ZS5cbiAgICB3b3JrSW5Qcm9ncmVzcy5jaGlsZExhbmVzID0gY3VycmVudC5jaGlsZExhbmVzO1xuICAgIHdvcmtJblByb2dyZXNzLmxhbmVzID0gY3VycmVudC5sYW5lcztcbiAgICB3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IGN1cnJlbnQuY2hpbGQ7XG4gICAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcyA9IGN1cnJlbnQubWVtb2l6ZWRQcm9wcztcbiAgICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID0gY3VycmVudC5tZW1vaXplZFN0YXRlO1xuICAgIHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlID0gY3VycmVudC51cGRhdGVRdWV1ZTsgLy8gTmVlZGVkIGJlY2F1c2UgQmxvY2tzIHN0b3JlIGRhdGEgb24gdHlwZS5cblxuICAgIHdvcmtJblByb2dyZXNzLnR5cGUgPSBjdXJyZW50LnR5cGU7IC8vIENsb25lIHRoZSBkZXBlbmRlbmNpZXMgb2JqZWN0LiBUaGlzIGlzIG11dGF0ZWQgZHVyaW5nIHRoZSByZW5kZXIgcGhhc2UsIHNvXG4gICAgLy8gaXQgY2Fubm90IGJlIHNoYXJlZCB3aXRoIHRoZSBjdXJyZW50IGZpYmVyLlxuXG4gICAgdmFyIGN1cnJlbnREZXBlbmRlbmNpZXMgPSBjdXJyZW50LmRlcGVuZGVuY2llcztcbiAgICB3b3JrSW5Qcm9ncmVzcy5kZXBlbmRlbmNpZXMgPSBjdXJyZW50RGVwZW5kZW5jaWVzID09PSBudWxsID8gbnVsbCA6IHtcbiAgICAgIGxhbmVzOiBjdXJyZW50RGVwZW5kZW5jaWVzLmxhbmVzLFxuICAgICAgZmlyc3RDb250ZXh0OiBjdXJyZW50RGVwZW5kZW5jaWVzLmZpcnN0Q29udGV4dFxuICAgIH07XG5cbiAgICB7XG4gICAgICAvLyBOb3RlOiBXZSBkb24ndCByZXNldCB0aGUgYWN0dWFsVGltZSBjb3VudHMuIEl0J3MgdXNlZnVsIHRvIGFjY3VtdWxhdGVcbiAgICAgIC8vIGFjdHVhbCB0aW1lIGFjcm9zcyBtdWx0aXBsZSByZW5kZXIgcGFzc2VzLlxuICAgICAgd29ya0luUHJvZ3Jlc3Muc2VsZkJhc2VEdXJhdGlvbiA9IGN1cnJlbnQuc2VsZkJhc2VEdXJhdGlvbjtcbiAgICAgIHdvcmtJblByb2dyZXNzLnRyZWVCYXNlRHVyYXRpb24gPSBjdXJyZW50LnRyZWVCYXNlRHVyYXRpb247XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHdvcmtJblByb2dyZXNzO1xufVxuZnVuY3Rpb24gY3JlYXRlSG9zdFJvb3RGaWJlcih0YWcpIHtcbiAgdmFyIG1vZGU7XG5cbiAgaWYgKHRhZyA9PT0gQ29uY3VycmVudFJvb3QpIHtcbiAgICBtb2RlID0gQ29uY3VycmVudE1vZGUgfCBCbG9ja2luZ01vZGUgfCBTdHJpY3RNb2RlO1xuICB9IGVsc2UgaWYgKHRhZyA9PT0gQmxvY2tpbmdSb290KSB7XG4gICAgbW9kZSA9IEJsb2NraW5nTW9kZSB8IFN0cmljdE1vZGU7XG4gIH0gZWxzZSB7XG4gICAgbW9kZSA9IE5vTW9kZTtcbiAgfVxuXG4gIGlmICggaXNEZXZUb29sc1ByZXNlbnQpIHtcbiAgICAvLyBBbHdheXMgY29sbGVjdCBwcm9maWxlIHRpbWluZ3Mgd2hlbiBEZXZUb29scyBhcmUgcHJlc2VudC5cbiAgICAvLyBUaGlzIGVuYWJsZXMgRGV2VG9vbHMgdG8gc3RhcnQgY2FwdHVyaW5nIHRpbWluZyBhdCBhbnkgcG9pbnTigJNcbiAgICAvLyBXaXRob3V0IHNvbWUgbm9kZXMgaW4gdGhlIHRyZWUgaGF2aW5nIGVtcHR5IGJhc2UgdGltZXMuXG4gICAgbW9kZSB8PSBQcm9maWxlTW9kZTtcbiAgfVxuXG4gIHJldHVybiBjcmVhdGVGaWJlcihIb3N0Um9vdCwgbnVsbCwgbnVsbCwgbW9kZSk7XG59XG5mdW5jdGlvbiBjcmVhdGVGaWJlckZyb21UeXBlQW5kUHJvcHModHlwZSwgLy8gUmVhY3QkRWxlbWVudFR5cGVcbmtleSwgcGVuZGluZ1Byb3BzLCBvd25lciwgbW9kZSwgbGFuZXMpIHtcbiAgdmFyIGZpYmVyVGFnID0gSW5kZXRlcm1pbmF0ZUNvbXBvbmVudDsgLy8gVGhlIHJlc29sdmVkIHR5cGUgaXMgc2V0IGlmIHdlIGtub3cgd2hhdCB0aGUgZmluYWwgdHlwZSB3aWxsIGJlLiBJLmUuIGl0J3Mgbm90IGxhenkuXG5cbiAgdmFyIHJlc29sdmVkVHlwZSA9IHR5cGU7XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgaWYgKHNob3VsZENvbnN0cnVjdCQxKHR5cGUpKSB7XG4gICAgICBmaWJlclRhZyA9IENsYXNzQ29tcG9uZW50O1xuXG4gICAgICB7XG4gICAgICAgIHJlc29sdmVkVHlwZSA9IHJlc29sdmVDbGFzc0ZvckhvdFJlbG9hZGluZyhyZXNvbHZlZFR5cGUpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB7XG4gICAgICAgIHJlc29sdmVkVHlwZSA9IHJlc29sdmVGdW5jdGlvbkZvckhvdFJlbG9hZGluZyhyZXNvbHZlZFR5cGUpO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmICh0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICBmaWJlclRhZyA9IEhvc3RDb21wb25lbnQ7XG4gIH0gZWxzZSB7XG4gICAgZ2V0VGFnOiBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgIGNhc2UgUkVBQ1RfRlJBR01FTlRfVFlQRTpcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUZpYmVyRnJvbUZyYWdtZW50KHBlbmRpbmdQcm9wcy5jaGlsZHJlbiwgbW9kZSwgbGFuZXMsIGtleSk7XG5cbiAgICAgIGNhc2UgUkVBQ1RfREVCVUdfVFJBQ0lOR19NT0RFX1RZUEU6XG4gICAgICAgIGZpYmVyVGFnID0gTW9kZTtcbiAgICAgICAgbW9kZSB8PSBEZWJ1Z1RyYWNpbmdNb2RlO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFOlxuICAgICAgICBmaWJlclRhZyA9IE1vZGU7XG4gICAgICAgIG1vZGUgfD0gU3RyaWN0TW9kZTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgUkVBQ1RfUFJPRklMRVJfVFlQRTpcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUZpYmVyRnJvbVByb2ZpbGVyKHBlbmRpbmdQcm9wcywgbW9kZSwgbGFuZXMsIGtleSk7XG5cbiAgICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfVFlQRTpcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUZpYmVyRnJvbVN1c3BlbnNlKHBlbmRpbmdQcm9wcywgbW9kZSwgbGFuZXMsIGtleSk7XG5cbiAgICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFOlxuICAgICAgICByZXR1cm4gY3JlYXRlRmliZXJGcm9tU3VzcGVuc2VMaXN0KHBlbmRpbmdQcm9wcywgbW9kZSwgbGFuZXMsIGtleSk7XG5cbiAgICAgIGNhc2UgUkVBQ1RfT0ZGU0NSRUVOX1RZUEU6XG4gICAgICAgIHJldHVybiBjcmVhdGVGaWJlckZyb21PZmZzY3JlZW4ocGVuZGluZ1Byb3BzLCBtb2RlLCBsYW5lcywga2V5KTtcblxuICAgICAgY2FzZSBSRUFDVF9MRUdBQ1lfSElEREVOX1RZUEU6XG4gICAgICAgIHJldHVybiBjcmVhdGVGaWJlckZyb21MZWdhY3lIaWRkZW4ocGVuZGluZ1Byb3BzLCBtb2RlLCBsYW5lcywga2V5KTtcblxuICAgICAgY2FzZSBSRUFDVF9TQ09QRV9UWVBFOlxuXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZmFsbHRocm91Z2hcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAge1xuICAgICAgICAgIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcgJiYgdHlwZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgc3dpdGNoICh0eXBlLiQkdHlwZW9mKSB7XG4gICAgICAgICAgICAgIGNhc2UgUkVBQ1RfUFJPVklERVJfVFlQRTpcbiAgICAgICAgICAgICAgICBmaWJlclRhZyA9IENvbnRleHRQcm92aWRlcjtcbiAgICAgICAgICAgICAgICBicmVhayBnZXRUYWc7XG5cbiAgICAgICAgICAgICAgY2FzZSBSRUFDVF9DT05URVhUX1RZUEU6XG4gICAgICAgICAgICAgICAgLy8gVGhpcyBpcyBhIGNvbnN1bWVyXG4gICAgICAgICAgICAgICAgZmliZXJUYWcgPSBDb250ZXh0Q29uc3VtZXI7XG4gICAgICAgICAgICAgICAgYnJlYWsgZ2V0VGFnO1xuXG4gICAgICAgICAgICAgIGNhc2UgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRTpcbiAgICAgICAgICAgICAgICBmaWJlclRhZyA9IEZvcndhcmRSZWY7XG5cbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICByZXNvbHZlZFR5cGUgPSByZXNvbHZlRm9yd2FyZFJlZkZvckhvdFJlbG9hZGluZyhyZXNvbHZlZFR5cGUpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGJyZWFrIGdldFRhZztcblxuICAgICAgICAgICAgICBjYXNlIFJFQUNUX01FTU9fVFlQRTpcbiAgICAgICAgICAgICAgICBmaWJlclRhZyA9IE1lbW9Db21wb25lbnQ7XG4gICAgICAgICAgICAgICAgYnJlYWsgZ2V0VGFnO1xuXG4gICAgICAgICAgICAgIGNhc2UgUkVBQ1RfTEFaWV9UWVBFOlxuICAgICAgICAgICAgICAgIGZpYmVyVGFnID0gTGF6eUNvbXBvbmVudDtcbiAgICAgICAgICAgICAgICByZXNvbHZlZFR5cGUgPSBudWxsO1xuICAgICAgICAgICAgICAgIGJyZWFrIGdldFRhZztcblxuICAgICAgICAgICAgICBjYXNlIFJFQUNUX0JMT0NLX1RZUEU6XG4gICAgICAgICAgICAgICAgZmliZXJUYWcgPSBCbG9jaztcbiAgICAgICAgICAgICAgICBicmVhayBnZXRUYWc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIGluZm8gPSAnJztcblxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlmICh0eXBlID09PSB1bmRlZmluZWQgfHwgdHlwZW9mIHR5cGUgPT09ICdvYmplY3QnICYmIHR5cGUgIT09IG51bGwgJiYgT2JqZWN0LmtleXModHlwZSkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgIGluZm8gKz0gJyBZb3UgbGlrZWx5IGZvcmdvdCB0byBleHBvcnQgeW91ciBjb21wb25lbnQgZnJvbSB0aGUgZmlsZSAnICsgXCJpdCdzIGRlZmluZWQgaW4sIG9yIHlvdSBtaWdodCBoYXZlIG1peGVkIHVwIGRlZmF1bHQgYW5kIFwiICsgJ25hbWVkIGltcG9ydHMuJztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIG93bmVyTmFtZSA9IG93bmVyID8gZ2V0Q29tcG9uZW50TmFtZShvd25lci50eXBlKSA6IG51bGw7XG5cbiAgICAgICAgICAgIGlmIChvd25lck5hbWUpIHtcbiAgICAgICAgICAgICAgaW5mbyArPSAnXFxuXFxuQ2hlY2sgdGhlIHJlbmRlciBtZXRob2Qgb2YgYCcgKyBvd25lck5hbWUgKyAnYC4nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoIFwiRWxlbWVudCB0eXBlIGlzIGludmFsaWQ6IGV4cGVjdGVkIGEgc3RyaW5nIChmb3IgYnVpbHQtaW4gY29tcG9uZW50cykgb3IgYSBjbGFzcy9mdW5jdGlvbiAoZm9yIGNvbXBvc2l0ZSBjb21wb25lbnRzKSBidXQgZ290OiBcIiArICh0eXBlID09IG51bGwgPyB0eXBlIDogdHlwZW9mIHR5cGUpICsgXCIuXCIgKyBpbmZvICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICB9XG5cbiAgdmFyIGZpYmVyID0gY3JlYXRlRmliZXIoZmliZXJUYWcsIHBlbmRpbmdQcm9wcywga2V5LCBtb2RlKTtcbiAgZmliZXIuZWxlbWVudFR5cGUgPSB0eXBlO1xuICBmaWJlci50eXBlID0gcmVzb2x2ZWRUeXBlO1xuICBmaWJlci5sYW5lcyA9IGxhbmVzO1xuXG4gIHtcbiAgICBmaWJlci5fZGVidWdPd25lciA9IG93bmVyO1xuICB9XG5cbiAgcmV0dXJuIGZpYmVyO1xufVxuZnVuY3Rpb24gY3JlYXRlRmliZXJGcm9tRWxlbWVudChlbGVtZW50LCBtb2RlLCBsYW5lcykge1xuICB2YXIgb3duZXIgPSBudWxsO1xuXG4gIHtcbiAgICBvd25lciA9IGVsZW1lbnQuX293bmVyO1xuICB9XG5cbiAgdmFyIHR5cGUgPSBlbGVtZW50LnR5cGU7XG4gIHZhciBrZXkgPSBlbGVtZW50LmtleTtcbiAgdmFyIHBlbmRpbmdQcm9wcyA9IGVsZW1lbnQucHJvcHM7XG4gIHZhciBmaWJlciA9IGNyZWF0ZUZpYmVyRnJvbVR5cGVBbmRQcm9wcyh0eXBlLCBrZXksIHBlbmRpbmdQcm9wcywgb3duZXIsIG1vZGUsIGxhbmVzKTtcblxuICB7XG4gICAgZmliZXIuX2RlYnVnU291cmNlID0gZWxlbWVudC5fc291cmNlO1xuICAgIGZpYmVyLl9kZWJ1Z093bmVyID0gZWxlbWVudC5fb3duZXI7XG4gIH1cblxuICByZXR1cm4gZmliZXI7XG59XG5mdW5jdGlvbiBjcmVhdGVGaWJlckZyb21GcmFnbWVudChlbGVtZW50cywgbW9kZSwgbGFuZXMsIGtleSkge1xuICB2YXIgZmliZXIgPSBjcmVhdGVGaWJlcihGcmFnbWVudCwgZWxlbWVudHMsIGtleSwgbW9kZSk7XG4gIGZpYmVyLmxhbmVzID0gbGFuZXM7XG4gIHJldHVybiBmaWJlcjtcbn1cblxuZnVuY3Rpb24gY3JlYXRlRmliZXJGcm9tUHJvZmlsZXIocGVuZGluZ1Byb3BzLCBtb2RlLCBsYW5lcywga2V5KSB7XG4gIHtcbiAgICBpZiAodHlwZW9mIHBlbmRpbmdQcm9wcy5pZCAhPT0gJ3N0cmluZycpIHtcbiAgICAgIGVycm9yKCdQcm9maWxlciBtdXN0IHNwZWNpZnkgYW4gXCJpZFwiIGFzIGEgcHJvcCcpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBmaWJlciA9IGNyZWF0ZUZpYmVyKFByb2ZpbGVyLCBwZW5kaW5nUHJvcHMsIGtleSwgbW9kZSB8IFByb2ZpbGVNb2RlKTsgLy8gVE9ETzogVGhlIFByb2ZpbGVyIGZpYmVyIHNob3VsZG4ndCBoYXZlIGEgdHlwZS4gSXQgaGFzIGEgdGFnLlxuXG4gIGZpYmVyLmVsZW1lbnRUeXBlID0gUkVBQ1RfUFJPRklMRVJfVFlQRTtcbiAgZmliZXIudHlwZSA9IFJFQUNUX1BST0ZJTEVSX1RZUEU7XG4gIGZpYmVyLmxhbmVzID0gbGFuZXM7XG5cbiAge1xuICAgIGZpYmVyLnN0YXRlTm9kZSA9IHtcbiAgICAgIGVmZmVjdER1cmF0aW9uOiAwLFxuICAgICAgcGFzc2l2ZUVmZmVjdER1cmF0aW9uOiAwXG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiBmaWJlcjtcbn1cblxuZnVuY3Rpb24gY3JlYXRlRmliZXJGcm9tU3VzcGVuc2UocGVuZGluZ1Byb3BzLCBtb2RlLCBsYW5lcywga2V5KSB7XG4gIHZhciBmaWJlciA9IGNyZWF0ZUZpYmVyKFN1c3BlbnNlQ29tcG9uZW50LCBwZW5kaW5nUHJvcHMsIGtleSwgbW9kZSk7IC8vIFRPRE86IFRoZSBTdXNwZW5zZUNvbXBvbmVudCBmaWJlciBzaG91bGRuJ3QgaGF2ZSBhIHR5cGUuIEl0IGhhcyBhIHRhZy5cbiAgLy8gVGhpcyBuZWVkcyB0byBiZSBmaXhlZCBpbiBnZXRDb21wb25lbnROYW1lIHNvIHRoYXQgaXQgcmVsaWVzIG9uIHRoZSB0YWdcbiAgLy8gaW5zdGVhZC5cblxuICBmaWJlci50eXBlID0gUkVBQ1RfU1VTUEVOU0VfVFlQRTtcbiAgZmliZXIuZWxlbWVudFR5cGUgPSBSRUFDVF9TVVNQRU5TRV9UWVBFO1xuICBmaWJlci5sYW5lcyA9IGxhbmVzO1xuICByZXR1cm4gZmliZXI7XG59XG5mdW5jdGlvbiBjcmVhdGVGaWJlckZyb21TdXNwZW5zZUxpc3QocGVuZGluZ1Byb3BzLCBtb2RlLCBsYW5lcywga2V5KSB7XG4gIHZhciBmaWJlciA9IGNyZWF0ZUZpYmVyKFN1c3BlbnNlTGlzdENvbXBvbmVudCwgcGVuZGluZ1Byb3BzLCBrZXksIG1vZGUpO1xuXG4gIHtcbiAgICAvLyBUT0RPOiBUaGUgU3VzcGVuc2VMaXN0Q29tcG9uZW50IGZpYmVyIHNob3VsZG4ndCBoYXZlIGEgdHlwZS4gSXQgaGFzIGEgdGFnLlxuICAgIC8vIFRoaXMgbmVlZHMgdG8gYmUgZml4ZWQgaW4gZ2V0Q29tcG9uZW50TmFtZSBzbyB0aGF0IGl0IHJlbGllcyBvbiB0aGUgdGFnXG4gICAgLy8gaW5zdGVhZC5cbiAgICBmaWJlci50eXBlID0gUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFO1xuICB9XG5cbiAgZmliZXIuZWxlbWVudFR5cGUgPSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEU7XG4gIGZpYmVyLmxhbmVzID0gbGFuZXM7XG4gIHJldHVybiBmaWJlcjtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUZpYmVyRnJvbU9mZnNjcmVlbihwZW5kaW5nUHJvcHMsIG1vZGUsIGxhbmVzLCBrZXkpIHtcbiAgdmFyIGZpYmVyID0gY3JlYXRlRmliZXIoT2Zmc2NyZWVuQ29tcG9uZW50LCBwZW5kaW5nUHJvcHMsIGtleSwgbW9kZSk7IC8vIFRPRE86IFRoZSBPZmZzY3JlZW5Db21wb25lbnQgZmliZXIgc2hvdWxkbid0IGhhdmUgYSB0eXBlLiBJdCBoYXMgYSB0YWcuXG4gIC8vIFRoaXMgbmVlZHMgdG8gYmUgZml4ZWQgaW4gZ2V0Q29tcG9uZW50TmFtZSBzbyB0aGF0IGl0IHJlbGllcyBvbiB0aGUgdGFnXG4gIC8vIGluc3RlYWQuXG5cbiAge1xuICAgIGZpYmVyLnR5cGUgPSBSRUFDVF9PRkZTQ1JFRU5fVFlQRTtcbiAgfVxuXG4gIGZpYmVyLmVsZW1lbnRUeXBlID0gUkVBQ1RfT0ZGU0NSRUVOX1RZUEU7XG4gIGZpYmVyLmxhbmVzID0gbGFuZXM7XG4gIHJldHVybiBmaWJlcjtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUZpYmVyRnJvbUxlZ2FjeUhpZGRlbihwZW5kaW5nUHJvcHMsIG1vZGUsIGxhbmVzLCBrZXkpIHtcbiAgdmFyIGZpYmVyID0gY3JlYXRlRmliZXIoTGVnYWN5SGlkZGVuQ29tcG9uZW50LCBwZW5kaW5nUHJvcHMsIGtleSwgbW9kZSk7IC8vIFRPRE86IFRoZSBMZWdhY3lIaWRkZW4gZmliZXIgc2hvdWxkbid0IGhhdmUgYSB0eXBlLiBJdCBoYXMgYSB0YWcuXG4gIC8vIFRoaXMgbmVlZHMgdG8gYmUgZml4ZWQgaW4gZ2V0Q29tcG9uZW50TmFtZSBzbyB0aGF0IGl0IHJlbGllcyBvbiB0aGUgdGFnXG4gIC8vIGluc3RlYWQuXG5cbiAge1xuICAgIGZpYmVyLnR5cGUgPSBSRUFDVF9MRUdBQ1lfSElEREVOX1RZUEU7XG4gIH1cblxuICBmaWJlci5lbGVtZW50VHlwZSA9IFJFQUNUX0xFR0FDWV9ISURERU5fVFlQRTtcbiAgZmliZXIubGFuZXMgPSBsYW5lcztcbiAgcmV0dXJuIGZpYmVyO1xufVxuZnVuY3Rpb24gY3JlYXRlRmliZXJGcm9tVGV4dChjb250ZW50LCBtb2RlLCBsYW5lcykge1xuICB2YXIgZmliZXIgPSBjcmVhdGVGaWJlcihIb3N0VGV4dCwgY29udGVudCwgbnVsbCwgbW9kZSk7XG4gIGZpYmVyLmxhbmVzID0gbGFuZXM7XG4gIHJldHVybiBmaWJlcjtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUZpYmVyRnJvbUhvc3RJbnN0YW5jZUZvckRlbGV0aW9uKCkge1xuICB2YXIgZmliZXIgPSBjcmVhdGVGaWJlcihIb3N0Q29tcG9uZW50LCBudWxsLCBudWxsLCBOb01vZGUpOyAvLyBUT0RPOiBUaGVzZSBzaG91bGQgbm90IG5lZWQgYSB0eXBlLlxuXG4gIGZpYmVyLmVsZW1lbnRUeXBlID0gJ0RFTEVURUQnO1xuICBmaWJlci50eXBlID0gJ0RFTEVURUQnO1xuICByZXR1cm4gZmliZXI7XG59XG5mdW5jdGlvbiBjcmVhdGVGaWJlckZyb21Qb3J0YWwocG9ydGFsLCBtb2RlLCBsYW5lcykge1xuICB2YXIgcGVuZGluZ1Byb3BzID0gcG9ydGFsLmNoaWxkcmVuICE9PSBudWxsID8gcG9ydGFsLmNoaWxkcmVuIDogW107XG4gIHZhciBmaWJlciA9IGNyZWF0ZUZpYmVyKEhvc3RQb3J0YWwsIHBlbmRpbmdQcm9wcywgcG9ydGFsLmtleSwgbW9kZSk7XG4gIGZpYmVyLmxhbmVzID0gbGFuZXM7XG4gIGZpYmVyLnN0YXRlTm9kZSA9IHtcbiAgICBjb250YWluZXJJbmZvOiBwb3J0YWwuY29udGFpbmVySW5mbyxcbiAgICBwZW5kaW5nQ2hpbGRyZW46IG51bGwsXG4gICAgLy8gVXNlZCBieSBwZXJzaXN0ZW50IHVwZGF0ZXNcbiAgICBpbXBsZW1lbnRhdGlvbjogcG9ydGFsLmltcGxlbWVudGF0aW9uXG4gIH07XG4gIHJldHVybiBmaWJlcjtcbn0gLy8gVXNlZCBmb3Igc3Rhc2hpbmcgV0lQIHByb3BlcnRpZXMgdG8gcmVwbGF5IGZhaWxlZCB3b3JrIGluIERFVi5cblxuZnVuY3Rpb24gYXNzaWduRmliZXJQcm9wZXJ0aWVzSW5ERVYodGFyZ2V0LCBzb3VyY2UpIHtcbiAgaWYgKHRhcmdldCA9PT0gbnVsbCkge1xuICAgIC8vIFRoaXMgRmliZXIncyBpbml0aWFsIHByb3BlcnRpZXMgd2lsbCBhbHdheXMgYmUgb3ZlcndyaXR0ZW4uXG4gICAgLy8gV2Ugb25seSB1c2UgYSBGaWJlciB0byBlbnN1cmUgdGhlIHNhbWUgaGlkZGVuIGNsYXNzIHNvIERFViBpc24ndCBzbG93LlxuICAgIHRhcmdldCA9IGNyZWF0ZUZpYmVyKEluZGV0ZXJtaW5hdGVDb21wb25lbnQsIG51bGwsIG51bGwsIE5vTW9kZSk7XG4gIH0gLy8gVGhpcyBpcyBpbnRlbnRpb25hbGx5IHdyaXR0ZW4gYXMgYSBsaXN0IG9mIGFsbCBwcm9wZXJ0aWVzLlxuICAvLyBXZSB0cmllZCB0byB1c2UgT2JqZWN0LmFzc2lnbigpIGluc3RlYWQgYnV0IHRoaXMgaXMgY2FsbGVkIGluXG4gIC8vIHRoZSBob3R0ZXN0IHBhdGgsIGFuZCBPYmplY3QuYXNzaWduKCkgd2FzIHRvbyBzbG93OlxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzEyNTAyXG4gIC8vIFRoaXMgY29kZSBpcyBERVYtb25seSBzbyBzaXplIGlzIG5vdCBhIGNvbmNlcm4uXG5cblxuICB0YXJnZXQudGFnID0gc291cmNlLnRhZztcbiAgdGFyZ2V0LmtleSA9IHNvdXJjZS5rZXk7XG4gIHRhcmdldC5lbGVtZW50VHlwZSA9IHNvdXJjZS5lbGVtZW50VHlwZTtcbiAgdGFyZ2V0LnR5cGUgPSBzb3VyY2UudHlwZTtcbiAgdGFyZ2V0LnN0YXRlTm9kZSA9IHNvdXJjZS5zdGF0ZU5vZGU7XG4gIHRhcmdldC5yZXR1cm4gPSBzb3VyY2UucmV0dXJuO1xuICB0YXJnZXQuY2hpbGQgPSBzb3VyY2UuY2hpbGQ7XG4gIHRhcmdldC5zaWJsaW5nID0gc291cmNlLnNpYmxpbmc7XG4gIHRhcmdldC5pbmRleCA9IHNvdXJjZS5pbmRleDtcbiAgdGFyZ2V0LnJlZiA9IHNvdXJjZS5yZWY7XG4gIHRhcmdldC5wZW5kaW5nUHJvcHMgPSBzb3VyY2UucGVuZGluZ1Byb3BzO1xuICB0YXJnZXQubWVtb2l6ZWRQcm9wcyA9IHNvdXJjZS5tZW1vaXplZFByb3BzO1xuICB0YXJnZXQudXBkYXRlUXVldWUgPSBzb3VyY2UudXBkYXRlUXVldWU7XG4gIHRhcmdldC5tZW1vaXplZFN0YXRlID0gc291cmNlLm1lbW9pemVkU3RhdGU7XG4gIHRhcmdldC5kZXBlbmRlbmNpZXMgPSBzb3VyY2UuZGVwZW5kZW5jaWVzO1xuICB0YXJnZXQubW9kZSA9IHNvdXJjZS5tb2RlO1xuICB0YXJnZXQuZmxhZ3MgPSBzb3VyY2UuZmxhZ3M7XG4gIHRhcmdldC5uZXh0RWZmZWN0ID0gc291cmNlLm5leHRFZmZlY3Q7XG4gIHRhcmdldC5maXJzdEVmZmVjdCA9IHNvdXJjZS5maXJzdEVmZmVjdDtcbiAgdGFyZ2V0Lmxhc3RFZmZlY3QgPSBzb3VyY2UubGFzdEVmZmVjdDtcbiAgdGFyZ2V0LmxhbmVzID0gc291cmNlLmxhbmVzO1xuICB0YXJnZXQuY2hpbGRMYW5lcyA9IHNvdXJjZS5jaGlsZExhbmVzO1xuICB0YXJnZXQuYWx0ZXJuYXRlID0gc291cmNlLmFsdGVybmF0ZTtcblxuICB7XG4gICAgdGFyZ2V0LmFjdHVhbER1cmF0aW9uID0gc291cmNlLmFjdHVhbER1cmF0aW9uO1xuICAgIHRhcmdldC5hY3R1YWxTdGFydFRpbWUgPSBzb3VyY2UuYWN0dWFsU3RhcnRUaW1lO1xuICAgIHRhcmdldC5zZWxmQmFzZUR1cmF0aW9uID0gc291cmNlLnNlbGZCYXNlRHVyYXRpb247XG4gICAgdGFyZ2V0LnRyZWVCYXNlRHVyYXRpb24gPSBzb3VyY2UudHJlZUJhc2VEdXJhdGlvbjtcbiAgfVxuXG4gIHRhcmdldC5fZGVidWdJRCA9IHNvdXJjZS5fZGVidWdJRDtcbiAgdGFyZ2V0Ll9kZWJ1Z1NvdXJjZSA9IHNvdXJjZS5fZGVidWdTb3VyY2U7XG4gIHRhcmdldC5fZGVidWdPd25lciA9IHNvdXJjZS5fZGVidWdPd25lcjtcbiAgdGFyZ2V0Ll9kZWJ1Z05lZWRzUmVtb3VudCA9IHNvdXJjZS5fZGVidWdOZWVkc1JlbW91bnQ7XG4gIHRhcmdldC5fZGVidWdIb29rVHlwZXMgPSBzb3VyY2UuX2RlYnVnSG9va1R5cGVzO1xuICByZXR1cm4gdGFyZ2V0O1xufVxuXG5mdW5jdGlvbiBGaWJlclJvb3ROb2RlKGNvbnRhaW5lckluZm8sIHRhZywgaHlkcmF0ZSkge1xuICB0aGlzLnRhZyA9IHRhZztcbiAgdGhpcy5jb250YWluZXJJbmZvID0gY29udGFpbmVySW5mbztcbiAgdGhpcy5wZW5kaW5nQ2hpbGRyZW4gPSBudWxsO1xuICB0aGlzLmN1cnJlbnQgPSBudWxsO1xuICB0aGlzLnBpbmdDYWNoZSA9IG51bGw7XG4gIHRoaXMuZmluaXNoZWRXb3JrID0gbnVsbDtcbiAgdGhpcy50aW1lb3V0SGFuZGxlID0gbm9UaW1lb3V0O1xuICB0aGlzLmNvbnRleHQgPSBudWxsO1xuICB0aGlzLnBlbmRpbmdDb250ZXh0ID0gbnVsbDtcbiAgdGhpcy5oeWRyYXRlID0gaHlkcmF0ZTtcbiAgdGhpcy5jYWxsYmFja05vZGUgPSBudWxsO1xuICB0aGlzLmNhbGxiYWNrUHJpb3JpdHkgPSBOb0xhbmVQcmlvcml0eTtcbiAgdGhpcy5ldmVudFRpbWVzID0gY3JlYXRlTGFuZU1hcChOb0xhbmVzKTtcbiAgdGhpcy5leHBpcmF0aW9uVGltZXMgPSBjcmVhdGVMYW5lTWFwKE5vVGltZXN0YW1wKTtcbiAgdGhpcy5wZW5kaW5nTGFuZXMgPSBOb0xhbmVzO1xuICB0aGlzLnN1c3BlbmRlZExhbmVzID0gTm9MYW5lcztcbiAgdGhpcy5waW5nZWRMYW5lcyA9IE5vTGFuZXM7XG4gIHRoaXMuZXhwaXJlZExhbmVzID0gTm9MYW5lcztcbiAgdGhpcy5tdXRhYmxlUmVhZExhbmVzID0gTm9MYW5lcztcbiAgdGhpcy5maW5pc2hlZExhbmVzID0gTm9MYW5lcztcbiAgdGhpcy5lbnRhbmdsZWRMYW5lcyA9IE5vTGFuZXM7XG4gIHRoaXMuZW50YW5nbGVtZW50cyA9IGNyZWF0ZUxhbmVNYXAoTm9MYW5lcyk7XG5cbiAge1xuICAgIHRoaXMubXV0YWJsZVNvdXJjZUVhZ2VySHlkcmF0aW9uRGF0YSA9IG51bGw7XG4gIH1cblxuICB7XG4gICAgdGhpcy5pbnRlcmFjdGlvblRocmVhZElEID0gdHJhY2luZy51bnN0YWJsZV9nZXRUaHJlYWRJRCgpO1xuICAgIHRoaXMubWVtb2l6ZWRJbnRlcmFjdGlvbnMgPSBuZXcgU2V0KCk7XG4gICAgdGhpcy5wZW5kaW5nSW50ZXJhY3Rpb25NYXAgPSBuZXcgTWFwKCk7XG4gIH1cblxuICB7XG4gICAgc3dpdGNoICh0YWcpIHtcbiAgICAgIGNhc2UgQmxvY2tpbmdSb290OlxuICAgICAgICB0aGlzLl9kZWJ1Z1Jvb3RUeXBlID0gJ2NyZWF0ZUJsb2NraW5nUm9vdCgpJztcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgQ29uY3VycmVudFJvb3Q6XG4gICAgICAgIHRoaXMuX2RlYnVnUm9vdFR5cGUgPSAnY3JlYXRlUm9vdCgpJztcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgTGVnYWN5Um9vdDpcbiAgICAgICAgdGhpcy5fZGVidWdSb290VHlwZSA9ICdjcmVhdGVMZWdhY3lSb290KCknO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlRmliZXJSb290KGNvbnRhaW5lckluZm8sIHRhZywgaHlkcmF0ZSwgaHlkcmF0aW9uQ2FsbGJhY2tzKSB7XG4gIHZhciByb290ID0gbmV3IEZpYmVyUm9vdE5vZGUoY29udGFpbmVySW5mbywgdGFnLCBoeWRyYXRlKTtcbiAgLy8gc3RhdGVOb2RlIGlzIGFueS5cblxuXG4gIHZhciB1bmluaXRpYWxpemVkRmliZXIgPSBjcmVhdGVIb3N0Um9vdEZpYmVyKHRhZyk7XG4gIHJvb3QuY3VycmVudCA9IHVuaW5pdGlhbGl6ZWRGaWJlcjtcbiAgdW5pbml0aWFsaXplZEZpYmVyLnN0YXRlTm9kZSA9IHJvb3Q7XG4gIGluaXRpYWxpemVVcGRhdGVRdWV1ZSh1bmluaXRpYWxpemVkRmliZXIpO1xuICByZXR1cm4gcm9vdDtcbn1cblxuLy8gVGhpcyBlbnN1cmVzIHRoYXQgdGhlIHZlcnNpb24gdXNlZCBmb3Igc2VydmVyIHJlbmRlcmluZyBtYXRjaGVzIHRoZSBvbmVcbi8vIHRoYXQgaXMgZXZlbnR1YWxseSByZWFkIGR1cmluZyBoeWRyYXRpb24uXG4vLyBJZiB0aGV5IGRvbid0IG1hdGNoIHRoZXJlJ3MgYSBwb3RlbnRpYWwgdGVhciBhbmQgYSBmdWxsIGRlb3B0IHJlbmRlciBpcyByZXF1aXJlZC5cblxuZnVuY3Rpb24gcmVnaXN0ZXJNdXRhYmxlU291cmNlRm9ySHlkcmF0aW9uKHJvb3QsIG11dGFibGVTb3VyY2UpIHtcbiAgdmFyIGdldFZlcnNpb24gPSBtdXRhYmxlU291cmNlLl9nZXRWZXJzaW9uO1xuICB2YXIgdmVyc2lvbiA9IGdldFZlcnNpb24obXV0YWJsZVNvdXJjZS5fc291cmNlKTsgLy8gVE9ETyBDbGVhciB0aGlzIGRhdGEgb25jZSBhbGwgcGVuZGluZyBoeWRyYXRpb24gd29yayBpcyBmaW5pc2hlZC5cbiAgLy8gUmV0YWluaW5nIGl0IGZvcmV2ZXIgbWF5IGludGVyZmVyZSB3aXRoIEdDLlxuXG4gIGlmIChyb290Lm11dGFibGVTb3VyY2VFYWdlckh5ZHJhdGlvbkRhdGEgPT0gbnVsbCkge1xuICAgIHJvb3QubXV0YWJsZVNvdXJjZUVhZ2VySHlkcmF0aW9uRGF0YSA9IFttdXRhYmxlU291cmNlLCB2ZXJzaW9uXTtcbiAgfSBlbHNlIHtcbiAgICByb290Lm11dGFibGVTb3VyY2VFYWdlckh5ZHJhdGlvbkRhdGEucHVzaChtdXRhYmxlU291cmNlLCB2ZXJzaW9uKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVQb3J0YWwoY2hpbGRyZW4sIGNvbnRhaW5lckluZm8sIC8vIFRPRE86IGZpZ3VyZSBvdXQgdGhlIEFQSSBmb3IgY3Jvc3MtcmVuZGVyZXIgaW1wbGVtZW50YXRpb24uXG5pbXBsZW1lbnRhdGlvbikge1xuICB2YXIga2V5ID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiBudWxsO1xuICByZXR1cm4ge1xuICAgIC8vIFRoaXMgdGFnIGFsbG93IHVzIHRvIHVuaXF1ZWx5IGlkZW50aWZ5IHRoaXMgYXMgYSBSZWFjdCBQb3J0YWxcbiAgICAkJHR5cGVvZjogUkVBQ1RfUE9SVEFMX1RZUEUsXG4gICAga2V5OiBrZXkgPT0gbnVsbCA/IG51bGwgOiAnJyArIGtleSxcbiAgICBjaGlsZHJlbjogY2hpbGRyZW4sXG4gICAgY29udGFpbmVySW5mbzogY29udGFpbmVySW5mbyxcbiAgICBpbXBsZW1lbnRhdGlvbjogaW1wbGVtZW50YXRpb25cbiAgfTtcbn1cblxudmFyIGRpZFdhcm5BYm91dE5lc3RlZFVwZGF0ZXM7XG52YXIgZGlkV2FybkFib3V0RmluZE5vZGVJblN0cmljdE1vZGU7XG5cbntcbiAgZGlkV2FybkFib3V0TmVzdGVkVXBkYXRlcyA9IGZhbHNlO1xuICBkaWRXYXJuQWJvdXRGaW5kTm9kZUluU3RyaWN0TW9kZSA9IHt9O1xufVxuXG5mdW5jdGlvbiBnZXRDb250ZXh0Rm9yU3VidHJlZShwYXJlbnRDb21wb25lbnQpIHtcbiAgaWYgKCFwYXJlbnRDb21wb25lbnQpIHtcbiAgICByZXR1cm4gZW1wdHlDb250ZXh0T2JqZWN0O1xuICB9XG5cbiAgdmFyIGZpYmVyID0gZ2V0KHBhcmVudENvbXBvbmVudCk7XG4gIHZhciBwYXJlbnRDb250ZXh0ID0gZmluZEN1cnJlbnRVbm1hc2tlZENvbnRleHQoZmliZXIpO1xuXG4gIGlmIChmaWJlci50YWcgPT09IENsYXNzQ29tcG9uZW50KSB7XG4gICAgdmFyIENvbXBvbmVudCA9IGZpYmVyLnR5cGU7XG5cbiAgICBpZiAoaXNDb250ZXh0UHJvdmlkZXIoQ29tcG9uZW50KSkge1xuICAgICAgcmV0dXJuIHByb2Nlc3NDaGlsZENvbnRleHQoZmliZXIsIENvbXBvbmVudCwgcGFyZW50Q29udGV4dCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHBhcmVudENvbnRleHQ7XG59XG5cbmZ1bmN0aW9uIGZpbmRIb3N0SW5zdGFuY2VXaXRoV2FybmluZyhjb21wb25lbnQsIG1ldGhvZE5hbWUpIHtcbiAge1xuICAgIHZhciBmaWJlciA9IGdldChjb21wb25lbnQpO1xuXG4gICAgaWYgKGZpYmVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmICh0eXBlb2YgY29tcG9uZW50LnJlbmRlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB7XG4gICAgICAgICAge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoIFwiVW5hYmxlIHRvIGZpbmQgbm9kZSBvbiBhbiB1bm1vdW50ZWQgY29tcG9uZW50LlwiICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB7XG4gICAgICAgICAge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoIFwiQXJndW1lbnQgYXBwZWFycyB0byBub3QgYmUgYSBSZWFjdENvbXBvbmVudC4gS2V5czogXCIgKyBPYmplY3Qua2V5cyhjb21wb25lbnQpICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGhvc3RGaWJlciA9IGZpbmRDdXJyZW50SG9zdEZpYmVyKGZpYmVyKTtcblxuICAgIGlmIChob3N0RmliZXIgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGlmIChob3N0RmliZXIubW9kZSAmIFN0cmljdE1vZGUpIHtcbiAgICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZShmaWJlci50eXBlKSB8fCAnQ29tcG9uZW50JztcblxuICAgICAgaWYgKCFkaWRXYXJuQWJvdXRGaW5kTm9kZUluU3RyaWN0TW9kZVtjb21wb25lbnROYW1lXSkge1xuICAgICAgICBkaWRXYXJuQWJvdXRGaW5kTm9kZUluU3RyaWN0TW9kZVtjb21wb25lbnROYW1lXSA9IHRydWU7XG4gICAgICAgIHZhciBwcmV2aW91c0ZpYmVyID0gY3VycmVudDtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgIHNldEN1cnJlbnRGaWJlcihob3N0RmliZXIpO1xuXG4gICAgICAgICAgaWYgKGZpYmVyLm1vZGUgJiBTdHJpY3RNb2RlKSB7XG4gICAgICAgICAgICBlcnJvcignJXMgaXMgZGVwcmVjYXRlZCBpbiBTdHJpY3RNb2RlLiAnICsgJyVzIHdhcyBwYXNzZWQgYW4gaW5zdGFuY2Ugb2YgJXMgd2hpY2ggaXMgaW5zaWRlIFN0cmljdE1vZGUuICcgKyAnSW5zdGVhZCwgYWRkIGEgcmVmIGRpcmVjdGx5IHRvIHRoZSBlbGVtZW50IHlvdSB3YW50IHRvIHJlZmVyZW5jZS4gJyArICdMZWFybiBtb3JlIGFib3V0IHVzaW5nIHJlZnMgc2FmZWx5IGhlcmU6ICcgKyAnaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3N0cmljdC1tb2RlLWZpbmQtbm9kZScsIG1ldGhvZE5hbWUsIG1ldGhvZE5hbWUsIGNvbXBvbmVudE5hbWUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlcnJvcignJXMgaXMgZGVwcmVjYXRlZCBpbiBTdHJpY3RNb2RlLiAnICsgJyVzIHdhcyBwYXNzZWQgYW4gaW5zdGFuY2Ugb2YgJXMgd2hpY2ggcmVuZGVycyBTdHJpY3RNb2RlIGNoaWxkcmVuLiAnICsgJ0luc3RlYWQsIGFkZCBhIHJlZiBkaXJlY3RseSB0byB0aGUgZWxlbWVudCB5b3Ugd2FudCB0byByZWZlcmVuY2UuICcgKyAnTGVhcm4gbW9yZSBhYm91dCB1c2luZyByZWZzIHNhZmVseSBoZXJlOiAnICsgJ2h0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9zdHJpY3QtbW9kZS1maW5kLW5vZGUnLCBtZXRob2ROYW1lLCBtZXRob2ROYW1lLCBjb21wb25lbnROYW1lKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgLy8gSWRlYWxseSB0aGlzIHNob3VsZCByZXNldCB0byBwcmV2aW91cyBidXQgdGhpcyBzaG91bGRuJ3QgYmUgY2FsbGVkIGluXG4gICAgICAgICAgLy8gcmVuZGVyIGFuZCB0aGVyZSdzIGFub3RoZXIgd2FybmluZyBmb3IgdGhhdCBhbnl3YXkuXG4gICAgICAgICAgaWYgKHByZXZpb3VzRmliZXIpIHtcbiAgICAgICAgICAgIHNldEN1cnJlbnRGaWJlcihwcmV2aW91c0ZpYmVyKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzZXRDdXJyZW50RmliZXIoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gaG9zdEZpYmVyLnN0YXRlTm9kZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVDb250YWluZXIoY29udGFpbmVySW5mbywgdGFnLCBoeWRyYXRlLCBoeWRyYXRpb25DYWxsYmFja3MpIHtcbiAgcmV0dXJuIGNyZWF0ZUZpYmVyUm9vdChjb250YWluZXJJbmZvLCB0YWcsIGh5ZHJhdGUpO1xufVxuZnVuY3Rpb24gdXBkYXRlQ29udGFpbmVyKGVsZW1lbnQsIGNvbnRhaW5lciwgcGFyZW50Q29tcG9uZW50LCBjYWxsYmFjaykge1xuICB7XG4gICAgb25TY2hlZHVsZVJvb3QoY29udGFpbmVyLCBlbGVtZW50KTtcbiAgfVxuXG4gIHZhciBjdXJyZW50JDEgPSBjb250YWluZXIuY3VycmVudDtcbiAgdmFyIGV2ZW50VGltZSA9IHJlcXVlc3RFdmVudFRpbWUoKTtcblxuICB7XG4gICAgLy8gJEZsb3dFeHBlY3RlZEVycm9yIC0gamVzdCBpc24ndCBhIGdsb2JhbCwgYW5kIGlzbid0IHJlY29nbml6ZWQgb3V0c2lkZSBvZiB0ZXN0c1xuICAgIGlmICgndW5kZWZpbmVkJyAhPT0gdHlwZW9mIGplc3QpIHtcbiAgICAgIHdhcm5JZlVubW9ja2VkU2NoZWR1bGVyKGN1cnJlbnQkMSk7XG4gICAgICB3YXJuSWZOb3RTY29wZWRXaXRoTWF0Y2hpbmdBY3QoY3VycmVudCQxKTtcbiAgICB9XG4gIH1cblxuICB2YXIgbGFuZSA9IHJlcXVlc3RVcGRhdGVMYW5lKGN1cnJlbnQkMSk7XG5cbiAgdmFyIGNvbnRleHQgPSBnZXRDb250ZXh0Rm9yU3VidHJlZShwYXJlbnRDb21wb25lbnQpO1xuXG4gIGlmIChjb250YWluZXIuY29udGV4dCA9PT0gbnVsbCkge1xuICAgIGNvbnRhaW5lci5jb250ZXh0ID0gY29udGV4dDtcbiAgfSBlbHNlIHtcbiAgICBjb250YWluZXIucGVuZGluZ0NvbnRleHQgPSBjb250ZXh0O1xuICB9XG5cbiAge1xuICAgIGlmIChpc1JlbmRlcmluZyAmJiBjdXJyZW50ICE9PSBudWxsICYmICFkaWRXYXJuQWJvdXROZXN0ZWRVcGRhdGVzKSB7XG4gICAgICBkaWRXYXJuQWJvdXROZXN0ZWRVcGRhdGVzID0gdHJ1ZTtcblxuICAgICAgZXJyb3IoJ1JlbmRlciBtZXRob2RzIHNob3VsZCBiZSBhIHB1cmUgZnVuY3Rpb24gb2YgcHJvcHMgYW5kIHN0YXRlOyAnICsgJ3RyaWdnZXJpbmcgbmVzdGVkIGNvbXBvbmVudCB1cGRhdGVzIGZyb20gcmVuZGVyIGlzIG5vdCBhbGxvd2VkLiAnICsgJ0lmIG5lY2Vzc2FyeSwgdHJpZ2dlciBuZXN0ZWQgdXBkYXRlcyBpbiBjb21wb25lbnREaWRVcGRhdGUuXFxuXFxuJyArICdDaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiAlcy4nLCBnZXRDb21wb25lbnROYW1lKGN1cnJlbnQudHlwZSkgfHwgJ1Vua25vd24nKTtcbiAgICB9XG4gIH1cblxuICB2YXIgdXBkYXRlID0gY3JlYXRlVXBkYXRlKGV2ZW50VGltZSwgbGFuZSk7IC8vIENhdXRpb246IFJlYWN0IERldlRvb2xzIGN1cnJlbnRseSBkZXBlbmRzIG9uIHRoaXMgcHJvcGVydHlcbiAgLy8gYmVpbmcgY2FsbGVkIFwiZWxlbWVudFwiLlxuXG4gIHVwZGF0ZS5wYXlsb2FkID0ge1xuICAgIGVsZW1lbnQ6IGVsZW1lbnRcbiAgfTtcbiAgY2FsbGJhY2sgPSBjYWxsYmFjayA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IGNhbGxiYWNrO1xuXG4gIGlmIChjYWxsYmFjayAhPT0gbnVsbCkge1xuICAgIHtcbiAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgZXJyb3IoJ3JlbmRlciguLi4pOiBFeHBlY3RlZCB0aGUgbGFzdCBvcHRpb25hbCBgY2FsbGJhY2tgIGFyZ3VtZW50IHRvIGJlIGEgJyArICdmdW5jdGlvbi4gSW5zdGVhZCByZWNlaXZlZDogJXMuJywgY2FsbGJhY2spO1xuICAgICAgfVxuICAgIH1cblxuICAgIHVwZGF0ZS5jYWxsYmFjayA9IGNhbGxiYWNrO1xuICB9XG5cbiAgZW5xdWV1ZVVwZGF0ZShjdXJyZW50JDEsIHVwZGF0ZSk7XG4gIHNjaGVkdWxlVXBkYXRlT25GaWJlcihjdXJyZW50JDEsIGxhbmUsIGV2ZW50VGltZSk7XG4gIHJldHVybiBsYW5lO1xufVxuZnVuY3Rpb24gZ2V0UHVibGljUm9vdEluc3RhbmNlKGNvbnRhaW5lcikge1xuICB2YXIgY29udGFpbmVyRmliZXIgPSBjb250YWluZXIuY3VycmVudDtcblxuICBpZiAoIWNvbnRhaW5lckZpYmVyLmNoaWxkKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBzd2l0Y2ggKGNvbnRhaW5lckZpYmVyLmNoaWxkLnRhZykge1xuICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICAgIHJldHVybiBnZXRQdWJsaWNJbnN0YW5jZShjb250YWluZXJGaWJlci5jaGlsZC5zdGF0ZU5vZGUpO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBjb250YWluZXJGaWJlci5jaGlsZC5zdGF0ZU5vZGU7XG4gIH1cbn1cblxuZnVuY3Rpb24gbWFya1JldHJ5TGFuZUltcGwoZmliZXIsIHJldHJ5TGFuZSkge1xuICB2YXIgc3VzcGVuc2VTdGF0ZSA9IGZpYmVyLm1lbW9pemVkU3RhdGU7XG5cbiAgaWYgKHN1c3BlbnNlU3RhdGUgIT09IG51bGwgJiYgc3VzcGVuc2VTdGF0ZS5kZWh5ZHJhdGVkICE9PSBudWxsKSB7XG4gICAgc3VzcGVuc2VTdGF0ZS5yZXRyeUxhbmUgPSBoaWdoZXJQcmlvcml0eUxhbmUoc3VzcGVuc2VTdGF0ZS5yZXRyeUxhbmUsIHJldHJ5TGFuZSk7XG4gIH1cbn0gLy8gSW5jcmVhc2VzIHRoZSBwcmlvcml0eSBvZiB0aGVubmFibGVzIHdoZW4gdGhleSByZXNvbHZlIHdpdGhpbiB0aGlzIGJvdW5kYXJ5LlxuXG5cbmZ1bmN0aW9uIG1hcmtSZXRyeUxhbmVJZk5vdEh5ZHJhdGVkKGZpYmVyLCByZXRyeUxhbmUpIHtcbiAgbWFya1JldHJ5TGFuZUltcGwoZmliZXIsIHJldHJ5TGFuZSk7XG4gIHZhciBhbHRlcm5hdGUgPSBmaWJlci5hbHRlcm5hdGU7XG5cbiAgaWYgKGFsdGVybmF0ZSkge1xuICAgIG1hcmtSZXRyeUxhbmVJbXBsKGFsdGVybmF0ZSwgcmV0cnlMYW5lKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBhdHRlbXB0VXNlckJsb2NraW5nSHlkcmF0aW9uJDEoZmliZXIpIHtcbiAgaWYgKGZpYmVyLnRhZyAhPT0gU3VzcGVuc2VDb21wb25lbnQpIHtcbiAgICAvLyBXZSBpZ25vcmUgSG9zdFJvb3RzIGhlcmUgYmVjYXVzZSB3ZSBjYW4ndCBpbmNyZWFzZVxuICAgIC8vIHRoZWlyIHByaW9yaXR5IGFuZCB0aGV5IHNob3VsZCBub3Qgc3VzcGVuZCBvbiBJL08sXG4gICAgLy8gc2luY2UgeW91IGhhdmUgdG8gd3JhcCBhbnl0aGluZyB0aGF0IG1pZ2h0IHN1c3BlbmQgaW5cbiAgICAvLyBTdXNwZW5zZS5cbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgZXZlbnRUaW1lID0gcmVxdWVzdEV2ZW50VGltZSgpO1xuICB2YXIgbGFuZSA9IElucHV0RGlzY3JldGVIeWRyYXRpb25MYW5lO1xuICBzY2hlZHVsZVVwZGF0ZU9uRmliZXIoZmliZXIsIGxhbmUsIGV2ZW50VGltZSk7XG4gIG1hcmtSZXRyeUxhbmVJZk5vdEh5ZHJhdGVkKGZpYmVyLCBsYW5lKTtcbn1cbmZ1bmN0aW9uIGF0dGVtcHRDb250aW51b3VzSHlkcmF0aW9uJDEoZmliZXIpIHtcbiAgaWYgKGZpYmVyLnRhZyAhPT0gU3VzcGVuc2VDb21wb25lbnQpIHtcbiAgICAvLyBXZSBpZ25vcmUgSG9zdFJvb3RzIGhlcmUgYmVjYXVzZSB3ZSBjYW4ndCBpbmNyZWFzZVxuICAgIC8vIHRoZWlyIHByaW9yaXR5IGFuZCB0aGV5IHNob3VsZCBub3Qgc3VzcGVuZCBvbiBJL08sXG4gICAgLy8gc2luY2UgeW91IGhhdmUgdG8gd3JhcCBhbnl0aGluZyB0aGF0IG1pZ2h0IHN1c3BlbmQgaW5cbiAgICAvLyBTdXNwZW5zZS5cbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgZXZlbnRUaW1lID0gcmVxdWVzdEV2ZW50VGltZSgpO1xuICB2YXIgbGFuZSA9IFNlbGVjdGl2ZUh5ZHJhdGlvbkxhbmU7XG4gIHNjaGVkdWxlVXBkYXRlT25GaWJlcihmaWJlciwgbGFuZSwgZXZlbnRUaW1lKTtcbiAgbWFya1JldHJ5TGFuZUlmTm90SHlkcmF0ZWQoZmliZXIsIGxhbmUpO1xufVxuZnVuY3Rpb24gYXR0ZW1wdEh5ZHJhdGlvbkF0Q3VycmVudFByaW9yaXR5JDEoZmliZXIpIHtcbiAgaWYgKGZpYmVyLnRhZyAhPT0gU3VzcGVuc2VDb21wb25lbnQpIHtcbiAgICAvLyBXZSBpZ25vcmUgSG9zdFJvb3RzIGhlcmUgYmVjYXVzZSB3ZSBjYW4ndCBpbmNyZWFzZVxuICAgIC8vIHRoZWlyIHByaW9yaXR5IG90aGVyIHRoYW4gc3luY2hyb25vdXNseSBmbHVzaCBpdC5cbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgZXZlbnRUaW1lID0gcmVxdWVzdEV2ZW50VGltZSgpO1xuICB2YXIgbGFuZSA9IHJlcXVlc3RVcGRhdGVMYW5lKGZpYmVyKTtcbiAgc2NoZWR1bGVVcGRhdGVPbkZpYmVyKGZpYmVyLCBsYW5lLCBldmVudFRpbWUpO1xuICBtYXJrUmV0cnlMYW5lSWZOb3RIeWRyYXRlZChmaWJlciwgbGFuZSk7XG59XG5mdW5jdGlvbiBydW5XaXRoUHJpb3JpdHkkMihwcmlvcml0eSwgZm4pIHtcblxuICB0cnkge1xuICAgIHNldEN1cnJlbnRVcGRhdGVMYW5lUHJpb3JpdHkocHJpb3JpdHkpO1xuICAgIHJldHVybiBmbigpO1xuICB9IGZpbmFsbHkge1xuICB9XG59XG5mdW5jdGlvbiBmaW5kSG9zdEluc3RhbmNlV2l0aE5vUG9ydGFscyhmaWJlcikge1xuICB2YXIgaG9zdEZpYmVyID0gZmluZEN1cnJlbnRIb3N0RmliZXJXaXRoTm9Qb3J0YWxzKGZpYmVyKTtcblxuICBpZiAoaG9zdEZpYmVyID09PSBudWxsKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBpZiAoaG9zdEZpYmVyLnRhZyA9PT0gRnVuZGFtZW50YWxDb21wb25lbnQpIHtcbiAgICByZXR1cm4gaG9zdEZpYmVyLnN0YXRlTm9kZS5pbnN0YW5jZTtcbiAgfVxuXG4gIHJldHVybiBob3N0RmliZXIuc3RhdGVOb2RlO1xufVxuXG52YXIgc2hvdWxkU3VzcGVuZEltcGwgPSBmdW5jdGlvbiAoZmliZXIpIHtcbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuZnVuY3Rpb24gc2hvdWxkU3VzcGVuZChmaWJlcikge1xuICByZXR1cm4gc2hvdWxkU3VzcGVuZEltcGwoZmliZXIpO1xufVxudmFyIG92ZXJyaWRlSG9va1N0YXRlID0gbnVsbDtcbnZhciBvdmVycmlkZUhvb2tTdGF0ZURlbGV0ZVBhdGggPSBudWxsO1xudmFyIG92ZXJyaWRlSG9va1N0YXRlUmVuYW1lUGF0aCA9IG51bGw7XG52YXIgb3ZlcnJpZGVQcm9wcyA9IG51bGw7XG52YXIgb3ZlcnJpZGVQcm9wc0RlbGV0ZVBhdGggPSBudWxsO1xudmFyIG92ZXJyaWRlUHJvcHNSZW5hbWVQYXRoID0gbnVsbDtcbnZhciBzY2hlZHVsZVVwZGF0ZSA9IG51bGw7XG52YXIgc2V0U3VzcGVuc2VIYW5kbGVyID0gbnVsbDtcblxue1xuICB2YXIgY29weVdpdGhEZWxldGVJbXBsID0gZnVuY3Rpb24gKG9iaiwgcGF0aCwgaW5kZXgpIHtcbiAgICB2YXIga2V5ID0gcGF0aFtpbmRleF07XG4gICAgdmFyIHVwZGF0ZWQgPSBBcnJheS5pc0FycmF5KG9iaikgPyBvYmouc2xpY2UoKSA6IF9hc3NpZ24oe30sIG9iaik7XG5cbiAgICBpZiAoaW5kZXggKyAxID09PSBwYXRoLmxlbmd0aCkge1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkodXBkYXRlZCkpIHtcbiAgICAgICAgdXBkYXRlZC5zcGxpY2Uoa2V5LCAxKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlbGV0ZSB1cGRhdGVkW2tleV07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB1cGRhdGVkO1xuICAgIH0gLy8gJEZsb3dGaXhNZSBudW1iZXIgb3Igc3RyaW5nIGlzIGZpbmUgaGVyZVxuXG5cbiAgICB1cGRhdGVkW2tleV0gPSBjb3B5V2l0aERlbGV0ZUltcGwob2JqW2tleV0sIHBhdGgsIGluZGV4ICsgMSk7XG4gICAgcmV0dXJuIHVwZGF0ZWQ7XG4gIH07XG5cbiAgdmFyIGNvcHlXaXRoRGVsZXRlID0gZnVuY3Rpb24gKG9iaiwgcGF0aCkge1xuICAgIHJldHVybiBjb3B5V2l0aERlbGV0ZUltcGwob2JqLCBwYXRoLCAwKTtcbiAgfTtcblxuICB2YXIgY29weVdpdGhSZW5hbWVJbXBsID0gZnVuY3Rpb24gKG9iaiwgb2xkUGF0aCwgbmV3UGF0aCwgaW5kZXgpIHtcbiAgICB2YXIgb2xkS2V5ID0gb2xkUGF0aFtpbmRleF07XG4gICAgdmFyIHVwZGF0ZWQgPSBBcnJheS5pc0FycmF5KG9iaikgPyBvYmouc2xpY2UoKSA6IF9hc3NpZ24oe30sIG9iaik7XG5cbiAgICBpZiAoaW5kZXggKyAxID09PSBvbGRQYXRoLmxlbmd0aCkge1xuICAgICAgdmFyIG5ld0tleSA9IG5ld1BhdGhbaW5kZXhdOyAvLyAkRmxvd0ZpeE1lIG51bWJlciBvciBzdHJpbmcgaXMgZmluZSBoZXJlXG5cbiAgICAgIHVwZGF0ZWRbbmV3S2V5XSA9IHVwZGF0ZWRbb2xkS2V5XTtcblxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkodXBkYXRlZCkpIHtcbiAgICAgICAgdXBkYXRlZC5zcGxpY2Uob2xkS2V5LCAxKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlbGV0ZSB1cGRhdGVkW29sZEtleV07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vICRGbG93Rml4TWUgbnVtYmVyIG9yIHN0cmluZyBpcyBmaW5lIGhlcmVcbiAgICAgIHVwZGF0ZWRbb2xkS2V5XSA9IGNvcHlXaXRoUmVuYW1lSW1wbCggLy8gJEZsb3dGaXhNZSBudW1iZXIgb3Igc3RyaW5nIGlzIGZpbmUgaGVyZVxuICAgICAgb2JqW29sZEtleV0sIG9sZFBhdGgsIG5ld1BhdGgsIGluZGV4ICsgMSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHVwZGF0ZWQ7XG4gIH07XG5cbiAgdmFyIGNvcHlXaXRoUmVuYW1lID0gZnVuY3Rpb24gKG9iaiwgb2xkUGF0aCwgbmV3UGF0aCkge1xuICAgIGlmIChvbGRQYXRoLmxlbmd0aCAhPT0gbmV3UGF0aC5sZW5ndGgpIHtcbiAgICAgIHdhcm4oJ2NvcHlXaXRoUmVuYW1lKCkgZXhwZWN0cyBwYXRocyBvZiB0aGUgc2FtZSBsZW5ndGgnKTtcblxuICAgICAgcmV0dXJuO1xuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5ld1BhdGgubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgIGlmIChvbGRQYXRoW2ldICE9PSBuZXdQYXRoW2ldKSB7XG4gICAgICAgICAgd2FybignY29weVdpdGhSZW5hbWUoKSBleHBlY3RzIHBhdGhzIHRvIGJlIHRoZSBzYW1lIGV4Y2VwdCBmb3IgdGhlIGRlZXBlc3Qga2V5Jyk7XG5cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gY29weVdpdGhSZW5hbWVJbXBsKG9iaiwgb2xkUGF0aCwgbmV3UGF0aCwgMCk7XG4gIH07XG5cbiAgdmFyIGNvcHlXaXRoU2V0SW1wbCA9IGZ1bmN0aW9uIChvYmosIHBhdGgsIGluZGV4LCB2YWx1ZSkge1xuICAgIGlmIChpbmRleCA+PSBwYXRoLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cblxuICAgIHZhciBrZXkgPSBwYXRoW2luZGV4XTtcbiAgICB2YXIgdXBkYXRlZCA9IEFycmF5LmlzQXJyYXkob2JqKSA/IG9iai5zbGljZSgpIDogX2Fzc2lnbih7fSwgb2JqKTsgLy8gJEZsb3dGaXhNZSBudW1iZXIgb3Igc3RyaW5nIGlzIGZpbmUgaGVyZVxuXG4gICAgdXBkYXRlZFtrZXldID0gY29weVdpdGhTZXRJbXBsKG9ialtrZXldLCBwYXRoLCBpbmRleCArIDEsIHZhbHVlKTtcbiAgICByZXR1cm4gdXBkYXRlZDtcbiAgfTtcblxuICB2YXIgY29weVdpdGhTZXQgPSBmdW5jdGlvbiAob2JqLCBwYXRoLCB2YWx1ZSkge1xuICAgIHJldHVybiBjb3B5V2l0aFNldEltcGwob2JqLCBwYXRoLCAwLCB2YWx1ZSk7XG4gIH07XG5cbiAgdmFyIGZpbmRIb29rID0gZnVuY3Rpb24gKGZpYmVyLCBpZCkge1xuICAgIC8vIEZvciBub3csIHRoZSBcImlkXCIgb2Ygc3RhdGVmdWwgaG9va3MgaXMganVzdCB0aGUgc3RhdGVmdWwgaG9vayBpbmRleC5cbiAgICAvLyBUaGlzIG1heSBjaGFuZ2UgaW4gdGhlIGZ1dHVyZSB3aXRoIGUuZy4gbmVzdGVkIGhvb2tzLlxuICAgIHZhciBjdXJyZW50SG9vayA9IGZpYmVyLm1lbW9pemVkU3RhdGU7XG5cbiAgICB3aGlsZSAoY3VycmVudEhvb2sgIT09IG51bGwgJiYgaWQgPiAwKSB7XG4gICAgICBjdXJyZW50SG9vayA9IGN1cnJlbnRIb29rLm5leHQ7XG4gICAgICBpZC0tO1xuICAgIH1cblxuICAgIHJldHVybiBjdXJyZW50SG9vaztcbiAgfTsgLy8gU3VwcG9ydCBEZXZUb29scyBlZGl0YWJsZSB2YWx1ZXMgZm9yIHVzZVN0YXRlIGFuZCB1c2VSZWR1Y2VyLlxuXG5cbiAgb3ZlcnJpZGVIb29rU3RhdGUgPSBmdW5jdGlvbiAoZmliZXIsIGlkLCBwYXRoLCB2YWx1ZSkge1xuICAgIHZhciBob29rID0gZmluZEhvb2soZmliZXIsIGlkKTtcblxuICAgIGlmIChob29rICE9PSBudWxsKSB7XG4gICAgICB2YXIgbmV3U3RhdGUgPSBjb3B5V2l0aFNldChob29rLm1lbW9pemVkU3RhdGUsIHBhdGgsIHZhbHVlKTtcbiAgICAgIGhvb2subWVtb2l6ZWRTdGF0ZSA9IG5ld1N0YXRlO1xuICAgICAgaG9vay5iYXNlU3RhdGUgPSBuZXdTdGF0ZTsgLy8gV2UgYXJlbid0IGFjdHVhbGx5IGFkZGluZyBhbiB1cGRhdGUgdG8gdGhlIHF1ZXVlLFxuICAgICAgLy8gYmVjYXVzZSB0aGVyZSBpcyBubyB1cGRhdGUgd2UgY2FuIGFkZCBmb3IgdXNlUmVkdWNlciBob29rcyB0aGF0IHdvbid0IHRyaWdnZXIgYW4gZXJyb3IuXG4gICAgICAvLyAoVGhlcmUncyBubyBhcHByb3ByaWF0ZSBhY3Rpb24gdHlwZSBmb3IgRGV2VG9vbHMgb3ZlcnJpZGVzLilcbiAgICAgIC8vIEFzIGEgcmVzdWx0IHRob3VnaCwgUmVhY3Qgd2lsbCBzZWUgdGhlIHNjaGVkdWxlZCB1cGRhdGUgYXMgYSBub29wIGFuZCBiYWlsb3V0LlxuICAgICAgLy8gU2hhbGxvdyBjbG9uaW5nIHByb3BzIHdvcmtzIGFzIGEgd29ya2Fyb3VuZCBmb3Igbm93IHRvIGJ5cGFzcyB0aGUgYmFpbG91dCBjaGVjay5cblxuICAgICAgZmliZXIubWVtb2l6ZWRQcm9wcyA9IF9hc3NpZ24oe30sIGZpYmVyLm1lbW9pemVkUHJvcHMpO1xuICAgICAgc2NoZWR1bGVVcGRhdGVPbkZpYmVyKGZpYmVyLCBTeW5jTGFuZSwgTm9UaW1lc3RhbXApO1xuICAgIH1cbiAgfTtcblxuICBvdmVycmlkZUhvb2tTdGF0ZURlbGV0ZVBhdGggPSBmdW5jdGlvbiAoZmliZXIsIGlkLCBwYXRoKSB7XG4gICAgdmFyIGhvb2sgPSBmaW5kSG9vayhmaWJlciwgaWQpO1xuXG4gICAgaWYgKGhvb2sgIT09IG51bGwpIHtcbiAgICAgIHZhciBuZXdTdGF0ZSA9IGNvcHlXaXRoRGVsZXRlKGhvb2subWVtb2l6ZWRTdGF0ZSwgcGF0aCk7XG4gICAgICBob29rLm1lbW9pemVkU3RhdGUgPSBuZXdTdGF0ZTtcbiAgICAgIGhvb2suYmFzZVN0YXRlID0gbmV3U3RhdGU7IC8vIFdlIGFyZW4ndCBhY3R1YWxseSBhZGRpbmcgYW4gdXBkYXRlIHRvIHRoZSBxdWV1ZSxcbiAgICAgIC8vIGJlY2F1c2UgdGhlcmUgaXMgbm8gdXBkYXRlIHdlIGNhbiBhZGQgZm9yIHVzZVJlZHVjZXIgaG9va3MgdGhhdCB3b24ndCB0cmlnZ2VyIGFuIGVycm9yLlxuICAgICAgLy8gKFRoZXJlJ3Mgbm8gYXBwcm9wcmlhdGUgYWN0aW9uIHR5cGUgZm9yIERldlRvb2xzIG92ZXJyaWRlcy4pXG4gICAgICAvLyBBcyBhIHJlc3VsdCB0aG91Z2gsIFJlYWN0IHdpbGwgc2VlIHRoZSBzY2hlZHVsZWQgdXBkYXRlIGFzIGEgbm9vcCBhbmQgYmFpbG91dC5cbiAgICAgIC8vIFNoYWxsb3cgY2xvbmluZyBwcm9wcyB3b3JrcyBhcyBhIHdvcmthcm91bmQgZm9yIG5vdyB0byBieXBhc3MgdGhlIGJhaWxvdXQgY2hlY2suXG5cbiAgICAgIGZpYmVyLm1lbW9pemVkUHJvcHMgPSBfYXNzaWduKHt9LCBmaWJlci5tZW1vaXplZFByb3BzKTtcbiAgICAgIHNjaGVkdWxlVXBkYXRlT25GaWJlcihmaWJlciwgU3luY0xhbmUsIE5vVGltZXN0YW1wKTtcbiAgICB9XG4gIH07XG5cbiAgb3ZlcnJpZGVIb29rU3RhdGVSZW5hbWVQYXRoID0gZnVuY3Rpb24gKGZpYmVyLCBpZCwgb2xkUGF0aCwgbmV3UGF0aCkge1xuICAgIHZhciBob29rID0gZmluZEhvb2soZmliZXIsIGlkKTtcblxuICAgIGlmIChob29rICE9PSBudWxsKSB7XG4gICAgICB2YXIgbmV3U3RhdGUgPSBjb3B5V2l0aFJlbmFtZShob29rLm1lbW9pemVkU3RhdGUsIG9sZFBhdGgsIG5ld1BhdGgpO1xuICAgICAgaG9vay5tZW1vaXplZFN0YXRlID0gbmV3U3RhdGU7XG4gICAgICBob29rLmJhc2VTdGF0ZSA9IG5ld1N0YXRlOyAvLyBXZSBhcmVuJ3QgYWN0dWFsbHkgYWRkaW5nIGFuIHVwZGF0ZSB0byB0aGUgcXVldWUsXG4gICAgICAvLyBiZWNhdXNlIHRoZXJlIGlzIG5vIHVwZGF0ZSB3ZSBjYW4gYWRkIGZvciB1c2VSZWR1Y2VyIGhvb2tzIHRoYXQgd29uJ3QgdHJpZ2dlciBhbiBlcnJvci5cbiAgICAgIC8vIChUaGVyZSdzIG5vIGFwcHJvcHJpYXRlIGFjdGlvbiB0eXBlIGZvciBEZXZUb29scyBvdmVycmlkZXMuKVxuICAgICAgLy8gQXMgYSByZXN1bHQgdGhvdWdoLCBSZWFjdCB3aWxsIHNlZSB0aGUgc2NoZWR1bGVkIHVwZGF0ZSBhcyBhIG5vb3AgYW5kIGJhaWxvdXQuXG4gICAgICAvLyBTaGFsbG93IGNsb25pbmcgcHJvcHMgd29ya3MgYXMgYSB3b3JrYXJvdW5kIGZvciBub3cgdG8gYnlwYXNzIHRoZSBiYWlsb3V0IGNoZWNrLlxuXG4gICAgICBmaWJlci5tZW1vaXplZFByb3BzID0gX2Fzc2lnbih7fSwgZmliZXIubWVtb2l6ZWRQcm9wcyk7XG4gICAgICBzY2hlZHVsZVVwZGF0ZU9uRmliZXIoZmliZXIsIFN5bmNMYW5lLCBOb1RpbWVzdGFtcCk7XG4gICAgfVxuICB9OyAvLyBTdXBwb3J0IERldlRvb2xzIHByb3BzIGZvciBmdW5jdGlvbiBjb21wb25lbnRzLCBmb3J3YXJkUmVmLCBtZW1vLCBob3N0IGNvbXBvbmVudHMsIGV0Yy5cblxuXG4gIG92ZXJyaWRlUHJvcHMgPSBmdW5jdGlvbiAoZmliZXIsIHBhdGgsIHZhbHVlKSB7XG4gICAgZmliZXIucGVuZGluZ1Byb3BzID0gY29weVdpdGhTZXQoZmliZXIubWVtb2l6ZWRQcm9wcywgcGF0aCwgdmFsdWUpO1xuXG4gICAgaWYgKGZpYmVyLmFsdGVybmF0ZSkge1xuICAgICAgZmliZXIuYWx0ZXJuYXRlLnBlbmRpbmdQcm9wcyA9IGZpYmVyLnBlbmRpbmdQcm9wcztcbiAgICB9XG5cbiAgICBzY2hlZHVsZVVwZGF0ZU9uRmliZXIoZmliZXIsIFN5bmNMYW5lLCBOb1RpbWVzdGFtcCk7XG4gIH07XG5cbiAgb3ZlcnJpZGVQcm9wc0RlbGV0ZVBhdGggPSBmdW5jdGlvbiAoZmliZXIsIHBhdGgpIHtcbiAgICBmaWJlci5wZW5kaW5nUHJvcHMgPSBjb3B5V2l0aERlbGV0ZShmaWJlci5tZW1vaXplZFByb3BzLCBwYXRoKTtcblxuICAgIGlmIChmaWJlci5hbHRlcm5hdGUpIHtcbiAgICAgIGZpYmVyLmFsdGVybmF0ZS5wZW5kaW5nUHJvcHMgPSBmaWJlci5wZW5kaW5nUHJvcHM7XG4gICAgfVxuXG4gICAgc2NoZWR1bGVVcGRhdGVPbkZpYmVyKGZpYmVyLCBTeW5jTGFuZSwgTm9UaW1lc3RhbXApO1xuICB9O1xuXG4gIG92ZXJyaWRlUHJvcHNSZW5hbWVQYXRoID0gZnVuY3Rpb24gKGZpYmVyLCBvbGRQYXRoLCBuZXdQYXRoKSB7XG4gICAgZmliZXIucGVuZGluZ1Byb3BzID0gY29weVdpdGhSZW5hbWUoZmliZXIubWVtb2l6ZWRQcm9wcywgb2xkUGF0aCwgbmV3UGF0aCk7XG5cbiAgICBpZiAoZmliZXIuYWx0ZXJuYXRlKSB7XG4gICAgICBmaWJlci5hbHRlcm5hdGUucGVuZGluZ1Byb3BzID0gZmliZXIucGVuZGluZ1Byb3BzO1xuICAgIH1cblxuICAgIHNjaGVkdWxlVXBkYXRlT25GaWJlcihmaWJlciwgU3luY0xhbmUsIE5vVGltZXN0YW1wKTtcbiAgfTtcblxuICBzY2hlZHVsZVVwZGF0ZSA9IGZ1bmN0aW9uIChmaWJlcikge1xuICAgIHNjaGVkdWxlVXBkYXRlT25GaWJlcihmaWJlciwgU3luY0xhbmUsIE5vVGltZXN0YW1wKTtcbiAgfTtcblxuICBzZXRTdXNwZW5zZUhhbmRsZXIgPSBmdW5jdGlvbiAobmV3U2hvdWxkU3VzcGVuZEltcGwpIHtcbiAgICBzaG91bGRTdXNwZW5kSW1wbCA9IG5ld1Nob3VsZFN1c3BlbmRJbXBsO1xuICB9O1xufVxuXG5mdW5jdGlvbiBmaW5kSG9zdEluc3RhbmNlQnlGaWJlcihmaWJlcikge1xuICB2YXIgaG9zdEZpYmVyID0gZmluZEN1cnJlbnRIb3N0RmliZXIoZmliZXIpO1xuXG4gIGlmIChob3N0RmliZXIgPT09IG51bGwpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHJldHVybiBob3N0RmliZXIuc3RhdGVOb2RlO1xufVxuXG5mdW5jdGlvbiBlbXB0eUZpbmRGaWJlckJ5SG9zdEluc3RhbmNlKGluc3RhbmNlKSB7XG4gIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiBnZXRDdXJyZW50RmliZXJGb3JEZXZUb29scygpIHtcbiAgcmV0dXJuIGN1cnJlbnQ7XG59XG5cbmZ1bmN0aW9uIGluamVjdEludG9EZXZUb29scyhkZXZUb29sc0NvbmZpZykge1xuICB2YXIgZmluZEZpYmVyQnlIb3N0SW5zdGFuY2UgPSBkZXZUb29sc0NvbmZpZy5maW5kRmliZXJCeUhvc3RJbnN0YW5jZTtcbiAgdmFyIFJlYWN0Q3VycmVudERpc3BhdGNoZXIgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdEN1cnJlbnREaXNwYXRjaGVyO1xuICByZXR1cm4gaW5qZWN0SW50ZXJuYWxzKHtcbiAgICBidW5kbGVUeXBlOiBkZXZUb29sc0NvbmZpZy5idW5kbGVUeXBlLFxuICAgIHZlcnNpb246IGRldlRvb2xzQ29uZmlnLnZlcnNpb24sXG4gICAgcmVuZGVyZXJQYWNrYWdlTmFtZTogZGV2VG9vbHNDb25maWcucmVuZGVyZXJQYWNrYWdlTmFtZSxcbiAgICByZW5kZXJlckNvbmZpZzogZGV2VG9vbHNDb25maWcucmVuZGVyZXJDb25maWcsXG4gICAgb3ZlcnJpZGVIb29rU3RhdGU6IG92ZXJyaWRlSG9va1N0YXRlLFxuICAgIG92ZXJyaWRlSG9va1N0YXRlRGVsZXRlUGF0aDogb3ZlcnJpZGVIb29rU3RhdGVEZWxldGVQYXRoLFxuICAgIG92ZXJyaWRlSG9va1N0YXRlUmVuYW1lUGF0aDogb3ZlcnJpZGVIb29rU3RhdGVSZW5hbWVQYXRoLFxuICAgIG92ZXJyaWRlUHJvcHM6IG92ZXJyaWRlUHJvcHMsXG4gICAgb3ZlcnJpZGVQcm9wc0RlbGV0ZVBhdGg6IG92ZXJyaWRlUHJvcHNEZWxldGVQYXRoLFxuICAgIG92ZXJyaWRlUHJvcHNSZW5hbWVQYXRoOiBvdmVycmlkZVByb3BzUmVuYW1lUGF0aCxcbiAgICBzZXRTdXNwZW5zZUhhbmRsZXI6IHNldFN1c3BlbnNlSGFuZGxlcixcbiAgICBzY2hlZHVsZVVwZGF0ZTogc2NoZWR1bGVVcGRhdGUsXG4gICAgY3VycmVudERpc3BhdGNoZXJSZWY6IFJlYWN0Q3VycmVudERpc3BhdGNoZXIsXG4gICAgZmluZEhvc3RJbnN0YW5jZUJ5RmliZXI6IGZpbmRIb3N0SW5zdGFuY2VCeUZpYmVyLFxuICAgIGZpbmRGaWJlckJ5SG9zdEluc3RhbmNlOiBmaW5kRmliZXJCeUhvc3RJbnN0YW5jZSB8fCBlbXB0eUZpbmRGaWJlckJ5SG9zdEluc3RhbmNlLFxuICAgIC8vIFJlYWN0IFJlZnJlc2hcbiAgICBmaW5kSG9zdEluc3RhbmNlc0ZvclJlZnJlc2g6ICBmaW5kSG9zdEluc3RhbmNlc0ZvclJlZnJlc2ggLFxuICAgIHNjaGVkdWxlUmVmcmVzaDogIHNjaGVkdWxlUmVmcmVzaCAsXG4gICAgc2NoZWR1bGVSb290OiAgc2NoZWR1bGVSb290ICxcbiAgICBzZXRSZWZyZXNoSGFuZGxlcjogIHNldFJlZnJlc2hIYW5kbGVyICxcbiAgICAvLyBFbmFibGVzIERldlRvb2xzIHRvIGFwcGVuZCBvd25lciBzdGFja3MgdG8gZXJyb3IgbWVzc2FnZXMgaW4gREVWIG1vZGUuXG4gICAgZ2V0Q3VycmVudEZpYmVyOiAgZ2V0Q3VycmVudEZpYmVyRm9yRGV2VG9vbHMgXG4gIH0pO1xufVxuXG5mdW5jdGlvbiBSZWFjdERPTVJvb3QoY29udGFpbmVyLCBvcHRpb25zKSB7XG4gIHRoaXMuX2ludGVybmFsUm9vdCA9IGNyZWF0ZVJvb3RJbXBsKGNvbnRhaW5lciwgQ29uY3VycmVudFJvb3QsIG9wdGlvbnMpO1xufVxuXG5mdW5jdGlvbiBSZWFjdERPTUJsb2NraW5nUm9vdChjb250YWluZXIsIHRhZywgb3B0aW9ucykge1xuICB0aGlzLl9pbnRlcm5hbFJvb3QgPSBjcmVhdGVSb290SW1wbChjb250YWluZXIsIHRhZywgb3B0aW9ucyk7XG59XG5cblJlYWN0RE9NUm9vdC5wcm90b3R5cGUucmVuZGVyID0gUmVhY3RET01CbG9ja2luZ1Jvb3QucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uIChjaGlsZHJlbikge1xuICB2YXIgcm9vdCA9IHRoaXMuX2ludGVybmFsUm9vdDtcblxuICB7XG4gICAgaWYgKHR5cGVvZiBhcmd1bWVudHNbMV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGVycm9yKCdyZW5kZXIoLi4uKTogZG9lcyBub3Qgc3VwcG9ydCB0aGUgc2Vjb25kIGNhbGxiYWNrIGFyZ3VtZW50LiAnICsgJ1RvIGV4ZWN1dGUgYSBzaWRlIGVmZmVjdCBhZnRlciByZW5kZXJpbmcsIGRlY2xhcmUgaXQgaW4gYSBjb21wb25lbnQgYm9keSB3aXRoIHVzZUVmZmVjdCgpLicpO1xuICAgIH1cblxuICAgIHZhciBjb250YWluZXIgPSByb290LmNvbnRhaW5lckluZm87XG5cbiAgICBpZiAoY29udGFpbmVyLm5vZGVUeXBlICE9PSBDT01NRU5UX05PREUpIHtcbiAgICAgIHZhciBob3N0SW5zdGFuY2UgPSBmaW5kSG9zdEluc3RhbmNlV2l0aE5vUG9ydGFscyhyb290LmN1cnJlbnQpO1xuXG4gICAgICBpZiAoaG9zdEluc3RhbmNlKSB7XG4gICAgICAgIGlmIChob3N0SW5zdGFuY2UucGFyZW50Tm9kZSAhPT0gY29udGFpbmVyKSB7XG4gICAgICAgICAgZXJyb3IoJ3JlbmRlciguLi4pOiBJdCBsb29rcyBsaWtlIHRoZSBSZWFjdC1yZW5kZXJlZCBjb250ZW50IG9mIHRoZSAnICsgJ3Jvb3QgY29udGFpbmVyIHdhcyByZW1vdmVkIHdpdGhvdXQgdXNpbmcgUmVhY3QuIFRoaXMgaXMgbm90ICcgKyAnc3VwcG9ydGVkIGFuZCB3aWxsIGNhdXNlIGVycm9ycy4gSW5zdGVhZCwgY2FsbCAnICsgXCJyb290LnVubW91bnQoKSB0byBlbXB0eSBhIHJvb3QncyBjb250YWluZXIuXCIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdXBkYXRlQ29udGFpbmVyKGNoaWxkcmVuLCByb290LCBudWxsLCBudWxsKTtcbn07XG5cblJlYWN0RE9NUm9vdC5wcm90b3R5cGUudW5tb3VudCA9IFJlYWN0RE9NQmxvY2tpbmdSb290LnByb3RvdHlwZS51bm1vdW50ID0gZnVuY3Rpb24gKCkge1xuICB7XG4gICAgaWYgKHR5cGVvZiBhcmd1bWVudHNbMF0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGVycm9yKCd1bm1vdW50KC4uLik6IGRvZXMgbm90IHN1cHBvcnQgYSBjYWxsYmFjayBhcmd1bWVudC4gJyArICdUbyBleGVjdXRlIGEgc2lkZSBlZmZlY3QgYWZ0ZXIgcmVuZGVyaW5nLCBkZWNsYXJlIGl0IGluIGEgY29tcG9uZW50IGJvZHkgd2l0aCB1c2VFZmZlY3QoKS4nKTtcbiAgICB9XG4gIH1cblxuICB2YXIgcm9vdCA9IHRoaXMuX2ludGVybmFsUm9vdDtcbiAgdmFyIGNvbnRhaW5lciA9IHJvb3QuY29udGFpbmVySW5mbztcbiAgdXBkYXRlQ29udGFpbmVyKG51bGwsIHJvb3QsIG51bGwsIGZ1bmN0aW9uICgpIHtcbiAgICB1bm1hcmtDb250YWluZXJBc1Jvb3QoY29udGFpbmVyKTtcbiAgfSk7XG59O1xuXG5mdW5jdGlvbiBjcmVhdGVSb290SW1wbChjb250YWluZXIsIHRhZywgb3B0aW9ucykge1xuICAvLyBUYWcgaXMgZWl0aGVyIExlZ2FjeVJvb3Qgb3IgQ29uY3VycmVudCBSb290XG4gIHZhciBoeWRyYXRlID0gb3B0aW9ucyAhPSBudWxsICYmIG9wdGlvbnMuaHlkcmF0ZSA9PT0gdHJ1ZTtcbiAgdmFyIGh5ZHJhdGlvbkNhbGxiYWNrcyA9IG9wdGlvbnMgIT0gbnVsbCAmJiBvcHRpb25zLmh5ZHJhdGlvbk9wdGlvbnMgfHwgbnVsbDtcbiAgdmFyIG11dGFibGVTb3VyY2VzID0gb3B0aW9ucyAhPSBudWxsICYmIG9wdGlvbnMuaHlkcmF0aW9uT3B0aW9ucyAhPSBudWxsICYmIG9wdGlvbnMuaHlkcmF0aW9uT3B0aW9ucy5tdXRhYmxlU291cmNlcyB8fCBudWxsO1xuICB2YXIgcm9vdCA9IGNyZWF0ZUNvbnRhaW5lcihjb250YWluZXIsIHRhZywgaHlkcmF0ZSk7XG4gIG1hcmtDb250YWluZXJBc1Jvb3Qocm9vdC5jdXJyZW50LCBjb250YWluZXIpO1xuICB2YXIgY29udGFpbmVyTm9kZVR5cGUgPSBjb250YWluZXIubm9kZVR5cGU7XG5cbiAge1xuICAgIHZhciByb290Q29udGFpbmVyRWxlbWVudCA9IGNvbnRhaW5lci5ub2RlVHlwZSA9PT0gQ09NTUVOVF9OT0RFID8gY29udGFpbmVyLnBhcmVudE5vZGUgOiBjb250YWluZXI7XG4gICAgbGlzdGVuVG9BbGxTdXBwb3J0ZWRFdmVudHMocm9vdENvbnRhaW5lckVsZW1lbnQpO1xuICB9XG5cbiAgaWYgKG11dGFibGVTb3VyY2VzKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtdXRhYmxlU291cmNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIG11dGFibGVTb3VyY2UgPSBtdXRhYmxlU291cmNlc1tpXTtcbiAgICAgIHJlZ2lzdGVyTXV0YWJsZVNvdXJjZUZvckh5ZHJhdGlvbihyb290LCBtdXRhYmxlU291cmNlKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcm9vdDtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUxlZ2FjeVJvb3QoY29udGFpbmVyLCBvcHRpb25zKSB7XG4gIHJldHVybiBuZXcgUmVhY3RET01CbG9ja2luZ1Jvb3QoY29udGFpbmVyLCBMZWdhY3lSb290LCBvcHRpb25zKTtcbn1cbmZ1bmN0aW9uIGlzVmFsaWRDb250YWluZXIobm9kZSkge1xuICByZXR1cm4gISEobm9kZSAmJiAobm9kZS5ub2RlVHlwZSA9PT0gRUxFTUVOVF9OT0RFIHx8IG5vZGUubm9kZVR5cGUgPT09IERPQ1VNRU5UX05PREUgfHwgbm9kZS5ub2RlVHlwZSA9PT0gRE9DVU1FTlRfRlJBR01FTlRfTk9ERSB8fCBub2RlLm5vZGVUeXBlID09PSBDT01NRU5UX05PREUgJiYgbm9kZS5ub2RlVmFsdWUgPT09ICcgcmVhY3QtbW91bnQtcG9pbnQtdW5zdGFibGUgJykpO1xufVxuXG52YXIgUmVhY3RDdXJyZW50T3duZXIkMyA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0Q3VycmVudE93bmVyO1xudmFyIHRvcExldmVsVXBkYXRlV2FybmluZ3M7XG52YXIgd2FybmVkQWJvdXRIeWRyYXRlQVBJID0gZmFsc2U7XG5cbntcbiAgdG9wTGV2ZWxVcGRhdGVXYXJuaW5ncyA9IGZ1bmN0aW9uIChjb250YWluZXIpIHtcbiAgICBpZiAoY29udGFpbmVyLl9yZWFjdFJvb3RDb250YWluZXIgJiYgY29udGFpbmVyLm5vZGVUeXBlICE9PSBDT01NRU5UX05PREUpIHtcbiAgICAgIHZhciBob3N0SW5zdGFuY2UgPSBmaW5kSG9zdEluc3RhbmNlV2l0aE5vUG9ydGFscyhjb250YWluZXIuX3JlYWN0Um9vdENvbnRhaW5lci5faW50ZXJuYWxSb290LmN1cnJlbnQpO1xuXG4gICAgICBpZiAoaG9zdEluc3RhbmNlKSB7XG4gICAgICAgIGlmIChob3N0SW5zdGFuY2UucGFyZW50Tm9kZSAhPT0gY29udGFpbmVyKSB7XG4gICAgICAgICAgZXJyb3IoJ3JlbmRlciguLi4pOiBJdCBsb29rcyBsaWtlIHRoZSBSZWFjdC1yZW5kZXJlZCBjb250ZW50IG9mIHRoaXMgJyArICdjb250YWluZXIgd2FzIHJlbW92ZWQgd2l0aG91dCB1c2luZyBSZWFjdC4gVGhpcyBpcyBub3QgJyArICdzdXBwb3J0ZWQgYW5kIHdpbGwgY2F1c2UgZXJyb3JzLiBJbnN0ZWFkLCBjYWxsICcgKyAnUmVhY3RET00udW5tb3VudENvbXBvbmVudEF0Tm9kZSB0byBlbXB0eSBhIGNvbnRhaW5lci4nKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBpc1Jvb3RSZW5kZXJlZEJ5U29tZVJlYWN0ID0gISFjb250YWluZXIuX3JlYWN0Um9vdENvbnRhaW5lcjtcbiAgICB2YXIgcm9vdEVsID0gZ2V0UmVhY3RSb290RWxlbWVudEluQ29udGFpbmVyKGNvbnRhaW5lcik7XG4gICAgdmFyIGhhc05vblJvb3RSZWFjdENoaWxkID0gISEocm9vdEVsICYmIGdldEluc3RhbmNlRnJvbU5vZGUocm9vdEVsKSk7XG5cbiAgICBpZiAoaGFzTm9uUm9vdFJlYWN0Q2hpbGQgJiYgIWlzUm9vdFJlbmRlcmVkQnlTb21lUmVhY3QpIHtcbiAgICAgIGVycm9yKCdyZW5kZXIoLi4uKTogUmVwbGFjaW5nIFJlYWN0LXJlbmRlcmVkIGNoaWxkcmVuIHdpdGggYSBuZXcgcm9vdCAnICsgJ2NvbXBvbmVudC4gSWYgeW91IGludGVuZGVkIHRvIHVwZGF0ZSB0aGUgY2hpbGRyZW4gb2YgdGhpcyBub2RlLCAnICsgJ3lvdSBzaG91bGQgaW5zdGVhZCBoYXZlIHRoZSBleGlzdGluZyBjaGlsZHJlbiB1cGRhdGUgdGhlaXIgc3RhdGUgJyArICdhbmQgcmVuZGVyIHRoZSBuZXcgY29tcG9uZW50cyBpbnN0ZWFkIG9mIGNhbGxpbmcgUmVhY3RET00ucmVuZGVyLicpO1xuICAgIH1cblxuICAgIGlmIChjb250YWluZXIubm9kZVR5cGUgPT09IEVMRU1FTlRfTk9ERSAmJiBjb250YWluZXIudGFnTmFtZSAmJiBjb250YWluZXIudGFnTmFtZS50b1VwcGVyQ2FzZSgpID09PSAnQk9EWScpIHtcbiAgICAgIGVycm9yKCdyZW5kZXIoKTogUmVuZGVyaW5nIGNvbXBvbmVudHMgZGlyZWN0bHkgaW50byBkb2N1bWVudC5ib2R5IGlzICcgKyAnZGlzY291cmFnZWQsIHNpbmNlIGl0cyBjaGlsZHJlbiBhcmUgb2Z0ZW4gbWFuaXB1bGF0ZWQgYnkgdGhpcmQtcGFydHkgJyArICdzY3JpcHRzIGFuZCBicm93c2VyIGV4dGVuc2lvbnMuIFRoaXMgbWF5IGxlYWQgdG8gc3VidGxlICcgKyAncmVjb25jaWxpYXRpb24gaXNzdWVzLiBUcnkgcmVuZGVyaW5nIGludG8gYSBjb250YWluZXIgZWxlbWVudCBjcmVhdGVkICcgKyAnZm9yIHlvdXIgYXBwLicpO1xuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gZ2V0UmVhY3RSb290RWxlbWVudEluQ29udGFpbmVyKGNvbnRhaW5lcikge1xuICBpZiAoIWNvbnRhaW5lcikge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgaWYgKGNvbnRhaW5lci5ub2RlVHlwZSA9PT0gRE9DVU1FTlRfTk9ERSkge1xuICAgIHJldHVybiBjb250YWluZXIuZG9jdW1lbnRFbGVtZW50O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBjb250YWluZXIuZmlyc3RDaGlsZDtcbiAgfVxufVxuXG5mdW5jdGlvbiBzaG91bGRIeWRyYXRlRHVlVG9MZWdhY3lIZXVyaXN0aWMoY29udGFpbmVyKSB7XG4gIHZhciByb290RWxlbWVudCA9IGdldFJlYWN0Um9vdEVsZW1lbnRJbkNvbnRhaW5lcihjb250YWluZXIpO1xuICByZXR1cm4gISEocm9vdEVsZW1lbnQgJiYgcm9vdEVsZW1lbnQubm9kZVR5cGUgPT09IEVMRU1FTlRfTk9ERSAmJiByb290RWxlbWVudC5oYXNBdHRyaWJ1dGUoUk9PVF9BVFRSSUJVVEVfTkFNRSkpO1xufVxuXG5mdW5jdGlvbiBsZWdhY3lDcmVhdGVSb290RnJvbURPTUNvbnRhaW5lcihjb250YWluZXIsIGZvcmNlSHlkcmF0ZSkge1xuICB2YXIgc2hvdWxkSHlkcmF0ZSA9IGZvcmNlSHlkcmF0ZSB8fCBzaG91bGRIeWRyYXRlRHVlVG9MZWdhY3lIZXVyaXN0aWMoY29udGFpbmVyKTsgLy8gRmlyc3QgY2xlYXIgYW55IGV4aXN0aW5nIGNvbnRlbnQuXG5cbiAgaWYgKCFzaG91bGRIeWRyYXRlKSB7XG4gICAgdmFyIHdhcm5lZCA9IGZhbHNlO1xuICAgIHZhciByb290U2libGluZztcblxuICAgIHdoaWxlIChyb290U2libGluZyA9IGNvbnRhaW5lci5sYXN0Q2hpbGQpIHtcbiAgICAgIHtcbiAgICAgICAgaWYgKCF3YXJuZWQgJiYgcm9vdFNpYmxpbmcubm9kZVR5cGUgPT09IEVMRU1FTlRfTk9ERSAmJiByb290U2libGluZy5oYXNBdHRyaWJ1dGUoUk9PVF9BVFRSSUJVVEVfTkFNRSkpIHtcbiAgICAgICAgICB3YXJuZWQgPSB0cnVlO1xuXG4gICAgICAgICAgZXJyb3IoJ3JlbmRlcigpOiBUYXJnZXQgbm9kZSBoYXMgbWFya3VwIHJlbmRlcmVkIGJ5IFJlYWN0LCBidXQgdGhlcmUgJyArICdhcmUgdW5yZWxhdGVkIG5vZGVzIGFzIHdlbGwuIFRoaXMgaXMgbW9zdCBjb21tb25seSBjYXVzZWQgYnkgJyArICd3aGl0ZS1zcGFjZSBpbnNlcnRlZCBhcm91bmQgc2VydmVyLXJlbmRlcmVkIG1hcmt1cC4nKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBjb250YWluZXIucmVtb3ZlQ2hpbGQocm9vdFNpYmxpbmcpO1xuICAgIH1cbiAgfVxuXG4gIHtcbiAgICBpZiAoc2hvdWxkSHlkcmF0ZSAmJiAhZm9yY2VIeWRyYXRlICYmICF3YXJuZWRBYm91dEh5ZHJhdGVBUEkpIHtcbiAgICAgIHdhcm5lZEFib3V0SHlkcmF0ZUFQSSA9IHRydWU7XG5cbiAgICAgIHdhcm4oJ3JlbmRlcigpOiBDYWxsaW5nIFJlYWN0RE9NLnJlbmRlcigpIHRvIGh5ZHJhdGUgc2VydmVyLXJlbmRlcmVkIG1hcmt1cCAnICsgJ3dpbGwgc3RvcCB3b3JraW5nIGluIFJlYWN0IHYxOC4gUmVwbGFjZSB0aGUgUmVhY3RET00ucmVuZGVyKCkgY2FsbCAnICsgJ3dpdGggUmVhY3RET00uaHlkcmF0ZSgpIGlmIHlvdSB3YW50IFJlYWN0IHRvIGF0dGFjaCB0byB0aGUgc2VydmVyIEhUTUwuJyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGNyZWF0ZUxlZ2FjeVJvb3QoY29udGFpbmVyLCBzaG91bGRIeWRyYXRlID8ge1xuICAgIGh5ZHJhdGU6IHRydWVcbiAgfSA6IHVuZGVmaW5lZCk7XG59XG5cbmZ1bmN0aW9uIHdhcm5PbkludmFsaWRDYWxsYmFjayQxKGNhbGxiYWNrLCBjYWxsZXJOYW1lKSB7XG4gIHtcbiAgICBpZiAoY2FsbGJhY2sgIT09IG51bGwgJiYgdHlwZW9mIGNhbGxiYWNrICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICBlcnJvcignJXMoLi4uKTogRXhwZWN0ZWQgdGhlIGxhc3Qgb3B0aW9uYWwgYGNhbGxiYWNrYCBhcmd1bWVudCB0byBiZSBhICcgKyAnZnVuY3Rpb24uIEluc3RlYWQgcmVjZWl2ZWQ6ICVzLicsIGNhbGxlck5hbWUsIGNhbGxiYWNrKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gbGVnYWN5UmVuZGVyU3VidHJlZUludG9Db250YWluZXIocGFyZW50Q29tcG9uZW50LCBjaGlsZHJlbiwgY29udGFpbmVyLCBmb3JjZUh5ZHJhdGUsIGNhbGxiYWNrKSB7XG4gIHtcbiAgICB0b3BMZXZlbFVwZGF0ZVdhcm5pbmdzKGNvbnRhaW5lcik7XG4gICAgd2Fybk9uSW52YWxpZENhbGxiYWNrJDEoY2FsbGJhY2sgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBjYWxsYmFjaywgJ3JlbmRlcicpO1xuICB9IC8vIFRPRE86IFdpdGhvdXQgYGFueWAgdHlwZSwgRmxvdyBzYXlzIFwiUHJvcGVydHkgY2Fubm90IGJlIGFjY2Vzc2VkIG9uIGFueVxuICAvLyBtZW1iZXIgb2YgaW50ZXJzZWN0aW9uIHR5cGUuXCIgV2h5eXl5eXkuXG5cblxuICB2YXIgcm9vdCA9IGNvbnRhaW5lci5fcmVhY3RSb290Q29udGFpbmVyO1xuICB2YXIgZmliZXJSb290O1xuXG4gIGlmICghcm9vdCkge1xuICAgIC8vIEluaXRpYWwgbW91bnRcbiAgICByb290ID0gY29udGFpbmVyLl9yZWFjdFJvb3RDb250YWluZXIgPSBsZWdhY3lDcmVhdGVSb290RnJvbURPTUNvbnRhaW5lcihjb250YWluZXIsIGZvcmNlSHlkcmF0ZSk7XG4gICAgZmliZXJSb290ID0gcm9vdC5faW50ZXJuYWxSb290O1xuXG4gICAgaWYgKHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdmFyIG9yaWdpbmFsQ2FsbGJhY2sgPSBjYWxsYmFjaztcblxuICAgICAgY2FsbGJhY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBpbnN0YW5jZSA9IGdldFB1YmxpY1Jvb3RJbnN0YW5jZShmaWJlclJvb3QpO1xuICAgICAgICBvcmlnaW5hbENhbGxiYWNrLmNhbGwoaW5zdGFuY2UpO1xuICAgICAgfTtcbiAgICB9IC8vIEluaXRpYWwgbW91bnQgc2hvdWxkIG5vdCBiZSBiYXRjaGVkLlxuXG5cbiAgICB1bmJhdGNoZWRVcGRhdGVzKGZ1bmN0aW9uICgpIHtcbiAgICAgIHVwZGF0ZUNvbnRhaW5lcihjaGlsZHJlbiwgZmliZXJSb290LCBwYXJlbnRDb21wb25lbnQsIGNhbGxiYWNrKTtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBmaWJlclJvb3QgPSByb290Ll9pbnRlcm5hbFJvb3Q7XG5cbiAgICBpZiAodHlwZW9mIGNhbGxiYWNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB2YXIgX29yaWdpbmFsQ2FsbGJhY2sgPSBjYWxsYmFjaztcblxuICAgICAgY2FsbGJhY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBpbnN0YW5jZSA9IGdldFB1YmxpY1Jvb3RJbnN0YW5jZShmaWJlclJvb3QpO1xuXG4gICAgICAgIF9vcmlnaW5hbENhbGxiYWNrLmNhbGwoaW5zdGFuY2UpO1xuICAgICAgfTtcbiAgICB9IC8vIFVwZGF0ZVxuXG5cbiAgICB1cGRhdGVDb250YWluZXIoY2hpbGRyZW4sIGZpYmVyUm9vdCwgcGFyZW50Q29tcG9uZW50LCBjYWxsYmFjayk7XG4gIH1cblxuICByZXR1cm4gZ2V0UHVibGljUm9vdEluc3RhbmNlKGZpYmVyUm9vdCk7XG59XG5cbmZ1bmN0aW9uIGZpbmRET01Ob2RlKGNvbXBvbmVudE9yRWxlbWVudCkge1xuICB7XG4gICAgdmFyIG93bmVyID0gUmVhY3RDdXJyZW50T3duZXIkMy5jdXJyZW50O1xuXG4gICAgaWYgKG93bmVyICE9PSBudWxsICYmIG93bmVyLnN0YXRlTm9kZSAhPT0gbnVsbCkge1xuICAgICAgdmFyIHdhcm5lZEFib3V0UmVmc0luUmVuZGVyID0gb3duZXIuc3RhdGVOb2RlLl93YXJuZWRBYm91dFJlZnNJblJlbmRlcjtcblxuICAgICAgaWYgKCF3YXJuZWRBYm91dFJlZnNJblJlbmRlcikge1xuICAgICAgICBlcnJvcignJXMgaXMgYWNjZXNzaW5nIGZpbmRET01Ob2RlIGluc2lkZSBpdHMgcmVuZGVyKCkuICcgKyAncmVuZGVyKCkgc2hvdWxkIGJlIGEgcHVyZSBmdW5jdGlvbiBvZiBwcm9wcyBhbmQgc3RhdGUuIEl0IHNob3VsZCAnICsgJ25ldmVyIGFjY2VzcyBzb21ldGhpbmcgdGhhdCByZXF1aXJlcyBzdGFsZSBkYXRhIGZyb20gdGhlIHByZXZpb3VzICcgKyAncmVuZGVyLCBzdWNoIGFzIHJlZnMuIE1vdmUgdGhpcyBsb2dpYyB0byBjb21wb25lbnREaWRNb3VudCBhbmQgJyArICdjb21wb25lbnREaWRVcGRhdGUgaW5zdGVhZC4nLCBnZXRDb21wb25lbnROYW1lKG93bmVyLnR5cGUpIHx8ICdBIGNvbXBvbmVudCcpO1xuICAgICAgfVxuXG4gICAgICBvd25lci5zdGF0ZU5vZGUuX3dhcm5lZEFib3V0UmVmc0luUmVuZGVyID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICBpZiAoY29tcG9uZW50T3JFbGVtZW50ID09IG51bGwpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGlmIChjb21wb25lbnRPckVsZW1lbnQubm9kZVR5cGUgPT09IEVMRU1FTlRfTk9ERSkge1xuICAgIHJldHVybiBjb21wb25lbnRPckVsZW1lbnQ7XG4gIH1cblxuICB7XG4gICAgcmV0dXJuIGZpbmRIb3N0SW5zdGFuY2VXaXRoV2FybmluZyhjb21wb25lbnRPckVsZW1lbnQsICdmaW5kRE9NTm9kZScpO1xuICB9XG59XG5mdW5jdGlvbiBoeWRyYXRlKGVsZW1lbnQsIGNvbnRhaW5lciwgY2FsbGJhY2spIHtcbiAgaWYgKCFpc1ZhbGlkQ29udGFpbmVyKGNvbnRhaW5lcikpIHtcbiAgICB7XG4gICAgICB0aHJvdyBFcnJvciggXCJUYXJnZXQgY29udGFpbmVyIGlzIG5vdCBhIERPTSBlbGVtZW50LlwiICk7XG4gICAgfVxuICB9XG5cbiAge1xuICAgIHZhciBpc01vZGVyblJvb3QgPSBpc0NvbnRhaW5lck1hcmtlZEFzUm9vdChjb250YWluZXIpICYmIGNvbnRhaW5lci5fcmVhY3RSb290Q29udGFpbmVyID09PSB1bmRlZmluZWQ7XG5cbiAgICBpZiAoaXNNb2Rlcm5Sb290KSB7XG4gICAgICBlcnJvcignWW91IGFyZSBjYWxsaW5nIFJlYWN0RE9NLmh5ZHJhdGUoKSBvbiBhIGNvbnRhaW5lciB0aGF0IHdhcyBwcmV2aW91c2x5ICcgKyAncGFzc2VkIHRvIFJlYWN0RE9NLmNyZWF0ZVJvb3QoKS4gVGhpcyBpcyBub3Qgc3VwcG9ydGVkLiAnICsgJ0RpZCB5b3UgbWVhbiB0byBjYWxsIGNyZWF0ZVJvb3QoY29udGFpbmVyLCB7aHlkcmF0ZTogdHJ1ZX0pLnJlbmRlcihlbGVtZW50KT8nKTtcbiAgICB9XG4gIH0gLy8gVE9ETzogdGhyb3cgb3Igd2FybiBpZiB3ZSBjb3VsZG4ndCBoeWRyYXRlP1xuXG5cbiAgcmV0dXJuIGxlZ2FjeVJlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyKG51bGwsIGVsZW1lbnQsIGNvbnRhaW5lciwgdHJ1ZSwgY2FsbGJhY2spO1xufVxuZnVuY3Rpb24gcmVuZGVyKGVsZW1lbnQsIGNvbnRhaW5lciwgY2FsbGJhY2spIHtcbiAgaWYgKCFpc1ZhbGlkQ29udGFpbmVyKGNvbnRhaW5lcikpIHtcbiAgICB7XG4gICAgICB0aHJvdyBFcnJvciggXCJUYXJnZXQgY29udGFpbmVyIGlzIG5vdCBhIERPTSBlbGVtZW50LlwiICk7XG4gICAgfVxuICB9XG5cbiAge1xuICAgIHZhciBpc01vZGVyblJvb3QgPSBpc0NvbnRhaW5lck1hcmtlZEFzUm9vdChjb250YWluZXIpICYmIGNvbnRhaW5lci5fcmVhY3RSb290Q29udGFpbmVyID09PSB1bmRlZmluZWQ7XG5cbiAgICBpZiAoaXNNb2Rlcm5Sb290KSB7XG4gICAgICBlcnJvcignWW91IGFyZSBjYWxsaW5nIFJlYWN0RE9NLnJlbmRlcigpIG9uIGEgY29udGFpbmVyIHRoYXQgd2FzIHByZXZpb3VzbHkgJyArICdwYXNzZWQgdG8gUmVhY3RET00uY3JlYXRlUm9vdCgpLiBUaGlzIGlzIG5vdCBzdXBwb3J0ZWQuICcgKyAnRGlkIHlvdSBtZWFuIHRvIGNhbGwgcm9vdC5yZW5kZXIoZWxlbWVudCk/Jyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGxlZ2FjeVJlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyKG51bGwsIGVsZW1lbnQsIGNvbnRhaW5lciwgZmFsc2UsIGNhbGxiYWNrKTtcbn1cbmZ1bmN0aW9uIHVuc3RhYmxlX3JlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyKHBhcmVudENvbXBvbmVudCwgZWxlbWVudCwgY29udGFpbmVyTm9kZSwgY2FsbGJhY2spIHtcbiAgaWYgKCFpc1ZhbGlkQ29udGFpbmVyKGNvbnRhaW5lck5vZGUpKSB7XG4gICAge1xuICAgICAgdGhyb3cgRXJyb3IoIFwiVGFyZ2V0IGNvbnRhaW5lciBpcyBub3QgYSBET00gZWxlbWVudC5cIiApO1xuICAgIH1cbiAgfVxuXG4gIGlmICghKHBhcmVudENvbXBvbmVudCAhPSBudWxsICYmIGhhcyhwYXJlbnRDb21wb25lbnQpKSkge1xuICAgIHtcbiAgICAgIHRocm93IEVycm9yKCBcInBhcmVudENvbXBvbmVudCBtdXN0IGJlIGEgdmFsaWQgUmVhY3QgQ29tcG9uZW50XCIgKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbGVnYWN5UmVuZGVyU3VidHJlZUludG9Db250YWluZXIocGFyZW50Q29tcG9uZW50LCBlbGVtZW50LCBjb250YWluZXJOb2RlLCBmYWxzZSwgY2FsbGJhY2spO1xufVxuZnVuY3Rpb24gdW5tb3VudENvbXBvbmVudEF0Tm9kZShjb250YWluZXIpIHtcbiAgaWYgKCFpc1ZhbGlkQ29udGFpbmVyKGNvbnRhaW5lcikpIHtcbiAgICB7XG4gICAgICB0aHJvdyBFcnJvciggXCJ1bm1vdW50Q29tcG9uZW50QXROb2RlKC4uLik6IFRhcmdldCBjb250YWluZXIgaXMgbm90IGEgRE9NIGVsZW1lbnQuXCIgKTtcbiAgICB9XG4gIH1cblxuICB7XG4gICAgdmFyIGlzTW9kZXJuUm9vdCA9IGlzQ29udGFpbmVyTWFya2VkQXNSb290KGNvbnRhaW5lcikgJiYgY29udGFpbmVyLl9yZWFjdFJvb3RDb250YWluZXIgPT09IHVuZGVmaW5lZDtcblxuICAgIGlmIChpc01vZGVyblJvb3QpIHtcbiAgICAgIGVycm9yKCdZb3UgYXJlIGNhbGxpbmcgUmVhY3RET00udW5tb3VudENvbXBvbmVudEF0Tm9kZSgpIG9uIGEgY29udGFpbmVyIHRoYXQgd2FzIHByZXZpb3VzbHkgJyArICdwYXNzZWQgdG8gUmVhY3RET00uY3JlYXRlUm9vdCgpLiBUaGlzIGlzIG5vdCBzdXBwb3J0ZWQuIERpZCB5b3UgbWVhbiB0byBjYWxsIHJvb3QudW5tb3VudCgpPycpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChjb250YWluZXIuX3JlYWN0Um9vdENvbnRhaW5lcikge1xuICAgIHtcbiAgICAgIHZhciByb290RWwgPSBnZXRSZWFjdFJvb3RFbGVtZW50SW5Db250YWluZXIoY29udGFpbmVyKTtcbiAgICAgIHZhciByZW5kZXJlZEJ5RGlmZmVyZW50UmVhY3QgPSByb290RWwgJiYgIWdldEluc3RhbmNlRnJvbU5vZGUocm9vdEVsKTtcblxuICAgICAgaWYgKHJlbmRlcmVkQnlEaWZmZXJlbnRSZWFjdCkge1xuICAgICAgICBlcnJvcihcInVubW91bnRDb21wb25lbnRBdE5vZGUoKTogVGhlIG5vZGUgeW91J3JlIGF0dGVtcHRpbmcgdG8gdW5tb3VudCBcIiArICd3YXMgcmVuZGVyZWQgYnkgYW5vdGhlciBjb3B5IG9mIFJlYWN0LicpO1xuICAgICAgfVxuICAgIH0gLy8gVW5tb3VudCBzaG91bGQgbm90IGJlIGJhdGNoZWQuXG5cblxuICAgIHVuYmF0Y2hlZFVwZGF0ZXMoZnVuY3Rpb24gKCkge1xuICAgICAgbGVnYWN5UmVuZGVyU3VidHJlZUludG9Db250YWluZXIobnVsbCwgbnVsbCwgY29udGFpbmVyLCBmYWxzZSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyAkRmxvd0ZpeE1lIFRoaXMgc2hvdWxkIHByb2JhYmx5IHVzZSBgZGVsZXRlIGNvbnRhaW5lci5fcmVhY3RSb290Q29udGFpbmVyYFxuICAgICAgICBjb250YWluZXIuX3JlYWN0Um9vdENvbnRhaW5lciA9IG51bGw7XG4gICAgICAgIHVubWFya0NvbnRhaW5lckFzUm9vdChjb250YWluZXIpO1xuICAgICAgfSk7XG4gICAgfSk7IC8vIElmIHlvdSBjYWxsIHVubW91bnRDb21wb25lbnRBdE5vZGUgdHdpY2UgaW4gcXVpY2sgc3VjY2Vzc2lvbiwgeW91J2xsXG4gICAgLy8gZ2V0IGB0cnVlYCB0d2ljZS4gVGhhdCdzIHByb2JhYmx5IGZpbmU/XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBlbHNlIHtcbiAgICB7XG4gICAgICB2YXIgX3Jvb3RFbCA9IGdldFJlYWN0Um9vdEVsZW1lbnRJbkNvbnRhaW5lcihjb250YWluZXIpO1xuXG4gICAgICB2YXIgaGFzTm9uUm9vdFJlYWN0Q2hpbGQgPSAhIShfcm9vdEVsICYmIGdldEluc3RhbmNlRnJvbU5vZGUoX3Jvb3RFbCkpOyAvLyBDaGVjayBpZiB0aGUgY29udGFpbmVyIGl0c2VsZiBpcyBhIFJlYWN0IHJvb3Qgbm9kZS5cblxuICAgICAgdmFyIGlzQ29udGFpbmVyUmVhY3RSb290ID0gY29udGFpbmVyLm5vZGVUeXBlID09PSBFTEVNRU5UX05PREUgJiYgaXNWYWxpZENvbnRhaW5lcihjb250YWluZXIucGFyZW50Tm9kZSkgJiYgISFjb250YWluZXIucGFyZW50Tm9kZS5fcmVhY3RSb290Q29udGFpbmVyO1xuXG4gICAgICBpZiAoaGFzTm9uUm9vdFJlYWN0Q2hpbGQpIHtcbiAgICAgICAgZXJyb3IoXCJ1bm1vdW50Q29tcG9uZW50QXROb2RlKCk6IFRoZSBub2RlIHlvdSdyZSBhdHRlbXB0aW5nIHRvIHVubW91bnQgXCIgKyAnd2FzIHJlbmRlcmVkIGJ5IFJlYWN0IGFuZCBpcyBub3QgYSB0b3AtbGV2ZWwgY29udGFpbmVyLiAlcycsIGlzQ29udGFpbmVyUmVhY3RSb290ID8gJ1lvdSBtYXkgaGF2ZSBhY2NpZGVudGFsbHkgcGFzc2VkIGluIGEgUmVhY3Qgcm9vdCBub2RlIGluc3RlYWQgJyArICdvZiBpdHMgY29udGFpbmVyLicgOiAnSW5zdGVhZCwgaGF2ZSB0aGUgcGFyZW50IGNvbXBvbmVudCB1cGRhdGUgaXRzIHN0YXRlIGFuZCAnICsgJ3JlcmVuZGVyIGluIG9yZGVyIHRvIHJlbW92ZSB0aGlzIGNvbXBvbmVudC4nKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuc2V0QXR0ZW1wdFVzZXJCbG9ja2luZ0h5ZHJhdGlvbihhdHRlbXB0VXNlckJsb2NraW5nSHlkcmF0aW9uJDEpO1xuc2V0QXR0ZW1wdENvbnRpbnVvdXNIeWRyYXRpb24oYXR0ZW1wdENvbnRpbnVvdXNIeWRyYXRpb24kMSk7XG5zZXRBdHRlbXB0SHlkcmF0aW9uQXRDdXJyZW50UHJpb3JpdHkoYXR0ZW1wdEh5ZHJhdGlvbkF0Q3VycmVudFByaW9yaXR5JDEpO1xuc2V0QXR0ZW1wdEh5ZHJhdGlvbkF0UHJpb3JpdHkocnVuV2l0aFByaW9yaXR5JDIpO1xudmFyIGRpZFdhcm5BYm91dFVuc3RhYmxlQ3JlYXRlUG9ydGFsID0gZmFsc2U7XG5cbntcbiAgaWYgKHR5cGVvZiBNYXAgIT09ICdmdW5jdGlvbicgfHwgLy8gJEZsb3dJc3N1ZSBGbG93IGluY29ycmVjdGx5IHRoaW5rcyBNYXAgaGFzIG5vIHByb3RvdHlwZVxuICBNYXAucHJvdG90eXBlID09IG51bGwgfHwgdHlwZW9mIE1hcC5wcm90b3R5cGUuZm9yRWFjaCAhPT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgU2V0ICE9PSAnZnVuY3Rpb24nIHx8IC8vICRGbG93SXNzdWUgRmxvdyBpbmNvcnJlY3RseSB0aGlua3MgU2V0IGhhcyBubyBwcm90b3R5cGVcbiAgU2V0LnByb3RvdHlwZSA9PSBudWxsIHx8IHR5cGVvZiBTZXQucHJvdG90eXBlLmNsZWFyICE9PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBTZXQucHJvdG90eXBlLmZvckVhY2ggIT09ICdmdW5jdGlvbicpIHtcbiAgICBlcnJvcignUmVhY3QgZGVwZW5kcyBvbiBNYXAgYW5kIFNldCBidWlsdC1pbiB0eXBlcy4gTWFrZSBzdXJlIHRoYXQgeW91IGxvYWQgYSAnICsgJ3BvbHlmaWxsIGluIG9sZGVyIGJyb3dzZXJzLiBodHRwczovL3JlYWN0anMub3JnL2xpbmsvcmVhY3QtcG9seWZpbGxzJyk7XG4gIH1cbn1cblxuc2V0UmVzdG9yZUltcGxlbWVudGF0aW9uKHJlc3RvcmVDb250cm9sbGVkU3RhdGUkMyk7XG5zZXRCYXRjaGluZ0ltcGxlbWVudGF0aW9uKGJhdGNoZWRVcGRhdGVzJDEsIGRpc2NyZXRlVXBkYXRlcyQxLCBmbHVzaERpc2NyZXRlVXBkYXRlcywgYmF0Y2hlZEV2ZW50VXBkYXRlcyQxKTtcblxuZnVuY3Rpb24gY3JlYXRlUG9ydGFsJDEoY2hpbGRyZW4sIGNvbnRhaW5lcikge1xuICB2YXIga2V5ID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBudWxsO1xuXG4gIGlmICghaXNWYWxpZENvbnRhaW5lcihjb250YWluZXIpKSB7XG4gICAge1xuICAgICAgdGhyb3cgRXJyb3IoIFwiVGFyZ2V0IGNvbnRhaW5lciBpcyBub3QgYSBET00gZWxlbWVudC5cIiApO1xuICAgIH1cbiAgfSAvLyBUT0RPOiBwYXNzIFJlYWN0RE9NIHBvcnRhbCBpbXBsZW1lbnRhdGlvbiBhcyB0aGlyZCBhcmd1bWVudFxuICAvLyAkRmxvd0ZpeE1lIFRoZSBGbG93IHR5cGUgaXMgb3BhcXVlIGJ1dCB0aGVyZSdzIG5vIHdheSB0byBhY3R1YWxseSBjcmVhdGUgaXQuXG5cblxuICByZXR1cm4gY3JlYXRlUG9ydGFsKGNoaWxkcmVuLCBjb250YWluZXIsIG51bGwsIGtleSk7XG59XG5cbmZ1bmN0aW9uIHJlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyKHBhcmVudENvbXBvbmVudCwgZWxlbWVudCwgY29udGFpbmVyTm9kZSwgY2FsbGJhY2spIHtcblxuICByZXR1cm4gdW5zdGFibGVfcmVuZGVyU3VidHJlZUludG9Db250YWluZXIocGFyZW50Q29tcG9uZW50LCBlbGVtZW50LCBjb250YWluZXJOb2RlLCBjYWxsYmFjayk7XG59XG5cbmZ1bmN0aW9uIHVuc3RhYmxlX2NyZWF0ZVBvcnRhbChjaGlsZHJlbiwgY29udGFpbmVyKSB7XG4gIHZhciBrZXkgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IG51bGw7XG5cbiAge1xuICAgIGlmICghZGlkV2FybkFib3V0VW5zdGFibGVDcmVhdGVQb3J0YWwpIHtcbiAgICAgIGRpZFdhcm5BYm91dFVuc3RhYmxlQ3JlYXRlUG9ydGFsID0gdHJ1ZTtcblxuICAgICAgd2FybignVGhlIFJlYWN0RE9NLnVuc3RhYmxlX2NyZWF0ZVBvcnRhbCgpIGFsaWFzIGhhcyBiZWVuIGRlcHJlY2F0ZWQsICcgKyAnYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiBSZWFjdCAxOCsuIFVwZGF0ZSB5b3VyIGNvZGUgdG8gdXNlICcgKyAnUmVhY3RET00uY3JlYXRlUG9ydGFsKCkgaW5zdGVhZC4gSXQgaGFzIHRoZSBleGFjdCBzYW1lIEFQSSwgJyArICdidXQgd2l0aG91dCB0aGUgXCJ1bnN0YWJsZV9cIiBwcmVmaXguJyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGNyZWF0ZVBvcnRhbCQxKGNoaWxkcmVuLCBjb250YWluZXIsIGtleSk7XG59XG5cbnZhciBJbnRlcm5hbHMgPSB7XG4gIC8vIEtlZXAgaW4gc3luYyB3aXRoIFJlYWN0VGVzdFV0aWxzLmpzLCBhbmQgUmVhY3RUZXN0VXRpbHNBY3QuanMuXG4gIC8vIFRoaXMgaXMgYW4gYXJyYXkgZm9yIGJldHRlciBtaW5pZmljYXRpb24uXG4gIEV2ZW50czogW2dldEluc3RhbmNlRnJvbU5vZGUsIGdldE5vZGVGcm9tSW5zdGFuY2UsIGdldEZpYmVyQ3VycmVudFByb3BzRnJvbU5vZGUsIGVucXVldWVTdGF0ZVJlc3RvcmUsIHJlc3RvcmVTdGF0ZUlmTmVlZGVkLCBmbHVzaFBhc3NpdmVFZmZlY3RzLCAvLyBUT0RPOiBUaGlzIGlzIHJlbGF0ZWQgdG8gYGFjdGAsIG5vdCBldmVudHMuIE1vdmUgdG8gc2VwYXJhdGUga2V5P1xuICBJc1RoaXNSZW5kZXJlckFjdGluZ11cbn07XG52YXIgZm91bmREZXZUb29scyA9IGluamVjdEludG9EZXZUb29scyh7XG4gIGZpbmRGaWJlckJ5SG9zdEluc3RhbmNlOiBnZXRDbG9zZXN0SW5zdGFuY2VGcm9tTm9kZSxcbiAgYnVuZGxlVHlwZTogIDEgLFxuICB2ZXJzaW9uOiBSZWFjdFZlcnNpb24sXG4gIHJlbmRlcmVyUGFja2FnZU5hbWU6ICdyZWFjdC1kb20nXG59KTtcblxue1xuICBpZiAoIWZvdW5kRGV2VG9vbHMgJiYgY2FuVXNlRE9NICYmIHdpbmRvdy50b3AgPT09IHdpbmRvdy5zZWxmKSB7XG4gICAgLy8gSWYgd2UncmUgaW4gQ2hyb21lIG9yIEZpcmVmb3gsIHByb3ZpZGUgYSBkb3dubG9hZCBsaW5rIGlmIG5vdCBpbnN0YWxsZWQuXG4gICAgaWYgKG5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZignQ2hyb21lJykgPiAtMSAmJiBuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoJ0VkZ2UnKSA9PT0gLTEgfHwgbmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKCdGaXJlZm94JykgPiAtMSkge1xuICAgICAgdmFyIHByb3RvY29sID0gd2luZG93LmxvY2F0aW9uLnByb3RvY29sOyAvLyBEb24ndCB3YXJuIGluIGV4b3RpYyBjYXNlcyBsaWtlIGNocm9tZS1leHRlbnNpb246Ly8uXG5cbiAgICAgIGlmICgvXihodHRwcz98ZmlsZSk6JC8udGVzdChwcm90b2NvbCkpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZ1xuICAgICAgICBjb25zb2xlLmluZm8oJyVjRG93bmxvYWQgdGhlIFJlYWN0IERldlRvb2xzICcgKyAnZm9yIGEgYmV0dGVyIGRldmVsb3BtZW50IGV4cGVyaWVuY2U6ICcgKyAnaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3JlYWN0LWRldnRvb2xzJyArIChwcm90b2NvbCA9PT0gJ2ZpbGU6JyA/ICdcXG5Zb3UgbWlnaHQgbmVlZCB0byB1c2UgYSBsb2NhbCBIVFRQIHNlcnZlciAoaW5zdGVhZCBvZiBmaWxlOi8vKTogJyArICdodHRwczovL3JlYWN0anMub3JnL2xpbmsvcmVhY3QtZGV2dG9vbHMtZmFxJyA6ICcnKSwgJ2ZvbnQtd2VpZ2h0OmJvbGQnKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0cy5fX1NFQ1JFVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRCA9IEludGVybmFscztcbmV4cG9ydHMuY3JlYXRlUG9ydGFsID0gY3JlYXRlUG9ydGFsJDE7XG5leHBvcnRzLmZpbmRET01Ob2RlID0gZmluZERPTU5vZGU7XG5leHBvcnRzLmZsdXNoU3luYyA9IGZsdXNoU3luYztcbmV4cG9ydHMuaHlkcmF0ZSA9IGh5ZHJhdGU7XG5leHBvcnRzLnJlbmRlciA9IHJlbmRlcjtcbmV4cG9ydHMudW5tb3VudENvbXBvbmVudEF0Tm9kZSA9IHVubW91bnRDb21wb25lbnRBdE5vZGU7XG5leHBvcnRzLnVuc3RhYmxlX2JhdGNoZWRVcGRhdGVzID0gYmF0Y2hlZFVwZGF0ZXMkMTtcbmV4cG9ydHMudW5zdGFibGVfY3JlYXRlUG9ydGFsID0gdW5zdGFibGVfY3JlYXRlUG9ydGFsO1xuZXhwb3J0cy51bnN0YWJsZV9yZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lciA9IHJlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyO1xuZXhwb3J0cy52ZXJzaW9uID0gUmVhY3RWZXJzaW9uO1xuICB9KSgpO1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBjaGVja0RDRSgpIHtcbiAgLyogZ2xvYmFsIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXyAqL1xuICBpZiAoXG4gICAgdHlwZW9mIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXyA9PT0gJ3VuZGVmaW5lZCcgfHxcbiAgICB0eXBlb2YgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fLmNoZWNrRENFICE9PSAnZnVuY3Rpb24nXG4gICkge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIC8vIFRoaXMgYnJhbmNoIGlzIHVucmVhY2hhYmxlIGJlY2F1c2UgdGhpcyBmdW5jdGlvbiBpcyBvbmx5IGNhbGxlZFxuICAgIC8vIGluIHByb2R1Y3Rpb24sIGJ1dCB0aGUgY29uZGl0aW9uIGlzIHRydWUgb25seSBpbiBkZXZlbG9wbWVudC5cbiAgICAvLyBUaGVyZWZvcmUgaWYgdGhlIGJyYW5jaCBpcyBzdGlsbCBoZXJlLCBkZWFkIGNvZGUgZWxpbWluYXRpb24gd2Fzbid0XG4gICAgLy8gcHJvcGVybHkgYXBwbGllZC5cbiAgICAvLyBEb24ndCBjaGFuZ2UgdGhlIG1lc3NhZ2UuIFJlYWN0IERldlRvb2xzIHJlbGllcyBvbiBpdC4gQWxzbyBtYWtlIHN1cmVcbiAgICAvLyB0aGlzIG1lc3NhZ2UgZG9lc24ndCBvY2N1ciBlbHNld2hlcmUgaW4gdGhpcyBmdW5jdGlvbiwgb3IgaXQgd2lsbCBjYXVzZVxuICAgIC8vIGEgZmFsc2UgcG9zaXRpdmUuXG4gICAgdGhyb3cgbmV3IEVycm9yKCdeX14nKTtcbiAgfVxuICB0cnkge1xuICAgIC8vIFZlcmlmeSB0aGF0IHRoZSBjb2RlIGFib3ZlIGhhcyBiZWVuIGRlYWQgY29kZSBlbGltaW5hdGVkIChEQ0UnZCkuXG4gICAgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fLmNoZWNrRENFKGNoZWNrRENFKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgLy8gRGV2VG9vbHMgc2hvdWxkbid0IGNyYXNoIFJlYWN0LCBubyBtYXR0ZXIgd2hhdC5cbiAgICAvLyBXZSBzaG91bGQgc3RpbGwgcmVwb3J0IGluIGNhc2Ugd2UgYnJlYWsgdGhpcyBjb2RlLlxuICAgIGNvbnNvbGUuZXJyb3IoZXJyKTtcbiAgfVxufVxuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJykge1xuICAvLyBEQ0UgY2hlY2sgc2hvdWxkIGhhcHBlbiBiZWZvcmUgUmVhY3RET00gYnVuZGxlIGV4ZWN1dGVzIHNvIHRoYXRcbiAgLy8gRGV2VG9vbHMgY2FuIHJlcG9ydCBiYWQgbWluaWZpY2F0aW9uIGR1cmluZyBpbmplY3Rpb24uXG4gIGNoZWNrRENFKCk7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtZG9tLnByb2R1Y3Rpb24ubWluLmpzJyk7XG59IGVsc2Uge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3JlYWN0LWRvbS5kZXZlbG9wbWVudC5qcycpO1xufVxuIiwiLyoqIEBsaWNlbnNlIFJlYWN0IHYxNy4wLjJcbiAqIHJlYWN0LmRldmVsb3BtZW50LmpzXG4gKlxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gIChmdW5jdGlvbigpIHtcbid1c2Ugc3RyaWN0JztcblxudmFyIF9hc3NpZ24gPSByZXF1aXJlKCdvYmplY3QtYXNzaWduJyk7XG5cbi8vIFRPRE86IHRoaXMgaXMgc3BlY2lhbCBiZWNhdXNlIGl0IGdldHMgaW1wb3J0ZWQgZHVyaW5nIGJ1aWxkLlxudmFyIFJlYWN0VmVyc2lvbiA9ICcxNy4wLjInO1xuXG4vLyBBVFRFTlRJT05cbi8vIFdoZW4gYWRkaW5nIG5ldyBzeW1ib2xzIHRvIHRoaXMgZmlsZSxcbi8vIFBsZWFzZSBjb25zaWRlciBhbHNvIGFkZGluZyB0byAncmVhY3QtZGV2dG9vbHMtc2hhcmVkL3NyYy9iYWNrZW5kL1JlYWN0U3ltYm9scydcbi8vIFRoZSBTeW1ib2wgdXNlZCB0byB0YWcgdGhlIFJlYWN0RWxlbWVudC1saWtlIHR5cGVzLiBJZiB0aGVyZSBpcyBubyBuYXRpdmUgU3ltYm9sXG4vLyBub3IgcG9seWZpbGwsIHRoZW4gYSBwbGFpbiBudW1iZXIgaXMgdXNlZCBmb3IgcGVyZm9ybWFuY2UuXG52YXIgUkVBQ1RfRUxFTUVOVF9UWVBFID0gMHhlYWM3O1xudmFyIFJFQUNUX1BPUlRBTF9UWVBFID0gMHhlYWNhO1xuZXhwb3J0cy5GcmFnbWVudCA9IDB4ZWFjYjtcbmV4cG9ydHMuU3RyaWN0TW9kZSA9IDB4ZWFjYztcbmV4cG9ydHMuUHJvZmlsZXIgPSAweGVhZDI7XG52YXIgUkVBQ1RfUFJPVklERVJfVFlQRSA9IDB4ZWFjZDtcbnZhciBSRUFDVF9DT05URVhUX1RZUEUgPSAweGVhY2U7XG52YXIgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSA9IDB4ZWFkMDtcbmV4cG9ydHMuU3VzcGVuc2UgPSAweGVhZDE7XG52YXIgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFID0gMHhlYWQ4O1xudmFyIFJFQUNUX01FTU9fVFlQRSA9IDB4ZWFkMztcbnZhciBSRUFDVF9MQVpZX1RZUEUgPSAweGVhZDQ7XG52YXIgUkVBQ1RfQkxPQ0tfVFlQRSA9IDB4ZWFkOTtcbnZhciBSRUFDVF9TRVJWRVJfQkxPQ0tfVFlQRSA9IDB4ZWFkYTtcbnZhciBSRUFDVF9GVU5EQU1FTlRBTF9UWVBFID0gMHhlYWQ1O1xudmFyIFJFQUNUX1NDT1BFX1RZUEUgPSAweGVhZDc7XG52YXIgUkVBQ1RfT1BBUVVFX0lEX1RZUEUgPSAweGVhZTA7XG52YXIgUkVBQ1RfREVCVUdfVFJBQ0lOR19NT0RFX1RZUEUgPSAweGVhZTE7XG52YXIgUkVBQ1RfT0ZGU0NSRUVOX1RZUEUgPSAweGVhZTI7XG52YXIgUkVBQ1RfTEVHQUNZX0hJRERFTl9UWVBFID0gMHhlYWUzO1xuXG5pZiAodHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2wuZm9yKSB7XG4gIHZhciBzeW1ib2xGb3IgPSBTeW1ib2wuZm9yO1xuICBSRUFDVF9FTEVNRU5UX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LmVsZW1lbnQnKTtcbiAgUkVBQ1RfUE9SVEFMX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LnBvcnRhbCcpO1xuICBleHBvcnRzLkZyYWdtZW50ID0gc3ltYm9sRm9yKCdyZWFjdC5mcmFnbWVudCcpO1xuICBleHBvcnRzLlN0cmljdE1vZGUgPSBzeW1ib2xGb3IoJ3JlYWN0LnN0cmljdF9tb2RlJyk7XG4gIGV4cG9ydHMuUHJvZmlsZXIgPSBzeW1ib2xGb3IoJ3JlYWN0LnByb2ZpbGVyJyk7XG4gIFJFQUNUX1BST1ZJREVSX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LnByb3ZpZGVyJyk7XG4gIFJFQUNUX0NPTlRFWFRfVFlQRSA9IHN5bWJvbEZvcigncmVhY3QuY29udGV4dCcpO1xuICBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5mb3J3YXJkX3JlZicpO1xuICBleHBvcnRzLlN1c3BlbnNlID0gc3ltYm9sRm9yKCdyZWFjdC5zdXNwZW5zZScpO1xuICBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LnN1c3BlbnNlX2xpc3QnKTtcbiAgUkVBQ1RfTUVNT19UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5tZW1vJyk7XG4gIFJFQUNUX0xBWllfVFlQRSA9IHN5bWJvbEZvcigncmVhY3QubGF6eScpO1xuICBSRUFDVF9CTE9DS19UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5ibG9jaycpO1xuICBSRUFDVF9TRVJWRVJfQkxPQ0tfVFlQRSA9IHN5bWJvbEZvcigncmVhY3Quc2VydmVyLmJsb2NrJyk7XG4gIFJFQUNUX0ZVTkRBTUVOVEFMX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LmZ1bmRhbWVudGFsJyk7XG4gIFJFQUNUX1NDT1BFX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LnNjb3BlJyk7XG4gIFJFQUNUX09QQVFVRV9JRF9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5vcGFxdWUuaWQnKTtcbiAgUkVBQ1RfREVCVUdfVFJBQ0lOR19NT0RFX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LmRlYnVnX3RyYWNlX21vZGUnKTtcbiAgUkVBQ1RfT0ZGU0NSRUVOX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0Lm9mZnNjcmVlbicpO1xuICBSRUFDVF9MRUdBQ1lfSElEREVOX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LmxlZ2FjeV9oaWRkZW4nKTtcbn1cblxudmFyIE1BWUJFX0lURVJBVE9SX1NZTUJPTCA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLml0ZXJhdG9yO1xudmFyIEZBVVhfSVRFUkFUT1JfU1lNQk9MID0gJ0BAaXRlcmF0b3InO1xuZnVuY3Rpb24gZ2V0SXRlcmF0b3JGbihtYXliZUl0ZXJhYmxlKSB7XG4gIGlmIChtYXliZUl0ZXJhYmxlID09PSBudWxsIHx8IHR5cGVvZiBtYXliZUl0ZXJhYmxlICE9PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIG1heWJlSXRlcmF0b3IgPSBNQVlCRV9JVEVSQVRPUl9TWU1CT0wgJiYgbWF5YmVJdGVyYWJsZVtNQVlCRV9JVEVSQVRPUl9TWU1CT0xdIHx8IG1heWJlSXRlcmFibGVbRkFVWF9JVEVSQVRPUl9TWU1CT0xdO1xuXG4gIGlmICh0eXBlb2YgbWF5YmVJdGVyYXRvciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBtYXliZUl0ZXJhdG9yO1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbi8qKlxuICogS2VlcHMgdHJhY2sgb2YgdGhlIGN1cnJlbnQgZGlzcGF0Y2hlci5cbiAqL1xudmFyIFJlYWN0Q3VycmVudERpc3BhdGNoZXIgPSB7XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICogQHR5cGUge1JlYWN0Q29tcG9uZW50fVxuICAgKi9cbiAgY3VycmVudDogbnVsbFxufTtcblxuLyoqXG4gKiBLZWVwcyB0cmFjayBvZiB0aGUgY3VycmVudCBiYXRjaCdzIGNvbmZpZ3VyYXRpb24gc3VjaCBhcyBob3cgbG9uZyBhbiB1cGRhdGVcbiAqIHNob3VsZCBzdXNwZW5kIGZvciBpZiBpdCBuZWVkcyB0by5cbiAqL1xudmFyIFJlYWN0Q3VycmVudEJhdGNoQ29uZmlnID0ge1xuICB0cmFuc2l0aW9uOiAwXG59O1xuXG4vKipcbiAqIEtlZXBzIHRyYWNrIG9mIHRoZSBjdXJyZW50IG93bmVyLlxuICpcbiAqIFRoZSBjdXJyZW50IG93bmVyIGlzIHRoZSBjb21wb25lbnQgd2hvIHNob3VsZCBvd24gYW55IGNvbXBvbmVudHMgdGhhdCBhcmVcbiAqIGN1cnJlbnRseSBiZWluZyBjb25zdHJ1Y3RlZC5cbiAqL1xudmFyIFJlYWN0Q3VycmVudE93bmVyID0ge1xuICAvKipcbiAgICogQGludGVybmFsXG4gICAqIEB0eXBlIHtSZWFjdENvbXBvbmVudH1cbiAgICovXG4gIGN1cnJlbnQ6IG51bGxcbn07XG5cbnZhciBSZWFjdERlYnVnQ3VycmVudEZyYW1lID0ge307XG52YXIgY3VycmVudEV4dHJhU3RhY2tGcmFtZSA9IG51bGw7XG5mdW5jdGlvbiBzZXRFeHRyYVN0YWNrRnJhbWUoc3RhY2spIHtcbiAge1xuICAgIGN1cnJlbnRFeHRyYVN0YWNrRnJhbWUgPSBzdGFjaztcbiAgfVxufVxuXG57XG4gIFJlYWN0RGVidWdDdXJyZW50RnJhbWUuc2V0RXh0cmFTdGFja0ZyYW1lID0gZnVuY3Rpb24gKHN0YWNrKSB7XG4gICAge1xuICAgICAgY3VycmVudEV4dHJhU3RhY2tGcmFtZSA9IHN0YWNrO1xuICAgIH1cbiAgfTsgLy8gU3RhY2sgaW1wbGVtZW50YXRpb24gaW5qZWN0ZWQgYnkgdGhlIGN1cnJlbnQgcmVuZGVyZXIuXG5cblxuICBSZWFjdERlYnVnQ3VycmVudEZyYW1lLmdldEN1cnJlbnRTdGFjayA9IG51bGw7XG5cbiAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5nZXRTdGFja0FkZGVuZHVtID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBzdGFjayA9ICcnOyAvLyBBZGQgYW4gZXh0cmEgdG9wIGZyYW1lIHdoaWxlIGFuIGVsZW1lbnQgaXMgYmVpbmcgdmFsaWRhdGVkXG5cbiAgICBpZiAoY3VycmVudEV4dHJhU3RhY2tGcmFtZSkge1xuICAgICAgc3RhY2sgKz0gY3VycmVudEV4dHJhU3RhY2tGcmFtZTtcbiAgICB9IC8vIERlbGVnYXRlIHRvIHRoZSBpbmplY3RlZCByZW5kZXJlci1zcGVjaWZpYyBpbXBsZW1lbnRhdGlvblxuXG5cbiAgICB2YXIgaW1wbCA9IFJlYWN0RGVidWdDdXJyZW50RnJhbWUuZ2V0Q3VycmVudFN0YWNrO1xuXG4gICAgaWYgKGltcGwpIHtcbiAgICAgIHN0YWNrICs9IGltcGwoKSB8fCAnJztcbiAgICB9XG5cbiAgICByZXR1cm4gc3RhY2s7XG4gIH07XG59XG5cbi8qKlxuICogVXNlZCBieSBhY3QoKSB0byB0cmFjayB3aGV0aGVyIHlvdSdyZSBpbnNpZGUgYW4gYWN0KCkgc2NvcGUuXG4gKi9cbnZhciBJc1NvbWVSZW5kZXJlckFjdGluZyA9IHtcbiAgY3VycmVudDogZmFsc2Vcbn07XG5cbnZhciBSZWFjdFNoYXJlZEludGVybmFscyA9IHtcbiAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlcjogUmVhY3RDdXJyZW50RGlzcGF0Y2hlcixcbiAgUmVhY3RDdXJyZW50QmF0Y2hDb25maWc6IFJlYWN0Q3VycmVudEJhdGNoQ29uZmlnLFxuICBSZWFjdEN1cnJlbnRPd25lcjogUmVhY3RDdXJyZW50T3duZXIsXG4gIElzU29tZVJlbmRlcmVyQWN0aW5nOiBJc1NvbWVSZW5kZXJlckFjdGluZyxcbiAgLy8gVXNlZCBieSByZW5kZXJlcnMgdG8gYXZvaWQgYnVuZGxpbmcgb2JqZWN0LWFzc2lnbiB0d2ljZSBpbiBVTUQgYnVuZGxlczpcbiAgYXNzaWduOiBfYXNzaWduXG59O1xuXG57XG4gIFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0RGVidWdDdXJyZW50RnJhbWUgPSBSZWFjdERlYnVnQ3VycmVudEZyYW1lO1xufVxuXG4vLyBieSBjYWxscyB0byB0aGVzZSBtZXRob2RzIGJ5IGEgQmFiZWwgcGx1Z2luLlxuLy9cbi8vIEluIFBST0QgKG9yIGluIHBhY2thZ2VzIHdpdGhvdXQgYWNjZXNzIHRvIFJlYWN0IGludGVybmFscyksXG4vLyB0aGV5IGFyZSBsZWZ0IGFzIHRoZXkgYXJlIGluc3RlYWQuXG5cbmZ1bmN0aW9uIHdhcm4oZm9ybWF0KSB7XG4gIHtcbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICBwcmludFdhcm5pbmcoJ3dhcm4nLCBmb3JtYXQsIGFyZ3MpO1xuICB9XG59XG5mdW5jdGlvbiBlcnJvcihmb3JtYXQpIHtcbiAge1xuICAgIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMiA+IDEgPyBfbGVuMiAtIDEgOiAwKSwgX2tleTIgPSAxOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICBhcmdzW19rZXkyIC0gMV0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgIH1cblxuICAgIHByaW50V2FybmluZygnZXJyb3InLCBmb3JtYXQsIGFyZ3MpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHByaW50V2FybmluZyhsZXZlbCwgZm9ybWF0LCBhcmdzKSB7XG4gIC8vIFdoZW4gY2hhbmdpbmcgdGhpcyBsb2dpYywgeW91IG1pZ2h0IHdhbnQgdG8gYWxzb1xuICAvLyB1cGRhdGUgY29uc29sZVdpdGhTdGFja0Rldi53d3cuanMgYXMgd2VsbC5cbiAge1xuICAgIHZhciBSZWFjdERlYnVnQ3VycmVudEZyYW1lID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZTtcbiAgICB2YXIgc3RhY2sgPSBSZWFjdERlYnVnQ3VycmVudEZyYW1lLmdldFN0YWNrQWRkZW5kdW0oKTtcblxuICAgIGlmIChzdGFjayAhPT0gJycpIHtcbiAgICAgIGZvcm1hdCArPSAnJXMnO1xuICAgICAgYXJncyA9IGFyZ3MuY29uY2F0KFtzdGFja10pO1xuICAgIH1cblxuICAgIHZhciBhcmdzV2l0aEZvcm1hdCA9IGFyZ3MubWFwKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICByZXR1cm4gJycgKyBpdGVtO1xuICAgIH0pOyAvLyBDYXJlZnVsOiBSTiBjdXJyZW50bHkgZGVwZW5kcyBvbiB0aGlzIHByZWZpeFxuXG4gICAgYXJnc1dpdGhGb3JtYXQudW5zaGlmdCgnV2FybmluZzogJyArIGZvcm1hdCk7IC8vIFdlIGludGVudGlvbmFsbHkgZG9uJ3QgdXNlIHNwcmVhZCAob3IgLmFwcGx5KSBkaXJlY3RseSBiZWNhdXNlIGl0XG4gICAgLy8gYnJlYWtzIElFOTogaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xMzYxMFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9uby1wcm9kdWN0aW9uLWxvZ2dpbmdcblxuICAgIEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseS5jYWxsKGNvbnNvbGVbbGV2ZWxdLCBjb25zb2xlLCBhcmdzV2l0aEZvcm1hdCk7XG4gIH1cbn1cblxudmFyIGRpZFdhcm5TdGF0ZVVwZGF0ZUZvclVubW91bnRlZENvbXBvbmVudCA9IHt9O1xuXG5mdW5jdGlvbiB3YXJuTm9vcChwdWJsaWNJbnN0YW5jZSwgY2FsbGVyTmFtZSkge1xuICB7XG4gICAgdmFyIF9jb25zdHJ1Y3RvciA9IHB1YmxpY0luc3RhbmNlLmNvbnN0cnVjdG9yO1xuICAgIHZhciBjb21wb25lbnROYW1lID0gX2NvbnN0cnVjdG9yICYmIChfY29uc3RydWN0b3IuZGlzcGxheU5hbWUgfHwgX2NvbnN0cnVjdG9yLm5hbWUpIHx8ICdSZWFjdENsYXNzJztcbiAgICB2YXIgd2FybmluZ0tleSA9IGNvbXBvbmVudE5hbWUgKyBcIi5cIiArIGNhbGxlck5hbWU7XG5cbiAgICBpZiAoZGlkV2FyblN0YXRlVXBkYXRlRm9yVW5tb3VudGVkQ29tcG9uZW50W3dhcm5pbmdLZXldKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZXJyb3IoXCJDYW4ndCBjYWxsICVzIG9uIGEgY29tcG9uZW50IHRoYXQgaXMgbm90IHlldCBtb3VudGVkLiBcIiArICdUaGlzIGlzIGEgbm8tb3AsIGJ1dCBpdCBtaWdodCBpbmRpY2F0ZSBhIGJ1ZyBpbiB5b3VyIGFwcGxpY2F0aW9uLiAnICsgJ0luc3RlYWQsIGFzc2lnbiB0byBgdGhpcy5zdGF0ZWAgZGlyZWN0bHkgb3IgZGVmaW5lIGEgYHN0YXRlID0ge307YCAnICsgJ2NsYXNzIHByb3BlcnR5IHdpdGggdGhlIGRlc2lyZWQgc3RhdGUgaW4gdGhlICVzIGNvbXBvbmVudC4nLCBjYWxsZXJOYW1lLCBjb21wb25lbnROYW1lKTtcblxuICAgIGRpZFdhcm5TdGF0ZVVwZGF0ZUZvclVubW91bnRlZENvbXBvbmVudFt3YXJuaW5nS2V5XSA9IHRydWU7XG4gIH1cbn1cbi8qKlxuICogVGhpcyBpcyB0aGUgYWJzdHJhY3QgQVBJIGZvciBhbiB1cGRhdGUgcXVldWUuXG4gKi9cblxuXG52YXIgUmVhY3ROb29wVXBkYXRlUXVldWUgPSB7XG4gIC8qKlxuICAgKiBDaGVja3Mgd2hldGhlciBvciBub3QgdGhpcyBjb21wb3NpdGUgY29tcG9uZW50IGlzIG1vdW50ZWQuXG4gICAqIEBwYXJhbSB7UmVhY3RDbGFzc30gcHVibGljSW5zdGFuY2UgVGhlIGluc3RhbmNlIHdlIHdhbnQgdG8gdGVzdC5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBtb3VudGVkLCBmYWxzZSBvdGhlcndpc2UuXG4gICAqIEBwcm90ZWN0ZWRcbiAgICogQGZpbmFsXG4gICAqL1xuICBpc01vdW50ZWQ6IGZ1bmN0aW9uIChwdWJsaWNJbnN0YW5jZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSxcblxuICAvKipcbiAgICogRm9yY2VzIGFuIHVwZGF0ZS4gVGhpcyBzaG91bGQgb25seSBiZSBpbnZva2VkIHdoZW4gaXQgaXMga25vd24gd2l0aFxuICAgKiBjZXJ0YWludHkgdGhhdCB3ZSBhcmUgKipub3QqKiBpbiBhIERPTSB0cmFuc2FjdGlvbi5cbiAgICpcbiAgICogWW91IG1heSB3YW50IHRvIGNhbGwgdGhpcyB3aGVuIHlvdSBrbm93IHRoYXQgc29tZSBkZWVwZXIgYXNwZWN0IG9mIHRoZVxuICAgKiBjb21wb25lbnQncyBzdGF0ZSBoYXMgY2hhbmdlZCBidXQgYHNldFN0YXRlYCB3YXMgbm90IGNhbGxlZC5cbiAgICpcbiAgICogVGhpcyB3aWxsIG5vdCBpbnZva2UgYHNob3VsZENvbXBvbmVudFVwZGF0ZWAsIGJ1dCBpdCB3aWxsIGludm9rZVxuICAgKiBgY29tcG9uZW50V2lsbFVwZGF0ZWAgYW5kIGBjb21wb25lbnREaWRVcGRhdGVgLlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0Q2xhc3N9IHB1YmxpY0luc3RhbmNlIFRoZSBpbnN0YW5jZSB0aGF0IHNob3VsZCByZXJlbmRlci5cbiAgICogQHBhcmFtIHs/ZnVuY3Rpb259IGNhbGxiYWNrIENhbGxlZCBhZnRlciBjb21wb25lbnQgaXMgdXBkYXRlZC5cbiAgICogQHBhcmFtIHs/c3RyaW5nfSBjYWxsZXJOYW1lIG5hbWUgb2YgdGhlIGNhbGxpbmcgZnVuY3Rpb24gaW4gdGhlIHB1YmxpYyBBUEkuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZW5xdWV1ZUZvcmNlVXBkYXRlOiBmdW5jdGlvbiAocHVibGljSW5zdGFuY2UsIGNhbGxiYWNrLCBjYWxsZXJOYW1lKSB7XG4gICAgd2Fybk5vb3AocHVibGljSW5zdGFuY2UsICdmb3JjZVVwZGF0ZScpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZXBsYWNlcyBhbGwgb2YgdGhlIHN0YXRlLiBBbHdheXMgdXNlIHRoaXMgb3IgYHNldFN0YXRlYCB0byBtdXRhdGUgc3RhdGUuXG4gICAqIFlvdSBzaG91bGQgdHJlYXQgYHRoaXMuc3RhdGVgIGFzIGltbXV0YWJsZS5cbiAgICpcbiAgICogVGhlcmUgaXMgbm8gZ3VhcmFudGVlIHRoYXQgYHRoaXMuc3RhdGVgIHdpbGwgYmUgaW1tZWRpYXRlbHkgdXBkYXRlZCwgc29cbiAgICogYWNjZXNzaW5nIGB0aGlzLnN0YXRlYCBhZnRlciBjYWxsaW5nIHRoaXMgbWV0aG9kIG1heSByZXR1cm4gdGhlIG9sZCB2YWx1ZS5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdENsYXNzfSBwdWJsaWNJbnN0YW5jZSBUaGUgaW5zdGFuY2UgdGhhdCBzaG91bGQgcmVyZW5kZXIuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBjb21wbGV0ZVN0YXRlIE5leHQgc3RhdGUuXG4gICAqIEBwYXJhbSB7P2Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsZWQgYWZ0ZXIgY29tcG9uZW50IGlzIHVwZGF0ZWQuXG4gICAqIEBwYXJhbSB7P3N0cmluZ30gY2FsbGVyTmFtZSBuYW1lIG9mIHRoZSBjYWxsaW5nIGZ1bmN0aW9uIGluIHRoZSBwdWJsaWMgQVBJLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGVucXVldWVSZXBsYWNlU3RhdGU6IGZ1bmN0aW9uIChwdWJsaWNJbnN0YW5jZSwgY29tcGxldGVTdGF0ZSwgY2FsbGJhY2ssIGNhbGxlck5hbWUpIHtcbiAgICB3YXJuTm9vcChwdWJsaWNJbnN0YW5jZSwgJ3JlcGxhY2VTdGF0ZScpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBTZXRzIGEgc3Vic2V0IG9mIHRoZSBzdGF0ZS4gVGhpcyBvbmx5IGV4aXN0cyBiZWNhdXNlIF9wZW5kaW5nU3RhdGUgaXNcbiAgICogaW50ZXJuYWwuIFRoaXMgcHJvdmlkZXMgYSBtZXJnaW5nIHN0cmF0ZWd5IHRoYXQgaXMgbm90IGF2YWlsYWJsZSB0byBkZWVwXG4gICAqIHByb3BlcnRpZXMgd2hpY2ggaXMgY29uZnVzaW5nLiBUT0RPOiBFeHBvc2UgcGVuZGluZ1N0YXRlIG9yIGRvbid0IHVzZSBpdFxuICAgKiBkdXJpbmcgdGhlIG1lcmdlLlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0Q2xhc3N9IHB1YmxpY0luc3RhbmNlIFRoZSBpbnN0YW5jZSB0aGF0IHNob3VsZCByZXJlbmRlci5cbiAgICogQHBhcmFtIHtvYmplY3R9IHBhcnRpYWxTdGF0ZSBOZXh0IHBhcnRpYWwgc3RhdGUgdG8gYmUgbWVyZ2VkIHdpdGggc3RhdGUuXG4gICAqIEBwYXJhbSB7P2Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsZWQgYWZ0ZXIgY29tcG9uZW50IGlzIHVwZGF0ZWQuXG4gICAqIEBwYXJhbSB7P3N0cmluZ30gTmFtZSBvZiB0aGUgY2FsbGluZyBmdW5jdGlvbiBpbiB0aGUgcHVibGljIEFQSS5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBlbnF1ZXVlU2V0U3RhdGU6IGZ1bmN0aW9uIChwdWJsaWNJbnN0YW5jZSwgcGFydGlhbFN0YXRlLCBjYWxsYmFjaywgY2FsbGVyTmFtZSkge1xuICAgIHdhcm5Ob29wKHB1YmxpY0luc3RhbmNlLCAnc2V0U3RhdGUnKTtcbiAgfVxufTtcblxudmFyIGVtcHR5T2JqZWN0ID0ge307XG5cbntcbiAgT2JqZWN0LmZyZWV6ZShlbXB0eU9iamVjdCk7XG59XG4vKipcbiAqIEJhc2UgY2xhc3MgaGVscGVycyBmb3IgdGhlIHVwZGF0aW5nIHN0YXRlIG9mIGEgY29tcG9uZW50LlxuICovXG5cblxuZnVuY3Rpb24gQ29tcG9uZW50KHByb3BzLCBjb250ZXh0LCB1cGRhdGVyKSB7XG4gIHRoaXMucHJvcHMgPSBwcm9wcztcbiAgdGhpcy5jb250ZXh0ID0gY29udGV4dDsgLy8gSWYgYSBjb21wb25lbnQgaGFzIHN0cmluZyByZWZzLCB3ZSB3aWxsIGFzc2lnbiBhIGRpZmZlcmVudCBvYmplY3QgbGF0ZXIuXG5cbiAgdGhpcy5yZWZzID0gZW1wdHlPYmplY3Q7IC8vIFdlIGluaXRpYWxpemUgdGhlIGRlZmF1bHQgdXBkYXRlciBidXQgdGhlIHJlYWwgb25lIGdldHMgaW5qZWN0ZWQgYnkgdGhlXG4gIC8vIHJlbmRlcmVyLlxuXG4gIHRoaXMudXBkYXRlciA9IHVwZGF0ZXIgfHwgUmVhY3ROb29wVXBkYXRlUXVldWU7XG59XG5cbkNvbXBvbmVudC5wcm90b3R5cGUuaXNSZWFjdENvbXBvbmVudCA9IHt9O1xuLyoqXG4gKiBTZXRzIGEgc3Vic2V0IG9mIHRoZSBzdGF0ZS4gQWx3YXlzIHVzZSB0aGlzIHRvIG11dGF0ZVxuICogc3RhdGUuIFlvdSBzaG91bGQgdHJlYXQgYHRoaXMuc3RhdGVgIGFzIGltbXV0YWJsZS5cbiAqXG4gKiBUaGVyZSBpcyBubyBndWFyYW50ZWUgdGhhdCBgdGhpcy5zdGF0ZWAgd2lsbCBiZSBpbW1lZGlhdGVseSB1cGRhdGVkLCBzb1xuICogYWNjZXNzaW5nIGB0aGlzLnN0YXRlYCBhZnRlciBjYWxsaW5nIHRoaXMgbWV0aG9kIG1heSByZXR1cm4gdGhlIG9sZCB2YWx1ZS5cbiAqXG4gKiBUaGVyZSBpcyBubyBndWFyYW50ZWUgdGhhdCBjYWxscyB0byBgc2V0U3RhdGVgIHdpbGwgcnVuIHN5bmNocm9ub3VzbHksXG4gKiBhcyB0aGV5IG1heSBldmVudHVhbGx5IGJlIGJhdGNoZWQgdG9nZXRoZXIuICBZb3UgY2FuIHByb3ZpZGUgYW4gb3B0aW9uYWxcbiAqIGNhbGxiYWNrIHRoYXQgd2lsbCBiZSBleGVjdXRlZCB3aGVuIHRoZSBjYWxsIHRvIHNldFN0YXRlIGlzIGFjdHVhbGx5XG4gKiBjb21wbGV0ZWQuXG4gKlxuICogV2hlbiBhIGZ1bmN0aW9uIGlzIHByb3ZpZGVkIHRvIHNldFN0YXRlLCBpdCB3aWxsIGJlIGNhbGxlZCBhdCBzb21lIHBvaW50IGluXG4gKiB0aGUgZnV0dXJlIChub3Qgc3luY2hyb25vdXNseSkuIEl0IHdpbGwgYmUgY2FsbGVkIHdpdGggdGhlIHVwIHRvIGRhdGVcbiAqIGNvbXBvbmVudCBhcmd1bWVudHMgKHN0YXRlLCBwcm9wcywgY29udGV4dCkuIFRoZXNlIHZhbHVlcyBjYW4gYmUgZGlmZmVyZW50XG4gKiBmcm9tIHRoaXMuKiBiZWNhdXNlIHlvdXIgZnVuY3Rpb24gbWF5IGJlIGNhbGxlZCBhZnRlciByZWNlaXZlUHJvcHMgYnV0IGJlZm9yZVxuICogc2hvdWxkQ29tcG9uZW50VXBkYXRlLCBhbmQgdGhpcyBuZXcgc3RhdGUsIHByb3BzLCBhbmQgY29udGV4dCB3aWxsIG5vdCB5ZXQgYmVcbiAqIGFzc2lnbmVkIHRvIHRoaXMuXG4gKlxuICogQHBhcmFtIHtvYmplY3R8ZnVuY3Rpb259IHBhcnRpYWxTdGF0ZSBOZXh0IHBhcnRpYWwgc3RhdGUgb3IgZnVuY3Rpb24gdG9cbiAqICAgICAgICBwcm9kdWNlIG5leHQgcGFydGlhbCBzdGF0ZSB0byBiZSBtZXJnZWQgd2l0aCBjdXJyZW50IHN0YXRlLlxuICogQHBhcmFtIHs/ZnVuY3Rpb259IGNhbGxiYWNrIENhbGxlZCBhZnRlciBzdGF0ZSBpcyB1cGRhdGVkLlxuICogQGZpbmFsXG4gKiBAcHJvdGVjdGVkXG4gKi9cblxuQ29tcG9uZW50LnByb3RvdHlwZS5zZXRTdGF0ZSA9IGZ1bmN0aW9uIChwYXJ0aWFsU3RhdGUsIGNhbGxiYWNrKSB7XG4gIGlmICghKHR5cGVvZiBwYXJ0aWFsU3RhdGUgPT09ICdvYmplY3QnIHx8IHR5cGVvZiBwYXJ0aWFsU3RhdGUgPT09ICdmdW5jdGlvbicgfHwgcGFydGlhbFN0YXRlID09IG51bGwpKSB7XG4gICAge1xuICAgICAgdGhyb3cgRXJyb3IoIFwic2V0U3RhdGUoLi4uKTogdGFrZXMgYW4gb2JqZWN0IG9mIHN0YXRlIHZhcmlhYmxlcyB0byB1cGRhdGUgb3IgYSBmdW5jdGlvbiB3aGljaCByZXR1cm5zIGFuIG9iamVjdCBvZiBzdGF0ZSB2YXJpYWJsZXMuXCIgKTtcbiAgICB9XG4gIH1cblxuICB0aGlzLnVwZGF0ZXIuZW5xdWV1ZVNldFN0YXRlKHRoaXMsIHBhcnRpYWxTdGF0ZSwgY2FsbGJhY2ssICdzZXRTdGF0ZScpO1xufTtcbi8qKlxuICogRm9yY2VzIGFuIHVwZGF0ZS4gVGhpcyBzaG91bGQgb25seSBiZSBpbnZva2VkIHdoZW4gaXQgaXMga25vd24gd2l0aFxuICogY2VydGFpbnR5IHRoYXQgd2UgYXJlICoqbm90KiogaW4gYSBET00gdHJhbnNhY3Rpb24uXG4gKlxuICogWW91IG1heSB3YW50IHRvIGNhbGwgdGhpcyB3aGVuIHlvdSBrbm93IHRoYXQgc29tZSBkZWVwZXIgYXNwZWN0IG9mIHRoZVxuICogY29tcG9uZW50J3Mgc3RhdGUgaGFzIGNoYW5nZWQgYnV0IGBzZXRTdGF0ZWAgd2FzIG5vdCBjYWxsZWQuXG4gKlxuICogVGhpcyB3aWxsIG5vdCBpbnZva2UgYHNob3VsZENvbXBvbmVudFVwZGF0ZWAsIGJ1dCBpdCB3aWxsIGludm9rZVxuICogYGNvbXBvbmVudFdpbGxVcGRhdGVgIGFuZCBgY29tcG9uZW50RGlkVXBkYXRlYC5cbiAqXG4gKiBAcGFyYW0gez9mdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGVkIGFmdGVyIHVwZGF0ZSBpcyBjb21wbGV0ZS5cbiAqIEBmaW5hbFxuICogQHByb3RlY3RlZFxuICovXG5cblxuQ29tcG9uZW50LnByb3RvdHlwZS5mb3JjZVVwZGF0ZSA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICB0aGlzLnVwZGF0ZXIuZW5xdWV1ZUZvcmNlVXBkYXRlKHRoaXMsIGNhbGxiYWNrLCAnZm9yY2VVcGRhdGUnKTtcbn07XG4vKipcbiAqIERlcHJlY2F0ZWQgQVBJcy4gVGhlc2UgQVBJcyB1c2VkIHRvIGV4aXN0IG9uIGNsYXNzaWMgUmVhY3QgY2xhc3NlcyBidXQgc2luY2VcbiAqIHdlIHdvdWxkIGxpa2UgdG8gZGVwcmVjYXRlIHRoZW0sIHdlJ3JlIG5vdCBnb2luZyB0byBtb3ZlIHRoZW0gb3ZlciB0byB0aGlzXG4gKiBtb2Rlcm4gYmFzZSBjbGFzcy4gSW5zdGVhZCwgd2UgZGVmaW5lIGEgZ2V0dGVyIHRoYXQgd2FybnMgaWYgaXQncyBhY2Nlc3NlZC5cbiAqL1xuXG5cbntcbiAgdmFyIGRlcHJlY2F0ZWRBUElzID0ge1xuICAgIGlzTW91bnRlZDogWydpc01vdW50ZWQnLCAnSW5zdGVhZCwgbWFrZSBzdXJlIHRvIGNsZWFuIHVwIHN1YnNjcmlwdGlvbnMgYW5kIHBlbmRpbmcgcmVxdWVzdHMgaW4gJyArICdjb21wb25lbnRXaWxsVW5tb3VudCB0byBwcmV2ZW50IG1lbW9yeSBsZWFrcy4nXSxcbiAgICByZXBsYWNlU3RhdGU6IFsncmVwbGFjZVN0YXRlJywgJ1JlZmFjdG9yIHlvdXIgY29kZSB0byB1c2Ugc2V0U3RhdGUgaW5zdGVhZCAoc2VlICcgKyAnaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8zMjM2KS4nXVxuICB9O1xuXG4gIHZhciBkZWZpbmVEZXByZWNhdGlvbldhcm5pbmcgPSBmdW5jdGlvbiAobWV0aG9kTmFtZSwgaW5mbykge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb21wb25lbnQucHJvdG90eXBlLCBtZXRob2ROYW1lLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgd2FybignJXMoLi4uKSBpcyBkZXByZWNhdGVkIGluIHBsYWluIEphdmFTY3JpcHQgUmVhY3QgY2xhc3Nlcy4gJXMnLCBpbmZvWzBdLCBpbmZvWzFdKTtcblxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xuXG4gIGZvciAodmFyIGZuTmFtZSBpbiBkZXByZWNhdGVkQVBJcykge1xuICAgIGlmIChkZXByZWNhdGVkQVBJcy5oYXNPd25Qcm9wZXJ0eShmbk5hbWUpKSB7XG4gICAgICBkZWZpbmVEZXByZWNhdGlvbldhcm5pbmcoZm5OYW1lLCBkZXByZWNhdGVkQVBJc1tmbk5hbWVdKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gQ29tcG9uZW50RHVtbXkoKSB7fVxuXG5Db21wb25lbnREdW1teS5wcm90b3R5cGUgPSBDb21wb25lbnQucHJvdG90eXBlO1xuLyoqXG4gKiBDb252ZW5pZW5jZSBjb21wb25lbnQgd2l0aCBkZWZhdWx0IHNoYWxsb3cgZXF1YWxpdHkgY2hlY2sgZm9yIHNDVS5cbiAqL1xuXG5mdW5jdGlvbiBQdXJlQ29tcG9uZW50KHByb3BzLCBjb250ZXh0LCB1cGRhdGVyKSB7XG4gIHRoaXMucHJvcHMgPSBwcm9wcztcbiAgdGhpcy5jb250ZXh0ID0gY29udGV4dDsgLy8gSWYgYSBjb21wb25lbnQgaGFzIHN0cmluZyByZWZzLCB3ZSB3aWxsIGFzc2lnbiBhIGRpZmZlcmVudCBvYmplY3QgbGF0ZXIuXG5cbiAgdGhpcy5yZWZzID0gZW1wdHlPYmplY3Q7XG4gIHRoaXMudXBkYXRlciA9IHVwZGF0ZXIgfHwgUmVhY3ROb29wVXBkYXRlUXVldWU7XG59XG5cbnZhciBwdXJlQ29tcG9uZW50UHJvdG90eXBlID0gUHVyZUNvbXBvbmVudC5wcm90b3R5cGUgPSBuZXcgQ29tcG9uZW50RHVtbXkoKTtcbnB1cmVDb21wb25lbnRQcm90b3R5cGUuY29uc3RydWN0b3IgPSBQdXJlQ29tcG9uZW50OyAvLyBBdm9pZCBhbiBleHRyYSBwcm90b3R5cGUganVtcCBmb3IgdGhlc2UgbWV0aG9kcy5cblxuX2Fzc2lnbihwdXJlQ29tcG9uZW50UHJvdG90eXBlLCBDb21wb25lbnQucHJvdG90eXBlKTtcblxucHVyZUNvbXBvbmVudFByb3RvdHlwZS5pc1B1cmVSZWFjdENvbXBvbmVudCA9IHRydWU7XG5cbi8vIGFuIGltbXV0YWJsZSBvYmplY3Qgd2l0aCBhIHNpbmdsZSBtdXRhYmxlIHZhbHVlXG5mdW5jdGlvbiBjcmVhdGVSZWYoKSB7XG4gIHZhciByZWZPYmplY3QgPSB7XG4gICAgY3VycmVudDogbnVsbFxuICB9O1xuXG4gIHtcbiAgICBPYmplY3Quc2VhbChyZWZPYmplY3QpO1xuICB9XG5cbiAgcmV0dXJuIHJlZk9iamVjdDtcbn1cblxuZnVuY3Rpb24gZ2V0V3JhcHBlZE5hbWUob3V0ZXJUeXBlLCBpbm5lclR5cGUsIHdyYXBwZXJOYW1lKSB7XG4gIHZhciBmdW5jdGlvbk5hbWUgPSBpbm5lclR5cGUuZGlzcGxheU5hbWUgfHwgaW5uZXJUeXBlLm5hbWUgfHwgJyc7XG4gIHJldHVybiBvdXRlclR5cGUuZGlzcGxheU5hbWUgfHwgKGZ1bmN0aW9uTmFtZSAhPT0gJycgPyB3cmFwcGVyTmFtZSArIFwiKFwiICsgZnVuY3Rpb25OYW1lICsgXCIpXCIgOiB3cmFwcGVyTmFtZSk7XG59XG5cbmZ1bmN0aW9uIGdldENvbnRleHROYW1lKHR5cGUpIHtcbiAgcmV0dXJuIHR5cGUuZGlzcGxheU5hbWUgfHwgJ0NvbnRleHQnO1xufVxuXG5mdW5jdGlvbiBnZXRDb21wb25lbnROYW1lKHR5cGUpIHtcbiAgaWYgKHR5cGUgPT0gbnVsbCkge1xuICAgIC8vIEhvc3Qgcm9vdCwgdGV4dCBub2RlIG9yIGp1c3QgaW52YWxpZCB0eXBlLlxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAge1xuICAgIGlmICh0eXBlb2YgdHlwZS50YWcgPT09ICdudW1iZXInKSB7XG4gICAgICBlcnJvcignUmVjZWl2ZWQgYW4gdW5leHBlY3RlZCBvYmplY3QgaW4gZ2V0Q29tcG9uZW50TmFtZSgpLiAnICsgJ1RoaXMgaXMgbGlrZWx5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgICB9XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gdHlwZS5kaXNwbGF5TmFtZSB8fCB0eXBlLm5hbWUgfHwgbnVsbDtcbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gdHlwZTtcbiAgfVxuXG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgZXhwb3J0cy5GcmFnbWVudDpcbiAgICAgIHJldHVybiAnRnJhZ21lbnQnO1xuXG4gICAgY2FzZSBSRUFDVF9QT1JUQUxfVFlQRTpcbiAgICAgIHJldHVybiAnUG9ydGFsJztcblxuICAgIGNhc2UgZXhwb3J0cy5Qcm9maWxlcjpcbiAgICAgIHJldHVybiAnUHJvZmlsZXInO1xuXG4gICAgY2FzZSBleHBvcnRzLlN0cmljdE1vZGU6XG4gICAgICByZXR1cm4gJ1N0cmljdE1vZGUnO1xuXG4gICAgY2FzZSBleHBvcnRzLlN1c3BlbnNlOlxuICAgICAgcmV0dXJuICdTdXNwZW5zZSc7XG5cbiAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRTpcbiAgICAgIHJldHVybiAnU3VzcGVuc2VMaXN0JztcbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICBzd2l0Y2ggKHR5cGUuJCR0eXBlb2YpIHtcbiAgICAgIGNhc2UgUkVBQ1RfQ09OVEVYVF9UWVBFOlxuICAgICAgICB2YXIgY29udGV4dCA9IHR5cGU7XG4gICAgICAgIHJldHVybiBnZXRDb250ZXh0TmFtZShjb250ZXh0KSArICcuQ29uc3VtZXInO1xuXG4gICAgICBjYXNlIFJFQUNUX1BST1ZJREVSX1RZUEU6XG4gICAgICAgIHZhciBwcm92aWRlciA9IHR5cGU7XG4gICAgICAgIHJldHVybiBnZXRDb250ZXh0TmFtZShwcm92aWRlci5fY29udGV4dCkgKyAnLlByb3ZpZGVyJztcblxuICAgICAgY2FzZSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFOlxuICAgICAgICByZXR1cm4gZ2V0V3JhcHBlZE5hbWUodHlwZSwgdHlwZS5yZW5kZXIsICdGb3J3YXJkUmVmJyk7XG5cbiAgICAgIGNhc2UgUkVBQ1RfTUVNT19UWVBFOlxuICAgICAgICByZXR1cm4gZ2V0Q29tcG9uZW50TmFtZSh0eXBlLnR5cGUpO1xuXG4gICAgICBjYXNlIFJFQUNUX0JMT0NLX1RZUEU6XG4gICAgICAgIHJldHVybiBnZXRDb21wb25lbnROYW1lKHR5cGUuX3JlbmRlcik7XG5cbiAgICAgIGNhc2UgUkVBQ1RfTEFaWV9UWVBFOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIGxhenlDb21wb25lbnQgPSB0eXBlO1xuICAgICAgICAgIHZhciBwYXlsb2FkID0gbGF6eUNvbXBvbmVudC5fcGF5bG9hZDtcbiAgICAgICAgICB2YXIgaW5pdCA9IGxhenlDb21wb25lbnQuX2luaXQ7XG5cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIGdldENvbXBvbmVudE5hbWUoaW5pdChwYXlsb2FkKSk7XG4gICAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgUkVTRVJWRURfUFJPUFMgPSB7XG4gIGtleTogdHJ1ZSxcbiAgcmVmOiB0cnVlLFxuICBfX3NlbGY6IHRydWUsXG4gIF9fc291cmNlOiB0cnVlXG59O1xudmFyIHNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duLCBzcGVjaWFsUHJvcFJlZldhcm5pbmdTaG93biwgZGlkV2FybkFib3V0U3RyaW5nUmVmcztcblxue1xuICBkaWRXYXJuQWJvdXRTdHJpbmdSZWZzID0ge307XG59XG5cbmZ1bmN0aW9uIGhhc1ZhbGlkUmVmKGNvbmZpZykge1xuICB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCAncmVmJykpIHtcbiAgICAgIHZhciBnZXR0ZXIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGNvbmZpZywgJ3JlZicpLmdldDtcblxuICAgICAgaWYgKGdldHRlciAmJiBnZXR0ZXIuaXNSZWFjdFdhcm5pbmcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjb25maWcucmVmICE9PSB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIGhhc1ZhbGlkS2V5KGNvbmZpZykge1xuICB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCAna2V5JykpIHtcbiAgICAgIHZhciBnZXR0ZXIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGNvbmZpZywgJ2tleScpLmdldDtcblxuICAgICAgaWYgKGdldHRlciAmJiBnZXR0ZXIuaXNSZWFjdFdhcm5pbmcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjb25maWcua2V5ICE9PSB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIGRlZmluZUtleVByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSkge1xuICB2YXIgd2FybkFib3V0QWNjZXNzaW5nS2V5ID0gZnVuY3Rpb24gKCkge1xuICAgIHtcbiAgICAgIGlmICghc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd24pIHtcbiAgICAgICAgc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd24gPSB0cnVlO1xuXG4gICAgICAgIGVycm9yKCclczogYGtleWAgaXMgbm90IGEgcHJvcC4gVHJ5aW5nIHRvIGFjY2VzcyBpdCB3aWxsIHJlc3VsdCAnICsgJ2luIGB1bmRlZmluZWRgIGJlaW5nIHJldHVybmVkLiBJZiB5b3UgbmVlZCB0byBhY2Nlc3MgdGhlIHNhbWUgJyArICd2YWx1ZSB3aXRoaW4gdGhlIGNoaWxkIGNvbXBvbmVudCwgeW91IHNob3VsZCBwYXNzIGl0IGFzIGEgZGlmZmVyZW50ICcgKyAncHJvcC4gKGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9zcGVjaWFsLXByb3BzKScsIGRpc3BsYXlOYW1lKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgd2FybkFib3V0QWNjZXNzaW5nS2V5LmlzUmVhY3RXYXJuaW5nID0gdHJ1ZTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3BzLCAna2V5Jywge1xuICAgIGdldDogd2FybkFib3V0QWNjZXNzaW5nS2V5LFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbn1cblxuZnVuY3Rpb24gZGVmaW5lUmVmUHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKSB7XG4gIHZhciB3YXJuQWJvdXRBY2Nlc3NpbmdSZWYgPSBmdW5jdGlvbiAoKSB7XG4gICAge1xuICAgICAgaWYgKCFzcGVjaWFsUHJvcFJlZldhcm5pbmdTaG93bikge1xuICAgICAgICBzcGVjaWFsUHJvcFJlZldhcm5pbmdTaG93biA9IHRydWU7XG5cbiAgICAgICAgZXJyb3IoJyVzOiBgcmVmYCBpcyBub3QgYSBwcm9wLiBUcnlpbmcgdG8gYWNjZXNzIGl0IHdpbGwgcmVzdWx0ICcgKyAnaW4gYHVuZGVmaW5lZGAgYmVpbmcgcmV0dXJuZWQuIElmIHlvdSBuZWVkIHRvIGFjY2VzcyB0aGUgc2FtZSAnICsgJ3ZhbHVlIHdpdGhpbiB0aGUgY2hpbGQgY29tcG9uZW50LCB5b3Ugc2hvdWxkIHBhc3MgaXQgYXMgYSBkaWZmZXJlbnQgJyArICdwcm9wLiAoaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3NwZWNpYWwtcHJvcHMpJywgZGlzcGxheU5hbWUpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICB3YXJuQWJvdXRBY2Nlc3NpbmdSZWYuaXNSZWFjdFdhcm5pbmcgPSB0cnVlO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvcHMsICdyZWYnLCB7XG4gICAgZ2V0OiB3YXJuQWJvdXRBY2Nlc3NpbmdSZWYsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xufVxuXG5mdW5jdGlvbiB3YXJuSWZTdHJpbmdSZWZDYW5ub3RCZUF1dG9Db252ZXJ0ZWQoY29uZmlnKSB7XG4gIHtcbiAgICBpZiAodHlwZW9mIGNvbmZpZy5yZWYgPT09ICdzdHJpbmcnICYmIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQgJiYgY29uZmlnLl9fc2VsZiAmJiBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50LnN0YXRlTm9kZSAhPT0gY29uZmlnLl9fc2VsZikge1xuICAgICAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lKFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQudHlwZSk7XG5cbiAgICAgIGlmICghZGlkV2FybkFib3V0U3RyaW5nUmVmc1tjb21wb25lbnROYW1lXSkge1xuICAgICAgICBlcnJvcignQ29tcG9uZW50IFwiJXNcIiBjb250YWlucyB0aGUgc3RyaW5nIHJlZiBcIiVzXCIuICcgKyAnU3VwcG9ydCBmb3Igc3RyaW5nIHJlZnMgd2lsbCBiZSByZW1vdmVkIGluIGEgZnV0dXJlIG1ham9yIHJlbGVhc2UuICcgKyAnVGhpcyBjYXNlIGNhbm5vdCBiZSBhdXRvbWF0aWNhbGx5IGNvbnZlcnRlZCB0byBhbiBhcnJvdyBmdW5jdGlvbi4gJyArICdXZSBhc2sgeW91IHRvIG1hbnVhbGx5IGZpeCB0aGlzIGNhc2UgYnkgdXNpbmcgdXNlUmVmKCkgb3IgY3JlYXRlUmVmKCkgaW5zdGVhZC4gJyArICdMZWFybiBtb3JlIGFib3V0IHVzaW5nIHJlZnMgc2FmZWx5IGhlcmU6ICcgKyAnaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3N0cmljdC1tb2RlLXN0cmluZy1yZWYnLCBjb21wb25lbnROYW1lLCBjb25maWcucmVmKTtcblxuICAgICAgICBkaWRXYXJuQWJvdXRTdHJpbmdSZWZzW2NvbXBvbmVudE5hbWVdID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbi8qKlxuICogRmFjdG9yeSBtZXRob2QgdG8gY3JlYXRlIGEgbmV3IFJlYWN0IGVsZW1lbnQuIFRoaXMgbm8gbG9uZ2VyIGFkaGVyZXMgdG9cbiAqIHRoZSBjbGFzcyBwYXR0ZXJuLCBzbyBkbyBub3QgdXNlIG5ldyB0byBjYWxsIGl0LiBBbHNvLCBpbnN0YW5jZW9mIGNoZWNrXG4gKiB3aWxsIG5vdCB3b3JrLiBJbnN0ZWFkIHRlc3QgJCR0eXBlb2YgZmllbGQgYWdhaW5zdCBTeW1ib2wuZm9yKCdyZWFjdC5lbGVtZW50JykgdG8gY2hlY2tcbiAqIGlmIHNvbWV0aGluZyBpcyBhIFJlYWN0IEVsZW1lbnQuXG4gKlxuICogQHBhcmFtIHsqfSB0eXBlXG4gKiBAcGFyYW0geyp9IHByb3BzXG4gKiBAcGFyYW0geyp9IGtleVxuICogQHBhcmFtIHtzdHJpbmd8b2JqZWN0fSByZWZcbiAqIEBwYXJhbSB7Kn0gb3duZXJcbiAqIEBwYXJhbSB7Kn0gc2VsZiBBICp0ZW1wb3JhcnkqIGhlbHBlciB0byBkZXRlY3QgcGxhY2VzIHdoZXJlIGB0aGlzYCBpc1xuICogZGlmZmVyZW50IGZyb20gdGhlIGBvd25lcmAgd2hlbiBSZWFjdC5jcmVhdGVFbGVtZW50IGlzIGNhbGxlZCwgc28gdGhhdCB3ZVxuICogY2FuIHdhcm4uIFdlIHdhbnQgdG8gZ2V0IHJpZCBvZiBvd25lciBhbmQgcmVwbGFjZSBzdHJpbmcgYHJlZmBzIHdpdGggYXJyb3dcbiAqIGZ1bmN0aW9ucywgYW5kIGFzIGxvbmcgYXMgYHRoaXNgIGFuZCBvd25lciBhcmUgdGhlIHNhbWUsIHRoZXJlIHdpbGwgYmUgbm9cbiAqIGNoYW5nZSBpbiBiZWhhdmlvci5cbiAqIEBwYXJhbSB7Kn0gc291cmNlIEFuIGFubm90YXRpb24gb2JqZWN0IChhZGRlZCBieSBhIHRyYW5zcGlsZXIgb3Igb3RoZXJ3aXNlKVxuICogaW5kaWNhdGluZyBmaWxlbmFtZSwgbGluZSBudW1iZXIsIGFuZC9vciBvdGhlciBpbmZvcm1hdGlvbi5cbiAqIEBpbnRlcm5hbFxuICovXG5cblxudmFyIFJlYWN0RWxlbWVudCA9IGZ1bmN0aW9uICh0eXBlLCBrZXksIHJlZiwgc2VsZiwgc291cmNlLCBvd25lciwgcHJvcHMpIHtcbiAgdmFyIGVsZW1lbnQgPSB7XG4gICAgLy8gVGhpcyB0YWcgYWxsb3dzIHVzIHRvIHVuaXF1ZWx5IGlkZW50aWZ5IHRoaXMgYXMgYSBSZWFjdCBFbGVtZW50XG4gICAgJCR0eXBlb2Y6IFJFQUNUX0VMRU1FTlRfVFlQRSxcbiAgICAvLyBCdWlsdC1pbiBwcm9wZXJ0aWVzIHRoYXQgYmVsb25nIG9uIHRoZSBlbGVtZW50XG4gICAgdHlwZTogdHlwZSxcbiAgICBrZXk6IGtleSxcbiAgICByZWY6IHJlZixcbiAgICBwcm9wczogcHJvcHMsXG4gICAgLy8gUmVjb3JkIHRoZSBjb21wb25lbnQgcmVzcG9uc2libGUgZm9yIGNyZWF0aW5nIHRoaXMgZWxlbWVudC5cbiAgICBfb3duZXI6IG93bmVyXG4gIH07XG5cbiAge1xuICAgIC8vIFRoZSB2YWxpZGF0aW9uIGZsYWcgaXMgY3VycmVudGx5IG11dGF0aXZlLiBXZSBwdXQgaXQgb25cbiAgICAvLyBhbiBleHRlcm5hbCBiYWNraW5nIHN0b3JlIHNvIHRoYXQgd2UgY2FuIGZyZWV6ZSB0aGUgd2hvbGUgb2JqZWN0LlxuICAgIC8vIFRoaXMgY2FuIGJlIHJlcGxhY2VkIHdpdGggYSBXZWFrTWFwIG9uY2UgdGhleSBhcmUgaW1wbGVtZW50ZWQgaW5cbiAgICAvLyBjb21tb25seSB1c2VkIGRldmVsb3BtZW50IGVudmlyb25tZW50cy5cbiAgICBlbGVtZW50Ll9zdG9yZSA9IHt9OyAvLyBUbyBtYWtlIGNvbXBhcmluZyBSZWFjdEVsZW1lbnRzIGVhc2llciBmb3IgdGVzdGluZyBwdXJwb3Nlcywgd2UgbWFrZVxuICAgIC8vIHRoZSB2YWxpZGF0aW9uIGZsYWcgbm9uLWVudW1lcmFibGUgKHdoZXJlIHBvc3NpYmxlLCB3aGljaCBzaG91bGRcbiAgICAvLyBpbmNsdWRlIGV2ZXJ5IGVudmlyb25tZW50IHdlIHJ1biB0ZXN0cyBpbiksIHNvIHRoZSB0ZXN0IGZyYW1ld29ya1xuICAgIC8vIGlnbm9yZXMgaXQuXG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudC5fc3RvcmUsICd2YWxpZGF0ZWQnLCB7XG4gICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIHZhbHVlOiBmYWxzZVxuICAgIH0pOyAvLyBzZWxmIGFuZCBzb3VyY2UgYXJlIERFViBvbmx5IHByb3BlcnRpZXMuXG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudCwgJ19zZWxmJywge1xuICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgdmFsdWU6IHNlbGZcbiAgICB9KTsgLy8gVHdvIGVsZW1lbnRzIGNyZWF0ZWQgaW4gdHdvIGRpZmZlcmVudCBwbGFjZXMgc2hvdWxkIGJlIGNvbnNpZGVyZWRcbiAgICAvLyBlcXVhbCBmb3IgdGVzdGluZyBwdXJwb3NlcyBhbmQgdGhlcmVmb3JlIHdlIGhpZGUgaXQgZnJvbSBlbnVtZXJhdGlvbi5cblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbGVtZW50LCAnX3NvdXJjZScsIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgIHZhbHVlOiBzb3VyY2VcbiAgICB9KTtcblxuICAgIGlmIChPYmplY3QuZnJlZXplKSB7XG4gICAgICBPYmplY3QuZnJlZXplKGVsZW1lbnQucHJvcHMpO1xuICAgICAgT2JqZWN0LmZyZWV6ZShlbGVtZW50KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZWxlbWVudDtcbn07XG4vKipcbiAqIENyZWF0ZSBhbmQgcmV0dXJuIGEgbmV3IFJlYWN0RWxlbWVudCBvZiB0aGUgZ2l2ZW4gdHlwZS5cbiAqIFNlZSBodHRwczovL3JlYWN0anMub3JnL2RvY3MvcmVhY3QtYXBpLmh0bWwjY3JlYXRlZWxlbWVudFxuICovXG5cbmZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnQodHlwZSwgY29uZmlnLCBjaGlsZHJlbikge1xuICB2YXIgcHJvcE5hbWU7IC8vIFJlc2VydmVkIG5hbWVzIGFyZSBleHRyYWN0ZWRcblxuICB2YXIgcHJvcHMgPSB7fTtcbiAgdmFyIGtleSA9IG51bGw7XG4gIHZhciByZWYgPSBudWxsO1xuICB2YXIgc2VsZiA9IG51bGw7XG4gIHZhciBzb3VyY2UgPSBudWxsO1xuXG4gIGlmIChjb25maWcgIT0gbnVsbCkge1xuICAgIGlmIChoYXNWYWxpZFJlZihjb25maWcpKSB7XG4gICAgICByZWYgPSBjb25maWcucmVmO1xuXG4gICAgICB7XG4gICAgICAgIHdhcm5JZlN0cmluZ1JlZkNhbm5vdEJlQXV0b0NvbnZlcnRlZChjb25maWcpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChoYXNWYWxpZEtleShjb25maWcpKSB7XG4gICAgICBrZXkgPSAnJyArIGNvbmZpZy5rZXk7XG4gICAgfVxuXG4gICAgc2VsZiA9IGNvbmZpZy5fX3NlbGYgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBjb25maWcuX19zZWxmO1xuICAgIHNvdXJjZSA9IGNvbmZpZy5fX3NvdXJjZSA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IGNvbmZpZy5fX3NvdXJjZTsgLy8gUmVtYWluaW5nIHByb3BlcnRpZXMgYXJlIGFkZGVkIHRvIGEgbmV3IHByb3BzIG9iamVjdFxuXG4gICAgZm9yIChwcm9wTmFtZSBpbiBjb25maWcpIHtcbiAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgcHJvcE5hbWUpICYmICFSRVNFUlZFRF9QUk9QUy5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkpIHtcbiAgICAgICAgcHJvcHNbcHJvcE5hbWVdID0gY29uZmlnW3Byb3BOYW1lXTtcbiAgICAgIH1cbiAgICB9XG4gIH0gLy8gQ2hpbGRyZW4gY2FuIGJlIG1vcmUgdGhhbiBvbmUgYXJndW1lbnQsIGFuZCB0aG9zZSBhcmUgdHJhbnNmZXJyZWQgb250b1xuICAvLyB0aGUgbmV3bHkgYWxsb2NhdGVkIHByb3BzIG9iamVjdC5cblxuXG4gIHZhciBjaGlsZHJlbkxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGggLSAyO1xuXG4gIGlmIChjaGlsZHJlbkxlbmd0aCA9PT0gMSkge1xuICAgIHByb3BzLmNoaWxkcmVuID0gY2hpbGRyZW47XG4gIH0gZWxzZSBpZiAoY2hpbGRyZW5MZW5ndGggPiAxKSB7XG4gICAgdmFyIGNoaWxkQXJyYXkgPSBBcnJheShjaGlsZHJlbkxlbmd0aCk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuTGVuZ3RoOyBpKyspIHtcbiAgICAgIGNoaWxkQXJyYXlbaV0gPSBhcmd1bWVudHNbaSArIDJdO1xuICAgIH1cblxuICAgIHtcbiAgICAgIGlmIChPYmplY3QuZnJlZXplKSB7XG4gICAgICAgIE9iamVjdC5mcmVlemUoY2hpbGRBcnJheSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcHJvcHMuY2hpbGRyZW4gPSBjaGlsZEFycmF5O1xuICB9IC8vIFJlc29sdmUgZGVmYXVsdCBwcm9wc1xuXG5cbiAgaWYgKHR5cGUgJiYgdHlwZS5kZWZhdWx0UHJvcHMpIHtcbiAgICB2YXIgZGVmYXVsdFByb3BzID0gdHlwZS5kZWZhdWx0UHJvcHM7XG5cbiAgICBmb3IgKHByb3BOYW1lIGluIGRlZmF1bHRQcm9wcykge1xuICAgICAgaWYgKHByb3BzW3Byb3BOYW1lXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHByb3BzW3Byb3BOYW1lXSA9IGRlZmF1bHRQcm9wc1twcm9wTmFtZV07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAge1xuICAgIGlmIChrZXkgfHwgcmVmKSB7XG4gICAgICB2YXIgZGlzcGxheU5hbWUgPSB0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJyA/IHR5cGUuZGlzcGxheU5hbWUgfHwgdHlwZS5uYW1lIHx8ICdVbmtub3duJyA6IHR5cGU7XG5cbiAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgZGVmaW5lS2V5UHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHJlZikge1xuICAgICAgICBkZWZpbmVSZWZQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBSZWFjdEVsZW1lbnQodHlwZSwga2V5LCByZWYsIHNlbGYsIHNvdXJjZSwgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCwgcHJvcHMpO1xufVxuZnVuY3Rpb24gY2xvbmVBbmRSZXBsYWNlS2V5KG9sZEVsZW1lbnQsIG5ld0tleSkge1xuICB2YXIgbmV3RWxlbWVudCA9IFJlYWN0RWxlbWVudChvbGRFbGVtZW50LnR5cGUsIG5ld0tleSwgb2xkRWxlbWVudC5yZWYsIG9sZEVsZW1lbnQuX3NlbGYsIG9sZEVsZW1lbnQuX3NvdXJjZSwgb2xkRWxlbWVudC5fb3duZXIsIG9sZEVsZW1lbnQucHJvcHMpO1xuICByZXR1cm4gbmV3RWxlbWVudDtcbn1cbi8qKlxuICogQ2xvbmUgYW5kIHJldHVybiBhIG5ldyBSZWFjdEVsZW1lbnQgdXNpbmcgZWxlbWVudCBhcyB0aGUgc3RhcnRpbmcgcG9pbnQuXG4gKiBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL3JlYWN0LWFwaS5odG1sI2Nsb25lZWxlbWVudFxuICovXG5cbmZ1bmN0aW9uIGNsb25lRWxlbWVudChlbGVtZW50LCBjb25maWcsIGNoaWxkcmVuKSB7XG4gIGlmICghIShlbGVtZW50ID09PSBudWxsIHx8IGVsZW1lbnQgPT09IHVuZGVmaW5lZCkpIHtcbiAgICB7XG4gICAgICB0aHJvdyBFcnJvciggXCJSZWFjdC5jbG9uZUVsZW1lbnQoLi4uKTogVGhlIGFyZ3VtZW50IG11c3QgYmUgYSBSZWFjdCBlbGVtZW50LCBidXQgeW91IHBhc3NlZCBcIiArIGVsZW1lbnQgKyBcIi5cIiApO1xuICAgIH1cbiAgfVxuXG4gIHZhciBwcm9wTmFtZTsgLy8gT3JpZ2luYWwgcHJvcHMgYXJlIGNvcGllZFxuXG4gIHZhciBwcm9wcyA9IF9hc3NpZ24oe30sIGVsZW1lbnQucHJvcHMpOyAvLyBSZXNlcnZlZCBuYW1lcyBhcmUgZXh0cmFjdGVkXG5cblxuICB2YXIga2V5ID0gZWxlbWVudC5rZXk7XG4gIHZhciByZWYgPSBlbGVtZW50LnJlZjsgLy8gU2VsZiBpcyBwcmVzZXJ2ZWQgc2luY2UgdGhlIG93bmVyIGlzIHByZXNlcnZlZC5cblxuICB2YXIgc2VsZiA9IGVsZW1lbnQuX3NlbGY7IC8vIFNvdXJjZSBpcyBwcmVzZXJ2ZWQgc2luY2UgY2xvbmVFbGVtZW50IGlzIHVubGlrZWx5IHRvIGJlIHRhcmdldGVkIGJ5IGFcbiAgLy8gdHJhbnNwaWxlciwgYW5kIHRoZSBvcmlnaW5hbCBzb3VyY2UgaXMgcHJvYmFibHkgYSBiZXR0ZXIgaW5kaWNhdG9yIG9mIHRoZVxuICAvLyB0cnVlIG93bmVyLlxuXG4gIHZhciBzb3VyY2UgPSBlbGVtZW50Ll9zb3VyY2U7IC8vIE93bmVyIHdpbGwgYmUgcHJlc2VydmVkLCB1bmxlc3MgcmVmIGlzIG92ZXJyaWRkZW5cblxuICB2YXIgb3duZXIgPSBlbGVtZW50Ll9vd25lcjtcblxuICBpZiAoY29uZmlnICE9IG51bGwpIHtcbiAgICBpZiAoaGFzVmFsaWRSZWYoY29uZmlnKSkge1xuICAgICAgLy8gU2lsZW50bHkgc3RlYWwgdGhlIHJlZiBmcm9tIHRoZSBwYXJlbnQuXG4gICAgICByZWYgPSBjb25maWcucmVmO1xuICAgICAgb3duZXIgPSBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50O1xuICAgIH1cblxuICAgIGlmIChoYXNWYWxpZEtleShjb25maWcpKSB7XG4gICAgICBrZXkgPSAnJyArIGNvbmZpZy5rZXk7XG4gICAgfSAvLyBSZW1haW5pbmcgcHJvcGVydGllcyBvdmVycmlkZSBleGlzdGluZyBwcm9wc1xuXG5cbiAgICB2YXIgZGVmYXVsdFByb3BzO1xuXG4gICAgaWYgKGVsZW1lbnQudHlwZSAmJiBlbGVtZW50LnR5cGUuZGVmYXVsdFByb3BzKSB7XG4gICAgICBkZWZhdWx0UHJvcHMgPSBlbGVtZW50LnR5cGUuZGVmYXVsdFByb3BzO1xuICAgIH1cblxuICAgIGZvciAocHJvcE5hbWUgaW4gY29uZmlnKSB7XG4gICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChjb25maWcsIHByb3BOYW1lKSAmJiAhUkVTRVJWRURfUFJPUFMuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpKSB7XG4gICAgICAgIGlmIChjb25maWdbcHJvcE5hbWVdID09PSB1bmRlZmluZWQgJiYgZGVmYXVsdFByb3BzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAvLyBSZXNvbHZlIGRlZmF1bHQgcHJvcHNcbiAgICAgICAgICBwcm9wc1twcm9wTmFtZV0gPSBkZWZhdWx0UHJvcHNbcHJvcE5hbWVdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHByb3BzW3Byb3BOYW1lXSA9IGNvbmZpZ1twcm9wTmFtZV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0gLy8gQ2hpbGRyZW4gY2FuIGJlIG1vcmUgdGhhbiBvbmUgYXJndW1lbnQsIGFuZCB0aG9zZSBhcmUgdHJhbnNmZXJyZWQgb250b1xuICAvLyB0aGUgbmV3bHkgYWxsb2NhdGVkIHByb3BzIG9iamVjdC5cblxuXG4gIHZhciBjaGlsZHJlbkxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGggLSAyO1xuXG4gIGlmIChjaGlsZHJlbkxlbmd0aCA9PT0gMSkge1xuICAgIHByb3BzLmNoaWxkcmVuID0gY2hpbGRyZW47XG4gIH0gZWxzZSBpZiAoY2hpbGRyZW5MZW5ndGggPiAxKSB7XG4gICAgdmFyIGNoaWxkQXJyYXkgPSBBcnJheShjaGlsZHJlbkxlbmd0aCk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuTGVuZ3RoOyBpKyspIHtcbiAgICAgIGNoaWxkQXJyYXlbaV0gPSBhcmd1bWVudHNbaSArIDJdO1xuICAgIH1cblxuICAgIHByb3BzLmNoaWxkcmVuID0gY2hpbGRBcnJheTtcbiAgfVxuXG4gIHJldHVybiBSZWFjdEVsZW1lbnQoZWxlbWVudC50eXBlLCBrZXksIHJlZiwgc2VsZiwgc291cmNlLCBvd25lciwgcHJvcHMpO1xufVxuLyoqXG4gKiBWZXJpZmllcyB0aGUgb2JqZWN0IGlzIGEgUmVhY3RFbGVtZW50LlxuICogU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9yZWFjdC1hcGkuaHRtbCNpc3ZhbGlkZWxlbWVudFxuICogQHBhcmFtIHs/b2JqZWN0fSBvYmplY3RcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgYG9iamVjdGAgaXMgYSBSZWFjdEVsZW1lbnQuXG4gKiBAZmluYWxcbiAqL1xuXG5mdW5jdGlvbiBpc1ZhbGlkRWxlbWVudChvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVvZiBvYmplY3QgPT09ICdvYmplY3QnICYmIG9iamVjdCAhPT0gbnVsbCAmJiBvYmplY3QuJCR0eXBlb2YgPT09IFJFQUNUX0VMRU1FTlRfVFlQRTtcbn1cblxudmFyIFNFUEFSQVRPUiA9ICcuJztcbnZhciBTVUJTRVBBUkFUT1IgPSAnOic7XG4vKipcbiAqIEVzY2FwZSBhbmQgd3JhcCBrZXkgc28gaXQgaXMgc2FmZSB0byB1c2UgYXMgYSByZWFjdGlkXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSB0byBiZSBlc2NhcGVkLlxuICogQHJldHVybiB7c3RyaW5nfSB0aGUgZXNjYXBlZCBrZXkuXG4gKi9cblxuZnVuY3Rpb24gZXNjYXBlKGtleSkge1xuICB2YXIgZXNjYXBlUmVnZXggPSAvWz06XS9nO1xuICB2YXIgZXNjYXBlckxvb2t1cCA9IHtcbiAgICAnPSc6ICc9MCcsXG4gICAgJzonOiAnPTInXG4gIH07XG4gIHZhciBlc2NhcGVkU3RyaW5nID0ga2V5LnJlcGxhY2UoZXNjYXBlUmVnZXgsIGZ1bmN0aW9uIChtYXRjaCkge1xuICAgIHJldHVybiBlc2NhcGVyTG9va3VwW21hdGNoXTtcbiAgfSk7XG4gIHJldHVybiAnJCcgKyBlc2NhcGVkU3RyaW5nO1xufVxuLyoqXG4gKiBUT0RPOiBUZXN0IHRoYXQgYSBzaW5nbGUgY2hpbGQgYW5kIGFuIGFycmF5IHdpdGggb25lIGl0ZW0gaGF2ZSB0aGUgc2FtZSBrZXlcbiAqIHBhdHRlcm4uXG4gKi9cblxuXG52YXIgZGlkV2FybkFib3V0TWFwcyA9IGZhbHNlO1xudmFyIHVzZXJQcm92aWRlZEtleUVzY2FwZVJlZ2V4ID0gL1xcLysvZztcblxuZnVuY3Rpb24gZXNjYXBlVXNlclByb3ZpZGVkS2V5KHRleHQpIHtcbiAgcmV0dXJuIHRleHQucmVwbGFjZSh1c2VyUHJvdmlkZWRLZXlFc2NhcGVSZWdleCwgJyQmLycpO1xufVxuLyoqXG4gKiBHZW5lcmF0ZSBhIGtleSBzdHJpbmcgdGhhdCBpZGVudGlmaWVzIGEgZWxlbWVudCB3aXRoaW4gYSBzZXQuXG4gKlxuICogQHBhcmFtIHsqfSBlbGVtZW50IEEgZWxlbWVudCB0aGF0IGNvdWxkIGNvbnRhaW4gYSBtYW51YWwga2V5LlxuICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IEluZGV4IHRoYXQgaXMgdXNlZCBpZiBhIG1hbnVhbCBrZXkgaXMgbm90IHByb3ZpZGVkLlxuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5cblxuZnVuY3Rpb24gZ2V0RWxlbWVudEtleShlbGVtZW50LCBpbmRleCkge1xuICAvLyBEbyBzb21lIHR5cGVjaGVja2luZyBoZXJlIHNpbmNlIHdlIGNhbGwgdGhpcyBibGluZGx5LiBXZSB3YW50IHRvIGVuc3VyZVxuICAvLyB0aGF0IHdlIGRvbid0IGJsb2NrIHBvdGVudGlhbCBmdXR1cmUgRVMgQVBJcy5cbiAgaWYgKHR5cGVvZiBlbGVtZW50ID09PSAnb2JqZWN0JyAmJiBlbGVtZW50ICE9PSBudWxsICYmIGVsZW1lbnQua2V5ICE9IG51bGwpIHtcbiAgICAvLyBFeHBsaWNpdCBrZXlcbiAgICByZXR1cm4gZXNjYXBlKCcnICsgZWxlbWVudC5rZXkpO1xuICB9IC8vIEltcGxpY2l0IGtleSBkZXRlcm1pbmVkIGJ5IHRoZSBpbmRleCBpbiB0aGUgc2V0XG5cblxuICByZXR1cm4gaW5kZXgudG9TdHJpbmcoMzYpO1xufVxuXG5mdW5jdGlvbiBtYXBJbnRvQXJyYXkoY2hpbGRyZW4sIGFycmF5LCBlc2NhcGVkUHJlZml4LCBuYW1lU29GYXIsIGNhbGxiYWNrKSB7XG4gIHZhciB0eXBlID0gdHlwZW9mIGNoaWxkcmVuO1xuXG4gIGlmICh0eXBlID09PSAndW5kZWZpbmVkJyB8fCB0eXBlID09PSAnYm9vbGVhbicpIHtcbiAgICAvLyBBbGwgb2YgdGhlIGFib3ZlIGFyZSBwZXJjZWl2ZWQgYXMgbnVsbC5cbiAgICBjaGlsZHJlbiA9IG51bGw7XG4gIH1cblxuICB2YXIgaW52b2tlQ2FsbGJhY2sgPSBmYWxzZTtcblxuICBpZiAoY2hpbGRyZW4gPT09IG51bGwpIHtcbiAgICBpbnZva2VDYWxsYmFjayA9IHRydWU7XG4gIH0gZWxzZSB7XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgaW52b2tlQ2FsbGJhY2sgPSB0cnVlO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgc3dpdGNoIChjaGlsZHJlbi4kJHR5cGVvZikge1xuICAgICAgICAgIGNhc2UgUkVBQ1RfRUxFTUVOVF9UWVBFOlxuICAgICAgICAgIGNhc2UgUkVBQ1RfUE9SVEFMX1RZUEU6XG4gICAgICAgICAgICBpbnZva2VDYWxsYmFjayA9IHRydWU7XG4gICAgICAgIH1cblxuICAgIH1cbiAgfVxuXG4gIGlmIChpbnZva2VDYWxsYmFjaykge1xuICAgIHZhciBfY2hpbGQgPSBjaGlsZHJlbjtcbiAgICB2YXIgbWFwcGVkQ2hpbGQgPSBjYWxsYmFjayhfY2hpbGQpOyAvLyBJZiBpdCdzIHRoZSBvbmx5IGNoaWxkLCB0cmVhdCB0aGUgbmFtZSBhcyBpZiBpdCB3YXMgd3JhcHBlZCBpbiBhbiBhcnJheVxuICAgIC8vIHNvIHRoYXQgaXQncyBjb25zaXN0ZW50IGlmIHRoZSBudW1iZXIgb2YgY2hpbGRyZW4gZ3Jvd3M6XG5cbiAgICB2YXIgY2hpbGRLZXkgPSBuYW1lU29GYXIgPT09ICcnID8gU0VQQVJBVE9SICsgZ2V0RWxlbWVudEtleShfY2hpbGQsIDApIDogbmFtZVNvRmFyO1xuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkobWFwcGVkQ2hpbGQpKSB7XG4gICAgICB2YXIgZXNjYXBlZENoaWxkS2V5ID0gJyc7XG5cbiAgICAgIGlmIChjaGlsZEtleSAhPSBudWxsKSB7XG4gICAgICAgIGVzY2FwZWRDaGlsZEtleSA9IGVzY2FwZVVzZXJQcm92aWRlZEtleShjaGlsZEtleSkgKyAnLyc7XG4gICAgICB9XG5cbiAgICAgIG1hcEludG9BcnJheShtYXBwZWRDaGlsZCwgYXJyYXksIGVzY2FwZWRDaGlsZEtleSwgJycsIGZ1bmN0aW9uIChjKSB7XG4gICAgICAgIHJldHVybiBjO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChtYXBwZWRDaGlsZCAhPSBudWxsKSB7XG4gICAgICBpZiAoaXNWYWxpZEVsZW1lbnQobWFwcGVkQ2hpbGQpKSB7XG4gICAgICAgIG1hcHBlZENoaWxkID0gY2xvbmVBbmRSZXBsYWNlS2V5KG1hcHBlZENoaWxkLCAvLyBLZWVwIGJvdGggdGhlIChtYXBwZWQpIGFuZCBvbGQga2V5cyBpZiB0aGV5IGRpZmZlciwganVzdCBhc1xuICAgICAgICAvLyB0cmF2ZXJzZUFsbENoaWxkcmVuIHVzZWQgdG8gZG8gZm9yIG9iamVjdHMgYXMgY2hpbGRyZW5cbiAgICAgICAgZXNjYXBlZFByZWZpeCArICggLy8gJEZsb3dGaXhNZSBGbG93IGluY29ycmVjdGx5IHRoaW5rcyBSZWFjdC5Qb3J0YWwgZG9lc24ndCBoYXZlIGEga2V5XG4gICAgICAgIG1hcHBlZENoaWxkLmtleSAmJiAoIV9jaGlsZCB8fCBfY2hpbGQua2V5ICE9PSBtYXBwZWRDaGlsZC5rZXkpID8gLy8gJEZsb3dGaXhNZSBGbG93IGluY29ycmVjdGx5IHRoaW5rcyBleGlzdGluZyBlbGVtZW50J3Mga2V5IGNhbiBiZSBhIG51bWJlclxuICAgICAgICBlc2NhcGVVc2VyUHJvdmlkZWRLZXkoJycgKyBtYXBwZWRDaGlsZC5rZXkpICsgJy8nIDogJycpICsgY2hpbGRLZXkpO1xuICAgICAgfVxuXG4gICAgICBhcnJheS5wdXNoKG1hcHBlZENoaWxkKTtcbiAgICB9XG5cbiAgICByZXR1cm4gMTtcbiAgfVxuXG4gIHZhciBjaGlsZDtcbiAgdmFyIG5leHROYW1lO1xuICB2YXIgc3VidHJlZUNvdW50ID0gMDsgLy8gQ291bnQgb2YgY2hpbGRyZW4gZm91bmQgaW4gdGhlIGN1cnJlbnQgc3VidHJlZS5cblxuICB2YXIgbmV4dE5hbWVQcmVmaXggPSBuYW1lU29GYXIgPT09ICcnID8gU0VQQVJBVE9SIDogbmFtZVNvRmFyICsgU1VCU0VQQVJBVE9SO1xuXG4gIGlmIChBcnJheS5pc0FycmF5KGNoaWxkcmVuKSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNoaWxkID0gY2hpbGRyZW5baV07XG4gICAgICBuZXh0TmFtZSA9IG5leHROYW1lUHJlZml4ICsgZ2V0RWxlbWVudEtleShjaGlsZCwgaSk7XG4gICAgICBzdWJ0cmVlQ291bnQgKz0gbWFwSW50b0FycmF5KGNoaWxkLCBhcnJheSwgZXNjYXBlZFByZWZpeCwgbmV4dE5hbWUsIGNhbGxiYWNrKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIGl0ZXJhdG9yRm4gPSBnZXRJdGVyYXRvckZuKGNoaWxkcmVuKTtcblxuICAgIGlmICh0eXBlb2YgaXRlcmF0b3JGbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdmFyIGl0ZXJhYmxlQ2hpbGRyZW4gPSBjaGlsZHJlbjtcblxuICAgICAge1xuICAgICAgICAvLyBXYXJuIGFib3V0IHVzaW5nIE1hcHMgYXMgY2hpbGRyZW5cbiAgICAgICAgaWYgKGl0ZXJhdG9yRm4gPT09IGl0ZXJhYmxlQ2hpbGRyZW4uZW50cmllcykge1xuICAgICAgICAgIGlmICghZGlkV2FybkFib3V0TWFwcykge1xuICAgICAgICAgICAgd2FybignVXNpbmcgTWFwcyBhcyBjaGlsZHJlbiBpcyBub3Qgc3VwcG9ydGVkLiAnICsgJ1VzZSBhbiBhcnJheSBvZiBrZXllZCBSZWFjdEVsZW1lbnRzIGluc3RlYWQuJyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZGlkV2FybkFib3V0TWFwcyA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIGl0ZXJhdG9yID0gaXRlcmF0b3JGbi5jYWxsKGl0ZXJhYmxlQ2hpbGRyZW4pO1xuICAgICAgdmFyIHN0ZXA7XG4gICAgICB2YXIgaWkgPSAwO1xuXG4gICAgICB3aGlsZSAoIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lKSB7XG4gICAgICAgIGNoaWxkID0gc3RlcC52YWx1ZTtcbiAgICAgICAgbmV4dE5hbWUgPSBuZXh0TmFtZVByZWZpeCArIGdldEVsZW1lbnRLZXkoY2hpbGQsIGlpKyspO1xuICAgICAgICBzdWJ0cmVlQ291bnQgKz0gbWFwSW50b0FycmF5KGNoaWxkLCBhcnJheSwgZXNjYXBlZFByZWZpeCwgbmV4dE5hbWUsIGNhbGxiYWNrKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgICB2YXIgY2hpbGRyZW5TdHJpbmcgPSAnJyArIGNoaWxkcmVuO1xuXG4gICAgICB7XG4gICAgICAgIHtcbiAgICAgICAgICB0aHJvdyBFcnJvciggXCJPYmplY3RzIGFyZSBub3QgdmFsaWQgYXMgYSBSZWFjdCBjaGlsZCAoZm91bmQ6IFwiICsgKGNoaWxkcmVuU3RyaW5nID09PSAnW29iamVjdCBPYmplY3RdJyA/ICdvYmplY3Qgd2l0aCBrZXlzIHsnICsgT2JqZWN0LmtleXMoY2hpbGRyZW4pLmpvaW4oJywgJykgKyAnfScgOiBjaGlsZHJlblN0cmluZykgKyBcIikuIElmIHlvdSBtZWFudCB0byByZW5kZXIgYSBjb2xsZWN0aW9uIG9mIGNoaWxkcmVuLCB1c2UgYW4gYXJyYXkgaW5zdGVhZC5cIiApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHN1YnRyZWVDb3VudDtcbn1cblxuLyoqXG4gKiBNYXBzIGNoaWxkcmVuIHRoYXQgYXJlIHR5cGljYWxseSBzcGVjaWZpZWQgYXMgYHByb3BzLmNoaWxkcmVuYC5cbiAqXG4gKiBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL3JlYWN0LWFwaS5odG1sI3JlYWN0Y2hpbGRyZW5tYXBcbiAqXG4gKiBUaGUgcHJvdmlkZWQgbWFwRnVuY3Rpb24oY2hpbGQsIGluZGV4KSB3aWxsIGJlIGNhbGxlZCBmb3IgZWFjaFxuICogbGVhZiBjaGlsZC5cbiAqXG4gKiBAcGFyYW0gez8qfSBjaGlsZHJlbiBDaGlsZHJlbiB0cmVlIGNvbnRhaW5lci5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oKiwgaW50KX0gZnVuYyBUaGUgbWFwIGZ1bmN0aW9uLlxuICogQHBhcmFtIHsqfSBjb250ZXh0IENvbnRleHQgZm9yIG1hcEZ1bmN0aW9uLlxuICogQHJldHVybiB7b2JqZWN0fSBPYmplY3QgY29udGFpbmluZyB0aGUgb3JkZXJlZCBtYXAgb2YgcmVzdWx0cy5cbiAqL1xuZnVuY3Rpb24gbWFwQ2hpbGRyZW4oY2hpbGRyZW4sIGZ1bmMsIGNvbnRleHQpIHtcbiAgaWYgKGNoaWxkcmVuID09IG51bGwpIHtcbiAgICByZXR1cm4gY2hpbGRyZW47XG4gIH1cblxuICB2YXIgcmVzdWx0ID0gW107XG4gIHZhciBjb3VudCA9IDA7XG4gIG1hcEludG9BcnJheShjaGlsZHJlbiwgcmVzdWx0LCAnJywgJycsIGZ1bmN0aW9uIChjaGlsZCkge1xuICAgIHJldHVybiBmdW5jLmNhbGwoY29udGV4dCwgY2hpbGQsIGNvdW50KyspO1xuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cbi8qKlxuICogQ291bnQgdGhlIG51bWJlciBvZiBjaGlsZHJlbiB0aGF0IGFyZSB0eXBpY2FsbHkgc3BlY2lmaWVkIGFzXG4gKiBgcHJvcHMuY2hpbGRyZW5gLlxuICpcbiAqIFNlZSBodHRwczovL3JlYWN0anMub3JnL2RvY3MvcmVhY3QtYXBpLmh0bWwjcmVhY3RjaGlsZHJlbmNvdW50XG4gKlxuICogQHBhcmFtIHs/Kn0gY2hpbGRyZW4gQ2hpbGRyZW4gdHJlZSBjb250YWluZXIuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBudW1iZXIgb2YgY2hpbGRyZW4uXG4gKi9cblxuXG5mdW5jdGlvbiBjb3VudENoaWxkcmVuKGNoaWxkcmVuKSB7XG4gIHZhciBuID0gMDtcbiAgbWFwQ2hpbGRyZW4oY2hpbGRyZW4sIGZ1bmN0aW9uICgpIHtcbiAgICBuKys7IC8vIERvbid0IHJldHVybiBhbnl0aGluZ1xuICB9KTtcbiAgcmV0dXJuIG47XG59XG5cbi8qKlxuICogSXRlcmF0ZXMgdGhyb3VnaCBjaGlsZHJlbiB0aGF0IGFyZSB0eXBpY2FsbHkgc3BlY2lmaWVkIGFzIGBwcm9wcy5jaGlsZHJlbmAuXG4gKlxuICogU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9yZWFjdC1hcGkuaHRtbCNyZWFjdGNoaWxkcmVuZm9yZWFjaFxuICpcbiAqIFRoZSBwcm92aWRlZCBmb3JFYWNoRnVuYyhjaGlsZCwgaW5kZXgpIHdpbGwgYmUgY2FsbGVkIGZvciBlYWNoXG4gKiBsZWFmIGNoaWxkLlxuICpcbiAqIEBwYXJhbSB7Pyp9IGNoaWxkcmVuIENoaWxkcmVuIHRyZWUgY29udGFpbmVyLlxuICogQHBhcmFtIHtmdW5jdGlvbigqLCBpbnQpfSBmb3JFYWNoRnVuY1xuICogQHBhcmFtIHsqfSBmb3JFYWNoQ29udGV4dCBDb250ZXh0IGZvciBmb3JFYWNoQ29udGV4dC5cbiAqL1xuZnVuY3Rpb24gZm9yRWFjaENoaWxkcmVuKGNoaWxkcmVuLCBmb3JFYWNoRnVuYywgZm9yRWFjaENvbnRleHQpIHtcbiAgbWFwQ2hpbGRyZW4oY2hpbGRyZW4sIGZ1bmN0aW9uICgpIHtcbiAgICBmb3JFYWNoRnVuYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyAvLyBEb24ndCByZXR1cm4gYW55dGhpbmcuXG4gIH0sIGZvckVhY2hDb250ZXh0KTtcbn1cbi8qKlxuICogRmxhdHRlbiBhIGNoaWxkcmVuIG9iamVjdCAodHlwaWNhbGx5IHNwZWNpZmllZCBhcyBgcHJvcHMuY2hpbGRyZW5gKSBhbmRcbiAqIHJldHVybiBhbiBhcnJheSB3aXRoIGFwcHJvcHJpYXRlbHkgcmUta2V5ZWQgY2hpbGRyZW4uXG4gKlxuICogU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9yZWFjdC1hcGkuaHRtbCNyZWFjdGNoaWxkcmVudG9hcnJheVxuICovXG5cblxuZnVuY3Rpb24gdG9BcnJheShjaGlsZHJlbikge1xuICByZXR1cm4gbWFwQ2hpbGRyZW4oY2hpbGRyZW4sIGZ1bmN0aW9uIChjaGlsZCkge1xuICAgIHJldHVybiBjaGlsZDtcbiAgfSkgfHwgW107XG59XG4vKipcbiAqIFJldHVybnMgdGhlIGZpcnN0IGNoaWxkIGluIGEgY29sbGVjdGlvbiBvZiBjaGlsZHJlbiBhbmQgdmVyaWZpZXMgdGhhdCB0aGVyZVxuICogaXMgb25seSBvbmUgY2hpbGQgaW4gdGhlIGNvbGxlY3Rpb24uXG4gKlxuICogU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9yZWFjdC1hcGkuaHRtbCNyZWFjdGNoaWxkcmVub25seVxuICpcbiAqIFRoZSBjdXJyZW50IGltcGxlbWVudGF0aW9uIG9mIHRoaXMgZnVuY3Rpb24gYXNzdW1lcyB0aGF0IGEgc2luZ2xlIGNoaWxkIGdldHNcbiAqIHBhc3NlZCB3aXRob3V0IGEgd3JhcHBlciwgYnV0IHRoZSBwdXJwb3NlIG9mIHRoaXMgaGVscGVyIGZ1bmN0aW9uIGlzIHRvXG4gKiBhYnN0cmFjdCBhd2F5IHRoZSBwYXJ0aWN1bGFyIHN0cnVjdHVyZSBvZiBjaGlsZHJlbi5cbiAqXG4gKiBAcGFyYW0gez9vYmplY3R9IGNoaWxkcmVuIENoaWxkIGNvbGxlY3Rpb24gc3RydWN0dXJlLlxuICogQHJldHVybiB7UmVhY3RFbGVtZW50fSBUaGUgZmlyc3QgYW5kIG9ubHkgYFJlYWN0RWxlbWVudGAgY29udGFpbmVkIGluIHRoZVxuICogc3RydWN0dXJlLlxuICovXG5cblxuZnVuY3Rpb24gb25seUNoaWxkKGNoaWxkcmVuKSB7XG4gIGlmICghaXNWYWxpZEVsZW1lbnQoY2hpbGRyZW4pKSB7XG4gICAge1xuICAgICAgdGhyb3cgRXJyb3IoIFwiUmVhY3QuQ2hpbGRyZW4ub25seSBleHBlY3RlZCB0byByZWNlaXZlIGEgc2luZ2xlIFJlYWN0IGVsZW1lbnQgY2hpbGQuXCIgKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gY2hpbGRyZW47XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUNvbnRleHQoZGVmYXVsdFZhbHVlLCBjYWxjdWxhdGVDaGFuZ2VkQml0cykge1xuICBpZiAoY2FsY3VsYXRlQ2hhbmdlZEJpdHMgPT09IHVuZGVmaW5lZCkge1xuICAgIGNhbGN1bGF0ZUNoYW5nZWRCaXRzID0gbnVsbDtcbiAgfSBlbHNlIHtcbiAgICB7XG4gICAgICBpZiAoY2FsY3VsYXRlQ2hhbmdlZEJpdHMgIT09IG51bGwgJiYgdHlwZW9mIGNhbGN1bGF0ZUNoYW5nZWRCaXRzICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGVycm9yKCdjcmVhdGVDb250ZXh0OiBFeHBlY3RlZCB0aGUgb3B0aW9uYWwgc2Vjb25kIGFyZ3VtZW50IHRvIGJlIGEgJyArICdmdW5jdGlvbi4gSW5zdGVhZCByZWNlaXZlZDogJXMnLCBjYWxjdWxhdGVDaGFuZ2VkQml0cyk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdmFyIGNvbnRleHQgPSB7XG4gICAgJCR0eXBlb2Y6IFJFQUNUX0NPTlRFWFRfVFlQRSxcbiAgICBfY2FsY3VsYXRlQ2hhbmdlZEJpdHM6IGNhbGN1bGF0ZUNoYW5nZWRCaXRzLFxuICAgIC8vIEFzIGEgd29ya2Fyb3VuZCB0byBzdXBwb3J0IG11bHRpcGxlIGNvbmN1cnJlbnQgcmVuZGVyZXJzLCB3ZSBjYXRlZ29yaXplXG4gICAgLy8gc29tZSByZW5kZXJlcnMgYXMgcHJpbWFyeSBhbmQgb3RoZXJzIGFzIHNlY29uZGFyeS4gV2Ugb25seSBleHBlY3RcbiAgICAvLyB0aGVyZSB0byBiZSB0d28gY29uY3VycmVudCByZW5kZXJlcnMgYXQgbW9zdDogUmVhY3QgTmF0aXZlIChwcmltYXJ5KSBhbmRcbiAgICAvLyBGYWJyaWMgKHNlY29uZGFyeSk7IFJlYWN0IERPTSAocHJpbWFyeSkgYW5kIFJlYWN0IEFSVCAoc2Vjb25kYXJ5KS5cbiAgICAvLyBTZWNvbmRhcnkgcmVuZGVyZXJzIHN0b3JlIHRoZWlyIGNvbnRleHQgdmFsdWVzIG9uIHNlcGFyYXRlIGZpZWxkcy5cbiAgICBfY3VycmVudFZhbHVlOiBkZWZhdWx0VmFsdWUsXG4gICAgX2N1cnJlbnRWYWx1ZTI6IGRlZmF1bHRWYWx1ZSxcbiAgICAvLyBVc2VkIHRvIHRyYWNrIGhvdyBtYW55IGNvbmN1cnJlbnQgcmVuZGVyZXJzIHRoaXMgY29udGV4dCBjdXJyZW50bHlcbiAgICAvLyBzdXBwb3J0cyB3aXRoaW4gaW4gYSBzaW5nbGUgcmVuZGVyZXIuIFN1Y2ggYXMgcGFyYWxsZWwgc2VydmVyIHJlbmRlcmluZy5cbiAgICBfdGhyZWFkQ291bnQ6IDAsXG4gICAgLy8gVGhlc2UgYXJlIGNpcmN1bGFyXG4gICAgUHJvdmlkZXI6IG51bGwsXG4gICAgQ29uc3VtZXI6IG51bGxcbiAgfTtcbiAgY29udGV4dC5Qcm92aWRlciA9IHtcbiAgICAkJHR5cGVvZjogUkVBQ1RfUFJPVklERVJfVFlQRSxcbiAgICBfY29udGV4dDogY29udGV4dFxuICB9O1xuICB2YXIgaGFzV2FybmVkQWJvdXRVc2luZ05lc3RlZENvbnRleHRDb25zdW1lcnMgPSBmYWxzZTtcbiAgdmFyIGhhc1dhcm5lZEFib3V0VXNpbmdDb25zdW1lclByb3ZpZGVyID0gZmFsc2U7XG4gIHZhciBoYXNXYXJuZWRBYm91dERpc3BsYXlOYW1lT25Db25zdW1lciA9IGZhbHNlO1xuXG4gIHtcbiAgICAvLyBBIHNlcGFyYXRlIG9iamVjdCwgYnV0IHByb3hpZXMgYmFjayB0byB0aGUgb3JpZ2luYWwgY29udGV4dCBvYmplY3QgZm9yXG4gICAgLy8gYmFja3dhcmRzIGNvbXBhdGliaWxpdHkuIEl0IGhhcyBhIGRpZmZlcmVudCAkJHR5cGVvZiwgc28gd2UgY2FuIHByb3Blcmx5XG4gICAgLy8gd2FybiBmb3IgdGhlIGluY29ycmVjdCB1c2FnZSBvZiBDb250ZXh0IGFzIGEgQ29uc3VtZXIuXG4gICAgdmFyIENvbnN1bWVyID0ge1xuICAgICAgJCR0eXBlb2Y6IFJFQUNUX0NPTlRFWFRfVFlQRSxcbiAgICAgIF9jb250ZXh0OiBjb250ZXh0LFxuICAgICAgX2NhbGN1bGF0ZUNoYW5nZWRCaXRzOiBjb250ZXh0Ll9jYWxjdWxhdGVDaGFuZ2VkQml0c1xuICAgIH07IC8vICRGbG93Rml4TWU6IEZsb3cgY29tcGxhaW5zIGFib3V0IG5vdCBzZXR0aW5nIGEgdmFsdWUsIHdoaWNoIGlzIGludGVudGlvbmFsIGhlcmVcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKENvbnN1bWVyLCB7XG4gICAgICBQcm92aWRlcjoge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpZiAoIWhhc1dhcm5lZEFib3V0VXNpbmdDb25zdW1lclByb3ZpZGVyKSB7XG4gICAgICAgICAgICBoYXNXYXJuZWRBYm91dFVzaW5nQ29uc3VtZXJQcm92aWRlciA9IHRydWU7XG5cbiAgICAgICAgICAgIGVycm9yKCdSZW5kZXJpbmcgPENvbnRleHQuQ29uc3VtZXIuUHJvdmlkZXI+IGlzIG5vdCBzdXBwb3J0ZWQgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiAnICsgJ2EgZnV0dXJlIG1ham9yIHJlbGVhc2UuIERpZCB5b3UgbWVhbiB0byByZW5kZXIgPENvbnRleHQuUHJvdmlkZXI+IGluc3RlYWQ/Jyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIGNvbnRleHQuUHJvdmlkZXI7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKF9Qcm92aWRlcikge1xuICAgICAgICAgIGNvbnRleHQuUHJvdmlkZXIgPSBfUHJvdmlkZXI7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBfY3VycmVudFZhbHVlOiB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBjb250ZXh0Ll9jdXJyZW50VmFsdWU7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKF9jdXJyZW50VmFsdWUpIHtcbiAgICAgICAgICBjb250ZXh0Ll9jdXJyZW50VmFsdWUgPSBfY3VycmVudFZhbHVlO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgX2N1cnJlbnRWYWx1ZTI6IHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIGNvbnRleHQuX2N1cnJlbnRWYWx1ZTI7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKF9jdXJyZW50VmFsdWUyKSB7XG4gICAgICAgICAgY29udGV4dC5fY3VycmVudFZhbHVlMiA9IF9jdXJyZW50VmFsdWUyO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgX3RocmVhZENvdW50OiB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBjb250ZXh0Ll90aHJlYWRDb3VudDtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAoX3RocmVhZENvdW50KSB7XG4gICAgICAgICAgY29udGV4dC5fdGhyZWFkQ291bnQgPSBfdGhyZWFkQ291bnQ7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBDb25zdW1lcjoge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpZiAoIWhhc1dhcm5lZEFib3V0VXNpbmdOZXN0ZWRDb250ZXh0Q29uc3VtZXJzKSB7XG4gICAgICAgICAgICBoYXNXYXJuZWRBYm91dFVzaW5nTmVzdGVkQ29udGV4dENvbnN1bWVycyA9IHRydWU7XG5cbiAgICAgICAgICAgIGVycm9yKCdSZW5kZXJpbmcgPENvbnRleHQuQ29uc3VtZXIuQ29uc3VtZXI+IGlzIG5vdCBzdXBwb3J0ZWQgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiAnICsgJ2EgZnV0dXJlIG1ham9yIHJlbGVhc2UuIERpZCB5b3UgbWVhbiB0byByZW5kZXIgPENvbnRleHQuQ29uc3VtZXI+IGluc3RlYWQ/Jyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIGNvbnRleHQuQ29uc3VtZXI7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBkaXNwbGF5TmFtZToge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gY29udGV4dC5kaXNwbGF5TmFtZTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAoZGlzcGxheU5hbWUpIHtcbiAgICAgICAgICBpZiAoIWhhc1dhcm5lZEFib3V0RGlzcGxheU5hbWVPbkNvbnN1bWVyKSB7XG4gICAgICAgICAgICB3YXJuKCdTZXR0aW5nIGBkaXNwbGF5TmFtZWAgb24gQ29udGV4dC5Db25zdW1lciBoYXMgbm8gZWZmZWN0LiAnICsgXCJZb3Ugc2hvdWxkIHNldCBpdCBkaXJlY3RseSBvbiB0aGUgY29udGV4dCB3aXRoIENvbnRleHQuZGlzcGxheU5hbWUgPSAnJXMnLlwiLCBkaXNwbGF5TmFtZSk7XG5cbiAgICAgICAgICAgIGhhc1dhcm5lZEFib3V0RGlzcGxheU5hbWVPbkNvbnN1bWVyID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTsgLy8gJEZsb3dGaXhNZTogRmxvdyBjb21wbGFpbnMgYWJvdXQgbWlzc2luZyBwcm9wZXJ0aWVzIGJlY2F1c2UgaXQgZG9lc24ndCB1bmRlcnN0YW5kIGRlZmluZVByb3BlcnR5XG5cbiAgICBjb250ZXh0LkNvbnN1bWVyID0gQ29uc3VtZXI7XG4gIH1cblxuICB7XG4gICAgY29udGV4dC5fY3VycmVudFJlbmRlcmVyID0gbnVsbDtcbiAgICBjb250ZXh0Ll9jdXJyZW50UmVuZGVyZXIyID0gbnVsbDtcbiAgfVxuXG4gIHJldHVybiBjb250ZXh0O1xufVxuXG52YXIgVW5pbml0aWFsaXplZCA9IC0xO1xudmFyIFBlbmRpbmcgPSAwO1xudmFyIFJlc29sdmVkID0gMTtcbnZhciBSZWplY3RlZCA9IDI7XG5cbmZ1bmN0aW9uIGxhenlJbml0aWFsaXplcihwYXlsb2FkKSB7XG4gIGlmIChwYXlsb2FkLl9zdGF0dXMgPT09IFVuaW5pdGlhbGl6ZWQpIHtcbiAgICB2YXIgY3RvciA9IHBheWxvYWQuX3Jlc3VsdDtcbiAgICB2YXIgdGhlbmFibGUgPSBjdG9yKCk7IC8vIFRyYW5zaXRpb24gdG8gdGhlIG5leHQgc3RhdGUuXG5cbiAgICB2YXIgcGVuZGluZyA9IHBheWxvYWQ7XG4gICAgcGVuZGluZy5fc3RhdHVzID0gUGVuZGluZztcbiAgICBwZW5kaW5nLl9yZXN1bHQgPSB0aGVuYWJsZTtcbiAgICB0aGVuYWJsZS50aGVuKGZ1bmN0aW9uIChtb2R1bGVPYmplY3QpIHtcbiAgICAgIGlmIChwYXlsb2FkLl9zdGF0dXMgPT09IFBlbmRpbmcpIHtcbiAgICAgICAgdmFyIGRlZmF1bHRFeHBvcnQgPSBtb2R1bGVPYmplY3QuZGVmYXVsdDtcblxuICAgICAgICB7XG4gICAgICAgICAgaWYgKGRlZmF1bHRFeHBvcnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZXJyb3IoJ2xhenk6IEV4cGVjdGVkIHRoZSByZXN1bHQgb2YgYSBkeW5hbWljIGltcG9ydCgpIGNhbGwuICcgKyAnSW5zdGVhZCByZWNlaXZlZDogJXNcXG5cXG5Zb3VyIGNvZGUgc2hvdWxkIGxvb2sgbGlrZTogXFxuICAnICsgLy8gQnJlYWsgdXAgaW1wb3J0cyB0byBhdm9pZCBhY2NpZGVudGFsbHkgcGFyc2luZyB0aGVtIGFzIGRlcGVuZGVuY2llcy5cbiAgICAgICAgICAgICdjb25zdCBNeUNvbXBvbmVudCA9IGxhenkoKCkgPT4gaW1wJyArIFwib3J0KCcuL015Q29tcG9uZW50JykpXCIsIG1vZHVsZU9iamVjdCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IC8vIFRyYW5zaXRpb24gdG8gdGhlIG5leHQgc3RhdGUuXG5cblxuICAgICAgICB2YXIgcmVzb2x2ZWQgPSBwYXlsb2FkO1xuICAgICAgICByZXNvbHZlZC5fc3RhdHVzID0gUmVzb2x2ZWQ7XG4gICAgICAgIHJlc29sdmVkLl9yZXN1bHQgPSBkZWZhdWx0RXhwb3J0O1xuICAgICAgfVxuICAgIH0sIGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgaWYgKHBheWxvYWQuX3N0YXR1cyA9PT0gUGVuZGluZykge1xuICAgICAgICAvLyBUcmFuc2l0aW9uIHRvIHRoZSBuZXh0IHN0YXRlLlxuICAgICAgICB2YXIgcmVqZWN0ZWQgPSBwYXlsb2FkO1xuICAgICAgICByZWplY3RlZC5fc3RhdHVzID0gUmVqZWN0ZWQ7XG4gICAgICAgIHJlamVjdGVkLl9yZXN1bHQgPSBlcnJvcjtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGlmIChwYXlsb2FkLl9zdGF0dXMgPT09IFJlc29sdmVkKSB7XG4gICAgcmV0dXJuIHBheWxvYWQuX3Jlc3VsdDtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBwYXlsb2FkLl9yZXN1bHQ7XG4gIH1cbn1cblxuZnVuY3Rpb24gbGF6eShjdG9yKSB7XG4gIHZhciBwYXlsb2FkID0ge1xuICAgIC8vIFdlIHVzZSB0aGVzZSBmaWVsZHMgdG8gc3RvcmUgdGhlIHJlc3VsdC5cbiAgICBfc3RhdHVzOiAtMSxcbiAgICBfcmVzdWx0OiBjdG9yXG4gIH07XG4gIHZhciBsYXp5VHlwZSA9IHtcbiAgICAkJHR5cGVvZjogUkVBQ1RfTEFaWV9UWVBFLFxuICAgIF9wYXlsb2FkOiBwYXlsb2FkLFxuICAgIF9pbml0OiBsYXp5SW5pdGlhbGl6ZXJcbiAgfTtcblxuICB7XG4gICAgLy8gSW4gcHJvZHVjdGlvbiwgdGhpcyB3b3VsZCBqdXN0IHNldCBpdCBvbiB0aGUgb2JqZWN0LlxuICAgIHZhciBkZWZhdWx0UHJvcHM7XG4gICAgdmFyIHByb3BUeXBlczsgLy8gJEZsb3dGaXhNZVxuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMobGF6eVR5cGUsIHtcbiAgICAgIGRlZmF1bHRQcm9wczoge1xuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBkZWZhdWx0UHJvcHM7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKG5ld0RlZmF1bHRQcm9wcykge1xuICAgICAgICAgIGVycm9yKCdSZWFjdC5sYXp5KC4uLik6IEl0IGlzIG5vdCBzdXBwb3J0ZWQgdG8gYXNzaWduIGBkZWZhdWx0UHJvcHNgIHRvICcgKyAnYSBsYXp5IGNvbXBvbmVudCBpbXBvcnQuIEVpdGhlciBzcGVjaWZ5IHRoZW0gd2hlcmUgdGhlIGNvbXBvbmVudCAnICsgJ2lzIGRlZmluZWQsIG9yIGNyZWF0ZSBhIHdyYXBwaW5nIGNvbXBvbmVudCBhcm91bmQgaXQuJyk7XG5cbiAgICAgICAgICBkZWZhdWx0UHJvcHMgPSBuZXdEZWZhdWx0UHJvcHM7IC8vIE1hdGNoIHByb2R1Y3Rpb24gYmVoYXZpb3IgbW9yZSBjbG9zZWx5OlxuICAgICAgICAgIC8vICRGbG93Rml4TWVcblxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShsYXp5VHlwZSwgJ2RlZmF1bHRQcm9wcycsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHByb3BUeXBlczoge1xuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBwcm9wVHlwZXM7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKG5ld1Byb3BUeXBlcykge1xuICAgICAgICAgIGVycm9yKCdSZWFjdC5sYXp5KC4uLik6IEl0IGlzIG5vdCBzdXBwb3J0ZWQgdG8gYXNzaWduIGBwcm9wVHlwZXNgIHRvICcgKyAnYSBsYXp5IGNvbXBvbmVudCBpbXBvcnQuIEVpdGhlciBzcGVjaWZ5IHRoZW0gd2hlcmUgdGhlIGNvbXBvbmVudCAnICsgJ2lzIGRlZmluZWQsIG9yIGNyZWF0ZSBhIHdyYXBwaW5nIGNvbXBvbmVudCBhcm91bmQgaXQuJyk7XG5cbiAgICAgICAgICBwcm9wVHlwZXMgPSBuZXdQcm9wVHlwZXM7IC8vIE1hdGNoIHByb2R1Y3Rpb24gYmVoYXZpb3IgbW9yZSBjbG9zZWx5OlxuICAgICAgICAgIC8vICRGbG93Rml4TWVcblxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShsYXp5VHlwZSwgJ3Byb3BUeXBlcycsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIGxhenlUeXBlO1xufVxuXG5mdW5jdGlvbiBmb3J3YXJkUmVmKHJlbmRlcikge1xuICB7XG4gICAgaWYgKHJlbmRlciAhPSBudWxsICYmIHJlbmRlci4kJHR5cGVvZiA9PT0gUkVBQ1RfTUVNT19UWVBFKSB7XG4gICAgICBlcnJvcignZm9yd2FyZFJlZiByZXF1aXJlcyBhIHJlbmRlciBmdW5jdGlvbiBidXQgcmVjZWl2ZWQgYSBgbWVtb2AgJyArICdjb21wb25lbnQuIEluc3RlYWQgb2YgZm9yd2FyZFJlZihtZW1vKC4uLikpLCB1c2UgJyArICdtZW1vKGZvcndhcmRSZWYoLi4uKSkuJyk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgcmVuZGVyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICBlcnJvcignZm9yd2FyZFJlZiByZXF1aXJlcyBhIHJlbmRlciBmdW5jdGlvbiBidXQgd2FzIGdpdmVuICVzLicsIHJlbmRlciA9PT0gbnVsbCA/ICdudWxsJyA6IHR5cGVvZiByZW5kZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAocmVuZGVyLmxlbmd0aCAhPT0gMCAmJiByZW5kZXIubGVuZ3RoICE9PSAyKSB7XG4gICAgICAgIGVycm9yKCdmb3J3YXJkUmVmIHJlbmRlciBmdW5jdGlvbnMgYWNjZXB0IGV4YWN0bHkgdHdvIHBhcmFtZXRlcnM6IHByb3BzIGFuZCByZWYuICVzJywgcmVuZGVyLmxlbmd0aCA9PT0gMSA/ICdEaWQgeW91IGZvcmdldCB0byB1c2UgdGhlIHJlZiBwYXJhbWV0ZXI/JyA6ICdBbnkgYWRkaXRpb25hbCBwYXJhbWV0ZXIgd2lsbCBiZSB1bmRlZmluZWQuJyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHJlbmRlciAhPSBudWxsKSB7XG4gICAgICBpZiAocmVuZGVyLmRlZmF1bHRQcm9wcyAhPSBudWxsIHx8IHJlbmRlci5wcm9wVHlwZXMgIT0gbnVsbCkge1xuICAgICAgICBlcnJvcignZm9yd2FyZFJlZiByZW5kZXIgZnVuY3Rpb25zIGRvIG5vdCBzdXBwb3J0IHByb3BUeXBlcyBvciBkZWZhdWx0UHJvcHMuICcgKyAnRGlkIHlvdSBhY2NpZGVudGFsbHkgcGFzcyBhIFJlYWN0IGNvbXBvbmVudD8nKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB2YXIgZWxlbWVudFR5cGUgPSB7XG4gICAgJCR0eXBlb2Y6IFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUsXG4gICAgcmVuZGVyOiByZW5kZXJcbiAgfTtcblxuICB7XG4gICAgdmFyIG93bk5hbWU7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVsZW1lbnRUeXBlLCAnZGlzcGxheU5hbWUnLCB7XG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gb3duTmFtZTtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIG93bk5hbWUgPSBuYW1lO1xuXG4gICAgICAgIGlmIChyZW5kZXIuZGlzcGxheU5hbWUgPT0gbnVsbCkge1xuICAgICAgICAgIHJlbmRlci5kaXNwbGF5TmFtZSA9IG5hbWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiBlbGVtZW50VHlwZTtcbn1cblxuLy8gRmlsdGVyIGNlcnRhaW4gRE9NIGF0dHJpYnV0ZXMgKGUuZy4gc3JjLCBocmVmKSBpZiB0aGVpciB2YWx1ZXMgYXJlIGVtcHR5IHN0cmluZ3MuXG5cbnZhciBlbmFibGVTY29wZUFQSSA9IGZhbHNlOyAvLyBFeHBlcmltZW50YWwgQ3JlYXRlIEV2ZW50IEhhbmRsZSBBUEkuXG5cbmZ1bmN0aW9uIGlzVmFsaWRFbGVtZW50VHlwZSh0eXBlKSB7XG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSAvLyBOb3RlOiB0eXBlb2YgbWlnaHQgYmUgb3RoZXIgdGhhbiAnc3ltYm9sJyBvciAnbnVtYmVyJyAoZS5nLiBpZiBpdCdzIGEgcG9seWZpbGwpLlxuXG5cbiAgaWYgKHR5cGUgPT09IGV4cG9ydHMuRnJhZ21lbnQgfHwgdHlwZSA9PT0gZXhwb3J0cy5Qcm9maWxlciB8fCB0eXBlID09PSBSRUFDVF9ERUJVR19UUkFDSU5HX01PREVfVFlQRSB8fCB0eXBlID09PSBleHBvcnRzLlN0cmljdE1vZGUgfHwgdHlwZSA9PT0gZXhwb3J0cy5TdXNwZW5zZSB8fCB0eXBlID09PSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfTEVHQUNZX0hJRERFTl9UWVBFIHx8IGVuYWJsZVNjb3BlQVBJICkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0JyAmJiB0eXBlICE9PSBudWxsKSB7XG4gICAgaWYgKHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0xBWllfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9NRU1PX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfUFJPVklERVJfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9DT05URVhUX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9GVU5EQU1FTlRBTF9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0JMT0NLX1RZUEUgfHwgdHlwZVswXSA9PT0gUkVBQ1RfU0VSVkVSX0JMT0NLX1RZUEUpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gbWVtbyh0eXBlLCBjb21wYXJlKSB7XG4gIHtcbiAgICBpZiAoIWlzVmFsaWRFbGVtZW50VHlwZSh0eXBlKSkge1xuICAgICAgZXJyb3IoJ21lbW86IFRoZSBmaXJzdCBhcmd1bWVudCBtdXN0IGJlIGEgY29tcG9uZW50LiBJbnN0ZWFkICcgKyAncmVjZWl2ZWQ6ICVzJywgdHlwZSA9PT0gbnVsbCA/ICdudWxsJyA6IHR5cGVvZiB0eXBlKTtcbiAgICB9XG4gIH1cblxuICB2YXIgZWxlbWVudFR5cGUgPSB7XG4gICAgJCR0eXBlb2Y6IFJFQUNUX01FTU9fVFlQRSxcbiAgICB0eXBlOiB0eXBlLFxuICAgIGNvbXBhcmU6IGNvbXBhcmUgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBjb21wYXJlXG4gIH07XG5cbiAge1xuICAgIHZhciBvd25OYW1lO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbGVtZW50VHlwZSwgJ2Rpc3BsYXlOYW1lJywge1xuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG93bk5hbWU7XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICBvd25OYW1lID0gbmFtZTtcblxuICAgICAgICBpZiAodHlwZS5kaXNwbGF5TmFtZSA9PSBudWxsKSB7XG4gICAgICAgICAgdHlwZS5kaXNwbGF5TmFtZSA9IG5hbWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiBlbGVtZW50VHlwZTtcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZURpc3BhdGNoZXIoKSB7XG4gIHZhciBkaXNwYXRjaGVyID0gUmVhY3RDdXJyZW50RGlzcGF0Y2hlci5jdXJyZW50O1xuXG4gIGlmICghKGRpc3BhdGNoZXIgIT09IG51bGwpKSB7XG4gICAge1xuICAgICAgdGhyb3cgRXJyb3IoIFwiSW52YWxpZCBob29rIGNhbGwuIEhvb2tzIGNhbiBvbmx5IGJlIGNhbGxlZCBpbnNpZGUgb2YgdGhlIGJvZHkgb2YgYSBmdW5jdGlvbiBjb21wb25lbnQuIFRoaXMgY291bGQgaGFwcGVuIGZvciBvbmUgb2YgdGhlIGZvbGxvd2luZyByZWFzb25zOlxcbjEuIFlvdSBtaWdodCBoYXZlIG1pc21hdGNoaW5nIHZlcnNpb25zIG9mIFJlYWN0IGFuZCB0aGUgcmVuZGVyZXIgKHN1Y2ggYXMgUmVhY3QgRE9NKVxcbjIuIFlvdSBtaWdodCBiZSBicmVha2luZyB0aGUgUnVsZXMgb2YgSG9va3NcXG4zLiBZb3UgbWlnaHQgaGF2ZSBtb3JlIHRoYW4gb25lIGNvcHkgb2YgUmVhY3QgaW4gdGhlIHNhbWUgYXBwXFxuU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9pbnZhbGlkLWhvb2stY2FsbCBmb3IgdGlwcyBhYm91dCBob3cgdG8gZGVidWcgYW5kIGZpeCB0aGlzIHByb2JsZW0uXCIgKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZGlzcGF0Y2hlcjtcbn1cblxuZnVuY3Rpb24gdXNlQ29udGV4dChDb250ZXh0LCB1bnN0YWJsZV9vYnNlcnZlZEJpdHMpIHtcbiAgdmFyIGRpc3BhdGNoZXIgPSByZXNvbHZlRGlzcGF0Y2hlcigpO1xuXG4gIHtcbiAgICBpZiAodW5zdGFibGVfb2JzZXJ2ZWRCaXRzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGVycm9yKCd1c2VDb250ZXh0KCkgc2Vjb25kIGFyZ3VtZW50IGlzIHJlc2VydmVkIGZvciBmdXR1cmUgJyArICd1c2UgaW4gUmVhY3QuIFBhc3NpbmcgaXQgaXMgbm90IHN1cHBvcnRlZC4gJyArICdZb3UgcGFzc2VkOiAlcy4lcycsIHVuc3RhYmxlX29ic2VydmVkQml0cywgdHlwZW9mIHVuc3RhYmxlX29ic2VydmVkQml0cyA9PT0gJ251bWJlcicgJiYgQXJyYXkuaXNBcnJheShhcmd1bWVudHNbMl0pID8gJ1xcblxcbkRpZCB5b3UgY2FsbCBhcnJheS5tYXAodXNlQ29udGV4dCk/ICcgKyAnQ2FsbGluZyBIb29rcyBpbnNpZGUgYSBsb29wIGlzIG5vdCBzdXBwb3J0ZWQuICcgKyAnTGVhcm4gbW9yZSBhdCBodHRwczovL3JlYWN0anMub3JnL2xpbmsvcnVsZXMtb2YtaG9va3MnIDogJycpO1xuICAgIH0gLy8gVE9ETzogYWRkIGEgbW9yZSBnZW5lcmljIHdhcm5pbmcgZm9yIGludmFsaWQgdmFsdWVzLlxuXG5cbiAgICBpZiAoQ29udGV4dC5fY29udGV4dCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB2YXIgcmVhbENvbnRleHQgPSBDb250ZXh0Ll9jb250ZXh0OyAvLyBEb24ndCBkZWR1cGxpY2F0ZSBiZWNhdXNlIHRoaXMgbGVnaXRpbWF0ZWx5IGNhdXNlcyBidWdzXG4gICAgICAvLyBhbmQgbm9ib2R5IHNob3VsZCBiZSB1c2luZyB0aGlzIGluIGV4aXN0aW5nIGNvZGUuXG5cbiAgICAgIGlmIChyZWFsQ29udGV4dC5Db25zdW1lciA9PT0gQ29udGV4dCkge1xuICAgICAgICBlcnJvcignQ2FsbGluZyB1c2VDb250ZXh0KENvbnRleHQuQ29uc3VtZXIpIGlzIG5vdCBzdXBwb3J0ZWQsIG1heSBjYXVzZSBidWdzLCBhbmQgd2lsbCBiZSAnICsgJ3JlbW92ZWQgaW4gYSBmdXR1cmUgbWFqb3IgcmVsZWFzZS4gRGlkIHlvdSBtZWFuIHRvIGNhbGwgdXNlQ29udGV4dChDb250ZXh0KSBpbnN0ZWFkPycpO1xuICAgICAgfSBlbHNlIGlmIChyZWFsQ29udGV4dC5Qcm92aWRlciA9PT0gQ29udGV4dCkge1xuICAgICAgICBlcnJvcignQ2FsbGluZyB1c2VDb250ZXh0KENvbnRleHQuUHJvdmlkZXIpIGlzIG5vdCBzdXBwb3J0ZWQuICcgKyAnRGlkIHlvdSBtZWFuIHRvIGNhbGwgdXNlQ29udGV4dChDb250ZXh0KSBpbnN0ZWFkPycpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBkaXNwYXRjaGVyLnVzZUNvbnRleHQoQ29udGV4dCwgdW5zdGFibGVfb2JzZXJ2ZWRCaXRzKTtcbn1cbmZ1bmN0aW9uIHVzZVN0YXRlKGluaXRpYWxTdGF0ZSkge1xuICB2YXIgZGlzcGF0Y2hlciA9IHJlc29sdmVEaXNwYXRjaGVyKCk7XG4gIHJldHVybiBkaXNwYXRjaGVyLnVzZVN0YXRlKGluaXRpYWxTdGF0ZSk7XG59XG5mdW5jdGlvbiB1c2VSZWR1Y2VyKHJlZHVjZXIsIGluaXRpYWxBcmcsIGluaXQpIHtcbiAgdmFyIGRpc3BhdGNoZXIgPSByZXNvbHZlRGlzcGF0Y2hlcigpO1xuICByZXR1cm4gZGlzcGF0Y2hlci51c2VSZWR1Y2VyKHJlZHVjZXIsIGluaXRpYWxBcmcsIGluaXQpO1xufVxuZnVuY3Rpb24gdXNlUmVmKGluaXRpYWxWYWx1ZSkge1xuICB2YXIgZGlzcGF0Y2hlciA9IHJlc29sdmVEaXNwYXRjaGVyKCk7XG4gIHJldHVybiBkaXNwYXRjaGVyLnVzZVJlZihpbml0aWFsVmFsdWUpO1xufVxuZnVuY3Rpb24gdXNlRWZmZWN0KGNyZWF0ZSwgZGVwcykge1xuICB2YXIgZGlzcGF0Y2hlciA9IHJlc29sdmVEaXNwYXRjaGVyKCk7XG4gIHJldHVybiBkaXNwYXRjaGVyLnVzZUVmZmVjdChjcmVhdGUsIGRlcHMpO1xufVxuZnVuY3Rpb24gdXNlTGF5b3V0RWZmZWN0KGNyZWF0ZSwgZGVwcykge1xuICB2YXIgZGlzcGF0Y2hlciA9IHJlc29sdmVEaXNwYXRjaGVyKCk7XG4gIHJldHVybiBkaXNwYXRjaGVyLnVzZUxheW91dEVmZmVjdChjcmVhdGUsIGRlcHMpO1xufVxuZnVuY3Rpb24gdXNlQ2FsbGJhY2soY2FsbGJhY2ssIGRlcHMpIHtcbiAgdmFyIGRpc3BhdGNoZXIgPSByZXNvbHZlRGlzcGF0Y2hlcigpO1xuICByZXR1cm4gZGlzcGF0Y2hlci51c2VDYWxsYmFjayhjYWxsYmFjaywgZGVwcyk7XG59XG5mdW5jdGlvbiB1c2VNZW1vKGNyZWF0ZSwgZGVwcykge1xuICB2YXIgZGlzcGF0Y2hlciA9IHJlc29sdmVEaXNwYXRjaGVyKCk7XG4gIHJldHVybiBkaXNwYXRjaGVyLnVzZU1lbW8oY3JlYXRlLCBkZXBzKTtcbn1cbmZ1bmN0aW9uIHVzZUltcGVyYXRpdmVIYW5kbGUocmVmLCBjcmVhdGUsIGRlcHMpIHtcbiAgdmFyIGRpc3BhdGNoZXIgPSByZXNvbHZlRGlzcGF0Y2hlcigpO1xuICByZXR1cm4gZGlzcGF0Y2hlci51c2VJbXBlcmF0aXZlSGFuZGxlKHJlZiwgY3JlYXRlLCBkZXBzKTtcbn1cbmZ1bmN0aW9uIHVzZURlYnVnVmFsdWUodmFsdWUsIGZvcm1hdHRlckZuKSB7XG4gIHtcbiAgICB2YXIgZGlzcGF0Y2hlciA9IHJlc29sdmVEaXNwYXRjaGVyKCk7XG4gICAgcmV0dXJuIGRpc3BhdGNoZXIudXNlRGVidWdWYWx1ZSh2YWx1ZSwgZm9ybWF0dGVyRm4pO1xuICB9XG59XG5cbi8vIEhlbHBlcnMgdG8gcGF0Y2ggY29uc29sZS5sb2dzIHRvIGF2b2lkIGxvZ2dpbmcgZHVyaW5nIHNpZGUtZWZmZWN0IGZyZWVcbi8vIHJlcGxheWluZyBvbiByZW5kZXIgZnVuY3Rpb24uIFRoaXMgY3VycmVudGx5IG9ubHkgcGF0Y2hlcyB0aGUgb2JqZWN0XG4vLyBsYXppbHkgd2hpY2ggd29uJ3QgY292ZXIgaWYgdGhlIGxvZyBmdW5jdGlvbiB3YXMgZXh0cmFjdGVkIGVhZ2VybHkuXG4vLyBXZSBjb3VsZCBhbHNvIGVhZ2VybHkgcGF0Y2ggdGhlIG1ldGhvZC5cbnZhciBkaXNhYmxlZERlcHRoID0gMDtcbnZhciBwcmV2TG9nO1xudmFyIHByZXZJbmZvO1xudmFyIHByZXZXYXJuO1xudmFyIHByZXZFcnJvcjtcbnZhciBwcmV2R3JvdXA7XG52YXIgcHJldkdyb3VwQ29sbGFwc2VkO1xudmFyIHByZXZHcm91cEVuZDtcblxuZnVuY3Rpb24gZGlzYWJsZWRMb2coKSB7fVxuXG5kaXNhYmxlZExvZy5fX3JlYWN0RGlzYWJsZWRMb2cgPSB0cnVlO1xuZnVuY3Rpb24gZGlzYWJsZUxvZ3MoKSB7XG4gIHtcbiAgICBpZiAoZGlzYWJsZWREZXB0aCA9PT0gMCkge1xuICAgICAgLyogZXNsaW50LWRpc2FibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgICBwcmV2TG9nID0gY29uc29sZS5sb2c7XG4gICAgICBwcmV2SW5mbyA9IGNvbnNvbGUuaW5mbztcbiAgICAgIHByZXZXYXJuID0gY29uc29sZS53YXJuO1xuICAgICAgcHJldkVycm9yID0gY29uc29sZS5lcnJvcjtcbiAgICAgIHByZXZHcm91cCA9IGNvbnNvbGUuZ3JvdXA7XG4gICAgICBwcmV2R3JvdXBDb2xsYXBzZWQgPSBjb25zb2xlLmdyb3VwQ29sbGFwc2VkO1xuICAgICAgcHJldkdyb3VwRW5kID0gY29uc29sZS5ncm91cEVuZDsgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xOTA5OVxuXG4gICAgICB2YXIgcHJvcHMgPSB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IGRpc2FibGVkTG9nLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgfTsgLy8gJEZsb3dGaXhNZSBGbG93IHRoaW5rcyBjb25zb2xlIGlzIGltbXV0YWJsZS5cblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoY29uc29sZSwge1xuICAgICAgICBpbmZvOiBwcm9wcyxcbiAgICAgICAgbG9nOiBwcm9wcyxcbiAgICAgICAgd2FybjogcHJvcHMsXG4gICAgICAgIGVycm9yOiBwcm9wcyxcbiAgICAgICAgZ3JvdXA6IHByb3BzLFxuICAgICAgICBncm91cENvbGxhcHNlZDogcHJvcHMsXG4gICAgICAgIGdyb3VwRW5kOiBwcm9wc1xuICAgICAgfSk7XG4gICAgICAvKiBlc2xpbnQtZW5hYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgIH1cblxuICAgIGRpc2FibGVkRGVwdGgrKztcbiAgfVxufVxuZnVuY3Rpb24gcmVlbmFibGVMb2dzKCkge1xuICB7XG4gICAgZGlzYWJsZWREZXB0aC0tO1xuXG4gICAgaWYgKGRpc2FibGVkRGVwdGggPT09IDApIHtcbiAgICAgIC8qIGVzbGludC1kaXNhYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgICAgdmFyIHByb3BzID0ge1xuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICB9OyAvLyAkRmxvd0ZpeE1lIEZsb3cgdGhpbmtzIGNvbnNvbGUgaXMgaW1tdXRhYmxlLlxuXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhjb25zb2xlLCB7XG4gICAgICAgIGxvZzogX2Fzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkxvZ1xuICAgICAgICB9KSxcbiAgICAgICAgaW5mbzogX2Fzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkluZm9cbiAgICAgICAgfSksXG4gICAgICAgIHdhcm46IF9hc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZXYXJuXG4gICAgICAgIH0pLFxuICAgICAgICBlcnJvcjogX2Fzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkVycm9yXG4gICAgICAgIH0pLFxuICAgICAgICBncm91cDogX2Fzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkdyb3VwXG4gICAgICAgIH0pLFxuICAgICAgICBncm91cENvbGxhcHNlZDogX2Fzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkdyb3VwQ29sbGFwc2VkXG4gICAgICAgIH0pLFxuICAgICAgICBncm91cEVuZDogX2Fzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkdyb3VwRW5kXG4gICAgICAgIH0pXG4gICAgICB9KTtcbiAgICAgIC8qIGVzbGludC1lbmFibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgfVxuXG4gICAgaWYgKGRpc2FibGVkRGVwdGggPCAwKSB7XG4gICAgICBlcnJvcignZGlzYWJsZWREZXB0aCBmZWxsIGJlbG93IHplcm8uICcgKyAnVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gICAgfVxuICB9XG59XG5cbnZhciBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdEN1cnJlbnREaXNwYXRjaGVyO1xudmFyIHByZWZpeDtcbmZ1bmN0aW9uIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKG5hbWUsIHNvdXJjZSwgb3duZXJGbikge1xuICB7XG4gICAgaWYgKHByZWZpeCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBFeHRyYWN0IHRoZSBWTSBzcGVjaWZpYyBwcmVmaXggdXNlZCBieSBlYWNoIGxpbmUuXG4gICAgICB0cnkge1xuICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICB2YXIgbWF0Y2ggPSB4LnN0YWNrLnRyaW0oKS5tYXRjaCgvXFxuKCAqKGF0ICk/KS8pO1xuICAgICAgICBwcmVmaXggPSBtYXRjaCAmJiBtYXRjaFsxXSB8fCAnJztcbiAgICAgIH1cbiAgICB9IC8vIFdlIHVzZSB0aGUgcHJlZml4IHRvIGVuc3VyZSBvdXIgc3RhY2tzIGxpbmUgdXAgd2l0aCBuYXRpdmUgc3RhY2sgZnJhbWVzLlxuXG5cbiAgICByZXR1cm4gJ1xcbicgKyBwcmVmaXggKyBuYW1lO1xuICB9XG59XG52YXIgcmVlbnRyeSA9IGZhbHNlO1xudmFyIGNvbXBvbmVudEZyYW1lQ2FjaGU7XG5cbntcbiAgdmFyIFBvc3NpYmx5V2Vha01hcCA9IHR5cGVvZiBXZWFrTWFwID09PSAnZnVuY3Rpb24nID8gV2Vha01hcCA6IE1hcDtcbiAgY29tcG9uZW50RnJhbWVDYWNoZSA9IG5ldyBQb3NzaWJseVdlYWtNYXAoKTtcbn1cblxuZnVuY3Rpb24gZGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZShmbiwgY29uc3RydWN0KSB7XG4gIC8vIElmIHNvbWV0aGluZyBhc2tlZCBmb3IgYSBzdGFjayBpbnNpZGUgYSBmYWtlIHJlbmRlciwgaXQgc2hvdWxkIGdldCBpZ25vcmVkLlxuICBpZiAoIWZuIHx8IHJlZW50cnkpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICB7XG4gICAgdmFyIGZyYW1lID0gY29tcG9uZW50RnJhbWVDYWNoZS5nZXQoZm4pO1xuXG4gICAgaWYgKGZyYW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBmcmFtZTtcbiAgICB9XG4gIH1cblxuICB2YXIgY29udHJvbDtcbiAgcmVlbnRyeSA9IHRydWU7XG4gIHZhciBwcmV2aW91c1ByZXBhcmVTdGFja1RyYWNlID0gRXJyb3IucHJlcGFyZVN0YWNrVHJhY2U7IC8vICRGbG93Rml4TWUgSXQgZG9lcyBhY2NlcHQgdW5kZWZpbmVkLlxuXG4gIEVycm9yLnByZXBhcmVTdGFja1RyYWNlID0gdW5kZWZpbmVkO1xuICB2YXIgcHJldmlvdXNEaXNwYXRjaGVyO1xuXG4gIHtcbiAgICBwcmV2aW91c0Rpc3BhdGNoZXIgPSBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudDsgLy8gU2V0IHRoZSBkaXNwYXRjaGVyIGluIERFViBiZWNhdXNlIHRoaXMgbWlnaHQgYmUgY2FsbCBpbiB0aGUgcmVuZGVyIGZ1bmN0aW9uXG4gICAgLy8gZm9yIHdhcm5pbmdzLlxuXG4gICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQgPSBudWxsO1xuICAgIGRpc2FibGVMb2dzKCk7XG4gIH1cblxuICB0cnkge1xuICAgIC8vIFRoaXMgc2hvdWxkIHRocm93LlxuICAgIGlmIChjb25zdHJ1Y3QpIHtcbiAgICAgIC8vIFNvbWV0aGluZyBzaG91bGQgYmUgc2V0dGluZyB0aGUgcHJvcHMgaW4gdGhlIGNvbnN0cnVjdG9yLlxuICAgICAgdmFyIEZha2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICB9OyAvLyAkRmxvd0ZpeE1lXG5cblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEZha2UucHJvdG90eXBlLCAncHJvcHMnLCB7XG4gICAgICAgIHNldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIC8vIFdlIHVzZSBhIHRocm93aW5nIHNldHRlciBpbnN0ZWFkIG9mIGZyb3plbiBvciBub24td3JpdGFibGUgcHJvcHNcbiAgICAgICAgICAvLyBiZWNhdXNlIHRoYXQgd29uJ3QgdGhyb3cgaW4gYSBub24tc3RyaWN0IG1vZGUgZnVuY3Rpb24uXG4gICAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gJ29iamVjdCcgJiYgUmVmbGVjdC5jb25zdHJ1Y3QpIHtcbiAgICAgICAgLy8gV2UgY29uc3RydWN0IGEgZGlmZmVyZW50IGNvbnRyb2wgZm9yIHRoaXMgY2FzZSB0byBpbmNsdWRlIGFueSBleHRyYVxuICAgICAgICAvLyBmcmFtZXMgYWRkZWQgYnkgdGhlIGNvbnN0cnVjdCBjYWxsLlxuICAgICAgICB0cnkge1xuICAgICAgICAgIFJlZmxlY3QuY29uc3RydWN0KEZha2UsIFtdKTtcbiAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgIGNvbnRyb2wgPSB4O1xuICAgICAgICB9XG5cbiAgICAgICAgUmVmbGVjdC5jb25zdHJ1Y3QoZm4sIFtdLCBGYWtlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgRmFrZS5jYWxsKCk7XG4gICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICBjb250cm9sID0geDtcbiAgICAgICAgfVxuXG4gICAgICAgIGZuLmNhbGwoRmFrZS5wcm90b3R5cGUpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0cnkge1xuICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICBjb250cm9sID0geDtcbiAgICAgIH1cblxuICAgICAgZm4oKTtcbiAgICB9XG4gIH0gY2F0Y2ggKHNhbXBsZSkge1xuICAgIC8vIFRoaXMgaXMgaW5saW5lZCBtYW51YWxseSBiZWNhdXNlIGNsb3N1cmUgZG9lc24ndCBkbyBpdCBmb3IgdXMuXG4gICAgaWYgKHNhbXBsZSAmJiBjb250cm9sICYmIHR5cGVvZiBzYW1wbGUuc3RhY2sgPT09ICdzdHJpbmcnKSB7XG4gICAgICAvLyBUaGlzIGV4dHJhY3RzIHRoZSBmaXJzdCBmcmFtZSBmcm9tIHRoZSBzYW1wbGUgdGhhdCBpc24ndCBhbHNvIGluIHRoZSBjb250cm9sLlxuICAgICAgLy8gU2tpcHBpbmcgb25lIGZyYW1lIHRoYXQgd2UgYXNzdW1lIGlzIHRoZSBmcmFtZSB0aGF0IGNhbGxzIHRoZSB0d28uXG4gICAgICB2YXIgc2FtcGxlTGluZXMgPSBzYW1wbGUuc3RhY2suc3BsaXQoJ1xcbicpO1xuICAgICAgdmFyIGNvbnRyb2xMaW5lcyA9IGNvbnRyb2wuc3RhY2suc3BsaXQoJ1xcbicpO1xuICAgICAgdmFyIHMgPSBzYW1wbGVMaW5lcy5sZW5ndGggLSAxO1xuICAgICAgdmFyIGMgPSBjb250cm9sTGluZXMubGVuZ3RoIC0gMTtcblxuICAgICAgd2hpbGUgKHMgPj0gMSAmJiBjID49IDAgJiYgc2FtcGxlTGluZXNbc10gIT09IGNvbnRyb2xMaW5lc1tjXSkge1xuICAgICAgICAvLyBXZSBleHBlY3QgYXQgbGVhc3Qgb25lIHN0YWNrIGZyYW1lIHRvIGJlIHNoYXJlZC5cbiAgICAgICAgLy8gVHlwaWNhbGx5IHRoaXMgd2lsbCBiZSB0aGUgcm9vdCBtb3N0IG9uZS4gSG93ZXZlciwgc3RhY2sgZnJhbWVzIG1heSBiZVxuICAgICAgICAvLyBjdXQgb2ZmIGR1ZSB0byBtYXhpbXVtIHN0YWNrIGxpbWl0cy4gSW4gdGhpcyBjYXNlLCBvbmUgbWF5YmUgY3V0IG9mZlxuICAgICAgICAvLyBlYXJsaWVyIHRoYW4gdGhlIG90aGVyLiBXZSBhc3N1bWUgdGhhdCB0aGUgc2FtcGxlIGlzIGxvbmdlciBvciB0aGUgc2FtZVxuICAgICAgICAvLyBhbmQgdGhlcmUgZm9yIGN1dCBvZmYgZWFybGllci4gU28gd2Ugc2hvdWxkIGZpbmQgdGhlIHJvb3QgbW9zdCBmcmFtZSBpblxuICAgICAgICAvLyB0aGUgc2FtcGxlIHNvbWV3aGVyZSBpbiB0aGUgY29udHJvbC5cbiAgICAgICAgYy0tO1xuICAgICAgfVxuXG4gICAgICBmb3IgKDsgcyA+PSAxICYmIGMgPj0gMDsgcy0tLCBjLS0pIHtcbiAgICAgICAgLy8gTmV4dCB3ZSBmaW5kIHRoZSBmaXJzdCBvbmUgdGhhdCBpc24ndCB0aGUgc2FtZSB3aGljaCBzaG91bGQgYmUgdGhlXG4gICAgICAgIC8vIGZyYW1lIHRoYXQgY2FsbGVkIG91ciBzYW1wbGUgZnVuY3Rpb24gYW5kIHRoZSBjb250cm9sLlxuICAgICAgICBpZiAoc2FtcGxlTGluZXNbc10gIT09IGNvbnRyb2xMaW5lc1tjXSkge1xuICAgICAgICAgIC8vIEluIFY4LCB0aGUgZmlyc3QgbGluZSBpcyBkZXNjcmliaW5nIHRoZSBtZXNzYWdlIGJ1dCBvdGhlciBWTXMgZG9uJ3QuXG4gICAgICAgICAgLy8gSWYgd2UncmUgYWJvdXQgdG8gcmV0dXJuIHRoZSBmaXJzdCBsaW5lLCBhbmQgdGhlIGNvbnRyb2wgaXMgYWxzbyBvbiB0aGUgc2FtZVxuICAgICAgICAgIC8vIGxpbmUsIHRoYXQncyBhIHByZXR0eSBnb29kIGluZGljYXRvciB0aGF0IG91ciBzYW1wbGUgdGhyZXcgYXQgc2FtZSBsaW5lIGFzXG4gICAgICAgICAgLy8gdGhlIGNvbnRyb2wuIEkuZS4gYmVmb3JlIHdlIGVudGVyZWQgdGhlIHNhbXBsZSBmcmFtZS4gU28gd2UgaWdub3JlIHRoaXMgcmVzdWx0LlxuICAgICAgICAgIC8vIFRoaXMgY2FuIGhhcHBlbiBpZiB5b3UgcGFzc2VkIGEgY2xhc3MgdG8gZnVuY3Rpb24gY29tcG9uZW50LCBvciBub24tZnVuY3Rpb24uXG4gICAgICAgICAgaWYgKHMgIT09IDEgfHwgYyAhPT0gMSkge1xuICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICBzLS07XG4gICAgICAgICAgICAgIGMtLTsgLy8gV2UgbWF5IHN0aWxsIGhhdmUgc2ltaWxhciBpbnRlcm1lZGlhdGUgZnJhbWVzIGZyb20gdGhlIGNvbnN0cnVjdCBjYWxsLlxuICAgICAgICAgICAgICAvLyBUaGUgbmV4dCBvbmUgdGhhdCBpc24ndCB0aGUgc2FtZSBzaG91bGQgYmUgb3VyIG1hdGNoIHRob3VnaC5cblxuICAgICAgICAgICAgICBpZiAoYyA8IDAgfHwgc2FtcGxlTGluZXNbc10gIT09IGNvbnRyb2xMaW5lc1tjXSkge1xuICAgICAgICAgICAgICAgIC8vIFY4IGFkZHMgYSBcIm5ld1wiIHByZWZpeCBmb3IgbmF0aXZlIGNsYXNzZXMuIExldCdzIHJlbW92ZSBpdCB0byBtYWtlIGl0IHByZXR0aWVyLlxuICAgICAgICAgICAgICAgIHZhciBfZnJhbWUgPSAnXFxuJyArIHNhbXBsZUxpbmVzW3NdLnJlcGxhY2UoJyBhdCBuZXcgJywgJyBhdCAnKTtcblxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50RnJhbWVDYWNoZS5zZXQoZm4sIF9mcmFtZSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSAvLyBSZXR1cm4gdGhlIGxpbmUgd2UgZm91bmQuXG5cblxuICAgICAgICAgICAgICAgIHJldHVybiBfZnJhbWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gd2hpbGUgKHMgPj0gMSAmJiBjID49IDApO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9IGZpbmFsbHkge1xuICAgIHJlZW50cnkgPSBmYWxzZTtcblxuICAgIHtcbiAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50ID0gcHJldmlvdXNEaXNwYXRjaGVyO1xuICAgICAgcmVlbmFibGVMb2dzKCk7XG4gICAgfVxuXG4gICAgRXJyb3IucHJlcGFyZVN0YWNrVHJhY2UgPSBwcmV2aW91c1ByZXBhcmVTdGFja1RyYWNlO1xuICB9IC8vIEZhbGxiYWNrIHRvIGp1c3QgdXNpbmcgdGhlIG5hbWUgaWYgd2UgY291bGRuJ3QgbWFrZSBpdCB0aHJvdy5cblxuXG4gIHZhciBuYW1lID0gZm4gPyBmbi5kaXNwbGF5TmFtZSB8fCBmbi5uYW1lIDogJyc7XG4gIHZhciBzeW50aGV0aWNGcmFtZSA9IG5hbWUgPyBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZShuYW1lKSA6ICcnO1xuXG4gIHtcbiAgICBpZiAodHlwZW9mIGZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjb21wb25lbnRGcmFtZUNhY2hlLnNldChmbiwgc3ludGhldGljRnJhbWUpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzeW50aGV0aWNGcmFtZTtcbn1cbmZ1bmN0aW9uIGRlc2NyaWJlRnVuY3Rpb25Db21wb25lbnRGcmFtZShmbiwgc291cmNlLCBvd25lckZuKSB7XG4gIHtcbiAgICByZXR1cm4gZGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZShmbiwgZmFsc2UpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHNob3VsZENvbnN0cnVjdChDb21wb25lbnQpIHtcbiAgdmFyIHByb3RvdHlwZSA9IENvbXBvbmVudC5wcm90b3R5cGU7XG4gIHJldHVybiAhIShwcm90b3R5cGUgJiYgcHJvdG90eXBlLmlzUmVhY3RDb21wb25lbnQpO1xufVxuXG5mdW5jdGlvbiBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYodHlwZSwgc291cmNlLCBvd25lckZuKSB7XG5cbiAgaWYgKHR5cGUgPT0gbnVsbCkge1xuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHtcbiAgICAgIHJldHVybiBkZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lKHR5cGUsIHNob3VsZENvbnN0cnVjdCh0eXBlKSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZSh0eXBlKTtcbiAgfVxuXG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgZXhwb3J0cy5TdXNwZW5zZTpcbiAgICAgIHJldHVybiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZSgnU3VzcGVuc2UnKTtcblxuICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFOlxuICAgICAgcmV0dXJuIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKCdTdXNwZW5zZUxpc3QnKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICBzd2l0Y2ggKHR5cGUuJCR0eXBlb2YpIHtcbiAgICAgIGNhc2UgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRTpcbiAgICAgICAgcmV0dXJuIGRlc2NyaWJlRnVuY3Rpb25Db21wb25lbnRGcmFtZSh0eXBlLnJlbmRlcik7XG5cbiAgICAgIGNhc2UgUkVBQ1RfTUVNT19UWVBFOlxuICAgICAgICAvLyBNZW1vIG1heSBjb250YWluIGFueSBjb21wb25lbnQgdHlwZSBzbyB3ZSByZWN1cnNpdmVseSByZXNvbHZlIGl0LlxuICAgICAgICByZXR1cm4gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKHR5cGUudHlwZSwgc291cmNlLCBvd25lckZuKTtcblxuICAgICAgY2FzZSBSRUFDVF9CTE9DS19UWVBFOlxuICAgICAgICByZXR1cm4gZGVzY3JpYmVGdW5jdGlvbkNvbXBvbmVudEZyYW1lKHR5cGUuX3JlbmRlcik7XG5cbiAgICAgIGNhc2UgUkVBQ1RfTEFaWV9UWVBFOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIGxhenlDb21wb25lbnQgPSB0eXBlO1xuICAgICAgICAgIHZhciBwYXlsb2FkID0gbGF6eUNvbXBvbmVudC5fcGF5bG9hZDtcbiAgICAgICAgICB2YXIgaW5pdCA9IGxhenlDb21wb25lbnQuX2luaXQ7XG5cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gTGF6eSBtYXkgY29udGFpbiBhbnkgY29tcG9uZW50IHR5cGUgc28gd2UgcmVjdXJzaXZlbHkgcmVzb2x2ZSBpdC5cbiAgICAgICAgICAgIHJldHVybiBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYoaW5pdChwYXlsb2FkKSwgc291cmNlLCBvd25lckZuKTtcbiAgICAgICAgICB9IGNhdGNoICh4KSB7fVxuICAgICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuICcnO1xufVxuXG52YXIgbG9nZ2VkVHlwZUZhaWx1cmVzID0ge307XG52YXIgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSQxID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZTtcblxuZnVuY3Rpb24gc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQoZWxlbWVudCkge1xuICB7XG4gICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgIHZhciBvd25lciA9IGVsZW1lbnQuX293bmVyO1xuICAgICAgdmFyIHN0YWNrID0gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKGVsZW1lbnQudHlwZSwgZWxlbWVudC5fc291cmNlLCBvd25lciA/IG93bmVyLnR5cGUgOiBudWxsKTtcbiAgICAgIFJlYWN0RGVidWdDdXJyZW50RnJhbWUkMS5zZXRFeHRyYVN0YWNrRnJhbWUoc3RhY2spO1xuICAgIH0gZWxzZSB7XG4gICAgICBSZWFjdERlYnVnQ3VycmVudEZyYW1lJDEuc2V0RXh0cmFTdGFja0ZyYW1lKG51bGwpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjaGVja1Byb3BUeXBlcyh0eXBlU3BlY3MsIHZhbHVlcywgbG9jYXRpb24sIGNvbXBvbmVudE5hbWUsIGVsZW1lbnQpIHtcbiAge1xuICAgIC8vICRGbG93Rml4TWUgVGhpcyBpcyBva2F5IGJ1dCBGbG93IGRvZXNuJ3Qga25vdyBpdC5cbiAgICB2YXIgaGFzID0gRnVuY3Rpb24uY2FsbC5iaW5kKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkpO1xuXG4gICAgZm9yICh2YXIgdHlwZVNwZWNOYW1lIGluIHR5cGVTcGVjcykge1xuICAgICAgaWYgKGhhcyh0eXBlU3BlY3MsIHR5cGVTcGVjTmFtZSkpIHtcbiAgICAgICAgdmFyIGVycm9yJDEgPSB2b2lkIDA7IC8vIFByb3AgdHlwZSB2YWxpZGF0aW9uIG1heSB0aHJvdy4gSW4gY2FzZSB0aGV5IGRvLCB3ZSBkb24ndCB3YW50IHRvXG4gICAgICAgIC8vIGZhaWwgdGhlIHJlbmRlciBwaGFzZSB3aGVyZSBpdCBkaWRuJ3QgZmFpbCBiZWZvcmUuIFNvIHdlIGxvZyBpdC5cbiAgICAgICAgLy8gQWZ0ZXIgdGhlc2UgaGF2ZSBiZWVuIGNsZWFuZWQgdXAsIHdlJ2xsIGxldCB0aGVtIHRocm93LlxuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgLy8gVGhpcyBpcyBpbnRlbnRpb25hbGx5IGFuIGludmFyaWFudCB0aGF0IGdldHMgY2F1Z2h0LiBJdCdzIHRoZSBzYW1lXG4gICAgICAgICAgLy8gYmVoYXZpb3IgYXMgd2l0aG91dCB0aGlzIHN0YXRlbWVudCBleGNlcHQgd2l0aCBhIGJldHRlciBtZXNzYWdlLlxuICAgICAgICAgIGlmICh0eXBlb2YgdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHZhciBlcnIgPSBFcnJvcigoY29tcG9uZW50TmFtZSB8fCAnUmVhY3QgY2xhc3MnKSArICc6ICcgKyBsb2NhdGlvbiArICcgdHlwZSBgJyArIHR5cGVTcGVjTmFtZSArICdgIGlzIGludmFsaWQ7ICcgKyAnaXQgbXVzdCBiZSBhIGZ1bmN0aW9uLCB1c3VhbGx5IGZyb20gdGhlIGBwcm9wLXR5cGVzYCBwYWNrYWdlLCBidXQgcmVjZWl2ZWQgYCcgKyB0eXBlb2YgdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0gKyAnYC4nICsgJ1RoaXMgb2Z0ZW4gaGFwcGVucyBiZWNhdXNlIG9mIHR5cG9zIHN1Y2ggYXMgYFByb3BUeXBlcy5mdW5jdGlvbmAgaW5zdGVhZCBvZiBgUHJvcFR5cGVzLmZ1bmNgLicpO1xuICAgICAgICAgICAgZXJyLm5hbWUgPSAnSW52YXJpYW50IFZpb2xhdGlvbic7XG4gICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZXJyb3IkMSA9IHR5cGVTcGVjc1t0eXBlU3BlY05hbWVdKHZhbHVlcywgdHlwZVNwZWNOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgbnVsbCwgJ1NFQ1JFVF9ET19OT1RfUEFTU19USElTX09SX1lPVV9XSUxMX0JFX0ZJUkVEJyk7XG4gICAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgICAgZXJyb3IkMSA9IGV4O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVycm9yJDEgJiYgIShlcnJvciQxIGluc3RhbmNlb2YgRXJyb3IpKSB7XG4gICAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQoZWxlbWVudCk7XG5cbiAgICAgICAgICBlcnJvcignJXM6IHR5cGUgc3BlY2lmaWNhdGlvbiBvZiAlcycgKyAnIGAlc2AgaXMgaW52YWxpZDsgdGhlIHR5cGUgY2hlY2tlciAnICsgJ2Z1bmN0aW9uIG11c3QgcmV0dXJuIGBudWxsYCBvciBhbiBgRXJyb3JgIGJ1dCByZXR1cm5lZCBhICVzLiAnICsgJ1lvdSBtYXkgaGF2ZSBmb3Jnb3R0ZW4gdG8gcGFzcyBhbiBhcmd1bWVudCB0byB0aGUgdHlwZSBjaGVja2VyICcgKyAnY3JlYXRvciAoYXJyYXlPZiwgaW5zdGFuY2VPZiwgb2JqZWN0T2YsIG9uZU9mLCBvbmVPZlR5cGUsIGFuZCAnICsgJ3NoYXBlIGFsbCByZXF1aXJlIGFuIGFyZ3VtZW50KS4nLCBjb21wb25lbnROYW1lIHx8ICdSZWFjdCBjbGFzcycsIGxvY2F0aW9uLCB0eXBlU3BlY05hbWUsIHR5cGVvZiBlcnJvciQxKTtcblxuICAgICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KG51bGwpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVycm9yJDEgaW5zdGFuY2VvZiBFcnJvciAmJiAhKGVycm9yJDEubWVzc2FnZSBpbiBsb2dnZWRUeXBlRmFpbHVyZXMpKSB7XG4gICAgICAgICAgLy8gT25seSBtb25pdG9yIHRoaXMgZmFpbHVyZSBvbmNlIGJlY2F1c2UgdGhlcmUgdGVuZHMgdG8gYmUgYSBsb3Qgb2YgdGhlXG4gICAgICAgICAgLy8gc2FtZSBlcnJvci5cbiAgICAgICAgICBsb2dnZWRUeXBlRmFpbHVyZXNbZXJyb3IkMS5tZXNzYWdlXSA9IHRydWU7XG4gICAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQoZWxlbWVudCk7XG5cbiAgICAgICAgICBlcnJvcignRmFpbGVkICVzIHR5cGU6ICVzJywgbG9jYXRpb24sIGVycm9yJDEubWVzc2FnZSk7XG5cbiAgICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChudWxsKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKGVsZW1lbnQpIHtcbiAge1xuICAgIGlmIChlbGVtZW50KSB7XG4gICAgICB2YXIgb3duZXIgPSBlbGVtZW50Ll9vd25lcjtcbiAgICAgIHZhciBzdGFjayA9IGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVihlbGVtZW50LnR5cGUsIGVsZW1lbnQuX3NvdXJjZSwgb3duZXIgPyBvd25lci50eXBlIDogbnVsbCk7XG4gICAgICBzZXRFeHRyYVN0YWNrRnJhbWUoc3RhY2spO1xuICAgIH0gZWxzZSB7XG4gICAgICBzZXRFeHRyYVN0YWNrRnJhbWUobnVsbCk7XG4gICAgfVxuICB9XG59XG5cbnZhciBwcm9wVHlwZXNNaXNzcGVsbFdhcm5pbmdTaG93bjtcblxue1xuICBwcm9wVHlwZXNNaXNzcGVsbFdhcm5pbmdTaG93biA9IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKSB7XG4gIGlmIChSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50KSB7XG4gICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lKFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQudHlwZSk7XG5cbiAgICBpZiAobmFtZSkge1xuICAgICAgcmV0dXJuICdcXG5cXG5DaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiBgJyArIG5hbWUgKyAnYC4nO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiAnJztcbn1cblxuZnVuY3Rpb24gZ2V0U291cmNlSW5mb0Vycm9yQWRkZW5kdW0oc291cmNlKSB7XG4gIGlmIChzb3VyY2UgIT09IHVuZGVmaW5lZCkge1xuICAgIHZhciBmaWxlTmFtZSA9IHNvdXJjZS5maWxlTmFtZS5yZXBsYWNlKC9eLipbXFxcXFxcL10vLCAnJyk7XG4gICAgdmFyIGxpbmVOdW1iZXIgPSBzb3VyY2UubGluZU51bWJlcjtcbiAgICByZXR1cm4gJ1xcblxcbkNoZWNrIHlvdXIgY29kZSBhdCAnICsgZmlsZU5hbWUgKyAnOicgKyBsaW5lTnVtYmVyICsgJy4nO1xuICB9XG5cbiAgcmV0dXJuICcnO1xufVxuXG5mdW5jdGlvbiBnZXRTb3VyY2VJbmZvRXJyb3JBZGRlbmR1bUZvclByb3BzKGVsZW1lbnRQcm9wcykge1xuICBpZiAoZWxlbWVudFByb3BzICE9PSBudWxsICYmIGVsZW1lbnRQcm9wcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIGdldFNvdXJjZUluZm9FcnJvckFkZGVuZHVtKGVsZW1lbnRQcm9wcy5fX3NvdXJjZSk7XG4gIH1cblxuICByZXR1cm4gJyc7XG59XG4vKipcbiAqIFdhcm4gaWYgdGhlcmUncyBubyBrZXkgZXhwbGljaXRseSBzZXQgb24gZHluYW1pYyBhcnJheXMgb2YgY2hpbGRyZW4gb3JcbiAqIG9iamVjdCBrZXlzIGFyZSBub3QgdmFsaWQuIFRoaXMgYWxsb3dzIHVzIHRvIGtlZXAgdHJhY2sgb2YgY2hpbGRyZW4gYmV0d2VlblxuICogdXBkYXRlcy5cbiAqL1xuXG5cbnZhciBvd25lckhhc0tleVVzZVdhcm5pbmcgPSB7fTtcblxuZnVuY3Rpb24gZ2V0Q3VycmVudENvbXBvbmVudEVycm9ySW5mbyhwYXJlbnRUeXBlKSB7XG4gIHZhciBpbmZvID0gZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKCk7XG5cbiAgaWYgKCFpbmZvKSB7XG4gICAgdmFyIHBhcmVudE5hbWUgPSB0eXBlb2YgcGFyZW50VHlwZSA9PT0gJ3N0cmluZycgPyBwYXJlbnRUeXBlIDogcGFyZW50VHlwZS5kaXNwbGF5TmFtZSB8fCBwYXJlbnRUeXBlLm5hbWU7XG5cbiAgICBpZiAocGFyZW50TmFtZSkge1xuICAgICAgaW5mbyA9IFwiXFxuXFxuQ2hlY2sgdGhlIHRvcC1sZXZlbCByZW5kZXIgY2FsbCB1c2luZyA8XCIgKyBwYXJlbnROYW1lICsgXCI+LlwiO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBpbmZvO1xufVxuLyoqXG4gKiBXYXJuIGlmIHRoZSBlbGVtZW50IGRvZXNuJ3QgaGF2ZSBhbiBleHBsaWNpdCBrZXkgYXNzaWduZWQgdG8gaXQuXG4gKiBUaGlzIGVsZW1lbnQgaXMgaW4gYW4gYXJyYXkuIFRoZSBhcnJheSBjb3VsZCBncm93IGFuZCBzaHJpbmsgb3IgYmVcbiAqIHJlb3JkZXJlZC4gQWxsIGNoaWxkcmVuIHRoYXQgaGF2ZW4ndCBhbHJlYWR5IGJlZW4gdmFsaWRhdGVkIGFyZSByZXF1aXJlZCB0b1xuICogaGF2ZSBhIFwia2V5XCIgcHJvcGVydHkgYXNzaWduZWQgdG8gaXQuIEVycm9yIHN0YXR1c2VzIGFyZSBjYWNoZWQgc28gYSB3YXJuaW5nXG4gKiB3aWxsIG9ubHkgYmUgc2hvd24gb25jZS5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBlbGVtZW50IEVsZW1lbnQgdGhhdCByZXF1aXJlcyBhIGtleS5cbiAqIEBwYXJhbSB7Kn0gcGFyZW50VHlwZSBlbGVtZW50J3MgcGFyZW50J3MgdHlwZS5cbiAqL1xuXG5cbmZ1bmN0aW9uIHZhbGlkYXRlRXhwbGljaXRLZXkoZWxlbWVudCwgcGFyZW50VHlwZSkge1xuICBpZiAoIWVsZW1lbnQuX3N0b3JlIHx8IGVsZW1lbnQuX3N0b3JlLnZhbGlkYXRlZCB8fCBlbGVtZW50LmtleSAhPSBudWxsKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgZWxlbWVudC5fc3RvcmUudmFsaWRhdGVkID0gdHJ1ZTtcbiAgdmFyIGN1cnJlbnRDb21wb25lbnRFcnJvckluZm8gPSBnZXRDdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvKHBhcmVudFR5cGUpO1xuXG4gIGlmIChvd25lckhhc0tleVVzZVdhcm5pbmdbY3VycmVudENvbXBvbmVudEVycm9ySW5mb10pIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBvd25lckhhc0tleVVzZVdhcm5pbmdbY3VycmVudENvbXBvbmVudEVycm9ySW5mb10gPSB0cnVlOyAvLyBVc3VhbGx5IHRoZSBjdXJyZW50IG93bmVyIGlzIHRoZSBvZmZlbmRlciwgYnV0IGlmIGl0IGFjY2VwdHMgY2hpbGRyZW4gYXMgYVxuICAvLyBwcm9wZXJ0eSwgaXQgbWF5IGJlIHRoZSBjcmVhdG9yIG9mIHRoZSBjaGlsZCB0aGF0J3MgcmVzcG9uc2libGUgZm9yXG4gIC8vIGFzc2lnbmluZyBpdCBhIGtleS5cblxuICB2YXIgY2hpbGRPd25lciA9ICcnO1xuXG4gIGlmIChlbGVtZW50ICYmIGVsZW1lbnQuX293bmVyICYmIGVsZW1lbnQuX293bmVyICE9PSBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50KSB7XG4gICAgLy8gR2l2ZSB0aGUgY29tcG9uZW50IHRoYXQgb3JpZ2luYWxseSBjcmVhdGVkIHRoaXMgY2hpbGQuXG4gICAgY2hpbGRPd25lciA9IFwiIEl0IHdhcyBwYXNzZWQgYSBjaGlsZCBmcm9tIFwiICsgZ2V0Q29tcG9uZW50TmFtZShlbGVtZW50Ll9vd25lci50eXBlKSArIFwiLlwiO1xuICB9XG5cbiAge1xuICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEoZWxlbWVudCk7XG5cbiAgICBlcnJvcignRWFjaCBjaGlsZCBpbiBhIGxpc3Qgc2hvdWxkIGhhdmUgYSB1bmlxdWUgXCJrZXlcIiBwcm9wLicgKyAnJXMlcyBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3dhcm5pbmcta2V5cyBmb3IgbW9yZSBpbmZvcm1hdGlvbi4nLCBjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvLCBjaGlsZE93bmVyKTtcblxuICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEobnVsbCk7XG4gIH1cbn1cbi8qKlxuICogRW5zdXJlIHRoYXQgZXZlcnkgZWxlbWVudCBlaXRoZXIgaXMgcGFzc2VkIGluIGEgc3RhdGljIGxvY2F0aW9uLCBpbiBhblxuICogYXJyYXkgd2l0aCBhbiBleHBsaWNpdCBrZXlzIHByb3BlcnR5IGRlZmluZWQsIG9yIGluIGFuIG9iamVjdCBsaXRlcmFsXG4gKiB3aXRoIHZhbGlkIGtleSBwcm9wZXJ0eS5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqIEBwYXJhbSB7UmVhY3ROb2RlfSBub2RlIFN0YXRpY2FsbHkgcGFzc2VkIGNoaWxkIG9mIGFueSB0eXBlLlxuICogQHBhcmFtIHsqfSBwYXJlbnRUeXBlIG5vZGUncyBwYXJlbnQncyB0eXBlLlxuICovXG5cblxuZnVuY3Rpb24gdmFsaWRhdGVDaGlsZEtleXMobm9kZSwgcGFyZW50VHlwZSkge1xuICBpZiAodHlwZW9mIG5vZGUgIT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkobm9kZSkpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGUubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBjaGlsZCA9IG5vZGVbaV07XG5cbiAgICAgIGlmIChpc1ZhbGlkRWxlbWVudChjaGlsZCkpIHtcbiAgICAgICAgdmFsaWRhdGVFeHBsaWNpdEtleShjaGlsZCwgcGFyZW50VHlwZSk7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzVmFsaWRFbGVtZW50KG5vZGUpKSB7XG4gICAgLy8gVGhpcyBlbGVtZW50IHdhcyBwYXNzZWQgaW4gYSB2YWxpZCBsb2NhdGlvbi5cbiAgICBpZiAobm9kZS5fc3RvcmUpIHtcbiAgICAgIG5vZGUuX3N0b3JlLnZhbGlkYXRlZCA9IHRydWU7XG4gICAgfVxuICB9IGVsc2UgaWYgKG5vZGUpIHtcbiAgICB2YXIgaXRlcmF0b3JGbiA9IGdldEl0ZXJhdG9yRm4obm9kZSk7XG5cbiAgICBpZiAodHlwZW9mIGl0ZXJhdG9yRm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIC8vIEVudHJ5IGl0ZXJhdG9ycyB1c2VkIHRvIHByb3ZpZGUgaW1wbGljaXQga2V5cyxcbiAgICAgIC8vIGJ1dCBub3cgd2UgcHJpbnQgYSBzZXBhcmF0ZSB3YXJuaW5nIGZvciB0aGVtIGxhdGVyLlxuICAgICAgaWYgKGl0ZXJhdG9yRm4gIT09IG5vZGUuZW50cmllcykge1xuICAgICAgICB2YXIgaXRlcmF0b3IgPSBpdGVyYXRvckZuLmNhbGwobm9kZSk7XG4gICAgICAgIHZhciBzdGVwO1xuXG4gICAgICAgIHdoaWxlICghKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmUpIHtcbiAgICAgICAgICBpZiAoaXNWYWxpZEVsZW1lbnQoc3RlcC52YWx1ZSkpIHtcbiAgICAgICAgICAgIHZhbGlkYXRlRXhwbGljaXRLZXkoc3RlcC52YWx1ZSwgcGFyZW50VHlwZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG4vKipcbiAqIEdpdmVuIGFuIGVsZW1lbnQsIHZhbGlkYXRlIHRoYXQgaXRzIHByb3BzIGZvbGxvdyB0aGUgcHJvcFR5cGVzIGRlZmluaXRpb24sXG4gKiBwcm92aWRlZCBieSB0aGUgdHlwZS5cbiAqXG4gKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gZWxlbWVudFxuICovXG5cblxuZnVuY3Rpb24gdmFsaWRhdGVQcm9wVHlwZXMoZWxlbWVudCkge1xuICB7XG4gICAgdmFyIHR5cGUgPSBlbGVtZW50LnR5cGU7XG5cbiAgICBpZiAodHlwZSA9PT0gbnVsbCB8fCB0eXBlID09PSB1bmRlZmluZWQgfHwgdHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHByb3BUeXBlcztcblxuICAgIGlmICh0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcHJvcFR5cGVzID0gdHlwZS5wcm9wVHlwZXM7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcgJiYgKHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgfHwgLy8gTm90ZTogTWVtbyBvbmx5IGNoZWNrcyBvdXRlciBwcm9wcyBoZXJlLlxuICAgIC8vIElubmVyIHByb3BzIGFyZSBjaGVja2VkIGluIHRoZSByZWNvbmNpbGVyLlxuICAgIHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX01FTU9fVFlQRSkpIHtcbiAgICAgIHByb3BUeXBlcyA9IHR5cGUucHJvcFR5cGVzO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHByb3BUeXBlcykge1xuICAgICAgLy8gSW50ZW50aW9uYWxseSBpbnNpZGUgdG8gYXZvaWQgdHJpZ2dlcmluZyBsYXp5IGluaXRpYWxpemVyczpcbiAgICAgIHZhciBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZSh0eXBlKTtcbiAgICAgIGNoZWNrUHJvcFR5cGVzKHByb3BUeXBlcywgZWxlbWVudC5wcm9wcywgJ3Byb3AnLCBuYW1lLCBlbGVtZW50KTtcbiAgICB9IGVsc2UgaWYgKHR5cGUuUHJvcFR5cGVzICE9PSB1bmRlZmluZWQgJiYgIXByb3BUeXBlc01pc3NwZWxsV2FybmluZ1Nob3duKSB7XG4gICAgICBwcm9wVHlwZXNNaXNzcGVsbFdhcm5pbmdTaG93biA9IHRydWU7IC8vIEludGVudGlvbmFsbHkgaW5zaWRlIHRvIGF2b2lkIHRyaWdnZXJpbmcgbGF6eSBpbml0aWFsaXplcnM6XG5cbiAgICAgIHZhciBfbmFtZSA9IGdldENvbXBvbmVudE5hbWUodHlwZSk7XG5cbiAgICAgIGVycm9yKCdDb21wb25lbnQgJXMgZGVjbGFyZWQgYFByb3BUeXBlc2AgaW5zdGVhZCBvZiBgcHJvcFR5cGVzYC4gRGlkIHlvdSBtaXNzcGVsbCB0aGUgcHJvcGVydHkgYXNzaWdubWVudD8nLCBfbmFtZSB8fCAnVW5rbm93bicpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgdHlwZS5nZXREZWZhdWx0UHJvcHMgPT09ICdmdW5jdGlvbicgJiYgIXR5cGUuZ2V0RGVmYXVsdFByb3BzLmlzUmVhY3RDbGFzc0FwcHJvdmVkKSB7XG4gICAgICBlcnJvcignZ2V0RGVmYXVsdFByb3BzIGlzIG9ubHkgdXNlZCBvbiBjbGFzc2ljIFJlYWN0LmNyZWF0ZUNsYXNzICcgKyAnZGVmaW5pdGlvbnMuIFVzZSBhIHN0YXRpYyBwcm9wZXJ0eSBuYW1lZCBgZGVmYXVsdFByb3BzYCBpbnN0ZWFkLicpO1xuICAgIH1cbiAgfVxufVxuLyoqXG4gKiBHaXZlbiBhIGZyYWdtZW50LCB2YWxpZGF0ZSB0aGF0IGl0IGNhbiBvbmx5IGJlIHByb3ZpZGVkIHdpdGggZnJhZ21lbnQgcHJvcHNcbiAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBmcmFnbWVudFxuICovXG5cblxuZnVuY3Rpb24gdmFsaWRhdGVGcmFnbWVudFByb3BzKGZyYWdtZW50KSB7XG4gIHtcbiAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGZyYWdtZW50LnByb3BzKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGtleSA9IGtleXNbaV07XG5cbiAgICAgIGlmIChrZXkgIT09ICdjaGlsZHJlbicgJiYga2V5ICE9PSAna2V5Jykge1xuICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKGZyYWdtZW50KTtcblxuICAgICAgICBlcnJvcignSW52YWxpZCBwcm9wIGAlc2Agc3VwcGxpZWQgdG8gYFJlYWN0LkZyYWdtZW50YC4gJyArICdSZWFjdC5GcmFnbWVudCBjYW4gb25seSBoYXZlIGBrZXlgIGFuZCBgY2hpbGRyZW5gIHByb3BzLicsIGtleSk7XG5cbiAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShudWxsKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGZyYWdtZW50LnJlZiAhPT0gbnVsbCkge1xuICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShmcmFnbWVudCk7XG5cbiAgICAgIGVycm9yKCdJbnZhbGlkIGF0dHJpYnV0ZSBgcmVmYCBzdXBwbGllZCB0byBgUmVhY3QuRnJhZ21lbnRgLicpO1xuXG4gICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKG51bGwpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gY3JlYXRlRWxlbWVudFdpdGhWYWxpZGF0aW9uKHR5cGUsIHByb3BzLCBjaGlsZHJlbikge1xuICB2YXIgdmFsaWRUeXBlID0gaXNWYWxpZEVsZW1lbnRUeXBlKHR5cGUpOyAvLyBXZSB3YXJuIGluIHRoaXMgY2FzZSBidXQgZG9uJ3QgdGhyb3cuIFdlIGV4cGVjdCB0aGUgZWxlbWVudCBjcmVhdGlvbiB0b1xuICAvLyBzdWNjZWVkIGFuZCB0aGVyZSB3aWxsIGxpa2VseSBiZSBlcnJvcnMgaW4gcmVuZGVyLlxuXG4gIGlmICghdmFsaWRUeXBlKSB7XG4gICAgdmFyIGluZm8gPSAnJztcblxuICAgIGlmICh0eXBlID09PSB1bmRlZmluZWQgfHwgdHlwZW9mIHR5cGUgPT09ICdvYmplY3QnICYmIHR5cGUgIT09IG51bGwgJiYgT2JqZWN0LmtleXModHlwZSkubGVuZ3RoID09PSAwKSB7XG4gICAgICBpbmZvICs9ICcgWW91IGxpa2VseSBmb3Jnb3QgdG8gZXhwb3J0IHlvdXIgY29tcG9uZW50IGZyb20gdGhlIGZpbGUgJyArIFwiaXQncyBkZWZpbmVkIGluLCBvciB5b3UgbWlnaHQgaGF2ZSBtaXhlZCB1cCBkZWZhdWx0IGFuZCBuYW1lZCBpbXBvcnRzLlwiO1xuICAgIH1cblxuICAgIHZhciBzb3VyY2VJbmZvID0gZ2V0U291cmNlSW5mb0Vycm9yQWRkZW5kdW1Gb3JQcm9wcyhwcm9wcyk7XG5cbiAgICBpZiAoc291cmNlSW5mbykge1xuICAgICAgaW5mbyArPSBzb3VyY2VJbmZvO1xuICAgIH0gZWxzZSB7XG4gICAgICBpbmZvICs9IGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bSgpO1xuICAgIH1cblxuICAgIHZhciB0eXBlU3RyaW5nO1xuXG4gICAgaWYgKHR5cGUgPT09IG51bGwpIHtcbiAgICAgIHR5cGVTdHJpbmcgPSAnbnVsbCc7XG4gICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHR5cGUpKSB7XG4gICAgICB0eXBlU3RyaW5nID0gJ2FycmF5JztcbiAgICB9IGVsc2UgaWYgKHR5cGUgIT09IHVuZGVmaW5lZCAmJiB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEUpIHtcbiAgICAgIHR5cGVTdHJpbmcgPSBcIjxcIiArIChnZXRDb21wb25lbnROYW1lKHR5cGUudHlwZSkgfHwgJ1Vua25vd24nKSArIFwiIC8+XCI7XG4gICAgICBpbmZvID0gJyBEaWQgeW91IGFjY2lkZW50YWxseSBleHBvcnQgYSBKU1ggbGl0ZXJhbCBpbnN0ZWFkIG9mIGEgY29tcG9uZW50Pyc7XG4gICAgfSBlbHNlIHtcbiAgICAgIHR5cGVTdHJpbmcgPSB0eXBlb2YgdHlwZTtcbiAgICB9XG5cbiAgICB7XG4gICAgICBlcnJvcignUmVhY3QuY3JlYXRlRWxlbWVudDogdHlwZSBpcyBpbnZhbGlkIC0tIGV4cGVjdGVkIGEgc3RyaW5nIChmb3IgJyArICdidWlsdC1pbiBjb21wb25lbnRzKSBvciBhIGNsYXNzL2Z1bmN0aW9uIChmb3IgY29tcG9zaXRlICcgKyAnY29tcG9uZW50cykgYnV0IGdvdDogJXMuJXMnLCB0eXBlU3RyaW5nLCBpbmZvKTtcbiAgICB9XG4gIH1cblxuICB2YXIgZWxlbWVudCA9IGNyZWF0ZUVsZW1lbnQuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgLy8gVGhlIHJlc3VsdCBjYW4gYmUgbnVsbGlzaCBpZiBhIG1vY2sgb3IgYSBjdXN0b20gZnVuY3Rpb24gaXMgdXNlZC5cbiAgLy8gVE9ETzogRHJvcCB0aGlzIHdoZW4gdGhlc2UgYXJlIG5vIGxvbmdlciBhbGxvd2VkIGFzIHRoZSB0eXBlIGFyZ3VtZW50LlxuXG4gIGlmIChlbGVtZW50ID09IG51bGwpIHtcbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfSAvLyBTa2lwIGtleSB3YXJuaW5nIGlmIHRoZSB0eXBlIGlzbid0IHZhbGlkIHNpbmNlIG91ciBrZXkgdmFsaWRhdGlvbiBsb2dpY1xuICAvLyBkb2Vzbid0IGV4cGVjdCBhIG5vbi1zdHJpbmcvZnVuY3Rpb24gdHlwZSBhbmQgY2FuIHRocm93IGNvbmZ1c2luZyBlcnJvcnMuXG4gIC8vIFdlIGRvbid0IHdhbnQgZXhjZXB0aW9uIGJlaGF2aW9yIHRvIGRpZmZlciBiZXR3ZWVuIGRldiBhbmQgcHJvZC5cbiAgLy8gKFJlbmRlcmluZyB3aWxsIHRocm93IHdpdGggYSBoZWxwZnVsIG1lc3NhZ2UgYW5kIGFzIHNvb24gYXMgdGhlIHR5cGUgaXNcbiAgLy8gZml4ZWQsIHRoZSBrZXkgd2FybmluZ3Mgd2lsbCBhcHBlYXIuKVxuXG5cbiAgaWYgKHZhbGlkVHlwZSkge1xuICAgIGZvciAodmFyIGkgPSAyOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YWxpZGF0ZUNoaWxkS2V5cyhhcmd1bWVudHNbaV0sIHR5cGUpO1xuICAgIH1cbiAgfVxuXG4gIGlmICh0eXBlID09PSBleHBvcnRzLkZyYWdtZW50KSB7XG4gICAgdmFsaWRhdGVGcmFnbWVudFByb3BzKGVsZW1lbnQpO1xuICB9IGVsc2Uge1xuICAgIHZhbGlkYXRlUHJvcFR5cGVzKGVsZW1lbnQpO1xuICB9XG5cbiAgcmV0dXJuIGVsZW1lbnQ7XG59XG52YXIgZGlkV2FybkFib3V0RGVwcmVjYXRlZENyZWF0ZUZhY3RvcnkgPSBmYWxzZTtcbmZ1bmN0aW9uIGNyZWF0ZUZhY3RvcnlXaXRoVmFsaWRhdGlvbih0eXBlKSB7XG4gIHZhciB2YWxpZGF0ZWRGYWN0b3J5ID0gY3JlYXRlRWxlbWVudFdpdGhWYWxpZGF0aW9uLmJpbmQobnVsbCwgdHlwZSk7XG4gIHZhbGlkYXRlZEZhY3RvcnkudHlwZSA9IHR5cGU7XG5cbiAge1xuICAgIGlmICghZGlkV2FybkFib3V0RGVwcmVjYXRlZENyZWF0ZUZhY3RvcnkpIHtcbiAgICAgIGRpZFdhcm5BYm91dERlcHJlY2F0ZWRDcmVhdGVGYWN0b3J5ID0gdHJ1ZTtcblxuICAgICAgd2FybignUmVhY3QuY3JlYXRlRmFjdG9yeSgpIGlzIGRlcHJlY2F0ZWQgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiAnICsgJ2EgZnV0dXJlIG1ham9yIHJlbGVhc2UuIENvbnNpZGVyIHVzaW5nIEpTWCAnICsgJ29yIHVzZSBSZWFjdC5jcmVhdGVFbGVtZW50KCkgZGlyZWN0bHkgaW5zdGVhZC4nKTtcbiAgICB9IC8vIExlZ2FjeSBob29rOiByZW1vdmUgaXRcblxuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHZhbGlkYXRlZEZhY3RvcnksICd0eXBlJywge1xuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgd2FybignRmFjdG9yeS50eXBlIGlzIGRlcHJlY2F0ZWQuIEFjY2VzcyB0aGUgY2xhc3MgZGlyZWN0bHkgJyArICdiZWZvcmUgcGFzc2luZyBpdCB0byBjcmVhdGVGYWN0b3J5LicpO1xuXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAndHlwZScsIHtcbiAgICAgICAgICB2YWx1ZTogdHlwZVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHR5cGU7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gdmFsaWRhdGVkRmFjdG9yeTtcbn1cbmZ1bmN0aW9uIGNsb25lRWxlbWVudFdpdGhWYWxpZGF0aW9uKGVsZW1lbnQsIHByb3BzLCBjaGlsZHJlbikge1xuICB2YXIgbmV3RWxlbWVudCA9IGNsb25lRWxlbWVudC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG4gIGZvciAodmFyIGkgPSAyOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFsaWRhdGVDaGlsZEtleXMoYXJndW1lbnRzW2ldLCBuZXdFbGVtZW50LnR5cGUpO1xuICB9XG5cbiAgdmFsaWRhdGVQcm9wVHlwZXMobmV3RWxlbWVudCk7XG4gIHJldHVybiBuZXdFbGVtZW50O1xufVxuXG57XG5cbiAgdHJ5IHtcbiAgICB2YXIgZnJvemVuT2JqZWN0ID0gT2JqZWN0LmZyZWV6ZSh7fSk7XG4gICAgLyogZXNsaW50LWRpc2FibGUgbm8tbmV3ICovXG5cbiAgICBuZXcgTWFwKFtbZnJvemVuT2JqZWN0LCBudWxsXV0pO1xuICAgIG5ldyBTZXQoW2Zyb3plbk9iamVjdF0pO1xuICAgIC8qIGVzbGludC1lbmFibGUgbm8tbmV3ICovXG4gIH0gY2F0Y2ggKGUpIHtcbiAgfVxufVxuXG52YXIgY3JlYXRlRWxlbWVudCQxID0gIGNyZWF0ZUVsZW1lbnRXaXRoVmFsaWRhdGlvbiA7XG52YXIgY2xvbmVFbGVtZW50JDEgPSAgY2xvbmVFbGVtZW50V2l0aFZhbGlkYXRpb24gO1xudmFyIGNyZWF0ZUZhY3RvcnkgPSAgY3JlYXRlRmFjdG9yeVdpdGhWYWxpZGF0aW9uIDtcbnZhciBDaGlsZHJlbiA9IHtcbiAgbWFwOiBtYXBDaGlsZHJlbixcbiAgZm9yRWFjaDogZm9yRWFjaENoaWxkcmVuLFxuICBjb3VudDogY291bnRDaGlsZHJlbixcbiAgdG9BcnJheTogdG9BcnJheSxcbiAgb25seTogb25seUNoaWxkXG59O1xuXG5leHBvcnRzLkNoaWxkcmVuID0gQ2hpbGRyZW47XG5leHBvcnRzLkNvbXBvbmVudCA9IENvbXBvbmVudDtcbmV4cG9ydHMuUHVyZUNvbXBvbmVudCA9IFB1cmVDb21wb25lbnQ7XG5leHBvcnRzLl9fU0VDUkVUX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVEID0gUmVhY3RTaGFyZWRJbnRlcm5hbHM7XG5leHBvcnRzLmNsb25lRWxlbWVudCA9IGNsb25lRWxlbWVudCQxO1xuZXhwb3J0cy5jcmVhdGVDb250ZXh0ID0gY3JlYXRlQ29udGV4dDtcbmV4cG9ydHMuY3JlYXRlRWxlbWVudCA9IGNyZWF0ZUVsZW1lbnQkMTtcbmV4cG9ydHMuY3JlYXRlRmFjdG9yeSA9IGNyZWF0ZUZhY3Rvcnk7XG5leHBvcnRzLmNyZWF0ZVJlZiA9IGNyZWF0ZVJlZjtcbmV4cG9ydHMuZm9yd2FyZFJlZiA9IGZvcndhcmRSZWY7XG5leHBvcnRzLmlzVmFsaWRFbGVtZW50ID0gaXNWYWxpZEVsZW1lbnQ7XG5leHBvcnRzLmxhenkgPSBsYXp5O1xuZXhwb3J0cy5tZW1vID0gbWVtbztcbmV4cG9ydHMudXNlQ2FsbGJhY2sgPSB1c2VDYWxsYmFjaztcbmV4cG9ydHMudXNlQ29udGV4dCA9IHVzZUNvbnRleHQ7XG5leHBvcnRzLnVzZURlYnVnVmFsdWUgPSB1c2VEZWJ1Z1ZhbHVlO1xuZXhwb3J0cy51c2VFZmZlY3QgPSB1c2VFZmZlY3Q7XG5leHBvcnRzLnVzZUltcGVyYXRpdmVIYW5kbGUgPSB1c2VJbXBlcmF0aXZlSGFuZGxlO1xuZXhwb3J0cy51c2VMYXlvdXRFZmZlY3QgPSB1c2VMYXlvdXRFZmZlY3Q7XG5leHBvcnRzLnVzZU1lbW8gPSB1c2VNZW1vO1xuZXhwb3J0cy51c2VSZWR1Y2VyID0gdXNlUmVkdWNlcjtcbmV4cG9ydHMudXNlUmVmID0gdXNlUmVmO1xuZXhwb3J0cy51c2VTdGF0ZSA9IHVzZVN0YXRlO1xuZXhwb3J0cy52ZXJzaW9uID0gUmVhY3RWZXJzaW9uO1xuICB9KSgpO1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJykge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3JlYWN0LnByb2R1Y3Rpb24ubWluLmpzJyk7XG59IGVsc2Uge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3JlYWN0LmRldmVsb3BtZW50LmpzJyk7XG59XG4iLCIvKiogQGxpY2Vuc2UgUmVhY3QgdjAuMjAuMlxuICogc2NoZWR1bGVyLXRyYWNpbmcuZGV2ZWxvcG1lbnQuanNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgKGZ1bmN0aW9uKCkge1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgREVGQVVMVF9USFJFQURfSUQgPSAwOyAvLyBDb3VudGVycyB1c2VkIHRvIGdlbmVyYXRlIHVuaXF1ZSBJRHMuXG5cbnZhciBpbnRlcmFjdGlvbklEQ291bnRlciA9IDA7XG52YXIgdGhyZWFkSURDb3VudGVyID0gMDsgLy8gU2V0IG9mIGN1cnJlbnRseSB0cmFjZWQgaW50ZXJhY3Rpb25zLlxuLy8gSW50ZXJhY3Rpb25zIFwic3RhY2tcIuKAk1xuLy8gTWVhbmluZyB0aGF0IG5ld2x5IHRyYWNlZCBpbnRlcmFjdGlvbnMgYXJlIGFwcGVuZGVkIHRvIHRoZSBwcmV2aW91c2x5IGFjdGl2ZSBzZXQuXG4vLyBXaGVuIGFuIGludGVyYWN0aW9uIGdvZXMgb3V0IG9mIHNjb3BlLCB0aGUgcHJldmlvdXMgc2V0IChpZiBhbnkpIGlzIHJlc3RvcmVkLlxuXG5leHBvcnRzLl9faW50ZXJhY3Rpb25zUmVmID0gbnVsbDsgLy8gTGlzdGVuZXIocykgdG8gbm90aWZ5IHdoZW4gaW50ZXJhY3Rpb25zIGJlZ2luIGFuZCBlbmQuXG5cbmV4cG9ydHMuX19zdWJzY3JpYmVyUmVmID0gbnVsbDtcblxue1xuICBleHBvcnRzLl9faW50ZXJhY3Rpb25zUmVmID0ge1xuICAgIGN1cnJlbnQ6IG5ldyBTZXQoKVxuICB9O1xuICBleHBvcnRzLl9fc3Vic2NyaWJlclJlZiA9IHtcbiAgICBjdXJyZW50OiBudWxsXG4gIH07XG59XG5mdW5jdGlvbiB1bnN0YWJsZV9jbGVhcihjYWxsYmFjaykge1xuXG4gIHZhciBwcmV2SW50ZXJhY3Rpb25zID0gZXhwb3J0cy5fX2ludGVyYWN0aW9uc1JlZi5jdXJyZW50O1xuICBleHBvcnRzLl9faW50ZXJhY3Rpb25zUmVmLmN1cnJlbnQgPSBuZXcgU2V0KCk7XG5cbiAgdHJ5IHtcbiAgICByZXR1cm4gY2FsbGJhY2soKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBleHBvcnRzLl9faW50ZXJhY3Rpb25zUmVmLmN1cnJlbnQgPSBwcmV2SW50ZXJhY3Rpb25zO1xuICB9XG59XG5mdW5jdGlvbiB1bnN0YWJsZV9nZXRDdXJyZW50KCkge1xuICB7XG4gICAgcmV0dXJuIGV4cG9ydHMuX19pbnRlcmFjdGlvbnNSZWYuY3VycmVudDtcbiAgfVxufVxuZnVuY3Rpb24gdW5zdGFibGVfZ2V0VGhyZWFkSUQoKSB7XG4gIHJldHVybiArK3RocmVhZElEQ291bnRlcjtcbn1cbmZ1bmN0aW9uIHVuc3RhYmxlX3RyYWNlKG5hbWUsIHRpbWVzdGFtcCwgY2FsbGJhY2spIHtcbiAgdmFyIHRocmVhZElEID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiBERUZBVUxUX1RIUkVBRF9JRDtcblxuICB2YXIgaW50ZXJhY3Rpb24gPSB7XG4gICAgX19jb3VudDogMSxcbiAgICBpZDogaW50ZXJhY3Rpb25JRENvdW50ZXIrKyxcbiAgICBuYW1lOiBuYW1lLFxuICAgIHRpbWVzdGFtcDogdGltZXN0YW1wXG4gIH07XG4gIHZhciBwcmV2SW50ZXJhY3Rpb25zID0gZXhwb3J0cy5fX2ludGVyYWN0aW9uc1JlZi5jdXJyZW50OyAvLyBUcmFjZWQgaW50ZXJhY3Rpb25zIHNob3VsZCBzdGFjay9hY2N1bXVsYXRlLlxuICAvLyBUbyBkbyB0aGF0LCBjbG9uZSB0aGUgY3VycmVudCBpbnRlcmFjdGlvbnMuXG4gIC8vIFRoZSBwcmV2aW91cyBzZXQgd2lsbCBiZSByZXN0b3JlZCB1cG9uIGNvbXBsZXRpb24uXG5cbiAgdmFyIGludGVyYWN0aW9ucyA9IG5ldyBTZXQocHJldkludGVyYWN0aW9ucyk7XG4gIGludGVyYWN0aW9ucy5hZGQoaW50ZXJhY3Rpb24pO1xuICBleHBvcnRzLl9faW50ZXJhY3Rpb25zUmVmLmN1cnJlbnQgPSBpbnRlcmFjdGlvbnM7XG4gIHZhciBzdWJzY3JpYmVyID0gZXhwb3J0cy5fX3N1YnNjcmliZXJSZWYuY3VycmVudDtcbiAgdmFyIHJldHVyblZhbHVlO1xuXG4gIHRyeSB7XG4gICAgaWYgKHN1YnNjcmliZXIgIT09IG51bGwpIHtcbiAgICAgIHN1YnNjcmliZXIub25JbnRlcmFjdGlvblRyYWNlZChpbnRlcmFjdGlvbik7XG4gICAgfVxuICB9IGZpbmFsbHkge1xuICAgIHRyeSB7XG4gICAgICBpZiAoc3Vic2NyaWJlciAhPT0gbnVsbCkge1xuICAgICAgICBzdWJzY3JpYmVyLm9uV29ya1N0YXJ0ZWQoaW50ZXJhY3Rpb25zLCB0aHJlYWRJRCk7XG4gICAgICB9XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVyblZhbHVlID0gY2FsbGJhY2soKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGV4cG9ydHMuX19pbnRlcmFjdGlvbnNSZWYuY3VycmVudCA9IHByZXZJbnRlcmFjdGlvbnM7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBpZiAoc3Vic2NyaWJlciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgc3Vic2NyaWJlci5vbldvcmtTdG9wcGVkKGludGVyYWN0aW9ucywgdGhyZWFkSUQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBpbnRlcmFjdGlvbi5fX2NvdW50LS07IC8vIElmIG5vIGFzeW5jIHdvcmsgd2FzIHNjaGVkdWxlZCBmb3IgdGhpcyBpbnRlcmFjdGlvbixcbiAgICAgICAgICAvLyBOb3RpZnkgc3Vic2NyaWJlcnMgdGhhdCBpdCdzIGNvbXBsZXRlZC5cblxuICAgICAgICAgIGlmIChzdWJzY3JpYmVyICE9PSBudWxsICYmIGludGVyYWN0aW9uLl9fY291bnQgPT09IDApIHtcbiAgICAgICAgICAgIHN1YnNjcmliZXIub25JbnRlcmFjdGlvblNjaGVkdWxlZFdvcmtDb21wbGV0ZWQoaW50ZXJhY3Rpb24pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXR1cm5WYWx1ZTtcbn1cbmZ1bmN0aW9uIHVuc3RhYmxlX3dyYXAoY2FsbGJhY2spIHtcbiAgdmFyIHRocmVhZElEID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBERUZBVUxUX1RIUkVBRF9JRDtcblxuICB2YXIgd3JhcHBlZEludGVyYWN0aW9ucyA9IGV4cG9ydHMuX19pbnRlcmFjdGlvbnNSZWYuY3VycmVudDtcbiAgdmFyIHN1YnNjcmliZXIgPSBleHBvcnRzLl9fc3Vic2NyaWJlclJlZi5jdXJyZW50O1xuXG4gIGlmIChzdWJzY3JpYmVyICE9PSBudWxsKSB7XG4gICAgc3Vic2NyaWJlci5vbldvcmtTY2hlZHVsZWQod3JhcHBlZEludGVyYWN0aW9ucywgdGhyZWFkSUQpO1xuICB9IC8vIFVwZGF0ZSB0aGUgcGVuZGluZyBhc3luYyB3b3JrIGNvdW50IGZvciB0aGUgY3VycmVudCBpbnRlcmFjdGlvbnMuXG4gIC8vIFVwZGF0ZSBhZnRlciBjYWxsaW5nIHN1YnNjcmliZXJzIGluIGNhc2Ugb2YgZXJyb3IuXG5cblxuICB3cmFwcGVkSW50ZXJhY3Rpb25zLmZvckVhY2goZnVuY3Rpb24gKGludGVyYWN0aW9uKSB7XG4gICAgaW50ZXJhY3Rpb24uX19jb3VudCsrO1xuICB9KTtcbiAgdmFyIGhhc1J1biA9IGZhbHNlO1xuXG4gIGZ1bmN0aW9uIHdyYXBwZWQoKSB7XG4gICAgdmFyIHByZXZJbnRlcmFjdGlvbnMgPSBleHBvcnRzLl9faW50ZXJhY3Rpb25zUmVmLmN1cnJlbnQ7XG4gICAgZXhwb3J0cy5fX2ludGVyYWN0aW9uc1JlZi5jdXJyZW50ID0gd3JhcHBlZEludGVyYWN0aW9ucztcbiAgICBzdWJzY3JpYmVyID0gZXhwb3J0cy5fX3N1YnNjcmliZXJSZWYuY3VycmVudDtcblxuICAgIHRyeSB7XG4gICAgICB2YXIgcmV0dXJuVmFsdWU7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGlmIChzdWJzY3JpYmVyICE9PSBudWxsKSB7XG4gICAgICAgICAgc3Vic2NyaWJlci5vbldvcmtTdGFydGVkKHdyYXBwZWRJbnRlcmFjdGlvbnMsIHRocmVhZElEKTtcbiAgICAgICAgfVxuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXR1cm5WYWx1ZSA9IGNhbGxiYWNrLmFwcGx5KHVuZGVmaW5lZCwgYXJndW1lbnRzKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBleHBvcnRzLl9faW50ZXJhY3Rpb25zUmVmLmN1cnJlbnQgPSBwcmV2SW50ZXJhY3Rpb25zO1xuXG4gICAgICAgICAgaWYgKHN1YnNjcmliZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHN1YnNjcmliZXIub25Xb3JrU3RvcHBlZCh3cmFwcGVkSW50ZXJhY3Rpb25zLCB0aHJlYWRJRCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXR1cm5WYWx1ZTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgaWYgKCFoYXNSdW4pIHtcbiAgICAgICAgLy8gV2Ugb25seSBleHBlY3QgYSB3cmFwcGVkIGZ1bmN0aW9uIHRvIGJlIGV4ZWN1dGVkIG9uY2UsXG4gICAgICAgIC8vIEJ1dCBpbiB0aGUgZXZlbnQgdGhhdCBpdCdzIGV4ZWN1dGVkIG1vcmUgdGhhbiBvbmNl4oCTXG4gICAgICAgIC8vIE9ubHkgZGVjcmVtZW50IHRoZSBvdXRzdGFuZGluZyBpbnRlcmFjdGlvbiBjb3VudHMgb25jZS5cbiAgICAgICAgaGFzUnVuID0gdHJ1ZTsgLy8gVXBkYXRlIHBlbmRpbmcgYXN5bmMgY291bnRzIGZvciBhbGwgd3JhcHBlZCBpbnRlcmFjdGlvbnMuXG4gICAgICAgIC8vIElmIHRoaXMgd2FzIHRoZSBsYXN0IHNjaGVkdWxlZCBhc3luYyB3b3JrIGZvciBhbnkgb2YgdGhlbSxcbiAgICAgICAgLy8gTWFyayB0aGVtIGFzIGNvbXBsZXRlZC5cblxuICAgICAgICB3cmFwcGVkSW50ZXJhY3Rpb25zLmZvckVhY2goZnVuY3Rpb24gKGludGVyYWN0aW9uKSB7XG4gICAgICAgICAgaW50ZXJhY3Rpb24uX19jb3VudC0tO1xuXG4gICAgICAgICAgaWYgKHN1YnNjcmliZXIgIT09IG51bGwgJiYgaW50ZXJhY3Rpb24uX19jb3VudCA9PT0gMCkge1xuICAgICAgICAgICAgc3Vic2NyaWJlci5vbkludGVyYWN0aW9uU2NoZWR1bGVkV29ya0NvbXBsZXRlZChpbnRlcmFjdGlvbik7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB3cmFwcGVkLmNhbmNlbCA9IGZ1bmN0aW9uIGNhbmNlbCgpIHtcbiAgICBzdWJzY3JpYmVyID0gZXhwb3J0cy5fX3N1YnNjcmliZXJSZWYuY3VycmVudDtcblxuICAgIHRyeSB7XG4gICAgICBpZiAoc3Vic2NyaWJlciAhPT0gbnVsbCkge1xuICAgICAgICBzdWJzY3JpYmVyLm9uV29ya0NhbmNlbGVkKHdyYXBwZWRJbnRlcmFjdGlvbnMsIHRocmVhZElEKTtcbiAgICAgIH1cbiAgICB9IGZpbmFsbHkge1xuICAgICAgLy8gVXBkYXRlIHBlbmRpbmcgYXN5bmMgY291bnRzIGZvciBhbGwgd3JhcHBlZCBpbnRlcmFjdGlvbnMuXG4gICAgICAvLyBJZiB0aGlzIHdhcyB0aGUgbGFzdCBzY2hlZHVsZWQgYXN5bmMgd29yayBmb3IgYW55IG9mIHRoZW0sXG4gICAgICAvLyBNYXJrIHRoZW0gYXMgY29tcGxldGVkLlxuICAgICAgd3JhcHBlZEludGVyYWN0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChpbnRlcmFjdGlvbikge1xuICAgICAgICBpbnRlcmFjdGlvbi5fX2NvdW50LS07XG5cbiAgICAgICAgaWYgKHN1YnNjcmliZXIgJiYgaW50ZXJhY3Rpb24uX19jb3VudCA9PT0gMCkge1xuICAgICAgICAgIHN1YnNjcmliZXIub25JbnRlcmFjdGlvblNjaGVkdWxlZFdvcmtDb21wbGV0ZWQoaW50ZXJhY3Rpb24pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIHdyYXBwZWQ7XG59XG5cbnZhciBzdWJzY3JpYmVycyA9IG51bGw7XG5cbntcbiAgc3Vic2NyaWJlcnMgPSBuZXcgU2V0KCk7XG59XG5cbmZ1bmN0aW9uIHVuc3RhYmxlX3N1YnNjcmliZShzdWJzY3JpYmVyKSB7XG4gIHtcbiAgICBzdWJzY3JpYmVycy5hZGQoc3Vic2NyaWJlcik7XG5cbiAgICBpZiAoc3Vic2NyaWJlcnMuc2l6ZSA9PT0gMSkge1xuICAgICAgZXhwb3J0cy5fX3N1YnNjcmliZXJSZWYuY3VycmVudCA9IHtcbiAgICAgICAgb25JbnRlcmFjdGlvblNjaGVkdWxlZFdvcmtDb21wbGV0ZWQ6IG9uSW50ZXJhY3Rpb25TY2hlZHVsZWRXb3JrQ29tcGxldGVkLFxuICAgICAgICBvbkludGVyYWN0aW9uVHJhY2VkOiBvbkludGVyYWN0aW9uVHJhY2VkLFxuICAgICAgICBvbldvcmtDYW5jZWxlZDogb25Xb3JrQ2FuY2VsZWQsXG4gICAgICAgIG9uV29ya1NjaGVkdWxlZDogb25Xb3JrU2NoZWR1bGVkLFxuICAgICAgICBvbldvcmtTdGFydGVkOiBvbldvcmtTdGFydGVkLFxuICAgICAgICBvbldvcmtTdG9wcGVkOiBvbldvcmtTdG9wcGVkXG4gICAgICB9O1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gdW5zdGFibGVfdW5zdWJzY3JpYmUoc3Vic2NyaWJlcikge1xuICB7XG4gICAgc3Vic2NyaWJlcnMuZGVsZXRlKHN1YnNjcmliZXIpO1xuXG4gICAgaWYgKHN1YnNjcmliZXJzLnNpemUgPT09IDApIHtcbiAgICAgIGV4cG9ydHMuX19zdWJzY3JpYmVyUmVmLmN1cnJlbnQgPSBudWxsO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBvbkludGVyYWN0aW9uVHJhY2VkKGludGVyYWN0aW9uKSB7XG4gIHZhciBkaWRDYXRjaEVycm9yID0gZmFsc2U7XG4gIHZhciBjYXVnaHRFcnJvciA9IG51bGw7XG4gIHN1YnNjcmliZXJzLmZvckVhY2goZnVuY3Rpb24gKHN1YnNjcmliZXIpIHtcbiAgICB0cnkge1xuICAgICAgc3Vic2NyaWJlci5vbkludGVyYWN0aW9uVHJhY2VkKGludGVyYWN0aW9uKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaWYgKCFkaWRDYXRjaEVycm9yKSB7XG4gICAgICAgIGRpZENhdGNoRXJyb3IgPSB0cnVlO1xuICAgICAgICBjYXVnaHRFcnJvciA9IGVycm9yO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG5cbiAgaWYgKGRpZENhdGNoRXJyb3IpIHtcbiAgICB0aHJvdyBjYXVnaHRFcnJvcjtcbiAgfVxufVxuXG5mdW5jdGlvbiBvbkludGVyYWN0aW9uU2NoZWR1bGVkV29ya0NvbXBsZXRlZChpbnRlcmFjdGlvbikge1xuICB2YXIgZGlkQ2F0Y2hFcnJvciA9IGZhbHNlO1xuICB2YXIgY2F1Z2h0RXJyb3IgPSBudWxsO1xuICBzdWJzY3JpYmVycy5mb3JFYWNoKGZ1bmN0aW9uIChzdWJzY3JpYmVyKSB7XG4gICAgdHJ5IHtcbiAgICAgIHN1YnNjcmliZXIub25JbnRlcmFjdGlvblNjaGVkdWxlZFdvcmtDb21wbGV0ZWQoaW50ZXJhY3Rpb24pO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBpZiAoIWRpZENhdGNoRXJyb3IpIHtcbiAgICAgICAgZGlkQ2F0Y2hFcnJvciA9IHRydWU7XG4gICAgICAgIGNhdWdodEVycm9yID0gZXJyb3I7XG4gICAgICB9XG4gICAgfVxuICB9KTtcblxuICBpZiAoZGlkQ2F0Y2hFcnJvcikge1xuICAgIHRocm93IGNhdWdodEVycm9yO1xuICB9XG59XG5cbmZ1bmN0aW9uIG9uV29ya1NjaGVkdWxlZChpbnRlcmFjdGlvbnMsIHRocmVhZElEKSB7XG4gIHZhciBkaWRDYXRjaEVycm9yID0gZmFsc2U7XG4gIHZhciBjYXVnaHRFcnJvciA9IG51bGw7XG4gIHN1YnNjcmliZXJzLmZvckVhY2goZnVuY3Rpb24gKHN1YnNjcmliZXIpIHtcbiAgICB0cnkge1xuICAgICAgc3Vic2NyaWJlci5vbldvcmtTY2hlZHVsZWQoaW50ZXJhY3Rpb25zLCB0aHJlYWRJRCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmICghZGlkQ2F0Y2hFcnJvcikge1xuICAgICAgICBkaWRDYXRjaEVycm9yID0gdHJ1ZTtcbiAgICAgICAgY2F1Z2h0RXJyb3IgPSBlcnJvcjtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuXG4gIGlmIChkaWRDYXRjaEVycm9yKSB7XG4gICAgdGhyb3cgY2F1Z2h0RXJyb3I7XG4gIH1cbn1cblxuZnVuY3Rpb24gb25Xb3JrU3RhcnRlZChpbnRlcmFjdGlvbnMsIHRocmVhZElEKSB7XG4gIHZhciBkaWRDYXRjaEVycm9yID0gZmFsc2U7XG4gIHZhciBjYXVnaHRFcnJvciA9IG51bGw7XG4gIHN1YnNjcmliZXJzLmZvckVhY2goZnVuY3Rpb24gKHN1YnNjcmliZXIpIHtcbiAgICB0cnkge1xuICAgICAgc3Vic2NyaWJlci5vbldvcmtTdGFydGVkKGludGVyYWN0aW9ucywgdGhyZWFkSUQpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBpZiAoIWRpZENhdGNoRXJyb3IpIHtcbiAgICAgICAgZGlkQ2F0Y2hFcnJvciA9IHRydWU7XG4gICAgICAgIGNhdWdodEVycm9yID0gZXJyb3I7XG4gICAgICB9XG4gICAgfVxuICB9KTtcblxuICBpZiAoZGlkQ2F0Y2hFcnJvcikge1xuICAgIHRocm93IGNhdWdodEVycm9yO1xuICB9XG59XG5cbmZ1bmN0aW9uIG9uV29ya1N0b3BwZWQoaW50ZXJhY3Rpb25zLCB0aHJlYWRJRCkge1xuICB2YXIgZGlkQ2F0Y2hFcnJvciA9IGZhbHNlO1xuICB2YXIgY2F1Z2h0RXJyb3IgPSBudWxsO1xuICBzdWJzY3JpYmVycy5mb3JFYWNoKGZ1bmN0aW9uIChzdWJzY3JpYmVyKSB7XG4gICAgdHJ5IHtcbiAgICAgIHN1YnNjcmliZXIub25Xb3JrU3RvcHBlZChpbnRlcmFjdGlvbnMsIHRocmVhZElEKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaWYgKCFkaWRDYXRjaEVycm9yKSB7XG4gICAgICAgIGRpZENhdGNoRXJyb3IgPSB0cnVlO1xuICAgICAgICBjYXVnaHRFcnJvciA9IGVycm9yO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG5cbiAgaWYgKGRpZENhdGNoRXJyb3IpIHtcbiAgICB0aHJvdyBjYXVnaHRFcnJvcjtcbiAgfVxufVxuXG5mdW5jdGlvbiBvbldvcmtDYW5jZWxlZChpbnRlcmFjdGlvbnMsIHRocmVhZElEKSB7XG4gIHZhciBkaWRDYXRjaEVycm9yID0gZmFsc2U7XG4gIHZhciBjYXVnaHRFcnJvciA9IG51bGw7XG4gIHN1YnNjcmliZXJzLmZvckVhY2goZnVuY3Rpb24gKHN1YnNjcmliZXIpIHtcbiAgICB0cnkge1xuICAgICAgc3Vic2NyaWJlci5vbldvcmtDYW5jZWxlZChpbnRlcmFjdGlvbnMsIHRocmVhZElEKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaWYgKCFkaWRDYXRjaEVycm9yKSB7XG4gICAgICAgIGRpZENhdGNoRXJyb3IgPSB0cnVlO1xuICAgICAgICBjYXVnaHRFcnJvciA9IGVycm9yO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG5cbiAgaWYgKGRpZENhdGNoRXJyb3IpIHtcbiAgICB0aHJvdyBjYXVnaHRFcnJvcjtcbiAgfVxufVxuXG5leHBvcnRzLnVuc3RhYmxlX2NsZWFyID0gdW5zdGFibGVfY2xlYXI7XG5leHBvcnRzLnVuc3RhYmxlX2dldEN1cnJlbnQgPSB1bnN0YWJsZV9nZXRDdXJyZW50O1xuZXhwb3J0cy51bnN0YWJsZV9nZXRUaHJlYWRJRCA9IHVuc3RhYmxlX2dldFRocmVhZElEO1xuZXhwb3J0cy51bnN0YWJsZV9zdWJzY3JpYmUgPSB1bnN0YWJsZV9zdWJzY3JpYmU7XG5leHBvcnRzLnVuc3RhYmxlX3RyYWNlID0gdW5zdGFibGVfdHJhY2U7XG5leHBvcnRzLnVuc3RhYmxlX3Vuc3Vic2NyaWJlID0gdW5zdGFibGVfdW5zdWJzY3JpYmU7XG5leHBvcnRzLnVuc3RhYmxlX3dyYXAgPSB1bnN0YWJsZV93cmFwO1xuICB9KSgpO1xufVxuIiwiLyoqIEBsaWNlbnNlIFJlYWN0IHYwLjIwLjJcbiAqIHNjaGVkdWxlci5kZXZlbG9wbWVudC5qc1xuICpcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAoZnVuY3Rpb24oKSB7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBlbmFibGVTY2hlZHVsZXJEZWJ1Z2dpbmcgPSBmYWxzZTtcbnZhciBlbmFibGVQcm9maWxpbmcgPSBmYWxzZTtcblxudmFyIHJlcXVlc3RIb3N0Q2FsbGJhY2s7XG52YXIgcmVxdWVzdEhvc3RUaW1lb3V0O1xudmFyIGNhbmNlbEhvc3RUaW1lb3V0O1xudmFyIHJlcXVlc3RQYWludDtcbnZhciBoYXNQZXJmb3JtYW5jZU5vdyA9IHR5cGVvZiBwZXJmb3JtYW5jZSA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIHBlcmZvcm1hbmNlLm5vdyA9PT0gJ2Z1bmN0aW9uJztcblxuaWYgKGhhc1BlcmZvcm1hbmNlTm93KSB7XG4gIHZhciBsb2NhbFBlcmZvcm1hbmNlID0gcGVyZm9ybWFuY2U7XG5cbiAgZXhwb3J0cy51bnN0YWJsZV9ub3cgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGxvY2FsUGVyZm9ybWFuY2Uubm93KCk7XG4gIH07XG59IGVsc2Uge1xuICB2YXIgbG9jYWxEYXRlID0gRGF0ZTtcbiAgdmFyIGluaXRpYWxUaW1lID0gbG9jYWxEYXRlLm5vdygpO1xuXG4gIGV4cG9ydHMudW5zdGFibGVfbm93ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBsb2NhbERhdGUubm93KCkgLSBpbml0aWFsVGltZTtcbiAgfTtcbn1cblxuaWYgKCAvLyBJZiBTY2hlZHVsZXIgcnVucyBpbiBhIG5vbi1ET00gZW52aXJvbm1lbnQsIGl0IGZhbGxzIGJhY2sgdG8gYSBuYWl2ZVxuLy8gaW1wbGVtZW50YXRpb24gdXNpbmcgc2V0VGltZW91dC5cbnR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnIHx8IC8vIENoZWNrIGlmIE1lc3NhZ2VDaGFubmVsIGlzIHN1cHBvcnRlZCwgdG9vLlxudHlwZW9mIE1lc3NhZ2VDaGFubmVsICE9PSAnZnVuY3Rpb24nKSB7XG4gIC8vIElmIHRoaXMgYWNjaWRlbnRhbGx5IGdldHMgaW1wb3J0ZWQgaW4gYSBub24tYnJvd3NlciBlbnZpcm9ubWVudCwgZS5nLiBKYXZhU2NyaXB0Q29yZSxcbiAgLy8gZmFsbGJhY2sgdG8gYSBuYWl2ZSBpbXBsZW1lbnRhdGlvbi5cbiAgdmFyIF9jYWxsYmFjayA9IG51bGw7XG4gIHZhciBfdGltZW91dElEID0gbnVsbDtcblxuICB2YXIgX2ZsdXNoQ2FsbGJhY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKF9jYWxsYmFjayAhPT0gbnVsbCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIGN1cnJlbnRUaW1lID0gZXhwb3J0cy51bnN0YWJsZV9ub3coKTtcbiAgICAgICAgdmFyIGhhc1JlbWFpbmluZ1RpbWUgPSB0cnVlO1xuXG4gICAgICAgIF9jYWxsYmFjayhoYXNSZW1haW5pbmdUaW1lLCBjdXJyZW50VGltZSk7XG5cbiAgICAgICAgX2NhbGxiYWNrID0gbnVsbDtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgc2V0VGltZW91dChfZmx1c2hDYWxsYmFjaywgMCk7XG4gICAgICAgIHRocm93IGU7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIHJlcXVlc3RIb3N0Q2FsbGJhY2sgPSBmdW5jdGlvbiAoY2IpIHtcbiAgICBpZiAoX2NhbGxiYWNrICE9PSBudWxsKSB7XG4gICAgICAvLyBQcm90ZWN0IGFnYWluc3QgcmUtZW50cmFuY3kuXG4gICAgICBzZXRUaW1lb3V0KHJlcXVlc3RIb3N0Q2FsbGJhY2ssIDAsIGNiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgX2NhbGxiYWNrID0gY2I7XG4gICAgICBzZXRUaW1lb3V0KF9mbHVzaENhbGxiYWNrLCAwKTtcbiAgICB9XG4gIH07XG5cbiAgcmVxdWVzdEhvc3RUaW1lb3V0ID0gZnVuY3Rpb24gKGNiLCBtcykge1xuICAgIF90aW1lb3V0SUQgPSBzZXRUaW1lb3V0KGNiLCBtcyk7XG4gIH07XG5cbiAgY2FuY2VsSG9zdFRpbWVvdXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgY2xlYXJUaW1lb3V0KF90aW1lb3V0SUQpO1xuICB9O1xuXG4gIGV4cG9ydHMudW5zdGFibGVfc2hvdWxkWWllbGQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xuXG4gIHJlcXVlc3RQYWludCA9IGV4cG9ydHMudW5zdGFibGVfZm9yY2VGcmFtZVJhdGUgPSBmdW5jdGlvbiAoKSB7fTtcbn0gZWxzZSB7XG4gIC8vIENhcHR1cmUgbG9jYWwgcmVmZXJlbmNlcyB0byBuYXRpdmUgQVBJcywgaW4gY2FzZSBhIHBvbHlmaWxsIG92ZXJyaWRlcyB0aGVtLlxuICB2YXIgX3NldFRpbWVvdXQgPSB3aW5kb3cuc2V0VGltZW91dDtcbiAgdmFyIF9jbGVhclRpbWVvdXQgPSB3aW5kb3cuY2xlYXJUaW1lb3V0O1xuXG4gIGlmICh0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAvLyBUT0RPOiBTY2hlZHVsZXIgbm8gbG9uZ2VyIHJlcXVpcmVzIHRoZXNlIG1ldGhvZHMgdG8gYmUgcG9seWZpbGxlZC4gQnV0XG4gICAgLy8gbWF5YmUgd2Ugd2FudCB0byBjb250aW51ZSB3YXJuaW5nIGlmIHRoZXkgZG9uJ3QgZXhpc3QsIHRvIHByZXNlcnZlIHRoZVxuICAgIC8vIG9wdGlvbiB0byByZWx5IG9uIGl0IGluIHRoZSBmdXR1cmU/XG4gICAgdmFyIHJlcXVlc3RBbmltYXRpb25GcmFtZSA9IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWU7XG4gICAgdmFyIGNhbmNlbEFuaW1hdGlvbkZyYW1lID0gd2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lO1xuXG4gICAgaWYgKHR5cGVvZiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIC8vIFVzaW5nIGNvbnNvbGVbJ2Vycm9yJ10gdG8gZXZhZGUgQmFiZWwgYW5kIEVTTGludFxuICAgICAgY29uc29sZVsnZXJyb3InXShcIlRoaXMgYnJvd3NlciBkb2Vzbid0IHN1cHBvcnQgcmVxdWVzdEFuaW1hdGlvbkZyYW1lLiBcIiArICdNYWtlIHN1cmUgdGhhdCB5b3UgbG9hZCBhICcgKyAncG9seWZpbGwgaW4gb2xkZXIgYnJvd3NlcnMuIGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9yZWFjdC1wb2x5ZmlsbHMnKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGNhbmNlbEFuaW1hdGlvbkZyYW1lICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAvLyBVc2luZyBjb25zb2xlWydlcnJvciddIHRvIGV2YWRlIEJhYmVsIGFuZCBFU0xpbnRcbiAgICAgIGNvbnNvbGVbJ2Vycm9yJ10oXCJUaGlzIGJyb3dzZXIgZG9lc24ndCBzdXBwb3J0IGNhbmNlbEFuaW1hdGlvbkZyYW1lLiBcIiArICdNYWtlIHN1cmUgdGhhdCB5b3UgbG9hZCBhICcgKyAncG9seWZpbGwgaW4gb2xkZXIgYnJvd3NlcnMuIGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9yZWFjdC1wb2x5ZmlsbHMnKTtcbiAgICB9XG4gIH1cblxuICB2YXIgaXNNZXNzYWdlTG9vcFJ1bm5pbmcgPSBmYWxzZTtcbiAgdmFyIHNjaGVkdWxlZEhvc3RDYWxsYmFjayA9IG51bGw7XG4gIHZhciB0YXNrVGltZW91dElEID0gLTE7IC8vIFNjaGVkdWxlciBwZXJpb2RpY2FsbHkgeWllbGRzIGluIGNhc2UgdGhlcmUgaXMgb3RoZXIgd29yayBvbiB0aGUgbWFpblxuICAvLyB0aHJlYWQsIGxpa2UgdXNlciBldmVudHMuIEJ5IGRlZmF1bHQsIGl0IHlpZWxkcyBtdWx0aXBsZSB0aW1lcyBwZXIgZnJhbWUuXG4gIC8vIEl0IGRvZXMgbm90IGF0dGVtcHQgdG8gYWxpZ24gd2l0aCBmcmFtZSBib3VuZGFyaWVzLCBzaW5jZSBtb3N0IHRhc2tzIGRvbid0XG4gIC8vIG5lZWQgdG8gYmUgZnJhbWUgYWxpZ25lZDsgZm9yIHRob3NlIHRoYXQgZG8sIHVzZSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUuXG5cbiAgdmFyIHlpZWxkSW50ZXJ2YWwgPSA1O1xuICB2YXIgZGVhZGxpbmUgPSAwOyAvLyBUT0RPOiBNYWtlIHRoaXMgY29uZmlndXJhYmxlXG5cbiAge1xuICAgIC8vIGBpc0lucHV0UGVuZGluZ2AgaXMgbm90IGF2YWlsYWJsZS4gU2luY2Ugd2UgaGF2ZSBubyB3YXkgb2Yga25vd2luZyBpZlxuICAgIC8vIHRoZXJlJ3MgcGVuZGluZyBpbnB1dCwgYWx3YXlzIHlpZWxkIGF0IHRoZSBlbmQgb2YgdGhlIGZyYW1lLlxuICAgIGV4cG9ydHMudW5zdGFibGVfc2hvdWxkWWllbGQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gZXhwb3J0cy51bnN0YWJsZV9ub3coKSA+PSBkZWFkbGluZTtcbiAgICB9OyAvLyBTaW5jZSB3ZSB5aWVsZCBldmVyeSBmcmFtZSByZWdhcmRsZXNzLCBgcmVxdWVzdFBhaW50YCBoYXMgbm8gZWZmZWN0LlxuXG5cbiAgICByZXF1ZXN0UGFpbnQgPSBmdW5jdGlvbiAoKSB7fTtcbiAgfVxuXG4gIGV4cG9ydHMudW5zdGFibGVfZm9yY2VGcmFtZVJhdGUgPSBmdW5jdGlvbiAoZnBzKSB7XG4gICAgaWYgKGZwcyA8IDAgfHwgZnBzID4gMTI1KSB7XG4gICAgICAvLyBVc2luZyBjb25zb2xlWydlcnJvciddIHRvIGV2YWRlIEJhYmVsIGFuZCBFU0xpbnRcbiAgICAgIGNvbnNvbGVbJ2Vycm9yJ10oJ2ZvcmNlRnJhbWVSYXRlIHRha2VzIGEgcG9zaXRpdmUgaW50IGJldHdlZW4gMCBhbmQgMTI1LCAnICsgJ2ZvcmNpbmcgZnJhbWUgcmF0ZXMgaGlnaGVyIHRoYW4gMTI1IGZwcyBpcyBub3Qgc3VwcG9ydGVkJyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGZwcyA+IDApIHtcbiAgICAgIHlpZWxkSW50ZXJ2YWwgPSBNYXRoLmZsb29yKDEwMDAgLyBmcHMpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyByZXNldCB0aGUgZnJhbWVyYXRlXG4gICAgICB5aWVsZEludGVydmFsID0gNTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIHBlcmZvcm1Xb3JrVW50aWxEZWFkbGluZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoc2NoZWR1bGVkSG9zdENhbGxiYWNrICE9PSBudWxsKSB7XG4gICAgICB2YXIgY3VycmVudFRpbWUgPSBleHBvcnRzLnVuc3RhYmxlX25vdygpOyAvLyBZaWVsZCBhZnRlciBgeWllbGRJbnRlcnZhbGAgbXMsIHJlZ2FyZGxlc3Mgb2Ygd2hlcmUgd2UgYXJlIGluIHRoZSB2c3luY1xuICAgICAgLy8gY3ljbGUuIFRoaXMgbWVhbnMgdGhlcmUncyBhbHdheXMgdGltZSByZW1haW5pbmcgYXQgdGhlIGJlZ2lubmluZyBvZlxuICAgICAgLy8gdGhlIG1lc3NhZ2UgZXZlbnQuXG5cbiAgICAgIGRlYWRsaW5lID0gY3VycmVudFRpbWUgKyB5aWVsZEludGVydmFsO1xuICAgICAgdmFyIGhhc1RpbWVSZW1haW5pbmcgPSB0cnVlO1xuXG4gICAgICB0cnkge1xuICAgICAgICB2YXIgaGFzTW9yZVdvcmsgPSBzY2hlZHVsZWRIb3N0Q2FsbGJhY2soaGFzVGltZVJlbWFpbmluZywgY3VycmVudFRpbWUpO1xuXG4gICAgICAgIGlmICghaGFzTW9yZVdvcmspIHtcbiAgICAgICAgICBpc01lc3NhZ2VMb29wUnVubmluZyA9IGZhbHNlO1xuICAgICAgICAgIHNjaGVkdWxlZEhvc3RDYWxsYmFjayA9IG51bGw7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gSWYgdGhlcmUncyBtb3JlIHdvcmssIHNjaGVkdWxlIHRoZSBuZXh0IG1lc3NhZ2UgZXZlbnQgYXQgdGhlIGVuZFxuICAgICAgICAgIC8vIG9mIHRoZSBwcmVjZWRpbmcgb25lLlxuICAgICAgICAgIHBvcnQucG9zdE1lc3NhZ2UobnVsbCk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIC8vIElmIGEgc2NoZWR1bGVyIHRhc2sgdGhyb3dzLCBleGl0IHRoZSBjdXJyZW50IGJyb3dzZXIgdGFzayBzbyB0aGVcbiAgICAgICAgLy8gZXJyb3IgY2FuIGJlIG9ic2VydmVkLlxuICAgICAgICBwb3J0LnBvc3RNZXNzYWdlKG51bGwpO1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaXNNZXNzYWdlTG9vcFJ1bm5pbmcgPSBmYWxzZTtcbiAgICB9IC8vIFlpZWxkaW5nIHRvIHRoZSBicm93c2VyIHdpbGwgZ2l2ZSBpdCBhIGNoYW5jZSB0byBwYWludCwgc28gd2UgY2FuXG4gIH07XG5cbiAgdmFyIGNoYW5uZWwgPSBuZXcgTWVzc2FnZUNoYW5uZWwoKTtcbiAgdmFyIHBvcnQgPSBjaGFubmVsLnBvcnQyO1xuICBjaGFubmVsLnBvcnQxLm9ubWVzc2FnZSA9IHBlcmZvcm1Xb3JrVW50aWxEZWFkbGluZTtcblxuICByZXF1ZXN0SG9zdENhbGxiYWNrID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgc2NoZWR1bGVkSG9zdENhbGxiYWNrID0gY2FsbGJhY2s7XG5cbiAgICBpZiAoIWlzTWVzc2FnZUxvb3BSdW5uaW5nKSB7XG4gICAgICBpc01lc3NhZ2VMb29wUnVubmluZyA9IHRydWU7XG4gICAgICBwb3J0LnBvc3RNZXNzYWdlKG51bGwpO1xuICAgIH1cbiAgfTtcblxuICByZXF1ZXN0SG9zdFRpbWVvdXQgPSBmdW5jdGlvbiAoY2FsbGJhY2ssIG1zKSB7XG4gICAgdGFza1RpbWVvdXRJRCA9IF9zZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIGNhbGxiYWNrKGV4cG9ydHMudW5zdGFibGVfbm93KCkpO1xuICAgIH0sIG1zKTtcbiAgfTtcblxuICBjYW5jZWxIb3N0VGltZW91dCA9IGZ1bmN0aW9uICgpIHtcbiAgICBfY2xlYXJUaW1lb3V0KHRhc2tUaW1lb3V0SUQpO1xuXG4gICAgdGFza1RpbWVvdXRJRCA9IC0xO1xuICB9O1xufVxuXG5mdW5jdGlvbiBwdXNoKGhlYXAsIG5vZGUpIHtcbiAgdmFyIGluZGV4ID0gaGVhcC5sZW5ndGg7XG4gIGhlYXAucHVzaChub2RlKTtcbiAgc2lmdFVwKGhlYXAsIG5vZGUsIGluZGV4KTtcbn1cbmZ1bmN0aW9uIHBlZWsoaGVhcCkge1xuICB2YXIgZmlyc3QgPSBoZWFwWzBdO1xuICByZXR1cm4gZmlyc3QgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBmaXJzdDtcbn1cbmZ1bmN0aW9uIHBvcChoZWFwKSB7XG4gIHZhciBmaXJzdCA9IGhlYXBbMF07XG5cbiAgaWYgKGZpcnN0ICE9PSB1bmRlZmluZWQpIHtcbiAgICB2YXIgbGFzdCA9IGhlYXAucG9wKCk7XG5cbiAgICBpZiAobGFzdCAhPT0gZmlyc3QpIHtcbiAgICAgIGhlYXBbMF0gPSBsYXN0O1xuICAgICAgc2lmdERvd24oaGVhcCwgbGFzdCwgMCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZpcnN0O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBudWxsO1xuICB9XG59XG5cbmZ1bmN0aW9uIHNpZnRVcChoZWFwLCBub2RlLCBpKSB7XG4gIHZhciBpbmRleCA9IGk7XG5cbiAgd2hpbGUgKHRydWUpIHtcbiAgICB2YXIgcGFyZW50SW5kZXggPSBpbmRleCAtIDEgPj4+IDE7XG4gICAgdmFyIHBhcmVudCA9IGhlYXBbcGFyZW50SW5kZXhdO1xuXG4gICAgaWYgKHBhcmVudCAhPT0gdW5kZWZpbmVkICYmIGNvbXBhcmUocGFyZW50LCBub2RlKSA+IDApIHtcbiAgICAgIC8vIFRoZSBwYXJlbnQgaXMgbGFyZ2VyLiBTd2FwIHBvc2l0aW9ucy5cbiAgICAgIGhlYXBbcGFyZW50SW5kZXhdID0gbm9kZTtcbiAgICAgIGhlYXBbaW5kZXhdID0gcGFyZW50O1xuICAgICAgaW5kZXggPSBwYXJlbnRJbmRleDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVGhlIHBhcmVudCBpcyBzbWFsbGVyLiBFeGl0LlxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBzaWZ0RG93bihoZWFwLCBub2RlLCBpKSB7XG4gIHZhciBpbmRleCA9IGk7XG4gIHZhciBsZW5ndGggPSBoZWFwLmxlbmd0aDtcblxuICB3aGlsZSAoaW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgbGVmdEluZGV4ID0gKGluZGV4ICsgMSkgKiAyIC0gMTtcbiAgICB2YXIgbGVmdCA9IGhlYXBbbGVmdEluZGV4XTtcbiAgICB2YXIgcmlnaHRJbmRleCA9IGxlZnRJbmRleCArIDE7XG4gICAgdmFyIHJpZ2h0ID0gaGVhcFtyaWdodEluZGV4XTsgLy8gSWYgdGhlIGxlZnQgb3IgcmlnaHQgbm9kZSBpcyBzbWFsbGVyLCBzd2FwIHdpdGggdGhlIHNtYWxsZXIgb2YgdGhvc2UuXG5cbiAgICBpZiAobGVmdCAhPT0gdW5kZWZpbmVkICYmIGNvbXBhcmUobGVmdCwgbm9kZSkgPCAwKSB7XG4gICAgICBpZiAocmlnaHQgIT09IHVuZGVmaW5lZCAmJiBjb21wYXJlKHJpZ2h0LCBsZWZ0KSA8IDApIHtcbiAgICAgICAgaGVhcFtpbmRleF0gPSByaWdodDtcbiAgICAgICAgaGVhcFtyaWdodEluZGV4XSA9IG5vZGU7XG4gICAgICAgIGluZGV4ID0gcmlnaHRJbmRleDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGhlYXBbaW5kZXhdID0gbGVmdDtcbiAgICAgICAgaGVhcFtsZWZ0SW5kZXhdID0gbm9kZTtcbiAgICAgICAgaW5kZXggPSBsZWZ0SW5kZXg7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChyaWdodCAhPT0gdW5kZWZpbmVkICYmIGNvbXBhcmUocmlnaHQsIG5vZGUpIDwgMCkge1xuICAgICAgaGVhcFtpbmRleF0gPSByaWdodDtcbiAgICAgIGhlYXBbcmlnaHRJbmRleF0gPSBub2RlO1xuICAgICAgaW5kZXggPSByaWdodEluZGV4O1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBOZWl0aGVyIGNoaWxkIGlzIHNtYWxsZXIuIEV4aXQuXG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNvbXBhcmUoYSwgYikge1xuICAvLyBDb21wYXJlIHNvcnQgaW5kZXggZmlyc3QsIHRoZW4gdGFzayBpZC5cbiAgdmFyIGRpZmYgPSBhLnNvcnRJbmRleCAtIGIuc29ydEluZGV4O1xuICByZXR1cm4gZGlmZiAhPT0gMCA/IGRpZmYgOiBhLmlkIC0gYi5pZDtcbn1cblxuLy8gVE9ETzogVXNlIHN5bWJvbHM/XG52YXIgSW1tZWRpYXRlUHJpb3JpdHkgPSAxO1xudmFyIFVzZXJCbG9ja2luZ1ByaW9yaXR5ID0gMjtcbnZhciBOb3JtYWxQcmlvcml0eSA9IDM7XG52YXIgTG93UHJpb3JpdHkgPSA0O1xudmFyIElkbGVQcmlvcml0eSA9IDU7XG5cbmZ1bmN0aW9uIG1hcmtUYXNrRXJyb3JlZCh0YXNrLCBtcykge1xufVxuXG4vKiBlc2xpbnQtZGlzYWJsZSBuby12YXIgKi9cbi8vIE1hdGgucG93KDIsIDMwKSAtIDFcbi8vIDBiMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExXG5cbnZhciBtYXhTaWduZWQzMUJpdEludCA9IDEwNzM3NDE4MjM7IC8vIFRpbWVzIG91dCBpbW1lZGlhdGVseVxuXG52YXIgSU1NRURJQVRFX1BSSU9SSVRZX1RJTUVPVVQgPSAtMTsgLy8gRXZlbnR1YWxseSB0aW1lcyBvdXRcblxudmFyIFVTRVJfQkxPQ0tJTkdfUFJJT1JJVFlfVElNRU9VVCA9IDI1MDtcbnZhciBOT1JNQUxfUFJJT1JJVFlfVElNRU9VVCA9IDUwMDA7XG52YXIgTE9XX1BSSU9SSVRZX1RJTUVPVVQgPSAxMDAwMDsgLy8gTmV2ZXIgdGltZXMgb3V0XG5cbnZhciBJRExFX1BSSU9SSVRZX1RJTUVPVVQgPSBtYXhTaWduZWQzMUJpdEludDsgLy8gVGFza3MgYXJlIHN0b3JlZCBvbiBhIG1pbiBoZWFwXG5cbnZhciB0YXNrUXVldWUgPSBbXTtcbnZhciB0aW1lclF1ZXVlID0gW107IC8vIEluY3JlbWVudGluZyBpZCBjb3VudGVyLiBVc2VkIHRvIG1haW50YWluIGluc2VydGlvbiBvcmRlci5cblxudmFyIHRhc2tJZENvdW50ZXIgPSAxOyAvLyBQYXVzaW5nIHRoZSBzY2hlZHVsZXIgaXMgdXNlZnVsIGZvciBkZWJ1Z2dpbmcuXG52YXIgY3VycmVudFRhc2sgPSBudWxsO1xudmFyIGN1cnJlbnRQcmlvcml0eUxldmVsID0gTm9ybWFsUHJpb3JpdHk7IC8vIFRoaXMgaXMgc2V0IHdoaWxlIHBlcmZvcm1pbmcgd29yaywgdG8gcHJldmVudCByZS1lbnRyYW5jeS5cblxudmFyIGlzUGVyZm9ybWluZ1dvcmsgPSBmYWxzZTtcbnZhciBpc0hvc3RDYWxsYmFja1NjaGVkdWxlZCA9IGZhbHNlO1xudmFyIGlzSG9zdFRpbWVvdXRTY2hlZHVsZWQgPSBmYWxzZTtcblxuZnVuY3Rpb24gYWR2YW5jZVRpbWVycyhjdXJyZW50VGltZSkge1xuICAvLyBDaGVjayBmb3IgdGFza3MgdGhhdCBhcmUgbm8gbG9uZ2VyIGRlbGF5ZWQgYW5kIGFkZCB0aGVtIHRvIHRoZSBxdWV1ZS5cbiAgdmFyIHRpbWVyID0gcGVlayh0aW1lclF1ZXVlKTtcblxuICB3aGlsZSAodGltZXIgIT09IG51bGwpIHtcbiAgICBpZiAodGltZXIuY2FsbGJhY2sgPT09IG51bGwpIHtcbiAgICAgIC8vIFRpbWVyIHdhcyBjYW5jZWxsZWQuXG4gICAgICBwb3AodGltZXJRdWV1ZSk7XG4gICAgfSBlbHNlIGlmICh0aW1lci5zdGFydFRpbWUgPD0gY3VycmVudFRpbWUpIHtcbiAgICAgIC8vIFRpbWVyIGZpcmVkLiBUcmFuc2ZlciB0byB0aGUgdGFzayBxdWV1ZS5cbiAgICAgIHBvcCh0aW1lclF1ZXVlKTtcbiAgICAgIHRpbWVyLnNvcnRJbmRleCA9IHRpbWVyLmV4cGlyYXRpb25UaW1lO1xuICAgICAgcHVzaCh0YXNrUXVldWUsIHRpbWVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gUmVtYWluaW5nIHRpbWVycyBhcmUgcGVuZGluZy5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aW1lciA9IHBlZWsodGltZXJRdWV1ZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaGFuZGxlVGltZW91dChjdXJyZW50VGltZSkge1xuICBpc0hvc3RUaW1lb3V0U2NoZWR1bGVkID0gZmFsc2U7XG4gIGFkdmFuY2VUaW1lcnMoY3VycmVudFRpbWUpO1xuXG4gIGlmICghaXNIb3N0Q2FsbGJhY2tTY2hlZHVsZWQpIHtcbiAgICBpZiAocGVlayh0YXNrUXVldWUpICE9PSBudWxsKSB7XG4gICAgICBpc0hvc3RDYWxsYmFja1NjaGVkdWxlZCA9IHRydWU7XG4gICAgICByZXF1ZXN0SG9zdENhbGxiYWNrKGZsdXNoV29yayk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBmaXJzdFRpbWVyID0gcGVlayh0aW1lclF1ZXVlKTtcblxuICAgICAgaWYgKGZpcnN0VGltZXIgIT09IG51bGwpIHtcbiAgICAgICAgcmVxdWVzdEhvc3RUaW1lb3V0KGhhbmRsZVRpbWVvdXQsIGZpcnN0VGltZXIuc3RhcnRUaW1lIC0gY3VycmVudFRpbWUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBmbHVzaFdvcmsoaGFzVGltZVJlbWFpbmluZywgaW5pdGlhbFRpbWUpIHtcblxuXG4gIGlzSG9zdENhbGxiYWNrU2NoZWR1bGVkID0gZmFsc2U7XG5cbiAgaWYgKGlzSG9zdFRpbWVvdXRTY2hlZHVsZWQpIHtcbiAgICAvLyBXZSBzY2hlZHVsZWQgYSB0aW1lb3V0IGJ1dCBpdCdzIG5vIGxvbmdlciBuZWVkZWQuIENhbmNlbCBpdC5cbiAgICBpc0hvc3RUaW1lb3V0U2NoZWR1bGVkID0gZmFsc2U7XG4gICAgY2FuY2VsSG9zdFRpbWVvdXQoKTtcbiAgfVxuXG4gIGlzUGVyZm9ybWluZ1dvcmsgPSB0cnVlO1xuICB2YXIgcHJldmlvdXNQcmlvcml0eUxldmVsID0gY3VycmVudFByaW9yaXR5TGV2ZWw7XG5cbiAgdHJ5IHtcbiAgICBpZiAoZW5hYmxlUHJvZmlsaW5nKSB7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gd29ya0xvb3AoaGFzVGltZVJlbWFpbmluZywgaW5pdGlhbFRpbWUpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgaWYgKGN1cnJlbnRUYXNrICE9PSBudWxsKSB7XG4gICAgICAgICAgdmFyIGN1cnJlbnRUaW1lID0gZXhwb3J0cy51bnN0YWJsZV9ub3coKTtcbiAgICAgICAgICBtYXJrVGFza0Vycm9yZWQoY3VycmVudFRhc2ssIGN1cnJlbnRUaW1lKTtcbiAgICAgICAgICBjdXJyZW50VGFzay5pc1F1ZXVlZCA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIE5vIGNhdGNoIGluIHByb2QgY29kZSBwYXRoLlxuICAgICAgcmV0dXJuIHdvcmtMb29wKGhhc1RpbWVSZW1haW5pbmcsIGluaXRpYWxUaW1lKTtcbiAgICB9XG4gIH0gZmluYWxseSB7XG4gICAgY3VycmVudFRhc2sgPSBudWxsO1xuICAgIGN1cnJlbnRQcmlvcml0eUxldmVsID0gcHJldmlvdXNQcmlvcml0eUxldmVsO1xuICAgIGlzUGVyZm9ybWluZ1dvcmsgPSBmYWxzZTtcbiAgfVxufVxuXG5mdW5jdGlvbiB3b3JrTG9vcChoYXNUaW1lUmVtYWluaW5nLCBpbml0aWFsVGltZSkge1xuICB2YXIgY3VycmVudFRpbWUgPSBpbml0aWFsVGltZTtcbiAgYWR2YW5jZVRpbWVycyhjdXJyZW50VGltZSk7XG4gIGN1cnJlbnRUYXNrID0gcGVlayh0YXNrUXVldWUpO1xuXG4gIHdoaWxlIChjdXJyZW50VGFzayAhPT0gbnVsbCAmJiAhKGVuYWJsZVNjaGVkdWxlckRlYnVnZ2luZyApKSB7XG4gICAgaWYgKGN1cnJlbnRUYXNrLmV4cGlyYXRpb25UaW1lID4gY3VycmVudFRpbWUgJiYgKCFoYXNUaW1lUmVtYWluaW5nIHx8IGV4cG9ydHMudW5zdGFibGVfc2hvdWxkWWllbGQoKSkpIHtcbiAgICAgIC8vIFRoaXMgY3VycmVudFRhc2sgaGFzbid0IGV4cGlyZWQsIGFuZCB3ZSd2ZSByZWFjaGVkIHRoZSBkZWFkbGluZS5cbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIHZhciBjYWxsYmFjayA9IGN1cnJlbnRUYXNrLmNhbGxiYWNrO1xuXG4gICAgaWYgKHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY3VycmVudFRhc2suY2FsbGJhY2sgPSBudWxsO1xuICAgICAgY3VycmVudFByaW9yaXR5TGV2ZWwgPSBjdXJyZW50VGFzay5wcmlvcml0eUxldmVsO1xuICAgICAgdmFyIGRpZFVzZXJDYWxsYmFja1RpbWVvdXQgPSBjdXJyZW50VGFzay5leHBpcmF0aW9uVGltZSA8PSBjdXJyZW50VGltZTtcblxuICAgICAgdmFyIGNvbnRpbnVhdGlvbkNhbGxiYWNrID0gY2FsbGJhY2soZGlkVXNlckNhbGxiYWNrVGltZW91dCk7XG4gICAgICBjdXJyZW50VGltZSA9IGV4cG9ydHMudW5zdGFibGVfbm93KCk7XG5cbiAgICAgIGlmICh0eXBlb2YgY29udGludWF0aW9uQ2FsbGJhY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgY3VycmVudFRhc2suY2FsbGJhY2sgPSBjb250aW51YXRpb25DYWxsYmFjaztcbiAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgaWYgKGN1cnJlbnRUYXNrID09PSBwZWVrKHRhc2tRdWV1ZSkpIHtcbiAgICAgICAgICBwb3AodGFza1F1ZXVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBhZHZhbmNlVGltZXJzKGN1cnJlbnRUaW1lKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcG9wKHRhc2tRdWV1ZSk7XG4gICAgfVxuXG4gICAgY3VycmVudFRhc2sgPSBwZWVrKHRhc2tRdWV1ZSk7XG4gIH0gLy8gUmV0dXJuIHdoZXRoZXIgdGhlcmUncyBhZGRpdGlvbmFsIHdvcmtcblxuXG4gIGlmIChjdXJyZW50VGFzayAhPT0gbnVsbCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9IGVsc2Uge1xuICAgIHZhciBmaXJzdFRpbWVyID0gcGVlayh0aW1lclF1ZXVlKTtcblxuICAgIGlmIChmaXJzdFRpbWVyICE9PSBudWxsKSB7XG4gICAgICByZXF1ZXN0SG9zdFRpbWVvdXQoaGFuZGxlVGltZW91dCwgZmlyc3RUaW1lci5zdGFydFRpbWUgLSBjdXJyZW50VGltZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbmZ1bmN0aW9uIHVuc3RhYmxlX3J1bldpdGhQcmlvcml0eShwcmlvcml0eUxldmVsLCBldmVudEhhbmRsZXIpIHtcbiAgc3dpdGNoIChwcmlvcml0eUxldmVsKSB7XG4gICAgY2FzZSBJbW1lZGlhdGVQcmlvcml0eTpcbiAgICBjYXNlIFVzZXJCbG9ja2luZ1ByaW9yaXR5OlxuICAgIGNhc2UgTm9ybWFsUHJpb3JpdHk6XG4gICAgY2FzZSBMb3dQcmlvcml0eTpcbiAgICBjYXNlIElkbGVQcmlvcml0eTpcbiAgICAgIGJyZWFrO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHByaW9yaXR5TGV2ZWwgPSBOb3JtYWxQcmlvcml0eTtcbiAgfVxuXG4gIHZhciBwcmV2aW91c1ByaW9yaXR5TGV2ZWwgPSBjdXJyZW50UHJpb3JpdHlMZXZlbDtcbiAgY3VycmVudFByaW9yaXR5TGV2ZWwgPSBwcmlvcml0eUxldmVsO1xuXG4gIHRyeSB7XG4gICAgcmV0dXJuIGV2ZW50SGFuZGxlcigpO1xuICB9IGZpbmFsbHkge1xuICAgIGN1cnJlbnRQcmlvcml0eUxldmVsID0gcHJldmlvdXNQcmlvcml0eUxldmVsO1xuICB9XG59XG5cbmZ1bmN0aW9uIHVuc3RhYmxlX25leHQoZXZlbnRIYW5kbGVyKSB7XG4gIHZhciBwcmlvcml0eUxldmVsO1xuXG4gIHN3aXRjaCAoY3VycmVudFByaW9yaXR5TGV2ZWwpIHtcbiAgICBjYXNlIEltbWVkaWF0ZVByaW9yaXR5OlxuICAgIGNhc2UgVXNlckJsb2NraW5nUHJpb3JpdHk6XG4gICAgY2FzZSBOb3JtYWxQcmlvcml0eTpcbiAgICAgIC8vIFNoaWZ0IGRvd24gdG8gbm9ybWFsIHByaW9yaXR5XG4gICAgICBwcmlvcml0eUxldmVsID0gTm9ybWFsUHJpb3JpdHk7XG4gICAgICBicmVhaztcblxuICAgIGRlZmF1bHQ6XG4gICAgICAvLyBBbnl0aGluZyBsb3dlciB0aGFuIG5vcm1hbCBwcmlvcml0eSBzaG91bGQgcmVtYWluIGF0IHRoZSBjdXJyZW50IGxldmVsLlxuICAgICAgcHJpb3JpdHlMZXZlbCA9IGN1cnJlbnRQcmlvcml0eUxldmVsO1xuICAgICAgYnJlYWs7XG4gIH1cblxuICB2YXIgcHJldmlvdXNQcmlvcml0eUxldmVsID0gY3VycmVudFByaW9yaXR5TGV2ZWw7XG4gIGN1cnJlbnRQcmlvcml0eUxldmVsID0gcHJpb3JpdHlMZXZlbDtcblxuICB0cnkge1xuICAgIHJldHVybiBldmVudEhhbmRsZXIoKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBjdXJyZW50UHJpb3JpdHlMZXZlbCA9IHByZXZpb3VzUHJpb3JpdHlMZXZlbDtcbiAgfVxufVxuXG5mdW5jdGlvbiB1bnN0YWJsZV93cmFwQ2FsbGJhY2soY2FsbGJhY2spIHtcbiAgdmFyIHBhcmVudFByaW9yaXR5TGV2ZWwgPSBjdXJyZW50UHJpb3JpdHlMZXZlbDtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAvLyBUaGlzIGlzIGEgZm9yayBvZiBydW5XaXRoUHJpb3JpdHksIGlubGluZWQgZm9yIHBlcmZvcm1hbmNlLlxuICAgIHZhciBwcmV2aW91c1ByaW9yaXR5TGV2ZWwgPSBjdXJyZW50UHJpb3JpdHlMZXZlbDtcbiAgICBjdXJyZW50UHJpb3JpdHlMZXZlbCA9IHBhcmVudFByaW9yaXR5TGV2ZWw7XG5cbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGNhbGxiYWNrLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGN1cnJlbnRQcmlvcml0eUxldmVsID0gcHJldmlvdXNQcmlvcml0eUxldmVsO1xuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gdW5zdGFibGVfc2NoZWR1bGVDYWxsYmFjayhwcmlvcml0eUxldmVsLCBjYWxsYmFjaywgb3B0aW9ucykge1xuICB2YXIgY3VycmVudFRpbWUgPSBleHBvcnRzLnVuc3RhYmxlX25vdygpO1xuICB2YXIgc3RhcnRUaW1lO1xuXG4gIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ29iamVjdCcgJiYgb3B0aW9ucyAhPT0gbnVsbCkge1xuICAgIHZhciBkZWxheSA9IG9wdGlvbnMuZGVsYXk7XG5cbiAgICBpZiAodHlwZW9mIGRlbGF5ID09PSAnbnVtYmVyJyAmJiBkZWxheSA+IDApIHtcbiAgICAgIHN0YXJ0VGltZSA9IGN1cnJlbnRUaW1lICsgZGVsYXk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXJ0VGltZSA9IGN1cnJlbnRUaW1lO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBzdGFydFRpbWUgPSBjdXJyZW50VGltZTtcbiAgfVxuXG4gIHZhciB0aW1lb3V0O1xuXG4gIHN3aXRjaCAocHJpb3JpdHlMZXZlbCkge1xuICAgIGNhc2UgSW1tZWRpYXRlUHJpb3JpdHk6XG4gICAgICB0aW1lb3V0ID0gSU1NRURJQVRFX1BSSU9SSVRZX1RJTUVPVVQ7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgVXNlckJsb2NraW5nUHJpb3JpdHk6XG4gICAgICB0aW1lb3V0ID0gVVNFUl9CTE9DS0lOR19QUklPUklUWV9USU1FT1VUO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIElkbGVQcmlvcml0eTpcbiAgICAgIHRpbWVvdXQgPSBJRExFX1BSSU9SSVRZX1RJTUVPVVQ7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgTG93UHJpb3JpdHk6XG4gICAgICB0aW1lb3V0ID0gTE9XX1BSSU9SSVRZX1RJTUVPVVQ7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgTm9ybWFsUHJpb3JpdHk6XG4gICAgZGVmYXVsdDpcbiAgICAgIHRpbWVvdXQgPSBOT1JNQUxfUFJJT1JJVFlfVElNRU9VVDtcbiAgICAgIGJyZWFrO1xuICB9XG5cbiAgdmFyIGV4cGlyYXRpb25UaW1lID0gc3RhcnRUaW1lICsgdGltZW91dDtcbiAgdmFyIG5ld1Rhc2sgPSB7XG4gICAgaWQ6IHRhc2tJZENvdW50ZXIrKyxcbiAgICBjYWxsYmFjazogY2FsbGJhY2ssXG4gICAgcHJpb3JpdHlMZXZlbDogcHJpb3JpdHlMZXZlbCxcbiAgICBzdGFydFRpbWU6IHN0YXJ0VGltZSxcbiAgICBleHBpcmF0aW9uVGltZTogZXhwaXJhdGlvblRpbWUsXG4gICAgc29ydEluZGV4OiAtMVxuICB9O1xuXG4gIGlmIChzdGFydFRpbWUgPiBjdXJyZW50VGltZSkge1xuICAgIC8vIFRoaXMgaXMgYSBkZWxheWVkIHRhc2suXG4gICAgbmV3VGFzay5zb3J0SW5kZXggPSBzdGFydFRpbWU7XG4gICAgcHVzaCh0aW1lclF1ZXVlLCBuZXdUYXNrKTtcblxuICAgIGlmIChwZWVrKHRhc2tRdWV1ZSkgPT09IG51bGwgJiYgbmV3VGFzayA9PT0gcGVlayh0aW1lclF1ZXVlKSkge1xuICAgICAgLy8gQWxsIHRhc2tzIGFyZSBkZWxheWVkLCBhbmQgdGhpcyBpcyB0aGUgdGFzayB3aXRoIHRoZSBlYXJsaWVzdCBkZWxheS5cbiAgICAgIGlmIChpc0hvc3RUaW1lb3V0U2NoZWR1bGVkKSB7XG4gICAgICAgIC8vIENhbmNlbCBhbiBleGlzdGluZyB0aW1lb3V0LlxuICAgICAgICBjYW5jZWxIb3N0VGltZW91dCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaXNIb3N0VGltZW91dFNjaGVkdWxlZCA9IHRydWU7XG4gICAgICB9IC8vIFNjaGVkdWxlIGEgdGltZW91dC5cblxuXG4gICAgICByZXF1ZXN0SG9zdFRpbWVvdXQoaGFuZGxlVGltZW91dCwgc3RhcnRUaW1lIC0gY3VycmVudFRpbWUpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBuZXdUYXNrLnNvcnRJbmRleCA9IGV4cGlyYXRpb25UaW1lO1xuICAgIHB1c2godGFza1F1ZXVlLCBuZXdUYXNrKTtcbiAgICAvLyB3YWl0IHVudGlsIHRoZSBuZXh0IHRpbWUgd2UgeWllbGQuXG5cblxuICAgIGlmICghaXNIb3N0Q2FsbGJhY2tTY2hlZHVsZWQgJiYgIWlzUGVyZm9ybWluZ1dvcmspIHtcbiAgICAgIGlzSG9zdENhbGxiYWNrU2NoZWR1bGVkID0gdHJ1ZTtcbiAgICAgIHJlcXVlc3RIb3N0Q2FsbGJhY2soZmx1c2hXb3JrKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmV3VGFzaztcbn1cblxuZnVuY3Rpb24gdW5zdGFibGVfcGF1c2VFeGVjdXRpb24oKSB7XG59XG5cbmZ1bmN0aW9uIHVuc3RhYmxlX2NvbnRpbnVlRXhlY3V0aW9uKCkge1xuXG4gIGlmICghaXNIb3N0Q2FsbGJhY2tTY2hlZHVsZWQgJiYgIWlzUGVyZm9ybWluZ1dvcmspIHtcbiAgICBpc0hvc3RDYWxsYmFja1NjaGVkdWxlZCA9IHRydWU7XG4gICAgcmVxdWVzdEhvc3RDYWxsYmFjayhmbHVzaFdvcmspO1xuICB9XG59XG5cbmZ1bmN0aW9uIHVuc3RhYmxlX2dldEZpcnN0Q2FsbGJhY2tOb2RlKCkge1xuICByZXR1cm4gcGVlayh0YXNrUXVldWUpO1xufVxuXG5mdW5jdGlvbiB1bnN0YWJsZV9jYW5jZWxDYWxsYmFjayh0YXNrKSB7XG4gIC8vIHJlbW92ZSBmcm9tIHRoZSBxdWV1ZSBiZWNhdXNlIHlvdSBjYW4ndCByZW1vdmUgYXJiaXRyYXJ5IG5vZGVzIGZyb20gYW5cbiAgLy8gYXJyYXkgYmFzZWQgaGVhcCwgb25seSB0aGUgZmlyc3Qgb25lLilcblxuXG4gIHRhc2suY2FsbGJhY2sgPSBudWxsO1xufVxuXG5mdW5jdGlvbiB1bnN0YWJsZV9nZXRDdXJyZW50UHJpb3JpdHlMZXZlbCgpIHtcbiAgcmV0dXJuIGN1cnJlbnRQcmlvcml0eUxldmVsO1xufVxuXG52YXIgdW5zdGFibGVfcmVxdWVzdFBhaW50ID0gcmVxdWVzdFBhaW50O1xudmFyIHVuc3RhYmxlX1Byb2ZpbGluZyA9ICBudWxsO1xuXG5leHBvcnRzLnVuc3RhYmxlX0lkbGVQcmlvcml0eSA9IElkbGVQcmlvcml0eTtcbmV4cG9ydHMudW5zdGFibGVfSW1tZWRpYXRlUHJpb3JpdHkgPSBJbW1lZGlhdGVQcmlvcml0eTtcbmV4cG9ydHMudW5zdGFibGVfTG93UHJpb3JpdHkgPSBMb3dQcmlvcml0eTtcbmV4cG9ydHMudW5zdGFibGVfTm9ybWFsUHJpb3JpdHkgPSBOb3JtYWxQcmlvcml0eTtcbmV4cG9ydHMudW5zdGFibGVfUHJvZmlsaW5nID0gdW5zdGFibGVfUHJvZmlsaW5nO1xuZXhwb3J0cy51bnN0YWJsZV9Vc2VyQmxvY2tpbmdQcmlvcml0eSA9IFVzZXJCbG9ja2luZ1ByaW9yaXR5O1xuZXhwb3J0cy51bnN0YWJsZV9jYW5jZWxDYWxsYmFjayA9IHVuc3RhYmxlX2NhbmNlbENhbGxiYWNrO1xuZXhwb3J0cy51bnN0YWJsZV9jb250aW51ZUV4ZWN1dGlvbiA9IHVuc3RhYmxlX2NvbnRpbnVlRXhlY3V0aW9uO1xuZXhwb3J0cy51bnN0YWJsZV9nZXRDdXJyZW50UHJpb3JpdHlMZXZlbCA9IHVuc3RhYmxlX2dldEN1cnJlbnRQcmlvcml0eUxldmVsO1xuZXhwb3J0cy51bnN0YWJsZV9nZXRGaXJzdENhbGxiYWNrTm9kZSA9IHVuc3RhYmxlX2dldEZpcnN0Q2FsbGJhY2tOb2RlO1xuZXhwb3J0cy51bnN0YWJsZV9uZXh0ID0gdW5zdGFibGVfbmV4dDtcbmV4cG9ydHMudW5zdGFibGVfcGF1c2VFeGVjdXRpb24gPSB1bnN0YWJsZV9wYXVzZUV4ZWN1dGlvbjtcbmV4cG9ydHMudW5zdGFibGVfcmVxdWVzdFBhaW50ID0gdW5zdGFibGVfcmVxdWVzdFBhaW50O1xuZXhwb3J0cy51bnN0YWJsZV9ydW5XaXRoUHJpb3JpdHkgPSB1bnN0YWJsZV9ydW5XaXRoUHJpb3JpdHk7XG5leHBvcnRzLnVuc3RhYmxlX3NjaGVkdWxlQ2FsbGJhY2sgPSB1bnN0YWJsZV9zY2hlZHVsZUNhbGxiYWNrO1xuZXhwb3J0cy51bnN0YWJsZV93cmFwQ2FsbGJhY2sgPSB1bnN0YWJsZV93cmFwQ2FsbGJhY2s7XG4gIH0pKCk7XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvc2NoZWR1bGVyLnByb2R1Y3Rpb24ubWluLmpzJyk7XG59IGVsc2Uge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3NjaGVkdWxlci5kZXZlbG9wbWVudC5qcycpO1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJykge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3NjaGVkdWxlci10cmFjaW5nLnByb2R1Y3Rpb24ubWluLmpzJyk7XG59IGVsc2Uge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3NjaGVkdWxlci10cmFjaW5nLmRldmVsb3BtZW50LmpzJyk7XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIGlzT2xkSUUgPSBmdW5jdGlvbiBpc09sZElFKCkge1xuICB2YXIgbWVtbztcbiAgcmV0dXJuIGZ1bmN0aW9uIG1lbW9yaXplKCkge1xuICAgIGlmICh0eXBlb2YgbWVtbyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIC8vIFRlc3QgZm9yIElFIDw9IDkgYXMgcHJvcG9zZWQgYnkgQnJvd3NlcmhhY2tzXG4gICAgICAvLyBAc2VlIGh0dHA6Ly9icm93c2VyaGFja3MuY29tLyNoYWNrLWU3MWQ4NjkyZjY1MzM0MTczZmVlNzE1YzIyMmNiODA1XG4gICAgICAvLyBUZXN0cyBmb3IgZXhpc3RlbmNlIG9mIHN0YW5kYXJkIGdsb2JhbHMgaXMgdG8gYWxsb3cgc3R5bGUtbG9hZGVyXG4gICAgICAvLyB0byBvcGVyYXRlIGNvcnJlY3RseSBpbnRvIG5vbi1zdGFuZGFyZCBlbnZpcm9ubWVudHNcbiAgICAgIC8vIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3dlYnBhY2stY29udHJpYi9zdHlsZS1sb2FkZXIvaXNzdWVzLzE3N1xuICAgICAgbWVtbyA9IEJvb2xlYW4od2luZG93ICYmIGRvY3VtZW50ICYmIGRvY3VtZW50LmFsbCAmJiAhd2luZG93LmF0b2IpO1xuICAgIH1cblxuICAgIHJldHVybiBtZW1vO1xuICB9O1xufSgpO1xuXG52YXIgZ2V0VGFyZ2V0ID0gZnVuY3Rpb24gZ2V0VGFyZ2V0KCkge1xuICB2YXIgbWVtbyA9IHt9O1xuICByZXR1cm4gZnVuY3Rpb24gbWVtb3JpemUodGFyZ2V0KSB7XG4gICAgaWYgKHR5cGVvZiBtZW1vW3RhcmdldF0gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB2YXIgc3R5bGVUYXJnZXQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHRhcmdldCk7IC8vIFNwZWNpYWwgY2FzZSB0byByZXR1cm4gaGVhZCBvZiBpZnJhbWUgaW5zdGVhZCBvZiBpZnJhbWUgaXRzZWxmXG5cbiAgICAgIGlmICh3aW5kb3cuSFRNTElGcmFtZUVsZW1lbnQgJiYgc3R5bGVUYXJnZXQgaW5zdGFuY2VvZiB3aW5kb3cuSFRNTElGcmFtZUVsZW1lbnQpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAvLyBUaGlzIHdpbGwgdGhyb3cgYW4gZXhjZXB0aW9uIGlmIGFjY2VzcyB0byBpZnJhbWUgaXMgYmxvY2tlZFxuICAgICAgICAgIC8vIGR1ZSB0byBjcm9zcy1vcmlnaW4gcmVzdHJpY3Rpb25zXG4gICAgICAgICAgc3R5bGVUYXJnZXQgPSBzdHlsZVRhcmdldC5jb250ZW50RG9jdW1lbnQuaGVhZDtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIC8vIGlzdGFuYnVsIGlnbm9yZSBuZXh0XG4gICAgICAgICAgc3R5bGVUYXJnZXQgPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIG1lbW9bdGFyZ2V0XSA9IHN0eWxlVGFyZ2V0O1xuICAgIH1cblxuICAgIHJldHVybiBtZW1vW3RhcmdldF07XG4gIH07XG59KCk7XG5cbnZhciBzdHlsZXNJbkRvbSA9IFtdO1xuXG5mdW5jdGlvbiBnZXRJbmRleEJ5SWRlbnRpZmllcihpZGVudGlmaWVyKSB7XG4gIHZhciByZXN1bHQgPSAtMTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0eWxlc0luRG9tLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKHN0eWxlc0luRG9tW2ldLmlkZW50aWZpZXIgPT09IGlkZW50aWZpZXIpIHtcbiAgICAgIHJlc3VsdCA9IGk7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBtb2R1bGVzVG9Eb20obGlzdCwgb3B0aW9ucykge1xuICB2YXIgaWRDb3VudE1hcCA9IHt9O1xuICB2YXIgaWRlbnRpZmllcnMgPSBbXTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgaXRlbSA9IGxpc3RbaV07XG4gICAgdmFyIGlkID0gb3B0aW9ucy5iYXNlID8gaXRlbVswXSArIG9wdGlvbnMuYmFzZSA6IGl0ZW1bMF07XG4gICAgdmFyIGNvdW50ID0gaWRDb3VudE1hcFtpZF0gfHwgMDtcbiAgICB2YXIgaWRlbnRpZmllciA9IFwiXCIuY29uY2F0KGlkLCBcIiBcIikuY29uY2F0KGNvdW50KTtcbiAgICBpZENvdW50TWFwW2lkXSA9IGNvdW50ICsgMTtcbiAgICB2YXIgaW5kZXggPSBnZXRJbmRleEJ5SWRlbnRpZmllcihpZGVudGlmaWVyKTtcbiAgICB2YXIgb2JqID0ge1xuICAgICAgY3NzOiBpdGVtWzFdLFxuICAgICAgbWVkaWE6IGl0ZW1bMl0sXG4gICAgICBzb3VyY2VNYXA6IGl0ZW1bM11cbiAgICB9O1xuXG4gICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgc3R5bGVzSW5Eb21baW5kZXhdLnJlZmVyZW5jZXMrKztcbiAgICAgIHN0eWxlc0luRG9tW2luZGV4XS51cGRhdGVyKG9iaik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0eWxlc0luRG9tLnB1c2goe1xuICAgICAgICBpZGVudGlmaWVyOiBpZGVudGlmaWVyLFxuICAgICAgICB1cGRhdGVyOiBhZGRTdHlsZShvYmosIG9wdGlvbnMpLFxuICAgICAgICByZWZlcmVuY2VzOiAxXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZGVudGlmaWVycy5wdXNoKGlkZW50aWZpZXIpO1xuICB9XG5cbiAgcmV0dXJuIGlkZW50aWZpZXJzO1xufVxuXG5mdW5jdGlvbiBpbnNlcnRTdHlsZUVsZW1lbnQob3B0aW9ucykge1xuICB2YXIgc3R5bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdHlsZScpO1xuICB2YXIgYXR0cmlidXRlcyA9IG9wdGlvbnMuYXR0cmlidXRlcyB8fCB7fTtcblxuICBpZiAodHlwZW9mIGF0dHJpYnV0ZXMubm9uY2UgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgdmFyIG5vbmNlID0gdHlwZW9mIF9fd2VicGFja19ub25jZV9fICE9PSAndW5kZWZpbmVkJyA/IF9fd2VicGFja19ub25jZV9fIDogbnVsbDtcblxuICAgIGlmIChub25jZSkge1xuICAgICAgYXR0cmlidXRlcy5ub25jZSA9IG5vbmNlO1xuICAgIH1cbiAgfVxuXG4gIE9iamVjdC5rZXlzKGF0dHJpYnV0ZXMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgIHN0eWxlLnNldEF0dHJpYnV0ZShrZXksIGF0dHJpYnV0ZXNba2V5XSk7XG4gIH0pO1xuXG4gIGlmICh0eXBlb2Ygb3B0aW9ucy5pbnNlcnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICBvcHRpb25zLmluc2VydChzdHlsZSk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIHRhcmdldCA9IGdldFRhcmdldChvcHRpb25zLmluc2VydCB8fCAnaGVhZCcpO1xuXG4gICAgaWYgKCF0YXJnZXQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvdWxkbid0IGZpbmQgYSBzdHlsZSB0YXJnZXQuIFRoaXMgcHJvYmFibHkgbWVhbnMgdGhhdCB0aGUgdmFsdWUgZm9yIHRoZSAnaW5zZXJ0JyBwYXJhbWV0ZXIgaXMgaW52YWxpZC5cIik7XG4gICAgfVxuXG4gICAgdGFyZ2V0LmFwcGVuZENoaWxkKHN0eWxlKTtcbiAgfVxuXG4gIHJldHVybiBzdHlsZTtcbn1cblxuZnVuY3Rpb24gcmVtb3ZlU3R5bGVFbGVtZW50KHN0eWxlKSB7XG4gIC8vIGlzdGFuYnVsIGlnbm9yZSBpZlxuICBpZiAoc3R5bGUucGFyZW50Tm9kZSA9PT0gbnVsbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHN0eWxlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc3R5bGUpO1xufVxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgICovXG5cblxudmFyIHJlcGxhY2VUZXh0ID0gZnVuY3Rpb24gcmVwbGFjZVRleHQoKSB7XG4gIHZhciB0ZXh0U3RvcmUgPSBbXTtcbiAgcmV0dXJuIGZ1bmN0aW9uIHJlcGxhY2UoaW5kZXgsIHJlcGxhY2VtZW50KSB7XG4gICAgdGV4dFN0b3JlW2luZGV4XSA9IHJlcGxhY2VtZW50O1xuICAgIHJldHVybiB0ZXh0U3RvcmUuZmlsdGVyKEJvb2xlYW4pLmpvaW4oJ1xcbicpO1xuICB9O1xufSgpO1xuXG5mdW5jdGlvbiBhcHBseVRvU2luZ2xldG9uVGFnKHN0eWxlLCBpbmRleCwgcmVtb3ZlLCBvYmopIHtcbiAgdmFyIGNzcyA9IHJlbW92ZSA/ICcnIDogb2JqLm1lZGlhID8gXCJAbWVkaWEgXCIuY29uY2F0KG9iai5tZWRpYSwgXCIge1wiKS5jb25jYXQob2JqLmNzcywgXCJ9XCIpIDogb2JqLmNzczsgLy8gRm9yIG9sZCBJRVxuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAgKi9cblxuICBpZiAoc3R5bGUuc3R5bGVTaGVldCkge1xuICAgIHN0eWxlLnN0eWxlU2hlZXQuY3NzVGV4dCA9IHJlcGxhY2VUZXh0KGluZGV4LCBjc3MpO1xuICB9IGVsc2Uge1xuICAgIHZhciBjc3NOb2RlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY3NzKTtcbiAgICB2YXIgY2hpbGROb2RlcyA9IHN0eWxlLmNoaWxkTm9kZXM7XG5cbiAgICBpZiAoY2hpbGROb2Rlc1tpbmRleF0pIHtcbiAgICAgIHN0eWxlLnJlbW92ZUNoaWxkKGNoaWxkTm9kZXNbaW5kZXhdKTtcbiAgICB9XG5cbiAgICBpZiAoY2hpbGROb2Rlcy5sZW5ndGgpIHtcbiAgICAgIHN0eWxlLmluc2VydEJlZm9yZShjc3NOb2RlLCBjaGlsZE5vZGVzW2luZGV4XSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0eWxlLmFwcGVuZENoaWxkKGNzc05vZGUpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBhcHBseVRvVGFnKHN0eWxlLCBvcHRpb25zLCBvYmopIHtcbiAgdmFyIGNzcyA9IG9iai5jc3M7XG4gIHZhciBtZWRpYSA9IG9iai5tZWRpYTtcbiAgdmFyIHNvdXJjZU1hcCA9IG9iai5zb3VyY2VNYXA7XG5cbiAgaWYgKG1lZGlhKSB7XG4gICAgc3R5bGUuc2V0QXR0cmlidXRlKCdtZWRpYScsIG1lZGlhKTtcbiAgfSBlbHNlIHtcbiAgICBzdHlsZS5yZW1vdmVBdHRyaWJ1dGUoJ21lZGlhJyk7XG4gIH1cblxuICBpZiAoc291cmNlTWFwICYmIHR5cGVvZiBidG9hICE9PSAndW5kZWZpbmVkJykge1xuICAgIGNzcyArPSBcIlxcbi8qIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsXCIuY29uY2F0KGJ0b2EodW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KEpTT04uc3RyaW5naWZ5KHNvdXJjZU1hcCkpKSksIFwiICovXCIpO1xuICB9IC8vIEZvciBvbGQgSUVcblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgICovXG5cblxuICBpZiAoc3R5bGUuc3R5bGVTaGVldCkge1xuICAgIHN0eWxlLnN0eWxlU2hlZXQuY3NzVGV4dCA9IGNzcztcbiAgfSBlbHNlIHtcbiAgICB3aGlsZSAoc3R5bGUuZmlyc3RDaGlsZCkge1xuICAgICAgc3R5bGUucmVtb3ZlQ2hpbGQoc3R5bGUuZmlyc3RDaGlsZCk7XG4gICAgfVxuXG4gICAgc3R5bGUuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY3NzKSk7XG4gIH1cbn1cblxudmFyIHNpbmdsZXRvbiA9IG51bGw7XG52YXIgc2luZ2xldG9uQ291bnRlciA9IDA7XG5cbmZ1bmN0aW9uIGFkZFN0eWxlKG9iaiwgb3B0aW9ucykge1xuICB2YXIgc3R5bGU7XG4gIHZhciB1cGRhdGU7XG4gIHZhciByZW1vdmU7XG5cbiAgaWYgKG9wdGlvbnMuc2luZ2xldG9uKSB7XG4gICAgdmFyIHN0eWxlSW5kZXggPSBzaW5nbGV0b25Db3VudGVyKys7XG4gICAgc3R5bGUgPSBzaW5nbGV0b24gfHwgKHNpbmdsZXRvbiA9IGluc2VydFN0eWxlRWxlbWVudChvcHRpb25zKSk7XG4gICAgdXBkYXRlID0gYXBwbHlUb1NpbmdsZXRvblRhZy5iaW5kKG51bGwsIHN0eWxlLCBzdHlsZUluZGV4LCBmYWxzZSk7XG4gICAgcmVtb3ZlID0gYXBwbHlUb1NpbmdsZXRvblRhZy5iaW5kKG51bGwsIHN0eWxlLCBzdHlsZUluZGV4LCB0cnVlKTtcbiAgfSBlbHNlIHtcbiAgICBzdHlsZSA9IGluc2VydFN0eWxlRWxlbWVudChvcHRpb25zKTtcbiAgICB1cGRhdGUgPSBhcHBseVRvVGFnLmJpbmQobnVsbCwgc3R5bGUsIG9wdGlvbnMpO1xuXG4gICAgcmVtb3ZlID0gZnVuY3Rpb24gcmVtb3ZlKCkge1xuICAgICAgcmVtb3ZlU3R5bGVFbGVtZW50KHN0eWxlKTtcbiAgICB9O1xuICB9XG5cbiAgdXBkYXRlKG9iaik7XG4gIHJldHVybiBmdW5jdGlvbiB1cGRhdGVTdHlsZShuZXdPYmopIHtcbiAgICBpZiAobmV3T2JqKSB7XG4gICAgICBpZiAobmV3T2JqLmNzcyA9PT0gb2JqLmNzcyAmJiBuZXdPYmoubWVkaWEgPT09IG9iai5tZWRpYSAmJiBuZXdPYmouc291cmNlTWFwID09PSBvYmouc291cmNlTWFwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdXBkYXRlKG9iaiA9IG5ld09iaik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlbW92ZSgpO1xuICAgIH1cbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAobGlzdCwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTsgLy8gRm9yY2Ugc2luZ2xlLXRhZyBzb2x1dGlvbiBvbiBJRTYtOSwgd2hpY2ggaGFzIGEgaGFyZCBsaW1pdCBvbiB0aGUgIyBvZiA8c3R5bGU+XG4gIC8vIHRhZ3MgaXQgd2lsbCBhbGxvdyBvbiBhIHBhZ2VcblxuICBpZiAoIW9wdGlvbnMuc2luZ2xldG9uICYmIHR5cGVvZiBvcHRpb25zLnNpbmdsZXRvbiAhPT0gJ2Jvb2xlYW4nKSB7XG4gICAgb3B0aW9ucy5zaW5nbGV0b24gPSBpc09sZElFKCk7XG4gIH1cblxuICBsaXN0ID0gbGlzdCB8fCBbXTtcbiAgdmFyIGxhc3RJZGVudGlmaWVycyA9IG1vZHVsZXNUb0RvbShsaXN0LCBvcHRpb25zKTtcbiAgcmV0dXJuIGZ1bmN0aW9uIHVwZGF0ZShuZXdMaXN0KSB7XG4gICAgbmV3TGlzdCA9IG5ld0xpc3QgfHwgW107XG5cbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG5ld0xpc3QpICE9PSAnW29iamVjdCBBcnJheV0nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsYXN0SWRlbnRpZmllcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBpZGVudGlmaWVyID0gbGFzdElkZW50aWZpZXJzW2ldO1xuICAgICAgdmFyIGluZGV4ID0gZ2V0SW5kZXhCeUlkZW50aWZpZXIoaWRlbnRpZmllcik7XG4gICAgICBzdHlsZXNJbkRvbVtpbmRleF0ucmVmZXJlbmNlcy0tO1xuICAgIH1cblxuICAgIHZhciBuZXdMYXN0SWRlbnRpZmllcnMgPSBtb2R1bGVzVG9Eb20obmV3TGlzdCwgb3B0aW9ucyk7XG5cbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgbGFzdElkZW50aWZpZXJzLmxlbmd0aDsgX2krKykge1xuICAgICAgdmFyIF9pZGVudGlmaWVyID0gbGFzdElkZW50aWZpZXJzW19pXTtcblxuICAgICAgdmFyIF9pbmRleCA9IGdldEluZGV4QnlJZGVudGlmaWVyKF9pZGVudGlmaWVyKTtcblxuICAgICAgaWYgKHN0eWxlc0luRG9tW19pbmRleF0ucmVmZXJlbmNlcyA9PT0gMCkge1xuICAgICAgICBzdHlsZXNJbkRvbVtfaW5kZXhdLnVwZGF0ZXIoKTtcblxuICAgICAgICBzdHlsZXNJbkRvbS5zcGxpY2UoX2luZGV4LCAxKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBsYXN0SWRlbnRpZmllcnMgPSBuZXdMYXN0SWRlbnRpZmllcnM7XG4gIH07XG59OyIsIid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcblxuZnVuY3Rpb24gdXNlQXN5bmNFZmZlY3QoZWZmZWN0LCBkZXN0cm95LCBpbnB1dHMpIHtcbiAgdmFyIGhhc0Rlc3Ryb3kgPSB0eXBlb2YgZGVzdHJveSA9PT0gJ2Z1bmN0aW9uJztcblxuICBSZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgIHZhciByZXN1bHQ7XG4gICAgdmFyIG1vdW50ZWQgPSB0cnVlO1xuICAgIHZhciBtYXliZVByb21pc2UgPSBlZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIG1vdW50ZWQ7XG4gICAgfSk7XG5cbiAgICBQcm9taXNlLnJlc29sdmUobWF5YmVQcm9taXNlKS50aGVuKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgcmVzdWx0ID0gdmFsdWU7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgbW91bnRlZCA9IGZhbHNlO1xuXG4gICAgICBpZiAoaGFzRGVzdHJveSkge1xuICAgICAgICBkZXN0cm95KHJlc3VsdCk7XG4gICAgICB9XG4gICAgfTtcbiAgfSwgaGFzRGVzdHJveSA/IGlucHV0cyA6IGRlc3Ryb3kpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHVzZUFzeW5jRWZmZWN0O1xubW9kdWxlLmV4cG9ydHMudXNlQXN5bmNFZmZlY3QgPSB1c2VBc3luY0VmZmVjdDtcbiIsInZhciBhcGkgPSByZXF1aXJlKFwiIS4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL2luamVjdFN0eWxlc0ludG9TdHlsZVRhZy5qc1wiKTtcbiAgICAgICAgICAgIHZhciBjb250ZW50ID0gcmVxdWlyZShcIiEhLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9janMuanM/P3J1bGVTZXRbMV0ucnVsZXNbMl0udXNlWzFdIS4uL25vZGVfbW9kdWxlcy9wb3N0Y3NzLWxvYWRlci9zcmMvaW5kZXguanM/P3J1bGVTZXRbMV0ucnVsZXNbMl0udXNlWzJdIS4vc3R5bGUuY3NzXCIpO1xuXG4gICAgICAgICAgICBjb250ZW50ID0gY29udGVudC5fX2VzTW9kdWxlID8gY29udGVudC5kZWZhdWx0IDogY29udGVudDtcblxuICAgICAgICAgICAgaWYgKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG4gICAgICAgICAgICB9XG5cbnZhciBvcHRpb25zID0ge307XG5cbm9wdGlvbnMuaW5zZXJ0ID0gXCJoZWFkXCI7XG5vcHRpb25zLnNpbmdsZXRvbiA9IGZhbHNlO1xuXG52YXIgdXBkYXRlID0gYXBpKGNvbnRlbnQsIG9wdGlvbnMpO1xuXG5cblxubW9kdWxlLmV4cG9ydHMgPSBjb250ZW50LmxvY2FscyB8fCB7fTsiLCIvKiAoaWdub3JlZCkgKi8iLCIvLyBUaGUgbW9kdWxlIGNhY2hlXG52YXIgX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fID0ge307XG5cbi8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG5mdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuXHR2YXIgY2FjaGVkTW9kdWxlID0gX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXTtcblx0aWYgKGNhY2hlZE1vZHVsZSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0cmV0dXJuIGNhY2hlZE1vZHVsZS5leHBvcnRzO1xuXHR9XG5cdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG5cdHZhciBtb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdID0ge1xuXHRcdGlkOiBtb2R1bGVJZCxcblx0XHQvLyBubyBtb2R1bGUubG9hZGVkIG5lZWRlZFxuXHRcdGV4cG9ydHM6IHt9XG5cdH07XG5cblx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG5cdF9fd2VicGFja19tb2R1bGVzX19bbW9kdWxlSWRdKG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG5cdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG5cdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbn1cblxuIiwiLy8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbl9fd2VicGFja19yZXF1aXJlX18ubiA9IChtb2R1bGUpID0+IHtcblx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG5cdFx0KCkgPT4gKG1vZHVsZVsnZGVmYXVsdCddKSA6XG5cdFx0KCkgPT4gKG1vZHVsZSk7XG5cdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsIHsgYTogZ2V0dGVyIH0pO1xuXHRyZXR1cm4gZ2V0dGVyO1xufTsiLCIvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9ucyBmb3IgaGFybW9ueSBleHBvcnRzXG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSAoZXhwb3J0cywgZGVmaW5pdGlvbikgPT4ge1xuXHRmb3IodmFyIGtleSBpbiBkZWZpbml0aW9uKSB7XG5cdFx0aWYoX193ZWJwYWNrX3JlcXVpcmVfXy5vKGRlZmluaXRpb24sIGtleSkgJiYgIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBrZXkpKSB7XG5cdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZGVmaW5pdGlvbltrZXldIH0pO1xuXHRcdH1cblx0fVxufTsiLCJfX3dlYnBhY2tfcmVxdWlyZV9fLmcgPSAoZnVuY3Rpb24oKSB7XG5cdGlmICh0eXBlb2YgZ2xvYmFsVGhpcyA9PT0gJ29iamVjdCcpIHJldHVybiBnbG9iYWxUaGlzO1xuXHR0cnkge1xuXHRcdHJldHVybiB0aGlzIHx8IG5ldyBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuXHR9IGNhdGNoIChlKSB7XG5cdFx0aWYgKHR5cGVvZiB3aW5kb3cgPT09ICdvYmplY3QnKSByZXR1cm4gd2luZG93O1xuXHR9XG59KSgpOyIsIl9fd2VicGFja19yZXF1aXJlX18ubyA9IChvYmosIHByb3ApID0+IChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKSkiLCIvLyBkZWZpbmUgX19lc01vZHVsZSBvbiBleHBvcnRzXG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIgPSAoZXhwb3J0cykgPT4ge1xuXHRpZih0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9TdHJpbmdUYWcpIHtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiAnTW9kdWxlJyB9KTtcblx0fVxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xufTsiLCJpbXBvcnQgcmFpbndheSwgeyBQZWVyU3RhdGUsIFJhaW53YXlDb25uZWN0aW9uIH0gZnJvbSBcIkByYWlud2F5L3dlYlwiO1xuaW1wb3J0IFJlYWN0LCB7IHVzZUVmZmVjdCwgdXNlUmVmLCB1c2VTdGF0ZSB9IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IFJlYWN0RE9NIGZyb20gXCJyZWFjdC1kb21cIjtcbmltcG9ydCBcIi4uL3N0eWxlLmNzc1wiO1xuaW1wb3J0IHVzZUFzeW5jRWZmZWN0IGZyb20gXCJ1c2UtYXN5bmMtZWZmZWN0XCI7XG5cbmNvbnN0IFF1aWNrRGVtbyA9ICgpID0+IHtcbiAgY29uc3QgW3J1bnRpbWUsIHNldFJ1bnRpbWVdID0gdXNlU3RhdGU8UmFpbndheUNvbm5lY3Rpb24+KCk7XG4gIGNvbnN0IFtlcnJvciwgc2V0RXJyb3JdID0gdXNlU3RhdGU8c3RyaW5nPihcIlwiKTtcbiAgdXNlQXN5bmNFZmZlY3QoYXN5bmMgKCkgPT4ge1xuICAgIHRyeSB7XG4gICAgICBsZXQgcnQgPSBhd2FpdCByYWlud2F5LmNvbm5lY3Qoe1xuICAgICAgICBhcGlLZXk6XG4gICAgICAgICAgbmV3IFVSTFNlYXJjaFBhcmFtcyh3aW5kb3cubG9jYXRpb24uc2VhcmNoKS5nZXQoXCJhcGlfa2V5XCIpID8/IFwiXCIsXG4gICAgICAgIGV4dGVybmFsSWQ6IFwid2ViLWRlbW8tcmVhY3RcIixcbiAgICAgIH0pO1xuXG4gICAgICBydC5hZGRFdmVudExpc3RlbmVyKFwiY2xvc2VcIiwgKGVycikgPT4ge1xuICAgICAgICAvLyBpZiB0aGUgcmFpbndheSBjb25uZWN0aW9uIGNsb3Nlcywgc29tZXRoaW5nIGlzIHdyb25nXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYExvc3QgY29ubmVjdGlvbiB0byBSYWlud2F5OiAke2Vycn1gKTtcbiAgICAgIH0pO1xuXG4gICAgICBydC5hZGRFdmVudExpc3RlbmVyKFwicGVlci1yZXF1ZXN0XCIsIGFzeW5jIChyZXEpID0+IHtcbiAgICAgICAgLy8gQWNjZXB0IGFsbCByZXF1ZXN0cyB0byBjb25uZWN0IHRvIHVzLCBzaW5jZSB3ZSdyZSBhIGRlbW8gYXBwXG4gICAgICAgIGNvbnN0IHBlZXIgPSBhd2FpdCByZXEuYWNjZXB0KCk7XG5cbiAgICAgICAgcGVlci5hZGRFdmVudExpc3RlbmVyKFwiY29ubmVjdGlvbi1zdGF0ZS1jaGFuZ2VcIiwgKHN0YXRlKSA9PiB7XG4gICAgICAgICAgLy8gbG9nIGFsbCBwZWVyIHN0YXRlIGNoYW5nZXNcbiAgICAgICAgICBjb25zb2xlLmxvZyhgUGVlciAke3BlZXIuaWR9IGNoYW5nZWQgc3RhdGUgdG8gJHtQZWVyU3RhdGVbc3RhdGVdfWApO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHNldEVycm9yKChlIGFzIEVycm9yKS5tZXNzYWdlKTtcbiAgICAgIGNvbnNvbGUubG9nKGUpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiAoXG4gICAgPG1haW4gY2xhc3NOYW1lPVwibS10LTggbS1sLTggbS1yLTggbS1iLThcIj5cbiAgICAgIHtlcnJvciA/IGVycm9yIDogcnVudGltZSA/IFwiQ29ubmVjdGVkLlwiIDogXCJDb25uZWN0aW5n4oCmXCJ9XG4gICAgPC9tYWluPlxuICApO1xufTtcblxuUmVhY3RET00ucmVuZGVyKFxuICA8UmVhY3QuU3RyaWN0TW9kZT5cbiAgICA8UXVpY2tEZW1vIC8+XG4gIDwvUmVhY3QuU3RyaWN0TW9kZT4sXG4gIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwicmVhY3Qtcm9vdFwiKSxcbik7XG4iXSwic291cmNlUm9vdCI6IiJ9